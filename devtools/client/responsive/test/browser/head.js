"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
redux
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
_loadPreferredDevices
}
=
require
(
"
devtools
/
client
/
responsive
/
actions
/
devices
"
)
;
const
{
getStr
}
=
require
(
"
devtools
/
client
/
responsive
/
utils
/
l10n
"
)
;
const
{
getTopLevelWindow
}
=
require
(
"
devtools
/
client
/
responsive
/
utils
/
window
"
)
;
const
{
addDevice
removeDevice
removeLocalDevices
}
=
require
(
"
devtools
/
client
/
shared
/
devices
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
asyncStorage
=
require
(
"
devtools
/
shared
/
async
-
storage
"
)
;
const
localTypes
=
require
(
"
devtools
/
client
/
responsive
/
types
"
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
devtools
/
client
/
responsive
/
manager
"
)
;
loader
.
lazyRequireGetter
(
this
"
message
"
"
devtools
/
client
/
responsive
/
utils
/
message
"
)
;
const
E10S_MULTI_ENABLED
=
Services
.
prefs
.
getIntPref
(
"
dom
.
ipc
.
processCount
"
)
>
1
;
const
TEST_URI_ROOT
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
responsive
/
test
/
browser
/
"
;
const
RELOAD_CONDITION_PREF_PREFIX
=
"
devtools
.
responsive
.
reloadConditions
.
"
;
const
DEFAULT_UA
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
.
userAgent
;
SimpleTest
.
requestCompleteLog
(
)
;
SimpleTest
.
waitForExplicitFinish
(
)
;
requestLongerTimeout
(
2
)
;
Services
.
prefs
.
setCharPref
(
"
devtools
.
devices
.
url
"
TEST_URI_ROOT
+
"
devices
.
json
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
responsive
.
reloadNotification
.
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
responsive
.
show
-
setting
-
tooltip
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
responsive
.
showUserAgentInput
"
true
)
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
devices
.
url
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
reloadNotification
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
html
.
displayedDeviceList
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
reloadConditions
.
touchSimulation
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
reloadConditions
.
userAgent
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
show
-
setting
-
tooltip
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
showUserAgentInput
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
touchSimulation
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
userAgent
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
viewport
.
height
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
viewport
.
pixelRatio
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
viewport
.
width
"
)
;
await
asyncStorage
.
removeItem
(
"
devtools
.
devices
.
url_cache
"
)
;
await
asyncStorage
.
removeItem
(
"
devtools
.
responsive
.
deviceState
"
)
;
await
removeLocalDevices
(
)
;
}
)
;
var
openRDM
=
async
function
(
tab
)
{
info
(
"
Opening
responsive
design
mode
"
)
;
const
manager
=
ResponsiveUIManager
;
const
ui
=
await
manager
.
openIfNeeded
(
tab
.
ownerGlobal
tab
{
trigger
:
"
test
"
}
)
;
info
(
"
Responsive
design
mode
opened
"
)
;
return
{
ui
manager
}
;
}
;
var
closeRDM
=
async
function
(
tab
options
)
{
info
(
"
Closing
responsive
design
mode
"
)
;
const
manager
=
ResponsiveUIManager
;
await
manager
.
closeIfNeeded
(
tab
.
ownerGlobal
tab
options
)
;
info
(
"
Responsive
design
mode
closed
"
)
;
}
;
function
addRDMTaskWithPreAndPost
(
url
preTask
task
postTask
options
)
{
let
onlyPrefAndTask
=
false
;
let
waitForDeviceList
=
false
;
if
(
typeof
options
=
=
"
object
"
)
{
onlyPrefAndTask
=
!
!
options
.
onlyPrefAndTask
;
waitForDeviceList
=
!
!
options
.
waitForDeviceList
;
}
add_task
(
async
function
(
)
{
let
tab
;
let
browser
;
let
preTaskValue
=
null
;
let
taskValue
=
null
;
let
ui
;
let
manager
;
if
(
!
onlyPrefAndTask
)
{
tab
=
await
addTab
(
url
)
;
browser
=
tab
.
linkedBrowser
;
if
(
preTask
)
{
preTaskValue
=
await
preTask
(
{
message
browser
}
)
;
}
const
rdmValues
=
await
openRDM
(
tab
)
;
ui
=
rdmValues
.
ui
;
manager
=
rdmValues
.
manager
;
await
waitForRDMLoaded
(
ui
{
waitForDeviceList
}
)
;
}
try
{
taskValue
=
await
task
(
{
ui
manager
message
browser
preTaskValue
}
)
;
}
catch
(
err
)
{
ok
(
false
"
Got
an
error
:
"
+
DevToolsUtils
.
safeErrorString
(
err
)
)
;
}
if
(
!
onlyPrefAndTask
)
{
await
closeRDM
(
tab
)
;
if
(
postTask
)
{
await
postTask
(
{
message
browser
preTaskValue
taskValue
}
)
;
}
await
removeTab
(
tab
)
;
}
await
SpecialPowers
.
flushPrefEnv
(
)
;
}
)
;
}
async
function
waitForRDMLoaded
(
ui
{
waitForDeviceList
}
)
{
await
message
.
wait
(
ui
.
toolWindow
"
post
-
init
"
)
;
const
{
store
}
=
ui
.
toolWindow
;
await
waitUntilState
(
store
state
=
>
state
.
viewports
.
length
=
=
1
)
;
if
(
waitForDeviceList
)
{
await
waitUntilState
(
store
state
=
>
state
.
devices
.
listState
=
=
localTypes
.
loadableState
.
LOADED
)
;
}
}
function
addRDMTask
(
rdmURL
rdmTask
options
)
{
addRDMTaskWithPreAndPost
(
rdmURL
undefined
rdmTask
undefined
options
)
;
}
async
function
spawnViewportTask
(
ui
args
task
)
{
const
result
=
await
ContentTask
.
spawn
(
ui
.
getViewportBrowser
(
)
args
task
)
;
await
promiseContentReflow
(
ui
)
;
return
result
;
}
function
waitForFrameLoad
(
ui
targetURL
)
{
return
spawnViewportTask
(
ui
{
targetURL
}
async
function
(
args
)
{
if
(
(
content
.
document
.
readyState
=
=
"
complete
"
|
|
content
.
document
.
readyState
=
=
"
interactive
"
)
&
&
content
.
location
.
href
=
=
args
.
targetURL
)
{
return
;
}
await
ContentTaskUtils
.
waitForEvent
(
this
"
DOMContentLoaded
"
)
;
}
)
;
}
function
waitForViewportResizeTo
(
ui
width
height
)
{
return
new
Promise
(
function
(
resolve
)
{
const
isSizeMatching
=
data
=
>
data
.
width
=
=
width
&
&
data
.
height
=
=
height
;
const
size
=
ui
.
getViewportSize
(
)
;
if
(
isSizeMatching
(
size
)
)
{
info
(
Viewport
already
resized
to
{
width
}
x
{
height
}
)
;
resolve
(
)
;
return
;
}
const
browser
=
ui
.
getViewportBrowser
(
)
;
const
onContentResize
=
data
=
>
{
if
(
!
isSizeMatching
(
data
)
)
{
return
;
}
ui
.
off
(
"
content
-
resize
"
onContentResize
)
;
browser
.
removeEventListener
(
"
mozbrowserloadend
"
onBrowserLoadEnd
)
;
info
(
Got
content
-
resize
to
{
width
}
x
{
height
}
)
;
resolve
(
)
;
}
;
const
onBrowserLoadEnd
=
async
function
(
)
{
const
data
=
ui
.
getViewportSize
(
ui
)
;
onContentResize
(
data
)
;
}
;
info
(
Waiting
for
viewport
-
resize
to
{
width
}
x
{
height
}
)
;
ui
.
on
(
"
content
-
resize
"
onContentResize
)
;
browser
.
addEventListener
(
"
mozbrowserloadend
"
onBrowserLoadEnd
{
once
:
true
}
)
;
}
)
;
}
var
setViewportSize
=
async
function
(
ui
manager
width
height
)
{
const
size
=
ui
.
getViewportSize
(
)
;
info
(
Current
size
:
{
size
.
width
}
x
{
size
.
height
}
+
set
to
:
{
width
}
x
{
height
}
)
;
if
(
size
.
width
!
=
width
|
|
size
.
height
!
=
height
)
{
const
resized
=
waitForViewportResizeTo
(
ui
width
height
)
;
ui
.
setViewportSize
(
{
width
height
}
)
;
await
resized
;
}
}
;
var
setViewportSizeAndAwaitReflow
=
async
function
(
ui
manager
width
height
)
{
await
setViewportSize
(
ui
manager
width
height
)
;
await
promiseContentReflow
(
ui
)
;
}
;
function
getViewportDevicePixelRatio
(
ui
)
{
return
SpecialPowers
.
spawn
(
ui
.
getViewportBrowser
(
)
[
]
async
function
(
)
{
return
content
.
devicePixelRatio
;
}
)
;
}
function
getElRect
(
selector
win
)
{
const
el
=
win
.
document
.
querySelector
(
selector
)
;
return
el
.
getBoundingClientRect
(
)
;
}
function
dragElementBy
(
selector
x
y
ui
)
{
const
browserWindow
=
ui
.
getBrowserWindow
(
)
;
const
rect
=
getElRect
(
selector
browserWindow
)
;
const
startPoint
=
{
clientX
:
Math
.
floor
(
rect
.
left
+
rect
.
width
/
2
)
clientY
:
Math
.
floor
(
rect
.
top
+
rect
.
height
/
2
)
}
;
const
endPoint
=
[
startPoint
.
clientX
+
x
startPoint
.
clientY
+
y
]
;
EventUtils
.
synthesizeMouseAtPoint
(
startPoint
.
clientX
startPoint
.
clientY
{
type
:
"
mousedown
"
}
browserWindow
)
;
EventUtils
.
synthesizeMouseAtPoint
(
.
.
.
endPoint
{
type
:
"
mousemove
"
}
browserWindow
)
;
EventUtils
.
synthesizeMouseAtPoint
(
.
.
.
endPoint
{
type
:
"
mouseup
"
}
browserWindow
)
;
return
rect
;
}
async
function
testViewportResize
(
ui
selector
moveBy
expectedHandleMove
)
{
const
resized
=
ui
.
once
(
"
viewport
-
resize
-
dragend
"
)
;
const
startRect
=
dragElementBy
(
selector
.
.
.
moveBy
ui
)
;
await
resized
;
const
endRect
=
getElRect
(
selector
ui
.
getBrowserWindow
(
)
)
;
is
(
endRect
.
left
-
startRect
.
left
expectedHandleMove
[
0
]
The
x
move
of
{
selector
}
is
as
expected
)
;
is
(
endRect
.
top
-
startRect
.
top
expectedHandleMove
[
1
]
The
y
move
of
{
selector
}
is
as
expected
)
;
}
async
function
openDeviceModal
(
ui
)
{
const
{
document
store
}
=
ui
.
toolWindow
;
info
(
"
Opening
device
modal
through
device
selector
.
"
)
;
const
onModalOpen
=
waitUntilState
(
store
state
=
>
state
.
devices
.
isModalOpen
)
;
await
selectMenuItem
(
ui
"
#
device
-
selector
"
getStr
(
"
responsive
.
editDeviceList2
"
)
)
;
await
onModalOpen
;
const
modal
=
document
.
getElementById
(
"
device
-
modal
-
wrapper
"
)
;
ok
(
modal
.
classList
.
contains
(
"
opened
"
)
&
&
!
modal
.
classList
.
contains
(
"
closed
"
)
"
The
device
modal
is
displayed
.
"
)
;
}
async
function
selectMenuItem
(
{
toolWindow
}
selector
value
)
{
const
{
document
}
=
toolWindow
;
const
button
=
document
.
querySelector
(
selector
)
;
isnot
(
button
null
Selector
"
{
selector
}
"
should
match
an
existing
element
.
)
;
info
(
Selecting
{
value
}
in
{
selector
}
.
)
;
await
testMenuItems
(
toolWindow
button
items
=
>
{
const
menuItem
=
findMenuItem
(
items
value
)
;
isnot
(
menuItem
undefined
Value
"
{
value
}
"
should
match
an
existing
menu
item
.
)
;
menuItem
.
click
(
)
;
}
)
;
}
async
function
testMenuItems
(
toolWindow
button
testFn
)
{
const
win
=
getTopLevelWindow
(
toolWindow
)
;
await
new
Promise
(
resolve
=
>
{
win
.
document
.
addEventListener
(
"
popupshown
"
async
(
)
=
>
{
if
(
button
.
id
=
=
=
"
device
-
selector
"
)
{
const
popup
=
toolWindow
.
document
.
querySelector
(
"
#
device
-
selector
-
menu
"
)
;
const
menuItems
=
[
.
.
.
popup
.
querySelectorAll
(
"
.
menuitem
>
.
command
"
)
]
;
testFn
(
menuItems
)
;
if
(
popup
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
{
button
.
click
(
)
;
await
waitUntil
(
(
)
=
>
!
popup
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
}
else
{
const
popup
=
win
.
document
.
querySelector
(
'
menupopup
[
menu
-
api
=
"
true
"
]
'
)
;
const
menuItems
=
[
.
.
.
popup
.
children
]
;
testFn
(
menuItems
)
;
popup
.
hidePopup
(
)
;
}
resolve
(
)
;
}
{
once
:
true
}
)
;
button
.
click
(
)
;
}
)
;
}
const
selectDevice
=
(
ui
value
)
=
>
Promise
.
all
(
[
once
(
ui
"
device
-
changed
"
)
selectMenuItem
(
ui
"
#
device
-
selector
"
value
)
]
)
;
const
selectDevicePixelRatio
=
(
ui
value
)
=
>
selectMenuItem
(
ui
"
#
device
-
pixel
-
ratio
-
menu
"
DPR
:
{
value
}
)
;
const
selectNetworkThrottling
=
(
ui
value
)
=
>
Promise
.
all
(
[
once
(
ui
"
network
-
throttling
-
changed
"
)
selectMenuItem
(
ui
"
#
network
-
throttling
-
menu
"
value
)
]
)
;
function
getSessionHistory
(
browser
)
{
if
(
Services
.
appinfo
.
sessionHistoryInParent
)
{
const
browsingContext
=
browser
.
browsingContext
;
const
uri
=
browsingContext
.
currentWindowGlobal
.
documentURI
.
displaySpec
;
const
history
=
browsingContext
.
sessionHistory
;
const
userContextId
=
browsingContext
.
originAttributes
.
userContextId
;
const
body
=
ContentTask
.
spawn
(
browser
browsingContext
function
(
browsingContext
)
{
const
docShell
=
browsingContext
.
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
return
docShell
.
document
.
body
;
}
)
;
const
{
SessionHistory
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
return
SessionHistory
.
collectFromParent
(
uri
body
history
userContextId
)
;
}
return
ContentTask
.
spawn
(
browser
null
function
(
)
{
const
{
SessionHistory
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
sessionstore
/
SessionHistory
.
jsm
"
)
;
return
SessionHistory
.
collect
(
docShell
)
;
}
)
;
}
function
getContentSize
(
ui
)
{
return
spawnViewportTask
(
ui
{
}
(
)
=
>
(
{
width
:
content
.
screen
.
width
height
:
content
.
screen
.
height
}
)
)
;
}
function
getViewportScroll
(
ui
)
{
return
spawnViewportTask
(
ui
{
}
(
)
=
>
(
{
x
:
content
.
scrollX
y
:
content
.
scrollY
}
)
)
;
}
async
function
waitForPageShow
(
browser
)
{
const
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
const
ui
=
ResponsiveUIManager
.
getResponsiveUIForTab
(
tab
)
;
if
(
ui
)
{
browser
=
ui
.
getViewportBrowser
(
)
;
}
info
(
"
Waiting
for
pageshow
from
"
+
(
ui
?
"
responsive
"
:
"
regular
"
)
+
"
browser
"
)
;
await
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
return
waitForTick
(
)
;
}
function
waitForViewportLoad
(
ui
)
{
return
BrowserTestUtils
.
waitForContentEvent
(
ui
.
getViewportBrowser
(
)
"
load
"
true
)
;
}
function
waitForViewportScroll
(
ui
)
{
return
BrowserTestUtils
.
waitForContentEvent
(
ui
.
getViewportBrowser
(
)
"
scroll
"
true
)
;
}
async
function
load
(
browser
url
)
{
const
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
null
false
)
;
BrowserTestUtils
.
loadURI
(
browser
url
)
;
await
loaded
;
}
function
back
(
browser
)
{
const
shown
=
waitForPageShow
(
browser
)
;
browser
.
goBack
(
)
;
return
shown
;
}
function
forward
(
browser
)
{
const
shown
=
waitForPageShow
(
browser
)
;
browser
.
goForward
(
)
;
return
shown
;
}
function
addDeviceForTest
(
device
)
{
info
(
Adding
Test
Device
"
{
device
.
name
}
"
to
the
list
.
)
;
addDevice
(
device
)
;
registerCleanupFunction
(
(
)
=
>
{
ok
(
removeDevice
(
device
)
Removed
Test
Device
"
{
device
.
name
}
"
from
the
list
.
)
;
}
)
;
}
async
function
waitForClientClose
(
ui
)
{
info
(
"
Waiting
for
RDM
devtools
client
to
close
"
)
;
await
ui
.
client
.
once
(
"
closed
"
)
;
info
(
"
RDM
'
s
devtools
client
is
now
closed
"
)
;
}
async
function
testDevicePixelRatio
(
ui
expected
)
{
const
dppx
=
await
getViewportDevicePixelRatio
(
ui
)
;
is
(
dppx
expected
devicePixelRatio
should
be
set
to
{
expected
}
)
;
}
async
function
testTouchEventsOverride
(
ui
expected
)
{
const
{
document
}
=
ui
.
toolWindow
;
const
touchButton
=
document
.
getElementById
(
"
touch
-
simulation
-
button
"
)
;
const
flag
=
await
ui
.
responsiveFront
.
getTouchEventsOverride
(
)
;
is
(
flag
=
=
=
"
enabled
"
expected
Touch
events
override
should
be
{
expected
?
"
enabled
"
:
"
disabled
"
}
)
;
is
(
touchButton
.
classList
.
contains
(
"
checked
"
)
expected
Touch
simulation
button
should
be
{
expected
?
"
"
:
"
in
"
}
active
.
)
;
}
function
testViewportDeviceMenuLabel
(
ui
expectedDeviceName
)
{
info
(
"
Test
viewport
'
s
device
select
label
"
)
;
const
button
=
ui
.
toolWindow
.
document
.
querySelector
(
"
#
device
-
selector
"
)
;
ok
(
button
.
textContent
.
includes
(
expectedDeviceName
)
Device
Select
value
{
button
.
textContent
}
should
be
:
{
expectedDeviceName
}
)
;
}
async
function
toggleTouchSimulation
(
ui
)
{
const
{
document
}
=
ui
.
toolWindow
;
const
touchButton
=
document
.
getElementById
(
"
touch
-
simulation
-
button
"
)
;
const
changed
=
once
(
ui
"
touch
-
simulation
-
changed
"
)
;
const
loaded
=
waitForViewportLoad
(
ui
)
;
touchButton
.
click
(
)
;
await
Promise
.
all
(
[
changed
loaded
]
)
;
}
async
function
testUserAgent
(
ui
expected
)
{
const
{
document
}
=
ui
.
toolWindow
;
const
userAgentInput
=
document
.
getElementById
(
"
user
-
agent
-
input
"
)
;
if
(
expected
=
=
=
DEFAULT_UA
)
{
is
(
userAgentInput
.
value
"
"
"
UA
input
should
be
empty
"
)
;
}
else
{
is
(
userAgentInput
.
value
expected
UA
input
should
be
set
to
{
expected
}
)
;
}
await
testUserAgentFromBrowser
(
ui
.
getViewportBrowser
(
)
expected
)
;
}
async
function
testUserAgentFromBrowser
(
browser
expected
)
{
const
ua
=
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
return
content
.
navigator
.
userAgent
;
}
)
;
is
(
ua
expected
UA
should
be
set
to
{
expected
}
)
;
}
function
testViewportDimensions
(
ui
w
h
)
{
const
viewport
=
ui
.
viewportElement
;
is
(
ui
.
toolWindow
.
getComputedStyle
(
viewport
)
.
getPropertyValue
(
"
width
"
)
{
w
}
px
Viewport
should
have
width
of
{
w
}
px
)
;
is
(
ui
.
toolWindow
.
getComputedStyle
(
viewport
)
.
getPropertyValue
(
"
height
"
)
{
h
}
px
Viewport
should
have
height
of
{
h
}
px
)
;
}
async
function
changeUserAgentInput
(
ui
value
)
{
const
{
Simulate
}
=
ui
.
toolWindow
.
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
test
-
utils
"
)
;
const
{
document
store
}
=
ui
.
toolWindow
;
const
userAgentInput
=
document
.
getElementById
(
"
user
-
agent
-
input
"
)
;
userAgentInput
.
value
=
value
;
Simulate
.
change
(
userAgentInput
)
;
const
userAgentChanged
=
waitUntilState
(
store
state
=
>
state
.
ui
.
userAgent
=
=
=
value
)
;
const
changed
=
once
(
ui
"
user
-
agent
-
changed
"
)
;
const
loaded
=
waitForViewportLoad
(
ui
)
;
Simulate
.
keyUp
(
userAgentInput
{
keyCode
:
KeyCodes
.
DOM_VK_RETURN
}
)
;
await
Promise
.
all
(
[
changed
loaded
userAgentChanged
]
)
;
}
function
addDeviceInModal
(
ui
device
)
{
const
{
Simulate
}
=
ui
.
toolWindow
.
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
test
-
utils
"
)
;
const
{
document
store
}
=
ui
.
toolWindow
;
const
nameInput
=
document
.
querySelector
(
"
#
device
-
form
-
name
input
"
)
;
const
[
widthInput
heightInput
]
=
document
.
querySelectorAll
(
"
#
device
-
form
-
size
input
"
)
;
const
pixelRatioInput
=
document
.
querySelector
(
"
#
device
-
form
-
pixel
-
ratio
input
"
)
;
const
userAgentInput
=
document
.
querySelector
(
"
#
device
-
form
-
user
-
agent
input
"
)
;
const
touchInput
=
document
.
querySelector
(
"
#
device
-
form
-
touch
input
"
)
;
nameInput
.
value
=
device
.
name
;
Simulate
.
change
(
nameInput
)
;
widthInput
.
value
=
device
.
width
;
Simulate
.
change
(
widthInput
)
;
Simulate
.
blur
(
widthInput
)
;
heightInput
.
value
=
device
.
height
;
Simulate
.
change
(
heightInput
)
;
Simulate
.
blur
(
heightInput
)
;
pixelRatioInput
.
value
=
device
.
pixelRatio
;
Simulate
.
change
(
pixelRatioInput
)
;
userAgentInput
.
value
=
device
.
userAgent
;
Simulate
.
change
(
userAgentInput
)
;
touchInput
.
checked
=
device
.
touch
;
Simulate
.
change
(
touchInput
)
;
const
existingCustomDevices
=
store
.
getState
(
)
.
devices
.
custom
.
length
;
const
adderSave
=
document
.
querySelector
(
"
#
device
-
form
-
save
"
)
;
const
saved
=
waitUntilState
(
store
state
=
>
state
.
devices
.
custom
.
length
=
=
existingCustomDevices
+
1
)
;
Simulate
.
click
(
adderSave
)
;
return
saved
;
}
async
function
editDeviceInModal
(
ui
device
newDevice
)
{
const
{
Simulate
}
=
ui
.
toolWindow
.
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
test
-
utils
"
)
;
const
{
document
store
}
=
ui
.
toolWindow
;
const
nameInput
=
document
.
querySelector
(
"
#
device
-
form
-
name
input
"
)
;
const
[
widthInput
heightInput
]
=
document
.
querySelectorAll
(
"
#
device
-
form
-
size
input
"
)
;
const
pixelRatioInput
=
document
.
querySelector
(
"
#
device
-
form
-
pixel
-
ratio
input
"
)
;
const
userAgentInput
=
document
.
querySelector
(
"
#
device
-
form
-
user
-
agent
input
"
)
;
const
touchInput
=
document
.
querySelector
(
"
#
device
-
form
-
touch
input
"
)
;
nameInput
.
value
=
newDevice
.
name
;
Simulate
.
change
(
nameInput
)
;
widthInput
.
value
=
newDevice
.
width
;
Simulate
.
change
(
widthInput
)
;
Simulate
.
blur
(
widthInput
)
;
heightInput
.
value
=
newDevice
.
height
;
Simulate
.
change
(
heightInput
)
;
Simulate
.
blur
(
heightInput
)
;
pixelRatioInput
.
value
=
newDevice
.
pixelRatio
;
Simulate
.
change
(
pixelRatioInput
)
;
userAgentInput
.
value
=
newDevice
.
userAgent
;
Simulate
.
change
(
userAgentInput
)
;
touchInput
.
checked
=
newDevice
.
touch
;
Simulate
.
change
(
touchInput
)
;
const
existingCustomDevices
=
store
.
getState
(
)
.
devices
.
custom
.
length
;
const
formSave
=
document
.
querySelector
(
"
#
device
-
form
-
save
"
)
;
const
saved
=
waitUntilState
(
store
state
=
>
state
.
devices
.
custom
.
length
=
=
existingCustomDevices
&
&
state
.
devices
.
custom
.
find
(
(
{
name
}
)
=
>
name
=
=
newDevice
.
name
)
&
&
!
state
.
devices
.
custom
.
find
(
(
{
name
}
)
=
>
name
=
=
device
.
name
)
)
;
const
onDeviceChanged
=
ui
.
once
(
"
device
-
changed
"
)
;
Simulate
.
click
(
formSave
)
;
await
onDeviceChanged
;
return
saved
;
}
function
findMenuItem
(
menuItems
name
)
{
return
menuItems
.
find
(
menuItem
=
>
menuItem
.
textContent
.
includes
(
name
)
)
;
}
function
reloadOnUAChange
(
enabled
)
{
const
pref
=
RELOAD_CONDITION_PREF_PREFIX
+
"
userAgent
"
;
Services
.
prefs
.
setBoolPref
(
pref
enabled
)
;
}
function
reloadOnTouchChange
(
enabled
)
{
const
pref
=
RELOAD_CONDITION_PREF_PREFIX
+
"
touchSimulation
"
;
Services
.
prefs
.
setBoolPref
(
pref
enabled
)
;
}
function
rotateViewport
(
ui
)
{
const
{
document
}
=
ui
.
toolWindow
;
const
rotateButton
=
document
.
getElementById
(
"
rotate
-
button
"
)
;
rotateButton
.
click
(
)
;
}
async
function
setTouchAndMetaViewportSupport
(
ui
value
)
{
const
reloadNeeded
=
await
ui
.
updateTouchSimulation
(
value
)
;
if
(
reloadNeeded
)
{
info
(
"
Reload
is
needed
-
-
waiting
for
it
.
"
)
;
const
reload
=
waitForViewportLoad
(
ui
)
;
const
browser
=
ui
.
getViewportBrowser
(
)
;
browser
.
reload
(
)
;
await
reload
;
await
promiseContentReflow
(
ui
)
;
}
return
reloadNeeded
;
}
async
function
testViewportZoomWidthAndHeight
(
msg
ui
zoom
width
height
)
{
if
(
typeof
zoom
!
=
=
"
undefined
"
)
{
const
resolution
=
await
spawnViewportTask
(
ui
{
}
function
(
)
{
return
content
.
windowUtils
.
getResolution
(
)
;
}
)
;
is
(
resolution
zoom
msg
+
"
should
have
expected
zoom
.
"
)
;
}
if
(
typeof
width
!
=
=
"
undefined
"
|
|
typeof
height
!
=
=
"
undefined
"
)
{
const
innerSize
=
await
spawnViewportTask
(
ui
{
}
function
(
)
{
return
{
width
:
content
.
innerWidth
height
:
content
.
innerHeight
}
;
}
)
;
if
(
typeof
width
!
=
=
"
undefined
"
)
{
is
(
innerSize
.
width
width
msg
+
"
should
have
expected
inner
width
.
"
)
;
}
if
(
typeof
height
!
=
=
"
undefined
"
)
{
is
(
innerSize
.
height
height
msg
+
"
should
have
expected
inner
height
.
"
)
;
}
}
}
function
promiseContentReflow
(
ui
)
{
return
SpecialPowers
.
spawn
(
ui
.
getViewportBrowser
(
)
[
]
async
function
(
)
{
return
new
Promise
(
resolve
=
>
{
content
.
window
.
requestAnimationFrame
(
(
)
=
>
{
content
.
window
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
)
;
}
)
;
}
async
function
promiseRDMZoom
(
ui
browser
zoom
)
{
const
currentZoom
=
ZoomManager
.
getZoomForBrowser
(
browser
)
;
if
(
currentZoom
.
toFixed
(
2
)
=
=
zoom
.
toFixed
(
2
)
)
{
return
;
}
const
width
=
browser
.
getBoundingClientRect
(
)
.
width
;
ZoomManager
.
setZoomForBrowser
(
browser
zoom
)
;
await
BrowserTestUtils
.
waitForCondition
(
function
(
)
{
return
browser
.
getBoundingClientRect
(
)
.
width
!
=
width
;
}
)
;
}
async
function
waitForDeviceAndViewportState
(
ui
)
{
const
{
store
}
=
ui
.
toolWindow
;
await
waitUntilState
(
store
state
=
>
state
.
viewports
.
length
=
=
1
&
&
state
.
devices
.
listState
=
=
localTypes
.
loadableState
.
LOADED
)
;
}
function
waitForDevicePixelRatio
(
ui
expected
)
{
return
SpecialPowers
.
spawn
(
ui
.
getViewportBrowser
(
)
[
{
expected
}
]
function
(
args
)
{
const
initial
=
content
.
devicePixelRatio
;
info
(
Listening
for
pixel
ratio
change
+
(
current
:
{
initial
}
expected
:
{
args
.
expected
}
)
)
;
return
new
Promise
(
resolve
=
>
{
const
mql
=
content
.
matchMedia
(
(
resolution
:
{
args
.
expected
}
dppx
)
)
;
if
(
mql
.
matches
)
{
info
(
Ratio
already
changed
to
{
args
.
expected
}
dppx
)
;
resolve
(
content
.
devicePixelRatio
)
;
return
;
}
mql
.
addListener
(
function
listener
(
)
{
info
(
Ratio
changed
to
{
args
.
expected
}
dppx
)
;
mql
.
removeListener
(
listener
)
;
resolve
(
content
.
devicePixelRatio
)
;
}
)
;
}
)
;
}
)
;
}
async
function
navigateToNewDomain
(
uri
ui
)
{
const
target
=
ui
.
currentTarget
;
await
load
(
ui
.
getViewportBrowser
(
)
uri
)
;
await
waitUntil
(
(
)
=
>
ui
.
currentTarget
!
=
=
target
)
;
}
