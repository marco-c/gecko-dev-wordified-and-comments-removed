"
use
strict
"
;
info
(
"
-
-
-
Starting
viewport
test
output
-
-
-
"
)
;
const
WIDTH
=
200
;
const
HEIGHT
=
200
;
const
INITIAL_CONTENT
=
"
width
=
800
initial
-
scale
=
1
"
;
const
INITIAL_RES_TARGET
=
1
.
0
;
const
TESTS
=
[
{
content
:
INITIAL_CONTENT
res_target
:
INITIAL_RES_TARGET
}
{
content
:
"
width
=
200
"
res_target
:
0
.
5
}
{
content
:
"
width
=
400
"
res_target
:
0
.
5
}
{
content
:
"
width
=
500
"
res_target
:
0
.
4
}
{
content
:
"
width
=
200
user
-
scalable
=
no
"
res_target
:
1
.
0
}
{
content
:
"
width
=
400
user
-
scalable
=
no
"
res_target
:
0
.
5
}
{
content
:
"
width
=
500
user
-
scalable
=
no
"
res_target
:
0
.
4
}
{
content
:
"
width
=
200
initial
-
scale
=
1
"
res_target
:
4
.
0
res_chrome
:
1
.
0
}
{
content
:
"
width
=
400
initial
-
scale
=
1
"
res_target
:
2
.
0
res_chrome
:
1
.
0
}
{
content
:
"
width
=
500
initial
-
scale
=
1
"
res_target
:
1
.
6
res_chrome
:
1
.
0
}
{
content
:
"
width
=
200
initial
-
scale
=
1
user
-
scalable
=
no
"
res_target
:
1
.
0
}
{
content
:
"
width
=
400
initial
-
scale
=
1
user
-
scalable
=
no
"
res_target
:
1
.
0
}
{
content
:
"
width
=
500
initial
-
scale
=
1
user
-
scalable
=
no
"
res_target
:
1
.
0
}
]
;
const
TEST_URL
=
data
:
text
/
html
;
charset
=
utf
-
8
<
html
>
<
head
>
<
meta
name
=
"
viewport
"
content
=
"
{
INITIAL_CONTENT
}
"
>
<
/
head
>
<
body
style
=
"
margin
:
0
"
>
<
div
id
=
"
box
"
style
=
"
width
:
400px
;
height
:
400px
;
background
-
color
:
green
"
>
Initial
<
/
div
>
<
/
body
>
<
/
html
>
;
addRDMTask
(
TEST_URL
async
function
(
{
ui
manager
browser
}
)
{
await
setViewportSize
(
ui
manager
WIDTH
HEIGHT
)
;
await
setTouchAndMetaViewportSupport
(
ui
true
)
;
const
initial_resolution
=
await
spawnViewportTask
(
ui
{
}
(
)
=
>
{
return
content
.
windowUtils
.
getResolution
(
)
;
}
)
;
is
(
initial_resolution
.
toFixed
(
2
)
INITIAL_RES_TARGET
.
toFixed
(
2
)
Initial
resolution
is
as
expected
.
)
;
for
(
const
test
of
TESTS
)
{
const
{
content
:
content
res_target
res_chrome
}
=
test
;
await
spawnViewportTask
(
ui
{
content
}
args
=
>
{
const
box
=
content
.
document
.
getElementById
(
"
box
"
)
;
box
.
textContent
=
args
.
content
;
const
meta
=
content
.
document
.
getElementsByTagName
(
"
meta
"
)
[
0
]
;
info
(
Changing
meta
viewport
content
to
"
{
args
.
content
}
"
.
)
;
meta
.
content
=
args
.
content
;
}
)
;
await
promiseContentReflow
(
ui
)
;
const
resolution
=
await
spawnViewportTask
(
ui
{
}
(
)
=
>
{
return
content
.
windowUtils
.
getResolution
(
)
;
}
)
;
is
(
resolution
.
toFixed
(
2
)
res_target
.
toFixed
(
2
)
Replaced
meta
viewport
content
"
{
content
}
"
resolution
is
as
expected
.
)
;
if
(
typeof
res_chrome
!
=
=
"
undefined
"
)
{
todo_is
(
resolution
.
toFixed
(
2
)
res_chrome
.
toFixed
(
2
)
Replaced
meta
viewport
content
"
{
content
}
"
resolution
matches
Chrome
resolution
.
)
;
}
info
(
"
Reload
and
wait
for
document
to
be
loaded
to
prepare
for
next
test
.
"
)
;
const
{
onResource
:
onDomComplete
}
=
await
ui
.
commands
.
resourceCommand
.
waitForNextResource
(
ui
.
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
ignoreExistingResources
:
true
predicate
:
resource
=
>
resource
.
targetFront
.
isTopLevel
&
&
resource
.
name
=
=
=
"
dom
-
complete
"
}
)
;
browser
.
reload
(
)
;
await
onDomComplete
;
}
}
)
;
