"
use
strict
"
;
info
(
"
-
-
-
Starting
viewport
test
output
-
-
-
"
)
;
info
(
*
*
*
WARNING
*
*
*
This
test
will
move
the
mouse
pointer
to
simulate
native
mouse
clicks
.
Do
not
move
the
mouse
during
this
test
or
you
may
cause
intermittent
failures
.
)
;
requestLongerTimeout
(
4
)
;
const
VIEWPORT_DIMENSION
=
200
;
const
META_VIEWPORT_CONTENTS
=
[
"
width
=
device
-
width
"
"
width
=
400
"
]
;
const
DPRS
=
[
1
2
3
]
;
const
URL_ROOT_2
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
const
IFRAME_PATHS
=
[
{
URL_ROOT
}
{
URL_ROOT_2
}
]
;
const
TESTS
=
[
{
description
:
"
untranslated
iframe
"
style
:
{
}
}
{
description
:
"
translated
50
%
iframe
"
style
:
{
position
:
"
absolute
"
left
:
"
50
%
"
top
:
"
50
%
"
transform
:
"
translate
(
-
50
%
-
50
%
)
"
}
}
{
description
:
"
translated
100
%
iframe
"
style
:
{
position
:
"
absolute
"
left
:
"
100
%
"
top
:
"
100
%
"
transform
:
"
translate
(
-
100
%
-
100
%
)
"
}
}
]
;
let
testID
=
0
;
for
(
const
mvcontent
of
META_VIEWPORT_CONTENTS
)
{
info
(
Starting
test
series
with
meta
viewport
content
"
{
mvcontent
}
"
.
)
;
const
TEST_URL
=
data
:
text
/
html
;
charset
=
utf
-
8
+
<
html
>
<
meta
name
=
"
viewport
"
content
=
"
{
mvcontent
}
"
>
+
<
body
style
=
"
margin
:
0
;
width
:
100
%
;
height
:
200
%
;
"
>
+
<
iframe
id
=
"
host
"
+
style
=
"
margin
:
0
;
border
:
0
;
width
:
100
%
;
height
:
100
%
"
>
<
/
iframe
>
+
<
/
body
>
<
/
html
>
;
addRDMTask
(
TEST_URL
async
function
(
{
ui
manager
browser
}
)
{
await
setViewportSize
(
ui
manager
VIEWPORT_DIMENSION
VIEWPORT_DIMENSION
)
;
await
setTouchAndMetaViewportSupport
(
ui
true
)
;
const
screenToWindowX
=
window
.
mozInnerScreenX
;
const
screenToWindowY
=
window
.
mozInnerScreenY
;
for
(
const
dpr
of
DPRS
)
{
await
selectDevicePixelRatio
(
ui
dpr
)
;
for
(
const
path
of
IFRAME_PATHS
)
{
for
(
const
test
of
TESTS
)
{
const
{
description
style
}
=
test
;
const
title
=
ID
{
testID
}
-
{
description
}
with
DPR
{
dpr
}
and
path
{
path
}
;
info
(
Starting
test
{
title
}
.
)
;
await
spawnViewportTask
(
ui
{
title
style
path
VIEWPORT_DIMENSION
screenToWindowX
screenToWindowY
}
async
args
=
>
{
const
oneMatchingMessageWithTimeout
=
(
win
prop
timeout
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
ourTimeoutID
=
0
;
const
ourListener
=
win
.
addEventListener
(
"
message
"
e
=
>
{
if
(
typeof
e
.
data
[
prop
]
!
=
=
"
undefined
"
)
{
if
(
ourTimeoutID
)
{
win
.
clearTimeout
(
ourTimeoutID
)
;
}
win
.
removeEventListener
(
"
message
"
ourListener
)
;
resolve
(
e
.
data
)
;
}
}
)
;
if
(
timeout
)
{
ourTimeoutID
=
win
.
setTimeout
(
(
)
=
>
{
win
.
removeEventListener
(
"
message
"
ourListener
)
;
reject
(
Timeout
waiting
for
message
with
prop
{
prop
}
after
{
timeout
}
ms
.
)
;
}
timeout
)
;
}
}
)
;
}
;
function
isfuzzy
(
actual
expected
epsilon
msg
)
{
if
(
actual
>
=
expected
-
epsilon
&
&
actual
<
=
expected
+
epsilon
)
{
ok
(
true
msg
)
;
}
else
{
is
(
actual
expected
msg
)
;
}
}
function
synthesizeNativeMouseClick
(
win
screenX
screenY
)
{
const
utils
=
win
.
windowUtils
;
const
scale
=
win
.
devicePixelRatio
;
return
new
Promise
(
resolve
=
>
{
utils
.
sendNativeMouseEvent
(
screenX
*
scale
screenY
*
scale
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_DOWN
0
0
win
.
document
.
documentElement
(
)
=
>
{
utils
.
sendNativeMouseEvent
(
screenX
*
scale
screenY
*
scale
utils
.
NATIVE_MOUSE_MESSAGE_BUTTON_UP
0
0
win
.
document
.
documentElement
resolve
)
;
}
)
;
}
)
;
}
const
host
=
content
.
document
.
getElementById
(
"
host
"
)
;
for
(
const
prop
in
args
.
style
)
{
info
(
Setting
style
.
{
prop
}
to
{
args
.
style
[
prop
]
}
.
)
;
host
.
style
[
prop
]
=
args
.
style
[
prop
]
;
}
const
IFRAME_URL
=
args
.
path
+
"
touch_event_target
.
html
"
;
const
READY_TIMEOUT_MS
=
5000
;
const
iframeReady
=
oneMatchingMessageWithTimeout
(
content
"
ready
"
READY_TIMEOUT_MS
)
;
host
.
src
=
IFRAME_URL
;
try
{
await
iframeReady
;
}
catch
(
error
)
{
ok
(
false
{
args
.
title
}
{
error
}
)
;
return
;
}
info
(
iframe
has
finished
loading
.
)
;
await
new
Promise
(
resolve
=
>
{
content
.
requestAnimationFrame
(
(
)
=
>
{
content
.
requestAnimationFrame
(
resolve
)
;
}
)
;
}
)
;
const
hostBounds
=
host
.
getBoxQuadsFromWindowOrigin
(
)
[
0
]
.
getBounds
(
)
;
const
windowToHostX
=
hostBounds
.
left
;
const
windowToHostY
=
hostBounds
.
top
;
const
screenToHostX
=
args
.
screenToWindowX
+
windowToHostX
;
const
screenToHostY
=
args
.
screenToWindowY
+
windowToHostY
;
const
quadrantOffsetDoc
=
hostBounds
.
width
*
0
.
25
;
const
hostUpperLeftQuadrantDocX
=
quadrantOffsetDoc
;
const
hostUpperLeftQuadrantDocY
=
quadrantOffsetDoc
;
const
quadrantOffsetViewport
=
args
.
VIEWPORT_DIMENSION
*
0
.
25
;
const
hostUpperLeftQuadrantViewportX
=
quadrantOffsetViewport
;
const
hostUpperLeftQuadrantViewportY
=
quadrantOffsetViewport
;
const
targetX
=
screenToHostX
+
hostUpperLeftQuadrantViewportX
;
const
targetY
=
screenToHostY
+
hostUpperLeftQuadrantViewportY
;
const
CLICK_TIMEOUT_MS
=
1000
;
const
CLICK_ATTEMPTS
=
3
;
let
eventWasReceived
=
false
;
for
(
let
attempt
=
0
;
attempt
<
CLICK_ATTEMPTS
;
attempt
+
+
)
{
const
gotXAndY
=
oneMatchingMessageWithTimeout
(
content
"
x
"
CLICK_TIMEOUT_MS
)
;
info
(
Sending
native
mousedown
and
mouseup
to
screen
position
{
targetX
}
{
targetY
}
(
attempt
{
attempt
}
)
.
)
;
await
synthesizeNativeMouseClick
(
content
targetX
targetY
)
;
try
{
const
{
x
y
screenX
screenY
}
=
await
gotXAndY
;
eventWasReceived
=
true
;
isfuzzy
(
x
hostUpperLeftQuadrantDocX
1
{
args
.
title
}
got
click
at
close
enough
X
{
x
}
screen
is
{
screenX
}
.
)
;
isfuzzy
(
y
hostUpperLeftQuadrantDocY
1
{
args
.
title
}
got
click
at
close
enough
Y
{
y
}
screen
is
{
screenY
}
.
)
;
break
;
}
catch
(
error
)
{
}
}
if
(
!
eventWasReceived
)
{
ok
(
false
{
args
.
title
}
failed
to
get
a
click
after
{
CLICK_ATTEMPTS
}
tries
.
)
;
}
}
)
;
testID
+
+
;
}
}
}
}
)
;
}
