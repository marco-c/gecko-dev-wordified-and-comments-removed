"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
BrowserElementWebNavigation
}
=
require
(
"
.
/
web
-
navigation
"
)
;
const
{
getStack
}
=
require
(
"
devtools
/
shared
/
platform
/
stack
"
)
;
const
FRAME_LOADER
=
Symbol
(
"
devtools
/
responsive
/
frame
-
loader
"
)
;
exports
.
OUTER_FRAME_LOADER_SYMBOL
=
FRAME_LOADER
;
function
debug
(
msg
)
{
}
const
SWAPPED_BROWSER_STATE
=
[
"
_remoteFinder
"
"
_securityUI
"
"
_documentURI
"
"
_documentContentType
"
"
_contentTitle
"
"
_characterSet
"
"
_contentPrincipal
"
"
_imageDocument
"
"
_isSyntheticDocument
"
"
_innerWindowID
"
]
;
const
PROPERTIES_FROM_BROWSER_WINDOW
=
[
"
PopupNotifications
"
"
gBrowser
"
]
;
function
tunnelToInnerBrowser
(
outer
inner
)
{
let
browserWindow
=
outer
.
ownerDocument
.
defaultView
;
let
gBrowser
=
browserWindow
.
gBrowser
;
let
mmTunnel
;
const
mirroringProgressListener
=
{
onStateChange
:
(
webProgress
request
stateFlags
status
)
=
>
{
if
(
webProgress
&
&
webProgress
.
isTopLevel
)
{
inner
.
_characterSet
=
outer
.
_characterSet
;
inner
.
_documentURI
=
outer
.
_documentURI
;
inner
.
_documentContentType
=
outer
.
_documentContentType
;
}
}
onLocationChange
:
(
webProgress
request
location
flags
)
=
>
{
if
(
webProgress
&
&
webProgress
.
isTopLevel
)
{
inner
.
_documentURI
=
outer
.
_documentURI
;
inner
.
_documentContentType
=
outer
.
_documentContentType
;
inner
.
_contentTitle
=
outer
.
_contentTitle
;
inner
.
_characterSet
=
outer
.
_characterSet
;
inner
.
_contentPrincipal
=
outer
.
_contentPrincipal
;
inner
.
_imageDocument
=
outer
.
_imageDocument
;
inner
.
_isSyntheticDocument
=
outer
.
_isSyntheticDocument
;
inner
.
_innerWindowID
=
outer
.
_innerWindowID
;
inner
.
_remoteWebNavigation
.
_currentURI
=
outer
.
_remoteWebNavigation
.
_currentURI
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsISupportsWeakReference
Ci
.
nsIWebProgressListener
]
)
}
;
return
{
async
start
(
)
{
if
(
outer
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
outer
browser
must
be
non
-
remote
.
"
)
;
}
if
(
!
inner
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
inner
browser
must
be
remote
.
"
)
;
}
outer
[
FRAME_LOADER
]
=
outer
.
frameLoader
;
Object
.
defineProperty
(
outer
"
frameLoader
"
{
get
(
)
{
const
stack
=
getStack
(
)
;
if
(
stack
.
caller
.
filename
.
endsWith
(
"
SessionStore
.
jsm
"
)
)
{
return
outer
[
FRAME_LOADER
]
;
}
return
inner
.
frameLoader
;
}
configurable
:
true
enumerable
:
true
}
)
;
Object
.
defineProperty
(
outer
"
outerWindowID
"
{
get
(
)
{
return
inner
.
outerWindowID
;
}
configurable
:
true
enumerable
:
true
}
)
;
debug
(
"
Copy
inner
permanentKey
to
outer
browser
"
)
;
outer
.
permanentKey
=
inner
.
permanentKey
;
mmTunnel
=
new
MessageManagerTunnel
(
outer
inner
)
;
outer
.
destroy
(
)
;
outer
.
setAttribute
(
"
remote
"
"
true
"
)
;
outer
.
construct
(
)
;
Object
.
defineProperty
(
outer
"
remoteType
"
{
get
(
)
{
return
inner
.
remoteType
;
}
configurable
:
true
enumerable
:
true
}
)
;
if
(
!
outer
.
isRemoteBrowser
)
{
throw
new
Error
(
"
Browser
failed
to
switch
to
remote
browser
binding
"
)
;
}
const
webNavigation
=
new
BrowserElementWebNavigation
(
inner
)
;
webNavigation
.
copyStateFrom
(
inner
.
_remoteWebNavigation
)
;
outer
.
_remoteWebNavigation
=
webNavigation
;
const
tab
=
gBrowser
.
getTabForBrowser
(
outer
)
;
const
filteredProgressListener
=
gBrowser
.
_tabFilters
.
get
(
tab
)
;
outer
.
webProgress
.
addProgressListener
(
filteredProgressListener
Ci
.
nsIWebProgress
.
NOTIFY_ALL
)
;
outer
.
webProgress
.
addProgressListener
(
mirroringProgressListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_ALL
|
Ci
.
nsIWebProgress
.
NOTIFY_LOCATION
)
;
gBrowser
.
_tabForBrowser
.
set
(
inner
tab
)
;
for
(
const
property
of
SWAPPED_BROWSER_STATE
)
{
outer
[
property
]
=
inner
[
property
]
;
}
for
(
const
property
of
PROPERTIES_FROM_BROWSER_WINDOW
)
{
Object
.
defineProperty
(
inner
.
ownerGlobal
property
{
get
(
)
{
return
outer
.
ownerGlobal
[
property
]
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
inner
.
addEventListener
(
"
mozbrowseropenwindow
"
this
)
;
inner
.
addEventListener
(
"
mozbrowsershowmodalprompt
"
this
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
mozbrowseropenwindow
"
:
this
.
handleOpenWindowEvent
(
event
)
;
break
;
case
"
mozbrowsershowmodalprompt
"
:
this
.
handleModalPromptEvent
(
event
)
;
break
;
}
}
handleOpenWindowEvent
(
event
)
{
const
{
detail
}
=
event
;
event
.
preventDefault
(
)
;
const
uri
=
Services
.
io
.
newURI
(
detail
.
url
)
;
let
flags
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEWTAB
;
if
(
detail
.
forceNoReferrer
)
{
flags
|
=
Ci
.
nsIBrowserDOMWindow
.
OPEN_NO_REFERRER
;
}
browserWindow
.
browserDOMWindow
.
openURI
(
uri
null
flags
Ci
.
nsIBrowserDOMWindow
.
OPEN_NEW
outer
.
contentPrincipal
)
;
}
handleModalPromptEvent
(
{
detail
}
)
{
if
(
!
[
"
alert
"
"
prompt
"
"
confirm
"
]
.
includes
(
detail
.
promptType
)
)
{
return
;
}
const
promptFunction
=
outer
.
contentWindow
[
detail
.
promptType
]
;
detail
.
returnValue
=
promptFunction
(
detail
.
message
detail
.
initialValue
)
;
}
stop
(
)
{
const
tab
=
gBrowser
.
getTabForBrowser
(
outer
)
;
const
filteredProgressListener
=
gBrowser
.
_tabFilters
.
get
(
tab
)
;
for
(
const
property
of
SWAPPED_BROWSER_STATE
)
{
inner
[
property
]
=
outer
[
property
]
;
}
gBrowser
.
_tabForBrowser
.
delete
(
inner
)
;
outer
.
webProgress
.
removeProgressListener
(
filteredProgressListener
)
;
outer
.
webProgress
.
removeProgressListener
(
mirroringProgressListener
)
;
outer
.
destroy
(
)
;
outer
.
setAttribute
(
"
remote
"
"
false
"
)
;
outer
.
removeAttribute
(
"
remoteType
"
)
;
delete
outer
.
remoteType
;
outer
.
construct
(
)
;
for
(
const
property
of
PROPERTIES_FROM_BROWSER_WINDOW
)
{
delete
inner
.
ownerGlobal
[
property
]
;
}
inner
.
removeEventListener
(
"
mozbrowseropenwindow
"
this
)
;
inner
.
removeEventListener
(
"
mozbrowsershowmodalprompt
"
this
)
;
mmTunnel
.
destroy
(
)
;
mmTunnel
=
null
;
delete
outer
.
frameLoader
;
delete
outer
[
FRAME_LOADER
]
;
delete
outer
.
outerWindowID
;
outer
.
permanentKey
=
{
id
:
"
zombie
"
}
;
browserWindow
=
null
;
gBrowser
=
null
;
}
}
;
}
exports
.
tunnelToInnerBrowser
=
tunnelToInnerBrowser
;
function
MessageManagerTunnel
(
outer
inner
)
{
if
(
outer
.
isRemoteBrowser
)
{
throw
new
Error
(
"
The
outer
browser
must
be
non
-
remote
.
"
)
;
}
this
.
outerRef
=
Cu
.
getWeakReference
(
outer
)
;
this
.
innerRef
=
Cu
.
getWeakReference
(
inner
)
;
this
.
tunneledMessageNames
=
new
Set
(
)
;
this
.
init
(
)
;
}
MessageManagerTunnel
.
prototype
=
{
PASS_THROUGH_METHODS
:
[
"
removeDelayedFrameScript
"
"
getDelayedFrameScripts
"
"
loadProcessScript
"
"
removeDelayedProcessScript
"
"
getDelayedProcessScripts
"
"
addWeakMessageListener
"
"
removeWeakMessageListener
"
]
OVERRIDDEN_METHODS
:
[
"
loadFrameScript
"
"
addMessageListener
"
"
removeMessageListener
"
"
sendAsyncMessage
"
]
OUTER_TO_INNER_MESSAGES
:
[
"
Browser
:
PurgeSessionHistory
"
"
InPermitUnload
"
"
PermitUnload
"
"
PageStyle
:
Disable
"
"
PageStyle
:
Switch
"
"
SessionStore
:
flush
"
"
SessionStore
:
restoreHistory
"
"
SessionStore
:
restoreTabContent
"
]
INNER_TO_OUTER_MESSAGES
:
[
"
Browser
:
LoadURI
"
"
PageStyle
:
StyleSheets
"
"
DOMTitleChanged
"
"
ImageDocumentLoaded
"
"
InPermitUnload
"
"
PermitUnload
"
"
SessionStore
:
update
"
"
browser
-
test
-
utils
:
loadEvent
"
]
OUTER_TO_INNER_MESSAGE_PREFIXES
:
[
"
Autoscroll
:
"
"
debug
:
"
"
Finder
:
"
"
MessageChannel
:
"
"
Printing
:
"
]
INNER_TO_OUTER_MESSAGE_PREFIXES
:
[
"
Autoscroll
:
"
"
debug
:
"
"
Finder
:
"
"
MessageChannel
:
"
"
Printing
:
"
]
OUTER_TO_INNER_FRAME_SCRIPTS
:
[
"
resource
:
/
/
devtools
/
server
/
startup
/
frame
.
js
"
]
get
outer
(
)
{
return
this
.
outerRef
.
get
(
)
;
}
get
outerParentMM
(
)
{
if
(
!
this
.
outer
[
FRAME_LOADER
]
)
{
return
null
;
}
return
this
.
outer
[
FRAME_LOADER
]
.
messageManager
;
}
get
outerChildMM
(
)
{
const
docShell
=
this
.
outer
[
FRAME_LOADER
]
.
docShell
;
return
docShell
.
messageManager
;
}
get
inner
(
)
{
return
this
.
innerRef
.
get
(
)
;
}
get
innerParentMM
(
)
{
if
(
!
this
.
inner
.
frameLoader
)
{
return
null
;
}
return
this
.
inner
.
frameLoader
.
messageManager
;
}
init
(
)
{
for
(
const
method
of
this
.
PASS_THROUGH_METHODS
)
{
this
[
method
]
=
(
.
.
.
args
)
=
>
{
if
(
!
this
.
outerParentMM
)
{
return
null
;
}
return
this
.
outerParentMM
[
method
]
(
.
.
.
args
)
;
}
;
}
for
(
const
name
of
this
.
INNER_TO_OUTER_MESSAGES
)
{
this
.
innerParentMM
.
addMessageListener
(
name
this
)
;
this
.
tunneledMessageNames
.
add
(
name
)
;
}
Services
.
obs
.
addObserver
(
this
"
message
-
manager
-
close
"
)
;
Object
.
defineProperty
(
this
.
outer
"
messageManager
"
{
value
:
this
writable
:
false
configurable
:
true
enumerable
:
true
}
)
;
}
destroy
(
)
{
if
(
this
.
destroyed
)
{
return
;
}
this
.
destroyed
=
true
;
debug
(
"
Destroy
tunnel
"
)
;
Services
.
obs
.
removeObserver
(
this
"
message
-
manager
-
close
"
)
;
delete
this
.
outer
.
messageManager
;
for
(
const
name
of
this
.
tunneledMessageNames
)
{
this
.
innerParentMM
.
removeMessageListener
(
name
this
)
;
}
for
(
const
method
of
this
.
OVERRIDDEN_METHODS
)
{
this
[
method
]
=
(
.
.
.
args
)
=
>
{
if
(
!
this
.
outerParentMM
)
{
return
null
;
}
return
this
.
outerParentMM
[
method
]
(
.
.
.
args
)
;
}
;
}
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
"
message
-
manager
-
close
"
)
{
return
;
}
if
(
subject
=
=
this
.
innerParentMM
)
{
debug
(
"
Inner
messageManager
has
closed
"
)
;
this
.
destroy
(
)
;
}
if
(
subject
=
=
this
.
outerParentMM
)
{
debug
(
"
Outer
messageManager
has
closed
"
)
;
this
.
destroy
(
)
;
}
}
get
processMessageManager
(
)
{
return
this
.
innerParentMM
.
processMessageManager
;
}
get
remoteType
(
)
{
return
this
.
innerParentMM
.
remoteType
;
}
loadFrameScript
(
url
.
.
.
args
)
{
debug
(
Calling
loadFrameScript
for
{
url
}
)
;
if
(
!
this
.
OUTER_TO_INNER_FRAME_SCRIPTS
.
includes
(
url
)
)
{
debug
(
Should
load
{
url
}
into
inner
?
)
;
this
.
outerParentMM
.
loadFrameScript
(
url
.
.
.
args
)
;
return
;
}
debug
(
Load
{
url
}
into
inner
)
;
this
.
innerParentMM
.
loadFrameScript
(
url
.
.
.
args
)
;
}
addMessageListener
(
name
.
.
.
args
)
{
debug
(
Calling
addMessageListener
for
{
name
}
)
;
debug
(
Add
outer
listener
for
{
name
}
)
;
this
.
outerParentMM
.
addMessageListener
(
name
.
.
.
args
)
;
if
(
this
.
INNER_TO_OUTER_MESSAGE_PREFIXES
.
some
(
prefix
=
>
name
.
startsWith
(
prefix
)
)
)
{
debug
(
Add
inner
listener
for
{
name
}
)
;
this
.
innerParentMM
.
addMessageListener
(
name
this
)
;
this
.
tunneledMessageNames
.
add
(
name
)
;
}
}
removeMessageListener
(
name
.
.
.
args
)
{
debug
(
Calling
removeMessageListener
for
{
name
}
)
;
debug
(
Remove
outer
listener
for
{
name
}
)
;
this
.
outerParentMM
.
removeMessageListener
(
name
.
.
.
args
)
;
}
sendAsyncMessage
(
name
.
.
.
args
)
{
debug
(
Calling
sendAsyncMessage
for
{
name
}
)
;
if
(
!
this
.
_shouldTunnelOuterToInner
(
name
)
)
{
debug
(
Should
{
name
}
go
to
inner
?
)
;
this
.
outerParentMM
.
sendAsyncMessage
(
name
.
.
.
args
)
;
return
;
}
debug
(
{
name
}
outer
-
>
inner
)
;
this
.
innerParentMM
.
sendAsyncMessage
(
name
.
.
.
args
)
;
}
receiveMessage
(
{
name
data
objects
principal
sync
}
)
{
if
(
!
this
.
_shouldTunnelInnerToOuter
(
name
)
)
{
debug
(
Received
unexpected
message
{
name
}
)
;
return
undefined
;
}
debug
(
{
name
}
inner
-
>
outer
sync
:
{
sync
}
)
;
if
(
sync
)
{
return
this
.
outerChildMM
.
sendSyncMessage
(
name
data
objects
principal
)
;
}
this
.
outerChildMM
.
sendAsyncMessage
(
name
data
objects
principal
)
;
return
undefined
;
}
_shouldTunnelOuterToInner
(
name
)
{
return
(
this
.
OUTER_TO_INNER_MESSAGES
.
includes
(
name
)
|
|
this
.
OUTER_TO_INNER_MESSAGE_PREFIXES
.
some
(
prefix
=
>
name
.
startsWith
(
prefix
)
)
)
;
}
_shouldTunnelInnerToOuter
(
name
)
{
return
(
this
.
INNER_TO_OUTER_MESSAGES
.
includes
(
name
)
|
|
this
.
INNER_TO_OUTER_MESSAGE_PREFIXES
.
some
(
prefix
=
>
name
.
startsWith
(
prefix
)
)
)
;
}
toString
(
)
{
return
"
[
object
MessageManagerTunnel
]
"
;
}
}
;
