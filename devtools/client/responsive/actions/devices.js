"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
asyncStorage
=
require
(
"
devtools
/
shared
/
async
-
storage
"
)
;
const
{
ADD_DEVICE
ADD_DEVICE_TYPE
EDIT_DEVICE
LOAD_DEVICE_LIST_START
LOAD_DEVICE_LIST_ERROR
LOAD_DEVICE_LIST_END
REMOVE_DEVICE
UPDATE_DEVICE_DISPLAYED
UPDATE_DEVICE_MODAL
}
=
require
(
"
devtools
/
client
/
responsive
/
actions
/
index
"
)
;
const
{
post
}
=
require
(
"
devtools
/
client
/
responsive
/
utils
/
message
"
)
;
const
{
addDevice
editDevice
getDevices
removeDevice
}
=
require
(
"
devtools
/
client
/
shared
/
devices
"
)
;
const
{
changeUserAgent
toggleTouchSimulation
}
=
require
(
"
devtools
/
client
/
responsive
/
actions
/
ui
"
)
;
const
{
changeDevice
changePixelRatio
changeViewportAngle
}
=
require
(
"
devtools
/
client
/
responsive
/
actions
/
viewports
"
)
;
const
DISPLAYED_DEVICES_PREF
=
"
devtools
.
responsive
.
html
.
displayedDeviceList
"
;
function
loadPreferredDevices
(
)
{
const
preferredDevices
=
{
added
:
new
Set
(
)
removed
:
new
Set
(
)
}
;
if
(
Services
.
prefs
.
prefHasUserValue
(
DISPLAYED_DEVICES_PREF
)
)
{
try
{
let
savedData
=
Services
.
prefs
.
getStringPref
(
DISPLAYED_DEVICES_PREF
)
;
savedData
=
JSON
.
parse
(
savedData
)
;
if
(
savedData
.
added
&
&
savedData
.
removed
)
{
preferredDevices
.
added
=
new
Set
(
savedData
.
added
)
;
preferredDevices
.
removed
=
new
Set
(
savedData
.
removed
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
return
preferredDevices
;
}
function
updatePreferredDevices
(
devices
)
{
let
devicesToSave
=
{
added
:
Array
.
from
(
devices
.
added
)
removed
:
Array
.
from
(
devices
.
removed
)
}
;
devicesToSave
=
JSON
.
stringify
(
devicesToSave
)
;
Services
.
prefs
.
setStringPref
(
DISPLAYED_DEVICES_PREF
devicesToSave
)
;
}
module
.
exports
=
{
_loadPreferredDevices
:
loadPreferredDevices
updatePreferredDevices
addCustomDevice
(
device
)
{
return
async
function
(
{
dispatch
}
)
{
await
addDevice
(
device
"
custom
"
)
;
dispatch
(
{
type
:
ADD_DEVICE
device
deviceType
:
"
custom
"
}
)
;
}
;
}
addDevice
(
device
deviceType
)
{
return
{
type
:
ADD_DEVICE
device
deviceType
}
;
}
addDeviceType
(
deviceType
)
{
return
{
type
:
ADD_DEVICE_TYPE
deviceType
}
;
}
editCustomDevice
(
viewport
oldDevice
newDevice
)
{
return
async
function
(
{
dispatch
}
)
{
await
editDevice
(
oldDevice
newDevice
"
custom
"
)
;
post
(
window
{
type
:
"
change
-
device
"
device
:
newDevice
viewport
}
)
;
if
(
viewport
)
{
dispatch
(
changeUserAgent
(
newDevice
.
userAgent
)
)
;
dispatch
(
toggleTouchSimulation
(
newDevice
.
touch
)
)
;
}
dispatch
(
{
type
:
EDIT_DEVICE
deviceType
:
"
custom
"
viewport
oldDevice
newDevice
}
)
;
}
;
}
removeCustomDevice
(
device
)
{
return
async
function
(
{
dispatch
}
)
{
await
removeDevice
(
device
"
custom
"
)
;
dispatch
(
{
type
:
REMOVE_DEVICE
device
deviceType
:
"
custom
"
}
)
;
}
;
}
updateDeviceDisplayed
(
device
deviceType
displayed
)
{
return
{
type
:
UPDATE_DEVICE_DISPLAYED
device
deviceType
displayed
}
;
}
loadDevices
(
)
{
return
async
function
(
{
dispatch
}
)
{
dispatch
(
{
type
:
LOAD_DEVICE_LIST_START
}
)
;
const
preferredDevices
=
loadPreferredDevices
(
)
;
let
deviceByTypes
;
try
{
deviceByTypes
=
await
getDevices
(
)
;
}
catch
(
e
)
{
console
.
error
(
"
Could
not
load
device
list
:
"
+
e
)
;
dispatch
(
{
type
:
LOAD_DEVICE_LIST_ERROR
}
)
;
return
;
}
for
(
const
[
type
devices
]
of
deviceByTypes
.
entries
(
)
)
{
dispatch
(
module
.
exports
.
addDeviceType
(
type
)
)
;
for
(
const
device
of
devices
)
{
if
(
device
.
os
=
=
"
fxos
"
)
{
continue
;
}
const
newDevice
=
Object
.
assign
(
{
}
device
{
displayed
:
preferredDevices
.
added
.
has
(
device
.
name
)
|
|
(
device
.
featured
&
&
!
preferredDevices
.
removed
.
has
(
device
.
name
)
)
}
)
;
dispatch
(
module
.
exports
.
addDevice
(
newDevice
type
)
)
;
}
}
if
(
!
deviceByTypes
.
has
(
"
custom
"
)
)
{
dispatch
(
module
.
exports
.
addDeviceType
(
"
custom
"
)
)
;
}
dispatch
(
{
type
:
LOAD_DEVICE_LIST_END
}
)
;
}
;
}
restoreDeviceState
(
)
{
return
async
function
(
{
dispatch
getState
}
)
{
const
deviceState
=
await
asyncStorage
.
getItem
(
"
devtools
.
responsive
.
deviceState
"
)
;
if
(
!
deviceState
)
{
return
;
}
const
{
id
device
:
deviceName
deviceType
}
=
deviceState
;
const
devices
=
getState
(
)
.
devices
;
if
(
!
devices
.
types
.
includes
(
deviceType
)
)
{
return
;
}
const
device
=
devices
[
deviceType
]
.
find
(
d
=
>
d
.
name
=
=
=
deviceName
)
;
if
(
!
device
)
{
return
;
}
const
viewport
=
getState
(
)
.
viewports
[
0
]
;
post
(
window
{
type
:
"
change
-
device
"
device
viewport
}
)
;
dispatch
(
changeDevice
(
id
device
.
name
deviceType
)
)
;
dispatch
(
changeViewportAngle
(
id
viewport
.
angle
)
)
;
dispatch
(
changePixelRatio
(
id
device
.
pixelRatio
)
)
;
dispatch
(
changeUserAgent
(
device
.
userAgent
)
)
;
dispatch
(
toggleTouchSimulation
(
device
.
touch
)
)
;
}
;
}
updateDeviceModal
(
isOpen
modalOpenedFromViewport
=
null
)
{
return
{
type
:
UPDATE_DEVICE_MODAL
isOpen
modalOpenedFromViewport
}
;
}
}
;
