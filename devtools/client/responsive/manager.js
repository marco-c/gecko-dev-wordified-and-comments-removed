"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUI
"
"
devtools
/
client
/
responsive
/
ui
"
)
;
loader
.
lazyRequireGetter
(
this
"
startup
"
"
devtools
/
client
/
responsive
/
utils
/
window
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
showNotification
"
"
devtools
/
client
/
responsive
/
utils
/
notification
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
l10n
"
"
devtools
/
client
/
responsive
/
utils
/
l10n
"
)
;
loader
.
lazyRequireGetter
(
this
"
PriorityLevels
"
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TargetFactory
"
"
devtools
/
client
/
framework
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevToolsBrowser
"
"
devtools
/
client
/
framework
/
devtools
-
browser
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Telemetry
"
"
devtools
/
client
/
shared
/
telemetry
"
)
;
class
ResponsiveUIManager
{
constructor
(
)
{
this
.
activeTabs
=
new
Map
(
)
;
this
.
handleMenuCheck
=
this
.
handleMenuCheck
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
get
telemetry
(
)
{
if
(
!
this
.
_telemetry
)
{
this
.
_telemetry
=
new
Telemetry
(
)
;
}
return
this
.
_telemetry
;
}
toggle
(
window
tab
options
=
{
}
)
{
const
action
=
this
.
isActiveForTab
(
tab
)
?
"
close
"
:
"
open
"
;
const
completed
=
this
[
action
+
"
IfNeeded
"
]
(
window
tab
options
)
;
completed
.
catch
(
console
.
error
)
;
return
completed
;
}
async
openIfNeeded
(
window
tab
options
=
{
}
)
{
if
(
!
tab
.
linkedBrowser
.
isRemoteBrowser
)
{
await
this
.
showRemoteOnlyNotification
(
window
tab
options
)
;
return
promise
.
reject
(
new
Error
(
"
RDM
only
available
for
remote
tabs
.
"
)
)
;
}
if
(
!
this
.
isActiveForTab
(
tab
)
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
browserUI
.
enabled
"
)
)
{
await
gDevToolsBrowser
.
loadBrowserStyleSheet
(
window
)
;
}
this
.
initMenuCheckListenerFor
(
window
)
;
const
ui
=
new
ResponsiveUI
(
this
window
tab
)
;
this
.
activeTabs
.
set
(
tab
ui
)
;
this
.
recordTelemetryOpen
(
window
tab
options
)
;
await
this
.
setMenuCheckFor
(
tab
window
)
;
await
ui
.
inited
;
this
.
emit
(
"
on
"
{
tab
}
)
;
}
return
this
.
getResponsiveUIForTab
(
tab
)
;
}
async
recordTelemetryOpen
(
window
tab
options
)
{
const
isKnownTab
=
TargetFactory
.
isKnownTab
(
tab
)
;
let
toolbox
;
if
(
isKnownTab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
}
const
hostType
=
toolbox
?
toolbox
.
hostType
:
"
none
"
;
const
hasToolbox
=
!
!
toolbox
;
if
(
hasToolbox
)
{
this
.
telemetry
.
scalarAdd
(
"
devtools
.
responsive
.
toolbox_opened_first
"
1
)
;
}
this
.
telemetry
.
recordEvent
(
"
activate
"
"
responsive_design
"
null
{
host
:
hostType
width
:
Math
.
ceil
(
window
.
outerWidth
/
50
)
*
50
session_id
:
toolbox
?
toolbox
.
sessionId
:
-
1
}
)
;
let
{
trigger
}
=
options
;
if
(
!
trigger
)
{
trigger
=
"
unknown
"
;
}
this
.
telemetry
.
keyedScalarAdd
(
"
devtools
.
responsive
.
open_trigger
"
trigger
1
)
;
}
async
closeIfNeeded
(
window
tab
options
=
{
}
)
{
if
(
this
.
isActiveForTab
(
tab
)
)
{
const
ui
=
this
.
activeTabs
.
get
(
tab
)
;
const
destroyed
=
await
ui
.
destroy
(
options
)
;
if
(
!
destroyed
)
{
return
;
}
this
.
activeTabs
.
delete
(
tab
)
;
if
(
!
this
.
isActiveForWindow
(
window
)
)
{
this
.
removeMenuCheckListenerFor
(
window
)
;
}
this
.
emit
(
"
off
"
{
tab
}
)
;
await
this
.
setMenuCheckFor
(
tab
window
)
;
this
.
recordTelemetryClose
(
window
tab
)
;
}
}
async
recordTelemetryClose
(
window
tab
)
{
const
isKnownTab
=
TargetFactory
.
isKnownTab
(
tab
)
;
let
toolbox
;
if
(
isKnownTab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
}
const
hostType
=
toolbox
?
toolbox
.
hostType
:
"
none
"
;
this
.
telemetry
.
recordEvent
(
"
deactivate
"
"
responsive_design
"
null
{
host
:
hostType
width
:
Math
.
ceil
(
window
.
outerWidth
/
50
)
*
50
session_id
:
toolbox
?
toolbox
.
sessionId
:
-
1
}
)
;
}
isActiveForTab
(
tab
)
{
return
this
.
activeTabs
.
has
(
tab
)
;
}
isActiveForWindow
(
window
)
{
return
[
.
.
.
this
.
activeTabs
.
keys
(
)
]
.
some
(
t
=
>
t
.
ownerGlobal
=
=
=
window
)
;
}
getResponsiveUIForTab
(
tab
)
{
return
this
.
activeTabs
.
get
(
tab
)
;
}
handleMenuCheck
(
{
target
}
)
{
this
.
setMenuCheckFor
(
target
)
;
}
initMenuCheckListenerFor
(
window
)
{
const
{
tabContainer
}
=
window
.
gBrowser
;
tabContainer
.
addEventListener
(
"
TabSelect
"
this
.
handleMenuCheck
)
;
}
removeMenuCheckListenerFor
(
window
)
{
if
(
window
&
&
window
.
gBrowser
&
&
window
.
gBrowser
.
tabContainer
)
{
const
{
tabContainer
}
=
window
.
gBrowser
;
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
.
handleMenuCheck
)
;
}
}
async
setMenuCheckFor
(
tab
window
=
tab
.
ownerGlobal
)
{
await
startup
(
window
)
;
const
menu
=
window
.
document
.
getElementById
(
"
menu_responsiveUI
"
)
;
if
(
menu
)
{
menu
.
setAttribute
(
"
checked
"
this
.
isActiveForTab
(
tab
)
)
;
}
}
showRemoteOnlyNotification
(
window
tab
{
trigger
}
=
{
}
)
{
return
showNotification
(
window
tab
{
toolboxButton
:
trigger
=
=
"
toolbox
"
msg
:
l10n
.
getStr
(
"
responsive
.
remoteOnly
"
)
priority
:
PriorityLevels
.
PRIORITY_CRITICAL_MEDIUM
}
)
;
}
}
module
.
exports
=
new
ResponsiveUIManager
(
)
;
