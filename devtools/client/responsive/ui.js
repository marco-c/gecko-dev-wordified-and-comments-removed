"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
getOrientation
}
=
require
(
"
devtools
/
client
/
responsive
/
utils
/
orientation
"
)
;
const
Constants
=
require
(
"
devtools
/
client
/
responsive
/
constants
"
)
;
const
{
TargetList
}
=
require
(
"
devtools
/
shared
/
resources
/
target
-
list
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsClient
"
"
devtools
/
shared
/
client
/
devtools
-
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsServer
"
"
devtools
/
server
/
devtools
-
server
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
throttlingProfiles
"
"
devtools
/
client
/
shared
/
components
/
throttling
/
profiles
"
)
;
loader
.
lazyRequireGetter
(
this
"
swapToInnerBrowser
"
"
devtools
/
client
/
responsive
/
browser
/
swap
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
message
"
"
devtools
/
client
/
responsive
/
utils
/
message
"
)
;
loader
.
lazyRequireGetter
(
this
"
showNotification
"
"
devtools
/
client
/
responsive
/
utils
/
notification
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
l10n
"
"
devtools
/
client
/
responsive
/
utils
/
l10n
"
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
devtools
/
shared
/
async
-
storage
"
)
;
loader
.
lazyRequireGetter
(
this
"
saveScreenshot
"
"
devtools
/
shared
/
screenshot
/
save
"
)
;
const
TOOL_URL
=
"
chrome
:
/
/
devtools
/
content
/
responsive
/
index
.
xhtml
"
;
const
RELOAD_CONDITION_PREF_PREFIX
=
"
devtools
.
responsive
.
reloadConditions
.
"
;
const
RELOAD_NOTIFICATION_PREF
=
"
devtools
.
responsive
.
reloadNotification
.
enabled
"
;
function
debug
(
msg
)
{
}
class
ResponsiveUI
{
constructor
(
manager
window
tab
)
{
this
.
manager
=
manager
;
this
.
browserWindow
=
window
;
this
.
tab
=
tab
;
this
.
destroying
=
false
;
this
.
destroyed
=
false
;
this
.
toolWindow
=
null
;
this
.
rdmFrame
=
null
;
this
.
onResizeDrag
=
this
.
onResizeDrag
.
bind
(
this
)
;
this
.
onResizeStart
=
this
.
onResizeStart
.
bind
(
this
)
;
this
.
onResizeStop
=
this
.
onResizeStop
.
bind
(
this
)
;
this
.
onTargetAvailable
=
this
.
onTargetAvailable
.
bind
(
this
)
;
this
.
inited
=
this
.
init
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
get
docShell
(
)
{
return
this
.
isBrowserUIEnabled
?
this
.
rdmFrame
.
contentWindow
.
docShell
:
this
.
toolWindow
.
docShell
;
}
get
isBrowserUIEnabled
(
)
{
if
(
!
this
.
_isBrowserUIEnabled
)
{
this
.
_isBrowserUIEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
browserUI
.
enabled
"
)
;
}
return
this
.
_isBrowserUIEnabled
;
}
get
currentTarget
(
)
{
return
this
.
targetList
.
targetFront
;
}
async
init
(
)
{
debug
(
"
Init
start
"
)
;
const
ui
=
this
;
if
(
this
.
isBrowserUIEnabled
)
{
this
.
initRDMFrame
(
)
;
}
this
.
tab
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
browserWindow
.
addEventListener
(
"
unload
"
this
)
;
if
(
!
this
.
isBrowserUIEnabled
)
{
debug
(
"
Create
browser
swapper
"
)
;
this
.
swap
=
swapToInnerBrowser
(
{
tab
:
this
.
tab
containerURL
:
TOOL_URL
async
getInnerBrowser
(
containerBrowser
)
{
const
toolWindow
=
(
ui
.
toolWindow
=
containerBrowser
.
contentWindow
)
;
toolWindow
.
addEventListener
(
"
message
"
ui
)
;
debug
(
"
Wait
until
init
from
inner
"
)
;
await
message
.
request
(
toolWindow
"
init
"
)
;
toolWindow
.
addInitialViewport
(
{
uri
:
"
about
:
blank
"
userContextId
:
ui
.
tab
.
userContextId
}
)
;
debug
(
"
Wait
until
browser
mounted
"
)
;
await
message
.
wait
(
toolWindow
"
browser
-
mounted
"
)
;
return
ui
.
getViewportBrowser
(
)
;
}
}
)
;
debug
(
"
Wait
until
swap
start
"
)
;
await
this
.
swap
.
start
(
)
;
}
else
{
this
.
rdmFrame
.
contentWindow
.
addEventListener
(
"
message
"
this
)
;
}
const
rdmContent
=
this
.
tab
.
linkedBrowser
;
const
fullZoom
=
rdmContent
.
fullZoom
;
const
textZoom
=
rdmContent
.
textZoom
;
if
(
this
.
isBrowserUIEnabled
)
{
this
.
browserWindow
.
addEventListener
(
"
FullZoomChange
"
this
)
;
}
else
{
this
.
docShell
.
contentViewer
.
fullZoom
=
1
;
this
.
docShell
.
contentViewer
.
textZoom
=
1
;
this
.
tab
.
linkedBrowser
.
addEventListener
(
"
FullZoomChange
"
this
)
;
}
this
.
tab
.
addEventListener
(
"
BeforeTabRemotenessChange
"
this
)
;
if
(
!
this
.
isBrowserUIEnabled
)
{
debug
(
"
Wait
until
start
frame
script
"
)
;
await
message
.
request
(
this
.
toolWindow
"
start
-
frame
-
script
"
)
;
}
debug
(
"
Wait
until
RDP
server
connect
"
)
;
await
this
.
connectToServer
(
)
;
await
this
.
restoreUIState
(
)
;
if
(
!
this
.
isBrowserUIEnabled
)
{
const
bc
=
this
.
toolWindow
.
docShell
.
browsingContext
;
const
zoomActor
=
bc
.
currentWindowGlobal
.
getActor
(
"
Zoom
"
)
;
zoomActor
.
sendAsyncMessage
(
"
FullZoom
"
{
value
:
1
.
0
}
)
;
rdmContent
.
fullZoom
=
fullZoom
;
rdmContent
.
textZoom
=
textZoom
;
}
if
(
!
this
.
isBrowserUIEnabled
)
{
message
.
post
(
this
.
toolWindow
"
post
-
init
"
)
;
}
else
{
message
.
post
(
this
.
rdmFrame
.
contentWindow
"
post
-
init
"
)
;
}
debug
(
"
Init
done
"
)
;
}
initRDMFrame
(
)
{
const
{
document
:
doc
gBrowser
}
=
this
.
browserWindow
;
const
rdmFrame
=
doc
.
createElement
(
"
iframe
"
)
;
rdmFrame
.
src
=
"
chrome
:
/
/
devtools
/
content
/
responsive
/
toolbar
.
xhtml
"
;
rdmFrame
.
classList
.
add
(
"
rdm
-
toolbar
"
)
;
const
resizeHandle
=
doc
.
createElement
(
"
div
"
)
;
resizeHandle
.
classList
.
add
(
"
viewport
-
resize
-
handle
"
)
;
const
resizeHandleX
=
doc
.
createElement
(
"
div
"
)
;
resizeHandleX
.
classList
.
add
(
"
viewport
-
horizontal
-
resize
-
handle
"
)
;
const
resizeHandleY
=
doc
.
createElement
(
"
div
"
)
;
resizeHandleY
.
classList
.
add
(
"
viewport
-
vertical
-
resize
-
handle
"
)
;
this
.
browserContainerEl
=
gBrowser
.
getBrowserContainer
(
gBrowser
.
getBrowserForTab
(
this
.
tab
)
)
;
this
.
browserStackEl
=
this
.
browserContainerEl
.
querySelector
(
"
.
browserStack
"
)
;
this
.
browserContainerEl
.
classList
.
add
(
"
responsive
-
mode
"
)
;
this
.
browserStackEl
.
prepend
(
rdmFrame
)
;
this
.
browserStackEl
.
append
(
resizeHandle
)
;
this
.
browserStackEl
.
append
(
resizeHandleX
)
;
this
.
browserStackEl
.
append
(
resizeHandleY
)
;
message
.
wait
(
rdmFrame
.
contentWindow
"
script
-
init
"
)
.
then
(
async
(
)
=
>
{
message
.
post
(
rdmFrame
.
contentWindow
"
init
"
)
;
message
.
wait
(
rdmFrame
.
contentWindow
"
init
:
done
"
)
.
then
(
(
)
=
>
{
rdmFrame
.
contentWindow
.
addInitialViewport
(
{
userContextId
:
this
.
tab
.
userContextId
}
)
;
}
)
;
}
)
;
this
.
rdmFrame
=
rdmFrame
;
this
.
resizeHandle
=
resizeHandle
;
this
.
resizeHandle
.
addEventListener
(
"
mousedown
"
this
.
onResizeStart
)
;
this
.
resizeHandleX
=
resizeHandleX
;
this
.
resizeHandleX
.
addEventListener
(
"
mousedown
"
this
.
onResizeStart
)
;
this
.
resizeHandleY
=
resizeHandleY
;
this
.
resizeHandleY
.
addEventListener
(
"
mousedown
"
this
.
onResizeStart
)
;
}
async
destroy
(
options
)
{
if
(
this
.
destroying
)
{
return
false
;
}
this
.
destroying
=
true
;
this
.
targetList
.
unwatchTargets
(
[
this
.
targetList
.
TYPES
.
FRAME
]
this
.
onTargetAvailable
)
;
const
isTabDestroyed
=
!
this
.
tab
.
linkedBrowser
;
const
isWindowClosing
=
(
options
&
&
options
.
reason
=
=
=
"
unload
"
)
|
|
isTabDestroyed
;
const
isTabContentDestroying
=
isWindowClosing
|
|
(
options
&
&
(
options
.
reason
=
=
=
"
TabClose
"
|
|
options
.
reason
=
=
=
"
BeforeTabRemotenessChange
"
)
)
;
if
(
!
isTabContentDestroying
)
{
await
this
.
inited
;
await
this
.
updateScreenOrientation
(
"
landscape
-
primary
"
0
)
;
}
if
(
this
.
isBrowserUIEnabled
)
{
await
this
.
responsiveFront
.
setDocumentInRDMPane
(
false
)
;
await
this
.
responsiveFront
.
setFloatingScrollbars
(
false
)
;
}
this
.
tab
.
removeEventListener
(
"
TabClose
"
this
)
;
this
.
tab
.
removeEventListener
(
"
BeforeTabRemotenessChange
"
this
)
;
this
.
browserWindow
.
removeEventListener
(
"
unload
"
this
)
;
if
(
!
this
.
isBrowserUIEnabled
)
{
this
.
tab
.
linkedBrowser
.
removeEventListener
(
"
FullZoomChange
"
this
)
;
this
.
toolWindow
.
removeEventListener
(
"
message
"
this
)
;
}
else
{
this
.
browserWindow
.
removeEventListener
(
"
FullZoomChange
"
this
)
;
this
.
rdmFrame
.
contentWindow
.
removeEventListener
(
"
message
"
this
)
;
this
.
rdmFrame
.
remove
(
)
;
this
.
resizeHandle
.
remove
(
)
;
this
.
resizeHandleX
.
remove
(
)
;
this
.
resizeHandleY
.
remove
(
)
;
this
.
browserContainerEl
.
classList
.
remove
(
"
responsive
-
mode
"
)
;
this
.
browserStackEl
.
style
.
removeProperty
(
"
-
-
rdm
-
width
"
)
;
this
.
browserStackEl
.
style
.
removeProperty
(
"
-
-
rdm
-
height
"
)
;
}
if
(
!
this
.
isBrowserUIEnabled
&
&
!
isTabContentDestroying
)
{
await
message
.
request
(
this
.
toolWindow
"
stop
-
frame
-
script
"
)
;
}
if
(
!
isTabContentDestroying
)
{
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
)
;
await
this
.
updateNetworkThrottling
(
)
;
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
reloadNeeded
|
=
(
await
this
.
updateTouchSimulation
(
)
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
}
const
swap
=
this
.
swap
;
this
.
browserContainerEl
=
null
;
this
.
browserStackEl
=
null
;
this
.
browserWindow
=
null
;
this
.
tab
=
null
;
this
.
inited
=
null
;
this
.
rdmFrame
=
null
;
this
.
resizeHandle
=
null
;
this
.
resizeHandleX
=
null
;
this
.
resizeHandleY
=
null
;
this
.
toolWindow
=
null
;
this
.
swap
=
null
;
const
clientClosed
=
this
.
client
.
close
(
)
;
if
(
!
isTabContentDestroying
)
{
await
clientClosed
;
}
this
.
client
=
this
.
responsiveFront
=
null
;
if
(
!
this
.
isBrowserUIEnabled
&
&
!
isWindowClosing
)
{
swap
.
stop
(
)
;
}
this
.
destroyed
=
true
;
return
true
;
}
async
connectToServer
(
)
{
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
this
.
client
=
new
DevToolsClient
(
DevToolsServer
.
connectPipe
(
)
)
;
await
this
.
client
.
connect
(
)
;
const
targetFront
=
await
this
.
client
.
mainRoot
.
getTab
(
)
;
this
.
targetList
=
new
TargetList
(
this
.
client
.
mainRoot
targetFront
)
;
await
this
.
targetList
.
watchTargets
(
[
this
.
targetList
.
TYPES
.
FRAME
]
this
.
onTargetAvailable
)
;
}
showReloadNotification
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
RELOAD_NOTIFICATION_PREF
false
)
)
{
showNotification
(
this
.
browserWindow
this
.
tab
{
msg
:
l10n
.
getFormatStr
(
"
responsive
.
reloadNotification
.
description2
"
)
}
)
;
Services
.
prefs
.
setBoolPref
(
RELOAD_NOTIFICATION_PREF
false
)
;
}
}
reloadOnChange
(
id
)
{
this
.
showReloadNotification
(
)
;
const
pref
=
RELOAD_CONDITION_PREF_PREFIX
+
id
;
return
Services
.
prefs
.
getBoolPref
(
pref
false
)
;
}
handleEvent
(
event
)
{
const
{
browserWindow
tab
toolWindow
}
=
this
;
switch
(
event
.
type
)
{
case
"
message
"
:
this
.
handleMessage
(
event
)
;
break
;
case
"
FullZoomChange
"
:
if
(
this
.
isBrowserUIEnabled
)
{
const
{
width
height
}
=
this
.
rdmFrame
.
contentWindow
.
getViewportSize
(
)
;
this
.
updateViewportSize
(
width
height
)
;
}
else
{
const
zoom
=
tab
.
linkedBrowser
.
fullZoom
;
toolWindow
.
setViewportZoom
(
zoom
)
;
}
break
;
case
"
BeforeTabRemotenessChange
"
:
this
.
onRemotenessChange
(
event
)
;
break
;
case
"
TabClose
"
:
case
"
unload
"
:
this
.
manager
.
closeIfNeeded
(
browserWindow
tab
{
reason
:
event
.
type
}
)
;
break
;
}
}
handleMessage
(
event
)
{
if
(
event
.
origin
!
=
=
"
chrome
:
/
/
devtools
"
)
{
return
;
}
switch
(
event
.
data
.
type
)
{
case
"
change
-
device
"
:
this
.
onChangeDevice
(
event
)
;
break
;
case
"
change
-
network
-
throttling
"
:
this
.
onChangeNetworkThrottling
(
event
)
;
break
;
case
"
change
-
pixel
-
ratio
"
:
this
.
onChangePixelRatio
(
event
)
;
break
;
case
"
change
-
touch
-
simulation
"
:
this
.
onChangeTouchSimulation
(
event
)
;
break
;
case
"
change
-
user
-
agent
"
:
this
.
onChangeUserAgent
(
event
)
;
break
;
case
"
content
-
resize
"
:
this
.
onContentResize
(
event
)
;
break
;
case
"
exit
"
:
this
.
onExit
(
)
;
break
;
case
"
remove
-
device
-
association
"
:
this
.
onRemoveDeviceAssociation
(
)
;
break
;
case
"
viewport
-
orientation
-
change
"
:
this
.
onRotateViewport
(
event
)
;
break
;
case
"
viewport
-
resize
"
:
this
.
onResizeViewport
(
event
)
;
break
;
case
"
screenshot
"
:
this
.
onScreenshot
(
)
;
break
;
case
"
toggle
-
left
-
alignment
"
:
this
.
onToggleLeftAlignment
(
event
)
;
break
;
case
"
update
-
device
-
modal
"
:
this
.
onUpdateDeviceModal
(
event
)
;
break
;
case
"
update
-
device
-
selector
-
menu
"
:
this
.
onUpdateDeviceSelectorMenu
(
event
)
;
}
}
async
onChangeDevice
(
event
)
{
const
{
pixelRatio
touch
userAgent
}
=
event
.
data
.
device
;
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
pixelRatio
)
;
const
{
device
viewport
}
=
event
.
data
;
const
{
type
angle
}
=
getOrientation
(
device
viewport
)
;
await
this
.
updateScreenOrientation
(
type
angle
)
;
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
userAgent
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
reloadNeeded
|
=
(
await
this
.
updateTouchSimulation
(
touch
)
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
device
-
changed
"
)
;
}
async
onChangeNetworkThrottling
(
event
)
{
const
{
enabled
profile
}
=
event
.
data
;
await
this
.
updateNetworkThrottling
(
enabled
profile
)
;
this
.
emit
(
"
network
-
throttling
-
changed
"
)
;
}
onChangePixelRatio
(
event
)
{
const
{
pixelRatio
}
=
event
.
data
;
this
.
updateDPPX
(
pixelRatio
)
;
}
async
onChangeTouchSimulation
(
event
)
{
const
{
enabled
}
=
event
.
data
;
const
reloadNeeded
=
(
await
this
.
updateTouchSimulation
(
enabled
)
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
touch
-
simulation
-
changed
"
)
;
}
async
onChangeUserAgent
(
event
)
{
const
{
userAgent
}
=
event
.
data
;
const
reloadNeeded
=
(
await
this
.
updateUserAgent
(
userAgent
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
user
-
agent
-
changed
"
)
;
}
onContentResize
(
event
)
{
const
{
width
height
}
=
event
.
data
;
this
.
emit
(
"
content
-
resize
"
{
width
height
}
)
;
}
onExit
(
)
{
const
{
browserWindow
tab
}
=
this
;
this
.
manager
.
closeIfNeeded
(
browserWindow
tab
)
;
}
async
onRemoveDeviceAssociation
(
)
{
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
)
;
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
reloadNeeded
|
=
(
await
this
.
updateTouchSimulation
(
)
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
this
.
emit
(
"
device
-
association
-
removed
"
)
;
}
onResizeDrag
(
{
screenX
screenY
}
)
{
if
(
!
this
.
isResizing
|
|
!
this
.
rdmFrame
.
contentWindow
)
{
return
;
}
const
zoom
=
this
.
tab
.
linkedBrowser
.
fullZoom
;
let
deltaX
=
(
screenX
-
this
.
lastScreenX
)
/
zoom
;
let
deltaY
=
(
screenY
-
this
.
lastScreenY
)
/
zoom
;
const
leftAlignmentEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
leftAlignViewport
.
enabled
"
false
)
;
if
(
!
leftAlignmentEnabled
)
{
deltaX
=
deltaX
*
2
;
}
if
(
this
.
ignoreX
)
{
deltaX
=
0
;
}
if
(
this
.
ignoreY
)
{
deltaY
=
0
;
}
const
viewportSize
=
this
.
rdmFrame
.
contentWindow
.
getViewportSize
(
)
;
let
width
=
Math
.
round
(
viewportSize
.
width
+
deltaX
)
;
let
height
=
Math
.
round
(
viewportSize
.
height
+
deltaY
)
;
if
(
width
<
Constants
.
MIN_VIEWPORT_DIMENSION
)
{
width
=
Constants
.
MIN_VIEWPORT_DIMENSION
;
}
else
if
(
width
!
=
viewportSize
.
width
)
{
this
.
lastScreenX
=
screenX
;
}
if
(
height
<
Constants
.
MIN_VIEWPORT_DIMENSION
)
{
height
=
Constants
.
MIN_VIEWPORT_DIMENSION
;
}
else
if
(
height
!
=
viewportSize
.
height
)
{
this
.
lastScreenY
=
screenY
;
}
this
.
rdmFrame
.
contentWindow
.
setViewportSize
(
{
width
height
}
)
;
this
.
updateViewportSize
(
width
height
)
;
if
(
this
.
rdmFrame
.
contentWindow
.
getAssociatedDevice
(
)
)
{
this
.
rdmFrame
.
contentWindow
.
clearDeviceAssociation
(
)
;
}
}
onResizeStart
(
{
target
screenX
screenY
}
)
{
this
.
browserWindow
.
addEventListener
(
"
mousemove
"
this
.
onResizeDrag
true
)
;
this
.
browserWindow
.
addEventListener
(
"
mouseup
"
this
.
onResizeStop
true
)
;
this
.
isResizing
=
true
;
this
.
lastScreenX
=
screenX
;
this
.
lastScreenY
=
screenY
;
this
.
ignoreX
=
target
=
=
=
this
.
resizeHandleY
;
this
.
ignoreY
=
target
=
=
=
this
.
resizeHandleX
;
}
onResizeStop
(
)
{
this
.
browserWindow
.
removeEventListener
(
"
mousemove
"
this
.
onResizeDrag
true
)
;
this
.
browserWindow
.
removeEventListener
(
"
mouseup
"
this
.
onResizeStop
true
)
;
this
.
isResizing
=
false
;
this
.
lastScreenX
=
0
;
this
.
lastScreenY
=
0
;
this
.
ignoreX
=
false
;
this
.
ignoreY
=
false
;
}
onResizeViewport
(
event
)
{
const
{
width
height
}
=
event
.
data
;
this
.
updateViewportSize
(
width
height
)
;
this
.
emit
(
"
viewport
-
resize
"
{
width
height
}
)
;
}
async
onRotateViewport
(
event
)
{
const
{
orientationType
:
type
angle
isViewportRotated
}
=
event
.
data
;
await
this
.
updateScreenOrientation
(
type
angle
isViewportRotated
)
;
}
async
onScreenshot
(
)
{
const
captureScreenshotSupported
=
await
this
.
currentTarget
.
actorHasMethod
(
"
responsive
"
"
captureScreenshot
"
)
;
if
(
captureScreenshotSupported
)
{
const
data
=
await
this
.
responsiveFront
.
captureScreenshot
(
)
;
await
saveScreenshot
(
this
.
browserWindow
{
}
data
)
;
message
.
post
(
this
.
rdmFrame
.
contentWindow
"
screenshot
-
captured
"
)
;
}
}
onToggleLeftAlignment
(
event
)
{
this
.
updateUIAlignment
(
event
.
data
.
leftAlignmentEnabled
)
;
}
onUpdateDeviceModal
(
event
)
{
this
.
browserStackEl
.
classList
.
toggle
(
"
device
-
modal
-
opened
"
event
.
data
.
isOpen
)
;
}
onUpdateDeviceSelectorMenu
(
event
)
{
this
.
browserStackEl
.
classList
.
toggle
(
"
device
-
selector
-
menu
-
opened
"
event
.
data
.
isOpen
)
;
}
async
hasDeviceState
(
)
{
const
deviceState
=
await
asyncStorage
.
getItem
(
"
devtools
.
responsive
.
deviceState
"
)
;
return
!
!
deviceState
;
}
async
restoreUIState
(
)
{
if
(
this
.
isBrowserUIEnabled
)
{
const
leftAlignmentEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
leftAlignViewport
.
enabled
"
false
)
;
this
.
updateUIAlignment
(
leftAlignmentEnabled
)
;
}
const
hasDeviceState
=
await
this
.
hasDeviceState
(
)
;
if
(
hasDeviceState
)
{
return
;
}
const
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
height
"
0
)
;
const
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
width
"
0
)
;
this
.
updateViewportSize
(
width
height
)
;
}
async
restoreActorState
(
)
{
if
(
this
.
isBrowserUIEnabled
)
{
await
this
.
responsiveFront
.
setDocumentInRDMPane
(
true
)
;
await
this
.
responsiveFront
.
setFloatingScrollbars
(
true
)
;
await
this
.
currentTarget
.
attach
(
)
;
}
const
hasDeviceState
=
await
this
.
hasDeviceState
(
)
;
if
(
hasDeviceState
)
{
return
;
}
const
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
height
"
0
)
;
const
pixelRatio
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
pixelRatio
"
0
)
;
const
touchSimulationEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
touchSimulation
.
enabled
"
false
)
;
const
userAgent
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
responsive
.
userAgent
"
"
"
)
;
const
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
width
"
0
)
;
const
{
type
angle
}
=
this
.
getInitialViewportOrientation
(
{
width
height
}
)
;
await
this
.
updateDPPX
(
pixelRatio
)
;
await
this
.
updateScreenOrientation
(
type
angle
)
;
let
reloadNeeded
=
false
;
if
(
touchSimulationEnabled
)
{
reloadNeeded
|
=
(
await
this
.
updateTouchSimulation
(
touchSimulationEnabled
)
)
&
&
this
.
reloadOnChange
(
"
touchSimulation
"
)
;
}
if
(
userAgent
)
{
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
userAgent
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
}
if
(
reloadNeeded
)
{
this
.
getViewportBrowser
(
)
.
reload
(
)
;
}
}
async
updateDPPX
(
dppx
)
{
if
(
!
dppx
)
{
await
this
.
responsiveFront
.
clearDPPXOverride
(
)
;
return
false
;
}
await
this
.
responsiveFront
.
setDPPXOverride
(
dppx
)
;
return
false
;
}
async
updateNetworkThrottling
(
enabled
profile
)
{
if
(
!
enabled
)
{
await
this
.
responsiveFront
.
clearNetworkThrottling
(
)
;
return
false
;
}
const
data
=
throttlingProfiles
.
find
(
(
{
id
}
)
=
>
id
=
=
profile
)
;
const
{
download
upload
latency
}
=
data
;
await
this
.
responsiveFront
.
setNetworkThrottling
(
{
downloadThroughput
:
download
uploadThroughput
:
upload
latency
}
)
;
return
false
;
}
updateUserAgent
(
userAgent
)
{
if
(
!
userAgent
)
{
return
this
.
responsiveFront
.
clearUserAgentOverride
(
)
;
}
return
this
.
responsiveFront
.
setUserAgentOverride
(
userAgent
)
;
}
async
updateTouchSimulation
(
enabled
)
{
let
reloadNeeded
;
if
(
enabled
)
{
const
metaViewportEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
metaViewport
.
enabled
"
false
)
;
reloadNeeded
=
await
this
.
responsiveFront
.
setTouchEventsOverride
(
Ci
.
nsIDocShell
.
TOUCHEVENTS_OVERRIDE_ENABLED
)
;
if
(
metaViewportEnabled
)
{
reloadNeeded
|
=
await
this
.
responsiveFront
.
setMetaViewportOverride
(
Ci
.
nsIDocShell
.
META_VIEWPORT_OVERRIDE_ENABLED
)
;
}
}
else
{
reloadNeeded
=
await
this
.
responsiveFront
.
clearTouchEventsOverride
(
)
;
reloadNeeded
|
=
await
this
.
responsiveFront
.
clearMetaViewportOverride
(
)
;
}
return
reloadNeeded
;
}
async
updateScreenOrientation
(
type
angle
isViewportRotated
=
false
)
{
const
simulateOrientationChangeSupported
=
await
this
.
currentTarget
.
actorHasMethod
(
"
responsive
"
"
simulateScreenOrientationChange
"
)
;
if
(
simulateOrientationChangeSupported
)
{
await
this
.
responsiveFront
.
simulateScreenOrientationChange
(
type
angle
isViewportRotated
)
;
}
if
(
!
isViewportRotated
)
{
this
.
emit
(
"
only
-
viewport
-
orientation
-
changed
"
)
;
}
}
updateUIAlignment
(
leftAlignmentEnabled
)
{
this
.
browserContainerEl
.
classList
.
toggle
(
"
left
-
aligned
"
leftAlignmentEnabled
)
;
}
updateViewportSize
(
width
height
)
{
if
(
!
this
.
isBrowserUIEnabled
)
{
return
;
}
const
zoom
=
this
.
tab
.
linkedBrowser
.
fullZoom
;
const
scaledWidth
=
width
*
zoom
;
const
scaledHeight
=
height
*
zoom
;
this
.
browserStackEl
.
style
.
setProperty
(
"
-
-
rdm
-
width
"
{
scaledWidth
}
px
)
;
this
.
browserStackEl
.
style
.
setProperty
(
"
-
-
rdm
-
height
"
{
scaledHeight
}
px
)
;
}
getViewportSize
(
)
{
if
(
!
this
.
isBrowserUIEnabled
)
{
return
this
.
toolWindow
.
getViewportSize
(
)
;
}
return
this
.
rdmFrame
.
contentWindow
.
getViewportSize
(
)
;
}
async
setViewportSize
(
size
)
{
await
this
.
inited
;
if
(
!
this
.
isBrowserUIEnabled
)
{
this
.
toolWindow
.
setViewportSize
(
size
)
;
return
;
}
const
{
width
height
}
=
size
;
this
.
updateViewportSize
(
width
height
)
;
}
getViewportBrowser
(
)
{
if
(
!
this
.
isBrowserUIEnabled
)
{
return
this
.
toolWindow
.
getViewportBrowser
(
)
;
}
return
this
.
tab
.
linkedBrowser
;
}
getViewportMessageManager
(
)
{
return
this
.
getViewportBrowser
(
)
.
messageManager
;
}
getInitialViewportOrientation
(
viewport
)
{
return
getOrientation
(
viewport
viewport
)
;
}
getBrowserWindow
(
)
{
if
(
!
this
.
isBrowserUIEnabled
)
{
return
this
.
toolWindow
;
}
return
this
.
browserWindow
;
}
async
onTargetAvailable
(
{
targetFront
}
)
{
this
.
responsiveFront
=
await
targetFront
.
getFront
(
"
responsive
"
)
;
await
this
.
restoreActorState
(
)
;
}
async
onRemotenessChange
(
event
)
{
const
isTargetSwitchingEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
target
-
switching
.
enabled
"
false
)
;
if
(
isTargetSwitchingEnabled
&
&
this
.
isBrowserUIEnabled
)
{
const
newTarget
=
await
this
.
client
.
mainRoot
.
getTab
(
)
;
await
this
.
targetList
.
switchToTarget
(
newTarget
)
;
}
else
{
const
{
browserWindow
tab
}
=
this
;
this
.
manager
.
closeIfNeeded
(
browserWindow
tab
{
reason
:
event
.
type
}
)
;
}
}
}
module
.
exports
=
ResponsiveUI
;
