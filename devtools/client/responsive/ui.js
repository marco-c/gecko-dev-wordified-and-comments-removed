"
use
strict
"
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
getOrientation
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
responsive
/
utils
/
orientation
.
js
"
)
;
const
Constants
=
require
(
"
resource
:
/
/
devtools
/
client
/
responsive
/
constants
.
js
"
)
;
const
{
CommandsFactory
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
commands
/
commands
-
factory
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
throttlingProfiles
"
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
throttling
/
profiles
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
message
"
"
resource
:
/
/
devtools
/
client
/
responsive
/
utils
/
message
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
showNotification
"
"
resource
:
/
/
devtools
/
client
/
responsive
/
utils
/
notification
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PriorityLevels
"
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
NotificationBox
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
l10n
"
"
resource
:
/
/
devtools
/
client
/
responsive
/
utils
/
l10n
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
resource
:
/
/
devtools
/
shared
/
async
-
storage
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
captureAndSaveScreenshot
"
"
resource
:
/
/
devtools
/
client
/
shared
/
screenshot
.
js
"
true
)
;
const
RELOAD_CONDITION_PREF_PREFIX
=
"
devtools
.
responsive
.
reloadConditions
.
"
;
const
RELOAD_NOTIFICATION_PREF
=
"
devtools
.
responsive
.
reloadNotification
.
enabled
"
;
const
USE_DYNAMIC_TOOLBAR_PREF
=
"
devtools
.
responsive
.
dynamicToolbar
.
enabled
"
;
const
DYNAMIC_TOOLBAR_MAX_HEIGHT
=
40
;
function
debug
(
_msg
)
{
}
class
ResponsiveUI
{
constructor
(
manager
window
tab
)
{
this
.
manager
=
manager
;
this
.
browserWindow
=
window
;
this
.
tab
=
tab
;
this
.
destroying
=
false
;
this
.
destroyed
=
false
;
this
.
rdmFrame
=
null
;
this
.
onResizeDrag
=
this
.
onResizeDrag
.
bind
(
this
)
;
this
.
onResizeStart
=
this
.
onResizeStart
.
bind
(
this
)
;
this
.
onResizeStop
=
this
.
onResizeStop
.
bind
(
this
)
;
this
.
onTargetAvailable
=
this
.
onTargetAvailable
.
bind
(
this
)
;
this
.
onContentScrolled
=
this
.
onContentScrolled
.
bind
(
this
)
;
this
.
networkFront
=
null
;
const
{
promise
resolve
}
=
Promise
.
withResolvers
(
)
;
this
.
initialized
=
promise
;
this
.
resolveInited
=
resolve
;
this
.
dynamicToolbar
=
null
;
EventEmitter
.
decorate
(
this
)
;
}
get
toolWindow
(
)
{
return
this
.
rdmFrame
.
contentWindow
;
}
get
docShell
(
)
{
return
this
.
toolWindow
.
docShell
;
}
get
viewportElement
(
)
{
return
this
.
browserStackEl
.
querySelector
(
"
browser
"
)
;
}
get
currentTarget
(
)
{
return
this
.
commands
.
targetCommand
.
targetFront
;
}
get
watcherFront
(
)
{
return
this
.
resourceCommand
.
watcherFront
;
}
async
initialize
(
)
{
debug
(
"
Init
start
"
)
;
this
.
initRDMFrame
(
)
;
this
.
hideBrowserUI
(
)
;
this
.
tab
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
browserWindow
.
addEventListener
(
"
unload
"
this
)
;
this
.
rdmFrame
.
contentWindow
.
addEventListener
(
"
message
"
this
)
;
this
.
tab
.
linkedBrowser
.
enterResponsiveMode
(
)
;
this
.
browserWindow
.
addEventListener
(
"
FullZoomChange
"
this
)
;
debug
(
"
Wait
until
RDP
server
connect
"
)
;
await
this
.
connectToServer
(
)
;
await
this
.
restoreUIState
(
)
;
this
.
showBrowserUI
(
)
;
message
.
post
(
this
.
toolWindow
"
post
-
init
"
)
;
debug
(
"
Init
done
"
)
;
this
.
resolveInited
(
)
;
}
initRDMFrame
(
)
{
const
{
document
:
doc
gBrowser
}
=
this
.
browserWindow
;
const
rdmFrame
=
doc
.
createElement
(
"
iframe
"
)
;
rdmFrame
.
src
=
"
chrome
:
/
/
devtools
/
content
/
responsive
/
toolbar
.
xhtml
"
;
rdmFrame
.
classList
.
add
(
"
rdm
-
toolbar
"
)
;
this
.
dynamicToolbar
=
doc
.
createElement
(
"
div
"
)
;
this
.
dynamicToolbar
.
classList
.
add
(
"
rdm
-
dynamic
-
toolbar
"
"
dynamic
-
toolbar
"
)
;
this
.
dynamicToolbar
.
style
.
visibility
=
"
hidden
"
;
if
(
Services
.
prefs
.
getBoolPref
(
USE_DYNAMIC_TOOLBAR_PREF
)
)
{
this
.
dynamicToolbar
.
style
.
visibility
=
"
visible
"
;
this
.
dynamicToolbar
.
style
.
height
=
DYNAMIC_TOOLBAR_MAX_HEIGHT
+
"
px
"
;
InspectorUtils
.
setDynamicToolbarMaxHeight
(
this
.
tab
.
linkedBrowser
.
browsingContext
DYNAMIC_TOOLBAR_MAX_HEIGHT
)
;
InspectorUtils
.
setVerticalClipping
(
this
.
tab
.
linkedBrowser
.
browsingContext
-
DYNAMIC_TOOLBAR_MAX_HEIGHT
)
;
}
const
resizeHandle
=
doc
.
createElement
(
"
div
"
)
;
resizeHandle
.
classList
.
add
(
"
rdm
-
viewport
-
resize
-
handle
"
"
viewport
-
resize
-
handle
"
)
;
const
resizeHandleX
=
doc
.
createElement
(
"
div
"
)
;
resizeHandleX
.
classList
.
add
(
"
rdm
-
viewport
-
resize
-
handle
"
"
viewport
-
horizontal
-
resize
-
handle
"
)
;
const
resizeHandleY
=
doc
.
createElement
(
"
div
"
)
;
resizeHandleY
.
classList
.
add
(
"
rdm
-
viewport
-
resize
-
handle
"
"
viewport
-
vertical
-
resize
-
handle
"
)
;
this
.
browserContainerEl
=
gBrowser
.
getBrowserContainer
(
gBrowser
.
getBrowserForTab
(
this
.
tab
)
)
;
this
.
browserStackEl
=
this
.
browserContainerEl
.
querySelector
(
"
.
browserStack
"
)
;
this
.
browserContainerEl
.
classList
.
add
(
"
responsive
-
mode
"
)
;
this
.
browserContainerEl
.
prepend
(
rdmFrame
)
;
this
.
browserStackEl
.
append
(
this
.
dynamicToolbar
resizeHandle
resizeHandleX
resizeHandleY
)
;
message
.
wait
(
rdmFrame
.
contentWindow
"
script
-
init
"
)
.
then
(
async
(
)
=
>
{
message
.
post
(
rdmFrame
.
contentWindow
"
init
"
)
;
message
.
wait
(
rdmFrame
.
contentWindow
"
init
:
done
"
)
.
then
(
(
)
=
>
{
rdmFrame
.
contentWindow
.
addInitialViewport
(
{
userContextId
:
this
.
tab
.
userContextId
}
)
;
}
)
;
}
)
;
this
.
rdmFrame
=
rdmFrame
;
this
.
resizeHandle
=
resizeHandle
;
this
.
resizeHandle
.
addEventListener
(
"
mousedown
"
this
.
onResizeStart
)
;
this
.
resizeHandleX
=
resizeHandleX
;
this
.
resizeHandleX
.
addEventListener
(
"
mousedown
"
this
.
onResizeStart
)
;
this
.
resizeHandleY
=
resizeHandleY
;
this
.
resizeHandleY
.
addEventListener
(
"
mousedown
"
this
.
onResizeStart
)
;
this
.
resizeToolbarObserver
=
new
this
.
browserWindow
.
ResizeObserver
(
entries
=
>
{
for
(
const
entry
of
entries
)
{
this
.
rdmFrame
.
classList
.
toggle
(
"
accomodate
-
ua
"
entry
.
contentBoxSize
[
0
]
.
inlineSize
<
=
800
)
;
}
}
)
;
this
.
resizeToolbarObserver
.
observe
(
this
.
browserStackEl
)
;
}
async
destroy
(
options
)
{
if
(
this
.
destroying
)
{
return
false
;
}
this
.
destroying
=
true
;
const
isTabDestroyed
=
!
this
.
tab
.
linkedBrowser
;
const
isWindowClosing
=
options
?
.
reason
=
=
=
"
unload
"
|
|
isTabDestroyed
;
const
isTabContentDestroying
=
isWindowClosing
|
|
options
?
.
reason
=
=
=
"
TabClose
"
;
if
(
!
isTabContentDestroying
)
{
await
this
.
initialized
;
await
Promise
.
all
(
[
this
.
updateScreenOrientation
(
"
landscape
-
primary
"
0
)
this
.
updateMaxTouchPointsEnabled
(
false
)
]
)
;
this
.
hideBrowserUI
(
)
;
await
this
.
updateNetworkThrottling
(
)
;
}
this
.
tab
.
removeEventListener
(
"
TabClose
"
this
)
;
this
.
browserWindow
.
removeEventListener
(
"
unload
"
this
)
;
this
.
tab
.
linkedBrowser
.
leaveResponsiveMode
(
)
;
this
.
browserWindow
.
removeEventListener
(
"
FullZoomChange
"
this
)
;
this
.
rdmFrame
.
contentWindow
.
removeEventListener
(
"
message
"
this
)
;
this
.
resizeToolbarObserver
.
unobserve
(
this
.
browserStackEl
)
;
this
.
rdmFrame
.
contentWindow
.
destroy
(
)
;
this
.
rdmFrame
.
remove
(
)
;
this
.
resizeHandle
.
remove
(
)
;
this
.
resizeHandleX
.
remove
(
)
;
this
.
resizeHandleY
.
remove
(
)
;
this
.
dynamicToolbar
.
remove
(
)
;
this
.
browserContainerEl
.
classList
.
remove
(
"
responsive
-
mode
"
)
;
this
.
browserStackEl
.
style
.
removeProperty
(
"
-
-
rdm
-
width
"
)
;
this
.
browserStackEl
.
style
.
removeProperty
(
"
-
-
rdm
-
height
"
)
;
this
.
browserStackEl
.
style
.
removeProperty
(
"
-
-
rdm
-
zoom
"
)
;
if
(
!
isTabContentDestroying
)
{
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
null
)
;
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
const
reloadOnTouchSimulationChange
=
this
.
reloadOnChange
(
"
touchSimulation
"
)
&
&
!
reloadNeeded
;
await
this
.
updateTouchSimulation
(
null
reloadOnTouchSimulationChange
)
;
if
(
reloadNeeded
)
{
await
this
.
reloadBrowser
(
)
;
}
this
.
commands
.
targetCommand
.
unwatchTargets
(
{
types
:
[
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
onTargetAvailable
}
)
;
this
.
resourceCommand
.
unwatchResources
(
[
this
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
]
{
onAvailable
:
this
.
onNetworkResourceAvailable
}
)
;
this
.
commands
.
targetCommand
.
destroy
(
)
;
}
this
.
showBrowserUI
(
)
;
this
.
browserContainerEl
=
null
;
this
.
browserStackEl
=
null
;
this
.
browserWindow
=
null
;
this
.
tab
=
null
;
this
.
initialized
=
null
;
this
.
rdmFrame
=
null
;
this
.
resizeHandle
=
null
;
this
.
resizeHandleX
=
null
;
this
.
resizeHandleY
=
null
;
this
.
dynamicToolbar
=
null
;
this
.
resizeToolbarObserver
=
null
;
const
commandsDestroyed
=
this
.
commands
.
destroy
(
)
;
if
(
!
isTabContentDestroying
)
{
await
commandsDestroyed
;
}
this
.
commands
=
null
;
this
.
destroyed
=
true
;
return
true
;
}
async
connectToServer
(
)
{
this
.
commands
=
await
CommandsFactory
.
forTab
(
this
.
tab
)
;
this
.
resourceCommand
=
this
.
commands
.
resourceCommand
;
await
this
.
commands
.
targetCommand
.
startListening
(
)
;
await
this
.
commands
.
targetCommand
.
watchTargets
(
{
types
:
[
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
onTargetAvailable
}
)
;
await
this
.
resourceCommand
.
watchResources
(
[
this
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
]
{
onAvailable
:
this
.
onNetworkResourceAvailable
}
)
;
this
.
networkFront
=
await
this
.
watcherFront
.
getNetworkParentActor
(
)
;
}
showReloadNotification
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
RELOAD_NOTIFICATION_PREF
false
)
)
{
showNotification
(
this
.
browserWindow
this
.
tab
{
msg
:
l10n
.
getFormatStr
(
"
responsive
.
reloadNotification
.
description2
"
)
}
)
;
Services
.
prefs
.
setBoolPref
(
RELOAD_NOTIFICATION_PREF
false
)
;
}
}
reloadOnChange
(
id
)
{
this
.
showReloadNotification
(
)
;
const
pref
=
RELOAD_CONDITION_PREF_PREFIX
+
id
;
return
Services
.
prefs
.
getBoolPref
(
pref
false
)
;
}
hideBrowserUI
(
)
{
this
.
tab
.
linkedBrowser
.
style
.
visibility
=
"
hidden
"
;
this
.
resizeHandle
.
style
.
visibility
=
"
hidden
"
;
}
showBrowserUI
(
)
{
this
.
tab
.
linkedBrowser
.
style
.
removeProperty
(
"
visibility
"
)
;
this
.
resizeHandle
.
style
.
removeProperty
(
"
visibility
"
)
;
}
handleEvent
(
event
)
{
const
{
browserWindow
tab
}
=
this
;
switch
(
event
.
type
)
{
case
"
message
"
:
this
.
handleMessage
(
event
)
;
break
;
case
"
FullZoomChange
"
:
const
{
width
height
}
=
this
.
getViewportSize
(
)
;
this
.
updateViewportSize
(
width
height
)
;
break
;
case
"
TabClose
"
:
case
"
unload
"
:
this
.
manager
.
closeIfNeeded
(
browserWindow
tab
{
reason
:
event
.
type
}
)
;
break
;
}
}
handleMessage
(
event
)
{
if
(
event
.
origin
!
=
=
"
chrome
:
/
/
devtools
"
)
{
return
;
}
switch
(
event
.
data
.
type
)
{
case
"
change
-
device
"
:
this
.
onChangeDevice
(
event
)
;
break
;
case
"
change
-
network
-
throttling
"
:
this
.
onChangeNetworkThrottling
(
event
)
;
break
;
case
"
change
-
pixel
-
ratio
"
:
this
.
onChangePixelRatio
(
event
)
;
break
;
case
"
change
-
touch
-
simulation
"
:
this
.
onChangeTouchSimulation
(
event
)
;
break
;
case
"
change
-
user
-
agent
"
:
this
.
onChangeUserAgent
(
event
)
;
break
;
case
"
exit
"
:
this
.
onExit
(
)
;
break
;
case
"
remove
-
device
-
association
"
:
this
.
onRemoveDeviceAssociation
(
event
)
;
break
;
case
"
viewport
-
orientation
-
change
"
:
this
.
onRotateViewport
(
event
)
;
break
;
case
"
viewport
-
resize
"
:
this
.
onResizeViewport
(
event
)
;
break
;
case
"
screenshot
"
:
this
.
onScreenshot
(
)
;
break
;
case
"
toggle
-
left
-
alignment
"
:
this
.
onToggleLeftAlignment
(
event
)
;
break
;
case
"
update
-
device
-
modal
"
:
this
.
onUpdateDeviceModal
(
event
)
;
break
;
}
}
async
onChangeDevice
(
event
)
{
const
{
pixelRatio
touch
userAgent
}
=
event
.
data
.
device
;
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
pixelRatio
)
;
const
{
device
viewport
}
=
event
.
data
;
const
{
type
angle
}
=
getOrientation
(
device
viewport
)
;
await
this
.
updateScreenOrientation
(
type
angle
)
;
await
this
.
updateMaxTouchPointsEnabled
(
touch
)
;
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
userAgent
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
const
reloadOnTouchSimulationChange
=
this
.
reloadOnChange
(
"
touchSimulation
"
)
&
&
!
reloadNeeded
;
await
this
.
updateTouchSimulation
(
touch
reloadOnTouchSimulationChange
)
;
if
(
reloadNeeded
)
{
this
.
reloadBrowser
(
)
;
}
this
.
emitForTests
(
"
device
-
changed
"
{
reloadTriggered
:
reloadNeeded
|
|
reloadOnTouchSimulationChange
}
)
;
}
async
onChangeNetworkThrottling
(
event
)
{
const
{
enabled
profile
}
=
event
.
data
;
await
this
.
updateNetworkThrottling
(
enabled
profile
)
;
this
.
emit
(
"
network
-
throttling
-
changed
"
)
;
}
onChangePixelRatio
(
event
)
{
const
{
pixelRatio
}
=
event
.
data
;
this
.
updateDPPX
(
pixelRatio
)
;
}
async
onChangeTouchSimulation
(
event
)
{
const
{
enabled
}
=
event
.
data
;
await
this
.
updateMaxTouchPointsEnabled
(
enabled
)
;
await
this
.
updateTouchSimulation
(
enabled
this
.
reloadOnChange
(
"
touchSimulation
"
)
)
;
this
.
emit
(
"
touch
-
simulation
-
changed
"
)
;
}
async
onChangeUserAgent
(
event
)
{
const
{
userAgent
}
=
event
.
data
;
const
reloadNeeded
=
(
await
this
.
updateUserAgent
(
userAgent
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
if
(
reloadNeeded
)
{
this
.
reloadBrowser
(
)
;
}
this
.
emit
(
"
user
-
agent
-
changed
"
)
;
}
onExit
(
)
{
const
{
browserWindow
tab
}
=
this
;
this
.
manager
.
closeIfNeeded
(
browserWindow
tab
)
;
}
async
onRemoveDeviceAssociation
(
event
)
{
const
{
resetProfile
}
=
event
.
data
;
if
(
resetProfile
)
{
let
reloadNeeded
=
false
;
await
this
.
updateDPPX
(
null
)
;
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
const
reloadOnTouchSimulationChange
=
this
.
reloadOnChange
(
"
touchSimulation
"
)
&
&
!
reloadNeeded
;
await
this
.
updateTouchSimulation
(
null
reloadOnTouchSimulationChange
)
;
if
(
reloadNeeded
)
{
this
.
reloadBrowser
(
)
;
}
}
this
.
emitForTests
(
"
device
-
association
-
removed
"
)
;
}
onResizeDrag
(
{
screenX
screenY
}
)
{
if
(
!
this
.
isResizing
|
|
!
this
.
rdmFrame
.
contentWindow
)
{
return
;
}
const
zoom
=
this
.
tab
.
linkedBrowser
.
fullZoom
;
let
deltaX
=
(
screenX
-
this
.
lastScreenX
)
/
zoom
;
let
deltaY
=
(
screenY
-
this
.
lastScreenY
)
/
zoom
;
const
leftAlignmentEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
leftAlignViewport
.
enabled
"
false
)
;
if
(
!
leftAlignmentEnabled
)
{
deltaX
=
deltaX
*
2
;
}
if
(
this
.
ignoreX
)
{
deltaX
=
0
;
}
if
(
this
.
ignoreY
)
{
deltaY
=
0
;
}
const
viewportSize
=
this
.
getViewportSize
(
)
;
let
width
=
Math
.
round
(
viewportSize
.
width
+
deltaX
)
;
let
height
=
Math
.
round
(
viewportSize
.
height
+
deltaY
)
;
if
(
width
<
Constants
.
MIN_VIEWPORT_DIMENSION
)
{
width
=
Constants
.
MIN_VIEWPORT_DIMENSION
;
}
else
if
(
width
!
=
viewportSize
.
width
)
{
this
.
lastScreenX
=
screenX
;
}
if
(
height
<
Constants
.
MIN_VIEWPORT_DIMENSION
)
{
height
=
Constants
.
MIN_VIEWPORT_DIMENSION
;
}
else
if
(
height
!
=
viewportSize
.
height
)
{
this
.
lastScreenY
=
screenY
;
}
this
.
rdmFrame
.
contentWindow
.
setViewportSize
(
{
width
height
}
)
;
this
.
updateViewportSize
(
width
height
)
;
if
(
this
.
rdmFrame
.
contentWindow
.
getAssociatedDevice
(
)
)
{
this
.
rdmFrame
.
contentWindow
.
clearDeviceAssociation
(
)
;
}
}
onResizeStart
(
{
target
screenX
screenY
}
)
{
this
.
browserWindow
.
addEventListener
(
"
mousemove
"
this
.
onResizeDrag
true
)
;
this
.
browserWindow
.
addEventListener
(
"
mouseup
"
this
.
onResizeStop
true
)
;
this
.
isResizing
=
true
;
this
.
lastScreenX
=
screenX
;
this
.
lastScreenY
=
screenY
;
this
.
ignoreX
=
target
=
=
=
this
.
resizeHandleY
;
this
.
ignoreY
=
target
=
=
=
this
.
resizeHandleX
;
}
onResizeStop
(
)
{
this
.
browserWindow
.
removeEventListener
(
"
mousemove
"
this
.
onResizeDrag
true
)
;
this
.
browserWindow
.
removeEventListener
(
"
mouseup
"
this
.
onResizeStop
true
)
;
this
.
isResizing
=
false
;
this
.
lastScreenX
=
0
;
this
.
lastScreenY
=
0
;
this
.
ignoreX
=
false
;
this
.
ignoreY
=
false
;
this
.
emit
(
"
viewport
-
resize
-
dragend
"
)
;
}
onResizeViewport
(
event
)
{
const
{
width
height
}
=
event
.
data
;
this
.
updateViewportSize
(
width
height
)
;
this
.
emit
(
"
viewport
-
resize
"
{
width
height
}
)
;
}
async
onRotateViewport
(
event
)
{
const
{
orientationType
:
type
angle
isViewportRotated
}
=
event
.
data
;
await
this
.
updateScreenOrientation
(
type
angle
isViewportRotated
)
;
}
async
onScreenshot
(
)
{
const
messages
=
await
captureAndSaveScreenshot
(
this
.
currentTarget
this
.
browserWindow
)
;
const
priorityMap
=
{
error
:
PriorityLevels
.
PRIORITY_CRITICAL_HIGH
warn
:
PriorityLevels
.
PRIORITY_WARNING_HIGH
}
;
for
(
const
{
text
level
}
of
messages
)
{
if
(
level
!
=
=
"
warn
"
&
&
level
!
=
=
"
error
"
)
{
continue
;
}
showNotification
(
this
.
browserWindow
this
.
tab
{
msg
:
text
priority
:
priorityMap
[
level
]
}
)
;
}
message
.
post
(
this
.
rdmFrame
.
contentWindow
"
screenshot
-
captured
"
)
;
}
onToggleLeftAlignment
(
event
)
{
this
.
updateUIAlignment
(
event
.
data
.
leftAlignmentEnabled
)
;
}
onUpdateDeviceModal
(
event
)
{
this
.
rdmFrame
.
classList
.
toggle
(
"
device
-
modal
-
opened
"
event
.
data
.
isOpen
)
;
}
async
hasDeviceState
(
)
{
const
deviceState
=
await
asyncStorage
.
getItem
(
"
devtools
.
responsive
.
deviceState
"
)
;
return
!
!
deviceState
;
}
async
restoreUIState
(
)
{
const
leftAlignmentEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
leftAlignViewport
.
enabled
"
false
)
;
this
.
updateUIAlignment
(
leftAlignmentEnabled
)
;
const
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
height
"
0
)
;
const
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
width
"
0
)
;
this
.
updateViewportSize
(
width
height
)
;
}
async
restoreActorState
(
isTargetSwitching
)
{
this
.
tab
.
linkedBrowser
.
enterResponsiveMode
(
)
;
if
(
isTargetSwitching
&
&
this
.
commands
.
targetCommand
.
targetFront
.
targetForm
.
followWindowGlobalLifeCycle
)
{
return
;
}
const
hasDeviceState
=
await
this
.
hasDeviceState
(
)
;
if
(
hasDeviceState
)
{
return
;
}
const
height
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
height
"
0
)
;
const
pixelRatio
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
pixelRatio
"
0
)
;
const
touchSimulationEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
responsive
.
touchSimulation
.
enabled
"
false
)
;
const
userAgent
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
responsive
.
userAgent
"
"
"
)
;
const
width
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
responsive
.
viewport
.
width
"
0
)
;
const
{
type
angle
}
=
this
.
commands
.
targetConfigurationCommand
.
configuration
.
rdmPaneOrientation
|
|
this
.
getInitialViewportOrientation
(
{
width
height
}
)
;
await
this
.
updateDPPX
(
pixelRatio
)
;
await
this
.
updateScreenOrientation
(
type
angle
)
;
await
this
.
updateMaxTouchPointsEnabled
(
touchSimulationEnabled
)
;
if
(
touchSimulationEnabled
)
{
await
this
.
updateTouchSimulation
(
touchSimulationEnabled
)
;
}
let
reloadNeeded
=
false
;
if
(
userAgent
)
{
reloadNeeded
|
=
(
await
this
.
updateUserAgent
(
userAgent
)
)
&
&
this
.
reloadOnChange
(
"
userAgent
"
)
;
}
if
(
reloadNeeded
)
{
await
this
.
reloadBrowser
(
)
;
}
}
async
updateDPPX
(
dppx
=
null
)
{
await
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
overrideDPPX
:
dppx
}
)
;
}
async
updateNetworkThrottling
(
enabled
profile
)
{
if
(
!
enabled
)
{
await
this
.
networkFront
.
clearNetworkThrottling
(
)
;
await
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
setTabOffline
:
false
}
)
;
return
false
;
}
const
data
=
throttlingProfiles
.
profiles
.
find
(
(
{
id
}
)
=
>
id
=
=
profile
)
;
const
{
download
upload
latency
id
}
=
data
;
await
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
setTabOffline
:
id
=
=
=
throttlingProfiles
.
PROFILE_CONSTANTS
.
OFFLINE
}
)
;
await
this
.
networkFront
.
setNetworkThrottling
(
{
downloadThroughput
:
download
uploadThroughput
:
upload
latency
}
)
;
return
false
;
}
async
updateUserAgent
(
userAgent
)
{
const
getConfigurationCustomUserAgent
=
(
)
=
>
this
.
commands
.
targetConfigurationCommand
.
configuration
.
customUserAgent
|
|
"
"
;
const
previousCustomUserAgent
=
getConfigurationCustomUserAgent
(
)
;
await
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
customUserAgent
:
userAgent
}
)
;
const
updatedUserAgent
=
getConfigurationCustomUserAgent
(
)
;
return
previousCustomUserAgent
!
=
=
updatedUserAgent
;
}
async
updateTouchSimulation
(
enabled
reloadOnTouchSimulationToggle
)
{
await
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
touchEventsOverride
:
enabled
?
"
enabled
"
:
null
reloadOnTouchSimulationToggle
}
)
;
}
async
updateScreenOrientation
(
type
angle
isViewportRotated
=
false
)
{
await
this
.
commands
.
targetConfigurationCommand
.
simulateScreenOrientationChange
(
{
type
angle
isViewportRotated
}
)
;
}
async
updateMaxTouchPointsEnabled
(
touchSimulationEnabled
)
{
return
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
rdmPaneMaxTouchPoints
:
touchSimulationEnabled
?
1
:
0
}
)
;
}
updateUIAlignment
(
leftAlignmentEnabled
)
{
this
.
browserContainerEl
.
classList
.
toggle
(
"
left
-
aligned
"
leftAlignmentEnabled
)
;
}
updateViewportSize
(
width
height
)
{
const
zoom
=
this
.
tab
.
linkedBrowser
.
fullZoom
;
this
.
browserStackEl
.
style
.
setProperty
(
"
-
-
rdm
-
width
"
{
width
}
px
)
;
this
.
browserStackEl
.
style
.
setProperty
(
"
-
-
rdm
-
height
"
{
height
}
px
)
;
this
.
browserStackEl
.
style
.
setProperty
(
"
-
-
rdm
-
zoom
"
zoom
)
;
this
.
emit
(
"
content
-
resize
"
{
width
height
}
)
;
}
getViewportSize
(
)
{
if
(
this
.
toolWindow
.
getViewportSize
)
{
return
this
.
toolWindow
.
getViewportSize
(
)
;
}
return
{
width
:
0
height
:
0
}
;
}
async
setViewportSize
(
size
)
{
await
this
.
initialized
;
let
{
width
height
}
=
size
;
if
(
!
size
.
width
)
{
width
=
this
.
getViewportSize
(
)
.
width
;
}
if
(
!
size
.
height
)
{
height
=
this
.
getViewportSize
(
)
.
height
;
}
this
.
rdmFrame
.
contentWindow
.
setViewportSize
(
{
width
height
}
)
;
this
.
updateViewportSize
(
width
height
)
;
}
getViewportBrowser
(
)
{
return
this
.
tab
.
linkedBrowser
;
}
getViewportMessageManager
(
)
{
return
this
.
getViewportBrowser
(
)
.
messageManager
;
}
getInitialViewportOrientation
(
viewport
)
{
return
getOrientation
(
viewport
viewport
)
;
}
getBrowserWindow
(
)
{
return
this
.
browserWindow
;
}
clamp
(
min
max
value
)
{
return
Math
.
min
(
Math
.
max
(
value
min
)
max
)
;
}
onContentScrolled
(
deltaY
)
{
const
currentHeight
=
parseInt
(
this
.
dynamicToolbar
.
style
.
height
10
)
;
const
newHeight
=
this
.
clamp
(
0
DYNAMIC_TOOLBAR_MAX_HEIGHT
currentHeight
+
deltaY
)
;
this
.
dynamicToolbar
.
style
.
height
=
newHeight
+
"
px
"
;
const
offset
=
newHeight
-
DYNAMIC_TOOLBAR_MAX_HEIGHT
;
InspectorUtils
.
setVerticalClipping
(
this
.
tab
.
linkedBrowser
.
browsingContext
offset
)
;
}
async
onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
{
if
(
this
.
destroying
)
{
return
;
}
if
(
targetFront
.
isTopLevel
)
{
await
this
.
restoreActorState
(
isTargetSwitching
)
;
this
.
emitForTests
(
"
responsive
-
ui
-
target
-
switch
-
done
"
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
USE_DYNAMIC_TOOLBAR_PREF
)
)
{
targetFront
.
on
(
"
contentScrolled
"
this
.
onContentScrolled
)
;
}
}
async
setElementPickerState
(
state
pickerType
)
{
this
.
commands
.
responsiveCommand
.
setElementPickerState
(
state
pickerType
)
;
}
onNetworkResourceAvailable
(
)
{
}
async
reloadBrowser
(
)
{
await
this
.
commands
.
targetCommand
.
reloadTopLevelTarget
(
)
;
}
}
module
.
exports
=
ResponsiveUI
;
