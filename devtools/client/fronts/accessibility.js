"
use
strict
"
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
accessibleSpec
accessibleWalkerSpec
accessibilitySpec
parentAccessibilitySpec
simulatorSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
accessibility
"
)
;
const
events
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
BROWSER_TOOLBOX_FISSION_ENABLED
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
browsertoolbox
.
fission
"
false
)
;
class
AccessibleFront
extends
FrontClassWithSpec
(
accessibleSpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
before
(
"
audited
"
this
.
audited
.
bind
(
this
)
)
;
this
.
before
(
"
name
-
change
"
this
.
nameChange
.
bind
(
this
)
)
;
this
.
before
(
"
value
-
change
"
this
.
valueChange
.
bind
(
this
)
)
;
this
.
before
(
"
description
-
change
"
this
.
descriptionChange
.
bind
(
this
)
)
;
this
.
before
(
"
shortcut
-
change
"
this
.
shortcutChange
.
bind
(
this
)
)
;
this
.
before
(
"
reorder
"
this
.
reorder
.
bind
(
this
)
)
;
this
.
before
(
"
text
-
change
"
this
.
textChange
.
bind
(
this
)
)
;
this
.
before
(
"
index
-
in
-
parent
-
change
"
this
.
indexInParentChange
.
bind
(
this
)
)
;
this
.
before
(
"
states
-
change
"
this
.
statesChange
.
bind
(
this
)
)
;
this
.
before
(
"
actions
-
change
"
this
.
actionsChange
.
bind
(
this
)
)
;
this
.
before
(
"
attributes
-
change
"
this
.
attributesChange
.
bind
(
this
)
)
;
}
marshallPool
(
)
{
return
this
.
getParent
(
)
;
}
get
useChildTargetToFetchChildren
(
)
{
if
(
!
BROWSER_TOOLBOX_FISSION_ENABLED
&
&
this
.
targetFront
.
isParentProcess
)
{
return
false
;
}
return
this
.
_form
.
useChildTargetToFetchChildren
|
|
this
.
_form
.
remoteFrame
;
}
get
role
(
)
{
return
this
.
_form
.
role
;
}
get
name
(
)
{
return
this
.
_form
.
name
;
}
get
value
(
)
{
return
this
.
_form
.
value
;
}
get
description
(
)
{
return
this
.
_form
.
description
;
}
get
keyboardShortcut
(
)
{
return
this
.
_form
.
keyboardShortcut
;
}
get
childCount
(
)
{
return
this
.
_form
.
childCount
;
}
get
domNodeType
(
)
{
return
this
.
_form
.
domNodeType
;
}
get
indexInParent
(
)
{
return
this
.
_form
.
indexInParent
;
}
get
states
(
)
{
return
this
.
_form
.
states
;
}
get
actions
(
)
{
return
this
.
_form
.
actions
;
}
get
attributes
(
)
{
return
this
.
_form
.
attributes
;
}
get
checks
(
)
{
return
this
.
_form
.
checks
;
}
form
(
form
)
{
this
.
actorID
=
form
.
actor
;
this
.
_form
=
this
.
_form
|
|
{
}
;
Object
.
assign
(
this
.
_form
form
)
;
}
nameChange
(
name
parent
)
{
this
.
_form
.
name
=
name
;
const
accessibilityWalkerFront
=
this
.
getParent
(
)
;
if
(
accessibilityWalkerFront
)
{
events
.
emit
(
accessibilityWalkerFront
"
name
-
change
"
this
parent
)
;
}
}
valueChange
(
value
)
{
this
.
_form
.
value
=
value
;
}
descriptionChange
(
description
)
{
this
.
_form
.
description
=
description
;
}
shortcutChange
(
keyboardShortcut
)
{
this
.
_form
.
keyboardShortcut
=
keyboardShortcut
;
}
reorder
(
childCount
)
{
this
.
_form
.
childCount
=
childCount
;
const
accessibilityWalkerFront
=
this
.
getParent
(
)
;
if
(
accessibilityWalkerFront
)
{
events
.
emit
(
accessibilityWalkerFront
"
reorder
"
this
)
;
}
}
textChange
(
)
{
const
accessibilityWalkerFront
=
this
.
getParent
(
)
;
if
(
accessibilityWalkerFront
)
{
events
.
emit
(
accessibilityWalkerFront
"
text
-
change
"
this
)
;
}
}
indexInParentChange
(
indexInParent
)
{
this
.
_form
.
indexInParent
=
indexInParent
;
}
statesChange
(
states
)
{
this
.
_form
.
states
=
states
;
}
actionsChange
(
actions
)
{
this
.
_form
.
actions
=
actions
;
}
attributesChange
(
attributes
)
{
this
.
_form
.
attributes
=
attributes
;
}
audited
(
checks
)
{
this
.
_form
.
checks
=
this
.
_form
.
checks
|
|
{
}
;
Object
.
assign
(
this
.
_form
.
checks
checks
)
;
}
hydrate
(
)
{
return
super
.
hydrate
(
)
.
then
(
properties
=
>
{
Object
.
assign
(
this
.
_form
properties
)
;
}
)
;
}
async
children
(
)
{
if
(
!
this
.
useChildTargetToFetchChildren
)
{
return
super
.
children
(
)
;
}
const
{
walker
:
domWalkerFront
}
=
await
this
.
targetFront
.
getFront
(
"
inspector
"
)
;
const
node
=
await
domWalkerFront
.
getNodeFromActor
(
this
.
actorID
[
"
rawAccessible
"
"
DOMNode
"
]
)
;
const
{
nodes
:
[
documentNodeFront
]
}
=
await
domWalkerFront
.
children
(
node
)
;
const
accessibilityFront
=
await
documentNodeFront
.
targetFront
.
getFront
(
"
accessibility
"
)
;
return
accessibilityFront
.
accessibleWalkerFront
.
children
(
)
;
}
async
_accumulateSnapshot
(
snapshot
)
{
const
{
childCount
useChildTargetToFetchChildren
}
=
snapshot
;
if
(
childCount
=
=
=
0
)
{
return
snapshot
;
}
if
(
!
useChildTargetToFetchChildren
)
{
const
childSnapshots
=
[
]
;
for
(
const
childSnapshot
of
snapshot
.
children
)
{
childSnapshots
.
push
(
this
.
_accumulateSnapshot
(
childSnapshot
)
)
;
}
await
Promise
.
all
(
childSnapshots
)
;
return
snapshot
;
}
const
inspectorFront
=
await
this
.
targetFront
.
getFront
(
"
inspector
"
)
;
const
frameNodeFront
=
await
inspectorFront
.
getNodeActorFromContentDomReference
(
snapshot
.
contentDOMReference
)
;
delete
snapshot
.
contentDOMReference
;
delete
snapshot
.
useChildTargetToFetchChildren
;
if
(
!
frameNodeFront
)
{
return
snapshot
;
}
const
frameAccessibleFront
=
await
this
.
parentFront
.
getAccessibleFor
(
frameNodeFront
)
;
if
(
!
frameAccessibleFront
)
{
return
snapshot
;
}
const
[
docAccessibleFront
]
=
await
frameAccessibleFront
.
children
(
)
;
const
childSnapshot
=
await
docAccessibleFront
.
snapshot
(
)
;
snapshot
.
children
.
push
(
childSnapshot
)
;
return
snapshot
;
}
async
snapshot
(
)
{
const
snapshot
=
await
super
.
snapshot
(
)
;
await
this
.
_accumulateSnapshot
(
snapshot
)
;
return
snapshot
;
}
}
class
AccessibleWalkerFront
extends
FrontClassWithSpec
(
accessibleWalkerSpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
documentReady
=
this
.
documentReady
.
bind
(
this
)
;
this
.
on
(
"
document
-
ready
"
this
.
documentReady
)
;
}
destroy
(
)
{
this
.
off
(
"
document
-
ready
"
this
.
documentReady
)
;
super
.
destroy
(
)
;
}
form
(
json
)
{
this
.
actorID
=
json
.
actor
;
}
documentReady
(
)
{
if
(
this
.
targetFront
.
isTopLevel
)
{
this
.
emit
(
"
top
-
level
-
document
-
ready
"
)
;
}
}
pick
(
doFocus
)
{
if
(
doFocus
)
{
return
this
.
pickAndFocus
(
)
;
}
return
super
.
pick
(
)
;
}
async
getAncestry
(
accessible
)
{
const
ancestry
=
await
super
.
getAncestry
(
accessible
)
;
if
(
!
BROWSER_TOOLBOX_FISSION_ENABLED
&
&
this
.
targetFront
.
isParentProcess
)
{
return
ancestry
;
}
const
parentTarget
=
await
this
.
targetFront
.
getParentTarget
(
)
;
if
(
!
parentTarget
)
{
return
ancestry
;
}
const
{
walker
:
domWalkerFront
}
=
await
this
.
targetFront
.
getFront
(
"
inspector
"
)
;
const
frameNodeFront
=
(
await
domWalkerFront
.
getRootNode
(
)
)
.
parentNode
(
)
;
const
accessibilityFront
=
await
parentTarget
.
getFront
(
"
accessibility
"
)
;
const
{
accessibleWalkerFront
}
=
accessibilityFront
;
const
frameAccessibleFront
=
await
accessibleWalkerFront
.
getAccessibleFor
(
frameNodeFront
)
;
if
(
!
frameAccessibleFront
)
{
return
Promise
.
reject
(
Can
'
t
get
the
ancestry
for
an
accessible
front
{
accessible
.
actorID
}
.
It
is
in
the
detached
tree
.
)
;
}
ancestry
.
push
(
{
accessible
:
frameAccessibleFront
children
:
await
frameAccessibleFront
.
children
(
)
}
.
.
.
(
await
accessibleWalkerFront
.
getAncestry
(
frameAccessibleFront
)
)
)
;
return
ancestry
;
}
async
audit
(
{
types
onProgress
}
)
{
const
onAudit
=
new
Promise
(
resolve
=
>
{
const
auditEventHandler
=
(
{
type
ancestries
progress
}
)
=
>
{
switch
(
type
)
{
case
"
error
"
:
this
.
off
(
"
audit
-
event
"
auditEventHandler
)
;
resolve
(
{
error
:
true
}
)
;
break
;
case
"
completed
"
:
this
.
off
(
"
audit
-
event
"
auditEventHandler
)
;
resolve
(
{
ancestries
}
)
;
break
;
case
"
progress
"
:
onProgress
(
progress
)
;
break
;
default
:
break
;
}
}
;
this
.
on
(
"
audit
-
event
"
auditEventHandler
)
;
super
.
startAudit
(
{
types
}
)
;
}
)
;
const
audit
=
await
onAudit
;
if
(
audit
.
error
|
|
audit
.
ancestries
.
length
=
=
=
0
)
{
return
audit
;
}
const
parentTarget
=
await
this
.
targetFront
.
getParentTarget
(
)
;
if
(
!
parentTarget
)
{
return
audit
;
}
const
[
docAccessibleFront
]
=
await
this
.
children
(
)
;
let
docAccessibleAncestry
;
try
{
docAccessibleAncestry
=
await
this
.
getAncestry
(
docAccessibleFront
)
;
}
catch
(
e
)
{
return
{
ancestries
:
[
]
}
;
}
for
(
const
ancestry
of
audit
.
ancestries
)
{
ancestry
.
push
(
.
.
.
docAccessibleAncestry
)
;
}
return
audit
;
}
async
_showTabbingOrder
(
startElm
startIndex
)
{
const
{
contentDOMReference
index
}
=
await
super
.
showTabbingOrder
(
startElm
startIndex
)
;
let
elm
;
if
(
contentDOMReference
)
{
const
inspectorFront
=
await
this
.
targetFront
.
getFront
(
"
inspector
"
)
;
elm
=
await
inspectorFront
.
getNodeActorFromContentDomReference
(
contentDOMReference
)
;
}
return
{
elm
index
}
;
}
async
showTabbingOrder
(
startElm
startIndex
)
{
let
{
elm
:
currentElm
index
:
currentIndex
}
=
await
this
.
_showTabbingOrder
(
startElm
startIndex
)
;
while
(
currentElm
)
{
if
(
currentElm
.
useChildTargetToFetchChildren
)
{
const
{
walker
:
domWalkerFront
}
=
await
currentElm
.
targetFront
.
getFront
(
"
inspector
"
)
;
const
{
nodes
:
[
childDocumentNodeFront
]
}
=
await
domWalkerFront
.
children
(
currentElm
)
;
const
{
accessibleWalkerFront
}
=
await
childDocumentNodeFront
.
targetFront
.
getFront
(
"
accessibility
"
)
;
(
{
index
:
currentIndex
}
=
await
accessibleWalkerFront
.
showTabbingOrder
(
childDocumentNodeFront
currentIndex
)
)
;
}
(
{
elm
:
currentElm
index
:
currentIndex
}
=
await
this
.
_showTabbingOrder
(
currentElm
currentIndex
)
)
;
}
return
{
elm
:
currentElm
index
:
currentIndex
}
;
}
}
class
AccessibilityFront
extends
FrontClassWithSpec
(
accessibilitySpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
before
(
"
init
"
this
.
init
.
bind
(
this
)
)
;
this
.
before
(
"
shutdown
"
this
.
shutdown
.
bind
(
this
)
)
;
this
.
formAttributeName
=
"
accessibilityActor
"
;
}
async
initialize
(
)
{
this
.
accessibleWalkerFront
=
await
super
.
getWalker
(
)
;
this
.
simulatorFront
=
await
super
.
getSimulator
(
)
;
const
{
enabled
}
=
await
super
.
bootstrap
(
)
;
this
.
enabled
=
enabled
;
try
{
this
.
_traits
=
await
this
.
getTraits
(
)
;
}
catch
(
e
)
{
this
.
_traits
=
{
}
;
}
}
get
traits
(
)
{
return
this
.
_traits
;
}
init
(
)
{
this
.
enabled
=
true
;
}
shutdown
(
)
{
this
.
enabled
=
false
;
}
}
class
ParentAccessibilityFront
extends
FrontClassWithSpec
(
parentAccessibilitySpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
before
(
"
can
-
be
-
enabled
-
change
"
this
.
canBeEnabled
.
bind
(
this
)
)
;
this
.
before
(
"
can
-
be
-
disabled
-
change
"
this
.
canBeDisabled
.
bind
(
this
)
)
;
this
.
formAttributeName
=
"
parentAccessibilityActor
"
;
}
async
initialize
(
)
{
(
{
canBeEnabled
:
this
.
canBeEnabled
canBeDisabled
:
this
.
canBeDisabled
}
=
await
super
.
bootstrap
(
)
)
;
}
canBeEnabled
(
canBeEnabled
)
{
this
.
canBeEnabled
=
canBeEnabled
;
}
canBeDisabled
(
canBeDisabled
)
{
this
.
canBeDisabled
=
canBeDisabled
;
}
}
const
SimulatorFront
=
FrontClassWithSpec
(
simulatorSpec
)
;
exports
.
AccessibleFront
=
AccessibleFront
;
registerFront
(
AccessibleFront
)
;
exports
.
AccessibleWalkerFront
=
AccessibleWalkerFront
;
registerFront
(
AccessibleWalkerFront
)
;
exports
.
AccessibilityFront
=
AccessibilityFront
;
registerFront
(
AccessibilityFront
)
;
exports
.
ParentAccessibilityFront
=
ParentAccessibilityFront
;
registerFront
(
ParentAccessibilityFront
)
;
exports
.
SimulatorFront
=
SimulatorFront
;
registerFront
(
SimulatorFront
)
;
