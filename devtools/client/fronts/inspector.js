"
use
strict
"
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
inspectorSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
inspector
"
)
;
loader
.
lazyRequireGetter
(
this
"
captureScreenshot
"
"
devtools
/
client
/
shared
/
screenshot
"
true
)
;
const
TELEMETRY_EYEDROPPER_OPENED
=
"
DEVTOOLS_EYEDROPPER_OPENED_COUNT
"
;
const
TELEMETRY_EYEDROPPER_OPENED_MENU
=
"
DEVTOOLS_MENU_EYEDROPPER_OPENED_COUNT
"
;
const
SHOW_ALL_ANONYMOUS_CONTENT_PREF
=
"
devtools
.
inspector
.
showAllAnonymousContent
"
;
const
telemetry
=
new
Telemetry
(
)
;
class
InspectorFront
extends
FrontClassWithSpec
(
inspectorSpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
_client
=
client
;
this
.
_highlighters
=
new
Map
(
)
;
this
.
formAttributeName
=
"
inspectorActor
"
;
this
.
_pendingGetHighlighterMap
=
new
Map
(
)
;
this
.
noopStylesheetListener
=
(
)
=
>
{
}
;
}
async
initialize
(
)
{
if
(
this
.
initialized
)
{
return
this
.
initialized
;
}
const
{
resourceCommand
}
=
this
.
targetFront
.
commands
;
if
(
resourceCommand
?
.
hasResourceCommandSupport
(
resourceCommand
.
TYPES
.
STYLESHEET
)
)
{
this
.
resourceCommand
=
resourceCommand
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
STYLESHEET
]
{
onAvailable
:
this
.
noopStylesheetListener
}
)
;
if
(
this
.
isDestroyed
(
)
)
{
return
null
;
}
}
this
.
initialized
=
await
Promise
.
all
(
[
this
.
_getWalker
(
)
this
.
_getPageStyle
(
)
]
)
;
return
this
.
initialized
;
}
async
_getWalker
(
)
{
const
showAllAnonymousContent
=
Services
.
prefs
.
getBoolPref
(
SHOW_ALL_ANONYMOUS_CONTENT_PREF
)
;
this
.
walker
=
await
this
.
getWalker
(
{
showAllAnonymousContent
}
)
;
await
this
.
walker
.
reparentRemoteFrame
(
)
;
}
hasHighlighter
(
type
)
{
return
this
.
_highlighters
.
has
(
type
)
;
}
async
_getPageStyle
(
)
{
this
.
pageStyle
=
await
super
.
getPageStyle
(
)
;
}
async
getCompatibilityFront
(
)
{
if
(
!
this
.
_compatibility
)
{
this
.
_compatibility
=
await
super
.
getCompatibility
(
)
;
}
return
this
.
_compatibility
;
}
destroy
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
this
.
_compatibility
=
null
;
if
(
this
.
resourceCommand
)
{
const
{
resourceCommand
}
=
this
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
STYLESHEET
]
{
onAvailable
:
this
.
noopStylesheetListener
}
)
;
this
.
resourceCommand
=
null
;
}
this
.
walker
=
null
;
this
.
destroyHighlighters
(
)
;
super
.
destroy
(
)
;
}
destroyHighlighters
(
)
{
for
(
const
type
of
this
.
_highlighters
.
keys
(
)
)
{
if
(
this
.
_highlighters
.
has
(
type
)
)
{
const
highlighter
=
this
.
_highlighters
.
get
(
type
)
;
if
(
!
highlighter
.
isDestroyed
(
)
)
{
highlighter
.
finalize
(
)
;
}
this
.
_highlighters
.
delete
(
type
)
;
}
}
}
async
getHighlighterByType
(
typeName
)
{
let
highlighter
=
null
;
try
{
highlighter
=
await
super
.
getHighlighterByType
(
typeName
)
;
}
catch
(
_
)
{
throw
new
Error
(
"
The
target
doesn
'
t
support
"
+
creating
highlighters
by
types
or
{
typeName
}
is
unknown
)
;
}
return
highlighter
;
}
getKnownHighlighter
(
type
)
{
return
this
.
_highlighters
.
get
(
type
)
;
}
async
getOrCreateHighlighterByType
(
type
)
{
let
front
=
this
.
_highlighters
.
get
(
type
)
;
let
pendingGetHighlighter
=
this
.
_pendingGetHighlighterMap
.
get
(
type
)
;
if
(
!
front
&
&
!
pendingGetHighlighter
)
{
pendingGetHighlighter
=
(
async
(
)
=
>
{
const
highlighter
=
await
this
.
getHighlighterByType
(
type
)
;
this
.
_highlighters
.
set
(
type
highlighter
)
;
this
.
_pendingGetHighlighterMap
.
delete
(
type
)
;
return
highlighter
;
}
)
(
)
;
this
.
_pendingGetHighlighterMap
.
set
(
type
pendingGetHighlighter
)
;
}
if
(
pendingGetHighlighter
)
{
front
=
await
pendingGetHighlighter
;
}
return
front
;
}
async
pickColorFromPage
(
options
)
{
let
screenshot
=
null
;
if
(
this
.
targetFront
.
hasActor
(
"
screenshotContent
"
)
)
{
try
{
const
{
data
}
=
await
captureScreenshot
(
this
.
targetFront
{
browsingContextID
:
this
.
targetFront
.
browsingContextID
disableFlash
:
true
ignoreDprForFileScale
:
true
}
)
;
screenshot
=
data
;
}
catch
(
e
)
{
console
.
error
(
"
Error
occured
when
taking
a
screenshot
for
the
eyedropper
"
e
)
;
}
}
await
super
.
pickColorFromPage
(
{
.
.
.
options
screenshot
}
)
;
if
(
options
?
.
fromMenu
)
{
telemetry
.
getHistogramById
(
TELEMETRY_EYEDROPPER_OPENED_MENU
)
.
add
(
true
)
;
}
else
{
telemetry
.
getHistogramById
(
TELEMETRY_EYEDROPPER_OPENED
)
.
add
(
true
)
;
}
}
async
getNodeFrontFromNodeGrip
(
grip
)
{
return
this
.
getNodeActorFromContentDomReference
(
grip
.
contentDomReference
)
;
}
async
getNodeActorFromContentDomReference
(
contentDomReference
)
{
const
{
browsingContextId
}
=
contentDomReference
;
if
(
this
.
targetFront
.
browsingContextID
=
=
=
browsingContextId
)
{
return
this
.
walker
.
getNodeActorFromContentDomReference
(
contentDomReference
)
;
}
const
{
descriptorFront
}
=
this
.
targetFront
;
let
target
;
if
(
descriptorFront
&
&
descriptorFront
.
traits
.
watcher
)
{
const
watcherFront
=
await
descriptorFront
.
getWatcher
(
)
;
target
=
await
watcherFront
.
getWindowGlobalTarget
(
browsingContextId
)
;
}
else
{
throw
new
Error
(
Unable
to
call
getNodeActorFromContentDomReference
for
{
this
.
targetFront
.
actorID
}
)
;
}
const
{
walker
}
=
await
target
.
getFront
(
"
inspector
"
)
;
return
walker
.
getNodeActorFromContentDomReference
(
contentDomReference
)
;
}
}
exports
.
InspectorFront
=
InspectorFront
;
registerFront
(
InspectorFront
)
;
