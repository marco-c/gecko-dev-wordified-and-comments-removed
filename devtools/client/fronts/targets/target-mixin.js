"
use
strict
"
;
loader
.
lazyRequireGetter
(
this
"
getFront
"
"
devtools
/
shared
/
protocol
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getThreadOptions
"
"
devtools
/
client
/
shared
/
thread
-
utils
"
true
)
;
function
TargetMixin
(
parentClass
)
{
class
Target
extends
parentClass
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
_forceChrome
=
false
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
threadFront
=
null
;
this
.
_client
=
client
;
this
.
fronts
=
new
Map
(
)
;
this
.
_resourceCache
=
{
}
;
const
offResourceAvailable
=
super
.
on
(
"
resource
-
available
-
form
"
this
.
_onResourceEvent
.
bind
(
this
"
resource
-
available
-
form
"
)
)
;
const
offResourceUpdated
=
super
.
on
(
"
resource
-
updated
-
form
"
this
.
_onResourceEvent
.
bind
(
this
"
resource
-
updated
-
form
"
)
)
;
this
.
_offResourceEvent
=
new
Map
(
[
[
"
resource
-
available
-
form
"
offResourceAvailable
]
[
"
resource
-
updated
-
form
"
offResourceUpdated
]
]
)
;
}
on
(
eventName
listener
)
{
if
(
this
.
_offResourceEvent
&
&
this
.
_offResourceEvent
.
has
(
eventName
)
)
{
const
off
=
this
.
_offResourceEvent
.
get
(
eventName
)
;
this
.
_offResourceEvent
.
delete
(
eventName
)
;
off
(
)
;
if
(
this
.
_resourceCache
[
eventName
]
)
{
for
(
const
cache
of
this
.
_resourceCache
[
eventName
]
)
{
listener
(
cache
)
;
}
delete
this
.
_resourceCache
[
eventName
]
;
}
}
return
super
.
on
(
eventName
listener
)
;
}
get
isTargetFront
(
)
{
return
true
;
}
get
descriptorFront
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
throw
new
Error
(
"
Descriptor
already
destroyed
for
target
:
"
+
this
)
;
}
if
(
this
.
isWorkerTarget
)
{
return
this
;
}
if
(
this
.
_descriptorFront
)
{
return
this
.
_descriptorFront
;
}
if
(
this
.
parentFront
.
typeName
.
endsWith
(
"
Descriptor
"
)
)
{
return
this
.
parentFront
;
}
throw
new
Error
(
"
Missing
descriptor
for
target
:
"
+
this
)
;
}
setDescriptor
(
descriptorFront
)
{
this
.
_descriptorFront
=
descriptorFront
;
}
get
targetType
(
)
{
return
this
.
_targetType
;
}
get
isTopLevel
(
)
{
if
(
!
this
.
targetForm
.
hasOwnProperty
(
"
isTopLevelTarget
"
)
)
{
return
!
!
this
.
_isTopLevel
;
}
return
this
.
targetForm
.
isTopLevelTarget
;
}
setTargetType
(
type
)
{
this
.
_targetType
=
type
;
}
setIsTopLevel
(
isTopLevel
)
{
if
(
!
this
.
getTrait
(
"
supportsTopLevelTargetFlag
"
)
)
{
this
.
_isTopLevel
=
isTopLevel
;
}
}
getWatcherFront
(
)
{
if
(
this
.
parentFront
.
typeName
=
=
"
watcher
"
)
{
return
this
.
parentFront
;
}
if
(
this
.
parentFront
.
typeName
.
endsWith
(
"
Descriptor
"
)
&
&
this
.
parentFront
.
traits
&
&
this
.
parentFront
.
traits
.
watcher
)
{
return
this
.
parentFront
.
getWatcher
(
)
;
}
return
null
;
}
async
getParentTarget
(
)
{
const
watcherFront
=
await
this
.
getWatcherFront
(
)
;
if
(
watcherFront
)
{
if
(
watcherFront
.
traits
.
frame
)
{
return
watcherFront
.
getParentBrowsingContextTarget
(
this
.
browsingContextID
)
;
}
return
null
;
}
if
(
this
.
parentFront
.
getParentTarget
)
{
return
this
.
parentFront
.
getParentTarget
(
)
;
}
return
null
;
}
async
getBrowsingContextTarget
(
browsingContextID
)
{
const
watcherFront
=
await
this
.
getWatcherFront
(
)
;
if
(
watcherFront
)
{
if
(
watcherFront
.
traits
.
frame
)
{
return
watcherFront
.
getBrowsingContextTarget
(
browsingContextID
)
;
}
return
null
;
}
throw
new
Error
(
Unable
to
call
getBrowsingContextTarget
for
{
this
.
actorID
}
)
;
}
hasActor
(
actorName
)
{
if
(
this
.
targetForm
)
{
return
!
!
this
.
targetForm
[
actorName
+
"
Actor
"
]
;
}
return
false
;
}
getTrait
(
traitName
)
{
if
(
this
.
traits
&
&
this
.
traits
[
traitName
]
)
{
return
this
.
traits
[
traitName
]
;
}
if
(
this
.
targetForm
.
traits
&
&
traitName
in
this
.
targetForm
.
traits
)
{
return
this
.
targetForm
.
traits
[
traitName
]
;
}
return
this
.
client
.
traits
[
traitName
]
;
}
get
isLocalTab
(
)
{
if
(
this
.
isWorkerTarget
)
{
return
false
;
}
return
!
!
this
.
descriptorFront
?
.
isLocalTab
;
}
get
localTab
(
)
{
if
(
this
.
isWorkerTarget
)
{
return
null
;
}
return
this
.
descriptorFront
?
.
localTab
|
|
null
;
}
get
root
(
)
{
return
this
.
client
.
mainRoot
.
rootForm
;
}
async
getFront
(
typeName
)
{
if
(
this
.
isDestroyed
(
)
)
{
throw
new
Error
(
"
Target
already
destroyed
unable
to
fetch
children
fronts
"
)
;
}
let
front
=
this
.
fronts
.
get
(
typeName
)
;
if
(
front
)
{
const
isFrontInitializing
=
typeof
front
.
then
=
=
=
"
function
"
;
const
isFrontAlive
=
!
isFrontInitializing
&
&
!
front
.
isDestroyed
(
)
;
if
(
isFrontInitializing
|
|
isFrontAlive
)
{
return
front
;
}
}
front
=
getFront
(
this
.
client
typeName
this
.
targetForm
this
)
;
this
.
fronts
.
set
(
typeName
front
)
;
front
=
await
front
;
this
.
fronts
.
set
(
typeName
front
)
;
return
front
;
}
getCachedFront
(
typeName
)
{
const
front
=
this
.
fronts
.
get
(
typeName
)
;
if
(
front
?
.
actorID
)
{
return
front
;
}
return
null
;
}
get
client
(
)
{
return
this
.
_client
;
}
get
chrome
(
)
{
return
(
this
.
isAddon
|
|
this
.
isContentProcess
|
|
this
.
isParentProcess
|
|
this
.
_forceChrome
)
;
}
forceChrome
(
)
{
this
.
_forceChrome
=
true
;
}
get
isBrowsingContext
(
)
{
return
this
.
typeName
=
=
=
"
browsingContextTarget
"
;
}
get
name
(
)
{
if
(
this
.
isAddon
|
|
this
.
isContentProcess
)
{
return
this
.
targetForm
.
name
;
}
return
this
.
title
;
}
get
title
(
)
{
return
this
.
_title
|
|
this
.
url
;
}
get
url
(
)
{
return
this
.
_url
;
}
get
isAddon
(
)
{
return
this
.
isLegacyAddon
|
|
this
.
isWebExtension
;
}
get
isWorkerTarget
(
)
{
return
(
this
.
typeName
=
=
=
"
workerTarget
"
|
|
this
.
typeName
=
=
=
"
workerDescriptor
"
)
;
}
get
isLegacyAddon
(
)
{
return
!
!
(
this
.
targetForm
&
&
this
.
targetForm
.
actor
&
&
this
.
targetForm
.
actor
.
match
(
/
conn
\
d
+
\
.
addon
(
Target
)
?
\
d
+
/
)
)
;
}
get
isWebExtension
(
)
{
return
!
!
(
this
.
targetForm
&
&
this
.
targetForm
.
actor
&
&
(
this
.
targetForm
.
actor
.
match
(
/
conn
\
d
+
\
.
webExtension
(
Target
)
?
\
d
+
/
)
|
|
this
.
targetForm
.
actor
.
match
(
/
child
\
d
+
\
/
webExtension
(
Target
)
?
\
d
+
/
)
)
)
;
}
get
isContentProcess
(
)
{
return
!
!
(
this
.
targetForm
&
&
this
.
targetForm
.
actor
&
&
this
.
targetForm
.
actor
.
match
(
/
conn
\
d
+
\
.
(
content
-
process
\
d
+
\
/
)
?
contentProcessTarget
\
d
+
/
)
)
;
}
get
isParentProcess
(
)
{
return
!
!
(
this
.
targetForm
&
&
this
.
targetForm
.
actor
&
&
this
.
targetForm
.
actor
.
match
(
/
conn
\
d
+
\
.
parentProcessTarget
\
d
+
/
)
)
;
}
get
isMultiProcess
(
)
{
return
!
this
.
window
;
}
getExtensionPathName
(
url
)
{
if
(
!
this
.
isWebExtension
)
{
throw
new
Error
(
"
Target
is
not
a
WebExtension
"
)
;
}
try
{
const
parsedURL
=
new
URL
(
url
)
;
if
(
parsedURL
.
protocol
!
=
=
"
moz
-
extension
:
"
)
{
return
url
;
}
return
parsedURL
.
pathname
;
}
catch
(
e
)
{
return
url
;
}
}
async
attachConsole
(
)
{
const
consoleFront
=
await
this
.
getFront
(
"
console
"
)
;
if
(
this
.
isDestroyedOrBeingDestroyed
(
)
)
{
return
;
}
await
consoleFront
.
startListeners
(
[
]
)
;
this
.
_onInspectObject
=
packet
=
>
this
.
emit
(
"
inspect
-
object
"
packet
)
;
this
.
removeOnInspectObjectListener
=
consoleFront
.
on
(
"
inspectObject
"
this
.
_onInspectObject
)
;
}
attachAndInitThread
(
targetCommand
)
{
if
(
this
.
_onThreadInitialized
)
{
return
this
.
_onThreadInitialized
;
}
this
.
_onThreadInitialized
=
this
.
_attachAndInitThread
(
targetCommand
)
;
return
this
.
_onThreadInitialized
;
}
async
_attachAndInitThread
(
targetCommand
)
{
if
(
this
.
isDestroyedOrBeingDestroyed
(
)
)
{
return
;
}
if
(
this
.
attach
)
{
await
this
.
attach
(
)
;
}
const
isBrowserToolbox
=
targetCommand
.
descriptorFront
.
isParentProcessDescriptor
;
const
isNonTopLevelFrameTarget
=
!
this
.
isTopLevel
&
&
this
.
targetType
=
=
=
targetCommand
.
TYPES
.
FRAME
;
if
(
isBrowserToolbox
&
&
isNonTopLevelFrameTarget
)
{
return
;
}
if
(
targetCommand
.
descriptorFront
.
createdForBrowserConsole
)
{
return
;
}
const
options
=
await
getThreadOptions
(
)
;
if
(
this
.
isDestroyedOrBeingDestroyed
(
)
)
{
return
;
}
const
threadFront
=
await
this
.
attachThread
(
options
)
;
if
(
this
.
getTrait
(
"
noPauseOnThreadActorAttach
"
)
)
{
return
;
}
try
{
if
(
this
.
isDestroyedOrBeingDestroyed
(
)
|
|
threadFront
.
isDestroyed
(
)
)
{
return
;
}
await
threadFront
.
resume
(
)
;
}
catch
(
ex
)
{
if
(
ex
.
error
=
=
=
"
wrongOrder
"
)
{
targetCommand
.
emit
(
"
target
-
thread
-
wrong
-
order
-
on
-
resume
"
)
;
}
else
{
throw
ex
;
}
}
}
async
attachThread
(
options
=
{
}
)
{
if
(
!
this
.
targetForm
|
|
!
this
.
targetForm
.
threadActor
)
{
throw
new
Error
(
"
TargetMixin
sub
class
should
set
targetForm
.
threadActor
before
calling
"
+
"
attachThread
"
)
;
}
this
.
threadFront
=
await
this
.
getFront
(
"
thread
"
)
;
const
isAttached
=
await
this
.
threadFront
.
isAttached
(
)
;
const
isDestroyed
=
this
.
isDestroyedOrBeingDestroyed
(
)
|
|
this
.
threadFront
.
isDestroyed
(
)
;
if
(
!
isAttached
&
&
!
isDestroyed
)
{
await
this
.
threadFront
.
attach
(
options
)
;
}
return
this
.
threadFront
;
}
isDestroyedOrBeingDestroyed
(
)
{
return
this
.
isDestroyed
(
)
|
|
this
.
_destroyer
;
}
destroy
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
let
destroyerResolve
;
this
.
_destroyer
=
new
Promise
(
r
=
>
(
destroyerResolve
=
r
)
)
;
this
.
_destroyTarget
(
)
.
then
(
destroyerResolve
)
;
return
this
.
_destroyer
;
}
async
_destroyTarget
(
)
{
if
(
this
.
_onThreadInitialized
)
{
try
{
await
this
.
_onThreadInitialized
;
}
catch
(
e
)
{
}
}
for
(
let
[
name
front
]
of
this
.
fronts
)
{
try
{
if
(
front
instanceof
Promise
)
{
front
=
await
front
;
}
front
.
destroy
(
)
;
}
catch
(
e
)
{
console
.
warn
(
"
Error
while
destroying
front
:
"
name
e
)
;
}
}
this
.
fronts
.
clear
(
)
;
if
(
this
.
removeOnInspectObjectListener
)
{
this
.
removeOnInspectObjectListener
(
)
;
this
.
removeOnInspectObjectListener
=
null
;
}
this
.
threadFront
=
null
;
this
.
_offResourceEvent
=
null
;
this
.
emit
(
"
target
-
destroyed
"
)
;
if
(
this
.
detach
&
&
!
this
.
isDestroyed
(
)
)
{
try
{
await
this
.
detach
(
)
;
}
catch
(
e
)
{
this
.
logDetachError
(
e
)
;
}
}
super
.
destroy
(
)
;
this
.
_cleanup
(
)
;
}
logDetachError
(
e
targetType
)
{
const
ignoredError
=
e
?
.
message
.
includes
(
"
noSuchActor
"
)
|
|
e
?
.
message
.
includes
(
"
Connection
closed
"
)
;
if
(
ignoredError
)
{
return
;
}
const
message
=
targetType
?
Error
while
detaching
the
{
targetType
}
target
:
:
"
Error
while
detaching
target
:
"
;
console
.
warn
(
message
e
)
;
}
_cleanup
(
)
{
this
.
threadFront
=
null
;
this
.
_client
=
null
;
this
.
_attach
=
null
;
this
.
_title
=
null
;
this
.
_url
=
null
;
}
_onResourceEvent
(
eventName
resources
)
{
if
(
!
this
.
_resourceCache
[
eventName
]
)
{
this
.
_resourceCache
[
eventName
]
=
[
]
;
}
this
.
_resourceCache
[
eventName
]
.
push
(
resources
)
;
}
toString
(
)
{
const
id
=
this
.
targetForm
?
this
.
targetForm
.
actor
:
null
;
return
Target
:
{
id
}
;
}
dumpPools
(
)
{
return
this
.
threadFront
.
dumpPools
(
)
;
}
logErrorInPage
(
text
category
)
{
if
(
this
.
getTrait
(
"
logInPage
"
)
)
{
const
errorFlag
=
0
;
return
this
.
logInPage
(
{
text
category
flags
:
errorFlag
}
)
;
}
return
Promise
.
resolve
(
)
;
}
logWarningInPage
(
text
category
)
{
if
(
this
.
getTrait
(
"
logInPage
"
)
)
{
const
warningFlag
=
1
;
return
this
.
logInPage
(
{
text
category
flags
:
warningFlag
}
)
;
}
return
Promise
.
resolve
(
)
;
}
}
return
Target
;
}
exports
.
TargetMixin
=
TargetMixin
;
