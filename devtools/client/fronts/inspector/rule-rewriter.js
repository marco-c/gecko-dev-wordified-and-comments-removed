"
use
strict
"
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
{
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
escapeCSSComment
parseNamedDeclarations
unescapeCSSComment
}
=
require
(
"
devtools
/
shared
/
css
/
parsing
-
utils
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getIndentationFromPrefs
"
"
getIndentationFromString
"
]
"
devtools
/
shared
/
indentation
"
true
)
;
const
NEWLINE_RX
=
/
[
\
r
\
n
]
/
;
const
EMPTY_COMMENT_START_RX
=
/
^
\
/
\
*
!
?
[
\
r
\
n
\
t
\
f
]
*
/
;
const
EMPTY_COMMENT_END_RX
=
/
^
[
\
r
\
n
\
t
\
f
]
*
\
*
\
/
/
;
const
BLANK_LINE_RX
=
/
^
[
\
t
]
*
(
?
:
\
r
\
n
|
\
n
|
\
r
|
\
f
|
)
/
;
function
RuleRewriter
(
isCssPropertyKnown
rule
inputString
)
{
this
.
rule
=
rule
;
this
.
isCssPropertyKnown
=
isCssPropertyKnown
;
this
.
modifications
=
[
]
;
this
.
changedDeclarations
=
{
}
;
this
.
editPromise
=
null
;
this
.
defaultIndentation
=
null
;
this
.
startInitialization
(
inputString
)
;
}
RuleRewriter
.
prototype
=
{
startInitialization
(
inputString
)
{
this
.
inputString
=
inputString
;
this
.
hasNewLine
=
/
[
\
r
\
n
]
/
.
test
(
this
.
inputString
)
;
this
.
declarations
=
parseNamedDeclarations
(
this
.
isCssPropertyKnown
this
.
inputString
true
)
;
this
.
decl
=
null
;
this
.
result
=
null
;
}
completeInitialization
(
index
)
{
if
(
index
<
0
)
{
throw
new
Error
(
"
Invalid
index
"
+
index
+
"
.
Expected
positive
integer
"
)
;
}
if
(
index
<
this
.
declarations
.
length
)
{
this
.
decl
=
this
.
declarations
[
index
]
;
this
.
result
=
this
.
inputString
.
substring
(
0
this
.
decl
.
offsets
[
0
]
)
;
}
else
{
this
.
decl
=
null
;
this
.
result
=
this
.
inputString
;
}
}
getIndentation
(
string
offset
)
{
let
originalOffset
=
offset
;
for
(
-
-
offset
;
offset
>
=
0
;
-
-
offset
)
{
const
c
=
string
[
offset
]
;
if
(
c
=
=
=
"
\
r
"
|
|
c
=
=
=
"
\
n
"
|
|
c
=
=
=
"
\
f
"
)
{
return
string
.
substring
(
offset
+
1
originalOffset
)
;
}
if
(
c
!
=
=
"
"
&
&
c
!
=
=
"
\
t
"
)
{
originalOffset
=
offset
;
}
}
return
"
"
;
}
sanitizePropertyValue
(
text
)
{
text
=
text
.
replace
(
/
;
/
"
"
)
;
const
lexer
=
getCSSLexer
(
text
)
;
let
result
=
"
"
;
let
previousOffset
=
0
;
const
parenStack
=
[
]
;
let
anySanitized
=
false
;
const
pushParen
=
(
token
closer
)
=
>
{
result
=
result
+
text
.
substring
(
previousOffset
token
.
startOffset
)
+
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
parenStack
.
push
(
{
closer
offset
:
result
.
length
-
1
}
)
;
previousOffset
=
token
.
endOffset
;
}
;
const
popSomeParens
=
closer
=
>
{
while
(
parenStack
.
length
)
{
const
paren
=
parenStack
.
pop
(
)
;
if
(
paren
.
closer
=
=
=
closer
)
{
return
true
;
}
result
=
result
.
substring
(
0
paren
.
offset
)
+
"
\
\
"
+
result
.
substring
(
paren
.
offset
)
;
anySanitized
=
true
;
}
return
false
;
}
;
while
(
true
)
{
const
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
)
{
switch
(
token
.
text
)
{
case
"
;
"
:
result
+
=
text
.
substring
(
previousOffset
token
.
startOffset
)
;
previousOffset
=
token
.
endOffset
;
break
;
case
"
{
"
:
pushParen
(
token
"
}
"
)
;
break
;
case
"
(
"
:
pushParen
(
token
"
)
"
)
;
break
;
case
"
[
"
:
pushParen
(
token
"
]
"
)
;
break
;
case
"
}
"
:
case
"
)
"
:
case
"
]
"
:
if
(
!
popSomeParens
(
token
.
text
)
)
{
result
+
=
text
.
substring
(
previousOffset
token
.
startOffset
)
;
result
+
=
"
\
\
"
+
token
.
text
;
previousOffset
=
token
.
endOffset
;
anySanitized
=
true
;
}
break
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
pushParen
(
token
"
)
"
)
;
}
}
popSomeParens
(
null
)
;
result
+
=
text
.
substring
(
previousOffset
text
.
length
)
;
const
eofFixup
=
lexer
.
performEOFFixup
(
"
"
true
)
;
if
(
eofFixup
)
{
anySanitized
=
true
;
result
+
=
eofFixup
;
}
return
[
anySanitized
result
]
;
}
skipWhitespaceBackward
(
string
index
)
{
for
(
-
-
index
;
index
>
=
0
&
&
(
string
[
index
]
=
=
=
"
"
|
|
string
[
index
]
=
=
=
"
\
t
"
)
;
-
-
index
)
{
}
return
index
;
}
maybeTerminateDecl
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
declarations
.
length
|
|
"
commentOffsets
"
in
this
.
declarations
[
index
]
)
{
return
;
}
const
termDecl
=
this
.
declarations
[
index
]
;
let
endIndex
=
termDecl
.
offsets
[
1
]
;
endIndex
=
this
.
skipWhitespaceBackward
(
this
.
result
endIndex
)
+
1
;
const
trailingText
=
this
.
result
.
substring
(
endIndex
)
;
if
(
termDecl
.
terminator
)
{
this
.
result
=
this
.
result
.
substring
(
0
endIndex
)
+
termDecl
.
terminator
+
trailingText
;
if
(
termDecl
.
terminator
!
=
=
"
;
"
&
&
termDecl
.
terminator
!
=
=
"
*
/
;
"
)
{
this
.
changedDeclarations
[
index
]
=
termDecl
.
value
+
termDecl
.
terminator
.
slice
(
0
-
1
)
;
}
}
if
(
this
.
hasNewLine
&
&
!
NEWLINE_RX
.
test
(
trailingText
)
)
{
this
.
result
+
=
"
\
n
"
;
}
}
sanitizeText
(
text
index
)
{
const
[
anySanitized
sanitizedText
]
=
this
.
sanitizePropertyValue
(
text
)
;
if
(
anySanitized
)
{
this
.
changedDeclarations
[
index
]
=
sanitizedText
;
}
return
sanitizedText
;
}
renameProperty
(
index
name
newName
)
{
this
.
completeInitialization
(
index
)
;
this
.
result
+
=
CSS
.
escape
(
newName
)
;
this
.
completeCopying
(
this
.
decl
.
colonOffsets
[
0
]
)
;
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
newName
}
)
;
}
setPropertyEnabled
(
index
name
isEnabled
)
{
this
.
completeInitialization
(
index
)
;
const
decl
=
this
.
decl
;
const
priority
=
decl
.
priority
;
let
copyOffset
=
decl
.
offsets
[
1
]
;
if
(
isEnabled
)
{
const
commentStart
=
decl
.
commentOffsets
[
0
]
;
if
(
EMPTY_COMMENT_START_RX
.
test
(
this
.
result
.
substring
(
commentStart
)
)
)
{
this
.
result
=
this
.
result
.
substring
(
0
commentStart
)
;
}
else
{
this
.
result
+
=
"
*
/
"
;
}
const
commentNamePart
=
this
.
inputString
.
substring
(
decl
.
offsets
[
0
]
decl
.
colonOffsets
[
1
]
)
;
this
.
result
+
=
unescapeCSSComment
(
commentNamePart
)
;
let
newText
=
this
.
inputString
.
substring
(
decl
.
colonOffsets
[
1
]
decl
.
offsets
[
1
]
)
;
newText
=
cssTrimRight
(
unescapeCSSComment
(
newText
)
)
;
this
.
result
+
=
this
.
sanitizeText
(
newText
index
)
+
"
;
"
;
const
trailingText
=
this
.
inputString
.
substring
(
decl
.
offsets
[
1
]
)
;
if
(
EMPTY_COMMENT_END_RX
.
test
(
trailingText
)
)
{
copyOffset
=
decl
.
commentOffsets
[
1
]
;
}
else
{
this
.
result
+
=
"
/
*
"
;
}
}
else
{
const
declText
=
this
.
inputString
.
substring
(
decl
.
offsets
[
0
]
decl
.
offsets
[
1
]
)
;
this
.
result
+
=
"
/
*
"
+
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
+
"
"
+
escapeCSSComment
(
declText
)
+
"
*
/
"
;
}
this
.
completeCopying
(
copyOffset
)
;
if
(
isEnabled
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
:
decl
.
value
priority
}
)
;
}
else
{
this
.
modifications
.
push
(
{
type
:
"
disable
"
index
name
}
)
;
}
}
async
getDefaultIndentation
(
)
{
if
(
!
this
.
rule
.
parentStyleSheet
)
{
return
null
;
}
if
(
this
.
rule
.
parentStyleSheet
.
resourceId
)
{
const
prefIndent
=
getIndentationFromPrefs
(
)
;
if
(
prefIndent
)
{
const
{
indentUnit
indentWithTabs
}
=
prefIndent
;
return
indentWithTabs
?
"
\
t
"
:
"
"
.
repeat
(
indentUnit
)
;
}
const
styleSheetsFront
=
await
this
.
rule
.
targetFront
.
getFront
(
"
stylesheets
"
)
;
const
{
str
:
source
}
=
await
styleSheetsFront
.
getText
(
this
.
rule
.
parentStyleSheet
.
resourceId
)
;
const
{
indentUnit
indentWithTabs
}
=
getIndentationFromString
(
source
)
;
return
indentWithTabs
?
"
\
t
"
:
"
"
.
repeat
(
indentUnit
)
;
}
return
this
.
rule
.
parentStyleSheet
.
guessIndentation
(
)
;
}
async
internalCreateProperty
(
index
name
value
priority
enabled
)
{
this
.
completeInitialization
(
index
)
;
let
newIndentation
=
"
"
;
if
(
this
.
hasNewLine
)
{
if
(
this
.
declarations
.
length
)
{
newIndentation
=
this
.
getIndentation
(
this
.
inputString
this
.
declarations
[
0
]
.
offsets
[
0
]
)
;
}
else
if
(
this
.
defaultIndentation
)
{
newIndentation
=
this
.
defaultIndentation
;
}
else
{
newIndentation
=
await
this
.
getDefaultIndentation
(
)
;
}
}
this
.
maybeTerminateDecl
(
index
-
1
)
;
let
savedWhitespace
=
"
"
;
if
(
this
.
hasNewLine
)
{
const
wsOffset
=
this
.
skipWhitespaceBackward
(
this
.
result
this
.
result
.
length
)
;
if
(
this
.
result
[
wsOffset
]
=
=
=
"
\
r
"
|
|
this
.
result
[
wsOffset
]
=
=
=
"
\
n
"
)
{
savedWhitespace
=
this
.
result
.
substring
(
wsOffset
+
1
)
;
this
.
result
=
this
.
result
.
substring
(
0
wsOffset
+
1
)
;
}
}
let
newText
=
CSS
.
escape
(
name
)
+
"
:
"
+
this
.
sanitizeText
(
value
index
)
;
if
(
priority
=
=
=
"
important
"
)
{
newText
+
=
"
!
important
"
;
}
newText
+
=
"
;
"
;
if
(
!
enabled
)
{
newText
=
"
/
*
"
+
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
+
"
"
+
escapeCSSComment
(
newText
)
+
"
*
/
"
;
}
this
.
result
+
=
newIndentation
+
newText
;
if
(
this
.
hasNewLine
)
{
this
.
result
+
=
"
\
n
"
;
}
this
.
result
+
=
savedWhitespace
;
if
(
this
.
decl
)
{
this
.
completeCopying
(
this
.
decl
.
offsets
[
0
]
)
;
}
}
createProperty
(
index
name
value
priority
enabled
)
{
this
.
editPromise
=
this
.
internalCreateProperty
(
index
name
value
priority
enabled
)
;
if
(
enabled
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
priority
}
)
;
}
}
setProperty
(
index
name
value
priority
)
{
this
.
completeInitialization
(
index
)
;
if
(
!
this
.
decl
)
{
this
.
createProperty
(
index
name
value
priority
true
)
;
return
;
}
this
.
result
+
=
this
.
inputString
.
substring
(
this
.
decl
.
offsets
[
0
]
this
.
decl
.
colonOffsets
[
1
]
)
+
this
.
sanitizeText
(
value
index
)
;
if
(
priority
=
=
=
"
important
"
)
{
this
.
result
+
=
"
!
important
"
;
}
this
.
result
+
=
"
;
"
;
this
.
completeCopying
(
this
.
decl
.
offsets
[
1
]
)
;
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
priority
}
)
;
}
removeProperty
(
index
name
)
{
this
.
completeInitialization
(
index
)
;
if
(
!
this
.
decl
)
{
return
;
}
if
(
this
.
decl
.
commentOffsets
)
{
this
.
setPropertyEnabled
(
index
name
true
)
;
this
.
startInitialization
(
this
.
result
)
;
this
.
completeInitialization
(
index
)
;
}
let
copyOffset
=
this
.
decl
.
offsets
[
1
]
;
if
(
this
.
hasNewLine
)
{
const
nlOffset
=
this
.
skipWhitespaceBackward
(
this
.
result
this
.
decl
.
offsets
[
0
]
)
;
if
(
nlOffset
<
0
|
|
this
.
result
[
nlOffset
]
=
=
=
"
\
r
"
|
|
this
.
result
[
nlOffset
]
=
=
=
"
\
n
"
)
{
const
trailingText
=
this
.
inputString
.
substring
(
copyOffset
)
;
const
match
=
BLANK_LINE_RX
.
exec
(
trailingText
)
;
if
(
match
)
{
this
.
result
=
this
.
result
.
substring
(
0
nlOffset
+
1
)
;
copyOffset
+
=
match
[
0
]
.
length
;
}
}
}
this
.
completeCopying
(
copyOffset
)
;
this
.
modifications
.
push
(
{
type
:
"
remove
"
index
name
}
)
;
}
completeCopying
(
copyOffset
)
{
this
.
result
+
=
this
.
inputString
.
substring
(
copyOffset
)
;
}
apply
(
)
{
return
Promise
.
resolve
(
this
.
editPromise
)
.
then
(
(
)
=
>
{
return
this
.
rule
.
setRuleText
(
this
.
result
this
.
modifications
)
;
}
)
;
}
getResult
(
)
{
return
{
changed
:
this
.
changedDeclarations
text
:
this
.
result
}
;
}
}
;
function
cssTrimRight
(
str
)
{
const
match
=
/
^
(
.
*
?
)
[
\
t
\
r
\
n
\
f
]
*
/
.
exec
(
str
)
;
if
(
match
)
{
return
match
[
1
]
;
}
return
str
;
}
module
.
exports
=
RuleRewriter
;
