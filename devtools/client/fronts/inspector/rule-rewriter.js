"
use
strict
"
;
const
{
InspectorCSSParserWrapper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
lexer
.
js
"
)
;
const
{
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
escapeCSSComment
parseNamedDeclarations
unescapeCSSComment
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
parsing
-
utils
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
getIndentationFromPrefs
"
"
getIndentationFromString
"
]
"
resource
:
/
/
devtools
/
shared
/
indentation
.
js
"
true
)
;
const
NEWLINE_RX
=
/
[
\
r
\
n
]
/
;
const
EMPTY_COMMENT_START_RX
=
/
^
\
/
\
*
!
?
[
\
r
\
n
\
t
\
f
]
*
/
;
const
EMPTY_COMMENT_END_RX
=
/
^
[
\
r
\
n
\
t
\
f
]
*
\
*
\
/
/
;
const
BLANK_LINE_RX
=
/
^
[
\
t
]
*
(
?
:
\
r
\
n
|
\
n
|
\
r
|
\
f
|
)
/
;
class
RuleRewriter
{
constructor
(
win
isCssPropertyKnown
rule
inputString
)
{
this
.
win
=
win
;
this
.
rule
=
rule
;
this
.
isCssPropertyKnown
=
isCssPropertyKnown
;
this
.
modifications
=
[
]
;
this
.
changedDeclarations
=
{
}
;
this
.
editPromise
=
null
;
this
.
defaultIndentation
=
null
;
this
.
startInitialization
(
inputString
)
;
}
startInitialization
(
inputString
)
{
this
.
inputString
=
inputString
;
this
.
hasNewLine
=
/
[
\
r
\
n
]
/
.
test
(
this
.
inputString
)
;
this
.
declarations
=
parseNamedDeclarations
(
this
.
isCssPropertyKnown
this
.
inputString
true
)
;
this
.
decl
=
null
;
this
.
result
=
null
;
}
completeInitialization
(
index
)
{
if
(
index
<
0
)
{
throw
new
Error
(
"
Invalid
index
"
+
index
+
"
.
Expected
positive
integer
"
)
;
}
if
(
index
<
this
.
declarations
.
length
)
{
this
.
decl
=
this
.
declarations
[
index
]
;
this
.
result
=
this
.
inputString
.
substring
(
0
this
.
decl
.
offsets
[
0
]
)
;
}
else
{
this
.
decl
=
null
;
this
.
result
=
this
.
inputString
;
}
}
getIndentation
(
string
offset
)
{
let
originalOffset
=
offset
;
for
(
-
-
offset
;
offset
>
=
0
;
-
-
offset
)
{
const
c
=
string
[
offset
]
;
if
(
c
=
=
=
"
\
r
"
|
|
c
=
=
=
"
\
n
"
|
|
c
=
=
=
"
\
f
"
)
{
return
string
.
substring
(
offset
+
1
originalOffset
)
;
}
if
(
c
!
=
=
"
"
&
&
c
!
=
=
"
\
t
"
)
{
originalOffset
=
offset
;
}
}
return
"
"
;
}
sanitizePropertyValue
(
text
)
{
text
=
text
.
replace
(
/
;
/
"
"
)
;
const
lexer
=
new
InspectorCSSParserWrapper
(
text
{
trackEOFChars
:
true
}
)
;
let
result
=
"
"
;
let
previousOffset
=
0
;
const
parenStack
=
[
]
;
let
anySanitized
=
false
;
const
pushParen
=
(
token
closer
)
=
>
{
result
=
result
+
text
.
substring
(
previousOffset
token
.
startOffset
)
+
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
parenStack
.
push
(
{
closer
offset
:
result
.
length
-
1
token
}
)
;
previousOffset
=
token
.
endOffset
;
}
;
const
popSomeParens
=
closer
=
>
{
while
(
parenStack
.
length
)
{
const
paren
=
parenStack
.
pop
(
)
;
if
(
paren
.
closer
=
=
=
closer
)
{
return
true
;
}
if
(
paren
.
closer
=
=
=
"
)
"
&
&
closer
=
=
null
&
&
paren
.
token
.
tokenType
=
=
=
"
Function
"
&
&
paren
.
token
.
value
=
=
=
"
url
"
)
{
return
true
;
}
result
=
result
.
substring
(
0
paren
.
offset
)
+
"
\
\
"
+
result
.
substring
(
paren
.
offset
)
;
anySanitized
=
true
;
}
return
false
;
}
;
let
token
;
while
(
(
token
=
lexer
.
nextToken
(
)
)
)
{
switch
(
token
.
tokenType
)
{
case
"
Semicolon
"
:
result
+
=
text
.
substring
(
previousOffset
token
.
startOffset
)
;
previousOffset
=
token
.
endOffset
;
break
;
case
"
CurlyBracketBlock
"
:
pushParen
(
token
"
}
"
)
;
break
;
case
"
ParenthesisBlock
"
:
case
"
Function
"
:
pushParen
(
token
"
)
"
)
;
break
;
case
"
SquareBracketBlock
"
:
pushParen
(
token
"
]
"
)
;
break
;
case
"
CloseCurlyBracket
"
:
case
"
CloseParenthesis
"
:
case
"
CloseSquareBracket
"
:
if
(
!
popSomeParens
(
token
.
text
)
)
{
result
+
=
text
.
substring
(
previousOffset
token
.
startOffset
)
;
result
+
=
"
\
\
"
+
token
.
text
;
previousOffset
=
token
.
endOffset
;
anySanitized
=
true
;
}
break
;
}
}
popSomeParens
(
null
)
;
result
+
=
text
.
substring
(
previousOffset
text
.
length
)
;
const
eofFixup
=
lexer
.
performEOFFixup
(
"
"
)
;
if
(
eofFixup
)
{
anySanitized
=
true
;
result
+
=
eofFixup
;
}
return
[
anySanitized
result
]
;
}
skipWhitespaceBackward
(
string
index
)
{
for
(
-
-
index
;
index
>
=
0
&
&
(
string
[
index
]
=
=
=
"
"
|
|
string
[
index
]
=
=
=
"
\
t
"
)
;
-
-
index
)
{
}
return
index
;
}
maybeTerminateDecl
(
index
)
{
if
(
index
<
0
|
|
index
>
=
this
.
declarations
.
length
|
|
"
commentOffsets
"
in
this
.
declarations
[
index
]
)
{
return
;
}
const
termDecl
=
this
.
declarations
[
index
]
;
let
endIndex
=
termDecl
.
offsets
[
1
]
;
endIndex
=
this
.
skipWhitespaceBackward
(
this
.
result
endIndex
)
+
1
;
const
trailingText
=
this
.
result
.
substring
(
endIndex
)
;
if
(
termDecl
.
terminator
)
{
this
.
result
=
this
.
result
.
substring
(
0
endIndex
)
+
termDecl
.
terminator
+
trailingText
;
if
(
termDecl
.
terminator
!
=
=
"
;
"
&
&
termDecl
.
terminator
!
=
=
"
*
/
;
"
)
{
this
.
changedDeclarations
[
index
]
=
termDecl
.
value
+
termDecl
.
terminator
.
slice
(
0
-
1
)
;
}
}
if
(
this
.
hasNewLine
&
&
!
NEWLINE_RX
.
test
(
trailingText
)
)
{
this
.
result
+
=
"
\
n
"
;
}
}
sanitizeText
(
text
index
)
{
const
[
anySanitized
sanitizedText
]
=
this
.
sanitizePropertyValue
(
text
)
;
if
(
anySanitized
)
{
this
.
changedDeclarations
[
index
]
=
sanitizedText
;
}
return
sanitizedText
;
}
renameProperty
(
index
name
newName
)
{
this
.
completeInitialization
(
index
)
;
this
.
result
+
=
CSS
.
escape
(
newName
)
;
this
.
completeCopying
(
this
.
decl
.
colonOffsets
[
0
]
)
;
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
newName
}
)
;
}
setPropertyEnabled
(
index
name
isEnabled
)
{
this
.
completeInitialization
(
index
)
;
const
decl
=
this
.
decl
;
const
priority
=
decl
.
priority
;
let
copyOffset
=
decl
.
offsets
[
1
]
;
if
(
isEnabled
)
{
const
commentStart
=
decl
.
commentOffsets
[
0
]
;
if
(
EMPTY_COMMENT_START_RX
.
test
(
this
.
result
.
substring
(
commentStart
)
)
)
{
this
.
result
=
this
.
result
.
substring
(
0
commentStart
)
;
}
else
{
this
.
result
+
=
"
*
/
"
;
}
const
commentNamePart
=
this
.
inputString
.
substring
(
decl
.
offsets
[
0
]
decl
.
colonOffsets
[
1
]
)
;
this
.
result
+
=
unescapeCSSComment
(
commentNamePart
)
;
let
newText
=
this
.
inputString
.
substring
(
decl
.
colonOffsets
[
1
]
decl
.
offsets
[
1
]
)
;
newText
=
cssTrimRight
(
unescapeCSSComment
(
newText
)
)
;
this
.
result
+
=
this
.
sanitizeText
(
newText
index
)
+
"
;
"
;
const
trailingText
=
this
.
inputString
.
substring
(
decl
.
offsets
[
1
]
)
;
if
(
EMPTY_COMMENT_END_RX
.
test
(
trailingText
)
)
{
copyOffset
=
decl
.
commentOffsets
[
1
]
;
}
else
{
this
.
result
+
=
"
/
*
"
;
}
}
else
{
const
declText
=
this
.
inputString
.
substring
(
decl
.
offsets
[
0
]
decl
.
offsets
[
1
]
)
;
this
.
result
+
=
"
/
*
"
+
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
+
"
"
+
escapeCSSComment
(
declText
)
+
"
*
/
"
;
}
this
.
completeCopying
(
copyOffset
)
;
if
(
isEnabled
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
:
decl
.
value
priority
}
)
;
}
else
{
this
.
modifications
.
push
(
{
type
:
"
disable
"
index
name
}
)
;
}
}
async
getDefaultIndentation
(
)
{
const
prefIndent
=
getIndentationFromPrefs
(
)
;
if
(
prefIndent
)
{
const
{
indentUnit
indentWithTabs
}
=
prefIndent
;
return
indentWithTabs
?
"
\
t
"
:
"
"
.
repeat
(
indentUnit
)
;
}
const
styleSheetsFront
=
await
this
.
rule
.
targetFront
.
getFront
(
"
stylesheets
"
)
;
if
(
!
this
.
rule
.
parentStyleSheet
)
{
console
.
error
(
"
Cannot
retrieve
default
indentation
for
rule
if
parentStyleSheet
is
not
attached
yet
falling
back
to
2
spaces
"
)
;
return
"
"
;
}
const
{
str
:
source
}
=
await
styleSheetsFront
.
getText
(
this
.
rule
.
parentStyleSheet
.
resourceId
)
;
const
{
indentUnit
indentWithTabs
}
=
getIndentationFromString
(
source
)
;
return
indentWithTabs
?
"
\
t
"
:
"
"
.
repeat
(
indentUnit
)
;
}
async
internalCreateProperty
(
index
name
value
priority
enabled
)
{
this
.
completeInitialization
(
index
)
;
let
newIndentation
=
"
"
;
if
(
this
.
hasNewLine
)
{
if
(
this
.
declarations
.
length
)
{
newIndentation
=
this
.
getIndentation
(
this
.
inputString
this
.
declarations
[
0
]
.
offsets
[
0
]
)
;
}
else
if
(
this
.
defaultIndentation
)
{
newIndentation
=
this
.
defaultIndentation
;
}
else
{
newIndentation
=
await
this
.
getDefaultIndentation
(
)
;
}
}
this
.
maybeTerminateDecl
(
index
-
1
)
;
let
savedWhitespace
=
"
"
;
if
(
this
.
hasNewLine
)
{
const
wsOffset
=
this
.
skipWhitespaceBackward
(
this
.
result
this
.
result
.
length
)
;
if
(
this
.
result
[
wsOffset
]
=
=
=
"
\
r
"
|
|
this
.
result
[
wsOffset
]
=
=
=
"
\
n
"
)
{
savedWhitespace
=
this
.
result
.
substring
(
wsOffset
+
1
)
;
this
.
result
=
this
.
result
.
substring
(
0
wsOffset
+
1
)
;
}
}
let
newText
=
CSS
.
escape
(
name
)
+
"
:
"
+
this
.
sanitizeText
(
value
index
)
;
if
(
priority
=
=
=
"
important
"
)
{
newText
+
=
"
!
important
"
;
}
newText
+
=
"
;
"
;
if
(
!
enabled
)
{
newText
=
"
/
*
"
+
COMMENT_PARSING_HEURISTIC_BYPASS_CHAR
+
"
"
+
escapeCSSComment
(
newText
)
+
"
*
/
"
;
}
newText
=
{
newIndentation
}
{
newText
}
{
this
.
hasNewLine
?
"
\
n
"
:
"
"
}
{
savedWhitespace
}
;
let
nestedDeclarationIndex
=
-
1
;
if
(
this
.
result
.
includes
(
"
{
"
)
)
{
const
dummySheet
=
new
this
.
win
.
CSSStyleSheet
(
)
;
dummySheet
.
replaceSync
(
"
:
root
{
\
n
"
+
this
.
result
+
"
}
"
)
;
const
dummyRule
=
dummySheet
.
cssRules
[
0
]
;
if
(
dummyRule
.
cssRules
.
length
)
{
const
nestedRule
=
dummyRule
.
cssRules
[
0
]
;
const
nestedRuleLine
=
InspectorUtils
.
getRelativeRuleLine
(
nestedRule
)
;
const
nestedRuleColumn
=
InspectorUtils
.
getRuleColumn
(
nestedRule
)
;
const
actualLine
=
nestedRuleLine
-
2
;
const
actualColumn
=
nestedRuleColumn
-
1
;
let
lineOffset
=
0
;
for
(
let
i
=
0
;
i
<
actualLine
;
i
+
+
)
{
lineOffset
=
this
.
result
.
indexOf
(
"
\
n
"
lineOffset
)
;
}
nestedDeclarationIndex
=
lineOffset
+
actualColumn
;
}
}
if
(
nestedDeclarationIndex
=
=
-
1
)
{
this
.
result
+
=
newText
;
}
else
{
this
.
result
=
this
.
result
.
substring
(
0
nestedDeclarationIndex
)
+
newText
+
this
.
result
.
substring
(
nestedDeclarationIndex
)
;
}
if
(
this
.
decl
)
{
this
.
completeCopying
(
this
.
decl
.
offsets
[
0
]
)
;
}
}
createProperty
(
index
name
value
priority
enabled
)
{
this
.
editPromise
=
this
.
internalCreateProperty
(
index
name
value
priority
enabled
)
;
if
(
enabled
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
priority
}
)
;
}
}
setProperty
(
index
name
value
priority
)
{
this
.
completeInitialization
(
index
)
;
if
(
!
this
.
decl
)
{
this
.
createProperty
(
index
name
value
priority
true
)
;
return
;
}
this
.
result
+
=
this
.
inputString
.
substring
(
this
.
decl
.
offsets
[
0
]
this
.
decl
.
colonOffsets
[
1
]
)
+
this
.
sanitizeText
(
value
index
)
;
if
(
priority
=
=
=
"
important
"
)
{
this
.
result
+
=
"
!
important
"
;
}
this
.
result
+
=
"
;
"
;
this
.
completeCopying
(
this
.
decl
.
offsets
[
1
]
)
;
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
priority
}
)
;
}
removeProperty
(
index
name
)
{
this
.
completeInitialization
(
index
)
;
if
(
!
this
.
decl
)
{
return
;
}
if
(
this
.
decl
.
commentOffsets
)
{
this
.
setPropertyEnabled
(
index
name
true
)
;
this
.
startInitialization
(
this
.
result
)
;
this
.
completeInitialization
(
index
)
;
}
let
copyOffset
=
this
.
decl
.
offsets
[
1
]
;
if
(
this
.
hasNewLine
)
{
const
nlOffset
=
this
.
skipWhitespaceBackward
(
this
.
result
this
.
decl
.
offsets
[
0
]
)
;
if
(
nlOffset
<
0
|
|
this
.
result
[
nlOffset
]
=
=
=
"
\
r
"
|
|
this
.
result
[
nlOffset
]
=
=
=
"
\
n
"
)
{
const
trailingText
=
this
.
inputString
.
substring
(
copyOffset
)
;
const
match
=
BLANK_LINE_RX
.
exec
(
trailingText
)
;
if
(
match
)
{
this
.
result
=
this
.
result
.
substring
(
0
nlOffset
+
1
)
;
copyOffset
+
=
match
[
0
]
.
length
;
}
}
}
this
.
completeCopying
(
copyOffset
)
;
this
.
modifications
.
push
(
{
type
:
"
remove
"
index
name
}
)
;
}
completeCopying
(
copyOffset
)
{
this
.
result
+
=
this
.
inputString
.
substring
(
copyOffset
)
;
}
apply
(
)
{
return
Promise
.
resolve
(
this
.
editPromise
)
.
then
(
(
)
=
>
{
return
this
.
rule
.
setRuleText
(
this
.
result
this
.
modifications
)
;
}
)
;
}
getResult
(
)
{
return
{
changed
:
this
.
changedDeclarations
text
:
this
.
result
}
;
}
}
function
cssTrimRight
(
str
)
{
const
match
=
/
^
(
.
*
?
)
[
\
t
\
r
\
n
\
f
]
*
/
.
exec
(
str
)
;
if
(
match
)
{
return
match
[
1
]
;
}
return
str
;
}
module
.
exports
=
RuleRewriter
;
