"
use
strict
"
;
const
{
objectSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
object
"
)
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
LongStringFront
}
=
require
(
"
devtools
/
client
/
fronts
/
string
"
)
;
class
ObjectFront
extends
FrontClassWithSpec
(
objectSpec
)
{
constructor
(
conn
=
null
targetFront
=
null
parentFront
=
null
data
)
{
if
(
!
parentFront
)
{
throw
new
Error
(
"
ObjectFront
require
a
parent
front
"
)
;
}
super
(
conn
targetFront
parentFront
)
;
this
.
_grip
=
data
;
this
.
actorID
=
this
.
_grip
.
actor
;
this
.
valid
=
true
;
parentFront
.
manage
(
this
)
;
}
skipDestroy
(
)
{
return
this
.
conn
&
&
this
.
conn
.
isToolboxDestroy
;
}
getGrip
(
)
{
return
this
.
_grip
;
}
get
isFrozen
(
)
{
return
this
.
_grip
.
frozen
;
}
get
isSealed
(
)
{
return
this
.
_grip
.
sealed
;
}
get
isExtensible
(
)
{
return
this
.
_grip
.
extensible
;
}
getParameterNames
(
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Function
"
)
{
console
.
error
(
"
getParameterNames
is
only
valid
for
function
grips
.
"
)
;
return
null
;
}
return
super
.
parameterNames
(
)
;
}
getOwnPropertyNames
(
)
{
return
super
.
ownPropertyNames
(
)
;
}
async
getPrototypeAndProperties
(
)
{
const
result
=
await
super
.
prototypeAndProperties
(
)
;
if
(
result
.
prototype
)
{
result
.
prototype
=
getAdHocFrontOrPrimitiveGrip
(
result
.
prototype
this
)
;
}
const
gripKeys
=
[
"
value
"
"
getterValue
"
"
get
"
"
set
"
]
;
if
(
result
.
ownProperties
)
{
Object
.
entries
(
result
.
ownProperties
)
.
forEach
(
(
[
key
descriptor
]
)
=
>
{
if
(
descriptor
)
{
for
(
const
gripKey
of
gripKeys
)
{
if
(
descriptor
.
hasOwnProperty
(
gripKey
)
)
{
result
.
ownProperties
[
key
]
[
gripKey
]
=
getAdHocFrontOrPrimitiveGrip
(
descriptor
[
gripKey
]
this
)
;
}
}
}
}
)
;
}
if
(
result
.
safeGetterValues
)
{
Object
.
entries
(
result
.
safeGetterValues
)
.
forEach
(
(
[
key
descriptor
]
)
=
>
{
if
(
descriptor
)
{
for
(
const
gripKey
of
gripKeys
)
{
if
(
descriptor
.
hasOwnProperty
(
gripKey
)
)
{
result
.
safeGetterValues
[
key
]
[
gripKey
]
=
getAdHocFrontOrPrimitiveGrip
(
descriptor
[
gripKey
]
this
)
;
}
}
}
}
)
;
}
if
(
result
.
ownSymbols
)
{
result
.
ownSymbols
.
forEach
(
(
descriptor
i
arr
)
=
>
{
if
(
descriptor
)
{
for
(
const
gripKey
of
gripKeys
)
{
if
(
descriptor
.
hasOwnProperty
(
gripKey
)
)
{
arr
[
i
]
[
gripKey
]
=
getAdHocFrontOrPrimitiveGrip
(
descriptor
[
gripKey
]
this
)
;
}
}
}
}
)
;
}
return
result
;
}
enumProperties
(
options
)
{
return
super
.
enumProperties
(
options
)
;
}
enumEntries
(
)
{
if
(
!
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
"
Storage
"
]
.
includes
(
this
.
_grip
.
class
)
)
{
console
.
error
(
"
enumEntries
is
only
valid
for
Map
/
Set
/
Storage
-
like
grips
.
"
)
;
return
null
;
}
return
super
.
enumEntries
(
)
;
}
enumSymbols
(
)
{
if
(
this
.
_grip
.
type
!
=
=
"
object
"
)
{
console
.
error
(
"
enumSymbols
is
only
valid
for
objects
grips
.
"
)
;
return
null
;
}
return
super
.
enumSymbols
(
)
;
}
getProperty
(
name
)
{
return
super
.
property
(
name
)
;
}
async
getPropertyValue
(
name
receiverId
)
{
const
response
=
await
super
.
propertyValue
(
name
receiverId
)
;
if
(
response
.
value
)
{
const
{
value
}
=
response
;
if
(
value
.
return
)
{
response
.
value
.
return
=
getAdHocFrontOrPrimitiveGrip
(
value
.
return
this
)
;
}
if
(
value
.
throw
)
{
response
.
value
.
throw
=
getAdHocFrontOrPrimitiveGrip
(
value
.
throw
this
)
;
}
}
return
response
;
}
async
getPrototype
(
)
{
const
result
=
await
super
.
prototype
(
)
;
if
(
!
result
.
prototype
)
{
return
result
;
}
result
.
prototype
=
getAdHocFrontOrPrimitiveGrip
(
result
.
prototype
this
)
;
return
result
;
}
getDisplayString
(
)
{
return
super
.
displayString
(
)
;
}
async
getProxySlots
(
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Proxy
"
)
{
console
.
error
(
"
getProxySlots
is
only
valid
for
proxy
grips
.
"
)
;
return
null
;
}
const
response
=
await
super
.
proxySlots
(
)
;
const
{
proxyHandler
proxyTarget
}
=
response
;
if
(
proxyHandler
)
{
response
.
proxyHandler
=
getAdHocFrontOrPrimitiveGrip
(
proxyHandler
this
)
;
}
if
(
proxyTarget
)
{
response
.
proxyTarget
=
getAdHocFrontOrPrimitiveGrip
(
proxyTarget
this
)
;
}
return
response
;
}
get
isSyntaxError
(
)
{
return
this
.
_grip
.
preview
&
&
this
.
_grip
.
preview
.
name
=
=
"
SyntaxError
"
;
}
}
function
getAdHocFrontOrPrimitiveGrip
(
packet
parentFront
)
{
const
isPacketAnObject
=
packet
&
&
typeof
packet
=
=
=
"
object
"
;
const
isFront
=
!
!
packet
.
typeName
;
if
(
!
isPacketAnObject
|
|
packet
.
type
=
=
"
symbol
"
|
|
(
packet
.
type
!
=
=
"
mapEntry
"
&
&
!
packet
.
actor
)
|
|
isFront
)
{
return
packet
;
}
const
{
conn
}
=
parentFront
;
const
targetFront
=
parentFront
.
isTargetFront
?
parentFront
:
parentFront
.
targetFront
;
const
existingFront
=
conn
.
getFrontByID
(
packet
.
actor
)
;
if
(
existingFront
)
{
return
existingFront
;
}
const
{
type
}
=
packet
;
if
(
type
=
=
=
"
longString
"
)
{
const
longStringFront
=
new
LongStringFront
(
conn
targetFront
parentFront
)
;
longStringFront
.
form
(
packet
)
;
parentFront
.
manage
(
longStringFront
)
;
return
longStringFront
;
}
if
(
type
=
=
=
"
mapEntry
"
&
&
packet
.
preview
)
{
const
{
key
value
}
=
packet
.
preview
;
packet
.
preview
.
key
=
getAdHocFrontOrPrimitiveGrip
(
key
parentFront
targetFront
)
;
packet
.
preview
.
value
=
getAdHocFrontOrPrimitiveGrip
(
value
parentFront
targetFront
)
;
return
packet
;
}
const
objectFront
=
new
ObjectFront
(
conn
targetFront
parentFront
packet
)
;
createChildFronts
(
objectFront
packet
)
;
return
objectFront
;
}
function
createChildFronts
(
objectFront
packet
)
{
if
(
packet
.
class
=
=
"
Promise
"
&
&
packet
.
promiseState
)
{
if
(
packet
.
promiseState
.
state
=
=
"
fulfilled
"
&
&
packet
.
promiseState
.
value
)
{
packet
.
promiseState
.
value
=
getAdHocFrontOrPrimitiveGrip
(
packet
.
promiseState
.
value
objectFront
)
;
}
else
if
(
packet
.
promiseState
.
state
=
=
"
rejected
"
&
&
packet
.
promiseState
.
reason
)
{
packet
.
promiseState
.
reason
=
getAdHocFrontOrPrimitiveGrip
(
packet
.
promiseState
.
reason
objectFront
)
;
}
}
if
(
packet
.
preview
)
{
const
{
message
entries
}
=
packet
.
preview
;
if
(
packet
.
preview
.
message
)
{
packet
.
preview
.
message
=
getAdHocFrontOrPrimitiveGrip
(
message
objectFront
)
;
}
if
(
entries
&
&
Array
.
isArray
(
entries
)
)
{
packet
.
preview
.
entries
=
entries
.
map
(
(
[
key
value
]
)
=
>
[
getAdHocFrontOrPrimitiveGrip
(
key
objectFront
)
getAdHocFrontOrPrimitiveGrip
(
value
objectFront
)
]
)
;
}
}
if
(
packet
&
&
typeof
packet
.
ownProperties
=
=
=
"
object
"
)
{
for
(
const
[
name
descriptor
]
of
Object
.
entries
(
packet
.
ownProperties
)
)
{
const
gripKeys
=
[
"
value
"
"
getterValue
"
"
get
"
"
set
"
]
;
for
(
const
key
of
gripKeys
)
{
if
(
descriptor
&
&
typeof
descriptor
=
=
=
"
object
"
&
&
descriptor
.
hasOwnProperty
(
key
)
)
{
packet
.
ownProperties
[
name
]
[
key
]
=
getAdHocFrontOrPrimitiveGrip
(
descriptor
[
key
]
objectFront
)
;
}
}
}
}
}
registerFront
(
ObjectFront
)
;
exports
.
ObjectFront
=
ObjectFront
;
exports
.
getAdHocFrontOrPrimitiveGrip
=
getAdHocFrontOrPrimitiveGrip
;
