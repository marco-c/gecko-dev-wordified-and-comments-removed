"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
{
rootSpec
}
=
require
(
"
devtools
/
shared
/
specs
/
root
"
)
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
loader
.
lazyRequireGetter
(
this
"
getFront
"
"
devtools
/
shared
/
protocol
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TabDescriptorFront
"
"
devtools
/
client
/
fronts
/
descriptors
/
tab
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowsingContextTargetFront
"
"
devtools
/
client
/
fronts
/
targets
/
browsing
-
context
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LocalTabTargetFront
"
"
devtools
/
client
/
fronts
/
targets
/
local
-
tab
"
true
)
;
class
RootFront
extends
FrontClassWithSpec
(
rootSpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
Object
.
defineProperty
(
this
"
rootForm
"
{
get
(
)
{
delete
this
.
rootForm
;
this
.
rootForm
=
this
.
getRoot
(
)
;
return
this
.
rootForm
;
}
configurable
:
true
}
)
;
this
.
fronts
=
new
Map
(
)
;
this
.
_client
=
client
;
}
form
(
form
)
{
this
.
actorID
=
form
.
from
;
this
.
applicationType
=
form
.
applicationType
;
this
.
traits
=
form
.
traits
;
}
async
listAllServiceWorkers
(
workerTargets
)
{
const
result
=
[
]
;
const
{
registrations
}
=
await
this
.
listServiceWorkerRegistrations
(
)
;
const
allWorkers
=
workerTargets
?
workerTargets
:
await
this
.
listAllWorkerTargets
(
)
;
for
(
const
registrationFront
of
registrations
)
{
const
latestWorker
=
registrationFront
.
activeWorker
|
|
registrationFront
.
waitingWorker
|
|
registrationFront
.
installingWorker
|
|
registrationFront
.
evaluatingWorker
;
if
(
latestWorker
!
=
=
null
)
{
const
latestWorkerFront
=
allWorkers
.
find
(
workerFront
=
>
workerFront
.
id
=
=
=
latestWorker
.
id
)
;
if
(
latestWorkerFront
)
{
registrationFront
.
workerTargetFront
=
latestWorkerFront
;
}
result
.
push
(
{
registration
:
registrationFront
workers
:
[
{
id
:
registrationFront
.
id
name
:
latestWorker
.
url
state
:
latestWorker
.
state
stateText
:
latestWorker
.
stateText
url
:
latestWorker
.
url
workerTargetFront
:
latestWorkerFront
}
]
}
)
;
}
}
return
result
;
}
async
listAllWorkers
(
)
{
const
allWorkers
=
await
this
.
listAllWorkerTargets
(
)
;
const
serviceWorkers
=
await
this
.
listAllServiceWorkers
(
allWorkers
)
;
const
result
=
{
service
:
serviceWorkers
.
map
(
(
{
registration
workers
}
)
=
>
{
return
workers
.
map
(
worker
=
>
{
return
Object
.
assign
(
worker
{
registrationFront
:
registration
fetch
:
registration
.
fetch
}
)
;
}
)
;
}
)
.
flat
(
)
shared
:
[
]
other
:
[
]
}
;
allWorkers
.
forEach
(
front
=
>
{
const
worker
=
{
id
:
front
.
id
url
:
front
.
url
name
:
front
.
url
workerTargetFront
:
front
}
;
switch
(
front
.
type
)
{
case
Ci
.
nsIWorkerDebugger
.
TYPE_SERVICE
:
break
;
case
Ci
.
nsIWorkerDebugger
.
TYPE_SHARED
:
result
.
shared
.
push
(
worker
)
;
break
;
default
:
result
.
other
.
push
(
worker
)
;
}
}
)
;
return
result
;
}
async
listAllWorkerTargets
(
)
{
const
listParentWorkers
=
async
(
)
=
>
{
const
{
workers
}
=
await
this
.
listWorkers
(
)
;
return
workers
;
}
;
const
listChildWorkers
=
async
(
)
=
>
{
const
processes
=
await
this
.
listProcesses
(
)
;
const
processWorkers
=
await
Promise
.
all
(
processes
.
map
(
async
processDescriptorFront
=
>
{
if
(
processDescriptorFront
.
isParent
)
{
return
[
]
;
}
const
front
=
await
processDescriptorFront
.
getTarget
(
)
;
if
(
!
front
)
{
return
[
]
;
}
const
response
=
await
front
.
listWorkers
(
)
;
return
response
.
workers
;
}
)
)
;
return
processWorkers
.
flat
(
)
;
}
;
const
[
parentWorkers
childWorkers
]
=
await
Promise
.
all
(
[
listParentWorkers
(
)
listChildWorkers
(
)
]
)
;
return
parentWorkers
.
concat
(
childWorkers
)
;
}
getMainProcess
(
)
{
return
this
.
getProcess
(
0
)
;
}
async
listTabs
(
{
favicons
}
=
{
}
)
{
const
{
selected
tabs
}
=
await
super
.
listTabs
(
{
favicons
}
)
;
const
targets
=
[
]
;
for
(
const
i
in
tabs
)
{
if
(
!
this
.
actorID
)
{
console
.
error
(
"
The
root
front
was
destroyed
while
processing
listTabs
"
)
;
return
[
]
;
}
try
{
const
form
=
tabs
[
i
]
;
const
target
=
await
this
.
_createTargetFrontForTabForm
(
form
)
;
target
.
setIsSelected
(
i
=
=
selected
)
;
targets
.
push
(
target
)
;
}
catch
(
e
)
{
console
.
error
(
"
Failed
to
get
the
target
for
tab
descriptor
"
e
)
;
}
}
return
targets
;
}
async
getTab
(
filter
)
{
const
packet
=
{
}
;
if
(
filter
)
{
if
(
typeof
filter
.
outerWindowID
=
=
"
number
"
)
{
packet
.
outerWindowID
=
filter
.
outerWindowID
;
}
else
if
(
typeof
filter
.
tabId
=
=
"
number
"
)
{
packet
.
tabId
=
filter
.
tabId
;
}
else
if
(
"
tab
"
in
filter
)
{
const
browser
=
filter
.
tab
.
linkedBrowser
;
if
(
browser
.
frameLoader
.
remoteTab
)
{
packet
.
tabId
=
browser
.
frameLoader
.
remoteTab
.
tabId
;
}
else
if
(
browser
.
outerWindowID
)
{
packet
.
outerWindowID
=
browser
.
outerWindowID
;
}
else
{
const
windowUtils
=
browser
.
contentWindow
.
windowUtils
;
packet
.
outerWindowID
=
windowUtils
.
outerWindowID
;
}
}
else
{
throw
new
Error
(
"
Unsupported
argument
given
to
getTab
request
"
)
;
}
}
const
form
=
await
super
.
getTab
(
packet
)
;
return
this
.
_createTargetFrontForTabForm
(
form
filter
)
;
}
async
_createTargetFrontForTabForm
(
form
filter
=
{
}
)
{
let
front
=
this
.
actor
(
form
.
actor
)
;
if
(
front
)
{
if
(
!
form
.
actor
.
includes
(
"
tabDescriptor
"
)
)
{
front
.
form
(
form
)
;
return
front
;
}
return
front
.
getTarget
(
)
;
}
if
(
!
form
.
actor
.
includes
(
"
tabDescriptor
"
)
)
{
if
(
filter
?
.
tab
?
.
tagName
=
=
"
tab
"
)
{
front
=
new
LocalTabTargetFront
(
this
.
_client
null
this
filter
.
tab
)
;
}
else
{
front
=
new
BrowsingContextTargetFront
(
this
.
_client
null
this
)
;
}
front
.
actorID
=
form
.
actor
;
front
.
form
(
form
)
;
this
.
manage
(
front
)
;
return
front
;
}
const
descriptorFront
=
new
TabDescriptorFront
(
this
.
_client
null
this
)
;
descriptorFront
.
actorID
=
form
.
actor
;
descriptorFront
.
form
(
form
)
;
this
.
manage
(
descriptorFront
)
;
front
=
await
descriptorFront
.
getTarget
(
filter
)
;
return
front
;
}
async
getAddon
(
{
id
}
)
{
const
addons
=
await
this
.
listAddons
(
)
;
const
webextensionDescriptorFront
=
addons
.
find
(
addon
=
>
addon
.
id
=
=
=
id
)
;
return
webextensionDescriptorFront
;
}
async
getWorker
(
id
)
{
const
{
service
shared
other
}
=
await
this
.
listAllWorkers
(
)
;
const
worker
=
[
.
.
.
service
.
.
.
shared
.
.
.
other
]
.
find
(
w
=
>
w
.
id
=
=
=
id
)
;
if
(
!
worker
)
{
return
null
;
}
return
worker
.
workerTargetFront
|
|
worker
.
registrationFront
;
}
echo
(
packet
)
{
packet
.
type
=
"
echo
"
;
return
this
.
request
(
packet
)
;
}
async
getFront
(
typeName
)
{
let
front
=
this
.
fronts
.
get
(
typeName
)
;
if
(
front
)
{
return
front
;
}
const
rootForm
=
await
this
.
rootForm
;
front
=
getFront
(
this
.
_client
typeName
rootForm
)
;
this
.
fronts
.
set
(
typeName
front
)
;
return
front
;
}
async
hasActor
(
actorName
)
{
const
rootForm
=
await
this
.
rootForm
;
return
!
!
rootForm
[
actorName
+
"
Actor
"
]
;
}
}
exports
.
RootFront
=
RootFront
;
registerFront
(
RootFront
)
;
