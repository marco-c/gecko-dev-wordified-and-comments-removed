"
use
strict
"
;
const
{
FrontClassWithSpec
registerFront
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
protocol
.
js
"
)
;
const
{
styleRuleSpec
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
style
-
rule
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
RuleRewriter
"
"
resource
:
/
/
devtools
/
client
/
fronts
/
inspector
/
rule
-
rewriter
.
js
"
)
;
class
StyleRuleFront
extends
FrontClassWithSpec
(
styleRuleSpec
)
{
constructor
(
client
targetFront
parentFront
)
{
super
(
client
targetFront
parentFront
)
;
this
.
before
(
"
location
-
changed
"
this
.
_locationChangedPre
.
bind
(
this
)
)
;
}
form
(
form
)
{
this
.
actorID
=
form
.
actor
;
this
.
_form
=
form
;
this
.
traits
=
form
.
traits
|
|
{
}
;
}
_locationChangedPre
(
line
column
)
{
this
.
_form
.
line
=
line
;
this
.
_form
.
column
=
column
;
}
startModifyingProperties
(
cssProperties
)
{
if
(
this
.
canSetRuleText
)
{
return
new
RuleRewriter
(
cssProperties
.
isKnown
this
this
.
authoredText
)
;
}
return
new
RuleModificationList
(
this
)
;
}
get
type
(
)
{
return
this
.
_form
.
type
;
}
get
line
(
)
{
return
this
.
_form
.
line
|
|
-
1
;
}
get
column
(
)
{
return
this
.
_form
.
column
|
|
-
1
;
}
get
cssText
(
)
{
return
this
.
_form
.
cssText
;
}
get
isNestedDeclarations
(
)
{
return
!
!
this
.
_form
.
isNestedDeclarations
;
}
get
authoredText
(
)
{
return
typeof
this
.
_form
.
authoredText
=
=
=
"
string
"
?
this
.
_form
.
authoredText
:
this
.
_form
.
cssText
;
}
get
declarations
(
)
{
return
this
.
_form
.
declarations
|
|
[
]
;
}
get
keyText
(
)
{
return
this
.
_form
.
keyText
;
}
get
name
(
)
{
return
this
.
_form
.
name
;
}
get
selectors
(
)
{
return
this
.
_form
.
selectors
;
}
get
selectorsSpecificity
(
)
{
return
this
.
_form
.
selectorsSpecificity
;
}
get
computedSelector
(
)
{
let
selector
=
"
"
;
for
(
const
ancestor
of
this
.
ancestorData
)
{
let
ancestorSelector
;
if
(
ancestor
.
selectors
)
{
ancestorSelector
=
ancestor
.
selectors
.
join
(
"
"
)
;
}
else
if
(
ancestor
.
type
=
=
=
"
container
"
)
{
ancestorSelector
=
ancestor
.
containerName
+
"
"
+
ancestor
.
containerQuery
;
}
else
if
(
ancestor
.
type
=
=
=
"
supports
"
)
{
ancestorSelector
=
ancestor
.
conditionText
;
}
else
if
(
ancestor
.
value
)
{
ancestorSelector
=
ancestor
.
value
;
}
selector
+
=
"
/
"
+
(
ancestor
.
type
?
ancestor
.
type
+
"
"
:
"
"
)
+
ancestorSelector
;
}
return
(
selector
?
selector
+
"
/
"
:
"
"
)
+
this
.
_form
.
selectors
.
join
(
"
"
)
;
}
get
selectorWarnings
(
)
{
return
this
.
_form
.
selectorWarnings
;
}
get
parentStyleSheet
(
)
{
const
resourceCommand
=
this
.
targetFront
.
commands
.
resourceCommand
;
return
resourceCommand
.
getResourceById
(
resourceCommand
.
TYPES
.
STYLESHEET
this
.
_form
.
parentStyleSheet
)
;
}
get
element
(
)
{
return
this
.
conn
.
getFrontByID
(
this
.
_form
.
element
)
;
}
get
href
(
)
{
if
(
this
.
_form
.
href
)
{
return
this
.
_form
.
href
;
}
const
sheet
=
this
.
parentStyleSheet
;
return
sheet
?
sheet
.
href
:
"
"
;
}
get
nodeHref
(
)
{
const
sheet
=
this
.
parentStyleSheet
;
return
sheet
?
sheet
.
nodeHref
:
"
"
;
}
get
canSetRuleText
(
)
{
return
this
.
_form
.
traits
&
&
this
.
_form
.
traits
.
canSetRuleText
;
}
get
location
(
)
{
return
{
source
:
this
.
parentStyleSheet
href
:
this
.
href
line
:
this
.
line
column
:
this
.
column
}
;
}
get
ancestorData
(
)
{
return
this
.
_form
.
ancestorData
;
}
get
userAdded
(
)
{
return
this
.
_form
.
userAdded
;
}
async
modifySelector
(
node
value
)
{
const
response
=
await
super
.
modifySelector
(
node
value
this
.
canSetRuleText
)
;
if
(
response
.
ruleProps
)
{
response
.
ruleProps
=
response
.
ruleProps
.
entries
[
0
]
;
}
return
response
;
}
setRuleText
(
newText
modifications
)
{
this
.
_form
.
authoredText
=
newText
;
return
super
.
setRuleText
(
newText
modifications
)
;
}
}
exports
.
StyleRuleFront
=
StyleRuleFront
;
registerFront
(
StyleRuleFront
)
;
class
RuleModificationList
{
constructor
(
rule
)
{
this
.
rule
=
rule
;
this
.
modifications
=
[
]
;
}
apply
(
)
{
return
this
.
rule
.
modifyProperties
(
this
.
modifications
)
;
}
setProperty
(
index
name
value
priority
)
{
this
.
modifications
.
push
(
{
type
:
"
set
"
index
name
value
priority
}
)
;
}
removeProperty
(
index
name
)
{
this
.
modifications
.
push
(
{
type
:
"
remove
"
index
name
}
)
;
}
renameProperty
(
index
name
)
{
this
.
removeProperty
(
index
name
)
;
}
setPropertyEnabled
(
index
name
isEnabled
)
{
if
(
!
isEnabled
)
{
this
.
modifications
.
push
(
{
type
:
"
disable
"
index
name
}
)
;
}
}
createProperty
(
)
{
}
}
