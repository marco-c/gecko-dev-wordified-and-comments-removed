"
use
strict
"
;
const
{
createClass
DOM
:
dom
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
debugWorker
}
=
require
(
"
.
.
/
.
.
/
modules
/
worker
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
debugger
-
client
"
true
)
;
const
Strings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
aboutdebugging
.
properties
"
)
;
module
.
exports
=
createClass
(
{
displayName
:
"
ServiceWorkerTarget
"
propTypes
:
{
client
:
PropTypes
.
instanceOf
(
DebuggerClient
)
.
isRequired
debugDisabled
:
PropTypes
.
bool
target
:
PropTypes
.
shape
(
{
active
:
PropTypes
.
bool
fetch
:
PropTypes
.
bool
.
isRequired
icon
:
PropTypes
.
string
name
:
PropTypes
.
string
.
isRequired
url
:
PropTypes
.
string
scope
:
PropTypes
.
string
.
isRequired
registrationActor
:
PropTypes
.
string
workerActor
:
PropTypes
.
string
}
)
.
isRequired
}
getInitialState
(
)
{
return
{
pushSubscription
:
null
}
;
}
componentDidMount
(
)
{
let
{
client
}
=
this
.
props
;
client
.
addListener
(
"
push
-
subscription
-
modified
"
this
.
onPushSubscriptionModified
)
;
this
.
updatePushSubscription
(
)
;
}
componentDidUpdate
(
oldProps
oldState
)
{
let
wasActive
=
oldProps
.
target
.
active
;
if
(
!
wasActive
&
&
this
.
isActive
(
)
)
{
this
.
updatePushSubscription
(
)
;
}
}
componentWillUnmount
(
)
{
let
{
client
}
=
this
.
props
;
client
.
removeListener
(
"
push
-
subscription
-
modified
"
this
.
onPushSubscriptionModified
)
;
}
debug
(
)
{
if
(
!
this
.
isRunning
(
)
)
{
return
;
}
let
{
client
target
}
=
this
.
props
;
debugWorker
(
client
target
.
workerActor
)
;
}
push
(
)
{
if
(
!
this
.
isActive
(
)
|
|
!
this
.
isRunning
(
)
)
{
return
;
}
let
{
client
target
}
=
this
.
props
;
client
.
request
(
{
to
:
target
.
workerActor
type
:
"
push
"
}
)
;
}
start
(
)
{
if
(
!
this
.
isActive
(
)
|
|
this
.
isRunning
(
)
)
{
return
;
}
let
{
client
target
}
=
this
.
props
;
client
.
request
(
{
to
:
target
.
registrationActor
type
:
"
start
"
}
)
;
}
unregister
(
)
{
let
{
client
target
}
=
this
.
props
;
client
.
request
(
{
to
:
target
.
registrationActor
type
:
"
unregister
"
}
)
;
}
onPushSubscriptionModified
(
type
data
)
{
let
{
target
}
=
this
.
props
;
if
(
data
.
from
=
=
=
target
.
registrationActor
)
{
this
.
updatePushSubscription
(
)
;
}
}
updatePushSubscription
(
)
{
if
(
!
this
.
props
.
target
.
registrationActor
)
{
return
;
}
let
{
client
target
}
=
this
.
props
;
client
.
request
(
{
to
:
target
.
registrationActor
type
:
"
getPushSubscription
"
}
(
{
subscription
}
)
=
>
{
this
.
setState
(
{
pushSubscription
:
subscription
}
)
;
}
)
;
}
isRunning
(
)
{
return
!
!
this
.
props
.
target
.
workerActor
;
}
isActive
(
)
{
return
this
.
props
.
target
.
active
;
}
getServiceWorkerStatus
(
)
{
if
(
this
.
isActive
(
)
&
&
this
.
isRunning
(
)
)
{
return
"
running
"
;
}
else
if
(
this
.
isActive
(
)
)
{
return
"
stopped
"
;
}
return
"
registering
"
;
}
renderButtons
(
)
{
let
pushButton
=
dom
.
button
(
{
className
:
"
push
-
button
"
onClick
:
this
.
push
disabled
:
this
.
props
.
debugDisabled
}
Strings
.
GetStringFromName
(
"
push
"
)
)
;
let
debugButton
=
dom
.
button
(
{
className
:
"
debug
-
button
"
onClick
:
this
.
debug
disabled
:
this
.
props
.
debugDisabled
}
Strings
.
GetStringFromName
(
"
debug
"
)
)
;
let
startButton
=
dom
.
button
(
{
className
:
"
start
-
button
"
onClick
:
this
.
start
disabled
:
this
.
props
.
debugDisabled
}
Strings
.
GetStringFromName
(
"
start
"
)
)
;
if
(
this
.
isRunning
(
)
)
{
if
(
this
.
isActive
(
)
)
{
return
[
pushButton
debugButton
]
;
}
return
debugButton
;
}
return
startButton
;
}
renderUnregisterLink
(
)
{
if
(
!
this
.
isActive
(
)
)
{
return
null
;
}
return
dom
.
a
(
{
onClick
:
this
.
unregister
className
:
"
unregister
-
link
"
}
Strings
.
GetStringFromName
(
"
unregister
"
)
)
;
}
render
(
)
{
let
{
target
}
=
this
.
props
;
let
{
pushSubscription
}
=
this
.
state
;
let
status
=
this
.
getServiceWorkerStatus
(
)
;
let
fetch
=
target
.
fetch
?
Strings
.
GetStringFromName
(
"
listeningForFetchEvents
"
)
:
Strings
.
GetStringFromName
(
"
notListeningForFetchEvents
"
)
;
return
dom
.
div
(
{
className
:
"
target
-
container
"
}
dom
.
img
(
{
className
:
"
target
-
icon
"
role
:
"
presentation
"
src
:
target
.
icon
}
)
dom
.
span
(
{
className
:
target
-
status
target
-
status
-
{
status
}
}
Strings
.
GetStringFromName
(
status
)
)
dom
.
div
(
{
className
:
"
target
"
}
dom
.
div
(
{
className
:
"
target
-
name
"
title
:
target
.
name
}
target
.
name
)
dom
.
ul
(
{
className
:
"
target
-
details
"
}
(
pushSubscription
?
dom
.
li
(
{
className
:
"
target
-
detail
"
}
dom
.
strong
(
null
Strings
.
GetStringFromName
(
"
pushService
"
)
)
dom
.
span
(
{
className
:
"
service
-
worker
-
push
-
url
"
title
:
pushSubscription
.
endpoint
}
pushSubscription
.
endpoint
)
)
:
null
)
dom
.
li
(
{
className
:
"
target
-
detail
"
}
dom
.
strong
(
null
Strings
.
GetStringFromName
(
"
fetch
"
)
)
dom
.
span
(
{
className
:
"
service
-
worker
-
fetch
-
flag
"
title
:
fetch
}
fetch
)
)
dom
.
li
(
{
className
:
"
target
-
detail
"
}
dom
.
strong
(
null
Strings
.
GetStringFromName
(
"
scope
"
)
)
dom
.
span
(
{
className
:
"
service
-
worker
-
scope
"
title
:
target
.
scope
}
target
.
scope
)
this
.
renderUnregisterLink
(
)
)
)
)
this
.
renderButtons
(
)
)
;
}
}
)
;
