"
use
strict
"
;
const
MOCKS_ROOT
=
CHROME_URL_ROOT
+
"
mocks
/
"
;
Services
.
scriptloader
.
loadSubScript
(
MOCKS_ROOT
+
"
helper
-
adb
-
mock
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
MOCKS_ROOT
+
"
helper
-
client
-
wrapper
-
mock
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
MOCKS_ROOT
+
"
helper
-
runtime
-
client
-
factory
-
mock
.
js
"
this
)
;
const
{
RUNTIMES
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
aboutdebugging
/
src
/
constants
.
js
"
)
;
class
Mocks
{
constructor
(
)
{
this
.
adbMock
=
createAdbMock
(
)
;
this
.
adbProcessMock
=
createAdbProcessMock
(
)
;
this
.
_usbRuntimes
=
[
]
;
this
.
_usbDevices
=
[
]
;
this
.
adbMock
.
adb
.
getRuntimes
=
(
)
=
>
{
return
this
.
_usbRuntimes
;
}
;
this
.
adbMock
.
adb
.
getDevices
=
(
)
=
>
{
const
runtimeDevices
=
this
.
_usbRuntimes
.
map
(
r
=
>
{
return
{
id
:
r
.
deviceId
name
:
r
.
deviceName
}
;
}
)
;
return
runtimeDevices
.
concat
(
this
.
_usbDevices
)
;
}
;
this
.
adbMock
.
adb
.
updateRuntimes
=
(
)
=
>
{
this
.
emitUSBUpdate
(
)
;
}
;
this
.
adbMock
.
adb
.
isProcessStarted
=
(
)
=
>
true
;
this
.
_observerMock
=
addObserverMock
(
this
.
adbMock
.
adb
)
;
this
.
runtimeClientFactoryMock
=
createRuntimeClientFactoryMock
(
)
;
this
.
_clients
=
{
[
RUNTIMES
.
NETWORK
]
:
{
}
[
RUNTIMES
.
THIS_FIREFOX
]
:
{
}
[
RUNTIMES
.
USB
]
:
{
}
}
;
this
.
runtimeClientFactoryMock
.
createClientForRuntime
=
runtime
=
>
{
return
this
.
_clients
[
runtime
.
type
]
[
runtime
.
id
]
;
}
;
this
.
_thisFirefoxClient
=
createThisFirefoxClientMock
(
)
;
this
.
_clients
[
RUNTIMES
.
THIS_FIREFOX
]
[
RUNTIMES
.
THIS_FIREFOX
]
=
this
.
_thisFirefoxClient
;
this
.
enableMocks
(
)
;
registerCleanupFunction
(
(
)
=
>
this
.
disableMocks
(
)
)
;
}
get
thisFirefoxClient
(
)
{
return
this
.
_thisFirefoxClient
;
}
enableMocks
(
)
{
enableAdbMock
(
this
.
adbMock
)
;
enableAdbProcessMock
(
this
.
adbProcessMock
)
;
enableRuntimeClientFactoryMock
(
this
.
runtimeClientFactoryMock
)
;
}
disableMocks
(
)
{
disableAdbMock
(
)
;
disableAdbProcessMock
(
)
;
disableRuntimeClientFactoryMock
(
)
;
for
(
const
host
of
Object
.
keys
(
this
.
_clients
[
RUNTIMES
.
NETWORK
]
)
)
{
this
.
removeNetworkRuntime
(
host
)
;
}
}
createNetworkRuntime
(
host
runtimeInfo
)
{
const
{
addNetworkLocation
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
aboutdebugging
/
src
/
modules
/
network
-
locations
.
js
"
)
;
addNetworkLocation
(
host
)
;
const
mockNetworkClient
=
createClientMock
(
)
;
mockNetworkClient
.
getDeviceDescription
=
(
)
=
>
{
return
{
name
:
runtimeInfo
.
name
|
|
"
TestBrand
"
channel
:
runtimeInfo
.
channel
|
|
"
release
"
version
:
runtimeInfo
.
version
|
|
"
1
.
0
"
}
;
}
;
this
.
_clients
[
RUNTIMES
.
NETWORK
]
[
host
]
=
mockNetworkClient
;
return
mockNetworkClient
;
}
removeNetworkRuntime
(
host
)
{
const
{
removeNetworkLocation
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
aboutdebugging
/
src
/
modules
/
network
-
locations
.
js
"
)
;
removeNetworkLocation
(
host
)
;
delete
this
.
_clients
[
RUNTIMES
.
NETWORK
]
[
host
]
;
}
emitUSBUpdate
(
)
{
this
.
_observerMock
.
emit
(
"
runtime
-
list
-
updated
"
)
;
}
createUSBRuntime
(
id
runtimeInfo
=
{
}
)
{
this
.
_usbRuntimes
.
push
(
{
deviceId
:
runtimeInfo
.
deviceId
|
|
"
test
device
id
"
deviceName
:
runtimeInfo
.
deviceName
|
|
"
test
device
name
"
id
isFenix
:
runtimeInfo
.
isFenix
shortName
:
runtimeInfo
.
shortName
|
|
"
testshort
"
socketPath
:
runtimeInfo
.
socketPath
|
|
"
test
/
path
"
versionName
:
runtimeInfo
.
versionName
|
|
"
1
.
0
"
}
)
;
let
mockUsbClient
=
runtimeInfo
.
clientWrapper
;
if
(
mockUsbClient
)
{
const
originalGetDeviceDescription
=
mockUsbClient
.
getDeviceDescription
.
bind
(
mockUsbClient
)
;
mockUsbClient
.
getDeviceDescription
=
async
(
)
=
>
{
const
deviceDescription
=
await
originalGetDeviceDescription
(
)
;
return
{
channel
:
runtimeInfo
.
channel
|
|
deviceDescription
.
channel
name
:
runtimeInfo
.
name
|
|
deviceDescription
.
name
version
:
runtimeInfo
.
version
|
|
deviceDescription
.
version
}
;
}
;
}
else
{
mockUsbClient
=
createClientMock
(
)
;
mockUsbClient
.
getDeviceDescription
=
(
)
=
>
{
return
{
channel
:
runtimeInfo
.
channel
|
|
"
release
"
name
:
runtimeInfo
.
name
|
|
"
TestBrand
"
version
:
runtimeInfo
.
version
|
|
"
1
.
0
"
}
;
}
;
}
this
.
_clients
[
RUNTIMES
.
USB
]
[
id
]
=
mockUsbClient
;
return
mockUsbClient
;
}
removeUSBRuntime
(
id
)
{
this
.
_usbRuntimes
=
this
.
_usbRuntimes
.
filter
(
runtime
=
>
runtime
.
id
!
=
=
id
)
;
delete
this
.
_clients
[
RUNTIMES
.
USB
]
[
id
]
;
}
addDevice
(
deviceId
deviceName
)
{
this
.
_usbDevices
.
push
(
{
id
:
deviceId
name
:
deviceName
}
)
;
}
removeDevice
(
deviceId
)
{
this
.
_usbDevices
=
this
.
_usbDevices
.
filter
(
d
=
>
{
return
d
.
id
!
=
=
deviceId
;
}
)
;
}
removeRuntime
(
id
)
{
if
(
this
.
_clients
[
RUNTIMES
.
USB
]
[
id
]
)
{
this
.
removeUSBRuntime
(
id
)
;
}
else
if
(
this
.
_clients
[
RUNTIMES
.
NETWORK
]
[
id
]
)
{
this
.
removeNetworkRuntime
(
id
)
;
}
}
}
const
silenceWorkerUpdates
=
function
(
)
{
const
{
removeMockedModule
setMockedModule
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
browser
-
loader
-
mocks
.
js
"
)
;
const
mock
=
{
WorkersListener
:
(
)
=
>
{
return
{
addListener
:
(
)
=
>
{
}
removeListener
:
(
)
=
>
{
}
}
;
}
}
;
setMockedModule
(
mock
"
devtools
/
client
/
shared
/
workers
-
listener
"
)
;
registerCleanupFunction
(
(
)
=
>
{
removeMockedModule
(
"
devtools
/
client
/
shared
/
workers
-
listener
"
)
;
}
)
;
}
;
async
function
createLocalClientWrapper
(
)
{
info
(
"
Create
a
local
DevToolsClient
"
)
;
const
{
useDistinctSystemPrincipalLoader
releaseDistinctSystemPrincipalLoader
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
DistinctSystemPrincipalLoader
.
sys
.
mjs
"
)
;
const
requester
=
{
}
;
const
serverLoader
=
useDistinctSystemPrincipalLoader
(
requester
)
;
registerCleanupFunction
(
(
)
=
>
{
releaseDistinctSystemPrincipalLoader
(
requester
)
;
}
)
;
const
{
DevToolsServer
}
=
serverLoader
.
require
(
"
resource
:
/
/
devtools
/
server
/
devtools
-
server
.
js
"
)
;
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
DevToolsServer
.
allowChromeProcess
=
true
;
const
{
DevToolsClient
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
devtools
-
client
.
js
"
)
;
const
{
ClientWrapper
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
aboutdebugging
/
src
/
modules
/
client
-
wrapper
.
js
"
)
;
const
client
=
new
DevToolsClient
(
DevToolsServer
.
connectPipe
(
)
)
;
await
client
.
connect
(
)
;
return
new
ClientWrapper
(
client
)
;
}
function
setupThisFirefoxMock
(
)
{
const
runtimeClientFactoryMock
=
createRuntimeClientFactoryMock
(
)
;
const
thisFirefoxClient
=
createThisFirefoxClientMock
(
)
;
runtimeClientFactoryMock
.
createClientForRuntime
=
runtime
=
>
{
if
(
runtime
.
id
=
=
=
RUNTIMES
.
THIS_FIREFOX
)
{
return
thisFirefoxClient
;
}
throw
new
Error
(
"
Unexpected
runtime
id
"
+
runtime
.
id
)
;
}
;
info
(
"
Enable
mocks
"
)
;
enableRuntimeClientFactoryMock
(
runtimeClientFactoryMock
)
;
registerCleanupFunction
(
(
)
=
>
{
disableRuntimeClientFactoryMock
(
)
;
}
)
;
return
thisFirefoxClient
;
}
