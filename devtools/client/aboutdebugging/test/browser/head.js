"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
CHROME_URL_ROOT
+
"
helper
-
mocks
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
webconsole
/
test
/
browser
/
shared
-
head
.
js
"
this
)
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
selectedTool
"
)
;
try
{
const
{
adbAddon
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
remote
-
debugging
/
adb
/
adb
-
addon
.
js
"
)
;
await
adbAddon
.
uninstall
(
)
;
}
catch
(
e
)
{
}
const
{
adbProcess
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
remote
-
debugging
/
adb
/
adb
-
process
.
js
"
)
;
await
adbProcess
.
kill
(
)
;
const
{
remoteClientManager
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
remote
-
debugging
/
remote
-
client
-
manager
.
js
"
)
;
await
remoteClientManager
.
removeAllClients
(
)
;
}
)
;
async
function
openAboutDebugging
(
{
enableWorkerUpdates
enableLocalTabs
=
true
}
=
{
}
)
{
if
(
!
enableWorkerUpdates
)
{
silenceWorkerUpdates
(
)
;
}
await
pushPref
(
"
devtools
.
aboutdebugging
.
local
-
tab
-
debugging
"
enableLocalTabs
)
;
info
(
"
opening
about
:
debugging
"
)
;
const
tab
=
await
addTab
(
"
about
:
debugging
"
)
;
const
browser
=
tab
.
linkedBrowser
;
const
document
=
browser
.
contentDocument
;
const
window
=
browser
.
contentWindow
;
info
(
"
Wait
until
Connect
page
is
displayed
"
)
;
await
waitUntil
(
(
)
=
>
document
.
querySelector
(
"
.
qa
-
connect
-
page
"
)
)
;
return
{
tab
document
window
}
;
}
async
function
openAboutDevtoolsToolbox
(
doc
tab
win
targetText
=
"
about
:
debugging
"
shouldWaitToolboxReady
=
true
)
{
info
(
"
Open
about
:
devtools
-
toolbox
page
"
)
;
info
(
"
Wait
for
the
target
to
appear
:
"
+
targetText
)
;
await
waitUntil
(
(
)
=
>
findDebugTargetByText
(
targetText
doc
)
)
;
const
target
=
findDebugTargetByText
(
targetText
doc
)
;
ok
(
target
{
targetText
}
target
appeared
)
;
const
{
DEBUG_TARGETS
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
aboutdebugging
/
src
/
constants
.
js
"
)
;
const
isWebExtension
=
target
.
dataset
.
qaTargetType
=
=
DEBUG_TARGETS
.
EXTENSION
;
const
inspectButton
=
target
.
querySelector
(
"
.
qa
-
debug
-
target
-
inspect
-
button
"
)
;
ok
(
inspectButton
Inspect
button
for
{
targetText
}
appeared
)
;
inspectButton
.
click
(
)
;
const
onToolboxReady
=
gDevTools
.
once
(
"
toolbox
-
ready
"
)
;
info
(
"
Wait
for
about
debugging
requests
to
settle
"
)
;
await
waitForAboutDebuggingRequests
(
win
.
AboutDebugging
.
store
)
;
if
(
shouldWaitToolboxReady
)
{
info
(
"
Wait
for
onToolboxReady
"
)
;
await
onToolboxReady
;
}
const
{
runtimes
}
=
win
.
AboutDebugging
.
store
.
getState
(
)
;
const
isOnThisFirefox
=
runtimes
.
selectedRuntimeId
=
=
=
"
this
-
firefox
"
;
const
isLocalWebExtension
=
isWebExtension
&
&
isOnThisFirefox
;
if
(
isLocalWebExtension
)
{
const
toolbox
=
await
onToolboxReady
;
const
focusedWin
=
Services
.
focus
.
focusedWindow
;
if
(
focusedWin
?
.
top
!
=
toolbox
.
win
)
{
info
(
"
Wait
for
the
toolbox
window
to
be
focused
"
)
;
await
new
Promise
(
r
=
>
{
toolbox
.
win
.
docShell
.
chromeEventHandler
.
addEventListener
(
"
focus
"
r
{
once
:
true
capture
:
true
}
)
;
toolbox
.
win
.
focus
(
)
;
}
)
;
info
(
"
The
toolbox
is
focused
"
)
;
}
return
{
devtoolsBrowser
:
null
devtoolsDocument
:
toolbox
.
doc
devtoolsTab
:
null
devtoolsWindow
:
toolbox
.
win
}
;
}
info
(
"
Wait
until
a
new
tab
is
opened
"
)
;
await
waitUntil
(
(
)
=
>
tab
.
nextElementSibling
)
;
info
(
"
Wait
for
about
:
devtools
-
toolbox
tab
will
be
selected
"
)
;
const
devtoolsTab
=
tab
.
nextElementSibling
;
await
waitUntil
(
(
)
=
>
gBrowser
.
selectedTab
=
=
=
devtoolsTab
)
;
const
devtoolsBrowser
=
gBrowser
.
selectedBrowser
;
info
(
"
Wait
for
about
:
devtools
-
toolbox
tab
to
have
the
expected
URL
"
)
;
await
waitUntil
(
(
)
=
>
devtoolsBrowser
.
contentWindow
.
location
.
href
.
startsWith
(
"
about
:
devtools
-
toolbox
?
"
)
)
;
if
(
!
shouldWaitToolboxReady
)
{
await
waitUntil
(
(
)
=
>
devtoolsBrowser
.
contentDocument
.
querySelector
(
"
.
qa
-
error
-
page
"
)
)
;
}
return
{
devtoolsBrowser
devtoolsDocument
:
devtoolsBrowser
.
contentDocument
devtoolsTab
devtoolsWindow
:
devtoolsBrowser
.
contentWindow
}
;
}
async
function
closeAboutDevtoolsToolbox
(
aboutDebuggingDocument
devtoolsTab
win
)
{
const
devtoolsBrowser
=
devtoolsTab
.
linkedBrowser
;
const
devtoolsWindow
=
devtoolsBrowser
.
contentWindow
;
const
toolbox
=
getToolbox
(
devtoolsWindow
)
;
info
(
"
Wait
for
requests
to
settle
"
)
;
await
toolbox
.
commands
.
client
.
waitForRequestsToSettle
(
{
ignoreOrphanedFronts
:
true
}
)
;
info
(
"
Close
about
:
devtools
-
toolbox
page
"
)
;
const
onToolboxDestroyed
=
gDevTools
.
once
(
"
toolbox
-
destroyed
"
)
;
info
(
"
Wait
for
removeTab
"
)
;
await
removeTab
(
devtoolsTab
)
;
info
(
"
Wait
for
toolbox
destroyed
"
)
;
await
onToolboxDestroyed
;
info
(
"
Wait
until
aboutdebugging
is
selected
"
)
;
await
waitUntil
(
(
)
=
>
gBrowser
.
selectedTab
!
=
=
devtoolsTab
)
;
info
(
"
Wait
until
about
:
devtools
-
toolbox
is
removed
from
debug
targets
"
)
;
await
waitUntil
(
(
)
=
>
!
findDebugTargetByText
(
"
Toolbox
-
"
aboutDebuggingDocument
)
)
;
await
waitForAboutDebuggingRequests
(
win
.
AboutDebugging
.
store
)
;
}
async
function
closeWebExtAboutDevtoolsToolbox
(
devtoolsWindow
win
)
{
const
toolbox
=
getToolbox
(
devtoolsWindow
)
;
await
toolbox
.
commands
.
client
.
waitForRequestsToSettle
(
)
;
info
(
"
Close
the
toolbox
and
wait
for
its
destruction
"
)
;
await
toolbox
.
destroy
(
)
;
await
waitForAboutDebuggingRequests
(
win
.
AboutDebugging
.
store
)
;
}
async
function
reloadAboutDebugging
(
tab
)
{
info
(
"
reload
about
:
debugging
"
)
;
await
reloadBrowser
(
tab
.
linkedBrowser
)
;
const
browser
=
tab
.
linkedBrowser
;
const
document
=
browser
.
contentDocument
;
const
window
=
browser
.
contentWindow
;
info
(
"
wait
for
the
initial
about
:
debugging
requests
to
settle
"
)
;
await
waitForAboutDebuggingRequests
(
window
.
AboutDebugging
.
store
)
;
return
document
;
}
function
waitForRequestsSuccess
(
store
)
{
return
Promise
.
all
(
[
waitForDispatch
(
store
"
REQUEST_EXTENSIONS_SUCCESS
"
)
waitForDispatch
(
store
"
REQUEST_TABS_SUCCESS
"
)
waitForDispatch
(
store
"
REQUEST_WORKERS_SUCCESS
"
)
]
)
;
}
async
function
waitForAboutDebuggingRequests
(
store
delay
=
500
)
{
let
hasSettled
=
false
;
while
(
!
hasSettled
)
{
let
timer
;
const
timerPromise
=
new
Promise
(
resolve
=
>
{
timer
=
setTimeout
(
(
)
=
>
{
hasSettled
=
true
;
resolve
(
)
;
}
delay
)
;
}
)
;
await
Promise
.
race
(
[
waitForDispatch
(
store
"
REQUEST_EXTENSIONS_SUCCESS
"
)
waitForDispatch
(
store
"
REQUEST_TABS_SUCCESS
"
)
waitForDispatch
(
store
"
REQUEST_WORKERS_SUCCESS
"
)
timerPromise
]
)
;
clearTimeout
(
timer
)
;
}
}
async
function
selectThisFirefoxPage
(
doc
store
)
{
info
(
"
Select
This
Firefox
page
"
)
;
const
onRequestSuccess
=
waitForRequestsSuccess
(
store
)
;
doc
.
location
.
hash
=
"
#
/
runtime
/
this
-
firefox
"
;
info
(
"
Wait
for
requests
to
be
complete
"
)
;
await
onRequestSuccess
;
info
(
"
Wait
for
runtime
page
to
be
rendered
"
)
;
await
waitUntil
(
(
)
=
>
doc
.
querySelector
(
"
.
qa
-
runtime
-
page
"
)
)
;
await
waitForAboutDebuggingRequests
(
store
)
;
}
async
function
selectConnectPage
(
doc
)
{
const
sidebarItems
=
doc
.
querySelectorAll
(
"
.
qa
-
sidebar
-
item
"
)
;
const
connectSidebarItem
=
[
.
.
.
sidebarItems
]
.
find
(
element
=
>
{
return
element
.
textContent
=
=
=
"
Setup
"
;
}
)
;
ok
(
connectSidebarItem
"
Sidebar
contains
a
Connect
item
"
)
;
const
connectLink
=
connectSidebarItem
.
querySelector
(
"
.
qa
-
sidebar
-
link
"
)
;
ok
(
connectLink
"
Sidebar
contains
a
Connect
link
"
)
;
info
(
"
Click
on
the
Connect
link
in
the
sidebar
"
)
;
connectLink
.
click
(
)
;
info
(
"
Wait
until
Connect
page
is
displayed
"
)
;
await
waitUntil
(
(
)
=
>
doc
.
querySelector
(
"
.
qa
-
connect
-
page
"
)
)
;
}
function
getDebugTargetPane
(
title
document
)
{
const
sanitizeTitle
=
x
=
>
{
return
x
.
replace
(
/
\
s
+
\
(
\
d
+
\
)
/
"
"
)
;
}
;
const
targetTitle
=
sanitizeTitle
(
title
)
;
for
(
const
titleEl
of
document
.
querySelectorAll
(
"
.
qa
-
debug
-
target
-
pane
-
title
"
)
)
{
if
(
sanitizeTitle
(
titleEl
.
textContent
)
!
=
=
targetTitle
)
{
continue
;
}
return
titleEl
.
closest
(
"
.
qa
-
debug
-
target
-
pane
"
)
;
}
return
null
;
}
function
findDebugTargetByText
(
text
document
)
{
const
targets
=
[
.
.
.
document
.
querySelectorAll
(
"
.
qa
-
debug
-
target
-
item
"
)
]
;
return
targets
.
find
(
target
=
>
target
.
textContent
.
includes
(
text
)
)
;
}
function
findSidebarItemByText
(
text
document
)
{
const
sidebarItems
=
document
.
querySelectorAll
(
"
.
qa
-
sidebar
-
item
"
)
;
return
[
.
.
.
sidebarItems
]
.
find
(
element
=
>
{
return
element
.
textContent
.
includes
(
text
)
;
}
)
;
}
function
findSidebarItemLinkByText
(
text
document
)
{
const
links
=
document
.
querySelectorAll
(
"
.
qa
-
sidebar
-
link
"
)
;
return
[
.
.
.
links
]
.
find
(
element
=
>
{
return
element
.
textContent
.
includes
(
text
)
;
}
)
;
}
async
function
connectToRuntime
(
deviceName
document
)
{
info
(
Wait
until
the
sidebar
item
for
{
deviceName
}
appears
)
;
await
waitUntil
(
(
)
=
>
findSidebarItemByText
(
deviceName
document
)
)
;
const
sidebarItem
=
findSidebarItemByText
(
deviceName
document
)
;
const
connectButton
=
sidebarItem
.
querySelector
(
"
.
qa
-
connect
-
button
"
)
;
ok
(
connectButton
Connect
button
is
displayed
for
the
runtime
{
deviceName
}
)
;
info
(
"
Click
on
the
connect
button
and
wait
until
it
disappears
"
)
;
connectButton
.
click
(
)
;
await
waitUntil
(
(
)
=
>
!
sidebarItem
.
querySelector
(
"
.
qa
-
connect
-
button
"
)
)
;
}
async
function
selectRuntime
(
deviceName
name
document
)
{
const
sidebarItem
=
findSidebarItemByText
(
deviceName
document
)
;
const
store
=
document
.
defaultView
.
AboutDebugging
.
store
;
const
onSelectPageSuccess
=
waitForDispatch
(
store
"
SELECT_PAGE_SUCCESS
"
)
;
sidebarItem
.
querySelector
(
"
.
qa
-
sidebar
-
link
"
)
.
click
(
)
;
await
waitUntil
(
(
)
=
>
{
const
runtimeInfo
=
document
.
querySelector
(
"
.
qa
-
runtime
-
name
"
)
;
return
runtimeInfo
&
&
runtimeInfo
.
textContent
.
includes
(
name
)
;
}
)
;
info
(
"
Wait
for
SELECT_PAGE_SUCCESS
to
be
dispatched
"
)
;
await
onSelectPageSuccess
;
}
function
getToolbox
(
win
)
{
return
gDevTools
.
getToolboxes
(
)
.
find
(
toolbox
=
>
toolbox
.
win
=
=
=
win
)
;
}
async
function
openProfilerDialog
(
client
doc
)
{
const
onProfilerLoaded
=
new
Promise
(
r
=
>
{
client
.
loadPerformanceProfiler
=
r
;
}
)
;
info
(
"
Click
on
the
Profile
Runtime
button
"
)
;
const
profileButton
=
doc
.
querySelector
(
"
.
qa
-
profile
-
runtime
-
button
"
)
;
profileButton
.
click
(
)
;
info
(
"
Wait
for
the
loadPerformanceProfiler
callback
to
be
executed
on
client
-
wrapper
"
)
;
return
onProfilerLoaded
;
}
function
getThisFirefoxString
(
aboutDebuggingWindow
)
{
const
loader
=
aboutDebuggingWindow
.
getBrowserLoaderForWindow
(
)
;
const
{
l10n
}
=
loader
.
require
(
"
resource
:
/
/
devtools
/
client
/
aboutdebugging
/
src
/
modules
/
l10n
.
js
"
)
;
return
l10n
.
getString
(
"
about
-
debugging
-
this
-
firefox
-
runtime
-
name
"
)
;
}
function
waitUntilUsbDeviceIsUnplugged
(
deviceName
aboutDebuggingDocument
)
{
info
(
"
Wait
until
the
USB
sidebar
item
appears
as
unplugged
"
)
;
return
waitUntil
(
(
)
=
>
{
const
sidebarItem
=
findSidebarItemByText
(
deviceName
aboutDebuggingDocument
)
;
return
!
!
sidebarItem
.
querySelector
(
"
.
qa
-
runtime
-
item
-
unplugged
"
)
;
}
)
;
}
async
function
updateSelectedTab
(
browser
tab
store
)
{
info
(
"
Update
the
selected
tab
"
)
;
const
{
runtimes
ui
}
=
store
.
getState
(
)
;
const
isOnThisFirefox
=
runtimes
.
selectedRuntimeId
=
=
=
"
this
-
firefox
"
&
&
ui
.
selectedPage
=
=
=
"
runtime
"
;
const
onTabsSuccess
=
isOnThisFirefox
?
waitForDispatch
(
store
"
REQUEST_TABS_SUCCESS
"
)
:
null
;
browser
.
selectedTab
=
tab
;
if
(
onTabsSuccess
)
{
info
(
"
Wait
for
the
tablist
update
after
updating
the
selected
tab
"
)
;
await
onTabsSuccess
;
}
}
async
function
synthesizeUrlKeyInput
(
toolbox
inputEl
url
)
{
const
{
devtoolsDocument
devtoolsWindow
}
=
toolbox
;
info
(
"
Wait
for
URL
input
to
be
focused
.
"
)
;
const
onInputFocused
=
waitUntil
(
(
)
=
>
devtoolsDocument
.
activeElement
=
=
=
inputEl
)
;
inputEl
.
focus
(
)
;
await
onInputFocused
;
info
(
"
Synthesize
entering
URL
into
text
field
"
)
;
const
onInputChange
=
waitUntil
(
(
)
=
>
inputEl
.
value
=
=
=
url
)
;
for
(
const
key
of
url
.
split
(
"
"
)
)
{
EventUtils
.
synthesizeKey
(
key
{
}
devtoolsWindow
)
;
}
await
onInputChange
;
info
(
"
Submit
URL
to
navigate
to
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
)
;
}
function
clickOnAddonWidget
(
addonId
)
{
const
focusedWin
=
Services
.
focus
.
focusedWindow
;
if
(
focusedWin
!
=
window
)
{
window
.
focus
(
)
;
}
const
widgetId
=
addonId
.
toLowerCase
(
)
.
replace
(
/
[
^
a
-
z0
-
9_
-
]
/
g
"
_
"
)
;
const
browserActionId
=
widgetId
+
"
-
browser
-
action
"
;
const
browserActionEl
=
window
.
document
.
getElementById
(
browserActionId
)
;
ok
(
browserActionEl
"
Got
the
browserAction
button
from
the
browser
UI
"
)
;
info
(
"
Show
the
web
extension
popup
"
)
;
browserActionEl
.
querySelector
(
"
.
unified
-
extensions
-
item
-
action
-
button
"
)
.
click
(
)
;
}
function
createAddonData
(
{
id
name
isSystem
=
false
hidden
=
false
temporary
=
false
}
)
{
return
{
actor
:
actorid
-
{
id
}
hidden
iconURL
:
moz
-
extension
:
/
/
{
id
}
/
icon
-
url
.
png
id
manifestURL
:
moz
-
extension
:
/
/
{
id
}
/
manifest
-
url
.
json
name
isSystem
temporarilyInstalled
:
temporary
debuggable
:
true
}
;
}
async
function
connectToLocalFirefox
(
{
runtimeId
runtimeName
deviceName
}
)
{
const
clientWrapper
=
await
createLocalClientWrapper
(
)
;
const
mocks
=
new
Mocks
(
)
;
const
usbClient
=
mocks
.
createUSBRuntime
(
runtimeId
{
deviceName
name
:
runtimeName
clientWrapper
}
)
;
const
disconnect
=
doc
=
>
disconnectFromLocalFirefox
(
{
doc
runtimeId
deviceName
mocks
}
)
;
return
{
disconnect
mocks
usbClient
}
;
}
async
function
disconnectFromLocalFirefox
(
{
doc
mocks
runtimeId
deviceName
}
)
{
info
(
"
Remove
USB
runtime
"
)
;
mocks
.
removeUSBRuntime
(
runtimeId
)
;
mocks
.
emitUSBUpdate
(
)
;
await
waitUntilUsbDeviceIsUnplugged
(
deviceName
doc
)
;
}
