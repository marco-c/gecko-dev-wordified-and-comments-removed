"
use
strict
"
;
var
{
utils
:
Cu
classes
:
Cc
interfaces
:
Ci
}
=
Components
;
const
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
AddonManager
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
{
}
)
;
const
Services
=
require
(
"
Services
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
DevToolsUtils
.
testing
=
true
;
const
CHROME_ROOT
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
+
1
)
;
registerCleanupFunction
(
(
)
=
>
{
DevToolsUtils
.
testing
=
false
;
}
)
;
function
*
openAboutDebugging
(
page
)
{
info
(
"
opening
about
:
debugging
"
)
;
let
url
=
"
about
:
debugging
"
;
if
(
page
)
{
url
+
=
"
#
"
+
page
;
}
let
tab
=
yield
addTab
(
url
)
;
let
browser
=
tab
.
linkedBrowser
;
let
document
=
browser
.
contentDocument
;
if
(
!
document
.
querySelector
(
"
.
app
"
)
)
{
yield
waitForMutation
(
document
.
body
{
childList
:
true
}
)
;
}
return
{
tab
document
}
;
}
function
closeAboutDebugging
(
tab
)
{
info
(
"
Closing
about
:
debugging
"
)
;
return
removeTab
(
tab
)
;
}
function
addTab
(
url
win
backgroundTab
=
false
)
{
info
(
"
Adding
tab
:
"
+
url
)
;
return
new
Promise
(
done
=
>
{
let
targetWindow
=
win
|
|
window
;
let
targetBrowser
=
targetWindow
.
gBrowser
;
targetWindow
.
focus
(
)
;
let
tab
=
targetBrowser
.
addTab
(
url
)
;
if
(
!
backgroundTab
)
{
targetBrowser
.
selectedTab
=
tab
;
}
let
linkedBrowser
=
tab
.
linkedBrowser
;
linkedBrowser
.
addEventListener
(
"
load
"
function
onLoad
(
)
{
linkedBrowser
.
removeEventListener
(
"
load
"
onLoad
true
)
;
info
(
"
Tab
added
and
finished
loading
:
"
+
url
)
;
done
(
tab
)
;
}
true
)
;
}
)
;
}
function
removeTab
(
tab
win
)
{
info
(
"
Removing
tab
.
"
)
;
return
new
Promise
(
done
=
>
{
let
targetWindow
=
win
|
|
window
;
let
targetBrowser
=
targetWindow
.
gBrowser
;
let
tabContainer
=
targetBrowser
.
tabContainer
;
tabContainer
.
addEventListener
(
"
TabClose
"
function
onClose
(
)
{
tabContainer
.
removeEventListener
(
"
TabClose
"
onClose
false
)
;
info
(
"
Tab
removed
and
finished
closing
.
"
)
;
done
(
)
;
}
false
)
;
targetBrowser
.
removeTab
(
tab
)
;
}
)
;
}
function
getSupportsFile
(
path
)
{
let
cr
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
let
uri
=
Services
.
io
.
newURI
(
CHROME_ROOT
+
path
null
null
)
;
let
fileurl
=
cr
.
convertChromeURL
(
uri
)
;
return
fileurl
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
}
function
getAddonList
(
document
)
{
return
document
.
querySelector
(
"
#
addons
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
addons
.
targets
"
)
;
}
function
getServiceWorkerList
(
document
)
{
return
document
.
querySelector
(
"
#
service
-
workers
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
service
-
workers
.
targets
"
)
;
}
function
getTabList
(
document
)
{
return
document
.
querySelector
(
"
#
tabs
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
tabs
.
targets
"
)
;
}
function
*
installAddon
(
document
path
name
evt
)
{
let
MockFilePicker
=
SpecialPowers
.
MockFilePicker
;
MockFilePicker
.
init
(
null
)
;
let
file
=
getSupportsFile
(
path
)
;
MockFilePicker
.
returnFiles
=
[
file
.
file
]
;
let
addonList
=
getAddonList
(
document
)
;
let
addonListMutation
=
waitForMutation
(
addonList
{
childList
:
true
}
)
;
let
onAddonInstalled
=
new
Promise
(
done
=
>
{
Services
.
obs
.
addObserver
(
function
listener
(
)
{
Services
.
obs
.
removeObserver
(
listener
evt
)
;
done
(
)
;
}
evt
false
)
;
}
)
;
document
.
getElementById
(
"
load
-
addon
-
from
-
file
"
)
.
click
(
)
;
yield
onAddonInstalled
;
ok
(
true
"
Addon
installed
and
running
its
bootstrap
.
js
file
"
)
;
yield
addonListMutation
;
let
names
=
[
.
.
.
addonList
.
querySelectorAll
(
"
.
target
-
name
"
)
]
;
names
=
names
.
map
(
element
=
>
element
.
textContent
)
;
ok
(
names
.
includes
(
name
)
"
The
addon
name
appears
in
the
list
of
addons
:
"
+
names
)
;
}
function
*
uninstallAddon
(
document
addonId
addonName
)
{
let
addonList
=
getAddonList
(
document
)
;
let
addonListMutation
=
waitForMutation
(
addonList
{
childList
:
true
}
)
;
yield
new
Promise
(
done
=
>
{
AddonManager
.
getAddonByID
(
addonId
addon
=
>
{
let
listener
=
{
onUninstalled
:
function
(
uninstalledAddon
)
{
if
(
uninstalledAddon
!
=
addon
)
{
return
;
}
AddonManager
.
removeAddonListener
(
listener
)
;
done
(
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
addon
.
uninstall
(
)
;
}
)
;
}
)
;
yield
addonListMutation
;
let
names
=
[
.
.
.
addonList
.
querySelectorAll
(
"
.
target
-
name
"
)
]
;
names
=
names
.
map
(
element
=
>
element
.
textContent
)
;
ok
(
!
names
.
includes
(
addonName
)
"
After
uninstall
the
addon
name
disappears
from
the
list
of
addons
:
"
+
names
)
;
}
function
waitForInitialAddonList
(
document
)
{
const
addonListContainer
=
getAddonList
(
document
)
;
let
addonCount
=
addonListContainer
.
querySelectorAll
(
"
.
target
"
)
;
addonCount
=
addonCount
?
[
.
.
.
addonCount
]
.
length
:
-
1
;
info
(
"
Waiting
for
add
-
ons
to
load
.
Current
add
-
on
count
:
"
+
addonCount
)
;
let
result
;
if
(
addonCount
>
0
)
{
info
(
"
Actually
the
add
-
ons
have
already
loaded
"
)
;
result
=
Promise
.
resolve
(
)
;
}
else
{
result
=
waitForMutation
(
addonListContainer
{
childList
:
true
}
)
;
}
return
result
;
}
function
waitForMutation
(
target
mutationOptions
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
new
MutationObserver
(
(
)
=
>
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
)
;
observer
.
observe
(
target
mutationOptions
)
;
}
)
;
}
function
assertHasTarget
(
expected
document
type
name
)
{
let
names
=
[
.
.
.
document
.
querySelectorAll
(
"
#
"
+
type
+
"
.
target
-
name
"
)
]
;
names
=
names
.
map
(
element
=
>
element
.
textContent
)
;
is
(
names
.
includes
(
name
)
expected
"
The
"
+
type
+
"
url
appears
in
the
list
:
"
+
names
)
;
}
function
waitForServiceWorkerRegistered
(
tab
)
{
let
frameScript
=
function
(
)
{
let
{
sw
}
=
content
.
wrappedJSObject
;
sw
.
then
(
function
(
registration
)
{
sendAsyncMessage
(
"
sw
-
registered
"
)
;
}
)
;
}
;
let
mm
=
tab
.
linkedBrowser
.
messageManager
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
frameScript
)
+
"
)
(
)
"
true
)
;
return
new
Promise
(
done
=
>
{
mm
.
addMessageListener
(
"
sw
-
registered
"
function
listener
(
)
{
mm
.
removeMessageListener
(
"
sw
-
registered
"
listener
)
;
done
(
)
;
}
)
;
}
)
;
}
function
unregisterServiceWorker
(
tab
)
{
let
frameScript
=
function
(
)
{
let
{
sw
}
=
content
.
wrappedJSObject
;
sw
.
then
(
function
(
registration
)
{
registration
.
unregister
(
)
.
then
(
function
(
)
{
sendAsyncMessage
(
"
sw
-
unregistered
"
)
;
}
function
(
e
)
{
dump
(
"
SW
not
unregistered
;
"
+
e
+
"
\
n
"
)
;
}
)
;
}
)
;
}
;
let
mm
=
tab
.
linkedBrowser
.
messageManager
;
mm
.
loadFrameScript
(
"
data
:
(
"
+
encodeURIComponent
(
frameScript
)
+
"
)
(
)
"
true
)
;
return
new
Promise
(
done
=
>
{
mm
.
addMessageListener
(
"
sw
-
unregistered
"
function
listener
(
)
{
mm
.
removeMessageListener
(
"
sw
-
unregistered
"
listener
)
;
done
(
)
;
}
)
;
}
)
;
}
