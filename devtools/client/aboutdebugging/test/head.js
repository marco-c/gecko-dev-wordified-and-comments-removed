"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
framework
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
AddonManager
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
{
}
)
;
const
{
Management
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
;
flags
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
flags
.
testing
=
false
;
}
)
;
function
*
openAboutDebugging
(
page
win
)
{
info
(
"
opening
about
:
debugging
"
)
;
let
url
=
"
about
:
debugging
"
;
if
(
page
)
{
url
+
=
"
#
"
+
page
;
}
let
tab
=
yield
addTab
(
url
{
window
:
win
}
)
;
let
browser
=
tab
.
linkedBrowser
;
let
document
=
browser
.
contentDocument
;
if
(
!
document
.
querySelector
(
"
.
app
"
)
)
{
yield
waitForMutation
(
document
.
body
{
childList
:
true
}
)
;
}
return
{
tab
document
}
;
}
function
changeAboutDebuggingHash
(
document
hash
)
{
info
(
Opening
about
:
debugging
#
{
hash
}
)
;
window
.
openUILinkIn
(
about
:
debugging
#
{
hash
}
"
current
"
)
;
return
waitForMutation
(
document
.
querySelector
(
"
.
main
-
content
"
)
{
childList
:
true
}
)
;
}
function
openPanel
(
document
panelId
)
{
info
(
Opening
{
panelId
}
panel
)
;
document
.
querySelector
(
[
aria
-
controls
=
"
{
panelId
}
"
]
)
.
click
(
)
;
return
waitForMutation
(
document
.
querySelector
(
"
.
main
-
content
"
)
{
childList
:
true
}
)
;
}
function
closeAboutDebugging
(
tab
)
{
info
(
"
Closing
about
:
debugging
"
)
;
return
removeTab
(
tab
)
;
}
function
getSupportsFile
(
path
)
{
let
cr
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
let
uri
=
Services
.
io
.
newURI
(
CHROME_URL_ROOT
+
path
)
;
let
fileurl
=
cr
.
convertChromeURL
(
uri
)
;
return
fileurl
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
}
function
getAddonList
(
document
)
{
return
document
.
querySelector
(
"
#
addons
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
addons
.
targets
"
)
;
}
function
getServiceWorkerList
(
document
)
{
return
document
.
querySelector
(
"
#
service
-
workers
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
service
-
workers
.
targets
"
)
;
}
function
getTabList
(
document
)
{
return
document
.
querySelector
(
"
#
tabs
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
tabs
.
targets
"
)
;
}
function
*
installAddon
(
{
document
path
name
isWebExtension
}
)
{
let
MockFilePicker
=
SpecialPowers
.
MockFilePicker
;
MockFilePicker
.
init
(
window
)
;
let
file
=
getSupportsFile
(
path
)
;
MockFilePicker
.
returnFiles
=
[
file
.
file
]
;
let
addonList
=
getAddonList
(
document
)
;
let
addonListMutation
=
waitForMutation
(
addonList
{
childList
:
true
}
)
;
let
onAddonInstalled
;
if
(
isWebExtension
)
{
onAddonInstalled
=
new
Promise
(
done
=
>
{
Management
.
on
(
"
startup
"
function
listener
(
event
extension
)
{
if
(
extension
.
name
!
=
name
)
{
return
;
}
Management
.
off
(
"
startup
"
listener
)
;
done
(
)
;
}
)
;
}
)
;
}
else
{
onAddonInstalled
=
new
Promise
(
done
=
>
{
Services
.
obs
.
addObserver
(
function
listener
(
)
{
Services
.
obs
.
removeObserver
(
listener
"
test
-
devtools
"
)
;
done
(
)
;
}
"
test
-
devtools
"
false
)
;
}
)
;
}
document
.
getElementById
(
"
load
-
addon
-
from
-
file
"
)
.
click
(
)
;
yield
onAddonInstalled
;
ok
(
true
"
Addon
installed
and
running
its
bootstrap
.
js
file
"
)
;
yield
addonListMutation
;
let
names
=
[
.
.
.
addonList
.
querySelectorAll
(
"
.
target
-
name
"
)
]
;
names
=
names
.
map
(
element
=
>
element
.
textContent
)
;
ok
(
names
.
includes
(
name
)
"
The
addon
name
appears
in
the
list
of
addons
:
"
+
names
)
;
}
function
*
uninstallAddon
(
{
document
id
name
}
)
{
let
addonList
=
getAddonList
(
document
)
;
let
addonListMutation
=
waitForMutation
(
addonList
{
childList
:
true
}
)
;
yield
new
Promise
(
done
=
>
{
AddonManager
.
getAddonByID
(
id
addon
=
>
{
let
listener
=
{
onUninstalled
:
function
(
uninstalledAddon
)
{
if
(
uninstalledAddon
!
=
addon
)
{
return
;
}
AddonManager
.
removeAddonListener
(
listener
)
;
done
(
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
addon
.
uninstall
(
)
;
}
)
;
}
)
;
yield
addonListMutation
;
let
names
=
[
.
.
.
addonList
.
querySelectorAll
(
"
.
target
-
name
"
)
]
;
names
=
names
.
map
(
element
=
>
element
.
textContent
)
;
ok
(
!
names
.
includes
(
name
)
"
After
uninstall
the
addon
name
disappears
from
the
list
of
addons
:
"
+
names
)
;
}
function
waitForInitialAddonList
(
document
)
{
const
addonListContainer
=
getAddonList
(
document
)
;
let
addonCount
=
addonListContainer
.
querySelectorAll
(
"
.
target
"
)
;
addonCount
=
addonCount
?
[
.
.
.
addonCount
]
.
length
:
-
1
;
info
(
"
Waiting
for
add
-
ons
to
load
.
Current
add
-
on
count
:
"
+
addonCount
)
;
let
result
;
if
(
addonCount
>
0
)
{
info
(
"
Actually
the
add
-
ons
have
already
loaded
"
)
;
result
=
Promise
.
resolve
(
)
;
}
else
{
result
=
waitForMutation
(
addonListContainer
{
childList
:
true
}
)
;
}
return
result
;
}
function
waitForMutation
(
target
mutationOptions
)
{
return
new
Promise
(
resolve
=
>
{
let
observer
=
new
MutationObserver
(
(
)
=
>
{
observer
.
disconnect
(
)
;
resolve
(
)
;
}
)
;
observer
.
observe
(
target
mutationOptions
)
;
}
)
;
}
function
waitForContentMutation
(
target
)
{
return
waitForMutation
(
target
{
characterData
:
true
childList
:
true
subtree
:
true
}
)
;
}
function
assertHasTarget
(
expected
document
type
name
)
{
let
names
=
[
.
.
.
document
.
querySelectorAll
(
"
#
"
+
type
+
"
.
target
-
name
"
)
]
;
names
=
names
.
map
(
element
=
>
element
.
textContent
)
;
is
(
names
.
includes
(
name
)
expected
"
The
"
+
type
+
"
url
appears
in
the
list
:
"
+
names
)
;
}
function
waitForServiceWorkerRegistered
(
tab
)
{
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
function
*
(
)
{
let
{
sw
}
=
content
.
wrappedJSObject
;
yield
sw
;
}
)
;
}
function
*
unregisterServiceWorker
(
tab
serviceWorkersElement
)
{
let
onMutation
=
waitForMutation
(
serviceWorkersElement
{
childList
:
true
}
)
;
yield
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
function
*
(
)
{
let
{
sw
}
=
content
.
wrappedJSObject
;
let
registration
=
yield
sw
;
yield
registration
.
unregister
(
)
;
}
)
;
return
onMutation
;
}
function
waitForDelayedStartupFinished
(
win
)
{
return
new
Promise
(
function
(
resolve
)
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
)
{
if
(
win
=
=
subject
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
}
)
;
}
function
*
setupTestAboutDebuggingWebExtension
(
name
path
)
{
yield
new
Promise
(
resolve
=
>
{
let
options
=
{
"
set
"
:
[
[
"
devtools
.
chrome
.
enabled
"
true
]
[
"
devtools
.
debugger
.
remote
-
enabled
"
true
]
[
"
devtools
.
debugger
.
prompt
-
connection
"
false
]
[
"
devtools
.
browser
-
toolbox
.
allow
-
unsafe
-
script
"
true
]
]
}
;
SpecialPowers
.
pushPrefEnv
(
options
resolve
)
;
}
)
;
let
{
tab
document
}
=
yield
openAboutDebugging
(
"
addons
"
)
;
yield
waitForInitialAddonList
(
document
)
;
yield
installAddon
(
{
document
path
name
isWebExtension
:
true
}
)
;
let
names
=
[
.
.
.
document
.
querySelectorAll
(
"
#
addons
.
target
-
name
"
)
]
;
let
nameEl
=
names
.
filter
(
element
=
>
element
.
textContent
=
=
=
name
)
[
0
]
;
ok
(
name
"
Found
the
addon
in
the
list
"
)
;
let
targetElement
=
nameEl
.
parentNode
.
parentNode
;
let
debugBtn
=
targetElement
.
querySelector
(
"
.
debug
-
button
"
)
;
ok
(
debugBtn
"
Found
its
debug
button
"
)
;
return
{
tab
document
debugBtn
}
;
}
function
*
waitForServiceWorkerActivation
(
swUrl
document
)
{
let
serviceWorkersElement
=
getServiceWorkerList
(
document
)
;
let
names
=
serviceWorkersElement
.
querySelectorAll
(
"
.
target
-
name
"
)
;
let
name
=
[
.
.
.
names
]
.
filter
(
element
=
>
element
.
textContent
=
=
=
swUrl
)
[
0
]
;
let
targetElement
=
name
.
parentNode
.
parentNode
;
let
targetStatus
=
targetElement
.
querySelector
(
"
.
target
-
status
"
)
;
while
(
targetStatus
.
textContent
=
=
=
"
Registering
"
)
{
yield
waitForMutation
(
serviceWorkersElement
{
childList
:
true
subtree
:
true
}
)
;
}
}
