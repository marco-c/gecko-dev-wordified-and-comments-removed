"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
AddonManager
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
{
}
)
;
const
{
Management
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
{
}
)
;
async
function
openAboutDebugging
(
page
win
)
{
info
(
"
opening
about
:
debugging
"
)
;
let
url
=
"
about
:
debugging
"
;
if
(
page
)
{
url
+
=
"
#
"
+
page
;
}
let
tab
=
await
addTab
(
url
{
window
:
win
}
)
;
let
browser
=
tab
.
linkedBrowser
;
let
document
=
browser
.
contentDocument
;
let
window
=
browser
.
contentWindow
;
info
(
"
Wait
until
the
main
about
debugging
container
is
available
"
)
;
await
waitUntilElement
(
"
.
app
"
document
)
;
return
{
tab
document
window
}
;
}
function
closeAboutDebugging
(
tab
)
{
info
(
"
Closing
about
:
debugging
"
)
;
return
removeTab
(
tab
)
;
}
function
getSupportsFile
(
path
)
{
let
cr
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
let
uri
=
Services
.
io
.
newURI
(
CHROME_URL_ROOT
+
path
)
;
let
fileurl
=
cr
.
convertChromeURL
(
uri
)
;
return
fileurl
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
}
function
getAddonList
(
document
)
{
return
document
.
querySelector
(
"
#
addons
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
addons
.
targets
"
)
;
}
function
getTemporaryAddonList
(
document
)
{
return
document
.
querySelector
(
"
#
temporary
-
addons
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
temporary
-
addons
.
targets
"
)
;
}
function
getAddonListWithAddon
(
document
id
)
{
const
addon
=
document
.
querySelector
(
[
data
-
addon
-
id
=
"
{
id
}
"
]
)
;
if
(
!
addon
)
{
throw
new
Error
(
"
couldn
'
t
find
add
-
on
by
id
"
)
;
}
return
addon
.
closest
(
"
.
target
-
list
"
)
;
}
function
getInstalledAddonNames
(
document
)
{
const
selector
=
"
#
addons
.
target
-
name
#
temporary
-
addons
.
target
-
name
"
;
return
[
.
.
.
document
.
querySelectorAll
(
selector
)
]
;
}
function
getServiceWorkerList
(
document
)
{
return
document
.
querySelector
(
"
#
service
-
workers
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
service
-
workers
.
targets
"
)
;
}
function
getServiceWorkerContainer
(
name
document
)
{
let
nameElements
=
[
.
.
.
document
.
querySelectorAll
(
"
#
service
-
workers
.
target
-
name
"
)
]
;
let
nameElement
=
nameElements
.
filter
(
element
=
>
element
.
textContent
=
=
=
name
)
[
0
]
;
if
(
nameElement
)
{
return
nameElement
.
closest
(
"
.
target
-
container
"
)
;
}
return
null
;
}
async
function
waitUntilServiceWorkerContainer
(
name
document
)
{
await
waitUntil
(
(
)
=
>
{
return
getServiceWorkerContainer
(
name
document
)
;
}
100
)
;
return
getServiceWorkerContainer
(
name
document
)
;
}
async
function
waitUntilElement
(
selector
parent
)
{
await
waitUntil
(
(
)
=
>
{
return
parent
.
querySelector
(
selector
)
;
}
100
)
;
return
parent
.
querySelector
(
selector
)
;
}
function
getTabList
(
document
)
{
return
document
.
querySelector
(
"
#
tabs
.
target
-
list
"
)
|
|
document
.
querySelector
(
"
#
tabs
.
targets
"
)
;
}
async
function
installAddon
(
{
document
path
name
isWebExtension
}
)
{
let
MockFilePicker
=
SpecialPowers
.
MockFilePicker
;
MockFilePicker
.
init
(
window
)
;
let
file
=
getSupportsFile
(
path
)
;
MockFilePicker
.
setFiles
(
[
file
.
file
]
)
;
let
onAddonInstalled
;
if
(
isWebExtension
)
{
onAddonInstalled
=
new
Promise
(
done
=
>
{
Management
.
on
(
"
startup
"
function
listener
(
event
extension
)
{
if
(
extension
.
name
!
=
name
)
{
return
;
}
Management
.
off
(
"
startup
"
listener
)
;
done
(
)
;
}
)
;
}
)
;
}
else
{
onAddonInstalled
=
new
Promise
(
done
=
>
{
Services
.
obs
.
addObserver
(
function
listener
(
)
{
Services
.
obs
.
removeObserver
(
listener
"
test
-
devtools
"
)
;
done
(
)
;
}
"
test
-
devtools
"
)
;
}
)
;
}
document
.
getElementById
(
"
load
-
addon
-
from
-
file
"
)
.
click
(
)
;
await
onAddonInstalled
;
ok
(
true
"
Addon
installed
and
running
its
bootstrap
.
js
file
"
)
;
info
(
"
Wait
for
the
addon
to
appear
in
the
UI
"
)
;
await
waitUntilAddonContainer
(
name
document
)
;
}
async
function
uninstallAddon
(
{
document
id
name
}
)
{
await
new
Promise
(
done
=
>
{
AddonManager
.
getAddonByID
(
id
addon
=
>
{
let
listener
=
{
onUninstalled
:
function
(
uninstalledAddon
)
{
if
(
uninstalledAddon
!
=
addon
)
{
return
;
}
AddonManager
.
removeAddonListener
(
listener
)
;
done
(
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
addon
.
uninstall
(
)
;
}
)
;
}
)
;
info
(
"
Wait
until
the
addon
is
removed
from
about
:
debugging
"
)
;
await
waitUntil
(
(
)
=
>
!
getAddonContainer
(
name
document
)
100
)
;
}
function
getAddonCount
(
document
)
{
const
addonListContainer
=
getAddonList
(
document
)
;
let
addonElements
=
addonListContainer
.
querySelectorAll
(
"
.
target
"
)
;
return
addonElements
.
length
;
}
function
waitForInitialAddonList
(
document
)
{
info
(
"
Waiting
for
add
-
ons
to
load
.
Current
add
-
on
count
:
"
+
getAddonCount
(
document
)
)
;
return
waitUntil
(
(
)
=
>
getAddonCount
(
document
)
>
0
100
)
;
}
function
getAddonContainer
(
name
document
)
{
let
nameElements
=
[
.
.
.
document
.
querySelectorAll
(
"
#
addons
-
panel
.
target
-
name
"
)
]
;
let
nameElement
=
nameElements
.
filter
(
element
=
>
element
.
textContent
=
=
=
name
)
[
0
]
;
if
(
nameElement
)
{
return
nameElement
.
closest
(
"
.
addon
-
target
-
container
"
)
;
}
return
null
;
}
async
function
waitUntilAddonContainer
(
name
document
)
{
await
waitUntil
(
(
)
=
>
{
return
getAddonContainer
(
name
document
)
;
}
)
;
return
getAddonContainer
(
name
document
)
;
}
function
assertHasTarget
(
expected
document
type
name
)
{
let
names
=
[
.
.
.
document
.
querySelectorAll
(
"
#
"
+
type
+
"
.
target
-
name
"
)
]
;
names
=
names
.
map
(
element
=
>
element
.
textContent
)
;
is
(
names
.
includes
(
name
)
expected
"
The
"
+
type
+
"
url
appears
in
the
list
:
"
+
names
)
;
}
function
waitForServiceWorkerRegistered
(
tab
)
{
return
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
async
function
(
)
{
let
{
sw
}
=
content
.
wrappedJSObject
;
await
sw
;
}
)
;
}
async
function
unregisterServiceWorker
(
tab
serviceWorkersElement
)
{
let
registrations
=
serviceWorkersElement
.
querySelectorAll
(
"
.
target
-
container
"
)
;
let
registrationCount
=
registrations
.
length
;
let
isRemoved
=
waitUntil
(
(
)
=
>
{
registrations
=
serviceWorkersElement
.
querySelectorAll
(
"
.
target
-
container
"
)
;
return
registrations
.
length
=
=
=
registrationCount
-
1
;
}
100
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
{
}
async
function
(
)
{
let
{
sw
}
=
content
.
wrappedJSObject
;
let
registration
=
await
sw
;
await
registration
.
unregister
(
)
;
}
)
;
return
isRemoved
;
}
function
waitForDelayedStartupFinished
(
win
)
{
return
new
Promise
(
function
(
resolve
)
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
)
{
if
(
win
=
=
subject
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
}
async
function
setupTestAboutDebuggingWebExtension
(
name
path
)
{
await
new
Promise
(
resolve
=
>
{
let
options
=
{
"
set
"
:
[
[
"
devtools
.
chrome
.
enabled
"
true
]
[
"
devtools
.
debugger
.
remote
-
enabled
"
true
]
[
"
devtools
.
debugger
.
prompt
-
connection
"
false
]
[
"
devtools
.
browser
-
toolbox
.
allow
-
unsafe
-
script
"
true
]
]
}
;
SpecialPowers
.
pushPrefEnv
(
options
resolve
)
;
}
)
;
let
{
tab
document
}
=
await
openAboutDebugging
(
"
addons
"
)
;
await
waitForInitialAddonList
(
document
)
;
await
installAddon
(
{
document
path
name
isWebExtension
:
true
}
)
;
let
names
=
getInstalledAddonNames
(
document
)
;
let
nameEl
=
names
.
filter
(
element
=
>
element
.
textContent
=
=
=
name
)
[
0
]
;
ok
(
name
"
Found
the
addon
in
the
list
"
)
;
let
targetElement
=
nameEl
.
parentNode
.
parentNode
;
let
debugBtn
=
targetElement
.
querySelector
(
"
.
debug
-
button
"
)
;
ok
(
debugBtn
"
Found
its
debug
button
"
)
;
return
{
tab
document
debugBtn
}
;
}
async
function
waitForServiceWorkerActivation
(
swUrl
document
)
{
let
serviceWorkersElement
=
getServiceWorkerList
(
document
)
;
let
names
=
serviceWorkersElement
.
querySelectorAll
(
"
.
target
-
name
"
)
;
let
name
=
[
.
.
.
names
]
.
filter
(
element
=
>
element
.
textContent
=
=
=
swUrl
)
[
0
]
;
let
targetElement
=
name
.
parentNode
.
parentNode
;
let
targetStatus
=
targetElement
.
querySelector
(
"
.
target
-
status
"
)
;
await
waitUntil
(
(
)
=
>
{
return
targetStatus
.
textContent
!
=
=
"
Registering
"
;
}
100
)
;
}
async
function
enableServiceWorkerDebugging
(
)
{
let
options
=
{
"
set
"
:
[
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
dom
.
ipc
.
processCount
"
1
]
]
}
;
await
new
Promise
(
done
=
>
{
SpecialPowers
.
pushPrefEnv
(
options
done
)
;
}
)
;
Services
.
ppmm
.
releaseCachedProcesses
(
)
;
}
function
promiseAddonEvent
(
event
)
{
return
new
Promise
(
resolve
=
>
{
let
listener
=
{
[
event
]
:
function
(
.
.
.
args
)
{
AddonManager
.
removeAddonListener
(
listener
)
;
resolve
(
args
)
;
}
}
;
AddonManager
.
addAddonListener
(
listener
)
;
}
)
;
}
function
installAddonWithManager
(
filePath
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
AddonManager
.
getInstallForFile
(
filePath
install
=
>
{
if
(
!
install
)
{
throw
new
Error
(
An
install
was
not
created
for
{
filePath
}
)
;
}
install
.
addListener
(
{
onDownloadFailed
:
reject
onDownloadCancelled
:
reject
onInstallFailed
:
reject
onInstallCancelled
:
reject
onInstallEnded
:
resolve
}
)
;
install
.
install
(
)
;
}
)
;
}
)
;
}
function
getAddonByID
(
addonId
)
{
return
new
Promise
(
resolve
=
>
{
AddonManager
.
getAddonByID
(
addonId
addon
=
>
resolve
(
addon
)
)
;
}
)
;
}
async
function
tearDownAddon
(
addon
)
{
const
onUninstalled
=
promiseAddonEvent
(
"
onUninstalled
"
)
;
addon
.
uninstall
(
)
;
const
[
uninstalledAddon
]
=
await
onUninstalled
;
is
(
uninstalledAddon
.
id
addon
.
id
Add
-
on
was
uninstalled
:
{
uninstalledAddon
.
id
}
)
;
}
