"
use
strict
"
;
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
let
sharedHeadURI
=
testDir
+
"
.
.
/
.
.
/
.
.
/
framework
/
test
/
shared
-
head
.
js
"
;
Services
.
scriptloader
.
loadSubScript
(
sharedHeadURI
this
)
;
let
gcliHelpersURI
=
testDir
+
"
.
.
/
.
.
/
.
.
/
commandline
/
test
/
helpers
.
js
"
;
Services
.
scriptloader
.
loadSubScript
(
gcliHelpersURI
this
)
;
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
DevToolsUtils
.
testing
=
false
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsiveUI
.
currentPreset
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsiveUI
.
customHeight
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsiveUI
.
customWidth
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsiveUI
.
presets
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsiveUI
.
rotate
"
)
;
}
)
;
SimpleTest
.
requestCompleteLog
(
)
;
const
{
ResponsiveUIManager
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
responsivedesign
/
responsivedesign
.
jsm
"
{
}
)
;
var
openRDM
=
Task
.
async
(
function
*
(
tab
=
gBrowser
.
selectedTab
method
=
"
menu
"
)
{
let
manager
=
ResponsiveUIManager
;
let
opened
=
once
(
manager
"
on
"
)
;
let
resized
=
once
(
manager
"
contentResize
"
)
;
if
(
method
=
=
"
menu
"
)
{
document
.
getElementById
(
"
menu_responsiveUI
"
)
.
doCommand
(
)
;
}
else
{
synthesizeKeyFromKeyTag
(
document
.
getElementById
(
"
key_responsiveUI
"
)
)
;
}
yield
opened
;
let
rdm
=
manager
.
getResponsiveUIForTab
(
tab
)
;
rdm
.
transitionsEnabled
=
false
;
registerCleanupFunction
(
(
)
=
>
{
rdm
.
transitionsEnabled
=
true
;
}
)
;
yield
resized
;
return
{
rdm
manager
}
;
}
)
;
var
closeRDM
=
Task
.
async
(
function
*
(
rdm
)
{
let
manager
=
ResponsiveUIManager
;
if
(
!
rdm
)
{
rdm
=
manager
.
getResponsiveUIForTab
(
gBrowser
.
selectedTab
)
;
}
let
closed
=
once
(
manager
"
off
"
)
;
let
resized
=
once
(
manager
"
contentResize
"
)
;
rdm
.
close
(
)
;
yield
resized
;
yield
closed
;
}
)
;
var
openInspector
=
Task
.
async
(
function
*
(
)
{
info
(
"
Opening
the
inspector
"
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
inspector
toolbox
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
if
(
inspector
)
{
info
(
"
Toolbox
and
inspector
already
open
"
)
;
return
{
toolbox
:
toolbox
inspector
:
inspector
}
;
}
}
info
(
"
Opening
the
toolbox
"
)
;
toolbox
=
yield
gDevTools
.
showToolbox
(
target
"
inspector
"
)
;
yield
waitForToolboxFrameFocus
(
toolbox
)
;
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
info
(
"
Waiting
for
the
inspector
to
update
"
)
;
if
(
inspector
.
_updateProgress
)
{
yield
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
return
{
toolbox
:
toolbox
inspector
:
inspector
}
;
}
)
;
var
closeToolbox
=
Task
.
async
(
function
*
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
}
)
;
function
waitForToolboxFrameFocus
(
toolbox
)
{
info
(
"
Making
sure
that
the
toolbox
'
s
frame
is
focused
"
)
;
let
def
=
promise
.
defer
(
)
;
waitForFocus
(
def
.
resolve
toolbox
.
win
)
;
return
def
.
promise
;
}
var
openInspectorSideBar
=
Task
.
async
(
function
*
(
id
)
{
let
{
toolbox
inspector
}
=
yield
openInspector
(
)
;
info
(
"
Selecting
the
"
+
id
+
"
sidebar
"
)
;
inspector
.
sidebar
.
select
(
id
)
;
return
{
toolbox
:
toolbox
inspector
:
inspector
view
:
inspector
[
id
]
.
view
|
|
inspector
[
id
]
.
computedView
}
;
}
)
;
function
hasSideBarTab
(
inspector
id
)
{
return
!
!
inspector
.
sidebar
.
getWindowForTab
(
id
)
;
}
function
openComputedView
(
)
{
return
openInspectorSideBar
(
"
computedview
"
)
;
}
function
openRuleView
(
)
{
return
openInspectorSideBar
(
"
ruleview
"
)
;
}
var
addTab
=
Task
.
async
(
function
*
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
window
.
focus
(
)
;
let
tab
=
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
)
;
let
browser
=
tab
.
linkedBrowser
;
yield
once
(
browser
"
load
"
true
)
;
info
(
"
URL
'
"
+
url
+
"
'
loading
complete
"
)
;
return
tab
;
}
)
;
function
wait
(
ms
)
{
let
def
=
promise
.
defer
(
)
;
setTimeout
(
def
.
resolve
ms
)
;
return
def
.
promise
;
}
function
waitForDocLoadComplete
(
aBrowser
=
gBrowser
)
{
let
deferred
=
promise
.
defer
(
)
;
let
progressListener
=
{
onStateChange
:
function
(
webProgress
req
flags
status
)
{
let
docStop
=
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
|
Ci
.
nsIWebProgressListener
.
STATE_STOP
;
info
(
Saw
state
{
flags
.
toString
(
16
)
}
and
status
{
status
.
toString
(
16
)
}
)
;
if
(
(
flags
&
docStop
)
=
=
docStop
&
&
status
!
=
Cr
.
NS_BINDING_ABORTED
)
{
aBrowser
.
removeProgressListener
(
progressListener
)
;
info
(
"
Browser
loaded
"
)
;
deferred
.
resolve
(
)
;
}
}
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
}
;
aBrowser
.
addProgressListener
(
progressListener
)
;
info
(
"
Waiting
for
browser
load
"
)
;
return
deferred
.
promise
;
}
function
getNodeFront
(
selector
{
walker
}
)
{
if
(
selector
.
_form
)
{
return
selector
;
}
return
walker
.
querySelector
(
walker
.
rootNode
selector
)
;
}
var
selectNode
=
Task
.
async
(
function
*
(
selector
inspector
reason
=
"
test
"
)
{
info
(
"
Selecting
the
node
for
'
"
+
selector
+
"
'
"
)
;
let
nodeFront
=
yield
getNodeFront
(
selector
inspector
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
nodeFront
reason
)
;
yield
updated
;
}
)
;
function
waitForResizeTo
(
manager
width
height
)
{
return
new
Promise
(
resolve
=
>
{
let
onResize
=
(
_
data
)
=
>
{
if
(
data
.
width
!
=
width
|
|
data
.
height
!
=
height
)
{
return
;
}
manager
.
off
(
"
contentResize
"
onResize
)
;
info
(
Got
contentResize
to
{
width
}
x
{
height
}
)
;
resolve
(
)
;
}
;
info
(
Waiting
for
contentResize
to
{
width
}
x
{
height
}
)
;
manager
.
on
(
"
contentResize
"
onResize
)
;
}
)
;
}
var
setPresetIndex
=
Task
.
async
(
function
*
(
rdm
manager
index
)
{
info
(
Current
preset
:
{
rdm
.
menulist
.
selectedIndex
}
change
to
:
{
index
}
)
;
if
(
rdm
.
menulist
.
selectedIndex
!
=
index
)
{
let
resized
=
once
(
manager
"
contentResize
"
)
;
rdm
.
menulist
.
selectedIndex
=
index
;
yield
resized
;
}
}
)
;
var
setSize
=
Task
.
async
(
function
*
(
rdm
manager
width
height
)
{
let
size
=
rdm
.
getSize
(
)
;
info
(
Current
size
:
{
size
.
width
}
x
{
size
.
height
}
+
set
to
:
{
width
}
x
{
height
}
)
;
if
(
size
.
width
!
=
width
|
|
size
.
height
!
=
height
)
{
let
resized
=
waitForResizeTo
(
manager
width
height
)
;
rdm
.
setSize
(
width
height
)
;
yield
resized
;
}
}
)
;
