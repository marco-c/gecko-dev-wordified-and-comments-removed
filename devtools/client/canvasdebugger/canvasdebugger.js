"
use
strict
"
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
SideMenuWidget
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
SideMenuWidget
.
jsm
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
CanvasFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
canvas
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
const
{
WidgetMethods
setNamedTimeout
clearNamedTimeout
setConditionalTimeout
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
Promise
=
require
(
"
Promise
"
)
;
const
CANVAS_ACTOR_RECORDING_ATTEMPT
=
flags
.
testing
?
500
:
5000
;
ChromeUtils
.
defineModuleGetter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
NetworkHelper
"
function
(
)
{
return
require
(
"
devtools
/
shared
/
webconsole
/
network
-
helper
"
)
;
}
)
;
const
EVENTS
=
{
UI_RESET
:
"
CanvasDebugger
:
UIReset
"
SNAPSHOTS_LIST_CLEARED
:
"
CanvasDebugger
:
SnapshotsListCleared
"
SNAPSHOT_RECORDING_STARTED
:
"
CanvasDebugger
:
SnapshotRecordingStarted
"
SNAPSHOT_RECORDING_FINISHED
:
"
CanvasDebugger
:
SnapshotRecordingFinished
"
SNAPSHOT_RECORDING_COMPLETED
:
"
CanvasDebugger
:
SnapshotRecordingCompleted
"
SNAPSHOT_RECORDING_CANCELLED
:
"
CanvasDebugger
:
SnapshotRecordingCancelled
"
SNAPSHOT_RECORDING_SELECTED
:
"
CanvasDebugger
:
SnapshotRecordingSelected
"
CALL_LIST_POPULATED
:
"
CanvasDebugger
:
CallListPopulated
"
CALL_STACK_DISPLAYED
:
"
CanvasDebugger
:
CallStackDisplayed
"
CALL_SCREENSHOT_DISPLAYED
:
"
CanvasDebugger
:
ScreenshotDisplayed
"
THUMBNAILS_DISPLAYED
:
"
CanvasDebugger
:
ThumbnailsDisplayed
"
SOURCE_SHOWN_IN_JS_DEBUGGER
:
"
CanvasDebugger
:
SourceShownInJsDebugger
"
SOURCE_NOT_FOUND_IN_JS_DEBUGGER
:
"
CanvasDebugger
:
SourceNotFoundInJsDebugger
"
}
;
XPCOMUtils
.
defineConstant
(
this
"
EVENTS
"
EVENTS
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
STRINGS_URI
=
"
devtools
/
client
/
locales
/
canvasdebugger
.
properties
"
;
const
SHARED_STRINGS_URI
=
"
devtools
/
client
/
locales
/
shared
.
properties
"
;
const
SNAPSHOT_START_RECORDING_DELAY
=
10
;
const
SNAPSHOT_DATA_EXPORT_MAX_BLOCK
=
1000
;
const
SNAPSHOT_DATA_DISPLAY_DELAY
=
10
;
const
SCREENSHOT_DISPLAY_DELAY
=
100
;
const
STACK_FUNC_INDENTATION
=
14
;
const
CALLS_LIST_SERIALIZER_IDENTIFIER
=
"
Recorded
Animation
Frame
Snapshot
"
;
const
CALLS_LIST_SERIALIZER_VERSION
=
1
;
const
CALLS_LIST_SLOW_SAVE_DELAY
=
100
;
var
gToolbox
gTarget
gFront
;
function
startupCanvasDebugger
(
)
{
return
Promise
.
all
(
[
EventsHandler
.
initialize
(
)
SnapshotsListView
.
initialize
(
)
CallsListView
.
initialize
(
)
]
)
;
}
function
shutdownCanvasDebugger
(
)
{
return
Promise
.
all
(
[
EventsHandler
.
destroy
(
)
SnapshotsListView
.
destroy
(
)
CallsListView
.
destroy
(
)
]
)
;
}
var
EventsHandler
=
{
initialize
:
function
(
)
{
gFront
.
setup
(
{
reload
:
false
}
)
;
this
.
_onTabWillNavigate
=
this
.
_onTabWillNavigate
.
bind
(
this
)
;
gTarget
.
on
(
"
will
-
navigate
"
this
.
_onTabWillNavigate
)
;
}
destroy
:
function
(
)
{
gTarget
.
off
(
"
will
-
navigate
"
this
.
_onTabWillNavigate
)
;
}
_onTabWillNavigate
:
function
(
)
{
SnapshotsListView
.
empty
(
)
;
CallsListView
.
empty
(
)
;
(
"
#
record
-
snapshot
"
)
.
removeAttribute
(
"
checked
"
)
;
(
"
#
record
-
snapshot
"
)
.
removeAttribute
(
"
disabled
"
)
;
(
"
#
record
-
snapshot
"
)
.
hidden
=
false
;
(
"
#
reload
-
notice
"
)
.
hidden
=
true
;
(
"
#
empty
-
notice
"
)
.
hidden
=
false
;
(
"
#
waiting
-
notice
"
)
.
hidden
=
true
;
(
"
#
debugging
-
pane
-
contents
"
)
.
hidden
=
true
;
(
"
#
screenshot
-
container
"
)
.
hidden
=
true
;
(
"
#
snapshot
-
filmstrip
"
)
.
hidden
=
true
;
window
.
emit
(
EVENTS
.
UI_RESET
)
;
}
}
;
var
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
var
SHARED_L10N
=
new
LocalizationHelper
(
SHARED_STRINGS_URI
)
;
EventEmitter
.
decorate
(
this
)
;
var
=
(
selector
target
=
document
)
=
>
target
.
querySelector
(
selector
)
;
var
all
=
(
selector
target
=
document
)
=
>
target
.
querySelectorAll
(
selector
)
;
function
getFileName
(
url
)
{
try
{
const
{
fileName
}
=
NetworkHelper
.
nsIURL
(
url
)
;
return
fileName
|
|
"
/
"
;
}
catch
(
e
)
{
return
"
"
;
}
}
function
getImageDataStorage
(
ctx
w
h
)
{
const
storage
=
getImageDataStorage
.
cache
;
if
(
storage
&
&
storage
.
width
=
=
w
&
&
storage
.
height
=
=
h
)
{
return
storage
;
}
return
getImageDataStorage
.
cache
=
ctx
.
createImageData
(
w
h
)
;
}
getImageDataStorage
.
cache
=
null
;
function
drawImage
(
canvas
width
height
pixels
options
=
{
}
)
{
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
if
(
pixels
.
length
<
=
1
)
{
ctx
.
clearRect
(
0
0
canvas
.
width
canvas
.
height
)
;
return
;
}
const
imageData
=
getImageDataStorage
(
ctx
width
height
)
;
imageData
.
data
.
set
(
pixels
)
;
if
(
options
.
centered
)
{
const
left
=
(
canvas
.
width
-
width
)
/
2
;
const
top
=
(
canvas
.
height
-
height
)
/
2
;
ctx
.
putImageData
(
imageData
left
top
)
;
}
else
{
ctx
.
putImageData
(
imageData
0
0
)
;
}
}
function
drawBackground
(
id
width
height
pixels
)
{
const
canvas
=
document
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
canvas
.
width
=
width
;
canvas
.
height
=
height
;
drawImage
(
canvas
width
height
pixels
)
;
document
.
mozSetImageElement
(
id
canvas
)
;
if
(
window
.
_onMozSetImageElement
)
{
window
.
_onMozSetImageElement
(
pixels
)
;
}
}
function
getNextDrawCall
(
calls
call
)
{
for
(
let
i
=
calls
.
indexOf
(
call
)
+
1
len
=
calls
.
length
;
i
<
len
;
i
+
+
)
{
const
nextCall
=
calls
[
i
]
;
const
name
=
nextCall
.
attachment
.
actor
.
name
;
if
(
CanvasFront
.
DRAW_CALLS
.
has
(
name
)
)
{
return
nextCall
;
}
}
return
null
;
}
function
getScreenshotFromCallLoadedFromDisk
(
calls
call
)
{
for
(
let
i
=
calls
.
indexOf
(
call
)
;
i
>
=
0
;
i
-
-
)
{
const
prevCall
=
calls
[
i
]
;
const
screenshot
=
prevCall
.
screenshot
;
if
(
screenshot
)
{
return
screenshot
;
}
}
return
CanvasFront
.
INVALID_SNAPSHOT_IMAGE
;
}
function
getThumbnailForCall
(
thumbnails
index
)
{
for
(
let
i
=
thumbnails
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
thumbnail
=
thumbnails
[
i
]
;
if
(
thumbnail
.
index
<
=
index
)
{
return
thumbnail
;
}
}
return
CanvasFront
.
INVALID_SNAPSHOT_IMAGE
;
}
