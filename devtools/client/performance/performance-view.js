"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
RecordingControls
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
RecordingControls
"
)
)
;
const
RecordingButton
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
RecordingButton
"
)
)
;
const
EVENTS
=
require
(
"
.
/
events
"
)
;
const
PerformanceUtils
=
require
(
"
.
/
modules
/
utils
"
)
;
const
{
DetailsView
}
=
require
(
"
.
/
views
/
details
"
)
;
const
{
OverviewView
}
=
require
(
"
.
/
views
/
overview
"
)
;
const
{
RecordingsView
}
=
require
(
"
.
/
views
/
recordings
"
)
;
const
{
ToolbarView
}
=
require
(
"
.
/
views
/
toolbar
"
)
;
const
{
L10N
}
=
require
(
"
.
/
modules
/
global
"
)
;
var
PerformanceView
=
{
_state
:
null
_bufferStatusSupported
:
false
states
:
{
unavailable
:
[
{
sel
:
"
#
performance
-
view
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
unavailable
-
notice
"
)
}
{
sel
:
"
#
performance
-
view
-
content
"
opt
:
"
hidden
"
val
:
(
)
=
>
true
}
]
empty
:
[
{
sel
:
"
#
performance
-
view
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
empty
-
notice
"
)
}
{
sel
:
"
#
performance
-
view
-
content
"
opt
:
"
hidden
"
val
:
(
)
=
>
true
}
]
recording
:
[
{
sel
:
"
#
performance
-
view
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
performance
-
view
-
content
"
)
}
{
sel
:
"
#
performance
-
view
-
content
"
opt
:
"
hidden
"
val
:
(
)
=
>
false
}
{
sel
:
"
#
details
-
pane
-
container
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
recording
-
notice
"
)
}
]
"
console
-
recording
"
:
[
{
sel
:
"
#
performance
-
view
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
performance
-
view
-
content
"
)
}
{
sel
:
"
#
performance
-
view
-
content
"
opt
:
"
hidden
"
val
:
(
)
=
>
false
}
{
sel
:
"
#
details
-
pane
-
container
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
console
-
recording
-
notice
"
)
}
]
recorded
:
[
{
sel
:
"
#
performance
-
view
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
performance
-
view
-
content
"
)
}
{
sel
:
"
#
performance
-
view
-
content
"
opt
:
"
hidden
"
val
:
(
)
=
>
false
}
{
sel
:
"
#
details
-
pane
-
container
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
details
-
pane
"
)
}
]
loading
:
[
{
sel
:
"
#
performance
-
view
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
performance
-
view
-
content
"
)
}
{
sel
:
"
#
performance
-
view
-
content
"
opt
:
"
hidden
"
val
:
(
)
=
>
false
}
{
sel
:
"
#
details
-
pane
-
container
"
opt
:
"
selectedPanel
"
val
:
(
)
=
>
(
"
#
loading
-
notice
"
)
}
]
}
async
initialize
(
)
{
this
.
_onRecordButtonClick
=
this
.
_onRecordButtonClick
.
bind
(
this
)
;
this
.
_onImportButtonClick
=
this
.
_onImportButtonClick
.
bind
(
this
)
;
this
.
_onClearButtonClick
=
this
.
_onClearButtonClick
.
bind
(
this
)
;
this
.
_onRecordingSelected
=
this
.
_onRecordingSelected
.
bind
(
this
)
;
this
.
_onProfilerStatusUpdated
=
this
.
_onProfilerStatusUpdated
.
bind
(
this
)
;
this
.
_onRecordingStateChange
=
this
.
_onRecordingStateChange
.
bind
(
this
)
;
this
.
_onNewRecordingFailed
=
this
.
_onNewRecordingFailed
.
bind
(
this
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingSelected
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_PROFILER_STATUS_UPDATE
this
.
_onProfilerStatusUpdated
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_ADDED
this
.
_onRecordingStateChange
)
;
PerformanceController
.
on
(
EVENTS
.
BACKEND_FAILED_AFTER_RECORDING_START
this
.
_onNewRecordingFailed
)
;
if
(
await
PerformanceController
.
canCurrentlyRecord
(
)
)
{
this
.
setState
(
"
empty
"
)
;
}
else
{
this
.
setState
(
"
unavailable
"
)
;
}
await
ToolbarView
.
initialize
(
)
;
await
RecordingsView
.
initialize
(
)
;
await
OverviewView
.
initialize
(
)
;
await
DetailsView
.
initialize
(
)
;
this
.
_recordingControlsState
=
{
onRecordButtonClick
:
this
.
_onRecordButtonClick
onImportButtonClick
:
this
.
_onImportButtonClick
onClearButtonClick
:
this
.
_onClearButtonClick
isRecording
:
false
isDisabled
:
false
}
;
const
{
createHtmlMount
}
=
PerformanceUtils
;
this
.
_recordingControlsMount
=
createHtmlMount
(
(
"
#
recording
-
controls
-
mount
"
)
)
;
this
.
_recordingButtonsMounts
=
Array
.
from
(
(
"
.
recording
-
button
-
mount
"
)
)
.
map
(
createHtmlMount
)
;
this
.
_renderRecordingControls
(
)
;
}
_renderRecordingControls
:
function
(
)
{
ReactDOM
.
render
(
RecordingControls
(
this
.
_recordingControlsState
)
this
.
_recordingControlsMount
)
;
for
(
const
button
of
this
.
_recordingButtonsMounts
)
{
ReactDOM
.
render
(
RecordingButton
(
this
.
_recordingControlsState
)
button
)
;
}
}
async
destroy
(
)
{
PerformanceController
.
off
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingSelected
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_PROFILER_STATUS_UPDATE
this
.
_onProfilerStatusUpdated
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_ADDED
this
.
_onRecordingStateChange
)
;
PerformanceController
.
off
(
EVENTS
.
BACKEND_FAILED_AFTER_RECORDING_START
this
.
_onNewRecordingFailed
)
;
await
ToolbarView
.
destroy
(
)
;
await
RecordingsView
.
destroy
(
)
;
await
OverviewView
.
destroy
(
)
;
await
DetailsView
.
destroy
(
)
;
}
setState
:
function
(
state
)
{
const
iframes
=
window
.
document
.
querySelectorAll
(
"
iframe
"
)
;
for
(
const
iframe
of
iframes
)
{
iframe
.
blur
(
)
;
}
window
.
focus
(
)
;
const
viewConfig
=
this
.
states
[
state
]
;
if
(
!
viewConfig
)
{
throw
new
Error
(
Invalid
state
for
PerformanceView
:
{
state
}
)
;
}
for
(
const
{
sel
opt
val
}
of
viewConfig
)
{
for
(
const
el
of
(
sel
)
)
{
el
[
opt
]
=
val
(
)
;
}
}
this
.
_state
=
state
;
if
(
state
=
=
=
"
console
-
recording
"
)
{
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
let
label
=
recording
.
getLabel
(
)
|
|
"
"
;
label
=
label
?
"
{
label
}
"
:
"
"
;
const
startCommand
=
(
"
.
console
-
profile
-
recording
-
notice
.
console
-
profile
-
command
"
)
;
const
stopCommand
=
(
"
.
console
-
profile
-
stop
-
notice
.
console
-
profile
-
command
"
)
;
startCommand
.
value
=
console
.
profile
(
{
label
}
)
;
stopCommand
.
value
=
console
.
profileEnd
(
{
label
}
)
;
}
this
.
updateBufferStatus
(
)
;
this
.
emit
(
EVENTS
.
UI_STATE_CHANGED
state
)
;
}
getState
:
function
(
)
{
return
this
.
_state
;
}
updateBufferStatus
:
function
(
)
{
if
(
!
this
.
_bufferStatusSupported
)
{
return
;
}
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
!
recording
|
|
!
recording
.
isRecording
(
)
)
{
return
;
}
const
bufferUsage
=
PerformanceController
.
getBufferUsageForRecording
(
recording
)
|
|
0
;
const
percent
=
Math
.
floor
(
bufferUsage
*
100
)
;
const
container
=
(
"
#
details
-
pane
-
container
"
)
;
const
bufferLabel
=
(
"
.
buffer
-
status
-
message
"
container
.
selectedPanel
)
;
if
(
percent
>
=
99
)
{
container
.
setAttribute
(
"
buffer
-
status
"
"
full
"
)
;
}
else
{
container
.
setAttribute
(
"
buffer
-
status
"
"
in
-
progress
"
)
;
}
bufferLabel
.
value
=
L10N
.
getFormatStr
(
"
profiler
.
bufferFull
"
percent
)
;
this
.
emit
(
EVENTS
.
UI_RECORDING_PROFILER_STATUS_RENDERED
percent
)
;
}
_lockRecordButtons
:
function
(
lock
)
{
this
.
_recordingControlsState
.
isLocked
=
lock
;
this
.
_renderRecordingControls
(
)
;
}
_toggleRecordButtons
:
function
(
activate
)
{
this
.
_recordingControlsState
.
isRecording
=
activate
;
this
.
_renderRecordingControls
(
)
;
}
_onRecordingStateChange
:
function
(
)
{
const
currentRecording
=
PerformanceController
.
getCurrentRecording
(
)
;
const
recordings
=
PerformanceController
.
getRecordings
(
)
;
this
.
_toggleRecordButtons
(
!
!
recordings
.
find
(
r
=
>
!
r
.
isConsole
(
)
&
&
r
.
isRecording
(
)
)
)
;
this
.
_lockRecordButtons
(
!
!
recordings
.
find
(
r
=
>
!
r
.
isConsole
(
)
&
&
r
.
isFinalizing
(
)
)
)
;
if
(
currentRecording
&
&
currentRecording
.
isFinalizing
(
)
)
{
this
.
setState
(
"
loading
"
)
;
}
if
(
currentRecording
&
&
currentRecording
.
isCompleted
(
)
)
{
this
.
setState
(
"
recorded
"
)
;
}
if
(
currentRecording
&
&
currentRecording
.
isRecording
(
)
)
{
this
.
updateBufferStatus
(
)
;
}
}
_onNewRecordingFailed
:
function
(
)
{
this
.
_lockRecordButtons
(
false
)
;
this
.
_toggleRecordButtons
(
false
)
;
}
_onClearButtonClick
:
function
(
e
)
{
this
.
emit
(
EVENTS
.
UI_CLEAR_RECORDINGS
)
;
}
_onRecordButtonClick
:
function
(
e
)
{
if
(
this
.
_recordingControlsState
.
isRecording
)
{
this
.
emit
(
EVENTS
.
UI_STOP_RECORDING
)
;
}
else
{
this
.
_lockRecordButtons
(
true
)
;
this
.
_toggleRecordButtons
(
true
)
;
this
.
emit
(
EVENTS
.
UI_START_RECORDING
)
;
}
}
_onImportButtonClick
:
function
(
e
)
{
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
L10N
.
getStr
(
"
recordingsList
.
importDialogTitle
"
)
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilter
(
L10N
.
getStr
(
"
recordingsList
.
saveDialogJSONFilter
"
)
"
*
.
json
"
)
;
fp
.
appendFilter
(
L10N
.
getStr
(
"
recordingsList
.
saveDialogAllFilter
"
)
"
*
.
*
"
)
;
fp
.
open
(
rv
=
>
{
if
(
rv
=
=
Ci
.
nsIFilePicker
.
returnOK
)
{
this
.
emit
(
EVENTS
.
UI_IMPORT_RECORDING
fp
.
file
)
;
}
}
)
;
}
_onRecordingSelected
:
function
(
recording
)
{
if
(
!
recording
)
{
this
.
setState
(
"
empty
"
)
;
}
else
if
(
recording
.
isRecording
(
)
&
&
recording
.
isConsole
(
)
)
{
this
.
setState
(
"
console
-
recording
"
)
;
}
else
if
(
recording
.
isRecording
(
)
)
{
this
.
setState
(
"
recording
"
)
;
}
else
{
this
.
setState
(
"
recorded
"
)
;
}
}
_onProfilerStatusUpdated
:
function
(
profilerStatus
)
{
if
(
!
profilerStatus
|
|
profilerStatus
.
position
=
=
=
void
0
)
{
return
;
}
if
(
!
this
.
_bufferStatusSupported
)
{
this
.
_bufferStatusSupported
=
true
;
(
"
#
details
-
pane
-
container
"
)
.
setAttribute
(
"
buffer
-
status
"
"
in
-
progress
"
)
;
}
if
(
!
this
.
getState
(
"
recording
"
)
&
&
!
this
.
getState
(
"
console
-
recording
"
)
)
{
return
;
}
this
.
updateBufferStatus
(
)
;
}
toString
:
(
)
=
>
"
[
object
PerformanceView
]
"
}
;
EventEmitter
.
decorate
(
PerformanceView
)
;
exports
.
PerformanceView
=
PerformanceView
;
