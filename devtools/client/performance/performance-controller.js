"
use
strict
"
;
var
BrowserLoaderModule
=
{
}
;
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
BrowserLoaderModule
)
;
var
{
loader
require
}
=
BrowserLoaderModule
.
BrowserLoader
(
{
baseURI
:
"
resource
:
/
/
devtools
/
client
/
performance
/
"
window
}
)
;
var
{
ViewHelpers
WidgetMethods
setNamedTimeout
clearNamedTimeout
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
var
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
var
Promise
=
require
(
"
Promise
"
)
;
var
EVENTS
=
require
(
"
devtools
/
client
/
performance
/
events
"
)
;
Object
.
defineProperty
(
this
"
EVENTS
"
{
value
:
EVENTS
enumerable
:
true
writable
:
false
}
)
;
var
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
var
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
var
Waterfall
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
Waterfall
"
)
)
;
var
JITOptimizationsView
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
JITOptimizations
"
)
)
;
var
RecordingControls
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
RecordingControls
"
)
)
;
var
RecordingButton
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
RecordingButton
"
)
)
;
var
RecordingList
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
RecordingList
"
)
)
;
var
RecordingListItem
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
performance
/
components
/
RecordingListItem
"
)
)
;
var
Services
=
require
(
"
Services
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
var
system
=
require
(
"
devtools
/
shared
/
system
"
)
;
var
{
L10N
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
global
"
)
;
var
{
PerformanceTelemetry
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
telemetry
"
)
;
var
{
TIMELINE_BLUEPRINT
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
markers
"
)
;
var
RecordingUtils
=
require
(
"
devtools
/
shared
/
performance
/
recording
-
utils
"
)
;
var
PerformanceUtils
=
require
(
"
devtools
/
client
/
performance
/
modules
/
utils
"
)
;
var
{
OptimizationsGraph
GraphsController
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
widgets
/
graphs
"
)
;
var
{
MarkerDetails
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
widgets
/
marker
-
details
"
)
;
var
{
MarkerBlueprintUtils
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
marker
-
blueprint
-
utils
"
)
;
var
WaterfallUtils
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
waterfall
-
utils
"
)
;
var
FrameUtils
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
frame
-
utils
"
)
;
var
{
CallView
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
widgets
/
tree
-
view
"
)
;
var
{
ThreadNode
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
tree
-
model
"
)
;
var
{
FrameNode
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
tree
-
model
"
)
;
var
{
OptionsView
}
=
require
(
"
devtools
/
client
/
shared
/
options
-
view
"
)
;
var
{
FlameGraph
FlameGraphUtils
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
FlameGraph
"
)
;
var
{
TreeWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
TreeWidget
"
)
;
var
{
SideMenuWidget
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
SideMenuWidget
.
jsm
"
)
;
var
BRANCH_NAME
=
"
devtools
.
performance
.
ui
.
"
;
var
gToolbox
gTarget
gFront
;
var
startupPerformance
=
async
function
(
)
{
await
PerformanceController
.
initialize
(
)
;
await
PerformanceView
.
initialize
(
)
;
PerformanceController
.
enableFrontEventListeners
(
)
;
}
;
var
shutdownPerformance
=
async
function
(
)
{
await
PerformanceController
.
destroy
(
)
;
await
PerformanceView
.
destroy
(
)
;
PerformanceController
.
disableFrontEventListeners
(
)
;
}
;
var
PerformanceController
=
{
_recordings
:
[
]
_currentRecording
:
null
async
initialize
(
)
{
this
.
_telemetry
=
new
PerformanceTelemetry
(
this
)
;
this
.
startRecording
=
this
.
startRecording
.
bind
(
this
)
;
this
.
stopRecording
=
this
.
stopRecording
.
bind
(
this
)
;
this
.
importRecording
=
this
.
importRecording
.
bind
(
this
)
;
this
.
exportRecording
=
this
.
exportRecording
.
bind
(
this
)
;
this
.
clearRecordings
=
this
.
clearRecordings
.
bind
(
this
)
;
this
.
_onRecordingSelectFromView
=
this
.
_onRecordingSelectFromView
.
bind
(
this
)
;
this
.
_onPrefChanged
=
this
.
_onPrefChanged
.
bind
(
this
)
;
this
.
_onThemeChanged
=
this
.
_onThemeChanged
.
bind
(
this
)
;
this
.
_onDetailsViewSelected
=
this
.
_onDetailsViewSelected
.
bind
(
this
)
;
this
.
_onProfilerStatus
=
this
.
_onProfilerStatus
.
bind
(
this
)
;
this
.
_onRecordingStarted
=
this
.
_emitRecordingStateChange
.
bind
(
this
"
recording
-
started
"
)
;
this
.
_onRecordingStopping
=
this
.
_emitRecordingStateChange
.
bind
(
this
"
recording
-
stopping
"
)
;
this
.
_onRecordingStopped
=
this
.
_emitRecordingStateChange
.
bind
(
this
"
recording
-
stopped
"
)
;
this
.
_e10s
=
Services
.
appinfo
.
browserTabsRemoteAutostart
;
this
.
_setMultiprocessAttributes
(
)
;
this
.
_prefs
=
require
(
"
devtools
/
client
/
performance
/
modules
/
global
"
)
.
PREFS
;
this
.
_prefs
.
registerObserver
(
)
;
this
.
_prefs
.
on
(
"
pref
-
changed
"
this
.
_onPrefChanged
)
;
ToolbarView
.
on
(
EVENTS
.
UI_PREF_CHANGED
this
.
_onPrefChanged
)
;
PerformanceView
.
on
(
EVENTS
.
UI_START_RECORDING
this
.
startRecording
)
;
PerformanceView
.
on
(
EVENTS
.
UI_STOP_RECORDING
this
.
stopRecording
)
;
PerformanceView
.
on
(
EVENTS
.
UI_IMPORT_RECORDING
this
.
importRecording
)
;
PerformanceView
.
on
(
EVENTS
.
UI_CLEAR_RECORDINGS
this
.
clearRecordings
)
;
RecordingsView
.
on
(
EVENTS
.
UI_EXPORT_RECORDING
this
.
exportRecording
)
;
RecordingsView
.
on
(
EVENTS
.
UI_RECORDING_SELECTED
this
.
_onRecordingSelectFromView
)
;
DetailsView
.
on
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
this
.
_onDetailsViewSelected
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
_prefObserver
.
on
(
"
devtools
.
theme
"
this
.
_onThemeChanged
)
;
}
destroy
:
function
(
)
{
this
.
_prefs
.
off
(
"
pref
-
changed
"
this
.
_onPrefChanged
)
;
this
.
_prefs
.
unregisterObserver
(
)
;
ToolbarView
.
off
(
EVENTS
.
UI_PREF_CHANGED
this
.
_onPrefChanged
)
;
PerformanceView
.
off
(
EVENTS
.
UI_START_RECORDING
this
.
startRecording
)
;
PerformanceView
.
off
(
EVENTS
.
UI_STOP_RECORDING
this
.
stopRecording
)
;
PerformanceView
.
off
(
EVENTS
.
UI_IMPORT_RECORDING
this
.
importRecording
)
;
PerformanceView
.
off
(
EVENTS
.
UI_CLEAR_RECORDINGS
this
.
clearRecordings
)
;
RecordingsView
.
off
(
EVENTS
.
UI_EXPORT_RECORDING
this
.
exportRecording
)
;
RecordingsView
.
off
(
EVENTS
.
UI_RECORDING_SELECTED
this
.
_onRecordingSelectFromView
)
;
DetailsView
.
off
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
this
.
_onDetailsViewSelected
)
;
this
.
_prefObserver
.
off
(
"
devtools
.
theme
"
this
.
_onThemeChanged
)
;
this
.
_prefObserver
.
destroy
(
)
;
this
.
_telemetry
.
destroy
(
)
;
}
enableFrontEventListeners
:
function
(
)
{
gFront
.
on
(
"
profiler
-
status
"
this
.
_onProfilerStatus
)
;
gFront
.
on
(
"
recording
-
started
"
this
.
_onRecordingStarted
)
;
gFront
.
on
(
"
recording
-
stopping
"
this
.
_onRecordingStopping
)
;
gFront
.
on
(
"
recording
-
stopped
"
this
.
_onRecordingStopped
)
;
}
disableFrontEventListeners
:
function
(
)
{
gFront
.
off
(
"
profiler
-
status
"
this
.
_onProfilerStatus
)
;
gFront
.
off
(
"
recording
-
started
"
this
.
_onRecordingStarted
)
;
gFront
.
off
(
"
recording
-
stopping
"
this
.
_onRecordingStopping
)
;
gFront
.
off
(
"
recording
-
stopped
"
this
.
_onRecordingStopped
)
;
}
getTheme
:
function
(
)
{
return
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
}
getOption
:
function
(
prefName
)
{
return
ToolbarView
.
optionsView
.
getPref
(
prefName
)
;
}
getPref
:
function
(
prefName
)
{
return
this
.
_prefs
[
prefName
]
;
}
setPref
:
function
(
prefName
prefValue
)
{
this
.
_prefs
[
prefName
]
=
prefValue
;
}
async
canCurrentlyRecord
(
)
{
const
hasActor
=
await
gTarget
.
hasActor
(
"
performance
"
)
;
if
(
!
hasActor
)
{
return
true
;
}
const
actorCanCheck
=
await
gTarget
.
actorHasMethod
(
"
performance
"
"
canCurrentlyRecord
"
)
;
if
(
!
actorCanCheck
)
{
return
true
;
}
return
(
await
gFront
.
canCurrentlyRecord
(
)
)
.
success
;
}
async
startRecording
(
)
{
const
options
=
{
withMarkers
:
true
withTicks
:
this
.
getOption
(
"
enable
-
framerate
"
)
withMemory
:
this
.
getOption
(
"
enable
-
memory
"
)
withFrames
:
true
withGCEvents
:
true
withAllocations
:
this
.
getOption
(
"
enable
-
allocations
"
)
allocationsSampleProbability
:
this
.
getPref
(
"
memory
-
sample
-
probability
"
)
allocationsMaxLogLength
:
this
.
getPref
(
"
memory
-
max
-
log
-
length
"
)
bufferSize
:
this
.
getPref
(
"
profiler
-
buffer
-
size
"
)
sampleFrequency
:
this
.
getPref
(
"
profiler
-
sample
-
frequency
"
)
}
;
const
recordingStarted
=
await
gFront
.
startRecording
(
options
)
;
if
(
!
recordingStarted
)
{
this
.
emit
(
EVENTS
.
BACKEND_FAILED_AFTER_RECORDING_START
)
;
PerformanceView
.
setState
(
"
unavailable
"
)
;
}
else
{
this
.
emit
(
EVENTS
.
BACKEND_READY_AFTER_RECORDING_START
)
;
}
}
async
stopRecording
(
)
{
const
recording
=
this
.
getLatestManualRecording
(
)
;
await
gFront
.
stopRecording
(
recording
)
;
this
.
emit
(
EVENTS
.
BACKEND_READY_AFTER_RECORDING_STOP
)
;
}
async
exportRecording
(
recording
file
)
{
await
recording
.
exportRecording
(
file
)
;
this
.
emit
(
EVENTS
.
RECORDING_EXPORTED
recording
file
)
;
}
async
clearRecordings
(
)
{
for
(
let
i
=
this
.
_recordings
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
model
=
this
.
_recordings
[
i
]
;
if
(
!
model
.
isConsole
(
)
&
&
model
.
isRecording
(
)
)
{
await
this
.
stopRecording
(
)
;
}
if
(
!
model
.
isRecording
(
)
&
&
!
model
.
isCompleted
(
)
)
{
await
this
.
waitForStateChangeOnRecording
(
model
"
recording
-
stopped
"
)
;
}
if
(
model
.
isCompleted
(
)
)
{
this
.
emit
(
EVENTS
.
RECORDING_DELETED
model
)
;
this
.
_recordings
.
splice
(
i
1
)
;
}
}
if
(
this
.
_recordings
.
length
>
0
)
{
if
(
!
this
.
_recordings
.
includes
(
this
.
getCurrentRecording
(
)
)
)
{
this
.
setCurrentRecording
(
this
.
_recordings
[
0
]
)
;
}
}
else
{
this
.
setCurrentRecording
(
null
)
;
}
}
async
importRecording
(
file
)
{
const
recording
=
await
gFront
.
importRecording
(
file
)
;
this
.
_addRecordingIfUnknown
(
recording
)
;
this
.
emit
(
EVENTS
.
RECORDING_IMPORTED
recording
)
;
}
setCurrentRecording
:
function
(
recording
)
{
if
(
this
.
_currentRecording
!
=
=
recording
)
{
this
.
_currentRecording
=
recording
;
this
.
emit
(
EVENTS
.
RECORDING_SELECTED
recording
)
;
}
}
getCurrentRecording
:
function
(
)
{
return
this
.
_currentRecording
;
}
getLatestManualRecording
:
function
(
)
{
for
(
let
i
=
this
.
_recordings
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
model
=
this
.
_recordings
[
i
]
;
if
(
!
model
.
isConsole
(
)
&
&
!
model
.
isImported
(
)
)
{
return
this
.
_recordings
[
i
]
;
}
}
return
null
;
}
_onRecordingSelectFromView
:
function
(
recording
)
{
this
.
setCurrentRecording
(
recording
)
;
}
_onPrefChanged
:
function
(
prefName
prefValue
)
{
this
.
emit
(
EVENTS
.
PREF_CHANGED
prefName
prefValue
)
;
}
_onThemeChanged
:
function
(
)
{
const
newValue
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
this
.
emit
(
EVENTS
.
THEME_CHANGED
newValue
)
;
}
_onProfilerStatus
:
function
(
status
)
{
this
.
emit
(
EVENTS
.
RECORDING_PROFILER_STATUS_UPDATE
status
)
;
}
_emitRecordingStateChange
(
eventName
recordingModel
)
{
this
.
_addRecordingIfUnknown
(
recordingModel
)
;
this
.
emit
(
EVENTS
.
RECORDING_STATE_CHANGE
eventName
recordingModel
)
;
}
_addRecordingIfUnknown
:
function
(
recording
)
{
if
(
!
this
.
_recordings
.
includes
(
recording
)
)
{
this
.
_recordings
.
push
(
recording
)
;
this
.
emit
(
EVENTS
.
RECORDING_ADDED
recording
)
;
}
}
getBufferUsageForRecording
:
function
(
recording
)
{
return
gFront
.
getBufferUsageForRecording
(
recording
)
;
}
isRecording
:
function
(
)
{
return
this
.
_recordings
.
some
(
r
=
>
r
.
isRecording
(
)
)
;
}
getRecordings
:
function
(
)
{
return
this
.
_recordings
;
}
getTraits
:
function
(
)
{
return
gFront
.
traits
;
}
isFeatureSupported
:
function
(
features
)
{
if
(
!
features
)
{
return
true
;
}
const
recording
=
this
.
getCurrentRecording
(
)
;
if
(
!
recording
)
{
return
false
;
}
const
config
=
recording
.
getConfiguration
(
)
;
return
[
]
.
concat
(
features
)
.
every
(
f
=
>
config
[
f
]
)
;
}
populateWithRecordings
:
function
(
recordings
=
[
]
)
{
for
(
const
recording
of
recordings
)
{
PerformanceController
.
_addRecordingIfUnknown
(
recording
)
;
}
this
.
emit
(
EVENTS
.
RECORDINGS_SEEDED
)
;
}
getMultiprocessStatus
:
function
(
)
{
if
(
flags
.
testing
)
{
return
{
enabled
:
true
}
;
}
const
enabled
=
this
.
_e10s
;
return
{
enabled
}
;
}
async
waitForStateChangeOnRecording
(
recording
expectedState
)
{
await
new
Promise
(
resolve
=
>
{
this
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
function
handler
(
state
model
)
{
if
(
state
=
=
=
expectedState
&
&
model
=
=
=
recording
)
{
this
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
handler
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
_setMultiprocessAttributes
:
function
(
)
{
const
{
enabled
}
=
this
.
getMultiprocessStatus
(
)
;
if
(
!
enabled
)
{
(
"
#
performance
-
view
"
)
.
setAttribute
(
"
e10s
"
"
disabled
"
)
;
}
}
_onDetailsViewSelected
:
function
(
.
.
.
data
)
{
this
.
emit
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
.
.
.
data
)
;
}
toString
:
(
)
=
>
"
[
object
PerformanceController
]
"
}
;
EventEmitter
.
decorate
(
PerformanceController
)
;
function
(
selector
target
=
document
)
{
return
target
.
querySelector
(
selector
)
;
}
function
(
selector
target
=
document
)
{
return
target
.
querySelectorAll
(
selector
)
;
}
