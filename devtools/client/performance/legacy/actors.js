"
use
strict
"
;
const
{
Task
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
Poller
}
=
require
(
"
devtools
/
client
/
shared
/
poller
"
)
;
const
CompatUtils
=
require
(
"
devtools
/
client
/
performance
/
legacy
/
compatibility
"
)
;
const
RecordingUtils
=
require
(
"
devtools
/
shared
/
performance
/
recording
-
utils
"
)
;
const
{
TimelineFront
}
=
require
(
"
devtools
/
server
/
actors
/
timeline
"
)
;
const
{
ProfilerFront
}
=
require
(
"
devtools
/
server
/
actors
/
profiler
"
)
;
const
PROFILER_CHECK_TIMER
=
5000
;
const
TIMELINE_ACTOR_METHODS
=
[
"
start
"
"
stop
"
]
;
const
PROFILER_ACTOR_METHODS
=
[
"
startProfiler
"
"
getStartOptions
"
"
stopProfiler
"
"
registerEventNotifications
"
"
unregisterEventNotifications
"
]
;
function
LegacyProfilerFront
(
target
)
{
this
.
_target
=
target
;
this
.
_onProfilerEvent
=
this
.
_onProfilerEvent
.
bind
(
this
)
;
this
.
_checkProfilerStatus
=
this
.
_checkProfilerStatus
.
bind
(
this
)
;
this
.
_PROFILER_CHECK_TIMER
=
this
.
_target
.
TEST_MOCK_PROFILER_CHECK_TIMER
|
|
PROFILER_CHECK_TIMER
;
EventEmitter
.
decorate
(
this
)
;
}
LegacyProfilerFront
.
prototype
=
{
EVENTS
:
[
"
console
-
api
-
profiler
"
"
profiler
-
stopped
"
]
connect
:
Task
.
async
(
function
*
(
)
{
let
target
=
this
.
_target
;
this
.
_front
=
new
ProfilerFront
(
target
.
client
target
.
form
)
;
this
.
traits
=
{
}
;
this
.
traits
.
filterable
=
target
.
getTrait
(
"
profilerDataFilterable
"
)
;
yield
this
.
registerEventNotifications
(
{
events
:
this
.
EVENTS
}
)
;
target
.
client
.
addListener
(
"
eventNotification
"
this
.
_onProfilerEvent
)
;
}
)
destroy
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_poller
)
{
yield
this
.
_poller
.
destroy
(
)
;
}
yield
this
.
unregisterEventNotifications
(
{
events
:
this
.
EVENTS
}
)
;
this
.
_target
.
client
.
removeListener
(
"
eventNotification
"
this
.
_onProfilerEvent
)
;
yield
this
.
_front
.
destroy
(
)
;
}
)
start
:
Task
.
async
(
function
*
(
options
=
{
}
)
{
if
(
!
this
.
_poller
)
{
this
.
_poller
=
new
Poller
(
this
.
_checkProfilerStatus
this
.
_PROFILER_CHECK_TIMER
false
)
;
}
if
(
!
this
.
_poller
.
isPolling
(
)
)
{
this
.
_poller
.
on
(
)
;
}
let
{
isActive
currentTime
position
generation
totalSize
}
=
yield
this
.
getStatus
(
)
;
if
(
isActive
)
{
return
{
startTime
:
currentTime
position
generation
totalSize
}
;
}
let
profilerOptions
=
{
entries
:
options
.
bufferSize
interval
:
options
.
sampleFrequency
?
(
1000
/
(
options
.
sampleFrequency
*
1000
)
)
:
void
0
}
;
let
startInfo
=
yield
this
.
startProfiler
(
profilerOptions
)
;
let
startTime
=
0
;
if
(
'
currentTime
'
in
startInfo
)
{
startTime
=
startInfo
.
currentTime
;
}
return
{
startTime
position
generation
totalSize
}
;
}
)
stop
:
Task
.
async
(
function
*
(
)
{
yield
this
.
_poller
.
off
(
)
;
}
)
getStatus
:
Task
.
async
(
function
*
(
)
{
let
data
=
yield
(
CompatUtils
.
callFrontMethod
(
"
isActive
"
)
.
call
(
this
)
)
;
if
(
!
data
)
{
return
;
}
if
(
this
.
_target
.
TEST_PROFILER_FILTER_STATUS
)
{
data
=
Object
.
keys
(
data
)
.
reduce
(
(
acc
prop
)
=
>
{
if
(
this
.
_target
.
TEST_PROFILER_FILTER_STATUS
.
indexOf
(
prop
)
=
=
=
-
1
)
{
acc
[
prop
]
=
data
[
prop
]
;
}
return
acc
;
}
{
}
)
;
}
this
.
emit
(
"
profiler
-
status
"
data
)
;
return
data
;
}
)
getProfile
:
Task
.
async
(
function
*
(
options
)
{
let
profilerData
=
yield
(
CompatUtils
.
callFrontMethod
(
"
getProfile
"
)
.
call
(
this
options
)
)
;
if
(
profilerData
.
profile
.
meta
.
version
=
=
=
2
)
{
RecordingUtils
.
deflateProfile
(
profilerData
.
profile
)
;
}
if
(
!
this
.
traits
.
filterable
)
{
RecordingUtils
.
filterSamples
(
profilerData
.
profile
options
.
startTime
|
|
0
)
;
}
return
profilerData
;
}
)
_onProfilerEvent
:
function
(
_
{
topic
subject
details
}
)
{
if
(
topic
=
=
=
"
console
-
api
-
profiler
"
)
{
if
(
subject
.
action
=
=
=
"
profile
"
)
{
this
.
emit
(
"
console
-
profile
-
start
"
details
)
;
}
else
if
(
subject
.
action
=
=
=
"
profileEnd
"
)
{
this
.
emit
(
"
console
-
profile
-
stop
"
details
)
;
}
}
else
if
(
topic
=
=
=
"
profiler
-
stopped
"
)
{
this
.
emit
(
"
profiler
-
stopped
"
)
;
}
}
_checkProfilerStatus
:
Task
.
async
(
function
*
(
)
{
yield
this
.
getStatus
(
)
;
}
)
toString
:
(
)
=
>
"
[
object
LegacyProfilerFront
]
"
}
;
function
LegacyTimelineFront
(
target
)
{
this
.
_target
=
target
;
EventEmitter
.
decorate
(
this
)
;
}
LegacyTimelineFront
.
prototype
=
{
EVENTS
:
[
"
markers
"
"
frames
"
"
ticks
"
]
connect
:
Task
.
async
(
function
*
(
)
{
let
supported
=
yield
CompatUtils
.
timelineActorSupported
(
this
.
_target
)
;
this
.
_front
=
supported
?
new
TimelineFront
(
this
.
_target
.
client
this
.
_target
.
form
)
:
new
CompatUtils
.
MockTimelineFront
(
)
;
this
.
IS_MOCK
=
!
supported
;
this
.
EVENTS
.
forEach
(
type
=
>
{
let
handler
=
this
[
_on
{
type
}
]
=
this
.
_onTimelineData
.
bind
(
this
type
)
;
this
.
_front
.
on
(
type
handler
)
;
}
)
;
}
)
destroy
:
Task
.
async
(
function
*
(
)
{
this
.
EVENTS
.
forEach
(
type
=
>
this
.
_front
.
off
(
type
this
[
_on
{
type
}
]
)
)
;
yield
this
.
_front
.
destroy
(
)
;
}
)
_onTimelineData
:
function
(
type
.
.
.
data
)
{
this
.
emit
(
"
timeline
-
data
"
type
.
.
.
data
)
;
}
toString
:
(
)
=
>
"
[
object
LegacyTimelineFront
]
"
}
;
PROFILER_ACTOR_METHODS
.
forEach
(
m
=
>
LegacyProfilerFront
.
prototype
[
m
]
=
CompatUtils
.
callFrontMethod
(
m
)
)
;
TIMELINE_ACTOR_METHODS
.
forEach
(
m
=
>
LegacyTimelineFront
.
prototype
[
m
]
=
CompatUtils
.
callFrontMethod
(
m
)
)
;
exports
.
LegacyProfilerFront
=
LegacyProfilerFront
;
exports
.
LegacyTimelineFront
=
LegacyTimelineFront
;
