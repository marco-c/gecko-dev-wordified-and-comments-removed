"
use
strict
"
;
var
JsCallTreeView
=
Heritage
.
extend
(
DetailsSubview
{
rerenderPrefs
:
[
"
invert
-
call
-
tree
"
"
show
-
platform
-
data
"
"
flatten
-
tree
-
recursion
"
"
show
-
jit
-
optimizations
"
]
rangeChangeDebounceTime
:
75
initialize
:
function
(
)
{
DetailsSubview
.
initialize
.
call
(
this
)
;
this
.
_onLink
=
this
.
_onLink
.
bind
(
this
)
;
this
.
_onFocus
=
this
.
_onFocus
.
bind
(
this
)
;
this
.
container
=
(
"
#
js
-
calltree
-
view
.
call
-
tree
-
cells
-
container
"
)
;
this
.
optimizationsElement
=
(
"
#
jit
-
optimizations
-
view
"
)
;
}
destroy
:
function
(
)
{
ReactDOM
.
unmountComponentAtNode
(
this
.
optimizationsElement
)
;
this
.
optimizationsElement
=
null
;
this
.
container
=
null
;
this
.
threadNode
=
null
;
DetailsSubview
.
destroy
.
call
(
this
)
;
}
render
:
function
(
interval
=
{
}
)
{
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
let
profile
=
recording
.
getProfile
(
)
;
let
showOptimizations
=
PerformanceController
.
getOption
(
"
show
-
jit
-
optimizations
"
)
;
let
options
=
{
contentOnly
:
!
PerformanceController
.
getOption
(
"
show
-
platform
-
data
"
)
invertTree
:
PerformanceController
.
getOption
(
"
invert
-
call
-
tree
"
)
flattenRecursion
:
PerformanceController
.
getOption
(
"
flatten
-
tree
-
recursion
"
)
showOptimizationHint
:
showOptimizations
}
;
let
threadNode
=
this
.
threadNode
=
this
.
_prepareCallTree
(
profile
interval
options
)
;
this
.
_populateCallTree
(
threadNode
options
)
;
if
(
showOptimizations
)
{
this
.
showOptimizations
(
)
;
}
else
{
this
.
hideOptimizations
(
)
;
}
this
.
emit
(
EVENTS
.
JS_CALL_TREE_RENDERED
)
;
}
showOptimizations
:
function
(
)
{
this
.
optimizationsElement
.
classList
.
remove
(
"
hidden
"
)
;
}
hideOptimizations
:
function
(
)
{
this
.
optimizationsElement
.
classList
.
add
(
"
hidden
"
)
;
}
_onFocus
:
function
(
_
treeItem
)
{
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
let
frameNode
=
treeItem
.
frame
;
if
(
!
frameNode
)
{
console
.
warn
(
"
No
frame
found
!
"
)
;
return
;
}
let
frameData
=
frameNode
.
getInfo
(
)
;
let
optimizationSites
=
frameNode
.
hasOptimizations
(
)
?
frameNode
.
getOptimizations
(
)
.
optimizationSites
:
[
]
;
let
optimizations
=
JITOptimizationsView
(
{
frameData
optimizationSites
onViewSourceInDebugger
:
(
url
line
)
=
>
{
gToolbox
.
viewSourceInDebugger
(
url
line
)
.
then
(
success
=
>
{
if
(
success
)
{
this
.
emit
(
EVENTS
.
SOURCE_SHOWN_IN_JS_DEBUGGER
)
;
}
else
{
this
.
emit
(
EVENTS
.
SOURCE_NOT_FOUND_IN_JS_DEBUGGER
)
;
}
}
)
;
}
}
)
;
ReactDOM
.
render
(
optimizations
this
.
optimizationsElement
)
;
this
.
emit
(
"
focus
"
treeItem
)
;
}
_onLink
:
function
(
_
treeItem
)
{
let
{
url
line
}
=
treeItem
.
frame
.
getInfo
(
)
;
gToolbox
.
viewSourceInDebugger
(
url
line
)
.
then
(
success
=
>
{
if
(
success
)
{
this
.
emit
(
EVENTS
.
SOURCE_SHOWN_IN_JS_DEBUGGER
)
;
}
else
{
this
.
emit
(
EVENTS
.
SOURCE_NOT_FOUND_IN_JS_DEBUGGER
)
;
}
}
)
;
}
_prepareCallTree
:
function
(
profile
{
startTime
endTime
}
options
)
{
let
thread
=
profile
.
threads
[
0
]
;
let
{
contentOnly
invertTree
flattenRecursion
}
=
options
;
let
threadNode
=
new
ThreadNode
(
thread
{
startTime
endTime
contentOnly
invertTree
flattenRecursion
}
)
;
if
(
!
invertTree
)
{
threadNode
.
calls
=
threadNode
.
calls
[
0
]
.
calls
;
}
return
threadNode
;
}
_populateCallTree
:
function
(
frameNode
options
=
{
}
)
{
let
inverted
=
options
.
invertTree
&
&
frameNode
.
samples
>
0
;
let
root
=
new
CallView
(
{
frame
:
frameNode
inverted
:
inverted
hidden
:
inverted
autoExpandDepth
:
inverted
?
0
:
undefined
showOptimizationHint
:
options
.
showOptimizationHint
}
)
;
root
.
on
(
"
link
"
this
.
_onLink
)
;
root
.
on
(
"
focus
"
this
.
_onFocus
)
;
this
.
container
.
innerHTML
=
"
"
;
root
.
attachTo
(
this
.
container
)
;
root
.
toggleCategories
(
!
options
.
contentOnly
)
;
return
root
;
}
toString
:
(
)
=
>
"
[
object
JsCallTreeView
]
"
}
)
;
EventEmitter
.
decorate
(
JsCallTreeView
)
;
