"
use
strict
"
;
var
DetailsSubview
=
{
initialize
(
)
{
this
.
_onRecordingStoppedOrSelected
=
this
.
_onRecordingStoppedOrSelected
.
bind
(
this
)
;
this
.
_onOverviewRangeChange
=
this
.
_onOverviewRangeChange
.
bind
(
this
)
;
this
.
_onDetailsViewSelected
=
this
.
_onDetailsViewSelected
.
bind
(
this
)
;
this
.
_onPrefChanged
=
this
.
_onPrefChanged
.
bind
(
this
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
OverviewView
.
on
(
EVENTS
.
UI_OVERVIEW_RANGE_SELECTED
this
.
_onOverviewRangeChange
)
;
DetailsView
.
on
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
this
.
_onDetailsViewSelected
)
;
let
self
=
this
;
let
originalRenderFn
=
this
.
render
;
let
afterRenderFn
=
(
)
=
>
{
this
.
_wasRendered
=
true
;
}
;
this
.
render
=
Task
.
async
(
function
*
(
.
.
.
args
)
{
let
maybeRetval
=
yield
originalRenderFn
.
apply
(
self
args
)
;
afterRenderFn
(
)
;
return
maybeRetval
;
}
)
;
}
destroy
(
)
{
clearNamedTimeout
(
"
range
-
change
-
debounce
"
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
OverviewView
.
off
(
EVENTS
.
UI_OVERVIEW_RANGE_SELECTED
this
.
_onOverviewRangeChange
)
;
DetailsView
.
off
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
this
.
_onDetailsViewSelected
)
;
}
get
wasRenderedAtLeastOnce
(
)
{
return
!
!
this
.
_wasRendered
;
}
rangeChangeDebounceTime
:
0
requiresUpdateOnRangeChange
:
true
shouldUpdateWhenShown
:
false
canUpdateWhileHidden
:
false
rerenderPrefs
:
[
]
observedPrefs
:
[
]
shouldUpdateWhileMouseIsActive
:
false
_onRecordingStoppedOrSelected
(
_
state
recording
)
{
if
(
typeof
state
!
=
=
"
string
"
)
{
recording
=
state
;
}
if
(
arguments
.
length
=
=
=
3
&
&
state
!
=
=
"
recording
-
stopped
"
)
{
return
;
}
if
(
!
recording
|
|
!
recording
.
isCompleted
(
)
)
{
return
;
}
if
(
DetailsView
.
isViewSelected
(
this
)
|
|
this
.
canUpdateWhileHidden
)
{
this
.
render
(
OverviewView
.
getTimeInterval
(
)
)
;
}
else
{
this
.
shouldUpdateWhenShown
=
true
;
}
}
_onOverviewRangeChange
(
_
interval
)
{
if
(
!
this
.
requiresUpdateOnRangeChange
)
{
return
;
}
if
(
DetailsView
.
isViewSelected
(
this
)
)
{
let
debounced
=
(
)
=
>
{
if
(
!
this
.
shouldUpdateWhileMouseIsActive
&
&
OverviewView
.
isMouseActive
)
{
setNamedTimeout
(
"
range
-
change
-
debounce
"
this
.
rangeChangeDebounceTime
debounced
)
;
}
else
{
this
.
render
(
interval
)
;
}
}
;
setNamedTimeout
(
"
range
-
change
-
debounce
"
this
.
rangeChangeDebounceTime
debounced
)
;
}
else
{
this
.
shouldUpdateWhenShown
=
true
;
}
}
_onDetailsViewSelected
(
)
{
if
(
DetailsView
.
isViewSelected
(
this
)
&
&
this
.
shouldUpdateWhenShown
)
{
this
.
render
(
OverviewView
.
getTimeInterval
(
)
)
;
this
.
shouldUpdateWhenShown
=
false
;
}
}
_onPrefChanged
(
_
prefName
)
{
if
(
~
this
.
observedPrefs
.
indexOf
(
prefName
)
&
&
this
.
_onObservedPrefChange
)
{
this
.
_onObservedPrefChange
(
_
prefName
)
;
}
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
!
recording
|
|
!
recording
.
isCompleted
(
)
)
{
return
;
}
if
(
!
~
this
.
rerenderPrefs
.
indexOf
(
prefName
)
)
{
return
;
}
if
(
this
.
_onRerenderPrefChanged
)
{
this
.
_onRerenderPrefChanged
(
_
prefName
)
;
}
if
(
DetailsView
.
isViewSelected
(
this
)
|
|
this
.
canUpdateWhileHidden
)
{
this
.
render
(
OverviewView
.
getTimeInterval
(
)
)
;
}
else
{
this
.
shouldUpdateWhenShown
=
true
;
}
}
}
;
