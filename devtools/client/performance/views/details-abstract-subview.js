"
use
strict
"
;
const
{
setNamedTimeout
clearNamedTimeout
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
EVENTS
=
require
(
"
devtools
/
client
/
performance
/
events
"
)
;
const
DetailsSubview
=
{
initialize
:
function
(
)
{
this
.
_onRecordingStoppedOrSelected
=
this
.
_onRecordingStoppedOrSelected
.
bind
(
this
)
;
this
.
_onOverviewRangeChange
=
this
.
_onOverviewRangeChange
.
bind
(
this
)
;
this
.
_onDetailsViewSelected
=
this
.
_onDetailsViewSelected
.
bind
(
this
)
;
this
.
_onPrefChanged
=
this
.
_onPrefChanged
.
bind
(
this
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
OverviewView
.
on
(
EVENTS
.
UI_OVERVIEW_RANGE_SELECTED
this
.
_onOverviewRangeChange
)
;
DetailsView
.
on
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
this
.
_onDetailsViewSelected
)
;
const
self
=
this
;
const
originalRenderFn
=
this
.
render
;
const
afterRenderFn
=
(
)
=
>
{
this
.
_wasRendered
=
true
;
}
;
this
.
render
=
async
function
(
.
.
.
args
)
{
const
maybeRetval
=
await
originalRenderFn
.
apply
(
self
args
)
;
afterRenderFn
(
)
;
return
maybeRetval
;
}
;
}
destroy
:
function
(
)
{
clearNamedTimeout
(
"
range
-
change
-
debounce
"
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
OverviewView
.
off
(
EVENTS
.
UI_OVERVIEW_RANGE_SELECTED
this
.
_onOverviewRangeChange
)
;
DetailsView
.
off
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
this
.
_onDetailsViewSelected
)
;
}
get
wasRenderedAtLeastOnce
(
)
{
return
!
!
this
.
_wasRendered
;
}
rangeChangeDebounceTime
:
0
requiresUpdateOnRangeChange
:
true
shouldUpdateWhenShown
:
false
canUpdateWhileHidden
:
false
rerenderPrefs
:
[
]
observedPrefs
:
[
]
shouldUpdateWhileMouseIsActive
:
false
_onRecordingStoppedOrSelected
:
function
(
state
recording
)
{
if
(
typeof
state
!
=
=
"
string
"
)
{
recording
=
state
;
}
if
(
arguments
.
length
=
=
=
3
&
&
state
!
=
=
"
recording
-
stopped
"
)
{
return
;
}
if
(
!
recording
|
|
!
recording
.
isCompleted
(
)
)
{
return
;
}
if
(
DetailsView
.
isViewSelected
(
this
)
|
|
this
.
canUpdateWhileHidden
)
{
this
.
render
(
OverviewView
.
getTimeInterval
(
)
)
;
}
else
{
this
.
shouldUpdateWhenShown
=
true
;
}
}
_onOverviewRangeChange
:
function
(
interval
)
{
if
(
!
this
.
requiresUpdateOnRangeChange
)
{
return
;
}
if
(
DetailsView
.
isViewSelected
(
this
)
)
{
const
debounced
=
(
)
=
>
{
if
(
!
this
.
shouldUpdateWhileMouseIsActive
&
&
OverviewView
.
isMouseActive
)
{
setNamedTimeout
(
"
range
-
change
-
debounce
"
this
.
rangeChangeDebounceTime
debounced
)
;
}
else
{
this
.
render
(
interval
)
;
}
}
;
setNamedTimeout
(
"
range
-
change
-
debounce
"
this
.
rangeChangeDebounceTime
debounced
)
;
}
else
{
this
.
shouldUpdateWhenShown
=
true
;
}
}
_onDetailsViewSelected
:
function
(
)
{
if
(
DetailsView
.
isViewSelected
(
this
)
&
&
this
.
shouldUpdateWhenShown
)
{
this
.
render
(
OverviewView
.
getTimeInterval
(
)
)
;
this
.
shouldUpdateWhenShown
=
false
;
}
}
_onPrefChanged
:
function
(
prefName
prefValue
)
{
if
(
~
this
.
observedPrefs
.
indexOf
(
prefName
)
&
&
this
.
_onObservedPrefChange
)
{
this
.
_onObservedPrefChange
(
prefName
)
;
}
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
!
recording
|
|
!
recording
.
isCompleted
(
)
)
{
return
;
}
if
(
!
~
this
.
rerenderPrefs
.
indexOf
(
prefName
)
)
{
return
;
}
if
(
this
.
_onRerenderPrefChanged
)
{
this
.
_onRerenderPrefChanged
(
prefName
)
;
}
if
(
DetailsView
.
isViewSelected
(
this
)
|
|
this
.
canUpdateWhileHidden
)
{
this
.
render
(
OverviewView
.
getTimeInterval
(
)
)
;
}
else
{
this
.
shouldUpdateWhenShown
=
true
;
}
}
}
;
exports
.
DetailsSubview
=
DetailsSubview
;
