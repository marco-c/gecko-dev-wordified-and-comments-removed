"
use
strict
"
;
const
EVENTS
=
require
(
"
devtools
/
client
/
performance
/
events
"
)
;
const
{
WaterfallView
}
=
require
(
"
devtools
/
client
/
performance
/
views
/
details
-
waterfall
"
)
;
const
{
JsCallTreeView
}
=
require
(
"
devtools
/
client
/
performance
/
views
/
details
-
js
-
call
-
tree
"
)
;
const
{
JsFlameGraphView
}
=
require
(
"
devtools
/
client
/
performance
/
views
/
details
-
js
-
flamegraph
"
)
;
const
{
MemoryCallTreeView
}
=
require
(
"
devtools
/
client
/
performance
/
views
/
details
-
memory
-
call
-
tree
"
)
;
const
{
MemoryFlameGraphView
}
=
require
(
"
devtools
/
client
/
performance
/
views
/
details
-
memory
-
flamegraph
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
DetailsView
=
{
components
:
{
waterfall
:
{
id
:
"
waterfall
-
view
"
view
:
WaterfallView
features
:
[
"
withMarkers
"
]
}
"
js
-
calltree
"
:
{
id
:
"
js
-
profile
-
view
"
view
:
JsCallTreeView
}
"
js
-
flamegraph
"
:
{
id
:
"
js
-
flamegraph
-
view
"
view
:
JsFlameGraphView
}
"
memory
-
calltree
"
:
{
id
:
"
memory
-
calltree
-
view
"
view
:
MemoryCallTreeView
features
:
[
"
withAllocations
"
]
}
"
memory
-
flamegraph
"
:
{
id
:
"
memory
-
flamegraph
-
view
"
view
:
MemoryFlameGraphView
features
:
[
"
withAllocations
"
]
prefs
:
[
"
enable
-
memory
-
flame
"
]
}
}
async
initialize
(
)
{
this
.
el
=
(
"
#
details
-
pane
"
)
;
this
.
toolbar
=
(
"
#
performance
-
toolbar
-
controls
-
detail
-
views
"
)
;
this
.
_onViewToggle
=
this
.
_onViewToggle
.
bind
(
this
)
;
this
.
_onRecordingStoppedOrSelected
=
this
.
_onRecordingStoppedOrSelected
.
bind
(
this
)
;
this
.
setAvailableViews
=
this
.
setAvailableViews
.
bind
(
this
)
;
for
(
const
button
of
(
"
toolbarbutton
[
data
-
view
]
"
this
.
toolbar
)
)
{
button
.
addEventListener
(
"
command
"
this
.
_onViewToggle
)
;
}
await
this
.
setAvailableViews
(
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
PREF_CHANGED
this
.
setAvailableViews
)
;
}
async
destroy
(
)
{
for
(
const
button
of
(
"
toolbarbutton
[
data
-
view
]
"
this
.
toolbar
)
)
{
button
.
removeEventListener
(
"
command
"
this
.
_onViewToggle
)
;
}
for
(
const
component
of
Object
.
values
(
this
.
components
)
)
{
component
.
initialized
&
&
(
await
component
.
view
.
destroy
(
)
)
;
}
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
PREF_CHANGED
this
.
setAvailableViews
)
;
}
async
setAvailableViews
(
)
{
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
const
isCompleted
=
recording
&
&
recording
.
isCompleted
(
)
;
let
invalidCurrentView
=
false
;
for
(
const
[
name
{
view
}
]
of
Object
.
entries
(
this
.
components
)
)
{
const
isSupported
=
this
.
_isViewSupported
(
name
)
;
(
toolbarbutton
[
data
-
view
=
{
name
}
]
)
.
hidden
=
!
isSupported
;
if
(
!
isSupported
&
&
this
.
isViewSelected
(
view
)
)
{
invalidCurrentView
=
true
;
}
}
if
(
(
this
.
_initialized
&
&
isCompleted
&
&
invalidCurrentView
)
|
|
(
!
this
.
_initialized
&
&
isCompleted
&
&
recording
)
)
{
await
this
.
selectDefaultView
(
)
;
}
}
_isViewSupported
:
function
(
viewName
)
{
const
{
features
prefs
}
=
this
.
components
[
viewName
]
;
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
!
recording
|
|
!
recording
.
isCompleted
(
)
)
{
return
false
;
}
const
prefSupported
=
prefs
&
&
prefs
.
length
?
prefs
.
every
(
p
=
>
PerformanceController
.
getPref
(
p
)
)
:
true
;
return
PerformanceController
.
isFeatureSupported
(
features
)
&
&
prefSupported
;
}
async
selectView
(
viewName
)
{
const
component
=
this
.
components
[
viewName
]
;
this
.
el
.
selectedPanel
=
(
"
#
"
+
component
.
id
)
;
await
this
.
_whenViewInitialized
(
component
)
;
for
(
const
button
of
(
"
toolbarbutton
[
data
-
view
]
"
this
.
toolbar
)
)
{
if
(
button
.
getAttribute
(
"
data
-
view
"
)
=
=
=
viewName
)
{
button
.
setAttribute
(
"
checked
"
true
)
;
}
else
{
button
.
removeAttribute
(
"
checked
"
)
;
}
}
this
.
_initialized
=
true
;
this
.
emit
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
viewName
)
;
}
selectDefaultView
:
function
(
)
{
if
(
this
.
_isViewSupported
(
"
waterfall
"
)
)
{
return
this
.
selectView
(
"
waterfall
"
)
;
}
return
this
.
selectView
(
"
js
-
calltree
"
)
;
}
isViewSelected
:
function
(
viewObject
)
{
if
(
!
this
.
_initialized
)
{
return
false
;
}
const
selectedPanel
=
this
.
el
.
selectedPanel
;
const
selectedId
=
selectedPanel
.
id
;
for
(
const
{
id
view
}
of
Object
.
values
(
this
.
components
)
)
{
if
(
id
=
=
selectedId
&
&
view
=
=
viewObject
)
{
return
true
;
}
}
return
false
;
}
async
_whenViewInitialized
(
component
)
{
if
(
component
.
initialized
)
{
return
;
}
component
.
initialized
=
true
;
await
component
.
view
.
initialize
(
)
;
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
recording
&
&
recording
.
isCompleted
(
)
)
{
component
.
view
.
shouldUpdateWhenShown
=
true
;
}
}
_onRecordingStoppedOrSelected
:
function
(
state
recording
)
{
if
(
typeof
state
=
=
=
"
string
"
&
&
state
!
=
=
"
recording
-
stopped
"
)
{
return
;
}
this
.
setAvailableViews
(
)
;
}
_onViewToggle
:
function
(
e
)
{
this
.
selectView
(
e
.
target
.
getAttribute
(
"
data
-
view
"
)
)
;
}
toString
:
(
)
=
>
"
[
object
DetailsView
]
"
}
;
EventEmitter
.
decorate
(
DetailsView
)
;
exports
.
DetailsView
=
DetailsView
;
