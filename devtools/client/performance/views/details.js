"
use
strict
"
;
var
DetailsView
=
{
components
:
{
"
waterfall
"
:
{
id
:
"
waterfall
-
view
"
view
:
WaterfallView
features
:
[
"
withMarkers
"
]
}
"
js
-
calltree
"
:
{
id
:
"
js
-
profile
-
view
"
view
:
JsCallTreeView
}
"
js
-
flamegraph
"
:
{
id
:
"
js
-
flamegraph
-
view
"
view
:
JsFlameGraphView
}
"
memory
-
calltree
"
:
{
id
:
"
memory
-
calltree
-
view
"
view
:
MemoryCallTreeView
features
:
[
"
withAllocations
"
]
}
"
memory
-
flamegraph
"
:
{
id
:
"
memory
-
flamegraph
-
view
"
view
:
MemoryFlameGraphView
features
:
[
"
withAllocations
"
]
prefs
:
[
"
enable
-
memory
-
flame
"
]
}
}
initialize
:
Task
.
async
(
function
*
(
)
{
this
.
el
=
(
"
#
details
-
pane
"
)
;
this
.
toolbar
=
(
"
#
performance
-
toolbar
-
controls
-
detail
-
views
"
)
;
this
.
_onViewToggle
=
this
.
_onViewToggle
.
bind
(
this
)
;
this
.
_onRecordingStoppedOrSelected
=
this
.
_onRecordingStoppedOrSelected
.
bind
(
this
)
;
this
.
setAvailableViews
=
this
.
setAvailableViews
.
bind
(
this
)
;
for
(
let
button
of
(
"
toolbarbutton
[
data
-
view
]
"
this
.
toolbar
)
)
{
button
.
addEventListener
(
"
command
"
this
.
_onViewToggle
)
;
}
yield
this
.
setAvailableViews
(
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
on
(
EVENTS
.
PREF_CHANGED
this
.
setAvailableViews
)
;
}
)
destroy
:
Task
.
async
(
function
*
(
)
{
for
(
let
button
of
(
"
toolbarbutton
[
data
-
view
]
"
this
.
toolbar
)
)
{
button
.
removeEventListener
(
"
command
"
this
.
_onViewToggle
)
;
}
for
(
let
[
component
]
of
Iterator
(
this
.
components
)
)
{
component
.
initialized
&
&
(
yield
component
.
view
.
destroy
(
)
)
;
}
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingStoppedOrSelected
)
;
PerformanceController
.
off
(
EVENTS
.
PREF_CHANGED
this
.
setAvailableViews
)
;
}
)
setAvailableViews
:
Task
.
async
(
function
*
(
)
{
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
let
isCompleted
=
recording
&
&
recording
.
isCompleted
(
)
;
let
invalidCurrentView
=
false
;
for
(
let
[
name
{
view
}
]
of
Iterator
(
this
.
components
)
)
{
let
isSupported
=
this
.
_isViewSupported
(
name
)
;
(
toolbarbutton
[
data
-
view
=
{
name
}
]
)
.
hidden
=
!
isSupported
;
if
(
!
isSupported
&
&
this
.
isViewSelected
(
view
)
)
{
invalidCurrentView
=
true
;
}
}
if
(
(
this
.
_initialized
&
&
isCompleted
&
&
invalidCurrentView
)
|
|
(
!
this
.
_initialized
&
&
isCompleted
&
&
recording
)
)
{
yield
this
.
selectDefaultView
(
)
;
}
}
)
_isViewSupported
:
function
(
viewName
)
{
let
{
features
prefs
}
=
this
.
components
[
viewName
]
;
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
!
recording
|
|
!
recording
.
isCompleted
(
)
)
{
return
false
;
}
let
prefSupported
=
(
prefs
&
&
prefs
.
length
)
?
prefs
.
every
(
p
=
>
PerformanceController
.
getPref
(
p
)
)
:
true
;
return
PerformanceController
.
isFeatureSupported
(
features
)
&
&
prefSupported
;
}
selectView
:
Task
.
async
(
function
*
(
viewName
)
{
let
component
=
this
.
components
[
viewName
]
;
this
.
el
.
selectedPanel
=
(
"
#
"
+
component
.
id
)
;
yield
this
.
_whenViewInitialized
(
component
)
;
for
(
let
button
of
(
"
toolbarbutton
[
data
-
view
]
"
this
.
toolbar
)
)
{
if
(
button
.
getAttribute
(
"
data
-
view
"
)
=
=
=
viewName
)
{
button
.
setAttribute
(
"
checked
"
true
)
;
}
else
{
button
.
removeAttribute
(
"
checked
"
)
;
}
}
this
.
_initialized
=
true
;
this
.
emit
(
EVENTS
.
UI_DETAILS_VIEW_SELECTED
viewName
)
;
}
)
selectDefaultView
:
function
(
)
{
if
(
this
.
_isViewSupported
(
"
waterfall
"
)
)
{
return
this
.
selectView
(
"
waterfall
"
)
;
}
return
this
.
selectView
(
"
js
-
calltree
"
)
;
}
isViewSelected
:
function
(
viewObject
)
{
if
(
!
this
.
_initialized
)
{
return
false
;
}
let
selectedPanel
=
this
.
el
.
selectedPanel
;
let
selectedId
=
selectedPanel
.
id
;
for
(
let
[
{
id
view
}
]
of
Iterator
(
this
.
components
)
)
{
if
(
id
=
=
selectedId
&
&
view
=
=
viewObject
)
{
return
true
;
}
}
return
false
;
}
_whenViewInitialized
:
Task
.
async
(
function
*
(
component
)
{
if
(
component
.
initialized
)
{
return
;
}
component
.
initialized
=
true
;
yield
component
.
view
.
initialize
(
)
;
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
recording
&
&
recording
.
isCompleted
(
)
)
{
component
.
view
.
shouldUpdateWhenShown
=
true
;
}
}
)
_onRecordingStoppedOrSelected
:
function
(
_
state
recording
)
{
if
(
typeof
state
=
=
=
"
string
"
&
&
state
!
=
=
"
recording
-
stopped
"
)
{
return
;
}
this
.
setAvailableViews
(
)
;
}
_onViewToggle
:
function
(
e
)
{
this
.
selectView
(
e
.
target
.
getAttribute
(
"
data
-
view
"
)
)
;
}
toString
:
(
)
=
>
"
[
object
DetailsView
]
"
}
;
EventEmitter
.
decorate
(
DetailsView
)
;
