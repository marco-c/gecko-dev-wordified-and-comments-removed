"
use
strict
"
;
const
EVENTS
=
require
(
"
.
.
/
events
"
)
;
const
{
GraphsController
}
=
require
(
"
.
.
/
modules
/
widgets
/
graphs
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
OVERVIEW_UPDATE_INTERVAL
=
200
;
const
FRAMERATE_GRAPH_LOW_RES_INTERVAL
=
100
;
const
FRAMERATE_GRAPH_HIGH_RES_INTERVAL
=
16
;
const
GRAPH_REQUIREMENTS
=
{
timeline
:
{
features
:
[
"
withMarkers
"
]
}
framerate
:
{
features
:
[
"
withTicks
"
]
}
memory
:
{
features
:
[
"
withMemory
"
]
}
}
;
const
OverviewView
=
{
OVERVIEW_UPDATE_INTERVAL
:
OVERVIEW_UPDATE_INTERVAL
initialize
:
function
(
)
{
this
.
graphs
=
new
GraphsController
(
{
root
:
(
"
#
overview
-
pane
"
)
getFilter
:
(
)
=
>
PerformanceController
.
getPref
(
"
hidden
-
markers
"
)
getTheme
:
(
)
=
>
PerformanceController
.
getTheme
(
)
}
)
;
if
(
!
PerformanceController
.
getTraits
(
)
.
features
.
withMarkers
)
{
this
.
disable
(
)
;
return
;
}
this
.
_multiprocessData
=
PerformanceController
.
getMultiprocessStatus
(
)
;
this
.
_onRecordingStateChange
=
this
.
_onRecordingStateChange
.
bind
(
this
)
;
this
.
_onRecordingSelected
=
this
.
_onRecordingSelected
.
bind
(
this
)
;
this
.
_onRecordingTick
=
this
.
_onRecordingTick
.
bind
(
this
)
;
this
.
_onGraphSelecting
=
this
.
_onGraphSelecting
.
bind
(
this
)
;
this
.
_onGraphRendered
=
this
.
_onGraphRendered
.
bind
(
this
)
;
this
.
_onPrefChanged
=
this
.
_onPrefChanged
.
bind
(
this
)
;
this
.
_onThemeChanged
=
this
.
_onThemeChanged
.
bind
(
this
)
;
PerformanceController
.
on
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
PerformanceController
.
on
(
EVENTS
.
THEME_CHANGED
this
.
_onThemeChanged
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingSelected
)
;
this
.
graphs
.
on
(
"
selecting
"
this
.
_onGraphSelecting
)
;
this
.
graphs
.
on
(
"
rendered
"
this
.
_onGraphRendered
)
;
}
async
destroy
(
)
{
PerformanceController
.
off
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
PerformanceController
.
off
(
EVENTS
.
THEME_CHANGED
this
.
_onThemeChanged
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingSelected
)
;
this
.
graphs
.
off
(
"
selecting
"
this
.
_onGraphSelecting
)
;
this
.
graphs
.
off
(
"
rendered
"
this
.
_onGraphRendered
)
;
await
this
.
graphs
.
destroy
(
)
;
}
get
isMouseActive
(
)
{
return
!
!
this
.
graphs
.
getWidgets
(
)
.
some
(
e
=
>
e
.
isMouseActive
)
;
}
disable
:
function
(
)
{
this
.
_disabled
=
true
;
this
.
graphs
.
disableAll
(
)
;
}
isDisabled
:
function
(
)
{
return
this
.
_disabled
;
}
setTimeInterval
:
function
(
interval
options
=
{
}
)
{
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
recording
=
=
null
)
{
throw
new
Error
(
"
A
recording
should
be
available
in
order
to
set
the
selection
.
"
)
;
}
if
(
this
.
isDisabled
(
)
)
{
return
;
}
const
mapStart
=
(
)
=
>
0
;
const
mapEnd
=
(
)
=
>
recording
.
getDuration
(
)
;
const
selection
=
{
start
:
interval
.
startTime
end
:
interval
.
endTime
}
;
this
.
_stopSelectionChangeEventPropagation
=
options
.
stopPropagation
;
this
.
graphs
.
setMappedSelection
(
selection
{
mapStart
mapEnd
}
)
;
this
.
_stopSelectionChangeEventPropagation
=
false
;
}
getTimeInterval
:
function
(
)
{
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
recording
=
=
null
)
{
throw
new
Error
(
"
A
recording
should
be
available
in
order
to
get
the
selection
.
"
)
;
}
if
(
this
.
isDisabled
(
)
)
{
return
{
startTime
:
0
endTime
:
recording
.
getDuration
(
)
}
;
}
const
mapStart
=
(
)
=
>
0
;
const
mapEnd
=
(
)
=
>
recording
.
getDuration
(
)
;
const
selection
=
this
.
graphs
.
getMappedSelection
(
{
mapStart
mapEnd
}
)
;
if
(
!
selection
|
|
(
selection
.
max
-
selection
.
min
)
<
1
)
{
return
{
startTime
:
0
endTime
:
recording
.
getDuration
(
)
}
;
}
return
{
startTime
:
selection
.
min
endTime
:
selection
.
max
}
;
}
async
render
(
resolution
)
{
if
(
this
.
isDisabled
(
)
)
{
return
;
}
const
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
await
this
.
graphs
.
render
(
recording
.
getAllData
(
)
resolution
)
;
this
.
emit
(
EVENTS
.
UI_OVERVIEW_RENDERED
resolution
)
;
}
async
_onRecordingTick
(
)
{
await
this
.
render
(
FRAMERATE_GRAPH_LOW_RES_INTERVAL
)
;
this
.
_prepareNextTick
(
)
;
}
_prepareNextTick
:
function
(
)
{
if
(
this
.
isRendering
(
)
)
{
this
.
_timeoutId
=
setTimeout
(
this
.
_onRecordingTick
this
.
OVERVIEW_UPDATE_INTERVAL
)
;
}
}
_onRecordingStateChange
:
OverviewViewOnStateChange
(
async
function
(
state
recording
)
{
if
(
state
!
=
=
"
recording
-
stopped
"
)
{
return
;
}
if
(
recording
!
=
=
PerformanceController
.
getCurrentRecording
(
)
)
{
return
;
}
this
.
render
(
FRAMERATE_GRAPH_HIGH_RES_INTERVAL
)
;
await
this
.
_checkSelection
(
recording
)
;
}
)
_onRecordingSelected
:
OverviewViewOnStateChange
(
async
function
(
recording
)
{
this
.
_setGraphVisibilityFromRecordingFeatures
(
recording
)
;
if
(
recording
.
isCompleted
(
)
)
{
await
this
.
render
(
FRAMERATE_GRAPH_HIGH_RES_INTERVAL
)
;
}
await
this
.
_checkSelection
(
recording
)
;
this
.
graphs
.
dropSelection
(
)
;
}
)
_startPolling
:
function
(
)
{
this
.
_timeoutId
=
setTimeout
(
this
.
_onRecordingTick
this
.
OVERVIEW_UPDATE_INTERVAL
)
;
}
_stopPolling
:
function
(
)
{
clearTimeout
(
this
.
_timeoutId
)
;
this
.
_timeoutId
=
null
;
}
isRendering
:
function
(
)
{
return
!
!
this
.
_timeoutId
;
}
async
_checkSelection
(
recording
)
{
const
isEnabled
=
recording
?
recording
.
isCompleted
(
)
:
false
;
await
this
.
graphs
.
selectionEnabled
(
isEnabled
)
;
}
_onGraphSelecting
:
function
(
)
{
if
(
this
.
_stopSelectionChangeEventPropagation
)
{
return
;
}
this
.
emit
(
EVENTS
.
UI_OVERVIEW_RANGE_SELECTED
this
.
getTimeInterval
(
)
)
;
}
_onGraphRendered
:
function
(
graphName
)
{
switch
(
graphName
)
{
case
"
timeline
"
:
this
.
emit
(
EVENTS
.
UI_MARKERS_GRAPH_RENDERED
)
;
break
;
case
"
memory
"
:
this
.
emit
(
EVENTS
.
UI_MEMORY_GRAPH_RENDERED
)
;
break
;
case
"
framerate
"
:
this
.
emit
(
EVENTS
.
UI_FRAMERATE_GRAPH_RENDERED
)
;
break
;
}
}
async
_onPrefChanged
(
prefName
prefValue
)
{
switch
(
prefName
)
{
case
"
hidden
-
markers
"
:
{
const
graph
=
await
this
.
graphs
.
isAvailable
(
"
timeline
"
)
;
if
(
graph
)
{
const
filter
=
PerformanceController
.
getPref
(
"
hidden
-
markers
"
)
;
graph
.
setFilter
(
filter
)
;
graph
.
refresh
(
{
force
:
true
}
)
;
}
break
;
}
}
}
_setGraphVisibilityFromRecordingFeatures
:
function
(
recording
)
{
for
(
const
[
graphName
requirements
]
of
Object
.
entries
(
GRAPH_REQUIREMENTS
)
)
{
this
.
graphs
.
enable
(
graphName
PerformanceController
.
isFeatureSupported
(
requirements
.
features
)
)
;
}
}
isRealtimeRenderingEnabled
:
function
(
)
{
return
this
.
_multiprocessData
.
enabled
;
}
_showGraphsPanel
:
function
(
recording
)
{
this
.
_setGraphVisibilityFromRecordingFeatures
(
recording
)
;
(
"
#
overview
-
pane
"
)
.
classList
.
remove
(
"
hidden
"
)
;
}
_hideGraphsPanel
:
function
(
)
{
(
"
#
overview
-
pane
"
)
.
classList
.
add
(
"
hidden
"
)
;
}
_onThemeChanged
:
function
(
theme
)
{
this
.
graphs
.
setTheme
(
{
theme
redraw
:
true
}
)
;
}
toString
:
(
)
=
>
"
[
object
OverviewView
]
"
}
;
function
OverviewViewOnStateChange
(
fn
)
{
return
function
_onRecordingStateChange
(
recording
)
{
if
(
typeof
recording
=
=
=
"
string
"
)
{
recording
=
arguments
[
1
]
;
}
const
currentRecording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
!
currentRecording
|
|
!
recording
)
{
if
(
this
.
isRendering
(
)
)
{
this
.
_stopPolling
(
)
;
}
return
;
}
if
(
!
this
.
isRealtimeRenderingEnabled
(
)
)
{
if
(
recording
.
isRecording
(
)
)
{
this
.
_hideGraphsPanel
(
)
;
return
;
}
this
.
_showGraphsPanel
(
recording
)
;
}
if
(
this
.
isRendering
(
)
&
&
!
currentRecording
.
isRecording
(
)
)
{
this
.
_stopPolling
(
)
;
}
else
if
(
currentRecording
.
isRecording
(
)
&
&
!
this
.
isRendering
(
)
)
{
this
.
_startPolling
(
)
;
}
if
(
fn
)
{
fn
.
apply
(
this
arguments
)
;
}
}
;
}
EventEmitter
.
decorate
(
OverviewView
)
;
exports
.
OverviewView
=
OverviewView
;
