"
use
strict
"
;
const
OVERVIEW_UPDATE_INTERVAL
=
200
;
const
FRAMERATE_GRAPH_LOW_RES_INTERVAL
=
100
;
const
FRAMERATE_GRAPH_HIGH_RES_INTERVAL
=
16
;
const
GRAPH_REQUIREMENTS
=
{
timeline
:
{
features
:
[
"
withMarkers
"
]
}
framerate
:
{
features
:
[
"
withTicks
"
]
}
memory
:
{
features
:
[
"
withMemory
"
]
}
}
;
var
OverviewView
=
{
OVERVIEW_UPDATE_INTERVAL
initialize
(
)
{
this
.
graphs
=
new
GraphsController
(
{
root
:
(
"
#
overview
-
pane
"
)
getFilter
:
(
)
=
>
PerformanceController
.
getPref
(
"
hidden
-
markers
"
)
getTheme
:
(
)
=
>
PerformanceController
.
getTheme
(
)
}
)
;
if
(
!
PerformanceController
.
getTraits
(
)
.
features
.
withMarkers
)
{
this
.
disable
(
)
;
return
;
}
this
.
_multiprocessData
=
PerformanceController
.
getMultiprocessStatus
(
)
;
this
.
_onRecordingStateChange
=
this
.
_onRecordingStateChange
.
bind
(
this
)
;
this
.
_onRecordingSelected
=
this
.
_onRecordingSelected
.
bind
(
this
)
;
this
.
_onRecordingTick
=
this
.
_onRecordingTick
.
bind
(
this
)
;
this
.
_onGraphSelecting
=
this
.
_onGraphSelecting
.
bind
(
this
)
;
this
.
_onGraphRendered
=
this
.
_onGraphRendered
.
bind
(
this
)
;
this
.
_onPrefChanged
=
this
.
_onPrefChanged
.
bind
(
this
)
;
this
.
_onThemeChanged
=
this
.
_onThemeChanged
.
bind
(
this
)
;
PerformanceController
.
on
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
PerformanceController
.
on
(
EVENTS
.
THEME_CHANGED
this
.
_onThemeChanged
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingSelected
)
;
this
.
graphs
.
on
(
"
selecting
"
this
.
_onGraphSelecting
)
;
this
.
graphs
.
on
(
"
rendered
"
this
.
_onGraphRendered
)
;
}
destroy
:
Task
.
async
(
function
*
(
)
{
PerformanceController
.
off
(
EVENTS
.
PREF_CHANGED
this
.
_onPrefChanged
)
;
PerformanceController
.
off
(
EVENTS
.
THEME_CHANGED
this
.
_onThemeChanged
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_SELECTED
this
.
_onRecordingSelected
)
;
this
.
graphs
.
off
(
"
selecting
"
this
.
_onGraphSelecting
)
;
this
.
graphs
.
off
(
"
rendered
"
this
.
_onGraphRendered
)
;
yield
this
.
graphs
.
destroy
(
)
;
}
)
get
isMouseActive
(
)
{
return
!
!
this
.
graphs
.
getWidgets
(
)
.
some
(
e
=
>
e
.
isMouseActive
)
;
}
disable
(
)
{
this
.
_disabled
=
true
;
this
.
graphs
.
disableAll
(
)
;
}
isDisabled
(
)
{
return
this
.
_disabled
;
}
setTimeInterval
(
interval
options
=
{
}
)
{
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
recording
=
=
null
)
{
throw
new
Error
(
"
A
recording
should
be
available
in
order
to
set
the
selection
.
"
)
;
}
if
(
this
.
isDisabled
(
)
)
{
return
;
}
let
mapStart
=
(
)
=
>
0
;
let
mapEnd
=
(
)
=
>
recording
.
getDuration
(
)
;
let
selection
=
{
start
:
interval
.
startTime
end
:
interval
.
endTime
}
;
this
.
_stopSelectionChangeEventPropagation
=
options
.
stopPropagation
;
this
.
graphs
.
setMappedSelection
(
selection
{
mapStart
mapEnd
}
)
;
this
.
_stopSelectionChangeEventPropagation
=
false
;
}
getTimeInterval
(
)
{
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
recording
=
=
null
)
{
throw
new
Error
(
"
A
recording
should
be
available
in
order
to
get
the
selection
.
"
)
;
}
if
(
this
.
isDisabled
(
)
)
{
return
{
startTime
:
0
endTime
:
recording
.
getDuration
(
)
}
;
}
let
mapStart
=
(
)
=
>
0
;
let
mapEnd
=
(
)
=
>
recording
.
getDuration
(
)
;
let
selection
=
this
.
graphs
.
getMappedSelection
(
{
mapStart
mapEnd
}
)
;
if
(
!
selection
|
|
(
selection
.
max
-
selection
.
min
)
<
1
)
{
return
{
startTime
:
0
endTime
:
recording
.
getDuration
(
)
}
;
}
return
{
startTime
:
selection
.
min
endTime
:
selection
.
max
}
;
}
render
:
Task
.
async
(
function
*
(
resolution
)
{
if
(
this
.
isDisabled
(
)
)
{
return
;
}
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
yield
this
.
graphs
.
render
(
recording
.
getAllData
(
)
resolution
)
;
this
.
emit
(
EVENTS
.
UI_OVERVIEW_RENDERED
resolution
)
;
}
)
_onRecordingTick
:
Task
.
async
(
function
*
(
)
{
yield
this
.
render
(
FRAMERATE_GRAPH_LOW_RES_INTERVAL
)
;
this
.
_prepareNextTick
(
)
;
}
)
_prepareNextTick
(
)
{
if
(
this
.
isRendering
(
)
)
{
this
.
_timeoutId
=
setTimeout
(
this
.
_onRecordingTick
this
.
OVERVIEW_UPDATE_INTERVAL
)
;
}
}
_onRecordingStateChange
:
OverviewViewOnStateChange
(
Task
.
async
(
function
*
(
_
state
recording
)
{
if
(
state
!
=
=
"
recording
-
stopped
"
)
{
return
;
}
if
(
recording
!
=
=
PerformanceController
.
getCurrentRecording
(
)
)
{
return
;
}
this
.
render
(
FRAMERATE_GRAPH_HIGH_RES_INTERVAL
)
;
yield
this
.
_checkSelection
(
recording
)
;
}
)
)
_onRecordingSelected
:
OverviewViewOnStateChange
(
Task
.
async
(
function
*
(
_
recording
)
{
this
.
_setGraphVisibilityFromRecordingFeatures
(
recording
)
;
if
(
recording
.
isCompleted
(
)
)
{
yield
this
.
render
(
FRAMERATE_GRAPH_HIGH_RES_INTERVAL
)
;
}
yield
this
.
_checkSelection
(
recording
)
;
this
.
graphs
.
dropSelection
(
)
;
}
)
)
_startPolling
(
)
{
this
.
_timeoutId
=
setTimeout
(
this
.
_onRecordingTick
this
.
OVERVIEW_UPDATE_INTERVAL
)
;
}
_stopPolling
(
)
{
clearTimeout
(
this
.
_timeoutId
)
;
this
.
_timeoutId
=
null
;
}
isRendering
(
)
{
return
!
!
this
.
_timeoutId
;
}
_checkSelection
:
Task
.
async
(
function
*
(
recording
)
{
let
isEnabled
=
recording
?
recording
.
isCompleted
(
)
:
false
;
yield
this
.
graphs
.
selectionEnabled
(
isEnabled
)
;
}
)
_onGraphSelecting
(
)
{
if
(
this
.
_stopSelectionChangeEventPropagation
)
{
return
;
}
this
.
emit
(
EVENTS
.
UI_OVERVIEW_RANGE_SELECTED
this
.
getTimeInterval
(
)
)
;
}
_onGraphRendered
(
_
graphName
)
{
switch
(
graphName
)
{
case
"
timeline
"
:
this
.
emit
(
EVENTS
.
UI_MARKERS_GRAPH_RENDERED
)
;
break
;
case
"
memory
"
:
this
.
emit
(
EVENTS
.
UI_MEMORY_GRAPH_RENDERED
)
;
break
;
case
"
framerate
"
:
this
.
emit
(
EVENTS
.
UI_FRAMERATE_GRAPH_RENDERED
)
;
break
;
}
}
_onPrefChanged
:
Task
.
async
(
function
*
(
_
prefName
prefValue
)
{
switch
(
prefName
)
{
case
"
hidden
-
markers
"
:
{
let
graph
=
yield
this
.
graphs
.
isAvailable
(
"
timeline
"
)
;
if
(
graph
)
{
let
filter
=
PerformanceController
.
getPref
(
"
hidden
-
markers
"
)
;
graph
.
setFilter
(
filter
)
;
graph
.
refresh
(
{
force
:
true
}
)
;
}
break
;
}
}
}
)
_setGraphVisibilityFromRecordingFeatures
(
recording
)
{
for
(
let
[
graphName
requirements
]
of
Object
.
entries
(
GRAPH_REQUIREMENTS
)
)
{
this
.
graphs
.
enable
(
graphName
PerformanceController
.
isFeatureSupported
(
requirements
.
features
)
)
;
}
}
isRealtimeRenderingEnabled
(
)
{
return
this
.
_multiprocessData
.
enabled
;
}
_showGraphsPanel
(
recording
)
{
this
.
_setGraphVisibilityFromRecordingFeatures
(
recording
)
;
(
"
#
overview
-
pane
"
)
.
classList
.
remove
(
"
hidden
"
)
;
}
_hideGraphsPanel
(
)
{
(
"
#
overview
-
pane
"
)
.
classList
.
add
(
"
hidden
"
)
;
}
_onThemeChanged
(
_
theme
)
{
this
.
graphs
.
setTheme
(
{
theme
redraw
:
true
}
)
;
}
toString
:
(
)
=
>
"
[
object
OverviewView
]
"
}
;
function
OverviewViewOnStateChange
(
fn
)
{
return
function
_onRecordingStateChange
(
eventName
recording
)
{
if
(
typeof
recording
=
=
=
"
string
"
)
{
recording
=
arguments
[
2
]
;
}
let
currentRecording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
!
currentRecording
|
|
!
recording
)
{
if
(
this
.
isRendering
(
)
)
{
this
.
_stopPolling
(
)
;
}
return
;
}
if
(
!
this
.
isRealtimeRenderingEnabled
(
)
)
{
if
(
recording
.
isRecording
(
)
)
{
this
.
_hideGraphsPanel
(
)
;
return
;
}
this
.
_showGraphsPanel
(
recording
)
;
}
if
(
this
.
isRendering
(
)
&
&
!
currentRecording
.
isRecording
(
)
)
{
this
.
_stopPolling
(
)
;
}
else
if
(
currentRecording
.
isRecording
(
)
&
&
!
this
.
isRendering
(
)
)
{
this
.
_startPolling
(
)
;
}
if
(
fn
)
{
fn
.
apply
(
this
arguments
)
;
}
}
;
}
EventEmitter
.
decorate
(
OverviewView
)
;
