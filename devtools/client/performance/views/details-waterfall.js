"
use
strict
"
;
const
MARKER_DETAILS_WIDTH
=
200
;
const
WATERFALL_RESIZE_EVENTS_DRAIN
=
100
;
const
{
TickUtils
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
waterfall
-
ticks
"
)
;
var
WaterfallView
=
Heritage
.
extend
(
DetailsSubview
{
MARKER_EPSILON
:
0
.
000000000001
WATERFALL_MARKER_SIDEBAR_WIDTH
:
175
WATERFALL_MARKER_SIDEBAR_SAFE_BOUNDS
:
20
observedPrefs
:
[
"
hidden
-
markers
"
]
rerenderPrefs
:
[
"
hidden
-
markers
"
]
rangeChangeDebounceTime
:
75
initialize
(
)
{
DetailsSubview
.
initialize
.
call
(
this
)
;
this
.
_cache
=
new
WeakMap
(
)
;
this
.
_onMarkerSelected
=
this
.
_onMarkerSelected
.
bind
(
this
)
;
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
_onViewSource
=
this
.
_onViewSource
.
bind
(
this
)
;
this
.
_onShowAllocations
=
this
.
_onShowAllocations
.
bind
(
this
)
;
this
.
_hiddenMarkers
=
PerformanceController
.
getPref
(
"
hidden
-
markers
"
)
;
this
.
treeContainer
=
(
"
#
waterfall
-
tree
"
)
;
this
.
detailsContainer
=
(
"
#
waterfall
-
details
"
)
;
this
.
detailsSplitter
=
(
"
#
waterfall
-
view
>
splitter
"
)
;
this
.
details
=
new
MarkerDetails
(
(
"
#
waterfall
-
details
"
)
(
"
#
waterfall
-
view
>
splitter
"
)
)
;
this
.
details
.
hidden
=
true
;
this
.
details
.
on
(
"
resize
"
this
.
_onResize
)
;
this
.
details
.
on
(
"
view
-
source
"
this
.
_onViewSource
)
;
this
.
details
.
on
(
"
show
-
allocations
"
this
.
_onShowAllocations
)
;
window
.
addEventListener
(
"
resize
"
this
.
_onResize
)
;
this
.
details
.
width
=
MARKER_DETAILS_WIDTH
;
}
destroy
(
)
{
DetailsSubview
.
destroy
.
call
(
this
)
;
clearNamedTimeout
(
"
waterfall
-
resize
"
)
;
this
.
_cache
=
null
;
this
.
details
.
off
(
"
resize
"
this
.
_onResize
)
;
this
.
details
.
off
(
"
view
-
source
"
this
.
_onViewSource
)
;
this
.
details
.
off
(
"
show
-
allocations
"
this
.
_onShowAllocations
)
;
window
.
removeEventListener
(
"
resize
"
this
.
_onResize
)
;
ReactDOM
.
unmountComponentAtNode
(
this
.
treeContainer
)
;
}
render
(
interval
=
{
}
)
{
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
if
(
recording
.
isRecording
(
)
)
{
return
;
}
let
startTime
=
interval
.
startTime
|
|
0
;
let
endTime
=
interval
.
endTime
|
|
recording
.
getDuration
(
)
;
let
markers
=
recording
.
getMarkers
(
)
;
let
rootMarkerNode
=
this
.
_prepareWaterfallTree
(
markers
)
;
this
.
_populateWaterfallTree
(
rootMarkerNode
{
startTime
endTime
}
)
;
this
.
emit
(
EVENTS
.
UI_WATERFALL_RENDERED
)
;
}
_onMarkerSelected
(
event
marker
)
{
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
let
frames
=
recording
.
getFrames
(
)
;
let
allocations
=
recording
.
getConfiguration
(
)
.
withAllocations
;
if
(
event
=
=
=
"
selected
"
)
{
this
.
details
.
render
(
{
marker
frames
allocations
}
)
;
this
.
details
.
hidden
=
false
;
}
if
(
event
=
=
=
"
unselected
"
)
{
this
.
details
.
empty
(
)
;
}
}
_onResize
(
)
{
setNamedTimeout
(
"
waterfall
-
resize
"
WATERFALL_RESIZE_EVENTS_DRAIN
(
)
=
>
{
this
.
render
(
OverviewView
.
getTimeInterval
(
)
)
;
}
)
;
}
_onObservedPrefChange
(
_
prefName
)
{
this
.
_hiddenMarkers
=
PerformanceController
.
getPref
(
"
hidden
-
markers
"
)
;
this
.
_cache
=
new
WeakMap
(
)
;
}
_onViewSource
(
_
data
)
{
gToolbox
.
viewSourceInDebugger
(
data
.
url
data
.
line
)
;
}
_onShowAllocations
(
_
data
)
{
let
{
endTime
}
=
data
;
let
startTime
=
0
;
let
recording
=
PerformanceController
.
getCurrentRecording
(
)
;
let
markers
=
recording
.
getMarkers
(
)
;
let
lastGCMarkerFromPreviousCycle
=
null
;
let
lastGCMarker
=
null
;
for
(
let
marker
of
markers
)
{
if
(
marker
.
start
=
=
=
endTime
)
{
break
;
}
if
(
marker
.
name
=
=
=
"
GarbageCollection
"
)
{
if
(
lastGCMarker
&
&
lastGCMarker
.
cycle
!
=
=
marker
.
cycle
)
{
lastGCMarkerFromPreviousCycle
=
lastGCMarker
;
}
lastGCMarker
=
marker
;
}
}
if
(
lastGCMarkerFromPreviousCycle
)
{
startTime
=
lastGCMarkerFromPreviousCycle
.
end
;
}
endTime
-
=
this
.
MARKER_EPSILON
;
startTime
+
=
startTime
!
=
=
0
?
this
.
MARKER_EPSILON
:
0
;
OverviewView
.
setTimeInterval
(
{
startTime
endTime
}
)
;
DetailsView
.
selectView
(
"
memory
-
calltree
"
)
;
}
_prepareWaterfallTree
(
markers
)
{
let
cached
=
this
.
_cache
.
get
(
markers
)
;
if
(
cached
)
{
return
cached
;
}
let
rootMarkerNode
=
WaterfallUtils
.
createParentNode
(
{
name
:
"
(
root
)
"
}
)
;
WaterfallUtils
.
collapseMarkersIntoNode
(
{
rootNode
:
rootMarkerNode
markersList
:
markers
filter
:
this
.
_hiddenMarkers
}
)
;
this
.
_cache
.
set
(
markers
rootMarkerNode
)
;
return
rootMarkerNode
;
}
_recalculateBounds
(
)
{
this
.
waterfallWidth
=
this
.
treeContainer
.
clientWidth
-
this
.
WATERFALL_MARKER_SIDEBAR_WIDTH
-
this
.
WATERFALL_MARKER_SIDEBAR_SAFE_BOUNDS
;
}
_populateWaterfallTree
(
rootMarkerNode
interval
)
{
this
.
_recalculateBounds
(
)
;
let
doc
=
this
.
treeContainer
.
ownerDocument
;
let
startTime
=
interval
.
startTime
|
0
;
let
endTime
=
interval
.
endTime
|
0
;
let
dataScale
=
this
.
waterfallWidth
/
(
endTime
-
startTime
)
;
this
.
canvas
=
TickUtils
.
drawWaterfallBackground
(
doc
dataScale
this
.
waterfallWidth
)
;
let
treeView
=
Waterfall
(
{
marker
:
rootMarkerNode
startTime
endTime
dataScale
sidebarWidth
:
this
.
WATERFALL_MARKER_SIDEBAR_WIDTH
waterfallWidth
:
this
.
waterfallWidth
onFocus
:
node
=
>
this
.
_onMarkerSelected
(
"
selected
"
node
)
}
)
;
ReactDOM
.
render
(
treeView
this
.
treeContainer
)
;
}
toString
:
(
)
=
>
"
[
object
WaterfallView
]
"
}
)
;
EventEmitter
.
decorate
(
WaterfallView
)
;
