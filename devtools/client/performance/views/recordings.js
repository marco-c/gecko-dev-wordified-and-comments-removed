"
use
strict
"
;
var
RecordingsView
=
{
initialize
(
)
{
this
.
_onSelect
=
this
.
_onSelect
.
bind
(
this
)
;
this
.
_onRecordingStateChange
=
this
.
_onRecordingStateChange
.
bind
(
this
)
;
this
.
_onNewRecording
=
this
.
_onNewRecording
.
bind
(
this
)
;
this
.
_onSaveButtonClick
=
this
.
_onSaveButtonClick
.
bind
(
this
)
;
this
.
_onRecordingDeleted
=
this
.
_onRecordingDeleted
.
bind
(
this
)
;
this
.
_onRecordingExported
=
this
.
_onRecordingExported
.
bind
(
this
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_ADDED
this
.
_onNewRecording
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_DELETED
this
.
_onRecordingDeleted
)
;
PerformanceController
.
on
(
EVENTS
.
RECORDING_EXPORTED
this
.
_onRecordingExported
)
;
this
.
_listState
=
{
recordings
:
[
]
labels
:
new
WeakMap
(
)
selected
:
null
}
;
this
.
_listMount
=
PerformanceUtils
.
createHtmlMount
(
(
"
#
recording
-
list
-
mount
"
)
)
;
this
.
_renderList
(
)
;
}
getSelectedIndex
(
)
{
const
{
recordings
selected
}
=
this
.
_listState
;
return
recordings
.
indexOf
(
selected
)
;
}
setSelectedByIndex
(
index
)
{
this
.
_onSelect
(
this
.
_listState
.
recordings
[
index
]
)
;
this
.
_renderList
(
)
;
}
get
selected
(
)
{
return
this
.
_listState
.
selected
;
}
get
itemCount
(
)
{
return
this
.
_listState
.
recordings
.
length
;
}
_renderList
(
)
{
const
{
recordings
labels
selected
}
=
this
.
_listState
;
const
recordingList
=
RecordingList
(
{
itemComponent
:
RecordingListItem
items
:
recordings
.
map
(
recording
=
>
(
{
onSelect
:
(
)
=
>
this
.
_onSelect
(
recording
)
onSave
:
(
)
=
>
this
.
_onSaveButtonClick
(
recording
)
isLoading
:
!
recording
.
isRecording
(
)
&
&
!
recording
.
isCompleted
(
)
isRecording
:
recording
.
isRecording
(
)
isSelected
:
recording
=
=
=
selected
duration
:
recording
.
getDuration
(
)
.
toFixed
(
0
)
label
:
labels
.
get
(
recording
)
}
)
)
}
)
;
ReactDOM
.
render
(
recordingList
this
.
_listMount
)
;
}
destroy
(
)
{
PerformanceController
.
off
(
EVENTS
.
RECORDING_STATE_CHANGE
this
.
_onRecordingStateChange
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_ADDED
this
.
_onNewRecording
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_DELETED
this
.
_onRecordingDeleted
)
;
PerformanceController
.
off
(
EVENTS
.
RECORDING_EXPORTED
this
.
_onRecordingExported
)
;
}
_onNewRecording
(
_
recording
)
{
this
.
_onRecordingStateChange
(
_
null
recording
)
;
}
_onRecordingStateChange
(
_
state
recording
)
{
const
{
recordings
labels
}
=
this
.
_listState
;
if
(
!
recordings
.
includes
(
recording
)
)
{
recordings
.
push
(
recording
)
;
labels
.
set
(
recording
recording
.
getLabel
(
)
|
|
L10N
.
getFormatStr
(
"
recordingsList
.
itemLabel
"
recordings
.
length
)
)
;
if
(
!
recording
.
isConsole
(
)
|
|
!
this
.
_listState
.
selected
)
{
this
.
_onSelect
(
recording
)
;
}
}
const
isCompletedManualRecording
=
!
recording
.
isConsole
(
)
&
&
recording
.
isCompleted
(
)
;
if
(
recording
.
isImported
(
)
|
|
isCompletedManualRecording
)
{
this
.
_onSelect
(
recording
)
;
}
this
.
_renderList
(
)
;
}
_onRecordingDeleted
(
_
recording
)
{
const
{
recordings
}
=
this
.
_listState
;
const
index
=
recordings
.
indexOf
(
recording
)
;
if
(
index
=
=
=
-
1
)
{
throw
new
Error
(
"
Attempting
to
remove
a
recording
that
doesn
'
t
exist
.
"
)
;
}
recordings
.
splice
(
index
1
)
;
this
.
_renderList
(
)
;
}
_onSelect
:
Task
.
async
(
function
*
(
recording
)
{
this
.
_listState
.
selected
=
recording
;
this
.
emit
(
EVENTS
.
UI_RECORDING_SELECTED
recording
)
;
this
.
_renderList
(
)
;
}
)
_onSaveButtonClick
(
recording
)
{
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
L10N
.
getStr
(
"
recordingsList
.
saveDialogTitle
"
)
Ci
.
nsIFilePicker
.
modeSave
)
;
fp
.
appendFilter
(
L10N
.
getStr
(
"
recordingsList
.
saveDialogJSONFilter
"
)
"
*
.
json
"
)
;
fp
.
appendFilter
(
L10N
.
getStr
(
"
recordingsList
.
saveDialogAllFilter
"
)
"
*
.
*
"
)
;
fp
.
defaultString
=
"
profile
.
json
"
;
fp
.
open
(
{
done
:
result
=
>
{
if
(
result
=
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
return
;
}
this
.
emit
(
EVENTS
.
UI_EXPORT_RECORDING
recording
fp
.
file
)
;
}
}
)
;
}
_onRecordingExported
(
_
recording
file
)
{
if
(
recording
.
isConsole
(
)
)
{
return
;
}
const
name
=
file
.
leafName
.
replace
(
/
\
.
.
+
/
"
"
)
;
this
.
_listState
.
labels
.
set
(
recording
name
)
;
this
.
_renderList
(
)
;
}
}
;
EventEmitter
.
decorate
(
RecordingsView
)
;
