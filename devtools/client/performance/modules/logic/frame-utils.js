"
use
strict
"
;
const
global
=
require
(
"
devtools
/
client
/
performance
/
modules
/
global
"
)
;
const
demangle
=
require
(
"
devtools
/
client
/
shared
/
demangle
"
)
;
const
{
assert
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
isChromeScheme
isContentScheme
isWASM
parseURL
}
=
require
(
"
devtools
/
client
/
shared
/
source
-
utils
"
)
;
const
{
CATEGORY_MASK
CATEGORY_MAPPINGS
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
categories
"
)
;
const
CHAR_CODE_R
=
"
r
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_0
=
"
0
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_9
=
"
9
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_CAP_Z
=
"
Z
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_LPAREN
=
"
(
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_RPAREN
=
"
)
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_COLON
=
"
:
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_SPACE
=
"
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_UNDERSCORE
=
"
_
"
.
charCodeAt
(
0
)
;
const
EVAL_TOKEN
=
"
%
20
%
3E
%
20eval
"
;
const
gInflatedFrameStore
=
new
WeakMap
(
)
;
const
gFrameData
=
new
WeakMap
(
)
;
function
parseLocation
(
location
fallbackLine
fallbackColumn
)
{
let
line
column
url
;
let
parenIndex
=
-
1
;
let
lineAndColumnIndex
=
-
1
;
let
lastCharCode
=
location
.
charCodeAt
(
location
.
length
-
1
)
;
let
i
;
if
(
lastCharCode
=
=
=
CHAR_CODE_RPAREN
)
{
i
=
location
.
length
-
2
;
}
else
if
(
isNumeric
(
lastCharCode
)
)
{
i
=
location
.
length
-
1
;
}
else
{
i
=
0
;
}
if
(
i
!
=
=
0
)
{
let
end
=
i
;
while
(
isNumeric
(
location
.
charCodeAt
(
i
)
)
)
{
i
-
-
;
}
if
(
location
.
charCodeAt
(
i
)
=
=
=
CHAR_CODE_COLON
)
{
column
=
location
.
substr
(
i
+
1
end
-
i
)
;
i
-
-
;
}
end
=
i
;
while
(
isNumeric
(
location
.
charCodeAt
(
i
)
)
)
{
i
-
-
;
}
if
(
location
.
charCodeAt
(
i
)
=
=
=
CHAR_CODE_COLON
)
{
line
=
location
.
substr
(
i
+
1
end
-
i
)
;
lineAndColumnIndex
=
i
;
i
-
-
;
}
else
{
lineAndColumnIndex
=
i
+
1
;
line
=
column
;
column
=
undefined
;
}
}
if
(
lastCharCode
=
=
=
CHAR_CODE_RPAREN
)
{
for
(
;
i
>
=
0
;
i
-
-
)
{
if
(
location
.
charCodeAt
(
i
)
=
=
=
CHAR_CODE_LPAREN
&
&
i
>
0
&
&
location
.
charCodeAt
(
i
-
1
)
=
=
=
CHAR_CODE_SPACE
)
{
parenIndex
=
i
;
break
;
}
}
}
let
parsedUrl
;
if
(
lineAndColumnIndex
>
0
)
{
let
resource
=
location
.
substring
(
parenIndex
+
1
lineAndColumnIndex
)
;
url
=
resource
.
split
(
"
-
>
"
)
.
pop
(
)
;
if
(
url
)
{
parsedUrl
=
parseURL
(
url
)
;
}
}
let
functionName
fileName
port
host
;
line
=
line
|
|
fallbackLine
;
column
=
column
|
|
fallbackColumn
;
if
(
parsedUrl
)
{
functionName
=
location
.
substring
(
0
parenIndex
-
1
)
;
fileName
=
parsedUrl
.
fileName
;
port
=
parsedUrl
.
port
;
host
=
parsedUrl
.
host
;
let
evalIndex
=
fileName
.
indexOf
(
EVAL_TOKEN
)
;
if
(
evalIndex
!
=
=
-
1
&
&
evalIndex
=
=
=
(
fileName
.
length
-
EVAL_TOKEN
.
length
)
)
{
let
evalLine
=
line
;
let
[
_fileName
_line
]
=
fileName
.
match
(
/
(
.
+
)
(
%
20line
%
20
(
\
d
+
)
%
20
%
3E
%
20eval
)
/
)
|
|
[
]
;
fileName
=
{
_fileName
}
(
eval
:
{
evalLine
}
)
;
line
=
_line
;
assert
(
_fileName
!
=
=
undefined
"
Filename
could
not
be
found
from
an
eval
location
site
"
)
;
assert
(
_line
!
=
=
undefined
"
Line
could
not
be
found
from
an
eval
location
site
"
)
;
[
url
]
=
url
.
match
(
/
(
.
+
)
(
line
(
\
d
+
)
>
eval
)
/
)
|
|
[
]
;
assert
(
url
!
=
=
undefined
"
The
URL
could
not
be
parsed
correctly
from
an
eval
location
site
"
)
;
}
}
else
{
functionName
=
location
;
url
=
null
;
}
return
{
functionName
fileName
host
port
url
line
column
}
;
}
function
computeIsContentAndCategory
(
frame
)
{
if
(
frame
.
category
)
{
return
;
}
let
location
=
frame
.
location
;
let
lastCharCode
=
location
.
charCodeAt
(
location
.
length
-
1
)
;
let
schemeStartIndex
=
-
1
;
if
(
lastCharCode
=
=
=
CHAR_CODE_RPAREN
)
{
for
(
let
i
=
location
.
length
-
2
;
i
>
=
0
;
i
-
-
)
{
if
(
location
.
charCodeAt
(
i
)
=
=
=
CHAR_CODE_LPAREN
&
&
i
>
0
&
&
location
.
charCodeAt
(
i
-
1
)
=
=
=
CHAR_CODE_SPACE
)
{
schemeStartIndex
=
i
+
1
;
break
;
}
}
}
else
{
schemeStartIndex
=
0
;
}
if
(
isContentScheme
(
location
schemeStartIndex
)
|
|
isWASM
(
location
)
)
{
frame
.
isContent
=
true
;
return
;
}
if
(
schemeStartIndex
!
=
=
0
)
{
for
(
let
j
=
schemeStartIndex
;
j
<
location
.
length
;
j
+
+
)
{
if
(
location
.
charCodeAt
(
j
)
=
=
=
CHAR_CODE_R
&
&
isChromeScheme
(
location
j
)
&
&
(
location
.
indexOf
(
"
resource
:
/
/
devtools
"
)
!
=
=
-
1
|
|
location
.
indexOf
(
"
resource
:
/
/
devtools
"
)
!
=
=
-
1
)
)
{
frame
.
category
=
CATEGORY_MASK
(
"
tools
"
)
;
return
;
}
}
}
if
(
location
=
=
=
"
EnterJIT
"
)
{
frame
.
category
=
CATEGORY_MASK
(
"
js
"
)
;
return
;
}
frame
.
category
=
CATEGORY_MASK
(
"
other
"
)
;
}
function
getInflatedFrameCache
(
frameTable
)
{
let
inflatedCache
=
gInflatedFrameStore
.
get
(
frameTable
)
;
if
(
inflatedCache
!
=
=
undefined
)
{
return
inflatedCache
;
}
inflatedCache
=
Array
.
from
(
{
length
:
frameTable
.
data
.
length
}
(
)
=
>
null
)
;
gInflatedFrameStore
.
set
(
frameTable
inflatedCache
)
;
return
inflatedCache
;
}
function
getOrAddInflatedFrame
(
cache
index
frameTable
stringTable
)
{
let
inflatedFrame
=
cache
[
index
]
;
if
(
inflatedFrame
=
=
=
null
)
{
inflatedFrame
=
cache
[
index
]
=
new
InflatedFrame
(
index
frameTable
stringTable
)
;
}
return
inflatedFrame
;
}
function
InflatedFrame
(
index
frameTable
stringTable
)
{
const
LOCATION_SLOT
=
frameTable
.
schema
.
location
;
const
IMPLEMENTATION_SLOT
=
frameTable
.
schema
.
implementation
;
const
OPTIMIZATIONS_SLOT
=
frameTable
.
schema
.
optimizations
;
const
LINE_SLOT
=
frameTable
.
schema
.
line
;
const
CATEGORY_SLOT
=
frameTable
.
schema
.
category
;
let
frame
=
frameTable
.
data
[
index
]
;
let
category
=
frame
[
CATEGORY_SLOT
]
;
this
.
location
=
stringTable
[
frame
[
LOCATION_SLOT
]
]
;
this
.
implementation
=
frame
[
IMPLEMENTATION_SLOT
]
;
this
.
optimizations
=
frame
[
OPTIMIZATIONS_SLOT
]
;
this
.
line
=
frame
[
LINE_SLOT
]
;
this
.
column
=
undefined
;
this
.
category
=
category
;
this
.
isContent
=
false
;
computeIsContentAndCategory
(
this
)
;
}
InflatedFrame
.
prototype
.
getFrameKey
=
function
getFrameKey
(
options
)
{
if
(
this
.
isContent
|
|
!
options
.
contentOnly
|
|
options
.
isRoot
)
{
options
.
isMetaCategoryOut
=
false
;
return
this
.
location
;
}
if
(
options
.
isLeaf
)
{
options
.
isMetaCategoryOut
=
true
;
return
this
.
category
;
}
return
"
"
;
}
;
function
isNumeric
(
c
)
{
return
c
>
=
CHAR_CODE_0
&
&
c
<
=
CHAR_CODE_9
;
}
function
shouldDemangle
(
name
)
{
return
name
&
&
name
.
charCodeAt
&
&
name
.
charCodeAt
(
0
)
=
=
=
CHAR_CODE_UNDERSCORE
&
&
name
.
charCodeAt
(
1
)
=
=
=
CHAR_CODE_UNDERSCORE
&
&
name
.
charCodeAt
(
2
)
=
=
=
CHAR_CODE_CAP_Z
;
}
function
getFrameInfo
(
node
options
)
{
let
data
=
gFrameData
.
get
(
node
)
;
if
(
!
data
)
{
if
(
node
.
nodeType
=
=
=
"
Thread
"
)
{
data
=
Object
.
create
(
null
)
;
data
.
functionName
=
global
.
L10N
.
getStr
(
"
table
.
root
"
)
;
}
else
{
data
=
parseLocation
(
node
.
location
node
.
line
node
.
column
)
;
data
.
hasOptimizations
=
node
.
hasOptimizations
(
)
;
data
.
isContent
=
node
.
isContent
;
data
.
isMetaCategory
=
node
.
isMetaCategory
;
}
data
.
samples
=
node
.
youngestFrameSamples
;
data
.
categoryData
=
CATEGORY_MAPPINGS
[
node
.
category
]
|
|
{
}
;
data
.
nodeType
=
node
.
nodeType
;
if
(
data
.
isMetaCategory
)
{
data
.
name
=
data
.
categoryData
.
label
;
}
else
if
(
shouldDemangle
(
data
.
functionName
)
)
{
data
.
name
=
demangle
(
data
.
functionName
)
;
}
else
{
data
.
name
=
data
.
functionName
;
}
data
.
tooltiptext
=
data
.
isMetaCategory
?
data
.
categoryData
.
label
:
node
.
location
|
|
"
"
;
gFrameData
.
set
(
node
data
)
;
}
if
(
!
options
)
{
return
data
;
}
let
totalSamples
=
options
.
root
.
samples
;
let
totalDuration
=
options
.
root
.
duration
;
if
(
options
&
&
options
.
root
&
&
!
data
.
COSTS_CALCULATED
)
{
data
.
selfDuration
=
node
.
youngestFrameSamples
/
totalSamples
*
totalDuration
;
data
.
selfPercentage
=
node
.
youngestFrameSamples
/
totalSamples
*
100
;
data
.
totalDuration
=
node
.
samples
/
totalSamples
*
totalDuration
;
data
.
totalPercentage
=
node
.
samples
/
totalSamples
*
100
;
data
.
COSTS_CALCULATED
=
true
;
}
if
(
options
&
&
options
.
allocations
&
&
!
data
.
ALLOCATION_DATA_CALCULATED
)
{
let
totalBytes
=
options
.
root
.
byteSize
;
data
.
selfCount
=
node
.
youngestFrameSamples
;
data
.
totalCount
=
node
.
samples
;
data
.
selfCountPercentage
=
node
.
youngestFrameSamples
/
totalSamples
*
100
;
data
.
totalCountPercentage
=
node
.
samples
/
totalSamples
*
100
;
data
.
selfSize
=
node
.
youngestFrameByteSize
;
data
.
totalSize
=
node
.
byteSize
;
data
.
selfSizePercentage
=
node
.
youngestFrameByteSize
/
totalBytes
*
100
;
data
.
totalSizePercentage
=
node
.
byteSize
/
totalBytes
*
100
;
data
.
ALLOCATION_DATA_CALCULATED
=
true
;
}
return
data
;
}
exports
.
getFrameInfo
=
getFrameInfo
;
function
findFrameByLocation
(
threadNode
location
)
{
if
(
!
threadNode
.
inverted
)
{
throw
new
Error
(
"
FrameUtils
.
findFrameByLocation
only
supports
leaf
nodes
in
an
inverted
tree
.
"
)
;
}
let
calls
=
threadNode
.
calls
;
for
(
let
i
=
0
;
i
<
calls
.
length
;
i
+
+
)
{
if
(
calls
[
i
]
.
location
=
=
=
location
)
{
return
calls
[
i
]
;
}
}
return
null
;
}
exports
.
findFrameByLocation
=
findFrameByLocation
;
exports
.
computeIsContentAndCategory
=
computeIsContentAndCategory
;
exports
.
parseLocation
=
parseLocation
;
exports
.
getInflatedFrameCache
=
getInflatedFrameCache
;
exports
.
getOrAddInflatedFrame
=
getOrAddInflatedFrame
;
exports
.
InflatedFrame
=
InflatedFrame
;
exports
.
shouldDemangle
=
shouldDemangle
;
