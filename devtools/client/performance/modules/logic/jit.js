"
use
strict
"
;
const
SUCCESSFUL_OUTCOMES
=
[
"
GenericSuccess
"
"
Inlined
"
"
DOM
"
"
Monomorphic
"
"
Polymorphic
"
]
;
const
OptimizationSite
=
function
(
id
opts
)
{
this
.
id
=
id
;
this
.
data
=
opts
;
this
.
samples
=
1
;
}
;
const
JITOptimizations
=
function
(
rawSites
stringTable
)
{
let
sites
=
[
]
;
for
(
let
rawSite
of
rawSites
)
{
let
existingSite
=
sites
.
find
(
(
site
)
=
>
site
.
data
=
=
=
rawSite
)
;
if
(
existingSite
)
{
existingSite
.
samples
+
+
;
}
else
{
sites
.
push
(
new
OptimizationSite
(
sites
.
length
rawSite
)
)
;
}
}
for
(
let
site
of
sites
)
{
let
data
=
site
.
data
;
let
STRATEGY_SLOT
=
data
.
attempts
.
schema
.
strategy
;
let
OUTCOME_SLOT
=
data
.
attempts
.
schema
.
outcome
;
let
attempts
=
data
.
attempts
.
data
.
map
(
(
a
)
=
>
{
return
{
id
:
site
.
id
strategy
:
stringTable
[
a
[
STRATEGY_SLOT
]
]
outcome
:
stringTable
[
a
[
OUTCOME_SLOT
]
]
}
}
)
;
let
types
=
data
.
types
.
map
(
(
t
)
=
>
{
let
typeset
=
maybeTypeset
(
t
.
typeset
stringTable
)
;
if
(
typeset
)
{
typeset
.
forEach
(
t
=
>
t
.
id
=
site
.
id
)
;
}
return
{
id
:
site
.
id
typeset
site
:
stringTable
[
t
.
site
]
mirType
:
stringTable
[
t
.
mirType
]
}
;
}
)
;
attempts
.
id
=
types
.
id
=
site
.
id
;
site
.
data
=
{
attempts
types
propertyName
:
maybeString
(
stringTable
data
.
propertyName
)
line
:
data
.
line
column
:
data
.
column
}
;
}
this
.
optimizationSites
=
sites
.
sort
(
(
a
b
)
=
>
b
.
samples
-
a
.
samples
)
;
}
;
JITOptimizations
.
prototype
=
{
[
Symbol
.
iterator
]
:
function
*
(
)
{
yield
*
this
.
optimizationSites
;
}
get
length
(
)
{
return
this
.
optimizationSites
.
length
;
}
}
;
function
isSuccessfulOutcome
(
outcome
)
{
return
!
!
~
SUCCESSFUL_OUTCOMES
.
indexOf
(
outcome
)
;
}
;
function
hasSuccessfulOutcome
(
optimizationSite
)
{
let
attempts
=
optimizationSite
.
data
.
attempts
;
let
lastOutcome
=
attempts
[
attempts
.
length
-
1
]
.
outcome
;
return
isSuccessfulOutcome
(
lastOutcome
)
;
}
;
function
maybeString
(
stringTable
index
)
{
return
index
?
stringTable
[
index
]
:
undefined
;
}
function
maybeTypeset
(
typeset
stringTable
)
{
if
(
!
typeset
)
{
return
undefined
;
}
return
typeset
.
map
(
(
ty
)
=
>
{
return
{
keyedBy
:
maybeString
(
stringTable
ty
.
keyedBy
)
name
:
maybeString
(
stringTable
ty
.
name
)
location
:
maybeString
(
stringTable
ty
.
location
)
line
:
ty
.
line
}
;
}
)
;
}
const
IMPLEMENTATION_MAP
=
{
"
interpreter
"
:
0
"
baseline
"
:
1
"
ion
"
:
2
}
;
const
IMPLEMENTATION_NAMES
=
Object
.
keys
(
IMPLEMENTATION_MAP
)
;
function
createTierGraphDataFromFrameNode
(
frameNode
sampleTimes
bucketSize
)
{
let
tierData
=
frameNode
.
getTierData
(
)
;
let
stringTable
=
frameNode
.
_stringTable
;
let
output
=
[
]
;
let
implEnum
;
let
tierDataIndex
=
0
;
let
nextOptSample
=
tierData
[
tierDataIndex
]
;
let
samplesInCurrentBucket
=
0
;
let
currentBucketStartTime
=
sampleTimes
[
0
]
;
let
bucket
=
[
]
;
let
previousValues
;
for
(
let
i
=
0
;
i
<
=
sampleTimes
.
length
;
i
+
+
)
{
let
sampleTime
=
sampleTimes
[
i
]
;
if
(
sampleTime
>
=
(
currentBucketStartTime
+
bucketSize
)
|
|
i
>
=
sampleTimes
.
length
)
{
let
dataPoint
=
{
}
;
dataPoint
.
values
=
[
]
;
dataPoint
.
delta
=
currentBucketStartTime
;
for
(
let
j
=
0
;
j
<
IMPLEMENTATION_NAMES
.
length
;
j
+
+
)
{
dataPoint
.
values
[
j
]
=
(
bucket
[
j
]
|
|
0
)
/
(
samplesInCurrentBucket
|
|
1
)
;
}
if
(
previousValues
)
{
let
data
=
Object
.
create
(
null
)
;
data
.
values
=
previousValues
;
data
.
delta
=
currentBucketStartTime
;
output
.
push
(
data
)
;
}
output
.
push
(
dataPoint
)
;
currentBucketStartTime
+
=
bucketSize
;
samplesInCurrentBucket
=
0
;
previousValues
=
dataPoint
.
values
;
bucket
=
[
]
;
}
if
(
nextOptSample
&
&
nextOptSample
.
time
=
=
=
sampleTime
)
{
implEnum
=
IMPLEMENTATION_MAP
[
stringTable
[
nextOptSample
.
implementation
]
|
|
"
interpreter
"
]
;
bucket
[
implEnum
]
=
(
bucket
[
implEnum
]
|
|
0
)
+
1
;
nextOptSample
=
tierData
[
+
+
tierDataIndex
]
;
}
samplesInCurrentBucket
+
+
;
}
return
output
;
}
exports
.
createTierGraphDataFromFrameNode
=
createTierGraphDataFromFrameNode
;
exports
.
OptimizationSite
=
OptimizationSite
;
exports
.
JITOptimizations
=
JITOptimizations
;
exports
.
hasSuccessfulOutcome
=
hasSuccessfulOutcome
;
exports
.
isSuccessfulOutcome
=
isSuccessfulOutcome
;
exports
.
SUCCESSFUL_OUTCOMES
=
SUCCESSFUL_OUTCOMES
;
