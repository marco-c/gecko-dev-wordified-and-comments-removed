"
use
strict
"
;
const
{
JITOptimizations
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
jit
"
)
;
const
FrameUtils
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
frame
-
utils
"
)
;
function
ThreadNode
(
thread
options
=
{
}
)
{
if
(
options
.
endTime
=
=
void
0
|
|
options
.
startTime
=
=
void
0
)
{
throw
new
Error
(
"
ThreadNode
requires
both
startTime
and
endTime
.
"
)
;
}
this
.
samples
=
0
;
this
.
sampleTimes
=
[
]
;
this
.
youngestFrameSamples
=
0
;
this
.
calls
=
[
]
;
this
.
duration
=
options
.
endTime
-
options
.
startTime
;
this
.
nodeType
=
"
Thread
"
;
this
.
inverted
=
options
.
invertTree
;
this
.
byteSize
=
0
;
this
.
youngestFrameByteSize
=
0
;
const
{
samples
stackTable
frameTable
stringTable
}
=
thread
;
if
(
samples
.
data
.
length
=
=
=
0
)
{
return
;
}
this
.
_buildInverted
(
samples
stackTable
frameTable
stringTable
options
)
;
if
(
!
options
.
invertTree
)
{
this
.
_uninvert
(
)
;
}
}
ThreadNode
.
prototype
=
{
_buildInverted
:
function
buildInverted
(
samples
stackTable
frameTable
stringTable
options
)
{
function
getOrAddFrameNode
(
calls
isLeaf
frameKey
inflatedFrame
isMetaCategory
leafTable
)
{
let
frameNode
;
if
(
isLeaf
)
{
frameNode
=
leafTable
[
frameKey
]
;
}
else
{
for
(
let
i
=
0
;
i
<
calls
.
length
;
i
+
+
)
{
if
(
calls
[
i
]
.
key
=
=
=
frameKey
)
{
frameNode
=
calls
[
i
]
;
break
;
}
}
}
if
(
!
frameNode
)
{
frameNode
=
new
FrameNode
(
frameKey
inflatedFrame
isMetaCategory
)
;
if
(
isLeaf
)
{
leafTable
[
frameKey
]
=
frameNode
;
}
calls
.
push
(
frameNode
)
;
}
return
frameNode
;
}
const
SAMPLE_STACK_SLOT
=
samples
.
schema
.
stack
;
const
SAMPLE_TIME_SLOT
=
samples
.
schema
.
time
;
const
SAMPLE_BYTESIZE_SLOT
=
samples
.
schema
.
size
;
const
STACK_PREFIX_SLOT
=
stackTable
.
schema
.
prefix
;
const
STACK_FRAME_SLOT
=
stackTable
.
schema
.
frame
;
const
getOrAddInflatedFrame
=
FrameUtils
.
getOrAddInflatedFrame
;
const
samplesData
=
samples
.
data
;
const
stacksData
=
stackTable
.
data
;
const
inflatedFrameCache
=
FrameUtils
.
getInflatedFrameCache
(
frameTable
)
;
const
leafTable
=
Object
.
create
(
null
)
;
const
startTime
=
options
.
startTime
;
const
endTime
=
options
.
endTime
;
const
flattenRecursion
=
options
.
flattenRecursion
;
const
mutableFrameKeyOptions
=
{
contentOnly
:
options
.
contentOnly
isRoot
:
false
isLeaf
:
false
isMetaCategoryOut
:
false
}
;
let
byteSize
=
0
;
for
(
let
i
=
0
;
i
<
samplesData
.
length
;
i
+
+
)
{
const
sample
=
samplesData
[
i
]
;
const
sampleTime
=
sample
[
SAMPLE_TIME_SLOT
]
;
if
(
SAMPLE_BYTESIZE_SLOT
!
=
=
void
0
)
{
byteSize
=
sample
[
SAMPLE_BYTESIZE_SLOT
]
;
}
if
(
!
sampleTime
|
|
sampleTime
<
=
startTime
|
|
sampleTime
>
endTime
)
{
continue
;
}
let
stackIndex
=
sample
[
SAMPLE_STACK_SLOT
]
;
let
calls
=
this
.
calls
;
let
prevCalls
=
this
.
calls
;
let
prevFrameKey
;
let
isLeaf
=
mutableFrameKeyOptions
.
isLeaf
=
true
;
const
skipRoot
=
options
.
invertTree
;
while
(
stackIndex
!
=
=
null
)
{
const
stackEntry
=
stacksData
[
stackIndex
]
;
const
frameIndex
=
stackEntry
[
STACK_FRAME_SLOT
]
;
stackIndex
=
stackEntry
[
STACK_PREFIX_SLOT
]
;
if
(
stackIndex
=
=
=
null
&
&
skipRoot
)
{
break
;
}
const
inflatedFrame
=
getOrAddInflatedFrame
(
inflatedFrameCache
frameIndex
frameTable
stringTable
)
;
mutableFrameKeyOptions
.
isRoot
=
stackIndex
=
=
=
null
;
const
frameKey
=
inflatedFrame
.
getFrameKey
(
mutableFrameKeyOptions
)
;
if
(
frameKey
=
=
=
"
"
)
{
continue
;
}
const
shouldFlatten
=
flattenRecursion
&
&
frameKey
=
=
=
prevFrameKey
;
if
(
!
shouldFlatten
)
{
calls
=
prevCalls
;
}
const
frameNode
=
getOrAddFrameNode
(
calls
isLeaf
frameKey
inflatedFrame
mutableFrameKeyOptions
.
isMetaCategoryOut
leafTable
)
;
if
(
isLeaf
)
{
frameNode
.
youngestFrameSamples
+
+
;
frameNode
.
_addOptimizations
(
inflatedFrame
.
optimizations
inflatedFrame
.
implementation
sampleTime
stringTable
)
;
if
(
byteSize
)
{
frameNode
.
youngestFrameByteSize
+
=
byteSize
;
}
}
if
(
!
shouldFlatten
)
{
frameNode
.
samples
+
+
;
if
(
byteSize
)
{
frameNode
.
byteSize
+
=
byteSize
;
}
}
prevFrameKey
=
frameKey
;
prevCalls
=
frameNode
.
calls
;
isLeaf
=
mutableFrameKeyOptions
.
isLeaf
=
false
;
}
this
.
samples
+
+
;
this
.
sampleTimes
.
push
(
sampleTime
)
;
if
(
byteSize
)
{
this
.
byteSize
+
=
byteSize
;
}
}
}
_uninvert
:
function
uninvert
(
)
{
function
mergeOrAddFrameNode
(
calls
node
samples
size
)
{
for
(
let
i
=
0
;
i
<
calls
.
length
;
i
+
+
)
{
if
(
calls
[
i
]
.
key
=
=
=
node
.
key
)
{
const
foundNode
=
calls
[
i
]
;
foundNode
.
_merge
(
node
samples
size
)
;
return
foundNode
.
calls
;
}
}
const
copy
=
node
.
_clone
(
samples
size
)
;
calls
.
push
(
copy
)
;
return
copy
.
calls
;
}
const
workstack
=
[
{
node
:
this
level
:
0
}
]
;
const
spine
=
[
]
;
let
entry
;
const
rootCalls
=
[
]
;
do
{
entry
=
workstack
.
pop
(
)
;
if
(
entry
)
{
spine
[
entry
.
level
]
=
entry
;
const
node
=
entry
.
node
;
const
calls
=
node
.
calls
;
let
callSamples
=
0
;
let
callByteSize
=
0
;
for
(
let
i
=
0
;
i
<
calls
.
length
;
i
+
+
)
{
workstack
.
push
(
{
node
:
calls
[
i
]
level
:
entry
.
level
+
1
}
)
;
callSamples
+
=
calls
[
i
]
.
samples
;
callByteSize
+
=
calls
[
i
]
.
byteSize
;
}
const
samplesDelta
=
node
.
samples
-
callSamples
;
const
byteSizeDelta
=
node
.
byteSize
-
callByteSize
;
if
(
samplesDelta
>
0
)
{
let
uninvertedCalls
=
rootCalls
;
for
(
let
level
=
entry
.
level
;
level
>
0
;
level
-
-
)
{
const
callee
=
spine
[
level
]
;
uninvertedCalls
=
mergeOrAddFrameNode
(
uninvertedCalls
callee
.
node
samplesDelta
byteSizeDelta
)
;
}
}
}
}
while
(
entry
)
;
this
.
calls
=
rootCalls
;
}
getInfo
:
function
(
options
)
{
return
FrameUtils
.
getFrameInfo
(
this
options
)
;
}
hasOptimizations
:
function
(
)
{
return
null
;
}
}
;
function
FrameNode
(
frameKey
{
location
line
category
isContent
}
isMetaCategory
)
{
this
.
key
=
frameKey
;
this
.
location
=
location
;
this
.
line
=
line
;
this
.
youngestFrameSamples
=
0
;
this
.
samples
=
0
;
this
.
calls
=
[
]
;
this
.
isContent
=
!
!
isContent
;
this
.
_optimizations
=
null
;
this
.
_tierData
=
[
]
;
this
.
_stringTable
=
null
;
this
.
isMetaCategory
=
!
!
isMetaCategory
;
this
.
category
=
category
;
this
.
nodeType
=
"
Frame
"
;
this
.
byteSize
=
0
;
this
.
youngestFrameByteSize
=
0
;
}
FrameNode
.
prototype
=
{
_addOptimizations
:
function
(
site
implementation
time
stringTable
)
{
if
(
site
)
{
let
opts
=
this
.
_optimizations
;
if
(
opts
=
=
=
null
)
{
opts
=
this
.
_optimizations
=
[
]
;
}
opts
.
push
(
site
)
;
}
if
(
!
this
.
_stringTable
)
{
this
.
_stringTable
=
stringTable
;
}
this
.
_tierData
.
push
(
{
implementation
time
}
)
;
}
_clone
:
function
(
samples
size
)
{
const
newNode
=
new
FrameNode
(
this
.
key
this
this
.
isMetaCategory
)
;
newNode
.
_merge
(
this
samples
size
)
;
return
newNode
;
}
_merge
:
function
(
otherNode
samples
size
)
{
if
(
this
=
=
=
otherNode
)
{
return
;
}
this
.
samples
+
=
samples
;
this
.
byteSize
+
=
size
;
if
(
otherNode
.
youngestFrameSamples
>
0
)
{
this
.
youngestFrameSamples
+
=
samples
;
}
if
(
otherNode
.
youngestFrameByteSize
>
0
)
{
this
.
youngestFrameByteSize
+
=
otherNode
.
youngestFrameByteSize
;
}
if
(
this
.
_stringTable
=
=
=
null
)
{
this
.
_stringTable
=
otherNode
.
_stringTable
;
}
if
(
otherNode
.
_optimizations
)
{
if
(
!
this
.
_optimizations
)
{
this
.
_optimizations
=
[
]
;
}
const
opts
=
this
.
_optimizations
;
const
otherOpts
=
otherNode
.
_optimizations
;
for
(
let
i
=
0
;
i
<
otherOpts
.
length
;
i
+
+
)
{
opts
.
push
(
otherOpts
[
i
]
)
;
}
}
if
(
otherNode
.
_tierData
.
length
)
{
const
tierData
=
this
.
_tierData
;
const
otherTierData
=
otherNode
.
_tierData
;
for
(
let
i
=
0
;
i
<
otherTierData
.
length
;
i
+
+
)
{
tierData
.
push
(
otherTierData
[
i
]
)
;
}
tierData
.
sort
(
(
a
b
)
=
>
a
.
time
-
b
.
time
)
;
}
}
getInfo
:
function
(
options
)
{
return
FrameUtils
.
getFrameInfo
(
this
options
)
;
}
hasOptimizations
:
function
(
)
{
return
!
this
.
isMetaCategory
&
&
!
!
this
.
_optimizations
;
}
getOptimizations
:
function
(
)
{
if
(
!
this
.
_optimizations
)
{
return
null
;
}
return
new
JITOptimizations
(
this
.
_optimizations
this
.
_stringTable
)
;
}
getTierData
:
function
(
)
{
return
this
.
_tierData
;
}
}
;
exports
.
ThreadNode
=
ThreadNode
;
exports
.
FrameNode
=
FrameNode
;
