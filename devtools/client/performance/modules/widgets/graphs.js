"
use
strict
"
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
LineGraphWidget
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
LineGraphWidget
"
)
;
const
MountainGraphWidget
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
MountainGraphWidget
"
)
;
const
{
CanvasGraphUtils
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
Graphs
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
;
const
{
getColor
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
const
ProfilerGlobal
=
require
(
"
devtools
/
client
/
performance
/
modules
/
global
"
)
;
const
{
MarkersOverview
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
widgets
/
markers
-
overview
"
)
;
const
{
createTierGraphDataFromFrameNode
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
logic
/
jit
"
)
;
const
HEIGHT
=
35
;
const
STROKE_WIDTH
=
1
;
const
DAMPEN_VALUES
=
0
.
95
;
const
CLIPHEAD_LINE_COLOR
=
"
#
666
"
;
const
SELECTION_LINE_COLOR
=
"
#
555
"
;
const
SELECTION_BACKGROUND_COLOR_NAME
=
"
graphs
-
blue
"
;
const
FRAMERATE_GRAPH_COLOR_NAME
=
"
graphs
-
green
"
;
const
MEMORY_GRAPH_COLOR_NAME
=
"
graphs
-
blue
"
;
const
MARKERS_GRAPH_HEADER_HEIGHT
=
14
;
const
MARKERS_GRAPH_ROW_HEIGHT
=
10
;
const
MARKERS_GROUP_VERTICAL_PADDING
=
4
;
const
OPTIMIZATIONS_GRAPH_RESOLUTION
=
100
;
function
PerformanceGraph
(
parent
metric
)
{
LineGraphWidget
.
call
(
this
parent
{
metric
}
)
;
this
.
setTheme
(
)
;
}
PerformanceGraph
.
prototype
=
extend
(
LineGraphWidget
.
prototype
{
strokeWidth
:
STROKE_WIDTH
dampenValuesFactor
:
DAMPEN_VALUES
fixedHeight
:
HEIGHT
clipheadLineColor
:
CLIPHEAD_LINE_COLOR
selectionLineColor
:
SELECTION_LINE_COLOR
withTooltipArrows
:
false
withFixedTooltipPositions
:
true
clearView
:
function
(
)
{
this
.
selectionEnabled
=
false
;
this
.
dropSelection
(
)
;
this
.
setData
(
[
]
)
;
}
setTheme
:
function
(
theme
)
{
theme
=
theme
|
|
"
light
"
;
const
mainColor
=
getColor
(
this
.
mainColor
|
|
"
graphs
-
blue
"
theme
)
;
this
.
backgroundColor
=
getColor
(
"
body
-
background
"
theme
)
;
this
.
strokeColor
=
mainColor
;
this
.
backgroundGradientStart
=
colorUtils
.
setAlpha
(
mainColor
0
.
2
)
;
this
.
backgroundGradientEnd
=
colorUtils
.
setAlpha
(
mainColor
0
.
2
)
;
this
.
selectionBackgroundColor
=
colorUtils
.
setAlpha
(
getColor
(
SELECTION_BACKGROUND_COLOR_NAME
theme
)
0
.
25
)
;
this
.
selectionStripesColor
=
"
rgba
(
255
255
255
0
.
1
)
"
;
this
.
maximumLineColor
=
colorUtils
.
setAlpha
(
mainColor
0
.
4
)
;
this
.
averageLineColor
=
colorUtils
.
setAlpha
(
mainColor
0
.
7
)
;
this
.
minimumLineColor
=
colorUtils
.
setAlpha
(
mainColor
0
.
9
)
;
}
}
)
;
function
FramerateGraph
(
parent
)
{
PerformanceGraph
.
call
(
this
parent
ProfilerGlobal
.
L10N
.
getStr
(
"
graphs
.
fps
"
)
)
;
}
FramerateGraph
.
prototype
=
extend
(
PerformanceGraph
.
prototype
{
mainColor
:
FRAMERATE_GRAPH_COLOR_NAME
setPerformanceData
:
function
(
{
duration
ticks
}
resolution
)
{
this
.
dataDuration
=
duration
;
return
this
.
setDataFromTimestamps
(
ticks
resolution
duration
)
;
}
}
)
;
function
MemoryGraph
(
parent
)
{
PerformanceGraph
.
call
(
this
parent
ProfilerGlobal
.
L10N
.
getStr
(
"
graphs
.
memory
"
)
)
;
}
MemoryGraph
.
prototype
=
extend
(
PerformanceGraph
.
prototype
{
mainColor
:
MEMORY_GRAPH_COLOR_NAME
setPerformanceData
:
function
(
{
duration
memory
}
)
{
this
.
dataDuration
=
duration
;
return
this
.
setData
(
memory
)
;
}
}
)
;
function
TimelineGraph
(
parent
filter
)
{
MarkersOverview
.
call
(
this
parent
filter
)
;
}
TimelineGraph
.
prototype
=
extend
(
MarkersOverview
.
prototype
{
headerHeight
:
MARKERS_GRAPH_HEADER_HEIGHT
rowHeight
:
MARKERS_GRAPH_ROW_HEIGHT
groupPadding
:
MARKERS_GROUP_VERTICAL_PADDING
setPerformanceData
:
MarkersOverview
.
prototype
.
setData
}
)
;
const
GRAPH_DEFINITIONS
=
{
memory
:
{
constructor
:
MemoryGraph
selector
:
"
#
memory
-
overview
"
}
framerate
:
{
constructor
:
FramerateGraph
selector
:
"
#
time
-
framerate
"
}
timeline
:
{
constructor
:
TimelineGraph
selector
:
"
#
markers
-
overview
"
primaryLink
:
true
}
}
;
function
GraphsController
(
{
definition
root
getFilter
getTheme
}
)
{
this
.
_graphs
=
{
}
;
this
.
_enabled
=
new
Set
(
)
;
this
.
_definition
=
definition
|
|
GRAPH_DEFINITIONS
;
this
.
_root
=
root
;
this
.
_getFilter
=
getFilter
;
this
.
_getTheme
=
getTheme
;
this
.
_primaryLink
=
Object
.
keys
(
this
.
_definition
)
.
filter
(
name
=
>
this
.
_definition
[
name
]
.
primaryLink
)
[
0
]
;
this
.
=
root
.
ownerDocument
.
querySelector
.
bind
(
root
.
ownerDocument
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
_onSelecting
=
this
.
_onSelecting
.
bind
(
this
)
;
}
GraphsController
.
prototype
=
{
get
:
function
(
graphName
)
{
return
this
.
_graphs
[
graphName
]
;
}
async
render
(
recordingData
resolution
)
{
await
this
.
_rendering
;
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_rendering
=
new
Promise
(
async
resolve
=
>
{
for
(
const
graph
of
await
this
.
_getEnabled
(
)
)
{
await
graph
.
setPerformanceData
(
recordingData
resolution
)
;
this
.
emit
(
"
rendered
"
graph
.
graphName
)
;
}
resolve
(
)
;
}
)
;
await
this
.
_rendering
;
}
async
destroy
(
)
{
const
primary
=
this
.
_getPrimaryLink
(
)
;
this
.
_destroyed
=
true
;
if
(
primary
)
{
primary
.
off
(
"
selecting
"
this
.
_onSelecting
)
;
}
if
(
this
.
_rendering
)
{
await
this
.
_rendering
;
}
for
(
const
graph
of
this
.
getWidgets
(
)
)
{
await
graph
.
destroy
(
)
;
}
}
setTheme
:
function
(
options
=
{
}
)
{
const
theme
=
options
.
theme
|
|
this
.
_getTheme
(
)
;
for
(
const
graph
of
this
.
getWidgets
(
)
)
{
graph
.
setTheme
(
theme
)
;
graph
.
refresh
(
{
force
:
options
.
redraw
}
)
;
}
}
async
isAvailable
(
graphName
)
{
if
(
!
this
.
_enabled
.
has
(
graphName
)
)
{
return
null
;
}
let
graph
=
this
.
get
(
graphName
)
;
if
(
!
graph
)
{
graph
=
await
this
.
_construct
(
graphName
)
;
}
await
graph
.
ready
(
)
;
return
graph
;
}
enable
:
function
(
graphName
isEnabled
)
{
const
el
=
this
.
(
this
.
_definition
[
graphName
]
.
selector
)
;
el
.
classList
[
isEnabled
?
"
remove
"
:
"
add
"
]
(
"
hidden
"
)
;
if
(
this
.
_enabled
.
has
(
graphName
)
=
=
=
isEnabled
)
{
return
;
}
if
(
isEnabled
)
{
this
.
_enabled
.
add
(
graphName
)
;
}
else
{
this
.
_enabled
.
delete
(
graphName
)
;
}
this
.
_enabledGraphs
=
null
;
}
disableAll
:
function
(
)
{
this
.
_root
.
classList
.
add
(
"
hidden
"
)
;
Object
.
keys
(
this
.
_definition
)
.
forEach
(
graphName
=
>
this
.
enable
(
graphName
false
)
)
;
}
setMappedSelection
:
function
(
selection
{
mapStart
mapEnd
}
)
{
return
this
.
_getPrimaryLink
(
)
.
setMappedSelection
(
selection
{
mapStart
mapEnd
}
)
;
}
getMappedSelection
:
function
(
{
mapStart
mapEnd
}
)
{
const
primary
=
this
.
_getPrimaryLink
(
)
;
if
(
primary
&
&
primary
.
hasData
(
)
)
{
return
primary
.
getMappedSelection
(
{
mapStart
mapEnd
}
)
;
}
return
null
;
}
getWidgets
:
function
(
)
{
return
Object
.
keys
(
this
.
_graphs
)
.
map
(
name
=
>
this
.
_graphs
[
name
]
)
;
}
dropSelection
:
function
(
)
{
if
(
this
.
_getPrimaryLink
(
)
)
{
return
this
.
_getPrimaryLink
(
)
.
dropSelection
(
)
;
}
return
null
;
}
async
selectionEnabled
(
enabled
)
{
for
(
const
graph
of
await
this
.
_getEnabled
(
)
)
{
graph
.
selectionEnabled
=
enabled
;
}
}
async
_construct
(
graphName
)
{
const
def
=
this
.
_definition
[
graphName
]
;
const
el
=
this
.
(
def
.
selector
)
;
const
filter
=
this
.
_getFilter
(
)
;
const
graph
=
(
this
.
_graphs
[
graphName
]
=
new
def
.
constructor
(
el
filter
)
)
;
graph
.
graphName
=
graphName
;
await
graph
.
ready
(
)
;
if
(
def
.
primaryLink
)
{
graph
.
on
(
"
selecting
"
this
.
_onSelecting
)
;
}
else
{
CanvasGraphUtils
.
linkAnimation
(
this
.
_getPrimaryLink
(
)
graph
)
;
CanvasGraphUtils
.
linkSelection
(
this
.
_getPrimaryLink
(
)
graph
)
;
}
el
.
classList
[
this
.
_enabled
.
has
(
graphName
)
?
"
remove
"
:
"
add
"
]
(
"
hidden
"
)
;
this
.
setTheme
(
)
;
return
graph
;
}
_getPrimaryLink
:
function
(
)
{
return
this
.
get
(
this
.
_primaryLink
)
;
}
_onSelecting
:
function
(
)
{
this
.
emit
(
"
selecting
"
)
;
}
async
_getEnabled
(
)
{
if
(
this
.
_enabledGraphs
)
{
return
this
.
_enabledGraphs
;
}
const
enabled
=
[
]
;
for
(
const
graphName
of
this
.
_enabled
)
{
const
graph
=
await
this
.
isAvailable
(
graphName
)
;
if
(
graph
)
{
enabled
.
push
(
graph
)
;
}
}
this
.
_enabledGraphs
=
enabled
;
return
this
.
_enabledGraphs
;
}
}
;
function
OptimizationsGraph
(
parent
)
{
MountainGraphWidget
.
call
(
this
parent
)
;
this
.
setTheme
(
)
;
}
OptimizationsGraph
.
prototype
=
extend
(
MountainGraphWidget
.
prototype
{
async
render
(
threadNode
frameNode
)
{
await
this
.
ready
(
)
;
if
(
!
threadNode
|
|
!
frameNode
)
{
this
.
setData
(
[
]
)
;
return
;
}
const
{
sampleTimes
}
=
threadNode
;
if
(
!
sampleTimes
.
length
)
{
this
.
setData
(
[
]
)
;
return
;
}
const
startTime
=
sampleTimes
[
0
]
;
const
endTime
=
sampleTimes
[
sampleTimes
.
length
-
1
]
;
const
bucketSize
=
(
endTime
-
startTime
)
/
OPTIMIZATIONS_GRAPH_RESOLUTION
;
const
data
=
createTierGraphDataFromFrameNode
(
frameNode
sampleTimes
bucketSize
)
;
if
(
!
data
)
{
console
.
error
(
FrameNode
#
{
frameNode
.
location
}
does
not
have
optimizations
data
to
render
.
)
;
return
;
}
this
.
dataOffsetX
=
startTime
;
await
this
.
setData
(
data
)
;
}
setTheme
:
function
(
theme
)
{
theme
=
theme
|
|
"
light
"
;
const
interpreterColor
=
getColor
(
"
graphs
-
red
"
theme
)
;
const
baselineColor
=
getColor
(
"
graphs
-
blue
"
theme
)
;
const
ionColor
=
getColor
(
"
graphs
-
green
"
theme
)
;
this
.
format
=
[
{
color
:
interpreterColor
}
{
color
:
baselineColor
}
{
color
:
ionColor
}
]
;
this
.
backgroundColor
=
getColor
(
"
sidebar
-
background
"
theme
)
;
}
}
)
;
exports
.
OptimizationsGraph
=
OptimizationsGraph
;
exports
.
FramerateGraph
=
FramerateGraph
;
exports
.
MemoryGraph
=
MemoryGraph
;
exports
.
TimelineGraph
=
TimelineGraph
;
exports
.
GraphsController
=
GraphsController
;
