"
use
strict
"
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
AbstractCanvasGraph
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
Graphs
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
;
const
{
getColor
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
const
ProfilerGlobal
=
require
(
"
devtools
/
client
/
performance
/
modules
/
global
"
)
;
const
{
MarkerBlueprintUtils
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
marker
-
blueprint
-
utils
"
)
;
const
{
TickUtils
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
waterfall
-
ticks
"
)
;
const
{
TIMELINE_BLUEPRINT
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
markers
"
)
;
const
OVERVIEW_HEADER_HEIGHT
=
14
;
const
OVERVIEW_ROW_HEIGHT
=
11
;
const
OVERVIEW_SELECTION_LINE_COLOR
=
"
#
666
"
;
const
OVERVIEW_CLIPHEAD_LINE_COLOR
=
"
#
555
"
;
const
OVERVIEW_HEADER_TICKS_MULTIPLE
=
100
;
const
OVERVIEW_HEADER_TICKS_SPACING_MIN
=
75
;
const
OVERVIEW_HEADER_TEXT_FONT_SIZE
=
9
;
const
OVERVIEW_HEADER_TEXT_FONT_FAMILY
=
"
sans
-
serif
"
;
const
OVERVIEW_HEADER_TEXT_PADDING_LEFT
=
6
;
const
OVERVIEW_HEADER_TEXT_PADDING_TOP
=
1
;
const
OVERVIEW_MARKER_WIDTH_MIN
=
4
;
const
OVERVIEW_GROUP_VERTICAL_PADDING
=
5
;
function
MarkersOverview
(
parent
filter
=
[
]
.
.
.
args
)
{
AbstractCanvasGraph
.
apply
(
this
[
parent
"
markers
-
overview
"
.
.
.
args
]
)
;
this
.
setTheme
(
)
;
this
.
setFilter
(
filter
)
;
}
MarkersOverview
.
prototype
=
extend
(
AbstractCanvasGraph
.
prototype
{
clipheadLineColor
:
OVERVIEW_CLIPHEAD_LINE_COLOR
selectionLineColor
:
OVERVIEW_SELECTION_LINE_COLOR
headerHeight
:
OVERVIEW_HEADER_HEIGHT
rowHeight
:
OVERVIEW_ROW_HEIGHT
groupPadding
:
OVERVIEW_GROUP_VERTICAL_PADDING
get
fixedHeight
(
)
{
return
this
.
headerHeight
+
this
.
rowHeight
*
this
.
_numberOfGroups
;
}
setFilter
:
function
(
filter
)
{
this
.
_paintBatches
=
new
Map
(
)
;
this
.
_filter
=
filter
;
this
.
_groupMap
=
Object
.
create
(
null
)
;
const
observedGroups
=
new
Set
(
)
;
for
(
const
type
in
TIMELINE_BLUEPRINT
)
{
if
(
filter
.
includes
(
type
)
)
{
continue
;
}
this
.
_paintBatches
.
set
(
type
{
definition
:
TIMELINE_BLUEPRINT
[
type
]
batch
:
[
]
}
)
;
observedGroups
.
add
(
TIMELINE_BLUEPRINT
[
type
]
.
group
)
;
}
let
actualPosition
=
0
;
for
(
const
groupNumber
of
Array
.
from
(
observedGroups
)
.
sort
(
)
)
{
this
.
_groupMap
[
groupNumber
]
=
actualPosition
+
+
;
}
this
.
_numberOfGroups
=
Object
.
keys
(
this
.
_groupMap
)
.
length
;
}
clearView
:
function
(
)
{
this
.
selectionEnabled
=
false
;
this
.
dropSelection
(
)
;
this
.
setData
(
{
duration
:
0
markers
:
[
]
}
)
;
}
buildGraphImage
:
function
(
)
{
const
{
markers
duration
}
=
this
.
_data
;
const
{
canvas
ctx
}
=
this
.
_getNamedCanvas
(
"
markers
-
overview
-
data
"
)
;
const
canvasWidth
=
this
.
_width
;
const
canvasHeight
=
this
.
_height
;
for
(
const
marker
of
markers
)
{
if
(
!
MarkerBlueprintUtils
.
shouldDisplayMarker
(
marker
this
.
_filter
)
)
{
continue
;
}
const
markerType
=
this
.
_paintBatches
.
get
(
marker
.
name
)
|
|
this
.
_paintBatches
.
get
(
"
UNKNOWN
"
)
;
markerType
.
batch
.
push
(
marker
)
;
}
const
groupHeight
=
this
.
rowHeight
*
this
.
_pixelRatio
;
const
groupPadding
=
this
.
groupPadding
*
this
.
_pixelRatio
;
const
headerHeight
=
this
.
headerHeight
*
this
.
_pixelRatio
;
const
dataScale
=
(
this
.
dataScaleX
=
canvasWidth
/
duration
)
;
ctx
.
fillStyle
=
this
.
headerBackgroundColor
;
ctx
.
fillRect
(
0
0
canvasWidth
headerHeight
)
;
ctx
.
fillStyle
=
this
.
backgroundColor
;
ctx
.
fillRect
(
0
headerHeight
canvasWidth
canvasHeight
)
;
ctx
.
fillStyle
=
this
.
alternatingBackgroundColor
;
ctx
.
beginPath
(
)
;
for
(
let
i
=
0
;
i
<
this
.
_numberOfGroups
;
i
+
=
2
)
{
const
top
=
headerHeight
+
i
*
groupHeight
;
ctx
.
rect
(
0
top
canvasWidth
groupHeight
)
;
}
ctx
.
fill
(
)
;
const
fontSize
=
OVERVIEW_HEADER_TEXT_FONT_SIZE
*
this
.
_pixelRatio
;
const
fontFamily
=
OVERVIEW_HEADER_TEXT_FONT_FAMILY
;
const
textPaddingLeft
=
OVERVIEW_HEADER_TEXT_PADDING_LEFT
*
this
.
_pixelRatio
;
const
textPaddingTop
=
OVERVIEW_HEADER_TEXT_PADDING_TOP
*
this
.
_pixelRatio
;
const
tickInterval
=
TickUtils
.
findOptimalTickInterval
(
{
ticksMultiple
:
OVERVIEW_HEADER_TICKS_MULTIPLE
ticksSpacingMin
:
OVERVIEW_HEADER_TICKS_SPACING_MIN
dataScale
:
dataScale
}
)
;
ctx
.
textBaseline
=
"
middle
"
;
ctx
.
font
=
fontSize
+
"
px
"
+
fontFamily
;
ctx
.
fillStyle
=
this
.
headerTextColor
;
ctx
.
strokeStyle
=
this
.
headerTimelineStrokeColor
;
ctx
.
beginPath
(
)
;
for
(
let
x
=
0
;
x
<
canvasWidth
;
x
+
=
tickInterval
)
{
const
lineLeft
=
x
;
const
textLeft
=
lineLeft
+
textPaddingLeft
;
const
time
=
Math
.
round
(
x
/
dataScale
)
;
const
label
=
ProfilerGlobal
.
L10N
.
getFormatStr
(
"
timeline
.
tick
"
time
)
;
ctx
.
fillText
(
label
textLeft
headerHeight
/
2
+
textPaddingTop
)
;
ctx
.
moveTo
(
lineLeft
0
)
;
ctx
.
lineTo
(
lineLeft
canvasHeight
)
;
}
ctx
.
stroke
(
)
;
for
(
const
[
{
definition
batch
}
]
of
this
.
_paintBatches
)
{
const
group
=
this
.
_groupMap
[
definition
.
group
]
;
const
top
=
headerHeight
+
group
*
groupHeight
+
groupPadding
/
2
;
const
height
=
groupHeight
-
groupPadding
;
const
color
=
getColor
(
definition
.
colorName
this
.
theme
)
;
ctx
.
fillStyle
=
color
;
ctx
.
beginPath
(
)
;
for
(
const
{
start
end
}
of
batch
)
{
const
left
=
start
*
dataScale
;
const
width
=
Math
.
max
(
(
end
-
start
)
*
dataScale
OVERVIEW_MARKER_WIDTH_MIN
)
;
ctx
.
rect
(
left
top
width
height
)
;
}
ctx
.
fill
(
)
;
batch
.
length
=
0
;
}
return
canvas
;
}
setTheme
:
function
(
theme
)
{
this
.
theme
=
theme
=
theme
|
|
"
light
"
;
this
.
backgroundColor
=
getColor
(
"
body
-
background
"
theme
)
;
this
.
selectionBackgroundColor
=
colorUtils
.
setAlpha
(
getColor
(
"
selection
-
background
"
theme
)
0
.
25
)
;
this
.
selectionStripesColor
=
colorUtils
.
setAlpha
(
"
#
fff
"
0
.
1
)
;
this
.
headerBackgroundColor
=
getColor
(
"
body
-
background
"
theme
)
;
this
.
headerTextColor
=
getColor
(
"
body
-
color
"
theme
)
;
this
.
headerTimelineStrokeColor
=
colorUtils
.
setAlpha
(
getColor
(
"
text
-
color
-
alt
"
theme
)
0
.
25
)
;
this
.
alternatingBackgroundColor
=
colorUtils
.
setAlpha
(
getColor
(
"
body
-
color
"
theme
)
0
.
05
)
;
}
}
)
;
exports
.
MarkersOverview
=
MarkersOverview
;
