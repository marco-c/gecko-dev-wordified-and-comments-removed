"
use
strict
"
;
const
{
L10N
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
global
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
AbstractTreeItem
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
AbstractTreeItem
.
jsm
"
)
;
const
URL_LABEL_TOOLTIP
=
L10N
.
getStr
(
"
table
.
url
.
tooltiptext
"
)
;
const
VIEW_OPTIMIZATIONS_TOOLTIP
=
L10N
.
getStr
(
"
table
.
view
-
optimizations
.
tooltiptext2
"
)
;
const
CALL_TREE_INDENTATION
=
16
;
const
FORMATTERS
=
{
TIME
:
value
=
>
L10N
.
getFormatStr
(
"
table
.
ms2
"
L10N
.
numberWithDecimals
(
value
2
)
)
PERCENT
:
value
=
>
L10N
.
getFormatStr
(
"
table
.
percentage3
"
L10N
.
numberWithDecimals
(
value
2
)
)
NUMBER
:
value
=
>
value
|
|
0
BYTESIZE
:
value
=
>
L10N
.
getFormatStr
(
"
table
.
bytes
"
value
|
|
0
)
}
;
const
CELLS
=
{
duration
:
[
"
duration
"
"
totalDuration
"
FORMATTERS
.
TIME
]
percentage
:
[
"
percentage
"
"
totalPercentage
"
FORMATTERS
.
PERCENT
]
selfDuration
:
[
"
self
-
duration
"
"
selfDuration
"
FORMATTERS
.
TIME
]
selfPercentage
:
[
"
self
-
percentage
"
"
selfPercentage
"
FORMATTERS
.
PERCENT
]
samples
:
[
"
samples
"
"
samples
"
FORMATTERS
.
NUMBER
]
selfSize
:
[
"
self
-
size
"
"
selfSize
"
FORMATTERS
.
BYTESIZE
]
selfSizePercentage
:
[
"
self
-
size
-
percentage
"
"
selfSizePercentage
"
FORMATTERS
.
PERCENT
]
selfCount
:
[
"
self
-
count
"
"
selfCount
"
FORMATTERS
.
NUMBER
]
selfCountPercentage
:
[
"
self
-
count
-
percentage
"
"
selfCountPercentage
"
FORMATTERS
.
PERCENT
]
size
:
[
"
size
"
"
totalSize
"
FORMATTERS
.
BYTESIZE
]
sizePercentage
:
[
"
size
-
percentage
"
"
totalSizePercentage
"
FORMATTERS
.
PERCENT
]
count
:
[
"
count
"
"
totalCount
"
FORMATTERS
.
NUMBER
]
countPercentage
:
[
"
count
-
percentage
"
"
totalCountPercentage
"
FORMATTERS
.
PERCENT
]
}
;
const
CELL_TYPES
=
Object
.
keys
(
CELLS
)
;
const
DEFAULT_SORTING_PREDICATE
=
(
frameA
frameB
)
=
>
{
const
dataA
=
frameA
.
getDisplayedData
(
)
;
const
dataB
=
frameB
.
getDisplayedData
(
)
;
const
isAllocations
=
"
totalSize
"
in
dataA
;
if
(
isAllocations
)
{
if
(
this
.
inverted
&
&
dataA
.
selfSize
!
=
=
dataB
.
selfSize
)
{
return
dataA
.
selfSize
<
dataB
.
selfSize
?
1
:
-
1
;
}
return
dataA
.
totalSize
<
dataB
.
totalSize
?
1
:
-
1
;
}
if
(
this
.
inverted
&
&
dataA
.
selfPercentage
!
=
=
dataB
.
selfPercentage
)
{
return
dataA
.
selfPercentage
<
dataB
.
selfPercentage
?
1
:
-
1
;
}
return
dataA
.
totalPercentage
<
dataB
.
totalPercentage
?
1
:
-
1
;
}
;
const
DEFAULT_AUTO_EXPAND_DEPTH
=
3
;
const
DEFAULT_VISIBLE_CELLS
=
{
duration
:
true
percentage
:
true
selfDuration
:
true
selfPercentage
:
true
samples
:
true
function
:
true
count
:
false
selfCount
:
false
size
:
false
selfSize
:
false
countPercentage
:
false
selfCountPercentage
:
false
sizePercentage
:
false
selfSizePercentage
:
false
}
;
function
CallView
(
{
caller
frame
level
hidden
inverted
sortingPredicate
autoExpandDepth
visibleCells
showOptimizationHint
}
)
{
AbstractTreeItem
.
call
(
this
{
parent
:
caller
level
:
level
|
(
0
-
(
hidden
?
1
:
0
)
)
}
)
;
if
(
sortingPredicate
!
=
null
)
{
this
.
sortingPredicate
=
sortingPredicate
;
}
else
if
(
caller
)
{
this
.
sortingPredicate
=
caller
.
sortingPredicate
;
}
else
{
this
.
sortingPredicate
=
DEFAULT_SORTING_PREDICATE
;
}
if
(
autoExpandDepth
!
=
null
)
{
this
.
autoExpandDepth
=
autoExpandDepth
;
}
else
if
(
caller
)
{
this
.
autoExpandDepth
=
caller
.
autoExpandDepth
;
}
else
{
this
.
autoExpandDepth
=
DEFAULT_AUTO_EXPAND_DEPTH
;
}
if
(
visibleCells
!
=
null
)
{
this
.
visibleCells
=
visibleCells
;
}
else
if
(
caller
)
{
this
.
visibleCells
=
caller
.
visibleCells
;
}
else
{
this
.
visibleCells
=
Object
.
create
(
DEFAULT_VISIBLE_CELLS
)
;
}
this
.
caller
=
caller
;
this
.
frame
=
frame
;
this
.
hidden
=
hidden
;
this
.
inverted
=
inverted
;
this
.
showOptimizationHint
=
showOptimizationHint
;
this
.
_onUrlClick
=
this
.
_onUrlClick
.
bind
(
this
)
;
}
CallView
.
prototype
=
extend
(
AbstractTreeItem
.
prototype
{
_displaySelf
:
function
(
document
arrowNode
)
{
const
frameInfo
=
this
.
getDisplayedData
(
)
;
const
cells
=
[
]
;
for
(
const
type
of
CELL_TYPES
)
{
if
(
this
.
visibleCells
[
type
]
)
{
cells
.
push
(
this
.
_createCell
(
document
CELLS
[
type
]
[
2
]
(
frameInfo
[
CELLS
[
type
]
[
1
]
]
)
CELLS
[
type
]
[
0
]
)
)
;
}
}
if
(
this
.
visibleCells
.
function
)
{
cells
.
push
(
this
.
_createFunctionCell
(
document
arrowNode
frameInfo
.
name
frameInfo
this
.
level
)
)
;
}
const
targetNode
=
document
.
createXULElement
(
"
hbox
"
)
;
targetNode
.
className
=
"
call
-
tree
-
item
"
;
targetNode
.
setAttribute
(
"
origin
"
frameInfo
.
isContent
?
"
content
"
:
"
chrome
"
)
;
targetNode
.
setAttribute
(
"
category
"
frameInfo
.
categoryData
.
abbrev
|
|
"
"
)
;
targetNode
.
setAttribute
(
"
tooltiptext
"
frameInfo
.
tooltiptext
)
;
if
(
this
.
hidden
)
{
targetNode
.
style
.
display
=
"
none
"
;
}
for
(
let
i
=
0
;
i
<
cells
.
length
;
i
+
+
)
{
targetNode
.
appendChild
(
cells
[
i
]
)
;
}
return
targetNode
;
}
_populateSelf
:
function
(
children
)
{
const
newLevel
=
this
.
level
+
1
;
for
(
const
newFrame
of
this
.
frame
.
calls
)
{
children
.
push
(
new
CallView
(
{
caller
:
this
frame
:
newFrame
level
:
newLevel
inverted
:
this
.
inverted
}
)
)
;
}
children
.
sort
(
this
.
sortingPredicate
.
bind
(
this
)
)
;
}
_createCell
:
function
(
doc
value
type
)
{
const
cell
=
doc
.
createXULElement
(
"
description
"
)
;
cell
.
className
=
"
plain
call
-
tree
-
cell
"
;
cell
.
setAttribute
(
"
type
"
type
)
;
cell
.
setAttribute
(
"
crop
"
"
end
"
)
;
cell
.
textContent
=
value
+
"
\
t
"
;
return
cell
;
}
_createFunctionCell
:
function
(
doc
arrowNode
frameName
frameInfo
frameLevel
)
{
const
cell
=
doc
.
createXULElement
(
"
hbox
"
)
;
cell
.
className
=
"
call
-
tree
-
cell
"
;
cell
.
style
.
marginInlineStart
=
frameLevel
*
CALL_TREE_INDENTATION
+
"
px
"
;
cell
.
setAttribute
(
"
type
"
"
function
"
)
;
cell
.
appendChild
(
arrowNode
)
;
if
(
this
.
root
.
showOptimizationHint
&
&
frameInfo
.
hasOptimizations
&
&
!
frameInfo
.
isMetaCategory
)
{
const
icon
=
doc
.
createXULElement
(
"
description
"
)
;
icon
.
setAttribute
(
"
tooltiptext
"
VIEW_OPTIMIZATIONS_TOOLTIP
)
;
icon
.
className
=
"
opt
-
icon
"
;
cell
.
appendChild
(
icon
)
;
}
if
(
frameName
)
{
const
nameNode
=
doc
.
createXULElement
(
"
description
"
)
;
nameNode
.
className
=
"
plain
call
-
tree
-
name
"
;
nameNode
.
textContent
=
frameName
;
cell
.
appendChild
(
nameNode
)
;
}
if
(
!
frameInfo
.
isMetaCategory
)
{
this
.
_appendFunctionDetailsCells
(
doc
cell
frameInfo
)
;
}
const
hasDescendants
=
Object
.
keys
(
this
.
frame
.
calls
)
.
length
>
0
;
if
(
!
hasDescendants
)
{
arrowNode
.
setAttribute
(
"
invisible
"
"
"
)
;
}
const
lastDescription
=
cell
.
querySelector
(
"
description
:
last
-
of
-
type
"
)
;
lastDescription
.
textContent
=
lastDescription
.
textContent
+
"
\
n
"
;
const
firstDescription
=
cell
.
querySelector
(
"
description
:
first
-
of
-
type
"
)
;
const
levelIndicator
=
frameLevel
>
0
?
"
"
.
repeat
(
frameLevel
)
:
"
"
;
firstDescription
.
textContent
=
levelIndicator
+
firstDescription
.
textContent
;
return
cell
;
}
_appendFunctionDetailsCells
:
function
(
doc
cell
frameInfo
)
{
if
(
frameInfo
.
fileName
)
{
const
urlNode
=
doc
.
createXULElement
(
"
description
"
)
;
urlNode
.
className
=
"
plain
call
-
tree
-
url
"
;
urlNode
.
textContent
=
frameInfo
.
fileName
;
urlNode
.
setAttribute
(
"
tooltiptext
"
URL_LABEL_TOOLTIP
+
"
"
+
frameInfo
.
url
)
;
urlNode
.
addEventListener
(
"
mousedown
"
this
.
_onUrlClick
)
;
cell
.
appendChild
(
urlNode
)
;
}
if
(
frameInfo
.
line
)
{
const
lineNode
=
doc
.
createXULElement
(
"
description
"
)
;
lineNode
.
className
=
"
plain
call
-
tree
-
line
"
;
lineNode
.
textContent
=
"
:
"
+
frameInfo
.
line
;
cell
.
appendChild
(
lineNode
)
;
}
if
(
frameInfo
.
column
)
{
const
columnNode
=
doc
.
createXULElement
(
"
description
"
)
;
columnNode
.
className
=
"
plain
call
-
tree
-
column
"
;
columnNode
.
textContent
=
"
:
"
+
frameInfo
.
column
;
cell
.
appendChild
(
columnNode
)
;
}
if
(
frameInfo
.
host
)
{
const
hostNode
=
doc
.
createXULElement
(
"
description
"
)
;
hostNode
.
className
=
"
plain
call
-
tree
-
host
"
;
hostNode
.
textContent
=
frameInfo
.
host
;
cell
.
appendChild
(
hostNode
)
;
}
if
(
frameInfo
.
categoryData
.
label
)
{
const
categoryNode
=
doc
.
createXULElement
(
"
description
"
)
;
categoryNode
.
className
=
"
plain
call
-
tree
-
category
"
;
categoryNode
.
style
.
color
=
frameInfo
.
categoryData
.
color
;
categoryNode
.
textContent
=
frameInfo
.
categoryData
.
label
;
cell
.
appendChild
(
categoryNode
)
;
}
}
getDisplayedData
:
function
(
)
{
if
(
this
.
_cachedDisplayedData
)
{
return
this
.
_cachedDisplayedData
;
}
this
.
_cachedDisplayedData
=
this
.
frame
.
getInfo
(
{
root
:
this
.
root
.
frame
allocations
:
this
.
visibleCells
.
count
|
|
this
.
visibleCells
.
selfCount
}
)
;
return
this
.
_cachedDisplayedData
;
}
toggleCategories
:
function
(
visible
)
{
if
(
!
visible
)
{
this
.
container
.
setAttribute
(
"
categories
-
hidden
"
"
"
)
;
}
else
{
this
.
container
.
removeAttribute
(
"
categories
-
hidden
"
)
;
}
}
_onUrlClick
:
function
(
e
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
button
=
=
=
0
)
{
this
.
root
.
emit
(
"
link
"
this
)
;
}
}
}
)
;
exports
.
CallView
=
CallView
;
