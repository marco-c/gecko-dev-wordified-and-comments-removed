"
use
strict
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
WATERFALL_BACKGROUND_TICKS_MULTIPLE
=
5
;
const
WATERFALL_BACKGROUND_TICKS_SCALES
=
3
;
const
WATERFALL_BACKGROUND_TICKS_SPACING_MIN
=
10
;
const
WATERFALL_BACKGROUND_TICKS_COLOR_RGB
=
[
128
136
144
]
;
const
WATERFALL_BACKGROUND_TICKS_OPACITY_MIN
=
32
;
const
WATERFALL_BACKGROUND_TICKS_OPACITY_ADD
=
32
;
const
FIND_OPTIMAL_TICK_INTERVAL_MAX_ITERS
=
100
;
function
drawWaterfallBackground
(
doc
dataScale
waterfallWidth
)
{
const
canvas
=
doc
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
const
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
const
canvasWidth
=
(
canvas
.
width
=
Math
.
max
(
waterfallWidth
1
)
)
;
const
canvasHeight
=
(
canvas
.
height
=
1
)
;
const
imageData
=
ctx
.
createImageData
(
canvasWidth
canvasHeight
)
;
const
pixelArray
=
imageData
.
data
;
const
buf
=
new
ArrayBuffer
(
pixelArray
.
length
)
;
const
view8bit
=
new
Uint8ClampedArray
(
buf
)
;
const
view32bit
=
new
Uint32Array
(
buf
)
;
const
[
r
g
b
]
=
WATERFALL_BACKGROUND_TICKS_COLOR_RGB
;
let
alphaComponent
=
WATERFALL_BACKGROUND_TICKS_OPACITY_MIN
;
const
tickInterval
=
findOptimalTickInterval
(
{
ticksMultiple
:
WATERFALL_BACKGROUND_TICKS_MULTIPLE
ticksSpacingMin
:
WATERFALL_BACKGROUND_TICKS_SPACING_MIN
dataScale
:
dataScale
}
)
;
for
(
let
i
=
1
;
i
<
=
WATERFALL_BACKGROUND_TICKS_SCALES
;
i
+
+
)
{
const
increment
=
tickInterval
*
Math
.
pow
(
2
i
)
;
for
(
let
x
=
0
;
x
<
canvasWidth
;
x
+
=
increment
)
{
const
position
=
x
|
0
;
view32bit
[
position
]
=
(
alphaComponent
<
<
24
)
|
(
b
<
<
16
)
|
(
g
<
<
8
)
|
r
;
}
alphaComponent
+
=
WATERFALL_BACKGROUND_TICKS_OPACITY_ADD
;
}
pixelArray
.
set
(
view8bit
)
;
ctx
.
putImageData
(
imageData
0
0
)
;
doc
.
mozSetImageElement
(
"
waterfall
-
background
"
canvas
)
;
return
canvas
;
}
function
findOptimalTickInterval
(
{
ticksMultiple
ticksSpacingMin
dataScale
}
)
{
let
timingStep
=
ticksMultiple
;
const
maxIters
=
FIND_OPTIMAL_TICK_INTERVAL_MAX_ITERS
;
let
numIters
=
0
;
if
(
dataScale
>
ticksSpacingMin
)
{
return
dataScale
;
}
while
(
true
)
{
const
scaledStep
=
dataScale
*
timingStep
;
if
(
+
+
numIters
>
maxIters
)
{
return
scaledStep
;
}
if
(
scaledStep
<
ticksSpacingMin
)
{
timingStep
<
<
=
1
;
continue
;
}
return
scaledStep
;
}
}
exports
.
TickUtils
=
{
findOptimalTickInterval
drawWaterfallBackground
}
;
