"
use
strict
"
;
const
{
TIMELINE_BLUEPRINT
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
markers
"
)
;
exports
.
MarkerBlueprintUtils
=
{
shouldDisplayMarker
:
function
(
marker
hiddenMarkerNames
)
{
if
(
!
hiddenMarkerNames
|
|
hiddenMarkerNames
.
length
=
=
0
)
{
return
true
;
}
const
isUnknown
=
!
(
marker
.
name
in
TIMELINE_BLUEPRINT
)
;
if
(
isUnknown
)
{
return
!
hiddenMarkerNames
.
includes
(
"
UNKNOWN
"
)
;
}
return
!
hiddenMarkerNames
.
includes
(
marker
.
name
)
;
}
getBlueprintFor
:
function
(
marker
)
{
return
TIMELINE_BLUEPRINT
[
marker
.
name
]
|
|
TIMELINE_BLUEPRINT
.
UNKNOWN
;
}
getMarkerLabel
:
function
(
marker
)
{
const
blueprint
=
this
.
getBlueprintFor
(
marker
)
;
const
dynamic
=
typeof
blueprint
.
label
=
=
=
"
function
"
;
const
label
=
dynamic
?
blueprint
.
label
(
marker
)
:
blueprint
.
label
;
return
label
;
}
getMarkerGenericName
:
function
(
markerName
)
{
const
blueprint
=
this
.
getBlueprintFor
(
{
name
:
markerName
}
)
;
const
dynamic
=
typeof
blueprint
.
label
=
=
=
"
function
"
;
const
generic
=
dynamic
?
blueprint
.
label
(
)
:
blueprint
.
label
;
if
(
!
generic
)
{
let
message
=
Could
not
find
marker
generic
name
for
"
{
markerName
}
"
.
;
if
(
typeof
blueprint
.
label
=
=
=
"
function
"
)
{
message
+
=
The
following
function
must
return
a
generic
name
string
when
no
+
marker
passed
:
{
blueprint
.
label
}
;
}
else
{
message
+
=
{
markerName
}
.
label
must
be
defined
in
the
marker
blueprint
.
;
}
throw
new
Error
(
message
)
;
}
return
generic
;
}
getMarkerFields
:
function
(
marker
)
{
const
blueprint
=
this
.
getBlueprintFor
(
marker
)
;
const
dynamic
=
typeof
blueprint
.
fields
=
=
=
"
function
"
;
const
fields
=
dynamic
?
blueprint
.
fields
(
marker
)
:
blueprint
.
fields
;
return
Object
.
entries
(
fields
|
|
{
}
)
.
filter
(
(
[
_
value
]
)
=
>
(
dynamic
?
true
:
value
in
marker
)
)
.
map
(
(
[
label
value
]
)
=
>
(
{
label
value
:
dynamic
?
value
:
marker
[
value
]
}
)
)
;
}
}
;
