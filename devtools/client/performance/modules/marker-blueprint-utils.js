"
use
strict
"
;
const
{
TIMELINE_BLUEPRINT
}
=
require
(
"
devtools
/
client
/
performance
/
modules
/
markers
"
)
;
exports
.
MarkerBlueprintUtils
=
{
shouldDisplayMarker
:
function
(
marker
hiddenMarkerNames
)
{
if
(
!
hiddenMarkerNames
|
|
hiddenMarkerNames
.
length
=
=
0
)
{
return
true
;
}
let
isUnknown
=
!
(
marker
.
name
in
TIMELINE_BLUEPRINT
)
;
if
(
isUnknown
)
{
return
hiddenMarkerNames
.
indexOf
(
"
UNKNOWN
"
)
=
=
-
1
;
}
return
hiddenMarkerNames
.
indexOf
(
marker
.
name
)
=
=
-
1
;
}
getBlueprintFor
:
function
(
marker
)
{
return
TIMELINE_BLUEPRINT
[
marker
.
name
]
|
|
TIMELINE_BLUEPRINT
.
UNKNOWN
;
}
getMarkerLabel
:
function
(
marker
)
{
let
blueprint
=
this
.
getBlueprintFor
(
marker
)
;
let
label
=
typeof
blueprint
.
label
=
=
=
"
function
"
?
blueprint
.
label
(
marker
)
:
blueprint
.
label
;
return
label
;
}
getMarkerGenericName
:
function
(
markerName
)
{
let
blueprint
=
this
.
getBlueprintFor
(
{
name
:
markerName
}
)
;
let
generic
=
typeof
blueprint
.
label
=
=
=
"
function
"
?
blueprint
.
label
(
)
:
blueprint
.
label
;
if
(
!
generic
)
{
let
message
=
Could
not
find
marker
generic
name
for
"
{
markerName
}
"
.
;
if
(
typeof
blueprint
.
label
=
=
=
"
function
"
)
{
message
+
=
The
following
function
must
return
a
generic
name
string
when
no
marker
passed
:
{
blueprint
.
label
}
;
}
else
{
message
+
=
{
markerName
}
.
label
must
be
defined
in
the
marker
blueprint
.
;
}
throw
new
Error
(
message
)
;
}
return
generic
;
}
getMarkerFields
:
function
(
marker
)
{
let
blueprint
=
this
.
getBlueprintFor
(
marker
)
;
if
(
typeof
blueprint
.
fields
=
=
=
"
function
"
)
{
let
fields
=
blueprint
.
fields
(
marker
)
|
|
{
}
;
return
Object
.
keys
(
fields
)
.
map
(
label
=
>
(
{
label
value
:
fields
[
label
]
}
)
)
;
}
return
(
blueprint
.
fields
|
|
[
]
)
.
reduce
(
(
fields
field
)
=
>
{
if
(
field
.
property
in
marker
)
{
let
label
=
field
.
label
;
let
value
=
marker
[
field
.
property
]
;
fields
.
push
(
{
label
value
}
)
;
}
return
fields
;
}
[
]
)
;
}
}
;
