"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
RecordingUtils
=
require
(
"
devtools
/
shared
/
performance
/
recording
-
utils
"
)
;
const
{
FileUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
PERF_TOOL_SERIALIZER_IDENTIFIER
=
"
Recorded
Performance
Data
"
;
const
PERF_TOOL_SERIALIZER_LEGACY_VERSION
=
1
;
const
PERF_TOOL_SERIALIZER_CURRENT_VERSION
=
2
;
function
getUnicodeConverter
(
)
{
const
cname
=
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
;
const
converter
=
Cc
[
cname
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
return
converter
;
}
function
saveRecordingToFile
(
recordingData
file
)
{
recordingData
.
fileType
=
PERF_TOOL_SERIALIZER_IDENTIFIER
;
recordingData
.
version
=
PERF_TOOL_SERIALIZER_CURRENT_VERSION
;
const
string
=
JSON
.
stringify
(
recordingData
)
;
const
inputStream
=
getUnicodeConverter
(
)
.
convertToInputStream
(
string
)
;
const
outputStream
=
FileUtils
.
openSafeFileOutputStream
(
file
)
;
return
new
Promise
(
resolve
=
>
{
NetUtil
.
asyncCopy
(
inputStream
outputStream
resolve
)
;
}
)
;
}
function
loadRecordingFromFile
(
file
)
{
const
channel
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
file
)
loadUsingSystemPrincipal
:
true
}
)
;
channel
.
contentType
=
"
text
/
plain
"
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
NetUtil
.
asyncFetch
(
channel
(
inputStream
)
=
>
{
let
recordingData
;
try
{
const
string
=
NetUtil
.
readInputStreamToString
(
inputStream
inputStream
.
available
(
)
)
;
recordingData
=
JSON
.
parse
(
string
)
;
}
catch
(
e
)
{
reject
(
new
Error
(
"
Could
not
read
recording
data
file
.
"
)
)
;
return
;
}
if
(
recordingData
.
fileType
!
=
PERF_TOOL_SERIALIZER_IDENTIFIER
)
{
reject
(
new
Error
(
"
Unrecognized
recording
data
file
.
"
)
)
;
return
;
}
if
(
!
isValidSerializerVersion
(
recordingData
.
version
)
)
{
reject
(
new
Error
(
"
Unsupported
recording
data
file
version
.
"
)
)
;
return
;
}
if
(
recordingData
.
version
=
=
=
PERF_TOOL_SERIALIZER_LEGACY_VERSION
)
{
recordingData
=
convertLegacyData
(
recordingData
)
;
}
if
(
recordingData
.
profile
.
meta
.
version
=
=
=
2
)
{
RecordingUtils
.
deflateProfile
(
recordingData
.
profile
)
;
}
if
(
!
recordingData
.
label
)
{
recordingData
.
label
=
file
.
leafName
.
replace
(
/
\
.
[
^
.
]
+
/
"
"
)
;
}
resolve
(
recordingData
)
;
}
)
;
}
)
;
}
function
isValidSerializerVersion
(
version
)
{
return
!
!
~
[
PERF_TOOL_SERIALIZER_LEGACY_VERSION
PERF_TOOL_SERIALIZER_CURRENT_VERSION
]
.
indexOf
(
version
)
;
}
function
convertLegacyData
(
legacyData
)
{
const
{
profilerData
ticksData
recordingDuration
}
=
legacyData
;
const
data
=
{
label
:
profilerData
.
profilerLabel
duration
:
recordingDuration
markers
:
[
]
frames
:
[
]
memory
:
[
]
ticks
:
ticksData
allocations
:
{
sites
:
[
]
timestamps
:
[
]
frames
:
[
]
sizes
:
[
]
}
profile
:
profilerData
.
profile
configuration
:
{
withTicks
:
!
!
ticksData
.
length
withMarkers
:
false
withMemory
:
false
withAllocations
:
false
}
systemHost
:
{
}
systemClient
:
{
}
}
;
return
data
;
}
exports
.
saveRecordingToFile
=
saveRecordingToFile
;
exports
.
loadRecordingFromFile
=
loadRecordingFromFile
;
