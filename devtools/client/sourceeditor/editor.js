"
use
strict
"
;
const
{
EXPAND_TAB
TAB_SIZE
DETECT_INDENT
getIndentationFromIteration
}
=
require
(
"
devtools
/
shared
/
indentation
"
)
;
const
ENABLE_CODE_FOLDING
=
"
devtools
.
editor
.
enableCodeFolding
"
;
const
KEYMAP
=
"
devtools
.
editor
.
keymap
"
;
const
AUTO_CLOSE
=
"
devtools
.
editor
.
autoclosebrackets
"
;
const
AUTOCOMPLETE
=
"
devtools
.
editor
.
autocomplete
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
VALID_KEYMAPS
=
new
Set
(
[
"
emacs
"
"
vim
"
"
sublime
"
]
)
;
const
MAX_VERTICAL_OFFSET
=
3
;
const
RE_SCRATCHPAD_ERROR
=
/
(
?
:
Scratchpad
\
/
\
d
+
:
|
\
(
)
(
\
d
+
)
:
?
(
\
d
+
)
?
(
?
:
\
)
|
\
n
)
/
;
const
RE_JUMP_TO_LINE
=
/
^
(
\
d
+
)
:
?
(
\
d
+
)
?
/
;
const
Services
=
require
(
"
Services
"
)
;
const
events
=
require
(
"
devtools
/
shared
/
old
-
event
-
emitter
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
{
getClientCssProperties
}
=
require
(
"
devtools
/
shared
/
fronts
/
css
-
properties
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
sourceeditor
.
properties
"
)
;
const
{
getWasmText
getWasmLineNumberFormatter
isWasm
lineToWasmOffset
wasmOffsetToLine
}
=
require
(
"
.
/
wasm
"
)
;
const
{
OS
}
=
Services
.
appinfo
;
const
CM_SCRIPTS
=
[
"
chrome
:
/
/
devtools
/
content
/
sourceeditor
/
codemirror
/
codemirror
.
bundle
.
js
"
]
;
const
CM_IFRAME
=
"
chrome
:
/
/
devtools
/
content
/
sourceeditor
/
codemirror
/
cmiframe
.
html
"
;
const
CM_MAPPING
=
[
"
focus
"
"
hasFocus
"
"
lineCount
"
"
somethingSelected
"
"
getCursor
"
"
setSelection
"
"
getSelection
"
"
replaceSelection
"
"
extendSelection
"
"
undo
"
"
redo
"
"
clearHistory
"
"
openDialog
"
"
refresh
"
"
getScrollInfo
"
"
getViewport
"
]
;
const
editors
=
new
WeakMap
(
)
;
Editor
.
modes
=
{
text
:
{
name
:
"
text
"
}
html
:
{
name
:
"
htmlmixed
"
}
css
:
{
name
:
"
css
"
}
wasm
:
{
name
:
"
wasm
"
}
js
:
{
name
:
"
javascript
"
}
vs
:
{
name
:
"
x
-
shader
/
x
-
vertex
"
}
fs
:
{
name
:
"
x
-
shader
/
x
-
fragment
"
}
}
;
function
Editor
(
config
)
{
const
tabSize
=
Services
.
prefs
.
getIntPref
(
TAB_SIZE
)
;
const
useTabs
=
!
Services
.
prefs
.
getBoolPref
(
EXPAND_TAB
)
;
const
useAutoClose
=
Services
.
prefs
.
getBoolPref
(
AUTO_CLOSE
)
;
this
.
version
=
null
;
this
.
config
=
{
value
:
"
"
mode
:
Editor
.
modes
.
text
indentUnit
:
tabSize
tabSize
:
tabSize
contextMenu
:
null
matchBrackets
:
true
extraKeys
:
{
}
indentWithTabs
:
useTabs
inputStyle
:
"
textarea
"
styleActiveLine
:
true
autoCloseBrackets
:
"
(
)
[
]
{
}
'
'
\
"
\
"
"
autoCloseEnabled
:
useAutoClose
theme
:
"
mozilla
"
themeSwitching
:
true
autocomplete
:
false
autocompleteOpts
:
{
}
}
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
jumpToLine
"
)
]
=
(
)
=
>
this
.
jumpToLine
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
moveLineUp
"
{
noaccel
:
true
}
)
]
=
(
)
=
>
this
.
moveLineUp
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
moveLineDown
"
{
noaccel
:
true
}
)
]
=
(
)
=
>
this
.
moveLineDown
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
toggleComment
"
)
]
=
"
toggleComment
"
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
indentLess
"
)
]
=
false
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
indentMore
"
)
]
=
false
;
Object
.
keys
(
config
)
.
forEach
(
k
=
>
{
if
(
k
!
=
"
extraKeys
"
)
{
this
.
config
[
k
]
=
config
[
k
]
;
return
;
}
if
(
!
config
.
extraKeys
)
{
return
;
}
Object
.
keys
(
config
.
extraKeys
)
.
forEach
(
key
=
>
{
this
.
config
.
extraKeys
[
key
]
=
config
.
extraKeys
[
key
]
;
}
)
;
}
)
;
if
(
!
this
.
config
.
gutters
)
{
this
.
config
.
gutters
=
[
]
;
}
if
(
this
.
config
.
lineNumbers
&
&
!
this
.
config
.
gutters
.
includes
(
"
CodeMirror
-
linenumbers
"
)
)
{
this
.
config
.
gutters
.
push
(
"
CodeMirror
-
linenumbers
"
)
;
}
this
.
config
.
autoCloseBracketsSaved
=
this
.
config
.
autoCloseBrackets
;
this
.
config
.
extraKeys
.
Tab
=
cm
=
>
{
if
(
cm
.
somethingSelected
(
)
)
{
cm
.
indentSelection
(
"
add
"
)
;
return
;
}
if
(
this
.
config
.
indentWithTabs
)
{
cm
.
replaceSelection
(
"
\
t
"
"
end
"
"
+
input
"
)
;
return
;
}
let
num
=
cm
.
getOption
(
"
indentUnit
"
)
;
if
(
cm
.
getCursor
(
)
.
ch
!
=
=
0
)
{
num
-
=
cm
.
getCursor
(
)
.
ch
%
num
;
}
cm
.
replaceSelection
(
"
"
.
repeat
(
num
)
"
end
"
"
+
input
"
)
;
}
;
if
(
!
this
.
config
.
externalScripts
)
{
this
.
config
.
externalScripts
=
[
]
;
}
if
(
this
.
config
.
cssProperties
)
{
this
.
config
.
autocompleteOpts
.
cssProperties
=
this
.
config
.
cssProperties
;
}
else
{
this
.
config
.
cssProperties
=
getClientCssProperties
(
)
;
}
events
.
decorate
(
this
)
;
}
Editor
.
prototype
=
{
container
:
null
version
:
null
config
:
null
Doc
:
null
get
codeMirror
(
)
{
if
(
!
editors
.
has
(
this
)
)
{
throw
new
Error
(
"
CodeMirror
instance
does
not
exist
.
You
must
wait
"
+
"
for
it
to
be
appended
to
the
DOM
.
"
)
;
}
return
editors
.
get
(
this
)
;
}
appendTo
:
function
(
el
env
)
{
return
new
Promise
(
resolve
=
>
{
let
cm
=
editors
.
get
(
this
)
;
if
(
!
env
)
{
env
=
el
.
ownerDocument
.
createElementNS
(
el
.
namespaceURI
"
iframe
"
)
;
if
(
el
.
namespaceURI
=
=
=
XUL_NS
)
{
env
.
flex
=
1
;
}
}
if
(
cm
)
{
throw
new
Error
(
"
You
can
append
an
editor
only
once
.
"
)
;
}
let
onLoad
=
(
)
=
>
{
let
win
=
env
.
contentWindow
.
wrappedJSObject
;
if
(
!
this
.
config
.
themeSwitching
)
{
win
.
document
.
documentElement
.
setAttribute
(
"
force
-
theme
"
"
light
"
)
;
}
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
devtools
/
content
/
shared
/
theme
-
switching
.
js
"
win
"
utf8
"
)
;
this
.
container
=
env
;
this
.
_setup
(
win
.
document
.
body
el
.
ownerDocument
)
;
env
.
removeEventListener
(
"
load
"
onLoad
true
)
;
resolve
(
)
;
}
;
env
.
addEventListener
(
"
load
"
onLoad
true
)
;
env
.
setAttribute
(
"
src
"
CM_IFRAME
)
;
el
.
appendChild
(
env
)
;
this
.
once
(
"
destroy
"
(
)
=
>
el
.
removeChild
(
env
)
)
;
}
)
;
}
appendToLocalElement
:
function
(
el
)
{
this
.
_setup
(
el
)
;
}
_setup
:
function
(
el
doc
)
{
doc
=
doc
|
|
el
.
ownerDocument
;
let
win
=
el
.
ownerDocument
.
defaultView
;
let
scriptsToInject
=
CM_SCRIPTS
.
concat
(
this
.
config
.
externalScripts
)
;
scriptsToInject
.
forEach
(
url
=
>
{
if
(
url
.
startsWith
(
"
chrome
:
/
/
"
)
)
{
Services
.
scriptloader
.
loadSubScript
(
url
win
"
utf8
"
)
;
}
}
)
;
const
{
propertyKeywords
colorKeywords
valueKeywords
}
=
getCSSKeywords
(
this
.
config
.
cssProperties
)
;
let
cssSpec
=
win
.
CodeMirror
.
resolveMode
(
"
text
/
css
"
)
;
cssSpec
.
propertyKeywords
=
propertyKeywords
;
cssSpec
.
colorKeywords
=
colorKeywords
;
cssSpec
.
valueKeywords
=
valueKeywords
;
win
.
CodeMirror
.
defineMIME
(
"
text
/
css
"
cssSpec
)
;
let
scssSpec
=
win
.
CodeMirror
.
resolveMode
(
"
text
/
x
-
scss
"
)
;
scssSpec
.
propertyKeywords
=
propertyKeywords
;
scssSpec
.
colorKeywords
=
colorKeywords
;
scssSpec
.
valueKeywords
=
valueKeywords
;
win
.
CodeMirror
.
defineMIME
(
"
text
/
x
-
scss
"
scssSpec
)
;
win
.
CodeMirror
.
commands
.
save
=
(
)
=
>
this
.
emit
(
"
saveRequested
"
)
;
let
cm
=
win
.
CodeMirror
(
el
this
.
config
)
;
this
.
Doc
=
win
.
CodeMirror
.
Doc
;
cm
.
getScrollerElement
(
)
.
addEventListener
(
"
wheel
"
ev
=
>
{
ev
.
preventDefault
(
)
;
let
{
deltaX
deltaY
}
=
ev
;
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_LINE
)
{
deltaX
*
=
cm
.
defaultCharWidth
(
)
;
deltaY
*
=
cm
.
defaultTextHeight
(
)
;
}
else
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_PAGE
)
{
deltaX
*
=
cm
.
getWrapperElement
(
)
.
clientWidth
;
deltaY
*
=
cm
.
getWrapperElement
(
)
.
clientHeight
;
}
cm
.
getScrollerElement
(
)
.
scrollBy
(
deltaX
deltaY
)
;
}
)
;
cm
.
getWrapperElement
(
)
.
addEventListener
(
"
contextmenu
"
ev
=
>
{
if
(
!
this
.
config
.
contextMenu
)
{
return
;
}
ev
.
stopPropagation
(
)
;
ev
.
preventDefault
(
)
;
let
popup
=
this
.
config
.
contextMenu
;
if
(
typeof
popup
=
=
"
string
"
)
{
popup
=
doc
.
getElementById
(
this
.
config
.
contextMenu
)
;
}
this
.
emit
(
"
popupOpen
"
ev
popup
)
;
popup
.
openPopupAtScreen
(
ev
.
screenX
ev
.
screenY
true
)
;
}
)
;
cm
.
on
(
"
focus
"
(
)
=
>
this
.
emit
(
"
focus
"
)
)
;
cm
.
on
(
"
scroll
"
(
)
=
>
this
.
emit
(
"
scroll
"
)
)
;
cm
.
on
(
"
change
"
(
)
=
>
{
this
.
emit
(
"
change
"
)
;
if
(
!
this
.
_lastDirty
)
{
this
.
_lastDirty
=
true
;
this
.
emit
(
"
dirty
-
change
"
)
;
}
}
)
;
cm
.
on
(
"
cursorActivity
"
(
)
=
>
this
.
emit
(
"
cursorActivity
"
)
)
;
cm
.
on
(
"
gutterClick
"
(
cmArg
line
gutter
ev
)
=
>
{
let
lineOrOffset
=
!
this
.
isWasm
?
line
:
this
.
lineToWasmOffset
(
line
)
;
let
head
=
{
line
:
line
ch
:
0
}
;
let
tail
=
{
line
:
line
ch
:
this
.
getText
(
lineOrOffset
)
.
length
}
;
if
(
ev
.
shiftKey
)
{
cmArg
.
setSelection
(
head
tail
)
;
return
;
}
this
.
emit
(
"
gutterClick
"
lineOrOffset
ev
.
button
)
;
}
)
;
win
.
CodeMirror
.
defineExtension
(
"
l10n
"
(
name
)
=
>
{
return
L10N
.
getStr
(
name
)
;
}
)
;
this
.
_initShortcuts
(
win
)
;
editors
.
set
(
this
cm
)
;
this
.
reloadPreferences
=
this
.
reloadPreferences
.
bind
(
this
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
editor
.
"
)
;
this
.
_prefObserver
.
on
(
TAB_SIZE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
EXPAND_TAB
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
KEYMAP
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
AUTO_CLOSE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
AUTOCOMPLETE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
DETECT_INDENT
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
ENABLE_CODE_FOLDING
this
.
reloadPreferences
)
;
this
.
reloadPreferences
(
)
;
win
.
editor
=
this
;
let
editorReadyEvent
=
new
win
.
CustomEvent
(
"
editorReady
"
)
;
win
.
dispatchEvent
(
editorReadyEvent
)
;
}
isAppended
:
function
(
)
{
return
editors
.
has
(
this
)
;
}
getMode
:
function
(
)
{
return
this
.
getOption
(
"
mode
"
)
;
}
loadScript
:
function
(
url
)
{
if
(
!
this
.
container
)
{
throw
new
Error
(
"
Can
'
t
load
a
script
until
the
editor
is
loaded
.
"
)
;
}
let
win
=
this
.
container
.
contentWindow
.
wrappedJSObject
;
Services
.
scriptloader
.
loadSubScript
(
url
win
"
utf8
"
)
;
}
createDocument
:
function
(
)
{
return
new
this
.
Doc
(
"
"
)
;
}
replaceDocument
:
function
(
doc
)
{
let
cm
=
editors
.
get
(
this
)
;
cm
.
swapDoc
(
doc
)
;
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
new
-
debugger
-
frontend
"
)
)
{
this
.
_updateLineNumberFormat
(
)
;
}
}
setMode
:
function
(
value
)
{
this
.
setOption
(
"
mode
"
value
)
;
if
(
this
.
config
.
autocomplete
)
{
this
.
setOption
(
"
autocomplete
"
false
)
;
this
.
setOption
(
"
autocomplete
"
true
)
;
}
}
insertCommandsController
:
function
(
)
{
const
{
insertCommandsController
}
=
require
(
"
devtools
/
client
/
sourceeditor
/
editor
-
commands
-
controller
"
)
;
insertCommandsController
(
this
)
;
}
getText
:
function
(
line
)
{
let
cm
=
editors
.
get
(
this
)
;
if
(
line
=
=
null
)
{
return
cm
.
getValue
(
)
;
}
let
info
=
this
.
lineInfo
(
line
)
;
return
info
?
info
.
text
:
"
"
;
}
getDoc
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
getDoc
(
)
;
}
get
isWasm
(
)
{
return
isWasm
(
this
.
getDoc
(
)
)
;
}
wasmOffsetToLine
:
function
(
offset
)
{
return
wasmOffsetToLine
(
this
.
getDoc
(
)
offset
)
;
}
lineToWasmOffset
:
function
(
number
)
{
return
lineToWasmOffset
(
this
.
getDoc
(
)
number
)
;
}
toLineIfWasmOffset
:
function
(
maybeOffset
)
{
if
(
typeof
maybeOffset
!
=
=
"
number
"
|
|
!
this
.
isWasm
)
{
return
maybeOffset
;
}
return
this
.
wasmOffsetToLine
(
maybeOffset
)
;
}
lineInfo
:
function
(
lineOrOffset
)
{
let
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
if
(
line
=
=
undefined
)
{
return
null
;
}
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
lineInfo
(
line
)
;
}
getLineOrOffset
:
function
(
line
)
{
return
this
.
isWasm
?
this
.
lineToWasmOffset
(
line
)
:
line
;
}
_updateLineNumberFormat
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
if
(
this
.
isWasm
)
{
let
formatter
=
getWasmLineNumberFormatter
(
this
.
getDoc
(
)
)
;
cm
.
setOption
(
"
lineNumberFormatter
"
formatter
)
;
}
else
{
cm
.
setOption
(
"
lineNumberFormatter
"
(
number
)
=
>
number
)
;
}
}
setText
:
function
(
value
)
{
let
cm
=
editors
.
get
(
this
)
;
if
(
typeof
value
!
=
=
"
string
"
&
&
"
binary
"
in
value
)
{
let
binary
=
value
.
binary
;
let
data
=
new
Uint8Array
(
binary
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
data
[
i
]
=
binary
.
charCodeAt
(
i
)
;
}
let
{
lines
done
}
=
getWasmText
(
this
.
getDoc
(
)
data
)
;
const
MAX_LINES
=
10000000
;
if
(
lines
.
length
>
MAX_LINES
)
{
lines
.
splice
(
MAX_LINES
lines
.
length
-
MAX_LINES
)
;
lines
.
push
(
"
;
;
.
.
.
.
text
is
truncated
due
to
the
size
"
)
;
}
if
(
!
done
)
{
lines
.
push
(
"
;
;
.
.
.
.
possible
error
during
wast
conversion
"
)
;
}
value
=
{
split
:
(
)
=
>
lines
}
;
}
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
new
-
debugger
-
frontend
"
)
)
{
this
.
_updateLineNumberFormat
(
)
;
}
cm
.
setValue
(
value
)
;
this
.
resetIndentUnit
(
)
;
}
reloadPreferences
:
function
(
)
{
let
useAutoClose
=
Services
.
prefs
.
getBoolPref
(
AUTO_CLOSE
)
;
this
.
setOption
(
"
autoCloseBrackets
"
useAutoClose
?
this
.
config
.
autoCloseBracketsSaved
:
false
)
;
const
keyMap
=
Services
.
prefs
.
getCharPref
(
KEYMAP
)
;
if
(
VALID_KEYMAPS
.
has
(
keyMap
)
)
{
this
.
setOption
(
"
keyMap
"
keyMap
)
;
}
else
{
this
.
setOption
(
"
keyMap
"
"
default
"
)
;
}
this
.
updateCodeFoldingGutter
(
)
;
this
.
resetIndentUnit
(
)
;
this
.
setupAutoCompletion
(
)
;
}
resetIndentUnit
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
let
iterFn
=
function
(
start
end
callback
)
{
cm
.
eachLine
(
start
end
(
line
)
=
>
{
return
callback
(
line
.
text
)
;
}
)
;
}
;
let
{
indentUnit
indentWithTabs
}
=
getIndentationFromIteration
(
iterFn
)
;
cm
.
setOption
(
"
tabSize
"
indentUnit
)
;
cm
.
setOption
(
"
indentUnit
"
indentUnit
)
;
cm
.
setOption
(
"
indentWithTabs
"
indentWithTabs
)
;
}
replaceText
:
function
(
value
from
to
)
{
let
cm
=
editors
.
get
(
this
)
;
if
(
!
from
)
{
this
.
setText
(
value
)
;
return
;
}
if
(
!
to
)
{
let
text
=
cm
.
getRange
(
{
line
:
0
ch
:
0
}
from
)
;
this
.
setText
(
text
+
value
)
;
return
;
}
cm
.
replaceRange
(
value
from
to
)
;
}
insertText
:
function
(
value
at
)
{
let
cm
=
editors
.
get
(
this
)
;
cm
.
replaceRange
(
value
at
at
)
;
}
dropSelection
:
function
(
)
{
if
(
!
this
.
somethingSelected
(
)
)
{
return
;
}
this
.
setCursor
(
this
.
getCursor
(
)
)
;
}
hasMultipleSelections
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
listSelections
(
)
.
length
>
1
;
}
getFirstVisibleLine
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
lineAtHeight
(
0
"
local
"
)
;
}
setFirstVisibleLine
:
function
(
line
)
{
let
cm
=
editors
.
get
(
this
)
;
let
{
top
}
=
cm
.
charCoords
(
{
line
:
line
ch
:
0
}
"
local
"
)
;
cm
.
scrollTo
(
0
top
)
;
}
setCursor
:
function
(
{
line
ch
}
align
)
{
let
cm
=
editors
.
get
(
this
)
;
this
.
alignLine
(
line
align
)
;
cm
.
setCursor
(
{
line
:
line
ch
:
ch
}
)
;
this
.
emit
(
"
cursorActivity
"
)
;
}
alignLine
:
function
(
line
align
)
{
let
cm
=
editors
.
get
(
this
)
;
let
from
=
cm
.
lineAtHeight
(
0
"
page
"
)
;
let
to
=
cm
.
lineAtHeight
(
cm
.
getWrapperElement
(
)
.
clientHeight
"
page
"
)
;
let
linesVisible
=
to
-
from
;
let
halfVisible
=
Math
.
round
(
linesVisible
/
2
)
;
if
(
line
<
=
to
&
&
line
>
=
from
)
{
return
;
}
let
offset
=
Math
.
min
(
halfVisible
MAX_VERTICAL_OFFSET
)
;
let
topLine
=
{
"
center
"
:
Math
.
max
(
line
-
halfVisible
0
)
"
bottom
"
:
Math
.
max
(
line
-
linesVisible
+
offset
0
)
"
top
"
:
Math
.
max
(
line
-
offset
0
)
}
[
align
|
|
"
top
"
]
|
|
offset
;
topLine
=
Math
.
min
(
topLine
this
.
lineCount
(
)
)
;
this
.
setFirstVisibleLine
(
topLine
)
;
}
hasMarker
:
function
(
line
gutterName
markerClass
)
{
let
marker
=
this
.
getMarker
(
line
gutterName
)
;
if
(
!
marker
)
{
return
false
;
}
return
marker
.
classList
.
contains
(
markerClass
)
;
}
addMarker
:
function
(
line
gutterName
markerClass
)
{
let
cm
=
editors
.
get
(
this
)
;
let
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
let
gutterMarkers
=
info
.
gutterMarkers
;
let
marker
;
if
(
gutterMarkers
)
{
marker
=
gutterMarkers
[
gutterName
]
;
if
(
marker
)
{
marker
.
classList
.
add
(
markerClass
)
;
return
;
}
}
marker
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
div
"
)
;
marker
.
className
=
markerClass
;
cm
.
setGutterMarker
(
info
.
line
gutterName
marker
)
;
}
removeMarker
:
function
(
line
gutterName
markerClass
)
{
if
(
!
this
.
hasMarker
(
line
gutterName
markerClass
)
)
{
return
;
}
this
.
lineInfo
(
line
)
.
gutterMarkers
[
gutterName
]
.
classList
.
remove
(
markerClass
)
;
}
addContentMarker
:
function
(
line
gutterName
markerClass
content
)
{
let
cm
=
editors
.
get
(
this
)
;
let
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
let
marker
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
div
"
)
;
marker
.
className
=
markerClass
;
marker
.
innerHTML
=
content
;
cm
.
setGutterMarker
(
info
.
line
gutterName
marker
)
;
}
removeContentMarker
:
function
(
line
gutterName
)
{
let
cm
=
editors
.
get
(
this
)
;
let
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
cm
.
setGutterMarker
(
info
.
line
gutterName
null
)
;
}
getMarker
:
function
(
line
gutterName
)
{
let
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
null
;
}
let
gutterMarkers
=
info
.
gutterMarkers
;
if
(
!
gutterMarkers
)
{
return
null
;
}
return
gutterMarkers
[
gutterName
]
;
}
removeAllMarkers
:
function
(
gutterName
)
{
let
cm
=
editors
.
get
(
this
)
;
cm
.
clearGutter
(
gutterName
)
;
}
setMarkerListeners
:
function
(
line
gutterName
markerClass
eventsArg
data
)
{
if
(
!
this
.
hasMarker
(
line
gutterName
markerClass
)
)
{
return
;
}
let
cm
=
editors
.
get
(
this
)
;
let
marker
=
cm
.
lineInfo
(
line
)
.
gutterMarkers
[
gutterName
]
;
for
(
let
name
in
eventsArg
)
{
let
listener
=
eventsArg
[
name
]
.
bind
(
this
line
marker
data
)
;
marker
.
addEventListener
(
name
listener
)
;
}
}
hasLineClass
:
function
(
line
className
)
{
let
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
|
|
!
info
.
wrapClass
)
{
return
false
;
}
return
info
.
wrapClass
.
split
(
"
"
)
.
includes
(
className
)
;
}
addLineClass
:
function
(
lineOrOffset
className
)
{
let
cm
=
editors
.
get
(
this
)
;
let
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
cm
.
addLineClass
(
line
"
wrap
"
className
)
;
}
removeLineClass
:
function
(
lineOrOffset
className
)
{
let
cm
=
editors
.
get
(
this
)
;
let
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
cm
.
removeLineClass
(
line
"
wrap
"
className
)
;
}
markText
:
function
(
from
to
className
=
"
marked
-
text
"
)
{
let
cm
=
editors
.
get
(
this
)
;
let
text
=
cm
.
getRange
(
from
to
)
;
let
span
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
span
"
)
;
span
.
className
=
className
;
span
.
textContent
=
text
;
let
mark
=
cm
.
markText
(
from
to
{
replacedWith
:
span
}
)
;
return
{
anchor
:
span
clear
:
(
)
=
>
mark
.
clear
(
)
}
;
}
getPosition
:
function
(
.
.
.
args
)
{
let
cm
=
editors
.
get
(
this
)
;
let
res
=
args
.
map
(
(
ind
)
=
>
cm
.
posFromIndex
(
ind
)
)
;
return
args
.
length
=
=
=
1
?
res
[
0
]
:
res
;
}
getOffset
:
function
(
.
.
.
args
)
{
let
cm
=
editors
.
get
(
this
)
;
let
res
=
args
.
map
(
(
pos
)
=
>
cm
.
indexFromPos
(
pos
)
)
;
return
args
.
length
>
1
?
res
:
res
[
0
]
;
}
getPositionFromCoords
:
function
(
{
left
top
}
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
coordsChar
(
{
left
:
left
top
:
top
}
)
;
}
getCoordsFromPosition
:
function
(
{
line
ch
}
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
charCoords
(
{
line
:
~
~
line
ch
:
~
~
ch
}
)
;
}
canUndo
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
historySize
(
)
.
undo
>
0
;
}
canRedo
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
historySize
(
)
.
redo
>
0
;
}
setClean
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
this
.
version
=
cm
.
changeGeneration
(
)
;
this
.
_lastDirty
=
false
;
this
.
emit
(
"
dirty
-
change
"
)
;
return
this
.
version
;
}
isClean
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
.
isClean
(
this
.
version
)
;
}
jumpToLine
:
function
(
)
{
let
doc
=
editors
.
get
(
this
)
.
getWrapperElement
(
)
.
ownerDocument
;
let
div
=
doc
.
createElement
(
"
div
"
)
;
let
inp
=
doc
.
createElement
(
"
input
"
)
;
let
txt
=
doc
.
createTextNode
(
L10N
.
getStr
(
"
gotoLineCmd
.
promptTitle
"
)
)
;
inp
.
type
=
"
text
"
;
inp
.
style
.
width
=
"
10em
"
;
inp
.
style
.
marginInlineStart
=
"
1em
"
;
div
.
appendChild
(
txt
)
;
div
.
appendChild
(
inp
)
;
if
(
!
this
.
hasMultipleSelections
(
)
)
{
let
cm
=
editors
.
get
(
this
)
;
let
sel
=
cm
.
getSelection
(
)
;
let
match
=
sel
.
match
(
RE_SCRATCHPAD_ERROR
)
;
if
(
match
)
{
let
[
line
column
]
=
match
;
inp
.
value
=
column
?
line
+
"
:
"
+
column
:
line
;
inp
.
selectionStart
=
inp
.
selectionEnd
=
inp
.
value
.
length
;
}
}
this
.
openDialog
(
div
(
line
)
=
>
{
let
match
=
line
.
toString
(
)
.
match
(
RE_JUMP_TO_LINE
)
;
if
(
match
)
{
let
[
matchLine
column
]
=
match
;
this
.
setCursor
(
{
line
:
matchLine
-
1
ch
:
column
?
column
-
1
:
0
}
)
;
}
}
)
;
}
moveLineUp
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
let
start
=
cm
.
getCursor
(
"
start
"
)
;
let
end
=
cm
.
getCursor
(
"
end
"
)
;
if
(
start
.
line
=
=
=
0
)
{
return
;
}
let
value
;
if
(
start
.
line
!
=
=
end
.
line
)
{
value
=
cm
.
getRange
(
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
+
"
\
n
"
;
}
else
{
value
=
cm
.
getLine
(
start
.
line
)
+
"
\
n
"
;
}
value
+
=
cm
.
getLine
(
start
.
line
-
1
)
;
cm
.
replaceRange
(
value
{
line
:
start
.
line
-
1
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
;
cm
.
setSelection
(
{
line
:
start
.
line
-
1
ch
:
start
.
ch
}
{
line
:
end
.
line
-
1
ch
:
end
.
ch
}
)
;
}
moveLineDown
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
let
start
=
cm
.
getCursor
(
"
start
"
)
;
let
end
=
cm
.
getCursor
(
"
end
"
)
;
if
(
end
.
line
+
1
=
=
=
cm
.
lineCount
(
)
)
{
return
;
}
let
value
=
cm
.
getLine
(
end
.
line
+
1
)
+
"
\
n
"
;
if
(
start
.
line
!
=
=
end
.
line
)
{
value
+
=
cm
.
getRange
(
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
;
}
else
{
value
+
=
cm
.
getLine
(
start
.
line
)
;
}
cm
.
replaceRange
(
value
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
+
1
ch
:
cm
.
getLine
(
end
.
line
+
1
)
.
length
}
)
;
cm
.
setSelection
(
{
line
:
start
.
line
+
1
ch
:
start
.
ch
}
{
line
:
end
.
line
+
1
ch
:
end
.
ch
}
)
;
}
findOrReplace
:
function
(
node
isReplaceAll
)
{
let
cm
=
editors
.
get
(
this
)
;
let
isInput
=
node
.
tagName
=
=
=
"
INPUT
"
;
let
isSearchInput
=
isInput
&
&
node
.
type
=
=
=
"
search
"
;
let
isDialogInput
=
isInput
&
&
node
.
parentNode
&
&
node
.
parentNode
.
classList
.
contains
(
"
CodeMirror
-
dialog
"
)
;
if
(
!
(
isSearchInput
|
|
isDialogInput
)
)
{
return
;
}
if
(
isSearchInput
|
|
isReplaceAll
)
{
node
.
select
(
)
;
}
cm
.
execCommand
(
"
find
"
)
;
}
findNextOrPrev
:
function
(
node
isFindPrev
)
{
let
cm
=
editors
.
get
(
this
)
;
let
isInput
=
node
.
tagName
=
=
=
"
INPUT
"
;
let
isSearchInput
=
isInput
&
&
node
.
type
=
=
=
"
search
"
;
if
(
!
isSearchInput
)
{
return
;
}
let
query
=
node
.
value
;
if
(
!
cm
.
state
.
search
|
|
cm
.
state
.
search
.
query
!
=
=
query
)
{
cm
.
state
.
search
=
{
posFrom
:
null
posTo
:
null
overlay
:
null
query
}
;
}
if
(
isFindPrev
)
{
cm
.
execCommand
(
"
findPrev
"
)
;
}
else
{
cm
.
execCommand
(
"
findNext
"
)
;
}
}
getFontSize
:
function
(
)
{
let
cm
=
editors
.
get
(
this
)
;
let
el
=
cm
.
getWrapperElement
(
)
;
let
win
=
el
.
ownerDocument
.
defaultView
;
return
parseInt
(
win
.
getComputedStyle
(
el
)
.
getPropertyValue
(
"
font
-
size
"
)
10
)
;
}
setFontSize
:
function
(
size
)
{
let
cm
=
editors
.
get
(
this
)
;
cm
.
getWrapperElement
(
)
.
style
.
fontSize
=
parseInt
(
size
10
)
+
"
px
"
;
cm
.
refresh
(
)
;
}
setOption
:
function
(
o
v
)
{
let
cm
=
editors
.
get
(
this
)
;
if
(
o
=
=
=
"
autoCloseBrackets
"
&
&
v
)
{
this
.
config
.
autoCloseBracketsSaved
=
v
;
}
if
(
o
=
=
=
"
autocomplete
"
)
{
this
.
config
.
autocomplete
=
v
;
this
.
setupAutoCompletion
(
)
;
}
else
{
cm
.
setOption
(
o
v
)
;
this
.
config
[
o
]
=
v
;
}
if
(
o
=
=
=
"
enableCodeFolding
"
)
{
this
.
updateCodeFoldingGutter
(
)
;
}
}
getOption
:
function
(
o
)
{
let
cm
=
editors
.
get
(
this
)
;
if
(
o
=
=
=
"
autocomplete
"
)
{
return
this
.
config
.
autocomplete
;
}
return
cm
.
getOption
(
o
)
;
}
setupAutoCompletion
:
function
(
)
{
if
(
!
this
.
initializeAutoCompletion
)
{
this
.
extend
(
require
(
"
.
/
autocomplete
"
)
)
;
}
if
(
this
.
config
.
autocomplete
&
&
Services
.
prefs
.
getBoolPref
(
AUTOCOMPLETE
)
)
{
this
.
initializeAutoCompletion
(
this
.
config
.
autocompleteOpts
)
;
}
else
{
this
.
destroyAutoCompletion
(
)
;
}
}
extend
:
function
(
funcs
)
{
Object
.
keys
(
funcs
)
.
forEach
(
name
=
>
{
let
cm
=
editors
.
get
(
this
)
;
let
ctx
=
{
ed
:
this
cm
:
cm
Editor
:
Editor
}
;
if
(
name
=
=
=
"
initialize
"
)
{
funcs
[
name
]
(
ctx
)
;
return
;
}
this
[
name
]
=
funcs
[
name
]
.
bind
(
null
ctx
)
;
}
)
;
}
destroy
:
function
(
)
{
this
.
container
=
null
;
this
.
config
=
null
;
this
.
version
=
null
;
if
(
this
.
_prefObserver
)
{
this
.
_prefObserver
.
off
(
TAB_SIZE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
EXPAND_TAB
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
KEYMAP
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
AUTO_CLOSE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
AUTOCOMPLETE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
DETECT_INDENT
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
ENABLE_CODE_FOLDING
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
destroy
(
)
;
}
let
cm
=
editors
.
get
(
this
)
;
if
(
cm
&
&
cm
.
doc
)
{
cm
.
doc
.
cm
=
null
;
}
this
.
emit
(
"
destroy
"
)
;
}
updateCodeFoldingGutter
:
function
(
)
{
let
shouldFoldGutter
=
this
.
config
.
enableCodeFolding
;
let
foldGutterIndex
=
this
.
config
.
gutters
.
indexOf
(
"
CodeMirror
-
foldgutter
"
)
;
let
cm
=
editors
.
get
(
this
)
;
if
(
shouldFoldGutter
=
=
=
undefined
)
{
shouldFoldGutter
=
Services
.
prefs
.
getBoolPref
(
ENABLE_CODE_FOLDING
)
;
}
if
(
shouldFoldGutter
)
{
if
(
foldGutterIndex
=
=
=
-
1
)
{
let
gutters
=
this
.
config
.
gutters
.
slice
(
)
;
gutters
.
push
(
"
CodeMirror
-
foldgutter
"
)
;
this
.
setOption
(
"
gutters
"
gutters
)
;
}
this
.
setOption
(
"
foldGutter
"
true
)
;
}
else
{
if
(
cm
)
{
cm
.
execCommand
(
"
unfoldAll
"
)
;
}
if
(
foldGutterIndex
!
=
=
-
1
)
{
let
gutters
=
this
.
config
.
gutters
.
slice
(
)
;
gutters
.
splice
(
foldGutterIndex
1
)
;
this
.
setOption
(
"
gutters
"
gutters
)
;
}
this
.
setOption
(
"
foldGutter
"
false
)
;
}
}
_initShortcuts
:
function
(
win
)
{
let
shortcuts
=
new
KeyShortcuts
(
{
window
:
win
}
)
;
this
.
_onShortcut
=
this
.
_onShortcut
.
bind
(
this
)
;
let
keys
=
[
"
find
.
key
"
"
findNext
.
key
"
"
findPrev
.
key
"
]
;
if
(
OS
=
=
=
"
Darwin
"
)
{
keys
.
push
(
"
replaceAllMac
.
key
"
)
;
}
else
{
keys
.
push
(
"
replaceAll
.
key
"
)
;
}
keys
.
forEach
(
name
=
>
{
let
key
=
L10N
.
getStr
(
name
)
;
shortcuts
.
on
(
key
event
=
>
this
.
_onShortcut
(
name
event
)
)
;
}
)
;
}
_onShortcut
:
function
(
name
event
)
{
if
(
!
this
.
_isInputOrTextarea
(
event
.
target
)
)
{
return
;
}
let
node
=
event
.
originalTarget
;
switch
(
name
)
{
case
"
replaceAllMac
.
key
"
:
this
.
findOrReplace
(
node
true
)
;
break
;
case
"
replaceAll
.
key
"
:
this
.
findOrReplace
(
node
true
)
;
break
;
case
"
find
.
key
"
:
this
.
findOrReplace
(
node
false
)
;
break
;
case
"
findPrev
.
key
"
:
this
.
findNextOrPrev
(
node
true
)
;
break
;
case
"
findNext
.
key
"
:
this
.
findNextOrPrev
(
node
false
)
;
break
;
default
:
console
.
error
(
"
Unexpected
editor
key
shortcut
"
name
)
;
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
_isInputOrTextarea
:
function
(
element
)
{
let
name
=
element
.
tagName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
|
|
name
=
=
=
"
textarea
"
;
}
}
;
CM_MAPPING
.
forEach
(
name
=
>
{
Editor
.
prototype
[
name
]
=
function
(
.
.
.
args
)
{
let
cm
=
editors
.
get
(
this
)
;
return
cm
[
name
]
.
apply
(
cm
args
)
;
}
;
}
)
;
Editor
.
accel
=
function
(
key
modifiers
=
{
}
)
{
return
(
modifiers
.
shift
?
"
Shift
-
"
:
"
"
)
+
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
?
"
Cmd
-
"
:
"
Ctrl
-
"
)
+
(
modifiers
.
alt
?
"
Alt
-
"
:
"
"
)
+
key
;
}
;
Editor
.
keyFor
=
function
(
cmd
opts
=
{
noaccel
:
false
}
)
{
let
key
=
L10N
.
getStr
(
cmd
+
"
.
commandkey
"
)
;
return
opts
.
noaccel
?
key
:
Editor
.
accel
(
key
)
;
}
;
function
getCSSKeywords
(
cssProperties
)
{
function
keySet
(
array
)
{
let
keys
=
{
}
;
for
(
let
i
=
0
;
i
<
array
.
length
;
+
+
i
)
{
keys
[
array
[
i
]
]
=
true
;
}
return
keys
;
}
let
propertyKeywords
=
cssProperties
.
getNames
(
)
;
let
colorKeywords
=
{
}
;
let
valueKeywords
=
{
}
;
propertyKeywords
.
forEach
(
property
=
>
{
if
(
property
.
includes
(
"
color
"
)
)
{
cssProperties
.
getValues
(
property
)
.
forEach
(
value
=
>
{
colorKeywords
[
value
]
=
true
;
}
)
;
}
else
{
cssProperties
.
getValues
(
property
)
.
forEach
(
value
=
>
{
valueKeywords
[
value
]
=
true
;
}
)
;
}
}
)
;
return
{
propertyKeywords
:
keySet
(
propertyKeywords
)
colorKeywords
:
colorKeywords
valueKeywords
:
valueKeywords
}
;
}
module
.
exports
=
Editor
;
