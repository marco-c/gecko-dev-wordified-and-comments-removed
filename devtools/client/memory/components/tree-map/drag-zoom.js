"
use
strict
"
;
const
{
debounce
}
=
require
(
"
sdk
/
lang
/
functional
"
)
;
const
{
lerp
}
=
require
(
"
devtools
/
client
/
memory
/
utils
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
LERP_SPEED
=
0
.
5
;
const
ZOOM_SPEED
=
0
.
01
;
const
TRANSLATE_EPSILON
=
1
;
const
ZOOM_EPSILON
=
0
.
001
;
const
LINE_SCROLL_MODE
=
1
;
const
SCROLL_LINE_SIZE
=
15
;
function
DragZoom
(
container
debounceRate
requestAnimationFrame
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
isDragging
=
false
;
this
.
mouseX
=
container
.
offsetWidth
/
2
;
this
.
mouseY
=
container
.
offsetHeight
/
2
;
this
.
zoomedWidth
=
container
.
offsetWidth
;
this
.
zoomedHeight
=
container
.
offsetHeight
;
this
.
zoom
=
0
;
this
.
translateX
=
0
;
this
.
translateY
=
0
;
this
.
offsetX
=
0
;
this
.
offsetY
=
0
;
this
.
smoothZoom
=
0
;
this
.
smoothTranslateX
=
0
;
this
.
smoothTranslateY
=
0
;
this
.
ZOOM_SPEED
=
ZOOM_SPEED
;
this
.
ZOOM_EPSILON
=
ZOOM_EPSILON
;
let
update
=
createUpdateLoop
(
container
this
requestAnimationFrame
)
;
this
.
destroy
=
setHandlers
(
this
container
update
debounceRate
)
;
}
module
.
exports
=
DragZoom
;
function
createUpdateLoop
(
container
dragZoom
requestAnimationFrame
)
{
let
isLooping
=
false
;
function
update
(
)
{
let
isScrollChanging
=
(
Math
.
abs
(
dragZoom
.
smoothZoom
-
dragZoom
.
zoom
)
>
ZOOM_EPSILON
)
;
let
isTranslateChanging
=
(
Math
.
abs
(
dragZoom
.
smoothTranslateX
-
dragZoom
.
translateX
)
>
TRANSLATE_EPSILON
|
|
Math
.
abs
(
dragZoom
.
smoothTranslateY
-
dragZoom
.
translateY
)
>
TRANSLATE_EPSILON
)
;
isLooping
=
isScrollChanging
|
|
isTranslateChanging
;
if
(
isScrollChanging
)
{
dragZoom
.
smoothZoom
=
lerp
(
dragZoom
.
smoothZoom
dragZoom
.
zoom
LERP_SPEED
)
;
}
else
{
dragZoom
.
smoothZoom
=
dragZoom
.
zoom
;
}
if
(
isTranslateChanging
)
{
dragZoom
.
smoothTranslateX
=
lerp
(
dragZoom
.
smoothTranslateX
dragZoom
.
translateX
LERP_SPEED
)
;
dragZoom
.
smoothTranslateY
=
lerp
(
dragZoom
.
smoothTranslateY
dragZoom
.
translateY
LERP_SPEED
)
;
}
else
{
dragZoom
.
smoothTranslateX
=
dragZoom
.
translateX
;
dragZoom
.
smoothTranslateY
=
dragZoom
.
translateY
;
}
let
zoom
=
1
+
dragZoom
.
smoothZoom
;
let
x
=
dragZoom
.
smoothTranslateX
;
let
y
=
dragZoom
.
smoothTranslateY
;
container
.
style
.
transform
=
translate
(
{
x
}
px
{
y
}
px
)
scale
(
{
zoom
}
)
;
if
(
isLooping
)
{
requestAnimationFrame
(
update
)
;
}
}
update
(
)
;
return
function
restartLoopingIfStopped
(
)
{
if
(
!
isLooping
)
{
update
(
)
;
}
}
;
}
function
setHandlers
(
dragZoom
container
update
debounceRate
)
{
let
emitChanged
=
debounce
(
(
)
=
>
dragZoom
.
emit
(
"
change
"
)
debounceRate
)
;
let
removeDragHandlers
=
setDragHandlers
(
container
dragZoom
emitChanged
update
)
;
let
removeScrollHandlers
=
setScrollHandlers
(
container
dragZoom
emitChanged
update
)
;
return
function
removeHandlers
(
)
{
removeDragHandlers
(
)
;
removeScrollHandlers
(
)
;
}
;
}
function
setDragHandlers
(
container
dragZoom
emitChanged
update
)
{
let
parentEl
=
container
.
parentElement
;
function
startDrag
(
)
{
dragZoom
.
isDragging
=
true
;
container
.
style
.
cursor
=
"
grabbing
"
;
}
function
stopDrag
(
)
{
dragZoom
.
isDragging
=
false
;
container
.
style
.
cursor
=
"
grab
"
;
}
function
drag
(
event
)
{
let
prevMouseX
=
dragZoom
.
mouseX
;
let
prevMouseY
=
dragZoom
.
mouseY
;
dragZoom
.
mouseX
=
event
.
clientX
-
parentEl
.
offsetLeft
;
dragZoom
.
mouseY
=
event
.
clientY
-
parentEl
.
offsetTop
;
if
(
!
dragZoom
.
isDragging
)
{
return
;
}
dragZoom
.
translateX
+
=
dragZoom
.
mouseX
-
prevMouseX
;
dragZoom
.
translateY
+
=
dragZoom
.
mouseY
-
prevMouseY
;
keepInView
(
container
dragZoom
)
;
emitChanged
(
)
;
update
(
)
;
}
parentEl
.
addEventListener
(
"
mousedown
"
startDrag
false
)
;
parentEl
.
addEventListener
(
"
mouseup
"
stopDrag
false
)
;
parentEl
.
addEventListener
(
"
mouseout
"
stopDrag
false
)
;
parentEl
.
addEventListener
(
"
mousemove
"
drag
false
)
;
return
function
removeListeners
(
)
{
parentEl
.
removeEventListener
(
"
mousedown
"
startDrag
false
)
;
parentEl
.
removeEventListener
(
"
mouseup
"
stopDrag
false
)
;
parentEl
.
removeEventListener
(
"
mouseout
"
stopDrag
false
)
;
parentEl
.
removeEventListener
(
"
mousemove
"
drag
false
)
;
}
;
}
function
setScrollHandlers
(
container
dragZoom
emitChanged
update
)
{
let
window
=
container
.
ownerDocument
.
defaultView
;
function
handleWheel
(
event
)
{
event
.
preventDefault
(
)
;
if
(
dragZoom
.
isDragging
)
{
return
;
}
let
scrollDelta
=
getScrollDelta
(
event
window
)
;
let
prevZoom
=
dragZoom
.
zoom
;
dragZoom
.
zoom
=
Math
.
max
(
0
dragZoom
.
zoom
-
scrollDelta
*
ZOOM_SPEED
)
;
let
deltaZoom
=
dragZoom
.
zoom
-
prevZoom
;
let
prevZoomedWidth
=
container
.
offsetWidth
*
(
1
+
prevZoom
)
;
let
prevZoomedHeight
=
container
.
offsetHeight
*
(
1
+
prevZoom
)
;
dragZoom
.
zoomedWidth
=
container
.
offsetWidth
*
(
1
+
dragZoom
.
zoom
)
;
dragZoom
.
zoomedHeight
=
container
.
offsetHeight
*
(
1
+
dragZoom
.
zoom
)
;
let
deltaWidth
=
dragZoom
.
zoomedWidth
-
prevZoomedWidth
;
let
deltaHeight
=
dragZoom
.
zoomedHeight
-
prevZoomedHeight
;
let
mouseOffsetX
=
dragZoom
.
mouseX
-
container
.
offsetWidth
/
2
;
let
mouseOffsetY
=
dragZoom
.
mouseY
-
container
.
offsetHeight
/
2
;
let
ratioZoomX
=
(
prevZoomedWidth
/
2
+
mouseOffsetX
-
dragZoom
.
translateX
)
/
prevZoomedWidth
;
let
ratioZoomY
=
(
prevZoomedHeight
/
2
+
mouseOffsetY
-
dragZoom
.
translateY
)
/
prevZoomedHeight
;
dragZoom
.
translateX
-
=
lerp
(
-
deltaWidth
/
2
deltaWidth
/
2
ratioZoomX
)
;
dragZoom
.
translateY
-
=
lerp
(
-
deltaHeight
/
2
deltaHeight
/
2
ratioZoomY
)
;
keepInView
(
container
dragZoom
)
;
emitChanged
(
)
;
update
(
)
;
}
container
.
addEventListener
(
"
wheel
"
handleWheel
false
)
;
return
function
removeListener
(
)
{
container
.
removeEventListener
(
"
wheel
"
handleWheel
false
)
;
}
;
}
function
getScrollDelta
(
event
window
)
{
if
(
event
.
deltaMode
=
=
=
LINE_SCROLL_MODE
)
{
return
event
.
deltaY
*
SCROLL_LINE_SIZE
;
}
return
event
.
deltaY
;
}
function
keepInView
(
container
dragZoom
)
{
let
{
devicePixelRatio
}
=
container
.
ownerDocument
.
defaultView
;
let
overdrawX
=
(
dragZoom
.
zoomedWidth
-
container
.
offsetWidth
)
/
2
;
let
overdrawY
=
(
dragZoom
.
zoomedHeight
-
container
.
offsetHeight
)
/
2
;
dragZoom
.
translateX
=
Math
.
max
(
-
overdrawX
Math
.
min
(
overdrawX
dragZoom
.
translateX
)
)
;
dragZoom
.
translateY
=
Math
.
max
(
-
overdrawY
Math
.
min
(
overdrawY
dragZoom
.
translateY
)
)
;
dragZoom
.
offsetX
=
devicePixelRatio
*
(
(
dragZoom
.
zoomedWidth
-
container
.
offsetWidth
)
/
2
-
dragZoom
.
translateX
)
;
dragZoom
.
offsetY
=
devicePixelRatio
*
(
(
dragZoom
.
zoomedHeight
-
container
.
offsetHeight
)
/
2
-
dragZoom
.
translateY
)
;
}
