"
use
strict
"
;
const
colorCoarseType
=
require
(
"
.
/
color
-
coarse
-
type
"
)
;
const
{
hslToStyle
formatAbbreviatedBytes
L10N
}
=
require
(
"
devtools
/
client
/
memory
/
utils
"
)
;
const
NO_SCROLL
=
{
translateX
:
0
translateY
:
0
zoom
:
0
offsetX
:
0
offsetY
:
0
}
;
const
ELLIPSIS
=
"
.
.
.
"
;
const
TEXT_MARGIN
=
2
;
const
TEXT_COLOR
=
"
#
000000
"
;
const
TEXT_LIGHT_COLOR
=
"
rgba
(
0
0
0
0
.
5
)
"
;
const
LINE_WIDTH
=
1
;
const
FONT_SIZE
=
10
;
const
FONT_LINE_HEIGHT
=
2
;
const
PADDING
=
[
5
+
FONT_SIZE
5
5
5
]
;
const
COUNT_LABEL
=
L10N
.
getStr
(
"
tree
-
map
.
node
-
count
"
)
;
exports
.
setupDraw
=
function
(
report
canvases
dragZoom
)
{
const
getTreemap
=
configureD3Treemap
.
bind
(
null
canvases
.
main
.
canvas
)
;
let
treemap
nodes
;
function
drawFullTreemap
(
)
{
treemap
=
getTreemap
(
)
;
nodes
=
treemap
(
report
)
;
drawTreemap
(
canvases
.
main
nodes
NO_SCROLL
)
;
drawTreemap
(
canvases
.
zoom
nodes
dragZoom
)
;
}
function
drawZoomedTreemap
(
)
{
drawTreemap
(
canvases
.
zoom
nodes
dragZoom
)
;
positionZoomedCanvas
(
canvases
.
zoom
.
canvas
dragZoom
)
;
}
drawFullTreemap
(
)
;
canvases
.
on
(
"
resize
"
drawFullTreemap
)
;
dragZoom
.
on
(
"
change
"
drawZoomedTreemap
)
;
}
;
const
configureD3Treemap
=
(
exports
.
configureD3Treemap
=
function
(
canvas
)
{
const
window
=
canvas
.
ownerDocument
.
defaultView
;
const
ratio
=
window
.
devicePixelRatio
;
const
treemap
=
window
.
d3
.
layout
.
treemap
(
)
.
size
(
[
canvas
.
width
+
(
PADDING
[
1
]
+
PADDING
[
3
]
)
*
ratio
canvas
.
height
+
(
PADDING
[
0
]
+
PADDING
[
2
]
)
*
ratio
]
)
.
sticky
(
true
)
.
padding
(
[
PADDING
[
0
]
*
ratio
PADDING
[
1
]
*
ratio
PADDING
[
2
]
*
ratio
PADDING
[
3
]
*
ratio
]
)
.
value
(
d
=
>
d
.
bytes
)
;
return
function
depthSortedNodes
(
report
)
{
const
nodes
=
treemap
(
report
)
;
nodes
.
sort
(
(
a
b
)
=
>
a
.
depth
-
b
.
depth
)
;
return
nodes
;
}
;
}
)
;
const
drawTruncatedName
=
(
exports
.
drawTruncatedName
=
function
(
ctx
x
y
innerWidth
name
)
{
const
truncated
=
name
.
substr
(
0
Math
.
floor
(
name
.
length
/
2
)
)
;
const
formatted
=
truncated
+
ELLIPSIS
;
if
(
ctx
.
measureText
(
formatted
)
.
width
>
innerWidth
)
{
drawTruncatedName
(
ctx
x
y
innerWidth
truncated
)
;
}
else
{
ctx
.
fillText
(
formatted
x
y
)
;
}
}
)
;
const
drawText
=
(
exports
.
drawText
=
function
(
ctx
node
borderWidth
ratio
dragZoom
padding
)
{
let
{
dx
dy
name
totalBytes
totalCount
}
=
node
;
const
scale
=
dragZoom
.
zoom
+
1
;
dx
*
=
scale
;
dy
*
=
scale
;
if
(
FONT_SIZE
*
FONT_LINE_HEIGHT
<
dy
)
{
const
margin
=
borderWidth
(
node
)
*
1
.
5
+
ratio
*
TEXT_MARGIN
;
const
x
=
margin
+
(
node
.
x
-
padding
[
0
]
)
*
scale
-
dragZoom
.
offsetX
;
const
y
=
margin
+
(
node
.
y
-
padding
[
1
]
)
*
scale
-
dragZoom
.
offsetY
;
const
innerWidth
=
dx
-
margin
*
2
;
const
nameSize
=
ctx
.
measureText
(
name
)
.
width
;
if
(
ctx
.
measureText
(
ELLIPSIS
)
.
width
>
innerWidth
)
{
return
;
}
ctx
.
fillStyle
=
TEXT_COLOR
;
if
(
nameSize
>
innerWidth
)
{
drawTruncatedName
(
ctx
x
y
innerWidth
name
)
;
}
else
{
const
bytesFormatted
=
formatAbbreviatedBytes
(
totalBytes
)
;
const
countFormatted
=
{
totalCount
}
{
COUNT_LABEL
}
;
const
byteSize
=
ctx
.
measureText
(
bytesFormatted
)
.
width
;
const
countSize
=
ctx
.
measureText
(
countFormatted
)
.
width
;
const
spaceSize
=
ctx
.
measureText
(
"
"
)
.
width
;
if
(
nameSize
+
byteSize
+
countSize
+
spaceSize
*
3
>
innerWidth
)
{
ctx
.
fillText
(
{
name
}
x
y
)
;
}
else
{
ctx
.
fillText
(
name
x
y
)
;
ctx
.
fillStyle
=
TEXT_LIGHT_COLOR
;
ctx
.
fillText
(
{
bytesFormatted
}
{
countFormatted
}
x
+
nameSize
+
spaceSize
y
)
;
}
}
}
}
)
;
const
drawBox
=
(
exports
.
drawBox
=
function
(
ctx
node
borderWidth
dragZoom
padding
)
{
const
border
=
borderWidth
(
node
)
;
const
fillHSL
=
colorCoarseType
(
node
)
;
const
strokeHSL
=
[
fillHSL
[
0
]
fillHSL
[
1
]
fillHSL
[
2
]
*
0
.
5
]
;
const
scale
=
1
+
dragZoom
.
zoom
;
const
x
=
scale
*
(
node
.
x
-
padding
[
0
]
)
-
dragZoom
.
offsetX
+
border
/
2
;
const
y
=
scale
*
(
node
.
y
-
padding
[
1
]
)
-
dragZoom
.
offsetY
+
border
/
2
;
const
dx
=
scale
*
node
.
dx
-
border
;
const
dy
=
scale
*
node
.
dy
-
border
;
ctx
.
fillStyle
=
hslToStyle
(
.
.
.
fillHSL
)
;
ctx
.
fillRect
(
x
y
dx
dy
)
;
ctx
.
strokeStyle
=
hslToStyle
(
.
.
.
strokeHSL
)
;
ctx
.
lineWidth
=
border
;
ctx
.
strokeRect
(
x
y
dx
dy
)
;
}
)
;
const
drawTreemap
=
(
exports
.
drawTreemap
=
function
(
{
canvas
ctx
}
nodes
dragZoom
)
{
const
window
=
canvas
.
ownerDocument
.
defaultView
;
const
ratio
=
window
.
devicePixelRatio
;
const
canvasArea
=
canvas
.
width
*
canvas
.
height
;
const
padding
=
[
PADDING
[
3
]
*
ratio
PADDING
[
0
]
*
ratio
]
;
ctx
.
clearRect
(
0
0
canvas
.
width
canvas
.
height
)
;
ctx
.
font
=
{
FONT_SIZE
*
ratio
}
px
sans
-
serif
;
ctx
.
textBaseline
=
"
top
"
;
function
borderWidth
(
node
)
{
const
areaRatio
=
Math
.
sqrt
(
node
.
area
/
canvasArea
)
;
return
ratio
*
Math
.
max
(
1
LINE_WIDTH
*
areaRatio
)
;
}
for
(
let
i
=
0
;
i
<
nodes
.
length
;
i
+
+
)
{
const
node
=
nodes
[
i
]
;
if
(
node
.
parent
=
=
=
undefined
)
{
continue
;
}
drawBox
(
ctx
node
borderWidth
dragZoom
padding
)
;
drawText
(
ctx
node
borderWidth
ratio
dragZoom
padding
)
;
}
}
)
;
const
positionZoomedCanvas
=
function
(
canvas
dragZoom
)
{
const
scale
=
1
/
(
1
+
dragZoom
.
zoom
)
;
const
x
=
-
dragZoom
.
translateX
;
const
y
=
-
dragZoom
.
translateY
;
canvas
.
style
.
transform
=
scale
(
{
scale
}
)
translate
(
{
x
}
px
{
y
}
px
)
;
}
;
exports
.
positionZoomedCanvas
=
positionZoomedCanvas
;
