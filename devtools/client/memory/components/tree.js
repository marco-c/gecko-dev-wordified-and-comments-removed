const
{
DOM
:
dom
createClass
createFactory
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
ViewHelpers
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
ViewHelpers
.
jsm
"
)
;
const
AUTO_EXPAND_DEPTH
=
3
;
const
ArrowExpander
=
createFactory
(
createClass
(
{
displayName
:
"
ArrowExpander
"
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
visible
!
=
nextProps
.
visible
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
attrs
=
{
className
:
"
arrow
theme
-
twisty
"
onClick
:
this
.
props
.
expanded
?
(
)
=
>
this
.
props
.
onCollapse
(
this
.
props
.
item
)
:
e
=
>
this
.
props
.
onExpand
(
this
.
props
.
item
e
.
altKey
)
}
;
if
(
this
.
props
.
expanded
)
{
attrs
.
className
+
=
"
open
"
;
}
if
(
!
this
.
props
.
visible
)
{
attrs
.
style
=
{
visibility
:
"
hidden
"
}
;
}
return
dom
.
div
(
attrs
)
;
}
}
)
)
;
const
TreeNode
=
createFactory
(
createClass
(
{
componentDidUpdate
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
render
(
)
{
const
arrow
=
ArrowExpander
(
{
item
:
this
.
props
.
item
expanded
:
this
.
props
.
expanded
visible
:
this
.
props
.
hasChildren
onExpand
:
this
.
props
.
onExpand
onCollapse
:
this
.
props
.
onCollapse
}
)
;
return
dom
.
div
(
{
className
:
"
tree
-
node
div
"
onFocus
:
this
.
props
.
onFocus
onClick
:
this
.
props
.
onFocus
onBlur
:
this
.
props
.
onBlur
style
:
{
padding
:
0
margin
:
0
}
}
this
.
props
.
renderItem
(
this
.
props
.
item
this
.
props
.
depth
this
.
props
.
focused
arrow
this
.
props
.
expanded
)
dom
.
button
(
this
.
_buttonAttrs
)
)
;
}
_buttonAttrs
:
{
ref
:
"
button
"
style
:
{
opacity
:
0
width
:
"
0
!
important
"
height
:
"
0
!
important
"
padding
:
"
0
!
important
"
outline
:
"
none
"
MozAppearance
:
"
none
"
MozMarginStart
:
"
-
1000px
!
important
"
}
}
}
)
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
return
function
(
.
.
.
args
)
{
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
animationId
=
null
;
fn
.
call
(
this
.
.
.
args
)
;
}
)
;
}
;
}
const
NUMBER_OF_OFFSCREEN_ITEMS
=
1
;
const
Tree
=
module
.
exports
=
createClass
(
{
displayName
:
"
Tree
"
propTypes
:
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
itemHeight
:
PropTypes
.
number
.
isRequired
filter
:
PropTypes
.
func
autoExpandDepth
:
PropTypes
.
number
reuseCachedTraversal
:
PropTypes
.
func
}
getDefaultProps
(
)
{
return
{
filter
:
item
=
>
true
expanded
:
new
Set
(
)
seen
:
new
Set
(
)
focused
:
undefined
autoExpandDepth
:
AUTO_EXPAND_DEPTH
reuseCachedTraversal
:
null
}
;
}
getInitialState
(
)
{
return
{
scroll
:
0
height
:
window
.
innerHeight
expanded
:
new
Set
(
)
seen
:
new
Set
(
)
focused
:
undefined
cachedTraversal
:
undefined
}
;
}
componentDidMount
(
)
{
window
.
addEventListener
(
"
resize
"
this
.
_updateHeight
)
;
this
.
_updateHeight
(
)
;
}
componentWillUnmount
(
)
{
window
.
removeEventListener
(
"
resize
"
this
.
_updateHeight
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
!
this
.
props
.
autoExpandDepth
)
{
return
;
}
for
(
let
{
item
}
of
this
.
_dfsFromRoots
(
this
.
props
.
autoExpandDepth
)
)
{
if
(
!
this
.
state
.
seen
.
has
(
item
)
)
{
this
.
state
.
expanded
.
add
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
}
}
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
begin
=
Math
.
max
(
(
(
this
.
state
.
scroll
/
this
.
props
.
itemHeight
)
|
0
)
-
NUMBER_OF_OFFSCREEN_ITEMS
0
)
;
const
end
=
begin
+
(
2
*
NUMBER_OF_OFFSCREEN_ITEMS
)
+
(
(
this
.
state
.
height
/
this
.
props
.
itemHeight
)
|
0
)
;
const
toRender
=
traversal
.
slice
(
begin
end
)
;
const
nodes
=
[
dom
.
div
(
{
key
:
"
top
-
spacer
"
style
:
{
padding
:
0
margin
:
0
height
:
begin
*
this
.
props
.
itemHeight
+
"
px
"
}
}
)
]
;
for
(
let
i
=
0
;
i
<
toRender
.
length
;
i
+
+
)
{
let
{
item
depth
}
=
toRender
[
i
]
;
nodes
.
push
(
TreeNode
(
{
key
:
this
.
props
.
getKey
(
item
)
item
:
item
depth
:
depth
renderItem
:
this
.
props
.
renderItem
focused
:
this
.
state
.
focused
=
=
=
item
expanded
:
this
.
state
.
expanded
.
has
(
item
)
hasChildren
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onFocus
:
(
)
=
>
this
.
_onFocus
(
item
)
}
)
)
;
}
nodes
.
push
(
dom
.
div
(
{
key
:
"
bottom
-
spacer
"
style
:
{
padding
:
0
margin
:
0
height
:
(
traversal
.
length
-
1
-
end
)
*
this
.
props
.
itemHeight
+
"
px
"
}
}
)
)
;
return
dom
.
div
(
{
className
:
"
tree
"
ref
:
"
tree
"
onKeyDown
:
this
.
_onKeyDown
onScroll
:
this
.
_onScroll
style
:
{
padding
:
0
margin
:
0
}
}
nodes
)
;
}
_updateHeight
(
)
{
this
.
setState
(
{
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
if
(
!
this
.
props
.
filter
(
item
)
)
{
return
traversal
;
}
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
state
.
expanded
.
has
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
for
(
let
child
of
this
.
props
.
getChildren
(
item
)
)
{
this
.
_dfs
(
child
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
cached
=
this
.
state
.
cachedTraversal
;
if
(
cached
&
&
maxDepth
=
=
=
Infinity
&
&
this
.
props
.
reuseCachedTraversal
&
&
this
.
props
.
reuseCachedTraversal
(
cached
)
)
{
return
cached
;
}
const
traversal
=
[
]
;
for
(
let
root
of
this
.
props
.
getRoots
(
)
)
{
this
.
_dfs
(
root
maxDepth
traversal
)
;
}
if
(
this
.
props
.
reuseCachedTraversal
)
{
this
.
state
.
cachedTraversal
=
traversal
;
}
return
traversal
;
}
_onExpand
:
oncePerAnimationFrame
(
function
(
item
expandAllChildren
)
{
this
.
state
.
expanded
.
add
(
item
)
;
if
(
expandAllChildren
)
{
for
(
let
{
item
:
child
}
of
this
.
_dfs
(
item
)
)
{
this
.
state
.
expanded
.
add
(
child
)
;
}
}
this
.
setState
(
{
expanded
:
this
.
state
.
expanded
cachedTraversal
:
null
}
)
;
}
)
_onCollapse
:
oncePerAnimationFrame
(
function
(
item
)
{
this
.
state
.
expanded
.
delete
(
item
)
;
this
.
setState
(
{
expanded
:
this
.
state
.
expanded
cachedTraversal
:
null
}
)
;
}
)
_onFocus
:
oncePerAnimationFrame
(
function
(
item
)
{
this
.
setState
(
{
focused
:
item
}
)
;
}
)
_onBlur
:
oncePerAnimationFrame
(
function
(
)
{
this
.
setState
(
{
focused
:
undefined
}
)
;
}
)
_onScroll
:
oncePerAnimationFrame
(
function
(
e
)
{
this
.
setState
(
{
scroll
:
Math
.
max
(
this
.
refs
.
tree
.
scrollTop
0
)
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
)
_onKeyDown
(
e
)
{
if
(
this
.
state
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
nativeEvent
&
&
e
.
nativeEvent
.
preventDefault
)
{
ViewHelpers
.
preventScrolling
(
e
.
nativeEvent
)
;
}
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
false
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
false
;
case
"
ArrowLeft
"
:
if
(
this
.
state
.
expanded
.
has
(
this
.
state
.
focused
)
&
&
this
.
props
.
getChildren
(
this
.
state
.
focused
)
.
length
)
{
this
.
_onCollapse
(
this
.
state
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
false
;
case
"
ArrowRight
"
:
if
(
!
this
.
state
.
expanded
.
has
(
this
.
state
.
focused
)
)
{
this
.
_onExpand
(
this
.
state
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
false
;
}
}
_focusPrevNode
:
oncePerAnimationFrame
(
function
(
)
{
let
prev
;
for
(
let
{
item
}
of
this
.
_dfsFromRoots
(
)
)
{
if
(
item
=
=
=
this
.
state
.
focused
)
{
break
;
}
prev
=
item
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
setState
(
{
focused
:
prev
}
)
;
}
)
_focusNextNode
:
oncePerAnimationFrame
(
function
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
let
i
=
0
;
for
(
let
{
item
}
of
traversal
)
{
if
(
item
=
=
=
this
.
state
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
setState
(
{
focused
:
traversal
[
i
+
1
]
.
item
}
)
;
}
}
)
_focusParentNode
:
oncePerAnimationFrame
(
function
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
state
.
focused
)
;
if
(
parent
)
{
this
.
setState
(
{
focused
:
parent
}
)
;
}
}
)
}
)
;
