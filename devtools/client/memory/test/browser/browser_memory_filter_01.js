"
use
strict
"
;
const
{
dominatorTreeState
viewState
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
memory
/
constants
.
js
"
)
;
const
{
changeViewAndRefresh
changeView
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
memory
/
actions
/
view
.
js
"
)
;
const
TEST_URL
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
memory
/
test
/
browser
/
doc_steady_allocation
.
html
"
;
this
.
test
=
makeMemoryTest
(
TEST_URL
async
function
(
{
panel
}
)
{
const
heapWorker
=
panel
.
panelWin
.
gHeapAnalysesClient
;
const
store
=
panel
.
panelWin
.
gStore
;
const
{
dispatch
}
=
store
;
const
doc
=
panel
.
panelWin
.
document
;
dispatch
(
changeView
(
viewState
.
CENSUS
)
)
;
const
takeSnapshotButton
=
doc
.
getElementById
(
"
take
-
snapshot
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
takeSnapshotButton
{
}
panel
.
panelWin
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
.
length
=
=
=
1
&
&
state
.
snapshots
[
0
]
.
census
&
&
state
.
snapshots
[
0
]
.
census
.
state
=
=
=
censusState
.
SAVING
)
;
let
filterInput
=
doc
.
getElementById
(
"
filter
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
filterInput
{
}
panel
.
panelWin
)
;
EventUtils
.
sendString
(
"
js
:
:
Shape
"
panel
.
panelWin
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
.
length
=
=
=
1
&
&
state
.
snapshots
[
0
]
.
census
&
&
state
.
snapshots
[
0
]
.
census
.
state
=
=
=
censusState
.
SAVING
)
;
ok
(
true
"
adding
a
filter
string
should
trigger
census
recompute
"
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
.
length
=
=
=
1
&
&
state
.
snapshots
[
0
]
.
census
&
&
state
.
snapshots
[
0
]
.
census
.
state
=
=
=
censusState
.
SAVED
)
;
let
nameElem
=
doc
.
querySelector
(
"
.
heap
-
tree
-
item
-
field
.
heap
-
tree
-
item
-
name
"
)
;
ok
(
nameElem
"
Should
get
a
tree
item
row
with
a
name
"
)
;
is
(
nameElem
.
textContent
.
trim
(
)
"
js
:
:
Shape
"
"
the
tree
item
should
be
the
one
we
filtered
for
"
)
;
is
(
filterInput
.
value
"
js
:
:
Shape
"
"
and
filter
input
contains
the
user
value
"
)
;
dispatch
(
changeViewAndRefresh
(
viewState
.
DOMINATOR_TREE
heapWorker
)
)
;
ok
(
true
"
change
view
to
dominator
tree
"
)
;
await
waitUntilDominatorTreeState
(
store
[
dominatorTreeState
.
LOADED
]
)
;
ok
(
true
"
computed
and
fetched
the
dominator
tree
.
"
)
;
dispatch
(
changeViewAndRefresh
(
viewState
.
CENSUS
heapWorker
)
)
;
ok
(
true
"
change
view
back
to
census
"
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
.
length
=
=
=
1
&
&
state
.
snapshots
[
0
]
.
census
&
&
state
.
snapshots
[
0
]
.
census
.
state
=
=
=
censusState
.
SAVED
)
;
nameElem
=
doc
.
querySelector
(
"
.
heap
-
tree
-
item
-
field
.
heap
-
tree
-
item
-
name
"
)
;
filterInput
=
doc
.
getElementById
(
"
filter
"
)
;
ok
(
nameElem
"
Should
still
get
a
tree
item
row
with
a
name
"
)
;
is
(
nameElem
.
textContent
.
trim
(
)
"
js
:
:
Shape
"
"
the
tree
item
should
still
be
the
one
we
filtered
for
"
)
;
is
(
filterInput
.
value
"
js
:
:
Shape
"
"
and
filter
input
still
contains
the
user
value
"
)
;
}
)
;
