"
use
strict
"
;
const
{
dominatorTreeState
viewState
}
=
require
(
"
devtools
/
client
/
memory
/
constants
"
)
;
const
{
expandDominatorTreeNode
}
=
require
(
"
devtools
/
client
/
memory
/
actions
/
snapshot
"
)
;
const
{
changeView
}
=
require
(
"
devtools
/
client
/
memory
/
actions
/
view
"
)
;
const
TEST_URL
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
memory
/
test
/
browser
/
doc_big_tree
.
html
"
;
this
.
test
=
makeMemoryTest
(
TEST_URL
async
function
(
{
tab
panel
}
)
{
requestLongerTimeout
(
4
)
;
const
store
=
panel
.
panelWin
.
gStore
;
const
{
getState
dispatch
}
=
store
;
const
doc
=
panel
.
panelWin
.
document
;
dispatch
(
changeView
(
viewState
.
DOMINATOR_TREE
)
)
;
const
takeSnapshotButton
=
doc
.
getElementById
(
"
take
-
snapshot
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
takeSnapshotButton
{
}
panel
.
panelWin
)
;
await
waitUntilDominatorTreeState
(
store
[
dominatorTreeState
.
LOADED
]
)
;
ok
(
true
"
Computed
and
fetched
the
dominator
tree
.
"
)
;
const
id
=
getState
(
)
.
snapshots
[
0
]
.
id
;
const
root
=
getState
(
)
.
snapshots
[
0
]
.
dominatorTree
.
root
;
(
function
expandAllEagerlyFetched
(
node
=
root
)
{
if
(
!
node
.
moreChildrenAvailable
|
|
node
.
children
)
{
dispatch
(
expandDominatorTreeNode
(
id
node
)
)
;
}
if
(
node
.
children
)
{
for
(
let
child
of
node
.
children
)
{
expandAllEagerlyFetched
(
child
)
;
}
}
}
(
)
)
;
const
deepest
=
(
function
findDeepest
(
node
=
root
)
{
if
(
node
.
moreChildrenAvailable
&
&
!
node
.
children
)
{
return
node
;
}
if
(
node
.
children
)
{
for
(
let
child
of
node
.
children
)
{
const
found
=
findDeepest
(
child
)
;
if
(
found
)
{
return
found
;
}
}
}
return
null
;
}
(
)
)
;
ok
(
deepest
"
Found
the
deepest
node
"
)
;
ok
(
!
getState
(
)
.
snapshots
[
0
]
.
dominatorTree
.
expanded
.
has
(
deepest
.
nodeId
)
"
The
deepest
node
should
not
be
expanded
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
doc
.
querySelector
(
.
node
-
{
deepest
.
nodeId
}
)
{
}
panel
.
panelWin
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
[
0
]
.
dominatorTree
.
focused
.
nodeId
=
=
=
deepest
.
nodeId
)
;
ok
(
doc
.
querySelector
(
.
node
-
{
deepest
.
nodeId
}
)
.
classList
.
contains
(
"
focused
"
)
"
The
deepest
node
should
be
focused
now
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_RIGHT
"
{
}
panel
.
panelWin
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
[
0
]
.
dominatorTree
.
expanded
.
has
(
deepest
.
nodeId
)
)
;
is
(
getState
(
)
.
snapshots
[
0
]
.
dominatorTree
.
state
dominatorTreeState
.
INCREMENTAL_FETCHING
"
Expanding
the
deepest
node
should
start
an
incremental
fetch
of
its
subtree
"
)
;
ok
(
doc
.
querySelector
(
.
node
-
{
deepest
.
nodeId
}
)
.
classList
.
contains
(
"
focused
"
)
"
The
deepest
node
should
still
be
focused
after
expansion
"
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
[
0
]
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
LOADED
)
;
ok
(
true
"
And
the
incremental
fetch
completes
.
"
)
;
ok
(
doc
.
querySelector
(
.
node
-
{
deepest
.
nodeId
}
)
.
classList
.
contains
(
"
focused
"
)
"
The
deepest
node
should
still
be
focused
after
we
have
loaded
its
children
"
)
;
const
newDeepest
=
(
function
findNewDeepest
(
node
=
getState
(
)
.
snapshots
[
0
]
.
dominatorTree
.
root
)
{
if
(
node
.
nodeId
=
=
=
deepest
.
nodeId
)
{
return
node
;
}
if
(
node
.
children
)
{
for
(
let
child
of
node
.
children
)
{
const
found
=
findNewDeepest
(
child
)
;
if
(
found
)
{
return
found
;
}
}
}
return
null
;
}
(
)
)
;
ok
(
newDeepest
"
We
found
the
up
-
to
-
date
version
of
deepest
"
)
;
ok
(
newDeepest
.
children
"
And
its
children
are
loaded
"
)
;
ok
(
newDeepest
.
children
.
length
"
And
there
are
more
than
0
children
"
)
;
const
firstChild
=
newDeepest
.
children
[
0
]
;
ok
(
firstChild
"
deepest
should
have
a
first
child
"
)
;
ok
(
doc
.
querySelector
(
.
node
-
{
firstChild
.
nodeId
}
)
"
and
the
first
child
should
exist
in
the
dom
"
)
;
EventUtils
.
synthesizeKey
(
"
VK_RIGHT
"
{
}
panel
.
panelWin
)
;
await
waitUntilState
(
store
state
=
>
state
.
snapshots
[
0
]
.
dominatorTree
.
focused
=
=
=
firstChild
)
;
ok
(
doc
.
querySelector
(
.
node
-
{
firstChild
.
nodeId
}
)
.
classList
.
contains
(
"
focused
"
)
"
The
first
child
should
now
be
focused
"
)
;
}
)
;
