const
{
assert
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
MemoryFront
}
=
require
(
"
devtools
/
server
/
actors
/
memory
"
)
;
const
HeapAnalysesClient
=
require
(
"
devtools
/
shared
/
heapsnapshot
/
HeapAnalysesClient
"
)
;
const
{
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
snapshotState
:
states
diffingState
}
=
require
(
"
.
/
constants
"
)
;
let
breakdownModel
=
exports
.
breakdown
=
PropTypes
.
shape
(
{
by
:
PropTypes
.
oneOf
(
[
"
coarseType
"
"
allocationStack
"
"
objectClass
"
"
internalType
"
]
)
.
isRequired
}
)
;
let
censusModel
=
exports
.
censusModel
=
PropTypes
.
shape
(
{
report
:
PropTypes
.
object
breakdown
:
breakdownModel
inverted
:
PropTypes
.
bool
filter
:
PropTypes
.
string
}
)
;
let
stateKeys
=
Object
.
keys
(
states
)
.
map
(
state
=
>
states
[
state
]
)
;
const
snapshotId
=
PropTypes
.
number
;
let
snapshotModel
=
exports
.
snapshot
=
PropTypes
.
shape
(
{
id
:
snapshotId
.
isRequired
selected
:
PropTypes
.
bool
.
isRequired
path
:
PropTypes
.
string
census
:
censusModel
error
:
PropTypes
.
object
imported
:
PropTypes
.
bool
.
isRequired
creationTime
:
PropTypes
.
number
state
:
function
(
snapshot
propName
)
{
let
current
=
snapshot
.
state
;
let
shouldHavePath
=
[
states
.
IMPORTING
states
.
SAVED
states
.
READ
states
.
SAVING_CENSUS
states
.
SAVED_CENSUS
]
;
let
shouldHaveCreationTime
=
[
states
.
READ
states
.
SAVING_CENSUS
states
.
SAVED_CENSUS
]
;
let
shouldHaveCensus
=
[
states
.
SAVED_CENSUS
]
;
if
(
!
stateKeys
.
includes
(
current
)
)
{
throw
new
Error
(
Snapshot
state
must
be
one
of
{
stateKeys
}
.
)
;
}
if
(
shouldHavePath
.
includes
(
current
)
&
&
!
snapshot
.
path
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
snapshot
path
.
)
;
}
if
(
shouldHaveCensus
.
includes
(
current
)
&
&
(
!
snapshot
.
census
|
|
!
snapshot
.
census
.
breakdown
)
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
census
and
breakdown
.
)
;
}
if
(
shouldHaveCreationTime
.
includes
(
current
)
&
&
!
snapshot
.
creationTime
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
creation
time
.
)
;
}
}
}
)
;
let
allocationsModel
=
exports
.
allocations
=
PropTypes
.
shape
(
{
recording
:
PropTypes
.
bool
.
isRequired
togglingInProgress
:
PropTypes
.
bool
.
isRequired
}
)
;
let
diffingModel
=
exports
.
diffingModel
=
PropTypes
.
shape
(
{
firstSnapshotId
:
snapshotId
secondSnapshotId
:
function
(
diffing
propName
)
{
if
(
diffing
.
secondSnapshotId
&
&
!
diffing
.
firstSnapshotId
)
{
throw
new
Error
(
"
Cannot
have
second
snapshot
without
already
having
"
+
"
first
snapshot
"
)
;
}
return
snapshotId
(
diffing
propName
)
;
}
census
:
censusModel
error
:
PropTypes
.
object
state
:
function
(
diffing
)
{
switch
(
diffing
.
state
)
{
case
diffingState
.
TOOK_DIFF
:
assert
(
diffing
.
census
"
If
we
took
a
diff
we
should
have
a
census
"
)
;
case
diffingState
.
TAKING_DIFF
:
assert
(
diffing
.
firstSnapshotId
"
Should
have
first
snapshot
"
)
;
assert
(
diffing
.
secondSnapshotId
"
Should
have
second
snapshot
"
)
;
break
;
case
diffingState
.
SELECTING
:
break
;
case
diffingState
.
ERROR
:
assert
(
diffing
.
error
"
Should
have
error
"
)
;
break
;
default
:
assert
(
false
Bad
diffing
state
:
{
diffing
.
state
}
)
;
}
}
}
)
;
let
appModel
=
exports
.
app
=
{
front
:
PropTypes
.
instanceOf
(
MemoryFront
)
allocations
:
allocationsModel
.
isRequired
heapWorker
:
PropTypes
.
instanceOf
(
HeapAnalysesClient
)
breakdown
:
breakdownModel
.
isRequired
snapshots
:
PropTypes
.
arrayOf
(
snapshotModel
)
.
isRequired
inverted
:
PropTypes
.
bool
.
isRequired
filter
:
PropTypes
.
string
diffing
:
diffingModel
}
;
