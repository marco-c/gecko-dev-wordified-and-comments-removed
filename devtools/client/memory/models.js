const
{
assert
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
MemoryFront
}
=
require
(
"
devtools
/
server
/
actors
/
memory
"
)
;
const
HeapAnalysesClient
=
require
(
"
devtools
/
shared
/
heapsnapshot
/
HeapAnalysesClient
"
)
;
const
{
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
snapshotState
:
states
diffingState
dominatorTreeState
viewState
}
=
require
(
"
.
/
constants
"
)
;
function
catchAndIgnore
(
fn
)
{
return
function
(
.
.
.
args
)
{
try
{
fn
(
.
.
.
args
)
;
}
catch
(
err
)
{
}
return
null
;
}
;
}
let
breakdownModel
=
exports
.
breakdown
=
PropTypes
.
shape
(
{
by
:
PropTypes
.
oneOf
(
[
"
coarseType
"
"
allocationStack
"
"
objectClass
"
"
internalType
"
]
)
.
isRequired
}
)
;
let
censusModel
=
exports
.
censusModel
=
PropTypes
.
shape
(
{
report
:
PropTypes
.
object
breakdown
:
breakdownModel
inverted
:
PropTypes
.
bool
filter
:
PropTypes
.
string
expanded
:
catchAndIgnore
(
function
(
census
)
{
if
(
census
.
report
)
{
assert
(
census
.
expanded
"
If
we
have
a
report
we
should
also
have
the
set
of
expanded
nodes
"
)
;
}
}
)
focused
:
PropTypes
.
object
}
)
;
let
dominatorTreeModel
=
exports
.
dominatorTreeModel
=
PropTypes
.
shape
(
{
dominatorTreeId
:
PropTypes
.
number
root
:
PropTypes
.
object
expanded
:
PropTypes
.
object
focused
:
PropTypes
.
object
error
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
object
]
)
breakdown
:
breakdownModel
activeFetchRequestCount
:
PropTypes
.
number
state
:
catchAndIgnore
(
function
(
dominatorTree
)
{
switch
(
dominatorTree
.
state
)
{
case
dominatorTreeState
.
COMPUTING
:
assert
(
dominatorTree
.
dominatorTreeId
=
=
null
"
Should
not
have
a
dominator
tree
id
yet
"
)
;
assert
(
!
dominatorTree
.
root
"
Should
not
have
the
root
of
the
tree
yet
"
)
;
assert
(
!
dominatorTree
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
dominatorTreeState
.
COMPUTED
:
case
dominatorTreeState
.
FETCHING
:
assert
(
dominatorTree
.
dominatorTreeId
!
=
null
"
Should
have
a
dominator
tree
id
"
)
;
assert
(
!
dominatorTree
.
root
"
Should
not
have
the
root
of
the
tree
yet
"
)
;
assert
(
!
dominatorTree
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
dominatorTreeState
.
INCREMENTAL_FETCHING
:
assert
(
typeof
dominatorTree
.
activeFetchRequestCount
=
=
=
"
number
"
"
The
active
fetch
request
count
is
a
number
when
we
are
in
the
"
+
"
INCREMENTAL_FETCHING
state
"
)
;
assert
(
dominatorTree
.
activeFetchRequestCount
>
0
"
We
are
keeping
track
of
how
many
active
requests
are
in
flight
.
"
)
;
case
dominatorTreeState
.
LOADED
:
assert
(
dominatorTree
.
dominatorTreeId
!
=
null
"
Should
have
a
dominator
tree
id
"
)
;
assert
(
dominatorTree
.
root
"
Should
have
the
root
of
the
tree
"
)
;
assert
(
dominatorTree
.
expanded
"
Should
have
an
expanded
set
"
)
;
assert
(
!
dominatorTree
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
dominatorTreeState
.
ERROR
:
assert
(
dominatorTree
.
error
"
Should
have
an
error
"
)
;
break
;
default
:
assert
(
false
Unexpected
dominator
tree
state
:
{
dominatorTree
.
state
}
)
;
}
}
)
}
)
;
let
stateKeys
=
Object
.
keys
(
states
)
.
map
(
state
=
>
states
[
state
]
)
;
const
snapshotId
=
PropTypes
.
number
;
let
snapshotModel
=
exports
.
snapshot
=
PropTypes
.
shape
(
{
id
:
snapshotId
.
isRequired
selected
:
PropTypes
.
bool
.
isRequired
path
:
PropTypes
.
string
census
:
censusModel
dominatorTree
:
dominatorTreeModel
error
:
PropTypes
.
object
imported
:
PropTypes
.
bool
.
isRequired
creationTime
:
PropTypes
.
number
state
:
catchAndIgnore
(
function
(
snapshot
propName
)
{
let
current
=
snapshot
.
state
;
let
shouldHavePath
=
[
states
.
IMPORTING
states
.
SAVED
states
.
READ
states
.
SAVING_CENSUS
states
.
SAVED_CENSUS
]
;
let
shouldHaveCreationTime
=
[
states
.
READ
states
.
SAVING_CENSUS
states
.
SAVED_CENSUS
]
;
let
shouldHaveCensus
=
[
states
.
SAVED_CENSUS
]
;
if
(
!
stateKeys
.
includes
(
current
)
)
{
throw
new
Error
(
Snapshot
state
must
be
one
of
{
stateKeys
}
.
)
;
}
if
(
shouldHavePath
.
includes
(
current
)
&
&
!
snapshot
.
path
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
snapshot
path
.
)
;
}
if
(
shouldHaveCensus
.
includes
(
current
)
&
&
(
!
snapshot
.
census
|
|
!
snapshot
.
census
.
breakdown
)
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
census
and
breakdown
.
)
;
}
if
(
shouldHaveCreationTime
.
includes
(
current
)
&
&
!
snapshot
.
creationTime
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
creation
time
.
)
;
}
}
)
}
)
;
let
allocationsModel
=
exports
.
allocations
=
PropTypes
.
shape
(
{
recording
:
PropTypes
.
bool
.
isRequired
togglingInProgress
:
PropTypes
.
bool
.
isRequired
}
)
;
let
diffingModel
=
exports
.
diffingModel
=
PropTypes
.
shape
(
{
firstSnapshotId
:
snapshotId
secondSnapshotId
:
catchAndIgnore
(
function
(
diffing
propName
)
{
if
(
diffing
.
secondSnapshotId
&
&
!
diffing
.
firstSnapshotId
)
{
throw
new
Error
(
"
Cannot
have
second
snapshot
without
already
having
"
+
"
first
snapshot
"
)
;
}
return
snapshotId
(
diffing
propName
)
;
}
)
census
:
censusModel
error
:
PropTypes
.
object
state
:
catchAndIgnore
(
function
(
diffing
)
{
switch
(
diffing
.
state
)
{
case
diffingState
.
TOOK_DIFF
:
assert
(
diffing
.
census
"
If
we
took
a
diff
we
should
have
a
census
"
)
;
case
diffingState
.
TAKING_DIFF
:
assert
(
diffing
.
firstSnapshotId
"
Should
have
first
snapshot
"
)
;
assert
(
diffing
.
secondSnapshotId
"
Should
have
second
snapshot
"
)
;
break
;
case
diffingState
.
SELECTING
:
break
;
case
diffingState
.
ERROR
:
assert
(
diffing
.
error
"
Should
have
error
"
)
;
break
;
default
:
assert
(
false
Bad
diffing
state
:
{
diffing
.
state
}
)
;
}
}
)
}
)
;
let
appModel
=
exports
.
app
=
{
front
:
PropTypes
.
instanceOf
(
MemoryFront
)
allocations
:
allocationsModel
.
isRequired
heapWorker
:
PropTypes
.
instanceOf
(
HeapAnalysesClient
)
breakdown
:
breakdownModel
.
isRequired
dominatorTreeBreakdown
:
breakdownModel
.
isRequired
snapshots
:
PropTypes
.
arrayOf
(
snapshotModel
)
.
isRequired
inverted
:
PropTypes
.
bool
.
isRequired
filter
:
PropTypes
.
string
diffing
:
diffingModel
view
:
catchAndIgnore
(
function
(
app
)
{
switch
(
app
.
view
)
{
case
viewState
.
CENSUS
:
assert
(
!
app
.
diffing
"
Should
not
be
diffing
"
)
;
break
;
case
viewState
.
DIFFING
:
assert
(
app
.
diffing
"
Should
be
diffing
"
)
;
break
;
case
viewState
.
DOMINATOR_TREE
:
assert
(
!
app
.
diffing
"
Should
not
be
diffing
"
)
;
break
;
default
:
assert
(
false
Unexpected
type
of
view
:
{
app
.
view
}
)
;
}
}
)
}
;
