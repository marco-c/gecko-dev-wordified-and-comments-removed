const
{
MemoryFront
}
=
require
(
"
devtools
/
server
/
actors
/
memory
"
)
;
const
HeapAnalysesClient
=
require
(
"
devtools
/
shared
/
heapsnapshot
/
HeapAnalysesClient
"
)
;
const
{
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
snapshotState
:
states
}
=
require
(
"
.
/
constants
"
)
;
let
breakdownModel
=
exports
.
breakdown
=
PropTypes
.
shape
(
{
by
:
PropTypes
.
oneOf
(
[
"
coarseType
"
"
allocationStack
"
"
objectClass
"
"
internalType
"
]
)
.
isRequired
}
)
;
let
snapshotModel
=
exports
.
snapshot
=
PropTypes
.
shape
(
{
id
:
PropTypes
.
number
.
isRequired
selected
:
PropTypes
.
bool
.
isRequired
path
:
PropTypes
.
string
census
:
PropTypes
.
object
breakdown
:
breakdownModel
state
:
function
(
props
propName
)
{
let
stateNames
=
Object
.
keys
(
states
)
;
let
current
=
props
.
state
;
let
shouldHavePath
=
[
states
.
SAVED
states
.
READ
states
.
SAVING_CENSUS
states
.
SAVED_CENSUS
]
;
let
shouldHaveCensus
=
[
states
.
SAVED_CENSUS
]
;
if
(
!
stateNames
.
includes
(
current
)
)
{
throw
new
Error
(
Snapshot
state
must
be
one
of
{
stateNames
}
.
)
;
}
if
(
shouldHavePath
.
includes
(
current
)
&
&
!
path
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
snapshot
path
.
)
;
}
if
(
shouldHaveCensus
.
includes
(
current
)
&
&
(
!
props
.
census
|
|
!
props
.
breakdown
)
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
census
and
breakdown
.
)
;
}
}
}
)
;
let
allocationsModel
=
exports
.
allocations
=
PropTypes
.
shape
(
{
recording
:
PropTypes
.
bool
.
isRequired
togglingInProgress
:
PropTypes
.
bool
.
isRequired
}
)
;
let
appModel
=
exports
.
app
=
{
front
:
PropTypes
.
instanceOf
(
MemoryFront
)
allocations
:
allocationsModel
heapWorker
:
PropTypes
.
instanceOf
(
HeapAnalysesClient
)
breakdown
:
breakdownModel
.
isRequired
snapshots
:
PropTypes
.
arrayOf
(
snapshotModel
)
.
isRequired
}
;
