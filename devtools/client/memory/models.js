"
use
strict
"
;
const
{
assert
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
MemoryFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
memory
"
)
;
const
HeapAnalysesClient
=
require
(
"
devtools
/
shared
/
heapsnapshot
/
HeapAnalysesClient
"
)
;
const
{
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
snapshotState
:
states
diffingState
dominatorTreeState
viewState
individualsState
}
=
require
(
"
.
/
constants
"
)
;
function
catchAndIgnore
(
fn
)
{
return
function
(
.
.
.
args
)
{
try
{
fn
(
.
.
.
args
)
;
}
catch
(
err
)
{
}
return
null
;
}
;
}
const
censusDisplayModel
=
exports
.
censusDisplay
=
PropTypes
.
shape
(
{
displayName
:
PropTypes
.
string
.
isRequired
tooltip
:
PropTypes
.
string
.
isRequired
inverted
:
PropTypes
.
bool
.
isRequired
breakdown
:
PropTypes
.
shape
(
{
by
:
PropTypes
.
string
.
isRequired
}
)
}
)
;
const
labelDisplayModel
=
exports
.
labelDisplay
=
PropTypes
.
shape
(
{
displayName
:
PropTypes
.
string
.
isRequired
tooltip
:
PropTypes
.
string
.
isRequired
breakdown
:
PropTypes
.
shape
(
{
by
:
PropTypes
.
string
.
isRequired
}
)
}
)
;
const
treeMapDisplayModel
=
exports
.
treeMapDisplay
=
PropTypes
.
shape
(
{
displayName
:
PropTypes
.
string
.
isRequired
tooltip
:
PropTypes
.
string
.
isRequired
inverted
:
PropTypes
.
bool
.
isRequired
breakdown
:
PropTypes
.
shape
(
{
by
:
PropTypes
.
string
.
isRequired
}
)
}
)
;
const
treeMapModel
=
exports
.
treeMapModel
=
PropTypes
.
shape
(
{
report
:
PropTypes
.
object
display
:
treeMapDisplayModel
state
:
catchAndIgnore
(
function
(
treeMap
)
{
switch
(
treeMap
.
state
)
{
case
treeMapState
.
SAVING
:
assert
(
!
treeMap
.
report
"
Should
not
have
a
report
"
)
;
assert
(
!
treeMap
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
treeMapState
.
SAVED
:
assert
(
treeMap
.
report
"
Should
have
a
report
"
)
;
assert
(
!
treeMap
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
treeMapState
.
ERROR
:
assert
(
treeMap
.
error
"
Should
have
an
error
"
)
;
break
;
default
:
assert
(
false
Unexpected
treeMap
state
:
{
treeMap
.
state
}
)
;
}
}
)
}
)
;
let
censusModel
=
exports
.
censusModel
=
PropTypes
.
shape
(
{
report
:
PropTypes
.
object
parentMap
:
PropTypes
.
object
display
:
censusDisplayModel
filter
:
PropTypes
.
string
expanded
:
catchAndIgnore
(
function
(
census
)
{
if
(
census
.
report
)
{
assert
(
census
.
expanded
"
If
we
have
a
report
we
should
also
have
the
set
of
expanded
nodes
"
)
;
}
}
)
focused
:
PropTypes
.
object
state
:
catchAndIgnore
(
function
(
census
)
{
switch
(
census
.
state
)
{
case
censusState
.
SAVING
:
assert
(
!
census
.
report
"
Should
not
have
a
report
"
)
;
assert
(
!
census
.
parentMap
"
Should
not
have
a
parent
map
"
)
;
assert
(
census
.
expanded
"
Should
not
have
an
expanded
set
"
)
;
assert
(
!
census
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
censusState
.
SAVED
:
assert
(
census
.
report
"
Should
have
a
report
"
)
;
assert
(
census
.
parentMap
"
Should
have
a
parent
map
"
)
;
assert
(
census
.
expanded
"
Should
have
an
expanded
set
"
)
;
assert
(
!
census
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
censusState
.
ERROR
:
assert
(
!
census
.
report
"
Should
not
have
a
report
"
)
;
assert
(
census
.
error
"
Should
have
an
error
"
)
;
break
;
default
:
assert
(
false
Unexpected
census
state
:
{
census
.
state
}
)
;
}
}
)
}
)
;
let
dominatorTreeModel
=
exports
.
dominatorTreeModel
=
PropTypes
.
shape
(
{
dominatorTreeId
:
PropTypes
.
number
root
:
PropTypes
.
object
expanded
:
PropTypes
.
object
focused
:
PropTypes
.
object
error
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
object
]
)
display
:
labelDisplayModel
activeFetchRequestCount
:
PropTypes
.
number
state
:
catchAndIgnore
(
function
(
dominatorTree
)
{
switch
(
dominatorTree
.
state
)
{
case
dominatorTreeState
.
COMPUTING
:
assert
(
dominatorTree
.
dominatorTreeId
=
=
null
"
Should
not
have
a
dominator
tree
id
yet
"
)
;
assert
(
!
dominatorTree
.
root
"
Should
not
have
the
root
of
the
tree
yet
"
)
;
assert
(
!
dominatorTree
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
dominatorTreeState
.
COMPUTED
:
case
dominatorTreeState
.
FETCHING
:
assert
(
dominatorTree
.
dominatorTreeId
!
=
null
"
Should
have
a
dominator
tree
id
"
)
;
assert
(
!
dominatorTree
.
root
"
Should
not
have
the
root
of
the
tree
yet
"
)
;
assert
(
!
dominatorTree
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
dominatorTreeState
.
INCREMENTAL_FETCHING
:
assert
(
typeof
dominatorTree
.
activeFetchRequestCount
=
=
=
"
number
"
"
The
active
fetch
request
count
is
a
number
when
we
are
in
the
"
+
"
INCREMENTAL_FETCHING
state
"
)
;
assert
(
dominatorTree
.
activeFetchRequestCount
>
0
"
We
are
keeping
track
of
how
many
active
requests
are
in
flight
.
"
)
;
case
dominatorTreeState
.
LOADED
:
assert
(
dominatorTree
.
dominatorTreeId
!
=
null
"
Should
have
a
dominator
tree
id
"
)
;
assert
(
dominatorTree
.
root
"
Should
have
the
root
of
the
tree
"
)
;
assert
(
dominatorTree
.
expanded
"
Should
have
an
expanded
set
"
)
;
assert
(
!
dominatorTree
.
error
"
Should
not
have
an
error
"
)
;
break
;
case
dominatorTreeState
.
ERROR
:
assert
(
dominatorTree
.
error
"
Should
have
an
error
"
)
;
break
;
default
:
assert
(
false
Unexpected
dominator
tree
state
:
{
dominatorTree
.
state
}
)
;
}
}
)
}
)
;
let
stateKeys
=
Object
.
keys
(
states
)
.
map
(
state
=
>
states
[
state
]
)
;
const
snapshotId
=
PropTypes
.
number
;
let
snapshotModel
=
exports
.
snapshot
=
PropTypes
.
shape
(
{
id
:
snapshotId
.
isRequired
selected
:
PropTypes
.
bool
.
isRequired
path
:
PropTypes
.
string
census
:
censusModel
dominatorTree
:
dominatorTreeModel
treeMap
:
treeMapModel
error
:
PropTypes
.
object
imported
:
PropTypes
.
bool
.
isRequired
creationTime
:
PropTypes
.
number
state
:
catchAndIgnore
(
function
(
snapshot
propName
)
{
let
current
=
snapshot
.
state
;
let
shouldHavePath
=
[
states
.
IMPORTING
states
.
SAVED
states
.
READ
]
;
let
shouldHaveCreationTime
=
[
states
.
READ
]
;
if
(
!
stateKeys
.
includes
(
current
)
)
{
throw
new
Error
(
Snapshot
state
must
be
one
of
{
stateKeys
}
.
)
;
}
if
(
shouldHavePath
.
includes
(
current
)
&
&
!
snapshot
.
path
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
snapshot
path
.
)
;
}
if
(
shouldHaveCreationTime
.
includes
(
current
)
&
&
!
snapshot
.
creationTime
)
{
throw
new
Error
(
Snapshots
in
state
{
current
}
must
have
a
creation
time
.
)
;
}
}
)
}
)
;
let
allocationsModel
=
exports
.
allocations
=
PropTypes
.
shape
(
{
recording
:
PropTypes
.
bool
.
isRequired
togglingInProgress
:
PropTypes
.
bool
.
isRequired
}
)
;
let
diffingModel
=
exports
.
diffingModel
=
PropTypes
.
shape
(
{
firstSnapshotId
:
snapshotId
secondSnapshotId
:
catchAndIgnore
(
function
(
diffing
propName
)
{
if
(
diffing
.
secondSnapshotId
&
&
!
diffing
.
firstSnapshotId
)
{
throw
new
Error
(
"
Cannot
have
second
snapshot
without
already
having
"
+
"
first
snapshot
"
)
;
}
return
snapshotId
(
diffing
propName
)
;
}
)
census
:
censusModel
error
:
PropTypes
.
object
state
:
catchAndIgnore
(
function
(
diffing
)
{
switch
(
diffing
.
state
)
{
case
diffingState
.
TOOK_DIFF
:
assert
(
diffing
.
census
"
If
we
took
a
diff
we
should
have
a
census
"
)
;
case
diffingState
.
TAKING_DIFF
:
assert
(
diffing
.
firstSnapshotId
"
Should
have
first
snapshot
"
)
;
assert
(
diffing
.
secondSnapshotId
"
Should
have
second
snapshot
"
)
;
break
;
case
diffingState
.
SELECTING
:
break
;
case
diffingState
.
ERROR
:
assert
(
diffing
.
error
"
Should
have
error
"
)
;
break
;
default
:
assert
(
false
Bad
diffing
state
:
{
diffing
.
state
}
)
;
}
}
)
}
)
;
let
previousViewModel
=
exports
.
previousView
=
PropTypes
.
shape
(
{
state
:
catchAndIgnore
(
function
(
previous
)
{
switch
(
previous
.
state
)
{
case
viewState
.
DIFFING
:
assert
(
previous
.
diffing
"
Should
have
previous
diffing
state
.
"
)
;
assert
(
!
previous
.
selected
"
Should
not
have
a
previously
selected
snapshot
.
"
)
;
break
;
case
viewState
.
CENSUS
:
case
viewState
.
DOMINATOR_TREE
:
case
viewState
.
TREE_MAP
:
assert
(
previous
.
selected
"
Should
have
a
previously
selected
snapshot
.
"
)
;
break
;
case
viewState
.
INDIVIDUALS
:
default
:
assert
(
false
Unexpected
previous
view
state
:
{
previous
.
state
}
.
)
;
}
}
)
diffing
:
diffingModel
selected
:
snapshotId
}
)
;
let
viewModel
=
exports
.
view
=
PropTypes
.
shape
(
{
state
:
catchAndIgnore
(
function
(
view
)
{
switch
(
view
.
state
)
{
case
viewState
.
DIFFING
:
case
viewState
.
CENSUS
:
case
viewState
.
DOMINATOR_TREE
:
case
viewState
.
INDIVIDUALS
:
case
viewState
.
TREE_MAP
:
break
;
default
:
assert
(
false
Unexpected
type
of
view
:
{
view
.
state
}
)
;
}
}
)
previous
:
previousViewModel
}
)
;
const
individualsModel
=
exports
.
individuals
=
PropTypes
.
shape
(
{
error
:
PropTypes
.
object
nodes
:
PropTypes
.
arrayOf
(
PropTypes
.
object
)
dominatorTree
:
dominatorTreeModel
id
:
snapshotId
censusBreakdown
:
PropTypes
.
object
indices
:
PropTypes
.
object
labelDisplay
:
labelDisplayModel
focused
:
PropTypes
.
object
state
:
catchAndIgnore
(
function
(
individuals
)
{
switch
(
individuals
.
state
)
{
case
individualsState
.
COMPUTING_DOMINATOR_TREE
:
case
individualsState
.
FETCHING
:
assert
(
!
individuals
.
nodes
"
Should
not
have
individual
nodes
"
)
;
assert
(
!
individuals
.
dominatorTree
"
Should
not
have
dominator
tree
"
)
;
assert
(
!
individuals
.
id
"
Should
not
have
an
id
"
)
;
assert
(
!
individuals
.
censusBreakdown
"
Should
not
have
a
censusBreakdown
"
)
;
assert
(
!
individuals
.
indices
"
Should
not
have
indices
"
)
;
assert
(
!
individuals
.
labelDisplay
"
Should
not
have
a
labelDisplay
"
)
;
break
;
case
individualsState
.
FETCHED
:
assert
(
individuals
.
nodes
"
Should
have
individual
nodes
"
)
;
assert
(
individuals
.
dominatorTree
"
Should
have
dominator
tree
"
)
;
assert
(
individuals
.
id
"
Should
have
an
id
"
)
;
assert
(
individuals
.
censusBreakdown
"
Should
have
a
censusBreakdown
"
)
;
assert
(
individuals
.
indices
"
Should
have
indices
"
)
;
assert
(
individuals
.
labelDisplay
"
Should
have
a
labelDisplay
"
)
;
break
;
case
individualsState
.
ERROR
:
assert
(
individuals
.
error
"
Should
have
an
error
object
"
)
;
break
;
default
:
assert
(
false
Unexpected
individuals
state
:
{
individuals
.
state
}
)
;
break
;
}
}
)
}
)
;
exports
.
app
=
{
front
:
PropTypes
.
instanceOf
(
MemoryFront
)
allocations
:
allocationsModel
.
isRequired
heapWorker
:
PropTypes
.
instanceOf
(
HeapAnalysesClient
)
censusDisplay
:
censusDisplayModel
.
isRequired
labelDisplay
:
labelDisplayModel
.
isRequired
treeMapDisplay
:
treeMapDisplayModel
.
isRequired
snapshots
:
PropTypes
.
arrayOf
(
snapshotModel
)
.
isRequired
filter
:
PropTypes
.
string
diffing
:
diffingModel
individuals
:
individualsModel
view
:
function
(
app
)
{
viewModel
.
isRequired
(
app
"
view
"
)
;
catchAndIgnore
(
function
(
app
)
{
switch
(
app
.
view
.
state
)
{
case
viewState
.
DIFFING
:
assert
(
app
.
diffing
"
Should
be
diffing
"
)
;
break
;
case
viewState
.
INDIVIDUALS
:
case
viewState
.
CENSUS
:
case
viewState
.
DOMINATOR_TREE
:
case
viewState
.
TREE_MAP
:
assert
(
!
app
.
diffing
"
Should
not
be
diffing
"
)
;
break
;
default
:
assert
(
false
Unexpected
type
of
view
:
{
app
.
view
.
state
}
)
;
}
}
)
(
app
)
;
catchAndIgnore
(
function
(
app
)
{
switch
(
app
.
view
.
state
)
{
case
viewState
.
INDIVIDUALS
:
assert
(
app
.
individuals
"
Should
have
individuals
state
"
)
;
break
;
case
viewState
.
DIFFING
:
case
viewState
.
CENSUS
:
case
viewState
.
DOMINATOR_TREE
:
case
viewState
.
TREE_MAP
:
assert
(
!
app
.
individuals
"
Should
not
have
individuals
state
"
)
;
break
;
default
:
assert
(
false
Unexpected
type
of
view
:
{
app
.
view
.
state
}
)
;
}
}
)
(
app
)
;
}
}
;
