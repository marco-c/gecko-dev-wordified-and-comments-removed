"
use
strict
"
;
const
{
assert
reportException
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
{
actions
diffingState
viewState
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
memory
/
constants
.
js
"
)
;
const
{
getSnapshot
censusIsUpToDate
snapshotIsDiffable
findSelectedSnapshot
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
memory
/
utils
.
js
"
)
;
exports
.
toggleDiffing
=
function
(
)
{
return
function
(
{
dispatch
getState
}
)
{
dispatch
(
{
type
:
actions
.
CHANGE_VIEW
newViewState
:
getState
(
)
.
diffing
?
viewState
.
CENSUS
:
viewState
.
DIFFING
oldDiffing
:
getState
(
)
.
diffing
oldSelected
:
findSelectedSnapshot
(
getState
(
)
)
}
)
;
}
;
}
;
const
selectSnapshotForDiffing
=
(
exports
.
selectSnapshotForDiffing
=
function
(
snapshot
)
{
assert
(
snapshotIsDiffable
(
snapshot
)
"
To
select
a
snapshot
for
diffing
it
must
be
diffable
"
)
;
return
{
type
:
actions
.
SELECT_SNAPSHOT_FOR_DIFFING
snapshot
}
;
}
)
;
const
takeCensusDiff
=
(
exports
.
takeCensusDiff
=
function
(
heapWorker
first
second
)
{
return
async
function
(
{
dispatch
getState
}
)
{
assert
(
snapshotIsDiffable
(
first
)
First
snapshot
must
be
in
a
diffable
state
found
{
first
.
state
}
)
;
assert
(
snapshotIsDiffable
(
second
)
Second
snapshot
must
be
in
a
diffable
state
found
{
second
.
state
}
)
;
let
report
parentMap
;
let
display
=
getState
(
)
.
censusDisplay
;
let
filter
=
getState
(
)
.
filter
;
if
(
censusIsUpToDate
(
filter
display
getState
(
)
.
diffing
.
census
)
)
{
return
;
}
do
{
if
(
!
getState
(
)
.
diffing
|
|
getState
(
)
.
diffing
.
firstSnapshotId
!
=
=
first
.
id
|
|
getState
(
)
.
diffing
.
secondSnapshotId
!
=
=
second
.
id
)
{
return
;
}
display
=
getState
(
)
.
censusDisplay
;
filter
=
getState
(
)
.
filter
;
dispatch
(
{
type
:
actions
.
TAKE_CENSUS_DIFF_START
first
second
filter
display
}
)
;
const
opts
=
display
.
inverted
?
{
asInvertedTreeNode
:
true
}
:
{
asTreeNode
:
true
}
;
opts
.
filter
=
filter
|
|
null
;
try
{
(
{
delta
:
report
parentMap
}
=
await
heapWorker
.
takeCensusDiff
(
first
.
path
second
.
path
{
breakdown
:
display
.
breakdown
}
opts
)
)
;
}
catch
(
error
)
{
reportException
(
"
actions
/
diffing
/
takeCensusDiff
"
error
)
;
dispatch
(
{
type
:
actions
.
DIFFING_ERROR
error
}
)
;
return
;
}
}
while
(
filter
!
=
=
getState
(
)
.
filter
|
|
display
!
=
=
getState
(
)
.
censusDisplay
)
;
dispatch
(
{
type
:
actions
.
TAKE_CENSUS_DIFF_END
first
second
report
parentMap
filter
display
}
)
;
}
;
}
)
;
const
refreshDiffing
=
(
exports
.
refreshDiffing
=
function
(
heapWorker
)
{
return
function
(
{
dispatch
getState
}
)
{
if
(
getState
(
)
.
diffing
.
secondSnapshotId
=
=
=
null
)
{
return
;
}
assert
(
getState
(
)
.
diffing
.
firstSnapshotId
"
Should
have
first
snapshot
id
"
)
;
if
(
getState
(
)
.
diffing
.
state
=
=
=
diffingState
.
TAKING_DIFF
)
{
return
;
}
const
{
firstSnapshotId
secondSnapshotId
}
=
getState
(
)
.
diffing
;
const
first
=
getSnapshot
(
getState
(
)
firstSnapshotId
)
;
const
second
=
getSnapshot
(
getState
(
)
secondSnapshotId
)
;
dispatch
(
takeCensusDiff
(
heapWorker
first
second
)
)
;
}
;
}
)
;
exports
.
selectSnapshotForDiffingAndRefresh
=
function
(
heapWorker
snapshot
)
{
return
async
function
(
{
dispatch
getState
}
)
{
assert
(
getState
(
)
.
diffing
"
If
we
are
selecting
for
diffing
we
must
be
in
diffing
mode
"
)
;
dispatch
(
selectSnapshotForDiffing
(
snapshot
)
)
;
await
dispatch
(
refreshDiffing
(
heapWorker
)
)
;
}
;
}
;
exports
.
expandDiffingCensusNode
=
function
(
node
)
{
return
{
type
:
actions
.
EXPAND_DIFFING_CENSUS_NODE
node
}
;
}
;
exports
.
collapseDiffingCensusNode
=
function
(
node
)
{
return
{
type
:
actions
.
COLLAPSE_DIFFING_CENSUS_NODE
node
}
;
}
;
exports
.
focusDiffingCensusNode
=
function
(
node
)
{
return
{
type
:
actions
.
FOCUS_DIFFING_CENSUS_NODE
node
}
;
}
;
