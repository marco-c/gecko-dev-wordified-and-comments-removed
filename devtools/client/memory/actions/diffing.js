"
use
strict
"
;
const
{
assert
reportException
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
actions
diffingState
viewState
}
=
require
(
"
.
.
/
constants
"
)
;
const
telemetry
=
require
(
"
.
.
/
telemetry
"
)
;
const
{
breakdownEquals
getSnapshot
censusIsUpToDate
snapshotIsDiffable
}
=
require
(
"
.
.
/
utils
"
)
;
const
toggleDiffing
=
exports
.
toggleDiffing
=
function
(
)
{
return
function
(
dispatch
getState
)
{
dispatch
(
{
type
:
actions
.
CHANGE_VIEW
view
:
getState
(
)
.
diffing
?
viewState
.
CENSUS
:
viewState
.
DIFFING
}
)
;
}
;
}
;
const
selectSnapshotForDiffing
=
exports
.
selectSnapshotForDiffing
=
function
(
snapshot
)
{
assert
(
snapshotIsDiffable
(
snapshot
)
"
To
select
a
snapshot
for
diffing
it
must
be
diffable
"
)
;
return
{
type
:
actions
.
SELECT_SNAPSHOT_FOR_DIFFING
snapshot
}
;
}
;
const
takeCensusDiff
=
exports
.
takeCensusDiff
=
function
(
heapWorker
first
second
)
{
return
function
*
(
dispatch
getState
)
{
assert
(
snapshotIsDiffable
(
first
)
First
snapshot
must
be
in
a
diffable
state
found
{
first
.
state
}
)
;
assert
(
snapshotIsDiffable
(
second
)
Second
snapshot
must
be
in
a
diffable
state
found
{
second
.
state
}
)
;
let
report
parentMap
;
let
inverted
=
getState
(
)
.
inverted
;
let
breakdown
=
getState
(
)
.
breakdown
;
let
filter
=
getState
(
)
.
filter
;
if
(
censusIsUpToDate
(
inverted
filter
breakdown
getState
(
)
.
diffing
.
census
)
)
{
return
;
}
do
{
if
(
!
getState
(
)
.
diffing
|
|
getState
(
)
.
diffing
.
firstSnapshotId
!
=
=
first
.
id
|
|
getState
(
)
.
diffing
.
secondSnapshotId
!
=
=
second
.
id
)
{
return
;
}
inverted
=
getState
(
)
.
inverted
;
breakdown
=
getState
(
)
.
breakdown
;
filter
=
getState
(
)
.
filter
;
dispatch
(
{
type
:
actions
.
TAKE_CENSUS_DIFF_START
first
second
inverted
filter
breakdown
}
)
;
let
opts
=
inverted
?
{
asInvertedTreeNode
:
true
}
:
{
asTreeNode
:
true
}
;
opts
.
filter
=
filter
|
|
null
;
try
{
(
{
delta
:
report
parentMap
}
=
yield
heapWorker
.
takeCensusDiff
(
first
.
path
second
.
path
{
breakdown
}
opts
)
)
;
}
catch
(
error
)
{
reportException
(
"
actions
/
diffing
/
takeCensusDiff
"
error
)
;
dispatch
(
{
type
:
actions
.
DIFFING_ERROR
error
}
)
;
return
;
}
}
while
(
inverted
!
=
=
getState
(
)
.
inverted
|
|
filter
!
=
=
getState
(
)
.
filter
|
|
!
breakdownEquals
(
breakdown
getState
(
)
.
breakdown
)
)
;
dispatch
(
{
type
:
actions
.
TAKE_CENSUS_DIFF_END
first
second
report
parentMap
inverted
filter
breakdown
}
)
;
telemetry
.
countDiff
(
{
inverted
filter
breakdown
}
)
;
}
;
}
;
const
refreshDiffing
=
exports
.
refreshDiffing
=
function
(
heapWorker
)
{
return
function
*
(
dispatch
getState
)
{
if
(
getState
(
)
.
diffing
.
secondSnapshotId
=
=
=
null
)
{
return
;
}
assert
(
getState
(
)
.
diffing
.
firstSnapshotId
"
Should
have
first
snapshot
id
"
)
;
if
(
getState
(
)
.
diffing
.
state
=
=
=
diffingState
.
TAKING_DIFF
)
{
return
;
}
const
{
firstSnapshotId
secondSnapshotId
}
=
getState
(
)
.
diffing
;
const
first
=
getSnapshot
(
getState
(
)
firstSnapshotId
)
;
const
second
=
getSnapshot
(
getState
(
)
secondSnapshotId
)
;
dispatch
(
takeCensusDiff
(
heapWorker
first
second
)
)
;
}
;
}
;
const
selectSnapshotForDiffingAndRefresh
=
exports
.
selectSnapshotForDiffingAndRefresh
=
function
(
heapWorker
snapshot
)
{
return
function
*
(
dispatch
getState
)
{
assert
(
getState
(
)
.
diffing
"
If
we
are
selecting
for
diffing
we
must
be
in
diffing
mode
"
)
;
dispatch
(
selectSnapshotForDiffing
(
snapshot
)
)
;
yield
dispatch
(
refreshDiffing
(
heapWorker
)
)
;
}
;
}
;
const
expandDiffingCensusNode
=
exports
.
expandDiffingCensusNode
=
function
(
node
)
{
return
{
type
:
actions
.
EXPAND_DIFFING_CENSUS_NODE
node
}
;
}
;
const
collapseDiffingCensusNode
=
exports
.
collapseDiffingCensusNode
=
function
(
node
)
{
return
{
type
:
actions
.
COLLAPSE_DIFFING_CENSUS_NODE
node
}
;
}
;
const
focusDiffingCensusNode
=
exports
.
focusDiffingCensusNode
=
function
(
node
)
{
return
{
type
:
actions
.
FOCUS_DIFFING_CENSUS_NODE
node
}
;
}
;
