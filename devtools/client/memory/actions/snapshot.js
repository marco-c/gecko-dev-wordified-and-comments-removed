"
use
strict
"
;
const
{
assert
reportException
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
censusIsUpToDate
getSnapshot
createSnapshot
dominatorTreeIsComputed
canTakeCensus
}
=
require
(
"
.
.
/
utils
"
)
;
const
{
actions
snapshotState
:
states
viewState
censusState
treeMapState
dominatorTreeState
}
=
require
(
"
.
.
/
constants
"
)
;
const
telemetry
=
require
(
"
.
.
/
telemetry
"
)
;
const
view
=
require
(
"
.
/
view
"
)
;
const
refresh
=
require
(
"
.
/
refresh
"
)
;
const
diffing
=
require
(
"
.
/
diffing
"
)
;
const
takeSnapshotAndCensus
=
exports
.
takeSnapshotAndCensus
=
function
(
front
heapWorker
)
{
return
function
*
(
dispatch
getState
)
{
const
id
=
yield
dispatch
(
takeSnapshot
(
front
)
)
;
if
(
id
=
=
=
null
)
{
return
;
}
yield
dispatch
(
readSnapshot
(
heapWorker
id
)
)
;
yield
dispatch
(
computeSnapshotData
(
heapWorker
id
)
)
;
}
;
}
;
const
computeSnapshotData
=
exports
.
computeSnapshotData
=
function
(
heapWorker
id
)
{
return
function
*
(
dispatch
getState
)
{
if
(
getSnapshot
(
getState
(
)
id
)
.
state
!
=
=
states
.
READ
)
{
return
;
}
const
censusTaker
=
getCurrentCensusTaker
(
getState
(
)
.
view
)
;
yield
dispatch
(
censusTaker
(
heapWorker
id
)
)
;
if
(
getState
(
)
.
view
=
=
=
viewState
.
DOMINATOR_TREE
)
{
yield
dispatch
(
computeAndFetchDominatorTree
(
heapWorker
id
)
)
;
}
}
;
}
;
const
selectSnapshotAndRefresh
=
exports
.
selectSnapshotAndRefresh
=
function
(
heapWorker
id
)
{
return
function
*
(
dispatch
getState
)
{
if
(
getState
(
)
.
diffing
)
{
dispatch
(
view
.
changeView
(
viewState
.
CENSUS
)
)
;
}
dispatch
(
selectSnapshot
(
id
)
)
;
yield
dispatch
(
refresh
.
refresh
(
heapWorker
)
)
;
}
;
}
;
const
takeSnapshot
=
exports
.
takeSnapshot
=
function
(
front
)
{
return
function
*
(
dispatch
getState
)
{
telemetry
.
countTakeSnapshot
(
)
;
if
(
getState
(
)
.
diffing
)
{
dispatch
(
view
.
changeView
(
viewState
.
CENSUS
)
)
;
}
const
snapshot
=
createSnapshot
(
getState
(
)
)
;
const
id
=
snapshot
.
id
;
dispatch
(
{
type
:
actions
.
TAKE_SNAPSHOT_START
snapshot
}
)
;
dispatch
(
selectSnapshot
(
id
)
)
;
let
path
;
try
{
path
=
yield
front
.
saveHeapSnapshot
(
)
;
}
catch
(
error
)
{
reportException
(
"
takeSnapshot
"
error
)
;
dispatch
(
{
type
:
actions
.
SNAPSHOT_ERROR
id
error
}
)
;
return
null
;
}
dispatch
(
{
type
:
actions
.
TAKE_SNAPSHOT_END
id
path
}
)
;
return
snapshot
.
id
;
}
;
}
;
const
readSnapshot
=
exports
.
readSnapshot
=
function
readSnapshot
(
heapWorker
id
)
{
return
function
*
(
dispatch
getState
)
{
const
snapshot
=
getSnapshot
(
getState
(
)
id
)
;
assert
(
[
states
.
SAVED
states
.
IMPORTING
]
.
includes
(
snapshot
.
state
)
Should
only
read
a
snapshot
once
.
Found
snapshot
in
state
{
snapshot
.
state
}
)
;
let
creationTime
;
dispatch
(
{
type
:
actions
.
READ_SNAPSHOT_START
id
}
)
;
try
{
yield
heapWorker
.
readHeapSnapshot
(
snapshot
.
path
)
;
creationTime
=
yield
heapWorker
.
getCreationTime
(
snapshot
.
path
)
;
}
catch
(
error
)
{
reportException
(
"
readSnapshot
"
error
)
;
dispatch
(
{
type
:
actions
.
SNAPSHOT_ERROR
id
error
}
)
;
return
;
}
dispatch
(
{
type
:
actions
.
READ_SNAPSHOT_END
id
creationTime
}
)
;
}
;
}
;
function
makeTakeCensusTask
(
{
getDisplay
getFilter
getCensus
beginAction
endAction
errorAction
}
)
{
return
function
(
heapWorker
id
)
{
return
function
*
(
dispatch
getState
)
{
const
snapshot
=
getSnapshot
(
getState
(
)
id
)
;
assert
(
canTakeCensus
(
snapshot
)
Attempting
to
take
a
census
when
the
snapshot
is
not
in
a
ready
state
.
)
;
let
report
parentMap
;
let
display
=
getDisplay
(
getState
(
)
)
;
let
filter
=
getFilter
(
getState
(
)
)
;
if
(
censusIsUpToDate
(
filter
display
getCensus
(
snapshot
)
)
)
{
return
;
}
do
{
display
=
getDisplay
(
getState
(
)
)
;
filter
=
getState
(
)
.
filter
;
dispatch
(
{
type
:
beginAction
id
filter
display
}
)
;
let
opts
=
display
.
inverted
?
{
asInvertedTreeNode
:
true
}
:
{
asTreeNode
:
true
}
;
opts
.
filter
=
filter
|
|
null
;
try
{
(
{
report
parentMap
}
=
yield
heapWorker
.
takeCensus
(
snapshot
.
path
{
breakdown
:
display
.
breakdown
}
opts
)
)
;
}
catch
(
error
)
{
reportException
(
"
takeCensus
"
error
)
;
dispatch
(
{
type
:
errorAction
id
error
}
)
;
return
;
}
}
while
(
filter
!
=
=
getState
(
)
.
filter
|
|
display
!
=
=
getDisplay
(
getState
(
)
)
)
;
dispatch
(
{
type
:
endAction
id
display
filter
report
parentMap
}
)
;
telemetry
.
countCensus
(
{
filter
display
}
)
;
}
;
}
;
}
const
takeCensus
=
exports
.
takeCensus
=
makeTakeCensusTask
(
{
getDisplay
:
(
state
)
=
>
state
.
censusDisplay
getFilter
:
(
state
)
=
>
state
.
filter
getCensus
:
(
snapshot
)
=
>
snapshot
.
census
beginAction
:
actions
.
TAKE_CENSUS_START
endAction
:
actions
.
TAKE_CENSUS_END
errorAction
:
actions
.
TAKE_CENSUS_ERROR
}
)
;
const
takeTreeMap
=
exports
.
takeTreeMap
=
makeTakeCensusTask
(
{
getDisplay
:
(
state
)
=
>
state
.
treeMapDisplay
getFilter
:
(
)
=
>
null
getCensus
:
(
snapshot
)
=
>
snapshot
.
treeMap
beginAction
:
actions
.
TAKE_TREE_MAP_START
endAction
:
actions
.
TAKE_TREE_MAP_END
errorAction
:
actions
.
TAKE_TREE_MAP_ERROR
}
)
;
const
defaultCensusTaker
=
takeTreeMap
;
const
getCurrentCensusTaker
=
exports
.
getCurrentCensusTaker
=
function
(
currentView
)
{
switch
(
currentView
)
{
case
viewState
.
TREE_MAP
:
return
takeTreeMap
;
break
;
case
viewState
.
CENSUS
:
return
takeCensus
;
break
;
}
return
defaultCensusTaker
;
}
;
const
refreshSelectedCensus
=
exports
.
refreshSelectedCensus
=
function
(
heapWorker
)
{
return
function
*
(
dispatch
getState
)
{
let
snapshot
=
getState
(
)
.
snapshots
.
find
(
s
=
>
s
.
selected
)
;
if
(
snapshot
&
&
(
snapshot
.
census
&
&
snapshot
.
census
.
state
=
=
=
censusState
.
SAVED
)
|
|
!
snapshot
.
census
)
{
yield
dispatch
(
takeCensus
(
heapWorker
snapshot
.
id
)
)
;
}
}
;
}
;
const
refreshSelectedTreeMap
=
exports
.
refreshSelectedTreeMap
=
function
(
heapWorker
)
{
return
function
*
(
dispatch
getState
)
{
let
snapshot
=
getState
(
)
.
snapshots
.
find
(
s
=
>
s
.
selected
)
;
if
(
snapshot
&
&
(
snapshot
.
treeMap
&
&
snapshot
.
treeMap
.
state
=
=
=
treeMapState
.
SAVED
)
|
|
!
snapshot
.
treeMap
)
{
yield
dispatch
(
takeTreeMap
(
heapWorker
snapshot
.
id
)
)
;
}
}
;
}
;
const
computeDominatorTree
=
exports
.
computeDominatorTree
=
function
(
heapWorker
id
)
{
return
function
*
(
dispatch
getState
)
{
const
snapshot
=
getSnapshot
(
getState
(
)
id
)
;
assert
(
!
(
snapshot
.
dominatorTree
&
&
snapshot
.
dominatorTree
.
dominatorTreeId
)
"
Should
not
re
-
compute
dominator
trees
"
)
;
dispatch
(
{
type
:
actions
.
COMPUTE_DOMINATOR_TREE_START
id
}
)
;
let
dominatorTreeId
;
try
{
dominatorTreeId
=
yield
heapWorker
.
computeDominatorTree
(
snapshot
.
path
)
;
}
catch
(
error
)
{
reportException
(
"
actions
/
snapshot
/
computeDominatorTree
"
error
)
;
dispatch
(
{
type
:
actions
.
DOMINATOR_TREE_ERROR
id
error
}
)
;
return
null
;
}
dispatch
(
{
type
:
actions
.
COMPUTE_DOMINATOR_TREE_END
id
dominatorTreeId
}
)
;
return
dominatorTreeId
;
}
;
}
;
const
fetchDominatorTree
=
exports
.
fetchDominatorTree
=
function
(
heapWorker
id
)
{
return
function
*
(
dispatch
getState
)
{
const
snapshot
=
getSnapshot
(
getState
(
)
id
)
;
assert
(
dominatorTreeIsComputed
(
snapshot
)
"
Should
have
dominator
tree
model
and
it
should
be
computed
"
)
;
let
display
;
let
root
;
do
{
display
=
getState
(
)
.
dominatorTreeDisplay
;
assert
(
display
&
&
display
.
breakdown
Should
have
a
breakdown
to
describe
nodes
with
got
:
{
uneval
(
display
)
}
)
;
dispatch
(
{
type
:
actions
.
FETCH_DOMINATOR_TREE_START
id
display
}
)
;
try
{
root
=
yield
heapWorker
.
getDominatorTree
(
{
dominatorTreeId
:
snapshot
.
dominatorTree
.
dominatorTreeId
breakdown
:
display
.
breakdown
}
)
;
}
catch
(
error
)
{
reportException
(
"
actions
/
snapshot
/
fetchDominatorTree
"
error
)
;
dispatch
(
{
type
:
actions
.
DOMINATOR_TREE_ERROR
id
error
}
)
;
return
null
;
}
}
while
(
display
!
=
=
getState
(
)
.
dominatorTreeDisplay
)
;
dispatch
(
{
type
:
actions
.
FETCH_DOMINATOR_TREE_END
id
root
}
)
;
telemetry
.
countDominatorTree
(
{
display
}
)
;
return
root
;
}
;
}
;
const
fetchImmediatelyDominated
=
exports
.
fetchImmediatelyDominated
=
function
(
heapWorker
id
lazyChildren
)
{
return
function
*
(
dispatch
getState
)
{
const
snapshot
=
getSnapshot
(
getState
(
)
id
)
;
assert
(
snapshot
.
dominatorTree
"
Should
have
dominator
tree
model
"
)
;
assert
(
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
LOADED
|
|
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
INCREMENTAL_FETCHING
"
Cannot
fetch
immediately
dominated
nodes
in
a
dominator
tree
unless
"
+
"
the
dominator
tree
has
already
been
computed
"
)
;
let
display
;
let
response
;
do
{
display
=
getState
(
)
.
dominatorTreeDisplay
;
assert
(
display
"
Should
have
a
display
to
describe
nodes
with
.
"
)
;
dispatch
(
{
type
:
actions
.
FETCH_IMMEDIATELY_DOMINATED_START
id
}
)
;
try
{
response
=
yield
heapWorker
.
getImmediatelyDominated
(
{
dominatorTreeId
:
snapshot
.
dominatorTree
.
dominatorTreeId
breakdown
:
display
.
breakdown
nodeId
:
lazyChildren
.
parentNodeId
(
)
startIndex
:
lazyChildren
.
siblingIndex
(
)
}
)
;
}
catch
(
error
)
{
reportException
(
"
actions
/
snapshot
/
fetchImmediatelyDominated
"
error
)
;
dispatch
(
{
type
:
actions
.
DOMINATOR_TREE_ERROR
id
error
}
)
;
return
null
;
}
}
while
(
display
!
=
=
getState
(
)
.
dominatorTreeDisplay
)
;
dispatch
(
{
type
:
actions
.
FETCH_IMMEDIATELY_DOMINATED_END
id
path
:
response
.
path
nodes
:
response
.
nodes
moreChildrenAvailable
:
response
.
moreChildrenAvailable
}
)
;
}
;
}
;
const
computeAndFetchDominatorTree
=
exports
.
computeAndFetchDominatorTree
=
function
(
heapWorker
id
)
{
return
function
*
(
dispatch
getState
)
{
const
dominatorTreeId
=
yield
dispatch
(
computeDominatorTree
(
heapWorker
id
)
)
;
if
(
dominatorTreeId
=
=
=
null
)
{
return
null
;
}
const
root
=
yield
dispatch
(
fetchDominatorTree
(
heapWorker
id
)
)
;
if
(
!
root
)
{
return
null
;
}
return
root
;
}
;
}
;
const
refreshSelectedDominatorTree
=
exports
.
refreshSelectedDominatorTree
=
function
(
heapWorker
)
{
return
function
*
(
dispatch
getState
)
{
let
snapshot
=
getState
(
)
.
snapshots
.
find
(
s
=
>
s
.
selected
)
;
if
(
!
snapshot
)
{
return
;
}
if
(
snapshot
.
dominatorTree
&
&
!
(
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
COMPUTED
|
|
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
LOADED
|
|
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
INCREMENTAL_FETCHING
)
)
{
return
;
}
if
(
snapshot
.
state
=
=
=
states
.
READ
)
{
if
(
snapshot
.
dominatorTree
)
{
yield
dispatch
(
fetchDominatorTree
(
heapWorker
snapshot
.
id
)
)
;
}
else
{
yield
dispatch
(
computeAndFetchDominatorTree
(
heapWorker
snapshot
.
id
)
)
;
}
}
else
{
return
;
}
}
;
}
;
const
selectSnapshot
=
exports
.
selectSnapshot
=
function
(
id
)
{
return
{
type
:
actions
.
SELECT_SNAPSHOT
id
}
;
}
;
const
clearSnapshots
=
exports
.
clearSnapshots
=
function
(
heapWorker
)
{
return
function
*
(
dispatch
getState
)
{
let
snapshots
=
getState
(
)
.
snapshots
.
filter
(
s
=
>
{
let
snapshotReady
=
s
.
state
=
=
=
states
.
READ
|
|
s
.
state
=
=
=
states
.
ERROR
;
let
censusReady
=
(
s
.
treeMap
&
&
s
.
treeMap
.
state
=
=
=
treeMapState
.
SAVED
)
|
|
(
s
.
census
&
&
s
.
census
.
state
=
=
=
censusState
.
SAVED
)
;
return
snapshotReady
&
&
censusReady
}
)
;
let
ids
=
snapshots
.
map
(
s
=
>
s
.
id
)
;
dispatch
(
{
type
:
actions
.
DELETE_SNAPSHOTS_START
ids
}
)
;
if
(
getState
(
)
.
diffing
)
{
dispatch
(
diffing
.
toggleDiffing
(
)
)
;
}
yield
Promise
.
all
(
snapshots
.
map
(
snapshot
=
>
{
return
heapWorker
.
deleteHeapSnapshot
(
snapshot
.
path
)
.
catch
(
error
=
>
{
reportException
(
"
clearSnapshots
"
error
)
;
dispatch
(
{
type
:
actions
.
SNAPSHOT_ERROR
id
:
snapshot
.
id
error
}
)
;
}
)
;
}
)
)
;
dispatch
(
{
type
:
actions
.
DELETE_SNAPSHOTS_END
ids
}
)
;
}
;
}
;
const
expandCensusNode
=
exports
.
expandCensusNode
=
function
(
id
node
)
{
return
{
type
:
actions
.
EXPAND_CENSUS_NODE
id
node
}
;
}
;
const
collapseCensusNode
=
exports
.
collapseCensusNode
=
function
(
id
node
)
{
return
{
type
:
actions
.
COLLAPSE_CENSUS_NODE
id
node
}
;
}
;
const
focusCensusNode
=
exports
.
focusCensusNode
=
function
(
id
node
)
{
return
{
type
:
actions
.
FOCUS_CENSUS_NODE
id
node
}
;
}
;
const
expandDominatorTreeNode
=
exports
.
expandDominatorTreeNode
=
function
(
id
node
)
{
return
{
type
:
actions
.
EXPAND_DOMINATOR_TREE_NODE
id
node
}
;
}
;
const
collapseDominatorTreeNode
=
exports
.
collapseDominatorTreeNode
=
function
(
id
node
)
{
return
{
type
:
actions
.
COLLAPSE_DOMINATOR_TREE_NODE
id
node
}
;
}
;
const
focusDominatorTreeNode
=
exports
.
focusDominatorTreeNode
=
function
(
id
node
)
{
return
{
type
:
actions
.
FOCUS_DOMINATOR_TREE_NODE
id
node
}
;
}
;
