"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
STRINGS_URI
=
"
devtools
/
client
/
locales
/
memory
.
properties
"
;
const
L10N
=
(
exports
.
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
)
;
const
{
OS
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
assert
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
Preferences
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
const
CUSTOM_CENSUS_DISPLAY_PREF
=
"
devtools
.
memory
.
custom
-
census
-
displays
"
;
const
CUSTOM_LABEL_DISPLAY_PREF
=
"
devtools
.
memory
.
custom
-
label
-
displays
"
;
const
CUSTOM_TREE_MAP_DISPLAY_PREF
=
"
devtools
.
memory
.
custom
-
tree
-
map
-
displays
"
;
const
BYTES
=
1024
;
const
KILOBYTES
=
Math
.
pow
(
BYTES
2
)
;
const
MEGABYTES
=
Math
.
pow
(
BYTES
3
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
snapshotState
:
states
diffingState
censusState
treeMapState
dominatorTreeState
individualsState
}
=
require
(
"
.
/
constants
"
)
;
exports
.
getSnapshotTitle
=
function
(
snapshot
)
{
if
(
!
snapshot
.
creationTime
)
{
return
L10N
.
getStr
(
"
snapshot
-
title
.
loading
"
)
;
}
if
(
snapshot
.
imported
)
{
return
OS
.
Path
.
basename
(
snapshot
.
path
.
replace
(
/
\
.
fxsnapshot
/
"
"
)
)
;
}
const
date
=
new
Date
(
snapshot
.
creationTime
/
1000
)
;
return
date
.
toLocaleTimeString
(
void
0
{
year
:
"
2
-
digit
"
month
:
"
2
-
digit
"
day
:
"
2
-
digit
"
hour12
:
false
}
)
;
}
;
function
getCustomDisplaysHelper
(
pref
)
{
let
customDisplays
=
Object
.
create
(
null
)
;
try
{
customDisplays
=
JSON
.
parse
(
Preferences
.
get
(
pref
)
)
|
|
Object
.
create
(
null
)
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
String
stored
in
"
{
pref
}
"
pref
cannot
be
parsed
by
\
JSON
.
parse
(
)
\
.
)
;
}
return
Object
.
freeze
(
customDisplays
)
;
}
exports
.
getCustomCensusDisplays
=
function
(
)
{
return
getCustomDisplaysHelper
(
CUSTOM_CENSUS_DISPLAY_PREF
)
;
}
;
exports
.
getCustomLabelDisplays
=
function
(
)
{
return
getCustomDisplaysHelper
(
CUSTOM_LABEL_DISPLAY_PREF
)
;
}
;
exports
.
getCustomTreeMapDisplays
=
function
(
)
{
return
getCustomDisplaysHelper
(
CUSTOM_TREE_MAP_DISPLAY_PREF
)
;
}
;
exports
.
getStatusText
=
function
(
state
)
{
assert
(
state
"
Must
have
a
state
"
)
;
switch
(
state
)
{
case
diffingState
.
ERROR
:
return
L10N
.
getStr
(
"
diffing
.
state
.
error
"
)
;
case
states
.
ERROR
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
error
"
)
;
case
states
.
SAVING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
saving
"
)
;
case
states
.
IMPORTING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
importing
"
)
;
case
states
.
SAVED
:
case
states
.
READING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
reading
"
)
;
case
censusState
.
SAVING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
saving
-
census
"
)
;
case
treeMapState
.
SAVING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
saving
-
tree
-
map
"
)
;
case
diffingState
.
TAKING_DIFF
:
return
L10N
.
getStr
(
"
diffing
.
state
.
taking
-
diff
"
)
;
case
diffingState
.
SELECTING
:
return
L10N
.
getStr
(
"
diffing
.
state
.
selecting
"
)
;
case
dominatorTreeState
.
COMPUTING
:
case
individualsState
.
COMPUTING_DOMINATOR_TREE
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
computing
"
)
;
case
dominatorTreeState
.
COMPUTED
:
case
dominatorTreeState
.
FETCHING
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
fetching
"
)
;
case
dominatorTreeState
.
INCREMENTAL_FETCHING
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
incrementalFetching
"
)
;
case
dominatorTreeState
.
ERROR
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
error
"
)
;
case
individualsState
.
ERROR
:
return
L10N
.
getStr
(
"
individuals
.
state
.
error
"
)
;
case
individualsState
.
FETCHING
:
return
L10N
.
getStr
(
"
individuals
.
state
.
fetching
"
)
;
case
dominatorTreeState
.
LOADED
:
case
diffingState
.
TOOK_DIFF
:
case
states
.
READ
:
case
censusState
.
SAVED
:
case
treeMapState
.
SAVED
:
case
individualsState
.
FETCHED
:
return
"
"
;
default
:
assert
(
false
Unexpected
state
:
{
state
}
)
;
return
"
"
;
}
}
;
exports
.
getStatusTextFull
=
function
(
state
)
{
assert
(
!
!
state
"
Must
have
a
state
"
)
;
switch
(
state
)
{
case
diffingState
.
ERROR
:
return
L10N
.
getStr
(
"
diffing
.
state
.
error
.
full
"
)
;
case
states
.
ERROR
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
error
.
full
"
)
;
case
states
.
SAVING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
saving
.
full
"
)
;
case
states
.
IMPORTING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
importing
"
)
;
case
states
.
SAVED
:
case
states
.
READING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
reading
.
full
"
)
;
case
censusState
.
SAVING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
saving
-
census
.
full
"
)
;
case
treeMapState
.
SAVING
:
return
L10N
.
getStr
(
"
snapshot
.
state
.
saving
-
tree
-
map
.
full
"
)
;
case
diffingState
.
TAKING_DIFF
:
return
L10N
.
getStr
(
"
diffing
.
state
.
taking
-
diff
.
full
"
)
;
case
diffingState
.
SELECTING
:
return
L10N
.
getStr
(
"
diffing
.
state
.
selecting
.
full
"
)
;
case
dominatorTreeState
.
COMPUTING
:
case
individualsState
.
COMPUTING_DOMINATOR_TREE
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
computing
.
full
"
)
;
case
dominatorTreeState
.
COMPUTED
:
case
dominatorTreeState
.
FETCHING
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
fetching
.
full
"
)
;
case
dominatorTreeState
.
INCREMENTAL_FETCHING
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
incrementalFetching
.
full
"
)
;
case
dominatorTreeState
.
ERROR
:
return
L10N
.
getStr
(
"
dominatorTree
.
state
.
error
.
full
"
)
;
case
individualsState
.
ERROR
:
return
L10N
.
getStr
(
"
individuals
.
state
.
error
.
full
"
)
;
case
individualsState
.
FETCHING
:
return
L10N
.
getStr
(
"
individuals
.
state
.
fetching
.
full
"
)
;
case
dominatorTreeState
.
LOADED
:
case
diffingState
.
TOOK_DIFF
:
case
states
.
READ
:
case
censusState
.
SAVED
:
case
treeMapState
.
SAVED
:
case
individualsState
.
FETCHED
:
return
"
"
;
default
:
assert
(
false
Unexpected
state
:
{
state
}
)
;
return
"
"
;
}
}
;
exports
.
snapshotIsDiffable
=
function
snapshotIsDiffable
(
snapshot
)
{
return
(
(
snapshot
.
census
&
&
snapshot
.
census
.
state
=
=
=
censusState
.
SAVED
)
|
|
(
snapshot
.
census
&
&
snapshot
.
census
.
state
=
=
=
censusState
.
SAVING
)
|
|
snapshot
.
state
=
=
=
states
.
SAVED
|
|
snapshot
.
state
=
=
=
states
.
READ
)
;
}
;
exports
.
getSnapshot
=
function
getSnapshot
(
state
id
)
{
const
found
=
state
.
snapshots
.
find
(
s
=
>
s
.
id
=
=
=
id
)
;
assert
(
found
No
matching
snapshot
found
with
id
=
{
id
}
)
;
return
found
;
}
;
exports
.
findSelectedSnapshot
=
function
(
state
)
{
const
found
=
state
.
snapshots
.
find
(
s
=
>
s
.
selected
)
;
return
found
?
found
.
id
:
null
;
}
;
let
ID_COUNTER
=
0
;
exports
.
createSnapshot
=
function
createSnapshot
(
state
)
{
let
dominatorTree
=
null
;
if
(
state
.
view
.
state
=
=
=
dominatorTreeState
.
DOMINATOR_TREE
)
{
dominatorTree
=
Object
.
freeze
(
{
dominatorTreeId
:
null
root
:
null
error
:
null
state
:
dominatorTreeState
.
COMPUTING
}
)
;
}
return
Object
.
freeze
(
{
id
:
+
+
ID_COUNTER
state
:
states
.
SAVING
dominatorTree
census
:
null
treeMap
:
null
path
:
null
imported
:
false
selected
:
false
error
:
null
}
)
;
}
;
exports
.
censusIsUpToDate
=
function
(
filter
display
census
)
{
return
(
census
&
&
filter
=
=
census
.
filter
&
&
display
=
=
=
census
.
display
)
;
}
;
exports
.
canTakeCensus
=
function
(
snapshot
)
{
return
(
snapshot
.
state
=
=
=
states
.
READ
&
&
(
!
snapshot
.
census
|
|
snapshot
.
census
.
state
=
=
=
censusState
.
SAVED
|
|
(
!
snapshot
.
treeMap
|
|
snapshot
.
treeMap
.
state
=
=
=
treeMapState
.
SAVED
)
)
)
;
}
;
exports
.
dominatorTreeIsComputed
=
function
(
snapshot
)
{
return
(
snapshot
.
dominatorTree
&
&
(
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
COMPUTED
|
|
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
LOADED
|
|
snapshot
.
dominatorTree
.
state
=
=
=
dominatorTreeState
.
INCREMENTAL_FETCHING
)
)
;
}
;
exports
.
getSavedCensus
=
function
(
snapshot
)
{
if
(
snapshot
.
treeMap
&
&
snapshot
.
treeMap
.
state
=
=
=
treeMapState
.
SAVED
)
{
return
snapshot
.
treeMap
;
}
if
(
snapshot
.
census
&
&
snapshot
.
census
.
state
=
=
=
censusState
.
SAVED
)
{
return
snapshot
.
census
;
}
return
null
;
}
;
exports
.
getSnapshotTotals
=
function
(
census
)
{
let
bytes
=
0
;
let
count
=
0
;
const
report
=
census
.
report
;
if
(
report
)
{
bytes
=
report
.
totalBytes
;
count
=
report
.
totalCount
;
}
return
{
bytes
count
}
;
}
;
exports
.
openFilePicker
=
function
(
{
title
filters
defaultName
mode
}
)
{
let
fpMode
;
if
(
mode
=
=
=
"
save
"
)
{
fpMode
=
Ci
.
nsIFilePicker
.
modeSave
;
}
else
if
(
mode
=
=
=
"
open
"
)
{
fpMode
=
Ci
.
nsIFilePicker
.
modeOpen
;
}
else
{
throw
new
Error
(
"
No
valid
mode
specified
for
nsIFilePicker
.
"
)
;
}
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
title
fpMode
)
;
for
(
const
filter
of
filters
|
|
[
]
)
{
fp
.
appendFilter
(
filter
[
0
]
filter
[
1
]
)
;
}
fp
.
defaultString
=
defaultName
;
return
new
Promise
(
resolve
=
>
{
fp
.
open
(
{
done
:
result
=
>
{
if
(
result
=
=
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
resolve
(
null
)
;
return
;
}
resolve
(
fp
.
file
)
;
}
}
)
;
}
)
;
}
;
exports
.
formatNumber
=
function
(
number
showSign
=
false
)
{
const
rounded
=
Math
.
round
(
number
)
;
if
(
rounded
=
=
=
0
|
|
rounded
=
=
=
-
0
)
{
return
"
0
"
;
}
const
abs
=
String
(
Math
.
abs
(
rounded
)
)
;
const
formatted
=
abs
.
replace
(
/
(
\
d
)
(
?
=
(
\
d
{
3
}
)
+
)
/
g
"
1
"
)
;
if
(
showSign
)
{
const
sign
=
rounded
<
0
?
"
-
"
:
"
+
"
;
return
sign
+
formatted
;
}
return
formatted
;
}
;
exports
.
formatPercent
=
function
(
percent
showSign
=
false
)
{
return
exports
.
L10N
.
getFormatStr
(
"
tree
-
item
.
percent2
"
exports
.
formatNumber
(
percent
showSign
)
)
;
}
;
exports
.
hslToStyle
=
function
(
h
s
l
)
{
h
=
parseInt
(
h
*
360
10
)
;
s
=
parseInt
(
s
*
100
10
)
;
l
=
parseInt
(
l
*
100
10
)
;
return
hsl
(
{
h
}
{
s
}
%
{
l
}
%
)
;
}
;
exports
.
lerp
=
function
(
a
b
t
)
{
return
a
*
(
1
-
t
)
+
b
*
t
;
}
;
exports
.
formatAbbreviatedBytes
=
function
(
n
)
{
if
(
n
<
BYTES
)
{
return
n
+
"
B
"
;
}
else
if
(
n
<
KILOBYTES
)
{
return
Math
.
floor
(
n
/
BYTES
)
+
"
KiB
"
;
}
else
if
(
n
<
MEGABYTES
)
{
return
Math
.
floor
(
n
/
KILOBYTES
)
+
"
MiB
"
;
}
return
Math
.
floor
(
n
/
MEGABYTES
)
+
"
GiB
"
;
}
;
