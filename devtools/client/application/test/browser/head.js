"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
async
function
enableServiceWorkerDebugging
(
)
{
await
pushPref
(
"
dom
.
serviceWorkers
.
enabled
"
true
)
;
await
pushPref
(
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processCount
"
1
)
;
await
pushPref
(
"
devtools
.
debugger
.
features
.
windowless
-
service
-
workers
"
true
)
;
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
Services
.
ppmm
.
releaseCachedProcesses
(
)
;
}
async
function
enableApplicationPanel
(
)
{
const
{
PromiseTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
;
PromiseTestUtils
.
allowMatchingRejectionsGlobally
(
/
this
.
_frontCreationListeners
is
null
/
)
;
await
enableServiceWorkerDebugging
(
)
;
Services
.
prefs
.
setBoolPref
(
"
dom
.
manifest
.
enabled
"
true
)
;
await
pushPref
(
"
devtools
.
application
.
enabled
"
true
)
;
}
function
setupTelemetryTest
(
)
{
Services
.
telemetry
.
clearEvents
(
)
;
const
ALL_CHANNELS
=
Ci
.
nsITelemetry
.
DATASET_ALL_CHANNELS
;
const
snapshot
=
Services
.
telemetry
.
snapshotEvents
(
ALL_CHANNELS
true
)
;
ok
(
!
snapshot
.
parent
"
No
events
have
been
logged
for
the
main
process
"
)
;
}
function
getTelemetryEvents
(
objectName
)
{
const
ALL_CHANNELS
=
Ci
.
nsITelemetry
.
DATASET_ALL_CHANNELS
;
const
snapshot
=
Services
.
telemetry
.
snapshotEvents
(
ALL_CHANNELS
true
)
;
const
events
=
snapshot
.
parent
.
filter
(
event
=
>
event
[
1
]
=
=
=
"
devtools
.
main
"
&
&
event
[
3
]
=
=
=
objectName
)
.
map
(
event
=
>
(
{
method
:
event
[
2
]
.
.
.
event
[
5
]
}
)
)
;
return
events
;
}
function
checkTelemetryEvent
(
expectedEvent
objectName
=
"
application
"
)
{
info
(
"
Check
telemetry
event
"
)
;
const
events
=
getTelemetryEvents
(
objectName
)
;
is
(
events
.
length
1
"
There
was
only
1
event
logged
"
)
;
const
[
event
]
=
events
;
ok
(
event
.
session_id
>
0
"
There
is
a
valid
session_id
in
the
event
"
)
;
Assert
.
deepEqual
(
event
{
.
.
.
expectedEvent
session_id
:
event
.
session_id
}
)
;
}
function
getWorkerContainers
(
doc
)
{
return
doc
.
querySelectorAll
(
"
.
js
-
sw
-
container
"
)
;
}
async
function
openNewTabAndApplicationPanel
(
url
)
{
const
tab
=
await
addTab
(
url
)
;
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
application
"
}
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
target
=
toolbox
.
target
;
const
commands
=
toolbox
.
commands
;
return
{
panel
tab
target
toolbox
commands
}
;
}
async
function
unregisterAllWorkers
(
client
doc
)
{
await
unregisterAllServiceWorkers
(
client
)
;
info
(
"
Wait
for
service
workers
to
disappear
from
the
UI
"
)
;
waitUntil
(
(
)
=
>
getWorkerContainers
(
doc
)
.
length
=
=
=
0
)
;
}
async
function
waitForWorkerRegistration
(
swTab
)
{
info
(
"
Wait
until
the
registration
appears
on
the
window
"
)
;
const
swBrowser
=
swTab
.
linkedBrowser
;
await
asyncWaitUntil
(
async
(
)
=
>
SpecialPowers
.
spawn
(
swBrowser
[
]
function
(
)
{
return
!
!
content
.
wrappedJSObject
.
getRegistration
(
)
;
}
)
)
;
}
function
selectPage
(
panel
page
)
{
info
(
Selecting
application
page
:
{
page
}
)
;
const
doc
=
panel
.
panelWin
.
document
;
const
navItem
=
doc
.
querySelector
(
.
js
-
sidebar
-
{
page
}
)
;
navItem
.
click
(
)
;
}
