"
use
strict
"
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
SideMenuWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
SideMenuWidget
.
jsm
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
)
;
const
Editor
=
require
(
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
WidgetMethods
setNamedTimeout
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
EVENTS
=
{
NEW_PROGRAM
:
"
ShaderEditor
:
NewProgram
"
PROGRAMS_ADDED
:
"
ShaderEditor
:
ProgramsAdded
"
SOURCES_SHOWN
:
"
ShaderEditor
:
SourcesShown
"
SHADER_COMPILED
:
"
ShaderEditor
:
ShaderCompiled
"
UI_RESET
:
"
ShaderEditor
:
UIReset
"
EDITOR_ERROR_MARKERS_REMOVED
:
"
ShaderEditor
:
EditorCleaned
"
}
;
exports
.
EVENTS
=
EVENTS
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
STRINGS_URI
=
"
devtools
/
client
/
locales
/
shadereditor
.
properties
"
;
const
HIGHLIGHT_TINT
=
[
1
0
0
.
25
1
]
;
const
TYPING_MAX_DELAY
=
500
;
const
SHADERS_AUTOGROW_ITEMS
=
4
;
const
GUTTER_ERROR_PANEL_OFFSET_X
=
7
;
const
GUTTER_ERROR_PANEL_DELAY
=
100
;
const
DEFAULT_EDITOR_CONFIG
=
{
gutters
:
[
"
errors
"
]
lineNumbers
:
true
showAnnotationRuler
:
true
}
;
class
EventsHandler
{
initialize
(
panel
toolbox
target
front
shadersListView
)
{
this
.
panel
=
panel
;
this
.
toolbox
=
toolbox
;
this
.
target
=
target
;
this
.
front
=
front
;
this
.
shadersListView
=
shadersListView
;
this
.
_onHostChanged
=
this
.
_onHostChanged
.
bind
(
this
)
;
this
.
_onTabNavigated
=
this
.
_onTabNavigated
.
bind
(
this
)
;
this
.
_onTabWillNavigate
=
this
.
_onTabWillNavigate
.
bind
(
this
)
;
this
.
_onProgramLinked
=
this
.
_onProgramLinked
.
bind
(
this
)
;
this
.
_onProgramsAdded
=
this
.
_onProgramsAdded
.
bind
(
this
)
;
this
.
toolbox
.
on
(
"
host
-
changed
"
this
.
_onHostChanged
)
;
this
.
target
.
on
(
"
will
-
navigate
"
this
.
_onTabWillNavigate
)
;
this
.
target
.
on
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
front
.
on
(
"
program
-
linked
"
this
.
_onProgramLinked
)
;
this
.
reloadButton
=
(
"
#
requests
-
menu
-
reload
-
notice
-
button
"
)
;
this
.
_onReloadCommand
=
this
.
_onReloadCommand
.
bind
(
this
)
;
this
.
reloadButton
.
addEventListener
(
"
command
"
this
.
_onReloadCommand
)
;
}
destroy
(
)
{
this
.
toolbox
.
off
(
"
host
-
changed
"
this
.
_onHostChanged
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
_onTabWillNavigate
)
;
this
.
target
.
off
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
front
.
off
(
"
program
-
linked
"
this
.
_onProgramLinked
)
;
this
.
reloadButton
.
removeEventListener
(
"
command
"
this
.
_onReloadCommand
)
;
}
_onReloadCommand
(
)
{
this
.
front
.
setup
(
{
reload
:
true
}
)
;
}
_onHostChanged
(
)
{
if
(
this
.
toolbox
.
hostType
=
=
"
right
"
|
|
this
.
toolbox
.
hostType
=
=
"
left
"
)
{
(
"
#
shaders
-
pane
"
)
.
removeAttribute
(
"
height
"
)
;
}
}
_onTabWillNavigate
(
{
isFrameSwitching
}
)
{
if
(
!
isFrameSwitching
)
{
this
.
front
.
setup
(
{
reload
:
false
}
)
;
}
this
.
shadersListView
.
empty
(
)
;
if
(
isFrameSwitching
)
{
(
"
#
reload
-
notice
"
)
.
hidden
=
false
;
(
"
#
waiting
-
notice
"
)
.
hidden
=
true
;
}
else
{
(
"
#
reload
-
notice
"
)
.
hidden
=
true
;
(
"
#
waiting
-
notice
"
)
.
hidden
=
false
;
}
(
"
#
content
"
)
.
hidden
=
true
;
this
.
panel
.
emit
(
EVENTS
.
UI_RESET
)
;
}
_onTabNavigated
(
)
{
this
.
front
.
getPrograms
(
)
.
then
(
this
.
_onProgramsAdded
)
;
}
_onProgramLinked
(
programActor
)
{
this
.
_addProgram
(
programActor
)
;
this
.
panel
.
emit
(
EVENTS
.
NEW_PROGRAM
)
;
}
_onProgramsAdded
(
programActors
)
{
programActors
.
forEach
(
this
.
_addProgram
.
bind
(
this
)
)
;
this
.
panel
.
emit
(
EVENTS
.
PROGRAMS_ADDED
)
;
}
_addProgram
(
programActor
)
{
(
"
#
waiting
-
notice
"
)
.
hidden
=
true
;
(
"
#
reload
-
notice
"
)
.
hidden
=
true
;
(
"
#
content
"
)
.
hidden
=
false
;
this
.
shadersListView
.
addProgram
(
programActor
)
;
}
}
exports
.
EventsHandler
=
EventsHandler
;
function
WidgetMethodsClass
(
)
{
}
WidgetMethodsClass
.
prototype
=
WidgetMethods
;
class
ShadersListView
extends
WidgetMethodsClass
{
initialize
(
toolbox
shadersEditorsView
)
{
this
.
toolbox
=
toolbox
;
this
.
shadersEditorsView
=
shadersEditorsView
;
this
.
widget
=
new
SideMenuWidget
(
this
.
_pane
=
(
"
#
shaders
-
pane
"
)
{
showArrows
:
true
showItemCheckboxes
:
true
}
)
;
this
.
_onProgramSelect
=
this
.
_onProgramSelect
.
bind
(
this
)
;
this
.
_onProgramCheck
=
this
.
_onProgramCheck
.
bind
(
this
)
;
this
.
_onProgramMouseOver
=
this
.
_onProgramMouseOver
.
bind
(
this
)
;
this
.
_onProgramMouseOut
=
this
.
_onProgramMouseOut
.
bind
(
this
)
;
this
.
widget
.
addEventListener
(
"
select
"
this
.
_onProgramSelect
)
;
this
.
widget
.
addEventListener
(
"
check
"
this
.
_onProgramCheck
)
;
this
.
widget
.
addEventListener
(
"
mouseover
"
this
.
_onProgramMouseOver
true
)
;
this
.
widget
.
addEventListener
(
"
mouseout
"
this
.
_onProgramMouseOut
true
)
;
}
destroy
(
)
{
this
.
widget
.
removeEventListener
(
"
select
"
this
.
_onProgramSelect
)
;
this
.
widget
.
removeEventListener
(
"
check
"
this
.
_onProgramCheck
)
;
this
.
widget
.
removeEventListener
(
"
mouseover
"
this
.
_onProgramMouseOver
true
)
;
this
.
widget
.
removeEventListener
(
"
mouseout
"
this
.
_onProgramMouseOut
true
)
;
}
addProgram
(
programActor
)
{
if
(
this
.
hasProgram
(
programActor
)
)
{
return
;
}
const
label
=
L10N
.
getFormatStr
(
"
shadersList
.
programLabel
"
this
.
itemCount
)
;
const
contents
=
document
.
createElement
(
"
label
"
)
;
contents
.
className
=
"
plain
program
-
item
"
;
contents
.
setAttribute
(
"
value
"
label
)
;
contents
.
setAttribute
(
"
crop
"
"
start
"
)
;
contents
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
push
(
[
contents
]
{
index
:
-
1
attachment
:
{
label
:
label
programActor
:
programActor
checkboxState
:
true
checkboxTooltip
:
L10N
.
getStr
(
"
shadersList
.
blackboxLabel
"
)
}
}
)
;
if
(
!
this
.
selectedItem
)
{
this
.
selectedIndex
=
0
;
}
if
(
(
this
.
toolbox
.
hostType
=
=
"
left
"
|
|
this
.
toolbox
.
hostType
=
=
"
right
"
)
&
&
this
.
itemCount
=
=
SHADERS_AUTOGROW_ITEMS
)
{
this
.
_pane
.
setAttribute
(
"
height
"
this
.
_pane
.
getBoundingClientRect
(
)
.
height
)
;
}
}
hasProgram
(
programActor
)
{
return
!
!
this
.
attachments
.
filter
(
e
=
>
e
.
programActor
=
=
programActor
)
.
length
;
}
_onProgramSelect
(
{
detail
:
sourceItem
}
)
{
if
(
!
sourceItem
)
{
return
;
}
const
attachment
=
sourceItem
.
attachment
;
function
getShaders
(
)
{
return
promise
.
all
(
[
attachment
.
vs
|
|
(
attachment
.
vs
=
attachment
.
programActor
.
getVertexShader
(
)
)
attachment
.
fs
|
|
(
attachment
.
fs
=
attachment
.
programActor
.
getFragmentShader
(
)
)
]
)
;
}
function
getSources
(
[
vertexShaderActor
fragmentShaderActor
]
)
{
return
promise
.
all
(
[
vertexShaderActor
.
getText
(
)
fragmentShaderActor
.
getText
(
)
]
)
;
}
const
showSources
=
(
[
vertexShaderText
fragmentShaderText
]
)
=
>
{
return
this
.
shadersEditorsView
.
setText
(
{
vs
:
vertexShaderText
fs
:
fragmentShaderText
}
)
;
}
;
getShaders
(
)
.
then
(
getSources
)
.
then
(
showSources
)
.
catch
(
console
.
error
)
;
}
_onProgramCheck
(
{
detail
:
{
checked
}
target
}
)
{
const
sourceItem
=
this
.
getItemForElement
(
target
)
;
const
attachment
=
sourceItem
.
attachment
;
attachment
.
isBlackBoxed
=
!
checked
;
attachment
.
programActor
[
checked
?
"
unblackbox
"
:
"
blackbox
"
]
(
)
;
}
_onProgramMouseOver
(
e
)
{
const
sourceItem
=
this
.
getItemForElement
(
e
.
target
{
noSiblings
:
true
}
)
;
if
(
sourceItem
&
&
!
sourceItem
.
attachment
.
isBlackBoxed
)
{
sourceItem
.
attachment
.
programActor
.
highlight
(
HIGHLIGHT_TINT
)
;
if
(
e
instanceof
Event
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
}
}
_onProgramMouseOut
(
e
)
{
const
sourceItem
=
this
.
getItemForElement
(
e
.
target
{
noSiblings
:
true
}
)
;
if
(
sourceItem
&
&
!
sourceItem
.
attachment
.
isBlackBoxed
)
{
sourceItem
.
attachment
.
programActor
.
unhighlight
(
)
;
if
(
e
instanceof
Event
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
}
}
}
exports
.
ShadersListView
=
ShadersListView
;
class
ShadersEditorsView
{
initialize
(
panel
shadersListView
)
{
this
.
panel
=
panel
;
this
.
shadersListView
=
shadersListView
;
XPCOMUtils
.
defineLazyGetter
(
this
"
_editorPromises
"
(
)
=
>
new
Map
(
)
)
;
this
.
_vsFocused
=
this
.
_onFocused
.
bind
(
this
"
vs
"
"
fs
"
)
;
this
.
_fsFocused
=
this
.
_onFocused
.
bind
(
this
"
fs
"
"
vs
"
)
;
this
.
_vsChanged
=
this
.
_onChanged
.
bind
(
this
"
vs
"
)
;
this
.
_fsChanged
=
this
.
_onChanged
.
bind
(
this
"
fs
"
)
;
this
.
_errors
=
{
vs
:
[
]
fs
:
[
]
}
;
}
async
destroy
(
)
{
this
.
_destroyed
=
true
;
await
this
.
_toggleListeners
(
"
off
"
)
;
for
(
const
p
of
this
.
_editorPromises
.
values
(
)
)
{
const
editor
=
await
p
;
editor
.
destroy
(
)
;
}
}
setText
(
sources
)
{
const
view
=
this
;
function
setTextAndClearHistory
(
editor
text
)
{
editor
.
setText
(
text
)
;
editor
.
clearHistory
(
)
;
}
return
(
async
function
(
)
{
await
view
.
_toggleListeners
(
"
off
"
)
;
await
promise
.
all
(
[
view
.
_getEditor
(
"
vs
"
)
.
then
(
e
=
>
setTextAndClearHistory
(
e
sources
.
vs
)
)
view
.
_getEditor
(
"
fs
"
)
.
then
(
e
=
>
setTextAndClearHistory
(
e
sources
.
fs
)
)
]
)
;
await
view
.
_toggleListeners
(
"
on
"
)
;
}
)
(
)
.
then
(
(
)
=
>
this
.
panel
.
emit
(
EVENTS
.
SOURCES_SHOWN
sources
)
)
;
}
_getEditor
(
type
)
{
if
(
this
.
_editorPromises
.
has
(
type
)
)
{
return
this
.
_editorPromises
.
get
(
type
)
;
}
const
promise
=
new
Promise
(
resolve
=
>
{
const
parent
=
(
"
#
"
+
type
+
"
-
editor
"
)
;
const
editor
=
new
Editor
(
DEFAULT_EDITOR_CONFIG
)
;
editor
.
config
.
mode
=
Editor
.
modes
[
type
]
;
if
(
this
.
_destroyed
)
{
resolve
(
editor
)
;
}
else
{
editor
.
appendTo
(
parent
)
.
then
(
(
)
=
>
resolve
(
editor
)
)
;
}
}
)
;
this
.
_editorPromises
.
set
(
type
promise
)
;
return
promise
;
}
_toggleListeners
(
flag
)
{
return
promise
.
all
(
[
"
vs
"
"
fs
"
]
.
map
(
type
=
>
{
return
this
.
_getEditor
(
type
)
.
then
(
editor
=
>
{
editor
[
flag
]
(
"
focus
"
this
[
"
_
"
+
type
+
"
Focused
"
]
)
;
editor
[
flag
]
(
"
change
"
this
[
"
_
"
+
type
+
"
Changed
"
]
)
;
}
)
;
}
)
)
;
}
_onFocused
(
focused
unfocused
)
{
(
"
#
"
+
focused
+
"
-
editor
-
label
"
)
.
setAttribute
(
"
selected
"
"
"
)
;
(
"
#
"
+
unfocused
+
"
-
editor
-
label
"
)
.
removeAttribute
(
"
selected
"
)
;
}
_onChanged
(
type
)
{
setNamedTimeout
(
"
gl
-
typed
"
TYPING_MAX_DELAY
(
)
=
>
this
.
_doCompile
(
type
)
)
;
this
.
_cleanEditor
(
type
)
;
}
_doCompile
(
type
)
{
(
async
function
(
)
{
const
editor
=
await
this
.
_getEditor
(
type
)
;
const
shaderActor
=
await
this
.
shadersListView
.
selectedAttachment
[
type
]
;
try
{
await
shaderActor
.
compile
(
editor
.
getText
(
)
)
;
this
.
_onSuccessfulCompilation
(
)
;
}
catch
(
e
)
{
this
.
_onFailedCompilation
(
type
editor
e
)
;
}
}
.
bind
(
this
)
)
(
)
;
}
_onSuccessfulCompilation
(
)
{
this
.
panel
.
emit
(
EVENTS
.
SHADER_COMPILED
null
)
;
}
_onFailedCompilation
(
type
editor
errors
)
{
const
lineCount
=
editor
.
lineCount
(
)
;
const
currentLine
=
editor
.
getCursor
(
)
.
line
;
const
listeners
=
{
mouseover
:
this
.
_onMarkerMouseOver
}
;
function
matchLinesAndMessages
(
string
)
{
return
{
lineMatch
:
string
.
match
(
/
\
d
{
2
}
|
[
1
-
9
]
/
)
textMatch
:
string
.
match
(
/
[
^
\
s
\
d
:
]
[
^
\
r
\
n
|
]
*
/
)
}
;
}
function
discardInvalidMatches
(
e
)
{
return
e
.
lineMatch
&
&
e
.
textMatch
;
}
function
sanitizeValidMatches
(
e
)
{
return
{
line
:
e
.
lineMatch
[
0
]
>
lineCount
?
currentLine
:
e
.
lineMatch
[
0
]
-
1
text
:
e
.
textMatch
[
0
]
.
trim
(
)
.
replace
(
/
\
s
{
2
}
/
g
"
"
)
}
;
}
function
sortByLine
(
first
second
)
{
return
first
.
line
>
second
.
line
?
1
:
-
1
;
}
function
groupSameLineMessages
(
accumulator
current
)
{
const
previous
=
accumulator
[
accumulator
.
length
-
1
]
;
if
(
!
previous
|
|
previous
.
line
!
=
current
.
line
)
{
return
[
.
.
.
accumulator
{
line
:
current
.
line
messages
:
[
current
.
text
]
}
]
;
}
previous
.
messages
.
push
(
current
.
text
)
;
return
accumulator
;
}
function
displayErrors
(
{
line
messages
}
)
{
editor
.
addMarker
(
line
"
errors
"
"
error
"
)
;
editor
.
setMarkerListeners
(
line
"
errors
"
"
error
"
listeners
messages
)
;
editor
.
addLineClass
(
line
"
error
-
line
"
)
;
}
(
this
.
_errors
[
type
]
=
errors
.
link
.
split
(
"
ERROR
"
)
.
map
(
matchLinesAndMessages
)
.
filter
(
discardInvalidMatches
)
.
map
(
sanitizeValidMatches
)
.
sort
(
sortByLine
)
.
reduce
(
groupSameLineMessages
[
]
)
)
.
forEach
(
displayErrors
)
;
this
.
panel
.
emit
(
EVENTS
.
SHADER_COMPILED
errors
)
;
}
_onMarkerMouseOver
(
line
node
messages
)
{
if
(
node
.
_markerErrorsTooltip
)
{
return
;
}
const
tooltip
=
node
.
_markerErrorsTooltip
=
new
HTMLTooltip
(
document
{
type
:
"
arrow
"
useXulWrapper
:
true
}
)
;
const
div
=
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
div
.
className
=
"
devtools
-
shader
-
tooltip
-
container
"
;
for
(
const
message
of
messages
)
{
const
messageDiv
=
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
messageDiv
.
className
=
"
devtools
-
tooltip
-
simple
-
text
"
;
messageDiv
.
textContent
=
message
;
div
.
appendChild
(
messageDiv
)
;
}
tooltip
.
panel
.
appendChild
(
div
)
;
tooltip
.
startTogglingOnHover
(
node
(
)
=
>
true
{
toggleDelay
:
GUTTER_ERROR_PANEL_DELAY
}
)
;
}
_cleanEditor
(
type
)
{
this
.
_getEditor
(
type
)
.
then
(
editor
=
>
{
editor
.
removeAllMarkers
(
"
errors
"
)
;
this
.
_errors
[
type
]
.
forEach
(
e
=
>
editor
.
removeLineClass
(
e
.
line
)
)
;
this
.
_errors
[
type
]
.
length
=
0
;
this
.
panel
.
emit
(
EVENTS
.
EDITOR_ERROR_MARKERS_REMOVED
)
;
}
)
;
}
}
exports
.
ShadersEditorsView
=
ShadersEditorsView
;
var
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
exports
.
L10N
=
L10N
;
var
=
(
selector
target
=
document
)
=
>
target
.
querySelector
(
selector
)
;
exports
.
=
;
