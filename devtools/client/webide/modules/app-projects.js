const
{
Cc
Ci
Cu
Cr
}
=
require
(
"
chrome
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
generateUUID
}
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
const
{
FileUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
IDB
=
{
_db
:
null
databaseName
:
"
AppProjects
"
open
:
function
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
request
=
indexedDB
.
open
(
IDB
.
databaseName
5
)
;
request
.
onerror
=
function
(
event
)
{
reject
(
"
Unable
to
open
AppProjects
indexedDB
:
"
+
this
.
error
.
name
+
"
-
"
+
this
.
error
.
message
)
;
}
;
request
.
onupgradeneeded
=
function
(
event
)
{
let
db
=
event
.
target
.
result
;
db
.
createObjectStore
(
"
projects
"
{
keyPath
:
"
location
"
}
)
;
}
;
request
.
onsuccess
=
function
(
)
{
let
db
=
IDB
.
_db
=
request
.
result
;
let
objectStore
=
db
.
transaction
(
"
projects
"
)
.
objectStore
(
"
projects
"
)
;
let
projects
=
[
]
;
let
toRemove
=
[
]
;
objectStore
.
openCursor
(
)
.
onsuccess
=
function
(
event
)
{
let
cursor
=
event
.
target
.
result
;
if
(
cursor
)
{
if
(
cursor
.
value
.
location
)
{
try
{
let
file
=
FileUtils
.
File
(
cursor
.
value
.
location
)
;
if
(
file
.
exists
(
)
)
{
projects
.
push
(
cursor
.
value
)
;
}
else
{
toRemove
.
push
(
cursor
.
value
.
location
)
;
}
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_ERROR_FILE_UNRECOGNIZED_PATH
)
{
projects
.
push
(
cursor
.
value
)
;
}
}
}
cursor
.
continue
(
)
;
}
else
{
let
removePromises
=
[
]
;
for
(
let
location
of
toRemove
)
{
removePromises
.
push
(
IDB
.
remove
(
location
)
)
;
}
Promise
.
all
(
removePromises
)
.
then
(
(
)
=
>
{
resolve
(
projects
)
;
}
)
;
}
}
;
}
;
}
)
;
}
add
:
function
(
project
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
!
project
.
location
)
{
reject
(
"
Missing
location
property
on
project
object
.
"
)
;
}
else
{
let
transaction
=
IDB
.
_db
.
transaction
(
[
"
projects
"
]
"
readwrite
"
)
;
let
objectStore
=
transaction
.
objectStore
(
"
projects
"
)
;
let
request
=
objectStore
.
add
(
project
)
;
request
.
onerror
=
function
(
event
)
{
reject
(
"
Unable
to
add
project
to
the
AppProjects
indexedDB
:
"
+
this
.
error
.
name
+
"
-
"
+
this
.
error
.
message
)
;
}
;
request
.
onsuccess
=
function
(
)
{
resolve
(
)
;
}
;
}
}
)
;
}
update
:
function
(
project
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
var
transaction
=
IDB
.
_db
.
transaction
(
[
"
projects
"
]
"
readwrite
"
)
;
var
objectStore
=
transaction
.
objectStore
(
"
projects
"
)
;
var
request
=
objectStore
.
put
(
project
)
;
request
.
onerror
=
function
(
event
)
{
reject
(
"
Unable
to
update
project
to
the
AppProjects
indexedDB
:
"
+
this
.
error
.
name
+
"
-
"
+
this
.
error
.
message
)
;
}
;
request
.
onsuccess
=
function
(
)
{
resolve
(
)
;
}
;
}
)
;
}
remove
:
function
(
location
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
request
=
IDB
.
_db
.
transaction
(
[
"
projects
"
]
"
readwrite
"
)
.
objectStore
(
"
projects
"
)
.
delete
(
location
)
;
request
.
onsuccess
=
function
(
event
)
{
resolve
(
)
;
}
;
request
.
onerror
=
function
(
)
{
reject
(
"
Unable
to
delete
project
to
the
AppProjects
indexedDB
:
"
+
this
.
error
.
name
+
"
-
"
+
this
.
error
.
message
)
;
}
;
}
)
;
}
}
;
var
loadDeferred
=
IDB
.
open
(
)
.
then
(
function
(
projects
)
{
AppProjects
.
projects
=
projects
;
AppProjects
.
emit
(
"
ready
"
projects
)
;
}
)
;
const
AppProjects
=
{
load
:
function
(
)
{
return
loadDeferred
;
}
addPackaged
:
function
(
folder
)
{
let
file
=
FileUtils
.
File
(
folder
.
path
)
;
if
(
!
file
.
exists
(
)
)
{
return
Promise
.
reject
(
"
path
doesn
'
t
exist
"
)
;
}
let
existingProject
=
this
.
get
(
folder
.
path
)
;
if
(
existingProject
)
{
return
Promise
.
reject
(
"
Already
added
"
)
;
}
let
project
=
{
type
:
"
packaged
"
location
:
folder
.
path
packagedAppOrigin
:
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
}
;
return
IDB
.
add
(
project
)
.
then
(
(
)
=
>
{
this
.
projects
.
push
(
project
)
;
return
project
;
}
)
;
}
addHosted
:
function
(
manifestURL
)
{
let
existingProject
=
this
.
get
(
manifestURL
)
;
if
(
existingProject
)
{
return
Promise
.
reject
(
"
Already
added
"
)
;
}
let
project
=
{
type
:
"
hosted
"
location
:
manifestURL
}
;
return
IDB
.
add
(
project
)
.
then
(
(
)
=
>
{
this
.
projects
.
push
(
project
)
;
return
project
;
}
)
;
}
update
:
function
(
project
)
{
return
IDB
.
update
(
project
)
;
}
updateLocation
:
function
(
project
newLocation
)
{
return
IDB
.
remove
(
project
.
location
)
.
then
(
(
)
=
>
{
project
.
location
=
newLocation
;
return
IDB
.
add
(
project
)
;
}
)
;
}
remove
:
function
(
location
)
{
return
IDB
.
remove
(
location
)
.
then
(
(
)
=
>
{
for
(
let
i
=
0
;
i
<
this
.
projects
.
length
;
i
+
+
)
{
if
(
this
.
projects
[
i
]
.
location
=
=
location
)
{
this
.
projects
.
splice
(
i
1
)
;
return
;
}
}
throw
new
Error
(
"
Unable
to
find
project
in
AppProjects
store
"
)
;
}
)
;
}
get
:
function
(
location
)
{
for
(
let
i
=
0
;
i
<
this
.
projects
.
length
;
i
+
+
)
{
if
(
this
.
projects
[
i
]
.
location
=
=
location
)
{
return
this
.
projects
[
i
]
;
}
}
return
null
;
}
projects
:
[
]
}
;
EventEmitter
.
decorate
(
AppProjects
)
;
exports
.
AppProjects
=
AppProjects
;
