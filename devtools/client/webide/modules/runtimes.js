"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Devices
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
apps
/
Devices
.
jsm
"
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
const
discovery
=
require
(
"
devtools
/
shared
/
discovery
/
discovery
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
promise
=
require
(
"
promise
"
)
;
loader
.
lazyRequireGetter
(
this
"
AuthenticationResult
"
"
devtools
/
shared
/
security
/
auth
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
Strings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
webide
.
properties
"
)
;
var
RuntimeScanners
=
{
_enabledCount
:
0
_scanners
:
new
Set
(
)
get
enabled
(
)
{
return
!
!
this
.
_enabledCount
;
}
add
(
scanner
)
{
if
(
this
.
enabled
)
{
this
.
_enableScanner
(
scanner
)
;
}
this
.
_scanners
.
add
(
scanner
)
;
this
.
_emitUpdated
(
)
;
}
remove
(
scanner
)
{
this
.
_scanners
.
delete
(
scanner
)
;
if
(
this
.
enabled
)
{
this
.
_disableScanner
(
scanner
)
;
}
this
.
_emitUpdated
(
)
;
}
has
(
scanner
)
{
return
this
.
_scanners
.
has
(
scanner
)
;
}
scan
(
)
{
if
(
!
this
.
enabled
)
{
return
promise
.
resolve
(
)
;
}
if
(
this
.
_scanPromise
)
{
return
this
.
_scanPromise
;
}
const
promises
=
[
]
;
for
(
const
scanner
of
this
.
_scanners
)
{
promises
.
push
(
scanner
.
scan
(
)
)
;
}
this
.
_scanPromise
=
promise
.
all
(
promises
)
;
this
.
_scanPromise
.
then
(
(
)
=
>
{
this
.
_scanPromise
=
null
;
}
(
)
=
>
{
this
.
_scanPromise
=
null
;
}
)
;
return
this
.
_scanPromise
;
}
listRuntimes
:
function
*
(
)
{
for
(
const
scanner
of
this
.
_scanners
)
{
for
(
const
runtime
of
scanner
.
listRuntimes
(
)
)
{
yield
runtime
;
}
}
}
_emitUpdated
(
)
{
this
.
emit
(
"
runtime
-
list
-
updated
"
)
;
}
enable
(
)
{
if
(
this
.
_enabledCount
+
+
!
=
=
0
)
{
return
;
}
this
.
_emitUpdated
=
this
.
_emitUpdated
.
bind
(
this
)
;
for
(
const
scanner
of
this
.
_scanners
)
{
this
.
_enableScanner
(
scanner
)
;
}
}
_enableScanner
(
scanner
)
{
scanner
.
enable
(
)
;
scanner
.
on
(
"
runtime
-
list
-
updated
"
this
.
_emitUpdated
)
;
}
disable
(
)
{
if
(
-
-
this
.
_enabledCount
!
=
=
0
)
{
return
;
}
for
(
const
scanner
of
this
.
_scanners
)
{
this
.
_disableScanner
(
scanner
)
;
}
}
_disableScanner
(
scanner
)
{
scanner
.
off
(
"
runtime
-
list
-
updated
"
this
.
_emitUpdated
)
;
scanner
.
disable
(
)
;
}
}
;
EventEmitter
.
decorate
(
RuntimeScanners
)
;
exports
.
RuntimeScanners
=
RuntimeScanners
;
var
LazyAdbScanner
=
{
enable
(
)
{
Devices
.
emit
(
"
adb
-
start
-
polling
"
)
;
}
disable
(
)
{
Devices
.
emit
(
"
adb
-
stop
-
polling
"
)
;
}
scan
(
)
{
return
promise
.
resolve
(
)
;
}
listRuntimes
:
function
(
)
{
return
[
]
;
}
}
;
EventEmitter
.
decorate
(
LazyAdbScanner
)
;
RuntimeScanners
.
add
(
LazyAdbScanner
)
;
var
WiFiScanner
=
{
_runtimes
:
[
]
init
(
)
{
this
.
updateRegistration
(
)
;
Services
.
prefs
.
addObserver
(
this
.
ALLOWED_PREF
this
)
;
}
enable
(
)
{
this
.
_updateRuntimes
=
this
.
_updateRuntimes
.
bind
(
this
)
;
discovery
.
on
(
"
devtools
-
device
-
added
"
this
.
_updateRuntimes
)
;
discovery
.
on
(
"
devtools
-
device
-
updated
"
this
.
_updateRuntimes
)
;
discovery
.
on
(
"
devtools
-
device
-
removed
"
this
.
_updateRuntimes
)
;
this
.
_updateRuntimes
(
)
;
}
disable
(
)
{
discovery
.
off
(
"
devtools
-
device
-
added
"
this
.
_updateRuntimes
)
;
discovery
.
off
(
"
devtools
-
device
-
updated
"
this
.
_updateRuntimes
)
;
discovery
.
off
(
"
devtools
-
device
-
removed
"
this
.
_updateRuntimes
)
;
}
_emitUpdated
(
)
{
this
.
emit
(
"
runtime
-
list
-
updated
"
)
;
}
_updateRuntimes
(
)
{
this
.
_runtimes
=
[
]
;
for
(
const
device
of
discovery
.
getRemoteDevicesWithService
(
"
devtools
"
)
)
{
this
.
_runtimes
.
push
(
new
WiFiRuntime
(
device
)
)
;
}
this
.
_emitUpdated
(
)
;
}
scan
(
)
{
discovery
.
scan
(
)
;
return
promise
.
resolve
(
)
;
}
listRuntimes
:
function
(
)
{
return
this
.
_runtimes
;
}
ALLOWED_PREF
:
"
devtools
.
remote
.
wifi
.
scan
"
get
allowed
(
)
{
return
Services
.
prefs
.
getBoolPref
(
this
.
ALLOWED_PREF
)
;
}
updateRegistration
(
)
{
if
(
this
.
allowed
)
{
RuntimeScanners
.
add
(
WiFiScanner
)
;
}
else
{
RuntimeScanners
.
remove
(
WiFiScanner
)
;
}
this
.
_emitUpdated
(
)
;
}
observe
(
subject
topic
data
)
{
if
(
data
!
=
=
WiFiScanner
.
ALLOWED_PREF
)
{
return
;
}
WiFiScanner
.
updateRegistration
(
)
;
}
}
;
EventEmitter
.
decorate
(
WiFiScanner
)
;
WiFiScanner
.
init
(
)
;
exports
.
WiFiScanner
=
WiFiScanner
;
var
StaticScanner
=
{
enable
(
)
{
}
disable
(
)
{
}
scan
(
)
{
return
promise
.
resolve
(
)
;
}
listRuntimes
(
)
{
const
runtimes
=
[
gRemoteRuntime
]
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webide
.
enableLocalRuntime
"
)
)
{
runtimes
.
push
(
gLocalRuntime
)
;
}
return
runtimes
;
}
}
;
EventEmitter
.
decorate
(
StaticScanner
)
;
RuntimeScanners
.
add
(
StaticScanner
)
;
var
RuntimeTypes
=
exports
.
RuntimeTypes
=
{
USB
:
"
USB
"
WIFI
:
"
WIFI
"
REMOTE
:
"
REMOTE
"
LOCAL
:
"
LOCAL
"
OTHER
:
"
OTHER
"
}
;
function
WiFiRuntime
(
deviceName
)
{
this
.
deviceName
=
deviceName
;
}
WiFiRuntime
.
prototype
=
{
type
:
RuntimeTypes
.
WIFI
prolongedConnection
:
true
connect
:
function
(
connection
)
{
const
service
=
discovery
.
getRemoteService
(
"
devtools
"
this
.
deviceName
)
;
if
(
!
service
)
{
return
promise
.
reject
(
new
Error
(
"
Can
'
t
find
device
:
"
+
this
.
name
)
)
;
}
connection
.
advertisement
=
service
;
connection
.
authenticator
.
sendOOB
=
this
.
sendOOB
;
connection
.
timeoutDelay
=
0
;
connection
.
connect
(
)
;
return
promise
.
resolve
(
)
;
}
get
id
(
)
{
return
this
.
deviceName
;
}
get
name
(
)
{
return
this
.
deviceName
;
}
sendOOB
(
session
)
{
const
WINDOW_ID
=
"
devtools
:
wifi
-
auth
"
;
const
{
authResult
}
=
session
;
if
(
authResult
!
=
AuthenticationResult
.
PENDING
)
{
throw
new
Error
(
"
Expected
PENDING
result
got
"
+
authResult
)
;
}
let
promptWindow
;
const
windowListener
=
{
onOpenWindow
(
xulWindow
)
{
const
win
=
xulWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
;
win
.
addEventListener
(
"
load
"
function
(
)
{
if
(
win
.
document
.
documentElement
.
getAttribute
(
"
id
"
)
!
=
WINDOW_ID
)
{
return
;
}
promptWindow
=
win
;
Services
.
wm
.
removeListener
(
windowListener
)
;
}
{
once
:
true
}
)
;
}
onCloseWindow
(
)
{
}
}
;
Services
.
wm
.
addListener
(
windowListener
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
const
MIN_HEIGHT
=
600
;
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webide
"
)
;
const
width
=
win
.
outerWidth
*
0
.
8
;
const
height
=
Math
.
max
(
win
.
outerHeight
*
0
.
5
MIN_HEIGHT
)
;
win
.
openDialog
(
"
chrome
:
/
/
webide
/
content
/
wifi
-
auth
.
xhtml
"
WINDOW_ID
"
modal
=
yes
width
=
"
+
width
+
"
height
=
"
+
height
session
)
;
}
)
;
return
{
close
(
)
{
if
(
!
promptWindow
)
{
return
;
}
promptWindow
.
close
(
)
;
promptWindow
=
null
;
}
}
;
}
}
;
exports
.
_WiFiRuntime
=
WiFiRuntime
;
var
gLocalRuntime
=
{
type
:
RuntimeTypes
.
LOCAL
connect
:
function
(
connection
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
connection
.
host
=
null
;
connection
.
port
=
null
;
connection
.
connect
(
)
;
return
promise
.
resolve
(
)
;
}
get
id
(
)
{
return
"
local
"
;
}
get
name
(
)
{
return
Strings
.
GetStringFromName
(
"
local_runtime
"
)
;
}
}
;
exports
.
_gLocalRuntime
=
gLocalRuntime
;
var
gRemoteRuntime
=
{
type
:
RuntimeTypes
.
REMOTE
connect
:
function
(
connection
)
{
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webide
"
)
;
if
(
!
win
)
{
return
promise
.
reject
(
new
Error
(
"
No
WebIDE
window
found
"
)
)
;
}
const
ret
=
{
value
:
connection
.
host
+
"
:
"
+
connection
.
port
}
;
const
title
=
Strings
.
GetStringFromName
(
"
remote_runtime_promptTitle
"
)
;
const
message
=
Strings
.
GetStringFromName
(
"
remote_runtime_promptMessage
"
)
;
const
ok
=
Services
.
prompt
.
prompt
(
win
title
message
ret
null
{
}
)
;
const
[
host
port
]
=
ret
.
value
.
split
(
"
:
"
)
;
if
(
!
ok
)
{
return
promise
.
reject
(
{
canceled
:
true
}
)
;
}
if
(
!
host
|
|
!
port
)
{
return
promise
.
reject
(
new
Error
(
"
Invalid
host
or
port
"
)
)
;
}
connection
.
host
=
host
;
connection
.
port
=
port
;
connection
.
connect
(
)
;
return
promise
.
resolve
(
)
;
}
get
name
(
)
{
return
Strings
.
GetStringFromName
(
"
remote_runtime
"
)
;
}
}
;
exports
.
_gRemoteRuntime
=
gRemoteRuntime
;
