const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
FileUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
old
-
event
-
emitter
"
)
;
const
{
OS
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
AppProjects
}
=
require
(
"
devtools
/
client
/
webide
/
modules
/
app
-
projects
"
)
;
const
TabStore
=
require
(
"
devtools
/
client
/
webide
/
modules
/
tab
-
store
"
)
;
const
{
AppValidator
}
=
require
(
"
devtools
/
client
/
webide
/
modules
/
app
-
validator
"
)
;
const
{
ConnectionManager
Connection
}
=
require
(
"
devtools
/
shared
/
client
/
connection
-
manager
"
)
;
const
{
getDeviceFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
device
"
)
;
const
{
getPreferenceFront
}
=
require
(
"
devtools
/
shared
/
fronts
/
preference
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
RuntimeScanners
RuntimeTypes
}
=
require
(
"
devtools
/
client
/
webide
/
modules
/
runtimes
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
Strings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
webide
.
properties
"
)
;
var
AppManager
=
exports
.
AppManager
=
{
DEFAULT_PROJECT_ICON
:
"
chrome
:
/
/
webide
/
skin
/
default
-
app
-
icon
.
png
"
DEFAULT_PROJECT_NAME
:
"
-
-
"
_initialized
:
false
init
:
function
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
true
;
let
port
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
debugger
.
remote
-
port
"
)
;
this
.
connection
=
ConnectionManager
.
createConnection
(
"
localhost
"
port
)
;
this
.
onConnectionChanged
=
this
.
onConnectionChanged
.
bind
(
this
)
;
this
.
connection
.
on
(
Connection
.
Events
.
STATUS_CHANGED
this
.
onConnectionChanged
)
;
this
.
tabStore
=
new
TabStore
(
this
.
connection
)
;
this
.
onTabList
=
this
.
onTabList
.
bind
(
this
)
;
this
.
onTabNavigate
=
this
.
onTabNavigate
.
bind
(
this
)
;
this
.
onTabClosed
=
this
.
onTabClosed
.
bind
(
this
)
;
this
.
tabStore
.
on
(
"
tab
-
list
"
this
.
onTabList
)
;
this
.
tabStore
.
on
(
"
navigate
"
this
.
onTabNavigate
)
;
this
.
tabStore
.
on
(
"
closed
"
this
.
onTabClosed
)
;
this
.
_clearRuntimeList
(
)
;
this
.
_rebuildRuntimeList
=
this
.
_rebuildRuntimeList
.
bind
(
this
)
;
RuntimeScanners
.
on
(
"
runtime
-
list
-
updated
"
this
.
_rebuildRuntimeList
)
;
RuntimeScanners
.
enable
(
)
;
this
.
_rebuildRuntimeList
(
)
;
this
.
_telemetry
=
new
Telemetry
(
)
;
}
destroy
:
function
(
)
{
if
(
!
this
.
_initialized
)
{
return
;
}
this
.
_initialized
=
false
;
this
.
selectedProject
=
null
;
this
.
selectedRuntime
=
null
;
RuntimeScanners
.
off
(
"
runtime
-
list
-
updated
"
this
.
_rebuildRuntimeList
)
;
RuntimeScanners
.
disable
(
)
;
this
.
runtimeList
=
null
;
this
.
tabStore
.
off
(
"
tab
-
list
"
this
.
onTabList
)
;
this
.
tabStore
.
off
(
"
navigate
"
this
.
onTabNavigate
)
;
this
.
tabStore
.
off
(
"
closed
"
this
.
onTabClosed
)
;
this
.
tabStore
.
destroy
(
)
;
this
.
tabStore
=
null
;
this
.
connection
.
off
(
Connection
.
Events
.
STATUS_CHANGED
this
.
onConnectionChanged
)
;
this
.
_listTabsResponse
=
null
;
this
.
connection
.
disconnect
(
)
;
this
.
connection
=
null
;
}
update
:
function
(
what
details
)
{
this
.
emit
(
"
app
-
manager
-
update
"
what
details
)
;
}
reportError
:
function
(
l10nProperty
.
.
.
l10nArgs
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webide
"
)
;
if
(
win
)
{
win
.
UI
.
reportError
(
l10nProperty
.
.
.
l10nArgs
)
;
}
else
{
let
text
;
if
(
l10nArgs
.
length
>
0
)
{
text
=
Strings
.
formatStringFromName
(
l10nProperty
l10nArgs
l10nArgs
.
length
)
;
}
else
{
text
=
Strings
.
GetStringFromName
(
l10nProperty
)
;
}
console
.
error
(
text
)
;
}
}
onConnectionChanged
:
function
(
)
{
console
.
log
(
"
Connection
status
changed
:
"
+
this
.
connection
.
status
)
;
if
(
this
.
connection
.
status
=
=
Connection
.
Status
.
DISCONNECTED
)
{
this
.
selectedRuntime
=
null
;
}
if
(
!
this
.
connected
)
{
this
.
_listTabsResponse
=
null
;
}
else
{
this
.
connection
.
client
.
listTabs
(
)
.
then
(
(
response
)
=
>
{
this
.
_listTabsResponse
=
response
;
this
.
_recordRuntimeInfo
(
)
;
this
.
update
(
"
runtime
-
global
-
actors
"
)
;
}
)
;
}
this
.
update
(
"
connection
"
)
;
}
get
connected
(
)
{
return
this
.
connection
&
&
this
.
connection
.
status
=
=
Connection
.
Status
.
CONNECTED
;
}
get
apps
(
)
{
if
(
this
.
_appsFront
)
{
return
this
.
_appsFront
.
apps
;
}
else
{
return
new
Map
(
)
;
}
}
isProjectRunning
:
function
(
)
{
if
(
this
.
selectedProject
.
type
=
=
"
mainProcess
"
|
|
this
.
selectedProject
.
type
=
=
"
tab
"
)
{
return
true
;
}
let
app
=
this
.
_getProjectFront
(
this
.
selectedProject
)
;
return
app
&
&
app
.
running
;
}
checkIfProjectIsRunning
:
function
(
)
{
if
(
this
.
selectedProject
)
{
if
(
this
.
isProjectRunning
(
)
)
{
this
.
update
(
"
project
-
started
"
)
;
}
else
{
this
.
update
(
"
project
-
stopped
"
)
;
}
}
}
listTabs
:
function
(
)
{
return
this
.
tabStore
.
listTabs
(
)
;
}
onTabList
:
function
(
)
{
this
.
update
(
"
runtime
-
targets
"
{
type
:
"
tabs
"
}
)
;
}
onTabNavigate
:
function
(
)
{
this
.
update
(
"
runtime
-
targets
"
{
type
:
"
tabs
"
}
)
;
if
(
this
.
selectedProject
.
type
!
=
=
"
tab
"
)
{
return
;
}
let
tab
=
this
.
selectedProject
.
app
=
this
.
tabStore
.
selectedTab
;
let
uri
=
NetUtil
.
newURI
(
tab
.
url
)
;
tab
.
favicon
=
uri
.
prePath
+
"
/
favicon
.
ico
"
;
tab
.
name
=
tab
.
title
|
|
Strings
.
GetStringFromName
(
"
project_tab_loading
"
)
;
if
(
uri
.
scheme
.
startsWith
(
"
http
"
)
)
{
tab
.
name
=
uri
.
host
+
"
:
"
+
tab
.
name
;
}
this
.
selectedProject
.
location
=
tab
.
url
;
this
.
selectedProject
.
name
=
tab
.
name
;
this
.
selectedProject
.
icon
=
tab
.
favicon
;
this
.
update
(
"
project
-
validated
"
)
;
}
onTabClosed
:
function
(
)
{
if
(
this
.
selectedProject
.
type
!
=
=
"
tab
"
)
{
return
;
}
this
.
selectedProject
=
null
;
}
reloadTab
:
function
(
)
{
if
(
this
.
selectedProject
&
&
this
.
selectedProject
.
type
!
=
"
tab
"
)
{
return
Promise
.
reject
(
"
tried
to
reload
non
-
tab
project
"
)
;
}
return
this
.
getTarget
(
)
.
then
(
target
=
>
{
target
.
activeTab
.
reload
(
)
;
}
console
.
error
.
bind
(
console
)
)
;
}
getTarget
:
function
(
)
{
if
(
this
.
selectedProject
.
type
=
=
"
mainProcess
"
)
{
if
(
this
.
connection
.
client
.
mainRoot
.
traits
.
allowChromeProcess
)
{
return
this
.
connection
.
client
.
getProcess
(
)
.
then
(
aResponse
=
>
{
return
TargetFactory
.
forRemoteTab
(
{
form
:
aResponse
.
form
client
:
this
.
connection
.
client
chrome
:
true
}
)
;
}
)
;
}
else
{
return
TargetFactory
.
forRemoteTab
(
{
form
:
this
.
_listTabsResponse
client
:
this
.
connection
.
client
chrome
:
true
isTabActor
:
false
}
)
;
}
}
if
(
this
.
selectedProject
.
type
=
=
"
tab
"
)
{
return
this
.
tabStore
.
getTargetForTab
(
)
;
}
let
app
=
this
.
_getProjectFront
(
this
.
selectedProject
)
;
if
(
!
app
)
{
return
Promise
.
reject
(
"
Can
'
t
find
app
front
for
selected
project
"
)
;
}
return
Task
.
spawn
(
function
*
(
)
{
for
(
let
i
=
0
;
i
<
10
;
i
+
+
)
{
try
{
return
yield
app
.
getTarget
(
)
;
}
catch
(
e
)
{
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
500
)
;
}
)
;
}
AppManager
.
reportError
(
"
error_cantConnectToApp
"
app
.
manifest
.
manifestURL
)
;
throw
new
Error
(
"
can
'
t
connect
to
app
"
)
;
}
)
;
}
getProjectManifestURL
:
function
(
project
)
{
let
manifest
=
null
;
if
(
project
.
type
=
=
"
runtimeApp
"
)
{
manifest
=
project
.
app
.
manifestURL
;
}
if
(
project
.
type
=
=
"
hosted
"
)
{
manifest
=
project
.
location
;
}
if
(
project
.
type
=
=
"
packaged
"
&
&
project
.
packagedAppOrigin
)
{
manifest
=
"
app
:
/
/
"
+
project
.
packagedAppOrigin
+
"
/
manifest
.
webapp
"
;
}
return
manifest
;
}
_getProjectFront
:
function
(
project
)
{
let
manifest
=
this
.
getProjectManifestURL
(
project
)
;
if
(
manifest
&
&
this
.
_appsFront
)
{
return
this
.
_appsFront
.
apps
.
get
(
manifest
)
;
}
return
null
;
}
_selectedProject
:
null
set
selectedProject
(
project
)
{
let
prev
=
this
.
_selectedProject
;
if
(
!
prev
&
&
!
project
)
{
return
;
}
else
if
(
prev
&
&
project
&
&
prev
.
type
=
=
=
project
.
type
)
{
let
type
=
project
.
type
;
if
(
type
=
=
=
"
runtimeApp
"
)
{
if
(
prev
.
app
.
manifestURL
=
=
=
project
.
app
.
manifestURL
)
{
return
;
}
}
else
if
(
type
=
=
=
"
tab
"
)
{
if
(
prev
.
app
.
actor
=
=
=
project
.
app
.
actor
)
{
return
;
}
}
else
if
(
type
=
=
=
"
packaged
"
|
|
type
=
=
=
"
hosted
"
)
{
if
(
prev
.
location
=
=
=
project
.
location
)
{
return
;
}
}
else
if
(
type
=
=
=
"
mainProcess
"
)
{
return
;
}
else
{
throw
new
Error
(
"
Unsupported
project
type
:
"
+
type
)
;
}
}
let
cancelled
=
false
;
this
.
update
(
"
before
-
project
"
{
cancel
:
(
)
=
>
{
cancelled
=
true
;
}
}
)
;
if
(
cancelled
)
{
return
;
}
this
.
_selectedProject
=
project
;
this
.
tabStore
.
selectedTab
=
null
;
if
(
project
)
{
if
(
project
.
type
=
=
"
packaged
"
|
|
project
.
type
=
=
"
hosted
"
)
{
this
.
validateAndUpdateProject
(
project
)
;
}
if
(
project
.
type
=
=
"
tab
"
)
{
this
.
tabStore
.
selectedTab
=
project
.
app
;
}
}
this
.
update
(
"
project
"
)
;
this
.
checkIfProjectIsRunning
(
)
;
}
get
selectedProject
(
)
{
return
this
.
_selectedProject
;
}
removeSelectedProject
:
Task
.
async
(
function
*
(
)
{
let
location
=
this
.
selectedProject
.
location
;
AppManager
.
selectedProject
=
null
;
if
(
AppManager
.
selectedProject
!
=
null
)
{
return
;
}
yield
AppProjects
.
remove
(
location
)
;
AppManager
.
update
(
"
project
-
removed
"
)
;
}
)
_selectedRuntime
:
null
set
selectedRuntime
(
value
)
{
this
.
_selectedRuntime
=
value
;
if
(
!
value
&
&
this
.
selectedProject
&
&
(
this
.
selectedProject
.
type
=
=
"
mainProcess
"
|
|
this
.
selectedProject
.
type
=
=
"
runtimeApp
"
|
|
this
.
selectedProject
.
type
=
=
"
tab
"
)
)
{
this
.
selectedProject
=
null
;
}
this
.
update
(
"
runtime
"
)
;
}
get
selectedRuntime
(
)
{
return
this
.
_selectedRuntime
;
}
connectToRuntime
:
function
(
runtime
)
{
if
(
this
.
connected
&
&
this
.
selectedRuntime
=
=
=
runtime
)
{
return
Promise
.
resolve
(
)
;
}
let
deferred
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
disconnectRuntime
(
)
.
then
(
(
)
=
>
{
this
.
selectedRuntime
=
runtime
;
let
onConnectedOrDisconnected
=
(
)
=
>
{
this
.
connection
.
off
(
Connection
.
Events
.
CONNECTED
onConnectedOrDisconnected
)
;
this
.
connection
.
off
(
Connection
.
Events
.
DISCONNECTED
onConnectedOrDisconnected
)
;
if
(
this
.
connected
)
{
resolve
(
)
;
}
else
{
reject
(
)
;
}
}
;
this
.
connection
.
on
(
Connection
.
Events
.
CONNECTED
onConnectedOrDisconnected
)
;
this
.
connection
.
on
(
Connection
.
Events
.
DISCONNECTED
onConnectedOrDisconnected
)
;
try
{
this
.
connection
.
resetOptions
(
)
;
this
.
selectedRuntime
.
connect
(
this
.
connection
)
.
catch
(
e
=
>
reject
(
e
)
)
;
}
catch
(
e
)
{
reject
(
e
)
;
}
}
reject
)
;
}
)
;
let
logResult
=
result
=
>
{
this
.
_telemetry
.
log
(
"
DEVTOOLS_WEBIDE_CONNECTION_RESULT
"
result
)
;
if
(
runtime
.
type
)
{
this
.
_telemetry
.
log
(
"
DEVTOOLS_WEBIDE_
"
+
runtime
.
type
+
"
_CONNECTION_RESULT
"
result
)
;
}
}
;
deferred
.
then
(
(
)
=
>
logResult
(
true
)
(
)
=
>
logResult
(
false
)
)
;
deferred
.
then
(
(
)
=
>
{
const
timerId
=
"
DEVTOOLS_WEBIDE_CONNECTION_TIME_SECONDS
"
;
this
.
_telemetry
.
startTimer
(
timerId
)
;
this
.
connection
.
once
(
Connection
.
Events
.
STATUS_CHANGED
(
)
=
>
{
this
.
_telemetry
.
stopTimer
(
timerId
)
;
}
)
;
}
)
.
catch
(
(
)
=
>
{
}
)
;
return
deferred
;
}
_recordRuntimeInfo
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
connected
)
{
return
;
}
let
runtime
=
this
.
selectedRuntime
;
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_WEBIDE_CONNECTED_RUNTIME_TYPE
"
runtime
.
type
|
|
"
UNKNOWN
"
true
)
;
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_WEBIDE_CONNECTED_RUNTIME_ID
"
runtime
.
id
|
|
"
unknown
"
true
)
;
if
(
!
this
.
deviceFront
)
{
this
.
update
(
"
runtime
-
telemetry
"
)
;
return
;
}
let
d
=
yield
this
.
deviceFront
.
getDescription
(
)
;
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_WEBIDE_CONNECTED_RUNTIME_PROCESSOR
"
d
.
processor
true
)
;
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_WEBIDE_CONNECTED_RUNTIME_OS
"
d
.
os
true
)
;
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_WEBIDE_CONNECTED_RUNTIME_PLATFORM_VERSION
"
d
.
platformversion
true
)
;
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_WEBIDE_CONNECTED_RUNTIME_APP_TYPE
"
d
.
apptype
true
)
;
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_WEBIDE_CONNECTED_RUNTIME_VERSION
"
d
.
version
true
)
;
this
.
update
(
"
runtime
-
telemetry
"
)
;
}
)
isMainProcessDebuggable
:
function
(
)
{
return
this
.
connection
.
client
&
&
this
.
connection
.
client
.
mainRoot
&
&
this
.
connection
.
client
.
mainRoot
.
traits
.
allowChromeProcess
|
|
(
this
.
_listTabsResponse
&
&
this
.
_listTabsResponse
.
consoleActor
)
;
}
get
listTabsForm
(
)
{
return
this
.
_listTabsResponse
;
}
get
deviceFront
(
)
{
if
(
!
this
.
_listTabsResponse
)
{
return
null
;
}
return
getDeviceFront
(
this
.
connection
.
client
this
.
_listTabsResponse
)
;
}
get
preferenceFront
(
)
{
if
(
!
this
.
_listTabsResponse
)
{
return
null
;
}
return
getPreferenceFront
(
this
.
connection
.
client
this
.
_listTabsResponse
)
;
}
disconnectRuntime
:
function
(
)
{
if
(
!
this
.
connected
)
{
return
Promise
.
resolve
(
)
;
}
return
new
Promise
(
resolve
=
>
{
this
.
connection
.
once
(
Connection
.
Events
.
DISCONNECTED
(
)
=
>
resolve
(
)
)
;
this
.
connection
.
disconnect
(
)
;
}
)
;
}
launchRuntimeApp
:
function
(
)
{
if
(
this
.
selectedProject
&
&
this
.
selectedProject
.
type
!
=
"
runtimeApp
"
)
{
return
Promise
.
reject
(
"
attempting
to
launch
a
non
-
runtime
app
"
)
;
}
let
app
=
this
.
_getProjectFront
(
this
.
selectedProject
)
;
return
app
.
launch
(
)
;
}
launchOrReloadRuntimeApp
:
function
(
)
{
if
(
this
.
selectedProject
&
&
this
.
selectedProject
.
type
!
=
"
runtimeApp
"
)
{
return
Promise
.
reject
(
"
attempting
to
launch
/
reload
a
non
-
runtime
app
"
)
;
}
let
app
=
this
.
_getProjectFront
(
this
.
selectedProject
)
;
if
(
!
app
.
running
)
{
return
app
.
launch
(
)
;
}
else
{
return
app
.
reload
(
)
;
}
}
runtimeCanHandleApps
:
function
(
)
{
return
!
!
this
.
_appsFront
;
}
installAndRunProject
:
function
(
)
{
let
project
=
this
.
selectedProject
;
if
(
!
project
|
|
(
project
.
type
!
=
"
packaged
"
&
&
project
.
type
!
=
"
hosted
"
)
)
{
console
.
error
(
"
Can
'
t
install
project
.
Unknown
type
of
project
.
"
)
;
return
Promise
.
reject
(
"
Can
'
t
install
"
)
;
}
if
(
!
this
.
_listTabsResponse
)
{
this
.
reportError
(
"
error_cantInstallNotFullyConnected
"
)
;
return
Promise
.
reject
(
"
Can
'
t
install
"
)
;
}
if
(
!
this
.
_appsFront
)
{
console
.
error
(
"
Runtime
doesn
'
t
have
a
webappsActor
"
)
;
return
Promise
.
reject
(
"
Can
'
t
install
"
)
;
}
return
Task
.
spawn
(
function
*
(
)
{
let
self
=
AppManager
;
yield
self
.
validateAndUpdateProject
(
project
)
;
if
(
project
.
errorsCount
>
0
)
{
self
.
reportError
(
"
error_cantInstallValidationErrors
"
)
;
return
;
}
let
installPromise
;
if
(
project
.
type
!
=
"
packaged
"
&
&
project
.
type
!
=
"
hosted
"
)
{
return
Promise
.
reject
(
"
Don
'
t
know
how
to
install
project
"
)
;
}
let
response
;
if
(
project
.
type
=
=
"
packaged
"
)
{
let
packageDir
=
project
.
location
;
console
.
log
(
"
Installing
app
from
"
+
packageDir
)
;
response
=
yield
self
.
_appsFront
.
installPackaged
(
packageDir
project
.
packagedAppOrigin
)
;
project
.
packagedAppOrigin
=
response
.
appId
;
AppProjects
.
update
(
project
)
;
}
if
(
project
.
type
=
=
"
hosted
"
)
{
let
manifestURLObject
=
Services
.
io
.
newURI
(
project
.
location
)
;
let
origin
=
Services
.
io
.
newURI
(
manifestURLObject
.
prePath
)
;
let
appId
=
origin
.
host
;
let
metadata
=
{
origin
:
origin
.
spec
manifestURL
:
project
.
location
}
;
response
=
yield
self
.
_appsFront
.
installHosted
(
appId
metadata
project
.
manifest
)
;
}
if
(
project
.
manifest
.
manifest_version
|
|
project
.
manifest
.
role
=
=
=
"
addon
"
)
{
return
;
}
let
{
app
}
=
response
;
if
(
!
app
.
running
)
{
let
deferred
=
new
Promise
(
resolve
=
>
{
self
.
on
(
"
app
-
manager
-
update
"
function
onUpdate
(
event
what
)
{
if
(
what
=
=
"
project
-
started
"
)
{
self
.
off
(
"
app
-
manager
-
update
"
onUpdate
)
;
resolve
(
)
;
}
}
)
;
}
)
;
yield
app
.
launch
(
)
;
yield
deferred
;
}
else
{
yield
app
.
reload
(
)
;
}
}
)
;
}
stopRunningApp
:
function
(
)
{
let
app
=
this
.
_getProjectFront
(
this
.
selectedProject
)
;
return
app
.
close
(
)
;
}
validateAndUpdateProject
:
function
(
project
)
{
if
(
!
project
)
{
return
Promise
.
reject
(
)
;
}
return
Task
.
spawn
(
function
*
(
)
{
let
packageDir
=
project
.
location
;
let
validation
=
new
AppValidator
(
{
type
:
project
.
type
location
:
packageDir
}
)
;
yield
validation
.
validate
(
)
;
if
(
validation
.
manifest
)
{
let
manifest
=
validation
.
manifest
;
let
iconPath
;
if
(
manifest
.
icons
)
{
let
size
=
Object
.
keys
(
manifest
.
icons
)
.
sort
(
(
a
b
)
=
>
b
-
a
)
[
0
]
;
if
(
size
)
{
iconPath
=
manifest
.
icons
[
size
]
;
}
}
if
(
!
iconPath
)
{
project
.
icon
=
AppManager
.
DEFAULT_PROJECT_ICON
;
}
else
{
if
(
project
.
type
=
=
"
hosted
"
)
{
let
manifestURL
=
Services
.
io
.
newURI
(
project
.
location
)
;
let
origin
=
Services
.
io
.
newURI
(
manifestURL
.
prePath
)
;
project
.
icon
=
Services
.
io
.
newURI
(
iconPath
null
origin
)
.
spec
;
}
else
if
(
project
.
type
=
=
"
packaged
"
)
{
let
projectFolder
=
FileUtils
.
File
(
packageDir
)
;
let
folderURI
=
Services
.
io
.
newFileURI
(
projectFolder
)
.
spec
;
project
.
icon
=
folderURI
+
iconPath
.
replace
(
/
^
\
/
|
\
\
/
"
"
)
;
}
}
project
.
manifest
=
validation
.
manifest
;
if
(
"
name
"
in
project
.
manifest
)
{
project
.
name
=
project
.
manifest
.
name
;
}
else
{
project
.
name
=
AppManager
.
DEFAULT_PROJECT_NAME
;
}
}
else
{
project
.
manifest
=
null
;
project
.
icon
=
AppManager
.
DEFAULT_PROJECT_ICON
;
project
.
name
=
AppManager
.
DEFAULT_PROJECT_NAME
;
}
project
.
validationStatus
=
"
valid
"
;
if
(
validation
.
warnings
.
length
>
0
)
{
project
.
warningsCount
=
validation
.
warnings
.
length
;
project
.
warnings
=
validation
.
warnings
;
project
.
validationStatus
=
"
warning
"
;
}
else
{
project
.
warnings
=
"
"
;
project
.
warningsCount
=
0
;
}
if
(
validation
.
errors
.
length
>
0
)
{
project
.
errorsCount
=
validation
.
errors
.
length
;
project
.
errors
=
validation
.
errors
;
project
.
validationStatus
=
"
error
"
;
}
else
{
project
.
errors
=
"
"
;
project
.
errorsCount
=
0
;
}
if
(
project
.
warningsCount
&
&
project
.
errorsCount
)
{
project
.
validationStatus
=
"
error
warning
"
;
}
if
(
project
.
type
=
=
=
"
hosted
"
&
&
project
.
location
!
=
=
validation
.
manifestURL
)
{
yield
AppProjects
.
updateLocation
(
project
validation
.
manifestURL
)
;
}
else
if
(
AppProjects
.
get
(
project
.
location
)
)
{
yield
AppProjects
.
update
(
project
)
;
}
if
(
AppManager
.
selectedProject
=
=
=
project
)
{
AppManager
.
update
(
"
project
-
validated
"
)
;
}
}
)
;
}
_clearRuntimeList
:
function
(
)
{
this
.
runtimeList
=
{
usb
:
[
]
wifi
:
[
]
other
:
[
]
}
;
}
_rebuildRuntimeList
:
function
(
)
{
let
runtimes
=
RuntimeScanners
.
listRuntimes
(
)
;
this
.
_clearRuntimeList
(
)
;
for
(
let
runtime
of
runtimes
)
{
switch
(
runtime
.
type
)
{
case
RuntimeTypes
.
USB
:
this
.
runtimeList
.
usb
.
push
(
runtime
)
;
break
;
case
RuntimeTypes
.
WIFI
:
this
.
runtimeList
.
wifi
.
push
(
runtime
)
;
break
;
default
:
this
.
runtimeList
.
other
.
push
(
runtime
)
;
}
}
this
.
update
(
"
runtime
-
details
"
)
;
this
.
update
(
"
runtime
-
list
"
)
;
}
writeManifest
:
function
(
project
)
{
if
(
project
.
type
!
=
"
packaged
"
)
{
return
Promise
.
reject
(
"
Not
a
packaged
app
"
)
;
}
if
(
!
project
.
manifest
)
{
project
.
manifest
=
{
}
;
}
let
folder
=
project
.
location
;
let
manifestPath
=
OS
.
Path
.
join
(
folder
"
manifest
.
webapp
"
)
;
let
text
=
JSON
.
stringify
(
project
.
manifest
null
2
)
;
let
encoder
=
new
TextEncoder
(
)
;
let
array
=
encoder
.
encode
(
text
)
;
return
OS
.
File
.
writeAtomic
(
manifestPath
array
{
tmpPath
:
manifestPath
+
"
.
tmp
"
}
)
;
}
}
;
EventEmitter
.
decorate
(
AppManager
)
;
