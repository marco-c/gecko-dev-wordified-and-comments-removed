"
use
strict
"
;
class
AudioNodeModel
extends
EventEmitter
{
constructor
(
actor
)
{
super
(
)
;
this
.
collection
=
null
;
this
.
actor
=
actor
;
this
.
id
=
actor
.
actorID
;
this
.
type
=
actor
.
type
;
this
.
bypassable
=
actor
.
bypassable
;
this
.
_bypassed
=
false
;
this
.
connections
=
[
]
;
}
connect
(
destination
param
)
{
let
edge
=
findWhere
(
this
.
connections
{
destination
:
destination
.
id
param
:
param
}
)
;
if
(
!
edge
)
{
this
.
connections
.
push
(
{
source
:
this
.
id
destination
:
destination
.
id
param
:
param
}
)
;
EventEmitter
.
emit
(
this
"
connect
"
this
destination
param
)
;
}
}
disconnect
(
)
{
this
.
connections
.
length
=
0
;
EventEmitter
.
emit
(
this
"
disconnect
"
this
)
;
}
isBypassed
(
)
{
return
this
.
_bypassed
;
}
bypass
(
enable
)
{
this
.
_bypassed
=
enable
;
return
this
.
actor
.
bypass
(
enable
)
.
then
(
(
)
=
>
EventEmitter
.
emit
(
this
"
bypass
"
this
enable
)
)
;
}
getParams
(
)
{
return
this
.
actor
.
getParams
(
)
;
}
getAutomationData
(
paramName
)
{
return
this
.
actor
.
getAutomationData
(
paramName
)
;
}
addToGraph
(
graph
)
{
graph
.
addNode
(
this
.
id
{
type
:
this
.
type
label
:
this
.
type
.
replace
(
/
Node
/
"
"
)
id
:
this
.
id
bypassed
:
this
.
_bypassed
}
)
;
}
addEdgesToGraph
(
graph
)
{
for
(
let
edge
of
this
.
connections
)
{
let
options
=
{
source
:
this
.
id
target
:
edge
.
destination
}
;
if
(
edge
.
param
)
{
options
.
label
=
options
.
param
=
edge
.
param
;
}
graph
.
addEdge
(
null
this
.
id
edge
.
destination
options
)
;
}
}
toString
(
)
{
return
"
[
object
AudioNodeModel
]
"
;
}
}
class
AudioNodesCollection
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
this
.
model
=
AudioNodeModel
;
this
.
models
=
new
Set
(
)
;
this
.
_onModelEvent
=
this
.
_onModelEvent
.
bind
(
this
)
;
}
forEach
(
fn
)
{
this
.
models
.
forEach
(
fn
)
;
}
add
(
obj
)
{
let
node
=
new
this
.
model
(
obj
)
;
node
.
collection
=
this
;
this
.
models
.
add
(
node
)
;
node
.
on
(
"
*
"
this
.
_onModelEvent
)
;
EventEmitter
.
emit
(
this
"
add
"
node
)
;
return
node
;
}
remove
(
node
)
{
this
.
models
.
delete
(
node
)
;
EventEmitter
.
emit
(
this
"
remove
"
node
)
;
}
reset
(
)
{
this
.
models
.
clear
(
)
;
}
get
(
id
)
{
return
findWhere
(
this
.
models
{
id
:
id
}
)
;
}
get
length
(
)
{
return
this
.
models
.
size
;
}
getInfo
(
)
{
let
info
=
{
nodes
:
this
.
length
edges
:
0
paramEdges
:
0
}
;
this
.
models
.
forEach
(
node
=
>
{
let
paramEdgeCount
=
node
.
connections
.
filter
(
edge
=
>
edge
.
param
)
.
length
;
info
.
edges
+
=
node
.
connections
.
length
-
paramEdgeCount
;
info
.
paramEdges
+
=
paramEdgeCount
;
}
)
;
return
info
;
}
populateGraph
(
graph
)
{
this
.
models
.
forEach
(
node
=
>
node
.
addToGraph
(
graph
)
)
;
this
.
models
.
forEach
(
node
=
>
node
.
addEdgesToGraph
(
graph
)
)
;
}
_onModelEvent
(
eventName
node
.
.
.
args
)
{
if
(
eventName
=
=
=
"
remove
"
)
{
this
.
remove
(
node
)
;
}
else
{
EventEmitter
.
emit
(
this
eventName
node
.
.
.
args
)
;
}
}
toString
(
)
{
return
"
[
object
AudioNodeCollection
]
"
;
}
}
