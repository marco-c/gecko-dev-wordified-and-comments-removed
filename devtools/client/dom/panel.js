"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
openContentLink
"
"
devtools
/
client
/
shared
/
link
"
true
)
;
function
DomPanel
(
iframeWindow
toolbox
commands
)
{
this
.
panelWin
=
iframeWindow
;
this
.
_toolbox
=
toolbox
;
this
.
_commands
=
commands
;
this
.
onContentMessage
=
this
.
onContentMessage
.
bind
(
this
)
;
this
.
onPanelVisibilityChange
=
this
.
onPanelVisibilityChange
.
bind
(
this
)
;
this
.
pendingRequests
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
DomPanel
.
prototype
=
{
async
open
(
)
{
const
onGetProperties
=
new
Promise
(
resolve
=
>
{
this
.
_resolveOpen
=
resolve
;
}
)
;
await
this
.
initialize
(
)
;
await
onGetProperties
;
return
this
;
}
async
initialize
(
)
{
this
.
panelWin
.
addEventListener
(
"
devtools
/
content
/
message
"
this
.
onContentMessage
true
)
;
this
.
_toolbox
.
on
(
"
select
"
this
.
onPanelVisibilityChange
)
;
this
.
_onTargetAvailable
=
(
)
=
>
{
}
;
this
.
_onTargetSelected
=
this
.
_onTargetSelected
.
bind
(
this
)
;
await
this
.
_commands
.
targetCommand
.
watchTargets
(
{
types
:
[
this
.
_commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
_onTargetAvailable
onSelected
:
this
.
_onTargetSelected
}
)
;
this
.
onResourceAvailable
=
this
.
onResourceAvailable
.
bind
(
this
)
;
await
this
.
_commands
.
resourceCommand
.
watchResources
(
[
this
.
_commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
onResourceAvailable
}
)
;
const
provider
=
{
getToolbox
:
this
.
getToolbox
.
bind
(
this
)
getPrototypeAndProperties
:
this
.
getPrototypeAndProperties
.
bind
(
this
)
openLink
:
this
.
openLink
.
bind
(
this
)
onPropertiesFetched
:
(
)
=
>
{
if
(
this
.
_resolveOpen
)
{
this
.
_resolveOpen
(
)
;
this
.
_resolveOpen
=
null
;
}
}
}
;
exportIntoContentScope
(
this
.
panelWin
provider
"
DomProvider
"
)
;
}
destroy
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
this
.
_commands
.
targetCommand
.
unwatchTargets
(
{
types
:
[
this
.
_commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
_onTargetAvailable
onSelected
:
this
.
_onTargetSelected
}
)
;
this
.
_commands
.
resourceCommand
.
unwatchResources
(
[
this
.
_commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
onResourceAvailable
}
)
;
this
.
_toolbox
.
off
(
"
select
"
this
.
onPanelVisibilityChange
)
;
this
.
emit
(
"
destroyed
"
)
;
}
refresh
(
)
{
if
(
!
this
.
isPanelVisible
(
)
)
{
return
;
}
if
(
!
this
.
shouldRefresh
)
{
return
;
}
this
.
shouldRefresh
=
false
;
this
.
getRootGrip
(
)
.
then
(
rootGrip
=
>
{
this
.
postContentMessage
(
"
initialize
"
rootGrip
)
;
}
)
;
}
forceRefresh
(
)
{
this
.
shouldRefresh
=
true
;
this
.
refresh
(
)
;
}
_onTargetSelected
(
{
targetFront
}
)
{
this
.
forceRefresh
(
)
;
}
onResourceAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
resourceType
=
=
=
this
.
_commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
&
&
resource
.
name
=
=
=
"
dom
-
complete
"
&
&
resource
.
targetFront
.
isTopLevel
)
{
this
.
forceRefresh
(
)
;
}
}
}
onPanelVisibilityChange
(
)
{
this
.
refresh
(
)
;
}
isPanelVisible
(
)
{
return
this
.
_toolbox
.
currentToolId
=
=
=
"
dom
"
;
}
async
getPrototypeAndProperties
(
objectFront
)
{
if
(
!
objectFront
.
actorID
)
{
console
.
error
(
"
No
actor
!
"
objectFront
)
;
throw
new
Error
(
"
Failed
to
get
object
front
.
"
)
;
}
if
(
!
this
.
currentTarget
)
{
return
null
;
}
let
request
=
this
.
pendingRequests
.
get
(
objectFront
.
actorID
)
;
if
(
!
request
)
{
request
=
objectFront
.
getPrototypeAndProperties
(
)
;
this
.
pendingRequests
.
set
(
objectFront
.
actorID
request
)
;
}
const
response
=
await
request
;
this
.
pendingRequests
.
delete
(
objectFront
.
actorID
)
;
if
(
!
this
.
pendingRequests
.
size
)
{
this
.
emit
(
"
no
-
pending
-
requests
"
)
;
}
return
response
;
}
openLink
(
url
)
{
openContentLink
(
url
)
;
}
async
getRootGrip
(
)
{
const
{
result
}
=
await
this
.
_toolbox
.
commands
.
scriptCommand
.
execute
(
"
window
"
)
;
return
result
;
}
postContentMessage
(
type
args
)
{
const
data
=
{
type
args
}
;
const
event
=
new
this
.
panelWin
.
MessageEvent
(
"
devtools
/
chrome
/
message
"
{
bubbles
:
true
cancelable
:
true
data
}
)
;
this
.
panelWin
.
dispatchEvent
(
event
)
;
}
onContentMessage
(
event
)
{
const
data
=
event
.
data
;
const
method
=
data
.
type
;
if
(
typeof
this
[
method
]
=
=
"
function
"
)
{
this
[
method
]
(
data
.
args
)
;
}
}
getToolbox
(
)
{
return
this
.
_toolbox
;
}
get
currentTarget
(
)
{
return
this
.
_toolbox
.
target
;
}
}
;
function
exportIntoContentScope
(
win
obj
defineAs
)
{
const
clone
=
Cu
.
createObjectIn
(
win
{
defineAs
}
)
;
const
props
=
Object
.
getOwnPropertyNames
(
obj
)
;
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
const
propName
=
props
[
i
]
;
const
propValue
=
obj
[
propName
]
;
if
(
typeof
propValue
=
=
"
function
"
)
{
Cu
.
exportFunction
(
propValue
clone
{
defineAs
:
propName
}
)
;
}
}
}
exports
.
DomPanel
=
DomPanel
;
