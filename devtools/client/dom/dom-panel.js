"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
defer
}
=
require
(
"
sdk
/
core
/
promise
"
)
;
const
{
ObjectClient
}
=
require
(
"
devtools
/
shared
/
client
/
main
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
function
DomPanel
(
iframeWindow
toolbox
)
{
this
.
panelWin
=
iframeWindow
;
this
.
_toolbox
=
toolbox
;
this
.
onTabNavigated
=
this
.
onTabNavigated
.
bind
(
this
)
;
this
.
onContentMessage
=
this
.
onContentMessage
.
bind
(
this
)
;
this
.
pendingRequests
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
DomPanel
.
prototype
=
{
open
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_opening
)
{
return
this
.
_opening
;
}
let
deferred
=
promise
.
defer
(
)
;
this
.
_opening
=
deferred
.
promise
;
if
(
!
this
.
target
.
isRemote
)
{
yield
this
.
target
.
makeRemote
(
)
;
}
this
.
initialize
(
)
;
this
.
once
(
"
no
-
pending
-
requests
"
(
)
=
>
{
this
.
isReady
=
true
;
this
.
emit
(
"
ready
"
)
;
deferred
.
resolve
(
this
)
;
}
)
;
return
this
.
_opening
;
}
)
initialize
:
function
(
)
{
this
.
panelWin
.
addEventListener
(
"
devtools
/
content
/
message
"
this
.
onContentMessage
true
)
;
this
.
target
.
on
(
"
navigate
"
this
.
onTabNavigated
)
;
let
provider
=
{
getPrototypeAndProperties
:
this
.
getPrototypeAndProperties
.
bind
(
this
)
}
;
exportIntoContentScope
(
this
.
panelWin
provider
"
DomProvider
"
)
;
this
.
doRefresh
(
)
;
}
destroy
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_destroying
)
{
return
this
.
_destroying
;
}
let
deferred
=
promise
.
defer
(
)
;
this
.
_destroying
=
deferred
.
promise
;
this
.
target
.
off
(
"
navigate
"
this
.
onTabNavigated
)
;
this
.
emit
(
"
destroyed
"
)
;
deferred
.
resolve
(
)
;
return
this
.
_destroying
;
}
)
doRefresh
:
function
(
)
{
this
.
refresh
(
)
.
then
(
rootGrip
=
>
{
this
.
postContentMessage
(
"
initialize
"
rootGrip
)
;
}
)
;
}
onTabNavigated
:
function
(
)
{
this
.
doRefresh
(
)
;
}
getPrototypeAndProperties
:
function
(
grip
)
{
let
deferred
=
defer
(
)
;
if
(
!
grip
.
actor
)
{
console
.
error
(
"
No
actor
!
"
grip
)
;
deferred
.
reject
(
new
Error
(
"
Failed
to
get
actor
from
grip
.
"
)
)
;
return
deferred
.
promise
;
}
if
(
!
this
.
target
)
{
return
deferred
.
promise
;
}
let
request
=
this
.
pendingRequests
.
get
(
grip
.
actor
)
;
if
(
request
)
{
return
request
;
}
let
client
=
new
ObjectClient
(
this
.
target
.
client
grip
)
;
client
.
getPrototypeAndProperties
(
response
=
>
{
this
.
pendingRequests
.
delete
(
grip
.
actor
deferred
.
promise
)
;
deferred
.
resolve
(
response
)
;
if
(
!
this
.
pendingRequests
.
size
)
{
this
.
emit
(
"
no
-
pending
-
requests
"
)
;
}
}
)
;
this
.
pendingRequests
.
set
(
grip
.
actor
deferred
.
promise
)
;
return
deferred
.
promise
;
}
refresh
:
function
(
)
{
let
deferred
=
defer
(
)
;
this
.
target
.
activeConsole
.
evaluateJSAsync
(
"
window
"
res
=
>
{
deferred
.
resolve
(
res
.
result
)
;
}
)
;
return
deferred
.
promise
;
}
postContentMessage
:
function
(
type
args
)
{
let
data
=
{
type
:
type
args
:
args
}
;
let
event
=
new
this
.
panelWin
.
MessageEvent
(
"
devtools
/
chrome
/
message
"
{
bubbles
:
true
cancelable
:
true
data
:
data
}
)
;
this
.
panelWin
.
dispatchEvent
(
event
)
;
}
onContentMessage
:
function
(
event
)
{
let
data
=
event
.
data
;
let
method
=
data
.
type
;
if
(
typeof
this
[
method
]
=
=
"
function
"
)
{
this
[
method
]
(
data
.
args
)
;
}
}
get
target
(
)
{
return
this
.
_toolbox
.
target
;
}
}
;
function
exportIntoContentScope
(
win
obj
defineAs
)
{
let
clone
=
Cu
.
createObjectIn
(
win
{
defineAs
:
defineAs
}
)
;
let
props
=
Object
.
getOwnPropertyNames
(
obj
)
;
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
let
propName
=
props
[
i
]
;
let
propValue
=
obj
[
propName
]
;
if
(
typeof
propValue
=
=
"
function
"
)
{
Cu
.
exportFunction
(
propValue
clone
{
defineAs
:
propName
}
)
;
}
}
}
exports
.
DomPanel
=
DomPanel
;
