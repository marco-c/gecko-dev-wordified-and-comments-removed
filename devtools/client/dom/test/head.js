"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
const
constants
=
require
(
"
devtools
/
client
/
dom
/
content
/
constants
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
dom
.
enabled
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
info
(
"
finish
(
)
was
called
cleaning
up
.
.
.
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dom
.
enabled
"
)
;
}
)
;
async
function
addTestTab
(
url
)
{
info
(
"
Adding
a
new
test
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
const
tab
=
await
addTab
(
url
)
;
const
panel
=
await
initDOMPanel
(
tab
)
;
const
doc
=
panel
.
panelWin
.
document
;
const
nodes
=
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeLabel
"
)
]
;
ok
(
nodes
.
length
>
0
"
The
DOM
panel
is
already
populated
"
)
;
return
{
tab
browser
:
tab
.
linkedBrowser
panel
}
;
}
async
function
initDOMPanel
(
tab
)
{
tab
=
tab
|
|
gBrowser
.
selectedTab
;
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
dom
"
}
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
return
panel
;
}
function
synthesizeMouseClickSoon
(
panel
element
)
{
return
new
Promise
(
resolve
=
>
{
executeSoon
(
(
)
=
>
{
EventUtils
.
synthesizeMouse
(
element
2
2
{
}
panel
.
panelWin
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
getRowByLabel
(
panel
text
)
{
const
doc
=
panel
.
panelWin
.
document
;
const
labels
=
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeLabel
"
)
]
;
const
label
=
labels
.
find
(
node
=
>
node
.
textContent
=
=
text
)
;
return
label
?
label
.
closest
(
"
.
treeRow
"
)
:
null
;
}
function
getRowByIndex
(
panel
id
)
{
const
doc
=
panel
.
panelWin
.
document
;
const
labels
=
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeLabel
"
)
]
;
const
label
=
labels
.
find
(
(
node
i
)
=
>
i
=
=
id
)
;
return
label
?
label
.
closest
(
"
.
treeRow
"
)
:
null
;
}
function
getAllRowsForLabel
(
panel
text
)
{
let
rootObjectLevel
;
let
node
;
const
result
=
[
]
;
const
doc
=
panel
.
panelWin
.
document
;
const
nodes
=
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeLabel
"
)
]
;
while
(
true
)
{
node
=
nodes
.
shift
(
)
;
if
(
!
node
|
|
node
.
textContent
=
=
=
text
)
{
rootObjectLevel
=
node
.
getAttribute
(
"
data
-
level
"
)
;
break
;
}
}
if
(
!
node
)
{
return
result
;
}
for
(
node
of
nodes
)
{
const
level
=
node
.
getAttribute
(
"
data
-
level
"
)
;
if
(
level
>
rootObjectLevel
)
{
result
.
push
(
{
name
:
normalizeTreeValue
(
node
.
textContent
)
value
:
normalizeTreeValue
(
node
.
parentNode
.
nextElementSibling
.
textContent
)
}
)
;
}
else
{
break
;
}
}
return
result
;
}
function
normalizeTreeValue
(
value
)
{
if
(
value
=
=
=
"
"
)
{
return
"
"
;
}
if
(
value
.
startsWith
(
"
)
&
&
value
.
endsWith
(
"
)
)
{
return
value
.
substr
(
1
value
.
length
-
2
)
;
}
if
(
isFinite
(
value
)
&
&
parseInt
(
value
10
)
=
=
value
)
{
return
parseInt
(
value
10
)
;
}
return
value
;
}
function
expandRow
(
panel
labelText
)
{
const
row
=
getRowByLabel
(
panel
labelText
)
;
return
synthesizeMouseClickSoon
(
panel
row
)
.
then
(
(
)
=
>
{
const
store
=
getReduxStoreFromPanel
(
panel
)
;
return
waitForDispatch
(
store
"
FETCH_PROPERTIES
"
)
;
}
)
;
}
async
function
evaluateJSAsync
(
panel
expression
)
{
const
consoleFront
=
await
panel
.
currentTarget
.
getFront
(
"
console
"
)
;
return
consoleFront
.
evaluateJSAsync
(
expression
)
;
}
function
refreshPanel
(
panel
)
{
const
doc
=
panel
.
panelWin
.
document
;
const
button
=
doc
.
querySelector
(
"
#
dom
-
refresh
-
button
"
)
;
return
synthesizeMouseClickSoon
(
panel
button
)
.
then
(
(
)
=
>
{
const
store
=
getReduxStoreFromPanel
(
panel
)
;
return
waitForDispatch
(
store
"
FETCH_PROPERTIES
"
)
;
}
)
;
}
function
getReduxStoreFromPanel
(
panel
)
{
return
panel
.
panelWin
.
view
.
mainFrame
.
store
;
}
