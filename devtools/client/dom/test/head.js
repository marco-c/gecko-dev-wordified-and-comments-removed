"
use
strict
"
;
const
FRAME_SCRIPT_UTILS_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
framework
/
test
/
shared
-
head
.
js
"
this
)
;
const
constants
=
require
(
"
devtools
/
client
/
dom
/
content
/
constants
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
dom
.
enabled
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
info
(
"
finish
(
)
was
called
cleaning
up
.
.
.
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dom
.
enabled
"
)
;
}
)
;
function
addTestTab
(
url
)
{
info
(
"
Adding
a
new
test
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
return
new
Promise
(
resolve
=
>
{
addTab
(
url
)
.
then
(
tab
=
>
{
getFrameScript
(
)
;
initDOMPanel
(
tab
)
.
then
(
panel
=
>
{
waitForDispatch
(
panel
"
FETCH_PROPERTIES
"
)
.
then
(
(
)
=
>
{
resolve
(
{
tab
:
tab
browser
:
tab
.
linkedBrowser
panel
:
panel
}
)
;
}
)
;
}
)
;
}
)
;
}
)
;
}
function
initDOMPanel
(
tab
)
{
return
new
Promise
(
resolve
=
>
{
let
target
=
TargetFactory
.
forTab
(
tab
|
|
gBrowser
.
selectedTab
)
;
gDevTools
.
showToolbox
(
target
"
dom
"
)
.
then
(
toolbox
=
>
{
let
panel
=
toolbox
.
getCurrentPanel
(
)
;
resolve
(
panel
)
;
}
)
;
}
)
;
}
function
synthesizeMouseClickSoon
(
panel
element
)
{
return
new
Promise
(
resolve
=
>
{
executeSoon
(
(
)
=
>
{
EventUtils
.
synthesizeMouse
(
element
2
2
{
}
panel
.
panelWin
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
getRowByLabel
(
panel
text
)
{
let
doc
=
panel
.
panelWin
.
document
;
let
labels
=
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeLabel
"
)
]
;
let
label
=
labels
.
find
(
node
=
>
node
.
textContent
=
=
text
)
;
return
label
?
label
.
closest
(
"
.
treeRow
"
)
:
null
;
}
function
getAllRowsForLabel
(
panel
text
)
{
let
rootObjectLevel
;
let
node
;
let
result
=
[
]
;
let
doc
=
panel
.
panelWin
.
document
;
let
nodes
=
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeLabel
"
)
]
;
while
(
true
)
{
node
=
nodes
.
shift
(
)
;
if
(
!
node
|
|
node
.
textContent
=
=
=
text
)
{
rootObjectLevel
=
node
.
getAttribute
(
"
data
-
level
"
)
;
break
;
}
}
if
(
!
node
)
{
return
result
;
}
for
(
node
of
nodes
)
{
let
level
=
node
.
getAttribute
(
"
data
-
level
"
)
;
if
(
level
>
rootObjectLevel
)
{
result
.
push
(
{
name
:
normalizeTreeValue
(
node
.
textContent
)
value
:
normalizeTreeValue
(
node
.
parentNode
.
nextElementSibling
.
textContent
)
}
)
;
}
else
{
break
;
}
}
return
result
;
}
function
normalizeTreeValue
(
value
)
{
if
(
value
=
=
=
"
"
)
{
return
"
"
;
}
if
(
value
.
startsWith
(
"
)
&
&
value
.
endsWith
(
"
)
)
{
return
value
.
substr
(
1
value
.
length
-
2
)
;
}
if
(
isFinite
(
value
)
&
&
parseInt
(
value
10
)
=
=
value
)
{
return
parseInt
(
value
10
)
;
}
return
value
;
}
function
expandRow
(
panel
labelText
)
{
let
row
=
getRowByLabel
(
panel
labelText
)
;
return
synthesizeMouseClickSoon
(
panel
row
)
.
then
(
(
)
=
>
{
return
waitForDispatch
(
panel
"
FETCH_PROPERTIES
"
)
;
}
)
;
}
function
evaluateJSAsync
(
panel
expression
)
{
return
new
Promise
(
resolve
=
>
{
panel
.
target
.
activeConsole
.
evaluateJSAsync
(
expression
res
=
>
{
resolve
(
res
)
;
}
)
;
}
)
;
}
function
refreshPanel
(
panel
)
{
let
doc
=
panel
.
panelWin
.
document
;
let
button
=
doc
.
querySelector
(
"
.
btn
.
refresh
"
)
;
return
synthesizeMouseClickSoon
(
panel
button
)
.
then
(
(
)
=
>
{
return
waitForDispatch
(
panel
"
FETCH_PROPERTIES
"
)
;
}
)
;
}
function
_afterDispatchDone
(
store
type
)
{
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
{
if
(
action
.
type
=
=
=
type
)
{
return
action
.
status
?
(
action
.
status
=
=
=
"
end
"
|
|
action
.
status
=
=
=
"
error
"
)
:
true
;
}
return
false
;
}
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
function
waitForDispatch
(
panel
type
eventRepeat
=
1
)
{
const
store
=
panel
.
panelWin
.
view
.
mainFrame
.
store
;
const
actionType
=
constants
[
type
]
;
let
count
=
0
;
return
Task
.
spawn
(
function
*
(
)
{
info
(
"
Waiting
for
"
+
type
+
"
to
dispatch
"
+
eventRepeat
+
"
time
(
s
)
"
)
;
while
(
count
<
eventRepeat
)
{
yield
_afterDispatchDone
(
store
actionType
)
;
count
+
+
;
info
(
type
+
"
dispatched
"
+
count
+
"
time
(
s
)
"
)
;
}
}
)
;
}
