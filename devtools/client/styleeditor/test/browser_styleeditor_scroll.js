"
use
strict
"
;
const
SIMPLE
=
TEST_BASE_HTTP
+
"
simple
.
css
"
;
const
LONG
=
TEST_BASE_HTTP
+
"
doc_long
.
css
"
;
const
DOCUMENT_WITH_LONG_SHEET
=
"
data
:
text
/
html
;
charset
=
UTF
-
8
"
+
encodeURIComponent
(
[
"
<
!
DOCTYPE
html
>
"
"
<
html
>
"
"
<
head
>
"
"
<
title
>
Editor
scroll
test
page
<
/
title
>
"
'
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
'
+
SIMPLE
+
'
"
>
'
'
<
link
rel
=
"
stylesheet
"
type
=
"
text
/
css
"
href
=
"
'
+
LONG
+
'
"
>
'
"
<
/
head
>
"
"
<
body
>
Editor
scroll
test
page
<
/
body
>
"
"
<
/
html
>
"
]
.
join
(
"
\
n
"
)
)
;
const
LINE_TO_SELECT
=
201
;
add_task
(
async
function
(
)
{
const
{
ui
}
=
await
openStyleEditorForURL
(
DOCUMENT_WITH_LONG_SHEET
)
;
is
(
ui
.
editors
.
length
2
"
Two
editors
present
.
"
)
;
const
simpleEditor
=
ui
.
editors
[
0
]
;
const
longEditor
=
ui
.
editors
[
1
]
;
info
(
Selecting
doc_long
.
css
and
scrolling
to
line
{
LINE_TO_SELECT
}
)
;
let
selectEventPromise
=
waitForEditorToBeSelected
(
longEditor
ui
)
;
await
ui
.
selectStyleSheet
(
longEditor
.
styleSheet
LINE_TO_SELECT
)
;
await
selectEventPromise
;
info
(
"
Checking
that
the
correct
line
is
visible
after
initial
load
"
)
;
const
{
from
to
}
=
longEditor
.
sourceEditor
.
getViewport
(
)
;
info
(
Lines
{
from
}
-
{
to
}
are
visible
(
expected
{
LINE_TO_SELECT
}
)
.
)
;
ok
(
from
<
=
LINE_TO_SELECT
"
The
editor
scrolled
too
much
.
"
)
;
ok
(
to
>
=
LINE_TO_SELECT
"
The
editor
scrolled
too
little
.
"
)
;
const
initialScrollTop
=
longEditor
.
sourceEditor
.
getScrollInfo
(
)
.
top
;
info
(
Storing
scrollTop
=
{
initialScrollTop
}
for
later
comparison
.
)
;
info
(
"
Selecting
the
first
editor
(
simple
.
css
)
"
)
;
await
ui
.
selectStyleSheet
(
simpleEditor
.
styleSheet
)
;
info
(
"
Selecting
doc_long
.
css
again
.
"
)
;
selectEventPromise
=
waitForEditorToBeSelected
(
longEditor
ui
)
;
const
summary
=
await
ui
.
getEditorSummary
(
longEditor
)
;
ui
.
_view
.
activeSummary
=
summary
;
info
(
"
Waiting
for
doc_long
.
css
to
be
selected
.
"
)
;
await
selectEventPromise
;
const
scrollTop
=
longEditor
.
sourceEditor
.
getScrollInfo
(
)
.
top
;
is
(
scrollTop
initialScrollTop
"
Scroll
top
was
restored
after
the
sheet
was
selected
again
.
"
)
;
}
)
;
var
waitForEditorToBeSelected
=
async
function
(
editor
ui
)
{
info
(
Waiting
for
{
editor
.
friendlyName
}
to
be
selected
.
)
;
let
selected
=
await
ui
.
once
(
"
editor
-
selected
"
)
;
while
(
selected
!
=
editor
)
{
info
(
Ignored
editor
-
selected
for
editor
{
editor
.
friendlyName
}
.
)
;
selected
=
await
ui
.
once
(
"
editor
-
selected
"
)
;
}
info
(
Got
editor
-
selected
for
{
editor
.
friendlyName
}
.
)
;
}
;
