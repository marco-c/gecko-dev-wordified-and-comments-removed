"
use
strict
"
;
const
FRAME_SCRIPT_UTILS_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
const
TEST_BASE
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
styleeditor
/
test
/
"
;
const
TEST_BASE_HTTP
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
styleeditor
/
test
/
"
;
const
TEST_BASE_HTTPS
=
"
https
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
styleeditor
/
test
/
"
;
const
TEST_HOST
=
"
mochi
.
test
:
8888
"
;
const
EDITOR_FRAME_SCRIPT
=
getRootDirectory
(
gTestPath
)
+
"
doc_frame_script
.
js
"
;
var
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
var
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
DevToolsUtils
.
testing
=
true
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
DevToolsUtils
.
testing
=
false
;
}
)
;
function
addTab
(
url
win
)
{
info
(
"
Adding
a
new
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
let
def
=
promise
.
defer
(
)
;
let
targetWindow
=
win
|
|
window
;
let
targetBrowser
=
targetWindow
.
gBrowser
;
let
tab
=
targetBrowser
.
selectedTab
=
targetBrowser
.
addTab
(
url
)
;
targetBrowser
.
selectedBrowser
.
addEventListener
(
"
load
"
function
onload
(
)
{
targetBrowser
.
selectedBrowser
.
removeEventListener
(
"
load
"
onload
true
)
;
info
(
"
URL
'
"
+
url
+
"
'
loading
complete
"
)
;
def
.
resolve
(
tab
)
;
}
true
)
;
return
def
.
promise
;
}
function
navigateTo
(
url
)
{
let
navigating
=
promise
.
defer
(
)
;
gBrowser
.
selectedBrowser
.
addEventListener
(
"
load
"
function
onload
(
)
{
gBrowser
.
selectedBrowser
.
removeEventListener
(
"
load
"
onload
true
)
;
navigating
.
resolve
(
)
;
}
true
)
;
content
.
location
=
url
;
return
navigating
.
promise
;
}
function
*
cleanup
(
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
}
var
openStyleEditor
=
Task
.
async
(
function
*
(
tab
)
{
if
(
!
tab
)
{
tab
=
gBrowser
.
selectedTab
;
}
let
target
=
TargetFactory
.
forTab
(
tab
)
;
let
toolbox
=
yield
gDevTools
.
showToolbox
(
target
"
styleeditor
"
)
;
let
panel
=
toolbox
.
getPanel
(
"
styleeditor
"
)
;
let
ui
=
panel
.
UI
;
return
{
toolbox
panel
ui
}
;
}
)
;
var
openStyleEditorForURL
=
Task
.
async
(
function
*
(
url
win
)
{
let
tab
=
yield
addTab
(
url
win
)
;
gBrowser
.
selectedBrowser
.
messageManager
.
loadFrameScript
(
EDITOR_FRAME_SCRIPT
false
)
;
let
result
=
yield
openStyleEditor
(
tab
)
;
result
.
tab
=
tab
;
return
result
;
}
)
;
function
loadCommonFrameScript
(
tab
)
{
let
browser
=
tab
?
tab
.
linkedBrowser
:
gBrowser
.
selectedBrowser
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_UTILS_URL
false
)
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
promise
.
resolve
(
)
;
}
function
waitForContentMessage
(
name
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
def
=
promise
.
defer
(
)
;
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
def
.
resolve
(
msg
.
data
)
;
}
)
;
return
def
.
promise
;
}
registerCleanupFunction
(
cleanup
)
;
function
*
getComputedStyleProperty
(
selector
pseudo
propName
)
{
return
yield
executeInContent
(
"
Test
:
GetComputedStylePropertyValue
"
{
selector
pseudo
name
:
propName
}
)
;
}
