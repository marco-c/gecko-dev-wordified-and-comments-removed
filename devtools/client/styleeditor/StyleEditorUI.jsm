"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
StyleEditorUI
"
]
;
const
{
loader
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
FileUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
{
OS
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
getString
text
wire
showFilePicker
optionsPopupMenu
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
styleeditor
/
StyleEditorUtil
.
jsm
"
)
;
const
{
SplitView
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
styleeditor
/
SplitView
.
jsm
"
)
;
const
{
StyleSheetEditor
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
styleeditor
/
StyleSheetEditor
.
jsm
"
)
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
OriginalSource
}
=
require
(
"
devtools
/
client
/
styleeditor
/
original
-
source
"
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
devtools
/
client
/
responsive
/
manager
"
)
;
loader
.
lazyRequireGetter
(
this
"
openContentLink
"
"
devtools
/
client
/
shared
/
link
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
copyString
"
"
devtools
/
shared
/
platform
/
clipboard
"
true
)
;
const
LOAD_ERROR
=
"
error
-
load
"
;
const
PREF_MEDIA_SIDEBAR
=
"
devtools
.
styleeditor
.
showMediaSidebar
"
;
const
PREF_SIDEBAR_WIDTH
=
"
devtools
.
styleeditor
.
mediaSidebarWidth
"
;
const
PREF_NAV_WIDTH
=
"
devtools
.
styleeditor
.
navSidebarWidth
"
;
const
PREF_ORIG_SOURCES
=
"
devtools
.
source
-
map
.
client
-
service
.
enabled
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
StyleEditorUI
(
toolbox
commands
panelDoc
cssProperties
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_toolbox
=
toolbox
;
this
.
_commands
=
commands
;
this
.
_panelDoc
=
panelDoc
;
this
.
_cssProperties
=
cssProperties
;
this
.
_window
=
this
.
_panelDoc
.
defaultView
;
this
.
_root
=
this
.
_panelDoc
.
getElementById
(
"
style
-
editor
-
chrome
"
)
;
this
.
editors
=
[
]
;
this
.
selectedEditor
=
null
;
this
.
savedLocations
=
{
}
;
this
.
_seenSheets
=
new
Map
(
)
;
this
.
_onOptionsButtonClick
=
this
.
_onOptionsButtonClick
.
bind
(
this
)
;
this
.
_onOrigSourcesPrefChanged
=
this
.
_onOrigSourcesPrefChanged
.
bind
(
this
)
;
this
.
_onMediaPrefChanged
=
this
.
_onMediaPrefChanged
.
bind
(
this
)
;
this
.
_updateMediaList
=
this
.
_updateMediaList
.
bind
(
this
)
;
this
.
_clear
=
this
.
_clear
.
bind
(
this
)
;
this
.
_onError
=
this
.
_onError
.
bind
(
this
)
;
this
.
_updateContextMenuItems
=
this
.
_updateContextMenuItems
.
bind
(
this
)
;
this
.
_openLinkNewTab
=
this
.
_openLinkNewTab
.
bind
(
this
)
;
this
.
_copyUrl
=
this
.
_copyUrl
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_onResourceUpdated
=
this
.
_onResourceUpdated
.
bind
(
this
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
styleeditor
.
"
)
;
this
.
_prefObserver
.
on
(
PREF_MEDIA_SIDEBAR
this
.
_onMediaPrefChanged
)
;
this
.
_sourceMapPrefObserver
=
new
PrefObserver
(
"
devtools
.
source
-
map
.
client
-
service
.
"
)
;
this
.
_sourceMapPrefObserver
.
on
(
PREF_ORIG_SOURCES
this
.
_onOrigSourcesPrefChanged
)
;
}
StyleEditorUI
.
prototype
=
{
get
cssProperties
(
)
{
return
this
.
_cssProperties
;
}
get
currentTarget
(
)
{
return
this
.
_commands
.
targetCommand
.
targetFront
;
}
get
selectedStyleSheetIndex
(
)
{
return
this
.
selectedEditor
?
this
.
selectedEditor
.
styleSheet
.
styleSheetIndex
:
-
1
;
}
async
initialize
(
)
{
this
.
createUI
(
)
;
await
this
.
_toolbox
.
resourceCommand
.
watchResources
(
[
this
.
_toolbox
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
this
.
_startLoadingStyleSheets
(
)
;
await
this
.
_toolbox
.
resourceCommand
.
watchResources
(
[
this
.
_toolbox
.
resourceCommand
.
TYPES
.
STYLESHEET
]
{
onAvailable
:
this
.
_onResourceAvailable
onUpdated
:
this
.
_onResourceUpdated
}
)
;
await
this
.
_waitForLoadingStyleSheets
(
)
;
}
createUI
:
function
(
)
{
this
.
_view
=
new
SplitView
(
this
.
_root
)
;
wire
(
this
.
_view
.
rootElement
"
.
style
-
editor
-
newButton
"
async
(
)
=
>
{
const
stylesheetsFront
=
await
this
.
currentTarget
.
getFront
(
"
stylesheets
"
)
;
stylesheetsFront
.
addStyleSheet
(
null
)
;
}
)
;
wire
(
this
.
_view
.
rootElement
"
.
style
-
editor
-
importButton
"
(
)
=
>
{
this
.
_importFromFile
(
this
.
_mockImportFile
|
|
null
this
.
_window
)
;
}
)
;
wire
(
this
.
_view
.
rootElement
"
#
style
-
editor
-
options
"
event
=
>
{
this
.
_onOptionsButtonClick
(
event
)
;
}
)
;
this
.
_panelDoc
.
addEventListener
(
"
contextmenu
"
(
)
=
>
{
this
.
_contextMenuStyleSheet
=
null
;
}
true
)
;
this
.
_optionsButton
=
this
.
_panelDoc
.
getElementById
(
"
style
-
editor
-
options
"
)
;
this
.
_contextMenu
=
this
.
_panelDoc
.
getElementById
(
"
sidebar
-
context
"
)
;
this
.
_contextMenu
.
addEventListener
(
"
popupshowing
"
this
.
_updateContextMenuItems
)
;
this
.
_openLinkNewTabItem
=
this
.
_panelDoc
.
getElementById
(
"
context
-
openlinknewtab
"
)
;
this
.
_openLinkNewTabItem
.
addEventListener
(
"
command
"
this
.
_openLinkNewTab
)
;
this
.
_copyUrlItem
=
this
.
_panelDoc
.
getElementById
(
"
context
-
copyurl
"
)
;
this
.
_copyUrlItem
.
addEventListener
(
"
command
"
this
.
_copyUrl
)
;
const
nav
=
this
.
_panelDoc
.
querySelector
(
"
.
splitview
-
controller
"
)
;
nav
.
setAttribute
(
"
width
"
Services
.
prefs
.
getIntPref
(
PREF_NAV_WIDTH
)
)
;
}
_onOptionsButtonClick
(
{
screenX
screenY
}
)
{
this
.
_optionsMenu
=
optionsPopupMenu
(
this
.
_toggleOrigSources
this
.
_toggleMediaSidebar
)
;
this
.
_optionsMenu
.
once
(
"
open
"
(
)
=
>
{
this
.
_optionsButton
.
setAttribute
(
"
open
"
true
)
;
}
)
;
this
.
_optionsMenu
.
once
(
"
close
"
(
)
=
>
{
this
.
_optionsButton
.
removeAttribute
(
"
open
"
)
;
}
)
;
this
.
_optionsMenu
.
popup
(
screenX
screenY
this
.
_toolbox
.
doc
)
;
}
async
_onOrigSourcesPrefChanged
(
)
{
this
.
_clear
(
)
;
this
.
_root
.
classList
.
add
(
"
loading
"
)
;
for
(
const
resource
of
this
.
_toolbox
.
resourceCommand
.
getAllResources
(
this
.
_toolbox
.
resourceCommand
.
TYPES
.
STYLESHEET
)
)
{
await
this
.
_handleStyleSheetResource
(
resource
)
;
}
this
.
_root
.
classList
.
remove
(
"
loading
"
)
;
this
.
emit
(
"
stylesheets
-
refreshed
"
)
;
}
_clear
:
function
(
)
{
if
(
this
.
selectedEditor
&
&
this
.
selectedEditor
.
sourceEditor
)
{
const
href
=
this
.
selectedEditor
.
styleSheet
.
href
;
const
{
line
ch
}
=
this
.
selectedEditor
.
sourceEditor
.
getCursor
(
)
;
this
.
_styleSheetToSelect
=
{
stylesheet
:
href
line
:
line
col
:
ch
}
;
}
for
(
const
editor
of
this
.
editors
)
{
if
(
editor
.
savedFile
)
{
const
identifier
=
this
.
getStyleSheetIdentifier
(
editor
.
styleSheet
)
;
this
.
savedLocations
[
identifier
]
=
editor
.
savedFile
;
}
}
this
.
_clearStyleSheetEditors
(
)
;
this
.
_view
.
removeAll
(
)
;
this
.
selectedEditor
=
null
;
this
.
_seenSheets
=
new
Map
(
)
;
this
.
emit
(
"
stylesheets
-
clear
"
)
;
}
_addStyleSheet
:
function
(
resource
)
{
if
(
!
this
.
_seenSheets
.
has
(
resource
)
)
{
const
promise
=
(
async
(
)
=
>
{
let
editor
=
await
this
.
_addStyleSheetEditor
(
resource
)
;
const
sourceMapService
=
this
.
_toolbox
.
sourceMapService
;
if
(
!
sourceMapService
|
|
!
Services
.
prefs
.
getBoolPref
(
PREF_ORIG_SOURCES
)
)
{
return
editor
;
}
const
{
href
nodeHref
resourceId
:
id
sourceMapURL
sourceMapBaseURL
}
=
resource
;
const
sources
=
await
sourceMapService
.
getOriginalURLs
(
{
id
url
:
href
|
|
nodeHref
sourceMapBaseURL
sourceMapURL
}
)
;
if
(
sources
&
&
sources
.
length
)
{
const
parentEditorName
=
editor
.
friendlyName
;
this
.
_removeStyleSheetEditor
(
editor
)
;
editor
=
null
;
for
(
const
{
id
:
originalId
url
:
originalURL
}
of
sources
)
{
const
original
=
new
OriginalSource
(
originalURL
originalId
sourceMapService
)
;
original
.
styleSheetIndex
=
resource
.
styleSheetIndex
;
original
.
relatedStyleSheet
=
resource
;
original
.
relatedEditorName
=
parentEditorName
;
original
.
resourceId
=
resource
.
resourceId
;
original
.
targetFront
=
resource
.
targetFront
;
original
.
mediaRules
=
resource
.
mediaRules
;
await
this
.
_addStyleSheetEditor
(
original
)
;
}
}
return
editor
;
}
)
(
)
;
this
.
_seenSheets
.
set
(
resource
promise
)
;
}
return
this
.
_seenSheets
.
get
(
resource
)
;
}
_getInlineStyleSheetsCount
(
)
{
return
this
.
editors
.
filter
(
editor
=
>
!
editor
.
styleSheet
.
href
)
.
length
;
}
_getNewStyleSheetsCount
(
)
{
return
this
.
editors
.
filter
(
editor
=
>
editor
.
isNew
)
.
length
;
}
_getNextFriendlyIndex
:
function
(
styleSheet
)
{
if
(
styleSheet
.
href
)
{
return
undefined
;
}
return
styleSheet
.
isNew
?
this
.
_getNewStyleSheetsCount
(
)
:
this
.
_getInlineStyleSheetsCount
(
)
;
}
async
_addStyleSheetEditor
(
resource
)
{
const
editor
=
new
StyleSheetEditor
(
resource
this
.
_window
this
.
_getNextFriendlyIndex
(
resource
)
)
;
editor
.
on
(
"
property
-
change
"
this
.
_summaryChange
.
bind
(
this
editor
)
)
;
editor
.
on
(
"
media
-
rules
-
changed
"
this
.
_updateMediaList
.
bind
(
this
editor
)
)
;
editor
.
on
(
"
linked
-
css
-
file
"
this
.
_summaryChange
.
bind
(
this
editor
)
)
;
editor
.
on
(
"
linked
-
css
-
file
-
error
"
this
.
_summaryChange
.
bind
(
this
editor
)
)
;
editor
.
on
(
"
error
"
this
.
_onError
)
;
editor
.
onMediaRulesChanged
(
resource
.
mediaRules
)
;
this
.
editors
.
push
(
editor
)
;
try
{
await
editor
.
fetchSource
(
)
;
}
catch
(
e
)
{
if
(
!
this
.
editors
.
includes
(
editor
)
)
{
return
null
;
}
throw
e
;
}
this
.
_sourceLoaded
(
editor
)
;
if
(
resource
.
fileName
)
{
this
.
emit
(
"
test
:
editor
-
updated
"
editor
)
;
}
return
editor
;
}
_importFromFile
:
function
(
file
parentWindow
)
{
const
onFileSelected
=
selectedFile
=
>
{
if
(
!
selectedFile
)
{
return
;
}
NetUtil
.
asyncFetch
(
{
uri
:
NetUtil
.
newURI
(
selectedFile
)
loadingNode
:
this
.
_window
.
document
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
async
(
stream
status
)
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
this
.
emit
(
"
error
"
{
key
:
LOAD_ERROR
level
:
"
warning
"
}
)
;
return
;
}
const
source
=
NetUtil
.
readInputStreamToString
(
stream
stream
.
available
(
)
)
;
stream
.
close
(
)
;
const
stylesheetsFront
=
await
this
.
currentTarget
.
getFront
(
"
stylesheets
"
)
;
stylesheetsFront
.
addStyleSheet
(
source
selectedFile
.
path
)
;
}
)
;
}
;
showFilePicker
(
file
false
parentWindow
onFileSelected
)
;
}
_onError
:
function
(
data
)
{
this
.
emit
(
"
error
"
data
)
;
}
_toggleOrigSources
:
function
(
)
{
const
isEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_ORIG_SOURCES
)
;
Services
.
prefs
.
setBoolPref
(
PREF_ORIG_SOURCES
!
isEnabled
)
;
}
_toggleMediaSidebar
:
function
(
)
{
const
isEnabled
=
Services
.
prefs
.
getBoolPref
(
PREF_MEDIA_SIDEBAR
)
;
Services
.
prefs
.
setBoolPref
(
PREF_MEDIA_SIDEBAR
!
isEnabled
)
;
}
_onMediaPrefChanged
:
function
(
)
{
this
.
editors
.
forEach
(
this
.
_updateMediaList
)
;
}
_updateContextMenuItems
:
function
(
)
{
this
.
_openLinkNewTabItem
.
hidden
=
!
this
.
_contextMenuStyleSheet
;
this
.
_copyUrlItem
.
hidden
=
!
this
.
_contextMenuStyleSheet
;
if
(
this
.
_contextMenuStyleSheet
)
{
this
.
_openLinkNewTabItem
.
setAttribute
(
"
disabled
"
!
this
.
_contextMenuStyleSheet
.
href
)
;
this
.
_copyUrlItem
.
setAttribute
(
"
disabled
"
!
this
.
_contextMenuStyleSheet
.
href
)
;
}
}
_openLinkNewTab
:
function
(
)
{
if
(
this
.
_contextMenuStyleSheet
)
{
openContentLink
(
this
.
_contextMenuStyleSheet
.
href
)
;
}
}
_copyUrl
:
function
(
)
{
if
(
this
.
_contextMenuStyleSheet
)
{
copyString
(
this
.
_contextMenuStyleSheet
.
href
)
;
}
}
_removeStyleSheetEditor
:
function
(
editor
)
{
if
(
editor
.
summary
)
{
this
.
_view
.
removeItem
(
editor
.
summary
)
;
}
else
{
const
self
=
this
;
this
.
on
(
"
editor
-
added
"
function
onAdd
(
added
)
{
if
(
editor
=
=
added
)
{
self
.
off
(
"
editor
-
added
"
onAdd
)
;
self
.
_view
.
removeItem
(
editor
.
summary
)
;
}
}
)
;
}
editor
.
destroy
(
)
;
this
.
editors
.
splice
(
this
.
editors
.
indexOf
(
editor
)
1
)
;
}
_clearStyleSheetEditors
:
function
(
)
{
for
(
const
editor
of
this
.
editors
)
{
editor
.
destroy
(
)
;
}
this
.
editors
=
[
]
;
}
_sourceLoaded
:
function
(
editor
)
{
let
ordinal
=
editor
.
styleSheet
.
styleSheetIndex
;
ordinal
=
ordinal
=
=
-
1
?
Number
.
MAX_SAFE_INTEGER
:
ordinal
;
const
{
summary
details
}
=
this
.
_view
.
appendItem
(
{
ordinal
onShow
:
detailsEl
=
>
{
this
.
selectedEditor
=
editor
;
(
async
function
(
)
{
if
(
!
editor
.
sourceEditor
)
{
const
inputElement
=
detailsEl
.
querySelector
(
"
.
stylesheet
-
editor
-
input
"
)
;
await
editor
.
load
(
inputElement
this
.
_cssProperties
)
;
}
editor
.
onShow
(
)
;
this
.
emit
(
"
editor
-
selected
"
editor
)
;
}
.
bind
(
this
)
(
)
.
catch
(
console
.
error
)
)
;
}
}
)
;
const
createdEditor
=
editor
;
createdEditor
.
summary
=
summary
;
createdEditor
.
details
=
details
;
wire
(
summary
"
.
stylesheet
-
enabled
"
function
onToggleDisabled
(
event
)
{
event
.
stopPropagation
(
)
;
event
.
target
.
blur
(
)
;
createdEditor
.
toggleDisabled
(
)
;
}
)
;
wire
(
summary
"
.
stylesheet
-
name
"
{
events
:
{
keypress
:
event
=
>
{
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
this
.
_view
.
setActiveSummary
(
summary
)
;
}
}
}
}
)
;
wire
(
summary
"
.
stylesheet
-
saveButton
"
function
onSaveButton
(
event
)
{
event
.
stopPropagation
(
)
;
event
.
target
.
blur
(
)
;
createdEditor
.
saveToFile
(
createdEditor
.
savedFile
)
;
}
)
;
this
.
_updateSummaryForEditor
(
createdEditor
summary
)
;
summary
.
addEventListener
(
"
contextmenu
"
(
)
=
>
{
this
.
_contextMenuStyleSheet
=
createdEditor
.
styleSheet
;
}
)
;
summary
.
addEventListener
(
"
focus
"
function
onSummaryFocus
(
event
)
{
if
(
event
.
target
=
=
summary
)
{
summary
.
querySelector
(
"
.
stylesheet
-
name
"
)
.
focus
(
)
;
}
}
)
;
const
sidebar
=
details
.
querySelector
(
"
.
stylesheet
-
sidebar
"
)
;
sidebar
.
setAttribute
(
"
width
"
Services
.
prefs
.
getIntPref
(
PREF_SIDEBAR_WIDTH
)
)
;
const
splitter
=
details
.
querySelector
(
"
.
devtools
-
side
-
splitter
"
)
;
splitter
.
addEventListener
(
"
mousemove
"
(
)
=
>
{
const
sidebarWidth
=
sidebar
.
getAttribute
(
"
width
"
)
;
Services
.
prefs
.
setIntPref
(
PREF_SIDEBAR_WIDTH
sidebarWidth
)
;
const
sidebars
=
[
.
.
.
this
.
_panelDoc
.
querySelectorAll
(
"
.
stylesheet
-
sidebar
"
)
]
;
for
(
const
mediaSidebar
of
sidebars
)
{
mediaSidebar
.
setAttribute
(
"
width
"
sidebarWidth
)
;
}
}
)
;
if
(
createdEditor
.
isNew
)
{
this
.
_selectEditor
(
createdEditor
)
;
}
if
(
this
.
_isEditorToSelect
(
createdEditor
)
)
{
this
.
switchToSelectedSheet
(
)
;
}
if
(
!
this
.
selectedEditor
&
&
!
this
.
_styleSheetBoundToSelect
&
&
createdEditor
.
styleSheet
.
styleSheetIndex
=
=
0
)
{
this
.
_selectEditor
(
createdEditor
)
;
}
this
.
emit
(
"
editor
-
added
"
createdEditor
)
;
}
switchToSelectedSheet
:
function
(
)
{
const
toSelect
=
this
.
_styleSheetToSelect
;
for
(
const
editor
of
this
.
editors
)
{
if
(
this
.
_isEditorToSelect
(
editor
)
)
{
this
.
_styleSheetBoundToSelect
=
this
.
_styleSheetToSelect
;
this
.
_styleSheetToSelect
=
null
;
return
this
.
_selectEditor
(
editor
toSelect
.
line
toSelect
.
col
)
;
}
}
return
Promise
.
resolve
(
)
;
}
_isEditorToSelect
:
function
(
editor
)
{
const
toSelect
=
this
.
_styleSheetToSelect
;
if
(
!
toSelect
)
{
return
false
;
}
const
isHref
=
toSelect
.
stylesheet
=
=
=
null
|
|
typeof
toSelect
.
stylesheet
=
=
"
string
"
;
return
(
(
isHref
&
&
editor
.
styleSheet
.
href
=
=
toSelect
.
stylesheet
)
|
|
toSelect
.
stylesheet
=
=
editor
.
styleSheet
)
;
}
_selectEditor
:
function
(
editor
line
=
null
col
=
null
)
{
if
(
!
this
.
editors
.
includes
(
editor
)
)
{
return
null
;
}
const
editorPromise
=
editor
.
getSourceEditor
(
)
.
then
(
(
)
=
>
{
if
(
line
!
=
=
null
|
|
col
!
=
=
null
)
{
editor
.
setCursor
(
line
col
)
;
}
this
.
_styleSheetBoundToSelect
=
null
;
}
)
;
const
summaryPromise
=
this
.
getEditorSummary
(
editor
)
.
then
(
summary
=
>
{
if
(
!
this
.
editors
.
includes
(
editor
)
)
{
throw
new
Error
(
"
Editor
was
destroyed
"
)
;
}
this
.
_view
.
setActiveSummary
(
summary
)
;
}
)
;
return
Promise
.
all
(
[
editorPromise
summaryPromise
]
)
;
}
getEditorSummary
:
function
(
editor
)
{
const
self
=
this
;
if
(
editor
.
summary
)
{
return
Promise
.
resolve
(
editor
.
summary
)
;
}
return
new
Promise
(
resolve
=
>
{
this
.
on
(
"
editor
-
added
"
function
onAdd
(
selected
)
{
if
(
selected
=
=
editor
)
{
self
.
off
(
"
editor
-
added
"
onAdd
)
;
resolve
(
editor
.
summary
)
;
}
}
)
;
}
)
;
}
getEditorDetails
:
function
(
editor
)
{
const
self
=
this
;
if
(
editor
.
details
)
{
return
Promise
.
resolve
(
editor
.
details
)
;
}
return
new
Promise
(
resolve
=
>
{
this
.
on
(
"
editor
-
added
"
function
onAdd
(
selected
)
{
if
(
selected
=
=
editor
)
{
self
.
off
(
"
editor
-
added
"
onAdd
)
;
resolve
(
editor
.
details
)
;
}
}
)
;
}
)
;
}
getStyleSheetIdentifier
:
function
(
styleSheet
)
{
return
styleSheet
.
href
?
styleSheet
.
href
:
"
inline
-
"
+
styleSheet
.
styleSheetIndex
+
"
-
at
-
"
+
styleSheet
.
nodeHref
;
}
getOriginalSourceSheet
:
function
(
sourceId
)
{
for
(
const
editor
of
this
.
editors
)
{
const
{
styleSheet
}
=
editor
;
if
(
styleSheet
.
isOriginalSource
&
&
styleSheet
.
sourceId
=
=
=
sourceId
)
{
return
styleSheet
;
}
}
return
null
;
}
getStylesheetFrontForGeneratedURL
:
function
(
url
)
{
for
(
const
styleSheet
of
this
.
_seenSheets
.
keys
(
)
)
{
const
sheetURL
=
styleSheet
.
href
|
|
styleSheet
.
nodeHref
;
if
(
!
styleSheet
.
isOriginalSource
&
&
sheetURL
=
=
=
url
)
{
return
styleSheet
;
}
}
return
null
;
}
selectStyleSheet
:
function
(
stylesheet
line
col
)
{
this
.
_styleSheetToSelect
=
{
stylesheet
:
stylesheet
line
:
line
col
:
col
}
;
return
this
.
switchToSelectedSheet
(
)
;
}
_summaryChange
:
function
(
editor
)
{
this
.
_updateSummaryForEditor
(
editor
)
;
}
_updateSummaryForEditor
:
function
(
editor
summary
)
{
summary
=
summary
|
|
editor
.
summary
;
if
(
!
summary
)
{
return
;
}
let
ruleCount
=
editor
.
styleSheet
.
ruleCount
;
if
(
editor
.
styleSheet
.
relatedStyleSheet
)
{
ruleCount
=
editor
.
styleSheet
.
relatedStyleSheet
.
ruleCount
;
}
if
(
ruleCount
=
=
=
undefined
)
{
ruleCount
=
"
-
"
;
}
summary
.
classList
.
toggle
(
"
disabled
"
!
!
editor
.
styleSheet
.
disabled
)
;
summary
.
classList
.
toggle
(
"
unsaved
"
!
!
editor
.
unsaved
)
;
summary
.
classList
.
toggle
(
"
linked
-
file
-
error
"
!
!
editor
.
linkedCSSFileError
)
;
const
label
=
summary
.
querySelector
(
"
.
stylesheet
-
name
>
label
"
)
;
label
.
setAttribute
(
"
value
"
editor
.
friendlyName
)
;
if
(
editor
.
styleSheet
.
href
)
{
label
.
setAttribute
(
"
tooltiptext
"
editor
.
styleSheet
.
href
)
;
}
let
linkedCSSSource
=
"
"
;
if
(
editor
.
linkedCSSFile
)
{
linkedCSSSource
=
OS
.
Path
.
basename
(
editor
.
linkedCSSFile
)
;
}
else
if
(
editor
.
styleSheet
.
relatedEditorName
)
{
linkedCSSSource
=
editor
.
styleSheet
.
relatedEditorName
;
}
text
(
summary
"
.
stylesheet
-
linked
-
file
"
linkedCSSSource
)
;
text
(
summary
"
.
stylesheet
-
title
"
editor
.
styleSheet
.
title
|
|
"
"
)
;
text
(
summary
"
.
stylesheet
-
rule
-
count
"
PluralForm
.
get
(
ruleCount
getString
(
"
ruleCount
.
label
"
)
)
.
replace
(
"
#
1
"
ruleCount
)
)
;
}
_updateMediaList
:
function
(
editor
)
{
(
async
function
(
)
{
const
details
=
await
this
.
getEditorDetails
(
editor
)
;
const
list
=
details
.
querySelector
(
"
.
stylesheet
-
media
-
list
"
)
;
while
(
list
.
firstChild
)
{
list
.
firstChild
.
remove
(
)
;
}
const
rules
=
editor
.
mediaRules
;
const
showSidebar
=
Services
.
prefs
.
getBoolPref
(
PREF_MEDIA_SIDEBAR
)
;
const
sidebar
=
details
.
querySelector
(
"
.
stylesheet
-
sidebar
"
)
;
let
inSource
=
false
;
for
(
const
rule
of
rules
)
{
const
{
line
column
parentStyleSheet
}
=
rule
;
let
location
=
{
line
:
line
column
:
column
source
:
editor
.
styleSheet
.
href
styleSheet
:
parentStyleSheet
}
;
if
(
editor
.
styleSheet
.
isOriginalSource
)
{
const
styleSheet
=
editor
.
cssSheet
;
location
=
await
editor
.
styleSheet
.
getOriginalLocation
(
styleSheet
line
column
)
;
}
if
(
location
.
source
!
=
editor
.
styleSheet
.
href
)
{
continue
;
}
inSource
=
true
;
const
div
=
this
.
_panelDoc
.
createElementNS
(
HTML_NS
"
div
"
)
;
div
.
className
=
"
media
-
rule
-
label
"
;
div
.
addEventListener
(
"
click
"
this
.
_jumpToLocation
.
bind
(
this
location
)
)
;
const
cond
=
this
.
_panelDoc
.
createElementNS
(
HTML_NS
"
div
"
)
;
cond
.
className
=
"
media
-
rule
-
condition
"
;
if
(
!
rule
.
matches
)
{
cond
.
classList
.
add
(
"
media
-
condition
-
unmatched
"
)
;
}
if
(
this
.
_toolbox
.
descriptorFront
.
isLocalTab
)
{
this
.
_setConditionContents
(
cond
rule
.
conditionText
)
;
}
else
{
cond
.
textContent
=
rule
.
conditionText
;
}
div
.
appendChild
(
cond
)
;
const
link
=
this
.
_panelDoc
.
createElementNS
(
HTML_NS
"
div
"
)
;
link
.
className
=
"
media
-
rule
-
line
theme
-
link
"
;
if
(
location
.
line
!
=
-
1
)
{
link
.
textContent
=
"
:
"
+
location
.
line
;
}
div
.
appendChild
(
link
)
;
list
.
appendChild
(
div
)
;
}
sidebar
.
hidden
=
!
showSidebar
|
|
!
inSource
;
this
.
emit
(
"
media
-
list
-
changed
"
editor
)
;
}
.
bind
(
this
)
(
)
.
catch
(
console
.
error
)
)
;
}
_setConditionContents
(
element
rawText
)
{
const
minMaxPattern
=
/
(
min
\
-
|
max
\
-
)
(
width
|
height
)
:
\
s
\
d
+
(
px
)
/
gi
;
let
match
=
minMaxPattern
.
exec
(
rawText
)
;
let
lastParsed
=
0
;
while
(
match
&
&
match
.
index
!
=
minMaxPattern
.
lastIndex
)
{
const
matchEnd
=
match
.
index
+
match
[
0
]
.
length
;
const
node
=
this
.
_panelDoc
.
createTextNode
(
rawText
.
substring
(
lastParsed
match
.
index
)
)
;
element
.
appendChild
(
node
)
;
const
link
=
this
.
_panelDoc
.
createElementNS
(
HTML_NS
"
a
"
)
;
link
.
href
=
"
#
"
;
link
.
className
=
"
media
-
responsive
-
mode
-
toggle
"
;
link
.
textContent
=
rawText
.
substring
(
match
.
index
matchEnd
)
;
link
.
addEventListener
(
"
click
"
this
.
_onMediaConditionClick
.
bind
(
this
)
)
;
element
.
appendChild
(
link
)
;
match
=
minMaxPattern
.
exec
(
rawText
)
;
lastParsed
=
matchEnd
;
}
const
node
=
this
.
_panelDoc
.
createTextNode
(
rawText
.
substring
(
lastParsed
rawText
.
length
)
)
;
element
.
appendChild
(
node
)
;
}
_onMediaConditionClick
:
function
(
e
)
{
const
conditionText
=
e
.
target
.
textContent
;
const
isWidthCond
=
conditionText
.
toLowerCase
(
)
.
indexOf
(
"
width
"
)
>
-
1
;
const
mediaVal
=
parseInt
(
/
\
d
+
/
.
exec
(
conditionText
)
10
)
;
const
options
=
isWidthCond
?
{
width
:
mediaVal
}
:
{
height
:
mediaVal
}
;
this
.
_launchResponsiveMode
(
options
)
;
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
async
_launchResponsiveMode
(
options
=
{
}
)
{
const
tab
=
this
.
currentTarget
.
localTab
;
const
win
=
this
.
currentTarget
.
localTab
.
ownerDocument
.
defaultView
;
await
ResponsiveUIManager
.
openIfNeeded
(
win
tab
{
trigger
:
"
style_editor
"
}
)
;
this
.
emit
(
"
responsive
-
mode
-
opened
"
)
;
ResponsiveUIManager
.
getResponsiveUIForTab
(
tab
)
.
setViewportSize
(
options
)
;
}
_jumpToLocation
:
function
(
location
)
{
const
source
=
location
.
styleSheet
|
|
location
.
source
;
this
.
selectStyleSheet
(
source
location
.
line
-
1
location
.
column
-
1
)
;
}
_startLoadingStyleSheets
(
)
{
this
.
_root
.
classList
.
add
(
"
loading
"
)
;
this
.
_loadingStyleSheets
=
[
]
;
}
async
_waitForLoadingStyleSheets
(
)
{
while
(
this
.
_loadingStyleSheets
?
.
length
>
0
)
{
const
pending
=
this
.
_loadingStyleSheets
;
this
.
_loadingStyleSheets
=
[
]
;
await
Promise
.
all
(
pending
)
;
}
this
.
_loadingStyleSheets
=
null
;
this
.
_root
.
classList
.
remove
(
"
loading
"
)
;
}
async
_handleStyleSheetResource
(
resource
)
{
try
{
const
{
fileName
}
=
resource
;
let
file
=
fileName
?
new
FileUtils
.
File
(
fileName
)
:
null
;
if
(
!
file
)
{
const
identifier
=
this
.
getStyleSheetIdentifier
(
resource
)
;
const
savedFile
=
this
.
savedLocations
[
identifier
]
;
if
(
savedFile
)
{
file
=
savedFile
;
}
}
resource
.
file
=
file
;
await
this
.
_addStyleSheet
(
resource
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
this
.
emit
(
"
error
"
{
key
:
LOAD_ERROR
level
:
"
warning
"
}
)
;
}
}
async
_onResourceAvailable
(
resources
)
{
const
promises
=
[
]
;
for
(
const
resource
of
resources
)
{
if
(
resource
.
resourceType
=
=
=
this
.
_toolbox
.
resourceCommand
.
TYPES
.
STYLESHEET
)
{
const
onStyleSheetHandled
=
this
.
_handleStyleSheetResource
(
resource
)
;
if
(
this
.
_loadingStyleSheets
)
{
this
.
_loadingStyleSheets
.
push
(
onStyleSheetHandled
)
;
}
promises
.
push
(
onStyleSheetHandled
)
;
continue
;
}
if
(
!
resource
.
targetFront
.
isTopLevel
)
{
continue
;
}
if
(
resource
.
name
=
=
=
"
will
-
navigate
"
)
{
this
.
_startLoadingStyleSheets
(
)
;
this
.
_clear
(
)
;
}
else
if
(
resource
.
name
=
=
=
"
dom
-
complete
"
)
{
promises
.
push
(
this
.
_waitForLoadingStyleSheets
(
)
)
;
}
}
await
Promise
.
all
(
promises
)
;
}
async
_onResourceUpdated
(
updates
)
{
for
(
const
{
resource
update
}
of
updates
)
{
if
(
update
.
resourceType
=
=
=
this
.
_toolbox
.
resourceCommand
.
TYPES
.
STYLESHEET
)
{
const
editor
=
this
.
editors
.
find
(
e
=
>
e
.
resourceId
=
=
=
update
.
resourceId
)
;
switch
(
update
.
updateType
)
{
case
"
style
-
applied
"
:
{
editor
.
onStyleApplied
(
update
)
;
break
;
}
case
"
property
-
change
"
:
{
for
(
const
[
property
value
]
of
Object
.
entries
(
update
.
resourceUpdates
)
)
{
editor
.
onPropertyChange
(
property
value
)
;
}
break
;
}
case
"
media
-
rules
-
changed
"
:
case
"
matches
-
change
"
:
{
const
{
mediaRules
}
=
resource
;
editor
.
onMediaRulesChanged
(
mediaRules
)
;
break
;
}
}
}
}
}
destroy
:
function
(
)
{
this
.
_toolbox
.
resourceCommand
.
unwatchResources
(
[
this
.
_toolbox
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
this
.
_toolbox
.
resourceCommand
.
TYPES
.
STYLESHEET
]
{
onAvailable
:
this
.
_onResourceAvailable
onUpdated
:
this
.
_onResourceUpdated
}
)
;
this
.
_clearStyleSheetEditors
(
)
;
this
.
_seenSheets
=
null
;
const
sidebar
=
this
.
_panelDoc
.
querySelector
(
"
.
splitview
-
controller
"
)
;
const
sidebarWidth
=
sidebar
.
getAttribute
(
"
width
"
)
;
Services
.
prefs
.
setIntPref
(
PREF_NAV_WIDTH
sidebarWidth
)
;
this
.
_sourceMapPrefObserver
.
off
(
PREF_ORIG_SOURCES
this
.
_onOrigSourcesPrefChanged
)
;
this
.
_sourceMapPrefObserver
.
destroy
(
)
;
this
.
_prefObserver
.
off
(
PREF_MEDIA_SIDEBAR
this
.
_onMediaPrefChanged
)
;
this
.
_prefObserver
.
destroy
(
)
;
}
}
;
