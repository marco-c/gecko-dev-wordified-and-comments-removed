"
use
strict
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
getString
"
"
assert
"
"
log
"
"
text
"
"
wire
"
"
showFilePicker
"
"
optionsPopupMenu
"
]
;
const
PROPERTIES_URL
=
"
chrome
:
/
/
devtools
/
locale
/
styleeditor
.
properties
"
;
const
{
loader
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
gStringBundle
=
Services
.
strings
.
createBundle
(
PROPERTIES_URL
)
;
loader
.
lazyRequireGetter
(
this
"
Menu
"
"
devtools
/
client
/
framework
/
menu
"
)
;
loader
.
lazyRequireGetter
(
this
"
MenuItem
"
"
devtools
/
client
/
framework
/
menu
-
item
"
)
;
const
PREF_MEDIA_SIDEBAR
=
"
devtools
.
styleeditor
.
showMediaSidebar
"
;
const
PREF_ORIG_SOURCES
=
"
devtools
.
source
-
map
.
client
-
service
.
enabled
"
;
function
getString
(
name
)
{
try
{
if
(
arguments
.
length
=
=
1
)
{
return
gStringBundle
.
GetStringFromName
(
name
)
;
}
const
rest
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
return
gStringBundle
.
formatStringFromName
(
name
rest
rest
.
length
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
throw
new
Error
(
"
L10N
error
.
'
"
+
name
+
"
'
is
missing
from
"
+
PROPERTIES_URL
)
;
}
}
function
assert
(
expression
message
)
{
if
(
!
expression
)
{
const
msg
=
message
?
"
ASSERTION
FAILURE
:
"
+
message
:
"
ASSERTION
FAILURE
"
;
log
(
msg
)
;
throw
new
Error
(
msg
)
;
}
return
expression
;
}
function
text
(
root
selector
textContent
)
{
const
element
=
root
.
querySelector
(
selector
)
;
if
(
!
element
)
{
return
null
;
}
if
(
textContent
=
=
=
undefined
)
{
return
element
.
textContent
;
}
element
.
textContent
=
textContent
;
return
textContent
;
}
function
forEach
(
object
callback
)
{
for
(
const
key
in
object
)
{
if
(
object
.
hasOwnProperty
(
key
)
)
{
callback
(
key
object
[
key
]
)
;
}
}
}
function
log
(
)
{
console
.
logStringMessage
(
Array
.
prototype
.
slice
.
call
(
arguments
)
.
join
(
"
"
)
)
;
}
function
wire
(
root
selectorOrElement
descriptor
)
{
let
matches
;
if
(
typeof
selectorOrElement
=
=
"
string
"
)
{
matches
=
root
.
querySelectorAll
(
selectorOrElement
)
;
if
(
!
matches
.
length
)
{
return
;
}
}
else
{
matches
=
[
selectorOrElement
]
;
}
if
(
typeof
descriptor
=
=
"
function
"
)
{
descriptor
=
{
events
:
{
click
:
descriptor
}
}
;
}
for
(
let
i
=
0
;
i
<
matches
.
length
;
i
+
+
)
{
const
element
=
matches
[
i
]
;
forEach
(
descriptor
.
events
function
(
name
handler
)
{
element
.
addEventListener
(
name
handler
)
;
}
)
;
forEach
(
descriptor
.
attributes
element
.
setAttribute
)
;
}
}
function
showFilePicker
(
path
toSave
parentWindow
callback
suggestedFilename
)
{
if
(
typeof
path
=
=
"
string
"
)
{
try
{
if
(
Services
.
io
.
extractScheme
(
path
)
=
=
"
file
"
)
{
const
uri
=
Services
.
io
.
newURI
(
path
)
;
const
file
=
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
callback
(
file
)
;
return
;
}
}
catch
(
ex
)
{
callback
(
null
)
;
return
;
}
try
{
const
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
path
)
;
callback
(
file
)
;
return
;
}
catch
(
ex
)
{
callback
(
null
)
;
return
;
}
}
if
(
path
)
{
callback
(
path
)
;
return
;
}
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
const
mode
=
toSave
?
fp
.
modeSave
:
fp
.
modeOpen
;
const
key
=
toSave
?
"
saveStyleSheet
"
:
"
importStyleSheet
"
;
const
fpCallback
=
function
(
result
)
{
if
(
result
=
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
callback
(
null
)
;
}
else
{
callback
(
fp
.
file
)
;
}
}
;
if
(
toSave
&
&
suggestedFilename
)
{
fp
.
defaultString
=
suggestedFilename
;
}
fp
.
init
(
parentWindow
getString
(
key
+
"
.
title
"
)
mode
)
;
fp
.
appendFilter
(
getString
(
key
+
"
.
filter
"
)
"
*
.
css
"
)
;
fp
.
appendFilters
(
fp
.
filterAll
)
;
fp
.
open
(
fpCallback
)
;
}
function
optionsPopupMenu
(
toggleOrigSources
toggleMediaSidebar
)
{
const
popupMenu
=
new
Menu
(
)
;
popupMenu
.
append
(
new
MenuItem
(
{
id
:
"
options
-
origsources
"
label
:
getString
(
"
showOriginalSources
.
label
"
)
accesskey
:
getString
(
"
showOriginalSources
.
accesskey
"
)
type
:
"
checkbox
"
checked
:
Services
.
prefs
.
getBoolPref
(
PREF_ORIG_SOURCES
)
click
:
(
)
=
>
toggleOrigSources
(
)
}
)
)
;
popupMenu
.
append
(
new
MenuItem
(
{
id
:
"
options
-
show
-
media
"
label
:
getString
(
"
showMediaSidebar
.
label
"
)
accesskey
:
getString
(
"
showMediaSidebar
.
accesskey
"
)
type
:
"
checkbox
"
checked
:
Services
.
prefs
.
getBoolPref
(
PREF_MEDIA_SIDEBAR
)
click
:
(
)
=
>
toggleMediaSidebar
(
)
}
)
)
;
return
popupMenu
;
}
