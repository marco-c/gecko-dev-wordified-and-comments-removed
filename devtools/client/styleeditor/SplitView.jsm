"
use
strict
"
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
EXPORTED_SYMBOLS
=
[
"
SplitView
"
]
;
var
bindings
=
new
WeakMap
(
)
;
class
SplitView
extends
EventEmitter
{
#
filter
;
static
FILTERED_CLASSNAME
=
"
splitview
-
filtered
"
;
static
ALL_FILTERED_CLASSNAME
=
"
splitview
-
all
-
filtered
"
;
constructor
(
root
)
{
super
(
)
;
this
.
_root
=
root
;
this
.
_controller
=
root
.
querySelector
(
"
.
splitview
-
controller
"
)
;
this
.
_nav
=
root
.
querySelector
(
"
.
splitview
-
nav
"
)
;
this
.
_side
=
root
.
querySelector
(
"
.
splitview
-
side
-
details
"
)
;
this
.
_tplSummary
=
root
.
querySelector
(
"
#
splitview
-
tpl
-
summary
-
stylesheet
"
)
;
this
.
_tplDetails
=
root
.
querySelector
(
"
#
splitview
-
tpl
-
details
-
stylesheet
"
)
;
this
.
_activeSummary
=
null
;
this
.
_nav
.
addEventListener
(
"
keydown
"
event
=
>
{
function
getFocusedItemWithin
(
nav
)
{
let
node
=
nav
.
ownerDocument
.
activeElement
;
while
(
node
&
&
node
.
parentNode
!
=
nav
)
{
node
=
node
.
parentNode
;
}
return
node
;
}
if
(
event
.
target
.
ownerDocument
!
=
this
.
_nav
.
ownerDocument
|
|
event
.
target
.
tagName
=
=
"
input
"
|
|
event
.
target
.
tagName
=
=
"
textarea
"
|
|
event
.
target
.
classList
.
contains
(
"
textbox
"
)
)
{
return
false
;
}
const
visibleElements
=
Array
.
from
(
this
.
_nav
.
querySelectorAll
(
li
:
not
(
.
{
SplitView
.
FILTERED_CLASSNAME
}
)
)
)
;
visibleElements
.
sort
(
(
a
b
)
=
>
a
.
getAttribute
(
"
data
-
ordinal
"
)
-
b
.
getAttribute
(
"
data
-
ordinal
"
)
)
;
let
elementToFocus
;
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_PAGE_UP
|
|
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_HOME
)
{
elementToFocus
=
visibleElements
[
0
]
;
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_PAGE_DOWN
|
|
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_END
)
{
elementToFocus
=
visibleElements
.
at
(
-
1
)
;
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_UP
)
{
const
focusedIndex
=
visibleElements
.
indexOf
(
getFocusedItemWithin
(
this
.
_nav
)
)
;
elementToFocus
=
visibleElements
[
focusedIndex
-
1
]
;
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_DOWN
)
{
const
focusedIndex
=
visibleElements
.
indexOf
(
getFocusedItemWithin
(
this
.
_nav
)
)
;
elementToFocus
=
visibleElements
[
focusedIndex
+
1
]
;
}
if
(
elementToFocus
!
=
=
undefined
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
elementToFocus
.
focus
(
)
;
return
false
;
}
return
true
;
}
)
;
}
get
rootElement
(
)
{
return
this
.
_root
;
}
setActiveSummary
(
summary
options
=
{
}
)
{
if
(
summary
=
=
this
.
_activeSummary
)
{
return
;
}
if
(
this
.
_activeSummary
)
{
const
binding
=
bindings
.
get
(
this
.
_activeSummary
)
;
this
.
_activeSummary
.
classList
.
remove
(
"
splitview
-
active
"
)
;
binding
.
_details
.
classList
.
remove
(
"
splitview
-
active
"
)
;
}
this
.
_activeSummary
=
summary
;
if
(
!
summary
)
{
this
.
emit
(
"
active
-
summary
-
cleared
"
)
;
return
;
}
const
binding
=
bindings
.
get
(
summary
)
;
summary
.
classList
.
add
(
"
splitview
-
active
"
)
;
binding
.
_details
.
classList
.
add
(
"
splitview
-
active
"
)
;
if
(
binding
.
onShow
)
{
binding
.
onShow
(
binding
.
_details
options
)
;
}
}
appendItem
(
options
)
{
const
details
=
this
.
_tplDetails
.
cloneNode
(
true
)
;
details
.
id
=
"
"
;
const
summary
=
this
.
_tplSummary
.
cloneNode
(
true
)
;
summary
.
id
=
"
"
;
if
(
options
?
.
ordinal
!
=
=
undefined
)
{
summary
.
style
.
MozBoxOrdinalGroup
=
options
.
ordinal
;
summary
.
setAttribute
(
"
data
-
ordinal
"
options
.
ordinal
)
;
}
summary
.
addEventListener
(
"
click
"
event
=
>
{
event
.
stopPropagation
(
)
;
this
.
setActiveSummary
(
summary
)
;
}
)
;
this
.
_nav
.
appendChild
(
summary
)
;
this
.
_side
.
appendChild
(
details
)
;
bindings
.
set
(
summary
{
_summary
:
summary
_details
:
details
onShow
:
options
?
.
onShow
}
)
;
return
{
summary
details
}
;
}
removeItem
(
summary
)
{
if
(
summary
=
=
this
.
_activeSummary
)
{
this
.
setActiveSummary
(
null
)
;
}
const
binding
=
bindings
.
get
(
summary
)
;
if
(
!
binding
)
{
return
;
}
summary
.
remove
(
)
;
binding
.
_details
.
remove
(
)
;
}
removeAll
(
)
{
while
(
this
.
_nav
.
hasChildNodes
(
)
)
{
this
.
removeItem
(
this
.
_nav
.
firstChild
)
;
}
}
setFilter
(
str
)
{
this
.
#
filter
=
str
;
for
(
const
summary
of
this
.
_nav
.
childNodes
)
{
this
.
handleSummaryVisibility
(
summary
{
triggerOnFilterStateChange
:
false
}
)
;
}
this
.
#
onFilterStateChange
(
)
;
if
(
this
.
_activeSummary
=
=
null
)
{
const
firstVisibleSummary
=
Array
.
from
(
this
.
_nav
.
childNodes
)
.
find
(
node
=
>
!
node
.
classList
.
contains
(
SplitView
.
FILTERED_CLASSNAME
)
)
;
if
(
firstVisibleSummary
)
{
this
.
setActiveSummary
(
firstVisibleSummary
{
reason
:
"
filter
-
auto
"
}
)
;
}
}
}
#
onFilterStateChange
(
)
{
const
summaries
=
Array
.
from
(
this
.
_nav
.
childNodes
)
;
const
hasVisibleSummary
=
summaries
.
some
(
node
=
>
!
node
.
classList
.
contains
(
SplitView
.
FILTERED_CLASSNAME
)
)
;
const
allFiltered
=
summaries
.
length
>
0
&
&
!
hasVisibleSummary
;
this
.
_nav
.
classList
.
toggle
(
SplitView
.
ALL_FILTERED_CLASSNAME
allFiltered
)
;
this
.
emit
(
"
filter
-
state
-
change
"
{
allFiltered
}
)
;
}
handleSummaryVisibility
(
summary
{
triggerOnFilterStateChange
=
true
}
=
{
}
)
{
if
(
!
this
.
#
filter
)
{
summary
.
classList
.
remove
(
SplitView
.
FILTERED_CLASSNAME
)
;
return
;
}
const
label
=
summary
.
querySelector
(
"
.
stylesheet
-
name
label
"
)
;
const
itemText
=
label
.
value
.
toLowerCase
(
)
;
const
matchesSearch
=
itemText
.
includes
(
this
.
#
filter
.
toLowerCase
(
)
)
;
summary
.
classList
.
toggle
(
SplitView
.
FILTERED_CLASSNAME
!
matchesSearch
)
;
if
(
this
.
_activeSummary
=
=
summary
&
&
!
matchesSearch
)
{
this
.
setActiveSummary
(
null
)
;
}
if
(
triggerOnFilterStateChange
)
{
this
.
#
onFilterStateChange
(
)
;
}
}
}
