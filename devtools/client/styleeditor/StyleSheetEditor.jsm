"
use
strict
"
;
const
EXPORTED_SYMBOLS
=
[
"
StyleSheetEditor
"
]
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
Editor
=
require
(
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
shortSource
prettifyCSS
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
{
throttle
}
=
require
(
"
devtools
/
shared
/
throttle
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
FileUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
{
OS
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
getString
showFilePicker
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
styleeditor
/
StyleEditorUtil
.
jsm
"
)
;
const
LOAD_ERROR
=
"
error
-
load
"
;
const
SAVE_ERROR
=
"
error
-
save
"
;
const
UPDATE_STYLESHEET_DELAY
=
500
;
const
AUTOCOMPLETION_PREF
=
"
devtools
.
styleeditor
.
autocompletion
-
enabled
"
;
const
TRANSITION_PREF
=
"
devtools
.
styleeditor
.
transitions
"
;
const
CHECK_LINKED_SHEET_DELAY
=
500
;
const
MAX_CHECK_COUNT
=
10
;
const
SELECTOR_HIGHLIGHT_TIMEOUT
=
500
;
const
EMIT_MEDIA_RULES_THROTTLING
=
500
;
function
StyleSheetEditor
(
resource
win
targetList
walker
highlighter
styleSheetFriendlyIndex
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_resource
=
resource
;
this
.
_targetList
=
targetList
;
this
.
_inputElement
=
null
;
this
.
sourceEditor
=
null
;
this
.
_window
=
win
;
this
.
_isNew
=
this
.
styleSheet
.
isNew
;
this
.
walker
=
walker
;
this
.
highlighter
=
highlighter
;
this
.
styleSheetFriendlyIndex
=
styleSheetFriendlyIndex
;
this
.
_isUpdating
=
false
;
this
.
_justSetText
=
false
;
this
.
_state
=
{
text
:
"
"
selection
:
{
start
:
{
line
:
0
ch
:
0
}
end
:
{
line
:
0
ch
:
0
}
}
}
;
this
.
_styleSheetFilePath
=
null
;
if
(
this
.
styleSheet
.
href
&
&
Services
.
io
.
extractScheme
(
this
.
styleSheet
.
href
)
=
=
"
file
"
)
{
this
.
_styleSheetFilePath
=
this
.
styleSheet
.
href
;
}
this
.
onPropertyChange
=
this
.
onPropertyChange
.
bind
(
this
)
;
this
.
_onError
=
this
.
_onError
.
bind
(
this
)
;
this
.
onMediaRulesChanged
=
this
.
onMediaRulesChanged
.
bind
(
this
)
;
this
.
checkLinkedFileForChanges
=
this
.
checkLinkedFileForChanges
.
bind
(
this
)
;
this
.
markLinkedFileBroken
=
this
.
markLinkedFileBroken
.
bind
(
this
)
;
this
.
saveToFile
=
this
.
saveToFile
.
bind
(
this
)
;
this
.
updateStyleSheet
=
this
.
updateStyleSheet
.
bind
(
this
)
;
this
.
_updateStyleSheet
=
this
.
_updateStyleSheet
.
bind
(
this
)
;
this
.
_onMouseMove
=
this
.
_onMouseMove
.
bind
(
this
)
;
this
.
_focusOnSourceEditorReady
=
false
;
this
.
styleSheet
.
on
(
"
error
"
this
.
_onError
)
;
this
.
savedFile
=
this
.
styleSheet
.
file
;
this
.
linkCSSFile
(
)
;
this
.
emitMediaRulesChanged
=
throttle
(
this
.
emitMediaRulesChanged
EMIT_MEDIA_RULES_THROTTLING
this
)
;
this
.
mediaRules
=
[
]
;
}
StyleSheetEditor
.
prototype
=
{
get
resourceId
(
)
{
return
this
.
_resource
.
resourceId
;
}
get
styleSheet
(
)
{
return
this
.
_resource
;
}
get
unsaved
(
)
{
return
this
.
sourceEditor
&
&
!
this
.
sourceEditor
.
isClean
(
)
;
}
get
isNew
(
)
{
return
this
.
_isNew
;
}
get
cssSheet
(
)
{
if
(
this
.
styleSheet
.
isOriginalSource
)
{
return
this
.
styleSheet
.
relatedStyleSheet
;
}
return
this
.
styleSheet
;
}
get
savedFile
(
)
{
return
this
.
_savedFile
;
}
set
savedFile
(
name
)
{
this
.
_savedFile
=
name
;
this
.
linkCSSFile
(
)
;
}
get
friendlyName
(
)
{
if
(
this
.
savedFile
)
{
return
this
.
savedFile
.
leafName
;
}
if
(
this
.
_isNew
)
{
const
index
=
this
.
styleSheetFriendlyIndex
+
1
|
|
0
;
return
getString
(
"
newStyleSheet
"
index
)
;
}
if
(
!
this
.
styleSheet
.
href
)
{
const
index
=
this
.
styleSheetFriendlyIndex
+
1
|
|
0
;
return
getString
(
"
inlineStyleSheet
"
index
)
;
}
if
(
!
this
.
_friendlyName
)
{
const
sheetURI
=
this
.
styleSheet
.
href
;
this
.
_friendlyName
=
shortSource
(
{
href
:
sheetURI
}
)
;
try
{
this
.
_friendlyName
=
decodeURI
(
this
.
_friendlyName
)
;
}
catch
(
ex
)
{
}
}
return
this
.
_friendlyName
;
}
get
transitionsEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
TRANSITION_PREF
)
;
}
linkCSSFile
:
function
(
)
{
if
(
!
this
.
styleSheet
.
isOriginalSource
)
{
return
;
}
const
relatedSheet
=
this
.
styleSheet
.
relatedStyleSheet
;
if
(
!
relatedSheet
|
|
!
relatedSheet
.
href
)
{
return
;
}
let
path
;
const
href
=
removeQuery
(
relatedSheet
.
href
)
;
const
uri
=
NetUtil
.
newURI
(
href
)
;
if
(
uri
.
scheme
=
=
"
file
"
)
{
const
file
=
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
.
file
;
path
=
file
.
path
;
}
else
if
(
this
.
savedFile
)
{
const
origHref
=
removeQuery
(
this
.
styleSheet
.
href
)
;
const
origUri
=
NetUtil
.
newURI
(
origHref
)
;
path
=
findLinkedFilePath
(
uri
origUri
this
.
savedFile
)
;
}
else
{
return
;
}
if
(
this
.
linkedCSSFile
=
=
path
)
{
return
;
}
this
.
linkedCSSFile
=
path
;
this
.
linkedCSSFileError
=
null
;
OS
.
File
.
stat
(
path
)
.
then
(
info
=
>
{
this
.
_fileModDate
=
info
.
lastModificationDate
.
getTime
(
)
;
}
this
.
markLinkedFileBroken
)
;
this
.
emit
(
"
linked
-
css
-
file
"
)
;
}
_getSourceTextAndPrettify
:
function
(
)
{
return
this
.
styleSheet
.
getText
(
)
.
then
(
longStr
=
>
{
return
longStr
.
string
(
)
;
}
)
.
then
(
source
=
>
{
const
ruleCount
=
this
.
styleSheet
.
ruleCount
;
if
(
!
this
.
styleSheet
.
isOriginalSource
)
{
const
{
result
mappings
}
=
prettifyCSS
(
source
ruleCount
)
;
source
=
result
;
this
.
_mappings
=
mappings
;
}
this
.
_state
.
text
=
source
;
return
source
;
}
)
;
}
fetchSource
:
function
(
)
{
return
this
.
_getSourceTextAndPrettify
(
)
.
then
(
source
=
>
{
this
.
sourceLoaded
=
true
;
return
source
;
}
)
.
catch
(
e
=
>
{
if
(
this
.
_isDestroyed
)
{
console
.
warn
(
"
Could
not
fetch
the
source
for
"
+
this
.
styleSheet
.
href
+
"
the
editor
was
destroyed
"
)
;
console
.
error
(
e
)
;
}
else
{
console
.
error
(
e
)
;
this
.
emit
(
"
error
"
{
key
:
LOAD_ERROR
append
:
this
.
styleSheet
.
href
level
:
"
warning
"
}
)
;
throw
e
;
}
}
)
;
}
setCursor
(
line
column
)
{
const
position
=
this
.
translateCursorPosition
(
line
column
)
;
this
.
sourceEditor
.
setCursor
(
{
line
:
position
.
line
ch
:
position
.
column
}
)
;
}
translateCursorPosition
(
line
column
)
{
if
(
Array
.
isArray
(
this
.
_mappings
)
)
{
for
(
const
mapping
of
this
.
_mappings
)
{
if
(
mapping
.
original
.
line
=
=
=
line
&
&
mapping
.
original
.
column
=
=
=
column
)
{
line
=
mapping
.
generated
.
line
;
column
=
mapping
.
generated
.
column
;
continue
;
}
}
}
return
{
line
column
}
;
}
onPropertyChange
:
function
(
property
value
)
{
this
.
emit
(
"
property
-
change
"
property
value
)
;
}
onStyleApplied
:
function
(
)
{
if
(
this
.
_isUpdating
)
{
this
.
_isUpdating
=
false
;
this
.
emit
(
"
style
-
applied
"
)
;
}
else
if
(
this
.
sourceEditor
)
{
this
.
_getSourceTextAndPrettify
(
)
.
then
(
newText
=
>
{
this
.
_justSetText
=
true
;
const
firstLine
=
this
.
sourceEditor
.
getFirstVisibleLine
(
)
;
const
pos
=
this
.
sourceEditor
.
getCursor
(
)
;
this
.
sourceEditor
.
setText
(
newText
)
;
this
.
sourceEditor
.
setFirstVisibleLine
(
firstLine
)
;
this
.
sourceEditor
.
setCursor
(
pos
)
;
this
.
emit
(
"
style
-
applied
"
)
;
}
)
;
}
}
onMediaRulesChanged
:
function
(
rules
)
{
if
(
!
rules
.
length
&
&
!
this
.
mediaRules
.
length
)
{
return
;
}
for
(
const
rule
of
this
.
mediaRules
)
{
rule
.
off
(
"
matches
-
change
"
this
.
emitMediaRulesChanged
)
;
rule
.
destroy
(
)
;
}
this
.
mediaRules
=
rules
;
for
(
const
rule
of
rules
)
{
rule
.
on
(
"
matches
-
change
"
this
.
emitMediaRulesChanged
)
;
}
this
.
emitMediaRulesChanged
(
)
;
}
emitMediaRulesChanged
:
function
(
)
{
this
.
emit
(
"
media
-
rules
-
changed
"
this
.
mediaRules
)
;
}
_onError
:
function
(
data
)
{
this
.
emit
(
"
error
"
data
)
;
}
load
:
function
(
inputElement
cssProperties
)
{
if
(
this
.
_isDestroyed
)
{
return
promise
.
reject
(
"
Won
'
t
load
source
editor
as
the
style
sheet
has
"
+
"
already
been
removed
from
Style
Editor
.
"
)
;
}
this
.
_inputElement
=
inputElement
;
const
config
=
{
value
:
this
.
_state
.
text
lineNumbers
:
true
mode
:
Editor
.
modes
.
css
readOnly
:
false
autoCloseBrackets
:
"
{
}
(
)
"
extraKeys
:
this
.
_getKeyBindings
(
)
contextMenu
:
"
sourceEditorContextMenu
"
autocomplete
:
Services
.
prefs
.
getBoolPref
(
AUTOCOMPLETION_PREF
)
autocompleteOpts
:
{
walker
:
this
.
walker
cssProperties
}
cssProperties
}
;
const
sourceEditor
=
(
this
.
_sourceEditor
=
new
Editor
(
config
)
)
;
sourceEditor
.
on
(
"
dirty
-
change
"
this
.
onPropertyChange
)
;
return
sourceEditor
.
appendTo
(
inputElement
)
.
then
(
(
)
=
>
{
sourceEditor
.
on
(
"
saveRequested
"
this
.
saveToFile
)
;
if
(
this
.
styleSheet
.
update
)
{
sourceEditor
.
on
(
"
change
"
this
.
updateStyleSheet
)
;
}
this
.
sourceEditor
=
sourceEditor
;
if
(
this
.
_focusOnSourceEditorReady
)
{
this
.
_focusOnSourceEditorReady
=
false
;
sourceEditor
.
focus
(
)
;
}
sourceEditor
.
setSelection
(
this
.
_state
.
selection
.
start
this
.
_state
.
selection
.
end
)
;
if
(
this
.
highlighter
&
&
this
.
walker
&
&
sourceEditor
.
container
&
&
sourceEditor
.
container
.
contentWindow
)
{
sourceEditor
.
container
.
contentWindow
.
addEventListener
(
"
mousemove
"
this
.
_onMouseMove
)
;
}
sourceEditor
.
insertCommandsController
(
)
;
this
.
emit
(
"
source
-
editor
-
load
"
)
;
}
)
;
}
getSourceEditor
:
function
(
)
{
const
self
=
this
;
if
(
this
.
sourceEditor
)
{
return
Promise
.
resolve
(
this
)
;
}
return
new
Promise
(
resolve
=
>
{
this
.
on
(
"
source
-
editor
-
load
"
(
)
=
>
{
resolve
(
self
)
;
}
)
;
}
)
;
}
focus
:
function
(
)
{
if
(
this
.
sourceEditor
)
{
this
.
sourceEditor
.
focus
(
)
;
}
else
{
this
.
_focusOnSourceEditorReady
=
true
;
}
}
onShow
:
function
(
)
{
if
(
this
.
sourceEditor
)
{
this
.
sourceEditor
.
refresh
(
)
;
}
this
.
focus
(
)
;
}
async
toggleDisabled
(
)
{
const
styleSheetsFront
=
await
this
.
_getStyleSheetsFront
(
)
;
if
(
styleSheetsFront
.
traits
.
supportResourceRequests
)
{
styleSheetsFront
.
toggleDisabled
(
this
.
resourceId
)
.
catch
(
console
.
error
)
;
}
else
{
this
.
styleSheet
.
toggleDisabled
(
)
.
catch
(
console
.
error
)
;
}
}
updateStyleSheet
:
function
(
)
{
if
(
this
.
_updateTask
)
{
this
.
_window
.
clearTimeout
(
this
.
_updateTask
)
;
}
this
.
_updateTask
=
this
.
_window
.
setTimeout
(
this
.
_updateStyleSheet
UPDATE_STYLESHEET_DELAY
)
;
}
_updateStyleSheet
:
function
(
)
{
if
(
this
.
styleSheet
.
disabled
)
{
return
;
}
if
(
this
.
_justSetText
)
{
this
.
_justSetText
=
false
;
return
;
}
this
.
_updateTask
=
null
;
if
(
this
.
sourceEditor
)
{
this
.
_state
.
text
=
this
.
sourceEditor
.
getText
(
)
;
}
this
.
_isUpdating
=
true
;
this
.
styleSheet
.
update
(
this
.
_state
.
text
this
.
transitionsEnabled
)
.
then
(
(
)
=
>
{
this
.
_mappings
=
null
;
}
)
.
catch
(
console
.
error
)
;
}
_onMouseMove
:
function
(
e
)
{
this
.
highlighter
.
hide
(
)
;
if
(
this
.
mouseMoveTimeout
)
{
this
.
_window
.
clearTimeout
(
this
.
mouseMoveTimeout
)
;
this
.
mouseMoveTimeout
=
null
;
}
this
.
mouseMoveTimeout
=
this
.
_window
.
setTimeout
(
(
)
=
>
{
this
.
_highlightSelectorAt
(
e
.
clientX
e
.
clientY
)
;
}
SELECTOR_HIGHLIGHT_TIMEOUT
)
;
}
async
_highlightSelectorAt
(
x
y
)
{
const
pos
=
this
.
sourceEditor
.
getPositionFromCoords
(
{
left
:
x
top
:
y
}
)
;
const
info
=
this
.
sourceEditor
.
getInfoAt
(
pos
)
;
if
(
!
info
|
|
info
.
state
!
=
=
"
selector
"
)
{
return
;
}
const
node
=
await
this
.
walker
.
getStyleSheetOwnerNode
(
this
.
styleSheet
.
actorID
)
;
await
this
.
highlighter
.
show
(
node
{
selector
:
info
.
selector
hideInfoBar
:
true
showOnly
:
"
border
"
region
:
"
border
"
}
)
;
this
.
emit
(
"
node
-
highlighted
"
)
;
}
saveToFile
:
function
(
file
callback
)
{
const
onFile
=
returnFile
=
>
{
if
(
!
returnFile
)
{
if
(
callback
)
{
callback
(
null
)
;
}
return
;
}
if
(
this
.
sourceEditor
)
{
this
.
_state
.
text
=
this
.
sourceEditor
.
getText
(
)
;
}
const
ostream
=
FileUtils
.
openSafeFileOutputStream
(
returnFile
)
;
const
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
const
istream
=
converter
.
convertToInputStream
(
this
.
_state
.
text
)
;
NetUtil
.
asyncCopy
(
istream
ostream
status
=
>
{
if
(
!
Components
.
isSuccessCode
(
status
)
)
{
if
(
callback
)
{
callback
(
null
)
;
}
this
.
emit
(
"
error
"
{
key
:
SAVE_ERROR
}
)
;
return
;
}
FileUtils
.
closeSafeFileOutputStream
(
ostream
)
;
this
.
onFileSaved
(
returnFile
)
;
if
(
callback
)
{
callback
(
returnFile
)
;
}
}
)
;
}
;
let
defaultName
;
if
(
this
.
_friendlyName
)
{
defaultName
=
OS
.
Path
.
basename
(
this
.
_friendlyName
)
;
}
showFilePicker
(
file
|
|
this
.
_styleSheetFilePath
true
this
.
_window
onFile
defaultName
)
;
}
onFileSaved
:
function
(
returnFile
)
{
this
.
_friendlyName
=
null
;
this
.
savedFile
=
returnFile
;
if
(
this
.
sourceEditor
)
{
this
.
sourceEditor
.
setClean
(
)
;
}
this
.
emit
(
"
property
-
change
"
)
;
this
.
_modCheckCount
=
0
;
this
.
_window
.
clearTimeout
(
this
.
_timeout
)
;
if
(
this
.
linkedCSSFile
&
&
!
this
.
linkedCSSFileError
)
{
this
.
_timeout
=
this
.
_window
.
setTimeout
(
this
.
checkLinkedFileForChanges
CHECK_LINKED_SHEET_DELAY
)
;
}
}
checkLinkedFileForChanges
:
function
(
)
{
OS
.
File
.
stat
(
this
.
linkedCSSFile
)
.
then
(
info
=
>
{
const
lastChange
=
info
.
lastModificationDate
.
getTime
(
)
;
if
(
this
.
_fileModDate
&
&
lastChange
!
=
this
.
_fileModDate
)
{
this
.
_fileModDate
=
lastChange
;
this
.
_modCheckCount
=
0
;
this
.
updateLinkedStyleSheet
(
)
;
return
;
}
if
(
+
+
this
.
_modCheckCount
>
MAX_CHECK_COUNT
)
{
this
.
updateLinkedStyleSheet
(
)
;
return
;
}
this
.
_timeout
=
this
.
_window
.
setTimeout
(
this
.
checkLinkedFileForChanges
CHECK_LINKED_SHEET_DELAY
)
;
}
this
.
markLinkedFileBroken
)
;
}
markLinkedFileBroken
:
function
(
error
)
{
this
.
linkedCSSFileError
=
error
|
|
true
;
this
.
emit
(
"
linked
-
css
-
file
-
error
"
)
;
error
+
=
"
querying
"
+
this
.
linkedCSSFile
+
"
original
source
location
:
"
+
this
.
savedFile
.
path
;
console
.
error
(
error
)
;
}
updateLinkedStyleSheet
:
function
(
)
{
OS
.
File
.
read
(
this
.
linkedCSSFile
)
.
then
(
array
=
>
{
const
decoder
=
new
TextDecoder
(
)
;
const
text
=
decoder
.
decode
(
array
)
;
this
.
_isUpdating
=
true
;
const
relatedSheet
=
this
.
styleSheet
.
relatedStyleSheet
;
relatedSheet
.
update
(
text
this
.
transitionsEnabled
)
;
}
this
.
markLinkedFileBroken
)
;
}
_getKeyBindings
:
function
(
)
{
const
bindings
=
{
}
;
const
keybind
=
Editor
.
accel
(
getString
(
"
saveStyleSheet
.
commandkey
"
)
)
;
bindings
[
keybind
]
=
(
)
=
>
{
this
.
saveToFile
(
this
.
savedFile
)
;
}
;
bindings
[
"
Shift
-
"
+
keybind
]
=
(
)
=
>
{
this
.
saveToFile
(
)
;
}
;
bindings
.
Esc
=
false
;
return
bindings
;
}
_getStyleSheetsFront
(
)
{
return
this
.
_targetList
.
targetFront
.
getFront
(
"
stylesheets
"
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_sourceEditor
)
{
this
.
_sourceEditor
.
off
(
"
dirty
-
change
"
this
.
onPropertyChange
)
;
this
.
_sourceEditor
.
off
(
"
saveRequested
"
this
.
saveToFile
)
;
this
.
_sourceEditor
.
off
(
"
change
"
this
.
updateStyleSheet
)
;
if
(
this
.
highlighter
&
&
this
.
walker
&
&
this
.
_sourceEditor
.
container
&
&
this
.
_sourceEditor
.
container
.
contentWindow
)
{
this
.
_sourceEditor
.
container
.
contentWindow
.
removeEventListener
(
"
mousemove
"
this
.
_onMouseMove
)
;
}
this
.
_sourceEditor
.
destroy
(
)
;
}
this
.
styleSheet
.
off
(
"
error
"
this
.
_onError
)
;
this
.
_isDestroyed
=
true
;
}
}
;
function
findLinkedFilePath
(
uri
origUri
file
)
{
const
{
origBranch
branch
}
=
findUnsharedBranches
(
origUri
uri
)
;
const
project
=
findProjectPath
(
file
origBranch
)
;
const
parts
=
project
.
concat
(
branch
)
;
const
path
=
OS
.
Path
.
join
.
apply
(
this
parts
)
;
return
path
;
}
function
findProjectPath
(
file
branch
)
{
const
path
=
OS
.
Path
.
split
(
file
.
path
)
.
components
;
for
(
let
i
=
2
;
i
<
=
branch
.
length
;
i
+
+
)
{
if
(
path
[
path
.
length
-
i
]
!
=
branch
[
branch
.
length
-
i
]
)
{
return
path
.
slice
(
0
path
.
length
-
i
+
1
)
;
}
}
return
path
.
slice
(
0
path
.
length
-
branch
.
length
)
;
}
function
findUnsharedBranches
(
origUri
uri
)
{
origUri
=
OS
.
Path
.
split
(
origUri
.
pathQueryRef
)
.
components
;
uri
=
OS
.
Path
.
split
(
uri
.
pathQueryRef
)
.
components
;
for
(
let
i
=
0
;
i
<
uri
.
length
-
1
;
i
+
+
)
{
if
(
uri
[
i
]
!
=
origUri
[
i
]
)
{
return
{
branch
:
uri
.
slice
(
i
)
origBranch
:
origUri
.
slice
(
i
)
}
;
}
}
return
{
branch
:
uri
origBranch
:
origUri
}
;
}
function
removeQuery
(
href
)
{
return
href
.
replace
(
/
\
?
.
*
/
"
"
)
;
}
