"
use
strict
"
;
const
{
Cc
Ci
Cu
components
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
client
/
shared
/
l10n
"
)
;
const
REGEX_MATCH_FUNCTION_NAME
=
/
^
\
(
?
function
\
s
+
(
[
^
(
\
s
]
+
)
\
s
*
\
(
/
;
const
CONSOLE_ENTRY_THRESHOLD
=
5
;
const
CONSOLE_WORKER_IDS
=
exports
.
CONSOLE_WORKER_IDS
=
[
"
SharedWorker
"
"
ServiceWorker
"
"
Worker
"
]
;
var
WebConsoleUtils
=
{
supportsString
:
function
(
string
)
{
let
str
=
Cc
[
"
mozilla
.
org
/
supports
-
string
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsString
)
;
str
.
data
=
string
;
return
str
;
}
cloneObject
:
function
(
object
recursive
filter
)
{
if
(
typeof
object
!
=
"
object
"
)
{
return
object
;
}
let
temp
;
if
(
Array
.
isArray
(
object
)
)
{
temp
=
[
]
;
Array
.
forEach
(
object
function
(
value
index
)
{
if
(
!
filter
|
|
filter
(
index
value
object
)
)
{
temp
.
push
(
recursive
?
WebConsoleUtils
.
cloneObject
(
value
)
:
value
)
;
}
}
)
;
}
else
{
temp
=
{
}
;
for
(
let
key
in
object
)
{
let
value
=
object
[
key
]
;
if
(
object
.
hasOwnProperty
(
key
)
&
&
(
!
filter
|
|
filter
(
key
value
object
)
)
)
{
temp
[
key
]
=
recursive
?
WebConsoleUtils
.
cloneObject
(
value
)
:
value
;
}
}
}
return
temp
;
}
copyTextStyles
:
function
(
from
to
)
{
let
win
=
from
.
ownerDocument
.
defaultView
;
let
style
=
win
.
getComputedStyle
(
from
)
;
to
.
style
.
fontFamily
=
style
.
getPropertyCSSValue
(
"
font
-
family
"
)
.
cssText
;
to
.
style
.
fontSize
=
style
.
getPropertyCSSValue
(
"
font
-
size
"
)
.
cssText
;
to
.
style
.
fontWeight
=
style
.
getPropertyCSSValue
(
"
font
-
weight
"
)
.
cssText
;
to
.
style
.
fontStyle
=
style
.
getPropertyCSSValue
(
"
font
-
style
"
)
.
cssText
;
}
createValueGrip
:
function
(
value
objectWrapper
)
{
switch
(
typeof
value
)
{
case
"
boolean
"
:
return
value
;
case
"
string
"
:
return
objectWrapper
(
value
)
;
case
"
number
"
:
if
(
value
=
=
=
Infinity
)
{
return
{
type
:
"
Infinity
"
}
;
}
else
if
(
value
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
Infinity
"
}
;
}
else
if
(
Number
.
isNaN
(
value
)
)
{
return
{
type
:
"
NaN
"
}
;
}
else
if
(
!
value
&
&
1
/
value
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
0
"
}
;
}
return
value
;
case
"
undefined
"
:
return
{
type
:
"
undefined
"
}
;
case
"
object
"
:
if
(
value
=
=
=
null
)
{
return
{
type
:
"
null
"
}
;
}
case
"
function
"
:
return
objectWrapper
(
value
)
;
default
:
console
.
error
(
"
Failed
to
provide
a
grip
for
value
of
"
+
typeof
value
+
"
:
"
+
value
)
;
return
null
;
}
}
isMixedHTTPSRequest
:
function
(
request
location
)
{
try
{
let
requestURI
=
Services
.
io
.
newURI
(
request
null
null
)
;
let
contentURI
=
Services
.
io
.
newURI
(
location
null
null
)
;
return
(
contentURI
.
scheme
=
=
"
https
"
&
&
requestURI
.
scheme
!
=
"
https
"
)
;
}
catch
(
ex
)
{
return
false
;
}
}
getFunctionName
:
function
(
func
)
{
let
name
=
null
;
if
(
func
.
name
)
{
name
=
func
.
name
;
}
else
{
let
desc
;
try
{
desc
=
func
.
getOwnPropertyDescriptor
(
"
displayName
"
)
;
}
catch
(
ex
)
{
}
if
(
desc
&
&
typeof
desc
.
value
=
=
"
string
"
)
{
name
=
desc
.
value
;
}
}
if
(
!
name
)
{
try
{
let
str
=
(
func
.
toString
(
)
|
|
func
.
toSource
(
)
)
+
"
"
;
name
=
(
str
.
match
(
REGEX_MATCH_FUNCTION_NAME
)
|
|
[
]
)
[
1
]
;
}
catch
(
ex
)
{
}
}
return
name
;
}
getObjectClassName
:
function
(
object
)
{
if
(
object
=
=
=
null
)
{
return
"
null
"
;
}
if
(
object
=
=
=
undefined
)
{
return
"
undefined
"
;
}
let
type
=
typeof
object
;
if
(
type
!
=
"
object
"
)
{
return
type
.
charAt
(
0
)
.
toUpperCase
(
)
+
type
.
substr
(
1
)
;
}
let
className
;
try
{
className
=
(
(
object
+
"
"
)
.
match
(
/
^
\
[
object
(
\
S
+
)
\
]
/
)
|
|
[
]
)
[
1
]
;
if
(
!
className
)
{
className
=
(
(
object
.
constructor
+
"
"
)
.
match
(
/
^
\
[
object
(
\
S
+
)
\
]
/
)
|
|
[
]
)
[
1
]
;
}
if
(
!
className
&
&
typeof
object
.
constructor
=
=
"
function
"
)
{
className
=
this
.
getFunctionName
(
object
.
constructor
)
;
}
}
catch
(
ex
)
{
}
return
className
;
}
isActorGrip
:
function
(
grip
)
{
return
grip
&
&
typeof
(
grip
)
=
=
"
object
"
&
&
grip
.
actor
;
}
_usageCount
:
0
get
usageCount
(
)
{
if
(
WebConsoleUtils
.
_usageCount
<
CONSOLE_ENTRY_THRESHOLD
)
{
WebConsoleUtils
.
_usageCount
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
selfxss
.
count
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
{
WebConsoleUtils
.
usageCount
=
CONSOLE_ENTRY_THRESHOLD
;
}
}
return
WebConsoleUtils
.
_usageCount
;
}
set
usageCount
(
newUC
)
{
if
(
newUC
<
=
CONSOLE_ENTRY_THRESHOLD
)
{
WebConsoleUtils
.
_usageCount
=
newUC
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
selfxss
.
count
"
newUC
)
;
}
}
pasteHandlerGen
:
function
(
inputField
notificationBox
msg
okstring
)
{
let
handler
=
function
(
event
)
{
if
(
WebConsoleUtils
.
usageCount
>
=
CONSOLE_ENTRY_THRESHOLD
)
{
inputField
.
removeEventListener
(
"
paste
"
handler
)
;
inputField
.
removeEventListener
(
"
drop
"
handler
)
;
return
true
;
}
if
(
notificationBox
.
getNotificationWithValue
(
"
selfxss
-
notification
"
)
)
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
false
;
}
let
notification
=
notificationBox
.
appendNotification
(
msg
"
selfxss
-
notification
"
null
notificationBox
.
PRIORITY_WARNING_HIGH
null
function
(
eventType
)
{
if
(
eventType
=
=
"
removed
"
)
{
inputField
.
removeEventListener
(
"
keyup
"
pasteKeyUpHandler
)
;
}
}
)
;
function
pasteKeyUpHandler
(
event2
)
{
let
value
=
inputField
.
value
|
|
inputField
.
textContent
;
if
(
value
.
includes
(
okstring
)
)
{
notificationBox
.
removeNotification
(
notification
)
;
inputField
.
removeEventListener
(
"
keyup
"
pasteKeyUpHandler
)
;
WebConsoleUtils
.
usageCount
=
CONSOLE_ENTRY_THRESHOLD
;
}
}
inputField
.
addEventListener
(
"
keyup
"
pasteKeyUpHandler
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
false
;
}
;
return
handler
;
}
}
;
exports
.
Utils
=
WebConsoleUtils
;
WebConsoleUtils
.
L10n
=
function
(
bundleURI
)
{
this
.
_helper
=
new
LocalizationHelper
(
bundleURI
)
;
}
;
WebConsoleUtils
.
L10n
.
prototype
=
{
timestampString
:
function
(
milliseconds
)
{
let
d
=
new
Date
(
milliseconds
?
milliseconds
:
null
)
;
let
hours
=
d
.
getHours
(
)
minutes
=
d
.
getMinutes
(
)
;
let
seconds
=
d
.
getSeconds
(
)
;
milliseconds
=
d
.
getMilliseconds
(
)
;
let
parameters
=
[
hours
minutes
seconds
milliseconds
]
;
return
this
.
getFormatStr
(
"
timestampFormat
"
parameters
)
;
}
getStr
:
function
(
name
)
{
try
{
return
this
.
_helper
.
getStr
(
name
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Failed
to
get
string
:
"
+
name
)
;
throw
ex
;
}
}
getFormatStr
:
function
(
name
array
)
{
try
{
return
this
.
_helper
.
getFormatStr
(
name
.
.
.
array
)
;
}
catch
(
ex
)
{
console
.
error
(
"
Failed
to
format
string
:
"
+
name
)
;
throw
ex
;
}
}
}
;
