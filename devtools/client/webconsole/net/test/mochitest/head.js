"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
webconsole
/
test
/
head
.
js
"
this
)
;
const
FRAME_SCRIPT_UTILS_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
const
NET_INFO_PREF
=
"
devtools
.
webconsole
.
filter
.
networkinfo
"
;
const
NET_XHR_PREF
=
"
devtools
.
webconsole
.
filter
.
netxhr
"
;
Services
.
prefs
.
setBoolPref
(
NET_INFO_PREF
true
)
;
Services
.
prefs
.
setBoolPref
(
NET_XHR_PREF
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
NET_INFO_PREF
true
)
;
Services
.
prefs
.
clearUserPref
(
NET_XHR_PREF
true
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
webconsole
.
new
-
frontend
-
enabled
"
false
)
;
registerCleanupFunction
(
function
*
(
)
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
webconsole
.
new
-
frontend
-
enabled
"
)
;
}
)
;
function
addTestTab
(
url
)
{
info
(
"
Adding
a
new
JSON
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
return
Task
.
spawn
(
function
*
(
)
{
let
tab
=
yield
addTab
(
url
)
;
loadCommonFrameScript
(
tab
)
;
let
hud
=
yield
openConsole
(
)
;
return
{
tab
:
tab
browser
:
tab
.
linkedBrowser
hud
:
hud
}
;
}
)
;
}
function
executeAndInspectXhr
(
hud
options
)
{
hud
.
jsterm
.
clearOutput
(
)
;
options
.
queryString
=
options
.
queryString
|
|
"
"
;
performRequestsInContent
(
{
method
:
options
.
method
url
:
options
.
url
+
options
.
queryString
body
:
options
.
body
nocache
:
options
.
nocache
requestHeaders
:
options
.
requestHeaders
}
)
;
return
Task
.
spawn
(
function
*
(
)
{
let
rules
=
yield
waitForMessages
(
{
webconsole
:
hud
messages
:
[
{
text
:
options
.
url
category
:
CATEGORY_NETWORK
severity
:
SEVERITY_INFO
isXhr
:
true
}
]
}
)
;
let
msg
=
[
.
.
.
rules
[
0
]
.
matched
]
[
0
]
;
let
body
=
msg
.
querySelector
(
"
.
message
-
body
"
)
;
yield
synthesizeMouseClickSoon
(
hud
body
)
;
yield
waitForBackend
(
msg
)
;
let
netInfoBody
=
body
.
querySelector
(
"
.
netInfoBody
"
)
;
ok
(
netInfoBody
"
Net
info
body
must
exist
"
)
;
return
netInfoBody
;
}
)
;
}
function
waitForBackend
(
element
)
{
if
(
!
element
.
hasAttribute
(
"
loading
"
)
)
{
return
;
}
return
once
(
element
"
netlog
-
no
-
pending
-
requests
"
true
)
;
}
function
selectNetInfoTab
(
hud
netInfoBody
tabId
)
{
let
tab
=
netInfoBody
.
querySelector
(
"
.
tabs
-
menu
-
item
.
"
+
tabId
)
;
ok
(
tab
"
Tab
must
exist
"
+
tabId
)
;
return
Task
.
spawn
(
function
*
(
)
{
yield
synthesizeMouseClickSoon
(
hud
tab
)
;
let
msg
=
getAncestorByClass
(
netInfoBody
"
message
"
)
;
yield
waitForBackend
(
msg
)
;
let
tabBody
=
netInfoBody
.
querySelector
(
"
.
"
+
tabId
+
"
TabBox
"
)
;
ok
(
tabBody
"
Tab
body
must
exist
"
)
;
return
tabBody
;
}
)
;
}
function
getAncestorByClass
(
node
className
)
{
for
(
let
parent
=
node
;
parent
;
parent
=
parent
.
parentNode
)
{
if
(
parent
.
classList
&
&
parent
.
classList
.
contains
(
className
)
)
{
return
parent
;
}
}
return
null
;
}
function
synthesizeMouseClickSoon
(
hud
element
)
{
return
new
Promise
(
(
resolve
)
=
>
{
executeSoon
(
(
)
=
>
{
EventUtils
.
synthesizeMouse
(
element
2
2
{
}
hud
.
iframeWindow
)
;
resolve
(
)
;
}
)
;
}
)
;
}
function
performRequestsInContent
(
requests
)
{
info
(
"
Performing
requests
in
the
context
of
the
content
.
"
)
;
return
executeInContent
(
"
devtools
:
test
:
xhr
"
requests
)
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
Promise
.
resolve
(
)
;
}
function
waitForContentMessage
(
name
)
{
info
(
"
Expecting
message
"
+
name
+
"
from
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
return
new
Promise
(
(
resolve
)
=
>
{
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
resolve
(
msg
.
data
)
;
}
)
;
}
)
;
}
function
loadCommonFrameScript
(
tab
)
{
let
browser
=
tab
?
tab
.
linkedBrowser
:
gBrowser
.
selectedBrowser
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_UTILS_URL
false
)
;
}
