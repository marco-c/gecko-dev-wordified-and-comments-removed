"
use
strict
"
;
const
{
Component
createFactory
DOM
PropTypes
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
TreeView
=
createFactory
(
require
(
"
devtools
/
client
/
shared
/
components
/
tree
/
TreeView
"
)
)
;
const
{
REPS
MODE
}
=
require
(
"
devtools
/
client
/
shared
/
components
/
reps
/
reps
"
)
;
const
{
Rep
}
=
REPS
;
const
SizeLimit
=
createFactory
(
require
(
"
.
/
size
-
limit
"
)
)
;
const
NetInfoGroupList
=
createFactory
(
require
(
"
.
/
net
-
info
-
group
-
list
"
)
)
;
const
Spinner
=
createFactory
(
require
(
"
.
/
spinner
"
)
)
;
const
Json
=
require
(
"
.
.
/
utils
/
json
"
)
;
const
NetUtils
=
require
(
"
.
.
/
utils
/
net
"
)
;
class
ResponseTab
extends
Component
{
static
get
propTypes
(
)
{
return
{
data
:
PropTypes
.
shape
(
{
request
:
PropTypes
.
object
.
isRequired
response
:
PropTypes
.
object
.
isRequired
}
)
actions
:
PropTypes
.
object
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
isJson
=
this
.
isJson
.
bind
(
this
)
;
this
.
parseJson
=
this
.
parseJson
.
bind
(
this
)
;
this
.
isImage
=
this
.
isImage
.
bind
(
this
)
;
this
.
isXml
=
this
.
isXml
.
bind
(
this
)
;
this
.
parseXml
=
this
.
parseXml
.
bind
(
this
)
;
this
.
renderJson
=
this
.
renderJson
.
bind
(
this
)
;
this
.
renderImage
=
this
.
renderImage
.
bind
(
this
)
;
this
.
renderXml
=
this
.
renderXml
.
bind
(
this
)
;
this
.
renderFormattedResponse
=
this
.
renderFormattedResponse
.
bind
(
this
)
;
this
.
renderRawResponse
=
this
.
renderRawResponse
.
bind
(
this
)
;
}
isJson
(
content
)
{
if
(
isLongString
(
content
.
text
)
)
{
return
false
;
}
return
Json
.
isJSON
(
content
.
mimeType
content
.
text
)
;
}
parseJson
(
file
)
{
let
content
=
file
.
response
.
content
;
if
(
isLongString
(
content
.
text
)
)
{
return
null
;
}
let
jsonString
=
new
String
(
content
.
text
)
;
return
Json
.
parseJSONString
(
jsonString
)
;
}
isImage
(
content
)
{
if
(
isLongString
(
content
.
text
)
)
{
return
false
;
}
return
NetUtils
.
isImage
(
content
.
mimeType
)
;
}
isXml
(
content
)
{
if
(
isLongString
(
content
.
text
)
)
{
return
false
;
}
return
NetUtils
.
isHTML
(
content
.
mimeType
)
;
}
parseXml
(
file
)
{
let
content
=
file
.
response
.
content
;
if
(
isLongString
(
content
.
text
)
)
{
return
null
;
}
return
NetUtils
.
parseXml
(
content
)
;
}
renderJson
(
file
)
{
let
content
=
file
.
response
.
content
;
if
(
!
this
.
isJson
(
content
)
)
{
return
null
;
}
let
json
=
this
.
parseJson
(
file
)
;
if
(
!
json
)
{
return
null
;
}
return
{
key
:
"
json
"
content
:
TreeView
(
{
columns
:
[
{
id
:
"
value
"
}
]
object
:
json
mode
:
MODE
.
TINY
renderValue
:
props
=
>
Rep
(
Object
.
assign
(
{
}
props
{
cropLimit
:
50
}
)
)
}
)
name
:
Locale
.
STR
(
"
jsonScopeName
"
)
}
;
}
renderImage
(
file
)
{
let
content
=
file
.
response
.
content
;
if
(
!
this
.
isImage
(
content
)
)
{
return
null
;
}
let
dataUri
=
"
data
:
"
+
content
.
mimeType
+
"
;
base64
"
+
content
.
text
;
return
{
key
:
"
image
"
content
:
DOM
.
img
(
{
src
:
dataUri
}
)
name
:
Locale
.
STR
(
"
netRequest
.
image
"
)
}
;
}
renderXml
(
file
)
{
let
content
=
file
.
response
.
content
;
if
(
!
this
.
isXml
(
content
)
)
{
return
null
;
}
let
doc
=
this
.
parseXml
(
file
)
;
if
(
!
doc
)
{
return
null
;
}
return
null
;
}
renderFormattedResponse
(
file
)
{
let
content
=
file
.
response
.
content
;
if
(
typeof
content
.
text
=
=
"
object
"
)
{
return
null
;
}
let
group
=
this
.
renderJson
(
file
)
;
if
(
group
)
{
return
group
;
}
group
=
this
.
renderImage
(
file
)
;
if
(
group
)
{
return
group
;
}
group
=
this
.
renderXml
(
file
)
;
if
(
group
)
{
return
group
;
}
}
renderRawResponse
(
file
)
{
let
group
;
let
content
=
file
.
response
.
content
;
if
(
typeof
content
.
text
=
=
"
object
"
)
{
group
=
{
key
:
"
raw
-
longstring
"
name
:
Locale
.
STR
(
"
netRequest
.
rawData
"
)
content
:
DOM
.
div
(
{
className
:
"
netInfoResponseContent
"
}
content
.
text
.
initial
SizeLimit
(
{
actions
:
this
.
props
.
actions
data
:
content
message
:
Locale
.
STR
(
"
netRequest
.
sizeLimitMessage
"
)
link
:
Locale
.
STR
(
"
netRequest
.
sizeLimitMessageLink
"
)
}
)
)
}
;
}
else
{
group
=
{
key
:
"
raw
"
name
:
Locale
.
STR
(
"
netRequest
.
rawData
"
)
content
:
DOM
.
div
(
{
className
:
"
netInfoResponseContent
"
}
content
.
text
)
}
;
}
return
group
;
}
componentDidMount
(
)
{
let
{
actions
data
:
file
}
=
this
.
props
;
let
content
=
file
.
response
.
content
;
if
(
!
content
|
|
typeof
(
content
.
text
)
=
=
"
undefined
"
)
{
actions
.
requestData
(
"
responseContent
"
)
;
}
}
render
(
)
{
let
{
actions
data
:
file
}
=
this
.
props
;
if
(
file
.
discardResponseBody
)
{
return
DOM
.
span
(
{
className
:
"
netInfoBodiesDiscarded
"
}
Locale
.
STR
(
"
netRequest
.
responseBodyDiscarded
"
)
)
;
}
let
content
=
file
.
response
.
content
;
if
(
!
content
|
|
typeof
(
content
.
text
)
=
=
"
undefined
"
)
{
return
(
Spinner
(
)
)
;
}
let
groups
=
[
]
;
groups
.
push
(
this
.
renderFormattedResponse
(
file
)
)
;
groups
.
push
(
this
.
renderRawResponse
(
file
)
)
;
groups
=
groups
.
filter
(
group
=
>
group
)
;
if
(
groups
.
length
>
1
)
{
groups
[
1
]
.
open
=
false
;
}
return
(
DOM
.
div
(
{
className
:
"
responseTabBox
"
}
DOM
.
div
(
{
className
:
"
panelContent
"
}
NetInfoGroupList
(
{
groups
:
groups
}
)
)
)
)
;
}
}
function
isLongString
(
text
)
{
return
typeof
text
=
=
"
object
"
;
}
module
.
exports
=
ResponseTab
;
