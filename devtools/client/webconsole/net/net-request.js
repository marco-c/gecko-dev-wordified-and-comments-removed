"
use
strict
"
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
parseURLParams
}
=
require
(
"
devtools
/
client
/
shared
/
components
/
reps
/
reps
"
)
;
const
{
cancelEvent
isLeftClick
}
=
require
(
"
.
/
utils
/
events
"
)
;
const
NetInfoBody
=
React
.
createFactory
(
require
(
"
.
/
components
/
net
-
info
-
body
"
)
)
;
const
DataProvider
=
require
(
"
.
/
data
-
provider
"
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
NetRequest
(
log
)
{
this
.
initialize
(
log
)
;
}
NetRequest
.
prototype
=
{
initialize
:
function
(
log
)
{
this
.
client
=
log
.
consoleFrame
.
webConsoleClient
;
this
.
owner
=
log
.
consoleFrame
.
owner
;
this
.
file
=
log
.
response
;
this
.
parentNode
=
log
.
node
;
this
.
file
.
request
.
queryString
=
parseURLParams
(
this
.
file
.
request
.
url
)
;
this
.
hasCookies
=
false
;
this
.
cachedResponses
=
new
Map
(
)
;
let
doc
=
this
.
parentNode
.
ownerDocument
;
let
twisty
=
doc
.
createElementNS
(
XHTML_NS
"
a
"
)
;
twisty
.
className
=
"
theme
-
twisty
"
;
twisty
.
href
=
"
#
"
;
let
messageBody
=
this
.
parentNode
.
querySelector
(
"
.
message
-
body
-
wrapper
"
)
;
this
.
parentNode
.
insertBefore
(
twisty
messageBody
)
;
this
.
parentNode
.
setAttribute
(
"
collapsible
"
true
)
;
this
.
parentNode
.
classList
.
add
(
"
netRequest
"
)
;
this
.
addClickListener
(
)
;
}
addClickListener
:
function
(
)
{
this
.
parentNode
.
addEventListener
(
"
click
"
(
event
)
=
>
{
if
(
!
isLeftClick
(
event
)
)
{
return
;
}
let
classList
=
event
.
originalTarget
.
classList
;
if
(
!
(
classList
.
contains
(
"
theme
-
twisty
"
)
|
|
classList
.
contains
(
"
method
"
)
)
)
{
return
;
}
this
.
onToggleBody
(
event
)
;
cancelEvent
(
event
)
;
}
true
)
;
}
onToggleBody
:
function
(
event
)
{
let
target
=
event
.
currentTarget
;
let
logRow
=
target
.
closest
(
"
.
netRequest
"
)
;
logRow
.
classList
.
toggle
(
"
opened
"
)
;
let
twisty
=
this
.
parentNode
.
querySelector
(
"
.
theme
-
twisty
"
)
;
if
(
logRow
.
classList
.
contains
(
"
opened
"
)
)
{
twisty
.
setAttribute
(
"
open
"
true
)
;
}
else
{
twisty
.
removeAttribute
(
"
open
"
)
;
}
let
isOpen
=
logRow
.
classList
.
contains
(
"
opened
"
)
;
if
(
isOpen
)
{
this
.
renderBody
(
)
;
}
else
{
this
.
closeBody
(
)
;
}
}
updateCookies
:
function
(
method
response
)
{
let
result
;
if
(
response
.
cookies
>
0
&
&
[
"
requestCookies
"
"
responseCookies
"
]
.
includes
(
method
)
)
{
this
.
hasCookies
=
true
;
this
.
refresh
(
)
;
}
}
updateBody
:
function
(
response
)
{
let
method
=
response
.
updateType
;
this
.
updateCookies
(
method
response
)
;
if
(
this
.
cachedResponses
.
get
(
method
)
)
{
this
.
cachedResponses
.
delete
(
method
)
;
this
.
requestData
(
method
)
;
}
}
closeBody
:
function
(
)
{
this
.
netInfoBodyBox
.
remove
(
)
;
}
renderBody
:
function
(
)
{
let
messageBody
=
this
.
parentNode
.
querySelector
(
"
.
message
-
body
-
wrapper
"
)
;
let
doc
=
messageBody
.
ownerDocument
;
this
.
netInfoBodyBox
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
this
.
netInfoBodyBox
.
classList
.
add
(
"
netInfoBody
"
)
;
messageBody
.
appendChild
(
this
.
netInfoBodyBox
)
;
let
body
=
NetInfoBody
(
{
actions
:
this
}
)
;
this
.
body
=
ReactDOM
.
render
(
body
this
.
netInfoBodyBox
)
;
this
.
refresh
(
)
;
}
refresh
:
function
(
)
{
if
(
!
this
.
netInfoBodyBox
)
{
return
;
}
let
newState
=
Object
.
assign
(
{
}
this
.
body
.
state
{
data
:
this
.
file
hasCookies
:
this
.
hasCookies
}
)
;
this
.
body
.
setState
(
newState
)
;
}
requestData
:
function
(
method
)
{
let
response
=
this
.
cachedResponses
.
get
(
method
)
;
if
(
response
)
{
return
;
}
this
.
parentNode
.
setAttribute
(
"
loading
"
"
true
"
)
;
let
actor
=
this
.
file
.
actor
;
DataProvider
.
requestData
(
this
.
client
actor
method
)
.
then
(
args
=
>
{
this
.
cachedResponses
.
set
(
method
args
)
;
this
.
onRequestData
(
method
args
)
;
if
(
!
DataProvider
.
hasPendingRequests
(
)
)
{
this
.
parentNode
.
removeAttribute
(
"
loading
"
)
;
setTimeout
(
(
)
=
>
{
let
event
=
document
.
createEvent
(
"
Event
"
)
;
event
.
initEvent
(
"
netlog
-
no
-
pending
-
requests
"
true
true
)
;
this
.
parentNode
.
dispatchEvent
(
event
)
;
}
)
;
}
}
)
;
}
onRequestData
:
function
(
method
response
)
{
let
result
;
switch
(
method
)
{
case
"
requestHeaders
"
:
result
=
this
.
onRequestHeaders
(
response
)
;
break
;
case
"
responseHeaders
"
:
result
=
this
.
onResponseHeaders
(
response
)
;
break
;
case
"
requestCookies
"
:
result
=
this
.
onRequestCookies
(
response
)
;
break
;
case
"
responseCookies
"
:
result
=
this
.
onResponseCookies
(
response
)
;
break
;
case
"
responseContent
"
:
result
=
this
.
onResponseContent
(
response
)
;
break
;
case
"
requestPostData
"
:
result
=
this
.
onRequestPostData
(
response
)
;
break
;
}
result
.
then
(
(
)
=
>
{
this
.
refresh
(
)
;
}
)
;
}
onRequestHeaders
:
function
(
response
)
{
this
.
file
.
request
.
headers
=
response
.
headers
;
return
this
.
resolveHeaders
(
this
.
file
.
request
.
headers
)
;
}
onResponseHeaders
:
function
(
response
)
{
this
.
file
.
response
.
headers
=
response
.
headers
;
return
this
.
resolveHeaders
(
this
.
file
.
response
.
headers
)
;
}
onResponseContent
:
function
(
response
)
{
let
content
=
response
.
content
;
for
(
let
p
in
content
)
{
this
.
file
.
response
.
content
[
p
]
=
content
[
p
]
;
}
return
Promise
.
resolve
(
)
;
}
onRequestPostData
:
function
(
response
)
{
this
.
file
.
request
.
postData
=
response
.
postData
;
return
Promise
.
resolve
(
)
;
}
onRequestCookies
:
function
(
response
)
{
this
.
file
.
request
.
cookies
=
response
.
cookies
;
return
this
.
resolveHeaders
(
this
.
file
.
request
.
cookies
)
;
}
onResponseCookies
:
function
(
response
)
{
this
.
file
.
response
.
cookies
=
response
.
cookies
;
return
this
.
resolveHeaders
(
this
.
file
.
response
.
cookies
)
;
}
onViewSourceInDebugger
:
function
(
frame
)
{
this
.
owner
.
viewSourceInDebugger
(
frame
.
source
frame
.
line
)
;
}
resolveHeaders
:
function
(
headers
)
{
let
promises
=
[
]
;
for
(
let
header
of
headers
)
{
if
(
typeof
header
.
value
=
=
"
object
"
)
{
promises
.
push
(
this
.
resolveString
(
header
.
value
)
.
then
(
value
=
>
{
header
.
value
=
value
;
}
)
)
;
}
}
return
Promise
.
all
(
promises
)
;
}
resolveString
:
function
(
object
propName
)
{
let
stringGrip
=
object
[
propName
]
;
if
(
typeof
stringGrip
=
=
"
object
"
)
{
DataProvider
.
resolveString
(
this
.
client
stringGrip
)
.
then
(
args
=
>
{
object
[
propName
]
=
args
;
this
.
refresh
(
)
;
}
)
;
}
}
}
;
module
.
exports
=
NetRequest
;
