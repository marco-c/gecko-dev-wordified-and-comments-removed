"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
WebConsoleConnectionProxy
}
=
require
(
"
devtools
/
client
/
webconsole
/
webconsole
-
connection
-
proxy
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
l10n
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
)
;
loader
.
lazyRequireGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
true
)
;
const
ZoomKeys
=
require
(
"
devtools
/
client
/
shared
/
zoom
-
keys
"
)
;
const
PREF_MESSAGE_TIMESTAMP
=
"
devtools
.
webconsole
.
timestampMessages
"
;
const
PREF_PERSISTLOG
=
"
devtools
.
webconsole
.
persistlog
"
;
const
PREF_SIDEBAR_ENABLED
=
"
devtools
.
webconsole
.
sidebarToggle
"
;
function
NewWebConsoleFrame
(
webConsoleOwner
)
{
this
.
owner
=
webConsoleOwner
;
this
.
hudId
=
this
.
owner
.
hudId
;
this
.
isBrowserConsole
=
this
.
owner
.
_browserConsole
;
this
.
window
=
this
.
owner
.
iframeWindow
;
this
.
_onToolboxPrefChanged
=
this
.
_onToolboxPrefChanged
.
bind
(
this
)
;
this
.
_onPanelSelected
=
this
.
_onPanelSelected
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
NewWebConsoleFrame
.
prototype
=
{
get
webConsoleClient
(
)
{
return
this
.
proxy
?
this
.
proxy
.
webConsoleClient
:
null
;
}
get
persistLog
(
)
{
return
this
.
isBrowserConsole
|
|
Services
.
prefs
.
getBoolPref
(
PREF_PERSISTLOG
)
;
}
async
init
(
)
{
this
.
_initUI
(
)
;
await
this
.
_initConnection
(
)
;
await
this
.
newConsoleOutput
.
init
(
)
;
let
id
=
WebConsoleUtils
.
supportsString
(
this
.
hudId
)
;
if
(
Services
.
obs
)
{
Services
.
obs
.
notifyObservers
(
id
"
web
-
console
-
created
"
)
;
}
}
destroy
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
.
promise
;
}
this
.
_destroyer
=
defer
(
)
;
Services
.
prefs
.
removeObserver
(
PREF_MESSAGE_TIMESTAMP
this
.
_onToolboxPrefChanged
)
;
this
.
React
=
this
.
ReactDOM
=
this
.
FrameView
=
null
;
if
(
this
.
jsterm
)
{
this
.
jsterm
.
destroy
(
)
;
this
.
jsterm
=
null
;
}
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
if
(
toolbox
)
{
toolbox
.
off
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
}
this
.
window
=
this
.
owner
=
this
.
newConsoleOutput
=
null
;
let
onDestroy
=
(
)
=
>
{
this
.
_destroyer
.
resolve
(
null
)
;
}
;
if
(
this
.
proxy
)
{
this
.
proxy
.
disconnect
(
)
.
then
(
onDestroy
)
;
this
.
proxy
=
null
;
}
else
{
onDestroy
(
)
;
}
return
this
.
_destroyer
.
promise
;
}
_onUpdateListeners
(
)
{
}
logWarningAboutReplacedAPI
(
)
{
this
.
owner
.
target
.
logWarningInPage
(
l10n
.
getStr
(
"
ConsoleAPIDisabled
"
)
"
ConsoleAPIDisabled
"
)
;
}
handleNetworkEventUpdate
(
)
{
}
setSaveRequestAndResponseBodies
(
value
)
{
if
(
!
this
.
webConsoleClient
)
{
return
promise
.
resolve
(
null
)
;
}
let
deferred
=
defer
(
)
;
let
newValue
=
!
!
value
;
let
toSet
=
{
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
:
newValue
}
;
this
.
webConsoleClient
.
setPreferences
(
toSet
response
=
>
{
if
(
!
response
.
error
)
{
this
.
_saveRequestAndResponseBodies
=
newValue
;
deferred
.
resolve
(
response
)
;
}
else
{
deferred
.
reject
(
response
.
error
)
;
}
}
)
;
return
deferred
.
promise
;
}
_initConnection
:
function
(
)
{
if
(
this
.
_initDefer
)
{
return
this
.
_initDefer
.
promise
;
}
this
.
_initDefer
=
defer
(
)
;
this
.
proxy
=
new
WebConsoleConnectionProxy
(
this
this
.
owner
.
target
)
;
this
.
proxy
.
connect
(
)
.
then
(
(
)
=
>
{
this
.
_initDefer
.
resolve
(
this
)
;
}
(
reason
)
=
>
{
this
.
_initDefer
.
reject
(
reason
)
;
}
)
;
return
this
.
_initDefer
.
promise
;
}
_initUI
:
function
(
)
{
this
.
document
=
this
.
window
.
document
;
this
.
rootElement
=
this
.
document
.
documentElement
;
this
.
outputNode
=
this
.
document
.
getElementById
(
"
output
-
container
"
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
let
Wrapper
=
this
.
owner
.
NewConsoleOutputWrapper
|
|
this
.
window
.
NewConsoleOutput
;
this
.
newConsoleOutput
=
new
Wrapper
(
this
.
outputNode
this
toolbox
this
.
owner
this
.
document
)
;
Services
.
prefs
.
addObserver
(
PREF_MESSAGE_TIMESTAMP
this
.
_onToolboxPrefChanged
)
;
this
.
_onToolboxPrefChanged
(
)
;
this
.
_initShortcuts
(
)
;
if
(
toolbox
)
{
toolbox
.
on
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
}
}
_initShortcuts
:
function
(
)
{
let
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
window
}
)
;
shortcuts
.
on
(
l10n
.
getStr
(
"
webconsole
.
find
.
key
"
)
event
=
>
{
this
.
filterBox
.
focus
(
)
;
event
.
preventDefault
(
)
;
}
)
;
let
clearShortcut
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
clearShortcut
=
l10n
.
getStr
(
"
webconsole
.
clear
.
keyOSX
"
)
;
}
else
{
clearShortcut
=
l10n
.
getStr
(
"
webconsole
.
clear
.
key
"
)
;
}
shortcuts
.
on
(
clearShortcut
(
)
=
>
this
.
jsterm
.
clearOutput
(
true
)
)
;
if
(
this
.
isBrowserConsole
)
{
shortcuts
.
on
(
l10n
.
getStr
(
"
webconsole
.
close
.
key
"
)
this
.
window
.
top
.
close
.
bind
(
this
.
window
.
top
)
)
;
ZoomKeys
.
register
(
this
.
window
)
;
shortcuts
.
on
(
"
CmdOrCtrl
+
Alt
+
R
"
quickRestart
)
;
}
else
if
(
Services
.
prefs
.
getBoolPref
(
PREF_SIDEBAR_ENABLED
)
)
{
shortcuts
.
on
(
"
Esc
"
event
=
>
{
if
(
!
this
.
jsterm
.
autocompletePopup
|
|
!
this
.
jsterm
.
autocompletePopup
.
isOpen
)
{
this
.
newConsoleOutput
.
dispatchSidebarClose
(
)
;
this
.
jsterm
.
focus
(
)
;
}
}
)
;
}
}
onLocationChange
:
function
(
uri
title
)
{
this
.
contentLocation
=
uri
;
if
(
this
.
owner
.
onLocationChange
)
{
this
.
owner
.
onLocationChange
(
uri
title
)
;
}
}
_releaseObject
:
function
(
actor
)
{
if
(
this
.
proxy
)
{
this
.
proxy
.
releaseActor
(
actor
)
;
}
}
_onToolboxPrefChanged
:
function
(
)
{
let
newValue
=
Services
.
prefs
.
getBoolPref
(
PREF_MESSAGE_TIMESTAMP
)
;
this
.
newConsoleOutput
.
dispatchTimestampsToggle
(
newValue
)
;
}
_onPanelSelected
:
function
(
)
{
this
.
jsterm
.
focus
(
)
;
}
handleTabNavigated
:
async
function
(
packet
)
{
if
(
packet
.
url
)
{
this
.
onLocationChange
(
packet
.
url
packet
.
title
)
;
}
if
(
!
packet
.
nativeConsoleAPI
)
{
this
.
logWarningAboutReplacedAPI
(
)
;
}
await
this
.
newConsoleOutput
.
waitAsyncDispatches
(
)
;
this
.
emit
(
"
reloaded
"
)
;
}
handleTabWillNavigate
:
function
(
packet
)
{
if
(
this
.
persistLog
)
{
packet
.
_type
=
true
;
this
.
newConsoleOutput
.
dispatchMessageAdd
(
packet
)
;
}
else
{
this
.
jsterm
.
clearOutput
(
false
)
;
}
if
(
packet
.
url
)
{
this
.
onLocationChange
(
packet
.
url
packet
.
title
)
;
}
}
}
;
function
quickRestart
(
)
{
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
let
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
env
.
set
(
"
MOZ_DISABLE_SAFE_MODE_KEY
"
"
1
"
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
}
exports
.
NewWebConsoleFrame
=
NewWebConsoleFrame
;
