"
use
strict
"
;
const
{
createElement
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
Provider
createProvider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
actions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
const
{
configureStore
}
=
require
(
"
devtools
/
client
/
webconsole
/
store
"
)
;
const
{
isPacketPrivate
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
)
;
const
{
getMutableMessagesById
getMessage
getAllNetworkMessagesUpdateById
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
messages
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
App
=
createFactory
(
require
(
"
devtools
/
client
/
webconsole
/
components
/
App
"
)
)
;
loader
.
lazyGetter
(
this
"
AppErrorBoundary
"
(
)
=
>
createFactory
(
require
(
"
devtools
/
client
/
shared
/
components
/
AppErrorBoundary
"
)
)
)
;
const
{
setupServiceContainer
}
=
require
(
"
devtools
/
client
/
webconsole
/
service
-
container
"
)
;
loader
.
lazyRequireGetter
(
this
"
Constants
"
"
devtools
/
client
/
webconsole
/
constants
"
)
;
loader
.
lazyGetter
(
this
"
L10N
"
function
(
)
{
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
return
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
startup
.
properties
"
)
;
}
)
;
loader
.
lazyRequireGetter
(
this
"
FluentL10n
"
"
devtools
/
client
/
shared
/
fluent
-
l10n
/
fluent
-
l10n
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
LocalizationProvider
"
"
devtools
/
client
/
shared
/
vendor
/
fluent
-
react
"
true
)
;
let
store
=
null
;
class
WebConsoleWrapper
{
constructor
(
parentNode
webConsoleUI
toolbox
document
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
parentNode
=
parentNode
;
this
.
webConsoleUI
=
webConsoleUI
;
this
.
toolbox
=
toolbox
;
this
.
hud
=
this
.
webConsoleUI
.
hud
;
this
.
document
=
document
;
this
.
init
=
this
.
init
.
bind
(
this
)
;
this
.
queuedMessageAdds
=
[
]
;
this
.
queuedMessageUpdates
=
[
]
;
this
.
queuedRequestUpdates
=
[
]
;
this
.
throttledDispatchPromise
=
null
;
this
.
telemetry
=
new
Telemetry
(
)
;
}
#
serviceContainer
;
async
init
(
)
{
const
{
webConsoleUI
}
=
this
;
let
fluentBundles
;
if
(
webConsoleUI
.
isBrowserConsole
)
{
const
fluentL10n
=
new
FluentL10n
(
)
;
await
fluentL10n
.
init
(
[
"
devtools
/
client
/
toolbox
.
ftl
"
]
)
;
fluentBundles
=
fluentL10n
.
getBundles
(
)
;
}
return
new
Promise
(
resolve
=
>
{
store
=
configureStore
(
this
.
webConsoleUI
{
telemetry
:
this
.
telemetry
thunkArgs
:
{
webConsoleUI
hud
:
this
.
hud
toolbox
:
this
.
toolbox
commands
:
this
.
hud
.
commands
}
}
)
;
const
app
=
AppErrorBoundary
(
{
componentName
:
"
Console
"
panel
:
L10N
.
getStr
(
"
ToolboxTabWebconsole
.
label
"
)
}
App
(
{
serviceContainer
:
this
.
getServiceContainer
(
)
webConsoleUI
onFirstMeaningfulPaint
:
resolve
closeSplitConsole
:
this
.
closeSplitConsole
.
bind
(
this
)
inputEnabled
:
!
webConsoleUI
.
isBrowserConsole
|
|
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
}
)
)
;
if
(
this
.
parentNode
)
{
const
maybeLocalizedElement
=
fluentBundles
?
createElement
(
LocalizationProvider
{
bundles
:
fluentBundles
}
app
)
:
app
;
this
.
body
=
ReactDOM
.
render
(
createElement
(
Provider
{
store
}
createElement
(
createProvider
(
this
.
hud
.
commands
.
targetCommand
.
storeId
)
{
store
:
this
.
hud
.
commands
.
targetCommand
.
store
}
maybeLocalizedElement
)
)
this
.
parentNode
)
;
}
else
{
resolve
(
)
;
}
}
)
;
}
destroy
(
)
{
if
(
this
.
parentNode
)
{
ReactDOM
.
unmountComponentAtNode
(
this
.
parentNode
)
;
}
}
dispatchMessageAdd
(
packet
)
{
this
.
batchedMessagesAdd
(
[
packet
]
)
;
}
dispatchMessagesAdd
(
messages
)
{
this
.
batchedMessagesAdd
(
messages
)
;
}
dispatchNetworkMessagesDisable
(
)
{
const
networkMessageIds
=
Object
.
keys
(
getAllNetworkMessagesUpdateById
(
store
.
getState
(
)
)
)
;
store
.
dispatch
(
actions
.
messagesDisable
(
networkMessageIds
)
)
;
}
dispatchMessagesClear
(
)
{
function
filter
(
l
)
{
return
l
.
filter
(
update
=
>
update
.
isNavigationRequest
)
;
}
this
.
queuedMessageAdds
=
filter
(
this
.
queuedMessageAdds
)
;
this
.
queuedMessageUpdates
=
filter
(
this
.
queuedMessageUpdates
)
;
this
.
queuedRequestUpdates
=
this
.
queuedRequestUpdates
.
filter
(
update
=
>
update
.
data
.
isNavigationRequest
)
;
store
?
.
dispatch
(
actions
.
messagesClear
(
)
)
;
this
.
webConsoleUI
.
emitForTests
(
"
messages
-
cleared
"
)
;
}
dispatchPrivateMessagesClear
(
)
{
const
messages
=
[
.
.
.
getMutableMessagesById
(
store
.
getState
(
)
)
.
values
(
)
]
;
this
.
queuedMessageUpdates
=
this
.
queuedMessageUpdates
.
filter
(
(
{
actor
}
)
=
>
{
const
queuedNetworkMessage
=
this
.
queuedMessageAdds
.
find
(
p
=
>
p
.
actor
=
=
=
actor
)
;
if
(
queuedNetworkMessage
&
&
isPacketPrivate
(
queuedNetworkMessage
)
)
{
return
false
;
}
const
requestMessage
=
messages
.
find
(
message
=
>
actor
=
=
=
message
.
actor
)
;
if
(
requestMessage
&
&
requestMessage
.
private
=
=
=
true
)
{
return
false
;
}
return
true
;
}
)
;
this
.
queuedRequestUpdates
=
this
.
queuedRequestUpdates
.
filter
(
(
{
id
}
)
=
>
{
const
requestMessage
=
getMessage
(
store
.
getState
(
)
id
)
;
if
(
requestMessage
&
&
requestMessage
.
private
=
=
=
true
)
{
return
false
;
}
return
true
;
}
)
;
this
.
queuedMessageAdds
=
this
.
queuedMessageAdds
.
filter
(
p
=
>
!
isPacketPrivate
(
p
)
)
;
store
.
dispatch
(
actions
.
privateMessagesClear
(
)
)
;
}
dispatchTargetMessagesRemove
(
targetFront
)
{
for
(
let
i
=
this
.
queuedMessageUpdates
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
packet
=
this
.
queuedMessageUpdates
[
i
]
;
if
(
packet
.
targetFront
=
=
targetFront
)
{
this
.
queuedMessageUpdates
.
splice
(
i
1
)
;
}
}
for
(
let
i
=
this
.
queuedRequestUpdates
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
packet
=
this
.
queuedRequestUpdates
[
i
]
;
if
(
packet
.
data
.
targetFront
=
=
targetFront
)
{
this
.
queuedRequestUpdates
.
splice
(
i
1
)
;
}
}
for
(
let
i
=
this
.
queuedMessageAdds
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
packet
=
this
.
queuedMessageAdds
[
i
]
;
if
(
packet
.
targetFront
=
=
targetFront
&
&
packet
.
type
!
=
=
Constants
.
MESSAGE_TYPE
.
COMMAND
&
&
packet
.
type
!
=
=
Constants
.
MESSAGE_TYPE
.
RESULT
)
{
this
.
queuedMessageAdds
.
splice
(
i
1
)
;
}
}
store
.
dispatch
(
actions
.
targetMessagesRemove
(
targetFront
)
)
;
}
dispatchMessagesUpdate
(
messages
)
{
this
.
batchedMessagesUpdates
(
messages
)
;
}
dispatchSidebarClose
(
)
{
store
.
dispatch
(
actions
.
sidebarClose
(
)
)
;
}
dispatchSplitConsoleCloseButtonToggle
(
)
{
store
.
dispatch
(
actions
.
splitConsoleCloseButtonToggle
(
this
.
toolbox
&
&
this
.
toolbox
.
currentToolId
!
=
=
"
webconsole
"
)
)
;
}
dispatchTabWillNavigate
(
packet
)
{
const
{
ui
}
=
store
.
getState
(
)
;
if
(
ui
.
persistLogs
|
|
this
.
webConsoleUI
.
isBrowserConsole
)
{
packet
.
type
=
"
will
-
navigate
"
;
this
.
dispatchMessageAdd
(
packet
)
;
}
else
{
this
.
dispatchMessagesClear
(
)
;
store
.
dispatch
(
{
type
:
Constants
.
WILL_NAVIGATE
}
)
;
}
}
batchedMessagesUpdates
(
messages
)
{
if
(
messages
.
length
)
{
this
.
queuedMessageUpdates
.
push
(
.
.
.
messages
)
;
this
.
setTimeoutIfNeeded
(
)
;
}
}
batchedRequestUpdates
(
message
)
{
this
.
queuedRequestUpdates
.
push
(
message
)
;
return
this
.
setTimeoutIfNeeded
(
)
;
}
batchedMessagesAdd
(
messages
)
{
if
(
messages
.
length
)
{
this
.
queuedMessageAdds
.
push
(
.
.
.
messages
)
;
this
.
setTimeoutIfNeeded
(
)
;
}
}
dispatchClearHistory
(
)
{
store
.
dispatch
(
actions
.
clearHistory
(
)
)
;
}
dispatchEvaluateExpression
(
expression
)
{
store
.
dispatch
(
actions
.
evaluateExpression
(
expression
)
)
;
}
dispatchUpdateInstantEvaluationResultForCurrentExpression
(
)
{
store
.
dispatch
(
actions
.
updateInstantEvaluationResultForCurrentExpression
(
)
)
;
}
waitAsyncDispatches
(
)
{
if
(
!
this
.
throttledDispatchPromise
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
throttledDispatchPromise
;
}
setTimeoutIfNeeded
(
)
{
if
(
this
.
throttledDispatchPromise
)
{
return
this
.
throttledDispatchPromise
;
}
this
.
throttledDispatchPromise
=
new
Promise
(
done
=
>
{
setTimeout
(
async
(
)
=
>
{
this
.
throttledDispatchPromise
=
null
;
if
(
!
store
)
{
this
.
setTimeoutIfNeeded
(
)
;
return
;
}
store
.
dispatch
(
actions
.
messagesAdd
(
this
.
queuedMessageAdds
)
)
;
const
{
length
}
=
this
.
queuedMessageAdds
;
if
(
this
.
toolbox
)
{
this
.
telemetry
.
addEventProperty
(
this
.
toolbox
"
enter
"
"
webconsole
"
null
"
message_count
"
length
)
;
}
this
.
queuedMessageAdds
=
[
]
;
if
(
this
.
queuedMessageUpdates
.
length
)
{
await
store
.
dispatch
(
actions
.
networkMessageUpdates
(
this
.
queuedMessageUpdates
null
)
)
;
this
.
webConsoleUI
.
emitForTests
(
"
network
-
messages
-
updated
"
)
;
this
.
queuedMessageUpdates
=
[
]
;
}
if
(
this
.
queuedRequestUpdates
.
length
)
{
await
store
.
dispatch
(
actions
.
networkUpdateRequests
(
this
.
queuedRequestUpdates
)
)
;
const
updateCount
=
this
.
queuedRequestUpdates
.
length
;
this
.
queuedRequestUpdates
=
[
]
;
this
.
webConsoleUI
.
emitForTests
(
"
network
-
request
-
payload
-
ready
"
updateCount
)
;
}
done
(
)
;
}
50
)
;
}
)
;
return
this
.
throttledDispatchPromise
;
}
getStore
(
)
{
return
store
;
}
getServiceContainer
(
)
{
if
(
!
this
.
#
serviceContainer
)
{
this
.
#
serviceContainer
=
setupServiceContainer
(
{
webConsoleUI
:
this
.
webConsoleUI
toolbox
:
this
.
toolbox
hud
:
this
.
hud
webConsoleWrapper
:
this
}
)
;
}
return
this
.
#
serviceContainer
;
}
subscribeToStore
(
callback
)
{
store
.
subscribe
(
(
)
=
>
callback
(
store
.
getState
(
)
)
)
;
}
createElement
(
nodename
)
{
return
this
.
document
.
createElement
(
nodename
)
;
}
closeSplitConsole
(
)
{
this
.
toolbox
.
closeSplitConsole
(
)
;
}
}
module
.
exports
=
WebConsoleWrapper
;
