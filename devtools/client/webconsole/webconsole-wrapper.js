"
use
strict
"
;
const
{
createElement
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
actions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
const
{
configureStore
}
=
require
(
"
devtools
/
client
/
webconsole
/
store
"
)
;
const
{
isPacketPrivate
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
)
;
const
{
getAllMessagesById
getMessage
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
messages
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
App
=
createFactory
(
require
(
"
devtools
/
client
/
webconsole
/
components
/
App
"
)
)
;
const
DataProvider
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
connector
/
firefox
-
data
-
provider
"
)
;
const
{
setupServiceContainer
}
=
require
(
"
devtools
/
client
/
webconsole
/
service
-
container
"
)
;
loader
.
lazyRequireGetter
(
this
"
Constants
"
"
devtools
/
client
/
webconsole
/
constants
"
)
;
let
store
=
null
;
class
WebConsoleWrapper
{
constructor
(
parentNode
webConsoleUI
toolbox
document
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
parentNode
=
parentNode
;
this
.
webConsoleUI
=
webConsoleUI
;
this
.
toolbox
=
toolbox
;
this
.
hud
=
this
.
webConsoleUI
.
hud
;
this
.
document
=
document
;
this
.
init
=
this
.
init
.
bind
(
this
)
;
this
.
dispatchPaused
=
this
.
dispatchPaused
.
bind
(
this
)
;
this
.
dispatchProgress
=
this
.
dispatchProgress
.
bind
(
this
)
;
this
.
queuedMessageAdds
=
[
]
;
this
.
queuedMessageUpdates
=
[
]
;
this
.
queuedRequestUpdates
=
[
]
;
this
.
throttledDispatchPromise
=
null
;
this
.
telemetry
=
new
Telemetry
(
)
;
}
async
init
(
)
{
const
{
webConsoleUI
}
=
this
;
const
webConsoleFront
=
await
this
.
hud
.
currentTarget
.
getFront
(
"
console
"
)
;
this
.
networkDataProvider
=
new
DataProvider
(
{
actions
:
{
updateRequest
:
(
id
data
)
=
>
this
.
batchedRequestUpdates
(
{
id
data
}
)
}
webConsoleFront
}
)
;
return
new
Promise
(
resolve
=
>
{
store
=
configureStore
(
this
.
webConsoleUI
{
sessionId
:
(
this
.
toolbox
&
&
this
.
toolbox
.
sessionId
)
|
|
-
1
telemetry
:
this
.
telemetry
thunkArgs
:
{
webConsoleUI
hud
:
this
.
hud
client
:
this
.
webConsoleUI
.
_commands
}
}
)
;
const
serviceContainer
=
setupServiceContainer
(
{
webConsoleUI
toolbox
:
this
.
toolbox
hud
:
this
.
hud
webConsoleWrapper
:
this
}
)
;
if
(
this
.
toolbox
)
{
this
.
toolbox
.
threadFront
.
on
(
"
paused
"
this
.
dispatchPaused
)
;
this
.
toolbox
.
threadFront
.
on
(
"
progress
"
this
.
dispatchProgress
)
;
}
const
app
=
App
(
{
serviceContainer
webConsoleUI
onFirstMeaningfulPaint
:
resolve
closeSplitConsole
:
this
.
closeSplitConsole
.
bind
(
this
)
hidePersistLogsCheckbox
:
webConsoleUI
.
isBrowserConsole
|
|
webConsoleUI
.
isBrowserToolboxConsole
hideShowContentMessagesCheckbox
:
!
webConsoleUI
.
isBrowserConsole
&
&
!
webConsoleUI
.
isBrowserToolboxConsole
}
)
;
if
(
this
.
parentNode
)
{
const
provider
=
createElement
(
Provider
{
store
}
app
)
;
this
.
body
=
ReactDOM
.
render
(
provider
this
.
parentNode
)
;
}
else
{
resolve
(
)
;
}
}
)
;
}
dispatchMessageAdd
(
packet
)
{
this
.
batchedMessagesAdd
(
[
packet
]
)
;
}
dispatchMessagesAdd
(
messages
)
{
this
.
batchedMessagesAdd
(
messages
)
;
}
dispatchMessagesClear
(
)
{
this
.
queuedMessageAdds
=
[
]
;
this
.
queuedMessageUpdates
=
[
]
;
this
.
queuedRequestUpdates
=
[
]
;
store
.
dispatch
(
actions
.
messagesClear
(
)
)
;
this
.
webConsoleUI
.
emitForTests
(
"
messages
-
cleared
"
)
;
}
dispatchPrivateMessagesClear
(
)
{
const
messages
=
[
.
.
.
getAllMessagesById
(
store
.
getState
(
)
)
.
values
(
)
]
;
this
.
queuedMessageUpdates
=
this
.
queuedMessageUpdates
.
filter
(
(
{
networkInfo
}
)
=
>
{
const
{
actor
}
=
networkInfo
;
const
queuedNetworkMessage
=
this
.
queuedMessageAdds
.
find
(
p
=
>
p
.
actor
=
=
=
actor
)
;
if
(
queuedNetworkMessage
&
&
isPacketPrivate
(
queuedNetworkMessage
)
)
{
return
false
;
}
const
requestMessage
=
messages
.
find
(
message
=
>
actor
=
=
=
message
.
actor
)
;
if
(
requestMessage
&
&
requestMessage
.
private
=
=
=
true
)
{
return
false
;
}
return
true
;
}
)
;
this
.
queuedRequestUpdates
=
this
.
queuedRequestUpdates
.
filter
(
(
{
id
}
)
=
>
{
const
requestMessage
=
getMessage
(
store
.
getState
(
)
id
)
;
if
(
requestMessage
&
&
requestMessage
.
private
=
=
=
true
)
{
return
false
;
}
return
true
;
}
)
;
this
.
queuedMessageAdds
=
this
.
queuedMessageAdds
.
filter
(
p
=
>
!
isPacketPrivate
(
p
)
)
;
store
.
dispatch
(
actions
.
privateMessagesClear
(
)
)
;
}
dispatchPaused
(
packet
)
{
if
(
packet
.
executionPoint
)
{
store
.
dispatch
(
actions
.
setPauseExecutionPoint
(
packet
.
executionPoint
)
)
;
}
}
dispatchProgress
(
packet
)
{
const
{
executionPoint
recording
}
=
packet
;
const
point
=
recording
?
null
:
executionPoint
;
store
.
dispatch
(
actions
.
setPauseExecutionPoint
(
point
)
)
;
}
dispatchMessageUpdate
(
message
res
)
{
const
NUMBER_OF_NETWORK_UPDATE
=
8
;
let
expectedLength
=
NUMBER_OF_NETWORK_UPDATE
;
if
(
res
.
networkInfo
.
updates
.
includes
(
"
responseCache
"
)
)
{
expectedLength
+
+
;
}
if
(
res
.
networkInfo
.
updates
.
includes
(
"
requestPostData
"
)
)
{
expectedLength
+
+
;
}
if
(
res
.
networkInfo
.
updates
.
length
=
=
=
expectedLength
)
{
this
.
batchedMessageUpdates
(
{
res
message
}
)
;
}
}
dispatchSidebarClose
(
)
{
store
.
dispatch
(
actions
.
sidebarClose
(
)
)
;
}
dispatchSplitConsoleCloseButtonToggle
(
)
{
store
.
dispatch
(
actions
.
splitConsoleCloseButtonToggle
(
this
.
toolbox
&
&
this
.
toolbox
.
currentToolId
!
=
=
"
webconsole
"
)
)
;
}
dispatchTabWillNavigate
(
packet
)
{
const
{
ui
}
=
store
.
getState
(
)
;
if
(
ui
.
persistLogs
|
|
this
.
webConsoleUI
.
isBrowserConsole
)
{
packet
.
type
=
"
will
-
navigate
"
;
this
.
dispatchMessageAdd
(
packet
)
;
}
else
{
this
.
webConsoleUI
.
clearNetworkRequests
(
)
;
this
.
dispatchMessagesClear
(
)
;
store
.
dispatch
(
{
type
:
Constants
.
WILL_NAVIGATE
}
)
;
}
}
batchedMessageUpdates
(
info
)
{
this
.
queuedMessageUpdates
.
push
(
info
)
;
this
.
setTimeoutIfNeeded
(
)
;
}
batchedRequestUpdates
(
message
)
{
this
.
queuedRequestUpdates
.
push
(
message
)
;
return
this
.
setTimeoutIfNeeded
(
)
;
}
batchedMessagesAdd
(
messages
)
{
this
.
queuedMessageAdds
=
this
.
queuedMessageAdds
.
concat
(
messages
)
;
this
.
setTimeoutIfNeeded
(
)
;
}
requestData
(
id
type
)
{
this
.
networkDataProvider
.
requestData
(
id
type
)
;
}
dispatchClearLogpointMessages
(
logpointId
)
{
store
.
dispatch
(
actions
.
messagesClearLogpoint
(
logpointId
)
)
;
}
dispatchClearHistory
(
)
{
store
.
dispatch
(
actions
.
clearHistory
(
)
)
;
}
dispatchEvaluateExpression
(
expression
)
{
store
.
dispatch
(
actions
.
evaluateExpression
(
expression
)
)
;
}
waitAsyncDispatches
(
)
{
if
(
!
this
.
throttledDispatchPromise
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
throttledDispatchPromise
;
}
setTimeoutIfNeeded
(
)
{
if
(
this
.
throttledDispatchPromise
)
{
return
this
.
throttledDispatchPromise
;
}
this
.
throttledDispatchPromise
=
new
Promise
(
done
=
>
{
setTimeout
(
async
(
)
=
>
{
this
.
throttledDispatchPromise
=
null
;
if
(
!
store
)
{
this
.
setTimeoutIfNeeded
(
)
;
return
;
}
store
.
dispatch
(
actions
.
messagesAdd
(
this
.
queuedMessageAdds
)
)
;
const
length
=
this
.
queuedMessageAdds
.
length
;
if
(
this
.
toolbox
)
{
this
.
telemetry
.
addEventProperty
(
this
.
toolbox
"
enter
"
"
webconsole
"
null
"
message_count
"
length
)
;
}
this
.
queuedMessageAdds
=
[
]
;
if
(
this
.
queuedMessageUpdates
.
length
>
0
)
{
for
(
const
{
message
res
}
of
this
.
queuedMessageUpdates
)
{
await
store
.
dispatch
(
actions
.
networkMessageUpdate
(
message
null
res
)
)
;
this
.
webConsoleUI
.
emitForTests
(
"
network
-
message
-
updated
"
res
)
;
}
this
.
queuedMessageUpdates
=
[
]
;
}
if
(
this
.
queuedRequestUpdates
.
length
>
0
)
{
for
(
const
{
id
data
}
of
this
.
queuedRequestUpdates
)
{
await
store
.
dispatch
(
actions
.
networkUpdateRequest
(
id
data
)
)
;
}
this
.
queuedRequestUpdates
=
[
]
;
this
.
webConsoleUI
.
emitForTests
(
"
network
-
request
-
payload
-
ready
"
)
;
}
done
(
)
;
}
50
)
;
}
)
;
return
this
.
throttledDispatchPromise
;
}
getStore
(
)
{
return
store
;
}
subscribeToStore
(
callback
)
{
store
.
subscribe
(
(
)
=
>
callback
(
store
.
getState
(
)
)
)
;
}
createElement
(
nodename
)
{
return
this
.
document
.
createElement
(
nodename
)
;
}
closeSplitConsole
(
)
{
this
.
toolbox
.
closeSplitConsole
(
)
;
}
}
module
.
exports
=
WebConsoleWrapper
;
