"
use
strict
"
;
const
DebuggerClient
=
function
(
transport
)
{
}
;
DebuggerClient
.
requester
=
function
(
packetSkeleton
config
=
{
}
)
{
let
{
before
after
}
=
config
;
return
function
(
.
.
.
args
)
{
let
outgoingPacket
=
{
to
:
packetSkeleton
.
to
|
|
this
.
actor
}
;
let
maxPosition
=
-
1
;
for
(
let
k
of
Object
.
keys
(
packetSkeleton
)
)
{
if
(
packetSkeleton
[
k
]
instanceof
DebuggerClient
.
Argument
)
{
let
{
position
}
=
packetSkeleton
[
k
]
;
outgoingPacket
[
k
]
=
packetSkeleton
[
k
]
.
getArgument
(
args
)
;
maxPosition
=
Math
.
max
(
position
maxPosition
)
;
}
else
{
outgoingPacket
[
k
]
=
packetSkeleton
[
k
]
;
}
}
if
(
before
)
{
outgoingPacket
=
before
.
call
(
this
outgoingPacket
)
;
}
return
this
.
request
(
outgoingPacket
(
response
)
=
>
{
if
(
after
)
{
let
{
from
}
=
response
;
response
=
after
.
call
(
this
response
)
;
if
(
!
response
.
from
)
{
response
.
from
=
from
;
}
}
let
thisCallback
=
args
[
maxPosition
+
1
]
;
if
(
thisCallback
)
{
thisCallback
(
response
)
;
}
return
response
;
}
"
DebuggerClient
.
requester
request
callback
"
)
;
}
;
}
;
function
arg
(
pos
)
{
return
new
DebuggerClient
.
Argument
(
pos
)
;
}
DebuggerClient
.
Argument
=
function
(
position
)
{
this
.
position
=
position
;
}
;
DebuggerClient
.
Argument
.
prototype
.
getArgument
=
function
(
params
)
{
if
(
!
(
this
.
position
in
params
)
)
{
throw
new
Error
(
"
Bad
index
into
params
:
"
+
this
.
position
)
;
}
return
params
[
this
.
position
]
;
}
;
module
.
exports
=
{
arg
DebuggerClient
}
;
