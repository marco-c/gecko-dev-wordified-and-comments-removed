"
use
strict
"
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
actions
=
require
(
"
devtools
/
client
/
webconsole
/
new
-
console
-
output
/
actions
/
index
"
)
;
const
{
createContextMenu
}
=
require
(
"
devtools
/
client
/
webconsole
/
new
-
console
-
output
/
utils
/
context
-
menu
"
)
;
const
{
configureStore
}
=
require
(
"
devtools
/
client
/
webconsole
/
new
-
console
-
output
/
store
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
old
-
event
-
emitter
"
)
;
const
ConsoleOutput
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
webconsole
/
new
-
console
-
output
/
components
/
console
-
output
"
)
)
;
const
FilterBar
=
React
.
createFactory
(
require
(
"
devtools
/
client
/
webconsole
/
new
-
console
-
output
/
components
/
filter
-
bar
"
)
)
;
let
store
=
null
;
function
NewConsoleOutputWrapper
(
parentNode
jsterm
toolbox
owner
document
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
parentNode
=
parentNode
;
this
.
jsterm
=
jsterm
;
this
.
toolbox
=
toolbox
;
this
.
owner
=
owner
;
this
.
document
=
document
;
this
.
init
=
this
.
init
.
bind
(
this
)
;
this
.
queuedMessageAdds
=
[
]
;
this
.
queuedMessageUpdates
=
[
]
;
this
.
queuedRequestUpdates
=
[
]
;
this
.
throttledDispatchTimeout
=
false
;
store
=
configureStore
(
this
.
jsterm
.
hud
)
;
}
NewConsoleOutputWrapper
.
prototype
=
{
init
:
function
(
)
{
const
attachRefToHud
=
(
id
node
)
=
>
{
this
.
jsterm
.
hud
[
id
]
=
node
;
}
;
this
.
parentNode
.
addEventListener
(
"
click
"
(
event
)
=
>
{
if
(
event
.
detail
!
=
=
1
|
|
event
.
button
!
=
=
0
)
{
return
;
}
let
target
=
event
.
originalTarget
|
|
event
.
target
;
if
(
target
.
closest
(
"
a
"
)
)
{
return
;
}
if
(
target
.
closest
(
"
input
"
)
)
{
return
;
}
if
(
!
target
.
closest
(
"
.
webconsole
-
output
"
)
)
{
return
;
}
let
selection
=
this
.
document
.
defaultView
.
getSelection
(
)
;
if
(
selection
&
&
!
selection
.
isCollapsed
)
{
return
;
}
this
.
jsterm
.
focus
(
)
;
}
)
;
const
serviceContainer
=
{
attachRefToHud
emitNewMessage
:
(
node
messageId
timeStamp
)
=
>
{
this
.
jsterm
.
hud
.
emit
(
"
new
-
messages
"
new
Set
(
[
{
node
messageId
timeStamp
}
]
)
)
;
}
hudProxy
:
this
.
jsterm
.
hud
.
proxy
openLink
:
url
=
>
{
this
.
jsterm
.
hud
.
owner
.
openLink
(
url
)
;
}
createElement
:
nodename
=
>
{
return
this
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
nodename
)
;
}
}
;
serviceContainer
.
openContextMenu
=
(
e
message
)
=
>
{
let
{
screenX
screenY
target
}
=
e
;
let
messageEl
=
target
.
closest
(
"
.
message
"
)
;
let
clipboardText
=
messageEl
?
messageEl
.
textContent
:
null
;
let
actorEl
=
target
.
closest
(
"
[
data
-
link
-
actor
-
id
]
"
)
;
let
actor
=
actorEl
?
actorEl
.
dataset
.
linkActorId
:
null
;
let
menu
=
createContextMenu
(
this
.
jsterm
this
.
parentNode
{
actor
clipboardText
message
serviceContainer
}
)
;
menu
.
once
(
"
open
"
(
)
=
>
this
.
emit
(
"
menu
-
open
"
)
)
;
menu
.
popup
(
screenX
screenY
this
.
toolbox
)
;
return
menu
;
}
;
if
(
this
.
toolbox
)
{
Object
.
assign
(
serviceContainer
{
onViewSourceInDebugger
:
frame
=
>
{
this
.
toolbox
.
viewSourceInDebugger
(
frame
.
url
frame
.
line
)
.
then
(
(
)
=
>
this
.
jsterm
.
hud
.
emit
(
"
source
-
in
-
debugger
-
opened
"
)
)
;
}
onViewSourceInScratchpad
:
frame
=
>
this
.
toolbox
.
viewSourceInScratchpad
(
frame
.
url
frame
.
line
)
onViewSourceInStyleEditor
:
frame
=
>
this
.
toolbox
.
viewSourceInStyleEditor
(
frame
.
url
frame
.
line
)
openNetworkPanel
:
(
requestId
)
=
>
{
return
this
.
toolbox
.
selectTool
(
"
netmonitor
"
)
.
then
(
(
panel
)
=
>
{
let
{
inspectRequest
}
=
panel
.
panelWin
.
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
connector
/
index
"
)
;
return
inspectRequest
(
requestId
)
;
}
)
;
}
sourceMapService
:
this
.
toolbox
?
this
.
toolbox
.
sourceMapURLService
:
null
highlightDomElement
:
(
grip
options
=
{
}
)
=
>
{
return
this
.
toolbox
.
highlighterUtils
?
this
.
toolbox
.
highlighterUtils
.
highlightDomValueGrip
(
grip
options
)
:
null
;
}
unHighlightDomElement
:
(
forceHide
=
false
)
=
>
{
return
this
.
toolbox
.
highlighterUtils
?
this
.
toolbox
.
highlighterUtils
.
unhighlight
(
forceHide
)
:
null
;
}
openNodeInInspector
:
async
(
grip
)
=
>
{
let
onSelectInspector
=
this
.
toolbox
.
selectTool
(
"
inspector
"
)
;
let
onGripNodeToFront
=
this
.
toolbox
.
highlighterUtils
.
gripToNodeFront
(
grip
)
;
let
[
front
inspector
]
=
await
Promise
.
all
(
[
onGripNodeToFront
onSelectInspector
]
)
;
let
onInspectorUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
let
onNodeFrontSet
=
this
.
toolbox
.
selection
.
setNodeFront
(
front
"
console
"
)
;
return
Promise
.
all
(
[
onNodeFrontSet
onInspectorUpdated
]
)
;
}
}
)
;
}
let
childComponent
=
ConsoleOutput
(
{
serviceContainer
}
)
;
let
filterBar
=
FilterBar
(
{
serviceContainer
:
{
attachRefToHud
}
}
)
;
let
provider
=
React
.
createElement
(
Provider
{
store
}
React
.
DOM
.
div
(
{
className
:
"
webconsole
-
output
-
wrapper
"
}
filterBar
childComponent
)
)
;
this
.
body
=
ReactDOM
.
render
(
provider
this
.
parentNode
)
;
this
.
jsterm
.
focus
(
)
;
}
dispatchMessageAdd
:
function
(
message
waitForResponse
)
{
let
promise
;
if
(
waitForResponse
)
{
promise
=
new
Promise
(
resolve
=
>
{
let
jsterm
=
this
.
jsterm
;
jsterm
.
hud
.
on
(
"
new
-
messages
"
function
onThisMessage
(
e
messages
)
{
for
(
let
m
of
messages
)
{
if
(
m
.
timeStamp
=
=
=
message
.
timestamp
)
{
resolve
(
m
.
node
)
;
jsterm
.
hud
.
off
(
"
new
-
messages
"
onThisMessage
)
;
return
;
}
}
}
)
;
}
)
;
}
else
{
promise
=
Promise
.
resolve
(
)
;
}
this
.
batchedMessagesAdd
(
message
)
;
return
promise
;
}
dispatchMessagesAdd
:
function
(
messages
)
{
store
.
dispatch
(
actions
.
messagesAdd
(
messages
)
)
;
}
dispatchMessagesClear
:
function
(
)
{
store
.
dispatch
(
actions
.
messagesClear
(
)
)
;
}
dispatchTimestampsToggle
:
function
(
enabled
)
{
store
.
dispatch
(
actions
.
timestampsToggle
(
enabled
)
)
;
}
dispatchMessageUpdate
:
function
(
message
res
)
{
const
NUMBER_OF_NETWORK_UPDATE
=
8
;
if
(
res
.
networkInfo
.
updates
.
length
=
=
=
NUMBER_OF_NETWORK_UPDATE
)
{
this
.
batchedMessageUpdates
(
{
res
message
}
)
;
}
}
dispatchRequestUpdate
:
function
(
id
data
)
{
this
.
batchedRequestUpdates
(
{
id
data
}
)
;
}
batchedMessageUpdates
:
function
(
info
)
{
this
.
queuedMessageUpdates
.
push
(
info
)
;
this
.
setTimeoutIfNeeded
(
)
;
}
batchedRequestUpdates
:
function
(
message
)
{
this
.
queuedRequestUpdates
.
push
(
message
)
;
this
.
setTimeoutIfNeeded
(
)
;
}
batchedMessagesAdd
:
function
(
message
)
{
this
.
queuedMessageAdds
.
push
(
message
)
;
this
.
setTimeoutIfNeeded
(
)
;
}
setTimeoutIfNeeded
:
function
(
)
{
if
(
this
.
throttledDispatchTimeout
)
{
return
;
}
this
.
throttledDispatchTimeout
=
setTimeout
(
(
)
=
>
{
this
.
throttledDispatchTimeout
=
null
;
store
.
dispatch
(
actions
.
messagesAdd
(
this
.
queuedMessageAdds
)
)
;
this
.
queuedMessageAdds
=
[
]
;
if
(
this
.
queuedMessageUpdates
.
length
>
0
)
{
this
.
queuedMessageUpdates
.
forEach
(
(
{
message
res
}
)
=
>
{
actions
.
networkMessageUpdate
(
message
)
;
this
.
jsterm
.
hud
.
emit
(
"
network
-
message
-
updated
"
res
)
;
}
)
;
this
.
queuedMessageUpdates
=
[
]
;
}
if
(
this
.
queuedRequestUpdates
.
length
>
0
)
{
this
.
queuedRequestUpdates
.
forEach
(
(
{
id
data
}
)
=
>
{
actions
.
networkUpdateRequest
(
id
data
)
;
this
.
jsterm
.
hud
.
emit
(
"
network
-
request
-
payload
-
ready
"
{
id
data
}
)
;
}
)
;
this
.
queuedRequestUpdates
=
[
]
;
}
}
50
)
;
}
getStore
:
function
(
)
{
return
store
;
}
}
;
module
.
exports
=
NewConsoleOutputWrapper
;
