"
use
strict
"
;
const
{
prepareMessage
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
)
;
const
{
IdGenerator
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
id
-
generator
"
)
;
const
{
batchActions
}
=
require
(
"
devtools
/
client
/
shared
/
redux
/
middleware
/
debounce
"
)
;
const
{
MESSAGES_ADD
NETWORK_MESSAGE_UPDATE
NETWORK_UPDATE_REQUEST
MESSAGES_CLEAR
MESSAGES_CLEAR_LOGPOINT
MESSAGE_OPEN
MESSAGE_CLOSE
MESSAGE_TYPE
MESSAGE_UPDATE_PAYLOAD
PAUSED_EXCECUTION_POINT
PRIVATE_MESSAGES_CLEAR
}
=
require
(
"
.
.
/
constants
"
)
;
const
defaultIdGenerator
=
new
IdGenerator
(
)
;
function
messagesAdd
(
packets
idGenerator
=
null
)
{
if
(
idGenerator
=
=
null
)
{
idGenerator
=
defaultIdGenerator
;
}
const
messages
=
packets
.
map
(
packet
=
>
prepareMessage
(
packet
idGenerator
)
)
;
for
(
let
i
=
messages
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
messages
[
i
]
.
type
=
=
=
MESSAGE_TYPE
.
CLEAR
)
{
return
batchActions
(
[
messagesClear
(
)
{
type
:
MESSAGES_ADD
messages
:
messages
.
slice
(
i
)
}
]
)
;
}
}
return
{
type
:
MESSAGES_ADD
messages
}
;
}
function
messagesClear
(
)
{
return
{
type
:
MESSAGES_CLEAR
}
;
}
function
messagesClearLogpoint
(
logpointId
)
{
return
{
type
:
MESSAGES_CLEAR_LOGPOINT
logpointId
}
;
}
function
setPauseExecutionPoint
(
executionPoint
)
{
return
{
type
:
PAUSED_EXCECUTION_POINT
executionPoint
}
;
}
function
privateMessagesClear
(
)
{
return
{
type
:
PRIVATE_MESSAGES_CLEAR
}
;
}
function
messageOpen
(
id
)
{
return
{
type
:
MESSAGE_OPEN
id
}
;
}
function
messageClose
(
id
)
{
return
{
type
:
MESSAGE_CLOSE
id
}
;
}
function
messageGetMatchingElements
(
id
cssSelectors
)
{
return
(
{
dispatch
services
}
)
=
>
{
services
.
requestEvaluation
(
document
.
querySelectorAll
(
'
{
cssSelectors
}
'
)
)
.
then
(
response
=
>
{
dispatch
(
messageUpdatePayload
(
id
response
.
result
)
)
;
}
)
.
catch
(
err
=
>
{
console
.
error
(
err
)
;
}
)
;
}
;
}
function
messageGetTableData
(
id
client
dataType
)
{
return
async
(
{
dispatch
}
)
=
>
{
let
enumResponse
;
try
{
if
(
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
dataType
)
)
{
enumResponse
=
await
client
.
enumEntries
(
)
;
}
else
{
enumResponse
=
await
client
.
enumProperties
(
{
ignoreNonIndexedProperties
:
dataType
=
=
=
"
Array
"
}
)
;
}
}
catch
(
e
)
{
if
(
e
.
error
=
=
=
"
noSuchActor
"
)
{
return
;
}
}
const
{
iterator
}
=
enumResponse
;
iterator
.
slice
(
0
iterator
.
count
sliceResponse
=
>
{
const
{
ownProperties
}
=
sliceResponse
;
dispatch
(
messageUpdatePayload
(
id
ownProperties
)
)
;
}
)
;
}
;
}
function
messageUpdatePayload
(
id
data
)
{
return
{
type
:
MESSAGE_UPDATE_PAYLOAD
id
data
}
;
}
function
networkMessageUpdate
(
packet
idGenerator
=
null
response
)
{
if
(
idGenerator
=
=
null
)
{
idGenerator
=
defaultIdGenerator
;
}
const
message
=
prepareMessage
(
packet
idGenerator
)
;
return
{
type
:
NETWORK_MESSAGE_UPDATE
message
response
}
;
}
function
networkUpdateRequest
(
id
data
)
{
return
{
type
:
NETWORK_UPDATE_REQUEST
id
data
}
;
}
module
.
exports
=
{
messagesAdd
messagesClear
messagesClearLogpoint
messageOpen
messageClose
messageGetMatchingElements
messageGetTableData
messageUpdatePayload
networkMessageUpdate
networkUpdateRequest
privateMessagesClear
setPauseExecutionPoint
}
;
