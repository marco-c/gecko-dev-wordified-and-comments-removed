"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
{
EVALUATE_EXPRESSION
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyRequireGetter
(
this
"
saveScreenshot
"
"
devtools
/
shared
/
screenshot
/
save
"
)
;
loader
.
lazyRequireGetter
(
this
"
messagesActions
"
"
devtools
/
client
/
webconsole
/
actions
/
messages
"
)
;
loader
.
lazyRequireGetter
(
this
"
historyActions
"
"
devtools
/
client
/
webconsole
/
actions
/
history
"
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleCommand
"
"
devtools
/
client
/
webconsole
/
types
"
true
)
;
const
HELP_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Tools
/
Web_Console
/
Helpers
"
;
function
evaluateExpression
(
expression
)
{
return
async
(
{
dispatch
services
}
)
=
>
{
if
(
!
expression
)
{
expression
=
services
.
getInputValue
(
)
;
}
if
(
!
expression
)
{
return
null
;
}
dispatch
(
messagesActions
.
messagesAdd
(
[
new
ConsoleCommand
(
{
messageText
:
expression
timeStamp
:
Date
.
now
(
)
}
)
]
)
)
;
dispatch
(
{
type
:
EVALUATE_EXPRESSION
expression
}
)
;
WebConsoleUtils
.
usageCount
+
+
;
let
mappedExpressionRes
;
try
{
mappedExpressionRes
=
await
services
.
getMappedExpression
(
expression
)
;
}
catch
(
e
)
{
console
.
warn
(
"
Error
when
calling
getMappedExpression
"
e
)
;
}
expression
=
mappedExpressionRes
?
mappedExpressionRes
.
expression
:
expression
;
const
{
frameActor
client
}
=
services
.
getFrameActor
(
)
;
const
onSettled
=
res
=
>
res
;
const
response
=
await
client
.
evaluateJSAsync
(
expression
{
frameActor
selectedNodeActor
:
services
.
getSelectedNodeActor
(
)
mapped
:
mappedExpressionRes
?
mappedExpressionRes
.
mapped
:
null
}
)
.
then
(
onSettled
onSettled
)
;
return
onExpressionEvaluated
(
response
{
dispatch
services
}
)
;
}
;
}
async
function
onExpressionEvaluated
(
response
{
dispatch
services
}
=
{
}
)
{
if
(
response
.
error
)
{
console
.
error
(
Evaluation
error
response
.
error
"
:
"
response
.
message
)
;
return
;
}
if
(
response
.
topLevelAwaitRejected
=
=
=
true
)
{
return
;
}
if
(
!
response
.
helperResult
)
{
dispatch
(
messagesActions
.
messagesAdd
(
[
response
]
)
)
;
return
;
}
await
handleHelperResult
(
response
{
dispatch
services
}
)
;
}
async
function
handleHelperResult
(
response
{
dispatch
services
}
)
{
const
result
=
response
.
result
;
const
helperResult
=
response
.
helperResult
;
const
helperHasRawOutput
=
!
!
(
helperResult
|
|
{
}
)
.
rawOutput
;
if
(
helperResult
&
&
helperResult
.
type
)
{
switch
(
helperResult
.
type
)
{
case
"
clearOutput
"
:
dispatch
(
messagesActions
.
messagesClear
(
)
)
;
break
;
case
"
clearHistory
"
:
dispatch
(
historyActions
.
clearHistory
(
)
)
;
break
;
case
"
inspectObject
"
:
services
.
inspectObjectActor
(
helperResult
.
object
)
;
break
;
case
"
help
"
:
services
.
openLink
(
HELP_URL
)
;
break
;
case
"
copyValueToClipboard
"
:
clipboardHelper
.
copyString
(
helperResult
.
value
)
;
break
;
case
"
screenshotOutput
"
:
const
{
args
value
}
=
helperResult
;
const
screenshotMessages
=
await
saveScreenshot
(
services
.
getPanelWindow
(
)
args
value
)
;
dispatch
(
messagesActions
.
messagesAdd
(
screenshotMessages
.
map
(
message
=
>
(
{
message
type
:
"
logMessage
"
}
)
)
)
)
;
return
;
}
}
const
hasErrorMessage
=
response
.
exceptionMessage
|
|
(
helperResult
&
&
helperResult
.
type
=
=
=
"
error
"
)
;
const
hasUndefinedResult
=
result
&
&
typeof
result
=
=
"
object
"
&
&
result
.
type
=
=
"
undefined
"
;
if
(
hasErrorMessage
|
|
helperHasRawOutput
|
|
!
hasUndefinedResult
)
{
dispatch
(
messagesActions
.
messagesAdd
(
[
response
]
)
)
;
}
}
module
.
exports
=
{
evaluateExpression
}
;
