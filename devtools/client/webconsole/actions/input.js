"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
{
EVALUATE_EXPRESSION
SET_TERMINAL_INPUT
SET_TERMINAL_EAGER_RESULT
EDITOR_PRETTY_PRINT
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
{
getAllPrefs
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
prefs
"
)
;
const
{
ResourceWatcher
}
=
require
(
"
devtools
/
shared
/
resources
/
resource
-
watcher
"
)
;
const
l10n
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
l10n
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyRequireGetter
(
this
"
saveScreenshot
"
"
devtools
/
shared
/
screenshot
/
save
"
)
;
loader
.
lazyRequireGetter
(
this
"
messagesActions
"
"
devtools
/
client
/
webconsole
/
actions
/
messages
"
)
;
loader
.
lazyRequireGetter
(
this
"
historyActions
"
"
devtools
/
client
/
webconsole
/
actions
/
history
"
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleCommand
"
"
devtools
/
client
/
webconsole
/
types
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
netmonitorBlockingActions
"
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
request
-
blocking
"
)
;
const
HELP_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Tools
/
Web_Console
/
Helpers
"
;
async
function
getMappedExpression
(
hud
expression
)
{
let
mapResult
;
try
{
mapResult
=
await
hud
.
getMappedExpression
(
expression
)
;
}
catch
(
e
)
{
console
.
warn
(
"
Error
when
calling
getMappedExpression
"
e
)
;
}
let
mapped
=
null
;
if
(
mapResult
)
{
(
{
expression
mapped
}
=
mapResult
)
;
}
return
{
expression
mapped
}
;
}
function
evaluateExpression
(
expression
from
=
"
input
"
)
{
return
async
(
{
dispatch
toolbox
webConsoleUI
hud
client
}
)
=
>
{
if
(
!
expression
)
{
expression
=
hud
.
getInputSelection
(
)
|
|
hud
.
getInputValue
(
)
;
}
if
(
!
expression
)
{
return
null
;
}
const
{
messages
}
=
dispatch
(
messagesActions
.
messagesAdd
(
[
new
ConsoleCommand
(
{
messageText
:
expression
timeStamp
:
Date
.
now
(
)
}
)
]
)
)
;
const
[
consoleCommandMessage
]
=
messages
;
dispatch
(
{
type
:
EVALUATE_EXPRESSION
expression
from
}
)
;
WebConsoleUtils
.
usageCount
+
+
;
let
mapped
;
(
{
expression
mapped
}
=
await
getMappedExpression
(
hud
expression
)
)
;
const
onSettled
=
res
=
>
res
;
const
response
=
await
client
.
evaluateJSAsync
(
expression
{
frameActor
:
webConsoleUI
.
getFrameActor
(
)
selectedNodeActor
:
webConsoleUI
.
getSelectedNodeActorID
(
)
selectedTargetFront
:
toolbox
&
&
toolbox
.
getSelectedTargetFront
(
)
mapped
}
)
.
then
(
onSettled
onSettled
)
;
const
serverConsoleCommandTimestamp
=
response
.
startTime
|
|
(
response
.
resultID
&
&
Number
(
response
.
resultID
.
replace
(
/
\
-
\
d
*
/
"
"
)
)
)
|
|
null
;
if
(
serverConsoleCommandTimestamp
&
&
consoleCommandMessage
.
timeStamp
>
serverConsoleCommandTimestamp
)
{
dispatch
(
messagesActions
.
messageRemove
(
consoleCommandMessage
.
id
)
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
new
ConsoleCommand
(
{
messageText
:
expression
timeStamp
:
serverConsoleCommandTimestamp
}
)
]
)
)
;
}
return
dispatch
(
onExpressionEvaluated
(
response
)
)
;
}
;
}
function
onExpressionEvaluated
(
response
)
{
return
async
(
{
dispatch
webConsoleUI
}
)
=
>
{
if
(
response
.
error
)
{
console
.
error
(
Evaluation
error
response
.
error
"
:
"
response
.
message
)
;
return
;
}
if
(
response
.
topLevelAwaitRejected
=
=
=
true
)
{
return
;
}
if
(
!
response
.
helperResult
)
{
webConsoleUI
.
wrapper
.
dispatchMessageAdd
(
response
)
;
return
;
}
await
dispatch
(
handleHelperResult
(
response
)
)
;
}
;
}
function
handleHelperResult
(
response
)
{
return
async
(
{
dispatch
hud
toolbox
webConsoleUI
}
)
=
>
{
const
{
result
helperResult
}
=
response
;
const
helperHasRawOutput
=
!
!
helperResult
?
.
rawOutput
;
if
(
helperResult
?
.
type
)
{
switch
(
helperResult
.
type
)
{
case
"
clearOutput
"
:
dispatch
(
messagesActions
.
messagesClear
(
)
)
;
break
;
case
"
clearHistory
"
:
dispatch
(
historyActions
.
clearHistory
(
)
)
;
break
;
case
"
inspectObject
"
:
{
const
objectActor
=
helperResult
.
object
;
if
(
hud
.
toolbox
&
&
!
helperResult
.
forceExpandInConsole
)
{
hud
.
toolbox
.
inspectObjectActor
(
objectActor
)
;
}
else
{
webConsoleUI
.
inspectObjectActor
(
objectActor
)
;
}
break
;
}
case
"
help
"
:
hud
.
openLink
(
HELP_URL
)
;
break
;
case
"
copyValueToClipboard
"
:
clipboardHelper
.
copyString
(
helperResult
.
value
)
;
break
;
case
"
screenshotOutput
"
:
const
{
args
value
}
=
helperResult
;
const
screenshotMessages
=
await
saveScreenshot
(
webConsoleUI
.
getPanelWindow
(
)
args
value
)
;
dispatch
(
messagesActions
.
messagesAdd
(
screenshotMessages
.
map
(
message
=
>
(
{
message
resourceType
:
ResourceWatcher
.
TYPES
.
PLATFORM_MESSAGE
}
)
)
)
)
;
break
;
case
"
blockURL
"
:
const
blockURL
=
helperResult
.
args
.
url
;
toolbox
.
getPanel
(
"
netmonitor
"
)
?
.
panelWin
.
store
.
dispatch
(
netmonitorBlockingActions
.
addBlockedUrl
(
blockURL
)
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
{
resourceType
:
ResourceWatcher
.
TYPES
.
PLATFORM_MESSAGE
message
:
l10n
.
getFormatStr
(
"
webconsole
.
message
.
commands
.
blockedURL
"
[
blockURL
]
)
}
]
)
)
;
break
;
case
"
unblockURL
"
:
const
unblockURL
=
helperResult
.
args
.
url
;
toolbox
.
getPanel
(
"
netmonitor
"
)
?
.
panelWin
.
store
.
dispatch
(
netmonitorBlockingActions
.
removeBlockedUrl
(
unblockURL
)
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
{
resourceType
:
ResourceWatcher
.
TYPES
.
PLATFORM_MESSAGE
message
:
l10n
.
getFormatStr
(
"
webconsole
.
message
.
commands
.
unblockedURL
"
[
unblockURL
]
)
}
]
)
)
;
return
;
}
}
const
hasErrorMessage
=
response
.
exceptionMessage
|
|
(
helperResult
&
&
helperResult
.
type
=
=
=
"
error
"
)
;
const
hasUndefinedResult
=
result
&
&
typeof
result
=
=
"
object
"
&
&
result
.
type
=
=
"
undefined
"
;
if
(
hasErrorMessage
|
|
helperHasRawOutput
|
|
!
hasUndefinedResult
)
{
dispatch
(
messagesActions
.
messagesAdd
(
[
response
]
)
)
;
}
}
;
}
function
focusInput
(
)
{
return
(
{
hud
}
)
=
>
{
return
hud
.
focusInput
(
)
;
}
;
}
function
setInputValue
(
value
)
{
return
(
{
hud
}
)
=
>
{
return
hud
.
setInputValue
(
value
)
;
}
;
}
function
terminalInputChanged
(
expression
force
=
false
)
{
return
async
(
{
dispatch
webConsoleUI
hud
toolbox
client
getState
}
)
=
>
{
const
prefs
=
getAllPrefs
(
getState
(
)
)
;
if
(
!
prefs
.
eagerEvaluation
)
{
return
null
;
}
const
{
terminalInput
=
"
"
}
=
getState
(
)
.
history
;
if
(
(
!
terminalInput
&
&
!
expression
)
|
|
(
typeof
terminalInput
=
=
=
"
string
"
&
&
typeof
expression
=
=
=
"
string
"
&
&
expression
.
trim
(
)
=
=
=
terminalInput
.
trim
(
)
&
&
!
force
)
)
{
return
null
;
}
dispatch
(
{
type
:
SET_TERMINAL_INPUT
expression
:
expression
.
trim
(
)
}
)
;
if
(
!
expression
|
|
!
expression
.
trim
(
)
)
{
return
dispatch
(
{
type
:
SET_TERMINAL_EAGER_RESULT
expression
result
:
null
}
)
;
}
let
mapped
;
(
{
expression
mapped
}
=
await
getMappedExpression
(
hud
expression
)
)
;
const
response
=
await
client
.
evaluateJSAsync
(
expression
{
frameActor
:
await
webConsoleUI
.
getFrameActor
(
)
selectedNodeActor
:
webConsoleUI
.
getSelectedNodeActorID
(
)
selectedTargetFront
:
toolbox
&
&
toolbox
.
getSelectedTargetFront
(
)
mapped
eager
:
true
}
)
;
return
dispatch
(
{
type
:
SET_TERMINAL_EAGER_RESULT
result
:
getEagerEvaluationResult
(
response
)
}
)
;
}
;
}
function
updateInstantEvaluationResultForCurrentExpression
(
)
{
return
(
{
getState
dispatch
}
)
=
>
dispatch
(
terminalInputChanged
(
getState
(
)
.
history
.
terminalInput
true
)
)
;
}
function
getEagerEvaluationResult
(
response
)
{
const
result
=
response
.
exception
|
|
response
.
result
;
if
(
result
?
.
isSyntaxError
|
|
(
result
&
&
result
.
type
=
=
"
undefined
"
)
)
{
return
null
;
}
return
result
;
}
function
prettyPrintEditor
(
)
{
return
{
type
:
EDITOR_PRETTY_PRINT
}
;
}
module
.
exports
=
{
evaluateExpression
focusInput
setInputValue
terminalInputChanged
updateInstantEvaluationResultForCurrentExpression
prettyPrintEditor
}
;
