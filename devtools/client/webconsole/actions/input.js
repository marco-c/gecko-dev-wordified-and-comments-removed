"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
{
EVALUATE_EXPRESSION
SET_TERMINAL_INPUT
SET_TERMINAL_EAGER_RESULT
EDITOR_PRETTY_PRINT
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
{
getAllPrefs
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
prefs
"
)
;
const
ResourceCommand
=
require
(
"
devtools
/
shared
/
commands
/
resource
/
resource
-
command
"
)
;
const
l10n
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
l10n
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyRequireGetter
(
this
"
messagesActions
"
"
devtools
/
client
/
webconsole
/
actions
/
messages
"
)
;
loader
.
lazyRequireGetter
(
this
"
historyActions
"
"
devtools
/
client
/
webconsole
/
actions
/
history
"
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleCommand
"
"
devtools
/
client
/
webconsole
/
types
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
netmonitorBlockingActions
"
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
request
-
blocking
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
saveScreenshot
"
"
captureAndSaveScreenshot
"
]
"
devtools
/
client
/
shared
/
screenshot
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createSimpleTableMessage
"
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getSelectedTarget
"
"
devtools
/
shared
/
commands
/
target
/
selectors
/
targets
"
true
)
;
const
HELP_URL
=
"
https
:
/
/
firefox
-
source
-
docs
.
mozilla
.
org
/
devtools
-
user
/
web_console
/
helpers
/
"
;
async
function
getMappedExpression
(
hud
expression
)
{
let
mapResult
;
try
{
mapResult
=
await
hud
.
getMappedExpression
(
expression
)
;
}
catch
(
e
)
{
console
.
warn
(
"
Error
when
calling
getMappedExpression
"
e
)
;
}
let
mapped
=
null
;
if
(
mapResult
)
{
(
{
expression
mapped
}
=
mapResult
)
;
}
return
{
expression
mapped
}
;
}
function
evaluateExpression
(
expression
from
=
"
input
"
)
{
return
async
(
{
dispatch
toolbox
webConsoleUI
hud
commands
}
)
=
>
{
if
(
!
expression
)
{
expression
=
hud
.
getInputSelection
(
)
|
|
hud
.
getInputValue
(
)
;
}
if
(
!
expression
)
{
return
null
;
}
const
{
messages
}
=
dispatch
(
messagesActions
.
messagesAdd
(
[
new
ConsoleCommand
(
{
messageText
:
expression
timeStamp
:
Date
.
now
(
)
}
)
]
)
)
;
const
[
consoleCommandMessage
]
=
messages
;
dispatch
(
{
type
:
EVALUATE_EXPRESSION
expression
from
}
)
;
WebConsoleUtils
.
usageCount
+
+
;
let
mapped
;
(
{
expression
mapped
}
=
await
getMappedExpression
(
hud
expression
)
)
;
const
onSettled
=
res
=
>
res
;
const
response
=
await
commands
.
scriptCommand
.
execute
(
expression
{
frameActor
:
hud
.
getSelectedFrameActorID
(
)
selectedNodeActor
:
webConsoleUI
.
getSelectedNodeActorID
(
)
selectedTargetFront
:
getSelectedTarget
(
webConsoleUI
.
hud
.
commands
.
targetCommand
.
store
.
getState
(
)
)
mapped
}
)
.
then
(
onSettled
onSettled
)
;
const
serverConsoleCommandTimestamp
=
response
.
startTime
;
if
(
serverConsoleCommandTimestamp
&
&
consoleCommandMessage
.
timeStamp
>
serverConsoleCommandTimestamp
)
{
dispatch
(
messagesActions
.
messageRemove
(
consoleCommandMessage
.
id
)
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
new
ConsoleCommand
(
{
messageText
:
expression
timeStamp
:
serverConsoleCommandTimestamp
}
)
]
)
)
;
}
return
dispatch
(
onExpressionEvaluated
(
response
)
)
;
}
;
}
function
onExpressionEvaluated
(
response
)
{
return
async
(
{
dispatch
webConsoleUI
}
)
=
>
{
if
(
response
.
error
)
{
console
.
error
(
Evaluation
error
response
.
error
"
:
"
response
.
message
)
;
return
;
}
if
(
response
.
topLevelAwaitRejected
=
=
=
true
)
{
return
;
}
if
(
!
response
.
helperResult
)
{
webConsoleUI
.
wrapper
.
dispatchMessageAdd
(
response
)
;
return
;
}
await
dispatch
(
handleHelperResult
(
response
)
)
;
}
;
}
function
handleHelperResult
(
response
)
{
return
async
(
{
dispatch
hud
toolbox
webConsoleUI
getState
}
)
=
>
{
const
{
result
helperResult
}
=
response
;
const
helperHasRawOutput
=
!
!
helperResult
?
.
rawOutput
;
let
networkFront
=
null
;
const
hasNetworkResourceCommandSupport
=
hud
.
resourceCommand
.
hasResourceCommandSupport
(
hud
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
)
;
if
(
hasNetworkResourceCommandSupport
)
{
networkFront
=
await
hud
.
resourceCommand
.
watcherFront
.
getNetworkParentActor
(
)
;
}
if
(
helperResult
?
.
type
)
{
switch
(
helperResult
.
type
)
{
case
"
clearOutput
"
:
dispatch
(
messagesActions
.
messagesClear
(
)
)
;
break
;
case
"
clearHistory
"
:
dispatch
(
historyActions
.
clearHistory
(
)
)
;
break
;
case
"
historyOutput
"
:
const
history
=
getState
(
)
.
history
.
entries
|
|
[
]
;
const
columns
=
new
Map
(
[
[
"
_index
"
"
(
index
)
"
]
[
"
expression
"
"
Expressions
"
]
]
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
{
.
.
.
createSimpleTableMessage
(
columns
history
.
map
(
(
expression
index
)
=
>
{
return
{
_index
:
index
expression
}
;
}
)
)
}
]
)
)
;
break
;
case
"
inspectObject
"
:
{
const
objectActor
=
helperResult
.
object
;
if
(
hud
.
toolbox
&
&
!
helperResult
.
forceExpandInConsole
)
{
hud
.
toolbox
.
inspectObjectActor
(
objectActor
)
;
}
else
{
webConsoleUI
.
inspectObjectActor
(
objectActor
)
;
}
break
;
}
case
"
help
"
:
hud
.
openLink
(
HELP_URL
)
;
break
;
case
"
copyValueToClipboard
"
:
clipboardHelper
.
copyString
(
helperResult
.
value
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
{
resourceType
:
ResourceCommand
.
TYPES
.
PLATFORM_MESSAGE
message
:
l10n
.
getStr
(
"
webconsole
.
message
.
commands
.
copyValueToClipboard
"
)
}
]
)
)
;
break
;
case
"
screenshotOutput
"
:
const
{
args
value
}
=
helperResult
;
const
targetFront
=
getSelectedTarget
(
hud
.
commands
.
targetCommand
.
store
.
getState
(
)
)
|
|
hud
.
currentTarget
;
let
screenshotMessages
;
if
(
targetFront
.
hasActor
(
"
screenshotContent
"
)
)
{
screenshotMessages
=
await
captureAndSaveScreenshot
(
targetFront
webConsoleUI
.
getPanelWindow
(
)
args
)
;
}
else
{
screenshotMessages
=
await
saveScreenshot
(
webConsoleUI
.
getPanelWindow
(
)
args
value
)
;
}
if
(
screenshotMessages
&
&
screenshotMessages
.
length
)
{
dispatch
(
messagesActions
.
messagesAdd
(
screenshotMessages
.
map
(
message
=
>
(
{
message
:
{
level
:
message
.
level
|
|
"
log
"
arguments
:
[
message
.
text
]
chromeContext
:
true
}
resourceType
:
ResourceCommand
.
TYPES
.
CONSOLE_MESSAGE
}
)
)
)
)
;
}
break
;
case
"
blockURL
"
:
const
blockURL
=
helperResult
.
args
.
url
;
if
(
networkFront
)
{
await
networkFront
.
blockRequest
(
{
url
:
blockURL
}
)
;
}
toolbox
.
getPanel
(
"
netmonitor
"
)
?
.
panelWin
.
store
.
dispatch
(
netmonitorBlockingActions
.
addBlockedUrl
(
blockURL
)
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
{
resourceType
:
ResourceCommand
.
TYPES
.
PLATFORM_MESSAGE
message
:
l10n
.
getFormatStr
(
"
webconsole
.
message
.
commands
.
blockedURL
"
[
blockURL
]
)
}
]
)
)
;
break
;
case
"
unblockURL
"
:
const
unblockURL
=
helperResult
.
args
.
url
;
if
(
networkFront
)
{
await
networkFront
.
unblockRequest
(
{
url
:
unblockURL
}
)
;
}
toolbox
.
getPanel
(
"
netmonitor
"
)
?
.
panelWin
.
store
.
dispatch
(
netmonitorBlockingActions
.
removeBlockedUrl
(
unblockURL
)
)
;
dispatch
(
messagesActions
.
messagesAdd
(
[
{
resourceType
:
ResourceCommand
.
TYPES
.
PLATFORM_MESSAGE
message
:
l10n
.
getFormatStr
(
"
webconsole
.
message
.
commands
.
unblockedURL
"
[
unblockURL
]
)
}
]
)
)
;
return
;
}
}
const
hasErrorMessage
=
response
.
exceptionMessage
|
|
(
helperResult
&
&
helperResult
.
type
=
=
=
"
error
"
)
;
const
hasUndefinedResult
=
result
&
&
typeof
result
=
=
"
object
"
&
&
result
.
type
=
=
"
undefined
"
;
if
(
hasErrorMessage
|
|
helperHasRawOutput
|
|
!
hasUndefinedResult
)
{
dispatch
(
messagesActions
.
messagesAdd
(
[
response
]
)
)
;
}
}
;
}
function
focusInput
(
)
{
return
(
{
hud
}
)
=
>
{
return
hud
.
focusInput
(
)
;
}
;
}
function
setInputValue
(
value
)
{
return
(
{
hud
}
)
=
>
{
return
hud
.
setInputValue
(
value
)
;
}
;
}
function
terminalInputChanged
(
expression
force
=
false
)
{
return
async
(
{
dispatch
webConsoleUI
hud
commands
getState
}
)
=
>
{
const
prefs
=
getAllPrefs
(
getState
(
)
)
;
if
(
!
prefs
.
eagerEvaluation
)
{
return
null
;
}
const
{
terminalInput
=
"
"
}
=
getState
(
)
.
history
;
if
(
(
!
terminalInput
&
&
!
expression
)
|
|
(
typeof
terminalInput
=
=
=
"
string
"
&
&
typeof
expression
=
=
=
"
string
"
&
&
expression
.
trim
(
)
=
=
=
terminalInput
.
trim
(
)
&
&
!
force
)
)
{
return
null
;
}
dispatch
(
{
type
:
SET_TERMINAL_INPUT
expression
:
expression
.
trim
(
)
}
)
;
if
(
!
expression
|
|
!
expression
.
trim
(
)
)
{
return
dispatch
(
{
type
:
SET_TERMINAL_EAGER_RESULT
expression
result
:
null
}
)
;
}
let
mapped
;
(
{
expression
mapped
}
=
await
getMappedExpression
(
hud
expression
)
)
;
if
(
mapped
?
.
await
)
{
return
dispatch
(
{
type
:
SET_TERMINAL_EAGER_RESULT
expression
result
:
null
}
)
;
}
const
response
=
await
commands
.
scriptCommand
.
execute
(
expression
{
frameActor
:
hud
.
getSelectedFrameActorID
(
)
selectedNodeActor
:
webConsoleUI
.
getSelectedNodeActorID
(
)
selectedTargetFront
:
getSelectedTarget
(
hud
.
commands
.
targetCommand
.
store
.
getState
(
)
)
mapped
eager
:
true
}
)
;
return
dispatch
(
{
type
:
SET_TERMINAL_EAGER_RESULT
result
:
getEagerEvaluationResult
(
response
)
}
)
;
}
;
}
function
updateInstantEvaluationResultForCurrentExpression
(
)
{
return
(
{
getState
dispatch
}
)
=
>
dispatch
(
terminalInputChanged
(
getState
(
)
.
history
.
terminalInput
true
)
)
;
}
function
getEagerEvaluationResult
(
response
)
{
const
result
=
response
.
exception
|
|
response
.
result
;
if
(
result
?
.
isSyntaxError
|
|
(
result
&
&
result
.
type
=
=
"
undefined
"
)
)
{
return
null
;
}
return
result
;
}
function
prettyPrintEditor
(
)
{
return
{
type
:
EDITOR_PRETTY_PRINT
}
;
}
module
.
exports
=
{
evaluateExpression
focusInput
setInputValue
terminalInputChanged
updateInstantEvaluationResultForCurrentExpression
prettyPrintEditor
}
;
