"
use
strict
"
;
const
{
AUTOCOMPLETE_CLEAR
AUTOCOMPLETE_DATA_RECEIVE
AUTOCOMPLETE_PENDING_REQUEST
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
function
autocompleteUpdate
(
force
getterPath
)
{
return
(
{
dispatch
getState
services
}
)
=
>
{
if
(
services
.
inputHasSelection
(
)
)
{
return
dispatch
(
autocompleteClear
(
)
)
;
}
const
inputValue
=
services
.
getInputValue
(
)
;
const
{
frameActor
:
frameActorId
client
}
=
services
.
getFrameActor
(
)
;
const
cursor
=
services
.
getInputCursor
(
)
;
const
state
=
getState
(
)
.
autocomplete
;
const
{
cache
}
=
state
;
if
(
!
force
&
&
(
!
inputValue
|
|
/
^
[
a
-
zA
-
Z0
-
9_
]
/
.
test
(
inputValue
.
substring
(
cursor
)
)
)
)
{
return
dispatch
(
autocompleteClear
(
)
)
;
}
const
input
=
inputValue
.
substring
(
0
cursor
)
;
const
retrieveFromCache
=
!
force
&
&
cache
&
&
cache
.
input
&
&
input
.
startsWith
(
cache
.
input
)
&
&
/
[
a
-
zA
-
Z0
-
9
]
/
.
test
(
input
)
&
&
frameActorId
=
=
=
cache
.
frameActorId
;
if
(
retrieveFromCache
)
{
return
dispatch
(
autoCompleteDataRetrieveFromCache
(
input
)
)
;
}
let
authorizedEvaluations
=
Array
.
isArray
(
state
.
authorizedEvaluations
)
&
&
state
.
authorizedEvaluations
.
length
>
0
?
state
.
authorizedEvaluations
:
[
]
;
if
(
Array
.
isArray
(
getterPath
)
&
&
getterPath
.
length
>
0
)
{
const
last
=
authorizedEvaluations
[
authorizedEvaluations
.
length
-
1
]
;
const
concat
=
!
last
|
|
last
.
every
(
(
x
index
)
=
>
x
=
=
=
getterPath
[
index
]
)
;
if
(
concat
)
{
authorizedEvaluations
.
push
(
getterPath
)
;
}
else
{
authorizedEvaluations
=
[
getterPath
]
;
}
}
return
dispatch
(
autocompleteDataFetch
(
{
input
frameActorId
client
authorizedEvaluations
force
}
)
)
;
}
;
}
function
autocompleteClear
(
)
{
return
{
type
:
AUTOCOMPLETE_CLEAR
}
;
}
function
autoCompleteDataRetrieveFromCache
(
input
)
{
return
{
type
:
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
input
}
;
}
let
currentRequestId
=
0
;
function
generateRequestId
(
)
{
return
currentRequestId
+
+
;
}
function
autocompleteDataFetch
(
{
input
frameActorId
force
client
authorizedEvaluations
}
)
{
return
(
{
dispatch
services
}
)
=
>
{
const
selectedNodeActor
=
services
.
getSelectedNodeActor
(
)
;
const
id
=
generateRequestId
(
)
;
dispatch
(
{
type
:
AUTOCOMPLETE_PENDING_REQUEST
id
}
)
;
client
.
autocomplete
(
input
undefined
frameActorId
selectedNodeActor
authorizedEvaluations
)
.
then
(
data
=
>
{
dispatch
(
autocompleteDataReceive
(
{
id
input
force
frameActorId
data
authorizedEvaluations
}
)
)
;
}
)
.
catch
(
e
=
>
{
console
.
error
(
"
failed
autocomplete
"
e
)
;
dispatch
(
autocompleteClear
(
)
)
;
}
)
;
}
;
}
function
autocompleteDataReceive
(
{
id
input
frameActorId
force
data
authorizedEvaluations
}
)
{
return
{
type
:
AUTOCOMPLETE_DATA_RECEIVE
id
input
force
frameActorId
data
authorizedEvaluations
}
;
}
module
.
exports
=
{
autocompleteClear
autocompleteUpdate
}
;
