"
use
strict
"
;
const
{
AUTOCOMPLETE_CLEAR
AUTOCOMPLETE_DATA_RECEIVE
AUTOCOMPLETE_PENDING_REQUEST
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
{
analyzeInputString
shouldInputBeAutocompleted
}
=
require
(
"
devtools
/
shared
/
webconsole
/
analyze
-
input
-
string
"
)
;
function
autocompleteUpdate
(
force
getterPath
expressionVars
)
{
return
async
(
{
dispatch
getState
webConsoleUI
hud
}
)
=
>
{
if
(
hud
.
inputHasSelection
(
)
)
{
return
dispatch
(
autocompleteClear
(
)
)
;
}
const
inputValue
=
hud
.
getInputValue
(
)
;
const
mappedVars
=
hud
.
getMappedVariables
(
)
?
?
{
}
;
const
allVars
=
(
expressionVars
?
?
[
]
)
.
concat
(
Object
.
keys
(
mappedVars
)
)
;
const
frameActorId
=
await
hud
.
getSelectedFrameActorID
(
)
;
const
cursor
=
webConsoleUI
.
getInputCursor
(
)
;
const
state
=
getState
(
)
.
autocomplete
;
const
{
cache
}
=
state
;
if
(
!
force
&
&
(
!
inputValue
|
|
/
^
[
a
-
zA
-
Z0
-
9_
]
/
.
test
(
inputValue
.
substring
(
cursor
)
)
)
)
{
return
dispatch
(
autocompleteClear
(
)
)
;
}
const
rawInput
=
inputValue
.
substring
(
0
cursor
)
;
const
retrieveFromCache
=
!
force
&
&
cache
&
&
cache
.
input
&
&
rawInput
.
startsWith
(
cache
.
input
)
&
&
/
[
a
-
zA
-
Z0
-
9
]
/
.
test
(
rawInput
)
&
&
frameActorId
=
=
=
cache
.
frameActorId
;
if
(
retrieveFromCache
)
{
return
dispatch
(
autoCompleteDataRetrieveFromCache
(
rawInput
)
)
;
}
const
authorizedEvaluations
=
updateAuthorizedEvaluations
(
state
.
authorizedEvaluations
getterPath
mappedVars
)
;
const
{
input
originalExpression
}
=
await
getMappedInput
(
rawInput
mappedVars
hud
)
;
return
dispatch
(
autocompleteDataFetch
(
{
input
frameActorId
authorizedEvaluations
force
allVars
mappedVars
originalExpression
}
)
)
;
}
;
}
function
updateAuthorizedEvaluations
(
authorizedEvaluations
getterPath
mappedVars
)
{
if
(
!
Array
.
isArray
(
authorizedEvaluations
)
|
|
authorizedEvaluations
.
length
=
=
0
)
{
authorizedEvaluations
=
[
]
;
}
if
(
Array
.
isArray
(
getterPath
)
&
&
getterPath
.
length
>
0
)
{
const
last
=
authorizedEvaluations
[
authorizedEvaluations
.
length
-
1
]
;
const
generatedPath
=
mappedVars
[
getterPath
[
0
]
]
?
.
split
(
"
.
"
)
;
if
(
generatedPath
)
{
getterPath
=
generatedPath
.
concat
(
getterPath
.
slice
(
1
)
)
;
}
const
isMappedVariable
=
generatedPath
&
&
getterPath
.
length
=
=
=
generatedPath
.
length
;
const
concat
=
!
last
|
|
last
.
every
(
(
x
index
)
=
>
x
=
=
=
getterPath
[
index
]
)
;
if
(
isMappedVariable
)
{
authorizedEvaluations
=
generatedPath
.
map
(
(
_
i
)
=
>
generatedPath
.
slice
(
0
i
+
1
)
)
;
}
else
if
(
concat
)
{
authorizedEvaluations
.
push
(
getterPath
)
;
}
else
{
authorizedEvaluations
=
[
getterPath
]
;
}
}
return
authorizedEvaluations
;
}
async
function
getMappedInput
(
rawInput
mappedVars
hud
)
{
if
(
!
mappedVars
|
|
Object
.
keys
(
mappedVars
)
.
length
=
=
0
)
{
return
{
input
:
rawInput
originalExpression
:
undefined
}
;
}
const
inputAnalysis
=
analyzeInputString
(
rawInput
500
)
;
if
(
!
shouldInputBeAutocompleted
(
inputAnalysis
)
)
{
return
{
input
:
rawInput
originalExpression
:
undefined
}
;
}
const
{
mainExpression
:
originalExpression
isPropertyAccess
isElementAccess
lastStatement
}
=
inputAnalysis
;
if
(
!
isPropertyAccess
&
&
!
isElementAccess
)
{
return
{
input
:
lastStatement
originalExpression
}
;
}
let
generated
=
(
await
hud
.
getMappedExpression
(
originalExpression
)
)
?
.
expression
?
?
originalExpression
;
const
trailingSemicolon
=
/
;
\
s
*
/
;
if
(
trailingSemicolon
.
test
(
generated
)
&
&
!
trailingSemicolon
.
test
(
originalExpression
)
)
{
generated
=
generated
.
slice
(
0
generated
.
lastIndexOf
(
"
;
"
)
)
;
}
const
suffix
=
lastStatement
.
slice
(
originalExpression
.
length
)
;
return
{
input
:
generated
+
suffix
originalExpression
}
;
}
function
autocompleteClear
(
)
{
return
{
type
:
AUTOCOMPLETE_CLEAR
}
;
}
function
autoCompleteDataRetrieveFromCache
(
input
)
{
return
{
type
:
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
input
}
;
}
let
currentRequestId
=
0
;
function
generateRequestId
(
)
{
return
currentRequestId
+
+
;
}
function
autocompleteDataFetch
(
{
input
frameActorId
force
authorizedEvaluations
allVars
mappedVars
originalExpression
}
)
{
return
async
(
{
dispatch
commands
webConsoleUI
hud
}
)
=
>
{
const
selectedNodeActorId
=
webConsoleUI
.
getSelectedNodeActorID
(
)
;
let
targetFront
=
commands
.
targetCommand
.
selectedTargetFront
;
const
contextSelectorTargetFront
=
hud
.
toolbox
?
hud
.
toolbox
.
getSelectedTargetFront
(
)
:
null
;
const
selectedActorId
=
selectedNodeActorId
|
|
frameActorId
;
if
(
contextSelectorTargetFront
)
{
targetFront
=
contextSelectorTargetFront
;
}
else
if
(
selectedActorId
)
{
const
selectedFront
=
commands
.
client
.
getFrontByID
(
selectedActorId
)
;
if
(
selectedFront
)
{
targetFront
=
selectedFront
.
targetFront
;
}
}
const
webconsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
const
id
=
generateRequestId
(
)
;
dispatch
(
{
type
:
AUTOCOMPLETE_PENDING_REQUEST
id
}
)
;
webconsoleFront
.
autocomplete
(
input
undefined
frameActorId
selectedNodeActorId
authorizedEvaluations
allVars
)
.
then
(
data
=
>
{
if
(
data
.
isUnsafeGetter
&
&
originalExpression
!
=
=
undefined
)
{
data
.
getterPath
=
unmapGetterPath
(
data
.
getterPath
originalExpression
mappedVars
)
;
}
return
dispatch
(
autocompleteDataReceive
(
{
id
input
force
frameActorId
data
authorizedEvaluations
}
)
)
;
}
)
.
catch
(
e
=
>
{
console
.
error
(
"
failed
autocomplete
"
e
)
;
dispatch
(
autocompleteClear
(
)
)
;
}
)
;
}
;
}
function
unmapGetterPath
(
getterPath
originalExpression
mappedVars
)
{
const
originalVariable
=
/
^
[
^
.
[
?
]
*
/
s
.
exec
(
originalExpression
)
[
0
]
.
trim
(
)
;
const
generatedVariable
=
mappedVars
[
originalVariable
]
;
if
(
generatedVariable
)
{
const
generatedVariableParts
=
generatedVariable
.
split
(
"
.
"
)
;
return
[
originalVariable
.
.
.
getterPath
.
slice
(
generatedVariableParts
.
length
)
]
;
}
return
getterPath
;
}
function
autocompleteDataReceive
(
{
id
input
frameActorId
force
data
authorizedEvaluations
}
)
{
return
{
type
:
AUTOCOMPLETE_DATA_RECEIVE
id
input
force
frameActorId
data
authorizedEvaluations
}
;
}
module
.
exports
=
{
autocompleteClear
autocompleteUpdate
}
;
