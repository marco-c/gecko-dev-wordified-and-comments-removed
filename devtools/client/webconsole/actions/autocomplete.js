"
use
strict
"
;
const
{
AUTOCOMPLETE_CLEAR
AUTOCOMPLETE_DATA_RECEIVE
AUTOCOMPLETE_PENDING_REQUEST
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
function
autocompleteUpdate
(
{
inputValue
cursor
client
frameActorId
force
}
)
{
return
(
{
dispatch
getState
}
)
=
>
{
const
{
cache
}
=
getState
(
)
.
autocomplete
;
if
(
!
force
&
&
(
!
inputValue
|
|
/
^
[
a
-
zA
-
Z0
-
9_
]
/
.
test
(
inputValue
.
substring
(
cursor
)
)
)
)
{
return
dispatch
(
autocompleteClear
(
)
)
;
}
const
input
=
inputValue
.
substring
(
0
cursor
)
;
const
retrieveFromCache
=
!
force
&
&
cache
&
&
cache
.
input
&
&
input
.
startsWith
(
cache
.
input
)
&
&
/
[
a
-
zA
-
Z0
-
9
]
/
.
test
(
input
)
&
&
frameActorId
=
=
=
cache
.
frameActorId
;
if
(
retrieveFromCache
)
{
return
dispatch
(
autoCompleteDataRetrieveFromCache
(
input
)
)
;
}
return
dispatch
(
autocompleteDataFetch
(
{
input
frameActorId
client
}
)
)
;
}
;
}
function
autocompleteClear
(
)
{
return
{
type
:
AUTOCOMPLETE_CLEAR
}
;
}
function
autoCompleteDataRetrieveFromCache
(
input
)
{
return
{
type
:
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
input
}
;
}
let
currentRequestId
=
0
;
function
generateRequestId
(
)
{
return
currentRequestId
+
+
;
}
function
autocompleteDataFetch
(
{
input
frameActorId
client
}
)
{
return
(
{
dispatch
}
)
=
>
{
const
id
=
generateRequestId
(
)
;
dispatch
(
{
type
:
AUTOCOMPLETE_PENDING_REQUEST
id
}
)
;
client
.
autocomplete
(
input
undefined
frameActorId
)
.
then
(
res
=
>
{
dispatch
(
autocompleteDataReceive
(
id
input
frameActorId
res
)
)
;
}
)
.
catch
(
e
=
>
{
console
.
error
(
"
failed
autocomplete
"
e
)
;
dispatch
(
autocompleteClear
(
)
)
;
}
)
;
}
;
}
function
autocompleteDataReceive
(
id
input
frameActorId
data
)
{
return
{
type
:
AUTOCOMPLETE_DATA_RECEIVE
id
input
frameActorId
data
}
;
}
module
.
exports
=
{
autocompleteUpdate
autocompleteDataFetch
autocompleteDataReceive
}
;
