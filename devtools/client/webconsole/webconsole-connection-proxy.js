"
use
strict
"
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
l10n
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
l10n
"
)
;
const
PREF_CONNECTION_TIMEOUT
=
"
devtools
.
debugger
.
remote
-
timeout
"
;
class
WebConsoleConnectionProxy
{
constructor
(
webConsoleUI
target
isBrowserConsole
fissionSupport
)
{
this
.
webConsoleUI
=
webConsoleUI
;
this
.
target
=
target
;
this
.
webConsoleClient
=
target
.
activeConsole
;
this
.
isBrowserConsole
=
isBrowserConsole
;
this
.
fissionSupport
=
fissionSupport
;
this
.
client
=
null
;
this
.
connected
=
false
;
this
.
_connectTimer
=
null
;
this
.
_connectDefer
=
null
;
this
.
_disconnecter
=
null
;
this
.
_onPageError
=
this
.
_onPageError
.
bind
(
this
)
;
this
.
_onLogMessage
=
this
.
_onLogMessage
.
bind
(
this
)
;
this
.
_onConsoleAPICall
=
this
.
_onConsoleAPICall
.
bind
(
this
)
;
this
.
_onNetworkEvent
=
this
.
_onNetworkEvent
.
bind
(
this
)
;
this
.
_onNetworkEventUpdate
=
this
.
_onNetworkEventUpdate
.
bind
(
this
)
;
this
.
_onTabNavigated
=
this
.
_onTabNavigated
.
bind
(
this
)
;
this
.
_onTabWillNavigate
=
this
.
_onTabWillNavigate
.
bind
(
this
)
;
this
.
_onAttachConsole
=
this
.
_onAttachConsole
.
bind
(
this
)
;
this
.
_onCachedMessages
=
this
.
_onCachedMessages
.
bind
(
this
)
;
this
.
_connectionTimeout
=
this
.
_connectionTimeout
.
bind
(
this
)
;
this
.
_onLastPrivateContextExited
=
this
.
_onLastPrivateContextExited
.
bind
(
this
)
;
this
.
_clearLogpointMessages
=
this
.
_clearLogpointMessages
.
bind
(
this
)
;
}
connect
(
)
{
if
(
this
.
_connectDefer
)
{
return
this
.
_connectDefer
.
promise
;
}
this
.
_connectDefer
=
defer
(
)
;
const
timeout
=
Services
.
prefs
.
getIntPref
(
PREF_CONNECTION_TIMEOUT
)
;
this
.
_connectTimer
=
setTimeout
(
this
.
_connectionTimeout
timeout
)
;
const
connPromise
=
this
.
_connectDefer
.
promise
;
connPromise
.
then
(
(
)
=
>
{
clearTimeout
(
this
.
_connectTimer
)
;
this
.
_connectTimer
=
null
;
}
(
)
=
>
{
clearTimeout
(
this
.
_connectTimer
)
;
this
.
_connectTimer
=
null
;
}
)
;
this
.
client
=
this
.
target
.
client
;
this
.
target
.
on
(
"
will
-
navigate
"
this
.
_onTabWillNavigate
)
;
this
.
target
.
on
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
_attachConsole
(
)
;
return
connPromise
;
}
_connectionTimeout
(
)
{
const
error
=
{
error
:
"
timeout
"
message
:
l10n
.
getStr
(
"
connectionTimeout
"
)
}
;
this
.
_connectDefer
.
reject
(
error
)
;
}
_attachConsole
(
)
{
const
listeners
=
[
"
PageError
"
"
ConsoleAPI
"
"
NetworkActivity
"
]
;
if
(
this
.
target
.
chrome
&
&
!
this
.
target
.
isAddon
)
{
listeners
.
push
(
"
ContentProcessMessages
"
)
;
}
return
this
.
webConsoleClient
.
startListeners
(
listeners
)
.
then
(
this
.
_onAttachConsole
error
=
>
{
console
.
error
(
"
attachConsole
failed
:
"
+
error
)
;
this
.
_connectDefer
.
reject
(
error
)
;
}
)
;
}
async
_onAttachConsole
(
response
)
{
let
saveBodies
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
saveRequestAndResponseBodies
"
)
;
if
(
this
.
webConsoleUI
.
isBrowserConsole
)
{
saveBodies
=
false
;
}
this
.
webConsoleUI
.
setSaveRequestAndResponseBodies
(
saveBodies
)
;
this
.
webConsoleClient
.
on
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
on
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
this
.
webConsoleClient
.
on
(
"
logMessage
"
this
.
_onLogMessage
)
;
this
.
webConsoleClient
.
on
(
"
pageError
"
this
.
_onPageError
)
;
this
.
webConsoleClient
.
on
(
"
consoleAPICall
"
this
.
_onConsoleAPICall
)
;
this
.
webConsoleClient
.
on
(
"
lastPrivateContextExited
"
this
.
_onLastPrivateContextExited
)
;
this
.
webConsoleClient
.
on
(
"
clearLogpointMessages
"
this
.
_clearLogpointMessages
)
;
const
msgs
=
[
"
PageError
"
"
ConsoleAPI
"
]
;
const
cachedMessages
=
await
this
.
webConsoleClient
.
getCachedMessages
(
msgs
)
;
this
.
_onCachedMessages
(
cachedMessages
)
;
}
dispatchMessageAdd
(
packet
)
{
this
.
webConsoleUI
.
wrapper
.
dispatchMessageAdd
(
packet
)
;
}
dispatchMessagesAdd
(
packets
)
{
this
.
webConsoleUI
.
wrapper
.
dispatchMessagesAdd
(
packets
)
;
}
dispatchMessageUpdate
(
networkInfo
response
)
{
if
(
!
this
.
webConsoleUI
)
{
return
;
}
this
.
webConsoleUI
.
wrapper
.
dispatchMessageUpdate
(
networkInfo
response
)
;
}
dispatchRequestUpdate
(
id
data
)
{
if
(
!
this
.
webConsoleUI
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
webConsoleUI
.
wrapper
.
dispatchRequestUpdate
(
id
data
)
;
}
async
_onCachedMessages
(
response
)
{
if
(
response
.
error
)
{
console
.
error
(
"
Web
Console
getCachedMessages
error
:
"
+
response
.
error
+
"
"
+
response
.
message
)
;
this
.
_connectDefer
.
reject
(
response
)
;
return
;
}
if
(
!
this
.
_connectTimer
)
{
console
.
error
(
"
Web
Console
getCachedMessages
error
:
invalid
state
.
"
)
;
}
const
messages
=
response
.
messages
.
concat
(
.
.
.
this
.
webConsoleClient
.
getNetworkEvents
(
)
)
;
messages
.
sort
(
(
a
b
)
=
>
a
.
timeStamp
-
b
.
timeStamp
)
;
this
.
dispatchMessagesAdd
(
messages
)
;
if
(
!
this
.
webConsoleClient
.
hasNativeConsoleAPI
)
{
await
this
.
webConsoleUI
.
logWarningAboutReplacedAPI
(
)
;
}
this
.
connected
=
true
;
this
.
_connectDefer
.
resolve
(
this
)
;
}
_onPageError
(
packet
)
{
if
(
!
this
.
webConsoleUI
)
{
return
;
}
packet
.
type
=
"
pageError
"
;
this
.
dispatchMessageAdd
(
packet
)
;
}
_onLogMessage
(
packet
)
{
if
(
!
this
.
webConsoleUI
)
{
return
;
}
packet
.
type
=
"
logMessage
"
;
this
.
dispatchMessageAdd
(
packet
)
;
}
_onConsoleAPICall
(
packet
)
{
if
(
!
this
.
webConsoleUI
)
{
return
;
}
packet
.
type
=
"
consoleAPICall
"
;
this
.
dispatchMessageAdd
(
packet
)
;
}
_clearLogpointMessages
(
logpointId
)
{
if
(
this
.
webConsoleUI
)
{
this
.
webConsoleUI
.
wrapper
.
dispatchClearLogpointMessages
(
logpointId
)
;
}
}
_onNetworkEvent
(
networkInfo
)
{
if
(
!
this
.
webConsoleUI
)
{
return
;
}
this
.
dispatchMessageAdd
(
networkInfo
)
;
}
_onNetworkEventUpdate
(
response
)
{
if
(
!
this
.
webConsoleUI
)
{
return
;
}
this
.
dispatchMessageUpdate
(
response
.
networkInfo
response
)
;
}
_onLastPrivateContextExited
(
packet
)
{
if
(
this
.
webConsoleUI
)
{
this
.
webConsoleUI
.
clearPrivateMessages
(
)
;
}
}
_onTabNavigated
(
packet
)
{
this
.
webConsoleUI
.
handleTabNavigated
(
packet
)
;
}
_onTabWillNavigate
(
packet
)
{
this
.
webConsoleUI
.
handleTabWillNavigate
(
packet
)
;
}
releaseActor
(
actor
)
{
if
(
this
.
client
)
{
this
.
client
.
release
(
actor
)
.
catch
(
(
)
=
>
{
}
)
;
}
}
disconnect
(
)
{
if
(
!
this
.
client
)
{
return
;
}
this
.
webConsoleClient
.
off
(
"
logMessage
"
this
.
_onLogMessage
)
;
this
.
webConsoleClient
.
off
(
"
pageError
"
this
.
_onPageError
)
;
this
.
webConsoleClient
.
off
(
"
consoleAPICall
"
this
.
_onConsoleAPICall
)
;
this
.
webConsoleClient
.
off
(
"
lastPrivateContextExited
"
this
.
_onLastPrivateContextExited
)
;
this
.
webConsoleClient
.
off
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
off
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
this
.
webConsoleClient
.
off
(
"
clearLogpointMessages
"
this
.
_clearLogpointMessages
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
_onTabWillNavigate
)
;
this
.
target
.
off
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
client
=
null
;
this
.
webConsoleClient
=
null
;
this
.
target
=
null
;
this
.
connected
=
false
;
this
.
webConsoleUI
=
null
;
}
}
exports
.
WebConsoleConnectionProxy
=
WebConsoleConnectionProxy
;
