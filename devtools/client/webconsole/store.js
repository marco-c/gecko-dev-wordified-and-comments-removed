"
use
strict
"
;
const
{
FilterState
}
=
require
(
"
devtools
/
client
/
webconsole
/
reducers
/
filters
"
)
;
const
{
PrefState
}
=
require
(
"
devtools
/
client
/
webconsole
/
reducers
/
prefs
"
)
;
const
{
UiState
}
=
require
(
"
devtools
/
client
/
webconsole
/
reducers
/
ui
"
)
;
const
{
applyMiddleware
compose
createStore
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
redux
"
)
;
const
{
BATCH_ACTIONS
}
=
require
(
"
devtools
/
client
/
shared
/
redux
/
middleware
/
debounce
"
)
;
const
{
MESSAGE_OPEN
MESSAGES_ADD
MESSAGES_CLEAR
PRIVATE_MESSAGES_CLEAR
REMOVED_ACTORS_CLEAR
NETWORK_MESSAGE_UPDATE
PREFS
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
{
reducers
}
=
require
(
"
.
/
reducers
/
index
"
)
;
const
{
getMessage
getAllMessagesUiById
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
messages
"
)
;
const
DataProvider
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
connector
/
firefox
-
data
-
provider
"
)
;
const
{
getAllNetworkMessagesUpdateById
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
messages
"
)
;
const
{
getPrefsService
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
prefs
"
)
;
function
configureStore
(
hud
options
=
{
}
)
{
const
prefsService
=
getPrefsService
(
hud
)
;
const
{
getBoolPref
getIntPref
}
=
prefsService
;
const
logLimit
=
options
.
logLimit
|
|
Math
.
max
(
getIntPref
(
"
devtools
.
hud
.
loglimit
"
)
1
)
;
const
sidebarToggle
=
getBoolPref
(
PREFS
.
UI
.
SIDEBAR_TOGGLE
)
;
const
initialState
=
{
prefs
:
PrefState
(
{
logLimit
sidebarToggle
}
)
filters
:
FilterState
(
{
error
:
getBoolPref
(
PREFS
.
FILTER
.
ERROR
)
warn
:
getBoolPref
(
PREFS
.
FILTER
.
WARN
)
info
:
getBoolPref
(
PREFS
.
FILTER
.
INFO
)
debug
:
getBoolPref
(
PREFS
.
FILTER
.
DEBUG
)
log
:
getBoolPref
(
PREFS
.
FILTER
.
LOG
)
css
:
getBoolPref
(
PREFS
.
FILTER
.
CSS
)
net
:
getBoolPref
(
PREFS
.
FILTER
.
NET
)
netxhr
:
getBoolPref
(
PREFS
.
FILTER
.
NETXHR
)
}
)
ui
:
UiState
(
{
filterBarVisible
:
getBoolPref
(
PREFS
.
UI
.
FILTER_BAR
)
networkMessageActiveTabId
:
"
headers
"
persistLogs
:
getBoolPref
(
PREFS
.
UI
.
PERSIST
)
}
)
}
;
return
createStore
(
createRootReducer
(
)
initialState
compose
(
applyMiddleware
(
thunk
.
bind
(
null
{
prefsService
}
)
)
enableActorReleaser
(
hud
)
enableBatching
(
)
enableNetProvider
(
hud
)
)
)
;
}
function
thunk
(
options
=
{
}
{
dispatch
getState
}
)
{
return
next
=
>
action
=
>
{
return
(
typeof
action
=
=
=
"
function
"
)
?
action
(
dispatch
getState
options
)
:
next
(
action
)
;
}
;
}
function
createRootReducer
(
)
{
return
function
rootReducer
(
state
action
)
{
const
newState
=
[
.
.
.
Object
.
entries
(
reducers
)
]
.
reduce
(
(
res
[
key
reducer
]
)
=
>
{
if
(
key
!
=
=
"
messages
"
)
{
res
[
key
]
=
reducer
(
state
[
key
]
action
)
;
}
return
res
;
}
{
}
)
;
return
Object
.
assign
(
newState
{
messages
:
reducers
.
messages
(
state
.
messages
action
newState
.
filters
newState
.
prefs
)
}
)
;
}
;
}
function
enableBatching
(
)
{
return
next
=
>
(
reducer
initialState
enhancer
)
=
>
{
function
batchingReducer
(
state
action
)
{
switch
(
action
.
type
)
{
case
BATCH_ACTIONS
:
return
action
.
actions
.
reduce
(
batchingReducer
state
)
;
default
:
return
reducer
(
state
action
)
;
}
}
if
(
typeof
initialState
=
=
=
"
function
"
&
&
typeof
enhancer
=
=
=
"
undefined
"
)
{
enhancer
=
initialState
;
initialState
=
undefined
;
}
return
next
(
batchingReducer
initialState
enhancer
)
;
}
;
}
function
enableActorReleaser
(
hud
)
{
return
next
=
>
(
reducer
initialState
enhancer
)
=
>
{
function
releaseActorsEnhancer
(
state
action
)
{
state
=
reducer
(
state
action
)
;
let
type
=
action
.
type
;
let
proxy
=
hud
?
hud
.
proxy
:
null
;
if
(
proxy
&
&
(
[
MESSAGES_ADD
MESSAGES_CLEAR
PRIVATE_MESSAGES_CLEAR
]
.
includes
(
type
)
)
)
{
releaseActors
(
state
.
messages
.
removedActors
proxy
)
;
state
=
reducer
(
state
{
type
:
REMOVED_ACTORS_CLEAR
}
)
;
}
return
state
;
}
return
next
(
releaseActorsEnhancer
initialState
enhancer
)
;
}
;
}
function
enableNetProvider
(
hud
)
{
let
dataProvider
;
return
next
=
>
(
reducer
initialState
enhancer
)
=
>
{
function
netProviderEnhancer
(
state
action
)
{
let
proxy
=
hud
?
hud
.
proxy
:
null
;
if
(
!
proxy
)
{
return
reducer
(
state
action
)
;
}
let
actions
=
{
updateRequest
:
(
id
data
batch
)
=
>
{
proxy
.
dispatchRequestUpdate
(
id
data
)
;
}
}
;
if
(
!
dataProvider
)
{
dataProvider
=
new
DataProvider
(
{
actions
webConsoleClient
:
proxy
.
webConsoleClient
}
)
;
proxy
.
networkDataProvider
=
dataProvider
;
}
let
type
=
action
.
type
;
let
newState
=
reducer
(
state
action
)
;
if
(
type
=
=
MESSAGE_OPEN
)
{
let
updates
=
getAllNetworkMessagesUpdateById
(
newState
)
;
let
message
=
updates
[
action
.
id
]
;
if
(
message
&
&
!
message
.
openedOnce
&
&
message
.
source
=
=
"
network
"
)
{
dataProvider
.
onNetworkEvent
(
message
)
;
message
.
updates
.
forEach
(
updateType
=
>
{
dataProvider
.
onNetworkEventUpdate
(
{
packet
:
{
updateType
:
updateType
}
networkInfo
:
message
}
)
;
}
)
;
}
}
if
(
type
=
=
NETWORK_MESSAGE_UPDATE
)
{
let
actor
=
action
.
response
.
networkInfo
.
actor
;
let
open
=
getAllMessagesUiById
(
state
)
.
includes
(
actor
)
;
if
(
open
)
{
let
message
=
getMessage
(
state
actor
)
;
message
.
updates
.
forEach
(
updateType
=
>
{
dataProvider
.
onNetworkEventUpdate
(
{
packet
:
{
updateType
}
networkInfo
:
message
}
)
;
}
)
;
}
}
return
newState
;
}
return
next
(
netProviderEnhancer
initialState
enhancer
)
;
}
;
}
function
releaseActors
(
removedActors
proxy
)
{
if
(
!
proxy
)
{
return
;
}
removedActors
.
forEach
(
actor
=
>
proxy
.
releaseActor
(
actor
)
)
;
}
module
.
exports
.
configureStore
=
configureStore
;
