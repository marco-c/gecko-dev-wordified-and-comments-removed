"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Debugger
=
require
(
"
Debugger
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
ToolSidebar
"
"
devtools
/
client
/
framework
/
sidebar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Messages
"
"
devtools
/
client
/
webconsole
/
console
-
output
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
devtools
/
shared
/
async
-
storage
"
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentClient
"
"
devtools
/
shared
/
client
/
environment
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
loader
.
lazyImporter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
VariablesViewController
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NotificationBox
"
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PriorityLevels
"
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
true
)
;
const
l10n
=
require
(
"
devtools
/
client
/
webconsole
/
webconsole
-
l10n
"
)
;
const
HISTORY_BACK
=
-
1
;
const
HISTORY_FORWARD
=
1
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
HELP_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Tools
/
Web_Console
/
Helpers
"
;
const
VARIABLES_VIEW_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
VariablesView
.
xul
"
;
const
PREF_INPUT_HISTORY_COUNT
=
"
devtools
.
webconsole
.
inputHistoryCount
"
;
const
PREF_AUTO_MULTILINE
=
"
devtools
.
webconsole
.
autoMultiline
"
;
function
JSTerm
(
webConsoleFrame
)
{
this
.
hud
=
webConsoleFrame
;
this
.
hudId
=
this
.
hud
.
hudId
;
this
.
inputHistoryCount
=
Services
.
prefs
.
getIntPref
(
PREF_INPUT_HISTORY_COUNT
)
;
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
_loadHistory
(
)
;
this
.
_objectActorsInVariablesViews
=
new
Map
(
)
;
this
.
_keyPress
=
this
.
_keyPress
.
bind
(
this
)
;
this
.
_inputEventHandler
=
this
.
_inputEventHandler
.
bind
(
this
)
;
this
.
_focusEventHandler
=
this
.
_focusEventHandler
.
bind
(
this
)
;
this
.
_onKeypressInVariablesView
=
this
.
_onKeypressInVariablesView
.
bind
(
this
)
;
this
.
_blurEventHandler
=
this
.
_blurEventHandler
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
JSTerm
.
prototype
=
{
SELECTED_FRAME
:
-
1
_loadHistory
:
function
(
)
{
this
.
history
=
[
]
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
0
;
this
.
historyLoaded
=
asyncStorage
.
getItem
(
"
webConsoleHistory
"
)
.
then
(
value
=
>
{
if
(
Array
.
isArray
(
value
)
)
{
this
.
history
=
value
.
concat
(
this
.
history
)
;
this
.
historyIndex
=
this
.
history
.
length
;
this
.
historyPlaceHolder
=
this
.
history
.
length
;
}
}
console
.
error
)
;
}
clearHistory
:
function
(
)
{
this
.
history
=
[
]
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
0
;
return
this
.
storeHistory
(
)
;
}
storeHistory
:
function
(
)
{
return
asyncStorage
.
setItem
(
"
webConsoleHistory
"
this
.
history
)
;
}
lastCompletion
:
null
_autocompleteCache
:
null
_autocompleteQuery
:
null
_lastFrameActorId
:
null
sidebar
:
null
_variablesView
:
null
_lazyVariablesView
:
true
_objectActorsInVariablesViews
:
null
lastInputValue
:
"
"
_inputChanged
:
false
_autocompletePopupNavigated
:
false
history
:
null
autocompletePopup
:
null
inputNode
:
null
completeNode
:
null
get
outputNode
(
)
{
return
this
.
hud
.
outputNode
;
}
get
webConsoleClient
(
)
{
return
this
.
hud
.
webConsoleClient
;
}
COMPLETE_FORWARD
:
0
COMPLETE_BACKWARD
:
1
COMPLETE_HINT_ONLY
:
2
COMPLETE_PAGEUP
:
3
COMPLETE_PAGEDOWN
:
4
init
:
function
(
)
{
let
autocompleteOptions
=
{
onSelect
:
this
.
onAutocompleteSelect
.
bind
(
this
)
onClick
:
this
.
acceptProposedCompletion
.
bind
(
this
)
listId
:
"
webConsole_autocompletePopupListBox
"
position
:
"
top
"
theme
:
"
auto
"
autoSelect
:
true
}
;
let
doc
=
this
.
hud
.
document
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
let
tooltipDoc
=
toolbox
?
toolbox
.
doc
:
doc
;
this
.
autocompletePopup
=
new
AutocompletePopup
(
tooltipDoc
autocompleteOptions
)
;
let
inputContainer
=
doc
.
querySelector
(
"
.
jsterm
-
input
-
container
"
)
;
this
.
completeNode
=
doc
.
querySelector
(
"
.
jsterm
-
complete
-
node
"
)
;
this
.
inputNode
=
doc
.
querySelector
(
"
.
jsterm
-
input
-
node
"
)
;
this
.
_updateCharSize
(
)
;
if
(
this
.
hud
.
isBrowserConsole
&
&
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
{
inputContainer
.
style
.
display
=
"
none
"
;
}
else
{
this
.
inputNode
.
addEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
addEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
addEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
addEventListener
(
"
focus
"
this
.
_focusEventHandler
)
;
}
if
(
!
this
.
hud
.
isBrowserConsole
)
{
let
okstring
=
l10n
.
getStr
(
"
selfxss
.
okstring
"
)
;
let
msg
=
l10n
.
getFormatStr
(
"
selfxss
.
msg
"
[
okstring
]
)
;
this
.
_onPaste
=
WebConsoleUtils
.
pasteHandlerGen
(
this
.
inputNode
this
.
getNotificationBox
(
)
msg
okstring
)
;
this
.
inputNode
.
addEventListener
(
"
paste
"
this
.
_onPaste
)
;
this
.
inputNode
.
addEventListener
(
"
drop
"
this
.
_onPaste
)
;
}
this
.
hud
.
window
.
addEventListener
(
"
blur
"
this
.
_blurEventHandler
)
;
this
.
lastInputValue
&
&
this
.
setInputValue
(
this
.
lastInputValue
)
;
}
focus
:
function
(
)
{
if
(
!
this
.
inputNode
.
getAttribute
(
"
focused
"
)
)
{
this
.
inputNode
.
focus
(
)
;
}
}
_executeResultCallback
:
function
(
callback
response
)
{
if
(
!
this
.
hud
)
{
return
;
}
if
(
response
.
error
)
{
console
.
error
(
"
Evaluation
error
"
+
response
.
error
+
"
:
"
+
response
.
message
)
;
return
;
}
let
errorMessage
=
response
.
exceptionMessage
;
let
errorDocURL
=
response
.
exceptionDocURL
;
let
errorDocLink
;
if
(
errorDocURL
)
{
errorMessage
+
=
"
"
;
errorDocLink
=
this
.
hud
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
errorDocLink
.
className
=
"
learn
-
more
-
link
webconsole
-
learn
-
more
-
link
"
;
errorDocLink
.
textContent
=
[
{
l10n
.
getStr
(
"
webConsoleMoreInfoLabel
"
)
}
]
;
errorDocLink
.
title
=
errorDocURL
.
split
(
"
?
"
)
[
0
]
;
errorDocLink
.
href
=
"
#
"
;
errorDocLink
.
draggable
=
false
;
errorDocLink
.
addEventListener
(
"
click
"
(
)
=
>
{
this
.
hud
.
owner
.
openLink
(
errorDocURL
)
;
}
)
;
}
if
(
typeof
response
.
exception
=
=
=
"
string
"
)
{
errorMessage
=
new
Error
(
errorMessage
)
.
toString
(
)
;
}
let
result
=
response
.
result
;
let
helperResult
=
response
.
helperResult
;
let
helperHasRawOutput
=
!
!
(
helperResult
|
|
{
}
)
.
rawOutput
;
if
(
helperResult
&
&
helperResult
.
type
)
{
switch
(
helperResult
.
type
)
{
case
"
clearOutput
"
:
this
.
clearOutput
(
)
;
break
;
case
"
clearHistory
"
:
this
.
clearHistory
(
)
;
break
;
case
"
inspectObject
"
:
this
.
inspectObjectActor
(
helperResult
.
object
)
;
break
;
case
"
error
"
:
try
{
errorMessage
=
l10n
.
getStr
(
helperResult
.
message
)
;
}
catch
(
ex
)
{
errorMessage
=
helperResult
.
message
;
}
break
;
case
"
help
"
:
this
.
hud
.
owner
.
openLink
(
HELP_URL
)
;
break
;
case
"
copyValueToClipboard
"
:
clipboardHelper
.
copyString
(
helperResult
.
value
)
;
break
;
}
}
if
(
!
errorMessage
&
&
result
&
&
typeof
result
=
=
"
object
"
&
&
result
.
type
=
=
"
undefined
"
&
&
helperResult
&
&
!
helperHasRawOutput
)
{
callback
&
&
callback
(
)
;
return
;
}
if
(
this
.
hud
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
hud
.
newConsoleOutput
.
dispatchMessageAdd
(
response
true
)
.
then
(
callback
)
;
return
;
}
let
msg
=
new
Messages
.
JavaScriptEvalOutput
(
response
errorMessage
errorDocLink
)
;
this
.
hud
.
output
.
addMessage
(
msg
)
;
if
(
callback
)
{
let
oldFlushCallback
=
this
.
hud
.
_flushCallback
;
this
.
hud
.
_flushCallback
=
(
)
=
>
{
callback
(
msg
.
element
)
;
if
(
oldFlushCallback
)
{
oldFlushCallback
(
)
;
this
.
hud
.
_flushCallback
=
oldFlushCallback
;
return
true
;
}
return
false
;
}
;
}
msg
.
_objectActors
=
new
Set
(
)
;
if
(
WebConsoleUtils
.
isActorGrip
(
response
.
exception
)
)
{
msg
.
_objectActors
.
add
(
response
.
exception
.
actor
)
;
}
if
(
WebConsoleUtils
.
isActorGrip
(
result
)
)
{
msg
.
_objectActors
.
add
(
result
.
actor
)
;
}
}
inspectObjectActor
:
function
(
objectActor
)
{
if
(
this
.
hud
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
hud
.
newConsoleOutput
.
dispatchMessageAdd
(
{
helperResult
:
{
type
:
"
inspectObject
"
object
:
objectActor
}
}
true
)
;
return
this
.
hud
.
newConsoleOutput
;
}
return
this
.
openVariablesView
(
{
objectActor
label
:
VariablesView
.
getString
(
objectActor
{
concise
:
true
}
)
}
)
;
}
execute
:
function
(
executeString
callback
)
{
let
deferred
=
defer
(
)
;
let
resultCallback
;
if
(
this
.
hud
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
resultCallback
=
(
msg
)
=
>
deferred
.
resolve
(
msg
)
;
}
else
{
resultCallback
=
(
msg
)
=
>
{
deferred
.
resolve
(
msg
)
;
if
(
callback
)
{
callback
(
msg
)
;
}
}
;
}
executeString
=
executeString
|
|
this
.
getInputValue
(
)
;
if
(
!
executeString
)
{
return
null
;
}
let
selectedNodeActor
=
null
;
let
inspectorSelection
=
this
.
hud
.
owner
.
getInspectorSelection
(
)
;
if
(
inspectorSelection
&
&
inspectorSelection
.
nodeFront
)
{
selectedNodeActor
=
inspectorSelection
.
nodeFront
.
actorID
;
}
if
(
this
.
hud
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
const
{
ConsoleCommand
}
=
require
(
"
devtools
/
client
/
webconsole
/
new
-
console
-
output
/
types
"
)
;
let
message
=
new
ConsoleCommand
(
{
messageText
:
executeString
}
)
;
this
.
hud
.
proxy
.
dispatchMessageAdd
(
message
)
;
}
else
{
let
message
=
new
Messages
.
Simple
(
executeString
{
category
:
"
input
"
severity
:
"
log
"
}
)
;
this
.
hud
.
output
.
addMessage
(
message
)
;
}
let
onResult
=
this
.
_executeResultCallback
.
bind
(
this
resultCallback
)
;
let
options
=
{
frame
:
this
.
SELECTED_FRAME
selectedNodeActor
:
selectedNodeActor
}
;
this
.
requestEvaluation
(
executeString
options
)
.
then
(
onResult
onResult
)
;
this
.
history
[
this
.
historyIndex
+
+
]
=
executeString
;
this
.
historyPlaceHolder
=
this
.
history
.
length
;
if
(
this
.
history
.
length
>
this
.
inputHistoryCount
)
{
this
.
history
.
splice
(
0
this
.
history
.
length
-
this
.
inputHistoryCount
)
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
this
.
history
.
length
;
}
this
.
storeHistory
(
)
;
WebConsoleUtils
.
usageCount
+
+
;
this
.
setInputValue
(
"
"
)
;
this
.
clearCompletion
(
)
;
return
deferred
.
promise
;
}
requestEvaluation
:
function
(
str
options
=
{
}
)
{
let
deferred
=
defer
(
)
;
function
onResult
(
response
)
{
if
(
!
response
.
error
)
{
deferred
.
resolve
(
response
)
;
}
else
{
deferred
.
reject
(
response
)
;
}
}
let
frameActor
=
null
;
if
(
"
frame
"
in
options
)
{
frameActor
=
this
.
getFrameActor
(
options
.
frame
)
;
}
let
evalOptions
=
{
bindObjectActor
:
options
.
bindObjectActor
frameActor
:
frameActor
selectedNodeActor
:
options
.
selectedNodeActor
selectedObjectActor
:
options
.
selectedObjectActor
}
;
this
.
webConsoleClient
.
evaluateJSAsync
(
str
onResult
evalOptions
)
;
return
deferred
.
promise
;
}
copyObject
:
function
(
evalString
evalOptions
)
{
return
this
.
webConsoleClient
.
evaluateJSAsync
(
copy
(
{
evalString
}
)
null
evalOptions
)
;
}
getFrameActor
:
function
(
frame
)
{
let
state
=
this
.
hud
.
owner
.
getDebuggerFrames
(
)
;
if
(
!
state
)
{
return
null
;
}
let
grip
;
if
(
frame
=
=
this
.
SELECTED_FRAME
)
{
grip
=
state
.
frames
[
state
.
selected
]
;
}
else
{
grip
=
state
.
frames
[
frame
]
;
}
return
grip
?
grip
.
actor
:
null
;
}
openVariablesView
:
function
(
options
)
{
if
(
!
this
.
hud
.
document
.
querySelector
(
"
#
webconsole
-
sidebar
"
)
)
{
return
Promise
.
resolve
(
null
)
;
}
let
onContainerReady
=
(
window
)
=
>
{
let
container
=
window
.
document
.
querySelector
(
"
#
variables
"
)
;
let
view
=
this
.
_variablesView
;
if
(
!
view
|
|
options
.
targetElement
)
{
let
viewOptions
=
{
container
:
container
hideFilterInput
:
options
.
hideFilterInput
}
;
view
=
this
.
_createVariablesView
(
viewOptions
)
;
if
(
!
options
.
targetElement
)
{
this
.
_variablesView
=
view
;
window
.
addEventListener
(
"
keypress
"
this
.
_onKeypressInVariablesView
)
;
}
}
options
.
view
=
view
;
this
.
_updateVariablesView
(
options
)
;
if
(
!
options
.
targetElement
&
&
options
.
autofocus
)
{
window
.
focus
(
)
;
}
this
.
emit
(
"
variablesview
-
open
"
{
view
options
}
)
;
return
view
;
}
;
let
openPromise
;
if
(
options
.
targetElement
)
{
let
deferred
=
defer
(
)
;
openPromise
=
deferred
.
promise
;
let
document
=
options
.
targetElement
.
ownerDocument
;
let
iframe
=
document
.
createElementNS
(
XHTML_NS
"
iframe
"
)
;
iframe
.
addEventListener
(
"
load
"
function
(
)
{
iframe
.
style
.
visibility
=
"
visible
"
;
deferred
.
resolve
(
iframe
.
contentWindow
)
;
}
{
capture
:
true
once
:
true
}
)
;
iframe
.
flex
=
1
;
iframe
.
style
.
visibility
=
"
hidden
"
;
iframe
.
setAttribute
(
"
src
"
VARIABLES_VIEW_URL
)
;
options
.
targetElement
.
appendChild
(
iframe
)
;
}
else
{
if
(
!
this
.
sidebar
)
{
this
.
_createSidebar
(
)
;
}
openPromise
=
this
.
_addVariablesViewSidebarTab
(
)
;
}
return
openPromise
.
then
(
onContainerReady
)
;
}
_createSidebar
:
function
(
)
{
let
tabbox
=
this
.
hud
.
document
.
querySelector
(
"
#
webconsole
-
sidebar
"
)
;
this
.
sidebar
=
new
ToolSidebar
(
tabbox
this
"
webconsole
"
)
;
this
.
sidebar
.
show
(
)
;
this
.
emit
(
"
sidebar
-
opened
"
)
;
}
_addVariablesViewSidebarTab
:
function
(
)
{
let
deferred
=
defer
(
)
;
let
onTabReady
=
(
)
=
>
{
let
window
=
this
.
sidebar
.
getWindowForTab
(
"
variablesview
"
)
;
deferred
.
resolve
(
window
)
;
}
;
let
tabPanel
=
this
.
sidebar
.
getTabPanel
(
"
variablesview
"
)
;
if
(
tabPanel
)
{
if
(
this
.
sidebar
.
getCurrentTabID
(
)
=
=
"
variablesview
"
)
{
onTabReady
(
)
;
}
else
{
this
.
sidebar
.
once
(
"
variablesview
-
selected
"
onTabReady
)
;
this
.
sidebar
.
select
(
"
variablesview
"
)
;
}
}
else
{
this
.
sidebar
.
once
(
"
variablesview
-
ready
"
onTabReady
)
;
this
.
sidebar
.
addTab
(
"
variablesview
"
VARIABLES_VIEW_URL
{
selected
:
true
}
)
;
}
return
deferred
.
promise
;
}
_onKeypressInVariablesView
:
function
(
event
)
{
let
tag
=
event
.
target
.
nodeName
;
if
(
event
.
keyCode
!
=
KeyCodes
.
DOM_VK_ESCAPE
|
|
event
.
shiftKey
|
|
event
.
altKey
|
|
event
.
ctrlKey
|
|
event
.
metaKey
|
|
[
"
input
"
"
textarea
"
"
select
"
"
textbox
"
]
.
indexOf
(
tag
)
>
-
1
)
{
return
;
}
this
.
_sidebarDestroy
(
)
;
this
.
focus
(
)
;
event
.
stopPropagation
(
)
;
}
_createVariablesView
:
function
(
options
)
{
let
view
=
new
VariablesView
(
options
.
container
)
;
view
.
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
view
.
searchPlaceholder
=
l10n
.
getStr
(
"
propertiesFilterPlaceholder
"
)
;
view
.
emptyText
=
l10n
.
getStr
(
"
emptyPropertiesList
"
)
;
view
.
searchEnabled
=
!
options
.
hideFilterInput
;
view
.
lazyEmpty
=
this
.
_lazyVariablesView
;
VariablesViewController
.
attach
(
view
{
getEnvironmentClient
:
grip
=
>
{
return
new
EnvironmentClient
(
this
.
hud
.
proxy
.
client
grip
)
;
}
getObjectClient
:
grip
=
>
{
return
new
ObjectClient
(
this
.
hud
.
proxy
.
client
grip
)
;
}
getLongStringClient
:
grip
=
>
{
return
this
.
webConsoleClient
.
longString
(
grip
)
;
}
releaseActor
:
actor
=
>
{
this
.
hud
.
_releaseObject
(
actor
)
;
}
simpleValueEvalMacro
:
simpleValueEvalMacro
overrideValueEvalMacro
:
overrideValueEvalMacro
getterOrSetterEvalMacro
:
getterOrSetterEvalMacro
}
)
;
view
.
on
(
"
fetched
"
(
type
variableObject
)
=
>
{
this
.
emit
(
"
variablesview
-
fetched
"
variableObject
)
;
}
)
;
return
view
;
}
_updateVariablesView
:
function
(
options
)
{
let
view
=
options
.
view
;
view
.
empty
(
)
;
view
.
controller
.
releaseActors
(
actor
=
>
{
return
view
.
_consoleLastObjectActor
!
=
actor
;
}
)
;
if
(
options
.
objectActor
&
&
(
!
this
.
hud
.
isBrowserConsole
|
|
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
)
{
view
.
eval
=
this
.
_variablesViewEvaluate
.
bind
(
this
options
)
;
view
.
switch
=
this
.
_variablesViewSwitch
.
bind
(
this
options
)
;
view
.
delete
=
this
.
_variablesViewDelete
.
bind
(
this
options
)
;
}
else
{
view
.
eval
=
null
;
view
.
switch
=
null
;
view
.
delete
=
null
;
}
let
{
variable
expanded
}
=
view
.
controller
.
setSingleVariable
(
options
)
;
variable
.
evaluationMacro
=
simpleValueEvalMacro
;
if
(
options
.
objectActor
)
{
view
.
_consoleLastObjectActor
=
options
.
objectActor
.
actor
;
}
else
if
(
options
.
rawObject
)
{
view
.
_consoleLastObjectActor
=
null
;
}
else
{
throw
new
Error
(
"
Variables
View
cannot
open
without
giving
it
an
object
display
.
"
)
;
}
expanded
.
then
(
(
)
=
>
{
this
.
emit
(
"
variablesview
-
updated
"
view
options
)
;
}
)
;
}
_variablesViewEvaluate
:
function
(
options
variableObject
value
)
{
let
updater
=
this
.
_updateVariablesView
.
bind
(
this
options
)
;
let
onEval
=
this
.
_silentEvalCallback
.
bind
(
this
updater
)
;
let
string
=
variableObject
.
evaluationMacro
(
variableObject
value
)
;
let
evalOptions
=
{
frame
:
this
.
SELECTED_FRAME
bindObjectActor
:
options
.
objectActor
.
actor
}
;
this
.
requestEvaluation
(
string
evalOptions
)
.
then
(
onEval
onEval
)
;
}
_variablesViewDelete
:
function
(
options
variableObject
)
{
let
onEval
=
this
.
_silentEvalCallback
.
bind
(
this
null
)
;
let
evalOptions
=
{
frame
:
this
.
SELECTED_FRAME
bindObjectActor
:
options
.
objectActor
.
actor
}
;
this
.
requestEvaluation
(
"
delete
_self
"
+
variableObject
.
symbolicName
evalOptions
)
.
then
(
onEval
onEval
)
;
}
_variablesViewSwitch
:
function
(
options
variableObject
newName
)
{
let
updater
=
this
.
_updateVariablesView
.
bind
(
this
options
)
;
let
onEval
=
this
.
_silentEvalCallback
.
bind
(
this
updater
)
;
let
evalOptions
=
{
frame
:
this
.
SELECTED_FRAME
bindObjectActor
:
options
.
objectActor
.
actor
}
;
let
newSymbolicName
=
variableObject
.
ownerView
.
symbolicName
+
'
[
"
'
+
newName
+
'
"
]
'
;
if
(
newSymbolicName
=
=
variableObject
.
symbolicName
)
{
return
;
}
let
code
=
"
_self
"
+
newSymbolicName
+
"
=
_self
"
+
variableObject
.
symbolicName
+
"
;
"
+
"
delete
_self
"
+
variableObject
.
symbolicName
;
this
.
requestEvaluation
(
code
evalOptions
)
.
then
(
onEval
onEval
)
;
}
_silentEvalCallback
:
function
(
callback
response
)
{
if
(
response
.
error
)
{
console
.
error
(
"
Web
Console
evaluation
failed
.
"
+
response
.
error
+
"
:
"
+
response
.
message
)
;
callback
&
&
callback
(
response
)
;
return
;
}
if
(
response
.
exceptionMessage
)
{
let
message
=
new
Messages
.
Simple
(
response
.
exceptionMessage
{
category
:
"
output
"
severity
:
"
error
"
timestamp
:
response
.
timestamp
}
)
;
this
.
hud
.
output
.
addMessage
(
message
)
;
message
.
_objectActors
=
new
Set
(
)
;
if
(
WebConsoleUtils
.
isActorGrip
(
response
.
exception
)
)
{
message
.
_objectActors
.
add
(
response
.
exception
.
actor
)
;
}
}
let
helper
=
response
.
helperResult
|
|
{
type
:
null
}
;
let
helperGrip
=
null
;
if
(
helper
.
type
=
=
"
inspectObject
"
)
{
helperGrip
=
helper
.
object
;
}
let
grips
=
[
response
.
result
helperGrip
]
;
for
(
let
grip
of
grips
)
{
if
(
WebConsoleUtils
.
isActorGrip
(
grip
)
)
{
this
.
hud
.
_releaseObject
(
grip
.
actor
)
;
}
}
callback
&
&
callback
(
response
)
;
}
clearOutput
:
function
(
clearStorage
)
{
let
hud
=
this
.
hud
;
if
(
hud
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
hud
.
newConsoleOutput
.
dispatchMessagesClear
(
)
;
}
else
{
let
outputNode
=
hud
.
outputNode
;
let
node
;
while
(
(
node
=
outputNode
.
firstChild
)
)
{
hud
.
removeOutputMessage
(
node
)
;
}
hud
.
groupDepth
=
0
;
hud
.
_outputQueue
.
forEach
(
hud
.
_destroyItem
hud
)
;
hud
.
_outputQueue
=
[
]
;
hud
.
_repeatNodes
=
{
}
;
}
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
if
(
clearStorage
)
{
this
.
webConsoleClient
.
clearMessagesCache
(
)
;
}
this
.
_sidebarDestroy
(
)
;
this
.
focus
(
)
;
this
.
emit
(
"
messages
-
cleared
"
)
;
}
clearPrivateMessages
:
function
(
)
{
let
nodes
=
this
.
hud
.
outputNode
.
querySelectorAll
(
"
.
message
[
private
]
"
)
;
for
(
let
node
of
nodes
)
{
this
.
hud
.
removeOutputMessage
(
node
)
;
}
this
.
emit
(
"
private
-
messages
-
cleared
"
)
;
}
resizeInput
:
function
(
)
{
let
inputNode
=
this
.
inputNode
;
inputNode
.
style
.
height
=
"
auto
"
;
let
scrollHeight
=
inputNode
.
inputField
?
inputNode
.
inputField
.
scrollHeight
:
inputNode
.
scrollHeight
;
if
(
scrollHeight
>
0
)
{
inputNode
.
style
.
height
=
scrollHeight
+
"
px
"
;
}
}
setInputValue
:
function
(
newValue
)
{
this
.
inputNode
.
value
=
newValue
;
this
.
lastInputValue
=
newValue
;
this
.
completeNode
.
value
=
"
"
;
this
.
resizeInput
(
)
;
this
.
_inputChanged
=
true
;
this
.
emit
(
"
set
-
input
-
value
"
)
;
}
getInputValue
:
function
(
)
{
return
this
.
inputNode
.
value
|
|
"
"
;
}
_inputEventHandler
:
function
(
)
{
if
(
this
.
lastInputValue
!
=
this
.
getInputValue
(
)
)
{
this
.
resizeInput
(
)
;
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
;
this
.
lastInputValue
=
this
.
getInputValue
(
)
;
this
.
_inputChanged
=
true
;
}
}
_blurEventHandler
:
function
(
)
{
if
(
this
.
autocompletePopup
)
{
this
.
clearCompletion
(
)
;
}
}
_keyPress
:
function
(
event
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
let
inputUpdated
=
false
;
if
(
event
.
ctrlKey
)
{
switch
(
event
.
charCode
)
{
case
101
:
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
break
;
}
let
lineEndPos
=
inputValue
.
length
;
if
(
this
.
hasMultilineInput
(
)
)
{
for
(
let
i
=
inputNode
.
selectionEnd
;
i
<
lineEndPos
;
i
+
+
)
{
if
(
inputValue
.
charAt
(
i
)
=
=
"
\
r
"
|
|
inputValue
.
charAt
(
i
)
=
=
"
\
n
"
)
{
lineEndPos
=
i
;
break
;
}
}
}
inputNode
.
setSelectionRange
(
lineEndPos
lineEndPos
)
;
event
.
preventDefault
(
)
;
this
.
clearCompletion
(
)
;
break
;
case
110
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
case
112
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
default
:
break
;
}
return
;
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
let
autoMultiline
=
Services
.
prefs
.
getBoolPref
(
PREF_AUTO_MULTILINE
)
;
if
(
event
.
shiftKey
|
|
(
!
Debugger
.
isCompilableUnit
(
inputNode
.
value
)
&
&
autoMultiline
)
)
{
return
;
}
}
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_ESCAPE
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
else
if
(
this
.
sidebar
)
{
this
.
_sidebarDestroy
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RETURN
:
if
(
this
.
_autocompletePopupNavigated
&
&
this
.
autocompletePopup
.
isOpen
&
&
this
.
autocompletePopup
.
selectedIndex
>
-
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
{
this
.
execute
(
)
;
this
.
_inputChanged
=
false
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_BACKWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_FORWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEUP
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputScroller
.
scrollTop
=
Math
.
max
(
0
this
.
hud
.
outputScroller
.
scrollTop
-
this
.
hud
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEDOWN
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputScroller
.
scrollTop
=
Math
.
min
(
this
.
hud
.
outputScroller
.
scrollHeight
this
.
hud
.
outputScroller
.
scrollTop
+
this
.
hud
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_HOME
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
0
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputScroller
.
scrollTop
=
0
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_END
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
this
.
autocompletePopup
.
itemCount
-
1
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputScroller
.
scrollTop
=
this
.
hud
.
outputScroller
.
scrollHeight
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_LEFT
:
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RIGHT
:
let
cursorAtTheEnd
=
this
.
inputNode
.
selectionStart
=
=
this
.
inputNode
.
selectionEnd
&
&
this
.
inputNode
.
selectionStart
=
=
inputValue
.
length
;
let
haveSuggestion
=
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
;
let
useCompletion
=
cursorAtTheEnd
|
|
this
.
_autocompletePopupNavigated
;
if
(
haveSuggestion
&
&
useCompletion
&
&
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
.
value
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_TAB
:
if
(
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
else
if
(
this
.
_inputChanged
)
{
this
.
updateCompleteNode
(
l10n
.
getStr
(
"
Autocomplete
.
blank
"
)
)
;
event
.
preventDefault
(
)
;
}
break
;
default
:
break
;
}
}
_focusEventHandler
:
function
(
)
{
this
.
_inputChanged
=
false
;
}
historyPeruse
:
function
(
direction
)
{
if
(
!
this
.
history
.
length
)
{
return
false
;
}
if
(
direction
=
=
HISTORY_BACK
)
{
if
(
this
.
historyPlaceHolder
<
=
0
)
{
return
false
;
}
let
inputVal
=
this
.
history
[
-
-
this
.
historyPlaceHolder
]
;
if
(
this
.
historyPlaceHolder
+
1
=
=
this
.
historyIndex
)
{
this
.
history
[
this
.
historyIndex
]
=
this
.
getInputValue
(
)
|
|
"
"
;
}
this
.
setInputValue
(
inputVal
)
;
}
else
if
(
direction
=
=
HISTORY_FORWARD
)
{
if
(
this
.
historyPlaceHolder
>
=
(
this
.
history
.
length
-
1
)
)
{
return
false
;
}
let
inputVal
=
this
.
history
[
+
+
this
.
historyPlaceHolder
]
;
this
.
setInputValue
(
inputVal
)
;
}
else
{
throw
new
Error
(
"
Invalid
argument
0
"
)
;
}
return
true
;
}
hasMultilineInput
:
function
(
)
{
return
/
[
\
r
\
n
]
/
.
test
(
this
.
getInputValue
(
)
)
;
}
canCaretGoPrevious
:
function
(
)
{
let
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
let
multiline
=
/
[
\
r
\
n
]
/
.
test
(
node
.
value
)
;
return
node
.
selectionStart
=
=
0
?
true
:
node
.
selectionStart
=
=
node
.
value
.
length
&
&
!
multiline
;
}
canCaretGoNext
:
function
(
)
{
let
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
let
multiline
=
/
[
\
r
\
n
]
/
.
test
(
node
.
value
)
;
return
node
.
selectionStart
=
=
node
.
value
.
length
?
true
:
node
.
selectionStart
=
=
0
&
&
!
multiline
;
}
complete
:
function
(
type
callback
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
let
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
!
inputValue
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
inputNode
.
selectionStart
!
=
inputNode
.
selectionEnd
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
this
.
lastCompletion
.
value
!
=
inputValue
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_updateCompletionResult
(
type
callback
)
;
return
false
;
}
let
popup
=
this
.
autocompletePopup
;
let
accepted
=
false
;
if
(
type
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
accepted
=
true
;
}
else
if
(
type
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEUP
)
{
popup
.
selectPreviousPageItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEDOWN
)
{
popup
.
selectNextPageItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
accepted
|
|
popup
.
itemCount
>
0
;
}
_updateCompletionResult
:
function
(
type
callback
)
{
let
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
this
.
lastCompletion
.
value
=
=
this
.
getInputValue
(
)
&
&
frameActor
=
=
this
.
_lastFrameActorId
)
{
return
;
}
let
requestId
=
gSequenceId
(
)
;
let
cursor
=
this
.
inputNode
.
selectionStart
;
let
input
=
this
.
getInputValue
(
)
.
substring
(
0
cursor
)
;
let
cache
=
this
.
_autocompleteCache
;
if
(
!
/
[
a
-
zA
-
Z0
-
9
]
/
.
test
(
input
)
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_autocompleteQuery
=
null
;
this
.
_autocompleteCache
=
null
;
}
if
(
this
.
_autocompleteQuery
&
&
input
.
startsWith
(
this
.
_autocompleteQuery
)
)
{
let
filterBy
=
input
;
let
lastNonAlpha
=
input
.
match
(
/
[
^
a
-
zA
-
Z0
-
9_
]
[
a
-
zA
-
Z0
-
9_
]
*
/
)
;
if
(
lastNonAlpha
)
{
filterBy
=
input
.
substring
(
input
.
lastIndexOf
(
lastNonAlpha
)
+
1
)
;
}
let
newList
=
cache
.
sort
(
)
.
filter
(
function
(
l
)
{
return
l
.
startsWith
(
filterBy
)
;
}
)
;
this
.
lastCompletion
=
{
requestId
:
null
completionType
:
type
value
:
null
}
;
let
response
=
{
matches
:
newList
matchProp
:
filterBy
}
;
this
.
_receiveAutocompleteProperties
(
null
callback
response
)
;
return
;
}
this
.
_lastFrameActorId
=
frameActor
;
this
.
lastCompletion
=
{
requestId
:
requestId
completionType
:
type
value
:
null
}
;
let
autocompleteCallback
=
this
.
_receiveAutocompleteProperties
.
bind
(
this
requestId
callback
)
;
this
.
webConsoleClient
.
autocomplete
(
input
cursor
autocompleteCallback
frameActor
)
;
}
_receiveAutocompleteProperties
:
function
(
requestId
callback
message
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
if
(
this
.
lastCompletion
.
value
=
=
inputValue
|
|
requestId
!
=
this
.
lastCompletion
.
requestId
)
{
return
;
}
let
cursor
=
inputNode
.
selectionStart
;
let
inputUntilCursor
=
inputValue
.
substring
(
0
cursor
)
;
if
(
requestId
!
=
null
&
&
/
[
a
-
zA
-
Z0
-
9
.
]
/
.
test
(
inputUntilCursor
)
)
{
this
.
_autocompleteCache
=
message
.
matches
;
this
.
_autocompleteQuery
=
inputUntilCursor
;
}
let
matches
=
message
.
matches
;
let
lastPart
=
message
.
matchProp
;
if
(
!
matches
.
length
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
;
}
let
items
=
matches
.
reverse
(
)
.
map
(
function
(
match
)
{
return
{
preLabel
:
lastPart
label
:
match
}
;
}
)
;
let
popup
=
this
.
autocompletePopup
;
popup
.
setItems
(
items
)
;
let
completionType
=
this
.
lastCompletion
.
completionType
;
this
.
lastCompletion
=
{
value
:
inputValue
matchProp
:
lastPart
}
;
if
(
items
.
length
>
1
&
&
!
popup
.
isOpen
)
{
let
str
=
this
.
getInputValue
(
)
.
substr
(
0
this
.
inputNode
.
selectionStart
)
;
let
offset
=
str
.
length
-
(
str
.
lastIndexOf
(
"
\
n
"
)
+
1
)
-
lastPart
.
length
;
let
x
=
offset
*
this
.
_inputCharWidth
;
popup
.
openPopup
(
inputNode
x
+
this
.
_chevronWidth
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
else
if
(
items
.
length
<
2
&
&
popup
.
isOpen
)
{
popup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
if
(
items
.
length
=
=
1
)
{
popup
.
selectedIndex
=
0
;
}
this
.
onAutocompleteSelect
(
)
;
if
(
completionType
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
}
onAutocompleteSelect
:
function
(
)
{
if
(
this
.
inputNode
.
selectionStart
!
=
this
.
getInputValue
(
)
.
length
)
{
return
;
}
let
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
let
suffix
=
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
;
this
.
updateCompleteNode
(
suffix
)
;
}
else
{
this
.
updateCompleteNode
(
"
"
)
;
}
}
clearCompletion
:
function
(
)
{
this
.
autocompletePopup
.
clearItems
(
)
;
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
updateCompleteNode
(
"
"
)
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
inputNode
.
blur
(
)
;
this
.
autocompletePopup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
this
.
inputNode
.
focus
(
)
;
}
)
;
this
.
autocompletePopup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
}
acceptProposedCompletion
:
function
(
)
{
let
updated
=
false
;
let
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
let
suffix
=
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
;
let
cursor
=
this
.
inputNode
.
selectionStart
;
let
value
=
this
.
getInputValue
(
)
;
this
.
setInputValue
(
value
.
substr
(
0
cursor
)
+
suffix
+
value
.
substr
(
cursor
)
)
;
let
newCursor
=
cursor
+
suffix
.
length
;
this
.
inputNode
.
selectionStart
=
this
.
inputNode
.
selectionEnd
=
newCursor
;
updated
=
true
;
}
this
.
clearCompletion
(
)
;
return
updated
;
}
updateCompleteNode
:
function
(
suffix
)
{
let
prefix
=
suffix
?
this
.
getInputValue
(
)
.
replace
(
/
[
\
S
]
/
g
"
"
)
:
"
"
;
this
.
completeNode
.
value
=
prefix
+
suffix
;
}
_updateCharSize
:
function
(
)
{
let
doc
=
this
.
hud
.
document
;
let
tempLabel
=
doc
.
createElementNS
(
XHTML_NS
"
span
"
)
;
let
style
=
tempLabel
.
style
;
style
.
position
=
"
fixed
"
;
style
.
padding
=
"
0
"
;
style
.
margin
=
"
0
"
;
style
.
width
=
"
auto
"
;
style
.
color
=
"
transparent
"
;
WebConsoleUtils
.
copyTextStyles
(
this
.
inputNode
tempLabel
)
;
tempLabel
.
textContent
=
"
x
"
;
doc
.
documentElement
.
appendChild
(
tempLabel
)
;
this
.
_inputCharWidth
=
tempLabel
.
offsetWidth
;
tempLabel
.
remove
(
)
;
this
.
_chevronWidth
=
+
doc
.
defaultView
.
getComputedStyle
(
this
.
inputNode
)
.
paddingLeft
.
replace
(
/
[
^
0
-
9
.
]
/
g
"
"
)
-
4
;
}
getNotificationBox
:
function
(
)
{
if
(
this
.
_notificationBox
)
{
return
this
.
_notificationBox
;
}
let
box
=
this
.
hud
.
document
.
getElementById
(
"
webconsole
-
notificationbox
"
)
;
if
(
box
.
tagName
=
=
=
"
notificationbox
"
)
{
return
box
;
}
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
this
.
_notificationBox
=
Object
.
assign
(
toolbox
.
ReactDOM
.
render
(
toolbox
.
React
.
createElement
(
NotificationBox
)
box
)
PriorityLevels
)
;
return
this
.
_notificationBox
;
}
_sidebarDestroy
:
function
(
)
{
if
(
this
.
_variablesView
)
{
this
.
_variablesView
.
controller
.
releaseActors
(
)
;
this
.
_variablesView
=
null
;
}
if
(
this
.
sidebar
)
{
this
.
sidebar
.
hide
(
)
;
this
.
sidebar
.
destroy
(
)
;
this
.
sidebar
=
null
;
}
this
.
emit
(
"
sidebar
-
closed
"
)
;
}
destroy
:
function
(
)
{
this
.
_sidebarDestroy
(
)
;
this
.
clearCompletion
(
)
;
if
(
this
.
hud
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
this
.
hud
.
outputNode
.
innerHTML
=
"
"
;
}
else
{
this
.
clearOutput
(
)
;
}
this
.
autocompletePopup
.
destroy
(
)
;
this
.
autocompletePopup
=
null
;
if
(
this
.
_onPaste
)
{
this
.
inputNode
.
removeEventListener
(
"
paste
"
this
.
_onPaste
)
;
this
.
inputNode
.
removeEventListener
(
"
drop
"
this
.
_onPaste
)
;
this
.
_onPaste
=
null
;
}
this
.
inputNode
.
removeEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
removeEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
removeEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
removeEventListener
(
"
focus
"
this
.
_focusEventHandler
)
;
this
.
hud
.
window
.
removeEventListener
(
"
blur
"
this
.
_blurEventHandler
)
;
this
.
hud
=
null
;
}
}
;
function
gSequenceId
(
)
{
return
gSequenceId
.
n
+
+
;
}
gSequenceId
.
n
=
0
;
exports
.
gSequenceId
=
gSequenceId
;
function
simpleValueEvalMacro
(
item
currentString
)
{
return
VariablesView
.
simpleValueEvalMacro
(
item
currentString
"
_self
"
)
;
}
function
overrideValueEvalMacro
(
item
currentString
)
{
return
VariablesView
.
overrideValueEvalMacro
(
item
currentString
"
_self
"
)
;
}
function
getterOrSetterEvalMacro
(
item
currentString
)
{
return
VariablesView
.
getterOrSetterEvalMacro
(
item
currentString
"
_self
"
)
;
}
exports
.
JSTerm
=
JSTerm
;
