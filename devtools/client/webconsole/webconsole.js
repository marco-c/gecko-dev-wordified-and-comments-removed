"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
Utils
:
WebConsoleUtils
CONSOLE_WORKER_IDS
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
{
getSourceNames
}
=
require
(
"
devtools
/
client
/
shared
/
source
-
utils
"
)
;
const
BrowserLoaderModule
=
{
}
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
BrowserLoaderModule
)
;
const
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
ErrorDocs
=
require
(
"
devtools
/
server
/
actors
/
errordocs
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolSidebar
"
"
devtools
/
client
/
framework
/
sidebar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleOutput
"
"
devtools
/
client
/
webconsole
/
console
-
output
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Messages
"
"
devtools
/
client
/
webconsole
/
console
-
output
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentClient
"
"
devtools
/
shared
/
client
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
system
"
"
devtools
/
shared
/
system
"
)
;
loader
.
lazyRequireGetter
(
this
"
JSTerm
"
"
devtools
/
client
/
webconsole
/
jsterm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gSequenceId
"
"
devtools
/
client
/
webconsole
/
jsterm
"
true
)
;
loader
.
lazyImporter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
VariablesViewController
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ZoomKeys
"
"
devtools
/
client
/
shared
/
zoom
-
keys
"
)
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
const
STRINGS_URI
=
"
devtools
/
client
/
locales
/
webconsole
.
properties
"
;
var
l10n
=
new
WebConsoleUtils
.
L10n
(
STRINGS_URI
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
MIXED_CONTENT_LEARN_MORE
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
Security
/
Mixed_content
"
;
const
IGNORED_SOURCE_URLS
=
[
"
debugger
eval
code
"
]
;
const
SEARCH_DELAY
=
200
;
const
DEFAULT_LOG_LIMIT
=
1000
;
const
CATEGORY_NETWORK
=
0
;
const
CATEGORY_CSS
=
1
;
const
CATEGORY_JS
=
2
;
const
CATEGORY_WEBDEV
=
3
;
const
CATEGORY_INPUT
=
4
;
const
CATEGORY_OUTPUT
=
5
;
const
CATEGORY_SECURITY
=
6
;
const
CATEGORY_SERVER
=
7
;
const
SEVERITY_ERROR
=
0
;
const
SEVERITY_WARNING
=
1
;
const
SEVERITY_INFO
=
2
;
const
SEVERITY_LOG
=
3
;
const
CATEGORY_CLASS_FRAGMENTS
=
[
"
network
"
"
cssparser
"
"
exception
"
"
console
"
"
input
"
"
output
"
"
security
"
"
server
"
]
;
const
SEVERITY_CLASS_FRAGMENTS
=
[
"
error
"
"
warn
"
"
info
"
"
log
"
]
;
const
MESSAGE_PREFERENCE_KEYS
=
[
[
"
network
"
"
netwarn
"
"
netxhr
"
"
networkinfo
"
]
[
"
csserror
"
"
cssparser
"
null
"
csslog
"
]
[
"
exception
"
"
jswarn
"
null
"
jslog
"
]
[
"
error
"
"
warn
"
"
info
"
"
log
"
]
[
null
null
null
null
]
[
null
null
null
null
]
[
"
secerror
"
"
secwarn
"
null
null
]
[
"
servererror
"
"
serverwarn
"
"
serverinfo
"
"
serverlog
"
]
]
;
const
LEVELS
=
{
error
:
SEVERITY_ERROR
exception
:
SEVERITY_ERROR
assert
:
SEVERITY_ERROR
warn
:
SEVERITY_WARNING
info
:
SEVERITY_INFO
log
:
SEVERITY_LOG
clear
:
SEVERITY_LOG
trace
:
SEVERITY_LOG
table
:
SEVERITY_LOG
debug
:
SEVERITY_LOG
dir
:
SEVERITY_LOG
dirxml
:
SEVERITY_LOG
group
:
SEVERITY_LOG
groupCollapsed
:
SEVERITY_LOG
groupEnd
:
SEVERITY_LOG
time
:
SEVERITY_LOG
timeEnd
:
SEVERITY_LOG
count
:
SEVERITY_LOG
}
;
const
WORKERTYPES_PREFKEYS
=
[
"
sharedworkers
"
"
serviceworkers
"
"
windowlessworkers
"
]
;
const
MIN_HTTP_ERROR_CODE
=
400
;
const
MAX_HTTP_ERROR_CODE
=
599
;
const
GROUP_INDENT
=
12
;
const
MESSAGES_IN_INTERVAL
=
DEFAULT_LOG_LIMIT
;
const
OUTPUT_INTERVAL
=
20
;
const
MAX_CLEANUP_TIME
=
10
;
const
THROTTLE_UPDATES
=
1000
;
const
FILTER_PREFS_PREFIX
=
"
devtools
.
webconsole
.
filter
.
"
;
const
MIN_FONT_SIZE
=
10
;
const
PREF_CONNECTION_TIMEOUT
=
"
devtools
.
debugger
.
remote
-
timeout
"
;
const
PREF_PERSISTLOG
=
"
devtools
.
webconsole
.
persistlog
"
;
const
PREF_MESSAGE_TIMESTAMP
=
"
devtools
.
webconsole
.
timestampMessages
"
;
const
PREF_NEW_FRONTEND_ENABLED
=
"
devtools
.
webconsole
.
new
-
frontend
-
enabled
"
;
function
WebConsoleFrame
(
webConsoleOwner
)
{
this
.
owner
=
webConsoleOwner
;
this
.
hudId
=
this
.
owner
.
hudId
;
this
.
isBrowserConsole
=
this
.
owner
.
_browserConsole
;
this
.
window
=
this
.
owner
.
iframeWindow
;
this
.
_repeatNodes
=
{
}
;
this
.
_outputQueue
=
[
]
;
this
.
_itemDestroyQueue
=
[
]
;
this
.
_pruneCategoriesQueue
=
{
}
;
this
.
filterPrefs
=
{
}
;
this
.
output
=
new
ConsoleOutput
(
this
)
;
this
.
unmountMessage
=
this
.
unmountMessage
.
bind
(
this
)
;
this
.
_toggleFilter
=
this
.
_toggleFilter
.
bind
(
this
)
;
this
.
resize
=
this
.
resize
.
bind
(
this
)
;
this
.
_onPanelSelected
=
this
.
_onPanelSelected
.
bind
(
this
)
;
this
.
_flushMessageQueue
=
this
.
_flushMessageQueue
.
bind
(
this
)
;
this
.
_onToolboxPrefChanged
=
this
.
_onToolboxPrefChanged
.
bind
(
this
)
;
this
.
_onUpdateListeners
=
this
.
_onUpdateListeners
.
bind
(
this
)
;
this
.
_outputTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_outputTimerInitialized
=
false
;
let
require
=
BrowserLoaderModule
.
BrowserLoader
(
{
window
:
this
.
window
useOnlyShared
:
true
}
)
.
require
;
this
.
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
this
.
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
this
.
FrameView
=
this
.
React
.
createFactory
(
require
(
"
devtools
/
client
/
shared
/
components
/
frame
"
)
)
;
this
.
StackTraceView
=
this
.
React
.
createFactory
(
require
(
"
devtools
/
client
/
shared
/
components
/
stack
-
trace
"
)
)
;
this
.
_telemetry
=
new
Telemetry
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
WebConsoleFrame
=
WebConsoleFrame
;
WebConsoleFrame
.
prototype
=
{
owner
:
null
proxy
:
null
get
popupset
(
)
{
return
this
.
owner
.
mainPopupSet
;
}
_initDefer
:
null
_lastOutputFlush
:
0
_outputQueue
:
null
_pruneCategoriesQueue
:
null
_flushCallback
:
null
_outputTimer
:
null
_outputTimerInitialized
:
null
_repeatNodes
:
null
filterPrefs
:
null
_filterPrefsPrefix
:
FILTER_PREFS_PREFIX
groupDepth
:
0
contentLocation
:
"
"
jsterm
:
null
outputNode
:
null
output
:
null
filterBox
:
null
get
webConsoleClient
(
)
{
return
this
.
proxy
?
this
.
proxy
.
webConsoleClient
:
null
;
}
_destroyer
:
null
_saveRequestAndResponseBodies
:
true
_throttleData
:
null
_chevronWidth
:
0
_inputCharWidth
:
0
setSaveRequestAndResponseBodies
:
function
(
value
)
{
if
(
!
this
.
webConsoleClient
)
{
return
promise
.
resolve
(
null
)
;
}
let
deferred
=
promise
.
defer
(
)
;
let
newValue
=
!
!
value
;
let
toSet
=
{
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
:
newValue
}
;
this
.
webConsoleClient
.
setPreferences
(
toSet
response
=
>
{
if
(
!
response
.
error
)
{
this
.
_saveRequestAndResponseBodies
=
newValue
;
deferred
.
resolve
(
response
)
;
}
else
{
deferred
.
reject
(
response
.
error
)
;
}
}
)
;
return
deferred
.
promise
;
}
setThrottleData
:
function
(
value
)
{
if
(
!
this
.
webConsoleClient
)
{
return
promise
.
resolve
(
null
)
;
}
let
deferred
=
promise
.
defer
(
)
;
let
toSet
=
{
"
NetworkMonitor
.
throttleData
"
:
value
}
;
this
.
webConsoleClient
.
setPreferences
(
toSet
response
=
>
{
if
(
!
response
.
error
)
{
this
.
_throttleData
=
value
;
deferred
.
resolve
(
response
)
;
}
else
{
deferred
.
reject
(
response
.
error
)
;
}
}
)
;
return
deferred
.
promise
;
}
get
persistLog
(
)
{
return
this
.
isBrowserConsole
|
|
Services
.
prefs
.
getBoolPref
(
PREF_PERSISTLOG
)
;
}
init
:
function
(
)
{
this
.
_initUI
(
)
;
let
connectionInited
=
this
.
_initConnection
(
)
;
let
allReady
=
this
.
jsterm
.
historyLoaded
.
catch
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
return
connectionInited
;
}
)
;
let
notifyObservers
=
(
)
=
>
{
let
id
=
WebConsoleUtils
.
supportsString
(
this
.
hudId
)
;
Services
.
obs
.
notifyObservers
(
id
"
web
-
console
-
created
"
null
)
;
}
;
allReady
.
then
(
notifyObservers
notifyObservers
)
;
if
(
this
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
allReady
.
then
(
this
.
newConsoleOutput
.
init
)
;
}
return
allReady
;
}
_initConnection
:
function
(
)
{
if
(
this
.
_initDefer
)
{
return
this
.
_initDefer
.
promise
;
}
this
.
_initDefer
=
promise
.
defer
(
)
;
this
.
proxy
=
new
WebConsoleConnectionProxy
(
this
this
.
owner
.
target
)
;
this
.
proxy
.
connect
(
)
.
then
(
(
)
=
>
{
this
.
_initDefer
.
resolve
(
this
)
;
}
(
reason
)
=
>
{
let
node
=
this
.
createMessageNode
(
CATEGORY_JS
SEVERITY_ERROR
reason
.
error
+
"
:
"
+
reason
.
message
)
;
this
.
outputMessage
(
CATEGORY_JS
node
[
reason
]
)
;
this
.
_initDefer
.
reject
(
reason
)
;
}
)
;
return
this
.
_initDefer
.
promise
;
}
_initUI
:
function
(
)
{
this
.
document
=
this
.
window
.
document
;
this
.
rootElement
=
this
.
document
.
documentElement
;
this
.
NEW_CONSOLE_OUTPUT_ENABLED
=
!
this
.
isBrowserConsole
&
&
!
this
.
owner
.
target
.
chrome
&
&
Services
.
prefs
.
getBoolPref
(
PREF_NEW_FRONTEND_ENABLED
)
;
this
.
outputNode
=
this
.
document
.
getElementById
(
"
output
-
container
"
)
;
this
.
outputWrapper
=
this
.
document
.
getElementById
(
"
output
-
wrapper
"
)
;
this
.
completeNode
=
this
.
document
.
querySelector
(
"
.
jsterm
-
complete
-
node
"
)
;
this
.
inputNode
=
this
.
document
.
querySelector
(
"
.
jsterm
-
input
-
node
"
)
;
this
.
outputScroller
=
this
.
outputWrapper
;
this
.
_updateCharSize
(
)
;
this
.
jsterm
=
new
JSTerm
(
this
)
;
this
.
jsterm
.
init
(
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
if
(
this
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
window
.
jsterm
=
this
.
jsterm
;
this
.
outputWrapper
.
removeAttribute
(
"
context
"
)
;
this
.
experimentalOutputNode
=
this
.
outputNode
.
cloneNode
(
)
;
this
.
experimentalOutputNode
.
removeAttribute
(
"
tabindex
"
)
;
this
.
outputNode
.
hidden
=
true
;
this
.
outputNode
.
parentNode
.
appendChild
(
this
.
experimentalOutputNode
)
;
this
.
newConsoleOutput
=
new
this
.
window
.
NewConsoleOutput
(
this
.
experimentalOutputNode
this
.
jsterm
toolbox
this
.
owner
this
.
document
)
;
let
filterToolbar
=
this
.
document
.
querySelector
(
"
.
hud
-
console
-
filter
-
toolbar
"
)
;
filterToolbar
.
hidden
=
true
;
}
else
{
this
.
_commandController
=
new
CommandController
(
this
)
;
this
.
window
.
controllers
.
insertControllerAt
(
0
this
.
_commandController
)
;
this
.
_contextMenuHandler
=
new
ConsoleContextMenu
(
this
)
;
this
.
_initDefaultFilterPrefs
(
)
;
this
.
filterBox
=
this
.
document
.
querySelector
(
"
.
hud
-
filter
-
box
"
)
;
this
.
_setFilterTextBoxEvents
(
)
;
this
.
_initFilterButtons
(
)
;
let
clearButton
=
this
.
document
.
getElementsByClassName
(
"
webconsole
-
clear
-
console
-
button
"
)
[
0
]
;
clearButton
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
owner
.
_onClearButton
(
)
;
this
.
jsterm
.
clearOutput
(
true
)
;
}
)
;
}
this
.
resize
(
)
;
this
.
window
.
addEventListener
(
"
resize
"
this
.
resize
true
)
;
this
.
jsterm
.
on
(
"
sidebar
-
opened
"
this
.
resize
)
;
this
.
jsterm
.
on
(
"
sidebar
-
closed
"
this
.
resize
)
;
if
(
toolbox
)
{
toolbox
.
on
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
}
this
.
outputWrapper
.
addEventListener
(
"
click
"
(
event
)
=
>
{
if
(
event
.
detail
!
=
=
1
|
|
event
.
button
!
=
=
0
)
{
return
;
}
let
selection
=
this
.
window
.
getSelection
(
)
;
if
(
selection
&
&
!
selection
.
isCollapsed
)
{
return
;
}
if
(
event
.
target
.
nodeName
.
toLowerCase
(
)
=
=
=
"
a
"
|
|
event
.
target
.
parentNode
.
nodeName
.
toLowerCase
(
)
=
=
=
"
a
"
)
{
return
;
}
if
(
this
.
NEW_CONSOLE_OUTPUT_ENABLED
&
&
event
.
target
.
nodeName
.
toLowerCase
(
)
=
=
=
"
input
"
&
&
event
.
target
.
getAttribute
(
"
type
"
)
.
toLowerCase
(
)
=
=
=
"
search
"
)
{
return
;
}
this
.
jsterm
.
focus
(
)
;
}
)
;
gDevTools
.
on
(
"
pref
-
changed
"
this
.
_onToolboxPrefChanged
)
;
this
.
_onToolboxPrefChanged
(
"
pref
-
changed
"
{
pref
:
PREF_MESSAGE_TIMESTAMP
newValue
:
Services
.
prefs
.
getBoolPref
(
PREF_MESSAGE_TIMESTAMP
)
}
)
;
this
.
_initShortcuts
(
)
;
this
.
jsterm
.
focus
(
)
;
}
resize
:
function
(
)
{
if
(
this
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
experimentalOutputNode
.
style
.
width
=
this
.
outputWrapper
.
clientWidth
+
"
px
"
;
}
else
{
this
.
outputNode
.
style
.
width
=
this
.
outputWrapper
.
clientWidth
+
"
px
"
;
}
}
_onPanelSelected
:
function
(
)
{
this
.
jsterm
.
focus
(
)
;
}
_initDefaultFilterPrefs
:
function
(
)
{
let
prefs
=
[
"
network
"
"
networkinfo
"
"
csserror
"
"
cssparser
"
"
csslog
"
"
exception
"
"
jswarn
"
"
jslog
"
"
error
"
"
info
"
"
warn
"
"
log
"
"
secerror
"
"
secwarn
"
"
netwarn
"
"
netxhr
"
"
sharedworkers
"
"
serviceworkers
"
"
windowlessworkers
"
"
servererror
"
"
serverwarn
"
"
serverinfo
"
"
serverlog
"
]
;
for
(
let
pref
of
prefs
)
{
this
.
filterPrefs
[
pref
]
=
Services
.
prefs
.
getBoolPref
(
this
.
_filterPrefsPrefix
+
pref
)
;
}
}
_initShortcuts
:
function
(
)
{
var
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
window
}
)
;
shortcuts
.
on
(
l10n
.
getStr
(
"
webconsole
.
find
.
key
"
)
(
name
event
)
=
>
{
this
.
filterBox
.
focus
(
)
;
event
.
preventDefault
(
)
;
}
)
;
let
clearShortcut
;
if
(
system
.
constants
.
platform
=
=
=
"
macosx
"
)
{
clearShortcut
=
l10n
.
getStr
(
"
webconsole
.
clear
.
keyOSX
"
)
;
}
else
{
clearShortcut
=
l10n
.
getStr
(
"
webconsole
.
clear
.
key
"
)
;
}
shortcuts
.
on
(
clearShortcut
(
)
=
>
this
.
jsterm
.
clearOutput
(
true
)
)
;
if
(
this
.
isBrowserConsole
)
{
shortcuts
.
on
(
l10n
.
getStr
(
"
webconsole
.
close
.
key
"
)
this
.
window
.
close
.
bind
(
this
.
window
)
)
;
ZoomKeys
.
register
(
this
.
window
)
;
}
}
_updateReflowActivityListener
:
function
(
callback
)
{
if
(
this
.
webConsoleClient
)
{
let
pref
=
this
.
_filterPrefsPrefix
+
"
csslog
"
;
if
(
Services
.
prefs
.
getBoolPref
(
pref
)
)
{
this
.
webConsoleClient
.
startListeners
(
[
"
ReflowActivity
"
]
callback
)
;
}
else
{
this
.
webConsoleClient
.
stopListeners
(
[
"
ReflowActivity
"
]
callback
)
;
}
}
}
_updateServerLoggingListener
:
function
(
callback
)
{
if
(
!
this
.
webConsoleClient
)
{
return
null
;
}
let
startListener
=
false
;
let
prefs
=
[
"
servererror
"
"
serverwarn
"
"
serverinfo
"
"
serverlog
"
]
;
for
(
let
i
=
0
;
i
<
prefs
.
length
;
i
+
+
)
{
if
(
this
.
filterPrefs
[
prefs
[
i
]
]
)
{
startListener
=
true
;
break
;
}
}
if
(
startListener
)
{
this
.
webConsoleClient
.
startListeners
(
[
"
ServerLogging
"
]
callback
)
;
}
else
{
this
.
webConsoleClient
.
stopListeners
(
[
"
ServerLogging
"
]
callback
)
;
}
}
_setFilterTextBoxEvents
:
function
(
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
timerEvent
=
this
.
adjustVisibilityOnSearchStringChange
.
bind
(
this
)
;
let
onChange
=
function
_onChange
(
)
{
timer
.
cancel
(
)
;
timer
.
initWithCallback
(
timerEvent
SEARCH_DELAY
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
;
this
.
filterBox
.
addEventListener
(
"
command
"
onChange
false
)
;
this
.
filterBox
.
addEventListener
(
"
input
"
onChange
false
)
;
}
_initFilterButtons
:
function
(
)
{
let
categories
=
this
.
document
.
querySelectorAll
(
"
.
webconsole
-
filter
-
button
[
category
]
"
)
;
Array
.
forEach
(
categories
function
(
button
)
{
button
.
addEventListener
(
"
contextmenu
"
(
)
=
>
{
button
.
open
=
true
;
}
false
)
;
button
.
addEventListener
(
"
click
"
this
.
_toggleFilter
false
)
;
let
someChecked
=
false
;
let
severities
=
button
.
querySelectorAll
(
"
menuitem
[
prefKey
]
"
)
;
Array
.
forEach
(
severities
function
(
menuItem
)
{
menuItem
.
addEventListener
(
"
command
"
this
.
_toggleFilter
false
)
;
let
prefKey
=
menuItem
.
getAttribute
(
"
prefKey
"
)
;
let
checked
=
this
.
filterPrefs
[
prefKey
]
;
menuItem
.
setAttribute
(
"
checked
"
checked
)
;
someChecked
=
someChecked
|
|
checked
;
}
this
)
;
button
.
setAttribute
(
"
checked
"
someChecked
)
;
button
.
setAttribute
(
"
aria
-
pressed
"
someChecked
)
;
}
this
)
;
if
(
!
this
.
isBrowserConsole
)
{
let
jslog
=
this
.
document
.
querySelector
(
"
menuitem
[
prefKey
=
jslog
]
"
)
;
jslog
.
hidden
=
true
;
}
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
)
{
let
net
=
this
.
document
.
querySelector
(
"
toolbarbutton
[
category
=
net
]
"
)
;
let
accesskey
=
net
.
getAttribute
(
"
accesskeyMacOSX
"
)
;
net
.
setAttribute
(
"
accesskey
"
accesskey
)
;
let
logging
=
this
.
document
.
querySelector
(
"
toolbarbutton
[
category
=
logging
]
"
)
;
logging
.
removeAttribute
(
"
accesskey
"
)
;
let
serverLogging
=
this
.
document
.
querySelector
(
"
toolbarbutton
[
category
=
server
]
"
)
;
serverLogging
.
removeAttribute
(
"
accesskey
"
)
;
}
}
_updateCharSize
:
function
(
)
{
let
doc
=
this
.
document
;
let
tempLabel
=
doc
.
createElementNS
(
XHTML_NS
"
span
"
)
;
let
style
=
tempLabel
.
style
;
style
.
position
=
"
fixed
"
;
style
.
padding
=
"
0
"
;
style
.
margin
=
"
0
"
;
style
.
width
=
"
auto
"
;
style
.
color
=
"
transparent
"
;
WebConsoleUtils
.
copyTextStyles
(
this
.
inputNode
tempLabel
)
;
tempLabel
.
textContent
=
"
x
"
;
doc
.
documentElement
.
appendChild
(
tempLabel
)
;
this
.
_inputCharWidth
=
tempLabel
.
offsetWidth
;
tempLabel
.
parentNode
.
removeChild
(
tempLabel
)
;
this
.
_chevronWidth
=
+
doc
.
defaultView
.
getComputedStyle
(
this
.
inputNode
)
.
paddingLeft
.
replace
(
/
[
^
0
-
9
.
]
/
g
"
"
)
-
4
;
}
_toggleFilter
:
function
(
event
)
{
let
target
=
event
.
target
;
let
tagName
=
target
.
tagName
;
let
isRightClick
=
(
event
.
button
=
=
=
2
)
;
if
(
tagName
!
=
event
.
currentTarget
.
tagName
|
|
isRightClick
)
{
return
;
}
switch
(
tagName
)
{
case
"
toolbarbutton
"
:
{
let
originalTarget
=
event
.
originalTarget
;
let
classes
=
originalTarget
.
classList
;
if
(
originalTarget
.
localName
!
=
=
"
toolbarbutton
"
)
{
break
;
}
if
(
!
classes
.
contains
(
"
toolbarbutton
-
menubutton
-
button
"
)
&
&
originalTarget
.
getAttribute
(
"
type
"
)
=
=
=
"
menu
-
button
"
)
{
break
;
}
let
state
=
target
.
getAttribute
(
"
checked
"
)
!
=
=
"
true
"
;
if
(
event
.
getModifierState
(
"
Alt
"
)
)
{
let
buttons
=
this
.
document
.
querySelectorAll
(
"
.
webconsole
-
filter
-
button
"
)
;
Array
.
forEach
(
buttons
(
button
)
=
>
{
if
(
button
!
=
=
target
)
{
button
.
setAttribute
(
"
checked
"
false
)
;
button
.
setAttribute
(
"
aria
-
pressed
"
false
)
;
this
.
_setMenuState
(
button
false
)
;
}
}
)
;
state
=
true
;
}
target
.
setAttribute
(
"
checked
"
state
)
;
target
.
setAttribute
(
"
aria
-
pressed
"
state
)
;
this
.
_setMenuState
(
target
state
)
;
if
(
target
.
getAttribute
(
"
category
"
)
=
=
"
css
"
&
&
state
)
{
let
csslogMenuItem
=
target
.
querySelector
(
"
menuitem
[
prefKey
=
csslog
]
"
)
;
csslogMenuItem
.
setAttribute
(
"
checked
"
false
)
;
this
.
setFilterState
(
"
csslog
"
false
)
;
}
break
;
}
case
"
menuitem
"
:
{
let
state
=
target
.
getAttribute
(
"
checked
"
)
!
=
=
"
true
"
;
target
.
setAttribute
(
"
checked
"
state
)
;
let
prefKey
=
target
.
getAttribute
(
"
prefKey
"
)
;
this
.
setFilterState
(
prefKey
state
)
;
let
menuPopup
=
target
.
parentNode
;
let
someChecked
=
false
;
let
menuItem
=
menuPopup
.
firstChild
;
while
(
menuItem
)
{
if
(
menuItem
.
hasAttribute
(
"
prefKey
"
)
&
&
menuItem
.
getAttribute
(
"
checked
"
)
=
=
=
"
true
"
)
{
someChecked
=
true
;
break
;
}
menuItem
=
menuItem
.
nextSibling
;
}
let
toolbarButton
=
menuPopup
.
parentNode
;
toolbarButton
.
setAttribute
(
"
checked
"
someChecked
)
;
toolbarButton
.
setAttribute
(
"
aria
-
pressed
"
someChecked
)
;
break
;
}
}
}
_setMenuState
:
function
(
target
state
)
{
let
menuItems
=
target
.
querySelectorAll
(
"
menuitem
"
)
;
Array
.
forEach
(
menuItems
(
item
)
=
>
{
item
.
setAttribute
(
"
checked
"
state
)
;
let
prefKey
=
item
.
getAttribute
(
"
prefKey
"
)
;
this
.
setFilterState
(
prefKey
state
)
;
}
)
;
}
setFilterState
:
function
(
toggleType
state
)
{
this
.
filterPrefs
[
toggleType
]
=
state
;
this
.
adjustVisibilityForMessageType
(
toggleType
state
)
;
Services
.
prefs
.
setBoolPref
(
this
.
_filterPrefsPrefix
+
toggleType
state
)
;
if
(
this
.
_updateListenersTimeout
)
{
clearTimeout
(
this
.
_updateListenersTimeout
)
;
}
this
.
_updateListenersTimeout
=
setTimeout
(
this
.
_onUpdateListeners
200
)
;
}
getFilterState
:
function
(
toggleType
)
{
return
this
.
filterPrefs
[
toggleType
]
;
}
_onUpdateListeners
:
function
(
)
{
this
.
_updateReflowActivityListener
(
)
;
this
.
_updateServerLoggingListener
(
)
;
}
stringMatchesFilters
:
function
(
str
filter
)
{
if
(
!
filter
|
|
!
str
)
{
return
true
;
}
let
searchStr
=
str
.
toLowerCase
(
)
;
let
filterStrings
=
filter
.
toLowerCase
(
)
.
split
(
/
\
s
+
/
)
;
return
!
filterStrings
.
some
(
function
(
f
)
{
return
searchStr
.
indexOf
(
f
)
=
=
-
1
;
}
)
;
}
adjustVisibilityForMessageType
:
function
(
prefKey
state
)
{
let
outputNode
=
this
.
outputNode
;
let
doc
=
this
.
document
;
let
attribute
=
WORKERTYPES_PREFKEYS
.
indexOf
(
prefKey
)
=
=
-
1
?
"
filter
"
:
"
workerType
"
;
let
xpath
=
"
.
/
/
*
[
contains
(
class
'
message
'
)
and
"
+
"
"
+
attribute
+
"
=
'
"
+
prefKey
+
"
'
]
"
;
let
result
=
doc
.
evaluate
(
xpath
outputNode
null
Ci
.
nsIDOMXPathResult
.
UNORDERED_NODE_SNAPSHOT_TYPE
null
)
;
for
(
let
i
=
0
;
i
<
result
.
snapshotLength
;
i
+
+
)
{
let
node
=
result
.
snapshotItem
(
i
)
;
if
(
state
)
{
node
.
classList
.
remove
(
"
filtered
-
by
-
type
"
)
;
}
else
{
node
.
classList
.
add
(
"
filtered
-
by
-
type
"
)
;
}
}
}
adjustVisibilityOnSearchStringChange
:
function
(
)
{
let
nodes
=
this
.
outputNode
.
getElementsByClassName
(
"
message
"
)
;
let
searchString
=
this
.
filterBox
.
value
;
for
(
let
i
=
0
n
=
nodes
.
length
;
i
<
n
;
+
+
i
)
{
let
node
=
nodes
[
i
]
;
let
text
=
node
.
textContent
;
if
(
this
.
stringMatchesFilters
(
text
searchString
)
)
{
node
.
classList
.
remove
(
"
filtered
-
by
-
string
"
)
;
}
else
{
node
.
classList
.
add
(
"
filtered
-
by
-
string
"
)
;
}
}
this
.
resize
(
)
;
}
filterMessageNode
:
function
(
node
)
{
let
isFiltered
=
false
;
let
prefKey
=
MESSAGE_PREFERENCE_KEYS
[
node
.
category
]
[
node
.
severity
]
;
if
(
prefKey
&
&
!
this
.
getFilterState
(
prefKey
)
)
{
node
.
classList
.
add
(
"
filtered
-
by
-
type
"
)
;
isFiltered
=
true
;
}
if
(
"
workerType
"
in
node
&
&
!
this
.
getFilterState
(
node
.
workerType
)
)
{
node
.
classList
.
add
(
"
filtered
-
by
-
type
"
)
;
isFiltered
=
true
;
}
let
search
=
this
.
filterBox
.
value
;
let
text
=
node
.
clipboardText
;
if
(
!
this
.
stringMatchesFilters
(
text
search
)
)
{
node
.
classList
.
add
(
"
filtered
-
by
-
string
"
)
;
isFiltered
=
true
;
}
if
(
isFiltered
&
&
node
.
classList
.
contains
(
"
inlined
-
variables
-
view
"
)
)
{
node
.
classList
.
add
(
"
hidden
-
message
"
)
;
}
return
isFiltered
;
}
mergeFilteredMessageNode
:
function
(
original
)
{
let
repeatNode
=
original
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
!
repeatNode
)
{
return
;
}
let
occurrences
=
parseInt
(
repeatNode
.
getAttribute
(
"
value
"
)
10
)
+
1
;
repeatNode
.
setAttribute
(
"
value
"
occurrences
)
;
repeatNode
.
textContent
=
occurrences
;
let
str
=
l10n
.
getStr
(
"
messageRepeats
.
tooltip2
"
)
;
repeatNode
.
title
=
PluralForm
.
get
(
occurrences
str
)
.
replace
(
"
#
1
"
occurrences
)
;
}
_filterRepeatedMessage
:
function
(
node
)
{
let
repeatNode
=
node
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
!
repeatNode
)
{
return
null
;
}
let
uid
=
repeatNode
.
_uid
;
let
dupeNode
=
null
;
if
(
node
.
category
=
=
CATEGORY_CSS
|
|
node
.
category
=
=
CATEGORY_SECURITY
)
{
dupeNode
=
this
.
_repeatNodes
[
uid
]
;
if
(
!
dupeNode
)
{
this
.
_repeatNodes
[
uid
]
=
node
;
}
}
else
if
(
(
node
.
category
=
=
CATEGORY_WEBDEV
|
|
node
.
category
=
=
CATEGORY_JS
)
&
&
node
.
category
!
=
CATEGORY_NETWORK
&
&
!
node
.
classList
.
contains
(
"
inlined
-
variables
-
view
"
)
)
{
let
lastMessage
=
this
.
outputNode
.
lastChild
;
if
(
!
lastMessage
)
{
return
null
;
}
let
lastRepeatNode
=
lastMessage
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
lastRepeatNode
&
&
lastRepeatNode
.
_uid
=
=
uid
)
{
dupeNode
=
lastMessage
;
}
}
if
(
dupeNode
)
{
this
.
mergeFilteredMessageNode
(
dupeNode
)
;
this
.
unmountMessage
(
node
)
;
return
dupeNode
;
}
return
null
;
}
displayCachedMessages
:
function
(
remoteMessages
)
{
if
(
!
remoteMessages
.
length
)
{
return
;
}
remoteMessages
.
forEach
(
function
(
message
)
{
switch
(
message
.
_type
)
{
case
"
PageError
"
:
{
let
category
=
Utils
.
categoryForScriptError
(
message
)
;
this
.
outputMessage
(
category
this
.
reportPageError
[
category
message
]
)
;
break
;
}
case
"
LogMessage
"
:
this
.
handleLogMessage
(
message
)
;
break
;
case
"
ConsoleAPI
"
:
this
.
outputMessage
(
CATEGORY_WEBDEV
this
.
logConsoleAPIMessage
[
message
]
)
;
break
;
case
"
NetworkEvent
"
:
this
.
outputMessage
(
CATEGORY_NETWORK
this
.
logNetEvent
[
message
]
)
;
break
;
}
}
this
)
;
}
logConsoleAPIMessage
:
function
(
message
)
{
let
body
=
null
;
let
clipboardText
=
null
;
let
sourceURL
=
message
.
filename
;
let
sourceLine
=
message
.
lineNumber
;
let
level
=
message
.
level
;
let
args
=
message
.
arguments
;
let
objectActors
=
new
Set
(
)
;
let
node
=
null
;
args
.
forEach
(
(
value
)
=
>
{
if
(
WebConsoleUtils
.
isActorGrip
(
value
)
)
{
objectActors
.
add
(
value
.
actor
)
;
}
}
)
;
switch
(
level
)
{
case
"
log
"
:
case
"
info
"
:
case
"
warn
"
:
case
"
error
"
:
case
"
exception
"
:
case
"
assert
"
:
case
"
debug
"
:
{
let
msg
=
new
Messages
.
ConsoleGeneric
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
table
"
:
{
let
msg
=
new
Messages
.
ConsoleTable
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
trace
"
:
{
let
msg
=
new
Messages
.
ConsoleTrace
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
clear
"
:
{
body
=
l10n
.
getStr
(
"
consoleCleared
"
)
;
clipboardText
=
body
;
break
;
}
case
"
dir
"
:
{
body
=
{
arguments
:
args
}
;
let
clipboardArray
=
[
]
;
args
.
forEach
(
(
value
)
=
>
{
clipboardArray
.
push
(
VariablesView
.
getString
(
value
)
)
;
}
)
;
clipboardText
=
clipboardArray
.
join
(
"
"
)
;
break
;
}
case
"
dirxml
"
:
{
message
.
level
=
"
log
"
;
return
this
.
logConsoleAPIMessage
(
message
)
;
}
case
"
group
"
:
case
"
groupCollapsed
"
:
clipboardText
=
body
=
message
.
groupName
;
this
.
groupDepth
+
+
;
break
;
case
"
groupEnd
"
:
if
(
this
.
groupDepth
>
0
)
{
this
.
groupDepth
-
-
;
}
break
;
case
"
time
"
:
{
let
timer
=
message
.
timer
;
if
(
!
timer
)
{
return
null
;
}
if
(
timer
.
error
)
{
console
.
error
(
new
Error
(
l10n
.
getStr
(
timer
.
error
)
)
)
;
return
null
;
}
body
=
l10n
.
getFormatStr
(
"
timerStarted
"
[
timer
.
name
]
)
;
clipboardText
=
body
;
break
;
}
case
"
timeEnd
"
:
{
let
timer
=
message
.
timer
;
if
(
!
timer
)
{
return
null
;
}
let
duration
=
Math
.
round
(
timer
.
duration
*
100
)
/
100
;
body
=
l10n
.
getFormatStr
(
"
timeEnd
"
[
timer
.
name
duration
]
)
;
clipboardText
=
body
;
break
;
}
case
"
count
"
:
{
let
counter
=
message
.
counter
;
if
(
!
counter
)
{
return
null
;
}
if
(
counter
.
error
)
{
console
.
error
(
l10n
.
getStr
(
counter
.
error
)
)
;
return
null
;
}
let
msg
=
new
Messages
.
ConsoleGeneric
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
timeStamp
"
:
{
return
null
;
}
default
:
console
.
error
(
new
Error
(
"
Unknown
Console
API
log
level
:
"
+
level
)
)
;
return
null
;
}
switch
(
level
)
{
case
"
group
"
:
case
"
groupCollapsed
"
:
case
"
groupEnd
"
:
case
"
time
"
:
case
"
timeEnd
"
:
case
"
count
"
:
for
(
let
actor
of
objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
objectActors
.
clear
(
)
;
}
if
(
level
=
=
"
groupEnd
"
)
{
return
null
;
}
if
(
!
node
)
{
node
=
this
.
createMessageNode
(
CATEGORY_WEBDEV
LEVELS
[
level
]
body
sourceURL
sourceLine
clipboardText
level
message
.
timeStamp
)
;
if
(
message
.
private
)
{
node
.
setAttribute
(
"
private
"
true
)
;
}
}
if
(
objectActors
.
size
>
0
)
{
node
.
_objectActors
=
objectActors
;
if
(
!
node
.
_messageObject
)
{
let
repeatNode
=
node
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
repeatNode
.
_uid
+
=
[
.
.
.
objectActors
]
.
join
(
"
-
"
)
;
}
}
let
workerTypeID
=
CONSOLE_WORKER_IDS
.
indexOf
(
message
.
workerType
)
;
if
(
workerTypeID
!
=
-
1
)
{
node
.
workerType
=
WORKERTYPES_PREFKEYS
[
workerTypeID
]
;
node
.
setAttribute
(
"
workerType
"
WORKERTYPES_PREFKEYS
[
workerTypeID
]
)
;
}
return
node
;
}
handleConsoleAPICall
:
function
(
message
)
{
this
.
outputMessage
(
CATEGORY_WEBDEV
this
.
logConsoleAPIMessage
[
message
]
)
;
}
reportPageError
:
function
(
category
scriptError
)
{
let
severity
=
"
error
"
;
if
(
scriptError
.
warning
|
|
scriptError
.
strict
)
{
severity
=
"
warning
"
;
}
else
if
(
scriptError
.
info
)
{
severity
=
"
log
"
;
}
switch
(
category
)
{
case
CATEGORY_CSS
:
category
=
"
css
"
;
break
;
case
CATEGORY_SECURITY
:
category
=
"
security
"
;
break
;
default
:
category
=
"
js
"
;
break
;
}
let
objectActors
=
new
Set
(
)
;
for
(
let
prop
of
[
"
errorMessage
"
"
lineText
"
]
)
{
let
grip
=
scriptError
[
prop
]
;
if
(
WebConsoleUtils
.
isActorGrip
(
grip
)
)
{
objectActors
.
add
(
grip
.
actor
)
;
}
}
let
errorMessage
=
scriptError
.
errorMessage
;
if
(
errorMessage
.
type
&
&
errorMessage
.
type
=
=
"
longString
"
)
{
errorMessage
=
errorMessage
.
initial
;
}
let
displayOrigin
=
scriptError
.
sourceName
;
if
(
scriptError
.
category
&
&
scriptError
.
category
=
=
"
SHA
-
1
Signature
"
)
{
let
sourceURI
=
Services
.
io
.
newURI
(
scriptError
.
sourceName
null
null
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
displayOrigin
=
sourceURI
.
prePath
;
}
let
msg
=
new
Messages
.
Simple
(
errorMessage
{
location
:
{
url
:
displayOrigin
line
:
scriptError
.
lineNumber
column
:
scriptError
.
columnNumber
}
stack
:
scriptError
.
stacktrace
category
:
category
severity
:
severity
timestamp
:
scriptError
.
timeStamp
private
:
scriptError
.
private
filterDuplicates
:
true
}
)
;
let
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
let
msgBody
=
node
.
getElementsByClassName
(
"
message
-
body
"
)
[
0
]
;
if
(
scriptError
.
exceptionDocURL
)
{
this
.
addLearnMoreWarningNode
(
msgBody
scriptError
.
exceptionDocURL
)
;
}
this
.
_telemetry
.
logKeyed
(
"
DEVTOOLS_JAVASCRIPT_ERROR_DISPLAYED
"
scriptError
.
errorMessageName
true
)
;
if
(
objectActors
.
size
>
0
)
{
node
.
_objectActors
=
objectActors
;
}
return
node
;
}
handlePageError
:
function
(
pageError
)
{
let
category
=
Utils
.
categoryForScriptError
(
pageError
)
;
this
.
outputMessage
(
category
this
.
reportPageError
[
category
pageError
]
)
;
}
handleLogMessage
:
function
(
packet
)
{
if
(
packet
.
message
)
{
this
.
outputMessage
(
CATEGORY_JS
this
.
_reportLogMessage
[
packet
]
)
;
}
}
_reportLogMessage
:
function
(
packet
)
{
let
msg
=
packet
.
message
;
if
(
msg
.
type
&
&
msg
.
type
=
=
"
longString
"
)
{
msg
=
msg
.
initial
;
}
let
node
=
this
.
createMessageNode
(
CATEGORY_JS
SEVERITY_LOG
msg
null
null
null
null
packet
.
timeStamp
)
;
if
(
WebConsoleUtils
.
isActorGrip
(
packet
.
message
)
)
{
node
.
_objectActors
=
new
Set
(
[
packet
.
message
.
actor
]
)
;
}
return
node
;
}
logNetEvent
:
function
(
networkInfo
)
{
let
actorId
=
networkInfo
.
actor
;
let
request
=
networkInfo
.
request
;
let
clipboardText
=
request
.
method
+
"
"
+
request
.
url
;
let
severity
=
SEVERITY_LOG
;
if
(
networkInfo
.
isXHR
)
{
clipboardText
=
request
.
method
+
"
XHR
"
+
request
.
url
;
severity
=
SEVERITY_INFO
;
}
let
mixedRequest
=
WebConsoleUtils
.
isMixedHTTPSRequest
(
request
.
url
this
.
contentLocation
)
;
if
(
mixedRequest
)
{
severity
=
SEVERITY_WARNING
;
}
let
methodNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
methodNode
.
className
=
"
method
"
;
methodNode
.
textContent
=
request
.
method
+
"
"
;
let
messageNode
=
this
.
createMessageNode
(
CATEGORY_NETWORK
severity
methodNode
null
null
clipboardText
null
networkInfo
.
timeStamp
)
;
if
(
networkInfo
.
private
)
{
messageNode
.
setAttribute
(
"
private
"
true
)
;
}
messageNode
.
_connectionId
=
actorId
;
messageNode
.
url
=
request
.
url
;
let
body
=
methodNode
.
parentNode
;
body
.
setAttribute
(
"
aria
-
haspopup
"
true
)
;
if
(
networkInfo
.
isXHR
)
{
let
xhrNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
xhrNode
.
className
=
"
xhr
"
;
xhrNode
.
textContent
=
l10n
.
getStr
(
"
webConsoleXhrIndicator
"
)
;
body
.
appendChild
(
xhrNode
)
;
body
.
appendChild
(
this
.
document
.
createTextNode
(
"
"
)
)
;
}
let
displayUrl
=
request
.
url
;
let
pos
=
displayUrl
.
indexOf
(
"
?
"
)
;
if
(
pos
>
-
1
)
{
displayUrl
=
displayUrl
.
substr
(
0
pos
)
;
}
let
urlNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
urlNode
.
className
=
"
url
"
;
urlNode
.
setAttribute
(
"
title
"
request
.
url
)
;
urlNode
.
href
=
request
.
url
;
urlNode
.
textContent
=
displayUrl
;
urlNode
.
draggable
=
false
;
body
.
appendChild
(
urlNode
)
;
body
.
appendChild
(
this
.
document
.
createTextNode
(
"
"
)
)
;
if
(
mixedRequest
)
{
messageNode
.
classList
.
add
(
"
mixed
-
content
"
)
;
this
.
makeMixedContentNode
(
body
)
;
}
let
statusNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
statusNode
.
className
=
"
status
"
;
body
.
appendChild
(
statusNode
)
;
let
onClick
=
(
)
=
>
this
.
openNetworkPanel
(
networkInfo
.
actor
)
;
this
.
_addMessageLinkCallback
(
urlNode
onClick
)
;
this
.
_addMessageLinkCallback
(
statusNode
onClick
)
;
networkInfo
.
node
=
messageNode
;
this
.
_updateNetMessage
(
actorId
)
;
if
(
this
.
window
.
NetRequest
)
{
this
.
window
.
NetRequest
.
onNetworkEvent
(
{
consoleFrame
:
this
response
:
networkInfo
node
:
messageNode
update
:
false
}
)
;
}
return
messageNode
;
}
makeMixedContentNode
:
function
(
linkNode
)
{
let
mixedContentWarning
=
"
[
"
+
l10n
.
getStr
(
"
webConsoleMixedContentWarning
"
)
+
"
]
"
;
let
mixedContentWarningNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
mixedContentWarningNode
.
title
=
MIXED_CONTENT_LEARN_MORE
;
mixedContentWarningNode
.
href
=
MIXED_CONTENT_LEARN_MORE
;
mixedContentWarningNode
.
className
=
"
learn
-
more
-
link
"
;
mixedContentWarningNode
.
textContent
=
mixedContentWarning
;
mixedContentWarningNode
.
draggable
=
false
;
linkNode
.
appendChild
(
mixedContentWarningNode
)
;
this
.
_addMessageLinkCallback
(
mixedContentWarningNode
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
this
.
owner
.
openLink
(
MIXED_CONTENT_LEARN_MORE
)
;
}
)
;
}
addLearnMoreWarningNode
:
function
(
node
url
)
{
let
moreInfoLabel
=
"
[
"
+
l10n
.
getStr
(
"
webConsoleMoreInfoLabel
"
)
+
"
]
"
;
let
warningNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
warningNode
.
title
=
url
.
split
(
"
?
"
)
[
0
]
;
warningNode
.
href
=
url
;
warningNode
.
draggable
=
false
;
warningNode
.
textContent
=
moreInfoLabel
;
warningNode
.
className
=
"
learn
-
more
-
link
"
;
this
.
_addMessageLinkCallback
(
warningNode
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
this
.
owner
.
openLink
(
url
)
;
}
)
;
node
.
appendChild
(
warningNode
)
;
}
logFileActivity
:
function
(
fileURI
)
{
let
urlNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
urlNode
.
setAttribute
(
"
title
"
fileURI
)
;
urlNode
.
className
=
"
url
"
;
urlNode
.
textContent
=
fileURI
;
urlNode
.
draggable
=
false
;
urlNode
.
href
=
fileURI
;
let
outputNode
=
this
.
createMessageNode
(
CATEGORY_NETWORK
SEVERITY_LOG
urlNode
null
null
fileURI
)
;
this
.
_addMessageLinkCallback
(
urlNode
(
)
=
>
{
this
.
owner
.
viewSource
(
fileURI
)
;
}
)
;
return
outputNode
;
}
handleFileActivity
:
function
(
fileURI
)
{
this
.
outputMessage
(
CATEGORY_NETWORK
this
.
logFileActivity
[
fileURI
]
)
;
}
logReflowActivity
:
function
(
message
)
{
let
{
start
end
sourceURL
sourceLine
}
=
message
;
let
duration
=
Math
.
round
(
(
end
-
start
)
*
100
)
/
100
;
let
node
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
if
(
sourceURL
)
{
node
.
textContent
=
l10n
.
getFormatStr
(
"
reflow
.
messageWithLink
"
[
duration
]
)
;
let
a
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
a
.
href
=
"
#
"
;
a
.
draggable
=
"
false
"
;
let
filename
=
getSourceNames
(
sourceURL
)
.
short
;
let
functionName
=
message
.
functionName
|
|
l10n
.
getStr
(
"
stacktrace
.
anonymousFunction
"
)
;
a
.
textContent
=
l10n
.
getFormatStr
(
"
reflow
.
messageLinkText
"
[
functionName
filename
sourceLine
]
)
;
this
.
_addMessageLinkCallback
(
a
(
)
=
>
{
this
.
owner
.
viewSourceInDebugger
(
sourceURL
sourceLine
)
;
}
)
;
node
.
appendChild
(
a
)
;
}
else
{
node
.
textContent
=
l10n
.
getFormatStr
(
"
reflow
.
messageWithNoLink
"
[
duration
]
)
;
}
return
this
.
createMessageNode
(
CATEGORY_CSS
SEVERITY_LOG
node
)
;
}
handleReflowActivity
:
function
(
message
)
{
this
.
outputMessage
(
CATEGORY_CSS
this
.
logReflowActivity
[
message
]
)
;
}
logWarningAboutReplacedAPI
:
function
(
)
{
let
node
=
this
.
createMessageNode
(
CATEGORY_JS
SEVERITY_WARNING
l10n
.
getStr
(
"
ConsoleAPIDisabled
"
)
)
;
this
.
outputMessage
(
CATEGORY_JS
node
)
;
}
handleNetworkEvent
:
function
(
networkInfo
)
{
this
.
outputMessage
(
CATEGORY_NETWORK
this
.
logNetEvent
[
networkInfo
]
)
;
}
handleNetworkEventUpdate
:
function
(
networkInfo
packet
)
{
if
(
networkInfo
.
node
&
&
this
.
_updateNetMessage
(
packet
.
from
)
)
{
if
(
this
.
window
.
NetRequest
)
{
this
.
window
.
NetRequest
.
onNetworkEvent
(
{
client
:
this
.
webConsoleClient
response
:
packet
node
:
networkInfo
.
node
update
:
true
}
)
;
}
this
.
emit
(
"
new
-
messages
"
new
Set
(
[
{
update
:
true
node
:
networkInfo
.
node
response
:
packet
}
]
)
)
;
}
if
(
this
.
owner
.
lastFinishedRequestCallback
&
&
networkInfo
.
updates
.
indexOf
(
"
responseContent
"
)
>
-
1
&
&
networkInfo
.
updates
.
indexOf
(
"
eventTimings
"
)
>
-
1
)
{
this
.
owner
.
lastFinishedRequestCallback
(
networkInfo
this
)
;
}
}
_updateNetMessage
:
function
(
actorId
)
{
let
networkInfo
=
this
.
webConsoleClient
.
getNetworkRequest
(
actorId
)
;
if
(
!
networkInfo
|
|
!
networkInfo
.
node
)
{
return
false
;
}
let
messageNode
=
networkInfo
.
node
;
let
updates
=
networkInfo
.
updates
;
let
hasEventTimings
=
updates
.
indexOf
(
"
eventTimings
"
)
>
-
1
;
let
hasResponseStart
=
updates
.
indexOf
(
"
responseStart
"
)
>
-
1
;
let
request
=
networkInfo
.
request
;
let
methodText
=
(
networkInfo
.
isXHR
)
?
request
.
method
+
"
XHR
"
:
request
.
method
;
let
response
=
networkInfo
.
response
;
let
updated
=
false
;
if
(
hasEventTimings
|
|
hasResponseStart
)
{
let
status
=
[
]
;
if
(
response
.
httpVersion
&
&
response
.
status
)
{
status
=
[
response
.
httpVersion
response
.
status
response
.
statusText
]
;
}
if
(
hasEventTimings
)
{
status
.
push
(
l10n
.
getFormatStr
(
"
NetworkPanel
.
durationMS
"
[
networkInfo
.
totalTime
]
)
)
;
}
let
statusText
=
"
[
"
+
status
.
join
(
"
"
)
+
"
]
"
;
let
statusNode
=
messageNode
.
getElementsByClassName
(
"
status
"
)
[
0
]
;
statusNode
.
textContent
=
statusText
;
messageNode
.
clipboardText
=
[
methodText
request
.
url
statusText
]
.
join
(
"
"
)
;
if
(
hasResponseStart
&
&
response
.
status
>
=
MIN_HTTP_ERROR_CODE
&
&
response
.
status
<
=
MAX_HTTP_ERROR_CODE
)
{
this
.
setMessageType
(
messageNode
CATEGORY_NETWORK
SEVERITY_ERROR
)
;
}
updated
=
true
;
}
if
(
messageNode
.
_netPanel
)
{
messageNode
.
_netPanel
.
update
(
)
;
}
return
updated
;
}
openNetworkPanel
:
function
(
requestId
)
{
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
if
(
!
toolbox
)
{
return
;
}
return
toolbox
.
selectTool
(
"
netmonitor
"
)
.
then
(
panel
=
>
{
return
panel
.
panelWin
.
NetMonitorController
.
inspectRequest
(
requestId
)
;
}
)
;
}
onLocationChange
:
function
(
uri
title
)
{
this
.
contentLocation
=
uri
;
if
(
this
.
owner
.
onLocationChange
)
{
this
.
owner
.
onLocationChange
(
uri
title
)
;
}
}
handleTabNavigated
:
function
(
event
packet
)
{
if
(
event
=
=
"
will
-
navigate
"
)
{
if
(
this
.
persistLog
)
{
if
(
this
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
packet
.
_type
=
true
;
this
.
newConsoleOutput
.
dispatchMessageAdd
(
packet
)
;
}
else
{
let
marker
=
new
Messages
.
NavigationMarker
(
packet
Date
.
now
(
)
)
;
this
.
output
.
addMessage
(
marker
)
;
}
}
else
{
this
.
jsterm
.
clearOutput
(
)
;
}
}
if
(
packet
.
url
)
{
this
.
onLocationChange
(
packet
.
url
packet
.
title
)
;
}
if
(
event
=
=
"
navigate
"
&
&
!
packet
.
nativeConsoleAPI
)
{
this
.
logWarningAboutReplacedAPI
(
)
;
}
}
outputMessage
:
function
(
category
methodOrNode
args
)
{
if
(
!
this
.
_outputQueue
.
length
)
{
this
.
_lastOutputFlush
=
Date
.
now
(
)
;
}
this
.
_outputQueue
.
push
(
[
category
methodOrNode
args
]
)
;
this
.
_initOutputTimer
(
)
;
}
_flushMessageQueue
:
function
(
)
{
this
.
_outputTimerInitialized
=
false
;
if
(
!
this
.
_outputTimer
)
{
return
;
}
let
startTime
=
Date
.
now
(
)
;
let
timeSinceFlush
=
startTime
-
this
.
_lastOutputFlush
;
let
shouldThrottle
=
this
.
_outputQueue
.
length
>
MESSAGES_IN_INTERVAL
&
&
timeSinceFlush
<
THROTTLE_UPDATES
;
let
toDisplay
=
Math
.
min
(
this
.
_outputQueue
.
length
MESSAGES_IN_INTERVAL
)
;
if
(
shouldThrottle
|
|
toDisplay
<
1
)
{
while
(
this
.
_itemDestroyQueue
.
length
)
{
if
(
(
Date
.
now
(
)
-
startTime
)
>
MAX_CLEANUP_TIME
)
{
break
;
}
this
.
_destroyItem
(
this
.
_itemDestroyQueue
.
pop
(
)
)
;
}
this
.
_initOutputTimer
(
)
;
return
;
}
let
shouldPrune
=
false
;
if
(
this
.
_outputQueue
.
length
>
toDisplay
&
&
this
.
_pruneOutputQueue
(
)
)
{
toDisplay
=
Math
.
min
(
this
.
_outputQueue
.
length
toDisplay
)
;
shouldPrune
=
true
;
}
let
batch
=
this
.
_outputQueue
.
splice
(
0
toDisplay
)
;
let
outputNode
=
this
.
outputNode
;
let
lastVisibleNode
=
null
;
let
scrollNode
=
this
.
outputWrapper
;
let
hudIdSupportsString
=
WebConsoleUtils
.
supportsString
(
this
.
hudId
)
;
let
scrolledToBottom
=
shouldPrune
|
|
Utils
.
isOutputScrolledToBottom
(
outputNode
scrollNode
)
;
let
messages
=
new
Set
(
)
;
for
(
let
i
=
0
;
i
<
batch
.
length
;
i
+
+
)
{
let
item
=
batch
[
i
]
;
let
result
=
this
.
_outputMessageFromQueue
(
hudIdSupportsString
item
)
;
if
(
result
)
{
messages
.
add
(
{
node
:
result
.
isRepeated
?
result
.
isRepeated
:
result
.
node
response
:
result
.
message
update
:
!
!
result
.
isRepeated
}
)
;
if
(
result
.
visible
&
&
result
.
node
=
=
this
.
outputNode
.
lastChild
)
{
lastVisibleNode
=
result
.
node
;
}
}
}
let
oldScrollHeight
=
0
;
let
removedNodes
=
0
;
if
(
shouldPrune
|
|
!
this
.
_outputQueue
.
length
)
{
if
(
!
scrolledToBottom
)
{
oldScrollHeight
=
scrollNode
.
scrollHeight
;
}
let
categories
=
Object
.
keys
(
this
.
_pruneCategoriesQueue
)
;
categories
.
forEach
(
function
_pruneOutput
(
category
)
{
removedNodes
+
=
this
.
pruneOutputIfNecessary
(
category
)
;
}
this
)
;
this
.
_pruneCategoriesQueue
=
{
}
;
}
let
isInputOutput
=
lastVisibleNode
&
&
(
lastVisibleNode
.
category
=
=
CATEGORY_INPUT
|
|
lastVisibleNode
.
category
=
=
CATEGORY_OUTPUT
)
;
if
(
lastVisibleNode
&
&
(
scrolledToBottom
|
|
isInputOutput
)
)
{
Utils
.
scrollToVisible
(
lastVisibleNode
)
;
}
else
if
(
!
scrolledToBottom
&
&
removedNodes
>
0
&
&
oldScrollHeight
!
=
scrollNode
.
scrollHeight
)
{
scrollNode
.
scrollTop
-
=
oldScrollHeight
-
scrollNode
.
scrollHeight
;
}
if
(
messages
.
size
)
{
this
.
emit
(
"
new
-
messages
"
messages
)
;
}
if
(
this
.
_outputQueue
.
length
=
=
=
0
&
&
this
.
_flushCallback
)
{
if
(
this
.
_flushCallback
(
)
=
=
=
false
)
{
this
.
_flushCallback
=
null
;
}
}
this
.
_initOutputTimer
(
)
;
this
.
resize
(
)
;
this
.
_lastOutputFlush
=
Date
.
now
(
)
;
}
_initOutputTimer
:
function
(
)
{
let
panelIsDestroyed
=
!
this
.
_outputTimer
;
let
alreadyScheduled
=
this
.
_outputTimerInitialized
;
let
nothingToDo
=
!
this
.
_itemDestroyQueue
.
length
&
&
!
this
.
_outputQueue
.
length
;
if
(
panelIsDestroyed
|
|
alreadyScheduled
|
|
nothingToDo
)
{
return
;
}
this
.
_outputTimerInitialized
=
true
;
this
.
_outputTimer
.
initWithCallback
(
this
.
_flushMessageQueue
OUTPUT_INTERVAL
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_outputMessageFromQueue
:
function
(
hudIdSupportsString
item
)
{
let
[
methodOrNode
args
]
=
item
;
let
message
=
(
args
&
&
args
.
length
)
?
args
[
args
.
length
-
1
]
:
null
;
let
node
=
typeof
methodOrNode
=
=
"
function
"
?
methodOrNode
.
apply
(
this
args
|
|
[
]
)
:
methodOrNode
;
if
(
!
node
)
{
return
null
;
}
let
isFiltered
=
this
.
filterMessageNode
(
node
)
;
let
isRepeated
=
this
.
_filterRepeatedMessage
(
node
)
;
if
(
message
&
&
message
.
level
=
=
"
clear
"
&
&
!
this
.
isBrowserConsole
)
{
this
.
jsterm
.
clearOutput
(
false
)
;
}
let
visible
=
!
isRepeated
&
&
!
isFiltered
;
if
(
!
isRepeated
)
{
this
.
outputNode
.
appendChild
(
node
)
;
this
.
_pruneCategoriesQueue
[
node
.
category
]
=
true
;
let
nodeID
=
node
.
getAttribute
(
"
id
"
)
;
Services
.
obs
.
notifyObservers
(
hudIdSupportsString
"
web
-
console
-
message
-
created
"
nodeID
)
;
}
if
(
node
.
_onOutput
)
{
node
.
_onOutput
(
)
;
delete
node
.
_onOutput
;
}
return
{
visible
:
visible
node
:
node
isRepeated
:
isRepeated
message
:
message
}
;
}
_pruneOutputQueue
:
function
(
)
{
let
nodes
=
{
}
;
this
.
_outputQueue
.
forEach
(
function
(
item
index
)
{
let
[
category
]
=
item
;
if
(
!
(
category
in
nodes
)
)
{
nodes
[
category
]
=
[
]
;
}
nodes
[
category
]
.
push
(
index
)
;
}
this
)
;
let
pruned
=
0
;
for
(
let
category
in
nodes
)
{
let
limit
=
Utils
.
logLimitForCategory
(
category
)
;
let
indexes
=
nodes
[
category
]
;
if
(
indexes
.
length
>
limit
)
{
let
n
=
Math
.
max
(
0
indexes
.
length
-
limit
)
;
pruned
+
=
n
;
for
(
let
i
=
n
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
_itemDestroyQueue
.
push
(
this
.
_outputQueue
[
indexes
[
i
]
]
)
;
this
.
_outputQueue
.
splice
(
indexes
[
i
]
1
)
;
}
}
}
return
pruned
;
}
_destroyItem
:
function
(
item
)
{
let
[
category
methodOrNode
args
]
=
item
;
if
(
typeof
methodOrNode
!
=
"
function
"
&
&
methodOrNode
.
_objectActors
)
{
for
(
let
actor
of
methodOrNode
.
_objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
methodOrNode
.
_objectActors
.
clear
(
)
;
}
if
(
methodOrNode
=
=
this
.
output
.
_flushMessageQueue
&
&
args
[
0
]
.
_objectActors
)
{
for
(
let
arg
of
args
)
{
if
(
!
arg
.
_objectActors
)
{
continue
;
}
for
(
let
actor
of
arg
.
_objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
arg
.
_objectActors
.
clear
(
)
;
}
}
if
(
category
=
=
CATEGORY_NETWORK
)
{
let
connectionId
=
null
;
if
(
methodOrNode
=
=
this
.
logNetEvent
)
{
connectionId
=
args
[
0
]
.
actor
;
}
else
if
(
typeof
methodOrNode
!
=
"
function
"
)
{
connectionId
=
methodOrNode
.
_connectionId
;
}
if
(
connectionId
&
&
this
.
webConsoleClient
.
hasNetworkRequest
(
connectionId
)
)
{
this
.
webConsoleClient
.
removeNetworkRequest
(
connectionId
)
;
this
.
_releaseObject
(
connectionId
)
;
}
}
else
if
(
category
=
=
CATEGORY_WEBDEV
&
&
methodOrNode
=
=
this
.
logConsoleAPIMessage
)
{
args
[
0
]
.
arguments
.
forEach
(
(
value
)
=
>
{
if
(
WebConsoleUtils
.
isActorGrip
(
value
)
)
{
this
.
_releaseObject
(
value
.
actor
)
;
}
}
)
;
}
else
if
(
category
=
=
CATEGORY_JS
&
&
methodOrNode
=
=
this
.
reportPageError
)
{
let
pageError
=
args
[
1
]
;
for
(
let
prop
of
[
"
errorMessage
"
"
lineText
"
]
)
{
let
grip
=
pageError
[
prop
]
;
if
(
WebConsoleUtils
.
isActorGrip
(
grip
)
)
{
this
.
_releaseObject
(
grip
.
actor
)
;
}
}
}
else
if
(
category
=
=
CATEGORY_JS
&
&
methodOrNode
=
=
this
.
_reportLogMessage
)
{
if
(
WebConsoleUtils
.
isActorGrip
(
args
[
0
]
.
message
)
)
{
this
.
_releaseObject
(
args
[
0
]
.
message
.
actor
)
;
}
}
}
unmountMessage
(
node
)
{
let
locationNode
=
node
.
querySelector
(
"
.
message
-
location
"
)
;
if
(
locationNode
)
{
this
.
ReactDOM
.
unmountComponentAtNode
(
locationNode
)
;
}
let
stacktraceNode
=
node
.
querySelector
(
"
.
stacktrace
"
)
;
if
(
stacktraceNode
)
{
this
.
ReactDOM
.
unmountComponentAtNode
(
stacktraceNode
)
;
}
}
pruneOutputIfNecessary
:
function
(
category
)
{
let
logLimit
=
Utils
.
logLimitForCategory
(
category
)
;
let
messageNodes
=
this
.
outputNode
.
querySelectorAll
(
"
.
message
[
category
=
"
+
CATEGORY_CLASS_FRAGMENTS
[
category
]
+
"
]
"
)
;
let
n
=
Math
.
max
(
0
messageNodes
.
length
-
logLimit
)
;
[
.
.
.
messageNodes
]
.
slice
(
0
n
)
.
forEach
(
this
.
removeOutputMessage
this
)
;
return
n
;
}
removeOutputMessage
:
function
(
node
)
{
if
(
node
.
_messageObject
)
{
node
.
_messageObject
.
destroy
(
)
;
}
if
(
node
.
_objectActors
)
{
for
(
let
actor
of
node
.
_objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
node
.
_objectActors
.
clear
(
)
;
}
if
(
node
.
category
=
=
CATEGORY_CSS
|
|
node
.
category
=
=
CATEGORY_SECURITY
)
{
let
repeatNode
=
node
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
repeatNode
&
&
repeatNode
.
_uid
)
{
delete
this
.
_repeatNodes
[
repeatNode
.
_uid
]
;
}
}
else
if
(
node
.
_connectionId
&
&
node
.
category
=
=
CATEGORY_NETWORK
)
{
this
.
webConsoleClient
.
removeNetworkRequest
(
node
.
_connectionId
)
;
this
.
_releaseObject
(
node
.
_connectionId
)
;
}
else
if
(
node
.
classList
.
contains
(
"
inlined
-
variables
-
view
"
)
)
{
let
view
=
node
.
_variablesView
;
if
(
view
)
{
view
.
controller
.
releaseActors
(
)
;
}
node
.
_variablesView
=
null
;
}
this
.
unmountMessage
(
node
)
;
node
.
remove
(
)
;
}
createMessageNode
:
function
(
category
severity
body
sourceURL
sourceLine
clipboardText
level
timestamp
)
{
if
(
typeof
body
!
=
"
string
"
&
&
clipboardText
=
=
null
&
&
body
.
innerText
)
{
clipboardText
=
body
.
innerText
;
}
let
indentNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
indentNode
.
className
=
"
indent
"
;
let
indent
=
this
.
groupDepth
*
GROUP_INDENT
;
indentNode
.
style
.
width
=
indent
+
"
px
"
;
let
iconContainer
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
iconContainer
.
className
=
"
icon
"
;
let
bodyNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
bodyNode
.
className
=
"
message
-
body
-
wrapper
message
-
body
devtools
-
monospace
"
;
let
storedBody
=
body
;
clipboardText
=
clipboardText
|
|
(
body
+
(
sourceURL
?
"
"
+
sourceURL
:
"
"
)
+
(
sourceLine
?
"
:
"
+
sourceLine
:
"
"
)
)
;
timestamp
=
timestamp
|
|
Date
.
now
(
)
;
let
node
=
this
.
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
node
.
id
=
"
console
-
msg
-
"
+
gSequenceId
(
)
;
node
.
className
=
"
message
"
;
node
.
clipboardText
=
clipboardText
;
node
.
timestamp
=
timestamp
;
this
.
setMessageType
(
node
category
severity
)
;
if
(
body
instanceof
Ci
.
nsIDOMNode
)
{
bodyNode
.
appendChild
(
body
)
;
}
else
{
let
str
=
undefined
;
if
(
level
=
=
"
dir
"
)
{
str
=
VariablesView
.
getString
(
body
.
arguments
[
0
]
)
;
}
else
{
str
=
body
;
}
if
(
str
!
=
=
undefined
)
{
body
=
this
.
document
.
createTextNode
(
str
)
;
bodyNode
.
appendChild
(
body
)
;
}
}
let
repeatNode
=
null
;
if
(
category
!
=
CATEGORY_INPUT
&
&
category
!
=
CATEGORY_OUTPUT
&
&
category
!
=
CATEGORY_NETWORK
&
&
!
(
category
=
=
CATEGORY_CSS
&
&
severity
=
=
SEVERITY_LOG
)
)
{
repeatNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
repeatNode
.
setAttribute
(
"
value
"
"
1
"
)
;
repeatNode
.
className
=
"
message
-
repeats
"
;
repeatNode
.
textContent
=
1
;
repeatNode
.
_uid
=
[
bodyNode
.
textContent
category
severity
level
sourceURL
sourceLine
]
.
join
(
"
:
"
)
;
}
let
timestampNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
timestampNode
.
className
=
"
timestamp
devtools
-
monospace
"
;
let
timestampString
=
l10n
.
timestampString
(
timestamp
)
;
timestampNode
.
textContent
=
timestampString
+
"
"
;
let
locationNode
;
if
(
sourceURL
&
&
IGNORED_SOURCE_URLS
.
indexOf
(
sourceURL
)
=
=
-
1
)
{
locationNode
=
this
.
createLocationNode
(
{
url
:
sourceURL
line
:
sourceLine
}
)
;
}
node
.
appendChild
(
timestampNode
)
;
node
.
appendChild
(
indentNode
)
;
node
.
appendChild
(
iconContainer
)
;
if
(
level
=
=
"
dir
"
)
{
let
options
=
{
objectActor
:
storedBody
.
arguments
[
0
]
targetElement
:
bodyNode
hideFilterInput
:
true
}
;
this
.
jsterm
.
openVariablesView
(
options
)
.
then
(
(
view
)
=
>
{
node
.
_variablesView
=
view
;
if
(
node
.
classList
.
contains
(
"
hidden
-
message
"
)
)
{
node
.
classList
.
remove
(
"
hidden
-
message
"
)
;
}
}
)
;
node
.
classList
.
add
(
"
inlined
-
variables
-
view
"
)
;
}
node
.
appendChild
(
bodyNode
)
;
if
(
repeatNode
)
{
node
.
appendChild
(
repeatNode
)
;
}
if
(
locationNode
)
{
node
.
appendChild
(
locationNode
)
;
}
node
.
appendChild
(
this
.
document
.
createTextNode
(
"
\
n
"
)
)
;
return
node
;
}
createLocationNode
:
function
(
location
)
{
let
locationNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
locationNode
.
className
=
"
message
-
location
devtools
-
monospace
"
;
let
onClick
=
(
{
url
line
}
)
=
>
{
let
category
=
locationNode
.
closest
(
"
.
message
"
)
.
category
;
let
target
=
null
;
if
(
/
^
Scratchpad
\
/
\
d
+
/
.
test
(
url
)
)
{
target
=
"
scratchpad
"
;
}
else
if
(
category
=
=
=
CATEGORY_CSS
)
{
target
=
"
styleeditor
"
;
}
else
if
(
category
=
=
=
CATEGORY_JS
|
|
category
=
=
=
CATEGORY_WEBDEV
)
{
target
=
"
jsdebugger
"
;
}
else
if
(
/
\
.
js
/
.
test
(
url
)
)
{
target
=
"
jsdebugger
"
;
}
else
{
target
=
"
jsdebugger
"
;
}
switch
(
target
)
{
case
"
scratchpad
"
:
this
.
owner
.
viewSourceInScratchpad
(
url
line
)
;
return
;
case
"
jsdebugger
"
:
this
.
owner
.
viewSourceInDebugger
(
url
line
)
;
return
;
case
"
styleeditor
"
:
this
.
owner
.
viewSourceInStyleEditor
(
url
line
)
;
return
;
}
this
.
owner
.
viewSource
(
url
line
)
;
}
;
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
let
{
url
line
column
}
=
location
;
let
source
=
url
?
url
.
split
(
"
-
>
"
)
.
pop
(
)
:
"
"
;
this
.
ReactDOM
.
render
(
this
.
FrameView
(
{
frame
:
{
source
line
column
}
showEmptyPathAsHost
:
true
onClick
sourceMapService
:
toolbox
?
toolbox
.
_sourceMapService
:
null
}
)
locationNode
)
;
return
locationNode
;
}
setMessageType
:
function
(
messageNode
category
severity
)
{
messageNode
.
category
=
category
;
messageNode
.
severity
=
severity
;
messageNode
.
setAttribute
(
"
category
"
CATEGORY_CLASS_FRAGMENTS
[
category
]
)
;
messageNode
.
setAttribute
(
"
severity
"
SEVERITY_CLASS_FRAGMENTS
[
severity
]
)
;
messageNode
.
setAttribute
(
"
filter
"
MESSAGE_PREFERENCE_KEYS
[
category
]
[
severity
]
)
;
}
_addMessageLinkCallback
:
function
(
node
callback
)
{
node
.
addEventListener
(
"
mousedown
"
(
event
)
=
>
{
this
.
_mousedown
=
true
;
this
.
_startX
=
event
.
clientX
;
this
.
_startY
=
event
.
clientY
;
}
false
)
;
node
.
addEventListener
(
"
click
"
(
event
)
=
>
{
let
mousedown
=
this
.
_mousedown
;
this
.
_mousedown
=
false
;
event
.
preventDefault
(
)
;
if
(
event
.
detail
!
=
1
|
|
event
.
button
!
=
0
)
{
return
;
}
if
(
mousedown
&
&
(
this
.
_startX
!
=
event
.
clientX
)
&
&
(
this
.
_startY
!
=
event
.
clientY
)
)
{
this
.
_startX
=
this
.
_startY
=
undefined
;
return
;
}
this
.
_startX
=
this
.
_startY
=
undefined
;
callback
.
call
(
this
event
)
;
}
false
)
;
}
_onToolboxPrefChanged
:
function
(
event
data
)
{
if
(
data
.
pref
=
=
PREF_MESSAGE_TIMESTAMP
)
{
if
(
data
.
newValue
)
{
this
.
outputNode
.
classList
.
remove
(
"
hideTimestamps
"
)
;
}
else
{
this
.
outputNode
.
classList
.
add
(
"
hideTimestamps
"
)
;
}
}
}
copySelectedItems
:
function
(
options
)
{
options
=
options
|
|
{
linkOnly
:
false
contextmenu
:
false
}
;
let
strings
=
[
]
;
let
children
=
this
.
output
.
getSelectedMessages
(
)
;
if
(
!
children
.
length
&
&
options
.
contextmenu
)
{
children
=
[
this
.
_contextMenuHandler
.
lastClickedMessage
]
;
}
for
(
let
item
of
children
)
{
if
(
!
item
.
classList
.
contains
(
"
filtered
-
by
-
type
"
)
&
&
!
item
.
classList
.
contains
(
"
filtered
-
by
-
string
"
)
)
{
if
(
options
.
linkOnly
)
{
strings
.
push
(
item
.
url
)
;
}
else
{
strings
.
push
(
item
.
clipboardText
)
;
}
}
}
clipboardHelper
.
copyString
(
strings
.
join
(
"
\
n
"
)
)
;
}
objectPropertiesProvider
:
function
(
actor
callback
)
{
this
.
webConsoleClient
.
inspectObjectProperties
(
actor
function
(
response
)
{
if
(
response
.
error
)
{
console
.
error
(
"
Failed
to
retrieve
the
object
properties
from
the
"
+
"
server
.
Error
:
"
+
response
.
error
)
;
return
;
}
callback
(
response
.
properties
)
;
}
)
;
}
_releaseObject
:
function
(
actor
)
{
if
(
this
.
proxy
)
{
this
.
proxy
.
releaseActor
(
actor
)
;
}
}
openSelectedItemInTab
:
function
(
)
{
let
item
=
this
.
output
.
getSelectedMessages
(
1
)
[
0
]
|
|
this
.
_contextMenuHandler
.
lastClickedMessage
;
if
(
!
item
|
|
!
item
.
url
)
{
return
;
}
this
.
owner
.
openLink
(
item
.
url
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
.
promise
;
}
this
.
_destroyer
=
promise
.
defer
(
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
if
(
toolbox
)
{
toolbox
.
off
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
}
gDevTools
.
off
(
"
pref
-
changed
"
this
.
_onToolboxPrefChanged
)
;
this
.
window
.
removeEventListener
(
"
resize
"
this
.
resize
true
)
;
this
.
_repeatNodes
=
{
}
;
this
.
_outputQueue
.
forEach
(
this
.
_destroyItem
this
)
;
this
.
_outputQueue
=
[
]
;
this
.
_itemDestroyQueue
.
forEach
(
this
.
_destroyItem
this
)
;
this
.
_itemDestroyQueue
=
[
]
;
this
.
_pruneCategoriesQueue
=
{
}
;
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
let
liveMessages
=
this
.
outputNode
.
querySelectorAll
(
"
.
message
"
)
;
Array
.
prototype
.
forEach
.
call
(
liveMessages
this
.
unmountMessage
)
;
if
(
this
.
_outputTimerInitialized
)
{
this
.
_outputTimerInitialized
=
false
;
this
.
_outputTimer
.
cancel
(
)
;
}
this
.
_outputTimer
=
null
;
if
(
this
.
jsterm
)
{
this
.
jsterm
.
off
(
"
sidebar
-
opened
"
this
.
resize
)
;
this
.
jsterm
.
off
(
"
sidebar
-
closed
"
this
.
resize
)
;
this
.
jsterm
.
destroy
(
)
;
this
.
jsterm
=
null
;
}
this
.
output
.
destroy
(
)
;
this
.
output
=
null
;
this
.
React
=
this
.
ReactDOM
=
this
.
FrameView
=
null
;
if
(
this
.
_contextMenuHandler
)
{
this
.
_contextMenuHandler
.
destroy
(
)
;
this
.
_contextMenuHandler
=
null
;
}
this
.
_commandController
=
null
;
let
onDestroy
=
(
)
=
>
{
this
.
_destroyer
.
resolve
(
null
)
;
}
;
if
(
this
.
proxy
)
{
this
.
proxy
.
disconnect
(
)
.
then
(
onDestroy
)
;
this
.
proxy
=
null
;
}
else
{
onDestroy
(
)
;
}
return
this
.
_destroyer
.
promise
;
}
}
;
var
Utils
=
{
scrollToVisible
:
function
(
node
)
{
node
.
scrollIntoView
(
false
)
;
}
isOutputScrolledToBottom
:
function
(
outputNode
scrollNode
)
{
let
lastNodeHeight
=
outputNode
.
lastChild
?
outputNode
.
lastChild
.
clientHeight
:
0
;
return
scrollNode
.
scrollTop
+
scrollNode
.
clientHeight
>
=
scrollNode
.
scrollHeight
-
lastNodeHeight
/
2
;
}
categoryForScriptError
:
function
(
scriptError
)
{
let
category
=
scriptError
.
category
;
if
(
/
^
(
?
:
CSS
|
Layout
)
\
b
/
.
test
(
category
)
)
{
return
CATEGORY_CSS
;
}
switch
(
category
)
{
case
"
Mixed
Content
Blocker
"
:
case
"
Mixed
Content
Message
"
:
case
"
CSP
"
:
case
"
Invalid
HSTS
Headers
"
:
case
"
Invalid
HPKP
Headers
"
:
case
"
SHA
-
1
Signature
"
:
case
"
Insecure
Password
Field
"
:
case
"
SSL
"
:
case
"
CORS
"
:
case
"
Iframe
Sandbox
"
:
case
"
Tracking
Protection
"
:
case
"
Sub
-
resource
Integrity
"
:
return
CATEGORY_SECURITY
;
default
:
return
CATEGORY_JS
;
}
}
logLimitForCategory
:
function
(
category
)
{
let
logLimit
=
DEFAULT_LOG_LIMIT
;
try
{
let
prefName
=
CATEGORY_CLASS_FRAGMENTS
[
category
]
;
logLimit
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
hud
.
loglimit
.
"
+
prefName
)
;
logLimit
=
Math
.
max
(
logLimit
1
)
;
}
catch
(
e
)
{
}
return
logLimit
;
}
}
;
function
CommandController
(
webConsole
)
{
this
.
owner
=
webConsole
;
}
CommandController
.
prototype
=
{
selectAll
:
function
(
)
{
this
.
owner
.
output
.
selectAllMessages
(
)
;
}
openURL
:
function
(
)
{
this
.
owner
.
openSelectedItemInTab
(
)
;
}
copyURL
:
function
(
)
{
this
.
owner
.
copySelectedItems
(
{
linkOnly
:
true
contextmenu
:
true
}
)
;
}
copyLastClicked
:
function
(
)
{
this
.
owner
.
copySelectedItems
(
{
linkOnly
:
false
contextmenu
:
true
}
)
;
}
supportsCommand
:
function
(
command
)
{
if
(
!
this
.
owner
|
|
!
this
.
owner
.
output
)
{
return
false
;
}
return
this
.
isCommandEnabled
(
command
)
;
}
isCommandEnabled
:
function
(
command
)
{
switch
(
command
)
{
case
"
consoleCmd_openURL
"
:
case
"
consoleCmd_copyURL
"
:
{
let
selectedItem
=
this
.
owner
.
output
.
getSelectedMessages
(
1
)
[
0
]
|
|
this
.
owner
.
_contextMenuHandler
.
lastClickedMessage
;
return
selectedItem
&
&
"
url
"
in
selectedItem
;
}
case
"
cmd_copy
"
:
{
return
this
.
owner
.
_contextMenuHandler
.
lastClickedMessage
&
&
!
this
.
owner
.
output
.
getSelectedMessages
(
1
)
[
0
]
;
}
case
"
cmd_selectAll
"
:
return
true
;
}
return
false
;
}
doCommand
:
function
(
command
)
{
switch
(
command
)
{
case
"
consoleCmd_openURL
"
:
this
.
openURL
(
)
;
break
;
case
"
consoleCmd_copyURL
"
:
this
.
copyURL
(
)
;
break
;
case
"
cmd_copy
"
:
this
.
copyLastClicked
(
)
;
break
;
case
"
cmd_selectAll
"
:
this
.
selectAll
(
)
;
break
;
}
}
}
;
function
WebConsoleConnectionProxy
(
webConsoleFrame
target
)
{
this
.
webConsoleFrame
=
webConsoleFrame
;
this
.
target
=
target
;
this
.
_onPageError
=
this
.
_onPageError
.
bind
(
this
)
;
this
.
_onLogMessage
=
this
.
_onLogMessage
.
bind
(
this
)
;
this
.
_onConsoleAPICall
=
this
.
_onConsoleAPICall
.
bind
(
this
)
;
this
.
_onNetworkEvent
=
this
.
_onNetworkEvent
.
bind
(
this
)
;
this
.
_onNetworkEventUpdate
=
this
.
_onNetworkEventUpdate
.
bind
(
this
)
;
this
.
_onFileActivity
=
this
.
_onFileActivity
.
bind
(
this
)
;
this
.
_onReflowActivity
=
this
.
_onReflowActivity
.
bind
(
this
)
;
this
.
_onServerLogCall
=
this
.
_onServerLogCall
.
bind
(
this
)
;
this
.
_onTabNavigated
=
this
.
_onTabNavigated
.
bind
(
this
)
;
this
.
_onAttachConsole
=
this
.
_onAttachConsole
.
bind
(
this
)
;
this
.
_onCachedMessages
=
this
.
_onCachedMessages
.
bind
(
this
)
;
this
.
_connectionTimeout
=
this
.
_connectionTimeout
.
bind
(
this
)
;
this
.
_onLastPrivateContextExited
=
this
.
_onLastPrivateContextExited
.
bind
(
this
)
;
}
WebConsoleConnectionProxy
.
prototype
=
{
webConsoleFrame
:
null
target
:
null
client
:
null
webConsoleClient
:
null
connected
:
false
_connectTimer
:
null
_connectDefer
:
null
_disconnecter
:
null
_consoleActor
:
null
_hasNativeConsoleAPI
:
false
connect
:
function
(
)
{
if
(
this
.
_connectDefer
)
{
return
this
.
_connectDefer
.
promise
;
}
this
.
_connectDefer
=
promise
.
defer
(
)
;
let
timeout
=
Services
.
prefs
.
getIntPref
(
PREF_CONNECTION_TIMEOUT
)
;
this
.
_connectTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_connectTimer
.
initWithCallback
(
this
.
_connectionTimeout
timeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
let
connPromise
=
this
.
_connectDefer
.
promise
;
connPromise
.
then
(
(
)
=
>
{
this
.
_connectTimer
.
cancel
(
)
;
this
.
_connectTimer
=
null
;
}
(
)
=
>
{
this
.
_connectTimer
=
null
;
}
)
;
let
client
=
this
.
client
=
this
.
target
.
client
;
if
(
this
.
target
.
isWorkerTarget
)
{
}
else
{
client
.
addListener
(
"
logMessage
"
this
.
_onLogMessage
)
;
client
.
addListener
(
"
pageError
"
this
.
_onPageError
)
;
client
.
addListener
(
"
consoleAPICall
"
this
.
_onConsoleAPICall
)
;
client
.
addListener
(
"
fileActivity
"
this
.
_onFileActivity
)
;
client
.
addListener
(
"
reflowActivity
"
this
.
_onReflowActivity
)
;
client
.
addListener
(
"
serverLogCall
"
this
.
_onServerLogCall
)
;
client
.
addListener
(
"
lastPrivateContextExited
"
this
.
_onLastPrivateContextExited
)
;
}
this
.
target
.
on
(
"
will
-
navigate
"
this
.
_onTabNavigated
)
;
this
.
target
.
on
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
_consoleActor
=
this
.
target
.
form
.
consoleActor
;
if
(
this
.
target
.
isTabActor
)
{
let
tab
=
this
.
target
.
form
;
this
.
webConsoleFrame
.
onLocationChange
(
tab
.
url
tab
.
title
)
;
}
this
.
_attachConsole
(
)
;
return
connPromise
;
}
_connectionTimeout
:
function
(
)
{
let
error
=
{
error
:
"
timeout
"
message
:
l10n
.
getStr
(
"
connectionTimeout
"
)
}
;
this
.
_connectDefer
.
reject
(
error
)
;
}
_attachConsole
:
function
(
)
{
let
listeners
=
[
"
PageError
"
"
ConsoleAPI
"
"
NetworkActivity
"
"
FileActivity
"
]
;
this
.
client
.
attachConsole
(
this
.
_consoleActor
listeners
this
.
_onAttachConsole
)
;
}
_onAttachConsole
:
function
(
response
webConsoleClient
)
{
if
(
response
.
error
)
{
console
.
error
(
"
attachConsole
failed
:
"
+
response
.
error
+
"
"
+
response
.
message
)
;
this
.
_connectDefer
.
reject
(
response
)
;
return
;
}
this
.
webConsoleClient
=
webConsoleClient
;
this
.
_hasNativeConsoleAPI
=
response
.
nativeConsoleAPI
;
let
saveBodies
=
!
this
.
webConsoleFrame
.
isBrowserConsole
;
this
.
webConsoleFrame
.
setSaveRequestAndResponseBodies
(
saveBodies
)
;
this
.
webConsoleClient
.
on
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
on
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
let
msgs
=
[
"
PageError
"
"
ConsoleAPI
"
]
;
this
.
webConsoleClient
.
getCachedMessages
(
msgs
this
.
_onCachedMessages
)
;
this
.
webConsoleFrame
.
_onUpdateListeners
(
)
;
}
dispatchMessageAdd
:
function
(
packet
)
{
this
.
webConsoleFrame
.
newConsoleOutput
.
dispatchMessageAdd
(
packet
)
;
}
dispatchMessagesAdd
:
function
(
packets
)
{
this
.
webConsoleFrame
.
newConsoleOutput
.
dispatchMessagesAdd
(
packets
)
;
}
_onCachedMessages
:
function
(
response
)
{
if
(
response
.
error
)
{
console
.
error
(
"
Web
Console
getCachedMessages
error
:
"
+
response
.
error
+
"
"
+
response
.
message
)
;
this
.
_connectDefer
.
reject
(
response
)
;
return
;
}
if
(
!
this
.
_connectTimer
)
{
console
.
error
(
"
Web
Console
getCachedMessages
error
:
invalid
state
.
"
)
;
}
let
messages
=
response
.
messages
.
concat
(
.
.
.
this
.
webConsoleClient
.
getNetworkEvents
(
)
)
;
messages
.
sort
(
(
a
b
)
=
>
a
.
timeStamp
-
b
.
timeStamp
)
;
if
(
this
.
webConsoleFrame
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
dispatchMessagesAdd
(
messages
)
;
}
else
{
this
.
webConsoleFrame
.
displayCachedMessages
(
messages
)
;
if
(
!
this
.
_hasNativeConsoleAPI
)
{
this
.
webConsoleFrame
.
logWarningAboutReplacedAPI
(
)
;
}
}
this
.
connected
=
true
;
this
.
_connectDefer
.
resolve
(
this
)
;
}
_onPageError
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
if
(
this
.
webConsoleFrame
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
dispatchMessageAdd
(
packet
)
;
return
;
}
this
.
webConsoleFrame
.
handlePageError
(
packet
.
pageError
)
;
}
}
_onLogMessage
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleLogMessage
(
packet
)
;
}
}
_onConsoleAPICall
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
if
(
this
.
webConsoleFrame
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
dispatchMessageAdd
(
packet
)
;
}
else
{
this
.
webConsoleFrame
.
handleConsoleAPICall
(
packet
.
message
)
;
}
}
}
_onNetworkEvent
:
function
(
type
networkInfo
)
{
if
(
this
.
webConsoleFrame
)
{
if
(
this
.
webConsoleFrame
.
NEW_CONSOLE_OUTPUT_ENABLED
)
{
this
.
dispatchMessageAdd
(
networkInfo
)
;
}
else
{
this
.
webConsoleFrame
.
handleNetworkEvent
(
networkInfo
)
;
}
}
}
_onNetworkEventUpdate
:
function
(
type
{
packet
networkInfo
}
)
{
if
(
this
.
webConsoleFrame
)
{
this
.
webConsoleFrame
.
handleNetworkEventUpdate
(
networkInfo
packet
)
;
}
}
_onFileActivity
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleFileActivity
(
packet
.
uri
)
;
}
}
_onReflowActivity
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleReflowActivity
(
packet
)
;
}
}
_onServerLogCall
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleConsoleAPICall
(
packet
.
message
)
;
}
}
_onLastPrivateContextExited
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
jsterm
.
clearPrivateMessages
(
)
;
}
}
_onTabNavigated
:
function
(
event
packet
)
{
if
(
!
this
.
webConsoleFrame
)
{
return
;
}
this
.
webConsoleFrame
.
handleTabNavigated
(
event
packet
)
;
}
releaseActor
:
function
(
actor
)
{
if
(
this
.
client
)
{
this
.
client
.
release
(
actor
)
;
}
}
disconnect
:
function
(
)
{
if
(
this
.
_disconnecter
)
{
return
this
.
_disconnecter
.
promise
;
}
this
.
_disconnecter
=
promise
.
defer
(
)
;
if
(
!
this
.
client
)
{
this
.
_disconnecter
.
resolve
(
null
)
;
return
this
.
_disconnecter
.
promise
;
}
this
.
client
.
removeListener
(
"
logMessage
"
this
.
_onLogMessage
)
;
this
.
client
.
removeListener
(
"
pageError
"
this
.
_onPageError
)
;
this
.
client
.
removeListener
(
"
consoleAPICall
"
this
.
_onConsoleAPICall
)
;
this
.
client
.
removeListener
(
"
fileActivity
"
this
.
_onFileActivity
)
;
this
.
client
.
removeListener
(
"
reflowActivity
"
this
.
_onReflowActivity
)
;
this
.
client
.
removeListener
(
"
serverLogCall
"
this
.
_onServerLogCall
)
;
this
.
client
.
removeListener
(
"
lastPrivateContextExited
"
this
.
_onLastPrivateContextExited
)
;
this
.
webConsoleClient
.
off
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
off
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
_onTabNavigated
)
;
this
.
target
.
off
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
client
=
null
;
this
.
webConsoleClient
=
null
;
this
.
target
=
null
;
this
.
connected
=
false
;
this
.
webConsoleFrame
=
null
;
this
.
_disconnecter
.
resolve
(
null
)
;
return
this
.
_disconnecter
.
promise
;
}
}
;
function
ConsoleContextMenu
(
owner
)
{
this
.
owner
=
owner
;
this
.
popup
=
this
.
owner
.
document
.
getElementById
(
"
output
-
contextmenu
"
)
;
this
.
build
=
this
.
build
.
bind
(
this
)
;
this
.
popup
.
addEventListener
(
"
popupshowing
"
this
.
build
)
;
}
ConsoleContextMenu
.
prototype
=
{
lastClickedMessage
:
null
build
:
function
(
event
)
{
let
metadata
=
this
.
getSelectionMetadata
(
event
.
rangeParent
)
;
for
(
let
element
of
this
.
popup
.
children
)
{
element
.
hidden
=
this
.
shouldHideMenuItem
(
element
metadata
)
;
}
}
getSelectionMetadata
:
function
(
clickElement
)
{
let
metadata
=
{
selectionType
:
"
"
selection
:
new
Set
(
)
}
;
let
selectedItems
=
this
.
owner
.
output
.
getSelectedMessages
(
)
;
if
(
!
selectedItems
.
length
)
{
let
clickedItem
=
this
.
owner
.
output
.
getMessageForElement
(
clickElement
)
;
if
(
clickedItem
)
{
this
.
lastClickedMessage
=
clickedItem
;
selectedItems
=
[
clickedItem
]
;
}
}
metadata
.
selectionType
=
selectedItems
.
length
>
1
?
"
multiple
"
:
"
single
"
;
let
selection
=
metadata
.
selection
;
for
(
let
item
of
selectedItems
)
{
switch
(
item
.
category
)
{
case
CATEGORY_NETWORK
:
selection
.
add
(
"
network
"
)
;
break
;
case
CATEGORY_CSS
:
selection
.
add
(
"
css
"
)
;
break
;
case
CATEGORY_JS
:
selection
.
add
(
"
js
"
)
;
break
;
case
CATEGORY_WEBDEV
:
selection
.
add
(
"
webdev
"
)
;
break
;
case
CATEGORY_SERVER
:
selection
.
add
(
"
server
"
)
;
break
;
}
}
return
metadata
;
}
shouldHideMenuItem
:
function
(
menuItem
metadata
)
{
let
selectionType
=
menuItem
.
getAttribute
(
"
selectiontype
"
)
;
if
(
selectionType
&
&
!
metadata
.
selectionType
=
=
selectionType
)
{
return
true
;
}
let
selection
=
menuItem
.
getAttribute
(
"
selection
"
)
;
if
(
!
selection
)
{
return
false
;
}
let
shouldHide
=
true
;
let
itemData
=
selection
.
split
(
"
|
"
)
;
for
(
let
type
of
metadata
.
selection
)
{
if
(
itemData
.
indexOf
(
type
)
!
=
=
-
1
)
{
shouldHide
=
false
;
break
;
}
}
return
shouldHide
;
}
destroy
:
function
(
)
{
this
.
popup
.
removeEventListener
(
"
popupshowing
"
this
.
build
)
;
this
.
popup
=
null
;
this
.
owner
=
null
;
this
.
lastClickedMessage
=
null
;
}
}
;
