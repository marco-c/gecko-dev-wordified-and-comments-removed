"
use
strict
"
;
var
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
Utils
"
"
devtools
/
client
/
webconsole
/
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
WebConsoleUI
"
"
devtools
/
client
/
webconsole
/
webconsole
-
ui
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
viewSource
"
"
devtools
/
client
/
shared
/
view
-
source
"
)
;
loader
.
lazyRequireGetter
(
this
"
openDocLink
"
"
devtools
/
client
/
shared
/
link
"
true
)
;
var
gHudId
=
0
;
const
isMacOS
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
class
WebConsole
{
constructor
(
target
iframeWindow
chromeWindow
hudService
isBrowserConsole
=
false
fissionSupport
=
false
)
{
this
.
iframeWindow
=
iframeWindow
;
this
.
chromeWindow
=
chromeWindow
;
this
.
hudId
=
"
hud_
"
+
+
+
gHudId
;
this
.
target
=
target
;
this
.
browserWindow
=
this
.
chromeWindow
.
top
;
this
.
hudService
=
hudService
;
this
.
isBrowserConsole
=
isBrowserConsole
;
this
.
fissionSupport
=
fissionSupport
;
const
element
=
this
.
browserWindow
.
document
.
documentElement
;
if
(
element
.
getAttribute
(
"
windowtype
"
)
!
=
gDevTools
.
chromeWindowType
)
{
this
.
browserWindow
=
this
.
hudService
.
currentContext
(
)
;
}
this
.
ui
=
new
WebConsoleUI
(
this
)
;
this
.
_destroyer
=
null
;
}
get
chromeUtilsWindow
(
)
{
if
(
this
.
browserWindow
)
{
return
this
.
browserWindow
;
}
return
this
.
chromeWindow
.
top
;
}
get
gViewSourceUtils
(
)
{
return
this
.
chromeUtilsWindow
.
gViewSourceUtils
;
}
init
(
)
{
return
this
.
ui
.
init
(
)
.
then
(
(
)
=
>
this
)
;
}
get
jsterm
(
)
{
return
this
.
ui
?
this
.
ui
.
jsterm
:
null
;
}
getInputValue
(
)
{
if
(
!
this
.
jsterm
)
{
return
null
;
}
return
this
.
jsterm
.
_getValue
(
)
;
}
setInputValue
(
newValue
)
{
if
(
!
this
.
jsterm
)
{
return
;
}
this
.
jsterm
.
_setValue
(
newValue
)
;
}
setFilterState
(
)
{
this
.
ui
&
&
this
.
ui
.
setFilterState
.
apply
(
this
.
ui
arguments
)
;
}
openLink
(
link
e
=
{
}
)
{
openDocLink
(
link
{
relatedToCurrent
:
true
inBackground
:
isMacOS
?
e
.
metaKey
:
e
.
ctrlKey
}
)
;
if
(
e
&
&
typeof
e
.
stopPropagation
=
=
=
"
function
"
)
{
e
.
stopPropagation
(
)
;
}
}
viewSource
(
sourceURL
sourceLine
)
{
this
.
gViewSourceUtils
.
viewSource
(
{
URL
:
sourceURL
lineNumber
:
sourceLine
|
|
0
}
)
;
}
viewSourceInStyleEditor
(
sourceURL
sourceLine
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
target
)
;
if
(
!
toolbox
)
{
this
.
viewSource
(
sourceURL
sourceLine
)
;
return
;
}
toolbox
.
viewSourceInStyleEditor
(
sourceURL
sourceLine
)
;
}
viewSourceInDebugger
(
sourceURL
sourceLine
sourceColumn
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
target
)
;
if
(
!
toolbox
)
{
this
.
viewSource
(
sourceURL
sourceLine
sourceColumn
)
;
return
;
}
toolbox
.
viewSourceInDebugger
(
sourceURL
sourceLine
sourceColumn
)
.
then
(
(
)
=
>
{
this
.
ui
.
emit
(
"
source
-
in
-
debugger
-
opened
"
)
;
}
)
;
}
viewSourceInScratchpad
(
sourceURL
sourceLine
)
{
viewSource
.
viewSourceInScratchpad
(
sourceURL
sourceLine
)
;
}
getDebuggerFrames
(
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
target
)
;
if
(
!
toolbox
)
{
return
null
;
}
const
panel
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
if
(
!
panel
)
{
return
null
;
}
return
panel
.
getFrames
(
)
;
}
lookupConsoleClient
(
thread
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
target
)
;
const
panel
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
return
panel
.
lookupConsoleClient
(
thread
)
;
}
getMappedExpression
(
expression
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
target
)
;
const
panel
=
toolbox
&
&
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
if
(
panel
)
{
return
panel
.
getMappedExpression
(
expression
)
;
}
if
(
this
.
parserService
&
&
expression
.
includes
(
"
await
"
)
)
{
const
shouldMapBindings
=
false
;
const
shouldMapAwait
=
true
;
const
res
=
this
.
parserService
.
mapExpression
(
expression
null
null
shouldMapBindings
shouldMapAwait
)
;
return
res
;
}
return
null
;
}
get
parserService
(
)
{
if
(
this
.
_parserService
)
{
return
this
.
_parserService
;
}
const
{
ParserDispatcher
}
=
require
(
"
devtools
/
client
/
debugger
/
src
/
workers
/
parser
/
index
"
)
;
this
.
_parserService
=
new
ParserDispatcher
(
)
;
this
.
_parserService
.
start
(
"
resource
:
/
/
devtools
/
client
/
debugger
/
dist
/
parser
-
worker
.
js
"
this
.
chromeUtilsWindow
)
;
return
this
.
_parserService
;
}
getInspectorSelection
(
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
target
)
;
if
(
!
toolbox
)
{
return
null
;
}
const
panel
=
toolbox
.
getPanel
(
"
inspector
"
)
;
if
(
!
panel
|
|
!
panel
.
selection
)
{
return
null
;
}
return
panel
.
selection
;
}
async
destroy
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
this
.
_destroyer
=
(
async
(
)
=
>
{
this
.
hudService
.
consoles
.
delete
(
this
.
hudId
)
;
if
(
this
.
ui
)
{
this
.
ui
.
destroy
(
)
;
}
if
(
!
this
.
isBrowserConsole
)
{
try
{
await
this
.
target
.
focus
(
)
;
}
catch
(
ex
)
{
}
}
if
(
this
.
_parserService
)
{
this
.
_parserService
.
stop
(
)
;
this
.
_parserService
=
null
;
}
const
id
=
Utils
.
supportsString
(
this
.
hudId
)
;
Services
.
obs
.
notifyObservers
(
id
"
web
-
console
-
destroyed
"
)
;
}
)
(
)
;
return
this
.
_destroyer
;
}
}
module
.
exports
=
WebConsole
;
