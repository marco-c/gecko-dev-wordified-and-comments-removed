"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
{
Utils
:
WebConsoleUtils
CONSOLE_WORKER_IDS
}
=
require
(
"
devtools
/
shared
/
webconsole
/
utils
"
)
;
const
promise
=
require
(
"
promise
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyImporter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolSidebar
"
"
devtools
/
client
/
framework
/
sidebar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleOutput
"
"
devtools
/
client
/
webconsole
/
console
-
output
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Messages
"
"
devtools
/
client
/
webconsole
/
console
-
output
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
devtools
/
shared
/
async
-
storage
"
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentClient
"
"
devtools
/
shared
/
client
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
system
"
"
devtools
/
shared
/
system
"
)
;
loader
.
lazyRequireGetter
(
this
"
Timers
"
"
sdk
/
timers
"
)
;
loader
.
lazyImporter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
VariablesViewController
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
PluralForm
"
"
resource
:
/
/
gre
/
modules
/
PluralForm
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
gDevTools
"
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
)
;
const
STRINGS_URI
=
"
chrome
:
/
/
devtools
/
locale
/
webconsole
.
properties
"
;
var
l10n
=
new
WebConsoleUtils
.
l10n
(
STRINGS_URI
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
MIXED_CONTENT_LEARN_MORE
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Security
/
MixedContent
"
;
const
TRACKING_PROTECTION_LEARN_MORE
=
"
https
:
/
/
developer
.
mozilla
.
org
/
Firefox
/
Privacy
/
Tracking_Protection
"
;
const
INSECURE_PASSWORDS_LEARN_MORE
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Security
/
InsecurePasswords
"
;
const
PUBLIC_KEY_PINS_LEARN_MORE
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Web
/
Security
/
Public_Key_Pinning
"
;
const
STRICT_TRANSPORT_SECURITY_LEARN_MORE
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Security
/
HTTP_Strict_Transport_Security
"
;
const
WEAK_SIGNATURE_ALGORITHM_LEARN_MORE
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Security
/
Weak_Signature_Algorithm
"
;
const
HELP_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Tools
/
Web_Console
/
Helpers
"
;
const
VARIABLES_VIEW_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
VariablesView
.
xul
"
;
const
IGNORED_SOURCE_URLS
=
[
"
debugger
eval
code
"
]
;
const
SEARCH_DELAY
=
200
;
const
DEFAULT_LOG_LIMIT
=
1000
;
const
CATEGORY_NETWORK
=
0
;
const
CATEGORY_CSS
=
1
;
const
CATEGORY_JS
=
2
;
const
CATEGORY_WEBDEV
=
3
;
const
CATEGORY_INPUT
=
4
;
const
CATEGORY_OUTPUT
=
5
;
const
CATEGORY_SECURITY
=
6
;
const
CATEGORY_SERVER
=
7
;
const
SEVERITY_ERROR
=
0
;
const
SEVERITY_WARNING
=
1
;
const
SEVERITY_INFO
=
2
;
const
SEVERITY_LOG
=
3
;
const
CATEGORY_CLASS_FRAGMENTS
=
[
"
network
"
"
cssparser
"
"
exception
"
"
console
"
"
input
"
"
output
"
"
security
"
"
server
"
]
;
const
SEVERITY_CLASS_FRAGMENTS
=
[
"
error
"
"
warn
"
"
info
"
"
log
"
]
;
const
MESSAGE_PREFERENCE_KEYS
=
[
[
"
network
"
"
netwarn
"
"
netxhr
"
"
networkinfo
"
]
[
"
csserror
"
"
cssparser
"
null
"
csslog
"
]
[
"
exception
"
"
jswarn
"
null
"
jslog
"
]
[
"
error
"
"
warn
"
"
info
"
"
log
"
]
[
null
null
null
null
]
[
null
null
null
null
]
[
"
secerror
"
"
secwarn
"
null
null
]
[
"
servererror
"
"
serverwarn
"
"
serverinfo
"
"
serverlog
"
]
]
;
const
LEVELS
=
{
error
:
SEVERITY_ERROR
exception
:
SEVERITY_ERROR
assert
:
SEVERITY_ERROR
warn
:
SEVERITY_WARNING
info
:
SEVERITY_INFO
log
:
SEVERITY_LOG
trace
:
SEVERITY_LOG
table
:
SEVERITY_LOG
debug
:
SEVERITY_LOG
dir
:
SEVERITY_LOG
dirxml
:
SEVERITY_LOG
group
:
SEVERITY_LOG
groupCollapsed
:
SEVERITY_LOG
groupEnd
:
SEVERITY_LOG
time
:
SEVERITY_LOG
timeEnd
:
SEVERITY_LOG
count
:
SEVERITY_LOG
}
;
const
WORKERTYPES_PREFKEYS
=
[
'
sharedworkers
'
'
serviceworkers
'
'
windowlessworkers
'
]
;
const
MIN_HTTP_ERROR_CODE
=
400
;
const
MAX_HTTP_ERROR_CODE
=
599
;
const
HISTORY_BACK
=
-
1
;
const
HISTORY_FORWARD
=
1
;
const
GROUP_INDENT
=
12
;
const
MESSAGES_IN_INTERVAL
=
DEFAULT_LOG_LIMIT
;
const
OUTPUT_INTERVAL
=
20
;
const
MAX_CLEANUP_TIME
=
10
;
const
THROTTLE_UPDATES
=
1000
;
const
FILTER_PREFS_PREFIX
=
"
devtools
.
webconsole
.
filter
.
"
;
const
MIN_FONT_SIZE
=
10
;
const
PREF_CONNECTION_TIMEOUT
=
"
devtools
.
debugger
.
remote
-
timeout
"
;
const
PREF_PERSISTLOG
=
"
devtools
.
webconsole
.
persistlog
"
;
const
PREF_MESSAGE_TIMESTAMP
=
"
devtools
.
webconsole
.
timestampMessages
"
;
const
PREF_INPUT_HISTORY_COUNT
=
"
devtools
.
webconsole
.
inputHistoryCount
"
;
function
WebConsoleFrame
(
webConsoleOwner
)
{
this
.
owner
=
webConsoleOwner
;
this
.
hudId
=
this
.
owner
.
hudId
;
this
.
window
=
this
.
owner
.
iframeWindow
;
this
.
_repeatNodes
=
{
}
;
this
.
_outputQueue
=
[
]
;
this
.
_itemDestroyQueue
=
[
]
;
this
.
_pruneCategoriesQueue
=
{
}
;
this
.
filterPrefs
=
{
}
;
this
.
output
=
new
ConsoleOutput
(
this
)
;
this
.
_toggleFilter
=
this
.
_toggleFilter
.
bind
(
this
)
;
this
.
resize
=
this
.
resize
.
bind
(
this
)
;
this
.
_onPanelSelected
=
this
.
_onPanelSelected
.
bind
(
this
)
;
this
.
_flushMessageQueue
=
this
.
_flushMessageQueue
.
bind
(
this
)
;
this
.
_onToolboxPrefChanged
=
this
.
_onToolboxPrefChanged
.
bind
(
this
)
;
this
.
_onUpdateListeners
=
this
.
_onUpdateListeners
.
bind
(
this
)
;
this
.
_outputTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_outputTimerInitialized
=
false
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
WebConsoleFrame
=
WebConsoleFrame
;
WebConsoleFrame
.
prototype
=
{
owner
:
null
proxy
:
null
get
popupset
(
)
{
return
this
.
owner
.
mainPopupSet
;
}
_initDefer
:
null
_lastOutputFlush
:
0
_outputQueue
:
null
_pruneCategoriesQueue
:
null
_flushCallback
:
null
_outputTimer
:
null
_outputTimerInitialized
:
null
_repeatNodes
:
null
filterPrefs
:
null
_filterPrefsPrefix
:
FILTER_PREFS_PREFIX
groupDepth
:
0
contentLocation
:
"
"
jsterm
:
null
outputNode
:
null
output
:
null
filterBox
:
null
get
webConsoleClient
(
)
{
return
this
.
proxy
?
this
.
proxy
.
webConsoleClient
:
null
;
}
_destroyer
:
null
_saveRequestAndResponseBodies
:
true
_chevronWidth
:
0
_inputCharWidth
:
0
setSaveRequestAndResponseBodies
:
function
(
value
)
{
if
(
!
this
.
webConsoleClient
)
{
return
promise
.
resolve
(
null
)
;
}
let
deferred
=
promise
.
defer
(
)
;
let
newValue
=
!
!
value
;
let
toSet
=
{
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
:
newValue
}
;
this
.
webConsoleClient
.
setPreferences
(
toSet
response
=
>
{
if
(
!
response
.
error
)
{
this
.
_saveRequestAndResponseBodies
=
newValue
;
deferred
.
resolve
(
response
)
;
}
else
{
deferred
.
reject
(
response
.
error
)
;
}
}
)
;
return
deferred
.
promise
;
}
get
persistLog
(
)
{
return
this
.
owner
.
_browserConsole
|
|
Services
.
prefs
.
getBoolPref
(
PREF_PERSISTLOG
)
;
}
init
:
function
(
)
{
this
.
_initUI
(
)
;
let
connectionInited
=
this
.
_initConnection
(
)
;
let
allReady
=
this
.
jsterm
.
historyLoaded
.
catch
(
(
)
=
>
{
}
)
.
then
(
(
)
=
>
{
return
connectionInited
;
}
)
;
let
notifyObservers
=
(
)
=
>
{
let
id
=
WebConsoleUtils
.
supportsString
(
this
.
hudId
)
;
Services
.
obs
.
notifyObservers
(
id
"
web
-
console
-
created
"
null
)
;
}
;
allReady
.
then
(
notifyObservers
notifyObservers
)
;
return
allReady
;
}
_initConnection
:
function
(
)
{
if
(
this
.
_initDefer
)
{
return
this
.
_initDefer
.
promise
;
}
this
.
_initDefer
=
promise
.
defer
(
)
;
this
.
proxy
=
new
WebConsoleConnectionProxy
(
this
this
.
owner
.
target
)
;
this
.
proxy
.
connect
(
)
.
then
(
(
)
=
>
{
this
.
_initDefer
.
resolve
(
this
)
;
}
(
reason
)
=
>
{
let
node
=
this
.
createMessageNode
(
CATEGORY_JS
SEVERITY_ERROR
reason
.
error
+
"
:
"
+
reason
.
message
)
;
this
.
outputMessage
(
CATEGORY_JS
node
[
reason
]
)
;
this
.
_initDefer
.
reject
(
reason
)
;
}
)
;
return
this
.
_initDefer
.
promise
;
}
_initUI
:
function
(
)
{
this
.
document
=
this
.
window
.
document
;
this
.
rootElement
=
this
.
document
.
documentElement
;
this
.
_initDefaultFilterPrefs
(
)
;
this
.
_commandController
=
new
CommandController
(
this
)
;
this
.
window
.
controllers
.
insertControllerAt
(
0
this
.
_commandController
)
;
this
.
_contextMenuHandler
=
new
ConsoleContextMenu
(
this
)
;
let
doc
=
this
.
document
;
if
(
system
.
constants
.
platform
=
=
=
"
macosx
"
)
{
doc
.
querySelector
(
"
#
key_clearOSX
"
)
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
doc
.
querySelector
(
"
#
key_clear
"
)
.
removeAttribute
(
"
disabled
"
)
;
}
this
.
filterBox
=
doc
.
querySelector
(
"
.
hud
-
filter
-
box
"
)
;
this
.
outputNode
=
doc
.
getElementById
(
"
output
-
container
"
)
;
this
.
outputWrapper
=
doc
.
getElementById
(
"
output
-
wrapper
"
)
;
this
.
completeNode
=
doc
.
querySelector
(
"
.
jsterm
-
complete
-
node
"
)
;
this
.
inputNode
=
doc
.
querySelector
(
"
.
jsterm
-
input
-
node
"
)
;
this
.
_setFilterTextBoxEvents
(
)
;
this
.
_initFilterButtons
(
)
;
let
fontSize
=
this
.
owner
.
_browserConsole
?
Services
.
prefs
.
getIntPref
(
"
devtools
.
webconsole
.
fontSize
"
)
:
0
;
if
(
fontSize
!
=
0
)
{
fontSize
=
Math
.
max
(
MIN_FONT_SIZE
fontSize
)
;
this
.
outputNode
.
style
.
fontSize
=
fontSize
+
"
px
"
;
this
.
completeNode
.
style
.
fontSize
=
fontSize
+
"
px
"
;
this
.
inputNode
.
style
.
fontSize
=
fontSize
+
"
px
"
;
}
if
(
this
.
owner
.
_browserConsole
)
{
for
(
let
id
of
[
"
Enlarge
"
"
Reduce
"
"
Reset
"
]
)
{
this
.
document
.
getElementById
(
"
cmd_fullZoom
"
+
id
)
.
removeAttribute
(
"
disabled
"
)
;
}
}
this
.
_updateCharSize
(
)
;
let
clearButton
=
doc
.
getElementsByClassName
(
"
webconsole
-
clear
-
console
-
button
"
)
[
0
]
;
clearButton
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
owner
.
_onClearButton
(
)
;
this
.
jsterm
.
clearOutput
(
true
)
;
}
)
;
this
.
jsterm
=
new
JSTerm
(
this
)
;
this
.
jsterm
.
init
(
)
;
this
.
resize
(
)
;
this
.
window
.
addEventListener
(
"
resize
"
this
.
resize
true
)
;
this
.
jsterm
.
on
(
"
sidebar
-
opened
"
this
.
resize
)
;
this
.
jsterm
.
on
(
"
sidebar
-
closed
"
this
.
resize
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
if
(
toolbox
)
{
toolbox
.
on
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
}
this
.
_addFocusCallback
(
this
.
outputNode
(
evt
)
=
>
{
if
(
(
evt
.
target
.
nodeName
.
toLowerCase
(
)
!
=
"
a
"
)
&
&
(
evt
.
target
.
parentNode
.
nodeName
.
toLowerCase
(
)
!
=
"
a
"
)
)
{
this
.
jsterm
.
inputNode
.
focus
(
)
;
}
}
)
;
gDevTools
.
on
(
"
pref
-
changed
"
this
.
_onToolboxPrefChanged
)
;
this
.
_onToolboxPrefChanged
(
"
pref
-
changed
"
{
pref
:
PREF_MESSAGE_TIMESTAMP
newValue
:
Services
.
prefs
.
getBoolPref
(
PREF_MESSAGE_TIMESTAMP
)
}
)
;
this
.
jsterm
.
inputNode
.
focus
(
)
;
}
resize
:
function
(
e
)
{
this
.
outputNode
.
style
.
width
=
this
.
outputWrapper
.
clientWidth
+
"
px
"
;
}
_onPanelSelected
:
function
(
evt
id
)
{
this
.
jsterm
.
inputNode
.
focus
(
)
;
}
_initDefaultFilterPrefs
:
function
(
)
{
let
prefs
=
[
"
network
"
"
networkinfo
"
"
csserror
"
"
cssparser
"
"
csslog
"
"
exception
"
"
jswarn
"
"
jslog
"
"
error
"
"
info
"
"
warn
"
"
log
"
"
secerror
"
"
secwarn
"
"
netwarn
"
"
netxhr
"
"
sharedworkers
"
"
serviceworkers
"
"
windowlessworkers
"
"
servererror
"
"
serverwarn
"
"
serverinfo
"
"
serverlog
"
]
;
for
(
let
pref
of
prefs
)
{
this
.
filterPrefs
[
pref
]
=
Services
.
prefs
.
getBoolPref
(
this
.
_filterPrefsPrefix
+
pref
)
;
}
}
_updateReflowActivityListener
:
function
(
callback
)
{
if
(
this
.
webConsoleClient
)
{
let
pref
=
this
.
_filterPrefsPrefix
+
"
csslog
"
;
if
(
Services
.
prefs
.
getBoolPref
(
pref
)
)
{
this
.
webConsoleClient
.
startListeners
(
[
"
ReflowActivity
"
]
callback
)
;
}
else
{
this
.
webConsoleClient
.
stopListeners
(
[
"
ReflowActivity
"
]
callback
)
;
}
}
}
_updateServerLoggingListener
:
function
(
callback
)
{
if
(
!
this
.
webConsoleClient
)
{
return
;
}
let
startListener
=
false
;
let
prefs
=
[
"
servererror
"
"
serverwarn
"
"
serverinfo
"
"
serverlog
"
]
;
for
(
let
i
=
0
;
i
<
prefs
.
length
;
i
+
+
)
{
if
(
this
.
filterPrefs
[
prefs
[
i
]
]
)
{
startListener
=
true
;
break
;
}
}
if
(
startListener
)
{
this
.
webConsoleClient
.
startListeners
(
[
"
ServerLogging
"
]
callback
)
;
}
else
{
this
.
webConsoleClient
.
stopListeners
(
[
"
ServerLogging
"
]
callback
)
;
}
}
_setFilterTextBoxEvents
:
function
(
)
{
let
timer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
let
timerEvent
=
this
.
adjustVisibilityOnSearchStringChange
.
bind
(
this
)
;
let
onChange
=
function
_onChange
(
)
{
timer
.
cancel
(
)
;
timer
.
initWithCallback
(
timerEvent
SEARCH_DELAY
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
;
this
.
filterBox
.
addEventListener
(
"
command
"
onChange
false
)
;
this
.
filterBox
.
addEventListener
(
"
input
"
onChange
false
)
;
}
_initFilterButtons
:
function
(
)
{
let
categories
=
this
.
document
.
querySelectorAll
(
"
.
webconsole
-
filter
-
button
[
category
]
"
)
;
Array
.
forEach
(
categories
function
(
button
)
{
button
.
addEventListener
(
"
contextmenu
"
(
event
)
=
>
{
button
.
open
=
true
;
}
false
)
;
button
.
addEventListener
(
"
click
"
this
.
_toggleFilter
false
)
;
let
someChecked
=
false
;
let
severities
=
button
.
querySelectorAll
(
"
menuitem
[
prefKey
]
"
)
;
Array
.
forEach
(
severities
function
(
menuItem
)
{
menuItem
.
addEventListener
(
"
command
"
this
.
_toggleFilter
false
)
;
let
prefKey
=
menuItem
.
getAttribute
(
"
prefKey
"
)
;
let
checked
=
this
.
filterPrefs
[
prefKey
]
;
menuItem
.
setAttribute
(
"
checked
"
checked
)
;
someChecked
=
someChecked
|
|
checked
;
}
this
)
;
button
.
setAttribute
(
"
checked
"
someChecked
)
;
button
.
setAttribute
(
"
aria
-
pressed
"
someChecked
)
;
}
this
)
;
if
(
!
this
.
owner
.
_browserConsole
)
{
let
jslog
=
this
.
document
.
querySelector
(
"
menuitem
[
prefKey
=
jslog
]
"
)
;
jslog
.
hidden
=
true
;
}
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
)
{
let
net
=
this
.
document
.
querySelector
(
"
toolbarbutton
[
category
=
net
]
"
)
;
let
accesskey
=
net
.
getAttribute
(
"
accesskeyMacOSX
"
)
;
net
.
setAttribute
(
"
accesskey
"
accesskey
)
;
let
logging
=
this
.
document
.
querySelector
(
"
toolbarbutton
[
category
=
logging
]
"
)
;
logging
.
removeAttribute
(
"
accesskey
"
)
;
let
serverLogging
=
this
.
document
.
querySelector
(
"
toolbarbutton
[
category
=
server
]
"
)
;
serverLogging
.
removeAttribute
(
"
accesskey
"
)
;
}
}
changeFontSize
:
function
(
size
)
{
let
fontSize
=
this
.
window
.
getComputedStyle
(
this
.
outputNode
null
)
.
getPropertyValue
(
"
font
-
size
"
)
.
replace
(
"
px
"
"
"
)
;
if
(
this
.
outputNode
.
style
.
fontSize
)
{
fontSize
=
this
.
outputNode
.
style
.
fontSize
.
replace
(
"
px
"
"
"
)
;
}
if
(
size
=
=
"
+
"
|
|
size
=
=
"
-
"
)
{
fontSize
=
parseInt
(
fontSize
10
)
;
if
(
size
=
=
"
+
"
)
{
fontSize
+
=
1
;
}
else
{
fontSize
-
=
1
;
}
if
(
fontSize
<
MIN_FONT_SIZE
)
{
fontSize
=
MIN_FONT_SIZE
;
}
Services
.
prefs
.
setIntPref
(
"
devtools
.
webconsole
.
fontSize
"
fontSize
)
;
fontSize
=
fontSize
+
"
px
"
;
this
.
completeNode
.
style
.
fontSize
=
fontSize
;
this
.
inputNode
.
style
.
fontSize
=
fontSize
;
this
.
outputNode
.
style
.
fontSize
=
fontSize
;
}
else
{
this
.
completeNode
.
style
.
fontSize
=
"
"
;
this
.
inputNode
.
style
.
fontSize
=
"
"
;
this
.
outputNode
.
style
.
fontSize
=
"
"
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
webconsole
.
fontSize
"
)
;
}
this
.
_updateCharSize
(
)
;
}
_updateCharSize
:
function
(
)
{
let
doc
=
this
.
document
;
let
tempLabel
=
doc
.
createElementNS
(
XHTML_NS
"
span
"
)
;
let
style
=
tempLabel
.
style
;
style
.
position
=
"
fixed
"
;
style
.
padding
=
"
0
"
;
style
.
margin
=
"
0
"
;
style
.
width
=
"
auto
"
;
style
.
color
=
"
transparent
"
;
WebConsoleUtils
.
copyTextStyles
(
this
.
inputNode
tempLabel
)
;
tempLabel
.
textContent
=
"
x
"
;
doc
.
documentElement
.
appendChild
(
tempLabel
)
;
this
.
_inputCharWidth
=
tempLabel
.
offsetWidth
;
tempLabel
.
parentNode
.
removeChild
(
tempLabel
)
;
this
.
_chevronWidth
=
+
doc
.
defaultView
.
getComputedStyle
(
this
.
inputNode
)
.
paddingLeft
.
replace
(
/
[
^
0
-
9
.
]
/
g
"
"
)
-
4
;
}
_toggleFilter
:
function
(
event
)
{
let
target
=
event
.
target
;
let
tagName
=
target
.
tagName
;
let
isRightClick
=
(
event
.
button
=
=
=
2
)
;
if
(
tagName
!
=
event
.
currentTarget
.
tagName
|
|
isRightClick
)
{
return
;
}
switch
(
tagName
)
{
case
"
toolbarbutton
"
:
{
let
originalTarget
=
event
.
originalTarget
;
let
classes
=
originalTarget
.
classList
;
if
(
originalTarget
.
localName
!
=
=
"
toolbarbutton
"
)
{
break
;
}
if
(
!
classes
.
contains
(
"
toolbarbutton
-
menubutton
-
button
"
)
&
&
originalTarget
.
getAttribute
(
"
type
"
)
=
=
=
"
menu
-
button
"
)
{
break
;
}
let
state
=
target
.
getAttribute
(
"
checked
"
)
!
=
=
"
true
"
;
if
(
event
.
getModifierState
(
"
Alt
"
)
)
{
let
buttons
=
this
.
document
.
querySelectorAll
(
"
.
webconsole
-
filter
-
button
"
)
;
Array
.
forEach
(
buttons
(
button
)
=
>
{
if
(
button
!
=
=
target
)
{
button
.
setAttribute
(
"
checked
"
false
)
;
button
.
setAttribute
(
"
aria
-
pressed
"
false
)
;
this
.
_setMenuState
(
button
false
)
;
}
}
)
;
state
=
true
;
}
target
.
setAttribute
(
"
checked
"
state
)
;
target
.
setAttribute
(
"
aria
-
pressed
"
state
)
;
this
.
_setMenuState
(
target
state
)
;
if
(
target
.
getAttribute
(
"
category
"
)
=
=
"
css
"
&
&
state
)
{
let
csslogMenuItem
=
target
.
querySelector
(
"
menuitem
[
prefKey
=
csslog
]
"
)
;
csslogMenuItem
.
setAttribute
(
"
checked
"
false
)
;
this
.
setFilterState
(
"
csslog
"
false
)
;
}
break
;
}
case
"
menuitem
"
:
{
let
state
=
target
.
getAttribute
(
"
checked
"
)
!
=
=
"
true
"
;
target
.
setAttribute
(
"
checked
"
state
)
;
let
prefKey
=
target
.
getAttribute
(
"
prefKey
"
)
;
this
.
setFilterState
(
prefKey
state
)
;
let
menuPopup
=
target
.
parentNode
;
let
someChecked
=
false
;
let
menuItem
=
menuPopup
.
firstChild
;
while
(
menuItem
)
{
if
(
menuItem
.
hasAttribute
(
"
prefKey
"
)
&
&
menuItem
.
getAttribute
(
"
checked
"
)
=
=
=
"
true
"
)
{
someChecked
=
true
;
break
;
}
menuItem
=
menuItem
.
nextSibling
;
}
let
toolbarButton
=
menuPopup
.
parentNode
;
toolbarButton
.
setAttribute
(
"
checked
"
someChecked
)
;
toolbarButton
.
setAttribute
(
"
aria
-
pressed
"
someChecked
)
;
break
;
}
}
}
_setMenuState
:
function
(
target
state
)
{
let
menuItems
=
target
.
querySelectorAll
(
"
menuitem
"
)
;
Array
.
forEach
(
menuItems
(
item
)
=
>
{
item
.
setAttribute
(
"
checked
"
state
)
;
let
prefKey
=
item
.
getAttribute
(
"
prefKey
"
)
;
this
.
setFilterState
(
prefKey
state
)
;
}
)
;
}
setFilterState
:
function
(
toggleType
state
)
{
this
.
filterPrefs
[
toggleType
]
=
state
;
this
.
adjustVisibilityForMessageType
(
toggleType
state
)
;
Services
.
prefs
.
setBoolPref
(
this
.
_filterPrefsPrefix
+
toggleType
state
)
;
if
(
this
.
_updateListenersTimeout
)
{
Timers
.
clearTimeout
(
this
.
_updateListenersTimeout
)
;
}
this
.
_updateListenersTimeout
=
Timers
.
setTimeout
(
this
.
_onUpdateListeners
200
)
;
}
getFilterState
:
function
(
toggleType
)
{
return
this
.
filterPrefs
[
toggleType
]
;
}
_onUpdateListeners
:
function
(
)
{
this
.
_updateReflowActivityListener
(
)
;
this
.
_updateServerLoggingListener
(
)
;
}
stringMatchesFilters
:
function
(
str
filter
)
{
if
(
!
filter
|
|
!
str
)
{
return
true
;
}
let
searchStr
=
str
.
toLowerCase
(
)
;
let
filterStrings
=
filter
.
toLowerCase
(
)
.
split
(
/
\
s
+
/
)
;
return
!
filterStrings
.
some
(
function
(
f
)
{
return
searchStr
.
indexOf
(
f
)
=
=
-
1
;
}
)
;
}
adjustVisibilityForMessageType
:
function
(
prefKey
state
)
{
let
outputNode
=
this
.
outputNode
;
let
doc
=
this
.
document
;
let
attribute
=
WORKERTYPES_PREFKEYS
.
indexOf
(
prefKey
)
=
=
-
1
?
'
filter
'
:
'
workerType
'
;
let
xpath
=
"
.
/
/
*
[
contains
(
class
'
message
'
)
and
"
+
"
"
+
attribute
+
"
=
'
"
+
prefKey
+
"
'
]
"
;
let
result
=
doc
.
evaluate
(
xpath
outputNode
null
Ci
.
nsIDOMXPathResult
.
UNORDERED_NODE_SNAPSHOT_TYPE
null
)
;
for
(
let
i
=
0
;
i
<
result
.
snapshotLength
;
i
+
+
)
{
let
node
=
result
.
snapshotItem
(
i
)
;
if
(
state
)
{
node
.
classList
.
remove
(
"
filtered
-
by
-
type
"
)
;
}
else
{
node
.
classList
.
add
(
"
filtered
-
by
-
type
"
)
;
}
}
}
adjustVisibilityOnSearchStringChange
:
function
(
)
{
let
nodes
=
this
.
outputNode
.
getElementsByClassName
(
"
message
"
)
;
let
searchString
=
this
.
filterBox
.
value
;
for
(
let
i
=
0
n
=
nodes
.
length
;
i
<
n
;
+
+
i
)
{
let
node
=
nodes
[
i
]
;
let
text
=
node
.
textContent
;
if
(
this
.
stringMatchesFilters
(
text
searchString
)
)
{
node
.
classList
.
remove
(
"
filtered
-
by
-
string
"
)
;
}
else
{
node
.
classList
.
add
(
"
filtered
-
by
-
string
"
)
;
}
}
}
filterMessageNode
:
function
(
node
)
{
let
isFiltered
=
false
;
let
prefKey
=
MESSAGE_PREFERENCE_KEYS
[
node
.
category
]
[
node
.
severity
]
;
if
(
prefKey
&
&
!
this
.
getFilterState
(
prefKey
)
)
{
node
.
classList
.
add
(
"
filtered
-
by
-
type
"
)
;
isFiltered
=
true
;
}
if
(
"
workerType
"
in
node
&
&
!
this
.
getFilterState
(
node
.
workerType
)
)
{
node
.
classList
.
add
(
"
filtered
-
by
-
type
"
)
;
isFiltered
=
true
;
}
let
search
=
this
.
filterBox
.
value
;
let
text
=
node
.
clipboardText
;
if
(
!
this
.
stringMatchesFilters
(
text
search
)
)
{
node
.
classList
.
add
(
"
filtered
-
by
-
string
"
)
;
isFiltered
=
true
;
}
if
(
isFiltered
&
&
node
.
classList
.
contains
(
"
inlined
-
variables
-
view
"
)
)
{
node
.
classList
.
add
(
"
hidden
-
message
"
)
;
}
return
isFiltered
;
}
mergeFilteredMessageNode
:
function
(
original
filtered
)
{
let
repeatNode
=
original
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
!
repeatNode
)
{
return
;
}
let
occurrences
=
parseInt
(
repeatNode
.
getAttribute
(
"
value
"
)
)
+
1
;
repeatNode
.
setAttribute
(
"
value
"
occurrences
)
;
repeatNode
.
textContent
=
occurrences
;
let
str
=
l10n
.
getStr
(
"
messageRepeats
.
tooltip2
"
)
;
repeatNode
.
title
=
PluralForm
.
get
(
occurrences
str
)
.
replace
(
"
#
1
"
occurrences
)
;
}
_filterRepeatedMessage
:
function
(
node
)
{
let
repeatNode
=
node
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
!
repeatNode
)
{
return
null
;
}
let
uid
=
repeatNode
.
_uid
;
let
dupeNode
=
null
;
if
(
node
.
category
=
=
CATEGORY_CSS
|
|
node
.
category
=
=
CATEGORY_SECURITY
)
{
dupeNode
=
this
.
_repeatNodes
[
uid
]
;
if
(
!
dupeNode
)
{
this
.
_repeatNodes
[
uid
]
=
node
;
}
}
else
if
(
(
node
.
category
=
=
CATEGORY_WEBDEV
|
|
node
.
category
=
=
CATEGORY_JS
)
&
&
node
.
category
!
=
CATEGORY_NETWORK
&
&
!
node
.
classList
.
contains
(
"
inlined
-
variables
-
view
"
)
)
{
let
lastMessage
=
this
.
outputNode
.
lastChild
;
if
(
!
lastMessage
)
{
return
null
;
}
let
lastRepeatNode
=
lastMessage
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
lastRepeatNode
&
&
lastRepeatNode
.
_uid
=
=
uid
)
{
dupeNode
=
lastMessage
;
}
}
if
(
dupeNode
)
{
this
.
mergeFilteredMessageNode
(
dupeNode
node
)
;
return
dupeNode
;
}
return
null
;
}
displayCachedMessages
:
function
(
remoteMessages
)
{
if
(
!
remoteMessages
.
length
)
{
return
;
}
remoteMessages
.
forEach
(
function
(
message
)
{
switch
(
message
.
_type
)
{
case
"
PageError
"
:
{
let
category
=
Utils
.
categoryForScriptError
(
message
)
;
this
.
outputMessage
(
category
this
.
reportPageError
[
category
message
]
)
;
break
;
}
case
"
LogMessage
"
:
this
.
handleLogMessage
(
message
)
;
break
;
case
"
ConsoleAPI
"
:
this
.
outputMessage
(
CATEGORY_WEBDEV
this
.
logConsoleAPIMessage
[
message
]
)
;
break
;
case
"
NetworkEvent
"
:
this
.
outputMessage
(
CATEGORY_NETWORK
this
.
logNetEvent
[
message
]
)
;
break
;
}
}
this
)
;
}
logConsoleAPIMessage
:
function
(
message
)
{
let
body
=
null
;
let
clipboardText
=
null
;
let
sourceURL
=
message
.
filename
;
let
sourceLine
=
message
.
lineNumber
;
let
level
=
message
.
level
;
let
args
=
message
.
arguments
;
let
objectActors
=
new
Set
(
)
;
let
node
=
null
;
args
.
forEach
(
(
value
)
=
>
{
if
(
WebConsoleUtils
.
isActorGrip
(
value
)
)
{
objectActors
.
add
(
value
.
actor
)
;
}
}
)
;
switch
(
level
)
{
case
"
log
"
:
case
"
info
"
:
case
"
warn
"
:
case
"
error
"
:
case
"
exception
"
:
case
"
assert
"
:
case
"
debug
"
:
{
let
msg
=
new
Messages
.
ConsoleGeneric
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
table
"
:
{
let
msg
=
new
Messages
.
ConsoleTable
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
trace
"
:
{
let
msg
=
new
Messages
.
ConsoleTrace
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
dir
"
:
{
body
=
{
arguments
:
args
}
;
let
clipboardArray
=
[
]
;
args
.
forEach
(
(
value
)
=
>
{
clipboardArray
.
push
(
VariablesView
.
getString
(
value
)
)
;
}
)
;
clipboardText
=
clipboardArray
.
join
(
"
"
)
;
break
;
}
case
"
dirxml
"
:
{
message
.
level
=
"
log
"
;
return
this
.
logConsoleAPIMessage
(
message
)
;
}
case
"
group
"
:
case
"
groupCollapsed
"
:
clipboardText
=
body
=
message
.
groupName
;
this
.
groupDepth
+
+
;
break
;
case
"
groupEnd
"
:
if
(
this
.
groupDepth
>
0
)
{
this
.
groupDepth
-
-
;
}
break
;
case
"
time
"
:
{
let
timer
=
message
.
timer
;
if
(
!
timer
)
{
return
null
;
}
if
(
timer
.
error
)
{
Cu
.
reportError
(
l10n
.
getStr
(
timer
.
error
)
)
;
return
null
;
}
body
=
l10n
.
getFormatStr
(
"
timerStarted
"
[
timer
.
name
]
)
;
clipboardText
=
body
;
break
;
}
case
"
timeEnd
"
:
{
let
timer
=
message
.
timer
;
if
(
!
timer
)
{
return
null
;
}
let
duration
=
Math
.
round
(
timer
.
duration
*
100
)
/
100
;
body
=
l10n
.
getFormatStr
(
"
timeEnd
"
[
timer
.
name
duration
]
)
;
clipboardText
=
body
;
break
;
}
case
"
count
"
:
{
let
counter
=
message
.
counter
;
if
(
!
counter
)
{
return
null
;
}
if
(
counter
.
error
)
{
Cu
.
reportError
(
l10n
.
getStr
(
counter
.
error
)
)
;
return
null
;
}
let
msg
=
new
Messages
.
ConsoleGeneric
(
message
)
;
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
break
;
}
case
"
timeStamp
"
:
{
return
null
;
}
default
:
Cu
.
reportError
(
"
Unknown
Console
API
log
level
:
"
+
level
)
;
return
null
;
}
switch
(
level
)
{
case
"
group
"
:
case
"
groupCollapsed
"
:
case
"
groupEnd
"
:
case
"
time
"
:
case
"
timeEnd
"
:
case
"
count
"
:
for
(
let
actor
of
objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
objectActors
.
clear
(
)
;
}
if
(
level
=
=
"
groupEnd
"
)
{
return
null
;
}
if
(
!
node
)
{
node
=
this
.
createMessageNode
(
CATEGORY_WEBDEV
LEVELS
[
level
]
body
sourceURL
sourceLine
clipboardText
level
message
.
timeStamp
)
;
if
(
message
.
private
)
{
node
.
setAttribute
(
"
private
"
true
)
;
}
}
if
(
objectActors
.
size
>
0
)
{
node
.
_objectActors
=
objectActors
;
if
(
!
node
.
_messageObject
)
{
let
repeatNode
=
node
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
repeatNode
.
_uid
+
=
[
.
.
.
objectActors
]
.
join
(
"
-
"
)
;
}
}
let
workerTypeID
=
CONSOLE_WORKER_IDS
.
indexOf
(
message
.
workerType
)
;
if
(
workerTypeID
!
=
-
1
)
{
node
.
workerType
=
WORKERTYPES_PREFKEYS
[
workerTypeID
]
;
node
.
setAttribute
(
'
workerType
'
WORKERTYPES_PREFKEYS
[
workerTypeID
]
)
;
}
return
node
;
}
handleConsoleAPICall
:
function
(
message
)
{
this
.
outputMessage
(
CATEGORY_WEBDEV
this
.
logConsoleAPIMessage
[
message
]
)
;
}
reportPageError
:
function
(
category
scriptError
)
{
let
severity
=
'
error
'
;
if
(
scriptError
.
warning
|
|
scriptError
.
strict
)
{
severity
=
'
warning
'
;
}
else
if
(
scriptError
.
info
)
{
severity
=
'
log
'
;
}
switch
(
category
)
{
case
CATEGORY_CSS
:
category
=
'
css
'
;
break
;
case
CATEGORY_SECURITY
:
category
=
'
security
'
;
break
;
default
:
category
=
"
js
"
;
break
;
}
let
objectActors
=
new
Set
(
)
;
for
(
let
prop
of
[
"
errorMessage
"
"
lineText
"
]
)
{
let
grip
=
scriptError
[
prop
]
;
if
(
WebConsoleUtils
.
isActorGrip
(
grip
)
)
{
objectActors
.
add
(
grip
.
actor
)
;
}
}
let
errorMessage
=
scriptError
.
errorMessage
;
if
(
errorMessage
.
type
&
&
errorMessage
.
type
=
=
"
longString
"
)
{
errorMessage
=
errorMessage
.
initial
;
}
let
displayOrigin
=
scriptError
.
sourceName
;
if
(
scriptError
.
category
&
&
scriptError
.
category
=
=
"
SHA
-
1
Signature
"
)
{
let
sourceURI
=
Services
.
io
.
newURI
(
scriptError
.
sourceName
null
null
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
displayOrigin
=
sourceURI
.
prePath
;
}
let
msg
=
new
Messages
.
Simple
(
errorMessage
{
location
:
{
url
:
displayOrigin
line
:
scriptError
.
lineNumber
column
:
scriptError
.
columnNumber
}
stack
:
scriptError
.
stacktrace
category
:
category
severity
:
severity
timestamp
:
scriptError
.
timeStamp
private
:
scriptError
.
private
filterDuplicates
:
true
}
)
;
let
node
=
msg
.
init
(
this
.
output
)
.
render
(
)
.
element
;
let
msgBody
=
node
.
getElementsByClassName
(
"
message
-
body
"
)
[
0
]
;
this
.
addMoreInfoLink
(
msgBody
scriptError
)
;
if
(
objectActors
.
size
>
0
)
{
node
.
_objectActors
=
objectActors
;
}
return
node
;
}
handlePageError
:
function
(
pageError
)
{
let
category
=
Utils
.
categoryForScriptError
(
pageError
)
;
this
.
outputMessage
(
category
this
.
reportPageError
[
category
pageError
]
)
;
}
handleLogMessage
:
function
(
packet
)
{
if
(
packet
.
message
)
{
this
.
outputMessage
(
CATEGORY_JS
this
.
_reportLogMessage
[
packet
]
)
;
}
}
_reportLogMessage
:
function
(
packet
)
{
let
msg
=
packet
.
message
;
if
(
msg
.
type
&
&
msg
.
type
=
=
"
longString
"
)
{
msg
=
msg
.
initial
;
}
let
node
=
this
.
createMessageNode
(
CATEGORY_JS
SEVERITY_LOG
msg
null
null
null
null
packet
.
timeStamp
)
;
if
(
WebConsoleUtils
.
isActorGrip
(
packet
.
message
)
)
{
node
.
_objectActors
=
new
Set
(
[
packet
.
message
.
actor
]
)
;
}
return
node
;
}
logNetEvent
:
function
(
networkInfo
)
{
let
actorId
=
networkInfo
.
actor
;
let
request
=
networkInfo
.
request
;
let
clipboardText
=
request
.
method
+
"
"
+
request
.
url
;
let
severity
=
SEVERITY_LOG
;
if
(
networkInfo
.
isXHR
)
{
clipboardText
=
request
.
method
+
"
XHR
"
+
request
.
url
;
severity
=
SEVERITY_INFO
;
}
let
mixedRequest
=
WebConsoleUtils
.
isMixedHTTPSRequest
(
request
.
url
this
.
contentLocation
)
;
if
(
mixedRequest
)
{
severity
=
SEVERITY_WARNING
;
}
let
methodNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
methodNode
.
className
=
"
method
"
;
methodNode
.
textContent
=
request
.
method
+
"
"
;
let
messageNode
=
this
.
createMessageNode
(
CATEGORY_NETWORK
severity
methodNode
null
null
clipboardText
null
networkInfo
.
timeStamp
)
;
if
(
networkInfo
.
private
)
{
messageNode
.
setAttribute
(
"
private
"
true
)
;
}
messageNode
.
_connectionId
=
actorId
;
messageNode
.
url
=
request
.
url
;
let
body
=
methodNode
.
parentNode
;
body
.
setAttribute
(
"
aria
-
haspopup
"
true
)
;
if
(
networkInfo
.
isXHR
)
{
let
xhrNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
xhrNode
.
className
=
"
xhr
"
;
xhrNode
.
textContent
=
l10n
.
getStr
(
"
webConsoleXhrIndicator
"
)
;
body
.
appendChild
(
xhrNode
)
;
body
.
appendChild
(
this
.
document
.
createTextNode
(
"
"
)
)
;
}
let
displayUrl
=
request
.
url
;
let
pos
=
displayUrl
.
indexOf
(
"
?
"
)
;
if
(
pos
>
-
1
)
{
displayUrl
=
displayUrl
.
substr
(
0
pos
)
;
}
let
urlNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
urlNode
.
className
=
"
url
"
;
urlNode
.
setAttribute
(
"
title
"
request
.
url
)
;
urlNode
.
href
=
request
.
url
;
urlNode
.
textContent
=
displayUrl
;
urlNode
.
draggable
=
false
;
body
.
appendChild
(
urlNode
)
;
body
.
appendChild
(
this
.
document
.
createTextNode
(
"
"
)
)
;
if
(
mixedRequest
)
{
messageNode
.
classList
.
add
(
"
mixed
-
content
"
)
;
this
.
makeMixedContentNode
(
body
)
;
}
let
statusNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
statusNode
.
className
=
"
status
"
;
body
.
appendChild
(
statusNode
)
;
let
onClick
=
(
)
=
>
this
.
openNetworkPanel
(
networkInfo
.
actor
)
;
this
.
_addMessageLinkCallback
(
urlNode
onClick
)
;
this
.
_addMessageLinkCallback
(
statusNode
onClick
)
;
networkInfo
.
node
=
messageNode
;
this
.
_updateNetMessage
(
actorId
)
;
return
messageNode
;
}
makeMixedContentNode
:
function
(
linkNode
)
{
let
mixedContentWarning
=
"
[
"
+
l10n
.
getStr
(
"
webConsoleMixedContentWarning
"
)
+
"
]
"
;
let
mixedContentWarningNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
mixedContentWarningNode
.
title
=
MIXED_CONTENT_LEARN_MORE
;
mixedContentWarningNode
.
href
=
MIXED_CONTENT_LEARN_MORE
;
mixedContentWarningNode
.
className
=
"
learn
-
more
-
link
"
;
mixedContentWarningNode
.
textContent
=
mixedContentWarning
;
mixedContentWarningNode
.
draggable
=
false
;
linkNode
.
appendChild
(
mixedContentWarningNode
)
;
this
.
_addMessageLinkCallback
(
mixedContentWarningNode
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
this
.
owner
.
openLink
(
MIXED_CONTENT_LEARN_MORE
)
;
}
)
;
}
addMoreInfoLink
:
function
(
node
scriptError
)
{
let
url
;
switch
(
scriptError
.
category
)
{
case
"
Insecure
Password
Field
"
:
url
=
INSECURE_PASSWORDS_LEARN_MORE
;
break
;
case
"
Mixed
Content
Message
"
:
case
"
Mixed
Content
Blocker
"
:
url
=
MIXED_CONTENT_LEARN_MORE
;
break
;
case
"
Invalid
HPKP
Headers
"
:
url
=
PUBLIC_KEY_PINS_LEARN_MORE
;
break
;
case
"
Invalid
HSTS
Headers
"
:
url
=
STRICT_TRANSPORT_SECURITY_LEARN_MORE
;
break
;
case
"
SHA
-
1
Signature
"
:
url
=
WEAK_SIGNATURE_ALGORITHM_LEARN_MORE
;
break
;
case
"
Tracking
Protection
"
:
url
=
TRACKING_PROTECTION_LEARN_MORE
;
break
;
default
:
return
;
}
this
.
addLearnMoreWarningNode
(
node
url
)
;
}
addLearnMoreWarningNode
:
function
(
node
url
)
{
let
moreInfoLabel
=
"
[
"
+
l10n
.
getStr
(
"
webConsoleMoreInfoLabel
"
)
+
"
]
"
;
let
warningNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
warningNode
.
title
=
url
;
warningNode
.
href
=
url
;
warningNode
.
draggable
=
false
;
warningNode
.
textContent
=
moreInfoLabel
;
warningNode
.
className
=
"
learn
-
more
-
link
"
;
this
.
_addMessageLinkCallback
(
warningNode
(
event
)
=
>
{
event
.
stopPropagation
(
)
;
this
.
owner
.
openLink
(
url
)
;
}
)
;
node
.
appendChild
(
warningNode
)
;
}
logFileActivity
:
function
(
fileURI
)
{
let
urlNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
urlNode
.
setAttribute
(
"
title
"
fileURI
)
;
urlNode
.
className
=
"
url
"
;
urlNode
.
textContent
=
fileURI
;
urlNode
.
draggable
=
false
;
urlNode
.
href
=
fileURI
;
let
outputNode
=
this
.
createMessageNode
(
CATEGORY_NETWORK
SEVERITY_LOG
urlNode
null
null
fileURI
)
;
this
.
_addMessageLinkCallback
(
urlNode
(
)
=
>
{
this
.
owner
.
viewSource
(
fileURI
)
;
}
)
;
return
outputNode
;
}
handleFileActivity
:
function
(
fileURI
)
{
this
.
outputMessage
(
CATEGORY_NETWORK
this
.
logFileActivity
[
fileURI
]
)
;
}
logReflowActivity
:
function
(
message
)
{
let
{
start
end
sourceURL
sourceLine
}
=
message
;
let
duration
=
Math
.
round
(
(
end
-
start
)
*
100
)
/
100
;
let
node
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
if
(
sourceURL
)
{
node
.
textContent
=
l10n
.
getFormatStr
(
"
reflow
.
messageWithLink
"
[
duration
]
)
;
let
a
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
a
.
href
=
"
#
"
;
a
.
draggable
=
"
false
"
;
let
filename
=
WebConsoleUtils
.
abbreviateSourceURL
(
sourceURL
)
;
let
functionName
=
message
.
functionName
|
|
l10n
.
getStr
(
"
stacktrace
.
anonymousFunction
"
)
;
a
.
textContent
=
l10n
.
getFormatStr
(
"
reflow
.
messageLinkText
"
[
functionName
filename
sourceLine
]
)
;
this
.
_addMessageLinkCallback
(
a
(
)
=
>
{
this
.
owner
.
viewSourceInDebugger
(
sourceURL
sourceLine
)
;
}
)
;
node
.
appendChild
(
a
)
;
}
else
{
node
.
textContent
=
l10n
.
getFormatStr
(
"
reflow
.
messageWithNoLink
"
[
duration
]
)
;
}
return
this
.
createMessageNode
(
CATEGORY_CSS
SEVERITY_LOG
node
)
;
}
handleReflowActivity
:
function
(
message
)
{
this
.
outputMessage
(
CATEGORY_CSS
this
.
logReflowActivity
[
message
]
)
;
}
logWarningAboutReplacedAPI
:
function
(
)
{
let
node
=
this
.
createMessageNode
(
CATEGORY_JS
SEVERITY_WARNING
l10n
.
getStr
(
"
ConsoleAPIDisabled
"
)
)
;
this
.
outputMessage
(
CATEGORY_JS
node
)
;
}
handleNetworkEvent
:
function
(
networkInfo
)
{
this
.
outputMessage
(
CATEGORY_NETWORK
this
.
logNetEvent
[
networkInfo
]
)
;
}
handleNetworkEventUpdate
:
function
(
networkInfo
packet
)
{
if
(
networkInfo
.
node
&
&
this
.
_updateNetMessage
(
packet
.
from
)
)
{
this
.
emit
(
"
new
-
messages
"
new
Set
(
[
{
update
:
true
node
:
networkInfo
.
node
response
:
packet
}
]
)
)
;
}
if
(
this
.
owner
.
lastFinishedRequestCallback
&
&
networkInfo
.
updates
.
indexOf
(
"
responseContent
"
)
>
-
1
&
&
networkInfo
.
updates
.
indexOf
(
"
eventTimings
"
)
>
-
1
)
{
this
.
owner
.
lastFinishedRequestCallback
(
networkInfo
this
)
;
}
}
_updateNetMessage
:
function
(
actorId
)
{
let
networkInfo
=
this
.
webConsoleClient
.
getNetworkRequest
(
actorId
)
;
if
(
!
networkInfo
|
|
!
networkInfo
.
node
)
{
return
;
}
let
messageNode
=
networkInfo
.
node
;
let
updates
=
networkInfo
.
updates
;
let
hasEventTimings
=
updates
.
indexOf
(
"
eventTimings
"
)
>
-
1
;
let
hasResponseStart
=
updates
.
indexOf
(
"
responseStart
"
)
>
-
1
;
let
request
=
networkInfo
.
request
;
let
methodText
=
(
networkInfo
.
isXHR
)
?
request
.
method
+
'
XHR
'
:
request
.
method
;
let
response
=
networkInfo
.
response
;
let
updated
=
false
;
if
(
hasEventTimings
|
|
hasResponseStart
)
{
let
status
=
[
]
;
if
(
response
.
httpVersion
&
&
response
.
status
)
{
status
=
[
response
.
httpVersion
response
.
status
response
.
statusText
]
;
}
if
(
hasEventTimings
)
{
status
.
push
(
l10n
.
getFormatStr
(
"
NetworkPanel
.
durationMS
"
[
networkInfo
.
totalTime
]
)
)
;
}
let
statusText
=
"
[
"
+
status
.
join
(
"
"
)
+
"
]
"
;
let
statusNode
=
messageNode
.
getElementsByClassName
(
"
status
"
)
[
0
]
;
statusNode
.
textContent
=
statusText
;
messageNode
.
clipboardText
=
[
methodText
request
.
url
statusText
]
.
join
(
"
"
)
;
if
(
hasResponseStart
&
&
response
.
status
>
=
MIN_HTTP_ERROR_CODE
&
&
response
.
status
<
=
MAX_HTTP_ERROR_CODE
)
{
this
.
setMessageType
(
messageNode
CATEGORY_NETWORK
SEVERITY_ERROR
)
;
}
updated
=
true
;
}
if
(
messageNode
.
_netPanel
)
{
messageNode
.
_netPanel
.
update
(
)
;
}
return
updated
;
}
openNetworkPanel
:
function
(
requestId
)
{
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
if
(
!
toolbox
)
{
return
;
}
return
toolbox
.
selectTool
(
"
netmonitor
"
)
.
then
(
panel
=
>
{
return
panel
.
panelWin
.
NetMonitorController
.
inspectRequest
(
requestId
)
;
}
)
;
}
onLocationChange
:
function
(
uri
title
)
{
this
.
contentLocation
=
uri
;
if
(
this
.
owner
.
onLocationChange
)
{
this
.
owner
.
onLocationChange
(
uri
title
)
;
}
}
handleTabNavigated
:
function
(
event
packet
)
{
if
(
event
=
=
"
will
-
navigate
"
)
{
if
(
this
.
persistLog
)
{
let
marker
=
new
Messages
.
NavigationMarker
(
packet
Date
.
now
(
)
)
;
this
.
output
.
addMessage
(
marker
)
;
}
else
{
this
.
jsterm
.
clearOutput
(
)
;
}
}
if
(
packet
.
url
)
{
this
.
onLocationChange
(
packet
.
url
packet
.
title
)
;
}
if
(
event
=
=
"
navigate
"
&
&
!
packet
.
nativeConsoleAPI
)
{
this
.
logWarningAboutReplacedAPI
(
)
;
}
}
outputMessage
:
function
(
category
methodOrNode
args
)
{
if
(
!
this
.
_outputQueue
.
length
)
{
this
.
_lastOutputFlush
=
Date
.
now
(
)
;
}
this
.
_outputQueue
.
push
(
[
category
methodOrNode
args
]
)
;
this
.
_initOutputTimer
(
)
;
}
_flushMessageQueue
:
function
(
)
{
this
.
_outputTimerInitialized
=
false
;
if
(
!
this
.
_outputTimer
)
{
return
;
}
let
startTime
=
Date
.
now
(
)
;
let
timeSinceFlush
=
startTime
-
this
.
_lastOutputFlush
;
let
shouldThrottle
=
this
.
_outputQueue
.
length
>
MESSAGES_IN_INTERVAL
&
&
timeSinceFlush
<
THROTTLE_UPDATES
;
let
toDisplay
=
Math
.
min
(
this
.
_outputQueue
.
length
MESSAGES_IN_INTERVAL
)
;
if
(
shouldThrottle
|
|
toDisplay
<
1
)
{
while
(
this
.
_itemDestroyQueue
.
length
)
{
if
(
(
Date
.
now
(
)
-
startTime
)
>
MAX_CLEANUP_TIME
)
{
break
;
}
this
.
_destroyItem
(
this
.
_itemDestroyQueue
.
pop
(
)
)
;
}
this
.
_initOutputTimer
(
)
;
return
;
}
let
shouldPrune
=
false
;
if
(
this
.
_outputQueue
.
length
>
toDisplay
&
&
this
.
_pruneOutputQueue
(
)
)
{
toDisplay
=
Math
.
min
(
this
.
_outputQueue
.
length
toDisplay
)
;
shouldPrune
=
true
;
}
let
batch
=
this
.
_outputQueue
.
splice
(
0
toDisplay
)
;
let
outputNode
=
this
.
outputNode
;
let
lastVisibleNode
=
null
;
let
scrollNode
=
this
.
outputWrapper
;
let
hudIdSupportsString
=
WebConsoleUtils
.
supportsString
(
this
.
hudId
)
;
let
scrolledToBottom
=
shouldPrune
|
|
Utils
.
isOutputScrolledToBottom
(
outputNode
scrollNode
)
;
let
messages
=
new
Set
(
)
;
for
(
let
i
=
0
;
i
<
batch
.
length
;
i
+
+
)
{
let
item
=
batch
[
i
]
;
let
result
=
this
.
_outputMessageFromQueue
(
hudIdSupportsString
item
)
;
if
(
result
)
{
messages
.
add
(
{
node
:
result
.
isRepeated
?
result
.
isRepeated
:
result
.
node
response
:
result
.
message
update
:
!
!
result
.
isRepeated
}
)
;
if
(
result
.
visible
&
&
result
.
node
=
=
this
.
outputNode
.
lastChild
)
{
lastVisibleNode
=
result
.
node
;
}
}
}
let
oldScrollHeight
=
0
;
let
removedNodes
=
0
;
if
(
shouldPrune
|
|
!
this
.
_outputQueue
.
length
)
{
if
(
!
scrolledToBottom
)
{
oldScrollHeight
=
scrollNode
.
scrollHeight
;
}
let
categories
=
Object
.
keys
(
this
.
_pruneCategoriesQueue
)
;
categories
.
forEach
(
function
_pruneOutput
(
category
)
{
removedNodes
+
=
this
.
pruneOutputIfNecessary
(
category
)
;
}
this
)
;
this
.
_pruneCategoriesQueue
=
{
}
;
}
let
isInputOutput
=
lastVisibleNode
&
&
(
lastVisibleNode
.
category
=
=
CATEGORY_INPUT
|
|
lastVisibleNode
.
category
=
=
CATEGORY_OUTPUT
)
;
if
(
lastVisibleNode
&
&
(
scrolledToBottom
|
|
isInputOutput
)
)
{
Utils
.
scrollToVisible
(
lastVisibleNode
)
;
}
else
if
(
!
scrolledToBottom
&
&
removedNodes
>
0
&
&
oldScrollHeight
!
=
scrollNode
.
scrollHeight
)
{
scrollNode
.
scrollTop
-
=
oldScrollHeight
-
scrollNode
.
scrollHeight
;
}
if
(
messages
.
size
)
{
this
.
emit
(
"
new
-
messages
"
messages
)
;
}
if
(
this
.
_outputQueue
.
length
=
=
=
0
&
&
this
.
_flushCallback
)
{
if
(
this
.
_flushCallback
(
)
=
=
=
false
)
{
this
.
_flushCallback
=
null
;
}
}
this
.
_initOutputTimer
(
)
;
this
.
_lastOutputFlush
=
Date
.
now
(
)
;
}
_initOutputTimer
:
function
(
)
{
let
panelIsDestroyed
=
!
this
.
_outputTimer
;
let
alreadyScheduled
=
this
.
_outputTimerInitialized
;
let
nothingToDo
=
!
this
.
_itemDestroyQueue
.
length
&
&
!
this
.
_outputQueue
.
length
;
if
(
panelIsDestroyed
|
|
alreadyScheduled
|
|
nothingToDo
)
{
return
;
}
this
.
_outputTimerInitialized
=
true
;
this
.
_outputTimer
.
initWithCallback
(
this
.
_flushMessageQueue
OUTPUT_INTERVAL
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_outputMessageFromQueue
:
function
(
hudIdSupportsString
item
)
{
let
[
category
methodOrNode
args
]
=
item
;
let
message
=
(
args
&
&
args
.
length
)
?
args
[
args
.
length
-
1
]
:
null
;
let
node
=
typeof
methodOrNode
=
=
"
function
"
?
methodOrNode
.
apply
(
this
args
|
|
[
]
)
:
methodOrNode
;
if
(
!
node
)
{
return
null
;
}
let
isFiltered
=
this
.
filterMessageNode
(
node
)
;
let
isRepeated
=
this
.
_filterRepeatedMessage
(
node
)
;
let
visible
=
!
isRepeated
&
&
!
isFiltered
;
if
(
!
isRepeated
)
{
this
.
outputNode
.
appendChild
(
node
)
;
this
.
_pruneCategoriesQueue
[
node
.
category
]
=
true
;
let
nodeID
=
node
.
getAttribute
(
"
id
"
)
;
Services
.
obs
.
notifyObservers
(
hudIdSupportsString
"
web
-
console
-
message
-
created
"
nodeID
)
;
}
if
(
node
.
_onOutput
)
{
node
.
_onOutput
(
)
;
delete
node
.
_onOutput
;
}
return
{
visible
:
visible
node
:
node
isRepeated
:
isRepeated
message
:
message
}
;
}
_pruneOutputQueue
:
function
(
)
{
let
nodes
=
{
}
;
this
.
_outputQueue
.
forEach
(
function
(
item
index
)
{
let
[
category
]
=
item
;
if
(
!
(
category
in
nodes
)
)
{
nodes
[
category
]
=
[
]
;
}
nodes
[
category
]
.
push
(
index
)
;
}
this
)
;
let
pruned
=
0
;
for
(
let
category
in
nodes
)
{
let
limit
=
Utils
.
logLimitForCategory
(
category
)
;
let
indexes
=
nodes
[
category
]
;
if
(
indexes
.
length
>
limit
)
{
let
n
=
Math
.
max
(
0
indexes
.
length
-
limit
)
;
pruned
+
=
n
;
for
(
let
i
=
n
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
_itemDestroyQueue
.
push
(
this
.
_outputQueue
[
indexes
[
i
]
]
)
;
this
.
_outputQueue
.
splice
(
indexes
[
i
]
1
)
;
}
}
}
return
pruned
;
}
_destroyItem
:
function
(
item
)
{
let
[
category
methodOrNode
args
]
=
item
;
if
(
typeof
methodOrNode
!
=
"
function
"
&
&
methodOrNode
.
_objectActors
)
{
for
(
let
actor
of
methodOrNode
.
_objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
methodOrNode
.
_objectActors
.
clear
(
)
;
}
if
(
methodOrNode
=
=
this
.
output
.
_flushMessageQueue
&
&
args
[
0
]
.
_objectActors
)
{
for
(
let
arg
of
args
)
{
if
(
!
arg
.
_objectActors
)
{
continue
;
}
for
(
let
actor
of
arg
.
_objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
arg
.
_objectActors
.
clear
(
)
;
}
}
if
(
category
=
=
CATEGORY_NETWORK
)
{
let
connectionId
=
null
;
if
(
methodOrNode
=
=
this
.
logNetEvent
)
{
connectionId
=
args
[
0
]
.
actor
;
}
else
if
(
typeof
methodOrNode
!
=
"
function
"
)
{
connectionId
=
methodOrNode
.
_connectionId
;
}
if
(
connectionId
&
&
this
.
webConsoleClient
.
hasNetworkRequest
(
connectionId
)
)
{
this
.
webConsoleClient
.
removeNetworkRequest
(
connectionId
)
;
this
.
_releaseObject
(
connectionId
)
;
}
}
else
if
(
category
=
=
CATEGORY_WEBDEV
&
&
methodOrNode
=
=
this
.
logConsoleAPIMessage
)
{
args
[
0
]
.
arguments
.
forEach
(
(
value
)
=
>
{
if
(
WebConsoleUtils
.
isActorGrip
(
value
)
)
{
this
.
_releaseObject
(
value
.
actor
)
;
}
}
)
;
}
else
if
(
category
=
=
CATEGORY_JS
&
&
methodOrNode
=
=
this
.
reportPageError
)
{
let
pageError
=
args
[
1
]
;
for
(
let
prop
of
[
"
errorMessage
"
"
lineText
"
]
)
{
let
grip
=
pageError
[
prop
]
;
if
(
WebConsoleUtils
.
isActorGrip
(
grip
)
)
{
this
.
_releaseObject
(
grip
.
actor
)
;
}
}
}
else
if
(
category
=
=
CATEGORY_JS
&
&
methodOrNode
=
=
this
.
_reportLogMessage
)
{
if
(
WebConsoleUtils
.
isActorGrip
(
args
[
0
]
.
message
)
)
{
this
.
_releaseObject
(
args
[
0
]
.
message
.
actor
)
;
}
}
}
pruneOutputIfNecessary
:
function
(
category
)
{
let
logLimit
=
Utils
.
logLimitForCategory
(
category
)
;
let
messageNodes
=
this
.
outputNode
.
querySelectorAll
(
"
.
message
[
category
=
"
+
CATEGORY_CLASS_FRAGMENTS
[
category
]
+
"
]
"
)
;
let
n
=
Math
.
max
(
0
messageNodes
.
length
-
logLimit
)
;
[
.
.
.
messageNodes
]
.
slice
(
0
n
)
.
forEach
(
this
.
removeOutputMessage
this
)
;
return
n
;
}
removeOutputMessage
:
function
(
node
)
{
if
(
node
.
_messageObject
)
{
node
.
_messageObject
.
destroy
(
)
;
}
if
(
node
.
_objectActors
)
{
for
(
let
actor
of
node
.
_objectActors
)
{
this
.
_releaseObject
(
actor
)
;
}
node
.
_objectActors
.
clear
(
)
;
}
if
(
node
.
category
=
=
CATEGORY_CSS
|
|
node
.
category
=
=
CATEGORY_SECURITY
)
{
let
repeatNode
=
node
.
getElementsByClassName
(
"
message
-
repeats
"
)
[
0
]
;
if
(
repeatNode
&
&
repeatNode
.
_uid
)
{
delete
this
.
_repeatNodes
[
repeatNode
.
_uid
]
;
}
}
else
if
(
node
.
_connectionId
&
&
node
.
category
=
=
CATEGORY_NETWORK
)
{
this
.
webConsoleClient
.
removeNetworkRequest
(
node
.
_connectionId
)
;
this
.
_releaseObject
(
node
.
_connectionId
)
;
}
else
if
(
node
.
classList
.
contains
(
"
inlined
-
variables
-
view
"
)
)
{
let
view
=
node
.
_variablesView
;
if
(
view
)
{
view
.
controller
.
releaseActors
(
)
;
}
node
.
_variablesView
=
null
;
}
node
.
remove
(
)
;
}
createMessageNode
:
function
(
category
severity
body
sourceURL
sourceLine
clipboardText
level
timestamp
)
{
if
(
typeof
body
!
=
"
string
"
&
&
clipboardText
=
=
null
&
&
body
.
innerText
)
{
clipboardText
=
body
.
innerText
;
}
let
indentNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
indentNode
.
className
=
"
indent
"
;
let
indent
=
this
.
groupDepth
*
GROUP_INDENT
;
indentNode
.
style
.
width
=
indent
+
"
px
"
;
let
iconContainer
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
iconContainer
.
className
=
"
icon
"
;
let
bodyNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
bodyNode
.
className
=
"
message
-
body
-
wrapper
message
-
body
devtools
-
monospace
"
;
let
storedBody
=
body
;
clipboardText
=
clipboardText
|
|
(
body
+
(
sourceURL
?
"
"
+
sourceURL
:
"
"
)
+
(
sourceLine
?
"
:
"
+
sourceLine
:
"
"
)
)
;
timestamp
=
timestamp
|
|
Date
.
now
(
)
;
let
node
=
this
.
document
.
createElementNS
(
XHTML_NS
"
div
"
)
;
node
.
id
=
"
console
-
msg
-
"
+
gSequenceId
(
)
;
node
.
className
=
"
message
"
;
node
.
clipboardText
=
clipboardText
;
node
.
timestamp
=
timestamp
;
this
.
setMessageType
(
node
category
severity
)
;
if
(
body
instanceof
Ci
.
nsIDOMNode
)
{
bodyNode
.
appendChild
(
body
)
;
}
else
{
let
str
=
undefined
;
if
(
level
=
=
"
dir
"
)
{
str
=
VariablesView
.
getString
(
body
.
arguments
[
0
]
)
;
}
else
{
str
=
body
;
}
if
(
str
!
=
=
undefined
)
{
body
=
this
.
document
.
createTextNode
(
str
)
;
bodyNode
.
appendChild
(
body
)
;
}
}
let
repeatNode
=
null
;
if
(
category
!
=
CATEGORY_INPUT
&
&
category
!
=
CATEGORY_OUTPUT
&
&
category
!
=
CATEGORY_NETWORK
&
&
!
(
category
=
=
CATEGORY_CSS
&
&
severity
=
=
SEVERITY_LOG
)
)
{
repeatNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
repeatNode
.
setAttribute
(
"
value
"
"
1
"
)
;
repeatNode
.
className
=
"
message
-
repeats
"
;
repeatNode
.
textContent
=
1
;
repeatNode
.
_uid
=
[
bodyNode
.
textContent
category
severity
level
sourceURL
sourceLine
]
.
join
(
"
:
"
)
;
}
let
timestampNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
timestampNode
.
className
=
"
timestamp
devtools
-
monospace
"
;
let
timestampString
=
l10n
.
timestampString
(
timestamp
)
;
timestampNode
.
textContent
=
timestampString
+
"
"
;
let
locationNode
;
if
(
sourceURL
&
&
IGNORED_SOURCE_URLS
.
indexOf
(
sourceURL
)
=
=
-
1
)
{
locationNode
=
this
.
createLocationNode
(
{
url
:
sourceURL
line
:
sourceLine
}
)
;
}
node
.
appendChild
(
timestampNode
)
;
node
.
appendChild
(
indentNode
)
;
node
.
appendChild
(
iconContainer
)
;
if
(
level
=
=
"
dir
"
)
{
let
options
=
{
objectActor
:
storedBody
.
arguments
[
0
]
targetElement
:
bodyNode
hideFilterInput
:
true
}
;
this
.
jsterm
.
openVariablesView
(
options
)
.
then
(
(
view
)
=
>
{
node
.
_variablesView
=
view
;
if
(
node
.
classList
.
contains
(
"
hidden
-
message
"
)
)
{
node
.
classList
.
remove
(
"
hidden
-
message
"
)
;
}
}
)
;
node
.
classList
.
add
(
"
inlined
-
variables
-
view
"
)
;
}
node
.
appendChild
(
bodyNode
)
;
if
(
repeatNode
)
{
node
.
appendChild
(
repeatNode
)
;
}
if
(
locationNode
)
{
node
.
appendChild
(
locationNode
)
;
}
node
.
appendChild
(
this
.
document
.
createTextNode
(
"
\
n
"
)
)
;
return
node
;
}
createLocationNode
:
function
(
{
url
line
column
}
target
)
{
if
(
!
url
)
{
url
=
"
"
;
}
let
locationNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
a
"
)
;
let
filenameNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
let
filename
;
let
fullURL
;
let
isScratchpad
=
false
;
if
(
/
^
Scratchpad
\
/
\
d
+
/
.
test
(
url
)
)
{
filename
=
url
;
fullURL
=
url
;
isScratchpad
=
true
;
}
else
{
fullURL
=
url
.
split
(
"
-
>
"
)
.
pop
(
)
;
filename
=
WebConsoleUtils
.
abbreviateSourceURL
(
fullURL
)
;
}
filenameNode
.
className
=
"
filename
"
;
filenameNode
.
textContent
=
"
"
+
(
filename
|
|
l10n
.
getStr
(
"
unknownLocation
"
)
)
;
locationNode
.
appendChild
(
filenameNode
)
;
locationNode
.
href
=
isScratchpad
|
|
!
fullURL
?
"
#
"
:
fullURL
;
locationNode
.
draggable
=
false
;
if
(
target
)
{
locationNode
.
target
=
target
;
}
locationNode
.
setAttribute
(
"
title
"
url
)
;
locationNode
.
className
=
"
message
-
location
theme
-
link
devtools
-
monospace
"
;
let
onClick
=
(
)
=
>
{
let
target
=
locationNode
.
target
;
if
(
target
=
=
"
scratchpad
"
|
|
isScratchpad
)
{
this
.
owner
.
viewSourceInScratchpad
(
url
line
)
;
return
;
}
let
category
=
locationNode
.
parentNode
.
category
;
if
(
target
=
=
"
styleeditor
"
|
|
category
=
=
CATEGORY_CSS
)
{
this
.
owner
.
viewSourceInStyleEditor
(
fullURL
line
)
;
}
else
if
(
target
=
=
"
jsdebugger
"
|
|
category
=
=
CATEGORY_JS
|
|
category
=
=
CATEGORY_WEBDEV
)
{
this
.
owner
.
viewSourceInDebugger
(
fullURL
line
)
;
}
else
{
this
.
owner
.
viewSource
(
fullURL
line
)
;
}
}
;
if
(
fullURL
)
{
this
.
_addMessageLinkCallback
(
locationNode
onClick
)
;
}
if
(
line
)
{
let
lineNumberNode
=
this
.
document
.
createElementNS
(
XHTML_NS
"
span
"
)
;
lineNumberNode
.
className
=
"
line
-
number
"
;
lineNumberNode
.
textContent
=
"
:
"
+
line
+
(
column
>
=
0
?
"
:
"
+
column
:
"
"
)
;
locationNode
.
appendChild
(
lineNumberNode
)
;
locationNode
.
sourceLine
=
line
;
}
return
locationNode
;
}
setMessageType
:
function
(
messageNode
category
severity
)
{
messageNode
.
category
=
category
;
messageNode
.
severity
=
severity
;
messageNode
.
setAttribute
(
"
category
"
CATEGORY_CLASS_FRAGMENTS
[
category
]
)
;
messageNode
.
setAttribute
(
"
severity
"
SEVERITY_CLASS_FRAGMENTS
[
severity
]
)
;
messageNode
.
setAttribute
(
"
filter
"
MESSAGE_PREFERENCE_KEYS
[
category
]
[
severity
]
)
;
}
_addMessageLinkCallback
:
function
(
node
callback
)
{
node
.
addEventListener
(
"
mousedown
"
(
event
)
=
>
{
this
.
_mousedown
=
true
;
this
.
_startX
=
event
.
clientX
;
this
.
_startY
=
event
.
clientY
;
}
false
)
;
node
.
addEventListener
(
"
click
"
(
event
)
=
>
{
let
mousedown
=
this
.
_mousedown
;
this
.
_mousedown
=
false
;
event
.
preventDefault
(
)
;
if
(
event
.
detail
!
=
1
|
|
event
.
button
!
=
0
)
{
return
;
}
if
(
mousedown
&
&
(
this
.
_startX
!
=
event
.
clientX
)
&
&
(
this
.
_startY
!
=
event
.
clientY
)
)
{
this
.
_startX
=
this
.
_startY
=
undefined
;
return
;
}
this
.
_startX
=
this
.
_startY
=
undefined
;
callback
.
call
(
this
event
)
;
}
false
)
;
}
_addFocusCallback
:
function
(
node
callback
)
{
node
.
addEventListener
(
"
mousedown
"
(
event
)
=
>
{
this
.
_mousedown
=
true
;
this
.
_startX
=
event
.
clientX
;
this
.
_startY
=
event
.
clientY
;
}
false
)
;
node
.
addEventListener
(
"
click
"
(
event
)
=
>
{
let
mousedown
=
this
.
_mousedown
;
this
.
_mousedown
=
false
;
if
(
event
.
detail
!
=
1
|
|
event
.
button
!
=
0
)
{
return
;
}
if
(
mousedown
&
&
(
Math
.
abs
(
event
.
clientX
-
this
.
_startX
)
>
=
2
)
&
&
(
Math
.
abs
(
event
.
clientY
-
this
.
_startY
)
>
=
1
)
)
{
this
.
_startX
=
this
.
_startY
=
undefined
;
return
;
}
this
.
_startX
=
this
.
_startY
=
undefined
;
callback
.
call
(
this
event
)
;
}
false
)
;
}
_onToolboxPrefChanged
:
function
(
event
data
)
{
if
(
data
.
pref
=
=
PREF_MESSAGE_TIMESTAMP
)
{
if
(
data
.
newValue
)
{
this
.
outputNode
.
classList
.
remove
(
"
hideTimestamps
"
)
;
}
else
{
this
.
outputNode
.
classList
.
add
(
"
hideTimestamps
"
)
;
}
}
}
copySelectedItems
:
function
(
options
)
{
options
=
options
|
|
{
linkOnly
:
false
contextmenu
:
false
}
;
let
strings
=
[
]
;
let
children
=
this
.
output
.
getSelectedMessages
(
)
;
if
(
!
children
.
length
&
&
options
.
contextmenu
)
{
children
=
[
this
.
_contextMenuHandler
.
lastClickedMessage
]
;
}
for
(
let
item
of
children
)
{
if
(
!
item
.
classList
.
contains
(
"
filtered
-
by
-
type
"
)
&
&
!
item
.
classList
.
contains
(
"
filtered
-
by
-
string
"
)
)
{
let
timestampString
=
l10n
.
timestampString
(
item
.
timestamp
)
;
if
(
options
.
linkOnly
)
{
strings
.
push
(
item
.
url
)
;
}
else
{
strings
.
push
(
item
.
clipboardText
)
;
}
}
}
clipboardHelper
.
copyString
(
strings
.
join
(
"
\
n
"
)
)
;
}
objectPropertiesProvider
:
function
(
actor
callback
)
{
this
.
webConsoleClient
.
inspectObjectProperties
(
actor
function
(
response
)
{
if
(
response
.
error
)
{
Cu
.
reportError
(
"
Failed
to
retrieve
the
object
properties
from
the
"
+
"
server
.
Error
:
"
+
response
.
error
)
;
return
;
}
callback
(
response
.
properties
)
;
}
)
;
}
_releaseObject
:
function
(
actor
)
{
if
(
this
.
proxy
)
{
this
.
proxy
.
releaseActor
(
actor
)
;
}
}
openSelectedItemInTab
:
function
(
)
{
let
item
=
this
.
output
.
getSelectedMessages
(
1
)
[
0
]
|
|
this
.
_contextMenuHandler
.
lastClickedMessage
;
if
(
!
item
|
|
!
item
.
url
)
{
return
;
}
this
.
owner
.
openLink
(
item
.
url
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
.
promise
;
}
this
.
_destroyer
=
promise
.
defer
(
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
owner
.
target
)
;
if
(
toolbox
)
{
toolbox
.
off
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
}
gDevTools
.
off
(
"
pref
-
changed
"
this
.
_onToolboxPrefChanged
)
;
this
.
window
.
removeEventListener
(
"
resize
"
this
.
resize
true
)
;
this
.
_repeatNodes
=
{
}
;
this
.
_outputQueue
.
forEach
(
this
.
_destroyItem
this
)
;
this
.
_outputQueue
=
[
]
;
this
.
_itemDestroyQueue
.
forEach
(
this
.
_destroyItem
this
)
;
this
.
_itemDestroyQueue
=
[
]
;
this
.
_pruneCategoriesQueue
=
{
}
;
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
if
(
this
.
_outputTimerInitialized
)
{
this
.
_outputTimerInitialized
=
false
;
this
.
_outputTimer
.
cancel
(
)
;
}
this
.
_outputTimer
=
null
;
if
(
this
.
jsterm
)
{
this
.
jsterm
.
off
(
"
sidebar
-
opened
"
this
.
resize
)
;
this
.
jsterm
.
off
(
"
sidebar
-
closed
"
this
.
resize
)
;
this
.
jsterm
.
destroy
(
)
;
this
.
jsterm
=
null
;
}
this
.
output
.
destroy
(
)
;
this
.
output
=
null
;
if
(
this
.
_contextMenuHandler
)
{
this
.
_contextMenuHandler
.
destroy
(
)
;
this
.
_contextMenuHandler
=
null
;
}
this
.
_commandController
=
null
;
let
onDestroy
=
(
)
=
>
{
this
.
_destroyer
.
resolve
(
null
)
;
}
;
if
(
this
.
proxy
)
{
this
.
proxy
.
disconnect
(
)
.
then
(
onDestroy
)
;
this
.
proxy
=
null
;
}
else
{
onDestroy
(
)
;
}
return
this
.
_destroyer
.
promise
;
}
}
;
function
simpleValueEvalMacro
(
item
currentString
)
{
return
VariablesView
.
simpleValueEvalMacro
(
item
currentString
"
_self
"
)
;
}
;
function
overrideValueEvalMacro
(
item
currentString
)
{
return
VariablesView
.
overrideValueEvalMacro
(
item
currentString
"
_self
"
)
;
}
;
function
getterOrSetterEvalMacro
(
item
currentString
)
{
return
VariablesView
.
getterOrSetterEvalMacro
(
item
currentString
"
_self
"
)
;
}
function
JSTerm
(
webConsoleFrame
)
{
this
.
hud
=
webConsoleFrame
;
this
.
hudId
=
this
.
hud
.
hudId
;
this
.
inputHistoryCount
=
Services
.
prefs
.
getIntPref
(
PREF_INPUT_HISTORY_COUNT
)
;
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
_loadHistory
(
)
;
this
.
_objectActorsInVariablesViews
=
new
Map
(
)
;
this
.
_keyPress
=
this
.
_keyPress
.
bind
(
this
)
;
this
.
_inputEventHandler
=
this
.
_inputEventHandler
.
bind
(
this
)
;
this
.
_focusEventHandler
=
this
.
_focusEventHandler
.
bind
(
this
)
;
this
.
_onKeypressInVariablesView
=
this
.
_onKeypressInVariablesView
.
bind
(
this
)
;
this
.
_blurEventHandler
=
this
.
_blurEventHandler
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
JSTerm
.
prototype
=
{
SELECTED_FRAME
:
-
1
_loadHistory
:
function
(
)
{
this
.
history
=
[
]
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
0
;
this
.
historyLoaded
=
asyncStorage
.
getItem
(
"
webConsoleHistory
"
)
.
then
(
value
=
>
{
if
(
Array
.
isArray
(
value
)
)
{
this
.
history
=
value
.
concat
(
this
.
history
)
;
this
.
historyIndex
=
this
.
history
.
length
;
this
.
historyPlaceHolder
=
this
.
history
.
length
;
}
}
console
.
error
)
;
}
clearHistory
:
function
(
)
{
this
.
history
=
[
]
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
0
;
return
this
.
storeHistory
(
)
;
}
storeHistory
:
function
(
)
{
return
asyncStorage
.
setItem
(
"
webConsoleHistory
"
this
.
history
)
;
}
lastCompletion
:
null
_autocompleteCache
:
null
_autocompleteQuery
:
null
_lastFrameActorId
:
null
sidebar
:
null
_variablesView
:
null
_lazyVariablesView
:
true
_objectActorsInVariablesViews
:
null
lastInputValue
:
"
"
_inputChanged
:
false
_autocompletePopupNavigated
:
false
history
:
null
autocompletePopup
:
null
inputNode
:
null
completeNode
:
null
get
outputNode
(
)
{
return
this
.
hud
.
outputNode
;
}
get
webConsoleClient
(
)
{
return
this
.
hud
.
webConsoleClient
;
}
COMPLETE_FORWARD
:
0
COMPLETE_BACKWARD
:
1
COMPLETE_HINT_ONLY
:
2
COMPLETE_PAGEUP
:
3
COMPLETE_PAGEDOWN
:
4
init
:
function
(
)
{
let
autocompleteOptions
=
{
onSelect
:
this
.
onAutocompleteSelect
.
bind
(
this
)
onClick
:
this
.
acceptProposedCompletion
.
bind
(
this
)
panelId
:
"
webConsole_autocompletePopup
"
listBoxId
:
"
webConsole_autocompletePopupListBox
"
position
:
"
before_start
"
theme
:
"
auto
"
direction
:
"
ltr
"
autoSelect
:
true
}
;
this
.
autocompletePopup
=
new
AutocompletePopup
(
this
.
hud
.
document
autocompleteOptions
)
;
let
doc
=
this
.
hud
.
document
;
let
inputContainer
=
doc
.
querySelector
(
"
.
jsterm
-
input
-
container
"
)
;
this
.
completeNode
=
doc
.
querySelector
(
"
.
jsterm
-
complete
-
node
"
)
;
this
.
inputNode
=
doc
.
querySelector
(
"
.
jsterm
-
input
-
node
"
)
;
if
(
this
.
hud
.
owner
.
_browserConsole
&
&
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
{
inputContainer
.
style
.
display
=
"
none
"
;
}
else
{
let
okstring
=
l10n
.
getStr
(
"
selfxss
.
okstring
"
)
;
let
msg
=
l10n
.
getFormatStr
(
"
selfxss
.
msg
"
[
okstring
]
)
;
this
.
_onPaste
=
WebConsoleUtils
.
pasteHandlerGen
(
this
.
inputNode
doc
.
getElementById
(
"
webconsole
-
notificationbox
"
)
msg
okstring
)
;
this
.
inputNode
.
addEventListener
(
"
keypress
"
this
.
_keyPress
false
)
;
this
.
inputNode
.
addEventListener
(
"
paste
"
this
.
_onPaste
)
;
this
.
inputNode
.
addEventListener
(
"
drop
"
this
.
_onPaste
)
;
this
.
inputNode
.
addEventListener
(
"
input
"
this
.
_inputEventHandler
false
)
;
this
.
inputNode
.
addEventListener
(
"
keyup
"
this
.
_inputEventHandler
false
)
;
this
.
inputNode
.
addEventListener
(
"
focus
"
this
.
_focusEventHandler
false
)
;
}
this
.
hud
.
window
.
addEventListener
(
"
blur
"
this
.
_blurEventHandler
false
)
;
this
.
lastInputValue
&
&
this
.
setInputValue
(
this
.
lastInputValue
)
;
}
focus
:
function
(
)
{
let
inputNode
=
this
.
inputNode
;
if
(
!
inputNode
.
getAttribute
(
"
focused
"
)
)
{
inputNode
.
focus
(
)
;
}
}
_executeResultCallback
:
function
(
callback
response
)
{
if
(
!
this
.
hud
)
{
return
;
}
if
(
response
.
error
)
{
Cu
.
reportError
(
"
Evaluation
error
"
+
response
.
error
+
"
:
"
+
response
.
message
)
;
return
;
}
let
errorMessage
=
response
.
exceptionMessage
;
let
result
=
response
.
result
;
let
helperResult
=
response
.
helperResult
;
let
helperHasRawOutput
=
!
!
(
helperResult
|
|
{
}
)
.
rawOutput
;
if
(
helperResult
&
&
helperResult
.
type
)
{
switch
(
helperResult
.
type
)
{
case
"
clearOutput
"
:
this
.
clearOutput
(
)
;
break
;
case
"
clearHistory
"
:
this
.
clearHistory
(
)
;
break
;
case
"
inspectObject
"
:
this
.
openVariablesView
(
{
label
:
VariablesView
.
getString
(
helperResult
.
object
{
concise
:
true
}
)
objectActor
:
helperResult
.
object
}
)
;
break
;
case
"
error
"
:
try
{
errorMessage
=
l10n
.
getStr
(
helperResult
.
message
)
;
}
catch
(
ex
)
{
errorMessage
=
helperResult
.
message
;
}
break
;
case
"
help
"
:
this
.
hud
.
owner
.
openLink
(
HELP_URL
)
;
break
;
case
"
copyValueToClipboard
"
:
clipboardHelper
.
copyString
(
helperResult
.
value
)
;
break
;
}
}
if
(
!
errorMessage
&
&
result
&
&
typeof
result
=
=
"
object
"
&
&
result
.
type
=
=
"
undefined
"
&
&
helperResult
&
&
!
helperHasRawOutput
)
{
callback
&
&
callback
(
)
;
return
;
}
let
msg
=
new
Messages
.
JavaScriptEvalOutput
(
response
errorMessage
)
;
this
.
hud
.
output
.
addMessage
(
msg
)
;
if
(
callback
)
{
let
oldFlushCallback
=
this
.
hud
.
_flushCallback
;
this
.
hud
.
_flushCallback
=
(
)
=
>
{
callback
(
msg
.
element
)
;
if
(
oldFlushCallback
)
{
oldFlushCallback
(
)
;
this
.
hud
.
_flushCallback
=
oldFlushCallback
;
return
true
;
}
return
false
;
}
;
}
msg
.
_objectActors
=
new
Set
(
)
;
if
(
WebConsoleUtils
.
isActorGrip
(
response
.
exception
)
)
{
msg
.
_objectActors
.
add
(
response
.
exception
.
actor
)
;
}
if
(
WebConsoleUtils
.
isActorGrip
(
result
)
)
{
msg
.
_objectActors
.
add
(
result
.
actor
)
;
}
}
execute
:
function
(
executeString
callback
)
{
let
deferred
=
promise
.
defer
(
)
;
let
resultCallback
=
function
(
msg
)
{
deferred
.
resolve
(
msg
)
;
if
(
callback
)
{
callback
(
msg
)
;
}
}
executeString
=
executeString
|
|
this
.
getInputValue
(
)
;
if
(
!
executeString
)
{
return
;
}
let
selectedNodeActor
=
null
;
let
inspectorSelection
=
this
.
hud
.
owner
.
getInspectorSelection
(
)
;
if
(
inspectorSelection
&
&
inspectorSelection
.
nodeFront
)
{
selectedNodeActor
=
inspectorSelection
.
nodeFront
.
actorID
;
}
let
message
=
new
Messages
.
Simple
(
executeString
{
category
:
"
input
"
severity
:
"
log
"
}
)
;
this
.
hud
.
output
.
addMessage
(
message
)
;
let
onResult
=
this
.
_executeResultCallback
.
bind
(
this
resultCallback
)
;
let
options
=
{
frame
:
this
.
SELECTED_FRAME
selectedNodeActor
:
selectedNodeActor
}
;
this
.
requestEvaluation
(
executeString
options
)
.
then
(
onResult
onResult
)
;
this
.
history
[
this
.
historyIndex
+
+
]
=
executeString
;
this
.
historyPlaceHolder
=
this
.
history
.
length
;
if
(
this
.
history
.
length
>
this
.
inputHistoryCount
)
{
this
.
history
.
splice
(
0
this
.
history
.
length
-
this
.
inputHistoryCount
)
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
this
.
history
.
length
;
}
this
.
storeHistory
(
)
;
WebConsoleUtils
.
usageCount
+
+
;
this
.
setInputValue
(
"
"
)
;
this
.
clearCompletion
(
)
;
return
deferred
.
promise
;
}
requestEvaluation
:
function
(
str
options
=
{
}
)
{
let
deferred
=
promise
.
defer
(
)
;
function
onResult
(
response
)
{
if
(
!
response
.
error
)
{
deferred
.
resolve
(
response
)
;
}
else
{
deferred
.
reject
(
response
)
;
}
}
let
frameActor
=
null
;
if
(
"
frame
"
in
options
)
{
frameActor
=
this
.
getFrameActor
(
options
.
frame
)
;
}
let
evalOptions
=
{
bindObjectActor
:
options
.
bindObjectActor
frameActor
:
frameActor
selectedNodeActor
:
options
.
selectedNodeActor
selectedObjectActor
:
options
.
selectedObjectActor
}
;
this
.
webConsoleClient
.
evaluateJSAsync
(
str
onResult
evalOptions
)
;
return
deferred
.
promise
;
}
getFrameActor
:
function
(
frame
)
{
let
state
=
this
.
hud
.
owner
.
getDebuggerFrames
(
)
;
if
(
!
state
)
{
return
null
;
}
let
grip
;
if
(
frame
=
=
this
.
SELECTED_FRAME
)
{
grip
=
state
.
frames
[
state
.
selected
]
;
}
else
{
grip
=
state
.
frames
[
frame
]
;
}
return
grip
?
grip
.
actor
:
null
;
}
openVariablesView
:
function
(
options
)
{
let
onContainerReady
=
(
window
)
=
>
{
let
container
=
window
.
document
.
querySelector
(
"
#
variables
"
)
;
let
view
=
this
.
_variablesView
;
if
(
!
view
|
|
options
.
targetElement
)
{
let
viewOptions
=
{
container
:
container
hideFilterInput
:
options
.
hideFilterInput
}
;
view
=
this
.
_createVariablesView
(
viewOptions
)
;
if
(
!
options
.
targetElement
)
{
this
.
_variablesView
=
view
;
window
.
addEventListener
(
"
keypress
"
this
.
_onKeypressInVariablesView
)
;
}
}
options
.
view
=
view
;
this
.
_updateVariablesView
(
options
)
;
if
(
!
options
.
targetElement
&
&
options
.
autofocus
)
{
window
.
focus
(
)
;
}
this
.
emit
(
"
variablesview
-
open
"
view
options
)
;
return
view
;
}
;
let
openPromise
;
if
(
options
.
targetElement
)
{
let
deferred
=
promise
.
defer
(
)
;
openPromise
=
deferred
.
promise
;
let
document
=
options
.
targetElement
.
ownerDocument
;
let
iframe
=
document
.
createElementNS
(
XHTML_NS
"
iframe
"
)
;
iframe
.
addEventListener
(
"
load
"
function
onIframeLoad
(
event
)
{
iframe
.
removeEventListener
(
"
load
"
onIframeLoad
true
)
;
iframe
.
style
.
visibility
=
"
visible
"
;
deferred
.
resolve
(
iframe
.
contentWindow
)
;
}
true
)
;
iframe
.
flex
=
1
;
iframe
.
style
.
visibility
=
"
hidden
"
;
iframe
.
setAttribute
(
"
src
"
VARIABLES_VIEW_URL
)
;
options
.
targetElement
.
appendChild
(
iframe
)
;
}
else
{
if
(
!
this
.
sidebar
)
{
this
.
_createSidebar
(
)
;
}
openPromise
=
this
.
_addVariablesViewSidebarTab
(
)
;
}
return
openPromise
.
then
(
onContainerReady
)
;
}
_createSidebar
:
function
(
)
{
let
tabbox
=
this
.
hud
.
document
.
querySelector
(
"
#
webconsole
-
sidebar
"
)
;
this
.
sidebar
=
new
ToolSidebar
(
tabbox
this
"
webconsole
"
)
;
this
.
sidebar
.
show
(
)
;
this
.
emit
(
"
sidebar
-
opened
"
)
;
}
_addVariablesViewSidebarTab
:
function
(
)
{
let
deferred
=
promise
.
defer
(
)
;
let
onTabReady
=
(
)
=
>
{
let
window
=
this
.
sidebar
.
getWindowForTab
(
"
variablesview
"
)
;
deferred
.
resolve
(
window
)
;
}
;
let
tabPanel
=
this
.
sidebar
.
getTabPanel
(
"
variablesview
"
)
;
if
(
tabPanel
)
{
if
(
this
.
sidebar
.
getCurrentTabID
(
)
=
=
"
variablesview
"
)
{
onTabReady
(
)
;
}
else
{
this
.
sidebar
.
once
(
"
variablesview
-
selected
"
onTabReady
)
;
this
.
sidebar
.
select
(
"
variablesview
"
)
;
}
}
else
{
this
.
sidebar
.
once
(
"
variablesview
-
ready
"
onTabReady
)
;
this
.
sidebar
.
addTab
(
"
variablesview
"
VARIABLES_VIEW_URL
true
)
;
}
return
deferred
.
promise
;
}
_onKeypressInVariablesView
:
function
(
event
)
{
let
tag
=
event
.
target
.
nodeName
;
if
(
event
.
keyCode
!
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_ESCAPE
|
|
event
.
shiftKey
|
|
event
.
altKey
|
|
event
.
ctrlKey
|
|
event
.
metaKey
|
|
[
"
input
"
"
textarea
"
"
select
"
"
textbox
"
]
.
indexOf
(
tag
)
>
-
1
)
{
return
;
}
this
.
_sidebarDestroy
(
)
;
this
.
inputNode
.
focus
(
)
;
event
.
stopPropagation
(
)
;
}
_createVariablesView
:
function
(
options
)
{
let
view
=
new
VariablesView
(
options
.
container
)
;
view
.
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
view
.
searchPlaceholder
=
l10n
.
getStr
(
"
propertiesFilterPlaceholder
"
)
;
view
.
emptyText
=
l10n
.
getStr
(
"
emptyPropertiesList
"
)
;
view
.
searchEnabled
=
!
options
.
hideFilterInput
;
view
.
lazyEmpty
=
this
.
_lazyVariablesView
;
VariablesViewController
.
attach
(
view
{
getEnvironmentClient
:
grip
=
>
{
return
new
EnvironmentClient
(
this
.
hud
.
proxy
.
client
grip
)
;
}
getObjectClient
:
grip
=
>
{
return
new
ObjectClient
(
this
.
hud
.
proxy
.
client
grip
)
;
}
getLongStringClient
:
grip
=
>
{
return
this
.
webConsoleClient
.
longString
(
grip
)
;
}
releaseActor
:
actor
=
>
{
this
.
hud
.
_releaseObject
(
actor
)
;
}
simpleValueEvalMacro
:
simpleValueEvalMacro
overrideValueEvalMacro
:
overrideValueEvalMacro
getterOrSetterEvalMacro
:
getterOrSetterEvalMacro
}
)
;
view
.
on
(
"
fetched
"
(
event
type
variableObject
)
=
>
{
this
.
emit
(
"
variablesview
-
fetched
"
variableObject
)
;
}
)
;
return
view
;
}
_updateVariablesView
:
function
(
options
)
{
let
view
=
options
.
view
;
view
.
empty
(
)
;
view
.
controller
.
releaseActors
(
actor
=
>
{
return
view
.
_consoleLastObjectActor
!
=
actor
;
}
)
;
if
(
options
.
objectActor
&
&
(
!
this
.
hud
.
owner
.
_browserConsole
|
|
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
)
{
view
.
eval
=
this
.
_variablesViewEvaluate
.
bind
(
this
options
)
;
view
.
switch
=
this
.
_variablesViewSwitch
.
bind
(
this
options
)
;
view
.
delete
=
this
.
_variablesViewDelete
.
bind
(
this
options
)
;
}
else
{
view
.
eval
=
null
;
view
.
switch
=
null
;
view
.
delete
=
null
;
}
let
{
variable
expanded
}
=
view
.
controller
.
setSingleVariable
(
options
)
;
variable
.
evaluationMacro
=
simpleValueEvalMacro
;
if
(
options
.
objectActor
)
{
view
.
_consoleLastObjectActor
=
options
.
objectActor
.
actor
;
}
else
if
(
options
.
rawObject
)
{
view
.
_consoleLastObjectActor
=
null
;
}
else
{
throw
new
Error
(
"
Variables
View
cannot
open
without
giving
it
an
object
"
+
"
display
.
"
)
;
}
expanded
.
then
(
(
)
=
>
{
this
.
emit
(
"
variablesview
-
updated
"
view
options
)
;
}
)
;
}
_variablesViewEvaluate
:
function
(
options
variableObject
value
)
{
let
updater
=
this
.
_updateVariablesView
.
bind
(
this
options
)
;
let
onEval
=
this
.
_silentEvalCallback
.
bind
(
this
updater
)
;
let
string
=
variableObject
.
evaluationMacro
(
variableObject
value
)
;
let
evalOptions
=
{
frame
:
this
.
SELECTED_FRAME
bindObjectActor
:
options
.
objectActor
.
actor
}
;
this
.
requestEvaluation
(
string
evalOptions
)
.
then
(
onEval
onEval
)
;
}
_variablesViewDelete
:
function
(
options
variableObject
)
{
let
onEval
=
this
.
_silentEvalCallback
.
bind
(
this
null
)
;
let
evalOptions
=
{
frame
:
this
.
SELECTED_FRAME
bindObjectActor
:
options
.
objectActor
.
actor
}
;
this
.
requestEvaluation
(
"
delete
_self
"
+
variableObject
.
symbolicName
evalOptions
)
.
then
(
onEval
onEval
)
;
}
_variablesViewSwitch
:
function
(
options
variableObject
newName
)
{
let
updater
=
this
.
_updateVariablesView
.
bind
(
this
options
)
;
let
onEval
=
this
.
_silentEvalCallback
.
bind
(
this
updater
)
;
let
evalOptions
=
{
frame
:
this
.
SELECTED_FRAME
bindObjectActor
:
options
.
objectActor
.
actor
}
;
let
newSymbolicName
=
variableObject
.
ownerView
.
symbolicName
+
'
[
"
'
+
newName
+
'
"
]
'
;
if
(
newSymbolicName
=
=
variableObject
.
symbolicName
)
{
return
;
}
let
code
=
"
_self
"
+
newSymbolicName
+
"
=
_self
"
+
variableObject
.
symbolicName
+
"
;
"
+
"
delete
_self
"
+
variableObject
.
symbolicName
;
this
.
requestEvaluation
(
code
evalOptions
)
.
then
(
onEval
onEval
)
;
}
_silentEvalCallback
:
function
(
callback
response
)
{
if
(
response
.
error
)
{
Cu
.
reportError
(
"
Web
Console
evaluation
failed
.
"
+
response
.
error
+
"
:
"
+
response
.
message
)
;
callback
&
&
callback
(
response
)
;
return
;
}
if
(
response
.
exceptionMessage
)
{
let
message
=
new
Messages
.
Simple
(
response
.
exceptionMessage
{
category
:
"
output
"
severity
:
"
error
"
timestamp
:
response
.
timestamp
}
)
;
this
.
hud
.
output
.
addMessage
(
message
)
;
message
.
_objectActors
=
new
Set
(
)
;
if
(
WebConsoleUtils
.
isActorGrip
(
response
.
exception
)
)
{
message
.
_objectActors
.
add
(
response
.
exception
.
actor
)
;
}
}
let
helper
=
response
.
helperResult
|
|
{
type
:
null
}
;
let
helperGrip
=
null
;
if
(
helper
.
type
=
=
"
inspectObject
"
)
{
helperGrip
=
helper
.
object
;
}
let
grips
=
[
response
.
result
helperGrip
]
;
for
(
let
grip
of
grips
)
{
if
(
WebConsoleUtils
.
isActorGrip
(
grip
)
)
{
this
.
hud
.
_releaseObject
(
grip
.
actor
)
;
}
}
callback
&
&
callback
(
response
)
;
}
clearOutput
:
function
(
clearStorage
)
{
let
hud
=
this
.
hud
;
let
outputNode
=
hud
.
outputNode
;
let
node
;
while
(
(
node
=
outputNode
.
firstChild
)
)
{
hud
.
removeOutputMessage
(
node
)
;
}
hud
.
groupDepth
=
0
;
hud
.
_outputQueue
.
forEach
(
hud
.
_destroyItem
hud
)
;
hud
.
_outputQueue
=
[
]
;
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
hud
.
_repeatNodes
=
{
}
;
if
(
clearStorage
)
{
this
.
webConsoleClient
.
clearMessagesCache
(
)
;
}
this
.
_sidebarDestroy
(
)
;
this
.
emit
(
"
messages
-
cleared
"
)
;
}
clearPrivateMessages
:
function
(
)
{
let
nodes
=
this
.
hud
.
outputNode
.
querySelectorAll
(
"
.
message
[
private
]
"
)
;
for
(
let
node
of
nodes
)
{
this
.
hud
.
removeOutputMessage
(
node
)
;
}
this
.
emit
(
"
private
-
messages
-
cleared
"
)
;
}
resizeInput
:
function
(
)
{
let
inputNode
=
this
.
inputNode
;
inputNode
.
style
.
height
=
"
auto
"
;
let
scrollHeight
=
inputNode
.
inputField
.
scrollHeight
;
if
(
scrollHeight
>
0
)
{
inputNode
.
style
.
height
=
scrollHeight
+
"
px
"
;
}
}
setInputValue
:
function
(
newValue
)
{
this
.
inputNode
.
value
=
newValue
;
this
.
lastInputValue
=
newValue
;
this
.
completeNode
.
value
=
"
"
;
this
.
resizeInput
(
)
;
this
.
_inputChanged
=
true
;
this
.
emit
(
"
set
-
input
-
value
"
)
;
}
getInputValue
:
function
(
)
{
return
this
.
inputNode
.
value
|
|
"
"
;
}
_inputEventHandler
:
function
(
)
{
if
(
this
.
lastInputValue
!
=
this
.
getInputValue
(
)
)
{
this
.
resizeInput
(
)
;
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
;
this
.
lastInputValue
=
this
.
getInputValue
(
)
;
this
.
_inputChanged
=
true
;
}
}
_blurEventHandler
:
function
(
)
{
if
(
this
.
autocompletePopup
)
{
this
.
clearCompletion
(
)
;
}
}
_keyPress
:
function
(
event
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
let
inputUpdated
=
false
;
if
(
event
.
ctrlKey
)
{
switch
(
event
.
charCode
)
{
case
101
:
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
break
;
}
let
lineEndPos
=
inputValue
.
length
;
if
(
this
.
hasMultilineInput
(
)
)
{
for
(
let
i
=
inputNode
.
selectionEnd
;
i
<
lineEndPos
;
i
+
+
)
{
if
(
inputValue
.
charAt
(
i
)
=
=
"
\
r
"
|
|
inputValue
.
charAt
(
i
)
=
=
"
\
n
"
)
{
lineEndPos
=
i
;
break
;
}
}
}
inputNode
.
setSelectionRange
(
lineEndPos
lineEndPos
)
;
event
.
preventDefault
(
)
;
this
.
clearCompletion
(
)
;
break
;
case
110
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
event
.
preventDefault
(
)
;
inputNode
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
case
112
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
event
.
preventDefault
(
)
;
inputNode
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
default
:
break
;
}
return
;
}
else
if
(
event
.
shiftKey
&
&
event
.
keyCode
=
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_RETURN
)
{
return
;
}
switch
(
event
.
keyCode
)
{
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_ESCAPE
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
else
if
(
this
.
sidebar
)
{
this
.
_sidebarDestroy
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_RETURN
:
if
(
this
.
_autocompletePopupNavigated
&
&
this
.
autocompletePopup
.
isOpen
&
&
this
.
autocompletePopup
.
selectedIndex
>
-
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
{
this
.
execute
(
)
;
this
.
_inputChanged
=
false
;
}
event
.
preventDefault
(
)
;
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_BACKWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_FORWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_PAGE_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEUP
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputWrapper
.
scrollTop
=
Math
.
max
(
0
this
.
hud
.
outputWrapper
.
scrollTop
-
this
.
hud
.
outputWrapper
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_PAGE_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEDOWN
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputWrapper
.
scrollTop
=
Math
.
min
(
this
.
hud
.
outputWrapper
.
scrollHeight
this
.
hud
.
outputWrapper
.
scrollTop
+
this
.
hud
.
outputWrapper
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_HOME
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
0
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputWrapper
.
scrollTop
=
0
;
event
.
preventDefault
(
)
;
}
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_END
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
this
.
autocompletePopup
.
itemCount
-
1
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputWrapper
.
scrollTop
=
this
.
hud
.
outputWrapper
.
scrollHeight
;
event
.
preventDefault
(
)
;
}
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_LEFT
:
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_RIGHT
:
{
let
cursorAtTheEnd
=
this
.
inputNode
.
selectionStart
=
=
this
.
inputNode
.
selectionEnd
&
&
this
.
inputNode
.
selectionStart
=
=
inputValue
.
length
;
let
haveSuggestion
=
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
;
let
useCompletion
=
cursorAtTheEnd
|
|
this
.
_autocompletePopupNavigated
;
if
(
haveSuggestion
&
&
useCompletion
&
&
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
.
value
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
}
break
;
}
case
Ci
.
nsIDOMKeyEvent
.
DOM_VK_TAB
:
if
(
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
else
if
(
this
.
_inputChanged
)
{
this
.
updateCompleteNode
(
l10n
.
getStr
(
"
Autocomplete
.
blank
"
)
)
;
event
.
preventDefault
(
)
;
}
break
;
default
:
break
;
}
}
_focusEventHandler
:
function
(
)
{
this
.
_inputChanged
=
false
;
}
historyPeruse
:
function
(
direction
)
{
if
(
!
this
.
history
.
length
)
{
return
false
;
}
if
(
direction
=
=
HISTORY_BACK
)
{
if
(
this
.
historyPlaceHolder
<
=
0
)
{
return
false
;
}
let
inputVal
=
this
.
history
[
-
-
this
.
historyPlaceHolder
]
;
if
(
this
.
historyPlaceHolder
+
1
=
=
this
.
historyIndex
)
{
this
.
history
[
this
.
historyIndex
]
=
this
.
getInputValue
(
)
|
|
"
"
;
}
this
.
setInputValue
(
inputVal
)
;
}
else
if
(
direction
=
=
HISTORY_FORWARD
)
{
if
(
this
.
historyPlaceHolder
>
=
(
this
.
history
.
length
-
1
)
)
{
return
false
;
}
let
inputVal
=
this
.
history
[
+
+
this
.
historyPlaceHolder
]
;
this
.
setInputValue
(
inputVal
)
;
}
else
{
throw
new
Error
(
"
Invalid
argument
0
"
)
;
}
return
true
;
}
hasMultilineInput
:
function
(
)
{
return
/
[
\
r
\
n
]
/
.
test
(
this
.
getInputValue
(
)
)
;
}
canCaretGoPrevious
:
function
(
)
{
let
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
let
multiline
=
/
[
\
r
\
n
]
/
.
test
(
node
.
value
)
;
return
node
.
selectionStart
=
=
0
?
true
:
node
.
selectionStart
=
=
node
.
value
.
length
&
&
!
multiline
;
}
canCaretGoNext
:
function
(
)
{
let
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
let
multiline
=
/
[
\
r
\
n
]
/
.
test
(
node
.
value
)
;
return
node
.
selectionStart
=
=
node
.
value
.
length
?
true
:
node
.
selectionStart
=
=
0
&
&
!
multiline
;
}
complete
:
function
(
type
callback
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
let
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
!
inputValue
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
inputNode
.
selectionStart
!
=
inputNode
.
selectionEnd
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
this
.
lastCompletion
.
value
!
=
inputValue
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_updateCompletionResult
(
type
callback
)
;
return
false
;
}
let
popup
=
this
.
autocompletePopup
;
let
accepted
=
false
;
if
(
type
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
accepted
=
true
;
}
else
if
(
type
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEUP
)
{
popup
.
selectPreviousPageItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEDOWN
)
{
popup
.
selectNextPageItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
accepted
|
|
popup
.
itemCount
>
0
;
}
_updateCompletionResult
:
function
(
type
callback
)
{
let
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
this
.
lastCompletion
.
value
=
=
this
.
getInputValue
(
)
&
&
frameActor
=
=
this
.
_lastFrameActorId
)
{
return
;
}
let
requestId
=
gSequenceId
(
)
;
let
cursor
=
this
.
inputNode
.
selectionStart
;
let
input
=
this
.
getInputValue
(
)
.
substring
(
0
cursor
)
;
let
cache
=
this
.
_autocompleteCache
;
if
(
!
/
[
a
-
zA
-
Z0
-
9
]
/
.
test
(
input
)
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_autocompleteQuery
=
null
;
this
.
_autocompleteCache
=
null
;
}
if
(
this
.
_autocompleteQuery
&
&
input
.
startsWith
(
this
.
_autocompleteQuery
)
)
{
let
filterBy
=
input
;
let
lastNonAlpha
=
input
.
match
(
/
[
^
a
-
zA
-
Z0
-
9_
]
[
a
-
zA
-
Z0
-
9_
]
*
/
)
;
if
(
lastNonAlpha
)
{
filterBy
=
input
.
substring
(
input
.
lastIndexOf
(
lastNonAlpha
)
+
1
)
;
}
let
newList
=
cache
.
sort
(
)
.
filter
(
function
(
l
)
{
return
l
.
startsWith
(
filterBy
)
;
}
)
;
this
.
lastCompletion
=
{
requestId
:
null
completionType
:
type
value
:
null
}
;
let
response
=
{
matches
:
newList
matchProp
:
filterBy
}
;
this
.
_receiveAutocompleteProperties
(
null
callback
response
)
;
return
;
}
this
.
_lastFrameActorId
=
frameActor
;
this
.
lastCompletion
=
{
requestId
:
requestId
completionType
:
type
value
:
null
}
;
let
autocompleteCallback
=
this
.
_receiveAutocompleteProperties
.
bind
(
this
requestId
callback
)
;
this
.
webConsoleClient
.
autocomplete
(
input
cursor
autocompleteCallback
frameActor
)
;
}
_receiveAutocompleteProperties
:
function
(
requestId
callback
message
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
if
(
this
.
lastCompletion
.
value
=
=
inputValue
|
|
requestId
!
=
this
.
lastCompletion
.
requestId
)
{
return
;
}
let
cursor
=
inputNode
.
selectionStart
;
let
inputUntilCursor
=
inputValue
.
substring
(
0
cursor
)
;
if
(
requestId
!
=
null
&
&
/
[
a
-
zA
-
Z0
-
9
.
]
/
.
test
(
inputUntilCursor
)
)
{
this
.
_autocompleteCache
=
message
.
matches
;
this
.
_autocompleteQuery
=
inputUntilCursor
;
}
let
matches
=
message
.
matches
;
let
lastPart
=
message
.
matchProp
;
if
(
!
matches
.
length
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
;
}
let
items
=
matches
.
reverse
(
)
.
map
(
function
(
match
)
{
return
{
preLabel
:
lastPart
label
:
match
}
;
}
)
;
let
popup
=
this
.
autocompletePopup
;
popup
.
setItems
(
items
)
;
let
completionType
=
this
.
lastCompletion
.
completionType
;
this
.
lastCompletion
=
{
value
:
inputValue
matchProp
:
lastPart
}
;
if
(
items
.
length
>
1
&
&
!
popup
.
isOpen
)
{
let
str
=
this
.
getInputValue
(
)
.
substr
(
0
this
.
inputNode
.
selectionStart
)
;
let
offset
=
str
.
length
-
(
str
.
lastIndexOf
(
"
\
n
"
)
+
1
)
-
lastPart
.
length
;
let
x
=
offset
*
this
.
hud
.
_inputCharWidth
;
popup
.
openPopup
(
inputNode
x
+
this
.
hud
.
_chevronWidth
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
else
if
(
items
.
length
<
2
&
&
popup
.
isOpen
)
{
popup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
if
(
items
.
length
=
=
1
)
{
popup
.
selectedIndex
=
0
;
}
this
.
onAutocompleteSelect
(
)
;
if
(
completionType
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
}
onAutocompleteSelect
:
function
(
)
{
if
(
this
.
inputNode
.
selectionStart
!
=
this
.
getInputValue
(
)
.
length
)
{
return
;
}
let
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
let
suffix
=
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
;
this
.
updateCompleteNode
(
suffix
)
;
}
else
{
this
.
updateCompleteNode
(
"
"
)
;
}
}
clearCompletion
:
function
(
)
{
this
.
autocompletePopup
.
clearItems
(
)
;
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
updateCompleteNode
(
"
"
)
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
}
acceptProposedCompletion
:
function
(
)
{
let
updated
=
false
;
let
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
let
suffix
=
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
;
let
cursor
=
this
.
inputNode
.
selectionStart
;
let
value
=
this
.
getInputValue
(
)
;
this
.
setInputValue
(
value
.
substr
(
0
cursor
)
+
suffix
+
value
.
substr
(
cursor
)
)
;
let
newCursor
=
cursor
+
suffix
.
length
;
this
.
inputNode
.
selectionStart
=
this
.
inputNode
.
selectionEnd
=
newCursor
;
updated
=
true
;
}
this
.
clearCompletion
(
)
;
return
updated
;
}
updateCompleteNode
:
function
(
suffix
)
{
let
prefix
=
suffix
?
this
.
getInputValue
(
)
.
replace
(
/
[
\
S
]
/
g
"
"
)
:
"
"
;
this
.
completeNode
.
value
=
prefix
+
suffix
;
}
_sidebarDestroy
:
function
(
)
{
if
(
this
.
_variablesView
)
{
this
.
_variablesView
.
controller
.
releaseActors
(
)
;
this
.
_variablesView
=
null
;
}
if
(
this
.
sidebar
)
{
this
.
sidebar
.
hide
(
)
;
this
.
sidebar
.
destroy
(
)
;
this
.
sidebar
=
null
;
}
this
.
emit
(
"
sidebar
-
closed
"
)
;
}
destroy
:
function
(
)
{
this
.
_sidebarDestroy
(
)
;
this
.
clearCompletion
(
)
;
this
.
clearOutput
(
)
;
this
.
autocompletePopup
.
destroy
(
)
;
this
.
autocompletePopup
=
null
;
let
popup
=
this
.
hud
.
owner
.
chromeWindow
.
document
.
getElementById
(
"
webConsole_autocompletePopup
"
)
;
if
(
popup
)
{
popup
.
parentNode
.
removeChild
(
popup
)
;
}
if
(
this
.
_onPaste
)
{
this
.
inputNode
.
removeEventListener
(
"
paste
"
this
.
_onPaste
false
)
;
this
.
inputNode
.
removeEventListener
(
"
drop
"
this
.
_onPaste
false
)
;
this
.
_onPaste
=
null
;
}
this
.
inputNode
.
removeEventListener
(
"
keypress
"
this
.
_keyPress
false
)
;
this
.
inputNode
.
removeEventListener
(
"
input
"
this
.
_inputEventHandler
false
)
;
this
.
inputNode
.
removeEventListener
(
"
keyup
"
this
.
_inputEventHandler
false
)
;
this
.
inputNode
.
removeEventListener
(
"
focus
"
this
.
_focusEventHandler
false
)
;
this
.
hud
.
window
.
removeEventListener
(
"
blur
"
this
.
_blurEventHandler
false
)
;
this
.
hud
=
null
;
}
}
;
var
Utils
=
{
scrollToVisible
:
function
(
node
)
{
node
.
scrollIntoView
(
false
)
;
}
isOutputScrolledToBottom
:
function
(
outputNode
scrollNode
)
{
let
lastNodeHeight
=
outputNode
.
lastChild
?
outputNode
.
lastChild
.
clientHeight
:
0
;
return
scrollNode
.
scrollTop
+
scrollNode
.
clientHeight
>
=
scrollNode
.
scrollHeight
-
lastNodeHeight
/
2
;
}
categoryForScriptError
:
function
(
scriptError
)
{
let
category
=
scriptError
.
category
;
if
(
/
^
(
?
:
CSS
|
Layout
)
\
b
/
.
test
(
category
)
)
{
return
CATEGORY_CSS
;
}
switch
(
category
)
{
case
"
Mixed
Content
Blocker
"
:
case
"
Mixed
Content
Message
"
:
case
"
CSP
"
:
case
"
Invalid
HSTS
Headers
"
:
case
"
Invalid
HPKP
Headers
"
:
case
"
SHA
-
1
Signature
"
:
case
"
Insecure
Password
Field
"
:
case
"
SSL
"
:
case
"
CORS
"
:
case
"
Iframe
Sandbox
"
:
case
"
Tracking
Protection
"
:
case
"
Sub
-
resource
Integrity
"
:
return
CATEGORY_SECURITY
;
default
:
return
CATEGORY_JS
;
}
}
logLimitForCategory
:
function
(
category
)
{
let
logLimit
=
DEFAULT_LOG_LIMIT
;
try
{
let
prefName
=
CATEGORY_CLASS_FRAGMENTS
[
category
]
;
logLimit
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
hud
.
loglimit
.
"
+
prefName
)
;
logLimit
=
Math
.
max
(
logLimit
1
)
;
}
catch
(
e
)
{
}
return
logLimit
;
}
}
;
function
CommandController
(
webConsole
)
{
this
.
owner
=
webConsole
;
}
CommandController
.
prototype
=
{
selectAll
:
function
(
)
{
this
.
owner
.
output
.
selectAllMessages
(
)
;
}
openURL
:
function
(
)
{
this
.
owner
.
openSelectedItemInTab
(
)
;
}
copyURL
:
function
(
)
{
this
.
owner
.
copySelectedItems
(
{
linkOnly
:
true
contextmenu
:
true
}
)
;
}
copyLastClicked
:
function
(
)
{
this
.
owner
.
copySelectedItems
(
{
linkOnly
:
false
contextmenu
:
true
}
)
;
}
supportsCommand
:
function
(
command
)
{
if
(
!
this
.
owner
|
|
!
this
.
owner
.
output
)
{
return
false
;
}
return
this
.
isCommandEnabled
(
command
)
;
}
isCommandEnabled
:
function
(
command
)
{
switch
(
command
)
{
case
"
consoleCmd_openURL
"
:
case
"
consoleCmd_copyURL
"
:
{
let
selectedItem
=
this
.
owner
.
output
.
getSelectedMessages
(
1
)
[
0
]
|
|
this
.
owner
.
_contextMenuHandler
.
lastClickedMessage
;
return
selectedItem
&
&
"
url
"
in
selectedItem
;
}
case
"
cmd_copy
"
:
{
return
this
.
owner
.
_contextMenuHandler
.
lastClickedMessage
&
&
!
this
.
owner
.
output
.
getSelectedMessages
(
1
)
[
0
]
;
}
case
"
consoleCmd_clearOutput
"
:
case
"
cmd_selectAll
"
:
case
"
cmd_find
"
:
return
true
;
case
"
cmd_fontSizeEnlarge
"
:
case
"
cmd_fontSizeReduce
"
:
case
"
cmd_fontSizeReset
"
:
case
"
cmd_close
"
:
return
this
.
owner
.
owner
.
_browserConsole
;
}
return
false
;
}
doCommand
:
function
(
command
)
{
switch
(
command
)
{
case
"
consoleCmd_openURL
"
:
this
.
openURL
(
)
;
break
;
case
"
consoleCmd_copyURL
"
:
this
.
copyURL
(
)
;
break
;
case
"
consoleCmd_clearOutput
"
:
this
.
owner
.
jsterm
.
clearOutput
(
true
)
;
break
;
case
"
cmd_copy
"
:
this
.
copyLastClicked
(
)
;
break
;
case
"
cmd_find
"
:
this
.
owner
.
filterBox
.
focus
(
)
;
break
;
case
"
cmd_selectAll
"
:
this
.
selectAll
(
)
;
break
;
case
"
cmd_fontSizeEnlarge
"
:
this
.
owner
.
changeFontSize
(
"
+
"
)
;
break
;
case
"
cmd_fontSizeReduce
"
:
this
.
owner
.
changeFontSize
(
"
-
"
)
;
break
;
case
"
cmd_fontSizeReset
"
:
this
.
owner
.
changeFontSize
(
"
"
)
;
break
;
case
"
cmd_close
"
:
this
.
owner
.
window
.
close
(
)
;
break
;
}
}
}
;
function
WebConsoleConnectionProxy
(
webConsoleFrame
target
)
{
this
.
webConsoleFrame
=
webConsoleFrame
;
this
.
target
=
target
;
this
.
_onPageError
=
this
.
_onPageError
.
bind
(
this
)
;
this
.
_onLogMessage
=
this
.
_onLogMessage
.
bind
(
this
)
;
this
.
_onConsoleAPICall
=
this
.
_onConsoleAPICall
.
bind
(
this
)
;
this
.
_onNetworkEvent
=
this
.
_onNetworkEvent
.
bind
(
this
)
;
this
.
_onNetworkEventUpdate
=
this
.
_onNetworkEventUpdate
.
bind
(
this
)
;
this
.
_onFileActivity
=
this
.
_onFileActivity
.
bind
(
this
)
;
this
.
_onReflowActivity
=
this
.
_onReflowActivity
.
bind
(
this
)
;
this
.
_onServerLogCall
=
this
.
_onServerLogCall
.
bind
(
this
)
;
this
.
_onTabNavigated
=
this
.
_onTabNavigated
.
bind
(
this
)
;
this
.
_onAttachConsole
=
this
.
_onAttachConsole
.
bind
(
this
)
;
this
.
_onCachedMessages
=
this
.
_onCachedMessages
.
bind
(
this
)
;
this
.
_connectionTimeout
=
this
.
_connectionTimeout
.
bind
(
this
)
;
this
.
_onLastPrivateContextExited
=
this
.
_onLastPrivateContextExited
.
bind
(
this
)
;
}
WebConsoleConnectionProxy
.
prototype
=
{
webConsoleFrame
:
null
target
:
null
client
:
null
webConsoleClient
:
null
connected
:
false
_connectTimer
:
null
_connectDefer
:
null
_disconnecter
:
null
_consoleActor
:
null
_hasNativeConsoleAPI
:
false
connect
:
function
(
)
{
if
(
this
.
_connectDefer
)
{
return
this
.
_connectDefer
.
promise
;
}
this
.
_connectDefer
=
promise
.
defer
(
)
;
let
timeout
=
Services
.
prefs
.
getIntPref
(
PREF_CONNECTION_TIMEOUT
)
;
this
.
_connectTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
this
.
_connectTimer
.
initWithCallback
(
this
.
_connectionTimeout
timeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
let
connPromise
=
this
.
_connectDefer
.
promise
;
connPromise
.
then
(
(
)
=
>
{
this
.
_connectTimer
.
cancel
(
)
;
this
.
_connectTimer
=
null
;
}
(
)
=
>
{
this
.
_connectTimer
=
null
;
}
)
;
let
client
=
this
.
client
=
this
.
target
.
client
;
if
(
this
.
target
.
isWorkerTarget
)
{
}
else
{
client
.
addListener
(
"
logMessage
"
this
.
_onLogMessage
)
;
client
.
addListener
(
"
pageError
"
this
.
_onPageError
)
;
client
.
addListener
(
"
consoleAPICall
"
this
.
_onConsoleAPICall
)
;
client
.
addListener
(
"
fileActivity
"
this
.
_onFileActivity
)
;
client
.
addListener
(
"
reflowActivity
"
this
.
_onReflowActivity
)
;
client
.
addListener
(
"
serverLogCall
"
this
.
_onServerLogCall
)
;
client
.
addListener
(
"
lastPrivateContextExited
"
this
.
_onLastPrivateContextExited
)
;
}
this
.
target
.
on
(
"
will
-
navigate
"
this
.
_onTabNavigated
)
;
this
.
target
.
on
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
_consoleActor
=
this
.
target
.
form
.
consoleActor
;
if
(
this
.
target
.
isTabActor
)
{
let
tab
=
this
.
target
.
form
;
this
.
webConsoleFrame
.
onLocationChange
(
tab
.
url
tab
.
title
)
;
}
this
.
_attachConsole
(
)
;
return
connPromise
;
}
_connectionTimeout
:
function
(
)
{
let
error
=
{
error
:
"
timeout
"
message
:
l10n
.
getStr
(
"
connectionTimeout
"
)
}
;
this
.
_connectDefer
.
reject
(
error
)
;
}
_attachConsole
:
function
(
)
{
let
listeners
=
[
"
PageError
"
"
ConsoleAPI
"
"
NetworkActivity
"
"
FileActivity
"
]
;
this
.
client
.
attachConsole
(
this
.
_consoleActor
listeners
this
.
_onAttachConsole
)
;
}
_onAttachConsole
:
function
(
response
webConsoleClient
)
{
if
(
response
.
error
)
{
Cu
.
reportError
(
"
attachConsole
failed
:
"
+
response
.
error
+
"
"
+
response
.
message
)
;
this
.
_connectDefer
.
reject
(
response
)
;
return
;
}
this
.
webConsoleClient
=
webConsoleClient
;
this
.
_hasNativeConsoleAPI
=
response
.
nativeConsoleAPI
;
let
saveBodies
=
!
this
.
webConsoleFrame
.
owner
.
_browserConsole
;
this
.
webConsoleFrame
.
setSaveRequestAndResponseBodies
(
saveBodies
)
;
this
.
webConsoleClient
.
on
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
on
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
let
msgs
=
[
"
PageError
"
"
ConsoleAPI
"
]
;
this
.
webConsoleClient
.
getCachedMessages
(
msgs
this
.
_onCachedMessages
)
;
this
.
webConsoleFrame
.
_onUpdateListeners
(
)
;
}
_onCachedMessages
:
function
(
response
)
{
if
(
response
.
error
)
{
Cu
.
reportError
(
"
Web
Console
getCachedMessages
error
:
"
+
response
.
error
+
"
"
+
response
.
message
)
;
this
.
_connectDefer
.
reject
(
response
)
;
return
;
}
if
(
!
this
.
_connectTimer
)
{
Cu
.
reportError
(
"
Web
Console
getCachedMessages
error
:
invalid
state
.
"
)
;
}
let
messages
=
response
.
messages
.
concat
(
.
.
.
this
.
webConsoleClient
.
getNetworkEvents
(
)
)
;
messages
.
sort
(
(
a
b
)
=
>
a
.
timeStamp
-
b
.
timeStamp
)
;
this
.
webConsoleFrame
.
displayCachedMessages
(
messages
)
;
if
(
!
this
.
_hasNativeConsoleAPI
)
{
this
.
webConsoleFrame
.
logWarningAboutReplacedAPI
(
)
;
}
this
.
connected
=
true
;
this
.
_connectDefer
.
resolve
(
this
)
;
}
_onPageError
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handlePageError
(
packet
.
pageError
)
;
}
}
_onLogMessage
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleLogMessage
(
packet
)
;
}
}
_onConsoleAPICall
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleConsoleAPICall
(
packet
.
message
)
;
}
}
_onNetworkEvent
:
function
(
type
networkInfo
)
{
if
(
this
.
webConsoleFrame
)
{
this
.
webConsoleFrame
.
handleNetworkEvent
(
networkInfo
)
;
}
}
_onNetworkEventUpdate
:
function
(
type
{
packet
networkInfo
}
)
{
if
(
this
.
webConsoleFrame
)
{
this
.
webConsoleFrame
.
handleNetworkEventUpdate
(
networkInfo
packet
)
;
}
}
_onFileActivity
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleFileActivity
(
packet
.
uri
)
;
}
}
_onReflowActivity
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleReflowActivity
(
packet
)
;
}
}
_onServerLogCall
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
handleConsoleAPICall
(
packet
.
message
)
;
}
}
_onLastPrivateContextExited
:
function
(
type
packet
)
{
if
(
this
.
webConsoleFrame
&
&
packet
.
from
=
=
this
.
_consoleActor
)
{
this
.
webConsoleFrame
.
jsterm
.
clearPrivateMessages
(
)
;
}
}
_onTabNavigated
:
function
(
event
packet
)
{
if
(
!
this
.
webConsoleFrame
)
{
return
;
}
this
.
webConsoleFrame
.
handleTabNavigated
(
event
packet
)
;
}
releaseActor
:
function
(
actor
)
{
if
(
this
.
client
)
{
this
.
client
.
release
(
actor
)
;
}
}
disconnect
:
function
(
)
{
if
(
this
.
_disconnecter
)
{
return
this
.
_disconnecter
.
promise
;
}
this
.
_disconnecter
=
promise
.
defer
(
)
;
if
(
!
this
.
client
)
{
this
.
_disconnecter
.
resolve
(
null
)
;
return
this
.
_disconnecter
.
promise
;
}
this
.
client
.
removeListener
(
"
logMessage
"
this
.
_onLogMessage
)
;
this
.
client
.
removeListener
(
"
pageError
"
this
.
_onPageError
)
;
this
.
client
.
removeListener
(
"
consoleAPICall
"
this
.
_onConsoleAPICall
)
;
this
.
client
.
removeListener
(
"
fileActivity
"
this
.
_onFileActivity
)
;
this
.
client
.
removeListener
(
"
reflowActivity
"
this
.
_onReflowActivity
)
;
this
.
client
.
removeListener
(
"
serverLogCall
"
this
.
_onServerLogCall
)
;
this
.
client
.
removeListener
(
"
lastPrivateContextExited
"
this
.
_onLastPrivateContextExited
)
;
this
.
webConsoleClient
.
off
(
"
networkEvent
"
this
.
_onNetworkEvent
)
;
this
.
webConsoleClient
.
off
(
"
networkEventUpdate
"
this
.
_onNetworkEventUpdate
)
;
this
.
target
.
off
(
"
will
-
navigate
"
this
.
_onTabNavigated
)
;
this
.
target
.
off
(
"
navigate
"
this
.
_onTabNavigated
)
;
this
.
client
=
null
;
this
.
webConsoleClient
=
null
;
this
.
target
=
null
;
this
.
connected
=
false
;
this
.
webConsoleFrame
=
null
;
this
.
_disconnecter
.
resolve
(
null
)
;
return
this
.
_disconnecter
.
promise
;
}
}
;
function
gSequenceId
(
)
{
return
gSequenceId
.
n
+
+
;
}
gSequenceId
.
n
=
0
;
function
ConsoleContextMenu
(
owner
)
{
this
.
owner
=
owner
;
this
.
popup
=
this
.
owner
.
document
.
getElementById
(
"
output
-
contextmenu
"
)
;
this
.
build
=
this
.
build
.
bind
(
this
)
;
this
.
popup
.
addEventListener
(
"
popupshowing
"
this
.
build
)
;
}
ConsoleContextMenu
.
prototype
=
{
lastClickedMessage
:
null
build
:
function
(
event
)
{
let
metadata
=
this
.
getSelectionMetadata
(
event
.
rangeParent
)
;
for
(
let
element
of
this
.
popup
.
children
)
{
element
.
hidden
=
this
.
shouldHideMenuItem
(
element
metadata
)
;
}
}
getSelectionMetadata
:
function
(
clickElement
)
{
let
metadata
=
{
selectionType
:
"
"
selection
:
new
Set
(
)
}
;
let
selectedItems
=
this
.
owner
.
output
.
getSelectedMessages
(
)
;
if
(
!
selectedItems
.
length
)
{
let
clickedItem
=
this
.
owner
.
output
.
getMessageForElement
(
clickElement
)
;
if
(
clickedItem
)
{
this
.
lastClickedMessage
=
clickedItem
;
selectedItems
=
[
clickedItem
]
;
}
}
metadata
.
selectionType
=
selectedItems
.
length
>
1
?
"
multiple
"
:
"
single
"
;
let
selection
=
metadata
.
selection
;
for
(
let
item
of
selectedItems
)
{
switch
(
item
.
category
)
{
case
CATEGORY_NETWORK
:
selection
.
add
(
"
network
"
)
;
break
;
case
CATEGORY_CSS
:
selection
.
add
(
"
css
"
)
;
break
;
case
CATEGORY_JS
:
selection
.
add
(
"
js
"
)
;
break
;
case
CATEGORY_WEBDEV
:
selection
.
add
(
"
webdev
"
)
;
break
;
case
CATEGORY_SERVER
:
selection
.
add
(
"
server
"
)
;
break
;
}
}
return
metadata
;
}
shouldHideMenuItem
:
function
(
menuItem
metadata
)
{
let
selectionType
=
menuItem
.
getAttribute
(
"
selectiontype
"
)
;
if
(
selectionType
&
&
!
metadata
.
selectionType
=
=
selectionType
)
{
return
true
;
}
let
selection
=
menuItem
.
getAttribute
(
"
selection
"
)
;
if
(
!
selection
)
{
return
false
;
}
let
shouldHide
=
true
;
let
itemData
=
selection
.
split
(
"
|
"
)
;
for
(
let
type
of
metadata
.
selection
)
{
if
(
itemData
.
indexOf
(
type
)
!
=
=
-
1
)
{
shouldHide
=
false
;
break
;
}
}
return
shouldHide
;
}
destroy
:
function
(
)
{
this
.
popup
.
removeEventListener
(
"
popupshowing
"
this
.
build
)
;
this
.
popup
=
null
;
this
.
owner
=
null
;
this
.
lastClickedMessage
=
null
;
}
}
;
