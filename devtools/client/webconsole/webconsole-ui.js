"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
l10n
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
)
;
var
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
const
{
BrowserLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
browser
-
loader
.
js
"
)
;
const
{
getAdHocFrontOrPrimitiveGrip
}
=
require
(
"
devtools
/
client
/
fronts
/
object
"
)
;
const
{
PREFS
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
FirefoxDataProvider
=
require
(
"
devtools
/
client
/
netmonitor
/
src
/
connector
/
firefox
-
data
-
provider
"
)
;
loader
.
lazyRequireGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
constants
"
"
devtools
/
client
/
webconsole
/
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
START_IGNORE_ACTION
"
"
devtools
/
client
/
shared
/
redux
/
middleware
/
ignore
"
true
)
;
const
ZoomKeys
=
require
(
"
devtools
/
client
/
shared
/
zoom
-
keys
"
)
;
const
PREF_SIDEBAR_ENABLED
=
"
devtools
.
webconsole
.
sidebarToggle
"
;
const
PREF_BROWSERTOOLBOX_SCOPE
=
"
devtools
.
browsertoolbox
.
scope
"
;
class
WebConsoleUI
{
constructor
(
hud
)
{
this
.
hud
=
hud
;
this
.
hudId
=
this
.
hud
.
hudId
;
this
.
isBrowserConsole
=
this
.
hud
.
isBrowserConsole
;
this
.
isBrowserToolboxConsole
=
this
.
hud
.
commands
.
descriptorFront
.
isBrowserProcessDescriptor
&
&
!
this
.
isBrowserConsole
;
this
.
fissionSupport
=
Services
.
prefs
.
getBoolPref
(
constants
.
PREFS
.
FEATURES
.
BROWSER_TOOLBOX_FISSION
)
;
this
.
window
=
this
.
hud
.
iframeWindow
;
this
.
_onPanelSelected
=
this
.
_onPanelSelected
.
bind
(
this
)
;
this
.
_onChangeSplitConsoleState
=
this
.
_onChangeSplitConsoleState
.
bind
(
this
)
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_onNetworkResourceUpdated
=
this
.
_onNetworkResourceUpdated
.
bind
(
this
)
;
this
.
clearPrivateMessages
=
this
.
clearPrivateMessages
.
bind
(
this
)
;
this
.
_onScopePrefChanged
=
this
.
_onScopePrefChanged
.
bind
(
this
)
;
if
(
this
.
isBrowserConsole
)
{
Services
.
prefs
.
addObserver
(
PREF_BROWSERTOOLBOX_SCOPE
this
.
_onScopePrefChanged
)
;
}
EventEmitter
.
decorate
(
this
)
;
}
get
webConsoleFront
(
)
{
return
this
.
_webConsoleFront
;
}
init
(
)
{
if
(
this
.
_initializer
)
{
return
this
.
_initializer
;
}
this
.
_initializer
=
(
async
(
)
=
>
{
this
.
_initUI
(
)
;
if
(
this
.
isBrowserConsole
)
{
await
this
.
hud
.
commands
.
targetCommand
.
startListening
(
)
;
}
await
this
.
wrapper
.
init
(
)
;
await
this
.
_attachTargets
(
)
;
await
this
.
wrapper
.
waitAsyncDispatches
(
)
;
}
)
(
)
;
return
this
.
_initializer
;
}
destroy
(
)
{
if
(
!
this
.
hud
)
{
return
;
}
this
.
React
=
this
.
ReactDOM
=
this
.
FrameView
=
null
;
if
(
this
.
wrapper
)
{
this
.
wrapper
.
getStore
(
)
.
dispatch
(
START_IGNORE_ACTION
)
;
this
.
wrapper
.
destroy
(
)
;
}
if
(
this
.
jsterm
)
{
this
.
jsterm
.
destroy
(
)
;
this
.
jsterm
=
null
;
}
const
{
toolbox
}
=
this
.
hud
;
if
(
toolbox
)
{
toolbox
.
off
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
toolbox
.
off
(
"
split
-
console
"
this
.
_onChangeSplitConsoleState
)
;
toolbox
.
off
(
"
select
"
this
.
_onChangeSplitConsoleState
)
;
}
if
(
this
.
isBrowserConsole
)
{
Services
.
prefs
.
removeObserver
(
PREF_BROWSERTOOLBOX_SCOPE
this
.
_onScopePrefChanged
)
;
}
this
.
hud
.
commands
.
targetCommand
.
unwatchTargets
(
{
types
:
this
.
hud
.
commands
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
_onTargetAvailable
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
const
resourceCommand
=
this
.
hud
.
resourceCommand
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
CONSOLE_MESSAGE
resourceCommand
.
TYPES
.
ERROR_MESSAGE
resourceCommand
.
TYPES
.
PLATFORM_MESSAGE
resourceCommand
.
TYPES
.
CLONED_CONTENT_PROCESS_MESSAGE
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
CSS_MESSAGE
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
this
.
stopWatchingNetworkResources
(
)
;
this
.
_webConsoleFront
=
null
;
this
.
networkDataProvider
.
destroy
(
)
;
this
.
networkDataProvider
=
null
;
this
.
window
=
this
.
hud
=
this
.
wrapper
=
null
;
}
async
clearOutput
(
clearStorage
event
)
{
if
(
event
)
{
event
.
preventDefault
(
)
;
}
if
(
this
.
wrapper
)
{
this
.
wrapper
.
dispatchMessagesClear
(
)
;
}
if
(
clearStorage
)
{
await
this
.
clearMessagesCache
(
)
;
}
this
.
emitForTests
(
"
messages
-
cleared
"
)
;
}
async
clearMessagesCache
(
)
{
if
(
!
this
.
hud
)
{
return
;
}
const
{
hasWebConsoleClearMessagesCacheAsync
}
=
this
.
hud
.
commands
.
client
.
mainRoot
.
traits
;
try
{
const
consoleFronts
=
await
this
.
hud
.
commands
.
targetCommand
.
getAllFronts
(
this
.
hud
.
commands
.
targetCommand
.
ALL_TYPES
"
console
"
)
;
const
promises
=
[
]
;
for
(
const
consoleFront
of
consoleFronts
)
{
promises
.
push
(
hasWebConsoleClearMessagesCacheAsync
?
consoleFront
.
clearMessagesCacheAsync
(
)
:
consoleFront
.
clearMessagesCache
(
)
)
;
}
await
Promise
.
all
(
promises
)
;
this
.
emitForTests
(
"
messages
-
cache
-
cleared
"
)
;
}
catch
(
e
)
{
console
.
warn
(
"
Exception
in
clearMessagesCache
"
e
)
;
}
}
clearPrivateMessages
(
)
{
if
(
this
.
wrapper
)
{
this
.
wrapper
.
dispatchPrivateMessagesClear
(
)
;
this
.
emitForTests
(
"
private
-
messages
-
cleared
"
)
;
}
}
inspectObjectActor
(
objectActor
)
{
const
{
webConsoleFront
}
=
this
;
this
.
wrapper
.
dispatchMessageAdd
(
{
helperResult
:
{
type
:
"
inspectObject
"
object
:
objectActor
&
&
objectActor
.
getGrip
?
objectActor
:
getAdHocFrontOrPrimitiveGrip
(
objectActor
webConsoleFront
)
}
}
true
)
;
return
this
.
wrapper
;
}
disableAllNetworkMessages
(
)
{
if
(
this
.
wrapper
)
{
this
.
wrapper
.
dispatchNetworkMessagesDisable
(
)
;
}
}
getPanelWindow
(
)
{
return
this
.
window
;
}
logWarningAboutReplacedAPI
(
)
{
return
this
.
hud
.
currentTarget
.
logWarningInPage
(
l10n
.
getStr
(
"
ConsoleAPIDisabled
"
)
"
ConsoleAPIDisabled
"
)
;
}
async
_attachTargets
(
)
{
const
{
commands
resourceCommand
}
=
this
.
hud
;
this
.
networkDataProvider
=
new
FirefoxDataProvider
(
{
commands
actions
:
{
updateRequest
:
(
id
data
)
=
>
this
.
wrapper
.
batchedRequestUpdates
(
{
id
data
}
)
}
owner
:
this
}
)
;
await
commands
.
targetCommand
.
watchTargets
(
{
types
:
this
.
hud
.
commands
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
_onTargetAvailable
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
CONSOLE_MESSAGE
resourceCommand
.
TYPES
.
ERROR_MESSAGE
resourceCommand
.
TYPES
.
PLATFORM_MESSAGE
resourceCommand
.
TYPES
.
CLONED_CONTENT_PROCESS_MESSAGE
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
if
(
this
.
isBrowserConsole
|
|
this
.
isBrowserToolboxConsole
)
{
const
shouldEnableNetworkMonitoring
=
Services
.
prefs
.
getBoolPref
(
PREFS
.
UI
.
ENABLE_NETWORK_MONITORING
)
;
if
(
shouldEnableNetworkMonitoring
)
{
await
this
.
startWatchingNetworkResources
(
)
;
}
else
{
await
this
.
stopWatchingNetworkResources
(
)
;
}
}
else
{
await
this
.
startWatchingNetworkResources
(
)
;
}
}
async
startWatchingNetworkResources
(
)
{
const
{
commands
resourceCommand
}
=
this
.
hud
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
NETWORK_EVENT
resourceCommand
.
TYPES
.
NETWORK_EVENT_STACKTRACE
]
{
onAvailable
:
this
.
_onResourceAvailable
onUpdated
:
this
.
_onNetworkResourceUpdated
}
)
;
const
hasNetworkResourceCommandSupport
=
resourceCommand
.
hasResourceCommandSupport
(
resourceCommand
.
TYPES
.
NETWORK_EVENT
)
;
const
supportsWatcherRequest
=
commands
.
targetCommand
.
hasTargetWatcherSupport
(
)
;
if
(
hasNetworkResourceCommandSupport
&
&
supportsWatcherRequest
)
{
const
networkFront
=
await
commands
.
watcherFront
.
getNetworkParentActor
(
)
;
const
saveBodies
=
!
this
.
isBrowserConsole
&
&
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
saveRequestAndResponseBodies
"
)
;
await
networkFront
.
setSaveRequestAndResponseBodies
(
saveBodies
)
;
}
}
async
stopWatchingNetworkResources
(
)
{
if
(
!
this
.
hud
)
{
return
;
}
await
this
.
hud
.
resourceCommand
.
unwatchResources
(
[
this
.
hud
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
this
.
hud
.
resourceCommand
.
TYPES
.
NETWORK_EVENT_STACKTRACE
]
{
onAvailable
:
this
.
_onResourceAvailable
onUpdated
:
this
.
_onNetworkResourceUpdated
}
)
;
}
handleDocumentEvent
(
resource
)
{
if
(
!
resource
.
targetFront
.
isTopLevel
)
{
return
;
}
if
(
resource
.
name
=
=
"
will
-
navigate
"
)
{
this
.
handleWillNavigate
(
{
timeStamp
:
resource
.
time
url
:
resource
.
newURI
}
)
;
}
else
if
(
resource
.
name
=
=
"
dom
-
complete
"
)
{
this
.
handleNavigated
(
{
hasNativeConsoleAPI
:
resource
.
hasNativeConsoleAPI
}
)
;
}
}
async
handleNavigated
(
{
hasNativeConsoleAPI
}
)
{
this
.
wrapper
.
dispatchUpdateInstantEvaluationResultForCurrentExpression
(
)
;
await
this
.
wrapper
.
waitAsyncDispatches
(
)
;
if
(
!
hasNativeConsoleAPI
)
{
this
.
logWarningAboutReplacedAPI
(
)
;
}
this
.
emit
(
"
reloaded
"
)
;
}
handleWillNavigate
(
{
timeStamp
url
}
)
{
this
.
wrapper
.
dispatchTabWillNavigate
(
{
timeStamp
url
}
)
;
}
async
watchCssMessages
(
)
{
const
{
resourceCommand
}
=
this
.
hud
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
CSS_MESSAGE
]
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
}
_onResourceAvailable
(
resources
)
{
if
(
!
this
.
hud
)
{
return
;
}
const
messages
=
[
]
;
for
(
const
resource
of
resources
)
{
const
{
TYPES
}
=
this
.
hud
.
resourceCommand
;
if
(
resource
.
resourceType
=
=
=
TYPES
.
DOCUMENT_EVENT
)
{
this
.
handleDocumentEvent
(
resource
)
;
continue
;
}
if
(
!
this
.
wrapper
|
|
(
(
resource
.
resourceType
=
=
=
TYPES
.
ERROR_MESSAGE
|
|
resource
.
resourceType
=
=
=
TYPES
.
CSS_MESSAGE
)
&
&
resource
.
pageError
?
.
isForwardedFromContentProcess
&
&
(
this
.
isBrowserToolboxConsole
|
|
this
.
isBrowserConsole
)
&
&
this
.
fissionSupport
)
)
{
continue
;
}
if
(
(
this
.
isBrowserToolboxConsole
|
|
this
.
isBrowserConsole
)
&
&
resource
.
isAlreadyExistingResource
&
&
(
resource
.
pageError
?
.
private
|
|
resource
.
message
?
.
private
)
)
{
continue
;
}
if
(
resource
.
resourceType
=
=
=
TYPES
.
NETWORK_EVENT_STACKTRACE
)
{
this
.
networkDataProvider
?
.
onStackTraceAvailable
(
resource
)
;
continue
;
}
if
(
resource
.
resourceType
=
=
=
TYPES
.
NETWORK_EVENT
)
{
this
.
networkDataProvider
?
.
onNetworkResourceAvailable
(
resource
)
;
}
messages
.
push
(
resource
)
;
}
this
.
wrapper
.
dispatchMessagesAdd
(
messages
)
;
}
_onNetworkResourceUpdated
(
updates
)
{
const
messageUpdates
=
[
]
;
for
(
const
{
resource
}
of
updates
)
{
if
(
resource
.
resourceType
=
=
this
.
hud
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
)
{
this
.
networkDataProvider
?
.
onNetworkResourceUpdated
(
resource
)
;
messageUpdates
.
push
(
resource
)
;
}
}
this
.
wrapper
.
dispatchMessagesUpdate
(
messageUpdates
)
;
}
async
_onTargetAvailable
(
{
targetFront
}
)
{
const
{
targetCommand
resourceCommand
}
=
this
.
hud
.
commands
;
const
hasNetworkResourceCommandSupport
=
resourceCommand
.
hasResourceCommandSupport
(
resourceCommand
.
TYPES
.
NETWORK_EVENT
)
;
const
supportsWatcherRequest
=
targetCommand
.
hasTargetWatcherSupport
(
)
;
if
(
!
hasNetworkResourceCommandSupport
|
|
!
supportsWatcherRequest
)
{
const
saveBodies
=
!
this
.
isBrowserConsole
&
&
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
saveRequestAndResponseBodies
"
)
;
const
front
=
await
targetFront
.
getFront
(
"
console
"
)
;
await
front
.
setPreferences
(
{
"
NetworkMonitor
.
saveRequestAndResponseBodies
"
:
saveBodies
}
)
;
}
if
(
targetFront
.
isTopLevel
)
{
this
.
_webConsoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
if
(
this
.
isBrowserConsole
|
|
this
.
isBrowserToolboxConsole
)
{
this
.
webConsoleFront
.
on
(
"
lastPrivateContextExited
"
this
.
clearPrivateMessages
)
;
}
}
}
_onTargetDestroyed
(
{
targetFront
isModeSwitching
}
)
{
if
(
!
this
.
wrapper
)
{
return
;
}
if
(
isModeSwitching
)
{
this
.
wrapper
.
dispatchTargetMessagesRemove
(
targetFront
)
;
}
}
_initUI
(
)
{
this
.
document
=
this
.
window
.
document
;
this
.
rootElement
=
this
.
document
.
documentElement
;
this
.
outputNode
=
this
.
document
.
getElementById
(
"
app
-
wrapper
"
)
;
const
{
toolbox
}
=
this
.
hud
;
const
WebConsoleWrapper
=
BrowserLoader
(
{
baseURI
:
"
resource
:
/
/
devtools
/
client
/
webconsole
/
"
window
:
this
.
window
}
)
.
require
(
"
devtools
/
client
/
webconsole
/
webconsole
-
wrapper
"
)
;
this
.
wrapper
=
new
WebConsoleWrapper
(
this
.
outputNode
this
toolbox
this
.
document
)
;
this
.
_initShortcuts
(
)
;
this
.
_initOutputSyntaxHighlighting
(
)
;
if
(
toolbox
)
{
toolbox
.
on
(
"
webconsole
-
selected
"
this
.
_onPanelSelected
)
;
toolbox
.
on
(
"
split
-
console
"
this
.
_onChangeSplitConsoleState
)
;
toolbox
.
on
(
"
select
"
this
.
_onChangeSplitConsoleState
)
;
}
}
_initOutputSyntaxHighlighting
(
)
{
const
syntaxHighlightNode
=
node
=
>
{
const
editor
=
this
.
jsterm
&
&
this
.
jsterm
.
editor
;
if
(
node
&
&
editor
)
{
node
.
classList
.
add
(
"
cm
-
s
-
mozilla
"
)
;
editor
.
CodeMirror
.
runMode
(
node
.
textContent
"
application
/
javascript
"
node
)
;
}
}
;
const
win
=
this
.
window
;
win
.
customElements
.
define
(
"
syntax
-
highlighted
"
class
extends
win
.
HTMLElement
{
connectedCallback
(
)
{
if
(
!
this
.
connected
)
{
this
.
connected
=
true
;
syntaxHighlightNode
(
this
)
;
this
.
observer
=
new
win
.
MutationObserver
(
(
mutations
observer
)
=
>
{
observer
.
disconnect
(
)
;
syntaxHighlightNode
(
this
)
;
observer
.
observe
(
this
{
childList
:
true
}
)
;
}
)
;
this
.
observer
.
observe
(
this
{
childList
:
true
}
)
;
}
}
}
)
;
}
_initShortcuts
(
)
{
const
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
window
}
)
;
let
clearShortcut
;
if
(
AppConstants
.
platform
=
=
=
"
macosx
"
)
{
const
alternativaClearShortcut
=
l10n
.
getStr
(
"
webconsole
.
clear
.
alternativeKeyOSX
"
)
;
shortcuts
.
on
(
alternativaClearShortcut
event
=
>
this
.
clearOutput
(
true
event
)
)
;
clearShortcut
=
l10n
.
getStr
(
"
webconsole
.
clear
.
keyOSX
"
)
;
}
else
{
clearShortcut
=
l10n
.
getStr
(
"
webconsole
.
clear
.
key
"
)
;
}
shortcuts
.
on
(
clearShortcut
event
=
>
this
.
clearOutput
(
true
event
)
)
;
if
(
this
.
isBrowserConsole
)
{
this
.
window
.
focus
(
)
;
shortcuts
.
on
(
l10n
.
getStr
(
"
webconsole
.
close
.
key
"
)
this
.
window
.
close
.
bind
(
this
.
window
)
)
;
ZoomKeys
.
register
(
this
.
window
shortcuts
)
;
shortcuts
.
on
(
"
CmdOrCtrl
+
Alt
+
R
"
quickRestart
)
;
}
else
if
(
Services
.
prefs
.
getBoolPref
(
PREF_SIDEBAR_ENABLED
)
)
{
shortcuts
.
on
(
"
Esc
"
event
=
>
{
this
.
wrapper
.
dispatchSidebarClose
(
)
;
if
(
this
.
jsterm
)
{
this
.
jsterm
.
focus
(
)
;
}
}
)
;
}
}
_onPanelSelected
(
)
{
if
(
this
.
jsterm
)
{
this
.
jsterm
.
focus
(
)
;
}
}
_onChangeSplitConsoleState
(
)
{
this
.
wrapper
.
dispatchSplitConsoleCloseButtonToggle
(
)
;
}
_onScopePrefChanged
(
)
{
if
(
this
.
isBrowserConsole
)
{
this
.
hud
.
updateWindowTitle
(
)
;
}
}
getInputCursor
(
)
{
return
this
.
jsterm
&
&
this
.
jsterm
.
getSelectionStart
(
)
;
}
getJsTermTooltipAnchor
(
)
{
return
this
.
outputNode
.
querySelector
(
"
.
CodeMirror
-
cursor
"
)
;
}
attachRef
(
id
node
)
{
this
[
id
]
=
node
;
}
getSelectedNodeActorID
(
)
{
const
inspectorSelection
=
this
.
hud
.
getInspectorSelection
(
)
;
return
inspectorSelection
?
.
nodeFront
?
.
actorID
;
}
}
function
quickRestart
(
)
{
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
env
.
set
(
"
MOZ_DISABLE_SAFE_MODE_KEY
"
"
1
"
)
;
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eAttemptQuit
|
Ci
.
nsIAppStartup
.
eRestart
)
;
}
exports
.
WebConsoleUI
=
WebConsoleUI
;
