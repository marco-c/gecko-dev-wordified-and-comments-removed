"
use
strict
"
;
const
contentTypes
=
{
"
text
/
plain
"
:
1
"
text
/
javascript
"
:
1
"
text
/
x
-
javascript
"
:
1
"
text
/
json
"
:
1
"
text
/
x
-
json
"
:
1
"
application
/
json
"
:
1
"
application
/
x
-
json
"
:
1
"
application
/
javascript
"
:
1
"
application
/
x
-
javascript
"
:
1
"
application
/
json
-
rpc
"
:
1
}
;
var
Json
=
{
}
;
Json
.
parseJSONString
=
function
(
jsonString
)
{
if
(
!
jsonString
.
length
)
{
return
null
;
}
let
regex
matches
;
let
first
=
firstNonWs
(
jsonString
)
;
if
(
first
!
=
=
"
[
"
&
&
first
!
=
=
"
{
"
)
{
regex
=
/
^
\
s
*
\
/
\
*
-
secure
-
(
[
\
s
\
S
]
*
)
\
*
\
/
\
s
*
/
;
matches
=
regex
.
exec
(
jsonString
)
;
if
(
matches
)
{
jsonString
=
matches
[
1
]
;
if
(
jsonString
[
0
]
=
=
=
"
\
\
"
&
&
jsonString
[
1
]
=
=
=
"
n
"
)
{
jsonString
=
jsonString
.
substr
(
2
)
;
}
if
(
jsonString
[
jsonString
.
length
-
2
]
=
=
=
"
\
\
"
&
&
jsonString
[
jsonString
.
length
-
1
]
=
=
=
"
n
"
)
{
jsonString
=
jsonString
.
substr
(
0
jsonString
.
length
-
2
)
;
}
}
if
(
jsonString
.
includes
(
"
&
&
&
START
&
&
&
"
)
)
{
regex
=
/
&
&
&
START
&
&
&
(
[
\
s
\
S
]
*
)
&
&
&
END
&
&
&
/
;
matches
=
regex
.
exec
(
jsonString
)
;
if
(
matches
)
{
jsonString
=
matches
[
1
]
;
}
}
regex
=
/
^
\
s
*
(
\
)
\
]
\
}
[
^
\
n
]
*
\
n
|
while
\
s
*
\
(
1
\
)
;
|
for
\
s
*
\
(
;
;
\
)
;
)
(
[
\
s
\
S
]
*
)
/
;
matches
=
regex
.
exec
(
jsonString
)
;
if
(
matches
)
{
jsonString
=
matches
[
2
]
;
}
regex
=
/
^
\
s
*
(
[
A
-
Za
-
z0
-
9_
.
]
+
\
s
*
(
?
:
\
[
.
*
\
]
|
)
)
\
s
*
\
(
(
[
\
s
\
S
]
*
)
\
)
/
;
matches
=
regex
.
exec
(
jsonString
)
;
if
(
matches
)
{
jsonString
=
matches
[
2
]
;
}
}
try
{
return
JSON
.
parse
(
jsonString
)
;
}
catch
(
err
)
{
}
first
=
firstNonWs
(
jsonString
)
;
if
(
first
!
=
=
"
[
"
&
&
first
!
=
=
"
{
"
&
&
isNaN
(
first
)
&
&
first
!
=
=
'
"
'
)
{
return
null
;
}
jsonString
=
pseudoJsonToJson
(
jsonString
)
;
try
{
return
JSON
.
parse
(
jsonString
)
;
}
catch
(
err
)
{
}
return
null
;
}
;
function
firstNonWs
(
str
)
{
for
(
let
i
=
0
len
=
str
.
length
;
i
<
len
;
i
+
+
)
{
let
ch
=
str
[
i
]
;
if
(
ch
!
=
=
"
"
&
&
ch
!
=
=
"
\
n
"
&
&
ch
!
=
=
"
\
t
"
&
&
ch
!
=
=
"
\
r
"
)
{
return
ch
;
}
}
return
"
"
;
}
function
pseudoJsonToJson
(
json
)
{
let
ret
=
"
"
;
let
at
=
0
lasti
=
0
lastch
=
"
"
hasMultipleParts
=
false
;
for
(
let
i
=
0
len
=
json
.
length
;
i
<
len
;
+
+
i
)
{
let
ch
=
json
[
i
]
;
if
(
/
\
s
/
.
test
(
ch
)
)
{
continue
;
}
if
(
ch
=
=
=
'
"
'
)
{
+
+
i
;
while
(
i
<
len
)
{
if
(
json
[
i
]
=
=
=
"
\
\
"
)
{
+
+
i
;
}
else
if
(
json
[
i
]
=
=
=
'
"
'
)
{
break
;
}
+
+
i
;
}
}
else
if
(
ch
=
=
=
"
'
"
)
{
ret
+
=
json
.
slice
(
at
i
)
+
"
\
"
"
;
at
=
i
+
1
;
+
+
i
;
while
(
i
<
len
)
{
if
(
json
[
i
]
=
=
=
"
\
\
"
)
{
+
+
i
;
}
else
if
(
json
[
i
]
=
=
=
"
'
"
)
{
break
;
}
+
+
i
;
}
if
(
i
<
len
)
{
ret
+
=
json
.
slice
(
at
i
)
+
"
\
"
"
;
at
=
i
+
1
;
}
}
else
if
(
(
ch
=
=
=
"
[
"
|
|
ch
=
=
=
"
{
"
)
&
&
(
lastch
=
=
=
"
]
"
|
|
lastch
=
=
=
"
}
"
)
)
{
ret
+
=
json
.
slice
(
at
i
)
+
"
"
;
hasMultipleParts
=
true
;
at
=
i
;
}
else
if
(
lastch
=
=
=
"
"
&
&
(
ch
=
=
=
"
]
"
|
|
ch
=
=
=
"
}
"
)
)
{
ret
+
=
json
.
slice
(
at
lasti
)
;
at
=
i
;
}
else
if
(
lastch
=
=
=
"
/
"
&
&
lasti
=
=
=
i
-
1
)
{
if
(
ch
=
=
=
"
/
"
)
{
ret
+
=
json
.
slice
(
at
i
-
1
)
;
at
=
i
+
json
.
slice
(
i
)
.
search
(
/
\
n
|
\
r
|
/
)
;
i
=
at
-
1
;
}
else
if
(
ch
=
=
=
"
*
"
)
{
ret
+
=
json
.
slice
(
at
i
-
1
)
;
at
=
json
.
indexOf
(
"
*
/
"
i
+
1
)
+
2
;
if
(
at
=
=
=
1
)
{
at
=
len
;
}
i
=
at
-
1
;
}
ch
=
"
\
0
"
;
}
else
if
(
/
[
a
-
zA
-
Z
_
]
/
.
test
(
ch
)
&
&
lastch
!
=
=
"
:
"
)
{
ret
+
=
json
.
slice
(
at
i
)
+
"
\
"
"
;
at
=
i
;
i
=
i
+
json
.
slice
(
i
)
.
search
(
/
[
^
a
-
zA
-
Z0
-
9
_
]
|
/
)
;
ret
+
=
json
.
slice
(
at
i
)
+
"
\
"
"
;
at
=
i
;
}
lastch
=
ch
;
lasti
=
i
;
}
ret
+
=
json
.
slice
(
at
)
;
if
(
hasMultipleParts
)
{
ret
=
"
[
"
+
ret
+
"
]
"
;
}
return
ret
;
}
Json
.
isJSON
=
function
(
contentType
data
)
{
let
len
=
data
?
data
.
length
:
0
;
for
(
let
i
=
0
;
i
<
len
;
i
+
+
)
{
let
ch
=
data
.
charAt
(
i
)
;
if
(
ch
=
=
=
"
{
"
)
{
return
true
;
}
if
(
ch
=
=
=
"
"
|
|
ch
=
=
=
"
\
t
"
|
|
ch
=
=
=
"
\
n
"
|
|
ch
=
=
=
"
\
r
"
)
{
continue
;
}
break
;
}
if
(
!
contentType
)
{
return
false
;
}
contentType
=
contentType
.
split
(
"
;
"
)
[
0
]
;
contentType
=
contentType
.
trim
(
)
;
return
!
!
contentTypes
[
contentType
]
;
}
;
module
.
exports
=
Json
;
