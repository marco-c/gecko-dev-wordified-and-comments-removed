"
use
strict
"
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
TreeView
=
createFactory
(
require
(
"
devtools
/
client
/
shared
/
components
/
tree
/
TreeView
"
)
)
;
const
{
REPS
MODE
parseURLEncodedText
}
=
require
(
"
devtools
/
client
/
shared
/
components
/
reps
/
reps
"
)
;
const
{
Rep
}
=
REPS
;
const
NetInfoParams
=
createFactory
(
require
(
"
.
/
net
-
info
-
params
"
)
)
;
const
NetInfoGroupList
=
createFactory
(
require
(
"
.
/
net
-
info
-
group
-
list
"
)
)
;
const
Spinner
=
createFactory
(
require
(
"
.
/
spinner
"
)
)
;
const
SizeLimit
=
createFactory
(
require
(
"
.
/
size
-
limit
"
)
)
;
const
NetUtils
=
require
(
"
.
.
/
utils
/
net
"
)
;
const
Json
=
require
(
"
.
.
/
utils
/
json
"
)
;
class
PostTab
extends
Component
{
static
get
propTypes
(
)
{
return
{
data
:
PropTypes
.
shape
(
{
request
:
PropTypes
.
object
.
isRequired
}
)
actions
:
PropTypes
.
object
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
isJson
=
this
.
isJson
.
bind
(
this
)
;
this
.
parseJson
=
this
.
parseJson
.
bind
(
this
)
;
this
.
renderJson
=
this
.
renderJson
.
bind
(
this
)
;
this
.
parseXml
=
this
.
parseXml
.
bind
(
this
)
;
this
.
isXml
=
this
.
isXml
.
bind
(
this
)
;
this
.
renderXml
=
this
.
renderXml
.
bind
(
this
)
;
this
.
renderMultiPart
=
this
.
renderMultiPart
.
bind
(
this
)
;
this
.
renderUrlEncoded
=
this
.
renderUrlEncoded
.
bind
(
this
)
;
this
.
renderRawData
=
this
.
renderRawData
.
bind
(
this
)
;
}
componentDidMount
(
)
{
let
{
actions
data
:
file
}
=
this
.
props
;
if
(
!
file
.
request
.
postData
)
{
actions
.
requestData
(
"
requestPostData
"
)
;
}
}
isJson
(
file
)
{
let
text
=
file
.
request
.
postData
.
text
;
let
value
=
NetUtils
.
getHeaderValue
(
file
.
request
.
headers
"
content
-
type
"
)
;
return
Json
.
isJSON
(
value
text
)
;
}
parseJson
(
file
)
{
let
postData
=
file
.
request
.
postData
;
if
(
!
postData
)
{
return
null
;
}
let
jsonString
=
new
String
(
postData
.
text
)
;
return
Json
.
parseJSONString
(
jsonString
)
;
}
renderJson
(
file
)
{
let
text
=
file
.
request
.
postData
.
text
;
if
(
!
text
|
|
isLongString
(
text
)
)
{
return
null
;
}
if
(
!
this
.
isJson
(
file
)
)
{
return
null
;
}
let
json
=
this
.
parseJson
(
file
)
;
if
(
!
json
)
{
return
null
;
}
return
{
key
:
"
json
"
content
:
TreeView
(
{
columns
:
[
{
id
:
"
value
"
}
]
object
:
json
mode
:
MODE
.
TINY
renderValue
:
props
=
>
Rep
(
Object
.
assign
(
{
}
props
{
cropLimit
:
50
}
)
)
}
)
name
:
Locale
.
STR
(
"
jsonScopeName
"
)
}
;
}
parseXml
(
file
)
{
let
text
=
file
.
request
.
postData
.
text
;
if
(
isLongString
(
text
)
)
{
return
null
;
}
return
NetUtils
.
parseXml
(
{
mimeType
:
NetUtils
.
getHeaderValue
(
file
.
request
.
headers
"
content
-
type
"
)
text
:
text
}
)
;
}
isXml
(
file
)
{
if
(
isLongString
(
file
.
request
.
postData
.
text
)
)
{
return
false
;
}
let
value
=
NetUtils
.
getHeaderValue
(
file
.
request
.
headers
"
content
-
type
"
)
;
if
(
!
value
)
{
return
false
;
}
return
NetUtils
.
isHTML
(
value
)
;
}
renderXml
(
file
)
{
let
text
=
file
.
request
.
postData
.
text
;
if
(
!
text
|
|
isLongString
(
text
)
)
{
return
null
;
}
if
(
!
this
.
isXml
(
file
)
)
{
return
null
;
}
let
doc
=
this
.
parseXml
(
file
)
;
if
(
!
doc
)
{
return
null
;
}
return
null
;
}
renderMultiPart
(
file
)
{
let
text
=
file
.
request
.
postData
.
text
;
if
(
!
text
|
|
isLongString
(
text
)
)
{
return
;
}
if
(
NetUtils
.
isMultiPartRequest
(
file
)
)
{
}
}
renderUrlEncoded
(
file
)
{
let
text
=
file
.
request
.
postData
.
text
;
if
(
!
text
|
|
isLongString
(
text
)
)
{
return
null
;
}
if
(
!
NetUtils
.
isURLEncodedRequest
(
file
)
)
{
return
null
;
}
let
lines
=
text
.
split
(
"
\
n
"
)
;
let
params
=
parseURLEncodedText
(
lines
[
lines
.
length
-
1
]
)
;
return
{
key
:
"
url
-
encoded
"
content
:
NetInfoParams
(
{
params
:
params
}
)
name
:
Locale
.
STR
(
"
netRequest
.
params
"
)
}
;
}
renderRawData
(
file
)
{
let
text
=
file
.
request
.
postData
.
text
;
let
group
;
if
(
typeof
text
=
=
"
object
"
)
{
group
=
{
key
:
"
raw
-
longstring
"
name
:
Locale
.
STR
(
"
netRequest
.
rawData
"
)
content
:
dom
.
div
(
{
className
:
"
netInfoResponseContent
"
}
sanitize
(
text
.
initial
)
SizeLimit
(
{
actions
:
this
.
props
.
actions
data
:
file
.
request
.
postData
message
:
Locale
.
STR
(
"
netRequest
.
sizeLimitMessage
"
)
link
:
Locale
.
STR
(
"
netRequest
.
sizeLimitMessageLink
"
)
}
)
)
}
;
}
else
{
group
=
{
key
:
"
raw
"
name
:
Locale
.
STR
(
"
netRequest
.
rawData
"
)
content
:
dom
.
div
(
{
className
:
"
netInfoResponseContent
"
}
sanitize
(
text
)
)
}
;
}
return
group
;
}
render
(
)
{
let
{
data
:
file
}
=
this
.
props
;
if
(
file
.
discardRequestBody
)
{
return
dom
.
span
(
{
className
:
"
netInfoBodiesDiscarded
"
}
Locale
.
STR
(
"
netRequest
.
requestBodyDiscarded
"
)
)
;
}
if
(
!
file
.
request
.
postData
)
{
return
(
Spinner
(
)
)
;
}
let
groups
=
[
]
;
groups
.
push
(
this
.
renderUrlEncoded
(
file
)
)
;
groups
.
push
(
this
.
renderJson
(
file
)
)
;
groups
.
push
(
this
.
renderXml
(
file
)
)
;
groups
.
push
(
this
.
renderRawData
(
file
)
)
;
groups
=
groups
.
filter
(
group
=
>
group
)
;
if
(
groups
.
length
>
1
)
{
groups
[
groups
.
length
-
1
]
.
open
=
false
;
}
return
(
dom
.
div
(
{
className
:
"
postTabBox
"
}
dom
.
div
(
{
className
:
"
panelContent
"
}
NetInfoGroupList
(
{
groups
:
groups
}
)
)
)
)
;
}
}
function
sanitize
(
text
)
{
text
=
JSON
.
stringify
(
text
)
;
text
=
text
.
replace
(
/
\
\
r
\
\
n
/
g
"
\
r
\
n
"
)
.
replace
(
/
\
\
"
/
g
"
\
"
"
)
;
return
text
.
slice
(
1
text
.
length
-
1
)
;
}
function
isLongString
(
text
)
{
return
typeof
text
=
=
"
object
"
;
}
module
.
exports
=
PostTab
;
