"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Debugger
=
require
(
"
Debugger
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
asyncStorage
"
"
devtools
/
shared
/
async
-
storage
"
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NotificationBox
"
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PriorityLevels
"
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
true
)
;
const
l10n
=
require
(
"
devtools
/
client
/
webconsole
/
webconsole
-
l10n
"
)
;
const
HISTORY_BACK
=
-
1
;
const
HISTORY_FORWARD
=
1
;
const
HELP_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Tools
/
Web_Console
/
Helpers
"
;
const
PREF_INPUT_HISTORY_COUNT
=
"
devtools
.
webconsole
.
inputHistoryCount
"
;
const
PREF_AUTO_MULTILINE
=
"
devtools
.
webconsole
.
autoMultiline
"
;
function
gSequenceId
(
)
{
return
gSequenceId
.
n
+
+
;
}
gSequenceId
.
n
=
0
;
const
{
Component
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
class
JSTerm
extends
Component
{
static
get
propTypes
(
)
{
return
{
hud
:
PropTypes
.
object
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
const
{
hud
}
=
props
;
this
.
hud
=
hud
;
this
.
hudId
=
this
.
hud
.
hudId
;
this
.
inputHistoryCount
=
Services
.
prefs
.
getIntPref
(
PREF_INPUT_HISTORY_COUNT
)
;
this
.
_loadHistory
(
)
;
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
_keyPress
=
this
.
_keyPress
.
bind
(
this
)
;
this
.
_inputEventHandler
=
this
.
_inputEventHandler
.
bind
(
this
)
;
this
.
_focusEventHandler
=
this
.
_focusEventHandler
.
bind
(
this
)
;
this
.
_blurEventHandler
=
this
.
_blurEventHandler
.
bind
(
this
)
;
this
.
SELECTED_FRAME
=
-
1
;
this
.
_autocompleteCache
=
null
;
this
.
_autocompleteQuery
=
null
;
this
.
_lastFrameActorId
=
null
;
this
.
lastInputValue
=
"
"
;
this
.
_inputChanged
=
false
;
this
.
_autocompletePopupNavigated
=
false
;
this
.
history
=
[
]
;
this
.
autocompletePopup
=
null
;
this
.
inputNode
=
null
;
this
.
completeNode
=
null
;
this
.
COMPLETE_FORWARD
=
0
;
this
.
COMPLETE_BACKWARD
=
1
;
this
.
COMPLETE_HINT_ONLY
=
2
;
this
.
COMPLETE_PAGEUP
=
3
;
this
.
COMPLETE_PAGEDOWN
=
4
;
EventEmitter
.
decorate
(
this
)
;
hud
.
jsterm
=
this
;
}
componentDidMount
(
)
{
if
(
!
this
.
inputNode
)
{
return
;
}
let
autocompleteOptions
=
{
onSelect
:
this
.
onAutocompleteSelect
.
bind
(
this
)
onClick
:
this
.
acceptProposedCompletion
.
bind
(
this
)
listId
:
"
webConsole_autocompletePopupListBox
"
position
:
"
top
"
theme
:
"
auto
"
autoSelect
:
true
}
;
let
doc
=
this
.
hud
.
document
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
let
tooltipDoc
=
toolbox
?
toolbox
.
doc
:
doc
;
this
.
autocompletePopup
=
new
AutocompletePopup
(
tooltipDoc
autocompleteOptions
)
;
this
.
inputBorderSize
=
this
.
inputNode
.
getBoundingClientRect
(
)
.
height
-
this
.
inputNode
.
clientHeight
;
this
.
_updateCharSize
(
)
;
this
.
inputNode
.
addEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
addEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
addEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
addEventListener
(
"
focus
"
this
.
_focusEventHandler
)
;
if
(
!
this
.
hud
.
isBrowserConsole
)
{
let
okstring
=
l10n
.
getStr
(
"
selfxss
.
okstring
"
)
;
let
msg
=
l10n
.
getFormatStr
(
"
selfxss
.
msg
"
[
okstring
]
)
;
this
.
_onPaste
=
WebConsoleUtils
.
pasteHandlerGen
(
this
.
inputNode
this
.
getNotificationBox
(
)
msg
okstring
)
;
this
.
inputNode
.
addEventListener
(
"
paste
"
this
.
_onPaste
)
;
this
.
inputNode
.
addEventListener
(
"
drop
"
this
.
_onPaste
)
;
}
this
.
hud
.
window
.
addEventListener
(
"
blur
"
this
.
_blurEventHandler
)
;
this
.
lastInputValue
&
&
this
.
setInputValue
(
this
.
lastInputValue
)
;
this
.
focus
(
)
;
}
shouldComponentUpdate
(
)
{
return
false
;
}
_loadHistory
(
)
{
this
.
history
=
[
]
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
0
;
this
.
historyLoaded
=
asyncStorage
.
getItem
(
"
webConsoleHistory
"
)
.
then
(
value
=
>
{
if
(
Array
.
isArray
(
value
)
)
{
this
.
history
=
value
.
concat
(
this
.
history
)
;
this
.
historyIndex
=
this
.
history
.
length
;
this
.
historyPlaceHolder
=
this
.
history
.
length
;
}
}
console
.
error
)
;
}
clearHistory
(
)
{
this
.
history
=
[
]
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
0
;
return
this
.
storeHistory
(
)
;
}
storeHistory
(
)
{
return
asyncStorage
.
setItem
(
"
webConsoleHistory
"
this
.
history
)
;
}
get
outputNode
(
)
{
return
this
.
hud
.
outputNode
;
}
get
webConsoleClient
(
)
{
return
this
.
hud
.
webConsoleClient
;
}
focus
(
)
{
if
(
this
.
inputNode
&
&
!
this
.
inputNode
.
getAttribute
(
"
focused
"
)
)
{
this
.
inputNode
.
focus
(
)
;
}
}
_executeResultCallback
(
callback
response
)
{
if
(
!
this
.
hud
)
{
return
;
}
if
(
response
.
error
)
{
console
.
error
(
"
Evaluation
error
"
+
response
.
error
+
"
:
"
+
response
.
message
)
;
return
;
}
let
errorMessage
=
response
.
exceptionMessage
;
if
(
typeof
response
.
exception
=
=
=
"
string
"
)
{
errorMessage
=
new
Error
(
errorMessage
)
.
toString
(
)
;
}
let
result
=
response
.
result
;
let
helperResult
=
response
.
helperResult
;
let
helperHasRawOutput
=
!
!
(
helperResult
|
|
{
}
)
.
rawOutput
;
if
(
helperResult
&
&
helperResult
.
type
)
{
switch
(
helperResult
.
type
)
{
case
"
clearOutput
"
:
this
.
clearOutput
(
)
;
break
;
case
"
clearHistory
"
:
this
.
clearHistory
(
)
;
break
;
case
"
inspectObject
"
:
this
.
inspectObjectActor
(
helperResult
.
object
)
;
break
;
case
"
error
"
:
try
{
errorMessage
=
l10n
.
getStr
(
helperResult
.
message
)
;
}
catch
(
ex
)
{
errorMessage
=
helperResult
.
message
;
}
break
;
case
"
help
"
:
this
.
hud
.
owner
.
openLink
(
HELP_URL
)
;
break
;
case
"
copyValueToClipboard
"
:
clipboardHelper
.
copyString
(
helperResult
.
value
)
;
break
;
}
}
if
(
!
errorMessage
&
&
result
&
&
typeof
result
=
=
"
object
"
&
&
result
.
type
=
=
"
undefined
"
&
&
helperResult
&
&
!
helperHasRawOutput
)
{
callback
&
&
callback
(
)
;
return
;
}
if
(
this
.
hud
.
newConsoleOutput
)
{
this
.
hud
.
newConsoleOutput
.
dispatchMessageAdd
(
response
true
)
.
then
(
callback
)
;
}
}
inspectObjectActor
(
objectActor
)
{
this
.
hud
.
newConsoleOutput
.
dispatchMessageAdd
(
{
helperResult
:
{
type
:
"
inspectObject
"
object
:
objectActor
}
}
true
)
;
return
this
.
hud
.
newConsoleOutput
;
}
async
execute
(
executeString
callback
)
{
let
deferred
=
defer
(
)
;
let
resultCallback
=
msg
=
>
deferred
.
resolve
(
msg
)
;
executeString
=
executeString
|
|
this
.
getInputValue
(
)
;
if
(
!
executeString
)
{
return
null
;
}
this
.
history
[
this
.
historyIndex
+
+
]
=
executeString
;
this
.
historyPlaceHolder
=
this
.
history
.
length
;
if
(
this
.
history
.
length
>
this
.
inputHistoryCount
)
{
this
.
history
.
splice
(
0
this
.
history
.
length
-
this
.
inputHistoryCount
)
;
this
.
historyIndex
=
this
.
historyPlaceHolder
=
this
.
history
.
length
;
}
this
.
storeHistory
(
)
;
WebConsoleUtils
.
usageCount
+
+
;
this
.
setInputValue
(
"
"
)
;
this
.
clearCompletion
(
)
;
let
selectedNodeActor
=
null
;
let
inspectorSelection
=
this
.
hud
.
owner
.
getInspectorSelection
(
)
;
if
(
inspectorSelection
&
&
inspectorSelection
.
nodeFront
)
{
selectedNodeActor
=
inspectorSelection
.
nodeFront
.
actorID
;
}
const
{
ConsoleCommand
}
=
require
(
"
devtools
/
client
/
webconsole
/
types
"
)
;
let
message
=
new
ConsoleCommand
(
{
messageText
:
executeString
}
)
;
this
.
hud
.
proxy
.
dispatchMessageAdd
(
message
)
;
let
onResult
=
this
.
_executeResultCallback
.
bind
(
this
resultCallback
)
;
let
options
=
{
frame
:
this
.
SELECTED_FRAME
selectedNodeActor
:
selectedNodeActor
}
;
const
mappedString
=
await
this
.
hud
.
owner
.
getMappedExpression
(
executeString
)
;
this
.
requestEvaluation
(
mappedString
options
)
.
then
(
onResult
onResult
)
;
return
deferred
.
promise
;
}
requestEvaluation
(
str
options
=
{
}
)
{
let
deferred
=
defer
(
)
;
function
onResult
(
response
)
{
if
(
!
response
.
error
)
{
deferred
.
resolve
(
response
)
;
}
else
{
deferred
.
reject
(
response
)
;
}
}
let
frameActor
=
null
;
if
(
"
frame
"
in
options
)
{
frameActor
=
this
.
getFrameActor
(
options
.
frame
)
;
}
let
evalOptions
=
{
bindObjectActor
:
options
.
bindObjectActor
frameActor
:
frameActor
selectedNodeActor
:
options
.
selectedNodeActor
selectedObjectActor
:
options
.
selectedObjectActor
}
;
this
.
webConsoleClient
.
evaluateJSAsync
(
str
onResult
evalOptions
)
;
return
deferred
.
promise
;
}
copyObject
(
evalString
evalOptions
)
{
return
this
.
webConsoleClient
.
evaluateJSAsync
(
copy
(
{
evalString
}
)
null
evalOptions
)
;
}
getFrameActor
(
frame
)
{
let
state
=
this
.
hud
.
owner
.
getDebuggerFrames
(
)
;
if
(
!
state
)
{
return
null
;
}
let
grip
;
if
(
frame
=
=
this
.
SELECTED_FRAME
)
{
grip
=
state
.
frames
[
state
.
selected
]
;
}
else
{
grip
=
state
.
frames
[
frame
]
;
}
return
grip
?
grip
.
actor
:
null
;
}
clearOutput
(
clearStorage
)
{
if
(
this
.
hud
&
&
this
.
hud
.
newConsoleOutput
)
{
this
.
hud
.
newConsoleOutput
.
dispatchMessagesClear
(
)
;
}
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
if
(
clearStorage
)
{
this
.
webConsoleClient
.
clearMessagesCache
(
)
;
}
this
.
focus
(
)
;
this
.
emit
(
"
messages
-
cleared
"
)
;
}
clearPrivateMessages
(
)
{
if
(
this
.
hud
&
&
this
.
hud
.
newConsoleOutput
)
{
this
.
hud
.
newConsoleOutput
.
dispatchPrivateMessagesClear
(
)
;
this
.
emit
(
"
private
-
messages
-
cleared
"
)
;
}
}
resizeInput
(
)
{
if
(
!
this
.
inputNode
)
{
return
;
}
let
inputNode
=
this
.
inputNode
;
inputNode
.
style
.
height
=
"
auto
"
;
let
scrollHeight
=
inputNode
.
inputField
?
inputNode
.
inputField
.
scrollHeight
:
inputNode
.
scrollHeight
;
if
(
scrollHeight
>
0
)
{
inputNode
.
style
.
height
=
(
scrollHeight
+
this
.
inputBorderSize
)
+
"
px
"
;
}
}
setInputValue
(
newValue
)
{
if
(
!
this
.
inputNode
)
{
return
;
}
this
.
inputNode
.
value
=
newValue
;
this
.
lastInputValue
=
newValue
;
this
.
completeNode
.
value
=
"
"
;
this
.
resizeInput
(
)
;
this
.
_inputChanged
=
true
;
this
.
emit
(
"
set
-
input
-
value
"
)
;
}
getInputValue
(
)
{
return
this
.
inputNode
?
this
.
inputNode
.
value
|
|
"
"
:
"
"
;
}
_inputEventHandler
(
)
{
if
(
this
.
lastInputValue
!
=
this
.
getInputValue
(
)
)
{
this
.
resizeInput
(
)
;
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
;
this
.
lastInputValue
=
this
.
getInputValue
(
)
;
this
.
_inputChanged
=
true
;
}
}
_blurEventHandler
(
)
{
if
(
this
.
autocompletePopup
)
{
this
.
clearCompletion
(
)
;
}
}
_keyPress
(
event
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
let
inputUpdated
=
false
;
if
(
event
.
ctrlKey
)
{
switch
(
event
.
charCode
)
{
case
101
:
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
break
;
}
let
lineEndPos
=
inputValue
.
length
;
if
(
this
.
hasMultilineInput
(
)
)
{
for
(
let
i
=
inputNode
.
selectionEnd
;
i
<
lineEndPos
;
i
+
+
)
{
if
(
inputValue
.
charAt
(
i
)
=
=
"
\
r
"
|
|
inputValue
.
charAt
(
i
)
=
=
"
\
n
"
)
{
lineEndPos
=
i
;
break
;
}
}
}
inputNode
.
setSelectionRange
(
lineEndPos
lineEndPos
)
;
event
.
preventDefault
(
)
;
this
.
clearCompletion
(
)
;
break
;
case
110
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
case
112
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
default
:
break
;
}
return
;
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
let
autoMultiline
=
Services
.
prefs
.
getBoolPref
(
PREF_AUTO_MULTILINE
)
;
if
(
event
.
shiftKey
|
|
(
!
Debugger
.
isCompilableUnit
(
inputNode
.
value
)
&
&
autoMultiline
)
)
{
return
;
}
}
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_ESCAPE
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RETURN
:
if
(
this
.
_autocompletePopupNavigated
&
&
this
.
autocompletePopup
.
isOpen
&
&
this
.
autocompletePopup
.
selectedIndex
>
-
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
{
this
.
execute
(
)
;
this
.
_inputChanged
=
false
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_BACKWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_FORWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEUP
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputScroller
.
scrollTop
=
Math
.
max
(
0
this
.
hud
.
outputScroller
.
scrollTop
-
this
.
hud
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEDOWN
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputScroller
.
scrollTop
=
Math
.
min
(
this
.
hud
.
outputScroller
.
scrollHeight
this
.
hud
.
outputScroller
.
scrollTop
+
this
.
hud
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_HOME
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
0
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputScroller
.
scrollTop
=
0
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_END
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
this
.
autocompletePopup
.
itemCount
-
1
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputScroller
.
scrollTop
=
this
.
hud
.
outputScroller
.
scrollHeight
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_LEFT
:
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RIGHT
:
let
cursorAtTheEnd
=
this
.
inputNode
.
selectionStart
=
=
this
.
inputNode
.
selectionEnd
&
&
this
.
inputNode
.
selectionStart
=
=
inputValue
.
length
;
let
haveSuggestion
=
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
;
let
useCompletion
=
cursorAtTheEnd
|
|
this
.
_autocompletePopupNavigated
;
if
(
haveSuggestion
&
&
useCompletion
&
&
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
.
value
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_TAB
:
if
(
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
else
if
(
this
.
_inputChanged
)
{
this
.
updateCompleteNode
(
l10n
.
getStr
(
"
Autocomplete
.
blank
"
)
)
;
event
.
preventDefault
(
)
;
}
break
;
default
:
break
;
}
}
_focusEventHandler
(
)
{
this
.
_inputChanged
=
false
;
}
historyPeruse
(
direction
)
{
if
(
!
this
.
history
.
length
)
{
return
false
;
}
if
(
direction
=
=
HISTORY_BACK
)
{
if
(
this
.
historyPlaceHolder
<
=
0
)
{
return
false
;
}
let
inputVal
=
this
.
history
[
-
-
this
.
historyPlaceHolder
]
;
if
(
this
.
historyPlaceHolder
+
1
=
=
this
.
historyIndex
)
{
this
.
history
[
this
.
historyIndex
]
=
this
.
getInputValue
(
)
|
|
"
"
;
}
this
.
setInputValue
(
inputVal
)
;
}
else
if
(
direction
=
=
HISTORY_FORWARD
)
{
if
(
this
.
historyPlaceHolder
>
=
(
this
.
history
.
length
-
1
)
)
{
return
false
;
}
let
inputVal
=
this
.
history
[
+
+
this
.
historyPlaceHolder
]
;
this
.
setInputValue
(
inputVal
)
;
}
else
{
throw
new
Error
(
"
Invalid
argument
0
"
)
;
}
return
true
;
}
hasMultilineInput
(
)
{
return
/
[
\
r
\
n
]
/
.
test
(
this
.
getInputValue
(
)
)
;
}
canCaretGoPrevious
(
)
{
let
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
let
multiline
=
/
[
\
r
\
n
]
/
.
test
(
node
.
value
)
;
return
node
.
selectionStart
=
=
0
?
true
:
node
.
selectionStart
=
=
node
.
value
.
length
&
&
!
multiline
;
}
canCaretGoNext
(
)
{
let
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
let
multiline
=
/
[
\
r
\
n
]
/
.
test
(
node
.
value
)
;
return
node
.
selectionStart
=
=
node
.
value
.
length
?
true
:
node
.
selectionStart
=
=
0
&
&
!
multiline
;
}
complete
(
type
callback
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
let
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
!
inputValue
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
inputNode
.
selectionStart
!
=
inputNode
.
selectionEnd
)
{
this
.
clearCompletion
(
)
;
this
.
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
this
.
lastCompletion
.
value
!
=
inputValue
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_updateCompletionResult
(
type
callback
)
;
return
false
;
}
let
popup
=
this
.
autocompletePopup
;
let
accepted
=
false
;
if
(
type
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
accepted
=
true
;
}
else
if
(
type
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEUP
)
{
popup
.
selectPreviousPageItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEDOWN
)
{
popup
.
selectNextPageItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
accepted
|
|
popup
.
itemCount
>
0
;
}
_updateCompletionResult
(
type
callback
)
{
let
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
this
.
lastCompletion
.
value
=
=
this
.
getInputValue
(
)
&
&
frameActor
=
=
this
.
_lastFrameActorId
)
{
return
;
}
let
requestId
=
gSequenceId
(
)
;
let
cursor
=
this
.
inputNode
.
selectionStart
;
let
input
=
this
.
getInputValue
(
)
.
substring
(
0
cursor
)
;
let
cache
=
this
.
_autocompleteCache
;
if
(
!
/
[
a
-
zA
-
Z0
-
9
]
/
.
test
(
input
)
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_autocompleteQuery
=
null
;
this
.
_autocompleteCache
=
null
;
}
if
(
this
.
_autocompleteQuery
&
&
input
.
startsWith
(
this
.
_autocompleteQuery
)
)
{
let
filterBy
=
input
;
let
lastNonAlpha
=
input
.
match
(
/
[
^
a
-
zA
-
Z0
-
9_
]
[
a
-
zA
-
Z0
-
9_
]
*
/
)
;
if
(
lastNonAlpha
)
{
filterBy
=
input
.
substring
(
input
.
lastIndexOf
(
lastNonAlpha
)
+
1
)
;
}
let
newList
=
cache
.
sort
(
)
.
filter
(
function
(
l
)
{
return
l
.
startsWith
(
filterBy
)
;
}
)
;
this
.
lastCompletion
=
{
requestId
:
null
completionType
:
type
value
:
null
}
;
let
response
=
{
matches
:
newList
matchProp
:
filterBy
}
;
this
.
_receiveAutocompleteProperties
(
null
callback
response
)
;
return
;
}
this
.
_lastFrameActorId
=
frameActor
;
this
.
lastCompletion
=
{
requestId
:
requestId
completionType
:
type
value
:
null
}
;
let
autocompleteCallback
=
this
.
_receiveAutocompleteProperties
.
bind
(
this
requestId
callback
)
;
this
.
webConsoleClient
.
autocomplete
(
input
cursor
autocompleteCallback
frameActor
)
;
}
_receiveAutocompleteProperties
(
requestId
callback
message
)
{
let
inputNode
=
this
.
inputNode
;
let
inputValue
=
this
.
getInputValue
(
)
;
if
(
this
.
lastCompletion
.
value
=
=
inputValue
|
|
requestId
!
=
this
.
lastCompletion
.
requestId
)
{
return
;
}
let
cursor
=
inputNode
.
selectionStart
;
let
inputUntilCursor
=
inputValue
.
substring
(
0
cursor
)
;
if
(
requestId
!
=
null
&
&
/
[
a
-
zA
-
Z0
-
9
.
]
/
.
test
(
inputUntilCursor
)
)
{
this
.
_autocompleteCache
=
message
.
matches
;
this
.
_autocompleteQuery
=
inputUntilCursor
;
}
let
matches
=
message
.
matches
;
let
lastPart
=
message
.
matchProp
;
if
(
!
matches
.
length
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
;
}
let
items
=
matches
.
reverse
(
)
.
map
(
function
(
match
)
{
return
{
preLabel
:
lastPart
label
:
match
}
;
}
)
;
let
popup
=
this
.
autocompletePopup
;
popup
.
setItems
(
items
)
;
let
completionType
=
this
.
lastCompletion
.
completionType
;
this
.
lastCompletion
=
{
value
:
inputValue
matchProp
:
lastPart
}
;
if
(
items
.
length
>
1
&
&
!
popup
.
isOpen
)
{
let
str
=
this
.
getInputValue
(
)
.
substr
(
0
this
.
inputNode
.
selectionStart
)
;
let
offset
=
str
.
length
-
(
str
.
lastIndexOf
(
"
\
n
"
)
+
1
)
-
lastPart
.
length
;
let
x
=
offset
*
this
.
_inputCharWidth
;
popup
.
openPopup
(
inputNode
x
+
this
.
_chevronWidth
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
else
if
(
items
.
length
<
2
&
&
popup
.
isOpen
)
{
popup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
if
(
items
.
length
=
=
1
)
{
popup
.
selectedIndex
=
0
;
}
this
.
onAutocompleteSelect
(
)
;
if
(
completionType
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
}
onAutocompleteSelect
(
)
{
if
(
this
.
inputNode
.
selectionStart
!
=
this
.
getInputValue
(
)
.
length
)
{
return
;
}
let
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
let
suffix
=
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
;
this
.
updateCompleteNode
(
suffix
)
;
}
else
{
this
.
updateCompleteNode
(
"
"
)
;
}
}
clearCompletion
(
)
{
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
updateCompleteNode
(
"
"
)
;
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
clearItems
(
)
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
inputNode
.
blur
(
)
;
this
.
autocompletePopup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
this
.
inputNode
.
focus
(
)
;
}
)
;
this
.
autocompletePopup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
}
}
acceptProposedCompletion
(
)
{
let
updated
=
false
;
let
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
let
suffix
=
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
;
let
cursor
=
this
.
inputNode
.
selectionStart
;
let
value
=
this
.
getInputValue
(
)
;
this
.
setInputValue
(
value
.
substr
(
0
cursor
)
+
suffix
+
value
.
substr
(
cursor
)
)
;
let
newCursor
=
cursor
+
suffix
.
length
;
this
.
inputNode
.
selectionStart
=
this
.
inputNode
.
selectionEnd
=
newCursor
;
updated
=
true
;
}
this
.
clearCompletion
(
)
;
return
updated
;
}
updateCompleteNode
(
suffix
)
{
if
(
!
this
.
completeNode
)
{
return
;
}
let
prefix
=
suffix
?
this
.
getInputValue
(
)
.
replace
(
/
[
\
S
]
/
g
"
"
)
:
"
"
;
this
.
completeNode
.
value
=
prefix
+
suffix
;
}
_updateCharSize
(
)
{
let
doc
=
this
.
hud
.
document
;
let
tempLabel
=
doc
.
createElement
(
"
span
"
)
;
let
style
=
tempLabel
.
style
;
style
.
position
=
"
fixed
"
;
style
.
padding
=
"
0
"
;
style
.
margin
=
"
0
"
;
style
.
width
=
"
auto
"
;
style
.
color
=
"
transparent
"
;
WebConsoleUtils
.
copyTextStyles
(
this
.
inputNode
tempLabel
)
;
tempLabel
.
textContent
=
"
x
"
;
doc
.
documentElement
.
appendChild
(
tempLabel
)
;
this
.
_inputCharWidth
=
tempLabel
.
offsetWidth
;
tempLabel
.
remove
(
)
;
this
.
_chevronWidth
=
+
doc
.
defaultView
.
getComputedStyle
(
this
.
inputNode
)
.
paddingLeft
.
replace
(
/
[
^
0
-
9
.
]
/
g
"
"
)
-
4
;
}
getNotificationBox
(
)
{
if
(
this
.
_notificationBox
)
{
return
this
.
_notificationBox
;
}
let
box
=
this
.
hud
.
document
.
getElementById
(
"
webconsole
-
notificationbox
"
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
this
.
_notificationBox
=
Object
.
assign
(
toolbox
.
ReactDOM
.
render
(
toolbox
.
React
.
createElement
(
NotificationBox
)
box
)
PriorityLevels
)
;
return
this
.
_notificationBox
;
}
destroy
(
)
{
this
.
clearCompletion
(
)
;
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
if
(
this
.
hud
.
outputNode
)
{
this
.
hud
.
outputNode
.
innerHTML
=
"
"
;
}
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
destroy
(
)
;
this
.
autocompletePopup
=
null
;
}
if
(
this
.
inputNode
)
{
if
(
this
.
_onPaste
)
{
this
.
inputNode
.
removeEventListener
(
"
paste
"
this
.
_onPaste
)
;
this
.
inputNode
.
removeEventListener
(
"
drop
"
this
.
_onPaste
)
;
this
.
_onPaste
=
null
;
}
this
.
inputNode
.
removeEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
removeEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
removeEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
removeEventListener
(
"
focus
"
this
.
_focusEventHandler
)
;
this
.
hud
.
window
.
removeEventListener
(
"
blur
"
this
.
_blurEventHandler
)
;
}
this
.
hud
=
null
;
}
render
(
)
{
if
(
this
.
props
.
hud
.
isBrowserConsole
&
&
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
{
return
null
;
}
return
[
dom
.
div
(
{
id
:
"
webconsole
-
notificationbox
"
key
:
"
notification
"
}
)
dom
.
div
(
{
className
:
"
jsterm
-
input
-
container
"
key
:
"
jsterm
-
container
"
style
:
{
direction
:
"
ltr
"
}
"
aria
-
live
"
:
"
off
"
}
dom
.
textarea
(
{
className
:
"
jsterm
-
complete
-
node
devtools
-
monospace
"
key
:
"
complete
"
tabIndex
:
"
-
1
"
ref
:
node
=
>
{
this
.
completeNode
=
node
;
}
}
)
dom
.
textarea
(
{
className
:
"
jsterm
-
input
-
node
devtools
-
monospace
"
key
:
"
input
"
tabIndex
:
"
0
"
rows
:
"
1
"
"
aria
-
autocomplete
"
:
"
list
"
ref
:
node
=
>
{
this
.
inputNode
=
node
;
}
}
)
)
]
;
}
}
module
.
exports
=
JSTerm
;
