"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
loader
.
lazyRequireGetter
(
this
"
Debugger
"
"
Debugger
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropTypes
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
KeyCodes
"
"
devtools
/
client
/
shared
/
keycodes
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Editor
"
"
devtools
/
client
/
sourceeditor
/
editor
"
)
;
loader
.
lazyRequireGetter
(
this
"
Telemetry
"
"
devtools
/
client
/
shared
/
telemetry
"
)
;
loader
.
lazyRequireGetter
(
this
"
processScreenshot
"
"
devtools
/
shared
/
webconsole
/
screenshot
-
helper
"
)
;
const
l10n
=
require
(
"
devtools
/
client
/
webconsole
/
webconsole
-
l10n
"
)
;
const
HELP_URL
=
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Tools
/
Web_Console
/
Helpers
"
;
function
gSequenceId
(
)
{
return
gSequenceId
.
n
+
+
;
}
gSequenceId
.
n
=
0
;
const
{
Component
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
{
getHistory
getHistoryValue
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
history
"
)
;
const
historyActions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
history
"
)
;
const
{
HISTORY_BACK
HISTORY_FORWARD
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
class
JSTerm
extends
Component
{
static
get
propTypes
(
)
{
return
{
appendToHistory
:
PropTypes
.
func
.
isRequired
clearHistory
:
PropTypes
.
func
.
isRequired
getValueFromHistory
:
PropTypes
.
func
.
isRequired
history
:
PropTypes
.
object
.
isRequired
hud
:
PropTypes
.
object
.
isRequired
onPaste
:
PropTypes
.
func
codeMirrorEnabled
:
PropTypes
.
bool
updatePlaceHolder
:
PropTypes
.
func
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
const
{
hud
}
=
props
;
this
.
hud
=
hud
;
this
.
hudId
=
this
.
hud
.
hudId
;
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
_keyPress
=
this
.
_keyPress
.
bind
(
this
)
;
this
.
_inputEventHandler
=
this
.
_inputEventHandler
.
bind
(
this
)
;
this
.
_blurEventHandler
=
this
.
_blurEventHandler
.
bind
(
this
)
;
this
.
SELECTED_FRAME
=
-
1
;
this
.
_autocompleteCache
=
null
;
this
.
_autocompleteQuery
=
null
;
this
.
_lastFrameActorId
=
null
;
this
.
lastInputValue
=
"
"
;
this
.
_autocompletePopupNavigated
=
false
;
this
.
autocompletePopup
=
null
;
this
.
inputNode
=
null
;
this
.
completeNode
=
null
;
this
.
COMPLETE_FORWARD
=
0
;
this
.
COMPLETE_BACKWARD
=
1
;
this
.
COMPLETE_HINT_ONLY
=
2
;
this
.
COMPLETE_PAGEUP
=
3
;
this
.
COMPLETE_PAGEDOWN
=
4
;
this
.
_telemetry
=
new
Telemetry
(
)
;
EventEmitter
.
decorate
(
this
)
;
hud
.
jsterm
=
this
;
}
componentDidMount
(
)
{
const
autocompleteOptions
=
{
onSelect
:
this
.
onAutocompleteSelect
.
bind
(
this
)
onClick
:
this
.
acceptProposedCompletion
.
bind
(
this
)
listId
:
"
webConsole_autocompletePopupListBox
"
position
:
"
top
"
theme
:
"
auto
"
autoSelect
:
true
}
;
const
doc
=
this
.
hud
.
document
;
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
const
tooltipDoc
=
toolbox
?
toolbox
.
doc
:
doc
;
this
.
autocompletePopup
=
new
AutocompletePopup
(
tooltipDoc
autocompleteOptions
)
;
if
(
this
.
props
.
codeMirrorEnabled
)
{
if
(
this
.
node
)
{
this
.
editor
=
new
Editor
(
{
autofocus
:
true
enableCodeFolding
:
false
gutters
:
[
]
lineWrapping
:
true
mode
:
Editor
.
modes
.
js
styleActiveLine
:
false
tabIndex
:
"
0
"
viewportMargin
:
Infinity
extraKeys
:
{
"
Enter
"
:
(
e
cm
)
=
>
{
if
(
!
this
.
autocompletePopup
.
isOpen
&
&
(
e
.
shiftKey
|
|
!
Debugger
.
isCompilableUnit
(
this
.
getInputValue
(
)
)
)
)
{
return
"
CodeMirror
.
Pass
"
;
}
this
.
execute
(
)
;
return
null
;
}
"
Up
"
:
(
)
=
>
{
let
inputUpdated
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_BACKWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
if
(
!
inputUpdated
)
{
return
"
CodeMirror
.
Pass
"
;
}
return
null
;
}
"
Down
"
:
(
)
=
>
{
let
inputUpdated
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_FORWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
if
(
!
inputUpdated
)
{
return
"
CodeMirror
.
Pass
"
;
}
return
null
;
}
"
Ctrl
-
N
"
:
(
)
=
>
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
"
Ctrl
-
P
"
:
(
)
=
>
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
}
}
)
;
this
.
editor
.
appendToLocalElement
(
this
.
node
)
;
const
cm
=
this
.
editor
.
codeMirror
;
cm
.
on
(
"
paste
"
(
_
event
)
=
>
this
.
props
.
onPaste
(
event
)
)
;
cm
.
on
(
"
drop
"
(
_
event
)
=
>
this
.
props
.
onPaste
(
event
)
)
;
}
}
else
if
(
this
.
inputNode
)
{
this
.
inputNode
.
addEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
addEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
addEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
this
.
focus
(
)
;
}
this
.
inputBorderSize
=
this
.
inputNode
?
this
.
inputNode
.
getBoundingClientRect
(
)
.
height
-
this
.
inputNode
.
clientHeight
:
0
;
this
.
_inputCharWidth
=
this
.
_getInputCharWidth
(
)
;
this
.
_chevronWidth
=
this
.
editor
?
null
:
this
.
_getChevronWidth
(
)
;
this
.
hud
.
window
.
addEventListener
(
"
blur
"
this
.
_blurEventHandler
)
;
this
.
lastInputValue
&
&
this
.
setInputValue
(
this
.
lastInputValue
)
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
return
false
;
}
get
outputNode
(
)
{
return
this
.
hud
.
outputNode
;
}
get
webConsoleClient
(
)
{
return
this
.
hud
.
webConsoleClient
;
}
focus
(
)
{
if
(
this
.
editor
)
{
this
.
editor
.
focus
(
)
;
}
else
if
(
this
.
inputNode
&
&
!
this
.
inputNode
.
getAttribute
(
"
focused
"
)
)
{
this
.
inputNode
.
focus
(
)
;
}
}
async
_executeResultCallback
(
response
)
{
if
(
!
this
.
hud
)
{
return
null
;
}
if
(
response
.
error
)
{
console
.
error
(
"
Evaluation
error
"
+
response
.
error
+
"
:
"
+
response
.
message
)
;
return
null
;
}
let
errorMessage
=
response
.
exceptionMessage
;
if
(
typeof
response
.
exception
=
=
=
"
string
"
)
{
errorMessage
=
new
Error
(
errorMessage
)
.
toString
(
)
;
}
const
result
=
response
.
result
;
const
helperResult
=
response
.
helperResult
;
const
helperHasRawOutput
=
!
!
(
helperResult
|
|
{
}
)
.
rawOutput
;
if
(
helperResult
&
&
helperResult
.
type
)
{
switch
(
helperResult
.
type
)
{
case
"
clearOutput
"
:
this
.
hud
.
clearOutput
(
)
;
break
;
case
"
clearHistory
"
:
this
.
props
.
clearHistory
(
)
;
break
;
case
"
inspectObject
"
:
this
.
inspectObjectActor
(
helperResult
.
object
)
;
break
;
case
"
error
"
:
try
{
errorMessage
=
l10n
.
getStr
(
helperResult
.
message
)
;
}
catch
(
ex
)
{
errorMessage
=
helperResult
.
message
;
}
break
;
case
"
help
"
:
this
.
hud
.
owner
.
openLink
(
HELP_URL
)
;
break
;
case
"
copyValueToClipboard
"
:
clipboardHelper
.
copyString
(
helperResult
.
value
)
;
break
;
case
"
screenshotOutput
"
:
const
{
args
value
}
=
helperResult
;
const
results
=
await
processScreenshot
(
this
.
hud
.
window
args
value
)
;
this
.
screenshotNotify
(
results
)
;
return
null
;
}
}
if
(
!
errorMessage
&
&
result
&
&
typeof
result
=
=
"
object
"
&
&
result
.
type
=
=
"
undefined
"
&
&
helperResult
&
&
!
helperHasRawOutput
)
{
return
null
;
}
if
(
this
.
hud
.
consoleOutput
)
{
return
this
.
hud
.
consoleOutput
.
dispatchMessageAdd
(
response
true
)
;
}
return
null
;
}
inspectObjectActor
(
objectActor
)
{
this
.
hud
.
consoleOutput
.
dispatchMessageAdd
(
{
helperResult
:
{
type
:
"
inspectObject
"
object
:
objectActor
}
}
true
)
;
return
this
.
hud
.
consoleOutput
;
}
screenshotNotify
(
results
)
{
const
wrappedResults
=
results
.
map
(
message
=
>
(
{
message
type
:
"
logMessage
"
}
)
)
;
this
.
hud
.
consoleOutput
.
dispatchMessagesAdd
(
wrappedResults
)
;
}
async
execute
(
executeString
)
{
executeString
=
executeString
|
|
this
.
getInputValue
(
)
;
if
(
!
executeString
)
{
return
null
;
}
this
.
props
.
appendToHistory
(
executeString
)
;
WebConsoleUtils
.
usageCount
+
+
;
this
.
setInputValue
(
"
"
)
;
this
.
clearCompletion
(
)
;
let
selectedNodeActor
=
null
;
const
inspectorSelection
=
this
.
hud
.
owner
.
getInspectorSelection
(
)
;
if
(
inspectorSelection
&
&
inspectorSelection
.
nodeFront
)
{
selectedNodeActor
=
inspectorSelection
.
nodeFront
.
actorID
;
}
const
{
ConsoleCommand
}
=
require
(
"
devtools
/
client
/
webconsole
/
types
"
)
;
const
cmdMessage
=
new
ConsoleCommand
(
{
messageText
:
executeString
}
)
;
this
.
hud
.
proxy
.
dispatchMessageAdd
(
cmdMessage
)
;
const
options
=
{
frame
:
this
.
SELECTED_FRAME
selectedNodeActor
}
;
const
mappedString
=
await
this
.
hud
.
owner
.
getMappedExpression
(
executeString
)
;
const
onEvaluated
=
this
.
requestEvaluation
(
mappedString
options
)
.
then
(
res
=
>
res
res
=
>
res
)
;
const
response
=
await
onEvaluated
;
return
this
.
_executeResultCallback
(
response
)
;
}
requestEvaluation
(
str
options
=
{
}
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
this
.
hud
.
owner
.
target
)
;
this
.
_telemetry
.
recordEvent
(
"
devtools
.
main
"
"
execute_js
"
"
webconsole
"
null
{
"
lines
"
:
str
.
split
(
/
\
n
/
)
.
length
"
session_id
"
:
toolbox
?
toolbox
.
sessionId
:
-
1
}
)
;
let
frameActor
=
null
;
if
(
"
frame
"
in
options
)
{
frameActor
=
this
.
getFrameActor
(
options
.
frame
)
;
}
const
evalOptions
=
{
bindObjectActor
:
options
.
bindObjectActor
frameActor
selectedNodeActor
:
options
.
selectedNodeActor
selectedObjectActor
:
options
.
selectedObjectActor
}
;
return
this
.
webConsoleClient
.
evaluateJSAsync
(
str
null
evalOptions
)
;
}
copyObject
(
evalString
evalOptions
)
{
return
this
.
webConsoleClient
.
evaluateJSAsync
(
copy
(
{
evalString
}
)
null
evalOptions
)
;
}
getFrameActor
(
frame
)
{
const
state
=
this
.
hud
.
owner
.
getDebuggerFrames
(
)
;
if
(
!
state
)
{
return
null
;
}
let
grip
;
if
(
frame
=
=
this
.
SELECTED_FRAME
)
{
grip
=
state
.
frames
[
state
.
selected
]
;
}
else
{
grip
=
state
.
frames
[
frame
]
;
}
return
grip
?
grip
.
actor
:
null
;
}
resizeInput
(
)
{
if
(
this
.
props
.
codeMirrorEnabled
)
{
return
;
}
if
(
!
this
.
inputNode
)
{
return
;
}
const
inputNode
=
this
.
inputNode
;
inputNode
.
style
.
height
=
"
auto
"
;
const
scrollHeight
=
inputNode
.
scrollHeight
;
if
(
scrollHeight
>
0
)
{
inputNode
.
style
.
height
=
(
scrollHeight
+
this
.
inputBorderSize
)
+
"
px
"
;
}
}
setInputValue
(
newValue
)
{
if
(
this
.
props
.
codeMirrorEnabled
)
{
if
(
this
.
editor
)
{
this
.
editor
.
setText
(
newValue
)
;
this
.
editor
.
setCursor
(
{
line
:
this
.
editor
.
getDoc
(
)
.
lineCount
(
)
ch
:
0
}
)
;
}
}
else
{
if
(
!
this
.
inputNode
)
{
return
;
}
this
.
inputNode
.
value
=
newValue
;
this
.
completeNode
.
value
=
"
"
;
}
this
.
lastInputValue
=
newValue
;
this
.
resizeInput
(
)
;
this
.
emit
(
"
set
-
input
-
value
"
)
;
}
getInputValue
(
)
{
if
(
this
.
props
.
codeMirrorEnabled
)
{
return
this
.
editor
.
getText
(
)
|
|
"
"
;
}
return
this
.
inputNode
?
this
.
inputNode
.
value
|
|
"
"
:
"
"
;
}
_inputEventHandler
(
)
{
if
(
this
.
lastInputValue
!
=
this
.
getInputValue
(
)
)
{
this
.
resizeInput
(
)
;
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
;
this
.
lastInputValue
=
this
.
getInputValue
(
)
;
}
}
_blurEventHandler
(
)
{
if
(
this
.
autocompletePopup
)
{
this
.
clearCompletion
(
)
;
}
}
_keyPress
(
event
)
{
const
inputNode
=
this
.
inputNode
;
const
inputValue
=
this
.
getInputValue
(
)
;
let
inputUpdated
=
false
;
if
(
event
.
ctrlKey
)
{
switch
(
event
.
charCode
)
{
case
101
:
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
break
;
}
let
lineEndPos
=
inputValue
.
length
;
if
(
this
.
hasMultilineInput
(
)
)
{
for
(
let
i
=
inputNode
.
selectionEnd
;
i
<
lineEndPos
;
i
+
+
)
{
if
(
inputValue
.
charAt
(
i
)
=
=
"
\
r
"
|
|
inputValue
.
charAt
(
i
)
=
=
"
\
n
"
)
{
lineEndPos
=
i
;
break
;
}
}
}
inputNode
.
setSelectionRange
(
lineEndPos
lineEndPos
)
;
event
.
preventDefault
(
)
;
this
.
clearCompletion
(
)
;
break
;
case
110
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
case
112
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
default
:
break
;
}
return
;
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
if
(
!
this
.
autocompletePopup
.
isOpen
&
&
(
event
.
shiftKey
|
|
!
Debugger
.
isCompilableUnit
(
this
.
getInputValue
(
)
)
)
)
{
return
;
}
}
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_ESCAPE
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RETURN
:
if
(
this
.
_autocompletePopupNavigated
&
&
this
.
autocompletePopup
.
isOpen
&
&
this
.
autocompletePopup
.
selectedIndex
>
-
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
{
this
.
execute
(
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_BACKWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_FORWARD
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
if
(
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEUP
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputScroller
.
scrollTop
=
Math
.
max
(
0
this
.
hud
.
outputScroller
.
scrollTop
-
this
.
hud
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
inputUpdated
=
this
.
complete
(
this
.
COMPLETE_PAGEDOWN
)
;
if
(
inputUpdated
)
{
this
.
_autocompletePopupNavigated
=
true
;
}
}
else
{
this
.
hud
.
outputScroller
.
scrollTop
=
Math
.
min
(
this
.
hud
.
outputScroller
.
scrollHeight
this
.
hud
.
outputScroller
.
scrollTop
+
this
.
hud
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_HOME
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
0
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputScroller
.
scrollTop
=
0
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_END
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectedIndex
=
this
.
autocompletePopup
.
itemCount
-
1
;
event
.
preventDefault
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
hud
.
outputScroller
.
scrollTop
=
this
.
hud
.
outputScroller
.
scrollHeight
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_LEFT
:
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RIGHT
:
const
cursorAtTheEnd
=
this
.
inputNode
.
selectionStart
=
=
this
.
inputNode
.
selectionEnd
&
&
this
.
inputNode
.
selectionStart
=
=
inputValue
.
length
;
const
haveSuggestion
=
this
.
autocompletePopup
.
isOpen
|
|
this
.
lastCompletion
.
value
;
const
useCompletion
=
cursorAtTheEnd
|
|
this
.
_autocompletePopupNavigated
;
if
(
haveSuggestion
&
&
useCompletion
&
&
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
.
value
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_TAB
:
if
(
this
.
complete
(
this
.
COMPLETE_HINT_ONLY
)
&
&
this
.
lastCompletion
&
&
this
.
acceptProposedCompletion
(
)
)
{
event
.
preventDefault
(
)
;
}
else
if
(
!
this
.
hasEmptyInput
(
)
)
{
if
(
!
event
.
shiftKey
)
{
this
.
insertStringAtCursor
(
"
\
t
"
)
;
}
event
.
preventDefault
(
)
;
}
break
;
default
:
break
;
}
}
historyPeruse
(
direction
)
{
const
{
history
updatePlaceHolder
getValueFromHistory
}
=
this
.
props
;
if
(
!
history
.
entries
.
length
)
{
return
false
;
}
const
newInputValue
=
getValueFromHistory
(
direction
)
;
const
expression
=
this
.
getInputValue
(
)
;
updatePlaceHolder
(
direction
expression
)
;
if
(
newInputValue
!
=
null
)
{
this
.
setInputValue
(
newInputValue
)
;
return
true
;
}
return
false
;
}
hasEmptyInput
(
)
{
return
this
.
getInputValue
(
)
=
=
=
"
"
;
}
hasMultilineInput
(
)
{
return
/
[
\
r
\
n
]
/
.
test
(
this
.
getInputValue
(
)
)
;
}
canCaretGoPrevious
(
)
{
const
inputValue
=
this
.
getInputValue
(
)
;
if
(
this
.
editor
)
{
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
return
(
line
=
=
=
0
&
&
ch
=
=
=
0
)
|
|
(
line
=
=
=
0
&
&
ch
=
=
=
inputValue
.
length
)
;
}
const
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
const
multiline
=
/
[
\
r
\
n
]
/
.
test
(
inputValue
)
;
return
node
.
selectionStart
=
=
0
?
true
:
node
.
selectionStart
=
=
inputValue
.
length
&
&
!
multiline
;
}
canCaretGoNext
(
)
{
const
inputValue
=
this
.
getInputValue
(
)
;
const
multiline
=
/
[
\
r
\
n
]
/
.
test
(
inputValue
)
;
if
(
this
.
editor
)
{
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
return
(
!
multiline
&
&
ch
=
=
=
0
)
|
|
this
.
editor
.
getDoc
(
)
.
getRange
(
{
line
:
0
ch
:
0
}
{
line
ch
}
)
.
length
=
=
=
inputValue
.
length
;
}
const
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
return
node
.
selectionStart
=
=
node
.
value
.
length
?
true
:
node
.
selectionStart
=
=
0
&
&
!
multiline
;
}
complete
(
type
callback
)
{
const
inputNode
=
this
.
inputNode
;
const
inputValue
=
this
.
getInputValue
(
)
;
const
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
!
inputValue
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
inputNode
.
selectionStart
!
=
inputNode
.
selectionEnd
)
{
this
.
clearCompletion
(
)
;
this
.
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
false
;
}
if
(
this
.
lastCompletion
.
value
!
=
inputValue
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_updateCompletionResult
(
type
callback
)
;
return
false
;
}
const
popup
=
this
.
autocompletePopup
;
let
accepted
=
false
;
if
(
type
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
accepted
=
true
;
}
else
if
(
type
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEUP
)
{
popup
.
selectPreviousPageItem
(
)
;
}
else
if
(
type
=
=
this
.
COMPLETE_PAGEDOWN
)
{
popup
.
selectNextPageItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
accepted
|
|
popup
.
itemCount
>
0
;
}
_updateCompletionResult
(
type
callback
)
{
const
frameActor
=
this
.
getFrameActor
(
this
.
SELECTED_FRAME
)
;
if
(
this
.
lastCompletion
.
value
=
=
this
.
getInputValue
(
)
&
&
frameActor
=
=
this
.
_lastFrameActorId
)
{
return
;
}
const
requestId
=
gSequenceId
(
)
;
const
cursor
=
this
.
inputNode
.
selectionStart
;
const
input
=
this
.
getInputValue
(
)
.
substring
(
0
cursor
)
;
const
cache
=
this
.
_autocompleteCache
;
if
(
!
/
[
a
-
zA
-
Z0
-
9
]
/
.
test
(
input
)
|
|
frameActor
!
=
this
.
_lastFrameActorId
)
{
this
.
_autocompleteQuery
=
null
;
this
.
_autocompleteCache
=
null
;
}
if
(
this
.
_autocompleteQuery
&
&
input
.
startsWith
(
this
.
_autocompleteQuery
)
)
{
let
filterBy
=
input
;
const
lastNonAlpha
=
input
.
match
(
/
[
^
a
-
zA
-
Z0
-
9_
]
[
a
-
zA
-
Z0
-
9_
]
*
/
)
;
if
(
lastNonAlpha
)
{
filterBy
=
input
.
substring
(
input
.
lastIndexOf
(
lastNonAlpha
)
+
1
)
;
}
const
newList
=
cache
.
sort
(
)
.
filter
(
function
(
l
)
{
return
l
.
startsWith
(
filterBy
)
;
}
)
;
this
.
lastCompletion
=
{
requestId
:
null
completionType
:
type
value
:
null
}
;
const
response
=
{
matches
:
newList
matchProp
:
filterBy
}
;
this
.
_receiveAutocompleteProperties
(
null
callback
response
)
;
return
;
}
this
.
_lastFrameActorId
=
frameActor
;
this
.
lastCompletion
=
{
requestId
:
requestId
completionType
:
type
value
:
null
}
;
const
autocompleteCallback
=
this
.
_receiveAutocompleteProperties
.
bind
(
this
requestId
callback
)
;
this
.
webConsoleClient
.
autocomplete
(
input
cursor
autocompleteCallback
frameActor
)
;
}
_receiveAutocompleteProperties
(
requestId
callback
message
)
{
const
inputNode
=
this
.
inputNode
;
const
inputValue
=
this
.
getInputValue
(
)
;
if
(
this
.
lastCompletion
.
value
=
=
inputValue
|
|
requestId
!
=
this
.
lastCompletion
.
requestId
)
{
return
;
}
const
cursor
=
inputNode
.
selectionStart
;
const
inputUntilCursor
=
inputValue
.
substring
(
0
cursor
)
;
if
(
requestId
!
=
null
&
&
/
[
a
-
zA
-
Z0
-
9
.
]
/
.
test
(
inputUntilCursor
)
)
{
this
.
_autocompleteCache
=
message
.
matches
;
this
.
_autocompleteQuery
=
inputUntilCursor
;
}
const
matches
=
message
.
matches
;
const
lastPart
=
message
.
matchProp
;
if
(
!
matches
.
length
)
{
this
.
clearCompletion
(
)
;
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
;
}
const
items
=
matches
.
reverse
(
)
.
map
(
function
(
match
)
{
return
{
preLabel
:
lastPart
label
:
match
}
;
}
)
;
const
popup
=
this
.
autocompletePopup
;
popup
.
setItems
(
items
)
;
const
completionType
=
this
.
lastCompletion
.
completionType
;
this
.
lastCompletion
=
{
value
:
inputValue
matchProp
:
lastPart
}
;
if
(
items
.
length
>
1
&
&
!
popup
.
isOpen
)
{
const
str
=
this
.
getInputValue
(
)
.
substr
(
0
this
.
inputNode
.
selectionStart
)
;
const
offset
=
str
.
length
-
(
str
.
lastIndexOf
(
"
\
n
"
)
+
1
)
-
lastPart
.
length
;
const
x
=
offset
*
this
.
_inputCharWidth
;
popup
.
openPopup
(
inputNode
x
+
this
.
_chevronWidth
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
else
if
(
items
.
length
<
2
&
&
popup
.
isOpen
)
{
popup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
if
(
items
.
length
=
=
1
)
{
popup
.
selectedIndex
=
0
;
}
this
.
onAutocompleteSelect
(
)
;
if
(
completionType
!
=
this
.
COMPLETE_HINT_ONLY
&
&
popup
.
itemCount
=
=
1
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_BACKWARD
)
{
popup
.
selectPreviousItem
(
)
;
}
else
if
(
completionType
=
=
this
.
COMPLETE_FORWARD
)
{
popup
.
selectNextItem
(
)
;
}
callback
&
&
callback
(
this
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
}
onAutocompleteSelect
(
)
{
if
(
this
.
inputNode
.
selectionStart
!
=
this
.
getInputValue
(
)
.
length
)
{
return
;
}
const
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
const
suffix
=
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
;
this
.
updateCompleteNode
(
suffix
)
;
}
else
{
this
.
updateCompleteNode
(
"
"
)
;
}
}
clearCompletion
(
)
{
this
.
lastCompletion
=
{
value
:
null
}
;
this
.
updateCompleteNode
(
"
"
)
;
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
clearItems
(
)
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
inputNode
.
blur
(
)
;
this
.
autocompletePopup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
this
.
inputNode
.
focus
(
)
;
}
)
;
this
.
autocompletePopup
.
hidePopup
(
)
;
this
.
_autocompletePopupNavigated
=
false
;
}
}
}
acceptProposedCompletion
(
)
{
let
updated
=
false
;
const
currentItem
=
this
.
autocompletePopup
.
selectedItem
;
if
(
currentItem
&
&
this
.
lastCompletion
.
value
)
{
this
.
insertStringAtCursor
(
currentItem
.
label
.
substring
(
this
.
lastCompletion
.
matchProp
.
length
)
)
;
updated
=
true
;
}
this
.
clearCompletion
(
)
;
return
updated
;
}
insertStringAtCursor
(
str
)
{
const
cursor
=
this
.
inputNode
.
selectionStart
;
const
value
=
this
.
getInputValue
(
)
;
this
.
setInputValue
(
value
.
substr
(
0
cursor
)
+
str
+
value
.
substr
(
cursor
)
)
;
const
newCursor
=
cursor
+
str
.
length
;
this
.
inputNode
.
selectionStart
=
this
.
inputNode
.
selectionEnd
=
newCursor
;
}
updateCompleteNode
(
suffix
)
{
if
(
!
this
.
completeNode
)
{
return
;
}
const
prefix
=
suffix
?
this
.
getInputValue
(
)
.
replace
(
/
[
\
S
]
/
g
"
"
)
:
"
"
;
this
.
completeNode
.
value
=
prefix
+
suffix
;
}
_getInputCharWidth
(
)
{
if
(
!
this
.
inputNode
&
&
!
this
.
node
)
{
return
null
;
}
if
(
this
.
editor
)
{
return
this
.
editor
.
defaultCharWidth
(
)
;
}
const
doc
=
this
.
hud
.
document
;
const
tempLabel
=
doc
.
createElement
(
"
span
"
)
;
const
style
=
tempLabel
.
style
;
style
.
position
=
"
fixed
"
;
style
.
padding
=
"
0
"
;
style
.
margin
=
"
0
"
;
style
.
width
=
"
auto
"
;
style
.
color
=
"
transparent
"
;
WebConsoleUtils
.
copyTextStyles
(
this
.
inputNode
tempLabel
)
;
tempLabel
.
textContent
=
"
x
"
;
doc
.
documentElement
.
appendChild
(
tempLabel
)
;
const
width
=
tempLabel
.
offsetWidth
;
tempLabel
.
remove
(
)
;
return
width
;
}
_getChevronWidth
(
)
{
if
(
!
this
.
inputNode
)
{
return
null
;
}
const
doc
=
this
.
hud
.
document
;
return
doc
.
defaultView
.
getComputedStyle
(
this
.
inputNode
)
.
paddingLeft
.
replace
(
/
[
^
0
-
9
.
]
/
g
"
"
)
-
4
;
}
destroy
(
)
{
this
.
clearCompletion
(
)
;
this
.
webConsoleClient
.
clearNetworkRequests
(
)
;
if
(
this
.
hud
.
outputNode
)
{
this
.
hud
.
outputNode
.
innerHTML
=
"
"
;
}
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
destroy
(
)
;
this
.
autocompletePopup
=
null
;
}
if
(
this
.
inputNode
)
{
this
.
inputNode
.
removeEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
removeEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
removeEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
this
.
hud
.
window
.
removeEventListener
(
"
blur
"
this
.
_blurEventHandler
)
;
}
if
(
this
.
editor
)
{
this
.
editor
.
destroy
(
)
;
this
.
editor
=
null
;
}
this
.
hud
=
null
;
}
render
(
)
{
if
(
this
.
props
.
hud
.
isBrowserConsole
&
&
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
{
return
null
;
}
if
(
this
.
props
.
codeMirrorEnabled
)
{
return
dom
.
div
(
{
className
:
"
jsterm
-
input
-
container
devtools
-
monospace
"
key
:
"
jsterm
-
container
"
style
:
{
direction
:
"
ltr
"
}
"
aria
-
live
"
:
"
off
"
ref
:
node
=
>
{
this
.
node
=
node
;
}
}
)
;
}
const
{
onPaste
}
=
this
.
props
;
return
(
dom
.
div
(
{
className
:
"
jsterm
-
input
-
container
"
key
:
"
jsterm
-
container
"
style
:
{
direction
:
"
ltr
"
}
"
aria
-
live
"
:
"
off
"
}
dom
.
textarea
(
{
className
:
"
jsterm
-
complete
-
node
devtools
-
monospace
"
key
:
"
complete
"
tabIndex
:
"
-
1
"
ref
:
node
=
>
{
this
.
completeNode
=
node
;
}
}
)
dom
.
textarea
(
{
className
:
"
jsterm
-
input
-
node
devtools
-
monospace
"
key
:
"
input
"
tabIndex
:
"
0
"
rows
:
"
1
"
"
aria
-
autocomplete
"
:
"
list
"
ref
:
node
=
>
{
this
.
inputNode
=
node
;
}
onPaste
:
onPaste
onDrop
:
onPaste
}
)
)
)
;
}
}
function
mapStateToProps
(
state
)
{
return
{
history
:
getHistory
(
state
)
getValueFromHistory
:
(
direction
)
=
>
getHistoryValue
(
state
direction
)
}
;
}
function
mapDispatchToProps
(
dispatch
)
{
return
{
appendToHistory
:
(
expr
)
=
>
dispatch
(
historyActions
.
appendToHistory
(
expr
)
)
clearHistory
:
(
)
=
>
dispatch
(
historyActions
.
clearHistory
(
)
)
updatePlaceHolder
:
(
direction
expression
)
=
>
dispatch
(
historyActions
.
updatePlaceHolder
(
direction
expression
)
)
}
;
}
module
.
exports
=
connect
(
mapStateToProps
mapDispatchToProps
)
(
JSTerm
)
;
