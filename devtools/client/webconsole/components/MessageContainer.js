"
use
strict
"
;
const
{
Component
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropTypes
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
loader
.
lazyRequireGetter
(
this
"
isWarningGroup
"
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
true
)
;
const
{
MESSAGE_SOURCE
MESSAGE_TYPE
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
componentMap
=
new
Map
(
[
[
"
ConsoleApiCall
"
require
(
"
.
/
message
-
types
/
ConsoleApiCall
"
)
]
[
"
ConsoleCommand
"
require
(
"
.
/
message
-
types
/
ConsoleCommand
"
)
]
[
"
CSSWarning
"
require
(
"
.
/
message
-
types
/
CSSWarning
"
)
]
[
"
DefaultRenderer
"
require
(
"
.
/
message
-
types
/
DefaultRenderer
"
)
]
[
"
EvaluationResult
"
require
(
"
.
/
message
-
types
/
EvaluationResult
"
)
]
[
"
NetworkEventMessage
"
require
(
"
.
/
message
-
types
/
NetworkEventMessage
"
)
]
[
"
PageError
"
require
(
"
.
/
message
-
types
/
PageError
"
)
]
[
"
WarningGroup
"
require
(
"
.
/
message
-
types
/
WarningGroup
"
)
]
]
)
;
class
MessageContainer
extends
Component
{
static
get
propTypes
(
)
{
return
{
messageId
:
PropTypes
.
string
.
isRequired
open
:
PropTypes
.
bool
.
isRequired
serviceContainer
:
PropTypes
.
object
.
isRequired
payload
:
PropTypes
.
object
tableData
:
PropTypes
.
object
timestampsVisible
:
PropTypes
.
bool
.
isRequired
repeat
:
PropTypes
.
number
badge
:
PropTypes
.
number
indent
:
PropTypes
.
number
networkMessageUpdate
:
PropTypes
.
object
getMessage
:
PropTypes
.
func
.
isRequired
isPaused
:
PropTypes
.
bool
.
isRequired
pausedExecutionPoint
:
PropTypes
.
any
inWarningGroup
:
PropTypes
.
bool
}
;
}
static
get
defaultProps
(
)
{
return
{
open
:
false
}
;
}
shouldComponentUpdate
(
nextProps
)
{
const
triggeringUpdateProps
=
[
"
repeat
"
"
open
"
"
payload
"
"
tableData
"
"
timestampsVisible
"
"
networkMessageUpdate
"
"
isPaused
"
"
pausedExecutionPoint
"
"
badge
"
"
inWarningGroup
"
]
;
return
triggeringUpdateProps
.
some
(
prop
=
>
this
.
props
[
prop
]
!
=
=
nextProps
[
prop
]
)
;
}
render
(
)
{
const
message
=
this
.
props
.
getMessage
(
)
;
const
MessageComponent
=
getMessageComponent
(
message
)
;
return
MessageComponent
(
Object
.
assign
(
{
message
}
this
.
props
)
)
;
}
}
function
getMessageComponent
(
message
)
{
if
(
!
message
)
{
return
componentMap
.
get
(
"
DefaultRenderer
"
)
;
}
switch
(
message
.
source
)
{
case
MESSAGE_SOURCE
.
CONSOLE_API
:
return
componentMap
.
get
(
"
ConsoleApiCall
"
)
;
case
MESSAGE_SOURCE
.
NETWORK
:
return
componentMap
.
get
(
"
NetworkEventMessage
"
)
;
case
MESSAGE_SOURCE
.
CSS
:
return
componentMap
.
get
(
"
CSSWarning
"
)
;
case
MESSAGE_SOURCE
.
JAVASCRIPT
:
switch
(
message
.
type
)
{
case
MESSAGE_TYPE
.
COMMAND
:
return
componentMap
.
get
(
"
ConsoleCommand
"
)
;
case
MESSAGE_TYPE
.
RESULT
:
return
componentMap
.
get
(
"
EvaluationResult
"
)
;
case
MESSAGE_TYPE
.
LOG
:
return
componentMap
.
get
(
"
PageError
"
)
;
default
:
return
componentMap
.
get
(
"
DefaultRenderer
"
)
;
}
case
MESSAGE_SOURCE
.
CONSOLE_FRONTEND
:
if
(
isWarningGroup
(
message
)
)
{
return
componentMap
.
get
(
"
WarningGroup
"
)
;
}
break
;
}
return
componentMap
.
get
(
"
DefaultRenderer
"
)
;
}
module
.
exports
.
MessageContainer
=
MessageContainer
;
module
.
exports
.
getMessageComponent
=
getMessageComponent
;
