"
use
strict
"
;
const
{
Component
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropTypes
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
MESSAGE_SOURCE
MESSAGE_TYPE
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
componentMap
=
new
Map
(
[
[
"
ConsoleApiCall
"
require
(
"
.
/
message
-
types
/
ConsoleApiCall
"
)
]
[
"
ConsoleCommand
"
require
(
"
.
/
message
-
types
/
ConsoleCommand
"
)
]
[
"
DefaultRenderer
"
require
(
"
.
/
message
-
types
/
DefaultRenderer
"
)
]
[
"
EvaluationResult
"
require
(
"
.
/
message
-
types
/
EvaluationResult
"
)
]
[
"
NetworkEventMessage
"
require
(
"
.
/
message
-
types
/
NetworkEventMessage
"
)
]
[
"
PageError
"
require
(
"
.
/
message
-
types
/
PageError
"
)
]
]
)
;
class
MessageContainer
extends
Component
{
static
get
propTypes
(
)
{
return
{
messageId
:
PropTypes
.
string
.
isRequired
open
:
PropTypes
.
bool
.
isRequired
serviceContainer
:
PropTypes
.
object
.
isRequired
tableData
:
PropTypes
.
object
timestampsVisible
:
PropTypes
.
bool
.
isRequired
repeat
:
PropTypes
.
number
networkMessageUpdate
:
PropTypes
.
object
getMessage
:
PropTypes
.
func
.
isRequired
isPaused
:
PropTypes
.
bool
.
isRequired
pausedExecutionPoint
:
PropTypes
.
any
}
;
}
static
get
defaultProps
(
)
{
return
{
open
:
false
}
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
const
repeatChanged
=
this
.
props
.
repeat
!
=
=
nextProps
.
repeat
;
const
openChanged
=
this
.
props
.
open
!
=
=
nextProps
.
open
;
const
tableDataChanged
=
this
.
props
.
tableData
!
=
=
nextProps
.
tableData
;
const
timestampVisibleChanged
=
this
.
props
.
timestampsVisible
!
=
=
nextProps
.
timestampsVisible
;
const
networkMessageUpdateChanged
=
this
.
props
.
networkMessageUpdate
!
=
=
nextProps
.
networkMessageUpdate
;
const
pausedChanged
=
this
.
props
.
isPaused
!
=
=
nextProps
.
isPaused
;
const
executionPointChanged
=
this
.
props
.
pausedExecutionPoint
!
=
=
nextProps
.
pausedExecutionPoint
;
return
repeatChanged
|
|
openChanged
|
|
tableDataChanged
|
|
timestampVisibleChanged
|
|
networkMessageUpdateChanged
|
|
pausedChanged
|
|
executionPointChanged
;
}
render
(
)
{
const
message
=
this
.
props
.
getMessage
(
)
;
const
MessageComponent
=
getMessageComponent
(
message
)
;
return
MessageComponent
(
Object
.
assign
(
{
message
}
this
.
props
)
)
;
}
}
function
getMessageComponent
(
message
)
{
if
(
!
message
)
{
return
componentMap
.
get
(
"
DefaultRenderer
"
)
;
}
switch
(
message
.
source
)
{
case
MESSAGE_SOURCE
.
CONSOLE_API
:
return
componentMap
.
get
(
"
ConsoleApiCall
"
)
;
case
MESSAGE_SOURCE
.
NETWORK
:
return
componentMap
.
get
(
"
NetworkEventMessage
"
)
;
case
MESSAGE_SOURCE
.
CSS
:
case
MESSAGE_SOURCE
.
JAVASCRIPT
:
switch
(
message
.
type
)
{
case
MESSAGE_TYPE
.
COMMAND
:
return
componentMap
.
get
(
"
ConsoleCommand
"
)
;
case
MESSAGE_TYPE
.
RESULT
:
return
componentMap
.
get
(
"
EvaluationResult
"
)
;
case
MESSAGE_TYPE
.
LOG
:
return
componentMap
.
get
(
"
PageError
"
)
;
default
:
return
componentMap
.
get
(
"
DefaultRenderer
"
)
;
}
}
return
componentMap
.
get
(
"
DefaultRenderer
"
)
;
}
module
.
exports
.
MessageContainer
=
MessageContainer
;
module
.
exports
.
getMessageComponent
=
getMessageComponent
;
