"
use
strict
"
;
const
{
createFactory
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
.
js
"
)
;
const
PropTypes
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
.
js
"
)
;
const
dom
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
.
js
"
)
;
const
GripMessageBody
=
require
(
"
resource
:
/
/
devtools
/
client
/
webconsole
/
components
/
Output
/
GripMessageBody
.
js
"
)
;
const
{
MESSAGE_TYPE
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
webconsole
/
constants
.
js
"
)
;
const
Message
=
createFactory
(
require
(
"
resource
:
/
/
devtools
/
client
/
webconsole
/
components
/
Output
/
Message
.
js
"
)
)
;
JSTracerTrace
.
displayName
=
"
JSTracerTrace
"
;
JSTracerTrace
.
propTypes
=
{
dispatch
:
PropTypes
.
func
.
isRequired
message
:
PropTypes
.
object
.
isRequired
serviceContainer
:
PropTypes
.
object
.
isRequired
timestampsVisible
:
PropTypes
.
bool
.
isRequired
maybeScrollToBottom
:
PropTypes
.
func
}
;
function
JSTracerTrace
(
props
)
{
const
{
dispatch
message
serviceContainer
timestampsVisible
repeat
maybeScrollToBottom
setExpanded
}
=
props
;
const
{
timeStamp
prefix
depth
source
eventName
frame
implementation
displayName
parameters
returnedValue
relatedTraceId
why
mutationType
mutationElement
}
=
message
;
let
messageBodyConfig
;
if
(
parameters
|
|
why
|
|
mutationType
)
{
messageBodyConfig
=
{
dispatch
serviceContainer
maybeScrollToBottom
setExpanded
type
:
"
"
useQuotes
:
true
customFormat
:
false
}
;
}
let
messageBody
;
if
(
eventName
)
{
messageBody
=
[
dom
.
span
(
{
className
:
"
jstracer
-
dom
-
event
"
}
DOM
|
{
eventName
}
)
]
;
}
else
if
(
typeof
relatedTraceId
=
=
"
number
"
)
{
messageBody
=
[
dom
.
span
(
{
className
:
"
jstracer
-
io
"
}
"
"
)
dom
.
span
(
{
className
:
"
jstracer
-
display
-
name
"
}
displayName
)
]
;
}
else
if
(
mutationType
)
{
messageBody
=
[
dom
.
span
(
{
className
:
"
jstracer
-
dom
-
mutation
"
}
"
DOM
Mutation
|
"
+
mutationType
+
"
"
)
formatRep
(
messageBodyConfig
mutationElement
)
]
;
}
else
if
(
displayName
)
{
messageBody
=
[
dom
.
span
(
{
className
:
"
jstracer
-
io
"
}
"
"
)
dom
.
span
(
{
className
:
"
jstracer
-
implementation
"
}
implementation
)
dom
.
span
(
{
className
:
"
jstracer
-
display
-
name
"
}
"
"
+
displayName
)
]
;
}
else
{
messageBody
=
[
dom
.
span
(
{
className
:
"
jstracer
-
io
"
}
"
"
)
]
;
}
if
(
parameters
)
{
messageBody
.
push
(
"
(
"
.
.
.
formatReps
(
messageBodyConfig
parameters
)
"
)
"
)
;
}
if
(
why
)
{
messageBody
.
push
(
dom
.
span
(
{
className
:
"
jstracer
-
exit
-
frame
-
reason
"
}
"
"
+
why
+
"
"
)
)
;
if
(
returnedValue
!
=
=
undefined
)
{
messageBody
.
push
(
formatRep
(
messageBodyConfig
returnedValue
)
)
;
}
}
if
(
prefix
)
{
messageBody
.
unshift
(
dom
.
span
(
{
className
:
"
console
-
message
-
prefix
"
}
{
prefix
}
)
)
;
}
const
topLevelClasses
=
[
"
cm
-
s
-
mozilla
"
]
;
return
Message
(
{
collapsible
:
false
source
level
:
MESSAGE_TYPE
.
JSTRACER
topLevelClasses
messageBody
repeat
frame
stacktrace
:
null
attachment
:
null
serviceContainer
dispatch
indent
:
depth
timeStamp
timestampsVisible
parameters
message
maybeScrollToBottom
}
)
;
}
function
formatReps
(
messageBodyConfig
objects
)
{
const
elements
=
[
]
;
const
length
=
objects
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
elements
.
push
(
formatRep
(
messageBodyConfig
objects
[
i
]
i
)
)
;
if
(
i
!
=
=
length
-
1
)
{
elements
.
push
(
"
"
)
;
}
}
return
elements
;
}
function
formatRep
(
messageBodyConfig
grip
key
)
{
return
GripMessageBody
(
{
.
.
.
messageBodyConfig
grip
key
}
)
;
}
module
.
exports
=
JSTracerTrace
;
