"
use
strict
"
;
const
{
Component
createElement
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
redux
/
visibility
-
handler
-
connect
"
)
;
const
{
initialize
}
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
ui
"
)
;
const
{
getMutableMessagesById
getAllMessagesUiById
getAllCssMessagesMatchingElements
getAllNetworkMessagesUpdateById
getVisibleMessages
getAllRepeatById
getAllWarningGroupsById
isMessageInWarningGroup
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
messages
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropTypes
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
loader
.
lazyRequireGetter
(
this
"
MessageContainer
"
"
devtools
/
client
/
webconsole
/
components
/
Output
/
MessageContainer
"
true
)
;
const
{
MESSAGE_TYPE
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
{
getInitialMessageCountForViewport
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
messages
.
js
"
)
;
class
ConsoleOutput
extends
Component
{
static
get
propTypes
(
)
{
return
{
initialized
:
PropTypes
.
bool
.
isRequired
mutableMessages
:
PropTypes
.
object
.
isRequired
messageCount
:
PropTypes
.
number
.
isRequired
messagesUi
:
PropTypes
.
array
.
isRequired
serviceContainer
:
PropTypes
.
shape
(
{
attachRefToWebConsoleUI
:
PropTypes
.
func
.
isRequired
openContextMenu
:
PropTypes
.
func
.
isRequired
sourceMapURLService
:
PropTypes
.
object
}
)
dispatch
:
PropTypes
.
func
.
isRequired
timestampsVisible
:
PropTypes
.
bool
cssMatchingElements
:
PropTypes
.
object
.
isRequired
messagesRepeat
:
PropTypes
.
object
.
isRequired
warningGroups
:
PropTypes
.
object
.
isRequired
networkMessagesUpdate
:
PropTypes
.
object
.
isRequired
visibleMessages
:
PropTypes
.
array
.
isRequired
networkMessageActiveTabId
:
PropTypes
.
string
.
isRequired
onFirstMeaningfulPaint
:
PropTypes
.
func
.
isRequired
editorMode
:
PropTypes
.
bool
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
onContextMenu
=
this
.
onContextMenu
.
bind
(
this
)
;
this
.
maybeScrollToBottom
=
this
.
maybeScrollToBottom
.
bind
(
this
)
;
this
.
resizeObserver
=
new
ResizeObserver
(
entries
=
>
{
if
(
!
this
.
outputNode
|
|
!
this
.
outputNode
.
isConnected
)
{
this
.
resizeObserver
.
disconnect
(
)
;
return
;
}
if
(
this
.
scrolledToBottom
)
{
this
.
scrollToBottom
(
)
;
}
}
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
visibleMessages
.
length
>
0
)
{
this
.
scrollToBottom
(
)
;
}
this
.
lastMessageIntersectionObserver
=
new
IntersectionObserver
(
entries
=
>
{
for
(
const
entry
of
entries
)
{
this
.
scrolledToBottom
=
entry
.
intersectionRatio
>
0
;
}
}
{
root
:
this
.
outputNode
rootMargin
:
"
10px
"
}
)
;
this
.
resizeObserver
.
observe
(
this
.
getElementToObserve
(
)
)
;
const
{
serviceContainer
onFirstMeaningfulPaint
dispatch
}
=
this
.
props
;
serviceContainer
.
attachRefToWebConsoleUI
(
"
outputScroller
"
this
.
outputNode
)
;
new
Promise
(
res
=
>
requestAnimationFrame
(
res
)
)
.
then
(
(
)
=
>
{
if
(
onFirstMeaningfulPaint
)
{
onFirstMeaningfulPaint
(
)
;
}
setTimeout
(
(
)
=
>
{
dispatch
(
initialize
(
)
)
;
}
0
)
;
}
)
;
}
componentWillUpdate
(
nextProps
nextState
)
{
if
(
nextProps
.
editorMode
!
=
=
this
.
props
.
editorMode
)
{
this
.
resizeObserver
.
disconnect
(
)
;
}
const
{
outputNode
}
=
this
;
if
(
!
outputNode
?
.
lastChild
)
{
this
.
shouldScrollBottom
=
true
;
return
;
}
const
{
lastChild
}
=
outputNode
;
this
.
lastMessageIntersectionObserver
.
unobserve
(
lastChild
)
;
const
visibleMessagesDelta
=
nextProps
.
visibleMessages
.
length
-
this
.
props
.
visibleMessages
.
length
;
const
messagesDelta
=
nextProps
.
messageCount
-
this
.
props
.
messageCount
;
const
isNewMessageEvaluationResult
=
messagesDelta
>
0
&
&
nextProps
.
mutableMessages
.
get
(
nextProps
.
visibleMessages
.
at
(
-
1
)
)
?
.
type
=
=
=
MESSAGE_TYPE
.
RESULT
;
const
messagesUiDelta
=
nextProps
.
messagesUi
.
length
-
this
.
props
.
messagesUi
.
length
;
const
isOpeningGroup
=
messagesUiDelta
>
0
&
&
nextProps
.
messagesUi
.
some
(
id
=
>
!
this
.
props
.
messagesUi
.
includes
(
id
)
&
&
nextProps
.
messagesUi
.
includes
(
id
)
&
&
this
.
props
.
visibleMessages
.
includes
(
id
)
&
&
nextProps
.
visibleMessages
.
includes
(
id
)
)
;
this
.
shouldScrollBottom
=
(
!
this
.
props
.
initialized
&
&
nextProps
.
initialized
&
&
this
.
scrolledToBottom
)
|
|
isNewMessageEvaluationResult
|
|
(
this
.
scrolledToBottom
&
&
visibleMessagesDelta
>
0
&
&
!
isOpeningGroup
)
;
}
componentDidUpdate
(
prevProps
)
{
this
.
maybeScrollToBottom
(
)
;
if
(
this
?
.
outputNode
?
.
lastChild
)
{
this
.
lastMessageIntersectionObserver
.
observe
(
this
.
outputNode
.
lastChild
)
;
}
if
(
prevProps
.
editorMode
!
=
=
this
.
props
.
editorMode
)
{
this
.
resizeObserver
.
observe
(
this
.
getElementToObserve
(
)
)
;
}
}
maybeScrollToBottom
(
)
{
if
(
this
.
outputNode
&
&
this
.
shouldScrollBottom
)
{
this
.
scrollToBottom
(
)
;
}
}
scrollToBottom
(
)
{
if
(
this
.
outputNode
.
scrollHeight
>
this
.
outputNode
.
clientHeight
)
{
this
.
outputNode
.
scrollTop
=
this
.
outputNode
.
scrollHeight
;
}
this
.
scrolledToBottom
=
true
;
}
getElementToObserve
(
)
{
return
this
.
props
.
editorMode
?
this
.
outputNode
:
this
.
outputNode
?
.
parentNode
;
}
onContextMenu
(
e
)
{
this
.
props
.
serviceContainer
.
openContextMenu
(
e
)
;
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
}
render
(
)
{
let
{
dispatch
visibleMessages
mutableMessages
messagesUi
cssMatchingElements
messagesRepeat
warningGroups
networkMessagesUpdate
networkMessageActiveTabId
serviceContainer
timestampsVisible
initialized
}
=
this
.
props
;
if
(
!
initialized
)
{
const
numberMessagesFitViewport
=
getInitialMessageCountForViewport
(
window
)
;
if
(
numberMessagesFitViewport
<
visibleMessages
.
length
)
{
visibleMessages
=
visibleMessages
.
slice
(
visibleMessages
.
length
-
numberMessagesFitViewport
)
;
}
}
const
messageNodes
=
visibleMessages
.
map
(
messageId
=
>
createElement
(
MessageContainer
{
dispatch
key
:
messageId
messageId
serviceContainer
open
:
messagesUi
.
includes
(
messageId
)
cssMatchingElements
:
cssMatchingElements
.
get
(
messageId
)
timestampsVisible
repeat
:
messagesRepeat
[
messageId
]
badge
:
warningGroups
.
has
(
messageId
)
?
warningGroups
.
get
(
messageId
)
.
length
:
null
inWarningGroup
:
warningGroups
&
&
warningGroups
.
size
>
0
?
isMessageInWarningGroup
(
mutableMessages
.
get
(
messageId
)
visibleMessages
)
:
false
networkMessageUpdate
:
networkMessagesUpdate
[
messageId
]
networkMessageActiveTabId
getMessage
:
(
)
=
>
mutableMessages
.
get
(
messageId
)
maybeScrollToBottom
:
this
.
maybeScrollToBottom
}
)
)
;
return
dom
.
div
(
{
className
:
"
webconsole
-
output
"
role
:
"
main
"
onContextMenu
:
this
.
onContextMenu
ref
:
node
=
>
{
this
.
outputNode
=
node
;
}
}
messageNodes
)
;
}
}
function
mapStateToProps
(
state
props
)
{
const
mutableMessages
=
getMutableMessagesById
(
state
)
;
return
{
initialized
:
state
.
ui
.
initialized
messageCount
:
mutableMessages
.
size
mutableMessages
visibleMessages
:
getVisibleMessages
(
state
)
messagesUi
:
getAllMessagesUiById
(
state
)
cssMatchingElements
:
getAllCssMessagesMatchingElements
(
state
)
messagesRepeat
:
getAllRepeatById
(
state
)
warningGroups
:
getAllWarningGroupsById
(
state
)
networkMessagesUpdate
:
getAllNetworkMessagesUpdateById
(
state
)
timestampsVisible
:
state
.
ui
.
timestampsVisible
networkMessageActiveTabId
:
state
.
ui
.
networkMessageActiveTabId
}
;
}
module
.
exports
=
connect
(
mapStateToProps
)
(
ConsoleOutput
)
;
