"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
debounce
}
=
require
(
"
devtools
/
shared
/
debounce
"
)
;
const
isMacOS
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
loader
.
lazyRequireGetter
(
this
"
Debugger
"
"
Debugger
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropTypes
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyCodes
"
"
devtools
/
client
/
shared
/
keycodes
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Editor
"
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
)
;
loader
.
lazyRequireGetter
(
this
"
getFocusableElements
"
"
devtools
/
client
/
shared
/
focus
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
l10n
"
"
devtools
/
client
/
webconsole
/
utils
/
messages
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
saveAs
"
"
devtools
/
shared
/
DevToolsUtils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
beautify
"
"
devtools
/
shared
/
jsbeautify
/
beautify
"
)
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
{
getHistory
getHistoryValue
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
history
"
)
;
const
{
getAutocompleteState
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
autocomplete
"
)
;
const
actions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
const
EvaluationContextSelector
=
createFactory
(
require
(
"
devtools
/
client
/
webconsole
/
components
/
Input
/
EvaluationContextSelector
"
)
)
;
const
{
HISTORY_BACK
HISTORY_FORWARD
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
JSTERM_CODEMIRROR_ORIGIN
=
"
jsterm
"
;
class
JSTerm
extends
Component
{
static
get
propTypes
(
)
{
return
{
getValueFromHistory
:
PropTypes
.
func
.
isRequired
history
:
PropTypes
.
object
.
isRequired
webConsoleUI
:
PropTypes
.
object
.
isRequired
serviceContainer
:
PropTypes
.
object
.
isRequired
onPaste
:
PropTypes
.
func
evaluateExpression
:
PropTypes
.
func
.
isRequired
updateHistoryPosition
:
PropTypes
.
func
.
isRequired
autocompleteUpdate
:
PropTypes
.
func
.
isRequired
autocompleteClear
:
PropTypes
.
func
.
isRequired
autocompleteData
:
PropTypes
.
object
.
isRequired
editorToggle
:
PropTypes
.
func
.
isRequired
editorOnboardingDismiss
:
PropTypes
.
func
.
isRequired
terminalInputChanged
:
PropTypes
.
func
.
isRequired
editorMode
:
PropTypes
.
bool
editorWidth
:
PropTypes
.
number
editorPrettifiedAt
:
PropTypes
.
number
showEditorOnboarding
:
PropTypes
.
bool
autocomplete
:
PropTypes
.
bool
showEvaluationContextSelector
:
PropTypes
.
bool
autocompletePopupPosition
:
PropTypes
.
string
inputEnabled
:
PropTypes
.
bool
}
;
}
constructor
(
props
)
{
super
(
props
)
;
const
{
webConsoleUI
}
=
props
;
this
.
webConsoleUI
=
webConsoleUI
;
this
.
hudId
=
this
.
webConsoleUI
.
hudId
;
this
.
_onEditorChanges
=
this
.
_onEditorChanges
.
bind
(
this
)
;
this
.
_onEditorBeforeChange
=
this
.
_onEditorBeforeChange
.
bind
(
this
)
;
this
.
_onEditorKeyHandled
=
this
.
_onEditorKeyHandled
.
bind
(
this
)
;
this
.
onContextMenu
=
this
.
onContextMenu
.
bind
(
this
)
;
this
.
imperativeUpdate
=
this
.
imperativeUpdate
.
bind
(
this
)
;
this
.
autocompleteUpdate
=
debounce
(
this
.
props
.
autocompleteUpdate
75
this
)
;
this
.
terminalInputChanged
=
debounce
(
this
.
props
.
terminalInputChanged
75
this
)
;
this
.
pendingCompletionText
=
null
;
this
.
lastInputValue
=
"
"
;
this
.
autocompletePopup
=
null
;
EventEmitter
.
decorate
(
this
)
;
webConsoleUI
.
jsterm
=
this
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
editorMode
)
{
this
.
setEditorWidth
(
this
.
props
.
editorWidth
)
;
}
const
autocompleteOptions
=
{
onSelect
:
this
.
onAutocompleteSelect
.
bind
(
this
)
onClick
:
this
.
acceptProposedCompletion
.
bind
(
this
)
listId
:
"
webConsole_autocompletePopupListBox
"
position
:
this
.
props
.
autocompletePopupPosition
autoSelect
:
true
useXulWrapper
:
true
}
;
const
doc
=
this
.
webConsoleUI
.
document
;
const
{
toolbox
}
=
this
.
webConsoleUI
.
wrapper
;
const
tooltipDoc
=
toolbox
?
toolbox
.
doc
:
doc
;
this
.
autocompletePopup
=
new
AutocompletePopup
(
tooltipDoc
autocompleteOptions
)
;
if
(
this
.
node
)
{
const
onArrowUp
=
(
)
=
>
{
let
inputUpdated
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectPreviousItem
(
)
;
return
null
;
}
if
(
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
return
inputUpdated
?
null
:
"
CodeMirror
.
Pass
"
;
}
;
const
onArrowDown
=
(
)
=
>
{
let
inputUpdated
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectNextItem
(
)
;
return
null
;
}
if
(
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
return
inputUpdated
?
null
:
"
CodeMirror
.
Pass
"
;
}
;
const
onArrowLeft
=
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
return
"
CodeMirror
.
Pass
"
;
}
;
const
onArrowRight
=
(
)
=
>
{
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
;
const
onCtrlCmdEnter
=
(
)
=
>
{
if
(
this
.
hasAutocompletionSuggestion
(
)
)
{
return
this
.
acceptProposedCompletion
(
)
;
}
this
.
_execute
(
)
;
return
null
;
}
;
this
.
editor
=
new
Editor
(
{
autofocus
:
true
enableCodeFolding
:
this
.
props
.
editorMode
lineNumbers
:
this
.
props
.
editorMode
lineWrapping
:
true
mode
:
{
name
:
"
javascript
"
globalVars
:
true
}
styleActiveLine
:
false
tabIndex
:
"
0
"
viewportMargin
:
Infinity
disableSearchAddon
:
true
extraKeys
:
{
Enter
:
(
)
=
>
{
const
hasSuggestion
=
this
.
hasAutocompletionSuggestion
(
)
;
if
(
!
hasSuggestion
&
&
!
Debugger
.
isCompilableUnit
(
this
.
_getValue
(
)
)
)
{
return
"
CodeMirror
.
Pass
"
;
}
if
(
hasSuggestion
)
{
return
this
.
acceptProposedCompletion
(
)
;
}
if
(
!
this
.
props
.
editorMode
)
{
this
.
_execute
(
)
;
return
null
;
}
return
"
CodeMirror
.
Pass
"
;
}
"
Cmd
-
Enter
"
:
onCtrlCmdEnter
"
Ctrl
-
Enter
"
:
onCtrlCmdEnter
[
Editor
.
accel
(
"
S
"
)
]
:
(
)
=
>
{
const
value
=
this
.
_getValue
(
)
;
if
(
!
value
)
{
return
null
;
}
const
date
=
new
Date
(
)
;
const
suggestedName
=
console
-
input
-
{
date
.
getFullYear
(
)
}
-
+
{
date
.
getMonth
(
)
+
1
}
-
{
date
.
getDate
(
)
}
_
{
date
.
getHours
(
)
}
-
+
{
date
.
getMinutes
(
)
}
-
{
date
.
getSeconds
(
)
}
.
js
;
const
data
=
new
TextEncoder
(
)
.
encode
(
value
)
;
return
saveAs
(
window
data
suggestedName
[
{
pattern
:
"
*
.
js
"
label
:
l10n
.
getStr
(
"
webconsole
.
input
.
openJavaScriptFileFilter
"
)
}
]
)
;
}
[
Editor
.
accel
(
"
O
"
)
]
:
async
(
)
=
>
this
.
_openFile
(
)
Tab
:
(
)
=
>
{
if
(
this
.
hasEmptyInput
(
)
)
{
this
.
editor
.
codeMirror
.
getInputField
(
)
.
blur
(
)
;
return
false
;
}
if
(
this
.
props
.
autocompleteData
&
&
this
.
props
.
autocompleteData
.
getterPath
)
{
this
.
props
.
autocompleteUpdate
(
true
this
.
props
.
autocompleteData
.
getterPath
)
;
return
false
;
}
const
isSomethingSelected
=
this
.
editor
.
somethingSelected
(
)
;
const
hasSuggestion
=
this
.
hasAutocompletionSuggestion
(
)
;
if
(
hasSuggestion
&
&
!
isSomethingSelected
)
{
this
.
acceptProposedCompletion
(
)
;
return
false
;
}
if
(
!
isSomethingSelected
)
{
this
.
insertStringAtCursor
(
"
\
t
"
)
;
return
false
;
}
return
true
;
}
"
Shift
-
Tab
"
:
(
)
=
>
{
if
(
this
.
hasEmptyInput
(
)
)
{
this
.
focusPreviousElement
(
)
;
return
false
;
}
const
hasSuggestion
=
this
.
hasAutocompletionSuggestion
(
)
;
if
(
hasSuggestion
)
{
return
false
;
}
return
"
CodeMirror
.
Pass
"
;
}
Up
:
onArrowUp
"
Cmd
-
Up
"
:
onArrowUp
Down
:
onArrowDown
"
Cmd
-
Down
"
:
onArrowDown
Left
:
onArrowLeft
"
Ctrl
-
Left
"
:
onArrowLeft
"
Cmd
-
Left
"
:
onArrowLeft
"
Alt
-
Left
"
:
onArrowLeft
"
Ctrl
-
A
"
:
isMacOS
?
onArrowLeft
:
undefined
Right
:
onArrowRight
"
Ctrl
-
Right
"
:
onArrowRight
"
Cmd
-
Right
"
:
onArrowRight
"
Alt
-
Right
"
:
onArrowRight
"
Ctrl
-
N
"
:
(
)
=
>
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
&
&
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
"
Ctrl
-
P
"
:
(
)
=
>
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
&
&
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
PageUp
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectPreviousPageItem
(
)
;
}
else
{
const
{
outputScroller
}
=
this
.
webConsoleUI
;
const
{
scrollTop
clientHeight
}
=
outputScroller
;
outputScroller
.
scrollTop
=
Math
.
max
(
0
scrollTop
-
clientHeight
)
;
}
return
null
;
}
PageDown
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectNextPageItem
(
)
;
}
else
{
const
{
outputScroller
}
=
this
.
webConsoleUI
;
const
{
scrollTop
scrollHeight
clientHeight
}
=
outputScroller
;
outputScroller
.
scrollTop
=
Math
.
min
(
scrollHeight
scrollTop
+
clientHeight
)
;
}
return
null
;
}
Home
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectItemAtIndex
(
0
)
;
return
null
;
}
if
(
!
this
.
_getValue
(
)
)
{
this
.
webConsoleUI
.
outputScroller
.
scrollTop
=
0
;
return
null
;
}
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
return
"
CodeMirror
.
Pass
"
;
}
End
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectItemAtIndex
(
this
.
autocompletePopup
.
itemCount
-
1
)
;
return
null
;
}
if
(
!
this
.
_getValue
(
)
)
{
const
{
outputScroller
}
=
this
.
webConsoleUI
;
outputScroller
.
scrollTop
=
outputScroller
.
scrollHeight
;
return
null
;
}
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
return
"
CodeMirror
.
Pass
"
;
}
"
Ctrl
-
Space
"
:
(
)
=
>
{
if
(
!
this
.
autocompletePopup
.
isOpen
)
{
this
.
props
.
autocompleteUpdate
(
true
null
this
.
_getExpressionVariables
(
)
)
;
return
null
;
}
return
"
CodeMirror
.
Pass
"
;
}
Esc
:
false
[
Editor
.
accel
(
"
F
"
)
]
:
false
}
}
)
;
this
.
editor
.
on
(
"
changes
"
this
.
_onEditorChanges
)
;
this
.
editor
.
on
(
"
beforeChange
"
this
.
_onEditorBeforeChange
)
;
this
.
editor
.
on
(
"
blur
"
this
.
_onEditorBlur
)
;
this
.
editor
.
on
(
"
keyHandled
"
this
.
_onEditorKeyHandled
)
;
this
.
editor
.
appendToLocalElement
(
this
.
node
)
;
const
cm
=
this
.
editor
.
codeMirror
;
cm
.
on
(
"
paste
"
(
_
event
)
=
>
this
.
props
.
onPaste
(
event
)
)
;
cm
.
on
(
"
drop
"
(
_
event
)
=
>
this
.
props
.
onPaste
(
event
)
)
;
this
.
node
.
addEventListener
(
"
keydown
"
event
=
>
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
if
(
this
.
props
.
autocompleteData
&
&
this
.
props
.
autocompleteData
.
getterPath
)
{
this
.
props
.
autocompleteClear
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
}
)
;
this
.
resizeObserver
=
new
ResizeObserver
(
(
)
=
>
{
if
(
!
this
.
node
|
|
!
this
.
node
.
isConnected
)
{
this
.
resizeObserver
.
disconnect
(
)
;
return
;
}
this
.
editor
.
codeMirror
.
refresh
(
)
;
}
)
;
this
.
resizeObserver
.
observe
(
this
.
node
)
;
this
.
_inputCharWidth
=
this
.
_getInputCharWidth
(
)
;
this
.
lastInputValue
&
&
this
.
_setValue
(
this
.
lastInputValue
)
;
}
}
UNSAFE_componentWillReceiveProps
(
nextProps
)
{
this
.
imperativeUpdate
(
nextProps
)
;
}
shouldComponentUpdate
(
nextProps
)
{
return
(
this
.
props
.
showEditorOnboarding
!
=
=
nextProps
.
showEditorOnboarding
|
|
this
.
props
.
editorMode
!
=
=
nextProps
.
editorMode
)
;
}
imperativeUpdate
(
nextProps
)
{
if
(
!
nextProps
)
{
return
;
}
if
(
nextProps
.
autocompleteData
!
=
=
this
.
props
.
autocompleteData
&
&
nextProps
.
autocompleteData
.
pendingRequestId
=
=
=
null
)
{
this
.
updateAutocompletionPopup
(
nextProps
.
autocompleteData
)
;
}
if
(
nextProps
.
editorMode
!
=
=
this
.
props
.
editorMode
)
{
if
(
this
.
editor
)
{
this
.
editor
.
setOption
(
"
lineNumbers
"
nextProps
.
editorMode
)
;
this
.
editor
.
setOption
(
"
enableCodeFolding
"
nextProps
.
editorMode
)
;
}
if
(
nextProps
.
editorMode
&
&
nextProps
.
editorWidth
)
{
this
.
setEditorWidth
(
nextProps
.
editorWidth
)
;
}
else
{
this
.
setEditorWidth
(
null
)
;
}
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
hidePopup
(
)
;
}
}
if
(
nextProps
.
autocompletePopupPosition
!
=
=
this
.
props
.
autocompletePopupPosition
&
&
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
position
=
nextProps
.
autocompletePopupPosition
;
}
if
(
nextProps
.
editorPrettifiedAt
&
&
nextProps
.
editorPrettifiedAt
!
=
=
this
.
props
.
editorPrettifiedAt
)
{
this
.
_setValue
(
beautify
.
js
(
this
.
_getValue
(
)
{
indent_size
:
Services
.
prefs
.
getIntPref
(
"
devtools
.
editor
.
tabsize
"
)
indent_with_tabs
:
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
editor
.
expandtab
"
)
}
)
)
;
}
}
setEditorWidth
(
editorWidth
)
{
if
(
!
this
.
node
)
{
return
;
}
if
(
editorWidth
)
{
this
.
node
.
style
.
width
=
{
editorWidth
}
px
;
}
else
{
this
.
node
.
style
.
removeProperty
(
"
width
"
)
;
}
}
focus
(
)
{
if
(
this
.
editor
)
{
this
.
editor
.
focus
(
)
;
}
}
focusPreviousElement
(
)
{
const
inputField
=
this
.
editor
.
codeMirror
.
getInputField
(
)
;
const
findPreviousFocusableElement
=
el
=
>
{
if
(
!
el
|
|
!
el
.
querySelectorAll
)
{
return
null
;
}
const
items
=
getFocusableElements
(
el
)
.
filter
(
(
{
offsetParent
}
)
=
>
offsetParent
!
=
=
null
)
;
const
inputIndex
=
items
.
indexOf
(
inputField
)
;
if
(
items
.
length
=
=
=
0
|
|
(
inputIndex
>
-
1
&
&
items
.
length
=
=
=
1
)
)
{
return
findPreviousFocusableElement
(
el
.
parentNode
)
;
}
const
index
=
inputIndex
>
0
?
inputIndex
-
1
:
items
.
length
-
1
;
return
items
[
index
]
;
}
;
const
focusableEl
=
findPreviousFocusableElement
(
this
.
node
.
parentNode
)
;
if
(
focusableEl
)
{
focusableEl
.
focus
(
)
;
}
}
_execute
(
)
{
const
value
=
this
.
_getValue
(
)
;
const
executeString
=
this
.
props
.
editorMode
?
this
.
getSelectedText
(
)
|
|
value
:
value
;
if
(
!
executeString
)
{
return
;
}
if
(
!
this
.
props
.
editorMode
)
{
this
.
props
.
terminalInputChanged
(
"
"
)
;
this
.
_setValue
(
"
"
)
;
}
this
.
clearCompletion
(
)
;
this
.
props
.
evaluateExpression
(
executeString
)
;
}
_setValue
(
newValue
=
"
"
)
{
this
.
lastInputValue
=
newValue
;
this
.
terminalInputChanged
(
newValue
)
;
if
(
this
.
editor
)
{
this
.
editor
.
codeMirror
.
operation
(
(
)
=
>
{
this
.
editor
.
setText
(
newValue
)
;
const
lines
=
newValue
.
split
(
"
\
n
"
)
;
this
.
editor
.
setCursor
(
{
line
:
lines
.
length
-
1
ch
:
lines
[
lines
.
length
-
1
]
.
length
}
)
;
this
.
editor
.
setAutoCompletionText
(
)
;
}
)
;
}
this
.
emitForTests
(
"
set
-
input
-
value
"
)
;
}
_getValue
(
)
{
return
this
.
editor
?
this
.
editor
.
getText
(
)
|
|
"
"
:
"
"
;
}
async
_openFile
(
)
{
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
this
.
webConsoleUI
.
document
.
defaultView
l10n
.
getStr
(
"
webconsole
.
input
.
openJavaScriptFile
"
)
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
appendFilter
(
l10n
.
getStr
(
"
webconsole
.
input
.
openJavaScriptFileFilter
"
)
"
*
.
js
"
)
;
function
readFile
(
file
)
{
return
new
Promise
(
resolve
=
>
{
IOUtils
.
read
(
file
.
path
)
.
then
(
data
=
>
{
const
decoder
=
new
TextDecoder
(
)
;
resolve
(
decoder
.
decode
(
data
)
)
;
}
)
;
}
)
;
}
const
content
=
await
new
Promise
(
resolve
=
>
{
fp
.
open
(
rv
=
>
{
if
(
rv
=
=
Ci
.
nsIFilePicker
.
returnOK
)
{
const
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
fp
.
file
.
path
)
;
readFile
(
file
)
.
then
(
resolve
)
;
}
}
)
;
}
)
;
this
.
_setValue
(
content
)
;
}
getSelectionStart
(
)
{
return
this
.
getInputValueBeforeCursor
(
)
.
length
;
}
getSelectedText
(
)
{
return
this
.
editor
.
getSelection
(
)
;
}
_onEditorBeforeChange
(
cm
change
)
{
const
{
from
to
origin
text
}
=
change
;
const
isAddedText
=
from
.
line
=
=
=
to
.
line
&
&
from
.
ch
=
=
=
to
.
ch
&
&
origin
=
=
=
"
+
input
"
;
if
(
!
isAddedText
&
&
origin
=
=
=
"
+
delete
"
&
&
from
.
line
=
=
=
to
.
line
&
&
from
.
ch
=
=
=
to
.
ch
)
{
return
;
}
const
addedText
=
text
.
join
(
"
"
)
;
const
completionText
=
this
.
getAutoCompletionText
(
)
;
const
addedCharacterMatchCompletion
=
isAddedText
&
&
completionText
.
startsWith
(
addedText
)
;
const
addedCharacterMatchPopupItem
=
isAddedText
&
&
this
.
autocompletePopup
.
items
.
some
(
(
{
preLabel
label
}
)
=
>
label
.
startsWith
(
preLabel
+
addedText
)
)
;
const
nextSelectedAutocompleteItemIndex
=
addedCharacterMatchPopupItem
&
&
this
.
autocompletePopup
.
items
.
findIndex
(
(
{
preLabel
label
}
)
=
>
label
.
startsWith
(
preLabel
+
addedText
)
)
;
if
(
addedCharacterMatchPopupItem
)
{
this
.
autocompletePopup
.
selectItemAtIndex
(
nextSelectedAutocompleteItemIndex
{
preventSelectCallback
:
true
}
)
;
}
if
(
!
completionText
|
|
change
.
canceled
|
|
!
addedCharacterMatchCompletion
)
{
this
.
setAutoCompletionText
(
"
"
)
;
}
if
(
!
addedCharacterMatchCompletion
&
&
!
addedCharacterMatchPopupItem
)
{
this
.
autocompletePopup
.
hidePopup
(
)
;
}
else
if
(
!
change
.
canceled
&
&
(
completionText
|
|
addedCharacterMatchCompletion
|
|
addedCharacterMatchPopupItem
)
)
{
this
.
pendingCompletionText
=
completionText
.
substring
(
text
.
length
)
;
this
.
autocompletePopup
.
items
.
forEach
(
item
=
>
{
if
(
item
.
label
.
startsWith
(
item
.
preLabel
+
addedText
)
)
{
item
.
preLabel
+
=
addedText
;
}
}
)
;
}
}
_onEditorBlur
(
cm
)
{
if
(
cm
.
somethingSelected
(
)
)
{
const
[
{
head
}
]
=
cm
.
listSelections
(
)
;
cm
.
setCursor
(
head
{
scroll
:
false
}
)
;
}
}
_onEditorKeyHandled
(
cm
key
e
)
{
const
closingKeys
=
[
'
]
'
'
)
'
"
'
}
'
"
]
;
if
(
this
.
autocompletePopup
.
isOpen
&
&
closingKeys
.
includes
(
key
)
)
{
this
.
clearCompletion
(
)
;
}
}
_getExpressionVariables
(
)
{
const
cm
=
this
.
editor
.
codeMirror
;
const
{
state
}
=
cm
.
getTokenAt
(
cm
.
getCursor
(
)
)
;
const
variables
=
[
]
;
if
(
state
.
context
)
{
for
(
let
c
=
state
.
context
;
c
;
c
=
c
.
prev
)
{
for
(
let
v
=
c
.
vars
;
v
;
v
=
v
.
next
)
{
if
(
v
.
name
)
{
variables
.
push
(
v
.
name
)
;
}
}
}
}
const
keys
=
[
"
localVars
"
"
globalVars
"
]
;
for
(
const
key
of
keys
)
{
if
(
state
[
key
]
)
{
for
(
let
v
=
state
[
key
]
;
v
;
v
=
v
.
next
)
{
if
(
v
.
name
)
{
variables
.
push
(
v
.
name
)
;
}
}
}
}
return
variables
;
}
_onEditorChanges
(
cm
changes
)
{
const
value
=
this
.
_getValue
(
)
;
if
(
this
.
lastInputValue
!
=
=
value
)
{
const
isJsTermChangeOnly
=
changes
.
every
(
(
{
origin
}
)
=
>
origin
=
=
=
JSTERM_CODEMIRROR_ORIGIN
)
;
if
(
!
isJsTermChangeOnly
&
&
(
this
.
props
.
autocomplete
|
|
this
.
hasAutocompletionSuggestion
(
)
)
)
{
this
.
autocompleteUpdate
(
false
null
this
.
_getExpressionVariables
(
)
)
;
}
this
.
lastInputValue
=
value
;
this
.
terminalInputChanged
(
value
)
;
}
}
historyPeruse
(
direction
)
{
const
{
history
updateHistoryPosition
getValueFromHistory
}
=
this
.
props
;
if
(
!
history
.
entries
.
length
)
{
return
false
;
}
const
newInputValue
=
getValueFromHistory
(
direction
)
;
const
expression
=
this
.
_getValue
(
)
;
updateHistoryPosition
(
direction
expression
)
;
if
(
newInputValue
!
=
null
)
{
this
.
_setValue
(
newInputValue
)
;
return
true
;
}
return
false
;
}
hasEmptyInput
(
)
{
return
this
.
_getValue
(
)
=
=
=
"
"
;
}
canCaretGoPrevious
(
)
{
if
(
!
this
.
editor
)
{
return
false
;
}
const
inputValue
=
this
.
_getValue
(
)
;
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
return
(
line
=
=
=
0
&
&
ch
=
=
=
0
)
|
|
(
line
=
=
=
0
&
&
ch
=
=
=
inputValue
.
length
)
;
}
canCaretGoNext
(
)
{
if
(
!
this
.
editor
)
{
return
false
;
}
const
inputValue
=
this
.
_getValue
(
)
;
const
multiline
=
/
[
\
r
\
n
]
/
.
test
(
inputValue
)
;
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
return
(
(
!
multiline
&
&
ch
=
=
=
0
)
|
|
this
.
editor
.
getDoc
(
)
.
getRange
(
{
line
:
0
ch
:
0
}
{
line
ch
}
)
.
length
=
=
=
inputValue
.
length
)
;
}
async
updateAutocompletionPopup
(
data
)
{
if
(
!
this
.
editor
)
{
return
;
}
const
{
matches
matchProp
isElementAccess
}
=
data
;
if
(
!
matches
.
length
)
{
this
.
clearCompletion
(
)
;
return
;
}
const
inputUntilCursor
=
this
.
getInputValueBeforeCursor
(
)
;
const
items
=
matches
.
map
(
label
=
>
{
let
preLabel
=
label
.
substring
(
0
matchProp
.
length
)
;
if
(
isElementAccess
&
&
/
^
[
'
"
]
/
.
test
(
matchProp
)
=
=
=
false
)
{
preLabel
=
label
.
substring
(
0
matchProp
.
length
+
1
)
;
}
return
{
preLabel
label
isElementAccess
}
;
}
)
;
if
(
items
.
length
)
{
const
{
preLabel
label
}
=
items
[
0
]
;
let
suffix
=
label
.
substring
(
preLabel
.
length
)
;
if
(
isElementAccess
)
{
if
(
!
matchProp
)
{
suffix
=
label
;
}
const
inputAfterCursor
=
this
.
_getValue
(
)
.
substring
(
inputUntilCursor
.
length
)
;
if
(
!
inputAfterCursor
.
trimLeft
(
)
.
startsWith
(
"
]
"
)
)
{
suffix
=
suffix
+
"
]
"
;
}
}
this
.
setAutoCompletionText
(
suffix
)
;
}
const
popup
=
this
.
autocompletePopup
;
popup
.
setItems
(
items
0
{
preventSelectCallback
:
true
}
)
;
const
minimumAutoCompleteLength
=
2
;
if
(
items
.
length
>
=
minimumAutoCompleteLength
|
|
(
items
.
length
=
=
=
1
&
&
items
[
0
]
.
preLabel
!
=
=
matchProp
)
|
|
(
items
.
length
=
=
=
1
&
&
!
this
.
canDisplayAutoCompletionText
(
)
&
&
items
[
0
]
.
label
!
=
=
matchProp
)
)
{
const
xOffset
=
-
1
*
matchProp
.
length
*
this
.
_inputCharWidth
;
const
yOffset
=
5
;
const
popupAlignElement
=
this
.
props
.
serviceContainer
.
getJsTermTooltipAnchor
(
)
;
this
.
_openPopupPendingPromise
=
popup
.
openPopup
(
popupAlignElement
xOffset
yOffset
0
{
preventSelectCallback
:
true
}
)
;
await
this
.
_openPopupPendingPromise
;
this
.
_openPopupPendingPromise
=
null
;
}
else
if
(
items
.
length
<
minimumAutoCompleteLength
&
&
(
popup
.
isOpen
|
|
this
.
_openPopupPendingPromise
)
)
{
if
(
this
.
_openPopupPendingPromise
)
{
await
this
.
_openPopupPendingPromise
;
}
popup
.
hidePopup
(
)
;
}
this
.
terminalInputChanged
(
this
.
getInputValueWithCompletionText
(
)
.
expression
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
}
onAutocompleteSelect
(
)
{
const
{
selectedItem
}
=
this
.
autocompletePopup
;
if
(
selectedItem
)
{
const
{
preLabel
label
isElementAccess
}
=
selectedItem
;
let
suffix
=
label
.
substring
(
preLabel
.
length
)
;
if
(
isElementAccess
)
{
const
inputBeforeCursor
=
this
.
getInputValueBeforeCursor
(
)
;
if
(
inputBeforeCursor
.
trim
(
)
.
endsWith
(
"
[
"
)
)
{
suffix
=
label
;
}
const
inputAfterCursor
=
this
.
_getValue
(
)
.
substring
(
inputBeforeCursor
.
length
)
;
if
(
!
inputAfterCursor
.
trimLeft
(
)
.
startsWith
(
"
]
"
)
)
{
suffix
=
suffix
+
"
]
"
;
}
}
this
.
setAutoCompletionText
(
suffix
)
;
}
else
{
this
.
setAutoCompletionText
(
"
"
)
;
}
this
.
terminalInputChanged
(
this
.
getInputValueWithCompletionText
(
)
.
expression
)
;
}
clearCompletion
(
)
{
this
.
autocompleteUpdate
.
cancel
(
)
;
this
.
terminalInputChanged
(
this
.
_getValue
(
)
)
;
this
.
setAutoCompletionText
(
"
"
)
;
let
onPopupClosed
=
Promise
.
resolve
(
)
;
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
clearItems
(
)
;
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
_openPopupPendingPromise
)
{
onPopupClosed
=
this
.
autocompletePopup
.
once
(
"
popup
-
closed
"
)
;
if
(
this
.
_openPopupPendingPromise
)
{
this
.
_openPopupPendingPromise
.
then
(
(
)
=
>
this
.
autocompletePopup
.
hidePopup
(
)
)
;
}
else
{
this
.
autocompletePopup
.
hidePopup
(
)
;
}
onPopupClosed
.
then
(
(
)
=
>
this
.
focus
(
)
)
;
}
}
onPopupClosed
.
then
(
(
)
=
>
this
.
emit
(
"
autocomplete
-
updated
"
)
)
;
}
acceptProposedCompletion
(
)
{
const
{
completionText
numberOfCharsToMoveTheCursorForward
numberOfCharsToReplaceCharsBeforeCursor
}
=
this
.
getInputValueWithCompletionText
(
)
;
this
.
autocompleteUpdate
.
cancel
(
)
;
this
.
props
.
autocompleteClear
(
)
;
if
(
this
.
_openPopupPendingPromise
)
{
this
.
_openPopupPendingPromise
.
then
(
(
)
=
>
this
.
autocompletePopup
.
hidePopup
(
)
)
;
}
if
(
completionText
)
{
this
.
insertStringAtCursor
(
completionText
numberOfCharsToReplaceCharsBeforeCursor
)
;
if
(
numberOfCharsToMoveTheCursorForward
)
{
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
this
.
editor
.
setCursor
(
{
line
ch
:
ch
+
numberOfCharsToMoveTheCursorForward
}
)
;
}
}
}
getInputValueWithCompletionText
(
)
{
const
inputBeforeCursor
=
this
.
getInputValueBeforeCursor
(
)
;
const
inputAfterCursor
=
this
.
_getValue
(
)
.
substring
(
inputBeforeCursor
.
length
)
;
let
completionText
=
this
.
getAutoCompletionText
(
)
;
let
numberOfCharsToReplaceCharsBeforeCursor
;
let
numberOfCharsToMoveTheCursorForward
=
0
;
if
(
this
.
autocompletePopup
.
isOpen
&
&
this
.
autocompletePopup
.
selectedItem
)
{
const
{
selectedItem
}
=
this
.
autocompletePopup
;
const
{
label
preLabel
isElementAccess
}
=
selectedItem
;
completionText
=
label
;
numberOfCharsToReplaceCharsBeforeCursor
=
preLabel
.
length
;
if
(
isElementAccess
)
{
const
lastOpeningBracketIndex
=
inputBeforeCursor
.
lastIndexOf
(
"
[
"
)
;
if
(
lastOpeningBracketIndex
>
-
1
)
{
numberOfCharsToReplaceCharsBeforeCursor
=
inputBeforeCursor
.
substring
(
lastOpeningBracketIndex
+
1
)
.
length
;
}
const
completionTextLastChar
=
completionText
[
completionText
.
length
-
1
]
;
const
endingQuote
=
[
"
'
"
"
]
.
includes
(
completionTextLastChar
)
?
completionTextLastChar
:
"
"
;
if
(
endingQuote
&
&
inputAfterCursor
.
trimLeft
(
)
.
startsWith
(
endingQuote
)
)
{
completionText
=
completionText
.
substring
(
0
completionText
.
length
-
1
)
;
numberOfCharsToMoveTheCursorForward
+
+
;
}
if
(
!
inputAfterCursor
.
trimLeft
(
)
.
match
(
new
RegExp
(
^
{
endingQuote
}
?
]
)
)
)
{
completionText
=
completionText
+
"
]
"
;
}
else
{
numberOfCharsToMoveTheCursorForward
+
+
;
}
}
}
const
expression
=
inputBeforeCursor
.
substring
(
0
inputBeforeCursor
.
length
-
(
numberOfCharsToReplaceCharsBeforeCursor
|
|
0
)
)
+
completionText
+
inputAfterCursor
;
return
{
completionText
expression
numberOfCharsToMoveTheCursorForward
numberOfCharsToReplaceCharsBeforeCursor
}
;
}
getInputValueBeforeCursor
(
)
{
return
this
.
editor
?
this
.
editor
.
getDoc
(
)
.
getRange
(
{
line
:
0
ch
:
0
}
this
.
editor
.
getCursor
(
)
)
:
null
;
}
insertStringAtCursor
(
str
numberOfCharsToReplaceCharsBeforeCursor
=
0
)
{
if
(
!
this
.
editor
)
{
return
;
}
const
cursor
=
this
.
editor
.
getCursor
(
)
;
const
from
=
{
line
:
cursor
.
line
ch
:
cursor
.
ch
-
numberOfCharsToReplaceCharsBeforeCursor
}
;
this
.
editor
.
getDoc
(
)
.
replaceRange
(
str
from
cursor
JSTERM_CODEMIRROR_ORIGIN
)
;
}
setAutoCompletionText
(
suffix
)
{
if
(
!
this
.
editor
)
{
return
;
}
this
.
pendingCompletionText
=
null
;
if
(
suffix
&
&
!
this
.
canDisplayAutoCompletionText
(
)
)
{
suffix
=
"
"
;
}
this
.
editor
.
setAutoCompletionText
(
suffix
)
;
}
getAutoCompletionText
(
)
{
const
renderedCompletionText
=
this
.
editor
&
&
this
.
editor
.
getAutoCompletionText
(
)
;
return
typeof
this
.
pendingCompletionText
=
=
=
"
string
"
?
this
.
pendingCompletionText
:
renderedCompletionText
;
}
hasAutocompletionSuggestion
(
)
{
return
(
this
.
getAutoCompletionText
(
)
|
|
(
this
.
autocompletePopup
.
isOpen
&
&
Number
.
isInteger
(
this
.
autocompletePopup
.
selectedIndex
)
&
&
this
.
autocompletePopup
.
selectedIndex
>
-
1
)
)
;
}
canDisplayAutoCompletionText
(
)
{
if
(
!
this
.
editor
)
{
return
false
;
}
const
{
ch
line
}
=
this
.
editor
.
getCursor
(
)
;
const
lineContent
=
this
.
editor
.
getLine
(
line
)
;
const
textAfterCursor
=
lineContent
.
substring
(
ch
)
;
return
textAfterCursor
=
=
=
"
"
;
}
_getInputCharWidth
(
)
{
return
this
.
editor
?
this
.
editor
.
defaultCharWidth
(
)
:
null
;
}
onContextMenu
(
e
)
{
this
.
props
.
serviceContainer
.
openEditContextMenu
(
e
)
;
}
destroy
(
)
{
this
.
autocompleteUpdate
.
cancel
(
)
;
this
.
terminalInputChanged
.
cancel
(
)
;
this
.
_openPopupPendingPromise
=
null
;
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
destroy
(
)
;
this
.
autocompletePopup
=
null
;
}
if
(
this
.
editor
)
{
this
.
resizeObserver
.
disconnect
(
)
;
this
.
editor
.
destroy
(
)
;
this
.
editor
=
null
;
}
this
.
webConsoleUI
=
null
;
}
renderOpenEditorButton
(
)
{
if
(
this
.
props
.
editorMode
)
{
return
null
;
}
return
dom
.
button
(
{
className
:
"
devtools
-
button
webconsole
-
input
-
openEditorButton
"
+
(
this
.
props
.
showEditorOnboarding
?
"
devtools
-
feature
-
callout
"
:
"
"
)
title
:
l10n
.
getFormatStr
(
"
webconsole
.
input
.
openEditorButton
.
tooltip2
"
[
isMacOS
?
"
Cmd
+
B
"
:
"
Ctrl
+
B
"
]
)
onClick
:
this
.
props
.
editorToggle
}
)
;
}
renderEvaluationContextSelector
(
)
{
if
(
this
.
props
.
editorMode
|
|
!
this
.
props
.
showEvaluationContextSelector
)
{
return
null
;
}
return
EvaluationContextSelector
(
this
.
props
)
;
}
renderEditorOnboarding
(
)
{
if
(
!
this
.
props
.
showEditorOnboarding
)
{
return
null
;
}
const
label
=
l10n
.
getStr
(
"
webconsole
.
input
.
editor
.
onboarding
.
label
"
)
;
let
[
prefix
suffix
]
=
label
.
split
(
"
%
1
S
"
)
;
suffix
=
suffix
.
split
(
"
%
2
S
"
)
;
const
enterString
=
l10n
.
getStr
(
"
webconsole
.
enterKey
"
)
;
return
dom
.
header
(
{
className
:
"
editor
-
onboarding
"
}
dom
.
img
(
{
className
:
"
editor
-
onboarding
-
fox
"
src
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
fox
-
smiling
.
svg
"
}
)
dom
.
p
(
{
}
prefix
dom
.
span
(
{
className
:
"
editor
-
onboarding
-
shortcut
"
}
enterString
)
suffix
[
0
]
dom
.
span
(
{
className
:
"
editor
-
onboarding
-
shortcut
"
}
[
isMacOS
?
Cmd
+
{
enterString
}
:
Ctrl
+
{
enterString
}
]
)
suffix
[
1
]
)
dom
.
button
(
{
className
:
"
editor
-
onboarding
-
dismiss
-
button
"
onClick
:
(
)
=
>
this
.
props
.
editorOnboardingDismiss
(
)
}
l10n
.
getStr
(
"
webconsole
.
input
.
editor
.
onboarding
.
dismiss
.
label
"
)
)
)
;
}
render
(
)
{
if
(
!
this
.
props
.
inputEnabled
)
{
return
null
;
}
return
dom
.
div
(
{
className
:
"
jsterm
-
input
-
container
devtools
-
input
"
key
:
"
jsterm
-
container
"
"
aria
-
live
"
:
"
off
"
tabIndex
:
-
1
onContextMenu
:
this
.
onContextMenu
ref
:
node
=
>
{
this
.
node
=
node
;
}
}
dom
.
div
(
{
className
:
"
webconsole
-
input
-
buttons
"
}
this
.
renderEvaluationContextSelector
(
)
this
.
renderOpenEditorButton
(
)
)
this
.
renderEditorOnboarding
(
)
)
;
}
}
function
mapStateToProps
(
state
)
{
return
{
history
:
getHistory
(
state
)
getValueFromHistory
:
direction
=
>
getHistoryValue
(
state
direction
)
autocompleteData
:
getAutocompleteState
(
state
)
showEditorOnboarding
:
state
.
ui
.
showEditorOnboarding
showEvaluationContextSelector
:
state
.
ui
.
showEvaluationContextSelector
autocompletePopupPosition
:
state
.
prefs
.
eagerEvaluation
?
"
top
"
:
"
bottom
"
editorPrettifiedAt
:
state
.
ui
.
editorPrettifiedAt
}
;
}
function
mapDispatchToProps
(
dispatch
)
{
return
{
updateHistoryPosition
:
(
direction
expression
)
=
>
dispatch
(
actions
.
updateHistoryPosition
(
direction
expression
)
)
autocompleteUpdate
:
(
force
getterPath
expressionVars
)
=
>
dispatch
(
actions
.
autocompleteUpdate
(
force
getterPath
expressionVars
)
)
autocompleteClear
:
(
)
=
>
dispatch
(
actions
.
autocompleteClear
(
)
)
evaluateExpression
:
expression
=
>
dispatch
(
actions
.
evaluateExpression
(
expression
)
)
editorToggle
:
(
)
=
>
dispatch
(
actions
.
editorToggle
(
)
)
editorOnboardingDismiss
:
(
)
=
>
dispatch
(
actions
.
editorOnboardingDismiss
(
)
)
terminalInputChanged
:
value
=
>
dispatch
(
actions
.
terminalInputChanged
(
value
)
)
}
;
}
module
.
exports
=
connect
(
mapStateToProps
mapDispatchToProps
)
(
JSTerm
)
;
