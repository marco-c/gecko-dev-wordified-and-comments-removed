"
use
strict
"
;
const
{
Utils
:
WebConsoleUtils
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
debounce
}
=
require
(
"
devtools
/
shared
/
debounce
"
)
;
loader
.
lazyRequireGetter
(
this
"
Debugger
"
"
Debugger
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
AutocompletePopup
"
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
PropTypes
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyCodes
"
"
devtools
/
client
/
shared
/
keycodes
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Editor
"
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
)
;
loader
.
lazyRequireGetter
(
this
"
focusableSelector
"
"
devtools
/
client
/
shared
/
focus
"
true
)
;
const
{
Component
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
{
getHistory
getHistoryValue
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
history
"
)
;
const
{
getAutocompleteState
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
autocomplete
"
)
;
const
actions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
const
{
HISTORY_BACK
HISTORY_FORWARD
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
class
JSTerm
extends
Component
{
static
get
propTypes
(
)
{
return
{
appendToHistory
:
PropTypes
.
func
.
isRequired
clearHistory
:
PropTypes
.
func
.
isRequired
getValueFromHistory
:
PropTypes
.
func
.
isRequired
history
:
PropTypes
.
object
.
isRequired
webConsoleUI
:
PropTypes
.
object
.
isRequired
serviceContainer
:
PropTypes
.
object
.
isRequired
onPaste
:
PropTypes
.
func
codeMirrorEnabled
:
PropTypes
.
bool
evaluateExpression
:
PropTypes
.
func
.
isRequired
updateHistoryPosition
:
PropTypes
.
func
.
isRequired
autocompleteUpdate
:
PropTypes
.
func
.
isRequired
autocompleteClear
:
PropTypes
.
func
.
isRequired
autocompleteData
:
PropTypes
.
object
.
isRequired
editorMode
:
PropTypes
.
bool
editorWidth
:
PropTypes
.
number
autocomplete
:
PropTypes
.
bool
}
;
}
constructor
(
props
)
{
super
(
props
)
;
const
{
webConsoleUI
}
=
props
;
this
.
webConsoleUI
=
webConsoleUI
;
this
.
hudId
=
this
.
webConsoleUI
.
hudId
;
this
.
_keyPress
=
this
.
_keyPress
.
bind
(
this
)
;
this
.
_inputEventHandler
=
this
.
_inputEventHandler
.
bind
(
this
)
;
this
.
onContextMenu
=
this
.
onContextMenu
.
bind
(
this
)
;
this
.
imperativeUpdate
=
this
.
imperativeUpdate
.
bind
(
this
)
;
this
.
autocompleteUpdate
=
debounce
(
this
.
props
.
autocompleteUpdate
75
this
)
;
this
.
lastInputValue
=
"
"
;
this
.
autocompletePopup
=
null
;
this
.
inputNode
=
null
;
this
.
completeNode
=
null
;
EventEmitter
.
decorate
(
this
)
;
webConsoleUI
.
jsterm
=
this
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
editorMode
)
{
this
.
setEditorWidth
(
this
.
props
.
editorWidth
)
;
}
const
autocompleteOptions
=
{
onSelect
:
this
.
onAutocompleteSelect
.
bind
(
this
)
onClick
:
this
.
acceptProposedCompletion
.
bind
(
this
)
listId
:
"
webConsole_autocompletePopupListBox
"
position
:
"
bottom
"
autoSelect
:
true
}
;
const
isMacOS
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
doc
=
this
.
webConsoleUI
.
document
;
const
toolbox
=
this
.
webConsoleUI
.
wrapper
.
toolbox
;
const
tooltipDoc
=
toolbox
?
toolbox
.
doc
:
doc
;
this
.
autocompletePopup
=
new
AutocompletePopup
(
tooltipDoc
autocompleteOptions
)
;
if
(
this
.
props
.
codeMirrorEnabled
)
{
if
(
this
.
node
)
{
const
onArrowUp
=
(
)
=
>
{
let
inputUpdated
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectPreviousItem
(
)
;
return
null
;
}
if
(
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
return
inputUpdated
?
null
:
"
CodeMirror
.
Pass
"
;
}
;
const
onArrowDown
=
(
)
=
>
{
let
inputUpdated
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectNextItem
(
)
;
return
null
;
}
if
(
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
return
inputUpdated
?
null
:
"
CodeMirror
.
Pass
"
;
}
;
const
onArrowLeft
=
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
return
"
CodeMirror
.
Pass
"
;
}
;
const
onArrowRight
=
(
)
=
>
{
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
;
const
onCtrlCmdEnter
=
(
)
=
>
{
if
(
this
.
hasAutocompletionSuggestion
(
)
)
{
return
this
.
acceptProposedCompletion
(
)
;
}
this
.
_execute
(
)
;
return
null
;
}
;
this
.
editor
=
new
Editor
(
{
autofocus
:
true
enableCodeFolding
:
false
autoCloseBrackets
:
false
lineNumbers
:
this
.
props
.
editorMode
lineWrapping
:
true
mode
:
Editor
.
modes
.
js
styleActiveLine
:
false
tabIndex
:
"
0
"
viewportMargin
:
Infinity
disableSearchAddon
:
true
extraKeys
:
{
Enter
:
(
)
=
>
{
const
hasSuggestion
=
this
.
hasAutocompletionSuggestion
(
)
;
if
(
!
hasSuggestion
&
&
!
Debugger
.
isCompilableUnit
(
this
.
_getValue
(
)
)
)
{
return
"
CodeMirror
.
Pass
"
;
}
if
(
hasSuggestion
)
{
return
this
.
acceptProposedCompletion
(
)
;
}
if
(
!
this
.
props
.
editorMode
)
{
this
.
_execute
(
)
;
return
null
;
}
return
"
CodeMirror
.
Pass
"
;
}
"
Cmd
-
Enter
"
:
onCtrlCmdEnter
"
Ctrl
-
Enter
"
:
onCtrlCmdEnter
Tab
:
(
)
=
>
{
if
(
this
.
hasEmptyInput
(
)
)
{
this
.
editor
.
codeMirror
.
getInputField
(
)
.
blur
(
)
;
return
false
;
}
if
(
this
.
props
.
autocompleteData
&
&
this
.
props
.
autocompleteData
.
getterPath
)
{
this
.
props
.
autocompleteUpdate
(
true
this
.
props
.
autocompleteData
.
getterPath
)
;
return
false
;
}
const
isSomethingSelected
=
this
.
editor
.
somethingSelected
(
)
;
const
hasSuggestion
=
this
.
hasAutocompletionSuggestion
(
)
;
if
(
hasSuggestion
&
&
!
isSomethingSelected
)
{
this
.
acceptProposedCompletion
(
)
;
return
false
;
}
if
(
!
isSomethingSelected
)
{
this
.
insertStringAtCursor
(
"
\
t
"
)
;
return
false
;
}
return
true
;
}
"
Shift
-
Tab
"
:
(
)
=
>
{
if
(
this
.
hasEmptyInput
(
)
)
{
this
.
focusPreviousElement
(
)
;
return
false
;
}
const
hasSuggestion
=
this
.
hasAutocompletionSuggestion
(
)
;
if
(
hasSuggestion
)
{
return
false
;
}
return
"
CodeMirror
.
Pass
"
;
}
Up
:
onArrowUp
"
Cmd
-
Up
"
:
onArrowUp
Down
:
onArrowDown
"
Cmd
-
Down
"
:
onArrowDown
Left
:
onArrowLeft
"
Ctrl
-
Left
"
:
onArrowLeft
"
Cmd
-
Left
"
:
onArrowLeft
"
Alt
-
Left
"
:
onArrowLeft
"
Ctrl
-
A
"
:
isMacOS
?
onArrowLeft
:
undefined
Right
:
onArrowRight
"
Ctrl
-
Right
"
:
onArrowRight
"
Cmd
-
Right
"
:
onArrowRight
"
Alt
-
Right
"
:
onArrowRight
"
Ctrl
-
N
"
:
(
)
=
>
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
&
&
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
"
Ctrl
-
P
"
:
(
)
=
>
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
&
&
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
return
null
;
}
this
.
clearCompletion
(
)
;
return
"
CodeMirror
.
Pass
"
;
}
PageUp
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectPreviousPageItem
(
)
;
}
else
{
const
{
outputScroller
}
=
this
.
webConsoleUI
;
const
{
scrollTop
clientHeight
}
=
outputScroller
;
outputScroller
.
scrollTop
=
Math
.
max
(
0
scrollTop
-
clientHeight
)
;
}
return
null
;
}
PageDown
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectNextPageItem
(
)
;
}
else
{
const
{
outputScroller
}
=
this
.
webConsoleUI
;
const
{
scrollTop
scrollHeight
clientHeight
}
=
outputScroller
;
outputScroller
.
scrollTop
=
Math
.
min
(
scrollHeight
scrollTop
+
clientHeight
)
;
}
return
null
;
}
Home
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectItemAtIndex
(
0
)
;
return
null
;
}
if
(
!
this
.
_getValue
(
)
)
{
this
.
webConsoleUI
.
outputScroller
.
scrollTop
=
0
;
return
null
;
}
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
return
"
CodeMirror
.
Pass
"
;
}
End
:
(
)
=
>
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectItemAtIndex
(
this
.
autocompletePopup
.
itemCount
-
1
)
;
return
null
;
}
if
(
!
this
.
_getValue
(
)
)
{
const
{
outputScroller
}
=
this
.
webConsoleUI
;
outputScroller
.
scrollTop
=
outputScroller
.
scrollHeight
;
return
null
;
}
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
return
"
CodeMirror
.
Pass
"
;
}
"
Ctrl
-
Space
"
:
(
)
=
>
{
if
(
!
this
.
autocompletePopup
.
isOpen
)
{
this
.
props
.
autocompleteUpdate
(
true
)
;
return
null
;
}
return
"
CodeMirror
.
Pass
"
;
}
Esc
:
false
"
Cmd
-
F
"
:
false
"
Ctrl
-
F
"
:
false
}
}
)
;
this
.
editor
.
on
(
"
changes
"
this
.
_inputEventHandler
)
;
this
.
editor
.
on
(
"
beforeChange
"
this
.
_onBeforeChange
)
;
this
.
editor
.
appendToLocalElement
(
this
.
node
)
;
const
cm
=
this
.
editor
.
codeMirror
;
cm
.
on
(
"
paste
"
(
_
event
)
=
>
this
.
props
.
onPaste
(
event
)
)
;
cm
.
on
(
"
drop
"
(
_
event
)
=
>
this
.
props
.
onPaste
(
event
)
)
;
this
.
node
.
addEventListener
(
"
keydown
"
event
=
>
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
if
(
this
.
props
.
autocompleteData
&
&
this
.
props
.
autocompleteData
.
getterPath
)
{
this
.
props
.
autocompleteClear
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
}
)
;
}
}
else
if
(
this
.
inputNode
)
{
this
.
inputNode
.
addEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
addEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
addEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
this
.
focus
(
)
;
}
this
.
inputBorderSize
=
this
.
inputNode
?
this
.
inputNode
.
getBoundingClientRect
(
)
.
height
-
this
.
inputNode
.
clientHeight
:
0
;
this
.
_inputCharWidth
=
this
.
_getInputCharWidth
(
)
;
this
.
_paddingInlineStart
=
this
.
editor
?
null
:
this
.
_getInputPaddingInlineStart
(
)
;
this
.
lastInputValue
&
&
this
.
_setValue
(
this
.
lastInputValue
)
;
}
componentWillReceiveProps
(
nextProps
)
{
this
.
imperativeUpdate
(
nextProps
)
;
}
shouldComponentUpdate
(
nextProps
)
{
return
false
;
}
imperativeUpdate
(
nextProps
)
{
if
(
!
nextProps
)
{
return
;
}
if
(
nextProps
.
autocompleteData
!
=
=
this
.
props
.
autocompleteData
&
&
nextProps
.
autocompleteData
.
pendingRequestId
=
=
=
null
)
{
this
.
updateAutocompletionPopup
(
nextProps
.
autocompleteData
)
;
}
if
(
nextProps
.
editorMode
!
=
=
this
.
props
.
editorMode
)
{
if
(
this
.
editor
)
{
this
.
editor
.
setOption
(
"
lineNumbers
"
nextProps
.
editorMode
)
;
}
if
(
nextProps
.
editorMode
&
&
nextProps
.
editorWidth
)
{
this
.
setEditorWidth
(
nextProps
.
editorWidth
)
;
}
else
{
this
.
setEditorWidth
(
null
)
;
}
}
}
setEditorWidth
(
editorWidth
)
{
if
(
!
this
.
node
)
{
return
;
}
if
(
editorWidth
)
{
this
.
node
.
style
.
width
=
{
editorWidth
}
px
;
}
else
{
this
.
node
.
style
.
removeProperty
(
"
width
"
)
;
}
}
focus
(
)
{
if
(
this
.
editor
)
{
this
.
editor
.
focus
(
)
;
}
else
if
(
this
.
inputNode
&
&
!
this
.
inputNode
.
getAttribute
(
"
focused
"
)
)
{
this
.
inputNode
.
focus
(
)
;
}
}
focusPreviousElement
(
)
{
const
inputField
=
this
.
editor
.
codeMirror
.
getInputField
(
)
;
const
findPreviousFocusableElement
=
el
=
>
{
if
(
!
el
|
|
!
el
.
querySelectorAll
)
{
return
null
;
}
const
items
=
Array
.
from
(
el
.
querySelectorAll
(
focusableSelector
)
)
;
const
inputIndex
=
items
.
indexOf
(
inputField
)
;
if
(
items
.
length
=
=
=
0
|
|
(
inputIndex
>
-
1
&
&
items
.
length
=
=
=
1
)
)
{
return
findPreviousFocusableElement
(
el
.
parentNode
)
;
}
const
index
=
inputIndex
>
0
?
inputIndex
-
1
:
items
.
length
-
1
;
return
items
[
index
]
;
}
;
const
focusableEl
=
findPreviousFocusableElement
(
this
.
node
.
parentNode
)
;
if
(
focusableEl
)
{
focusableEl
.
focus
(
)
;
}
}
_execute
(
)
{
const
executeString
=
this
.
_getValue
(
)
;
if
(
!
executeString
)
{
return
;
}
if
(
!
this
.
props
.
editorMode
)
{
this
.
_setValue
(
"
"
)
;
}
this
.
clearCompletion
(
)
;
this
.
props
.
evaluateExpression
(
executeString
)
;
}
resizeInput
(
)
{
if
(
this
.
props
.
codeMirrorEnabled
|
|
!
this
.
inputNode
)
{
return
;
}
const
{
inputNode
completeNode
}
=
this
;
inputNode
.
style
.
height
=
"
auto
"
;
const
minHeightBackup
=
inputNode
.
style
.
minHeight
;
inputNode
.
style
.
minHeight
=
"
unset
"
;
completeNode
.
style
.
height
=
"
auto
"
;
const
scrollHeight
=
inputNode
.
scrollHeight
;
if
(
scrollHeight
>
0
)
{
const
pxHeight
=
scrollHeight
+
this
.
inputBorderSize
+
"
px
"
;
inputNode
.
style
.
height
=
pxHeight
;
inputNode
.
style
.
minHeight
=
minHeightBackup
;
completeNode
.
style
.
height
=
pxHeight
;
}
}
_setValue
(
newValue
)
{
newValue
=
newValue
|
|
"
"
;
this
.
lastInputValue
=
newValue
;
if
(
this
.
props
.
codeMirrorEnabled
)
{
if
(
this
.
editor
)
{
this
.
editor
.
codeMirror
.
operation
(
(
)
=
>
{
this
.
editor
.
setText
(
newValue
)
;
const
lines
=
newValue
.
split
(
"
\
n
"
)
;
this
.
editor
.
setCursor
(
{
line
:
lines
.
length
-
1
ch
:
lines
[
lines
.
length
-
1
]
.
length
}
)
;
this
.
editor
.
setAutoCompletionText
(
)
;
}
)
;
}
}
else
{
if
(
!
this
.
inputNode
)
{
return
;
}
this
.
inputNode
.
value
=
newValue
;
this
.
completeNode
.
value
=
"
"
;
}
this
.
resizeInput
(
)
;
this
.
emit
(
"
set
-
input
-
value
"
)
;
}
_getValue
(
)
{
if
(
this
.
props
.
codeMirrorEnabled
)
{
return
this
.
editor
?
this
.
editor
.
getText
(
)
|
|
"
"
:
"
"
;
}
return
this
.
inputNode
?
this
.
inputNode
.
value
|
|
"
"
:
"
"
;
}
getSelectionStart
(
)
{
if
(
this
.
props
.
codeMirrorEnabled
)
{
return
this
.
getInputValueBeforeCursor
(
)
.
length
;
}
return
this
.
inputNode
?
this
.
inputNode
.
selectionStart
:
null
;
}
getSelectedText
(
)
{
if
(
this
.
inputNode
)
{
return
this
.
inputNode
.
value
.
substring
(
this
.
inputNode
.
selectionStart
this
.
inputNode
.
selectionEnd
)
;
}
return
this
.
editor
.
getSelection
(
)
;
}
_onBeforeChange
(
cm
change
)
{
const
{
from
to
origin
text
}
=
change
;
const
completionText
=
this
.
getAutoCompletionText
(
)
;
const
addedCharacterMatchCompletion
=
from
.
line
=
=
=
to
.
line
&
&
from
.
ch
=
=
=
to
.
ch
&
&
origin
=
=
=
"
+
input
"
&
&
completionText
.
startsWith
(
text
.
join
(
"
"
)
)
;
if
(
!
completionText
|
|
change
.
canceled
|
|
!
addedCharacterMatchCompletion
)
{
this
.
setAutoCompletionText
(
"
"
)
;
}
}
_inputEventHandler
(
)
{
const
value
=
this
.
_getValue
(
)
;
if
(
this
.
lastInputValue
!
=
=
value
)
{
this
.
resizeInput
(
)
;
if
(
this
.
props
.
autocomplete
|
|
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompleteUpdate
(
)
;
}
this
.
lastInputValue
=
value
;
}
}
_keyPress
(
event
)
{
const
inputValue
=
this
.
_getValue
(
)
;
let
inputUpdated
=
false
;
if
(
event
.
ctrlKey
)
{
switch
(
event
.
charCode
)
{
case
97
:
if
(
!
Services
.
appinfo
.
OS
=
=
"
Darwin
"
)
{
break
;
}
this
.
clearCompletion
(
)
;
break
;
case
101
:
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
break
;
}
this
.
clearCompletion
(
)
;
break
;
case
110
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoNext
(
)
&
&
this
.
historyPeruse
(
HISTORY_FORWARD
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
case
112
:
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
&
&
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoPrevious
(
)
&
&
this
.
historyPeruse
(
HISTORY_BACK
)
)
{
event
.
preventDefault
(
)
;
this
.
focus
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
default
:
break
;
}
if
(
event
.
key
=
=
=
"
"
&
&
!
this
.
autocompletePopup
.
isOpen
)
{
this
.
props
.
autocompleteUpdate
(
true
)
;
event
.
preventDefault
(
)
;
}
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_LEFT
&
&
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
getAutoCompletionText
(
)
)
)
{
this
.
clearCompletion
(
)
;
}
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RIGHT
)
{
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
event
.
preventDefault
(
)
;
}
this
.
clearCompletion
(
)
;
}
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
if
(
this
.
hasAutocompletionSuggestion
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
if
(
this
.
props
.
editorMode
)
{
this
.
_execute
(
)
;
}
event
.
preventDefault
(
)
;
}
return
;
}
else
if
(
event
.
metaKey
&
&
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
)
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
if
(
this
.
hasAutocompletionSuggestion
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
if
(
this
.
props
.
editorMode
)
{
this
.
_execute
(
)
;
}
event
.
preventDefault
(
)
;
}
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
if
(
!
this
.
autocompletePopup
.
isOpen
&
&
(
event
.
shiftKey
|
|
!
Debugger
.
isCompilableUnit
(
this
.
_getValue
(
)
)
)
)
{
return
;
}
}
const
{
props
}
=
this
;
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_ESCAPE
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
clearCompletion
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
else
if
(
props
.
autocompleteData
&
&
props
.
autocompleteData
.
getterPath
)
{
props
.
autocompleteClear
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RETURN
:
if
(
this
.
hasAutocompletionSuggestion
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
}
else
if
(
!
props
.
editorMode
)
{
this
.
_execute
(
)
;
}
else
{
this
.
insertStringAtCursor
(
"
\
n
"
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectPreviousItem
(
)
;
event
.
preventDefault
(
)
;
}
else
if
(
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoPrevious
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_BACK
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectNextItem
(
)
;
event
.
preventDefault
(
)
;
}
else
if
(
this
.
props
.
editorMode
=
=
=
false
&
&
this
.
canCaretGoNext
(
)
)
{
inputUpdated
=
this
.
historyPeruse
(
HISTORY_FORWARD
)
;
}
if
(
inputUpdated
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectPreviousPageItem
(
)
;
}
else
{
this
.
webConsoleUI
.
outputScroller
.
scrollTop
=
Math
.
max
(
0
this
.
webConsoleUI
.
outputScroller
.
scrollTop
-
this
.
webConsoleUI
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectNextPageItem
(
)
;
}
else
{
this
.
webConsoleUI
.
outputScroller
.
scrollTop
=
Math
.
min
(
this
.
webConsoleUI
.
outputScroller
.
scrollHeight
this
.
webConsoleUI
.
outputScroller
.
scrollTop
+
this
.
webConsoleUI
.
outputScroller
.
clientHeight
)
;
}
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_HOME
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectItemAtIndex
(
0
)
;
event
.
preventDefault
(
)
;
}
else
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
this
.
webConsoleUI
.
outputScroller
.
scrollTop
=
0
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_END
:
if
(
this
.
autocompletePopup
.
isOpen
)
{
this
.
autocompletePopup
.
selectItemAtIndex
(
this
.
autocompletePopup
.
itemCount
-
1
)
;
event
.
preventDefault
(
)
;
}
else
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
else
if
(
inputValue
.
length
<
=
0
)
{
const
{
outputScroller
}
=
this
.
webConsoleUI
;
outputScroller
.
scrollTop
=
outputScroller
.
scrollHeight
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_LEFT
:
if
(
this
.
autocompletePopup
.
isOpen
|
|
this
.
getAutoCompletionText
(
)
)
{
this
.
clearCompletion
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_RIGHT
:
if
(
this
.
getAutoCompletionText
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
event
.
preventDefault
(
)
;
}
this
.
clearCompletion
(
)
;
break
;
case
KeyCodes
.
DOM_VK_TAB
:
if
(
this
.
hasAutocompletionSuggestion
(
)
)
{
this
.
acceptProposedCompletion
(
)
;
event
.
preventDefault
(
)
;
}
else
if
(
props
.
autocompleteData
&
&
props
.
autocompleteData
.
getterPath
)
{
event
.
preventDefault
(
)
;
props
.
autocompleteUpdate
(
true
props
.
autocompleteData
.
getterPath
)
;
}
else
if
(
!
this
.
hasEmptyInput
(
)
)
{
if
(
!
event
.
shiftKey
)
{
this
.
insertStringAtCursor
(
"
\
t
"
)
;
}
event
.
preventDefault
(
)
;
}
break
;
default
:
break
;
}
}
historyPeruse
(
direction
)
{
const
{
history
updateHistoryPosition
getValueFromHistory
}
=
this
.
props
;
if
(
!
history
.
entries
.
length
)
{
return
false
;
}
const
newInputValue
=
getValueFromHistory
(
direction
)
;
const
expression
=
this
.
_getValue
(
)
;
updateHistoryPosition
(
direction
expression
)
;
if
(
newInputValue
!
=
null
)
{
this
.
_setValue
(
newInputValue
)
;
return
true
;
}
return
false
;
}
hasEmptyInput
(
)
{
return
this
.
_getValue
(
)
=
=
=
"
"
;
}
hasMultilineInput
(
)
{
return
/
[
\
r
\
n
]
/
.
test
(
this
.
_getValue
(
)
)
;
}
canCaretGoPrevious
(
)
{
const
inputValue
=
this
.
_getValue
(
)
;
if
(
this
.
editor
)
{
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
return
(
(
line
=
=
=
0
&
&
ch
=
=
=
0
)
|
|
(
line
=
=
=
0
&
&
ch
=
=
=
inputValue
.
length
)
)
;
}
const
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
const
multiline
=
/
[
\
r
\
n
]
/
.
test
(
inputValue
)
;
return
node
.
selectionStart
=
=
0
?
true
:
node
.
selectionStart
=
=
inputValue
.
length
&
&
!
multiline
;
}
canCaretGoNext
(
)
{
const
inputValue
=
this
.
_getValue
(
)
;
const
multiline
=
/
[
\
r
\
n
]
/
.
test
(
inputValue
)
;
if
(
this
.
editor
)
{
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
return
(
(
!
multiline
&
&
ch
=
=
=
0
)
|
|
this
.
editor
.
getDoc
(
)
.
getRange
(
{
line
:
0
ch
:
0
}
{
line
ch
}
)
.
length
=
=
=
inputValue
.
length
)
;
}
const
node
=
this
.
inputNode
;
if
(
node
.
selectionStart
!
=
node
.
selectionEnd
)
{
return
false
;
}
return
node
.
selectionStart
=
=
node
.
value
.
length
?
true
:
node
.
selectionStart
=
=
0
&
&
!
multiline
;
}
updateAutocompletionPopup
(
data
)
{
const
{
matches
matchProp
isElementAccess
}
=
data
;
if
(
!
matches
.
length
)
{
this
.
clearCompletion
(
)
;
this
.
emit
(
"
autocomplete
-
updated
"
)
;
return
;
}
const
inputUntilCursor
=
this
.
getInputValueBeforeCursor
(
)
;
const
items
=
matches
.
map
(
label
=
>
{
let
preLabel
=
label
.
substring
(
0
matchProp
.
length
)
;
if
(
isElementAccess
&
&
/
^
[
'
"
]
/
.
test
(
matchProp
)
=
=
=
false
)
{
preLabel
=
label
.
substring
(
0
matchProp
.
length
+
1
)
;
}
return
{
preLabel
label
isElementAccess
}
;
}
)
;
if
(
items
.
length
>
0
)
{
const
{
preLabel
label
}
=
items
[
0
]
;
let
suffix
=
label
.
substring
(
preLabel
.
length
)
;
if
(
isElementAccess
)
{
if
(
!
matchProp
)
{
suffix
=
label
;
}
const
inputAfterCursor
=
this
.
_getValue
(
)
.
substring
(
inputUntilCursor
.
length
)
;
if
(
!
inputAfterCursor
.
trimLeft
(
)
.
startsWith
(
"
]
"
)
)
{
suffix
=
suffix
+
"
]
"
;
}
}
this
.
setAutoCompletionText
(
suffix
)
;
}
const
popup
=
this
.
autocompletePopup
;
popup
.
setItems
(
items
0
{
preventSelectCallback
:
true
}
)
;
const
minimumAutoCompleteLength
=
2
;
if
(
items
.
length
>
=
minimumAutoCompleteLength
|
|
(
items
.
length
=
=
=
1
&
&
items
[
0
]
.
preLabel
!
=
=
matchProp
)
|
|
(
items
.
length
=
=
=
1
&
&
!
this
.
canDisplayAutoCompletionText
(
)
&
&
items
[
0
]
.
label
!
=
=
matchProp
)
)
{
const
popupAlignElement
=
this
.
props
.
serviceContainer
.
getJsTermTooltipAnchor
(
)
;
let
xOffset
;
let
yOffset
;
if
(
this
.
editor
)
{
xOffset
=
-
1
*
matchProp
.
length
*
this
.
_inputCharWidth
;
yOffset
=
5
;
}
else
if
(
this
.
inputNode
)
{
const
offset
=
inputUntilCursor
.
length
-
(
inputUntilCursor
.
lastIndexOf
(
"
\
n
"
)
+
1
)
-
matchProp
.
length
;
xOffset
=
offset
*
this
.
_inputCharWidth
+
this
.
_paddingInlineStart
;
}
if
(
popupAlignElement
)
{
popup
.
openPopup
(
popupAlignElement
xOffset
yOffset
0
{
preventSelectCallback
:
true
}
)
;
}
}
else
if
(
items
.
length
<
minimumAutoCompleteLength
&
&
popup
.
isOpen
)
{
popup
.
hidePopup
(
)
;
}
this
.
emit
(
"
autocomplete
-
updated
"
)
;
}
onAutocompleteSelect
(
)
{
const
{
selectedItem
}
=
this
.
autocompletePopup
;
if
(
selectedItem
)
{
const
{
preLabel
label
isElementAccess
}
=
selectedItem
;
let
suffix
=
label
.
substring
(
preLabel
.
length
)
;
if
(
isElementAccess
)
{
const
inputBeforeCursor
=
this
.
getInputValueBeforeCursor
(
)
;
if
(
inputBeforeCursor
.
trim
(
)
.
endsWith
(
"
[
"
)
)
{
suffix
=
label
;
}
const
inputAfterCursor
=
this
.
_getValue
(
)
.
substring
(
inputBeforeCursor
.
length
)
;
if
(
!
inputAfterCursor
.
trimLeft
(
)
.
startsWith
(
"
]
"
)
)
{
suffix
=
suffix
+
"
]
"
;
}
}
this
.
setAutoCompletionText
(
suffix
)
;
}
else
{
this
.
setAutoCompletionText
(
"
"
)
;
}
}
clearCompletion
(
)
{
this
.
setAutoCompletionText
(
"
"
)
;
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
clearItems
(
)
;
if
(
this
.
autocompletePopup
.
isOpen
)
{
if
(
this
.
inputNode
)
{
this
.
inputNode
.
blur
(
)
;
}
this
.
autocompletePopup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
this
.
focus
(
)
;
}
)
;
this
.
autocompletePopup
.
hidePopup
(
)
;
}
this
.
emit
(
"
autocomplete
-
updated
"
)
;
}
}
acceptProposedCompletion
(
)
{
let
completionText
=
this
.
getAutoCompletionText
(
)
;
let
numberOfCharsToReplaceCharsBeforeCursor
;
if
(
this
.
autocompletePopup
.
isOpen
&
&
this
.
autocompletePopup
.
selectedItem
)
{
const
{
selectedItem
}
=
this
.
autocompletePopup
;
const
{
label
preLabel
isElementAccess
}
=
selectedItem
;
completionText
=
label
;
numberOfCharsToReplaceCharsBeforeCursor
=
preLabel
.
length
;
if
(
isElementAccess
)
{
const
inputBeforeCursor
=
this
.
getInputValueBeforeCursor
(
)
;
const
lastOpeningBracketIndex
=
inputBeforeCursor
.
lastIndexOf
(
"
[
"
)
;
if
(
lastOpeningBracketIndex
>
-
1
)
{
numberOfCharsToReplaceCharsBeforeCursor
=
inputBeforeCursor
.
substring
(
lastOpeningBracketIndex
+
1
)
.
length
;
}
const
inputAfterCursor
=
this
.
_getValue
(
)
.
substring
(
inputBeforeCursor
.
length
)
;
if
(
!
inputAfterCursor
.
trimLeft
(
)
.
startsWith
(
"
]
"
)
)
{
completionText
=
completionText
+
"
]
"
;
}
}
}
this
.
props
.
autocompleteClear
(
)
;
if
(
completionText
)
{
this
.
insertStringAtCursor
(
completionText
numberOfCharsToReplaceCharsBeforeCursor
)
;
}
}
getInputValueBeforeCursor
(
)
{
if
(
this
.
editor
)
{
return
this
.
editor
.
getDoc
(
)
.
getRange
(
{
line
:
0
ch
:
0
}
this
.
editor
.
getCursor
(
)
)
;
}
if
(
this
.
inputNode
)
{
const
cursor
=
this
.
inputNode
.
selectionStart
;
return
this
.
_getValue
(
)
.
substring
(
0
cursor
)
;
}
return
null
;
}
insertStringAtCursor
(
str
numberOfCharsToReplaceCharsBeforeCursor
=
0
)
{
const
value
=
this
.
_getValue
(
)
;
let
prefix
=
this
.
getInputValueBeforeCursor
(
)
;
const
suffix
=
value
.
replace
(
prefix
"
"
)
;
if
(
numberOfCharsToReplaceCharsBeforeCursor
)
{
prefix
=
prefix
.
substring
(
0
prefix
.
length
-
numberOfCharsToReplaceCharsBeforeCursor
)
;
}
const
editorCursor
=
this
.
editor
&
&
this
.
editor
.
getCursor
(
)
;
const
scrollPosition
=
this
.
inputNode
?
this
.
inputNode
.
parentElement
.
scrollTop
:
null
;
this
.
_setValue
(
prefix
+
str
+
suffix
)
;
if
(
this
.
inputNode
)
{
const
newCursor
=
prefix
.
length
+
str
.
length
;
this
.
inputNode
.
selectionStart
=
this
.
inputNode
.
selectionEnd
=
newCursor
;
this
.
inputNode
.
parentElement
.
scrollTop
=
scrollPosition
;
}
else
if
(
this
.
editor
)
{
this
.
editor
.
setCursor
(
{
line
:
editorCursor
.
line
ch
:
editorCursor
.
ch
+
str
.
length
-
numberOfCharsToReplaceCharsBeforeCursor
}
)
;
}
}
setAutoCompletionText
(
suffix
)
{
if
(
suffix
&
&
!
this
.
canDisplayAutoCompletionText
(
)
)
{
suffix
=
"
"
;
}
if
(
this
.
completeNode
)
{
const
lines
=
this
.
getInputValueBeforeCursor
(
)
.
split
(
"
\
n
"
)
;
const
lastLine
=
lines
[
lines
.
length
-
1
]
;
const
prefix
=
"
\
n
"
.
repeat
(
lines
.
length
-
1
)
+
lastLine
.
replace
(
/
[
\
S
]
/
g
"
"
)
;
this
.
completeNode
.
value
=
suffix
?
prefix
+
suffix
:
"
"
;
}
if
(
this
.
editor
)
{
this
.
editor
.
setAutoCompletionText
(
suffix
)
;
}
}
getAutoCompletionText
(
)
{
if
(
this
.
completeNode
)
{
return
this
.
completeNode
.
value
.
replace
(
/
^
\
s
+
/
gm
"
"
)
;
}
if
(
this
.
editor
)
{
return
this
.
editor
.
getAutoCompletionText
(
)
;
}
return
null
;
}
hasAutocompletionSuggestion
(
)
{
return
(
this
.
getAutoCompletionText
(
)
|
|
(
this
.
autocompletePopup
.
isOpen
&
&
Number
.
isInteger
(
this
.
autocompletePopup
.
selectedIndex
)
&
&
this
.
autocompletePopup
.
selectedIndex
>
-
1
)
)
;
}
canDisplayAutoCompletionText
(
)
{
if
(
this
.
editor
)
{
const
{
ch
line
}
=
this
.
editor
.
getCursor
(
)
;
const
lineContent
=
this
.
editor
.
getLine
(
line
)
;
const
textAfterCursor
=
lineContent
.
substring
(
ch
)
;
return
textAfterCursor
=
=
=
"
"
;
}
if
(
this
.
inputNode
)
{
const
value
=
this
.
_getValue
(
)
;
const
textAfterCursor
=
value
.
substring
(
this
.
inputNode
.
selectionStart
)
;
return
textAfterCursor
.
split
(
"
\
n
"
)
[
0
]
=
=
=
"
"
;
}
return
false
;
}
_getInputCharWidth
(
)
{
if
(
!
this
.
inputNode
&
&
!
this
.
node
)
{
return
null
;
}
if
(
this
.
editor
)
{
return
this
.
editor
.
defaultCharWidth
(
)
;
}
const
doc
=
this
.
webConsoleUI
.
document
;
const
tempLabel
=
doc
.
createElement
(
"
span
"
)
;
const
style
=
tempLabel
.
style
;
style
.
position
=
"
fixed
"
;
style
.
padding
=
"
0
"
;
style
.
margin
=
"
0
"
;
style
.
width
=
"
auto
"
;
style
.
color
=
"
transparent
"
;
WebConsoleUtils
.
copyTextStyles
(
this
.
inputNode
tempLabel
)
;
tempLabel
.
textContent
=
"
x
"
;
doc
.
documentElement
.
appendChild
(
tempLabel
)
;
const
width
=
tempLabel
.
getBoundingClientRect
(
)
.
width
;
tempLabel
.
remove
(
)
;
return
width
;
}
_getInputPaddingInlineStart
(
)
{
if
(
!
this
.
inputNode
)
{
return
null
;
}
const
doc
=
this
.
webConsoleUI
.
document
;
return
new
Number
(
doc
.
defaultView
.
getComputedStyle
(
this
.
inputNode
)
.
paddingInlineStart
.
replace
(
/
[
^
0
-
9
.
]
/
g
"
"
)
)
;
}
onContextMenu
(
e
)
{
this
.
props
.
serviceContainer
.
openEditContextMenu
(
e
)
;
}
destroy
(
)
{
if
(
this
.
autocompletePopup
)
{
this
.
autocompletePopup
.
destroy
(
)
;
this
.
autocompletePopup
=
null
;
}
if
(
this
.
inputNode
)
{
this
.
inputNode
.
removeEventListener
(
"
keypress
"
this
.
_keyPress
)
;
this
.
inputNode
.
removeEventListener
(
"
input
"
this
.
_inputEventHandler
)
;
this
.
inputNode
.
removeEventListener
(
"
keyup
"
this
.
_inputEventHandler
)
;
}
if
(
this
.
editor
)
{
this
.
editor
.
destroy
(
)
;
this
.
editor
=
null
;
}
this
.
webConsoleUI
=
null
;
}
render
(
)
{
if
(
this
.
props
.
webConsoleUI
.
isBrowserConsole
&
&
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
)
{
return
null
;
}
if
(
this
.
props
.
codeMirrorEnabled
)
{
return
dom
.
div
(
{
className
:
"
jsterm
-
input
-
container
devtools
-
input
devtools
-
monospace
"
key
:
"
jsterm
-
container
"
style
:
{
direction
:
"
ltr
"
}
"
aria
-
live
"
:
"
off
"
onContextMenu
:
this
.
onContextMenu
ref
:
node
=
>
{
this
.
node
=
node
;
}
}
)
;
}
const
{
onPaste
}
=
this
.
props
;
return
dom
.
div
(
{
className
:
"
jsterm
-
input
-
container
"
key
:
"
jsterm
-
container
"
style
:
{
direction
:
"
ltr
"
}
"
aria
-
live
"
:
"
off
"
ref
:
node
=
>
{
this
.
node
=
node
;
}
}
dom
.
textarea
(
{
className
:
"
jsterm
-
complete
-
node
devtools
-
monospace
"
key
:
"
complete
"
tabIndex
:
"
-
1
"
ref
:
node
=
>
{
this
.
completeNode
=
node
;
}
}
)
dom
.
textarea
(
{
className
:
"
jsterm
-
input
-
node
devtools
-
monospace
"
key
:
"
input
"
tabIndex
:
"
0
"
rows
:
"
1
"
"
aria
-
autocomplete
"
:
"
list
"
ref
:
node
=
>
{
this
.
inputNode
=
node
;
}
onPaste
:
onPaste
onDrop
:
onPaste
onContextMenu
:
this
.
onContextMenu
}
)
)
;
}
}
function
mapStateToProps
(
state
)
{
return
{
history
:
getHistory
(
state
)
getValueFromHistory
:
direction
=
>
getHistoryValue
(
state
direction
)
autocompleteData
:
getAutocompleteState
(
state
)
}
;
}
function
mapDispatchToProps
(
dispatch
)
{
return
{
appendToHistory
:
expr
=
>
dispatch
(
actions
.
appendToHistory
(
expr
)
)
clearHistory
:
(
)
=
>
dispatch
(
actions
.
clearHistory
(
)
)
updateHistoryPosition
:
(
direction
expression
)
=
>
dispatch
(
actions
.
updateHistoryPosition
(
direction
expression
)
)
autocompleteUpdate
:
(
force
getterPath
)
=
>
dispatch
(
actions
.
autocompleteUpdate
(
force
getterPath
)
)
autocompleteClear
:
(
)
=
>
dispatch
(
actions
.
autocompleteClear
(
)
)
evaluateExpression
:
expression
=
>
dispatch
(
actions
.
evaluateExpression
(
expression
)
)
}
;
}
module
.
exports
=
connect
(
mapStateToProps
mapDispatchToProps
)
(
JSTerm
)
;
