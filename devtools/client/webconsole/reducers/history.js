"
use
strict
"
;
const
{
APPEND_TO_HISTORY
CLEAR_HISTORY
EVALUATE_EXPRESSION
HISTORY_LOADED
UPDATE_HISTORY_POSITION
HISTORY_BACK
HISTORY_FORWARD
REVERSE_SEARCH_INPUT_TOGGLE
REVERSE_SEARCH_INPUT_CHANGE
REVERSE_SEARCH_BACK
REVERSE_SEARCH_NEXT
SET_TERMINAL_INPUT
SET_TERMINAL_EAGER_RESULT
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
function
getInitialState
(
)
{
return
{
entries
:
[
]
position
:
undefined
originalUserValue
:
null
reverseSearchEnabled
:
false
currentReverseSearchResults
:
null
currentReverseSearchResultsPosition
:
null
terminalInput
:
null
terminalEagerResult
:
null
}
;
}
function
history
(
state
=
getInitialState
(
)
action
prefsState
)
{
switch
(
action
.
type
)
{
case
APPEND_TO_HISTORY
:
case
EVALUATE_EXPRESSION
:
return
appendToHistory
(
state
prefsState
action
.
expression
)
;
case
CLEAR_HISTORY
:
return
clearHistory
(
state
)
;
case
HISTORY_LOADED
:
return
historyLoaded
(
state
action
.
entries
)
;
case
UPDATE_HISTORY_POSITION
:
return
updateHistoryPosition
(
state
action
.
direction
action
.
expression
)
;
case
REVERSE_SEARCH_INPUT_TOGGLE
:
return
reverseSearchInputToggle
(
state
action
)
;
case
REVERSE_SEARCH_INPUT_CHANGE
:
return
reverseSearchInputChange
(
state
action
.
value
)
;
case
REVERSE_SEARCH_BACK
:
return
reverseSearchBack
(
state
)
;
case
REVERSE_SEARCH_NEXT
:
return
reverseSearchNext
(
state
)
;
case
SET_TERMINAL_INPUT
:
return
setTerminalInput
(
state
action
.
expression
)
;
case
SET_TERMINAL_EAGER_RESULT
:
return
setTerminalEagerResult
(
state
action
.
expression
action
.
result
)
;
}
return
state
;
}
function
appendToHistory
(
state
prefsState
expression
)
{
state
=
{
.
.
.
state
}
;
state
.
entries
=
[
.
.
.
state
.
entries
]
;
if
(
expression
.
trim
(
)
!
=
state
.
entries
[
state
.
entries
.
length
-
1
]
)
{
state
.
entries
.
push
(
expression
)
;
}
if
(
state
.
entries
.
length
>
prefsState
.
historyCount
)
{
state
.
entries
.
splice
(
0
state
.
entries
.
length
-
prefsState
.
historyCount
)
;
}
state
.
position
=
state
.
entries
.
length
;
state
.
originalUserValue
=
null
;
return
state
;
}
function
clearHistory
(
state
)
{
return
getInitialState
(
)
;
}
function
historyLoaded
(
state
entries
)
{
const
newEntries
=
[
.
.
.
entries
.
.
.
state
.
entries
]
;
return
{
.
.
.
state
entries
:
newEntries
position
:
newEntries
.
length
originalUserValue
:
null
}
;
}
function
updateHistoryPosition
(
state
direction
expression
)
{
if
(
direction
=
=
HISTORY_BACK
)
{
if
(
state
.
position
<
=
0
)
{
return
state
;
}
state
=
{
.
.
.
state
}
;
if
(
state
.
position
=
=
state
.
entries
.
length
)
{
state
.
originalUserValue
=
expression
|
|
"
"
;
}
state
.
position
-
-
;
}
else
if
(
direction
=
=
HISTORY_FORWARD
)
{
if
(
state
.
position
>
=
state
.
entries
.
length
)
{
return
state
;
}
state
=
{
.
.
.
state
position
:
state
.
position
+
1
}
;
}
return
state
;
}
function
reverseSearchInputToggle
(
state
action
)
{
const
{
initialValue
=
"
"
}
=
action
;
if
(
state
.
reverseSearchEnabled
)
{
return
{
.
.
.
state
reverseSearchEnabled
:
false
position
:
undefined
currentReverseSearchResults
:
null
currentReverseSearchResultsPosition
:
null
}
;
}
return
reverseSearchInputChange
(
state
initialValue
)
;
}
function
reverseSearchInputChange
(
state
searchString
)
{
if
(
searchString
=
=
=
"
"
)
{
return
{
.
.
.
state
position
:
undefined
currentReverseSearchResults
:
null
currentReverseSearchResultsPosition
:
null
}
;
}
searchString
=
searchString
.
toLocaleLowerCase
(
)
;
const
matchingEntries
=
state
.
entries
.
filter
(
entry
=
>
entry
.
toLocaleLowerCase
(
)
.
includes
(
searchString
)
)
;
const
uniqueEntries
=
new
Set
(
matchingEntries
.
reverse
(
)
)
;
const
currentReverseSearchResults
=
Array
.
from
(
new
Set
(
uniqueEntries
)
)
.
reverse
(
)
;
return
{
.
.
.
state
position
:
undefined
currentReverseSearchResults
currentReverseSearchResultsPosition
:
currentReverseSearchResults
.
length
-
1
}
;
}
function
reverseSearchBack
(
state
)
{
let
nextPosition
=
state
.
currentReverseSearchResultsPosition
-
1
;
if
(
nextPosition
<
0
)
{
nextPosition
=
state
.
currentReverseSearchResults
.
length
-
1
;
}
return
{
.
.
.
state
currentReverseSearchResultsPosition
:
nextPosition
}
;
}
function
reverseSearchNext
(
state
)
{
let
previousPosition
=
state
.
currentReverseSearchResultsPosition
+
1
;
if
(
previousPosition
>
=
state
.
currentReverseSearchResults
.
length
)
{
previousPosition
=
0
;
}
return
{
.
.
.
state
currentReverseSearchResultsPosition
:
previousPosition
}
;
}
function
setTerminalInput
(
state
expression
)
{
return
{
.
.
.
state
terminalInput
:
expression
terminalEagerResult
:
!
expression
?
null
:
state
.
terminalEagerResult
}
;
}
function
setTerminalEagerResult
(
state
expression
result
)
{
if
(
state
.
terminalInput
=
=
expression
)
{
return
{
.
.
.
state
terminalEagerResult
:
result
}
;
}
return
state
;
}
exports
.
history
=
history
;
