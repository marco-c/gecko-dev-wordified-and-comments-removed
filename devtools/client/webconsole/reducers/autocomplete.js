"
use
strict
"
;
const
{
AUTOCOMPLETE_CLEAR
AUTOCOMPLETE_DATA_RECEIVE
AUTOCOMPLETE_PENDING_REQUEST
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
function
getDefaultState
(
)
{
return
Object
.
freeze
(
{
cache
:
null
matches
:
[
]
matchProp
:
null
isElementAccess
:
false
pendingRequestId
:
null
}
)
;
}
function
autocomplete
(
state
=
getDefaultState
(
)
action
)
{
switch
(
action
.
type
)
{
case
AUTOCOMPLETE_CLEAR
:
return
getDefaultState
(
)
;
case
AUTOCOMPLETE_RETRIEVE_FROM_CACHE
:
return
autoCompleteRetrieveFromCache
(
state
action
)
;
case
AUTOCOMPLETE_PENDING_REQUEST
:
return
{
.
.
.
state
cache
:
null
pendingRequestId
:
action
.
id
}
;
case
AUTOCOMPLETE_DATA_RECEIVE
:
if
(
action
.
id
!
=
=
state
.
pendingRequestId
)
{
return
state
;
}
if
(
action
.
data
.
matches
=
=
=
null
)
{
return
getDefaultState
(
)
;
}
return
{
.
.
.
state
cache
:
{
input
:
action
.
input
frameActorId
:
action
.
frameActorId
.
.
.
action
.
data
}
pendingRequestId
:
null
.
.
.
action
.
data
}
;
}
return
state
;
}
function
autoCompleteRetrieveFromCache
(
state
action
)
{
const
{
input
}
=
action
;
const
{
cache
}
=
state
;
let
filterBy
=
input
;
if
(
cache
.
isElementAccess
)
{
filterBy
=
input
.
substring
(
input
.
lastIndexOf
(
"
[
"
)
+
1
)
;
}
else
{
const
lastNonAlpha
=
input
.
match
(
/
[
^
a
-
zA
-
Z0
-
9_
:
]
[
a
-
zA
-
Z0
-
9_
:
]
*
/
)
;
if
(
lastNonAlpha
)
{
filterBy
=
input
.
substring
(
input
.
lastIndexOf
(
lastNonAlpha
)
+
1
)
;
}
}
const
stripWrappingQuotes
=
s
=
>
s
.
replace
(
/
^
[
'
"
]
(
.
+
(
?
=
[
'
"
]
)
)
[
'
"
]
/
g
"
1
"
)
;
const
filterByLc
=
filterBy
.
toLocaleLowerCase
(
)
;
const
looseMatching
=
!
filterBy
|
|
filterBy
[
0
]
.
toLocaleLowerCase
(
)
=
=
=
filterBy
[
0
]
;
const
needStripQuote
=
cache
.
isElementAccess
&
&
!
/
^
[
"
'
]
/
.
test
(
filterBy
)
;
const
newList
=
cache
.
matches
.
filter
(
l
=
>
{
if
(
needStripQuote
)
{
l
=
stripWrappingQuotes
(
l
)
;
}
if
(
looseMatching
)
{
return
l
.
toLocaleLowerCase
(
)
.
startsWith
(
filterByLc
)
;
}
return
l
.
startsWith
(
filterBy
)
;
}
)
;
return
{
.
.
.
state
matches
:
newList
matchProp
:
filterBy
isElementAccess
:
cache
.
isElementAccess
}
;
}
exports
.
autocomplete
=
autocomplete
;
