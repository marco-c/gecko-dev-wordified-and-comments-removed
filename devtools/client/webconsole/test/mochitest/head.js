"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
test
-
actor
-
registry
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
var
{
HUDService
}
=
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
;
var
WCUL10n
=
require
(
"
devtools
/
client
/
webconsole
/
webconsole
-
l10n
"
)
;
const
DOCS_GA_PARAMS
=
?
{
new
URLSearchParams
(
{
"
utm_source
"
:
"
mozilla
"
"
utm_medium
"
:
"
firefox
-
console
-
errors
"
"
utm_campaign
"
:
"
default
"
}
)
}
;
const
STATUS_CODES_GA_PARAMS
=
?
{
new
URLSearchParams
(
{
"
utm_source
"
:
"
mozilla
"
"
utm_medium
"
:
"
devtools
-
webconsole
"
"
utm_campaign
"
:
"
default
"
}
)
}
;
const
wcActions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
webconsole
.
ui
.
filterbar
"
)
;
await
SpecialPowers
.
flushPrefEnv
(
)
;
Services
.
prefs
.
getChildList
(
"
devtools
.
webconsole
.
filter
"
)
.
forEach
(
pref
=
>
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
)
;
const
browserConsole
=
HUDService
.
getBrowserConsole
(
)
;
if
(
browserConsole
)
{
if
(
browserConsole
.
jsterm
)
{
browserConsole
.
jsterm
.
clearOutput
(
true
)
;
}
await
HUDService
.
toggleBrowserConsole
(
)
;
}
}
)
;
async
function
openNewTabAndConsole
(
url
clearJstermHistory
=
true
)
{
const
toolbox
=
await
openNewTabAndToolbox
(
url
"
webconsole
"
)
;
const
hud
=
toolbox
.
getCurrentPanel
(
)
.
hud
;
hud
.
jsterm
.
_lazyVariablesView
=
false
;
if
(
clearJstermHistory
)
{
await
hud
.
ui
.
consoleOutput
.
dispatchClearHistory
(
)
;
}
return
hud
;
}
function
logAllStoreChanges
(
hud
)
{
const
store
=
hud
.
ui
.
consoleOutput
.
getStore
(
)
;
store
.
subscribe
(
(
)
=
>
{
const
messages
=
[
.
.
.
store
.
getState
(
)
.
messages
.
messagesById
.
values
(
)
]
;
const
debugMessages
=
messages
.
map
(
(
{
id
type
parameters
messageText
}
)
=
>
{
return
{
id
type
parameters
messageText
}
;
}
)
;
info
(
"
messages
:
"
+
JSON
.
stringify
(
debugMessages
)
)
;
}
)
;
}
function
waitForMessages
(
{
hud
messages
}
)
{
return
new
Promise
(
resolve
=
>
{
const
matchedMessages
=
[
]
;
hud
.
ui
.
on
(
"
new
-
messages
"
function
messagesReceived
(
newMessages
)
{
for
(
const
message
of
messages
)
{
if
(
message
.
matched
)
{
continue
;
}
for
(
const
newMessage
of
newMessages
)
{
const
messageBody
=
newMessage
.
node
.
querySelector
(
"
.
message
-
body
"
)
;
if
(
messageBody
.
textContent
.
includes
(
message
.
text
)
)
{
matchedMessages
.
push
(
newMessage
)
;
message
.
matched
=
true
;
const
messagesLeft
=
messages
.
length
-
matchedMessages
.
length
;
info
(
Matched
a
message
with
text
:
"
{
message
.
text
}
"
+
(
messagesLeft
>
0
?
still
waiting
for
{
messagesLeft
}
messages
.
:
all
messages
received
.
)
)
;
break
;
}
}
if
(
matchedMessages
.
length
=
=
=
messages
.
length
)
{
hud
.
ui
.
off
(
"
new
-
messages
"
messagesReceived
)
;
resolve
(
matchedMessages
)
;
return
;
}
}
}
)
;
}
)
;
}
function
waitForRepeatedMessage
(
hud
text
repeat
)
{
return
waitFor
(
(
)
=
>
{
const
node
=
findMessage
(
hud
text
)
;
if
(
!
node
)
{
return
false
;
}
const
repeatNode
=
node
.
querySelector
(
"
.
message
-
repeats
"
)
;
if
(
repeatNode
&
&
parseInt
(
repeatNode
.
textContent
10
)
=
=
=
repeat
)
{
return
node
;
}
return
false
;
}
)
;
}
async
function
waitForMessage
(
hud
text
)
{
const
messages
=
await
waitForMessages
(
{
hud
messages
:
[
{
text
}
]
}
)
;
return
messages
[
0
]
;
}
async
function
waitFor
(
condition
message
=
"
waitFor
"
interval
=
10
maxTries
=
500
)
{
await
BrowserTestUtils
.
waitForCondition
(
condition
message
interval
maxTries
)
;
return
condition
(
)
;
}
function
findMessage
(
hud
text
selector
=
"
.
message
"
)
{
const
elements
=
findMessages
(
hud
text
selector
)
;
return
elements
.
pop
(
)
;
}
function
findMessages
(
hud
text
selector
=
"
.
message
"
)
{
const
messages
=
hud
.
ui
.
outputNode
.
querySelectorAll
(
selector
)
;
const
elements
=
Array
.
prototype
.
filter
.
call
(
messages
(
el
)
=
>
el
.
textContent
.
includes
(
text
)
)
;
return
elements
;
}
async
function
openContextMenu
(
hud
element
)
{
const
onConsoleMenuOpened
=
hud
.
ui
.
consoleOutput
.
once
(
"
menu
-
open
"
)
;
synthesizeContextMenuEvent
(
element
)
;
await
onConsoleMenuOpened
;
const
doc
=
hud
.
ui
.
consoleOutput
.
owner
.
chromeWindow
.
document
;
return
doc
.
getElementById
(
"
webconsole
-
menu
"
)
;
}
function
hideContextMenu
(
hud
)
{
const
doc
=
hud
.
ui
.
consoleOutput
.
owner
.
chromeWindow
.
document
;
const
popup
=
doc
.
getElementById
(
"
webconsole
-
menu
"
)
;
if
(
!
popup
)
{
return
Promise
.
resolve
(
)
;
}
const
onPopupHidden
=
once
(
popup
"
popuphidden
"
)
;
popup
.
hidePopup
(
)
;
return
onPopupHidden
;
}
function
loadDocument
(
url
browser
=
gBrowser
.
selectedBrowser
)
{
BrowserTestUtils
.
loadURI
(
browser
url
)
;
return
BrowserTestUtils
.
browserLoaded
(
browser
)
;
}
function
waitForNodeMutation
(
node
observeConfig
=
{
}
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
MutationObserver
(
mutations
=
>
{
resolve
(
mutations
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
node
observeConfig
)
;
}
)
;
}
async
function
testOpenInDebugger
(
hud
toolbox
text
)
{
info
(
Finding
message
for
open
-
in
-
debugger
test
;
text
is
"
{
text
}
"
)
;
const
messageNode
=
await
waitFor
(
(
)
=
>
findMessage
(
hud
text
)
)
;
const
frameLinkNode
=
messageNode
.
querySelector
(
"
.
message
-
location
.
frame
-
link
"
)
;
ok
(
frameLinkNode
"
The
message
does
have
a
location
link
"
)
;
await
checkClickOnNode
(
hud
toolbox
frameLinkNode
)
;
}
async
function
checkClickOnNode
(
hud
toolbox
frameLinkNode
)
{
info
(
"
checking
click
on
node
location
"
)
;
const
url
=
frameLinkNode
.
getAttribute
(
"
data
-
url
"
)
;
ok
(
url
source
url
found
(
"
{
url
}
"
)
)
;
const
line
=
frameLinkNode
.
getAttribute
(
"
data
-
line
"
)
;
ok
(
line
source
line
found
(
"
{
line
}
"
)
)
;
const
onSourceInDebuggerOpened
=
once
(
hud
.
ui
"
source
-
in
-
debugger
-
opened
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
frameLinkNode
.
querySelector
(
"
.
frame
-
link
-
filename
"
)
)
;
await
onSourceInDebuggerOpened
;
const
dbg
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
is
(
dbg
.
_selectors
.
getSelectedSource
(
dbg
.
_getState
(
)
)
.
get
(
"
url
"
)
url
"
expected
source
url
"
)
;
}
function
hasFocus
(
node
)
{
return
node
.
ownerDocument
.
activeElement
=
=
node
&
&
node
.
ownerDocument
.
hasFocus
(
)
;
}
function
jstermSetValueAndComplete
(
jsterm
value
caretIndexOffset
=
0
completionType
)
{
const
{
inputNode
}
=
jsterm
;
inputNode
.
value
=
value
;
const
index
=
value
.
length
+
caretIndexOffset
;
inputNode
.
setSelectionRange
(
index
index
)
;
return
jstermComplete
(
jsterm
completionType
)
;
}
function
jstermComplete
(
jsterm
completionType
=
jsterm
.
COMPLETE_HINT_ONLY
)
{
const
updated
=
jsterm
.
once
(
"
autocomplete
-
updated
"
)
;
jsterm
.
complete
(
completionType
)
;
return
updated
;
}
async
function
openDebugger
(
options
=
{
}
)
{
if
(
!
options
.
tab
)
{
options
.
tab
=
gBrowser
.
selectedTab
;
}
const
target
=
TargetFactory
.
forTab
(
options
.
tab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
const
dbgPanelAlreadyOpen
=
toolbox
&
&
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
if
(
dbgPanelAlreadyOpen
)
{
await
toolbox
.
selectTool
(
"
jsdebugger
"
)
;
return
{
target
toolbox
panel
:
toolbox
.
getCurrentPanel
(
)
}
;
}
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
jsdebugger
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
panel
.
_view
.
Variables
.
lazyEmpty
=
false
;
await
panel
.
panelWin
.
DebuggerController
.
waitForSourcesLoaded
(
)
;
return
{
target
toolbox
panel
}
;
}
async
function
openInspector
(
options
=
{
}
)
{
if
(
!
options
.
tab
)
{
options
.
tab
=
gBrowser
.
selectedTab
;
}
const
target
=
TargetFactory
.
forTab
(
options
.
tab
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
inspector
"
)
;
return
toolbox
.
getCurrentPanel
(
)
;
}
async
function
openConsole
(
tab
)
{
const
target
=
TargetFactory
.
forTab
(
tab
|
|
gBrowser
.
selectedTab
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
webconsole
"
)
;
return
toolbox
.
getCurrentPanel
(
)
.
hud
;
}
async
function
closeConsole
(
tab
=
gBrowser
.
selectedTab
)
{
const
target
=
TargetFactory
.
forTab
(
tab
)
;
const
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
await
toolbox
.
destroy
(
)
;
}
}
function
simulateLinkClick
(
element
clickEventProps
)
{
const
oldOpenTrustedLinkIn
=
window
.
openTrustedLinkIn
;
const
oldOpenWebLinkIn
=
window
.
openWebLinkIn
;
const
onOpenLink
=
new
Promise
(
(
resolve
)
=
>
{
window
.
openWebLinkIn
=
window
.
openTrustedLinkIn
=
function
(
link
where
)
{
window
.
openTrustedLinkIn
=
oldOpenTrustedLinkIn
;
window
.
openWebLinkIn
=
oldOpenWebLinkIn
;
resolve
(
{
link
:
link
where
}
)
;
}
;
if
(
clickEventProps
)
{
element
.
dispatchEvent
(
clickEventProps
)
;
}
else
{
element
.
click
(
)
;
}
}
)
;
let
timeoutId
;
const
onTimeout
=
new
Promise
(
function
(
resolve
)
{
timeoutId
=
setTimeout
(
(
)
=
>
{
window
.
openTrustedLinkIn
=
oldOpenTrustedLinkIn
;
window
.
openWebLinkIn
=
oldOpenWebLinkIn
;
timeoutId
=
null
;
resolve
(
{
link
:
null
where
:
null
}
)
;
}
1000
)
;
}
)
;
onOpenLink
.
then
(
(
)
=
>
{
if
(
timeoutId
)
{
clearTimeout
(
timeoutId
)
;
}
}
)
;
return
Promise
.
race
(
[
onOpenLink
onTimeout
]
)
;
}
function
openNewBrowserWindow
(
options
)
{
const
win
=
OpenBrowserWindow
(
options
)
;
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
)
{
if
(
win
=
=
subject
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
win
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
}
async
function
openMessageInNetmonitor
(
toolbox
hud
url
urlInConsole
)
{
urlInConsole
=
urlInConsole
|
|
url
;
const
message
=
await
waitFor
(
(
)
=
>
findMessage
(
hud
urlInConsole
)
)
;
const
onNetmonitorSelected
=
toolbox
.
once
(
"
netmonitor
-
selected
"
(
event
panel
)
=
>
{
return
panel
;
}
)
;
const
menuPopup
=
await
openContextMenu
(
hud
message
)
;
const
openInNetMenuItem
=
menuPopup
.
querySelector
(
"
#
console
-
menu
-
open
-
in
-
network
-
panel
"
)
;
ok
(
openInNetMenuItem
"
open
in
network
panel
item
is
enabled
"
)
;
openInNetMenuItem
.
click
(
)
;
const
{
panelWin
}
=
await
onNetmonitorSelected
;
ok
(
true
"
The
netmonitor
panel
is
selected
when
clicking
on
the
network
message
"
)
;
const
{
store
windowRequire
}
=
panelWin
;
const
nmActions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
const
{
getSelectedRequest
}
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
selectors
/
index
"
)
;
store
.
dispatch
(
nmActions
.
batchEnable
(
false
)
)
;
await
waitUntil
(
(
)
=
>
{
const
selected
=
getSelectedRequest
(
store
.
getState
(
)
)
;
return
selected
&
&
selected
.
url
=
=
=
url
;
}
)
;
ok
(
true
"
The
attached
url
is
correct
.
"
)
;
}
function
selectNode
(
hud
node
)
{
const
outputContainer
=
hud
.
ui
.
outputNode
.
querySelector
(
"
.
webconsole
-
output
"
)
;
outputContainer
.
ownerDocument
.
activeElement
.
blur
(
)
;
const
selection
=
outputContainer
.
ownerDocument
.
getSelection
(
)
;
const
range
=
document
.
createRange
(
)
;
range
.
selectNodeContents
(
node
)
;
selection
.
removeAllRanges
(
)
;
selection
.
addRange
(
range
)
;
return
selection
;
}
async
function
waitForBrowserConsole
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
)
{
Services
.
obs
.
removeObserver
(
observer
"
web
-
console
-
created
"
)
;
subject
.
QueryInterface
(
Ci
.
nsISupportsString
)
;
const
hud
=
HUDService
.
getBrowserConsole
(
)
;
ok
(
hud
"
browser
console
is
open
"
)
;
is
(
subject
.
data
hud
.
hudId
"
notification
hudId
is
correct
"
)
;
executeSoon
(
(
)
=
>
resolve
(
hud
)
)
;
}
"
web
-
console
-
created
"
)
;
}
)
;
}
async
function
getFilterState
(
hud
)
{
const
filterBar
=
await
setFilterBarVisible
(
hud
true
)
;
const
buttons
=
filterBar
.
querySelectorAll
(
"
button
"
)
;
const
result
=
{
}
;
for
(
const
button
of
buttons
)
{
const
classes
=
new
Set
(
button
.
classList
.
values
(
)
)
;
const
checked
=
classes
.
has
(
"
checked
"
)
;
classes
.
delete
(
"
devtools
-
button
"
)
;
classes
.
delete
(
"
checked
"
)
;
const
category
=
classes
.
values
(
)
.
next
(
)
.
value
;
result
[
category
]
=
checked
;
}
return
result
;
}
async
function
setFilterState
(
hud
settings
)
{
const
filterBar
=
await
setFilterBarVisible
(
hud
true
)
;
for
(
const
category
in
settings
)
{
const
setActive
=
settings
[
category
]
;
const
button
=
filterBar
.
querySelector
(
.
{
category
}
)
;
if
(
!
button
)
{
ok
(
false
setFilterState
(
)
called
with
a
category
of
{
category
}
+
which
doesn
'
t
exist
.
)
;
}
info
(
Setting
the
{
category
}
category
to
{
setActive
?
"
checked
"
:
"
disabled
"
}
)
;
const
isChecked
=
button
.
classList
.
contains
(
"
checked
"
)
;
if
(
setActive
!
=
=
isChecked
)
{
button
.
click
(
)
;
await
waitFor
(
(
)
=
>
{
return
button
.
classList
.
contains
(
"
checked
"
)
=
=
=
setActive
;
}
)
;
}
}
}
async
function
setFilterBarVisible
(
hud
state
)
{
info
(
Setting
the
filter
bar
visibility
to
{
state
}
)
;
const
outputNode
=
hud
.
ui
.
outputNode
;
const
toolbar
=
await
waitFor
(
(
)
=
>
{
return
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
primary
"
)
;
}
)
;
let
filterBar
=
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
secondary
"
)
;
if
(
state
)
{
if
(
!
filterBar
)
{
toolbar
.
querySelector
(
"
.
devtools
-
filter
-
icon
"
)
.
click
(
)
;
filterBar
=
await
waitFor
(
(
)
=
>
{
return
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
secondary
"
)
;
}
)
;
}
return
filterBar
;
}
if
(
filterBar
)
{
toolbar
.
querySelector
(
"
.
devtools
-
filter
-
icon
"
)
.
click
(
)
;
await
waitFor
(
(
)
=
>
{
return
!
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
secondary
"
)
;
}
)
;
}
return
null
;
}
async
function
resetFilters
(
hud
)
{
info
(
"
Resetting
filters
to
their
default
state
"
)
;
const
store
=
hud
.
ui
.
consoleOutput
.
getStore
(
)
;
store
.
dispatch
(
wcActions
.
filtersClear
(
)
)
;
}
