"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
test
-
actor
-
registry
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
debugger
/
test
/
mochitest
/
helpers
/
context
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
debugger
/
test
/
mochitest
/
helpers
.
js
"
this
)
;
var
{
HUDService
}
=
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
;
var
WCUL10n
=
require
(
"
devtools
/
client
/
webconsole
/
webconsole
-
l10n
"
)
;
const
DOCS_GA_PARAMS
=
?
{
new
URLSearchParams
(
{
"
utm_source
"
:
"
mozilla
"
"
utm_medium
"
:
"
firefox
-
console
-
errors
"
"
utm_campaign
"
:
"
default
"
}
)
}
;
const
GA_PARAMS
=
?
{
new
URLSearchParams
(
{
"
utm_source
"
:
"
mozilla
"
"
utm_medium
"
:
"
devtools
-
webconsole
"
"
utm_campaign
"
:
"
default
"
}
)
}
;
const
wcActions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
webconsole
.
ui
.
filterbar
"
)
;
await
SpecialPowers
.
flushPrefEnv
(
)
;
Services
.
prefs
.
getChildList
(
"
devtools
.
webconsole
.
filter
"
)
.
forEach
(
pref
=
>
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
)
;
const
browserConsole
=
HUDService
.
getBrowserConsole
(
)
;
if
(
browserConsole
)
{
browserConsole
.
ui
.
clearOutput
(
true
)
;
await
HUDService
.
toggleBrowserConsole
(
)
;
}
}
)
;
async
function
openNewTabAndConsole
(
url
clearJstermHistory
=
true
)
{
const
toolbox
=
await
openNewTabAndToolbox
(
url
"
webconsole
"
)
;
const
hud
=
toolbox
.
getCurrentPanel
(
)
.
hud
;
if
(
clearJstermHistory
)
{
await
hud
.
ui
.
wrapper
.
dispatchClearHistory
(
)
;
}
return
hud
;
}
async
function
openNewWindowAndConsole
(
url
)
{
const
win
=
await
openNewBrowserWindow
(
)
;
const
tab
=
await
addTab
(
url
{
window
:
win
}
)
;
win
.
gBrowser
.
selectedTab
=
tab
;
const
hud
=
await
openConsole
(
tab
)
;
return
{
win
hud
tab
}
;
}
function
logAllStoreChanges
(
hud
)
{
const
store
=
hud
.
ui
.
wrapper
.
getStore
(
)
;
store
.
subscribe
(
(
)
=
>
{
const
messages
=
[
.
.
.
store
.
getState
(
)
.
messages
.
messagesById
.
values
(
)
]
;
const
debugMessages
=
messages
.
map
(
(
{
id
type
parameters
messageText
}
)
=
>
{
return
{
id
type
parameters
messageText
}
;
}
)
;
info
(
"
messages
:
"
+
JSON
.
stringify
(
debugMessages
)
)
;
}
)
;
}
function
waitForMessages
(
{
hud
messages
selector
=
"
.
message
"
}
)
{
return
new
Promise
(
resolve
=
>
{
const
matchedMessages
=
[
]
;
hud
.
ui
.
on
(
"
new
-
messages
"
function
messagesReceived
(
newMessages
)
{
for
(
const
message
of
messages
)
{
if
(
message
.
matched
)
{
continue
;
}
for
(
const
newMessage
of
newMessages
)
{
const
messageBody
=
newMessage
.
node
.
querySelector
(
.
message
-
body
)
;
if
(
messageBody
&
&
newMessage
.
node
.
matches
(
selector
)
&
&
messageBody
.
textContent
.
includes
(
message
.
text
)
)
{
matchedMessages
.
push
(
newMessage
)
;
message
.
matched
=
true
;
const
messagesLeft
=
messages
.
length
-
matchedMessages
.
length
;
info
(
Matched
a
message
with
text
:
"
{
message
.
text
}
"
+
(
messagesLeft
>
0
?
still
waiting
for
{
messagesLeft
}
messages
.
:
all
messages
received
.
)
)
;
break
;
}
}
if
(
matchedMessages
.
length
=
=
=
messages
.
length
)
{
hud
.
ui
.
off
(
"
new
-
messages
"
messagesReceived
)
;
resolve
(
matchedMessages
)
;
return
;
}
}
}
)
;
}
)
;
}
function
waitForRepeatedMessage
(
hud
text
repeat
)
{
return
waitFor
(
(
)
=
>
{
const
node
=
findMessage
(
hud
text
)
;
if
(
!
node
)
{
return
false
;
}
const
repeatNode
=
node
.
querySelector
(
"
.
message
-
repeats
"
)
;
if
(
repeatNode
&
&
parseInt
(
repeatNode
.
textContent
10
)
=
=
=
repeat
)
{
return
node
;
}
return
false
;
}
)
;
}
async
function
waitForMessage
(
hud
text
selector
)
{
const
messages
=
await
waitForMessages
(
{
hud
messages
:
[
{
text
}
]
selector
}
)
;
return
messages
[
0
]
;
}
function
executeAndWaitForMessage
(
hud
input
matchingText
selector
=
"
.
message
"
)
{
const
onMessage
=
waitForMessage
(
hud
matchingText
selector
)
;
hud
.
jsterm
.
execute
(
input
)
;
return
onMessage
;
}
async
function
waitFor
(
condition
message
=
"
waitFor
"
interval
=
10
maxTries
=
500
)
{
await
BrowserTestUtils
.
waitForCondition
(
condition
message
interval
maxTries
)
;
return
condition
(
)
;
}
function
findMessage
(
hud
text
selector
=
"
.
message
"
)
{
const
elements
=
findMessages
(
hud
text
selector
)
;
return
elements
.
pop
(
)
;
}
function
findMessages
(
hud
text
selector
=
"
.
message
"
)
{
const
messages
=
hud
.
ui
.
outputNode
.
querySelectorAll
(
selector
)
;
const
elements
=
Array
.
prototype
.
filter
.
call
(
messages
(
el
)
=
>
el
.
textContent
.
includes
(
text
)
)
;
return
elements
;
}
async
function
openContextMenu
(
hud
element
)
{
const
onConsoleMenuOpened
=
hud
.
ui
.
wrapper
.
once
(
"
menu
-
open
"
)
;
synthesizeContextMenuEvent
(
element
)
;
await
onConsoleMenuOpened
;
return
_getContextMenu
(
hud
)
;
}
function
hideContextMenu
(
hud
)
{
const
popup
=
_getContextMenu
(
hud
)
;
if
(
!
popup
)
{
return
Promise
.
resolve
(
)
;
}
const
onPopupHidden
=
once
(
popup
"
popuphidden
"
)
;
popup
.
hidePopup
(
)
;
return
onPopupHidden
;
}
function
_getContextMenu
(
hud
)
{
const
toolbox
=
gDevTools
.
getToolbox
(
hud
.
target
)
;
const
doc
=
toolbox
?
toolbox
.
topWindow
.
document
:
hud
.
chromeWindow
.
document
;
return
doc
.
getElementById
(
"
webconsole
-
menu
"
)
;
}
function
loadDocument
(
url
browser
=
gBrowser
.
selectedBrowser
)
{
BrowserTestUtils
.
loadURI
(
browser
url
)
;
return
BrowserTestUtils
.
browserLoaded
(
browser
)
;
}
function
waitForNodeMutation
(
node
observeConfig
=
{
}
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
MutationObserver
(
mutations
=
>
{
resolve
(
mutations
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
node
observeConfig
)
;
}
)
;
}
async
function
testOpenInDebugger
(
hud
toolbox
text
expectUrl
=
true
expectLine
=
true
expectColumn
=
true
)
{
info
(
Finding
message
for
open
-
in
-
debugger
test
;
text
is
"
{
text
}
"
)
;
const
messageNode
=
await
waitFor
(
(
)
=
>
findMessage
(
hud
text
)
)
;
const
frameLinkNode
=
messageNode
.
querySelector
(
"
.
message
-
location
.
frame
-
link
"
)
;
ok
(
frameLinkNode
"
The
message
does
have
a
location
link
"
)
;
await
checkClickOnNode
(
hud
toolbox
frameLinkNode
expectUrl
expectLine
expectColumn
)
;
}
async
function
checkClickOnNode
(
hud
toolbox
frameLinkNode
expectUrl
expectLine
expectColumn
)
{
info
(
"
checking
click
on
node
location
"
)
;
const
onSourceInDebuggerOpened
=
once
(
hud
.
ui
"
source
-
in
-
debugger
-
opened
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
frameLinkNode
.
querySelector
(
"
.
frame
-
link
-
filename
"
)
)
;
await
onSourceInDebuggerOpened
;
const
dbg
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
await
waitFor
(
(
)
=
>
!
!
dbg
.
_selectors
.
getSelectedSource
(
dbg
.
_getState
(
)
)
&
&
!
!
dbg
.
_selectors
.
getSelectedLocation
(
dbg
.
_getState
(
)
)
)
;
if
(
expectUrl
)
{
const
url
=
frameLinkNode
.
getAttribute
(
"
data
-
url
"
)
;
ok
(
url
source
url
found
(
"
{
url
}
"
)
)
;
is
(
dbg
.
_selectors
.
getSelectedSource
(
dbg
.
_getState
(
)
)
.
url
url
"
expected
source
url
"
)
;
}
if
(
expectLine
)
{
const
line
=
frameLinkNode
.
getAttribute
(
"
data
-
line
"
)
;
ok
(
line
source
line
found
(
"
{
line
}
"
)
)
;
is
(
dbg
.
_selectors
.
getSelectedLocation
(
dbg
.
_getState
(
)
)
.
line
line
"
expected
source
line
"
)
;
}
if
(
expectColumn
)
{
const
column
=
frameLinkNode
.
getAttribute
(
"
data
-
column
"
)
;
ok
(
column
source
column
found
(
"
{
column
}
"
)
)
;
is
(
dbg
.
_selectors
.
getSelectedLocation
(
dbg
.
_getState
(
)
)
.
column
column
"
expected
source
column
"
)
;
}
}
function
hasFocus
(
node
)
{
return
node
.
ownerDocument
.
activeElement
=
=
node
&
&
node
.
ownerDocument
.
hasFocus
(
)
;
}
function
getInputValue
(
hud
)
{
return
hud
.
jsterm
.
_getValue
(
)
;
}
function
setInputValue
(
hud
value
)
{
return
hud
.
jsterm
.
_setValue
(
value
)
;
}
async
function
setInputValueForAutocompletion
(
hud
value
caretPosition
=
value
.
length
)
{
const
{
jsterm
}
=
hud
;
setInputValue
(
hud
"
"
)
;
jsterm
.
focus
(
)
;
const
updated
=
jsterm
.
once
(
"
autocomplete
-
updated
"
)
;
EventUtils
.
sendString
(
value
)
;
await
updated
;
if
(
caretPosition
<
0
)
{
caretPosition
=
value
.
length
+
caretPosition
;
}
if
(
Number
.
isInteger
(
caretPosition
)
)
{
if
(
jsterm
.
inputNode
)
{
const
{
inputNode
}
=
jsterm
;
inputNode
.
value
=
value
;
inputNode
.
setSelectionRange
(
caretPosition
caretPosition
)
;
}
if
(
jsterm
.
editor
)
{
jsterm
.
editor
.
setCursor
(
jsterm
.
editor
.
getPosition
(
caretPosition
)
)
;
}
}
}
async
function
setInputValueForGetterConfirmDialog
(
toolbox
hud
value
)
{
await
setInputValueForAutocompletion
(
hud
value
)
;
await
waitFor
(
(
)
=
>
isConfirmDialogOpened
(
toolbox
)
)
;
ok
(
true
"
The
confirm
dialog
is
displayed
"
)
;
return
getConfirmDialog
(
toolbox
)
;
}
function
checkInputCompletionValue
(
hud
expectedValue
assertionInfo
)
{
const
completionValue
=
getInputCompletionValue
(
hud
)
;
if
(
completionValue
=
=
=
null
)
{
ok
(
false
"
Couldn
'
t
retrieve
the
completion
value
"
)
;
}
info
(
Expects
"
{
expectedValue
}
"
is
"
{
completionValue
}
"
)
;
if
(
hud
.
jsterm
.
completeNode
)
{
is
(
completionValue
expectedValue
assertionInfo
)
;
}
else
{
is
(
completionValue
expectedValue
.
trim
(
)
assertionInfo
)
;
}
}
function
checkInputCursorPosition
(
hud
expectedCursorIndex
assertionInfo
)
{
const
{
jsterm
}
=
hud
;
if
(
jsterm
.
inputNode
)
{
const
{
selectionStart
selectionEnd
}
=
jsterm
.
inputNode
;
is
(
selectionStart
expectedCursorIndex
assertionInfo
)
;
ok
(
selectionStart
=
=
=
selectionEnd
)
;
}
else
{
is
(
jsterm
.
editor
.
getCursor
(
)
.
ch
expectedCursorIndex
assertionInfo
)
;
}
}
function
checkInputValueAndCursorPosition
(
hud
expectedStringWithCursor
assertionInfo
)
{
info
(
Checking
jsterm
state
:
\
n
{
expectedStringWithCursor
}
)
;
if
(
!
expectedStringWithCursor
.
includes
(
"
|
"
)
)
{
ok
(
false
expectedStringWithCursor
must
contain
a
"
|
"
char
to
indicate
cursor
position
)
;
}
const
inputValue
=
expectedStringWithCursor
.
replace
(
"
|
"
"
"
)
;
const
{
jsterm
}
=
hud
;
is
(
getInputValue
(
hud
)
inputValue
"
console
input
has
expected
value
"
)
;
if
(
jsterm
.
inputNode
)
{
is
(
jsterm
.
inputNode
.
selectionStart
jsterm
.
inputNode
.
selectionEnd
)
;
is
(
jsterm
.
inputNode
.
selectionStart
expectedStringWithCursor
.
indexOf
(
"
|
"
)
assertionInfo
)
;
}
else
{
const
lines
=
expectedStringWithCursor
.
split
(
"
\
n
"
)
;
const
lineWithCursor
=
lines
.
findIndex
(
line
=
>
line
.
includes
(
"
|
"
)
)
;
const
{
ch
line
}
=
jsterm
.
editor
.
getCursor
(
)
;
is
(
line
lineWithCursor
assertionInfo
+
"
-
correct
line
"
)
;
is
(
ch
lines
[
lineWithCursor
]
.
indexOf
(
"
|
"
)
assertionInfo
+
"
-
correct
ch
"
)
;
}
}
function
getInputCompletionValue
(
hud
)
{
const
{
jsterm
}
=
hud
;
if
(
jsterm
.
completeNode
)
{
return
jsterm
.
completeNode
.
value
;
}
if
(
jsterm
.
editor
)
{
return
jsterm
.
editor
.
getAutoCompletionText
(
)
;
}
return
null
;
}
function
isInputFocused
(
hud
)
{
const
{
jsterm
}
=
hud
;
const
document
=
jsterm
.
outputNode
.
ownerDocument
;
const
documentIsFocused
=
document
.
hasFocus
(
)
;
if
(
jsterm
.
inputNode
)
{
return
document
.
activeElement
=
=
jsterm
.
inputNode
&
&
documentIsFocused
;
}
if
(
jsterm
.
editor
)
{
return
documentIsFocused
&
&
jsterm
.
editor
.
hasFocus
(
)
;
}
return
false
;
}
async
function
openDebugger
(
options
=
{
}
)
{
if
(
!
options
.
tab
)
{
options
.
tab
=
gBrowser
.
selectedTab
;
}
const
target
=
await
TargetFactory
.
forTab
(
options
.
tab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
const
dbgPanelAlreadyOpen
=
toolbox
&
&
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
if
(
dbgPanelAlreadyOpen
)
{
await
toolbox
.
selectTool
(
"
jsdebugger
"
)
;
return
{
target
toolbox
panel
:
toolbox
.
getCurrentPanel
(
)
}
;
}
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
jsdebugger
"
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
if
(
panel
.
_view
)
{
panel
.
_view
.
Variables
.
lazyEmpty
=
false
;
}
if
(
panel
.
panelWin
&
&
panel
.
panelWin
.
DebuggerController
)
{
await
panel
.
panelWin
.
DebuggerController
.
waitForSourcesLoaded
(
)
;
}
else
{
await
toolbox
.
threadClient
.
getSources
(
)
;
}
return
{
target
toolbox
panel
}
;
}
async
function
openInspector
(
options
=
{
}
)
{
if
(
!
options
.
tab
)
{
options
.
tab
=
gBrowser
.
selectedTab
;
}
const
target
=
await
TargetFactory
.
forTab
(
options
.
tab
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
inspector
"
)
;
return
toolbox
.
getCurrentPanel
(
)
;
}
async
function
openConsole
(
tab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
|
|
gBrowser
.
selectedTab
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
webconsole
"
)
;
return
toolbox
.
getCurrentPanel
(
)
.
hud
;
}
async
function
closeConsole
(
tab
=
gBrowser
.
selectedTab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
const
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
await
toolbox
.
destroy
(
)
;
}
}
function
simulateLinkClick
(
element
clickEventProps
)
{
return
overrideOpenLink
(
(
)
=
>
{
if
(
clickEventProps
)
{
element
.
dispatchEvent
(
clickEventProps
)
;
}
else
{
element
.
click
(
)
;
}
}
)
;
}
function
overrideOpenLink
(
fn
)
{
const
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
gDevTools
.
chromeWindowType
)
;
const
oldOpenTrustedLinkIn
=
browserWindow
.
openTrustedLinkIn
;
const
oldOpenWebLinkIn
=
browserWindow
.
openWebLinkIn
;
const
onOpenLink
=
new
Promise
(
(
resolve
)
=
>
{
const
openLinkIn
=
function
(
link
where
)
{
browserWindow
.
openTrustedLinkIn
=
oldOpenTrustedLinkIn
;
browserWindow
.
openWebLinkIn
=
oldOpenWebLinkIn
;
resolve
(
{
link
:
link
where
}
)
;
}
;
browserWindow
.
openWebLinkIn
=
browserWindow
.
openTrustedLinkIn
=
openLinkIn
;
fn
(
)
;
}
)
;
let
timeoutId
;
const
onTimeout
=
new
Promise
(
function
(
resolve
)
{
timeoutId
=
setTimeout
(
(
)
=
>
{
browserWindow
.
openTrustedLinkIn
=
oldOpenTrustedLinkIn
;
browserWindow
.
openWebLinkIn
=
oldOpenWebLinkIn
;
timeoutId
=
null
;
resolve
(
{
link
:
null
where
:
null
}
)
;
}
1000
)
;
}
)
;
onOpenLink
.
then
(
(
)
=
>
{
if
(
timeoutId
)
{
clearTimeout
(
timeoutId
)
;
}
}
)
;
return
Promise
.
race
(
[
onOpenLink
onTimeout
]
)
;
}
function
openNewBrowserWindow
(
options
)
{
const
win
=
OpenBrowserWindow
(
options
)
;
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
)
{
if
(
win
=
=
subject
)
{
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
win
)
;
}
}
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
)
;
}
async
function
openMessageInNetmonitor
(
toolbox
hud
url
urlInConsole
)
{
urlInConsole
=
urlInConsole
|
|
url
;
const
message
=
await
waitFor
(
(
)
=
>
findMessage
(
hud
urlInConsole
)
)
;
const
onNetmonitorSelected
=
toolbox
.
once
(
"
netmonitor
-
selected
"
(
event
panel
)
=
>
{
return
panel
;
}
)
;
const
menuPopup
=
await
openContextMenu
(
hud
message
)
;
const
openInNetMenuItem
=
menuPopup
.
querySelector
(
"
#
console
-
menu
-
open
-
in
-
network
-
panel
"
)
;
ok
(
openInNetMenuItem
"
open
in
network
panel
item
is
enabled
"
)
;
openInNetMenuItem
.
click
(
)
;
const
{
panelWin
}
=
await
onNetmonitorSelected
;
ok
(
true
"
The
netmonitor
panel
is
selected
when
clicking
on
the
network
message
"
)
;
const
{
store
windowRequire
}
=
panelWin
;
const
nmActions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
const
{
getSelectedRequest
}
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
selectors
/
index
"
)
;
store
.
dispatch
(
nmActions
.
batchEnable
(
false
)
)
;
await
waitUntil
(
(
)
=
>
{
const
selected
=
getSelectedRequest
(
store
.
getState
(
)
)
;
return
selected
&
&
selected
.
url
=
=
=
url
;
}
)
;
ok
(
true
"
The
attached
url
is
correct
.
"
)
;
}
function
selectNode
(
hud
node
)
{
const
outputContainer
=
hud
.
ui
.
outputNode
.
querySelector
(
"
.
webconsole
-
output
"
)
;
outputContainer
.
ownerDocument
.
activeElement
.
blur
(
)
;
const
selection
=
outputContainer
.
ownerDocument
.
getSelection
(
)
;
const
range
=
document
.
createRange
(
)
;
range
.
selectNodeContents
(
node
)
;
selection
.
removeAllRanges
(
)
;
selection
.
addRange
(
range
)
;
return
selection
;
}
async
function
waitForBrowserConsole
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
)
{
Services
.
obs
.
removeObserver
(
observer
"
web
-
console
-
created
"
)
;
subject
.
QueryInterface
(
Ci
.
nsISupportsString
)
;
const
hud
=
HUDService
.
getBrowserConsole
(
)
;
ok
(
hud
"
browser
console
is
open
"
)
;
is
(
subject
.
data
hud
.
hudId
"
notification
hudId
is
correct
"
)
;
executeSoon
(
(
)
=
>
resolve
(
hud
)
)
;
}
"
web
-
console
-
created
"
)
;
}
)
;
}
async
function
getFilterState
(
hud
)
{
const
{
outputNode
}
=
hud
.
ui
;
const
filterBar
=
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
secondary
"
)
;
const
buttons
=
filterBar
.
querySelectorAll
(
"
button
"
)
;
const
result
=
{
}
;
for
(
const
button
of
buttons
)
{
const
classes
=
new
Set
(
button
.
classList
.
values
(
)
)
;
classes
.
delete
(
"
devtools
-
togglebutton
"
)
;
const
category
=
classes
.
values
(
)
.
next
(
)
.
value
;
result
[
category
]
=
button
.
getAttribute
(
"
aria
-
pressed
"
)
=
=
=
"
true
"
;
}
return
result
;
}
function
getFilterInput
(
hud
)
{
return
hud
.
ui
.
outputNode
.
querySelector
(
"
.
devtools
-
searchbox
input
"
)
;
}
async
function
setFilterState
(
hud
settings
)
{
const
{
outputNode
}
=
hud
.
ui
;
const
filterBar
=
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
secondary
"
)
;
for
(
const
category
in
settings
)
{
const
value
=
settings
[
category
]
;
const
button
=
filterBar
.
querySelector
(
.
{
category
}
)
;
if
(
category
=
=
=
"
text
"
)
{
const
filterInput
=
getFilterInput
(
hud
)
;
filterInput
.
focus
(
)
;
filterInput
.
select
(
)
;
if
(
!
value
)
{
EventUtils
.
synthesizeKey
(
"
KEY_Delete
"
)
;
}
else
{
EventUtils
.
sendString
(
value
)
;
}
await
waitFor
(
(
)
=
>
filterInput
.
value
=
=
=
value
)
;
continue
;
}
if
(
!
button
)
{
ok
(
false
setFilterState
(
)
called
with
a
category
of
{
category
}
+
which
doesn
'
t
exist
.
)
;
}
info
(
Setting
the
{
category
}
category
to
{
value
?
"
checked
"
:
"
disabled
"
}
)
;
const
isPressed
=
button
.
getAttribute
(
"
aria
-
pressed
"
)
;
if
(
(
!
value
&
&
isPressed
=
=
=
"
true
"
)
|
|
(
value
&
&
isPressed
!
=
=
"
true
"
)
)
{
button
.
click
(
)
;
await
waitFor
(
(
)
=
>
{
const
pressed
=
button
.
getAttribute
(
"
aria
-
pressed
"
)
;
if
(
!
value
)
{
return
pressed
=
=
=
"
false
"
|
|
pressed
=
=
=
null
;
}
return
pressed
=
=
=
"
true
"
;
}
)
;
}
}
}
async
function
resetFilters
(
hud
)
{
info
(
"
Resetting
filters
to
their
default
state
"
)
;
const
store
=
hud
.
ui
.
wrapper
.
getStore
(
)
;
store
.
dispatch
(
wcActions
.
filtersClear
(
)
)
;
}
async
function
openReverseSearch
(
hud
)
{
info
(
"
Open
the
reverse
search
UI
with
a
keyboard
shortcut
"
)
;
const
onReverseSearchUiOpen
=
waitFor
(
(
)
=
>
getReverseSearchElement
(
hud
)
)
;
const
isMacOS
=
AppConstants
.
platform
=
=
=
"
macosx
"
;
if
(
isMacOS
)
{
EventUtils
.
synthesizeKey
(
"
r
"
{
ctrlKey
:
true
}
)
;
}
else
{
EventUtils
.
synthesizeKey
(
"
VK_F9
"
)
;
}
const
element
=
await
onReverseSearchUiOpen
;
return
element
;
}
function
getReverseSearchElement
(
hud
)
{
const
{
outputNode
}
=
hud
.
ui
;
return
outputNode
.
querySelector
(
"
.
reverse
-
search
"
)
;
}
function
getReverseSearchInfoElement
(
hud
)
{
const
reverseSearchElement
=
getReverseSearchElement
(
hud
)
;
if
(
!
reverseSearchElement
)
{
return
null
;
}
return
reverseSearchElement
.
querySelector
(
"
.
reverse
-
search
-
info
"
)
;
}
function
isReverseSearchInputFocused
(
hud
)
{
const
{
outputNode
}
=
hud
.
ui
;
const
document
=
outputNode
.
ownerDocument
;
const
documentIsFocused
=
document
.
hasFocus
(
)
;
const
reverseSearchInput
=
outputNode
.
querySelector
(
"
.
reverse
-
search
-
input
"
)
;
return
document
.
activeElement
=
=
reverseSearchInput
&
&
documentIsFocused
;
}
async
function
selectNodeWithPicker
(
toolbox
testActor
selector
)
{
const
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
const
inspectorFront
=
inspector
.
inspector
;
const
onPickerStarted
=
inspectorFront
.
nodePicker
.
once
(
"
picker
-
started
"
)
;
inspectorFront
.
nodePicker
.
start
(
)
;
await
onPickerStarted
;
info
(
Picker
mode
started
now
clicking
on
"
{
selector
}
"
to
select
that
node
)
;
const
onPickerStopped
=
inspectorFront
.
nodePicker
.
once
(
"
picker
-
stopped
"
)
;
const
onInspectorUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
testActor
.
synthesizeMouse
(
{
selector
center
:
true
options
:
{
}
}
)
;
await
onPickerStopped
;
await
onInspectorUpdated
;
}
function
expandObjectInspectorNode
(
node
)
{
const
arrow
=
getObjectInspectorNodeArrow
(
node
)
;
if
(
!
arrow
)
{
ok
(
false
"
Node
can
'
t
be
expanded
"
)
;
return
;
}
arrow
.
click
(
)
;
}
function
getObjectInspectorNodeArrow
(
node
)
{
return
node
.
querySelector
(
"
.
arrow
"
)
;
}
function
isObjectInspectorNodeExpandable
(
node
)
{
return
!
!
getObjectInspectorNodeArrow
(
node
)
;
}
function
getObjectInspectorNodes
(
oi
)
{
return
oi
.
querySelectorAll
(
"
.
tree
-
node
"
)
;
}
function
getObjectInspectorChildrenNodes
(
node
)
{
const
getLevel
=
n
=
>
parseInt
(
n
.
getAttribute
(
"
aria
-
level
"
)
10
)
;
const
level
=
getLevel
(
node
)
;
const
childLevel
=
level
+
1
;
const
children
=
[
]
;
let
currentNode
=
node
;
while
(
currentNode
.
nextSibling
&
&
getLevel
(
currentNode
.
nextSibling
)
=
=
=
childLevel
)
{
currentNode
=
currentNode
.
nextSibling
;
children
.
push
(
currentNode
)
;
}
return
children
;
}
function
getObjectInspectorInvokeGetterButton
(
node
)
{
return
node
.
querySelector
(
"
.
invoke
-
getter
"
)
;
}
function
findObjectInspectorNode
(
oi
nodeLabel
)
{
return
[
.
.
.
oi
.
querySelectorAll
(
"
.
tree
-
node
"
)
]
.
find
(
node
=
>
{
const
label
=
node
.
querySelector
(
"
.
object
-
label
"
)
;
if
(
!
label
)
{
return
false
;
}
return
label
.
textContent
=
=
=
nodeLabel
;
}
)
;
}
function
getAutocompletePopupLabels
(
popup
)
{
return
popup
.
getItems
(
)
.
map
(
item
=
>
item
.
label
)
;
}
function
getConfirmDialog
(
toolbox
)
{
const
{
doc
}
=
toolbox
;
return
doc
.
querySelector
(
"
.
invoke
-
confirm
"
)
;
}
function
isConfirmDialogOpened
(
toolbox
)
{
const
tooltip
=
getConfirmDialog
(
toolbox
)
;
if
(
!
tooltip
)
{
return
false
;
}
return
tooltip
.
classList
.
contains
(
"
tooltip
-
visible
"
)
;
}
async
function
selectFrame
(
dbg
frame
)
{
const
onScopes
=
waitForDispatch
(
dbg
"
ADD_SCOPES
"
)
;
await
dbg
.
actions
.
selectFrame
(
dbg
.
selectors
.
getThreadContext
(
)
frame
)
;
await
onScopes
;
}
async
function
pauseDebugger
(
dbg
)
{
info
(
"
Waiting
for
debugger
to
pause
"
)
;
const
onPaused
=
waitForPaused
(
dbg
)
;
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
}
async
function
(
)
{
content
.
wrappedJSObject
.
firstCall
(
)
;
}
)
;
await
onPaused
;
}
function
hasVerticalOverflow
(
container
)
{
return
container
.
scrollHeight
>
container
.
clientHeight
;
}
function
isScrolledToBottom
(
container
)
{
if
(
!
container
.
lastChild
)
{
return
true
;
}
const
lastNodeHeight
=
container
.
lastChild
.
clientHeight
;
return
container
.
scrollTop
+
container
.
clientHeight
>
=
container
.
scrollHeight
-
lastNodeHeight
/
2
;
}
function
checkConsoleOutputForWarningGroup
(
hud
expectedMessages
)
{
const
messages
=
findMessages
(
hud
"
"
)
;
is
(
messages
.
length
expectedMessages
.
length
"
Got
the
expected
number
of
messages
"
)
;
const
isInWarningGroup
=
index
=
>
{
const
message
=
expectedMessages
[
index
]
;
if
(
!
message
.
startsWith
(
"
|
"
)
)
{
return
false
;
}
const
groups
=
expectedMessages
.
slice
(
0
index
)
.
reverse
(
)
.
filter
(
m
=
>
!
m
.
startsWith
(
"
|
"
)
)
;
if
(
groups
.
length
=
=
=
0
)
{
ok
(
false
"
Unexpected
structure
:
an
indented
message
isn
'
t
in
a
group
"
)
;
}
return
groups
[
0
]
.
startsWith
(
"
"
)
|
|
groups
[
0
]
.
startsWith
(
"
"
)
;
}
;
expectedMessages
.
forEach
(
(
expectedMessage
i
)
=
>
{
const
message
=
messages
[
i
]
;
info
(
Checking
"
{
expectedMessage
}
"
)
;
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
false
"
"
There
'
s
a
collapsed
arrow
"
)
;
is
(
message
.
querySelector
(
"
.
indent
"
)
.
getAttribute
(
"
data
-
indent
"
)
"
0
"
"
The
warningGroup
has
the
expected
indent
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
true
"
"
There
'
s
an
expanded
arrow
"
)
;
is
(
message
.
querySelector
(
"
.
indent
"
)
.
getAttribute
(
"
data
-
indent
"
)
"
0
"
"
The
warningGroup
has
the
expected
indent
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
false
"
"
There
'
s
a
collapsed
arrow
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
true
"
"
There
'
s
an
expanded
arrow
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
|
"
)
)
{
if
(
isInWarningGroup
(
i
)
)
{
is
(
message
.
querySelector
(
"
.
indent
.
warning
-
indent
"
)
.
getAttribute
(
"
data
-
indent
"
)
"
1
"
"
The
message
has
the
expected
indent
"
)
;
}
expectedMessage
=
expectedMessage
.
replace
(
"
|
"
"
"
)
;
}
else
{
is
(
message
.
querySelector
(
"
.
indent
"
)
.
getAttribute
(
"
data
-
indent
"
)
"
0
"
"
The
message
has
the
expected
indent
"
)
;
}
ok
(
message
.
textContent
.
trim
(
)
.
includes
(
expectedMessage
.
trim
(
)
)
Message
includes
+
the
expected
"
{
expectedMessage
}
"
content
-
"
{
message
.
textContent
.
trim
(
)
}
"
)
;
}
)
;
}
async
function
checkMessageStack
(
hud
text
frameLines
)
{
const
msgNode
=
await
waitFor
(
(
)
=
>
findMessage
(
hud
text
)
)
;
ok
(
!
msgNode
.
classList
.
contains
(
"
open
"
)
Error
logged
not
expanded
)
;
const
button
=
await
waitFor
(
(
)
=
>
msgNode
.
querySelector
(
"
.
collapse
-
button
"
)
)
;
button
.
click
(
)
;
const
framesNode
=
await
waitFor
(
(
)
=
>
msgNode
.
querySelector
(
"
.
frames
"
)
)
;
const
frameNodes
=
framesNode
.
querySelectorAll
(
"
.
frame
"
)
;
ok
(
frameNodes
.
length
=
=
frameLines
.
length
Found
{
frameLines
.
length
}
frames
)
;
for
(
let
i
=
0
;
i
<
frameLines
.
length
;
i
+
+
)
{
ok
(
frameNodes
[
i
]
.
querySelector
(
"
.
line
"
)
.
textContent
=
=
"
"
+
frameLines
[
i
]
Found
line
{
frameLines
[
i
]
}
for
frame
#
{
i
}
)
;
}
}
