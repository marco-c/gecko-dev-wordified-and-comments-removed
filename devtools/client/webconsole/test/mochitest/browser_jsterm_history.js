"
use
strict
"
;
const
TEST_URI
=
"
data
:
text
/
html
;
charset
=
UTF
-
8
test
"
;
const
COMMANDS
=
[
"
document
"
"
window
"
"
window
.
location
"
]
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
webconsole
.
jsterm
.
codeMirror
"
false
)
;
await
testHistory
(
)
;
await
pushPref
(
"
devtools
.
webconsole
.
jsterm
.
codeMirror
"
true
)
;
await
testHistory
(
)
;
}
)
;
async
function
testHistory
(
)
{
const
hud
=
await
openNewTabAndConsole
(
TEST_URI
)
;
const
{
jsterm
}
=
hud
;
jsterm
.
focus
(
)
;
for
(
const
command
of
COMMANDS
)
{
info
(
Executing
command
{
command
}
)
;
await
executeAndWaitForMessage
(
hud
command
"
"
"
.
result
"
)
;
}
for
(
let
x
=
COMMANDS
.
length
-
1
;
x
!
=
-
1
;
x
-
-
)
{
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
is
(
getInputValue
(
hud
)
COMMANDS
[
x
]
"
check
history
previous
idx
:
"
+
x
)
;
}
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
is
(
getInputValue
(
hud
)
COMMANDS
[
0
]
"
test
that
item
is
still
index
0
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
is
(
getInputValue
(
hud
)
COMMANDS
[
0
]
"
test
that
item
is
still
still
index
0
"
)
;
for
(
let
i
=
1
;
i
<
COMMANDS
.
length
;
i
+
+
)
{
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
is
(
getInputValue
(
hud
)
COMMANDS
[
i
]
"
check
history
next
idx
:
"
+
i
)
;
}
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
is
(
getInputValue
(
hud
)
"
"
"
check
input
is
empty
again
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
is
(
getInputValue
(
hud
)
"
"
"
check
input
is
still
empty
"
)
;
const
idxLast
=
COMMANDS
.
length
-
1
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
is
(
getInputValue
(
hud
)
COMMANDS
[
idxLast
]
"
check
history
next
idx
:
"
+
idxLast
)
;
}
