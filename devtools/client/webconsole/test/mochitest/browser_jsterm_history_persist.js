"
use
strict
"
;
requestLongerTimeout
(
2
)
;
const
TEST_URI
=
"
data
:
text
/
html
;
charset
=
utf
-
8
Web
Console
test
for
"
+
"
persisting
history
-
bug
943306
"
;
const
INPUT_HISTORY_COUNT
=
10
;
const
{
getHistoryEntries
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
history
"
)
;
add_task
(
async
function
(
)
{
info
(
"
Setting
custom
input
history
pref
to
"
+
INPUT_HISTORY_COUNT
)
;
Services
.
prefs
.
setIntPref
(
"
devtools
.
webconsole
.
inputHistoryCount
"
INPUT_HISTORY_COUNT
)
;
let
hud1
=
await
openNewTabAndConsole
(
TEST_URI
)
;
let
state1
=
hud1
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state1
)
)
"
[
]
"
"
No
history
on
first
tab
initially
"
)
;
await
populateInputHistory
(
hud1
)
;
state1
=
hud1
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state1
)
)
'
[
"
0
"
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
]
'
"
First
tab
has
populated
history
"
)
;
let
hud2
=
await
openNewTabAndConsole
(
TEST_URI
false
)
;
let
state2
=
hud2
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state2
)
)
'
[
"
0
"
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
]
'
"
Second
tab
has
populated
history
"
)
;
await
testNavigatingHistoryInUI
(
hud2
)
;
state2
=
hud2
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state2
)
)
'
[
"
0
"
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
"
"
]
'
"
An
empty
entry
has
been
added
in
the
second
tab
due
to
history
perusal
"
)
;
let
hud3
=
await
openNewTabAndConsole
(
TEST_URI
false
)
;
let
state3
=
hud3
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state3
)
)
'
[
"
0
"
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
]
'
"
Third
tab
has
populated
history
"
)
;
hud3
.
jsterm
.
setInputValue
(
'
"
hello
from
third
tab
"
'
)
;
await
hud3
.
jsterm
.
execute
(
)
;
state1
=
hud1
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state1
)
)
'
[
"
0
"
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
]
'
"
First
tab
history
hasn
'
t
changed
due
to
command
in
third
tab
"
)
;
state2
=
hud2
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state2
)
)
'
[
"
0
"
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
"
"
]
'
"
Second
tab
history
hasn
'
t
changed
due
to
command
in
third
tab
"
)
;
state3
=
hud3
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state3
)
)
'
[
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
"
\
\
"
hello
from
third
tab
\
\
"
"
]
'
"
Third
tab
has
updated
history
(
and
purged
the
first
result
)
after
"
+
"
running
a
command
"
)
;
let
hud4
=
await
openNewTabAndConsole
(
TEST_URI
false
)
;
let
state4
=
hud4
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state4
)
)
'
[
"
1
"
"
2
"
"
3
"
"
4
"
"
5
"
"
6
"
"
7
"
"
8
"
"
9
"
"
\
\
"
hello
from
third
tab
\
\
"
"
]
'
"
Fourth
tab
has
most
recent
history
"
)
;
await
hud4
.
jsterm
.
props
.
clearHistory
(
)
;
state4
=
hud4
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state4
)
)
"
[
]
"
"
Clearing
history
for
a
tab
works
"
)
;
let
hud5
=
await
openNewTabAndConsole
(
TEST_URI
false
)
;
let
state5
=
hud5
.
ui
.
consoleOutput
.
getStore
(
)
.
getState
(
)
;
is
(
JSON
.
stringify
(
getHistoryEntries
(
state5
)
)
"
[
]
"
"
Clearing
history
carries
over
to
a
new
tab
"
)
;
info
(
"
Clearing
custom
input
history
pref
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
webconsole
.
inputHistoryCount
"
)
;
}
)
;
async
function
populateInputHistory
(
hud
)
{
let
jsterm
=
hud
.
jsterm
;
for
(
let
i
=
0
;
i
<
INPUT_HISTORY_COUNT
;
i
+
+
)
{
jsterm
.
setInputValue
(
i
)
;
await
jsterm
.
execute
(
)
;
}
}
function
testNavigatingHistoryInUI
(
hud
)
{
let
jsterm
=
hud
.
jsterm
;
jsterm
.
focus
(
)
;
for
(
let
i
=
INPUT_HISTORY_COUNT
-
1
;
i
>
=
0
;
i
-
-
)
{
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
is
(
jsterm
.
getInputValue
(
)
i
"
Pressing
up
restores
last
input
"
)
;
}
}
