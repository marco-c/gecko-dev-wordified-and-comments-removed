"
use
strict
"
;
const
TEST_URI
=
"
data
:
text
/
html
;
charset
=
utf
-
8
Web
Console
test
for
"
+
"
bug
804845
and
bug
619598
"
;
add_task
(
async
function
(
)
{
const
{
jsterm
}
=
await
openNewTabAndConsole
(
TEST_URI
)
;
ok
(
!
jsterm
.
getInputValue
(
)
"
jsterm
.
getInputValue
(
)
is
empty
"
)
;
is
(
jsterm
.
inputNode
.
selectionStart
0
)
;
is
(
jsterm
.
inputNode
.
selectionEnd
0
)
;
testSingleLineInputNavNoHistory
(
jsterm
)
;
testMultiLineInputNavNoHistory
(
jsterm
)
;
await
testNavWithHistory
(
jsterm
)
;
}
)
;
function
testSingleLineInputNavNoHistory
(
jsterm
)
{
const
inputNode
=
jsterm
.
inputNode
;
EventUtils
.
sendString
(
"
1
"
)
;
is
(
inputNode
.
selectionStart
1
"
caret
location
after
single
char
input
"
)
;
synthesizeLineStartKey
(
)
;
is
(
inputNode
.
selectionStart
0
"
caret
location
after
single
char
input
and
ctrl
-
a
"
)
;
synthesizeLineEndKey
(
)
;
is
(
inputNode
.
selectionStart
1
"
caret
location
after
single
char
input
and
ctrl
-
e
"
)
;
EventUtils
.
sendString
(
"
2
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
is
(
inputNode
.
selectionStart
0
"
caret
location
after
two
char
input
and
KEY_ArrowUp
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
is
(
inputNode
.
selectionStart
2
"
caret
location
after
two
char
input
and
KEY_ArrowDown
"
)
;
synthesizeLineStartKey
(
)
;
is
(
inputNode
.
selectionStart
0
"
move
caret
to
beginning
of
2
char
input
with
ctrl
-
a
"
)
;
synthesizeLineStartKey
(
)
;
is
(
inputNode
.
selectionStart
0
"
no
change
of
caret
location
on
repeat
ctrl
-
a
"
)
;
synthesizeLineUpKey
(
)
;
is
(
inputNode
.
selectionStart
0
"
no
change
of
caret
location
on
ctrl
-
p
from
beginning
of
line
"
)
;
synthesizeLineEndKey
(
)
;
is
(
inputNode
.
selectionStart
2
"
move
caret
to
end
of
2
char
input
with
ctrl
-
e
"
)
;
synthesizeLineEndKey
(
)
;
is
(
inputNode
.
selectionStart
2
"
no
change
of
caret
location
on
repeat
ctrl
-
e
"
)
;
synthesizeLineDownKey
(
)
;
is
(
inputNode
.
selectionStart
2
"
no
change
of
caret
location
on
ctrl
-
n
from
end
of
line
"
)
;
synthesizeLineUpKey
(
)
;
is
(
inputNode
.
selectionStart
0
"
ctrl
-
p
moves
to
start
of
line
"
)
;
synthesizeLineDownKey
(
)
;
is
(
inputNode
.
selectionStart
2
"
ctrl
-
n
moves
to
end
of
line
"
)
;
}
function
testMultiLineInputNavNoHistory
(
jsterm
)
{
const
inputNode
=
jsterm
.
inputNode
;
const
lineValues
=
[
"
one
"
"
2
"
"
something
longer
"
"
"
"
"
"
three
!
"
]
;
jsterm
.
setInputValue
(
"
"
)
;
for
(
let
i
=
0
;
i
<
lineValues
.
length
;
i
+
+
)
{
jsterm
.
setInputValue
(
jsterm
.
getInputValue
(
)
+
lineValues
[
i
]
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
{
shiftKey
:
true
}
)
;
}
const
inputValue
=
jsterm
.
getInputValue
(
)
;
is
(
inputNode
.
selectionStart
inputNode
.
selectionEnd
)
;
is
(
inputNode
.
selectionStart
inputValue
.
length
"
caret
at
end
of
multiline
input
"
)
;
const
newlineString
=
inputValue
.
match
(
/
(
\
r
\
n
?
|
\
n
\
r
?
)
/
)
[
0
]
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowUp
"
)
;
let
expectedStringAfterCarat
=
lineValues
[
5
]
+
newlineString
;
is
(
jsterm
.
getInputValue
(
)
.
slice
(
inputNode
.
selectionStart
)
expectedStringAfterCarat
"
up
arrow
from
end
of
multiline
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_ArrowDown
"
)
;
is
(
jsterm
.
getInputValue
(
)
.
slice
(
inputNode
.
selectionStart
)
"
"
"
down
arrow
from
within
multiline
"
)
;
synthesizeLineUpKey
(
)
;
is
(
jsterm
.
getInputValue
(
)
.
slice
(
inputNode
.
selectionStart
)
expectedStringAfterCarat
"
ctrl
-
p
from
end
of
multiline
"
)
;
for
(
let
i
=
4
;
i
>
=
0
;
i
-
-
)
{
synthesizeLineUpKey
(
)
;
expectedStringAfterCarat
=
lineValues
[
i
]
+
newlineString
+
expectedStringAfterCarat
;
is
(
jsterm
.
getInputValue
(
)
.
slice
(
inputNode
.
selectionStart
)
expectedStringAfterCarat
"
ctrl
-
p
from
within
line
"
+
i
+
"
of
multiline
input
"
)
;
}
synthesizeLineUpKey
(
)
;
is
(
inputNode
.
selectionStart
0
"
reached
start
of
input
"
)
;
is
(
jsterm
.
getInputValue
(
)
inputValue
"
no
change
to
multiline
input
on
ctrl
-
p
from
beginning
of
multiline
"
)
;
synthesizeLineEndKey
(
)
;
let
caretPos
=
inputNode
.
selectionStart
;
let
expectedStringBeforeCarat
=
lineValues
[
0
]
;
is
(
jsterm
.
getInputValue
(
)
.
slice
(
0
caretPos
)
expectedStringBeforeCarat
"
ctrl
-
e
into
multiline
input
"
)
;
synthesizeLineEndKey
(
)
;
is
(
inputNode
.
selectionStart
caretPos
"
repeat
ctrl
-
e
doesn
'
t
change
caret
position
in
multiline
input
"
)
;
for
(
let
i
=
1
;
i
<
lineValues
.
length
;
i
+
+
)
{
synthesizeLineDownKey
(
)
;
synthesizeLineStartKey
(
)
;
caretPos
=
inputNode
.
selectionStart
;
expectedStringBeforeCarat
+
=
newlineString
;
is
(
jsterm
.
getInputValue
(
)
.
slice
(
0
caretPos
)
expectedStringBeforeCarat
"
ctrl
-
a
to
beginning
of
line
"
+
(
i
+
1
)
+
"
in
multiline
input
"
)
;
synthesizeLineEndKey
(
)
;
caretPos
=
inputNode
.
selectionStart
;
expectedStringBeforeCarat
+
=
lineValues
[
i
]
;
is
(
jsterm
.
getInputValue
(
)
.
slice
(
0
caretPos
)
expectedStringBeforeCarat
"
ctrl
-
e
to
end
of
line
"
+
(
i
+
1
)
+
"
in
multiline
input
"
)
;
}
}
async
function
testNavWithHistory
(
jsterm
)
{
const
inputNode
=
jsterm
.
inputNode
;
const
values
=
[
'
"
single
line
input
"
'
'
"
a
longer
single
-
line
input
to
check
caret
repositioning
"
'
'
"
multi
-
line
"
\
n
"
input
"
\
n
"
here
!
"
'
]
;
for
(
let
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
jsterm
.
setInputValue
(
values
[
i
]
)
;
await
jsterm
.
execute
(
)
;
}
is
(
inputNode
.
selectionStart
0
"
caret
location
at
start
of
empty
line
"
)
;
synthesizeLineUpKey
(
)
;
is
(
inputNode
.
selectionStart
values
[
values
.
length
-
1
]
.
length
"
caret
location
correct
at
end
of
last
history
input
"
)
;
for
(
let
i
=
values
.
length
-
1
;
i
>
0
;
i
-
-
)
{
const
match
=
values
[
i
]
.
match
(
/
(
\
n
)
/
g
)
;
if
(
match
)
{
synthesizeLineStartKey
(
)
;
for
(
let
j
=
0
;
j
<
match
.
length
;
j
+
+
)
{
synthesizeLineUpKey
(
)
;
}
synthesizeLineUpKey
(
)
;
}
else
{
synthesizeLineUpKey
(
)
;
}
is
(
jsterm
.
getInputValue
(
)
values
[
i
-
1
]
"
ctrl
-
p
updates
inputNode
from
backwards
history
values
[
"
+
i
-
1
+
"
]
"
)
;
}
let
inputValue
=
jsterm
.
getInputValue
(
)
;
synthesizeLineUpKey
(
)
;
is
(
inputNode
.
selectionStart
0
"
ctrl
-
p
at
beginning
of
history
moves
caret
location
to
beginning
"
+
"
of
line
"
)
;
is
(
jsterm
.
getInputValue
(
)
inputValue
"
no
change
to
input
value
on
ctrl
-
p
from
beginning
of
line
"
)
;
for
(
let
i
=
1
;
i
<
values
.
length
;
i
+
+
)
{
synthesizeLineDownKey
(
)
;
is
(
jsterm
.
getInputValue
(
)
values
[
i
]
"
ctrl
-
n
updates
inputNode
from
forwards
history
values
[
"
+
i
+
"
]
"
)
;
is
(
inputNode
.
selectionStart
values
[
i
]
.
length
"
caret
location
correct
at
end
of
history
input
for
values
[
"
+
i
+
"
]
"
)
;
}
synthesizeLineDownKey
(
)
;
ok
(
!
jsterm
.
getInputValue
(
)
"
ctrl
-
n
at
end
of
history
updates
to
empty
input
"
)
;
inputValue
=
"
one
\
nlinebreak
"
;
jsterm
.
setInputValue
(
inputValue
)
;
synthesizeLineUpKey
(
)
;
is
(
jsterm
.
getInputValue
(
)
inputValue
"
ctrl
-
p
from
end
of
multi
-
line
does
not
trigger
history
"
)
;
synthesizeLineStartKey
(
)
;
synthesizeLineUpKey
(
)
;
is
(
jsterm
.
getInputValue
(
)
values
[
values
.
length
-
1
]
"
ctrl
-
p
from
start
of
multi
-
line
triggers
history
"
)
;
}
function
synthesizeLineStartKey
(
)
{
EventUtils
.
synthesizeKey
(
"
a
"
{
ctrlKey
:
true
}
)
;
}
function
synthesizeLineEndKey
(
)
{
EventUtils
.
synthesizeKey
(
"
e
"
{
ctrlKey
:
true
}
)
;
}
function
synthesizeLineUpKey
(
)
{
EventUtils
.
synthesizeKey
(
"
p
"
{
ctrlKey
:
true
}
)
;
}
function
synthesizeLineDownKey
(
)
{
EventUtils
.
synthesizeKey
(
"
n
"
{
ctrlKey
:
true
}
)
;
}
