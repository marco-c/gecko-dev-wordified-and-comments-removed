"
use
strict
"
;
const
SEASON
=
{
english
:
"
season
"
chinese
:
"
\
u5b63
"
}
;
const
SEASONS
=
[
{
english
:
"
spring
"
chinese
:
"
\
u6625
"
escapedChinese
:
"
\
\
u6625
"
}
{
english
:
"
summer
"
chinese
:
"
\
u590f
"
escapedChinese
:
"
\
\
u590f
"
}
{
english
:
"
autumn
"
chinese
:
"
\
u79cb
"
escapedChinese
:
"
\
\
u79cb
"
}
{
english
:
"
winter
"
chinese
:
"
\
u51ac
"
escapedChinese
:
"
\
\
u51ac
"
}
]
;
const
HTML_FILENAME
=
test
.
html
;
const
JS_ASCII_FILENAME
=
{
SEASON
.
english
}
.
js
;
const
JS_UNICODE_FILENAME
=
{
SEASON
.
chinese
}
.
js
;
const
ENCODED_JS_UNICODE_FILENAME
=
encodeURIComponent
(
JS_UNICODE_FILENAME
)
;
const
HTML_CONSOLE_OUTPUT
=
Test
filtering
{
SEASON
.
english
}
names
.
;
const
HTML_CONTENT
=
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf
-
8
"
>
<
title
>
Test
filtering
logs
by
filling
keywords
in
the
filter
input
.
<
/
title
>
<
script
>
console
.
log
(
"
{
HTML_CONSOLE_OUTPUT
}
"
)
;
<
/
script
>
<
script
src
=
"
/
{
JS_ASCII_FILENAME
}
"
>
<
/
script
>
<
script
src
=
"
/
{
ENCODED_JS_UNICODE_FILENAME
}
"
>
<
/
script
>
;
add_task
(
async
function
(
)
{
const
testUrl
=
createServerAndGetTestUrl
(
)
;
const
hud
=
await
openNewTabAndConsole
(
testUrl
)
;
const
lastSeason
=
SEASONS
[
SEASONS
.
length
-
1
]
;
await
waitFor
(
(
)
=
>
findMessage
(
hud
lastSeason
.
english
)
&
&
findMessage
(
hud
lastSeason
.
chinese
)
)
;
let
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
SEASONS
.
length
*
2
+
1
"
the
total
number
of
all
the
logs
before
starting
filtering
"
)
;
checkLogContent
(
visibleLogs
[
0
]
HTML_CONSOLE_OUTPUT
HTML_FILENAME
)
;
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
+
1
]
SEASONS
[
i
]
.
english
JS_ASCII_FILENAME
)
;
}
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
+
1
+
SEASONS
.
length
]
SEASONS
[
i
]
.
chinese
JS_UNICODE_FILENAME
)
;
}
setFilterInput
(
hud
JS_ASCII_FILENAME
)
;
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
SEASONS
.
length
the
number
of
all
the
logs
containing
{
JS_ASCII_FILENAME
}
)
;
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
]
SEASONS
[
i
]
.
english
JS_ASCII_FILENAME
)
;
}
for
(
const
curSeason
of
SEASONS
)
{
setFilterInput
(
hud
curSeason
.
english
)
;
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
1
the
number
of
all
the
logs
containing
{
curSeason
.
english
}
)
;
checkLogContent
(
visibleLogs
[
0
]
curSeason
.
english
JS_ASCII_FILENAME
)
;
}
setFilterInput
(
hud
JS_UNICODE_FILENAME
)
;
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
SEASONS
.
length
the
number
of
all
the
logs
containing
{
JS_UNICODE_FILENAME
}
)
;
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
]
SEASONS
[
i
]
.
chinese
JS_UNICODE_FILENAME
)
;
}
for
(
const
curSeason
of
SEASONS
)
{
setFilterInput
(
hud
curSeason
.
chinese
)
;
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
1
the
number
of
all
the
logs
containing
{
curSeason
.
chinese
}
)
;
checkLogContent
(
visibleLogs
[
0
]
curSeason
.
chinese
JS_UNICODE_FILENAME
)
;
}
setFilterInput
(
hud
SEASON
.
english
)
;
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
SEASONS
.
length
+
1
the
number
of
all
the
logs
containing
{
SEASON
.
english
}
)
;
checkLogContent
(
visibleLogs
[
0
]
HTML_CONSOLE_OUTPUT
HTML_FILENAME
)
;
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
+
1
]
SEASONS
[
i
]
.
english
JS_ASCII_FILENAME
)
;
}
setFilterInput
(
hud
SEASON
.
chinese
)
;
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
SEASONS
.
length
the
number
of
all
the
logs
containing
{
SEASON
.
chinese
}
)
;
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
]
SEASONS
[
i
]
.
chinese
JS_UNICODE_FILENAME
)
;
}
clearFilterInput
(
hud
)
;
visibleLogs
=
getVisibleLogs
(
hud
)
;
is
(
visibleLogs
.
length
SEASONS
.
length
*
2
+
1
"
the
total
number
of
all
the
logs
after
clearing
filtering
"
)
;
checkLogContent
(
visibleLogs
[
0
]
HTML_CONSOLE_OUTPUT
HTML_FILENAME
)
;
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
+
1
]
SEASONS
[
i
]
.
english
JS_ASCII_FILENAME
)
;
}
for
(
let
i
=
0
;
i
<
SEASONS
.
length
;
i
+
+
)
{
checkLogContent
(
visibleLogs
[
i
+
1
+
SEASONS
.
length
]
SEASONS
[
i
]
.
chinese
JS_UNICODE_FILENAME
)
;
}
}
)
;
function
createServerAndGetTestUrl
(
)
{
const
httpServer
=
createTestHTTPServer
(
)
;
httpServer
.
registerContentType
(
"
html
"
"
text
/
html
"
)
;
httpServer
.
registerContentType
(
"
js
"
"
application
/
javascript
"
)
;
httpServer
.
registerPathHandler
(
"
/
"
+
HTML_FILENAME
function
(
request
response
)
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
response
.
write
(
HTML_CONTENT
)
;
}
)
;
httpServer
.
registerPathHandler
(
"
/
"
+
JS_ASCII_FILENAME
function
(
request
response
)
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
let
content
=
"
"
;
for
(
const
curSeason
of
SEASONS
)
{
content
+
=
console
.
log
(
"
{
curSeason
.
english
}
"
)
;
;
}
response
.
write
(
content
)
;
}
)
;
httpServer
.
registerPathHandler
(
"
/
"
+
ENCODED_JS_UNICODE_FILENAME
function
(
request
response
)
{
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
let
content
=
"
"
;
for
(
const
curSeason
of
SEASONS
)
{
content
+
=
console
.
log
(
"
{
curSeason
.
escapedChinese
}
"
)
;
;
}
response
.
write
(
content
)
;
}
)
;
const
port
=
httpServer
.
identity
.
primaryPort
;
return
http
:
/
/
localhost
:
{
port
}
/
{
HTML_FILENAME
}
;
}
function
setFilterInput
(
hud
value
)
{
hud
.
ui
.
filterBox
.
focus
(
)
;
hud
.
ui
.
filterBox
.
select
(
)
;
EventUtils
.
sendString
(
value
)
;
}
function
clearFilterInput
(
hud
)
{
hud
.
ui
.
filterBox
.
focus
(
)
;
hud
.
ui
.
filterBox
.
select
(
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Delete
"
)
;
}
function
getVisibleLogs
(
hud
)
{
const
outputNode
=
hud
.
outputNode
;
return
outputNode
.
querySelectorAll
(
"
.
message
"
)
;
}
function
checkLogContent
(
node
expectedMessageBody
expectedFilename
)
{
const
messageBody
=
node
.
querySelector
(
"
.
message
-
body
"
)
.
textContent
;
const
location
=
node
.
querySelector
(
"
.
message
-
location
"
)
.
textContent
;
const
filename
=
location
.
split
(
"
:
"
)
[
0
]
;
is
(
messageBody
expectedMessageBody
"
the
expected
message
body
"
)
;
is
(
filename
expectedFilename
"
the
expected
filename
"
)
;
}
