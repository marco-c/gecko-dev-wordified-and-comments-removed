"
use
strict
"
;
const
TEST_URI
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
webconsole
/
"
+
"
test
/
mochitest
/
"
+
"
test
-
closure
-
optimized
-
out
.
html
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
devtools
.
debugger
.
new
-
debugger
-
frontend
"
false
)
;
const
hud
=
await
openNewTabAndConsole
(
TEST_URI
)
;
const
{
toolbox
panel
:
debuggerPanel
}
=
await
openDebugger
(
)
;
const
sources
=
debuggerPanel
.
panelWin
.
DebuggerView
.
Sources
;
await
debuggerPanel
.
addBreakpoint
(
{
actor
:
sources
.
values
[
0
]
line
:
18
}
)
;
await
ensureThreadClientState
(
debuggerPanel
"
resumed
"
)
;
const
{
FETCHED_SCOPES
}
=
debuggerPanel
.
panelWin
.
EVENTS
;
const
fetchedScopes
=
debuggerPanel
.
panelWin
.
once
(
FETCHED_SCOPES
)
;
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
}
async
function
(
)
{
const
button
=
content
.
document
.
querySelector
(
"
button
"
)
;
button
.
click
(
)
;
}
)
;
await
fetchedScopes
;
ok
(
true
"
Scopes
were
fetched
"
)
;
await
toolbox
.
selectTool
(
"
webconsole
"
)
;
const
onMessage
=
waitForMessage
(
hud
"
optimized
out
"
)
;
hud
.
jsterm
.
execute
(
"
upvar
"
)
;
info
(
"
Waiting
for
optimized
out
message
"
)
;
await
onMessage
;
ok
(
true
"
Optimized
out
message
logged
"
)
;
}
)
;
async
function
ensureThreadClientState
(
debuggerPanel
state
)
{
const
thread
=
debuggerPanel
.
panelWin
.
gThreadClient
;
info
(
Thread
is
:
'
{
thread
.
state
}
'
.
)
;
if
(
thread
.
state
!
=
state
)
{
info
(
"
Waiting
for
thread
event
:
'
{
state
}
'
.
"
)
;
await
thread
.
addOneTimeListener
(
state
)
;
}
}
