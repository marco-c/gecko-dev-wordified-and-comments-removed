"
use
strict
"
;
const
reduxActions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
const
{
configureStore
}
=
require
(
"
devtools
/
client
/
webconsole
/
store
"
)
;
const
{
IdGenerator
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
id
-
generator
"
)
;
const
{
stubPackets
}
=
require
(
"
devtools
/
client
/
webconsole
/
test
/
node
/
fixtures
/
stubs
/
index
"
)
;
const
{
getMutableMessagesById
}
=
require
(
"
devtools
/
client
/
webconsole
/
selectors
/
messages
"
)
;
const
{
getPrefsService
}
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
prefs
"
)
;
const
prefsService
=
getPrefsService
(
{
}
)
;
const
{
PREFS
}
=
require
(
"
devtools
/
client
/
webconsole
/
constants
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
{
getSerializedPacket
parsePacketAndCreateFronts
}
=
require
(
"
devtools
/
client
/
webconsole
/
test
/
browser
/
stub
-
generator
-
helpers
"
)
;
function
setupActions
(
)
{
const
wrappedActions
=
Object
.
assign
(
{
}
reduxActions
)
;
const
idGenerator
=
new
IdGenerator
(
)
;
wrappedActions
.
messagesAdd
=
packets
=
>
{
return
reduxActions
.
messagesAdd
(
packets
idGenerator
)
;
}
;
return
{
.
.
.
reduxActions
messagesAdd
:
packets
=
>
reduxActions
.
messagesAdd
(
packets
idGenerator
)
}
;
}
function
setupStore
(
input
=
[
]
{
storeOptions
=
{
}
actions
webConsoleUI
}
=
{
}
)
{
if
(
!
webConsoleUI
)
{
webConsoleUI
=
getWebConsoleUiMock
(
)
;
}
const
store
=
configureStore
(
webConsoleUI
{
.
.
.
storeOptions
thunkArgs
:
{
toolbox
:
{
sessionId
:
-
1
}
}
telemetry
:
new
Telemetry
(
)
}
)
;
const
messagesAdd
=
actions
?
actions
.
messagesAdd
:
reduxActions
.
messagesAdd
;
store
.
dispatch
(
messagesAdd
(
input
.
map
(
cmd
=
>
stubPackets
.
get
(
cmd
)
)
)
)
;
return
store
;
}
function
clonePacket
(
packet
)
{
const
strPacket
=
getSerializedPacket
(
packet
)
;
return
parsePacketAndCreateFronts
(
JSON
.
parse
(
strPacket
)
)
;
}
function
getMessageAt
(
state
index
)
{
const
messageMap
=
getMutableMessagesById
(
state
)
;
return
messageMap
.
get
(
state
.
messages
.
mutableMessagesOrder
[
index
]
)
;
}
function
getFirstMessage
(
state
)
{
return
getMessageAt
(
state
0
)
;
}
function
getLastMessage
(
state
)
{
const
lastIndex
=
state
.
messages
.
mutableMessagesOrder
.
length
-
1
;
return
getMessageAt
(
state
lastIndex
)
;
}
function
getFiltersPrefs
(
)
{
return
Object
.
values
(
PREFS
.
FILTER
)
.
reduce
(
(
res
pref
)
=
>
{
res
[
pref
]
=
prefsService
.
getBoolPref
(
pref
)
;
return
res
;
}
{
}
)
;
}
function
clearPrefs
(
)
{
[
"
devtools
.
hud
.
loglimit
"
.
.
.
Object
.
values
(
PREFS
.
FILTER
)
.
.
.
Object
.
values
(
PREFS
.
UI
)
]
.
forEach
(
prefsService
.
clearUserPref
)
;
}
function
getPrivatePacket
(
key
)
{
const
packet
=
clonePacket
(
stubPackets
.
get
(
key
)
)
;
if
(
packet
.
message
)
{
packet
.
message
.
private
=
true
;
}
else
if
(
packet
.
pageError
)
{
packet
.
pageError
.
private
=
true
;
}
if
(
Object
.
getOwnPropertyNames
(
packet
)
.
includes
(
"
private
"
)
)
{
packet
.
private
=
true
;
}
return
packet
;
}
function
getWebConsoleUiMock
(
hud
proxyOverrides
)
{
const
proxy
=
getProxyMock
(
proxyOverrides
)
;
return
{
emit
:
(
)
=
>
{
}
emitForTests
:
(
)
=
>
{
}
hud
proxy
clearNetworkRequests
:
(
)
=
>
{
}
clearMessagesCache
:
(
)
=
>
{
}
releaseActor
:
proxy
.
releaseActor
getProxy
:
(
)
=
>
proxy
inspectObjectActor
:
(
)
=
>
{
}
toolbox
:
{
sessionId
:
1
}
watchCssMessages
:
(
)
=
>
{
}
}
;
}
function
getProxyMock
(
overrides
=
{
}
)
{
return
{
releaseActor
:
actor
=
>
{
}
target
:
{
ensureCSSErrorReportingEnabled
:
(
)
=
>
{
}
}
.
.
.
overrides
}
;
}
function
formatErrorTextWithCausedBy
(
text
)
{
return
text
.
replace
(
/
Caused
by
/
g
"
\
nCaused
by
"
)
;
}
module
.
exports
=
{
clearPrefs
clonePacket
formatErrorTextWithCausedBy
getFiltersPrefs
getFirstMessage
getLastMessage
getMessageAt
getPrivatePacket
getWebConsoleUiMock
prefsService
setupActions
setupStore
}
;
