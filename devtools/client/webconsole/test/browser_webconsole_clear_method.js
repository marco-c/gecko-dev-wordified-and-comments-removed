"
use
strict
"
;
add_task
(
async
function
(
)
{
const
TEST_URI
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
webconsole
/
"
+
"
test
/
test
-
console
-
clear
.
html
"
;
await
loadTab
(
TEST_URI
)
;
let
hud
=
await
openConsole
(
)
;
ok
(
hud
"
Web
Console
opened
"
)
;
info
(
"
Check
the
console
.
clear
(
)
done
on
page
load
has
been
processed
.
"
)
;
await
waitForLog
(
"
Console
was
cleared
"
hud
)
;
ok
(
hud
.
outputNode
.
textContent
.
includes
(
"
Console
was
cleared
"
)
"
console
.
clear
(
)
message
is
displayed
"
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log1
"
)
"
log1
not
displayed
"
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log2
"
)
"
log2
not
displayed
"
)
;
info
(
"
Logging
two
messages
log3
log4
"
)
;
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
}
function
*
(
)
{
content
.
wrappedJSObject
.
console
.
log
(
"
log3
"
)
;
content
.
wrappedJSObject
.
console
.
log
(
"
log4
"
)
;
}
)
;
await
waitForLog
(
"
log3
"
hud
)
;
await
waitForLog
(
"
log4
"
hud
)
;
ok
(
hud
.
outputNode
.
textContent
.
includes
(
"
Console
was
cleared
"
)
"
console
.
clear
(
)
message
is
still
displayed
"
)
;
ok
(
hud
.
outputNode
.
textContent
.
includes
(
"
log3
"
)
"
log3
is
displayed
"
)
;
ok
(
hud
.
outputNode
.
textContent
.
includes
(
"
log4
"
)
"
log4
is
displayed
"
)
;
info
(
"
Open
the
variables
view
sidebar
for
'
objFromPage
'
"
)
;
await
openSidebar
(
"
objFromPage
"
{
a
:
1
}
hud
)
;
let
sidebarClosed
=
hud
.
jsterm
.
once
(
"
sidebar
-
closed
"
)
;
info
(
"
Call
console
.
clear
from
the
page
"
)
;
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
}
function
*
(
)
{
content
.
wrappedJSObject
.
console
.
clear
(
)
;
}
)
;
info
(
"
Wait
for
variables
view
sidebar
to
be
closed
after
console
.
clear
(
)
"
)
;
await
sidebarClosed
;
await
new
Promise
(
executeSoon
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log3
"
)
"
log3
not
displayed
"
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log4
"
)
"
log4
not
displayed
"
)
;
ok
(
hud
.
outputNode
.
textContent
.
includes
(
"
Console
was
cleared
"
)
"
console
.
clear
(
)
message
is
still
displayed
"
)
;
is
(
hud
.
outputNode
.
textContent
.
split
(
"
Console
was
cleared
"
)
.
length
2
"
console
.
clear
(
)
message
is
only
displayed
once
"
)
;
info
(
"
Logging
one
messages
log5
"
)
;
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
}
function
*
(
)
{
content
.
wrappedJSObject
.
console
.
log
(
"
log5
"
)
;
}
)
;
await
waitForLog
(
"
log5
"
hud
)
;
info
(
"
Close
and
reopen
the
webconsole
.
"
)
;
await
closeConsole
(
gBrowser
.
selectedTab
)
;
hud
=
await
openConsole
(
)
;
await
waitForLog
(
"
Console
was
cleared
"
hud
)
;
ok
(
hud
.
outputNode
.
textContent
.
includes
(
"
Console
was
cleared
"
)
"
console
.
clear
(
)
message
is
still
displayed
"
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log1
"
)
"
log1
not
displayed
"
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log2
"
)
"
log1
not
displayed
"
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log3
"
)
"
log3
not
displayed
"
)
;
ok
(
!
hud
.
outputNode
.
textContent
.
includes
(
"
log4
"
)
"
log4
not
displayed
"
)
;
ok
(
hud
.
outputNode
.
textContent
.
includes
(
"
log5
"
)
"
log5
still
displayed
"
)
;
}
)
;
function
waitForLog
(
message
webconsole
options
)
{
return
waitForMessages
(
{
webconsole
:
webconsole
messages
:
[
{
text
:
message
category
:
CATEGORY_WEBDEV
severity
:
SEVERITY_LOG
}
]
}
)
;
}
async
function
openSidebar
(
objName
expectedObj
webconsole
)
{
let
msg
=
await
webconsole
.
jsterm
.
execute
(
objName
)
;
ok
(
msg
"
output
message
found
"
)
;
let
anchor
=
msg
.
querySelector
(
"
a
"
)
;
let
body
=
msg
.
querySelector
(
"
.
message
-
body
"
)
;
ok
(
anchor
"
object
anchor
"
)
;
ok
(
body
"
message
body
"
)
;
await
EventUtils
.
synthesizeMouse
(
anchor
2
2
{
}
webconsole
.
iframeWindow
)
;
let
vviewVar
=
await
webconsole
.
jsterm
.
once
(
"
variablesview
-
fetched
"
)
;
let
vview
=
vviewVar
.
_variablesView
;
ok
(
vview
"
variables
view
object
exists
"
)
;
await
findVariableViewProperties
(
vviewVar
[
expectedObj
]
{
webconsole
:
webconsole
}
)
;
}
