"
use
strict
"
;
const
TEST_URI
=
"
data
:
text
/
html
;
charset
=
utf8
<
!
DOCTYPE
html
>
<
p
>
browser_console_devtools_loader_exception
.
js
<
/
p
>
"
;
add_task
(
async
function
(
)
{
await
pushPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
const
wcHud
=
await
openNewTabAndConsole
(
TEST_URI
)
;
ok
(
wcHud
"
web
console
opened
"
)
;
const
bcHud
=
await
BrowserConsoleManager
.
toggleBrowserConsole
(
)
;
ok
(
bcHud
"
browser
console
opened
"
)
;
const
toolbox
=
wcHud
.
toolbox
;
const
oldPanels
=
toolbox
.
_toolPanels
;
toolbox
.
_toolPanels
=
{
}
;
function
fixToolbox
(
)
{
toolbox
.
_toolPanels
=
oldPanels
;
}
info
(
"
generate
exception
and
wait
for
message
"
)
;
executeSoon
(
(
)
=
>
{
expectUncaughtException
(
)
;
executeSoon
(
fixToolbox
)
;
toolbox
.
getToolPanels
(
)
;
}
)
;
const
msg
=
await
waitFor
(
(
)
=
>
findErrorMessage
(
bcHud
"
TypeError
:
this
.
_toolPanels
is
not
iterable
"
)
)
;
fixToolbox
(
)
;
ok
(
msg
Message
found
:
"
TypeError
:
this
.
_toolPanels
is
not
iterable
"
)
;
const
locationNode
=
msg
.
querySelector
(
"
.
message
-
location
.
frame
-
link
-
source
"
)
;
ok
(
locationNode
"
Message
location
link
element
found
"
)
;
const
url
=
locationNode
.
href
;
info
(
"
view
-
source
url
:
"
+
url
)
;
ok
(
url
"
we
have
some
source
URL
after
the
click
"
)
;
ok
(
url
.
includes
(
"
toolbox
.
js
"
)
"
we
have
the
expected
view
source
URL
"
)
;
ok
(
!
url
.
includes
(
"
-
>
"
)
"
no
-
>
in
the
URL
given
to
view
-
source
"
)
;
const
isFissionEnabledForBrowserConsole
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
browsertoolbox
.
fission
"
false
)
;
const
{
targetCommand
}
=
bcHud
.
commands
;
const
onViewSourceTargetAvailable
=
!
isFissionEnabledForBrowserConsole
?
Promise
.
resolve
(
)
:
new
Promise
(
resolve
=
>
{
const
onAvailable
=
(
{
targetFront
}
)
=
>
{
if
(
targetFront
.
url
.
includes
(
"
view
-
source
:
"
)
)
{
targetCommand
.
unwatchTargets
(
{
types
:
[
targetCommand
.
TYPES
.
FRAME
]
onAvailable
}
)
;
resolve
(
)
;
}
}
;
targetCommand
.
watchTargets
(
{
types
:
[
targetCommand
.
TYPES
.
FRAME
]
onAvailable
}
)
;
}
)
;
const
onTabOpen
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
tabUrl
=
>
tabUrl
.
startsWith
(
"
view
-
source
:
"
)
true
)
;
locationNode
.
click
(
)
;
await
onTabOpen
;
ok
(
true
"
The
view
source
tab
was
opened
in
response
to
clicking
the
link
"
)
;
info
(
"
Wait
for
the
frame
target
to
be
available
"
)
;
await
onViewSourceTargetAvailable
;
}
)
;
