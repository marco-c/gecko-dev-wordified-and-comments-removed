"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
debugger
/
test
/
mochitest
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
webconsole
/
test
/
browser
/
shared
-
head
.
js
"
this
)
;
var
{
BrowserConsoleManager
}
=
require
(
"
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
"
)
;
var
WCUL10n
=
require
(
"
devtools
/
client
/
webconsole
/
utils
/
l10n
"
)
;
const
DOCS_GA_PARAMS
=
?
{
new
URLSearchParams
(
{
utm_source
:
"
mozilla
"
utm_medium
:
"
firefox
-
console
-
errors
"
utm_campaign
:
"
default
"
}
)
}
;
const
GA_PARAMS
=
?
{
new
URLSearchParams
(
{
utm_source
:
"
mozilla
"
utm_medium
:
"
devtools
-
webconsole
"
utm_campaign
:
"
default
"
}
)
}
;
const
wcActions
=
require
(
"
devtools
/
client
/
webconsole
/
actions
/
index
"
)
;
registerCleanupFunction
(
async
function
(
)
{
Services
.
cookies
.
removeAll
(
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
webconsole
.
ui
.
filterbar
"
)
;
await
SpecialPowers
.
flushPrefEnv
(
)
;
Services
.
prefs
.
getChildList
(
"
devtools
.
webconsole
.
filter
"
)
.
forEach
(
pref
=
>
{
Services
.
prefs
.
clearUserPref
(
pref
)
;
}
)
;
}
)
;
async
function
openNewTabAndConsole
(
url
clearJstermHistory
=
true
hostId
)
{
const
toolbox
=
await
openNewTabAndToolbox
(
url
"
webconsole
"
hostId
)
;
const
hud
=
toolbox
.
getCurrentPanel
(
)
.
hud
;
if
(
clearJstermHistory
)
{
await
hud
.
ui
.
wrapper
.
dispatchClearHistory
(
)
;
}
return
hud
;
}
async
function
openNewTabWithIframesAndConsole
(
tabUrl
iframes
)
{
await
addTab
(
tabUrl
)
;
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
iframes
async
function
(
urls
)
{
const
iframesLoadPromises
=
urls
.
map
(
(
url
i
)
=
>
{
const
iframe
=
content
.
document
.
createElement
(
"
iframe
"
)
;
iframe
.
classList
.
add
(
iframe
-
{
i
+
1
}
)
;
const
onLoadIframe
=
new
Promise
(
resolve
=
>
{
iframe
.
addEventListener
(
"
load
"
resolve
{
once
:
true
}
)
;
}
)
;
content
.
document
.
body
.
append
(
iframe
)
;
iframe
.
src
=
url
;
return
onLoadIframe
;
}
)
;
await
Promise
.
all
(
iframesLoadPromises
)
;
}
)
;
return
openConsole
(
)
;
}
async
function
openNewWindowAndConsole
(
url
)
{
const
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
tab
=
await
addTab
(
url
{
window
:
win
}
)
;
win
.
gBrowser
.
selectedTab
=
tab
;
const
hud
=
await
openConsole
(
tab
)
;
return
{
win
hud
tab
}
;
}
function
logAllStoreChanges
(
hud
)
{
const
store
=
hud
.
ui
.
wrapper
.
getStore
(
)
;
store
.
subscribe
(
(
)
=
>
{
const
messages
=
[
.
.
.
store
.
getState
(
)
.
messages
.
mutableMessagesById
.
values
(
)
]
;
const
debugMessages
=
messages
.
map
(
(
{
id
type
parameters
messageText
}
)
=
>
{
return
{
id
type
parameters
messageText
}
;
}
)
;
info
(
"
messages
:
"
+
JSON
.
stringify
(
debugMessages
function
(
key
value
)
{
if
(
value
&
&
value
.
getGrip
)
{
return
value
.
getGrip
(
)
;
}
return
value
;
}
)
)
;
}
)
;
}
function
waitForMessagesByType
(
{
hud
messages
}
)
{
return
new
Promise
(
resolve
=
>
{
const
matchedMessages
=
[
]
;
hud
.
ui
.
on
(
"
new
-
messages
"
function
messagesReceived
(
newMessages
)
{
for
(
const
message
of
messages
)
{
if
(
message
.
matched
)
{
continue
;
}
const
typeSelector
=
message
.
typeSelector
;
if
(
!
typeSelector
)
{
throw
new
Error
(
"
typeSelector
property
is
required
"
)
;
}
if
(
!
typeSelector
.
startsWith
(
"
.
"
)
)
{
throw
new
Error
(
"
typeSelector
property
start
with
a
dot
e
.
g
.
.
result
"
)
;
}
const
selector
=
"
.
message
"
+
typeSelector
;
for
(
const
newMessage
of
newMessages
)
{
const
messageBody
=
newMessage
.
node
.
querySelector
(
.
message
-
body
)
;
if
(
messageBody
&
&
newMessage
.
node
.
matches
(
selector
)
&
&
messageBody
.
textContent
.
includes
(
message
.
text
)
)
{
matchedMessages
.
push
(
newMessage
)
;
message
.
matched
=
true
;
const
messagesLeft
=
messages
.
length
-
matchedMessages
.
length
;
info
(
Matched
a
message
with
text
:
"
{
message
.
text
}
"
+
(
messagesLeft
>
0
?
still
waiting
for
{
messagesLeft
}
messages
.
:
all
messages
received
.
)
)
;
break
;
}
}
if
(
matchedMessages
.
length
=
=
=
messages
.
length
)
{
hud
.
ui
.
off
(
"
new
-
messages
"
messagesReceived
)
;
resolve
(
matchedMessages
)
;
return
;
}
}
}
)
;
}
)
;
}
function
waitForRepeatedMessageByType
(
hud
text
typeSelector
repeat
)
{
return
waitFor
(
(
)
=
>
{
const
node
=
findMessageByType
(
hud
text
typeSelector
)
;
if
(
!
node
)
{
return
false
;
}
const
repeatNode
=
node
.
querySelector
(
"
.
message
-
repeats
"
)
;
if
(
repeatNode
&
&
parseInt
(
repeatNode
.
textContent
10
)
=
=
=
repeat
)
{
return
node
;
}
return
false
;
}
)
;
}
async
function
waitForMessageByType
(
hud
text
typeSelector
)
{
const
messages
=
await
waitForMessagesByType
(
{
hud
messages
:
[
{
text
typeSelector
}
]
}
)
;
return
messages
[
0
]
;
}
function
execute
(
hud
input
)
{
return
hud
.
ui
.
wrapper
.
dispatchEvaluateExpression
(
input
)
;
}
function
executeAndWaitForMessageByType
(
hud
input
matchingText
typeSelector
)
{
const
onMessage
=
waitForMessageByType
(
hud
matchingText
typeSelector
)
;
execute
(
hud
input
)
;
return
onMessage
;
}
function
executeAndWaitForResultMessage
(
hud
input
matchingText
)
{
return
executeAndWaitForMessageByType
(
hud
input
matchingText
"
.
result
"
)
;
}
function
executeAndWaitForErrorMessage
(
hud
input
matchingText
)
{
return
executeAndWaitForMessageByType
(
hud
input
matchingText
"
.
error
"
)
;
}
function
keyboardExecuteAndWaitForMessageByType
(
hud
input
matchingText
typeSelector
)
{
hud
.
jsterm
.
focus
(
)
;
setInputValue
(
hud
input
)
;
const
onMessage
=
waitForMessageByType
(
hud
matchingText
typeSelector
)
;
if
(
isEditorModeEnabled
(
hud
)
)
{
EventUtils
.
synthesizeKey
(
"
KEY_Enter
"
{
[
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
"
metaKey
"
:
"
ctrlKey
"
]
:
true
}
)
;
}
else
{
EventUtils
.
synthesizeKey
(
"
VK_RETURN
"
)
;
}
return
onMessage
;
}
function
keyboardExecuteAndWaitForResultMessage
(
hud
input
matchingText
)
{
return
keyboardExecuteAndWaitForMessageByType
(
hud
input
matchingText
"
.
result
"
)
;
}
async
function
checkUniqueMessageExists
(
hud
msg
typeSelector
)
{
info
(
Checking
"
{
msg
}
"
was
logged
)
;
let
messages
;
try
{
messages
=
await
waitFor
(
async
(
)
=
>
{
const
msgs
=
await
findMessagesVirtualizedByType
(
{
hud
text
:
msg
typeSelector
}
)
;
return
msgs
.
length
?
msgs
:
null
;
}
)
;
}
catch
(
e
)
{
ok
(
false
Message
"
{
msg
}
"
wasn
'
t
logged
\
n
)
;
return
;
}
is
(
messages
.
length
1
"
{
msg
}
"
was
logged
once
)
;
const
[
messageEl
]
=
messages
;
const
repeatNode
=
messageEl
.
querySelector
(
"
.
message
-
repeats
"
)
;
is
(
repeatNode
null
"
{
msg
}
"
wasn
'
t
repeated
)
;
}
async
function
openContextMenu
(
hud
element
)
{
const
onConsoleMenuOpened
=
hud
.
ui
.
wrapper
.
once
(
"
menu
-
open
"
)
;
synthesizeContextMenuEvent
(
element
)
;
await
onConsoleMenuOpened
;
return
_getContextMenu
(
hud
)
;
}
function
hideContextMenu
(
hud
)
{
const
popup
=
_getContextMenu
(
hud
)
;
if
(
!
popup
)
{
return
Promise
.
resolve
(
)
;
}
const
onPopupHidden
=
once
(
popup
"
popuphidden
"
)
;
popup
.
hidePopup
(
)
;
return
onPopupHidden
;
}
function
_getContextMenu
(
hud
)
{
const
toolbox
=
hud
.
toolbox
;
const
doc
=
toolbox
?
toolbox
.
topWindow
.
document
:
hud
.
chromeWindow
.
document
;
return
doc
.
getElementById
(
"
webconsole
-
menu
"
)
;
}
async
function
toggleNetworkMonitoringConsoleSetting
(
hud
shouldBeSwitchedOn
)
{
const
selector
=
"
.
webconsole
-
console
-
settings
-
menu
-
item
-
enableNetworkMonitoring
"
;
const
settingChanged
=
waitFor
(
(
)
=
>
{
const
el
=
getConsoleSettingElement
(
hud
selector
)
;
return
shouldBeSwitchedOn
?
el
.
getAttribute
(
"
aria
-
checked
"
)
=
=
=
"
true
"
:
el
.
getAttribute
(
"
aria
-
checked
"
)
!
=
=
"
true
"
;
}
)
;
await
toggleConsoleSetting
(
hud
selector
)
;
await
settingChanged
;
}
async
function
toggleConsoleSetting
(
hud
selector
)
{
const
toolbox
=
hud
.
toolbox
;
const
doc
=
toolbox
?
toolbox
.
doc
:
hud
.
chromeWindow
.
document
;
const
menuItem
=
doc
.
querySelector
(
selector
)
;
menuItem
.
click
(
)
;
}
function
getConsoleSettingElement
(
hud
selector
)
{
const
toolbox
=
hud
.
toolbox
;
const
doc
=
toolbox
?
toolbox
.
doc
:
hud
.
chromeWindow
.
document
;
return
doc
.
querySelector
(
selector
)
;
}
function
checkConsoleSettingState
(
hud
selector
enabled
)
{
const
el
=
getConsoleSettingElement
(
hud
selector
)
;
const
checked
=
el
.
getAttribute
(
"
aria
-
checked
"
)
=
=
=
"
true
"
;
if
(
enabled
)
{
ok
(
checked
"
setting
is
enabled
"
)
;
}
else
{
ok
(
!
checked
"
setting
is
disabled
"
)
;
}
}
function
waitForNodeMutation
(
node
observeConfig
=
{
}
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
MutationObserver
(
mutations
=
>
{
resolve
(
mutations
)
;
observer
.
disconnect
(
)
;
}
)
;
observer
.
observe
(
node
observeConfig
)
;
}
)
;
}
async
function
testOpenInDebugger
(
hud
{
text
typeSelector
expectUrl
=
true
expectLine
=
true
expectColumn
=
true
logPointExpr
=
undefined
}
)
{
info
(
Finding
message
for
open
-
in
-
debugger
test
;
text
is
"
{
text
}
"
)
;
const
messageNode
=
await
waitFor
(
(
)
=
>
findMessageByType
(
hud
text
typeSelector
)
)
;
const
locationNode
=
messageNode
.
querySelector
(
"
.
message
-
location
"
)
;
ok
(
locationNode
"
The
message
does
have
a
location
link
"
)
;
await
checkClickOnNode
(
hud
hud
.
toolbox
locationNode
expectUrl
expectLine
expectColumn
logPointExpr
)
;
}
async
function
checkClickOnNode
(
hud
toolbox
frameLinkNode
expectUrl
expectLine
expectColumn
logPointExpr
)
{
info
(
"
checking
click
on
node
location
"
)
;
await
waitForTime
(
1000
)
;
const
onSourceInDebuggerOpened
=
once
(
hud
"
source
-
in
-
debugger
-
opened
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
frameLinkNode
.
querySelector
(
"
.
frame
-
link
-
filename
"
)
)
;
await
onSourceInDebuggerOpened
;
const
dbg
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
await
waitFor
(
(
)
=
>
!
!
dbg
.
_selectors
.
getSelectedSource
(
dbg
.
_getState
(
)
)
&
&
!
!
dbg
.
_selectors
.
getSelectedLocation
(
dbg
.
_getState
(
)
)
)
;
if
(
expectUrl
)
{
const
url
=
frameLinkNode
.
getAttribute
(
"
data
-
url
"
)
;
ok
(
url
source
url
found
(
"
{
url
}
"
)
)
;
is
(
dbg
.
_selectors
.
getSelectedSource
(
dbg
.
_getState
(
)
)
.
url
url
"
expected
source
url
"
)
;
}
if
(
expectLine
)
{
const
line
=
frameLinkNode
.
getAttribute
(
"
data
-
line
"
)
;
ok
(
line
source
line
found
(
"
{
line
}
"
)
)
;
is
(
parseInt
(
dbg
.
_selectors
.
getSelectedLocation
(
dbg
.
_getState
(
)
)
.
line
10
)
parseInt
(
line
10
)
"
expected
source
line
"
)
;
}
if
(
expectColumn
)
{
const
column
=
frameLinkNode
.
getAttribute
(
"
data
-
column
"
)
;
ok
(
column
source
column
found
(
"
{
column
}
"
)
)
;
is
(
parseInt
(
dbg
.
_selectors
.
getSelectedLocation
(
dbg
.
_getState
(
)
)
.
column
10
)
parseInt
(
column
10
)
"
expected
source
column
"
)
;
}
if
(
logPointExpr
!
=
=
undefined
&
&
logPointExpr
!
=
=
"
"
)
{
const
inputEl
=
dbg
.
panelWin
.
document
.
activeElement
;
is
(
inputEl
.
tagName
"
TEXTAREA
"
"
The
textarea
of
logpoint
panel
is
focused
"
)
;
const
inputValue
=
inputEl
.
parentElement
.
parentElement
.
innerText
.
trim
(
)
;
is
(
inputValue
logPointExpr
"
The
input
in
the
open
logpoint
panel
matches
the
logpoint
expression
"
)
;
}
}
function
hasFocus
(
node
)
{
return
(
node
.
ownerDocument
.
activeElement
=
=
node
&
&
node
.
ownerDocument
.
hasFocus
(
)
)
;
}
function
getInputValue
(
hud
)
{
return
hud
.
jsterm
.
_getValue
(
)
;
}
function
setInputValue
(
hud
value
)
{
const
onValueSet
=
hud
.
jsterm
.
once
(
"
set
-
input
-
value
"
)
;
hud
.
jsterm
.
_setValue
(
value
)
;
return
onValueSet
;
}
async
function
setInputValueForAutocompletion
(
hud
value
caretPosition
=
value
.
length
)
{
const
{
jsterm
}
=
hud
;
const
initialPromises
=
[
]
;
if
(
jsterm
.
autocompletePopup
.
isOpen
)
{
initialPromises
.
push
(
jsterm
.
autocompletePopup
.
once
(
"
popup
-
closed
"
)
)
;
}
setInputValue
(
hud
"
"
)
;
await
Promise
.
all
(
initialPromises
)
;
await
waitForTick
(
)
;
jsterm
.
focus
(
)
;
const
updated
=
jsterm
.
once
(
"
autocomplete
-
updated
"
)
;
EventUtils
.
sendString
(
value
hud
.
iframeWindow
)
;
await
updated
;
await
waitForTick
(
)
;
if
(
caretPosition
<
0
)
{
caretPosition
=
value
.
length
+
caretPosition
;
}
if
(
Number
.
isInteger
(
caretPosition
)
)
{
jsterm
.
editor
.
setCursor
(
jsterm
.
editor
.
getPosition
(
caretPosition
)
)
;
}
}
async
function
setInputValueForGetterConfirmDialog
(
toolbox
hud
value
)
{
await
setInputValueForAutocompletion
(
hud
value
)
;
await
waitFor
(
(
)
=
>
isConfirmDialogOpened
(
toolbox
)
)
;
ok
(
true
"
The
confirm
dialog
is
displayed
"
)
;
return
getConfirmDialog
(
toolbox
)
;
}
function
checkInputCompletionValue
(
hud
expectedValue
assertionInfo
)
{
const
completionValue
=
getInputCompletionValue
(
hud
)
;
if
(
completionValue
=
=
=
null
)
{
ok
(
false
"
Couldn
'
t
retrieve
the
completion
value
"
)
;
}
info
(
Expects
"
{
expectedValue
}
"
is
"
{
completionValue
}
"
)
;
is
(
completionValue
expectedValue
assertionInfo
)
;
}
function
checkInputCursorPosition
(
hud
expectedCursorIndex
assertionInfo
)
{
const
{
jsterm
}
=
hud
;
is
(
jsterm
.
editor
.
getCursor
(
)
.
ch
expectedCursorIndex
assertionInfo
)
;
}
function
checkInputValueAndCursorPosition
(
hud
expectedStringWithCursor
assertionInfo
)
{
info
(
Checking
jsterm
state
:
\
n
{
expectedStringWithCursor
}
)
;
if
(
!
expectedStringWithCursor
.
includes
(
"
|
"
)
)
{
ok
(
false
expectedStringWithCursor
must
contain
a
"
|
"
char
to
indicate
cursor
position
)
;
}
const
inputValue
=
expectedStringWithCursor
.
replace
(
"
|
"
"
"
)
;
const
{
jsterm
}
=
hud
;
is
(
getInputValue
(
hud
)
inputValue
"
console
input
has
expected
value
"
)
;
const
lines
=
expectedStringWithCursor
.
split
(
"
\
n
"
)
;
const
lineWithCursor
=
lines
.
findIndex
(
line
=
>
line
.
includes
(
"
|
"
)
)
;
const
{
ch
line
}
=
jsterm
.
editor
.
getCursor
(
)
;
is
(
line
lineWithCursor
assertionInfo
+
"
-
correct
line
"
)
;
is
(
ch
lines
[
lineWithCursor
]
.
indexOf
(
"
|
"
)
assertionInfo
+
"
-
correct
ch
"
)
;
}
function
getInputCompletionValue
(
hud
)
{
const
{
jsterm
}
=
hud
;
return
jsterm
.
editor
.
getAutoCompletionText
(
)
;
}
function
closeAutocompletePopup
(
hud
)
{
const
{
jsterm
}
=
hud
;
if
(
!
jsterm
.
autocompletePopup
.
isOpen
)
{
return
Promise
.
resolve
(
)
;
}
const
onPopupClosed
=
jsterm
.
autocompletePopup
.
once
(
"
popup
-
closed
"
)
;
const
onAutocompleteUpdated
=
jsterm
.
once
(
"
autocomplete
-
updated
"
)
;
EventUtils
.
synthesizeKey
(
"
KEY_Escape
"
)
;
return
Promise
.
all
(
[
onPopupClosed
onAutocompleteUpdated
]
)
;
}
function
isInputFocused
(
hud
)
{
const
{
jsterm
}
=
hud
;
const
document
=
hud
.
ui
.
outputNode
.
ownerDocument
;
const
documentIsFocused
=
document
.
hasFocus
(
)
;
return
documentIsFocused
&
&
jsterm
.
editor
.
hasFocus
(
)
;
}
async
function
openDebugger
(
options
=
{
}
)
{
if
(
!
options
.
tab
)
{
options
.
tab
=
gBrowser
.
selectedTab
;
}
let
toolbox
=
await
gDevTools
.
getToolboxForTab
(
options
.
tab
)
;
const
dbgPanelAlreadyOpen
=
toolbox
&
&
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
if
(
dbgPanelAlreadyOpen
)
{
await
toolbox
.
selectTool
(
"
jsdebugger
"
)
;
return
{
target
:
toolbox
.
target
toolbox
panel
:
toolbox
.
getCurrentPanel
(
)
}
;
}
toolbox
=
await
gDevTools
.
showToolboxForTab
(
options
.
tab
{
toolId
:
"
jsdebugger
"
}
)
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
await
toolbox
.
threadFront
.
getSources
(
)
;
return
{
target
:
toolbox
.
target
toolbox
panel
}
;
}
async
function
openInspector
(
options
=
{
}
)
{
if
(
!
options
.
tab
)
{
options
.
tab
=
gBrowser
.
selectedTab
;
}
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
options
.
tab
{
toolId
:
"
inspector
"
}
)
;
return
toolbox
.
getCurrentPanel
(
)
;
}
async
function
openNetMonitor
(
tab
)
{
tab
=
tab
|
|
gBrowser
.
selectedTab
;
let
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
!
toolbox
)
{
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
)
;
}
await
toolbox
.
selectTool
(
"
netmonitor
"
)
;
return
toolbox
.
getCurrentPanel
(
)
;
}
async
function
openConsole
(
tab
)
{
tab
=
tab
|
|
gBrowser
.
selectedTab
;
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
webconsole
"
}
)
;
return
toolbox
.
getCurrentPanel
(
)
.
hud
;
}
async
function
closeConsole
(
tab
=
gBrowser
.
selectedTab
)
{
const
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
toolbox
)
{
await
toolbox
.
destroy
(
)
;
}
}
function
simulateLinkClick
(
element
clickEventProps
)
{
return
overrideOpenLink
(
(
)
=
>
{
if
(
clickEventProps
)
{
element
.
dispatchEvent
(
clickEventProps
)
;
}
else
{
element
.
click
(
)
;
}
}
)
;
}
function
overrideOpenLink
(
fn
)
{
const
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
gDevTools
.
chromeWindowType
)
;
const
oldOpenTrustedLinkIn
=
browserWindow
.
openTrustedLinkIn
;
const
oldOpenWebLinkIn
=
browserWindow
.
openWebLinkIn
;
const
onOpenLink
=
new
Promise
(
resolve
=
>
{
const
openLinkIn
=
function
(
link
where
)
{
browserWindow
.
openTrustedLinkIn
=
oldOpenTrustedLinkIn
;
browserWindow
.
openWebLinkIn
=
oldOpenWebLinkIn
;
resolve
(
{
link
where
}
)
;
}
;
browserWindow
.
openWebLinkIn
=
browserWindow
.
openTrustedLinkIn
=
openLinkIn
;
fn
(
)
;
}
)
;
let
timeoutId
;
const
onTimeout
=
new
Promise
(
function
(
resolve
)
{
timeoutId
=
setTimeout
(
(
)
=
>
{
browserWindow
.
openTrustedLinkIn
=
oldOpenTrustedLinkIn
;
browserWindow
.
openWebLinkIn
=
oldOpenWebLinkIn
;
timeoutId
=
null
;
resolve
(
{
link
:
null
where
:
null
}
)
;
}
1000
)
;
}
)
;
onOpenLink
.
then
(
(
)
=
>
{
if
(
timeoutId
)
{
clearTimeout
(
timeoutId
)
;
}
}
)
;
return
Promise
.
race
(
[
onOpenLink
onTimeout
]
)
;
}
async
function
openMessageInNetmonitor
(
toolbox
hud
url
urlInConsole
)
{
urlInConsole
=
urlInConsole
|
|
url
;
const
message
=
await
waitFor
(
(
)
=
>
findMessageByType
(
hud
urlInConsole
"
.
network
"
)
)
;
const
onNetmonitorSelected
=
toolbox
.
once
(
"
netmonitor
-
selected
"
(
event
panel
)
=
>
{
return
panel
;
}
)
;
const
menuPopup
=
await
openContextMenu
(
hud
message
)
;
const
openInNetMenuItem
=
menuPopup
.
querySelector
(
"
#
console
-
menu
-
open
-
in
-
network
-
panel
"
)
;
ok
(
openInNetMenuItem
"
open
in
network
panel
item
is
enabled
"
)
;
menuPopup
.
activateItem
(
openInNetMenuItem
)
;
const
{
panelWin
}
=
await
onNetmonitorSelected
;
ok
(
true
"
The
netmonitor
panel
is
selected
when
clicking
on
the
network
message
"
)
;
const
{
store
windowRequire
}
=
panelWin
;
const
nmActions
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
actions
/
index
"
)
;
const
{
getSelectedRequest
}
=
windowRequire
(
"
devtools
/
client
/
netmonitor
/
src
/
selectors
/
index
"
)
;
store
.
dispatch
(
nmActions
.
batchEnable
(
false
)
)
;
await
waitFor
(
(
)
=
>
{
const
selected
=
getSelectedRequest
(
store
.
getState
(
)
)
;
return
selected
&
&
selected
.
url
=
=
=
url
;
}
network
entry
for
the
URL
"
{
url
}
"
wasn
'
t
found
)
;
ok
(
true
"
The
attached
url
is
correct
.
"
)
;
info
(
"
Wait
for
the
netmonitor
headers
panel
to
appear
as
it
spawns
RDP
requests
"
)
;
await
waitFor
(
(
)
=
>
panelWin
.
document
.
querySelector
(
"
#
headers
-
panel
.
headers
-
overview
"
)
)
;
}
function
selectNode
(
hud
node
)
{
const
outputContainer
=
hud
.
ui
.
outputNode
.
querySelector
(
"
.
webconsole
-
output
"
)
;
outputContainer
.
ownerDocument
.
activeElement
.
blur
(
)
;
const
selection
=
outputContainer
.
ownerDocument
.
getSelection
(
)
;
const
range
=
document
.
createRange
(
)
;
range
.
selectNodeContents
(
node
)
;
selection
.
removeAllRanges
(
)
;
selection
.
addRange
(
range
)
;
return
selection
;
}
async
function
waitForBrowserConsole
(
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
obs
.
addObserver
(
function
observer
(
subject
)
{
Services
.
obs
.
removeObserver
(
observer
"
web
-
console
-
created
"
)
;
subject
.
QueryInterface
(
Ci
.
nsISupportsString
)
;
const
hud
=
BrowserConsoleManager
.
getBrowserConsole
(
)
;
ok
(
hud
"
browser
console
is
open
"
)
;
is
(
subject
.
data
hud
.
hudId
"
notification
hudId
is
correct
"
)
;
executeSoon
(
(
)
=
>
resolve
(
hud
)
)
;
}
"
web
-
console
-
created
"
)
;
}
)
;
}
async
function
getFilterState
(
hud
)
{
const
{
outputNode
}
=
hud
.
ui
;
const
filterBar
=
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
secondary
"
)
;
const
buttons
=
filterBar
.
querySelectorAll
(
"
button
"
)
;
const
result
=
{
}
;
for
(
const
button
of
buttons
)
{
result
[
button
.
dataset
.
category
]
=
button
.
getAttribute
(
"
aria
-
pressed
"
)
=
=
=
"
true
"
;
}
return
result
;
}
function
getFilterInput
(
hud
)
{
return
hud
.
ui
.
outputNode
.
querySelector
(
"
.
devtools
-
searchbox
input
"
)
;
}
async
function
setFilterState
(
hud
settings
)
{
const
{
outputNode
}
=
hud
.
ui
;
const
filterBar
=
outputNode
.
querySelector
(
"
.
webconsole
-
filterbar
-
secondary
"
)
;
for
(
const
category
in
settings
)
{
const
value
=
settings
[
category
]
;
const
button
=
filterBar
.
querySelector
(
[
data
-
category
=
"
{
category
}
"
]
)
;
if
(
category
=
=
=
"
text
"
)
{
const
filterInput
=
getFilterInput
(
hud
)
;
filterInput
.
focus
(
)
;
filterInput
.
select
(
)
;
const
win
=
outputNode
.
ownerDocument
.
defaultView
;
if
(
!
value
)
{
EventUtils
.
synthesizeKey
(
"
KEY_Delete
"
{
}
win
)
;
}
else
{
EventUtils
.
sendString
(
value
win
)
;
}
await
waitFor
(
(
)
=
>
filterInput
.
value
=
=
=
value
)
;
continue
;
}
if
(
!
button
)
{
ok
(
false
setFilterState
(
)
called
with
a
category
of
{
category
}
+
which
doesn
'
t
exist
.
)
;
}
info
(
Setting
the
{
category
}
category
to
{
value
?
"
checked
"
:
"
disabled
"
}
)
;
const
isPressed
=
button
.
getAttribute
(
"
aria
-
pressed
"
)
;
if
(
(
!
value
&
&
isPressed
=
=
=
"
true
"
)
|
|
(
value
&
&
isPressed
!
=
=
"
true
"
)
)
{
button
.
click
(
)
;
await
waitFor
(
(
)
=
>
{
const
pressed
=
button
.
getAttribute
(
"
aria
-
pressed
"
)
;
if
(
!
value
)
{
return
pressed
=
=
=
"
false
"
|
|
pressed
=
=
=
null
;
}
return
pressed
=
=
=
"
true
"
;
}
)
;
}
}
}
async
function
resetFilters
(
hud
)
{
info
(
"
Resetting
filters
to
their
default
state
"
)
;
const
store
=
hud
.
ui
.
wrapper
.
getStore
(
)
;
store
.
dispatch
(
wcActions
.
filtersClear
(
)
)
;
}
async
function
openReverseSearch
(
hud
)
{
info
(
"
Open
the
reverse
search
UI
with
a
keyboard
shortcut
"
)
;
const
onReverseSearchUiOpen
=
waitFor
(
(
)
=
>
getReverseSearchElement
(
hud
)
)
;
const
isMacOS
=
AppConstants
.
platform
=
=
=
"
macosx
"
;
if
(
isMacOS
)
{
EventUtils
.
synthesizeKey
(
"
r
"
{
ctrlKey
:
true
}
)
;
}
else
{
EventUtils
.
synthesizeKey
(
"
VK_F9
"
)
;
}
const
element
=
await
onReverseSearchUiOpen
;
return
element
;
}
function
getReverseSearchElement
(
hud
)
{
const
{
outputNode
}
=
hud
.
ui
;
return
outputNode
.
querySelector
(
"
.
reverse
-
search
"
)
;
}
function
getReverseSearchInfoElement
(
hud
)
{
const
reverseSearchElement
=
getReverseSearchElement
(
hud
)
;
if
(
!
reverseSearchElement
)
{
return
null
;
}
return
reverseSearchElement
.
querySelector
(
"
.
reverse
-
search
-
info
"
)
;
}
function
isReverseSearchInputFocused
(
hud
)
{
const
{
outputNode
}
=
hud
.
ui
;
const
document
=
outputNode
.
ownerDocument
;
const
documentIsFocused
=
document
.
hasFocus
(
)
;
const
reverseSearchInput
=
outputNode
.
querySelector
(
"
.
reverse
-
search
-
input
"
)
;
return
document
.
activeElement
=
=
reverseSearchInput
&
&
documentIsFocused
;
}
function
getEagerEvaluationElement
(
hud
)
{
return
hud
.
ui
.
outputNode
.
querySelector
(
"
.
eager
-
evaluation
-
result
"
)
;
}
async
function
waitForEagerEvaluationResult
(
hud
text
)
{
await
waitUntil
(
(
)
=
>
{
const
elem
=
getEagerEvaluationElement
(
hud
)
;
if
(
elem
)
{
if
(
text
instanceof
RegExp
)
{
return
text
.
test
(
elem
.
innerText
)
;
}
return
elem
.
innerText
=
=
text
;
}
return
false
;
}
)
;
ok
(
true
Got
eager
evaluation
result
{
text
}
)
;
}
async
function
waitForNoEagerEvaluationResult
(
hud
)
{
await
waitUntil
(
(
)
=
>
{
const
elem
=
getEagerEvaluationElement
(
hud
)
;
return
elem
&
&
elem
.
innerText
=
=
"
"
;
}
)
;
ok
(
true
Eager
evaluation
result
disappeared
)
;
}
async
function
selectNodeWithPicker
(
toolbox
selector
)
{
const
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
const
onPickerStarted
=
toolbox
.
nodePicker
.
once
(
"
picker
-
started
"
)
;
toolbox
.
nodePicker
.
start
(
)
;
await
onPickerStarted
;
info
(
Picker
mode
started
now
clicking
on
"
{
selector
}
"
to
select
that
node
)
;
const
onPickerStopped
=
toolbox
.
nodePicker
.
once
(
"
picker
-
stopped
"
)
;
const
onInspectorUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
await
safeSynthesizeMouseEventAtCenterInContentPage
(
selector
)
;
await
onPickerStopped
;
await
onInspectorUpdated
;
}
function
expandObjectInspectorNode
(
node
)
{
const
arrow
=
getObjectInspectorNodeArrow
(
node
)
;
if
(
!
arrow
)
{
ok
(
false
"
Node
can
'
t
be
expanded
"
)
;
return
;
}
arrow
.
click
(
)
;
}
function
getObjectInspectorNodeArrow
(
node
)
{
return
node
.
querySelector
(
"
.
arrow
"
)
;
}
function
isObjectInspectorNodeExpandable
(
node
)
{
return
!
!
getObjectInspectorNodeArrow
(
node
)
;
}
function
getObjectInspectorNodes
(
oi
)
{
return
oi
.
querySelectorAll
(
"
.
tree
-
node
"
)
;
}
function
getObjectInspectorChildrenNodes
(
node
)
{
const
getLevel
=
n
=
>
parseInt
(
n
.
getAttribute
(
"
aria
-
level
"
)
10
)
;
const
level
=
getLevel
(
node
)
;
const
childLevel
=
level
+
1
;
const
children
=
[
]
;
let
currentNode
=
node
;
while
(
currentNode
.
nextSibling
&
&
getLevel
(
currentNode
.
nextSibling
)
=
=
=
childLevel
)
{
currentNode
=
currentNode
.
nextSibling
;
children
.
push
(
currentNode
)
;
}
return
children
;
}
function
getObjectInspectorInvokeGetterButton
(
node
)
{
return
node
.
querySelector
(
"
.
invoke
-
getter
"
)
;
}
function
findObjectInspectorNode
(
oi
nodeLabel
)
{
return
[
.
.
.
oi
.
querySelectorAll
(
"
.
tree
-
node
"
)
]
.
find
(
node
=
>
{
const
label
=
node
.
querySelector
(
"
.
object
-
label
"
)
;
if
(
!
label
)
{
return
false
;
}
return
label
.
textContent
=
=
=
nodeLabel
;
}
)
;
}
function
getAutocompletePopupLabels
(
popup
)
{
return
popup
.
getItems
(
)
.
map
(
item
=
>
item
.
label
)
;
}
function
hasExactPopupLabels
(
popup
expected
)
{
return
hasPopupLabels
(
popup
expected
true
)
;
}
function
hasPopupLabel
(
popup
label
)
{
return
hasPopupLabels
(
popup
[
label
]
)
;
}
function
hasPopupLabels
(
popup
expectedLabels
checkAll
=
false
)
{
const
autocompleteLabels
=
getAutocompletePopupLabels
(
popup
)
;
if
(
checkAll
)
{
return
(
autocompleteLabels
.
length
=
=
=
expectedLabels
.
length
&
&
autocompleteLabels
.
every
(
(
autoLabel
idx
)
=
>
{
return
expectedLabels
.
indexOf
(
autoLabel
)
=
=
=
idx
;
}
)
)
;
}
return
expectedLabels
.
every
(
expectedLabel
=
>
{
return
autocompleteLabels
.
includes
(
expectedLabel
)
;
}
)
;
}
function
getConfirmDialog
(
toolbox
)
{
const
{
doc
}
=
toolbox
;
return
doc
.
querySelector
(
"
.
invoke
-
confirm
"
)
;
}
function
isConfirmDialogOpened
(
toolbox
)
{
const
tooltip
=
getConfirmDialog
(
toolbox
)
;
if
(
!
tooltip
)
{
return
false
;
}
return
tooltip
.
classList
.
contains
(
"
tooltip
-
visible
"
)
;
}
async
function
selectFrame
(
dbg
frame
)
{
const
onScopes
=
waitForDispatch
(
dbg
.
store
"
ADD_SCOPES
"
)
;
await
dbg
.
actions
.
selectFrame
(
dbg
.
selectors
.
getThreadContext
(
)
frame
)
;
await
onScopes
;
}
async
function
pauseDebugger
(
dbg
)
{
info
(
"
Waiting
for
debugger
to
pause
"
)
;
const
onPaused
=
waitForPaused
(
dbg
)
;
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
content
.
wrappedJSObject
.
firstCall
(
)
;
}
)
.
catch
(
(
)
=
>
{
}
)
;
await
onPaused
;
}
function
hasVerticalOverflow
(
container
)
{
return
container
.
scrollHeight
>
container
.
clientHeight
;
}
function
isScrolledToBottom
(
container
)
{
if
(
!
container
.
lastChild
)
{
return
true
;
}
const
lastNodeHeight
=
container
.
lastChild
.
clientHeight
;
return
(
container
.
scrollTop
+
container
.
clientHeight
>
=
container
.
scrollHeight
-
lastNodeHeight
/
2
)
;
}
async
function
checkConsoleOutputForWarningGroup
(
hud
expectedMessages
)
{
const
messages
=
await
findAllMessagesVirtualized
(
hud
)
;
is
(
messages
.
length
expectedMessages
.
length
"
Got
the
expected
number
of
messages
"
)
;
const
isInWarningGroup
=
index
=
>
{
const
message
=
expectedMessages
[
index
]
;
if
(
!
message
.
startsWith
(
"
|
"
)
)
{
return
false
;
}
const
groups
=
expectedMessages
.
slice
(
0
index
)
.
reverse
(
)
.
filter
(
m
=
>
!
m
.
startsWith
(
"
|
"
)
)
;
if
(
groups
.
length
=
=
=
0
)
{
ok
(
false
"
Unexpected
structure
:
an
indented
message
isn
'
t
in
a
group
"
)
;
}
return
groups
[
0
]
.
startsWith
(
"
"
)
|
|
groups
[
0
]
.
startsWith
(
"
"
)
;
}
;
for
(
let
[
i
expectedMessage
]
of
expectedMessages
.
entries
(
)
)
{
const
message
=
await
findMessageVirtualizedById
(
{
hud
messageId
:
messages
[
i
]
.
getAttribute
(
"
data
-
message
-
id
"
)
}
)
;
info
(
Checking
"
{
expectedMessage
}
"
)
;
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
false
"
"
There
'
s
a
collapsed
arrow
"
)
;
is
(
message
.
getAttribute
(
"
data
-
indent
"
)
"
0
"
"
The
warningGroup
has
the
expected
indent
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
true
"
"
There
'
s
an
expanded
arrow
"
)
;
is
(
message
.
getAttribute
(
"
data
-
indent
"
)
"
0
"
"
The
warningGroup
has
the
expected
indent
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
false
"
"
There
'
s
a
collapsed
arrow
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
"
)
)
{
is
(
message
.
querySelector
(
"
.
arrow
"
)
.
getAttribute
(
"
aria
-
expanded
"
)
"
true
"
"
There
'
s
an
expanded
arrow
"
)
;
expectedMessage
=
expectedMessage
.
replace
(
"
"
"
"
)
;
}
if
(
expectedMessage
.
startsWith
(
"
|
"
)
)
{
if
(
isInWarningGroup
(
i
)
)
{
is
(
message
.
getAttribute
(
"
data
-
indent
"
)
"
1
"
"
The
message
has
the
expected
indent
"
)
;
}
expectedMessage
=
expectedMessage
.
replace
(
"
|
"
"
"
)
;
}
else
{
is
(
message
.
getAttribute
(
"
data
-
indent
"
)
"
0
"
"
The
message
has
the
expected
indent
"
)
;
}
ok
(
message
.
textContent
.
trim
(
)
.
includes
(
expectedMessage
.
trim
(
)
)
Message
includes
+
the
expected
"
{
expectedMessage
}
"
content
-
"
{
message
.
textContent
.
trim
(
)
}
"
)
;
}
}
async
function
checkMessageStack
(
hud
text
expectedFrameLines
)
{
info
(
Checking
message
stack
for
"
{
text
}
"
)
;
const
msgNode
=
await
waitFor
(
(
)
=
>
findErrorMessage
(
hud
text
)
Couln
'
t
find
message
including
"
{
text
}
"
)
;
ok
(
!
msgNode
.
classList
.
contains
(
"
open
"
)
Error
logged
not
expanded
)
;
const
button
=
await
waitFor
(
(
)
=
>
msgNode
.
querySelector
(
"
.
collapse
-
button
"
)
Couldn
'
t
find
the
expand
button
on
"
{
text
}
"
message
)
;
button
.
click
(
)
;
const
framesNode
=
await
waitFor
(
(
)
=
>
msgNode
.
querySelector
(
"
.
message
-
body
-
wrapper
>
.
stacktrace
.
frames
"
)
Couldn
'
t
find
stacktrace
frames
on
"
{
text
}
"
message
)
;
const
frameNodes
=
Array
.
from
(
framesNode
.
querySelectorAll
(
"
.
frame
"
)
)
.
filter
(
el
=
>
{
const
fileName
=
el
.
querySelector
(
"
.
filename
"
)
.
textContent
;
return
(
fileName
!
=
=
"
self
-
hosted
"
&
&
!
fileName
.
startsWith
(
"
chrome
:
"
)
&
&
!
fileName
.
startsWith
(
"
resource
:
"
)
)
;
}
)
;
for
(
let
i
=
0
;
i
<
frameNodes
.
length
;
i
+
+
)
{
const
frameNode
=
frameNodes
[
i
]
;
is
(
frameNode
.
querySelector
(
"
.
line
"
)
.
textContent
expectedFrameLines
[
i
]
.
toString
(
)
Found
line
{
expectedFrameLines
[
i
]
}
for
frame
#
{
i
}
)
;
}
is
(
frameNodes
.
length
expectedFrameLines
.
length
Found
{
frameNodes
.
length
}
frames
)
;
}
function
reloadPage
(
)
{
const
onLoad
=
BrowserTestUtils
.
waitForContentEvent
(
gBrowser
.
selectedBrowser
"
load
"
true
)
;
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
{
content
.
location
.
reload
(
)
;
}
)
;
return
onLoad
;
}
function
isEditorModeEnabled
(
hud
)
{
const
{
outputNode
}
=
hud
.
ui
;
const
appNode
=
outputNode
.
querySelector
(
"
.
webconsole
-
app
"
)
;
return
appNode
.
classList
.
contains
(
"
jsterm
-
editor
"
)
;
}
function
toggleLayout
(
hud
)
{
const
isMacOS
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
enabled
=
isEditorModeEnabled
(
hud
)
;
EventUtils
.
synthesizeKey
(
"
b
"
{
[
isMacOS
?
"
metaKey
"
:
"
ctrlKey
"
]
:
true
}
)
;
return
waitFor
(
(
)
=
>
isEditorModeEnabled
(
hud
)
=
=
=
!
enabled
)
;
}
async
function
waitForLazyRequests
(
toolbox
)
{
const
ui
=
toolbox
.
getCurrentPanel
(
)
.
hud
.
ui
;
return
waitUntil
(
(
)
=
>
{
return
(
!
ui
.
networkDataProvider
.
lazyRequestData
.
size
&
&
!
ui
.
wrapper
.
queuedRequestUpdates
.
length
)
;
}
)
;
}
async
function
clearOutput
(
hud
{
keepStorage
=
false
}
=
{
}
)
{
const
{
ui
}
=
hud
;
const
promises
=
[
ui
.
once
(
"
messages
-
cleared
"
)
]
;
if
(
ui
.
outputNode
.
querySelector
(
"
.
object
-
inspector
"
)
)
{
promises
.
push
(
ui
.
once
(
"
fronts
-
released
"
)
)
;
}
ui
.
clearOutput
(
!
keepStorage
)
;
await
Promise
.
all
(
promises
)
;
}
function
getContextSelectorItems
(
hud
)
{
const
toolbox
=
hud
.
toolbox
;
const
doc
=
toolbox
?
toolbox
.
doc
:
hud
.
chromeWindow
.
document
;
const
list
=
doc
.
getElementById
(
"
webconsole
-
console
-
evaluation
-
context
-
selector
-
menu
-
list
"
)
;
return
Array
.
from
(
list
.
querySelectorAll
(
"
li
.
menuitem
button
hr
"
)
)
;
}
function
checkContextSelectorMenu
(
hud
expected
)
{
const
items
=
getContextSelectorItems
(
hud
)
;
is
(
items
.
length
expected
.
length
"
The
context
selector
menu
has
the
expected
number
of
items
"
)
;
expected
.
forEach
(
(
expectedItem
i
)
=
>
{
checkContextSelectorMenuItemAt
(
hud
i
expectedItem
)
;
}
)
;
}
function
checkContextSelectorMenuItemAt
(
hud
index
expected
)
{
const
el
=
getContextSelectorItems
(
hud
)
.
at
(
index
)
;
if
(
expected
.
separator
=
=
=
true
)
{
is
(
el
.
getAttribute
(
"
role
"
)
"
menuseparator
"
"
The
element
is
a
separator
"
)
;
return
;
}
const
elChecked
=
el
.
getAttribute
(
"
aria
-
checked
"
)
=
=
=
"
true
"
;
const
elTooltip
=
el
.
getAttribute
(
"
title
"
)
;
const
elLabel
=
el
.
querySelector
(
"
.
label
"
)
.
innerText
;
is
(
elLabel
expected
.
label
The
item
has
the
expected
label
)
;
is
(
elTooltip
expected
.
tooltip
Item
"
{
elLabel
}
"
has
the
expected
tooltip
)
;
is
(
elChecked
expected
.
checked
Item
"
{
elLabel
}
"
is
{
expected
.
checked
?
"
checked
"
:
"
unchecked
"
}
)
;
}
function
selectTargetInContextSelector
(
hud
targetLabel
)
{
const
items
=
getContextSelectorItems
(
hud
)
;
const
itemToSelect
=
items
.
find
(
item
=
>
item
.
querySelector
(
"
.
label
"
)
?
.
innerText
=
=
=
targetLabel
)
;
if
(
!
itemToSelect
)
{
ok
(
false
Couldn
'
t
find
target
with
"
{
targetLabel
}
"
label
)
;
return
;
}
itemToSelect
.
click
(
)
;
}
async
function
getImageSizeFromClipboard
(
)
{
const
clipid
=
Ci
.
nsIClipboard
;
const
clip
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
]
.
getService
(
clipid
)
;
const
trans
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
const
flavor
=
"
image
/
png
"
;
trans
.
init
(
null
)
;
trans
.
addDataFlavor
(
flavor
)
;
clip
.
getData
(
trans
clipid
.
kGlobalClipboard
)
;
const
data
=
{
}
;
trans
.
getTransferData
(
flavor
data
)
;
ok
(
data
.
value
"
screenshot
exists
"
)
;
let
image
=
data
.
value
;
if
(
image
instanceof
Ci
.
imgIContainer
)
{
image
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
encodeImage
(
image
flavor
)
;
}
if
(
!
(
image
instanceof
Ci
.
nsIInputStream
)
)
{
throw
new
Error
(
"
Unable
to
read
image
data
"
)
;
}
const
binaryStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
binaryStream
.
setInputStream
(
image
)
;
const
available
=
binaryStream
.
available
(
)
;
const
buffer
=
new
ArrayBuffer
(
available
)
;
is
(
binaryStream
.
readArrayBuffer
(
available
buffer
)
available
"
Read
expected
amount
of
data
"
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
buffer
]
async
function
(
_buffer
)
{
const
img
=
content
.
document
.
createElement
(
"
img
"
)
;
const
loaded
=
new
Promise
(
r
=
>
{
img
.
addEventListener
(
"
load
"
r
{
once
:
true
}
)
;
}
)
;
const
url
=
content
.
URL
.
createObjectURL
(
new
Blob
(
[
_buffer
]
{
type
:
"
image
/
png
"
}
)
)
;
img
.
src
=
url
;
content
.
document
.
documentElement
.
appendChild
(
img
)
;
info
(
"
Waiting
for
the
clipboard
image
to
load
in
the
content
page
"
)
;
await
loaded
;
img
.
remove
(
)
;
content
.
URL
.
revokeObjectURL
(
url
)
;
return
{
width
:
img
.
width
height
:
img
.
height
}
;
}
)
;
}
