"
use
strict
"
;
async
function
findMessageVirtualizedById
(
{
hud
messageId
}
)
{
if
(
!
messageId
)
{
throw
new
Error
(
"
messageId
parameter
is
required
"
)
;
}
const
elements
=
await
findMessagesVirtualized
(
{
hud
expectedCount
:
1
messageId
}
)
;
return
elements
.
at
(
-
1
)
;
}
async
function
findMessageVirtualizedByType
(
{
hud
text
typeSelector
}
)
{
const
elements
=
await
findMessagesVirtualizedByType
(
{
hud
text
typeSelector
expectedCount
:
1
}
)
;
return
elements
.
at
(
-
1
)
;
}
async
function
findAllMessagesVirtualized
(
hud
)
{
return
findMessagesVirtualized
(
{
hud
}
)
;
}
let
gInFindMessagesVirtualized
=
false
;
let
gFindMessagesVirtualizedStack
=
null
;
async
function
findMessagesVirtualizedByType
(
{
hud
text
typeSelector
expectedCount
}
)
{
if
(
!
typeSelector
)
{
throw
new
Error
(
"
typeSelector
parameter
is
required
"
)
;
}
if
(
!
typeSelector
.
startsWith
(
"
.
"
)
)
{
throw
new
Error
(
"
typeSelector
should
start
with
a
dot
e
.
g
.
.
result
"
)
;
}
return
findMessagesVirtualized
(
{
hud
text
selector
:
"
.
message
"
+
typeSelector
expectedCount
}
)
;
}
async
function
findMessagesVirtualized
(
{
hud
text
selector
expectedCount
messageId
}
)
{
if
(
text
=
=
=
undefined
)
{
text
=
"
"
;
}
if
(
selector
=
=
=
undefined
)
{
selector
=
"
.
message
"
;
}
if
(
expectedCount
=
=
=
undefined
)
{
expectedCount
=
-
1
;
}
const
outputNode
=
hud
.
ui
.
outputNode
;
const
scrollport
=
outputNode
.
querySelector
(
"
.
webconsole
-
output
"
)
;
function
getVisibleMessageIds
(
)
{
return
JSON
.
parse
(
scrollport
.
getAttribute
(
"
data
-
visible
-
messages
"
)
)
;
}
function
getVisibleMessageMap
(
)
{
return
new
Map
(
JSON
.
parse
(
scrollport
.
getAttribute
(
"
data
-
visible
-
messages
"
)
)
.
map
(
(
id
i
)
=
>
[
id
i
]
)
)
;
}
function
getMessageIndex
(
message
)
{
return
getVisibleMessageIds
(
)
.
indexOf
(
message
.
getAttribute
(
"
data
-
message
-
id
"
)
)
;
}
function
getNextMessageId
(
prevMessage
)
{
const
visible
=
getVisibleMessageIds
(
)
;
let
index
=
0
;
if
(
prevMessage
)
{
const
lastId
=
prevMessage
.
getAttribute
(
"
data
-
message
-
id
"
)
;
index
=
visible
.
indexOf
(
lastId
)
;
if
(
index
=
=
=
-
1
)
{
throw
new
Error
(
Tried
to
get
next
message
ID
for
message
that
doesn
'
t
exist
.
Last
seen
ID
:
{
lastId
}
all
visible
ids
:
[
{
visible
.
join
(
"
"
)
}
]
)
;
}
}
if
(
index
+
1
>
=
visible
.
length
)
{
return
null
;
}
return
visible
[
index
+
1
]
;
}
if
(
gInFindMessagesVirtualized
)
{
throw
new
Error
(
findMessagesVirtualized
was
re
-
entered
somehow
.
This
is
not
allowed
.
Other
stack
:
[
{
gFindMessagesVirtualizedStack
}
]
)
;
}
try
{
gInFindMessagesVirtualized
=
true
;
gFindMessagesVirtualizedStack
=
new
Error
(
)
.
stack
;
scrollport
.
setAttribute
(
"
disable
-
autoscroll
"
"
"
)
;
const
allIndices
=
[
]
;
const
allElements
=
[
]
;
const
seenIds
=
new
Set
(
)
;
let
lastItem
=
null
;
while
(
true
)
{
if
(
scrollport
.
scrollHeight
>
scrollport
.
clientHeight
)
{
if
(
!
lastItem
&
&
scrollport
.
scrollTop
!
=
0
)
{
scrollport
.
scrollTop
=
0
;
}
else
if
(
!
lastItem
&
&
scrollport
.
scrollTop
=
=
0
)
{
scrollport
.
scrollTop
=
1
;
}
else
{
scrollport
.
scrollTop
=
scrollport
.
scrollTop
+
scrollport
.
clientHeight
;
}
await
new
Promise
(
resolve
=
>
hud
.
ui
.
once
(
"
lazy
-
message
-
list
-
updated
-
or
-
noop
"
resolve
)
)
;
try
{
await
waitFor
(
async
(
)
=
>
{
const
nextMessageId
=
getNextMessageId
(
lastItem
)
;
if
(
nextMessageId
=
=
=
undefined
|
|
scrollport
.
querySelector
(
[
data
-
message
-
id
=
"
{
nextMessageId
}
"
]
)
)
{
return
true
;
}
const
scrollTarget
=
scrollport
.
scrollTop
+
scrollport
.
clientHeight
;
scrollport
.
scrollTop
=
scrollTarget
;
await
new
Promise
(
resolve
=
>
hud
.
ui
.
once
(
"
lazy
-
message
-
list
-
updated
-
or
-
noop
"
resolve
)
)
;
return
false
;
}
)
;
}
catch
(
e
)
{
throw
new
Error
(
Failed
waiting
for
next
message
ID
(
{
getNextMessageId
(
lastItem
)
}
)
Visible
messages
:
[
{
[
.
.
.
scrollport
.
querySelectorAll
(
"
.
message
"
)
]
.
map
(
el
=
>
el
.
getAttribute
(
"
data
-
message
-
id
"
)
)
}
]
)
;
}
}
const
bottomPlaceholder
=
scrollport
.
querySelector
(
"
.
lazy
-
message
-
list
-
bottom
"
)
;
if
(
!
bottomPlaceholder
)
{
break
;
}
lastItem
=
bottomPlaceholder
.
previousSibling
;
const
indices
=
[
.
.
.
scrollport
.
querySelectorAll
(
"
[
data
-
message
-
id
]
"
)
]
.
filter
(
el
=
>
el
!
=
=
scrollport
.
firstChild
&
&
el
!
=
=
scrollport
.
lastChild
)
.
map
(
el
=
>
getMessageIndex
(
el
)
)
;
allIndices
.
push
(
.
.
.
indices
)
;
allIndices
.
sort
(
(
lhs
rhs
)
=
>
lhs
-
rhs
)
;
for
(
let
i
=
1
;
i
<
allIndices
.
length
;
i
+
+
)
{
if
(
allIndices
[
i
]
!
=
allIndices
[
i
-
1
]
&
&
allIndices
[
i
]
!
=
allIndices
[
i
-
1
]
+
1
)
{
throw
new
Error
(
Gap
detected
in
virtualized
webconsole
output
between
{
allIndices
[
i
-
1
]
}
and
{
allIndices
[
i
]
}
.
Indices
:
{
allIndices
.
join
(
"
"
)
}
)
;
}
}
const
messages
=
scrollport
.
querySelectorAll
(
selector
)
;
const
filtered
=
[
.
.
.
messages
]
.
filter
(
el
=
>
el
.
textContent
.
includes
(
text
)
&
&
(
!
messageId
|
|
el
.
getAttribute
(
"
data
-
message
-
id
"
)
=
=
=
messageId
)
&
&
!
seenIds
.
has
(
el
.
getAttribute
(
"
data
-
message
-
id
"
)
)
)
;
allElements
.
push
(
.
.
.
filtered
)
;
for
(
const
message
of
filtered
)
{
seenIds
.
add
(
message
.
getAttribute
(
"
data
-
message
-
id
"
)
)
;
}
if
(
expectedCount
>
=
0
&
&
allElements
.
length
>
=
expectedCount
)
{
break
;
}
if
(
bottomPlaceholder
.
getBoundingClientRect
(
)
.
height
=
=
0
)
{
break
;
}
await
waitForTime
(
0
)
;
}
const
idsToIndices
=
getVisibleMessageMap
(
)
;
allElements
.
sort
(
(
lhs
rhs
)
=
>
idsToIndices
.
get
(
lhs
.
getAttribute
(
"
data
-
message
-
id
"
)
)
-
idsToIndices
.
get
(
rhs
.
getAttribute
(
"
data
-
message
-
id
"
)
)
)
;
return
allElements
;
}
finally
{
scrollport
.
removeAttribute
(
"
disable
-
autoscroll
"
)
;
gInFindMessagesVirtualized
=
false
;
gFindMessagesVirtualizedStack
=
null
;
}
}
function
findMessageByType
(
hud
text
typeSelector
)
{
const
elements
=
findMessagesByType
(
hud
text
typeSelector
)
;
return
elements
.
at
(
-
1
)
;
}
function
findMessagesByType
(
hud
text
typeSelector
)
{
if
(
!
typeSelector
)
{
throw
new
Error
(
"
typeSelector
parameter
is
required
"
)
;
}
if
(
!
typeSelector
.
startsWith
(
"
.
"
)
)
{
throw
new
Error
(
"
typeSelector
should
start
with
a
dot
e
.
g
.
.
result
"
)
;
}
const
selector
=
"
.
message
"
+
typeSelector
;
const
messages
=
hud
.
ui
.
outputNode
.
querySelectorAll
(
selector
)
;
const
elements
=
Array
.
from
(
messages
)
.
filter
(
el
=
>
el
.
textContent
.
includes
(
text
)
)
;
return
elements
;
}
function
findAllMessages
(
hud
)
{
const
messages
=
hud
.
ui
.
outputNode
.
querySelectorAll
(
"
.
message
"
)
;
return
Array
.
from
(
messages
)
;
}
function
findMessagePartByType
(
hud
options
)
{
const
elements
=
findMessagePartsByType
(
hud
options
)
;
return
elements
.
at
(
-
1
)
;
}
function
findMessagePartsByType
(
hud
{
text
typeSelector
partSelector
}
)
{
if
(
!
typeSelector
)
{
throw
new
Error
(
"
typeSelector
parameter
is
required
"
)
;
}
if
(
!
typeSelector
.
startsWith
(
"
.
"
)
)
{
throw
new
Error
(
"
typeSelector
should
start
with
a
dot
e
.
g
.
.
result
"
)
;
}
if
(
!
partSelector
)
{
throw
new
Error
(
"
partSelector
parameter
is
required
"
)
;
}
const
selector
=
"
.
message
"
+
typeSelector
+
"
"
+
partSelector
;
const
parts
=
hud
.
ui
.
outputNode
.
querySelectorAll
(
selector
)
;
const
elements
=
Array
.
from
(
parts
)
.
filter
(
el
=
>
el
.
textContent
.
includes
(
text
)
)
;
return
elements
;
}
function
findEvaluationResultMessage
(
hud
text
extraSelector
=
"
"
)
{
return
findMessageByType
(
hud
text
"
.
result
"
+
extraSelector
)
;
}
function
findEvaluationResultMessages
(
hud
text
extraSelector
=
"
"
)
{
return
findMessagesByType
(
hud
text
"
.
result
"
+
extraSelector
)
;
}
function
findErrorMessage
(
hud
text
extraSelector
=
"
"
)
{
return
findMessageByType
(
hud
text
"
.
error
"
+
extraSelector
)
;
}
function
findErrorMessages
(
hud
text
extraSelector
=
"
"
)
{
return
findMessagesByType
(
hud
text
"
.
error
"
+
extraSelector
)
;
}
function
findWarningMessage
(
hud
text
extraSelector
=
"
"
)
{
return
findMessageByType
(
hud
text
"
.
warn
"
+
extraSelector
)
;
}
function
findWarningMessages
(
hud
text
extraSelector
=
"
"
)
{
return
findMessagesByType
(
hud
text
"
.
warn
"
+
extraSelector
)
;
}
function
findConsoleAPIMessage
(
hud
text
extraSelector
=
"
"
)
{
return
findMessageByType
(
hud
text
"
.
console
-
api
"
+
extraSelector
)
;
}
function
findConsoleAPIMessages
(
hud
text
extraSelector
=
"
"
)
{
return
findMessagesByType
(
hud
text
"
.
console
-
api
"
+
extraSelector
)
;
}
function
findNetworkMessage
(
hud
text
extraSelector
=
"
"
)
{
return
findMessageByType
(
hud
text
"
.
network
"
+
extraSelector
)
;
}
function
findNetworkMessages
(
hud
text
extraSelector
=
"
"
)
{
return
findMessagesByType
(
hud
text
"
.
network
"
+
extraSelector
)
;
}
function
findTracerMessages
(
hud
text
extraSelector
=
"
"
)
{
return
findMessagesByType
(
hud
text
"
.
jstracer
"
+
extraSelector
)
;
}
