"
use
strict
"
;
async
function
findMessageVirtualized
(
{
hud
text
selector
messageId
}
)
{
const
elements
=
await
findMessagesVirtualized
(
{
hud
text
selector
expectedCount
:
1
messageId
}
)
;
return
elements
.
at
(
-
1
)
;
}
async
function
findAllMessagesVirtualized
(
hud
)
{
return
findMessagesVirtualized
(
{
hud
}
)
;
}
let
gInFindMessagesVirtualized
=
false
;
let
gFindMessagesVirtualizedStack
=
null
;
async
function
findMessagesVirtualized
(
{
hud
text
selector
expectedCount
messageId
}
)
{
if
(
text
=
=
=
undefined
)
{
text
=
"
"
;
}
if
(
selector
=
=
=
undefined
)
{
selector
=
"
.
message
"
;
}
if
(
expectedCount
=
=
=
undefined
)
{
expectedCount
=
-
1
;
}
const
outputNode
=
hud
.
ui
.
outputNode
;
const
scrollport
=
outputNode
.
querySelector
(
"
.
webconsole
-
output
"
)
;
function
getVisibleMessageIds
(
)
{
return
JSON
.
parse
(
scrollport
.
getAttribute
(
"
data
-
visible
-
messages
"
)
)
;
}
function
getVisibleMessageMap
(
)
{
return
new
Map
(
JSON
.
parse
(
scrollport
.
getAttribute
(
"
data
-
visible
-
messages
"
)
)
.
map
(
(
id
i
)
=
>
[
id
i
]
)
)
;
}
function
getMessageIndex
(
message
)
{
return
getVisibleMessageIds
(
)
.
indexOf
(
message
.
getAttribute
(
"
data
-
message
-
id
"
)
)
;
}
function
getNextMessageId
(
prevMessage
)
{
const
visible
=
getVisibleMessageIds
(
)
;
let
index
=
0
;
if
(
prevMessage
)
{
const
lastId
=
prevMessage
.
getAttribute
(
"
data
-
message
-
id
"
)
;
index
=
visible
.
indexOf
(
lastId
)
;
if
(
index
=
=
=
-
1
)
{
throw
new
Error
(
Tried
to
get
next
message
ID
for
message
that
doesn
'
t
exist
.
Last
seen
ID
:
{
lastId
}
all
visible
ids
:
[
{
visible
.
join
(
"
"
)
}
]
)
;
}
}
if
(
index
+
1
>
=
visible
.
length
)
{
return
null
;
}
return
visible
[
index
+
1
]
;
}
if
(
gInFindMessagesVirtualized
)
{
throw
new
Error
(
findMessagesVirtualized
was
re
-
entered
somehow
.
This
is
not
allowed
.
Other
stack
:
[
{
gFindMessagesVirtualizedStack
}
]
)
;
}
try
{
gInFindMessagesVirtualized
=
true
;
gFindMessagesVirtualizedStack
=
new
Error
(
)
.
stack
;
scrollport
.
setAttribute
(
"
disable
-
autoscroll
"
"
"
)
;
const
allIndices
=
[
]
;
const
allElements
=
[
]
;
const
seenIds
=
new
Set
(
)
;
let
lastItem
=
null
;
while
(
true
)
{
if
(
scrollport
.
scrollHeight
>
scrollport
.
clientHeight
)
{
if
(
!
lastItem
&
&
scrollport
.
scrollTop
!
=
0
)
{
scrollport
.
scrollTop
=
0
;
}
else
if
(
!
lastItem
&
&
scrollport
.
scrollTop
=
=
0
)
{
scrollport
.
scrollTop
=
1
;
}
else
{
scrollport
.
scrollTop
=
scrollport
.
scrollTop
+
scrollport
.
clientHeight
;
}
await
new
Promise
(
resolve
=
>
hud
.
ui
.
once
(
"
lazy
-
message
-
list
-
updated
-
or
-
noop
"
resolve
)
)
;
try
{
await
waitFor
(
async
(
)
=
>
{
const
nextMessageId
=
getNextMessageId
(
lastItem
)
;
if
(
nextMessageId
=
=
=
undefined
|
|
scrollport
.
querySelector
(
[
data
-
message
-
id
=
"
{
nextMessageId
}
"
]
)
)
{
return
true
;
}
const
scrollTarget
=
scrollport
.
scrollTop
+
scrollport
.
clientHeight
;
scrollport
.
scrollTop
=
scrollTarget
;
await
new
Promise
(
resolve
=
>
hud
.
ui
.
once
(
"
lazy
-
message
-
list
-
updated
-
or
-
noop
"
resolve
)
)
;
return
false
;
}
)
;
}
catch
(
e
)
{
throw
new
Error
(
Failed
waiting
for
next
message
ID
(
{
getNextMessageId
(
lastItem
)
}
)
Visible
messages
:
[
{
[
.
.
.
scrollport
.
querySelectorAll
(
"
.
message
"
)
]
.
map
(
el
=
>
el
.
getAttribute
(
"
data
-
message
-
id
"
)
)
}
]
)
;
}
}
const
bottomPlaceholder
=
scrollport
.
querySelector
(
"
.
lazy
-
message
-
list
-
bottom
"
)
;
if
(
!
bottomPlaceholder
)
{
break
;
}
lastItem
=
bottomPlaceholder
.
previousSibling
;
const
indices
=
[
.
.
.
scrollport
.
querySelectorAll
(
"
[
data
-
message
-
id
]
"
)
]
.
filter
(
el
=
>
el
!
=
=
scrollport
.
firstChild
&
&
el
!
=
=
scrollport
.
lastChild
)
.
map
(
el
=
>
getMessageIndex
(
el
)
)
;
allIndices
.
push
(
.
.
.
indices
)
;
allIndices
.
sort
(
(
lhs
rhs
)
=
>
lhs
-
rhs
)
;
for
(
let
i
=
1
;
i
<
allIndices
.
length
;
i
+
+
)
{
if
(
allIndices
[
i
]
!
=
allIndices
[
i
-
1
]
&
&
allIndices
[
i
]
!
=
allIndices
[
i
-
1
]
+
1
)
{
throw
new
Error
(
Gap
detected
in
virtualized
webconsole
output
between
{
allIndices
[
i
-
1
]
}
and
{
allIndices
[
i
]
}
.
Indices
:
{
allIndices
.
join
(
"
"
)
}
)
;
}
}
const
messages
=
scrollport
.
querySelectorAll
(
selector
)
;
const
filtered
=
[
.
.
.
messages
]
.
filter
(
el
=
>
el
.
textContent
.
includes
(
text
)
&
&
(
!
messageId
|
|
el
.
getAttribute
(
"
data
-
message
-
id
"
)
=
=
=
messageId
)
&
&
!
seenIds
.
has
(
el
.
getAttribute
(
"
data
-
message
-
id
"
)
)
)
;
allElements
.
push
(
.
.
.
filtered
)
;
for
(
const
message
of
filtered
)
{
seenIds
.
add
(
message
.
getAttribute
(
"
data
-
message
-
id
"
)
)
;
}
if
(
expectedCount
>
=
0
&
&
allElements
.
length
>
=
expectedCount
)
{
break
;
}
if
(
bottomPlaceholder
.
getBoundingClientRect
(
)
.
height
=
=
0
)
{
break
;
}
await
waitForTime
(
0
)
;
}
const
idsToIndices
=
getVisibleMessageMap
(
)
;
allElements
.
sort
(
(
lhs
rhs
)
=
>
idsToIndices
.
get
(
lhs
.
getAttribute
(
"
data
-
message
-
id
"
)
)
-
idsToIndices
.
get
(
rhs
.
getAttribute
(
"
data
-
message
-
id
"
)
)
)
;
return
allElements
;
}
finally
{
scrollport
.
removeAttribute
(
"
disable
-
autoscroll
"
)
;
gInFindMessagesVirtualized
=
false
;
gFindMessagesVirtualizedStack
=
null
;
}
}
