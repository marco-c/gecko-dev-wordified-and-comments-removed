"
use
strict
"
;
const
TEST_URI
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
webconsole
/
"
+
"
test
/
browser
/
test_jsterm_screenshot_command
.
html
"
;
const
dpr
=
"
-
-
dpr
1
"
;
add_task
(
async
function
(
)
{
const
hud
=
await
openNewTabAndConsole
(
TEST_URI
)
;
ok
(
hud
"
web
console
opened
"
)
;
await
testClipboard
(
hud
)
;
await
testFullpageClipboard
(
hud
)
;
await
testSelectorClipboard
(
hud
)
;
await
createScrollbarOverflow
(
)
;
await
testFullpageClipboardScrollbar
(
hud
)
;
}
)
;
async
function
testClipboard
(
hud
)
{
const
command
=
:
screenshot
-
-
clipboard
{
dpr
}
;
await
executeScreenshotClipboardCommand
(
hud
command
)
;
const
contentSize
=
await
getContentSize
(
)
;
const
imgSize
=
await
getImageSizeFromClipboard
(
)
;
is
(
imgSize
.
width
contentSize
.
innerWidth
"
Clipboard
:
Image
width
matches
window
size
"
)
;
is
(
imgSize
.
height
contentSize
.
innerHeight
"
Clipboard
:
Image
height
matches
window
size
"
)
;
}
async
function
testFullpageClipboard
(
hud
)
{
const
command
=
:
screenshot
-
-
fullpage
-
-
clipboard
{
dpr
}
;
await
executeScreenshotClipboardCommand
(
hud
command
)
;
const
contentSize
=
await
getContentSize
(
)
;
const
imgSize
=
await
getImageSizeFromClipboard
(
)
;
is
(
imgSize
.
width
contentSize
.
innerWidth
+
contentSize
.
scrollMaxX
-
contentSize
.
scrollMinX
"
Fullpage
Clipboard
:
Image
width
matches
page
size
"
)
;
is
(
imgSize
.
height
contentSize
.
innerHeight
+
contentSize
.
scrollMaxY
-
contentSize
.
scrollMinY
"
Fullpage
Clipboard
:
Image
height
matches
page
size
"
)
;
}
async
function
testSelectorClipboard
(
hud
)
{
const
command
=
:
screenshot
-
-
selector
"
img
#
testImage
"
-
-
clipboard
{
dpr
}
;
await
executeScreenshotClipboardCommand
(
hud
command
)
;
const
imgSize1
=
await
getImageSizeFromClipboard
(
)
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
imgSize1
]
function
(
imgSize
)
{
const
img
=
content
.
document
.
querySelector
(
"
#
testImage
"
)
;
is
(
imgSize
.
width
img
.
clientWidth
"
Selector
Clipboard
:
Image
width
matches
element
size
"
)
;
is
(
imgSize
.
height
img
.
clientHeight
"
Selector
Clipboard
:
Image
height
matches
element
size
"
)
;
}
)
;
}
async
function
testFullpageClipboardScrollbar
(
hud
)
{
const
command
=
:
screenshot
-
-
fullpage
-
-
clipboard
{
dpr
}
;
await
executeScreenshotClipboardCommand
(
hud
command
)
;
const
contentSize
=
await
getContentSize
(
)
;
const
scrollbarSize
=
await
getScrollbarSize
(
)
;
const
imgSize
=
await
getImageSizeFromClipboard
(
)
;
is
(
imgSize
.
width
contentSize
.
innerWidth
+
contentSize
.
scrollMaxX
-
contentSize
.
scrollMinX
-
scrollbarSize
.
width
"
Scroll
Fullpage
Clipboard
:
Image
width
matches
page
size
minus
scrollbar
size
"
)
;
is
(
imgSize
.
height
contentSize
.
innerHeight
+
contentSize
.
scrollMaxY
-
contentSize
.
scrollMinY
-
scrollbarSize
.
height
"
Scroll
Fullpage
Clipboard
:
Image
height
matches
page
size
minus
scrollbar
size
"
)
;
}
function
executeScreenshotClipboardCommand
(
hud
command
)
{
return
executeAndWaitForMessage
(
hud
command
"
Screenshot
copied
to
clipboard
.
"
)
;
}
async
function
createScrollbarOverflow
(
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
content
.
document
.
body
.
classList
.
add
(
"
overflow
"
)
;
}
)
;
}
async
function
getScrollbarSize
(
)
{
const
scrollbarSize
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
const
winUtils
=
content
.
windowUtils
;
const
scrollbarHeight
=
{
}
;
const
scrollbarWidth
=
{
}
;
winUtils
.
getScrollbarSize
(
true
scrollbarWidth
scrollbarHeight
)
;
return
{
width
:
scrollbarWidth
.
value
height
:
scrollbarHeight
.
value
}
;
}
)
;
info
(
Scrollbar
size
:
{
scrollbarSize
.
width
}
x
{
scrollbarSize
.
height
}
)
;
return
scrollbarSize
;
}
async
function
getContentSize
(
)
{
const
contentSize
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
return
{
scrollMaxY
:
content
.
scrollMaxY
scrollMaxX
:
content
.
scrollMaxX
scrollMinY
:
content
.
scrollMinY
scrollMinX
:
content
.
scrollMinX
innerWidth
:
content
.
innerWidth
innerHeight
:
content
.
innerHeight
}
;
}
)
;
info
(
content
size
:
{
contentSize
.
innerWidth
}
x
{
contentSize
.
innerHeight
}
)
;
return
contentSize
;
}
async
function
getImageSizeFromClipboard
(
)
{
const
clipid
=
Ci
.
nsIClipboard
;
const
clip
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
]
.
getService
(
clipid
)
;
const
trans
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
const
flavor
=
"
image
/
png
"
;
trans
.
init
(
null
)
;
trans
.
addDataFlavor
(
flavor
)
;
clip
.
getData
(
trans
clipid
.
kGlobalClipboard
)
;
const
data
=
{
}
;
trans
.
getTransferData
(
flavor
data
)
;
ok
(
data
.
value
"
screenshot
exists
"
)
;
let
image
=
data
.
value
;
if
(
image
instanceof
Ci
.
imgIContainer
)
{
image
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
encodeImage
(
image
flavor
)
;
}
if
(
!
(
image
instanceof
Ci
.
nsIInputStream
)
)
{
throw
new
Error
(
"
Unable
to
read
image
data
"
)
;
}
const
binaryStream
=
Cc
[
"
mozilla
.
org
/
binaryinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIBinaryInputStream
)
;
binaryStream
.
setInputStream
(
image
)
;
const
available
=
binaryStream
.
available
(
)
;
const
buffer
=
new
ArrayBuffer
(
available
)
;
is
(
binaryStream
.
readArrayBuffer
(
available
buffer
)
available
"
Read
expected
amount
of
data
"
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
buffer
]
async
function
(
_buffer
)
{
const
img
=
content
.
document
.
createElement
(
"
img
"
)
;
const
loaded
=
new
Promise
(
r
=
>
{
img
.
addEventListener
(
"
load
"
r
{
once
:
true
}
)
;
}
)
;
const
url
=
content
.
URL
.
createObjectURL
(
new
Blob
(
[
_buffer
]
{
type
:
"
image
/
png
"
}
)
)
;
img
.
src
=
url
;
content
.
document
.
documentElement
.
appendChild
(
img
)
;
info
(
"
Waiting
for
the
clipboard
image
to
load
in
the
content
page
"
)
;
await
loaded
;
img
.
remove
(
)
;
content
.
URL
.
revokeObjectURL
(
url
)
;
return
{
width
:
img
.
width
height
:
img
.
height
}
;
}
)
;
}
