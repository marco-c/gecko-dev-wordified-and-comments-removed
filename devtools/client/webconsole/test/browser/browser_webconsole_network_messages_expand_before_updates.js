"
use
strict
"
;
const
TEST_FILE
=
"
test
-
network
-
request
.
html
"
;
const
TEST_PATH
=
"
https
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
webconsole
/
test
/
browser
/
"
;
const
TEST_URI
=
TEST_PATH
+
TEST_FILE
;
requestLongerTimeout
(
4
)
;
pushPref
(
"
devtools
.
webconsole
.
filter
.
net
"
false
)
;
pushPref
(
"
devtools
.
webconsole
.
filter
.
netxhr
"
true
)
;
waitFor
.
overrideIntervalForTestFile
=
50
;
const
tabs
=
[
{
id
:
"
headers
"
testEmpty
:
testEmptyHeaders
testContent
:
testHeaders
}
{
id
:
"
cookies
"
testEmpty
:
testEmptyCookies
testContent
:
testCookies
}
{
id
:
"
request
"
testEmpty
:
testEmptyRequest
testContent
:
testRequest
}
{
id
:
"
response
"
testEmpty
:
testEmptyResponse
testContent
:
testResponse
}
{
id
:
"
timings
"
testEmpty
:
testEmptyTimings
testContent
:
testTimings
}
{
id
:
"
stack
-
trace
"
testEmpty
:
testEmptyStackTrace
testContent
:
testStackTrace
}
{
id
:
"
security
"
testEmpty
:
testEmptySecurity
testContent
:
testSecurity
}
]
;
add_task
(
async
function
task
(
)
{
const
hud
=
await
openNewTabAndConsole
(
TEST_URI
)
;
for
(
const
tab
of
tabs
)
{
info
(
Test
"
{
tab
.
id
}
"
panel
)
;
await
openRequestBeforeUpdates
(
hud
tab
)
;
}
}
)
;
async
function
openRequestBeforeUpdates
(
hud
tab
)
{
const
toolbox
=
hud
.
toolbox
;
await
clearOutput
(
hud
)
;
const
xhrUrl
=
TEST_PATH
+
"
sjs_slow
-
response
-
test
-
server
.
sjs
"
;
const
onMessage
=
waitForMessageByType
(
hud
xhrUrl
"
.
network
"
)
;
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
content
.
wrappedJSObject
.
testXhrPostSlowResponse
(
)
;
}
)
;
info
(
Wait
for
{
xhrUrl
}
message
)
;
const
{
node
:
messageNode
}
=
await
onMessage
;
ok
(
messageNode
"
Network
message
found
.
"
)
;
const
state
=
hud
.
ui
.
wrapper
.
getStore
(
)
.
getState
(
)
;
state
.
ui
.
networkMessageActiveTabId
=
tab
.
id
;
await
expandXhrMessage
(
messageNode
)
;
if
(
tab
.
id
!
=
"
security
"
)
{
const
currentTab
=
messageNode
.
querySelector
(
#
{
tab
.
id
}
-
tab
)
;
is
(
currentTab
.
getAttribute
(
"
aria
-
selected
"
)
"
true
"
"
The
correct
tab
is
selected
"
)
;
if
(
tab
.
testEmpty
)
{
info
(
"
Test
that
the
tab
is
empty
"
)
;
tab
.
testEmpty
(
messageNode
)
;
}
}
info
(
"
Test
content
of
the
default
tab
"
)
;
await
tab
.
testContent
(
messageNode
)
;
info
(
"
Test
all
tabs
in
the
network
log
"
)
;
await
testNetworkMessage
(
toolbox
messageNode
)
;
}
async
function
testNetworkMessage
(
toolbox
messageNode
)
{
await
testStatusInfo
(
messageNode
)
;
await
testHeaders
(
messageNode
)
;
await
testCookies
(
messageNode
)
;
await
testRequest
(
messageNode
)
;
await
testResponse
(
messageNode
)
;
await
testTimings
(
messageNode
)
;
await
testStackTrace
(
messageNode
)
;
await
testSecurity
(
messageNode
)
;
await
waitForLazyRequests
(
toolbox
)
;
}
async
function
testStatusInfo
(
messageNode
)
{
const
statusInfo
=
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
.
status
-
info
"
)
)
;
ok
(
statusInfo
"
Status
info
is
not
empty
"
)
;
}
function
testEmptyHeaders
(
messageNode
)
{
const
emptyNotice
=
messageNode
.
querySelector
(
"
#
headers
-
panel
.
empty
-
notice
"
)
;
ok
(
emptyNotice
"
Headers
tab
is
empty
"
)
;
}
async
function
testHeaders
(
messageNode
)
{
const
headersTab
=
messageNode
.
querySelector
(
"
#
headers
-
tab
"
)
;
ok
(
headersTab
"
Headers
tab
is
available
"
)
;
headersTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
headers
-
panel
.
headers
-
overview
"
)
"
Wait
for
.
header
-
overview
to
be
rendered
"
)
;
}
function
testEmptyCookies
(
messageNode
)
{
const
emptyNotice
=
messageNode
.
querySelector
(
"
#
cookies
-
panel
.
empty
-
notice
"
)
;
ok
(
emptyNotice
"
Cookies
tab
is
empty
"
)
;
}
async
function
testCookies
(
messageNode
)
{
const
cookiesTab
=
messageNode
.
querySelector
(
"
#
cookies
-
tab
"
)
;
ok
(
cookiesTab
"
Cookies
tab
is
available
"
)
;
cookiesTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
cookies
-
panel
.
treeValueCell
"
)
"
Wait
for
.
treeValueCell
to
be
rendered
"
)
;
}
function
testEmptyRequest
(
messageNode
)
{
const
emptyNotice
=
messageNode
.
querySelector
(
"
#
request
-
panel
.
empty
-
notice
"
)
;
ok
(
emptyNotice
"
Request
tab
is
empty
"
)
;
}
async
function
testRequest
(
messageNode
)
{
const
requestTab
=
messageNode
.
querySelector
(
"
#
request
-
tab
"
)
;
ok
(
requestTab
"
Request
tab
is
available
"
)
;
requestTab
.
click
(
)
;
const
requestPanel
=
messageNode
.
querySelector
(
"
#
request
-
panel
"
)
;
await
waitForSourceEditor
(
requestPanel
)
;
const
requestContent
=
requestPanel
.
querySelector
(
"
.
panel
-
container
.
cm
-
content
"
)
;
ok
(
requestContent
"
Request
content
is
available
"
)
;
ok
(
requestContent
.
textContent
.
includes
(
"
Hello
world
!
"
)
"
Request
POST
body
is
correct
"
)
;
}
function
testEmptyResponse
(
messageNode
)
{
const
panel
=
messageNode
.
querySelector
(
"
#
response
-
panel
.
tab
-
panel
"
)
;
is
(
panel
.
textContent
"
No
response
data
available
for
this
request
"
"
Cookies
tab
is
empty
"
)
;
}
async
function
testResponse
(
messageNode
)
{
const
responseTab
=
messageNode
.
querySelector
(
"
#
response
-
tab
"
)
;
ok
(
responseTab
"
Response
tab
is
available
"
)
;
responseTab
.
click
(
)
;
const
responsePanel
=
messageNode
.
querySelector
(
"
#
response
-
panel
"
)
;
const
responsePayloadHeader
=
await
waitFor
(
(
)
=
>
responsePanel
.
querySelector
(
"
.
data
-
header
"
)
)
;
if
(
responsePayloadHeader
.
getAttribute
(
"
aria
-
expanded
"
)
=
=
=
"
false
"
)
{
responsePayloadHeader
.
click
(
)
;
}
await
waitForSourceEditor
(
responsePanel
)
;
const
responseContent
=
messageNode
.
querySelector
(
"
#
response
-
panel
.
editor
-
row
-
container
.
cm
-
content
"
)
;
ok
(
responseContent
"
Response
content
is
available
"
)
;
ok
(
responseContent
.
textContent
"
Response
text
is
available
"
)
;
}
function
testEmptyTimings
(
messageNode
)
{
const
panel
=
messageNode
.
querySelector
(
"
#
timings
-
panel
.
tab
-
panel
"
)
;
is
(
panel
.
textContent
"
No
timings
for
this
request
"
"
Timings
tab
is
empty
"
)
;
}
async
function
testTimings
(
messageNode
)
{
const
timingsTab
=
messageNode
.
querySelector
(
"
#
timings
-
tab
"
)
;
ok
(
timingsTab
"
Timings
tab
is
available
"
)
;
timingsTab
.
click
(
)
;
const
timingsContent
=
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
timings
-
panel
.
timings
-
container
.
timings
-
label
"
"
Wait
for
.
timings
-
label
to
be
rendered
"
)
)
;
ok
(
timingsContent
"
Timings
content
is
available
"
)
;
ok
(
timingsContent
.
textContent
"
Timings
text
is
available
"
)
;
}
function
testEmptyStackTrace
(
messageNode
)
{
const
panel
=
messageNode
.
querySelector
(
"
#
stack
-
trace
-
panel
.
tab
-
panel
"
)
;
is
(
panel
.
textContent
"
"
"
StackTrace
tab
is
empty
"
)
;
}
async
function
testStackTrace
(
messageNode
)
{
const
stackTraceTab
=
messageNode
.
querySelector
(
"
#
stack
-
trace
-
tab
"
)
;
ok
(
stackTraceTab
"
StackTrace
tab
is
available
"
)
;
stackTraceTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
stack
-
trace
-
panel
.
frame
-
link
"
)
"
Wait
for
.
frame
-
link
to
be
rendered
"
)
;
}
function
testEmptySecurity
(
messageNode
)
{
const
panel
=
messageNode
.
querySelector
(
"
#
security
-
panel
.
tab
-
panel
"
)
;
is
(
panel
.
textContent
"
"
"
Security
tab
is
empty
"
)
;
}
async
function
testSecurity
(
messageNode
)
{
const
securityTab
=
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
security
-
tab
"
)
)
;
ok
(
securityTab
"
Security
tab
is
available
"
)
;
securityTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
security
-
panel
.
treeTable
.
treeRow
"
)
"
Wait
for
#
security
-
panel
.
treeTable
.
treeRow
to
be
rendered
"
)
;
}
function
expandXhrMessage
(
node
)
{
info
(
"
Click
on
XHR
message
and
wait
for
the
network
detail
panel
to
be
displayed
"
)
;
node
.
querySelector
(
"
.
url
"
)
.
click
(
)
;
return
waitFor
(
(
)
=
>
node
.
querySelector
(
"
.
network
-
info
"
)
"
Wait
for
.
network
-
info
to
be
rendered
"
)
;
}
