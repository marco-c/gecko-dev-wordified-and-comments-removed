"
use
strict
"
;
const
TEST_FILE
=
"
test
-
network
-
request
.
html
"
;
const
TEST_PATH
=
"
https
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
webconsole
/
test
/
browser
/
"
;
const
TEST_URI
=
TEST_PATH
+
TEST_FILE
;
requestLongerTimeout
(
2
)
;
registerCleanupFunction
(
async
function
(
)
{
await
new
Promise
(
resolve
=
>
{
Services
.
clearData
.
deleteData
(
Ci
.
nsIClearDataService
.
CLEAR_ALL
value
=
>
resolve
(
)
)
;
}
)
;
}
)
;
pushPref
(
"
devtools
.
webconsole
.
filter
.
net
"
false
)
;
pushPref
(
"
devtools
.
webconsole
.
filter
.
netxhr
"
true
)
;
add_task
(
async
function
task
(
)
{
const
hud
=
await
openNewTabAndConsole
(
TEST_URI
)
;
const
currentTab
=
gBrowser
.
selectedTab
;
const
target
=
await
TargetFactory
.
forTab
(
currentTab
)
;
const
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
const
xhrUrl
=
TEST_PATH
+
"
sjs_slow
-
response
-
test
-
server
.
sjs
"
;
const
onMessage
=
waitForMessage
(
hud
xhrUrl
)
;
const
onRequestUpdates
=
waitForRequestUpdates
(
hud
)
;
const
onPayloadReady
=
waitForPayloadReady
(
hud
)
;
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
content
.
wrappedJSObject
.
testXhrPostSlowResponse
(
)
;
}
)
;
const
{
node
:
messageNode
}
=
await
onMessage
;
ok
(
messageNode
"
Network
message
found
.
"
)
;
await
onRequestUpdates
;
await
expandXhrMessage
(
messageNode
)
;
const
toggleButtonNode
=
messageNode
.
querySelector
(
"
.
sidebar
-
toggle
"
)
;
ok
(
!
toggleButtonNode
"
Sidebar
toggle
button
shouldn
'
t
be
shown
"
)
;
await
onPayloadReady
;
await
testNetworkMessage
(
toolbox
messageNode
)
;
}
)
;
async
function
testNetworkMessage
(
toolbox
messageNode
)
{
await
testStatusInfo
(
messageNode
)
;
await
testHeaders
(
messageNode
)
;
await
testCookies
(
messageNode
)
;
await
testRequest
(
messageNode
)
;
await
testResponse
(
messageNode
)
;
await
testTimings
(
messageNode
)
;
await
testStackTrace
(
messageNode
)
;
await
testSecurity
(
messageNode
)
;
await
waitForLazyRequests
(
toolbox
)
;
}
function
testStatusInfo
(
messageNode
)
{
const
statusInfo
=
messageNode
.
querySelector
(
"
.
status
-
info
"
)
;
ok
(
statusInfo
"
Status
info
is
not
empty
"
)
;
}
async
function
testHeaders
(
messageNode
)
{
const
headersTab
=
messageNode
.
querySelector
(
"
#
headers
-
tab
"
)
;
ok
(
headersTab
"
Headers
tab
is
available
"
)
;
headersTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
headers
-
panel
.
headers
-
overview
"
)
"
Wait
for
.
header
-
overview
to
be
rendered
"
)
;
}
async
function
testCookies
(
messageNode
)
{
const
cookiesTab
=
messageNode
.
querySelector
(
"
#
cookies
-
tab
"
)
;
ok
(
cookiesTab
"
Cookies
tab
is
available
"
)
;
cookiesTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
cookies
-
panel
.
treeValueCell
"
)
"
Wait
for
.
treeValueCell
to
be
rendered
"
)
;
}
async
function
testRequest
(
messageNode
)
{
const
requestTab
=
messageNode
.
querySelector
(
"
#
request
-
tab
"
)
;
ok
(
requestTab
"
Request
tab
is
available
"
)
;
requestTab
.
click
(
)
;
const
requestPanel
=
messageNode
.
querySelector
(
"
#
request
-
panel
"
)
;
await
waitForSourceEditor
(
requestPanel
)
;
const
requestContent
=
requestPanel
.
querySelector
(
"
.
panel
-
container
.
CodeMirror
"
)
;
ok
(
requestContent
"
Request
content
is
available
"
)
;
ok
(
requestContent
.
textContent
.
includes
(
"
Hello
world
!
"
)
"
Request
POST
body
is
correct
"
)
;
}
async
function
testResponse
(
messageNode
)
{
const
responseTab
=
messageNode
.
querySelector
(
"
#
response
-
tab
"
)
;
ok
(
responseTab
"
Response
tab
is
available
"
)
;
responseTab
.
click
(
)
;
const
responsePanel
=
messageNode
.
querySelector
(
"
#
response
-
panel
"
)
;
await
waitForSourceEditor
(
responsePanel
)
;
const
responseContent
=
messageNode
.
querySelector
(
"
#
response
-
panel
.
editor
-
row
-
container
.
CodeMirror
"
)
;
ok
(
responseContent
"
Response
content
is
available
"
)
;
ok
(
responseContent
.
textContent
"
Response
text
is
available
"
)
;
}
async
function
testTimings
(
messageNode
)
{
const
timingsTab
=
messageNode
.
querySelector
(
"
#
timings
-
tab
"
)
;
ok
(
timingsTab
"
Timings
tab
is
available
"
)
;
timingsTab
.
click
(
)
;
const
timingsContent
=
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
timings
-
panel
.
timings
-
container
.
timings
-
label
"
"
Wait
for
.
timings
-
label
to
be
rendered
"
)
)
;
ok
(
timingsContent
"
Timings
content
is
available
"
)
;
ok
(
timingsContent
.
textContent
"
Timings
text
is
available
"
)
;
}
async
function
testStackTrace
(
messageNode
)
{
const
stackTraceTab
=
messageNode
.
querySelector
(
"
#
stack
-
trace
-
tab
"
)
;
ok
(
stackTraceTab
"
StackTrace
tab
is
available
"
)
;
stackTraceTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
stack
-
trace
-
panel
.
frame
-
link
"
)
"
Wait
for
.
frame
-
link
to
be
rendered
"
)
;
}
async
function
testSecurity
(
messageNode
)
{
const
securityTab
=
messageNode
.
querySelector
(
"
#
security
-
tab
"
)
;
ok
(
securityTab
"
Security
tab
is
available
"
)
;
securityTab
.
click
(
)
;
await
waitFor
(
(
)
=
>
messageNode
.
querySelector
(
"
#
security
-
panel
.
treeTable
.
treeRow
"
)
"
Wait
for
#
security
-
panel
.
treeTable
.
treeRow
to
be
rendered
"
)
;
}
async
function
waitForPayloadReady
(
hud
)
{
return
hud
.
ui
.
once
(
"
network
-
request
-
payload
-
ready
"
)
;
}
async
function
waitForSourceEditor
(
panel
)
{
return
waitUntil
(
(
)
=
>
{
return
!
!
panel
.
querySelector
(
"
.
CodeMirror
"
)
;
}
)
;
}
async
function
waitForRequestUpdates
(
hud
)
{
return
hud
.
ui
.
once
(
"
network
-
messages
-
updated
"
)
;
}
function
expandXhrMessage
(
node
)
{
info
(
"
Click
on
XHR
message
and
wait
for
the
network
detail
panel
to
be
displayed
"
)
;
node
.
querySelector
(
"
.
url
"
)
.
click
(
)
;
return
waitFor
(
(
)
=
>
node
.
querySelector
(
"
.
network
-
info
"
)
"
Wait
for
.
network
-
info
to
be
rendered
"
)
;
}
