"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
redux
-
head
.
js
"
this
)
;
const
{
ORDERED_PROPS
PREF_KEYS
}
=
require
(
"
devtools
/
client
/
accessibility
/
constants
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
accessibility
.
enabled
"
true
)
;
const
SIMULATION_MENU_BUTTON_ID
=
"
#
simulation
-
menu
-
button
"
;
const
TREE_FILTERS_MENU_ID
=
"
accessibility
-
tree
-
filters
-
menu
"
;
const
PREFS_MENU_ID
=
"
accessibility
-
tree
-
filters
-
prefs
-
menu
"
;
const
MENU_INDEXES
=
{
[
TREE_FILTERS_MENU_ID
]
:
0
[
PREFS_MENU_ID
]
:
1
}
;
async
function
initA11y
(
)
{
if
(
Services
.
appinfo
.
accessibilityEnabled
)
{
return
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
}
const
initPromise
=
new
Promise
(
resolve
=
>
{
const
observe
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
}
)
;
const
a11yService
=
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
await
initPromise
;
return
a11yService
;
}
function
shutdownA11y
(
)
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
Promise
.
resolve
(
)
;
}
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceShrinkingGC
(
)
;
return
new
Promise
(
resolve
=
>
{
const
observe
=
(
subject
topic
data
)
=
>
{
if
(
data
=
=
=
"
0
"
)
{
Services
.
obs
.
removeObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
}
)
;
}
registerCleanupFunction
(
async
(
)
=
>
{
info
(
"
Cleaning
up
.
.
.
"
)
;
await
shutdownA11y
(
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
accessibility
.
enabled
"
)
;
}
)
;
const
EXPANDABLE_PROPS
=
[
"
actions
"
"
states
"
"
attributes
"
]
;
async
function
addTestTab
(
url
)
{
info
(
"
Adding
a
new
test
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
const
tab
=
await
addTab
(
url
)
;
const
panel
=
await
initAccessibilityPanel
(
tab
)
;
const
win
=
panel
.
panelWin
;
const
doc
=
win
.
document
;
const
store
=
win
.
view
.
store
;
const
enableButton
=
doc
.
getElementById
(
"
accessibility
-
enable
-
button
"
)
;
if
(
enableButton
)
{
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
enableButton
win
)
;
}
await
waitUntilState
(
store
state
=
>
state
.
accessibles
.
size
=
=
=
1
&
&
state
.
details
.
accessible
&
&
state
.
details
.
accessible
.
role
=
=
=
"
document
"
)
;
await
panel
.
_toolbox
.
loadTool
(
"
inspector
"
)
;
return
{
tab
browser
:
tab
.
linkedBrowser
panel
win
toolbox
:
panel
.
_toolbox
doc
store
}
;
}
async
function
disableAccessibilityInspector
(
env
)
{
const
{
doc
win
panel
}
=
env
;
const
shutdown
=
panel
.
front
.
once
(
"
shutdown
"
)
;
const
disableButton
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
doc
.
getElementById
(
"
accessibility
-
disable
-
button
"
)
"
Wait
for
the
disable
button
.
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
disableButton
win
)
;
await
shutdown
;
}
async
function
initAccessibilityPanel
(
tab
=
gBrowser
.
selectedTab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
accessibility
"
)
;
return
toolbox
.
getCurrentPanel
(
)
;
}
function
compareBadges
(
badges
expected
=
[
]
)
{
const
badgeEls
=
badges
?
[
.
.
.
badges
.
querySelectorAll
(
"
.
badge
"
)
]
:
[
]
;
return
(
badgeEls
.
length
=
=
=
expected
.
length
&
&
badgeEls
.
every
(
(
badge
i
)
=
>
badge
.
textContent
=
=
=
expected
[
i
]
)
)
;
}
function
closestScrolledParent
(
node
)
{
if
(
node
=
=
null
)
{
return
null
;
}
if
(
node
.
scrollHeight
>
node
.
clientHeight
)
{
return
node
;
}
return
closestScrolledParent
(
node
.
parentNode
)
;
}
function
isVisible
(
element
)
{
const
{
top
bottom
}
=
element
.
getBoundingClientRect
(
)
;
const
scrolledParent
=
closestScrolledParent
(
element
.
parentNode
)
;
const
scrolledParentRect
=
scrolledParent
?
scrolledParent
.
getBoundingClientRect
(
)
:
null
;
return
(
!
scrolledParent
|
|
(
top
>
=
scrolledParentRect
.
top
&
&
bottom
<
=
scrolledParentRect
.
bottom
)
)
;
}
function
checkSelected
(
row
expected
)
{
if
(
!
expected
)
{
return
true
;
}
if
(
row
.
classList
.
contains
(
"
selected
"
)
!
=
=
expected
)
{
return
false
;
}
return
isVisible
(
row
)
;
}
function
checkLevel
(
row
expected
)
{
if
(
!
expected
)
{
return
true
;
}
return
parseInt
(
row
.
getAttribute
(
"
aria
-
level
"
)
10
)
=
=
=
expected
;
}
async
function
checkTreeState
(
doc
expected
)
{
info
(
"
Checking
tree
state
.
"
)
;
const
hasExpectedStructure
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeRow
"
)
]
.
every
(
(
row
i
)
=
>
{
const
{
role
name
badges
selected
level
}
=
expected
[
i
]
;
return
(
row
.
querySelector
(
"
.
treeLabelCell
"
)
.
textContent
=
=
=
role
&
&
row
.
querySelector
(
"
.
treeValueCell
"
)
.
textContent
=
=
=
name
&
&
compareBadges
(
row
.
querySelector
(
"
.
badges
"
)
badges
)
&
&
checkSelected
(
row
selected
)
&
&
checkLevel
(
row
level
)
)
;
}
)
"
Wait
for
the
right
tree
update
.
"
)
;
ok
(
hasExpectedStructure
"
Tree
structure
is
correct
.
"
)
;
}
function
relationsMatch
(
relations
expected
)
{
for
(
const
relationType
in
expected
)
{
let
expTargets
=
expected
[
relationType
]
;
expTargets
=
Array
.
isArray
(
expTargets
)
?
expTargets
:
[
expTargets
]
;
let
targets
=
relations
[
relationType
]
;
targets
=
Array
.
isArray
(
targets
)
?
targets
:
[
targets
]
;
for
(
const
index
in
expTargets
)
{
if
(
expTargets
[
index
]
.
name
!
=
=
targets
[
index
]
.
name
|
|
expTargets
[
index
]
.
role
!
=
=
targets
[
index
]
.
role
)
{
return
false
;
}
}
}
return
true
;
}
function
parseNumReplacer
(
_
value
)
{
if
(
typeof
value
=
=
=
"
number
"
)
{
return
value
.
toFixed
(
2
)
;
}
return
value
;
}
async
function
checkAuditState
(
store
expectedState
)
{
info
(
"
Checking
audit
state
.
"
)
;
await
waitUntilState
(
store
(
{
details
}
)
=
>
{
const
{
audit
}
=
details
;
for
(
const
key
in
expectedState
)
{
const
expected
=
expectedState
[
key
]
;
if
(
expected
&
&
typeof
expected
=
=
=
"
object
"
)
{
if
(
JSON
.
stringify
(
audit
[
key
]
parseNumReplacer
)
!
=
=
JSON
.
stringify
(
expected
parseNumReplacer
)
)
{
return
false
;
}
}
else
if
(
audit
&
&
audit
[
key
]
!
=
=
expected
)
{
return
false
;
}
}
ok
(
true
"
Audit
state
is
correct
.
"
)
;
return
true
;
}
)
;
}
async
function
checkSidebarState
(
store
expectedState
)
{
info
(
"
Checking
sidebar
state
.
"
)
;
await
waitUntilState
(
store
(
{
details
}
)
=
>
{
for
(
const
key
of
ORDERED_PROPS
)
{
const
expected
=
expectedState
[
key
]
;
if
(
expected
=
=
=
undefined
)
{
continue
;
}
if
(
key
=
=
=
"
relations
"
)
{
if
(
!
relationsMatch
(
details
.
relations
expected
)
)
{
return
false
;
}
}
else
if
(
EXPANDABLE_PROPS
.
includes
(
key
)
)
{
if
(
JSON
.
stringify
(
details
.
accessible
[
key
]
)
!
=
=
JSON
.
stringify
(
expected
)
)
{
return
false
;
}
}
else
if
(
details
.
accessible
&
&
details
.
accessible
[
key
]
!
=
=
expected
)
{
return
false
;
}
}
ok
(
true
"
Sidebar
state
is
correct
.
"
)
;
return
true
;
}
)
;
}
async
function
checkToolbarPrefsState
(
doc
toolbarPrefValues
store
)
{
info
(
"
Checking
toolbar
prefs
state
.
"
)
;
const
[
hasExpectedStructure
]
=
await
Promise
.
all
(
[
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
Object
.
keys
(
toolbarPrefValues
)
.
every
(
name
=
>
Services
.
prefs
.
getBoolPref
(
PREF_KEYS
[
name
]
false
)
=
=
=
toolbarPrefValues
[
name
]
)
;
}
"
Wait
for
the
right
prefs
state
.
"
)
waitUntilState
(
store
(
{
ui
}
)
=
>
{
for
(
const
name
in
toolbarPrefValues
)
{
if
(
ui
[
name
]
!
=
=
toolbarPrefValues
[
name
]
)
{
return
false
;
}
}
ok
(
true
"
UI
pref
state
is
correct
.
"
)
;
return
true
;
}
)
]
)
;
ok
(
hasExpectedStructure
"
Prefs
state
is
correct
.
"
)
;
}
async
function
checkToolbarState
(
doc
activeToolbarFilters
)
{
info
(
"
Checking
toolbar
state
.
"
)
;
const
hasExpectedStructure
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
[
.
.
.
doc
.
querySelectorAll
(
"
#
accessibility
-
tree
-
filters
-
menu
.
command
"
)
]
.
every
(
(
filter
i
)
=
>
(
activeToolbarFilters
[
i
]
?
"
true
"
:
null
)
=
=
=
filter
.
getAttribute
(
"
aria
-
checked
"
)
)
"
Wait
for
the
right
toolbar
state
.
"
)
;
ok
(
hasExpectedStructure
"
Toolbar
state
is
correct
.
"
)
;
}
async
function
checkSimulationState
(
doc
expected
)
{
const
{
buttonActive
checkedOptionIndices
}
=
expected
;
const
simulationMenuOptions
=
doc
.
querySelector
(
SIMULATION_MENU_BUTTON_ID
+
"
-
menu
"
)
.
querySelectorAll
(
"
.
menuitem
"
)
;
is
(
doc
.
querySelector
(
SIMULATION_MENU_BUTTON_ID
)
.
className
devtools
-
button
toolbar
-
menu
-
button
simulation
{
buttonActive
?
"
active
"
:
"
"
}
Simulation
menu
button
contains
{
buttonActive
?
"
active
"
:
"
base
"
}
class
.
)
;
if
(
checkedOptionIndices
)
{
simulationMenuOptions
.
forEach
(
(
menuListItem
index
)
=
>
{
const
isChecked
=
checkedOptionIndices
.
includes
(
index
)
;
const
button
=
menuListItem
.
firstChild
;
is
(
button
.
getAttribute
(
"
aria
-
checked
"
)
isChecked
?
"
true
"
:
null
Simulation
option
{
index
}
is
{
isChecked
?
"
"
:
"
not
"
}
selected
.
)
;
}
)
;
}
}
async
function
focusAccessibleProperties
(
doc
)
{
const
tree
=
doc
.
querySelector
(
"
.
tree
"
)
;
if
(
doc
.
activeElement
!
=
=
tree
)
{
tree
.
focus
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
tree
.
querySelector
(
"
.
node
.
focused
"
)
"
Tree
selected
.
"
)
;
}
}
async
function
selectProperty
(
doc
id
)
{
const
win
=
doc
.
defaultView
;
let
selected
=
false
;
let
node
;
await
focusAccessibleProperties
(
doc
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
node
=
doc
.
getElementById
(
{
id
}
)
;
if
(
node
)
{
if
(
selected
)
{
return
node
.
firstChild
.
classList
.
contains
(
"
focused
"
)
;
}
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
node
win
)
;
selected
=
true
;
}
else
{
const
tree
=
doc
.
querySelector
(
"
.
tree
"
)
;
tree
.
scrollTop
=
parseFloat
(
win
.
getComputedStyle
(
tree
)
.
height
)
;
}
return
false
;
}
)
;
return
node
;
}
function
selectRow
(
doc
rowNumber
)
{
info
(
Selecting
row
{
rowNumber
}
.
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
doc
.
querySelectorAll
(
"
.
treeRow
"
)
[
rowNumber
]
doc
.
defaultView
)
;
}
async
function
toggleRow
(
doc
rowNumber
)
{
const
win
=
doc
.
defaultView
;
const
row
=
doc
.
querySelectorAll
(
"
.
treeRow
"
)
[
rowNumber
]
;
const
twisty
=
row
.
querySelector
(
"
.
theme
-
twisty
"
)
;
const
expected
=
!
twisty
.
classList
.
contains
(
"
open
"
)
;
info
(
{
expected
?
"
Expanding
"
:
"
Collapsing
"
}
row
{
rowNumber
}
.
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
twisty
win
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
twisty
.
classList
.
contains
(
"
devtools
-
throbber
"
)
&
&
expected
=
=
=
twisty
.
classList
.
contains
(
"
open
"
)
"
Twisty
updated
.
"
)
;
}
async
function
toggleMenuItem
(
doc
toolboxDoc
menuId
menuItemIndex
)
{
const
toolboxWin
=
toolboxDoc
.
defaultView
;
const
panelWin
=
doc
.
defaultView
;
const
menuButton
=
doc
.
querySelectorAll
(
"
.
toolbar
-
menu
-
button
"
)
[
MENU_INDEXES
[
menuId
]
]
;
ok
(
menuButton
"
Expected
menu
button
"
)
;
const
menuEl
=
toolboxDoc
.
getElementById
(
menuId
)
;
const
menuItem
=
menuEl
.
querySelectorAll
(
"
.
command
"
)
[
menuItemIndex
]
;
ok
(
menuItem
"
Expected
menu
item
"
)
;
const
expected
=
menuItem
.
getAttribute
(
"
aria
-
checked
"
)
=
=
=
"
true
"
?
null
:
"
true
"
;
EventUtils
.
synthesizeMouseAtCenter
(
menuButton
{
}
panelWin
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
!
menuItem
.
offsetParent
"
Menu
item
is
visible
.
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItem
{
}
toolboxWin
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
expected
=
=
=
menuItem
.
getAttribute
(
"
aria
-
checked
"
)
"
Menu
item
updated
.
"
)
;
}
async
function
openSimulationMenu
(
doc
)
{
doc
.
querySelector
(
SIMULATION_MENU_BUTTON_ID
)
.
click
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
doc
.
querySelector
(
SIMULATION_MENU_BUTTON_ID
+
"
-
menu
"
)
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
async
function
toggleSimulationOption
(
doc
optionIndex
)
{
const
simulationMenu
=
doc
.
querySelector
(
SIMULATION_MENU_BUTTON_ID
+
"
-
menu
"
)
;
simulationMenu
.
querySelectorAll
(
"
.
menuitem
"
)
[
optionIndex
]
.
firstChild
.
click
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
simulationMenu
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
async
function
findAccessibleFor
(
{
toolbox
:
{
target
}
panel
:
{
walker
:
accessibilityWalker
}
}
selector
)
{
const
domWalker
=
(
await
target
.
getFront
(
"
inspector
"
)
)
.
walker
;
const
node
=
await
domWalker
.
querySelector
(
domWalker
.
rootNode
selector
)
;
return
accessibilityWalker
.
getAccessibleFor
(
node
)
;
}
async
function
selectAccessibleForNode
(
env
selector
)
{
const
{
panel
win
}
=
env
;
const
front
=
await
findAccessibleFor
(
env
selector
)
;
const
{
EVENTS
}
=
win
;
const
onSelected
=
win
.
once
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_SELECTED
)
;
panel
.
selectAccessible
(
front
)
;
await
onSelected
;
}
async
function
runA11yPanelTests
(
tests
env
)
{
for
(
const
{
desc
setup
expected
}
of
tests
)
{
info
(
desc
)
;
if
(
setup
)
{
await
setup
(
env
)
;
}
const
{
tree
sidebar
audit
toolbarPrefValues
activeToolbarFilters
simulation
}
=
expected
;
if
(
tree
)
{
await
checkTreeState
(
env
.
doc
tree
)
;
}
if
(
sidebar
)
{
await
checkSidebarState
(
env
.
store
sidebar
)
;
}
if
(
activeToolbarFilters
)
{
await
checkToolbarState
(
env
.
doc
activeToolbarFilters
)
;
}
if
(
toolbarPrefValues
)
{
await
checkToolbarPrefsState
(
env
.
doc
toolbarPrefValues
env
.
store
)
;
}
if
(
typeof
audit
!
=
=
"
undefined
"
)
{
await
checkAuditState
(
env
.
store
audit
)
;
}
if
(
simulation
)
{
await
checkSimulationState
(
env
.
doc
simulation
)
;
}
}
}
function
buildURL
(
uri
)
{
return
data
:
text
/
html
;
charset
=
UTF
-
8
{
encodeURIComponent
(
uri
)
}
;
}
function
addA11yPanelTestsTask
(
tests
uri
msg
)
{
addA11YPanelTask
(
msg
uri
env
=
>
runA11yPanelTests
(
tests
env
)
)
;
}
function
addA11YPanelTask
(
msg
uri
task
)
{
add_task
(
async
function
a11YPanelTask
(
)
{
info
(
msg
)
;
const
env
=
await
addTestTab
(
buildURL
(
uri
)
)
;
await
task
(
env
)
;
await
disableAccessibilityInspector
(
env
)
;
}
)
;
}
function
reload
(
target
waitForTargetEvent
=
"
navigate
"
)
{
executeSoon
(
(
)
=
>
target
.
reload
(
)
)
;
return
once
(
target
waitForTargetEvent
)
;
}
function
navigate
(
target
url
waitForTargetEvent
=
"
navigate
"
)
{
executeSoon
(
(
)
=
>
target
.
navigateTo
(
{
url
}
)
)
;
return
once
(
target
waitForTargetEvent
)
;
}
