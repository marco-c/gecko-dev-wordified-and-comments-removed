"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
redux
-
head
.
js
"
this
)
;
const
{
ORDERED_PROPS
}
=
require
(
"
devtools
/
client
/
accessibility
/
constants
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
accessibility
.
enabled
"
true
)
;
async
function
initA11y
(
)
{
if
(
Services
.
appinfo
.
accessibilityEnabled
)
{
return
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
}
const
initPromise
=
new
Promise
(
resolve
=
>
{
const
observe
=
(
)
=
>
{
Services
.
obs
.
removeObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
}
)
;
const
a11yService
=
Cc
[
"
mozilla
.
org
/
accessibilityService
;
1
"
]
.
getService
(
Ci
.
nsIAccessibilityService
)
;
await
initPromise
;
return
a11yService
;
}
function
shutdownA11y
(
)
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
return
Promise
.
resolve
(
)
;
}
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceShrinkingGC
(
)
;
return
new
Promise
(
resolve
=
>
{
const
observe
=
(
subject
topic
data
)
=
>
{
if
(
data
=
=
=
"
0
"
)
{
Services
.
obs
.
removeObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
}
)
;
}
registerCleanupFunction
(
async
(
)
=
>
{
info
(
"
Cleaning
up
.
.
.
"
)
;
await
shutdownA11y
(
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
accessibility
.
enabled
"
)
;
}
)
;
const
EXPANDABLE_PROPS
=
[
"
actions
"
"
states
"
"
attributes
"
]
;
async
function
addTestTab
(
url
)
{
info
(
"
Adding
a
new
test
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
const
tab
=
await
addTab
(
url
)
;
const
panel
=
await
initAccessibilityPanel
(
tab
)
;
const
win
=
panel
.
panelWin
;
const
doc
=
win
.
document
;
const
store
=
win
.
view
.
store
;
const
enableButton
=
doc
.
getElementById
(
"
accessibility
-
enable
-
button
"
)
;
if
(
enableButton
)
{
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
enableButton
win
)
;
}
await
waitUntilState
(
store
state
=
>
state
.
accessibles
.
size
=
=
=
1
&
&
state
.
details
.
accessible
&
&
state
.
details
.
accessible
.
role
=
=
=
"
document
"
)
;
await
win
.
gToolbox
.
loadTool
(
"
inspector
"
)
;
return
{
tab
browser
:
tab
.
linkedBrowser
panel
win
toolbox
:
panel
.
_toolbox
doc
store
}
;
}
async
function
disableAccessibilityInspector
(
env
)
{
const
{
doc
win
panel
}
=
env
;
const
shutdown
=
panel
.
front
.
once
(
"
shutdown
"
)
;
const
disableButton
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
doc
.
getElementById
(
"
accessibility
-
disable
-
button
"
)
"
Wait
for
the
disable
button
.
"
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
disableButton
win
)
;
await
shutdown
;
}
async
function
initAccessibilityPanel
(
tab
=
gBrowser
.
selectedTab
)
{
const
target
=
await
TargetFactory
.
forTab
(
tab
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
accessibility
"
)
;
return
toolbox
.
getCurrentPanel
(
)
;
}
function
compareBadges
(
badges
expected
=
[
]
)
{
const
badgeEls
=
badges
?
[
.
.
.
badges
.
querySelectorAll
(
"
.
badge
"
)
]
:
[
]
;
return
(
badgeEls
.
length
=
=
=
expected
.
length
&
&
badgeEls
.
every
(
(
badge
i
)
=
>
badge
.
textContent
=
=
=
expected
[
i
]
)
)
;
}
function
closestScrolledParent
(
node
)
{
if
(
node
=
=
null
)
{
return
null
;
}
if
(
node
.
scrollHeight
>
node
.
clientHeight
)
{
return
node
;
}
return
closestScrolledParent
(
node
.
parentNode
)
;
}
function
isVisible
(
element
)
{
const
{
top
bottom
}
=
element
.
getBoundingClientRect
(
)
;
const
scrolledParent
=
closestScrolledParent
(
element
.
parentNode
)
;
const
scrolledParentRect
=
scrolledParent
?
scrolledParent
.
getBoundingClientRect
(
)
:
null
;
return
(
!
scrolledParent
|
|
(
top
>
=
scrolledParentRect
.
top
&
&
bottom
<
=
scrolledParentRect
.
bottom
)
)
;
}
function
checkSelected
(
row
expected
)
{
if
(
!
expected
)
{
return
true
;
}
if
(
row
.
classList
.
contains
(
"
selected
"
)
!
=
=
expected
)
{
return
false
;
}
return
isVisible
(
row
)
;
}
function
checkLevel
(
row
expected
)
{
if
(
!
expected
)
{
return
true
;
}
return
parseInt
(
row
.
getAttribute
(
"
aria
-
level
"
)
10
)
=
=
=
expected
;
}
async
function
checkTreeState
(
doc
expected
)
{
info
(
"
Checking
tree
state
.
"
)
;
const
hasExpectedStructure
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeRow
"
)
]
.
every
(
(
row
i
)
=
>
{
const
{
role
name
badges
selected
level
}
=
expected
[
i
]
;
return
(
row
.
querySelector
(
"
.
treeLabelCell
"
)
.
textContent
=
=
=
role
&
&
row
.
querySelector
(
"
.
treeValueCell
"
)
.
textContent
=
=
=
name
&
&
compareBadges
(
row
.
querySelector
(
"
.
badges
"
)
badges
)
&
&
checkSelected
(
row
selected
)
&
&
checkLevel
(
row
level
)
)
;
}
)
"
Wait
for
the
right
tree
update
.
"
)
;
ok
(
hasExpectedStructure
"
Tree
structure
is
correct
.
"
)
;
}
function
relationsMatch
(
relations
expected
)
{
for
(
const
relationType
in
expected
)
{
let
expTargets
=
expected
[
relationType
]
;
expTargets
=
Array
.
isArray
(
expTargets
)
?
expTargets
:
[
expTargets
]
;
let
targets
=
relations
[
relationType
]
;
targets
=
Array
.
isArray
(
targets
)
?
targets
:
[
targets
]
;
for
(
const
index
in
expTargets
)
{
if
(
expTargets
[
index
]
.
name
!
=
=
targets
[
index
]
.
name
|
|
expTargets
[
index
]
.
role
!
=
=
targets
[
index
]
.
role
)
{
return
false
;
}
}
}
return
true
;
}
function
parseNumReplacer
(
_
value
)
{
if
(
typeof
value
=
=
=
"
number
"
)
{
return
value
.
toFixed
(
2
)
;
}
return
value
;
}
async
function
checkAuditState
(
store
expectedState
)
{
info
(
"
Checking
audit
state
.
"
)
;
await
waitUntilState
(
store
(
{
details
}
)
=
>
{
const
{
audit
}
=
details
;
for
(
const
key
in
expectedState
)
{
const
expected
=
expectedState
[
key
]
;
if
(
expected
&
&
typeof
expected
=
=
=
"
object
"
)
{
if
(
JSON
.
stringify
(
audit
[
key
]
parseNumReplacer
)
!
=
=
JSON
.
stringify
(
expected
parseNumReplacer
)
)
{
return
false
;
}
}
else
if
(
audit
&
&
audit
[
key
]
!
=
=
expected
)
{
return
false
;
}
}
ok
(
true
"
Audit
state
is
correct
.
"
)
;
return
true
;
}
)
;
}
async
function
checkSidebarState
(
store
expectedState
)
{
info
(
"
Checking
sidebar
state
.
"
)
;
await
waitUntilState
(
store
(
{
details
}
)
=
>
{
for
(
const
key
of
ORDERED_PROPS
)
{
const
expected
=
expectedState
[
key
]
;
if
(
expected
=
=
=
undefined
)
{
continue
;
}
if
(
key
=
=
=
"
relations
"
)
{
if
(
!
relationsMatch
(
details
.
relations
expected
)
)
{
return
false
;
}
}
else
if
(
EXPANDABLE_PROPS
.
includes
(
key
)
)
{
if
(
JSON
.
stringify
(
details
.
accessible
[
key
]
)
!
=
=
JSON
.
stringify
(
expected
)
)
{
return
false
;
}
}
else
if
(
details
.
accessible
&
&
details
.
accessible
[
key
]
!
=
=
expected
)
{
return
false
;
}
}
ok
(
true
"
Sidebar
state
is
correct
.
"
)
;
return
true
;
}
)
;
}
async
function
checkToolbarState
(
doc
expected
)
{
info
(
"
Checking
toolbar
state
.
"
)
;
const
hasExpectedStructure
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
[
.
.
.
doc
.
querySelectorAll
(
"
button
.
toggle
-
button
.
badge
"
)
]
.
every
(
(
filter
i
)
=
>
expected
[
i
]
=
=
=
filter
.
classList
.
contains
(
"
checked
"
)
)
"
Wait
for
the
right
toolbar
state
.
"
)
;
ok
(
hasExpectedStructure
"
Toolbar
state
is
correct
.
"
)
;
}
async
function
focusAccessibleProperties
(
doc
)
{
const
tree
=
doc
.
querySelector
(
"
.
tree
"
)
;
if
(
doc
.
activeElement
!
=
=
tree
)
{
tree
.
focus
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
tree
.
querySelector
(
"
.
node
.
focused
"
)
"
Tree
selected
.
"
)
;
}
}
async
function
selectProperty
(
doc
id
)
{
const
win
=
doc
.
defaultView
;
let
selected
=
false
;
let
node
;
await
focusAccessibleProperties
(
doc
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
node
=
doc
.
getElementById
(
{
id
}
)
;
if
(
node
)
{
if
(
selected
)
{
return
node
.
firstChild
.
classList
.
contains
(
"
focused
"
)
;
}
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
node
win
)
;
selected
=
true
;
}
else
{
const
tree
=
doc
.
querySelector
(
"
.
tree
"
)
;
tree
.
scrollTop
=
parseFloat
(
win
.
getComputedStyle
(
tree
)
.
height
)
;
}
return
false
;
}
)
;
return
node
;
}
function
selectRow
(
doc
rowNumber
)
{
info
(
Selecting
row
{
rowNumber
}
.
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
doc
.
querySelectorAll
(
"
.
treeRow
"
)
[
rowNumber
]
doc
.
defaultView
)
;
}
async
function
toggleRow
(
doc
rowNumber
)
{
const
win
=
doc
.
defaultView
;
const
row
=
doc
.
querySelectorAll
(
"
.
treeRow
"
)
[
rowNumber
]
;
const
twisty
=
row
.
querySelector
(
"
.
theme
-
twisty
"
)
;
const
expected
=
!
twisty
.
classList
.
contains
(
"
open
"
)
;
info
(
{
expected
?
"
Expanding
"
:
"
Collapsing
"
}
row
{
rowNumber
}
.
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
twisty
win
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
twisty
.
classList
.
contains
(
"
devtools
-
throbber
"
)
&
&
expected
=
=
=
twisty
.
classList
.
contains
(
"
open
"
)
"
Twisty
updated
.
"
)
;
}
async
function
toggleFilter
(
doc
filterIndex
)
{
const
win
=
doc
.
defaultView
;
const
filter
=
doc
.
querySelectorAll
(
"
.
devtools
-
toolbar
.
badge
.
toggle
-
button
"
)
[
filterIndex
]
;
const
expected
=
!
filter
.
classList
.
contains
(
"
checked
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
filter
{
}
win
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
expected
=
=
=
filter
.
classList
.
contains
(
"
checked
"
)
"
Filter
updated
.
"
)
;
}
async
function
findAccessibleFor
(
{
toolbox
:
{
walker
:
domWalker
}
panel
:
{
walker
:
a11yWalker
}
}
selector
)
{
const
node
=
await
domWalker
.
querySelector
(
domWalker
.
rootNode
selector
)
;
return
a11yWalker
.
getAccessibleFor
(
node
)
;
}
async
function
selectAccessibleForNode
(
env
selector
)
{
const
{
panel
win
}
=
env
;
const
front
=
await
findAccessibleFor
(
env
selector
)
;
const
{
EVENTS
}
=
win
;
const
onSelected
=
win
.
once
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_SELECTED
)
;
panel
.
selectAccessible
(
front
)
;
await
onSelected
;
}
async
function
runA11yPanelTests
(
tests
env
)
{
for
(
const
{
desc
setup
expected
}
of
tests
)
{
info
(
desc
)
;
if
(
setup
)
{
await
setup
(
env
)
;
}
const
{
tree
sidebar
audit
toolbar
}
=
expected
;
if
(
tree
)
{
await
checkTreeState
(
env
.
doc
tree
)
;
}
if
(
sidebar
)
{
await
checkSidebarState
(
env
.
store
sidebar
)
;
}
if
(
toolbar
)
{
await
checkToolbarState
(
env
.
doc
toolbar
)
;
}
if
(
typeof
audit
!
=
=
"
undefined
"
)
{
await
checkAuditState
(
env
.
store
audit
)
;
}
}
}
function
buildURL
(
uri
)
{
return
data
:
text
/
html
;
charset
=
UTF
-
8
{
encodeURIComponent
(
uri
)
}
;
}
function
addA11yPanelTestsTask
(
tests
uri
msg
)
{
addA11YPanelTask
(
msg
uri
env
=
>
runA11yPanelTests
(
tests
env
)
)
;
}
function
addA11YPanelTask
(
msg
uri
task
)
{
add_task
(
async
function
a11YPanelTask
(
)
{
info
(
msg
)
;
const
env
=
await
addTestTab
(
buildURL
(
uri
)
)
;
await
task
(
env
)
;
await
disableAccessibilityInspector
(
env
)
;
}
)
;
}
function
reload
(
target
waitForTargetEvent
=
"
navigate
"
)
{
executeSoon
(
(
)
=
>
target
.
reload
(
)
)
;
return
once
(
target
waitForTargetEvent
)
;
}
function
navigate
(
target
url
waitForTargetEvent
=
"
navigate
"
)
{
executeSoon
(
(
)
=
>
target
.
navigateTo
(
{
url
}
)
)
;
return
once
(
target
waitForTargetEvent
)
;
}
