"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
ORDERED_PROPS
PREF_KEYS
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
accessibility
/
constants
.
js
"
)
;
const
SIMULATION_MENU_BUTTON_ID
=
"
simulation
-
menu
-
button
"
;
const
SIMULATION_MENU_ID
=
"
simulation
-
menu
-
button
-
menu
"
;
const
TREE_FILTERS_MENU_ID
=
"
accessibility
-
tree
-
filters
-
menu
"
;
const
PREFS_MENU_ID
=
"
accessibility
-
tree
-
filters
-
prefs
-
menu
"
;
const
MENU_INDEXES
=
{
[
TREE_FILTERS_MENU_ID
]
:
0
[
PREFS_MENU_ID
]
:
1
}
;
function
waitForAccessibilityShutdown
(
)
{
return
new
Promise
(
resolve
=
>
{
if
(
!
Services
.
appinfo
.
accessibilityEnabled
)
{
resolve
(
)
;
return
;
}
const
observe
=
(
subject
topic
data
)
=
>
{
if
(
data
=
=
=
"
0
"
)
{
Services
.
obs
.
removeObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
ok
(
!
Services
.
appinfo
.
accessibilityEnabled
"
Accessibility
disabled
in
this
process
"
)
;
resolve
(
)
;
}
}
;
Services
.
obs
.
addObserver
(
observe
"
a11y
-
init
-
or
-
shutdown
"
)
;
SpecialPowers
.
gc
(
)
;
SpecialPowers
.
forceShrinkingGC
(
)
;
SpecialPowers
.
forceCC
(
)
;
}
)
;
}
async
function
shutdownAccessibility
(
browser
)
{
await
waitForAccessibilityShutdown
(
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
waitForAccessibilityShutdown
)
;
}
const
EXPANDABLE_PROPS
=
[
"
actions
"
"
states
"
"
attributes
"
]
;
async
function
addTestTab
(
url
{
waitUntilDocumentAccessibleInState
=
true
}
=
{
}
)
{
info
(
"
Adding
a
new
test
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
const
tab
=
await
addTab
(
url
)
;
const
panel
=
await
initAccessibilityPanel
(
tab
)
;
const
win
=
panel
.
panelWin
;
const
doc
=
win
.
document
;
const
store
=
win
.
view
.
store
;
win
.
focus
(
)
;
if
(
waitUntilDocumentAccessibleInState
)
{
await
waitUntilState
(
store
state
=
>
state
.
accessibles
.
size
=
=
=
1
&
&
state
.
details
.
accessible
?
.
role
=
=
=
"
document
"
)
;
}
return
{
tab
browser
:
tab
.
linkedBrowser
panel
win
toolbox
:
panel
.
_toolbox
doc
store
}
;
}
async
function
initAccessibilityPanel
(
tab
=
gBrowser
.
selectedTab
)
{
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
accessibility
"
}
)
;
return
toolbox
.
getCurrentPanel
(
)
;
}
function
compareBadges
(
badges
expected
=
[
]
)
{
const
badgeEls
=
badges
?
[
.
.
.
badges
.
querySelectorAll
(
"
.
badge
"
)
]
:
[
]
;
return
(
badgeEls
.
length
=
=
=
expected
.
length
&
&
badgeEls
.
every
(
(
badge
i
)
=
>
badge
.
textContent
=
=
=
expected
[
i
]
)
)
;
}
function
closestScrolledParent
(
node
)
{
if
(
node
=
=
null
)
{
return
null
;
}
if
(
node
.
scrollHeight
>
node
.
clientHeight
)
{
return
node
;
}
return
closestScrolledParent
(
node
.
parentNode
)
;
}
function
isVisible
(
element
)
{
const
{
top
bottom
}
=
element
.
getBoundingClientRect
(
)
;
const
scrolledParent
=
closestScrolledParent
(
element
.
parentNode
)
;
const
scrolledParentRect
=
scrolledParent
?
scrolledParent
.
getBoundingClientRect
(
)
:
null
;
return
(
!
scrolledParent
|
|
(
top
>
=
scrolledParentRect
.
top
&
&
bottom
<
=
scrolledParentRect
.
bottom
)
)
;
}
function
checkSelected
(
row
expected
)
{
if
(
!
expected
)
{
return
true
;
}
if
(
row
.
classList
.
contains
(
"
selected
"
)
!
=
=
expected
)
{
return
false
;
}
return
isVisible
(
row
)
;
}
function
checkLevel
(
row
expected
)
{
if
(
!
expected
)
{
return
true
;
}
return
parseInt
(
row
.
getAttribute
(
"
aria
-
level
"
)
10
)
=
=
=
expected
;
}
async
function
checkTreeState
(
doc
expected
)
{
info
(
"
Checking
tree
state
.
"
)
;
const
hasExpectedStructure
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
const
rows
=
[
.
.
.
doc
.
querySelectorAll
(
"
.
treeRow
"
)
]
;
if
(
rows
.
length
!
=
=
expected
.
length
)
{
return
false
;
}
return
rows
.
every
(
(
row
i
)
=
>
{
const
{
role
name
badges
selected
level
}
=
expected
[
i
]
;
return
(
row
.
querySelector
(
"
.
treeLabelCell
"
)
.
textContent
=
=
=
role
&
&
row
.
querySelector
(
"
.
treeValueCell
"
)
.
textContent
=
=
=
name
&
&
compareBadges
(
row
.
querySelector
(
"
.
badges
"
)
badges
)
&
&
checkSelected
(
row
selected
)
&
&
checkLevel
(
row
level
)
)
;
}
)
;
}
"
Wait
for
the
right
tree
update
.
"
)
;
ok
(
hasExpectedStructure
"
Tree
structure
is
correct
.
"
)
;
}
function
relationsMatch
(
relations
expected
)
{
for
(
const
relationType
in
expected
)
{
let
expTargets
=
expected
[
relationType
]
;
expTargets
=
Array
.
isArray
(
expTargets
)
?
expTargets
:
[
expTargets
]
;
let
targets
=
relations
?
relations
[
relationType
]
:
[
]
;
targets
=
Array
.
isArray
(
targets
)
?
targets
:
[
targets
]
;
for
(
const
index
in
expTargets
)
{
if
(
!
targets
[
index
]
)
{
return
false
;
}
if
(
expTargets
[
index
]
.
name
!
=
=
targets
[
index
]
.
name
|
|
expTargets
[
index
]
.
role
!
=
=
targets
[
index
]
.
role
)
{
return
false
;
}
}
}
return
true
;
}
function
parseNumReplacer
(
_
value
)
{
if
(
typeof
value
=
=
=
"
number
"
)
{
return
value
.
toFixed
(
2
)
;
}
return
value
;
}
async
function
checkAuditState
(
store
expectedState
)
{
info
(
"
Checking
audit
state
.
"
)
;
await
waitUntilState
(
store
(
{
details
}
)
=
>
{
const
{
audit
}
=
details
;
for
(
const
key
in
expectedState
)
{
const
expected
=
expectedState
[
key
]
;
if
(
expected
&
&
typeof
expected
=
=
=
"
object
"
)
{
if
(
JSON
.
stringify
(
audit
[
key
]
parseNumReplacer
)
!
=
=
JSON
.
stringify
(
expected
parseNumReplacer
)
)
{
return
false
;
}
}
else
if
(
audit
&
&
audit
[
key
]
!
=
=
expected
)
{
return
false
;
}
}
ok
(
true
"
Audit
state
is
correct
.
"
)
;
return
true
;
}
)
;
}
async
function
checkSidebarState
(
store
expectedState
)
{
info
(
"
Checking
sidebar
state
.
"
)
;
await
waitUntilState
(
store
(
{
details
}
)
=
>
{
for
(
const
key
of
ORDERED_PROPS
)
{
const
expected
=
expectedState
[
key
]
;
if
(
expected
=
=
=
undefined
)
{
continue
;
}
if
(
key
=
=
=
"
relations
"
)
{
if
(
!
relationsMatch
(
details
.
relations
expected
)
)
{
return
false
;
}
}
else
if
(
EXPANDABLE_PROPS
.
includes
(
key
)
)
{
if
(
JSON
.
stringify
(
details
.
accessible
[
key
]
)
!
=
=
JSON
.
stringify
(
expected
)
)
{
return
false
;
}
}
else
if
(
details
.
accessible
&
&
details
.
accessible
[
key
]
!
=
=
expected
)
{
return
false
;
}
}
ok
(
true
"
Sidebar
state
is
correct
.
"
)
;
return
true
;
}
)
;
}
async
function
checkToolbarPrefsState
(
doc
toolbarPrefValues
store
)
{
info
(
"
Checking
toolbar
prefs
state
.
"
)
;
const
[
hasExpectedStructure
]
=
await
Promise
.
all
(
[
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
Object
.
keys
(
toolbarPrefValues
)
.
every
(
name
=
>
Services
.
prefs
.
getBoolPref
(
PREF_KEYS
[
name
]
false
)
=
=
=
toolbarPrefValues
[
name
]
)
;
}
"
Wait
for
the
right
prefs
state
.
"
)
waitUntilState
(
store
(
{
ui
}
)
=
>
{
for
(
const
name
in
toolbarPrefValues
)
{
if
(
ui
[
name
]
!
=
=
toolbarPrefValues
[
name
]
)
{
return
false
;
}
}
ok
(
true
"
UI
pref
state
is
correct
.
"
)
;
return
true
;
}
)
]
)
;
ok
(
hasExpectedStructure
"
Prefs
state
is
correct
.
"
)
;
}
async
function
checkToolbarState
(
doc
activeToolbarFilters
)
{
info
(
"
Checking
toolbar
state
.
"
)
;
const
hasExpectedStructure
=
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
[
.
.
.
doc
.
querySelectorAll
(
"
#
accessibility
-
tree
-
filters
-
menu
.
command
"
)
]
.
every
(
(
filter
i
)
=
>
(
activeToolbarFilters
[
i
]
?
"
true
"
:
null
)
=
=
=
filter
.
getAttribute
(
"
aria
-
checked
"
)
)
"
Wait
for
the
right
toolbar
state
.
"
)
;
ok
(
hasExpectedStructure
"
Toolbar
state
is
correct
.
"
)
;
}
async
function
checkSimulationState
(
doc
toolboxDoc
expected
)
{
const
{
buttonActive
checkedOptionIndices
colorMatrix
}
=
expected
;
await
waitFor
(
(
)
=
>
doc
.
getElementById
(
SIMULATION_MENU_BUTTON_ID
)
.
classList
.
contains
(
"
active
"
)
=
=
=
buttonActive
)
;
ok
(
true
Simulation
menu
button
contains
{
buttonActive
?
"
active
"
:
"
base
"
}
class
.
)
;
if
(
checkedOptionIndices
)
{
const
simulationMenuOptions
=
toolboxDoc
.
getElementById
(
SIMULATION_MENU_ID
)
.
querySelectorAll
(
"
.
menuitem
"
)
;
simulationMenuOptions
.
forEach
(
(
menuListItem
index
)
=
>
{
const
isChecked
=
checkedOptionIndices
.
includes
(
index
)
;
const
button
=
menuListItem
.
firstChild
;
is
(
button
.
getAttribute
(
"
aria
-
checked
"
)
isChecked
?
"
true
"
:
null
Simulation
option
{
index
}
is
{
isChecked
?
"
"
:
"
not
"
}
selected
.
)
;
}
)
;
}
const
docShellColorMatrix
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
content
.
window
.
docShell
.
getColorMatrix
(
)
)
;
Assert
.
deepEqual
(
docShellColorMatrix
.
map
(
v
=
>
v
.
toFixed
(
6
)
)
colorMatrix
docShell
color
matrix
has
expected
value
)
;
}
async
function
focusAccessibleProperties
(
doc
)
{
const
tree
=
doc
.
querySelector
(
"
.
tree
"
)
;
if
(
doc
.
activeElement
!
=
=
tree
)
{
tree
.
focus
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
tree
.
querySelector
(
"
.
node
.
focused
"
)
"
Tree
selected
.
"
)
;
}
}
async
function
selectProperty
(
doc
id
)
{
const
win
=
doc
.
defaultView
;
let
selected
=
false
;
let
node
;
await
focusAccessibleProperties
(
doc
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
node
=
doc
.
getElementById
(
{
id
}
)
;
if
(
node
)
{
if
(
selected
)
{
return
node
.
firstChild
.
classList
.
contains
(
"
focused
"
)
;
}
AccessibilityUtils
.
setEnv
(
{
nonNegativeTabIndexRule
:
false
}
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
node
win
)
;
AccessibilityUtils
.
resetEnv
(
)
;
selected
=
true
;
}
else
{
const
tree
=
doc
.
querySelector
(
"
.
tree
"
)
;
tree
.
scrollTop
=
parseFloat
(
win
.
getComputedStyle
(
tree
)
.
height
)
;
}
return
false
;
}
)
;
return
node
;
}
function
selectRow
(
doc
rowNumber
)
{
info
(
Selecting
row
{
rowNumber
}
.
)
;
AccessibilityUtils
.
setEnv
(
{
nonNegativeTabIndexRule
:
false
}
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
doc
.
querySelectorAll
(
"
.
treeRow
"
)
[
rowNumber
]
doc
.
defaultView
)
;
AccessibilityUtils
.
resetEnv
(
)
;
}
async
function
toggleRow
(
doc
rowNumber
)
{
const
win
=
doc
.
defaultView
;
const
row
=
doc
.
querySelectorAll
(
"
.
treeRow
"
)
[
rowNumber
]
;
const
twisty
=
row
.
querySelector
(
"
.
theme
-
twisty
"
)
;
const
expected
=
!
twisty
.
classList
.
contains
(
"
open
"
)
;
info
(
{
expected
?
"
Expanding
"
:
"
Collapsing
"
}
row
{
rowNumber
}
.
)
;
AccessibilityUtils
.
setEnv
(
{
mustHaveAccessibleRule
:
false
}
)
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
twisty
win
)
;
AccessibilityUtils
.
resetEnv
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
twisty
.
classList
.
contains
(
"
devtools
-
throbber
"
)
&
&
expected
=
=
=
twisty
.
classList
.
contains
(
"
open
"
)
"
Twisty
updated
.
"
)
;
}
async
function
toggleMenuItem
(
doc
toolboxDoc
menuId
menuItemIndex
)
{
const
toolboxWin
=
toolboxDoc
.
defaultView
;
const
panelWin
=
doc
.
defaultView
;
const
menuButton
=
doc
.
querySelectorAll
(
"
.
toolbar
-
menu
-
button
"
)
[
MENU_INDEXES
[
menuId
]
]
;
ok
(
menuButton
"
Expected
menu
button
"
)
;
const
menuEl
=
toolboxDoc
.
getElementById
(
menuId
)
;
const
menuItem
=
menuEl
.
querySelectorAll
(
"
.
command
"
)
[
menuItemIndex
]
;
ok
(
menuItem
"
Expected
menu
item
"
)
;
const
expected
=
menuItem
.
getAttribute
(
"
aria
-
checked
"
)
=
=
=
"
true
"
?
null
:
"
true
"
;
const
onPopupShown
=
new
Promise
(
r
=
>
toolboxDoc
.
addEventListener
(
"
popupshown
"
r
{
once
:
true
}
)
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuButton
{
}
panelWin
)
;
await
onPopupShown
;
const
boundingRect
=
menuItem
.
getBoundingClientRect
(
)
;
ok
(
boundingRect
.
width
>
0
&
&
boundingRect
.
height
>
0
"
Menu
item
is
visible
.
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
menuItem
{
}
toolboxWin
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
expected
=
=
=
menuItem
.
getAttribute
(
"
aria
-
checked
"
)
"
Menu
item
updated
.
"
)
;
}
async
function
openSimulationMenu
(
doc
toolboxDoc
)
{
doc
.
getElementById
(
SIMULATION_MENU_BUTTON_ID
)
.
click
(
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
toolboxDoc
.
getElementById
(
SIMULATION_MENU_ID
)
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
async
function
toggleSimulationOption
(
toolboxDoc
optionIndex
)
{
const
simulationMenu
=
toolboxDoc
.
getElementById
(
SIMULATION_MENU_ID
)
;
const
menuItemButton
=
simulationMenu
.
querySelectorAll
(
"
.
menuitem
"
)
[
optionIndex
]
.
firstChild
;
const
previousAriaCheckedValue
=
menuItemButton
.
getAttribute
(
"
aria
-
checked
"
)
;
menuItemButton
.
click
(
)
;
await
waitFor
(
(
)
=
>
menuItemButton
.
getAttribute
(
"
aria
-
checked
"
)
!
=
=
previousAriaCheckedValue
)
;
await
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
!
simulationMenu
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
async
function
findAccessibleFor
(
{
toolbox
:
{
target
}
panel
:
{
accessibilityProxy
:
{
accessibilityFront
:
{
accessibleWalkerFront
}
}
}
}
selector
)
{
const
domWalker
=
(
await
target
.
getFront
(
"
inspector
"
)
)
.
walker
;
const
node
=
await
domWalker
.
querySelector
(
domWalker
.
rootNode
selector
)
;
return
accessibleWalkerFront
.
getAccessibleFor
(
node
)
;
}
async
function
selectAccessibleForNode
(
env
selector
)
{
const
{
panel
win
}
=
env
;
const
front
=
await
findAccessibleFor
(
env
selector
)
;
const
{
EVENTS
}
=
win
;
const
onSelected
=
win
.
once
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_SELECTED
)
;
panel
.
selectAccessible
(
front
)
;
await
onSelected
;
}
async
function
runA11yPanelTests
(
tests
env
)
{
for
(
const
{
desc
setup
expected
}
of
tests
)
{
info
(
desc
)
;
if
(
setup
)
{
await
setup
(
env
)
;
}
const
{
tree
sidebar
audit
toolbarPrefValues
activeToolbarFilters
simulation
}
=
expected
;
if
(
tree
)
{
await
checkTreeState
(
env
.
doc
tree
)
;
}
if
(
sidebar
)
{
await
checkSidebarState
(
env
.
store
sidebar
)
;
}
if
(
activeToolbarFilters
)
{
await
checkToolbarState
(
env
.
doc
activeToolbarFilters
)
;
}
if
(
toolbarPrefValues
)
{
await
checkToolbarPrefsState
(
env
.
doc
toolbarPrefValues
env
.
store
)
;
}
if
(
typeof
audit
!
=
=
"
undefined
"
)
{
await
checkAuditState
(
env
.
store
audit
)
;
}
if
(
simulation
)
{
await
checkSimulationState
(
env
.
doc
env
.
toolbox
.
doc
simulation
)
;
}
}
}
function
buildURL
(
uri
options
=
{
}
)
{
if
(
options
.
remoteIframe
)
{
const
srcURL
=
new
URL
(
http
:
/
/
example
.
net
/
document
-
builder
.
sjs
)
;
srcURL
.
searchParams
.
append
(
"
html
"
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
/
>
<
title
>
Accessibility
Panel
Test
(
OOP
)
<
/
title
>
<
/
head
>
<
body
>
{
uri
}
<
/
body
>
<
/
html
>
)
;
uri
=
<
iframe
title
=
"
Accessibility
Panel
Test
(
OOP
)
"
src
=
"
{
srcURL
.
href
}
"
/
>
;
}
return
data
:
text
/
html
;
charset
=
UTF
-
8
{
encodeURIComponent
(
uri
)
}
;
}
function
addA11yPanelTestsTask
(
tests
uri
msg
options
)
{
addA11YPanelTask
(
msg
uri
env
=
>
runA11yPanelTests
(
tests
env
)
options
)
;
}
async
function
closeTabToolboxAccessibility
(
tab
=
gBrowser
.
selectedTab
)
{
if
(
gDevTools
.
hasToolboxForTab
(
tab
)
)
{
await
gDevTools
.
closeToolboxForTab
(
tab
)
;
}
await
shutdownAccessibility
(
gBrowser
.
getBrowserForTab
(
tab
)
)
;
await
removeTab
(
tab
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
function
addA11YPanelTask
(
msg
uri
task
options
=
{
}
)
{
add_task
(
async
function
a11YPanelTask
(
)
{
info
(
msg
)
;
const
env
=
await
addTestTab
(
uri
.
startsWith
(
"
http
"
)
?
uri
:
buildURL
(
uri
options
)
)
;
await
task
(
env
)
;
await
closeTabToolboxAccessibility
(
env
.
tab
)
;
}
)
;
}
