"
use
strict
"
;
const
{
FETCH_CHILDREN
RESET
SELECT
HIGHLIGHT
}
=
require
(
"
.
.
/
constants
"
)
;
function
getInitialState
(
)
{
return
new
Map
(
)
;
}
function
accessibles
(
state
=
getInitialState
(
)
action
)
{
switch
(
action
.
type
)
{
case
FETCH_CHILDREN
:
return
onReceiveChildren
(
state
action
)
;
case
HIGHLIGHT
:
case
SELECT
:
return
onReceiveAncestry
(
state
action
)
;
case
RESET
:
return
getInitialState
(
)
;
default
:
return
state
;
}
}
function
cleanupChild
(
cache
accessible
)
{
let
cached
=
cache
.
get
(
accessible
.
actorID
)
;
if
(
!
cached
)
{
return
;
}
for
(
let
child
of
cached
.
children
)
{
cleanupChild
(
cache
child
)
;
}
cache
.
delete
(
accessible
.
actorID
)
;
}
function
staleChildren
(
cache
accessible
)
{
let
cached
=
cache
.
get
(
accessible
.
actorID
)
;
if
(
!
cached
)
{
return
false
;
}
return
cached
.
children
.
length
!
=
=
accessible
.
childCount
;
}
function
updateChildrenCache
(
cache
accessible
children
)
{
let
{
actorID
}
=
accessible
;
if
(
cache
.
has
(
actorID
)
)
{
let
cached
=
cache
.
get
(
actorID
)
;
for
(
let
child
of
cached
.
children
)
{
if
(
!
children
.
includes
(
child
)
|
|
staleChildren
(
cache
child
)
)
{
cleanupChild
(
cache
child
)
;
}
}
cached
.
children
=
children
;
cache
.
set
(
actorID
cached
)
;
}
else
{
cache
.
set
(
actorID
{
children
}
)
;
}
return
cache
;
}
function
onReceiveChildren
(
cache
action
)
{
let
{
accessible
response
:
children
error
}
=
action
;
if
(
error
)
{
console
.
warn
(
"
Error
fetching
children
"
accessible
error
)
;
return
cache
;
}
return
updateChildrenCache
(
new
Map
(
cache
)
accessible
children
)
;
}
function
onReceiveAncestry
(
cache
action
)
{
let
{
accessible
:
acc
response
:
ancestry
error
}
=
action
;
if
(
error
)
{
console
.
warn
(
"
Error
fetching
ancestry
"
acc
error
)
;
return
cache
;
}
let
newCache
=
new
Map
(
cache
)
;
ancestry
.
forEach
(
(
{
accessible
children
}
)
=
>
updateChildrenCache
(
newCache
accessible
children
)
)
;
return
newCache
;
}
exports
.
accessibles
=
accessibles
;
