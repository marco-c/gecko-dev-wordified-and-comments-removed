"
use
strict
"
;
const
{
AUDIT
FETCH_CHILDREN
HIGHLIGHT
RESET
SELECT
}
=
require
(
"
devtools
/
client
/
accessibility
/
constants
"
)
;
function
getInitialState
(
)
{
return
new
Map
(
)
;
}
function
accessibles
(
state
=
getInitialState
(
)
action
)
{
switch
(
action
.
type
)
{
case
FETCH_CHILDREN
:
return
onReceiveChildren
(
state
action
)
;
case
HIGHLIGHT
:
case
SELECT
:
return
onReceiveAncestry
(
state
action
)
;
case
AUDIT
:
return
onAudit
(
state
action
)
;
case
RESET
:
return
getInitialState
(
)
;
default
:
return
state
;
}
}
function
getActorID
(
accessible
)
{
return
accessible
.
actorID
|
|
(
accessible
.
_form
&
&
accessible
.
_form
.
actor
)
;
}
function
cleanupChild
(
cache
accessible
)
{
const
actorID
=
getActorID
(
accessible
)
;
const
cached
=
cache
.
get
(
actorID
)
;
if
(
!
cached
)
{
return
;
}
for
(
const
child
of
cached
.
children
)
{
cleanupChild
(
cache
child
)
;
}
cache
.
delete
(
actorID
)
;
}
function
staleChildren
(
cache
accessible
)
{
const
cached
=
cache
.
get
(
getActorID
(
accessible
)
)
;
if
(
!
cached
)
{
return
false
;
}
return
cached
.
children
.
length
!
=
=
accessible
.
childCount
;
}
function
updateChildrenCache
(
cache
accessible
children
)
{
const
actorID
=
getActorID
(
accessible
)
;
if
(
cache
.
has
(
actorID
)
)
{
const
cached
=
cache
.
get
(
actorID
)
;
for
(
const
child
of
cached
.
children
)
{
if
(
!
children
.
includes
(
child
)
|
|
staleChildren
(
cache
child
)
)
{
cleanupChild
(
cache
child
)
;
}
}
cached
.
children
=
children
;
cache
.
set
(
actorID
cached
)
;
}
else
{
cache
.
set
(
actorID
{
children
}
)
;
}
return
cache
;
}
function
updateAncestry
(
cache
ancestry
)
{
ancestry
.
forEach
(
(
{
accessible
children
}
)
=
>
updateChildrenCache
(
cache
accessible
children
)
)
;
return
cache
;
}
function
onReceiveChildren
(
cache
action
)
{
const
{
error
accessible
response
:
children
}
=
action
;
if
(
!
error
)
{
return
updateChildrenCache
(
new
Map
(
cache
)
accessible
children
)
;
}
if
(
accessible
.
actorID
)
{
console
.
warn
(
Error
fetching
children
:
accessible
error
)
;
return
cache
;
}
const
newCache
=
new
Map
(
cache
)
;
cleanupChild
(
newCache
accessible
)
;
return
newCache
;
}
function
onReceiveAncestry
(
cache
action
)
{
const
{
error
response
:
ancestry
}
=
action
;
if
(
error
)
{
console
.
warn
(
Error
fetching
ancestry
:
error
)
;
return
cache
;
}
return
updateAncestry
(
new
Map
(
cache
)
ancestry
)
;
}
function
onAudit
(
cache
action
)
{
const
{
error
response
:
ancestries
}
=
action
;
if
(
error
)
{
console
.
warn
(
Error
performing
an
audit
:
error
)
;
return
cache
;
}
const
newCache
=
new
Map
(
cache
)
;
ancestries
.
forEach
(
ancestry
=
>
updateAncestry
(
newCache
ancestry
)
)
;
return
newCache
;
}
exports
.
accessibles
=
accessibles
;
