"
use
strict
"
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
TreeView
=
createFactory
(
require
(
"
devtools
/
client
/
shared
/
components
/
tree
/
TreeView
"
)
)
;
const
{
MODE
}
=
require
(
"
devtools
/
client
/
shared
/
components
/
reps
/
reps
"
)
;
const
{
fetchChildren
}
=
require
(
"
devtools
/
client
/
accessibility
/
actions
/
accessibles
"
)
;
const
{
L10N
}
=
require
(
"
devtools
/
client
/
accessibility
/
utils
/
l10n
"
)
;
const
{
isFiltered
}
=
require
(
"
devtools
/
client
/
accessibility
/
utils
/
audit
"
)
;
const
AccessibilityRow
=
createFactory
(
require
(
"
devtools
/
client
/
accessibility
/
components
/
AccessibilityRow
"
)
)
;
const
AccessibilityRowValue
=
createFactory
(
require
(
"
devtools
/
client
/
accessibility
/
components
/
AccessibilityRowValue
"
)
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
accessibility
/
provider
"
)
;
const
{
scrollIntoView
}
=
require
(
"
devtools
/
client
/
shared
/
scroll
"
)
;
class
AccessibilityTree
extends
Component
{
static
get
propTypes
(
)
{
return
{
toolboxDoc
:
PropTypes
.
object
.
isRequired
dispatch
:
PropTypes
.
func
.
isRequired
accessibles
:
PropTypes
.
object
expanded
:
PropTypes
.
object
selected
:
PropTypes
.
string
highlighted
:
PropTypes
.
object
filtered
:
PropTypes
.
bool
getAccessibilityTreeRoot
:
PropTypes
.
func
.
isRequired
startListeningForAccessibilityEvents
:
PropTypes
.
func
.
isRequired
stopListeningForAccessibilityEvents
:
PropTypes
.
func
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
onNameChange
=
this
.
onNameChange
.
bind
(
this
)
;
this
.
onReorder
=
this
.
onReorder
.
bind
(
this
)
;
this
.
onTextChange
=
this
.
onTextChange
.
bind
(
this
)
;
this
.
renderValue
=
this
.
renderValue
.
bind
(
this
)
;
this
.
scrollSelectedRowIntoView
=
this
.
scrollSelectedRowIntoView
.
bind
(
this
)
;
}
componentWillMount
(
)
{
this
.
props
.
startListeningForAccessibilityEvents
(
{
reorder
:
this
.
onReorder
"
name
-
change
"
:
this
.
onNameChange
"
text
-
change
"
:
this
.
onTextChange
}
)
;
window
.
on
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_INSPECTED
this
.
scrollSelectedRowIntoView
)
;
return
null
;
}
componentDidUpdate
(
prevProps
)
{
if
(
this
.
props
.
filtered
!
=
=
prevProps
.
filtered
)
{
this
.
scrollSelectedRowIntoView
(
)
;
}
window
.
emit
(
EVENTS
.
ACCESSIBILITY_INSPECTOR_UPDATED
)
;
}
componentWillUnmount
(
)
{
this
.
props
.
stopListeningForAccessibilityEvents
(
{
reorder
:
this
.
onReorder
"
name
-
change
"
:
this
.
onNameChange
"
text
-
change
"
:
this
.
onTextChange
}
)
;
window
.
off
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_INSPECTED
this
.
scrollSelectedRowIntoView
)
;
}
onReorder
(
accessibleFront
)
{
if
(
this
.
props
.
accessibles
.
has
(
accessibleFront
.
actorID
)
)
{
this
.
props
.
dispatch
(
fetchChildren
(
accessibleFront
)
)
;
}
}
scrollSelectedRowIntoView
(
)
{
const
{
treeview
}
=
this
.
refs
;
if
(
!
treeview
)
{
return
;
}
const
treeEl
=
treeview
.
treeRef
.
current
;
if
(
!
treeEl
)
{
return
;
}
const
selected
=
treeEl
.
ownerDocument
.
querySelector
(
"
.
treeTable
.
treeRow
.
selected
"
)
;
if
(
selected
)
{
scrollIntoView
(
selected
{
center
:
true
}
)
;
}
}
onNameChange
(
accessibleFront
parentFront
)
{
const
{
accessibles
dispatch
}
=
this
.
props
;
const
accessibleWalkerFront
=
accessibleFront
.
parent
(
)
;
parentFront
=
parentFront
|
|
accessibleWalkerFront
;
if
(
accessibles
.
has
(
accessibleFront
.
actorID
)
|
|
accessibles
.
has
(
parentFront
.
actorID
)
)
{
dispatch
(
fetchChildren
(
parentFront
)
)
;
}
}
onTextChange
(
accessibleFront
)
{
const
{
accessibles
dispatch
}
=
this
.
props
;
if
(
accessibles
.
has
(
accessibleFront
.
actorID
)
)
{
dispatch
(
fetchChildren
(
accessibleFront
)
)
;
}
}
renderValue
(
props
)
{
return
AccessibilityRowValue
(
props
)
;
}
render
(
)
{
const
columns
=
[
{
id
:
"
default
"
title
:
L10N
.
getStr
(
"
accessibility
.
role
"
)
}
{
id
:
"
value
"
title
:
L10N
.
getStr
(
"
accessibility
.
name
"
)
}
]
;
const
{
accessibles
dispatch
expanded
selected
highlighted
:
highlightedItem
toolboxDoc
filtered
getAccessibilityTreeRoot
}
=
this
.
props
;
const
renderRow
=
rowProps
=
>
{
const
{
object
}
=
rowProps
.
member
;
const
highlighted
=
object
=
=
=
highlightedItem
;
return
AccessibilityRow
(
Object
.
assign
(
{
}
rowProps
{
toolboxDoc
highlighted
decorator
:
{
getRowClass
:
function
(
)
{
return
highlighted
?
[
"
highlighted
"
]
:
[
]
;
}
}
}
)
)
;
}
;
const
className
=
filtered
?
"
filtered
"
:
undefined
;
return
TreeView
(
{
ref
:
"
treeview
"
object
:
getAccessibilityTreeRoot
(
)
mode
:
MODE
.
SHORT
provider
:
new
Provider
(
accessibles
filtered
dispatch
)
columns
:
columns
className
renderValue
:
this
.
renderValue
renderRow
label
:
L10N
.
getStr
(
"
accessibility
.
treeName
"
)
header
:
true
expandedNodes
:
expanded
selected
onClickRow
(
nodePath
event
)
{
if
(
event
.
target
.
classList
.
contains
(
"
theme
-
twisty
"
)
)
{
this
.
toggle
(
nodePath
)
;
}
this
.
selectRow
(
this
.
rows
.
find
(
row
=
>
row
.
props
.
member
.
path
=
=
=
nodePath
)
{
preventAutoScroll
:
true
}
)
;
return
true
;
}
onContextMenuTree
:
function
(
e
)
{
let
row
=
this
.
getSelectedRow
(
)
;
if
(
!
row
)
{
return
;
}
row
=
row
.
getWrappedInstance
(
)
;
row
.
onContextMenu
(
e
)
;
}
}
)
;
}
}
const
mapStateToProps
=
(
{
accessibles
ui
:
{
expanded
selected
highlighted
}
audit
:
{
filters
}
}
)
=
>
(
{
accessibles
expanded
selected
highlighted
filtered
:
isFiltered
(
filters
)
}
)
;
module
.
exports
=
connect
(
mapStateToProps
)
(
AccessibilityTree
)
;
