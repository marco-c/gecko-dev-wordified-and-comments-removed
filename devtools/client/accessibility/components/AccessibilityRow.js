"
use
strict
"
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
findDOMNode
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
connect
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
TreeRow
=
require
(
"
devtools
/
client
/
shared
/
components
/
tree
/
TreeRow
"
)
;
const
AuditFilter
=
createFactory
(
require
(
"
.
/
AuditFilter
"
)
)
;
const
AuditController
=
createFactory
(
require
(
"
.
/
AuditController
"
)
)
;
const
{
flashElementOn
flashElementOff
}
=
require
(
"
devtools
/
client
/
inspector
/
markup
/
utils
"
)
;
const
{
openDocLink
}
=
require
(
"
devtools
/
client
/
shared
/
link
"
)
;
const
{
PREFS
VALUE_FLASHING_DURATION
VALUE_HIGHLIGHT_DURATION
}
=
require
(
"
.
.
/
constants
"
)
;
const
nodeConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
{
updateDetails
}
=
require
(
"
.
.
/
actions
/
details
"
)
;
const
{
unhighlight
}
=
require
(
"
.
.
/
actions
/
accessibles
"
)
;
const
{
L10N
}
=
require
(
"
.
.
/
utils
/
l10n
"
)
;
loader
.
lazyRequireGetter
(
this
"
Menu
"
"
devtools
/
client
/
framework
/
menu
"
)
;
loader
.
lazyRequireGetter
(
this
"
MenuItem
"
"
devtools
/
client
/
framework
/
menu
-
item
"
)
;
const
{
scrollIntoView
}
=
require
(
"
devtools
/
client
/
shared
/
scroll
"
)
;
const
JSON_URL_PREFIX
=
"
data
:
application
/
json
;
charset
=
UTF
-
8
"
;
const
TELEMETRY_ACCESSIBLE_CONTEXT_MENU_OPENED
=
"
devtools
.
accessibility
.
accessible_context_menu_opened
"
;
const
TELEMETRY_ACCESSIBLE_CONTEXT_MENU_ITEM_ACTIVATED
=
"
devtools
.
accessibility
.
accessible_context_menu_item_activated
"
;
class
HighlightableTreeRowClass
extends
TreeRow
{
shouldComponentUpdate
(
nextProps
)
{
const
shouldTreeRowUpdate
=
super
.
shouldComponentUpdate
(
nextProps
)
;
if
(
shouldTreeRowUpdate
)
{
return
shouldTreeRowUpdate
;
}
if
(
nextProps
.
highlighted
!
=
=
this
.
props
.
highlighted
|
|
nextProps
.
filtered
!
=
=
this
.
props
.
filtered
)
{
return
true
;
}
return
false
;
}
}
const
HighlightableTreeRow
=
createFactory
(
HighlightableTreeRowClass
)
;
class
AccessibilityRow
extends
Component
{
static
get
propTypes
(
)
{
return
{
.
.
.
TreeRow
.
propTypes
hasContextMenu
:
PropTypes
.
bool
.
isRequired
dispatch
:
PropTypes
.
func
.
isRequired
scrollContentNodeIntoView
:
PropTypes
.
bool
.
isRequired
supports
:
PropTypes
.
object
}
;
}
componentDidMount
(
)
{
const
{
member
:
{
selected
object
}
scrollContentNodeIntoView
}
=
this
.
props
;
if
(
selected
)
{
this
.
unhighlight
(
object
)
;
this
.
update
(
)
;
this
.
highlight
(
object
{
duration
:
VALUE_HIGHLIGHT_DURATION
}
scrollContentNodeIntoView
)
;
}
if
(
this
.
props
.
highlighted
)
{
this
.
scrollIntoView
(
)
;
}
}
componentDidUpdate
(
prevProps
)
{
const
{
member
:
{
selected
object
}
scrollContentNodeIntoView
}
=
this
.
props
;
if
(
!
prevProps
.
member
.
selected
&
&
selected
)
{
this
.
unhighlight
(
object
)
;
this
.
update
(
)
;
this
.
highlight
(
object
{
duration
:
VALUE_HIGHLIGHT_DURATION
}
scrollContentNodeIntoView
)
;
}
if
(
this
.
props
.
highlighted
)
{
this
.
scrollIntoView
(
)
;
}
if
(
!
selected
&
&
prevProps
.
member
.
value
!
=
=
this
.
props
.
member
.
value
)
{
this
.
flashValue
(
)
;
}
}
scrollIntoView
(
)
{
const
row
=
findDOMNode
(
this
)
;
if
(
!
row
)
{
return
;
}
scrollIntoView
(
row
)
;
}
async
update
(
)
{
const
{
dispatch
member
:
{
object
}
supports
}
=
this
.
props
;
if
(
!
object
.
actorID
)
{
return
;
}
const
domWalker
=
(
await
object
.
targetFront
.
getFront
(
"
inspector
"
)
)
.
walker
;
dispatch
(
updateDetails
(
domWalker
object
supports
)
)
;
window
.
emit
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_SELECTED
object
)
;
}
flashValue
(
)
{
const
row
=
findDOMNode
(
this
)
;
if
(
!
row
)
{
return
;
}
const
value
=
row
.
querySelector
(
"
.
objectBox
"
)
;
flashElementOn
(
value
)
;
if
(
this
.
_flashMutationTimer
)
{
clearTimeout
(
this
.
_flashMutationTimer
)
;
this
.
_flashMutationTimer
=
null
;
}
this
.
_flashMutationTimer
=
setTimeout
(
(
)
=
>
{
flashElementOff
(
value
)
;
}
VALUE_FLASHING_DURATION
)
;
}
async
scrollNodeIntoViewIfNeeded
(
accessibleFront
)
{
if
(
!
accessibleFront
.
actorID
)
{
return
;
}
const
domWalker
=
(
await
accessibleFront
.
targetFront
.
getFront
(
"
inspector
"
)
)
.
walker
;
const
node
=
await
domWalker
.
getNodeFromActor
(
accessibleFront
.
actorID
[
"
rawAccessible
"
"
DOMNode
"
]
)
;
if
(
!
node
)
{
return
;
}
if
(
node
.
nodeType
=
=
nodeConstants
.
ELEMENT_NODE
)
{
await
node
.
scrollIntoView
(
)
;
}
else
if
(
node
.
nodeType
!
=
nodeConstants
.
DOCUMENT_NODE
)
{
await
node
.
parentNode
(
)
.
scrollIntoView
(
)
;
}
}
async
highlight
(
accessibleFront
options
scrollContentNodeIntoView
)
{
this
.
props
.
dispatch
(
unhighlight
(
)
)
;
if
(
!
accessibleFront
)
{
return
;
}
const
accessibilityWalkerFront
=
accessibleFront
.
parent
(
)
;
if
(
!
accessibilityWalkerFront
)
{
return
;
}
if
(
scrollContentNodeIntoView
)
{
await
this
.
scrollNodeIntoViewIfNeeded
(
accessibleFront
)
;
}
accessibilityWalkerFront
.
highlightAccessible
(
accessibleFront
options
)
.
catch
(
error
=
>
console
.
warn
(
error
)
)
;
}
unhighlight
(
accessibleFront
)
{
this
.
props
.
dispatch
(
unhighlight
(
)
)
;
if
(
!
accessibleFront
)
{
return
;
}
const
accessibilityWalkerFront
=
accessibleFront
.
parent
(
)
;
if
(
!
accessibilityWalkerFront
)
{
return
;
}
accessibilityWalkerFront
.
unhighlight
(
)
.
catch
(
error
=
>
console
.
warn
(
error
)
)
;
}
async
printToJSON
(
)
{
const
{
member
supports
}
=
this
.
props
;
if
(
!
supports
.
snapshot
)
{
return
;
}
if
(
gTelemetry
)
{
gTelemetry
.
keyedScalarAdd
(
TELEMETRY_ACCESSIBLE_CONTEXT_MENU_ITEM_ACTIVATED
"
print
-
to
-
json
"
1
)
;
}
const
snapshot
=
await
member
.
object
.
snapshot
(
)
;
openDocLink
(
{
JSON_URL_PREFIX
}
{
encodeURIComponent
(
JSON
.
stringify
(
snapshot
)
)
}
)
;
}
onContextMenu
(
e
)
{
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
if
(
!
gToolbox
)
{
return
;
}
const
menu
=
new
Menu
(
{
id
:
"
accessibility
-
row
-
contextmenu
"
}
)
;
const
{
supports
}
=
this
.
props
;
if
(
supports
.
snapshot
)
{
menu
.
append
(
new
MenuItem
(
{
id
:
"
menu
-
printtojson
"
label
:
L10N
.
getStr
(
"
accessibility
.
tree
.
menu
.
printToJSON
"
)
click
:
(
)
=
>
this
.
printToJSON
(
)
}
)
)
;
}
menu
.
popup
(
e
.
screenX
e
.
screenY
gToolbox
.
doc
)
;
if
(
gTelemetry
)
{
gTelemetry
.
scalarAdd
(
TELEMETRY_ACCESSIBLE_CONTEXT_MENU_OPENED
1
)
;
}
}
render
(
)
{
const
{
member
}
=
this
.
props
;
const
props
=
{
.
.
.
this
.
props
onContextMenu
:
this
.
props
.
hasContextMenu
&
&
(
e
=
>
this
.
onContextMenu
(
e
)
)
onMouseOver
:
(
)
=
>
this
.
highlight
(
member
.
object
)
onMouseOut
:
(
)
=
>
this
.
unhighlight
(
member
.
object
)
key
:
{
member
.
path
}
-
{
member
.
active
?
"
active
"
:
"
inactive
"
}
}
;
return
AuditController
(
{
accessibleFront
:
member
.
object
}
AuditFilter
(
{
}
HighlightableTreeRow
(
props
)
)
)
;
}
}
const
mapStateToProps
=
(
{
ui
:
{
supports
[
PREFS
.
SCROLL_INTO_VIEW
]
:
scrollContentNodeIntoView
}
}
)
=
>
(
{
supports
scrollContentNodeIntoView
}
)
;
module
.
exports
=
connect
(
mapStateToProps
null
null
{
withRef
:
true
}
)
(
AccessibilityRow
)
;
