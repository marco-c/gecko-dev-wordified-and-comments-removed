"
use
strict
"
;
const
nodeConstants
=
require
(
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
constants
.
js
"
)
;
const
{
createFactory
createElement
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
.
mjs
"
)
;
const
ReactDOM
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dom
.
mjs
"
)
;
const
{
Provider
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
redux
.
js
"
)
;
const
MainFrame
=
createFactory
(
require
(
"
resource
:
/
/
devtools
/
client
/
accessibility
/
components
/
MainFrame
.
js
"
)
)
;
const
createStore
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
redux
/
create
-
store
.
js
"
)
;
const
{
reducers
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
accessibility
/
reducers
/
index
.
js
"
)
;
const
thunkOptions
=
{
options
:
{
}
}
;
const
store
=
createStore
(
reducers
{
thunkOptions
}
)
;
const
{
reset
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
accessibility
/
actions
/
ui
.
js
"
)
;
const
{
select
highlight
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
accessibility
/
actions
/
accessibles
.
js
"
)
;
class
AccessibilityView
{
constructor
(
localStore
)
{
addEventListener
(
"
devtools
/
chrome
/
message
"
this
.
onMessage
.
bind
(
this
)
true
)
;
this
.
store
=
localStore
;
}
async
initialize
(
{
supports
fluentBundles
toolbox
getAccessibilityTreeRoot
startListeningForAccessibilityEvents
stopListeningForAccessibilityEvents
audit
simulate
toggleDisplayTabbingOrder
enableAccessibility
resetAccessiblity
startListeningForLifecycleEvents
stopListeningForLifecycleEvents
startListeningForParentLifecycleEvents
stopListeningForParentLifecycleEvents
highlightAccessible
unhighlightAccessible
}
)
{
await
this
.
store
.
dispatch
(
reset
(
resetAccessiblity
supports
)
)
;
const
container
=
document
.
getElementById
(
"
content
"
)
;
const
mainFrame
=
MainFrame
(
{
fluentBundles
toolbox
getAccessibilityTreeRoot
startListeningForAccessibilityEvents
stopListeningForAccessibilityEvents
audit
simulate
enableAccessibility
resetAccessiblity
startListeningForLifecycleEvents
stopListeningForLifecycleEvents
startListeningForParentLifecycleEvents
stopListeningForParentLifecycleEvents
highlightAccessible
unhighlightAccessible
}
)
;
thunkOptions
.
options
.
toggleDisplayTabbingOrder
=
toggleDisplayTabbingOrder
;
const
provider
=
createElement
(
Provider
{
store
:
this
.
store
}
mainFrame
)
;
if
(
!
this
.
store
.
getState
(
)
.
ui
.
canBeEnabled
)
{
window
.
emit
(
EVENTS
.
INITIALIZED
)
;
}
else
{
window
.
once
(
EVENTS
.
PROPERTIES_UPDATED
)
.
then
(
(
)
=
>
{
window
.
emit
(
EVENTS
.
INITIALIZED
)
;
}
)
;
}
this
.
mainFrame
=
ReactDOM
.
render
(
provider
container
)
;
}
destroy
(
)
{
const
container
=
document
.
getElementById
(
"
content
"
)
;
ReactDOM
.
unmountComponentAtNode
(
container
)
;
}
async
selectAccessible
(
accessible
)
{
await
this
.
store
.
dispatch
(
select
(
accessible
)
)
;
window
.
emit
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_INSPECTED
)
;
}
async
highlightAccessible
(
accessible
)
{
await
this
.
store
.
dispatch
(
highlight
(
accessible
)
)
;
window
.
emit
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_HIGHLIGHTED
)
;
}
async
selectNodeAccessible
(
node
)
{
if
(
!
node
)
{
return
;
}
const
accessibilityFront
=
await
node
.
targetFront
.
getFront
(
"
accessibility
"
)
;
const
accessibleWalkerFront
=
await
accessibilityFront
.
getWalker
(
)
;
let
accessible
=
await
accessibleWalkerFront
.
getAccessibleFor
(
node
)
;
if
(
accessible
)
{
await
accessible
.
hydrate
(
)
;
}
if
(
!
accessible
|
|
accessible
.
indexInParent
<
0
)
{
const
{
nodes
:
children
}
=
await
node
.
walkerFront
.
children
(
node
)
;
for
(
const
child
of
children
)
{
if
(
child
.
nodeType
=
=
=
nodeConstants
.
TEXT_NODE
)
{
accessible
=
await
accessibleWalkerFront
.
getAccessibleFor
(
child
)
;
if
(
accessible
)
{
await
accessible
.
hydrate
(
)
;
if
(
accessible
.
indexInParent
>
=
0
)
{
break
;
}
}
}
}
}
if
(
!
accessible
|
|
accessible
.
indexInParent
<
0
)
{
let
parentNode
=
node
.
parentNode
(
)
;
while
(
parentNode
)
{
accessible
=
await
accessibleWalkerFront
.
getAccessibleFor
(
parentNode
)
;
if
(
accessible
)
{
await
accessible
.
hydrate
(
)
;
if
(
accessible
.
indexInParent
>
=
0
)
{
break
;
}
}
parentNode
=
parentNode
.
parentNode
(
)
;
}
}
if
(
!
accessible
)
{
console
.
warn
(
No
accessible
object
found
for
a
node
or
a
node
in
its
ancestry
:
{
node
.
actorID
}
)
;
return
;
}
await
this
.
store
.
dispatch
(
select
(
accessible
)
)
;
window
.
emit
(
EVENTS
.
NEW_ACCESSIBLE_FRONT_INSPECTED
)
;
}
onMessage
(
event
)
{
const
data
=
event
.
data
;
const
method
=
data
.
type
;
if
(
typeof
this
[
method
]
=
=
=
"
function
"
)
{
this
[
method
]
(
.
.
.
data
.
args
)
;
}
}
}
window
.
view
=
new
AccessibilityView
(
store
)
;
