"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
framework
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
TableWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
TableWidget
"
)
;
const
SPLIT_CONSOLE_PREF
=
"
devtools
.
toolbox
.
splitconsoleEnabled
"
;
const
STORAGE_PREF
=
"
devtools
.
storage
.
enabled
"
;
const
DUMPEMIT_PREF
=
"
devtools
.
dump
.
emit
"
;
const
DEBUGGERLOG_PREF
=
"
devtools
.
debugger
.
log
"
;
const
CACHES_ON_HTTP_PREF
=
"
dom
.
caches
.
testing
.
enabled
"
;
const
PATH
=
"
browser
/
devtools
/
client
/
storage
/
test
/
"
;
const
MAIN_DOMAIN
=
"
http
:
/
/
test1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN
=
"
http
:
/
/
sectest1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN_SECURED
=
"
https
:
/
/
sectest1
.
example
.
org
:
443
/
"
+
PATH
;
var
gToolbox
gPanelWindow
gWindow
gUI
;
Services
.
prefs
.
setBoolPref
(
STORAGE_PREF
true
)
;
Services
.
prefs
.
setBoolPref
(
CACHES_ON_HTTP_PREF
true
)
;
registerCleanupFunction
(
(
)
=
>
{
gToolbox
=
gPanelWindow
=
gWindow
=
gUI
=
null
;
Services
.
prefs
.
clearUserPref
(
STORAGE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
SPLIT_CONSOLE_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DUMPEMIT_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DEBUGGERLOG_PREF
)
;
Services
.
prefs
.
clearUserPref
(
CACHES_ON_HTTP_PREF
)
;
}
)
;
function
*
openTabAndSetupStorage
(
url
)
{
let
tab
=
yield
addTab
(
url
)
;
let
content
=
tab
.
linkedBrowser
.
contentWindow
;
gWindow
=
content
.
wrappedJSObject
;
yield
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
function
*
(
)
{
function
getAllWindows
(
baseWindow
)
{
let
windows
=
new
Set
(
)
;
let
_getAllWindows
=
function
(
win
)
{
windows
.
add
(
win
.
wrappedJSObject
)
;
for
(
let
i
=
0
;
i
<
win
.
length
;
i
+
+
)
{
_getAllWindows
(
win
[
i
]
)
;
}
}
;
_getAllWindows
(
baseWindow
)
;
return
windows
;
}
let
windows
=
getAllWindows
(
content
)
;
for
(
let
win
of
windows
)
{
let
readyState
=
win
.
document
.
readyState
;
info
(
Found
a
window
:
{
readyState
}
)
;
if
(
readyState
!
=
"
complete
"
)
{
yield
new
Promise
(
resolve
=
>
{
let
onLoad
=
(
)
=
>
{
win
.
removeEventListener
(
"
load
"
onLoad
)
;
resolve
(
)
;
}
;
win
.
addEventListener
(
"
load
"
onLoad
)
;
}
)
;
}
if
(
win
.
setup
)
{
yield
win
.
setup
(
)
;
}
}
}
)
;
return
yield
openStoragePanel
(
)
;
}
var
openStoragePanel
=
Task
.
async
(
function
*
(
cb
)
{
info
(
"
Opening
the
storage
inspector
"
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
storage
toolbox
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
storage
=
toolbox
.
getPanel
(
"
storage
"
)
;
if
(
storage
)
{
gPanelWindow
=
storage
.
panelWindow
;
gUI
=
storage
.
UI
;
gToolbox
=
toolbox
;
info
(
"
Toolbox
and
storage
already
open
"
)
;
if
(
cb
)
{
return
cb
(
storage
toolbox
)
;
}
return
{
toolbox
:
toolbox
storage
:
storage
}
;
}
}
info
(
"
Opening
the
toolbox
"
)
;
toolbox
=
yield
gDevTools
.
showToolbox
(
target
"
storage
"
)
;
storage
=
toolbox
.
getPanel
(
"
storage
"
)
;
gPanelWindow
=
storage
.
panelWindow
;
gUI
=
storage
.
UI
;
gToolbox
=
toolbox
;
gUI
.
animationsEnabled
=
false
;
info
(
"
Waiting
for
the
stores
to
update
"
)
;
yield
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
yield
waitForToolboxFrameFocus
(
toolbox
)
;
if
(
cb
)
{
return
cb
(
storage
toolbox
)
;
}
return
{
toolbox
:
toolbox
storage
:
storage
}
;
}
)
;
function
waitForToolboxFrameFocus
(
toolbox
)
{
info
(
"
Making
sure
that
the
toolbox
'
s
frame
is
focused
"
)
;
let
def
=
promise
.
defer
(
)
;
waitForFocus
(
def
.
resolve
toolbox
.
win
)
;
return
def
.
promise
;
}
function
forceCollections
(
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceShrinkingGC
(
)
;
}
function
*
finishTests
(
)
{
yield
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
function
*
(
)
{
function
getAllWindows
(
baseWindow
)
{
let
windows
=
new
Set
(
)
;
let
_getAllWindows
=
function
(
win
)
{
windows
.
add
(
win
.
wrappedJSObject
)
;
for
(
let
i
=
0
;
i
<
win
.
length
;
i
+
+
)
{
_getAllWindows
(
win
[
i
]
)
;
}
}
;
_getAllWindows
(
baseWindow
)
;
return
windows
;
}
let
windows
=
getAllWindows
(
content
)
;
for
(
let
win
of
windows
)
{
try
{
win
.
localStorage
.
clear
(
)
;
win
.
sessionStorage
.
clear
(
)
;
}
catch
(
ex
)
{
}
if
(
win
.
clear
)
{
yield
win
.
clear
(
)
;
}
}
}
)
;
Services
.
cookies
.
removeAll
(
)
;
forceCollections
(
)
;
finish
(
)
;
}
function
*
click
(
node
)
{
let
def
=
promise
.
defer
(
)
;
node
.
scrollIntoView
(
)
;
setTimeout
(
(
)
=
>
{
node
.
click
(
)
;
def
.
resolve
(
)
;
}
200
)
;
return
def
;
}
function
variablesViewExpandTo
(
options
)
{
let
root
=
options
.
rootVariable
;
let
expandTo
=
options
.
expandTo
.
split
(
"
.
"
)
;
let
lastDeferred
=
promise
.
defer
(
)
;
function
getNext
(
prop
)
{
let
name
=
expandTo
.
shift
(
)
;
let
newProp
=
prop
.
get
(
name
)
;
if
(
expandTo
.
length
>
0
)
{
ok
(
newProp
"
found
property
"
+
name
)
;
if
(
newProp
&
&
newProp
.
expand
)
{
newProp
.
expand
(
)
;
getNext
(
newProp
)
;
}
else
{
lastDeferred
.
reject
(
prop
)
;
}
}
else
if
(
newProp
)
{
lastDeferred
.
resolve
(
newProp
)
;
}
else
{
lastDeferred
.
reject
(
prop
)
;
}
}
if
(
root
&
&
root
.
expand
)
{
root
.
expand
(
)
;
getNext
(
root
)
;
}
else
{
lastDeferred
.
resolve
(
root
)
;
}
return
lastDeferred
.
promise
;
}
function
findVariableViewProperties
(
ruleArray
parsed
)
{
function
init
(
)
{
if
(
parsed
)
{
ruleArray
=
ruleArray
.
map
(
(
{
name
value
dontMatch
}
)
=
>
{
return
{
name
:
"
.
"
+
name
value
dontMatch
}
;
}
)
;
}
let
expandRules
=
[
]
;
let
rules
=
ruleArray
.
filter
(
rule
=
>
{
if
(
typeof
rule
.
name
=
=
"
string
"
&
&
rule
.
name
.
indexOf
(
"
.
"
)
>
-
1
)
{
expandRules
.
push
(
rule
)
;
return
false
;
}
return
true
;
}
)
;
let
outstanding
=
[
]
;
finder
(
rules
gUI
.
view
outstanding
)
;
let
lastStep
=
processExpandRules
.
bind
(
null
expandRules
)
;
let
returnResults
=
onAllRulesMatched
.
bind
(
null
ruleArray
)
;
return
promise
.
all
(
outstanding
)
.
then
(
lastStep
)
.
then
(
returnResults
)
;
}
function
onMatch
(
prop
rule
matched
)
{
if
(
matched
&
&
!
rule
.
matchedProp
)
{
rule
.
matchedProp
=
prop
;
}
}
function
finder
(
rules
view
promises
)
{
for
(
let
scope
of
view
)
{
for
(
let
[
prop
]
of
scope
)
{
for
(
let
rule
of
rules
)
{
let
matcher
=
matchVariablesViewProperty
(
prop
rule
)
;
promises
.
push
(
matcher
.
then
(
onMatch
.
bind
(
null
prop
rule
)
)
)
;
}
}
}
}
function
processExpandRules
(
rules
)
{
let
rule
=
rules
.
shift
(
)
;
if
(
!
rule
)
{
return
promise
.
resolve
(
null
)
;
}
let
deferred
=
promise
.
defer
(
)
;
let
expandOptions
=
{
rootVariable
:
gUI
.
view
.
getScopeAtIndex
(
parsed
?
1
:
0
)
expandTo
:
rule
.
name
}
;
variablesViewExpandTo
(
expandOptions
)
.
then
(
function
onSuccess
(
prop
)
{
let
name
=
rule
.
name
;
let
lastName
=
name
.
split
(
"
.
"
)
.
pop
(
)
;
rule
.
name
=
lastName
;
let
matched
=
matchVariablesViewProperty
(
prop
rule
)
;
return
matched
.
then
(
onMatch
.
bind
(
null
prop
rule
)
)
.
then
(
function
(
)
{
rule
.
name
=
name
;
}
)
;
}
function
onFailure
(
)
{
return
promise
.
resolve
(
null
)
;
}
)
.
then
(
processExpandRules
.
bind
(
null
rules
)
)
.
then
(
function
(
)
{
deferred
.
resolve
(
null
)
;
}
)
;
return
deferred
.
promise
;
}
function
onAllRulesMatched
(
rules
)
{
for
(
let
rule
of
rules
)
{
let
matched
=
rule
.
matchedProp
;
if
(
matched
&
&
!
rule
.
dontMatch
)
{
ok
(
true
"
rule
"
+
rule
.
name
+
"
matched
for
property
"
+
matched
.
name
)
;
}
else
if
(
matched
&
&
rule
.
dontMatch
)
{
ok
(
false
"
rule
"
+
rule
.
name
+
"
should
not
match
property
"
+
matched
.
name
)
;
}
else
{
ok
(
rule
.
dontMatch
"
rule
"
+
rule
.
name
+
"
did
not
match
any
property
"
)
;
}
}
return
rules
;
}
return
init
(
)
;
}
function
matchVariablesViewProperty
(
prop
rule
)
{
function
resolve
(
result
)
{
return
promise
.
resolve
(
result
)
;
}
if
(
!
prop
)
{
return
resolve
(
false
)
;
}
if
(
rule
.
name
)
{
let
match
=
rule
.
name
instanceof
RegExp
?
rule
.
name
.
test
(
prop
.
name
)
:
prop
.
name
=
=
rule
.
name
;
if
(
!
match
)
{
return
resolve
(
false
)
;
}
}
if
(
"
value
"
in
rule
)
{
let
displayValue
=
prop
.
displayValue
;
if
(
prop
.
displayValueClassName
=
=
"
token
-
string
"
)
{
displayValue
=
displayValue
.
substring
(
1
displayValue
.
length
-
1
)
;
}
let
match
=
rule
.
value
instanceof
RegExp
?
rule
.
value
.
test
(
displayValue
)
:
displayValue
=
=
rule
.
value
;
if
(
!
match
)
{
info
(
"
rule
"
+
rule
.
name
+
"
did
not
match
value
expected
'
"
+
rule
.
value
+
"
'
found
'
"
+
displayValue
+
"
'
"
)
;
return
resolve
(
false
)
;
}
}
return
resolve
(
true
)
;
}
function
*
selectTreeItem
(
ids
)
{
if
(
gUI
.
tree
.
isSelected
(
ids
)
)
{
return
;
}
let
updated
=
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
gUI
.
tree
.
selectedItem
=
ids
;
yield
updated
;
}
function
*
selectTableItem
(
id
)
{
let
selector
=
"
.
table
-
widget
-
cell
[
data
-
id
=
'
"
+
id
+
"
'
]
"
;
let
target
=
gPanelWindow
.
document
.
querySelector
(
selector
)
;
ok
(
target
"
table
item
found
with
ids
"
+
id
)
;
yield
click
(
target
)
;
yield
gUI
.
once
(
"
sidebar
-
updated
"
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
promise
.
defer
(
)
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
function
getRowValues
(
id
includeHidden
=
false
)
{
let
cells
=
getRowCells
(
id
includeHidden
)
;
let
values
=
{
}
;
for
(
let
name
in
cells
)
{
let
cell
=
cells
[
name
]
;
values
[
name
]
=
cell
.
value
;
}
return
values
;
}
function
getRowCells
(
id
includeHidden
=
false
)
{
let
doc
=
gPanelWindow
.
document
;
let
table
=
gUI
.
table
;
let
item
=
doc
.
querySelector
(
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
[
value
=
'
"
+
id
+
"
'
]
"
)
;
if
(
!
item
)
{
ok
(
false
"
Row
id
'
"
+
id
+
"
'
exists
"
)
;
}
let
index
=
table
.
columns
.
get
(
table
.
uniqueId
)
.
visibleCellNodes
.
indexOf
(
item
)
;
let
cells
=
{
}
;
for
(
let
[
name
column
]
of
[
.
.
.
table
.
columns
]
)
{
if
(
!
includeHidden
&
&
column
.
column
.
parentNode
.
hidden
)
{
continue
;
}
cells
[
name
]
=
column
.
visibleCellNodes
[
index
]
;
}
return
cells
;
}
function
getCellValue
(
id
column
)
{
let
row
=
getRowValues
(
id
true
)
;
return
row
[
column
]
;
}
function
*
editCell
(
id
column
newValue
validate
=
true
)
{
let
row
=
getRowCells
(
id
true
)
;
let
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
editableFieldsEngine
.
edit
(
row
[
column
]
)
;
yield
typeWithTerminator
(
newValue
"
VK_RETURN
"
validate
)
;
}
function
*
startCellEdit
(
id
column
selectText
=
true
)
{
let
row
=
getRowCells
(
id
true
)
;
let
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
let
cell
=
row
[
column
]
;
info
(
"
Selecting
row
"
+
id
)
;
gUI
.
table
.
selectedRow
=
id
;
info
(
"
Starting
cell
edit
(
"
+
id
+
"
"
+
column
+
"
)
"
)
;
editableFieldsEngine
.
edit
(
cell
)
;
if
(
!
selectText
)
{
let
textbox
=
gUI
.
table
.
_editableFieldsEngine
.
textbox
;
textbox
.
selectionEnd
=
textbox
.
selectionStart
;
}
}
function
checkCell
(
id
column
expected
)
{
is
(
getCellValue
(
id
column
)
expected
column
+
"
column
has
the
right
value
for
"
+
id
)
;
}
function
showColumn
(
id
state
)
{
let
columns
=
gUI
.
table
.
columns
;
let
column
=
columns
.
get
(
id
)
;
if
(
state
)
{
column
.
wrapper
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
column
.
wrapper
.
setAttribute
(
"
hidden
"
true
)
;
}
}
function
showAllColumns
(
state
)
{
let
columns
=
gUI
.
table
.
columns
;
for
(
let
[
id
]
of
columns
)
{
showColumn
(
id
state
)
;
}
}
function
*
typeWithTerminator
(
str
terminator
validate
=
true
)
{
let
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
let
textbox
=
editableFieldsEngine
.
textbox
;
let
colName
=
textbox
.
closest
(
"
.
table
-
widget
-
column
"
)
.
id
;
let
changeExpected
=
str
!
=
=
textbox
.
value
;
if
(
!
changeExpected
)
{
return
editableFieldsEngine
.
currentTarget
.
getAttribute
(
"
data
-
id
"
)
;
}
info
(
"
Typing
"
+
str
)
;
EventUtils
.
sendString
(
str
)
;
info
(
"
Pressing
"
+
terminator
)
;
EventUtils
.
synthesizeKey
(
terminator
{
}
)
;
if
(
validate
)
{
info
(
"
Validating
results
.
.
.
waiting
for
ROW_EDIT
event
.
"
)
;
let
uniqueId
=
yield
gUI
.
table
.
once
(
TableWidget
.
EVENTS
.
ROW_EDIT
)
;
checkCell
(
uniqueId
colName
str
)
;
return
uniqueId
;
}
return
yield
gUI
.
table
.
once
(
TableWidget
.
EVENTS
.
ROW_EDIT
)
;
}
function
getCurrentEditorValue
(
)
{
let
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
let
textbox
=
editableFieldsEngine
.
textbox
;
return
textbox
.
value
;
}
function
PressKeyXTimes
(
key
x
modifiers
=
{
}
)
{
for
(
let
i
=
0
;
i
<
x
;
i
+
+
)
{
EventUtils
.
synthesizeKey
(
key
modifiers
)
;
}
}
function
*
checkState
(
state
)
{
for
(
let
[
store
names
]
of
state
)
{
let
storeName
=
store
.
join
(
"
>
"
)
;
info
(
Selecting
tree
item
{
storeName
}
)
;
yield
selectTreeItem
(
store
)
;
let
items
=
gUI
.
table
.
items
;
is
(
items
.
size
names
.
length
There
is
correct
number
of
rows
in
{
storeName
}
)
;
for
(
let
name
of
names
)
{
ok
(
items
.
has
(
name
)
There
is
item
with
name
'
{
name
}
'
in
{
storeName
}
)
;
}
}
}
function
containsFocus
(
doc
container
)
{
let
elm
=
doc
.
activeElement
;
while
(
elm
)
{
if
(
elm
=
=
=
container
)
{
return
true
;
}
elm
=
elm
.
parentNode
;
}
return
false
;
}
var
focusSearchBoxUsingShortcut
=
Task
.
async
(
function
*
(
panelWin
callback
)
{
info
(
"
Focusing
search
box
"
)
;
let
searchBox
=
panelWin
.
document
.
getElementById
(
"
storage
-
searchbox
"
)
;
let
focused
=
once
(
searchBox
"
focus
"
)
;
panelWin
.
focus
(
)
;
let
strings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
storage
.
properties
"
)
;
synthesizeKeyShortcut
(
strings
.
GetStringFromName
(
"
storage
.
filter
.
key
"
)
)
;
yield
focused
;
if
(
callback
)
{
callback
(
)
;
}
}
)
;
