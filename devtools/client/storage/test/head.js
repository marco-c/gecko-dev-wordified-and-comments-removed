"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
TableWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
TableWidget
"
)
;
const
STORAGE_PREF
=
"
devtools
.
storage
.
enabled
"
;
const
DOM_CACHE
=
"
dom
.
caches
.
enabled
"
;
const
DUMPEMIT_PREF
=
"
devtools
.
dump
.
emit
"
;
const
DEBUGGERLOG_PREF
=
"
devtools
.
debugger
.
log
"
;
const
CACHES_ON_HTTP_PREF
=
"
dom
.
caches
.
testing
.
enabled
"
;
const
PATH
=
"
browser
/
devtools
/
client
/
storage
/
test
/
"
;
const
MAIN_DOMAIN
=
"
http
:
/
/
test1
.
example
.
org
/
"
+
PATH
;
const
MAIN_DOMAIN_WITH_PORT
=
"
http
:
/
/
test1
.
example
.
org
:
8000
/
"
+
PATH
;
const
ALT_DOMAIN
=
"
http
:
/
/
sectest1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN_SECURED
=
"
https
:
/
/
sectest1
.
example
.
org
:
443
/
"
+
PATH
;
const
SEPARATOR_GUID
=
"
{
9d414cc5
-
8319
-
0a04
-
0586
-
c0a6ae01670a
}
"
;
var
gToolbox
gPanelWindow
gUI
;
Services
.
prefs
.
setBoolPref
(
STORAGE_PREF
true
)
;
Services
.
prefs
.
setBoolPref
(
CACHES_ON_HTTP_PREF
true
)
;
registerCleanupFunction
(
(
)
=
>
{
gToolbox
=
gPanelWindow
=
gUI
=
null
;
Services
.
prefs
.
clearUserPref
(
CACHES_ON_HTTP_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DEBUGGERLOG_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DOM_CACHE
)
;
Services
.
prefs
.
clearUserPref
(
DUMPEMIT_PREF
)
;
Services
.
prefs
.
clearUserPref
(
STORAGE_PREF
)
;
}
)
;
async
function
openTab
(
url
options
=
{
}
)
{
const
tab
=
await
addTab
(
url
options
)
;
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
async
function
(
)
{
function
getAllWindows
(
baseWindow
)
{
const
windows
=
new
Set
(
)
;
const
_getAllWindows
=
function
(
win
)
{
windows
.
add
(
win
.
wrappedJSObject
)
;
for
(
let
i
=
0
;
i
<
win
.
length
;
i
+
+
)
{
_getAllWindows
(
win
[
i
]
)
;
}
}
;
_getAllWindows
(
baseWindow
)
;
return
windows
;
}
const
windows
=
getAllWindows
(
content
)
;
for
(
const
win
of
windows
)
{
const
readyState
=
win
.
document
.
readyState
;
info
(
Found
a
window
:
{
readyState
}
)
;
if
(
readyState
!
=
"
complete
"
)
{
await
new
Promise
(
resolve
=
>
{
const
onLoad
=
(
)
=
>
{
win
.
removeEventListener
(
"
load
"
onLoad
)
;
resolve
(
)
;
}
;
win
.
addEventListener
(
"
load
"
onLoad
)
;
}
)
;
}
if
(
win
.
setup
)
{
await
win
.
setup
(
)
;
}
}
}
)
;
return
tab
;
}
async
function
openTabAndSetupStorage
(
url
options
=
{
}
)
{
await
openTab
(
url
options
)
;
return
openStoragePanel
(
)
;
}
var
openStoragePanel
=
async
function
(
cb
)
{
info
(
"
Opening
the
storage
inspector
"
)
;
const
target
=
await
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
storage
toolbox
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
storage
=
toolbox
.
getPanel
(
"
storage
"
)
;
if
(
storage
)
{
gPanelWindow
=
storage
.
panelWindow
;
gUI
=
storage
.
UI
;
gToolbox
=
toolbox
;
info
(
"
Toolbox
and
storage
already
open
"
)
;
if
(
cb
)
{
return
cb
(
storage
toolbox
)
;
}
return
{
toolbox
:
toolbox
storage
:
storage
}
;
}
}
info
(
"
Opening
the
toolbox
"
)
;
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
storage
"
)
;
storage
=
toolbox
.
getPanel
(
"
storage
"
)
;
gPanelWindow
=
storage
.
panelWindow
;
gUI
=
storage
.
UI
;
gToolbox
=
toolbox
;
gUI
.
animationsEnabled
=
false
;
info
(
"
Waiting
for
the
stores
to
update
"
)
;
await
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
await
waitForToolboxFrameFocus
(
toolbox
)
;
if
(
cb
)
{
return
cb
(
storage
toolbox
)
;
}
return
{
toolbox
:
toolbox
storage
:
storage
}
;
}
;
function
waitForToolboxFrameFocus
(
toolbox
)
{
info
(
"
Making
sure
that
the
toolbox
'
s
frame
is
focused
"
)
;
return
new
Promise
(
resolve
=
>
{
waitForFocus
(
resolve
toolbox
.
win
)
;
}
)
;
}
function
forceCollections
(
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceShrinkingGC
(
)
;
}
async
function
finishTests
(
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
{
await
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
null
async
function
(
)
{
function
getAllWindows
(
baseWindow
)
{
const
windows
=
new
Set
(
)
;
const
_getAllWindows
=
function
(
win
)
{
windows
.
add
(
win
.
wrappedJSObject
)
;
for
(
let
i
=
0
;
i
<
win
.
length
;
i
+
+
)
{
_getAllWindows
(
win
[
i
]
)
;
}
}
;
_getAllWindows
(
baseWindow
)
;
return
windows
;
}
const
windows
=
getAllWindows
(
content
)
;
for
(
const
win
of
windows
)
{
try
{
win
.
localStorage
.
clear
(
)
;
win
.
sessionStorage
.
clear
(
)
;
}
catch
(
ex
)
{
}
if
(
win
.
clear
)
{
await
win
.
clear
(
)
;
}
}
}
)
;
await
closeTabAndToolbox
(
gBrowser
.
selectedTab
)
;
}
Services
.
cookies
.
removeAll
(
)
;
forceCollections
(
)
;
finish
(
)
;
}
function
click
(
node
)
{
node
.
scrollIntoView
(
)
;
return
new
Promise
(
resolve
=
>
{
setTimeout
(
(
)
=
>
{
node
.
click
(
)
;
resolve
(
)
;
}
200
)
;
}
)
;
}
function
variablesViewExpandTo
(
options
)
{
const
root
=
options
.
rootVariable
;
const
expandTo
=
options
.
expandTo
.
split
(
"
.
"
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
getNext
(
prop
)
{
const
name
=
expandTo
.
shift
(
)
;
const
newProp
=
prop
.
get
(
name
)
;
if
(
expandTo
.
length
>
0
)
{
ok
(
newProp
"
found
property
"
+
name
)
;
if
(
newProp
&
&
newProp
.
expand
)
{
newProp
.
expand
(
)
;
getNext
(
newProp
)
;
}
else
{
reject
(
prop
)
;
}
}
else
if
(
newProp
)
{
resolve
(
newProp
)
;
}
else
{
reject
(
prop
)
;
}
}
if
(
root
&
&
root
.
expand
)
{
root
.
expand
(
)
;
getNext
(
root
)
;
}
else
{
resolve
(
root
)
;
}
}
)
;
}
function
findVariableViewProperties
(
ruleArray
parsed
)
{
function
init
(
)
{
if
(
parsed
)
{
ruleArray
=
ruleArray
.
map
(
(
{
name
value
dontMatch
}
)
=
>
{
return
{
name
:
"
.
"
+
name
value
dontMatch
}
;
}
)
;
}
const
expandRules
=
[
]
;
const
rules
=
ruleArray
.
filter
(
rule
=
>
{
if
(
typeof
rule
.
name
=
=
"
string
"
&
&
rule
.
name
.
indexOf
(
"
.
"
)
>
-
1
)
{
expandRules
.
push
(
rule
)
;
return
false
;
}
return
true
;
}
)
;
const
outstanding
=
[
]
;
finder
(
rules
gUI
.
view
outstanding
)
;
const
lastStep
=
processExpandRules
.
bind
(
null
expandRules
)
;
const
returnResults
=
onAllRulesMatched
.
bind
(
null
ruleArray
)
;
return
promise
.
all
(
outstanding
)
.
then
(
lastStep
)
.
then
(
returnResults
)
;
}
function
onMatch
(
prop
rule
matched
)
{
if
(
matched
&
&
!
rule
.
matchedProp
)
{
rule
.
matchedProp
=
prop
;
}
}
function
finder
(
rules
view
promises
)
{
for
(
const
scope
of
view
)
{
for
(
const
[
prop
]
of
scope
)
{
for
(
const
rule
of
rules
)
{
const
matcher
=
matchVariablesViewProperty
(
prop
rule
)
;
promises
.
push
(
matcher
.
then
(
onMatch
.
bind
(
null
prop
rule
)
)
)
;
}
}
}
}
function
processExpandRules
(
rules
)
{
return
new
Promise
(
resolve
=
>
{
const
rule
=
rules
.
shift
(
)
;
if
(
!
rule
)
{
resolve
(
null
)
;
}
const
expandOptions
=
{
rootVariable
:
gUI
.
view
.
getScopeAtIndex
(
parsed
?
1
:
0
)
expandTo
:
rule
.
name
}
;
variablesViewExpandTo
(
expandOptions
)
.
then
(
function
onSuccess
(
prop
)
{
const
name
=
rule
.
name
;
const
lastName
=
name
.
split
(
"
.
"
)
.
pop
(
)
;
rule
.
name
=
lastName
;
const
matched
=
matchVariablesViewProperty
(
prop
rule
)
;
return
matched
.
then
(
onMatch
.
bind
(
null
prop
rule
)
)
.
then
(
function
(
)
{
rule
.
name
=
name
;
}
)
;
}
function
onFailure
(
)
{
resolve
(
null
)
;
}
)
.
then
(
processExpandRules
.
bind
(
null
rules
)
)
.
then
(
function
(
)
{
resolve
(
null
)
;
}
)
;
}
)
;
}
function
onAllRulesMatched
(
rules
)
{
for
(
const
rule
of
rules
)
{
const
matched
=
rule
.
matchedProp
;
if
(
matched
&
&
!
rule
.
dontMatch
)
{
ok
(
true
"
rule
"
+
rule
.
name
+
"
matched
for
property
"
+
matched
.
name
)
;
}
else
if
(
matched
&
&
rule
.
dontMatch
)
{
ok
(
false
"
rule
"
+
rule
.
name
+
"
should
not
match
property
"
+
matched
.
name
)
;
}
else
{
ok
(
rule
.
dontMatch
"
rule
"
+
rule
.
name
+
"
did
not
match
any
property
"
)
;
}
}
return
rules
;
}
return
init
(
)
;
}
function
matchVariablesViewProperty
(
prop
rule
)
{
function
resolve
(
result
)
{
return
promise
.
resolve
(
result
)
;
}
if
(
!
prop
)
{
return
resolve
(
false
)
;
}
if
(
rule
.
name
)
{
const
match
=
rule
.
name
instanceof
RegExp
?
rule
.
name
.
test
(
prop
.
name
)
:
prop
.
name
=
=
rule
.
name
;
if
(
!
match
)
{
return
resolve
(
false
)
;
}
}
if
(
"
value
"
in
rule
)
{
let
displayValue
=
prop
.
displayValue
;
if
(
prop
.
displayValueClassName
=
=
"
token
-
string
"
)
{
displayValue
=
displayValue
.
substring
(
1
displayValue
.
length
-
1
)
;
}
const
match
=
rule
.
value
instanceof
RegExp
?
rule
.
value
.
test
(
displayValue
)
:
displayValue
=
=
rule
.
value
;
if
(
!
match
)
{
info
(
"
rule
"
+
rule
.
name
+
"
did
not
match
value
expected
'
"
+
rule
.
value
+
"
'
found
'
"
+
displayValue
+
"
'
"
)
;
return
resolve
(
false
)
;
}
}
return
resolve
(
true
)
;
}
async
function
selectTreeItem
(
ids
)
{
if
(
gUI
.
tree
.
isSelected
(
ids
)
)
{
info
(
"
{
ids
}
"
is
already
selected
returning
.
)
;
return
;
}
if
(
!
gUI
.
tree
.
exists
(
ids
)
)
{
info
(
"
{
ids
}
"
does
not
exist
returning
.
)
;
return
;
}
info
(
Selecting
"
{
ids
}
"
.
)
;
const
updated
=
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
gUI
.
tree
.
selectedItem
=
ids
;
await
updated
;
}
async
function
selectTableItem
(
id
)
{
const
table
=
gUI
.
table
;
const
selector
=
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
[
value
=
'
"
+
id
+
"
'
]
"
;
const
target
=
gPanelWindow
.
document
.
querySelector
(
selector
)
;
ok
(
target
row
found
with
id
"
{
id
}
"
)
;
if
(
!
target
)
{
showAvailableIds
(
)
;
}
const
updated
=
gUI
.
once
(
"
sidebar
-
updated
"
)
;
info
(
selecting
row
"
{
id
}
"
)
;
await
click
(
target
)
;
await
updated
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
return
new
Promise
(
resolve
=
>
{
for
(
const
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
resolve
(
.
.
.
aArgs
)
;
}
useCapture
)
;
break
;
}
}
}
)
;
}
function
getRowValues
(
id
includeHidden
=
false
)
{
const
cells
=
getRowCells
(
id
includeHidden
)
;
const
values
=
{
}
;
for
(
const
name
in
cells
)
{
const
cell
=
cells
[
name
]
;
values
[
name
]
=
cell
.
value
;
}
return
values
;
}
function
getRowCells
(
id
includeHidden
=
false
)
{
const
doc
=
gPanelWindow
.
document
;
const
table
=
gUI
.
table
;
const
item
=
doc
.
querySelector
(
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
[
value
=
'
"
+
id
+
"
'
]
"
)
;
if
(
!
item
)
{
ok
(
false
The
row
id
'
{
id
}
'
that
was
passed
to
getRowCells
(
)
does
not
+
exist
.
{
getAvailableIds
(
)
}
)
;
}
const
index
=
table
.
columns
.
get
(
table
.
uniqueId
)
.
cellNodes
.
indexOf
(
item
)
;
const
cells
=
{
}
;
for
(
const
[
name
column
]
of
[
.
.
.
table
.
columns
]
)
{
if
(
!
includeHidden
&
&
column
.
column
.
parentNode
.
hidden
)
{
continue
;
}
cells
[
name
]
=
column
.
cellNodes
[
index
]
;
}
return
cells
;
}
function
isTableEmpty
(
)
{
const
doc
=
gPanelWindow
.
document
;
const
table
=
gUI
.
table
;
const
cells
=
doc
.
querySelectorAll
(
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
"
)
;
return
cells
.
length
=
=
=
0
;
}
function
getAvailableIds
(
)
{
const
doc
=
gPanelWindow
.
document
;
const
table
=
gUI
.
table
;
let
out
=
"
Available
ids
:
\
n
"
;
const
cells
=
doc
.
querySelectorAll
(
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
"
)
;
for
(
const
cell
of
cells
)
{
out
+
=
-
{
cell
.
getAttribute
(
"
value
"
)
}
\
n
;
}
return
out
;
}
function
showAvailableIds
(
)
{
info
(
getAvailableIds
(
)
)
;
}
function
getCellValue
(
id
column
)
{
const
row
=
getRowValues
(
id
true
)
;
if
(
typeof
row
[
column
]
=
=
=
"
undefined
"
)
{
let
out
=
"
"
;
for
(
const
key
in
row
)
{
const
value
=
row
[
key
]
;
out
+
=
-
{
key
}
=
{
value
}
\
n
;
}
ok
(
false
The
column
name
'
{
column
}
'
that
was
passed
to
+
getCellValue
(
)
does
not
exist
.
Current
column
names
and
row
+
values
are
:
\
n
{
out
}
)
;
}
return
row
[
column
]
;
}
async
function
editCell
(
id
column
newValue
validate
=
true
)
{
const
row
=
getRowCells
(
id
true
)
;
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
editableFieldsEngine
.
edit
(
row
[
column
]
)
;
await
typeWithTerminator
(
newValue
"
KEY_Enter
"
validate
)
;
}
function
startCellEdit
(
id
column
selectText
=
true
)
{
const
row
=
getRowCells
(
id
true
)
;
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
const
cell
=
row
[
column
]
;
info
(
"
Selecting
row
"
+
id
)
;
gUI
.
table
.
selectedRow
=
id
;
info
(
"
Starting
cell
edit
(
"
+
id
+
"
"
+
column
+
"
)
"
)
;
editableFieldsEngine
.
edit
(
cell
)
;
if
(
!
selectText
)
{
const
textbox
=
gUI
.
table
.
_editableFieldsEngine
.
textbox
;
textbox
.
selectionEnd
=
textbox
.
selectionStart
;
}
}
function
checkCell
(
id
column
expected
)
{
is
(
getCellValue
(
id
column
)
expected
column
+
"
column
has
the
right
value
for
"
+
id
)
;
}
function
showColumn
(
id
state
)
{
const
columns
=
gUI
.
table
.
columns
;
const
column
=
columns
.
get
(
id
)
;
if
(
state
)
{
column
.
wrapper
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
column
.
wrapper
.
setAttribute
(
"
hidden
"
true
)
;
}
}
function
clickColumnHeader
(
id
)
{
const
columns
=
gUI
.
table
.
columns
;
const
column
=
columns
.
get
(
id
)
;
const
header
=
column
.
header
;
header
.
click
(
)
;
}
function
showAllColumns
(
state
)
{
const
columns
=
gUI
.
table
.
columns
;
for
(
const
[
id
]
of
columns
)
{
showColumn
(
id
state
)
;
}
}
async
function
typeWithTerminator
(
str
terminator
validate
=
true
)
{
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
const
textbox
=
editableFieldsEngine
.
textbox
;
const
colName
=
textbox
.
closest
(
"
.
table
-
widget
-
column
"
)
.
id
;
const
changeExpected
=
str
!
=
=
textbox
.
value
;
if
(
!
changeExpected
)
{
return
editableFieldsEngine
.
currentTarget
.
getAttribute
(
"
data
-
id
"
)
;
}
info
(
"
Typing
"
+
str
)
;
EventUtils
.
sendString
(
str
)
;
info
(
"
Pressing
"
+
terminator
)
;
EventUtils
.
synthesizeKey
(
terminator
)
;
if
(
validate
)
{
info
(
"
Validating
results
.
.
.
waiting
for
ROW_EDIT
event
.
"
)
;
const
uniqueId
=
await
gUI
.
table
.
once
(
TableWidget
.
EVENTS
.
ROW_EDIT
)
;
checkCell
(
uniqueId
colName
str
)
;
return
uniqueId
;
}
return
gUI
.
table
.
once
(
TableWidget
.
EVENTS
.
ROW_EDIT
)
;
}
function
getCurrentEditorValue
(
)
{
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
const
textbox
=
editableFieldsEngine
.
textbox
;
return
textbox
.
value
;
}
function
PressKeyXTimes
(
key
x
modifiers
=
{
}
)
{
for
(
let
i
=
0
;
i
<
x
;
i
+
+
)
{
EventUtils
.
synthesizeKey
(
key
modifiers
)
;
}
}
async
function
checkState
(
state
)
{
for
(
const
[
store
names
]
of
state
)
{
const
storeName
=
store
.
join
(
"
>
"
)
;
info
(
Selecting
tree
item
{
storeName
}
)
;
await
selectTreeItem
(
store
)
;
const
items
=
gUI
.
table
.
items
;
is
(
items
.
size
names
.
length
There
is
correct
number
of
rows
in
{
storeName
}
)
;
if
(
names
.
length
=
=
=
0
)
{
showAvailableIds
(
)
;
}
for
(
const
name
of
names
)
{
ok
(
items
.
has
(
name
)
There
is
item
with
name
'
{
name
}
'
in
{
storeName
}
)
;
if
(
!
items
.
has
(
name
)
)
{
showAvailableIds
(
)
;
}
}
}
}
function
containsFocus
(
doc
container
)
{
let
elm
=
doc
.
activeElement
;
while
(
elm
)
{
if
(
elm
=
=
=
container
)
{
return
true
;
}
elm
=
elm
.
parentNode
;
}
return
false
;
}
var
focusSearchBoxUsingShortcut
=
async
function
(
panelWin
callback
)
{
info
(
"
Focusing
search
box
"
)
;
const
searchBox
=
panelWin
.
document
.
getElementById
(
"
storage
-
searchbox
"
)
;
const
focused
=
once
(
searchBox
"
focus
"
)
;
panelWin
.
focus
(
)
;
const
strings
=
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
storage
.
properties
"
)
;
synthesizeKeyShortcut
(
strings
.
GetStringFromName
(
"
storage
.
filter
.
key
"
)
)
;
await
focused
;
if
(
callback
)
{
callback
(
)
;
}
}
;
function
getCookieId
(
name
domain
path
)
{
return
{
name
}
{
SEPARATOR_GUID
}
{
domain
}
{
SEPARATOR_GUID
}
{
path
}
;
}
function
setPermission
(
url
permission
)
{
const
nsIPermissionManager
=
Ci
.
nsIPermissionManager
;
const
uri
=
Services
.
io
.
newURI
(
url
)
;
const
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipal
(
uri
{
}
)
;
Cc
[
"
mozilla
.
org
/
permissionmanager
;
1
"
]
.
getService
(
nsIPermissionManager
)
.
addFromPrincipal
(
principal
permission
nsIPermissionManager
.
ALLOW_ACTION
)
;
}
function
toggleSidebar
(
)
{
gUI
.
sidebarToggleBtn
.
click
(
)
;
}
function
sidebarToggleVisible
(
)
{
return
!
gUI
.
sidebarToggleBtn
.
hidden
;
}
function
sidebarParseTreeVisible
(
state
)
{
if
(
state
)
{
ok
(
gUI
.
view
.
_currHierarchy
.
size
>
2
"
Parse
tree
should
be
visible
.
"
)
;
}
else
{
ok
(
gUI
.
view
.
_currHierarchy
.
size
<
=
2
"
Parse
tree
should
not
be
visible
.
"
)
;
}
}
async
function
performAdd
(
store
)
{
const
storeName
=
store
.
join
(
"
>
"
)
;
const
toolbar
=
gPanelWindow
.
document
.
getElementById
(
"
storage
-
toolbar
"
)
;
const
type
=
store
[
0
]
;
await
selectTreeItem
(
store
)
;
const
menuAdd
=
toolbar
.
querySelector
(
"
#
add
-
button
"
)
;
if
(
menuAdd
.
hidden
)
{
is
(
menuAdd
.
hidden
false
performAdd
called
for
{
storeName
}
but
it
is
not
supported
)
;
return
;
}
const
eventEdit
=
gUI
.
table
.
once
(
"
row
-
edit
"
)
;
const
eventWait
=
gUI
.
once
(
"
store
-
objects
-
edit
"
)
;
menuAdd
.
click
(
)
;
const
rowId
=
await
eventEdit
;
await
eventWait
;
const
key
=
type
=
=
=
"
cookies
"
?
"
uniqueKey
"
:
"
name
"
;
const
value
=
getCellValue
(
rowId
key
)
;
is
(
rowId
value
Row
'
{
rowId
}
'
was
successfully
added
.
)
;
}
function
checkCellLength
(
len
)
{
const
cells
=
gPanelWindow
.
document
.
querySelectorAll
(
"
#
name
.
table
-
widget
-
cell
"
)
;
const
msg
=
Table
should
initially
display
{
len
}
items
;
is
(
cells
.
length
len
msg
)
;
}
async
function
scroll
(
)
{
const
=
id
=
>
gPanelWindow
.
document
.
querySelector
(
id
)
;
const
table
=
(
"
#
storage
-
table
.
table
-
widget
-
body
"
)
;
const
cell
=
(
"
#
name
.
table
-
widget
-
cell
"
)
;
const
cellHeight
=
cell
.
getBoundingClientRect
(
)
.
height
;
const
onStoresUpdate
=
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
table
.
scrollTop
+
=
cellHeight
*
50
;
await
onStoresUpdate
;
}
