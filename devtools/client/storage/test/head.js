"
use
strict
"
;
registerCleanupFunction
(
async
(
)
=
>
{
Services
.
cookies
.
removeAll
(
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
const
browser
=
gBrowser
.
selectedBrowser
;
const
contexts
=
browser
.
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
;
for
(
const
context
of
contexts
)
{
await
SpecialPowers
.
spawn
(
context
[
]
async
(
)
=
>
{
const
win
=
content
.
wrappedJSObject
;
try
{
win
.
localStorage
.
clear
(
)
;
win
.
sessionStorage
.
clear
(
)
;
}
catch
(
ex
)
{
}
if
(
win
.
clear
)
{
await
Promise
.
race
(
[
new
Promise
(
r
=
>
win
.
setTimeout
(
r
10000
)
)
win
.
clear
(
)
]
)
;
}
}
)
;
}
await
closeTabAndToolbox
(
gBrowser
.
selectedTab
)
;
}
forceCollections
(
)
;
}
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
TableWidget
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
TableWidget
.
js
"
)
;
const
{
LocalTabCommandsFactory
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
local
-
tab
-
commands
-
factory
.
js
"
)
;
const
STORAGE_PREF
=
"
devtools
.
storage
.
enabled
"
;
const
DUMPEMIT_PREF
=
"
devtools
.
dump
.
emit
"
;
const
DEBUGGERLOG_PREF
=
"
devtools
.
debugger
.
log
"
;
const
CACHES_ON_HTTP_PREF
=
"
dom
.
caches
.
testing
.
enabled
"
;
const
PATH
=
"
browser
/
devtools
/
client
/
storage
/
test
/
"
;
const
MAIN_DOMAIN
=
"
http
:
/
/
test1
.
example
.
org
/
"
+
PATH
;
const
MAIN_DOMAIN_SECURED
=
"
https
:
/
/
test1
.
example
.
org
/
"
+
PATH
;
const
MAIN_DOMAIN_WITH_PORT
=
"
http
:
/
/
test1
.
example
.
org
:
8000
/
"
+
PATH
;
const
ALT_DOMAIN
=
"
http
:
/
/
sectest1
.
example
.
org
/
"
+
PATH
;
const
ALT_DOMAIN_SECURED
=
"
https
:
/
/
sectest1
.
example
.
org
:
443
/
"
+
PATH
;
const
SEPARATOR_GUID
=
"
{
9d414cc5
-
8319
-
0a04
-
0586
-
c0a6ae01670a
}
"
;
var
gToolbox
gPanelWindow
gUI
;
Services
.
prefs
.
setBoolPref
(
STORAGE_PREF
true
)
;
Services
.
prefs
.
setBoolPref
(
CACHES_ON_HTTP_PREF
true
)
;
registerCleanupFunction
(
(
)
=
>
{
gToolbox
=
gPanelWindow
=
gUI
=
null
;
Services
.
prefs
.
clearUserPref
(
CACHES_ON_HTTP_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DEBUGGERLOG_PREF
)
;
Services
.
prefs
.
clearUserPref
(
DUMPEMIT_PREF
)
;
Services
.
prefs
.
clearUserPref
(
STORAGE_PREF
)
;
}
)
;
async
function
openTab
(
url
options
=
{
}
)
{
const
tab
=
await
addTab
(
url
options
)
;
const
browser
=
gBrowser
.
selectedBrowser
;
const
contexts
=
browser
.
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
;
for
(
const
context
of
contexts
)
{
await
SpecialPowers
.
spawn
(
context
[
]
async
(
)
=
>
{
const
win
=
content
.
wrappedJSObject
;
const
readyState
=
win
.
document
.
readyState
;
info
(
Found
a
window
:
{
readyState
}
)
;
if
(
readyState
!
=
"
complete
"
)
{
await
new
Promise
(
resolve
=
>
{
const
onLoad
=
(
)
=
>
{
win
.
removeEventListener
(
"
load
"
onLoad
)
;
resolve
(
)
;
}
;
win
.
addEventListener
(
"
load
"
onLoad
)
;
}
)
;
}
if
(
win
.
setup
)
{
await
win
.
setup
(
)
;
}
}
)
;
}
return
tab
;
}
async
function
openTabAndSetupStorage
(
url
options
=
{
}
)
{
await
openTab
(
url
options
)
;
return
openStoragePanel
(
)
;
}
var
openStoragePanelForAddon
=
async
function
(
addonId
)
{
const
toolbox
=
await
gDevTools
.
showToolboxForWebExtension
(
addonId
{
toolId
:
"
storage
"
}
)
;
info
(
"
Making
sure
that
the
toolbox
'
s
frame
is
focused
"
)
;
await
SimpleTest
.
promiseFocus
(
toolbox
.
win
)
;
const
storage
=
_setupStoragePanelForTest
(
toolbox
)
;
return
{
toolbox
storage
}
;
}
;
var
openStoragePanel
=
async
function
(
{
tab
hostType
}
=
{
}
)
{
const
toolbox
=
await
openToolboxForTab
(
tab
|
|
gBrowser
.
selectedTab
"
storage
"
hostType
)
;
const
storage
=
_setupStoragePanelForTest
(
toolbox
)
;
return
{
toolbox
storage
}
;
}
;
function
_setupStoragePanelForTest
(
toolbox
)
{
const
storage
=
toolbox
.
getPanel
(
"
storage
"
)
;
gPanelWindow
=
storage
.
panelWindow
;
gUI
=
storage
.
UI
;
gToolbox
=
toolbox
;
gUI
.
animationsEnabled
=
false
;
return
storage
;
}
function
forceCollections
(
)
{
Cu
.
forceGC
(
)
;
Cu
.
forceCC
(
)
;
Cu
.
forceShrinkingGC
(
)
;
}
function
click
(
node
)
{
node
.
scrollIntoView
(
)
;
return
new
Promise
(
resolve
=
>
{
setTimeout
(
(
)
=
>
{
node
.
click
(
)
;
resolve
(
)
;
}
200
)
;
}
)
;
}
function
variablesViewExpandTo
(
options
)
{
const
root
=
options
.
rootVariable
;
const
expandTo
=
options
.
expandTo
.
split
(
"
.
"
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
function
getNext
(
prop
)
{
const
name
=
expandTo
.
shift
(
)
;
const
newProp
=
prop
.
get
(
name
)
;
if
(
expandTo
.
length
)
{
ok
(
newProp
"
found
property
"
+
name
)
;
if
(
newProp
&
&
newProp
.
expand
)
{
newProp
.
expand
(
)
;
getNext
(
newProp
)
;
}
else
{
reject
(
prop
)
;
}
}
else
if
(
newProp
)
{
resolve
(
newProp
)
;
}
else
{
reject
(
prop
)
;
}
}
if
(
root
&
&
root
.
expand
)
{
root
.
expand
(
)
;
getNext
(
root
)
;
}
else
{
resolve
(
root
)
;
}
}
)
;
}
function
findVariableViewProperties
(
ruleArray
parsed
)
{
function
init
(
)
{
if
(
parsed
)
{
ruleArray
=
ruleArray
.
map
(
(
{
name
value
dontMatch
}
)
=
>
{
return
{
name
:
"
.
"
+
name
value
dontMatch
}
;
}
)
;
}
const
expandRules
=
[
]
;
const
rules
=
ruleArray
.
filter
(
rule
=
>
{
if
(
typeof
rule
.
name
=
=
"
string
"
&
&
rule
.
name
.
indexOf
(
"
.
"
)
>
-
1
)
{
expandRules
.
push
(
rule
)
;
return
false
;
}
return
true
;
}
)
;
const
outstanding
=
[
]
;
finder
(
rules
gUI
.
view
outstanding
)
;
const
lastStep
=
processExpandRules
.
bind
(
null
expandRules
)
;
const
returnResults
=
onAllRulesMatched
.
bind
(
null
ruleArray
)
;
return
Promise
.
all
(
outstanding
)
.
then
(
lastStep
)
.
then
(
returnResults
)
;
}
function
onMatch
(
prop
rule
matched
)
{
if
(
matched
&
&
!
rule
.
matchedProp
)
{
rule
.
matchedProp
=
prop
;
}
}
function
finder
(
rules
view
promises
)
{
for
(
const
scope
of
view
)
{
for
(
const
[
prop
]
of
scope
)
{
for
(
const
rule
of
rules
)
{
const
matcher
=
matchVariablesViewProperty
(
prop
rule
)
;
promises
.
push
(
matcher
.
then
(
onMatch
.
bind
(
null
prop
rule
)
)
)
;
}
}
}
}
function
processExpandRules
(
rules
)
{
return
new
Promise
(
resolve
=
>
{
const
rule
=
rules
.
shift
(
)
;
if
(
!
rule
)
{
resolve
(
null
)
;
}
const
expandOptions
=
{
rootVariable
:
gUI
.
view
.
getScopeAtIndex
(
parsed
?
1
:
0
)
expandTo
:
rule
.
name
}
;
variablesViewExpandTo
(
expandOptions
)
.
then
(
function
onSuccess
(
prop
)
{
const
name
=
rule
.
name
;
const
lastName
=
name
.
split
(
"
.
"
)
.
pop
(
)
;
rule
.
name
=
lastName
;
const
matched
=
matchVariablesViewProperty
(
prop
rule
)
;
return
matched
.
then
(
onMatch
.
bind
(
null
prop
rule
)
)
.
then
(
function
(
)
{
rule
.
name
=
name
;
}
)
;
}
function
onFailure
(
)
{
resolve
(
null
)
;
}
)
.
then
(
processExpandRules
.
bind
(
null
rules
)
)
.
then
(
function
(
)
{
resolve
(
null
)
;
}
)
;
}
)
;
}
function
onAllRulesMatched
(
rules
)
{
for
(
const
rule
of
rules
)
{
const
matched
=
rule
.
matchedProp
;
if
(
matched
&
&
!
rule
.
dontMatch
)
{
ok
(
true
"
rule
"
+
rule
.
name
+
"
matched
for
property
"
+
matched
.
name
)
;
}
else
if
(
matched
&
&
rule
.
dontMatch
)
{
ok
(
false
"
rule
"
+
rule
.
name
+
"
should
not
match
property
"
+
matched
.
name
)
;
}
else
{
ok
(
rule
.
dontMatch
"
rule
"
+
rule
.
name
+
"
did
not
match
any
property
"
)
;
}
}
return
rules
;
}
return
init
(
)
;
}
function
matchVariablesViewProperty
(
prop
rule
)
{
function
resolve
(
result
)
{
return
Promise
.
resolve
(
result
)
;
}
if
(
!
prop
)
{
return
resolve
(
false
)
;
}
if
(
typeof
rule
.
name
=
=
"
string
"
)
{
const
match
=
rule
.
name
instanceof
RegExp
?
rule
.
name
.
test
(
prop
.
name
)
:
prop
.
name
=
=
rule
.
name
;
if
(
!
match
)
{
return
resolve
(
false
)
;
}
}
if
(
"
value
"
in
rule
)
{
let
displayValue
=
prop
.
displayValue
;
if
(
prop
.
displayValueClassName
=
=
"
token
-
string
"
)
{
displayValue
=
displayValue
.
substring
(
1
displayValue
.
length
-
1
)
;
}
const
match
=
rule
.
value
instanceof
RegExp
?
rule
.
value
.
test
(
displayValue
)
:
displayValue
=
=
rule
.
value
;
if
(
!
match
)
{
info
(
"
rule
"
+
rule
.
name
+
"
did
not
match
value
expected
'
"
+
rule
.
value
+
"
'
found
'
"
+
displayValue
+
"
'
"
)
;
return
resolve
(
false
)
;
}
}
return
resolve
(
true
)
;
}
async
function
selectTreeItem
(
ids
)
{
if
(
gUI
.
tree
.
isSelected
(
ids
)
)
{
info
(
"
{
ids
}
"
is
already
selected
returning
.
)
;
return
;
}
if
(
!
gUI
.
tree
.
exists
(
ids
)
)
{
info
(
"
{
ids
}
"
does
not
exist
returning
.
)
;
return
;
}
info
(
Selecting
"
{
ids
}
"
.
)
;
if
(
ids
.
length
>
1
)
{
const
updated
=
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
gUI
.
tree
.
selectedItem
=
ids
;
await
updated
;
}
else
{
gUI
.
tree
.
selectedItem
=
ids
;
}
}
async
function
selectTableItem
(
id
)
{
const
table
=
gUI
.
table
;
const
selector
=
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
[
value
=
'
"
+
id
+
"
'
]
"
;
const
target
=
gPanelWindow
.
document
.
querySelector
(
selector
)
;
ok
(
target
row
found
with
id
"
{
id
}
"
)
;
if
(
!
target
)
{
showAvailableIds
(
)
;
}
const
updated
=
gUI
.
once
(
"
sidebar
-
updated
"
)
;
info
(
selecting
row
"
{
id
}
"
)
;
await
click
(
target
)
;
await
updated
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
return
new
Promise
(
resolve
=
>
{
for
(
const
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
add
in
target
&
&
remove
in
target
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
resolve
(
.
.
.
aArgs
)
;
}
useCapture
)
;
break
;
}
}
}
)
;
}
function
getRowValues
(
id
includeHidden
=
false
)
{
const
cells
=
getRowCells
(
id
includeHidden
)
;
const
values
=
{
}
;
for
(
const
name
in
cells
)
{
const
cell
=
cells
[
name
]
;
values
[
name
]
=
cell
.
value
;
}
return
values
;
}
function
getRowItem
(
id
)
{
const
doc
=
gPanelWindow
.
document
;
const
table
=
gUI
.
table
;
return
doc
.
querySelector
(
.
table
-
widget
-
column
#
{
table
.
uniqueId
}
.
table
-
widget
-
cell
[
value
=
'
{
id
}
'
]
)
;
}
function
getRowCells
(
id
includeHidden
=
false
)
{
const
table
=
gUI
.
table
;
const
item
=
getRowItem
(
id
)
;
if
(
!
item
)
{
ok
(
false
The
row
id
'
{
id
}
'
that
was
passed
to
getRowCells
(
)
does
not
+
exist
.
{
getAvailableIds
(
)
}
)
;
}
const
index
=
table
.
columns
.
get
(
table
.
uniqueId
)
.
cellNodes
.
indexOf
(
item
)
;
const
cells
=
{
}
;
for
(
const
[
name
column
]
of
[
.
.
.
table
.
columns
]
)
{
if
(
!
includeHidden
&
&
column
.
column
.
parentNode
.
hidden
)
{
continue
;
}
cells
[
name
]
=
column
.
cellNodes
[
index
]
;
}
return
cells
;
}
function
isTableEmpty
(
)
{
const
doc
=
gPanelWindow
.
document
;
const
table
=
gUI
.
table
;
const
cells
=
doc
.
querySelectorAll
(
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
"
)
;
return
cells
.
length
=
=
=
0
;
}
function
getAvailableIds
(
)
{
const
doc
=
gPanelWindow
.
document
;
const
table
=
gUI
.
table
;
let
out
=
"
Available
ids
:
\
n
"
;
const
cells
=
doc
.
querySelectorAll
(
"
.
table
-
widget
-
column
#
"
+
table
.
uniqueId
+
"
.
table
-
widget
-
cell
"
)
;
for
(
const
cell
of
cells
)
{
out
+
=
-
{
cell
.
getAttribute
(
"
value
"
)
}
\
n
;
}
return
out
;
}
function
showAvailableIds
(
)
{
info
(
getAvailableIds
(
)
)
;
}
function
getCellValue
(
id
column
)
{
const
row
=
getRowValues
(
id
true
)
;
if
(
typeof
row
[
column
]
=
=
=
"
undefined
"
)
{
let
out
=
"
"
;
for
(
const
key
in
row
)
{
const
value
=
row
[
key
]
;
out
+
=
-
{
key
}
=
{
value
}
\
n
;
}
ok
(
false
The
column
name
'
{
column
}
'
that
was
passed
to
+
getCellValue
(
)
does
not
exist
.
Current
column
names
and
row
+
values
are
:
\
n
{
out
}
)
;
}
return
row
[
column
]
;
}
async
function
editCell
(
id
column
newValue
validate
=
true
)
{
const
row
=
getRowCells
(
id
true
)
;
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
editableFieldsEngine
.
edit
(
row
[
column
]
)
;
await
typeWithTerminator
(
newValue
"
KEY_Enter
"
validate
)
;
}
function
startCellEdit
(
id
column
selectText
=
true
)
{
const
row
=
getRowCells
(
id
true
)
;
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
const
cell
=
row
[
column
]
;
info
(
"
Selecting
row
"
+
id
)
;
gUI
.
table
.
selectedRow
=
id
;
info
(
"
Starting
cell
edit
(
"
+
id
+
"
"
+
column
+
"
)
"
)
;
editableFieldsEngine
.
edit
(
cell
)
;
if
(
!
selectText
)
{
const
textbox
=
gUI
.
table
.
_editableFieldsEngine
.
textbox
;
textbox
.
selectionEnd
=
textbox
.
selectionStart
;
}
}
function
checkCell
(
id
column
expected
)
{
is
(
getCellValue
(
id
column
)
expected
column
+
"
column
has
the
right
value
for
"
+
id
)
;
}
function
checkCellUneditable
(
id
column
)
{
const
row
=
getRowCells
(
id
true
)
;
const
cell
=
row
[
column
]
;
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
const
textbox
=
editableFieldsEngine
.
textbox
;
ok
(
!
cell
.
hidden
&
&
textbox
.
hidden
The
cell
located
in
column
{
column
}
and
row
{
id
}
is
not
editable
.
)
;
}
function
showColumn
(
id
state
)
{
const
columns
=
gUI
.
table
.
columns
;
const
column
=
columns
.
get
(
id
)
;
column
.
column
.
hidden
=
!
state
;
}
function
clickColumnHeader
(
id
)
{
const
columns
=
gUI
.
table
.
columns
;
const
column
=
columns
.
get
(
id
)
;
const
header
=
column
.
header
;
header
.
click
(
)
;
}
function
showAllColumns
(
state
)
{
const
columns
=
gUI
.
table
.
columns
;
for
(
const
[
id
]
of
columns
)
{
showColumn
(
id
state
)
;
}
}
async
function
typeWithTerminator
(
str
terminator
validate
=
true
)
{
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
const
textbox
=
editableFieldsEngine
.
textbox
;
const
colName
=
textbox
.
closest
(
"
.
table
-
widget
-
column
"
)
.
id
;
const
changeExpected
=
str
!
=
=
textbox
.
value
;
if
(
!
changeExpected
)
{
return
editableFieldsEngine
.
currentTarget
.
getAttribute
(
"
data
-
id
"
)
;
}
info
(
"
Typing
"
+
str
)
;
EventUtils
.
sendString
(
str
gPanelWindow
)
;
info
(
"
Pressing
"
+
terminator
)
;
EventUtils
.
synthesizeKey
(
terminator
null
gPanelWindow
)
;
if
(
validate
)
{
info
(
"
Validating
results
.
.
.
waiting
for
ROW_EDIT
event
.
"
)
;
const
uniqueId
=
await
gUI
.
table
.
once
(
TableWidget
.
EVENTS
.
ROW_EDIT
)
;
checkCell
(
uniqueId
colName
str
)
;
return
uniqueId
;
}
return
gUI
.
table
.
once
(
TableWidget
.
EVENTS
.
ROW_EDIT
)
;
}
function
getCurrentEditorValue
(
)
{
const
editableFieldsEngine
=
gUI
.
table
.
_editableFieldsEngine
;
const
textbox
=
editableFieldsEngine
.
textbox
;
return
textbox
.
value
;
}
function
PressKeyXTimes
(
key
x
modifiers
=
{
}
)
{
for
(
let
i
=
0
;
i
<
x
;
i
+
+
)
{
EventUtils
.
synthesizeKey
(
key
modifiers
)
;
}
}
async
function
checkState
(
state
)
{
for
(
const
[
store
names
]
of
state
)
{
const
storeName
=
store
.
join
(
"
>
"
)
;
info
(
Selecting
tree
item
{
storeName
}
)
;
await
selectTreeItem
(
store
)
;
const
items
=
gUI
.
table
.
items
;
is
(
items
.
size
names
.
length
There
is
correct
number
of
rows
in
{
storeName
}
)
;
if
(
names
.
length
=
=
=
0
)
{
showAvailableIds
(
)
;
}
for
(
const
name
of
names
)
{
if
(
!
items
.
has
(
name
)
)
{
showAvailableIds
(
)
;
}
ok
(
items
.
has
(
name
)
There
is
item
with
name
'
{
name
}
'
in
{
storeName
}
)
;
}
}
}
function
containsFocus
(
doc
container
)
{
let
elm
=
doc
.
activeElement
;
while
(
elm
)
{
if
(
elm
=
=
=
container
)
{
return
true
;
}
elm
=
elm
.
parentNode
;
}
return
false
;
}
var
focusSearchBoxUsingShortcut
=
async
function
(
panelWin
callback
)
{
info
(
"
Focusing
search
box
"
)
;
const
searchBox
=
panelWin
.
document
.
getElementById
(
"
storage
-
searchbox
"
)
;
const
focused
=
once
(
searchBox
"
focus
"
)
;
panelWin
.
focus
(
)
;
const
shortcut
=
await
panelWin
.
document
.
l10n
.
formatValue
(
"
storage
-
filter
-
key
"
)
;
synthesizeKeyShortcut
(
shortcut
)
;
await
focused
;
if
(
callback
)
{
callback
(
)
;
}
}
;
function
getCookieId
(
name
domain
path
partitionKey
=
"
"
)
{
return
{
name
}
{
SEPARATOR_GUID
}
{
domain
}
{
SEPARATOR_GUID
}
{
path
}
{
SEPARATOR_GUID
}
{
partitionKey
}
;
}
function
setPermission
(
url
permission
)
{
const
nsIPermissionManager
=
Ci
.
nsIPermissionManager
;
const
uri
=
Services
.
io
.
newURI
(
url
)
;
const
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
{
}
)
;
Cc
[
"
mozilla
.
org
/
permissionmanager
;
1
"
]
.
getService
(
nsIPermissionManager
)
.
addFromPrincipal
(
principal
permission
nsIPermissionManager
.
ALLOW_ACTION
)
;
}
function
toggleSidebar
(
)
{
gUI
.
sidebarToggleBtn
.
click
(
)
;
}
function
sidebarToggleVisible
(
)
{
return
!
gUI
.
sidebarToggleBtn
.
hidden
;
}
function
sidebarParseTreeVisible
(
state
)
{
if
(
state
)
{
Assert
.
greater
(
gUI
.
view
.
_testOnlyHierarchy
.
size
2
"
Parse
tree
should
be
visible
.
"
)
;
}
else
{
Assert
.
lessOrEqual
(
gUI
.
view
.
_testOnlyHierarchy
.
size
2
"
Parse
tree
should
not
be
visible
.
"
)
;
}
}
async
function
performAdd
(
store
)
{
const
storeName
=
store
.
join
(
"
>
"
)
;
const
toolbar
=
gPanelWindow
.
document
.
getElementById
(
"
storage
-
toolbar
"
)
;
const
type
=
store
[
0
]
;
await
selectTreeItem
(
store
)
;
const
menuAdd
=
toolbar
.
querySelector
(
"
#
add
-
button
"
)
;
if
(
menuAdd
.
hidden
)
{
is
(
menuAdd
.
hidden
false
performAdd
called
for
{
storeName
}
but
it
is
not
supported
)
;
return
"
"
;
}
const
eventEdit
=
gUI
.
table
.
once
(
"
row
-
edit
"
)
;
const
eventWait
=
gUI
.
once
(
"
store
-
objects
-
edit
"
)
;
menuAdd
.
click
(
)
;
const
rowId
=
await
eventEdit
;
await
eventWait
;
const
key
=
type
=
=
=
"
cookies
"
?
"
uniqueKey
"
:
"
name
"
;
const
value
=
getCellValue
(
rowId
key
)
;
is
(
rowId
value
Row
'
{
rowId
}
'
was
successfully
added
.
)
;
return
rowId
;
}
const
CELL_SELECTOR
=
"
#
storage
-
table
.
table
-
widget
-
column
:
first
-
child
.
table
-
widget
-
cell
"
;
function
getCellLength
(
)
{
return
gPanelWindow
.
document
.
querySelectorAll
(
CELL_SELECTOR
)
.
length
;
}
function
checkCellLength
(
len
)
{
is
(
getCellLength
(
)
len
Table
should
contain
{
len
}
items
)
;
}
async
function
scroll
(
)
{
const
=
id
=
>
gPanelWindow
.
document
.
querySelector
(
id
)
;
const
table
=
(
"
#
storage
-
table
.
table
-
widget
-
body
"
)
;
const
cell
=
(
CELL_SELECTOR
)
;
const
cellHeight
=
cell
.
getBoundingClientRect
(
)
.
height
;
const
onStoresUpdate
=
gUI
.
once
(
"
store
-
objects
-
updated
"
)
;
table
.
scrollTop
+
=
cellHeight
*
50
;
await
onStoresUpdate
;
}
function
checkTree
(
doc
path
isExpected
=
true
)
{
const
doesExist
=
isInTree
(
doc
path
)
;
ok
(
isExpected
?
doesExist
:
!
doesExist
{
path
.
join
(
"
>
"
)
}
is
{
isExpected
?
"
"
:
"
not
"
}
in
the
tree
)
;
}
function
isInTree
(
doc
path
)
{
const
treeId
=
JSON
.
stringify
(
path
)
;
return
!
!
doc
.
querySelector
(
[
data
-
id
=
'
{
treeId
}
'
]
)
;
}
function
getTreeNodeLabel
(
doc
path
)
{
const
treeId
=
JSON
.
stringify
(
path
)
;
return
doc
.
querySelector
(
[
data
-
id
=
'
{
treeId
}
'
]
.
tree
-
widget
-
item
)
.
textContent
;
}
function
checkStorageData
(
name
value
)
{
ok
(
hasStorageData
(
name
value
)
Table
row
has
an
entry
for
:
{
name
}
with
value
:
{
value
}
)
;
}
async
function
waitForStorageData
(
name
value
)
{
info
(
"
Waiting
for
data
to
appear
in
the
table
"
)
;
await
waitFor
(
(
)
=
>
hasStorageData
(
name
value
)
)
;
ok
(
true
Table
row
has
an
entry
for
:
{
name
}
with
value
:
{
value
}
)
;
}
function
hasStorageData
(
name
value
)
{
return
gUI
.
table
.
items
.
get
(
name
)
?
.
value
=
=
=
value
;
}
function
buildURLWithContent
(
domain
html
protocol
=
"
https
"
)
{
return
{
protocol
}
:
/
/
{
domain
}
/
document
-
builder
.
sjs
?
html
=
{
encodeURI
(
html
)
}
;
}
function
checkCookieData
(
name
value
)
{
ok
(
hasCookieData
(
name
value
)
Table
row
has
an
entry
for
:
{
name
}
with
value
:
{
value
}
)
;
}
function
hasCookieData
(
name
value
)
{
const
rows
=
Array
.
from
(
gUI
.
table
.
items
)
;
const
cookie
=
rows
.
map
(
(
[
data
]
)
=
>
data
)
.
find
(
x
=
>
x
.
name
=
=
=
name
)
;
info
(
found
{
cookie
?
.
value
}
)
;
return
cookie
?
.
value
=
=
=
value
;
}
