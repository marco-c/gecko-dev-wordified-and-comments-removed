"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
ELLIPSIS
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
parseItemValue
}
=
require
(
"
devtools
/
shared
/
storage
/
utils
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
getUnicodeHostname
}
=
require
(
"
devtools
/
client
/
shared
/
unicode
-
url
"
)
;
const
getStorageTypeURL
=
require
(
"
devtools
/
client
/
storage
/
utils
/
doc
-
utils
"
)
;
const
SEPARATOR_GUID
=
"
{
9d414cc5
-
8319
-
0a04
-
0586
-
c0a6ae01670a
}
"
;
loader
.
lazyRequireGetter
(
this
"
TreeWidget
"
"
devtools
/
client
/
shared
/
widgets
/
TreeWidget
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TableWidget
"
"
devtools
/
client
/
shared
/
widgets
/
TableWidget
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
debounce
"
"
devtools
/
shared
/
debounce
"
true
)
;
loader
.
lazyImporter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
storage
/
VariablesView
.
jsm
"
)
;
const
REASON
=
{
NEW_ROW
:
"
new
-
row
"
NEXT_50_ITEMS
:
"
next
-
50
-
items
"
POPULATE
:
"
populate
"
UPDATE
:
"
update
"
}
;
const
LAZY_RESIZE_INTERVAL_MS
=
200
;
const
ITEM_NAME_MAX_LENGTH
=
32
;
const
HEADERS_L10N_IDS
=
{
Cache
:
{
status
:
"
storage
-
table
-
headers
-
cache
-
status
"
}
cookies
:
{
creationTime
:
"
storage
-
table
-
headers
-
cookies
-
creation
-
time
"
expires
:
"
storage
-
table
-
headers
-
cookies
-
expires
"
lastAccessed
:
"
storage
-
table
-
headers
-
cookies
-
last
-
accessed
"
name
:
"
storage
-
table
-
headers
-
cookies
-
name
"
size
:
"
storage
-
table
-
headers
-
cookies
-
size
"
value
:
"
storage
-
table
-
headers
-
cookies
-
value
"
}
extensionStorage
:
{
area
:
"
storage
-
table
-
headers
-
extension
-
storage
-
area
"
}
}
;
const
HEADERS_NON_L10N_STRINGS
=
{
Cache
:
{
url
:
"
URL
"
}
cookies
:
{
host
:
"
Domain
"
hostOnly
:
"
HostOnly
"
isHttpOnly
:
"
HttpOnly
"
isSecure
:
"
Secure
"
path
:
"
Path
"
sameSite
:
"
SameSite
"
uniqueKey
:
"
Unique
key
"
}
extensionStorage
:
{
name
:
"
Key
"
value
:
"
Value
"
}
indexedDB
:
{
autoIncrement
:
"
Auto
Increment
"
db
:
"
Database
Name
"
indexes
:
"
Indexes
"
keyPath
:
"
Key
Path
"
name
:
"
Key
"
objectStore
:
"
Object
Store
Name
"
objectStores
:
"
Object
Stores
"
origin
:
"
Origin
"
storage
:
"
Storage
"
uniqueKey
:
"
Unique
key
"
value
:
"
Value
"
version
:
"
Version
"
}
localStorage
:
{
name
:
"
Key
"
value
:
"
Value
"
}
sessionStorage
:
{
name
:
"
Key
"
value
:
"
Value
"
}
}
;
class
StorageUI
{
constructor
(
panelWin
toolbox
commands
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_window
=
panelWin
;
this
.
_panelDoc
=
panelWin
.
document
;
this
.
_toolbox
=
toolbox
;
this
.
_commands
=
commands
;
this
.
sidebarToggledOpen
=
null
;
this
.
shouldLoadMoreItems
=
true
;
const
treeNode
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
"
)
;
this
.
tree
=
new
TreeWidget
(
treeNode
{
defaultType
:
"
dir
"
contextMenuId
:
"
storage
-
tree
-
popup
"
}
)
;
this
.
onHostSelect
=
this
.
onHostSelect
.
bind
(
this
)
;
this
.
tree
.
on
(
"
select
"
this
.
onHostSelect
)
;
const
tableNode
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
"
)
;
this
.
table
=
new
TableWidget
(
tableNode
{
emptyText
:
"
storage
-
table
-
empty
-
text
"
highlightUpdated
:
true
cellContextMenuId
:
"
storage
-
table
-
popup
"
l10n
:
this
.
_panelDoc
.
l10n
}
)
;
this
.
updateObjectSidebar
=
this
.
updateObjectSidebar
.
bind
(
this
)
;
this
.
table
.
on
(
TableWidget
.
EVENTS
.
ROW_SELECTED
this
.
updateObjectSidebar
)
;
this
.
handleScrollEnd
=
this
.
loadMoreItems
.
bind
(
this
)
;
this
.
table
.
on
(
TableWidget
.
EVENTS
.
SCROLL_END
this
.
handleScrollEnd
)
;
this
.
editItem
=
this
.
editItem
.
bind
(
this
)
;
this
.
table
.
on
(
TableWidget
.
EVENTS
.
CELL_EDIT
this
.
editItem
)
;
this
.
sidebar
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
sidebar
"
)
;
this
.
sidebar
.
setAttribute
(
"
width
"
"
300
"
)
;
this
.
view
=
new
VariablesView
(
this
.
sidebar
.
firstChild
{
lazyEmpty
:
true
lazyEmptyDelay
:
10
searchEnabled
:
true
contextMenuId
:
"
variable
-
view
-
popup
"
preventDescriptorModifiers
:
true
}
)
;
this
.
filterItems
=
this
.
filterItems
.
bind
(
this
)
;
this
.
onPaneToggleButtonClicked
=
this
.
onPaneToggleButtonClicked
.
bind
(
this
)
;
this
.
setupToolbar
(
)
;
this
.
handleKeypress
=
this
.
handleKeypress
.
bind
(
this
)
;
this
.
_panelDoc
.
addEventListener
(
"
keypress
"
this
.
handleKeypress
)
;
this
.
onTreePopupShowing
=
this
.
onTreePopupShowing
.
bind
(
this
)
;
this
.
_treePopup
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
"
)
;
this
.
_treePopup
.
addEventListener
(
"
popupshowing
"
this
.
onTreePopupShowing
)
;
this
.
onTablePopupShowing
=
this
.
onTablePopupShowing
.
bind
(
this
)
;
this
.
_tablePopup
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
"
)
;
this
.
_tablePopup
.
addEventListener
(
"
popupshowing
"
this
.
onTablePopupShowing
)
;
this
.
onVariableViewPopupShowing
=
this
.
onVariableViewPopupShowing
.
bind
(
this
)
;
this
.
_variableViewPopup
=
this
.
_panelDoc
.
getElementById
(
"
variable
-
view
-
popup
"
)
;
this
.
_variableViewPopup
.
addEventListener
(
"
popupshowing
"
this
.
onVariableViewPopupShowing
)
;
this
.
onRefreshTable
=
this
.
onRefreshTable
.
bind
(
this
)
;
this
.
onAddItem
=
this
.
onAddItem
.
bind
(
this
)
;
this
.
onCopyItem
=
this
.
onCopyItem
.
bind
(
this
)
;
this
.
onPanelWindowResize
=
debounce
(
this
.
#
onLazyPanelResize
LAZY_RESIZE_INTERVAL_MS
this
)
;
this
.
onRemoveItem
=
this
.
onRemoveItem
.
bind
(
this
)
;
this
.
onRemoveAllFrom
=
this
.
onRemoveAllFrom
.
bind
(
this
)
;
this
.
onRemoveAll
=
this
.
onRemoveAll
.
bind
(
this
)
;
this
.
onRemoveAllSessionCookies
=
this
.
onRemoveAllSessionCookies
.
bind
(
this
)
;
this
.
onRemoveTreeItem
=
this
.
onRemoveTreeItem
.
bind
(
this
)
;
this
.
_refreshButton
=
this
.
_panelDoc
.
getElementById
(
"
refresh
-
button
"
)
;
this
.
_refreshButton
.
addEventListener
(
"
click
"
this
.
onRefreshTable
)
;
this
.
_addButton
=
this
.
_panelDoc
.
getElementById
(
"
add
-
button
"
)
;
this
.
_addButton
.
addEventListener
(
"
click
"
this
.
onAddItem
)
;
this
.
_window
.
addEventListener
(
"
resize
"
this
.
onPanelWindowResize
true
)
;
this
.
_variableViewPopupCopy
=
this
.
_panelDoc
.
getElementById
(
"
variable
-
view
-
popup
-
copy
"
)
;
this
.
_variableViewPopupCopy
.
addEventListener
(
"
command
"
this
.
onCopyItem
)
;
this
.
_tablePopupAddItem
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
add
"
)
;
this
.
_tablePopupAddItem
.
addEventListener
(
"
command
"
this
.
onAddItem
)
;
this
.
_tablePopupDelete
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
"
)
;
this
.
_tablePopupDelete
.
addEventListener
(
"
command
"
this
.
onRemoveItem
)
;
this
.
_tablePopupDeleteAllFrom
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
-
all
-
from
"
)
;
this
.
_tablePopupDeleteAllFrom
.
addEventListener
(
"
command
"
this
.
onRemoveAllFrom
)
;
this
.
_tablePopupDeleteAll
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
-
all
"
)
;
this
.
_tablePopupDeleteAll
.
addEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_tablePopupDeleteAllSessionCookies
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
-
all
-
session
-
cookies
"
)
;
this
.
_tablePopupDeleteAllSessionCookies
.
addEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
this
.
_treePopupDeleteAll
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
-
delete
-
all
"
)
;
this
.
_treePopupDeleteAll
.
addEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_treePopupDeleteAllSessionCookies
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
-
delete
-
all
-
session
-
cookies
"
)
;
this
.
_treePopupDeleteAllSessionCookies
.
addEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
this
.
_treePopupDelete
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
-
delete
"
)
;
this
.
_treePopupDelete
.
addEventListener
(
"
command
"
this
.
onRemoveTreeItem
)
;
}
get
currentTarget
(
)
{
return
this
.
_commands
.
targetCommand
.
targetFront
;
}
async
init
(
)
{
this
.
storageResources
=
{
}
;
await
this
.
_initL10NStringsMap
(
)
;
const
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
_panelDoc
.
defaultView
}
)
;
const
key
=
this
.
_l10nStrings
.
get
(
"
storage
-
filter
-
key
"
)
;
shortcuts
.
on
(
key
event
=
>
{
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
)
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
await
this
.
_commands
.
targetCommand
.
watchTargets
(
{
types
:
[
this
.
_commands
.
targetCommand
.
TYPES
.
FRAME
]
onAvailable
:
this
.
_onTargetAvailable
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
this
.
_onResourceListAvailable
=
this
.
_onResourceListAvailable
.
bind
(
this
)
;
const
{
resourceCommand
}
=
this
.
_toolbox
;
await
this
.
_toolbox
.
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
COOKIE
resourceCommand
.
TYPES
.
CACHE_STORAGE
resourceCommand
.
TYPES
.
EXTENSION_STORAGE
resourceCommand
.
TYPES
.
INDEXED_DB
resourceCommand
.
TYPES
.
LOCAL_STORAGE
resourceCommand
.
TYPES
.
SESSION_STORAGE
]
{
onAvailable
:
this
.
_onResourceListAvailable
}
)
;
}
async
_initL10NStringsMap
(
)
{
const
ids
=
[
"
storage
-
filter
-
key
"
"
storage
-
table
-
headers
-
cookies
-
name
"
"
storage
-
table
-
headers
-
cookies
-
value
"
"
storage
-
table
-
headers
-
cookies
-
expires
"
"
storage
-
table
-
headers
-
cookies
-
size
"
"
storage
-
table
-
headers
-
cookies
-
last
-
accessed
"
"
storage
-
table
-
headers
-
cookies
-
creation
-
time
"
"
storage
-
table
-
headers
-
cache
-
status
"
"
storage
-
table
-
headers
-
extension
-
storage
-
area
"
"
storage
-
tree
-
labels
-
cookies
"
"
storage
-
tree
-
labels
-
local
-
storage
"
"
storage
-
tree
-
labels
-
session
-
storage
"
"
storage
-
tree
-
labels
-
indexed
-
db
"
"
storage
-
tree
-
labels
-
cache
"
"
storage
-
tree
-
labels
-
extension
-
storage
"
"
storage
-
expires
-
session
"
]
;
const
results
=
await
this
.
_panelDoc
.
l10n
.
formatValues
(
ids
.
map
(
s
=
>
(
{
id
:
s
}
)
)
)
;
this
.
_l10nStrings
=
new
Map
(
ids
.
map
(
(
id
i
)
=
>
[
id
results
[
i
]
]
)
)
;
}
async
_onTargetAvailable
(
{
targetFront
}
)
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
this
.
front
=
await
targetFront
.
getFront
(
"
storage
"
)
;
}
async
_onResourceListAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
isDestroyed
(
)
)
{
continue
;
}
const
{
resourceKey
}
=
resource
;
if
(
!
this
.
storageResources
[
resourceKey
]
)
{
this
.
storageResources
[
resourceKey
]
=
[
]
;
}
this
.
storageResources
[
resourceKey
]
.
push
(
resource
)
;
resource
.
on
(
"
single
-
store
-
update
"
this
.
_onStoreUpdate
.
bind
(
this
resource
)
)
;
resource
.
on
(
"
single
-
store
-
cleared
"
this
.
_onStoreCleared
.
bind
(
this
resource
)
)
;
}
try
{
await
this
.
populateStorageTree
(
)
;
}
catch
(
e
)
{
if
(
!
this
.
_toolbox
|
|
this
.
_toolbox
.
_destroyer
)
{
return
;
}
console
.
error
(
e
)
;
}
}
_onTargetDestroyed
(
{
targetFront
}
)
{
for
(
const
type
in
this
.
storageResources
)
{
this
.
storageResources
[
type
]
=
this
.
storageResources
[
type
]
.
filter
(
storage
=
>
{
return
!
storage
.
isDestroyed
(
)
&
&
storage
.
targetFront
!
=
targetFront
;
}
)
;
}
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
this
.
storageResources
=
{
}
;
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
tree
.
clear
(
)
;
}
set
animationsEnabled
(
value
)
{
this
.
_panelDoc
.
documentElement
.
classList
.
toggle
(
"
no
-
animate
"
!
value
)
;
}
destroy
(
)
{
if
(
this
.
_destroyed
)
{
return
;
}
this
.
_destroyed
=
true
;
const
{
resourceCommand
}
=
this
.
_toolbox
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
COOKIE
resourceCommand
.
TYPES
.
CACHE_STORAGE
resourceCommand
.
TYPES
.
EXTENSION_STORAGE
resourceCommand
.
TYPES
.
INDEXED_DB
resourceCommand
.
TYPES
.
LOCAL_STORAGE
resourceCommand
.
TYPES
.
SESSION_STORAGE
]
{
onAvailable
:
this
.
_onResourceListAvailable
}
)
;
this
.
table
.
off
(
TableWidget
.
EVENTS
.
ROW_SELECTED
this
.
updateObjectSidebar
)
;
this
.
table
.
off
(
TableWidget
.
EVENTS
.
SCROLL_END
this
.
loadMoreItems
)
;
this
.
table
.
off
(
TableWidget
.
EVENTS
.
CELL_EDIT
this
.
editItem
)
;
this
.
table
.
destroy
(
)
;
this
.
_panelDoc
.
removeEventListener
(
"
keypress
"
this
.
handleKeypress
)
;
this
.
searchBox
.
removeEventListener
(
"
input
"
this
.
filterItems
)
;
this
.
searchBox
=
null
;
this
.
sidebarToggleBtn
.
removeEventListener
(
"
click
"
this
.
onPaneToggleButtonClicked
)
;
this
.
sidebarToggleBtn
=
null
;
this
.
_window
.
removeEventListener
(
"
resize
"
this
.
#
onLazyPanelResize
true
)
;
this
.
_treePopup
.
removeEventListener
(
"
popupshowing
"
this
.
onTreePopupShowing
)
;
this
.
_refreshButton
.
removeEventListener
(
"
click
"
this
.
onRefreshTable
)
;
this
.
_addButton
.
removeEventListener
(
"
click
"
this
.
onAddItem
)
;
this
.
_tablePopupAddItem
.
removeEventListener
(
"
command
"
this
.
onAddItem
)
;
this
.
_treePopupDeleteAll
.
removeEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_treePopupDeleteAllSessionCookies
.
removeEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
this
.
_treePopupDelete
.
removeEventListener
(
"
command
"
this
.
onRemoveTreeItem
)
;
this
.
_tablePopup
.
removeEventListener
(
"
popupshowing
"
this
.
onTablePopupShowing
)
;
this
.
_tablePopupDelete
.
removeEventListener
(
"
command
"
this
.
onRemoveItem
)
;
this
.
_tablePopupDeleteAllFrom
.
removeEventListener
(
"
command
"
this
.
onRemoveAllFrom
)
;
this
.
_tablePopupDeleteAll
.
removeEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_tablePopupDeleteAllSessionCookies
.
removeEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
}
setupToolbar
(
)
{
this
.
searchBox
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
searchbox
"
)
;
this
.
searchBox
.
addEventListener
(
"
input
"
this
.
filterItems
)
;
this
.
sidebarToggleBtn
=
this
.
_panelDoc
.
querySelector
(
"
.
sidebar
-
toggle
"
)
;
this
.
updateSidebarToggleButton
(
)
;
this
.
sidebarToggleBtn
.
addEventListener
(
"
click
"
this
.
onPaneToggleButtonClicked
)
;
}
onPaneToggleButtonClicked
(
)
{
if
(
this
.
sidebar
.
hidden
&
&
this
.
table
.
selectedRow
)
{
this
.
sidebar
.
hidden
=
false
;
this
.
sidebarToggledOpen
=
true
;
this
.
updateSidebarToggleButton
(
)
;
}
else
{
this
.
sidebarToggledOpen
=
false
;
this
.
hideSidebar
(
)
;
}
}
updateSidebarToggleButton
(
)
{
let
dataL10nId
;
this
.
sidebarToggleBtn
.
hidden
=
!
this
.
table
.
hasSelectedRow
;
if
(
this
.
sidebar
.
hidden
)
{
this
.
sidebarToggleBtn
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
dataL10nId
=
"
storage
-
expand
-
pane
"
;
}
else
{
this
.
sidebarToggleBtn
.
classList
.
remove
(
"
pane
-
collapsed
"
)
;
dataL10nId
=
"
storage
-
collapse
-
pane
"
;
}
this
.
_panelDoc
.
l10n
.
setAttributes
(
this
.
sidebarToggleBtn
dataL10nId
)
;
}
hideSidebar
(
)
{
this
.
sidebar
.
hidden
=
true
;
this
.
updateSidebarToggleButton
(
)
;
}
getCurrentFront
(
)
{
const
{
datatype
host
}
=
this
.
table
;
return
this
.
_getStorage
(
datatype
host
)
;
}
_getStorage
(
type
host
)
{
const
storageType
=
this
.
storageResources
[
type
]
;
return
storageType
.
find
(
x
=
>
host
in
x
.
hosts
)
;
}
makeFieldsEditable
(
editableFields
)
{
if
(
editableFields
&
&
editableFields
.
length
)
{
this
.
table
.
makeFieldsEditable
(
editableFields
)
;
}
else
if
(
this
.
table
.
_editableFieldsEngine
)
{
this
.
table
.
_editableFieldsEngine
.
destroy
(
)
;
}
}
editItem
(
data
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
!
selectedItem
)
{
return
;
}
const
front
=
this
.
getCurrentFront
(
)
;
front
.
editItem
(
data
)
;
}
async
removeItemFromTable
(
name
)
{
if
(
this
.
table
.
isSelected
(
name
)
&
&
this
.
table
.
items
.
size
>
1
)
{
if
(
this
.
table
.
selectedIndex
=
=
0
)
{
this
.
table
.
selectNextRow
(
)
;
}
else
{
this
.
table
.
selectPreviousRow
(
)
;
}
}
this
.
table
.
remove
(
name
)
;
await
this
.
updateObjectSidebar
(
)
;
}
_onStoreCleared
(
resource
{
clearedHostsOrPaths
}
)
{
const
{
resourceKey
}
=
resource
;
function
*
enumPaths
(
)
{
if
(
Array
.
isArray
(
clearedHostsOrPaths
)
)
{
for
(
const
host
of
clearedHostsOrPaths
)
{
yield
[
host
]
;
}
}
else
{
for
(
const
host
in
clearedHostsOrPaths
)
{
const
paths
=
clearedHostsOrPaths
[
host
]
;
if
(
!
paths
.
length
)
{
yield
[
host
]
;
}
else
{
for
(
let
path
of
paths
)
{
try
{
path
=
JSON
.
parse
(
path
)
;
yield
[
host
.
.
.
path
]
;
}
catch
(
ex
)
{
}
}
}
}
}
}
for
(
const
path
of
enumPaths
(
)
)
{
if
(
this
.
tree
.
isSelected
(
[
resourceKey
.
.
.
path
]
)
)
{
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
itemOffset
=
0
;
this
.
emit
(
"
store
-
objects
-
cleared
"
)
;
break
;
}
}
}
async
_onStoreUpdate
(
resource
update
)
{
const
{
changed
added
deleted
}
=
update
;
if
(
added
)
{
await
this
.
handleAddedItems
(
added
)
;
}
if
(
changed
)
{
await
this
.
handleChangedItems
(
changed
)
;
}
if
(
deleted
)
{
await
this
.
handleDeletedItems
(
deleted
)
;
}
if
(
added
|
|
deleted
|
|
changed
)
{
this
.
emit
(
"
store
-
objects
-
edit
"
)
;
}
}
async
#
onLazyPanelResize
(
)
{
if
(
this
.
_window
.
closed
|
|
this
.
_destroyed
|
|
this
.
table
.
hasScrollbar
)
{
return
;
}
await
this
.
loadMoreItems
(
)
;
this
.
emit
(
"
storage
-
resize
"
)
;
}
_getColumnName
(
type
name
)
{
const
columnName
=
HEADERS_NON_L10N_STRINGS
[
type
]
?
.
[
name
]
;
if
(
columnName
)
{
return
columnName
;
}
const
l10nId
=
HEADERS_L10N_IDS
[
type
]
?
.
[
name
]
;
if
(
l10nId
&
&
this
.
_l10nStrings
.
has
(
l10nId
)
)
{
return
this
.
_l10nStrings
.
get
(
l10nId
)
;
}
return
name
;
}
async
handleAddedItems
(
added
)
{
for
(
const
type
in
added
)
{
for
(
const
host
in
added
[
type
]
)
{
const
label
=
this
.
getReadableLabelFromHostname
(
host
)
;
this
.
tree
.
add
(
[
type
{
id
:
host
label
type
:
"
url
"
}
]
)
;
for
(
let
name
of
added
[
type
]
[
host
]
)
{
try
{
name
=
JSON
.
parse
(
name
)
;
if
(
name
.
length
=
=
3
)
{
name
.
splice
(
2
1
)
;
}
this
.
tree
.
add
(
[
type
host
.
.
.
name
]
)
;
if
(
!
this
.
tree
.
selectedItem
)
{
this
.
tree
.
selectedItem
=
[
type
host
name
[
0
]
name
[
1
]
]
;
await
this
.
fetchStorageObjects
(
type
host
[
JSON
.
stringify
(
name
)
]
REASON
.
NEW_ROW
)
;
}
}
catch
(
ex
)
{
}
}
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
await
this
.
fetchStorageObjects
(
type
host
added
[
type
]
[
host
]
REASON
.
NEW_ROW
)
;
}
}
}
}
async
handleDeletedItems
(
deleted
)
{
for
(
const
type
in
deleted
)
{
for
(
const
host
in
deleted
[
type
]
)
{
if
(
!
deleted
[
type
]
[
host
]
.
length
)
{
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
tree
.
selectPreviousItem
(
)
;
}
this
.
tree
.
remove
(
[
type
host
]
)
;
}
else
{
for
(
const
name
of
deleted
[
type
]
[
host
]
)
{
try
{
if
(
[
"
indexedDB
"
"
Cache
"
]
.
includes
(
type
)
)
{
const
names
=
JSON
.
parse
(
name
)
;
if
(
names
.
length
<
3
)
{
if
(
this
.
tree
.
isSelected
(
[
type
host
.
.
.
names
]
)
)
{
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
tree
.
selectPreviousItem
(
)
;
}
this
.
tree
.
remove
(
[
type
host
.
.
.
names
]
)
;
}
if
(
names
.
length
)
{
const
tableItemName
=
names
.
pop
(
)
;
if
(
this
.
tree
.
isSelected
(
[
type
host
.
.
.
names
]
)
)
{
await
this
.
removeItemFromTable
(
tableItemName
)
;
}
}
}
else
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
await
this
.
removeItemFromTable
(
name
)
;
}
}
catch
(
ex
)
{
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
await
this
.
removeItemFromTable
(
name
)
;
}
}
}
}
}
}
}
async
handleChangedItems
(
changed
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
!
selectedItem
)
{
return
;
}
const
[
type
host
db
objectStore
]
=
selectedItem
;
if
(
!
changed
[
type
]
|
|
!
changed
[
type
]
[
host
]
|
|
!
changed
[
type
]
[
host
]
.
length
)
{
return
;
}
try
{
const
toUpdate
=
[
]
;
for
(
const
name
of
changed
[
type
]
[
host
]
)
{
if
(
[
"
indexedDB
"
"
Cache
"
]
.
includes
(
type
)
)
{
const
names
=
JSON
.
parse
(
name
)
;
if
(
names
[
0
]
=
=
db
&
&
names
[
1
]
=
=
objectStore
&
&
names
[
2
]
)
{
toUpdate
.
push
(
name
)
;
}
}
else
{
toUpdate
.
push
(
name
)
;
}
}
await
this
.
fetchStorageObjects
(
type
host
toUpdate
REASON
.
UPDATE
)
;
}
catch
(
ex
)
{
await
this
.
fetchStorageObjects
(
type
host
changed
[
type
]
[
host
]
REASON
.
UPDATE
)
;
}
}
async
fetchStorageObjects
(
type
host
names
reason
)
{
const
fetchOpts
=
reason
=
=
=
REASON
.
NEXT_50_ITEMS
?
{
offset
:
this
.
itemOffset
}
:
{
}
;
const
storage
=
this
.
_getStorage
(
type
host
)
;
this
.
sidebarToggledOpen
=
null
;
if
(
reason
!
=
=
REASON
.
NEXT_50_ITEMS
&
&
reason
!
=
=
REASON
.
UPDATE
&
&
reason
!
=
=
REASON
.
NEW_ROW
&
&
reason
!
=
=
REASON
.
POPULATE
)
{
throw
new
Error
(
"
Invalid
reason
specified
"
)
;
}
try
{
if
(
reason
=
=
=
REASON
.
POPULATE
|
|
(
reason
=
=
=
REASON
.
NEW_ROW
&
&
this
.
table
.
items
.
size
=
=
=
0
)
)
{
let
subType
=
null
;
if
(
type
=
=
=
"
indexedDB
"
&
&
names
)
{
const
[
dbName
objectStoreName
]
=
JSON
.
parse
(
names
[
0
]
)
;
if
(
dbName
)
{
subType
=
"
database
"
;
}
if
(
objectStoreName
)
{
subType
=
"
object
store
"
;
}
}
await
this
.
resetColumns
(
type
host
subType
)
;
}
const
{
data
total
}
=
await
storage
.
getStoreObjects
(
host
names
fetchOpts
)
;
if
(
data
.
length
)
{
await
this
.
populateTable
(
data
reason
total
)
;
}
else
if
(
reason
=
=
=
REASON
.
POPULATE
)
{
await
this
.
clearHeaders
(
)
;
}
this
.
updateToolbar
(
)
;
this
.
emit
(
"
store
-
objects
-
updated
"
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
supportsAddItem
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsAddItem
|
|
false
;
}
supportsRemoveItem
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsRemoveItem
|
|
false
;
}
supportsRemoveAll
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsRemoveAll
|
|
false
;
}
supportsRemoveAllSessionCookies
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsRemoveAllSessionCookies
|
|
false
;
}
updateToolbar
(
)
{
const
item
=
this
.
tree
.
selectedItem
;
if
(
!
item
)
{
return
;
}
const
[
type
host
]
=
item
;
this
.
_addButton
.
hidden
=
!
host
|
|
!
this
.
supportsAddItem
(
type
host
)
;
}
async
populateStorageTree
(
)
{
const
populateTreeFromResource
=
(
type
resource
)
=
>
{
for
(
const
host
in
resource
.
hosts
)
{
const
label
=
this
.
getReadableLabelFromHostname
(
host
)
;
this
.
tree
.
add
(
[
type
{
id
:
host
label
type
:
"
url
"
}
]
)
;
for
(
const
name
of
resource
.
hosts
[
host
]
)
{
try
{
const
names
=
JSON
.
parse
(
name
)
;
this
.
tree
.
add
(
[
type
host
.
.
.
names
]
)
;
if
(
!
this
.
tree
.
selectedItem
)
{
this
.
tree
.
selectedItem
=
[
type
host
names
[
0
]
names
[
1
]
]
;
}
}
catch
(
ex
)
{
}
}
if
(
!
this
.
tree
.
selectedItem
)
{
this
.
tree
.
selectedItem
=
[
type
host
]
;
}
}
}
;
const
onStoresObjectsUpdated
=
this
.
once
(
"
store
-
objects
-
updated
"
)
;
const
initialSelectedItem
=
this
.
tree
.
selectedItem
;
for
(
const
[
type
resources
]
of
Object
.
entries
(
this
.
storageResources
)
)
{
let
typeLabel
=
type
;
try
{
typeLabel
=
this
.
getStorageTypeLabel
(
type
)
;
}
catch
(
e
)
{
console
.
error
(
"
Unable
to
localize
tree
label
type
:
"
+
type
)
;
}
this
.
tree
.
add
(
[
{
id
:
type
label
:
typeLabel
type
:
"
store
"
}
]
)
;
for
(
const
resource
of
resources
)
{
populateTreeFromResource
(
type
resource
)
;
}
}
if
(
initialSelectedItem
!
=
=
this
.
tree
.
selectedItem
)
{
await
onStoresObjectsUpdated
;
}
}
getStorageTypeLabel
(
type
)
{
let
dataL10nId
;
switch
(
type
)
{
case
"
cookies
"
:
dataL10nId
=
"
storage
-
tree
-
labels
-
cookies
"
;
break
;
case
"
localStorage
"
:
dataL10nId
=
"
storage
-
tree
-
labels
-
local
-
storage
"
;
break
;
case
"
sessionStorage
"
:
dataL10nId
=
"
storage
-
tree
-
labels
-
session
-
storage
"
;
break
;
case
"
indexedDB
"
:
dataL10nId
=
"
storage
-
tree
-
labels
-
indexed
-
db
"
;
break
;
case
"
Cache
"
:
dataL10nId
=
"
storage
-
tree
-
labels
-
cache
"
;
break
;
case
"
extensionStorage
"
:
dataL10nId
=
"
storage
-
tree
-
labels
-
extension
-
storage
"
;
break
;
default
:
throw
new
Error
(
"
Unknown
storage
type
"
)
;
}
return
this
.
_l10nStrings
.
get
(
dataL10nId
)
;
}
async
updateObjectSidebar
(
)
{
const
item
=
this
.
table
.
selectedRow
;
let
value
;
if
(
(
item
?
.
name
|
|
item
?
.
name
=
=
=
"
"
)
&
&
item
?
.
valueActor
)
{
value
=
await
item
.
valueActor
.
string
(
)
;
}
if
(
this
.
table
.
items
.
size
=
=
=
0
|
|
!
item
|
|
!
this
.
table
.
selectedRow
|
|
item
.
uniqueKey
!
=
=
this
.
table
.
selectedRow
.
uniqueKey
)
{
this
.
hideSidebar
(
)
;
return
;
}
if
(
this
.
sidebarToggledOpen
=
=
=
null
|
|
this
.
sidebarToggledOpen
=
=
=
true
)
{
this
.
sidebar
.
hidden
=
false
;
}
this
.
updateSidebarToggleButton
(
)
;
this
.
view
.
empty
(
)
;
const
mainScope
=
this
.
view
.
addScope
(
"
storage
-
data
"
)
;
mainScope
.
expanded
=
true
;
if
(
value
)
{
const
itemVar
=
mainScope
.
addItem
(
item
.
name
+
"
"
{
}
{
relaxed
:
true
}
)
;
itemVar
.
setGrip
(
value
)
;
const
obj
=
parseItemValue
(
value
)
;
if
(
typeof
obj
=
=
=
"
object
"
)
{
this
.
populateSidebar
(
item
.
name
obj
)
;
}
const
itemProps
=
Object
.
keys
(
item
)
;
if
(
itemProps
.
length
>
3
)
{
const
rawObject
=
Object
.
create
(
null
)
;
const
otherProps
=
itemProps
.
filter
(
e
=
>
!
[
"
name
"
"
value
"
"
valueActor
"
]
.
includes
(
e
)
)
;
for
(
const
prop
of
otherProps
)
{
const
column
=
this
.
table
.
columns
.
get
(
prop
)
;
if
(
column
?
.
private
)
{
continue
;
}
const
fieldName
=
this
.
_getColumnName
(
this
.
table
.
datatype
prop
)
;
rawObject
[
fieldName
]
=
item
[
prop
]
;
}
itemVar
.
populate
(
rawObject
{
sorted
:
true
}
)
;
itemVar
.
twisty
=
true
;
itemVar
.
expanded
=
true
;
}
}
else
{
for
(
const
key
in
item
)
{
const
column
=
this
.
table
.
columns
.
get
(
key
)
;
if
(
column
?
.
private
)
{
continue
;
}
mainScope
.
addItem
(
key
{
}
true
)
.
setGrip
(
item
[
key
]
)
;
const
obj
=
parseItemValue
(
item
[
key
]
)
;
if
(
typeof
obj
=
=
=
"
object
"
)
{
this
.
populateSidebar
(
item
.
name
obj
)
;
}
}
}
this
.
emit
(
"
sidebar
-
updated
"
)
;
}
getReadableLabelFromHostname
(
host
)
{
try
{
const
{
hostname
}
=
new
URL
(
host
)
;
const
unicodeHostname
=
getUnicodeHostname
(
hostname
)
;
if
(
hostname
!
=
=
unicodeHostname
)
{
return
host
.
replace
(
hostname
unicodeHostname
)
+
"
[
"
+
host
+
"
]
"
;
}
}
catch
(
_
)
{
}
return
host
;
}
populateSidebar
(
name
obj
)
{
const
jsonObject
=
Object
.
create
(
null
)
;
const
view
=
this
.
view
;
jsonObject
[
name
]
=
obj
;
const
valueScope
=
view
.
getScopeAtIndex
(
1
)
|
|
view
.
addScope
(
"
storage
-
parsed
-
value
"
)
;
valueScope
.
expanded
=
true
;
const
jsonVar
=
valueScope
.
addItem
(
"
"
Object
.
create
(
null
)
{
relaxed
:
true
}
)
;
jsonVar
.
expanded
=
true
;
jsonVar
.
twisty
=
true
;
jsonVar
.
populate
(
jsonObject
{
expanded
:
true
}
)
;
}
async
onHostSelect
(
item
)
{
if
(
!
item
)
{
return
;
}
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
searchBox
.
value
=
"
"
;
const
[
type
host
]
=
item
;
this
.
table
.
host
=
host
;
this
.
table
.
datatype
=
type
;
this
.
updateToolbar
(
)
;
let
names
=
null
;
if
(
!
host
)
{
let
storageTypeHintL10nId
=
"
"
;
switch
(
type
)
{
case
"
Cache
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
cache
-
hint
"
;
break
;
case
"
cookies
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
cookies
-
hint
"
;
break
;
case
"
extensionStorage
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
extensionstorage
-
hint
"
;
break
;
case
"
localStorage
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
localstorage
-
hint
"
;
break
;
case
"
indexedDB
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
indexeddb
-
hint
"
;
break
;
case
"
sessionStorage
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
sessionstorage
-
hint
"
;
break
;
}
this
.
table
.
setPlaceholder
(
storageTypeHintL10nId
getStorageTypeURL
(
this
.
table
.
datatype
)
)
;
await
this
.
clearHeaders
(
)
;
return
;
}
if
(
item
.
length
>
2
)
{
names
=
[
JSON
.
stringify
(
item
.
slice
(
2
)
)
]
;
}
this
.
itemOffset
=
0
;
await
this
.
fetchStorageObjects
(
type
host
names
REASON
.
POPULATE
)
;
}
async
clearHeaders
(
)
{
this
.
table
.
setColumns
(
{
}
null
{
}
{
}
)
;
}
async
resetColumns
(
type
host
subtype
)
{
this
.
table
.
host
=
host
;
this
.
table
.
datatype
=
type
;
let
uniqueKey
=
null
;
const
columns
=
{
}
;
const
editableFields
=
[
]
;
const
hiddenFields
=
[
]
;
const
privateFields
=
[
]
;
const
fields
=
await
this
.
getCurrentFront
(
)
.
getFields
(
subtype
)
;
fields
.
forEach
(
f
=
>
{
if
(
!
uniqueKey
)
{
this
.
table
.
uniqueId
=
uniqueKey
=
f
.
name
;
}
if
(
f
.
editable
)
{
editableFields
.
push
(
f
.
name
)
;
}
if
(
f
.
hidden
)
{
hiddenFields
.
push
(
f
.
name
)
;
}
if
(
f
.
private
)
{
privateFields
.
push
(
f
.
name
)
;
}
const
columnName
=
this
.
_getColumnName
(
type
f
.
name
)
;
if
(
columnName
)
{
columns
[
f
.
name
]
=
columnName
;
}
else
if
(
!
f
.
private
)
{
columns
[
f
.
name
]
=
f
.
name
;
console
.
error
(
No
string
defined
in
HEADERS_NON_L10N_STRINGS
for
'
{
type
}
.
{
f
.
name
}
'
)
;
}
}
)
;
this
.
table
.
setColumns
(
columns
null
hiddenFields
privateFields
)
;
this
.
hideSidebar
(
)
;
this
.
makeFieldsEditable
(
editableFields
)
;
}
async
populateTable
(
data
reason
totalAvailable
)
{
for
(
const
item
of
data
)
{
if
(
item
.
value
)
{
item
.
valueActor
=
item
.
value
;
item
.
value
=
item
.
value
.
initial
|
|
"
"
;
}
if
(
item
.
expires
!
=
null
)
{
item
.
expires
=
item
.
expires
?
new
Date
(
item
.
expires
)
.
toUTCString
(
)
:
this
.
_l10nStrings
.
get
(
"
storage
-
expires
-
session
"
)
;
}
if
(
item
.
creationTime
!
=
null
)
{
item
.
creationTime
=
new
Date
(
item
.
creationTime
)
.
toUTCString
(
)
;
}
if
(
item
.
lastAccessed
!
=
null
)
{
item
.
lastAccessed
=
new
Date
(
item
.
lastAccessed
)
.
toUTCString
(
)
;
}
switch
(
reason
)
{
case
REASON
.
POPULATE
:
case
REASON
.
NEXT_50_ITEMS
:
this
.
table
.
push
(
item
true
)
;
break
;
case
REASON
.
NEW_ROW
:
this
.
table
.
push
(
item
false
)
;
break
;
case
REASON
.
UPDATE
:
this
.
table
.
update
(
item
)
;
if
(
item
=
=
this
.
table
.
selectedRow
&
&
!
this
.
sidebar
.
hidden
)
{
await
this
.
updateObjectSidebar
(
)
;
}
break
;
}
this
.
shouldLoadMoreItems
=
true
;
}
if
(
(
reason
=
=
=
REASON
.
POPULATE
|
|
reason
=
=
=
REASON
.
NEXT_50_ITEMS
)
&
&
this
.
table
.
items
.
size
<
totalAvailable
&
&
!
this
.
table
.
hasScrollbar
)
{
await
this
.
loadMoreItems
(
)
;
}
}
handleKeypress
(
event
)
{
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
if
(
!
this
.
sidebar
.
hidden
)
{
this
.
hideSidebar
(
)
;
this
.
sidebarToggledOpen
=
false
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_BACK_SPACE
|
|
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_DELETE
)
{
if
(
this
.
table
.
selectedRow
&
&
event
.
target
.
localName
!
=
"
input
"
)
{
this
.
onRemoveItem
(
event
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
}
filterItems
(
)
{
const
value
=
this
.
searchBox
.
value
;
this
.
table
.
filterItems
(
value
[
"
valueActor
"
]
)
;
this
.
_panelDoc
.
documentElement
.
classList
.
toggle
(
"
filtering
"
!
!
value
)
;
}
async
loadMoreItems
(
)
{
if
(
!
this
.
shouldLoadMoreItems
|
|
this
.
_toolbox
.
currentToolId
!
=
=
"
storage
"
|
|
!
this
.
tree
.
selectedItem
)
{
return
;
}
this
.
shouldLoadMoreItems
=
false
;
this
.
itemOffset
+
=
50
;
const
item
=
this
.
tree
.
selectedItem
;
const
[
type
host
]
=
item
;
let
names
=
null
;
if
(
item
.
length
>
2
)
{
names
=
[
JSON
.
stringify
(
item
.
slice
(
2
)
)
]
;
}
await
this
.
fetchStorageObjects
(
type
host
names
REASON
.
NEXT_50_ITEMS
)
;
}
onTablePopupShowing
(
event
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
const
[
type
host
]
=
selectedItem
;
if
(
(
!
this
.
supportsAddItem
(
type
host
)
&
&
!
this
.
supportsRemoveItem
(
type
host
)
)
|
|
(
type
=
=
=
"
indexedDB
"
&
&
selectedItem
.
length
!
=
=
4
)
)
{
event
.
preventDefault
(
)
;
return
;
}
const
rowId
=
this
.
table
.
contextMenuRowId
;
const
data
=
this
.
table
.
items
.
get
(
rowId
)
;
if
(
this
.
supportsRemoveItem
(
type
host
)
)
{
const
name
=
data
[
this
.
table
.
uniqueId
]
;
const
separatorRegex
=
new
RegExp
(
SEPARATOR_GUID
"
g
"
)
;
const
label
=
addEllipsis
(
(
name
+
"
"
)
.
replace
(
separatorRegex
"
-
"
)
)
;
this
.
_tablePopupDelete
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
itemName
:
label
}
)
)
;
this
.
_tablePopupDelete
.
hidden
=
false
;
}
else
{
this
.
_tablePopupDelete
.
hidden
=
true
;
}
if
(
this
.
supportsAddItem
(
type
host
)
)
{
this
.
_tablePopupAddItem
.
hidden
=
false
;
}
else
{
this
.
_tablePopupAddItem
.
hidden
=
true
;
}
let
showDeleteAllSessionCookies
=
false
;
if
(
this
.
supportsRemoveAllSessionCookies
(
type
host
)
)
{
if
(
selectedItem
.
length
=
=
=
2
)
{
showDeleteAllSessionCookies
=
true
;
}
}
this
.
_tablePopupDeleteAllSessionCookies
.
hidden
=
!
showDeleteAllSessionCookies
;
if
(
type
=
=
=
"
cookies
"
)
{
const
hostString
=
addEllipsis
(
data
.
host
)
;
this
.
_tablePopupDeleteAllFrom
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
host
:
hostString
}
)
)
;
this
.
_tablePopupDeleteAllFrom
.
hidden
=
false
;
}
else
{
this
.
_tablePopupDeleteAllFrom
.
hidden
=
true
;
}
}
onTreePopupShowing
(
event
)
{
let
showMenu
=
false
;
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
selectedItem
)
{
const
[
type
host
]
=
selectedItem
;
let
showDeleteAll
=
false
;
if
(
this
.
supportsRemoveAll
(
type
host
)
)
{
let
level
;
if
(
type
=
=
"
indexedDB
"
)
{
level
=
4
;
}
else
if
(
type
=
=
"
Cache
"
)
{
level
=
3
;
}
else
{
level
=
2
;
}
if
(
selectedItem
.
length
=
=
level
)
{
showDeleteAll
=
true
;
}
}
this
.
_treePopupDeleteAll
.
hidden
=
!
showDeleteAll
;
let
showDeleteAllSessionCookies
=
false
;
if
(
this
.
supportsRemoveAllSessionCookies
(
type
host
)
)
{
if
(
type
=
=
=
"
cookies
"
&
&
selectedItem
.
length
=
=
=
2
)
{
showDeleteAllSessionCookies
=
true
;
}
}
this
.
_treePopupDeleteAllSessionCookies
.
hidden
=
!
showDeleteAllSessionCookies
;
const
showDelete
=
(
type
=
=
"
indexedDB
"
|
|
type
=
=
"
Cache
"
)
&
&
selectedItem
.
length
=
=
3
;
this
.
_treePopupDelete
.
hidden
=
!
showDelete
;
if
(
showDelete
)
{
const
itemName
=
addEllipsis
(
selectedItem
[
selectedItem
.
length
-
1
]
)
;
this
.
_treePopupDelete
.
setAttribute
(
"
data
-
l10n
-
args
"
JSON
.
stringify
(
{
itemName
}
)
)
;
}
showMenu
=
showDeleteAll
|
|
showDelete
;
}
if
(
!
showMenu
)
{
event
.
preventDefault
(
)
;
}
}
onVariableViewPopupShowing
(
event
)
{
const
item
=
this
.
view
.
getFocusedItem
(
)
;
this
.
_variableViewPopupCopy
.
setAttribute
(
"
disabled
"
!
item
)
;
}
async
onRefreshTable
(
)
{
await
this
.
onHostSelect
(
this
.
tree
.
selectedItem
)
;
}
onAddItem
(
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
!
selectedItem
)
{
return
;
}
const
front
=
this
.
getCurrentFront
(
)
;
const
[
host
]
=
selectedItem
;
this
.
table
.
scrollIntoViewOnUpdate
=
true
;
this
.
table
.
editBookmark
=
createGUID
(
)
;
front
.
addItem
(
this
.
table
.
editBookmark
host
)
;
}
onCopyItem
(
)
{
this
.
view
.
_copyItem
(
)
;
}
onRemoveItem
(
event
)
{
const
[
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
uniqueId
=
this
.
table
.
uniqueId
;
const
rowId
=
event
.
type
=
=
"
command
"
?
this
.
table
.
contextMenuRowId
:
this
.
table
.
selectedRow
[
uniqueId
]
;
const
data
=
this
.
table
.
items
.
get
(
rowId
)
;
let
name
=
data
[
uniqueId
]
;
if
(
path
.
length
)
{
name
=
JSON
.
stringify
(
[
.
.
.
path
name
]
)
;
}
front
.
removeItem
(
host
name
)
;
return
false
;
}
onRemoveAll
(
)
{
const
[
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
name
=
path
.
length
?
JSON
.
stringify
(
path
)
:
undefined
;
front
.
removeAll
(
host
name
)
;
}
onRemoveAllSessionCookies
(
)
{
const
[
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
name
=
path
.
length
?
JSON
.
stringify
(
path
)
:
undefined
;
front
.
removeAllSessionCookies
(
host
name
)
;
}
onRemoveAllFrom
(
)
{
const
[
host
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
rowId
=
this
.
table
.
contextMenuRowId
;
const
data
=
this
.
table
.
items
.
get
(
rowId
)
;
front
.
removeAll
(
host
data
.
host
)
;
}
onRemoveTreeItem
(
)
{
const
[
type
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
if
(
type
=
=
"
indexedDB
"
&
&
path
.
length
=
=
1
)
{
this
.
removeDatabase
(
host
path
[
0
]
)
;
}
else
if
(
type
=
=
"
Cache
"
&
&
path
.
length
=
=
1
)
{
this
.
removeCache
(
host
path
[
0
]
)
;
}
}
async
removeDatabase
(
host
dbName
)
{
const
front
=
this
.
getCurrentFront
(
)
;
try
{
const
result
=
await
front
.
removeDatabase
(
host
dbName
)
;
if
(
result
.
blocked
)
{
const
notificationBox
=
this
.
_toolbox
.
getNotificationBox
(
)
;
const
message
=
await
this
.
_panelDoc
.
l10n
.
formatValue
(
"
storage
-
idb
-
delete
-
blocked
"
{
dbName
}
)
;
notificationBox
.
appendNotification
(
message
"
storage
-
idb
-
delete
-
blocked
"
null
notificationBox
.
PRIORITY_WARNING_LOW
)
;
}
}
catch
(
error
)
{
const
notificationBox
=
this
.
_toolbox
.
getNotificationBox
(
)
;
const
message
=
await
this
.
_panelDoc
.
l10n
.
formatValue
(
"
storage
-
idb
-
delete
-
error
"
{
dbName
}
)
;
notificationBox
.
appendNotification
(
message
"
storage
-
idb
-
delete
-
error
"
null
notificationBox
.
PRIORITY_CRITICAL_LOW
)
;
}
}
removeCache
(
host
cacheName
)
{
const
front
=
this
.
getCurrentFront
(
)
;
front
.
removeItem
(
host
JSON
.
stringify
(
[
cacheName
]
)
)
;
}
}
exports
.
StorageUI
=
StorageUI
;
function
createGUID
(
)
{
return
"
{
cccccccc
-
cccc
-
4ccc
-
yccc
-
cccccccccccc
}
"
.
replace
(
/
[
cy
]
/
g
c
=
>
{
const
r
=
(
Math
.
random
(
)
*
16
)
|
0
;
const
v
=
c
=
=
"
c
"
?
r
:
(
r
&
0x3
)
|
0x8
;
return
v
.
toString
(
16
)
;
}
)
;
}
function
addEllipsis
(
name
)
{
if
(
name
.
length
>
ITEM_NAME_MAX_LENGTH
)
{
if
(
/
^
https
?
:
/
.
test
(
name
)
)
{
const
halfLen
=
ITEM_NAME_MAX_LENGTH
/
2
;
return
name
.
slice
(
0
halfLen
)
+
ELLIPSIS
+
name
.
slice
(
-
halfLen
)
;
}
return
name
.
substr
(
0
ITEM_NAME_MAX_LENGTH
)
+
ELLIPSIS
;
}
return
name
;
}
