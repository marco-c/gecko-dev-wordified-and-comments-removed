"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
LocalizationHelper
ELLIPSIS
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
parseItemValue
}
=
require
(
"
devtools
/
shared
/
storage
/
utils
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
getUnicodeHostname
}
=
require
(
"
devtools
/
client
/
shared
/
unicode
-
url
"
)
;
const
getStorageTypeURL
=
require
(
"
devtools
/
client
/
storage
/
utils
/
mdn
-
utils
"
)
;
const
SEPARATOR_GUID
=
"
{
9d414cc5
-
8319
-
0a04
-
0586
-
c0a6ae01670a
}
"
;
loader
.
lazyRequireGetter
(
this
"
TreeWidget
"
"
devtools
/
client
/
shared
/
widgets
/
TreeWidget
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TableWidget
"
"
devtools
/
client
/
shared
/
widgets
/
TableWidget
"
true
)
;
loader
.
lazyImporter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
storage
/
VariablesView
.
jsm
"
)
;
const
STORAGE_STRINGS
=
"
devtools
/
client
/
locales
/
storage
.
properties
"
;
const
L10N
=
new
LocalizationHelper
(
STORAGE_STRINGS
true
)
;
const
GENERIC_VARIABLES_VIEW_SETTINGS
=
{
lazyEmpty
:
true
lazyEmptyDelay
:
10
searchEnabled
:
true
contextMenuId
:
"
variable
-
view
-
popup
"
searchPlaceholder
:
L10N
.
getStr
(
"
storage
.
search
.
placeholder
"
)
preventDescriptorModifiers
:
true
}
;
const
REASON
=
{
NEW_ROW
:
"
new
-
row
"
NEXT_50_ITEMS
:
"
next
-
50
-
items
"
POPULATE
:
"
populate
"
UPDATE
:
"
update
"
}
;
const
ITEM_NAME_MAX_LENGTH
=
32
;
const
NON_L10N_STRINGS
=
new
Map
(
[
[
"
Cache
.
url
"
"
URL
"
]
[
"
cookies
.
host
"
"
Domain
"
]
[
"
cookies
.
hostOnly
"
"
HostOnly
"
]
[
"
cookies
.
isHttpOnly
"
"
HttpOnly
"
]
[
"
cookies
.
isSecure
"
"
Secure
"
]
[
"
cookies
.
path
"
"
Path
"
]
[
"
cookies
.
sameSite
"
"
SameSite
"
]
[
"
cookies
.
uniqueKey
"
"
Unique
key
"
]
[
"
extensionStorage
.
name
"
"
Key
"
]
[
"
extensionStorage
.
value
"
"
Value
"
]
[
"
indexedDB
.
autoIncrement
"
"
Auto
Increment
"
]
[
"
indexedDB
.
db
"
"
Database
Name
"
]
[
"
indexedDB
.
indexes
"
"
Indexes
"
]
[
"
indexedDB
.
keyPath
"
"
Key
Path
"
]
[
"
indexedDB
.
name
"
"
Key
"
]
[
"
indexedDB
.
objectStore
"
"
Object
Store
Name
"
]
[
"
indexedDB
.
objectStores
"
"
Object
Stores
"
]
[
"
indexedDB
.
origin
"
"
Origin
"
]
[
"
indexedDB
.
storage
"
"
Storage
"
]
[
"
indexedDB
.
uniqueKey
"
"
Unique
key
"
]
[
"
indexedDB
.
value
"
"
Value
"
]
[
"
indexedDB
.
version
"
"
Version
"
]
[
"
localStorage
.
name
"
"
Key
"
]
[
"
localStorage
.
value
"
"
Value
"
]
[
"
sessionStorage
.
name
"
"
Key
"
]
[
"
sessionStorage
.
value
"
"
Value
"
]
]
)
;
const
NON_ORIGINAL_L10N_IDS
=
new
Map
(
[
[
"
cookies
.
expires
"
"
cookies
.
expires2
"
]
[
"
cookies
.
lastAccessed
"
"
cookies
.
lastAccessed2
"
]
[
"
cookies
.
creationTime
"
"
cookies
.
creationTime2
"
]
[
"
indexedDB
.
keyPath
"
"
indexedDB
.
keyPath2
"
]
]
)
;
class
StorageUI
{
constructor
(
panelWin
toolbox
commands
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_window
=
panelWin
;
this
.
_panelDoc
=
panelWin
.
document
;
this
.
_toolbox
=
toolbox
;
this
.
_commands
=
commands
;
this
.
sidebarToggledOpen
=
null
;
this
.
shouldLoadMoreItems
=
true
;
const
treeNode
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
"
)
;
this
.
tree
=
new
TreeWidget
(
treeNode
{
defaultType
:
"
dir
"
contextMenuId
:
"
storage
-
tree
-
popup
"
}
)
;
this
.
onHostSelect
=
this
.
onHostSelect
.
bind
(
this
)
;
this
.
tree
.
on
(
"
select
"
this
.
onHostSelect
)
;
const
tableNode
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
"
)
;
this
.
table
=
new
TableWidget
(
tableNode
{
emptyText
:
"
storage
-
table
-
empty
-
text
"
highlightUpdated
:
true
cellContextMenuId
:
"
storage
-
table
-
popup
"
l10n
:
this
.
_panelDoc
.
l10n
}
)
;
this
.
updateObjectSidebar
=
this
.
updateObjectSidebar
.
bind
(
this
)
;
this
.
table
.
on
(
TableWidget
.
EVENTS
.
ROW_SELECTED
this
.
updateObjectSidebar
)
;
this
.
handleScrollEnd
=
this
.
handleScrollEnd
.
bind
(
this
)
;
this
.
table
.
on
(
TableWidget
.
EVENTS
.
SCROLL_END
this
.
handleScrollEnd
)
;
this
.
editItem
=
this
.
editItem
.
bind
(
this
)
;
this
.
table
.
on
(
TableWidget
.
EVENTS
.
CELL_EDIT
this
.
editItem
)
;
this
.
sidebar
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
sidebar
"
)
;
this
.
sidebar
.
setAttribute
(
"
width
"
"
300
"
)
;
this
.
view
=
new
VariablesView
(
this
.
sidebar
.
firstChild
GENERIC_VARIABLES_VIEW_SETTINGS
)
;
this
.
filterItems
=
this
.
filterItems
.
bind
(
this
)
;
this
.
onPaneToggleButtonClicked
=
this
.
onPaneToggleButtonClicked
.
bind
(
this
)
;
this
.
setupToolbar
(
)
;
const
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
_panelDoc
.
defaultView
}
)
;
const
key
=
L10N
.
getStr
(
"
storage
.
filter
.
key
"
)
;
shortcuts
.
on
(
key
event
=
>
{
event
.
preventDefault
(
)
;
this
.
searchBox
.
focus
(
)
;
}
)
;
this
.
handleKeypress
=
this
.
handleKeypress
.
bind
(
this
)
;
this
.
_panelDoc
.
addEventListener
(
"
keypress
"
this
.
handleKeypress
)
;
this
.
onTreePopupShowing
=
this
.
onTreePopupShowing
.
bind
(
this
)
;
this
.
_treePopup
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
"
)
;
this
.
_treePopup
.
addEventListener
(
"
popupshowing
"
this
.
onTreePopupShowing
)
;
this
.
onTablePopupShowing
=
this
.
onTablePopupShowing
.
bind
(
this
)
;
this
.
_tablePopup
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
"
)
;
this
.
_tablePopup
.
addEventListener
(
"
popupshowing
"
this
.
onTablePopupShowing
)
;
this
.
onVariableViewPopupShowing
=
this
.
onVariableViewPopupShowing
.
bind
(
this
)
;
this
.
_variableViewPopup
=
this
.
_panelDoc
.
getElementById
(
"
variable
-
view
-
popup
"
)
;
this
.
_variableViewPopup
.
addEventListener
(
"
popupshowing
"
this
.
onVariableViewPopupShowing
)
;
this
.
onRefreshTable
=
this
.
onRefreshTable
.
bind
(
this
)
;
this
.
onAddItem
=
this
.
onAddItem
.
bind
(
this
)
;
this
.
onCopyItem
=
this
.
onCopyItem
.
bind
(
this
)
;
this
.
onRemoveItem
=
this
.
onRemoveItem
.
bind
(
this
)
;
this
.
onRemoveAllFrom
=
this
.
onRemoveAllFrom
.
bind
(
this
)
;
this
.
onRemoveAll
=
this
.
onRemoveAll
.
bind
(
this
)
;
this
.
onRemoveAllSessionCookies
=
this
.
onRemoveAllSessionCookies
.
bind
(
this
)
;
this
.
onRemoveTreeItem
=
this
.
onRemoveTreeItem
.
bind
(
this
)
;
this
.
_refreshButton
=
this
.
_panelDoc
.
getElementById
(
"
refresh
-
button
"
)
;
this
.
_refreshButton
.
addEventListener
(
"
click
"
this
.
onRefreshTable
)
;
this
.
_refreshButton
.
setAttribute
(
"
title
"
L10N
.
getFormatStr
(
"
storage
.
popupMenu
.
refreshItemLabel
"
)
)
;
this
.
_addButton
=
this
.
_panelDoc
.
getElementById
(
"
add
-
button
"
)
;
this
.
_addButton
.
addEventListener
(
"
click
"
this
.
onAddItem
)
;
this
.
_variableViewPopupCopy
=
this
.
_panelDoc
.
getElementById
(
"
variable
-
view
-
popup
-
copy
"
)
;
this
.
_variableViewPopupCopy
.
addEventListener
(
"
command
"
this
.
onCopyItem
)
;
this
.
_tablePopupAddItem
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
add
"
)
;
this
.
_tablePopupAddItem
.
addEventListener
(
"
command
"
this
.
onAddItem
)
;
this
.
_tablePopupDelete
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
"
)
;
this
.
_tablePopupDelete
.
addEventListener
(
"
command
"
this
.
onRemoveItem
)
;
this
.
_tablePopupDeleteAllFrom
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
-
all
-
from
"
)
;
this
.
_tablePopupDeleteAllFrom
.
addEventListener
(
"
command
"
this
.
onRemoveAllFrom
)
;
this
.
_tablePopupDeleteAll
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
-
all
"
)
;
this
.
_tablePopupDeleteAll
.
addEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_tablePopupDeleteAllSessionCookies
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
table
-
popup
-
delete
-
all
-
session
-
cookies
"
)
;
this
.
_tablePopupDeleteAllSessionCookies
.
addEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
this
.
_treePopupDeleteAll
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
-
delete
-
all
"
)
;
this
.
_treePopupDeleteAll
.
addEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_treePopupDeleteAllSessionCookies
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
-
delete
-
all
-
session
-
cookies
"
)
;
this
.
_treePopupDeleteAllSessionCookies
.
addEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
this
.
_treePopupDelete
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
tree
-
popup
-
delete
"
)
;
this
.
_treePopupDelete
.
addEventListener
(
"
command
"
this
.
onRemoveTreeItem
)
;
}
get
currentTarget
(
)
{
return
this
.
_toolbox
.
targetList
.
targetFront
;
}
async
init
(
)
{
this
.
storageResources
=
{
}
;
const
{
targetList
}
=
this
.
_toolbox
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
await
targetList
.
watchTargets
(
[
targetList
.
TYPES
.
FRAME
]
this
.
_onTargetAvailable
this
.
_onTargetDestroyed
)
;
this
.
_onResourceListAvailable
=
this
.
_onResourceListAvailable
.
bind
(
this
)
;
const
{
resourceWatcher
}
=
this
.
_toolbox
;
await
this
.
_toolbox
.
resourceWatcher
.
watchResources
(
[
resourceWatcher
.
TYPES
.
COOKIE
resourceWatcher
.
TYPES
.
CACHE_STORAGE
resourceWatcher
.
TYPES
.
EXTENSION_STORAGE
resourceWatcher
.
TYPES
.
INDEXED_DB
resourceWatcher
.
TYPES
.
LOCAL_STORAGE
resourceWatcher
.
TYPES
.
SESSION_STORAGE
]
{
onAvailable
:
this
.
_onResourceListAvailable
}
)
;
}
async
_onTargetAvailable
(
{
targetFront
}
)
{
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
this
.
front
=
await
targetFront
.
getFront
(
"
storage
"
)
;
}
async
_onResourceListAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
const
{
resourceKey
}
=
resource
;
if
(
!
this
.
storageResources
[
resourceKey
]
)
{
this
.
storageResources
[
resourceKey
]
=
[
]
;
}
this
.
storageResources
[
resourceKey
]
.
push
(
resource
)
;
resource
.
on
(
"
single
-
store
-
update
"
this
.
_onStoreUpdate
.
bind
(
this
resource
)
)
;
resource
.
on
(
"
single
-
store
-
cleared
"
this
.
_onStoreCleared
.
bind
(
this
resource
)
)
;
}
try
{
await
this
.
populateStorageTree
(
)
;
}
catch
(
e
)
{
if
(
!
this
.
_toolbox
|
|
this
.
_toolbox
.
_destroyer
)
{
return
;
}
console
.
error
(
e
)
;
}
}
_onTargetDestroyed
(
{
targetFront
}
)
{
for
(
const
type
in
this
.
storageResources
)
{
this
.
storageResources
[
type
]
=
this
.
storageResources
[
type
]
.
filter
(
storage
=
>
{
return
!
storage
.
isDestroyed
(
)
&
&
storage
.
targetFront
!
=
targetFront
;
}
)
;
}
if
(
!
targetFront
.
isTopLevel
)
{
return
;
}
this
.
storageResources
=
{
}
;
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
tree
.
clear
(
)
;
}
set
animationsEnabled
(
value
)
{
this
.
_panelDoc
.
documentElement
.
classList
.
toggle
(
"
no
-
animate
"
!
value
)
;
}
destroy
(
)
{
const
{
resourceWatcher
}
=
this
.
_toolbox
;
resourceWatcher
.
unwatchResources
(
[
resourceWatcher
.
TYPES
.
COOKIE
resourceWatcher
.
TYPES
.
CACHE_STORAGE
resourceWatcher
.
TYPES
.
EXTENSION_STORAGE
resourceWatcher
.
TYPES
.
INDEXED_DB
resourceWatcher
.
TYPES
.
LOCAL_STORAGE
resourceWatcher
.
TYPES
.
SESSION_STORAGE
]
{
onAvailable
:
this
.
_onResourceListAvailable
}
)
;
this
.
table
.
off
(
TableWidget
.
EVENTS
.
ROW_SELECTED
this
.
updateObjectSidebar
)
;
this
.
table
.
off
(
TableWidget
.
EVENTS
.
SCROLL_END
this
.
handleScrollEnd
)
;
this
.
table
.
off
(
TableWidget
.
EVENTS
.
CELL_EDIT
this
.
editItem
)
;
this
.
table
.
destroy
(
)
;
this
.
_panelDoc
.
removeEventListener
(
"
keypress
"
this
.
handleKeypress
)
;
this
.
searchBox
.
removeEventListener
(
"
input
"
this
.
filterItems
)
;
this
.
searchBox
=
null
;
this
.
sidebarToggleBtn
.
removeEventListener
(
"
click
"
this
.
onPaneToggleButtonClicked
)
;
this
.
sidebarToggleBtn
=
null
;
this
.
_treePopup
.
removeEventListener
(
"
popupshowing
"
this
.
onTreePopupShowing
)
;
this
.
_refreshButton
.
removeEventListener
(
"
click
"
this
.
onRefreshTable
)
;
this
.
_addButton
.
removeEventListener
(
"
click
"
this
.
onAddItem
)
;
this
.
_tablePopupAddItem
.
removeEventListener
(
"
command
"
this
.
onAddItem
)
;
this
.
_treePopupDeleteAll
.
removeEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_treePopupDeleteAllSessionCookies
.
removeEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
this
.
_treePopupDelete
.
removeEventListener
(
"
command
"
this
.
onRemoveTreeItem
)
;
this
.
_tablePopup
.
removeEventListener
(
"
popupshowing
"
this
.
onTablePopupShowing
)
;
this
.
_tablePopupDelete
.
removeEventListener
(
"
command
"
this
.
onRemoveItem
)
;
this
.
_tablePopupDeleteAllFrom
.
removeEventListener
(
"
command
"
this
.
onRemoveAllFrom
)
;
this
.
_tablePopupDeleteAll
.
removeEventListener
(
"
command
"
this
.
onRemoveAll
)
;
this
.
_tablePopupDeleteAllSessionCookies
.
removeEventListener
(
"
command
"
this
.
onRemoveAllSessionCookies
)
;
}
setupToolbar
(
)
{
this
.
searchBox
=
this
.
_panelDoc
.
getElementById
(
"
storage
-
searchbox
"
)
;
this
.
searchBox
.
addEventListener
(
"
input
"
this
.
filterItems
)
;
this
.
sidebarToggleBtn
=
this
.
_panelDoc
.
querySelector
(
"
.
sidebar
-
toggle
"
)
;
this
.
updateSidebarToggleButton
(
)
;
this
.
sidebarToggleBtn
.
addEventListener
(
"
click
"
this
.
onPaneToggleButtonClicked
)
;
}
onPaneToggleButtonClicked
(
)
{
if
(
this
.
sidebar
.
hidden
&
&
this
.
table
.
selectedRow
)
{
this
.
sidebar
.
hidden
=
false
;
this
.
sidebarToggledOpen
=
true
;
this
.
updateSidebarToggleButton
(
)
;
}
else
{
this
.
sidebarToggledOpen
=
false
;
this
.
hideSidebar
(
)
;
}
}
updateSidebarToggleButton
(
)
{
let
title
;
this
.
sidebarToggleBtn
.
hidden
=
!
this
.
table
.
hasSelectedRow
;
if
(
this
.
sidebar
.
hidden
)
{
this
.
sidebarToggleBtn
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
title
=
L10N
.
getStr
(
"
storage
.
expandPane
"
)
;
}
else
{
this
.
sidebarToggleBtn
.
classList
.
remove
(
"
pane
-
collapsed
"
)
;
title
=
L10N
.
getStr
(
"
storage
.
collapsePane
"
)
;
}
this
.
sidebarToggleBtn
.
setAttribute
(
"
title
"
title
)
;
}
hideSidebar
(
)
{
this
.
sidebar
.
hidden
=
true
;
this
.
updateSidebarToggleButton
(
)
;
}
getCurrentFront
(
)
{
const
{
datatype
host
}
=
this
.
table
;
return
this
.
_getStorage
(
datatype
host
)
;
}
_getStorage
(
type
host
)
{
const
storageType
=
this
.
storageResources
[
type
]
;
return
storageType
.
find
(
x
=
>
host
in
x
.
hosts
)
;
}
makeFieldsEditable
(
editableFields
)
{
if
(
editableFields
&
&
editableFields
.
length
>
0
)
{
this
.
table
.
makeFieldsEditable
(
editableFields
)
;
}
else
if
(
this
.
table
.
_editableFieldsEngine
)
{
this
.
table
.
_editableFieldsEngine
.
destroy
(
)
;
}
}
editItem
(
data
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
!
selectedItem
)
{
return
;
}
const
front
=
this
.
getCurrentFront
(
)
;
front
.
editItem
(
data
)
;
}
async
removeItemFromTable
(
name
)
{
if
(
this
.
table
.
isSelected
(
name
)
&
&
this
.
table
.
items
.
size
>
1
)
{
if
(
this
.
table
.
selectedIndex
=
=
0
)
{
this
.
table
.
selectNextRow
(
)
;
}
else
{
this
.
table
.
selectPreviousRow
(
)
;
}
}
this
.
table
.
remove
(
name
)
;
await
this
.
updateObjectSidebar
(
)
;
}
_onStoreCleared
(
resource
{
clearedHostsOrPaths
}
)
{
const
{
resourceKey
}
=
resource
;
function
*
enumPaths
(
)
{
if
(
Array
.
isArray
(
clearedHostsOrPaths
)
)
{
for
(
const
host
of
clearedHostsOrPaths
)
{
yield
[
host
]
;
}
}
else
{
for
(
const
host
in
clearedHostsOrPaths
)
{
const
paths
=
clearedHostsOrPaths
[
host
]
;
if
(
!
paths
.
length
)
{
yield
[
host
]
;
}
else
{
for
(
let
path
of
paths
)
{
try
{
path
=
JSON
.
parse
(
path
)
;
yield
[
host
.
.
.
path
]
;
}
catch
(
ex
)
{
}
}
}
}
}
}
for
(
const
path
of
enumPaths
(
)
)
{
if
(
this
.
tree
.
isSelected
(
[
resourceKey
.
.
.
path
]
)
)
{
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
itemOffset
=
0
;
this
.
emit
(
"
store
-
objects
-
cleared
"
)
;
break
;
}
}
}
async
_onStoreUpdate
(
resource
update
)
{
const
{
changed
added
deleted
}
=
update
;
if
(
added
)
{
await
this
.
handleAddedItems
(
added
)
;
}
if
(
changed
)
{
await
this
.
handleChangedItems
(
changed
)
;
}
if
(
deleted
)
{
await
this
.
handleDeletedItems
(
deleted
)
;
}
if
(
added
|
|
deleted
|
|
changed
)
{
this
.
emit
(
"
store
-
objects
-
edit
"
)
;
}
}
async
handleAddedItems
(
added
)
{
for
(
const
type
in
added
)
{
for
(
const
host
in
added
[
type
]
)
{
const
label
=
this
.
getReadableLabelFromHostname
(
host
)
;
this
.
tree
.
add
(
[
type
{
id
:
host
label
:
label
type
:
"
url
"
}
]
)
;
for
(
let
name
of
added
[
type
]
[
host
]
)
{
try
{
name
=
JSON
.
parse
(
name
)
;
if
(
name
.
length
=
=
3
)
{
name
.
splice
(
2
1
)
;
}
this
.
tree
.
add
(
[
type
host
.
.
.
name
]
)
;
if
(
!
this
.
tree
.
selectedItem
)
{
this
.
tree
.
selectedItem
=
[
type
host
name
[
0
]
name
[
1
]
]
;
await
this
.
fetchStorageObjects
(
type
host
[
JSON
.
stringify
(
name
)
]
REASON
.
NEW_ROW
)
;
}
}
catch
(
ex
)
{
}
}
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
await
this
.
fetchStorageObjects
(
type
host
added
[
type
]
[
host
]
REASON
.
NEW_ROW
)
;
}
}
}
}
async
handleDeletedItems
(
deleted
)
{
for
(
const
type
in
deleted
)
{
for
(
const
host
in
deleted
[
type
]
)
{
if
(
!
deleted
[
type
]
[
host
]
.
length
)
{
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
tree
.
selectPreviousItem
(
)
;
}
this
.
tree
.
remove
(
[
type
host
]
)
;
}
else
{
for
(
const
name
of
deleted
[
type
]
[
host
]
)
{
try
{
if
(
[
"
indexedDB
"
"
Cache
"
]
.
includes
(
type
)
)
{
const
names
=
JSON
.
parse
(
name
)
;
if
(
names
.
length
<
3
)
{
if
(
this
.
tree
.
isSelected
(
[
type
host
.
.
.
names
]
)
)
{
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
tree
.
selectPreviousItem
(
)
;
}
this
.
tree
.
remove
(
[
type
host
.
.
.
names
]
)
;
}
if
(
names
.
length
>
0
)
{
const
tableItemName
=
names
.
pop
(
)
;
if
(
this
.
tree
.
isSelected
(
[
type
host
.
.
.
names
]
)
)
{
await
this
.
removeItemFromTable
(
tableItemName
)
;
}
}
}
else
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
await
this
.
removeItemFromTable
(
name
)
;
}
}
catch
(
ex
)
{
if
(
this
.
tree
.
isSelected
(
[
type
host
]
)
)
{
await
this
.
removeItemFromTable
(
name
)
;
}
}
}
}
}
}
}
async
handleChangedItems
(
changed
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
!
selectedItem
)
{
return
;
}
const
[
type
host
db
objectStore
]
=
selectedItem
;
if
(
!
changed
[
type
]
|
|
!
changed
[
type
]
[
host
]
|
|
changed
[
type
]
[
host
]
.
length
=
=
0
)
{
return
;
}
try
{
const
toUpdate
=
[
]
;
for
(
const
name
of
changed
[
type
]
[
host
]
)
{
if
(
[
"
indexedDB
"
"
Cache
"
]
.
includes
(
type
)
)
{
const
names
=
JSON
.
parse
(
name
)
;
if
(
names
[
0
]
=
=
db
&
&
names
[
1
]
=
=
objectStore
&
&
names
[
2
]
)
{
toUpdate
.
push
(
name
)
;
}
}
else
{
toUpdate
.
push
(
name
)
;
}
}
await
this
.
fetchStorageObjects
(
type
host
toUpdate
REASON
.
UPDATE
)
;
}
catch
(
ex
)
{
await
this
.
fetchStorageObjects
(
type
host
changed
[
type
]
[
host
]
REASON
.
UPDATE
)
;
}
}
async
fetchStorageObjects
(
type
host
names
reason
)
{
const
fetchOpts
=
reason
=
=
=
REASON
.
NEXT_50_ITEMS
?
{
offset
:
this
.
itemOffset
}
:
{
}
;
const
storage
=
this
.
_getStorage
(
type
host
)
;
this
.
sidebarToggledOpen
=
null
;
if
(
reason
!
=
=
REASON
.
NEXT_50_ITEMS
&
&
reason
!
=
=
REASON
.
UPDATE
&
&
reason
!
=
=
REASON
.
NEW_ROW
&
&
reason
!
=
=
REASON
.
POPULATE
)
{
throw
new
Error
(
"
Invalid
reason
specified
"
)
;
}
try
{
if
(
reason
=
=
=
REASON
.
POPULATE
|
|
(
reason
=
=
=
REASON
.
NEW_ROW
&
&
this
.
table
.
items
.
size
=
=
=
0
)
)
{
let
subType
=
null
;
if
(
type
=
=
=
"
indexedDB
"
&
&
names
)
{
const
[
dbName
objectStoreName
]
=
JSON
.
parse
(
names
[
0
]
)
;
if
(
dbName
)
{
subType
=
"
database
"
;
}
if
(
objectStoreName
)
{
subType
=
"
object
store
"
;
}
}
await
this
.
resetColumns
(
type
host
subType
)
;
}
const
{
data
}
=
await
storage
.
getStoreObjects
(
host
names
fetchOpts
)
;
if
(
data
.
length
)
{
await
this
.
populateTable
(
data
reason
)
;
}
else
if
(
reason
=
=
=
REASON
.
POPULATE
)
{
await
this
.
clearHeaders
(
)
;
}
this
.
updateToolbar
(
)
;
this
.
emit
(
"
store
-
objects
-
updated
"
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
}
supportsAddItem
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsAddItem
|
|
false
;
}
supportsRemoveItem
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsRemoveItem
|
|
false
;
}
supportsRemoveAll
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsRemoveAll
|
|
false
;
}
supportsRemoveAllSessionCookies
(
type
host
)
{
const
storage
=
this
.
_getStorage
(
type
host
)
;
return
storage
?
.
traits
.
supportsRemoveAllSessionCookies
|
|
false
;
}
updateToolbar
(
)
{
const
item
=
this
.
tree
.
selectedItem
;
if
(
!
item
)
{
return
;
}
const
[
type
host
]
=
item
;
const
canAdd
=
this
.
supportsAddItem
(
type
host
)
&
&
host
;
if
(
canAdd
)
{
this
.
_addButton
.
hidden
=
false
;
this
.
_addButton
.
setAttribute
(
"
title
"
L10N
.
getFormatStr
(
"
storage
.
popupMenu
.
addItemLabel
"
)
)
;
}
else
{
this
.
_addButton
.
hidden
=
true
;
this
.
_addButton
.
removeAttribute
(
"
title
"
)
;
}
}
async
populateStorageTree
(
)
{
const
populateTreeFromResource
=
(
type
resource
)
=
>
{
for
(
const
host
in
resource
.
hosts
)
{
const
label
=
this
.
getReadableLabelFromHostname
(
host
)
;
this
.
tree
.
add
(
[
type
{
id
:
host
label
:
label
type
:
"
url
"
}
]
)
;
for
(
const
name
of
resource
.
hosts
[
host
]
)
{
try
{
const
names
=
JSON
.
parse
(
name
)
;
this
.
tree
.
add
(
[
type
host
.
.
.
names
]
)
;
if
(
!
this
.
tree
.
selectedItem
)
{
this
.
tree
.
selectedItem
=
[
type
host
names
[
0
]
names
[
1
]
]
;
}
}
catch
(
ex
)
{
}
}
if
(
!
this
.
tree
.
selectedItem
)
{
this
.
tree
.
selectedItem
=
[
type
host
]
;
}
}
}
;
const
onStoresObjectsUpdated
=
this
.
once
(
"
store
-
objects
-
updated
"
)
;
const
initialSelectedItem
=
this
.
tree
.
selectedItem
;
for
(
const
[
type
resources
]
of
Object
.
entries
(
this
.
storageResources
)
)
{
let
typeLabel
=
type
;
try
{
typeLabel
=
L10N
.
getStr
(
"
tree
.
labels
.
"
+
type
)
;
}
catch
(
e
)
{
console
.
error
(
"
Unable
to
localize
tree
label
type
:
"
+
type
)
;
}
this
.
tree
.
add
(
[
{
id
:
type
label
:
typeLabel
type
:
"
store
"
}
]
)
;
for
(
const
resource
of
resources
)
{
populateTreeFromResource
(
type
resource
)
;
}
}
if
(
initialSelectedItem
!
=
=
this
.
tree
.
selectedItem
)
{
await
onStoresObjectsUpdated
;
}
}
async
updateObjectSidebar
(
)
{
const
item
=
this
.
table
.
selectedRow
;
let
value
;
if
(
item
?
.
name
&
&
item
?
.
valueActor
)
{
value
=
await
item
.
valueActor
.
string
(
)
;
}
if
(
this
.
table
.
items
.
size
=
=
=
0
|
|
!
item
|
|
!
this
.
table
.
selectedRow
|
|
item
.
uniqueKey
!
=
=
this
.
table
.
selectedRow
.
uniqueKey
)
{
this
.
hideSidebar
(
)
;
return
;
}
if
(
this
.
sidebarToggledOpen
=
=
=
null
|
|
this
.
sidebarToggledOpen
=
=
=
true
)
{
this
.
sidebar
.
hidden
=
false
;
}
this
.
updateSidebarToggleButton
(
)
;
this
.
view
.
empty
(
)
;
const
mainScope
=
this
.
view
.
addScope
(
L10N
.
getStr
(
"
storage
.
data
.
label
"
)
)
;
mainScope
.
expanded
=
true
;
if
(
value
)
{
const
itemVar
=
mainScope
.
addItem
(
item
.
name
+
"
"
{
}
{
relaxed
:
true
}
)
;
itemVar
.
setGrip
(
value
)
;
const
obj
=
parseItemValue
(
value
)
;
if
(
typeof
obj
=
=
=
"
object
"
)
{
this
.
populateSidebar
(
item
.
name
obj
)
;
}
const
itemProps
=
Object
.
keys
(
item
)
;
if
(
itemProps
.
length
>
3
)
{
const
rawObject
=
Object
.
create
(
null
)
;
const
otherProps
=
itemProps
.
filter
(
e
=
>
!
[
"
name
"
"
value
"
"
valueActor
"
]
.
includes
(
e
)
)
;
for
(
const
prop
of
otherProps
)
{
const
column
=
this
.
table
.
columns
.
get
(
prop
)
;
if
(
column
?
.
private
)
{
continue
;
}
const
fieldName
=
getColumnName
(
this
.
table
.
datatype
prop
)
;
rawObject
[
fieldName
]
=
item
[
prop
]
;
}
itemVar
.
populate
(
rawObject
{
sorted
:
true
}
)
;
itemVar
.
twisty
=
true
;
itemVar
.
expanded
=
true
;
}
}
else
{
for
(
const
key
in
item
)
{
const
column
=
this
.
table
.
columns
.
get
(
key
)
;
if
(
column
?
.
private
)
{
continue
;
}
mainScope
.
addItem
(
key
{
}
true
)
.
setGrip
(
item
[
key
]
)
;
const
obj
=
parseItemValue
(
item
[
key
]
)
;
if
(
typeof
obj
=
=
=
"
object
"
)
{
this
.
populateSidebar
(
item
.
name
obj
)
;
}
}
}
this
.
emit
(
"
sidebar
-
updated
"
)
;
}
getReadableLabelFromHostname
(
host
)
{
try
{
const
{
hostname
}
=
new
URL
(
host
)
;
const
unicodeHostname
=
getUnicodeHostname
(
hostname
)
;
if
(
hostname
!
=
=
unicodeHostname
)
{
return
host
.
replace
(
hostname
unicodeHostname
)
+
"
[
"
+
host
+
"
]
"
;
}
}
catch
(
_
)
{
}
return
host
;
}
populateSidebar
(
name
obj
)
{
const
jsonObject
=
Object
.
create
(
null
)
;
const
view
=
this
.
view
;
jsonObject
[
name
]
=
obj
;
const
valueScope
=
view
.
getScopeAtIndex
(
1
)
|
|
view
.
addScope
(
L10N
.
getStr
(
"
storage
.
parsedValue
.
label
"
)
)
;
valueScope
.
expanded
=
true
;
const
jsonVar
=
valueScope
.
addItem
(
"
"
Object
.
create
(
null
)
{
relaxed
:
true
}
)
;
jsonVar
.
expanded
=
true
;
jsonVar
.
twisty
=
true
;
jsonVar
.
populate
(
jsonObject
{
expanded
:
true
}
)
;
}
async
onHostSelect
(
item
)
{
if
(
!
item
)
{
return
;
}
this
.
table
.
clear
(
)
;
this
.
hideSidebar
(
)
;
this
.
searchBox
.
value
=
"
"
;
const
[
type
host
]
=
item
;
this
.
table
.
host
=
host
;
this
.
table
.
datatype
=
type
;
this
.
updateToolbar
(
)
;
let
names
=
null
;
if
(
!
host
)
{
let
storageTypeHintL10nId
=
"
"
;
switch
(
type
)
{
case
"
Cache
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
cache
-
hint
"
;
break
;
case
"
cookies
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
cookies
-
hint
"
;
break
;
case
"
extensionStorage
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
extensionstorage
-
hint
"
;
break
;
case
"
localStorage
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
localstorage
-
hint
"
;
break
;
case
"
indexedDB
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
indexeddb
-
hint
"
;
break
;
case
"
sessionStorage
"
:
storageTypeHintL10nId
=
"
storage
-
table
-
type
-
sessionstorage
-
hint
"
;
break
;
}
this
.
table
.
setPlaceholder
(
storageTypeHintL10nId
getStorageTypeURL
(
this
.
table
.
datatype
)
+
"
?
utm_source
=
devtools
&
utm_medium
=
storage
-
inspector
"
)
;
await
this
.
clearHeaders
(
)
;
return
;
}
if
(
item
.
length
>
2
)
{
names
=
[
JSON
.
stringify
(
item
.
slice
(
2
)
)
]
;
}
await
this
.
fetchStorageObjects
(
type
host
names
REASON
.
POPULATE
)
;
this
.
itemOffset
=
0
;
}
async
clearHeaders
(
)
{
this
.
table
.
setColumns
(
{
}
null
{
}
{
}
)
;
}
async
resetColumns
(
type
host
subtype
)
{
this
.
table
.
host
=
host
;
this
.
table
.
datatype
=
type
;
let
uniqueKey
=
null
;
const
columns
=
{
}
;
const
editableFields
=
[
]
;
const
hiddenFields
=
[
]
;
const
privateFields
=
[
]
;
const
fields
=
await
this
.
getCurrentFront
(
)
.
getFields
(
subtype
)
;
fields
.
forEach
(
f
=
>
{
if
(
!
uniqueKey
)
{
this
.
table
.
uniqueId
=
uniqueKey
=
f
.
name
;
}
if
(
f
.
editable
)
{
editableFields
.
push
(
f
.
name
)
;
}
if
(
f
.
hidden
)
{
hiddenFields
.
push
(
f
.
name
)
;
}
if
(
f
.
private
)
{
privateFields
.
push
(
f
.
name
)
;
}
const
columnName
=
getColumnName
(
type
f
.
name
)
;
if
(
columnName
)
{
columns
[
f
.
name
]
=
columnName
;
}
else
if
(
!
f
.
private
)
{
columns
[
f
.
name
]
=
f
.
name
;
console
.
error
(
No
string
defined
in
NON_L10N_STRINGS
for
'
{
type
}
.
{
f
.
name
}
'
)
;
}
}
)
;
this
.
table
.
setColumns
(
columns
null
hiddenFields
privateFields
)
;
this
.
hideSidebar
(
)
;
this
.
makeFieldsEditable
(
editableFields
)
;
}
async
populateTable
(
data
reason
)
{
for
(
const
item
of
data
)
{
if
(
item
.
value
)
{
item
.
valueActor
=
item
.
value
;
item
.
value
=
item
.
value
.
initial
|
|
"
"
;
}
if
(
item
.
expires
!
=
null
)
{
item
.
expires
=
item
.
expires
?
new
Date
(
item
.
expires
)
.
toUTCString
(
)
:
L10N
.
getStr
(
"
label
.
expires
.
session
"
)
;
}
if
(
item
.
creationTime
!
=
null
)
{
item
.
creationTime
=
new
Date
(
item
.
creationTime
)
.
toUTCString
(
)
;
}
if
(
item
.
lastAccessed
!
=
null
)
{
item
.
lastAccessed
=
new
Date
(
item
.
lastAccessed
)
.
toUTCString
(
)
;
}
switch
(
reason
)
{
case
REASON
.
POPULATE
:
case
REASON
.
NEXT_50_ITEMS
:
this
.
table
.
push
(
item
true
)
;
break
;
case
REASON
.
NEW_ROW
:
this
.
table
.
push
(
item
false
)
;
break
;
case
REASON
.
UPDATE
:
this
.
table
.
update
(
item
)
;
if
(
item
=
=
this
.
table
.
selectedRow
&
&
!
this
.
sidebar
.
hidden
)
{
await
this
.
updateObjectSidebar
(
)
;
}
break
;
}
this
.
shouldLoadMoreItems
=
true
;
}
}
handleKeypress
(
event
)
{
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
if
(
!
this
.
sidebar
.
hidden
)
{
this
.
hideSidebar
(
)
;
this
.
sidebarToggledOpen
=
false
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
else
if
(
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_BACK_SPACE
|
|
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_DELETE
)
{
if
(
this
.
table
.
selectedRow
&
&
event
.
target
.
localName
!
=
"
input
"
)
{
this
.
onRemoveItem
(
event
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
}
}
filterItems
(
)
{
const
value
=
this
.
searchBox
.
value
;
this
.
table
.
filterItems
(
value
[
"
valueActor
"
]
)
;
this
.
_panelDoc
.
documentElement
.
classList
.
toggle
(
"
filtering
"
!
!
value
)
;
}
async
handleScrollEnd
(
)
{
if
(
!
this
.
shouldLoadMoreItems
)
{
return
;
}
this
.
shouldLoadMoreItems
=
false
;
this
.
itemOffset
+
=
50
;
const
item
=
this
.
tree
.
selectedItem
;
const
[
type
host
]
=
item
;
let
names
=
null
;
if
(
item
.
length
>
2
)
{
names
=
[
JSON
.
stringify
(
item
.
slice
(
2
)
)
]
;
}
await
this
.
fetchStorageObjects
(
type
host
names
REASON
.
NEXT_50_ITEMS
)
;
}
onTablePopupShowing
(
event
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
const
[
type
host
]
=
selectedItem
;
if
(
(
!
this
.
supportsAddItem
(
type
host
)
&
&
!
this
.
supportsRemoveItem
(
type
host
)
)
|
|
(
type
=
=
=
"
indexedDB
"
&
&
selectedItem
.
length
!
=
=
4
)
)
{
event
.
preventDefault
(
)
;
return
;
}
const
rowId
=
this
.
table
.
contextMenuRowId
;
const
data
=
this
.
table
.
items
.
get
(
rowId
)
;
if
(
this
.
supportsRemoveItem
(
type
host
)
)
{
const
name
=
data
[
this
.
table
.
uniqueId
]
;
const
separatorRegex
=
new
RegExp
(
SEPARATOR_GUID
"
g
"
)
;
const
label
=
addEllipsis
(
(
name
+
"
"
)
.
replace
(
separatorRegex
"
-
"
)
)
;
this
.
_tablePopupDelete
.
hidden
=
false
;
this
.
_tablePopupDelete
.
setAttribute
(
"
label
"
L10N
.
getFormatStr
(
"
storage
.
popupMenu
.
deleteLabel
"
label
)
)
;
}
else
{
this
.
_tablePopupDelete
.
hidden
=
true
;
}
if
(
this
.
supportsAddItem
(
type
host
)
)
{
this
.
_tablePopupAddItem
.
hidden
=
false
;
this
.
_tablePopupAddItem
.
setAttribute
(
"
label
"
L10N
.
getFormatStr
(
"
storage
.
popupMenu
.
addItemLabel
"
)
)
;
}
else
{
this
.
_tablePopupAddItem
.
hidden
=
true
;
}
let
showDeleteAllSessionCookies
=
false
;
if
(
this
.
supportsRemoveAllSessionCookies
(
type
host
)
)
{
if
(
selectedItem
.
length
=
=
=
2
)
{
showDeleteAllSessionCookies
=
true
;
}
}
this
.
_tablePopupDeleteAllSessionCookies
.
hidden
=
!
showDeleteAllSessionCookies
;
if
(
type
=
=
=
"
cookies
"
)
{
const
hostString
=
addEllipsis
(
data
.
host
)
;
this
.
_tablePopupDeleteAllFrom
.
hidden
=
false
;
this
.
_tablePopupDeleteAllFrom
.
setAttribute
(
"
label
"
L10N
.
getFormatStr
(
"
storage
.
popupMenu
.
deleteAllFromLabel
"
hostString
)
)
;
}
else
{
this
.
_tablePopupDeleteAllFrom
.
hidden
=
true
;
}
}
onTreePopupShowing
(
event
)
{
let
showMenu
=
false
;
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
selectedItem
)
{
const
[
type
host
]
=
selectedItem
;
let
showDeleteAll
=
false
;
if
(
this
.
supportsRemoveAll
(
type
host
)
)
{
let
level
;
if
(
type
=
=
"
indexedDB
"
)
{
level
=
4
;
}
else
if
(
type
=
=
"
Cache
"
)
{
level
=
3
;
}
else
{
level
=
2
;
}
if
(
selectedItem
.
length
=
=
level
)
{
showDeleteAll
=
true
;
}
}
this
.
_treePopupDeleteAll
.
hidden
=
!
showDeleteAll
;
let
showDeleteAllSessionCookies
=
false
;
if
(
this
.
supportsRemoveAllSessionCookies
(
type
host
)
)
{
if
(
type
=
=
=
"
cookies
"
&
&
selectedItem
.
length
=
=
=
2
)
{
showDeleteAllSessionCookies
=
true
;
}
}
this
.
_treePopupDeleteAllSessionCookies
.
hidden
=
!
showDeleteAllSessionCookies
;
const
showDelete
=
(
type
=
=
"
indexedDB
"
|
|
type
=
=
"
Cache
"
)
&
&
selectedItem
.
length
=
=
3
;
this
.
_treePopupDelete
.
hidden
=
!
showDelete
;
if
(
showDelete
)
{
const
itemName
=
addEllipsis
(
selectedItem
[
selectedItem
.
length
-
1
]
)
;
this
.
_treePopupDelete
.
setAttribute
(
"
label
"
L10N
.
getFormatStr
(
"
storage
.
popupMenu
.
deleteLabel
"
itemName
)
)
;
}
showMenu
=
showDeleteAll
|
|
showDelete
;
}
if
(
!
showMenu
)
{
event
.
preventDefault
(
)
;
}
}
onVariableViewPopupShowing
(
event
)
{
const
item
=
this
.
view
.
getFocusedItem
(
)
;
this
.
_variableViewPopupCopy
.
setAttribute
(
"
disabled
"
!
item
)
;
}
async
onRefreshTable
(
)
{
await
this
.
onHostSelect
(
this
.
tree
.
selectedItem
)
;
}
onAddItem
(
)
{
const
selectedItem
=
this
.
tree
.
selectedItem
;
if
(
!
selectedItem
)
{
return
;
}
const
front
=
this
.
getCurrentFront
(
)
;
const
[
host
]
=
selectedItem
;
this
.
table
.
scrollIntoViewOnUpdate
=
true
;
this
.
table
.
editBookmark
=
createGUID
(
)
;
front
.
addItem
(
this
.
table
.
editBookmark
host
)
;
}
onCopyItem
(
)
{
this
.
view
.
_copyItem
(
)
;
}
onRemoveItem
(
event
)
{
const
[
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
uniqueId
=
this
.
table
.
uniqueId
;
const
rowId
=
event
.
type
=
=
"
command
"
?
this
.
table
.
contextMenuRowId
:
this
.
table
.
selectedRow
[
uniqueId
]
;
const
data
=
this
.
table
.
items
.
get
(
rowId
)
;
let
name
=
data
[
uniqueId
]
;
if
(
path
.
length
>
0
)
{
name
=
JSON
.
stringify
(
[
.
.
.
path
name
]
)
;
}
front
.
removeItem
(
host
name
)
;
return
false
;
}
onRemoveAll
(
)
{
const
[
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
name
=
path
.
length
>
0
?
JSON
.
stringify
(
path
)
:
undefined
;
front
.
removeAll
(
host
name
)
;
}
onRemoveAllSessionCookies
(
)
{
const
[
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
name
=
path
.
length
>
0
?
JSON
.
stringify
(
path
)
:
undefined
;
front
.
removeAllSessionCookies
(
host
name
)
;
}
onRemoveAllFrom
(
)
{
const
[
host
]
=
this
.
tree
.
selectedItem
;
const
front
=
this
.
getCurrentFront
(
)
;
const
rowId
=
this
.
table
.
contextMenuRowId
;
const
data
=
this
.
table
.
items
.
get
(
rowId
)
;
front
.
removeAll
(
host
data
.
host
)
;
}
onRemoveTreeItem
(
)
{
const
[
type
host
.
.
.
path
]
=
this
.
tree
.
selectedItem
;
if
(
type
=
=
"
indexedDB
"
&
&
path
.
length
=
=
1
)
{
this
.
removeDatabase
(
host
path
[
0
]
)
;
}
else
if
(
type
=
=
"
Cache
"
&
&
path
.
length
=
=
1
)
{
this
.
removeCache
(
host
path
[
0
]
)
;
}
}
removeDatabase
(
host
dbName
)
{
const
front
=
this
.
getCurrentFront
(
)
;
front
.
removeDatabase
(
host
dbName
)
.
then
(
result
=
>
{
if
(
result
.
blocked
)
{
const
notificationBox
=
this
.
_toolbox
.
getNotificationBox
(
)
;
notificationBox
.
appendNotification
(
L10N
.
getFormatStr
(
"
storage
.
idb
.
deleteBlocked
"
dbName
)
"
storage
-
idb
-
delete
-
blocked
"
null
notificationBox
.
PRIORITY_WARNING_LOW
)
;
}
}
)
.
catch
(
error
=
>
{
const
notificationBox
=
this
.
_toolbox
.
getNotificationBox
(
)
;
notificationBox
.
appendNotification
(
L10N
.
getFormatStr
(
"
storage
.
idb
.
deleteError
"
dbName
)
"
storage
-
idb
-
delete
-
error
"
null
notificationBox
.
PRIORITY_CRITICAL_LOW
)
;
}
)
;
}
removeCache
(
host
cacheName
)
{
const
front
=
this
.
getCurrentFront
(
)
;
front
.
removeItem
(
host
JSON
.
stringify
(
[
cacheName
]
)
)
;
}
}
exports
.
StorageUI
=
StorageUI
;
function
createGUID
(
)
{
return
"
{
cccccccc
-
cccc
-
4ccc
-
yccc
-
cccccccccccc
}
"
.
replace
(
/
[
cy
]
/
g
c
=
>
{
const
r
=
(
Math
.
random
(
)
*
16
)
|
0
;
const
v
=
c
=
=
"
c
"
?
r
:
(
r
&
0x3
)
|
0x8
;
return
v
.
toString
(
16
)
;
}
)
;
}
function
addEllipsis
(
name
)
{
if
(
name
.
length
>
ITEM_NAME_MAX_LENGTH
)
{
if
(
/
^
https
?
:
/
.
test
(
name
)
)
{
const
halfLen
=
ITEM_NAME_MAX_LENGTH
/
2
;
return
name
.
slice
(
0
halfLen
)
+
ELLIPSIS
+
name
.
slice
(
-
halfLen
)
;
}
return
name
.
substr
(
0
ITEM_NAME_MAX_LENGTH
)
+
ELLIPSIS
;
}
return
name
;
}
function
getColumnName
(
type
name
)
{
let
id
=
{
type
}
.
{
name
}
;
id
=
NON_ORIGINAL_L10N_IDS
.
get
(
id
)
|
|
id
;
let
columnName
=
NON_L10N_STRINGS
.
get
(
id
)
;
if
(
!
columnName
)
{
try
{
columnName
=
L10N
.
getStr
(
table
.
headers
.
{
id
}
)
;
}
catch
(
e
)
{
columnName
=
name
;
}
}
return
columnName
;
}
