"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
kDebuggerPrefs
=
[
"
devtools
.
debugger
.
remote
-
enabled
"
"
devtools
.
chrome
.
enabled
"
]
;
const
{
XPCOMUtils
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
{
}
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Services
"
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
CustomizableWidgets
"
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
Bundle
"
function
(
)
{
const
kUrl
=
"
chrome
:
/
/
devtools
/
locale
/
key
-
shortcuts
.
properties
"
;
return
Services
.
strings
.
createBundle
(
kUrl
)
;
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
KeyShortcuts
"
function
(
)
{
const
isMac
=
AppConstants
.
platform
=
=
"
macosx
"
;
const
modifiers
=
isMac
?
"
accel
alt
"
:
"
accel
shift
"
;
return
[
{
id
:
"
toggleToolbox
"
shortcut
:
Bundle
.
GetStringFromName
(
"
toggleToolbox
.
commandkey
"
)
modifiers
}
{
id
:
"
toggleToolboxF12
"
shortcut
:
Bundle
.
GetStringFromName
(
"
toggleToolboxF12
.
commandkey
"
)
modifiers
:
"
"
}
{
id
:
"
toggleToolbar
"
shortcut
:
Bundle
.
GetStringFromName
(
"
toggleToolbar
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
id
:
"
webide
"
shortcut
:
Bundle
.
GetStringFromName
(
"
webide
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
id
:
"
browserToolbox
"
shortcut
:
Bundle
.
GetStringFromName
(
"
browserToolbox
.
commandkey
"
)
modifiers
:
"
accel
alt
shift
"
}
{
id
:
"
browserConsole
"
shortcut
:
Bundle
.
GetStringFromName
(
"
browserConsole
.
commandkey
"
)
modifiers
:
"
accel
shift
"
}
{
id
:
"
responsiveDesignMode
"
shortcut
:
Bundle
.
GetStringFromName
(
"
responsiveDesignMode
.
commandkey
"
)
modifiers
}
{
id
:
"
scratchpad
"
shortcut
:
Bundle
.
GetStringFromName
(
"
scratchpad
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
inspector
"
shortcut
:
Bundle
.
GetStringFromName
(
"
inspector
.
commandkey
"
)
modifiers
}
{
toolId
:
"
webconsole
"
shortcut
:
Bundle
.
GetStringFromName
(
"
webconsole
.
commandkey
"
)
modifiers
}
{
toolId
:
"
jsdebugger
"
shortcut
:
Bundle
.
GetStringFromName
(
"
debugger
.
commandkey
"
)
modifiers
}
{
toolId
:
"
netmonitor
"
shortcut
:
Bundle
.
GetStringFromName
(
"
netmonitor
.
commandkey
"
)
modifiers
}
{
toolId
:
"
styleeditor
"
shortcut
:
Bundle
.
GetStringFromName
(
"
styleeditor
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
performance
"
shortcut
:
Bundle
.
GetStringFromName
(
"
performance
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
storage
"
shortcut
:
Bundle
.
GetStringFromName
(
"
storage
.
commandkey
"
)
modifiers
:
"
shift
"
}
{
toolId
:
"
dom
"
shortcut
:
Bundle
.
GetStringFromName
(
"
dom
.
commandkey
"
)
modifiers
}
]
;
}
)
;
function
DevToolsStartup
(
)
{
}
DevToolsStartup
.
prototype
=
{
handle
:
function
(
cmdLine
)
{
let
consoleFlag
=
cmdLine
.
handleFlag
(
"
jsconsole
"
false
)
;
let
debuggerFlag
=
cmdLine
.
handleFlag
(
"
jsdebugger
"
false
)
;
let
devtoolsFlag
=
cmdLine
.
handleFlag
(
"
devtools
"
false
)
;
if
(
consoleFlag
)
{
this
.
handleConsoleFlag
(
cmdLine
)
;
}
if
(
debuggerFlag
)
{
this
.
handleDebuggerFlag
(
cmdLine
)
;
}
let
debuggerServerFlag
;
try
{
debuggerServerFlag
=
cmdLine
.
handleFlagWithParam
(
"
start
-
debugger
-
server
"
false
)
;
}
catch
(
e
)
{
debuggerServerFlag
=
cmdLine
.
handleFlag
(
"
start
-
debugger
-
server
"
false
)
;
}
if
(
debuggerServerFlag
)
{
this
.
handleDebuggerServerFlag
(
cmdLine
debuggerServerFlag
)
;
}
let
onWindowReady
=
window
=
>
{
this
.
hookWindow
(
window
)
;
if
(
devtoolsFlag
)
{
this
.
handleDevToolsFlag
(
window
)
;
devtoolsFlag
=
false
;
}
JsonView
.
initialize
(
)
;
}
;
Services
.
obs
.
addObserver
(
onWindowReady
"
browser
-
delayed
-
startup
-
finished
"
)
;
}
hookWindow
(
window
)
{
this
.
hookKeyShortcuts
(
window
)
;
if
(
this
.
initialized
)
{
return
;
}
this
.
hookWebDeveloperMenu
(
window
)
;
this
.
hookDeveloperToggle
(
window
)
;
}
hookDeveloperToggle
(
window
)
{
let
id
=
"
developer
-
button
"
;
let
widget
=
CustomizableUI
.
getWidget
(
id
)
;
if
(
widget
&
&
widget
.
provider
=
=
CustomizableUI
.
PROVIDER_API
)
{
return
;
}
let
item
=
{
id
:
id
type
:
"
view
"
viewId
:
"
PanelUI
-
developer
"
shortcutId
:
"
key_toggleToolbox
"
tooltiptext
:
"
developer
-
button
.
tooltiptext2
"
defaultArea
:
AppConstants
.
MOZ_DEV_EDITION
?
CustomizableUI
.
AREA_NAVBAR
:
CustomizableUI
.
AREA_PANEL
onViewShowing
:
(
event
)
=
>
{
this
.
initDevTools
(
)
;
let
doc
=
event
.
target
.
ownerDocument
;
let
menu
=
doc
.
getElementById
(
"
menuWebDeveloperPopup
"
)
;
let
itemsToDisplay
=
[
.
.
.
menu
.
children
]
;
itemsToDisplay
.
push
(
{
localName
:
"
menuseparator
"
getAttribute
:
(
)
=
>
{
}
}
)
;
itemsToDisplay
.
push
(
doc
.
getElementById
(
"
goOfflineMenuitem
"
)
)
;
let
developerItems
=
doc
.
getElementById
(
"
PanelUI
-
developerItems
"
)
;
let
{
clearSubview
fillSubviewFromMenuItems
}
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
{
}
)
;
clearSubview
(
developerItems
)
;
fillSubviewFromMenuItems
(
itemsToDisplay
developerItems
)
;
}
onInit
(
anchor
)
{
this
.
onBeforeCreated
(
anchor
.
ownerDocument
)
;
}
onBeforeCreated
(
doc
)
{
if
(
doc
.
getElementById
(
"
PanelUI
-
developerItems
"
)
)
{
return
;
}
let
view
=
doc
.
createElement
(
"
panelview
"
)
;
view
.
id
=
"
PanelUI
-
developerItems
"
;
let
panel
=
doc
.
createElement
(
"
vbox
"
)
;
panel
.
setAttribute
(
"
class
"
"
panel
-
subview
-
body
"
)
;
view
.
appendChild
(
panel
)
;
doc
.
getElementById
(
"
PanelUI
-
multiView
"
)
.
appendChild
(
view
)
;
}
}
;
CustomizableUI
.
createWidget
(
item
)
;
CustomizableWidgets
.
push
(
item
)
;
}
hookWebDeveloperMenu
(
window
)
{
let
menu
=
window
.
document
.
getElementById
(
"
webDeveloperMenu
"
)
;
menu
.
addEventListener
(
"
popupshowing
"
(
)
=
>
this
.
initDevTools
(
)
{
once
:
true
}
)
;
}
hookKeyShortcuts
(
window
)
{
let
doc
=
window
.
document
;
let
keyset
=
doc
.
createElement
(
"
keyset
"
)
;
keyset
.
setAttribute
(
"
id
"
"
devtoolsKeyset
"
)
;
for
(
let
key
of
KeyShortcuts
)
{
let
xulKey
=
this
.
createKey
(
doc
key
(
)
=
>
this
.
onKey
(
window
key
)
)
;
keyset
.
appendChild
(
xulKey
)
;
}
let
mainKeyset
=
doc
.
getElementById
(
"
mainKeyset
"
)
;
mainKeyset
.
parentNode
.
insertBefore
(
keyset
mainKeyset
)
;
}
onKey
(
window
key
)
{
let
require
=
this
.
initDevTools
(
)
;
let
{
gDevToolsBrowser
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
gDevToolsBrowser
.
onKeyShortcut
(
window
key
)
;
}
createKey
(
doc
{
id
toolId
shortcut
modifiers
:
mod
}
oncommand
)
{
let
k
=
doc
.
createElement
(
"
key
"
)
;
k
.
id
=
"
key_
"
+
(
id
|
|
toolId
)
;
if
(
shortcut
.
startsWith
(
"
VK_
"
)
)
{
k
.
setAttribute
(
"
keycode
"
shortcut
)
;
}
else
{
k
.
setAttribute
(
"
key
"
shortcut
)
;
}
if
(
mod
)
{
k
.
setAttribute
(
"
modifiers
"
mod
)
;
}
k
.
setAttribute
(
"
oncommand
"
"
;
"
)
;
k
.
addEventListener
(
"
command
"
oncommand
)
;
return
k
;
}
initialized
:
false
initDevTools
:
function
(
)
{
this
.
initialized
=
true
;
let
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
return
require
;
}
handleConsoleFlag
:
function
(
cmdLine
)
{
let
window
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webconsole
"
)
;
if
(
!
window
)
{
this
.
initDevTools
(
)
;
let
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
let
hudservice
=
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
;
let
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
hudservice
.
toggleBrowserConsole
(
)
.
catch
(
console
.
error
)
;
}
else
{
window
.
focus
(
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
handleDevToolsFlag
:
function
(
window
)
{
const
require
=
this
.
initDevTools
(
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
let
target
=
TargetFactory
.
forTab
(
window
.
gBrowser
.
selectedTab
)
;
gDevTools
.
showToolbox
(
target
)
;
}
_isRemoteDebuggingEnabled
(
)
{
let
remoteDebuggingEnabled
=
false
;
try
{
remoteDebuggingEnabled
=
kDebuggerPrefs
.
every
(
pref
=
>
{
return
Services
.
prefs
.
getBoolPref
(
pref
)
;
}
)
;
}
catch
(
ex
)
{
let
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
console
.
error
(
ex
)
;
return
false
;
}
if
(
!
remoteDebuggingEnabled
)
{
let
errorMsg
=
"
Could
not
run
chrome
debugger
!
You
need
the
following
"
+
"
prefs
to
be
set
to
true
:
"
+
kDebuggerPrefs
.
join
(
"
"
)
;
let
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
console
.
error
(
new
Error
(
errorMsg
)
)
;
dump
(
errorMsg
+
"
\
n
"
)
;
}
return
remoteDebuggingEnabled
;
}
handleDebuggerFlag
:
function
(
cmdLine
)
{
if
(
!
this
.
_isRemoteDebuggingEnabled
(
)
)
{
return
;
}
let
devtoolsThreadResumed
=
false
;
let
pauseOnStartup
=
cmdLine
.
handleFlag
(
"
wait
-
for
-
jsdebugger
"
false
)
;
if
(
pauseOnStartup
)
{
let
observe
=
function
(
subject
topic
data
)
{
devtoolsThreadResumed
=
true
;
Services
.
obs
.
removeObserver
(
observe
"
devtools
-
thread
-
resumed
"
)
;
}
;
Services
.
obs
.
addObserver
(
observe
"
devtools
-
thread
-
resumed
"
)
;
}
const
{
BrowserToolboxProcess
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
{
}
)
;
BrowserToolboxProcess
.
init
(
)
;
if
(
pauseOnStartup
)
{
let
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
)
;
tm
.
spinEventLoopUntil
(
(
)
=
>
{
return
devtoolsThreadResumed
;
}
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
handleDebuggerServerFlag
:
function
(
cmdLine
portOrPath
)
{
if
(
!
this
.
_isRemoteDebuggingEnabled
(
)
)
{
return
;
}
let
webSocket
=
false
;
let
defaultPort
=
Services
.
prefs
.
getIntPref
(
"
devtools
.
debugger
.
remote
-
port
"
)
;
if
(
portOrPath
=
=
=
true
)
{
webSocket
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
websocket
"
)
;
portOrPath
=
defaultPort
;
}
else
if
(
portOrPath
.
startsWith
(
"
ws
:
"
)
)
{
webSocket
=
true
;
let
port
=
portOrPath
.
slice
(
3
)
;
portOrPath
=
Number
(
port
)
?
port
:
defaultPort
;
}
let
{
DevToolsLoader
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
try
{
let
serverLoader
=
new
DevToolsLoader
(
)
;
serverLoader
.
invisibleToDebugger
=
true
;
let
{
DebuggerServer
:
debuggerServer
}
=
serverLoader
.
require
(
"
devtools
/
server
/
main
"
)
;
debuggerServer
.
init
(
)
;
debuggerServer
.
addBrowserActors
(
)
;
debuggerServer
.
allowChromeProcess
=
true
;
let
listener
=
debuggerServer
.
createListener
(
)
;
listener
.
portOrPath
=
portOrPath
;
listener
.
webSocket
=
webSocket
;
listener
.
open
(
)
;
dump
(
"
Started
debugger
server
on
"
+
portOrPath
+
"
\
n
"
)
;
}
catch
(
e
)
{
dump
(
"
Unable
to
start
debugger
server
on
"
+
portOrPath
+
"
:
"
+
e
)
;
}
if
(
cmdLine
.
state
=
=
Ci
.
nsICommandLine
.
STATE_REMOTE_AUTO
)
{
cmdLine
.
preventDefault
=
true
;
}
}
helpInfo
:
"
-
-
jsconsole
Open
the
Browser
Console
.
\
n
"
+
"
-
-
jsdebugger
Open
the
Browser
Toolbox
.
\
n
"
+
"
-
-
wait
-
for
-
jsdebugger
Spin
event
loop
until
JS
debugger
connects
.
\
n
"
+
"
Enables
debugging
(
some
)
application
startup
code
paths
.
\
n
"
+
"
Only
has
an
effect
when
-
-
jsdebugger
is
also
supplied
.
\
n
"
+
"
-
-
devtools
Open
DevTools
on
initial
load
.
\
n
"
+
"
-
-
start
-
debugger
-
server
[
ws
:
]
[
<
port
>
|
<
path
>
]
Start
the
debugger
server
on
\
n
"
+
"
a
TCP
port
or
Unix
domain
socket
path
.
Defaults
to
TCP
port
\
n
"
+
"
6000
.
Use
WebSocket
protocol
if
ws
:
prefix
is
specified
.
\
n
"
classID
:
Components
.
ID
(
"
{
9e9a9283
-
0ce9
-
4e4a
-
8f1c
-
ba129a032c32
}
"
)
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsICommandLineHandler
]
)
}
;
const
JsonView
=
{
initialized
:
false
initialize
:
function
(
)
{
if
(
this
.
initialized
)
{
return
;
}
this
.
initialized
=
true
;
Services
.
ppmm
.
loadProcessScript
(
"
resource
:
/
/
devtools
/
client
/
jsonview
/
converter
-
observer
.
js
"
true
)
;
Services
.
ppmm
.
addMessageListener
(
"
devtools
:
jsonview
:
save
"
this
.
onSave
)
;
}
onSave
:
function
(
message
)
{
let
chrome
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
let
browser
=
chrome
.
gBrowser
.
selectedBrowser
;
if
(
message
.
data
.
url
=
=
=
null
)
{
chrome
.
saveBrowser
(
browser
false
message
.
data
.
windowID
)
;
}
else
{
let
persistable
=
browser
.
QueryInterface
(
Ci
.
nsIFrameLoaderOwner
)
.
frameLoader
.
QueryInterface
(
Ci
.
nsIWebBrowserPersistable
)
;
persistable
.
startPersistence
(
message
.
data
.
windowID
{
onDocumentReady
(
doc
)
{
let
uri
=
chrome
.
makeURI
(
doc
.
documentURI
doc
.
characterSet
)
;
let
filename
=
chrome
.
getDefaultFileName
(
undefined
uri
doc
null
)
;
chrome
.
internalSave
(
message
.
data
.
url
doc
filename
null
doc
.
contentType
false
null
null
null
doc
false
null
undefined
)
;
}
onError
(
status
)
{
throw
new
Error
(
"
JSON
Viewer
'
s
onSave
failed
in
startPersistence
"
)
;
}
}
)
;
}
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
DevToolsStartup
]
)
;
