"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
CHROME_URL_ROOT
+
"
helper
-
addons
.
js
"
this
)
;
const
{
PromiseTestUtils
}
=
scopedCuImport
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
File
closed
/
)
;
requestLongerTimeout
(
2
)
;
const
ADDON_ID
=
"
test
-
devtools
-
webextension
mozilla
.
org
"
;
const
ADDON_NAME
=
"
test
-
devtools
-
webextension
"
;
const
{
BrowserToolboxProcess
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
{
}
)
;
add_task
(
async
function
testWebExtensionsToolboxWebConsole
(
)
{
await
enableExtensionDebugging
(
)
;
is
(
Services
.
prefs
.
getBoolPref
(
"
ui
.
popup
.
disable_autohide
"
)
false
"
disable_autohide
should
be
initially
false
"
)
;
info
(
"
Create
promises
waiting
for
the
messages
emitted
by
the
test
addon
"
)
;
let
onReadyForOpenPopup
;
let
onPopupCustomMessage
;
const
{
Management
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Extension
.
jsm
"
null
)
;
Management
.
on
(
"
startup
"
function
listener
(
event
extension
)
{
if
(
extension
.
name
!
=
ADDON_NAME
)
{
return
;
}
Management
.
off
(
"
startup
"
listener
)
;
function
waitForExtensionTestMessage
(
expectedMessage
)
{
return
new
Promise
(
done
=
>
{
extension
.
on
(
"
test
-
message
"
function
testLogListener
(
evt
.
.
.
args
)
{
const
[
message
]
=
args
;
if
(
message
!
=
=
expectedMessage
)
{
return
;
}
extension
.
off
(
"
test
-
message
"
testLogListener
)
;
done
(
args
)
;
}
)
;
}
)
;
}
onReadyForOpenPopup
=
waitForExtensionTestMessage
(
"
readyForOpenPopup
"
)
;
onPopupCustomMessage
=
waitForExtensionTestMessage
(
"
popupPageFunctionCalled
"
)
;
}
)
;
const
{
document
tab
window
:
aboutDebuggingWindow
}
=
await
openAboutDebugging
(
)
;
await
selectThisFirefoxPage
(
document
aboutDebuggingWindow
.
AboutDebugging
.
store
)
;
await
installTemporaryExtensionFromXPI
(
{
background
:
function
(
)
{
const
{
browser
}
=
this
;
window
.
myWebExtensionShowPopup
=
function
(
)
{
browser
.
test
.
sendMessage
(
"
readyForOpenPopup
"
)
;
}
;
}
extraProperties
:
{
browser_action
:
{
default_title
:
"
WebExtension
Popup
Debugging
"
default_popup
:
"
popup
.
html
"
}
}
files
:
{
"
popup
.
html
"
:
<
!
DOCTYPE
html
>
<
html
>
<
head
>
<
meta
charset
=
"
utf
-
8
"
>
<
script
src
=
"
popup
.
js
"
>
<
/
script
>
<
/
head
>
<
body
>
Background
Page
Body
Test
Content
<
/
body
>
<
/
html
>
"
popup
.
js
"
:
function
(
)
{
const
{
browser
}
=
this
;
window
.
myWebExtensionPopupAddonFunction
=
function
(
)
{
browser
.
test
.
sendMessage
(
"
popupPageFunctionCalled
"
browser
.
runtime
.
getManifest
(
)
)
;
}
;
}
}
id
:
ADDON_ID
name
:
ADDON_NAME
}
document
)
;
const
target
=
findDebugTargetByText
(
ADDON_NAME
document
)
;
info
(
"
Setup
the
toolbox
test
function
as
environment
variable
"
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
env
.
set
(
"
MOZ_TOOLBOX_TEST_SCRIPT
"
"
new
"
+
toolboxTestScript
)
;
registerCleanupFunction
(
(
)
=
>
env
.
set
(
"
MOZ_TOOLBOX_TEST_SCRIPT
"
"
"
)
)
;
info
(
"
Click
inspect
to
open
the
addon
toolbox
"
)
;
const
onToolboxClose
=
BrowserToolboxProcess
.
once
(
"
close
"
)
;
const
inspectButton
=
target
.
querySelector
(
"
.
js
-
debug
-
target
-
inspect
-
button
"
)
;
inspectButton
.
click
(
)
;
info
(
"
Wait
until
the
addon
popup
is
opened
from
the
test
script
"
)
;
await
onReadyForOpenPopup
;
const
widgetId
=
ADDON_ID
.
toLowerCase
(
)
.
replace
(
/
[
^
a
-
z0
-
9_
-
]
/
g
"
_
"
)
;
const
browserActionId
=
widgetId
+
"
-
browser
-
action
"
;
const
browserActionEl
=
window
.
document
.
getElementById
(
browserActionId
)
;
ok
(
browserActionEl
"
Got
the
browserAction
button
from
the
browser
UI
"
)
;
browserActionEl
.
click
(
)
;
info
(
"
Clicked
on
the
browserAction
button
"
)
;
const
args
=
await
onPopupCustomMessage
;
ok
(
true
"
Received
console
message
from
the
popup
page
function
as
expected
"
)
;
is
(
args
[
0
]
"
popupPageFunctionCalled
"
"
Got
the
expected
console
message
"
)
;
is
(
args
[
1
]
&
&
args
[
1
]
.
name
ADDON_NAME
"
Got
the
expected
manifest
from
WebExtension
API
"
)
;
info
(
"
Wait
for
the
toolbox
to
close
"
)
;
await
onToolboxClose
;
is
(
Services
.
prefs
.
getBoolPref
(
"
ui
.
popup
.
disable_autohide
"
)
false
"
disable_autohide
should
be
reset
to
false
when
the
toolbox
is
closed
"
)
;
ok
(
true
"
Addon
toolbox
closed
"
)
;
await
removeTemporaryExtension
(
ADDON_NAME
document
)
;
await
removeTab
(
tab
)
;
}
)
;
function
toolboxTestScript
(
)
{
let
jsterm
;
const
popupFramePromise
=
new
Promise
(
resolve
=
>
{
const
listener
=
data
=
>
{
if
(
data
.
frames
.
some
(
(
{
url
}
)
=
>
url
&
&
url
.
endsWith
(
"
popup
.
html
"
)
)
)
{
toolbox
.
target
.
off
(
"
frame
-
update
"
listener
)
;
resolve
(
)
;
}
}
;
toolbox
.
target
.
on
(
"
frame
-
update
"
listener
)
;
}
)
;
const
waitForFrameListUpdate
=
toolbox
.
target
.
once
(
"
frame
-
update
"
)
;
toolbox
.
selectTool
(
"
webconsole
"
)
.
then
(
async
(
console
)
=
>
{
const
clickNoAutoHideMenu
=
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
toolbox
.
doc
.
getElementById
(
"
toolbox
-
meatball
-
menu
-
button
"
)
.
click
(
)
;
toolbox
.
doc
.
addEventListener
(
"
popupshown
"
(
)
=
>
{
const
menuItem
=
toolbox
.
doc
.
getElementById
(
"
toolbox
-
meatball
-
menu
-
noautohide
"
)
;
menuItem
.
click
(
)
;
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
;
dump
(
Clicking
the
menu
button
\
n
)
;
await
clickNoAutoHideMenu
(
)
;
dump
(
Clicked
the
menu
button
\
n
)
;
jsterm
=
console
.
hud
.
jsterm
;
jsterm
.
execute
(
"
myWebExtensionShowPopup
(
)
"
)
;
await
Promise
.
all
(
[
waitForFrameListUpdate
popupFramePromise
]
)
;
dump
(
Clicking
the
frame
list
button
\
n
)
;
const
btn
=
toolbox
.
doc
.
getElementById
(
"
command
-
button
-
frames
"
)
;
btn
.
click
(
)
;
const
waitUntil
=
function
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
toolbox
.
win
.
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
;
await
waitUntil
(
(
)
=
>
btn
.
style
.
pointerEvents
=
=
=
"
none
"
)
;
dump
(
Clicked
the
frame
list
button
\
n
)
;
const
menuList
=
toolbox
.
doc
.
getElementById
(
"
toolbox
-
frame
-
menu
"
)
;
const
frames
=
Array
.
from
(
menuList
.
querySelectorAll
(
"
.
command
"
)
)
;
if
(
frames
.
length
!
=
2
)
{
throw
Error
(
Number
of
frames
found
is
wrong
:
{
frames
.
length
}
!
=
2
)
;
}
const
popupFrameBtn
=
frames
.
filter
(
(
frame
)
=
>
{
return
frame
.
querySelector
(
"
.
label
"
)
.
textContent
.
endsWith
(
"
popup
.
html
"
)
;
}
)
.
pop
(
)
;
if
(
!
popupFrameBtn
)
{
throw
Error
(
"
Extension
Popup
frame
not
found
in
the
listed
frames
"
)
;
}
const
waitForNavigated
=
toolbox
.
target
.
once
(
"
navigate
"
)
;
popupFrameBtn
.
click
(
)
;
await
waitForNavigated
;
await
jsterm
.
execute
(
"
myWebExtensionPopupAddonFunction
(
)
"
)
;
await
toolbox
.
destroy
(
)
;
}
)
.
catch
(
(
error
)
=
>
{
dump
(
"
Error
while
running
code
in
the
browser
toolbox
process
:
\
n
"
)
;
dump
(
error
+
"
\
n
"
)
;
dump
(
"
stack
:
\
n
"
+
error
.
stack
+
"
\
n
"
)
;
}
)
;
}
