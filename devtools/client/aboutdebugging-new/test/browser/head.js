"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
redux
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
CHROME_URL_ROOT
+
"
debug
-
target
-
pane_collapsibilities_head
.
js
"
this
)
;
registerCleanupFunction
(
async
function
(
)
{
try
{
const
{
adbAddon
}
=
require
(
"
devtools
/
shared
/
adb
/
adb
-
addon
"
)
;
await
adbAddon
.
uninstall
(
)
;
}
catch
(
e
)
{
}
const
{
ADB
}
=
require
(
"
devtools
/
shared
/
adb
/
adb
"
)
;
await
ADB
.
kill
(
)
;
}
)
;
async
function
enableNewAboutDebugging
(
)
{
await
pushPref
(
"
devtools
.
aboutdebugging
.
new
-
enabled
"
true
)
;
await
pushPref
(
"
devtools
.
aboutdebugging
.
network
"
true
)
;
}
async
function
openAboutDebugging
(
page
win
)
{
await
enableNewAboutDebugging
(
)
;
info
(
"
opening
about
:
debugging
"
)
;
const
tab
=
await
addTab
(
"
about
:
debugging
"
{
window
:
win
}
)
;
const
browser
=
tab
.
linkedBrowser
;
const
document
=
browser
.
contentDocument
;
const
window
=
browser
.
contentWindow
;
const
{
AboutDebugging
}
=
window
;
await
Promise
.
all
(
[
waitForDispatch
(
AboutDebugging
.
store
"
REQUEST_EXTENSIONS_SUCCESS
"
)
waitForDispatch
(
AboutDebugging
.
store
"
REQUEST_TABS_SUCCESS
"
)
waitForDispatch
(
AboutDebugging
.
store
"
REQUEST_WORKERS_SUCCESS
"
)
]
)
;
return
{
tab
document
window
}
;
}
async
function
waitForRequestsToSettle
(
store
delay
=
500
)
{
let
hasSettled
=
false
;
while
(
!
hasSettled
)
{
let
timer
;
const
timerPromise
=
new
Promise
(
resolve
=
>
{
timer
=
setTimeout
(
(
)
=
>
{
hasSettled
=
true
;
resolve
(
)
;
}
delay
)
;
}
)
;
await
Promise
.
race
(
[
waitForDispatch
(
store
"
REQUEST_EXTENSIONS_SUCCESS
"
)
waitForDispatch
(
store
"
REQUEST_TABS_SUCCESS
"
)
waitForDispatch
(
store
"
REQUEST_WORKERS_SUCCESS
"
)
timerPromise
]
)
;
clearTimeout
(
timer
)
;
}
}
function
waitForDispatch
(
store
type
)
{
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
action
.
type
=
=
=
type
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
async
function
selectConnectPage
(
doc
)
{
const
sidebarItems
=
doc
.
querySelectorAll
(
"
.
js
-
sidebar
-
item
"
)
;
const
connectSidebarItem
=
[
.
.
.
sidebarItems
]
.
find
(
element
=
>
{
return
element
.
textContent
=
=
=
"
Connect
"
;
}
)
;
ok
(
connectSidebarItem
"
Sidebar
contains
a
Connect
item
"
)
;
const
connectLink
=
connectSidebarItem
.
querySelector
(
"
.
js
-
sidebar
-
link
"
)
;
ok
(
connectLink
"
Sidebar
contains
a
Connect
link
"
)
;
info
(
"
Click
on
the
Connect
link
in
the
sidebar
"
)
;
connectLink
.
click
(
)
;
info
(
"
Wait
until
Connect
page
is
displayed
"
)
;
await
waitUntil
(
(
)
=
>
doc
.
querySelector
(
"
.
js
-
connect
-
page
"
)
)
;
}
function
findDebugTargetByText
(
text
document
)
{
const
targets
=
[
.
.
.
document
.
querySelectorAll
(
"
.
js
-
debug
-
target
-
item
"
)
]
;
return
targets
.
find
(
target
=
>
target
.
textContent
.
includes
(
text
)
)
;
}
function
findSidebarItemByText
(
text
document
)
{
const
sidebarItems
=
document
.
querySelectorAll
(
"
.
js
-
sidebar
-
item
"
)
;
return
[
.
.
.
sidebarItems
]
.
find
(
element
=
>
{
return
element
.
textContent
.
includes
(
text
)
;
}
)
;
}
async
function
connectToRuntime
(
deviceName
appName
document
)
{
info
(
Wait
until
the
sidebar
item
for
{
deviceName
}
appears
)
;
await
waitUntil
(
(
)
=
>
findSidebarItemByText
(
deviceName
document
)
)
;
const
sidebarItem
=
findSidebarItemByText
(
deviceName
document
)
;
const
connectButton
=
sidebarItem
.
querySelector
(
"
.
js
-
connect
-
button
"
)
;
ok
(
connectButton
Connect
button
is
displayed
for
the
runtime
{
deviceName
}
)
;
info
(
"
Click
on
the
connect
button
and
wait
until
it
disappears
"
)
;
connectButton
.
click
(
)
;
await
waitUntil
(
(
)
=
>
!
sidebarItem
.
querySelector
(
"
.
js
-
connect
-
button
"
)
)
;
sidebarItem
.
querySelector
(
"
.
js
-
sidebar
-
link
"
)
.
click
(
)
;
await
waitUntil
(
(
)
=
>
{
const
runtimeInfo
=
document
.
querySelector
(
"
.
js
-
runtime
-
info
"
)
;
return
runtimeInfo
.
textContent
.
includes
(
appName
)
;
}
)
;
}
