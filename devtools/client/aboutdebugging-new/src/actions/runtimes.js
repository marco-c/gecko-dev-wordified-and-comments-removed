"
use
strict
"
;
const
Actions
=
require
(
"
.
/
index
"
)
;
const
{
getAllRuntimes
getCurrentRuntime
findRuntimeById
}
=
require
(
"
.
.
/
modules
/
runtimes
-
state
-
helper
"
)
;
const
{
l10n
}
=
require
(
"
.
.
/
modules
/
l10n
"
)
;
const
{
createClientForRuntime
}
=
require
(
"
.
.
/
modules
/
runtime
-
client
-
factory
"
)
;
const
{
remoteClientManager
}
=
require
(
"
devtools
/
client
/
shared
/
remote
-
debugging
/
remote
-
client
-
manager
"
)
;
const
{
CONNECT_RUNTIME_FAILURE
CONNECT_RUNTIME_START
CONNECT_RUNTIME_SUCCESS
DISCONNECT_RUNTIME_FAILURE
DISCONNECT_RUNTIME_START
DISCONNECT_RUNTIME_SUCCESS
PAGE_TYPES
REMOTE_RUNTIMES_UPDATED
RUNTIME_PREFERENCE
RUNTIMES
THIS_FIREFOX_RUNTIME_CREATED
UNWATCH_RUNTIME_FAILURE
UNWATCH_RUNTIME_START
UNWATCH_RUNTIME_SUCCESS
UPDATE_CONNECTION_PROMPT_SETTING_FAILURE
UPDATE_CONNECTION_PROMPT_SETTING_START
UPDATE_CONNECTION_PROMPT_SETTING_SUCCESS
UPDATE_RUNTIME_MULTIE10S_FAILURE
UPDATE_RUNTIME_MULTIE10S_START
UPDATE_RUNTIME_MULTIE10S_SUCCESS
WATCH_RUNTIME_FAILURE
WATCH_RUNTIME_START
WATCH_RUNTIME_SUCCESS
}
=
require
(
"
.
.
/
constants
"
)
;
async
function
getRuntimeInfo
(
runtime
clientWrapper
)
{
const
{
type
}
=
runtime
;
const
{
name
channel
deviceName
isMultiE10s
version
}
=
await
clientWrapper
.
getDeviceDescription
(
)
;
const
icon
=
(
channel
=
=
=
"
release
"
|
|
channel
=
=
=
"
beta
"
|
|
channel
=
=
=
"
aurora
"
)
?
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
{
channel
}
.
svg
:
"
chrome
:
/
/
devtools
/
skin
/
images
/
aboutdebugging
-
firefox
-
nightly
.
svg
"
;
return
{
deviceName
icon
isMultiE10s
name
type
version
}
;
}
function
onRemoteDebuggerClientClosed
(
)
{
window
.
AboutDebugging
.
onNetworkLocationsUpdated
(
)
;
window
.
AboutDebugging
.
onUSBRuntimesUpdated
(
)
;
}
function
onMultiE10sUpdated
(
)
{
window
.
AboutDebugging
.
store
.
dispatch
(
updateMultiE10s
(
)
)
;
}
function
connectRuntime
(
id
)
{
return
async
(
dispatch
getState
)
=
>
{
dispatch
(
{
type
:
CONNECT_RUNTIME_START
}
)
;
try
{
const
runtime
=
findRuntimeById
(
id
getState
(
)
.
runtimes
)
;
const
clientWrapper
=
await
createClientForRuntime
(
runtime
)
;
const
info
=
await
getRuntimeInfo
(
runtime
clientWrapper
)
;
const
{
isMultiE10s
}
=
info
;
delete
info
.
isMultiE10s
;
const
{
CONNECTION_PROMPT
PERMANENT_PRIVATE_BROWSING
SERVICE_WORKERS_ENABLED
}
=
RUNTIME_PREFERENCE
;
const
connectionPromptEnabled
=
await
clientWrapper
.
getPreference
(
CONNECTION_PROMPT
false
)
;
const
privateBrowsing
=
await
clientWrapper
.
getPreference
(
PERMANENT_PRIVATE_BROWSING
false
)
;
const
serviceWorkersEnabled
=
await
clientWrapper
.
getPreference
(
SERVICE_WORKERS_ENABLED
true
)
;
const
serviceWorkersAvailable
=
serviceWorkersEnabled
&
&
!
privateBrowsing
;
const
runtimeDetails
=
{
clientWrapper
connectionPromptEnabled
info
isMultiE10s
serviceWorkersAvailable
}
;
const
deviceFront
=
await
clientWrapper
.
getFront
(
"
device
"
)
;
if
(
deviceFront
)
{
deviceFront
.
on
(
"
multi
-
e10s
-
updated
"
onMultiE10sUpdated
)
;
}
if
(
runtime
.
type
!
=
=
RUNTIMES
.
THIS_FIREFOX
)
{
clientWrapper
.
addOneTimeListener
(
"
closed
"
onRemoteDebuggerClientClosed
)
;
}
dispatch
(
{
type
:
CONNECT_RUNTIME_SUCCESS
runtime
:
{
id
runtimeDetails
type
:
runtime
.
type
}
}
)
;
}
catch
(
e
)
{
dispatch
(
{
type
:
CONNECT_RUNTIME_FAILURE
error
:
e
}
)
;
}
}
;
}
function
createThisFirefoxRuntime
(
)
{
return
(
dispatch
getState
)
=
>
{
const
thisFirefoxRuntime
=
{
id
:
RUNTIMES
.
THIS_FIREFOX
isUnknown
:
false
name
:
l10n
.
getString
(
"
about
-
debugging
-
this
-
firefox
-
runtime
-
name
"
)
type
:
RUNTIMES
.
THIS_FIREFOX
}
;
dispatch
(
{
type
:
THIS_FIREFOX_RUNTIME_CREATED
runtime
:
thisFirefoxRuntime
}
)
;
}
;
}
function
disconnectRuntime
(
id
)
{
return
async
(
dispatch
getState
)
=
>
{
dispatch
(
{
type
:
DISCONNECT_RUNTIME_START
}
)
;
try
{
const
runtime
=
findRuntimeById
(
id
getState
(
)
.
runtimes
)
;
const
{
clientWrapper
}
=
runtime
.
runtimeDetails
;
const
deviceFront
=
await
clientWrapper
.
getFront
(
"
device
"
)
;
if
(
deviceFront
)
{
deviceFront
.
off
(
"
multi
-
e10s
-
updated
"
onMultiE10sUpdated
)
;
}
if
(
runtime
.
type
!
=
=
RUNTIMES
.
THIS_FIREFOX
)
{
clientWrapper
.
removeListener
(
"
closed
"
onRemoteDebuggerClientClosed
)
;
}
await
clientWrapper
.
close
(
)
;
dispatch
(
{
type
:
DISCONNECT_RUNTIME_SUCCESS
runtime
:
{
id
type
:
runtime
.
type
}
}
)
;
}
catch
(
e
)
{
dispatch
(
{
type
:
DISCONNECT_RUNTIME_FAILURE
error
:
e
}
)
;
}
}
;
}
function
updateConnectionPromptSetting
(
connectionPromptEnabled
)
{
return
async
(
dispatch
getState
)
=
>
{
dispatch
(
{
type
:
UPDATE_CONNECTION_PROMPT_SETTING_START
}
)
;
try
{
const
runtime
=
getCurrentRuntime
(
getState
(
)
.
runtimes
)
;
const
{
clientWrapper
}
=
runtime
.
runtimeDetails
;
const
promptPrefName
=
RUNTIME_PREFERENCE
.
CONNECTION_PROMPT
;
await
clientWrapper
.
setPreference
(
promptPrefName
connectionPromptEnabled
)
;
connectionPromptEnabled
=
await
clientWrapper
.
getPreference
(
promptPrefName
connectionPromptEnabled
)
;
dispatch
(
{
type
:
UPDATE_CONNECTION_PROMPT_SETTING_SUCCESS
runtime
connectionPromptEnabled
}
)
;
}
catch
(
e
)
{
dispatch
(
{
type
:
UPDATE_CONNECTION_PROMPT_SETTING_FAILURE
error
:
e
}
)
;
}
}
;
}
function
updateMultiE10s
(
)
{
return
async
(
dispatch
getState
)
=
>
{
dispatch
(
{
type
:
UPDATE_RUNTIME_MULTIE10S_START
}
)
;
try
{
const
runtime
=
getCurrentRuntime
(
getState
(
)
.
runtimes
)
;
const
{
clientWrapper
}
=
runtime
.
runtimeDetails
;
const
{
isMultiE10s
}
=
await
clientWrapper
.
getDeviceDescription
(
)
;
dispatch
(
{
type
:
UPDATE_RUNTIME_MULTIE10S_SUCCESS
runtime
isMultiE10s
}
)
;
}
catch
(
e
)
{
dispatch
(
{
type
:
UPDATE_RUNTIME_MULTIE10S_FAILURE
error
:
e
}
)
;
}
}
;
}
function
watchRuntime
(
id
)
{
return
async
(
dispatch
getState
)
=
>
{
dispatch
(
{
type
:
WATCH_RUNTIME_START
}
)
;
try
{
if
(
id
=
=
=
RUNTIMES
.
THIS_FIREFOX
)
{
await
dispatch
(
connectRuntime
(
RUNTIMES
.
THIS_FIREFOX
)
)
;
}
const
runtime
=
findRuntimeById
(
id
getState
(
)
.
runtimes
)
;
await
dispatch
(
{
type
:
WATCH_RUNTIME_SUCCESS
runtime
}
)
;
dispatch
(
Actions
.
requestExtensions
(
)
)
;
dispatch
(
Actions
.
requestTabs
(
)
)
;
dispatch
(
Actions
.
requestWorkers
(
)
)
;
}
catch
(
e
)
{
dispatch
(
{
type
:
WATCH_RUNTIME_FAILURE
error
:
e
}
)
;
}
}
;
}
function
unwatchRuntime
(
id
)
{
return
async
(
dispatch
getState
)
=
>
{
const
runtime
=
findRuntimeById
(
id
getState
(
)
.
runtimes
)
;
dispatch
(
{
type
:
UNWATCH_RUNTIME_START
runtime
}
)
;
try
{
if
(
id
=
=
=
RUNTIMES
.
THIS_FIREFOX
)
{
await
dispatch
(
disconnectRuntime
(
RUNTIMES
.
THIS_FIREFOX
)
)
;
}
dispatch
(
{
type
:
UNWATCH_RUNTIME_SUCCESS
}
)
;
}
catch
(
e
)
{
dispatch
(
{
type
:
UNWATCH_RUNTIME_FAILURE
error
:
e
}
)
;
}
}
;
}
function
updateNetworkRuntimes
(
locations
)
{
const
runtimes
=
locations
.
map
(
location
=
>
{
const
[
host
port
]
=
location
.
split
(
"
:
"
)
;
return
{
id
:
location
extra
:
{
connectionParameters
:
{
host
port
:
parseInt
(
port
10
)
}
}
isUnknown
:
false
name
:
location
type
:
RUNTIMES
.
NETWORK
}
;
}
)
;
return
updateRemoteRuntimes
(
runtimes
RUNTIMES
.
NETWORK
)
;
}
function
updateUSBRuntimes
(
adbRuntimes
)
{
const
runtimes
=
adbRuntimes
.
map
(
adbRuntime
=
>
{
const
socketPath
=
adbRuntime
.
_socketPath
;
const
deviceId
=
adbRuntime
.
deviceId
;
const
connectionParameters
=
adbRuntime
.
isUnknown
(
)
?
null
:
{
deviceId
socketPath
}
;
return
{
id
:
adbRuntime
.
id
extra
:
{
connectionParameters
deviceName
:
adbRuntime
.
deviceName
}
isUnknown
:
adbRuntime
.
isUnknown
(
)
name
:
adbRuntime
.
shortName
type
:
RUNTIMES
.
USB
}
;
}
)
;
return
updateRemoteRuntimes
(
runtimes
RUNTIMES
.
USB
)
;
}
function
_isRuntimeValid
(
runtime
runtimes
)
{
const
isRuntimeAvailable
=
runtimes
.
some
(
r
=
>
r
.
id
=
=
=
runtime
.
id
)
;
const
isConnectionValid
=
runtime
.
runtimeDetails
&
&
!
runtime
.
runtimeDetails
.
clientWrapper
.
isClosed
(
)
;
return
isRuntimeAvailable
&
&
isConnectionValid
;
}
function
updateRemoteRuntimes
(
runtimes
type
)
{
return
async
(
dispatch
getState
)
=
>
{
const
currentRuntime
=
getCurrentRuntime
(
getState
(
)
.
runtimes
)
;
if
(
currentRuntime
&
&
currentRuntime
.
type
=
=
=
type
&
&
!
_isRuntimeValid
(
currentRuntime
runtimes
)
)
{
await
dispatch
(
Actions
.
selectPage
(
PAGE_TYPES
.
RUNTIME
RUNTIMES
.
THIS_FIREFOX
)
)
;
}
runtimes
.
forEach
(
runtime
=
>
{
const
existingRuntime
=
findRuntimeById
(
runtime
.
id
getState
(
)
.
runtimes
)
;
const
isConnectionValid
=
existingRuntime
&
&
existingRuntime
.
runtimeDetails
&
&
!
existingRuntime
.
runtimeDetails
.
clientWrapper
.
isClosed
(
)
;
runtime
.
runtimeDetails
=
isConnectionValid
?
existingRuntime
.
runtimeDetails
:
null
;
}
)
;
const
existingRuntimes
=
getAllRuntimes
(
getState
(
)
.
runtimes
)
;
for
(
const
runtime
of
existingRuntimes
)
{
const
isConnected
=
runtime
.
runtimeDetails
;
const
isSameType
=
runtime
.
type
=
=
=
type
;
if
(
isConnected
&
&
isSameType
&
&
!
_isRuntimeValid
(
runtime
runtimes
)
)
{
await
dispatch
(
disconnectRuntime
(
runtime
.
id
)
)
;
}
}
dispatch
(
{
type
:
REMOTE_RUNTIMES_UPDATED
runtimes
runtimeType
:
type
}
)
;
for
(
const
runtime
of
getAllRuntimes
(
getState
(
)
.
runtimes
)
)
{
if
(
runtime
.
type
!
=
=
type
)
{
continue
;
}
const
isConnected
=
!
!
runtime
.
runtimeDetails
;
const
hasConnectedClient
=
remoteClientManager
.
hasClient
(
runtime
.
id
runtime
.
type
)
;
if
(
!
isConnected
&
&
hasConnectedClient
)
{
await
dispatch
(
connectRuntime
(
runtime
.
id
)
)
;
}
}
}
;
}
function
removeRuntimeListeners
(
)
{
return
(
dispatch
getState
)
=
>
{
const
allRuntimes
=
getAllRuntimes
(
getState
(
)
.
runtimes
)
;
const
remoteRuntimes
=
allRuntimes
.
filter
(
r
=
>
r
.
type
!
=
=
RUNTIMES
.
THIS_FIREFOX
)
;
for
(
const
runtime
of
remoteRuntimes
)
{
if
(
runtime
.
runtimeDetails
)
{
const
{
clientWrapper
}
=
runtime
.
runtimeDetails
;
clientWrapper
.
removeListener
(
"
closed
"
onRemoteDebuggerClientClosed
)
;
}
}
}
;
}
module
.
exports
=
{
connectRuntime
createThisFirefoxRuntime
disconnectRuntime
removeRuntimeListeners
unwatchRuntime
updateConnectionPromptSetting
updateNetworkRuntimes
updateUSBRuntimes
watchRuntime
}
;
