"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
loader
.
lazyImporter
(
this
"
BrowserToolboxProcess
"
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
AddonManager
"
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
{
Toolbox
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
let
browserToolboxProcess
=
null
;
let
remoteAddonToolbox
=
null
;
function
closeToolbox
(
)
{
if
(
browserToolboxProcess
)
{
browserToolboxProcess
.
close
(
)
;
}
if
(
remoteAddonToolbox
)
{
remoteAddonToolbox
.
destroy
(
)
;
}
}
exports
.
debugLocalAddon
=
async
function
(
addonID
)
{
closeToolbox
(
)
;
browserToolboxProcess
=
BrowserToolboxProcess
.
init
(
{
addonID
onClose
:
(
)
=
>
{
browserToolboxProcess
=
null
;
}
}
)
;
}
;
exports
.
debugRemoteAddon
=
async
function
(
addonForm
client
)
{
closeToolbox
(
)
;
const
options
=
{
form
:
addonForm
chrome
:
true
client
}
;
const
target
=
await
TargetFactory
.
forRemoteTab
(
options
)
;
const
hostType
=
Toolbox
.
HostType
.
WINDOW
;
remoteAddonToolbox
=
await
gDevTools
.
showToolbox
(
target
null
hostType
)
;
remoteAddonToolbox
.
once
(
"
destroy
"
(
)
=
>
{
remoteAddonToolbox
=
null
;
}
)
;
}
;
exports
.
getAddonForm
=
async
function
(
addonID
client
)
{
const
{
addons
}
=
await
client
.
listAddons
(
)
;
return
addons
.
find
(
addon
=
>
addon
.
id
=
=
=
addonID
)
;
}
;
exports
.
uninstallAddon
=
async
function
(
addonID
)
{
const
addon
=
await
AddonManager
.
getAddonByID
(
addonID
)
;
return
addon
&
&
addon
.
uninstall
(
)
;
}
;
exports
.
parseFileUri
=
function
(
url
)
{
const
windowsRegex
=
/
^
file
:
\
/
\
/
\
/
(
[
a
-
zA
-
Z
]
:
\
/
.
*
)
/
;
if
(
windowsRegex
.
test
(
url
)
)
{
return
windowsRegex
.
exec
(
url
)
[
1
]
;
}
return
url
.
slice
(
"
file
:
/
/
"
.
length
)
;
}
;
exports
.
getExtensionUuid
=
function
(
extension
)
{
const
{
manifestURL
}
=
extension
;
return
manifestURL
?
/
moz
-
extension
:
\
/
\
/
(
[
^
/
]
*
)
/
.
exec
(
manifestURL
)
[
1
]
:
null
;
}
;
exports
.
openTemporaryExtension
=
function
(
win
message
)
{
return
new
Promise
(
resolve
=
>
{
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
win
message
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
open
(
res
=
>
{
if
(
res
=
=
Ci
.
nsIFilePicker
.
returnCancel
|
|
!
fp
.
file
)
{
return
;
}
let
file
=
fp
.
file
;
if
(
!
file
.
isDirectory
(
)
&
&
!
file
.
leafName
.
endsWith
(
"
.
xpi
"
)
&
&
!
file
.
leafName
.
endsWith
(
"
.
zip
"
)
)
{
file
=
file
.
parent
;
}
resolve
(
file
)
;
}
)
;
}
)
;
}
;
