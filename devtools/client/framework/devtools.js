"
use
strict
"
;
const
{
DevToolsShim
}
=
ChromeUtils
.
importESModule
(
"
chrome
:
/
/
devtools
-
startup
/
content
/
DevToolsShim
.
sys
.
mjs
"
)
;
const
{
DEFAULT_SANDBOX_NAME
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
BrowserToolboxLauncher
:
"
resource
:
/
/
devtools
/
client
/
framework
/
browser
-
toolbox
/
Launcher
.
sys
.
mjs
"
}
)
;
loader
.
lazyRequireGetter
(
this
"
LocalTabCommandsFactory
"
"
resource
:
/
/
devtools
/
client
/
framework
/
local
-
tab
-
commands
-
factory
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CommandsFactory
"
"
resource
:
/
/
devtools
/
shared
/
commands
/
commands
-
factory
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolboxHostManager
"
"
resource
:
/
/
devtools
/
client
/
framework
/
toolbox
-
host
-
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserConsoleManager
"
"
resource
:
/
/
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Toolbox
"
"
resource
:
/
/
devtools
/
client
/
framework
/
toolbox
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Telemetry
"
"
resource
:
/
/
devtools
/
client
/
shared
/
telemetry
.
js
"
)
;
const
{
defaultTools
:
DefaultTools
defaultThemes
:
DefaultThemes
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
definitions
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
getTheme
setTheme
getAutoTheme
addThemeObserver
removeThemeObserver
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
theme
.
js
"
)
;
const
FORBIDDEN_IDS
=
new
Set
(
[
"
toolbox
"
"
"
]
)
;
const
MAX_ORDINAL
=
99
;
const
POPUP_DEBUG_PREF
=
"
devtools
.
popups
.
debug
"
;
const
DEVTOOLS_ALWAYS_ON_TOP
=
"
devtools
.
toolbox
.
alwaysOnTop
"
;
class
DevTools
{
constructor
(
)
{
if
(
Services
.
appinfo
.
processType
!
=
Services
.
appinfo
.
PROCESS_TYPE_DEFAULT
|
|
!
Cu
.
getRealmLocation
(
globalThis
)
.
startsWith
(
DEFAULT_SANDBOX_NAME
)
)
{
throw
new
Error
(
"
This
module
should
be
loaded
in
the
parent
process
only
in
the
shared
global
.
"
)
;
}
this
.
_tools
=
new
Map
(
)
;
this
.
_themes
=
new
Map
(
)
;
this
.
_toolboxesPerCommands
=
new
Map
(
)
;
this
.
_creatingToolboxes
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
_telemetry
=
new
Telemetry
(
)
;
this
.
_commandsPromiseByWebExtId
=
new
Map
(
)
;
this
.
_onThemeChanged
=
this
.
_onThemeChanged
.
bind
(
this
)
;
addThemeObserver
(
this
.
_onThemeChanged
)
;
this
.
registerDefaults
(
)
;
DevToolsShim
.
register
(
this
)
;
}
chromeWindowType
=
"
navigator
:
browser
"
;
registerDefaults
(
)
{
this
.
getDefaultTools
(
)
.
forEach
(
definition
=
>
this
.
registerTool
(
definition
)
)
;
this
.
getDefaultThemes
(
)
.
forEach
(
definition
=
>
this
.
registerTheme
(
definition
)
)
;
}
unregisterDefaults
(
)
{
for
(
const
definition
of
this
.
getToolDefinitionArray
(
)
)
{
this
.
unregisterTool
(
definition
.
id
)
;
}
for
(
const
definition
of
this
.
getThemeDefinitionArray
(
)
)
{
this
.
unregisterTheme
(
definition
.
id
)
;
}
}
registerTool
(
toolDefinition
)
{
const
toolId
=
toolDefinition
.
id
;
if
(
!
toolId
|
|
FORBIDDEN_IDS
.
has
(
toolId
)
)
{
throw
new
Error
(
"
Invalid
definition
.
id
"
)
;
}
if
(
!
DefaultTools
.
includes
(
toolDefinition
)
)
{
toolDefinition
.
visibilityswitch
=
"
devtools
.
"
+
toolId
+
"
.
enabled
"
;
}
this
.
_tools
.
set
(
toolId
toolDefinition
)
;
this
.
emit
(
"
tool
-
registered
"
toolId
)
;
}
unregisterTool
(
toolId
isQuitApplication
)
{
this
.
_tools
.
delete
(
toolId
)
;
if
(
!
isQuitApplication
)
{
this
.
emit
(
"
tool
-
unregistered
"
toolId
)
;
}
}
ordinalSort
(
d1
d2
)
{
const
o1
=
typeof
d1
.
ordinal
=
=
"
number
"
?
d1
.
ordinal
:
MAX_ORDINAL
;
const
o2
=
typeof
d2
.
ordinal
=
=
"
number
"
?
d2
.
ordinal
:
MAX_ORDINAL
;
return
o1
-
o2
;
}
getDefaultTools
(
)
{
return
DefaultTools
.
sort
(
this
.
ordinalSort
)
;
}
getAdditionalTools
(
)
{
const
tools
=
[
]
;
for
(
const
[
value
]
of
this
.
_tools
)
{
if
(
!
DefaultTools
.
includes
(
value
)
)
{
tools
.
push
(
value
)
;
}
}
return
tools
.
sort
(
this
.
ordinalSort
)
;
}
getDefaultThemes
(
)
{
return
DefaultThemes
.
sort
(
this
.
ordinalSort
)
;
}
getToolDefinition
(
toolId
)
{
const
tool
=
this
.
_tools
.
get
(
toolId
)
;
if
(
!
tool
)
{
return
null
;
}
else
if
(
!
tool
.
visibilityswitch
)
{
return
tool
;
}
const
enabled
=
Services
.
prefs
.
getBoolPref
(
tool
.
visibilityswitch
true
)
;
return
enabled
?
tool
:
null
;
}
getToolDefinitionMap
(
)
{
const
tools
=
new
Map
(
)
;
for
(
const
[
id
definition
]
of
this
.
_tools
)
{
if
(
this
.
getToolDefinition
(
id
)
)
{
tools
.
set
(
id
definition
)
;
}
}
return
tools
;
}
getToolDefinitionArray
(
)
{
const
definitions
=
[
]
;
for
(
const
[
id
definition
]
of
this
.
_tools
)
{
if
(
this
.
getToolDefinition
(
id
)
)
{
definitions
.
push
(
definition
)
;
}
}
return
definitions
.
sort
(
this
.
ordinalSort
)
;
}
getTheme
(
)
{
return
getTheme
(
)
;
}
getAutoTheme
(
)
{
return
getAutoTheme
(
)
;
}
_onThemeChanged
(
)
{
this
.
emit
(
"
theme
-
changed
"
getTheme
(
)
)
;
}
registerTheme
(
themeDefinition
)
{
const
themeId
=
themeDefinition
.
id
;
if
(
!
themeId
)
{
throw
new
Error
(
"
Invalid
theme
id
"
)
;
}
if
(
this
.
_themes
.
get
(
themeId
)
)
{
throw
new
Error
(
"
Theme
with
the
same
id
is
already
registered
"
)
;
}
this
.
_themes
.
set
(
themeId
themeDefinition
)
;
this
.
emit
(
"
theme
-
registered
"
themeId
)
;
}
unregisterTheme
(
theme
)
{
let
themeId
=
null
;
if
(
typeof
theme
=
=
"
string
"
)
{
themeId
=
theme
;
theme
=
this
.
_themes
.
get
(
theme
)
;
}
else
{
themeId
=
theme
.
id
;
}
const
currTheme
=
getTheme
(
)
;
const
isCoreTheme
=
DefaultThemes
.
some
(
t
=
>
t
.
id
=
=
=
themeId
)
;
if
(
!
Services
.
startup
.
shuttingDown
&
&
!
isCoreTheme
&
&
theme
.
id
=
=
currTheme
)
{
setTheme
(
"
auto
"
)
;
this
.
emit
(
"
theme
-
unregistered
"
theme
)
;
}
this
.
_themes
.
delete
(
themeId
)
;
}
getThemeDefinition
(
themeId
)
{
const
theme
=
this
.
_themes
.
get
(
themeId
)
;
if
(
!
theme
)
{
return
null
;
}
return
theme
;
}
getThemeDefinitionMap
(
)
{
const
themes
=
new
Map
(
)
;
for
(
const
[
id
definition
]
of
this
.
_themes
)
{
if
(
this
.
getThemeDefinition
(
id
)
)
{
themes
.
set
(
id
definition
)
;
}
}
return
themes
;
}
getThemeDefinitionArray
(
)
{
const
definitions
=
[
]
;
for
(
const
[
id
definition
]
of
this
.
_themes
)
{
if
(
this
.
getThemeDefinition
(
id
)
)
{
definitions
.
push
(
definition
)
;
}
}
return
definitions
.
sort
(
this
.
ordinalSort
)
;
}
saveDevToolsSession
(
state
)
{
state
.
browserConsole
=
BrowserConsoleManager
.
getBrowserConsoleSessionState
(
)
;
state
.
browserToolbox
=
lazy
.
BrowserToolboxLauncher
.
getBrowserToolboxSessionState
(
)
;
}
async
restoreDevToolsSession
(
{
browserConsole
browserToolbox
}
)
{
if
(
browserToolbox
)
{
lazy
.
BrowserToolboxLauncher
.
init
(
)
;
}
if
(
browserConsole
&
&
!
BrowserConsoleManager
.
getBrowserConsole
(
)
)
{
await
BrowserConsoleManager
.
toggleBrowserConsole
(
)
;
}
}
_firstShowToolbox
=
true
;
async
showToolbox
(
commands
{
toolId
toolOptions
hostType
startTime
raise
=
true
reason
=
"
toolbox_show
"
hostOptions
}
=
{
}
)
{
let
toolbox
=
this
.
_toolboxesPerCommands
.
get
(
commands
)
;
if
(
toolbox
)
{
if
(
hostType
!
=
null
&
&
toolbox
.
hostType
!
=
hostType
)
{
await
toolbox
.
switchHost
(
hostType
)
;
}
if
(
toolId
!
=
null
)
{
await
toolbox
.
selectTool
(
toolId
reason
toolOptions
)
;
}
if
(
raise
)
{
await
toolbox
.
raise
(
)
;
}
}
else
{
const
promise
=
this
.
_creatingToolboxes
.
get
(
commands
)
;
if
(
promise
)
{
return
promise
;
}
const
toolboxPromise
=
this
.
_createToolbox
(
commands
{
toolId
toolOptions
hostType
hostOptions
}
)
;
this
.
_creatingToolboxes
.
set
(
commands
toolboxPromise
)
;
toolbox
=
await
toolboxPromise
;
this
.
_creatingToolboxes
.
delete
(
commands
)
;
if
(
startTime
)
{
this
.
logToolboxOpenTime
(
toolbox
startTime
)
;
}
this
.
_firstShowToolbox
=
false
;
}
const
width
=
Math
.
ceil
(
toolbox
.
win
.
outerWidth
/
50
)
*
50
;
const
panelName
=
this
.
makeToolIdHumanReadable
(
toolId
|
|
toolbox
.
defaultToolId
)
;
this
.
_telemetry
.
addEventProperty
(
toolbox
"
enter
"
panelName
null
"
width
"
width
)
;
return
toolbox
;
}
async
showToolboxForTab
(
tab
{
toolId
toolOptions
hostType
startTime
raise
reason
hostOptions
}
=
{
}
)
{
if
(
tab
.
linkedBrowser
.
browsingContext
.
opener
&
&
Services
.
prefs
.
getBoolPref
(
POPUP_DEBUG_PREF
)
)
{
const
openerTab
=
tab
.
ownerGlobal
.
gBrowser
.
getTabForBrowser
(
tab
.
linkedBrowser
.
browsingContext
.
opener
.
embedderElement
)
;
const
openerCommands
=
await
LocalTabCommandsFactory
.
getCommandsForTab
(
openerTab
)
;
if
(
this
.
getToolboxForCommands
(
openerCommands
)
)
{
console
.
log
(
"
Can
'
t
open
a
toolbox
for
this
document
as
this
is
debugged
from
its
opener
tab
"
)
;
return
null
;
}
}
const
commands
=
await
LocalTabCommandsFactory
.
createCommandsForTab
(
tab
)
;
return
this
.
showToolbox
(
commands
{
toolId
toolOptions
hostType
startTime
raise
reason
hostOptions
}
)
;
}
async
showToolboxForWebExtension
(
extensionId
{
toolId
}
=
{
}
)
{
let
commandsPromise
=
this
.
_commandsPromiseByWebExtId
.
get
(
extensionId
)
;
if
(
!
commandsPromise
)
{
commandsPromise
=
CommandsFactory
.
forAddon
(
extensionId
)
;
this
.
_commandsPromiseByWebExtId
.
set
(
extensionId
commandsPromise
)
;
}
const
commands
=
await
commandsPromise
;
commands
.
client
.
once
(
"
closed
"
)
.
then
(
(
)
=
>
{
this
.
_commandsPromiseByWebExtId
.
delete
(
extensionId
)
;
}
)
;
return
this
.
showToolbox
(
commands
{
hostType
:
Toolbox
.
HostType
.
WINDOW
hostOptions
:
{
alwaysOnTop
:
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ALWAYS_ON_TOP
false
)
}
toolId
}
)
;
}
logToolboxOpenTime
(
toolbox
startTime
)
{
const
toolId
=
toolbox
.
currentToolId
|
|
toolbox
.
defaultToolId
;
const
delay
=
ChromeUtils
.
now
(
)
-
startTime
;
const
panelName
=
this
.
makeToolIdHumanReadable
(
toolId
)
;
if
(
this
.
_firstShowToolbox
)
{
Glean
.
devtools
.
coldToolboxOpenDelay
[
toolId
]
.
accumulateSingleSample
(
delay
)
;
}
else
{
Glean
.
devtools
.
warmToolboxOpenDelay
[
toolId
]
.
accumulateSingleSample
(
delay
)
;
}
const
browserWin
=
toolbox
.
topWindow
;
this
.
_telemetry
.
addEventProperty
(
browserWin
"
open
"
"
tools
"
null
"
first_panel
"
panelName
)
;
}
makeToolIdHumanReadable
(
toolId
)
{
if
(
/
^
[
0
-
9a
-
fA
-
F
]
{
40
}
_temporary
-
addon
/
.
test
(
toolId
)
)
{
return
"
temporary
-
addon
"
;
}
let
matches
=
toolId
.
match
(
/
^
_
(
[
0
-
9a
-
fA
-
F
]
{
8
}
-
[
0
-
9a
-
fA
-
F
]
{
4
}
-
[
0
-
9a
-
fA
-
F
]
{
4
}
-
[
0
-
9a
-
fA
-
F
]
{
4
}
-
[
0
-
9a
-
fA
-
F
]
{
12
}
)
_
/
)
;
if
(
matches
&
&
matches
.
length
=
=
=
2
)
{
return
matches
[
1
]
;
}
matches
=
toolId
.
match
(
/
^
_
?
(
.
*
)
-
\
d
+
-
\
d
+
-
devtools
-
panel
/
)
;
if
(
matches
&
&
matches
.
length
=
=
=
2
)
{
return
matches
[
1
]
;
}
return
toolId
;
}
async
_createToolbox
(
commands
{
toolId
toolOptions
hostType
hostOptions
}
=
{
}
)
{
const
manager
=
new
ToolboxHostManager
(
commands
hostType
hostOptions
)
;
const
toolbox
=
await
manager
.
create
(
toolId
toolOptions
)
;
this
.
_toolboxesPerCommands
.
set
(
commands
toolbox
)
;
toolbox
.
once
(
"
destroy
"
(
)
=
>
{
this
.
emit
(
"
toolbox
-
destroy
"
toolbox
)
;
}
)
;
toolbox
.
once
(
"
destroyed
"
(
)
=
>
{
this
.
_toolboxesPerCommands
.
delete
(
commands
)
;
this
.
emit
(
"
toolbox
-
destroyed
"
toolbox
)
;
}
)
;
await
toolbox
.
open
(
)
;
this
.
emit
(
"
toolbox
-
ready
"
toolbox
)
;
return
toolbox
;
}
getToolboxForCommands
(
commands
)
{
return
this
.
_toolboxesPerCommands
.
get
(
commands
)
;
}
getToolboxForDescriptorFront
(
descriptorFront
)
{
for
(
const
[
commands
toolbox
]
of
this
.
_toolboxesPerCommands
)
{
if
(
commands
.
descriptorFront
=
=
descriptorFront
)
{
return
toolbox
;
}
}
return
null
;
}
getToolboxForTab
(
tab
)
{
return
this
.
getToolboxes
(
)
.
find
(
t
=
>
t
.
commands
.
descriptorFront
.
localTab
=
=
=
tab
)
;
}
async
closeToolboxForTab
(
tab
)
{
const
commands
=
await
LocalTabCommandsFactory
.
getCommandsForTab
(
tab
)
;
let
toolbox
=
await
this
.
_creatingToolboxes
.
get
(
commands
)
;
if
(
!
toolbox
)
{
toolbox
=
this
.
_toolboxesPerCommands
.
get
(
commands
)
;
}
if
(
!
toolbox
)
{
return
;
}
await
toolbox
.
destroy
(
)
;
}
createCommandsForTabForWebExtension
(
tab
)
{
return
CommandsFactory
.
forTab
(
tab
{
isWebExtension
:
true
}
)
;
}
openBrowserConsole
(
)
{
const
{
BrowserConsoleManager
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
.
js
"
)
;
BrowserConsoleManager
.
openBrowserConsoleOrFocus
(
)
;
}
async
inspectNode
(
tab
domReference
startTime
)
{
const
toolboxWasOpened
=
!
!
gDevTools
.
getToolboxForTab
(
tab
)
;
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
inspector
"
toolOptions
:
{
defaultStartupNodeDomReference
:
domReference
defaultStartupNodeSelectionReason
:
"
browser
-
context
-
menu
"
}
startTime
reason
:
"
inspect_dom
"
}
)
;
if
(
!
toolboxWasOpened
)
{
return
;
}
const
inspector
=
toolbox
.
getCurrentPanel
(
)
;
const
nodeFront
=
await
inspector
.
inspectorFront
.
getNodeActorFromContentDomReference
(
domReference
)
;
if
(
!
nodeFront
)
{
return
;
}
const
onNewNode
=
inspector
.
selection
.
once
(
"
new
-
node
-
front
"
)
;
inspector
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
"
browser
-
context
-
menu
"
}
)
;
await
onNewNode
;
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
async
inspectA11Y
(
tab
domReference
startTime
)
{
const
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
:
"
accessibility
"
startTime
}
)
;
const
inspectorFront
=
await
toolbox
.
target
.
getFront
(
"
inspector
"
)
;
const
nodeFront
=
await
inspectorFront
.
getNodeActorFromContentDomReference
(
domReference
)
;
if
(
!
nodeFront
)
{
return
;
}
const
a11yPanel
=
toolbox
.
getCurrentPanel
(
)
;
const
onSelected
=
a11yPanel
.
once
(
"
new
-
accessible
-
front
-
selected
"
)
;
a11yPanel
.
selectAccessibleForNode
(
nodeFront
"
browser
-
context
-
menu
"
)
;
await
onSelected
;
}
destroy
(
{
shuttingDown
}
)
{
if
(
!
shuttingDown
)
{
for
(
const
[
toolbox
]
of
this
.
_toolboxesPerCommands
)
{
toolbox
.
destroy
(
)
;
}
}
for
(
const
[
key
]
of
this
.
getToolDefinitionMap
(
)
)
{
this
.
unregisterTool
(
key
true
)
;
}
gDevTools
.
unregisterDefaults
(
)
;
removeThemeObserver
(
this
.
_onThemeChanged
)
;
if
(
!
shuttingDown
)
{
DevToolsShim
.
unregister
(
)
;
}
}
getToolboxes
(
)
{
return
Array
.
from
(
this
.
_toolboxesPerCommands
.
values
(
)
)
;
}
hasToolboxForTab
(
tab
)
{
return
this
.
getToolboxes
(
)
.
some
(
t
=
>
t
.
commands
.
descriptorFront
.
localTab
=
=
=
tab
)
;
}
}
const
gDevTools
=
(
exports
.
gDevTools
=
new
DevTools
(
)
)
;
