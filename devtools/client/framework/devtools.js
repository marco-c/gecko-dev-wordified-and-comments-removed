"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
DevToolsShim
}
=
Cu
.
import
(
"
chrome
:
/
/
devtools
-
shim
/
content
/
DevToolsShim
.
jsm
"
{
}
)
;
loader
.
lazyRequireGetter
(
this
"
TargetFactory
"
"
devtools
/
client
/
framework
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TabTarget
"
"
devtools
/
client
/
framework
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Toolbox
"
"
devtools
/
client
/
framework
/
toolbox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolboxHostManager
"
"
devtools
/
client
/
framework
/
toolbox
-
host
-
manager
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevToolsBrowser
"
"
devtools
/
client
/
framework
/
devtools
-
browser
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HUDService
"
"
devtools
/
client
/
webconsole
/
hudservice
"
true
)
;
loader
.
lazyImporter
(
this
"
ScratchpadManager
"
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
WebExtensionInspectedWindowFront
"
"
devtools
/
shared
/
fronts
/
webextension
-
inspected
-
window
"
true
)
;
const
{
defaultTools
:
DefaultTools
defaultThemes
:
DefaultThemes
}
=
require
(
"
devtools
/
client
/
definitions
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
old
-
event
-
emitter
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
getTheme
setTheme
addThemeObserver
removeThemeObserver
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
const
FORBIDDEN_IDS
=
new
Set
(
[
"
toolbox
"
"
"
]
)
;
const
MAX_ORDINAL
=
99
;
function
DevTools
(
)
{
this
.
_tools
=
new
Map
(
)
;
this
.
_themes
=
new
Map
(
)
;
this
.
_toolboxes
=
new
Map
(
)
;
this
.
_creatingToolboxes
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
_onThemeChanged
=
this
.
_onThemeChanged
.
bind
(
this
)
;
addThemeObserver
(
this
.
_onThemeChanged
)
;
this
.
registerDefaults
(
)
;
DevToolsShim
.
register
(
this
)
;
}
DevTools
.
prototype
=
{
chromeWindowType
:
"
navigator
:
browser
"
registerDefaults
(
)
{
this
.
getDefaultTools
(
)
.
forEach
(
definition
=
>
this
.
registerTool
(
definition
)
)
;
this
.
getDefaultThemes
(
)
.
forEach
(
definition
=
>
this
.
registerTheme
(
definition
)
)
;
}
unregisterDefaults
(
)
{
for
(
let
definition
of
this
.
getToolDefinitionArray
(
)
)
{
this
.
unregisterTool
(
definition
.
id
)
;
}
for
(
let
definition
of
this
.
getThemeDefinitionArray
(
)
)
{
this
.
unregisterTheme
(
definition
.
id
)
;
}
}
registerTool
(
toolDefinition
)
{
let
toolId
=
toolDefinition
.
id
;
if
(
!
toolId
|
|
FORBIDDEN_IDS
.
has
(
toolId
)
)
{
throw
new
Error
(
"
Invalid
definition
.
id
"
)
;
}
if
(
!
DefaultTools
.
includes
(
toolDefinition
)
)
{
toolDefinition
.
visibilityswitch
=
"
devtools
.
"
+
toolId
+
"
.
enabled
"
;
}
this
.
_tools
.
set
(
toolId
toolDefinition
)
;
this
.
emit
(
"
tool
-
registered
"
toolId
)
;
}
unregisterTool
(
tool
isQuitApplication
)
{
let
toolId
=
null
;
if
(
typeof
tool
=
=
"
string
"
)
{
toolId
=
tool
;
tool
=
this
.
_tools
.
get
(
tool
)
;
}
else
{
let
{
Deprecated
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Deprecated
.
jsm
"
{
}
)
;
Deprecated
.
warning
(
"
Deprecation
WARNING
:
gDevTools
.
unregisterTool
(
tool
)
is
"
+
"
deprecated
.
You
should
unregister
a
tool
using
its
toolId
:
"
+
"
gDevTools
.
unregisterTool
(
toolId
)
.
"
)
;
toolId
=
tool
.
id
;
}
this
.
_tools
.
delete
(
toolId
)
;
if
(
!
isQuitApplication
)
{
this
.
emit
(
"
tool
-
unregistered
"
toolId
)
;
}
}
ordinalSort
(
d1
d2
)
{
let
o1
=
(
typeof
d1
.
ordinal
=
=
"
number
"
)
?
d1
.
ordinal
:
MAX_ORDINAL
;
let
o2
=
(
typeof
d2
.
ordinal
=
=
"
number
"
)
?
d2
.
ordinal
:
MAX_ORDINAL
;
return
o1
-
o2
;
}
getDefaultTools
(
)
{
return
DefaultTools
.
sort
(
this
.
ordinalSort
)
;
}
getAdditionalTools
(
)
{
let
tools
=
[
]
;
for
(
let
[
value
]
of
this
.
_tools
)
{
if
(
!
DefaultTools
.
includes
(
value
)
)
{
tools
.
push
(
value
)
;
}
}
return
tools
.
sort
(
this
.
ordinalSort
)
;
}
getDefaultThemes
(
)
{
return
DefaultThemes
.
sort
(
this
.
ordinalSort
)
;
}
getToolDefinition
(
toolId
)
{
let
tool
=
this
.
_tools
.
get
(
toolId
)
;
if
(
!
tool
)
{
return
null
;
}
else
if
(
!
tool
.
visibilityswitch
)
{
return
tool
;
}
let
enabled
=
Services
.
prefs
.
getBoolPref
(
tool
.
visibilityswitch
true
)
;
return
enabled
?
tool
:
null
;
}
getToolDefinitionMap
(
)
{
let
tools
=
new
Map
(
)
;
for
(
let
[
id
definition
]
of
this
.
_tools
)
{
if
(
this
.
getToolDefinition
(
id
)
)
{
tools
.
set
(
id
definition
)
;
}
}
return
tools
;
}
getToolDefinitionArray
(
)
{
let
definitions
=
[
]
;
for
(
let
[
id
definition
]
of
this
.
_tools
)
{
if
(
this
.
getToolDefinition
(
id
)
)
{
definitions
.
push
(
definition
)
;
}
}
return
definitions
.
sort
(
this
.
ordinalSort
)
;
}
getTheme
(
)
{
return
getTheme
(
)
;
}
_onThemeChanged
(
)
{
this
.
emit
(
"
theme
-
changed
"
getTheme
(
)
)
;
}
registerTheme
(
themeDefinition
)
{
let
themeId
=
themeDefinition
.
id
;
if
(
!
themeId
)
{
throw
new
Error
(
"
Invalid
theme
id
"
)
;
}
if
(
this
.
_themes
.
get
(
themeId
)
)
{
throw
new
Error
(
"
Theme
with
the
same
id
is
already
registered
"
)
;
}
this
.
_themes
.
set
(
themeId
themeDefinition
)
;
this
.
emit
(
"
theme
-
registered
"
themeId
)
;
}
unregisterTheme
(
theme
)
{
let
themeId
=
null
;
if
(
typeof
theme
=
=
"
string
"
)
{
themeId
=
theme
;
theme
=
this
.
_themes
.
get
(
theme
)
;
}
else
{
themeId
=
theme
.
id
;
}
let
currTheme
=
getTheme
(
)
;
let
isCoreTheme
=
DefaultThemes
.
some
(
t
=
>
t
.
id
=
=
=
themeId
)
;
if
(
!
Services
.
startup
.
shuttingDown
&
&
!
isCoreTheme
&
&
theme
.
id
=
=
currTheme
)
{
setTheme
(
"
light
"
)
;
this
.
emit
(
"
theme
-
unregistered
"
theme
)
;
}
this
.
_themes
.
delete
(
themeId
)
;
}
getThemeDefinition
(
themeId
)
{
let
theme
=
this
.
_themes
.
get
(
themeId
)
;
if
(
!
theme
)
{
return
null
;
}
return
theme
;
}
getThemeDefinitionMap
(
)
{
let
themes
=
new
Map
(
)
;
for
(
let
[
id
definition
]
of
this
.
_themes
)
{
if
(
this
.
getThemeDefinition
(
id
)
)
{
themes
.
set
(
id
definition
)
;
}
}
return
themes
;
}
getThemeDefinitionArray
(
)
{
let
definitions
=
[
]
;
for
(
let
[
id
definition
]
of
this
.
_themes
)
{
if
(
this
.
getThemeDefinition
(
id
)
)
{
definitions
.
push
(
definition
)
;
}
}
return
definitions
.
sort
(
this
.
ordinalSort
)
;
}
saveDevToolsSession
:
function
(
state
)
{
state
.
browserConsole
=
HUDService
.
getBrowserConsoleSessionState
(
)
;
state
.
scratchpads
=
[
]
;
if
(
Cu
.
isModuleLoaded
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
)
{
state
.
scratchpads
=
ScratchpadManager
.
getSessionState
(
)
;
}
}
restoreDevToolsSession
:
function
(
{
scratchpads
browserConsole
}
)
{
if
(
scratchpads
)
{
ScratchpadManager
.
restoreSession
(
scratchpads
)
;
}
if
(
browserConsole
&
&
!
HUDService
.
getBrowserConsole
(
)
)
{
HUDService
.
toggleBrowserConsole
(
)
;
}
}
_firstShowToolbox
:
true
showToolbox
:
Task
.
async
(
function
*
(
target
toolId
hostType
hostOptions
startTime
)
{
let
toolbox
=
this
.
_toolboxes
.
get
(
target
)
;
if
(
toolbox
)
{
if
(
hostType
!
=
null
&
&
toolbox
.
hostType
!
=
hostType
)
{
yield
toolbox
.
switchHost
(
hostType
)
;
}
if
(
toolId
!
=
null
&
&
toolbox
.
currentToolId
!
=
toolId
)
{
yield
toolbox
.
selectTool
(
toolId
)
;
}
toolbox
.
raise
(
)
;
}
else
{
let
promise
=
this
.
_creatingToolboxes
.
get
(
target
)
;
if
(
promise
)
{
return
yield
promise
;
}
let
toolboxPromise
=
this
.
createToolbox
(
target
toolId
hostType
hostOptions
)
;
this
.
_creatingToolboxes
.
set
(
target
toolboxPromise
)
;
toolbox
=
yield
toolboxPromise
;
this
.
_creatingToolboxes
.
delete
(
target
)
;
if
(
startTime
)
{
this
.
logToolboxOpenTime
(
toolbox
.
currentToolId
startTime
)
;
}
this
.
_firstShowToolbox
=
false
;
}
return
toolbox
;
}
)
logToolboxOpenTime
(
toolId
startTime
)
{
let
{
performance
}
=
Services
.
appShell
.
hiddenDOMWindow
;
let
delay
=
performance
.
now
(
)
-
startTime
;
let
telemetryKey
=
this
.
_firstShowToolbox
?
"
DEVTOOLS_COLD_TOOLBOX_OPEN_DELAY_MS
"
:
"
DEVTOOLS_WARM_TOOLBOX_OPEN_DELAY_MS
"
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
telemetryKey
)
;
histogram
.
add
(
toolId
delay
)
;
}
createToolbox
:
Task
.
async
(
function
*
(
target
toolId
hostType
hostOptions
)
{
let
manager
=
new
ToolboxHostManager
(
target
hostType
hostOptions
)
;
let
toolbox
=
yield
manager
.
create
(
toolId
)
;
this
.
_toolboxes
.
set
(
target
toolbox
)
;
this
.
emit
(
"
toolbox
-
created
"
toolbox
)
;
toolbox
.
once
(
"
destroy
"
(
)
=
>
{
this
.
emit
(
"
toolbox
-
destroy
"
target
)
;
}
)
;
toolbox
.
once
(
"
destroyed
"
(
)
=
>
{
this
.
_toolboxes
.
delete
(
target
)
;
this
.
emit
(
"
toolbox
-
destroyed
"
target
)
;
}
)
;
yield
toolbox
.
open
(
)
;
this
.
emit
(
"
toolbox
-
ready
"
toolbox
)
;
return
toolbox
;
}
)
getToolbox
(
target
)
{
return
this
.
_toolboxes
.
get
(
target
)
;
}
closeToolbox
:
Task
.
async
(
function
*
(
target
)
{
let
toolbox
=
yield
this
.
_creatingToolboxes
.
get
(
target
)
;
if
(
!
toolbox
)
{
toolbox
=
this
.
_toolboxes
.
get
(
target
)
;
}
if
(
!
toolbox
)
{
return
false
;
}
yield
toolbox
.
destroy
(
)
;
return
true
;
}
)
getTargetForTab
:
function
(
tab
)
{
return
TargetFactory
.
forTab
(
tab
)
;
}
createTargetForTab
:
function
(
tab
)
{
return
new
TabTarget
(
tab
)
;
}
createWebExtensionInspectedWindowFront
:
function
(
tabTarget
)
{
return
new
WebExtensionInspectedWindowFront
(
tabTarget
.
client
tabTarget
.
form
)
;
}
openBrowserConsole
:
function
(
)
{
let
{
HUDService
}
=
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
;
HUDService
.
openBrowserConsoleOrFocus
(
)
;
}
async
inspectNode
(
tab
nodeSelectors
startTime
)
{
let
target
=
TargetFactory
.
forTab
(
tab
)
;
let
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
inspector
"
null
null
startTime
)
;
let
inspector
=
toolbox
.
getCurrentPanel
(
)
;
let
onNewNode
=
inspector
.
selection
.
once
(
"
new
-
node
-
front
"
)
;
async
function
querySelectors
(
nodeFront
)
{
let
selector
=
nodeSelectors
.
pop
(
)
;
if
(
!
selector
)
{
return
nodeFront
;
}
nodeFront
=
await
inspector
.
walker
.
querySelector
(
nodeFront
selector
)
;
if
(
nodeSelectors
.
length
>
0
)
{
let
{
nodes
}
=
await
inspector
.
walker
.
children
(
nodeFront
)
;
nodeFront
=
nodes
[
0
]
;
}
return
querySelectors
(
nodeFront
)
;
}
let
nodeFront
=
await
inspector
.
walker
.
getRootNode
(
)
;
nodeFront
=
await
querySelectors
(
nodeFront
)
;
inspector
.
selection
.
setNodeFront
(
nodeFront
"
browser
-
context
-
menu
"
)
;
await
onNewNode
;
await
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
destroy
(
{
shuttingDown
}
)
{
if
(
!
shuttingDown
)
{
for
(
let
[
toolbox
]
of
this
.
_toolboxes
)
{
toolbox
.
destroy
(
)
;
}
}
for
(
let
[
key
]
of
this
.
getToolDefinitionMap
(
)
)
{
this
.
unregisterTool
(
key
true
)
;
}
gDevTools
.
unregisterDefaults
(
)
;
removeThemeObserver
(
this
.
_onThemeChanged
)
;
if
(
!
shuttingDown
)
{
DevToolsShim
.
unregister
(
)
;
}
}
*
[
Symbol
.
iterator
]
(
)
{
for
(
let
toolbox
of
this
.
_toolboxes
)
{
yield
toolbox
;
}
}
}
;
const
gDevTools
=
exports
.
gDevTools
=
new
DevTools
(
)
;
