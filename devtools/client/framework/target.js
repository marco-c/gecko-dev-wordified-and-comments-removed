"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerServer
"
"
devtools
/
server
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
const
targets
=
new
WeakMap
(
)
;
const
promiseTargets
=
new
WeakMap
(
)
;
const
TargetFactory
=
exports
.
TargetFactory
=
{
forTab
:
function
(
tab
)
{
let
target
=
targets
.
get
(
tab
)
;
if
(
target
=
=
null
)
{
target
=
new
TabTarget
(
tab
)
;
targets
.
set
(
tab
target
)
;
}
return
target
;
}
forRemoteTab
:
function
(
options
)
{
let
targetPromise
=
promiseTargets
.
get
(
options
)
;
if
(
targetPromise
=
=
null
)
{
let
target
=
new
TabTarget
(
options
)
;
targetPromise
=
target
.
makeRemote
(
)
.
then
(
(
)
=
>
target
)
;
promiseTargets
.
set
(
options
targetPromise
)
;
}
return
targetPromise
;
}
forWorker
:
function
(
workerClient
)
{
let
target
=
targets
.
get
(
workerClient
)
;
if
(
target
=
=
null
)
{
target
=
new
WorkerTarget
(
workerClient
)
;
targets
.
set
(
workerClient
target
)
;
}
return
target
;
}
isKnownTab
:
function
(
tab
)
{
return
targets
.
has
(
tab
)
;
}
}
;
function
TabTarget
(
tab
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
activeTab
=
this
.
activeConsole
=
null
;
if
(
tab
&
&
!
[
"
client
"
"
form
"
"
chrome
"
]
.
every
(
tab
.
hasOwnProperty
tab
)
)
{
this
.
_tab
=
tab
;
this
.
_setupListeners
(
)
;
}
else
{
this
.
_form
=
tab
.
form
;
this
.
_url
=
this
.
_form
.
url
;
this
.
_title
=
this
.
_form
.
title
;
this
.
_client
=
tab
.
client
;
this
.
_chrome
=
tab
.
chrome
;
}
if
(
typeof
tab
.
isTabActor
=
=
"
boolean
"
)
{
this
.
_isTabActor
=
tab
.
isTabActor
;
}
else
{
this
.
_isTabActor
=
true
;
}
}
exports
.
TabTarget
=
TabTarget
;
TabTarget
.
prototype
=
{
_webProgressListener
:
null
getActorDescription
:
function
(
actorName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
getActorDescription
(
)
can
only
be
called
on
"
+
"
remote
tabs
.
"
)
;
}
let
deferred
=
defer
(
)
;
if
(
this
.
_protocolDescription
&
&
this
.
_protocolDescription
.
types
[
actorName
]
)
{
deferred
.
resolve
(
this
.
_protocolDescription
.
types
[
actorName
]
)
;
}
else
{
this
.
client
.
mainRoot
.
protocolDescription
(
description
=
>
{
this
.
_protocolDescription
=
description
;
deferred
.
resolve
(
description
.
types
[
actorName
]
)
;
}
)
;
}
return
deferred
.
promise
;
}
hasActor
:
function
(
actorName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
hasActor
(
)
can
only
be
called
on
remote
"
+
"
tabs
.
"
)
;
}
if
(
this
.
form
)
{
return
!
!
this
.
form
[
actorName
+
"
Actor
"
]
;
}
return
false
;
}
actorHasMethod
:
function
(
actorName
methodName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
actorHasMethod
(
)
can
only
be
called
on
"
+
"
remote
tabs
.
"
)
;
}
return
this
.
getActorDescription
(
actorName
)
.
then
(
desc
=
>
{
if
(
desc
&
&
desc
.
methods
)
{
return
!
!
desc
.
methods
.
find
(
method
=
>
method
.
name
=
=
=
methodName
)
;
}
return
false
;
}
)
;
}
getTrait
:
function
(
traitName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
getTrait
(
)
can
only
be
called
on
remote
"
+
"
tabs
.
"
)
;
}
if
(
this
.
form
.
traits
&
&
traitName
in
this
.
form
.
traits
)
{
return
this
.
form
.
traits
[
traitName
]
;
}
return
this
.
client
.
traits
[
traitName
]
;
}
get
tab
(
)
{
return
this
.
_tab
;
}
get
form
(
)
{
return
this
.
_form
;
}
get
root
(
)
{
if
(
!
this
.
_root
)
{
this
.
_root
=
this
.
_getRoot
(
)
;
}
return
this
.
_root
;
}
_getRoot
:
function
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
client
.
listTabs
(
response
=
>
{
if
(
response
.
error
)
{
reject
(
new
Error
(
response
.
error
+
"
:
"
+
response
.
message
)
)
;
return
;
}
resolve
(
response
)
;
}
)
;
}
)
;
}
get
client
(
)
{
return
this
.
_client
;
}
get
chrome
(
)
{
return
this
.
_chrome
;
}
get
isTabActor
(
)
{
return
this
.
_isTabActor
;
}
get
window
(
)
{
if
(
Services
.
appinfo
.
processType
!
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
)
{
console
.
error
(
"
The
.
window
getter
on
devtools
'
|
target
|
object
isn
'
t
"
+
"
e10s
friendly
!
\
n
"
+
Error
(
)
.
stack
)
;
}
if
(
this
.
_tab
&
&
this
.
_tab
.
linkedBrowser
)
{
return
this
.
_tab
.
linkedBrowser
.
contentWindow
;
}
return
null
;
}
get
name
(
)
{
if
(
this
.
isAddon
)
{
return
this
.
_form
.
name
;
}
return
this
.
_title
;
}
get
url
(
)
{
return
this
.
_url
;
}
get
isRemote
(
)
{
return
!
this
.
isLocalTab
;
}
get
isAddon
(
)
{
return
!
!
(
this
.
_form
&
&
this
.
_form
.
actor
&
&
(
this
.
_form
.
actor
.
match
(
/
conn
\
d
+
\
.
addon
\
d
+
/
)
|
|
this
.
_form
.
actor
.
match
(
/
conn
\
d
+
\
.
webExtension
\
d
+
/
)
)
)
;
}
get
isWebExtension
(
)
{
return
!
!
(
this
.
_form
&
&
this
.
_form
.
actor
&
&
this
.
_form
.
actor
.
match
(
/
conn
\
d
+
\
.
webExtension
\
d
+
/
)
)
;
}
get
isLocalTab
(
)
{
return
!
!
this
.
_tab
;
}
get
isMultiProcess
(
)
{
return
!
this
.
window
;
}
makeRemote
:
function
(
)
{
if
(
this
.
_remote
)
{
return
this
.
_remote
.
promise
;
}
this
.
_remote
=
defer
(
)
;
if
(
this
.
isLocalTab
)
{
if
(
!
DebuggerServer
.
initialized
)
{
DebuggerServer
.
init
(
)
;
}
DebuggerServer
.
registerActors
(
{
root
:
true
browser
:
true
tab
:
false
}
)
;
this
.
_client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
this
.
_chrome
=
false
;
}
this
.
_setupRemoteListeners
(
)
;
let
attachTab
=
(
)
=
>
{
this
.
_client
.
attachTab
(
this
.
_form
.
actor
(
response
tabClient
)
=
>
{
if
(
!
tabClient
)
{
this
.
_remote
.
reject
(
"
Unable
to
attach
to
the
tab
"
)
;
return
;
}
this
.
activeTab
=
tabClient
;
this
.
threadActor
=
response
.
threadActor
;
attachConsole
(
)
;
}
)
;
}
;
let
onConsoleAttached
=
(
response
consoleClient
)
=
>
{
if
(
!
consoleClient
)
{
this
.
_remote
.
reject
(
"
Unable
to
attach
to
the
console
"
)
;
return
;
}
this
.
activeConsole
=
consoleClient
;
this
.
_remote
.
resolve
(
null
)
;
}
;
let
attachConsole
=
(
)
=
>
{
this
.
_client
.
attachConsole
(
this
.
_form
.
consoleActor
[
"
NetworkActivity
"
]
onConsoleAttached
)
;
}
;
if
(
this
.
isLocalTab
)
{
this
.
_client
.
connect
(
)
.
then
(
(
)
=
>
this
.
_client
.
getTab
(
{
tab
:
this
.
tab
}
)
)
.
then
(
response
=
>
{
this
.
_form
=
response
.
tab
;
this
.
_url
=
this
.
_form
.
url
;
this
.
_title
=
this
.
_form
.
title
;
attachTab
(
)
;
}
e
=
>
this
.
_remote
.
reject
(
e
)
)
;
}
else
if
(
this
.
isTabActor
)
{
attachTab
(
)
;
}
else
{
attachConsole
(
)
;
}
return
this
.
_remote
.
promise
;
}
_setupListeners
:
function
(
)
{
this
.
_webProgressListener
=
new
TabWebProgressListener
(
this
)
;
this
.
tab
.
linkedBrowser
.
addProgressListener
(
this
.
_webProgressListener
)
;
this
.
tab
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
tab
.
parentNode
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
tab
.
ownerDocument
.
defaultView
.
addEventListener
(
"
unload
"
this
)
;
this
.
tab
.
addEventListener
(
"
TabRemotenessChange
"
this
)
;
}
_teardownListeners
:
function
(
)
{
if
(
this
.
_webProgressListener
)
{
this
.
_webProgressListener
.
destroy
(
)
;
}
this
.
_tab
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
unload
"
this
)
;
this
.
_tab
.
removeEventListener
(
"
TabClose
"
this
)
;
this
.
_tab
.
parentNode
.
removeEventListener
(
"
TabSelect
"
this
)
;
this
.
_tab
.
removeEventListener
(
"
TabRemotenessChange
"
this
)
;
}
_setupRemoteListeners
:
function
(
)
{
this
.
client
.
addListener
(
"
closed
"
this
.
destroy
)
;
this
.
_onTabDetached
=
(
type
packet
)
=
>
{
if
(
packet
.
from
=
=
this
.
_form
.
actor
)
{
this
.
destroy
(
)
;
}
}
;
this
.
client
.
addListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
_onTabNavigated
=
(
type
packet
)
=
>
{
let
event
=
Object
.
create
(
null
)
;
event
.
url
=
packet
.
url
;
event
.
title
=
packet
.
title
;
event
.
nativeConsoleAPI
=
packet
.
nativeConsoleAPI
;
event
.
isFrameSwitching
=
packet
.
isFrameSwitching
;
if
(
!
packet
.
isFrameSwitching
)
{
this
.
_url
=
packet
.
url
;
this
.
_title
=
packet
.
title
;
}
if
(
packet
.
state
=
=
"
start
"
)
{
event
.
_navPayload
=
this
.
_navRequest
;
this
.
emit
(
"
will
-
navigate
"
event
)
;
this
.
_navRequest
=
null
;
}
else
{
event
.
_navPayload
=
this
.
_navWindow
;
this
.
emit
(
"
navigate
"
event
)
;
this
.
_navWindow
=
null
;
}
}
;
this
.
client
.
addListener
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
_onFrameUpdate
=
(
type
packet
)
=
>
{
this
.
emit
(
"
frame
-
update
"
packet
)
;
}
;
this
.
client
.
addListener
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
this
.
_onSourceUpdated
=
(
event
packet
)
=
>
this
.
emit
(
"
source
-
updated
"
packet
)
;
this
.
client
.
addListener
(
"
newSource
"
this
.
_onSourceUpdated
)
;
this
.
client
.
addListener
(
"
updatedSource
"
this
.
_onSourceUpdated
)
;
}
_teardownRemoteListeners
:
function
(
)
{
this
.
client
.
removeListener
(
"
closed
"
this
.
destroy
)
;
this
.
client
.
removeListener
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
client
.
removeListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
client
.
removeListener
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
this
.
client
.
removeListener
(
"
newSource
"
this
.
_onSourceUpdated
)
;
this
.
client
.
removeListener
(
"
updatedSource
"
this
.
_onSourceUpdated
)
;
}
handleEvent
:
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabClose
"
:
case
"
unload
"
:
this
.
destroy
(
)
;
break
;
case
"
TabSelect
"
:
if
(
this
.
tab
.
selected
)
{
this
.
emit
(
"
visible
"
event
)
;
}
else
{
this
.
emit
(
"
hidden
"
event
)
;
}
break
;
case
"
TabRemotenessChange
"
:
this
.
onRemotenessChange
(
)
;
break
;
}
}
onRemotenessChange
:
function
(
)
{
if
(
this
.
_tab
.
isResponsiveDesignMode
)
{
return
;
}
let
tab
=
this
.
_tab
;
let
onToolboxDestroyed
=
(
event
target
)
=
>
{
if
(
target
!
=
this
)
{
return
;
}
gDevTools
.
off
(
"
toolbox
-
destroyed
"
target
)
;
let
newTarget
=
TargetFactory
.
forTab
(
tab
)
;
gDevTools
.
showToolbox
(
newTarget
)
;
}
;
gDevTools
.
on
(
"
toolbox
-
destroyed
"
onToolboxDestroyed
)
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
.
promise
;
}
this
.
_destroyer
=
defer
(
)
;
this
.
emit
(
"
close
"
)
;
if
(
this
.
_tab
)
{
this
.
_teardownListeners
(
)
;
}
let
cleanupAndResolve
=
(
)
=
>
{
this
.
_cleanup
(
)
;
this
.
_destroyer
.
resolve
(
null
)
;
}
;
if
(
this
.
_tab
&
&
!
this
.
_client
)
{
cleanupAndResolve
(
)
;
}
else
if
(
this
.
_client
)
{
this
.
_teardownRemoteListeners
(
)
;
if
(
this
.
isLocalTab
)
{
this
.
_client
.
close
(
)
.
then
(
cleanupAndResolve
)
;
}
else
if
(
this
.
activeTab
)
{
this
.
activeTab
.
detach
(
)
;
cleanupAndResolve
(
)
;
}
else
{
cleanupAndResolve
(
)
;
}
}
return
this
.
_destroyer
.
promise
;
}
_cleanup
:
function
(
)
{
if
(
this
.
_tab
)
{
targets
.
delete
(
this
.
_tab
)
;
}
else
{
promiseTargets
.
delete
(
this
.
_form
)
;
}
this
.
activeTab
=
null
;
this
.
activeConsole
=
null
;
this
.
_client
=
null
;
this
.
_tab
=
null
;
this
.
_form
=
null
;
this
.
_remote
=
null
;
this
.
_root
=
null
;
this
.
_title
=
null
;
this
.
_url
=
null
;
this
.
threadActor
=
null
;
}
toString
:
function
(
)
{
let
id
=
this
.
_tab
?
this
.
_tab
:
(
this
.
_form
&
&
this
.
_form
.
actor
)
;
return
TabTarget
:
{
id
}
;
}
resolveLocation
(
loc
)
{
let
deferred
=
defer
(
)
;
this
.
client
.
request
(
Object
.
assign
(
{
to
:
this
.
_form
.
actor
type
:
"
resolveLocation
"
}
loc
)
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
}
;
function
TabWebProgressListener
(
target
)
{
this
.
target
=
target
;
}
TabWebProgressListener
.
prototype
=
{
target
:
null
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
onStateChange
:
function
(
progress
request
flag
)
{
let
isStart
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_START
;
let
isDocument
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_DOCUMENT
;
let
isNetwork
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
;
let
isRequest
=
flag
&
Ci
.
nsIWebProgressListener
.
STATE_IS_REQUEST
;
if
(
!
isStart
|
|
!
isDocument
|
|
!
isRequest
|
|
!
isNetwork
)
{
return
;
}
if
(
progress
.
isTopLevel
)
{
if
(
this
.
target
.
_client
)
{
this
.
target
.
_navRequest
=
request
;
}
else
{
this
.
target
.
emit
(
"
will
-
navigate
"
request
)
;
}
}
}
onProgressChange
:
function
(
)
{
}
onSecurityChange
:
function
(
)
{
}
onStatusChange
:
function
(
)
{
}
onLocationChange
:
function
(
webProgress
request
URI
flags
)
{
if
(
this
.
target
&
&
!
(
flags
&
Ci
.
nsIWebProgressListener
.
LOCATION_CHANGE_SAME_DOCUMENT
)
)
{
let
window
=
webProgress
.
DOMWindow
;
if
(
this
.
target
.
_client
)
{
this
.
target
.
_navWindow
=
window
;
}
else
{
this
.
target
.
emit
(
"
navigate
"
window
)
;
}
}
}
destroy
:
function
(
)
{
if
(
this
.
target
.
tab
)
{
try
{
this
.
target
.
tab
.
linkedBrowser
.
removeProgressListener
(
this
)
;
}
catch
(
ex
)
{
}
}
this
.
target
.
_webProgressListener
=
null
;
this
.
target
.
_navRequest
=
null
;
this
.
target
.
_navWindow
=
null
;
this
.
target
=
null
;
}
}
;
function
WorkerTarget
(
workerClient
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_workerClient
=
workerClient
;
}
WorkerTarget
.
prototype
=
{
get
isRemote
(
)
{
return
true
;
}
get
isTabActor
(
)
{
return
true
;
}
get
name
(
)
{
return
"
Worker
"
;
}
get
url
(
)
{
return
this
.
_workerClient
.
url
;
}
get
isWorkerTarget
(
)
{
return
true
;
}
get
form
(
)
{
return
{
consoleActor
:
this
.
_workerClient
.
consoleActor
}
;
}
get
activeTab
(
)
{
return
this
.
_workerClient
;
}
get
client
(
)
{
return
this
.
_workerClient
.
client
;
}
destroy
:
function
(
)
{
this
.
_workerClient
.
detach
(
)
;
}
hasActor
:
function
(
name
)
{
if
(
name
=
=
"
console
"
)
{
return
true
;
}
return
false
;
}
getTrait
:
function
(
)
{
return
undefined
;
}
makeRemote
:
function
(
)
{
return
Promise
.
resolve
(
)
;
}
}
;
