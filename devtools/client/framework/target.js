"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerServer
"
"
devtools
/
server
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
debugger
-
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getFront
"
"
devtools
/
shared
/
protocol
"
true
)
;
const
targets
=
new
WeakMap
(
)
;
const
promiseTargets
=
new
WeakMap
(
)
;
const
TargetFactory
=
exports
.
TargetFactory
=
{
forTab
:
async
function
(
tab
)
{
let
target
=
targets
.
get
(
tab
)
;
if
(
target
)
{
return
target
;
}
const
promise
=
this
.
createTargetForTab
(
tab
)
;
targets
.
set
(
tab
promise
)
;
target
=
await
promise
;
targets
.
set
(
tab
target
)
;
return
target
;
}
async
createTargetForTab
(
tab
)
{
function
createLocalServer
(
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
}
function
createLocalClient
(
)
{
return
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
}
createLocalServer
(
)
;
const
client
=
createLocalClient
(
)
;
await
client
.
connect
(
)
;
const
front
=
await
client
.
mainRoot
.
getTab
(
{
tab
}
)
;
return
new
Target
(
{
client
activeTab
:
front
chrome
:
false
tab
}
)
;
}
forRemoteTab
:
function
(
options
)
{
let
targetPromise
=
promiseTargets
.
get
(
options
)
;
if
(
targetPromise
=
=
null
)
{
const
target
=
new
Target
(
options
)
;
targetPromise
=
target
.
attach
(
)
.
then
(
(
)
=
>
target
)
;
targetPromise
.
catch
(
e
=
>
{
console
.
error
(
"
Exception
while
attaching
target
"
e
)
;
}
)
;
promiseTargets
.
set
(
options
targetPromise
)
;
}
return
targetPromise
;
}
forWorker
:
function
(
workerTargetFront
)
{
let
target
=
targets
.
get
(
workerTargetFront
)
;
if
(
target
=
=
null
)
{
target
=
new
Target
(
{
client
:
workerTargetFront
.
client
activeTab
:
workerTargetFront
chrome
:
false
}
)
;
targets
.
set
(
workerTargetFront
target
)
;
}
return
target
;
}
isKnownTab
:
function
(
tab
)
{
return
targets
.
has
(
tab
)
;
}
}
;
class
Target
extends
EventEmitter
{
constructor
(
{
client
chrome
activeTab
tab
=
null
}
)
{
if
(
!
activeTab
)
{
throw
new
Error
(
"
Cannot
instanciate
target
without
a
non
-
null
activeTab
"
)
;
}
super
(
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_onTabNavigated
=
this
.
_onTabNavigated
.
bind
(
this
)
;
this
.
activeConsole
=
null
;
this
.
activeTab
=
activeTab
;
this
.
_url
=
this
.
form
.
url
;
this
.
_title
=
this
.
form
.
title
;
this
.
_client
=
client
;
this
.
_chrome
=
chrome
;
if
(
tab
)
{
this
.
_tab
=
tab
;
this
.
_setupListeners
(
)
;
}
if
(
this
.
form
.
traits
&
&
(
"
isBrowsingContext
"
in
this
.
form
.
traits
)
)
{
this
.
_isBrowsingContext
=
this
.
form
.
traits
.
isBrowsingContext
;
}
else
{
this
.
_isBrowsingContext
=
!
this
.
isLegacyAddon
&
&
!
this
.
isContentProcess
&
&
!
this
.
isWorkerTarget
;
}
this
.
fronts
=
new
Map
(
)
;
this
.
_inspector
=
null
;
}
async
getActorDescription
(
actorName
)
{
if
(
this
.
_protocolDescription
&
&
this
.
_protocolDescription
.
types
[
actorName
]
)
{
return
this
.
_protocolDescription
.
types
[
actorName
]
;
}
const
description
=
await
this
.
client
.
mainRoot
.
protocolDescription
(
)
;
this
.
_protocolDescription
=
description
;
return
description
.
types
[
actorName
]
;
}
hasActor
(
actorName
)
{
if
(
this
.
form
)
{
return
!
!
this
.
form
[
actorName
+
"
Actor
"
]
;
}
return
false
;
}
actorHasMethod
(
actorName
methodName
)
{
return
this
.
getActorDescription
(
actorName
)
.
then
(
desc
=
>
{
if
(
desc
&
&
desc
.
methods
)
{
return
!
!
desc
.
methods
.
find
(
method
=
>
method
.
name
=
=
=
methodName
)
;
}
return
false
;
}
)
;
}
getTrait
(
traitName
)
{
if
(
this
.
form
.
traits
&
&
traitName
in
this
.
form
.
traits
)
{
return
this
.
form
.
traits
[
traitName
]
;
}
return
this
.
client
.
traits
[
traitName
]
;
}
get
tab
(
)
{
return
this
.
_tab
;
}
get
form
(
)
{
return
this
.
activeTab
.
targetForm
;
}
get
root
(
)
{
return
this
.
client
.
mainRoot
.
rootForm
;
}
async
getInspector
(
typeName
)
{
if
(
this
.
_inspector
&
&
this
.
_inspector
.
actorID
)
{
return
this
.
_inspector
;
}
this
.
_inspector
=
await
getFront
(
this
.
client
"
inspector
"
this
.
form
)
;
this
.
emit
(
"
inspector
"
this
.
_inspector
)
;
return
this
.
_inspector
;
}
onFront
(
typeName
callback
)
{
const
front
=
this
.
fronts
.
get
(
typeName
)
;
if
(
front
)
{
return
callback
(
front
)
;
}
return
this
.
on
(
typeName
callback
)
;
}
async
getFront
(
typeName
)
{
let
front
=
this
.
fronts
.
get
(
typeName
)
;
if
(
front
&
&
front
.
actorID
|
|
front
&
&
typeof
front
.
then
=
=
=
"
function
"
)
{
return
front
;
}
front
=
getFront
(
this
.
client
typeName
this
.
form
)
;
this
.
fronts
.
set
(
typeName
front
)
;
front
=
await
front
;
this
.
emit
(
typeName
front
)
;
this
.
fronts
.
set
(
typeName
front
)
;
return
front
;
}
getCachedFront
(
typeName
)
{
const
front
=
this
.
fronts
.
get
(
typeName
)
;
if
(
front
&
&
front
.
actorID
)
{
return
front
;
}
return
null
;
}
get
client
(
)
{
return
this
.
_client
;
}
get
chrome
(
)
{
return
this
.
_chrome
;
}
get
isBrowsingContext
(
)
{
return
this
.
_isBrowsingContext
;
}
get
name
(
)
{
if
(
this
.
isAddon
)
{
return
this
.
form
.
name
;
}
return
this
.
_title
;
}
get
url
(
)
{
return
this
.
_url
;
}
get
isAddon
(
)
{
return
this
.
isLegacyAddon
|
|
this
.
isWebExtension
;
}
get
isWorkerTarget
(
)
{
return
this
.
activeTab
&
&
this
.
activeTab
.
typeName
=
=
=
"
workerTarget
"
;
}
get
isLegacyAddon
(
)
{
return
!
!
(
this
.
form
&
&
this
.
form
.
actor
&
&
this
.
form
.
actor
.
match
(
/
conn
\
d
+
\
.
addon
(
Target
)
?
\
d
+
/
)
)
;
}
get
isWebExtension
(
)
{
return
!
!
(
this
.
form
&
&
this
.
form
.
actor
&
&
(
this
.
form
.
actor
.
match
(
/
conn
\
d
+
\
.
webExtension
(
Target
)
?
\
d
+
/
)
|
|
this
.
form
.
actor
.
match
(
/
child
\
d
+
\
/
webExtension
(
Target
)
?
\
d
+
/
)
)
)
;
}
get
isContentProcess
(
)
{
return
!
!
(
this
.
form
&
&
this
.
form
.
actor
&
&
this
.
form
.
actor
.
match
(
/
conn
\
d
+
\
.
(
content
-
process
\
d
+
\
/
)
?
contentProcessTarget
\
d
+
/
)
)
;
}
get
isLocalTab
(
)
{
return
!
!
this
.
_tab
;
}
get
isMultiProcess
(
)
{
return
!
this
.
window
;
}
get
canRewind
(
)
{
return
this
.
activeTab
&
&
this
.
activeTab
.
traits
.
canRewind
;
}
isReplayEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
devtools
.
recordreplay
.
mvp
.
enabled
"
)
&
&
this
.
canRewind
&
&
this
.
isLocalTab
;
}
getExtensionPathName
(
url
)
{
if
(
!
this
.
isWebExtension
)
{
throw
new
Error
(
"
Target
is
not
a
WebExtension
"
)
;
}
try
{
const
parsedURL
=
new
URL
(
url
)
;
if
(
parsedURL
.
protocol
!
=
=
"
moz
-
extension
:
"
)
{
return
url
;
}
return
parsedURL
.
pathname
;
}
catch
(
e
)
{
return
url
;
}
}
get
contentPrincipal
(
)
{
if
(
!
this
.
isLocalTab
)
{
return
null
;
}
return
this
.
tab
.
linkedBrowser
.
contentPrincipal
;
}
attach
(
)
{
if
(
this
.
_attach
)
{
return
this
.
_attach
;
}
const
attachBrowsingContextTarget
=
async
(
)
=
>
{
if
(
!
this
.
activeTab
)
{
const
[
targetFront
]
=
await
this
.
_client
.
attachTarget
(
this
.
form
)
;
this
.
activeTab
=
targetFront
;
}
else
{
await
this
.
activeTab
.
attach
(
)
;
}
this
.
activeTab
.
on
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
_onFrameUpdate
=
packet
=
>
{
this
.
emit
(
"
frame
-
update
"
packet
)
;
}
;
this
.
activeTab
.
on
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
}
;
const
attachConsole
=
async
(
)
=
>
{
const
[
consoleClient
]
=
await
this
.
_client
.
attachConsole
(
this
.
form
.
consoleActor
[
]
)
;
this
.
activeConsole
=
consoleClient
;
this
.
_onInspectObject
=
packet
=
>
this
.
emit
(
"
inspect
-
object
"
packet
)
;
this
.
activeConsole
.
on
(
"
inspectObject
"
this
.
_onInspectObject
)
;
}
;
this
.
_attach
=
(
async
(
)
=
>
{
if
(
this
.
isBrowsingContext
)
{
await
attachBrowsingContextTarget
(
)
;
}
else
if
(
this
.
isWorkerTarget
|
|
this
.
isLegacyAddon
)
{
await
this
.
activeTab
.
attach
(
)
;
}
else
if
(
this
.
isContentProcess
)
{
}
else
{
throw
new
Error
(
Unsupported
type
of
target
.
Expected
target
of
one
of
the
+
following
types
:
BrowsingContext
ContentProcess
Worker
or
+
Addon
(
legacy
)
.
)
;
}
this
.
_setupRemoteListeners
(
)
;
return
attachConsole
(
)
;
}
)
(
)
;
return
this
.
_attach
;
}
_setupListeners
(
)
{
this
.
tab
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
tab
.
ownerDocument
.
defaultView
.
addEventListener
(
"
unload
"
this
)
;
this
.
tab
.
addEventListener
(
"
TabRemotenessChange
"
this
)
;
}
_teardownListeners
(
)
{
if
(
this
.
_tab
.
ownerDocument
.
defaultView
)
{
this
.
_tab
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
unload
"
this
)
;
}
this
.
_tab
.
removeEventListener
(
"
TabClose
"
this
)
;
this
.
_tab
.
removeEventListener
(
"
TabRemotenessChange
"
this
)
;
}
_onTabNavigated
(
packet
)
{
const
event
=
Object
.
create
(
null
)
;
event
.
url
=
packet
.
url
;
event
.
title
=
packet
.
title
;
event
.
nativeConsoleAPI
=
packet
.
nativeConsoleAPI
;
event
.
isFrameSwitching
=
packet
.
isFrameSwitching
;
if
(
!
packet
.
isFrameSwitching
|
|
this
.
isWebExtension
)
{
this
.
_url
=
packet
.
url
;
this
.
_title
=
packet
.
title
;
}
if
(
packet
.
state
=
=
"
start
"
)
{
this
.
emit
(
"
will
-
navigate
"
event
)
;
}
else
{
this
.
emit
(
"
navigate
"
event
)
;
}
}
_setupRemoteListeners
(
)
{
this
.
client
.
addListener
(
"
closed
"
this
.
destroy
)
;
if
(
this
.
activeTab
)
{
this
.
activeTab
.
on
(
"
tabDetached
"
this
.
destroy
)
;
this
.
_onSourceUpdated
=
packet
=
>
this
.
emit
(
"
source
-
updated
"
packet
)
;
this
.
activeTab
.
on
(
"
newSource
"
this
.
_onSourceUpdated
)
;
this
.
activeTab
.
on
(
"
updatedSource
"
this
.
_onSourceUpdated
)
;
}
else
{
this
.
_onTabDetached
=
(
type
packet
)
=
>
{
if
(
packet
.
from
=
=
this
.
form
.
actor
)
{
this
.
destroy
(
)
;
}
}
;
this
.
client
.
addListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
_onSourceUpdated
=
(
type
packet
)
=
>
this
.
emit
(
"
source
-
updated
"
packet
)
;
this
.
client
.
addListener
(
"
newSource
"
this
.
_onSourceUpdated
)
;
this
.
client
.
addListener
(
"
updatedSource
"
this
.
_onSourceUpdated
)
;
}
}
_teardownRemoteListeners
(
)
{
this
.
client
.
removeListener
(
"
closed
"
this
.
destroy
)
;
if
(
this
.
activeTab
)
{
this
.
activeTab
.
off
(
"
tabDetached
"
this
.
destroy
)
;
this
.
activeTab
.
off
(
"
newSource
"
this
.
_onSourceUpdated
)
;
this
.
activeTab
.
off
(
"
updatedSource
"
this
.
_onSourceUpdated
)
;
}
else
{
this
.
client
.
removeListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
client
.
removeListener
(
"
newSource
"
this
.
_onSourceUpdated
)
;
this
.
client
.
removeListener
(
"
updatedSource
"
this
.
_onSourceUpdated
)
;
}
if
(
this
.
activeTab
)
{
this
.
activeTab
.
off
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
activeTab
.
off
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
}
if
(
this
.
activeConsole
&
&
this
.
_onInspectObject
)
{
this
.
activeConsole
.
off
(
"
inspectObject
"
this
.
_onInspectObject
)
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabClose
"
:
case
"
unload
"
:
this
.
destroy
(
)
;
break
;
case
"
TabRemotenessChange
"
:
this
.
onRemotenessChange
(
)
;
break
;
}
}
onRemotenessChange
(
)
{
if
(
this
.
_tab
.
isResponsiveDesignMode
)
{
return
;
}
const
tab
=
this
.
_tab
;
const
onToolboxDestroyed
=
async
(
target
)
=
>
{
if
(
target
!
=
this
)
{
return
;
}
gDevTools
.
off
(
"
toolbox
-
destroyed
"
target
)
;
const
newTarget
=
await
TargetFactory
.
forTab
(
tab
)
;
gDevTools
.
showToolbox
(
newTarget
)
;
}
;
gDevTools
.
on
(
"
toolbox
-
destroyed
"
onToolboxDestroyed
)
;
}
destroy
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
this
.
_destroyer
=
(
async
(
)
=
>
{
this
.
emit
(
"
close
"
)
;
for
(
let
[
front
]
of
this
.
fronts
)
{
front
=
await
front
;
await
front
.
destroy
(
)
;
}
if
(
this
.
_tab
)
{
this
.
_teardownListeners
(
)
;
}
this
.
_teardownRemoteListeners
(
)
;
if
(
this
.
isLocalTab
)
{
await
this
.
_client
.
close
(
)
;
}
else
if
(
this
.
activeTab
)
{
try
{
await
this
.
activeTab
.
detach
(
)
;
}
catch
(
e
)
{
console
.
warn
(
Error
while
detaching
target
:
{
e
.
message
}
)
;
}
}
this
.
_cleanup
(
)
;
}
)
(
)
;
return
this
.
_destroyer
;
}
_cleanup
(
)
{
if
(
this
.
_tab
)
{
targets
.
delete
(
this
.
_tab
)
;
}
else
{
promiseTargets
.
delete
(
this
.
form
)
;
}
this
.
activeTab
=
null
;
this
.
activeConsole
=
null
;
this
.
_client
=
null
;
this
.
_tab
=
null
;
this
.
_attach
=
null
;
this
.
_title
=
null
;
this
.
_url
=
null
;
}
toString
(
)
{
const
id
=
this
.
_tab
?
this
.
_tab
:
(
this
.
form
&
&
this
.
form
.
actor
)
;
return
Target
:
{
id
}
;
}
logErrorInPage
(
text
category
)
{
if
(
this
.
activeTab
&
&
this
.
activeTab
.
traits
.
logInPage
)
{
const
errorFlag
=
0
;
return
this
.
activeTab
.
logInPage
(
{
text
category
flags
:
errorFlag
}
)
;
}
return
Promise
.
resolve
(
)
;
}
logWarningInPage
(
text
category
)
{
if
(
this
.
activeTab
&
&
this
.
activeTab
.
traits
.
logInPage
)
{
const
warningFlag
=
1
;
return
this
.
activeTab
.
logInPage
(
{
text
category
flags
:
warningFlag
}
)
;
}
return
Promise
.
resolve
(
)
;
}
}
exports
.
Target
=
Target
;
