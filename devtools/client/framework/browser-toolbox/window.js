"
use
strict
"
;
var
{
loader
require
DevToolsLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
loader
.
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
devtools
-
browser
.
js
"
)
;
var
{
gDevTools
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
devtools
.
js
"
)
;
var
{
Toolbox
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
toolbox
.
js
"
)
;
var
{
DevToolsClient
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
devtools
-
client
.
js
"
)
;
var
{
PrefsHelper
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
prefs
.
js
"
)
;
const
KeyShortcuts
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
key
-
shortcuts
.
js
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
BrowserToolboxLauncher
:
"
resource
:
/
/
devtools
/
client
/
framework
/
browser
-
toolbox
/
Launcher
.
sys
.
mjs
"
}
)
;
const
{
CommandsFactory
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
commands
/
commands
-
factory
.
js
"
)
;
const
STATUS_REVEAL_TIME
=
15000
;
var
Prefs
=
new
PrefsHelper
(
"
devtools
.
debugger
"
{
chromeDebuggingHost
:
[
"
Char
"
"
chrome
-
debugging
-
host
"
]
chromeDebuggingWebSocket
:
[
"
Bool
"
"
chrome
-
debugging
-
websocket
"
]
}
)
;
var
gCommands
gToolbox
gShortcuts
;
function
appendStatusMessage
(
msg
)
{
const
statusMessage
=
document
.
getElementById
(
"
status
-
message
"
)
;
statusMessage
.
textContent
+
=
msg
+
"
\
n
"
;
if
(
msg
.
stack
)
{
statusMessage
.
textContent
+
=
msg
.
stack
+
"
\
n
"
;
}
}
function
toggleStatusMessage
(
visible
=
true
)
{
document
.
getElementById
(
"
status
-
message
-
container
"
)
.
hidden
=
!
visible
;
}
function
revealStatusMessage
(
)
{
toggleStatusMessage
(
true
)
;
}
function
hideStatusMessage
(
)
{
toggleStatusMessage
(
false
)
;
}
var
connect
=
async
function
(
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
browsertoolbox
.
fission
"
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_FISSION_PREF
"
)
=
=
=
"
1
"
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
webconsole
.
input
.
context
"
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_INPUT_CONTEXT
"
)
=
=
=
"
1
"
)
;
if
(
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_FORCE_MULTIPROCESS
"
)
=
=
=
"
1
"
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
browsertoolbox
.
scope
"
"
everything
"
)
;
}
const
port
=
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_PORT
"
)
;
if
(
!
port
)
{
throw
new
Error
(
"
Must
pass
a
port
in
an
env
variable
with
MOZ_BROWSER_TOOLBOX_PORT
"
)
;
}
const
host
=
Prefs
.
chromeDebuggingHost
;
const
webSocket
=
Prefs
.
chromeDebuggingWebSocket
;
appendStatusMessage
(
Connecting
to
{
host
}
:
{
port
}
ws
:
{
webSocket
}
)
;
const
transport
=
await
DevToolsClient
.
socketConnect
(
{
host
port
webSocket
}
)
;
const
client
=
new
DevToolsClient
(
transport
)
;
appendStatusMessage
(
"
Start
protocol
client
for
connection
"
)
;
await
client
.
connect
(
)
;
appendStatusMessage
(
"
Get
root
form
for
toolbox
"
)
;
gCommands
=
await
CommandsFactory
.
forMainProcess
(
{
client
}
)
;
await
openToolbox
(
gCommands
)
;
}
;
function
setPrefDefaults
(
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
showUserAgentStyles
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
showAllAnonymousContent
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
dom
.
window
.
dump
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
console
.
stdout
.
chrome
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
command
-
button
-
noautohide
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
performance
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
sessionstore
.
resume_from_crash
"
false
)
;
Services
.
prefs
.
setIntPref
(
"
toolkit
.
startup
.
max_resumed_crashes
"
-
1
)
;
}
window
.
addEventListener
(
"
load
"
async
function
(
)
{
gShortcuts
=
new
KeyShortcuts
(
{
window
}
)
;
gShortcuts
.
on
(
"
CmdOrCtrl
+
W
"
onCloseCommand
)
;
gShortcuts
.
on
(
"
CmdOrCtrl
+
Alt
+
Shift
+
I
"
onDebugBrowserToolbox
)
;
gShortcuts
.
on
(
"
CmdOrCtrl
+
Alt
+
R
"
onReloadBrowser
)
;
const
statusMessageContainer
=
document
.
getElementById
(
"
status
-
message
-
title
"
)
;
statusMessageContainer
.
textContent
=
L10N
.
getStr
(
"
browserToolbox
.
statusMessage
"
)
;
setPrefDefaults
(
)
;
const
delayedStatusReveal
=
setTimeout
(
revealStatusMessage
STATUS_REVEAL_TIME
)
;
try
{
await
connect
(
)
;
clearTimeout
(
delayedStatusReveal
)
;
hideStatusMessage
(
)
;
}
catch
(
e
)
{
clearTimeout
(
delayedStatusReveal
)
;
appendStatusMessage
(
e
)
;
revealStatusMessage
(
)
;
console
.
error
(
e
)
;
}
}
{
once
:
true
}
)
;
function
onCloseCommand
(
event
)
{
window
.
close
(
)
;
}
function
onDebugBrowserToolbox
(
)
{
lazy
.
BrowserToolboxLauncher
.
init
(
)
;
}
function
onReloadBrowser
(
)
{
gToolbox
.
commands
.
targetCommand
.
reloadTopLevelTarget
(
)
;
}
async
function
openToolbox
(
commands
)
{
const
{
descriptorFront
}
=
commands
;
const
form
=
descriptorFront
.
_form
;
appendStatusMessage
(
Create
toolbox
for
target
descriptor
:
{
JSON
.
stringify
(
{
form
}
null
2
)
}
)
;
const
selectedTool
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
browsertoolbox
.
panel
"
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
selectedTool
"
"
jsdebugger
"
)
)
;
const
toolboxOptions
=
{
doc
:
document
}
;
appendStatusMessage
(
Show
toolbox
with
{
selectedTool
}
selected
)
;
gToolbox
=
await
gDevTools
.
showToolbox
(
descriptorFront
{
toolId
:
selectedTool
hostType
:
Toolbox
.
HostType
.
BROWSERTOOLBOX
hostOptions
:
toolboxOptions
}
)
;
bindToolboxHandlers
(
)
;
gToolbox
.
raise
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
browsertoolbox
.
enable
-
test
-
server
"
false
)
)
{
installTestingServer
(
)
;
}
if
(
env
.
get
(
"
MOZ_PROFILER_STARTUP
"
)
=
=
=
"
1
"
)
{
const
notificationBox
=
gToolbox
.
getNotificationBox
(
)
;
const
text
=
"
The
profiler
started
recording
this
toolbox
open
another
browser
toolbox
to
open
the
profile
via
the
performance
panel
"
;
notificationBox
.
appendNotification
(
text
null
null
notificationBox
.
PRIORITY_INFO_HIGH
)
;
}
}
function
installTestingServer
(
)
{
const
testLoader
=
new
DevToolsLoader
(
{
invisibleToDebugger
:
true
}
)
;
const
{
DevToolsServer
}
=
testLoader
.
require
(
"
resource
:
/
/
devtools
/
server
/
devtools
-
server
.
js
"
)
;
const
{
SocketListener
}
=
testLoader
.
require
(
"
resource
:
/
/
devtools
/
shared
/
security
/
socket
.
js
"
)
;
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
DevToolsServer
.
allowChromeProcess
=
true
;
DevToolsServer
.
keepAlive
=
true
;
const
socketOptions
=
{
portOrPath
:
6001
}
;
const
listener
=
new
SocketListener
(
DevToolsServer
socketOptions
)
;
listener
.
open
(
)
;
}
async
function
bindToolboxHandlers
(
)
{
gToolbox
.
once
(
"
destroyed
"
quitApp
)
;
window
.
addEventListener
(
"
unload
"
onUnload
)
;
gCommands
.
client
.
once
(
"
closed
"
quitApp
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
)
{
updateBadgeText
(
false
)
;
gToolbox
.
on
(
"
toolbox
-
paused
"
(
)
=
>
updateBadgeText
(
true
)
)
;
gToolbox
.
on
(
"
toolbox
-
resumed
"
(
)
=
>
updateBadgeText
(
false
)
)
;
}
}
function
updateBadgeText
(
paused
)
{
const
dockSupport
=
Cc
[
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
]
.
getService
(
Ci
.
nsIMacDockSupport
)
;
dockSupport
.
badgeText
=
paused
?
"
"
:
"
"
;
}
function
onUnload
(
)
{
window
.
removeEventListener
(
"
unload
"
onUnload
)
;
gToolbox
.
destroy
(
)
;
}
function
quitApp
(
)
{
const
quit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
quit
"
quit
-
application
-
requested
"
)
;
const
shouldProceed
=
!
quit
.
data
;
if
(
shouldProceed
)
{
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
)
;
}
}
