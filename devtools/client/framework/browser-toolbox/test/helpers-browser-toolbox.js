"
use
strict
"
;
const
{
BrowserToolboxLauncher
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
browser
-
toolbox
/
Launcher
.
jsm
"
)
;
const
{
DevToolsClient
}
=
require
(
"
devtools
/
client
/
devtools
-
client
"
)
;
async
function
initBrowserToolboxTask
(
{
enableBrowserToolboxFission
enableContentMessages
existingProcessClose
}
=
{
}
)
{
if
(
AppConstants
.
ASAN
)
{
ok
(
false
"
ToolboxTask
cannot
be
used
on
ASAN
builds
.
This
test
should
be
skipped
(
Bug
1591064
)
.
"
)
;
}
await
pushPref
(
"
devtools
.
chrome
.
enabled
"
true
)
;
await
pushPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
true
)
;
await
pushPref
(
"
devtools
.
browsertoolbox
.
enable
-
test
-
server
"
true
)
;
await
pushPref
(
"
devtools
.
debugger
.
prompt
-
connection
"
false
)
;
if
(
enableBrowserToolboxFission
)
{
await
pushPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
}
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
.
PromiseTestUtils
.
allowMatchingRejectionsGlobally
(
/
File
closed
/
)
;
let
process
;
let
dbgProcess
;
if
(
!
existingProcessClose
)
{
[
process
dbgProcess
]
=
await
new
Promise
(
resolve
=
>
{
BrowserToolboxLauncher
.
init
(
{
onRun
:
(
_process
_dbgProcess
)
=
>
resolve
(
[
_process
_dbgProcess
]
)
overwritePreferences
:
true
}
)
;
}
)
;
ok
(
true
"
Browser
toolbox
started
"
)
;
is
(
BrowserToolboxLauncher
.
getBrowserToolboxSessionState
(
)
true
"
Has
session
state
"
)
;
}
else
{
ok
(
true
"
Connecting
to
existing
browser
toolbox
"
)
;
ok
(
!
enableBrowserToolboxFission
"
Not
trying
to
control
preferences
in
existing
browser
toolbox
"
)
;
}
let
transport
;
while
(
true
)
{
try
{
transport
=
await
DevToolsClient
.
socketConnect
(
{
host
:
"
localhost
"
port
:
6001
webSocket
:
false
}
)
;
break
;
}
catch
(
e
)
{
await
waitForTime
(
100
)
;
}
}
ok
(
true
"
Got
transport
"
)
;
const
client
=
new
DevToolsClient
(
transport
)
;
await
client
.
connect
(
)
;
const
descriptorFront
=
await
client
.
mainRoot
.
getMainProcess
(
)
;
const
target
=
await
descriptorFront
.
getTarget
(
)
;
const
consoleFront
=
await
target
.
getFront
(
"
console
"
)
;
ok
(
true
"
Connected
"
)
;
if
(
enableContentMessages
)
{
const
preferenceFront
=
await
client
.
mainRoot
.
getFront
(
"
preference
"
)
;
await
preferenceFront
.
setBoolPref
(
"
devtools
.
browserconsole
.
contentMessages
"
true
)
;
}
await
importFunctions
(
{
info
:
msg
=
>
dump
(
msg
+
"
\
n
"
)
is
:
(
a
b
description
)
=
>
{
let
msg
=
"
'
"
+
JSON
.
stringify
(
a
)
+
"
'
is
equal
to
'
"
+
JSON
.
stringify
(
b
)
+
"
'
"
;
if
(
description
)
{
msg
+
=
"
-
"
+
description
;
}
if
(
a
!
=
=
b
)
{
msg
=
"
FAILURE
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
throw
new
Error
(
msg
)
;
}
else
{
msg
=
"
SUCCESS
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
}
}
ok
:
(
a
description
)
=
>
{
let
msg
=
"
'
"
+
JSON
.
stringify
(
a
)
+
"
'
is
true
"
;
if
(
description
)
{
msg
+
=
"
-
"
+
description
;
}
if
(
!
a
)
{
msg
=
"
FAILURE
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
throw
new
Error
(
msg
)
;
}
else
{
msg
=
"
SUCCESS
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
}
}
}
)
;
async
function
evaluateExpression
(
expression
options
=
{
}
)
{
const
onEvaluationResult
=
consoleFront
.
once
(
"
evaluationResult
"
)
;
await
consoleFront
.
evaluateJSAsync
(
{
text
:
expression
.
.
.
options
}
)
;
return
onEvaluationResult
;
}
async
function
spawn
(
arg
fn
)
{
const
argString
=
JSON
.
stringify
(
Array
.
isArray
(
arg
)
?
arg
:
[
arg
]
)
;
const
rv
=
await
evaluateExpression
(
(
{
fn
}
)
.
apply
(
null
{
argString
}
)
{
mapped
:
{
await
:
true
}
}
)
;
if
(
rv
.
exceptionMessage
)
{
throw
new
Error
(
ToolboxTask
.
spawn
failure
:
{
rv
.
exceptionMessage
}
)
;
}
else
if
(
rv
.
topLevelAwaitRejected
)
{
throw
new
Error
(
ToolboxTask
.
spawn
await
rejected
)
;
}
return
rv
.
result
;
}
async
function
importFunctions
(
functions
)
{
for
(
const
[
key
fn
]
of
Object
.
entries
(
functions
)
)
{
await
evaluateExpression
(
this
.
{
key
}
=
{
fn
}
)
;
}
}
async
function
importScript
(
script
)
{
const
response
=
await
evaluateExpression
(
script
)
;
if
(
response
.
hasException
)
{
ok
(
false
"
ToolboxTask
.
spawn
exception
while
importing
script
:
"
+
response
.
exceptionMessage
)
;
}
}
let
destroyed
=
false
;
async
function
destroy
(
)
{
if
(
destroyed
)
{
return
null
;
}
const
closePromise
=
existingProcessClose
?
existingProcessClose
(
)
:
dbgProcess
.
wait
(
)
;
evaluateExpression
(
"
gToolbox
.
destroy
(
)
"
)
.
catch
(
e
=
>
{
if
(
!
e
.
message
.
includes
(
"
Connection
closed
"
)
)
{
throw
e
;
}
}
)
;
const
{
exitCode
}
=
await
closePromise
;
ok
(
true
"
Browser
toolbox
process
closed
"
)
;
is
(
exitCode
0
"
The
remote
debugger
process
died
cleanly
"
)
;
if
(
!
existingProcessClose
)
{
is
(
BrowserToolboxLauncher
.
getBrowserToolboxSessionState
(
)
false
"
No
session
state
after
closing
"
)
;
}
await
client
.
close
(
)
;
destroyed
=
true
;
}
registerCleanupFunction
(
destroy
)
;
return
{
importFunctions
importScript
spawn
destroy
}
;
}
