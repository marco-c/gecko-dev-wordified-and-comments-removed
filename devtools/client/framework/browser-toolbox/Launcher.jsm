"
use
strict
"
;
const
BROWSER_TOOLBOX_WINDOW_URL
=
"
chrome
:
/
/
devtools
/
content
/
framework
/
browser
-
toolbox
/
window
.
html
"
;
const
CHROME_DEBUGGER_PROFILE_NAME
=
"
chrome_debugger_profile
"
;
const
{
require
useDistinctSystemPrincipalLoader
releaseDistinctSystemPrincipalLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
jsm
"
)
;
const
{
Subprocess
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Subprocess
.
jsm
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
sys
.
mjs
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
BackgroundTasksUtils
"
"
resource
:
/
/
gre
/
modules
/
BackgroundTasksUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetters
(
lazy
{
XreDirProvider
:
[
"
mozilla
.
org
/
xre
/
directory
-
provider
;
1
"
"
nsIXREDirProvider
"
]
}
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
EXPORTED_SYMBOLS
=
[
"
BrowserToolboxLauncher
"
]
;
const
processes
=
new
Set
(
)
;
class
BrowserToolboxLauncher
extends
EventEmitter
{
static
init
(
args
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
|
|
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
)
)
{
console
.
error
(
"
Could
not
start
Browser
Toolbox
you
need
to
enable
it
.
"
)
;
return
null
;
}
return
new
BrowserToolboxLauncher
(
args
)
;
}
static
getBrowserToolboxSessionState
(
)
{
return
processes
.
size
!
=
=
0
;
}
#
closed
;
#
devToolsServer
;
#
dbgProfilePath
;
#
dbgProcess
;
#
listener
;
#
loader
;
#
port
;
#
telemetry
=
new
Telemetry
(
)
;
constructor
(
{
forceMultiprocess
onRun
overwritePreferences
}
=
{
}
)
{
super
(
)
;
if
(
onRun
)
{
this
.
once
(
"
run
"
onRun
)
;
}
this
.
close
=
this
.
close
.
bind
(
this
)
;
Services
.
obs
.
addObserver
(
this
.
close
"
quit
-
application
"
)
;
this
.
#
initServer
(
)
;
this
.
#
initProfile
(
overwritePreferences
)
;
this
.
#
create
(
{
forceMultiprocess
}
)
;
processes
.
add
(
this
)
;
}
#
initServer
(
)
{
if
(
this
.
#
devToolsServer
)
{
dumpn
(
"
The
chrome
toolbox
server
is
already
running
.
"
)
;
return
;
}
dumpn
(
"
Initializing
the
chrome
toolbox
server
.
"
)
;
this
.
#
loader
=
useDistinctSystemPrincipalLoader
(
this
)
;
const
{
DevToolsServer
}
=
this
.
#
loader
.
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
SocketListener
}
=
this
.
#
loader
.
require
(
"
devtools
/
shared
/
security
/
socket
"
)
;
this
.
#
devToolsServer
=
DevToolsServer
;
dumpn
(
"
Created
a
separate
loader
instance
for
the
DevToolsServer
.
"
)
;
this
.
#
devToolsServer
.
init
(
)
;
/
/
We
mainly
need
a
root
actor
and
target
actors
for
opening
a
toolbox
even
/
/
against
chrome
/
content
.
But
the
"
no
auto
hide
"
button
uses
the
/
/
preference
actor
so
also
register
the
browser
actors
.
this
.
#
devToolsServer
.
registerAllActors
(
)
;
this
.
#
devToolsServer
.
allowChromeProcess
=
true
;
dumpn
(
"
initialized
and
added
the
browser
actors
for
the
DevToolsServer
.
"
)
;
const
bts
=
Cc
[
"
mozilla
.
org
/
backgroundtasks
;
1
"
]
?
.
getService
(
Ci
.
nsIBackgroundTasks
)
;
if
(
bts
?
.
isBackgroundTaskMode
)
{
/
/
A
special
root
actor
just
for
background
tasks
invoked
with
/
/
-
-
backgroundtask
TASK
-
-
jsdebugger
.
const
{
createRootActor
}
=
this
.
#
loader
.
require
(
"
resource
:
)
;
this
.
#
devToolsServer
.
setRootActor
(
createRootActor
)
;
}
const
chromeDebuggingWebSocket
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
chrome
-
debugging
-
websocket
"
)
;
const
socketOptions
=
{
fromBrowserToolbox
:
true
portOrPath
:
-
1
webSocket
:
chromeDebuggingWebSocket
}
;
const
listener
=
new
SocketListener
(
this
.
#
devToolsServer
socketOptions
)
;
listener
.
open
(
)
;
this
.
#
listener
=
listener
;
this
.
#
port
=
listener
.
port
;
if
(
!
this
.
#
port
)
{
throw
new
Error
(
"
No
devtools
server
port
"
)
;
}
dumpn
(
"
Finished
initializing
the
chrome
toolbox
server
.
"
)
;
dump
(
DevTools
Server
for
Browser
Toolbox
listening
on
port
:
{
this
.
#
port
}
\
n
)
;
}
/
*
*
*
Initializes
a
profile
for
the
remote
debugger
process
.
*
/
#
initProfile
(
overwritePreferences
)
{
dumpn
(
"
Initializing
the
chrome
toolbox
user
profile
.
"
)
;
const
bts
=
Cc
[
"
mozilla
.
org
/
backgroundtasks
;
1
"
]
?
.
getService
(
Ci
.
nsIBackgroundTasks
)
;
let
debuggingProfileDir
=
Services
.
dirsvc
.
get
(
"
ProfD
"
Ci
.
nsIFile
)
;
if
(
bts
?
.
isBackgroundTaskMode
)
{
/
/
Background
tasks
run
with
a
temporary
ephemeral
profile
.
We
move
the
/
/
browser
toolbox
profile
out
of
that
ephemeral
profile
so
that
it
has
/
/
alonger
life
then
the
background
task
profile
.
This
preserves
/
/
breakpoints
etc
across
repeated
debugging
invocations
.
This
/
/
directory
is
close
to
the
background
task
temporary
profile
name
(
s
)
/
/
but
doesn
'
t
match
the
prefix
that
will
get
purged
by
the
stale
/
/
ephemeral
profile
cleanup
mechanism
.
/
/
/
/
For
example
the
invocation
/
/
firefox
-
-
backgroundtask
success
-
-
jsdebugger
-
-
wait
-
for
-
jsdebugger
/
/
might
run
with
ephemeral
profile
/
/
/
tmp
/
MozillaBackgroundTask
-
<
HASH
>
-
success
/
/
and
sibling
directory
browser
toolbox
profile
/
/
/
tmp
/
MozillaBackgroundTask
-
<
HASH
>
-
chrome_debugger_profile
-
success
/
/
/
/
See
BackgroundTasks
:
:
Shutdown
for
ephemeral
profile
cleanup
details
.
debuggingProfileDir
=
debuggingProfileDir
.
parent
;
debuggingProfileDir
.
append
(
{
Services
.
appinfo
.
vendor
}
BackgroundTask
-
+
{
lazy
.
XreDirProvider
.
getInstallHash
(
)
}
-
{
CHROME_DEBUGGER_PROFILE_NAME
}
-
{
bts
.
backgroundTaskName
(
)
}
)
;
}
else
{
debuggingProfileDir
.
append
(
CHROME_DEBUGGER_PROFILE_NAME
)
;
}
try
{
debuggingProfileDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
catch
(
ex
)
{
if
(
ex
.
result
=
=
=
Cr
.
NS_ERROR_FILE_ALREADY_EXISTS
)
{
if
(
!
overwritePreferences
)
{
this
.
#
dbgProfilePath
=
debuggingProfileDir
.
path
;
return
;
}
/
/
Fall
through
and
copy
the
current
set
of
prefs
to
the
profile
.
}
else
{
dumpn
(
"
Error
trying
to
create
a
profile
directory
failing
.
"
)
;
dumpn
(
"
Error
:
"
+
(
ex
.
message
|
|
ex
)
)
;
return
;
}
}
this
.
#
dbgProfilePath
=
debuggingProfileDir
.
path
;
const
prefsFile
=
debuggingProfileDir
.
clone
(
)
;
prefsFile
.
append
(
"
prefs
.
js
"
)
;
if
(
bts
?
.
isBackgroundTaskMode
)
{
const
defaultProfile
=
lazy
.
BackgroundTasksUtils
.
getDefaultProfile
(
)
;
if
(
!
defaultProfile
)
{
throw
new
Error
(
"
Cannot
start
Browser
Toolbox
from
background
task
with
no
default
profile
"
)
;
}
const
defaultPrefsFile
=
defaultProfile
.
rootDir
.
clone
(
)
;
defaultPrefsFile
.
append
(
"
prefs
.
js
"
)
;
defaultPrefsFile
.
copyTo
(
prefsFile
.
parent
prefsFile
.
leafName
)
;
dumpn
(
Copied
browser
toolbox
prefs
at
'
{
prefsFile
.
path
}
'
+
from
default
profiles
prefs
at
'
{
defaultPrefsFile
.
path
}
'
)
;
}
else
{
Services
.
prefs
.
savePrefFile
(
prefsFile
)
;
}
dumpn
(
"
Finished
creating
the
chrome
toolbox
user
profile
at
:
"
+
this
.
#
dbgProfilePath
)
;
}
#
create
(
{
forceMultiprocess
}
=
{
}
)
{
dumpn
(
"
Initializing
chrome
debugging
process
.
"
)
;
let
command
=
Services
.
dirsvc
.
get
(
"
XREExeF
"
Ci
.
nsIFile
)
.
path
;
let
profilePath
=
this
.
#
dbgProfilePath
;
const
customBinaryPath
=
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_BINARY
"
)
;
if
(
customBinaryPath
)
{
command
=
customBinaryPath
;
profilePath
=
lazy
.
FileUtils
.
getDir
(
"
TmpD
"
[
"
browserToolboxProfile
"
]
true
)
.
path
;
}
dumpn
(
"
Running
chrome
debugging
process
.
"
)
;
const
args
=
[
"
-
no
-
remote
"
"
-
foreground
"
"
-
profile
"
profilePath
"
-
chrome
"
BROWSER_TOOLBOX_WINDOW_URL
]
;
const
isBrowserToolboxFission
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
browsertoolbox
.
fission
"
false
)
;
const
isInputContextEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webconsole
.
input
.
context
"
false
)
;
const
environment
=
{
MOZ_PROFILER_STARTUP
:
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_PROFILER_STARTUP
"
)
MOZ_BROWSER_TOOLBOX_PROFILER_STARTUP
:
"
0
"
MOZ_BROWSER_TOOLBOX_FISSION_PREF
:
isBrowserToolboxFission
?
"
1
"
:
"
0
"
MOZ_BROWSER_TOOLBOX_FORCE_MULTIPROCESS
:
forceMultiprocess
?
"
1
"
:
"
0
"
MOZ_BROWSER_TOOLBOX_INPUT_CONTEXT
:
isInputContextEnabled
?
"
1
"
:
"
0
"
MOZ_DISABLE_SAFE_MODE_KEY
:
"
1
"
MOZ_BROWSER_TOOLBOX_PORT
:
String
(
this
.
#
port
)
MOZ_HEADLESS
:
null
MOZ_MARIONETTE
:
null
MOZ_LOG
:
null
MOZ_LOG_FILE
:
null
XPCOM_MEM_BLOAT_LOG
:
null
XPCOM_MEM_LEAK_LOG
:
null
XPCOM_MEM_LOG_CLASSES
:
null
XPCOM_MEM_REFCNT_LOG
:
null
XRE_PROFILE_PATH
:
null
XRE_PROFILE_LOCAL_PATH
:
null
}
;
if
(
!
AppConstants
.
MOZILLA_OFFICIAL
)
{
args
.
push
(
"
-
purgecaches
"
)
;
}
dump
(
Starting
Browser
Toolbox
{
command
}
{
args
.
join
(
"
"
)
}
\
n
)
;
Subprocess
.
call
(
{
command
arguments
:
args
environmentAppend
:
true
stderr
:
"
stdout
"
environment
}
)
.
then
(
proc
=
>
{
this
.
#
dbgProcess
=
proc
;
this
.
#
telemetry
.
toolOpened
(
"
jsbrowserdebugger
"
-
1
this
)
;
dumpn
(
"
Chrome
toolbox
is
now
running
.
.
.
"
)
;
this
.
emitForTests
(
"
run
"
this
proc
this
.
#
dbgProfilePath
)
;
proc
.
stdin
.
close
(
)
;
const
dumpPipe
=
async
pipe
=
>
{
let
leftover
=
"
"
;
let
data
=
await
pipe
.
readString
(
)
;
while
(
data
)
{
data
=
leftover
+
data
;
const
lines
=
data
.
split
(
/
\
r
\
n
|
\
r
|
\
n
/
)
;
if
(
lines
.
length
)
{
for
(
const
line
of
lines
.
slice
(
0
-
1
)
)
{
dump
(
{
proc
.
pid
}
>
{
line
}
\
n
)
;
}
leftover
=
lines
[
lines
.
length
-
1
]
;
}
data
=
await
pipe
.
readString
(
)
;
}
if
(
leftover
)
{
dump
(
{
proc
.
pid
}
>
{
leftover
}
\
n
)
;
}
}
;
dumpPipe
(
proc
.
stdout
)
;
proc
.
wait
(
)
.
then
(
(
)
=
>
this
.
close
(
)
)
;
return
proc
;
}
err
=
>
{
console
.
log
(
Error
loading
Browser
Toolbox
:
{
command
}
{
args
.
join
(
"
"
)
}
err
)
;
}
)
;
}
async
close
(
)
{
if
(
this
.
#
closed
)
{
return
;
}
this
.
#
closed
=
true
;
dumpn
(
"
Cleaning
up
the
chrome
debugging
process
.
"
)
;
Services
.
obs
.
removeObserver
(
this
.
close
"
quit
-
application
"
)
;
if
(
this
.
#
listener
)
{
this
.
#
listener
.
close
(
)
;
}
this
.
#
devToolsServer
=
null
;
this
.
#
dbgProcess
.
stdout
.
close
(
)
;
await
this
.
#
dbgProcess
.
kill
(
)
;
this
.
#
telemetry
.
toolClosed
(
"
jsbrowserdebugger
"
-
1
this
)
;
dumpn
(
"
Chrome
toolbox
is
now
closed
.
.
.
"
)
;
processes
.
delete
(
this
)
;
this
.
#
dbgProcess
=
null
;
if
(
this
.
#
loader
)
{
releaseDistinctSystemPrincipalLoader
(
this
)
;
}
this
.
#
loader
=
null
;
this
.
#
telemetry
=
null
;
}
}
function
dumpn
(
str
)
{
if
(
wantLogging
)
{
dump
(
"
DBG
-
FRONTEND
:
"
+
str
+
"
\
n
"
)
;
}
}
var
wantLogging
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
log
"
)
;
const
prefObserver
=
{
observe
:
(
.
.
.
args
)
=
>
{
wantLogging
=
Services
.
prefs
.
getBoolPref
(
args
.
pop
(
)
)
;
}
}
;
Services
.
prefs
.
addObserver
(
"
devtools
.
debugger
.
log
"
prefObserver
)
;
const
unloadObserver
=
function
(
subject
)
{
if
(
subject
.
wrappedJSObject
=
=
require
(
"
loader
/
unload
"
)
)
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
debugger
.
log
"
prefObserver
)
;
Services
.
obs
.
removeObserver
(
unloadObserver
"
devtools
:
loader
:
destroy
"
)
;
}
}
;
Services
.
obs
.
addObserver
(
unloadObserver
"
devtools
:
loader
:
destroy
"
)
;
