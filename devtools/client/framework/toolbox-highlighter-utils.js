"
use
strict
"
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
exports
.
getHighlighterUtils
=
function
(
toolbox
)
{
if
(
!
toolbox
|
|
!
toolbox
.
target
)
{
throw
new
Error
(
"
Missing
or
invalid
toolbox
passed
to
getHighlighterUtils
"
)
;
return
;
}
let
exported
=
{
}
;
let
target
=
toolbox
.
target
;
let
isPicking
=
false
;
let
isNodeFrontHighlighted
=
false
;
exported
.
release
=
function
(
)
{
toolbox
=
target
=
null
;
}
;
let
isRemoteHighlightable
=
exported
.
isRemoteHighlightable
=
function
(
)
{
return
target
.
client
.
traits
.
highlightable
;
}
;
let
supportsCustomHighlighters
=
exported
.
supportsCustomHighlighters
=
(
)
=
>
{
return
!
!
target
.
client
.
traits
.
customHighlighters
;
}
;
let
isInspectorInitialized
=
false
;
let
requireInspector
=
generator
=
>
{
return
Task
.
async
(
function
*
(
.
.
.
args
)
{
if
(
!
isInspectorInitialized
)
{
yield
toolbox
.
initInspector
(
)
;
isInspectorInitialized
=
true
;
}
return
yield
generator
.
apply
(
null
args
)
;
}
)
;
}
;
let
togglePicker
=
exported
.
togglePicker
=
function
(
doFocus
)
{
if
(
isPicking
)
{
return
cancelPicker
(
)
;
}
else
{
return
startPicker
(
doFocus
)
;
}
}
;
let
startPicker
=
exported
.
startPicker
=
requireInspector
(
function
*
(
doFocus
=
false
)
{
if
(
isPicking
)
{
return
;
}
isPicking
=
true
;
toolbox
.
pickerButtonChecked
=
true
;
yield
toolbox
.
selectTool
(
"
inspector
"
)
;
toolbox
.
on
(
"
select
"
cancelPicker
)
;
if
(
isRemoteHighlightable
(
)
)
{
toolbox
.
walker
.
on
(
"
picker
-
node
-
hovered
"
onPickerNodeHovered
)
;
toolbox
.
walker
.
on
(
"
picker
-
node
-
picked
"
onPickerNodePicked
)
;
toolbox
.
walker
.
on
(
"
picker
-
node
-
previewed
"
onPickerNodePreviewed
)
;
toolbox
.
walker
.
on
(
"
picker
-
node
-
canceled
"
onPickerNodeCanceled
)
;
yield
toolbox
.
highlighter
.
pick
(
doFocus
)
;
toolbox
.
emit
(
"
picker
-
started
"
)
;
}
else
{
toolbox
.
emit
(
"
picker
-
started
"
)
;
let
node
=
yield
toolbox
.
walker
.
pick
(
)
;
onPickerNodePicked
(
{
node
:
node
}
)
;
}
}
)
;
let
stopPicker
=
exported
.
stopPicker
=
requireInspector
(
function
*
(
)
{
if
(
!
isPicking
)
{
return
;
}
isPicking
=
false
;
toolbox
.
pickerButtonChecked
=
false
;
if
(
isRemoteHighlightable
(
)
)
{
yield
toolbox
.
highlighter
.
cancelPick
(
)
;
toolbox
.
walker
.
off
(
"
picker
-
node
-
hovered
"
onPickerNodeHovered
)
;
toolbox
.
walker
.
off
(
"
picker
-
node
-
picked
"
onPickerNodePicked
)
;
toolbox
.
walker
.
off
(
"
picker
-
node
-
previewed
"
onPickerNodePreviewed
)
;
toolbox
.
walker
.
off
(
"
picker
-
node
-
canceled
"
onPickerNodeCanceled
)
;
}
else
{
yield
toolbox
.
walker
.
cancelPick
(
)
;
}
toolbox
.
off
(
"
select
"
cancelPicker
)
;
toolbox
.
emit
(
"
picker
-
stopped
"
)
;
}
)
;
let
cancelPicker
=
exported
.
cancelPicker
=
Task
.
async
(
function
*
(
)
{
yield
stopPicker
(
)
;
toolbox
.
emit
(
"
picker
-
canceled
"
)
;
}
)
;
function
onPickerNodeHovered
(
data
)
{
toolbox
.
emit
(
"
picker
-
node
-
hovered
"
data
.
node
)
;
}
function
onPickerNodePicked
(
data
)
{
toolbox
.
selection
.
setNodeFront
(
data
.
node
"
picker
-
node
-
picked
"
)
;
stopPicker
(
)
;
}
function
onPickerNodePreviewed
(
data
)
{
toolbox
.
selection
.
setNodeFront
(
data
.
node
"
picker
-
node
-
previewed
"
)
;
}
function
onPickerNodeCanceled
(
)
{
cancelPicker
(
)
;
toolbox
.
win
.
focus
(
)
;
}
let
highlightNodeFront
=
exported
.
highlightNodeFront
=
requireInspector
(
function
*
(
nodeFront
options
=
{
}
)
{
if
(
!
nodeFront
)
{
return
;
}
isNodeFrontHighlighted
=
true
;
if
(
isRemoteHighlightable
(
)
)
{
yield
toolbox
.
highlighter
.
showBoxModel
(
nodeFront
options
)
;
}
else
{
yield
toolbox
.
walker
.
highlight
(
nodeFront
)
;
}
toolbox
.
emit
(
"
node
-
highlight
"
nodeFront
options
.
toSource
(
)
)
;
}
)
;
let
highlightDomValueGrip
=
exported
.
highlightDomValueGrip
=
requireInspector
(
function
*
(
valueGrip
options
=
{
}
)
{
let
nodeFront
=
yield
gripToNodeFront
(
valueGrip
)
;
if
(
nodeFront
)
{
yield
highlightNodeFront
(
nodeFront
options
)
;
}
else
{
throw
new
Error
(
"
The
ValueGrip
passed
could
not
be
translated
to
a
NodeFront
"
)
;
}
}
)
;
let
gripToNodeFront
=
exported
.
gripToNodeFront
=
requireInspector
(
function
*
(
grip
)
{
return
yield
toolbox
.
walker
.
getNodeActorFromObjectActor
(
grip
.
actor
)
;
}
)
;
let
unhighlight
=
exported
.
unhighlight
=
Task
.
async
(
function
*
(
forceHide
=
false
)
{
forceHide
=
forceHide
|
|
!
flags
.
testing
;
if
(
isNodeFrontHighlighted
&
&
forceHide
&
&
toolbox
.
highlighter
&
&
isRemoteHighlightable
(
)
)
{
isNodeFrontHighlighted
=
false
;
yield
toolbox
.
highlighter
.
hideBoxModel
(
)
;
}
if
(
toolbox
)
{
toolbox
.
emit
(
"
node
-
unhighlight
"
)
;
}
}
)
;
let
getHighlighterByType
=
exported
.
getHighlighterByType
=
requireInspector
(
function
*
(
typeName
)
{
let
highlighter
=
null
;
if
(
supportsCustomHighlighters
(
)
)
{
highlighter
=
yield
toolbox
.
inspector
.
getHighlighterByType
(
typeName
)
;
}
return
highlighter
|
|
promise
.
reject
(
"
The
target
doesn
'
t
support
"
+
creating
highlighters
by
types
or
{
typeName
}
is
unknown
)
;
}
)
;
return
exported
;
}
;
