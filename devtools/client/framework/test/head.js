Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
allow_unsafe_parent_loads
"
true
]
]
}
)
;
function
toggleAllTools
(
state
)
{
for
(
const
[
tool
]
of
gDevTools
.
_tools
)
{
if
(
!
tool
.
visibilityswitch
)
{
continue
;
}
if
(
state
)
{
Services
.
prefs
.
setBoolPref
(
tool
.
visibilityswitch
true
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
tool
.
visibilityswitch
)
;
}
}
}
function
getParentProcessActors
(
callback
)
{
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
debugger
-
server
"
)
;
const
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
const
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
client
.
connect
(
)
.
then
(
(
)
=
>
client
.
mainRoot
.
getMainProcess
(
)
)
.
then
(
front
=
>
{
callback
(
client
front
)
;
}
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
DebuggerServer
.
destroy
(
)
;
}
)
;
}
function
getSourceActor
(
aSources
aURL
)
{
const
item
=
aSources
.
getItemForAttachment
(
a
=
>
a
.
source
.
url
=
=
=
aURL
)
;
return
item
&
&
item
.
value
;
}
async
function
openScratchpadWindow
(
)
{
const
win
=
ScratchpadManager
.
openScratchpad
(
)
;
await
once
(
win
"
load
"
)
;
return
new
Promise
(
resolve
=
>
{
win
.
Scratchpad
.
addObserver
(
{
onReady
:
function
(
)
{
win
.
Scratchpad
.
removeObserver
(
this
)
;
resolve
(
win
)
;
}
}
)
;
}
)
;
}
function
waitForContentMessage
(
name
)
{
info
(
"
Expecting
message
"
+
name
+
"
from
content
"
)
;
const
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
return
new
Promise
(
resolve
=
>
{
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
resolve
(
msg
.
data
)
;
}
)
;
}
)
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
info
(
"
Sending
message
"
+
name
+
"
to
content
"
)
;
const
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
promise
.
resolve
(
)
;
}
function
synthesizeKeyElement
(
el
)
{
const
key
=
el
.
getAttribute
(
"
key
"
)
|
|
el
.
getAttribute
(
"
keycode
"
)
;
const
mod
=
{
}
;
el
.
getAttribute
(
"
modifiers
"
)
.
split
(
"
"
)
.
forEach
(
m
=
>
(
mod
[
m
+
"
Key
"
]
=
true
)
)
;
info
(
Synthesizing
:
key
=
{
key
}
mod
=
{
JSON
.
stringify
(
mod
)
}
)
;
EventUtils
.
synthesizeKey
(
key
mod
el
.
ownerDocument
.
defaultView
)
;
}
function
checkHostType
(
toolbox
hostType
previousHostType
)
{
is
(
toolbox
.
hostType
hostType
"
host
type
is
"
+
hostType
)
;
const
pref
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
host
"
)
;
is
(
pref
hostType
"
host
pref
is
"
+
hostType
)
;
if
(
previousHostType
)
{
is
(
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
previousHost
"
)
previousHostType
"
The
previous
host
is
correct
"
)
;
}
}
function
createScript
(
url
)
{
info
(
Creating
script
:
{
url
}
)
;
loadFrameScriptUtils
(
)
;
const
command
=
let
script
=
document
.
createElement
(
"
script
"
)
;
script
.
setAttribute
(
"
src
"
"
{
url
}
"
)
;
document
.
body
.
appendChild
(
script
)
;
null
;
;
return
evalInDebuggee
(
command
)
;
}
function
waitForSourceLoad
(
toolbox
url
)
{
info
(
Waiting
for
source
{
url
}
to
be
available
.
.
.
)
;
return
new
Promise
(
resolve
=
>
{
const
target
=
toolbox
.
target
;
function
sourceHandler
(
sourceEvent
)
{
if
(
sourceEvent
&
&
sourceEvent
.
source
&
&
sourceEvent
.
source
.
url
=
=
=
url
)
{
resolve
(
)
;
target
.
off
(
"
source
-
updated
"
sourceHandler
)
;
}
}
target
.
on
(
"
source
-
updated
"
sourceHandler
)
;
}
)
;
}
function
DevToolPanel
(
iframeWindow
toolbox
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_toolbox
=
toolbox
;
this
.
_window
=
iframeWindow
;
}
DevToolPanel
.
prototype
=
{
open
:
function
(
)
{
return
new
Promise
(
resolve
=
>
{
executeSoon
(
(
)
=
>
{
this
.
_isReady
=
true
;
this
.
emit
(
"
ready
"
)
;
resolve
(
this
)
;
}
)
;
}
)
;
}
get
document
(
)
{
return
this
.
_window
.
document
;
}
get
target
(
)
{
return
this
.
_toolbox
.
target
;
}
get
toolbox
(
)
{
return
this
.
_toolbox
;
}
get
isReady
(
)
{
return
this
.
_isReady
;
}
_isReady
:
false
destroy
:
function
(
)
{
return
Promise
.
resolve
(
null
)
;
}
}
;
function
createTestPanel
(
iframeWindow
toolbox
)
{
return
new
DevToolPanel
(
iframeWindow
toolbox
)
;
}
async
function
openChevronMenu
(
toolbox
)
{
const
chevronMenuButton
=
toolbox
.
doc
.
querySelector
(
"
.
tools
-
chevron
-
menu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
chevronMenuButton
{
}
toolbox
.
win
)
;
const
menuPopup
=
toolbox
.
doc
.
getElementById
(
"
tools
-
chevron
-
menu
-
button
-
panel
"
)
;
ok
(
menuPopup
"
tools
-
chevron
-
menupopup
is
available
"
)
;
info
(
"
Waiting
for
the
menu
popup
to
be
displayed
"
)
;
await
waitUntil
(
(
)
=
>
menuPopup
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
async
function
closeChevronMenu
(
toolbox
)
{
const
chevronMenuButton
=
toolbox
.
doc
.
querySelector
(
"
.
tools
-
chevron
-
menu
"
)
;
chevronMenuButton
.
focus
(
)
;
EventUtils
.
sendKey
(
"
ESCAPE
"
toolbox
.
doc
.
defaultView
)
;
const
menuPopup
=
toolbox
.
doc
.
getElementById
(
"
tools
-
chevron
-
menu
-
button
-
panel
"
)
;
info
(
"
Closing
the
chevron
popup
menu
"
)
;
await
waitUntil
(
(
)
=
>
!
menuPopup
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
function
prepareToolTabReorderTest
(
toolbox
startingOrder
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
toolbox
.
tabsOrder
"
startingOrder
.
join
(
"
"
)
)
;
ok
(
!
toolbox
.
doc
.
getElementById
(
"
tools
-
chevron
-
menu
-
button
"
)
"
The
size
of
the
screen
being
too
small
"
)
;
for
(
const
id
of
startingOrder
)
{
ok
(
getElementByToolId
(
toolbox
id
)
Tab
element
should
exist
for
{
id
}
)
;
}
}
async
function
dndToolTab
(
toolbox
dragTarget
dropTarget
passedTargets
=
[
]
)
{
info
(
Drag
{
dragTarget
}
to
{
dropTarget
}
)
;
const
dragTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
dragTarget
)
;
const
onReady
=
dragTargetEl
.
classList
.
contains
(
"
selected
"
)
?
Promise
.
resolve
(
)
:
toolbox
.
once
(
"
select
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
dragTargetEl
{
type
:
"
mousedown
"
}
dragTargetEl
.
ownerGlobal
)
;
await
onReady
;
for
(
const
passedTarget
of
passedTargets
)
{
info
(
Via
{
passedTarget
}
)
;
const
passedTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
passedTarget
)
;
EventUtils
.
synthesizeMouseAtCenter
(
passedTargetEl
{
type
:
"
mousemove
"
}
passedTargetEl
.
ownerGlobal
)
;
}
if
(
dropTarget
)
{
const
dropTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
dropTarget
)
;
EventUtils
.
synthesizeMouseAtCenter
(
dropTargetEl
{
type
:
"
mousemove
"
}
dropTargetEl
.
ownerGlobal
)
;
EventUtils
.
synthesizeMouseAtCenter
(
dropTargetEl
{
type
:
"
mouseup
"
}
dropTargetEl
.
ownerGlobal
)
;
}
else
{
const
containerEl
=
toolbox
.
doc
.
getElementById
(
"
toolbox
-
container
"
)
;
EventUtils
.
synthesizeMouse
(
containerEl
0
0
{
type
:
"
mouseout
"
}
containerEl
.
ownerGlobal
)
;
}
await
new
Promise
(
resolve
=
>
{
const
onUpdated
=
(
)
=
>
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
toolbox
.
tabsOrder
"
onUpdated
)
;
resolve
(
)
;
}
;
Services
.
prefs
.
addObserver
(
"
devtools
.
toolbox
.
tabsOrder
"
onUpdated
)
;
}
)
;
}
function
assertToolTabOrder
(
toolbox
expectedOrder
)
{
info
(
"
Check
the
order
of
the
tabs
on
the
toolbar
"
)
;
const
tabEls
=
toolbox
.
doc
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
;
for
(
let
i
=
0
;
i
<
expectedOrder
.
length
;
i
+
+
)
{
const
isOrdered
=
tabEls
[
i
]
.
dataset
.
id
=
=
=
expectedOrder
[
i
]
|
|
tabEls
[
i
]
.
dataset
.
extensionId
=
=
=
expectedOrder
[
i
]
;
ok
(
isOrdered
The
tab
[
{
expectedOrder
[
i
]
}
]
should
exist
at
[
{
i
}
]
)
;
}
}
function
assertToolTabSelected
(
toolbox
dragTarget
)
{
info
(
"
Check
whether
the
drag
target
was
selected
"
)
;
const
dragTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
dragTarget
)
;
ok
(
dragTargetEl
.
classList
.
contains
(
"
selected
"
)
"
The
dragged
tool
should
be
selected
"
)
;
}
function
assertToolTabPreferenceOrder
(
expectedOrder
)
{
info
(
"
Check
the
order
in
DevTools
preference
for
tabs
order
"
)
;
is
(
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
tabsOrder
"
)
expectedOrder
.
join
(
"
"
)
"
The
preference
should
be
correct
"
)
;
}
function
getElementByToolId
(
toolbox
id
)
{
for
(
const
tabEl
of
toolbox
.
doc
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
)
{
if
(
tabEl
.
dataset
.
id
=
=
=
id
|
|
tabEl
.
dataset
.
extensionId
=
=
=
id
)
{
return
tabEl
;
}
}
return
null
;
}
function
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
idOrSelector
)
{
const
tabEl
=
getElementByToolId
(
toolbox
idOrSelector
)
;
return
tabEl
?
tabEl
:
toolbox
.
doc
.
querySelector
(
idOrSelector
)
;
}
function
getWindow
(
toolbox
)
{
return
toolbox
.
topWindow
;
}
async
function
resizeWindow
(
toolbox
width
height
)
{
const
hostWindow
=
toolbox
.
win
.
parent
;
const
originalWidth
=
hostWindow
.
outerWidth
;
const
originalHeight
=
hostWindow
.
outerHeight
;
const
toWidth
=
width
|
|
originalWidth
;
const
toHeight
=
height
|
|
originalHeight
;
const
onResize
=
once
(
hostWindow
"
resize
"
)
;
hostWindow
.
resizeTo
(
toWidth
toHeight
)
;
await
onResize
;
}
function
assertSelectedLocationInDebugger
(
debuggerPanel
line
column
)
{
const
location
=
debuggerPanel
.
_selectors
.
getSelectedLocation
(
debuggerPanel
.
_getState
(
)
)
;
is
(
location
.
line
line
)
;
is
(
location
.
column
column
)
;
}
async
function
openAboutToolbox
(
params
)
{
info
(
"
Open
about
:
devtools
-
toolbox
"
)
;
const
querystring
=
new
URLSearchParams
(
)
;
Object
.
keys
(
params
)
.
forEach
(
x
=
>
querystring
.
append
(
x
params
[
x
]
)
)
;
const
tab
=
await
addTab
(
about
:
devtools
-
toolbox
?
{
querystring
}
)
;
const
browser
=
tab
.
linkedBrowser
;
return
{
tab
document
:
browser
.
contentDocument
}
;
}
function
setupPreferencesForBrowserToolbox
(
)
{
const
options
=
{
set
:
[
[
"
devtools
.
debugger
.
prompt
-
connection
"
false
]
[
"
devtools
.
debugger
.
remote
-
enabled
"
true
]
[
"
devtools
.
chrome
.
enabled
"
true
]
[
"
devtools
.
browser
-
toolbox
.
allow
-
unsafe
-
script
"
true
]
[
"
devtools
.
debugger
.
remote
-
timeout
"
120000
]
]
}
;
return
SpecialPowers
.
pushPrefEnv
(
options
)
;
}
function
loadFTL
(
toolbox
path
)
{
const
win
=
toolbox
.
doc
.
ownerGlobal
;
if
(
win
.
MozXULElement
)
{
win
.
MozXULElement
.
insertFTLIfNeeded
(
path
)
;
}
}
