Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
function
toggleAllTools
(
state
)
{
for
(
let
[
tool
]
of
gDevTools
.
_tools
)
{
if
(
!
tool
.
visibilityswitch
)
{
continue
;
}
if
(
state
)
{
Services
.
prefs
.
setBoolPref
(
tool
.
visibilityswitch
true
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
tool
.
visibilityswitch
)
;
}
}
}
function
getChromeActors
(
callback
)
{
let
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
let
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
let
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
client
.
connect
(
)
.
then
(
(
)
=
>
client
.
getProcess
(
)
)
.
then
(
response
=
>
{
callback
(
client
response
.
form
)
;
}
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
DebuggerServer
.
destroy
(
)
;
}
)
;
}
function
getSourceActor
(
aSources
aURL
)
{
let
item
=
aSources
.
getItemForAttachment
(
a
=
>
a
.
source
.
url
=
=
=
aURL
)
;
return
item
&
&
item
.
value
;
}
async
function
openScratchpadWindow
(
)
{
let
{
promise
:
p
resolve
}
=
defer
(
)
;
let
win
=
ScratchpadManager
.
openScratchpad
(
)
;
await
once
(
win
"
load
"
)
;
win
.
Scratchpad
.
addObserver
(
{
onReady
:
function
(
)
{
win
.
Scratchpad
.
removeObserver
(
this
)
;
resolve
(
win
)
;
}
}
)
;
return
p
;
}
function
waitForContentMessage
(
name
)
{
info
(
"
Expecting
message
"
+
name
+
"
from
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
def
=
defer
(
)
;
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
def
.
resolve
(
msg
.
data
)
;
}
)
;
return
def
.
promise
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
info
(
"
Sending
message
"
+
name
+
"
to
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
promise
.
resolve
(
)
;
}
function
synthesizeKeyElement
(
el
)
{
let
key
=
el
.
getAttribute
(
"
key
"
)
|
|
el
.
getAttribute
(
"
keycode
"
)
;
let
mod
=
{
}
;
el
.
getAttribute
(
"
modifiers
"
)
.
split
(
"
"
)
.
forEach
(
(
m
)
=
>
mod
[
m
+
"
Key
"
]
=
true
)
;
info
(
Synthesizing
:
key
=
{
key
}
mod
=
{
JSON
.
stringify
(
mod
)
}
)
;
EventUtils
.
synthesizeKey
(
key
mod
el
.
ownerDocument
.
defaultView
)
;
}
function
checkHostType
(
toolbox
hostType
previousHostType
)
{
is
(
toolbox
.
hostType
hostType
"
host
type
is
"
+
hostType
)
;
let
pref
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
host
"
)
;
is
(
pref
hostType
"
host
pref
is
"
+
hostType
)
;
if
(
previousHostType
)
{
is
(
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
previousHost
"
)
previousHostType
"
The
previous
host
is
correct
"
)
;
}
}
function
createScript
(
url
)
{
info
(
Creating
script
:
{
url
}
)
;
loadFrameScriptUtils
(
)
;
let
command
=
let
script
=
document
.
createElement
(
"
script
"
)
;
script
.
setAttribute
(
"
src
"
"
{
url
}
"
)
;
document
.
body
.
appendChild
(
script
)
;
null
;
;
return
evalInDebuggee
(
command
)
;
}
function
waitForSourceLoad
(
toolbox
url
)
{
info
(
Waiting
for
source
{
url
}
to
be
available
.
.
.
)
;
return
new
Promise
(
resolve
=
>
{
let
target
=
toolbox
.
target
;
function
sourceHandler
(
sourceEvent
)
{
if
(
sourceEvent
&
&
sourceEvent
.
source
&
&
sourceEvent
.
source
.
url
=
=
=
url
)
{
resolve
(
)
;
target
.
off
(
"
source
-
updated
"
sourceHandler
)
;
}
}
target
.
on
(
"
source
-
updated
"
sourceHandler
)
;
}
)
;
}
function
DevToolPanel
(
iframeWindow
toolbox
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_toolbox
=
toolbox
;
this
.
_window
=
iframeWindow
;
}
DevToolPanel
.
prototype
=
{
open
:
function
(
)
{
let
deferred
=
defer
(
)
;
executeSoon
(
(
)
=
>
{
this
.
_isReady
=
true
;
this
.
emit
(
"
ready
"
)
;
deferred
.
resolve
(
this
)
;
}
)
;
return
deferred
.
promise
;
}
get
document
(
)
{
return
this
.
_window
.
document
;
}
get
target
(
)
{
return
this
.
_toolbox
.
target
;
}
get
toolbox
(
)
{
return
this
.
_toolbox
;
}
get
isReady
(
)
{
return
this
.
_isReady
;
}
_isReady
:
false
destroy
:
function
(
)
{
return
defer
(
null
)
;
}
}
;
function
createTestPanel
(
iframeWindow
toolbox
)
{
return
new
DevToolPanel
(
iframeWindow
toolbox
)
;
}
async
function
openChevronMenu
(
toolbox
)
{
let
chevronMenuButton
=
toolbox
.
doc
.
querySelector
(
"
.
tools
-
chevron
-
menu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
chevronMenuButton
{
}
toolbox
.
win
)
;
let
menuPopup
=
toolbox
.
doc
.
querySelector
(
"
#
tools
-
chevron
-
menupopup
"
)
;
ok
(
menuPopup
"
tools
-
chevron
-
menupopup
is
available
"
)
;
info
(
"
Waiting
for
the
menu
popup
to
be
displayed
"
)
;
await
waitUntil
(
(
)
=
>
menuPopup
&
&
menuPopup
.
state
=
=
=
"
open
"
)
;
return
menuPopup
;
}
