Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
inspector
/
test
/
shared
-
head
.
js
"
this
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
async
function
getSupportedToolIds
(
tab
)
{
info
(
"
Getting
the
entire
list
of
tools
supported
in
this
tab
"
)
;
let
shouldDestroyToolbox
=
false
;
let
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
!
toolbox
)
{
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
)
;
shouldDestroyToolbox
=
true
;
}
const
toolIds
=
gDevTools
.
getToolDefinitionArray
(
)
.
filter
(
def
=
>
def
.
isToolSupported
(
toolbox
)
)
.
map
(
def
=
>
def
.
id
)
;
if
(
shouldDestroyToolbox
)
{
await
toolbox
.
destroy
(
)
;
}
return
toolIds
;
}
function
toggleAllTools
(
state
)
{
for
(
const
[
tool
]
of
gDevTools
.
_tools
)
{
if
(
!
tool
.
visibilityswitch
)
{
continue
;
}
if
(
state
)
{
Services
.
prefs
.
setBoolPref
(
tool
.
visibilityswitch
true
)
;
}
else
{
Services
.
prefs
.
clearUserPref
(
tool
.
visibilityswitch
)
;
}
}
}
async
function
getParentProcessActors
(
callback
)
{
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
DevToolsClient
}
=
require
(
"
devtools
/
client
/
devtools
-
client
"
)
;
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
DevToolsServer
.
allowChromeProcess
=
true
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
DevToolsServer
.
destroy
(
)
;
}
)
;
const
client
=
new
DevToolsClient
(
DevToolsServer
.
connectPipe
(
)
)
;
await
client
.
connect
(
)
;
const
mainProcessDescriptor
=
await
client
.
mainRoot
.
getMainProcess
(
)
;
const
mainProcessTargetFront
=
await
mainProcessDescriptor
.
getTarget
(
)
;
callback
(
client
mainProcessTargetFront
)
;
}
function
getSourceActor
(
aSources
aURL
)
{
const
item
=
aSources
.
getItemForAttachment
(
a
=
>
a
.
source
.
url
=
=
=
aURL
)
;
return
item
&
&
item
.
value
;
}
function
synthesizeKeyElement
(
el
)
{
const
key
=
el
.
getAttribute
(
"
key
"
)
|
|
el
.
getAttribute
(
"
keycode
"
)
;
const
mod
=
{
}
;
el
.
getAttribute
(
"
modifiers
"
)
.
split
(
"
"
)
.
forEach
(
m
=
>
(
mod
[
m
+
"
Key
"
]
=
true
)
)
;
info
(
Synthesizing
:
key
=
{
key
}
mod
=
{
JSON
.
stringify
(
mod
)
}
)
;
EventUtils
.
synthesizeKey
(
key
mod
el
.
ownerDocument
.
defaultView
)
;
}
function
checkHostType
(
toolbox
hostType
previousHostType
)
{
is
(
toolbox
.
hostType
hostType
"
host
type
is
"
+
hostType
)
;
const
pref
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
host
"
)
;
is
(
pref
hostType
"
host
pref
is
"
+
hostType
)
;
if
(
previousHostType
)
{
is
(
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
previousHost
"
)
previousHostType
"
The
previous
host
is
correct
"
)
;
}
}
function
createScript
(
url
)
{
info
(
Creating
script
:
{
url
}
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
url
]
urlChild
=
>
{
const
script
=
content
.
document
.
createElement
(
"
script
"
)
;
script
.
setAttribute
(
"
src
"
urlChild
)
;
content
.
document
.
body
.
appendChild
(
script
)
;
}
)
;
}
function
waitForSourceLoad
(
toolbox
url
)
{
info
(
Waiting
for
source
{
url
}
to
be
available
.
.
.
)
;
return
new
Promise
(
resolve
=
>
{
const
{
resourceCommand
}
=
toolbox
;
function
onAvailable
(
sources
)
{
for
(
const
source
of
sources
)
{
if
(
source
.
url
=
=
=
url
)
{
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
}
)
;
resolve
(
)
;
}
}
}
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
ignoreExistingResources
:
true
}
)
;
}
)
;
}
function
DevToolPanel
(
iframeWindow
toolbox
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_toolbox
=
toolbox
;
this
.
_window
=
iframeWindow
;
}
DevToolPanel
.
prototype
=
{
open
(
)
{
return
new
Promise
(
resolve
=
>
{
executeSoon
(
(
)
=
>
{
resolve
(
this
)
;
}
)
;
}
)
;
}
get
document
(
)
{
return
this
.
_window
.
document
;
}
get
target
(
)
{
return
this
.
_toolbox
.
target
;
}
get
toolbox
(
)
{
return
this
.
_toolbox
;
}
destroy
(
)
{
return
Promise
.
resolve
(
null
)
;
}
}
;
function
createTestPanel
(
iframeWindow
toolbox
)
{
return
new
DevToolPanel
(
iframeWindow
toolbox
)
;
}
async
function
openChevronMenu
(
toolbox
)
{
const
chevronMenuButton
=
toolbox
.
doc
.
querySelector
(
"
.
tools
-
chevron
-
menu
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
chevronMenuButton
{
}
toolbox
.
win
)
;
const
menuPopup
=
toolbox
.
doc
.
getElementById
(
"
tools
-
chevron
-
menu
-
button
-
panel
"
)
;
ok
(
menuPopup
"
tools
-
chevron
-
menupopup
is
available
"
)
;
info
(
"
Waiting
for
the
menu
popup
to
be
displayed
"
)
;
await
waitUntil
(
(
)
=
>
menuPopup
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
async
function
closeChevronMenu
(
toolbox
)
{
const
chevronMenuButton
=
toolbox
.
doc
.
querySelector
(
"
.
tools
-
chevron
-
menu
"
)
;
chevronMenuButton
.
focus
(
)
;
EventUtils
.
sendKey
(
"
ESCAPE
"
toolbox
.
doc
.
defaultView
)
;
const
menuPopup
=
toolbox
.
doc
.
getElementById
(
"
tools
-
chevron
-
menu
-
button
-
panel
"
)
;
info
(
"
Closing
the
chevron
popup
menu
"
)
;
await
waitUntil
(
(
)
=
>
!
menuPopup
.
classList
.
contains
(
"
tooltip
-
visible
"
)
)
;
}
function
prepareToolTabReorderTest
(
toolbox
startingOrder
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
toolbox
.
tabsOrder
"
startingOrder
.
join
(
"
"
)
)
;
ok
(
!
toolbox
.
doc
.
getElementById
(
"
tools
-
chevron
-
menu
-
button
"
)
"
The
size
of
the
screen
being
too
small
"
)
;
for
(
const
id
of
startingOrder
)
{
ok
(
getElementByToolId
(
toolbox
id
)
Tab
element
should
exist
for
{
id
}
)
;
}
}
async
function
dndToolTab
(
toolbox
dragTarget
dropTarget
passedTargets
=
[
]
)
{
info
(
Drag
{
dragTarget
}
to
{
dropTarget
}
)
;
const
dragTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
dragTarget
)
;
const
onReady
=
dragTargetEl
.
classList
.
contains
(
"
selected
"
)
?
Promise
.
resolve
(
)
:
toolbox
.
once
(
"
select
"
)
;
EventUtils
.
synthesizeMouseAtCenter
(
dragTargetEl
{
type
:
"
mousedown
"
}
dragTargetEl
.
ownerGlobal
)
;
await
onReady
;
for
(
const
passedTarget
of
passedTargets
)
{
info
(
Via
{
passedTarget
}
)
;
const
passedTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
passedTarget
)
;
EventUtils
.
synthesizeMouseAtCenter
(
passedTargetEl
{
type
:
"
mousemove
"
}
passedTargetEl
.
ownerGlobal
)
;
}
if
(
dropTarget
)
{
const
dropTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
dropTarget
)
;
EventUtils
.
synthesizeMouseAtCenter
(
dropTargetEl
{
type
:
"
mousemove
"
}
dropTargetEl
.
ownerGlobal
)
;
EventUtils
.
synthesizeMouseAtCenter
(
dropTargetEl
{
type
:
"
mouseup
"
}
dropTargetEl
.
ownerGlobal
)
;
}
else
{
const
containerEl
=
toolbox
.
doc
.
getElementById
(
"
toolbox
-
container
"
)
;
EventUtils
.
synthesizeMouse
(
containerEl
0
0
{
type
:
"
mouseout
"
}
containerEl
.
ownerGlobal
)
;
}
await
new
Promise
(
resolve
=
>
{
const
onUpdated
=
(
)
=
>
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
toolbox
.
tabsOrder
"
onUpdated
)
;
resolve
(
)
;
}
;
Services
.
prefs
.
addObserver
(
"
devtools
.
toolbox
.
tabsOrder
"
onUpdated
)
;
}
)
;
}
function
assertToolTabOrder
(
toolbox
expectedOrder
)
{
info
(
"
Check
the
order
of
the
tabs
on
the
toolbar
"
)
;
const
tabEls
=
toolbox
.
doc
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
;
for
(
let
i
=
0
;
i
<
expectedOrder
.
length
;
i
+
+
)
{
const
isOrdered
=
tabEls
[
i
]
.
dataset
.
id
=
=
=
expectedOrder
[
i
]
|
|
tabEls
[
i
]
.
dataset
.
extensionId
=
=
=
expectedOrder
[
i
]
;
ok
(
isOrdered
The
tab
[
{
expectedOrder
[
i
]
}
]
should
exist
at
[
{
i
}
]
)
;
}
}
function
assertToolTabSelected
(
toolbox
dragTarget
)
{
info
(
"
Check
whether
the
drag
target
was
selected
"
)
;
const
dragTargetEl
=
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
dragTarget
)
;
ok
(
dragTargetEl
.
classList
.
contains
(
"
selected
"
)
"
The
dragged
tool
should
be
selected
"
)
;
}
function
assertToolTabPreferenceOrder
(
expectedOrder
)
{
info
(
"
Check
the
order
in
DevTools
preference
for
tabs
order
"
)
;
is
(
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
tabsOrder
"
)
expectedOrder
.
join
(
"
"
)
"
The
preference
should
be
correct
"
)
;
}
function
getElementByToolId
(
toolbox
id
)
{
for
(
const
tabEl
of
toolbox
.
doc
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
)
{
if
(
tabEl
.
dataset
.
id
=
=
=
id
|
|
tabEl
.
dataset
.
extensionId
=
=
=
id
)
{
return
tabEl
;
}
}
return
null
;
}
function
getElementByToolIdOrExtensionIdOrSelector
(
toolbox
idOrSelector
)
{
const
tabEl
=
getElementByToolId
(
toolbox
idOrSelector
)
;
return
tabEl
?
tabEl
:
toolbox
.
doc
.
querySelector
(
idOrSelector
)
;
}
function
getToolboxTab
(
doc
toolId
)
{
return
(
doc
.
getElementById
(
toolbox
-
tab
-
{
toolId
}
)
|
|
doc
.
getElementById
(
tools
-
chevron
-
menupopup
-
{
toolId
}
)
)
;
}
function
getWindow
(
toolbox
)
{
return
toolbox
.
topWindow
;
}
async
function
resizeWindow
(
toolbox
width
height
)
{
const
hostWindow
=
toolbox
.
win
.
parent
;
const
originalWidth
=
hostWindow
.
outerWidth
;
const
originalHeight
=
hostWindow
.
outerHeight
;
const
toWidth
=
width
|
|
originalWidth
;
const
toHeight
=
height
|
|
originalHeight
;
const
onResize
=
once
(
hostWindow
"
resize
"
)
;
hostWindow
.
resizeTo
(
toWidth
toHeight
)
;
await
onResize
;
}
function
assertSelectedLocationInDebugger
(
debuggerPanel
line
column
)
{
const
location
=
debuggerPanel
.
_selectors
.
getSelectedLocation
(
debuggerPanel
.
_getState
(
)
)
;
is
(
location
.
line
line
)
;
is
(
location
.
column
column
)
;
}
async
function
openAboutToolbox
(
params
)
{
info
(
"
Open
about
:
devtools
-
toolbox
"
)
;
const
querystring
=
new
URLSearchParams
(
)
;
Object
.
keys
(
params
)
.
forEach
(
x
=
>
querystring
.
append
(
x
params
[
x
]
)
)
;
const
tab
=
await
addTab
(
about
:
devtools
-
toolbox
?
{
querystring
}
)
;
const
browser
=
tab
.
linkedBrowser
;
return
{
tab
document
:
browser
.
contentDocument
}
;
}
function
loadFTL
(
toolbox
path
)
{
const
win
=
toolbox
.
doc
.
ownerGlobal
;
if
(
win
.
MozXULElement
)
{
win
.
MozXULElement
.
insertFTLIfNeeded
(
path
)
;
}
}
async
function
sendToolboxReloadShortcut
(
shortcut
toolbox
)
{
const
promises
=
[
]
;
const
jsdebugger
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
if
(
jsdebugger
)
{
promises
.
push
(
jsdebugger
.
once
(
"
reloaded
"
)
)
;
}
const
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
if
(
inspector
)
{
promises
.
push
(
inspector
.
once
(
"
reloaded
"
)
inspector
.
once
(
"
inspector
-
updated
"
)
)
;
}
const
loadPromise
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
promises
.
push
(
loadPromise
)
;
info
(
"
Focus
the
toolbox
window
and
emit
the
reload
shortcut
:
"
+
shortcut
)
;
toolbox
.
win
.
focus
(
)
;
synthesizeKeyShortcut
(
shortcut
toolbox
.
win
)
;
info
(
"
Wait
for
page
and
toolbox
reload
promises
"
)
;
await
Promise
.
all
(
promises
)
;
}
function
getErrorIcon
(
toolbox
)
{
return
toolbox
.
doc
.
querySelector
(
"
.
toolbox
-
error
"
)
;
}
function
getErrorIconCount
(
toolbox
)
{
const
textContent
=
getErrorIcon
(
toolbox
)
?
.
textContent
;
try
{
const
int
=
parseInt
(
textContent
10
)
;
return
int
.
toString
(
)
=
=
=
textContent
?
int
:
textContent
;
}
catch
(
e
)
{
return
textContent
;
}
}
