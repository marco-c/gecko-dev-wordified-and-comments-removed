const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
function
scopedCuImport
(
path
)
{
const
scope
=
{
}
;
Cu
.
import
(
path
scope
)
;
return
scope
;
}
const
{
Services
}
=
scopedCuImport
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
gDevTools
}
=
scopedCuImport
(
"
resource
:
/
/
/
modules
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
)
;
const
{
console
}
=
scopedCuImport
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
shared
/
Console
.
jsm
"
)
;
const
{
ScratchpadManager
}
=
scopedCuImport
(
"
resource
:
/
/
/
modules
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
const
{
require
}
=
scopedCuImport
(
"
resource
:
/
/
gre
/
modules
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
waitForExplicitFinish
(
)
;
function
getFrameScript
(
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
frameURL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
mm
.
loadFrameScript
(
frameURL
false
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
mm
=
null
;
}
)
;
return
mm
;
}
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
DevToolsUtils
.
testing
=
false
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
}
)
;
registerCleanupFunction
(
function
*
cleanup
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
function
addTab
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
let
def
=
promise
.
defer
(
)
;
let
tab
=
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
)
;
gBrowser
.
selectedBrowser
.
addEventListener
(
"
load
"
function
onload
(
)
{
gBrowser
.
selectedBrowser
.
removeEventListener
(
"
load
"
onload
true
)
;
info
(
"
URL
'
"
+
url
+
"
'
loading
complete
"
)
;
def
.
resolve
(
tab
)
;
}
true
)
;
return
def
.
promise
;
}
function
removeTab
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
return
new
Promise
(
resolve
=
>
{
let
tabContainer
=
gBrowser
.
tabContainer
;
tabContainer
.
addEventListener
(
"
TabClose
"
function
onClose
(
aEvent
)
{
tabContainer
.
removeEventListener
(
"
TabClose
"
onClose
false
)
;
info
(
"
Tab
removed
and
finished
closing
.
"
)
;
resolve
(
)
;
}
false
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
}
function
synthesizeKeyFromKeyTag
(
aKeyId
document
)
{
let
key
=
document
.
getElementById
(
aKeyId
)
;
isnot
(
key
null
"
Successfully
retrieved
the
<
key
>
node
"
)
;
let
modifiersAttr
=
key
.
getAttribute
(
"
modifiers
"
)
;
let
name
=
null
;
if
(
key
.
getAttribute
(
"
keycode
"
)
)
name
=
key
.
getAttribute
(
"
keycode
"
)
;
else
if
(
key
.
getAttribute
(
"
key
"
)
)
name
=
key
.
getAttribute
(
"
key
"
)
;
isnot
(
name
null
"
Successfully
retrieved
keycode
/
key
"
)
;
let
modifiers
=
{
shiftKey
:
modifiersAttr
.
match
(
"
shift
"
)
ctrlKey
:
modifiersAttr
.
match
(
"
ctrl
"
)
altKey
:
modifiersAttr
.
match
(
"
alt
"
)
metaKey
:
modifiersAttr
.
match
(
"
meta
"
)
accelKey
:
modifiersAttr
.
match
(
"
accel
"
)
}
;
EventUtils
.
synthesizeKey
(
name
modifiers
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
promise
.
defer
(
)
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
function
loadHelperScript
(
filePath
)
{
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
waitForTick
(
)
{
let
deferred
=
promise
.
defer
(
)
;
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
function
loadToolbox
(
url
)
{
let
{
promise
:
p
resolve
}
=
promise
.
defer
(
)
;
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
gBrowser
.
selectedBrowser
.
addEventListener
(
"
load
"
function
onLoad
(
evt
)
{
gBrowser
.
selectedBrowser
.
removeEventListener
(
evt
.
type
onLoad
true
)
;
gDevTools
.
showToolbox
(
target
)
.
then
(
resolve
)
;
}
true
)
;
content
.
location
=
url
;
return
p
;
}
function
unloadToolbox
(
toolbox
)
{
return
toolbox
.
destroy
(
)
.
then
(
function
(
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
}
