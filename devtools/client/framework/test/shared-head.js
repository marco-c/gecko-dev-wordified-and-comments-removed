"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
Constructor
:
CC
}
=
Components
;
function
scopedCuImport
(
path
)
{
const
scope
=
{
}
;
Cu
.
import
(
path
scope
)
;
return
scope
;
}
const
{
Services
}
=
scopedCuImport
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
console
}
=
scopedCuImport
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
const
{
ScratchpadManager
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
const
{
require
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
let
promise
=
require
(
"
promise
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
waitForExplicitFinish
(
)
;
function
getFrameScript
(
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
frameURL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
mm
.
loadFrameScript
(
frameURL
false
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
mm
=
null
;
}
)
;
return
mm
;
}
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
DevToolsUtils
.
testing
=
false
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
}
)
;
registerCleanupFunction
(
function
*
cleanup
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
var
addTab
=
Task
.
async
(
function
*
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
"
+
url
)
;
let
tab
=
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
)
;
yield
once
(
gBrowser
.
selectedBrowser
"
load
"
true
)
;
info
(
"
Tab
added
and
finished
loading
"
)
;
return
tab
;
}
)
;
var
removeTab
=
Task
.
async
(
function
*
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
let
onClose
=
once
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
gBrowser
.
removeTab
(
tab
)
;
yield
onClose
;
info
(
"
Tab
removed
and
finished
closing
"
)
;
}
)
;
function
synthesizeKeyFromKeyTag
(
key
)
{
is
(
key
&
&
key
.
tagName
"
key
"
"
Successfully
retrieved
the
<
key
>
node
"
)
;
let
modifiersAttr
=
key
.
getAttribute
(
"
modifiers
"
)
;
let
name
=
null
;
if
(
key
.
getAttribute
(
"
keycode
"
)
)
{
name
=
key
.
getAttribute
(
"
keycode
"
)
;
}
else
if
(
key
.
getAttribute
(
"
key
"
)
)
{
name
=
key
.
getAttribute
(
"
key
"
)
;
}
isnot
(
name
null
"
Successfully
retrieved
keycode
/
key
"
)
;
let
modifiers
=
{
shiftKey
:
!
!
modifiersAttr
.
match
(
"
shift
"
)
ctrlKey
:
!
!
modifiersAttr
.
match
(
"
control
"
)
altKey
:
!
!
modifiersAttr
.
match
(
"
alt
"
)
metaKey
:
!
!
modifiersAttr
.
match
(
"
meta
"
)
accelKey
:
!
!
modifiersAttr
.
match
(
"
accel
"
)
}
;
info
(
"
Synthesizing
key
"
+
name
+
"
"
+
JSON
.
stringify
(
modifiers
)
)
;
EventUtils
.
synthesizeKey
(
name
modifiers
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
promise
.
defer
(
)
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
function
loadHelperScript
(
filePath
)
{
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
waitForTick
(
)
{
let
deferred
=
promise
.
defer
(
)
;
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
var
openToolboxForTab
=
Task
.
async
(
function
*
(
tab
toolId
hostType
)
{
info
(
"
Opening
the
toolbox
"
)
;
let
toolbox
;
let
target
=
TargetFactory
.
forTab
(
tab
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
if
(
!
toolId
|
|
(
toolId
&
&
toolbox
.
getPanel
(
toolId
)
)
)
{
info
(
"
Toolbox
is
already
opened
"
)
;
return
toolbox
;
}
}
toolbox
=
yield
gDevTools
.
showToolbox
(
target
toolId
hostType
)
;
yield
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
toolbox
.
frame
.
contentWindow
)
)
;
info
(
"
Toolbox
opened
and
focused
"
)
;
return
toolbox
;
}
)
;
var
openNewTabAndToolbox
=
Task
.
async
(
function
*
(
url
toolId
hostType
)
{
let
tab
=
yield
addTab
(
url
)
;
return
openToolboxForTab
(
tab
toolId
hostType
)
}
)
;
function
closeToolboxAndTab
(
toolbox
)
{
return
toolbox
.
destroy
(
)
.
then
(
function
(
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
}
