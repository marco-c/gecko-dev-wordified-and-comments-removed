"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
Constructor
:
CC
}
=
Components
;
function
scopedCuImport
(
path
)
{
const
scope
=
{
}
;
ChromeUtils
.
import
(
path
scope
)
;
return
scope
;
}
const
{
PromiseTestUtils
}
=
scopedCuImport
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
Component
not
initialized
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
Connection
closed
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
destroy
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
File
closed
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
is
no
longer
usable
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
NS_ERROR_FAILURE
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
this
\
.
_urls
is
null
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
this
\
.
tabTarget
is
null
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
this
\
.
toolbox
is
null
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
this
\
.
webConsoleClient
is
null
/
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
this
\
.
worker
is
null
/
)
;
const
{
console
}
=
scopedCuImport
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
const
{
ScratchpadManager
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
const
{
loader
require
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
let
promise
=
require
(
"
promise
"
)
;
let
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
waitForExplicitFinish
(
)
;
var
EXPECTED_DTU_ASSERT_FAILURE_COUNT
=
0
;
registerCleanupFunction
(
function
(
)
{
if
(
DevToolsUtils
.
assertionFailureCount
!
=
=
EXPECTED_DTU_ASSERT_FAILURE_COUNT
)
{
ok
(
false
"
Should
have
had
the
expected
number
of
DevToolsUtils
.
assert
(
)
failures
.
"
+
"
Expected
"
+
EXPECTED_DTU_ASSERT_FAILURE_COUNT
+
"
got
"
+
DevToolsUtils
.
assertionFailureCount
)
;
}
}
)
;
const
ConsoleObserver
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
observe
:
function
(
subject
topic
data
)
{
let
message
=
subject
.
wrappedJSObject
.
arguments
[
0
]
;
if
(
message
&
&
/
Failed
propType
/
.
test
(
message
.
toString
(
)
)
)
{
ok
(
false
message
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
}
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
DEBUG_ALLOCATIONS
=
env
.
get
(
"
DEBUG_DEVTOOLS_ALLOCATIONS
"
)
;
if
(
DEBUG_ALLOCATIONS
)
{
const
{
allocationTracker
}
=
require
(
"
devtools
/
shared
/
test
-
helpers
/
allocation
-
tracker
"
)
;
let
tracker
=
allocationTracker
(
)
;
registerCleanupFunction
(
(
)
=
>
{
if
(
DEBUG_ALLOCATIONS
=
=
"
normal
"
)
{
tracker
.
logCount
(
)
;
}
else
if
(
DEBUG_ALLOCATIONS
=
=
"
verbose
"
)
{
tracker
.
logAllocationSites
(
)
;
}
tracker
.
stop
(
)
;
}
)
;
}
var
waitForTime
=
DevToolsUtils
.
waitForTime
;
function
getFrameScript
(
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
frameURL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
mm
.
loadFrameScript
(
frameURL
false
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
mm
=
null
;
}
)
;
return
mm
;
}
flags
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
flags
.
testing
=
false
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleEnabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleHeight
"
)
;
}
)
;
registerCleanupFunction
(
function
*
cleanup
(
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
{
yield
closeTabAndToolbox
(
gBrowser
.
selectedTab
)
;
}
}
)
;
var
addTab
=
Task
.
async
(
function
*
(
url
options
=
{
background
:
false
window
:
window
}
)
{
info
(
"
Adding
a
new
tab
with
URL
:
"
+
url
)
;
let
{
background
}
=
options
;
let
{
gBrowser
}
=
options
.
window
?
options
.
window
:
window
;
let
{
userContextId
}
=
options
;
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
url
{
userContextId
preferredRemoteType
:
options
.
preferredRemoteType
}
)
;
if
(
!
background
)
{
gBrowser
.
selectedTab
=
tab
;
}
yield
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
info
(
"
Tab
added
and
finished
loading
"
)
;
return
tab
;
}
)
;
var
removeTab
=
Task
.
async
(
function
*
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
let
{
gBrowser
}
=
tab
.
ownerDocument
.
defaultView
;
let
onClose
=
once
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
gBrowser
.
removeTab
(
tab
)
;
yield
onClose
;
info
(
"
Tab
removed
and
finished
closing
"
)
;
}
)
;
var
refreshTab
=
async
function
(
tab
=
gBrowser
.
selectedTab
)
{
info
(
"
Refreshing
tab
.
"
)
;
const
finished
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
gBrowser
.
reloadTab
(
tab
)
;
await
finished
;
info
(
"
Tab
finished
refreshing
.
"
)
;
}
;
function
synthesizeKeyFromKeyTag
(
key
)
{
is
(
key
&
&
key
.
tagName
"
key
"
"
Successfully
retrieved
the
<
key
>
node
"
)
;
let
modifiersAttr
=
key
.
getAttribute
(
"
modifiers
"
)
;
let
name
=
null
;
if
(
key
.
getAttribute
(
"
keycode
"
)
)
{
name
=
key
.
getAttribute
(
"
keycode
"
)
;
}
else
if
(
key
.
getAttribute
(
"
key
"
)
)
{
name
=
key
.
getAttribute
(
"
key
"
)
;
}
isnot
(
name
null
"
Successfully
retrieved
keycode
/
key
"
)
;
let
modifiers
=
{
shiftKey
:
!
!
modifiersAttr
.
match
(
"
shift
"
)
ctrlKey
:
!
!
modifiersAttr
.
match
(
"
control
"
)
altKey
:
!
!
modifiersAttr
.
match
(
"
alt
"
)
metaKey
:
!
!
modifiersAttr
.
match
(
"
meta
"
)
accelKey
:
!
!
modifiersAttr
.
match
(
"
accel
"
)
}
;
info
(
"
Synthesizing
key
"
+
name
+
"
"
+
JSON
.
stringify
(
modifiers
)
)
;
EventUtils
.
synthesizeKey
(
name
modifiers
)
;
}
function
synthesizeKeyShortcut
(
key
target
)
{
let
window
=
Services
.
appShell
.
hiddenDOMWindow
;
let
shortcut
=
KeyShortcuts
.
parseElectronKey
(
window
key
)
;
let
keyEvent
=
{
altKey
:
shortcut
.
alt
ctrlKey
:
shortcut
.
ctrl
metaKey
:
shortcut
.
meta
shiftKey
:
shortcut
.
shift
}
;
if
(
shortcut
.
keyCode
)
{
keyEvent
.
keyCode
=
shortcut
.
keyCode
;
}
info
(
"
Synthesizing
key
shortcut
:
"
+
key
)
;
EventUtils
.
synthesizeKey
(
shortcut
.
key
|
|
"
"
keyEvent
target
)
;
}
function
waitForNEvents
(
target
eventName
numTimes
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
defer
(
)
;
let
count
=
0
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
if
(
+
+
count
=
=
numTimes
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
function
waitForDOM
(
target
selector
expectedLength
=
1
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
observer
=
new
MutationObserver
(
(
mutations
)
=
>
{
mutations
.
forEach
(
(
mutation
)
=
>
{
let
elements
=
mutation
.
target
.
querySelectorAll
(
selector
)
;
if
(
elements
.
length
=
=
=
expectedLength
)
{
observer
.
disconnect
(
)
;
resolve
(
elements
)
;
}
}
)
;
}
)
;
observer
.
observe
(
target
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
;
}
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
return
waitForNEvents
(
target
eventName
1
useCapture
)
;
}
function
loadHelperScript
(
filePath
)
{
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
waitForTick
(
)
{
let
deferred
=
defer
(
)
;
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
function
wait
(
ms
)
{
return
new
promise
(
resolve
=
>
setTimeout
(
resolve
ms
)
)
;
}
var
openToolboxForTab
=
Task
.
async
(
function
*
(
tab
toolId
hostType
)
{
info
(
"
Opening
the
toolbox
"
)
;
let
toolbox
;
let
target
=
TargetFactory
.
forTab
(
tab
)
;
yield
target
.
makeRemote
(
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
if
(
!
toolId
|
|
(
toolId
&
&
toolbox
.
getPanel
(
toolId
)
)
)
{
info
(
"
Toolbox
is
already
opened
"
)
;
return
toolbox
;
}
}
toolbox
=
yield
gDevTools
.
showToolbox
(
target
toolId
hostType
)
;
yield
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
toolbox
.
win
)
)
;
info
(
"
Toolbox
opened
and
focused
"
)
;
return
toolbox
;
}
)
;
var
openNewTabAndToolbox
=
Task
.
async
(
function
*
(
url
toolId
hostType
)
{
let
tab
=
yield
addTab
(
url
)
;
return
openToolboxForTab
(
tab
toolId
hostType
)
;
}
)
;
var
closeTabAndToolbox
=
Task
.
async
(
function
*
(
tab
=
gBrowser
.
selectedTab
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
if
(
target
)
{
yield
gDevTools
.
closeToolbox
(
target
)
;
}
yield
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
var
closeToolboxAndTab
=
Task
.
async
(
function
*
(
toolbox
)
{
yield
toolbox
.
destroy
(
)
;
yield
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
let
MM_INC_ID
=
0
;
function
evalInDebuggee
(
mm
script
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
id
=
MM_INC_ID
+
+
;
mm
.
sendAsyncMessage
(
"
devtools
:
test
:
eval
"
{
script
id
}
)
;
mm
.
addMessageListener
(
"
devtools
:
test
:
eval
:
response
"
handler
)
;
function
handler
(
{
data
}
)
{
if
(
id
!
=
=
data
.
id
)
{
return
;
}
info
(
Successfully
evaled
in
debuggee
:
{
script
}
)
;
mm
.
removeMessageListener
(
"
devtools
:
test
:
eval
:
response
"
handler
)
;
resolve
(
data
.
value
)
;
}
}
)
;
}
function
waitForContextMenu
(
popup
button
onShown
onHidden
)
{
let
deferred
=
defer
(
)
;
function
onPopupShown
(
)
{
info
(
"
onPopupShown
"
)
;
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
onShown
&
&
onShown
(
)
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
executeSoon
(
(
)
=
>
popup
.
hidePopup
(
)
)
;
}
function
onPopupHidden
(
)
{
info
(
"
onPopupHidden
"
)
;
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
onHidden
&
&
onHidden
(
)
;
deferred
.
resolve
(
popup
)
;
}
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
info
(
"
wait
for
the
context
menu
to
open
"
)
;
synthesizeContextMenuEvent
(
button
)
;
return
deferred
.
promise
;
}
function
synthesizeContextMenuEvent
(
el
)
{
el
.
scrollIntoView
(
)
;
let
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
EventUtils
.
synthesizeMouse
(
el
5
2
eventDetails
el
.
ownerDocument
.
defaultView
)
;
}
function
waitForClipboardPromise
(
setup
expected
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SimpleTest
.
waitForClipboard
(
expected
setup
resolve
reject
)
;
}
)
;
}
function
pushPref
(
preferenceName
value
)
{
return
new
Promise
(
resolve
=
>
{
let
options
=
{
"
set
"
:
[
[
preferenceName
value
]
]
}
;
SpecialPowers
.
pushPrefEnv
(
options
resolve
)
;
}
)
;
}
function
lookupPath
(
obj
path
)
{
let
segments
=
path
.
split
(
"
.
"
)
;
return
segments
.
reduce
(
(
prev
current
)
=
>
prev
[
current
]
obj
)
;
}
var
closeToolbox
=
Task
.
async
(
function
*
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
}
)
;
function
loadTelemetryAndRecordLogs
(
)
{
info
(
"
Mock
the
Telemetry
log
function
to
record
logged
information
"
)
;
let
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
Telemetry
.
prototype
.
telemetryInfo
=
{
}
;
Telemetry
.
prototype
.
_oldlog
=
Telemetry
.
prototype
.
log
;
Telemetry
.
prototype
.
log
=
function
(
histogramId
value
)
{
if
(
!
this
.
telemetryInfo
)
{
return
;
}
if
(
histogramId
)
{
if
(
!
this
.
telemetryInfo
[
histogramId
]
)
{
this
.
telemetryInfo
[
histogramId
]
=
[
]
;
}
this
.
telemetryInfo
[
histogramId
]
.
push
(
value
)
;
}
}
;
Telemetry
.
prototype
.
_oldlogScalar
=
Telemetry
.
prototype
.
logScalar
;
Telemetry
.
prototype
.
logScalar
=
Telemetry
.
prototype
.
log
;
Telemetry
.
prototype
.
_oldlogKeyed
=
Telemetry
.
prototype
.
logKeyed
;
Telemetry
.
prototype
.
logKeyed
=
function
(
histogramId
key
value
)
{
this
.
log
(
{
histogramId
}
|
{
key
}
value
)
;
}
;
return
Telemetry
;
}
function
stopRecordingTelemetryLogs
(
Telemetry
)
{
info
(
"
Stopping
Telemetry
"
)
;
Telemetry
.
prototype
.
log
=
Telemetry
.
prototype
.
_oldlog
;
Telemetry
.
prototype
.
logScalar
=
Telemetry
.
prototype
.
_oldlogScalar
;
Telemetry
.
prototype
.
logKeyed
=
Telemetry
.
prototype
.
_oldlogKeyed
;
delete
Telemetry
.
prototype
.
_oldlog
;
delete
Telemetry
.
prototype
.
_oldlogScalar
;
delete
Telemetry
.
prototype
.
_oldlogKeyed
;
delete
Telemetry
.
prototype
.
telemetryInfo
;
}
function
emptyClipboard
(
)
{
let
clipboard
=
Cc
[
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
]
.
getService
(
SpecialPowers
.
Ci
.
nsIClipboard
)
;
clipboard
.
emptyClipboard
(
clipboard
.
kGlobalClipboard
)
;
}
function
isWindows
(
)
{
return
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
;
}
function
waitForTitleChange
(
toolbox
)
{
let
deferred
=
defer
(
)
;
toolbox
.
win
.
parent
.
addEventListener
(
"
message
"
function
onmessage
(
event
)
{
if
(
event
.
data
.
name
=
=
"
set
-
host
-
title
"
)
{
toolbox
.
win
.
parent
.
removeEventListener
(
"
message
"
onmessage
)
;
deferred
.
resolve
(
)
;
}
}
)
;
return
deferred
.
promise
;
}
function
createTestHTTPServer
(
)
{
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
{
}
)
;
let
server
=
new
HttpServer
(
)
;
registerCleanupFunction
(
function
*
cleanup
(
)
{
let
destroyed
=
defer
(
)
;
server
.
stop
(
(
)
=
>
{
destroyed
.
resolve
(
)
;
}
)
;
yield
destroyed
.
promise
;
}
)
;
server
.
start
(
-
1
)
;
return
server
;
}
async
function
injectEventUtilsInContentTask
(
browser
)
{
await
ContentTask
.
spawn
(
browser
{
}
function
*
(
)
{
if
(
"
EventUtils
"
in
this
)
{
return
;
}
let
EventUtils
=
this
.
EventUtils
=
{
}
;
EventUtils
.
window
=
{
}
;
EventUtils
.
parent
=
EventUtils
.
window
;
EventUtils
.
_EU_Ci
=
Components
.
interfaces
;
EventUtils
.
_EU_Cc
=
Components
.
classes
;
EventUtils
.
navigator
=
content
.
navigator
;
EventUtils
.
KeyboardEvent
=
content
.
KeyboardEvent
;
EventUtils
.
synthesizeClick
=
element
=
>
new
Promise
(
resolve
=
>
{
element
.
addEventListener
(
"
click
"
function
(
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
type
:
"
mousedown
"
isSynthesized
:
false
}
content
)
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
type
:
"
mouseup
"
isSynthesized
:
false
}
content
)
;
}
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
EventUtils
)
;
}
)
;
}
