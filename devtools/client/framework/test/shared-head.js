"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
Constructor
:
CC
}
=
Components
;
function
scopedCuImport
(
path
)
{
const
scope
=
{
}
;
Cu
.
import
(
path
scope
)
;
return
scope
;
}
const
{
console
}
=
scopedCuImport
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
const
{
ScratchpadManager
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
const
{
require
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
let
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
waitForExplicitFinish
(
)
;
var
EXPECTED_DTU_ASSERT_FAILURE_COUNT
=
0
;
registerCleanupFunction
(
function
(
)
{
if
(
DevToolsUtils
.
assertionFailureCount
!
=
=
EXPECTED_DTU_ASSERT_FAILURE_COUNT
)
{
ok
(
false
"
Should
have
had
the
expected
number
of
DevToolsUtils
.
assert
(
)
failures
.
"
+
"
Expected
"
+
EXPECTED_DTU_ASSERT_FAILURE_COUNT
+
"
got
"
+
DevToolsUtils
.
assertionFailureCount
)
;
}
}
)
;
const
ConsoleObserver
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
observe
:
function
(
subject
topic
data
)
{
let
message
=
subject
.
wrappedJSObject
.
arguments
[
0
]
;
if
(
/
Failed
propType
/
.
test
(
message
)
)
{
ok
(
false
message
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
}
)
;
var
waitForTime
=
DevToolsUtils
.
waitForTime
;
function
getFrameScript
(
)
{
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
frameURL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
mm
.
loadFrameScript
(
frameURL
false
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
mm
=
null
;
}
)
;
return
mm
;
}
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
DevToolsUtils
.
testing
=
false
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
}
)
;
registerCleanupFunction
(
function
*
cleanup
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
var
addTab
=
Task
.
async
(
function
*
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
"
+
url
)
;
let
tab
=
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
)
;
yield
once
(
gBrowser
.
selectedBrowser
"
load
"
true
)
;
info
(
"
Tab
added
and
finished
loading
"
)
;
return
tab
;
}
)
;
var
removeTab
=
Task
.
async
(
function
*
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
let
onClose
=
once
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
gBrowser
.
removeTab
(
tab
)
;
yield
onClose
;
info
(
"
Tab
removed
and
finished
closing
"
)
;
}
)
;
function
synthesizeKeyFromKeyTag
(
key
)
{
is
(
key
&
&
key
.
tagName
"
key
"
"
Successfully
retrieved
the
<
key
>
node
"
)
;
let
modifiersAttr
=
key
.
getAttribute
(
"
modifiers
"
)
;
let
name
=
null
;
if
(
key
.
getAttribute
(
"
keycode
"
)
)
{
name
=
key
.
getAttribute
(
"
keycode
"
)
;
}
else
if
(
key
.
getAttribute
(
"
key
"
)
)
{
name
=
key
.
getAttribute
(
"
key
"
)
;
}
isnot
(
name
null
"
Successfully
retrieved
keycode
/
key
"
)
;
let
modifiers
=
{
shiftKey
:
!
!
modifiersAttr
.
match
(
"
shift
"
)
ctrlKey
:
!
!
modifiersAttr
.
match
(
"
control
"
)
altKey
:
!
!
modifiersAttr
.
match
(
"
alt
"
)
metaKey
:
!
!
modifiersAttr
.
match
(
"
meta
"
)
accelKey
:
!
!
modifiersAttr
.
match
(
"
accel
"
)
}
;
info
(
"
Synthesizing
key
"
+
name
+
"
"
+
JSON
.
stringify
(
modifiers
)
)
;
EventUtils
.
synthesizeKey
(
name
modifiers
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
promise
.
defer
(
)
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
function
loadHelperScript
(
filePath
)
{
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
waitForTick
(
)
{
let
deferred
=
promise
.
defer
(
)
;
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
var
openToolboxForTab
=
Task
.
async
(
function
*
(
tab
toolId
hostType
)
{
info
(
"
Opening
the
toolbox
"
)
;
let
toolbox
;
let
target
=
TargetFactory
.
forTab
(
tab
)
;
yield
target
.
makeRemote
(
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
if
(
!
toolId
|
|
(
toolId
&
&
toolbox
.
getPanel
(
toolId
)
)
)
{
info
(
"
Toolbox
is
already
opened
"
)
;
return
toolbox
;
}
}
toolbox
=
yield
gDevTools
.
showToolbox
(
target
toolId
hostType
)
;
yield
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
toolbox
.
frame
.
contentWindow
)
)
;
info
(
"
Toolbox
opened
and
focused
"
)
;
return
toolbox
;
}
)
;
var
openNewTabAndToolbox
=
Task
.
async
(
function
*
(
url
toolId
hostType
)
{
let
tab
=
yield
addTab
(
url
)
;
return
openToolboxForTab
(
tab
toolId
hostType
)
;
}
)
;
var
closeTabAndToolbox
=
Task
.
async
(
function
*
(
tab
=
gBrowser
.
selectedTab
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
if
(
target
)
{
yield
gDevTools
.
closeToolbox
(
target
)
;
}
yield
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
var
closeToolboxAndTab
=
Task
.
async
(
function
*
(
toolbox
)
{
yield
toolbox
.
destroy
(
)
;
yield
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
let
MM_INC_ID
=
0
;
function
evalInDebuggee
(
mm
script
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
let
id
=
MM_INC_ID
+
+
;
mm
.
sendAsyncMessage
(
"
devtools
:
test
:
eval
"
{
script
id
}
)
;
mm
.
addMessageListener
(
"
devtools
:
test
:
eval
:
response
"
handler
)
;
function
handler
(
{
data
}
)
{
if
(
id
!
=
=
data
.
id
)
{
return
;
}
info
(
Successfully
evaled
in
debuggee
:
{
script
}
)
;
mm
.
removeMessageListener
(
"
devtools
:
test
:
eval
:
response
"
handler
)
;
resolve
(
data
.
value
)
;
}
}
)
;
}
function
waitForContextMenu
(
popup
button
onShown
onHidden
)
{
let
deferred
=
promise
.
defer
(
)
;
function
onPopupShown
(
)
{
info
(
"
onPopupShown
"
)
;
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
onShown
&
&
onShown
(
)
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
executeSoon
(
(
)
=
>
popup
.
hidePopup
(
)
)
;
}
function
onPopupHidden
(
)
{
info
(
"
onPopupHidden
"
)
;
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
onHidden
&
&
onHidden
(
)
;
deferred
.
resolve
(
popup
)
;
}
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
info
(
"
wait
for
the
context
menu
to
open
"
)
;
button
.
scrollIntoView
(
)
;
let
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
EventUtils
.
synthesizeMouse
(
button
5
2
eventDetails
button
.
ownerDocument
.
defaultView
)
;
return
deferred
.
promise
;
}
