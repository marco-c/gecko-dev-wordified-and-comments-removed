"
use
strict
"
;
const
{
BrowserToolboxProcess
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
)
;
const
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
async
function
initBrowserToolboxTask
(
{
enableBrowserToolboxFission
}
=
{
}
)
{
await
pushPref
(
"
devtools
.
chrome
.
enabled
"
true
)
;
await
pushPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
true
)
;
await
pushPref
(
"
devtools
.
browser
-
toolbox
.
allow
-
unsafe
-
script
"
true
)
;
await
pushPref
(
"
devtools
.
debugger
.
prompt
-
connection
"
false
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
.
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
File
closed
/
)
;
const
process
=
await
new
Promise
(
onRun
=
>
{
BrowserToolboxProcess
.
init
(
null
onRun
true
)
;
}
)
;
ok
(
true
"
Browser
toolbox
started
\
n
"
)
;
is
(
BrowserToolboxProcess
.
getBrowserToolboxSessionState
(
)
true
"
Has
session
state
"
)
;
let
transport
;
while
(
true
)
{
try
{
transport
=
await
DebuggerClient
.
socketConnect
(
{
host
:
"
localhost
"
port
:
6001
webSocket
:
false
}
)
;
break
;
}
catch
(
e
)
{
await
waitForTime
(
100
)
;
}
}
ok
(
true
"
Got
transport
"
)
;
const
client
=
new
DebuggerClient
(
transport
)
;
await
client
.
connect
(
)
;
ok
(
true
"
Connected
"
)
;
const
target
=
await
client
.
mainRoot
.
getMainProcess
(
)
;
const
consoleFront
=
await
target
.
getFront
(
"
console
"
)
;
const
preferenceFront
=
await
client
.
mainRoot
.
getFront
(
"
preference
"
)
;
if
(
enableBrowserToolboxFission
)
{
await
preferenceFront
.
setBoolPref
(
"
devtools
.
browsertoolbox
.
fission
"
true
)
;
}
async
function
spawn
(
arg
fn
)
{
const
rv
=
await
consoleFront
.
evaluateJSAsync
(
(
{
fn
}
)
(
{
arg
}
)
{
mapped
:
{
await
:
true
}
}
)
;
if
(
rv
.
exception
)
{
throw
new
Error
(
ToolboxTask
.
spawn
failure
:
{
rv
.
exception
.
message
}
)
;
}
else
if
(
rv
.
topLevelAwaitRejected
)
{
throw
new
Error
(
ToolboxTask
.
spawn
await
rejected
)
;
}
return
rv
.
result
;
}
async
function
importFunctions
(
functions
)
{
for
(
const
[
key
fn
]
of
Object
.
entries
(
functions
)
)
{
await
consoleFront
.
evaluateJSAsync
(
this
.
{
key
}
=
{
fn
}
)
;
}
}
async
function
importScript
(
script
)
{
await
consoleFront
.
evaluateJSAsync
(
script
)
;
}
async
function
destroy
(
)
{
const
closePromise
=
process
.
_dbgProcess
.
wait
(
)
;
consoleFront
.
evaluateJSAsync
(
"
gToolbox
.
destroy
(
)
"
)
;
const
{
exitCode
}
=
await
closePromise
;
ok
(
true
"
Browser
toolbox
process
closed
"
)
;
is
(
exitCode
0
"
The
remote
debugger
process
died
cleanly
"
)
;
is
(
BrowserToolboxProcess
.
getBrowserToolboxSessionState
(
)
false
"
No
session
state
after
closing
"
)
;
await
client
.
close
(
)
;
}
return
{
importFunctions
importScript
spawn
destroy
}
;
}
