"
use
strict
"
;
const
{
DevToolsClient
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
devtools
-
client
.
js
"
)
;
const
{
DevToolsServer
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
devtools
-
server
.
js
"
)
;
const
{
createCommandsDictionary
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
commands
/
index
.
js
"
)
;
const
TEST_URL
=
data
:
text
/
html
;
charset
=
utf
-
8
<
div
id
=
"
test
"
>
<
/
div
>
;
add_task
(
async
function
(
)
{
const
tab
=
await
addTab
(
TEST_URL
)
;
const
client
=
await
setupDebuggerClient
(
)
;
const
mainRoot
=
client
.
mainRoot
;
const
tabDescriptors
=
await
mainRoot
.
listTabs
(
)
;
const
concurrentCommands
=
[
]
;
for
(
const
descriptor
of
tabDescriptors
)
{
concurrentCommands
.
push
(
(
async
(
)
=
>
{
const
commands
=
await
createCommandsDictionary
(
descriptor
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
}
)
(
)
)
;
}
info
(
"
Instantiate
all
tab
'
s
commands
and
initialize
their
TargetCommand
"
)
;
await
Promise
.
all
(
concurrentCommands
)
;
await
testGetTargetWithConcurrentCalls
(
tabDescriptors
tabTarget
=
>
{
return
!
!
tabTarget
.
targetForm
?
.
traits
;
}
)
;
await
client
.
close
(
)
;
await
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
(
)
{
const
client
=
await
setupDebuggerClient
(
)
;
const
mainRoot
=
client
.
mainRoot
;
const
processes
=
await
mainRoot
.
listProcesses
(
)
;
await
testGetTargetWithConcurrentCalls
(
processes
(
)
=
>
{
return
true
;
}
)
;
await
client
.
close
(
)
;
}
)
;
add_task
(
async
function
(
)
{
const
client
=
await
setupDebuggerClient
(
)
;
const
mainRoot
=
client
.
mainRoot
;
const
{
workers
}
=
await
mainRoot
.
listWorkers
(
)
;
ok
(
!
!
workers
.
length
"
list
workers
returned
a
non
-
empty
list
of
workers
"
)
;
for
(
const
workerDescriptorFront
of
workers
)
{
let
targetFront
;
try
{
targetFront
=
await
workerDescriptorFront
.
getTarget
(
)
;
}
catch
(
e
)
{
if
(
e
.
message
.
includes
(
"
nsIWorkerDebugger
.
initialize
"
)
|
|
workerDescriptorFront
.
isDestroyed
(
)
|
|
!
workerDescriptorFront
.
name
)
{
info
(
"
Failed
to
connect
to
"
+
workerDescriptorFront
.
url
)
;
continue
;
}
throw
e
;
}
if
(
!
workerDescriptorFront
.
name
)
{
info
(
"
Failed
to
connect
to
"
+
workerDescriptorFront
.
url
)
;
continue
;
}
is
(
workerDescriptorFront
targetFront
"
For
now
worker
descriptors
and
targets
are
the
same
object
(
see
bug
1667404
)
"
)
;
ok
(
workerDescriptorFront
.
name
.
includes
(
"
.
js
"
)
|
|
workerDescriptorFront
.
name
.
includes
(
"
.
mjs
"
)
worker
descriptor
front
holds
the
worker
file
name
(
{
workerDescriptorFront
.
name
}
)
)
;
is
(
workerDescriptorFront
.
isWorkerDescriptor
true
"
isWorkerDescriptor
is
true
"
)
;
}
await
client
.
close
(
)
;
}
)
;
async
function
setupDebuggerClient
(
)
{
DevToolsServer
.
init
(
)
;
DevToolsServer
.
allowChromeProcess
=
true
;
if
(
!
DevToolsServer
.
createRootActor
)
{
DevToolsServer
.
registerAllActors
(
)
;
}
const
transport
=
DevToolsServer
.
connectPipe
(
)
;
const
client
=
new
DevToolsClient
(
transport
)
;
await
client
.
connect
(
)
;
return
client
;
}
async
function
testGetTargetWithConcurrentCalls
(
descriptors
isTargetAttached
)
{
await
Promise
.
all
(
descriptors
.
map
(
async
descriptor
=
>
{
const
promises
=
[
]
;
const
concurrentCalls
=
10
;
for
(
let
i
=
0
;
i
<
concurrentCalls
;
i
+
+
)
{
const
targetPromise
=
descriptor
.
getTarget
(
)
;
if
(
i
%
2
=
=
0
)
{
await
wait
(
0
)
;
}
promises
.
push
(
targetPromise
.
then
(
target
=
>
{
ok
(
isTargetAttached
(
target
)
"
The
target
is
attached
"
)
;
return
target
;
}
)
)
;
}
const
targets
=
await
Promise
.
all
(
promises
)
;
for
(
let
i
=
1
;
i
<
concurrentCalls
;
i
+
+
)
{
is
(
targets
[
0
]
targets
[
i
]
"
All
the
targets
returned
by
concurrent
calls
to
getTarget
are
the
same
"
)
;
}
}
)
)
;
}
