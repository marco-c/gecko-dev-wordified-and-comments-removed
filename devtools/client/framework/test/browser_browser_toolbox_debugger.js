const
{
PromiseTestUtils
}
=
scopedCuImport
(
"
resource
:
/
/
testing
-
common
/
PromiseTestUtils
.
jsm
"
)
;
PromiseTestUtils
.
whitelistRejectionsGlobally
(
/
File
closed
/
)
;
requestLongerTimeout
(
4
)
;
const
{
fetch
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
debuggerHeadURL
=
CHROME_URL_ROOT
+
"
.
.
/
.
.
/
debugger
/
new
/
test
/
mochitest
/
head
.
js
"
;
const
helpersURL
=
CHROME_URL_ROOT
+
"
.
.
/
.
.
/
debugger
/
new
/
test
/
mochitest
/
helpers
.
js
"
;
const
helpersContextURL
=
CHROME_URL_ROOT
+
"
.
.
/
.
.
/
debugger
/
new
/
test
/
mochitest
/
helpers
/
context
.
js
"
;
const
testScriptURL
=
CHROME_URL_ROOT
+
"
test_browser_toolbox_debugger
.
js
"
;
add_task
(
async
function
runTest
(
)
{
await
new
Promise
(
done
=
>
{
const
options
=
{
"
set
"
:
[
[
"
devtools
.
debugger
.
prompt
-
connection
"
false
]
[
"
devtools
.
debugger
.
remote
-
enabled
"
true
]
[
"
devtools
.
chrome
.
enabled
"
true
]
[
"
devtools
.
browser
-
toolbox
.
allow
-
unsafe
-
script
"
true
]
[
"
devtools
.
debugger
.
remote
-
timeout
"
120000
]
]
}
;
SpecialPowers
.
pushPrefEnv
(
options
done
)
;
}
)
;
const
s
=
Cu
.
Sandbox
(
"
http
:
/
/
mozilla
.
org
"
)
;
const
id
=
new
Date
(
)
.
getTime
(
)
;
const
testUrl
=
http
:
/
/
mozilla
.
org
/
browser
-
toolbox
-
test
-
{
id
}
.
js
;
Cu
.
evalInSandbox
(
"
(
"
+
function
(
)
{
this
.
plop
=
function
plop
(
)
{
return
1
;
}
;
}
+
"
)
.
call
(
this
)
"
s
"
1
.
8
"
testUrl
0
)
;
const
interval
=
setInterval
(
s
.
plop
1000
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
testHead
=
(
function
(
)
{
const
info
=
msg
=
>
dump
(
msg
+
"
\
n
"
)
;
const
is
=
(
a
b
description
)
=
>
{
let
msg
=
"
'
"
+
JSON
.
stringify
(
a
)
+
"
'
is
equal
to
'
"
+
JSON
.
stringify
(
b
)
+
"
'
"
;
if
(
description
)
{
msg
+
=
"
-
"
+
description
;
}
if
(
a
!
=
=
b
)
{
msg
=
"
FAILURE
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
throw
new
Error
(
msg
)
;
}
else
{
msg
=
"
SUCCESS
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
}
}
;
const
ok
=
(
a
description
)
=
>
{
let
msg
=
"
'
"
+
JSON
.
stringify
(
a
)
+
"
'
is
true
"
;
if
(
description
)
{
msg
+
=
"
-
"
+
description
;
}
if
(
!
a
)
{
msg
=
"
FAILURE
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
throw
new
Error
(
msg
)
;
}
else
{
msg
=
"
SUCCESS
:
"
+
msg
;
dump
(
msg
+
"
\
n
"
)
;
}
}
;
const
registerCleanupFunction
=
(
)
=
>
{
}
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
}
)
.
toSource
(
)
.
replace
(
/
^
\
(
function
\
(
\
)
\
{
|
\
}
\
)
/
g
"
"
)
;
let
{
content
:
debuggerHead
}
=
await
fetch
(
debuggerHeadURL
)
;
const
{
content
:
debuggerHelpers
}
=
await
fetch
(
helpersURL
)
;
const
{
content
:
debuggerContextHelpers
}
=
await
fetch
(
helpersContextURL
)
;
debuggerHead
=
debuggerHead
+
debuggerContextHelpers
+
debuggerHelpers
;
debuggerHead
=
debuggerHead
.
replace
(
/
Services
.
scriptloader
.
loadSubScript
[
^
\
)
]
*
\
)
;
/
g
"
"
)
;
const
testScript
=
(
await
fetch
(
testScriptURL
)
)
.
content
;
const
source
=
"
try
{
let
testUrl
=
\
"
"
+
testUrl
+
"
\
"
;
"
+
testHead
+
debuggerHead
+
testScript
+
"
}
catch
(
e
)
{
"
+
"
dump
(
'
Exception
:
'
+
e
+
'
at
'
+
e
.
fileName
+
'
:
'
+
"
+
"
e
.
lineNumber
+
'
\
\
nStack
:
'
+
e
.
stack
+
'
\
\
n
'
)
;
"
+
"
}
"
;
env
.
set
(
"
MOZ_TOOLBOX_TEST_SCRIPT
"
source
)
;
registerCleanupFunction
(
(
)
=
>
{
env
.
set
(
"
MOZ_TOOLBOX_TEST_SCRIPT
"
"
"
)
;
}
)
;
const
{
BrowserToolboxProcess
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
)
;
let
closePromise
;
await
new
Promise
(
onRun
=
>
{
closePromise
=
new
Promise
(
onClose
=
>
{
info
(
"
Opening
the
browser
toolbox
\
n
"
)
;
BrowserToolboxProcess
.
init
(
onClose
onRun
)
;
}
)
;
}
)
;
ok
(
true
"
Browser
toolbox
started
\
n
"
)
;
await
closePromise
;
ok
(
true
"
Browser
toolbox
process
just
closed
"
)
;
clearInterval
(
interval
)
;
}
)
;
