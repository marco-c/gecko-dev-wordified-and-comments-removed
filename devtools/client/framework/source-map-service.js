"
use
strict
"
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
LocationStore
serialize
deserialize
}
=
require
(
"
.
/
location
-
store
"
)
;
function
SourceMapService
(
target
)
{
this
.
_target
=
target
;
this
.
_locationStore
=
new
LocationStore
(
)
;
this
.
_isNotSourceMapped
=
new
Map
(
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
_onSourceUpdated
=
this
.
_onSourceUpdated
.
bind
(
this
)
;
this
.
_resolveLocation
=
this
.
_resolveLocation
.
bind
(
this
)
;
this
.
_resolveAndUpdate
=
this
.
_resolveAndUpdate
.
bind
(
this
)
;
this
.
subscribe
=
this
.
subscribe
.
bind
(
this
)
;
this
.
unsubscribe
=
this
.
unsubscribe
.
bind
(
this
)
;
this
.
reset
=
this
.
reset
.
bind
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
target
.
on
(
"
source
-
updated
"
this
.
_onSourceUpdated
)
;
target
.
on
(
"
navigate
"
this
.
reset
)
;
target
.
on
(
"
will
-
navigate
"
this
.
reset
)
;
}
SourceMapService
.
prototype
.
reset
=
function
(
)
{
if
(
!
this
.
_locationStore
)
{
return
;
}
this
.
_locationStore
.
clear
(
)
;
this
.
_isNotSourceMapped
.
clear
(
)
;
}
;
SourceMapService
.
prototype
.
destroy
=
function
(
)
{
this
.
reset
(
)
;
this
.
_target
.
off
(
"
source
-
updated
"
this
.
_onSourceUpdated
)
;
this
.
_target
.
off
(
"
navigate
"
this
.
reset
)
;
this
.
_target
.
off
(
"
will
-
navigate
"
this
.
reset
)
;
this
.
_target
.
off
(
"
close
"
this
.
destroy
)
;
this
.
_target
=
this
.
_locationStore
=
this
.
_isNotSourceMapped
=
null
;
}
;
SourceMapService
.
prototype
.
subscribe
=
function
(
location
callback
)
{
if
(
!
location
.
url
|
|
!
location
.
line
|
|
this
.
_isNotSourceMapped
.
get
(
location
.
url
)
)
{
return
;
}
this
.
on
(
serialize
(
location
)
callback
)
;
this
.
_locationStore
.
set
(
location
)
;
this
.
_resolveAndUpdate
(
location
)
;
}
;
SourceMapService
.
prototype
.
unsubscribe
=
function
(
location
callback
)
{
this
.
off
(
serialize
(
location
)
callback
)
;
if
(
!
this
.
_locationStore
)
{
return
;
}
this
.
_locationStore
.
clearByURL
(
location
.
url
)
;
}
;
SourceMapService
.
prototype
.
_resolveAndUpdate
=
function
(
location
)
{
this
.
_resolveLocation
(
location
)
.
then
(
resolvedLocation
=
>
{
if
(
resolvedLocation
&
&
!
isSameLocation
(
location
resolvedLocation
)
)
{
this
.
emit
(
serialize
(
location
)
location
resolvedLocation
)
;
}
}
)
;
}
;
SourceMapService
.
prototype
.
_resolveLocation
=
Task
.
async
(
function
*
(
location
)
{
let
resolvedLocation
;
const
cachedLocation
=
this
.
_locationStore
.
get
(
location
)
;
if
(
cachedLocation
)
{
resolvedLocation
=
cachedLocation
;
}
else
{
const
promisedLocation
=
resolveLocation
(
this
.
_target
location
)
;
if
(
promisedLocation
)
{
this
.
_locationStore
.
set
(
location
promisedLocation
)
;
resolvedLocation
=
promisedLocation
;
}
}
return
resolvedLocation
;
}
)
;
SourceMapService
.
prototype
.
_onSourceUpdated
=
function
(
_
sourceEvent
)
{
let
{
type
source
}
=
sourceEvent
;
const
isNotSourceMapped
=
!
(
source
.
sourceMapURL
|
|
source
.
isSourceMapped
|
|
source
.
isPrettyPrinted
)
;
if
(
type
=
=
=
"
newSource
"
&
&
isNotSourceMapped
)
{
this
.
_isNotSourceMapped
.
set
(
source
.
url
true
)
;
return
;
}
let
sourceUrl
=
null
;
if
(
source
.
generatedUrl
&
&
source
.
isSourceMapped
)
{
sourceUrl
=
source
.
generatedUrl
;
}
else
if
(
source
.
url
&
&
source
.
isPrettyPrinted
)
{
sourceUrl
=
source
.
url
;
}
const
locationsToResolve
=
this
.
_locationStore
.
getByURL
(
sourceUrl
)
;
if
(
locationsToResolve
.
length
)
{
this
.
_locationStore
.
clearByURL
(
sourceUrl
)
;
for
(
let
location
of
locationsToResolve
)
{
this
.
_resolveAndUpdate
(
deserialize
(
location
)
)
;
}
}
}
;
exports
.
SourceMapService
=
SourceMapService
;
function
resolveLocation
(
target
location
)
{
return
Task
.
spawn
(
function
*
(
)
{
let
newLocation
=
yield
target
.
resolveLocation
(
{
url
:
location
.
url
line
:
location
.
line
column
:
location
.
column
|
|
Infinity
}
)
;
if
(
newLocation
.
error
)
{
return
null
;
}
return
newLocation
;
}
)
;
}
function
isSameLocation
(
location
resolvedLocation
)
{
return
location
.
url
=
=
=
resolvedLocation
.
url
&
&
location
.
line
=
=
=
resolvedLocation
.
line
&
&
location
.
column
=
=
=
resolvedLocation
.
column
;
}
