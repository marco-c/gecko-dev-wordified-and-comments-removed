"
use
strict
"
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
div
button
}
=
dom
;
const
{
openWebLink
}
=
require
(
"
devtools
/
client
/
shared
/
link
"
)
;
const
Menu
=
require
(
"
devtools
/
client
/
framework
/
menu
"
)
;
const
MenuItem
=
require
(
"
devtools
/
client
/
framework
/
menu
-
item
"
)
;
const
ToolboxTabs
=
createFactory
(
require
(
"
devtools
/
client
/
framework
/
components
/
ToolboxTabs
"
)
)
;
class
ToolboxToolbar
extends
Component
{
static
get
propTypes
(
)
{
return
{
focusedButton
:
PropTypes
.
string
toolboxButtons
:
PropTypes
.
array
currentToolId
:
PropTypes
.
string
highlightedTools
:
PropTypes
.
instanceOf
(
Set
)
panelDefinitions
:
PropTypes
.
array
hostTypes
:
PropTypes
.
arrayOf
(
PropTypes
.
shape
(
{
position
:
PropTypes
.
string
.
isRequired
switchHost
:
PropTypes
.
func
.
isRequired
}
)
)
currentHostType
:
PropTypes
.
string
canCloseToolbox
:
PropTypes
.
bool
isSplitConsoleActive
:
PropTypes
.
bool
disableAutohide
:
PropTypes
.
bool
selectTool
:
PropTypes
.
func
toggleOptions
:
PropTypes
.
func
.
isRequired
toggleSplitConsole
:
PropTypes
.
func
toggleNoAutohide
:
PropTypes
.
func
closeToolbox
:
PropTypes
.
func
focusButton
:
PropTypes
.
func
canRender
:
PropTypes
.
bool
L10N
:
PropTypes
.
object
toolbox
:
PropTypes
.
object
onTabsOrderUpdated
:
PropTypes
.
func
.
isRequired
visibleToolboxButtonCount
:
PropTypes
.
number
}
;
}
render
(
)
{
const
classnames
=
[
"
devtools
-
tabbar
"
]
;
const
startButtons
=
renderToolboxButtonsStart
(
this
.
props
)
;
const
endButtons
=
renderToolboxButtonsEnd
(
this
.
props
)
;
if
(
!
startButtons
)
{
classnames
.
push
(
"
devtools
-
tabbar
-
has
-
start
"
)
;
}
if
(
!
endButtons
)
{
classnames
.
push
(
"
devtools
-
tabbar
-
has
-
end
"
)
;
}
return
this
.
props
.
canRender
?
(
div
(
{
className
:
classnames
.
join
(
"
"
)
}
startButtons
ToolboxTabs
(
this
.
props
)
endButtons
renderToolboxControls
(
this
.
props
)
)
)
:
div
(
{
className
:
classnames
.
join
(
"
"
)
}
)
;
}
}
module
.
exports
=
ToolboxToolbar
;
function
renderToolboxButtonsStart
(
props
)
{
return
renderToolboxButtons
(
props
true
)
;
}
function
renderToolboxButtonsEnd
(
props
)
{
return
renderToolboxButtons
(
props
false
)
;
}
function
renderToolboxButtons
(
{
focusedButton
toolboxButtons
focusButton
}
isStart
)
{
const
visibleButtons
=
toolboxButtons
.
filter
(
command
=
>
{
const
{
isVisible
isInStartContainer
}
=
command
;
return
isVisible
&
&
(
isStart
?
isInStartContainer
:
!
isInStartContainer
)
;
}
)
;
if
(
visibleButtons
.
length
=
=
=
0
)
{
return
null
;
}
const
rdmIndex
=
visibleButtons
.
findIndex
(
button
=
>
button
.
id
=
=
=
"
command
-
button
-
responsive
"
)
;
if
(
rdmIndex
!
=
=
-
1
&
&
rdmIndex
!
=
=
visibleButtons
.
length
-
1
)
{
const
rdm
=
visibleButtons
.
splice
(
rdmIndex
1
)
[
0
]
;
visibleButtons
.
push
(
rdm
)
;
}
const
renderedButtons
=
visibleButtons
.
map
(
command
=
>
{
const
{
id
description
disabled
onClick
isChecked
className
:
buttonClass
onKeyDown
}
=
command
;
return
button
(
{
id
title
:
description
disabled
className
:
(
"
command
-
button
devtools
-
button
"
+
buttonClass
+
(
isChecked
?
"
checked
"
:
"
"
)
)
onClick
:
(
event
)
=
>
{
onClick
(
event
)
;
focusButton
(
id
)
;
}
onFocus
:
(
)
=
>
focusButton
(
id
)
tabIndex
:
id
=
=
=
focusedButton
?
"
0
"
:
"
-
1
"
onKeyDown
:
(
event
)
=
>
{
onKeyDown
(
event
)
;
}
}
)
;
}
)
;
const
children
=
renderedButtons
;
if
(
renderedButtons
.
length
)
{
if
(
isStart
)
{
children
.
push
(
renderSeparator
(
)
)
;
}
else
if
(
rdmIndex
!
=
=
-
1
&
&
visibleButtons
.
length
>
1
)
{
children
.
splice
(
children
.
length
-
1
0
renderSeparator
(
)
)
;
}
}
return
div
(
{
id
:
toolbox
-
buttons
-
{
isStart
?
"
start
"
:
"
end
"
}
}
.
.
.
children
)
;
}
function
renderSeparator
(
)
{
return
div
(
{
className
:
"
devtools
-
separator
"
}
)
;
}
function
renderToolboxControls
(
props
)
{
const
{
focusedButton
closeToolbox
hostTypes
focusButton
L10N
areDockOptionsEnabled
canCloseToolbox
}
=
props
;
const
meatballMenuButtonId
=
"
toolbox
-
meatball
-
menu
-
button
"
;
const
meatballMenuButton
=
button
(
{
id
:
meatballMenuButtonId
onFocus
:
(
)
=
>
focusButton
(
meatballMenuButtonId
)
className
:
"
devtools
-
button
"
title
:
L10N
.
getStr
(
"
toolbox
.
meatballMenu
.
button
.
tooltip
"
)
onClick
:
evt
=
>
{
showMeatballMenu
(
evt
.
target
{
.
.
.
props
hostTypes
:
areDockOptionsEnabled
?
hostTypes
:
[
]
}
)
;
}
tabIndex
:
focusedButton
=
=
=
meatballMenuButtonId
?
"
0
"
:
"
-
1
"
}
)
;
const
closeButtonId
=
"
toolbox
-
close
"
;
const
closeButton
=
canCloseToolbox
?
button
(
{
id
:
closeButtonId
onFocus
:
(
)
=
>
focusButton
(
closeButtonId
)
className
:
"
devtools
-
button
"
title
:
L10N
.
getStr
(
"
toolbox
.
closebutton
.
tooltip
"
)
onClick
:
(
)
=
>
{
closeToolbox
(
)
;
}
tabIndex
:
focusedButton
=
=
=
"
toolbox
-
close
"
?
"
0
"
:
"
-
1
"
}
)
:
null
;
return
div
(
{
id
:
"
toolbox
-
controls
"
}
meatballMenuButton
closeButton
)
;
}
function
showMeatballMenu
(
menuButton
{
currentToolId
hostTypes
currentHostType
isSplitConsoleActive
disableAutohide
toggleOptions
toggleSplitConsole
toggleNoAutohide
L10N
toolbox
}
)
{
const
menu
=
new
Menu
(
{
id
:
"
toolbox
-
meatball
-
menu
"
}
)
;
for
(
const
hostType
of
hostTypes
)
{
const
l10nkey
=
hostType
.
position
=
=
=
"
window
"
?
"
separateWindow
"
:
hostType
.
position
;
menu
.
append
(
new
MenuItem
(
{
id
:
toolbox
-
meatball
-
menu
-
dock
-
{
hostType
.
position
}
label
:
L10N
.
getStr
(
toolbox
.
meatballMenu
.
dock
.
{
l10nkey
}
.
label
)
click
:
(
)
=
>
hostType
.
switchHost
(
)
type
:
"
checkbox
"
checked
:
hostType
.
position
=
=
=
currentHostType
}
)
)
;
}
if
(
menu
.
items
.
length
)
{
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
}
if
(
currentToolId
!
=
=
"
webconsole
"
)
{
menu
.
append
(
new
MenuItem
(
{
id
:
"
toolbox
-
meatball
-
menu
-
splitconsole
"
label
:
L10N
.
getStr
(
toolbox
.
meatballMenu
.
{
isSplitConsoleActive
?
"
hideconsole
"
:
"
splitconsole
"
}
.
label
)
accelerator
:
"
Esc
"
click
:
toggleSplitConsole
}
)
)
;
}
if
(
typeof
disableAutohide
!
=
=
"
undefined
"
)
{
menu
.
append
(
new
MenuItem
(
{
id
:
"
toolbox
-
meatball
-
menu
-
noautohide
"
label
:
L10N
.
getStr
(
"
toolbox
.
meatballMenu
.
noautohide
.
label
"
)
type
:
"
checkbox
"
checked
:
disableAutohide
click
:
toggleNoAutohide
}
)
)
;
}
menu
.
append
(
new
MenuItem
(
{
id
:
"
toolbox
-
meatball
-
menu
-
settings
"
label
:
L10N
.
getStr
(
"
toolbox
.
meatballMenu
.
settings
.
label
"
)
accelerator
:
L10N
.
getStr
(
"
toolbox
.
help
.
key
"
)
click
:
(
)
=
>
toggleOptions
(
)
}
)
)
;
if
(
menu
.
items
.
length
)
{
menu
.
append
(
new
MenuItem
(
{
type
:
"
separator
"
}
)
)
;
}
menu
.
append
(
new
MenuItem
(
{
id
:
"
toolbox
-
meatball
-
menu
-
documentation
"
label
:
L10N
.
getStr
(
"
toolbox
.
meatballMenu
.
documentation
.
label
"
)
click
:
(
)
=
>
{
openWebLink
(
"
https
:
/
/
developer
.
mozilla
.
org
/
docs
/
Tools
?
utm_source
=
devtools
&
utm_medium
=
tabbar
-
menu
"
)
;
}
}
)
)
;
menu
.
append
(
new
MenuItem
(
{
id
:
"
toolbox
-
meatball
-
menu
-
community
"
label
:
L10N
.
getStr
(
"
toolbox
.
meatballMenu
.
community
.
label
"
)
click
:
(
)
=
>
{
openWebLink
(
"
https
:
/
/
discourse
.
mozilla
.
org
/
c
/
devtools
?
utm_source
=
devtools
&
utm_medium
=
tabbar
-
menu
"
)
;
}
}
)
)
;
const
rect
=
menuButton
.
getBoundingClientRect
(
)
;
const
screenX
=
menuButton
.
ownerDocument
.
defaultView
.
mozInnerScreenX
;
const
screenY
=
menuButton
.
ownerDocument
.
defaultView
.
mozInnerScreenY
;
menu
.
popupWithZoom
(
rect
.
left
+
screenX
rect
.
bottom
+
screenY
toolbox
)
;
}
