"
use
strict
"
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
gDevToolsBrowser
"
"
resource
:
/
/
devtools
/
client
/
framework
/
devtools
-
browser
.
js
"
true
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
PrivateBrowsingUtils
:
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
sys
.
mjs
"
}
)
;
const
MIN_PAGE_SIZE
=
25
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
class
BaseInBrowserHost
{
constructor
(
hostTab
type
)
{
this
.
hostTab
=
hostTab
;
this
.
type
=
type
;
this
.
_gBrowser
=
this
.
hostTab
.
ownerGlobal
.
gBrowser
;
this
.
_browserContainer
=
this
.
_gBrowser
.
getBrowserContainer
(
this
.
hostTab
.
linkedBrowser
)
;
this
.
frame
=
null
;
Services
.
obs
.
addObserver
(
this
"
browsing
-
context
-
active
-
change
"
)
;
}
_createFrame
(
)
{
this
.
frame
=
createDevToolsFrame
(
this
.
hostTab
.
ownerDocument
this
.
type
=
=
"
bottom
"
?
"
devtools
-
toolbox
-
bottom
-
iframe
"
:
"
devtools
-
toolbox
-
side
-
iframe
"
)
;
}
observe
(
subject
topic
)
{
if
(
topic
!
=
"
browsing
-
context
-
active
-
change
"
)
{
return
;
}
if
(
this
.
hostTab
.
linkedBrowser
?
.
browsingContext
!
=
subject
)
{
return
;
}
if
(
!
this
.
frame
)
{
return
;
}
this
.
frame
.
docShellIsActive
=
subject
.
isActive
;
}
raise
(
)
{
focusTab
(
this
.
hostTab
)
;
}
setTitle
(
)
{
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
"
browsing
-
context
-
active
-
change
"
)
;
this
.
_gBrowser
=
null
;
this
.
_browserContainer
=
null
;
}
}
class
BottomHost
extends
BaseInBrowserHost
{
constructor
(
hostTab
)
{
super
(
hostTab
"
bottom
"
)
;
this
.
heightPref
=
"
devtools
.
toolbox
.
footer
.
height
"
;
}
#
splitter
;
#
destroyed
;
async
create
(
)
{
await
gDevToolsBrowser
.
loadBrowserStyleSheet
(
this
.
hostTab
.
ownerGlobal
)
;
const
{
ownerDocument
}
=
this
.
hostTab
;
this
.
#
splitter
=
ownerDocument
.
createXULElement
(
"
splitter
"
)
;
this
.
#
splitter
.
setAttribute
(
"
class
"
"
devtools
-
horizontal
-
splitter
"
)
;
this
.
#
splitter
.
setAttribute
(
"
resizebefore
"
"
none
"
)
;
this
.
#
splitter
.
setAttribute
(
"
resizeafter
"
"
sibling
"
)
;
this
.
_createFrame
(
)
;
this
.
frame
.
style
.
height
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
this
.
heightPref
)
this
.
_browserContainer
.
clientHeight
-
MIN_PAGE_SIZE
)
+
"
px
"
;
this
.
_browserContainer
.
appendChild
(
this
.
#
splitter
)
;
this
.
_browserContainer
.
appendChild
(
this
.
frame
)
;
this
.
frame
.
docShellIsActive
=
true
;
focusTab
(
this
.
hostTab
)
;
return
this
.
frame
;
}
destroy
(
)
{
if
(
!
this
.
#
destroyed
)
{
this
.
#
destroyed
=
true
;
const
height
=
parseInt
(
this
.
frame
.
style
.
height
10
)
;
if
(
!
isNaN
(
height
)
)
{
Services
.
prefs
.
setIntPref
(
this
.
heightPref
height
)
;
}
this
.
_browserContainer
.
removeChild
(
this
.
#
splitter
)
;
this
.
_browserContainer
.
removeChild
(
this
.
frame
)
;
this
.
frame
=
null
;
this
.
#
splitter
=
null
;
super
.
destroy
(
)
;
}
return
Promise
.
resolve
(
null
)
;
}
}
class
SidebarHost
extends
BaseInBrowserHost
{
constructor
(
hostTab
type
)
{
super
(
hostTab
type
)
;
this
.
widthPref
=
"
devtools
.
toolbox
.
sidebar
.
width
"
;
}
#
splitter
;
#
browserPanel
;
#
destroyed
;
async
create
(
)
{
await
gDevToolsBrowser
.
loadBrowserStyleSheet
(
this
.
hostTab
.
ownerGlobal
)
;
this
.
#
browserPanel
=
this
.
_gBrowser
.
getPanel
(
this
.
hostTab
.
linkedBrowser
)
;
const
{
ownerDocument
}
=
this
.
hostTab
;
this
.
#
splitter
=
ownerDocument
.
createXULElement
(
"
splitter
"
)
;
this
.
#
splitter
.
setAttribute
(
"
class
"
"
devtools
-
side
-
splitter
"
)
;
this
.
_createFrame
(
)
;
this
.
frame
.
style
.
width
=
Math
.
min
(
Services
.
prefs
.
getIntPref
(
this
.
widthPref
)
this
.
#
browserPanel
.
clientWidth
-
MIN_PAGE_SIZE
)
+
"
px
"
;
const
topWindow
=
this
.
hostTab
.
ownerGlobal
;
const
topDoc
=
topWindow
.
document
.
documentElement
;
const
isLTR
=
topWindow
.
getComputedStyle
(
topDoc
)
.
direction
=
=
=
"
ltr
"
;
this
.
#
splitter
.
setAttribute
(
"
resizebefore
"
"
none
"
)
;
this
.
#
splitter
.
setAttribute
(
"
resizeafter
"
"
none
"
)
;
if
(
(
isLTR
&
&
this
.
type
=
=
"
right
"
)
|
|
(
!
isLTR
&
&
this
.
type
=
=
"
left
"
)
)
{
this
.
#
splitter
.
setAttribute
(
"
resizeafter
"
"
sibling
"
)
;
this
.
#
browserPanel
.
appendChild
(
this
.
#
splitter
)
;
this
.
#
browserPanel
.
appendChild
(
this
.
frame
)
;
}
else
{
this
.
#
splitter
.
setAttribute
(
"
resizebefore
"
"
sibling
"
)
;
this
.
#
browserPanel
.
insertBefore
(
this
.
frame
this
.
_browserContainer
)
;
this
.
#
browserPanel
.
insertBefore
(
this
.
#
splitter
this
.
_browserContainer
)
;
}
this
.
frame
.
docShellIsActive
=
true
;
focusTab
(
this
.
hostTab
)
;
return
this
.
frame
;
}
destroy
(
)
{
if
(
!
this
.
#
destroyed
)
{
this
.
#
destroyed
=
true
;
const
width
=
parseInt
(
this
.
frame
.
style
.
width
10
)
;
if
(
!
isNaN
(
width
)
)
{
Services
.
prefs
.
setIntPref
(
this
.
widthPref
width
)
;
}
this
.
#
browserPanel
.
removeChild
(
this
.
#
splitter
)
;
this
.
#
browserPanel
.
removeChild
(
this
.
frame
)
;
this
.
#
browserPanel
=
null
;
this
.
#
splitter
=
null
;
this
.
frame
=
null
;
super
.
destroy
(
)
;
}
return
Promise
.
resolve
(
null
)
;
}
}
class
LeftHost
extends
SidebarHost
{
constructor
(
hostTab
)
{
super
(
hostTab
"
left
"
)
;
}
}
class
RightHost
extends
SidebarHost
{
constructor
(
hostTab
)
{
super
(
hostTab
"
right
"
)
;
}
}
class
WindowHost
extends
EventEmitter
{
constructor
(
hostTab
options
)
{
super
(
)
;
this
.
_boundUnload
=
this
.
_boundUnload
.
bind
(
this
)
;
this
.
hostTab
=
hostTab
;
this
.
options
=
options
;
}
type
=
"
window
"
;
WINDOW_URL
=
"
chrome
:
/
/
devtools
/
content
/
framework
/
toolbox
-
window
.
xhtml
"
;
create
(
)
{
return
new
Promise
(
resolve
=
>
{
let
flags
=
"
chrome
centerscreen
resizable
dialog
=
no
"
;
const
owner
=
this
.
hostTab
?
.
ownerGlobal
;
if
(
owner
&
&
lazy
.
PrivateBrowsingUtils
.
isWindowPrivate
(
owner
)
)
{
flags
+
=
"
private
"
;
}
if
(
this
.
hostTab
&
&
!
this
.
hostTab
.
ownerGlobal
.
gFissionBrowser
)
{
flags
+
=
"
non
-
fission
"
;
}
if
(
this
.
options
?
.
alwaysOnTop
)
{
flags
+
=
"
alwaysontop
"
;
}
const
win
=
Services
.
ww
.
openWindow
(
null
this
.
WINDOW_URL
"
_blank
"
flags
null
)
;
const
frameLoad
=
(
)
=
>
{
win
.
removeEventListener
(
"
load
"
frameLoad
true
)
;
win
.
focus
(
)
;
this
.
frame
=
createDevToolsFrame
(
win
.
document
"
devtools
-
toolbox
-
window
-
iframe
"
)
;
win
.
document
.
getElementById
(
"
devtools
-
toolbox
-
window
"
)
.
appendChild
(
this
.
frame
)
;
this
.
frame
.
docShellIsActive
=
true
;
this
.
frame
.
setAttribute
(
"
forceOwnRefreshDriver
"
"
"
)
;
resolve
(
this
.
frame
)
;
}
;
win
.
addEventListener
(
"
load
"
frameLoad
true
)
;
win
.
addEventListener
(
"
unload
"
this
.
_boundUnload
)
;
this
.
_window
=
win
;
}
)
;
}
_boundUnload
(
event
)
{
if
(
event
.
target
.
location
!
=
this
.
WINDOW_URL
)
{
return
;
}
this
.
_window
.
removeEventListener
(
"
unload
"
this
.
_boundUnload
)
;
this
.
emit
(
"
window
-
closed
"
)
;
}
raise
(
)
{
this
.
_window
.
focus
(
)
;
}
setTitle
(
title
)
{
this
.
_window
.
document
.
title
=
title
;
}
destroy
(
)
{
if
(
!
this
.
_destroyed
)
{
this
.
_destroyed
=
true
;
this
.
_window
.
removeEventListener
(
"
unload
"
this
.
_boundUnload
)
;
this
.
_window
.
close
(
)
;
}
return
Promise
.
resolve
(
null
)
;
}
}
class
BrowserToolboxHost
extends
EventEmitter
{
constructor
(
hostTab
options
)
{
super
(
)
;
this
.
doc
=
options
.
doc
;
}
type
=
"
browsertoolbox
"
;
async
create
(
)
{
this
.
frame
=
createDevToolsFrame
(
this
.
doc
"
devtools
-
toolbox
-
browsertoolbox
-
iframe
"
)
;
this
.
doc
.
body
.
appendChild
(
this
.
frame
)
;
this
.
frame
.
docShellIsActive
=
true
;
return
this
.
frame
;
}
raise
(
)
{
this
.
doc
.
defaultView
.
focus
(
)
;
}
setTitle
(
title
)
{
this
.
doc
.
title
=
title
;
}
destroy
(
)
{
return
Promise
.
resolve
(
null
)
;
}
}
class
PageHost
{
constructor
(
hostTab
options
)
{
this
.
frame
=
options
.
customIframe
;
}
type
=
"
page
"
;
create
(
)
{
return
Promise
.
resolve
(
this
.
frame
)
;
}
raise
(
)
{
focusTab
(
this
.
frame
.
ownerGlobal
.
gBrowser
.
getTabForBrowser
(
this
.
frame
)
)
;
}
setTitle
(
)
{
}
destroy
(
)
{
return
Promise
.
resolve
(
null
)
;
}
}
function
focusTab
(
tab
)
{
const
browserWindow
=
tab
.
ownerGlobal
;
browserWindow
.
focus
(
)
;
browserWindow
.
gBrowser
.
selectedTab
=
tab
;
}
function
createDevToolsFrame
(
doc
className
)
{
const
frame
=
doc
.
createXULElement
(
"
browser
"
)
;
frame
.
setAttribute
(
"
type
"
"
content
"
)
;
frame
.
style
.
flex
=
"
1
auto
"
;
frame
.
className
=
className
;
const
inXULDocument
=
doc
.
documentElement
.
namespaceURI
=
=
=
XUL_NS
;
if
(
inXULDocument
)
{
frame
.
tooltip
=
"
aHTMLTooltip
"
;
}
frame
.
setAttribute
(
"
manualactiveness
"
"
true
"
)
;
return
frame
;
}
exports
.
Hosts
=
{
bottom
:
BottomHost
left
:
LeftHost
right
:
RightHost
window
:
WindowHost
browsertoolbox
:
BrowserToolboxHost
page
:
PageHost
}
;
