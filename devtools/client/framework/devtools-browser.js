"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
getTheme
addThemeObserver
removeThemeObserver
}
=
require
(
"
devtools
/
client
/
shared
/
theme
"
)
;
loader
.
lazyRequireGetter
(
this
"
Toolbox
"
"
devtools
/
client
/
framework
/
toolbox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsServer
"
"
devtools
/
server
/
devtools
-
server
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsClient
"
"
devtools
/
client
/
devtools
-
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserMenus
"
"
devtools
/
client
/
framework
/
browser
-
menus
"
)
;
loader
.
lazyRequireGetter
(
this
"
appendStyleSheet
"
"
devtools
/
client
/
shared
/
stylesheet
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
devtools
/
client
/
responsive
/
manager
"
)
;
loader
.
lazyRequireGetter
(
this
"
toggleEnableDevToolsPopup
"
"
devtools
/
client
/
framework
/
enable
-
devtools
-
popup
"
true
)
;
loader
.
lazyImporter
(
this
"
BrowserToolboxLauncher
"
"
resource
:
/
/
devtools
/
client
/
framework
/
browser
-
toolbox
/
Launcher
.
jsm
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
const
BROWSER_STYLESHEET_URL
=
"
chrome
:
/
/
devtools
/
skin
/
devtools
-
browser
.
css
"
;
const
DEVTOOLS_F12_DISABLED_PREF
=
"
devtools
.
experiment
.
f12
.
shortcut_disabled
"
;
var
gDevToolsBrowser
=
(
exports
.
gDevToolsBrowser
=
{
_trackedBrowserWindows
:
new
Set
(
)
_browserStyleSheets
:
new
WeakMap
(
)
async
toggleToolboxCommand
(
gBrowser
startTime
)
{
const
toolbox
=
await
gDevTools
.
getToolboxForTab
(
gBrowser
.
selectedTab
)
;
const
isDocked
=
toolbox
&
&
toolbox
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
;
if
(
isDocked
)
{
gDevTools
.
closeToolboxForTab
(
gBrowser
.
selectedTab
)
;
}
else
{
gDevTools
.
showToolboxForTab
(
gBrowser
.
selectedTab
{
startTime
}
)
;
}
}
updateCommandAvailability
(
win
)
{
const
doc
=
win
.
document
;
function
toggleMenuItem
(
id
isEnabled
)
{
const
cmd
=
doc
.
getElementById
(
id
)
;
cmd
.
hidden
=
!
isEnabled
;
if
(
isEnabled
)
{
cmd
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
cmd
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
const
chromeEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
;
const
devtoolsRemoteEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
)
;
const
remoteEnabled
=
chromeEnabled
&
&
devtoolsRemoteEnabled
;
toggleMenuItem
(
"
menu_browserToolbox
"
remoteEnabled
)
;
toggleMenuItem
(
"
menu_browserContentToolbox
"
remoteEnabled
&
&
win
.
gMultiProcessBrowser
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
policy
.
disabled
"
false
)
)
{
toggleMenuItem
(
"
menu_devToolbox
"
false
)
;
toggleMenuItem
(
"
menu_devtools_remotedebugging
"
false
)
;
toggleMenuItem
(
"
menu_browserToolbox
"
false
)
;
toggleMenuItem
(
"
menu_browserContentToolbox
"
false
)
;
toggleMenuItem
(
"
menu_browserConsole
"
false
)
;
toggleMenuItem
(
"
menu_responsiveUI
"
false
)
;
toggleMenuItem
(
"
menu_eyedropper
"
false
)
;
toggleMenuItem
(
"
extensionsForDevelopers
"
false
)
;
}
}
updateDevtoolsThemeAttribute
(
win
)
{
let
devtoolsTheme
=
getTheme
(
)
;
if
(
devtoolsTheme
!
=
"
dark
"
)
{
devtoolsTheme
=
"
light
"
;
}
win
.
document
.
getElementById
(
"
appcontent
"
)
.
setAttribute
(
"
devtoolstheme
"
devtoolsTheme
)
;
}
observe
(
subject
topic
prefName
)
{
switch
(
topic
)
{
case
"
browser
-
delayed
-
startup
-
finished
"
:
this
.
_registerBrowserWindow
(
subject
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
prefName
.
endsWith
(
"
enabled
"
)
)
{
for
(
const
win
of
this
.
_trackedBrowserWindows
)
{
this
.
updateCommandAvailability
(
win
)
;
}
}
break
;
case
"
quit
-
application
"
:
gDevToolsBrowser
.
destroy
(
{
shuttingDown
:
true
}
)
;
break
;
case
"
devtools
:
loader
:
destroy
"
:
if
(
subject
.
wrappedJSObject
=
=
require
(
"
loader
/
unload
"
)
)
{
gDevToolsBrowser
.
destroy
(
{
shuttingDown
:
false
}
)
;
}
break
;
}
}
_observersRegistered
:
false
async
selectToolCommand
(
win
toolId
startTime
)
{
if
(
gDevToolsBrowser
.
_isAboutDevtoolsToolbox
(
win
)
)
{
const
toolbox
=
gDevToolsBrowser
.
_getAboutDevtoolsToolbox
(
win
)
;
toolbox
.
selectTool
(
toolId
"
key_shortcut
"
)
;
return
;
}
const
tab
=
win
.
gBrowser
.
selectedTab
;
const
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
const
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolbox
&
&
(
toolbox
.
currentToolId
=
=
toolId
|
|
(
toolId
=
=
"
webconsole
"
&
&
toolbox
.
splitConsole
)
)
)
{
toolbox
.
fireCustomKey
(
toolId
)
;
if
(
toolDefinition
.
preventClosingOnKey
|
|
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
if
(
!
toolDefinition
.
preventRaisingOnKey
)
{
toolbox
.
raise
(
)
;
}
}
else
{
toolbox
.
destroy
(
)
;
}
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
else
{
gDevTools
.
showToolboxForTab
(
tab
{
raise
:
!
toolDefinition
.
preventRaisingOnKey
startTime
toolId
}
)
.
then
(
newToolbox
=
>
{
newToolbox
.
fireCustomKey
(
toolId
)
;
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
)
;
}
}
async
onKeyShortcut
(
window
key
startTime
)
{
if
(
gDevToolsBrowser
.
_isAboutDevtoolsToolbox
(
window
)
&
&
(
key
.
id
=
=
=
"
toggleToolbox
"
|
|
key
.
id
=
=
=
"
toggleToolboxF12
"
)
)
{
return
;
}
if
(
key
.
toolId
)
{
await
gDevToolsBrowser
.
selectToolCommand
(
window
key
.
toolId
startTime
)
;
return
;
}
switch
(
key
.
id
)
{
case
"
toggleToolbox
"
:
await
gDevToolsBrowser
.
toggleToolboxCommand
(
window
.
gBrowser
startTime
)
;
break
;
case
"
toggleToolboxF12
"
:
const
isF12Disabled
=
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_F12_DISABLED_PREF
false
)
;
if
(
isF12Disabled
)
{
toggleEnableDevToolsPopup
(
window
.
document
startTime
)
;
}
else
{
await
gDevToolsBrowser
.
toggleToolboxCommand
(
window
.
gBrowser
startTime
)
;
}
break
;
case
"
browserToolbox
"
:
BrowserToolboxLauncher
.
init
(
)
;
break
;
case
"
browserConsole
"
:
const
{
BrowserConsoleManager
}
=
require
(
"
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
"
)
;
BrowserConsoleManager
.
openBrowserConsoleOrFocus
(
)
;
break
;
case
"
responsiveDesignMode
"
:
ResponsiveUIManager
.
toggle
(
window
window
.
gBrowser
.
selectedTab
{
trigger
:
"
shortcut
"
}
)
;
break
;
}
}
openAboutDebugging
(
gBrowser
hash
)
{
const
url
=
"
about
:
debugging
"
+
(
hash
?
"
#
"
+
hash
:
"
"
)
;
gBrowser
.
selectedTab
=
gBrowser
.
addTrustedTab
(
url
)
;
}
async
_getContentProcessDescriptor
(
processId
)
{
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
DevToolsServer
.
allowChromeProcess
=
true
;
const
transport
=
DevToolsServer
.
connectPipe
(
)
;
const
client
=
new
DevToolsClient
(
transport
)
;
await
client
.
connect
(
)
;
return
client
.
mainRoot
.
getProcess
(
processId
)
;
}
async
openContentProcessToolbox
(
gBrowser
)
{
const
{
childCount
}
=
Services
.
ppmm
;
const
mm
=
gBrowser
.
selectedBrowser
.
messageManager
.
processMessageManager
;
let
processId
=
null
;
for
(
let
i
=
1
;
i
<
childCount
;
i
+
+
)
{
const
child
=
Services
.
ppmm
.
getChildAt
(
i
)
;
if
(
child
=
=
mm
)
{
processId
=
mm
.
osPid
;
break
;
}
}
if
(
processId
)
{
try
{
const
descriptor
=
await
this
.
_getContentProcessDescriptor
(
processId
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
descriptor
{
hostType
:
Toolbox
.
HostType
.
WINDOW
hostOptions
:
{
browserContentToolboxOpener
:
gBrowser
.
ownerGlobal
}
}
)
;
toolbox
.
target
.
on
(
"
target
-
destroyed
"
(
)
=
>
{
toolbox
.
commands
.
client
.
close
(
)
;
}
)
;
return
toolbox
;
}
catch
(
e
)
{
console
.
error
(
"
Exception
while
opening
the
browser
content
toolbox
:
"
e
)
;
}
}
else
{
const
msg
=
L10N
.
getStr
(
"
toolbox
.
noContentProcessForTab
.
message
"
)
;
Services
.
prompt
.
alert
(
null
"
"
msg
)
;
throw
new
Error
(
msg
)
;
}
}
loadBrowserStyleSheet
(
win
)
{
if
(
this
.
_browserStyleSheets
.
has
(
win
)
)
{
return
Promise
.
resolve
(
)
;
}
const
doc
=
win
.
document
;
const
{
styleSheet
loadPromise
}
=
appendStyleSheet
(
doc
BROWSER_STYLESHEET_URL
)
;
this
.
_browserStyleSheets
.
set
(
win
styleSheet
)
;
return
loadPromise
;
}
_registerBrowserWindow
(
win
)
{
if
(
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
add
(
win
)
;
BrowserMenus
.
addMenus
(
win
.
document
)
;
this
.
updateCommandAvailability
(
win
)
;
this
.
updateDevtoolsThemeAttribute
(
win
)
;
if
(
!
this
.
_observersRegistered
)
{
this
.
_observersRegistered
=
true
;
Services
.
prefs
.
addObserver
(
"
devtools
.
"
this
)
;
this
.
_onThemeChanged
=
this
.
_onThemeChanged
.
bind
(
this
)
;
addThemeObserver
(
this
.
_onThemeChanged
)
;
}
win
.
addEventListener
(
"
unload
"
this
)
;
const
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
}
_onThemeChanged
(
)
{
for
(
const
win
of
this
.
_trackedBrowserWindows
)
{
this
.
updateDevtoolsThemeAttribute
(
win
)
;
}
}
_addToolToWindows
(
toolDefinition
)
{
if
(
!
toolDefinition
.
inMenu
)
{
return
;
}
try
{
if
(
toolDefinition
.
visibilityswitch
&
&
!
Services
.
prefs
.
getBoolPref
(
toolDefinition
.
visibilityswitch
)
)
{
return
;
}
}
catch
(
e
)
{
}
const
allDefs
=
gDevTools
.
getToolDefinitionArray
(
)
;
let
prevDef
;
for
(
const
def
of
allDefs
)
{
if
(
!
def
.
inMenu
)
{
continue
;
}
if
(
def
=
=
=
toolDefinition
)
{
break
;
}
prevDef
=
def
;
}
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
insertToolMenuElements
(
win
.
document
toolDefinition
prevDef
)
;
gDevToolsBrowser
.
_updateMenuItems
(
win
)
;
}
}
hasToolboxOpened
(
win
)
{
const
tab
=
win
.
gBrowser
.
selectedTab
;
for
(
const
[
descriptor
]
of
gDevTools
.
_toolboxes
)
{
if
(
descriptor
.
localTab
=
=
tab
)
{
return
true
;
}
}
return
false
;
}
_updateMenu
(
)
{
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
gDevToolsBrowser
.
_updateMenuItems
(
win
)
;
}
}
_updateMenuItems
(
win
)
{
const
menu
=
win
.
document
.
getElementById
(
"
menu_devToolbox
"
)
;
menu
.
hidden
=
gDevToolsBrowser
.
_isAboutDevtoolsToolbox
(
win
)
|
|
Services
.
prefs
.
getBoolPref
(
"
devtools
.
policy
.
disabled
"
false
)
;
const
hasToolbox
=
gDevToolsBrowser
.
hasToolboxOpened
(
win
)
;
if
(
hasToolbox
)
{
menu
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
menu
.
removeAttribute
(
"
checked
"
)
;
}
}
_isAboutDevtoolsToolbox
(
win
)
{
const
currentURI
=
win
.
gBrowser
.
currentURI
;
return
(
currentURI
.
scheme
=
=
=
"
about
"
&
&
currentURI
.
filePath
=
=
=
"
devtools
-
toolbox
"
)
;
}
_getAboutDevtoolsToolbox
(
win
)
{
if
(
!
gDevToolsBrowser
.
_isAboutDevtoolsToolbox
(
win
)
)
{
return
null
;
}
return
gDevTools
.
getToolboxes
(
)
.
find
(
toolbox
=
>
toolbox
.
topWindow
=
=
=
win
)
;
}
_removeToolFromWindows
(
toolId
)
{
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
removeToolFromMenu
(
toolId
win
.
document
)
;
}
}
_forgetBrowserWindow
(
win
)
{
if
(
!
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
delete
(
win
)
;
win
.
removeEventListener
(
"
unload
"
this
)
;
BrowserMenus
.
removeMenus
(
win
.
document
)
;
for
(
const
[
descriptor
toolbox
]
of
gDevTools
.
_toolboxes
)
{
if
(
descriptor
.
localTab
&
&
descriptor
.
localTab
.
ownerDocument
.
defaultView
=
=
win
)
{
toolbox
.
destroy
(
)
;
}
}
const
styleSheet
=
this
.
_browserStyleSheets
.
get
(
win
)
;
if
(
styleSheet
)
{
styleSheet
.
remove
(
)
;
this
.
_browserStyleSheets
.
delete
(
win
)
;
}
const
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabSelect
"
:
gDevToolsBrowser
.
_updateMenu
(
)
;
break
;
case
"
unload
"
:
gDevToolsBrowser
.
_forgetBrowserWindow
(
event
.
target
.
defaultView
)
;
break
;
}
}
destroy
(
{
shuttingDown
}
)
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
"
gDevToolsBrowser
)
;
removeThemeObserver
(
this
.
_onThemeChanged
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
quit
-
application
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
devtools
:
loader
:
destroy
"
)
;
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
gDevToolsBrowser
.
_forgetBrowserWindow
(
win
)
;
}
DevToolsServer
.
removeContentServerScript
(
)
;
gDevTools
.
destroy
(
{
shuttingDown
}
)
;
}
}
)
;
gDevTools
.
getToolDefinitionArray
(
)
.
forEach
(
def
=
>
gDevToolsBrowser
.
_addToolToWindows
(
def
)
)
;
gDevTools
.
on
(
"
tool
-
registered
"
function
(
toolId
)
{
const
toolDefinition
=
gDevTools
.
_tools
.
get
(
toolId
)
;
if
(
toolDefinition
)
{
gDevToolsBrowser
.
_addToolToWindows
(
toolDefinition
)
;
}
}
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
function
(
toolId
)
{
gDevToolsBrowser
.
_removeToolFromWindows
(
toolId
)
;
}
)
;
gDevTools
.
on
(
"
toolbox
-
ready
"
gDevToolsBrowser
.
_updateMenu
)
;
gDevTools
.
on
(
"
toolbox
-
destroyed
"
gDevToolsBrowser
.
_updateMenu
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
quit
-
application
"
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
devtools
:
loader
:
destroy
"
)
;
for
(
const
win
of
Services
.
wm
.
getEnumerator
(
gDevTools
.
chromeWindowType
)
)
{
if
(
win
.
gBrowserInit
?
.
delayedStartupFinished
)
{
gDevToolsBrowser
.
_registerBrowserWindow
(
win
)
;
}
}
