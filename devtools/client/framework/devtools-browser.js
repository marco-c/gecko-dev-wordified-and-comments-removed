"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
gDevTools
}
=
require
(
"
.
/
devtools
"
)
;
loader
.
lazyRequireGetter
(
this
"
TargetFactory
"
"
devtools
/
client
/
framework
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Toolbox
"
"
devtools
/
client
/
framework
/
toolbox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerServer
"
"
devtools
/
server
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
debugger
-
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserMenus
"
"
devtools
/
client
/
framework
/
browser
-
menus
"
)
;
loader
.
lazyRequireGetter
(
this
"
appendStyleSheet
"
"
devtools
/
client
/
shared
/
stylesheet
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
devtools
/
client
/
responsive
.
html
/
manager
"
true
)
;
loader
.
lazyImporter
(
this
"
BrowserToolboxProcess
"
"
resource
:
/
/
devtools
/
client
/
framework
/
ToolboxProcess
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
ScratchpadManager
"
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
const
BROWSER_STYLESHEET_URL
=
"
chrome
:
/
/
devtools
/
skin
/
devtools
-
browser
.
css
"
;
var
gDevToolsBrowser
=
exports
.
gDevToolsBrowser
=
{
_trackedBrowserWindows
:
new
Set
(
)
_browserStyleSheets
:
new
WeakMap
(
)
toggleToolboxCommand
(
gBrowser
startTime
)
{
const
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
const
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
const
isDocked
=
toolbox
&
&
toolbox
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
;
if
(
isDocked
)
{
gDevTools
.
closeToolbox
(
target
)
;
}
else
{
gDevTools
.
showToolbox
(
target
null
null
null
startTime
)
;
}
}
updateCommandAvailability
(
win
)
{
const
doc
=
win
.
document
;
function
toggleMenuItem
(
id
isEnabled
)
{
const
cmd
=
doc
.
getElementById
(
id
)
;
if
(
isEnabled
)
{
cmd
.
removeAttribute
(
"
disabled
"
)
;
cmd
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
cmd
.
setAttribute
(
"
disabled
"
"
true
"
)
;
cmd
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
const
webIDEEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webide
.
enabled
"
)
;
toggleMenuItem
(
"
menu_webide
"
webIDEEnabled
)
;
if
(
webIDEEnabled
)
{
gDevToolsBrowser
.
installWebIDEWidget
(
)
;
}
else
{
gDevToolsBrowser
.
uninstallWebIDEWidget
(
)
;
}
const
chromeEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
;
const
devtoolsRemoteEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
)
;
const
remoteEnabled
=
chromeEnabled
&
&
devtoolsRemoteEnabled
;
toggleMenuItem
(
"
menu_browserToolbox
"
remoteEnabled
)
;
toggleMenuItem
(
"
menu_browserContentToolbox
"
remoteEnabled
&
&
win
.
gMultiProcessBrowser
)
;
toggleMenuItem
(
"
menu_devtools_connect
"
devtoolsRemoteEnabled
)
;
}
updateDevtoolsThemeAttribute
(
win
)
{
let
devtoolsTheme
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
if
(
devtoolsTheme
!
=
"
dark
"
)
{
devtoolsTheme
=
"
light
"
;
}
win
.
document
.
getElementById
(
"
browser
-
bottombox
"
)
.
setAttribute
(
"
devtoolstheme
"
devtoolsTheme
)
;
win
.
document
.
getElementById
(
"
appcontent
"
)
.
setAttribute
(
"
devtoolstheme
"
devtoolsTheme
)
;
}
observe
(
subject
topic
prefName
)
{
switch
(
topic
)
{
case
"
browser
-
delayed
-
startup
-
finished
"
:
this
.
_registerBrowserWindow
(
subject
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
prefName
.
endsWith
(
"
enabled
"
)
)
{
for
(
const
win
of
this
.
_trackedBrowserWindows
)
{
this
.
updateCommandAvailability
(
win
)
;
}
}
if
(
prefName
=
=
=
"
devtools
.
theme
"
)
{
for
(
const
win
of
this
.
_trackedBrowserWindows
)
{
this
.
updateDevtoolsThemeAttribute
(
win
)
;
}
}
break
;
case
"
quit
-
application
"
:
gDevToolsBrowser
.
destroy
(
{
shuttingDown
:
true
}
)
;
break
;
case
"
devtools
:
loader
:
destroy
"
:
if
(
subject
.
wrappedJSObject
=
=
require
(
"
loader
/
unload
"
)
)
{
gDevToolsBrowser
.
destroy
(
{
shuttingDown
:
false
}
)
;
}
break
;
}
}
_prefObserverRegistered
:
false
ensurePrefObserver
(
)
{
if
(
!
this
.
_prefObserverRegistered
)
{
this
.
_prefObserverRegistered
=
true
;
Services
.
prefs
.
addObserver
(
"
devtools
.
"
this
)
;
}
}
selectToolCommand
(
gBrowser
toolId
startTime
)
{
const
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
const
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
const
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolbox
&
&
(
toolbox
.
currentToolId
=
=
toolId
|
|
(
toolId
=
=
"
webconsole
"
&
&
toolbox
.
splitConsole
)
)
)
{
toolbox
.
fireCustomKey
(
toolId
)
;
if
(
toolDefinition
.
preventClosingOnKey
|
|
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
toolbox
.
raise
(
)
;
}
else
{
gDevTools
.
closeToolbox
(
target
)
;
}
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
else
{
gDevTools
.
showToolbox
(
target
toolId
null
null
startTime
)
.
then
(
newToolbox
=
>
{
newToolbox
.
fireCustomKey
(
toolId
)
;
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
)
;
}
}
onKeyShortcut
(
window
key
startTime
)
{
if
(
key
.
toolId
)
{
gDevToolsBrowser
.
selectToolCommand
(
window
.
gBrowser
key
.
toolId
startTime
)
;
return
;
}
switch
(
key
.
id
)
{
case
"
toggleToolbox
"
:
case
"
toggleToolboxF12
"
:
gDevToolsBrowser
.
toggleToolboxCommand
(
window
.
gBrowser
startTime
)
;
break
;
case
"
webide
"
:
gDevToolsBrowser
.
openWebIDE
(
)
;
break
;
case
"
browserToolbox
"
:
BrowserToolboxProcess
.
init
(
)
;
break
;
case
"
browserConsole
"
:
const
{
HUDService
}
=
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
;
HUDService
.
openBrowserConsoleOrFocus
(
)
;
break
;
case
"
responsiveDesignMode
"
:
ResponsiveUIManager
.
toggle
(
window
window
.
gBrowser
.
selectedTab
{
trigger
:
"
shortcut
"
}
)
;
break
;
case
"
scratchpad
"
:
ScratchpadManager
.
openScratchpad
(
)
;
break
;
case
"
inspectorMac
"
:
gDevToolsBrowser
.
selectToolCommand
(
window
.
gBrowser
"
inspector
"
startTime
)
;
break
;
}
}
openAboutDebugging
(
gBrowser
hash
)
{
const
url
=
"
about
:
debugging
"
+
(
hash
?
"
#
"
+
hash
:
"
"
)
;
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
)
;
}
openConnectScreen
(
gBrowser
)
{
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
"
chrome
:
/
/
devtools
/
content
/
framework
/
connect
/
connect
.
xhtml
"
)
;
}
openWebIDE
(
)
{
const
win
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webide
"
)
;
if
(
win
)
{
win
.
focus
(
)
;
}
else
{
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
webide
/
content
/
"
"
webide
"
"
chrome
centerscreen
resizable
"
null
)
;
}
}
_getContentProcessTarget
(
processId
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
const
transport
=
DebuggerServer
.
connectPipe
(
)
;
const
client
=
new
DebuggerClient
(
transport
)
;
return
new
Promise
(
resolve
=
>
{
client
.
connect
(
)
.
then
(
(
)
=
>
{
client
.
getProcess
(
processId
)
.
then
(
response
=
>
{
const
options
=
{
form
:
response
.
form
client
:
client
chrome
:
true
isBrowsingContext
:
false
}
;
return
TargetFactory
.
forRemoteTab
(
options
)
;
}
)
.
then
(
target
=
>
{
target
.
on
(
"
close
"
(
)
=
>
{
client
.
close
(
)
;
}
)
;
resolve
(
target
)
;
}
)
;
}
)
;
}
)
;
}
openContentProcessToolbox
(
gBrowser
)
{
const
{
childCount
}
=
Services
.
ppmm
;
const
mm
=
gBrowser
.
selectedBrowser
.
messageManager
.
processMessageManager
;
let
processId
=
null
;
for
(
let
i
=
1
;
i
<
childCount
;
i
+
+
)
{
const
child
=
Services
.
ppmm
.
getChildAt
(
i
)
;
if
(
child
=
=
mm
)
{
processId
=
i
;
break
;
}
}
if
(
processId
)
{
return
this
.
_getContentProcessTarget
(
processId
)
.
then
(
target
=
>
{
return
gDevTools
.
showToolbox
(
target
null
Toolbox
.
HostType
.
WINDOW
)
;
}
)
;
}
const
msg
=
L10N
.
getStr
(
"
toolbox
.
noContentProcessForTab
.
message
"
)
;
Services
.
prompt
.
alert
(
null
"
"
msg
)
;
return
Promise
.
reject
(
msg
)
;
}
async
openWorkerToolbox
(
client
workerTargetActor
)
{
const
[
workerClient
]
=
await
client
.
attachWorker
(
workerTargetActor
)
;
const
workerTarget
=
TargetFactory
.
forWorker
(
workerClient
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
workerTarget
null
Toolbox
.
HostType
.
WINDOW
)
;
toolbox
.
once
(
"
destroy
"
(
)
=
>
workerClient
.
detach
(
)
)
;
}
installWebIDEWidget
(
)
{
if
(
this
.
isWebIDEWidgetInstalled
(
)
)
{
return
;
}
CustomizableUI
.
createWidget
(
{
id
:
"
webide
-
button
"
shortcutId
:
"
key_webide
"
label
:
"
devtools
-
webide
-
button2
.
label
"
tooltiptext
:
"
devtools
-
webide
-
button2
.
tooltiptext
"
onCommand
(
event
)
{
gDevToolsBrowser
.
openWebIDE
(
)
;
}
}
)
;
}
isWebIDEWidgetInstalled
(
)
{
const
widgetWrapper
=
CustomizableUI
.
getWidget
(
"
webide
-
button
"
)
;
return
!
!
(
widgetWrapper
&
&
widgetWrapper
.
provider
=
=
CustomizableUI
.
PROVIDER_API
)
;
}
loadBrowserStyleSheet
:
function
(
win
)
{
if
(
this
.
_browserStyleSheets
.
has
(
win
)
)
{
return
Promise
.
resolve
(
)
;
}
const
doc
=
win
.
document
;
const
{
styleSheet
loadPromise
}
=
appendStyleSheet
(
doc
BROWSER_STYLESHEET_URL
)
;
this
.
_browserStyleSheets
.
set
(
win
styleSheet
)
;
return
loadPromise
;
}
isWebIDEInitialized
:
defer
(
)
uninstallWebIDEWidget
(
)
{
if
(
this
.
isWebIDEWidgetInstalled
(
)
)
{
CustomizableUI
.
removeWidgetFromArea
(
"
webide
-
button
"
)
;
}
CustomizableUI
.
destroyWidget
(
"
webide
-
button
"
)
;
}
_registerBrowserWindow
(
win
)
{
if
(
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
add
(
win
)
;
BrowserMenus
.
addMenus
(
win
.
document
)
;
this
.
updateCommandAvailability
(
win
)
;
this
.
updateDevtoolsThemeAttribute
(
win
)
;
this
.
ensurePrefObserver
(
)
;
win
.
addEventListener
(
"
unload
"
this
)
;
const
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
}
setSlowScriptDebugHandler
(
)
{
const
debugService
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
function
slowScriptDebugHandler
(
tab
callback
)
{
const
target
=
TargetFactory
.
forTab
(
tab
)
;
gDevTools
.
showToolbox
(
target
"
jsdebugger
"
)
.
then
(
toolbox
=
>
{
const
threadClient
=
toolbox
.
threadClient
;
switch
(
threadClient
.
state
)
{
case
"
paused
"
:
threadClient
.
resumeThenPause
(
)
;
callback
(
)
;
break
;
case
"
attached
"
:
threadClient
.
interrupt
(
(
)
=
>
{
threadClient
.
resumeThenPause
(
)
;
callback
(
)
;
}
)
;
break
;
case
"
resuming
"
:
threadClient
.
addOneTimeListener
(
"
resumed
"
(
)
=
>
{
threadClient
.
interrupt
(
(
)
=
>
{
threadClient
.
resumeThenPause
(
)
;
callback
(
)
;
}
)
;
}
)
;
break
;
default
:
throw
Error
(
"
invalid
thread
client
state
in
slow
script
debug
handler
:
"
+
threadClient
.
state
)
;
}
}
)
;
}
debugService
.
activationHandler
=
function
(
window
)
{
const
chromeWindow
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
;
let
setupFinished
=
false
;
slowScriptDebugHandler
(
chromeWindow
.
gBrowser
.
selectedTab
(
)
=
>
{
setupFinished
=
true
;
}
)
;
const
utils
=
window
.
windowUtils
;
utils
.
enterModalState
(
)
;
Services
.
tm
.
spinEventLoopUntil
(
(
)
=
>
{
return
setupFinished
;
}
)
;
utils
.
leaveModalState
(
)
;
}
;
debugService
.
remoteActivationHandler
=
function
(
browser
callback
)
{
const
chromeWindow
=
browser
.
ownerDocument
.
defaultView
;
const
tab
=
chromeWindow
.
gBrowser
.
getTabForBrowser
(
browser
)
;
chromeWindow
.
gBrowser
.
selected
=
tab
;
slowScriptDebugHandler
(
tab
function
(
)
{
callback
.
finishDebuggerStartup
(
)
;
}
)
;
}
;
}
unsetSlowScriptDebugHandler
(
)
{
const
debugService
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
debugService
.
activationHandler
=
undefined
;
}
_addToolToWindows
(
toolDefinition
)
{
if
(
!
toolDefinition
.
inMenu
)
{
return
;
}
try
{
if
(
toolDefinition
.
visibilityswitch
&
&
!
Services
.
prefs
.
getBoolPref
(
toolDefinition
.
visibilityswitch
)
)
{
return
;
}
}
catch
(
e
)
{
}
const
allDefs
=
gDevTools
.
getToolDefinitionArray
(
)
;
let
prevDef
;
for
(
const
def
of
allDefs
)
{
if
(
!
def
.
inMenu
)
{
continue
;
}
if
(
def
=
=
=
toolDefinition
)
{
break
;
}
prevDef
=
def
;
}
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
insertToolMenuElements
(
win
.
document
toolDefinition
prevDef
)
;
}
if
(
toolDefinition
.
id
=
=
=
"
jsdebugger
"
)
{
gDevToolsBrowser
.
setSlowScriptDebugHandler
(
)
;
}
}
hasToolboxOpened
(
win
)
{
const
tab
=
win
.
gBrowser
.
selectedTab
;
for
(
const
[
target
]
of
gDevTools
.
_toolboxes
)
{
if
(
target
.
tab
=
=
tab
)
{
return
true
;
}
}
return
false
;
}
_updateMenuCheckbox
(
)
{
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
const
hasToolbox
=
gDevToolsBrowser
.
hasToolboxOpened
(
win
)
;
const
menu
=
win
.
document
.
getElementById
(
"
menu_devToolbox
"
)
;
if
(
hasToolbox
)
{
menu
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
menu
.
removeAttribute
(
"
checked
"
)
;
}
}
}
_removeToolFromWindows
(
toolId
)
{
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
removeToolFromMenu
(
toolId
win
.
document
)
;
}
if
(
toolId
=
=
=
"
jsdebugger
"
)
{
gDevToolsBrowser
.
unsetSlowScriptDebugHandler
(
)
;
}
}
_forgetBrowserWindow
(
win
)
{
if
(
!
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
delete
(
win
)
;
win
.
removeEventListener
(
"
unload
"
this
)
;
BrowserMenus
.
removeMenus
(
win
.
document
)
;
for
(
const
[
target
toolbox
]
of
gDevTools
.
_toolboxes
)
{
if
(
target
.
tab
&
&
target
.
tab
.
ownerDocument
.
defaultView
=
=
win
)
{
toolbox
.
destroy
(
)
;
}
}
const
styleSheet
=
this
.
_browserStyleSheets
.
get
(
win
)
;
if
(
styleSheet
)
{
styleSheet
.
remove
(
)
;
this
.
_browserStyleSheets
.
delete
(
win
)
;
}
const
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabSelect
"
:
gDevToolsBrowser
.
_updateMenuCheckbox
(
)
;
break
;
case
"
unload
"
:
gDevToolsBrowser
.
_forgetBrowserWindow
(
event
.
target
.
defaultView
)
;
break
;
}
}
destroy
(
{
shuttingDown
}
)
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
"
gDevToolsBrowser
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
quit
-
application
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
devtools
:
loader
:
destroy
"
)
;
for
(
const
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
gDevToolsBrowser
.
_forgetBrowserWindow
(
win
)
;
}
DebuggerServer
.
removeContentServerScript
(
)
;
gDevTools
.
destroy
(
{
shuttingDown
}
)
;
}
}
;
gDevTools
.
getToolDefinitionArray
(
)
.
forEach
(
def
=
>
gDevToolsBrowser
.
_addToolToWindows
(
def
)
)
;
gDevTools
.
on
(
"
tool
-
registered
"
function
(
toolId
)
{
const
toolDefinition
=
gDevTools
.
_tools
.
get
(
toolId
)
;
if
(
toolDefinition
)
{
gDevToolsBrowser
.
_addToolToWindows
(
toolDefinition
)
;
}
}
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
function
(
toolId
)
{
gDevToolsBrowser
.
_removeToolFromWindows
(
toolId
)
;
}
)
;
gDevTools
.
on
(
"
toolbox
-
ready
"
gDevToolsBrowser
.
_updateMenuCheckbox
)
;
gDevTools
.
on
(
"
toolbox
-
destroyed
"
gDevToolsBrowser
.
_updateMenuCheckbox
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
quit
-
application
"
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
devtools
:
loader
:
destroy
"
)
;
const
enumerator
=
Services
.
wm
.
getEnumerator
(
gDevTools
.
chromeWindowType
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
const
win
=
enumerator
.
getNext
(
)
;
if
(
win
.
gBrowserInit
&
&
win
.
gBrowserInit
.
delayedStartupFinished
)
{
gDevToolsBrowser
.
_registerBrowserWindow
(
win
)
;
}
}
