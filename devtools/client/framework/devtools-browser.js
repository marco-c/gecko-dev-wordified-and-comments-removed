"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
{
gDevTools
}
=
require
(
"
.
/
devtools
"
)
;
const
{
when
:
unload
}
=
require
(
"
sdk
/
system
/
unload
"
)
;
loader
.
lazyRequireGetter
(
this
"
TargetFactory
"
"
devtools
/
client
/
framework
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Toolbox
"
"
devtools
/
client
/
framework
/
toolbox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerServer
"
"
devtools
/
server
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserMenus
"
"
devtools
/
client
/
framework
/
browser
-
menus
"
)
;
loader
.
lazyImporter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
locale
/
toolbox
.
properties
"
)
;
const
TABS_OPEN_PEAK_HISTOGRAM
=
"
DEVTOOLS_TABS_OPEN_PEAK_LINEAR
"
;
const
TABS_OPEN_AVG_HISTOGRAM
=
"
DEVTOOLS_TABS_OPEN_AVERAGE_LINEAR
"
;
const
TABS_PINNED_PEAK_HISTOGRAM
=
"
DEVTOOLS_TABS_PINNED_PEAK_LINEAR
"
;
const
TABS_PINNED_AVG_HISTOGRAM
=
"
DEVTOOLS_TABS_PINNED_AVERAGE_LINEAR
"
;
var
gDevToolsBrowser
=
exports
.
gDevToolsBrowser
=
{
_trackedBrowserWindows
:
new
Set
(
)
_telemetry
:
new
Telemetry
(
)
_tabStats
:
{
peakOpen
:
0
peakPinned
:
0
histOpen
:
[
]
histPinned
:
[
]
}
toggleToolboxCommand
:
function
(
gBrowser
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
let
isDocked
=
toolbox
&
&
toolbox
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
;
isDocked
?
toolbox
.
destroy
(
)
:
gDevTools
.
showToolbox
(
target
)
;
}
updateCommandAvailability
:
function
(
win
)
{
let
doc
=
win
.
document
;
function
toggleMenuItem
(
id
isEnabled
)
{
let
cmd
=
doc
.
getElementById
(
id
)
;
if
(
isEnabled
)
{
cmd
.
removeAttribute
(
"
disabled
"
)
;
cmd
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
cmd
.
setAttribute
(
"
disabled
"
"
true
"
)
;
cmd
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
let
devToolbarEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
toolbar
.
enabled
"
)
;
toggleMenuItem
(
"
menu_devToolbar
"
devToolbarEnabled
)
;
let
focusEl
=
doc
.
getElementById
(
"
menu_devToolbar
"
)
;
if
(
devToolbarEnabled
)
{
focusEl
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
focusEl
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
devToolbarEnabled
&
&
Services
.
prefs
.
getBoolPref
(
"
devtools
.
toolbar
.
visible
"
)
)
{
win
.
DeveloperToolbar
.
show
(
false
)
.
catch
(
console
.
error
)
;
}
let
webIDEEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webide
.
enabled
"
)
;
toggleMenuItem
(
"
menu_webide
"
webIDEEnabled
)
;
let
showWebIDEWidget
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webide
.
widget
.
enabled
"
)
;
if
(
webIDEEnabled
&
&
showWebIDEWidget
)
{
gDevToolsBrowser
.
installWebIDEWidget
(
)
;
}
else
{
gDevToolsBrowser
.
uninstallWebIDEWidget
(
)
;
}
let
chromeEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
;
let
devtoolsRemoteEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
)
;
let
remoteEnabled
=
chromeEnabled
&
&
devtoolsRemoteEnabled
;
toggleMenuItem
(
"
menu_browserToolbox
"
remoteEnabled
)
;
toggleMenuItem
(
"
menu_browserContentToolbox
"
remoteEnabled
&
&
win
.
gMultiProcessBrowser
)
;
toggleMenuItem
(
"
menu_devtools_connect
"
devtoolsRemoteEnabled
)
;
}
observe
:
function
(
subject
topic
prefName
)
{
switch
(
topic
)
{
case
"
browser
-
delayed
-
startup
-
finished
"
:
this
.
_registerBrowserWindow
(
subject
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
prefName
.
endsWith
(
"
enabled
"
)
)
{
for
(
let
win
of
this
.
_trackedBrowserWindows
)
{
this
.
updateCommandAvailability
(
win
)
;
}
}
break
;
}
}
_prefObserverRegistered
:
false
ensurePrefObserver
:
function
(
)
{
if
(
!
this
.
_prefObserverRegistered
)
{
this
.
_prefObserverRegistered
=
true
;
Services
.
prefs
.
addObserver
(
"
devtools
.
"
this
false
)
;
}
}
selectToolCommand
:
function
(
gBrowser
toolId
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
let
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolbox
&
&
(
toolbox
.
currentToolId
=
=
toolId
|
|
(
toolId
=
=
"
webconsole
"
&
&
toolbox
.
splitConsole
)
)
)
{
toolbox
.
fireCustomKey
(
toolId
)
;
if
(
toolDefinition
.
preventClosingOnKey
|
|
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
toolbox
.
raise
(
)
;
}
else
{
toolbox
.
destroy
(
)
;
}
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
else
{
gDevTools
.
showToolbox
(
target
toolId
)
.
then
(
(
)
=
>
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
toolbox
.
fireCustomKey
(
toolId
)
;
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
)
;
}
}
openAboutDebugging
:
function
(
gBrowser
hash
)
{
let
url
=
"
about
:
debugging
"
+
(
hash
?
"
#
"
+
hash
:
"
"
)
;
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
)
;
}
openConnectScreen
:
function
(
gBrowser
)
{
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
"
chrome
:
/
/
devtools
/
content
/
framework
/
connect
/
connect
.
xhtml
"
)
;
}
openWebIDE
:
function
(
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webide
"
)
;
if
(
win
)
{
win
.
focus
(
)
;
}
else
{
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
webide
/
content
/
"
"
webide
"
"
chrome
centerscreen
resizable
"
null
)
;
}
}
_getContentProcessTarget
:
function
(
processId
)
{
if
(
!
DebuggerServer
.
initialized
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
addBrowserActors
(
)
;
}
DebuggerServer
.
allowChromeProcess
=
true
;
let
transport
=
DebuggerServer
.
connectPipe
(
)
;
let
client
=
new
DebuggerClient
(
transport
)
;
let
deferred
=
defer
(
)
;
client
.
connect
(
)
.
then
(
(
)
=
>
{
client
.
getProcess
(
processId
)
.
then
(
response
=
>
{
let
options
=
{
form
:
response
.
form
client
:
client
chrome
:
true
isTabActor
:
false
}
;
return
TargetFactory
.
forRemoteTab
(
options
)
;
}
)
.
then
(
target
=
>
{
target
.
on
(
"
close
"
(
)
=
>
{
client
.
close
(
)
;
}
)
;
deferred
.
resolve
(
target
)
;
}
)
;
}
)
;
return
deferred
.
promise
;
}
openContentProcessToolbox
:
function
(
gBrowser
)
{
let
{
childCount
}
=
Services
.
ppmm
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
.
processMessageManager
;
let
processId
=
null
;
for
(
let
i
=
1
;
i
<
childCount
;
i
+
+
)
{
let
child
=
Services
.
ppmm
.
getChildAt
(
i
)
;
if
(
child
=
=
mm
)
{
processId
=
i
;
break
;
}
}
if
(
processId
)
{
this
.
_getContentProcessTarget
(
processId
)
.
then
(
target
=
>
{
return
gDevTools
.
showToolbox
(
target
"
jsdebugger
"
Toolbox
.
HostType
.
WINDOW
)
;
}
)
;
}
else
{
let
msg
=
L10N
.
getStr
(
"
toolbox
.
noContentProcessForTab
.
message
"
)
;
Services
.
prompt
.
alert
(
null
"
"
msg
)
;
}
}
installDeveloperWidget
:
function
(
)
{
let
id
=
"
developer
-
button
"
;
let
widget
=
CustomizableUI
.
getWidget
(
id
)
;
if
(
widget
&
&
widget
.
provider
=
=
CustomizableUI
.
PROVIDER_API
)
{
return
;
}
CustomizableUI
.
createWidget
(
{
id
:
id
type
:
"
view
"
viewId
:
"
PanelUI
-
developer
"
shortcutId
:
"
key_devToolboxMenuItem
"
tooltiptext
:
"
developer
-
button
.
tooltiptext2
"
defaultArea
:
AppConstants
.
MOZ_DEV_EDITION
?
CustomizableUI
.
AREA_NAVBAR
:
CustomizableUI
.
AREA_PANEL
onViewShowing
:
function
(
aEvent
)
{
let
doc
=
aEvent
.
target
.
ownerDocument
;
let
win
=
doc
.
defaultView
;
let
menu
=
doc
.
getElementById
(
"
menuWebDeveloperPopup
"
)
;
let
itemsToDisplay
=
[
.
.
.
menu
.
children
]
;
itemsToDisplay
.
push
(
{
localName
:
"
menuseparator
"
getAttribute
:
(
)
=
>
{
}
}
)
;
itemsToDisplay
.
push
(
doc
.
getElementById
(
"
goOfflineMenuitem
"
)
)
;
let
developerItems
=
doc
.
getElementById
(
"
PanelUI
-
developerItems
"
)
;
let
{
clearSubview
fillSubviewFromMenuItems
}
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
{
}
)
;
clearSubview
(
developerItems
)
;
fillSubviewFromMenuItems
(
itemsToDisplay
developerItems
)
;
}
onBeforeCreated
:
function
(
doc
)
{
if
(
doc
.
getElementById
(
"
PanelUI
-
developerItems
"
)
)
{
return
;
}
let
view
=
doc
.
createElement
(
"
panelview
"
)
;
view
.
id
=
"
PanelUI
-
developerItems
"
;
let
panel
=
doc
.
createElement
(
"
vbox
"
)
;
panel
.
setAttribute
(
"
class
"
"
panel
-
subview
-
body
"
)
;
view
.
appendChild
(
panel
)
;
doc
.
getElementById
(
"
PanelUI
-
multiView
"
)
.
appendChild
(
view
)
;
}
}
)
;
}
installWebIDEWidget
:
function
(
)
{
if
(
this
.
isWebIDEWidgetInstalled
(
)
)
{
return
;
}
let
defaultArea
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webide
.
widget
.
inNavbarByDefault
"
)
)
{
defaultArea
=
CustomizableUI
.
AREA_NAVBAR
;
}
else
{
defaultArea
=
CustomizableUI
.
AREA_PANEL
;
}
CustomizableUI
.
createWidget
(
{
id
:
"
webide
-
button
"
shortcutId
:
"
key_webide
"
label
:
"
devtools
-
webide
-
button2
.
label
"
tooltiptext
:
"
devtools
-
webide
-
button2
.
tooltiptext
"
defaultArea
:
defaultArea
onCommand
:
function
(
aEvent
)
{
gDevToolsBrowser
.
openWebIDE
(
)
;
}
}
)
;
}
isWebIDEWidgetInstalled
:
function
(
)
{
let
widgetWrapper
=
CustomizableUI
.
getWidget
(
"
webide
-
button
"
)
;
return
!
!
(
widgetWrapper
&
&
widgetWrapper
.
provider
=
=
CustomizableUI
.
PROVIDER_API
)
;
}
isWebIDEInitialized
:
defer
(
)
uninstallWebIDEWidget
:
function
(
)
{
if
(
this
.
isWebIDEWidgetInstalled
(
)
)
{
CustomizableUI
.
removeWidgetFromArea
(
"
webide
-
button
"
)
;
}
CustomizableUI
.
destroyWidget
(
"
webide
-
button
"
)
;
}
moveWebIDEWidgetInNavbar
:
function
(
)
{
CustomizableUI
.
addWidgetToArea
(
"
webide
-
button
"
CustomizableUI
.
AREA_NAVBAR
)
;
}
_registerBrowserWindow
:
function
(
win
)
{
if
(
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
add
(
win
)
;
BrowserMenus
.
addMenus
(
win
.
document
)
;
gDevToolsBrowser
.
installDeveloperWidget
(
)
;
loader
.
lazyGetter
(
win
"
DeveloperToolbar
"
function
(
)
{
let
{
DeveloperToolbar
}
=
require
(
"
devtools
/
client
/
shared
/
developer
-
toolbar
"
)
;
return
new
DeveloperToolbar
(
win
)
;
}
)
;
this
.
updateCommandAvailability
(
win
)
;
this
.
ensurePrefObserver
(
)
;
win
.
addEventListener
(
"
unload
"
this
)
;
let
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
addEventListener
(
"
TabSelect
"
this
false
)
;
tabContainer
.
addEventListener
(
"
TabOpen
"
this
false
)
;
tabContainer
.
addEventListener
(
"
TabClose
"
this
false
)
;
tabContainer
.
addEventListener
(
"
TabPinned
"
this
false
)
;
tabContainer
.
addEventListener
(
"
TabUnpinned
"
this
false
)
;
}
setSlowScriptDebugHandler
:
function
DT_setSlowScriptDebugHandler
(
)
{
let
debugService
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
let
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIThreadManager
)
;
function
slowScriptDebugHandler
(
aTab
aCallback
)
{
let
target
=
TargetFactory
.
forTab
(
aTab
)
;
gDevTools
.
showToolbox
(
target
"
jsdebugger
"
)
.
then
(
toolbox
=
>
{
let
threadClient
=
toolbox
.
getCurrentPanel
(
)
.
panelWin
.
gThreadClient
;
switch
(
threadClient
.
state
)
{
case
"
paused
"
:
threadClient
.
resumeThenPause
(
)
;
aCallback
(
)
;
break
;
case
"
attached
"
:
threadClient
.
interrupt
(
(
)
=
>
{
threadClient
.
resumeThenPause
(
)
;
aCallback
(
)
;
}
)
;
break
;
case
"
resuming
"
:
threadClient
.
addOneTimeListener
(
"
resumed
"
(
)
=
>
{
threadClient
.
interrupt
(
(
)
=
>
{
threadClient
.
resumeThenPause
(
)
;
aCallback
(
)
;
}
)
;
}
)
;
break
;
default
:
throw
Error
(
"
invalid
thread
client
state
in
slow
script
debug
handler
:
"
+
threadClient
.
state
)
;
}
}
)
;
}
debugService
.
activationHandler
=
function
(
aWindow
)
{
let
chromeWindow
=
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
;
let
setupFinished
=
false
;
slowScriptDebugHandler
(
chromeWindow
.
gBrowser
.
selectedTab
(
)
=
>
{
setupFinished
=
true
;
}
)
;
let
utils
=
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
utils
.
enterModalState
(
)
;
while
(
!
setupFinished
)
{
tm
.
currentThread
.
processNextEvent
(
true
)
;
}
utils
.
leaveModalState
(
)
;
}
;
debugService
.
remoteActivationHandler
=
function
(
aBrowser
aCallback
)
{
let
chromeWindow
=
aBrowser
.
ownerDocument
.
defaultView
;
let
tab
=
chromeWindow
.
gBrowser
.
getTabForBrowser
(
aBrowser
)
;
chromeWindow
.
gBrowser
.
selected
=
tab
;
function
callback
(
)
{
aCallback
.
finishDebuggerStartup
(
)
;
}
slowScriptDebugHandler
(
tab
callback
)
;
}
;
}
unsetSlowScriptDebugHandler
:
function
DT_unsetSlowScriptDebugHandler
(
)
{
let
debugService
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
debugService
.
activationHandler
=
undefined
;
}
_addToolToWindows
:
function
DT_addToolToWindows
(
toolDefinition
)
{
if
(
!
toolDefinition
.
inMenu
)
{
return
;
}
try
{
if
(
toolDefinition
.
visibilityswitch
&
&
!
Services
.
prefs
.
getBoolPref
(
toolDefinition
.
visibilityswitch
)
)
{
return
;
}
}
catch
(
e
)
{
}
let
allDefs
=
gDevTools
.
getToolDefinitionArray
(
)
;
let
prevDef
;
for
(
let
def
of
allDefs
)
{
if
(
!
def
.
inMenu
)
{
continue
;
}
if
(
def
=
=
=
toolDefinition
)
{
break
;
}
prevDef
=
def
;
}
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
insertToolMenuElements
(
win
.
document
toolDefinition
prevDef
)
;
}
if
(
toolDefinition
.
id
=
=
=
"
jsdebugger
"
)
{
gDevToolsBrowser
.
setSlowScriptDebugHandler
(
)
;
}
}
hasToolboxOpened
:
function
(
win
)
{
let
tab
=
win
.
gBrowser
.
selectedTab
;
for
(
let
[
target
toolbox
]
of
gDevTools
.
_toolboxes
)
{
if
(
target
.
tab
=
=
tab
)
{
return
true
;
}
}
return
false
;
}
_updateMenuCheckbox
:
function
DT_updateMenuCheckbox
(
)
{
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
let
hasToolbox
=
gDevToolsBrowser
.
hasToolboxOpened
(
win
)
;
let
menu
=
win
.
document
.
getElementById
(
"
menu_devToolbox
"
)
;
if
(
hasToolbox
)
{
menu
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
menu
.
removeAttribute
(
"
checked
"
)
;
}
}
}
_removeToolFromWindows
:
function
DT_removeToolFromWindows
(
toolId
)
{
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
removeToolFromMenu
(
toolId
win
.
document
)
;
}
if
(
toolId
=
=
=
"
jsdebugger
"
)
{
gDevToolsBrowser
.
unsetSlowScriptDebugHandler
(
)
;
}
}
_forgetBrowserWindow
:
function
(
win
)
{
if
(
!
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
delete
(
win
)
;
win
.
removeEventListener
(
"
unload
"
this
)
;
BrowserMenus
.
removeMenus
(
win
.
document
)
;
for
(
let
[
target
toolbox
]
of
gDevTools
.
_toolboxes
)
{
if
(
toolbox
.
win
.
top
=
=
win
)
{
toolbox
.
destroy
(
)
;
}
}
let
desc
=
Object
.
getOwnPropertyDescriptor
(
win
"
DeveloperToolbar
"
)
;
if
(
desc
&
&
!
desc
.
get
)
{
win
.
DeveloperToolbar
.
destroy
(
)
;
}
let
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
false
)
;
tabContainer
.
removeEventListener
(
"
TabOpen
"
this
false
)
;
tabContainer
.
removeEventListener
(
"
TabClose
"
this
false
)
;
tabContainer
.
removeEventListener
(
"
TabPinned
"
this
false
)
;
tabContainer
.
removeEventListener
(
"
TabUnpinned
"
this
false
)
;
}
handleEvent
:
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
case
"
TabClose
"
:
case
"
TabPinned
"
:
case
"
TabUnpinned
"
:
let
open
=
0
;
let
pinned
=
0
;
for
(
let
win
of
this
.
_trackedBrowserWindows
)
{
let
tabContainer
=
win
.
gBrowser
.
tabContainer
;
let
numPinnedTabs
=
win
.
gBrowser
.
_numPinnedTabs
|
|
0
;
let
numTabs
=
tabContainer
.
itemCount
-
numPinnedTabs
;
open
+
=
numTabs
;
pinned
+
=
numPinnedTabs
;
}
this
.
_tabStats
.
histOpen
.
push
(
open
)
;
this
.
_tabStats
.
histPinned
.
push
(
pinned
)
;
this
.
_tabStats
.
peakOpen
=
Math
.
max
(
open
this
.
_tabStats
.
peakOpen
)
;
this
.
_tabStats
.
peakPinned
=
Math
.
max
(
pinned
this
.
_tabStats
.
peakPinned
)
;
break
;
case
"
TabSelect
"
:
gDevToolsBrowser
.
_updateMenuCheckbox
(
)
;
break
;
case
"
unload
"
:
gDevToolsBrowser
.
_forgetBrowserWindow
(
event
.
target
.
defaultView
)
;
break
;
}
}
_pingTelemetry
:
function
(
)
{
let
mean
=
function
(
arr
)
{
if
(
arr
.
length
=
=
=
0
)
{
return
0
;
}
let
total
=
arr
.
reduce
(
(
a
b
)
=
>
a
+
b
)
;
return
Math
.
ceil
(
total
/
arr
.
length
)
;
}
;
let
tabStats
=
gDevToolsBrowser
.
_tabStats
;
this
.
_telemetry
.
log
(
TABS_OPEN_PEAK_HISTOGRAM
tabStats
.
peakOpen
)
;
this
.
_telemetry
.
log
(
TABS_OPEN_AVG_HISTOGRAM
mean
(
tabStats
.
histOpen
)
)
;
this
.
_telemetry
.
log
(
TABS_PINNED_PEAK_HISTOGRAM
tabStats
.
peakPinned
)
;
this
.
_telemetry
.
log
(
TABS_PINNED_AVG_HISTOGRAM
mean
(
tabStats
.
histPinned
)
)
;
}
destroy
:
function
(
)
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
"
gDevToolsBrowser
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
.
destroy
"
quit
-
application
"
)
;
gDevToolsBrowser
.
_pingTelemetry
(
)
;
gDevToolsBrowser
.
_telemetry
=
null
;
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
gDevToolsBrowser
.
_forgetBrowserWindow
(
win
)
;
}
}
}
;
gDevTools
.
getToolDefinitionArray
(
)
.
forEach
(
def
=
>
gDevToolsBrowser
.
_addToolToWindows
(
def
)
)
;
gDevTools
.
on
(
"
tool
-
registered
"
function
(
ev
toolId
)
{
let
toolDefinition
=
gDevTools
.
_tools
.
get
(
toolId
)
;
gDevToolsBrowser
.
_addToolToWindows
(
toolDefinition
)
;
}
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
function
(
ev
toolId
)
{
if
(
typeof
toolId
!
=
"
string
"
)
{
toolId
=
toolId
.
id
;
}
gDevToolsBrowser
.
_removeToolFromWindows
(
toolId
)
;
}
)
;
gDevTools
.
on
(
"
toolbox
-
ready
"
gDevToolsBrowser
.
_updateMenuCheckbox
)
;
gDevTools
.
on
(
"
toolbox
-
destroyed
"
gDevToolsBrowser
.
_updateMenuCheckbox
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
.
destroy
"
quit
-
application
"
false
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
false
)
;
let
enumerator
=
Services
.
wm
.
getEnumerator
(
gDevTools
.
chromeWindowType
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
win
=
enumerator
.
getNext
(
)
;
if
(
win
.
gBrowserInit
&
&
win
.
gBrowserInit
.
delayedStartupFinished
)
{
gDevToolsBrowser
.
_registerBrowserWindow
(
win
)
;
}
}
unload
(
function
(
)
{
gDevToolsBrowser
.
destroy
(
)
;
}
)
;
