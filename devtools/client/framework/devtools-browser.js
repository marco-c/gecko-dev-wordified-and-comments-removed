"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
gDevTools
}
=
require
(
"
.
/
devtools
"
)
;
loader
.
lazyRequireGetter
(
this
"
TargetFactory
"
"
devtools
/
client
/
framework
/
target
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Toolbox
"
"
devtools
/
client
/
framework
/
toolbox
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerServer
"
"
devtools
/
server
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserMenus
"
"
devtools
/
client
/
framework
/
browser
-
menus
"
)
;
loader
.
lazyRequireGetter
(
this
"
appendStyleSheet
"
"
devtools
/
client
/
shared
/
stylesheet
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DeveloperToolbar
"
"
devtools
/
client
/
shared
/
developer
-
toolbar
"
true
)
;
loader
.
lazyImporter
(
this
"
CustomizableUI
"
"
resource
:
/
/
/
modules
/
CustomizableUI
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
CustomizableWidgets
"
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
LightweightThemeManager
"
"
resource
:
/
/
gre
/
modules
/
LightweightThemeManager
.
jsm
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
const
COMPACT_LIGHT_ID
=
"
firefox
-
compact
-
light
mozilla
.
org
"
;
const
COMPACT_DARK_ID
=
"
firefox
-
compact
-
dark
mozilla
.
org
"
;
const
BROWSER_STYLESHEET_URL
=
"
chrome
:
/
/
devtools
/
skin
/
devtools
-
browser
.
css
"
;
var
gDevToolsBrowser
=
exports
.
gDevToolsBrowser
=
{
_trackedBrowserWindows
:
new
Set
(
)
_browserStyleSheets
:
new
WeakMap
(
)
_toolbars
:
new
WeakMap
(
)
_tabStats
:
{
peakOpen
:
0
peakPinned
:
0
histOpen
:
[
]
histPinned
:
[
]
}
toggleToolboxCommand
(
gBrowser
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
let
isDocked
=
toolbox
&
&
toolbox
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
;
isDocked
?
gDevTools
.
closeToolbox
(
target
)
:
gDevTools
.
showToolbox
(
target
)
;
}
updateCommandAvailability
(
win
)
{
let
doc
=
win
.
document
;
function
toggleMenuItem
(
id
isEnabled
)
{
let
cmd
=
doc
.
getElementById
(
id
)
;
if
(
isEnabled
)
{
cmd
.
removeAttribute
(
"
disabled
"
)
;
cmd
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
cmd
.
setAttribute
(
"
disabled
"
"
true
"
)
;
cmd
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
let
devToolbarEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
toolbar
.
enabled
"
)
;
toggleMenuItem
(
"
menu_devToolbar
"
devToolbarEnabled
)
;
let
focusEl
=
doc
.
getElementById
(
"
menu_devToolbar
"
)
;
if
(
devToolbarEnabled
)
{
focusEl
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
focusEl
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
devToolbarEnabled
&
&
Services
.
prefs
.
getBoolPref
(
"
devtools
.
toolbar
.
visible
"
)
)
{
this
.
getDeveloperToolbar
(
win
)
.
show
(
false
)
.
catch
(
console
.
error
)
;
}
let
webIDEEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
webide
.
enabled
"
)
;
toggleMenuItem
(
"
menu_webide
"
webIDEEnabled
)
;
if
(
webIDEEnabled
)
{
gDevToolsBrowser
.
installWebIDEWidget
(
)
;
}
else
{
gDevToolsBrowser
.
uninstallWebIDEWidget
(
)
;
}
let
chromeEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
chrome
.
enabled
"
)
;
let
devtoolsRemoteEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
remote
-
enabled
"
)
;
let
remoteEnabled
=
chromeEnabled
&
&
devtoolsRemoteEnabled
;
toggleMenuItem
(
"
menu_browserToolbox
"
remoteEnabled
)
;
toggleMenuItem
(
"
menu_browserContentToolbox
"
remoteEnabled
&
&
win
.
gMultiProcessBrowser
)
;
toggleMenuItem
(
"
menu_devtools_connect
"
devtoolsRemoteEnabled
)
;
}
updateDevtoolsThemeAttribute
(
win
)
{
let
devtoolsTheme
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
if
(
devtoolsTheme
!
=
"
dark
"
)
{
devtoolsTheme
=
"
light
"
;
}
win
.
document
.
getElementById
(
"
browser
-
bottombox
"
)
.
setAttribute
(
"
devtoolstheme
"
devtoolsTheme
)
;
win
.
document
.
getElementById
(
"
content
"
)
.
setAttribute
(
"
devtoolstheme
"
devtoolsTheme
)
;
let
currentTheme
=
LightweightThemeManager
.
currentTheme
;
let
currentThemeID
=
currentTheme
&
&
currentTheme
.
id
;
if
(
currentThemeID
=
=
COMPACT_LIGHT_ID
&
&
devtoolsTheme
=
=
"
dark
"
)
{
LightweightThemeManager
.
currentTheme
=
LightweightThemeManager
.
getUsedTheme
(
COMPACT_DARK_ID
)
;
}
if
(
currentThemeID
=
=
COMPACT_DARK_ID
&
&
devtoolsTheme
=
=
"
light
"
)
{
LightweightThemeManager
.
currentTheme
=
LightweightThemeManager
.
getUsedTheme
(
COMPACT_LIGHT_ID
)
;
}
}
observe
(
subject
topic
prefName
)
{
switch
(
topic
)
{
case
"
browser
-
delayed
-
startup
-
finished
"
:
this
.
_registerBrowserWindow
(
subject
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
prefName
.
endsWith
(
"
enabled
"
)
)
{
for
(
let
win
of
this
.
_trackedBrowserWindows
)
{
this
.
updateCommandAvailability
(
win
)
;
}
}
if
(
prefName
=
=
=
"
devtools
.
theme
"
)
{
for
(
let
win
of
this
.
_trackedBrowserWindows
)
{
this
.
updateDevtoolsThemeAttribute
(
win
)
;
}
}
break
;
case
"
quit
-
application
"
:
gDevToolsBrowser
.
destroy
(
{
shuttingDown
:
true
}
)
;
break
;
case
"
sdk
:
loader
:
destroy
"
:
if
(
subject
.
wrappedJSObject
=
=
require
(
"
loader
/
unload
"
)
)
{
gDevToolsBrowser
.
destroy
(
{
shuttingDown
:
false
}
)
;
}
break
;
case
"
lightweight
-
theme
-
changed
"
:
let
currentTheme
=
LightweightThemeManager
.
currentTheme
;
let
currentThemeID
=
currentTheme
&
&
currentTheme
.
id
;
let
devtoolsTheme
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
if
(
currentThemeID
=
=
COMPACT_LIGHT_ID
&
&
devtoolsTheme
=
=
"
dark
"
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
theme
"
"
light
"
)
;
}
if
(
currentThemeID
=
=
COMPACT_DARK_ID
&
&
devtoolsTheme
=
=
"
light
"
)
{
Services
.
prefs
.
setCharPref
(
"
devtools
.
theme
"
"
dark
"
)
;
}
break
;
}
}
_prefObserverRegistered
:
false
ensurePrefObserver
(
)
{
if
(
!
this
.
_prefObserverRegistered
)
{
this
.
_prefObserverRegistered
=
true
;
Services
.
prefs
.
addObserver
(
"
devtools
.
"
this
)
;
}
}
selectToolCommand
(
gBrowser
toolId
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
let
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolbox
&
&
(
toolbox
.
currentToolId
=
=
toolId
|
|
(
toolId
=
=
"
webconsole
"
&
&
toolbox
.
splitConsole
)
)
)
{
toolbox
.
fireCustomKey
(
toolId
)
;
if
(
toolDefinition
.
preventClosingOnKey
|
|
toolbox
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
toolbox
.
raise
(
)
;
}
else
{
gDevTools
.
closeToolbox
(
target
)
;
}
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
else
{
gDevTools
.
showToolbox
(
target
toolId
)
.
then
(
newToolbox
=
>
{
newToolbox
.
fireCustomKey
(
toolId
)
;
gDevTools
.
emit
(
"
select
-
tool
-
command
"
toolId
)
;
}
)
;
}
}
openAboutDebugging
(
gBrowser
hash
)
{
let
url
=
"
about
:
debugging
"
+
(
hash
?
"
#
"
+
hash
:
"
"
)
;
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
url
)
;
}
openConnectScreen
(
gBrowser
)
{
gBrowser
.
selectedTab
=
gBrowser
.
addTab
(
"
chrome
:
/
/
devtools
/
content
/
framework
/
connect
/
connect
.
xhtml
"
)
;
}
openWebIDE
(
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
"
devtools
:
webide
"
)
;
if
(
win
)
{
win
.
focus
(
)
;
}
else
{
Services
.
ww
.
openWindow
(
null
"
chrome
:
/
/
webide
/
content
/
"
"
webide
"
"
chrome
centerscreen
resizable
"
null
)
;
}
}
_getContentProcessTarget
(
processId
)
{
if
(
!
DebuggerServer
.
initialized
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
addBrowserActors
(
)
;
}
DebuggerServer
.
allowChromeProcess
=
true
;
let
transport
=
DebuggerServer
.
connectPipe
(
)
;
let
client
=
new
DebuggerClient
(
transport
)
;
let
deferred
=
defer
(
)
;
client
.
connect
(
)
.
then
(
(
)
=
>
{
client
.
getProcess
(
processId
)
.
then
(
response
=
>
{
let
options
=
{
form
:
response
.
form
client
:
client
chrome
:
true
isTabActor
:
false
}
;
return
TargetFactory
.
forRemoteTab
(
options
)
;
}
)
.
then
(
target
=
>
{
target
.
on
(
"
close
"
(
)
=
>
{
client
.
close
(
)
;
}
)
;
deferred
.
resolve
(
target
)
;
}
)
;
}
)
;
return
deferred
.
promise
;
}
openContentProcessToolbox
(
gBrowser
)
{
let
{
childCount
}
=
Services
.
ppmm
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
.
processMessageManager
;
let
processId
=
null
;
for
(
let
i
=
1
;
i
<
childCount
;
i
+
+
)
{
let
child
=
Services
.
ppmm
.
getChildAt
(
i
)
;
if
(
child
=
=
mm
)
{
processId
=
i
;
break
;
}
}
if
(
processId
)
{
this
.
_getContentProcessTarget
(
processId
)
.
then
(
target
=
>
{
return
gDevTools
.
showToolbox
(
target
"
jsdebugger
"
Toolbox
.
HostType
.
WINDOW
)
;
}
)
;
}
else
{
let
msg
=
L10N
.
getStr
(
"
toolbox
.
noContentProcessForTab
.
message
"
)
;
Services
.
prompt
.
alert
(
null
"
"
msg
)
;
}
}
installDeveloperWidget
(
)
{
let
id
=
"
developer
-
button
"
;
let
widget
=
CustomizableUI
.
getWidget
(
id
)
;
if
(
widget
&
&
widget
.
provider
=
=
CustomizableUI
.
PROVIDER_API
)
{
return
;
}
let
item
=
{
id
:
id
type
:
"
view
"
viewId
:
"
PanelUI
-
developer
"
shortcutId
:
"
key_devToolboxMenuItem
"
tooltiptext
:
"
developer
-
button
.
tooltiptext2
"
defaultArea
:
AppConstants
.
MOZ_DEV_EDITION
?
CustomizableUI
.
AREA_NAVBAR
:
CustomizableUI
.
AREA_PANEL
onViewShowing
(
event
)
{
let
doc
=
event
.
target
.
ownerDocument
;
let
menu
=
doc
.
getElementById
(
"
menuWebDeveloperPopup
"
)
;
let
itemsToDisplay
=
[
.
.
.
menu
.
children
]
;
itemsToDisplay
.
push
(
{
localName
:
"
menuseparator
"
getAttribute
:
(
)
=
>
{
}
}
)
;
itemsToDisplay
.
push
(
doc
.
getElementById
(
"
goOfflineMenuitem
"
)
)
;
let
developerItems
=
doc
.
getElementById
(
"
PanelUI
-
developerItems
"
)
;
let
{
clearSubview
fillSubviewFromMenuItems
}
=
Cu
.
import
(
"
resource
:
/
/
/
modules
/
CustomizableWidgets
.
jsm
"
{
}
)
;
clearSubview
(
developerItems
)
;
fillSubviewFromMenuItems
(
itemsToDisplay
developerItems
)
;
}
onInit
(
anchor
)
{
this
.
onBeforeCreated
(
anchor
.
ownerDocument
)
;
}
onBeforeCreated
(
doc
)
{
if
(
doc
.
getElementById
(
"
PanelUI
-
developerItems
"
)
)
{
return
;
}
let
view
=
doc
.
createElement
(
"
panelview
"
)
;
view
.
id
=
"
PanelUI
-
developerItems
"
;
let
panel
=
doc
.
createElement
(
"
vbox
"
)
;
panel
.
setAttribute
(
"
class
"
"
panel
-
subview
-
body
"
)
;
view
.
appendChild
(
panel
)
;
doc
.
getElementById
(
"
PanelUI
-
multiView
"
)
.
appendChild
(
view
)
;
}
}
;
CustomizableUI
.
createWidget
(
item
)
;
CustomizableWidgets
.
push
(
item
)
;
}
installWebIDEWidget
(
)
{
if
(
this
.
isWebIDEWidgetInstalled
(
)
)
{
return
;
}
CustomizableUI
.
createWidget
(
{
id
:
"
webide
-
button
"
shortcutId
:
"
key_webide
"
label
:
"
devtools
-
webide
-
button2
.
label
"
tooltiptext
:
"
devtools
-
webide
-
button2
.
tooltiptext
"
onCommand
(
event
)
{
gDevToolsBrowser
.
openWebIDE
(
)
;
}
}
)
;
}
isWebIDEWidgetInstalled
(
)
{
let
widgetWrapper
=
CustomizableUI
.
getWidget
(
"
webide
-
button
"
)
;
return
!
!
(
widgetWrapper
&
&
widgetWrapper
.
provider
=
=
CustomizableUI
.
PROVIDER_API
)
;
}
loadBrowserStyleSheet
:
function
(
win
)
{
if
(
this
.
_browserStyleSheets
.
has
(
win
)
)
{
return
Promise
.
resolve
(
)
;
}
let
doc
=
win
.
document
;
let
{
styleSheet
loadPromise
}
=
appendStyleSheet
(
doc
BROWSER_STYLESHEET_URL
)
;
this
.
_browserStyleSheets
.
set
(
win
styleSheet
)
;
return
loadPromise
;
}
isWebIDEInitialized
:
defer
(
)
uninstallWebIDEWidget
(
)
{
if
(
this
.
isWebIDEWidgetInstalled
(
)
)
{
CustomizableUI
.
removeWidgetFromArea
(
"
webide
-
button
"
)
;
}
CustomizableUI
.
destroyWidget
(
"
webide
-
button
"
)
;
}
_registerBrowserWindow
(
win
)
{
if
(
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
add
(
win
)
;
BrowserMenus
.
addMenus
(
win
.
document
)
;
gDevToolsBrowser
.
installDeveloperWidget
(
)
;
this
.
updateCommandAvailability
(
win
)
;
this
.
updateDevtoolsThemeAttribute
(
win
)
;
this
.
ensurePrefObserver
(
)
;
win
.
addEventListener
(
"
unload
"
this
)
;
let
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
tabContainer
.
addEventListener
(
"
TabOpen
"
this
)
;
tabContainer
.
addEventListener
(
"
TabClose
"
this
)
;
tabContainer
.
addEventListener
(
"
TabPinned
"
this
)
;
tabContainer
.
addEventListener
(
"
TabUnpinned
"
this
)
;
}
getDeveloperToolbar
(
win
)
{
let
toolbar
=
this
.
_toolbars
.
get
(
win
)
;
if
(
toolbar
)
{
return
toolbar
;
}
toolbar
=
new
DeveloperToolbar
(
win
)
;
this
.
_toolbars
.
set
(
win
toolbar
)
;
return
toolbar
;
}
setSlowScriptDebugHandler
(
)
{
let
debugService
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
let
tm
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIThreadManager
)
;
function
slowScriptDebugHandler
(
tab
callback
)
{
let
target
=
TargetFactory
.
forTab
(
tab
)
;
gDevTools
.
showToolbox
(
target
"
jsdebugger
"
)
.
then
(
toolbox
=
>
{
let
threadClient
=
toolbox
.
threadClient
;
switch
(
threadClient
.
state
)
{
case
"
paused
"
:
threadClient
.
resumeThenPause
(
)
;
callback
(
)
;
break
;
case
"
attached
"
:
threadClient
.
interrupt
(
(
)
=
>
{
threadClient
.
resumeThenPause
(
)
;
callback
(
)
;
}
)
;
break
;
case
"
resuming
"
:
threadClient
.
addOneTimeListener
(
"
resumed
"
(
)
=
>
{
threadClient
.
interrupt
(
(
)
=
>
{
threadClient
.
resumeThenPause
(
)
;
callback
(
)
;
}
)
;
}
)
;
break
;
default
:
throw
Error
(
"
invalid
thread
client
state
in
slow
script
debug
handler
:
"
+
threadClient
.
state
)
;
}
}
)
;
}
debugService
.
activationHandler
=
function
(
window
)
{
let
chromeWindow
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShellTreeItem
)
.
rootTreeItem
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindow
)
.
QueryInterface
(
Ci
.
nsIDOMChromeWindow
)
;
let
setupFinished
=
false
;
slowScriptDebugHandler
(
chromeWindow
.
gBrowser
.
selectedTab
(
)
=
>
{
setupFinished
=
true
;
}
)
;
let
utils
=
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
utils
.
enterModalState
(
)
;
tm
.
spinEventLoopUntil
(
(
)
=
>
{
return
setupFinished
;
}
)
;
utils
.
leaveModalState
(
)
;
}
;
debugService
.
remoteActivationHandler
=
function
(
browser
callback
)
{
let
chromeWindow
=
browser
.
ownerDocument
.
defaultView
;
let
tab
=
chromeWindow
.
gBrowser
.
getTabForBrowser
(
browser
)
;
chromeWindow
.
gBrowser
.
selected
=
tab
;
slowScriptDebugHandler
(
tab
function
(
)
{
callback
.
finishDebuggerStartup
(
)
;
}
)
;
}
;
}
unsetSlowScriptDebugHandler
(
)
{
let
debugService
=
Cc
[
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
]
.
getService
(
Ci
.
nsISlowScriptDebug
)
;
debugService
.
activationHandler
=
undefined
;
}
_addToolToWindows
(
toolDefinition
)
{
if
(
!
toolDefinition
.
inMenu
)
{
return
;
}
try
{
if
(
toolDefinition
.
visibilityswitch
&
&
!
Services
.
prefs
.
getBoolPref
(
toolDefinition
.
visibilityswitch
)
)
{
return
;
}
}
catch
(
e
)
{
}
let
allDefs
=
gDevTools
.
getToolDefinitionArray
(
)
;
let
prevDef
;
for
(
let
def
of
allDefs
)
{
if
(
!
def
.
inMenu
)
{
continue
;
}
if
(
def
=
=
=
toolDefinition
)
{
break
;
}
prevDef
=
def
;
}
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
insertToolMenuElements
(
win
.
document
toolDefinition
prevDef
)
;
}
if
(
toolDefinition
.
id
=
=
=
"
jsdebugger
"
)
{
gDevToolsBrowser
.
setSlowScriptDebugHandler
(
)
;
}
}
hasToolboxOpened
(
win
)
{
let
tab
=
win
.
gBrowser
.
selectedTab
;
for
(
let
[
target
]
of
gDevTools
.
_toolboxes
)
{
if
(
target
.
tab
=
=
tab
)
{
return
true
;
}
}
return
false
;
}
_updateMenuCheckbox
(
)
{
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
let
hasToolbox
=
gDevToolsBrowser
.
hasToolboxOpened
(
win
)
;
let
menu
=
win
.
document
.
getElementById
(
"
menu_devToolbox
"
)
;
if
(
hasToolbox
)
{
menu
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
menu
.
removeAttribute
(
"
checked
"
)
;
}
}
}
_removeToolFromWindows
(
toolId
)
{
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
BrowserMenus
.
removeToolFromMenu
(
toolId
win
.
document
)
;
}
if
(
toolId
=
=
=
"
jsdebugger
"
)
{
gDevToolsBrowser
.
unsetSlowScriptDebugHandler
(
)
;
}
}
_forgetBrowserWindow
(
win
)
{
if
(
!
gDevToolsBrowser
.
_trackedBrowserWindows
.
has
(
win
)
)
{
return
;
}
gDevToolsBrowser
.
_trackedBrowserWindows
.
delete
(
win
)
;
win
.
removeEventListener
(
"
unload
"
this
)
;
BrowserMenus
.
removeMenus
(
win
.
document
)
;
for
(
let
[
target
toolbox
]
of
gDevTools
.
_toolboxes
)
{
if
(
target
.
tab
&
&
target
.
tab
.
ownerDocument
.
defaultView
=
=
win
)
{
toolbox
.
destroy
(
)
;
}
}
let
styleSheet
=
this
.
_browserStyleSheets
.
get
(
win
)
;
if
(
styleSheet
)
{
styleSheet
.
remove
(
)
;
this
.
_browserStyleSheets
.
delete
(
win
)
;
}
this
.
_toolbars
.
delete
(
win
)
;
let
tabContainer
=
win
.
gBrowser
.
tabContainer
;
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
)
;
tabContainer
.
removeEventListener
(
"
TabOpen
"
this
)
;
tabContainer
.
removeEventListener
(
"
TabClose
"
this
)
;
tabContainer
.
removeEventListener
(
"
TabPinned
"
this
)
;
tabContainer
.
removeEventListener
(
"
TabUnpinned
"
this
)
;
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabOpen
"
:
case
"
TabClose
"
:
case
"
TabPinned
"
:
case
"
TabUnpinned
"
:
let
open
=
0
;
let
pinned
=
0
;
for
(
let
win
of
this
.
_trackedBrowserWindows
)
{
let
tabContainer
=
win
.
gBrowser
.
tabContainer
;
let
numPinnedTabs
=
win
.
gBrowser
.
_numPinnedTabs
|
|
0
;
let
numTabs
=
tabContainer
.
itemCount
-
numPinnedTabs
;
open
+
=
numTabs
;
pinned
+
=
numPinnedTabs
;
}
this
.
_tabStats
.
histOpen
.
push
(
open
)
;
this
.
_tabStats
.
histPinned
.
push
(
pinned
)
;
this
.
_tabStats
.
peakOpen
=
Math
.
max
(
open
this
.
_tabStats
.
peakOpen
)
;
this
.
_tabStats
.
peakPinned
=
Math
.
max
(
pinned
this
.
_tabStats
.
peakPinned
)
;
break
;
case
"
TabSelect
"
:
gDevToolsBrowser
.
_updateMenuCheckbox
(
)
;
break
;
case
"
unload
"
:
gDevToolsBrowser
.
_forgetBrowserWindow
(
event
.
target
.
defaultView
)
;
break
;
}
}
destroy
(
{
shuttingDown
}
)
{
Services
.
prefs
.
removeObserver
(
"
devtools
.
"
gDevToolsBrowser
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
lightweight
-
theme
-
changed
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
quit
-
application
"
)
;
Services
.
obs
.
removeObserver
(
gDevToolsBrowser
"
sdk
:
loader
:
destroy
"
)
;
for
(
let
win
of
gDevToolsBrowser
.
_trackedBrowserWindows
)
{
gDevToolsBrowser
.
_forgetBrowserWindow
(
win
)
;
}
DebuggerServer
.
removeContentServerScript
(
)
;
gDevTools
.
destroy
(
{
shuttingDown
}
)
;
}
}
;
gDevTools
.
getToolDefinitionArray
(
)
.
forEach
(
def
=
>
gDevToolsBrowser
.
_addToolToWindows
(
def
)
)
;
gDevTools
.
on
(
"
tool
-
registered
"
function
(
ev
toolId
)
{
let
toolDefinition
=
gDevTools
.
_tools
.
get
(
toolId
)
;
if
(
toolDefinition
)
{
gDevToolsBrowser
.
_addToolToWindows
(
toolDefinition
)
;
}
}
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
function
(
ev
toolId
)
{
gDevToolsBrowser
.
_removeToolFromWindows
(
toolId
)
;
}
)
;
gDevTools
.
on
(
"
toolbox
-
ready
"
gDevToolsBrowser
.
_updateMenuCheckbox
)
;
gDevTools
.
on
(
"
toolbox
-
destroyed
"
gDevToolsBrowser
.
_updateMenuCheckbox
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
quit
-
application
"
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
browser
-
delayed
-
startup
-
finished
"
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
sdk
:
loader
:
destroy
"
)
;
Services
.
obs
.
addObserver
(
gDevToolsBrowser
"
lightweight
-
theme
-
changed
"
)
;
let
enumerator
=
Services
.
wm
.
getEnumerator
(
gDevTools
.
chromeWindowType
)
;
while
(
enumerator
.
hasMoreElements
(
)
)
{
let
win
=
enumerator
.
getNext
(
)
;
if
(
win
.
gBrowserInit
&
&
win
.
gBrowserInit
.
delayedStartupFinished
)
{
gDevToolsBrowser
.
_registerBrowserWindow
(
win
)
;
}
}
