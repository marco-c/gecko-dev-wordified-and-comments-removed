"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
function
Selection
(
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_walker
=
null
;
this
.
_isSlotted
=
false
;
this
.
_onMutations
=
this
.
_onMutations
.
bind
(
this
)
;
this
.
setNodeFront
=
this
.
setNodeFront
.
bind
(
this
)
;
}
Selection
.
prototype
=
{
_onMutations
:
function
(
mutations
)
{
let
attributeChange
=
false
;
let
pseudoChange
=
false
;
let
detached
=
false
;
let
parentNode
=
null
;
for
(
const
m
of
mutations
)
{
if
(
!
attributeChange
&
&
m
.
type
=
=
"
attributes
"
)
{
attributeChange
=
true
;
}
if
(
m
.
type
=
=
"
childList
"
)
{
if
(
!
detached
&
&
!
this
.
isConnected
(
)
)
{
if
(
this
.
isNode
(
)
)
{
parentNode
=
m
.
target
;
}
detached
=
true
;
}
}
if
(
m
.
type
=
=
"
pseudoClassLock
"
)
{
pseudoChange
=
true
;
}
}
if
(
attributeChange
)
{
this
.
emit
(
"
attribute
-
changed
"
)
;
}
if
(
pseudoChange
)
{
this
.
emit
(
"
pseudoclass
"
)
;
}
if
(
detached
)
{
this
.
emit
(
"
detached
-
front
"
parentNode
)
;
}
}
destroy
:
function
(
)
{
this
.
setWalker
(
)
;
}
setWalker
:
function
(
walker
=
null
)
{
if
(
this
.
_walker
)
{
this
.
_walker
.
off
(
"
mutations
"
this
.
_onMutations
)
;
}
this
.
_walker
=
walker
;
if
(
this
.
_walker
)
{
this
.
_walker
.
on
(
"
mutations
"
this
.
_onMutations
)
;
}
}
setNodeFront
:
function
(
nodeFront
{
reason
=
"
unknown
"
isSlotted
=
false
}
=
{
}
)
{
this
.
reason
=
reason
;
const
parentNode
=
nodeFront
&
&
nodeFront
.
parentNode
(
)
;
if
(
nodeFront
&
&
parentNode
&
&
parentNode
.
inlineTextChild
=
=
=
nodeFront
)
{
nodeFront
=
parentNode
;
}
if
(
this
.
_nodeFront
=
=
null
&
&
nodeFront
=
=
null
)
{
return
;
}
this
.
_isSlotted
=
isSlotted
;
this
.
_nodeFront
=
nodeFront
;
if
(
nodeFront
)
{
this
.
setWalker
(
nodeFront
.
walkerFront
)
;
}
else
{
this
.
setWalker
(
)
;
}
this
.
emit
(
"
new
-
node
-
front
"
nodeFront
this
.
reason
)
;
}
get
nodeFront
(
)
{
return
this
.
_nodeFront
;
}
isRoot
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
_nodeFront
.
isDocumentElement
)
;
}
isNode
:
function
(
)
{
return
!
!
this
.
_nodeFront
;
}
isConnected
:
function
(
)
{
let
node
=
this
.
_nodeFront
;
if
(
!
node
|
|
node
.
isDestroyed
(
)
)
{
return
false
;
}
while
(
node
)
{
if
(
node
=
=
=
this
.
_walker
.
rootNode
)
{
return
true
;
}
node
=
node
.
parentOrHost
(
)
;
}
return
false
;
}
isHTMLNode
:
function
(
)
{
const
xhtmlNs
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
namespaceURI
=
=
xhtmlNs
;
}
isSVGNode
:
function
(
)
{
const
svgNs
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
namespaceURI
=
=
svgNs
;
}
isMathMLNode
:
function
(
)
{
const
mathmlNs
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
;
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
namespaceURI
=
=
mathmlNs
;
}
isElementNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ELEMENT_NODE
)
;
}
isPseudoElementNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isPseudoElement
;
}
isAnonymousNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isAnonymous
;
}
isAttributeNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ATTRIBUTE_NODE
)
;
}
isTextNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
TEXT_NODE
;
}
isCDATANode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
CDATA_SECTION_NODE
)
;
}
isEntityRefNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ENTITY_REFERENCE_NODE
)
;
}
isEntityNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ENTITY_NODE
)
;
}
isProcessingInstructionNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
PROCESSING_INSTRUCTION_NODE
)
;
}
isCommentNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
PROCESSING_INSTRUCTION_NODE
)
;
}
isDocumentNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_NODE
)
;
}
isBodyNode
:
function
(
)
{
return
(
this
.
isHTMLNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
nodeFront
.
nodeName
=
=
=
"
BODY
"
)
;
}
isHeadNode
:
function
(
)
{
return
(
this
.
isHTMLNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
nodeFront
.
nodeName
=
=
=
"
HEAD
"
)
;
}
isDocumentTypeNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_TYPE_NODE
)
;
}
isDocumentFragmentNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_FRAGMENT_NODE
)
;
}
isNotationNode
:
function
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
NOTATION_NODE
)
;
}
isSlotted
:
function
(
)
{
return
this
.
_isSlotted
;
}
isShadowRootNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isShadowRoot
;
}
}
;
module
.
exports
=
Selection
;
