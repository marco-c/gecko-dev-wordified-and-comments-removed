"
use
strict
"
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
constants
.
js
"
)
;
class
Selection
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
this
.
setNodeFront
=
this
.
setNodeFront
.
bind
(
this
)
;
}
#
nodeFront
;
#
walker
=
null
;
#
isSlotted
=
false
;
#
searchQuery
;
#
onMutations
=
mutations
=
>
{
let
attributeChange
=
false
;
let
pseudoChange
=
false
;
let
detached
=
false
;
let
detachedNodeParent
=
null
;
for
(
const
m
of
mutations
)
{
if
(
m
.
type
=
=
"
attributes
"
)
{
attributeChange
=
true
;
}
if
(
m
.
type
=
=
"
pseudoClassLock
"
)
{
pseudoChange
=
true
;
}
if
(
m
.
type
=
=
"
childList
"
)
{
if
(
!
this
.
isConnected
(
)
&
&
(
m
.
removed
.
some
(
nodeFront
=
>
nodeFront
=
=
this
.
nodeFront
)
|
|
!
detachedNodeParent
)
)
{
if
(
this
.
isNode
(
)
)
{
detachedNodeParent
=
m
.
target
;
}
detached
=
true
;
}
}
}
if
(
attributeChange
)
{
this
.
emit
(
"
attribute
-
changed
"
)
;
}
if
(
pseudoChange
)
{
this
.
emit
(
"
pseudoclass
"
)
;
}
if
(
detached
)
{
this
.
emit
(
"
detached
-
front
"
detachedNodeParent
)
;
}
}
;
destroy
(
)
{
this
.
setWalker
(
)
;
this
.
#
nodeFront
=
null
;
}
setWalker
(
walker
=
null
)
{
if
(
this
.
#
walker
)
{
this
.
#
removeWalkerFrontEventListeners
(
this
.
#
walker
)
;
}
this
.
#
walker
=
walker
;
if
(
this
.
#
walker
)
{
this
.
#
setWalkerFrontEventListeners
(
this
.
#
walker
)
;
}
}
#
setWalkerFrontEventListeners
(
walker
)
{
walker
.
on
(
"
mutations
"
this
.
#
onMutations
)
;
}
#
removeWalkerFrontEventListeners
(
walker
)
{
walker
.
off
(
"
mutations
"
this
.
#
onMutations
)
;
}
onTargetDestroyed
(
targetFront
)
{
if
(
this
.
#
walker
&
&
!
targetFront
.
isTopLevel
&
&
this
.
#
walker
.
targetFront
=
=
targetFront
)
{
this
.
#
removeWalkerFrontEventListeners
(
this
.
#
walker
)
;
this
.
emit
(
"
detached
-
front
"
)
;
}
}
setNodeFront
(
nodeFront
{
reason
=
"
unknown
"
isSlotted
=
false
searchQuery
=
null
}
=
{
}
)
{
this
.
reason
=
reason
;
const
parentNode
=
nodeFront
&
&
nodeFront
.
parentNode
(
)
;
if
(
nodeFront
&
&
parentNode
&
&
parentNode
.
inlineTextChild
=
=
=
nodeFront
)
{
nodeFront
=
parentNode
;
}
if
(
this
.
#
nodeFront
=
=
null
&
&
nodeFront
=
=
null
)
{
return
;
}
this
.
emit
(
"
node
-
front
-
will
-
unset
"
)
;
this
.
#
isSlotted
=
isSlotted
;
this
.
#
searchQuery
=
searchQuery
;
this
.
#
nodeFront
=
nodeFront
;
if
(
nodeFront
)
{
this
.
setWalker
(
nodeFront
.
walkerFront
)
;
}
else
{
this
.
setWalker
(
)
;
}
this
.
emit
(
"
new
-
node
-
front
"
nodeFront
this
.
reason
)
;
}
get
nodeFront
(
)
{
return
this
.
#
nodeFront
;
}
isRoot
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
#
nodeFront
.
isDocumentElement
)
;
}
isNode
(
)
{
return
!
!
this
.
#
nodeFront
;
}
isConnected
(
)
{
let
node
=
this
.
#
nodeFront
;
if
(
!
node
|
|
node
.
isDestroyed
(
)
)
{
return
false
;
}
while
(
node
)
{
if
(
node
=
=
=
this
.
#
walker
.
rootNode
)
{
return
true
;
}
node
=
node
.
parentOrHost
(
)
;
}
return
false
;
}
isHTMLNode
(
)
{
const
xhtmlNs
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
namespaceURI
=
=
xhtmlNs
;
}
isSVGNode
(
)
{
const
svgNs
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
namespaceURI
=
=
svgNs
;
}
isMathMLNode
(
)
{
const
mathmlNs
=
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
;
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
namespaceURI
=
=
mathmlNs
;
}
isElementNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ELEMENT_NODE
)
;
}
isPseudoElementNode
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isPseudoElement
;
}
isAnonymousNode
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isAnonymous
;
}
isAttributeNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ATTRIBUTE_NODE
)
;
}
isTextNode
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
TEXT_NODE
;
}
isCDATANode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
CDATA_SECTION_NODE
)
;
}
isEntityRefNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ENTITY_REFERENCE_NODE
)
;
}
isEntityNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ENTITY_NODE
)
;
}
isProcessingInstructionNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
PROCESSING_INSTRUCTION_NODE
)
;
}
isCommentNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
PROCESSING_INSTRUCTION_NODE
)
;
}
isDocumentNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_NODE
)
;
}
isBodyNode
(
)
{
return
(
this
.
isHTMLNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
nodeFront
.
nodeName
=
=
=
"
BODY
"
)
;
}
isHeadNode
(
)
{
return
(
this
.
isHTMLNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
nodeFront
.
nodeName
=
=
=
"
HEAD
"
)
;
}
isDocumentTypeNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_TYPE_NODE
)
;
}
isDocumentFragmentNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_FRAGMENT_NODE
)
;
}
isNotationNode
(
)
{
return
(
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
NOTATION_NODE
)
;
}
isSlotted
(
)
{
return
this
.
#
isSlotted
;
}
isShadowRootNode
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isShadowRoot
;
}
supportsScrollIntoView
(
)
{
return
this
.
isElementNode
(
)
;
}
getSearchQuery
(
)
{
return
this
.
#
searchQuery
;
}
}
module
.
exports
=
Selection
;
