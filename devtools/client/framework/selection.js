"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
nodeConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
{
getRootBindingParent
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
function
Selection
(
walker
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_onMutations
=
this
.
_onMutations
.
bind
(
this
)
;
this
.
setWalker
(
walker
)
;
this
.
setNode
(
null
)
;
}
exports
.
Selection
=
Selection
;
Selection
.
prototype
=
{
_walker
:
null
_node
:
null
_onMutations
:
function
(
mutations
)
{
let
attributeChange
=
false
;
let
pseudoChange
=
false
;
let
detached
=
false
;
let
parentNode
=
null
;
for
(
let
m
of
mutations
)
{
if
(
!
attributeChange
&
&
m
.
type
=
=
"
attributes
"
)
{
attributeChange
=
true
;
}
if
(
m
.
type
=
=
"
childList
"
)
{
if
(
!
detached
&
&
!
this
.
isConnected
(
)
)
{
if
(
this
.
isNode
(
)
)
{
parentNode
=
m
.
target
;
}
detached
=
true
;
}
}
if
(
m
.
type
=
=
"
pseudoClassLock
"
)
{
pseudoChange
=
true
;
}
}
if
(
attributeChange
)
{
this
.
emit
(
"
attribute
-
changed
"
)
;
}
if
(
pseudoChange
)
{
this
.
emit
(
"
pseudoclass
"
)
;
}
if
(
detached
)
{
this
.
emit
(
"
detached
-
front
"
parentNode
)
;
}
}
destroy
:
function
(
)
{
this
.
setNode
(
null
)
;
this
.
setWalker
(
null
)
;
}
setWalker
:
function
(
walker
)
{
if
(
this
.
_walker
)
{
this
.
_walker
.
off
(
"
mutations
"
this
.
_onMutations
)
;
}
this
.
_walker
=
walker
;
if
(
this
.
_walker
)
{
this
.
_walker
.
on
(
"
mutations
"
this
.
_onMutations
)
;
}
}
setNode
:
function
(
value
reason
=
"
unknown
"
)
{
if
(
value
)
{
value
=
this
.
_walker
.
frontForRawNode
(
value
)
;
}
this
.
setNodeFront
(
value
reason
)
;
}
get
node
(
)
{
return
this
.
_node
;
}
get
document
(
)
{
if
(
this
.
isNode
(
)
)
{
return
this
.
node
.
ownerDocument
;
}
return
null
;
}
setNodeFront
:
function
(
value
reason
=
"
unknown
"
)
{
this
.
reason
=
reason
;
let
parentNode
=
value
&
&
value
.
parentNode
(
)
;
if
(
value
&
&
parentNode
&
&
parentNode
.
inlineTextChild
=
=
=
value
)
{
value
=
parentNode
;
}
let
rawValue
=
null
;
if
(
value
&
&
value
.
isLocalToBeDeprecated
(
)
)
{
rawValue
=
value
.
rawNode
(
)
;
}
this
.
emit
(
"
before
-
new
-
node
-
front
"
value
reason
)
;
this
.
_node
=
rawValue
;
this
.
_nodeFront
=
value
;
this
.
emit
(
"
new
-
node
-
front
"
value
this
.
reason
)
;
}
get
documentFront
(
)
{
return
this
.
_walker
.
document
(
this
.
_nodeFront
)
;
}
get
nodeFront
(
)
{
return
this
.
_nodeFront
;
}
isRoot
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
_nodeFront
.
isDocumentElement
;
}
isNode
:
function
(
)
{
if
(
!
this
.
_nodeFront
)
{
return
false
;
}
if
(
this
.
_node
&
&
Cu
.
isDeadWrapper
(
this
.
_node
)
)
{
return
false
;
}
return
true
;
}
isLocal
:
function
(
)
{
return
!
!
this
.
_node
;
}
isConnected
:
function
(
)
{
let
node
=
this
.
_nodeFront
;
if
(
!
node
|
|
!
node
.
actorID
)
{
return
false
;
}
let
rawNode
=
null
;
if
(
node
.
isLocalToBeDeprecated
(
)
)
{
rawNode
=
node
.
rawNode
(
)
;
}
if
(
rawNode
)
{
try
{
let
doc
=
this
.
document
;
if
(
doc
&
&
doc
.
defaultView
)
{
let
docEl
=
doc
.
documentElement
;
let
bindingParent
=
getRootBindingParent
(
rawNode
)
;
if
(
docEl
.
contains
(
bindingParent
)
)
{
return
true
;
}
}
}
catch
(
e
)
{
}
return
false
;
}
while
(
node
)
{
if
(
node
=
=
=
this
.
_walker
.
rootNode
)
{
return
true
;
}
node
=
node
.
parentNode
(
)
;
}
return
false
;
}
isHTMLNode
:
function
(
)
{
let
xhtmlNs
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
namespaceURI
=
=
xhtmlNs
;
}
isElementNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ELEMENT_NODE
;
}
isPseudoElementNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isPseudoElement
;
}
isAnonymousNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
isAnonymous
;
}
isAttributeNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ATTRIBUTE_NODE
;
}
isTextNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
TEXT_NODE
;
}
isCDATANode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
CDATA_SECTION_NODE
;
}
isEntityRefNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ENTITY_REFERENCE_NODE
;
}
isEntityNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
ENTITY_NODE
;
}
isProcessingInstructionNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
PROCESSING_INSTRUCTION_NODE
;
}
isCommentNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
PROCESSING_INSTRUCTION_NODE
;
}
isDocumentNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_NODE
;
}
isBodyNode
:
function
(
)
{
return
this
.
isHTMLNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
nodeFront
.
nodeName
=
=
=
"
BODY
"
;
}
isHeadNode
:
function
(
)
{
return
this
.
isHTMLNode
(
)
&
&
this
.
isConnected
(
)
&
&
this
.
nodeFront
.
nodeName
=
=
=
"
HEAD
"
;
}
isDocumentTypeNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_TYPE_NODE
;
}
isDocumentFragmentNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
DOCUMENT_FRAGMENT_NODE
;
}
isNotationNode
:
function
(
)
{
return
this
.
isNode
(
)
&
&
this
.
nodeFront
.
nodeType
=
=
nodeConstants
.
NOTATION_NODE
;
}
}
;
