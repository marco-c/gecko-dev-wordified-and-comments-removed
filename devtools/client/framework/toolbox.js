"
use
strict
"
;
const
SOURCE_MAP_WORKER
=
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
/
worker
.
js
"
;
const
SOURCE_MAP_WORKER_ASSETS
=
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
/
assets
/
"
;
const
MAX_ORDINAL
=
99
;
const
SPLITCONSOLE_ENABLED_PREF
=
"
devtools
.
toolbox
.
splitconsoleEnabled
"
;
const
SPLITCONSOLE_HEIGHT_PREF
=
"
devtools
.
toolbox
.
splitconsoleHeight
"
;
const
DISABLE_AUTOHIDE_PREF
=
"
ui
.
popup
.
disable_autohide
"
;
const
HOST_HISTOGRAM
=
"
DEVTOOLS_TOOLBOX_HOST
"
;
const
CURRENT_THEME_SCALAR
=
"
devtools
.
current_theme
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
var
{
Ci
Cc
}
=
require
(
"
chrome
"
)
;
var
promise
=
require
(
"
promise
"
)
;
const
{
debounce
}
=
require
(
"
devtools
/
shared
/
debounce
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
var
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
{
getUnicodeUrl
}
=
require
(
"
devtools
/
client
/
shared
/
unicode
-
url
"
)
;
var
{
attachThread
detachThread
}
=
require
(
"
.
/
attach
-
thread
"
)
;
var
{
DOMHelpers
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
DOMHelpers
.
jsm
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
var
Startup
=
Cc
[
"
mozilla
.
org
/
devtools
/
startup
-
clh
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
const
{
BrowserLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
{
}
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
loader
.
lazyRequireGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
loader
.
lazyRequireGetter
(
this
"
ZoomKeys
"
"
devtools
/
client
/
shared
/
zoom
-
keys
"
)
;
loader
.
lazyRequireGetter
(
this
"
settleAll
"
"
devtools
/
shared
/
ThreadSafeDevToolsUtils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolboxButtons
"
"
devtools
/
client
/
definitions
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SourceMapURLService
"
"
devtools
/
client
/
framework
/
source
-
map
-
url
-
service
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HUDService
"
"
devtools
/
client
/
webconsole
/
hudservice
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
viewSource
"
"
devtools
/
client
/
shared
/
view
-
source
"
)
;
loader
.
lazyRequireGetter
(
this
"
buildHarLog
"
"
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
builder
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetMonitorAPI
"
"
devtools
/
client
/
netmonitor
/
src
/
api
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
sortPanelDefinitions
"
"
devtools
/
client
/
framework
/
toolbox
-
tabs
-
order
-
manager
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createEditContextMenu
"
"
devtools
/
client
/
framework
/
toolbox
-
context
-
menu
"
true
)
;
loader
.
lazyGetter
(
this
"
domNodeConstants
"
(
)
=
>
{
return
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
registerHarOverlay
"
(
)
=
>
{
return
require
(
"
devtools
/
client
/
netmonitor
/
src
/
har
/
toolbox
-
overlay
"
)
.
register
;
}
)
;
loader
.
lazyGetter
(
this
"
reloadAndRecordTab
"
(
)
=
>
require
(
"
devtools
/
client
/
webreplay
/
menu
.
js
"
)
.
reloadAndRecordTab
)
;
loader
.
lazyGetter
(
this
"
reloadAndStopRecordingTab
"
(
)
=
>
require
(
"
devtools
/
client
/
webreplay
/
menu
.
js
"
)
.
reloadAndStopRecordingTab
)
;
loader
.
lazyGetter
(
this
"
remoteClientManager
"
(
)
=
>
require
(
"
devtools
/
client
/
shared
/
remote
-
debugging
/
remote
-
client
-
manager
.
js
"
)
.
remoteClientManager
)
;
function
Toolbox
(
target
selectedTool
hostType
contentWindow
frameId
msSinceProcessStart
)
{
this
.
_target
=
target
;
this
.
_win
=
contentWindow
;
this
.
frameId
=
frameId
;
this
.
telemetry
=
new
Telemetry
(
)
;
this
.
sessionId
=
msSinceProcessStart
;
this
.
_webExtensions
=
new
Map
(
)
;
this
.
_toolPanels
=
new
Map
(
)
;
this
.
_toolStartups
=
new
Map
(
)
;
this
.
_inspectorExtensionSidebars
=
new
Map
(
)
;
this
.
_initInspector
=
null
;
this
.
_inspector
=
null
;
this
.
_netMonitorAPI
=
null
;
this
.
frameMap
=
new
Map
(
)
;
this
.
selectedFrameId
=
null
;
this
.
_toolRegistered
=
this
.
_toolRegistered
.
bind
(
this
)
;
this
.
_toolUnregistered
=
this
.
_toolUnregistered
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_refreshHostTitle
=
this
.
_refreshHostTitle
.
bind
(
this
)
;
this
.
toggleNoAutohide
=
this
.
toggleNoAutohide
.
bind
(
this
)
;
this
.
_updateFrames
=
this
.
_updateFrames
.
bind
(
this
)
;
this
.
_splitConsoleOnKeypress
=
this
.
_splitConsoleOnKeypress
.
bind
(
this
)
;
this
.
closeToolbox
=
this
.
closeToolbox
.
bind
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_highlighterReady
=
this
.
_highlighterReady
.
bind
(
this
)
;
this
.
_highlighterHidden
=
this
.
_highlighterHidden
.
bind
(
this
)
;
this
.
_applyCacheSettings
=
this
.
_applyCacheSettings
.
bind
(
this
)
;
this
.
_applyServiceWorkersTestingSettings
=
this
.
_applyServiceWorkersTestingSettings
.
bind
(
this
)
;
this
.
_saveSplitConsoleHeight
=
this
.
_saveSplitConsoleHeight
.
bind
(
this
)
;
this
.
_onFocus
=
this
.
_onFocus
.
bind
(
this
)
;
this
.
_onBrowserMessage
=
this
.
_onBrowserMessage
.
bind
(
this
)
;
this
.
_updateTextBoxMenuItems
=
this
.
_updateTextBoxMenuItems
.
bind
(
this
)
;
this
.
_onPerformanceFrontEvent
=
this
.
_onPerformanceFrontEvent
.
bind
(
this
)
;
this
.
_onTabsOrderUpdated
=
this
.
_onTabsOrderUpdated
.
bind
(
this
)
;
this
.
_onToolbarFocus
=
this
.
_onToolbarFocus
.
bind
(
this
)
;
this
.
_onToolbarArrowKeypress
=
this
.
_onToolbarArrowKeypress
.
bind
(
this
)
;
this
.
_onPickerClick
=
this
.
_onPickerClick
.
bind
(
this
)
;
this
.
_onPickerKeypress
=
this
.
_onPickerKeypress
.
bind
(
this
)
;
this
.
_onPickerStarting
=
this
.
_onPickerStarting
.
bind
(
this
)
;
this
.
_onPickerStarted
=
this
.
_onPickerStarted
.
bind
(
this
)
;
this
.
_onPickerStopped
=
this
.
_onPickerStopped
.
bind
(
this
)
;
this
.
_onPickerCanceled
=
this
.
_onPickerCanceled
.
bind
(
this
)
;
this
.
_onInspectObject
=
this
.
_onInspectObject
.
bind
(
this
)
;
this
.
_onNewSelectedNodeFront
=
this
.
_onNewSelectedNodeFront
.
bind
(
this
)
;
this
.
_onToolSelected
=
this
.
_onToolSelected
.
bind
(
this
)
;
this
.
updateToolboxButtonsVisibility
=
this
.
updateToolboxButtonsVisibility
.
bind
(
this
)
;
this
.
updateToolboxButtons
=
this
.
updateToolboxButtons
.
bind
(
this
)
;
this
.
selectTool
=
this
.
selectTool
.
bind
(
this
)
;
this
.
_pingTelemetrySelectTool
=
this
.
_pingTelemetrySelectTool
.
bind
(
this
)
;
this
.
toggleSplitConsole
=
this
.
toggleSplitConsole
.
bind
(
this
)
;
this
.
toggleOptions
=
this
.
toggleOptions
.
bind
(
this
)
;
this
.
togglePaintFlashing
=
this
.
togglePaintFlashing
.
bind
(
this
)
;
this
.
toggleDragging
=
this
.
toggleDragging
.
bind
(
this
)
;
this
.
isPaintFlashing
=
false
;
this
.
_target
.
on
(
"
close
"
this
.
destroy
)
;
if
(
!
selectedTool
)
{
selectedTool
=
Services
.
prefs
.
getCharPref
(
this
.
_prefs
.
LAST_TOOL
)
;
}
this
.
_defaultToolId
=
selectedTool
;
this
.
_hostType
=
hostType
;
this
.
isOpen
=
new
Promise
(
function
(
resolve
)
{
this
.
_resolveIsOpen
=
resolve
;
}
.
bind
(
this
)
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
_target
.
on
(
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_target
.
on
(
"
navigate
"
this
.
_refreshHostTitle
)
;
this
.
_target
.
on
(
"
frame
-
update
"
this
.
_updateFrames
)
;
this
.
_target
.
on
(
"
inspect
-
object
"
this
.
_onInspectObject
)
;
this
.
on
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
this
.
on
(
"
select
"
this
.
_onToolSelected
)
;
gDevTools
.
on
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
loader
.
lazyGetter
(
this
"
direction
"
(
)
=
>
{
const
top
=
this
.
win
.
top
;
const
topDocEl
=
top
.
document
.
documentElement
;
const
isRtl
=
top
.
getComputedStyle
(
topDocEl
)
.
direction
=
=
=
"
rtl
"
;
return
isRtl
?
"
rtl
"
:
"
ltr
"
;
}
)
;
}
exports
.
Toolbox
=
Toolbox
;
Toolbox
.
HostType
=
{
BOTTOM
:
"
bottom
"
RIGHT
:
"
right
"
LEFT
:
"
left
"
WINDOW
:
"
window
"
CUSTOM
:
"
custom
"
}
;
Toolbox
.
prototype
=
{
_URL
:
"
about
:
devtools
-
toolbox
"
_prefs
:
{
LAST_TOOL
:
"
devtools
.
toolbox
.
selectedTool
"
SIDE_ENABLED
:
"
devtools
.
toolbox
.
sideEnabled
"
}
get
currentToolId
(
)
{
return
this
.
_currentToolId
;
}
set
currentToolId
(
id
)
{
this
.
_currentToolId
=
id
;
this
.
component
.
setCurrentToolId
(
id
)
;
}
get
defaultToolId
(
)
{
return
this
.
_defaultToolId
;
}
get
panelDefinitions
(
)
{
return
this
.
_panelDefinitions
;
}
set
panelDefinitions
(
definitions
)
{
this
.
_panelDefinitions
=
definitions
;
this
.
_combineAndSortPanelDefinitions
(
)
;
}
get
visibleAdditionalTools
(
)
{
if
(
!
this
.
_visibleAdditionalTools
)
{
this
.
_visibleAdditionalTools
=
[
]
;
}
return
this
.
_visibleAdditionalTools
;
}
set
visibleAdditionalTools
(
tools
)
{
this
.
_visibleAdditionalTools
=
tools
;
if
(
this
.
isReady
)
{
this
.
_combineAndSortPanelDefinitions
(
)
;
}
}
_combineAndSortPanelDefinitions
(
)
{
let
definitions
=
[
.
.
.
this
.
_panelDefinitions
.
.
.
this
.
getVisibleAdditionalTools
(
)
]
;
definitions
=
sortPanelDefinitions
(
definitions
)
;
this
.
component
.
setPanelDefinitions
(
definitions
)
;
}
lastUsedToolId
:
null
getToolPanels
:
function
(
)
{
return
new
Map
(
this
.
_toolPanels
)
;
}
getPanel
:
function
(
id
)
{
return
this
.
_toolPanels
.
get
(
id
)
;
}
getPanelWhenReady
:
function
(
id
)
{
const
panel
=
this
.
getPanel
(
id
)
;
return
new
Promise
(
resolve
=
>
{
if
(
panel
)
{
resolve
(
panel
)
;
}
else
{
this
.
on
(
id
+
"
-
ready
"
initializedPanel
=
>
{
resolve
(
initializedPanel
)
;
}
)
;
}
}
)
;
}
getCurrentPanel
:
function
(
)
{
return
this
.
_toolPanels
.
get
(
this
.
currentToolId
)
;
}
toggleDragging
:
function
(
)
{
this
.
doc
.
querySelector
(
"
window
"
)
.
classList
.
toggle
(
"
dragging
"
)
;
}
get
target
(
)
{
return
this
.
_target
;
}
get
threadClient
(
)
{
return
this
.
_threadClient
;
}
get
hostType
(
)
{
return
this
.
_hostType
;
}
get
win
(
)
{
return
this
.
_win
;
}
get
doc
(
)
{
return
this
.
win
.
document
;
}
get
highlighter
(
)
{
return
this
.
_highlighter
;
}
get
inspector
(
)
{
return
this
.
_inspector
;
}
get
walker
(
)
{
return
this
.
_walker
;
}
get
selection
(
)
{
return
this
.
_selection
;
}
get
splitConsole
(
)
{
return
this
.
_splitConsole
;
}
isSplitConsoleFocused
:
function
(
)
{
if
(
!
this
.
_splitConsole
)
{
return
false
;
}
const
focusedWin
=
Services
.
focus
.
focusedWindow
;
return
focusedWin
&
&
focusedWin
=
=
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
iframe
-
webconsole
"
)
.
contentWindow
;
}
open
:
function
(
)
{
return
(
async
function
(
)
{
this
.
browserRequire
=
BrowserLoader
(
{
window
:
this
.
doc
.
defaultView
useOnlyShared
:
true
}
)
.
require
;
const
isToolboxURL
=
this
.
win
.
location
.
href
.
startsWith
(
this
.
_URL
)
;
if
(
isToolboxURL
)
{
this
.
_URL
=
this
.
win
.
location
.
href
;
}
const
domHelper
=
new
DOMHelpers
(
this
.
win
)
;
const
domReady
=
new
Promise
(
resolve
=
>
{
domHelper
.
onceDOMReady
(
(
)
=
>
{
resolve
(
)
;
}
this
.
_URL
)
;
}
)
;
await
this
.
_target
.
attach
(
)
;
if
(
isToolboxURL
)
{
this
.
_showDebugTargetInfo
=
true
;
const
deviceFront
=
await
this
.
target
.
client
.
mainRoot
.
getFront
(
"
device
"
)
;
const
description
=
await
deviceFront
.
getDescription
(
)
;
const
remoteId
=
new
this
.
win
.
URLSearchParams
(
this
.
win
.
location
.
href
)
.
get
(
"
remoteId
"
)
;
const
connectionType
=
remoteClientManager
.
getConnectionTypeByRemoteId
(
remoteId
)
;
this
.
_deviceDescription
=
Object
.
assign
(
{
}
description
{
connectionType
}
)
;
}
if
(
this
.
_target
.
activeConsole
)
{
await
this
.
_target
.
activeConsole
.
startListeners
(
[
"
NetworkActivity
"
]
)
;
}
this
.
_threadClient
=
await
attachThread
(
this
)
;
await
domReady
;
this
.
isReady
=
true
;
const
framesPromise
=
this
.
_listFrames
(
)
;
Services
.
prefs
.
addObserver
(
"
devtools
.
cache
.
disabled
"
this
.
_applyCacheSettings
)
;
Services
.
prefs
.
addObserver
(
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
this
.
_applyServiceWorkersTestingSettings
)
;
this
.
doc
.
addEventListener
(
"
contextmenu
"
(
e
)
=
>
{
if
(
e
.
originalTarget
.
closest
(
"
input
[
type
=
text
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
[
type
=
search
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
:
not
(
[
type
]
)
"
)
|
|
e
.
originalTarget
.
closest
(
"
textarea
"
)
)
{
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
this
.
openTextBoxContextMenu
(
e
.
screenX
e
.
screenY
)
;
}
}
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
doc
.
defaultView
}
)
;
this
.
_componentMount
=
this
.
doc
.
getElementById
(
"
toolbox
-
toolbar
-
mount
"
)
;
this
.
_mountReactComponent
(
)
;
this
.
_buildDockOptions
(
)
;
this
.
_buildOptions
(
)
;
this
.
_buildTabs
(
)
;
this
.
_applyCacheSettings
(
)
;
this
.
_applyServiceWorkersTestingSettings
(
)
;
this
.
_addKeysToWindow
(
)
;
this
.
_addReloadKeys
(
)
;
this
.
_addHostListeners
(
)
;
this
.
_registerOverlays
(
)
;
if
(
!
this
.
_hostOptions
|
|
this
.
_hostOptions
.
zoom
=
=
=
true
)
{
ZoomKeys
.
register
(
this
.
win
)
;
}
this
.
_componentMount
.
addEventListener
(
"
keypress
"
this
.
_onToolbarArrowKeypress
)
;
this
.
_componentMount
.
setAttribute
(
"
aria
-
label
"
L10N
.
getStr
(
"
toolbox
.
label
"
)
)
;
this
.
webconsolePanel
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
webconsole
"
)
;
this
.
webconsolePanel
.
height
=
Services
.
prefs
.
getIntPref
(
SPLITCONSOLE_HEIGHT_PREF
)
;
this
.
webconsolePanel
.
addEventListener
(
"
resize
"
this
.
_saveSplitConsoleHeight
)
;
this
.
_buildButtons
(
)
;
this
.
_pingTelemetry
(
)
;
const
toolDef
=
gDevTools
.
getToolDefinition
(
this
.
_defaultToolId
)
;
if
(
!
toolDef
|
|
!
toolDef
.
isTargetSupported
(
this
.
_target
)
)
{
this
.
_defaultToolId
=
"
webconsole
"
;
}
this
.
win
.
requestIdleCallback
(
(
)
=
>
{
this
.
component
.
setCanRender
(
)
;
}
{
timeout
:
16
}
)
;
await
this
.
selectTool
(
this
.
_defaultToolId
"
initial_panel
"
)
;
const
browserWin
=
this
.
win
.
top
;
let
splitConsolePromise
=
promise
.
resolve
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
SPLITCONSOLE_ENABLED_PREF
)
)
{
splitConsolePromise
=
this
.
openSplitConsole
(
)
;
this
.
telemetry
.
addEventProperty
(
browserWin
"
open
"
"
tools
"
null
"
splitconsole
"
true
)
;
}
else
{
this
.
telemetry
.
addEventProperty
(
browserWin
"
open
"
"
tools
"
null
"
splitconsole
"
false
)
;
}
await
promise
.
all
(
[
splitConsolePromise
framesPromise
]
)
;
const
performanceFrontConnection
=
this
.
initPerformance
(
)
;
if
(
flags
.
testing
)
{
await
performanceFrontConnection
;
}
this
.
emit
(
"
ready
"
)
;
this
.
_resolveIsOpen
(
)
;
}
.
bind
(
this
)
)
(
)
.
catch
(
e
=
>
{
console
.
error
(
"
Exception
while
opening
the
toolbox
"
String
(
e
)
e
)
;
dump
(
e
.
stack
+
"
\
n
"
)
;
}
)
;
}
get
React
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
}
get
ReactDOM
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
}
get
ReactRedux
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
}
get
ToolboxController
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
framework
/
components
/
ToolboxController
"
)
;
}
_createSourceMapService
:
function
(
)
{
if
(
this
.
_sourceMapService
)
{
return
this
.
_sourceMapService
;
}
const
service
=
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
source
-
map
/
index
"
)
;
this
.
_sourceMapService
=
new
Proxy
(
service
{
get
:
(
target
name
)
=
>
{
switch
(
name
)
{
case
"
getOriginalURLs
"
:
return
(
urlInfo
)
=
>
{
return
target
.
getOriginalURLs
(
urlInfo
)
.
catch
(
text
=
>
{
const
message
=
L10N
.
getFormatStr
(
"
toolbox
.
sourceMapFailure
"
text
urlInfo
.
url
urlInfo
.
sourceMapURL
)
;
this
.
target
.
logWarningInPage
(
message
"
source
map
"
)
;
return
null
;
}
)
;
}
;
case
"
getOriginalSourceText
"
:
return
(
originalSource
)
=
>
{
return
target
.
getOriginalSourceText
(
originalSource
)
.
catch
(
text
=
>
{
const
message
=
L10N
.
getFormatStr
(
"
toolbox
.
sourceMapSourceFailure
"
text
originalSource
.
url
)
;
this
.
target
.
logWarningInPage
(
message
"
source
map
"
)
;
return
{
text
:
message
contentType
:
"
text
/
plain
"
}
;
}
)
;
}
;
case
"
applySourceMap
"
:
return
(
generatedId
url
code
mappings
)
=
>
{
return
target
.
applySourceMap
(
generatedId
url
code
mappings
)
.
then
(
result
=
>
{
if
(
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
.
sourceMapChanged
(
generatedId
url
)
;
}
return
result
;
}
)
;
}
;
default
:
return
target
[
name
]
;
}
}
}
)
;
this
.
_sourceMapService
.
startSourceMapWorker
(
SOURCE_MAP_WORKER
SOURCE_MAP_WORKER_ASSETS
)
;
return
this
.
_sourceMapService
;
}
get
sourceMapService
(
)
{
return
this
.
_createSourceMapService
(
)
;
}
get
sourceMapURLService
(
)
{
if
(
this
.
_sourceMapURLService
)
{
return
this
.
_sourceMapURLService
;
}
const
sourceMaps
=
this
.
_createSourceMapService
(
)
;
this
.
_sourceMapURLService
=
new
SourceMapURLService
(
this
sourceMaps
)
;
return
this
.
_sourceMapURLService
;
}
_getTelemetryHostId
:
function
(
)
{
switch
(
this
.
hostType
)
{
case
Toolbox
.
HostType
.
BOTTOM
:
return
0
;
case
Toolbox
.
HostType
.
RIGHT
:
return
1
;
case
Toolbox
.
HostType
.
WINDOW
:
return
2
;
case
Toolbox
.
HostType
.
CUSTOM
:
return
3
;
case
Toolbox
.
HostType
.
LEFT
:
return
4
;
default
:
return
9
;
}
}
_getTelemetryHostString
:
function
(
)
{
switch
(
this
.
hostType
)
{
case
Toolbox
.
HostType
.
BOTTOM
:
return
"
bottom
"
;
case
Toolbox
.
HostType
.
LEFT
:
return
"
left
"
;
case
Toolbox
.
HostType
.
RIGHT
:
return
"
right
"
;
case
Toolbox
.
HostType
.
WINDOW
:
return
"
window
"
;
case
Toolbox
.
HostType
.
CUSTOM
:
return
"
other
"
;
default
:
return
"
bottom
"
;
}
}
_pingTelemetry
:
function
(
)
{
this
.
telemetry
.
toolOpened
(
"
toolbox
"
this
.
sessionId
this
)
;
this
.
telemetry
.
getHistogramById
(
HOST_HISTOGRAM
)
.
add
(
this
.
_getTelemetryHostId
(
)
)
;
const
currentTheme
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
this
.
telemetry
.
keyedScalarAdd
(
CURRENT_THEME_SCALAR
currentTheme
1
)
;
const
browserWin
=
this
.
win
.
top
;
this
.
telemetry
.
preparePendingEvent
(
browserWin
"
open
"
"
tools
"
null
[
"
entrypoint
"
"
first_panel
"
"
host
"
"
shortcut
"
"
splitconsole
"
"
width
"
"
session_id
"
]
)
;
this
.
telemetry
.
addEventProperty
(
browserWin
"
open
"
"
tools
"
null
"
host
"
this
.
_getTelemetryHostString
(
)
)
;
}
_createButtonState
:
function
(
options
)
{
let
isCheckedValue
=
false
;
const
{
id
className
description
disabled
onClick
isInStartContainer
setup
teardown
isTargetSupported
isCurrentlyVisible
isChecked
onKeyDown
}
=
options
;
const
toolbox
=
this
;
const
button
=
{
id
className
description
disabled
async
onClick
(
event
)
{
if
(
typeof
onClick
=
=
"
function
"
)
{
await
onClick
(
event
toolbox
)
;
button
.
emit
(
"
updatechecked
"
)
;
}
}
onKeyDown
(
event
)
{
if
(
typeof
onKeyDown
=
=
"
function
"
)
{
onKeyDown
(
event
toolbox
)
;
}
}
isTargetSupported
isCurrentlyVisible
get
isChecked
(
)
{
if
(
typeof
isChecked
=
=
"
function
"
)
{
return
isChecked
(
toolbox
)
;
}
return
isCheckedValue
;
}
set
isChecked
(
value
)
{
isCheckedValue
=
value
;
this
.
emit
(
"
updatechecked
"
)
;
}
visibilityswitch
:
devtools
.
{
id
}
.
enabled
isInStartContainer
:
!
!
isInStartContainer
}
;
if
(
typeof
setup
=
=
"
function
"
)
{
const
onChange
=
(
)
=
>
{
button
.
emit
(
"
updatechecked
"
)
;
}
;
setup
(
this
onChange
)
;
button
.
teardown
=
teardown
.
bind
(
options
this
onChange
)
;
}
button
.
isVisible
=
this
.
_commandIsVisible
(
button
)
;
EventEmitter
.
decorate
(
button
)
;
return
button
;
}
_buildOptions
:
function
(
)
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
help
.
key
"
)
this
.
toggleOptions
)
;
}
_splitConsoleOnKeypress
:
function
(
e
)
{
if
(
e
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
this
.
toggleSplitConsole
(
)
;
if
(
this
.
_threadClient
.
state
=
=
"
paused
"
)
{
e
.
preventDefault
(
)
;
}
}
}
useKeyWithSplitConsole
:
function
(
key
handler
whichTool
)
{
this
.
shortcuts
.
on
(
key
event
=
>
{
if
(
this
.
currentToolId
=
=
=
whichTool
&
&
this
.
isSplitConsoleFocused
(
)
)
{
handler
(
)
;
event
.
preventDefault
(
)
;
}
}
)
;
}
_addReloadKeys
:
function
(
)
{
[
[
"
reload
"
false
]
[
"
reload2
"
false
]
[
"
forceReload
"
true
]
[
"
forceReload2
"
true
]
]
.
forEach
(
(
[
id
force
]
)
=
>
{
const
key
=
L10N
.
getStr
(
"
toolbox
.
"
+
id
+
"
.
key
"
)
;
this
.
shortcuts
.
on
(
key
event
=
>
{
this
.
reloadTarget
(
force
)
;
event
.
preventDefault
(
)
;
}
)
;
}
)
;
}
_addHostListeners
:
function
(
)
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
nextTool
.
key
"
)
event
=
>
{
this
.
selectNextTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
previousTool
.
key
"
)
event
=
>
{
this
.
selectPreviousTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleHost
.
key
"
)
event
=
>
{
this
.
switchToPreviousHost
(
)
;
event
.
preventDefault
(
)
;
}
)
;
const
onClose
=
event
=
>
this
.
closeToolbox
(
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleToolboxF12
.
key
"
)
onClose
)
;
if
(
this
.
hostType
=
=
"
window
"
)
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
closeToolbox
.
key
"
)
onClose
)
;
}
if
(
AppConstants
.
platform
=
=
"
macosx
"
)
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleToolboxOSX
.
key
"
)
onClose
)
;
}
else
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleToolbox
.
key
"
)
onClose
)
;
}
this
.
doc
.
addEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
)
;
this
.
doc
.
addEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
win
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
addEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
_removeHostListeners
:
function
(
)
{
if
(
this
.
doc
)
{
this
.
doc
.
removeEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
)
;
this
.
doc
.
removeEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
win
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
removeEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
}
_onBrowserMessage
:
function
(
event
)
{
if
(
event
.
data
&
&
event
.
data
.
name
=
=
=
"
switched
-
host
"
)
{
this
.
_onSwitchedHost
(
event
.
data
)
;
}
}
_registerOverlays
:
function
(
)
{
registerHarOverlay
(
this
)
;
}
_saveSplitConsoleHeight
:
function
(
)
{
Services
.
prefs
.
setIntPref
(
SPLITCONSOLE_HEIGHT_PREF
this
.
webconsolePanel
.
height
)
;
}
_refreshConsoleDisplay
:
function
(
)
{
const
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
const
webconsolePanel
=
this
.
webconsolePanel
;
const
splitter
=
this
.
doc
.
getElementById
(
"
toolbox
-
console
-
splitter
"
)
;
const
openedConsolePanel
=
this
.
currentToolId
=
=
=
"
webconsole
"
;
if
(
openedConsolePanel
)
{
deck
.
setAttribute
(
"
collapsed
"
"
true
"
)
;
splitter
.
setAttribute
(
"
hidden
"
"
true
"
)
;
webconsolePanel
.
removeAttribute
(
"
collapsed
"
)
;
}
else
{
deck
.
removeAttribute
(
"
collapsed
"
)
;
if
(
this
.
splitConsole
)
{
webconsolePanel
.
removeAttribute
(
"
collapsed
"
)
;
splitter
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
webconsolePanel
.
setAttribute
(
"
collapsed
"
"
true
"
)
;
splitter
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
}
_addKeysToWindow
:
function
(
)
{
if
(
this
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
)
{
return
;
}
for
(
const
item
of
Startup
.
KeyShortcuts
)
{
const
{
id
toolId
shortcut
modifiers
}
=
item
;
const
electronKey
=
KeyShortcuts
.
parseXulKey
(
modifiers
shortcut
)
;
if
(
id
=
=
"
browserConsole
"
)
{
this
.
shortcuts
.
on
(
electronKey
(
)
=
>
{
HUDService
.
toggleBrowserConsole
(
)
;
}
)
;
}
else
if
(
toolId
)
{
this
.
shortcuts
.
on
(
electronKey
(
)
=
>
{
this
.
selectTool
(
toolId
"
key_shortcut
"
)
.
then
(
(
)
=
>
this
.
fireCustomKey
(
toolId
)
)
;
}
)
;
}
}
}
fireCustomKey
:
function
(
toolId
)
{
const
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolDefinition
.
onkey
&
&
(
(
this
.
currentToolId
=
=
=
toolId
)
|
|
(
toolId
=
=
"
webconsole
"
&
&
this
.
splitConsole
)
)
)
{
toolDefinition
.
onkey
(
this
.
getCurrentPanel
(
)
this
)
;
}
}
get
notificationBox
(
)
{
if
(
!
this
.
_notificationBox
)
{
let
{
NotificationBox
PriorityLevels
}
=
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
)
;
NotificationBox
=
this
.
React
.
createFactory
(
NotificationBox
)
;
const
box
=
this
.
doc
.
getElementById
(
"
toolbox
-
notificationbox
"
)
;
this
.
_notificationBox
=
Object
.
assign
(
this
.
ReactDOM
.
render
(
NotificationBox
(
{
}
)
box
)
PriorityLevels
)
;
}
return
this
.
_notificationBox
;
}
_buildDockOptions
:
function
(
)
{
if
(
!
this
.
_target
.
isLocalTab
)
{
this
.
component
.
setDockOptionsEnabled
(
false
)
;
this
.
component
.
setCanCloseToolbox
(
false
)
;
return
;
}
this
.
component
.
setDockOptionsEnabled
(
true
)
;
this
.
component
.
setCanCloseToolbox
(
this
.
hostType
!
=
=
Toolbox
.
HostType
.
WINDOW
)
;
const
sideEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
_prefs
.
SIDE_ENABLED
)
;
const
hostTypes
=
[
]
;
for
(
const
type
in
Toolbox
.
HostType
)
{
const
position
=
Toolbox
.
HostType
[
type
]
;
if
(
position
=
=
Toolbox
.
HostType
.
CUSTOM
|
|
(
!
sideEnabled
&
&
(
position
=
=
Toolbox
.
HostType
.
LEFT
|
|
position
=
=
Toolbox
.
HostType
.
RIGHT
)
)
)
{
continue
;
}
hostTypes
.
push
(
{
position
switchHost
:
this
.
switchHost
.
bind
(
this
position
)
}
)
;
}
this
.
component
.
setCurrentHostType
(
this
.
hostType
)
;
this
.
component
.
setHostTypes
(
hostTypes
)
;
}
postMessage
:
function
(
msg
)
{
if
(
this
.
win
.
parent
)
{
msg
.
frameId
=
this
.
frameId
;
this
.
win
.
parent
.
postMessage
(
msg
"
*
"
)
;
}
}
_buildTabs
:
async
function
(
)
{
const
definitions
=
gDevTools
.
getToolDefinitionArray
(
)
;
definitions
.
forEach
(
definition
=
>
this
.
_buildPanelForTool
(
definition
)
)
;
this
.
panelDefinitions
=
definitions
.
filter
(
definition
=
>
definition
.
isTargetSupported
(
this
.
_target
)
&
&
definition
.
id
!
=
=
"
options
"
)
;
if
(
this
.
disableAutohideAvailable
)
{
const
disable
=
await
this
.
_isDisableAutohideEnabled
(
)
;
this
.
component
.
setDisableAutohide
(
disable
)
;
}
}
_mountReactComponent
:
function
(
)
{
const
element
=
this
.
React
.
createElement
(
this
.
ToolboxController
{
L10N
currentToolId
:
this
.
currentToolId
selectTool
:
this
.
selectTool
toggleOptions
:
this
.
toggleOptions
toggleSplitConsole
:
this
.
toggleSplitConsole
toggleNoAutohide
:
this
.
toggleNoAutohide
closeToolbox
:
this
.
closeToolbox
focusButton
:
this
.
_onToolbarFocus
toolbox
:
this
showDebugTargetInfo
:
this
.
_showDebugTargetInfo
deviceDescription
:
this
.
_deviceDescription
onTabsOrderUpdated
:
this
.
_onTabsOrderUpdated
}
)
;
this
.
component
=
this
.
ReactDOM
.
render
(
element
this
.
_componentMount
)
;
}
_onToolbarFocus
:
function
(
id
)
{
this
.
component
.
setFocusedButton
(
id
)
;
}
_onToolbarArrowKeypress
:
function
(
event
)
{
const
{
key
target
ctrlKey
shiftKey
altKey
metaKey
}
=
event
;
if
(
ctrlKey
|
|
shiftKey
|
|
altKey
|
|
metaKey
)
{
return
;
}
const
buttons
=
[
.
.
.
this
.
_componentMount
.
querySelectorAll
(
"
button
"
)
]
;
const
curIndex
=
buttons
.
indexOf
(
target
)
;
if
(
curIndex
=
=
=
-
1
)
{
console
.
warn
(
target
+
"
is
not
found
among
Developer
Tools
tab
bar
"
+
"
focusable
elements
.
"
)
;
return
;
}
let
newTarget
;
if
(
key
=
=
=
"
ArrowLeft
"
)
{
if
(
curIndex
=
=
=
0
)
{
return
;
}
newTarget
=
buttons
[
curIndex
-
1
]
;
}
else
if
(
key
=
=
=
"
ArrowRight
"
)
{
if
(
curIndex
=
=
=
buttons
.
length
-
1
)
{
return
;
}
newTarget
=
buttons
[
curIndex
+
1
]
;
}
else
{
return
;
}
newTarget
.
focus
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
_buildButtons
(
)
{
this
.
toolbarButtons
=
[
this
.
_buildPickerButton
(
)
this
.
_buildFrameButton
(
)
]
;
ToolboxButtons
.
forEach
(
definition
=
>
{
const
button
=
this
.
_createButtonState
(
definition
)
;
this
.
toolbarButtons
.
push
(
button
)
;
}
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
_buildFrameButton
(
)
{
this
.
frameButton
=
this
.
_createButtonState
(
{
id
:
"
command
-
button
-
frames
"
description
:
L10N
.
getStr
(
"
toolbox
.
frames
.
tooltip
"
)
isTargetSupported
:
target
=
>
{
return
target
.
activeTab
&
&
target
.
activeTab
.
traits
.
frames
;
}
isCurrentlyVisible
:
(
)
=
>
{
const
hasFrames
=
this
.
frameMap
.
size
>
1
;
const
isOnOptionsPanel
=
this
.
currentToolId
=
=
=
"
options
"
;
return
hasFrames
|
|
isOnOptionsPanel
;
}
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
showFrames
.
key
"
)
event
=
>
{
if
(
event
.
target
.
id
=
=
=
"
command
-
button
-
frames
"
)
{
event
.
target
.
click
(
)
;
}
}
)
;
return
this
.
frameButton
;
}
_onPickerClick
:
async
function
(
)
{
const
focus
=
this
.
hostType
=
=
=
Toolbox
.
HostType
.
BOTTOM
|
|
this
.
hostType
=
=
=
Toolbox
.
HostType
.
LEFT
|
|
this
.
hostType
=
=
=
Toolbox
.
HostType
.
RIGHT
;
const
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
.
togglePicker
)
{
currentPanel
.
togglePicker
(
focus
)
;
}
else
{
if
(
!
this
.
inspector
)
{
await
this
.
initInspector
(
)
;
}
this
.
inspector
.
nodePicker
.
togglePicker
(
focus
)
;
}
}
_onPickerKeypress
:
function
(
event
)
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
const
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
.
cancelPicker
)
{
currentPanel
.
cancelPicker
(
)
;
}
else
{
this
.
inspector
.
nodePicker
.
cancel
(
)
;
}
event
.
stopImmediatePropagation
(
)
;
}
}
_onPickerStarting
:
async
function
(
)
{
this
.
pickerButton
.
isChecked
=
true
;
await
this
.
selectTool
(
"
inspector
"
"
inspect_dom
"
)
;
this
.
on
(
"
select
"
this
.
inspector
.
nodePicker
.
stop
)
;
}
_onPickerStarted
:
async
function
(
)
{
this
.
doc
.
addEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
}
_onPickerStopped
:
function
(
)
{
this
.
off
(
"
select
"
this
.
inspector
.
nodePicker
.
stop
)
;
this
.
doc
.
removeEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
this
.
pickerButton
.
isChecked
=
false
;
}
_onPickerCanceled
:
function
(
)
{
this
.
win
.
focus
(
)
;
}
_buildPickerButton
(
)
{
this
.
pickerButton
=
this
.
_createButtonState
(
{
id
:
"
command
-
button
-
pick
"
description
:
L10N
.
getStr
(
"
pickButton
.
tooltip
"
)
onClick
:
this
.
_onPickerClick
isInStartContainer
:
true
isTargetSupported
:
target
=
>
{
return
target
.
activeTab
&
&
target
.
activeTab
.
traits
.
frames
;
}
}
)
;
return
this
.
pickerButton
;
}
_applyCacheSettings
:
async
function
(
)
{
const
pref
=
"
devtools
.
cache
.
disabled
"
;
const
cacheDisabled
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
if
(
this
.
target
.
activeTab
)
{
await
this
.
target
.
activeTab
.
reconfigure
(
{
options
:
{
"
cacheDisabled
"
:
cacheDisabled
}
}
)
;
if
(
flags
.
testing
)
{
this
.
emit
(
"
cache
-
reconfigured
"
)
;
}
}
}
_applyServiceWorkersTestingSettings
:
function
(
)
{
const
pref
=
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
;
const
serviceWorkersTestingEnabled
=
Services
.
prefs
.
getBoolPref
(
pref
)
|
|
false
;
if
(
this
.
target
.
activeTab
)
{
this
.
target
.
activeTab
.
reconfigure
(
{
options
:
{
"
serviceWorkersTestingEnabled
"
:
serviceWorkersTestingEnabled
}
}
)
;
}
}
updateToolboxButtonsVisibility
(
)
{
this
.
toolbarButtons
.
forEach
(
button
=
>
{
button
.
isVisible
=
this
.
_commandIsVisible
(
button
)
;
}
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
updateToolboxButtons
(
)
{
const
inspector
=
this
.
inspector
;
const
hasHighlighters
=
inspector
&
&
(
inspector
.
hasHighlighter
(
"
RulersHighlighter
"
)
|
|
inspector
.
hasHighlighter
(
"
MeasuringToolHighlighter
"
)
)
;
if
(
hasHighlighters
|
|
this
.
isPaintFlashing
)
{
if
(
this
.
isPaintFlashing
)
{
this
.
togglePaintFlashing
(
)
;
}
if
(
hasHighlighters
)
{
inspector
.
destroyHighlighters
(
)
;
}
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
}
togglePaintFlashing
:
function
(
)
{
if
(
this
.
isPaintFlashing
)
{
this
.
telemetry
.
toolOpened
(
"
paintflashing
"
this
.
sessionId
this
)
;
}
else
{
this
.
telemetry
.
toolClosed
(
"
paintflashing
"
this
.
sessionId
this
)
;
}
this
.
isPaintFlashing
=
!
this
.
isPaintFlashing
;
return
this
.
target
.
activeTab
.
reconfigure
(
{
options
:
{
"
paintFlashing
"
:
this
.
isPaintFlashing
}
}
)
;
}
updatePickerButton
(
)
{
const
button
=
this
.
pickerButton
;
const
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
&
&
currentPanel
.
updatePickerButton
)
{
currentPanel
.
updatePickerButton
(
)
;
}
else
{
button
.
description
=
L10N
.
getStr
(
"
pickButton
.
tooltip
"
)
;
button
.
className
=
null
;
button
.
disabled
=
null
;
}
}
updateFrameButton
(
)
{
if
(
this
.
currentToolId
=
=
=
"
options
"
&
&
this
.
frameMap
.
size
<
=
1
)
{
this
.
frameButton
.
disabled
=
true
;
this
.
frameButton
.
description
=
L10N
.
getStr
(
"
toolbox
.
frames
.
disabled
.
tooltip
"
)
;
}
else
{
this
.
frameButton
.
disabled
=
false
;
this
.
frameButton
.
description
=
L10N
.
getStr
(
"
toolbox
.
frames
.
tooltip
"
)
;
}
const
selectedFrame
=
this
.
frameMap
.
get
(
this
.
selectedFrameId
)
|
|
{
}
;
const
isVisible
=
this
.
_commandIsVisible
(
this
.
frameButton
)
;
this
.
frameButton
.
isVisible
=
isVisible
;
if
(
isVisible
)
{
this
.
frameButton
.
isChecked
=
selectedFrame
.
parentID
!
=
null
;
}
}
_commandIsVisible
:
function
(
button
)
{
const
{
isTargetSupported
isCurrentlyVisible
visibilityswitch
}
=
button
;
if
(
!
Services
.
prefs
.
getBoolPref
(
visibilityswitch
true
)
)
{
return
false
;
}
if
(
isTargetSupported
&
&
!
isTargetSupported
(
this
.
target
)
)
{
return
false
;
}
if
(
isCurrentlyVisible
&
&
!
isCurrentlyVisible
(
)
)
{
return
false
;
}
return
true
;
}
_buildPanelForTool
:
function
(
toolDefinition
)
{
if
(
!
toolDefinition
.
isTargetSupported
(
this
.
_target
)
)
{
return
;
}
const
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
const
id
=
toolDefinition
.
id
;
if
(
toolDefinition
.
ordinal
=
=
undefined
|
|
toolDefinition
.
ordinal
<
0
)
{
toolDefinition
.
ordinal
=
MAX_ORDINAL
;
}
if
(
!
toolDefinition
.
bgTheme
)
{
toolDefinition
.
bgTheme
=
"
theme
-
toolbar
"
;
}
const
panel
=
this
.
doc
.
createXULElement
(
"
vbox
"
)
;
panel
.
className
=
"
toolbox
-
panel
"
+
toolDefinition
.
bgTheme
;
if
(
!
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
)
{
panel
.
id
=
"
toolbox
-
panel
-
"
+
id
;
}
deck
.
appendChild
(
panel
)
;
if
(
toolDefinition
.
buildToolStartup
&
&
!
this
.
_toolStartups
.
has
(
id
)
)
{
this
.
_toolStartups
.
set
(
id
toolDefinition
.
buildToolStartup
(
this
)
)
;
}
this
.
_addKeysToWindow
(
)
;
}
get
additionalToolDefinitions
(
)
{
if
(
!
this
.
_additionalToolDefinitions
)
{
this
.
_additionalToolDefinitions
=
new
Map
(
)
;
}
return
this
.
_additionalToolDefinitions
;
}
getAdditionalTools
(
)
{
if
(
this
.
_additionalToolDefinitions
)
{
return
Array
.
from
(
this
.
additionalToolDefinitions
.
values
(
)
)
;
}
return
[
]
;
}
getVisibleAdditionalTools
(
)
{
return
this
.
visibleAdditionalTools
.
map
(
toolId
=
>
this
.
additionalToolDefinitions
.
get
(
toolId
)
)
;
}
hasAdditionalTool
(
toolId
)
{
return
this
.
additionalToolDefinitions
.
has
(
toolId
)
;
}
addAdditionalTool
(
definition
)
{
if
(
!
definition
.
id
)
{
throw
new
Error
(
"
Tool
definition
id
is
missing
"
)
;
}
if
(
this
.
isToolRegistered
(
definition
.
id
)
)
{
throw
new
Error
(
"
Tool
definition
already
registered
:
"
+
definition
.
id
)
;
}
this
.
additionalToolDefinitions
.
set
(
definition
.
id
definition
)
;
this
.
visibleAdditionalTools
=
[
.
.
.
this
.
visibleAdditionalTools
definition
.
id
]
;
const
buildPanel
=
(
)
=
>
this
.
_buildPanelForTool
(
definition
)
;
if
(
this
.
isReady
)
{
buildPanel
(
)
;
}
else
{
this
.
once
(
"
ready
"
buildPanel
)
;
}
}
get
inspectorExtensionSidebars
(
)
{
return
this
.
_inspectorExtensionSidebars
;
}
async
registerInspectorExtensionSidebar
(
id
options
)
{
this
.
_inspectorExtensionSidebars
.
set
(
id
options
)
;
if
(
!
this
.
_inspector
)
{
return
;
}
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
inspector
.
addExtensionSidebar
(
id
options
)
;
}
unregisterInspectorExtensionSidebar
(
id
)
{
if
(
this
.
_destroyer
)
{
return
;
}
const
sidebarDef
=
this
.
_inspectorExtensionSidebars
.
get
(
id
)
;
if
(
!
sidebarDef
)
{
return
;
}
this
.
_inspectorExtensionSidebars
.
delete
(
id
)
;
if
(
!
this
.
_inspector
)
{
return
;
}
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
inspector
.
removeExtensionSidebar
(
id
)
;
}
removeAdditionalTool
(
toolId
)
{
if
(
this
.
_destroyer
)
{
return
;
}
if
(
!
this
.
hasAdditionalTool
(
toolId
)
)
{
throw
new
Error
(
"
Tool
definition
not
registered
to
this
toolbox
:
"
+
toolId
)
;
}
this
.
additionalToolDefinitions
.
delete
(
toolId
)
;
this
.
visibleAdditionalTools
=
this
.
visibleAdditionalTools
.
filter
(
id
=
>
id
!
=
=
toolId
)
;
this
.
unloadTool
(
toolId
)
;
}
loadTool
:
function
(
id
)
{
if
(
id
=
=
=
"
inspector
"
&
&
!
this
.
_inspector
)
{
this
.
initInspector
(
)
;
}
let
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
iframe
)
{
const
panel
=
this
.
_toolPanels
.
get
(
id
)
;
return
new
Promise
(
resolve
=
>
{
if
(
panel
)
{
resolve
(
panel
)
;
}
else
{
this
.
once
(
id
+
"
-
ready
"
initializedPanel
=
>
{
resolve
(
initializedPanel
)
;
}
)
;
}
}
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
definition
=
this
.
getToolDefinition
(
id
)
;
if
(
!
definition
)
{
reject
(
new
Error
(
"
no
such
tool
id
"
+
id
)
)
;
return
;
}
iframe
=
this
.
doc
.
createXULElement
(
"
iframe
"
)
;
iframe
.
className
=
"
toolbox
-
panel
-
iframe
"
;
iframe
.
id
=
"
toolbox
-
panel
-
iframe
-
"
+
id
;
iframe
.
setAttribute
(
"
flex
"
1
)
;
iframe
.
setAttribute
(
"
forceOwnRefreshDriver
"
"
"
)
;
iframe
.
tooltip
=
"
aHTMLTooltip
"
;
iframe
.
style
.
visibility
=
"
hidden
"
;
gDevTools
.
emit
(
id
+
"
-
init
"
this
iframe
)
;
this
.
emit
(
id
+
"
-
init
"
iframe
)
;
if
(
!
iframe
.
parentNode
)
{
const
vbox
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
;
vbox
.
appendChild
(
iframe
)
;
vbox
.
visibility
=
"
visible
"
;
}
const
onLoad
=
async
(
)
=
>
{
if
(
id
=
=
=
"
inspector
"
)
{
await
this
.
_initInspector
;
if
(
this
.
_destroyingInspector
)
{
return
;
}
}
iframe
.
style
.
visibility
=
"
visible
"
;
this
.
setIframeDocumentDir
(
iframe
)
;
let
built
=
definition
.
build
(
iframe
.
contentWindow
this
)
;
if
(
!
(
typeof
built
.
then
=
=
"
function
"
)
)
{
const
panel
=
built
;
iframe
.
panel
=
panel
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
build
"
this
panel
)
;
this
.
emit
(
id
+
"
-
build
"
panel
)
;
if
(
typeof
panel
.
open
=
=
"
function
"
)
{
built
=
panel
.
open
(
)
;
}
else
{
built
=
new
Promise
(
resolve
=
>
{
resolve
(
panel
)
;
}
)
;
}
}
promise
.
resolve
(
built
)
.
then
(
(
panel
)
=
>
{
this
.
_toolPanels
.
set
(
id
panel
)
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
ready
"
this
panel
)
;
this
.
emit
(
id
+
"
-
ready
"
panel
)
;
resolve
(
panel
)
;
}
console
.
error
)
;
}
;
iframe
.
setAttribute
(
"
src
"
definition
.
url
)
;
if
(
definition
.
panelLabel
)
{
iframe
.
setAttribute
(
"
aria
-
label
"
definition
.
panelLabel
)
;
}
if
(
iframe
.
contentWindow
)
{
const
domHelper
=
new
DOMHelpers
(
iframe
.
contentWindow
)
;
domHelper
.
onceDOMReady
(
onLoad
)
;
}
else
{
const
callback
=
(
)
=
>
{
iframe
.
removeEventListener
(
"
DOMContentLoaded
"
callback
)
;
onLoad
(
)
;
}
;
iframe
.
addEventListener
(
"
DOMContentLoaded
"
callback
)
;
}
}
)
;
}
setIframeDocumentDir
:
function
(
iframe
)
{
const
docEl
=
iframe
.
contentWindow
&
&
iframe
.
contentWindow
.
document
.
documentElement
;
if
(
!
docEl
|
|
docEl
.
namespaceURI
!
=
=
HTML_NS
)
{
return
;
}
if
(
docEl
.
hasAttribute
(
"
dir
"
)
)
{
docEl
.
setAttribute
(
"
dir
"
this
.
direction
)
;
}
}
selectSingleNode
:
function
(
collection
id
)
{
[
.
.
.
collection
]
.
forEach
(
node
=
>
{
if
(
node
.
id
=
=
=
id
)
{
node
.
setAttribute
(
"
selected
"
"
true
"
)
;
node
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
}
else
{
node
.
removeAttribute
(
"
selected
"
)
;
node
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
if
(
!
node
.
id
)
{
node
=
this
.
webconsolePanel
;
}
const
iframe
=
node
.
querySelector
(
"
.
toolbox
-
panel
-
iframe
"
)
;
if
(
iframe
)
{
let
visible
=
node
.
id
=
=
id
;
if
(
node
=
=
this
.
webconsolePanel
&
&
this
.
splitConsole
)
{
visible
=
true
;
}
this
.
setIframeVisible
(
iframe
visible
)
;
}
}
)
;
}
setIframeVisible
:
function
(
iframe
visible
)
{
const
state
=
visible
?
"
visible
"
:
"
hidden
"
;
const
win
=
iframe
.
contentWindow
;
const
doc
=
win
.
document
;
if
(
doc
.
visibilityState
!
=
state
)
{
Object
.
defineProperty
(
doc
"
visibilityState
"
{
value
:
state
configurable
:
true
}
)
;
doc
.
dispatchEvent
(
new
win
.
Event
(
"
visibilitychange
"
)
)
;
}
}
selectTool
:
function
(
id
reason
=
"
unknown
"
)
{
this
.
emit
(
"
panel
-
changed
"
)
;
if
(
this
.
currentToolId
=
=
id
)
{
const
panel
=
this
.
_toolPanels
.
get
(
id
)
;
if
(
panel
)
{
this
.
focusTool
(
id
)
;
return
promise
.
resolve
(
panel
)
;
}
return
this
.
once
(
"
select
"
)
.
then
(
(
)
=
>
promise
.
resolve
(
this
.
_toolPanels
.
get
(
id
)
)
)
;
}
if
(
!
this
.
isReady
)
{
throw
new
Error
(
"
Can
'
t
select
tool
wait
for
toolbox
'
ready
'
event
"
)
;
}
if
(
this
.
panelDefinitions
.
find
(
(
definition
)
=
>
definition
.
id
=
=
=
id
)
|
|
id
=
=
=
"
options
"
|
|
this
.
additionalToolDefinitions
.
get
(
id
)
)
{
if
(
this
.
currentToolId
)
{
this
.
telemetry
.
toolClosed
(
this
.
currentToolId
this
.
sessionId
this
)
;
}
this
.
_pingTelemetrySelectTool
(
id
reason
)
;
}
else
{
throw
new
Error
(
"
No
tool
found
"
)
;
}
const
toolboxPanels
=
this
.
doc
.
querySelectorAll
(
"
.
toolbox
-
panel
"
)
;
this
.
selectSingleNode
(
toolboxPanels
"
toolbox
-
panel
-
"
+
id
)
;
this
.
lastUsedToolId
=
this
.
currentToolId
;
this
.
currentToolId
=
id
;
this
.
_refreshConsoleDisplay
(
)
;
if
(
id
!
=
"
options
"
)
{
Services
.
prefs
.
setCharPref
(
this
.
_prefs
.
LAST_TOOL
id
)
;
}
return
this
.
loadTool
(
id
)
.
then
(
panel
=
>
{
this
.
focusTool
(
id
)
;
this
.
emit
(
"
select
"
id
)
;
this
.
emit
(
id
+
"
-
selected
"
panel
)
;
return
panel
;
}
)
;
}
_pingTelemetrySelectTool
(
id
reason
)
{
const
width
=
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
;
const
panelName
=
this
.
getTelemetryPanelNameOrOther
(
id
)
;
const
prevPanelName
=
this
.
getTelemetryPanelNameOrOther
(
this
.
currentToolId
)
;
const
cold
=
!
this
.
getPanel
(
id
)
;
const
pending
=
[
"
host
"
"
width
"
"
start_state
"
"
panel_name
"
"
cold
"
"
session_id
"
]
;
if
(
this
.
currentToolId
)
{
this
.
telemetry
.
recordEvent
(
"
exit
"
prevPanelName
null
{
"
host
"
:
this
.
_hostType
"
width
"
:
width
"
panel_name
"
:
prevPanelName
"
next_panel
"
:
panelName
"
reason
"
:
reason
"
session_id
"
:
this
.
sessionId
}
)
;
}
const
browserWin
=
this
.
win
.
top
;
this
.
telemetry
.
addEventProperties
(
browserWin
"
open
"
"
tools
"
null
{
"
width
"
:
width
"
session_id
"
:
this
.
sessionId
}
)
;
if
(
id
=
=
=
"
webconsole
"
)
{
pending
.
push
(
"
message_count
"
)
;
}
this
.
telemetry
.
preparePendingEvent
(
this
"
enter
"
panelName
null
pending
)
;
this
.
telemetry
.
addEventProperties
(
this
"
enter
"
panelName
null
{
"
host
"
:
this
.
_hostType
"
start_state
"
:
reason
"
panel_name
"
:
panelName
"
cold
"
:
cold
"
session_id
"
:
this
.
sessionId
}
)
;
if
(
reason
!
=
=
"
initial_panel
"
)
{
const
width
=
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
;
this
.
telemetry
.
addEventProperty
(
this
"
enter
"
panelName
null
"
width
"
width
)
;
}
if
(
!
cold
&
&
id
=
=
=
"
webconsole
"
)
{
this
.
telemetry
.
addEventProperty
(
this
"
enter
"
"
webconsole
"
null
"
message_count
"
0
)
;
}
this
.
telemetry
.
toolOpened
(
id
this
.
sessionId
this
)
;
}
focusTool
:
function
(
id
state
=
true
)
{
const
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
state
)
{
iframe
.
focus
(
)
;
}
else
{
iframe
.
blur
(
)
;
}
}
focusConsoleInput
:
function
(
)
{
const
consolePanel
=
this
.
getPanel
(
"
webconsole
"
)
;
if
(
consolePanel
)
{
consolePanel
.
focusInput
(
)
;
}
}
_onFocus
:
function
(
{
originalTarget
}
)
{
const
webconsoleURL
=
gDevTools
.
getToolDefinition
(
"
webconsole
"
)
.
url
;
if
(
originalTarget
.
nodeType
!
=
=
1
|
|
originalTarget
.
baseURI
=
=
=
webconsoleURL
)
{
return
;
}
this
.
_lastFocusedElement
=
originalTarget
;
}
_onTabsOrderUpdated
:
function
(
)
{
this
.
_combineAndSortPanelDefinitions
(
)
;
}
openSplitConsole
:
function
(
)
{
this
.
_splitConsole
=
true
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_ENABLED_PREF
true
)
;
this
.
_refreshConsoleDisplay
(
)
;
const
iframe
=
this
.
webconsolePanel
.
querySelector
(
"
.
toolbox
-
panel
-
iframe
"
)
;
if
(
iframe
)
{
this
.
setIframeVisible
(
iframe
true
)
;
}
return
this
.
loadTool
(
"
webconsole
"
)
.
then
(
(
)
=
>
{
this
.
component
.
setIsSplitConsoleActive
(
true
)
;
this
.
telemetry
.
recordEvent
(
"
activate
"
"
split_console
"
null
{
"
host
"
:
this
.
_getTelemetryHostString
(
)
"
width
"
:
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
"
session_id
"
:
this
.
sessionId
}
)
;
this
.
emit
(
"
split
-
console
"
)
;
this
.
focusConsoleInput
(
)
;
}
)
;
}
closeSplitConsole
:
function
(
)
{
this
.
_splitConsole
=
false
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_ENABLED_PREF
false
)
;
this
.
_refreshConsoleDisplay
(
)
;
this
.
component
.
setIsSplitConsoleActive
(
false
)
;
this
.
telemetry
.
recordEvent
(
"
deactivate
"
"
split_console
"
null
{
"
host
"
:
this
.
_getTelemetryHostString
(
)
"
width
"
:
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
"
session_id
"
:
this
.
sessionId
}
)
;
this
.
emit
(
"
split
-
console
"
)
;
if
(
this
.
_lastFocusedElement
)
{
this
.
_lastFocusedElement
.
focus
(
)
;
}
return
promise
.
resolve
(
)
;
}
toggleSplitConsole
:
function
(
)
{
if
(
this
.
currentToolId
!
=
=
"
webconsole
"
)
{
return
this
.
splitConsole
?
this
.
closeSplitConsole
(
)
:
this
.
openSplitConsole
(
)
;
}
return
promise
.
resolve
(
)
;
}
toggleOptions
:
function
(
)
{
if
(
this
.
currentToolId
=
=
=
"
options
"
&
&
gDevTools
.
getToolDefinition
(
this
.
lastUsedToolId
)
)
{
this
.
selectTool
(
this
.
lastUsedToolId
"
toggle_settings_off
"
)
;
}
else
{
this
.
selectTool
(
"
options
"
"
toggle_settings_on
"
)
;
}
}
reloadTarget
:
function
(
force
)
{
if
(
this
.
target
.
canRewind
)
{
reloadAndRecordTab
(
)
;
}
else
{
this
.
target
.
activeTab
.
reload
(
{
force
:
force
}
)
;
}
}
selectNextTool
:
function
(
)
{
const
definitions
=
this
.
component
.
panelDefinitions
;
const
index
=
definitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
this
.
currentToolId
)
;
const
definition
=
index
=
=
=
-
1
|
|
index
>
=
definitions
.
length
-
1
?
definitions
[
0
]
:
definitions
[
index
+
1
]
;
return
this
.
selectTool
(
definition
.
id
"
select_next_key
"
)
;
}
selectPreviousTool
:
function
(
)
{
const
definitions
=
this
.
component
.
panelDefinitions
;
const
index
=
definitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
this
.
currentToolId
)
;
const
definition
=
index
=
=
=
-
1
|
|
index
<
1
?
definitions
[
definitions
.
length
-
1
]
:
definitions
[
index
-
1
]
;
return
this
.
selectTool
(
definition
.
id
"
select_prev_key
"
)
;
}
async
isToolHighlighted
(
id
)
{
if
(
!
this
.
component
)
{
await
this
.
isOpen
;
}
return
this
.
component
.
isToolHighlighted
(
id
)
;
}
async
highlightTool
(
id
)
{
if
(
!
this
.
component
)
{
await
this
.
isOpen
;
}
this
.
component
.
highlightTool
(
id
)
;
}
async
unhighlightTool
(
id
)
{
if
(
!
this
.
component
)
{
await
this
.
isOpen
;
}
this
.
component
.
unhighlightTool
(
id
)
;
}
raise
:
function
(
)
{
this
.
postMessage
(
{
name
:
"
raise
-
host
"
}
)
;
}
async
_onWillNavigate
(
)
{
this
.
updateToolboxButtons
(
)
;
const
toolId
=
this
.
currentToolId
;
if
(
toolId
!
=
"
inspector
"
&
&
toolId
!
=
"
webconsole
"
&
&
toolId
!
=
"
netmonitor
"
)
{
return
;
}
const
start
=
this
.
win
.
performance
.
now
(
)
;
const
panel
=
this
.
getPanel
(
toolId
)
;
if
(
!
panel
)
{
return
;
}
await
panel
.
once
(
"
reloaded
"
)
;
const
delay
=
this
.
win
.
performance
.
now
(
)
-
start
;
const
telemetryKey
=
"
DEVTOOLS_TOOLBOX_PAGE_RELOAD_DELAY_MS
"
;
this
.
telemetry
.
getKeyedHistogramById
(
telemetryKey
)
.
add
(
toolId
delay
)
;
}
_refreshHostTitle
:
function
(
)
{
let
title
;
if
(
this
.
target
.
name
&
&
this
.
target
.
name
!
=
this
.
target
.
url
)
{
const
url
=
this
.
target
.
isWebExtension
?
this
.
target
.
getExtensionPathName
(
this
.
target
.
url
)
:
getUnicodeUrl
(
this
.
target
.
url
)
;
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate2
"
this
.
target
.
name
url
)
;
}
else
{
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate1
"
getUnicodeUrl
(
this
.
target
.
url
)
)
;
}
this
.
postMessage
(
{
name
:
"
set
-
host
-
title
"
title
}
)
;
}
get
preferenceFront
(
)
{
const
frontPromise
=
this
.
target
.
client
.
mainRoot
.
getFront
(
"
preference
"
)
;
frontPromise
.
then
(
front
=
>
{
this
.
_preferenceFront
=
front
;
}
)
;
return
frontPromise
;
}
get
disableAutohideAvailable
(
)
{
return
this
.
_target
.
chrome
;
}
async
toggleNoAutohide
(
)
{
const
front
=
await
this
.
preferenceFront
;
const
toggledValue
=
!
(
await
this
.
_isDisableAutohideEnabled
(
)
)
;
front
.
setBoolPref
(
DISABLE_AUTOHIDE_PREF
toggledValue
)
;
if
(
this
.
disableAutohideAvailable
)
{
this
.
component
.
setDisableAutohide
(
toggledValue
)
;
}
this
.
_autohideHasBeenToggled
=
true
;
}
async
_isDisableAutohideEnabled
(
)
{
await
this
.
isOpen
;
if
(
!
this
.
disableAutohideAvailable
)
{
return
false
;
}
const
prefFront
=
await
this
.
preferenceFront
;
return
prefFront
.
getBoolPref
(
DISABLE_AUTOHIDE_PREF
)
;
}
_listFrames
:
async
function
(
event
)
{
if
(
!
this
.
target
.
activeTab
|
|
!
this
.
target
.
activeTab
.
traits
.
frames
)
{
return
promise
.
resolve
(
)
;
}
const
{
frames
}
=
await
this
.
target
.
activeTab
.
listFrames
(
)
;
this
.
_updateFrames
(
{
frames
}
)
;
}
onSelectFrame
:
function
(
frameId
)
{
this
.
target
.
activeTab
.
switchToFrame
(
{
windowId
:
frameId
}
)
;
}
onHighlightFrame
:
async
function
(
frameId
)
{
await
this
.
initInspector
(
)
;
if
(
this
.
rootFrameSelected
)
{
const
frameActor
=
await
this
.
walker
.
getNodeActorFromWindowID
(
frameId
)
;
this
.
highlighter
.
highlight
(
frameActor
)
;
}
}
_updateFrames
:
function
(
data
)
{
if
(
!
this
.
isReady
)
{
return
;
}
if
(
data
.
destroyAll
)
{
this
.
frameMap
.
clear
(
)
;
this
.
selectedFrameId
=
null
;
}
else
if
(
data
.
selected
)
{
this
.
selectedFrameId
=
data
.
selected
;
}
else
if
(
data
.
frames
)
{
data
.
frames
.
forEach
(
frame
=
>
{
if
(
frame
.
destroy
)
{
this
.
frameMap
.
delete
(
frame
.
id
)
;
if
(
this
.
selectedFrameId
=
=
frame
.
id
)
{
this
.
selectedFrameId
=
null
;
}
}
else
{
this
.
frameMap
.
set
(
frame
.
id
frame
)
;
}
}
)
;
}
if
(
!
this
.
selectedFrameId
)
{
const
frames
=
[
.
.
.
this
.
frameMap
.
values
(
)
]
;
const
topFrames
=
frames
.
filter
(
frame
=
>
!
frame
.
parentID
)
;
this
.
selectedFrameId
=
topFrames
.
length
?
topFrames
[
0
]
.
id
:
null
;
}
const
wasVisible
=
this
.
frameButton
.
isVisible
;
const
wasDisabled
=
this
.
frameButton
.
disabled
;
this
.
updateFrameButton
(
)
;
const
toolbarUpdate
=
(
)
=
>
{
if
(
this
.
frameButton
.
isVisible
=
=
=
wasVisible
&
&
this
.
frameButton
.
disabled
=
=
=
wasDisabled
)
{
return
;
}
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
;
if
(
data
.
destroyAll
&
&
!
this
.
debouncedToolbarUpdate
)
{
this
.
debouncedToolbarUpdate
=
debounce
(
(
)
=
>
{
toolbarUpdate
(
)
;
this
.
debouncedToolbarUpdate
=
null
;
}
200
this
)
;
}
if
(
this
.
debouncedToolbarUpdate
)
{
this
.
debouncedToolbarUpdate
(
)
;
}
else
{
toolbarUpdate
(
)
;
}
}
get
selectedFrameDepth
(
)
{
if
(
!
this
.
selectedFrameId
)
{
return
0
;
}
let
depth
=
0
;
let
frame
=
this
.
frameMap
.
get
(
this
.
selectedFrameId
)
;
while
(
frame
)
{
depth
+
+
;
frame
=
this
.
frameMap
.
get
(
frame
.
parentID
)
;
}
return
depth
-
1
;
}
get
rootFrameSelected
(
)
{
return
this
.
selectedFrameDepth
=
=
0
;
}
switchToPreviousHost
:
function
(
)
{
return
this
.
switchHost
(
"
previous
"
)
;
}
switchHost
:
function
(
hostType
)
{
if
(
hostType
=
=
this
.
hostType
|
|
!
this
.
_target
.
isLocalTab
)
{
return
null
;
}
this
.
emit
(
"
host
-
will
-
change
"
hostType
)
;
this
.
focusTool
(
this
.
currentToolId
false
)
;
this
.
postMessage
(
{
name
:
"
switch
-
host
"
hostType
}
)
;
return
this
.
once
(
"
host
-
changed
"
)
;
}
_onSwitchedHost
:
function
(
{
hostType
}
)
{
this
.
_hostType
=
hostType
;
this
.
_buildDockOptions
(
)
;
this
.
_addKeysToWindow
(
)
;
this
.
focusTool
(
this
.
currentToolId
true
)
;
this
.
emit
(
"
host
-
changed
"
)
;
this
.
telemetry
.
getHistogramById
(
HOST_HISTOGRAM
)
.
add
(
this
.
_getTelemetryHostId
(
)
)
;
this
.
component
.
setCurrentHostType
(
hostType
)
;
}
isToolRegistered
:
function
(
toolId
)
{
return
!
!
this
.
getToolDefinition
(
toolId
)
;
}
getToolDefinition
:
function
(
toolId
)
{
return
gDevTools
.
getToolDefinition
(
toolId
)
|
|
this
.
additionalToolDefinitions
.
get
(
toolId
)
;
}
unloadTool
:
function
(
toolId
)
{
if
(
typeof
toolId
!
=
"
string
"
)
{
throw
new
Error
(
"
Unexpected
non
-
string
toolId
received
.
"
)
;
}
if
(
this
.
_toolPanels
.
has
(
toolId
)
)
{
const
instance
=
this
.
_toolPanels
.
get
(
toolId
)
;
instance
.
destroy
(
)
;
this
.
_toolPanels
.
delete
(
toolId
)
;
}
const
panel
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
toolId
)
;
if
(
this
.
currentToolId
=
=
toolId
)
{
const
index
=
this
.
panelDefinitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
toolId
)
;
const
nextTool
=
this
.
panelDefinitions
[
index
+
1
]
;
const
previousTool
=
this
.
panelDefinitions
[
index
-
1
]
;
let
toolNameToSelect
;
if
(
nextTool
)
{
toolNameToSelect
=
nextTool
.
id
;
}
if
(
previousTool
)
{
toolNameToSelect
=
previousTool
.
id
;
}
if
(
toolNameToSelect
)
{
this
.
selectTool
(
toolNameToSelect
"
tool_unloaded
"
)
;
}
}
this
.
panelDefinitions
=
this
.
panelDefinitions
.
filter
(
(
{
id
}
)
=
>
id
!
=
=
toolId
)
;
this
.
visibleAdditionalTools
=
this
.
visibleAdditionalTools
.
filter
(
id
=
>
id
!
=
=
toolId
)
;
this
.
_combineAndSortPanelDefinitions
(
)
;
if
(
panel
)
{
panel
.
remove
(
)
;
}
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
const
doc
=
this
.
win
.
parent
.
document
;
const
key
=
doc
.
getElementById
(
"
key_
"
+
toolId
)
;
if
(
key
)
{
key
.
remove
(
)
;
}
}
}
getToolStartup
:
function
(
toolId
)
{
return
this
.
_toolStartups
.
get
(
toolId
)
;
}
_unloadToolStartup
:
async
function
(
toolId
)
{
const
startup
=
this
.
getToolStartup
(
toolId
)
;
if
(
!
startup
)
{
return
;
}
this
.
_toolStartups
.
delete
(
toolId
)
;
await
startup
.
destroy
(
)
;
}
_toolRegistered
:
function
(
toolId
)
{
let
definition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
let
isAdditionalTool
=
false
;
if
(
!
definition
)
{
definition
=
this
.
additionalToolDefinitions
.
get
(
toolId
)
;
isAdditionalTool
=
true
;
}
if
(
definition
.
isTargetSupported
(
this
.
_target
)
)
{
if
(
isAdditionalTool
)
{
this
.
visibleAdditionalTools
=
[
.
.
.
this
.
visibleAdditionalTools
toolId
]
;
this
.
_combineAndSortPanelDefinitions
(
)
;
}
else
{
this
.
panelDefinitions
=
this
.
panelDefinitions
.
concat
(
definition
)
;
}
this
.
_buildPanelForTool
(
definition
)
;
this
.
emit
(
"
tool
-
registered
"
toolId
)
;
}
}
_toolUnregistered
:
function
(
toolId
)
{
this
.
unloadTool
(
toolId
)
;
this
.
_unloadToolStartup
(
toolId
)
;
this
.
emit
(
"
tool
-
unregistered
"
toolId
)
;
}
initInspector
:
function
(
)
{
if
(
!
this
.
_initInspector
)
{
this
.
_initInspector
=
(
async
function
(
)
{
this
.
_inspector
=
await
this
.
target
.
getInspector
(
)
;
this
.
_walker
=
this
.
inspector
.
walker
;
this
.
_highlighter
=
this
.
inspector
.
highlighter
;
this
.
_selection
=
this
.
inspector
.
selection
;
this
.
inspector
.
nodePicker
.
on
(
"
picker
-
starting
"
this
.
_onPickerStarting
)
;
this
.
inspector
.
nodePicker
.
on
(
"
picker
-
started
"
this
.
_onPickerStarted
)
;
this
.
inspector
.
nodePicker
.
on
(
"
picker
-
stopped
"
this
.
_onPickerStopped
)
;
this
.
inspector
.
nodePicker
.
on
(
"
picker
-
node
-
canceled
"
this
.
_onPickerCanceled
)
;
this
.
walker
.
on
(
"
highlighter
-
ready
"
this
.
_highlighterReady
)
;
this
.
walker
.
on
(
"
highlighter
-
hide
"
this
.
_highlighterHidden
)
;
this
.
_selection
.
on
(
"
new
-
node
-
front
"
this
.
_onNewSelectedNodeFront
)
;
}
.
bind
(
this
)
)
(
)
;
}
return
this
.
_initInspector
;
}
_onNewSelectedNodeFront
:
function
(
)
{
this
.
emit
(
"
selection
-
changed
"
)
;
}
_onInspectObject
:
function
(
packet
)
{
this
.
inspectObjectActor
(
packet
.
objectActor
packet
.
inspectFromAnnotation
)
;
}
_onToolSelected
:
function
(
)
{
this
.
_refreshHostTitle
(
)
;
this
.
updatePickerButton
(
)
;
this
.
updateFrameButton
(
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
inspectObjectActor
:
async
function
(
objectActor
inspectFromAnnotation
)
{
if
(
objectActor
.
preview
&
&
objectActor
.
preview
.
nodeType
=
=
=
domNodeConstants
.
ELEMENT_NODE
)
{
await
this
.
loadTool
(
"
inspector
"
)
;
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
const
nodeFound
=
await
inspector
.
inspectNodeActor
(
objectActor
.
actor
inspectFromAnnotation
)
;
if
(
nodeFound
)
{
await
this
.
selectTool
(
"
inspector
"
)
;
}
}
else
if
(
objectActor
.
type
!
=
=
"
null
"
&
&
objectActor
.
type
!
=
=
"
undefined
"
)
{
await
this
.
openSplitConsole
(
)
;
const
panel
=
this
.
getPanel
(
"
webconsole
"
)
;
panel
.
hud
.
ui
.
inspectObjectActor
(
objectActor
)
;
}
}
destroyInspector
:
function
(
)
{
if
(
this
.
_destroyingInspector
)
{
return
this
.
_destroyingInspector
;
}
this
.
_destroyingInspector
=
(
async
function
(
)
{
if
(
!
this
.
_inspector
&
&
!
this
.
_initInspector
)
{
return
;
}
await
this
.
_initInspector
;
await
this
.
_inspector
.
destroy
(
)
;
this
.
_inspector
=
null
;
this
.
_highlighter
=
null
;
this
.
_selection
=
null
;
this
.
_walker
=
null
;
}
.
bind
(
this
)
)
(
)
;
return
this
.
_destroyingInspector
;
}
getNotificationBox
:
function
(
)
{
return
this
.
notificationBox
;
}
closeToolbox
:
async
function
(
)
{
const
shouldStopRecording
=
this
.
target
.
isReplayEnabled
(
)
;
await
this
.
destroy
(
)
;
if
(
shouldStopRecording
)
{
reloadAndStopRecordingTab
(
)
;
}
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
this
.
_destroyer
=
this
.
_destroyToolbox
(
)
;
return
this
.
_destroyer
;
}
_destroyToolbox
:
async
function
(
)
{
this
.
emit
(
"
destroy
"
)
;
this
.
_target
.
off
(
"
inspect
-
object
"
this
.
_onInspectObject
)
;
this
.
_target
.
off
(
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_target
.
off
(
"
navigate
"
this
.
_refreshHostTitle
)
;
this
.
_target
.
off
(
"
frame
-
update
"
this
.
_updateFrames
)
;
this
.
off
(
"
select
"
this
.
_onToolSelected
)
;
this
.
off
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
gDevTools
.
off
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
off
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
Services
.
prefs
.
removeObserver
(
"
devtools
.
cache
.
disabled
"
this
.
_applyCacheSettings
)
;
Services
.
prefs
.
removeObserver
(
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
this
.
_applyServiceWorkersTestingSettings
)
;
this
.
telemetry
.
toolClosed
(
this
.
currentToolId
this
.
sessionId
this
)
;
this
.
_lastFocusedElement
=
null
;
if
(
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
.
destroy
(
)
;
this
.
_sourceMapURLService
=
null
;
}
if
(
this
.
_sourceMapService
)
{
this
.
_sourceMapService
.
stopSourceMapWorker
(
)
;
this
.
_sourceMapService
=
null
;
}
if
(
this
.
webconsolePanel
)
{
this
.
_saveSplitConsoleHeight
(
)
;
this
.
webconsolePanel
.
removeEventListener
(
"
resize
"
this
.
_saveSplitConsoleHeight
)
;
this
.
webconsolePanel
=
null
;
}
if
(
this
.
_componentMount
)
{
this
.
_componentMount
.
removeEventListener
(
"
keypress
"
this
.
_onToolbarArrowKeypress
)
;
this
.
ReactDOM
.
unmountComponentAtNode
(
this
.
_componentMount
)
;
this
.
_componentMount
=
null
;
}
const
outstanding
=
[
]
;
for
(
const
[
id
panel
]
of
this
.
_toolPanels
)
{
try
{
gDevTools
.
emit
(
id
+
"
-
destroy
"
this
panel
)
;
this
.
emit
(
id
+
"
-
destroy
"
panel
)
;
outstanding
.
push
(
panel
.
destroy
(
)
)
;
}
catch
(
e
)
{
console
.
error
(
"
Panel
"
+
id
+
"
:
"
e
)
;
}
}
for
(
const
id
of
this
.
_toolStartups
.
keys
(
)
)
{
outstanding
.
push
(
this
.
_unloadToolStartup
(
id
)
)
;
}
this
.
browserRequire
=
null
;
this
.
_toolNames
=
null
;
outstanding
.
push
(
this
.
destroyInspector
(
)
)
;
outstanding
.
push
(
this
.
resetPreference
(
)
)
;
detachThread
(
this
.
_threadClient
)
;
this
.
_threadClient
=
null
;
this
.
toolbarButtons
.
forEach
(
button
=
>
{
if
(
typeof
button
.
teardown
=
=
"
function
"
)
{
button
.
teardown
(
)
;
}
}
)
;
const
win
=
this
.
win
;
const
host
=
this
.
_getTelemetryHostString
(
)
;
const
width
=
Math
.
ceil
(
win
.
outerWidth
/
50
)
*
50
;
const
prevPanelName
=
this
.
getTelemetryPanelNameOrOther
(
this
.
currentToolId
)
;
this
.
telemetry
.
toolClosed
(
"
toolbox
"
this
.
sessionId
this
)
;
this
.
telemetry
.
recordEvent
(
"
exit
"
prevPanelName
null
{
"
host
"
:
host
"
width
"
:
width
"
panel_name
"
:
this
.
getTelemetryPanelNameOrOther
(
this
.
currentToolId
)
"
next_panel
"
:
"
none
"
"
reason
"
:
"
toolbox_close
"
"
session_id
"
:
this
.
sessionId
}
)
;
this
.
telemetry
.
recordEvent
(
"
close
"
"
tools
"
null
{
"
host
"
:
host
"
width
"
:
width
"
session_id
"
:
this
.
sessionId
}
)
;
const
onceDestroyed
=
new
Promise
(
resolve
=
>
{
resolve
(
settleAll
(
outstanding
)
.
catch
(
console
.
error
)
.
then
(
(
)
=
>
{
const
api
=
this
.
_netMonitorAPI
;
this
.
_netMonitorAPI
=
null
;
return
api
?
api
.
destroy
(
)
:
null
;
}
console
.
error
)
.
then
(
(
)
=
>
{
this
.
_removeHostListeners
(
)
;
try
{
win
.
location
.
replace
(
"
about
:
blank
"
)
;
}
catch
(
e
)
{
}
if
(
!
this
.
_target
)
{
return
null
;
}
const
target
=
this
.
_target
;
this
.
_target
=
null
;
target
.
off
(
"
close
"
this
.
destroy
)
;
return
target
.
destroy
(
)
;
}
console
.
error
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
destroyed
"
)
;
this
.
_host
=
null
;
this
.
_win
=
null
;
this
.
_toolPanels
.
clear
(
)
;
if
(
flags
.
testing
)
{
win
.
windowUtils
.
garbageCollect
(
)
;
}
}
)
.
catch
(
console
.
error
)
)
;
}
)
;
const
leakCheckObserver
=
(
{
wrappedJSObject
:
barrier
}
)
=
>
{
barrier
.
client
.
addBlocker
(
"
DevTools
:
Wait
until
toolbox
is
destroyed
"
onceDestroyed
)
;
}
;
const
topic
=
"
shutdown
-
leaks
-
before
-
check
"
;
Services
.
obs
.
addObserver
(
leakCheckObserver
topic
)
;
await
onceDestroyed
;
Services
.
obs
.
removeObserver
(
leakCheckObserver
topic
)
;
}
_highlighterReady
:
function
(
)
{
this
.
emit
(
"
highlighter
-
ready
"
)
;
}
_highlighterHidden
:
function
(
)
{
this
.
emit
(
"
highlighter
-
hide
"
)
;
}
_updateTextBoxMenuItems
:
function
(
)
{
const
window
=
this
.
win
;
[
"
cmd_undo
"
"
cmd_delete
"
"
cmd_cut
"
"
cmd_copy
"
"
cmd_paste
"
"
cmd_selectAll
"
]
.
forEach
(
window
.
goUpdateCommand
)
;
}
openTextBoxContextMenu
:
function
(
x
y
)
{
const
menu
=
createEditContextMenu
(
this
.
win
"
toolbox
-
menu
"
)
;
menu
.
once
(
"
open
"
(
)
=
>
this
.
emit
(
"
menu
-
open
"
)
)
;
menu
.
once
(
"
close
"
(
)
=
>
this
.
emit
(
"
menu
-
close
"
)
)
;
menu
.
popup
(
x
y
{
doc
:
this
.
doc
}
)
;
}
async
initPerformance
(
)
{
if
(
!
this
.
target
.
hasActor
(
"
performance
"
)
)
{
return
promise
.
resolve
(
)
;
}
const
performanceFront
=
await
this
.
target
.
getFront
(
"
performance
"
)
;
performanceFront
.
once
(
"
console
-
profile
-
start
"
(
)
=
>
this
.
_onPerformanceFrontEvent
(
performanceFront
)
)
;
return
performanceFront
;
}
async
_onPerformanceFrontEvent
(
performanceFront
)
{
if
(
this
.
getPanel
(
"
performance
"
)
)
{
performanceFront
.
flushQueuedRecordings
(
)
;
return
;
}
const
panel
=
await
this
.
loadTool
(
"
performance
"
)
;
const
recordings
=
performanceFront
.
flushQueuedRecordings
(
)
;
panel
.
panelWin
.
PerformanceController
.
populateWithRecordings
(
recordings
)
;
await
panel
.
open
(
)
;
}
async
resetPreference
(
)
{
if
(
!
this
.
_preferenceFront
)
{
return
;
}
if
(
this
.
_autohideHasBeenToggled
)
{
await
this
.
_preferenceFront
.
clearUserPref
(
DISABLE_AUTOHIDE_PREF
)
;
}
this
.
_preferenceFront
=
null
;
}
get
gViewSourceUtils
(
)
{
return
this
.
win
.
gViewSourceUtils
;
}
viewSourceInStyleEditor
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInStyleEditor
(
this
sourceURL
sourceLine
)
;
}
viewSourceInDebugger
:
function
(
sourceURL
sourceLine
reason
)
{
return
viewSource
.
viewSourceInDebugger
(
this
sourceURL
sourceLine
reason
)
;
}
viewSourceInScratchpad
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInScratchpad
(
sourceURL
sourceLine
)
;
}
viewSource
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSource
(
this
sourceURL
sourceLine
)
;
}
getNetMonitorAPI
:
async
function
(
)
{
const
netPanel
=
this
.
getPanel
(
"
netmonitor
"
)
;
if
(
netPanel
)
{
return
netPanel
.
panelWin
.
Netmonitor
.
api
;
}
if
(
this
.
_netMonitorAPI
)
{
return
this
.
_netMonitorAPI
;
}
this
.
_netMonitorAPI
=
new
NetMonitorAPI
(
)
;
await
this
.
_netMonitorAPI
.
connect
(
this
)
;
return
this
.
_netMonitorAPI
;
}
getHARFromNetMonitor
:
async
function
(
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
let
har
=
await
netMonitor
.
getHar
(
)
;
har
=
har
|
|
buildHarLog
(
Services
.
appinfo
)
;
return
har
.
log
;
}
addRequestFinishedListener
:
async
function
(
listener
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
netMonitor
.
addRequestFinishedListener
(
listener
)
;
}
removeRequestFinishedListener
:
async
function
(
listener
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
netMonitor
.
removeRequestFinishedListener
(
listener
)
;
const
netPanel
=
this
.
getPanel
(
"
netmonitor
"
)
;
const
hasListeners
=
netMonitor
.
hasRequestFinishedListeners
(
)
;
if
(
this
.
_netMonitorAPI
&
&
!
hasListeners
&
&
!
netPanel
)
{
this
.
_netMonitorAPI
.
destroy
(
)
;
this
.
_netMonitorAPI
=
null
;
}
}
fetchResponseContent
:
async
function
(
requestId
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
return
netMonitor
.
fetchResponseContent
(
requestId
)
;
}
listWebExtensions
:
function
(
)
{
return
Array
.
from
(
this
.
_webExtensions
)
.
map
(
(
[
uuid
{
name
pref
}
]
)
=
>
{
return
{
uuid
name
pref
}
;
}
)
;
}
registerWebExtension
:
function
(
extensionUUID
{
name
pref
}
)
{
this
.
_webExtensions
.
set
(
extensionUUID
{
name
pref
}
)
;
this
.
emit
(
"
webextension
-
registered
"
extensionUUID
)
;
}
unregisterWebExtension
:
function
(
extensionUUID
)
{
this
.
_webExtensions
.
delete
(
extensionUUID
)
;
this
.
emit
(
"
webextension
-
unregistered
"
extensionUUID
)
;
}
isWebExtensionEnabled
:
function
(
extensionUUID
)
{
const
extInfo
=
this
.
_webExtensions
.
get
(
extensionUUID
)
;
return
extInfo
&
&
Services
.
prefs
.
getBoolPref
(
extInfo
.
pref
false
)
;
}
getTelemetryPanelNameOrOther
:
function
(
id
)
{
if
(
!
this
.
_toolNames
)
{
const
definitions
=
gDevTools
.
getToolDefinitionArray
(
)
;
const
definitionIds
=
definitions
.
map
(
definition
=
>
definition
.
id
)
;
this
.
_toolNames
=
new
Set
(
definitionIds
)
;
}
if
(
!
this
.
_toolNames
.
has
(
id
)
)
{
return
"
other
"
;
}
return
id
;
}
}
;
