"
use
strict
"
;
const
MAX_ORDINAL
=
99
;
const
SPLITCONSOLE_ENABLED_PREF
=
"
devtools
.
toolbox
.
splitconsoleEnabled
"
;
const
SPLITCONSOLE_HEIGHT_PREF
=
"
devtools
.
toolbox
.
splitconsoleHeight
"
;
const
OS_HISTOGRAM
=
"
DEVTOOLS_OS_ENUMERATED_PER_USER
"
;
const
OS_IS_64_BITS
=
"
DEVTOOLS_OS_IS_64_BITS_PER_USER
"
;
const
HOST_HISTOGRAM
=
"
DEVTOOLS_TOOLBOX_HOST
"
;
const
SCREENSIZE_HISTOGRAM
=
"
DEVTOOLS_SCREEN_RESOLUTION_ENUMERATED_PER_USER
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
{
SourceMapService
}
=
require
(
"
.
/
source
-
map
-
service
"
)
;
var
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
var
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
var
HUDService
=
require
(
"
devtools
/
client
/
webconsole
/
hudservice
"
)
;
var
viewSource
=
require
(
"
devtools
/
client
/
shared
/
view
-
source
"
)
;
var
{
attachThread
detachThread
}
=
require
(
"
.
/
attach
-
thread
"
)
;
var
Menu
=
require
(
"
devtools
/
client
/
framework
/
menu
"
)
;
var
MenuItem
=
require
(
"
devtools
/
client
/
framework
/
menu
-
item
"
)
;
var
{
DOMHelpers
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
DOMHelpers
.
jsm
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
BrowserLoader
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
{
}
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
loader
.
lazyRequireGetter
(
this
"
CommandUtils
"
"
devtools
/
client
/
shared
/
developer
-
toolbar
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getHighlighterUtils
"
"
devtools
/
client
/
framework
/
toolbox
-
highlighter
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Selection
"
"
devtools
/
client
/
framework
/
selection
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorFront
"
"
devtools
/
shared
/
fronts
/
inspector
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
loader
.
lazyRequireGetter
(
this
"
showDoorhanger
"
"
devtools
/
client
/
shared
/
doorhanger
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createPerformanceFront
"
"
devtools
/
shared
/
fronts
/
performance
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
system
"
"
devtools
/
shared
/
system
"
)
;
loader
.
lazyRequireGetter
(
this
"
getPreferenceFront
"
"
devtools
/
shared
/
fronts
/
preference
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ZoomKeys
"
"
devtools
/
client
/
shared
/
zoom
-
keys
"
)
;
loader
.
lazyRequireGetter
(
this
"
settleAll
"
"
devtools
/
shared
/
ThreadSafeDevToolsUtils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolboxButtons
"
"
devtools
/
client
/
definitions
"
true
)
;
loader
.
lazyGetter
(
this
"
registerHarOverlay
"
(
)
=
>
{
return
require
(
"
devtools
/
client
/
netmonitor
/
har
/
toolbox
-
overlay
"
)
.
register
;
}
)
;
function
Toolbox
(
target
selectedTool
hostType
contentWindow
frameId
)
{
this
.
_target
=
target
;
this
.
_win
=
contentWindow
;
this
.
frameId
=
frameId
;
this
.
_toolPanels
=
new
Map
(
)
;
this
.
_telemetry
=
new
Telemetry
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
sourcemap
.
locations
.
enabled
"
)
)
{
this
.
_sourceMapService
=
new
SourceMapService
(
this
.
_target
)
;
}
this
.
_initInspector
=
null
;
this
.
_inspector
=
null
;
this
.
frameMap
=
new
Map
(
)
;
this
.
selectedFrameId
=
null
;
this
.
_toolRegistered
=
this
.
_toolRegistered
.
bind
(
this
)
;
this
.
_toolUnregistered
=
this
.
_toolUnregistered
.
bind
(
this
)
;
this
.
_refreshHostTitle
=
this
.
_refreshHostTitle
.
bind
(
this
)
;
this
.
_toggleAutohide
=
this
.
_toggleAutohide
.
bind
(
this
)
;
this
.
showFramesMenu
=
this
.
showFramesMenu
.
bind
(
this
)
;
this
.
_updateFrames
=
this
.
_updateFrames
.
bind
(
this
)
;
this
.
_splitConsoleOnKeypress
=
this
.
_splitConsoleOnKeypress
.
bind
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
highlighterUtils
=
getHighlighterUtils
(
this
)
;
this
.
_highlighterReady
=
this
.
_highlighterReady
.
bind
(
this
)
;
this
.
_highlighterHidden
=
this
.
_highlighterHidden
.
bind
(
this
)
;
this
.
_prefChanged
=
this
.
_prefChanged
.
bind
(
this
)
;
this
.
_saveSplitConsoleHeight
=
this
.
_saveSplitConsoleHeight
.
bind
(
this
)
;
this
.
_onFocus
=
this
.
_onFocus
.
bind
(
this
)
;
this
.
_onBrowserMessage
=
this
.
_onBrowserMessage
.
bind
(
this
)
;
this
.
_showDevEditionPromo
=
this
.
_showDevEditionPromo
.
bind
(
this
)
;
this
.
_updateTextBoxMenuItems
=
this
.
_updateTextBoxMenuItems
.
bind
(
this
)
;
this
.
_onBottomHostMinimized
=
this
.
_onBottomHostMinimized
.
bind
(
this
)
;
this
.
_onBottomHostMaximized
=
this
.
_onBottomHostMaximized
.
bind
(
this
)
;
this
.
_onToolSelectWhileMinimized
=
this
.
_onToolSelectWhileMinimized
.
bind
(
this
)
;
this
.
_onPerformanceFrontEvent
=
this
.
_onPerformanceFrontEvent
.
bind
(
this
)
;
this
.
_onBottomHostWillChange
=
this
.
_onBottomHostWillChange
.
bind
(
this
)
;
this
.
_toggleMinimizeMode
=
this
.
_toggleMinimizeMode
.
bind
(
this
)
;
this
.
_onTabbarFocus
=
this
.
_onTabbarFocus
.
bind
(
this
)
;
this
.
_onTabbarArrowKeypress
=
this
.
_onTabbarArrowKeypress
.
bind
(
this
)
;
this
.
_onPickerClick
=
this
.
_onPickerClick
.
bind
(
this
)
;
this
.
_onPickerKeypress
=
this
.
_onPickerKeypress
.
bind
(
this
)
;
this
.
_onPickerStarted
=
this
.
_onPickerStarted
.
bind
(
this
)
;
this
.
_onPickerStopped
=
this
.
_onPickerStopped
.
bind
(
this
)
;
this
.
_target
.
on
(
"
close
"
this
.
destroy
)
;
if
(
!
selectedTool
)
{
selectedTool
=
Services
.
prefs
.
getCharPref
(
this
.
_prefs
.
LAST_TOOL
)
;
}
this
.
_defaultToolId
=
selectedTool
;
this
.
_hostType
=
hostType
;
EventEmitter
.
decorate
(
this
)
;
this
.
_target
.
on
(
"
navigate
"
this
.
_refreshHostTitle
)
;
this
.
_target
.
on
(
"
frame
-
update
"
this
.
_updateFrames
)
;
this
.
on
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
this
.
on
(
"
select
"
this
.
_refreshHostTitle
)
;
this
.
on
(
"
ready
"
this
.
_showDevEditionPromo
)
;
gDevTools
.
on
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
this
.
on
(
"
picker
-
started
"
this
.
_onPickerStarted
)
;
this
.
on
(
"
picker
-
stopped
"
this
.
_onPickerStopped
)
;
}
exports
.
Toolbox
=
Toolbox
;
Toolbox
.
HostType
=
{
BOTTOM
:
"
bottom
"
SIDE
:
"
side
"
WINDOW
:
"
window
"
CUSTOM
:
"
custom
"
}
;
Toolbox
.
prototype
=
{
_URL
:
"
about
:
devtools
-
toolbox
"
_prefs
:
{
LAST_TOOL
:
"
devtools
.
toolbox
.
selectedTool
"
SIDE_ENABLED
:
"
devtools
.
toolbox
.
sideEnabled
"
}
currentToolId
:
null
lastUsedToolId
:
null
getToolPanels
:
function
(
)
{
return
new
Map
(
this
.
_toolPanels
)
;
}
getPanel
:
function
(
id
)
{
return
this
.
_toolPanels
.
get
(
id
)
;
}
getPanelWhenReady
:
function
(
id
)
{
let
deferred
=
defer
(
)
;
let
panel
=
this
.
getPanel
(
id
)
;
if
(
panel
)
{
deferred
.
resolve
(
panel
)
;
}
else
{
this
.
on
(
id
+
"
-
ready
"
(
e
initializedPanel
)
=
>
{
deferred
.
resolve
(
initializedPanel
)
;
}
)
;
}
return
deferred
.
promise
;
}
getCurrentPanel
:
function
(
)
{
return
this
.
_toolPanels
.
get
(
this
.
currentToolId
)
;
}
get
target
(
)
{
return
this
.
_target
;
}
get
threadClient
(
)
{
return
this
.
_threadClient
;
}
get
hostType
(
)
{
return
this
.
_hostType
;
}
get
win
(
)
{
return
this
.
_win
;
}
get
doc
(
)
{
return
this
.
win
.
document
;
}
get
highlighter
(
)
{
return
this
.
_highlighter
;
}
get
performance
(
)
{
return
this
.
_performance
;
}
get
inspector
(
)
{
return
this
.
_inspector
;
}
get
walker
(
)
{
return
this
.
_walker
;
}
get
selection
(
)
{
return
this
.
_selection
;
}
get
splitConsole
(
)
{
return
this
.
_splitConsole
;
}
isSplitConsoleFocused
:
function
(
)
{
if
(
!
this
.
_splitConsole
)
{
return
false
;
}
let
focusedWin
=
Services
.
focus
.
focusedWindow
;
return
focusedWin
&
&
focusedWin
=
=
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
iframe
-
webconsole
"
)
.
contentWindow
;
}
open
:
function
(
)
{
return
Task
.
spawn
(
function
*
(
)
{
this
.
browserRequire
=
BrowserLoader
(
{
window
:
this
.
doc
.
defaultView
useOnlyShared
:
true
}
)
.
require
;
if
(
this
.
win
.
location
.
href
.
startsWith
(
this
.
_URL
)
)
{
this
.
_URL
=
this
.
win
.
location
.
href
;
}
let
domReady
=
defer
(
)
;
let
domHelper
=
new
DOMHelpers
(
this
.
win
)
;
domHelper
.
onceDOMReady
(
(
)
=
>
{
domReady
.
resolve
(
)
;
}
this
.
_URL
)
;
yield
this
.
_target
.
makeRemote
(
)
;
this
.
_threadClient
=
yield
attachThread
(
this
)
;
yield
domReady
.
promise
;
this
.
isReady
=
true
;
let
framesPromise
=
this
.
_listFrames
(
)
;
this
.
closeButton
=
this
.
doc
.
getElementById
(
"
toolbox
-
close
"
)
;
this
.
closeButton
.
addEventListener
(
"
click
"
this
.
destroy
true
)
;
gDevTools
.
on
(
"
pref
-
changed
"
this
.
_prefChanged
)
;
let
framesMenu
=
this
.
doc
.
getElementById
(
"
command
-
button
-
frames
"
)
;
framesMenu
.
addEventListener
(
"
click
"
this
.
showFramesMenu
false
)
;
let
noautohideMenu
=
this
.
doc
.
getElementById
(
"
command
-
button
-
noautohide
"
)
;
noautohideMenu
.
addEventListener
(
"
click
"
this
.
_toggleAutohide
true
)
;
this
.
textBoxContextMenuPopup
=
this
.
doc
.
getElementById
(
"
toolbox
-
textbox
-
context
-
popup
"
)
;
this
.
textBoxContextMenuPopup
.
addEventListener
(
"
popupshowing
"
this
.
_updateTextBoxMenuItems
true
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
doc
.
defaultView
}
)
;
this
.
_buildDockButtons
(
)
;
this
.
_buildOptions
(
)
;
this
.
_buildTabs
(
)
;
this
.
_applyCacheSettings
(
)
;
this
.
_applyServiceWorkersTestingSettings
(
)
;
this
.
_addKeysToWindow
(
)
;
this
.
_addReloadKeys
(
)
;
this
.
_addHostListeners
(
)
;
this
.
_registerOverlays
(
)
;
if
(
!
this
.
_hostOptions
|
|
this
.
_hostOptions
.
zoom
=
=
=
true
)
{
ZoomKeys
.
register
(
this
.
win
)
;
}
this
.
tabbar
=
this
.
doc
.
querySelector
(
"
.
devtools
-
tabbar
"
)
;
this
.
tabbar
.
addEventListener
(
"
focus
"
this
.
_onTabbarFocus
true
)
;
this
.
tabbar
.
addEventListener
(
"
click
"
this
.
_onTabbarFocus
true
)
;
this
.
tabbar
.
addEventListener
(
"
keypress
"
this
.
_onTabbarArrowKeypress
)
;
this
.
webconsolePanel
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
webconsole
"
)
;
this
.
webconsolePanel
.
height
=
Services
.
prefs
.
getIntPref
(
SPLITCONSOLE_HEIGHT_PREF
)
;
this
.
webconsolePanel
.
addEventListener
(
"
resize
"
this
.
_saveSplitConsoleHeight
)
;
let
buttonsPromise
=
this
.
_buildButtons
(
)
;
this
.
_pingTelemetry
(
)
;
let
toolDef
=
gDevTools
.
getToolDefinition
(
this
.
_defaultToolId
)
;
if
(
!
toolDef
|
|
!
toolDef
.
isTargetSupported
(
this
.
_target
)
)
{
this
.
_defaultToolId
=
"
webconsole
"
;
}
yield
this
.
selectTool
(
this
.
_defaultToolId
)
;
let
splitConsolePromise
=
promise
.
resolve
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
SPLITCONSOLE_ENABLED_PREF
)
)
{
splitConsolePromise
=
this
.
openSplitConsole
(
)
;
}
yield
promise
.
all
(
[
splitConsolePromise
buttonsPromise
framesPromise
]
)
;
let
performanceFrontConnection
=
this
.
initPerformance
(
)
;
if
(
flags
.
testing
)
{
yield
performanceFrontConnection
;
}
this
.
emit
(
"
ready
"
)
;
}
.
bind
(
this
)
)
.
then
(
null
console
.
error
.
bind
(
console
)
)
;
}
get
React
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
}
get
ReactDOM
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
}
get
ReactRedux
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
}
_getTelemetryHostId
:
function
(
)
{
switch
(
this
.
hostType
)
{
case
Toolbox
.
HostType
.
BOTTOM
:
return
0
;
case
Toolbox
.
HostType
.
SIDE
:
return
1
;
case
Toolbox
.
HostType
.
WINDOW
:
return
2
;
case
Toolbox
.
HostType
.
CUSTOM
:
return
3
;
default
:
return
9
;
}
}
_pingTelemetry
:
function
(
)
{
this
.
_telemetry
.
toolOpened
(
"
toolbox
"
)
;
this
.
_telemetry
.
logOncePerBrowserVersion
(
OS_HISTOGRAM
system
.
getOSCPU
(
)
)
;
this
.
_telemetry
.
logOncePerBrowserVersion
(
OS_IS_64_BITS
Services
.
appinfo
.
is64Bit
?
1
:
0
)
;
this
.
_telemetry
.
logOncePerBrowserVersion
(
SCREENSIZE_HISTOGRAM
system
.
getScreenDimensions
(
)
)
;
this
.
_telemetry
.
log
(
HOST_HISTOGRAM
this
.
_getTelemetryHostId
(
)
)
;
}
_prefChanged
:
function
(
event
data
)
{
switch
(
data
.
pref
)
{
case
"
devtools
.
cache
.
disabled
"
:
this
.
_applyCacheSettings
(
)
;
break
;
case
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
:
this
.
_applyServiceWorkersTestingSettings
(
)
;
break
;
}
}
_buildOptions
:
function
(
)
{
let
selectOptions
=
(
name
event
)
=
>
{
if
(
this
.
currentToolId
=
=
=
"
options
"
&
&
gDevTools
.
getToolDefinition
(
this
.
lastUsedToolId
)
)
{
this
.
selectTool
(
this
.
lastUsedToolId
)
;
}
else
{
this
.
selectTool
(
"
options
"
)
;
}
event
.
preventDefault
(
)
;
}
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
options
.
key
"
)
selectOptions
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
help
.
key
"
)
selectOptions
)
;
}
_splitConsoleOnKeypress
:
function
(
e
)
{
if
(
e
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
this
.
toggleSplitConsole
(
)
;
if
(
this
.
_threadClient
.
state
=
=
"
paused
"
)
{
e
.
preventDefault
(
)
;
}
}
}
useKeyWithSplitConsole
:
function
(
key
handler
whichTool
)
{
this
.
shortcuts
.
on
(
key
(
name
event
)
=
>
{
if
(
this
.
currentToolId
=
=
=
whichTool
&
&
this
.
isSplitConsoleFocused
(
)
)
{
handler
(
)
;
event
.
preventDefault
(
)
;
}
}
)
;
}
_addReloadKeys
:
function
(
)
{
[
[
"
reload
"
false
]
[
"
reload2
"
false
]
[
"
forceReload
"
true
]
[
"
forceReload2
"
true
]
]
.
forEach
(
(
[
id
force
]
)
=
>
{
let
key
=
L10N
.
getStr
(
"
toolbox
.
"
+
id
+
"
.
key
"
)
;
this
.
shortcuts
.
on
(
key
(
name
event
)
=
>
{
this
.
reloadTarget
(
force
)
;
event
.
preventDefault
(
)
;
}
)
;
}
)
;
}
_addHostListeners
:
function
(
)
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
nextTool
.
key
"
)
(
name
event
)
=
>
{
this
.
selectNextTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
previousTool
.
key
"
)
(
name
event
)
=
>
{
this
.
selectPreviousTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
minimize
.
key
"
)
(
name
event
)
=
>
{
this
.
_toggleMinimizeMode
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleHost
.
key
"
)
(
name
event
)
=
>
{
this
.
switchToPreviousHost
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
doc
.
addEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
false
)
;
this
.
doc
.
addEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
win
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
addEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
_removeHostListeners
:
function
(
)
{
if
(
this
.
doc
)
{
this
.
doc
.
removeEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
false
)
;
this
.
doc
.
removeEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
win
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
removeEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
}
_onBrowserMessage
:
function
(
event
)
{
if
(
!
event
.
data
)
{
return
;
}
switch
(
event
.
data
.
name
)
{
case
"
switched
-
host
"
:
this
.
_onSwitchedHost
(
event
.
data
)
;
break
;
case
"
host
-
minimized
"
:
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
BOTTOM
)
{
this
.
_onBottomHostMinimized
(
)
;
}
break
;
case
"
host
-
maximized
"
:
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
BOTTOM
)
{
this
.
_onBottomHostMaximized
(
)
;
}
break
;
}
}
_registerOverlays
:
function
(
)
{
registerHarOverlay
(
this
)
;
}
_saveSplitConsoleHeight
:
function
(
)
{
Services
.
prefs
.
setIntPref
(
SPLITCONSOLE_HEIGHT_PREF
this
.
webconsolePanel
.
height
)
;
}
_refreshConsoleDisplay
:
function
(
)
{
let
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
let
webconsolePanel
=
this
.
webconsolePanel
;
let
splitter
=
this
.
doc
.
getElementById
(
"
toolbox
-
console
-
splitter
"
)
;
let
openedConsolePanel
=
this
.
currentToolId
=
=
=
"
webconsole
"
;
if
(
openedConsolePanel
)
{
deck
.
setAttribute
(
"
collapsed
"
"
true
"
)
;
splitter
.
setAttribute
(
"
hidden
"
"
true
"
)
;
webconsolePanel
.
removeAttribute
(
"
collapsed
"
)
;
}
else
{
deck
.
removeAttribute
(
"
collapsed
"
)
;
if
(
this
.
splitConsole
)
{
webconsolePanel
.
removeAttribute
(
"
collapsed
"
)
;
splitter
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
webconsolePanel
.
setAttribute
(
"
collapsed
"
"
true
"
)
;
splitter
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
}
_addKeysToWindow
:
function
(
)
{
if
(
this
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
)
{
return
;
}
let
doc
=
this
.
win
.
parent
.
document
;
for
(
let
[
id
toolDefinition
]
of
gDevTools
.
getToolDefinitionMap
(
)
)
{
if
(
!
toolDefinition
.
key
|
|
doc
.
getElementById
(
"
key_
"
+
id
)
)
{
continue
;
}
let
toolId
=
id
;
let
key
=
doc
.
createElement
(
"
key
"
)
;
key
.
id
=
"
key_
"
+
toolId
;
if
(
toolDefinition
.
key
.
startsWith
(
"
VK_
"
)
)
{
key
.
setAttribute
(
"
keycode
"
toolDefinition
.
key
)
;
}
else
{
key
.
setAttribute
(
"
key
"
toolDefinition
.
key
)
;
}
key
.
setAttribute
(
"
modifiers
"
toolDefinition
.
modifiers
)
;
key
.
setAttribute
(
"
oncommand
"
"
void
(
0
)
;
"
)
;
key
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
selectTool
(
toolId
)
.
then
(
(
)
=
>
this
.
fireCustomKey
(
toolId
)
)
;
}
true
)
;
doc
.
getElementById
(
"
toolbox
-
keyset
"
)
.
appendChild
(
key
)
;
}
if
(
!
doc
.
getElementById
(
"
key_browserconsole
"
)
)
{
let
key
=
doc
.
createElement
(
"
key
"
)
;
key
.
id
=
"
key_browserconsole
"
;
key
.
setAttribute
(
"
key
"
L10N
.
getStr
(
"
browserConsoleCmd
.
commandkey
"
)
)
;
key
.
setAttribute
(
"
modifiers
"
"
accel
shift
"
)
;
key
.
setAttribute
(
"
oncommand
"
"
void
(
0
)
"
)
;
key
.
addEventListener
(
"
command
"
(
)
=
>
{
HUDService
.
toggleBrowserConsole
(
)
;
}
true
)
;
doc
.
getElementById
(
"
toolbox
-
keyset
"
)
.
appendChild
(
key
)
;
}
}
fireCustomKey
:
function
(
toolId
)
{
let
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolDefinition
.
onkey
&
&
(
(
this
.
currentToolId
=
=
=
toolId
)
|
|
(
toolId
=
=
"
webconsole
"
&
&
this
.
splitConsole
)
)
)
{
toolDefinition
.
onkey
(
this
.
getCurrentPanel
(
)
this
)
;
}
}
get
notificationBox
(
)
{
if
(
!
this
.
_notificationBox
)
{
let
{
NotificationBox
PriorityLevels
}
=
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
notification
-
box
"
)
;
NotificationBox
=
this
.
React
.
createFactory
(
NotificationBox
)
;
let
box
=
this
.
doc
.
getElementById
(
"
toolbox
-
notificationbox
"
)
;
this
.
_notificationBox
=
Object
.
assign
(
this
.
ReactDOM
.
render
(
NotificationBox
(
{
}
)
box
)
PriorityLevels
)
;
}
return
this
.
_notificationBox
;
}
_buildDockButtons
:
function
(
)
{
let
dockBox
=
this
.
doc
.
getElementById
(
"
toolbox
-
dock
-
buttons
"
)
;
while
(
dockBox
.
firstChild
)
{
dockBox
.
removeChild
(
dockBox
.
firstChild
)
;
}
if
(
!
this
.
_target
.
isLocalTab
)
{
return
;
}
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
BOTTOM
)
{
let
minimizeBtn
=
this
.
doc
.
createElementNS
(
HTML_NS
"
button
"
)
;
minimizeBtn
.
id
=
"
toolbox
-
dock
-
bottom
-
minimize
"
;
minimizeBtn
.
className
=
"
devtools
-
button
"
;
minimizeBtn
.
setAttribute
(
"
hidden
"
"
true
"
)
;
minimizeBtn
.
addEventListener
(
"
click
"
this
.
_toggleMinimizeMode
)
;
dockBox
.
appendChild
(
minimizeBtn
)
;
this
.
_onBottomHostMaximized
(
)
;
this
.
on
(
"
before
-
select
"
this
.
_onToolSelectWhileMinimized
)
;
this
.
once
(
"
host
-
will
-
change
"
this
.
_onBottomHostWillChange
)
;
}
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
this
.
closeButton
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
else
{
this
.
closeButton
.
removeAttribute
(
"
hidden
"
)
;
}
let
sideEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
_prefs
.
SIDE_ENABLED
)
;
for
(
let
type
in
Toolbox
.
HostType
)
{
let
position
=
Toolbox
.
HostType
[
type
]
;
if
(
position
=
=
this
.
hostType
|
|
position
=
=
Toolbox
.
HostType
.
CUSTOM
|
|
(
!
sideEnabled
&
&
position
=
=
Toolbox
.
HostType
.
SIDE
)
)
{
continue
;
}
let
button
=
this
.
doc
.
createElementNS
(
HTML_NS
"
button
"
)
;
button
.
id
=
"
toolbox
-
dock
-
"
+
position
;
button
.
className
=
"
toolbox
-
dock
-
button
devtools
-
button
"
;
button
.
setAttribute
(
"
title
"
L10N
.
getStr
(
"
toolboxDockButtons
.
"
+
position
+
"
.
tooltip
"
)
)
;
button
.
addEventListener
(
"
click
"
this
.
switchHost
.
bind
(
this
position
)
)
;
dockBox
.
appendChild
(
button
)
;
}
}
_getMinimizeButtonShortcutTooltip
:
function
(
)
{
let
str
=
L10N
.
getStr
(
"
toolbox
.
minimize
.
key
"
)
;
let
key
=
KeyShortcuts
.
parseElectronKey
(
this
.
win
str
)
;
return
"
(
"
+
KeyShortcuts
.
stringify
(
key
)
+
"
)
"
;
}
_onBottomHostMinimized
:
function
(
)
{
let
btn
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
dock
-
bottom
-
minimize
"
)
;
btn
.
className
=
"
minimized
"
;
btn
.
setAttribute
(
"
title
"
L10N
.
getStr
(
"
toolboxDockButtons
.
bottom
.
maximize
"
)
+
"
"
+
this
.
_getMinimizeButtonShortcutTooltip
(
)
)
;
}
_onBottomHostMaximized
:
function
(
)
{
let
btn
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
dock
-
bottom
-
minimize
"
)
;
btn
.
className
=
"
maximized
"
;
btn
.
setAttribute
(
"
title
"
L10N
.
getStr
(
"
toolboxDockButtons
.
bottom
.
minimize
"
)
+
"
"
+
this
.
_getMinimizeButtonShortcutTooltip
(
)
)
;
}
_onToolSelectWhileMinimized
:
function
(
)
{
this
.
postMessage
(
{
name
:
"
maximize
-
host
"
}
)
;
}
postMessage
:
function
(
msg
)
{
if
(
this
.
win
.
parent
)
{
msg
.
frameId
=
this
.
frameId
;
this
.
win
.
parent
.
postMessage
(
msg
"
*
"
)
;
}
}
_onBottomHostWillChange
:
function
(
)
{
this
.
postMessage
(
{
name
:
"
maximize
-
host
"
}
)
;
this
.
off
(
"
before
-
select
"
this
.
_onToolSelectWhileMinimized
)
;
}
_toggleMinimizeMode
:
function
(
)
{
if
(
this
.
hostType
!
=
=
Toolbox
.
HostType
.
BOTTOM
)
{
return
;
}
let
toolbarHeight
=
this
.
tabbar
.
getBoxQuads
(
{
box
:
"
content
"
}
)
[
0
]
.
bounds
.
height
;
this
.
postMessage
(
{
name
:
"
toggle
-
minimize
-
mode
"
toolbarHeight
}
)
;
}
_buildTabs
:
function
(
)
{
for
(
let
definition
of
gDevTools
.
getToolDefinitionArray
(
)
)
{
this
.
_buildTabForTool
(
definition
)
;
}
}
get
tabbarFocusableElms
(
)
{
return
[
.
.
.
this
.
tabbar
.
querySelectorAll
(
"
[
tabindex
]
:
not
(
[
hidden
]
)
button
:
not
(
[
hidden
]
)
"
)
]
;
}
_onTabbarFocus
:
function
(
event
)
{
this
.
tabbarFocusableElms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
event
.
target
=
=
=
elm
?
"
0
"
:
"
-
1
"
)
)
;
}
_onTabbarArrowKeypress
:
function
(
event
)
{
let
{
key
target
}
=
event
;
let
focusableElms
=
this
.
tabbarFocusableElms
;
let
curIndex
=
focusableElms
.
indexOf
(
target
)
;
if
(
curIndex
=
=
=
-
1
)
{
console
.
warn
(
target
+
"
is
not
found
among
Developer
Tools
tab
bar
"
+
"
focusable
elements
.
It
needs
to
either
be
a
button
or
have
"
+
"
tabindex
.
If
it
is
intended
to
be
hidden
'
hidden
'
attribute
must
"
+
"
be
used
.
"
)
;
return
;
}
let
newTarget
;
if
(
key
=
=
=
"
ArrowLeft
"
)
{
if
(
curIndex
=
=
=
0
)
{
return
;
}
newTarget
=
focusableElms
[
curIndex
-
1
]
;
}
else
if
(
key
=
=
=
"
ArrowRight
"
)
{
if
(
curIndex
=
=
=
focusableElms
.
length
-
1
)
{
return
;
}
newTarget
=
focusableElms
[
curIndex
+
1
]
;
}
else
{
return
;
}
focusableElms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
newTarget
=
=
=
elm
?
"
0
"
:
"
-
1
"
)
)
;
newTarget
.
focus
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
_buildButtons
:
function
(
)
{
if
(
this
.
target
.
getTrait
(
"
highlightable
"
)
)
{
this
.
_buildPickerButton
(
)
;
}
this
.
setToolboxButtonsVisibility
(
)
;
if
(
!
this
.
target
.
hasActor
(
"
gcli
"
)
)
{
return
promise
.
resolve
(
)
;
}
if
(
this
.
target
.
chrome
)
{
return
promise
.
resolve
(
)
;
}
const
options
=
{
environment
:
CommandUtils
.
createEnvironment
(
this
"
_target
"
)
}
;
return
CommandUtils
.
createRequisition
(
this
.
target
options
)
.
then
(
requisition
=
>
{
this
.
_requisition
=
requisition
;
const
spec
=
CommandUtils
.
getCommandbarSpec
(
"
devtools
.
toolbox
.
toolbarSpec
"
)
;
return
CommandUtils
.
createButtons
(
spec
this
.
target
this
.
doc
requisition
)
.
then
(
buttons
=
>
{
let
container
=
this
.
doc
.
getElementById
(
"
toolbox
-
buttons
"
)
;
buttons
.
forEach
(
button
=
>
{
if
(
button
)
{
container
.
appendChild
(
button
)
;
}
}
)
;
this
.
setToolboxButtonsVisibility
(
)
;
}
)
;
}
)
;
}
_buildPickerButton
:
function
(
)
{
this
.
_pickerButton
=
this
.
doc
.
createElementNS
(
HTML_NS
"
button
"
)
;
this
.
_pickerButton
.
id
=
"
command
-
button
-
pick
"
;
this
.
_pickerButton
.
className
=
"
command
-
button
command
-
button
-
invertable
devtools
-
button
"
;
this
.
_pickerButton
.
setAttribute
(
"
title
"
L10N
.
getStr
(
"
pickButton
.
tooltip
"
)
)
;
let
container
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
picker
-
container
"
)
;
container
.
appendChild
(
this
.
_pickerButton
)
;
this
.
_pickerButton
.
addEventListener
(
"
click
"
this
.
_onPickerClick
false
)
;
}
_onPickerClick
:
function
(
)
{
let
focus
=
this
.
hostType
=
=
=
Toolbox
.
HostType
.
BOTTOM
|
|
this
.
hostType
=
=
=
Toolbox
.
HostType
.
SIDE
;
this
.
highlighterUtils
.
togglePicker
(
focus
)
;
}
_onPickerKeypress
:
function
(
event
)
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
this
.
highlighterUtils
.
cancelPicker
(
)
;
event
.
stopImmediatePropagation
(
)
;
}
}
_onPickerStarted
:
function
(
)
{
this
.
doc
.
addEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
}
_onPickerStopped
:
function
(
)
{
this
.
doc
.
removeEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
}
_applyCacheSettings
:
function
(
)
{
let
pref
=
"
devtools
.
cache
.
disabled
"
;
let
cacheDisabled
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
if
(
this
.
target
.
activeTab
)
{
this
.
target
.
activeTab
.
reconfigure
(
{
"
cacheDisabled
"
:
cacheDisabled
}
)
;
}
}
_applyServiceWorkersTestingSettings
:
function
(
)
{
let
pref
=
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
;
let
serviceWorkersTestingEnabled
=
Services
.
prefs
.
getBoolPref
(
pref
)
|
|
false
;
if
(
this
.
target
.
activeTab
)
{
this
.
target
.
activeTab
.
reconfigure
(
{
"
serviceWorkersTestingEnabled
"
:
serviceWorkersTestingEnabled
}
)
;
}
}
set
pickerButtonChecked
(
isChecked
)
{
if
(
isChecked
)
{
this
.
_pickerButton
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
this
.
_pickerButton
.
removeAttribute
(
"
checked
"
)
;
}
}
get
toolboxButtons
(
)
{
return
ToolboxButtons
.
map
(
options
=
>
{
let
button
=
this
.
doc
.
getElementById
(
options
.
id
)
;
if
(
!
button
)
{
return
false
;
}
return
{
id
:
options
.
id
button
:
button
label
:
button
.
getAttribute
(
"
title
"
)
visibilityswitch
:
"
devtools
.
"
+
options
.
id
+
"
.
enabled
"
isTargetSupported
:
options
.
isTargetSupported
?
options
.
isTargetSupported
:
target
=
>
target
.
isLocalTab
}
;
}
)
.
filter
(
button
=
>
button
)
;
}
setToolboxButtonsVisibility
:
function
(
)
{
this
.
toolboxButtons
.
forEach
(
buttonSpec
=
>
{
let
{
visibilityswitch
button
isTargetSupported
}
=
buttonSpec
;
let
on
=
true
;
try
{
on
=
Services
.
prefs
.
getBoolPref
(
visibilityswitch
)
;
}
catch
(
ex
)
{
}
on
=
on
&
&
isTargetSupported
(
this
.
target
)
;
if
(
button
)
{
if
(
on
)
{
button
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
button
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
}
)
;
this
.
_updateNoautohideButton
(
)
;
}
_buildTabForTool
:
function
(
toolDefinition
)
{
if
(
!
toolDefinition
.
isTargetSupported
(
this
.
_target
)
)
{
return
;
}
let
tabs
=
this
.
doc
.
getElementById
(
"
toolbox
-
tabs
"
)
;
let
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
let
id
=
toolDefinition
.
id
;
if
(
toolDefinition
.
ordinal
=
=
undefined
|
|
toolDefinition
.
ordinal
<
0
)
{
toolDefinition
.
ordinal
=
MAX_ORDINAL
;
}
let
radio
=
this
.
doc
.
createElement
(
"
radio
"
)
;
radio
.
className
=
"
devtools
-
tab
"
;
radio
.
id
=
"
toolbox
-
tab
-
"
+
id
;
radio
.
setAttribute
(
"
toolid
"
id
)
;
radio
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
radio
.
setAttribute
(
"
ordinal
"
toolDefinition
.
ordinal
)
;
radio
.
setAttribute
(
"
tooltiptext
"
toolDefinition
.
tooltip
)
;
if
(
toolDefinition
.
invertIconForLightTheme
)
{
radio
.
setAttribute
(
"
icon
-
invertable
"
"
light
-
theme
"
)
;
}
else
if
(
toolDefinition
.
invertIconForDarkTheme
)
{
radio
.
setAttribute
(
"
icon
-
invertable
"
"
dark
-
theme
"
)
;
}
radio
.
addEventListener
(
"
command
"
this
.
selectTool
.
bind
(
this
id
)
)
;
let
spacer
=
this
.
doc
.
createElement
(
"
spacer
"
)
;
spacer
.
setAttribute
(
"
flex
"
"
1
"
)
;
radio
.
appendChild
(
spacer
)
;
if
(
toolDefinition
.
icon
)
{
let
image
=
this
.
doc
.
createElement
(
"
image
"
)
;
image
.
className
=
"
default
-
icon
"
;
image
.
setAttribute
(
"
src
"
toolDefinition
.
icon
|
|
toolDefinition
.
highlightedicon
)
;
radio
.
appendChild
(
image
)
;
image
=
this
.
doc
.
createElement
(
"
image
"
)
;
image
.
className
=
"
highlighted
-
icon
"
;
image
.
setAttribute
(
"
src
"
toolDefinition
.
highlightedicon
|
|
toolDefinition
.
icon
)
;
radio
.
appendChild
(
image
)
;
}
if
(
toolDefinition
.
label
&
&
!
toolDefinition
.
iconOnly
)
{
let
label
=
this
.
doc
.
createElement
(
"
label
"
)
;
label
.
setAttribute
(
"
value
"
toolDefinition
.
label
)
;
label
.
setAttribute
(
"
crop
"
"
end
"
)
;
label
.
setAttribute
(
"
flex
"
"
1
"
)
;
radio
.
appendChild
(
label
)
;
}
if
(
!
toolDefinition
.
bgTheme
)
{
toolDefinition
.
bgTheme
=
"
theme
-
toolbar
"
;
}
let
vbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
vbox
.
className
=
"
toolbox
-
panel
"
+
toolDefinition
.
bgTheme
;
if
(
!
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
)
{
vbox
.
id
=
"
toolbox
-
panel
-
"
+
id
;
}
if
(
id
=
=
=
"
options
"
)
{
radio
.
setAttribute
(
"
role
"
"
button
"
)
;
let
optionTabContainer
=
this
.
doc
.
getElementById
(
"
toolbox
-
option
-
container
"
)
;
optionTabContainer
.
appendChild
(
radio
)
;
deck
.
appendChild
(
vbox
)
;
}
else
{
radio
.
setAttribute
(
"
role
"
"
tab
"
)
;
if
(
tabs
.
childNodes
.
length
=
=
0
|
|
tabs
.
lastChild
.
getAttribute
(
"
ordinal
"
)
<
=
toolDefinition
.
ordinal
)
{
tabs
.
appendChild
(
radio
)
;
deck
.
appendChild
(
vbox
)
;
}
else
{
Array
.
some
(
tabs
.
childNodes
(
node
i
)
=
>
{
if
(
+
node
.
getAttribute
(
"
ordinal
"
)
>
toolDefinition
.
ordinal
)
{
tabs
.
insertBefore
(
radio
node
)
;
deck
.
insertBefore
(
vbox
deck
.
childNodes
[
i
]
)
;
return
true
;
}
return
false
;
}
)
;
}
}
this
.
_addKeysToWindow
(
)
;
}
get
additionalToolDefinitions
(
)
{
if
(
!
this
.
_additionalToolDefinitions
)
{
this
.
_additionalToolDefinitions
=
new
Map
(
)
;
}
return
this
.
_additionalToolDefinitions
;
}
getAdditionalTools
(
)
{
return
Array
.
from
(
this
.
additionalToolDefinitions
.
values
(
)
)
;
}
hasAdditionalTool
(
toolId
)
{
return
this
.
additionalToolDefinitions
.
has
(
toolId
)
;
}
addAdditionalTool
(
definition
)
{
if
(
!
definition
.
id
)
{
throw
new
Error
(
"
Tool
definition
id
is
missing
"
)
;
}
if
(
this
.
isToolRegistered
(
definition
.
id
)
)
{
throw
new
Error
(
"
Tool
definition
already
registered
:
"
+
definition
.
id
)
;
}
this
.
additionalToolDefinitions
.
set
(
definition
.
id
definition
)
;
this
.
_buildTabForTool
(
definition
)
;
}
removeAdditionalTool
(
toolId
)
{
if
(
!
this
.
hasAdditionalTool
(
toolId
)
)
{
throw
new
Error
(
"
Tool
definition
not
registered
to
this
toolbox
:
"
+
toolId
)
;
}
this
.
unloadTool
(
toolId
)
;
this
.
additionalToolDefinitions
.
delete
(
toolId
)
;
}
loadTool
:
function
(
id
)
{
if
(
id
=
=
=
"
inspector
"
&
&
!
this
.
_inspector
)
{
return
this
.
initInspector
(
)
.
then
(
(
)
=
>
{
return
this
.
loadTool
(
id
)
;
}
)
;
}
let
deferred
=
defer
(
)
;
let
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
iframe
)
{
let
panel
=
this
.
_toolPanels
.
get
(
id
)
;
if
(
panel
)
{
deferred
.
resolve
(
panel
)
;
}
else
{
this
.
once
(
id
+
"
-
ready
"
initializedPanel
=
>
{
deferred
.
resolve
(
initializedPanel
)
;
}
)
;
}
return
deferred
.
promise
;
}
let
definition
=
this
.
getToolDefinition
(
id
)
;
if
(
!
definition
)
{
deferred
.
reject
(
new
Error
(
"
no
such
tool
id
"
+
id
)
)
;
return
deferred
.
promise
;
}
iframe
=
this
.
doc
.
createElement
(
"
iframe
"
)
;
iframe
.
className
=
"
toolbox
-
panel
-
iframe
"
;
iframe
.
id
=
"
toolbox
-
panel
-
iframe
-
"
+
id
;
iframe
.
setAttribute
(
"
flex
"
1
)
;
iframe
.
setAttribute
(
"
forceOwnRefreshDriver
"
"
"
)
;
iframe
.
tooltip
=
"
aHTMLTooltip
"
;
iframe
.
style
.
visibility
=
"
hidden
"
;
gDevTools
.
emit
(
id
+
"
-
init
"
this
iframe
)
;
this
.
emit
(
id
+
"
-
init
"
iframe
)
;
if
(
!
iframe
.
parentNode
)
{
let
vbox
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
;
vbox
.
appendChild
(
iframe
)
;
}
let
onLoad
=
(
)
=
>
{
iframe
.
style
.
visibility
=
"
visible
"
;
this
.
setIframeDocumentDir
(
iframe
)
;
let
built
=
definition
.
build
(
iframe
.
contentWindow
this
)
;
if
(
!
(
typeof
built
.
then
=
=
"
function
"
)
)
{
let
panel
=
built
;
iframe
.
panel
=
panel
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
build
"
this
panel
)
;
this
.
emit
(
id
+
"
-
build
"
panel
)
;
if
(
typeof
panel
.
open
=
=
"
function
"
)
{
built
=
panel
.
open
(
)
;
}
else
{
let
buildDeferred
=
defer
(
)
;
buildDeferred
.
resolve
(
panel
)
;
built
=
buildDeferred
.
promise
;
}
}
promise
.
resolve
(
built
)
.
then
(
(
panel
)
=
>
{
this
.
_toolPanels
.
set
(
id
panel
)
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
ready
"
this
panel
)
;
this
.
emit
(
id
+
"
-
ready
"
panel
)
;
deferred
.
resolve
(
panel
)
;
}
console
.
error
)
;
}
;
iframe
.
setAttribute
(
"
src
"
definition
.
url
)
;
if
(
definition
.
panelLabel
)
{
iframe
.
setAttribute
(
"
aria
-
label
"
definition
.
panelLabel
)
;
}
if
(
iframe
.
contentWindow
)
{
let
domHelper
=
new
DOMHelpers
(
iframe
.
contentWindow
)
;
domHelper
.
onceDOMReady
(
onLoad
)
;
}
else
{
let
callback
=
(
)
=
>
{
iframe
.
removeEventListener
(
"
DOMContentLoaded
"
callback
)
;
onLoad
(
)
;
}
;
iframe
.
addEventListener
(
"
DOMContentLoaded
"
callback
)
;
}
return
deferred
.
promise
;
}
setIframeDocumentDir
:
function
(
iframe
)
{
let
docEl
=
iframe
.
contentWindow
&
&
iframe
.
contentWindow
.
document
.
documentElement
;
if
(
!
docEl
|
|
docEl
.
namespaceURI
!
=
=
HTML_NS
)
{
return
;
}
if
(
docEl
.
hasAttribute
(
"
dir
"
)
)
{
let
top
=
this
.
win
.
top
;
let
topDocEl
=
top
.
document
.
documentElement
;
let
isRtl
=
top
.
getComputedStyle
(
topDocEl
)
.
direction
=
=
=
"
rtl
"
;
docEl
.
setAttribute
(
"
dir
"
isRtl
?
"
rtl
"
:
"
ltr
"
)
;
}
}
selectSingleNode
:
function
(
collection
id
)
{
[
.
.
.
collection
]
.
forEach
(
node
=
>
{
if
(
node
.
id
=
=
=
id
)
{
node
.
setAttribute
(
"
selected
"
"
true
"
)
;
node
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
}
else
{
node
.
removeAttribute
(
"
selected
"
)
;
node
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
}
)
;
}
selectTool
:
function
(
id
)
{
this
.
emit
(
"
before
-
select
"
id
)
;
let
tabs
=
this
.
doc
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
;
this
.
selectSingleNode
(
tabs
"
toolbox
-
tab
-
"
+
id
)
;
let
sep
=
this
.
doc
.
getElementById
(
"
toolbox
-
controls
-
separator
"
)
;
if
(
id
=
=
=
"
options
"
)
{
sep
.
setAttribute
(
"
invisible
"
"
true
"
)
;
}
else
{
sep
.
removeAttribute
(
"
invisible
"
)
;
}
if
(
this
.
currentToolId
=
=
id
)
{
let
panel
=
this
.
_toolPanels
.
get
(
id
)
;
if
(
panel
)
{
this
.
focusTool
(
id
)
;
return
promise
.
resolve
(
panel
)
;
}
return
this
.
once
(
"
select
"
)
.
then
(
(
)
=
>
promise
.
resolve
(
this
.
_toolPanels
.
get
(
id
)
)
)
;
}
if
(
!
this
.
isReady
)
{
throw
new
Error
(
"
Can
'
t
select
tool
wait
for
toolbox
'
ready
'
event
"
)
;
}
let
tab
=
this
.
doc
.
getElementById
(
"
toolbox
-
tab
-
"
+
id
)
;
if
(
tab
)
{
if
(
this
.
currentToolId
)
{
this
.
_telemetry
.
toolClosed
(
this
.
currentToolId
)
;
}
this
.
_telemetry
.
toolOpened
(
id
)
;
}
else
{
throw
new
Error
(
"
No
tool
found
"
)
;
}
let
tabstrip
=
this
.
doc
.
getElementById
(
"
toolbox
-
tabs
"
)
;
tabstrip
.
selectedItem
=
tab
|
|
tabstrip
.
childNodes
[
0
]
;
let
toolboxPanels
=
this
.
doc
.
querySelectorAll
(
"
.
toolbox
-
panel
"
)
;
this
.
selectSingleNode
(
toolboxPanels
"
toolbox
-
panel
-
"
+
id
)
;
this
.
lastUsedToolId
=
this
.
currentToolId
;
this
.
currentToolId
=
id
;
this
.
_refreshConsoleDisplay
(
)
;
if
(
id
!
=
"
options
"
)
{
Services
.
prefs
.
setCharPref
(
this
.
_prefs
.
LAST_TOOL
id
)
;
}
return
this
.
loadTool
(
id
)
.
then
(
panel
=
>
{
this
.
focusTool
(
id
)
;
this
.
emit
(
"
select
"
id
)
;
this
.
emit
(
id
+
"
-
selected
"
panel
)
;
return
panel
;
}
)
;
}
focusTool
:
function
(
id
state
=
true
)
{
let
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
state
)
{
iframe
.
focus
(
)
;
}
else
{
iframe
.
blur
(
)
;
}
}
focusConsoleInput
:
function
(
)
{
let
consolePanel
=
this
.
getPanel
(
"
webconsole
"
)
;
if
(
consolePanel
)
{
consolePanel
.
focusInput
(
)
;
}
}
_onFocus
:
function
(
{
originalTarget
}
)
{
let
webconsoleURL
=
gDevTools
.
getToolDefinition
(
"
webconsole
"
)
.
url
;
if
(
originalTarget
.
nodeType
!
=
=
1
|
|
originalTarget
.
baseURI
=
=
=
webconsoleURL
)
{
return
;
}
this
.
_lastFocusedElement
=
originalTarget
;
}
openSplitConsole
:
function
(
)
{
this
.
_splitConsole
=
true
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_ENABLED_PREF
true
)
;
this
.
_refreshConsoleDisplay
(
)
;
this
.
emit
(
"
split
-
console
"
)
;
return
this
.
loadTool
(
"
webconsole
"
)
.
then
(
(
)
=
>
{
this
.
focusConsoleInput
(
)
;
}
)
;
}
closeSplitConsole
:
function
(
)
{
this
.
_splitConsole
=
false
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_ENABLED_PREF
false
)
;
this
.
_refreshConsoleDisplay
(
)
;
this
.
emit
(
"
split
-
console
"
)
;
if
(
this
.
_lastFocusedElement
)
{
this
.
_lastFocusedElement
.
focus
(
)
;
}
return
promise
.
resolve
(
)
;
}
toggleSplitConsole
:
function
(
)
{
if
(
this
.
currentToolId
!
=
=
"
webconsole
"
)
{
return
this
.
splitConsole
?
this
.
closeSplitConsole
(
)
:
this
.
openSplitConsole
(
)
;
}
return
promise
.
resolve
(
)
;
}
reloadTarget
:
function
(
force
)
{
this
.
target
.
activeTab
.
reload
(
{
force
:
force
}
)
;
}
selectNextTool
:
function
(
)
{
let
tools
=
this
.
doc
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
;
let
selected
=
this
.
doc
.
querySelector
(
"
.
devtools
-
tab
[
selected
]
"
)
;
let
nextIndex
=
[
.
.
.
tools
]
.
indexOf
(
selected
)
+
1
;
let
next
=
tools
[
nextIndex
]
|
|
tools
[
0
]
;
let
tool
=
next
.
getAttribute
(
"
toolid
"
)
;
return
this
.
selectTool
(
tool
)
;
}
selectPreviousTool
:
function
(
)
{
let
tools
=
this
.
doc
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
;
let
selected
=
this
.
doc
.
querySelector
(
"
.
devtools
-
tab
[
selected
]
"
)
;
let
prevIndex
=
[
.
.
.
tools
]
.
indexOf
(
selected
)
-
1
;
let
prev
=
tools
[
prevIndex
]
|
|
tools
[
tools
.
length
-
1
]
;
let
tool
=
prev
.
getAttribute
(
"
toolid
"
)
;
return
this
.
selectTool
(
tool
)
;
}
highlightTool
:
function
(
id
)
{
let
tab
=
this
.
doc
.
getElementById
(
"
toolbox
-
tab
-
"
+
id
)
;
tab
&
&
tab
.
setAttribute
(
"
highlighted
"
"
true
"
)
;
}
unhighlightTool
:
function
(
id
)
{
let
tab
=
this
.
doc
.
getElementById
(
"
toolbox
-
tab
-
"
+
id
)
;
tab
&
&
tab
.
removeAttribute
(
"
highlighted
"
)
;
}
raise
:
function
(
)
{
this
.
postMessage
(
{
name
:
"
raise
-
host
"
}
)
;
}
_refreshHostTitle
:
function
(
)
{
let
title
;
if
(
this
.
target
.
name
&
&
this
.
target
.
name
!
=
this
.
target
.
url
)
{
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate2
"
this
.
target
.
name
this
.
target
.
url
)
;
}
else
{
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate1
"
this
.
target
.
url
)
;
}
this
.
postMessage
(
{
name
:
"
set
-
host
-
title
"
title
}
)
;
}
get
_preferenceFront
(
)
{
return
this
.
target
.
root
.
then
(
rootForm
=
>
{
return
getPreferenceFront
(
this
.
target
.
client
rootForm
)
;
}
)
;
}
_toggleAutohide
:
Task
.
async
(
function
*
(
)
{
let
prefName
=
"
ui
.
popup
.
disable_autohide
"
;
let
front
=
yield
this
.
_preferenceFront
;
let
current
=
yield
front
.
getBoolPref
(
prefName
)
;
yield
front
.
setBoolPref
(
prefName
!
current
)
;
this
.
_updateNoautohideButton
(
)
;
}
)
_updateNoautohideButton
:
Task
.
async
(
function
*
(
)
{
let
menu
=
this
.
doc
.
getElementById
(
"
command
-
button
-
noautohide
"
)
;
if
(
menu
.
getAttribute
(
"
hidden
"
)
=
=
=
"
true
"
)
{
return
;
}
if
(
!
this
.
target
.
root
)
{
return
;
}
let
prefName
=
"
ui
.
popup
.
disable_autohide
"
;
let
front
=
yield
this
.
_preferenceFront
;
let
current
=
yield
front
.
getBoolPref
(
prefName
)
;
if
(
current
)
{
menu
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
else
{
menu
.
removeAttribute
(
"
checked
"
)
;
}
}
)
_listFrames
:
function
(
event
)
{
if
(
!
this
.
_target
.
activeTab
|
|
!
this
.
_target
.
activeTab
.
traits
.
frames
)
{
return
promise
.
resolve
(
)
;
}
let
packet
=
{
to
:
this
.
_target
.
form
.
actor
type
:
"
listFrames
"
}
;
return
this
.
_target
.
client
.
request
(
packet
resp
=
>
{
this
.
_updateFrames
(
null
{
frames
:
resp
.
frames
}
)
;
}
)
;
}
showFramesMenu
:
function
(
event
)
{
let
menu
=
new
Menu
(
)
;
let
target
=
event
.
target
;
this
.
frameMap
.
forEach
(
frame
=
>
{
let
checked
=
frame
.
id
=
=
this
.
selectedFrameId
;
menu
.
append
(
new
MenuItem
(
{
label
:
frame
.
url
type
:
"
radio
"
checked
click
:
(
)
=
>
{
this
.
onSelectFrame
(
frame
.
id
)
;
}
}
)
)
;
}
)
;
menu
.
once
(
"
open
"
)
.
then
(
(
)
=
>
{
target
.
setAttribute
(
"
open
"
"
true
"
)
;
}
)
;
menu
.
once
(
"
close
"
)
.
then
(
(
)
=
>
{
target
.
removeAttribute
(
"
open
"
)
;
}
)
;
let
rect
=
target
.
getBoundingClientRect
(
)
;
let
screenX
=
target
.
ownerDocument
.
defaultView
.
mozInnerScreenX
;
let
screenY
=
target
.
ownerDocument
.
defaultView
.
mozInnerScreenY
;
menu
.
popup
(
rect
.
left
+
screenX
rect
.
bottom
+
screenY
this
)
;
return
menu
;
}
onSelectFrame
:
function
(
frameId
)
{
let
packet
=
{
to
:
this
.
_target
.
form
.
actor
type
:
"
switchToFrame
"
windowId
:
frameId
}
;
this
.
_target
.
client
.
request
(
packet
)
;
}
_updateFrames
:
function
(
event
data
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
command
-
button
-
frames
.
enabled
"
)
)
{
return
;
}
if
(
!
this
.
isReady
)
{
return
;
}
if
(
data
.
destroyAll
)
{
this
.
frameMap
.
clear
(
)
;
this
.
selectedFrameId
=
null
;
}
else
if
(
data
.
selected
)
{
this
.
selectedFrameId
=
data
.
selected
;
}
else
if
(
data
.
frames
)
{
data
.
frames
.
forEach
(
frame
=
>
{
if
(
frame
.
destroy
)
{
this
.
frameMap
.
delete
(
frame
.
id
)
;
if
(
this
.
selectedFrameId
=
=
frame
.
id
)
{
this
.
selectedFrameId
=
null
;
}
}
else
{
this
.
frameMap
.
set
(
frame
.
id
frame
)
;
}
}
)
;
}
if
(
!
this
.
selectedFrameId
)
{
let
frames
=
[
.
.
.
this
.
frameMap
.
values
(
)
]
;
let
topFrames
=
frames
.
filter
(
frame
=
>
!
frame
.
parentID
)
;
this
.
selectedFrameId
=
topFrames
.
length
?
topFrames
[
0
]
.
id
:
null
;
}
let
frame
=
this
.
frameMap
.
get
(
this
.
selectedFrameId
)
;
let
topFrameSelected
=
frame
?
!
frame
.
parentID
:
false
;
let
button
=
this
.
doc
.
getElementById
(
"
command
-
button
-
frames
"
)
;
button
.
removeAttribute
(
"
checked
"
)
;
if
(
!
topFrameSelected
&
&
this
.
selectedFrameId
)
{
button
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
}
switchToPreviousHost
:
function
(
)
{
return
this
.
switchHost
(
"
previous
"
)
;
}
switchHost
:
function
(
hostType
)
{
if
(
hostType
=
=
this
.
hostType
|
|
!
this
.
_target
.
isLocalTab
)
{
return
null
;
}
this
.
emit
(
"
host
-
will
-
change
"
hostType
)
;
this
.
focusTool
(
this
.
currentToolId
false
)
;
this
.
postMessage
(
{
name
:
"
switch
-
host
"
hostType
}
)
;
return
this
.
once
(
"
host
-
changed
"
)
;
}
_onSwitchedHost
:
function
(
{
hostType
}
)
{
this
.
_hostType
=
hostType
;
this
.
_buildDockButtons
(
)
;
this
.
_addKeysToWindow
(
)
;
this
.
focusTool
(
this
.
currentToolId
true
)
;
this
.
emit
(
"
host
-
changed
"
)
;
this
.
_telemetry
.
log
(
HOST_HISTOGRAM
this
.
_getTelemetryHostId
(
)
)
;
}
isToolRegistered
:
function
(
toolId
)
{
return
!
!
this
.
getToolDefinition
(
toolId
)
;
}
getToolDefinition
:
function
(
toolId
)
{
return
gDevTools
.
getToolDefinition
(
toolId
)
|
|
this
.
additionalToolDefinitions
.
get
(
toolId
)
;
}
unloadTool
:
function
(
toolId
)
{
if
(
typeof
toolId
!
=
"
string
"
)
{
throw
new
Error
(
"
Unexpected
non
-
string
toolId
received
.
"
)
;
}
if
(
this
.
_toolPanels
.
has
(
toolId
)
)
{
let
instance
=
this
.
_toolPanels
.
get
(
toolId
)
;
instance
.
destroy
(
)
;
this
.
_toolPanels
.
delete
(
toolId
)
;
}
let
radio
=
this
.
doc
.
getElementById
(
"
toolbox
-
tab
-
"
+
toolId
)
;
let
panel
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
toolId
)
;
if
(
radio
)
{
if
(
this
.
currentToolId
=
=
toolId
)
{
let
nextToolName
=
null
;
if
(
radio
.
nextSibling
)
{
nextToolName
=
radio
.
nextSibling
.
getAttribute
(
"
toolid
"
)
;
}
if
(
radio
.
previousSibling
)
{
nextToolName
=
radio
.
previousSibling
.
getAttribute
(
"
toolid
"
)
;
}
if
(
nextToolName
)
{
this
.
selectTool
(
nextToolName
)
;
}
}
radio
.
parentNode
.
removeChild
(
radio
)
;
}
if
(
panel
)
{
panel
.
parentNode
.
removeChild
(
panel
)
;
}
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
let
doc
=
this
.
win
.
parent
.
document
;
let
key
=
doc
.
getElementById
(
"
key_
"
+
toolId
)
;
if
(
key
)
{
key
.
parentNode
.
removeChild
(
key
)
;
}
}
}
_toolRegistered
:
function
(
event
toolId
)
{
let
tool
=
this
.
getToolDefinition
(
toolId
)
;
if
(
!
tool
)
{
return
;
}
this
.
_buildTabForTool
(
tool
)
;
this
.
emit
(
"
tool
-
registered
"
toolId
)
;
}
_toolUnregistered
:
function
(
event
toolId
)
{
this
.
unloadTool
(
toolId
)
;
this
.
emit
(
"
tool
-
unregistered
"
toolId
)
;
}
initInspector
:
function
(
)
{
if
(
!
this
.
_initInspector
)
{
this
.
_initInspector
=
Task
.
spawn
(
function
*
(
)
{
this
.
_inspector
=
InspectorFront
(
this
.
_target
.
client
this
.
_target
.
form
)
;
let
pref
=
"
devtools
.
inspector
.
showAllAnonymousContent
"
;
let
showAllAnonymousContent
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
this
.
_walker
=
yield
this
.
_inspector
.
getWalker
(
{
showAllAnonymousContent
}
)
;
this
.
_selection
=
new
Selection
(
this
.
_walker
)
;
if
(
this
.
highlighterUtils
.
isRemoteHighlightable
(
)
)
{
this
.
walker
.
on
(
"
highlighter
-
ready
"
this
.
_highlighterReady
)
;
this
.
walker
.
on
(
"
highlighter
-
hide
"
this
.
_highlighterHidden
)
;
let
autohide
=
!
flags
.
testing
;
this
.
_highlighter
=
yield
this
.
_inspector
.
getHighlighter
(
autohide
)
;
}
}
.
bind
(
this
)
)
;
}
return
this
.
_initInspector
;
}
destroyInspector
:
function
(
)
{
if
(
this
.
_destroyingInspector
)
{
return
this
.
_destroyingInspector
;
}
this
.
_destroyingInspector
=
Task
.
spawn
(
function
*
(
)
{
if
(
!
this
.
_inspector
)
{
return
;
}
if
(
this
.
_walker
&
&
!
this
.
walker
.
traits
.
autoReleased
)
{
try
{
yield
this
.
_walker
.
release
(
)
;
}
catch
(
e
)
{
}
}
yield
this
.
highlighterUtils
.
stopPicker
(
)
;
yield
this
.
_inspector
.
destroy
(
)
;
if
(
this
.
_highlighter
)
{
if
(
!
this
.
highlighter
.
traits
.
autoHideOnDestroy
)
{
this
.
highlighterUtils
.
unhighlight
(
)
;
}
yield
this
.
_highlighter
.
destroy
(
)
;
}
if
(
this
.
_selection
)
{
this
.
_selection
.
destroy
(
)
;
}
if
(
this
.
walker
)
{
this
.
walker
.
off
(
"
highlighter
-
ready
"
this
.
_highlighterReady
)
;
this
.
walker
.
off
(
"
highlighter
-
hide
"
this
.
_highlighterHidden
)
;
}
this
.
_inspector
=
null
;
this
.
_highlighter
=
null
;
this
.
_selection
=
null
;
this
.
_walker
=
null
;
}
.
bind
(
this
)
)
;
return
this
.
_destroyingInspector
;
}
getNotificationBox
:
function
(
)
{
return
this
.
notificationBox
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
let
deferred
=
defer
(
)
;
this
.
_destroyer
=
deferred
.
promise
;
this
.
emit
(
"
destroy
"
)
;
this
.
_target
.
off
(
"
navigate
"
this
.
_refreshHostTitle
)
;
this
.
_target
.
off
(
"
frame
-
update
"
this
.
_updateFrames
)
;
this
.
off
(
"
select
"
this
.
_refreshHostTitle
)
;
this
.
off
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
this
.
off
(
"
ready
"
this
.
_showDevEditionPromo
)
;
gDevTools
.
off
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
off
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
gDevTools
.
off
(
"
pref
-
changed
"
this
.
_prefChanged
)
;
this
.
_lastFocusedElement
=
null
;
if
(
this
.
_sourceMapService
)
{
this
.
_sourceMapService
.
destroy
(
)
;
this
.
_sourceMapService
=
null
;
}
if
(
this
.
webconsolePanel
)
{
this
.
_saveSplitConsoleHeight
(
)
;
this
.
webconsolePanel
.
removeEventListener
(
"
resize
"
this
.
_saveSplitConsoleHeight
)
;
this
.
webconsolePanel
=
null
;
}
if
(
this
.
closeButton
)
{
this
.
closeButton
.
removeEventListener
(
"
click
"
this
.
destroy
true
)
;
this
.
closeButton
=
null
;
}
if
(
this
.
textBoxContextMenuPopup
)
{
this
.
textBoxContextMenuPopup
.
removeEventListener
(
"
popupshowing
"
this
.
_updateTextBoxMenuItems
true
)
;
this
.
textBoxContextMenuPopup
=
null
;
}
if
(
this
.
tabbar
)
{
this
.
tabbar
.
removeEventListener
(
"
focus
"
this
.
_onTabbarFocus
true
)
;
this
.
tabbar
.
removeEventListener
(
"
click
"
this
.
_onTabbarFocus
true
)
;
this
.
tabbar
.
removeEventListener
(
"
keypress
"
this
.
_onTabbarArrowKeypress
)
;
this
.
tabbar
=
null
;
}
let
outstanding
=
[
]
;
for
(
let
[
id
panel
]
of
this
.
_toolPanels
)
{
try
{
gDevTools
.
emit
(
id
+
"
-
destroy
"
this
panel
)
;
this
.
emit
(
id
+
"
-
destroy
"
panel
)
;
outstanding
.
push
(
panel
.
destroy
(
)
)
;
}
catch
(
e
)
{
console
.
error
(
"
Panel
"
+
id
+
"
:
"
e
)
;
}
}
this
.
browserRequire
=
null
;
if
(
this
.
target
.
activeTab
&
&
!
this
.
target
.
activeTab
.
traits
.
noTabReconfigureOnClose
)
{
this
.
target
.
activeTab
.
reconfigure
(
{
"
cacheDisabled
"
:
false
"
serviceWorkersTestingEnabled
"
:
false
}
)
;
}
outstanding
.
push
(
this
.
destroyInspector
(
)
.
then
(
(
)
=
>
{
if
(
this
.
_pickerButton
)
{
this
.
_pickerButton
.
removeEventListener
(
"
click
"
this
.
_togglePicker
false
)
;
this
.
_pickerButton
=
null
;
}
}
)
)
;
outstanding
.
push
(
this
.
destroyPerformance
(
)
)
;
detachThread
(
this
.
_threadClient
)
;
this
.
_threadClient
=
null
;
let
win
=
this
.
win
;
if
(
this
.
_requisition
)
{
CommandUtils
.
destroyRequisition
(
this
.
_requisition
this
.
target
)
;
}
this
.
_telemetry
.
toolClosed
(
"
toolbox
"
)
;
this
.
_telemetry
.
destroy
(
)
;
deferred
.
resolve
(
settleAll
(
outstanding
)
.
catch
(
console
.
error
)
.
then
(
(
)
=
>
{
this
.
_removeHostListeners
(
)
;
if
(
win
.
location
)
{
win
.
location
.
replace
(
"
about
:
blank
"
)
;
}
if
(
!
this
.
_target
)
{
return
null
;
}
let
target
=
this
.
_target
;
this
.
_target
=
null
;
this
.
highlighterUtils
.
release
(
)
;
target
.
off
(
"
close
"
this
.
destroy
)
;
return
target
.
destroy
(
)
;
}
console
.
error
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
destroyed
"
)
;
this
.
_host
=
null
;
this
.
_win
=
null
;
this
.
_toolPanels
.
clear
(
)
;
if
(
flags
.
testing
)
{
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
garbageCollect
(
)
;
}
}
)
.
then
(
null
console
.
error
)
)
;
let
leakCheckObserver
=
(
{
wrappedJSObject
:
barrier
}
)
=
>
{
barrier
.
client
.
addBlocker
(
"
DevTools
:
Wait
until
toolbox
is
destroyed
"
this
.
_destroyer
)
;
}
;
let
topic
=
"
shutdown
-
leaks
-
before
-
check
"
;
Services
.
obs
.
addObserver
(
leakCheckObserver
topic
false
)
;
this
.
_destroyer
.
then
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
leakCheckObserver
topic
)
;
}
)
;
return
this
.
_destroyer
;
}
_highlighterReady
:
function
(
)
{
this
.
emit
(
"
highlighter
-
ready
"
)
;
}
_highlighterHidden
:
function
(
)
{
this
.
emit
(
"
highlighter
-
hide
"
)
;
}
_showDevEditionPromo
:
function
(
)
{
if
(
this
.
target
.
chrome
)
{
return
;
}
showDoorhanger
(
{
window
:
this
.
win
type
:
"
deveditionpromo
"
}
)
;
}
_updateTextBoxMenuItems
:
function
(
)
{
let
window
=
this
.
win
;
[
"
cmd_undo
"
"
cmd_delete
"
"
cmd_cut
"
"
cmd_copy
"
"
cmd_paste
"
"
cmd_selectAll
"
]
.
forEach
(
window
.
goUpdateCommand
)
;
}
openTextBoxContextMenu
:
function
(
x
y
)
{
this
.
textBoxContextMenuPopup
.
openPopupAtScreen
(
x
y
true
)
;
}
initPerformance
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
target
.
hasActor
(
"
profiler
"
)
)
{
return
promise
.
resolve
(
)
;
}
if
(
this
.
_performanceFrontConnection
)
{
return
this
.
_performanceFrontConnection
.
promise
;
}
this
.
_performanceFrontConnection
=
defer
(
)
;
this
.
_performance
=
createPerformanceFront
(
this
.
_target
)
;
yield
this
.
performance
.
connect
(
)
;
this
.
emit
(
"
profiler
-
connected
"
)
;
this
.
performance
.
on
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
this
.
_performanceFrontConnection
.
resolve
(
this
.
performance
)
;
return
this
.
_performanceFrontConnection
.
promise
;
}
)
destroyPerformance
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
performance
)
{
return
;
}
if
(
this
.
_performanceFrontConnection
)
{
yield
this
.
_performanceFrontConnection
.
promise
;
}
this
.
performance
.
off
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
yield
this
.
performance
.
destroy
(
)
;
this
.
_performance
=
null
;
}
)
_onPerformanceFrontEvent
:
Task
.
async
(
function
*
(
eventName
recording
)
{
if
(
this
.
getPanel
(
"
performance
"
)
)
{
this
.
performance
.
off
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
return
;
}
this
.
_performanceQueuedRecordings
=
this
.
_performanceQueuedRecordings
|
|
[
]
;
let
recordings
=
this
.
_performanceQueuedRecordings
;
if
(
eventName
=
=
=
"
console
-
profile
-
start
"
&
&
!
this
.
_performanceToolOpenedViaConsole
)
{
this
.
_performanceToolOpenedViaConsole
=
this
.
loadTool
(
"
performance
"
)
;
let
panel
=
yield
this
.
_performanceToolOpenedViaConsole
;
yield
panel
.
open
(
)
;
panel
.
panelWin
.
PerformanceController
.
populateWithRecordings
(
recordings
)
;
this
.
performance
.
off
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
}
if
(
eventName
=
=
=
"
recording
-
started
"
)
{
recordings
.
push
(
recording
)
;
}
}
)
get
gViewSourceUtils
(
)
{
return
this
.
win
.
gViewSourceUtils
;
}
viewSourceInStyleEditor
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInStyleEditor
(
this
sourceURL
sourceLine
)
;
}
viewSourceInDebugger
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInDebugger
(
this
sourceURL
sourceLine
)
;
}
viewSourceInScratchpad
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInScratchpad
(
sourceURL
sourceLine
)
;
}
viewSource
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSource
(
this
sourceURL
sourceLine
)
;
}
}
;
