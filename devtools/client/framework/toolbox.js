"
use
strict
"
;
const
SOURCE_MAP_WORKER
=
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
/
worker
.
js
"
;
const
MAX_ORDINAL
=
99
;
const
SPLITCONSOLE_ENABLED_PREF
=
"
devtools
.
toolbox
.
splitconsoleEnabled
"
;
const
SPLITCONSOLE_HEIGHT_PREF
=
"
devtools
.
toolbox
.
splitconsoleHeight
"
;
const
DISABLE_AUTOHIDE_PREF
=
"
ui
.
popup
.
disable_autohide
"
;
const
HOST_HISTOGRAM
=
"
DEVTOOLS_TOOLBOX_HOST
"
;
const
SCREENSIZE_HISTOGRAM
=
"
DEVTOOLS_SCREEN_RESOLUTION_ENUMERATED_PER_USER
"
;
const
CURRENT_THEME_SCALAR
=
"
devtools
.
current_theme
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
REGEX_PANEL
=
/
webconsole
|
inspector
|
jsdebugger
|
styleeditor
|
netmonitor
|
storage
/
;
var
{
Ci
Cc
}
=
require
(
"
chrome
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
ChromeUtils
=
require
(
"
ChromeUtils
"
)
;
var
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
var
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
{
getUnicodeUrl
}
=
require
(
"
devtools
/
client
/
shared
/
unicode
-
url
"
)
;
var
{
attachThread
detachThread
}
=
require
(
"
.
/
attach
-
thread
"
)
;
var
Menu
=
require
(
"
devtools
/
client
/
framework
/
menu
"
)
;
var
MenuItem
=
require
(
"
devtools
/
client
/
framework
/
menu
-
item
"
)
;
var
{
DOMHelpers
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
DOMHelpers
.
jsm
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
var
Startup
=
Cc
[
"
mozilla
.
org
/
devtools
/
startup
-
clh
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
const
{
BrowserLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
{
}
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
loader
.
lazyRequireGetter
(
this
"
getHighlighterUtils
"
"
devtools
/
client
/
framework
/
toolbox
-
highlighter
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
Selection
"
"
devtools
/
client
/
framework
/
selection
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorFront
"
"
devtools
/
shared
/
fronts
/
inspector
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
devtools
/
shared
/
flags
"
)
;
loader
.
lazyRequireGetter
(
this
"
showDoorhanger
"
"
devtools
/
client
/
shared
/
doorhanger
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createPerformanceFront
"
"
devtools
/
shared
/
fronts
/
performance
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
system
"
"
devtools
/
shared
/
system
"
)
;
loader
.
lazyRequireGetter
(
this
"
getPreferenceFront
"
"
devtools
/
shared
/
fronts
/
preference
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
loader
.
lazyRequireGetter
(
this
"
ZoomKeys
"
"
devtools
/
client
/
shared
/
zoom
-
keys
"
)
;
loader
.
lazyRequireGetter
(
this
"
settleAll
"
"
devtools
/
shared
/
ThreadSafeDevToolsUtils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ToolboxButtons
"
"
devtools
/
client
/
definitions
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SourceMapURLService
"
"
devtools
/
client
/
framework
/
source
-
map
-
url
-
service
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
HUDService
"
"
devtools
/
client
/
webconsole
/
hudservice
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
viewSource
"
"
devtools
/
client
/
shared
/
view
-
source
"
)
;
loader
.
lazyRequireGetter
(
this
"
StyleSheetsFront
"
"
devtools
/
shared
/
fronts
/
stylesheets
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
buildHarLog
"
"
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
builder
-
utils
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getKnownDeviceFront
"
"
devtools
/
shared
/
fronts
/
device
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetMonitorAPI
"
"
devtools
/
client
/
netmonitor
/
src
/
api
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
sortPanelDefinitions
"
"
devtools
/
client
/
framework
/
toolbox
-
tabs
-
order
-
manager
"
true
)
;
loader
.
lazyGetter
(
this
"
domNodeConstants
"
(
)
=
>
{
return
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
registerHarOverlay
"
(
)
=
>
{
return
require
(
"
devtools
/
client
/
netmonitor
/
src
/
har
/
toolbox
-
overlay
"
)
.
register
;
}
)
;
function
Toolbox
(
target
selectedTool
hostType
contentWindow
frameId
)
{
this
.
_target
=
target
;
this
.
_win
=
contentWindow
;
this
.
frameId
=
frameId
;
this
.
_webExtensions
=
new
Map
(
)
;
this
.
_toolPanels
=
new
Map
(
)
;
this
.
_inspectorExtensionSidebars
=
new
Map
(
)
;
this
.
_telemetry
=
new
Telemetry
(
)
;
this
.
_initInspector
=
null
;
this
.
_inspector
=
null
;
this
.
_styleSheets
=
null
;
this
.
_netMonitorAPI
=
null
;
this
.
frameMap
=
new
Map
(
)
;
this
.
selectedFrameId
=
null
;
this
.
_toolRegistered
=
this
.
_toolRegistered
.
bind
(
this
)
;
this
.
_toolUnregistered
=
this
.
_toolUnregistered
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_refreshHostTitle
=
this
.
_refreshHostTitle
.
bind
(
this
)
;
this
.
toggleNoAutohide
=
this
.
toggleNoAutohide
.
bind
(
this
)
;
this
.
showFramesMenu
=
this
.
showFramesMenu
.
bind
(
this
)
;
this
.
handleKeyDownOnFramesButton
=
this
.
handleKeyDownOnFramesButton
.
bind
(
this
)
;
this
.
showFramesMenuOnKeyDown
=
this
.
showFramesMenuOnKeyDown
.
bind
(
this
)
;
this
.
_updateFrames
=
this
.
_updateFrames
.
bind
(
this
)
;
this
.
_splitConsoleOnKeypress
=
this
.
_splitConsoleOnKeypress
.
bind
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
highlighterUtils
=
getHighlighterUtils
(
this
)
;
this
.
_highlighterReady
=
this
.
_highlighterReady
.
bind
(
this
)
;
this
.
_highlighterHidden
=
this
.
_highlighterHidden
.
bind
(
this
)
;
this
.
_applyCacheSettings
=
this
.
_applyCacheSettings
.
bind
(
this
)
;
this
.
_applyServiceWorkersTestingSettings
=
this
.
_applyServiceWorkersTestingSettings
.
bind
(
this
)
;
this
.
_saveSplitConsoleHeight
=
this
.
_saveSplitConsoleHeight
.
bind
(
this
)
;
this
.
_onFocus
=
this
.
_onFocus
.
bind
(
this
)
;
this
.
_onBrowserMessage
=
this
.
_onBrowserMessage
.
bind
(
this
)
;
this
.
_showDevEditionPromo
=
this
.
_showDevEditionPromo
.
bind
(
this
)
;
this
.
_updateTextBoxMenuItems
=
this
.
_updateTextBoxMenuItems
.
bind
(
this
)
;
this
.
_onPerformanceFrontEvent
=
this
.
_onPerformanceFrontEvent
.
bind
(
this
)
;
this
.
_onTabsOrderUpdated
=
this
.
_onTabsOrderUpdated
.
bind
(
this
)
;
this
.
_onToolbarFocus
=
this
.
_onToolbarFocus
.
bind
(
this
)
;
this
.
_onToolbarArrowKeypress
=
this
.
_onToolbarArrowKeypress
.
bind
(
this
)
;
this
.
_onPickerClick
=
this
.
_onPickerClick
.
bind
(
this
)
;
this
.
_onPickerKeypress
=
this
.
_onPickerKeypress
.
bind
(
this
)
;
this
.
_onPickerStarted
=
this
.
_onPickerStarted
.
bind
(
this
)
;
this
.
_onPickerStopped
=
this
.
_onPickerStopped
.
bind
(
this
)
;
this
.
_onInspectObject
=
this
.
_onInspectObject
.
bind
(
this
)
;
this
.
_onNewSelectedNodeFront
=
this
.
_onNewSelectedNodeFront
.
bind
(
this
)
;
this
.
updatePickerButton
=
this
.
updatePickerButton
.
bind
(
this
)
;
this
.
selectTool
=
this
.
selectTool
.
bind
(
this
)
;
this
.
_pingTelemetrySelectTool
=
this
.
_pingTelemetrySelectTool
.
bind
(
this
)
;
this
.
toggleSplitConsole
=
this
.
toggleSplitConsole
.
bind
(
this
)
;
this
.
_target
.
on
(
"
close
"
this
.
destroy
)
;
if
(
!
selectedTool
)
{
selectedTool
=
Services
.
prefs
.
getCharPref
(
this
.
_prefs
.
LAST_TOOL
)
;
}
this
.
_defaultToolId
=
selectedTool
;
this
.
_hostType
=
hostType
;
this
.
_isOpenDeferred
=
defer
(
)
;
this
.
isOpen
=
this
.
_isOpenDeferred
.
promise
;
EventEmitter
.
decorate
(
this
)
;
this
.
_target
.
on
(
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_target
.
on
(
"
navigate
"
this
.
_refreshHostTitle
)
;
this
.
_target
.
on
(
"
frame
-
update
"
this
.
_updateFrames
)
;
this
.
_target
.
on
(
"
inspect
-
object
"
this
.
_onInspectObject
)
;
this
.
on
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
this
.
on
(
"
select
"
this
.
_refreshHostTitle
)
;
this
.
on
(
"
select
"
this
.
updatePickerButton
)
;
this
.
on
(
"
ready
"
this
.
_showDevEditionPromo
)
;
gDevTools
.
on
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
this
.
on
(
"
picker
-
started
"
this
.
_onPickerStarted
)
;
this
.
on
(
"
picker
-
stopped
"
this
.
_onPickerStopped
)
;
loader
.
lazyGetter
(
this
"
direction
"
(
)
=
>
{
let
top
=
this
.
win
.
top
;
let
topDocEl
=
top
.
document
.
documentElement
;
let
isRtl
=
top
.
getComputedStyle
(
topDocEl
)
.
direction
=
=
=
"
rtl
"
;
return
isRtl
?
"
rtl
"
:
"
ltr
"
;
}
)
;
}
exports
.
Toolbox
=
Toolbox
;
Toolbox
.
HostType
=
{
BOTTOM
:
"
bottom
"
SIDE
:
"
side
"
WINDOW
:
"
window
"
CUSTOM
:
"
custom
"
}
;
Toolbox
.
prototype
=
{
_URL
:
"
about
:
devtools
-
toolbox
"
_prefs
:
{
LAST_TOOL
:
"
devtools
.
toolbox
.
selectedTool
"
SIDE_ENABLED
:
"
devtools
.
toolbox
.
sideEnabled
"
}
get
currentToolId
(
)
{
return
this
.
_currentToolId
;
}
set
currentToolId
(
id
)
{
this
.
_currentToolId
=
id
;
this
.
component
.
setCurrentToolId
(
id
)
;
}
get
panelDefinitions
(
)
{
return
this
.
_panelDefinitions
;
}
set
panelDefinitions
(
definitions
)
{
this
.
_panelDefinitions
=
definitions
;
this
.
_combineAndSortPanelDefinitions
(
)
;
}
get
visibleAdditionalTools
(
)
{
if
(
!
this
.
_visibleAdditionalTools
)
{
this
.
_visibleAdditionalTools
=
[
]
;
}
return
this
.
_visibleAdditionalTools
;
}
set
visibleAdditionalTools
(
tools
)
{
this
.
_visibleAdditionalTools
=
tools
;
if
(
this
.
isReady
)
{
this
.
_combineAndSortPanelDefinitions
(
)
;
}
}
_combineAndSortPanelDefinitions
(
)
{
let
definitions
=
[
.
.
.
this
.
_panelDefinitions
.
.
.
this
.
getVisibleAdditionalTools
(
)
]
;
definitions
=
sortPanelDefinitions
(
definitions
)
;
this
.
component
.
setPanelDefinitions
(
definitions
)
;
}
lastUsedToolId
:
null
getToolPanels
:
function
(
)
{
return
new
Map
(
this
.
_toolPanels
)
;
}
getPanel
:
function
(
id
)
{
return
this
.
_toolPanels
.
get
(
id
)
;
}
getPanelWhenReady
:
function
(
id
)
{
let
deferred
=
defer
(
)
;
let
panel
=
this
.
getPanel
(
id
)
;
if
(
panel
)
{
deferred
.
resolve
(
panel
)
;
}
else
{
this
.
on
(
id
+
"
-
ready
"
initializedPanel
=
>
{
deferred
.
resolve
(
initializedPanel
)
;
}
)
;
}
return
deferred
.
promise
;
}
getCurrentPanel
:
function
(
)
{
return
this
.
_toolPanels
.
get
(
this
.
currentToolId
)
;
}
get
target
(
)
{
return
this
.
_target
;
}
get
threadClient
(
)
{
return
this
.
_threadClient
;
}
get
hostType
(
)
{
return
this
.
_hostType
;
}
get
win
(
)
{
return
this
.
_win
;
}
get
doc
(
)
{
return
this
.
win
.
document
;
}
get
highlighter
(
)
{
return
this
.
_highlighter
;
}
get
performance
(
)
{
return
this
.
_performance
;
}
get
inspector
(
)
{
return
this
.
_inspector
;
}
get
walker
(
)
{
return
this
.
_walker
;
}
get
selection
(
)
{
return
this
.
_selection
;
}
get
splitConsole
(
)
{
return
this
.
_splitConsole
;
}
isSplitConsoleFocused
:
function
(
)
{
if
(
!
this
.
_splitConsole
)
{
return
false
;
}
let
focusedWin
=
Services
.
focus
.
focusedWindow
;
return
focusedWin
&
&
focusedWin
=
=
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
iframe
-
webconsole
"
)
.
contentWindow
;
}
open
:
function
(
)
{
return
(
async
function
(
)
{
this
.
browserRequire
=
BrowserLoader
(
{
window
:
this
.
doc
.
defaultView
useOnlyShared
:
true
}
)
.
require
;
if
(
this
.
win
.
location
.
href
.
startsWith
(
this
.
_URL
)
)
{
this
.
_URL
=
this
.
win
.
location
.
href
;
}
let
domReady
=
defer
(
)
;
let
domHelper
=
new
DOMHelpers
(
this
.
win
)
;
domHelper
.
onceDOMReady
(
(
)
=
>
{
domReady
.
resolve
(
)
;
}
this
.
_URL
)
;
await
this
.
_target
.
makeRemote
(
)
;
if
(
this
.
_target
.
activeConsole
)
{
await
this
.
_target
.
activeConsole
.
startListeners
(
[
"
NetworkActivity
"
]
)
;
}
this
.
_threadClient
=
await
attachThread
(
this
)
;
await
domReady
.
promise
;
this
.
isReady
=
true
;
let
framesPromise
=
this
.
_listFrames
(
)
;
Services
.
prefs
.
addObserver
(
"
devtools
.
cache
.
disabled
"
this
.
_applyCacheSettings
)
;
Services
.
prefs
.
addObserver
(
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
this
.
_applyServiceWorkersTestingSettings
)
;
this
.
textBoxContextMenuPopup
=
this
.
doc
.
getElementById
(
"
toolbox
-
textbox
-
context
-
popup
"
)
;
this
.
textBoxContextMenuPopup
.
addEventListener
(
"
popupshowing
"
this
.
_updateTextBoxMenuItems
true
)
;
this
.
doc
.
addEventListener
(
"
contextmenu
"
(
e
)
=
>
{
if
(
e
.
originalTarget
.
closest
(
"
input
[
type
=
text
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
[
type
=
search
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
:
not
(
[
type
]
)
"
)
|
|
e
.
originalTarget
.
closest
(
"
textarea
"
)
)
{
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
this
.
openTextBoxContextMenu
(
e
.
screenX
e
.
screenY
)
;
}
}
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
doc
.
defaultView
}
)
;
this
.
_componentMount
=
this
.
doc
.
getElementById
(
"
toolbox
-
toolbar
-
mount
"
)
;
this
.
_mountReactComponent
(
)
;
this
.
_buildDockOptions
(
)
;
this
.
_buildOptions
(
)
;
this
.
_buildTabs
(
)
;
this
.
_applyCacheSettings
(
)
;
this
.
_applyServiceWorkersTestingSettings
(
)
;
this
.
_addKeysToWindow
(
)
;
this
.
_addReloadKeys
(
)
;
this
.
_addHostListeners
(
)
;
this
.
_registerOverlays
(
)
;
if
(
!
this
.
_hostOptions
|
|
this
.
_hostOptions
.
zoom
=
=
=
true
)
{
ZoomKeys
.
register
(
this
.
win
)
;
}
this
.
_componentMount
.
addEventListener
(
"
keypress
"
this
.
_onToolbarArrowKeypress
)
;
this
.
_componentMount
.
setAttribute
(
"
aria
-
label
"
L10N
.
getStr
(
"
toolbox
.
label
"
)
)
;
this
.
webconsolePanel
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
webconsole
"
)
;
this
.
webconsolePanel
.
height
=
Services
.
prefs
.
getIntPref
(
SPLITCONSOLE_HEIGHT_PREF
)
;
this
.
webconsolePanel
.
addEventListener
(
"
resize
"
this
.
_saveSplitConsoleHeight
)
;
this
.
_buildButtons
(
)
;
this
.
_pingTelemetry
(
)
;
let
toolDef
=
gDevTools
.
getToolDefinition
(
this
.
_defaultToolId
)
;
if
(
!
toolDef
|
|
!
toolDef
.
isTargetSupported
(
this
.
_target
)
)
{
this
.
_defaultToolId
=
"
webconsole
"
;
}
this
.
win
.
requestIdleCallback
(
(
)
=
>
{
this
.
component
.
setCanRender
(
)
;
}
{
timeout
:
16
}
)
;
await
this
.
selectTool
(
this
.
_defaultToolId
"
initial_panel
"
)
;
let
splitConsolePromise
=
promise
.
resolve
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
SPLITCONSOLE_ENABLED_PREF
)
)
{
splitConsolePromise
=
this
.
openSplitConsole
(
)
;
this
.
_telemetry
.
addEventProperty
(
"
devtools
.
main
"
"
open
"
"
tools
"
null
"
splitconsole
"
true
)
;
}
else
{
this
.
_telemetry
.
addEventProperty
(
"
devtools
.
main
"
"
open
"
"
tools
"
null
"
splitconsole
"
false
)
;
}
await
promise
.
all
(
[
splitConsolePromise
framesPromise
]
)
;
let
performanceFrontConnection
=
this
.
initPerformance
(
)
;
if
(
flags
.
testing
)
{
await
performanceFrontConnection
;
}
this
.
emit
(
"
ready
"
)
;
this
.
_isOpenDeferred
.
resolve
(
)
;
}
.
bind
(
this
)
)
(
)
.
catch
(
console
.
error
)
;
}
get
React
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
}
get
ReactDOM
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
}
get
ReactRedux
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
}
get
ToolboxController
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
framework
/
components
/
toolbox
-
controller
"
)
;
}
_createSourceMapService
:
function
(
)
{
if
(
this
.
_sourceMapService
)
{
return
this
.
_sourceMapService
;
}
let
service
=
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
source
-
map
/
index
"
)
;
this
.
_sourceMapService
=
new
Proxy
(
service
{
get
:
(
target
name
)
=
>
{
switch
(
name
)
{
case
"
getOriginalURLs
"
:
return
(
urlInfo
)
=
>
{
return
target
.
getOriginalURLs
(
urlInfo
)
.
catch
(
text
=
>
{
let
message
=
L10N
.
getFormatStr
(
"
toolbox
.
sourceMapFailure
"
text
urlInfo
.
url
urlInfo
.
sourceMapURL
)
;
this
.
target
.
logWarningInPage
(
message
"
source
map
"
)
;
return
null
;
}
)
;
}
;
case
"
getOriginalSourceText
"
:
return
(
originalSource
)
=
>
{
return
target
.
getOriginalSourceText
(
originalSource
)
.
catch
(
text
=
>
{
let
message
=
L10N
.
getFormatStr
(
"
toolbox
.
sourceMapSourceFailure
"
text
originalSource
.
url
)
;
this
.
target
.
logWarningInPage
(
message
"
source
map
"
)
;
return
{
text
:
message
contentType
:
"
text
/
plain
"
}
;
}
)
;
}
;
case
"
applySourceMap
"
:
return
(
generatedId
url
code
mappings
)
=
>
{
return
target
.
applySourceMap
(
generatedId
url
code
mappings
)
.
then
(
result
=
>
{
if
(
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
.
sourceMapChanged
(
generatedId
url
)
;
}
return
result
;
}
)
;
}
;
default
:
return
target
[
name
]
;
}
}
}
)
;
this
.
_sourceMapService
.
startSourceMapWorker
(
SOURCE_MAP_WORKER
)
;
return
this
.
_sourceMapService
;
}
get
sourceMapService
(
)
{
if
(
!
Services
.
prefs
.
getBoolPref
(
"
devtools
.
source
-
map
.
client
-
service
.
enabled
"
)
)
{
return
null
;
}
return
this
.
_createSourceMapService
(
)
;
}
get
sourceMapURLService
(
)
{
if
(
this
.
_sourceMapURLService
)
{
return
this
.
_sourceMapURLService
;
}
let
sourceMaps
=
this
.
_createSourceMapService
(
)
;
this
.
_sourceMapURLService
=
new
SourceMapURLService
(
this
sourceMaps
)
;
return
this
.
_sourceMapURLService
;
}
_getTelemetryHostId
:
function
(
)
{
switch
(
this
.
hostType
)
{
case
Toolbox
.
HostType
.
BOTTOM
:
return
0
;
case
Toolbox
.
HostType
.
SIDE
:
return
1
;
case
Toolbox
.
HostType
.
WINDOW
:
return
2
;
case
Toolbox
.
HostType
.
CUSTOM
:
return
3
;
default
:
return
9
;
}
}
_getTelemetryHostString
:
function
(
)
{
switch
(
this
.
hostType
)
{
case
Toolbox
.
HostType
.
BOTTOM
:
return
"
bottom
"
;
case
Toolbox
.
HostType
.
SIDE
:
return
"
side
"
;
case
Toolbox
.
HostType
.
WINDOW
:
return
"
window
"
;
case
Toolbox
.
HostType
.
CUSTOM
:
return
"
other
"
;
default
:
return
"
bottom
"
;
}
}
_pingTelemetry
:
function
(
)
{
this
.
_telemetry
.
toolOpened
(
"
toolbox
"
)
;
this
.
_telemetry
.
logOncePerBrowserVersion
(
SCREENSIZE_HISTOGRAM
system
.
getScreenDimensions
(
)
)
;
this
.
_telemetry
.
log
(
HOST_HISTOGRAM
this
.
_getTelemetryHostId
(
)
)
;
let
currentTheme
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
this
.
_telemetry
.
logKeyedScalar
(
CURRENT_THEME_SCALAR
currentTheme
1
)
;
this
.
_telemetry
.
preparePendingEvent
(
"
devtools
.
main
"
"
open
"
"
tools
"
null
[
"
entrypoint
"
"
first_panel
"
"
host
"
"
splitconsole
"
"
width
"
]
)
;
this
.
_telemetry
.
addEventProperty
(
"
devtools
.
main
"
"
open
"
"
tools
"
null
"
host
"
this
.
_getTelemetryHostString
(
)
)
;
}
_createButtonState
:
function
(
options
)
{
let
isCheckedValue
=
false
;
const
{
id
className
description
disabled
onClick
isInStartContainer
setup
teardown
isTargetSupported
isCurrentlyVisible
isChecked
onKeyDown
}
=
options
;
const
toolbox
=
this
;
const
button
=
{
id
className
description
disabled
onClick
(
event
)
{
if
(
typeof
onClick
=
=
"
function
"
)
{
onClick
(
event
toolbox
)
;
}
}
onKeyDown
(
event
)
{
if
(
typeof
onKeyDown
=
=
"
function
"
)
{
onKeyDown
(
event
toolbox
)
;
}
}
isTargetSupported
isCurrentlyVisible
get
isChecked
(
)
{
if
(
typeof
isChecked
=
=
"
function
"
)
{
return
isChecked
(
toolbox
)
;
}
return
isCheckedValue
;
}
set
isChecked
(
value
)
{
isCheckedValue
=
value
;
this
.
emit
(
"
updatechecked
"
)
;
}
visibilityswitch
:
devtools
.
{
id
}
.
enabled
isInStartContainer
:
!
!
isInStartContainer
}
;
if
(
typeof
setup
=
=
"
function
"
)
{
let
onChange
=
(
)
=
>
{
button
.
emit
(
"
updatechecked
"
)
;
}
;
setup
(
this
onChange
)
;
button
.
teardown
=
teardown
.
bind
(
options
this
onChange
)
;
}
button
.
isVisible
=
this
.
_commandIsVisible
(
button
)
;
EventEmitter
.
decorate
(
button
)
;
return
button
;
}
_buildOptions
:
function
(
)
{
let
selectOptions
=
event
=
>
{
if
(
this
.
currentToolId
=
=
=
"
options
"
&
&
gDevTools
.
getToolDefinition
(
this
.
lastUsedToolId
)
)
{
this
.
selectTool
(
this
.
lastUsedToolId
"
toggle_settings_off
"
)
;
}
else
{
this
.
selectTool
(
"
options
"
"
toggle_settings_on
"
)
;
}
}
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
help
.
key
"
)
selectOptions
)
;
}
_splitConsoleOnKeypress
:
function
(
e
)
{
if
(
e
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
this
.
toggleSplitConsole
(
)
;
if
(
this
.
_threadClient
.
state
=
=
"
paused
"
)
{
e
.
preventDefault
(
)
;
}
}
}
useKeyWithSplitConsole
:
function
(
key
handler
whichTool
)
{
this
.
shortcuts
.
on
(
key
event
=
>
{
if
(
this
.
currentToolId
=
=
=
whichTool
&
&
this
.
isSplitConsoleFocused
(
)
)
{
handler
(
)
;
event
.
preventDefault
(
)
;
}
}
)
;
}
_addReloadKeys
:
function
(
)
{
[
[
"
reload
"
false
]
[
"
reload2
"
false
]
[
"
forceReload
"
true
]
[
"
forceReload2
"
true
]
]
.
forEach
(
(
[
id
force
]
)
=
>
{
let
key
=
L10N
.
getStr
(
"
toolbox
.
"
+
id
+
"
.
key
"
)
;
this
.
shortcuts
.
on
(
key
event
=
>
{
this
.
reloadTarget
(
force
)
;
event
.
preventDefault
(
)
;
}
)
;
}
)
;
}
_addHostListeners
:
function
(
)
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
nextTool
.
key
"
)
event
=
>
{
this
.
selectNextTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
previousTool
.
key
"
)
event
=
>
{
this
.
selectPreviousTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleHost
.
key
"
)
event
=
>
{
this
.
switchToPreviousHost
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
doc
.
addEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
)
;
this
.
doc
.
addEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
win
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
addEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
_removeHostListeners
:
function
(
)
{
if
(
this
.
doc
)
{
this
.
doc
.
removeEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
)
;
this
.
doc
.
removeEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
win
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
removeEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
}
_onBrowserMessage
:
function
(
event
)
{
if
(
event
.
data
&
&
event
.
data
.
name
=
=
=
"
switched
-
host
"
)
{
this
.
_onSwitchedHost
(
event
.
data
)
;
}
}
_registerOverlays
:
function
(
)
{
registerHarOverlay
(
this
)
;
}
_saveSplitConsoleHeight
:
function
(
)
{
Services
.
prefs
.
setIntPref
(
SPLITCONSOLE_HEIGHT_PREF
this
.
webconsolePanel
.
height
)
;
}
_refreshConsoleDisplay
:
function
(
)
{
let
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
let
webconsolePanel
=
this
.
webconsolePanel
;
let
splitter
=
this
.
doc
.
getElementById
(
"
toolbox
-
console
-
splitter
"
)
;
let
openedConsolePanel
=
this
.
currentToolId
=
=
=
"
webconsole
"
;
if
(
openedConsolePanel
)
{
deck
.
setAttribute
(
"
collapsed
"
"
true
"
)
;
splitter
.
setAttribute
(
"
hidden
"
"
true
"
)
;
webconsolePanel
.
removeAttribute
(
"
collapsed
"
)
;
}
else
{
deck
.
removeAttribute
(
"
collapsed
"
)
;
if
(
this
.
splitConsole
)
{
webconsolePanel
.
removeAttribute
(
"
collapsed
"
)
;
splitter
.
removeAttribute
(
"
hidden
"
)
;
}
else
{
webconsolePanel
.
setAttribute
(
"
collapsed
"
"
true
"
)
;
splitter
.
setAttribute
(
"
hidden
"
"
true
"
)
;
}
}
}
_addKeysToWindow
:
function
(
)
{
if
(
this
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
)
{
return
;
}
let
doc
=
this
.
win
.
parent
.
document
;
for
(
let
item
of
Startup
.
KeyShortcuts
)
{
if
(
!
item
.
toolId
)
{
continue
;
}
let
{
toolId
shortcut
modifiers
}
=
item
;
let
key
=
doc
.
createElement
(
"
key
"
)
;
key
.
id
=
"
key_
"
+
toolId
;
if
(
shortcut
.
startsWith
(
"
VK_
"
)
)
{
key
.
setAttribute
(
"
keycode
"
shortcut
)
;
}
else
{
key
.
setAttribute
(
"
key
"
shortcut
)
;
}
key
.
setAttribute
(
"
modifiers
"
modifiers
)
;
key
.
setAttribute
(
"
oncommand
"
"
void
(
0
)
;
"
)
;
key
.
addEventListener
(
"
command
"
(
)
=
>
{
this
.
selectTool
(
toolId
"
key_shortcut
"
)
.
then
(
(
)
=
>
this
.
fireCustomKey
(
toolId
)
)
;
}
true
)
;
doc
.
getElementById
(
"
toolbox
-
keyset
"
)
.
appendChild
(
key
)
;
}
if
(
!
doc
.
getElementById
(
"
key_browserconsole
"
)
)
{
let
key
=
doc
.
createElement
(
"
key
"
)
;
key
.
id
=
"
key_browserconsole
"
;
key
.
setAttribute
(
"
key
"
L10N
.
getStr
(
"
browserConsoleCmd
.
commandkey
"
)
)
;
key
.
setAttribute
(
"
modifiers
"
"
accel
shift
"
)
;
key
.
setAttribute
(
"
oncommand
"
"
void
(
0
)
"
)
;
key
.
addEventListener
(
"
command
"
(
)
=
>
{
HUDService
.
toggleBrowserConsole
(
)
;
}
true
)
;
doc
.
getElementById
(
"
toolbox
-
keyset
"
)
.
appendChild
(
key
)
;
}
}
fireCustomKey
:
function
(
toolId
)
{
let
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolDefinition
.
onkey
&
&
(
(
this
.
currentToolId
=
=
=
toolId
)
|
|
(
toolId
=
=
"
webconsole
"
&
&
this
.
splitConsole
)
)
)
{
toolDefinition
.
onkey
(
this
.
getCurrentPanel
(
)
this
)
;
}
}
get
notificationBox
(
)
{
if
(
!
this
.
_notificationBox
)
{
let
{
NotificationBox
PriorityLevels
}
=
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
)
;
NotificationBox
=
this
.
React
.
createFactory
(
NotificationBox
)
;
let
box
=
this
.
doc
.
getElementById
(
"
toolbox
-
notificationbox
"
)
;
this
.
_notificationBox
=
Object
.
assign
(
this
.
ReactDOM
.
render
(
NotificationBox
(
{
}
)
box
)
PriorityLevels
)
;
}
return
this
.
_notificationBox
;
}
_buildDockOptions
:
function
(
)
{
if
(
!
this
.
_target
.
isLocalTab
)
{
this
.
component
.
setDockOptionsEnabled
(
false
)
;
this
.
component
.
setCanCloseToolbox
(
false
)
;
return
;
}
this
.
component
.
setDockOptionsEnabled
(
true
)
;
this
.
component
.
setCanCloseToolbox
(
this
.
hostType
!
=
=
Toolbox
.
HostType
.
WINDOW
)
;
let
sideEnabled
=
Services
.
prefs
.
getBoolPref
(
this
.
_prefs
.
SIDE_ENABLED
)
;
let
hostTypes
=
[
]
;
for
(
let
type
in
Toolbox
.
HostType
)
{
let
position
=
Toolbox
.
HostType
[
type
]
;
if
(
position
=
=
this
.
hostType
|
|
position
=
=
Toolbox
.
HostType
.
CUSTOM
|
|
(
!
sideEnabled
&
&
position
=
=
Toolbox
.
HostType
.
SIDE
)
)
{
continue
;
}
hostTypes
.
push
(
{
position
switchHost
:
this
.
switchHost
.
bind
(
this
position
)
}
)
;
}
this
.
component
.
setHostTypes
(
hostTypes
)
;
}
postMessage
:
function
(
msg
)
{
if
(
this
.
win
.
parent
)
{
msg
.
frameId
=
this
.
frameId
;
this
.
win
.
parent
.
postMessage
(
msg
"
*
"
)
;
}
}
_buildTabs
:
async
function
(
)
{
const
definitions
=
gDevTools
.
getToolDefinitionArray
(
)
;
definitions
.
forEach
(
definition
=
>
this
.
_buildPanelForTool
(
definition
)
)
;
this
.
panelDefinitions
=
definitions
.
filter
(
definition
=
>
definition
.
isTargetSupported
(
this
.
_target
)
&
&
definition
.
id
!
=
=
"
options
"
)
;
if
(
this
.
disableAutohideAvailable
)
{
let
disable
=
await
this
.
_isDisableAutohideEnabled
(
)
;
this
.
component
.
setDisableAutohide
(
disable
)
;
}
}
_mountReactComponent
:
function
(
)
{
const
element
=
this
.
React
.
createElement
(
this
.
ToolboxController
{
L10N
currentToolId
:
this
.
currentToolId
selectTool
:
this
.
selectTool
toggleSplitConsole
:
this
.
toggleSplitConsole
toggleNoAutohide
:
this
.
toggleNoAutohide
closeToolbox
:
this
.
destroy
focusButton
:
this
.
_onToolbarFocus
toolbox
:
this
onTabsOrderUpdated
:
this
.
_onTabsOrderUpdated
}
)
;
this
.
component
=
this
.
ReactDOM
.
render
(
element
this
.
_componentMount
)
;
}
_onToolbarFocus
:
function
(
id
)
{
this
.
component
.
setFocusedButton
(
id
)
;
}
_onToolbarArrowKeypress
:
function
(
event
)
{
let
{
key
target
ctrlKey
shiftKey
altKey
metaKey
}
=
event
;
if
(
ctrlKey
|
|
shiftKey
|
|
altKey
|
|
metaKey
)
{
return
;
}
let
buttons
=
[
.
.
.
this
.
_componentMount
.
querySelectorAll
(
"
button
"
)
]
;
let
curIndex
=
buttons
.
indexOf
(
target
)
;
if
(
curIndex
=
=
=
-
1
)
{
console
.
warn
(
target
+
"
is
not
found
among
Developer
Tools
tab
bar
"
+
"
focusable
elements
.
"
)
;
return
;
}
let
newTarget
;
if
(
key
=
=
=
"
ArrowLeft
"
)
{
if
(
curIndex
=
=
=
0
)
{
return
;
}
newTarget
=
buttons
[
curIndex
-
1
]
;
}
else
if
(
key
=
=
=
"
ArrowRight
"
)
{
if
(
curIndex
=
=
=
buttons
.
length
-
1
)
{
return
;
}
newTarget
=
buttons
[
curIndex
+
1
]
;
}
else
{
return
;
}
newTarget
.
focus
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
_buildButtons
(
)
{
this
.
toolbarButtons
=
[
this
.
_buildPickerButton
(
)
this
.
_buildFrameButton
(
)
]
;
ToolboxButtons
.
forEach
(
definition
=
>
{
let
button
=
this
.
_createButtonState
(
definition
)
;
this
.
toolbarButtons
.
push
(
button
)
;
}
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
_buildFrameButton
(
)
{
this
.
frameButton
=
this
.
_createButtonState
(
{
id
:
"
command
-
button
-
frames
"
description
:
L10N
.
getStr
(
"
toolbox
.
frames
.
tooltip
"
)
onClick
:
this
.
showFramesMenu
isTargetSupported
:
target
=
>
{
return
target
.
activeTab
&
&
target
.
activeTab
.
traits
.
frames
;
}
isCurrentlyVisible
:
(
)
=
>
{
return
this
.
frameMap
.
size
>
1
;
}
onKeyDown
:
this
.
handleKeyDownOnFramesButton
}
)
;
return
this
.
frameButton
;
}
_onPickerClick
:
function
(
)
{
let
focus
=
this
.
hostType
=
=
=
Toolbox
.
HostType
.
BOTTOM
|
|
this
.
hostType
=
=
=
Toolbox
.
HostType
.
SIDE
;
let
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
.
togglePicker
)
{
currentPanel
.
togglePicker
(
focus
)
;
}
else
{
this
.
highlighterUtils
.
togglePicker
(
focus
)
;
}
}
_onPickerKeypress
:
function
(
event
)
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
let
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
.
cancelPicker
)
{
currentPanel
.
cancelPicker
(
)
;
}
else
{
this
.
highlighterUtils
.
cancelPicker
(
)
;
}
event
.
stopImmediatePropagation
(
)
;
}
}
_onPickerStarted
:
function
(
)
{
this
.
doc
.
addEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
}
_onPickerStopped
:
function
(
)
{
this
.
doc
.
removeEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
}
_buildPickerButton
(
)
{
this
.
pickerButton
=
this
.
_createButtonState
(
{
id
:
"
command
-
button
-
pick
"
description
:
L10N
.
getStr
(
"
pickButton
.
tooltip
"
)
onClick
:
this
.
_onPickerClick
isInStartContainer
:
true
isTargetSupported
:
target
=
>
{
return
target
.
activeTab
&
&
target
.
activeTab
.
traits
.
frames
;
}
}
)
;
return
this
.
pickerButton
;
}
_applyCacheSettings
:
function
(
)
{
let
pref
=
"
devtools
.
cache
.
disabled
"
;
let
cacheDisabled
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
if
(
this
.
target
.
activeTab
)
{
this
.
target
.
activeTab
.
reconfigure
(
{
"
cacheDisabled
"
:
cacheDisabled
}
)
;
}
}
_applyServiceWorkersTestingSettings
:
function
(
)
{
let
pref
=
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
;
let
serviceWorkersTestingEnabled
=
Services
.
prefs
.
getBoolPref
(
pref
)
|
|
false
;
if
(
this
.
target
.
activeTab
)
{
this
.
target
.
activeTab
.
reconfigure
(
{
"
serviceWorkersTestingEnabled
"
:
serviceWorkersTestingEnabled
}
)
;
}
}
updateToolboxButtonsVisibility
(
)
{
this
.
toolbarButtons
.
forEach
(
button
=
>
{
button
.
isVisible
=
this
.
_commandIsVisible
(
button
)
;
}
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
updatePickerButton
(
)
{
const
button
=
this
.
pickerButton
;
let
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
&
&
currentPanel
.
updatePickerButton
)
{
currentPanel
.
updatePickerButton
(
)
;
}
else
{
button
.
description
=
L10N
.
getStr
(
"
pickButton
.
tooltip
"
)
;
button
.
className
=
null
;
button
.
disabled
=
null
;
}
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
_commandIsVisible
:
function
(
button
)
{
const
{
isTargetSupported
isCurrentlyVisible
visibilityswitch
}
=
button
;
if
(
!
Services
.
prefs
.
getBoolPref
(
visibilityswitch
true
)
)
{
return
false
;
}
if
(
isTargetSupported
&
&
!
isTargetSupported
(
this
.
target
)
)
{
return
false
;
}
if
(
isCurrentlyVisible
&
&
!
isCurrentlyVisible
(
)
)
{
return
false
;
}
return
true
;
}
_buildPanelForTool
:
function
(
toolDefinition
)
{
if
(
!
toolDefinition
.
isTargetSupported
(
this
.
_target
)
)
{
return
;
}
let
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
let
id
=
toolDefinition
.
id
;
if
(
toolDefinition
.
ordinal
=
=
undefined
|
|
toolDefinition
.
ordinal
<
0
)
{
toolDefinition
.
ordinal
=
MAX_ORDINAL
;
}
if
(
!
toolDefinition
.
bgTheme
)
{
toolDefinition
.
bgTheme
=
"
theme
-
toolbar
"
;
}
let
panel
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
panel
.
className
=
"
toolbox
-
panel
"
+
toolDefinition
.
bgTheme
;
if
(
!
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
)
{
panel
.
id
=
"
toolbox
-
panel
-
"
+
id
;
}
deck
.
appendChild
(
panel
)
;
this
.
_addKeysToWindow
(
)
;
}
get
additionalToolDefinitions
(
)
{
if
(
!
this
.
_additionalToolDefinitions
)
{
this
.
_additionalToolDefinitions
=
new
Map
(
)
;
}
return
this
.
_additionalToolDefinitions
;
}
getAdditionalTools
(
)
{
if
(
this
.
_additionalToolDefinitions
)
{
return
Array
.
from
(
this
.
additionalToolDefinitions
.
values
(
)
)
;
}
return
[
]
;
}
getVisibleAdditionalTools
(
)
{
return
this
.
visibleAdditionalTools
.
map
(
toolId
=
>
this
.
additionalToolDefinitions
.
get
(
toolId
)
)
;
}
hasAdditionalTool
(
toolId
)
{
return
this
.
additionalToolDefinitions
.
has
(
toolId
)
;
}
addAdditionalTool
(
definition
)
{
if
(
!
definition
.
id
)
{
throw
new
Error
(
"
Tool
definition
id
is
missing
"
)
;
}
if
(
this
.
isToolRegistered
(
definition
.
id
)
)
{
throw
new
Error
(
"
Tool
definition
already
registered
:
"
+
definition
.
id
)
;
}
this
.
additionalToolDefinitions
.
set
(
definition
.
id
definition
)
;
this
.
visibleAdditionalTools
=
[
.
.
.
this
.
visibleAdditionalTools
definition
.
id
]
;
const
buildPanel
=
(
)
=
>
this
.
_buildPanelForTool
(
definition
)
;
if
(
this
.
isReady
)
{
buildPanel
(
)
;
}
else
{
this
.
once
(
"
ready
"
buildPanel
)
;
}
}
get
inspectorExtensionSidebars
(
)
{
return
this
.
_inspectorExtensionSidebars
;
}
async
registerInspectorExtensionSidebar
(
id
options
)
{
this
.
_inspectorExtensionSidebars
.
set
(
id
options
)
;
if
(
!
this
.
_inspector
)
{
return
;
}
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
inspector
.
addExtensionSidebar
(
id
options
)
;
}
unregisterInspectorExtensionSidebar
(
id
)
{
const
sidebarDef
=
this
.
_inspectorExtensionSidebars
.
get
(
id
)
;
if
(
!
sidebarDef
)
{
return
;
}
this
.
_inspectorExtensionSidebars
.
delete
(
id
)
;
if
(
!
this
.
_inspector
)
{
return
;
}
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
inspector
.
removeExtensionSidebar
(
id
)
;
}
removeAdditionalTool
(
toolId
)
{
if
(
this
.
_destroyer
)
{
return
;
}
if
(
!
this
.
hasAdditionalTool
(
toolId
)
)
{
throw
new
Error
(
"
Tool
definition
not
registered
to
this
toolbox
:
"
+
toolId
)
;
}
this
.
additionalToolDefinitions
.
delete
(
toolId
)
;
this
.
visibleAdditionalTools
=
this
.
visibleAdditionalTools
.
filter
(
id
=
>
id
!
=
=
toolId
)
;
this
.
unloadTool
(
toolId
)
;
}
loadTool
:
function
(
id
)
{
if
(
id
=
=
=
"
inspector
"
&
&
!
this
.
_inspector
)
{
return
this
.
initInspector
(
)
.
then
(
(
)
=
>
this
.
loadTool
(
id
)
)
;
}
let
deferred
=
defer
(
)
;
let
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
iframe
)
{
let
panel
=
this
.
_toolPanels
.
get
(
id
)
;
if
(
panel
)
{
deferred
.
resolve
(
panel
)
;
}
else
{
this
.
once
(
id
+
"
-
ready
"
initializedPanel
=
>
{
deferred
.
resolve
(
initializedPanel
)
;
}
)
;
}
return
deferred
.
promise
;
}
let
definition
=
this
.
getToolDefinition
(
id
)
;
if
(
!
definition
)
{
deferred
.
reject
(
new
Error
(
"
no
such
tool
id
"
+
id
)
)
;
return
deferred
.
promise
;
}
iframe
=
this
.
doc
.
createElement
(
"
iframe
"
)
;
iframe
.
className
=
"
toolbox
-
panel
-
iframe
"
;
iframe
.
id
=
"
toolbox
-
panel
-
iframe
-
"
+
id
;
iframe
.
setAttribute
(
"
flex
"
1
)
;
iframe
.
setAttribute
(
"
forceOwnRefreshDriver
"
"
"
)
;
iframe
.
tooltip
=
"
aHTMLTooltip
"
;
iframe
.
style
.
visibility
=
"
hidden
"
;
gDevTools
.
emit
(
id
+
"
-
init
"
this
iframe
)
;
this
.
emit
(
id
+
"
-
init
"
iframe
)
;
if
(
!
iframe
.
parentNode
)
{
let
vbox
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
;
vbox
.
appendChild
(
iframe
)
;
vbox
.
visibility
=
"
visible
"
;
}
let
onLoad
=
(
)
=
>
{
iframe
.
style
.
visibility
=
"
visible
"
;
this
.
setIframeDocumentDir
(
iframe
)
;
let
built
=
definition
.
build
(
iframe
.
contentWindow
this
)
;
if
(
!
(
typeof
built
.
then
=
=
"
function
"
)
)
{
let
panel
=
built
;
iframe
.
panel
=
panel
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
build
"
this
panel
)
;
this
.
emit
(
id
+
"
-
build
"
panel
)
;
if
(
typeof
panel
.
open
=
=
"
function
"
)
{
built
=
panel
.
open
(
)
;
}
else
{
let
buildDeferred
=
defer
(
)
;
buildDeferred
.
resolve
(
panel
)
;
built
=
buildDeferred
.
promise
;
}
}
promise
.
resolve
(
built
)
.
then
(
(
panel
)
=
>
{
this
.
_toolPanels
.
set
(
id
panel
)
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
ready
"
this
panel
)
;
this
.
emit
(
id
+
"
-
ready
"
panel
)
;
deferred
.
resolve
(
panel
)
;
}
console
.
error
)
;
}
;
iframe
.
setAttribute
(
"
src
"
definition
.
url
)
;
if
(
definition
.
panelLabel
)
{
iframe
.
setAttribute
(
"
aria
-
label
"
definition
.
panelLabel
)
;
}
if
(
iframe
.
contentWindow
)
{
let
domHelper
=
new
DOMHelpers
(
iframe
.
contentWindow
)
;
domHelper
.
onceDOMReady
(
onLoad
)
;
}
else
{
let
callback
=
(
)
=
>
{
iframe
.
removeEventListener
(
"
DOMContentLoaded
"
callback
)
;
onLoad
(
)
;
}
;
iframe
.
addEventListener
(
"
DOMContentLoaded
"
callback
)
;
}
return
deferred
.
promise
;
}
setIframeDocumentDir
:
function
(
iframe
)
{
let
docEl
=
iframe
.
contentWindow
&
&
iframe
.
contentWindow
.
document
.
documentElement
;
if
(
!
docEl
|
|
docEl
.
namespaceURI
!
=
=
HTML_NS
)
{
return
;
}
if
(
docEl
.
hasAttribute
(
"
dir
"
)
)
{
docEl
.
setAttribute
(
"
dir
"
this
.
direction
)
;
}
}
selectSingleNode
:
function
(
collection
id
)
{
[
.
.
.
collection
]
.
forEach
(
node
=
>
{
if
(
node
.
id
=
=
=
id
)
{
node
.
setAttribute
(
"
selected
"
"
true
"
)
;
node
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
}
else
{
node
.
removeAttribute
(
"
selected
"
)
;
node
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
if
(
!
node
.
id
)
{
node
=
this
.
webconsolePanel
;
}
let
iframe
=
node
.
querySelector
(
"
.
toolbox
-
panel
-
iframe
"
)
;
if
(
iframe
)
{
let
visible
=
node
.
id
=
=
id
;
if
(
node
=
=
this
.
webconsolePanel
&
&
this
.
splitConsole
)
{
visible
=
true
;
}
this
.
setIframeVisible
(
iframe
visible
)
;
}
}
)
;
}
setIframeVisible
:
function
(
iframe
visible
)
{
let
state
=
visible
?
"
visible
"
:
"
hidden
"
;
let
win
=
iframe
.
contentWindow
;
let
doc
=
win
.
document
;
if
(
doc
.
visibilityState
!
=
state
)
{
Object
.
defineProperty
(
doc
"
visibilityState
"
{
value
:
state
configurable
:
true
}
)
;
win
.
dispatchEvent
(
new
win
.
Event
(
"
visibilitychange
"
)
)
;
}
}
selectTool
:
function
(
id
reason
=
"
unknown
"
)
{
if
(
this
.
currentToolId
=
=
id
)
{
let
panel
=
this
.
_toolPanels
.
get
(
id
)
;
if
(
panel
)
{
this
.
focusTool
(
id
)
;
return
promise
.
resolve
(
panel
)
;
}
return
this
.
once
(
"
select
"
)
.
then
(
(
)
=
>
promise
.
resolve
(
this
.
_toolPanels
.
get
(
id
)
)
)
;
}
if
(
!
this
.
isReady
)
{
throw
new
Error
(
"
Can
'
t
select
tool
wait
for
toolbox
'
ready
'
event
"
)
;
}
if
(
this
.
panelDefinitions
.
find
(
(
definition
)
=
>
definition
.
id
=
=
=
id
)
|
|
id
=
=
=
"
options
"
|
|
this
.
additionalToolDefinitions
.
get
(
id
)
)
{
if
(
this
.
currentToolId
)
{
this
.
_telemetry
.
toolClosed
(
this
.
currentToolId
)
;
}
this
.
_pingTelemetrySelectTool
(
id
reason
)
;
}
else
{
throw
new
Error
(
"
No
tool
found
"
)
;
}
let
toolboxPanels
=
this
.
doc
.
querySelectorAll
(
"
.
toolbox
-
panel
"
)
;
this
.
selectSingleNode
(
toolboxPanels
"
toolbox
-
panel
-
"
+
id
)
;
this
.
lastUsedToolId
=
this
.
currentToolId
;
this
.
currentToolId
=
id
;
this
.
_refreshConsoleDisplay
(
)
;
if
(
id
!
=
"
options
"
)
{
Services
.
prefs
.
setCharPref
(
this
.
_prefs
.
LAST_TOOL
id
)
;
}
return
this
.
loadTool
(
id
)
.
then
(
panel
=
>
{
this
.
focusTool
(
id
)
;
this
.
emit
(
"
select
"
id
)
;
this
.
emit
(
id
+
"
-
selected
"
panel
)
;
return
panel
;
}
)
;
}
_pingTelemetrySelectTool
(
id
reason
)
{
const
width
=
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
;
const
panelName
=
this
.
getTelemetryPanelName
(
id
)
;
const
prevPanelName
=
this
.
getTelemetryPanelName
(
this
.
currentToolId
)
;
this
.
_telemetry
.
addEventProperties
(
"
devtools
.
main
"
"
enter
"
panelName
null
{
"
host
"
:
this
.
_hostType
"
width
"
:
width
"
start_state
"
:
reason
"
panel_name
"
:
id
"
cold
"
:
!
this
.
getPanel
(
id
)
}
)
;
if
(
this
.
currentToolId
)
{
this
.
_telemetry
.
recordEvent
(
"
devtools
.
main
"
"
exit
"
prevPanelName
null
{
"
host
"
:
this
.
_hostType
"
width
"
:
width
"
panel_name
"
:
prevPanelName
"
next_panel
"
:
id
"
reason
"
:
reason
}
)
;
}
const
pending
=
[
"
host
"
"
width
"
"
start_state
"
"
panel_name
"
"
cold
"
]
;
if
(
id
=
=
=
"
webconsole
"
)
{
pending
.
push
(
"
message_count
"
)
;
}
this
.
_telemetry
.
preparePendingEvent
(
"
devtools
.
main
"
"
enter
"
panelName
null
pending
)
;
this
.
_telemetry
.
toolOpened
(
id
)
;
}
focusTool
:
function
(
id
state
=
true
)
{
let
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
state
)
{
iframe
.
focus
(
)
;
}
else
{
iframe
.
blur
(
)
;
}
}
focusConsoleInput
:
function
(
)
{
let
consolePanel
=
this
.
getPanel
(
"
webconsole
"
)
;
if
(
consolePanel
)
{
consolePanel
.
focusInput
(
)
;
}
}
_onFocus
:
function
(
{
originalTarget
}
)
{
let
webconsoleURL
=
gDevTools
.
getToolDefinition
(
"
webconsole
"
)
.
url
;
if
(
originalTarget
.
nodeType
!
=
=
1
|
|
originalTarget
.
baseURI
=
=
=
webconsoleURL
)
{
return
;
}
this
.
_lastFocusedElement
=
originalTarget
;
}
_onTabsOrderUpdated
:
function
(
)
{
this
.
_combineAndSortPanelDefinitions
(
)
;
}
openSplitConsole
:
function
(
)
{
this
.
_splitConsole
=
true
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_ENABLED_PREF
true
)
;
this
.
_refreshConsoleDisplay
(
)
;
let
iframe
=
this
.
webconsolePanel
.
querySelector
(
"
.
toolbox
-
panel
-
iframe
"
)
;
if
(
iframe
)
{
this
.
setIframeVisible
(
iframe
true
)
;
}
return
this
.
loadTool
(
"
webconsole
"
)
.
then
(
(
)
=
>
{
this
.
component
.
setIsSplitConsoleActive
(
true
)
;
this
.
emit
(
"
split
-
console
"
)
;
this
.
focusConsoleInput
(
)
;
}
)
;
}
closeSplitConsole
:
function
(
)
{
this
.
_splitConsole
=
false
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_ENABLED_PREF
false
)
;
this
.
_refreshConsoleDisplay
(
)
;
this
.
component
.
setIsSplitConsoleActive
(
false
)
;
this
.
emit
(
"
split
-
console
"
)
;
if
(
this
.
_lastFocusedElement
)
{
this
.
_lastFocusedElement
.
focus
(
)
;
}
return
promise
.
resolve
(
)
;
}
toggleSplitConsole
:
function
(
)
{
if
(
this
.
currentToolId
!
=
=
"
webconsole
"
)
{
return
this
.
splitConsole
?
this
.
closeSplitConsole
(
)
:
this
.
openSplitConsole
(
)
;
}
return
promise
.
resolve
(
)
;
}
reloadTarget
:
function
(
force
)
{
this
.
target
.
activeTab
.
reload
(
{
force
:
force
}
)
;
}
selectNextTool
:
function
(
)
{
let
definitions
=
this
.
component
.
panelDefinitions
;
const
index
=
definitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
this
.
currentToolId
)
;
let
definition
=
index
=
=
=
-
1
|
|
index
>
=
definitions
.
length
-
1
?
definitions
[
0
]
:
definitions
[
index
+
1
]
;
return
this
.
selectTool
(
definition
.
id
"
select_next_key
"
)
;
}
selectPreviousTool
:
function
(
)
{
let
definitions
=
this
.
component
.
panelDefinitions
;
const
index
=
definitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
this
.
currentToolId
)
;
let
definition
=
index
=
=
=
-
1
|
|
index
<
1
?
definitions
[
definitions
.
length
-
1
]
:
definitions
[
index
-
1
]
;
return
this
.
selectTool
(
definition
.
id
"
select_prev_key
"
)
;
}
async
highlightTool
(
id
)
{
if
(
!
this
.
component
)
{
await
this
.
isOpen
;
}
this
.
component
.
highlightTool
(
id
)
;
}
async
unhighlightTool
(
id
)
{
if
(
!
this
.
component
)
{
await
this
.
isOpen
;
}
this
.
component
.
unhighlightTool
(
id
)
;
}
raise
:
function
(
)
{
this
.
postMessage
(
{
name
:
"
raise
-
host
"
}
)
;
}
async
_onWillNavigate
(
)
{
let
toolId
=
this
.
currentToolId
;
if
(
toolId
!
=
"
inspector
"
&
&
toolId
!
=
"
webconsole
"
&
&
toolId
!
=
"
netmonitor
"
)
{
return
;
}
let
start
=
this
.
win
.
performance
.
now
(
)
;
let
panel
=
this
.
getPanel
(
toolId
)
;
if
(
!
panel
)
{
return
;
}
await
panel
.
once
(
"
reloaded
"
)
;
let
delay
=
this
.
win
.
performance
.
now
(
)
-
start
;
let
telemetryKey
=
"
DEVTOOLS_TOOLBOX_PAGE_RELOAD_DELAY_MS
"
;
let
histogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
telemetryKey
)
;
histogram
.
add
(
toolId
delay
)
;
}
_refreshHostTitle
:
function
(
)
{
let
title
;
if
(
this
.
target
.
name
&
&
this
.
target
.
name
!
=
this
.
target
.
url
)
{
const
url
=
this
.
target
.
isWebExtension
?
this
.
target
.
getExtensionPathName
(
this
.
target
.
url
)
:
getUnicodeUrl
(
this
.
target
.
url
)
;
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate2
"
this
.
target
.
name
url
)
;
}
else
{
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate1
"
getUnicodeUrl
(
this
.
target
.
url
)
)
;
}
this
.
postMessage
(
{
name
:
"
set
-
host
-
title
"
title
}
)
;
}
get
preferenceFront
(
)
{
if
(
this
.
_preferenceFront
)
{
return
Promise
.
resolve
(
this
.
_preferenceFront
)
;
}
return
this
.
isOpen
.
then
(
(
)
=
>
{
return
this
.
target
.
root
.
then
(
rootForm
=
>
{
let
front
=
getPreferenceFront
(
this
.
target
.
client
rootForm
)
;
this
.
_preferenceFront
=
front
;
return
front
;
}
)
;
}
)
;
}
get
disableAutohideAvailable
(
)
{
return
this
.
_target
.
chrome
;
}
async
toggleNoAutohide
(
)
{
let
front
=
await
this
.
preferenceFront
;
let
toggledValue
=
!
(
await
this
.
_isDisableAutohideEnabled
(
)
)
;
front
.
setBoolPref
(
DISABLE_AUTOHIDE_PREF
toggledValue
)
;
if
(
this
.
disableAutohideAvailable
)
{
this
.
component
.
setDisableAutohide
(
toggledValue
)
;
}
this
.
_autohideHasBeenToggled
=
true
;
}
async
_isDisableAutohideEnabled
(
)
{
await
this
.
isOpen
;
if
(
!
this
.
disableAutohideAvailable
)
{
return
false
;
}
let
prefFront
=
await
this
.
preferenceFront
;
return
prefFront
.
getBoolPref
(
DISABLE_AUTOHIDE_PREF
)
;
}
_listFrames
:
function
(
event
)
{
if
(
!
this
.
_target
.
activeTab
|
|
!
this
.
_target
.
activeTab
.
traits
.
frames
)
{
return
promise
.
resolve
(
)
;
}
let
packet
=
{
to
:
this
.
_target
.
form
.
actor
type
:
"
listFrames
"
}
;
return
this
.
_target
.
client
.
request
(
packet
resp
=
>
{
this
.
_updateFrames
(
{
frames
:
resp
.
frames
}
)
;
}
)
;
}
showFramesMenu
:
async
function
(
event
)
{
let
menu
=
new
Menu
(
)
;
let
target
=
event
.
target
;
await
this
.
initInspector
(
)
;
if
(
!
(
"
_supportsFrameHighlight
"
in
this
)
)
{
this
.
_supportsFrameHighlight
=
await
this
.
target
.
actorHasMethod
(
"
domwalker
"
"
getNodeActorFromWindowID
"
)
;
}
this
.
frameMap
.
forEach
(
frame
=
>
{
let
checked
=
frame
.
id
=
=
this
.
selectedFrameId
;
let
label
;
if
(
this
.
target
.
isWebExtension
)
{
label
=
this
.
target
.
getExtensionPathName
(
frame
.
url
)
;
}
else
{
label
=
getUnicodeUrl
(
frame
.
url
)
;
}
menu
.
append
(
new
MenuItem
(
{
label
type
:
"
radio
"
checked
click
:
(
)
=
>
{
this
.
onSelectFrame
(
frame
.
id
)
;
}
hover
:
(
)
=
>
{
this
.
onHightlightFrame
(
frame
.
id
)
;
}
}
)
)
;
}
)
;
menu
.
once
(
"
open
"
)
.
then
(
(
)
=
>
{
this
.
frameButton
.
isChecked
=
true
;
}
)
;
menu
.
once
(
"
close
"
)
.
then
(
(
)
=
>
{
this
.
frameButton
.
isChecked
=
false
;
this
.
highlighterUtils
.
unhighlight
(
)
;
}
)
;
let
rect
=
target
.
getBoundingClientRect
(
)
;
let
screenX
=
target
.
ownerDocument
.
defaultView
.
mozInnerScreenX
;
let
screenY
=
target
.
ownerDocument
.
defaultView
.
mozInnerScreenY
;
menu
.
popup
(
rect
.
left
+
screenX
rect
.
bottom
+
screenY
this
)
;
return
menu
;
}
handleKeyDownOnFramesButton
:
function
(
event
)
{
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
showFrames
.
key
"
)
this
.
showFramesMenuOnKeyDown
)
;
}
showFramesMenuOnKeyDown
:
function
(
event
)
{
if
(
event
.
target
.
id
=
=
"
command
-
button
-
frames
"
)
{
this
.
showFramesMenu
(
event
)
;
}
}
onSelectFrame
:
function
(
frameId
)
{
let
packet
=
{
to
:
this
.
_target
.
form
.
actor
type
:
"
switchToFrame
"
windowId
:
frameId
}
;
this
.
_target
.
client
.
request
(
packet
)
;
}
onHightlightFrame
:
async
function
(
frameId
)
{
if
(
this
.
_supportsFrameHighlight
&
&
this
.
rootFrameSelected
)
{
let
frameActor
=
await
this
.
walker
.
getNodeActorFromWindowID
(
frameId
)
;
this
.
highlighterUtils
.
highlightNodeFront
(
frameActor
)
;
}
}
_updateFrames
:
function
(
data
)
{
if
(
!
this
.
isReady
)
{
return
;
}
if
(
data
.
destroyAll
)
{
this
.
frameMap
.
clear
(
)
;
this
.
selectedFrameId
=
null
;
}
else
if
(
data
.
selected
)
{
this
.
selectedFrameId
=
data
.
selected
;
}
else
if
(
data
.
frames
)
{
data
.
frames
.
forEach
(
frame
=
>
{
if
(
frame
.
destroy
)
{
this
.
frameMap
.
delete
(
frame
.
id
)
;
if
(
this
.
selectedFrameId
=
=
frame
.
id
)
{
this
.
selectedFrameId
=
null
;
}
}
else
{
this
.
frameMap
.
set
(
frame
.
id
frame
)
;
}
}
)
;
}
if
(
!
this
.
selectedFrameId
)
{
let
frames
=
[
.
.
.
this
.
frameMap
.
values
(
)
]
;
let
topFrames
=
frames
.
filter
(
frame
=
>
!
frame
.
parentID
)
;
this
.
selectedFrameId
=
topFrames
.
length
?
topFrames
[
0
]
.
id
:
null
;
}
let
frame
=
this
.
frameMap
.
get
(
this
.
selectedFrameId
)
;
let
topFrameSelected
=
frame
?
!
frame
.
parentID
:
false
;
this
.
_framesButtonChecked
=
false
;
if
(
!
topFrameSelected
&
&
this
.
selectedFrameId
)
{
this
.
_framesButtonChecked
=
false
;
}
this
.
frameButton
.
isVisible
=
this
.
_commandIsVisible
(
this
.
frameButton
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
get
selectedFrameDepth
(
)
{
if
(
!
this
.
selectedFrameId
)
{
return
0
;
}
let
depth
=
0
;
let
frame
=
this
.
frameMap
.
get
(
this
.
selectedFrameId
)
;
while
(
frame
)
{
depth
+
+
;
frame
=
this
.
frameMap
.
get
(
frame
.
parentID
)
;
}
return
depth
-
1
;
}
get
rootFrameSelected
(
)
{
return
this
.
selectedFrameDepth
=
=
0
;
}
switchToPreviousHost
:
function
(
)
{
return
this
.
switchHost
(
"
previous
"
)
;
}
switchHost
:
function
(
hostType
)
{
if
(
hostType
=
=
this
.
hostType
|
|
!
this
.
_target
.
isLocalTab
)
{
return
null
;
}
this
.
emit
(
"
host
-
will
-
change
"
hostType
)
;
this
.
focusTool
(
this
.
currentToolId
false
)
;
this
.
postMessage
(
{
name
:
"
switch
-
host
"
hostType
}
)
;
return
this
.
once
(
"
host
-
changed
"
)
;
}
_onSwitchedHost
:
function
(
{
hostType
}
)
{
this
.
_hostType
=
hostType
;
this
.
_buildDockOptions
(
)
;
this
.
_addKeysToWindow
(
)
;
this
.
focusTool
(
this
.
currentToolId
true
)
;
this
.
emit
(
"
host
-
changed
"
)
;
this
.
_telemetry
.
log
(
HOST_HISTOGRAM
this
.
_getTelemetryHostId
(
)
)
;
}
isToolRegistered
:
function
(
toolId
)
{
return
!
!
this
.
getToolDefinition
(
toolId
)
;
}
getToolDefinition
:
function
(
toolId
)
{
return
gDevTools
.
getToolDefinition
(
toolId
)
|
|
this
.
additionalToolDefinitions
.
get
(
toolId
)
;
}
unloadTool
:
function
(
toolId
)
{
if
(
typeof
toolId
!
=
"
string
"
)
{
throw
new
Error
(
"
Unexpected
non
-
string
toolId
received
.
"
)
;
}
if
(
this
.
_toolPanels
.
has
(
toolId
)
)
{
let
instance
=
this
.
_toolPanels
.
get
(
toolId
)
;
instance
.
destroy
(
)
;
this
.
_toolPanels
.
delete
(
toolId
)
;
}
let
panel
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
toolId
)
;
if
(
this
.
currentToolId
=
=
toolId
)
{
let
index
=
this
.
panelDefinitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
toolId
)
;
let
nextTool
=
this
.
panelDefinitions
[
index
+
1
]
;
let
previousTool
=
this
.
panelDefinitions
[
index
-
1
]
;
let
toolNameToSelect
;
if
(
nextTool
)
{
toolNameToSelect
=
nextTool
.
id
;
}
if
(
previousTool
)
{
toolNameToSelect
=
previousTool
.
id
;
}
if
(
toolNameToSelect
)
{
this
.
selectTool
(
toolNameToSelect
"
tool_unloaded
"
)
;
}
}
this
.
panelDefinitions
=
this
.
panelDefinitions
.
filter
(
(
{
id
}
)
=
>
id
!
=
=
toolId
)
;
this
.
visibleAdditionalTools
=
this
.
visibleAdditionalTools
.
filter
(
id
=
>
id
!
=
=
toolId
)
;
this
.
_combineAndSortPanelDefinitions
(
)
;
if
(
panel
)
{
panel
.
remove
(
)
;
}
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
let
doc
=
this
.
win
.
parent
.
document
;
let
key
=
doc
.
getElementById
(
"
key_
"
+
toolId
)
;
if
(
key
)
{
key
.
remove
(
)
;
}
}
}
_toolRegistered
:
function
(
toolId
)
{
let
definition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
let
isAdditionalTool
=
false
;
if
(
!
definition
)
{
definition
=
this
.
additionalToolDefinitions
.
get
(
toolId
)
;
isAdditionalTool
=
true
;
}
if
(
definition
.
isTargetSupported
(
this
.
_target
)
)
{
if
(
isAdditionalTool
)
{
this
.
visibleAdditionalTools
=
[
.
.
.
this
.
visibleAdditionalTools
toolId
]
;
this
.
_combineAndSortPanelDefinitions
(
)
;
}
else
{
this
.
panelDefinitions
=
this
.
panelDefinitions
.
concat
(
definition
)
;
}
this
.
_buildPanelForTool
(
definition
)
;
this
.
emit
(
"
tool
-
registered
"
toolId
)
;
}
}
_toolUnregistered
:
function
(
toolId
)
{
this
.
unloadTool
(
toolId
)
;
this
.
emit
(
"
tool
-
unregistered
"
toolId
)
;
}
initInspector
:
function
(
)
{
if
(
!
this
.
_initInspector
)
{
this
.
_initInspector
=
(
async
function
(
)
{
this
.
_inspector
=
InspectorFront
(
this
.
_target
.
client
this
.
_target
.
form
)
;
let
pref
=
"
devtools
.
inspector
.
showAllAnonymousContent
"
;
let
showAllAnonymousContent
=
Services
.
prefs
.
getBoolPref
(
pref
)
;
this
.
_walker
=
await
this
.
_inspector
.
getWalker
(
{
showAllAnonymousContent
}
)
;
this
.
_selection
=
new
Selection
(
this
.
_walker
)
;
this
.
_selection
.
on
(
"
new
-
node
-
front
"
this
.
_onNewSelectedNodeFront
)
;
if
(
this
.
highlighterUtils
.
isRemoteHighlightable
(
)
)
{
this
.
walker
.
on
(
"
highlighter
-
ready
"
this
.
_highlighterReady
)
;
this
.
walker
.
on
(
"
highlighter
-
hide
"
this
.
_highlighterHidden
)
;
let
autohide
=
!
flags
.
testing
;
this
.
_highlighter
=
await
this
.
_inspector
.
getHighlighter
(
autohide
)
;
}
}
.
bind
(
this
)
)
(
)
;
}
return
this
.
_initInspector
;
}
_onNewSelectedNodeFront
:
function
(
)
{
this
.
emit
(
"
selection
-
changed
"
)
;
}
_onInspectObject
:
function
(
packet
)
{
this
.
inspectObjectActor
(
packet
.
objectActor
packet
.
inspectFromAnnotation
)
;
}
inspectObjectActor
:
async
function
(
objectActor
inspectFromAnnotation
)
{
if
(
objectActor
.
preview
&
&
objectActor
.
preview
.
nodeType
=
=
=
domNodeConstants
.
ELEMENT_NODE
)
{
await
this
.
loadTool
(
"
inspector
"
)
;
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
const
nodeFound
=
await
inspector
.
inspectNodeActor
(
objectActor
.
actor
inspectFromAnnotation
)
;
if
(
nodeFound
)
{
await
this
.
selectTool
(
"
inspector
"
"
inspect_dom
"
)
;
}
}
else
if
(
objectActor
.
type
!
=
=
"
null
"
&
&
objectActor
.
type
!
=
=
"
undefined
"
)
{
await
this
.
openSplitConsole
(
)
;
const
panel
=
this
.
getPanel
(
"
webconsole
"
)
;
const
jsterm
=
panel
.
hud
.
jsterm
;
jsterm
.
inspectObjectActor
(
objectActor
)
;
}
}
destroyInspector
:
function
(
)
{
if
(
this
.
_destroyingInspector
)
{
return
this
.
_destroyingInspector
;
}
this
.
_destroyingInspector
=
(
async
function
(
)
{
if
(
!
this
.
_inspector
)
{
return
;
}
await
this
.
_initInspector
;
let
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
.
stopPicker
)
{
await
currentPanel
.
stopPicker
(
)
;
}
else
{
await
this
.
highlighterUtils
.
stopPicker
(
)
;
}
await
this
.
_inspector
.
destroy
(
)
;
if
(
this
.
_highlighter
)
{
if
(
!
this
.
highlighter
.
traits
.
autoHideOnDestroy
)
{
this
.
highlighterUtils
.
unhighlight
(
)
;
}
await
this
.
_highlighter
.
destroy
(
)
;
}
if
(
this
.
_selection
)
{
this
.
_selection
.
off
(
"
new
-
node
-
front
"
this
.
_onNewSelectedNodeFront
)
;
this
.
_selection
.
destroy
(
)
;
}
if
(
this
.
walker
)
{
this
.
walker
.
off
(
"
highlighter
-
ready
"
this
.
_highlighterReady
)
;
this
.
walker
.
off
(
"
highlighter
-
hide
"
this
.
_highlighterHidden
)
;
}
this
.
_inspector
=
null
;
this
.
_highlighter
=
null
;
this
.
_selection
=
null
;
this
.
_walker
=
null
;
}
.
bind
(
this
)
)
(
)
;
return
this
.
_destroyingInspector
;
}
getNotificationBox
:
function
(
)
{
return
this
.
notificationBox
;
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
let
deferred
=
defer
(
)
;
this
.
_destroyer
=
deferred
.
promise
;
this
.
emit
(
"
destroy
"
)
;
this
.
_target
.
off
(
"
inspect
-
object
"
this
.
_onInspectObject
)
;
this
.
_target
.
off
(
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
_target
.
off
(
"
navigate
"
this
.
_refreshHostTitle
)
;
this
.
_target
.
off
(
"
frame
-
update
"
this
.
_updateFrames
)
;
this
.
off
(
"
select
"
this
.
_refreshHostTitle
)
;
this
.
off
(
"
select
"
this
.
updatePickerButton
)
;
this
.
off
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
this
.
off
(
"
ready
"
this
.
_showDevEditionPromo
)
;
gDevTools
.
off
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
off
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
Services
.
prefs
.
removeObserver
(
"
devtools
.
cache
.
disabled
"
this
.
_applyCacheSettings
)
;
Services
.
prefs
.
removeObserver
(
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
this
.
_applyServiceWorkersTestingSettings
)
;
this
.
_lastFocusedElement
=
null
;
if
(
this
.
_sourceMapURLService
)
{
this
.
_sourceMapURLService
.
destroy
(
)
;
this
.
_sourceMapURLService
=
null
;
}
if
(
this
.
_sourceMapService
)
{
this
.
_sourceMapService
.
stopSourceMapWorker
(
)
;
this
.
_sourceMapService
=
null
;
}
if
(
this
.
webconsolePanel
)
{
this
.
_saveSplitConsoleHeight
(
)
;
this
.
webconsolePanel
.
removeEventListener
(
"
resize
"
this
.
_saveSplitConsoleHeight
)
;
this
.
webconsolePanel
=
null
;
}
if
(
this
.
textBoxContextMenuPopup
)
{
this
.
textBoxContextMenuPopup
.
removeEventListener
(
"
popupshowing
"
this
.
_updateTextBoxMenuItems
true
)
;
this
.
textBoxContextMenuPopup
=
null
;
}
if
(
this
.
_componentMount
)
{
this
.
_componentMount
.
removeEventListener
(
"
keypress
"
this
.
_onToolbarArrowKeypress
)
;
this
.
ReactDOM
.
unmountComponentAtNode
(
this
.
_componentMount
)
;
this
.
_componentMount
=
null
;
}
let
outstanding
=
[
]
;
for
(
let
[
id
panel
]
of
this
.
_toolPanels
)
{
try
{
gDevTools
.
emit
(
id
+
"
-
destroy
"
this
panel
)
;
this
.
emit
(
id
+
"
-
destroy
"
panel
)
;
outstanding
.
push
(
panel
.
destroy
(
)
)
;
}
catch
(
e
)
{
console
.
error
(
"
Panel
"
+
id
+
"
:
"
e
)
;
}
}
this
.
browserRequire
=
null
;
if
(
this
.
target
.
activeTab
&
&
!
this
.
target
.
activeTab
.
traits
.
noTabReconfigureOnClose
)
{
this
.
target
.
activeTab
.
reconfigure
(
{
"
cacheDisabled
"
:
false
"
serviceWorkersTestingEnabled
"
:
false
}
)
;
}
outstanding
.
push
(
this
.
destroyInspector
(
)
)
;
outstanding
.
push
(
this
.
destroyPerformance
(
)
)
;
outstanding
.
push
(
this
.
destroyPreference
(
)
)
;
if
(
this
.
_styleSheets
)
{
this
.
_styleSheets
.
destroy
(
)
;
this
.
_styleSheets
=
null
;
}
let
deviceFront
=
getKnownDeviceFront
(
this
.
target
.
client
)
;
if
(
deviceFront
)
{
deviceFront
.
destroy
(
)
;
}
detachThread
(
this
.
_threadClient
)
;
this
.
_threadClient
=
null
;
this
.
toolbarButtons
.
forEach
(
button
=
>
{
if
(
typeof
button
.
teardown
=
=
"
function
"
)
{
button
.
teardown
(
)
;
}
}
)
;
const
win
=
this
.
win
;
const
host
=
this
.
_getTelemetryHostString
(
)
;
const
width
=
Math
.
ceil
(
win
.
outerWidth
/
50
)
*
50
;
const
prevPanelName
=
this
.
getTelemetryPanelName
(
this
.
currentToolId
)
;
this
.
_telemetry
.
toolClosed
(
"
toolbox
"
)
;
this
.
_telemetry
.
recordEvent
(
"
devtools
.
main
"
"
close
"
"
tools
"
null
{
host
:
host
width
:
width
}
)
;
this
.
_telemetry
.
recordEvent
(
"
devtools
.
main
"
"
exit
"
prevPanelName
null
{
"
host
"
:
host
"
width
"
:
width
"
panel_name
"
:
this
.
currentToolId
"
next_panel
"
:
"
none
"
"
reason
"
:
"
toolbox_close
"
}
)
;
this
.
_telemetry
.
destroy
(
)
;
deferred
.
resolve
(
settleAll
(
outstanding
)
.
catch
(
console
.
error
)
.
then
(
(
)
=
>
{
let
api
=
this
.
_netMonitorAPI
;
this
.
_netMonitorAPI
=
null
;
return
api
?
api
.
destroy
(
)
:
null
;
}
console
.
error
)
.
then
(
(
)
=
>
{
this
.
_removeHostListeners
(
)
;
try
{
win
.
location
.
replace
(
"
about
:
blank
"
)
;
}
catch
(
e
)
{
}
if
(
!
this
.
_target
)
{
return
null
;
}
let
target
=
this
.
_target
;
this
.
_target
=
null
;
this
.
highlighterUtils
.
release
(
)
;
target
.
off
(
"
close
"
this
.
destroy
)
;
return
target
.
destroy
(
)
;
}
console
.
error
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
destroyed
"
)
;
this
.
_host
=
null
;
this
.
_win
=
null
;
this
.
_toolPanels
.
clear
(
)
;
if
(
flags
.
testing
)
{
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
garbageCollect
(
)
;
}
}
)
.
catch
(
console
.
error
)
)
;
let
leakCheckObserver
=
(
{
wrappedJSObject
:
barrier
}
)
=
>
{
barrier
.
client
.
addBlocker
(
"
DevTools
:
Wait
until
toolbox
is
destroyed
"
this
.
_destroyer
)
;
}
;
let
topic
=
"
shutdown
-
leaks
-
before
-
check
"
;
Services
.
obs
.
addObserver
(
leakCheckObserver
topic
)
;
this
.
_destroyer
.
then
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
leakCheckObserver
topic
)
;
}
)
;
return
this
.
_destroyer
;
}
_highlighterReady
:
function
(
)
{
this
.
emit
(
"
highlighter
-
ready
"
)
;
}
_highlighterHidden
:
function
(
)
{
this
.
emit
(
"
highlighter
-
hide
"
)
;
}
_showDevEditionPromo
:
function
(
)
{
if
(
this
.
target
.
chrome
)
{
return
;
}
showDoorhanger
(
{
window
:
this
.
win
type
:
"
deveditionpromo
"
}
)
;
}
_updateTextBoxMenuItems
:
function
(
)
{
let
window
=
this
.
win
;
[
"
cmd_undo
"
"
cmd_delete
"
"
cmd_cut
"
"
cmd_copy
"
"
cmd_paste
"
"
cmd_selectAll
"
]
.
forEach
(
window
.
goUpdateCommand
)
;
}
openTextBoxContextMenu
:
function
(
x
y
)
{
this
.
textBoxContextMenuPopup
.
openPopupAtScreen
(
x
y
true
)
;
}
async
initPerformance
(
)
{
if
(
!
this
.
target
.
hasActor
(
"
performance
"
)
)
{
return
promise
.
resolve
(
)
;
}
if
(
this
.
_performanceFrontConnection
)
{
return
this
.
_performanceFrontConnection
.
promise
;
}
this
.
_performanceFrontConnection
=
defer
(
)
;
this
.
_performance
=
createPerformanceFront
(
this
.
_target
)
;
await
this
.
performance
.
connect
(
)
;
this
.
emit
(
"
profiler
-
connected
"
)
;
this
.
performance
.
on
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
this
.
_performanceFrontConnection
.
resolve
(
this
.
performance
)
;
return
this
.
_performanceFrontConnection
.
promise
;
}
async
destroyPerformance
(
)
{
if
(
!
this
.
performance
)
{
return
;
}
if
(
this
.
_performanceFrontConnection
)
{
await
this
.
_performanceFrontConnection
.
promise
;
}
this
.
performance
.
off
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
await
this
.
performance
.
destroy
(
)
;
this
.
_performance
=
null
;
}
initStyleSheetsFront
:
function
(
)
{
if
(
!
this
.
_styleSheets
&
&
this
.
target
.
hasActor
(
"
styleSheets
"
)
)
{
this
.
_styleSheets
=
StyleSheetsFront
(
this
.
target
.
client
this
.
target
.
form
)
;
}
return
this
.
_styleSheets
;
}
async
destroyPreference
(
)
{
if
(
!
this
.
_preferenceFront
)
{
return
;
}
if
(
this
.
_autohideHasBeenToggled
)
{
await
this
.
_preferenceFront
.
clearUserPref
(
DISABLE_AUTOHIDE_PREF
)
;
}
this
.
_preferenceFront
.
destroy
(
)
;
this
.
_preferenceFront
=
null
;
}
async
_onPerformanceFrontEvent
(
eventName
recording
)
{
if
(
this
.
getPanel
(
"
performance
"
)
)
{
this
.
performance
.
off
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
return
;
}
this
.
_performanceQueuedRecordings
=
this
.
_performanceQueuedRecordings
|
|
[
]
;
let
recordings
=
this
.
_performanceQueuedRecordings
;
if
(
eventName
=
=
=
"
console
-
profile
-
start
"
&
&
!
this
.
_performanceToolOpenedViaConsole
)
{
this
.
_performanceToolOpenedViaConsole
=
this
.
loadTool
(
"
performance
"
)
;
let
panel
=
await
this
.
_performanceToolOpenedViaConsole
;
await
panel
.
open
(
)
;
panel
.
panelWin
.
PerformanceController
.
populateWithRecordings
(
recordings
)
;
this
.
performance
.
off
(
"
*
"
this
.
_onPerformanceFrontEvent
)
;
}
if
(
eventName
=
=
=
"
recording
-
started
"
)
{
recordings
.
push
(
recording
)
;
}
}
get
gViewSourceUtils
(
)
{
return
this
.
win
.
gViewSourceUtils
;
}
viewSourceInStyleEditor
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInStyleEditor
(
this
sourceURL
sourceLine
)
;
}
viewSourceInDebugger
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInDebugger
(
this
sourceURL
sourceLine
)
;
}
viewSourceInScratchpad
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSourceInScratchpad
(
sourceURL
sourceLine
)
;
}
viewSource
:
function
(
sourceURL
sourceLine
)
{
return
viewSource
.
viewSource
(
this
sourceURL
sourceLine
)
;
}
getNetMonitorAPI
:
async
function
(
)
{
let
netPanel
=
this
.
getPanel
(
"
netmonitor
"
)
;
if
(
netPanel
)
{
return
netPanel
.
panelWin
.
Netmonitor
.
api
;
}
if
(
this
.
_netMonitorAPI
)
{
return
this
.
_netMonitorAPI
;
}
this
.
_netMonitorAPI
=
new
NetMonitorAPI
(
)
;
await
this
.
_netMonitorAPI
.
connect
(
this
)
;
return
this
.
_netMonitorAPI
;
}
getHARFromNetMonitor
:
async
function
(
)
{
let
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
let
har
=
await
netMonitor
.
getHar
(
)
;
har
=
har
|
|
buildHarLog
(
Services
.
appinfo
)
;
return
har
.
log
;
}
addRequestFinishedListener
:
async
function
(
listener
)
{
let
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
netMonitor
.
addRequestFinishedListener
(
listener
)
;
}
removeRequestFinishedListener
:
async
function
(
listener
)
{
let
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
netMonitor
.
removeRequestFinishedListener
(
listener
)
;
let
netPanel
=
this
.
getPanel
(
"
netmonitor
"
)
;
let
hasListeners
=
netMonitor
.
hasRequestFinishedListeners
(
)
;
if
(
this
.
_netMonitorAPI
&
&
!
hasListeners
&
&
!
netPanel
)
{
this
.
_netMonitorAPI
.
destroy
(
)
;
this
.
_netMonitorAPI
=
null
;
}
}
fetchResponseContent
:
async
function
(
requestId
)
{
let
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
return
netMonitor
.
fetchResponseContent
(
requestId
)
;
}
listWebExtensions
:
function
(
)
{
return
Array
.
from
(
this
.
_webExtensions
)
.
map
(
(
[
uuid
{
name
pref
}
]
)
=
>
{
return
{
uuid
name
pref
}
;
}
)
;
}
registerWebExtension
:
function
(
extensionUUID
{
name
pref
}
)
{
this
.
_webExtensions
.
set
(
extensionUUID
{
name
pref
}
)
;
this
.
emit
(
"
webextension
-
registered
"
extensionUUID
)
;
}
unregisterWebExtension
:
function
(
extensionUUID
)
{
this
.
_webExtensions
.
delete
(
extensionUUID
)
;
this
.
emit
(
"
webextension
-
unregistered
"
extensionUUID
)
;
}
isWebExtensionEnabled
:
function
(
extensionUUID
)
{
let
extInfo
=
this
.
_webExtensions
.
get
(
extensionUUID
)
;
return
extInfo
&
&
Services
.
prefs
.
getBoolPref
(
extInfo
.
pref
false
)
;
}
getTelemetryPanelName
:
function
(
id
)
{
if
(
!
REGEX_PANEL
.
test
(
id
)
)
{
return
"
other
"
;
}
return
id
;
}
}
;
