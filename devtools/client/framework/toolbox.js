"
use
strict
"
;
const
MAX_ORDINAL
=
99
;
const
SPLITCONSOLE_OPEN_PREF
=
"
devtools
.
toolbox
.
splitconsole
.
open
"
;
const
SPLITCONSOLE_ENABLED_PREF
=
"
devtools
.
toolbox
.
splitconsole
.
enabled
"
;
const
SPLITCONSOLE_HEIGHT_PREF
=
"
devtools
.
toolbox
.
splitconsoleHeight
"
;
const
DEVTOOLS_ALWAYS_ON_TOP
=
"
devtools
.
toolbox
.
alwaysOnTop
"
;
const
DISABLE_AUTOHIDE_PREF
=
"
ui
.
popup
.
disable_autohide
"
;
const
PSEUDO_LOCALE_PREF
=
"
intl
.
l10n
.
pseudo
"
;
const
HOST_HISTOGRAM
=
"
DEVTOOLS_TOOLBOX_HOST
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
REGEX_4XX_5XX
=
/
^
[
4
5
]
\
d
\
d
/
;
const
BROWSERTOOLBOX_SCOPE_PREF
=
"
devtools
.
browsertoolbox
.
scope
"
;
const
BROWSERTOOLBOX_SCOPE_EVERYTHING
=
"
everything
"
;
const
BROWSERTOOLBOX_SCOPE_PARENTPROCESS
=
"
parent
-
process
"
;
const
{
debounce
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
debounce
.
js
"
)
;
const
{
throttle
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
throttle
.
js
"
)
;
const
{
safeAsyncMethod
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
async
-
utils
.
js
"
)
;
var
{
gDevTools
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
devtools
.
js
"
)
;
var
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
Selection
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
selection
.
js
"
)
;
var
Telemetry
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
telemetry
.
js
"
)
;
const
{
getUnicodeUrl
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
unicode
-
url
.
js
"
)
;
var
{
DOMHelpers
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
dom
-
helpers
.
js
"
)
;
const
{
KeyCodes
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
keycodes
.
js
"
)
;
const
{
FluentL10n
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
fluent
-
l10n
/
fluent
-
l10n
.
js
"
)
;
var
Startup
=
Cc
[
"
mozilla
.
org
/
devtools
/
startup
-
clh
;
1
"
]
.
getService
(
Ci
.
nsISupports
)
.
wrappedJSObject
;
const
{
BrowserLoader
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
browser
-
loader
.
sys
.
mjs
"
)
;
const
{
MultiLocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
L10N
=
new
MultiLocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
"
devtools
/
client
/
locales
/
menus
.
properties
"
)
;
loader
.
lazyRequireGetter
(
this
"
registerStoreObserver
"
"
resource
:
/
/
devtools
/
client
/
shared
/
redux
/
subscriber
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createToolboxStore
"
"
resource
:
/
/
devtools
/
client
/
framework
/
store
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
registerWalkerListeners
"
"
removeTarget
"
]
"
resource
:
/
/
devtools
/
client
/
framework
/
actions
/
index
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
[
"
selectTarget
"
]
"
resource
:
/
/
devtools
/
shared
/
commands
/
target
/
actions
/
targets
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
TRACER_LOG_METHODS
"
"
resource
:
/
/
devtools
/
shared
/
specs
/
tracer
.
js
"
true
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
AppConstants
:
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
TYPES
:
"
resource
:
/
/
devtools
/
shared
/
highlighters
.
mjs
"
}
)
;
loader
.
lazyRequireGetter
(
this
"
flags
"
"
resource
:
/
/
devtools
/
shared
/
flags
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyShortcuts
"
"
resource
:
/
/
devtools
/
client
/
shared
/
key
-
shortcuts
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
ZoomKeys
"
"
resource
:
/
/
devtools
/
client
/
shared
/
zoom
-
keys
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
ToolboxButtons
"
"
resource
:
/
/
devtools
/
client
/
definitions
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SourceMapURLService
"
"
resource
:
/
/
devtools
/
client
/
framework
/
source
-
map
-
url
-
service
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
BrowserConsoleManager
"
"
resource
:
/
/
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
viewSource
"
"
resource
:
/
/
devtools
/
client
/
shared
/
view
-
source
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
buildHarLog
"
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
builder
-
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
NetMonitorAPI
"
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
api
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
sortPanelDefinitions
"
"
resource
:
/
/
devtools
/
client
/
framework
/
toolbox
-
tabs
-
order
-
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createEditContextMenu
"
"
resource
:
/
/
devtools
/
client
/
framework
/
toolbox
-
context
-
menu
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getSelectedTarget
"
"
resource
:
/
/
devtools
/
shared
/
commands
/
target
/
selectors
/
targets
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
remoteClientManager
"
"
resource
:
/
/
devtools
/
client
/
shared
/
remote
-
debugging
/
remote
-
client
-
manager
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
resource
:
/
/
devtools
/
client
/
responsive
/
manager
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
DevToolsUtils
"
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
NodePicker
"
"
resource
:
/
/
devtools
/
client
/
inspector
/
node
-
picker
.
js
"
)
;
loader
.
lazyGetter
(
this
"
domNodeConstants
"
(
)
=
>
{
return
require
(
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
constants
.
js
"
)
;
}
)
;
loader
.
lazyRequireGetter
(
this
"
NodeFront
"
"
resource
:
/
/
devtools
/
client
/
fronts
/
node
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
PICKER_TYPES
"
"
resource
:
/
/
devtools
/
shared
/
picker
-
constants
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
HarAutomation
"
"
resource
:
/
/
devtools
/
client
/
netmonitor
/
src
/
har
/
har
-
automation
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
getThreadOptions
"
"
resource
:
/
/
devtools
/
client
/
shared
/
thread
-
utils
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
SourceMapLoader
"
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
openProfilerTab
"
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
shared
/
browser
.
js
"
true
)
;
loader
.
lazyGetter
(
this
"
ProfilerBackground
"
(
)
=
>
{
return
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
shared
/
background
.
sys
.
mjs
"
)
;
}
)
;
const
BOOLEAN_CONFIGURATION_PREFS
=
{
"
devtools
.
cache
.
disabled
"
:
{
name
:
"
cacheDisabled
"
}
"
devtools
.
custom
-
formatters
.
enabled
"
:
{
name
:
"
customFormatters
"
}
"
devtools
.
serviceWorkers
.
testing
.
enabled
"
:
{
name
:
"
serviceWorkersTestingEnabled
"
}
"
devtools
.
inspector
.
simple
-
highlighters
-
reduced
-
motion
"
:
{
name
:
"
useSimpleHighlightersForReducedMotion
"
}
"
devtools
.
debugger
.
features
.
overlay
"
:
{
name
:
"
pauseOverlay
"
thread
:
true
}
"
devtools
.
debugger
.
features
.
javascript
-
tracing
"
:
{
name
:
"
isTracerFeatureEnabled
"
}
}
;
function
Toolbox
(
commands
selectedTool
hostType
contentWindow
frameId
)
{
this
.
_win
=
contentWindow
;
this
.
frameId
=
frameId
;
this
.
selection
=
new
Selection
(
)
;
this
.
telemetry
=
new
Telemetry
(
{
useSessionId
:
true
}
)
;
this
.
sessionId
=
this
.
telemetry
.
sessionId
;
this
.
commands
=
commands
;
this
.
_descriptorFront
=
commands
.
descriptorFront
;
this
.
_webExtensions
=
new
Map
(
)
;
this
.
_toolPanels
=
new
Map
(
)
;
this
.
_inspectorExtensionSidebars
=
new
Map
(
)
;
this
.
_netMonitorAPI
=
null
;
this
.
frameMap
=
new
Map
(
)
;
this
.
selectedFrameId
=
null
;
this
.
_pausedTargets
=
new
Set
(
)
;
this
.
_windowHostShortcuts
=
null
;
this
.
_toolRegistered
=
this
.
_toolRegistered
.
bind
(
this
)
;
this
.
_toolUnregistered
=
this
.
_toolUnregistered
.
bind
(
this
)
;
this
.
_refreshHostTitle
=
this
.
_refreshHostTitle
.
bind
(
this
)
;
this
.
toggleNoAutohide
=
this
.
toggleNoAutohide
.
bind
(
this
)
;
this
.
toggleAlwaysOnTop
=
this
.
toggleAlwaysOnTop
.
bind
(
this
)
;
this
.
disablePseudoLocale
=
(
)
=
>
this
.
changePseudoLocale
(
"
none
"
)
;
this
.
enableAccentedPseudoLocale
=
(
)
=
>
this
.
changePseudoLocale
(
"
accented
"
)
;
this
.
enableBidiPseudoLocale
=
(
)
=
>
this
.
changePseudoLocale
(
"
bidi
"
)
;
this
.
_updateFrames
=
this
.
_updateFrames
.
bind
(
this
)
;
this
.
_splitConsoleOnKeypress
=
this
.
_splitConsoleOnKeypress
.
bind
(
this
)
;
this
.
closeToolbox
=
this
.
closeToolbox
.
bind
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_saveSplitConsoleHeight
=
this
.
_saveSplitConsoleHeight
.
bind
(
this
)
;
this
.
_onFocus
=
this
.
_onFocus
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
this
.
_onBrowserMessage
=
this
.
_onBrowserMessage
.
bind
(
this
)
;
this
.
_onTabsOrderUpdated
=
this
.
_onTabsOrderUpdated
.
bind
(
this
)
;
this
.
_onToolbarFocus
=
this
.
_onToolbarFocus
.
bind
(
this
)
;
this
.
_onToolbarArrowKeypress
=
this
.
_onToolbarArrowKeypress
.
bind
(
this
)
;
this
.
_onPickerClick
=
this
.
_onPickerClick
.
bind
(
this
)
;
this
.
_onPickerKeypress
=
this
.
_onPickerKeypress
.
bind
(
this
)
;
this
.
_onPickerStarting
=
this
.
_onPickerStarting
.
bind
(
this
)
;
this
.
_onPickerStarted
=
this
.
_onPickerStarted
.
bind
(
this
)
;
this
.
_onPickerStopped
=
this
.
_onPickerStopped
.
bind
(
this
)
;
this
.
_onPickerCanceled
=
this
.
_onPickerCanceled
.
bind
(
this
)
;
this
.
_onPickerPicked
=
this
.
_onPickerPicked
.
bind
(
this
)
;
this
.
_onPickerPreviewed
=
this
.
_onPickerPreviewed
.
bind
(
this
)
;
this
.
_onInspectObject
=
this
.
_onInspectObject
.
bind
(
this
)
;
this
.
_onNewSelectedNodeFront
=
this
.
_onNewSelectedNodeFront
.
bind
(
this
)
;
this
.
_onToolSelected
=
this
.
_onToolSelected
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_onMouseDown
=
this
.
_onMouseDown
.
bind
(
this
)
;
this
.
updateToolboxButtonsVisibility
=
this
.
updateToolboxButtonsVisibility
.
bind
(
this
)
;
this
.
updateToolboxButtons
=
this
.
updateToolboxButtons
.
bind
(
this
)
;
this
.
selectTool
=
this
.
selectTool
.
bind
(
this
)
;
this
.
_pingTelemetrySelectTool
=
this
.
_pingTelemetrySelectTool
.
bind
(
this
)
;
this
.
toggleSplitConsole
=
this
.
toggleSplitConsole
.
bind
(
this
)
;
this
.
toggleOptions
=
this
.
toggleOptions
.
bind
(
this
)
;
this
.
_onTargetAvailable
=
this
.
_onTargetAvailable
.
bind
(
this
)
;
this
.
_onTargetDestroyed
=
this
.
_onTargetDestroyed
.
bind
(
this
)
;
this
.
_onTargetSelected
=
this
.
_onTargetSelected
.
bind
(
this
)
;
this
.
_onResourceAvailable
=
this
.
_onResourceAvailable
.
bind
(
this
)
;
this
.
_onResourceUpdated
=
this
.
_onResourceUpdated
.
bind
(
this
)
;
this
.
_onToolSelectedStopPicker
=
this
.
_onToolSelectedStopPicker
.
bind
(
this
)
;
this
.
_throttledSetToolboxButtons
=
throttle
(
(
)
=
>
this
.
component
?
.
setToolboxButtons
(
this
.
toolbarButtons
)
500
this
)
;
this
.
_debounceUpdateFocusedState
=
debounce
(
(
)
=
>
{
this
.
component
?
.
setFocusedState
(
this
.
_isToolboxFocused
)
;
}
500
this
)
;
if
(
!
selectedTool
)
{
selectedTool
=
Services
.
prefs
.
getCharPref
(
this
.
_prefs
.
LAST_TOOL
)
;
}
this
.
_defaultToolId
=
selectedTool
;
this
.
_hostType
=
hostType
;
this
.
isOpen
=
new
Promise
(
function
(
resolve
)
{
this
.
_resolveIsOpen
=
resolve
;
}
.
bind
(
this
)
)
;
EventEmitter
.
decorate
(
this
)
;
this
.
on
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
this
.
on
(
"
select
"
this
.
_onToolSelected
)
;
this
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
_onNewSelectedNodeFront
)
;
gDevTools
.
on
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
on
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
loader
.
lazyGetter
(
this
"
direction
"
(
)
=
>
{
const
{
documentElement
}
=
this
.
doc
;
const
isRtl
=
this
.
win
.
getComputedStyle
(
documentElement
)
.
direction
=
=
=
"
rtl
"
;
return
isRtl
?
"
rtl
"
:
"
ltr
"
;
}
)
;
}
exports
.
Toolbox
=
Toolbox
;
Toolbox
.
HostType
=
{
BOTTOM
:
"
bottom
"
RIGHT
:
"
right
"
LEFT
:
"
left
"
WINDOW
:
"
window
"
BROWSERTOOLBOX
:
"
browsertoolbox
"
PAGE
:
"
page
"
}
;
Toolbox
.
prototype
=
{
_URL
:
"
about
:
devtools
-
toolbox
"
_prefs
:
{
LAST_TOOL
:
"
devtools
.
toolbox
.
selectedTool
"
}
get
nodePicker
(
)
{
if
(
!
this
.
_nodePicker
)
{
this
.
_nodePicker
=
new
NodePicker
(
this
.
commands
this
.
selection
)
;
this
.
_nodePicker
.
on
(
"
picker
-
starting
"
this
.
_onPickerStarting
)
;
this
.
_nodePicker
.
on
(
"
picker
-
started
"
this
.
_onPickerStarted
)
;
this
.
_nodePicker
.
on
(
"
picker
-
stopped
"
this
.
_onPickerStopped
)
;
this
.
_nodePicker
.
on
(
"
picker
-
node
-
canceled
"
this
.
_onPickerCanceled
)
;
this
.
_nodePicker
.
on
(
"
picker
-
node
-
picked
"
this
.
_onPickerPicked
)
;
this
.
_nodePicker
.
on
(
"
picker
-
node
-
previewed
"
this
.
_onPickerPreviewed
)
;
}
return
this
.
_nodePicker
;
}
get
store
(
)
{
if
(
!
this
.
_store
)
{
this
.
_store
=
createToolboxStore
(
)
;
}
return
this
.
_store
;
}
get
currentToolId
(
)
{
return
this
.
_currentToolId
;
}
set
currentToolId
(
id
)
{
this
.
_currentToolId
=
id
;
this
.
component
.
setCurrentToolId
(
id
)
;
}
get
defaultToolId
(
)
{
return
this
.
_defaultToolId
;
}
get
panelDefinitions
(
)
{
return
this
.
_panelDefinitions
;
}
set
panelDefinitions
(
definitions
)
{
this
.
_panelDefinitions
=
definitions
;
this
.
_combineAndSortPanelDefinitions
(
)
;
}
get
visibleAdditionalTools
(
)
{
if
(
!
this
.
_visibleAdditionalTools
)
{
this
.
_visibleAdditionalTools
=
[
]
;
}
return
this
.
_visibleAdditionalTools
;
}
set
visibleAdditionalTools
(
tools
)
{
this
.
_visibleAdditionalTools
=
tools
;
if
(
this
.
isReady
)
{
this
.
_combineAndSortPanelDefinitions
(
)
;
}
}
_combineAndSortPanelDefinitions
(
)
{
let
definitions
=
[
.
.
.
this
.
_panelDefinitions
.
.
.
this
.
getVisibleAdditionalTools
(
)
]
;
definitions
=
sortPanelDefinitions
(
definitions
)
;
this
.
component
.
setPanelDefinitions
(
definitions
)
;
}
lastUsedToolId
:
null
getToolPanels
(
)
{
return
new
Map
(
this
.
_toolPanels
)
;
}
getPanel
(
id
)
{
return
this
.
_toolPanels
.
get
(
id
)
;
}
getPanelWhenReady
(
id
)
{
const
panel
=
this
.
getPanel
(
id
)
;
return
new
Promise
(
resolve
=
>
{
if
(
panel
)
{
resolve
(
panel
)
;
}
else
{
this
.
on
(
id
+
"
-
ready
"
initializedPanel
=
>
{
resolve
(
initializedPanel
)
;
}
)
;
}
}
)
;
}
getCurrentPanel
(
)
{
return
this
.
_toolPanels
.
get
(
this
.
currentToolId
)
;
}
get
target
(
)
{
return
this
.
commands
.
targetCommand
.
targetFront
;
}
get
threadFront
(
)
{
return
this
.
commands
.
targetCommand
.
targetFront
.
threadFront
;
}
get
hostType
(
)
{
return
this
.
_hostType
;
}
get
win
(
)
{
return
this
.
_win
;
}
get
topWindow
(
)
{
return
DevToolsUtils
.
getTopWindow
(
this
.
win
)
;
}
get
topDoc
(
)
{
return
this
.
topWindow
.
document
;
}
get
doc
(
)
{
return
this
.
win
.
document
;
}
get
splitConsole
(
)
{
return
this
.
_splitConsole
;
}
isSplitConsoleFocused
(
)
{
if
(
!
this
.
_splitConsole
)
{
return
false
;
}
const
focusedWin
=
Services
.
focus
.
focusedWindow
;
return
(
focusedWin
&
&
focusedWin
=
=
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
iframe
-
webconsole
"
)
.
contentWindow
)
;
}
isSplitConsoleEnabled
(
)
{
if
(
typeof
this
.
_splitConsoleEnabled
!
=
=
"
boolean
"
)
{
this
.
updateIsSplitConsoleEnabled
(
)
;
}
return
this
.
_splitConsoleEnabled
;
}
get
isBrowserToolbox
(
)
{
return
this
.
hostType
=
=
=
Toolbox
.
HostType
.
BROWSERTOOLBOX
;
}
get
isMultiProcessBrowserToolbox
(
)
{
return
this
.
isBrowserToolbox
;
}
selectTarget
(
targetActorID
)
{
if
(
this
.
getSelectedTargetFront
(
)
?
.
actorID
!
=
=
targetActorID
)
{
this
.
commands
.
targetCommand
.
store
.
dispatch
(
selectTarget
(
targetActorID
)
)
;
}
}
getSelectedTargetFront
(
)
{
const
selectedTarget
=
getSelectedTarget
(
this
.
commands
.
targetCommand
.
store
.
getState
(
)
)
;
if
(
!
selectedTarget
)
{
return
null
;
}
return
this
.
commands
.
client
.
getFrontByID
(
selectedTarget
.
actorID
)
;
}
_onTargetCommandStateChange
(
state
oldState
)
{
if
(
getSelectedTarget
(
state
)
!
=
=
getSelectedTarget
(
oldState
)
)
{
const
dbg
=
this
.
getPanel
(
"
jsdebugger
"
)
;
if
(
!
dbg
)
{
return
;
}
const
threadActorID
=
getSelectedTarget
(
state
)
?
.
threadFront
?
.
actorID
;
if
(
!
threadActorID
)
{
return
;
}
dbg
.
selectThread
(
threadActorID
)
;
}
}
_onThreadStateChanged
(
resource
)
{
if
(
resource
.
state
=
=
"
paused
"
)
{
this
.
_onTargetPaused
(
resource
.
targetFront
resource
.
why
.
type
)
;
}
else
if
(
resource
.
state
=
=
"
resumed
"
)
{
this
.
_onTargetResumed
(
resource
.
targetFront
)
;
}
}
async
onTracerToggled
(
)
{
const
{
tracerCommand
}
=
this
.
commands
;
if
(
!
tracerCommand
.
isTracingEnabled
)
{
return
;
}
const
{
logMethod
}
=
this
.
commands
.
tracerCommand
.
getTracingOptions
(
)
;
if
(
logMethod
=
=
TRACER_LOG_METHODS
.
CONSOLE
&
&
this
.
currentToolId
!
=
=
"
webconsole
"
)
{
await
this
.
openSplitConsole
(
{
focusConsoleInput
:
false
}
)
;
}
else
if
(
logMethod
=
=
TRACER_LOG_METHODS
.
DEBUGGER_SIDEBAR
)
{
const
panel
=
await
this
.
selectTool
(
"
jsdebugger
"
)
;
panel
.
showTracerSidebar
(
)
;
}
}
async
_onTracingStateChanged
(
resource
)
{
const
{
profile
}
=
resource
;
if
(
!
profile
)
{
return
;
}
const
browser
=
await
openProfilerTab
(
{
defaultPanel
:
"
stack
-
chart
"
}
)
;
const
profileCaptureResult
=
{
type
:
"
SUCCESS
"
profile
}
;
ProfilerBackground
.
registerProfileCaptureForBrowser
(
browser
profileCaptureResult
null
)
;
}
_onTargetPaused
(
targetFront
reason
)
{
if
(
reason
=
=
=
"
interrupted
"
)
{
return
;
}
this
.
highlightTool
(
"
jsdebugger
"
)
;
if
(
reason
=
=
=
"
debuggerStatement
"
|
|
reason
=
=
=
"
mutationBreakpoint
"
|
|
reason
=
=
=
"
eventBreakpoint
"
|
|
reason
=
=
=
"
breakpoint
"
|
|
reason
=
=
=
"
exception
"
|
|
reason
=
=
=
"
resumeLimit
"
|
|
reason
=
=
=
"
XHR
"
|
|
reason
=
=
=
"
breakpointConditionThrown
"
)
{
this
.
raise
(
)
;
this
.
selectTool
(
"
jsdebugger
"
reason
)
;
this
.
_pausedTargets
.
add
(
targetFront
)
;
this
.
emit
(
"
toolbox
-
paused
"
)
;
}
}
_onTargetResumed
(
targetFront
)
{
if
(
this
.
isHighlighted
(
"
jsdebugger
"
)
)
{
this
.
_pausedTargets
.
delete
(
targetFront
)
;
if
(
this
.
_pausedTargets
.
size
=
=
0
)
{
this
.
emit
(
"
toolbox
-
resumed
"
)
;
this
.
unhighlightTool
(
"
jsdebugger
"
)
;
}
}
}
async
_onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
{
if
(
targetFront
.
isTopLevel
)
{
if
(
!
targetFront
.
targetForm
.
ignoreSubFrames
)
{
targetFront
.
on
(
"
frame
-
update
"
this
.
_updateFrames
)
;
}
const
consoleFront
=
await
targetFront
.
getFront
(
"
console
"
)
;
consoleFront
.
on
(
"
inspectObject
"
this
.
_onInspectObject
)
;
}
targetFront
.
watchFronts
(
"
inspector
"
async
inspectorFront
=
>
{
registerWalkerListeners
(
this
.
store
inspectorFront
.
walker
)
;
}
)
;
if
(
targetFront
.
isTopLevel
&
&
isTargetSwitching
)
{
await
this
.
_listFrames
(
)
;
if
(
targetFront
.
isDestroyed
(
)
)
{
return
;
}
}
if
(
targetFront
.
targetForm
.
ignoreSubFrames
)
{
this
.
_updateFrames
(
{
frames
:
[
{
id
:
targetFront
.
actorID
targetFront
url
:
targetFront
.
url
title
:
targetFront
.
title
isTopLevel
:
targetFront
.
isTopLevel
}
]
}
)
;
}
if
(
targetFront
.
targetForm
.
isPopup
&
&
!
targetFront
.
isTopLevel
&
&
this
.
_descriptorFront
.
isLocalTab
)
{
await
this
.
switchHostToTab
(
targetFront
.
targetForm
.
browsingContextID
)
;
}
}
async
_onTargetSelected
(
{
targetFront
}
)
{
this
.
_updateFrames
(
{
selected
:
targetFront
.
actorID
}
)
;
this
.
selectTarget
(
targetFront
.
actorID
)
;
this
.
_refreshHostTitle
(
)
;
}
_onTargetDestroyed
(
{
targetFront
}
)
{
removeTarget
(
this
.
store
targetFront
)
;
if
(
targetFront
.
isTopLevel
)
{
const
consoleFront
=
targetFront
.
getCachedFront
(
"
console
"
)
;
if
(
consoleFront
)
{
consoleFront
.
off
(
"
inspectObject
"
this
.
_onInspectObject
)
;
}
targetFront
.
off
(
"
frame
-
update
"
this
.
_updateFrames
)
;
}
else
if
(
this
.
selection
)
{
this
.
selection
.
onTargetDestroyed
(
targetFront
)
;
}
if
(
targetFront
.
isTopLevel
|
|
this
.
_pausedTargets
.
has
(
targetFront
)
)
{
this
.
_onTargetResumed
(
targetFront
)
;
}
if
(
targetFront
.
targetForm
.
ignoreSubFrames
)
{
this
.
_updateFrames
(
{
frames
:
[
{
id
:
targetFront
.
persistedActorID
destroy
:
true
}
]
}
)
;
}
}
_onTargetThreadFrontResumeWrongOrder
(
)
{
const
box
=
this
.
getNotificationBox
(
)
;
box
.
appendNotification
(
L10N
.
getStr
(
"
toolbox
.
resumeOrderWarning
"
)
"
wrong
-
resume
-
order
"
"
"
box
.
PRIORITY_WARNING_HIGH
)
;
}
async
open
(
)
{
try
{
const
fluentL10n
=
new
FluentL10n
(
)
;
const
fluentInitPromise
=
fluentL10n
.
init
(
[
"
devtools
/
client
/
toolbox
.
ftl
"
]
)
;
const
isToolboxURL
=
this
.
win
.
location
.
href
.
startsWith
(
this
.
_URL
)
;
if
(
isToolboxURL
)
{
this
.
_URL
=
this
.
win
.
location
.
href
;
}
await
new
Promise
(
resolve
=
>
{
DOMHelpers
.
onceDOMReady
(
this
.
win
(
)
=
>
{
resolve
(
)
;
}
this
.
_URL
)
;
}
)
;
this
.
browserRequire
=
BrowserLoader
(
{
window
:
this
.
win
useOnlyShared
:
true
}
)
.
require
;
await
fluentInitPromise
;
this
.
_mountReactComponent
(
fluentL10n
.
getBundles
(
)
)
;
this
.
resourceCommand
=
this
.
commands
.
resourceCommand
;
this
.
commands
.
targetCommand
.
on
(
"
target
-
thread
-
wrong
-
order
-
on
-
resume
"
this
.
_onTargetThreadFrontResumeWrongOrder
.
bind
(
this
)
)
;
registerStoreObserver
(
this
.
commands
.
targetCommand
.
store
this
.
_onTargetCommandStateChange
.
bind
(
this
)
)
;
await
this
.
commands
.
targetCommand
.
startListening
(
)
;
await
this
.
_listenAndApplyConfigurationPref
(
)
;
await
this
.
commands
.
targetCommand
.
watchTargets
(
{
types
:
this
.
commands
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
_onTargetAvailable
onSelected
:
this
.
_onTargetSelected
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
const
watchedResources
=
[
this
.
resourceCommand
.
TYPES
.
CONSOLE_MESSAGE
this
.
resourceCommand
.
TYPES
.
ERROR_MESSAGE
this
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
this
.
resourceCommand
.
TYPES
.
THREAD_STATE
]
;
let
tracerInitialization
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
features
.
javascript
-
tracing
"
false
)
)
{
watchedResources
.
push
(
this
.
resourceCommand
.
TYPES
.
JSTRACER_STATE
)
;
tracerInitialization
=
this
.
commands
.
tracerCommand
.
initialize
(
)
;
this
.
onTracerToggled
=
this
.
onTracerToggled
.
bind
(
this
)
;
this
.
commands
.
tracerCommand
.
on
(
"
toggle
"
this
.
onTracerToggled
)
;
}
if
(
!
this
.
isBrowserToolbox
)
{
watchedResources
.
push
(
this
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
)
;
}
const
onResourcesWatched
=
this
.
resourceCommand
.
watchResources
(
watchedResources
{
onAvailable
:
this
.
_onResourceAvailable
onUpdated
:
this
.
_onResourceUpdated
}
)
;
this
.
isReady
=
true
;
const
framesPromise
=
this
.
_listFrames
(
)
;
Services
.
prefs
.
addObserver
(
BROWSERTOOLBOX_SCOPE_PREF
this
.
_refreshHostTitle
)
;
this
.
_buildDockOptions
(
)
;
this
.
_buildInitialPanelDefinitions
(
)
;
this
.
_setDebugTargetData
(
)
;
this
.
_addWindowListeners
(
)
;
this
.
_addChromeEventHandlerEvents
(
)
;
this
.
_tabBar
=
this
.
doc
.
querySelector
(
"
.
devtools
-
tabbar
"
)
;
this
.
_tabBar
.
addEventListener
(
"
keypress
"
this
.
_onToolbarArrowKeypress
)
;
this
.
_componentMount
.
setAttribute
(
"
aria
-
label
"
L10N
.
getStr
(
"
toolbox
.
label
"
)
)
;
this
.
webconsolePanel
=
this
.
doc
.
querySelector
(
"
#
toolbox
-
panel
-
webconsole
"
)
;
this
.
doc
.
getElementById
(
"
toolbox
-
console
-
splitter
"
)
.
addEventListener
(
"
command
"
this
.
_saveSplitConsoleHeight
)
;
this
.
_buildButtons
(
)
;
this
.
_pingTelemetry
(
)
;
const
toolDef
=
gDevTools
.
getToolDefinition
(
this
.
_defaultToolId
)
;
if
(
!
toolDef
|
|
!
toolDef
.
isToolSupported
(
this
)
)
{
this
.
_defaultToolId
=
"
webconsole
"
;
}
await
this
.
_setInitialMeatballState
(
)
;
this
.
win
.
requestIdleCallback
(
(
)
=
>
{
this
.
component
.
setCanRender
(
)
;
}
{
timeout
:
16
}
)
;
await
this
.
selectTool
(
this
.
_defaultToolId
"
initial_panel
"
)
;
let
splitConsolePromise
=
Promise
.
resolve
(
)
;
if
(
Services
.
prefs
.
getBoolPref
(
SPLITCONSOLE_OPEN_PREF
)
)
{
splitConsolePromise
=
this
.
openSplitConsole
(
)
;
this
.
telemetry
.
addEventProperty
(
this
.
topWindow
"
open
"
"
tools
"
null
"
splitconsole
"
true
)
;
}
else
{
this
.
telemetry
.
addEventProperty
(
this
.
topWindow
"
open
"
"
tools
"
null
"
splitconsole
"
false
)
;
}
await
Promise
.
all
(
[
splitConsolePromise
framesPromise
onResourcesWatched
tracerInitialization
]
)
;
if
(
this
.
hostType
!
=
=
Toolbox
.
HostType
.
PAGE
)
{
await
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
{
restoreFocus
:
true
}
)
;
}
await
this
.
initHarAutomation
(
)
;
this
.
emit
(
"
ready
"
)
;
this
.
_resolveIsOpen
(
)
;
}
catch
(
error
)
{
console
.
error
(
"
Exception
while
opening
the
toolbox
"
String
(
error
)
error
)
;
dump
(
error
.
stack
+
"
\
n
"
)
;
if
(
error
.
serverStack
)
{
dump
(
"
Server
stack
:
"
+
error
.
serverStack
+
"
\
n
"
)
;
}
if
(
this
.
_appBoundary
)
{
this
.
_appBoundary
.
setState
(
{
errorMsg
:
error
.
toString
(
)
errorStack
:
error
.
stack
errorInfo
:
{
serverStack
:
error
.
serverStack
}
toolbox
:
this
}
)
;
}
}
}
getChromeEventHandler
(
)
{
if
(
!
this
.
win
|
|
!
this
.
win
.
docShell
)
{
return
null
;
}
return
this
.
win
.
docShell
.
chromeEventHandler
;
}
_addChromeEventHandlerEvents
(
)
{
this
.
_chromeEventHandler
=
this
.
getChromeEventHandler
(
)
;
if
(
!
this
.
_chromeEventHandler
)
{
return
;
}
this
.
_addShortcuts
(
)
;
this
.
_addWindowHostShortcuts
(
)
;
this
.
_chromeEventHandler
.
addEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
)
;
this
.
_chromeEventHandler
.
addEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
_chromeEventHandler
.
addEventListener
(
"
blur
"
this
.
_onBlur
true
)
;
this
.
_chromeEventHandler
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
_chromeEventHandler
.
addEventListener
(
"
mousedown
"
this
.
_onMouseDown
)
;
}
_removeChromeEventHandlerEvents
(
)
{
if
(
!
this
.
_chromeEventHandler
)
{
return
;
}
this
.
_removeShortcuts
(
)
;
this
.
_removeWindowHostShortcuts
(
)
;
this
.
_chromeEventHandler
.
removeEventListener
(
"
keypress
"
this
.
_splitConsoleOnKeypress
)
;
this
.
_chromeEventHandler
.
removeEventListener
(
"
focus
"
this
.
_onFocus
true
)
;
this
.
_chromeEventHandler
.
removeEventListener
(
"
focus
"
this
.
_onBlur
true
)
;
this
.
_chromeEventHandler
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
)
;
this
.
_chromeEventHandler
.
removeEventListener
(
"
mousedown
"
this
.
_onMouseDown
)
;
this
.
_chromeEventHandler
=
null
;
}
_addShortcuts
(
)
{
if
(
!
this
.
shortcuts
)
{
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
doc
.
defaultView
target
:
this
.
getChromeEventHandler
(
)
}
)
;
}
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
showFrames
.
key
"
)
event
=
>
{
if
(
event
.
target
.
id
=
=
=
"
command
-
button
-
frames
"
)
{
event
.
target
.
click
(
)
;
}
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
nextTool
.
key
"
)
event
=
>
{
this
.
selectNextTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
previousTool
.
key
"
)
event
=
>
{
this
.
selectPreviousTool
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleHost
.
key
"
)
event
=
>
{
this
.
switchToPreviousHost
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
help
.
key
"
)
this
.
toggleOptions
)
;
if
(
!
this
.
isBrowserToolbox
)
{
[
[
"
reload
"
false
]
[
"
reload2
"
false
]
[
"
forceReload
"
true
]
[
"
forceReload2
"
true
]
]
.
forEach
(
(
[
id
bypassCache
]
)
=
>
{
const
key
=
L10N
.
getStr
(
"
toolbox
.
"
+
id
+
"
.
key
"
)
;
this
.
shortcuts
.
on
(
key
event
=
>
{
this
.
reload
(
bypassCache
)
;
event
.
preventDefault
(
)
;
}
)
;
}
)
;
}
if
(
this
.
hostType
!
=
Toolbox
.
HostType
.
PAGE
)
{
ZoomKeys
.
register
(
this
.
win
this
.
shortcuts
)
;
}
}
async
reload
(
bypassCache
)
{
const
box
=
this
.
getNotificationBox
(
)
;
const
notification
=
box
.
getNotificationWithValue
(
"
reload
-
error
"
)
;
if
(
notification
)
{
notification
.
close
(
)
;
}
const
consolePanel
=
this
.
getPanel
(
"
webconsole
"
)
;
if
(
consolePanel
)
{
consolePanel
.
hud
.
ui
.
handleWillNavigate
(
{
timeStamp
:
new
Date
(
)
url
:
null
}
)
;
}
const
netPanel
=
this
.
getPanel
(
"
netmonitor
"
)
;
if
(
netPanel
)
{
netPanel
.
panelWin
.
connector
.
willNavigate
(
)
;
}
try
{
await
this
.
commands
.
targetCommand
.
reloadTopLevelTarget
(
bypassCache
)
;
}
catch
(
e
)
{
let
{
message
}
=
e
;
message
=
message
.
replace
(
"
Protocol
error
(
SyntaxError
)
:
"
"
"
)
;
box
.
appendNotification
(
L10N
.
getFormatStr
(
"
toolbox
.
errorOnReload
"
message
)
"
reload
-
error
"
"
"
box
.
PRIORITY_CRITICAL_HIGH
)
;
}
}
_removeShortcuts
(
)
{
if
(
this
.
shortcuts
)
{
this
.
shortcuts
.
destroy
(
)
;
this
.
shortcuts
=
null
;
}
}
_addWindowHostShortcuts
(
)
{
if
(
this
.
hostType
!
=
Toolbox
.
HostType
.
WINDOW
)
{
return
;
}
if
(
!
this
.
_windowHostShortcuts
)
{
this
.
_windowHostShortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
win
target
:
this
.
getChromeEventHandler
(
)
}
)
;
}
const
shortcuts
=
this
.
_windowHostShortcuts
;
for
(
const
item
of
Startup
.
KeyShortcuts
)
{
const
{
id
toolId
shortcut
modifiers
}
=
item
;
const
electronKey
=
KeyShortcuts
.
parseXulKey
(
modifiers
shortcut
)
;
if
(
id
=
=
"
browserConsole
"
)
{
shortcuts
.
on
(
electronKey
(
)
=
>
{
BrowserConsoleManager
.
toggleBrowserConsole
(
)
;
}
)
;
}
else
if
(
toolId
)
{
shortcuts
.
on
(
electronKey
(
)
=
>
{
this
.
selectTool
(
toolId
"
key_shortcut
"
)
.
then
(
(
)
=
>
this
.
fireCustomKey
(
toolId
)
)
;
}
)
;
}
}
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
closeToolbox
.
key
"
)
this
.
closeToolbox
)
;
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleToolboxF12
.
key
"
)
this
.
closeToolbox
)
;
if
(
lazy
.
AppConstants
.
platform
=
=
"
macosx
"
)
{
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleToolboxOSX
.
key
"
)
this
.
closeToolbox
)
;
}
else
{
shortcuts
.
on
(
L10N
.
getStr
(
"
toolbox
.
toggleToolbox
.
key
"
)
this
.
closeToolbox
)
;
}
}
_removeWindowHostShortcuts
(
)
{
if
(
this
.
_windowHostShortcuts
)
{
this
.
_windowHostShortcuts
.
destroy
(
)
;
this
.
_windowHostShortcuts
=
null
;
}
}
_onContextMenu
(
e
)
{
const
isInInput
=
e
.
originalTarget
.
closest
(
"
input
[
type
=
text
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
[
type
=
search
]
"
)
|
|
e
.
originalTarget
.
closest
(
"
input
:
not
(
[
type
]
)
"
)
|
|
e
.
originalTarget
.
closest
(
"
.
devtools
-
input
"
)
|
|
e
.
originalTarget
.
closest
(
"
textarea
"
)
;
const
doc
=
e
.
originalTarget
.
ownerDocument
;
const
isHTMLPanel
=
doc
.
documentElement
.
namespaceURI
=
=
=
HTML_NS
;
if
(
isInInput
|
|
isHTMLPanel
)
{
e
.
stopPropagation
(
)
;
e
.
preventDefault
(
)
;
}
if
(
isInInput
)
{
this
.
openTextBoxContextMenu
(
e
.
screenX
e
.
screenY
)
;
}
}
_onMouseDown
(
e
)
{
const
isMiddleClick
=
e
.
button
=
=
=
1
;
if
(
isMiddleClick
)
{
e
.
preventDefault
(
)
;
}
}
_getDebugTargetData
(
)
{
const
url
=
new
URL
(
this
.
win
.
location
)
;
const
remoteId
=
url
.
searchParams
.
get
(
"
remoteId
"
)
;
const
runtimeInfo
=
remoteClientManager
.
getRuntimeInfoByRemoteId
(
remoteId
)
;
const
connectionType
=
remoteClientManager
.
getConnectionTypeByRemoteId
(
remoteId
)
;
return
{
connectionType
runtimeInfo
descriptorType
:
this
.
_descriptorFront
.
descriptorType
descriptorName
:
this
.
_descriptorFront
.
name
}
;
}
isDebugTargetFenix
(
)
{
return
this
.
_getDebugTargetData
(
)
?
.
runtimeInfo
?
.
isFenix
;
}
get
React
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
}
get
ReactDOM
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
}
get
ReactRedux
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
}
get
ToolboxController
(
)
{
return
this
.
browserRequire
(
"
devtools
/
client
/
framework
/
components
/
ToolboxController
"
)
;
}
get
AppErrorBoundary
(
)
{
return
this
.
browserRequire
(
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
AppErrorBoundary
.
js
"
)
;
}
get
sourceMapLoader
(
)
{
if
(
this
.
_sourceMapLoader
)
{
return
this
.
_sourceMapLoader
;
}
this
.
_sourceMapLoader
=
new
SourceMapLoader
(
this
.
commands
.
targetCommand
)
;
return
this
.
_sourceMapLoader
;
}
get
parserWorker
(
)
{
if
(
this
.
_parserWorker
)
{
return
this
.
_parserWorker
;
}
const
{
ParserDispatcher
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
debugger
/
src
/
workers
/
parser
/
index
.
js
"
)
;
this
.
_parserWorker
=
new
ParserDispatcher
(
)
;
return
this
.
_parserWorker
;
}
get
sourceMapURLService
(
)
{
if
(
this
.
_sourceMapURLService
)
{
return
this
.
_sourceMapURLService
;
}
this
.
_sourceMapURLService
=
new
SourceMapURLService
(
this
.
commands
this
.
sourceMapLoader
)
;
return
this
.
_sourceMapURLService
;
}
_getTelemetryHostId
(
)
{
switch
(
this
.
hostType
)
{
case
Toolbox
.
HostType
.
BOTTOM
:
return
0
;
case
Toolbox
.
HostType
.
RIGHT
:
return
1
;
case
Toolbox
.
HostType
.
WINDOW
:
return
2
;
case
Toolbox
.
HostType
.
BROWSERTOOLBOX
:
return
3
;
case
Toolbox
.
HostType
.
LEFT
:
return
4
;
case
Toolbox
.
HostType
.
PAGE
:
return
5
;
default
:
return
9
;
}
}
_getTelemetryHostString
(
)
{
switch
(
this
.
hostType
)
{
case
Toolbox
.
HostType
.
BOTTOM
:
return
"
bottom
"
;
case
Toolbox
.
HostType
.
LEFT
:
return
"
left
"
;
case
Toolbox
.
HostType
.
RIGHT
:
return
"
right
"
;
case
Toolbox
.
HostType
.
WINDOW
:
return
"
window
"
;
case
Toolbox
.
HostType
.
PAGE
:
return
"
page
"
;
case
Toolbox
.
HostType
.
BROWSERTOOLBOX
:
return
"
other
"
;
default
:
return
"
bottom
"
;
}
}
_pingTelemetry
(
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
everOpened
"
true
)
;
this
.
telemetry
.
toolOpened
(
"
toolbox
"
this
)
;
this
.
telemetry
.
getHistogramById
(
HOST_HISTOGRAM
)
.
add
(
this
.
_getTelemetryHostId
(
)
)
;
const
currentTheme
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
Glean
.
devtools
.
currentTheme
[
currentTheme
]
.
add
(
1
)
;
const
browserWin
=
this
.
topWindow
;
this
.
telemetry
.
preparePendingEvent
(
browserWin
"
open
"
"
tools
"
null
[
"
entrypoint
"
"
first_panel
"
"
host
"
"
shortcut
"
"
splitconsole
"
"
width
"
]
)
;
this
.
telemetry
.
addEventProperty
(
browserWin
"
open
"
"
tools
"
null
"
host
"
this
.
_getTelemetryHostString
(
)
)
;
}
_createButtonState
(
options
)
{
let
isCheckedValue
=
false
;
const
{
id
className
description
disabled
onClick
isInStartContainer
setup
teardown
isToolSupported
isCurrentlyVisible
isChecked
isToggle
onKeyDown
experimentalURL
}
=
options
;
const
toolbox
=
this
;
const
button
=
{
id
className
description
disabled
async
onClick
(
event
)
{
if
(
typeof
onClick
=
=
"
function
"
)
{
await
onClick
(
event
toolbox
)
;
button
.
emit
(
"
updatechecked
"
)
;
}
}
onKeyDown
(
event
)
{
if
(
typeof
onKeyDown
=
=
"
function
"
)
{
onKeyDown
(
event
toolbox
)
;
}
}
isToolSupported
isCurrentlyVisible
get
isChecked
(
)
{
if
(
typeof
isChecked
=
=
"
function
"
)
{
return
isChecked
(
toolbox
)
;
}
return
isCheckedValue
;
}
set
isChecked
(
value
)
{
isCheckedValue
=
value
;
this
.
emit
(
"
updatechecked
"
)
;
}
isToggle
visibilityswitch
:
devtools
.
{
id
}
.
enabled
isInStartContainer
:
!
!
isInStartContainer
experimentalURL
getContextMenu
(
)
{
if
(
options
.
getContextMenu
)
{
return
options
.
getContextMenu
(
toolbox
)
;
}
return
null
;
}
}
;
if
(
typeof
setup
=
=
"
function
"
)
{
const
onChange
=
async
(
)
=
>
{
button
.
emit
(
"
updatechecked
"
)
;
}
;
setup
(
this
onChange
)
;
button
.
teardown
=
teardown
.
bind
(
options
this
onChange
)
;
}
button
.
isVisible
=
this
.
_commandIsVisible
(
button
)
;
EventEmitter
.
decorate
(
button
)
;
return
button
;
}
_splitConsoleOnKeypress
(
e
)
{
if
(
e
.
keyCode
!
=
=
KeyCodes
.
DOM_VK_ESCAPE
|
|
!
this
.
isSplitConsoleEnabled
(
)
)
{
return
;
}
const
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
typeof
currentPanel
.
onToolboxChromeEventHandlerEscapeKeyDown
=
=
=
"
function
"
)
{
const
ac
=
new
this
.
win
.
AbortController
(
)
;
currentPanel
.
onToolboxChromeEventHandlerEscapeKeyDown
(
ac
)
;
if
(
ac
.
signal
.
aborted
)
{
return
;
}
}
this
.
toggleSplitConsole
(
)
;
if
(
this
.
threadFront
.
state
=
=
"
paused
"
|
|
this
.
hostType
=
=
=
Toolbox
.
HostType
.
PAGE
)
{
e
.
preventDefault
(
)
;
}
}
useKeyWithSplitConsole
(
key
handler
whichTool
)
{
this
.
shortcuts
.
on
(
key
event
=
>
{
if
(
this
.
currentToolId
=
=
=
whichTool
&
&
this
.
isSplitConsoleFocused
(
)
)
{
handler
(
)
;
event
.
preventDefault
(
)
;
}
}
)
;
}
_addWindowListeners
(
)
{
this
.
win
.
addEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
addEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
_removeWindowListeners
(
)
{
if
(
this
.
win
)
{
this
.
win
.
removeEventListener
(
"
unload
"
this
.
destroy
)
;
this
.
win
.
removeEventListener
(
"
message
"
this
.
_onBrowserMessage
true
)
;
}
}
_onBrowserMessage
(
event
)
{
if
(
event
.
data
?
.
name
=
=
=
"
switched
-
host
"
)
{
this
.
_onSwitchedHost
(
event
.
data
)
;
}
if
(
event
.
data
?
.
name
=
=
=
"
switched
-
host
-
to
-
tab
"
)
{
this
.
_onSwitchedHostToTab
(
event
.
data
.
browsingContextID
)
;
}
if
(
event
.
data
?
.
name
=
=
=
"
host
-
raised
"
)
{
this
.
emit
(
"
host
-
raised
"
)
;
}
}
_saveSplitConsoleHeight
(
)
{
const
height
=
parseInt
(
this
.
webconsolePanel
.
style
.
height
10
)
;
if
(
!
isNaN
(
height
)
)
{
Services
.
prefs
.
setIntPref
(
SPLITCONSOLE_HEIGHT_PREF
height
)
;
}
}
_refreshConsoleDisplay
(
)
{
const
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
const
webconsolePanel
=
this
.
webconsolePanel
;
const
splitter
=
this
.
doc
.
getElementById
(
"
toolbox
-
console
-
splitter
"
)
;
const
openedConsolePanel
=
this
.
currentToolId
=
=
=
"
webconsole
"
;
if
(
openedConsolePanel
)
{
deck
.
setAttribute
(
"
hidden
"
"
"
)
;
deck
.
removeAttribute
(
"
expanded
"
)
;
splitter
.
hidden
=
true
;
webconsolePanel
.
removeAttribute
(
"
hidden
"
)
;
webconsolePanel
.
setAttribute
(
"
expanded
"
"
"
)
;
}
else
{
deck
.
removeAttribute
(
"
hidden
"
)
;
deck
.
toggleAttribute
(
"
expanded
"
!
this
.
splitConsole
)
;
splitter
.
hidden
=
!
this
.
splitConsole
;
webconsolePanel
.
collapsed
=
!
this
.
splitConsole
;
webconsolePanel
.
removeAttribute
(
"
expanded
"
)
;
}
this
.
webconsolePanel
.
style
.
height
=
openedConsolePanel
?
"
"
:
Services
.
prefs
.
getIntPref
(
SPLITCONSOLE_HEIGHT_PREF
)
+
"
px
"
;
}
fireCustomKey
(
toolId
)
{
const
toolDefinition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
if
(
toolDefinition
.
onkey
&
&
(
this
.
currentToolId
=
=
=
toolId
|
|
(
toolId
=
=
"
webconsole
"
&
&
this
.
splitConsole
)
)
)
{
toolDefinition
.
onkey
(
this
.
getCurrentPanel
(
)
this
)
;
}
}
get
notificationBox
(
)
{
if
(
!
this
.
_notificationBox
)
{
let
{
NotificationBox
PriorityLevels
}
=
this
.
browserRequire
(
"
devtools
/
client
/
shared
/
components
/
NotificationBox
"
)
;
NotificationBox
=
this
.
React
.
createFactory
(
NotificationBox
)
;
const
box
=
this
.
doc
.
getElementById
(
"
toolbox
-
notificationbox
"
)
;
this
.
_notificationBox
=
Object
.
assign
(
this
.
ReactDOM
.
render
(
NotificationBox
(
{
wrapping
:
true
}
)
box
)
PriorityLevels
)
;
}
return
this
.
_notificationBox
;
}
_buildDockOptions
(
)
{
if
(
!
this
.
_descriptorFront
.
isLocalTab
)
{
this
.
component
.
setDockOptionsEnabled
(
false
)
;
this
.
component
.
setCanCloseToolbox
(
false
)
;
return
;
}
this
.
component
.
setDockOptionsEnabled
(
true
)
;
this
.
component
.
setCanCloseToolbox
(
this
.
hostType
!
=
=
Toolbox
.
HostType
.
WINDOW
)
;
const
hostTypes
=
[
]
;
for
(
const
type
in
Toolbox
.
HostType
)
{
const
position
=
Toolbox
.
HostType
[
type
]
;
if
(
position
=
=
Toolbox
.
HostType
.
BROWSERTOOLBOX
|
|
position
=
=
Toolbox
.
HostType
.
PAGE
)
{
continue
;
}
hostTypes
.
push
(
{
position
switchHost
:
this
.
switchHost
.
bind
(
this
position
)
}
)
;
}
this
.
component
.
setCurrentHostType
(
this
.
hostType
)
;
this
.
component
.
setHostTypes
(
hostTypes
)
;
}
postMessage
(
msg
)
{
if
(
!
this
.
_destroyer
)
{
msg
.
frameId
=
this
.
frameId
;
this
.
topWindow
.
postMessage
(
msg
"
*
"
)
;
}
}
async
_buildInitialPanelDefinitions
(
)
{
const
definitions
=
gDevTools
.
getToolDefinitionArray
(
)
;
definitions
.
forEach
(
definition
=
>
this
.
_buildPanelForTool
(
definition
)
)
;
this
.
panelDefinitions
=
definitions
.
filter
(
definition
=
>
definition
.
isToolSupported
(
this
)
&
&
definition
.
id
!
=
=
"
options
"
)
;
}
async
_setInitialMeatballState
(
)
{
let
disableAutohide
pseudoLocale
;
if
(
this
.
isBrowserToolbox
|
|
this
.
_descriptorFront
.
isWebExtensionDescriptor
)
{
disableAutohide
=
await
this
.
_isDisableAutohideEnabled
(
)
;
}
if
(
this
.
isBrowserToolbox
)
{
pseudoLocale
=
await
this
.
getPseudoLocale
(
)
;
}
if
(
typeof
disableAutohide
=
=
"
boolean
"
)
{
this
.
component
.
setDisableAutohide
(
disableAutohide
)
;
}
if
(
typeof
pseudoLocale
=
=
"
string
"
)
{
this
.
component
.
setPseudoLocale
(
pseudoLocale
)
;
}
if
(
this
.
_descriptorFront
.
isWebExtensionDescriptor
&
&
this
.
hostType
=
=
=
Toolbox
.
HostType
.
WINDOW
)
{
const
alwaysOnTop
=
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ALWAYS_ON_TOP
false
)
;
this
.
component
.
setAlwaysOnTop
(
alwaysOnTop
)
;
}
}
_mountReactComponent
(
fluentBundles
)
{
const
element
=
this
.
React
.
createElement
(
this
.
AppErrorBoundary
{
componentName
:
"
General
"
panel
:
L10N
.
getStr
(
"
webDeveloperToolsMenu
.
label
"
)
}
this
.
React
.
createElement
(
this
.
ToolboxController
{
ref
:
r
=
>
{
this
.
component
=
r
;
}
L10N
fluentBundles
currentToolId
:
this
.
currentToolId
selectTool
:
this
.
selectTool
toggleOptions
:
this
.
toggleOptions
toggleSplitConsole
:
this
.
toggleSplitConsole
toggleNoAutohide
:
this
.
toggleNoAutohide
toggleAlwaysOnTop
:
this
.
toggleAlwaysOnTop
disablePseudoLocale
:
this
.
disablePseudoLocale
enableAccentedPseudoLocale
:
this
.
enableAccentedPseudoLocale
enableBidiPseudoLocale
:
this
.
enableBidiPseudoLocale
closeToolbox
:
this
.
closeToolbox
focusButton
:
this
.
_onToolbarFocus
toolbox
:
this
onTabsOrderUpdated
:
this
.
_onTabsOrderUpdated
}
)
)
;
this
.
_componentMount
=
this
.
doc
.
getElementById
(
"
toolbox
-
toolbar
-
mount
"
)
;
this
.
_appBoundary
=
this
.
ReactDOM
.
render
(
element
this
.
_componentMount
)
;
}
_onToolbarFocus
(
id
)
{
this
.
component
.
setFocusedButton
(
id
)
;
}
_onToolbarArrowKeypress
(
event
)
{
const
{
key
target
ctrlKey
shiftKey
altKey
metaKey
}
=
event
;
if
(
ctrlKey
|
|
shiftKey
|
|
altKey
|
|
metaKey
)
{
return
;
}
const
buttons
=
[
.
.
.
this
.
_tabBar
.
querySelectorAll
(
"
button
"
)
]
;
const
curIndex
=
buttons
.
indexOf
(
target
)
;
if
(
curIndex
=
=
=
-
1
)
{
console
.
warn
(
target
+
"
is
not
found
among
Developer
Tools
tab
bar
"
+
"
focusable
elements
.
"
)
;
return
;
}
let
newTarget
;
const
firstTabIndex
=
0
;
const
lastTabIndex
=
buttons
.
length
-
1
;
const
nextOrLastTabIndex
=
Math
.
min
(
lastTabIndex
curIndex
+
1
)
;
const
previousOrFirstTabIndex
=
Math
.
max
(
firstTabIndex
curIndex
-
1
)
;
const
ltr
=
this
.
direction
=
=
=
"
ltr
"
;
if
(
key
=
=
=
"
ArrowLeft
"
)
{
if
(
(
ltr
&
&
curIndex
=
=
=
firstTabIndex
)
|
|
(
!
ltr
&
&
curIndex
=
=
=
lastTabIndex
)
)
{
return
;
}
newTarget
=
buttons
[
ltr
?
previousOrFirstTabIndex
:
nextOrLastTabIndex
]
;
}
else
if
(
key
=
=
=
"
ArrowRight
"
)
{
if
(
(
ltr
&
&
curIndex
=
=
=
lastTabIndex
)
|
|
(
!
ltr
&
&
curIndex
=
=
=
firstTabIndex
)
)
{
return
;
}
newTarget
=
buttons
[
ltr
?
nextOrLastTabIndex
:
previousOrFirstTabIndex
]
;
}
else
{
return
;
}
newTarget
.
focus
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
_buildButtons
(
)
{
this
.
toolbarButtons
=
[
this
.
_buildErrorCountButton
(
)
this
.
_buildPickerButton
(
)
this
.
_buildFrameButton
(
)
]
;
ToolboxButtons
.
forEach
(
definition
=
>
{
const
button
=
this
.
_createButtonState
(
definition
)
;
this
.
toolbarButtons
.
push
(
button
)
;
}
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
_buildFrameButton
(
)
{
this
.
frameButton
=
this
.
_createButtonState
(
{
id
:
"
command
-
button
-
frames
"
description
:
L10N
.
getStr
(
"
toolbox
.
frames
.
tooltip
"
)
isToolSupported
:
toolbox
=
>
{
return
toolbox
.
target
.
getTrait
(
"
frames
"
)
;
}
isCurrentlyVisible
:
(
)
=
>
{
const
hasFrames
=
this
.
frameMap
.
size
>
1
;
const
isOnOptionsPanel
=
this
.
currentToolId
=
=
=
"
options
"
;
return
hasFrames
|
|
isOnOptionsPanel
;
}
}
)
;
return
this
.
frameButton
;
}
_buildErrorCountButton
(
)
{
this
.
errorCountButton
=
this
.
_createButtonState
(
{
id
:
"
command
-
button
-
errorcount
"
isInStartContainer
:
false
isToolSupported
:
(
)
=
>
true
description
:
L10N
.
getStr
(
"
toolbox
.
errorCountButton
.
description
"
)
}
)
;
this
.
updateErrorCountButton
(
)
;
return
this
.
errorCountButton
;
}
async
_onPickerClick
(
)
{
const
focus
=
this
.
hostType
=
=
=
Toolbox
.
HostType
.
BOTTOM
|
|
this
.
hostType
=
=
=
Toolbox
.
HostType
.
LEFT
|
|
this
.
hostType
=
=
=
Toolbox
.
HostType
.
RIGHT
;
const
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
.
togglePicker
)
{
currentPanel
.
togglePicker
(
focus
)
;
}
else
{
this
.
nodePicker
.
togglePicker
(
focus
)
;
}
}
_onPickerKeypress
(
event
)
{
if
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_ESCAPE
)
{
const
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
.
cancelPicker
)
{
currentPanel
.
cancelPicker
(
)
;
}
else
{
this
.
nodePicker
.
stop
(
{
canceled
:
true
}
)
;
}
event
.
stopImmediatePropagation
(
)
;
}
}
async
_onPickerStarting
(
)
{
if
(
this
.
isDestroying
(
)
)
{
return
;
}
this
.
tellRDMAboutPickerState
(
true
PICKER_TYPES
.
ELEMENT
)
;
this
.
pickerButton
.
isChecked
=
true
;
await
this
.
selectTool
(
"
inspector
"
"
inspect_dom
"
)
;
this
.
getPanel
(
"
inspector
"
)
.
hideEyeDropper
(
)
;
this
.
on
(
"
select
"
this
.
_onToolSelectedStopPicker
)
;
}
async
_onPickerStarted
(
)
{
this
.
doc
.
addEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
}
_onPickerStopped
(
)
{
if
(
this
.
isDestroying
(
)
)
{
return
;
}
this
.
tellRDMAboutPickerState
(
false
PICKER_TYPES
.
ELEMENT
)
;
this
.
off
(
"
select
"
this
.
_onToolSelectedStopPicker
)
;
this
.
doc
.
removeEventListener
(
"
keypress
"
this
.
_onPickerKeypress
true
)
;
this
.
pickerButton
.
isChecked
=
false
;
}
_onToolSelectedStopPicker
(
)
{
this
.
nodePicker
.
stop
(
{
canceled
:
true
}
)
;
}
_onPickerCanceled
(
)
{
if
(
this
.
hostType
!
=
=
Toolbox
.
HostType
.
WINDOW
)
{
this
.
win
.
focus
(
)
;
}
}
_onPickerPicked
(
nodeFront
)
{
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
"
picker
-
node
-
picked
"
}
)
;
}
_onPickerPreviewed
(
nodeFront
)
{
this
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
"
picker
-
node
-
previewed
"
}
)
;
}
async
tellRDMAboutPickerState
(
state
pickerType
)
{
const
{
localTab
}
=
this
.
target
;
if
(
!
ResponsiveUIManager
.
isActiveForTab
(
localTab
)
)
{
return
;
}
const
ui
=
ResponsiveUIManager
.
getResponsiveUIForTab
(
localTab
)
;
await
ui
.
responsiveFront
.
setElementPickerState
(
state
pickerType
)
;
}
_buildPickerButton
(
)
{
this
.
pickerButton
=
this
.
_createButtonState
(
{
id
:
"
command
-
button
-
pick
"
className
:
this
.
_getPickerAdditionalClassName
(
)
description
:
this
.
_getPickerTooltip
(
)
onClick
:
this
.
_onPickerClick
isInStartContainer
:
true
isToolSupported
:
toolbox
=
>
{
return
toolbox
.
target
.
getTrait
(
"
frames
"
)
;
}
isToggle
:
true
}
)
;
return
this
.
pickerButton
;
}
_getPickerAdditionalClassName
(
)
{
if
(
this
.
isDebugTargetFenix
(
)
)
{
return
"
remote
-
fenix
"
;
}
return
null
;
}
_getPickerTooltip
(
)
{
let
shortcut
=
L10N
.
getStr
(
"
toolbox
.
elementPicker
.
key
"
)
;
shortcut
=
KeyShortcuts
.
parseElectronKey
(
shortcut
)
;
shortcut
=
KeyShortcuts
.
stringify
(
shortcut
)
;
const
shortcutMac
=
L10N
.
getStr
(
"
toolbox
.
elementPicker
.
mac
.
key
"
)
;
const
isMac
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
let
label
;
if
(
this
.
isDebugTargetFenix
(
)
)
{
label
=
isMac
?
"
toolbox
.
androidElementPicker
.
mac
.
tooltip
"
:
"
toolbox
.
androidElementPicker
.
tooltip
"
;
}
else
{
label
=
isMac
?
"
toolbox
.
elementPicker
.
mac
.
tooltip
"
:
"
toolbox
.
elementPicker
.
tooltip
"
;
}
return
isMac
?
L10N
.
getFormatStr
(
label
shortcut
shortcutMac
)
:
L10N
.
getFormatStr
(
label
shortcut
)
;
}
async
_listenAndApplyConfigurationPref
(
)
{
this
.
_onBooleanConfigurationPrefChange
=
this
.
_onBooleanConfigurationPrefChange
.
bind
(
this
)
;
const
targetConfiguration
=
{
}
;
const
threadConfiguration
=
await
getThreadOptions
(
)
;
for
(
const
prefName
in
BOOLEAN_CONFIGURATION_PREFS
)
{
const
{
name
thread
}
=
BOOLEAN_CONFIGURATION_PREFS
[
prefName
]
;
const
value
=
Services
.
prefs
.
getBoolPref
(
prefName
false
)
;
if
(
thread
)
{
threadConfiguration
[
name
]
=
value
;
}
else
{
targetConfiguration
[
name
]
=
value
;
}
Services
.
prefs
.
addObserver
(
prefName
this
.
_onBooleanConfigurationPrefChange
)
;
}
await
this
.
commands
.
targetConfigurationCommand
.
updateConfiguration
(
targetConfiguration
)
;
await
this
.
commands
.
threadConfigurationCommand
.
updateConfiguration
(
threadConfiguration
)
;
}
async
_onBooleanConfigurationPrefChange
(
subject
topic
prefName
)
{
const
{
name
thread
}
=
BOOLEAN_CONFIGURATION_PREFS
[
prefName
]
;
const
value
=
Services
.
prefs
.
getBoolPref
(
prefName
false
)
;
const
configurationCommand
=
thread
?
this
.
commands
.
threadConfigurationCommand
:
this
.
commands
.
targetConfigurationCommand
;
await
configurationCommand
.
updateConfiguration
(
{
[
name
]
:
value
}
)
;
this
.
emitForTests
(
"
new
-
configuration
-
applied
"
prefName
)
;
}
updateToolboxButtonsVisibility
(
)
{
this
.
toolbarButtons
.
forEach
(
button
=
>
{
button
.
isVisible
=
this
.
_commandIsVisible
(
button
)
;
}
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
updateToolboxButtons
(
)
{
const
inspectorFront
=
this
.
target
.
getCachedFront
(
"
inspector
"
)
;
const
hasHighlighters
=
inspectorFront
&
&
(
inspectorFront
.
hasHighlighter
(
lazy
.
TYPES
.
RULERS
)
|
|
inspectorFront
.
hasHighlighter
(
lazy
.
TYPES
.
MEASURING
)
)
;
if
(
hasHighlighters
)
{
inspectorFront
.
destroyHighlighters
(
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
}
updatePickerButton
(
)
{
const
button
=
this
.
pickerButton
;
const
currentPanel
=
this
.
getCurrentPanel
(
)
;
if
(
currentPanel
?
.
updatePickerButton
)
{
currentPanel
.
updatePickerButton
(
)
;
}
else
{
button
.
description
=
this
.
_getPickerTooltip
(
)
;
button
.
className
=
this
.
_getPickerAdditionalClassName
(
)
;
button
.
disabled
=
null
;
}
}
updateFrameButton
(
)
{
if
(
this
.
isDestroying
(
)
)
{
return
;
}
if
(
this
.
currentToolId
=
=
=
"
options
"
&
&
this
.
frameMap
.
size
<
=
1
)
{
this
.
frameButton
.
disabled
=
true
;
this
.
frameButton
.
description
=
L10N
.
getStr
(
"
toolbox
.
frames
.
disabled
.
tooltip
"
)
;
}
else
{
this
.
frameButton
.
disabled
=
false
;
this
.
frameButton
.
description
=
L10N
.
getStr
(
"
toolbox
.
frames
.
tooltip
"
)
;
}
const
selectedFrame
=
this
.
frameMap
.
get
(
this
.
selectedFrameId
)
|
|
{
}
;
const
isVisible
=
!
this
.
frameButton
.
isCurrentlyVisible
(
)
?
false
:
this
.
_commandIsVisible
(
this
.
frameButton
)
;
this
.
frameButton
.
isVisible
=
isVisible
;
if
(
isVisible
)
{
this
.
frameButton
.
isChecked
=
!
selectedFrame
.
isTopLevel
;
}
}
updateErrorCountButton
(
)
{
this
.
errorCountButton
.
isVisible
=
this
.
_commandIsVisible
(
this
.
errorCountButton
)
&
&
this
.
_errorCount
>
0
;
this
.
errorCountButton
.
errorCount
=
this
.
_errorCount
;
}
updateIsSplitConsoleEnabled
(
)
{
this
.
_splitConsoleEnabled
=
Services
.
prefs
.
getBoolPref
(
SPLITCONSOLE_ENABLED_PREF
true
)
;
if
(
!
this
.
_splitConsoleEnabled
&
&
this
.
splitConsole
)
{
this
.
closeSplitConsole
(
)
;
}
}
_commandIsVisible
(
button
)
{
const
{
isToolSupported
isCurrentlyVisible
visibilityswitch
}
=
button
;
if
(
!
Services
.
prefs
.
getBoolPref
(
visibilityswitch
true
)
)
{
return
false
;
}
if
(
isToolSupported
&
&
!
isToolSupported
(
this
)
)
{
return
false
;
}
if
(
isCurrentlyVisible
&
&
!
isCurrentlyVisible
(
)
)
{
return
false
;
}
return
true
;
}
_buildPanelForTool
(
toolDefinition
)
{
if
(
!
toolDefinition
.
isToolSupported
(
this
)
)
{
return
;
}
const
deck
=
this
.
doc
.
getElementById
(
"
toolbox
-
deck
"
)
;
const
id
=
toolDefinition
.
id
;
if
(
toolDefinition
.
ordinal
=
=
undefined
|
|
toolDefinition
.
ordinal
<
0
)
{
toolDefinition
.
ordinal
=
MAX_ORDINAL
;
}
if
(
!
toolDefinition
.
bgTheme
)
{
toolDefinition
.
bgTheme
=
"
theme
-
toolbar
"
;
}
const
panel
=
this
.
doc
.
createXULElement
(
"
vbox
"
)
;
panel
.
className
=
"
toolbox
-
panel
"
+
toolDefinition
.
bgTheme
;
if
(
!
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
)
{
panel
.
id
=
"
toolbox
-
panel
-
"
+
id
;
}
deck
.
appendChild
(
panel
)
;
}
get
additionalToolDefinitions
(
)
{
if
(
!
this
.
_additionalToolDefinitions
)
{
this
.
_additionalToolDefinitions
=
new
Map
(
)
;
}
return
this
.
_additionalToolDefinitions
;
}
getAdditionalTools
(
)
{
if
(
this
.
_additionalToolDefinitions
)
{
return
Array
.
from
(
this
.
additionalToolDefinitions
.
values
(
)
)
;
}
return
[
]
;
}
getVisibleAdditionalTools
(
)
{
return
this
.
visibleAdditionalTools
.
map
(
toolId
=
>
this
.
additionalToolDefinitions
.
get
(
toolId
)
)
;
}
hasAdditionalTool
(
toolId
)
{
return
this
.
additionalToolDefinitions
.
has
(
toolId
)
;
}
addAdditionalTool
(
definition
)
{
if
(
!
definition
.
id
)
{
throw
new
Error
(
"
Tool
definition
id
is
missing
"
)
;
}
if
(
this
.
isToolRegistered
(
definition
.
id
)
)
{
throw
new
Error
(
"
Tool
definition
already
registered
:
"
+
definition
.
id
)
;
}
this
.
additionalToolDefinitions
.
set
(
definition
.
id
definition
)
;
this
.
visibleAdditionalTools
=
[
.
.
.
this
.
visibleAdditionalTools
definition
.
id
]
;
const
buildPanel
=
(
)
=
>
this
.
_buildPanelForTool
(
definition
)
;
if
(
this
.
isReady
)
{
buildPanel
(
)
;
}
else
{
this
.
once
(
"
ready
"
buildPanel
)
;
}
}
get
inspectorExtensionSidebars
(
)
{
return
this
.
_inspectorExtensionSidebars
;
}
async
registerInspectorExtensionSidebar
(
id
options
)
{
this
.
_inspectorExtensionSidebars
.
set
(
id
options
)
;
if
(
!
this
.
target
.
getCachedFront
(
"
inspector
"
)
)
{
return
;
}
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
if
(
!
inspector
)
{
return
;
}
inspector
.
addExtensionSidebar
(
id
options
)
;
}
unregisterInspectorExtensionSidebar
(
id
)
{
if
(
this
.
_destroyer
)
{
return
;
}
const
sidebarDef
=
this
.
_inspectorExtensionSidebars
.
get
(
id
)
;
if
(
!
sidebarDef
)
{
return
;
}
this
.
_inspectorExtensionSidebars
.
delete
(
id
)
;
if
(
!
this
.
target
.
getCachedFront
(
"
inspector
"
)
)
{
return
;
}
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
inspector
.
removeExtensionSidebar
(
id
)
;
}
removeAdditionalTool
(
toolId
)
{
if
(
this
.
_destroyer
)
{
return
;
}
if
(
!
this
.
hasAdditionalTool
(
toolId
)
)
{
throw
new
Error
(
"
Tool
definition
not
registered
to
this
toolbox
:
"
+
toolId
)
;
}
this
.
additionalToolDefinitions
.
delete
(
toolId
)
;
this
.
visibleAdditionalTools
=
this
.
visibleAdditionalTools
.
filter
(
id
=
>
id
!
=
=
toolId
)
;
this
.
unloadTool
(
toolId
)
;
}
loadTool
(
id
options
)
{
let
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
iframe
)
{
const
panel
=
this
.
_toolPanels
.
get
(
id
)
;
return
new
Promise
(
resolve
=
>
{
if
(
panel
)
{
resolve
(
panel
)
;
}
else
{
this
.
once
(
id
+
"
-
ready
"
initializedPanel
=
>
{
resolve
(
initializedPanel
)
;
}
)
;
}
}
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
definition
=
this
.
getToolDefinition
(
id
)
;
if
(
!
definition
)
{
reject
(
new
Error
(
"
no
such
tool
id
"
+
id
)
)
;
return
;
}
iframe
=
this
.
doc
.
createXULElement
(
"
iframe
"
)
;
iframe
.
className
=
"
toolbox
-
panel
-
iframe
"
;
iframe
.
id
=
"
toolbox
-
panel
-
iframe
-
"
+
id
;
iframe
.
setAttribute
(
"
flex
"
1
)
;
iframe
.
setAttribute
(
"
forceOwnRefreshDriver
"
"
"
)
;
iframe
.
tooltip
=
"
aHTMLTooltip
"
;
gDevTools
.
emit
(
id
+
"
-
init
"
this
iframe
)
;
this
.
emit
(
id
+
"
-
init
"
iframe
)
;
if
(
!
iframe
.
parentNode
)
{
const
vbox
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
id
)
;
vbox
.
appendChild
(
iframe
)
;
}
const
onLoad
=
async
(
)
=
>
{
this
.
setIframeDocumentDir
(
iframe
)
;
let
built
=
definition
.
build
(
iframe
.
contentWindow
this
this
.
commands
)
;
if
(
!
(
typeof
built
.
then
=
=
"
function
"
)
)
{
const
panel
=
built
;
iframe
.
panel
=
panel
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
build
"
this
panel
)
;
this
.
emit
(
id
+
"
-
build
"
panel
)
;
if
(
typeof
panel
.
open
=
=
"
function
"
)
{
built
=
panel
.
open
(
options
)
;
}
else
{
built
=
new
Promise
(
resolve
=
>
{
resolve
(
panel
)
;
}
)
;
}
}
Promise
.
resolve
(
built
)
.
then
(
panel
=
>
{
this
.
_toolPanels
.
set
(
id
panel
)
;
if
(
typeof
panel
.
emit
=
=
"
undefined
"
)
{
EventEmitter
.
decorate
(
panel
)
;
}
gDevTools
.
emit
(
id
+
"
-
ready
"
this
panel
)
;
this
.
emit
(
id
+
"
-
ready
"
panel
)
;
resolve
(
panel
)
;
}
console
.
error
)
;
}
;
iframe
.
setAttribute
(
"
src
"
definition
.
url
)
;
if
(
definition
.
panelLabel
)
{
iframe
.
setAttribute
(
"
aria
-
label
"
definition
.
panelLabel
)
;
}
if
(
iframe
.
contentWindow
)
{
DOMHelpers
.
onceDOMReady
(
iframe
.
contentWindow
onLoad
)
;
}
else
{
const
callback
=
(
)
=
>
{
iframe
.
removeEventListener
(
"
DOMContentLoaded
"
callback
)
;
onLoad
(
)
;
}
;
iframe
.
addEventListener
(
"
DOMContentLoaded
"
callback
)
;
}
}
)
;
}
setIframeDocumentDir
(
iframe
)
{
const
docEl
=
iframe
.
contentWindow
?
.
document
.
documentElement
;
if
(
!
docEl
|
|
docEl
.
namespaceURI
!
=
=
HTML_NS
)
{
return
;
}
if
(
docEl
.
hasAttribute
(
"
dir
"
)
)
{
docEl
.
setAttribute
(
"
dir
"
this
.
direction
)
;
}
}
selectSingleNode
(
collection
id
)
{
[
.
.
.
collection
]
.
forEach
(
node
=
>
{
if
(
node
.
id
=
=
=
id
)
{
node
.
setAttribute
(
"
selected
"
"
true
"
)
;
node
.
setAttribute
(
"
aria
-
selected
"
"
true
"
)
;
}
else
{
node
.
removeAttribute
(
"
selected
"
)
;
node
.
removeAttribute
(
"
aria
-
selected
"
)
;
}
if
(
!
node
.
id
)
{
node
=
this
.
webconsolePanel
;
}
const
iframe
=
node
.
querySelector
(
"
.
toolbox
-
panel
-
iframe
"
)
;
if
(
iframe
)
{
let
visible
=
node
.
id
=
=
id
;
if
(
node
=
=
this
.
webconsolePanel
&
&
this
.
splitConsole
)
{
visible
=
true
;
}
this
.
setIframeVisible
(
iframe
visible
)
;
}
}
)
;
}
setIframeVisible
(
iframe
visible
)
{
const
state
=
visible
?
"
visible
"
:
"
hidden
"
;
const
win
=
iframe
.
contentWindow
;
const
doc
=
win
.
document
;
if
(
doc
.
visibilityState
!
=
state
)
{
Object
.
defineProperty
(
doc
"
visibilityState
"
{
value
:
state
configurable
:
true
}
)
;
doc
.
dispatchEvent
(
new
win
.
Event
(
"
visibilitychange
"
)
)
;
}
}
selectTool
(
id
reason
=
"
unknown
"
options
)
{
this
.
emit
(
"
panel
-
changed
"
)
;
if
(
this
.
currentToolId
=
=
id
)
{
const
panel
=
this
.
_toolPanels
.
get
(
id
)
;
if
(
panel
)
{
this
.
focusTool
(
id
)
;
return
Promise
.
resolve
(
panel
)
;
}
return
this
.
once
(
"
select
"
)
.
then
(
(
)
=
>
Promise
.
resolve
(
this
.
_toolPanels
.
get
(
id
)
)
)
;
}
if
(
!
this
.
isReady
)
{
throw
new
Error
(
"
Can
'
t
select
tool
wait
for
toolbox
'
ready
'
event
"
)
;
}
if
(
this
.
panelDefinitions
.
find
(
definition
=
>
definition
.
id
=
=
=
id
)
|
|
id
=
=
=
"
options
"
|
|
this
.
additionalToolDefinitions
.
get
(
id
)
)
{
if
(
this
.
currentToolId
)
{
this
.
telemetry
.
toolClosed
(
this
.
currentToolId
this
)
;
}
this
.
_pingTelemetrySelectTool
(
id
reason
)
;
}
else
{
throw
new
Error
(
"
No
tool
found
"
)
;
}
const
toolboxPanels
=
this
.
doc
.
querySelectorAll
(
"
.
toolbox
-
panel
"
)
;
this
.
lastUsedToolId
=
this
.
currentToolId
;
this
.
currentToolId
=
id
;
this
.
_refreshConsoleDisplay
(
)
;
if
(
id
!
=
"
options
"
)
{
Services
.
prefs
.
setCharPref
(
this
.
_prefs
.
LAST_TOOL
id
)
;
}
return
this
.
loadTool
(
id
options
)
.
then
(
panel
=
>
{
this
.
selectSingleNode
(
toolboxPanels
"
toolbox
-
panel
-
"
+
id
)
;
this
.
focusTool
(
id
)
;
this
.
emit
(
"
select
"
id
)
;
this
.
emit
(
id
+
"
-
selected
"
panel
)
;
return
panel
;
}
)
;
}
_pingTelemetrySelectTool
(
id
reason
)
{
const
width
=
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
;
const
panelName
=
this
.
getTelemetryPanelNameOrOther
(
id
)
;
const
prevPanelName
=
this
.
getTelemetryPanelNameOrOther
(
this
.
currentToolId
)
;
const
cold
=
!
this
.
getPanel
(
id
)
;
const
pending
=
[
"
host
"
"
width
"
"
start_state
"
"
panel_name
"
"
cold
"
]
;
if
(
this
.
currentToolId
)
{
this
.
telemetry
.
recordEvent
(
"
exit
"
prevPanelName
null
{
host
:
this
.
_hostType
width
panel_name
:
prevPanelName
next_panel
:
panelName
reason
}
)
;
}
this
.
telemetry
.
addEventProperties
(
this
.
topWindow
"
open
"
"
tools
"
null
{
width
}
)
;
if
(
id
=
=
=
"
webconsole
"
)
{
pending
.
push
(
"
message_count
"
)
;
}
this
.
telemetry
.
preparePendingEvent
(
this
"
enter
"
panelName
null
pending
)
;
this
.
telemetry
.
addEventProperties
(
this
"
enter
"
panelName
null
{
host
:
this
.
_hostType
start_state
:
reason
panel_name
:
panelName
cold
}
)
;
if
(
reason
!
=
=
"
initial_panel
"
)
{
const
width
=
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
;
this
.
telemetry
.
addEventProperty
(
this
"
enter
"
panelName
null
"
width
"
width
)
;
}
if
(
!
cold
&
&
id
=
=
=
"
webconsole
"
)
{
this
.
telemetry
.
addEventProperty
(
this
"
enter
"
"
webconsole
"
null
"
message_count
"
0
)
;
}
this
.
telemetry
.
toolOpened
(
id
this
)
;
}
focusTool
(
id
state
=
true
)
{
const
iframe
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
iframe
-
"
+
id
)
;
if
(
state
)
{
iframe
.
focus
(
)
;
}
else
{
iframe
.
blur
(
)
;
}
}
focusConsoleInput
(
)
{
const
consolePanel
=
this
.
getPanel
(
"
webconsole
"
)
;
if
(
consolePanel
)
{
consolePanel
.
focusInput
(
)
;
}
}
disableAllConsoleNetworkLogs
(
)
{
const
consolePanel
=
this
.
getPanel
(
"
webconsole
"
)
;
if
(
consolePanel
)
{
consolePanel
.
hud
.
ui
.
disableAllNetworkMessages
(
)
;
}
}
_updateLastFocusedElementForSplitConsole
(
originalTarget
)
{
const
webconsoleURL
=
gDevTools
.
getToolDefinition
(
"
webconsole
"
)
.
url
;
if
(
originalTarget
.
nodeType
!
=
=
1
|
|
originalTarget
.
baseURI
=
=
=
webconsoleURL
)
{
return
;
}
this
.
_lastFocusedElement
=
originalTarget
;
}
_isToolboxFocused
:
false
_onFocus
(
{
originalTarget
}
)
{
this
.
_isToolboxFocused
=
true
;
this
.
_debounceUpdateFocusedState
(
)
;
this
.
_updateLastFocusedElementForSplitConsole
(
originalTarget
)
;
}
_onBlur
(
)
{
this
.
_isToolboxFocused
=
false
;
this
.
_debounceUpdateFocusedState
(
)
;
}
_onTabsOrderUpdated
(
)
{
this
.
_combineAndSortPanelDefinitions
(
)
;
}
openSplitConsole
(
{
focusConsoleInput
=
true
}
=
{
}
)
{
if
(
!
this
.
isSplitConsoleEnabled
(
)
)
{
return
this
.
selectTool
(
"
webconsole
"
"
use_in_console_with_disabled_split_console
"
)
;
}
this
.
_splitConsole
=
true
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_OPEN_PREF
true
)
;
this
.
_refreshConsoleDisplay
(
)
;
const
iframe
=
this
.
webconsolePanel
.
querySelector
(
"
.
toolbox
-
panel
-
iframe
"
)
;
if
(
iframe
)
{
this
.
setIframeVisible
(
iframe
true
)
;
}
return
this
.
loadTool
(
"
webconsole
"
)
.
then
(
(
)
=
>
{
if
(
!
this
.
component
)
{
return
;
}
this
.
component
.
setIsSplitConsoleActive
(
true
)
;
this
.
telemetry
.
recordEvent
(
"
activate
"
"
split_console
"
null
{
host
:
this
.
_getTelemetryHostString
(
)
width
:
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
}
)
;
this
.
emit
(
"
split
-
console
"
)
;
if
(
focusConsoleInput
)
{
this
.
focusConsoleInput
(
)
;
}
}
)
;
}
closeSplitConsole
(
)
{
this
.
_splitConsole
=
false
;
Services
.
prefs
.
setBoolPref
(
SPLITCONSOLE_OPEN_PREF
false
)
;
this
.
_saveSplitConsoleHeight
(
)
;
this
.
_refreshConsoleDisplay
(
)
;
this
.
component
.
setIsSplitConsoleActive
(
false
)
;
this
.
telemetry
.
recordEvent
(
"
deactivate
"
"
split_console
"
null
{
host
:
this
.
_getTelemetryHostString
(
)
width
:
Math
.
ceil
(
this
.
win
.
outerWidth
/
50
)
*
50
}
)
;
this
.
emit
(
"
split
-
console
"
)
;
if
(
this
.
_lastFocusedElement
)
{
this
.
_lastFocusedElement
.
focus
(
)
;
}
return
Promise
.
resolve
(
)
;
}
toggleSplitConsole
(
)
{
if
(
this
.
currentToolId
!
=
=
"
webconsole
"
)
{
return
this
.
splitConsole
?
this
.
closeSplitConsole
(
)
:
this
.
openSplitConsole
(
)
;
}
return
Promise
.
resolve
(
)
;
}
toggleOptions
(
event
)
{
if
(
this
.
currentToolId
=
=
=
"
options
"
&
&
gDevTools
.
getToolDefinition
(
this
.
lastUsedToolId
)
)
{
this
.
selectTool
(
this
.
lastUsedToolId
"
toggle_settings_off
"
)
;
}
else
{
this
.
selectTool
(
"
options
"
"
toggle_settings_on
"
)
;
}
event
.
preventDefault
(
)
;
}
selectNextTool
(
)
{
const
definitions
=
this
.
component
.
panelDefinitions
;
const
index
=
definitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
this
.
currentToolId
)
;
const
definition
=
index
=
=
=
-
1
|
|
index
>
=
definitions
.
length
-
1
?
definitions
[
0
]
:
definitions
[
index
+
1
]
;
return
this
.
selectTool
(
definition
.
id
"
select_next_key
"
)
;
}
selectPreviousTool
(
)
{
const
definitions
=
this
.
component
.
panelDefinitions
;
const
index
=
definitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
this
.
currentToolId
)
;
const
definition
=
index
=
=
=
-
1
|
|
index
<
1
?
definitions
[
definitions
.
length
-
1
]
:
definitions
[
index
-
1
]
;
return
this
.
selectTool
(
definition
.
id
"
select_prev_key
"
)
;
}
isHighlighted
(
id
)
{
return
this
.
component
.
state
.
highlightedTools
.
has
(
id
)
;
}
async
highlightTool
(
id
)
{
if
(
!
this
.
component
)
{
await
this
.
isOpen
;
}
this
.
component
.
highlightTool
(
id
)
;
}
async
unhighlightTool
(
id
)
{
if
(
!
this
.
component
)
{
await
this
.
isOpen
;
}
this
.
component
.
unhighlightTool
(
id
)
;
}
raise
(
)
{
this
.
postMessage
(
{
name
:
"
raise
-
host
"
}
)
;
return
this
.
once
(
"
host
-
raised
"
)
;
}
async
_onWillNavigate
(
{
isFrameSwitching
}
=
{
}
)
{
if
(
this
.
_pausedTargets
.
size
>
0
)
{
this
.
emit
(
"
toolbox
-
resumed
"
)
;
this
.
_pausedTargets
.
clear
(
)
;
if
(
this
.
isHighlighted
(
"
jsdebugger
"
)
)
{
this
.
unhighlightTool
(
"
jsdebugger
"
)
;
}
}
this
.
setErrorCount
(
0
)
;
if
(
!
isFrameSwitching
)
{
this
.
_updateFrames
(
{
destroyAll
:
true
}
)
;
}
this
.
updateToolboxButtons
(
)
;
const
toolId
=
this
.
currentToolId
;
if
(
toolId
!
=
"
inspector
"
&
&
toolId
!
=
"
webconsole
"
&
&
toolId
!
=
"
netmonitor
"
&
&
toolId
!
=
"
accessibility
"
)
{
return
;
}
const
start
=
this
.
win
.
performance
.
now
(
)
;
const
panel
=
this
.
getPanel
(
toolId
)
;
if
(
!
panel
)
{
return
;
}
await
panel
.
once
(
"
reloaded
"
)
;
if
(
this
.
isDestroying
(
)
)
{
return
;
}
const
delay
=
this
.
win
.
performance
.
now
(
)
-
start
;
const
telemetryKey
=
"
DEVTOOLS_TOOLBOX_PAGE_RELOAD_DELAY_MS
"
;
this
.
telemetry
.
getKeyedHistogramById
(
telemetryKey
)
.
add
(
toolId
delay
)
;
}
_refreshHostTitle
(
)
{
let
title
;
const
{
selectedTargetFront
}
=
this
.
commands
.
targetCommand
;
if
(
this
.
target
.
isXpcShellTarget
)
{
title
=
"
XPCShell
Toolbox
"
;
}
else
if
(
this
.
isMultiProcessBrowserToolbox
)
{
const
scope
=
Services
.
prefs
.
getCharPref
(
BROWSERTOOLBOX_SCOPE_PREF
)
;
if
(
scope
=
=
BROWSERTOOLBOX_SCOPE_EVERYTHING
)
{
title
=
L10N
.
getStr
(
"
toolbox
.
multiProcessBrowserToolboxTitle
"
)
;
}
else
if
(
scope
=
=
BROWSERTOOLBOX_SCOPE_PARENTPROCESS
)
{
title
=
L10N
.
getStr
(
"
toolbox
.
parentProcessBrowserToolboxTitle
"
)
;
}
else
{
throw
new
Error
(
"
Unsupported
scope
:
"
+
scope
)
;
}
}
else
if
(
selectedTargetFront
.
name
&
&
selectedTargetFront
.
name
!
=
selectedTargetFront
.
url
)
{
if
(
this
.
_descriptorFront
.
isWebExtensionDescriptor
&
&
selectedTargetFront
.
url
.
includes
(
selectedTargetFront
.
name
)
)
{
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate1
"
getUnicodeUrl
(
selectedTargetFront
.
url
)
)
;
}
else
{
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate2
"
selectedTargetFront
.
name
getUnicodeUrl
(
selectedTargetFront
.
url
)
)
;
}
}
else
{
title
=
L10N
.
getFormatStr
(
"
toolbox
.
titleTemplate1
"
getUnicodeUrl
(
selectedTargetFront
.
url
)
)
;
}
this
.
postMessage
(
{
name
:
"
set
-
host
-
title
"
title
}
)
;
}
getExtensionPathName
(
url
)
{
if
(
!
URL
.
canParse
(
url
)
)
{
return
url
;
}
const
parsedURL
=
new
URL
(
url
)
;
if
(
parsedURL
.
protocol
!
=
=
"
moz
-
extension
:
"
)
{
return
url
;
}
return
parsedURL
.
pathname
;
}
get
preferenceFront
(
)
{
if
(
!
this
.
_preferenceFrontRequest
)
{
this
.
_preferenceFrontRequest
=
this
.
commands
.
client
.
mainRoot
.
getFront
(
"
preference
"
)
;
}
return
this
.
_preferenceFrontRequest
;
}
async
changePseudoLocale
(
pseudoLocale
)
{
await
this
.
isOpen
;
const
prefFront
=
await
this
.
preferenceFront
;
if
(
pseudoLocale
=
=
=
"
none
"
)
{
await
prefFront
.
clearUserPref
(
PSEUDO_LOCALE_PREF
)
;
}
else
{
await
prefFront
.
setCharPref
(
PSEUDO_LOCALE_PREF
pseudoLocale
)
;
}
this
.
component
.
setPseudoLocale
(
pseudoLocale
)
;
this
.
_pseudoLocaleChanged
=
true
;
}
async
getPseudoLocale
(
)
{
if
(
!
this
.
isBrowserToolbox
)
{
return
undefined
;
}
const
prefFront
=
await
this
.
preferenceFront
;
const
locale
=
await
prefFront
.
getCharPref
(
PSEUDO_LOCALE_PREF
)
;
switch
(
locale
)
{
case
"
bidi
"
:
case
"
accented
"
:
return
locale
;
default
:
return
"
none
"
;
}
}
async
toggleNoAutohide
(
)
{
const
front
=
await
this
.
preferenceFront
;
const
toggledValue
=
!
(
await
this
.
_isDisableAutohideEnabled
(
)
)
;
front
.
setBoolPref
(
DISABLE_AUTOHIDE_PREF
toggledValue
)
;
if
(
this
.
isBrowserToolbox
|
|
this
.
_descriptorFront
.
isWebExtensionDescriptor
)
{
this
.
component
.
setDisableAutohide
(
toggledValue
)
;
}
this
.
_autohideHasBeenToggled
=
true
;
}
async
toggleAlwaysOnTop
(
)
{
const
currentValue
=
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_ALWAYS_ON_TOP
false
)
;
Services
.
prefs
.
setBoolPref
(
DEVTOOLS_ALWAYS_ON_TOP
!
currentValue
)
;
const
addonId
=
this
.
_descriptorFront
.
id
;
await
this
.
destroy
(
)
;
gDevTools
.
showToolboxForWebExtension
(
addonId
)
;
}
async
_isDisableAutohideEnabled
(
)
{
if
(
!
this
.
isBrowserToolbox
&
&
!
this
.
_descriptorFront
.
isWebExtensionDescriptor
)
{
return
false
;
}
const
prefFront
=
await
this
.
preferenceFront
;
return
prefFront
.
getBoolPref
(
DISABLE_AUTOHIDE_PREF
)
;
}
async
_listFrames
(
)
{
if
(
!
this
.
target
.
getTrait
(
"
frames
"
)
|
|
this
.
target
.
targetForm
.
ignoreSubFrames
)
{
return
;
}
try
{
const
{
frames
}
=
await
this
.
target
.
listFrames
(
)
;
this
.
_updateFrames
(
{
frames
}
)
;
}
catch
(
e
)
{
console
.
error
(
"
Error
while
listing
frames
"
e
)
;
}
}
onIframePickerFrameSelected
(
frameIdOrTargetActorId
)
{
if
(
!
this
.
frameMap
.
has
(
frameIdOrTargetActorId
)
)
{
console
.
error
(
Can
'
t
focus
on
frame
"
{
frameIdOrTargetActorId
}
"
it
is
not
a
known
frame
)
;
return
;
}
const
frameInfo
=
this
.
frameMap
.
get
(
frameIdOrTargetActorId
)
;
if
(
!
frameInfo
.
targetFront
)
{
this
.
target
.
switchToFrame
(
{
windowId
:
frameIdOrTargetActorId
}
)
;
return
;
}
this
.
commands
.
targetCommand
.
selectTarget
(
frameInfo
.
targetFront
)
;
}
async
onHighlightFrame
(
frameIdOrTargetActorId
)
{
if
(
!
this
.
rootFrameSelected
)
{
return
null
;
}
const
frameInfo
=
this
.
frameMap
.
get
(
frameIdOrTargetActorId
)
;
if
(
!
frameInfo
)
{
return
null
;
}
let
nodeFront
;
if
(
frameInfo
.
targetFront
)
{
const
inspectorFront
=
await
frameInfo
.
targetFront
.
getFront
(
"
inspector
"
)
;
nodeFront
=
await
inspectorFront
.
walker
.
documentElement
(
)
;
}
else
{
const
inspectorFront
=
await
this
.
target
.
getFront
(
"
inspector
"
)
;
nodeFront
=
await
inspectorFront
.
walker
.
getNodeActorFromWindowID
(
frameIdOrTargetActorId
)
;
}
const
highlighter
=
this
.
getHighlighter
(
)
;
return
highlighter
.
highlight
(
nodeFront
)
;
}
_updateFrames
(
data
)
{
if
(
data
.
selected
)
{
data
.
selected
=
data
.
selected
.
toString
(
)
;
}
else
if
(
data
.
frameData
)
{
data
.
frameData
.
id
=
data
.
frameData
.
id
.
toString
(
)
;
}
else
if
(
data
.
frames
)
{
data
.
frames
.
forEach
(
frame
=
>
{
if
(
frame
.
id
)
{
frame
.
id
=
frame
.
id
.
toString
(
)
;
}
}
)
;
}
if
(
data
.
destroyAll
)
{
this
.
frameMap
.
clear
(
)
;
this
.
selectedFrameId
=
null
;
}
else
if
(
data
.
selected
)
{
if
(
data
.
selected
=
=
this
.
target
.
actorID
)
{
this
.
selectedFrameId
=
null
;
}
else
{
this
.
selectedFrameId
=
data
.
selected
;
}
}
else
if
(
data
.
frameData
&
&
this
.
frameMap
.
has
(
data
.
frameData
.
id
)
)
{
const
existingFrameData
=
this
.
frameMap
.
get
(
data
.
frameData
.
id
)
;
if
(
existingFrameData
.
title
=
=
data
.
frameData
.
title
&
&
existingFrameData
.
url
=
=
data
.
frameData
.
url
)
{
return
;
}
this
.
frameMap
.
set
(
data
.
frameData
.
id
{
.
.
.
existingFrameData
url
:
data
.
frameData
.
url
title
:
data
.
frameData
.
title
}
)
;
}
else
if
(
data
.
frames
)
{
data
.
frames
.
forEach
(
frame
=
>
{
if
(
frame
.
destroy
)
{
this
.
frameMap
.
delete
(
frame
.
id
)
;
if
(
this
.
selectedFrameId
=
=
frame
.
id
)
{
this
.
selectedFrameId
=
null
;
}
}
else
{
this
.
frameMap
.
set
(
frame
.
id
frame
)
;
}
}
)
;
}
if
(
!
this
.
selectedFrameId
)
{
const
frames
=
[
.
.
.
this
.
frameMap
.
values
(
)
]
;
const
topFrames
=
frames
.
filter
(
frame
=
>
frame
.
isTopLevel
)
;
this
.
selectedFrameId
=
topFrames
.
length
?
topFrames
[
0
]
.
id
:
null
;
}
if
(
!
this
.
debouncedToolbarUpdate
)
{
this
.
debouncedToolbarUpdate
=
debounce
(
(
)
=
>
{
if
(
this
.
component
)
{
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
this
.
debouncedToolbarUpdate
=
null
;
}
200
this
)
;
}
const
updateUiElements
=
(
)
=
>
{
this
.
updateFrameButton
(
)
;
if
(
this
.
debouncedToolbarUpdate
)
{
this
.
debouncedToolbarUpdate
(
)
;
}
}
;
if
(
!
this
.
isReady
)
{
this
.
once
(
"
ready
"
)
.
then
(
(
)
=
>
updateUiElements
)
;
}
else
{
updateUiElements
(
)
;
}
}
get
rootFrameSelected
(
)
{
if
(
!
this
.
selectedFrameId
)
{
return
true
;
}
return
this
.
frameMap
.
get
(
this
.
selectedFrameId
)
.
isTopLevel
;
}
switchToPreviousHost
(
)
{
return
this
.
switchHost
(
"
previous
"
)
;
}
switchHost
(
hostType
)
{
if
(
hostType
=
=
this
.
hostType
|
|
!
this
.
_descriptorFront
.
isLocalTab
)
{
return
null
;
}
this
.
_removeChromeEventHandlerEvents
(
)
;
this
.
emit
(
"
host
-
will
-
change
"
hostType
)
;
this
.
focusTool
(
this
.
currentToolId
false
)
;
this
.
postMessage
(
{
name
:
"
switch
-
host
"
hostType
}
)
;
return
this
.
once
(
"
host
-
changed
"
)
;
}
switchHostToTab
(
tabBrowsingContextID
)
{
this
.
postMessage
(
{
name
:
"
switch
-
host
-
to
-
tab
"
tabBrowsingContextID
}
)
;
return
this
.
once
(
"
switched
-
host
-
to
-
tab
"
)
;
}
_onSwitchedHost
(
{
hostType
}
)
{
this
.
_hostType
=
hostType
;
this
.
_buildDockOptions
(
)
;
this
.
_addChromeEventHandlerEvents
(
)
;
this
.
focusTool
(
this
.
currentToolId
true
)
;
this
.
emit
(
"
host
-
changed
"
)
;
this
.
telemetry
.
getHistogramById
(
HOST_HISTOGRAM
)
.
add
(
this
.
_getTelemetryHostId
(
)
)
;
this
.
component
.
setCurrentHostType
(
hostType
)
;
}
_onSwitchedHostToTab
(
browsingContextID
)
{
const
targets
=
this
.
commands
.
targetCommand
.
getAllTargets
(
[
this
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
)
;
const
target
=
targets
.
find
(
target
=
>
target
.
browsingContextID
=
=
browsingContextID
)
;
this
.
commands
.
targetCommand
.
selectTarget
(
target
)
;
this
.
emit
(
"
switched
-
host
-
to
-
tab
"
)
;
}
isToolRegistered
(
toolId
)
{
return
!
!
this
.
getToolDefinition
(
toolId
)
;
}
getToolDefinition
(
toolId
)
{
return
(
gDevTools
.
getToolDefinition
(
toolId
)
|
|
this
.
additionalToolDefinitions
.
get
(
toolId
)
)
;
}
unloadTool
(
toolId
)
{
if
(
typeof
toolId
!
=
"
string
"
)
{
throw
new
Error
(
"
Unexpected
non
-
string
toolId
received
.
"
)
;
}
if
(
this
.
_toolPanels
.
has
(
toolId
)
)
{
const
instance
=
this
.
_toolPanels
.
get
(
toolId
)
;
instance
.
destroy
(
)
;
this
.
_toolPanels
.
delete
(
toolId
)
;
}
const
panel
=
this
.
doc
.
getElementById
(
"
toolbox
-
panel
-
"
+
toolId
)
;
if
(
this
.
currentToolId
=
=
toolId
)
{
const
index
=
this
.
panelDefinitions
.
findIndex
(
(
{
id
}
)
=
>
id
=
=
=
toolId
)
;
const
nextTool
=
this
.
panelDefinitions
[
index
+
1
]
;
const
previousTool
=
this
.
panelDefinitions
[
index
-
1
]
;
let
toolNameToSelect
;
if
(
nextTool
)
{
toolNameToSelect
=
nextTool
.
id
;
}
if
(
previousTool
)
{
toolNameToSelect
=
previousTool
.
id
;
}
if
(
toolNameToSelect
)
{
this
.
selectTool
(
toolNameToSelect
"
tool_unloaded
"
)
;
}
}
this
.
panelDefinitions
=
this
.
panelDefinitions
.
filter
(
(
{
id
}
)
=
>
id
!
=
=
toolId
)
;
this
.
visibleAdditionalTools
=
this
.
visibleAdditionalTools
.
filter
(
id
=
>
id
!
=
=
toolId
)
;
this
.
_combineAndSortPanelDefinitions
(
)
;
if
(
panel
)
{
panel
.
remove
(
)
;
}
if
(
this
.
hostType
=
=
Toolbox
.
HostType
.
WINDOW
)
{
const
doc
=
this
.
win
.
parent
.
document
;
const
key
=
doc
.
getElementById
(
"
key_
"
+
toolId
)
;
if
(
key
)
{
key
.
remove
(
)
;
}
}
}
_toolRegistered
(
toolId
)
{
let
definition
=
gDevTools
.
getToolDefinition
(
toolId
)
;
let
isAdditionalTool
=
false
;
if
(
!
definition
)
{
definition
=
this
.
additionalToolDefinitions
.
get
(
toolId
)
;
isAdditionalTool
=
true
;
}
if
(
definition
.
isToolSupported
(
this
)
)
{
if
(
isAdditionalTool
)
{
this
.
visibleAdditionalTools
=
[
.
.
.
this
.
visibleAdditionalTools
toolId
]
;
this
.
_combineAndSortPanelDefinitions
(
)
;
}
else
{
this
.
panelDefinitions
=
this
.
panelDefinitions
.
concat
(
definition
)
;
}
this
.
_buildPanelForTool
(
definition
)
;
this
.
emit
(
"
tool
-
registered
"
toolId
)
;
}
}
_toolUnregistered
(
toolId
)
{
this
.
unloadTool
(
toolId
)
;
this
.
emit
(
"
tool
-
unregistered
"
toolId
)
;
}
getHighlighter
(
)
{
let
pendingHighlight
;
const
_getInspector
=
async
(
)
=
>
{
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
if
(
inspector
)
{
return
inspector
;
}
return
this
.
loadTool
(
"
inspector
"
)
;
}
;
async
function
_waitForHighlighterEvent
(
eventName
)
{
const
inspector
=
await
_getInspector
(
)
;
return
new
Promise
(
resolve
=
>
{
function
_handler
(
data
)
{
if
(
data
.
type
=
=
=
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
{
inspector
.
highlighters
.
off
(
eventName
_handler
)
;
resolve
(
data
)
;
}
}
inspector
.
highlighters
.
on
(
eventName
_handler
)
;
}
)
;
}
return
{
highlight
:
this
.
_safeAsyncAfterDestroy
(
async
(
object
options
)
=
>
{
pendingHighlight
=
(
async
(
)
=
>
{
let
nodeFront
=
object
;
if
(
!
(
nodeFront
instanceof
NodeFront
)
)
{
const
inspectorFront
=
await
this
.
target
.
getFront
(
"
inspector
"
)
;
nodeFront
=
await
inspectorFront
.
getNodeFrontFromNodeGrip
(
object
)
;
}
if
(
!
nodeFront
)
{
return
null
;
}
const
inspector
=
await
_getInspector
(
)
;
return
inspector
.
highlighters
.
showHighlighterTypeForNode
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
nodeFront
options
)
;
}
)
(
)
;
return
pendingHighlight
;
}
)
unhighlight
:
this
.
_safeAsyncAfterDestroy
(
async
(
)
=
>
{
if
(
pendingHighlight
)
{
await
pendingHighlight
;
pendingHighlight
=
null
;
}
const
inspector
=
await
_getInspector
(
)
;
return
inspector
.
highlighters
.
hideHighlighterType
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
)
waitForHighlighterShown
:
this
.
_safeAsyncAfterDestroy
(
async
(
)
=
>
{
return
_waitForHighlighterEvent
(
"
highlighter
-
shown
"
)
;
}
)
waitForHighlighterHidden
:
this
.
_safeAsyncAfterDestroy
(
async
(
)
=
>
{
return
_waitForHighlighterEvent
(
"
highlighter
-
hidden
"
)
;
}
)
}
;
}
_safeAsyncAfterDestroy
(
fn
)
{
return
safeAsyncMethod
(
fn
(
)
=
>
!
!
this
.
_destroyer
)
;
}
async
_onNewSelectedNodeFront
(
)
{
this
.
emit
(
"
selection
-
changed
"
)
;
const
targetFrontActorID
=
this
.
selection
?
.
nodeFront
?
.
targetFront
?
.
actorID
;
if
(
targetFrontActorID
)
{
this
.
selectTarget
(
targetFrontActorID
)
;
}
}
_onToolSelected
(
)
{
this
.
_refreshHostTitle
(
)
;
this
.
updatePickerButton
(
)
;
this
.
updateFrameButton
(
)
;
this
.
updateErrorCountButton
(
)
;
this
.
component
.
setToolboxButtons
(
this
.
toolbarButtons
)
;
}
_onInspectObject
(
packet
)
{
this
.
inspectObjectActor
(
packet
.
objectActor
packet
.
inspectFromAnnotation
)
;
}
async
inspectObjectActor
(
objectActor
inspectFromAnnotation
)
{
const
objectGrip
=
objectActor
?
.
getGrip
?
objectActor
.
getGrip
(
)
:
objectActor
;
if
(
objectGrip
.
preview
&
&
objectGrip
.
preview
.
nodeType
=
=
=
domNodeConstants
.
ELEMENT_NODE
)
{
await
this
.
viewElementInInspector
(
objectGrip
inspectFromAnnotation
)
;
return
;
}
if
(
objectGrip
.
class
=
=
"
Function
"
)
{
if
(
!
objectGrip
.
location
)
{
console
.
error
(
"
Missing
location
in
Function
objectGrip
"
objectGrip
)
;
return
;
}
const
{
url
line
column
}
=
objectGrip
.
location
;
await
this
.
viewSourceInDebugger
(
url
line
column
)
;
return
;
}
if
(
objectGrip
.
type
!
=
=
"
null
"
&
&
objectGrip
.
type
!
=
=
"
undefined
"
)
{
if
(
this
.
currentToolId
!
=
"
webconsole
"
)
{
await
this
.
openSplitConsole
(
)
;
}
const
panel
=
this
.
getPanel
(
"
webconsole
"
)
;
panel
.
hud
.
ui
.
inspectObjectActor
(
objectActor
)
;
}
}
getNotificationBox
(
)
{
return
this
.
notificationBox
;
}
async
closeToolbox
(
)
{
await
this
.
destroy
(
)
;
}
isDestroying
(
)
{
return
this
.
_destroyer
;
}
destroy
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
;
}
let
destroyerResolve
;
this
.
_destroyer
=
new
Promise
(
r
=
>
(
destroyerResolve
=
r
)
)
;
this
.
_destroyToolbox
(
)
.
then
(
destroyerResolve
)
;
return
this
.
_destroyer
;
}
async
_destroyToolbox
(
)
{
this
.
emit
(
"
destroy
"
)
;
this
.
commands
.
client
.
isToolboxDestroy
=
true
;
this
.
off
(
"
select
"
this
.
_onToolSelected
)
;
this
.
off
(
"
host
-
changed
"
this
.
_refreshHostTitle
)
;
gDevTools
.
off
(
"
tool
-
registered
"
this
.
_toolRegistered
)
;
gDevTools
.
off
(
"
tool
-
unregistered
"
this
.
_toolUnregistered
)
;
for
(
const
prefName
in
BOOLEAN_CONFIGURATION_PREFS
)
{
Services
.
prefs
.
removeObserver
(
prefName
this
.
_onBooleanConfigurationPrefChange
)
;
}
Services
.
prefs
.
removeObserver
(
BROWSERTOOLBOX_SCOPE_PREF
this
.
_refreshHostTitle
)
;
this
.
telemetry
.
toolClosed
(
this
.
currentToolId
this
)
;
this
.
_lastFocusedElement
=
null
;
this
.
_pausedTargets
=
null
;
if
(
this
.
_sourceMapLoader
)
{
this
.
_sourceMapLoader
.
destroy
(
)
;
this
.
_sourceMapLoader
=
null
;
}
if
(
this
.
_parserWorker
)
{
this
.
_parserWorker
.
stop
(
)
;
this
.
_parserWorker
=
null
;
}
if
(
this
.
webconsolePanel
)
{
this
.
_saveSplitConsoleHeight
(
)
;
this
.
webconsolePanel
.
removeEventListener
(
"
resize
"
this
.
_saveSplitConsoleHeight
)
;
this
.
webconsolePanel
=
null
;
}
if
(
this
.
_tabBar
)
{
this
.
_tabBar
.
removeEventListener
(
"
keypress
"
this
.
_onToolbarArrowKeypress
)
;
}
if
(
this
.
_componentMount
)
{
this
.
ReactDOM
.
unmountComponentAtNode
(
this
.
_componentMount
)
;
this
.
component
=
null
;
this
.
_componentMount
=
null
;
this
.
_tabBar
=
null
;
this
.
_appBoundary
=
null
;
}
this
.
destroyHarAutomation
(
)
;
for
(
const
[
id
panel
]
of
this
.
_toolPanels
)
{
try
{
gDevTools
.
emit
(
id
+
"
-
destroy
"
this
panel
)
;
this
.
emit
(
id
+
"
-
destroy
"
panel
)
;
const
rv
=
panel
.
destroy
(
)
;
if
(
rv
)
{
console
.
error
(
Panel
{
id
}
'
s
destroy
method
returned
something
whereas
it
shouldn
'
t
(
and
should
be
synchronous
)
.
)
;
}
}
catch
(
e
)
{
console
.
error
(
"
Panel
"
+
id
+
"
:
"
e
)
;
}
}
this
.
browserRequire
=
null
;
this
.
_toolNames
=
null
;
const
onResetPreference
=
this
.
resetPreference
(
)
.
then
(
(
)
=
>
{
this
.
_preferenceFrontRequest
=
null
;
}
)
;
this
.
commands
.
targetCommand
.
unwatchTargets
(
{
types
:
this
.
commands
.
targetCommand
.
ALL_TYPES
onAvailable
:
this
.
_onTargetAvailable
onSelected
:
this
.
_onTargetSelected
onDestroyed
:
this
.
_onTargetDestroyed
}
)
;
const
watchedResources
=
[
this
.
resourceCommand
.
TYPES
.
CONSOLE_MESSAGE
this
.
resourceCommand
.
TYPES
.
ERROR_MESSAGE
this
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
this
.
resourceCommand
.
TYPES
.
THREAD_STATE
]
;
if
(
!
this
.
isBrowserToolbox
)
{
watchedResources
.
push
(
this
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
)
;
}
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
features
.
javascript
-
tracing
"
false
)
)
{
watchedResources
.
push
(
this
.
resourceCommand
.
TYPES
.
JSTRACER_STATE
)
;
this
.
commands
.
tracerCommand
.
off
(
"
toggle
"
this
.
onTracerToggled
)
;
}
this
.
resourceCommand
.
unwatchResources
(
watchedResources
{
onAvailable
:
this
.
_onResourceAvailable
}
)
;
if
(
this
.
toolbarButtons
)
{
this
.
toolbarButtons
.
forEach
(
button
=
>
{
if
(
typeof
button
.
teardown
=
=
"
function
"
)
{
button
.
teardown
(
)
;
}
}
)
;
}
const
win
=
this
.
win
;
const
host
=
this
.
_getTelemetryHostString
(
)
;
const
width
=
Math
.
ceil
(
win
.
outerWidth
/
50
)
*
50
;
const
prevPanelName
=
this
.
getTelemetryPanelNameOrOther
(
this
.
currentToolId
)
;
this
.
telemetry
.
toolClosed
(
"
toolbox
"
this
)
;
this
.
telemetry
.
recordEvent
(
"
exit
"
prevPanelName
null
{
host
width
panel_name
:
this
.
getTelemetryPanelNameOrOther
(
this
.
currentToolId
)
next_panel
:
"
none
"
reason
:
"
toolbox_close
"
}
)
;
this
.
telemetry
.
recordEvent
(
"
close
"
"
tools
"
null
{
host
width
}
)
;
const
onceDestroyed
=
new
Promise
(
resolve
=
>
{
resolve
(
onResetPreference
.
catch
(
console
.
error
)
.
then
(
async
(
)
=
>
{
if
(
this
.
_nodePicker
)
{
this
.
_nodePicker
.
destroy
(
)
;
this
.
_nodePicker
=
null
;
}
this
.
selection
.
destroy
(
)
;
this
.
selection
=
null
;
if
(
this
.
_netMonitorAPI
)
{
this
.
_netMonitorAPI
.
destroy
(
)
;
this
.
_netMonitorAPI
=
null
;
}
if
(
this
.
_sourceMapURLService
)
{
await
this
.
_sourceMapURLService
.
waitForSourcesLoading
(
)
;
this
.
_sourceMapURLService
.
destroy
(
)
;
this
.
_sourceMapURLService
=
null
;
}
this
.
_removeWindowListeners
(
)
;
this
.
_removeChromeEventHandlerEvents
(
)
;
this
.
_store
=
null
;
return
this
.
commands
.
destroy
(
)
;
}
console
.
error
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
destroyed
"
)
;
this
.
_host
=
null
;
this
.
_win
=
null
;
this
.
_toolPanels
.
clear
(
)
;
this
.
_descriptorFront
=
null
;
this
.
resourceCommand
=
null
;
this
.
commands
=
null
;
if
(
flags
.
testing
)
{
win
.
windowUtils
.
garbageCollect
(
)
;
}
}
)
.
catch
(
console
.
error
)
)
;
}
)
;
const
leakCheckObserver
=
(
{
wrappedJSObject
:
barrier
}
)
=
>
{
barrier
.
client
.
addBlocker
(
"
DevTools
:
Wait
until
toolbox
is
destroyed
"
onceDestroyed
)
;
}
;
const
topic
=
"
shutdown
-
leaks
-
before
-
check
"
;
Services
.
obs
.
addObserver
(
leakCheckObserver
topic
)
;
await
onceDestroyed
;
Services
.
obs
.
removeObserver
(
leakCheckObserver
topic
)
;
}
openTextBoxContextMenu
(
x
y
)
{
const
menu
=
createEditContextMenu
(
this
.
topWindow
"
toolbox
-
menu
"
)
;
menu
.
once
(
"
open
"
(
)
=
>
this
.
emit
(
"
menu
-
open
"
)
)
;
menu
.
once
(
"
close
"
(
)
=
>
this
.
emit
(
"
menu
-
close
"
)
)
;
menu
.
popup
(
x
y
this
.
doc
)
;
}
getTextBoxContextMenu
(
)
{
return
this
.
topDoc
.
getElementById
(
"
toolbox
-
menu
"
)
;
}
async
resetPreference
(
)
{
if
(
!
this
.
_preferenceFrontRequest
|
|
(
!
this
.
_autohideHasBeenToggled
&
&
!
this
.
_pseudoLocaleChanged
)
)
{
return
;
}
const
preferenceFront
=
await
this
.
preferenceFront
;
if
(
this
.
_autohideHasBeenToggled
)
{
await
preferenceFront
.
clearUserPref
(
DISABLE_AUTOHIDE_PREF
)
;
}
if
(
this
.
_pseudoLocaleChanged
)
{
await
preferenceFront
.
clearUserPref
(
PSEUDO_LOCALE_PREF
)
;
}
}
async
initHarAutomation
(
)
{
const
autoExport
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
netmonitor
.
har
.
enableAutoExportToFile
"
)
;
if
(
autoExport
)
{
this
.
harAutomation
=
new
HarAutomation
(
)
;
await
this
.
harAutomation
.
initialize
(
this
)
;
}
}
destroyHarAutomation
(
)
{
if
(
this
.
harAutomation
)
{
this
.
harAutomation
.
destroy
(
)
;
}
}
get
gViewSourceUtils
(
)
{
return
this
.
win
.
gViewSourceUtils
;
}
async
viewGeneratedSourceInStyleEditor
(
url
)
{
if
(
typeof
url
!
=
=
"
string
"
)
{
console
.
warn
(
"
Failed
to
open
generated
source
no
url
given
"
)
;
return
false
;
}
return
viewSource
.
viewSourceInStyleEditor
(
this
url
1
)
;
}
async
viewSourceInStyleEditorByURL
(
url
line
column
)
{
if
(
typeof
url
!
=
=
"
string
"
)
{
console
.
warn
(
"
Failed
to
open
source
no
url
given
"
)
;
return
false
;
}
if
(
typeof
line
!
=
=
"
number
"
)
{
console
.
warn
(
"
No
line
given
when
navigating
to
source
.
If
you
'
re
seeing
this
there
is
a
bug
.
"
)
;
line
=
1
;
column
=
null
;
}
return
viewSource
.
viewSourceInStyleEditor
(
this
url
line
column
)
;
}
async
viewSourceInStyleEditorByResource
(
stylesheetResource
line
column
)
{
if
(
!
stylesheetResource
|
|
typeof
stylesheetResource
!
=
=
"
object
"
)
{
console
.
warn
(
"
Failed
to
open
source
no
stylesheet
given
"
)
;
return
false
;
}
if
(
typeof
line
!
=
=
"
number
"
)
{
console
.
warn
(
"
No
line
given
when
navigating
to
source
.
If
you
'
re
seeing
this
there
is
a
bug
.
"
)
;
line
=
1
;
column
=
null
;
}
return
viewSource
.
viewSourceInStyleEditor
(
this
stylesheetResource
line
column
)
;
}
async
viewElementInInspector
(
objectGrip
reason
)
{
await
this
.
loadTool
(
"
inspector
"
)
;
const
inspector
=
this
.
getPanel
(
"
inspector
"
)
;
const
nodeFound
=
await
inspector
.
inspectNodeActor
(
objectGrip
reason
)
;
if
(
nodeFound
)
{
await
this
.
selectTool
(
"
inspector
"
reason
)
;
}
}
async
viewGeneratedSourceInDebugger
(
url
)
{
if
(
typeof
url
!
=
=
"
string
"
)
{
console
.
warn
(
"
Failed
to
open
generated
source
no
url
given
"
)
;
return
false
;
}
return
viewSource
.
viewSourceInDebugger
(
this
url
null
null
null
null
)
;
}
async
viewSourceInDebugger
(
sourceURL
sourceLine
sourceColumn
sourceId
reason
)
{
if
(
typeof
sourceURL
!
=
=
"
string
"
&
&
typeof
sourceId
!
=
=
"
string
"
)
{
console
.
warn
(
"
Failed
to
open
generated
source
no
url
/
id
given
"
)
;
return
false
;
}
if
(
typeof
sourceLine
!
=
=
"
number
"
)
{
console
.
warn
(
"
No
line
given
when
navigating
to
source
.
If
you
'
re
seeing
this
there
is
a
bug
.
"
)
;
sourceLine
=
1
;
sourceColumn
=
null
;
}
return
viewSource
.
viewSourceInDebugger
(
this
sourceURL
sourceLine
sourceColumn
sourceId
reason
)
;
}
viewSource
(
sourceURL
sourceLine
sourceColumn
)
{
return
viewSource
.
viewSource
(
this
sourceURL
sourceLine
sourceColumn
)
;
}
async
getNetMonitorAPI
(
)
{
const
netPanel
=
this
.
getPanel
(
"
netmonitor
"
)
;
if
(
netPanel
)
{
return
netPanel
.
panelWin
.
Netmonitor
.
api
;
}
if
(
this
.
_netMonitorAPI
)
{
return
this
.
_netMonitorAPI
;
}
this
.
_netMonitorAPI
=
new
NetMonitorAPI
(
)
;
await
this
.
_netMonitorAPI
.
connect
(
this
)
;
return
this
.
_netMonitorAPI
;
}
async
getHARFromNetMonitor
(
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
let
har
=
await
netMonitor
.
getHar
(
)
;
har
=
har
|
|
buildHarLog
(
Services
.
appinfo
)
;
return
har
.
log
;
}
async
addRequestFinishedListener
(
listener
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
netMonitor
.
addRequestFinishedListener
(
listener
)
;
}
async
removeRequestFinishedListener
(
listener
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
netMonitor
.
removeRequestFinishedListener
(
listener
)
;
const
netPanel
=
this
.
getPanel
(
"
netmonitor
"
)
;
const
hasListeners
=
netMonitor
.
hasRequestFinishedListeners
(
)
;
if
(
this
.
_netMonitorAPI
&
&
!
hasListeners
&
&
!
netPanel
)
{
this
.
_netMonitorAPI
.
destroy
(
)
;
this
.
_netMonitorAPI
=
null
;
}
}
async
fetchResponseContent
(
requestId
)
{
const
netMonitor
=
await
this
.
getNetMonitorAPI
(
)
;
return
netMonitor
.
fetchResponseContent
(
requestId
)
;
}
listWebExtensions
(
)
{
return
Array
.
from
(
this
.
_webExtensions
)
.
map
(
(
[
uuid
{
name
pref
}
]
)
=
>
{
return
{
uuid
name
pref
}
;
}
)
;
}
registerWebExtension
(
extensionUUID
{
name
pref
}
)
{
this
.
_webExtensions
.
set
(
extensionUUID
{
name
pref
}
)
;
this
.
emit
(
"
webextension
-
registered
"
extensionUUID
)
;
}
unregisterWebExtension
(
extensionUUID
)
{
this
.
_webExtensions
.
delete
(
extensionUUID
)
;
this
.
emit
(
"
webextension
-
unregistered
"
extensionUUID
)
;
}
isWebExtensionEnabled
(
extensionUUID
)
{
const
extInfo
=
this
.
_webExtensions
.
get
(
extensionUUID
)
;
return
extInfo
&
&
Services
.
prefs
.
getBoolPref
(
extInfo
.
pref
false
)
;
}
getTelemetryPanelNameOrOther
(
id
)
{
if
(
!
this
.
_toolNames
)
{
const
definitions
=
gDevTools
.
getToolDefinitionArray
(
)
;
const
definitionIds
=
definitions
.
map
(
definition
=
>
definition
.
id
)
;
this
.
_toolNames
=
new
Set
(
definitionIds
)
;
}
if
(
!
this
.
_toolNames
.
has
(
id
)
)
{
return
"
other
"
;
}
return
id
;
}
_setDebugTargetData
(
)
{
if
(
this
.
hostType
=
=
=
Toolbox
.
HostType
.
PAGE
|
|
this
.
_descriptorFront
.
isWebExtensionDescriptor
)
{
this
.
component
.
setDebugTargetData
(
this
.
_getDebugTargetData
(
)
)
;
}
}
_onResourceAvailable
(
resources
)
{
let
errors
=
this
.
_errorCount
|
|
0
;
const
{
TYPES
}
=
this
.
resourceCommand
;
for
(
const
resource
of
resources
)
{
const
{
resourceType
}
=
resource
;
if
(
resourceType
=
=
=
TYPES
.
ERROR_MESSAGE
&
&
resource
.
pageError
.
error
)
{
errors
+
+
;
continue
;
}
if
(
resourceType
=
=
=
TYPES
.
CONSOLE_MESSAGE
)
{
const
{
level
}
=
resource
;
if
(
level
=
=
=
"
error
"
|
|
level
=
=
=
"
exception
"
|
|
level
=
=
=
"
assert
"
)
{
errors
+
+
;
}
if
(
level
=
=
=
"
clear
"
)
{
errors
=
0
;
}
}
if
(
resourceType
=
=
=
TYPES
.
DOCUMENT_EVENT
&
&
resource
.
name
=
=
=
"
will
-
navigate
"
&
&
resource
.
targetFront
.
isTopLevel
)
{
this
.
_onWillNavigate
(
{
isFrameSwitching
:
resource
.
isFrameSwitching
}
)
;
errors
=
0
;
}
if
(
resourceType
=
=
=
TYPES
.
DOCUMENT_EVENT
&
&
!
resource
.
isFrameSwitching
&
&
resource
.
name
=
=
=
"
dom
-
interactive
"
)
{
setTimeout
(
(
)
=
>
{
if
(
resource
.
targetFront
.
isDestroyed
(
)
)
{
return
;
}
this
.
_updateFrames
(
{
frameData
:
{
id
:
resource
.
targetFront
.
actorID
url
:
resource
.
targetFront
.
url
title
:
resource
.
targetFront
.
title
}
}
)
;
if
(
resource
.
targetFront
.
isTopLevel
)
{
this
.
_refreshHostTitle
(
)
;
this
.
_setDebugTargetData
(
)
;
}
}
0
)
;
}
if
(
resourceType
=
=
TYPES
.
THREAD_STATE
)
{
this
.
_onThreadStateChanged
(
resource
)
;
}
if
(
resourceType
=
=
TYPES
.
JSTRACER_STATE
)
{
this
.
_onTracingStateChanged
(
resource
)
;
}
}
this
.
setErrorCount
(
errors
)
;
}
_onResourceUpdated
(
resources
)
{
let
errors
=
this
.
_errorCount
|
|
0
;
for
(
const
{
update
}
of
resources
)
{
if
(
update
.
resourceType
=
=
=
this
.
resourceCommand
.
TYPES
.
NETWORK_EVENT
&
&
update
.
resourceUpdates
.
status
&
&
update
.
resourceUpdates
.
status
.
toString
(
)
.
match
(
REGEX_4XX_5XX
)
)
{
errors
+
+
;
}
}
this
.
setErrorCount
(
errors
)
;
}
setErrorCount
(
count
)
{
if
(
!
this
.
component
|
|
this
.
_errorCount
=
=
=
count
)
{
return
;
}
this
.
_errorCount
=
count
;
this
.
updateErrorCountButton
(
)
;
this
.
_throttledSetToolboxButtons
(
)
;
}
}
;
