"
use
strict
"
;
const
{
AddonManager
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
AddonManager
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
TABS_REORDERED_SCALAR
=
"
devtools
.
toolbox
.
tabs_reordered
"
;
const
PREFERENCE_NAME
=
"
devtools
.
toolbox
.
tabsOrder
"
;
class
ToolboxTabsOrderManager
{
constructor
(
toolbox
onOrderUpdated
panelDefinitions
)
{
this
.
toolbox
=
toolbox
;
this
.
onOrderUpdated
=
onOrderUpdated
;
this
.
currentPanelDefinitions
=
panelDefinitions
|
|
[
]
;
this
.
onMouseDown
=
this
.
onMouseDown
.
bind
(
this
)
;
this
.
onMouseMove
=
this
.
onMouseMove
.
bind
(
this
)
;
this
.
onMouseUp
=
this
.
onMouseUp
.
bind
(
this
)
;
Services
.
prefs
.
addObserver
(
PREFERENCE_NAME
this
.
onOrderUpdated
)
;
this
.
telemetry
=
new
Telemetry
(
)
;
}
async
destroy
(
)
{
Services
.
prefs
.
removeObserver
(
PREFERENCE_NAME
this
.
onOrderUpdated
)
;
await
this
.
onMouseUp
(
)
;
}
insertBefore
(
target
)
{
const
xBefore
=
this
.
dragTarget
.
offsetLeft
;
this
.
toolboxTabsElement
.
insertBefore
(
this
.
dragTarget
target
)
;
const
xAfter
=
this
.
dragTarget
.
offsetLeft
;
this
.
dragStartX
+
=
xAfter
-
xBefore
;
this
.
isOrderUpdated
=
true
;
}
isFirstTab
(
tabElement
)
{
return
!
tabElement
.
previousSibling
;
}
isLastTab
(
tabElement
)
{
return
(
!
tabElement
.
nextSibling
|
|
tabElement
.
nextSibling
.
id
=
=
=
"
tools
-
chevron
-
menu
-
button
"
)
;
}
isRTL
(
)
{
return
this
.
toolbox
.
direction
=
=
=
"
rtl
"
;
}
async
saveOrderPreference
(
)
{
const
tabs
=
[
.
.
.
this
.
toolboxTabsElement
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
]
;
const
tabIds
=
tabs
.
map
(
tab
=
>
tab
.
dataset
.
extensionId
|
|
tab
.
dataset
.
id
)
;
const
overflowedTabIds
=
this
.
currentPanelDefinitions
.
filter
(
definition
=
>
!
tabs
.
some
(
tab
=
>
tab
.
dataset
.
id
=
=
=
definition
.
id
)
)
.
map
(
definition
=
>
definition
.
extensionId
|
|
definition
.
id
)
;
const
currentTabIds
=
tabIds
.
concat
(
overflowedTabIds
)
;
const
dragTargetId
=
this
.
dragTarget
.
dataset
.
extensionId
|
|
this
.
dragTarget
.
dataset
.
id
;
const
prefIds
=
getTabsOrderFromPreference
(
)
;
const
absoluteIds
=
toAbsoluteOrder
(
prefIds
currentTabIds
dragTargetId
)
;
const
extensions
=
await
AddonManager
.
getAllAddons
(
)
;
const
definitions
=
gDevTools
.
getToolDefinitionArray
(
)
;
const
result
=
absoluteIds
.
filter
(
id
=
>
definitions
.
find
(
d
=
>
id
=
=
=
(
d
.
extensionId
|
|
d
.
id
)
)
|
|
extensions
.
find
(
e
=
>
id
=
=
=
e
.
id
)
)
;
Services
.
prefs
.
setCharPref
(
PREFERENCE_NAME
result
.
join
(
"
"
)
)
;
}
setCurrentPanelDefinitions
(
currentPanelDefinitions
)
{
this
.
currentPanelDefinitions
=
currentPanelDefinitions
;
}
onMouseDown
(
e
)
{
if
(
!
e
.
target
.
classList
.
contains
(
"
devtools
-
tab
"
)
)
{
return
;
}
this
.
dragStartX
=
e
.
pageX
;
this
.
dragTarget
=
e
.
target
;
this
.
previousPageX
=
e
.
pageX
;
this
.
toolboxContainerElement
=
this
.
dragTarget
.
closest
(
"
#
toolbox
-
container
"
)
;
this
.
toolboxTabsElement
=
this
.
dragTarget
.
closest
(
"
.
toolbox
-
tabs
"
)
;
this
.
isOrderUpdated
=
false
;
this
.
eventTarget
=
this
.
dragTarget
.
ownerGlobal
.
top
;
this
.
eventTarget
.
addEventListener
(
"
mousemove
"
this
.
onMouseMove
)
;
this
.
eventTarget
.
addEventListener
(
"
mouseup
"
this
.
onMouseUp
)
;
this
.
toolboxContainerElement
.
classList
.
add
(
"
tabs
-
reordering
"
)
;
}
onMouseMove
(
e
)
{
const
diffPageX
=
e
.
pageX
-
this
.
previousPageX
;
let
dragTargetCenterX
=
this
.
dragTarget
.
offsetLeft
+
diffPageX
+
this
.
dragTarget
.
clientWidth
/
2
;
let
isDragTargetPreviousSibling
=
false
;
const
tabElements
=
this
.
toolboxTabsElement
.
querySelectorAll
(
"
.
devtools
-
tab
"
)
;
const
firstElement
=
tabElements
[
0
]
;
const
firstElementCenterX
=
firstElement
.
offsetLeft
+
firstElement
.
clientWidth
/
2
;
const
lastElement
=
tabElements
[
tabElements
.
length
-
1
]
;
const
lastElementCenterX
=
lastElement
.
offsetLeft
+
lastElement
.
clientWidth
/
2
;
const
max
=
Math
.
max
(
firstElementCenterX
lastElementCenterX
)
;
const
min
=
Math
.
min
(
firstElementCenterX
lastElementCenterX
)
;
dragTargetCenterX
=
Math
.
min
(
max
dragTargetCenterX
)
;
dragTargetCenterX
=
Math
.
max
(
min
dragTargetCenterX
)
;
for
(
const
tabElement
of
tabElements
)
{
if
(
tabElement
=
=
=
this
.
dragTarget
)
{
isDragTargetPreviousSibling
=
true
;
continue
;
}
const
anotherCenterX
=
tabElement
.
offsetLeft
+
tabElement
.
clientWidth
/
2
;
const
distanceWithDragTarget
=
Math
.
abs
(
dragTargetCenterX
-
anotherCenterX
)
;
const
isReplaceable
=
distanceWithDragTarget
<
tabElement
.
clientWidth
/
3
;
if
(
isReplaceable
)
{
const
replaceableElement
=
isDragTargetPreviousSibling
?
tabElement
.
nextSibling
:
tabElement
;
this
.
insertBefore
(
replaceableElement
)
;
break
;
}
}
let
distance
=
e
.
pageX
-
this
.
dragStartX
;
const
isFirstTab
=
this
.
isFirstTab
(
this
.
dragTarget
)
;
const
isLastTab
=
this
.
isLastTab
(
this
.
dragTarget
)
;
const
isLeftmostTab
=
this
.
isRTL
(
)
?
isLastTab
:
isFirstTab
;
const
isRightmostTab
=
this
.
isRTL
(
)
?
isFirstTab
:
isLastTab
;
if
(
(
isLeftmostTab
&
&
distance
<
0
)
|
|
(
isRightmostTab
&
&
distance
>
0
)
)
{
distance
=
0
;
}
this
.
dragTarget
.
style
.
left
=
{
distance
}
px
;
this
.
previousPageX
=
e
.
pageX
;
}
async
onMouseUp
(
)
{
if
(
!
this
.
dragTarget
)
{
return
;
}
if
(
this
.
isOrderUpdated
)
{
await
this
.
saveOrderPreference
(
)
;
const
toolId
=
this
.
dragTarget
.
dataset
.
extensionId
|
|
this
.
dragTarget
.
dataset
.
id
;
this
.
telemetry
.
keyedScalarAdd
(
TABS_REORDERED_SCALAR
toolId
1
)
;
}
this
.
eventTarget
.
removeEventListener
(
"
mousemove
"
this
.
onMouseMove
)
;
this
.
eventTarget
.
removeEventListener
(
"
mouseup
"
this
.
onMouseUp
)
;
this
.
toolboxContainerElement
.
classList
.
remove
(
"
tabs
-
reordering
"
)
;
this
.
dragTarget
.
style
.
left
=
null
;
this
.
dragTarget
=
null
;
this
.
toolboxContainerElement
=
null
;
this
.
toolboxTabsElement
=
null
;
this
.
eventTarget
=
null
;
}
}
function
getTabsOrderFromPreference
(
)
{
const
pref
=
Services
.
prefs
.
getCharPref
(
PREFERENCE_NAME
"
"
)
;
return
pref
?
pref
.
split
(
"
"
)
:
[
]
;
}
function
sortPanelDefinitions
(
definitions
)
{
const
toolIds
=
getTabsOrderFromPreference
(
)
;
return
definitions
.
sort
(
(
a
b
)
=
>
{
let
orderA
=
toolIds
.
indexOf
(
a
.
extensionId
|
|
a
.
id
)
;
let
orderB
=
toolIds
.
indexOf
(
b
.
extensionId
|
|
b
.
id
)
;
orderA
=
orderA
<
0
?
Number
.
MAX_VALUE
:
orderA
;
orderB
=
orderB
<
0
?
Number
.
MAX_VALUE
:
orderB
;
return
orderA
-
orderB
;
}
)
;
}
function
toAbsoluteOrder
(
prefIds
currentTabIds
dragTargetId
)
{
currentTabIds
=
[
.
.
.
currentTabIds
]
;
let
indexAtCurrentTabs
=
0
;
for
(
const
prefId
of
prefIds
)
{
if
(
prefId
=
=
=
dragTargetId
)
{
}
else
if
(
currentTabIds
.
includes
(
prefId
)
)
{
indexAtCurrentTabs
=
currentTabIds
.
indexOf
(
prefId
)
+
1
;
}
else
{
currentTabIds
.
splice
(
indexAtCurrentTabs
0
prefId
)
;
indexAtCurrentTabs
+
=
1
;
}
}
return
currentTabIds
;
}
module
.
exports
.
ToolboxTabsOrderManager
=
ToolboxTabsOrderManager
;
module
.
exports
.
sortPanelDefinitions
=
sortPanelDefinitions
;
module
.
exports
.
toAbsoluteOrder
=
toAbsoluteOrder
;
