"
use
strict
"
;
var
{
loader
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
loader
.
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
var
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
var
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
var
{
Toolbox
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
DebuggerClient
}
=
require
(
"
devtools
/
shared
/
client
/
debugger
-
client
"
)
;
var
{
PrefsHelper
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
STATUS_REVEAL_TIME
=
15000
;
var
Prefs
=
new
PrefsHelper
(
"
devtools
.
debugger
"
{
chromeDebuggingHost
:
[
"
Char
"
"
chrome
-
debugging
-
host
"
]
chromeDebuggingWebSocket
:
[
"
Bool
"
"
chrome
-
debugging
-
websocket
"
]
}
)
;
var
gToolbox
gClient
;
function
appendStatusMessage
(
msg
)
{
const
statusMessage
=
document
.
getElementById
(
"
status
-
message
"
)
;
statusMessage
.
value
+
=
msg
+
"
\
n
"
;
if
(
msg
.
stack
)
{
statusMessage
.
value
+
=
msg
.
stack
+
"
\
n
"
;
}
}
function
toggleStatusMessage
(
visible
=
true
)
{
const
statusMessageContainer
=
document
.
getElementById
(
"
status
-
message
-
container
"
)
;
statusMessageContainer
.
hidden
=
!
visible
;
}
function
revealStatusMessage
(
)
{
toggleStatusMessage
(
true
)
;
}
function
hideStatusMessage
(
)
{
toggleStatusMessage
(
false
)
;
}
var
connect
=
async
function
(
)
{
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
port
=
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_PORT
"
)
;
const
addonID
=
env
.
get
(
"
MOZ_BROWSER_TOOLBOX_ADDONID
"
)
;
if
(
!
port
)
{
throw
new
Error
(
"
Must
pass
a
port
in
an
env
variable
with
MOZ_BROWSER_TOOLBOX_PORT
"
)
;
}
const
host
=
Prefs
.
chromeDebuggingHost
;
const
webSocket
=
Prefs
.
chromeDebuggingWebSocket
;
appendStatusMessage
(
Connecting
to
{
host
}
:
{
port
}
ws
:
{
webSocket
}
)
;
const
transport
=
await
DebuggerClient
.
socketConnect
(
{
host
port
webSocket
}
)
;
gClient
=
new
DebuggerClient
(
transport
)
;
appendStatusMessage
(
"
Start
protocol
client
for
connection
"
)
;
await
gClient
.
connect
(
)
;
appendStatusMessage
(
"
Get
root
form
for
toolbox
"
)
;
if
(
addonID
)
{
const
{
addons
}
=
await
gClient
.
listAddons
(
)
;
const
addonActor
=
addons
.
filter
(
addon
=
>
addon
.
id
=
=
=
addonID
)
.
pop
(
)
;
const
isBrowsingContext
=
addonActor
.
isWebExtension
;
await
openToolbox
(
{
form
:
addonActor
chrome
:
true
isBrowsingContext
}
)
;
}
else
{
const
response
=
await
gClient
.
getProcess
(
)
;
await
openToolbox
(
{
form
:
response
.
form
chrome
:
true
}
)
;
}
}
;
function
setPrefDefaults
(
)
{
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
showUserAgentStyles
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
performance
.
ui
.
show
-
platform
-
data
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
showAllAnonymousContent
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
browser
.
dom
.
window
.
dump
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
command
-
button
-
noautohide
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
source
-
maps
-
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
new
-
debugger
-
frontend
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
preference
.
new
-
panel
-
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
layout
.
css
.
emulate
-
moz
-
box
-
with
-
flex
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
accessibility
.
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
performance
.
enabled
"
false
)
;
}
window
.
addEventListener
(
"
load
"
async
function
(
)
{
const
cmdClose
=
document
.
getElementById
(
"
toolbox
-
cmd
-
close
"
)
;
cmdClose
.
addEventListener
(
"
command
"
onCloseCommand
)
;
setPrefDefaults
(
)
;
const
delayedStatusReveal
=
setTimeout
(
revealStatusMessage
STATUS_REVEAL_TIME
)
;
try
{
await
connect
(
)
;
clearTimeout
(
delayedStatusReveal
)
;
hideStatusMessage
(
)
;
}
catch
(
e
)
{
clearTimeout
(
delayedStatusReveal
)
;
appendStatusMessage
(
e
)
;
revealStatusMessage
(
)
;
console
.
error
(
e
)
;
}
}
{
once
:
true
}
)
;
function
onCloseCommand
(
event
)
{
window
.
close
(
)
;
}
async
function
openToolbox
(
{
form
chrome
isBrowsingContext
}
)
{
let
options
=
{
form
:
form
client
:
gClient
chrome
:
chrome
isBrowsingContext
:
isBrowsingContext
}
;
appendStatusMessage
(
Create
toolbox
target
:
{
JSON
.
stringify
(
arguments
null
2
)
}
)
;
const
target
=
await
TargetFactory
.
forRemoteTab
(
options
)
;
const
frame
=
document
.
getElementById
(
"
toolbox
-
iframe
"
)
;
const
selectedTool
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
browsertoolbox
.
panel
"
Services
.
prefs
.
getCharPref
(
"
devtools
.
toolbox
.
selectedTool
"
"
jsdebugger
"
)
)
;
options
=
{
customIframe
:
frame
}
;
appendStatusMessage
(
Show
toolbox
with
{
selectedTool
}
selected
)
;
const
toolbox
=
await
gDevTools
.
showToolbox
(
target
selectedTool
Toolbox
.
HostType
.
CUSTOM
options
)
;
onNewToolbox
(
toolbox
)
;
}
function
onNewToolbox
(
toolbox
)
{
gToolbox
=
toolbox
;
bindToolboxHandlers
(
)
;
raise
(
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
testScript
=
env
.
get
(
"
MOZ_TOOLBOX_TEST_SCRIPT
"
)
;
if
(
testScript
)
{
const
prefName
=
"
devtools
.
browser
-
toolbox
.
allow
-
unsafe
-
script
"
;
if
(
Services
.
prefs
.
getPrefType
(
prefName
)
=
=
Services
.
prefs
.
PREF_BOOL
&
&
Services
.
prefs
.
getBoolPref
(
prefName
)
=
=
=
true
)
{
evaluateTestScript
(
testScript
toolbox
)
;
}
}
}
function
evaluateTestScript
(
script
toolbox
)
{
const
sandbox
=
Cu
.
Sandbox
(
window
)
;
sandbox
.
window
=
window
;
sandbox
.
toolbox
=
toolbox
;
sandbox
.
ChromeUtils
=
ChromeUtils
;
Cu
.
evalInSandbox
(
script
sandbox
)
;
}
async
function
bindToolboxHandlers
(
)
{
gToolbox
.
once
(
"
destroyed
"
quitApp
)
;
window
.
addEventListener
(
"
unload
"
onUnload
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
)
{
updateBadgeText
(
false
)
;
const
panel
=
await
gToolbox
.
getPanelWhenReady
(
"
jsdebugger
"
)
;
setupThreadListeners
(
panel
)
;
}
}
function
setupThreadListeners
(
panel
)
{
updateBadgeText
(
panel
.
isPaused
(
)
)
;
const
onPaused
=
updateBadgeText
.
bind
(
null
true
)
;
const
onResumed
=
updateBadgeText
.
bind
(
null
false
)
;
gToolbox
.
target
.
on
(
"
thread
-
paused
"
onPaused
)
;
gToolbox
.
target
.
on
(
"
thread
-
resumed
"
onResumed
)
;
panel
.
once
(
"
destroyed
"
(
)
=
>
{
gToolbox
.
target
.
off
(
"
thread
-
paused
"
onPaused
)
;
gToolbox
.
target
.
off
(
"
thread
-
resumed
"
onResumed
)
;
}
)
;
}
function
updateBadgeText
(
paused
)
{
const
dockSupport
=
Cc
[
"
mozilla
.
org
/
widget
/
macdocksupport
;
1
"
]
.
getService
(
Ci
.
nsIMacDockSupport
)
;
dockSupport
.
badgeText
=
paused
?
"
"
:
"
"
;
}
function
onUnload
(
)
{
window
.
removeEventListener
(
"
unload
"
onUnload
)
;
window
.
removeEventListener
(
"
message
"
onMessage
)
;
const
cmdClose
=
document
.
getElementById
(
"
toolbox
-
cmd
-
close
"
)
;
cmdClose
.
removeEventListener
(
"
command
"
onCloseCommand
)
;
gToolbox
.
destroy
(
)
;
}
function
onMessage
(
event
)
{
try
{
const
json
=
JSON
.
parse
(
event
.
data
)
;
switch
(
json
.
name
)
{
case
"
toolbox
-
raise
"
:
raise
(
)
;
break
;
case
"
toolbox
-
title
"
:
setTitle
(
json
.
data
.
value
)
;
break
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
window
.
addEventListener
(
"
message
"
onMessage
)
;
function
raise
(
)
{
window
.
focus
(
)
;
}
function
setTitle
(
title
)
{
document
.
title
=
title
;
}
function
quitApp
(
)
{
const
quit
=
Cc
[
"
mozilla
.
org
/
supports
-
PRBool
;
1
"
]
.
createInstance
(
Ci
.
nsISupportsPRBool
)
;
Services
.
obs
.
notifyObservers
(
quit
"
quit
-
application
-
requested
"
)
;
const
shouldProceed
=
!
quit
.
data
;
if
(
shouldProceed
)
{
Services
.
startup
.
quit
(
Ci
.
nsIAppStartup
.
eForceQuit
)
;
}
}
