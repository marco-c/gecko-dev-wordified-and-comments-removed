"
use
strict
"
;
const
SCRATCHPAD_CONTEXT_CONTENT
=
1
;
const
SCRATCHPAD_CONTEXT_BROWSER
=
2
;
const
BUTTON_POSITION_SAVE
=
0
;
const
BUTTON_POSITION_CANCEL
=
1
;
const
BUTTON_POSITION_DONT_SAVE
=
2
;
const
BUTTON_POSITION_REVERT
=
0
;
const
EVAL_FUNCTION_TIMEOUT
=
1000
;
const
MAXIMUM_FONT_SIZE
=
96
;
const
MINIMUM_FONT_SIZE
=
6
;
const
NORMAL_FONT_SIZE
=
12
;
const
SCRATCHPAD_L10N
=
"
chrome
:
/
/
devtools
/
locale
/
scratchpad
.
properties
"
;
const
DEVTOOLS_CHROME_ENABLED
=
"
devtools
.
chrome
.
enabled
"
;
const
PREF_RECENT_FILES_MAX
=
"
devtools
.
scratchpad
.
recentFilesMax
"
;
const
SHOW_LINE_NUMBERS
=
"
devtools
.
scratchpad
.
lineNumbers
"
;
const
WRAP_TEXT
=
"
devtools
.
scratchpad
.
wrapText
"
;
const
SHOW_TRAILING_SPACE
=
"
devtools
.
scratchpad
.
showTrailingSpace
"
;
const
EDITOR_FONT_SIZE
=
"
devtools
.
scratchpad
.
editorFontSize
"
;
const
ENABLE_AUTOCOMPLETION
=
"
devtools
.
scratchpad
.
enableAutocompletion
"
;
const
TAB_SIZE
=
"
devtools
.
editor
.
tabsize
"
;
const
FALLBACK_CHARSET_LIST
=
"
intl
.
fallbackCharsetList
.
ISO
-
8859
-
1
"
;
const
VARIABLES_VIEW_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
VariablesView
.
xul
"
;
const
{
require
loader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
Editor
=
require
(
"
devtools
/
client
/
sourceeditor
/
editor
"
)
;
const
TargetFactory
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
.
TargetFactory
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
DevToolsWorker
}
=
require
(
"
devtools
/
shared
/
worker
/
worker
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
NetUtil
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
{
ScratchpadManager
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
const
{
OS
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
const
{
Reflect
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
)
;
const
Promise
=
require
(
"
Promise
"
)
;
XPCOMUtils
.
defineConstant
(
this
"
SCRATCHPAD_CONTEXT_CONTENT
"
SCRATCHPAD_CONTEXT_CONTENT
)
;
XPCOMUtils
.
defineConstant
(
this
"
SCRATCHPAD_CONTEXT_BROWSER
"
SCRATCHPAD_CONTEXT_BROWSER
)
;
XPCOMUtils
.
defineConstant
(
this
"
BUTTON_POSITION_SAVE
"
BUTTON_POSITION_SAVE
)
;
XPCOMUtils
.
defineConstant
(
this
"
BUTTON_POSITION_CANCEL
"
BUTTON_POSITION_CANCEL
)
;
XPCOMUtils
.
defineConstant
(
this
"
BUTTON_POSITION_DONT_SAVE
"
BUTTON_POSITION_DONT_SAVE
)
;
XPCOMUtils
.
defineConstant
(
this
"
BUTTON_POSITION_REVERT
"
BUTTON_POSITION_REVERT
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
VariablesViewController
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerServer
"
"
devtools
/
server
/
main
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
DebuggerClient
"
"
devtools
/
shared
/
client
/
debugger
-
client
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
EnvironmentClient
"
"
devtools
/
shared
/
client
/
environment
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
ObjectClient
"
"
devtools
/
shared
/
client
/
object
-
client
"
)
;
loader
.
lazyRequireGetter
(
this
"
HUDService
"
"
devtools
/
client
/
webconsole
/
hudservice
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
openDocLink
"
"
devtools
/
client
/
shared
/
link
"
true
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
REMOTE_TIMEOUT
"
(
)
=
>
Services
.
prefs
.
getIntPref
(
"
devtools
.
debugger
.
remote
-
timeout
"
)
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ShortcutUtils
"
"
resource
:
/
/
gre
/
modules
/
ShortcutUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Reflect
"
"
resource
:
/
/
gre
/
modules
/
reflect
.
jsm
"
)
;
var
WebConsoleUtils
=
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
.
Utils
;
var
Scratchpad
=
{
_instanceId
:
null
_initialWindowTitle
:
document
.
title
_dirty
:
false
_scanModeLine
:
function
SP__scanModeLine
(
aLine
=
"
"
)
{
aLine
=
aLine
.
trim
(
)
;
const
obj
=
{
}
;
const
ch1
=
aLine
.
charAt
(
0
)
;
const
ch2
=
aLine
.
charAt
(
1
)
;
if
(
ch1
!
=
=
"
/
"
|
|
(
ch2
!
=
=
"
*
"
&
&
ch2
!
=
=
"
/
"
)
)
{
return
obj
;
}
aLine
=
aLine
.
replace
(
/
^
\
/
\
/
/
"
"
)
.
replace
(
/
^
\
/
\
*
/
"
"
)
.
replace
(
/
\
*
\
/
/
"
"
)
;
aLine
.
split
(
"
"
)
.
forEach
(
pair
=
>
{
const
[
key
val
]
=
pair
.
split
(
"
:
"
)
;
if
(
key
&
&
val
)
{
obj
[
key
.
trim
(
)
]
=
val
.
trim
(
)
;
}
}
)
;
return
obj
;
}
_setupPopupShowingListeners
:
function
SP_setupPopupShowing
(
)
{
const
elementIDs
=
[
"
sp
-
menu_editpopup
"
"
scratchpad
-
text
-
popup
"
]
;
for
(
const
elementID
of
elementIDs
)
{
const
elem
=
document
.
getElementById
(
elementID
)
;
if
(
elem
)
{
elem
.
addEventListener
(
"
popupshowing
"
function
(
)
{
goUpdateGlobalEditMenuItems
(
)
;
const
commands
=
[
"
cmd_undo
"
"
cmd_redo
"
"
cmd_delete
"
"
cmd_findAgain
"
]
;
commands
.
forEach
(
goUpdateCommand
)
;
}
)
;
}
}
}
_setupCommandListeners
:
function
SP_setupCommands
(
)
{
const
commands
=
{
"
cmd_find
"
:
(
)
=
>
{
goDoCommand
(
"
cmd_find
"
)
;
}
"
cmd_findAgain
"
:
(
)
=
>
{
goDoCommand
(
"
cmd_findAgain
"
)
;
}
"
cmd_gotoLine
"
:
(
)
=
>
{
goDoCommand
(
"
cmd_gotoLine
"
)
;
}
"
sp
-
cmd
-
newWindow
"
:
(
)
=
>
{
Scratchpad
.
openScratchpad
(
)
;
}
"
sp
-
cmd
-
openFile
"
:
(
)
=
>
{
Scratchpad
.
openFile
(
)
;
}
"
sp
-
cmd
-
clearRecentFiles
"
:
(
)
=
>
{
Scratchpad
.
clearRecentFiles
(
)
;
}
"
sp
-
cmd
-
save
"
:
(
)
=
>
{
Scratchpad
.
saveFile
(
)
;
}
"
sp
-
cmd
-
saveas
"
:
(
)
=
>
{
Scratchpad
.
saveFileAs
(
)
;
}
"
sp
-
cmd
-
revert
"
:
(
)
=
>
{
Scratchpad
.
promptRevert
(
)
;
}
"
sp
-
cmd
-
close
"
:
(
)
=
>
{
Scratchpad
.
close
(
)
;
}
"
sp
-
cmd
-
run
"
:
(
)
=
>
{
Scratchpad
.
run
(
)
;
}
"
sp
-
cmd
-
inspect
"
:
(
)
=
>
{
Scratchpad
.
inspect
(
)
;
}
"
sp
-
cmd
-
display
"
:
(
)
=
>
{
Scratchpad
.
display
(
)
;
}
"
sp
-
cmd
-
pprint
"
:
(
)
=
>
{
Scratchpad
.
prettyPrint
(
)
;
}
"
sp
-
cmd
-
contentContext
"
:
(
)
=
>
{
Scratchpad
.
setContentContext
(
)
;
}
"
sp
-
cmd
-
browserContext
"
:
(
)
=
>
{
Scratchpad
.
setBrowserContext
(
)
;
}
"
sp
-
cmd
-
reloadAndRun
"
:
(
)
=
>
{
Scratchpad
.
reloadAndRun
(
)
;
}
"
sp
-
cmd
-
evalFunction
"
:
(
)
=
>
{
Scratchpad
.
evalTopLevelFunction
(
)
;
}
"
sp
-
cmd
-
errorConsole
"
:
(
)
=
>
{
Scratchpad
.
openErrorConsole
(
)
;
}
"
sp
-
cmd
-
webConsole
"
:
(
)
=
>
{
Scratchpad
.
openWebConsole
(
)
;
}
"
sp
-
cmd
-
documentationLink
"
:
(
)
=
>
{
Scratchpad
.
openDocumentationPage
(
)
;
}
"
sp
-
cmd
-
hideSidebar
"
:
(
)
=
>
{
Scratchpad
.
sidebar
.
hide
(
)
;
}
"
sp
-
cmd
-
line
-
numbers
"
:
(
)
=
>
{
Scratchpad
.
toggleEditorOption
(
"
lineNumbers
"
SHOW_LINE_NUMBERS
)
;
}
"
sp
-
cmd
-
wrap
-
text
"
:
(
)
=
>
{
Scratchpad
.
toggleEditorOption
(
"
lineWrapping
"
WRAP_TEXT
)
;
}
"
sp
-
cmd
-
highlight
-
trailing
-
space
"
:
(
)
=
>
{
Scratchpad
.
toggleEditorOption
(
"
showTrailingSpace
"
SHOW_TRAILING_SPACE
)
;
}
"
sp
-
cmd
-
larger
-
font
"
:
(
)
=
>
{
Scratchpad
.
increaseFontSize
(
)
;
}
"
sp
-
cmd
-
smaller
-
font
"
:
(
)
=
>
{
Scratchpad
.
decreaseFontSize
(
)
;
}
"
sp
-
cmd
-
normal
-
font
"
:
(
)
=
>
{
Scratchpad
.
normalFontSize
(
)
;
}
}
;
for
(
const
command
in
commands
)
{
const
elem
=
document
.
getElementById
(
command
)
;
if
(
elem
)
{
elem
.
addEventListener
(
"
command
"
commands
[
command
]
)
;
}
}
}
_updateViewMenuItems
:
function
SP_updateViewMenuItems
(
)
{
this
.
_updateViewMenuItem
(
SHOW_LINE_NUMBERS
"
sp
-
menu
-
line
-
numbers
"
)
;
this
.
_updateViewMenuItem
(
WRAP_TEXT
"
sp
-
menu
-
word
-
wrap
"
)
;
this
.
_updateViewMenuItem
(
SHOW_TRAILING_SPACE
"
sp
-
menu
-
highlight
-
trailing
-
space
"
)
;
this
.
_updateViewFontMenuItem
(
MINIMUM_FONT_SIZE
"
sp
-
cmd
-
smaller
-
font
"
)
;
this
.
_updateViewFontMenuItem
(
MAXIMUM_FONT_SIZE
"
sp
-
cmd
-
larger
-
font
"
)
;
}
_updateViewMenuItem
:
function
SP_updateViewMenuItem
(
preferenceName
menuId
)
{
const
checked
=
Services
.
prefs
.
getBoolPref
(
preferenceName
)
;
if
(
checked
)
{
document
.
getElementById
(
menuId
)
.
setAttribute
(
"
checked
"
true
)
;
}
else
{
document
.
getElementById
(
menuId
)
.
removeAttribute
(
"
checked
"
)
;
}
}
_updateViewFontMenuItem
:
function
SP_updateViewFontMenuItem
(
fontSize
commandId
)
{
const
prefFontSize
=
Services
.
prefs
.
getIntPref
(
EDITOR_FONT_SIZE
)
;
if
(
prefFontSize
=
=
=
fontSize
)
{
document
.
getElementById
(
commandId
)
.
setAttribute
(
"
disabled
"
true
)
;
}
}
executionContext
:
SCRATCHPAD_CONTEXT_CONTENT
initialized
:
false
get
dirty
(
)
{
const
clean
=
this
.
editor
&
&
this
.
editor
.
isClean
(
)
;
return
this
.
_dirty
|
|
!
clean
;
}
set
dirty
(
aValue
)
{
this
.
_dirty
=
aValue
;
if
(
!
aValue
&
&
this
.
editor
)
{
this
.
editor
.
setClean
(
)
;
}
this
.
_updateTitle
(
)
;
}
get
notificationBox
(
)
{
return
document
.
getElementById
(
"
scratchpad
-
notificationbox
"
)
;
}
hideMenu
:
function
SP_hideMenu
(
)
{
document
.
getElementById
(
"
sp
-
menu
-
toolbar
"
)
.
style
.
display
=
"
none
"
;
}
showMenu
:
function
SP_showMenu
(
)
{
document
.
getElementById
(
"
sp
-
menu
-
toolbar
"
)
.
style
.
display
=
"
"
;
}
getText
:
function
SP_getText
(
aStart
aEnd
)
{
var
value
=
this
.
editor
.
getText
(
)
;
return
value
.
slice
(
aStart
|
|
0
aEnd
|
|
value
.
length
)
;
}
setFilename
:
function
SP_setFilename
(
aFilename
)
{
this
.
filename
=
aFilename
;
this
.
_updateTitle
(
)
;
}
_updateTitle
:
function
SP__updateTitle
(
)
{
let
title
=
this
.
filename
|
|
this
.
_initialWindowTitle
;
if
(
this
.
dirty
)
{
title
=
"
*
"
+
title
;
}
document
.
title
=
title
;
}
getState
:
function
SP_getState
(
)
{
return
{
filename
:
this
.
filename
text
:
this
.
getText
(
)
executionContext
:
this
.
executionContext
saved
:
!
this
.
dirty
}
;
}
setState
:
function
SP_setState
(
aState
)
{
if
(
aState
.
filename
)
{
this
.
setFilename
(
aState
.
filename
)
;
}
this
.
dirty
=
!
aState
.
saved
;
if
(
aState
.
executionContext
=
=
SCRATCHPAD_CONTEXT_BROWSER
)
{
this
.
setBrowserContext
(
)
;
}
else
{
this
.
setContentContext
(
)
;
}
}
get
browserWindow
(
)
{
return
Services
.
wm
.
getMostRecentWindow
(
gDevTools
.
chromeWindowType
)
;
}
get
gBrowser
(
)
{
const
recentWin
=
this
.
browserWindow
;
return
recentWin
?
recentWin
.
gBrowser
:
null
;
}
get
uniqueName
(
)
{
return
"
Scratchpad
/
"
+
this
.
_instanceId
;
}
get
sidebar
(
)
{
if
(
!
this
.
_sidebar
)
{
this
.
_sidebar
=
new
ScratchpadSidebar
(
this
)
;
}
return
this
.
_sidebar
;
}
setText
:
function
SP_setText
(
value
)
{
return
this
.
editor
.
setText
(
value
)
;
}
evaluate
:
function
SP_evaluate
(
aString
)
{
let
connection
;
if
(
this
.
target
)
{
connection
=
ScratchpadTarget
.
consoleFor
(
this
.
target
)
;
}
else
if
(
this
.
executionContext
=
=
SCRATCHPAD_CONTEXT_CONTENT
)
{
connection
=
ScratchpadTab
.
consoleFor
(
this
.
gBrowser
.
selectedTab
)
;
}
else
{
connection
=
ScratchpadWindow
.
consoleFor
(
this
.
browserWindow
)
;
}
const
evalOptions
=
{
url
:
this
.
uniqueName
}
;
return
connection
.
then
(
(
{
debuggerClient
webConsoleClient
}
)
=
>
{
const
deferred
=
defer
(
)
;
webConsoleClient
.
evaluateJSAsync
(
aString
aResponse
=
>
{
this
.
debuggerClient
=
debuggerClient
;
this
.
webConsoleClient
=
webConsoleClient
;
if
(
aResponse
.
error
)
{
deferred
.
reject
(
aResponse
)
;
}
else
if
(
aResponse
.
exception
!
=
=
null
)
{
deferred
.
resolve
(
[
aString
aResponse
]
)
;
}
else
{
deferred
.
resolve
(
[
aString
undefined
aResponse
.
result
]
)
;
}
}
evalOptions
)
;
return
deferred
.
promise
;
}
)
;
}
execute
:
function
SP_execute
(
)
{
WebConsoleUtils
.
usageCount
+
+
;
const
selection
=
this
.
editor
.
getSelection
(
)
|
|
this
.
getText
(
)
;
return
this
.
evaluate
(
selection
)
;
}
run
:
function
SP_run
(
)
{
const
deferred
=
defer
(
)
;
const
reject
=
aReason
=
>
deferred
.
reject
(
aReason
)
;
this
.
execute
(
)
.
then
(
(
[
aString
aError
aResult
]
)
=
>
{
const
resolve
=
(
)
=
>
deferred
.
resolve
(
[
aString
aError
aResult
]
)
;
if
(
aError
)
{
this
.
writeAsErrorComment
(
aError
)
.
then
(
resolve
reject
)
;
}
else
{
this
.
editor
.
dropSelection
(
)
;
resolve
(
)
;
}
}
reject
)
;
return
deferred
.
promise
;
}
inspect
:
function
SP_inspect
(
)
{
const
deferred
=
defer
(
)
;
const
reject
=
aReason
=
>
deferred
.
reject
(
aReason
)
;
this
.
execute
(
)
.
then
(
(
[
aString
aError
aResult
]
)
=
>
{
const
resolve
=
(
)
=
>
deferred
.
resolve
(
[
aString
aError
aResult
]
)
;
if
(
aError
)
{
this
.
writeAsErrorComment
(
aError
)
.
then
(
resolve
reject
)
;
}
else
{
this
.
editor
.
dropSelection
(
)
;
this
.
sidebar
.
open
(
aString
aResult
)
.
then
(
resolve
reject
)
;
}
}
reject
)
;
return
deferred
.
promise
;
}
reloadAndRun
:
function
SP_reloadAndRun
(
)
{
const
deferred
=
defer
(
)
;
if
(
this
.
executionContext
!
=
=
SCRATCHPAD_CONTEXT_CONTENT
)
{
console
.
error
(
this
.
strings
.
GetStringFromName
(
"
scratchpadContext
.
invalid
"
)
)
;
return
;
}
const
target
=
TargetFactory
.
forTab
(
this
.
gBrowser
.
selectedTab
)
;
target
.
once
(
"
navigate
"
(
)
=
>
{
this
.
run
(
)
.
then
(
results
=
>
deferred
.
resolve
(
results
)
)
;
}
)
;
target
.
makeRemote
(
)
.
then
(
(
)
=
>
target
.
activeTab
.
reload
(
)
)
;
return
deferred
.
promise
;
}
display
:
function
SP_display
(
)
{
const
deferred
=
defer
(
)
;
const
reject
=
aReason
=
>
deferred
.
reject
(
aReason
)
;
this
.
execute
(
)
.
then
(
(
[
aString
aError
aResult
]
)
=
>
{
const
resolve
=
(
)
=
>
deferred
.
resolve
(
[
aString
aError
aResult
]
)
;
if
(
aError
)
{
this
.
writeAsErrorComment
(
aError
)
.
then
(
resolve
reject
)
;
}
else
if
(
VariablesView
.
isPrimitive
(
{
value
:
aResult
}
)
)
{
this
.
_writePrimitiveAsComment
(
aResult
)
.
then
(
resolve
reject
)
;
}
else
{
const
objectClient
=
new
ObjectClient
(
this
.
debuggerClient
aResult
)
;
objectClient
.
getDisplayString
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
reportError
(
"
display
"
aResponse
)
;
reject
(
aResponse
)
;
}
else
{
this
.
writeAsComment
(
aResponse
.
displayString
)
;
resolve
(
)
;
}
}
)
;
}
}
reject
)
;
return
deferred
.
promise
;
}
_prettyPrintWorker
:
null
get
prettyPrintWorker
(
)
{
if
(
!
this
.
_prettyPrintWorker
)
{
this
.
_prettyPrintWorker
=
new
DevToolsWorker
(
"
resource
:
/
/
devtools
/
server
/
actors
/
pretty
-
print
-
worker
.
js
"
{
name
:
"
pretty
-
print
"
verbose
:
flags
.
wantLogging
}
)
;
}
return
this
.
_prettyPrintWorker
;
}
prettyPrint
:
function
SP_prettyPrint
(
)
{
const
uglyText
=
this
.
getText
(
)
;
const
tabsize
=
Services
.
prefs
.
getIntPref
(
TAB_SIZE
)
;
return
this
.
prettyPrintWorker
.
performTask
(
"
pretty
-
print
"
{
url
:
"
(
scratchpad
)
"
indent
:
tabsize
source
:
uglyText
}
)
.
then
(
data
=
>
{
this
.
editor
.
setText
(
data
.
code
)
;
}
)
.
catch
(
error
=
>
{
this
.
writeAsErrorComment
(
{
exception
:
error
}
)
;
throw
error
;
}
)
;
}
_parseText
:
function
SP__parseText
(
aText
)
{
try
{
return
Reflect
.
parse
(
aText
)
;
}
catch
(
e
)
{
this
.
writeAsErrorComment
(
{
exception
:
DevToolsUtils
.
safeErrorString
(
e
)
}
)
;
return
false
;
}
}
_containsCursor
:
function
(
aLoc
aCursorPos
)
{
const
lineNumber
=
aCursorPos
.
line
+
1
;
const
columnNumber
=
aCursorPos
.
ch
;
if
(
aLoc
.
start
.
line
<
=
lineNumber
&
&
aLoc
.
end
.
line
>
=
lineNumber
)
{
if
(
aLoc
.
start
.
line
=
=
=
aLoc
.
end
.
line
)
{
return
aLoc
.
start
.
column
<
=
columnNumber
&
&
aLoc
.
end
.
column
>
=
columnNumber
;
}
if
(
aLoc
.
start
.
line
=
=
lineNumber
)
{
return
columnNumber
>
=
aLoc
.
start
.
column
;
}
if
(
aLoc
.
end
.
line
=
=
lineNumber
)
{
return
columnNumber
<
=
aLoc
.
end
.
column
;
}
return
true
;
}
return
false
;
}
_findTopLevelFunction
:
function
SP__findTopLevelFunction
(
aAst
aCursorPos
)
{
for
(
const
statement
of
aAst
.
body
)
{
switch
(
statement
.
type
)
{
case
"
FunctionDeclaration
"
:
if
(
this
.
_containsCursor
(
statement
.
loc
aCursorPos
)
)
{
return
statement
;
}
break
;
case
"
VariableDeclaration
"
:
for
(
const
decl
of
statement
.
declarations
)
{
if
(
!
decl
.
init
)
{
continue
;
}
if
(
(
decl
.
init
.
type
=
=
"
FunctionExpression
"
|
|
decl
.
init
.
type
=
=
"
ArrowFunctionExpression
"
)
&
&
this
.
_containsCursor
(
decl
.
loc
aCursorPos
)
)
{
return
decl
;
}
}
break
;
}
}
return
null
;
}
_getFunctionText
:
function
SP__getFunctionText
(
aFunction
aFullText
)
{
let
functionText
=
"
"
;
let
lineNumber
=
0
;
const
{
start
end
}
=
aFunction
.
loc
;
const
singleLine
=
start
.
line
=
=
=
end
.
line
;
for
(
const
line
of
aFullText
.
split
(
/
\
n
/
g
)
)
{
lineNumber
+
+
;
if
(
singleLine
&
&
start
.
line
=
=
=
lineNumber
)
{
functionText
=
line
.
slice
(
start
.
column
end
.
column
)
;
break
;
}
if
(
start
.
line
=
=
=
lineNumber
)
{
functionText
+
=
line
.
slice
(
start
.
column
)
+
"
\
n
"
;
continue
;
}
if
(
end
.
line
=
=
=
lineNumber
)
{
functionText
+
=
line
.
slice
(
0
end
.
column
)
;
break
;
}
if
(
start
.
line
<
lineNumber
&
&
end
.
line
>
lineNumber
)
{
functionText
+
=
line
+
"
\
n
"
;
}
}
return
functionText
;
}
evalTopLevelFunction
:
function
SP_evalTopLevelFunction
(
)
{
const
text
=
this
.
getText
(
)
;
const
ast
=
this
.
_parseText
(
text
)
;
if
(
!
ast
)
{
return
promise
.
resolve
(
[
text
undefined
undefined
]
)
;
}
const
cursorPos
=
this
.
editor
.
getCursor
(
)
;
const
funcStatement
=
this
.
_findTopLevelFunction
(
ast
cursorPos
)
;
if
(
!
funcStatement
)
{
return
promise
.
resolve
(
[
text
undefined
undefined
]
)
;
}
let
functionText
=
this
.
_getFunctionText
(
funcStatement
text
)
;
if
(
funcStatement
.
type
=
=
"
FunctionDeclaration
"
&
&
!
functionText
.
startsWith
(
"
function
"
)
)
{
functionText
=
"
function
"
+
functionText
;
funcStatement
.
loc
.
start
.
column
-
=
9
;
}
const
from
=
{
line
:
funcStatement
.
loc
.
start
.
line
-
1
ch
:
funcStatement
.
loc
.
start
.
column
}
;
const
to
=
{
line
:
funcStatement
.
loc
.
end
.
line
-
1
ch
:
funcStatement
.
loc
.
end
.
column
}
;
const
marker
=
this
.
editor
.
markText
(
from
to
"
eval
-
text
"
)
;
setTimeout
(
(
)
=
>
marker
.
clear
(
)
EVAL_FUNCTION_TIMEOUT
)
;
return
this
.
evaluate
(
functionText
)
;
}
_writePrimitiveAsComment
:
function
SP__writePrimitiveAsComment
(
aValue
)
{
const
deferred
=
defer
(
)
;
if
(
aValue
.
type
=
=
"
longString
"
)
{
const
client
=
this
.
webConsoleClient
;
client
.
longString
(
aValue
)
.
substring
(
0
aValue
.
length
aResponse
=
>
{
if
(
aResponse
.
error
)
{
reportError
(
"
display
"
aResponse
)
;
deferred
.
reject
(
aResponse
)
;
}
else
{
deferred
.
resolve
(
aResponse
.
substring
)
;
}
}
)
;
}
else
{
deferred
.
resolve
(
aValue
.
type
|
|
aValue
)
;
}
return
deferred
.
promise
.
then
(
aComment
=
>
{
this
.
writeAsComment
(
aComment
)
;
}
)
;
}
writeAsComment
:
function
SP_writeAsComment
(
aValue
)
{
const
value
=
"
\
n
/
*
\
n
"
+
aValue
+
"
\
n
*
/
"
;
if
(
this
.
editor
.
somethingSelected
(
)
)
{
const
from
=
this
.
editor
.
getCursor
(
"
end
"
)
;
this
.
editor
.
replaceSelection
(
this
.
editor
.
getSelection
(
)
+
value
)
;
const
to
=
this
.
editor
.
getPosition
(
this
.
editor
.
getOffset
(
from
)
+
value
.
length
)
;
this
.
editor
.
setSelection
(
from
to
)
;
return
;
}
const
text
=
this
.
editor
.
getText
(
)
;
this
.
editor
.
setText
(
text
+
value
)
;
const
[
from
to
]
=
this
.
editor
.
getPosition
(
text
.
length
(
text
+
value
)
.
length
)
;
this
.
editor
.
setSelection
(
from
to
)
;
}
writeAsErrorComment
:
function
SP_writeAsErrorComment
(
aError
)
{
const
deferred
=
defer
(
)
;
if
(
VariablesView
.
isPrimitive
(
{
value
:
aError
.
exception
}
)
)
{
const
error
=
aError
.
exception
;
const
type
=
error
.
type
;
if
(
type
=
=
"
undefined
"
|
|
type
=
=
"
null
"
|
|
type
=
=
"
Infinity
"
|
|
type
=
=
"
-
Infinity
"
|
|
type
=
=
"
NaN
"
|
|
type
=
=
"
-
0
"
)
{
deferred
.
resolve
(
type
)
;
}
else
if
(
type
=
=
"
longString
"
)
{
deferred
.
resolve
(
error
.
initial
+
"
\
u2026
"
)
;
}
else
{
deferred
.
resolve
(
error
)
;
}
}
else
if
(
"
preview
"
in
aError
.
exception
)
{
const
error
=
aError
.
exception
;
const
stack
=
this
.
_constructErrorStack
(
error
.
preview
)
;
if
(
typeof
aError
.
exceptionMessage
=
=
"
string
"
)
{
deferred
.
resolve
(
aError
.
exceptionMessage
+
stack
)
;
}
else
{
deferred
.
resolve
(
stack
)
;
}
}
else
{
const
objectClient
=
new
ObjectClient
(
this
.
debuggerClient
aError
.
exception
)
;
objectClient
.
getPrototypeAndProperties
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
deferred
.
reject
(
aResponse
)
;
return
;
}
const
{
ownProperties
safeGetterValues
}
=
aResponse
;
const
error
=
Object
.
create
(
null
)
;
for
(
const
key
of
Object
.
keys
(
safeGetterValues
)
)
{
error
[
key
]
=
safeGetterValues
[
key
]
.
getterValue
;
}
for
(
const
key
of
Object
.
keys
(
ownProperties
)
)
{
error
[
key
]
=
ownProperties
[
key
]
.
value
;
}
const
stack
=
this
.
_constructErrorStack
(
error
)
;
if
(
typeof
error
.
message
=
=
"
string
"
)
{
deferred
.
resolve
(
error
.
message
+
stack
)
;
}
else
{
objectClient
.
getDisplayString
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
deferred
.
reject
(
aResponse
)
;
}
else
if
(
typeof
aResponse
.
displayString
=
=
"
string
"
)
{
deferred
.
resolve
(
aResponse
.
displayString
+
stack
)
;
}
else
{
deferred
.
resolve
(
stack
)
;
}
}
)
;
}
}
)
;
}
return
deferred
.
promise
.
then
(
aMessage
=
>
{
console
.
error
(
aMessage
)
;
this
.
writeAsComment
(
"
Exception
:
"
+
aMessage
)
;
}
)
;
}
_constructErrorStack
(
error
)
{
let
stack
;
if
(
typeof
error
.
stack
=
=
"
string
"
&
&
error
.
stack
)
{
stack
=
error
.
stack
;
}
else
if
(
typeof
error
.
fileName
=
=
"
string
"
)
{
stack
=
"
"
+
error
.
fileName
;
if
(
typeof
error
.
lineNumber
=
=
"
number
"
)
{
stack
+
=
"
:
"
+
error
.
lineNumber
;
}
}
else
if
(
typeof
error
.
filename
=
=
"
string
"
)
{
stack
=
"
"
+
error
.
filename
;
if
(
typeof
error
.
lineNumber
=
=
"
number
"
)
{
stack
+
=
"
:
"
+
error
.
lineNumber
;
if
(
typeof
error
.
columnNumber
=
=
"
number
"
)
{
stack
+
=
"
:
"
+
error
.
columnNumber
;
}
}
}
else
if
(
typeof
error
.
lineNumber
=
=
"
number
"
)
{
stack
=
"
"
+
error
.
lineNumber
;
if
(
typeof
error
.
columnNumber
=
=
"
number
"
)
{
stack
+
=
"
:
"
+
error
.
columnNumber
;
}
}
return
stack
?
"
\
n
"
+
stack
.
replace
(
/
\
n
/
"
"
)
:
"
"
;
}
openScratchpad
:
function
SP_openScratchpad
(
)
{
return
ScratchpadManager
.
openScratchpad
(
)
;
}
exportToFile
:
function
SP_exportToFile
(
aFile
aNoConfirmation
aSilentError
aCallback
)
{
if
(
!
aNoConfirmation
&
&
aFile
.
exists
(
)
&
&
!
window
.
confirm
(
this
.
strings
.
GetStringFromName
(
"
export
.
fileOverwriteConfirmation
"
)
)
)
{
return
;
}
const
encoder
=
new
TextEncoder
(
)
;
const
buffer
=
encoder
.
encode
(
this
.
getText
(
)
)
;
const
writePromise
=
OS
.
File
.
writeAtomic
(
aFile
.
path
buffer
{
tmpPath
:
aFile
.
path
+
"
.
tmp
"
}
)
;
writePromise
.
then
(
value
=
>
{
if
(
aCallback
)
{
aCallback
.
call
(
this
Cr
.
NS_OK
)
;
}
}
reason
=
>
{
if
(
!
aSilentError
)
{
window
.
alert
(
this
.
strings
.
GetStringFromName
(
"
saveFile
.
failed
"
)
)
;
}
if
(
aCallback
)
{
aCallback
.
call
(
this
Cr
.
NS_ERROR_UNEXPECTED
)
;
}
}
)
;
}
_getApplicableCharsets
:
function
SP__getApplicableCharsets
(
aBestCharset
=
"
UTF
-
8
"
)
{
const
charsets
=
Services
.
prefs
.
getCharPref
(
FALLBACK_CHARSET_LIST
)
.
split
(
"
"
)
.
filter
(
function
(
value
)
{
return
value
.
length
;
}
)
;
charsets
.
unshift
(
aBestCharset
)
;
return
charsets
;
}
_getUnicodeContent
:
function
SP__getUnicodeContent
(
aContent
aCharsetArray
)
{
const
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
let
content
=
null
;
aCharsetArray
.
some
(
charset
=
>
{
try
{
converter
.
charset
=
charset
;
content
=
converter
.
ConvertToUnicode
(
aContent
)
;
return
true
;
}
catch
(
e
)
{
this
.
notificationBox
.
appendNotification
(
this
.
strings
.
formatStringFromName
(
"
importFromFile
.
convert
.
failed
"
[
charset
]
1
)
"
file
-
import
-
convert
-
failed
"
null
this
.
notificationBox
.
PRIORITY_WARNING_HIGH
null
)
;
}
}
)
;
return
content
;
}
importFromFile
:
function
SP_importFromFile
(
aFile
aSilentError
aCallback
)
{
return
new
Promise
(
resolve
=
>
{
const
channel
=
NetUtil
.
newChannel
(
{
uri
:
NetUtil
.
newURI
(
aFile
)
loadingNode
:
window
.
document
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
;
channel
.
contentType
=
"
application
/
javascript
"
;
this
.
notificationBox
.
removeAllNotifications
(
false
)
;
NetUtil
.
asyncFetch
(
channel
(
aInputStream
aStatus
)
=
>
{
let
content
=
null
;
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
const
charsets
=
this
.
_getApplicableCharsets
(
)
;
content
=
NetUtil
.
readInputStreamToString
(
aInputStream
aInputStream
.
available
(
)
)
;
content
=
this
.
_getUnicodeContent
(
content
charsets
)
;
if
(
!
content
)
{
const
message
=
this
.
strings
.
formatStringFromName
(
"
importFromFile
.
convert
.
failed
"
[
charsets
.
join
(
"
"
)
]
1
)
;
this
.
notificationBox
.
appendNotification
(
message
"
file
-
import
-
convert
-
failed
"
null
this
.
notificationBox
.
PRIORITY_CRITICAL_MEDIUM
null
)
;
if
(
aCallback
)
{
aCallback
.
call
(
this
aStatus
content
)
;
}
resolve
(
[
aStatus
content
]
)
;
return
;
}
const
line
=
content
.
split
(
"
\
n
"
)
[
0
]
;
const
modeline
=
this
.
_scanModeLine
(
line
)
;
const
chrome
=
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_CHROME_ENABLED
)
;
if
(
chrome
&
&
modeline
[
"
-
sp
-
context
"
]
=
=
=
"
browser
"
)
{
this
.
setBrowserContext
(
)
;
}
this
.
editor
.
setText
(
content
)
;
this
.
editor
.
clearHistory
(
)
;
this
.
dirty
=
false
;
document
.
getElementById
(
"
sp
-
cmd
-
revert
"
)
.
setAttribute
(
"
disabled
"
true
)
;
}
else
if
(
!
aSilentError
)
{
window
.
alert
(
this
.
strings
.
GetStringFromName
(
"
openFile
.
failed
"
)
)
;
}
this
.
setFilename
(
aFile
.
path
)
;
this
.
setRecentFile
(
aFile
)
;
if
(
aCallback
)
{
aCallback
.
call
(
this
aStatus
content
)
;
}
resolve
(
[
aStatus
content
]
)
;
}
)
;
}
)
;
}
openFile
:
function
SP_openFile
(
aIndex
)
{
const
promptCallback
=
aFile
=
>
{
this
.
promptSave
(
(
aCloseFile
aSaved
aStatus
)
=
>
{
let
shouldOpen
=
aCloseFile
;
if
(
aSaved
&
&
!
Components
.
isSuccessCode
(
aStatus
)
)
{
shouldOpen
=
false
;
}
if
(
shouldOpen
)
{
let
file
;
if
(
aFile
)
{
file
=
aFile
;
}
else
{
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
const
filePath
=
this
.
getRecentFiles
(
)
[
aIndex
]
;
file
.
initWithPath
(
filePath
)
;
}
if
(
!
file
.
exists
(
)
)
{
this
.
notificationBox
.
appendNotification
(
this
.
strings
.
GetStringFromName
(
"
fileNoLongerExists
.
notification
"
)
"
file
-
no
-
longer
-
exists
"
null
this
.
notificationBox
.
PRIORITY_WARNING_HIGH
null
)
;
this
.
clearFiles
(
aIndex
1
)
;
return
;
}
this
.
importFromFile
(
file
false
)
;
}
}
)
;
}
;
if
(
aIndex
>
-
1
)
{
promptCallback
(
)
;
}
else
{
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
this
.
strings
.
GetStringFromName
(
"
openFile
.
title
"
)
Ci
.
nsIFilePicker
.
modeOpen
)
;
fp
.
defaultString
=
"
"
;
fp
.
appendFilter
(
"
JavaScript
Files
"
"
*
.
js
;
*
.
jsm
;
*
.
json
"
)
;
fp
.
appendFilter
(
"
All
Files
"
"
*
.
*
"
)
;
fp
.
open
(
aResult
=
>
{
if
(
aResult
!
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
promptCallback
(
fp
.
file
)
;
}
}
)
;
}
}
getRecentFiles
:
function
SP_getRecentFiles
(
)
{
const
branch
=
Services
.
prefs
.
getBranch
(
"
devtools
.
scratchpad
.
"
)
;
let
filePaths
=
[
]
;
if
(
branch
.
prefHasUserValue
(
"
recentFilePaths
"
)
)
{
const
data
=
branch
.
getStringPref
(
"
recentFilePaths
"
)
;
filePaths
=
JSON
.
parse
(
data
)
;
}
return
filePaths
;
}
setRecentFile
:
function
SP_setRecentFile
(
aFile
)
{
const
maxRecent
=
Services
.
prefs
.
getIntPref
(
PREF_RECENT_FILES_MAX
)
;
if
(
maxRecent
<
1
)
{
return
;
}
const
filePaths
=
this
.
getRecentFiles
(
)
;
const
filesCount
=
filePaths
.
length
;
const
pathIndex
=
filePaths
.
indexOf
(
aFile
.
path
)
;
if
(
pathIndex
>
-
1
)
{
if
(
pathIndex
=
=
=
(
filesCount
-
1
)
)
{
this
.
populateRecentFilesMenu
(
)
;
return
;
}
filePaths
.
splice
(
pathIndex
1
)
;
}
else
if
(
filesCount
=
=
=
maxRecent
)
{
filePaths
.
shift
(
)
;
}
filePaths
.
push
(
aFile
.
path
)
;
Services
.
prefs
.
getBranch
(
"
devtools
.
scratchpad
.
"
)
.
setStringPref
(
"
recentFilePaths
"
JSON
.
stringify
(
filePaths
)
)
;
}
populateRecentFilesMenu
:
function
SP_populateRecentFilesMenu
(
)
{
const
maxRecent
=
Services
.
prefs
.
getIntPref
(
PREF_RECENT_FILES_MAX
)
;
const
recentFilesMenu
=
document
.
getElementById
(
"
sp
-
open_recent
-
menu
"
)
;
if
(
maxRecent
<
1
)
{
recentFilesMenu
.
setAttribute
(
"
hidden
"
true
)
;
return
;
}
const
recentFilesPopup
=
recentFilesMenu
.
firstChild
;
const
filePaths
=
this
.
getRecentFiles
(
)
;
const
filename
=
this
.
getState
(
)
.
filename
;
recentFilesMenu
.
setAttribute
(
"
disabled
"
true
)
;
while
(
recentFilesPopup
.
hasChildNodes
(
)
)
{
recentFilesPopup
.
firstChild
.
remove
(
)
;
}
if
(
filePaths
.
length
>
0
)
{
recentFilesMenu
.
removeAttribute
(
"
disabled
"
)
;
for
(
let
i
=
filePaths
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
const
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
type
"
"
radio
"
)
;
menuitem
.
setAttribute
(
"
label
"
filePaths
[
i
]
)
;
if
(
filePaths
[
i
]
=
=
=
filename
)
{
menuitem
.
setAttribute
(
"
checked
"
true
)
;
menuitem
.
setAttribute
(
"
disabled
"
true
)
;
}
menuitem
.
addEventListener
(
"
command
"
Scratchpad
.
openFile
.
bind
(
Scratchpad
i
)
)
;
recentFilesPopup
.
appendChild
(
menuitem
)
;
}
recentFilesPopup
.
appendChild
(
document
.
createElement
(
"
menuseparator
"
)
)
;
const
clearItems
=
document
.
createElement
(
"
menuitem
"
)
;
clearItems
.
setAttribute
(
"
id
"
"
sp
-
menu
-
clear_recent
"
)
;
clearItems
.
setAttribute
(
"
label
"
this
.
strings
.
GetStringFromName
(
"
clearRecentMenuItems
.
label
"
)
)
;
clearItems
.
setAttribute
(
"
command
"
"
sp
-
cmd
-
clearRecentFiles
"
)
;
recentFilesPopup
.
appendChild
(
clearItems
)
;
}
}
clearFiles
:
function
SP_clearFile
(
aIndex
aLength
)
{
const
filePaths
=
this
.
getRecentFiles
(
)
;
filePaths
.
splice
(
aIndex
aLength
)
;
Services
.
prefs
.
getBranch
(
"
devtools
.
scratchpad
.
"
)
.
setStringPref
(
"
recentFilePaths
"
JSON
.
stringify
(
filePaths
)
)
;
}
clearRecentFiles
:
function
SP_clearRecentFiles
(
)
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
scratchpad
.
recentFilePaths
"
)
;
}
handleRecentFileMaxChange
:
function
SP_handleRecentFileMaxChange
(
)
{
const
maxRecent
=
Services
.
prefs
.
getIntPref
(
PREF_RECENT_FILES_MAX
)
;
const
menu
=
document
.
getElementById
(
"
sp
-
open_recent
-
menu
"
)
;
if
(
maxRecent
<
1
)
{
menu
.
setAttribute
(
"
hidden
"
true
)
;
}
else
{
if
(
menu
.
hasAttribute
(
"
hidden
"
)
)
{
if
(
!
menu
.
firstChild
.
hasChildNodes
(
)
)
{
this
.
populateRecentFilesMenu
(
)
;
}
menu
.
removeAttribute
(
"
hidden
"
)
;
}
const
filePaths
=
this
.
getRecentFiles
(
)
;
if
(
maxRecent
<
filePaths
.
length
)
{
const
diff
=
filePaths
.
length
-
maxRecent
;
this
.
clearFiles
(
0
diff
)
;
}
}
}
saveFile
:
function
SP_saveFile
(
aCallback
)
{
if
(
!
this
.
filename
)
{
return
this
.
saveFileAs
(
aCallback
)
;
}
return
new
Promise
(
resolve
=
>
{
const
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
this
.
filename
)
;
this
.
exportToFile
(
file
true
false
aStatus
=
>
{
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
this
.
dirty
=
false
;
document
.
getElementById
(
"
sp
-
cmd
-
revert
"
)
.
setAttribute
(
"
disabled
"
true
)
;
this
.
setRecentFile
(
file
)
;
}
if
(
aCallback
)
{
aCallback
(
aStatus
)
;
}
resolve
(
aStatus
)
;
}
)
;
}
)
;
}
saveFileAs
:
function
SP_saveFileAs
(
aCallback
)
{
return
new
Promise
(
resolve
=
>
{
const
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
const
fpCallback
=
aResult
=
>
{
if
(
aResult
!
=
Ci
.
nsIFilePicker
.
returnCancel
)
{
this
.
setFilename
(
fp
.
file
.
path
)
;
this
.
exportToFile
(
fp
.
file
true
false
aStatus
=
>
{
if
(
Components
.
isSuccessCode
(
aStatus
)
)
{
this
.
dirty
=
false
;
this
.
setRecentFile
(
fp
.
file
)
;
}
if
(
aCallback
)
{
aCallback
(
aStatus
)
;
}
resolve
(
aStatus
)
;
}
)
;
}
}
;
fp
.
init
(
window
this
.
strings
.
GetStringFromName
(
"
saveFileAs
"
)
Ci
.
nsIFilePicker
.
modeSave
)
;
fp
.
defaultString
=
"
scratchpad
.
js
"
;
fp
.
appendFilter
(
"
JavaScript
Files
"
"
*
.
js
;
*
.
jsm
;
*
.
json
"
)
;
fp
.
appendFilter
(
"
All
Files
"
"
*
.
*
"
)
;
fp
.
open
(
fpCallback
)
;
}
)
;
}
revertFile
:
function
SP_revertFile
(
aCallback
)
{
const
file
=
Cc
[
"
mozilla
.
org
/
file
/
local
;
1
"
]
.
createInstance
(
Ci
.
nsIFile
)
;
file
.
initWithPath
(
this
.
filename
)
;
if
(
!
file
.
exists
(
)
)
{
return
;
}
this
.
importFromFile
(
file
false
(
aStatus
aContent
)
=
>
{
if
(
aCallback
)
{
aCallback
(
aStatus
)
;
}
}
)
;
}
promptRevert
:
function
SP_promptRervert
(
aCallback
)
{
if
(
this
.
filename
)
{
const
ps
=
Services
.
prompt
;
const
flags
=
ps
.
BUTTON_POS_0
*
ps
.
BUTTON_TITLE_REVERT
+
ps
.
BUTTON_POS_1
*
ps
.
BUTTON_TITLE_CANCEL
;
const
button
=
ps
.
confirmEx
(
window
this
.
strings
.
GetStringFromName
(
"
confirmRevert
.
title
"
)
this
.
strings
.
GetStringFromName
(
"
confirmRevert
"
)
flags
null
null
null
null
{
}
)
;
if
(
button
=
=
BUTTON_POSITION_CANCEL
)
{
if
(
aCallback
)
{
aCallback
(
false
)
;
}
return
;
}
if
(
button
=
=
BUTTON_POSITION_REVERT
)
{
this
.
revertFile
(
aStatus
=
>
{
if
(
aCallback
)
{
aCallback
(
true
aStatus
)
;
}
}
)
;
return
;
}
}
if
(
aCallback
)
{
aCallback
(
false
)
;
}
}
openErrorConsole
:
function
SP_openErrorConsole
(
)
{
HUDService
.
toggleBrowserConsole
(
)
;
}
openWebConsole
:
function
SP_openWebConsole
(
)
{
const
target
=
TargetFactory
.
forTab
(
this
.
gBrowser
.
selectedTab
)
;
gDevTools
.
showToolbox
(
target
"
webconsole
"
)
;
this
.
browserWindow
.
focus
(
)
;
}
setContentContext
:
function
SP_setContentContext
(
)
{
if
(
this
.
executionContext
=
=
SCRATCHPAD_CONTEXT_CONTENT
)
{
return
;
}
const
content
=
document
.
getElementById
(
"
sp
-
menu
-
content
"
)
;
document
.
getElementById
(
"
sp
-
menu
-
browser
"
)
.
removeAttribute
(
"
checked
"
)
;
document
.
getElementById
(
"
sp
-
cmd
-
reloadAndRun
"
)
.
removeAttribute
(
"
disabled
"
)
;
content
.
setAttribute
(
"
checked
"
true
)
;
this
.
executionContext
=
SCRATCHPAD_CONTEXT_CONTENT
;
this
.
notificationBox
.
removeAllNotifications
(
false
)
;
}
setBrowserContext
:
function
SP_setBrowserContext
(
)
{
if
(
this
.
executionContext
=
=
SCRATCHPAD_CONTEXT_BROWSER
)
{
return
;
}
const
browser
=
document
.
getElementById
(
"
sp
-
menu
-
browser
"
)
;
const
reloadAndRun
=
document
.
getElementById
(
"
sp
-
cmd
-
reloadAndRun
"
)
;
document
.
getElementById
(
"
sp
-
menu
-
content
"
)
.
removeAttribute
(
"
checked
"
)
;
reloadAndRun
.
setAttribute
(
"
disabled
"
true
)
;
browser
.
setAttribute
(
"
checked
"
true
)
;
this
.
executionContext
=
SCRATCHPAD_CONTEXT_BROWSER
;
this
.
notificationBox
.
appendNotification
(
this
.
strings
.
GetStringFromName
(
"
browserContext
.
notification
"
)
SCRATCHPAD_CONTEXT_BROWSER
null
this
.
notificationBox
.
PRIORITY_WARNING_HIGH
null
)
;
}
getInnerWindowId
:
function
SP_getInnerWindowId
(
aWindow
)
{
return
aWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
.
currentInnerWindowID
;
}
updateStatusBar
:
function
SP_updateStatusBar
(
aEventType
)
{
var
statusBarField
=
document
.
getElementById
(
"
statusbar
-
line
-
col
"
)
;
const
{
line
ch
}
=
this
.
editor
.
getCursor
(
)
;
statusBarField
.
textContent
=
this
.
strings
.
formatStringFromName
(
"
scratchpad
.
statusBarLineCol
"
[
line
+
1
ch
+
1
]
2
)
;
}
onLoad
:
function
SP_onLoad
(
aEvent
)
{
if
(
aEvent
.
target
!
=
document
)
{
return
;
}
const
chrome
=
Services
.
prefs
.
getBoolPref
(
DEVTOOLS_CHROME_ENABLED
)
;
if
(
chrome
)
{
const
environmentMenu
=
document
.
getElementById
(
"
sp
-
environment
-
menu
"
)
;
const
errorConsoleCommand
=
document
.
getElementById
(
"
sp
-
cmd
-
errorConsole
"
)
;
const
chromeContextCommand
=
document
.
getElementById
(
"
sp
-
cmd
-
browserContext
"
)
;
environmentMenu
.
removeAttribute
(
"
hidden
"
)
;
chromeContextCommand
.
removeAttribute
(
"
disabled
"
)
;
errorConsoleCommand
.
removeAttribute
(
"
disabled
"
)
;
}
let
initialText
=
this
.
strings
.
formatStringFromName
(
"
scratchpadIntro1
"
[
ShortcutUtils
.
prettifyShortcut
(
document
.
getElementById
(
"
sp
-
key
-
run
"
)
true
)
ShortcutUtils
.
prettifyShortcut
(
document
.
getElementById
(
"
sp
-
key
-
inspect
"
)
true
)
ShortcutUtils
.
prettifyShortcut
(
document
.
getElementById
(
"
sp
-
key
-
display
"
)
true
)
]
3
)
;
let
args
=
window
.
arguments
;
let
state
=
null
;
if
(
args
&
&
args
[
0
]
instanceof
Ci
.
nsIDialogParamBlock
)
{
args
=
args
[
0
]
;
this
.
_instanceId
=
args
.
GetString
(
0
)
;
state
=
args
.
GetString
(
1
)
|
|
null
;
if
(
state
)
{
state
=
JSON
.
parse
(
state
)
;
this
.
setState
(
state
)
;
if
(
"
text
"
in
state
)
{
initialText
=
state
.
text
;
}
}
}
else
{
this
.
_instanceId
=
ScratchpadManager
.
createUid
(
)
;
}
const
config
=
{
mode
:
Editor
.
modes
.
js
value
:
initialText
lineNumbers
:
Services
.
prefs
.
getBoolPref
(
SHOW_LINE_NUMBERS
)
contextMenu
:
"
scratchpad
-
text
-
popup
"
showTrailingSpace
:
Services
.
prefs
.
getBoolPref
(
SHOW_TRAILING_SPACE
)
autocomplete
:
Services
.
prefs
.
getBoolPref
(
ENABLE_AUTOCOMPLETION
)
lineWrapping
:
Services
.
prefs
.
getBoolPref
(
WRAP_TEXT
)
}
;
this
.
editor
=
new
Editor
(
config
)
;
const
editorElement
=
document
.
querySelector
(
"
#
scratchpad
-
editor
"
)
;
this
.
editor
.
appendTo
(
editorElement
)
.
then
(
(
)
=
>
{
var
lines
=
initialText
.
split
(
"
\
n
"
)
;
this
.
editor
.
setFontSize
(
Services
.
prefs
.
getIntPref
(
EDITOR_FONT_SIZE
)
)
;
this
.
editor
.
on
(
"
change
"
this
.
_onChanged
)
;
this
.
updateStatusBar
=
Scratchpad
.
updateStatusBar
.
bind
(
this
)
;
this
.
editor
.
on
(
"
cursorActivity
"
this
.
updateStatusBar
)
;
const
okstring
=
this
.
strings
.
GetStringFromName
(
"
selfxss
.
okstring
"
)
;
const
msg
=
this
.
strings
.
formatStringFromName
(
"
selfxss
.
msg
"
[
okstring
]
1
)
;
this
.
_onPaste
=
WebConsoleUtils
.
pasteHandlerGen
(
this
.
editor
.
container
.
contentDocument
.
body
document
.
querySelector
(
"
#
scratchpad
-
notificationbox
"
)
msg
okstring
)
;
editorElement
.
addEventListener
(
"
paste
"
this
.
_onPaste
true
)
;
editorElement
.
addEventListener
(
"
drop
"
this
.
_onPaste
)
;
this
.
editor
.
on
(
"
saveRequested
"
(
)
=
>
this
.
saveFile
(
)
)
;
this
.
editor
.
focus
(
)
;
this
.
editor
.
setCursor
(
{
line
:
lines
.
length
ch
:
lines
.
pop
(
)
.
length
}
)
;
this
.
editor
.
insertCommandsController
(
)
;
if
(
state
)
{
this
.
dirty
=
!
state
.
saved
;
}
this
.
initialized
=
true
;
this
.
_triggerObservers
(
"
Ready
"
)
;
this
.
populateRecentFilesMenu
(
)
;
PreferenceObserver
.
init
(
)
;
CloseObserver
.
init
(
)
;
}
)
.
catch
(
console
.
error
)
;
this
.
_setupCommandListeners
(
)
;
this
.
_updateViewMenuItems
(
)
;
this
.
_setupPopupShowingListeners
(
)
;
if
(
Services
.
appinfo
.
OS
=
=
"
WINNT
"
)
{
const
helpMenu
=
document
.
getElementById
(
"
sp
-
help
-
menu
"
)
;
helpMenu
.
setAttribute
(
"
accesskey
"
helpMenu
.
getAttribute
(
"
accesskeywindows
"
)
)
;
}
}
_onChanged
:
function
SP__onChanged
(
)
{
Scratchpad
.
_updateTitle
(
)
;
if
(
Scratchpad
.
filename
)
{
if
(
Scratchpad
.
dirty
)
{
document
.
getElementById
(
"
sp
-
cmd
-
revert
"
)
.
removeAttribute
(
"
disabled
"
)
;
}
else
{
document
.
getElementById
(
"
sp
-
cmd
-
revert
"
)
.
setAttribute
(
"
disabled
"
true
)
;
}
}
}
undo
:
function
SP_undo
(
)
{
this
.
editor
.
undo
(
)
;
}
redo
:
function
SP_redo
(
)
{
this
.
editor
.
redo
(
)
;
}
onUnload
:
function
SP_onUnload
(
aEvent
)
{
if
(
aEvent
.
target
!
=
document
)
{
return
;
}
if
(
this
.
_reloadAndRunEvent
&
&
this
.
gBrowser
)
{
this
.
gBrowser
.
selectedBrowser
.
removeEventListener
(
"
load
"
this
.
_reloadAndRunEvent
true
)
;
}
PreferenceObserver
.
uninit
(
)
;
CloseObserver
.
uninit
(
)
;
if
(
this
.
_onPaste
)
{
const
editorElement
=
document
.
querySelector
(
"
#
scratchpad
-
editor
"
)
;
editorElement
.
removeEventListener
(
"
paste
"
this
.
_onPaste
true
)
;
editorElement
.
removeEventListener
(
"
drop
"
this
.
_onPaste
)
;
this
.
_onPaste
=
null
;
}
this
.
editor
.
off
(
"
change
"
this
.
_onChanged
)
;
this
.
editor
.
off
(
"
cursorActivity
"
this
.
updateStatusBar
)
;
this
.
editor
.
destroy
(
)
;
this
.
editor
=
null
;
if
(
this
.
_sidebar
)
{
this
.
_sidebar
.
destroy
(
)
;
this
.
_sidebar
=
null
;
}
if
(
this
.
_prettyPrintWorker
)
{
this
.
_prettyPrintWorker
.
destroy
(
)
;
this
.
_prettyPrintWorker
=
null
;
}
scratchpadTargets
=
null
;
this
.
webConsoleClient
=
null
;
this
.
debuggerClient
=
null
;
this
.
initialized
=
false
;
}
promptSave
:
function
SP_promptSave
(
aCallback
)
{
if
(
this
.
dirty
)
{
const
ps
=
Services
.
prompt
;
const
flags
=
ps
.
BUTTON_POS_0
*
ps
.
BUTTON_TITLE_SAVE
+
ps
.
BUTTON_POS_1
*
ps
.
BUTTON_TITLE_CANCEL
+
ps
.
BUTTON_POS_2
*
ps
.
BUTTON_TITLE_DONT_SAVE
;
const
button
=
ps
.
confirmEx
(
window
this
.
strings
.
GetStringFromName
(
"
confirmClose
.
title
"
)
this
.
strings
.
GetStringFromName
(
"
confirmClose
"
)
flags
null
null
null
null
{
}
)
;
if
(
button
=
=
BUTTON_POSITION_CANCEL
)
{
if
(
aCallback
)
{
aCallback
(
false
false
)
;
}
return
false
;
}
if
(
button
=
=
BUTTON_POSITION_SAVE
)
{
this
.
saveFile
(
aStatus
=
>
{
if
(
aCallback
)
{
aCallback
(
true
true
aStatus
)
;
}
}
)
;
return
true
;
}
}
if
(
aCallback
)
{
aCallback
(
true
false
)
;
}
return
true
;
}
onClose
:
function
SP_onClose
(
aEvent
aCallback
)
{
aEvent
.
preventDefault
(
)
;
this
.
close
(
aCallback
)
;
}
close
:
function
SP_close
(
aCallback
)
{
let
shouldClose
;
this
.
promptSave
(
(
aShouldClose
aSaved
aStatus
)
=
>
{
shouldClose
=
aShouldClose
;
if
(
aSaved
&
&
!
Components
.
isSuccessCode
(
aStatus
)
)
{
shouldClose
=
false
;
}
if
(
shouldClose
)
{
window
.
close
(
)
;
}
if
(
aCallback
)
{
aCallback
(
shouldClose
)
;
}
}
)
;
return
shouldClose
;
}
toggleEditorOption
:
function
SP_toggleEditorOption
(
optionName
optionPreference
)
{
const
newOptionValue
=
!
this
.
editor
.
getOption
(
optionName
)
;
this
.
editor
.
setOption
(
optionName
newOptionValue
)
;
Services
.
prefs
.
setBoolPref
(
optionPreference
newOptionValue
)
;
}
increaseFontSize
:
function
SP_increaseFontSize
(
)
{
const
size
=
this
.
editor
.
getFontSize
(
)
;
if
(
size
<
MAXIMUM_FONT_SIZE
)
{
const
newFontSize
=
size
+
1
;
this
.
editor
.
setFontSize
(
newFontSize
)
;
Services
.
prefs
.
setIntPref
(
EDITOR_FONT_SIZE
newFontSize
)
;
if
(
newFontSize
=
=
=
MAXIMUM_FONT_SIZE
)
{
document
.
getElementById
(
"
sp
-
cmd
-
larger
-
font
"
)
.
setAttribute
(
"
disabled
"
true
)
;
}
document
.
getElementById
(
"
sp
-
cmd
-
smaller
-
font
"
)
.
removeAttribute
(
"
disabled
"
)
;
}
}
decreaseFontSize
:
function
SP_decreaseFontSize
(
)
{
const
size
=
this
.
editor
.
getFontSize
(
)
;
if
(
size
>
MINIMUM_FONT_SIZE
)
{
const
newFontSize
=
size
-
1
;
this
.
editor
.
setFontSize
(
newFontSize
)
;
Services
.
prefs
.
setIntPref
(
EDITOR_FONT_SIZE
newFontSize
)
;
if
(
newFontSize
=
=
=
MINIMUM_FONT_SIZE
)
{
document
.
getElementById
(
"
sp
-
cmd
-
smaller
-
font
"
)
.
setAttribute
(
"
disabled
"
true
)
;
}
}
document
.
getElementById
(
"
sp
-
cmd
-
larger
-
font
"
)
.
removeAttribute
(
"
disabled
"
)
;
}
normalFontSize
:
function
SP_normalFontSize
(
)
{
this
.
editor
.
setFontSize
(
NORMAL_FONT_SIZE
)
;
Services
.
prefs
.
setIntPref
(
EDITOR_FONT_SIZE
NORMAL_FONT_SIZE
)
;
document
.
getElementById
(
"
sp
-
cmd
-
larger
-
font
"
)
.
removeAttribute
(
"
disabled
"
)
;
document
.
getElementById
(
"
sp
-
cmd
-
smaller
-
font
"
)
.
removeAttribute
(
"
disabled
"
)
;
}
_observers
:
[
]
addObserver
:
function
SP_addObserver
(
aObserver
)
{
this
.
_observers
.
push
(
aObserver
)
;
}
removeObserver
:
function
SP_removeObserver
(
aObserver
)
{
const
index
=
this
.
_observers
.
indexOf
(
aObserver
)
;
if
(
index
!
=
-
1
)
{
this
.
_observers
.
splice
(
index
1
)
;
}
}
_triggerObservers
:
function
SP_triggerObservers
(
aName
aArgs
)
{
if
(
!
aArgs
)
{
aArgs
=
[
this
]
;
}
else
{
aArgs
.
unshift
(
this
)
;
}
for
(
let
i
=
0
;
i
<
this
.
_observers
.
length
;
+
+
i
)
{
const
observer
=
this
.
_observers
[
i
]
;
const
handler
=
observer
[
"
on
"
+
aName
]
;
if
(
handler
)
{
handler
.
apply
(
observer
aArgs
)
;
}
}
}
openDocumentationPage
:
function
SP_openDocumentationPage
(
)
{
openDocLink
(
this
.
strings
.
GetStringFromName
(
"
help
.
openDocumentationPage
"
)
)
;
this
.
browserWindow
.
focus
(
)
;
}
}
;
function
ScratchpadTab
(
aTab
)
{
this
.
_tab
=
aTab
;
}
var
scratchpadTargets
=
new
WeakMap
(
)
;
ScratchpadTab
.
consoleFor
=
function
consoleFor
(
aSubject
)
{
if
(
!
scratchpadTargets
.
has
(
aSubject
)
)
{
scratchpadTargets
.
set
(
aSubject
new
this
(
aSubject
)
)
;
}
return
scratchpadTargets
.
get
(
aSubject
)
.
connect
(
aSubject
)
;
}
;
ScratchpadTab
.
prototype
=
{
_connector
:
null
connect
:
function
ST_connect
(
aSubject
)
{
if
(
this
.
_connector
)
{
return
this
.
_connector
;
}
const
deferred
=
defer
(
)
;
this
.
_connector
=
deferred
.
promise
;
const
connectTimer
=
setTimeout
(
(
)
=
>
{
deferred
.
reject
(
{
error
:
"
timeout
"
message
:
Scratchpad
.
strings
.
GetStringFromName
(
"
connectionTimeout
"
)
}
)
;
}
REMOTE_TIMEOUT
)
;
deferred
.
promise
.
then
(
(
)
=
>
clearTimeout
(
connectTimer
)
)
;
this
.
_attach
(
aSubject
)
.
then
(
aTarget
=
>
{
const
consoleActor
=
aTarget
.
form
.
consoleActor
;
const
client
=
aTarget
.
client
;
client
.
attachConsole
(
consoleActor
[
]
)
.
then
(
(
[
aResponse
aWebConsoleClient
]
)
=
>
{
deferred
.
resolve
(
{
webConsoleClient
:
aWebConsoleClient
debuggerClient
:
client
}
)
;
}
error
=
>
{
reportError
(
"
attachConsole
"
error
)
;
deferred
.
reject
(
error
)
;
}
)
;
}
)
;
return
deferred
.
promise
;
}
_attach
:
function
ST__attach
(
aSubject
)
{
const
target
=
TargetFactory
.
forTab
(
this
.
_tab
)
;
target
.
once
(
"
close
"
(
)
=
>
{
if
(
scratchpadTargets
)
{
scratchpadTargets
.
delete
(
aSubject
)
;
}
}
)
;
return
target
.
makeRemote
(
)
.
then
(
(
)
=
>
target
)
;
}
}
;
function
ScratchpadWindow
(
)
{
}
ScratchpadWindow
.
consoleFor
=
ScratchpadTab
.
consoleFor
;
ScratchpadWindow
.
prototype
=
extend
(
ScratchpadTab
.
prototype
{
_attach
:
function
SW__attach
(
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
registerAllActors
(
)
;
DebuggerServer
.
allowChromeProcess
=
true
;
const
client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
return
client
.
connect
(
)
.
then
(
(
)
=
>
client
.
getProcess
(
)
)
.
then
(
aResponse
=
>
{
return
{
form
:
aResponse
.
form
client
:
client
}
;
}
)
;
}
}
)
;
function
ScratchpadTarget
(
aTarget
)
{
this
.
_target
=
aTarget
;
}
ScratchpadTarget
.
consoleFor
=
ScratchpadTab
.
consoleFor
;
ScratchpadTarget
.
prototype
=
extend
(
ScratchpadTab
.
prototype
{
_attach
:
function
ST__attach
(
)
{
if
(
this
.
_target
.
isRemote
)
{
return
promise
.
resolve
(
this
.
_target
)
;
}
return
this
.
_target
.
makeRemote
(
)
.
then
(
(
)
=
>
this
.
_target
)
;
}
}
)
;
function
ScratchpadSidebar
(
aScratchpad
)
{
EventEmitter
.
decorate
(
this
)
;
const
ToolSidebar
=
require
(
"
devtools
/
client
/
framework
/
sidebar
"
)
.
ToolSidebar
;
const
tabbox
=
document
.
querySelector
(
"
#
scratchpad
-
sidebar
"
)
;
this
.
_sidebar
=
new
ToolSidebar
(
tabbox
this
"
scratchpad
"
)
;
this
.
_scratchpad
=
aScratchpad
;
}
ScratchpadSidebar
.
prototype
=
{
_sidebar
:
null
variablesView
:
null
visible
:
false
open
:
function
SS_open
(
aEvalString
aObject
)
{
this
.
show
(
)
;
const
deferred
=
defer
(
)
;
const
onTabReady
=
(
)
=
>
{
if
(
this
.
variablesView
)
{
this
.
variablesView
.
controller
.
releaseActors
(
)
;
}
else
{
const
window
=
this
.
_sidebar
.
getWindowForTab
(
"
variablesview
"
)
;
const
container
=
window
.
document
.
querySelector
(
"
#
variables
"
)
;
this
.
variablesView
=
new
VariablesView
(
container
{
searchEnabled
:
true
searchPlaceholder
:
this
.
_scratchpad
.
strings
.
GetStringFromName
(
"
propertiesFilterPlaceholder
"
)
}
)
;
VariablesViewController
.
attach
(
this
.
variablesView
{
getEnvironmentClient
:
aGrip
=
>
{
return
new
EnvironmentClient
(
this
.
_scratchpad
.
debuggerClient
aGrip
)
;
}
getObjectClient
:
aGrip
=
>
{
return
new
ObjectClient
(
this
.
_scratchpad
.
debuggerClient
aGrip
)
;
}
getLongStringClient
:
aActor
=
>
{
return
this
.
_scratchpad
.
webConsoleClient
.
longString
(
aActor
)
;
}
releaseActor
:
aActor
=
>
{
this
.
_scratchpad
.
debuggerClient
.
release
(
aActor
)
;
}
}
)
;
}
this
.
_update
(
aObject
)
.
then
(
(
)
=
>
deferred
.
resolve
(
)
)
;
}
;
if
(
this
.
_sidebar
.
getCurrentTabID
(
)
=
=
"
variablesview
"
)
{
onTabReady
(
)
;
}
else
{
this
.
_sidebar
.
once
(
"
variablesview
-
ready
"
onTabReady
)
;
this
.
_sidebar
.
addTab
(
"
variablesview
"
VARIABLES_VIEW_URL
{
selected
:
true
}
)
;
}
return
deferred
.
promise
;
}
show
:
function
SS_show
(
)
{
if
(
!
this
.
visible
)
{
this
.
visible
=
true
;
this
.
_sidebar
.
show
(
)
;
}
}
hide
:
function
SS_hide
(
)
{
if
(
this
.
visible
)
{
this
.
visible
=
false
;
this
.
_sidebar
.
hide
(
)
;
}
}
destroy
:
function
SS_destroy
(
)
{
if
(
this
.
variablesView
)
{
this
.
variablesView
.
controller
.
releaseActors
(
)
;
this
.
variablesView
=
null
;
}
return
this
.
_sidebar
.
destroy
(
)
;
}
_update
:
function
SS__update
(
aValue
)
{
let
options
onlyEnumVisible
;
if
(
VariablesView
.
isPrimitive
(
{
value
:
aValue
}
)
)
{
options
=
{
rawObject
:
{
value
:
aValue
}
}
;
onlyEnumVisible
=
true
;
}
else
{
options
=
{
objectActor
:
aValue
}
;
onlyEnumVisible
=
false
;
}
const
view
=
this
.
variablesView
;
view
.
onlyEnumVisible
=
onlyEnumVisible
;
view
.
empty
(
)
;
return
view
.
controller
.
setSingleVariable
(
options
)
.
expanded
;
}
}
;
function
reportError
(
aAction
aResponse
)
{
console
.
error
(
aAction
+
"
failed
:
"
+
aResponse
.
error
+
"
"
+
aResponse
.
message
)
;
}
var
PreferenceObserver
=
{
_initialized
:
false
init
:
function
PO_init
(
)
{
if
(
this
.
_initialized
)
{
return
;
}
this
.
branch
=
Services
.
prefs
.
getBranch
(
"
devtools
.
scratchpad
.
"
)
;
this
.
branch
.
addObserver
(
"
"
this
)
;
this
.
_initialized
=
true
;
}
observe
:
function
PO_observe
(
aMessage
aTopic
aData
)
{
if
(
aTopic
!
=
"
nsPref
:
changed
"
)
{
return
;
}
if
(
aData
=
=
"
recentFilesMax
"
)
{
Scratchpad
.
handleRecentFileMaxChange
(
)
;
}
else
if
(
aData
=
=
"
recentFilePaths
"
)
{
Scratchpad
.
populateRecentFilesMenu
(
)
;
}
}
uninit
:
function
PO_uninit
(
)
{
if
(
!
this
.
branch
)
{
return
;
}
this
.
branch
.
removeObserver
(
"
"
this
)
;
this
.
branch
=
null
;
}
}
;
var
CloseObserver
=
{
init
:
function
CO_init
(
)
{
Services
.
obs
.
addObserver
(
this
"
browser
-
lastwindow
-
close
-
requested
"
)
;
}
observe
:
function
CO_observe
(
aSubject
)
{
if
(
Scratchpad
.
close
(
)
)
{
this
.
uninit
(
)
;
}
else
{
aSubject
.
QueryInterface
(
Ci
.
nsISupportsPRBool
)
;
aSubject
.
data
=
true
;
}
}
uninit
:
function
CO_uninit
(
)
{
if
(
this
.
_uninited
)
{
return
;
}
this
.
_uninited
=
true
;
Services
.
obs
.
removeObserver
(
this
"
browser
-
lastwindow
-
close
-
requested
"
)
;
}
}
;
XPCOMUtils
.
defineLazyGetter
(
Scratchpad
"
strings
"
function
(
)
{
return
Services
.
strings
.
createBundle
(
SCRATCHPAD_L10N
)
;
}
)
;
addEventListener
(
"
load
"
Scratchpad
.
onLoad
.
bind
(
Scratchpad
)
false
)
;
addEventListener
(
"
unload
"
Scratchpad
.
onUnload
.
bind
(
Scratchpad
)
false
)
;
addEventListener
(
"
close
"
Scratchpad
.
onClose
.
bind
(
Scratchpad
)
false
)
;
