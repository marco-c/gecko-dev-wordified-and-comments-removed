"
use
strict
"
;
const
{
NetUtil
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
{
}
)
;
const
{
FileUtils
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
{
}
)
;
const
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
const
{
ScratchpadManager
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
{
}
)
;
const
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
var
gScratchpadWindow
;
flags
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
{
flags
.
testing
=
false
;
}
)
;
function
openScratchpad
(
aReadyCallback
aOptions
=
{
}
)
{
let
win
=
aOptions
.
window
|
|
ScratchpadManager
.
openScratchpad
(
aOptions
.
state
)
;
if
(
!
win
)
{
return
;
}
let
onLoad
=
function
(
)
{
win
.
removeEventListener
(
"
load
"
onLoad
)
;
win
.
Scratchpad
.
addObserver
(
{
onReady
:
function
(
aScratchpad
)
{
aScratchpad
.
removeObserver
(
this
)
;
if
(
aOptions
.
noFocus
)
{
aReadyCallback
(
win
aScratchpad
)
;
}
else
{
waitForFocus
(
aReadyCallback
.
bind
(
null
win
aScratchpad
)
win
)
;
}
}
}
)
;
}
;
if
(
aReadyCallback
)
{
win
.
addEventListener
(
"
load
"
onLoad
)
;
}
gScratchpadWindow
=
win
;
return
gScratchpadWindow
;
}
function
openTabAndScratchpad
(
aOptions
=
{
}
)
{
waitForExplicitFinish
(
)
;
return
new
promise
(
resolve
=
>
{
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
)
;
let
{
selectedBrowser
}
=
gBrowser
;
selectedBrowser
.
addEventListener
(
"
load
"
function
(
)
{
openScratchpad
(
(
win
sp
)
=
>
resolve
(
[
win
sp
]
)
aOptions
)
;
}
{
capture
:
true
once
:
true
}
)
;
content
.
location
=
"
data
:
text
/
html
;
charset
=
utf8
"
+
(
aOptions
.
tabContent
|
|
"
"
)
;
}
)
;
}
function
createTempFile
(
aName
aContent
aCallback
=
function
(
)
{
}
)
{
let
file
=
FileUtils
.
getFile
(
"
TmpD
"
[
aName
]
)
;
file
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
parseInt
(
"
666
"
8
)
)
;
let
fout
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
fout
.
init
(
file
.
QueryInterface
(
Ci
.
nsIFile
)
0x02
|
0x08
|
0x20
parseInt
(
"
644
"
8
)
fout
.
DEFER_OPEN
)
;
let
converter
=
Cc
[
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
]
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
converter
.
charset
=
"
UTF
-
8
"
;
let
fileContentStream
=
converter
.
convertToInputStream
(
aContent
)
;
NetUtil
.
asyncCopy
(
fileContentStream
fout
function
(
aStatus
)
{
aCallback
(
aStatus
file
)
;
}
)
;
}
function
runAsyncTests
(
aScratchpad
aTests
)
{
let
deferred
=
defer
(
)
;
(
function
runTest
(
)
{
if
(
aTests
.
length
)
{
let
test
=
aTests
.
shift
(
)
;
aScratchpad
.
setText
(
test
.
code
)
;
aScratchpad
[
test
.
method
]
(
)
.
then
(
function
success
(
)
{
is
(
aScratchpad
.
getText
(
)
test
.
result
test
.
label
)
;
runTest
(
)
;
}
function
failure
(
error
)
{
ok
(
false
error
.
stack
+
"
"
+
test
.
label
)
;
runTest
(
)
;
}
)
;
}
else
{
deferred
.
resolve
(
)
;
}
}
)
(
)
;
return
deferred
.
promise
;
}
var
runAsyncCallbackTests
=
Task
.
async
(
function
*
(
aScratchpad
aTests
)
{
for
(
let
{
prepare
method
then
}
of
aTests
)
{
yield
prepare
(
)
;
let
res
=
yield
aScratchpad
[
method
]
(
)
;
yield
then
(
res
)
;
}
}
)
;
function
inContent
(
generator
)
{
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
}
generator
)
;
}
function
cleanup
(
)
{
if
(
gScratchpadWindow
)
{
gScratchpadWindow
.
close
(
)
;
gScratchpadWindow
=
null
;
}
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
registerCleanupFunction
(
cleanup
)
;
