"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
framework
/
test
/
head
.
js
"
this
)
;
const
JSON_VIEW_PREF
=
"
devtools
.
jsonview
.
enabled
"
;
Services
.
prefs
.
setBoolPref
(
JSON_VIEW_PREF
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
JSON_VIEW_PREF
)
;
}
)
;
async
function
addJsonViewTab
(
url
{
appReadyState
=
"
complete
"
docReadyState
=
"
complete
"
}
=
{
}
)
{
info
(
"
Adding
a
new
JSON
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
const
tabAdded
=
BrowserTestUtils
.
waitForNewTab
(
gBrowser
url
)
;
const
tabLoaded
=
addTab
(
url
)
;
const
tab
=
await
Promise
.
race
(
[
tabAdded
tabLoaded
]
)
;
const
browser
=
tab
.
linkedBrowser
;
const
rootDir
=
getRootDirectory
(
gTestPath
)
;
const
error
=
tabLoaded
.
then
(
(
)
=
>
SpecialPowers
.
spawn
(
browser
[
]
function
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
{
requirejs
}
=
content
.
wrappedJSObject
;
if
(
requirejs
)
{
requirejs
.
onError
=
err
=
>
{
info
(
err
)
;
ok
(
false
"
RequireJS
error
"
)
;
reject
(
err
)
;
}
;
}
}
)
;
}
)
)
;
const
data
=
{
rootDir
appReadyState
docReadyState
}
;
await
Promise
.
race
(
[
error
ContentTask
.
spawn
(
browser
data
async
function
(
data
)
{
const
{
JSONView
}
=
content
.
wrappedJSObject
;
if
(
!
JSONView
)
{
throw
new
Error
(
"
The
JSON
Viewer
did
not
load
.
"
)
;
}
const
docReadyStates
=
[
"
loading
"
"
interactive
"
"
complete
"
]
;
const
docReadyIndex
=
docReadyStates
.
indexOf
(
data
.
docReadyState
)
;
const
appReadyStates
=
[
"
uninitialized
"
.
.
.
docReadyStates
]
;
const
appReadyIndex
=
appReadyStates
.
indexOf
(
data
.
appReadyState
)
;
if
(
docReadyIndex
<
0
|
|
appReadyIndex
<
0
)
{
throw
new
Error
(
"
Invalid
app
or
doc
readyState
parameter
.
"
)
;
}
const
{
document
}
=
content
;
while
(
docReadyStates
.
indexOf
(
document
.
readyState
)
<
docReadyIndex
)
{
info
(
DocReadyState
is
"
{
document
.
readyState
}
"
.
Await
"
{
data
.
docReadyState
}
"
)
;
await
new
Promise
(
resolve
=
>
{
document
.
addEventListener
(
"
readystatechange
"
resolve
{
once
:
true
}
)
;
}
)
;
}
while
(
appReadyStates
.
indexOf
(
JSONView
.
readyState
)
<
appReadyIndex
)
{
info
(
AppReadyState
is
"
{
JSONView
.
readyState
}
"
.
Await
"
{
data
.
appReadyState
}
"
)
;
await
new
Promise
(
resolve
=
>
{
content
.
addEventListener
(
"
AppReadyStateChange
"
resolve
{
once
:
true
}
)
;
}
)
;
}
}
)
]
)
;
return
tab
;
}
function
clickJsonNode
(
selector
)
{
info
(
"
Expanding
node
:
'
"
+
selector
+
"
'
"
)
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
selector
selector
=
>
{
content
.
document
.
querySelector
(
selector
)
.
click
(
)
;
}
)
;
}
function
selectJsonViewContentTab
(
name
)
{
info
(
"
Selecting
tab
:
'
"
+
name
+
"
'
"
)
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
name
async
name
=
>
{
const
tabsSelector
=
"
.
tabs
-
menu
.
tabs
-
menu
-
item
"
;
const
targetTabSelector
=
{
tabsSelector
}
.
{
CSS
.
escape
(
name
)
}
;
const
targetTab
=
content
.
document
.
querySelector
(
targetTabSelector
)
;
const
targetTabIndex
=
Array
.
prototype
.
indexOf
.
call
(
content
.
document
.
querySelectorAll
(
tabsSelector
)
targetTab
)
;
const
targetTabButton
=
targetTab
.
querySelector
(
"
a
"
)
;
await
new
Promise
(
resolve
=
>
{
content
.
addEventListener
(
"
TabChanged
"
(
{
detail
:
{
index
}
}
)
=
>
{
is
(
index
targetTabIndex
"
Hm
?
"
)
;
if
(
index
=
=
=
targetTabIndex
)
{
resolve
(
)
;
}
}
{
once
:
true
}
)
;
targetTabButton
.
click
(
)
;
}
)
;
is
(
targetTabButton
.
getAttribute
(
"
aria
-
selected
"
)
"
true
"
"
Tab
is
now
selected
"
)
;
}
)
;
}
function
getElementCount
(
selector
)
{
info
(
"
Get
element
count
:
'
"
+
selector
+
"
'
"
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
]
selectorChild
=
>
{
return
content
.
document
.
querySelectorAll
(
selectorChild
)
.
length
;
}
)
;
}
function
getElementText
(
selector
)
{
info
(
"
Get
element
text
:
'
"
+
selector
+
"
'
"
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
]
selectorChild
=
>
{
const
element
=
content
.
document
.
querySelector
(
selectorChild
)
;
return
element
?
element
.
textContent
:
null
;
}
)
;
}
function
getElementAttr
(
selector
attr
)
{
info
(
"
Get
attribute
'
"
+
attr
+
"
'
for
element
'
"
+
selector
+
"
'
"
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
attr
]
(
selectorChild
attrChild
)
=
>
{
const
element
=
content
.
document
.
querySelector
(
selectorChild
)
;
return
element
?
element
.
getAttribute
(
attrChild
)
:
null
;
}
)
;
}
async
function
getRowText
(
rowIndex
)
{
const
key
=
await
getElementText
(
.
jsonPanelBox
.
treeTable
.
treeRow
:
nth
-
of
-
type
(
{
rowIndex
+
1
}
)
.
treeLabelCell
)
;
const
value
=
await
getElementText
(
.
jsonPanelBox
.
treeTable
.
treeRow
:
nth
-
of
-
type
(
{
rowIndex
+
1
}
)
.
treeValueCell
)
;
return
{
key
}
:
{
value
}
;
}
function
focusElement
(
selector
)
{
info
(
"
Focus
element
:
'
"
+
selector
+
"
'
"
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
]
selectorChild
=
>
{
const
element
=
content
.
document
.
querySelector
(
selectorChild
)
;
if
(
element
)
{
element
.
focus
(
)
;
}
}
)
;
}
function
sendString
(
str
selector
)
{
info
(
"
Send
string
:
'
"
+
str
+
"
'
"
)
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
selector
str
]
(
selectorChild
strChild
)
=
>
{
if
(
selectorChild
)
{
const
element
=
content
.
document
.
querySelector
(
selectorChild
)
;
if
(
element
)
{
element
.
focus
(
)
;
}
}
EventUtils
.
sendString
(
strChild
content
)
;
}
)
;
}
function
waitForTime
(
delay
)
{
return
new
Promise
(
resolve
=
>
setTimeout
(
resolve
delay
)
)
;
}
function
waitForFilter
(
)
{
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
{
return
new
Promise
(
resolve
=
>
{
const
firstRow
=
content
.
document
.
querySelector
(
"
.
jsonPanelBox
.
treeTable
.
treeRow
"
)
;
if
(
firstRow
.
classList
.
contains
(
"
hidden
"
)
)
{
resolve
(
)
;
return
;
}
const
observer
=
new
content
.
MutationObserver
(
function
(
mutations
)
{
for
(
let
i
=
0
;
i
<
mutations
.
length
;
i
+
+
)
{
const
mutation
=
mutations
[
i
]
;
if
(
mutation
.
attributeName
=
=
"
class
"
)
{
if
(
firstRow
.
classList
.
contains
(
"
hidden
"
)
)
{
observer
.
disconnect
(
)
;
resolve
(
)
;
break
;
}
}
}
}
)
;
observer
.
observe
(
firstRow
{
attributes
:
true
}
)
;
}
)
;
}
)
;
}
function
normalizeNewLines
(
value
)
{
return
value
.
replace
(
"
(
\
r
\
n
|
\
n
)
"
"
\
n
"
)
;
}
