"
use
strict
"
;
const
TEST_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
http
:
/
/
example
.
com
"
)
;
const
JSON_VIEW_MIME_TYPE
=
"
application
/
vnd
.
mozilla
.
json
.
view
"
;
const
nullP
=
Services
.
scriptSecurityManager
.
createNullPrincipal
(
{
}
)
;
add_task
(
async
function
test_blocked_data_exposure
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
data_uri
.
block_toplevel_data_uri_navigations
"
true
]
]
}
)
;
await
BrowserTestUtils
.
withNewTab
(
TEST_PATH
+
"
empty
.
html
"
async
browser
=
>
{
const
tabCount
=
gBrowser
.
tabs
.
length
;
await
SpecialPowers
.
spawn
(
browser
[
]
function
(
)
{
content
.
w
=
content
.
window
.
open
(
"
data
:
application
/
vnd
.
mozilla
.
json
.
view
1
"
"
_blank
"
)
;
ok
(
!
Cu
.
waiveXrays
(
content
.
w
)
.
JSONView
"
Should
not
have
created
a
JSON
View
object
"
)
;
return
new
Promise
(
resolve
=
>
{
content
.
setTimeout
(
function
(
)
{
resolve
(
)
;
ok
(
!
Cu
.
waiveXrays
(
content
.
w
)
.
JSONView
"
Should
still
not
have
a
JSON
View
object
"
)
;
}
1000
)
;
}
)
;
}
)
;
is
(
tabCount
gBrowser
.
tabs
.
length
"
Haven
'
t
actually
opened
a
new
window
/
tab
"
)
;
}
)
;
}
)
;
add_task
(
async
function
test_converter_abort_should_stop_data_sending
(
)
{
const
loadInfo
=
NetUtil
.
newChannel
(
{
uri
:
Services
.
io
.
newURI
(
"
data
:
text
/
plain
"
)
loadingPrincipal
:
nullP
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
.
loadInfo
;
const
chan
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIChannel
"
"
nsIWritablePropertyBag
"
]
)
URI
:
Services
.
io
.
newURI
(
"
data
:
application
/
json
{
}
"
)
loadInfo
notificationCallbacks
:
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInterfaceRequestor
"
]
)
getInterface
(
)
{
return
docShell
;
}
}
status
:
Cr
.
NS_OK
setProperty
(
)
{
}
}
;
let
onStartFired
=
false
;
const
listener
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIStreamListener
"
]
)
onStartRequest
(
)
{
onStartFired
=
true
;
chan
.
status
=
Cr
.
NS_BINDING_ABORTED
;
}
onDataAvailable
(
)
{
ok
(
false
"
onDataAvailable
should
never
fire
"
)
;
}
}
;
const
conv
=
Cc
[
"
mozilla
.
org
/
streamconv
;
1
?
from
=
"
+
JSON_VIEW_MIME_TYPE
+
"
&
to
=
*
/
*
"
]
.
createInstance
(
Ci
.
nsIStreamConverter
)
;
conv
.
asyncConvertData
(
"
application
/
vnd
.
mozilla
.
json
.
view
"
"
text
/
html
"
listener
null
)
;
conv
.
onStartRequest
(
chan
)
;
ok
(
onStartFired
"
Should
have
fired
onStartRequest
"
)
;
}
)
;
add_task
(
async
function
test_converter_principal_needs_matching
(
)
{
const
loadInfo
=
NetUtil
.
newChannel
(
{
uri
:
Services
.
io
.
newURI
(
"
data
:
text
/
plain
"
)
loadingPrincipal
:
nullP
securityFlags
:
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
contentPolicyType
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
}
)
.
loadInfo
;
const
chan
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIChannel
"
"
nsIWritablePropertyBag
"
]
)
URI
:
Services
.
io
.
newURI
(
"
data
:
application
/
json
{
}
"
)
loadInfo
notificationCallbacks
:
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIInterfaceRequestor
"
]
)
getInterface
(
)
{
return
docShell
;
}
}
status
:
Cr
.
NS_OK
setProperty
(
)
{
}
cancel
(
arg
)
{
this
.
status
=
arg
;
}
}
;
let
onStartFired
=
false
;
const
listener
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIStreamListener
"
]
)
onStartRequest
(
)
{
onStartFired
=
true
;
}
onDataAvailable
(
)
{
ok
(
false
"
onDataAvailable
should
never
fire
"
)
;
}
}
;
const
conv
=
Cc
[
"
mozilla
.
org
/
streamconv
;
1
?
from
=
"
+
JSON_VIEW_MIME_TYPE
+
"
&
to
=
*
/
*
"
]
.
createInstance
(
Ci
.
nsIStreamConverter
)
;
conv
.
asyncConvertData
(
"
application
/
vnd
.
mozilla
.
json
.
view
"
"
text
/
html
"
listener
null
)
;
conv
.
onStartRequest
(
chan
)
;
ok
(
onStartFired
"
Should
have
fired
onStartRequest
"
)
;
is
(
chan
.
status
Cr
.
NS_BINDING_ABORTED
"
Should
have
been
aborted
.
"
)
;
}
)
;
