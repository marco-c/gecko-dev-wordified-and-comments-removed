"
use
strict
"
;
const
asyncStoreHelper
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
async
-
store
-
helper
.
js
"
)
;
const
{
makeBreakpointServerOptions
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
debugger
/
src
/
utils
/
breakpoint
/
index
.
js
"
)
;
const
{
validateBreakpointLocation
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
validate
-
breakpoint
.
jsm
"
)
;
const
asyncStore
=
asyncStoreHelper
(
"
debugger
"
{
pendingBreakpoints
:
[
"
pending
-
breakpoints
"
{
}
]
tabs
:
[
"
tabs
"
[
]
]
xhrBreakpoints
:
[
"
xhr
-
breakpoints
"
[
]
]
eventListenerBreakpoints
:
[
"
event
-
listener
-
breakpoints
"
undefined
]
blackboxedRanges
:
[
"
blackboxedRanges
"
{
}
]
}
)
;
exports
.
asyncStore
=
asyncStore
;
exports
.
getThreadOptions
=
async
function
(
)
{
return
{
pauseOnExceptions
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
pause
-
on
-
exceptions
"
)
ignoreCaughtExceptions
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
ignore
-
caught
-
exceptions
"
)
shouldIncludeSavedFrames
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
features
.
async
-
captured
-
stacks
"
)
shouldIncludeAsyncLiveFrames
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
features
.
async
-
live
-
stacks
"
)
skipBreakpoints
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
skip
-
pausing
"
)
logEventBreakpoints
:
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
log
-
event
-
breakpoints
"
)
observeAsmJS
:
true
breakpoints
:
createServerBreakpoints
(
sanitizeBreakpoints
(
await
asyncStore
.
pendingBreakpoints
)
)
xhrBreakpoints
:
createServerXHRBreakpoints
(
await
asyncStore
.
xhrBreakpoints
)
eventBreakpoints
:
(
(
await
asyncStore
.
eventListenerBreakpoints
)
|
|
{
}
)
.
active
|
|
[
]
}
;
}
;
function
makeServerBreakpointFromPendingBreakpoint
(
pendingBreakpoint
)
{
const
{
options
location
}
=
pendingBreakpoint
;
return
{
location
:
{
sourceUrl
:
location
.
sourceUrl
line
:
location
.
line
column
:
location
.
column
}
options
:
makeBreakpointServerOptions
(
options
)
}
;
}
function
createServerXHRBreakpoints
(
xhrBreakpoints
)
{
return
xhrBreakpoints
.
filter
(
breakpoint
=
>
!
breakpoint
.
disabled
)
.
map
(
(
{
path
method
}
)
=
>
(
{
path
method
}
)
)
;
}
function
createServerBreakpoints
(
pendingBreakpoints
)
{
const
serverBreakpoints
=
{
}
;
for
(
const
key
in
pendingBreakpoints
)
{
const
breakpoint
=
pendingBreakpoints
[
key
]
;
if
(
!
breakpoint
.
disabled
)
{
serverBreakpoints
[
key
]
=
makeServerBreakpointFromPendingBreakpoint
(
breakpoint
)
;
}
}
return
serverBreakpoints
;
}
function
sanitizeBreakpoints
(
breakpoints
)
{
if
(
typeof
breakpoints
!
=
"
object
"
)
{
return
{
}
;
}
const
validBreakpoints
=
{
}
;
for
(
const
key
in
breakpoints
)
{
const
bp
=
breakpoints
[
key
]
;
try
{
if
(
!
bp
)
{
throw
new
Error
(
"
Undefined
breakpoint
"
)
;
}
validateBreakpointLocation
(
bp
.
generatedLocation
)
;
validateBreakpointLocation
(
bp
.
location
)
;
validBreakpoints
[
key
]
=
bp
;
}
catch
(
e
)
{
console
.
error
(
"
Ignore
invalid
breakpoint
from
debugger
store
"
bp
e
.
message
)
;
}
}
return
validBreakpoints
;
}
exports
.
sanitizeBreakpoints
=
sanitizeBreakpoints
;
