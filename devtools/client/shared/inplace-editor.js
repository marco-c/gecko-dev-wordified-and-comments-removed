"
use
strict
"
;
const
focusManager
=
Services
.
focus
;
const
isOSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
{
KeyCodes
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
keycodes
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
findMostRelevantCssPropertyIndex
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
suggestion
-
picker
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
InspectorCSSParserWrapper
"
"
resource
:
/
/
devtools
/
shared
/
css
/
lexer
.
js
"
true
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
CONTENT_TYPES
=
{
PLAIN_TEXT
:
0
CSS_VALUE
:
1
CSS_MIXED
:
2
CSS_PROPERTY
:
3
}
;
const
MAX_POPUP_ENTRIES
=
500
;
const
FOCUS_FORWARD
=
focusManager
.
MOVEFOCUS_FORWARD
;
const
FOCUS_BACKWARD
=
focusManager
.
MOVEFOCUS_BACKWARD
;
const
WORD_REGEXP
=
/
\
w
/
;
const
isWordChar
=
function
(
str
)
{
return
str
&
&
WORD_REGEXP
.
test
(
str
)
;
}
;
const
GRID_PROPERTY_NAMES
=
[
"
grid
-
area
"
"
grid
-
row
"
"
grid
-
row
-
start
"
"
grid
-
row
-
end
"
"
grid
-
column
"
"
grid
-
column
-
start
"
"
grid
-
column
-
end
"
]
;
const
GRID_ROW_PROPERTY_NAMES
=
[
"
grid
-
area
"
"
grid
-
row
"
"
grid
-
row
-
start
"
"
grid
-
row
-
end
"
]
;
const
GRID_COL_PROPERTY_NAMES
=
[
"
grid
-
area
"
"
grid
-
column
"
"
grid
-
column
-
start
"
"
grid
-
column
-
end
"
]
;
function
isKeyIn
(
key
.
.
.
keys
)
{
return
keys
.
some
(
expectedKey
=
>
{
return
key
=
=
=
KeyCodes
[
"
DOM_VK_
"
+
expectedKey
]
;
}
)
;
}
function
editableField
(
options
)
{
return
editableItem
(
options
function
(
element
event
)
{
if
(
!
options
.
element
.
inplaceEditor
)
{
new
InplaceEditor
(
options
event
)
;
}
}
)
;
}
exports
.
editableField
=
editableField
;
function
editableItem
(
options
callback
)
{
const
trigger
=
options
.
trigger
|
|
"
click
"
;
const
element
=
options
.
element
;
element
.
addEventListener
(
trigger
function
(
evt
)
{
if
(
!
isValidTargetForEditableItemCallback
(
evt
.
target
)
)
{
return
;
}
const
win
=
this
.
ownerDocument
.
defaultView
;
const
selection
=
win
.
getSelection
(
)
;
if
(
trigger
!
=
"
click
"
|
|
selection
.
isCollapsed
)
{
callback
(
element
evt
)
;
}
evt
.
stopPropagation
(
)
;
}
)
;
element
.
addEventListener
(
"
keypress
"
function
(
evt
)
{
if
(
!
isValidTargetForEditableItemCallback
(
evt
.
target
)
)
{
return
;
}
if
(
isKeyIn
(
evt
.
keyCode
"
RETURN
"
)
|
|
isKeyIn
(
evt
.
charCode
"
SPACE
"
)
)
{
callback
(
element
)
;
}
}
true
)
;
element
.
_editable
=
true
;
element
.
setAttribute
(
"
editable
"
"
"
)
;
element
.
_trigger
=
trigger
;
element
.
setAttribute
(
"
role
"
"
button
"
)
;
return
function
turnOnEditMode
(
)
{
callback
(
element
)
;
}
;
}
exports
.
editableItem
=
editableItem
;
function
isValidTargetForEditableItemCallback
(
eventTarget
)
{
const
{
nodeName
}
=
eventTarget
;
return
nodeName
!
=
=
"
a
"
&
&
nodeName
!
=
=
"
button
"
;
}
function
getInplaceEditorForSpan
(
span
)
{
return
span
.
inplaceEditor
;
}
exports
.
getInplaceEditorForSpan
=
getInplaceEditorForSpan
;
class
InplaceEditor
extends
EventEmitter
{
constructor
(
options
event
)
{
super
(
)
;
this
.
elt
=
options
.
element
;
const
doc
=
this
.
elt
.
ownerDocument
;
this
.
doc
=
doc
;
this
.
elt
.
inplaceEditor
=
this
;
this
.
cssProperties
=
options
.
cssProperties
;
this
.
getCssVariables
=
options
.
getCssVariables
?
options
.
getCssVariables
.
bind
(
this
)
:
null
;
this
.
change
=
options
.
change
;
this
.
done
=
options
.
done
;
this
.
contextMenu
=
options
.
contextMenu
;
this
.
defaultIncrement
=
options
.
defaultIncrement
|
|
1
;
this
.
destroy
=
options
.
destroy
;
this
.
initial
=
options
.
initial
?
options
.
initial
:
this
.
elt
.
textContent
;
this
.
multiline
=
options
.
multiline
|
|
false
;
this
.
maxWidth
=
options
.
maxWidth
;
if
(
typeof
this
.
maxWidth
=
=
"
function
"
)
{
this
.
maxWidth
=
this
.
maxWidth
(
)
;
}
this
.
trimOutput
=
options
.
trimOutput
=
=
=
undefined
?
true
:
!
!
options
.
trimOutput
;
this
.
stopOnShiftTab
=
!
!
options
.
stopOnShiftTab
;
this
.
stopOnTab
=
!
!
options
.
stopOnTab
;
this
.
stopOnReturn
=
!
!
options
.
stopOnReturn
;
this
.
contentType
=
options
.
contentType
|
|
CONTENT_TYPES
.
PLAIN_TEXT
;
this
.
property
=
options
.
property
;
this
.
popup
=
options
.
popup
;
this
.
preserveTextStyles
=
options
.
preserveTextStyles
=
=
=
undefined
?
false
:
!
!
options
.
preserveTextStyles
;
this
.
showSuggestCompletionOnEmpty
=
!
!
options
.
showSuggestCompletionOnEmpty
;
this
.
focusEditableFieldAfterApply
=
options
.
focusEditableFieldAfterApply
=
=
=
true
;
this
.
focusEditableFieldContainerSelector
=
options
.
focusEditableFieldContainerSelector
;
if
(
this
.
focusEditableFieldAfterApply
&
&
!
this
.
focusEditableFieldContainerSelector
)
{
throw
new
Error
(
"
focusEditableFieldContainerSelector
is
mandatory
when
focusEditableFieldAfterApply
is
true
"
)
;
}
this
.
#
createInput
(
options
)
;
this
.
originalDisplay
=
this
.
elt
.
style
.
display
;
this
.
elt
.
style
.
display
=
"
none
"
;
this
.
elt
.
parentNode
.
insertBefore
(
this
.
input
this
.
elt
)
;
this
.
#
autosize
(
)
;
this
.
inputCharDimensions
=
this
.
#
getInputCharDimensions
(
)
;
if
(
typeof
options
.
advanceChars
=
=
=
"
function
"
)
{
this
.
#
advanceChars
=
options
.
advanceChars
;
}
else
{
const
advanceCharcodes
=
{
}
;
const
advanceChars
=
options
.
advanceChars
|
|
"
"
;
for
(
let
i
=
0
;
i
<
advanceChars
.
length
;
i
+
+
)
{
advanceCharcodes
[
advanceChars
.
charCodeAt
(
i
)
]
=
true
;
}
this
.
#
advanceChars
=
charCode
=
>
charCode
in
advanceCharcodes
;
}
this
.
input
.
focus
(
)
;
if
(
typeof
options
.
selectAll
=
=
"
undefined
"
|
|
options
.
selectAll
)
{
this
.
input
.
select
(
)
;
}
const
win
=
doc
.
defaultView
;
this
.
#
abortController
=
new
win
.
AbortController
(
)
;
const
eventListenerConfig
=
{
signal
:
this
.
#
abortController
.
signal
}
;
this
.
input
.
addEventListener
(
"
blur
"
this
.
#
onBlur
eventListenerConfig
)
;
this
.
input
.
addEventListener
(
"
keypress
"
this
.
#
onKeyPress
eventListenerConfig
)
;
this
.
input
.
addEventListener
(
"
wheel
"
this
.
#
onWheel
eventListenerConfig
)
;
this
.
input
.
addEventListener
(
"
input
"
this
.
#
onInput
eventListenerConfig
)
;
this
.
input
.
addEventListener
(
"
dblclick
"
this
.
#
stopEventPropagation
eventListenerConfig
)
;
this
.
input
.
addEventListener
(
"
click
"
this
.
#
stopEventPropagation
eventListenerConfig
)
;
this
.
input
.
addEventListener
(
"
mousedown
"
this
.
#
stopEventPropagation
eventListenerConfig
)
;
this
.
input
.
addEventListener
(
"
contextmenu
"
this
.
#
onContextMenu
eventListenerConfig
)
;
win
.
addEventListener
(
"
blur
"
this
.
#
onWindowBlur
eventListenerConfig
)
;
this
.
validate
=
options
.
validate
;
if
(
this
.
validate
)
{
this
.
input
.
addEventListener
(
"
keyup
"
this
.
#
onKeyup
eventListenerConfig
)
;
}
this
.
#
updateSize
(
)
;
if
(
options
.
start
)
{
options
.
start
(
this
event
)
;
}
this
.
#
getGridNamesBeforeCompletion
(
options
.
getGridLineNames
)
;
}
static
CONTENT_TYPES
=
CONTENT_TYPES
;
#
abortController
;
#
advanceChars
;
#
applied
;
#
measurement
;
#
openPopupTimeout
;
#
pressedKey
;
#
preventSuggestions
;
#
selectedIndex
;
#
variableNames
;
#
variables
;
get
currentInputValue
(
)
{
const
val
=
this
.
trimOutput
?
this
.
input
.
value
.
trim
(
)
:
this
.
input
.
value
;
return
val
;
}
#
createInput
(
options
=
{
}
)
{
this
.
input
=
this
.
doc
.
createElementNS
(
HTML_NS
this
.
multiline
?
"
textarea
"
:
"
input
"
)
;
this
.
input
.
inplaceEditor
=
this
;
if
(
this
.
multiline
)
{
this
.
input
.
style
.
resize
=
"
none
"
;
this
.
input
.
style
.
overflow
=
"
hidden
"
;
this
.
input
.
style
.
padding
=
"
0
"
;
}
this
.
input
.
classList
.
add
(
"
styleinspector
-
propertyeditor
"
)
;
if
(
options
.
inputClass
)
{
this
.
input
.
classList
.
add
(
options
.
inputClass
)
;
}
this
.
input
.
value
=
this
.
initial
;
if
(
options
.
inputAriaLabel
)
{
this
.
input
.
setAttribute
(
"
aria
-
label
"
options
.
inputAriaLabel
)
;
}
else
if
(
options
.
inputAriaLabelledBy
)
{
this
.
input
.
setAttribute
(
"
aria
-
labelledby
"
options
.
inputAriaLabelledBy
)
;
}
if
(
!
this
.
preserveTextStyles
)
{
copyTextStyles
(
this
.
elt
this
.
input
)
;
}
}
#
clear
(
doneCallResult
)
{
if
(
!
this
.
input
)
{
return
;
}
this
.
#
abortController
.
abort
(
)
;
this
.
#
stopAutosize
(
)
;
this
.
elt
.
style
.
display
=
this
.
originalDisplay
;
if
(
this
.
doc
.
activeElement
=
=
this
.
input
)
{
this
.
elt
.
focus
(
)
;
}
this
.
input
.
remove
(
)
;
this
.
input
=
null
;
delete
this
.
elt
.
inplaceEditor
;
delete
this
.
elt
;
if
(
this
.
destroy
)
{
this
.
destroy
(
doneCallResult
)
;
}
}
#
autosize
(
)
{
this
.
#
measurement
=
this
.
doc
.
createElementNS
(
HTML_NS
this
.
multiline
?
"
pre
"
:
"
span
"
)
;
this
.
#
measurement
.
className
=
"
autosizer
"
;
this
.
elt
.
parentNode
.
appendChild
(
this
.
#
measurement
)
;
const
style
=
this
.
#
measurement
.
style
;
style
.
visibility
=
"
hidden
"
;
style
.
position
=
"
absolute
"
;
style
.
top
=
"
0
"
;
style
.
left
=
"
0
"
;
if
(
this
.
multiline
)
{
style
.
whiteSpace
=
"
pre
-
wrap
"
;
style
.
wordWrap
=
"
break
-
word
"
;
if
(
this
.
maxWidth
)
{
style
.
maxWidth
=
this
.
maxWidth
+
"
px
"
;
style
.
position
=
"
fixed
"
;
}
}
copyAllStyles
(
this
.
input
this
.
#
measurement
)
;
this
.
#
updateSize
(
)
;
}
#
stopAutosize
(
)
{
if
(
!
this
.
#
measurement
)
{
return
;
}
this
.
#
measurement
.
remove
(
)
;
this
.
#
measurement
=
null
;
}
#
updateSize
(
)
{
let
content
=
this
.
input
.
value
;
const
unbreakableSpace
=
"
\
u00a0
"
;
if
(
content
=
=
=
"
"
)
{
content
=
unbreakableSpace
;
}
if
(
content
.
lastIndexOf
(
"
\
n
"
)
=
=
=
content
.
length
-
1
)
{
content
=
content
+
unbreakableSpace
;
}
if
(
!
this
.
multiline
)
{
content
=
content
.
replace
(
/
/
g
unbreakableSpace
)
;
}
this
.
#
measurement
.
textContent
=
content
;
let
width
=
this
.
#
measurement
.
getBoundingClientRect
(
)
.
width
;
if
(
this
.
multiline
)
{
if
(
this
.
maxWidth
)
{
width
=
Math
.
min
(
this
.
maxWidth
width
)
;
}
const
height
=
this
.
#
measurement
.
getBoundingClientRect
(
)
.
height
;
this
.
input
.
style
.
height
=
height
+
"
px
"
;
}
this
.
input
.
style
.
width
=
width
+
"
px
"
;
}
#
getInputCharDimensions
(
)
{
this
.
#
measurement
.
textContent
=
"
x
"
;
const
width
=
this
.
#
measurement
.
clientWidth
;
const
height
=
this
.
#
measurement
.
clientHeight
;
return
{
width
height
}
;
}
#
incrementValue
(
increment
)
{
const
value
=
this
.
input
.
value
;
const
selectionStart
=
this
.
input
.
selectionStart
;
const
selectionEnd
=
this
.
input
.
selectionEnd
;
const
newValue
=
this
.
#
incrementCSSValue
(
value
increment
selectionStart
selectionEnd
)
;
if
(
!
newValue
)
{
return
false
;
}
this
.
input
.
value
=
newValue
.
value
;
this
.
input
.
setSelectionRange
(
newValue
.
start
newValue
.
end
)
;
this
.
#
doValidation
(
)
;
if
(
this
.
change
)
{
this
.
change
(
this
.
currentInputValue
)
;
}
return
true
;
}
#
incrementCSSValue
(
value
increment
selStart
selEnd
)
{
const
range
=
this
.
#
parseCSSValue
(
value
selStart
)
;
const
type
=
range
?
.
type
|
|
"
"
;
const
rawValue
=
range
?
value
.
substring
(
range
.
start
range
.
end
)
:
"
"
;
const
preRawValue
=
range
?
value
.
substr
(
0
range
.
start
)
:
"
"
;
const
postRawValue
=
range
?
value
.
substr
(
range
.
end
)
:
"
"
;
let
info
;
let
incrementedValue
=
null
selection
;
if
(
type
=
=
=
"
num
"
)
{
if
(
rawValue
=
=
"
0
"
)
{
info
=
{
}
;
info
.
units
=
this
.
#
findCompatibleUnit
(
preRawValue
postRawValue
)
;
}
const
newValue
=
this
.
#
incrementRawValue
(
rawValue
increment
info
)
;
if
(
newValue
!
=
=
null
)
{
incrementedValue
=
newValue
;
selection
=
[
0
incrementedValue
.
length
]
;
}
}
else
if
(
type
=
=
=
"
hex
"
)
{
const
exprOffset
=
selStart
-
range
.
start
;
const
exprOffsetEnd
=
selEnd
-
range
.
start
;
const
newValue
=
this
.
#
incHexColor
(
rawValue
increment
exprOffset
exprOffsetEnd
)
;
if
(
newValue
)
{
incrementedValue
=
newValue
.
value
;
selection
=
newValue
.
selection
;
}
}
else
{
if
(
type
=
=
=
"
rgb
"
|
|
type
=
=
=
"
hsl
"
|
|
type
=
=
=
"
hwb
"
)
{
info
=
{
}
;
const
isCSS4Color
=
!
value
.
includes
(
"
"
)
;
/
/
In
case
the
value
uses
the
new
syntax
of
the
CSS
Color
4
specification
/
/
it
is
split
by
the
spaces
and
the
slash
separating
the
alpha
value
/
/
between
the
different
color
components
.
/
/
Example
:
rgb
(
255
0
0
/
0
.
5
)
/
/
Otherwise
the
value
is
represented
using
the
old
color
syntax
and
is
/
/
split
by
the
commas
between
the
color
components
.
/
/
Example
:
rgba
(
255
0
0
0
.
5
)
const
part
=
value
.
substring
(
range
.
start
selStart
)
.
split
(
isCSS4Color
?
/
?
\
/
?
|
/
:
"
"
)
.
length
-
1
;
if
(
part
=
=
=
3
)
{
/
/
alpha
info
.
minValue
=
0
;
info
.
maxValue
=
1
;
}
else
if
(
type
=
=
=
"
rgb
"
)
{
info
.
minValue
=
0
;
info
.
maxValue
=
255
;
}
else
if
(
part
!
=
=
0
)
{
/
/
hsl
or
hwb
percentage
info
.
minValue
=
0
;
info
.
maxValue
=
100
;
/
/
select
the
previous
number
if
the
selection
is
at
the
end
of
a
/
/
percentage
sign
.
if
(
value
.
charAt
(
selStart
-
1
)
=
=
=
"
%
"
)
{
-
-
selStart
;
}
}
}
return
this
.
#
incrementGenericValue
(
value
increment
selStart
selEnd
info
)
;
}
if
(
incrementedValue
=
=
=
null
)
{
return
null
;
}
return
{
value
:
preRawValue
+
incrementedValue
+
postRawValue
start
:
range
.
start
+
selection
[
0
]
end
:
range
.
start
+
selection
[
1
]
}
;
}
/
*
*
*
Find
a
compatible
unit
to
use
for
a
CSS
number
value
inserted
between
the
*
provided
beforeValue
and
afterValue
.
The
compatible
unit
will
be
picked
*
from
a
selection
of
default
units
corresponding
to
supported
CSS
value
*
dimensions
(
distance
angle
duration
)
.
*
*
param
{
string
}
beforeValue
*
The
string
preceeding
the
number
value
in
the
current
property
*
value
.
*
param
{
string
}
afterValue
*
The
string
following
the
number
value
in
the
current
property
value
.
*
return
{
string
}
a
valid
unit
that
can
be
used
for
this
number
value
or
*
empty
string
if
no
match
could
be
found
.
*
/
#
findCompatibleUnit
(
beforeValue
afterValue
)
{
if
(
!
this
.
property
|
|
!
this
.
property
.
name
)
{
return
"
"
;
}
const
el
=
this
.
doc
.
createElement
(
"
div
"
)
;
const
units
=
[
"
"
"
px
"
"
deg
"
"
s
"
]
;
for
(
const
unit
of
units
)
{
const
value
=
beforeValue
+
"
1
"
+
unit
+
afterValue
;
el
.
style
.
setProperty
(
this
.
property
.
name
"
"
)
;
el
.
style
.
setProperty
(
this
.
property
.
name
value
)
;
if
(
el
.
style
.
getPropertyValue
(
this
.
property
.
name
)
!
=
=
"
"
)
{
return
unit
;
}
}
return
"
"
;
}
#
parseCSSValue
(
value
offset
)
{
const
reSplitCSS
=
/
(
?
<
url
>
url
\
(
"
?
[
^
"
\
)
]
+
"
?
\
)
?
)
|
(
?
<
rgb
>
rgba
?
\
(
[
^
)
]
*
\
)
?
)
|
(
?
<
hsl
>
hsla
?
\
(
[
^
)
]
*
\
)
?
)
|
(
?
<
hwb
>
hwb
\
(
[
^
)
]
*
\
)
?
)
|
(
?
<
hex
>
#
[
\
dA
-
Fa
-
f
]
+
)
|
(
?
<
number
>
-
?
\
d
*
\
.
?
\
d
+
(
%
|
[
a
-
z
]
{
1
4
}
)
?
)
|
"
(
[
^
"
]
*
)
"
?
|
'
(
[
^
'
]
*
)
'
?
|
(
[
^
\
s
\
/
!
\
(
\
)
]
+
)
|
(
!
(
.
*
)
?
)
/
;
let
start
=
0
;
let
m
;
while
(
(
m
=
reSplitCSS
.
exec
(
value
)
)
&
&
m
.
index
+
m
[
0
]
.
length
<
offset
)
{
value
=
value
.
substring
(
m
.
index
+
m
[
0
]
.
length
)
;
start
+
=
m
.
index
+
m
[
0
]
.
length
;
offset
-
=
m
.
index
+
m
[
0
]
.
length
;
}
if
(
!
m
)
{
return
null
;
}
let
type
;
if
(
m
.
groups
.
url
)
{
type
=
"
url
"
;
}
else
if
(
m
.
groups
.
rgb
)
{
type
=
"
rgb
"
;
}
else
if
(
m
.
groups
.
hsl
)
{
type
=
"
hsl
"
;
}
else
if
(
m
.
groups
.
hwb
)
{
type
=
"
hwb
"
;
}
else
if
(
m
.
groups
.
hex
)
{
type
=
"
hex
"
;
}
else
if
(
m
.
groups
.
number
)
{
type
=
"
num
"
;
}
return
{
value
:
m
[
0
]
start
:
start
+
m
.
index
end
:
start
+
m
.
index
+
m
[
0
]
.
length
type
}
;
}
#
incrementGenericValue
(
value
increment
offset
offsetEnd
info
)
{
let
start
end
;
if
(
/
^
-
?
[
0
-
9
.
]
/
.
test
(
value
.
substring
(
offset
offsetEnd
)
)
&
&
!
/
\
d
/
.
test
(
value
.
charAt
(
offset
-
1
)
+
value
.
charAt
(
offsetEnd
)
)
)
{
start
=
offset
;
end
=
offsetEnd
;
}
else
{
const
pattern
=
"
[
"
+
(
info
?
"
0
-
9
.
"
:
"
0
-
9
"
)
+
"
]
*
"
;
const
before
=
new
RegExp
(
pattern
+
"
"
)
.
exec
(
value
.
substr
(
0
offset
)
)
[
0
]
.
length
;
const
after
=
new
RegExp
(
"
^
"
+
pattern
)
.
exec
(
value
.
substr
(
offset
)
)
[
0
]
.
length
;
start
=
offset
-
before
;
end
=
offset
+
after
;
if
(
value
.
charAt
(
start
-
1
)
=
=
=
"
-
"
&
&
(
start
-
1
=
=
=
0
|
|
/
[
(
:
=
'
"
]
/
.
test
(
value
.
charAt
(
start
-
2
)
)
)
)
{
-
-
start
;
}
}
if
(
start
!
=
=
end
)
{
if
(
value
.
charAt
(
end
)
=
=
=
"
%
"
)
{
+
+
end
;
}
const
first
=
value
.
substr
(
0
start
)
;
let
mid
=
value
.
substring
(
start
end
)
;
const
last
=
value
.
substr
(
end
)
;
mid
=
this
.
#
incrementRawValue
(
mid
increment
info
)
;
if
(
mid
!
=
=
null
)
{
return
{
value
:
first
+
mid
+
last
start
end
:
start
+
mid
.
length
}
;
}
}
return
null
;
}
#
incrementRawValue
(
rawValue
increment
info
)
{
const
num
=
parseFloat
(
rawValue
)
;
if
(
isNaN
(
num
)
)
{
return
null
;
}
const
number
=
/
\
d
+
(
\
.
\
d
+
)
?
/
.
exec
(
rawValue
)
;
let
units
=
rawValue
.
substr
(
number
.
index
+
number
[
0
]
.
length
)
;
if
(
info
&
&
"
units
"
in
info
)
{
units
=
info
.
units
;
}
let
newValue
=
Math
.
round
(
(
num
+
increment
)
*
1000
)
/
1000
;
if
(
info
&
&
"
minValue
"
in
info
)
{
newValue
=
Math
.
max
(
newValue
info
.
minValue
)
;
}
if
(
info
&
&
"
maxValue
"
in
info
)
{
newValue
=
Math
.
min
(
newValue
info
.
maxValue
)
;
}
newValue
=
newValue
.
toString
(
)
;
return
newValue
+
units
;
}
#
incHexColor
(
rawValue
increment
offset
offsetEnd
)
{
if
(
offsetEnd
>
rawValue
.
length
&
&
offset
>
=
rawValue
.
length
)
{
return
null
;
}
if
(
offset
<
1
&
&
offsetEnd
<
=
1
)
{
return
null
;
}
rawValue
=
rawValue
.
substr
(
1
)
;
-
-
offset
;
-
-
offsetEnd
;
offset
=
Math
.
max
(
offset
0
)
;
offsetEnd
=
Math
.
min
(
offsetEnd
rawValue
.
length
)
;
offsetEnd
=
Math
.
max
(
offsetEnd
offset
)
;
if
(
rawValue
.
length
=
=
=
3
)
{
rawValue
=
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
2
)
+
rawValue
.
charAt
(
2
)
;
offset
*
=
2
;
offsetEnd
*
=
2
;
}
if
(
rawValue
.
length
=
=
=
4
)
{
rawValue
=
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
2
)
+
rawValue
.
charAt
(
2
)
+
rawValue
.
charAt
(
3
)
+
rawValue
.
charAt
(
3
)
;
offset
*
=
2
;
offsetEnd
*
=
2
;
}
if
(
rawValue
.
length
!
=
=
6
&
&
rawValue
.
length
!
=
=
8
)
{
return
null
;
}
if
(
offset
=
=
=
offsetEnd
)
{
if
(
offset
=
=
=
0
)
{
offsetEnd
=
1
;
}
else
{
offset
=
offsetEnd
-
1
;
}
}
offset
-
=
offset
%
2
;
offsetEnd
+
=
offsetEnd
%
2
;
if
(
increment
>
-
1
&
&
increment
<
1
)
{
increment
=
increment
<
0
?
-
1
:
1
;
}
if
(
Math
.
abs
(
increment
)
=
=
=
10
)
{
increment
=
increment
<
0
?
-
16
:
16
;
}
const
isUpper
=
rawValue
.
toUpperCase
(
)
=
=
=
rawValue
;
for
(
let
pos
=
offset
;
pos
<
offsetEnd
;
pos
+
=
2
)
{
let
mid
=
rawValue
.
substr
(
pos
2
)
;
const
value
=
parseInt
(
mid
16
)
;
if
(
isNaN
(
value
)
)
{
return
null
;
}
mid
=
Math
.
min
(
Math
.
max
(
value
+
increment
0
)
255
)
.
toString
(
16
)
;
while
(
mid
.
length
<
2
)
{
mid
=
"
0
"
+
mid
;
}
if
(
isUpper
)
{
mid
=
mid
.
toUpperCase
(
)
;
}
rawValue
=
rawValue
.
substr
(
0
pos
)
+
mid
+
rawValue
.
substr
(
pos
+
2
)
;
}
return
{
value
:
"
#
"
+
rawValue
selection
:
[
offset
+
1
offsetEnd
+
1
]
}
;
}
#
cycleCSSSuggestion
(
reverse
noSelect
)
{
const
{
label
preLabel
}
=
this
.
popup
.
selectedItem
|
|
{
label
:
"
"
preLabel
:
"
"
}
;
if
(
reverse
)
{
this
.
popup
.
selectPreviousItem
(
)
;
}
else
{
this
.
popup
.
selectNextItem
(
)
;
}
this
.
#
selectedIndex
=
this
.
popup
.
selectedIndex
;
const
input
=
this
.
input
;
let
pre
=
"
"
;
if
(
input
.
selectionStart
<
input
.
selectionEnd
)
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
)
;
}
else
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
-
label
.
length
+
preLabel
.
length
)
;
}
const
post
=
input
.
value
.
slice
(
input
.
selectionEnd
input
.
value
.
length
)
;
const
item
=
this
.
popup
.
selectedItem
;
const
toComplete
=
item
.
label
.
slice
(
item
.
preLabel
.
length
)
;
input
.
value
=
pre
+
toComplete
+
post
;
if
(
!
noSelect
)
{
input
.
setSelectionRange
(
pre
.
length
pre
.
length
+
toComplete
.
length
)
;
}
else
{
input
.
setSelectionRange
(
pre
.
length
+
toComplete
.
length
pre
.
length
+
toComplete
.
length
)
;
}
this
.
#
updateSize
(
)
;
this
.
emit
(
"
after
-
suggest
"
)
;
}
#
apply
(
direction
key
)
{
if
(
this
.
#
applied
)
{
return
null
;
}
this
.
#
applied
=
true
;
if
(
this
.
done
)
{
const
val
=
this
.
cancelled
?
this
.
initial
:
this
.
currentInputValue
;
return
this
.
done
(
val
!
this
.
cancelled
direction
key
)
;
}
return
null
;
}
#
onWindowBlur
=
(
)
=
>
{
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
this
.
popup
.
hidePopup
(
)
;
}
if
(
this
.
#
openPopupTimeout
)
{
this
.
doc
.
defaultView
.
clearTimeout
(
this
.
#
openPopupTimeout
)
;
}
}
;
#
onBlur
=
event
=
>
{
if
(
event
&
&
this
.
popup
&
&
this
.
popup
.
isOpen
&
&
this
.
popup
.
selectedIndex
>
=
0
)
{
this
.
#
acceptPopupSuggestion
(
)
;
}
else
{
const
onApplied
=
this
.
#
apply
(
)
;
this
.
#
clear
(
onApplied
)
;
}
}
;
async
#
getGridNamesBeforeCompletion
(
getGridLineNames
)
{
if
(
getGridLineNames
&
&
this
.
property
&
&
GRID_PROPERTY_NAMES
.
includes
(
this
.
property
.
name
)
)
{
this
.
gridLineNames
=
await
getGridLineNames
(
)
;
}
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_VALUE
&
&
this
.
input
&
&
this
.
input
.
value
=
=
"
"
)
{
this
.
#
maybeSuggestCompletion
(
false
)
;
}
}
#
onAutocompletePopupClick
=
(
)
=
>
{
this
.
#
acceptPopupSuggestion
(
)
;
}
;
#
acceptPopupSuggestion
(
)
{
let
label
preLabel
;
if
(
this
.
#
selectedIndex
=
=
=
undefined
)
{
(
{
label
preLabel
}
=
this
.
popup
.
getItemAtIndex
(
this
.
popup
.
selectedIndex
)
)
;
}
else
{
(
{
label
preLabel
}
=
this
.
popup
.
getItemAtIndex
(
this
.
#
selectedIndex
)
)
;
}
const
input
=
this
.
input
;
let
pre
=
"
"
;
if
(
input
.
selectionStart
<
input
.
selectionEnd
|
|
this
.
contentType
!
=
=
CONTENT_TYPES
.
CSS_MIXED
)
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
)
;
}
else
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
-
label
.
length
+
preLabel
.
length
)
;
}
const
post
=
input
.
value
.
slice
(
input
.
selectionEnd
input
.
value
.
length
)
;
const
item
=
this
.
popup
.
selectedItem
;
this
.
#
selectedIndex
=
this
.
popup
.
selectedIndex
;
const
toComplete
=
item
.
label
.
slice
(
item
.
preLabel
.
length
)
;
input
.
value
=
pre
+
toComplete
+
post
;
input
.
setSelectionRange
(
pre
.
length
+
toComplete
.
length
pre
.
length
+
toComplete
.
length
)
;
this
.
#
updateSize
(
)
;
const
onPopupHidden
=
(
)
=
>
{
this
.
popup
.
off
(
"
popup
-
closed
"
onPopupHidden
)
;
this
.
doc
.
defaultView
.
setTimeout
(
(
)
=
>
{
input
.
focus
(
)
;
this
.
emit
(
"
after
-
suggest
"
)
;
}
0
)
;
}
;
this
.
popup
.
on
(
"
popup
-
closed
"
onPopupHidden
)
;
this
.
#
hideAutocompletePopup
(
)
;
}
#
onKeyPress
=
event
=
>
{
let
prevent
=
false
;
const
key
=
event
.
keyCode
;
const
input
=
this
.
input
;
this
.
#
pressedKey
=
event
.
key
;
const
multilineNavigation
=
!
this
.
#
isSingleLine
(
)
&
&
isKeyIn
(
key
"
UP
"
"
DOWN
"
"
LEFT
"
"
RIGHT
"
)
;
const
isPlainText
=
this
.
contentType
=
=
CONTENT_TYPES
.
PLAIN_TEXT
;
const
isPopupOpen
=
this
.
popup
&
&
this
.
popup
.
isOpen
;
let
increment
=
0
;
if
(
!
isPlainText
&
&
!
multilineNavigation
)
{
increment
=
this
.
#
getIncrement
(
event
)
;
}
if
(
isKeyIn
(
key
"
PAGE_UP
"
"
PAGE_DOWN
"
)
)
{
this
.
#
preventSuggestions
=
true
;
}
let
cycling
=
false
;
if
(
increment
&
&
this
.
#
incrementValue
(
increment
)
)
{
this
.
#
updateSize
(
)
;
prevent
=
true
;
cycling
=
true
;
}
if
(
isPopupOpen
&
&
isKeyIn
(
key
"
UP
"
"
DOWN
"
"
PAGE_UP
"
"
PAGE_DOWN
"
)
)
{
prevent
=
true
;
cycling
=
true
;
this
.
#
cycleCSSSuggestion
(
isKeyIn
(
key
"
UP
"
"
PAGE_UP
"
)
)
;
this
.
#
doValidation
(
)
;
}
if
(
isKeyIn
(
key
"
BACK_SPACE
"
"
DELETE
"
"
LEFT
"
"
RIGHT
"
"
HOME
"
"
END
"
)
)
{
if
(
isPopupOpen
&
&
this
.
currentInputValue
!
=
=
"
"
)
{
this
.
#
hideAutocompletePopup
(
)
;
}
}
else
if
(
(
event
.
key
=
=
=
"
"
&
&
event
.
ctrlKey
)
|
|
(
!
cycling
&
&
!
multilineNavigation
&
&
!
event
.
metaKey
&
&
!
event
.
altKey
&
&
!
event
.
ctrlKey
&
&
!
(
isKeyIn
(
key
"
UP
"
"
DOWN
"
)
&
&
event
.
shiftKey
)
)
)
{
this
.
#
maybeSuggestCompletion
(
true
)
;
}
if
(
this
.
multiline
&
&
event
.
shiftKey
&
&
isKeyIn
(
key
"
RETURN
"
)
)
{
prevent
=
false
;
}
else
if
(
this
.
#
advanceChars
(
event
.
charCode
input
.
value
input
.
selectionStart
)
|
|
isKeyIn
(
key
"
RETURN
"
"
TAB
"
)
)
{
prevent
=
true
;
const
ctrlOrCmd
=
isOSX
?
event
.
metaKey
:
event
.
ctrlKey
;
let
direction
;
if
(
(
this
.
stopOnReturn
&
&
isKeyIn
(
key
"
RETURN
"
)
&
&
!
ctrlOrCmd
)
|
|
(
this
.
stopOnTab
&
&
!
event
.
shiftKey
&
&
isKeyIn
(
key
"
TAB
"
)
)
|
|
(
this
.
stopOnShiftTab
&
&
event
.
shiftKey
&
&
isKeyIn
(
key
"
TAB
"
)
)
)
{
direction
=
null
;
}
else
if
(
event
.
shiftKey
&
&
isKeyIn
(
key
"
TAB
"
)
)
{
direction
=
FOCUS_BACKWARD
;
}
else
{
direction
=
FOCUS_FORWARD
;
}
this
.
#
preventSuggestions
=
true
;
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_PROPERTY
&
&
direction
=
=
FOCUS_FORWARD
)
{
this
.
#
preventSuggestions
=
false
;
}
if
(
isKeyIn
(
key
"
TAB
"
)
&
&
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_MIXED
)
{
if
(
this
.
popup
&
&
input
.
selectionStart
<
input
.
selectionEnd
)
{
event
.
preventDefault
(
)
;
input
.
setSelectionRange
(
input
.
selectionEnd
input
.
selectionEnd
)
;
this
.
emit
(
"
after
-
suggest
"
)
;
return
;
}
else
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
event
.
preventDefault
(
)
;
this
.
#
cycleCSSSuggestion
(
event
.
shiftKey
true
)
;
return
;
}
}
const
onApplied
=
this
.
#
apply
(
direction
key
)
;
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
this
.
#
hideAutocompletePopup
(
)
;
}
if
(
direction
!
=
=
null
&
&
focusManager
.
focusedElement
=
=
=
input
)
{
const
next
=
moveFocus
(
this
.
doc
.
defaultView
direction
this
.
focusEditableFieldAfterApply
this
.
focusEditableFieldContainerSelector
)
;
if
(
next
&
&
next
.
ownerDocument
=
=
=
this
.
doc
&
&
next
.
_editable
)
{
const
e
=
this
.
doc
.
createEvent
(
"
Event
"
)
;
e
.
initEvent
(
next
.
_trigger
true
true
)
;
next
.
dispatchEvent
(
e
)
;
}
}
this
.
#
clear
(
onApplied
)
;
}
else
if
(
isKeyIn
(
key
"
ESCAPE
"
)
)
{
this
.
#
preventSuggestions
=
true
;
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
this
.
#
hideAutocompletePopup
(
)
;
}
else
{
this
.
cancelled
=
true
;
const
onApplied
=
this
.
#
apply
(
)
;
this
.
#
clear
(
onApplied
)
;
}
prevent
=
true
;
event
.
stopPropagation
(
)
;
}
else
if
(
isKeyIn
(
key
"
SPACE
"
)
)
{
prevent
=
!
input
.
value
;
}
if
(
prevent
)
{
event
.
preventDefault
(
)
;
}
}
;
#
onContextMenu
=
event
=
>
{
if
(
this
.
contextMenu
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
this
.
contextMenu
(
event
)
;
}
}
;
#
openAutocompletePopup
(
offset
selectedIndex
)
{
this
.
popup
.
on
(
"
popup
-
click
"
this
.
#
onAutocompletePopupClick
)
;
this
.
popup
.
openPopup
(
this
.
input
offset
0
selectedIndex
)
;
}
#
hideAutocompletePopup
(
)
{
this
.
popup
.
off
(
"
popup
-
click
"
this
.
#
onAutocompletePopupClick
)
;
this
.
popup
.
hidePopup
(
)
;
}
#
getIncrement
(
event
)
{
const
largeIncrement
=
100
;
const
mediumIncrement
=
10
;
const
smallIncrement
=
0
.
1
;
let
increment
=
0
;
let
wheelUp
=
false
;
let
wheelDown
=
false
;
if
(
event
.
type
=
=
=
"
wheel
"
)
{
if
(
event
.
wheelDelta
>
0
)
{
wheelUp
=
true
;
}
else
if
(
event
.
wheelDelta
<
0
)
{
wheelDown
=
true
;
}
}
const
key
=
event
.
keyCode
;
if
(
wheelUp
|
|
isKeyIn
(
key
"
UP
"
"
PAGE_UP
"
)
)
{
increment
=
1
*
this
.
defaultIncrement
;
}
else
if
(
wheelDown
|
|
isKeyIn
(
key
"
DOWN
"
"
PAGE_DOWN
"
)
)
{
increment
=
-
1
*
this
.
defaultIncrement
;
}
const
largeIncrementKeyPressed
=
event
.
shiftKey
;
const
smallIncrementKeyPressed
=
this
.
#
isSmallIncrementKeyPressed
(
event
)
;
if
(
largeIncrementKeyPressed
&
&
!
smallIncrementKeyPressed
)
{
if
(
isKeyIn
(
key
"
PAGE_UP
"
"
PAGE_DOWN
"
)
)
{
increment
*
=
largeIncrement
;
}
else
{
increment
*
=
mediumIncrement
;
}
}
else
if
(
smallIncrementKeyPressed
&
&
!
largeIncrementKeyPressed
)
{
increment
*
=
smallIncrement
;
}
return
increment
;
}
#
isSmallIncrementKeyPressed
=
evt
=
>
{
if
(
isOSX
)
{
return
evt
.
altKey
;
}
return
evt
.
ctrlKey
;
}
;
#
onKeyup
=
(
)
=
>
{
this
.
#
applied
=
false
;
}
;
#
onInput
=
(
)
=
>
{
this
.
#
doValidation
(
)
;
if
(
this
.
#
measurement
)
{
this
.
#
updateSize
(
)
;
}
if
(
this
.
change
)
{
this
.
change
(
this
.
currentInputValue
)
;
}
if
(
this
.
currentInputValue
=
=
=
"
"
&
&
this
.
showSuggestCompletionOnEmpty
)
{
this
.
#
maybeSuggestCompletion
(
false
)
;
}
}
;
#
onWheel
=
event
=
>
{
const
isPlainText
=
this
.
contentType
=
=
CONTENT_TYPES
.
PLAIN_TEXT
;
let
increment
=
0
;
if
(
!
isPlainText
)
{
increment
=
this
.
#
getIncrement
(
event
)
;
}
if
(
increment
&
&
this
.
#
incrementValue
(
increment
)
)
{
this
.
#
updateSize
(
)
;
event
.
preventDefault
(
)
;
}
}
;
#
stopEventPropagation
(
e
)
{
e
.
stopPropagation
(
)
;
}
#
doValidation
(
)
{
if
(
this
.
validate
&
&
this
.
input
)
{
this
.
validate
(
this
.
input
.
value
)
;
}
}
#
maybeSuggestCompletion
(
autoInsert
)
{
if
(
!
this
.
input
)
{
return
;
}
const
preTimeoutQuery
=
this
.
input
.
value
;
this
.
#
openPopupTimeout
=
this
.
doc
.
defaultView
.
setTimeout
(
(
)
=
>
{
if
(
this
.
#
preventSuggestions
)
{
this
.
#
preventSuggestions
=
false
;
return
;
}
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
PLAIN_TEXT
)
{
return
;
}
if
(
!
this
.
input
)
{
return
;
}
const
input
=
this
.
input
;
if
(
input
.
value
.
length
-
preTimeoutQuery
.
length
>
1
)
{
return
;
}
const
query
=
input
.
value
.
slice
(
0
input
.
selectionStart
)
;
let
startCheckQuery
=
query
;
if
(
query
=
=
null
)
{
return
;
}
if
(
input
.
selectionStart
=
=
input
.
selectionEnd
&
&
input
.
selectionStart
<
input
.
value
.
length
)
{
const
nextChar
=
input
.
value
.
slice
(
input
.
selectionStart
)
[
0
]
;
if
(
/
[
\
w
-
]
/
.
test
(
nextChar
)
)
{
this
.
emit
(
"
after
-
suggest
"
"
nothing
to
autocomplete
"
)
;
return
;
}
}
let
list
=
[
]
;
let
postLabelValues
=
[
]
;
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_PROPERTY
)
{
list
=
this
.
#
getCSSVariableNames
(
)
.
concat
(
this
.
#
getCSSPropertyList
(
)
)
;
}
else
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_VALUE
)
{
const
lexer
=
new
InspectorCSSParserWrapper
(
query
)
;
const
functionStack
=
[
]
;
let
token
;
let
lastMeaningfulToken
;
let
foundImportant
=
false
;
let
importantState
=
"
"
;
let
queryStartIndex
=
0
;
while
(
(
token
=
lexer
.
nextToken
(
)
)
)
{
const
currentFunction
=
functionStack
.
at
(
-
1
)
;
if
(
token
.
tokenType
!
=
=
"
WhiteSpace
"
&
&
token
.
tokenType
!
=
=
"
Comment
"
)
{
lastMeaningfulToken
=
token
;
if
(
currentFunction
)
{
currentFunction
.
tokens
.
push
(
token
)
;
}
}
if
(
token
.
tokenType
=
=
=
"
Function
"
|
|
token
.
tokenType
=
=
=
"
ParenthesisBlock
"
)
{
functionStack
.
push
(
{
fnToken
:
token
tokens
:
[
]
}
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
CloseParenthesis
"
)
{
functionStack
.
pop
(
)
;
}
if
(
token
.
tokenType
=
=
=
"
WhiteSpace
"
|
|
token
.
tokenType
=
=
=
"
Comma
"
|
|
token
.
tokenType
=
=
=
"
Function
"
|
|
(
token
.
tokenType
=
=
=
"
Comment
"
&
&
token
.
text
.
length
>
=
4
&
&
token
.
text
.
endsWith
(
"
*
/
"
)
)
)
{
queryStartIndex
=
token
.
endOffset
;
}
if
(
!
foundImportant
)
{
if
(
token
.
tokenType
=
=
=
"
Delim
"
&
&
token
.
text
=
=
=
"
!
"
)
{
importantState
=
"
!
"
;
}
else
if
(
importantState
=
=
=
"
!
"
)
{
if
(
token
.
tokenType
=
=
=
"
Ident
"
&
&
token
.
text
=
=
=
"
important
"
)
{
foundImportant
=
true
;
break
;
}
else
{
importantState
=
"
"
;
}
}
}
}
startCheckQuery
=
query
.
substring
(
queryStartIndex
)
;
const
lastFunctionEntry
=
functionStack
.
at
(
-
1
)
;
const
functionValues
=
lastFunctionEntry
?
this
.
#
getAutocompleteDataForFunction
(
lastFunctionEntry
)
:
null
;
if
(
foundImportant
)
{
list
=
[
]
;
postLabelValues
=
[
]
;
}
else
if
(
functionValues
)
{
list
=
functionValues
.
list
;
postLabelValues
=
functionValues
.
postLabelValues
;
}
else
{
list
=
this
.
#
getCSSValuesForPropertyName
(
this
.
property
.
name
)
;
if
(
!
functionStack
.
length
&
&
!
input
.
value
.
slice
(
input
.
selectionStart
)
.
trim
(
)
&
&
lastMeaningfulToken
&
&
(
lastMeaningfulToken
.
tokenType
!
=
=
"
Delim
"
|
|
lastMeaningfulToken
.
text
!
=
=
"
/
"
)
&
&
lastMeaningfulToken
.
tokenType
!
=
=
"
Comma
"
&
&
!
input
.
value
.
trim
(
)
.
startsWith
(
"
!
"
)
)
{
list
.
unshift
(
"
!
important
"
)
;
}
}
}
else
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_MIXED
&
&
/
^
\
s
*
style
\
s
*
=
/
.
test
(
query
)
)
{
const
styleValue
=
query
.
replace
(
/
^
\
s
*
style
\
s
*
=
\
s
*
/
"
"
)
;
if
(
/
^
(
"
[
^
"
]
*
"
|
'
[
^
'
]
*
'
)
/
.
test
(
styleValue
)
)
{
this
.
emit
(
"
after
-
suggest
"
"
nothing
to
autocomplete
"
)
;
return
;
}
const
match
=
query
.
match
(
/
(
[
:
;
"
'
=
]
?
)
\
s
*
(
[
^
"
'
;
:
=
]
+
)
?
/
)
;
if
(
match
&
&
match
.
length
>
=
2
)
{
if
(
match
[
1
]
=
=
"
:
"
)
{
const
propertyName
=
query
.
match
(
/
[
;
"
'
=
]
\
s
*
(
[
^
"
'
;
:
=
]
+
)
\
s
*
:
\
s
*
[
^
"
'
;
:
=
]
*
/
)
[
1
]
;
list
=
[
"
!
important
;
"
.
.
.
this
.
#
getCSSValuesForPropertyName
(
propertyName
)
]
;
const
matchLastQuery
=
/
(
[
^
\
s
.
\
/
]
+
)
/
.
exec
(
match
[
2
]
|
|
"
"
)
;
if
(
matchLastQuery
)
{
startCheckQuery
=
matchLastQuery
[
0
]
;
}
else
{
startCheckQuery
=
"
"
;
}
if
(
!
match
[
2
]
)
{
list
.
splice
(
0
1
)
;
}
}
else
if
(
match
[
1
]
)
{
list
=
this
.
#
getCSSVariableNames
(
)
.
concat
(
this
.
#
getCSSPropertyList
(
)
)
;
startCheckQuery
=
match
[
2
]
;
}
if
(
startCheckQuery
=
=
null
)
{
this
.
emit
(
"
after
-
suggest
"
"
nothing
to
autocomplete
"
)
;
return
;
}
}
}
if
(
!
this
.
popup
)
{
this
.
emit
(
"
after
-
suggest
"
"
no
popup
"
)
;
return
;
}
const
finalList
=
[
]
;
const
length
=
list
.
length
;
for
(
let
i
=
0
count
=
0
;
i
<
length
&
&
count
<
MAX_POPUP_ENTRIES
;
i
+
+
)
{
if
(
startCheckQuery
!
=
null
&
&
list
[
i
]
.
startsWith
(
startCheckQuery
)
)
{
count
+
+
;
finalList
.
push
(
{
preLabel
:
startCheckQuery
label
:
list
[
i
]
postLabel
:
postLabelValues
[
i
]
?
postLabelValues
[
i
]
:
"
"
}
)
;
}
else
if
(
count
>
0
)
{
break
;
}
else
if
(
startCheckQuery
!
=
null
&
&
list
[
i
]
[
0
]
>
startCheckQuery
[
0
]
)
{
break
;
}
}
finalList
.
sort
(
(
item1
item2
)
=
>
{
let
comparison
=
item1
.
label
.
localeCompare
(
item2
.
label
)
;
if
(
/
^
\
w
/
.
test
(
item1
.
label
)
!
=
/
^
\
w
/
.
test
(
item2
.
label
)
)
{
comparison
=
-
1
*
comparison
;
}
return
comparison
;
}
)
;
let
index
=
0
;
if
(
startCheckQuery
)
{
const
cssValues
=
finalList
.
map
(
item
=
>
item
.
label
)
;
index
=
findMostRelevantCssPropertyIndex
(
cssValues
)
;
}
if
(
autoInsert
&
&
finalList
[
index
]
)
{
const
item
=
finalList
[
index
]
.
label
;
input
.
value
=
query
+
item
.
slice
(
startCheckQuery
.
length
)
+
input
.
value
.
slice
(
query
.
length
)
;
input
.
setSelectionRange
(
query
.
length
query
.
length
+
item
.
length
-
startCheckQuery
.
length
)
;
this
.
#
updateSize
(
)
;
}
if
(
finalList
.
length
>
1
)
{
const
indent
=
this
.
input
.
selectionStart
-
startCheckQuery
.
length
;
let
offset
=
indent
*
this
.
inputCharDimensions
.
width
;
offset
=
this
.
#
isSingleLine
(
)
?
offset
:
0
;
const
selectedIndex
=
autoInsert
?
index
:
-
1
;
this
.
popup
.
setItems
(
finalList
selectedIndex
)
;
this
.
#
openAutocompletePopup
(
offset
selectedIndex
)
;
}
else
{
this
.
#
hideAutocompletePopup
(
)
;
}
this
.
#
autocloseParenthesis
(
)
;
this
.
emit
(
"
after
-
suggest
"
)
;
this
.
#
doValidation
(
)
;
}
0
)
;
}
#
getAutocompleteDataForFunction
(
functionStackEntry
)
{
const
functionName
=
functionStackEntry
?
.
fnToken
?
.
value
;
if
(
!
functionName
)
{
return
null
;
}
let
list
=
[
]
;
let
postLabelValues
=
[
]
;
if
(
functionName
=
=
=
"
var
"
)
{
if
(
functionStackEntry
.
tokens
.
length
>
1
)
{
return
null
;
}
list
=
this
.
#
getCSSVariableNames
(
)
;
postLabelValues
=
list
.
map
(
varName
=
>
this
.
#
getCSSVariableValue
(
varName
)
)
;
}
else
if
(
functionName
.
includes
(
"
gradient
"
)
)
{
list
=
this
.
#
getCSSValuesForPropertyName
(
"
color
"
)
;
}
return
{
list
postLabelValues
}
;
}
#
autocloseParenthesis
(
)
{
const
{
selectionStart
selectionEnd
}
=
this
.
input
;
const
parts
=
this
.
#
splitStringAt
(
this
.
input
.
value
selectionEnd
)
;
const
nextChar
=
parts
[
1
]
[
0
]
;
if
(
this
.
#
pressedKey
=
=
"
(
"
&
&
!
isWordChar
(
nextChar
)
)
{
this
.
#
updateValue
(
parts
[
0
]
+
"
)
"
+
parts
[
1
]
)
;
}
if
(
this
.
#
pressedKey
=
=
"
)
"
&
&
nextChar
=
=
"
)
"
)
{
this
.
#
updateValue
(
parts
[
0
]
+
parts
[
1
]
.
substring
(
1
)
)
;
}
this
.
input
.
setSelectionRange
(
selectionStart
selectionEnd
)
;
this
.
#
pressedKey
=
null
;
}
#
updateValue
(
str
)
{
const
start
=
this
.
input
.
selectionStart
;
this
.
input
.
value
=
str
;
this
.
input
.
setSelectionRange
(
start
start
)
;
this
.
#
updateSize
(
)
;
}
#
splitStringAt
(
str
index
)
{
return
[
str
.
substring
(
0
index
)
str
.
substring
(
index
str
.
length
)
]
;
}
#
isSingleLine
(
)
{
if
(
!
this
.
multiline
)
{
return
true
;
}
const
inputRect
=
this
.
input
.
getBoundingClientRect
(
)
;
return
inputRect
.
height
<
2
*
this
.
inputCharDimensions
.
height
;
}
#
getCSSPropertyList
(
)
{
return
this
.
cssProperties
.
getNames
(
)
.
sort
(
)
;
}
#
getCSSValuesForPropertyName
(
propertyName
)
{
const
gridLineList
=
[
]
;
if
(
this
.
gridLineNames
)
{
if
(
GRID_ROW_PROPERTY_NAMES
.
includes
(
this
.
property
.
name
)
)
{
gridLineList
.
push
(
.
.
.
this
.
gridLineNames
.
rows
)
;
}
if
(
GRID_COL_PROPERTY_NAMES
.
includes
(
this
.
property
.
name
)
)
{
gridLineList
.
push
(
.
.
.
this
.
gridLineNames
.
cols
)
;
}
}
return
gridLineList
.
concat
(
this
.
cssProperties
.
getValues
(
propertyName
)
)
.
sort
(
)
;
}
#
getCSSVariablesMap
(
)
{
if
(
!
this
.
getCssVariables
)
{
return
null
;
}
if
(
!
this
.
#
variables
)
{
this
.
#
variables
=
this
.
getCssVariables
(
)
;
}
return
this
.
#
variables
;
}
#
getCSSVariableNames
(
)
{
if
(
!
this
.
#
variableNames
)
{
const
variables
=
this
.
#
getCSSVariablesMap
(
)
;
if
(
!
variables
)
{
return
[
]
;
}
this
.
#
variableNames
=
Array
.
from
(
variables
.
keys
(
)
)
.
sort
(
)
;
}
return
this
.
#
variableNames
;
}
#
getCSSVariableValue
(
varName
)
{
return
this
.
#
getCSSVariablesMap
(
)
?
.
get
(
varName
)
;
}
}
exports
.
InplaceEditor
=
InplaceEditor
;
function
copyTextStyles
(
from
to
)
{
const
win
=
from
.
ownerDocument
.
defaultView
;
const
style
=
win
.
getComputedStyle
(
from
)
;
to
.
style
.
fontFamily
=
style
.
fontFamily
;
to
.
style
.
fontSize
=
style
.
fontSize
;
to
.
style
.
fontWeight
=
style
.
fontWeight
;
to
.
style
.
fontStyle
=
style
.
fontStyle
;
}
function
copyAllStyles
(
from
to
)
{
const
win
=
from
.
ownerDocument
.
defaultView
;
const
style
=
win
.
getComputedStyle
(
from
)
;
copyTextStyles
(
from
to
)
;
to
.
style
.
lineHeight
=
style
.
lineHeight
;
const
boxSizing
=
style
.
boxSizing
;
if
(
boxSizing
=
=
=
"
border
-
box
"
)
{
to
.
style
.
boxSizing
=
boxSizing
;
copyBoxModelStyles
(
from
to
)
;
}
}
function
copyBoxModelStyles
(
from
to
)
{
const
properties
=
[
"
paddingTop
"
"
paddingRight
"
"
paddingBottom
"
"
paddingLeft
"
"
borderTopStyle
"
"
borderRightStyle
"
"
borderBottomStyle
"
"
borderLeftStyle
"
"
borderTopWidth
"
"
borderRightWidth
"
"
borderBottomWidth
"
"
borderLeftWidth
"
]
;
const
win
=
from
.
ownerDocument
.
defaultView
;
const
style
=
win
.
getComputedStyle
(
from
)
;
for
(
const
property
of
properties
)
{
to
.
style
[
property
]
=
style
[
property
]
;
}
}
function
moveFocus
(
win
direction
focusEditableField
focusEditableFieldContainerSelector
)
{
if
(
!
focusEditableField
)
{
return
focusManager
.
moveFocus
(
win
null
direction
0
)
;
}
if
(
!
win
.
document
.
querySelector
(
focusEditableFieldContainerSelector
)
)
{
console
.
error
(
focusEditableFieldContainerSelector
"
can
'
t
be
found
in
document
.
"
focusEditableFieldContainerSelector
should
match
an
existing
element
)
;
return
focusManager
.
moveFocus
(
win
null
direction
0
)
;
}
while
(
true
)
{
const
focusedElement
=
focusManager
.
moveFocus
(
win
null
direction
0
)
;
if
(
focusedElement
.
_editable
)
{
return
focusedElement
;
}
if
(
!
focusedElement
.
closest
(
focusEditableFieldContainerSelector
)
)
{
return
focusedElement
;
}
}
}
