"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
focusManager
=
Services
.
focus
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
CONTENT_TYPES
=
{
PLAIN_TEXT
:
0
CSS_VALUE
:
1
CSS_MIXED
:
2
CSS_PROPERTY
:
3
}
;
const
MAX_POPUP_ENTRIES
=
500
;
const
FOCUS_FORWARD
=
focusManager
.
MOVEFOCUS_FORWARD
;
const
FOCUS_BACKWARD
=
focusManager
.
MOVEFOCUS_BACKWARD
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
findMostRelevantCssPropertyIndex
}
=
require
(
"
.
/
suggestion
-
picker
"
)
;
function
isKeyIn
(
key
.
.
.
keys
)
{
return
keys
.
some
(
expectedKey
=
>
{
return
key
=
=
=
KeyCodes
[
"
DOM_VK_
"
+
expectedKey
]
;
}
)
;
}
function
editableField
(
options
)
{
return
editableItem
(
options
function
(
element
event
)
{
if
(
!
options
.
element
.
inplaceEditor
)
{
new
InplaceEditor
(
options
event
)
;
}
}
)
;
}
exports
.
editableField
=
editableField
;
function
editableItem
(
options
callback
)
{
let
trigger
=
options
.
trigger
|
|
"
click
"
;
let
element
=
options
.
element
;
element
.
addEventListener
(
trigger
function
(
evt
)
{
if
(
evt
.
target
.
nodeName
!
=
=
"
a
"
)
{
let
win
=
this
.
ownerDocument
.
defaultView
;
let
selection
=
win
.
getSelection
(
)
;
if
(
trigger
!
=
"
click
"
|
|
selection
.
isCollapsed
)
{
callback
(
element
evt
)
;
}
evt
.
stopPropagation
(
)
;
}
}
false
)
;
element
.
addEventListener
(
"
keypress
"
function
(
evt
)
{
if
(
isKeyIn
(
evt
.
keyCode
"
RETURN
"
)
|
|
isKeyIn
(
evt
.
charCode
"
SPACE
"
)
)
{
callback
(
element
)
;
}
}
true
)
;
element
.
addEventListener
(
"
mousedown
"
function
(
evt
)
{
if
(
evt
.
target
.
nodeName
!
=
=
"
a
"
)
{
let
cleanup
=
function
(
)
{
element
.
style
.
removeProperty
(
"
outline
-
style
"
)
;
element
.
removeEventListener
(
"
mouseup
"
cleanup
false
)
;
element
.
removeEventListener
(
"
mouseout
"
cleanup
false
)
;
}
;
element
.
style
.
setProperty
(
"
outline
-
style
"
"
none
"
)
;
element
.
addEventListener
(
"
mouseup
"
cleanup
false
)
;
element
.
addEventListener
(
"
mouseout
"
cleanup
false
)
;
}
}
false
)
;
element
.
_editable
=
true
;
element
.
_trigger
=
trigger
;
element
.
setAttribute
(
"
role
"
"
button
"
)
;
return
function
turnOnEditMode
(
)
{
callback
(
element
)
;
}
;
}
exports
.
editableItem
=
editableItem
;
function
getInplaceEditorForSpan
(
span
)
{
return
span
.
inplaceEditor
;
}
exports
.
getInplaceEditorForSpan
=
getInplaceEditorForSpan
;
function
InplaceEditor
(
options
event
)
{
this
.
elt
=
options
.
element
;
let
doc
=
this
.
elt
.
ownerDocument
;
this
.
doc
=
doc
;
this
.
elt
.
inplaceEditor
=
this
;
this
.
cssProperties
=
options
.
cssProperties
;
this
.
change
=
options
.
change
;
this
.
done
=
options
.
done
;
this
.
contextMenu
=
options
.
contextMenu
;
this
.
destroy
=
options
.
destroy
;
this
.
initial
=
options
.
initial
?
options
.
initial
:
this
.
elt
.
textContent
;
this
.
multiline
=
options
.
multiline
|
|
false
;
this
.
maxWidth
=
options
.
maxWidth
;
if
(
typeof
this
.
maxWidth
=
=
"
function
"
)
{
this
.
maxWidth
=
this
.
maxWidth
(
)
;
}
this
.
trimOutput
=
options
.
trimOutput
=
=
=
undefined
?
true
:
!
!
options
.
trimOutput
;
this
.
stopOnShiftTab
=
!
!
options
.
stopOnShiftTab
;
this
.
stopOnTab
=
!
!
options
.
stopOnTab
;
this
.
stopOnReturn
=
!
!
options
.
stopOnReturn
;
this
.
contentType
=
options
.
contentType
|
|
CONTENT_TYPES
.
PLAIN_TEXT
;
this
.
property
=
options
.
property
;
this
.
popup
=
options
.
popup
;
this
.
preserveTextStyles
=
options
.
preserveTextStyles
=
=
=
undefined
?
false
:
!
!
options
.
preserveTextStyles
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
this
.
_onWindowBlur
=
this
.
_onWindowBlur
.
bind
(
this
)
;
this
.
_onKeyPress
=
this
.
_onKeyPress
.
bind
(
this
)
;
this
.
_onInput
=
this
.
_onInput
.
bind
(
this
)
;
this
.
_onKeyup
=
this
.
_onKeyup
.
bind
(
this
)
;
this
.
_onAutocompletePopupClick
=
this
.
_onAutocompletePopupClick
.
bind
(
this
)
;
this
.
_onContextMenu
=
this
.
_onContextMenu
.
bind
(
this
)
;
this
.
_createInput
(
)
;
this
.
originalDisplay
=
this
.
elt
.
style
.
display
;
this
.
elt
.
style
.
display
=
"
none
"
;
this
.
elt
.
parentNode
.
insertBefore
(
this
.
input
this
.
elt
)
;
this
.
_autosize
(
)
;
this
.
inputCharDimensions
=
this
.
_getInputCharDimensions
(
)
;
if
(
typeof
options
.
advanceChars
=
=
=
"
function
"
)
{
this
.
_advanceChars
=
options
.
advanceChars
;
}
else
{
let
advanceCharcodes
=
{
}
;
let
advanceChars
=
options
.
advanceChars
|
|
"
"
;
for
(
let
i
=
0
;
i
<
advanceChars
.
length
;
i
+
+
)
{
advanceCharcodes
[
advanceChars
.
charCodeAt
(
i
)
]
=
true
;
}
this
.
_advanceChars
=
charCode
=
>
charCode
in
advanceCharcodes
;
}
this
.
input
.
focus
(
)
;
if
(
typeof
options
.
selectAll
=
=
"
undefined
"
|
|
options
.
selectAll
)
{
this
.
input
.
select
(
)
;
}
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_VALUE
&
&
this
.
input
.
value
=
=
"
"
)
{
this
.
_maybeSuggestCompletion
(
false
)
;
}
this
.
input
.
addEventListener
(
"
blur
"
this
.
_onBlur
false
)
;
this
.
input
.
addEventListener
(
"
keypress
"
this
.
_onKeyPress
false
)
;
this
.
input
.
addEventListener
(
"
input
"
this
.
_onInput
false
)
;
this
.
input
.
addEventListener
(
"
dblclick
"
this
.
_stopEventPropagation
false
)
;
this
.
input
.
addEventListener
(
"
click
"
this
.
_stopEventPropagation
false
)
;
this
.
input
.
addEventListener
(
"
mousedown
"
this
.
_stopEventPropagation
false
)
;
this
.
input
.
addEventListener
(
"
contextmenu
"
this
.
_onContextMenu
false
)
;
this
.
doc
.
defaultView
.
addEventListener
(
"
blur
"
this
.
_onWindowBlur
false
)
;
this
.
validate
=
options
.
validate
;
if
(
this
.
validate
)
{
this
.
input
.
addEventListener
(
"
keyup
"
this
.
_onKeyup
false
)
;
}
this
.
_updateSize
(
)
;
EventEmitter
.
decorate
(
this
)
;
if
(
options
.
start
)
{
options
.
start
(
this
event
)
;
}
}
exports
.
InplaceEditor
=
InplaceEditor
;
InplaceEditor
.
CONTENT_TYPES
=
CONTENT_TYPES
;
InplaceEditor
.
prototype
=
{
get
currentInputValue
(
)
{
let
val
=
this
.
trimOutput
?
this
.
input
.
value
.
trim
(
)
:
this
.
input
.
value
;
return
val
;
}
_createInput
:
function
(
)
{
this
.
input
=
this
.
doc
.
createElementNS
(
HTML_NS
this
.
multiline
?
"
textarea
"
:
"
input
"
)
;
this
.
input
.
inplaceEditor
=
this
;
if
(
this
.
multiline
)
{
this
.
input
.
style
.
resize
=
"
none
"
;
this
.
input
.
style
.
overflow
=
"
hidden
"
;
}
this
.
input
.
classList
.
add
(
"
styleinspector
-
propertyeditor
"
)
;
this
.
input
.
value
=
this
.
initial
;
if
(
!
this
.
preserveTextStyles
)
{
copyTextStyles
(
this
.
elt
this
.
input
)
;
}
}
_clear
:
function
(
)
{
if
(
!
this
.
input
)
{
return
;
}
this
.
input
.
removeEventListener
(
"
blur
"
this
.
_onBlur
false
)
;
this
.
input
.
removeEventListener
(
"
keypress
"
this
.
_onKeyPress
false
)
;
this
.
input
.
removeEventListener
(
"
keyup
"
this
.
_onKeyup
false
)
;
this
.
input
.
removeEventListener
(
"
input
"
this
.
_onInput
false
)
;
this
.
input
.
removeEventListener
(
"
dblclick
"
this
.
_stopEventPropagation
false
)
;
this
.
input
.
removeEventListener
(
"
click
"
this
.
_stopEventPropagation
false
)
;
this
.
input
.
removeEventListener
(
"
mousedown
"
this
.
_stopEventPropagation
false
)
;
this
.
input
.
removeEventListener
(
"
contextmenu
"
this
.
_onContextMenu
false
)
;
this
.
doc
.
defaultView
.
removeEventListener
(
"
blur
"
this
.
_onWindowBlur
false
)
;
this
.
_stopAutosize
(
)
;
this
.
elt
.
style
.
display
=
this
.
originalDisplay
;
if
(
this
.
doc
.
activeElement
=
=
this
.
input
)
{
this
.
elt
.
focus
(
)
;
}
this
.
input
.
remove
(
)
;
this
.
input
=
null
;
delete
this
.
elt
.
inplaceEditor
;
delete
this
.
elt
;
if
(
this
.
destroy
)
{
this
.
destroy
(
)
;
}
}
_autosize
:
function
(
)
{
this
.
_measurement
=
this
.
doc
.
createElementNS
(
HTML_NS
this
.
multiline
?
"
pre
"
:
"
span
"
)
;
this
.
_measurement
.
className
=
"
autosizer
"
;
this
.
elt
.
parentNode
.
appendChild
(
this
.
_measurement
)
;
let
style
=
this
.
_measurement
.
style
;
style
.
visibility
=
"
hidden
"
;
style
.
position
=
"
absolute
"
;
style
.
top
=
"
0
"
;
style
.
left
=
"
0
"
;
if
(
this
.
multiline
)
{
style
.
whiteSpace
=
"
pre
-
wrap
"
;
style
.
wordWrap
=
"
break
-
word
"
;
if
(
this
.
maxWidth
)
{
style
.
maxWidth
=
this
.
maxWidth
+
"
px
"
;
style
.
position
=
"
fixed
"
;
}
}
copyAllStyles
(
this
.
input
this
.
_measurement
)
;
this
.
_updateSize
(
)
;
}
_stopAutosize
:
function
(
)
{
if
(
!
this
.
_measurement
)
{
return
;
}
this
.
_measurement
.
remove
(
)
;
delete
this
.
_measurement
;
}
_updateSize
:
function
(
)
{
let
content
=
this
.
input
.
value
;
let
unbreakableSpace
=
"
\
u00a0
"
;
if
(
content
=
=
=
"
"
)
{
content
=
unbreakableSpace
;
}
if
(
content
.
lastIndexOf
(
"
\
n
"
)
=
=
=
content
.
length
-
1
)
{
content
=
content
+
unbreakableSpace
;
}
if
(
!
this
.
multiline
)
{
content
=
content
.
replace
(
/
/
g
unbreakableSpace
)
;
}
this
.
_measurement
.
textContent
=
content
;
let
width
=
this
.
_measurement
.
getBoundingClientRect
(
)
.
width
+
2
;
if
(
this
.
multiline
)
{
if
(
this
.
maxWidth
)
{
width
=
Math
.
min
(
this
.
maxWidth
width
)
;
}
let
height
=
this
.
_measurement
.
getBoundingClientRect
(
)
.
height
;
this
.
input
.
style
.
height
=
height
+
"
px
"
;
}
this
.
input
.
style
.
width
=
width
+
"
px
"
;
}
_getInputCharDimensions
:
function
(
)
{
this
.
_measurement
.
textContent
=
"
x
"
;
let
width
=
this
.
_measurement
.
clientWidth
;
let
height
=
this
.
_measurement
.
clientHeight
;
return
{
width
height
}
;
}
_incrementValue
:
function
(
increment
)
{
let
value
=
this
.
input
.
value
;
let
selectionStart
=
this
.
input
.
selectionStart
;
let
selectionEnd
=
this
.
input
.
selectionEnd
;
let
newValue
=
this
.
_incrementCSSValue
(
value
increment
selectionStart
selectionEnd
)
;
if
(
!
newValue
)
{
return
false
;
}
this
.
input
.
value
=
newValue
.
value
;
this
.
input
.
setSelectionRange
(
newValue
.
start
newValue
.
end
)
;
this
.
_doValidation
(
)
;
if
(
this
.
change
)
{
this
.
change
(
this
.
currentInputValue
)
;
}
return
true
;
}
_incrementCSSValue
:
function
(
value
increment
selStart
selEnd
)
{
let
range
=
this
.
_parseCSSValue
(
value
selStart
)
;
let
type
=
(
range
&
&
range
.
type
)
|
|
"
"
;
let
rawValue
=
range
?
value
.
substring
(
range
.
start
range
.
end
)
:
"
"
;
let
preRawValue
=
range
?
value
.
substr
(
0
range
.
start
)
:
"
"
;
let
postRawValue
=
range
?
value
.
substr
(
range
.
end
)
:
"
"
;
let
info
;
let
incrementedValue
=
null
selection
;
if
(
type
=
=
=
"
num
"
)
{
if
(
rawValue
=
=
"
0
"
)
{
info
=
{
}
;
info
.
units
=
this
.
_findCompatibleUnit
(
preRawValue
postRawValue
)
;
}
let
newValue
=
this
.
_incrementRawValue
(
rawValue
increment
info
)
;
if
(
newValue
!
=
=
null
)
{
incrementedValue
=
newValue
;
selection
=
[
0
incrementedValue
.
length
]
;
}
}
else
if
(
type
=
=
=
"
hex
"
)
{
let
exprOffset
=
selStart
-
range
.
start
;
let
exprOffsetEnd
=
selEnd
-
range
.
start
;
let
newValue
=
this
.
_incHexColor
(
rawValue
increment
exprOffset
exprOffsetEnd
)
;
if
(
newValue
)
{
incrementedValue
=
newValue
.
value
;
selection
=
newValue
.
selection
;
}
}
else
{
if
(
type
=
=
=
"
rgb
"
|
|
type
=
=
=
"
hsl
"
)
{
info
=
{
}
;
let
part
=
value
.
substring
(
range
.
start
selStart
)
.
split
(
"
"
)
.
length
-
1
;
if
(
part
=
=
=
3
)
{
info
.
minValue
=
0
;
info
.
maxValue
=
1
;
}
else
if
(
type
=
=
=
"
rgb
"
)
{
info
.
minValue
=
0
;
info
.
maxValue
=
255
;
}
else
if
(
part
!
=
=
0
)
{
info
.
minValue
=
0
;
info
.
maxValue
=
100
;
if
(
value
.
charAt
(
selStart
-
1
)
=
=
=
"
%
"
)
{
-
-
selStart
;
}
}
}
return
this
.
_incrementGenericValue
(
value
increment
selStart
selEnd
info
)
;
}
if
(
incrementedValue
=
=
=
null
)
{
return
null
;
}
return
{
value
:
preRawValue
+
incrementedValue
+
postRawValue
start
:
range
.
start
+
selection
[
0
]
end
:
range
.
start
+
selection
[
1
]
}
;
}
_findCompatibleUnit
:
function
(
beforeValue
afterValue
)
{
if
(
!
this
.
property
|
|
!
this
.
property
.
name
)
{
return
"
"
;
}
let
el
=
this
.
doc
.
createElement
(
"
div
"
)
;
let
units
=
[
"
px
"
"
deg
"
"
s
"
]
;
for
(
let
unit
of
units
)
{
let
value
=
beforeValue
+
"
1
"
+
unit
+
afterValue
;
el
.
style
.
setProperty
(
this
.
property
.
name
"
"
)
;
el
.
style
.
setProperty
(
this
.
property
.
name
value
)
;
if
(
el
.
style
.
getPropertyValue
(
this
.
property
.
name
)
!
=
=
"
"
)
{
return
unit
;
}
}
return
"
"
;
}
_parseCSSValue
:
function
(
value
offset
)
{
const
reSplitCSS
=
/
(
url
\
(
"
?
[
^
"
\
)
]
+
"
?
\
)
?
)
|
(
rgba
?
\
(
[
^
)
]
*
\
)
?
)
|
(
hsla
?
\
(
[
^
)
]
*
\
)
?
)
|
(
#
[
\
dA
-
Fa
-
f
]
+
)
|
(
-
?
\
d
*
\
.
?
\
d
+
(
%
|
[
a
-
z
]
{
1
4
}
)
?
)
|
"
(
[
^
"
]
*
)
"
?
|
'
(
[
^
'
]
*
)
'
?
|
(
[
^
\
s
\
/
!
\
(
\
)
]
+
)
|
(
!
(
.
*
)
?
)
/
;
let
start
=
0
;
let
m
;
while
(
(
m
=
reSplitCSS
.
exec
(
value
)
)
&
&
(
m
.
index
+
m
[
0
]
.
length
<
offset
)
)
{
value
=
value
.
substr
(
m
.
index
+
m
[
0
]
.
length
)
;
start
+
=
m
.
index
+
m
[
0
]
.
length
;
offset
-
=
m
.
index
+
m
[
0
]
.
length
;
}
if
(
!
m
)
{
return
null
;
}
let
type
;
if
(
m
[
1
]
)
{
type
=
"
url
"
;
}
else
if
(
m
[
2
]
)
{
type
=
"
rgb
"
;
}
else
if
(
m
[
3
]
)
{
type
=
"
hsl
"
;
}
else
if
(
m
[
4
]
)
{
type
=
"
hex
"
;
}
else
if
(
m
[
5
]
)
{
type
=
"
num
"
;
}
return
{
value
:
m
[
0
]
start
:
start
+
m
.
index
end
:
start
+
m
.
index
+
m
[
0
]
.
length
type
:
type
}
;
}
_incrementGenericValue
:
function
(
value
increment
offset
offsetEnd
info
)
{
let
start
end
;
if
(
/
^
-
?
[
0
-
9
.
]
/
.
test
(
value
.
substring
(
offset
offsetEnd
)
)
&
&
!
(
/
\
d
/
.
test
(
value
.
charAt
(
offset
-
1
)
+
value
.
charAt
(
offsetEnd
)
)
)
)
{
start
=
offset
;
end
=
offsetEnd
;
}
else
{
let
pattern
=
"
[
"
+
(
info
?
"
0
-
9
.
"
:
"
0
-
9
"
)
+
"
]
*
"
;
let
before
=
new
RegExp
(
pattern
+
"
"
)
.
exec
(
value
.
substr
(
0
offset
)
)
[
0
]
.
length
;
let
after
=
new
RegExp
(
"
^
"
+
pattern
)
.
exec
(
value
.
substr
(
offset
)
)
[
0
]
.
length
;
start
=
offset
-
before
;
end
=
offset
+
after
;
if
(
value
.
charAt
(
start
-
1
)
=
=
=
"
-
"
&
&
(
start
-
1
=
=
=
0
|
|
/
[
(
:
=
'
"
]
/
.
test
(
value
.
charAt
(
start
-
2
)
)
)
)
{
-
-
start
;
}
}
if
(
start
!
=
=
end
)
{
if
(
value
.
charAt
(
end
)
=
=
=
"
%
"
)
{
+
+
end
;
}
let
first
=
value
.
substr
(
0
start
)
;
let
mid
=
value
.
substring
(
start
end
)
;
let
last
=
value
.
substr
(
end
)
;
mid
=
this
.
_incrementRawValue
(
mid
increment
info
)
;
if
(
mid
!
=
=
null
)
{
return
{
value
:
first
+
mid
+
last
start
:
start
end
:
start
+
mid
.
length
}
;
}
}
return
null
;
}
_incrementRawValue
:
function
(
rawValue
increment
info
)
{
let
num
=
parseFloat
(
rawValue
)
;
if
(
isNaN
(
num
)
)
{
return
null
;
}
let
number
=
/
\
d
+
(
\
.
\
d
+
)
?
/
.
exec
(
rawValue
)
;
let
units
=
rawValue
.
substr
(
number
.
index
+
number
[
0
]
.
length
)
;
if
(
info
&
&
"
units
"
in
info
)
{
units
=
info
.
units
;
}
let
newValue
=
Math
.
round
(
(
num
+
increment
)
*
1000
)
/
1000
;
if
(
info
&
&
"
minValue
"
in
info
)
{
newValue
=
Math
.
max
(
newValue
info
.
minValue
)
;
}
if
(
info
&
&
"
maxValue
"
in
info
)
{
newValue
=
Math
.
min
(
newValue
info
.
maxValue
)
;
}
newValue
=
newValue
.
toString
(
)
;
return
newValue
+
units
;
}
_incHexColor
:
function
(
rawValue
increment
offset
offsetEnd
)
{
if
(
offsetEnd
>
rawValue
.
length
&
&
offset
>
=
rawValue
.
length
)
{
return
null
;
}
if
(
offset
<
1
&
&
offsetEnd
<
=
1
)
{
return
null
;
}
rawValue
=
rawValue
.
substr
(
1
)
;
-
-
offset
;
-
-
offsetEnd
;
offset
=
Math
.
max
(
offset
0
)
;
offsetEnd
=
Math
.
min
(
offsetEnd
rawValue
.
length
)
;
offsetEnd
=
Math
.
max
(
offsetEnd
offset
)
;
if
(
rawValue
.
length
=
=
=
3
)
{
rawValue
=
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
2
)
+
rawValue
.
charAt
(
2
)
;
offset
*
=
2
;
offsetEnd
*
=
2
;
}
if
(
rawValue
.
length
=
=
=
4
)
{
rawValue
=
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
0
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
1
)
+
rawValue
.
charAt
(
2
)
+
rawValue
.
charAt
(
2
)
+
rawValue
.
charAt
(
3
)
+
rawValue
.
charAt
(
3
)
;
offset
*
=
2
;
offsetEnd
*
=
2
;
}
if
(
rawValue
.
length
!
=
=
6
&
&
rawValue
.
length
!
=
=
8
)
{
return
null
;
}
if
(
offset
=
=
=
offsetEnd
)
{
if
(
offset
=
=
=
0
)
{
offsetEnd
=
1
;
}
else
{
offset
=
offsetEnd
-
1
;
}
}
offset
-
=
offset
%
2
;
offsetEnd
+
=
offsetEnd
%
2
;
if
(
increment
>
-
1
&
&
increment
<
1
)
{
increment
=
(
increment
<
0
?
-
1
:
1
)
;
}
if
(
Math
.
abs
(
increment
)
=
=
=
10
)
{
increment
=
(
increment
<
0
?
-
16
:
16
)
;
}
let
isUpper
=
(
rawValue
.
toUpperCase
(
)
=
=
=
rawValue
)
;
for
(
let
pos
=
offset
;
pos
<
offsetEnd
;
pos
+
=
2
)
{
let
mid
=
rawValue
.
substr
(
pos
2
)
;
let
value
=
parseInt
(
mid
16
)
;
if
(
isNaN
(
value
)
)
{
return
null
;
}
mid
=
Math
.
min
(
Math
.
max
(
value
+
increment
0
)
255
)
.
toString
(
16
)
;
while
(
mid
.
length
<
2
)
{
mid
=
"
0
"
+
mid
;
}
if
(
isUpper
)
{
mid
=
mid
.
toUpperCase
(
)
;
}
rawValue
=
rawValue
.
substr
(
0
pos
)
+
mid
+
rawValue
.
substr
(
pos
+
2
)
;
}
return
{
value
:
"
#
"
+
rawValue
selection
:
[
offset
+
1
offsetEnd
+
1
]
}
;
}
_cycleCSSSuggestion
:
function
(
reverse
noSelect
)
{
let
{
label
preLabel
}
=
this
.
popup
.
selectedItem
|
|
{
label
:
"
"
preLabel
:
"
"
}
;
if
(
reverse
)
{
this
.
popup
.
selectPreviousItem
(
)
;
}
else
{
this
.
popup
.
selectNextItem
(
)
;
}
this
.
_selectedIndex
=
this
.
popup
.
selectedIndex
;
let
input
=
this
.
input
;
let
pre
=
"
"
;
if
(
input
.
selectionStart
<
input
.
selectionEnd
)
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
)
;
}
else
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
-
label
.
length
+
preLabel
.
length
)
;
}
let
post
=
input
.
value
.
slice
(
input
.
selectionEnd
input
.
value
.
length
)
;
let
item
=
this
.
popup
.
selectedItem
;
let
toComplete
=
item
.
label
.
slice
(
item
.
preLabel
.
length
)
;
input
.
value
=
pre
+
toComplete
+
post
;
if
(
!
noSelect
)
{
input
.
setSelectionRange
(
pre
.
length
pre
.
length
+
toComplete
.
length
)
;
}
else
{
input
.
setSelectionRange
(
pre
.
length
+
toComplete
.
length
pre
.
length
+
toComplete
.
length
)
;
}
this
.
_updateSize
(
)
;
this
.
emit
(
"
after
-
suggest
"
)
;
}
_apply
:
function
(
event
direction
)
{
if
(
this
.
_applied
)
{
return
null
;
}
this
.
_applied
=
true
;
if
(
this
.
done
)
{
let
val
=
this
.
cancelled
?
this
.
initial
:
this
.
currentInputValue
;
return
this
.
done
(
val
!
this
.
cancelled
direction
)
;
}
return
null
;
}
_onWindowBlur
:
function
(
)
{
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
this
.
popup
.
hidePopup
(
)
;
}
if
(
this
.
_openPopupTimeout
)
{
this
.
doc
.
defaultView
.
clearTimeout
(
this
.
_openPopupTimeout
)
;
}
}
_onBlur
:
function
(
event
)
{
if
(
event
&
&
this
.
popup
&
&
this
.
popup
.
isOpen
&
&
this
.
popup
.
selectedIndex
>
=
0
)
{
this
.
_acceptPopupSuggestion
(
)
;
}
else
{
this
.
_apply
(
)
;
this
.
_clear
(
)
;
}
}
_onAutocompletePopupClick
:
function
(
)
{
this
.
_acceptPopupSuggestion
(
)
;
}
_acceptPopupSuggestion
:
function
(
)
{
let
label
preLabel
;
if
(
this
.
_selectedIndex
=
=
=
undefined
)
{
(
{
label
preLabel
}
=
this
.
popup
.
getItemAtIndex
(
this
.
popup
.
selectedIndex
)
)
;
}
else
{
(
{
label
preLabel
}
=
this
.
popup
.
getItemAtIndex
(
this
.
_selectedIndex
)
)
;
}
let
input
=
this
.
input
;
let
pre
=
"
"
;
if
(
input
.
selectionStart
<
input
.
selectionEnd
|
|
this
.
contentType
!
=
=
CONTENT_TYPES
.
CSS_MIXED
)
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
)
;
}
else
{
pre
=
input
.
value
.
slice
(
0
input
.
selectionStart
-
label
.
length
+
preLabel
.
length
)
;
}
let
post
=
input
.
value
.
slice
(
input
.
selectionEnd
input
.
value
.
length
)
;
let
item
=
this
.
popup
.
selectedItem
;
this
.
_selectedIndex
=
this
.
popup
.
selectedIndex
;
let
toComplete
=
item
.
label
.
slice
(
item
.
preLabel
.
length
)
;
input
.
value
=
pre
+
toComplete
+
post
;
input
.
setSelectionRange
(
pre
.
length
+
toComplete
.
length
pre
.
length
+
toComplete
.
length
)
;
this
.
_updateSize
(
)
;
let
onPopupHidden
=
(
)
=
>
{
this
.
popup
.
off
(
"
popup
-
closed
"
onPopupHidden
)
;
this
.
doc
.
defaultView
.
setTimeout
(
(
)
=
>
{
input
.
focus
(
)
;
this
.
emit
(
"
after
-
suggest
"
)
;
}
0
)
;
}
;
this
.
popup
.
on
(
"
popup
-
closed
"
onPopupHidden
)
;
this
.
_hideAutocompletePopup
(
)
;
}
_onKeyPress
:
function
(
event
)
{
let
prevent
=
false
;
let
key
=
event
.
keyCode
;
let
input
=
this
.
input
;
let
multilineNavigation
=
!
this
.
_isSingleLine
(
)
&
&
isKeyIn
(
key
"
UP
"
"
DOWN
"
"
LEFT
"
"
RIGHT
"
)
;
let
isPlainText
=
this
.
contentType
=
=
CONTENT_TYPES
.
PLAIN_TEXT
;
let
isPopupOpen
=
this
.
popup
&
&
this
.
popup
.
isOpen
;
let
increment
=
0
;
if
(
!
isPlainText
&
&
!
multilineNavigation
)
{
increment
=
this
.
_getIncrement
(
event
)
;
}
if
(
isKeyIn
(
key
"
PAGE_UP
"
"
PAGE_DOWN
"
)
)
{
this
.
_preventSuggestions
=
true
;
}
let
cycling
=
false
;
if
(
increment
&
&
this
.
_incrementValue
(
increment
)
)
{
this
.
_updateSize
(
)
;
prevent
=
true
;
cycling
=
true
;
}
if
(
isPopupOpen
&
&
isKeyIn
(
key
"
UP
"
"
DOWN
"
"
PAGE_UP
"
"
PAGE_DOWN
"
)
)
{
prevent
=
true
;
cycling
=
true
;
this
.
_cycleCSSSuggestion
(
isKeyIn
(
key
"
UP
"
"
PAGE_UP
"
)
)
;
this
.
_doValidation
(
)
;
}
if
(
isKeyIn
(
key
"
BACK_SPACE
"
"
DELETE
"
"
LEFT
"
"
RIGHT
"
"
HOME
"
"
END
"
)
)
{
if
(
isPopupOpen
)
{
this
.
_hideAutocompletePopup
(
)
;
}
}
else
if
(
!
cycling
&
&
!
multilineNavigation
&
&
!
event
.
metaKey
&
&
!
event
.
altKey
&
&
!
event
.
ctrlKey
)
{
this
.
_maybeSuggestCompletion
(
true
)
;
}
if
(
this
.
multiline
&
&
event
.
shiftKey
&
&
isKeyIn
(
key
"
RETURN
"
)
)
{
prevent
=
false
;
}
else
if
(
this
.
_advanceChars
(
event
.
charCode
input
.
value
input
.
selectionStart
)
|
|
isKeyIn
(
key
"
RETURN
"
"
TAB
"
)
)
{
prevent
=
true
;
let
direction
;
if
(
(
this
.
stopOnReturn
&
&
isKeyIn
(
key
"
RETURN
"
)
)
|
|
(
this
.
stopOnTab
&
&
!
event
.
shiftKey
&
&
isKeyIn
(
key
"
TAB
"
)
)
|
|
(
this
.
stopOnShiftTab
&
&
event
.
shiftKey
&
&
isKeyIn
(
key
"
TAB
"
)
)
)
{
direction
=
null
;
}
else
if
(
event
.
shiftKey
&
&
isKeyIn
(
key
"
TAB
"
)
)
{
direction
=
FOCUS_BACKWARD
;
}
else
{
direction
=
FOCUS_FORWARD
;
}
this
.
_preventSuggestions
=
true
;
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_PROPERTY
&
&
direction
=
=
FOCUS_FORWARD
)
{
this
.
_preventSuggestions
=
false
;
}
if
(
isKeyIn
(
key
"
TAB
"
)
&
&
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_MIXED
)
{
if
(
this
.
popup
&
&
input
.
selectionStart
<
input
.
selectionEnd
)
{
event
.
preventDefault
(
)
;
input
.
setSelectionRange
(
input
.
selectionEnd
input
.
selectionEnd
)
;
this
.
emit
(
"
after
-
suggest
"
)
;
return
;
}
else
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
event
.
preventDefault
(
)
;
this
.
_cycleCSSSuggestion
(
event
.
shiftKey
true
)
;
return
;
}
}
this
.
_apply
(
event
direction
)
;
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
this
.
_hideAutocompletePopup
(
)
;
}
if
(
direction
!
=
=
null
&
&
focusManager
.
focusedElement
=
=
=
input
)
{
let
next
=
moveFocus
(
this
.
doc
.
defaultView
direction
)
;
if
(
next
&
&
next
.
ownerDocument
=
=
=
this
.
doc
&
&
next
.
_editable
)
{
let
e
=
this
.
doc
.
createEvent
(
"
Event
"
)
;
e
.
initEvent
(
next
.
_trigger
true
true
)
;
next
.
dispatchEvent
(
e
)
;
}
}
this
.
_clear
(
)
;
}
else
if
(
isKeyIn
(
key
"
ESCAPE
"
)
)
{
this
.
_preventSuggestions
=
true
;
if
(
this
.
popup
&
&
this
.
popup
.
isOpen
)
{
this
.
_hideAutocompletePopup
(
)
;
}
prevent
=
true
;
this
.
cancelled
=
true
;
this
.
_apply
(
)
;
this
.
_clear
(
)
;
event
.
stopPropagation
(
)
;
}
else
if
(
isKeyIn
(
key
"
SPACE
"
)
)
{
prevent
=
!
input
.
value
;
}
if
(
prevent
)
{
event
.
preventDefault
(
)
;
}
}
_onContextMenu
:
function
(
event
)
{
if
(
this
.
contextMenu
)
{
this
.
contextMenu
(
event
)
;
}
}
_openAutocompletePopup
:
function
(
offset
selectedIndex
)
{
this
.
popup
.
on
(
"
popup
-
click
"
this
.
_onAutocompletePopupClick
)
;
this
.
popup
.
openPopup
(
this
.
input
offset
0
selectedIndex
)
;
}
_hideAutocompletePopup
:
function
(
)
{
this
.
popup
.
off
(
"
popup
-
click
"
this
.
_onAutocompletePopupClick
)
;
this
.
popup
.
hidePopup
(
)
;
}
_getIncrement
:
function
(
event
)
{
const
largeIncrement
=
100
;
const
mediumIncrement
=
10
;
const
smallIncrement
=
0
.
1
;
let
increment
=
0
;
let
key
=
event
.
keyCode
;
if
(
isKeyIn
(
key
"
UP
"
"
PAGE_UP
"
)
)
{
increment
=
1
;
}
else
if
(
isKeyIn
(
key
"
DOWN
"
"
PAGE_DOWN
"
)
)
{
increment
=
-
1
;
}
if
(
event
.
shiftKey
&
&
!
event
.
altKey
)
{
if
(
isKeyIn
(
key
"
PAGE_UP
"
"
PAGE_DOWN
"
)
)
{
increment
*
=
largeIncrement
;
}
else
{
increment
*
=
mediumIncrement
;
}
}
else
if
(
event
.
altKey
&
&
!
event
.
shiftKey
)
{
increment
*
=
smallIncrement
;
}
return
increment
;
}
_onKeyup
:
function
(
)
{
this
.
_applied
=
false
;
}
_onInput
:
function
(
)
{
this
.
_doValidation
(
)
;
if
(
this
.
_measurement
)
{
this
.
_updateSize
(
)
;
}
if
(
this
.
change
)
{
this
.
change
(
this
.
currentInputValue
)
;
}
}
_stopEventPropagation
:
function
(
e
)
{
e
.
stopPropagation
(
)
;
}
_doValidation
:
function
(
)
{
if
(
this
.
validate
&
&
this
.
input
)
{
this
.
validate
(
this
.
input
.
value
)
;
}
}
_maybeSuggestCompletion
:
function
(
autoInsert
)
{
if
(
!
this
.
input
)
{
return
;
}
let
preTimeoutQuery
=
this
.
input
.
value
;
this
.
_openPopupTimeout
=
this
.
doc
.
defaultView
.
setTimeout
(
(
)
=
>
{
if
(
this
.
_preventSuggestions
)
{
this
.
_preventSuggestions
=
false
;
return
;
}
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
PLAIN_TEXT
)
{
return
;
}
if
(
!
this
.
input
)
{
return
;
}
let
input
=
this
.
input
;
if
(
input
.
value
.
length
-
preTimeoutQuery
.
length
>
1
)
{
return
;
}
let
query
=
input
.
value
.
slice
(
0
input
.
selectionStart
)
;
let
startCheckQuery
=
query
;
if
(
query
=
=
null
)
{
return
;
}
if
(
input
.
selectionStart
=
=
input
.
selectionEnd
&
&
input
.
selectionStart
<
input
.
value
.
length
)
{
let
nextChar
=
input
.
value
.
slice
(
input
.
selectionStart
)
[
0
]
;
if
(
/
[
\
w
-
]
/
.
test
(
nextChar
)
)
{
this
.
emit
(
"
after
-
suggest
"
"
nothing
to
autocomplete
"
)
;
return
;
}
}
let
list
=
[
]
;
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_PROPERTY
)
{
list
=
this
.
_getCSSPropertyList
(
)
;
}
else
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_VALUE
)
{
let
match
=
/
(
[
^
\
s
.
\
/
]
+
)
/
.
exec
(
query
)
;
if
(
match
)
{
startCheckQuery
=
match
[
0
]
;
}
else
{
startCheckQuery
=
"
"
;
}
list
=
[
"
!
important
"
.
.
.
this
.
_getCSSValuesForPropertyName
(
this
.
property
.
name
)
]
;
if
(
query
=
=
"
"
)
{
list
.
splice
(
0
1
)
;
}
}
else
if
(
this
.
contentType
=
=
CONTENT_TYPES
.
CSS_MIXED
&
&
/
^
\
s
*
style
\
s
*
=
/
.
test
(
query
)
)
{
let
styleValue
=
query
.
replace
(
/
^
\
s
*
style
\
s
*
=
\
s
*
/
"
"
)
;
if
(
/
^
(
"
[
^
"
]
*
"
|
'
[
^
'
]
*
'
)
/
.
test
(
styleValue
)
)
{
this
.
emit
(
"
after
-
suggest
"
"
nothing
to
autocomplete
"
)
;
return
;
}
let
match
=
query
.
match
(
/
(
[
:
;
"
'
=
]
?
)
\
s
*
(
[
^
"
'
;
:
=
]
+
)
?
/
)
;
if
(
match
&
&
match
.
length
>
=
2
)
{
if
(
match
[
1
]
=
=
"
:
"
)
{
let
propertyName
=
query
.
match
(
/
[
;
"
'
=
]
\
s
*
(
[
^
"
'
;
:
=
]
+
)
\
s
*
:
\
s
*
[
^
"
'
;
:
=
]
*
/
)
[
1
]
;
list
=
[
"
!
important
;
"
.
.
.
this
.
_getCSSValuesForPropertyName
(
propertyName
)
]
;
let
matchLastQuery
=
/
(
[
^
\
s
.
\
/
]
+
)
/
.
exec
(
match
[
2
]
|
|
"
"
)
;
if
(
matchLastQuery
)
{
startCheckQuery
=
matchLastQuery
[
0
]
;
}
else
{
startCheckQuery
=
"
"
;
}
if
(
!
match
[
2
]
)
{
list
.
splice
(
0
1
)
;
}
}
else
if
(
match
[
1
]
)
{
list
=
this
.
_getCSSPropertyList
(
)
;
startCheckQuery
=
match
[
2
]
;
}
if
(
startCheckQuery
=
=
null
)
{
this
.
emit
(
"
after
-
suggest
"
"
nothing
to
autocomplete
"
)
;
return
;
}
}
}
if
(
!
this
.
popup
)
{
this
.
emit
(
"
after
-
suggest
"
"
no
popup
"
)
;
return
;
}
let
finalList
=
[
]
;
let
length
=
list
.
length
;
for
(
let
i
=
0
count
=
0
;
i
<
length
&
&
count
<
MAX_POPUP_ENTRIES
;
i
+
+
)
{
if
(
startCheckQuery
!
=
null
&
&
list
[
i
]
.
startsWith
(
startCheckQuery
)
)
{
count
+
+
;
finalList
.
push
(
{
preLabel
:
startCheckQuery
label
:
list
[
i
]
}
)
;
}
else
if
(
count
>
0
)
{
break
;
}
else
if
(
startCheckQuery
!
=
null
&
&
list
[
i
]
[
0
]
>
startCheckQuery
[
0
]
)
{
break
;
}
}
finalList
.
sort
(
(
item1
item2
)
=
>
{
let
comparison
=
item1
.
label
.
localeCompare
(
item2
.
label
)
;
if
(
/
^
\
w
/
.
test
(
item1
.
label
)
!
=
/
^
\
w
/
.
test
(
item2
.
label
)
)
{
comparison
=
-
1
*
comparison
;
}
return
comparison
;
}
)
;
let
index
=
0
;
if
(
startCheckQuery
)
{
let
cssValues
=
finalList
.
map
(
item
=
>
item
.
label
)
;
index
=
findMostRelevantCssPropertyIndex
(
cssValues
)
;
}
if
(
autoInsert
&
&
finalList
[
index
]
)
{
let
item
=
finalList
[
index
]
.
label
;
input
.
value
=
query
+
item
.
slice
(
startCheckQuery
.
length
)
+
input
.
value
.
slice
(
query
.
length
)
;
input
.
setSelectionRange
(
query
.
length
query
.
length
+
item
.
length
-
startCheckQuery
.
length
)
;
this
.
_updateSize
(
)
;
}
if
(
finalList
.
length
>
1
)
{
let
indent
=
this
.
input
.
selectionStart
-
startCheckQuery
.
length
;
let
offset
=
indent
*
this
.
inputCharDimensions
.
width
;
offset
=
this
.
_isSingleLine
(
)
?
offset
:
0
;
let
selectedIndex
=
autoInsert
?
index
:
-
1
;
this
.
popup
.
setItems
(
finalList
)
;
this
.
_openAutocompletePopup
(
offset
selectedIndex
)
;
}
else
{
this
.
_hideAutocompletePopup
(
)
;
}
this
.
emit
(
"
after
-
suggest
"
)
;
this
.
_doValidation
(
)
;
}
0
)
;
}
_isSingleLine
:
function
(
)
{
let
inputRect
=
this
.
input
.
getBoundingClientRect
(
)
;
return
inputRect
.
height
<
2
*
this
.
inputCharDimensions
.
height
;
}
_getCSSPropertyList
:
function
(
)
{
return
this
.
cssProperties
.
getNames
(
)
.
sort
(
)
;
}
_getCSSValuesForPropertyName
:
function
(
propertyName
)
{
return
this
.
cssProperties
.
getValues
(
propertyName
)
;
}
}
;
function
copyTextStyles
(
from
to
)
{
let
win
=
from
.
ownerDocument
.
defaultView
;
let
style
=
win
.
getComputedStyle
(
from
)
;
let
getCssText
=
name
=
>
style
.
getPropertyCSSValue
(
name
)
.
cssText
;
to
.
style
.
fontFamily
=
getCssText
(
"
font
-
family
"
)
;
to
.
style
.
fontSize
=
getCssText
(
"
font
-
size
"
)
;
to
.
style
.
fontWeight
=
getCssText
(
"
font
-
weight
"
)
;
to
.
style
.
fontStyle
=
getCssText
(
"
font
-
style
"
)
;
}
function
copyAllStyles
(
from
to
)
{
let
win
=
from
.
ownerDocument
.
defaultView
;
let
style
=
win
.
getComputedStyle
(
from
)
;
let
getCssText
=
name
=
>
style
.
getPropertyCSSValue
(
name
)
.
cssText
;
copyTextStyles
(
from
to
)
;
to
.
style
.
lineHeight
=
getCssText
(
"
line
-
height
"
)
;
let
boxSizing
=
getCssText
(
"
box
-
sizing
"
)
;
if
(
boxSizing
=
=
=
"
border
-
box
"
)
{
to
.
style
.
boxSizing
=
boxSizing
;
copyBoxModelStyles
(
from
to
)
;
}
}
function
copyBoxModelStyles
(
from
to
)
{
let
win
=
from
.
ownerDocument
.
defaultView
;
let
style
=
win
.
getComputedStyle
(
from
)
;
let
getCssText
=
name
=
>
style
.
getPropertyCSSValue
(
name
)
.
cssText
;
to
.
style
.
paddingTop
=
getCssText
(
"
padding
-
top
"
)
;
to
.
style
.
paddingRight
=
getCssText
(
"
padding
-
right
"
)
;
to
.
style
.
paddingBottom
=
getCssText
(
"
padding
-
bottom
"
)
;
to
.
style
.
paddingLeft
=
getCssText
(
"
padding
-
left
"
)
;
to
.
style
.
borderTopStyle
=
getCssText
(
"
border
-
top
-
style
"
)
;
to
.
style
.
borderRightStyle
=
getCssText
(
"
border
-
right
-
style
"
)
;
to
.
style
.
borderBottomStyle
=
getCssText
(
"
border
-
bottom
-
style
"
)
;
to
.
style
.
borderLeftStyle
=
getCssText
(
"
border
-
left
-
style
"
)
;
to
.
style
.
borderTopWidth
=
getCssText
(
"
border
-
top
-
width
"
)
;
to
.
style
.
borderRightWidth
=
getCssText
(
"
border
-
right
-
width
"
)
;
to
.
style
.
borderBottomWidth
=
getCssText
(
"
border
-
bottom
-
width
"
)
;
to
.
style
.
borderLeftWidth
=
getCssText
(
"
border
-
left
-
width
"
)
;
}
function
moveFocus
(
win
direction
)
{
return
focusManager
.
moveFocus
(
win
null
direction
0
)
;
}
