"
use
strict
"
;
const
{
Ci
Cu
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
getRect
getAdjustedQuads
getWindowDimensions
}
=
require
(
"
devtools
/
shared
/
layout
/
utils
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
isContentStylesheet
getCSSStyleRules
}
=
require
(
"
devtools
/
shared
/
inspector
/
css
-
logic
"
)
;
const
InspectorUtils
=
require
(
"
InspectorUtils
"
)
;
const
EventUtils
=
{
}
;
EventUtils
.
window
=
{
}
;
EventUtils
.
parent
=
{
}
;
EventUtils
.
_EU_Ci
=
Ci
;
EventUtils
.
_EU_Cc
=
Cc
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
EventUtils
)
;
const
protocol
=
require
(
"
devtools
/
shared
/
protocol
"
)
;
const
{
Arg
RetVal
}
=
protocol
;
const
dumpn
=
msg
=
>
{
dump
(
msg
+
"
\
n
"
)
;
}
;
function
getHighlighterCanvasFrameHelper
(
conn
actorID
)
{
const
actor
=
conn
.
getActor
(
actorID
)
;
if
(
actor
&
&
actor
.
_highlighter
)
{
return
actor
.
_highlighter
.
markup
;
}
return
null
;
}
var
testSpec
=
protocol
.
generateActorSpec
(
{
typeName
:
"
testActor
"
methods
:
{
getNumberOfElementMatches
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
number
"
)
}
}
getHighlighterAttribute
:
{
request
:
{
nodeID
:
Arg
(
0
"
string
"
)
name
:
Arg
(
1
"
string
"
)
actorID
:
Arg
(
2
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
string
"
)
}
}
getHighlighterNodeTextContent
:
{
request
:
{
nodeID
:
Arg
(
0
"
string
"
)
actorID
:
Arg
(
1
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
string
"
)
}
}
getSelectorHighlighterBoxNb
:
{
request
:
{
highlighter
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
number
"
)
}
}
changeHighlightedNodeWaitForUpdate
:
{
request
:
{
name
:
Arg
(
0
"
string
"
)
value
:
Arg
(
1
"
string
"
)
actorID
:
Arg
(
2
"
string
"
)
}
response
:
{
}
}
waitForHighlighterEvent
:
{
request
:
{
event
:
Arg
(
0
"
string
"
)
actorID
:
Arg
(
1
"
string
"
)
}
response
:
{
}
}
waitForEventOnNode
:
{
request
:
{
eventName
:
Arg
(
0
"
string
"
)
selector
:
Arg
(
1
"
nullable
:
string
"
)
}
response
:
{
}
}
changeZoomLevel
:
{
request
:
{
level
:
Arg
(
0
"
string
"
)
actorID
:
Arg
(
1
"
string
"
)
}
response
:
{
}
}
getAllAdjustedQuads
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
synthesizeMouse
:
{
request
:
{
object
:
Arg
(
0
"
json
"
)
}
response
:
{
}
}
synthesizeKey
:
{
request
:
{
args
:
Arg
(
0
"
json
"
)
}
response
:
{
}
}
scrollIntoView
:
{
request
:
{
args
:
Arg
(
0
"
string
"
)
}
response
:
{
}
}
hasPseudoClassLock
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
pseudo
:
Arg
(
1
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
boolean
"
)
}
}
loadAndWaitForCustomEvent
:
{
request
:
{
url
:
Arg
(
0
"
string
"
)
}
response
:
{
}
}
hasNode
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
boolean
"
)
}
}
getBoundingClientRect
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
setProperty
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
property
:
Arg
(
1
"
string
"
)
value
:
Arg
(
2
"
string
"
)
}
response
:
{
}
}
getProperty
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
property
:
Arg
(
1
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
string
"
)
}
}
getAttribute
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
property
:
Arg
(
1
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
string
"
)
}
}
setAttribute
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
property
:
Arg
(
1
"
string
"
)
value
:
Arg
(
2
"
string
"
)
}
response
:
{
}
}
removeAttribute
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
property
:
Arg
(
1
"
string
"
)
}
response
:
{
}
}
reload
:
{
request
:
{
}
response
:
{
}
}
reloadFrame
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
}
}
eval
:
{
request
:
{
js
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
nullable
:
json
"
)
}
}
scrollWindow
:
{
request
:
{
x
:
Arg
(
0
"
number
"
)
y
:
Arg
(
1
"
number
"
)
relative
:
Arg
(
2
"
nullable
:
boolean
"
)
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
reflow
:
{
}
getNodeRect
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
getTextNodeRect
:
{
request
:
{
parentSelector
:
Arg
(
0
"
string
"
)
childNodeIndex
:
Arg
(
1
"
number
"
)
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
getNodeInfo
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
getStyleSheetsInfoForNode
:
{
request
:
{
selector
:
Arg
(
0
"
string
"
)
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
getWindowDimensions
:
{
request
:
{
}
response
:
{
value
:
RetVal
(
"
json
"
)
}
}
}
}
)
;
var
TestActor
=
exports
.
TestActor
=
protocol
.
ActorClassWithSpec
(
testSpec
{
initialize
:
function
(
conn
targetActor
options
)
{
this
.
conn
=
conn
;
this
.
targetActor
=
targetActor
;
}
get
content
(
)
{
return
this
.
targetActor
.
window
;
}
_querySelector
:
function
(
selector
)
{
let
document
=
this
.
content
.
document
;
if
(
Array
.
isArray
(
selector
)
)
{
const
fullSelector
=
selector
.
join
(
"
>
>
"
)
;
while
(
selector
.
length
>
1
)
{
const
str
=
selector
.
shift
(
)
;
const
iframe
=
document
.
querySelector
(
str
)
;
if
(
!
iframe
)
{
throw
new
Error
(
"
Unable
to
find
element
with
selector
\
"
"
+
str
+
"
\
"
"
+
"
(
full
selector
:
"
+
fullSelector
+
"
)
"
)
;
}
if
(
!
iframe
.
contentWindow
)
{
throw
new
Error
(
"
Iframe
selector
doesn
'
t
target
an
iframe
\
"
"
+
str
+
"
\
"
"
+
"
(
full
selector
:
"
+
fullSelector
+
"
)
"
)
;
}
document
=
iframe
.
contentWindow
.
document
;
}
selector
=
selector
.
shift
(
)
;
}
const
node
=
document
.
querySelector
(
selector
)
;
if
(
!
node
)
{
throw
new
Error
(
"
Unable
to
find
element
with
selector
\
"
"
+
selector
+
"
\
"
"
)
;
}
return
node
;
}
getNumberOfElementMatches
:
function
(
selector
root
=
this
.
content
.
document
)
{
return
root
.
querySelectorAll
(
selector
)
.
length
;
}
getHighlighterAttribute
:
function
(
nodeID
name
actorID
)
{
const
helper
=
getHighlighterCanvasFrameHelper
(
this
.
conn
actorID
)
;
if
(
helper
)
{
return
helper
.
getAttributeForElement
(
nodeID
name
)
;
}
return
null
;
}
getHighlighterNodeTextContent
:
function
(
nodeID
actorID
)
{
let
value
;
const
helper
=
getHighlighterCanvasFrameHelper
(
this
.
conn
actorID
)
;
if
(
helper
)
{
value
=
helper
.
getTextContentForElement
(
nodeID
)
;
}
return
value
;
}
getSelectorHighlighterBoxNb
:
function
(
actorID
)
{
const
highlighter
=
this
.
conn
.
getActor
(
actorID
)
;
const
{
_highlighter
:
h
}
=
highlighter
;
if
(
!
h
|
|
!
h
.
_highlighters
)
{
return
null
;
}
return
h
.
_highlighters
.
length
;
}
changeHighlightedNodeWaitForUpdate
:
function
(
name
value
actorID
)
{
return
new
Promise
(
resolve
=
>
{
const
highlighter
=
this
.
conn
.
getActor
(
actorID
)
;
const
{
_highlighter
:
h
}
=
highlighter
;
h
.
once
(
"
updated
"
resolve
)
;
h
.
currentNode
.
setAttribute
(
name
value
)
;
}
)
;
}
waitForHighlighterEvent
:
function
(
event
actorID
)
{
const
highlighter
=
this
.
conn
.
getActor
(
actorID
)
;
const
{
_highlighter
:
h
}
=
highlighter
;
return
h
.
once
(
event
)
;
}
waitForEventOnNode
:
function
(
eventName
selector
)
{
return
new
Promise
(
resolve
=
>
{
const
node
=
selector
?
this
.
_querySelector
(
selector
)
:
this
.
content
;
node
.
addEventListener
(
eventName
function
(
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
}
)
;
}
changeZoomLevel
:
function
(
level
actorID
)
{
dumpn
(
"
Zooming
page
to
"
+
level
)
;
return
new
Promise
(
resolve
=
>
{
if
(
actorID
)
{
const
actor
=
this
.
conn
.
getActor
(
actorID
)
;
const
{
_highlighter
:
h
}
=
actor
;
h
.
once
(
"
updated
"
resolve
)
;
}
else
{
resolve
(
)
;
}
const
docShell
=
this
.
content
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocShell
)
;
docShell
.
contentViewer
.
fullZoom
=
level
;
}
)
;
}
getAllAdjustedQuads
:
function
(
selector
)
{
const
regions
=
{
}
;
const
node
=
this
.
_querySelector
(
selector
)
;
for
(
const
boxType
of
[
"
content
"
"
padding
"
"
border
"
"
margin
"
]
)
{
regions
[
boxType
]
=
getAdjustedQuads
(
this
.
content
node
boxType
)
;
}
return
regions
;
}
synthesizeMouse
:
function
(
{
selector
x
y
center
options
}
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
node
.
scrollIntoView
(
)
;
if
(
center
)
{
EventUtils
.
synthesizeMouseAtCenter
(
node
options
node
.
ownerDocument
.
defaultView
)
;
}
else
{
EventUtils
.
synthesizeMouse
(
node
x
y
options
node
.
ownerDocument
.
defaultView
)
;
}
}
synthesizeKey
:
function
(
{
key
options
content
}
)
{
EventUtils
.
synthesizeKey
(
key
options
this
.
content
)
;
}
scrollIntoView
:
function
(
selector
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
node
.
scrollIntoView
(
)
;
}
hasPseudoClassLock
:
function
(
selector
pseudo
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
return
InspectorUtils
.
hasPseudoClassLock
(
node
pseudo
)
;
}
loadAndWaitForCustomEvent
:
function
(
url
)
{
return
new
Promise
(
resolve
=
>
{
this
.
targetActor
.
chromeEventHandler
.
addEventListener
(
"
DOMWindowCreated
"
(
)
=
>
{
this
.
content
.
addEventListener
(
"
test
-
page
-
processing
-
done
"
resolve
{
once
:
true
}
)
;
}
{
once
:
true
}
)
;
this
.
content
.
location
=
url
;
}
)
;
}
hasNode
:
function
(
selector
)
{
try
{
this
.
_querySelector
(
selector
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
getBoundingClientRect
:
function
(
selector
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
const
rect
=
node
.
getBoundingClientRect
(
)
;
return
{
x
:
rect
.
x
y
:
rect
.
y
width
:
rect
.
width
height
:
rect
.
height
top
:
rect
.
top
right
:
rect
.
right
bottom
:
rect
.
bottom
left
:
rect
.
left
}
;
}
setProperty
:
function
(
selector
property
value
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
node
[
property
]
=
value
;
}
getProperty
:
function
(
selector
property
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
return
node
[
property
]
;
}
getAttribute
:
function
(
selector
attribute
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
return
node
.
getAttribute
(
attribute
)
;
}
setAttribute
:
function
(
selector
attribute
value
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
node
.
setAttribute
(
attribute
value
)
;
}
removeAttribute
:
function
(
selector
attribute
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
node
.
removeAttribute
(
attribute
)
;
}
reload
:
function
(
)
{
this
.
content
.
location
.
reload
(
)
;
}
reloadFrame
:
function
(
selector
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
const
deferred
=
defer
(
)
;
const
onLoad
=
function
(
)
{
node
.
removeEventListener
(
"
load
"
onLoad
)
;
deferred
.
resolve
(
)
;
}
;
node
.
addEventListener
(
"
load
"
onLoad
)
;
node
.
contentWindow
.
location
.
reload
(
)
;
return
deferred
.
promise
;
}
eval
:
function
(
js
)
{
const
sb
=
Cu
.
Sandbox
(
this
.
content
{
sandboxPrototype
:
this
.
content
}
)
;
const
result
=
Cu
.
evalInSandbox
(
js
sb
)
;
if
(
typeof
result
=
=
"
function
"
)
{
return
null
;
}
else
if
(
typeof
result
=
=
"
object
"
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
result
)
)
;
}
return
result
;
}
scrollWindow
:
function
(
x
y
relative
)
{
if
(
isNaN
(
x
)
|
|
isNaN
(
y
)
)
{
return
{
}
;
}
const
deferred
=
defer
(
)
;
this
.
content
.
addEventListener
(
"
scroll
"
function
(
event
)
{
const
data
=
{
x
:
this
.
content
.
scrollX
y
:
this
.
content
.
scrollY
}
;
deferred
.
resolve
(
data
)
;
}
{
once
:
true
}
)
;
this
.
content
[
relative
?
"
scrollBy
"
:
"
scrollTo
"
]
(
x
y
)
;
return
deferred
.
promise
;
}
reflow
:
function
(
)
{
const
deferred
=
defer
(
)
;
this
.
content
.
document
.
documentElement
.
offsetWidth
;
this
.
content
.
requestAnimationFrame
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
async
getNodeRect
(
selector
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
return
getRect
(
this
.
content
node
this
.
content
)
;
}
async
getTextNodeRect
(
parentSelector
childNodeIndex
)
{
const
parentNode
=
this
.
_querySelector
(
parentSelector
)
;
const
node
=
parentNode
.
childNodes
[
childNodeIndex
]
;
return
getAdjustedQuads
(
this
.
content
node
)
[
0
]
.
bounds
;
}
getNodeInfo
:
function
(
selector
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
let
info
=
null
;
if
(
node
)
{
info
=
{
tagName
:
node
.
tagName
namespaceURI
:
node
.
namespaceURI
numChildren
:
node
.
children
.
length
numNodes
:
node
.
childNodes
.
length
attributes
:
[
.
.
.
node
.
attributes
]
.
map
(
(
{
name
value
namespaceURI
}
)
=
>
{
return
{
name
value
namespaceURI
}
;
}
)
outerHTML
:
node
.
outerHTML
innerHTML
:
node
.
innerHTML
textContent
:
node
.
textContent
}
;
}
return
info
;
}
getStyleSheetsInfoForNode
:
function
(
selector
)
{
const
node
=
this
.
_querySelector
(
selector
)
;
const
domRules
=
getCSSStyleRules
(
node
)
;
const
sheets
=
[
]
;
for
(
let
i
=
0
n
=
domRules
.
length
;
i
<
n
;
i
+
+
)
{
const
sheet
=
domRules
[
i
]
.
parentStyleSheet
;
sheets
.
push
(
{
href
:
sheet
.
href
isContentSheet
:
isContentStylesheet
(
sheet
)
}
)
;
}
return
sheets
;
}
getWindowDimensions
:
function
(
)
{
return
getWindowDimensions
(
this
.
content
)
;
}
}
)
;
var
TestActorFront
=
exports
.
TestActorFront
=
protocol
.
FrontClassWithSpec
(
testSpec
{
initialize
:
function
(
client
{
testActor
}
toolbox
)
{
protocol
.
Front
.
prototype
.
initialize
.
call
(
this
client
{
actor
:
testActor
}
)
;
this
.
manage
(
this
)
;
this
.
toolbox
=
toolbox
;
}
zoomPageTo
:
function
(
level
actorID
=
this
.
toolbox
.
highlighter
.
actorID
)
{
return
this
.
changeZoomLevel
(
level
actorID
)
;
}
changeHighlightedNodeWaitForUpdate
:
protocol
.
custom
(
function
(
name
value
highlighter
)
{
return
this
.
_changeHighlightedNodeWaitForUpdate
(
name
value
(
highlighter
|
|
this
.
toolbox
.
highlighter
)
.
actorID
)
;
}
{
impl
:
"
_changeHighlightedNodeWaitForUpdate
"
}
)
getHighlighterNodeAttribute
:
function
(
nodeID
name
highlighter
)
{
return
this
.
getHighlighterAttribute
(
nodeID
name
(
highlighter
|
|
this
.
toolbox
.
highlighter
)
.
actorID
)
;
}
getHighlighterNodeTextContent
:
protocol
.
custom
(
function
(
nodeID
highlighter
)
{
return
this
.
_getHighlighterNodeTextContent
(
nodeID
(
highlighter
|
|
this
.
toolbox
.
highlighter
)
.
actorID
)
;
}
{
impl
:
"
_getHighlighterNodeTextContent
"
}
)
isHighlighting
:
function
(
)
{
return
this
.
getHighlighterNodeAttribute
(
"
box
-
model
-
elements
"
"
hidden
"
)
.
then
(
value
=
>
value
=
=
=
null
)
;
}
async
isNodeCorrectlyHighlighted
(
selector
is
prefix
=
"
"
)
{
prefix
+
=
(
prefix
?
"
"
:
"
"
)
+
selector
+
"
"
;
const
boxModel
=
await
this
.
_getBoxModelStatus
(
)
;
const
regions
=
await
this
.
getAllAdjustedQuads
(
selector
)
;
for
(
const
boxType
of
[
"
content
"
"
padding
"
"
border
"
"
margin
"
]
)
{
const
[
quad
]
=
regions
[
boxType
]
;
for
(
const
point
in
boxModel
[
boxType
]
.
points
)
{
is
(
boxModel
[
boxType
]
.
points
[
point
]
.
x
quad
[
point
]
.
x
prefix
+
boxType
+
"
point
"
+
point
+
"
x
coordinate
is
correct
"
)
;
is
(
boxModel
[
boxType
]
.
points
[
point
]
.
y
quad
[
point
]
.
y
prefix
+
boxType
+
"
point
"
+
point
+
"
y
coordinate
is
correct
"
)
;
}
}
}
async
getSimpleBorderRect
(
toolbox
)
{
const
{
border
}
=
await
this
.
_getBoxModelStatus
(
toolbox
)
;
const
{
p1
p2
p4
}
=
border
.
points
;
return
{
top
:
p1
.
y
left
:
p1
.
x
width
:
p2
.
x
-
p1
.
x
height
:
p4
.
y
-
p1
.
y
}
;
}
async
_getBoxModelStatus
(
)
{
const
isVisible
=
await
this
.
isHighlighting
(
)
;
const
ret
=
{
visible
:
isVisible
}
;
for
(
const
region
of
[
"
margin
"
"
border
"
"
padding
"
"
content
"
]
)
{
const
points
=
await
this
.
_getPointsForRegion
(
region
)
;
const
visible
=
await
this
.
_isRegionHidden
(
region
)
;
ret
[
region
]
=
{
points
visible
}
;
}
ret
.
guides
=
{
}
;
for
(
const
guide
of
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
)
{
ret
.
guides
[
guide
]
=
await
this
.
_getGuideStatus
(
guide
)
;
}
return
ret
;
}
async
assertHighlightedNode
(
selector
)
{
const
rect
=
await
this
.
getNodeRect
(
selector
)
;
return
this
.
isNodeRectHighlighted
(
rect
)
;
}
async
assertHighlightedTextNode
(
parentSelector
childNodeIndex
)
{
const
rect
=
await
this
.
getTextNodeRect
(
parentSelector
childNodeIndex
)
;
return
this
.
isNodeRectHighlighted
(
rect
)
;
}
async
isNodeRectHighlighted
(
{
left
top
width
height
}
)
{
const
{
visible
border
}
=
await
this
.
_getBoxModelStatus
(
)
;
let
points
=
border
.
points
;
if
(
!
visible
)
{
return
false
;
}
const
right
=
left
+
width
;
const
bottom
=
top
+
height
;
const
list
=
[
]
;
for
(
let
i
=
1
;
i
<
=
4
;
i
+
+
)
{
const
p
=
points
[
"
p
"
+
i
]
;
list
.
push
(
[
p
.
x
p
.
y
]
)
;
}
points
=
list
;
return
isInside
(
[
left
top
]
points
)
&
&
isInside
(
[
right
top
]
points
)
&
&
isInside
(
[
right
bottom
]
points
)
&
&
isInside
(
[
left
bottom
]
points
)
;
}
async
_getPointsForRegion
(
region
)
{
const
d
=
await
this
.
getHighlighterNodeAttribute
(
"
box
-
model
-
"
+
region
"
d
"
)
;
const
polygons
=
d
.
match
(
/
M
[
^
M
]
+
/
g
)
;
if
(
!
polygons
)
{
return
null
;
}
const
points
=
polygons
[
0
]
.
trim
(
)
.
split
(
"
"
)
.
map
(
i
=
>
{
return
i
.
replace
(
/
M
|
L
/
"
"
)
.
split
(
"
"
)
;
}
)
;
return
{
p1
:
{
x
:
parseFloat
(
points
[
0
]
[
0
]
)
y
:
parseFloat
(
points
[
0
]
[
1
]
)
}
p2
:
{
x
:
parseFloat
(
points
[
1
]
[
0
]
)
y
:
parseFloat
(
points
[
1
]
[
1
]
)
}
p3
:
{
x
:
parseFloat
(
points
[
2
]
[
0
]
)
y
:
parseFloat
(
points
[
2
]
[
1
]
)
}
p4
:
{
x
:
parseFloat
(
points
[
3
]
[
0
]
)
y
:
parseFloat
(
points
[
3
]
[
1
]
)
}
}
;
}
async
_isRegionHidden
(
region
)
{
const
value
=
await
this
.
getHighlighterNodeAttribute
(
"
box
-
model
-
"
+
region
"
hidden
"
)
;
return
value
!
=
=
null
;
}
async
_getGuideStatus
(
location
)
{
const
id
=
"
box
-
model
-
guide
-
"
+
location
;
const
hidden
=
await
this
.
getHighlighterNodeAttribute
(
id
"
hidden
"
)
;
const
x1
=
await
this
.
getHighlighterNodeAttribute
(
id
"
x1
"
)
;
const
y1
=
await
this
.
getHighlighterNodeAttribute
(
id
"
y1
"
)
;
const
x2
=
await
this
.
getHighlighterNodeAttribute
(
id
"
x2
"
)
;
const
y2
=
await
this
.
getHighlighterNodeAttribute
(
id
"
y2
"
)
;
return
{
visible
:
!
hidden
x1
:
x1
y1
:
y1
x2
:
x2
y2
:
y2
}
;
}
async
getGuidesRectangle
(
)
{
const
tGuide
=
await
this
.
_getGuideStatus
(
"
top
"
)
;
const
rGuide
=
await
this
.
_getGuideStatus
(
"
right
"
)
;
const
bGuide
=
await
this
.
_getGuideStatus
(
"
bottom
"
)
;
const
lGuide
=
await
this
.
_getGuideStatus
(
"
left
"
)
;
if
(
!
tGuide
.
visible
|
|
!
rGuide
.
visible
|
|
!
bGuide
.
visible
|
|
!
lGuide
.
visible
)
{
return
null
;
}
return
{
p1
:
{
x
:
lGuide
.
x1
y
:
tGuide
.
y1
}
p2
:
{
x
:
+
rGuide
.
x1
+
1
y
:
tGuide
.
y1
}
p3
:
{
x
:
+
rGuide
.
x1
+
1
y
:
+
bGuide
.
y1
+
1
}
p4
:
{
x
:
lGuide
.
x1
y
:
+
bGuide
.
y1
+
1
}
}
;
}
waitForHighlighterEvent
:
protocol
.
custom
(
function
(
event
)
{
return
this
.
_waitForHighlighterEvent
(
event
this
.
toolbox
.
highlighter
.
actorID
)
;
}
{
impl
:
"
_waitForHighlighterEvent
"
}
)
async
getHighlighterRegionPath
(
region
highlighter
)
{
const
d
=
await
this
.
getHighlighterNodeAttribute
(
box
-
model
-
{
region
}
"
d
"
highlighter
)
;
if
(
!
d
)
{
return
{
d
:
null
}
;
}
const
polygons
=
d
.
match
(
/
M
[
^
M
]
+
/
g
)
;
if
(
!
polygons
)
{
return
{
d
}
;
}
const
points
=
[
]
;
for
(
const
polygon
of
polygons
)
{
points
.
push
(
polygon
.
trim
(
)
.
split
(
"
"
)
.
map
(
i
=
>
{
return
i
.
replace
(
/
M
|
L
/
"
"
)
.
split
(
"
"
)
;
}
)
)
;
}
return
{
d
points
}
;
}
}
)
;
function
isInside
(
point
polygon
)
{
if
(
polygon
.
length
=
=
=
0
)
{
return
false
;
}
point
=
point
.
map
(
n
=
>
n
.
toFixed
(
2
)
)
;
polygon
=
polygon
.
map
(
p
=
>
p
.
map
(
n
=
>
n
.
toFixed
(
2
)
)
)
;
const
n
=
polygon
.
length
;
const
newPoints
=
polygon
.
slice
(
0
)
;
newPoints
.
push
(
polygon
[
0
]
)
;
let
wn
=
0
;
for
(
let
i
=
0
;
i
<
n
;
i
+
+
)
{
const
r
=
isLeft
(
newPoints
[
i
]
newPoints
[
i
+
1
]
point
)
;
if
(
r
=
=
=
0
)
{
return
true
;
}
if
(
newPoints
[
i
]
[
1
]
<
=
point
[
1
]
)
{
if
(
newPoints
[
i
+
1
]
[
1
]
>
point
[
1
]
&
&
r
>
0
)
{
wn
+
+
;
}
}
else
if
(
newPoints
[
i
+
1
]
[
1
]
<
=
point
[
1
]
&
&
r
<
0
)
{
wn
-
-
;
}
}
if
(
wn
=
=
=
0
)
{
dumpn
(
JSON
.
stringify
(
point
)
+
"
is
outside
of
"
+
JSON
.
stringify
(
polygon
)
)
;
}
return
wn
!
=
=
0
;
}
function
isLeft
(
p0
p1
p2
)
{
const
l
=
(
(
p1
[
0
]
-
p0
[
0
]
)
*
(
p2
[
1
]
-
p0
[
1
]
)
)
-
(
(
p2
[
0
]
-
p0
[
0
]
)
*
(
p1
[
1
]
-
p0
[
1
]
)
)
;
return
l
;
}
