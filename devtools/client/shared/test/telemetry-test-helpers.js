"
use
strict
"
;
class
TelemetryHelpers
{
constructor
(
)
{
this
.
oldCanRecord
=
Services
.
telemetry
.
canRecordExtended
;
this
.
generateTelemetryTests
=
this
.
generateTelemetryTests
.
bind
(
this
)
;
registerCleanupFunction
(
this
.
stopTelemetry
.
bind
(
this
)
)
;
}
startTelemetry
(
)
{
Services
.
telemetry
.
canRecordExtended
=
true
;
}
stopTelemetry
(
)
{
this
.
clearToolsOpenedPref
(
)
;
Services
.
telemetry
.
canRecordExtended
=
this
.
oldCanRecord
;
this
.
clearHistograms
(
Services
.
telemetry
.
snapshotHistograms
)
;
this
.
clearHistograms
(
Services
.
telemetry
.
snapshotKeyedHistograms
)
;
Services
.
telemetry
.
clearScalars
(
)
;
Services
.
telemetry
.
clearEvents
(
)
;
}
clearHistograms
(
snapshotFunc
)
{
const
OPTIN
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
;
const
OPTOUT
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTOUT
;
const
tel
=
Services
.
telemetry
;
for
(
let
optInOut
of
[
OPTIN
OPTOUT
]
)
{
const
snapshot
=
snapshotFunc
(
optInOut
true
false
)
.
parent
;
const
histKeys
=
Object
.
keys
(
snapshot
)
;
for
(
let
getHistogram
of
[
tel
.
getHistogramById
tel
.
getKeyedHistogramById
]
)
{
for
(
let
key
of
histKeys
)
{
try
{
getHistogram
(
key
)
.
clear
(
)
;
}
catch
(
e
)
{
}
}
}
}
}
clearToolsOpenedPref
(
)
{
const
TOOLS_OPENED_PREF
=
"
devtools
.
telemetry
.
tools
.
opened
.
version
"
;
Services
.
prefs
.
clearUserPref
(
TOOLS_OPENED_PREF
)
;
}
checkTelemetry
(
histId
key
expected
checkType
)
{
const
OPTIN
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
;
let
actual
;
let
msg
;
if
(
checkType
=
=
=
"
array
"
|
|
checkType
=
=
=
"
hasentries
"
)
{
if
(
key
)
{
const
keyedHistogram
=
Services
.
telemetry
.
getKeyedHistogramById
(
histId
)
.
snapshot
(
)
;
const
result
=
keyedHistogram
[
key
]
;
if
(
result
)
{
actual
=
result
.
counts
;
}
else
{
ok
(
false
{
histId
}
[
{
key
}
]
exists
)
;
return
;
}
}
else
{
actual
=
Services
.
telemetry
.
getHistogramById
(
histId
)
.
snapshot
(
)
.
counts
;
}
}
switch
(
checkType
)
{
case
"
array
"
:
msg
=
key
?
{
histId
}
[
"
{
key
}
"
]
correct
.
:
{
histId
}
correct
.
;
is
(
JSON
.
stringify
(
actual
)
JSON
.
stringify
(
expected
)
msg
)
;
break
;
case
"
hasentries
"
:
let
hasEntry
=
actual
.
some
(
num
=
>
num
>
0
)
;
if
(
key
)
{
ok
(
hasEntry
{
histId
}
[
"
{
key
}
"
]
has
at
least
one
entry
.
)
;
}
else
{
ok
(
hasEntry
{
histId
}
has
at
least
one
entry
.
)
;
}
break
;
case
"
scalar
"
:
const
scalars
=
Services
.
telemetry
.
snapshotScalars
(
OPTIN
false
)
.
parent
;
is
(
scalars
[
histId
]
expected
{
histId
}
correct
)
;
break
;
case
"
keyedscalar
"
:
const
keyedScalars
=
Services
.
telemetry
.
snapshotKeyedScalars
(
OPTIN
false
)
.
parent
;
const
value
=
keyedScalars
[
histId
]
[
key
]
;
msg
=
key
?
{
histId
}
[
"
{
key
}
"
]
correct
.
:
{
histId
}
correct
.
;
is
(
value
expected
msg
)
;
break
;
}
}
generateTelemetryTests
(
prefix
=
"
"
)
{
const
OPTIN
=
Ci
.
nsITelemetry
.
DATASET_RELEASE_CHANNEL_OPTIN
;
const
histograms
=
Services
.
telemetry
.
snapshotHistograms
(
OPTIN
true
false
)
.
parent
;
const
keyedHistograms
=
Services
.
telemetry
.
snapshotKeyedHistograms
(
OPTIN
true
false
)
.
parent
;
const
scalars
=
Services
.
telemetry
.
snapshotScalars
(
OPTIN
false
)
.
parent
;
const
keyedScalars
=
Services
.
telemetry
.
snapshotKeyedScalars
(
OPTIN
false
)
.
parent
;
const
allHistograms
=
Object
.
assign
(
{
}
histograms
keyedHistograms
scalars
keyedScalars
)
;
const
histIds
=
Object
.
keys
(
allHistograms
)
.
filter
(
histId
=
>
histId
.
startsWith
(
prefix
)
)
;
dump
(
"
=
"
.
repeat
(
80
)
+
"
\
n
"
)
;
for
(
let
histId
of
histIds
)
{
let
snapshot
=
allHistograms
[
histId
]
;
if
(
histId
=
=
=
histId
.
toLowerCase
(
)
)
{
if
(
typeof
snapshot
=
=
=
"
object
"
)
{
const
keys
=
Object
.
keys
(
snapshot
)
;
for
(
let
key
of
keys
)
{
const
value
=
snapshot
[
key
]
;
dump
(
checkTelemetry
(
"
{
histId
}
"
"
{
key
}
"
{
value
}
"
keyedscalar
"
)
;
\
n
)
;
}
}
else
{
dump
(
checkTelemetry
(
"
{
histId
}
"
"
"
{
snapshot
}
"
scalar
"
)
;
\
n
)
;
}
}
else
if
(
typeof
snapshot
.
histogram_type
!
=
=
"
undefined
"
&
&
typeof
snapshot
.
counts
!
=
=
"
undefined
"
)
{
const
actual
=
snapshot
.
counts
;
this
.
displayDataFromHistogramSnapshot
(
snapshot
"
"
histId
actual
)
;
}
else
{
const
keys
=
Object
.
keys
(
snapshot
)
;
for
(
let
key
of
keys
)
{
const
value
=
snapshot
[
key
]
;
const
actual
=
value
.
counts
;
this
.
displayDataFromHistogramSnapshot
(
value
key
histId
actual
)
;
}
}
}
dump
(
"
=
"
.
repeat
(
80
)
+
"
\
n
"
)
;
}
displayDataFromHistogramSnapshot
(
snapshot
key
histId
actual
)
{
key
=
key
?
"
{
key
}
"
:
"
"
;
switch
(
snapshot
.
histogram_type
)
{
case
Services
.
telemetry
.
HISTOGRAM_EXPONENTIAL
:
case
Services
.
telemetry
.
HISTOGRAM_LINEAR
:
let
total
=
0
;
for
(
let
val
of
actual
)
{
total
+
=
val
;
}
if
(
histId
.
endsWith
(
"
_ENUMERATED
"
)
)
{
if
(
total
>
0
)
{
actual
=
actual
.
toSource
(
)
;
dump
(
checkTelemetry
(
"
{
histId
}
"
{
key
}
{
actual
}
"
array
"
)
;
\
n
)
;
}
return
;
}
dump
(
checkTelemetry
(
"
{
histId
}
"
{
key
}
null
"
hasentries
"
)
;
\
n
)
;
break
;
case
Services
.
telemetry
.
HISTOGRAM_BOOLEAN
:
actual
=
actual
.
toSource
(
)
;
if
(
actual
!
=
=
"
[
0
0
0
]
"
)
{
dump
(
checkTelemetry
(
"
{
histId
}
"
{
key
}
{
actual
}
"
array
"
)
;
\
n
)
;
}
break
;
case
Services
.
telemetry
.
HISTOGRAM_FLAG
:
actual
=
actual
.
toSource
(
)
;
if
(
actual
!
=
=
"
[
1
0
0
]
"
)
{
dump
(
checkTelemetry
(
"
{
histId
}
"
{
key
}
{
actual
}
"
array
"
)
;
\
n
)
;
}
break
;
case
Services
.
telemetry
.
HISTOGRAM_COUNT
:
actual
=
actual
.
toSource
(
)
;
dump
(
checkTelemetry
(
"
{
histId
}
"
{
key
}
{
actual
}
"
array
"
)
;
\
n
)
;
break
;
}
}
}
const
telemetryHelpers
=
new
TelemetryHelpers
(
)
;
const
generateTelemetryTests
=
telemetryHelpers
.
generateTelemetryTests
;
const
checkTelemetry
=
telemetryHelpers
.
checkTelemetry
;
const
startTelemetry
=
telemetryHelpers
.
startTelemetry
;
