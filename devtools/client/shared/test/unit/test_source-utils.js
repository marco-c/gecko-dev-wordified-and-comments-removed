"
use
strict
"
;
const
{
require
}
=
Components
.
utils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
sourceUtils
=
require
(
"
devtools
/
client
/
shared
/
source
-
utils
"
)
;
const
CHROME_URLS
=
[
"
chrome
:
/
/
foo
"
"
resource
:
/
/
baz
"
"
jar
:
file
:
/
/
/
Users
/
root
"
]
;
const
CONTENT_URLS
=
[
"
http
:
/
/
mozilla
.
org
"
"
https
:
/
/
mozilla
.
org
"
"
file
:
/
/
/
Users
/
root
"
"
app
:
/
/
fxosapp
"
"
blob
:
http
:
/
/
mozilla
.
org
"
"
blob
:
https
:
/
/
mozilla
.
org
"
]
;
add_task
(
function
*
(
)
{
let
parsed
=
sourceUtils
.
parseURL
(
"
https
:
/
/
foo
.
com
:
8888
/
boo
/
bar
.
js
?
q
=
query
"
)
;
equal
(
parsed
.
fileName
"
bar
.
js
"
"
parseURL
parsed
valid
fileName
"
)
;
equal
(
parsed
.
host
"
foo
.
com
:
8888
"
"
parseURL
parsed
valid
host
"
)
;
equal
(
parsed
.
hostname
"
foo
.
com
"
"
parseURL
parsed
valid
hostname
"
)
;
equal
(
parsed
.
port
"
8888
"
"
parseURL
parsed
valid
port
"
)
;
equal
(
parsed
.
href
"
https
:
/
/
foo
.
com
:
8888
/
boo
/
bar
.
js
?
q
=
query
"
"
parseURL
parsed
valid
href
"
)
;
parsed
=
sourceUtils
.
parseURL
(
"
https
:
/
/
foo
.
com
"
)
;
equal
(
parsed
.
host
"
foo
.
com
"
"
parseURL
parsed
valid
host
when
no
port
given
"
)
;
equal
(
parsed
.
hostname
"
foo
.
com
"
"
parseURL
parsed
valid
hostname
when
no
port
given
"
)
;
equal
(
sourceUtils
.
parseURL
(
"
self
-
hosted
"
)
null
"
parseURL
returns
null
for
invalid
URLs
"
)
;
}
)
;
add_task
(
function
*
(
)
{
for
(
let
url
of
CHROME_URLS
)
{
ok
(
!
sourceUtils
.
isContentScheme
(
url
)
{
url
}
correctly
identified
as
not
content
scheme
)
;
}
for
(
let
url
of
CONTENT_URLS
)
{
ok
(
sourceUtils
.
isContentScheme
(
url
)
{
url
}
correctly
identified
as
content
scheme
)
;
}
}
)
;
add_task
(
function
*
(
)
{
for
(
let
url
of
CHROME_URLS
)
{
ok
(
sourceUtils
.
isChromeScheme
(
url
)
{
url
}
correctly
identified
as
chrome
scheme
)
;
}
for
(
let
url
of
CONTENT_URLS
)
{
ok
(
!
sourceUtils
.
isChromeScheme
(
url
)
{
url
}
correctly
identified
as
not
chrome
scheme
)
;
}
}
)
;
add_task
(
function
*
(
)
{
ok
(
sourceUtils
.
isWASM
(
"
wasm
-
function
[
66240
]
(
?
:
13870536
)
"
)
"
wasm
function
correctly
identified
"
)
;
ok
(
!
sourceUtils
.
isWASM
(
CHROME_URLS
[
0
]
)
A
chrome
url
does
not
identify
as
wasm
.
)
;
}
)
;
add_task
(
function
*
(
)
{
let
dataURI
=
"
data
:
text
/
html
;
charset
=
utf
-
8
<
!
DOCTYPE
html
>
<
/
html
>
"
;
ok
(
sourceUtils
.
isDataScheme
(
dataURI
)
{
dataURI
}
correctly
identified
as
data
scheme
)
;
for
(
let
url
of
CHROME_URLS
)
{
ok
(
!
sourceUtils
.
isDataScheme
(
url
)
{
url
}
correctly
identified
as
not
data
scheme
)
;
}
for
(
let
url
of
CONTENT_URLS
)
{
ok
(
!
sourceUtils
.
isDataScheme
(
url
)
{
url
}
correctly
identified
as
not
data
scheme
)
;
}
}
)
;
add_task
(
function
*
(
)
{
testAbbreviation
(
"
http
:
/
/
example
.
com
/
foo
/
bar
/
baz
/
boo
.
js
"
"
boo
.
js
"
"
http
:
/
/
example
.
com
/
foo
/
bar
/
baz
/
boo
.
js
"
"
example
.
com
"
)
;
}
)
;
add_task
(
function
*
(
)
{
ok
(
sourceUtils
.
isScratchpadScheme
(
"
Scratchpad
/
1
"
)
"
Scratchpad
/
1
identified
as
scratchpad
"
)
;
ok
(
sourceUtils
.
isScratchpadScheme
(
"
Scratchpad
/
20
"
)
"
Scratchpad
/
20
identified
as
scratchpad
"
)
;
ok
(
!
sourceUtils
.
isScratchpadScheme
(
"
http
:
/
/
www
.
mozilla
.
org
"
)
"
http
:
/
/
www
.
mozilla
.
org
not
identified
as
scratchpad
"
)
;
}
)
;
add_task
(
function
*
(
)
{
let
longMalformedURL
=
example
.
com
{
new
Array
(
100
)
.
fill
(
"
/
a
"
)
.
join
(
"
"
)
}
/
file
.
js
;
ok
(
sourceUtils
.
getSourceNames
(
longMalformedURL
)
.
short
.
length
<
=
100
"
short
names
are
capped
at
100
characters
"
)
;
testAbbreviation
(
"
self
-
hosted
"
"
self
-
hosted
"
"
self
-
hosted
"
)
;
testAbbreviation
(
"
"
"
(
unknown
)
"
"
(
unknown
)
"
)
;
testAbbreviation
(
"
data
:
text
/
html
;
charset
=
utf
-
8
<
!
DOCTYPE
html
>
<
/
html
>
"
"
data
:
<
!
DOCTYPE
html
>
<
/
html
>
"
"
data
:
text
/
html
;
charset
=
utf
-
8
<
!
DOCTYPE
html
>
<
/
html
>
"
)
;
let
longDataURI
=
data
:
image
/
png
;
base64
{
new
Array
(
100
)
.
fill
(
"
a
"
)
.
join
(
"
"
)
}
;
let
longDataURIShort
=
sourceUtils
.
getSourceNames
(
longDataURI
)
.
short
;
ok
(
longDataURIShort
.
length
<
=
100
"
short
names
are
capped
at
100
characters
for
data
URIs
"
)
;
equal
(
longDataURIShort
.
substr
(
0
10
)
"
data
:
aaaaa
"
"
truncated
data
URI
short
names
still
have
data
:
.
.
.
"
)
;
let
testUrl
=
"
http
:
/
/
example
.
com
/
foo
/
bar
/
baz
/
boo
.
js
"
;
testAbbreviation
(
testUrl
"
boo
.
js
"
testUrl
"
example
.
com
"
)
;
testAbbreviation
(
testUrl
"
boo
.
js
"
testUrl
"
example
.
com
"
)
;
testAbbreviation
(
"
http
:
/
/
example
.
com
:
8888
/
foo
/
bar
/
baz
.
js
?
q
=
query
#
go
"
"
baz
.
js
"
"
http
:
/
/
example
.
com
:
8888
/
foo
/
bar
/
baz
.
js
"
"
example
.
com
:
8888
"
)
;
testAbbreviation
(
"
http
:
/
/
example
.
com
/
"
"
/
"
"
http
:
/
/
example
.
com
/
"
"
example
.
com
"
)
;
testAbbreviation
(
"
http
:
/
/
example
.
com
/
foo
/
bar
/
"
"
bar
"
"
http
:
/
/
example
.
com
/
foo
/
bar
/
"
"
example
.
com
"
)
;
testAbbreviation
(
"
http
:
/
/
example
.
com
/
bar
"
"
bar
"
"
http
:
/
/
example
.
com
/
bar
"
"
example
.
com
"
)
;
testAbbreviation
(
"
http
:
/
/
example
.
com
/
foo
.
js
?
bar
=
1
&
baz
=
2
"
"
foo
.
js
"
"
http
:
/
/
example
.
com
/
foo
.
js
"
"
example
.
com
"
)
;
testAbbreviation
(
"
http
:
/
/
example
.
com
/
foo
/
?
bar
=
1
&
baz
=
2
"
"
foo
"
"
http
:
/
/
example
.
com
/
foo
/
"
"
example
.
com
"
)
;
}
)
;
add_task
(
function
*
(
)
{
const
{
getSourceMappedFile
}
=
sourceUtils
;
const
source
=
"
baz
.
js
"
;
const
output
=
getSourceMappedFile
(
source
)
;
equal
(
output
"
baz
.
js
"
"
correctly
formats
file
name
"
)
;
const
source1
=
"
/
foo
/
bar
/
baz
.
js
"
;
const
output1
=
getSourceMappedFile
(
source1
)
;
equal
(
output1
"
baz
.
js
"
"
correctly
formats
Linux
file
path
"
)
;
const
source2
=
"
Z
:
\
\
foo
\
\
bar
\
\
baz
.
js
"
;
const
output2
=
getSourceMappedFile
(
source2
)
;
equal
(
output2
"
baz
.
js
"
"
correctly
formats
Windows
file
path
"
)
;
}
)
;
function
testAbbreviation
(
source
short
long
host
)
{
let
results
=
sourceUtils
.
getSourceNames
(
source
)
;
equal
(
results
.
short
short
{
source
}
has
correct
"
short
"
name
)
;
equal
(
results
.
long
long
{
source
}
has
correct
"
long
"
name
)
;
equal
(
results
.
host
host
{
source
}
has
correct
"
host
"
name
)
;
}
