"
use
strict
"
;
const
TEST_URI
=
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
"
<
p
>
browser_telemetry_button_responsive
.
js
<
/
p
>
"
;
const
TOOL_DELAY
=
200
;
const
asyncStorage
=
require
(
"
devtools
/
shared
/
async
-
storage
"
)
;
requestLongerTimeout
(
2
)
;
flags
.
testing
=
true
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
html
.
displayedDeviceList
"
)
;
Services
.
prefs
.
setCharPref
(
"
devtools
.
devices
.
url
"
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
responsive
.
html
/
test
/
browser
/
devices
.
json
"
)
;
registerCleanupFunction
(
(
)
=
>
{
flags
.
testing
=
false
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
devices
.
url
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
responsive
.
html
.
displayedDeviceList
"
)
;
asyncStorage
.
removeItem
(
"
devtools
.
devices
.
url_cache
"
)
;
asyncStorage
.
removeItem
(
"
devtools
.
devices
.
local
"
)
;
}
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
devtools
/
client
/
responsive
.
html
/
manager
"
true
)
;
add_task
(
async
function
(
)
{
await
addTab
(
TEST_URI
)
;
let
Telemetry
=
loadTelemetryAndRecordLogs
(
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
inspector
"
)
;
info
(
"
inspector
opened
"
)
;
info
(
"
testing
the
responsivedesign
button
"
)
;
await
testButton
(
toolbox
Telemetry
)
;
stopRecordingTelemetryLogs
(
Telemetry
)
;
await
gDevTools
.
closeToolbox
(
target
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
async
function
testButton
(
toolbox
Telemetry
)
{
info
(
"
Testing
command
-
button
-
responsive
"
)
;
let
button
=
toolbox
.
doc
.
querySelector
(
"
#
command
-
button
-
responsive
"
)
;
ok
(
button
"
Captain
we
have
the
button
"
)
;
await
delayedClicks
(
button
4
)
;
checkResults
(
"
_RESPONSIVE_
"
Telemetry
)
;
}
function
waitForToggle
(
)
{
return
new
Promise
(
resolve
=
>
{
let
handler
=
(
)
=
>
{
ResponsiveUIManager
.
off
(
"
on
"
handler
)
;
ResponsiveUIManager
.
off
(
"
off
"
handler
)
;
resolve
(
)
;
}
;
ResponsiveUIManager
.
on
(
"
on
"
handler
)
;
ResponsiveUIManager
.
on
(
"
off
"
handler
)
;
}
)
;
}
var
delayedClicks
=
async
function
(
node
clicks
)
{
for
(
let
i
=
0
;
i
<
clicks
;
i
+
+
)
{
info
(
"
Clicking
button
"
+
node
.
id
)
;
let
toggled
=
waitForToggle
(
)
;
node
.
click
(
)
;
await
toggled
;
await
DevToolsUtils
.
waitForTime
(
TOOL_DELAY
)
;
}
}
;
function
checkResults
(
histIdFocus
Telemetry
)
{
let
result
=
Telemetry
.
prototype
.
telemetryInfo
;
for
(
let
[
histId
value
]
of
Object
.
entries
(
result
)
)
{
if
(
histId
.
startsWith
(
"
DEVTOOLS_INSPECTOR_
"
)
|
|
!
histId
.
includes
(
histIdFocus
)
)
{
continue
;
}
if
(
histId
.
endsWith
(
"
OPENED_COUNT
"
)
)
{
ok
(
value
.
length
>
1
histId
+
"
has
more
than
one
entry
"
)
;
let
okay
=
value
.
every
(
function
(
element
)
{
return
element
=
=
=
true
;
}
)
;
ok
(
okay
"
All
"
+
histId
+
"
entries
are
=
=
=
true
"
)
;
}
else
if
(
histId
.
endsWith
(
"
TIME_ACTIVE_SECONDS
"
)
)
{
ok
(
value
.
length
>
1
histId
+
"
has
more
than
one
entry
"
)
;
let
okay
=
value
.
every
(
function
(
element
)
{
return
element
>
0
;
}
)
;
ok
(
okay
"
All
"
+
histId
+
"
entries
have
time
>
0
"
)
;
}
}
}
