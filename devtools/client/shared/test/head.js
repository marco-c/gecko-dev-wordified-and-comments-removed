"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
framework
/
test
/
shared
-
head
.
js
"
this
)
;
const
{
DOMHelpers
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
DOMHelpers
.
jsm
"
{
}
)
;
const
{
Hosts
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
-
hosts
"
)
;
const
TEST_URI_ROOT
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
shared
/
test
/
"
;
const
OPTIONS_VIEW_URL
=
TEST_URI_ROOT
+
"
doc_options
-
view
.
xul
"
;
function
catchFail
(
func
)
{
return
function
(
)
{
try
{
return
func
.
apply
(
null
arguments
)
;
}
catch
(
ex
)
{
ok
(
false
ex
)
;
console
.
error
(
ex
)
;
finish
(
)
;
throw
ex
;
}
}
;
}
function
waitForValue
(
options
)
{
let
start
=
Date
.
now
(
)
;
let
timeout
=
options
.
timeout
|
|
5000
;
let
lastValue
;
function
wait
(
validatorFn
successFn
failureFn
)
{
if
(
(
Date
.
now
(
)
-
start
)
>
timeout
)
{
ok
(
false
"
Timed
out
while
waiting
for
:
"
+
options
.
name
)
;
let
expected
=
"
value
"
in
options
?
"
'
"
+
options
.
value
+
"
'
"
:
"
a
trueish
value
"
;
info
(
"
timeout
info
:
:
got
'
"
+
lastValue
+
"
'
expected
"
+
expected
)
;
failureFn
(
options
lastValue
)
;
return
;
}
lastValue
=
validatorFn
(
options
lastValue
)
;
let
successful
=
"
value
"
in
options
?
lastValue
=
=
options
.
value
:
lastValue
;
if
(
successful
)
{
ok
(
true
options
.
name
)
;
successFn
(
options
lastValue
)
;
}
else
{
setTimeout
(
(
)
=
>
{
wait
(
validatorFn
successFn
failureFn
)
;
}
100
)
;
}
}
wait
(
options
.
validator
options
.
success
options
.
failure
)
;
}
function
oneTimeObserve
(
name
callback
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
func
=
function
(
)
{
Services
.
obs
.
removeObserver
(
func
name
)
;
if
(
callback
)
{
callback
(
)
;
}
resolve
(
)
;
}
;
Services
.
obs
.
addObserver
(
func
name
false
)
;
}
)
;
}
let
createHost
=
Task
.
async
(
function
*
(
type
=
"
bottom
"
src
=
"
data
:
text
/
html
;
charset
=
utf
-
8
"
)
{
let
host
=
new
Hosts
[
type
]
(
gBrowser
.
selectedTab
)
;
let
iframe
=
yield
host
.
create
(
)
;
yield
new
Promise
(
resolve
=
>
{
let
domHelper
=
new
DOMHelpers
(
iframe
.
contentWindow
)
;
iframe
.
setAttribute
(
"
src
"
src
)
;
domHelper
.
onceDOMReady
(
resolve
)
;
}
)
;
return
[
host
iframe
.
contentWindow
iframe
.
contentDocument
]
;
}
)
;
function
loadTelemetryAndRecordLogs
(
)
{
info
(
"
Mock
the
Telemetry
log
function
to
record
logged
information
"
)
;
let
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
Telemetry
.
prototype
.
telemetryInfo
=
{
}
;
Telemetry
.
prototype
.
_oldlog
=
Telemetry
.
prototype
.
log
;
Telemetry
.
prototype
.
log
=
function
(
histogramId
value
)
{
if
(
!
this
.
telemetryInfo
)
{
return
;
}
if
(
histogramId
)
{
if
(
!
this
.
telemetryInfo
[
histogramId
]
)
{
this
.
telemetryInfo
[
histogramId
]
=
[
]
;
}
this
.
telemetryInfo
[
histogramId
]
.
push
(
value
)
;
}
}
;
return
Telemetry
;
}
function
stopRecordingTelemetryLogs
(
Telemetry
)
{
Telemetry
.
prototype
.
log
=
Telemetry
.
prototype
.
_oldlog
;
delete
Telemetry
.
prototype
.
_oldlog
;
delete
Telemetry
.
prototype
.
telemetryInfo
;
}
function
checkTelemetryResults
(
Telemetry
)
{
let
result
=
Telemetry
.
prototype
.
telemetryInfo
;
for
(
let
histId
in
result
)
{
let
value
=
result
[
histId
]
;
if
(
histId
.
endsWith
(
"
OPENED_PER_USER_FLAG
"
)
)
{
ok
(
value
.
length
=
=
=
1
&
&
value
[
0
]
=
=
=
true
"
Per
user
value
"
+
histId
+
"
has
a
single
value
of
true
"
)
;
}
else
if
(
histId
.
endsWith
(
"
OPENED_COUNT
"
)
)
{
ok
(
value
.
length
>
1
histId
+
"
has
more
than
one
entry
"
)
;
let
okay
=
value
.
every
(
function
(
element
)
{
return
element
=
=
=
true
;
}
)
;
ok
(
okay
"
All
"
+
histId
+
"
entries
are
=
=
=
true
"
)
;
}
else
if
(
histId
.
endsWith
(
"
TIME_ACTIVE_SECONDS
"
)
)
{
ok
(
value
.
length
>
1
histId
+
"
has
more
than
one
entry
"
)
;
let
okay
=
value
.
every
(
function
(
element
)
{
return
element
>
0
;
}
)
;
ok
(
okay
"
All
"
+
histId
+
"
entries
have
time
>
0
"
)
;
}
}
}
function
*
openAndCloseToolbox
(
nbOfTimes
usageTime
toolId
)
{
for
(
let
i
=
0
;
i
<
nbOfTimes
;
i
+
+
)
{
info
(
"
Opening
toolbox
"
+
(
i
+
1
)
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
showToolbox
(
target
toolId
)
;
yield
new
Promise
(
resolve
=
>
setTimeout
(
resolve
usageTime
)
)
;
info
(
"
Closing
toolbox
"
+
(
i
+
1
)
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
}
}
function
synthesizeProfileForTest
(
samples
)
{
const
RecordingUtils
=
require
(
"
devtools
/
shared
/
performance
/
recording
-
utils
"
)
;
samples
.
unshift
(
{
time
:
0
frames
:
[
]
}
)
;
let
uniqueStacks
=
new
RecordingUtils
.
UniqueStacks
(
)
;
return
RecordingUtils
.
deflateThread
(
{
samples
:
samples
markers
:
[
]
}
uniqueStacks
)
;
}
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
function
showFilterPopupPresets
(
widget
)
{
let
onRender
=
widget
.
once
(
"
render
"
)
;
widget
.
_togglePresets
(
)
;
return
onRender
;
}
let
showFilterPopupPresetsAndCreatePreset
=
Task
.
async
(
function
*
(
widget
name
value
)
{
yield
showFilterPopupPresets
(
widget
)
;
let
onRender
=
widget
.
once
(
"
render
"
)
;
widget
.
setCssValue
(
value
)
;
yield
onRender
;
let
footer
=
widget
.
el
.
querySelector
(
"
.
presets
-
list
.
footer
"
)
;
footer
.
querySelector
(
"
input
"
)
.
value
=
name
;
onRender
=
widget
.
once
(
"
render
"
)
;
widget
.
_savePreset
(
{
preventDefault
:
(
)
=
>
{
}
}
)
;
yield
onRender
;
}
)
;
function
checkCssSyntaxHighlighterOutput
(
expectedNodes
parent
)
{
const
PROPERTY_NAME_COLOR
=
"
theme
-
fg
-
color5
"
;
const
PROPERTY_VALUE_COLOR
=
"
theme
-
fg
-
color1
"
;
const
COMMENT_COLOR
=
"
theme
-
comment
"
;
function
checkNode
(
expected
actual
)
{
ok
(
actual
.
textContent
=
=
expected
.
text
"
Check
that
node
has
the
expected
textContent
"
)
;
info
(
"
Expected
text
content
:
[
"
+
expected
.
text
+
"
]
"
)
;
info
(
"
Actual
text
content
:
[
"
+
actual
.
textContent
+
"
]
"
)
;
info
(
"
Check
that
node
has
the
expected
type
"
)
;
if
(
expected
.
type
=
=
"
text
"
)
{
ok
(
actual
.
nodeType
=
=
3
"
Check
that
node
is
a
text
node
"
)
;
}
else
{
ok
(
actual
.
tagName
.
toUpperCase
(
)
=
=
"
SPAN
"
"
Check
that
node
is
a
SPAN
"
)
;
}
info
(
"
Check
that
node
has
the
expected
className
"
)
;
let
expectedClassName
=
null
;
let
actualClassName
=
null
;
switch
(
expected
.
type
)
{
case
"
property
-
name
"
:
expectedClassName
=
PROPERTY_NAME_COLOR
;
break
;
case
"
property
-
value
"
:
expectedClassName
=
PROPERTY_VALUE_COLOR
;
break
;
case
"
comment
"
:
expectedClassName
=
COMMENT_COLOR
;
break
;
default
:
ok
(
!
actual
.
classList
"
No
className
expected
"
)
;
return
;
}
ok
(
actual
.
classList
.
length
=
=
1
"
One
className
expected
"
)
;
actualClassName
=
actual
.
classList
[
0
]
;
ok
(
expectedClassName
=
=
actualClassName
"
Check
className
value
"
)
;
info
(
"
Expected
className
:
"
+
expectedClassName
)
;
info
(
"
Actual
className
:
"
+
actualClassName
)
;
}
info
(
"
Logging
the
actual
nodes
we
have
:
"
)
;
for
(
let
j
=
0
;
j
<
parent
.
childNodes
.
length
;
j
+
+
)
{
let
n
=
parent
.
childNodes
[
j
]
;
info
(
j
+
"
/
"
+
"
nodeType
:
"
+
n
.
nodeType
+
"
/
"
+
"
textContent
:
"
+
n
.
textContent
)
;
}
ok
(
parent
.
childNodes
.
length
=
=
parent
.
childNodes
.
length
"
Check
we
have
the
expected
number
of
nodes
"
)
;
info
(
"
Expected
node
count
"
+
expectedNodes
.
length
)
;
info
(
"
Actual
node
count
"
+
expectedNodes
.
length
)
;
for
(
let
i
=
0
;
i
<
expectedNodes
.
length
;
i
+
+
)
{
info
(
"
Check
node
"
+
i
)
;
checkNode
(
expectedNodes
[
i
]
parent
.
childNodes
[
i
]
)
;
}
}
