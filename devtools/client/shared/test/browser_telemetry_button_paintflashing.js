"
use
strict
"
;
const
TEST_URI
=
"
data
:
text
/
html
;
charset
=
utf
-
8
"
+
"
<
p
>
browser_telemetry_button_paintflashing
.
js
<
/
p
>
"
;
const
TOOL_DELAY
=
200
;
add_task
(
async
function
(
)
{
await
addTab
(
TEST_URI
)
;
let
Telemetry
=
loadTelemetryAndRecordLogs
(
)
;
await
pushPref
(
"
devtools
.
command
-
button
-
paintflashing
.
enabled
"
true
)
;
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
let
toolbox
=
await
gDevTools
.
showToolbox
(
target
"
inspector
"
)
;
info
(
"
inspector
opened
"
)
;
info
(
"
testing
the
paintflashing
button
"
)
;
await
testButton
(
toolbox
Telemetry
)
;
stopRecordingTelemetryLogs
(
Telemetry
)
;
await
gDevTools
.
closeToolbox
(
target
)
;
gBrowser
.
removeCurrentTab
(
)
;
}
)
;
async
function
testButton
(
toolbox
Telemetry
)
{
info
(
"
Testing
command
-
button
-
paintflashing
"
)
;
let
button
=
toolbox
.
doc
.
querySelector
(
"
#
command
-
button
-
paintflashing
"
)
;
ok
(
button
"
Captain
we
have
the
button
"
)
;
await
delayedClicks
(
toolbox
button
4
)
;
checkResults
(
"
_PAINTFLASHING_
"
Telemetry
)
;
}
async
function
delayedClicks
(
toolbox
node
clicks
)
{
for
(
let
i
=
0
;
i
<
clicks
;
i
+
+
)
{
await
new
Promise
(
resolve
=
>
{
setTimeout
(
(
)
=
>
resolve
(
)
TOOL_DELAY
)
;
}
)
;
let
{
CommandState
}
=
require
(
"
devtools
/
shared
/
gcli
/
command
-
state
"
)
;
let
clicked
=
new
Promise
(
resolve
=
>
{
CommandState
.
on
(
"
changed
"
function
changed
(
type
{
command
}
)
{
if
(
command
=
=
=
"
paintflashing
"
)
{
CommandState
.
off
(
"
changed
"
changed
)
;
resolve
(
)
;
}
}
)
;
}
)
;
info
(
"
Clicking
button
"
+
node
.
id
)
;
node
.
click
(
)
;
await
clicked
;
}
}
function
checkResults
(
histIdFocus
Telemetry
)
{
let
result
=
Telemetry
.
prototype
.
telemetryInfo
;
for
(
let
[
histId
value
]
of
Object
.
entries
(
result
)
)
{
if
(
histId
.
startsWith
(
"
DEVTOOLS_INSPECTOR_
"
)
|
|
!
histId
.
includes
(
histIdFocus
)
)
{
continue
;
}
if
(
histId
.
endsWith
(
"
OPENED_COUNT
"
)
)
{
ok
(
value
.
length
>
1
histId
+
"
has
more
than
one
entry
"
)
;
let
okay
=
value
.
every
(
function
(
element
)
{
return
element
=
=
=
true
;
}
)
;
ok
(
okay
"
All
"
+
histId
+
"
entries
are
=
=
=
true
"
)
;
}
else
if
(
histId
.
endsWith
(
"
TIME_ACTIVE_SECONDS
"
)
)
{
ok
(
value
.
length
>
1
histId
+
"
has
more
than
one
entry
"
)
;
let
okay
=
value
.
every
(
function
(
element
)
{
return
element
>
0
;
}
)
;
ok
(
okay
"
All
"
+
histId
+
"
entries
have
time
>
0
"
)
;
}
}
}
