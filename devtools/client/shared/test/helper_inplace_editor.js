"
use
strict
"
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
{
editableField
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
inplace
-
editor
.
js
"
)
;
const
{
colorUtils
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
color
.
js
"
)
;
const
createInplaceEditorAndClick
=
async
function
(
options
doc
textContent
)
{
const
span
=
(
options
.
element
=
createSpan
(
doc
)
)
;
if
(
textContent
)
{
span
.
textContent
=
textContent
;
}
info
(
"
Creating
an
inplace
-
editor
field
"
)
;
editableField
(
options
)
;
info
(
"
Clicking
on
the
inplace
-
editor
field
to
turn
to
edit
mode
"
)
;
span
.
click
(
)
;
}
;
function
createSpan
(
doc
)
{
info
(
"
Creating
a
new
span
element
"
)
;
const
div
=
doc
.
createElementNS
(
HTML_NS
"
div
"
)
;
const
span
=
doc
.
createElementNS
(
HTML_NS
"
span
"
)
;
span
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
span
.
style
.
fontSize
=
"
11px
"
;
span
.
style
.
display
=
"
inline
-
block
"
;
span
.
style
.
width
=
"
100px
"
;
span
.
style
.
border
=
"
1px
solid
red
"
;
span
.
style
.
fontFamily
=
"
monospace
"
;
div
.
style
.
height
=
"
100
%
"
;
div
.
style
.
position
=
"
absolute
"
;
div
.
appendChild
(
span
)
;
const
parent
=
doc
.
querySelector
(
"
window
"
)
|
|
doc
.
body
;
parent
.
appendChild
(
div
)
;
return
span
;
}
async
function
testCompletion
(
[
key
completion
index
items
postLabel
colorSwatch
]
editor
)
{
info
(
"
Pressing
key
"
+
key
)
;
info
(
"
Expecting
"
+
completion
)
;
let
onVisibilityChange
=
null
;
const
total
=
Array
.
isArray
(
items
)
?
items
.
length
:
items
;
const
open
=
total
>
0
;
if
(
editor
.
popup
.
isOpen
!
=
open
)
{
onVisibilityChange
=
editor
.
popup
.
once
(
open
?
"
popup
-
opened
"
:
"
popup
-
closed
"
)
;
}
let
onSuggest
;
if
(
/
(
left
|
right
|
back_space
|
escape
)
/
gi
.
test
(
key
)
)
{
info
(
"
Adding
event
listener
for
right
|
back_space
|
escape
keys
"
)
;
onSuggest
=
once
(
editor
.
input
"
keypress
"
)
;
}
else
{
info
(
"
Waiting
for
after
-
suggest
event
on
the
editor
"
)
;
onSuggest
=
editor
.
once
(
"
after
-
suggest
"
)
;
}
info
(
"
Synthesizing
key
"
+
key
)
;
EventUtils
.
synthesizeKey
(
key
{
}
editor
.
input
.
defaultView
)
;
await
onSuggest
;
await
onVisibilityChange
;
await
waitForTime
(
5
)
;
info
(
"
Checking
the
state
"
)
;
if
(
completion
!
=
=
null
)
{
is
(
editor
.
input
.
value
completion
"
Correct
value
is
autocompleted
"
)
;
}
if
(
postLabel
)
{
const
selectedItem
=
editor
.
popup
.
getItems
(
)
[
index
]
;
const
selectedElement
=
editor
.
popup
.
elements
.
get
(
selectedItem
)
;
ok
(
selectedElement
.
textContent
.
includes
(
postLabel
)
"
Selected
popup
element
contains
the
expected
post
-
label
"
)
;
const
swatchSpan
=
selectedElement
.
getElementsByClassName
(
"
autocomplete
-
swatch
autocomplete
-
colorswatch
"
)
;
if
(
colorSwatch
)
{
Assert
.
strictEqual
(
swatchSpan
.
length
1
"
Displayed
the
expected
color
swatch
"
)
;
const
color
=
new
colorUtils
.
CssColor
(
swatchSpan
[
0
]
.
style
.
backgroundColor
)
;
const
swatchColor
=
color
.
rgba
;
const
postColor
=
new
colorUtils
.
CssColor
(
postLabel
)
.
rgba
;
Assert
.
equal
(
swatchColor
postColor
"
Color
swatch
matches
postLabel
value
"
)
;
}
else
{
Assert
.
strictEqual
(
swatchSpan
.
length
0
"
As
expected
no
swatches
were
available
"
)
;
}
}
if
(
total
=
=
=
0
)
{
ok
(
!
(
editor
.
popup
&
&
editor
.
popup
.
isOpen
)
"
Popup
is
closed
"
)
;
}
else
{
ok
(
editor
.
popup
.
isOpen
"
Popup
is
open
"
)
;
const
popupItems
=
editor
.
popup
.
getItems
(
)
;
if
(
Array
.
isArray
(
items
)
)
{
Assert
.
deepEqual
(
popupItems
.
map
(
item
=
>
item
.
label
)
items
"
Suggestions
match
"
)
;
}
else
{
is
(
popupItems
.
length
total
"
Number
of
suggestions
match
"
+
(
popupItems
.
length
!
=
=
total
?
-
got
{
JSON
.
stringify
(
popupItems
.
map
(
item
=
>
item
.
label
)
)
}
:
"
"
)
)
;
}
is
(
editor
.
popup
.
selectedIndex
index
"
Expected
item
is
selected
"
)
;
}
}
