"
use
strict
"
;
const
{
Constructor
:
CC
}
=
Components
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
DEBUG_ALLOCATIONS
=
env
.
get
(
"
DEBUG_DEVTOOLS_ALLOCATIONS
"
)
;
if
(
DEBUG_ALLOCATIONS
)
{
const
{
DevToolsLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
loader
=
new
DevToolsLoader
(
{
invisibleToDebugger
:
true
}
)
;
const
{
allocationTracker
}
=
loader
.
require
(
"
devtools
/
shared
/
test
-
helpers
/
allocation
-
tracker
"
)
;
const
tracker
=
allocationTracker
(
{
watchAllGlobals
:
true
}
)
;
registerCleanupFunction
(
(
)
=
>
{
if
(
DEBUG_ALLOCATIONS
=
=
"
normal
"
)
{
tracker
.
logCount
(
)
;
}
else
if
(
DEBUG_ALLOCATIONS
=
=
"
verbose
"
)
{
tracker
.
logAllocationSites
(
)
;
}
tracker
.
stop
(
)
;
}
)
;
}
const
{
loader
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TabDescriptorFactory
}
=
require
(
"
devtools
/
client
/
framework
/
tab
-
descriptor
-
factory
"
)
;
const
{
CommandsFactory
}
=
require
(
"
devtools
/
shared
/
commands
/
commands
-
factory
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
let
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_COM
=
URL_ROOT
;
const
URL_ROOT_COM_SSL
=
URL_ROOT_SSL
;
const
URL_ROOT_ORG
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
org
/
"
)
;
const
URL_ROOT_ORG_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
org
/
"
)
;
const
URL_ROOT_NET
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
net
/
"
)
;
const
URL_ROOT_MOCHI_8888
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
try
{
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
"
this
)
;
}
catch
(
e
)
{
ok
(
false
"
MISSING
DEPENDENCY
ON
telemetry
-
test
-
helpers
.
js
\
n
"
+
"
Please
add
the
following
line
in
browser
.
ini
:
\
n
"
+
"
!
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
\
n
"
)
;
throw
e
;
}
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
function
testActorBootstrap
(
)
{
const
TEST_ACTOR_URL
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
test
-
actor
.
js
"
;
const
{
require
:
_require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
_require
(
TEST_ACTOR_URL
)
;
const
Services
=
_require
(
"
Services
"
)
;
const
actorRegistryObserver
=
subject
=
>
{
const
actorRegistry
=
subject
.
wrappedJSObject
;
actorRegistry
.
registerModule
(
TEST_ACTOR_URL
{
prefix
:
"
test
"
constructor
:
"
TestActor
"
type
:
{
target
:
true
}
}
)
;
}
;
Services
.
obs
.
addObserver
(
actorRegistryObserver
"
devtools
-
server
-
initialized
"
)
;
const
unloadListener
=
(
)
=
>
{
Services
.
cpmm
.
removeMessageListener
(
"
remove
-
devtools
-
testactor
-
observer
"
unloadListener
)
;
Services
.
obs
.
removeObserver
(
actorRegistryObserver
"
devtools
-
server
-
initialized
"
)
;
}
;
Services
.
cpmm
.
addMessageListener
(
"
remove
-
devtools
-
testactor
-
observer
"
unloadListener
)
;
}
const
testActorBootstrapScript
=
"
data
:
(
"
+
testActorBootstrap
+
"
)
(
)
"
;
Services
.
ppmm
.
loadProcessScript
(
testActorBootstrapScript
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
remove
-
devtools
-
testactor
-
observer
"
)
;
Services
.
ppmm
.
removeDelayedProcessScript
(
testActorBootstrapScript
)
;
}
)
;
async
function
getTestActor
(
toolbox
)
{
const
inspector
=
await
toolbox
.
loadTool
(
"
inspector
"
)
;
const
testActor
=
await
toolbox
.
target
.
getFront
(
"
test
"
)
;
testActor
.
highlighter
=
(
)
=
>
{
return
inspector
.
highlighters
.
getActiveHighlighter
(
"
BoxModelHighlighter
"
)
;
}
;
return
testActor
;
}
async
function
getTestActorWithoutToolbox
(
tab
)
{
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
const
{
DevToolsClient
}
=
require
(
"
devtools
/
client
/
devtools
-
client
"
)
;
DevToolsServer
.
init
(
)
;
DevToolsServer
.
registerAllActors
(
)
;
const
client
=
new
DevToolsClient
(
DevToolsServer
.
connectPipe
(
)
)
;
await
client
.
connect
(
)
;
const
descriptor
=
await
client
.
mainRoot
.
getTab
(
{
tab
}
)
;
const
targetFront
=
await
descriptor
.
getTarget
(
)
;
return
targetFront
.
getFront
(
"
test
"
)
;
}
waitForExplicitFinish
(
)
;
var
EXPECTED_DTU_ASSERT_FAILURE_COUNT
=
0
;
registerCleanupFunction
(
function
(
)
{
if
(
DevToolsUtils
.
assertionFailureCount
!
=
=
EXPECTED_DTU_ASSERT_FAILURE_COUNT
)
{
ok
(
false
"
Should
have
had
the
expected
number
of
DevToolsUtils
.
assert
(
)
failures
.
"
+
"
Expected
"
+
EXPECTED_DTU_ASSERT_FAILURE_COUNT
+
"
got
"
+
DevToolsUtils
.
assertionFailureCount
)
;
}
}
)
;
const
ConsoleObserver
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
observe
:
function
(
subject
)
{
const
message
=
subject
.
wrappedJSObject
.
arguments
[
0
]
;
if
(
message
&
&
/
Failed
propType
/
.
test
(
message
.
toString
(
)
)
)
{
ok
(
false
message
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
javascript
.
options
.
asyncstack_capture_debuggee_only
"
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleEnabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleHeight
"
)
;
Services
.
prefs
.
clearUserPref
(
"
javascript
.
options
.
asyncstack_capture_debuggee_only
"
)
;
}
)
;
var
{
BrowserConsoleManager
}
=
require
(
"
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
"
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
const
browserConsole
=
BrowserConsoleManager
.
getBrowserConsole
(
)
;
if
(
browserConsole
)
{
await
safeCloseBrowserConsole
(
{
clearOutput
:
true
}
)
;
}
while
(
gBrowser
.
tabs
.
length
>
1
)
{
await
closeTabAndToolbox
(
gBrowser
.
selectedTab
)
;
}
await
waitForTick
(
)
;
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
ok
(
!
DevToolsServer
.
hasConnection
(
)
"
The
main
process
DevToolsServer
has
no
pending
connection
when
the
test
ends
"
)
;
if
(
DevToolsServer
.
hasConnection
(
)
)
{
for
(
const
conn
of
Object
.
values
(
DevToolsServer
.
_connections
)
)
{
conn
.
close
(
)
;
}
}
}
)
;
async
function
safeCloseBrowserConsole
(
{
clearOutput
=
false
}
=
{
}
)
{
const
hud
=
BrowserConsoleManager
.
getBrowserConsole
(
)
;
if
(
!
hud
)
{
return
;
}
if
(
clearOutput
)
{
info
(
"
Clear
the
browser
console
output
"
)
;
const
{
ui
}
=
hud
;
const
promises
=
[
ui
.
once
(
"
messages
-
cleared
"
)
]
;
if
(
ui
.
outputNode
.
querySelector
(
"
.
object
-
inspector
"
)
)
{
promises
.
push
(
ui
.
once
(
"
fronts
-
released
"
)
)
;
}
ui
.
clearOutput
(
true
)
;
await
Promise
.
all
(
promises
)
;
info
(
"
Browser
console
cleared
"
)
;
}
info
(
"
Wait
for
all
Browser
Console
targets
to
be
attached
"
)
;
await
Promise
.
race
(
[
waitForAllTargetsToBeAttached
(
hud
.
targetList
)
wait
(
1000
)
]
)
;
hud
.
targetList
.
destroy
(
)
;
info
(
"
Close
the
Browser
Console
"
)
;
await
BrowserConsoleManager
.
closeBrowserConsole
(
)
;
info
(
"
Browser
Console
closed
"
)
;
}
function
waitForAllTargetsToBeAttached
(
targetList
)
{
return
Promise
.
allSettled
(
targetList
.
getAllTargets
(
targetList
.
ALL_TYPES
)
.
map
(
target
=
>
target
.
_onThreadInitialized
)
)
;
}
var
addTab
=
async
function
(
url
options
=
{
}
)
{
info
(
"
Adding
a
new
tab
with
URL
:
"
+
url
)
;
const
{
background
=
false
userContextId
preferredRemoteType
waitForLoad
=
true
}
=
options
;
const
{
gBrowser
}
=
options
.
window
?
options
.
window
:
window
;
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
url
{
userContextId
preferredRemoteType
}
)
;
if
(
!
background
)
{
gBrowser
.
selectedTab
=
tab
;
}
if
(
waitForLoad
)
{
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
info
(
"
Tab
added
and
finished
loading
"
)
;
}
else
{
info
(
"
Tab
added
"
)
;
}
return
tab
;
}
;
var
removeTab
=
async
function
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
const
{
gBrowser
}
=
tab
.
ownerDocument
.
defaultView
;
const
onClose
=
once
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
gBrowser
.
removeTab
(
tab
)
;
await
onClose
;
info
(
"
Tab
removed
and
finished
closing
"
)
;
}
;
var
refreshTab
=
async
function
(
tab
=
gBrowser
.
selectedTab
)
{
info
(
"
Refreshing
tab
.
"
)
;
const
finished
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
gBrowser
.
reloadTab
(
tab
)
;
await
finished
;
info
(
"
Tab
finished
refreshing
.
"
)
;
}
;
async
function
navigateTo
(
uri
{
isErrorPage
=
false
}
=
{
}
)
{
const
toolbox
=
await
gDevTools
.
getToolboxForTab
(
gBrowser
.
selectedTab
)
;
const
target
=
toolbox
.
target
;
const
onTargetSwitched
=
toolbox
.
commands
.
targetCommand
.
once
(
"
switched
-
target
"
)
;
const
onNavigate
=
target
.
once
(
"
navigate
"
)
;
const
targetFollowsWindowLifecycle
=
target
.
targetForm
.
followWindowGlobalLifeCycle
;
const
onPanelReloaded
=
waitForPanelReload
(
toolbox
.
currentToolId
toolbox
.
target
toolbox
.
getCurrentPanel
(
)
)
;
info
(
Load
document
"
{
uri
}
"
)
;
const
browser
=
gBrowser
.
selectedBrowser
;
const
currentPID
=
browser
.
browsingContext
.
currentWindowGlobal
.
osPid
;
const
onBrowserLoaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
null
isErrorPage
)
;
BrowserTestUtils
.
loadURI
(
browser
uri
)
;
info
(
Waiting
for
page
to
be
loaded
)
;
await
onBrowserLoaded
;
info
(
page
loaded
)
;
const
switchedToAnotherProcess
=
currentPID
!
=
=
browser
.
browsingContext
.
currentWindowGlobal
.
osPid
;
if
(
onPanelReloaded
)
{
info
(
Waiting
for
{
toolbox
.
currentToolId
}
to
be
reloaded
)
;
await
onPanelReloaded
(
)
;
info
(
panel
reloaded
)
;
}
if
(
switchedToAnotherProcess
|
|
targetFollowsWindowLifecycle
)
{
info
(
Waiting
for
target
switch
)
;
await
onTargetSwitched
;
info
(
switched
-
target
emitted
)
;
}
else
{
info
(
Waiting
for
target
'
navigate
'
event
)
;
await
onNavigate
;
info
(
'
navigate
'
emitted
)
;
}
}
async
function
createAndAttachTargetForTab
(
tab
)
{
info
(
"
Creating
and
attaching
to
a
local
tab
target
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
const
target
=
commands
.
targetCommand
.
targetFront
;
await
target
.
attach
(
)
;
return
target
;
}
function
waitForPanelReload
(
currentToolId
target
panel
)
{
if
(
currentToolId
=
=
"
inspector
"
)
{
const
inspector
=
panel
;
const
markuploaded
=
inspector
.
once
(
"
markuploaded
"
)
;
const
onNewRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
const
onUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
const
onReloaded
=
inspector
.
once
(
"
reloaded
"
)
;
return
async
function
(
)
{
info
(
"
Waiting
for
markup
view
to
load
after
navigation
.
"
)
;
await
markuploaded
;
info
(
"
Waiting
for
new
root
.
"
)
;
await
onNewRoot
;
info
(
"
Waiting
for
inspector
to
update
after
new
-
root
event
.
"
)
;
await
onUpdated
;
info
(
"
Waiting
for
inspector
updates
after
page
reload
"
)
;
await
onReloaded
;
}
;
}
else
if
(
currentToolId
=
=
"
netmonitor
"
)
{
const
monitor
=
panel
;
const
onReloaded
=
monitor
.
once
(
"
reloaded
"
)
;
return
async
function
(
)
{
info
(
"
Waiting
for
netmonitor
updates
after
page
reload
"
)
;
await
onReloaded
;
}
;
}
return
null
;
}
function
isFissionEnabled
(
)
{
return
SpecialPowers
.
useRemoteSubframes
;
}
var
openInspectorForURL
=
async
function
(
url
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
const
{
inspector
toolbox
testActor
}
=
await
openInspector
(
hostType
)
;
return
{
tab
inspector
toolbox
testActor
}
;
}
;
async
function
getActiveInspector
(
)
{
const
toolbox
=
await
gDevTools
.
getToolboxForTab
(
gBrowser
.
selectedTab
)
;
return
toolbox
.
getPanel
(
"
inspector
"
)
;
}
function
synthesizeKeyShortcut
(
key
target
)
{
const
window
=
Services
.
appShell
.
hiddenDOMWindow
;
const
shortcut
=
KeyShortcuts
.
parseElectronKey
(
window
key
)
;
const
keyEvent
=
{
altKey
:
shortcut
.
alt
ctrlKey
:
shortcut
.
ctrl
metaKey
:
shortcut
.
meta
shiftKey
:
shortcut
.
shift
}
;
if
(
shortcut
.
keyCode
)
{
keyEvent
.
keyCode
=
shortcut
.
keyCode
;
}
info
(
"
Synthesizing
key
shortcut
:
"
+
key
)
;
EventUtils
.
synthesizeKey
(
shortcut
.
key
|
|
"
"
keyEvent
target
)
;
}
var
waitForTime
=
DevToolsUtils
.
waitForTime
;
function
waitForTick
(
)
{
return
new
Promise
(
resolve
=
>
DevToolsUtils
.
executeSoon
(
resolve
)
)
;
}
function
wait
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
ms
)
;
info
(
"
Waiting
"
+
ms
/
1000
+
"
seconds
.
"
)
;
}
)
;
}
async
function
waitFor
(
condition
message
=
"
"
interval
=
10
maxTries
=
500
)
{
try
{
const
value
=
await
BrowserTestUtils
.
waitForCondition
(
condition
message
interval
maxTries
)
;
return
value
;
}
catch
(
e
)
{
const
errorMessage
=
"
Failed
waitFor
(
)
:
"
+
message
+
"
\
n
"
+
"
Failed
condition
:
"
+
condition
+
"
\
n
"
;
throw
new
Error
(
errorMessage
)
;
}
}
function
waitForNEvents
(
target
eventName
numTimes
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
count
=
0
;
return
new
Promise
(
resolve
=
>
{
for
(
const
[
add
remove
]
of
[
[
"
on
"
"
off
"
]
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
addMessageListener
"
"
removeMessageListener
"
]
]
)
{
if
(
add
in
target
&
&
remove
in
target
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
args
)
{
if
(
typeof
info
=
=
=
"
function
"
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
}
if
(
+
+
count
=
=
numTimes
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
resolve
(
.
.
.
args
)
;
}
}
useCapture
)
;
break
;
}
}
}
)
;
}
function
waitForDOM
(
target
selector
expectedLength
=
1
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
MutationObserver
(
mutations
=
>
{
mutations
.
forEach
(
mutation
=
>
{
const
elements
=
mutation
.
target
.
querySelectorAll
(
selector
)
;
if
(
elements
.
length
=
=
=
expectedLength
)
{
observer
.
disconnect
(
)
;
resolve
(
elements
)
;
}
}
)
;
}
)
;
observer
.
observe
(
target
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
;
}
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
return
waitForNEvents
(
target
eventName
1
useCapture
)
;
}
function
loadHelperScript
(
filePath
)
{
const
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
var
openToolboxForTab
=
async
function
(
tab
toolId
hostType
)
{
info
(
"
Opening
the
toolbox
"
)
;
let
toolbox
;
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
toolbox
)
{
if
(
!
toolId
|
|
(
toolId
&
&
toolbox
.
getPanel
(
toolId
)
)
)
{
info
(
"
Toolbox
is
already
opened
"
)
;
return
toolbox
;
}
}
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
hostType
}
)
;
await
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
toolbox
.
win
)
)
;
info
(
"
Toolbox
opened
and
focused
"
)
;
return
toolbox
;
}
;
var
openNewTabAndToolbox
=
async
function
(
url
toolId
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
return
openToolboxForTab
(
tab
toolId
hostType
)
;
}
;
var
closeTabAndToolbox
=
async
function
(
tab
=
gBrowser
.
selectedTab
)
{
if
(
TabDescriptorFactory
.
isKnownTab
(
tab
)
)
{
await
gDevTools
.
closeToolboxForTab
(
tab
)
;
}
await
removeTab
(
tab
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
;
var
closeToolboxAndTab
=
async
function
(
toolbox
)
{
await
toolbox
.
destroy
(
)
;
await
removeTab
(
gBrowser
.
selectedTab
)
;
}
;
async
function
getSupportedToolIds
(
tab
)
{
info
(
"
Getting
the
entire
list
of
tools
supported
in
this
tab
"
)
;
let
shouldDestroyToolbox
=
false
;
let
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
!
toolbox
)
{
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
)
;
shouldDestroyToolbox
=
true
;
}
const
toolIds
=
gDevTools
.
getToolDefinitionArray
(
)
.
filter
(
def
=
>
def
.
isTargetSupported
(
toolbox
.
target
)
)
.
map
(
def
=
>
def
.
id
)
;
if
(
shouldDestroyToolbox
)
{
await
toolbox
.
destroy
(
)
;
}
return
toolIds
;
}
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
async
function
asyncWaitUntil
(
predicate
interval
=
10
)
{
let
success
=
await
predicate
(
)
;
while
(
!
success
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
interval
)
)
;
success
=
await
predicate
(
)
;
}
}
function
waitForContextMenu
(
popup
button
onShown
onHidden
)
{
return
new
Promise
(
resolve
=
>
{
function
onPopupShown
(
)
{
info
(
"
onPopupShown
"
)
;
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
onShown
&
&
onShown
(
)
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
popup
.
hidePopup
(
)
)
;
}
function
onPopupHidden
(
)
{
info
(
"
onPopupHidden
"
)
;
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
onHidden
&
&
onHidden
(
)
;
resolve
(
popup
)
;
}
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
info
(
"
wait
for
the
context
menu
to
open
"
)
;
synthesizeContextMenuEvent
(
button
)
;
}
)
;
}
function
synthesizeContextMenuEvent
(
el
)
{
el
.
scrollIntoView
(
)
;
const
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
EventUtils
.
synthesizeMouse
(
el
5
2
eventDetails
el
.
ownerDocument
.
defaultView
)
;
}
function
waitForClipboardPromise
(
setup
expected
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SimpleTest
.
waitForClipboard
(
expected
setup
resolve
reject
)
;
}
)
;
}
function
pushPref
(
preferenceName
value
)
{
const
options
=
{
set
:
[
[
preferenceName
value
]
]
}
;
return
SpecialPowers
.
pushPrefEnv
(
options
)
;
}
function
lookupPath
(
obj
path
)
{
const
segments
=
path
.
split
(
"
.
"
)
;
return
segments
.
reduce
(
(
prev
current
)
=
>
prev
[
current
]
obj
)
;
}
var
closeToolbox
=
async
function
(
)
{
await
gDevTools
.
closeToolboxForTab
(
gBrowser
.
selectedTab
)
;
}
;
function
emptyClipboard
(
)
{
const
clipboard
=
Services
.
clipboard
;
clipboard
.
emptyClipboard
(
clipboard
.
kGlobalClipboard
)
;
}
function
isWindows
(
)
{
return
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
;
}
function
waitForTitleChange
(
toolbox
)
{
return
new
Promise
(
resolve
=
>
{
toolbox
.
topWindow
.
addEventListener
(
"
message
"
function
onmessage
(
event
)
{
if
(
event
.
data
.
name
=
=
"
set
-
host
-
title
"
)
{
toolbox
.
topWindow
.
removeEventListener
(
"
message
"
onmessage
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
function
createTestHTTPServer
(
)
{
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
server
=
new
HttpServer
(
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
await
new
Promise
(
resolve
=
>
server
.
stop
(
resolve
)
)
;
}
)
;
server
.
start
(
-
1
)
;
return
server
;
}
async
function
registerActorInContentProcess
(
url
options
)
{
function
convertChromeToFile
(
uri
)
{
return
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
.
convertChromeURL
(
Services
.
io
.
newURI
(
uri
)
)
.
spec
;
}
url
=
url
.
startsWith
(
"
chrome
:
/
/
mochitests
"
)
?
convertChromeToFile
(
url
)
:
url
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
url
options
}
]
args
=
>
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
ActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
actor
-
registry
"
)
;
ActorRegistry
.
registerModule
(
args
.
url
args
.
options
)
;
}
)
;
}
async
function
moveWindowTo
(
win
left
top
)
{
left
=
Math
.
max
(
win
.
screen
.
availLeft
left
)
;
left
=
Math
.
min
(
win
.
screen
.
width
left
)
;
top
=
Math
.
max
(
win
.
screen
.
availTop
top
)
;
top
=
Math
.
min
(
win
.
screen
.
height
top
)
;
info
(
Moving
window
to
{
{
left
}
{
top
}
}
)
;
win
.
moveTo
(
left
top
)
;
info
(
"
Wait
for
window
screenLeft
and
screenTop
to
be
updated
"
)
;
return
waitUntil
(
(
)
=
>
win
.
screenLeft
=
=
=
left
&
&
win
.
screenTop
=
=
=
top
)
;
}
function
getCurrentTestFilePath
(
)
{
return
gTestPath
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
"
"
)
;
}
function
waitForNextResource
(
resourceWatcher
resourceType
{
ignoreExistingResources
=
false
predicate
}
=
{
}
)
{
predicate
=
predicate
|
|
(
resource
=
>
!
!
resource
)
;
return
new
Promise
(
resolve
=
>
{
const
onAvailable
=
resources
=
>
{
const
matchingResource
=
resources
.
find
(
resource
=
>
predicate
(
resource
)
)
;
if
(
matchingResource
)
{
resolve
(
matchingResource
)
;
resourceWatcher
.
unwatchResources
(
[
resourceType
]
{
onAvailable
}
)
;
}
}
;
resourceWatcher
.
watchResources
(
[
resourceType
]
{
ignoreExistingResources
onAvailable
}
)
;
}
)
;
}
async
function
unregisterAllServiceWorkers
(
client
)
{
info
(
"
Wait
until
all
workers
have
a
valid
registrationFront
"
)
;
let
workers
;
await
asyncWaitUntil
(
async
function
(
)
{
workers
=
await
client
.
mainRoot
.
listAllWorkers
(
)
;
const
allWorkersRegistered
=
workers
.
service
.
every
(
worker
=
>
!
!
worker
.
registrationFront
)
;
return
allWorkersRegistered
;
}
)
;
info
(
"
Unregister
all
service
workers
"
)
;
const
promises
=
[
]
;
for
(
const
worker
of
workers
.
service
)
{
promises
.
push
(
worker
.
registrationFront
.
unregister
(
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
function
colorAt
(
image
x
y
)
{
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
canvas
=
document
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
canvas
.
width
=
image
.
width
;
canvas
.
height
=
image
.
height
;
const
context
=
canvas
.
getContext
(
"
2d
"
)
;
context
.
drawImage
(
image
0
0
image
.
width
image
.
height
)
;
const
[
r
g
b
]
=
context
.
getImageData
(
x
y
1
1
)
.
data
;
return
{
r
g
b
}
;
}
let
allDownloads
=
[
]
;
async
function
waitUntilScreenshot
(
)
{
const
{
Downloads
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
const
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
return
new
Promise
(
function
(
resolve
)
{
const
view
=
{
onDownloadAdded
:
async
download
=
>
{
await
download
.
whenSucceeded
(
)
;
if
(
allDownloads
.
includes
(
download
)
)
{
return
;
}
allDownloads
.
push
(
download
)
;
resolve
(
download
.
target
.
path
)
;
list
.
removeView
(
view
)
;
}
}
;
list
.
addView
(
view
)
;
}
)
;
}
async
function
resetDownloads
(
)
{
info
(
"
Reset
downloads
"
)
;
const
{
Downloads
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
const
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
const
downloads
=
await
publicList
.
getAll
(
)
;
for
(
const
download
of
downloads
)
{
publicList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
allDownloads
=
[
]
;
}
async
function
takeNodeScreenshot
(
inspector
)
{
registerCleanupFunction
(
resetDownloads
)
;
info
(
"
Call
screenshotNode
(
)
and
wait
until
the
screenshot
is
found
in
the
Downloads
"
)
;
const
whenScreenshotSucceeded
=
waitUntilScreenshot
(
)
;
inspector
.
screenshotNode
(
)
;
const
filePath
=
await
whenScreenshotSucceeded
;
info
(
"
Create
an
image
using
the
downloaded
fileas
source
"
)
;
const
image
=
new
Image
(
)
;
const
onImageLoad
=
once
(
image
"
load
"
)
;
image
.
src
=
OS
.
Path
.
toFileURI
(
filePath
)
;
await
onImageLoad
;
info
(
"
Remove
the
downloaded
screenshot
file
"
)
;
await
OS
.
File
.
remove
(
filePath
)
;
info
(
"
Wait
for
one
second
to
make
sure
future
screenshots
will
use
a
different
name
"
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
1000
)
)
;
return
image
;
}
async
function
assertSingleColorScreenshotImage
(
image
width
height
{
r
g
b
}
)
{
info
(
Assert
{
image
.
src
}
content
)
;
const
ratio
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
content
.
wrappedJSObject
.
devicePixelRatio
)
;
is
(
image
.
width
ratio
*
width
node
screenshot
has
the
expected
width
(
dpr
=
{
ratio
}
)
)
;
is
(
image
.
height
height
*
ratio
node
screenshot
has
the
expected
height
(
dpr
=
{
ratio
}
)
)
;
const
color
=
colorAt
(
image
0
0
)
;
is
(
color
.
r
r
"
node
screenshot
has
the
expected
red
component
"
)
;
is
(
color
.
g
g
"
node
screenshot
has
the
expected
green
component
"
)
;
is
(
color
.
b
b
"
node
screenshot
has
the
expected
blue
component
"
)
;
}
function
checkImageColorAt
(
{
image
x
=
0
y
expectedColor
label
}
)
{
const
color
=
colorAt
(
image
x
y
)
;
is
(
rgb
(
{
Object
.
values
(
color
)
.
join
(
"
"
)
}
)
expectedColor
label
)
;
}
function
checkPoolChildrenSize
(
parentPool
typeName
expected
)
{
const
children
=
[
.
.
.
parentPool
.
poolChildren
(
)
]
;
const
childrenByType
=
children
.
filter
(
pool
=
>
pool
.
typeName
=
=
=
typeName
)
;
is
(
childrenByType
.
length
expected
{
parentPool
.
actorID
}
should
have
{
expected
}
children
of
type
{
typeName
}
)
;
}
function
waitForDispatch
(
store
actionType
repeat
=
1
)
{
let
count
=
0
;
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
{
const
isDone
=
!
action
.
status
|
|
action
.
status
=
=
=
"
done
"
|
|
action
.
status
=
=
=
"
error
"
;
if
(
action
.
type
=
=
=
actionType
&
&
isDone
&
&
+
+
count
=
=
repeat
)
{
return
true
;
}
return
false
;
}
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
