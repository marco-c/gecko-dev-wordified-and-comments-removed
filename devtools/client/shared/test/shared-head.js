"
use
strict
"
;
const
{
Constructor
:
CC
}
=
Components
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
DEBUG_ALLOCATIONS
=
env
.
get
(
"
DEBUG_DEVTOOLS_ALLOCATIONS
"
)
;
if
(
DEBUG_ALLOCATIONS
)
{
const
{
DevToolsLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
loader
=
new
DevToolsLoader
(
{
invisibleToDebugger
:
true
}
)
;
const
{
allocationTracker
}
=
loader
.
require
(
"
devtools
/
shared
/
test
-
helpers
/
allocation
-
tracker
"
)
;
const
tracker
=
allocationTracker
(
{
watchAllGlobals
:
true
}
)
;
registerCleanupFunction
(
(
)
=
>
{
if
(
DEBUG_ALLOCATIONS
=
=
"
normal
"
)
{
tracker
.
logCount
(
)
;
}
else
if
(
DEBUG_ALLOCATIONS
=
=
"
verbose
"
)
{
tracker
.
logAllocationSites
(
)
;
}
tracker
.
stop
(
)
;
}
)
;
}
const
{
loader
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TabDescriptorFactory
}
=
require
(
"
devtools
/
client
/
framework
/
tab
-
descriptor
-
factory
"
)
;
const
{
CommandsFactory
}
=
require
(
"
devtools
/
shared
/
commands
/
commands
-
factory
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
devtools
/
client
/
responsive
/
manager
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_COM
=
URL_ROOT
;
const
URL_ROOT_COM_SSL
=
URL_ROOT_SSL
;
const
URL_ROOT_ORG
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
org
/
"
)
;
const
URL_ROOT_ORG_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
org
/
"
)
;
const
URL_ROOT_NET
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
net
/
"
)
;
const
URL_ROOT_MOCHI_8888
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
const
TARGET_SWITCHING_PREF
=
"
devtools
.
target
-
switching
.
server
.
enabled
"
;
try
{
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
"
this
)
;
}
catch
(
e
)
{
ok
(
false
"
MISSING
DEPENDENCY
ON
telemetry
-
test
-
helpers
.
js
\
n
"
+
"
Please
add
the
following
line
in
browser
.
ini
:
\
n
"
+
"
!
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
\
n
"
)
;
throw
e
;
}
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
function
highlighterTestActorBootstrap
(
)
{
const
HIGHLIGHTER_TEST_ACTOR_URL
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
highlighter
-
test
-
actor
.
js
"
;
const
{
require
:
_require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
_require
(
HIGHLIGHTER_TEST_ACTOR_URL
)
;
const
Services
=
_require
(
"
Services
"
)
;
const
actorRegistryObserver
=
subject
=
>
{
const
actorRegistry
=
subject
.
wrappedJSObject
;
actorRegistry
.
registerModule
(
HIGHLIGHTER_TEST_ACTOR_URL
{
prefix
:
"
highlighterTest
"
constructor
:
"
HighlighterTestActor
"
type
:
{
target
:
true
}
}
)
;
}
;
Services
.
obs
.
addObserver
(
actorRegistryObserver
"
devtools
-
server
-
initialized
"
)
;
const
unloadListener
=
(
)
=
>
{
Services
.
cpmm
.
removeMessageListener
(
"
remove
-
devtools
-
testactor
-
observer
"
unloadListener
)
;
Services
.
obs
.
removeObserver
(
actorRegistryObserver
"
devtools
-
server
-
initialized
"
)
;
}
;
Services
.
cpmm
.
addMessageListener
(
"
remove
-
devtools
-
testactor
-
observer
"
unloadListener
)
;
}
const
highlighterTestActorBootstrapScript
=
"
data
:
(
"
+
highlighterTestActorBootstrap
+
"
)
(
)
"
;
Services
.
ppmm
.
loadProcessScript
(
highlighterTestActorBootstrapScript
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
remove
-
devtools
-
testactor
-
observer
"
)
;
Services
.
ppmm
.
removeDelayedProcessScript
(
highlighterTestActorBootstrapScript
)
;
}
)
;
async
function
getHighlighterTestFront
(
toolbox
{
findTarget
}
=
{
}
)
{
const
inspector
=
await
toolbox
.
loadTool
(
"
inspector
"
)
;
const
target
=
findTarget
?
toolbox
.
commands
.
targetCommand
.
getAllTargets
(
[
toolbox
.
commands
.
targetCommand
.
TYPES
.
FRAME
]
)
.
find
(
t
=
>
findTarget
(
t
)
)
:
toolbox
.
target
;
const
highlighterTestFront
=
await
target
.
getFront
(
"
highlighterTest
"
)
;
highlighterTestFront
.
highlighter
=
(
)
=
>
{
return
inspector
.
highlighters
.
getActiveHighlighter
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
;
return
highlighterTestFront
;
}
async
function
getHighlighterTestFrontWithoutToolbox
(
tab
)
{
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
const
targetFront
=
commands
.
targetCommand
.
targetFront
;
return
targetFront
.
getFront
(
"
highlighterTest
"
)
;
}
waitForExplicitFinish
(
)
;
var
EXPECTED_DTU_ASSERT_FAILURE_COUNT
=
0
;
registerCleanupFunction
(
function
(
)
{
if
(
DevToolsUtils
.
assertionFailureCount
!
=
=
EXPECTED_DTU_ASSERT_FAILURE_COUNT
)
{
ok
(
false
"
Should
have
had
the
expected
number
of
DevToolsUtils
.
assert
(
)
failures
.
"
+
"
Expected
"
+
EXPECTED_DTU_ASSERT_FAILURE_COUNT
+
"
got
"
+
DevToolsUtils
.
assertionFailureCount
)
;
}
}
)
;
const
ConsoleObserver
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIObserver
"
]
)
observe
:
function
(
subject
)
{
const
message
=
subject
.
wrappedJSObject
.
arguments
[
0
]
;
if
(
message
&
&
/
Failed
propType
/
.
test
(
message
.
toString
(
)
)
)
{
ok
(
false
message
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
javascript
.
options
.
asyncstack_capture_debuggee_only
"
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleEnabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleHeight
"
)
;
Services
.
prefs
.
clearUserPref
(
"
javascript
.
options
.
asyncstack_capture_debuggee_only
"
)
;
}
)
;
var
{
BrowserConsoleManager
}
=
require
(
"
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
"
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
const
browserConsole
=
BrowserConsoleManager
.
getBrowserConsole
(
)
;
if
(
browserConsole
)
{
await
safeCloseBrowserConsole
(
{
clearOutput
:
true
}
)
;
}
while
(
gBrowser
.
tabs
.
length
>
1
)
{
await
closeTabAndToolbox
(
gBrowser
.
selectedTab
)
;
}
await
waitForTick
(
)
;
const
{
DevToolsServer
}
=
require
(
"
devtools
/
server
/
devtools
-
server
"
)
;
ok
(
!
DevToolsServer
.
hasConnection
(
)
"
The
main
process
DevToolsServer
has
no
pending
connection
when
the
test
ends
"
)
;
if
(
DevToolsServer
.
hasConnection
(
)
)
{
for
(
const
conn
of
Object
.
values
(
DevToolsServer
.
_connections
)
)
{
conn
.
close
(
)
;
}
}
}
)
;
async
function
safeCloseBrowserConsole
(
{
clearOutput
=
false
}
=
{
}
)
{
const
hud
=
BrowserConsoleManager
.
getBrowserConsole
(
)
;
if
(
!
hud
)
{
return
;
}
if
(
clearOutput
)
{
info
(
"
Clear
the
browser
console
output
"
)
;
const
{
ui
}
=
hud
;
const
promises
=
[
ui
.
once
(
"
messages
-
cleared
"
)
]
;
if
(
ui
.
outputNode
.
querySelector
(
"
.
object
-
inspector
"
)
)
{
promises
.
push
(
ui
.
once
(
"
fronts
-
released
"
)
)
;
}
ui
.
clearOutput
(
true
)
;
await
Promise
.
all
(
promises
)
;
info
(
"
Browser
console
cleared
"
)
;
}
info
(
"
Wait
for
all
Browser
Console
targets
to
be
attached
"
)
;
await
Promise
.
race
(
[
waitForAllTargetsToBeAttached
(
hud
.
commands
.
targetCommand
)
wait
(
1000
)
]
)
;
info
(
"
Close
the
Browser
Console
"
)
;
await
BrowserConsoleManager
.
closeBrowserConsole
(
)
;
info
(
"
Browser
Console
closed
"
)
;
}
function
waitForAllTargetsToBeAttached
(
targetCommand
)
{
return
Promise
.
allSettled
(
targetCommand
.
getAllTargets
(
targetCommand
.
ALL_TYPES
)
.
map
(
target
=
>
target
.
_onThreadInitialized
)
)
;
}
var
addTab
=
async
function
(
url
options
=
{
}
)
{
info
(
"
Adding
a
new
tab
with
URL
:
"
+
url
)
;
const
{
background
=
false
userContextId
preferredRemoteType
waitForLoad
=
true
}
=
options
;
const
{
gBrowser
}
=
options
.
window
?
options
.
window
:
window
;
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
url
{
userContextId
preferredRemoteType
}
)
;
if
(
!
background
)
{
gBrowser
.
selectedTab
=
tab
;
}
if
(
waitForLoad
)
{
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
waitForPresShell
(
tab
.
linkedBrowser
)
;
info
(
"
Tab
added
and
finished
loading
"
)
;
}
else
{
info
(
"
Tab
added
"
)
;
}
return
tab
;
}
;
var
removeTab
=
async
function
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
const
{
gBrowser
}
=
tab
.
ownerDocument
.
defaultView
;
const
onClose
=
once
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
gBrowser
.
removeTab
(
tab
)
;
await
onClose
;
info
(
"
Tab
removed
and
finished
closing
"
)
;
}
;
async
function
reloadBrowser
(
{
browser
=
gBrowser
.
selectedBrowser
isErrorPage
=
false
}
=
{
}
)
{
return
navigateTo
(
browser
.
currentURI
.
spec
{
browser
isErrorPage
}
)
;
}
async
function
navigateTo
(
uri
{
browser
=
gBrowser
.
selectedBrowser
isErrorPage
=
false
}
=
{
}
)
{
const
waitForDevToolsReload
=
await
watchForDevToolsReload
(
browser
{
isErrorPage
}
)
;
uri
=
uri
.
replaceAll
(
"
\
n
"
"
"
)
;
info
(
Navigating
to
"
{
uri
}
"
)
;
const
onBrowserLoaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
loadedUrl
=
>
{
return
loadedUrl
=
=
=
uri
|
|
decodeURI
(
loadedUrl
)
=
=
=
uri
;
}
isErrorPage
)
;
if
(
uri
=
=
=
browser
.
currentURI
.
spec
)
{
gBrowser
.
reloadTab
(
gBrowser
.
getTabForBrowser
(
browser
)
)
;
}
else
{
BrowserTestUtils
.
loadURI
(
browser
uri
)
;
}
info
(
Waiting
for
page
to
be
loaded
)
;
await
onBrowserLoaded
;
info
(
page
loaded
)
;
await
waitForDevToolsReload
(
)
;
}
async
function
watchForDevToolsReload
(
browser
{
isErrorPage
=
false
}
=
{
}
)
{
const
waitForToolboxReload
=
await
watchForToolboxReload
(
browser
{
isErrorPage
}
)
;
const
waitForResponsiveReload
=
await
watchForResponsiveReload
(
browser
{
isErrorPage
}
)
;
return
async
function
(
)
{
info
(
"
Wait
for
the
toolbox
to
reload
"
)
;
await
waitForToolboxReload
(
)
;
info
(
"
Wait
for
Responsive
UI
to
reload
"
)
;
await
waitForResponsiveReload
(
)
;
}
;
}
async
function
watchForToolboxReload
(
browser
{
isErrorPage
}
=
{
}
)
{
const
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
const
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
!
toolbox
)
{
return
function
(
)
{
}
;
}
const
currentToolId
=
toolbox
.
currentToolId
;
const
panel
=
toolbox
.
getCurrentPanel
(
)
;
const
waitForCurrentPanelReload
=
watchForPanelReload
(
currentToolId
panel
)
;
const
waitForToolboxCommandsReload
=
await
watchForCommandsReload
(
toolbox
.
commands
{
isErrorPage
}
)
;
const
checkTargetSwitching
=
await
watchForTargetSwitching
(
toolbox
.
commands
browser
)
;
return
async
function
(
)
{
const
isTargetSwitching
=
checkTargetSwitching
(
)
;
info
(
Waiting
for
toolbox
commands
to
be
reloaded
)
;
await
waitForToolboxCommandsReload
(
isTargetSwitching
)
;
if
(
waitForCurrentPanelReload
)
{
info
(
Waiting
for
{
toolbox
.
currentToolId
}
to
be
reloaded
)
;
await
waitForCurrentPanelReload
(
)
;
info
(
panel
reloaded
)
;
}
}
;
}
async
function
watchForResponsiveReload
(
browser
{
isErrorPage
}
=
{
}
)
{
const
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
const
ui
=
ResponsiveUIManager
.
getResponsiveUIForTab
(
tab
)
;
if
(
!
ui
)
{
return
function
(
)
{
}
;
}
const
onResponsiveTargetSwitch
=
ui
.
once
(
"
responsive
-
ui
-
target
-
switch
-
done
"
)
;
const
waitForResponsiveCommandsReload
=
await
watchForCommandsReload
(
ui
.
commands
{
isErrorPage
}
)
;
const
checkTargetSwitching
=
await
watchForTargetSwitching
(
ui
.
commands
browser
)
;
return
async
function
(
)
{
const
isTargetSwitching
=
checkTargetSwitching
(
)
;
info
(
Waiting
for
responsive
ui
commands
to
be
reloaded
)
;
await
waitForResponsiveCommandsReload
(
isTargetSwitching
)
;
if
(
isTargetSwitching
)
{
await
onResponsiveTargetSwitch
;
}
}
;
}
function
watchForPanelReload
(
toolId
panel
)
{
if
(
toolId
=
=
"
inspector
"
)
{
const
markuploaded
=
panel
.
once
(
"
markuploaded
"
)
;
const
onNewRoot
=
panel
.
once
(
"
new
-
root
"
)
;
const
onUpdated
=
panel
.
once
(
"
inspector
-
updated
"
)
;
const
onReloaded
=
panel
.
once
(
"
reloaded
"
)
;
return
async
function
(
)
{
info
(
"
Waiting
for
markup
view
to
load
after
navigation
.
"
)
;
await
markuploaded
;
info
(
"
Waiting
for
new
root
.
"
)
;
await
onNewRoot
;
info
(
"
Waiting
for
inspector
to
update
after
new
-
root
event
.
"
)
;
await
onUpdated
;
info
(
"
Waiting
for
inspector
updates
after
page
reload
"
)
;
await
onReloaded
;
}
;
}
else
if
(
toolId
=
=
"
netmonitor
"
)
{
const
onReloaded
=
panel
.
once
(
"
reloaded
"
)
;
return
async
function
(
)
{
info
(
"
Waiting
for
netmonitor
updates
after
page
reload
"
)
;
await
onReloaded
;
}
;
}
else
if
(
toolId
=
=
"
accessibility
"
)
{
const
onReloaded
=
panel
.
once
(
"
reloaded
"
)
;
return
async
function
(
)
{
info
(
"
Waiting
for
accessibility
updates
after
page
reload
"
)
;
await
onReloaded
;
}
;
}
return
null
;
}
async
function
watchForCommandsReload
(
commands
{
isErrorPage
=
false
}
=
{
}
)
{
const
onTargetSwitched
=
commands
.
targetCommand
.
once
(
"
switched
-
target
"
)
;
const
documentEventName
=
isErrorPage
?
"
dom
-
loading
"
:
"
dom
-
complete
"
;
const
{
onResource
:
onTopLevelDomEvent
}
=
await
commands
.
resourceCommand
.
waitForNextResource
(
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
ignoreExistingResources
:
true
predicate
:
resource
=
>
resource
.
targetFront
.
isTopLevel
&
&
resource
.
name
=
=
=
documentEventName
}
)
;
return
async
function
(
isTargetSwitching
)
{
if
(
typeof
isTargetSwitching
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
isTargetSwitching
was
not
provided
to
the
wait
method
"
)
;
}
if
(
isTargetSwitching
)
{
info
(
Waiting
for
target
switch
)
;
await
onTargetSwitched
;
info
(
switched
-
target
emitted
)
;
}
else
{
info
(
Waiting
for
'
{
documentEventName
}
'
resource
)
;
await
onTopLevelDomEvent
;
info
(
'
dom
-
complete
'
resource
emitted
)
;
}
return
isTargetSwitching
;
}
;
}
async
function
watchForTargetSwitching
(
commands
browser
)
{
browser
=
browser
|
|
gBrowser
.
selectedBrowser
;
const
currentPID
=
browser
.
browsingContext
.
currentWindowGlobal
.
osPid
;
const
currentBrowsingContextID
=
browser
.
browsingContext
.
id
;
const
targetFollowsWindowLifecycle
=
commands
.
targetCommand
.
targetFront
.
targetForm
.
followWindowGlobalLifeCycle
;
return
function
(
)
{
const
switchedProcess
=
currentPID
!
=
=
browser
.
browsingContext
.
currentWindowGlobal
.
osPid
;
const
switchedBrowsingContext
=
currentBrowsingContextID
!
=
=
browser
.
browsingContext
.
id
;
return
(
targetFollowsWindowLifecycle
|
|
switchedProcess
|
|
switchedBrowsingContext
)
;
}
;
}
async
function
createAndAttachTargetForTab
(
tab
)
{
info
(
"
Creating
and
attaching
to
a
local
tab
target
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
const
target
=
commands
.
targetCommand
.
targetFront
;
await
target
.
attach
(
)
;
return
target
;
}
function
isFissionEnabled
(
)
{
return
SpecialPowers
.
useRemoteSubframes
;
}
function
isServerTargetSwitchingEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
TARGET_SWITCHING_PREF
)
;
}
function
isEveryFrameTargetEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
devtools
.
every
-
frame
-
target
.
enabled
"
false
)
;
}
var
openInspectorForURL
=
async
function
(
url
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
const
{
inspector
toolbox
highlighterTestFront
}
=
await
openInspector
(
hostType
)
;
return
{
tab
inspector
toolbox
highlighterTestFront
}
;
}
;
async
function
getActiveInspector
(
)
{
const
toolbox
=
await
gDevTools
.
getToolboxForTab
(
gBrowser
.
selectedTab
)
;
return
toolbox
.
getPanel
(
"
inspector
"
)
;
}
function
synthesizeKeyShortcut
(
key
target
)
{
const
window
=
Services
.
appShell
.
hiddenDOMWindow
;
const
shortcut
=
KeyShortcuts
.
parseElectronKey
(
window
key
)
;
const
keyEvent
=
{
altKey
:
shortcut
.
alt
ctrlKey
:
shortcut
.
ctrl
metaKey
:
shortcut
.
meta
shiftKey
:
shortcut
.
shift
}
;
if
(
shortcut
.
keyCode
)
{
keyEvent
.
keyCode
=
shortcut
.
keyCode
;
}
info
(
"
Synthesizing
key
shortcut
:
"
+
key
)
;
EventUtils
.
synthesizeKey
(
shortcut
.
key
|
|
"
"
keyEvent
target
)
;
}
var
waitForTime
=
DevToolsUtils
.
waitForTime
;
function
waitForTick
(
)
{
return
new
Promise
(
resolve
=
>
DevToolsUtils
.
executeSoon
(
resolve
)
)
;
}
function
wait
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
ms
)
;
info
(
"
Waiting
"
+
ms
/
1000
+
"
seconds
.
"
)
;
}
)
;
}
async
function
waitFor
(
condition
message
=
"
"
interval
=
10
maxTries
=
500
)
{
interval
=
typeof
waitFor
.
overrideIntervalForTestFile
!
=
=
"
undefined
"
?
waitFor
.
overrideIntervalForTestFile
:
interval
;
maxTries
=
typeof
waitFor
.
overrideMaxTriesForTestFile
!
=
=
"
undefined
"
?
waitFor
.
overrideMaxTriesForTestFile
:
maxTries
;
try
{
const
value
=
await
BrowserTestUtils
.
waitForCondition
(
condition
message
interval
maxTries
)
;
return
value
;
}
catch
(
e
)
{
const
errorMessage
=
"
Failed
waitFor
(
)
:
"
+
message
+
"
\
n
"
+
"
Failed
condition
:
"
+
condition
+
"
\
n
"
;
throw
new
Error
(
errorMessage
)
;
}
}
function
waitForNEvents
(
target
eventName
numTimes
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
count
=
0
;
return
new
Promise
(
resolve
=
>
{
for
(
const
[
add
remove
]
of
[
[
"
on
"
"
off
"
]
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
addMessageListener
"
"
removeMessageListener
"
]
]
)
{
if
(
add
in
target
&
&
remove
in
target
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
args
)
{
if
(
typeof
info
=
=
=
"
function
"
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
}
if
(
+
+
count
=
=
numTimes
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
resolve
(
.
.
.
args
)
;
}
}
useCapture
)
;
break
;
}
}
}
)
;
}
function
waitForDOM
(
target
selector
expectedLength
=
1
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
MutationObserver
(
mutations
=
>
{
mutations
.
forEach
(
mutation
=
>
{
const
elements
=
mutation
.
target
.
querySelectorAll
(
selector
)
;
if
(
elements
.
length
=
=
=
expectedLength
)
{
observer
.
disconnect
(
)
;
resolve
(
elements
)
;
}
}
)
;
}
)
;
observer
.
observe
(
target
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
;
}
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
return
waitForNEvents
(
target
eventName
1
useCapture
)
;
}
function
loadHelperScript
(
filePath
)
{
const
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
var
openToolboxForTab
=
async
function
(
tab
toolId
hostType
)
{
info
(
"
Opening
the
toolbox
"
)
;
let
toolbox
;
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
toolbox
)
{
if
(
!
toolId
|
|
(
toolId
&
&
toolbox
.
getPanel
(
toolId
)
)
)
{
info
(
"
Toolbox
is
already
opened
"
)
;
return
toolbox
;
}
}
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
hostType
}
)
;
await
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
toolbox
.
win
)
)
;
info
(
"
Toolbox
opened
and
focused
"
)
;
return
toolbox
;
}
;
var
openNewTabAndToolbox
=
async
function
(
url
toolId
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
return
openToolboxForTab
(
tab
toolId
hostType
)
;
}
;
var
closeTabAndToolbox
=
async
function
(
tab
=
gBrowser
.
selectedTab
)
{
if
(
TabDescriptorFactory
.
isKnownTab
(
tab
)
)
{
await
gDevTools
.
closeToolboxForTab
(
tab
)
;
}
await
removeTab
(
tab
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
;
var
closeToolboxAndTab
=
async
function
(
toolbox
)
{
await
toolbox
.
destroy
(
)
;
await
removeTab
(
gBrowser
.
selectedTab
)
;
}
;
async
function
getSupportedToolIds
(
tab
)
{
info
(
"
Getting
the
entire
list
of
tools
supported
in
this
tab
"
)
;
let
shouldDestroyToolbox
=
false
;
let
toolbox
=
await
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
!
toolbox
)
{
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
)
;
shouldDestroyToolbox
=
true
;
}
const
toolIds
=
gDevTools
.
getToolDefinitionArray
(
)
.
filter
(
def
=
>
def
.
isTargetSupported
(
toolbox
.
target
)
)
.
map
(
def
=
>
def
.
id
)
;
if
(
shouldDestroyToolbox
)
{
await
toolbox
.
destroy
(
)
;
}
return
toolIds
;
}
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
async
function
asyncWaitUntil
(
predicate
interval
=
10
)
{
let
success
=
await
predicate
(
)
;
while
(
!
success
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
interval
)
)
;
success
=
await
predicate
(
)
;
}
}
function
waitForContextMenu
(
popup
button
onShown
onHidden
)
{
return
new
Promise
(
resolve
=
>
{
function
onPopupShown
(
)
{
info
(
"
onPopupShown
"
)
;
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
onShown
&
&
onShown
(
)
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
popup
.
hidePopup
(
)
)
;
}
function
onPopupHidden
(
)
{
info
(
"
onPopupHidden
"
)
;
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
onHidden
&
&
onHidden
(
)
;
resolve
(
popup
)
;
}
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
info
(
"
wait
for
the
context
menu
to
open
"
)
;
synthesizeContextMenuEvent
(
button
)
;
}
)
;
}
function
synthesizeContextMenuEvent
(
el
)
{
el
.
scrollIntoView
(
)
;
const
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
EventUtils
.
synthesizeMouse
(
el
5
2
eventDetails
el
.
ownerDocument
.
defaultView
)
;
}
function
waitForClipboardPromise
(
setup
expected
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SimpleTest
.
waitForClipboard
(
expected
setup
resolve
reject
)
;
}
)
;
}
function
pushPref
(
preferenceName
value
)
{
const
options
=
{
set
:
[
[
preferenceName
value
]
]
}
;
return
SpecialPowers
.
pushPrefEnv
(
options
)
;
}
function
lookupPath
(
obj
path
)
{
const
segments
=
path
.
split
(
"
.
"
)
;
return
segments
.
reduce
(
(
prev
current
)
=
>
prev
[
current
]
obj
)
;
}
var
closeToolbox
=
async
function
(
)
{
await
gDevTools
.
closeToolboxForTab
(
gBrowser
.
selectedTab
)
;
}
;
function
emptyClipboard
(
)
{
const
clipboard
=
Services
.
clipboard
;
clipboard
.
emptyClipboard
(
clipboard
.
kGlobalClipboard
)
;
}
function
isWindows
(
)
{
return
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
;
}
async
function
enableTargetSwitching
(
)
{
await
pushPref
(
TARGET_SWITCHING_PREF
true
)
;
}
function
waitForTitleChange
(
toolbox
)
{
return
new
Promise
(
resolve
=
>
{
toolbox
.
topWindow
.
addEventListener
(
"
message
"
function
onmessage
(
event
)
{
if
(
event
.
data
.
name
=
=
"
set
-
host
-
title
"
)
{
toolbox
.
topWindow
.
removeEventListener
(
"
message
"
onmessage
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
function
createTestHTTPServer
(
)
{
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
const
server
=
new
HttpServer
(
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
await
new
Promise
(
resolve
=
>
server
.
stop
(
resolve
)
)
;
}
)
;
server
.
start
(
-
1
)
;
return
server
;
}
async
function
registerActorInContentProcess
(
url
options
)
{
function
convertChromeToFile
(
uri
)
{
return
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
.
convertChromeURL
(
Services
.
io
.
newURI
(
uri
)
)
.
spec
;
}
url
=
url
.
startsWith
(
"
chrome
:
/
/
mochitests
"
)
?
convertChromeToFile
(
url
)
:
url
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
url
options
}
]
args
=
>
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
ActorRegistry
}
=
require
(
"
devtools
/
server
/
actors
/
utils
/
actor
-
registry
"
)
;
ActorRegistry
.
registerModule
(
args
.
url
args
.
options
)
;
}
)
;
}
async
function
moveWindowTo
(
win
left
top
)
{
left
=
Math
.
max
(
win
.
screen
.
availLeft
left
)
;
left
=
Math
.
min
(
win
.
screen
.
width
left
)
;
top
=
Math
.
max
(
win
.
screen
.
availTop
top
)
;
top
=
Math
.
min
(
win
.
screen
.
height
top
)
;
info
(
Moving
window
to
{
{
left
}
{
top
}
}
)
;
win
.
moveTo
(
left
top
)
;
info
(
"
Wait
for
window
screenLeft
and
screenTop
to
be
updated
"
)
;
return
waitUntil
(
(
)
=
>
win
.
screenLeft
=
=
=
left
&
&
win
.
screenTop
=
=
=
top
)
;
}
function
getCurrentTestFilePath
(
)
{
return
gTestPath
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
"
"
)
;
}
async
function
unregisterAllServiceWorkers
(
client
)
{
info
(
"
Wait
until
all
workers
have
a
valid
registrationFront
"
)
;
let
workers
;
await
asyncWaitUntil
(
async
function
(
)
{
workers
=
await
client
.
mainRoot
.
listAllWorkers
(
)
;
const
allWorkersRegistered
=
workers
.
service
.
every
(
worker
=
>
!
!
worker
.
registrationFront
)
;
return
allWorkersRegistered
;
}
)
;
info
(
"
Unregister
all
service
workers
"
)
;
const
promises
=
[
]
;
for
(
const
worker
of
workers
.
service
)
{
promises
.
push
(
worker
.
registrationFront
.
unregister
(
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
function
colorAt
(
image
x
y
)
{
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
canvas
=
document
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
canvas
.
width
=
image
.
width
;
canvas
.
height
=
image
.
height
;
const
context
=
canvas
.
getContext
(
"
2d
"
)
;
context
.
drawImage
(
image
0
0
image
.
width
image
.
height
)
;
const
[
r
g
b
]
=
context
.
getImageData
(
x
y
1
1
)
.
data
;
return
{
r
g
b
}
;
}
let
allDownloads
=
[
]
;
async
function
waitUntilScreenshot
(
)
{
const
{
Downloads
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
const
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
return
new
Promise
(
function
(
resolve
)
{
const
view
=
{
onDownloadAdded
:
async
download
=
>
{
await
download
.
whenSucceeded
(
)
;
if
(
allDownloads
.
includes
(
download
)
)
{
return
;
}
allDownloads
.
push
(
download
)
;
resolve
(
download
.
target
.
path
)
;
list
.
removeView
(
view
)
;
}
}
;
list
.
addView
(
view
)
;
}
)
;
}
async
function
resetDownloads
(
)
{
info
(
"
Reset
downloads
"
)
;
const
{
Downloads
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
const
publicList
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
const
downloads
=
await
publicList
.
getAll
(
)
;
for
(
const
download
of
downloads
)
{
publicList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
allDownloads
=
[
]
;
}
async
function
takeNodeScreenshot
(
inspector
)
{
registerCleanupFunction
(
resetDownloads
)
;
info
(
"
Call
screenshotNode
(
)
and
wait
until
the
screenshot
is
found
in
the
Downloads
"
)
;
const
whenScreenshotSucceeded
=
waitUntilScreenshot
(
)
;
inspector
.
screenshotNode
(
)
;
const
filePath
=
await
whenScreenshotSucceeded
;
info
(
"
Create
an
image
using
the
downloaded
fileas
source
"
)
;
const
image
=
new
Image
(
)
;
const
onImageLoad
=
once
(
image
"
load
"
)
;
image
.
src
=
OS
.
Path
.
toFileURI
(
filePath
)
;
await
onImageLoad
;
info
(
"
Remove
the
downloaded
screenshot
file
"
)
;
await
OS
.
File
.
remove
(
filePath
)
;
info
(
"
Wait
for
one
second
to
make
sure
future
screenshots
will
use
a
different
name
"
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
1000
)
)
;
return
image
;
}
async
function
assertSingleColorScreenshotImage
(
image
width
height
{
r
g
b
}
)
{
info
(
Assert
{
image
.
src
}
content
)
;
const
ratio
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
content
.
wrappedJSObject
.
devicePixelRatio
)
;
is
(
image
.
width
ratio
*
width
node
screenshot
has
the
expected
width
(
dpr
=
{
ratio
}
)
)
;
is
(
image
.
height
height
*
ratio
node
screenshot
has
the
expected
height
(
dpr
=
{
ratio
}
)
)
;
const
color
=
colorAt
(
image
0
0
)
;
is
(
color
.
r
r
"
node
screenshot
has
the
expected
red
component
"
)
;
is
(
color
.
g
g
"
node
screenshot
has
the
expected
green
component
"
)
;
is
(
color
.
b
b
"
node
screenshot
has
the
expected
blue
component
"
)
;
}
function
checkImageColorAt
(
{
image
x
=
0
y
expectedColor
label
}
)
{
const
color
=
colorAt
(
image
x
y
)
;
is
(
rgb
(
{
Object
.
values
(
color
)
.
join
(
"
"
)
}
)
expectedColor
label
)
;
}
function
checkPoolChildrenSize
(
parentPool
typeName
expected
)
{
const
children
=
[
.
.
.
parentPool
.
poolChildren
(
)
]
;
const
childrenByType
=
children
.
filter
(
pool
=
>
pool
.
typeName
=
=
=
typeName
)
;
is
(
childrenByType
.
length
expected
{
parentPool
.
actorID
}
should
have
{
expected
}
children
of
type
{
typeName
}
)
;
}
function
waitForDispatch
(
store
actionType
repeat
=
1
)
{
let
count
=
0
;
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
{
const
isDone
=
!
action
.
status
|
|
action
.
status
=
=
=
"
done
"
|
|
action
.
status
=
=
=
"
error
"
;
if
(
action
.
type
=
=
=
actionType
&
&
isDone
&
&
+
+
count
=
=
repeat
)
{
return
true
;
}
return
false
;
}
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
async
function
getBrowsingContextInFrames
(
browsingContext
selectors
)
{
let
context
=
browsingContext
;
if
(
!
Array
.
isArray
(
selectors
)
)
{
throw
new
Error
(
"
getBrowsingContextInFrames
called
with
an
invalid
selectors
argument
"
)
;
}
if
(
selectors
.
length
=
=
=
0
)
{
throw
new
Error
(
"
getBrowsingContextInFrames
called
with
an
empty
selectors
array
"
)
;
}
while
(
selectors
.
length
)
{
const
selector
=
selectors
.
shift
(
)
;
context
=
await
SpecialPowers
.
spawn
(
context
[
selector
]
_selector
=
>
{
return
content
.
document
.
querySelector
(
_selector
)
.
browsingContext
;
}
)
;
}
return
context
;
}
async
function
safeSynthesizeMouseEventInContentPage
(
selector
x
y
options
=
{
}
)
{
let
context
=
gBrowser
.
selectedBrowser
.
browsingContext
;
if
(
Array
.
isArray
(
selector
)
)
{
if
(
selector
.
length
=
=
=
1
)
{
selector
=
selector
[
0
]
;
}
else
{
context
=
await
getBrowsingContextInFrames
(
context
selector
.
slice
(
0
-
1
)
)
;
selector
=
selector
.
at
(
-
1
)
;
}
}
await
scrollContentPageNodeIntoView
(
context
selector
)
;
BrowserTestUtils
.
synthesizeMouse
(
selector
x
y
options
context
)
;
}
async
function
safeSynthesizeMouseEventAtCenterInContentPage
(
selector
options
=
{
}
)
{
let
context
=
gBrowser
.
selectedBrowser
.
browsingContext
;
if
(
Array
.
isArray
(
selector
)
)
{
if
(
selector
.
length
=
=
=
1
)
{
selector
=
selector
[
0
]
;
}
else
{
context
=
await
getBrowsingContextInFrames
(
context
selector
.
slice
(
0
-
1
)
)
;
selector
=
selector
.
at
(
-
1
)
;
}
}
await
scrollContentPageNodeIntoView
(
context
selector
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
selector
options
context
)
;
}
function
scrollContentPageNodeIntoView
(
browsingContext
selector
)
{
return
SpecialPowers
.
spawn
(
browsingContext
[
selector
]
function
(
innerSelector
)
{
const
node
=
content
.
wrappedJSObject
.
document
.
querySelector
(
innerSelector
)
;
node
.
scrollIntoView
(
)
;
}
)
;
}
function
setContentPageZoomLevel
(
zoomLevel
)
{
gBrowser
.
selectedBrowser
.
fullZoom
=
zoomLevel
;
}
async
function
waitForNextTopLevelDomCompleteResource
(
commands
)
{
const
{
onResource
:
onDomCompleteResource
}
=
await
commands
.
resourceCommand
.
waitForNextResource
(
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
ignoreExistingResources
:
true
predicate
:
resource
=
>
resource
.
name
=
=
=
"
dom
-
complete
"
&
&
resource
.
targetFront
.
isTopLevel
}
)
;
return
{
onDomCompleteResource
}
;
}
const
waitForPresShell
=
function
(
context
)
{
return
SpecialPowers
.
spawn
(
context
[
]
async
(
)
=
>
{
const
winUtils
=
SpecialPowers
.
getDOMWindowUtils
(
content
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
try
{
return
!
!
winUtils
.
getPresShellId
(
)
;
}
catch
(
e
)
{
return
false
;
}
}
"
Waiting
for
a
valid
presShell
"
)
;
}
)
;
}
;
