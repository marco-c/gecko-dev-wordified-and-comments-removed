"
use
strict
"
;
const
{
Constructor
:
CC
}
=
Components
;
function
scopedCuImport
(
path
)
{
const
scope
=
{
}
;
ChromeUtils
.
import
(
path
scope
)
;
return
scope
;
}
const
{
ScratchpadManager
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
client
/
scratchpad
/
scratchpad
-
manager
.
jsm
"
)
;
const
{
loader
require
}
=
scopedCuImport
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
let
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
try
{
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
"
this
)
;
}
catch
(
e
)
{
ok
(
false
"
MISSING
DEPENDENCY
ON
telemetry
-
test
-
helpers
.
js
\
n
"
+
"
Please
add
the
following
line
in
browser
.
ini
:
\
n
"
+
"
!
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
\
n
"
)
;
throw
e
;
}
require
(
"
devtools
/
client
/
framework
/
devtools
-
browser
"
)
;
waitForExplicitFinish
(
)
;
var
EXPECTED_DTU_ASSERT_FAILURE_COUNT
=
0
;
registerCleanupFunction
(
function
(
)
{
if
(
DevToolsUtils
.
assertionFailureCount
!
=
=
EXPECTED_DTU_ASSERT_FAILURE_COUNT
)
{
ok
(
false
"
Should
have
had
the
expected
number
of
DevToolsUtils
.
assert
(
)
failures
.
"
+
"
Expected
"
+
EXPECTED_DTU_ASSERT_FAILURE_COUNT
+
"
got
"
+
DevToolsUtils
.
assertionFailureCount
)
;
}
}
)
;
const
ConsoleObserver
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
]
)
observe
:
function
(
subject
)
{
const
message
=
subject
.
wrappedJSObject
.
arguments
[
0
]
;
if
(
message
&
&
/
Failed
propType
/
.
test
(
message
.
toString
(
)
)
)
{
ok
(
false
message
)
;
}
}
}
;
Services
.
obs
.
addObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
obs
.
removeObserver
(
ConsoleObserver
"
console
-
api
-
log
-
event
"
)
;
}
)
;
const
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
const
DEBUG_ALLOCATIONS
=
env
.
get
(
"
DEBUG_DEVTOOLS_ALLOCATIONS
"
)
;
if
(
DEBUG_ALLOCATIONS
)
{
const
{
allocationTracker
}
=
require
(
"
devtools
/
shared
/
test
-
helpers
/
allocation
-
tracker
"
)
;
const
tracker
=
allocationTracker
(
)
;
registerCleanupFunction
(
(
)
=
>
{
if
(
DEBUG_ALLOCATIONS
=
=
"
normal
"
)
{
tracker
.
logCount
(
)
;
}
else
if
(
DEBUG_ALLOCATIONS
=
=
"
verbose
"
)
{
tracker
.
logAllocationSites
(
)
;
}
tracker
.
stop
(
)
;
}
)
;
}
var
waitForTime
=
DevToolsUtils
.
waitForTime
;
function
loadFrameScriptUtils
(
browser
=
gBrowser
.
selectedBrowser
)
{
let
mm
=
browser
.
messageManager
;
const
frameURL
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
frame
-
script
-
utils
.
js
"
;
info
(
"
Loading
the
helper
frame
script
"
+
frameURL
)
;
mm
.
loadFrameScript
(
frameURL
false
)
;
SimpleTest
.
registerCleanupFunction
(
(
)
=
>
{
mm
=
null
;
}
)
;
return
mm
;
}
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
show
-
three
-
pane
-
tooltip
"
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
show
-
three
-
pane
-
tooltip
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleEnabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleHeight
"
)
;
}
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
while
(
gBrowser
.
tabs
.
length
>
1
)
{
await
closeTabAndToolbox
(
gBrowser
.
selectedTab
)
;
}
}
)
;
var
addTab
=
async
function
(
url
options
=
{
}
)
{
info
(
"
Adding
a
new
tab
with
URL
:
"
+
url
)
;
const
{
background
=
false
userContextId
preferredRemoteType
waitForLoad
=
true
}
=
options
;
const
{
gBrowser
}
=
options
.
window
?
options
.
window
:
window
;
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
url
{
userContextId
preferredRemoteType
}
)
;
if
(
!
background
)
{
gBrowser
.
selectedTab
=
tab
;
}
if
(
waitForLoad
)
{
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
info
(
"
Tab
added
and
finished
loading
"
)
;
}
else
{
info
(
"
Tab
added
"
)
;
}
return
tab
;
}
;
var
removeTab
=
async
function
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
const
{
gBrowser
}
=
tab
.
ownerDocument
.
defaultView
;
const
onClose
=
once
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
gBrowser
.
removeTab
(
tab
)
;
await
onClose
;
info
(
"
Tab
removed
and
finished
closing
"
)
;
}
;
var
refreshTab
=
async
function
(
tab
=
gBrowser
.
selectedTab
)
{
info
(
"
Refreshing
tab
.
"
)
;
const
finished
=
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
gBrowser
.
reloadTab
(
tab
)
;
await
finished
;
info
(
"
Tab
finished
refreshing
.
"
)
;
}
;
function
synthesizeKeyFromKeyTag
(
key
)
{
is
(
key
&
&
key
.
tagName
"
key
"
"
Successfully
retrieved
the
<
key
>
node
"
)
;
const
modifiersAttr
=
key
.
getAttribute
(
"
modifiers
"
)
;
let
name
=
null
;
if
(
key
.
getAttribute
(
"
keycode
"
)
)
{
name
=
key
.
getAttribute
(
"
keycode
"
)
;
}
else
if
(
key
.
getAttribute
(
"
key
"
)
)
{
name
=
key
.
getAttribute
(
"
key
"
)
;
}
isnot
(
name
null
"
Successfully
retrieved
keycode
/
key
"
)
;
const
modifiers
=
{
shiftKey
:
!
!
modifiersAttr
.
match
(
"
shift
"
)
ctrlKey
:
!
!
modifiersAttr
.
match
(
"
control
"
)
altKey
:
!
!
modifiersAttr
.
match
(
"
alt
"
)
metaKey
:
!
!
modifiersAttr
.
match
(
"
meta
"
)
accelKey
:
!
!
modifiersAttr
.
match
(
"
accel
"
)
}
;
info
(
"
Synthesizing
key
"
+
name
+
"
"
+
JSON
.
stringify
(
modifiers
)
)
;
EventUtils
.
synthesizeKey
(
name
modifiers
)
;
}
function
synthesizeKeyShortcut
(
key
target
)
{
const
window
=
Services
.
appShell
.
hiddenDOMWindow
;
const
shortcut
=
KeyShortcuts
.
parseElectronKey
(
window
key
)
;
const
keyEvent
=
{
altKey
:
shortcut
.
alt
ctrlKey
:
shortcut
.
ctrl
metaKey
:
shortcut
.
meta
shiftKey
:
shortcut
.
shift
}
;
if
(
shortcut
.
keyCode
)
{
keyEvent
.
keyCode
=
shortcut
.
keyCode
;
}
info
(
"
Synthesizing
key
shortcut
:
"
+
key
)
;
EventUtils
.
synthesizeKey
(
shortcut
.
key
|
|
"
"
keyEvent
target
)
;
}
function
waitForNEvents
(
target
eventName
numTimes
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
count
=
0
;
return
new
Promise
(
resolve
=
>
{
for
(
const
[
add
remove
]
of
[
[
"
on
"
"
off
"
]
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
addMessageListener
"
"
removeMessageListener
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
args
)
{
if
(
typeof
info
=
=
=
"
function
"
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
}
if
(
+
+
count
=
=
numTimes
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
resolve
(
.
.
.
args
)
;
}
}
useCapture
)
;
break
;
}
}
}
)
;
}
function
waitForDOM
(
target
selector
expectedLength
=
1
)
{
return
new
Promise
(
(
resolve
)
=
>
{
const
observer
=
new
MutationObserver
(
(
mutations
)
=
>
{
mutations
.
forEach
(
(
mutation
)
=
>
{
const
elements
=
mutation
.
target
.
querySelectorAll
(
selector
)
;
if
(
elements
.
length
=
=
=
expectedLength
)
{
observer
.
disconnect
(
)
;
resolve
(
elements
)
;
}
}
)
;
}
)
;
observer
.
observe
(
target
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
;
}
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
return
waitForNEvents
(
target
eventName
1
useCapture
)
;
}
function
loadHelperScript
(
filePath
)
{
const
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
function
waitForTick
(
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
function
wait
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
ms
)
;
info
(
"
Waiting
"
+
ms
/
1000
+
"
seconds
.
"
)
;
}
)
;
}
var
openToolboxForTab
=
async
function
(
tab
toolId
hostType
)
{
info
(
"
Opening
the
toolbox
"
)
;
let
toolbox
;
const
target
=
TargetFactory
.
forTab
(
tab
)
;
await
target
.
makeRemote
(
)
;
toolbox
=
gDevTools
.
getToolbox
(
target
)
;
if
(
toolbox
)
{
if
(
!
toolId
|
|
(
toolId
&
&
toolbox
.
getPanel
(
toolId
)
)
)
{
info
(
"
Toolbox
is
already
opened
"
)
;
return
toolbox
;
}
}
toolbox
=
await
gDevTools
.
showToolbox
(
target
toolId
hostType
)
;
await
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
toolbox
.
win
)
)
;
info
(
"
Toolbox
opened
and
focused
"
)
;
return
toolbox
;
}
;
var
openNewTabAndToolbox
=
async
function
(
url
toolId
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
return
openToolboxForTab
(
tab
toolId
hostType
)
;
}
;
var
closeTabAndToolbox
=
async
function
(
tab
=
gBrowser
.
selectedTab
)
{
const
target
=
TargetFactory
.
forTab
(
tab
)
;
if
(
target
)
{
await
gDevTools
.
closeToolbox
(
target
)
;
}
await
removeTab
(
tab
)
;
}
;
var
closeToolboxAndTab
=
async
function
(
toolbox
)
{
await
toolbox
.
destroy
(
)
;
await
removeTab
(
gBrowser
.
selectedTab
)
;
}
;
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
async
function
asyncWaitUntil
(
predicate
interval
=
10
)
{
let
success
=
await
predicate
(
)
;
while
(
!
success
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
interval
)
)
;
success
=
await
predicate
(
)
;
}
}
let
MM_INC_ID
=
0
;
function
evalInDebuggee
(
script
browser
=
gBrowser
.
selectedBrowser
)
{
return
new
Promise
(
resolve
=
>
{
const
id
=
MM_INC_ID
+
+
;
const
mm
=
browser
.
messageManager
;
mm
.
sendAsyncMessage
(
"
devtools
:
test
:
eval
"
{
script
id
}
)
;
mm
.
addMessageListener
(
"
devtools
:
test
:
eval
:
response
"
handler
)
;
function
handler
(
{
data
}
)
{
if
(
id
!
=
=
data
.
id
)
{
return
;
}
info
(
Successfully
evaled
in
debuggee
:
{
script
}
)
;
mm
.
removeMessageListener
(
"
devtools
:
test
:
eval
:
response
"
handler
)
;
resolve
(
data
.
value
)
;
}
}
)
;
}
function
waitForContextMenu
(
popup
button
onShown
onHidden
)
{
return
new
Promise
(
resolve
=
>
{
function
onPopupShown
(
)
{
info
(
"
onPopupShown
"
)
;
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
onShown
&
&
onShown
(
)
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
executeSoon
(
(
)
=
>
popup
.
hidePopup
(
)
)
;
}
function
onPopupHidden
(
)
{
info
(
"
onPopupHidden
"
)
;
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
onHidden
&
&
onHidden
(
)
;
resolve
(
popup
)
;
}
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
info
(
"
wait
for
the
context
menu
to
open
"
)
;
synthesizeContextMenuEvent
(
button
)
;
}
)
;
}
function
synthesizeContextMenuEvent
(
el
)
{
el
.
scrollIntoView
(
)
;
const
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
EventUtils
.
synthesizeMouse
(
el
5
2
eventDetails
el
.
ownerDocument
.
defaultView
)
;
}
function
waitForClipboardPromise
(
setup
expected
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SimpleTest
.
waitForClipboard
(
expected
setup
resolve
reject
)
;
}
)
;
}
function
pushPref
(
preferenceName
value
)
{
return
new
Promise
(
resolve
=
>
{
const
options
=
{
"
set
"
:
[
[
preferenceName
value
]
]
}
;
SpecialPowers
.
pushPrefEnv
(
options
resolve
)
;
}
)
;
}
function
lookupPath
(
obj
path
)
{
const
segments
=
path
.
split
(
"
.
"
)
;
return
segments
.
reduce
(
(
prev
current
)
=
>
prev
[
current
]
obj
)
;
}
var
closeToolbox
=
async
function
(
)
{
const
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
await
gDevTools
.
closeToolbox
(
target
)
;
}
;
function
emptyClipboard
(
)
{
const
clipboard
=
Services
.
clipboard
;
clipboard
.
emptyClipboard
(
clipboard
.
kGlobalClipboard
)
;
}
function
isWindows
(
)
{
return
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
;
}
function
waitForTitleChange
(
toolbox
)
{
return
new
Promise
(
resolve
=
>
{
toolbox
.
win
.
parent
.
addEventListener
(
"
message
"
function
onmessage
(
event
)
{
if
(
event
.
data
.
name
=
=
"
set
-
host
-
title
"
)
{
toolbox
.
win
.
parent
.
removeEventListener
(
"
message
"
onmessage
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
function
createTestHTTPServer
(
)
{
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
{
}
)
;
const
server
=
new
HttpServer
(
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
await
new
Promise
(
resolve
=
>
server
.
stop
(
resolve
)
)
;
}
)
;
server
.
start
(
-
1
)
;
return
server
;
}
async
function
injectEventUtilsInContentTask
(
browser
)
{
await
ContentTask
.
spawn
(
browser
{
}
async
function
(
)
{
if
(
"
EventUtils
"
in
this
)
{
return
;
}
const
EventUtils
=
this
.
EventUtils
=
{
}
;
EventUtils
.
window
=
{
}
;
EventUtils
.
parent
=
EventUtils
.
window
;
EventUtils
.
_EU_Ci
=
Ci
;
EventUtils
.
_EU_Cc
=
Cc
;
EventUtils
.
navigator
=
content
.
navigator
;
EventUtils
.
KeyboardEvent
=
content
.
KeyboardEvent
;
EventUtils
.
synthesizeClick
=
element
=
>
new
Promise
(
resolve
=
>
{
element
.
addEventListener
(
"
click
"
function
(
)
{
resolve
(
)
;
}
{
once
:
true
}
)
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
type
:
"
mousedown
"
isSynthesized
:
false
}
content
)
;
EventUtils
.
synthesizeMouseAtCenter
(
element
{
type
:
"
mouseup
"
isSynthesized
:
false
}
content
)
;
}
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
EventUtils
.
js
"
EventUtils
)
;
}
)
;
}
async
function
enableWebComponents
(
)
{
await
pushPref
(
"
dom
.
webcomponents
.
shadowdom
.
enabled
"
true
)
;
await
pushPref
(
"
dom
.
webcomponents
.
customelements
.
enabled
"
true
)
;
}
async
function
registerActorInContentProcess
(
url
options
)
{
function
convertChromeToFile
(
uri
)
{
return
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
.
convertChromeURL
(
Services
.
io
.
newURI
(
uri
)
)
.
spec
;
}
url
=
url
.
startsWith
(
"
chrome
:
/
/
mochitests
"
)
?
convertChromeToFile
(
url
)
:
url
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
url
options
}
args
=
>
{
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
DebuggerServer
}
=
require
(
"
devtools
/
server
/
main
"
)
;
DebuggerServer
.
registerModule
(
args
.
url
args
.
options
)
;
}
)
;
}
