"
use
strict
"
;
const
isMochitest
=
"
gTestPath
"
in
this
;
const
isXpcshell
=
!
isMochitest
;
if
(
isXpcshell
)
{
this
.
gTestPath
=
_TEST_FILE
[
0
]
;
}
const
{
Constructor
:
CC
}
=
Components
;
const
DEBUG_ALLOCATIONS
=
Services
.
env
.
get
(
"
DEBUG_DEVTOOLS_ALLOCATIONS
"
)
;
if
(
DEBUG_ALLOCATIONS
)
{
const
{
useDistinctSystemPrincipalLoader
releaseDistinctSystemPrincipalLoader
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
DistinctSystemPrincipalLoader
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
requester
=
{
}
;
const
loader
=
useDistinctSystemPrincipalLoader
(
requester
)
;
registerCleanupFunction
(
(
)
=
>
releaseDistinctSystemPrincipalLoader
(
requester
)
)
;
const
{
allocationTracker
}
=
loader
.
require
(
"
resource
:
/
/
devtools
/
shared
/
test
-
helpers
/
allocation
-
tracker
.
js
"
)
;
const
tracker
=
allocationTracker
(
{
watchAllGlobals
:
true
}
)
;
registerCleanupFunction
(
(
)
=
>
{
if
(
DEBUG_ALLOCATIONS
=
=
"
normal
"
)
{
tracker
.
logCount
(
)
;
}
else
if
(
DEBUG_ALLOCATIONS
=
=
"
verbose
"
)
{
tracker
.
logAllocationSites
(
)
;
}
tracker
.
stop
(
)
;
}
)
;
}
const
DEBUG_STEP
=
Services
.
env
.
get
(
"
DEBUG_STEP
"
)
;
if
(
DEBUG_STEP
)
{
const
{
useDistinctSystemPrincipalLoader
releaseDistinctSystemPrincipalLoader
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
DistinctSystemPrincipalLoader
.
sys
.
mjs
"
{
global
:
"
shared
"
}
)
;
const
requester
=
{
}
;
const
loader
=
useDistinctSystemPrincipalLoader
(
requester
)
;
const
stepper
=
loader
.
require
(
"
resource
:
/
/
devtools
/
shared
/
test
-
helpers
/
test
-
stepper
.
js
"
)
;
stepper
.
start
(
globalThis
gTestPath
DEBUG_STEP
)
;
registerCleanupFunction
(
(
)
=
>
{
stepper
.
stop
(
)
;
releaseDistinctSystemPrincipalLoader
(
requester
)
;
}
)
;
}
const
DEBUG_TRACE_LINE
=
Services
.
env
.
get
(
"
DEBUG_TRACE_LINE
"
)
;
if
(
DEBUG_TRACE_LINE
)
{
const
{
useDistinctSystemPrincipalLoader
releaseDistinctSystemPrincipalLoader
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
DistinctSystemPrincipalLoader
.
sys
.
mjs
"
)
;
const
requester
=
{
}
;
const
loader
=
useDistinctSystemPrincipalLoader
(
requester
)
;
const
lineTracer
=
loader
.
require
(
"
resource
:
/
/
devtools
/
shared
/
test
-
helpers
/
test
-
line
-
tracer
.
js
"
)
;
lineTracer
.
start
(
globalThis
gTestPath
DEBUG_TRACE_LINE
)
;
registerCleanupFunction
(
(
)
=
>
{
lineTracer
.
stop
(
)
;
releaseDistinctSystemPrincipalLoader
(
requester
)
;
}
)
;
}
const
{
loader
require
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
sys
.
mjs
"
)
;
const
{
sinon
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
Sinon
.
sys
.
mjs
"
)
;
const
{
gDevTools
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
devtools
.
js
"
)
;
const
{
CommandsFactory
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
commands
/
commands
-
factory
.
js
"
)
;
const
DevToolsUtils
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
KeyShortcuts
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
key
-
shortcuts
.
js
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveUIManager
"
"
resource
:
/
/
devtools
/
client
/
responsive
/
manager
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
localTypes
"
"
resource
:
/
/
devtools
/
client
/
responsive
/
types
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
ResponsiveMessageHelper
"
"
resource
:
/
/
devtools
/
client
/
responsive
/
utils
/
message
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
FluentReact
"
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
fluent
-
react
.
js
"
)
;
const
TEST_DIR
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
const
CHROME_URL_ROOT
=
TEST_DIR
+
"
/
"
;
const
URL_ROOT
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
com
/
"
)
;
const
URL_ROOT_COM
=
URL_ROOT
;
const
URL_ROOT_COM_SSL
=
URL_ROOT_SSL
;
const
URL_ROOT_ORG
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
org
/
"
)
;
const
URL_ROOT_ORG_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
org
/
"
)
;
const
URL_ROOT_NET
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
example
.
net
/
"
)
;
const
URL_ROOT_NET_SSL
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
https
:
/
/
example
.
net
/
"
)
;
const
URL_ROOT_MOCHI_8888
=
CHROME_URL_ROOT
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
try
{
if
(
isMochitest
)
{
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
"
this
)
;
}
}
catch
(
e
)
{
ok
(
false
"
MISSING
DEPENDENCY
ON
telemetry
-
test
-
helpers
.
js
\
n
"
+
"
Please
add
the
following
line
in
browser
.
ini
:
\
n
"
+
"
!
/
devtools
/
client
/
shared
/
test
/
telemetry
-
test
-
helpers
.
js
\
n
"
)
;
throw
e
;
}
require
(
"
resource
:
/
/
devtools
/
client
/
framework
/
devtools
-
browser
.
js
"
)
;
if
(
isMochitest
)
{
waitForExplicitFinish
(
)
;
}
var
EXPECTED_DTU_ASSERT_FAILURE_COUNT
=
0
;
registerCleanupFunction
(
function
(
)
{
if
(
DevToolsUtils
.
assertionFailureCount
!
=
=
EXPECTED_DTU_ASSERT_FAILURE_COUNT
)
{
ok
(
false
"
Should
have
had
the
expected
number
of
DevToolsUtils
.
assert
(
)
failures
.
"
+
"
Expected
"
+
EXPECTED_DTU_ASSERT_FAILURE_COUNT
+
"
got
"
+
DevToolsUtils
.
assertionFailureCount
)
;
}
}
)
;
function
onConsoleMessage
(
subject
)
{
const
message
=
subject
.
wrappedJSObject
.
arguments
[
0
]
;
if
(
message
&
&
/
Failed
propType
/
.
test
(
message
.
toString
(
)
)
)
{
ok
(
false
message
)
;
}
}
const
ConsoleAPIStorage
=
Cc
[
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
]
.
getService
(
Ci
.
nsIConsoleAPIStorage
)
;
ConsoleAPIStorage
.
addLogEventListener
(
onConsoleMessage
Cc
[
"
mozilla
.
org
/
systemprincipal
;
1
"
]
.
createInstance
(
Ci
.
nsIPrincipal
)
)
;
registerCleanupFunction
(
(
)
=
>
{
ConsoleAPIStorage
.
removeLogEventListener
(
onConsoleMessage
)
;
}
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
true
)
;
Services
.
prefs
.
setBoolPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
inspector
.
simple
-
highlighters
.
message
-
dismissed
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
three
-
pane
-
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
host
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
previousHost
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsole
.
open
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
toolbox
.
splitconsoleHeight
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
inspector
.
simple
-
highlighters
.
message
-
dismissed
"
)
;
}
)
;
var
{
BrowserConsoleManager
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
webconsole
/
browser
-
console
-
manager
.
js
"
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
const
browserConsole
=
BrowserConsoleManager
.
getBrowserConsole
(
)
;
if
(
browserConsole
)
{
await
safeCloseBrowserConsole
(
{
clearOutput
:
true
}
)
;
}
while
(
isMochitest
&
&
gBrowser
.
tabs
.
length
>
1
)
{
await
closeTabAndToolbox
(
gBrowser
.
selectedTab
)
;
}
await
waitForTick
(
)
;
const
{
DevToolsServer
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
devtools
-
server
.
js
"
)
;
ok
(
!
DevToolsServer
.
hasConnection
(
)
"
The
main
process
DevToolsServer
has
no
pending
connection
when
the
test
ends
"
)
;
if
(
DevToolsServer
.
hasConnection
(
)
)
{
for
(
const
conn
of
Object
.
values
(
DevToolsServer
.
_connections
)
)
{
conn
.
close
(
)
;
}
}
}
)
;
async
function
safeCloseBrowserConsole
(
{
clearOutput
=
false
}
=
{
}
)
{
const
hud
=
BrowserConsoleManager
.
getBrowserConsole
(
)
;
if
(
!
hud
)
{
return
;
}
if
(
clearOutput
)
{
info
(
"
Clear
the
browser
console
output
"
)
;
const
{
ui
}
=
hud
;
const
promises
=
[
ui
.
once
(
"
messages
-
cleared
"
)
]
;
if
(
ui
.
outputNode
.
querySelector
(
"
.
object
-
inspector
"
)
)
{
promises
.
push
(
ui
.
once
(
"
fronts
-
released
"
)
)
;
}
await
ui
.
clearOutput
(
true
)
;
await
Promise
.
all
(
promises
)
;
info
(
"
Browser
console
cleared
"
)
;
}
info
(
"
Wait
for
all
Browser
Console
targets
to
be
attached
"
)
;
await
Promise
.
race
(
[
waitForAllTargetsToBeAttached
(
hud
.
commands
.
targetCommand
)
wait
(
1000
)
]
)
;
info
(
"
Close
the
Browser
Console
"
)
;
await
BrowserConsoleManager
.
closeBrowserConsole
(
)
;
info
(
"
Browser
Console
closed
"
)
;
}
function
highlighterTestActorBootstrap
(
)
{
const
HIGHLIGHTER_TEST_ACTOR_URL
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
highlighter
-
test
-
actor
.
js
"
;
const
{
require
:
_require
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
sys
.
mjs
"
)
;
_require
(
HIGHLIGHTER_TEST_ACTOR_URL
)
;
const
actorRegistryObserver
=
subject
=
>
{
const
actorRegistry
=
subject
.
wrappedJSObject
;
actorRegistry
.
registerModule
(
HIGHLIGHTER_TEST_ACTOR_URL
{
prefix
:
"
highlighterTest
"
constructor
:
"
HighlighterTestActor
"
type
:
{
target
:
true
}
}
)
;
}
;
Services
.
obs
.
addObserver
(
actorRegistryObserver
"
devtools
-
server
-
initialized
"
)
;
const
unloadListener
=
(
)
=
>
{
Services
.
cpmm
.
removeMessageListener
(
"
remove
-
devtools
-
testactor
-
observer
"
unloadListener
)
;
Services
.
obs
.
removeObserver
(
actorRegistryObserver
"
devtools
-
server
-
initialized
"
)
;
}
;
Services
.
cpmm
.
addMessageListener
(
"
remove
-
devtools
-
testactor
-
observer
"
unloadListener
)
;
}
if
(
isMochitest
)
{
const
highlighterTestActorBootstrapScript
=
"
data
:
(
"
+
highlighterTestActorBootstrap
+
"
)
(
)
"
;
Services
.
ppmm
.
loadProcessScript
(
highlighterTestActorBootstrapScript
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
ppmm
.
broadcastAsyncMessage
(
"
remove
-
devtools
-
testactor
-
observer
"
)
;
Services
.
ppmm
.
removeDelayedProcessScript
(
highlighterTestActorBootstrapScript
)
;
}
)
;
}
async
function
getHighlighterTestFront
(
toolbox
{
target
}
=
{
}
)
{
const
inspector
=
await
toolbox
.
loadTool
(
"
inspector
"
)
;
const
highlighterTestFront
=
await
(
target
|
|
toolbox
.
target
)
.
getFront
(
"
highlighterTest
"
)
;
highlighterTestFront
.
highlighter
=
(
)
=
>
{
return
inspector
.
highlighters
.
getActiveHighlighter
(
inspector
.
highlighters
.
TYPES
.
BOXMODEL
)
;
}
;
return
highlighterTestFront
;
}
async
function
getHighlighterTestFrontWithoutToolbox
(
tab
)
{
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
const
targetFront
=
commands
.
targetCommand
.
targetFront
;
return
targetFront
.
getFront
(
"
highlighterTest
"
)
;
}
function
waitForAllTargetsToBeAttached
(
targetCommand
)
{
return
Promise
.
allSettled
(
targetCommand
.
getAllTargets
(
targetCommand
.
ALL_TYPES
)
.
map
(
target
=
>
target
.
initialized
)
)
;
}
async
function
addTab
(
url
options
=
{
}
)
{
info
(
"
Adding
a
new
tab
with
URL
:
"
+
url
)
;
const
{
background
=
false
userContextId
preferredRemoteType
waitForLoad
=
true
}
=
options
;
const
{
gBrowser
}
=
options
.
window
?
options
.
window
:
window
;
const
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
url
{
userContextId
preferredRemoteType
}
)
;
if
(
!
background
)
{
gBrowser
.
selectedTab
=
tab
;
}
if
(
waitForLoad
)
{
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
await
waitForPresShell
(
tab
.
linkedBrowser
)
;
info
(
"
Tab
added
and
finished
loading
"
)
;
}
else
{
info
(
"
Tab
added
"
)
;
}
return
tab
;
}
async
function
removeTab
(
tab
)
{
info
(
"
Removing
tab
.
"
)
;
const
{
gBrowser
}
=
tab
.
ownerDocument
.
defaultView
;
const
onClose
=
once
(
gBrowser
.
tabContainer
"
TabClose
"
)
;
gBrowser
.
removeTab
(
tab
)
;
await
onClose
;
info
(
"
Tab
removed
and
finished
closing
"
)
;
}
async
function
reloadBrowser
(
{
browser
=
gBrowser
.
selectedBrowser
isErrorPage
=
false
waitForLoad
=
true
}
=
{
}
)
{
return
navigateTo
(
browser
.
currentURI
.
spec
{
browser
isErrorPage
waitForLoad
}
)
;
}
async
function
navigateTo
(
uri
{
browser
=
gBrowser
.
selectedBrowser
isErrorPage
=
false
waitForLoad
=
true
}
=
{
}
)
{
const
waitForDevToolsReload
=
await
watchForDevToolsReload
(
browser
{
isErrorPage
waitForLoad
}
)
;
uri
=
uri
.
replaceAll
(
"
\
n
"
"
"
)
;
info
(
Navigating
to
"
{
uri
}
"
)
;
const
onBrowserLoaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
loadedUrl
=
>
{
return
loadedUrl
=
=
=
uri
|
|
decodeURI
(
loadedUrl
)
=
=
=
uri
;
}
isErrorPage
)
;
if
(
uri
=
=
=
browser
.
currentURI
.
spec
)
{
gBrowser
.
reloadTab
(
gBrowser
.
getTabForBrowser
(
browser
)
)
;
}
else
{
BrowserTestUtils
.
startLoadingURIString
(
browser
uri
)
;
}
if
(
waitForLoad
)
{
info
(
Waiting
for
page
to
be
loaded
)
;
await
onBrowserLoaded
;
info
(
page
loaded
)
;
}
await
waitForDevToolsReload
(
)
;
}
async
function
watchForDevToolsReload
(
browser
{
isErrorPage
=
false
waitForLoad
=
true
}
=
{
}
)
{
const
waitForToolboxReload
=
await
_watchForToolboxReload
(
browser
{
isErrorPage
waitForLoad
}
)
;
const
waitForResponsiveReload
=
await
_watchForResponsiveReload
(
browser
{
isErrorPage
waitForLoad
}
)
;
return
async
function
(
)
{
info
(
"
Wait
for
the
toolbox
to
reload
"
)
;
await
waitForToolboxReload
(
)
;
info
(
"
Wait
for
Responsive
UI
to
reload
"
)
;
await
waitForResponsiveReload
(
)
;
}
;
}
async
function
_watchForToolboxReload
(
browser
{
isErrorPage
waitForLoad
}
=
{
}
)
{
const
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
const
toolbox
=
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
!
toolbox
)
{
return
function
(
)
{
}
;
}
const
waitForCurrentPanelReload
=
watchForCurrentPanelReload
(
toolbox
)
;
const
waitForToolboxCommandsReload
=
await
watchForCommandsReload
(
toolbox
.
commands
{
isErrorPage
waitForLoad
}
)
;
const
checkTargetSwitching
=
await
watchForTargetSwitching
(
toolbox
.
commands
browser
)
;
return
async
function
(
)
{
const
isTargetSwitching
=
checkTargetSwitching
(
)
;
info
(
Waiting
for
toolbox
commands
to
be
reloaded
)
;
await
waitForToolboxCommandsReload
(
isTargetSwitching
)
;
if
(
waitForCurrentPanelReload
)
{
info
(
Waiting
for
{
toolbox
.
currentToolId
}
to
be
reloaded
)
;
await
waitForCurrentPanelReload
(
)
;
info
(
panel
reloaded
)
;
}
}
;
}
async
function
_watchForResponsiveReload
(
browser
{
isErrorPage
waitForLoad
}
=
{
}
)
{
const
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
const
ui
=
ResponsiveUIManager
.
getResponsiveUIForTab
(
tab
)
;
if
(
!
ui
)
{
return
function
(
)
{
}
;
}
const
onResponsiveTargetSwitch
=
ui
.
once
(
"
responsive
-
ui
-
target
-
switch
-
done
"
)
;
const
waitForResponsiveCommandsReload
=
await
watchForCommandsReload
(
ui
.
commands
{
isErrorPage
waitForLoad
}
)
;
const
checkTargetSwitching
=
await
watchForTargetSwitching
(
ui
.
commands
browser
)
;
return
async
function
(
)
{
const
isTargetSwitching
=
checkTargetSwitching
(
)
;
info
(
Waiting
for
responsive
ui
commands
to
be
reloaded
)
;
await
waitForResponsiveCommandsReload
(
isTargetSwitching
)
;
if
(
isTargetSwitching
)
{
await
onResponsiveTargetSwitch
;
}
}
;
}
function
watchForCurrentPanelReload
(
toolbox
)
{
return
_watchForPanelReload
(
toolbox
toolbox
.
currentToolId
)
;
}
function
watchForLoadedPanelsReload
(
toolbox
)
{
const
waitForPanels
=
[
]
;
for
(
const
[
id
]
of
toolbox
.
getToolPanels
(
)
)
{
waitForPanels
.
push
(
_watchForPanelReload
(
toolbox
id
)
)
;
}
return
function
(
)
{
return
Promise
.
all
(
waitForPanels
.
map
(
async
watchPanel
=
>
{
if
(
watchPanel
)
{
await
watchPanel
(
)
;
}
}
)
)
;
}
;
}
function
_watchForPanelReload
(
toolbox
toolId
)
{
const
panel
=
toolbox
.
getPanel
(
toolId
)
;
if
(
toolId
=
=
"
inspector
"
)
{
const
markuploaded
=
panel
.
once
(
"
markuploaded
"
)
;
const
onNewRoot
=
panel
.
once
(
"
new
-
root
"
)
;
const
onUpdated
=
panel
.
once
(
"
inspector
-
updated
"
)
;
const
onReloaded
=
panel
.
once
(
"
reloaded
"
)
;
return
async
function
(
)
{
info
(
"
Waiting
for
markup
view
to
load
after
navigation
.
"
)
;
await
markuploaded
;
info
(
"
Waiting
for
new
root
.
"
)
;
await
onNewRoot
;
info
(
"
Waiting
for
inspector
to
update
after
new
-
root
event
.
"
)
;
await
onUpdated
;
info
(
"
Waiting
for
inspector
updates
after
page
reload
"
)
;
await
onReloaded
;
}
;
}
else
if
(
[
"
netmonitor
"
"
accessibility
"
"
webconsole
"
"
jsdebugger
"
]
.
includes
(
toolId
)
)
{
const
onReloaded
=
panel
.
once
(
"
reloaded
"
)
;
return
async
function
(
)
{
info
(
Waiting
for
{
toolId
}
updates
after
page
reload
)
;
await
onReloaded
;
}
;
}
return
null
;
}
async
function
watchForCommandsReload
(
commands
{
isErrorPage
=
false
waitForLoad
=
true
}
=
{
}
)
{
const
onTargetSwitched
=
commands
.
targetCommand
.
once
(
"
switched
-
target
"
)
;
const
waitForCompleteLoad
=
waitForLoad
&
&
!
isErrorPage
;
const
documentEventName
=
waitForCompleteLoad
?
"
dom
-
complete
"
:
"
dom
-
loading
"
;
const
{
onResource
:
onTopLevelDomEvent
}
=
await
commands
.
resourceCommand
.
waitForNextResource
(
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
ignoreExistingResources
:
true
predicate
:
resource
=
>
resource
.
targetFront
.
isTopLevel
&
&
resource
.
name
=
=
=
documentEventName
}
)
;
return
async
function
(
isTargetSwitching
)
{
if
(
typeof
isTargetSwitching
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
isTargetSwitching
was
not
provided
to
the
wait
method
"
)
;
}
if
(
isTargetSwitching
)
{
info
(
Waiting
for
target
switch
)
;
await
onTargetSwitched
;
info
(
switched
-
target
emitted
)
;
}
info
(
Waiting
for
'
{
documentEventName
}
'
resource
)
;
await
onTopLevelDomEvent
;
info
(
'
{
documentEventName
}
'
resource
emitted
)
;
return
isTargetSwitching
;
}
;
}
async
function
watchForTargetSwitching
(
commands
browser
)
{
browser
=
browser
|
|
gBrowser
.
selectedBrowser
;
const
currentPID
=
browser
.
browsingContext
.
currentWindowGlobal
.
osPid
;
const
currentBrowsingContextID
=
browser
.
browsingContext
.
id
;
const
targetFollowsWindowLifecycle
=
commands
.
targetCommand
.
targetFront
.
targetForm
.
followWindowGlobalLifeCycle
;
return
function
(
)
{
const
switchedProcess
=
currentPID
!
=
=
browser
.
browsingContext
.
currentWindowGlobal
.
osPid
;
const
switchedBrowsingContext
=
currentBrowsingContextID
!
=
=
browser
.
browsingContext
.
id
;
return
(
targetFollowsWindowLifecycle
|
|
switchedProcess
|
|
switchedBrowsingContext
)
;
}
;
}
async
function
createAndAttachTargetForTab
(
tab
)
{
info
(
"
Creating
and
attaching
to
a
local
tab
target
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
const
target
=
commands
.
targetCommand
.
targetFront
;
return
target
;
}
function
isFissionEnabled
(
)
{
return
SpecialPowers
.
useRemoteSubframes
;
}
function
isEveryFrameTargetEnabled
(
)
{
return
Services
.
prefs
.
getBoolPref
(
"
devtools
.
every
-
frame
-
target
.
enabled
"
false
)
;
}
async
function
openInspectorForURL
(
url
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
const
{
inspector
toolbox
highlighterTestFront
}
=
await
openInspector
(
hostType
)
;
return
{
tab
inspector
toolbox
highlighterTestFront
}
;
}
function
getActiveInspector
(
)
{
const
toolbox
=
gDevTools
.
getToolboxForTab
(
gBrowser
.
selectedTab
)
;
return
toolbox
.
getPanel
(
"
inspector
"
)
;
}
function
synthesizeKeyShortcut
(
key
target
)
{
const
shortcut
=
KeyShortcuts
.
parseElectronKey
(
key
)
;
const
keyEvent
=
{
altKey
:
shortcut
.
alt
ctrlKey
:
shortcut
.
ctrl
metaKey
:
shortcut
.
meta
shiftKey
:
shortcut
.
shift
}
;
if
(
shortcut
.
keyCode
)
{
keyEvent
.
keyCode
=
shortcut
.
keyCode
;
}
info
(
"
Synthesizing
key
shortcut
:
"
+
key
)
;
EventUtils
.
synthesizeKey
(
shortcut
.
key
|
|
"
"
keyEvent
target
)
;
}
var
waitForTime
=
DevToolsUtils
.
waitForTime
;
function
waitForTick
(
)
{
return
new
Promise
(
resolve
=
>
DevToolsUtils
.
executeSoon
(
resolve
)
)
;
}
function
wait
(
ms
)
{
return
new
Promise
(
resolve
=
>
{
setTimeout
(
resolve
ms
)
;
info
(
"
Waiting
"
+
ms
/
1000
+
"
seconds
.
"
)
;
}
)
;
}
async
function
waitFor
(
condition
message
=
"
"
interval
=
10
maxTries
=
500
)
{
interval
=
typeof
waitFor
.
overrideIntervalForTestFile
!
=
=
"
undefined
"
?
waitFor
.
overrideIntervalForTestFile
:
interval
;
maxTries
=
typeof
waitFor
.
overrideMaxTriesForTestFile
!
=
=
"
undefined
"
?
waitFor
.
overrideMaxTriesForTestFile
:
maxTries
;
try
{
const
value
=
await
BrowserTestUtils
.
waitForCondition
(
condition
message
interval
maxTries
)
;
return
value
;
}
catch
(
e
)
{
const
errorMessage
=
Failed
waitFor
(
)
:
{
message
}
\
nFailed
condition
:
{
condition
}
\
nException
Message
:
{
e
}
;
throw
new
Error
(
errorMessage
)
;
}
}
function
waitForNEvents
(
target
eventName
numTimes
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
count
=
0
;
return
new
Promise
(
resolve
=
>
{
for
(
const
[
add
remove
]
of
[
[
"
on
"
"
off
"
]
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
addMessageListener
"
"
removeMessageListener
"
]
]
)
{
if
(
add
in
target
&
&
remove
in
target
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
args
)
{
if
(
typeof
info
=
=
=
"
function
"
)
{
info
(
"
Got
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
}
if
(
+
+
count
=
=
numTimes
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
resolve
(
.
.
.
args
)
;
}
}
useCapture
)
;
break
;
}
}
}
)
;
}
function
waitForDOM
(
target
selector
expectedLength
=
1
)
{
return
new
Promise
(
resolve
=
>
{
const
observer
=
new
MutationObserver
(
mutations
=
>
{
mutations
.
forEach
(
mutation
=
>
{
const
elements
=
mutation
.
target
.
querySelectorAll
(
selector
)
;
if
(
elements
.
length
=
=
=
expectedLength
)
{
observer
.
disconnect
(
)
;
resolve
(
elements
)
;
}
}
)
;
}
)
;
observer
.
observe
(
target
{
attributes
:
true
childList
:
true
subtree
:
true
}
)
;
}
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
return
waitForNEvents
(
target
eventName
1
useCapture
)
;
}
function
loadHelperScript
(
filePath
)
{
const
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
"
+
filePath
this
)
;
}
async
function
openToolboxForTab
(
tab
toolId
hostType
)
{
info
(
"
Opening
the
toolbox
"
)
;
let
toolbox
=
gDevTools
.
getToolboxForTab
(
tab
)
;
if
(
toolbox
)
{
if
(
!
toolId
|
|
(
toolId
&
&
toolbox
.
getPanel
(
toolId
)
)
)
{
info
(
"
Toolbox
is
already
opened
"
)
;
return
toolbox
;
}
}
toolbox
=
await
gDevTools
.
showToolboxForTab
(
tab
{
toolId
hostType
}
)
;
await
new
Promise
(
resolve
=
>
waitForFocus
(
resolve
toolbox
.
win
)
)
;
info
(
"
Toolbox
opened
and
focused
"
)
;
return
toolbox
;
}
async
function
openNewTabAndToolbox
(
url
toolId
hostType
)
{
const
tab
=
await
addTab
(
url
)
;
return
openToolboxForTab
(
tab
toolId
hostType
)
;
}
async
function
closeTabAndToolbox
(
tab
=
gBrowser
.
selectedTab
)
{
if
(
gDevTools
.
hasToolboxForTab
(
tab
)
)
{
await
gDevTools
.
closeToolboxForTab
(
tab
)
;
}
await
removeTab
(
tab
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
}
async
function
closeToolboxAndTab
(
toolbox
)
{
await
toolbox
.
destroy
(
)
;
await
removeTab
(
gBrowser
.
selectedTab
)
;
}
function
waitUntil
(
predicate
interval
=
10
)
{
if
(
predicate
(
)
)
{
return
Promise
.
resolve
(
true
)
;
}
return
new
Promise
(
resolve
=
>
{
setTimeout
(
function
(
)
{
waitUntil
(
predicate
interval
)
.
then
(
(
)
=
>
resolve
(
true
)
)
;
}
interval
)
;
}
)
;
}
async
function
asyncWaitUntil
(
predicate
interval
=
10
)
{
let
success
=
await
predicate
(
)
;
while
(
!
success
)
{
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
interval
)
)
;
success
=
await
predicate
(
)
;
}
}
function
waitForContextMenu
(
popup
button
onShown
onHidden
)
{
return
new
Promise
(
resolve
=
>
{
function
onPopupShown
(
)
{
info
(
"
onPopupShown
"
)
;
popup
.
removeEventListener
(
"
popupshown
"
onPopupShown
)
;
onShown
&
&
onShown
(
)
;
popup
.
addEventListener
(
"
popuphidden
"
onPopupHidden
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
popup
.
hidePopup
(
)
)
;
}
function
onPopupHidden
(
)
{
info
(
"
onPopupHidden
"
)
;
popup
.
removeEventListener
(
"
popuphidden
"
onPopupHidden
)
;
onHidden
&
&
onHidden
(
)
;
resolve
(
popup
)
;
}
popup
.
addEventListener
(
"
popupshown
"
onPopupShown
)
;
info
(
"
wait
for
the
context
menu
to
open
"
)
;
synthesizeContextMenuEvent
(
button
)
;
}
)
;
}
function
synthesizeContextMenuEvent
(
el
)
{
el
.
scrollIntoView
(
)
;
const
eventDetails
=
{
type
:
"
contextmenu
"
button
:
2
}
;
EventUtils
.
synthesizeMouse
(
el
5
2
eventDetails
el
.
ownerDocument
.
defaultView
)
;
}
function
waitForClipboardPromise
(
setup
expected
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
SimpleTest
.
waitForClipboard
(
expected
setup
resolve
reject
)
;
}
)
;
}
function
pushPref
(
preferenceName
value
)
{
const
options
=
{
set
:
[
[
preferenceName
value
]
]
}
;
return
SpecialPowers
.
pushPrefEnv
(
options
)
;
}
async
function
closeToolbox
(
)
{
await
gDevTools
.
closeToolboxForTab
(
gBrowser
.
selectedTab
)
;
}
function
emptyClipboard
(
)
{
const
clipboard
=
Services
.
clipboard
;
clipboard
.
emptyClipboard
(
clipboard
.
kGlobalClipboard
)
;
}
function
isWindows
(
)
{
return
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
;
}
function
createTestHTTPServer
(
)
{
const
{
HttpServer
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
httpd
.
sys
.
mjs
"
)
;
const
server
=
new
HttpServer
(
)
;
registerCleanupFunction
(
async
function
cleanup
(
)
{
await
new
Promise
(
resolve
=
>
server
.
stop
(
resolve
)
)
;
}
)
;
server
.
start
(
-
1
)
;
return
server
;
}
async
function
registerActorInContentProcess
(
url
options
)
{
function
convertChromeToFile
(
uri
)
{
return
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
.
convertChromeURL
(
Services
.
io
.
newURI
(
uri
)
)
.
spec
;
}
url
=
url
.
startsWith
(
"
chrome
:
/
/
mochitests
"
)
?
convertChromeToFile
(
url
)
:
url
;
return
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
url
options
}
]
args
=
>
{
const
{
require
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
Loader
.
sys
.
mjs
"
)
;
const
{
ActorRegistry
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
utils
/
actor
-
registry
.
js
"
)
;
ActorRegistry
.
registerModule
(
args
.
url
args
.
options
)
;
}
)
;
}
async
function
moveWindowTo
(
win
left
top
)
{
left
=
Math
.
max
(
win
.
screen
.
availLeft
left
)
;
left
=
Math
.
min
(
win
.
screen
.
width
left
)
;
top
=
Math
.
max
(
win
.
screen
.
availTop
top
)
;
top
=
Math
.
min
(
win
.
screen
.
height
top
)
;
info
(
Moving
window
to
{
{
left
}
{
top
}
}
)
;
win
.
moveTo
(
left
top
)
;
return
waitUntil
(
(
)
=
>
{
info
(
Wait
for
window
screenLeft
and
screenTop
to
be
updated
:
(
{
win
.
screenLeft
}
{
win
.
screenTop
}
)
)
;
return
win
.
screenLeft
=
=
=
left
&
&
win
.
screenTop
=
=
=
top
;
}
)
;
}
function
getCurrentTestFilePath
(
)
{
return
gTestPath
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
"
"
)
;
}
async
function
unregisterAllServiceWorkers
(
client
)
{
info
(
"
Wait
until
all
workers
have
a
valid
registrationFront
"
)
;
let
workers
;
await
asyncWaitUntil
(
async
function
(
)
{
workers
=
await
client
.
mainRoot
.
listAllWorkers
(
)
;
const
allWorkersRegistered
=
workers
.
service
.
every
(
worker
=
>
!
!
worker
.
registrationFront
)
;
return
allWorkersRegistered
;
}
)
;
info
(
"
Unregister
all
service
workers
"
)
;
const
promises
=
[
]
;
for
(
const
worker
of
workers
.
service
)
{
promises
.
push
(
worker
.
registrationFront
.
unregister
(
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
function
colorAt
(
image
x
y
)
{
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
canvas
=
document
.
createElementNS
(
HTML_NS
"
canvas
"
)
;
canvas
.
width
=
image
.
width
;
canvas
.
height
=
image
.
height
;
const
context
=
canvas
.
getContext
(
"
2d
"
)
;
context
.
drawImage
(
image
0
0
image
.
width
image
.
height
)
;
const
[
r
g
b
]
=
context
.
getImageData
(
x
y
1
1
)
.
data
;
return
{
r
g
b
}
;
}
let
allDownloads
=
[
]
;
async
function
waitUntilScreenshot
(
{
isWindowPrivate
=
false
}
=
{
}
)
{
const
{
Downloads
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
sys
.
mjs
"
)
;
const
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
return
new
Promise
(
function
(
resolve
)
{
const
view
=
{
onDownloadAdded
:
async
download
=
>
{
await
download
.
whenSucceeded
(
)
;
if
(
allDownloads
.
includes
(
download
)
)
{
return
;
}
is
(
!
!
download
.
source
.
isPrivate
isWindowPrivate
The
download
occured
in
the
expected
{
isWindowPrivate
?
"
private
"
:
"
"
}
window
)
;
allDownloads
.
push
(
download
)
;
resolve
(
download
.
target
.
path
)
;
list
.
removeView
(
view
)
;
}
}
;
list
.
addView
(
view
)
;
}
)
;
}
async
function
resetDownloads
(
)
{
info
(
"
Reset
downloads
"
)
;
const
{
Downloads
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
sys
.
mjs
"
)
;
const
downloadList
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
const
downloads
=
await
downloadList
.
getAll
(
)
;
for
(
const
download
of
downloads
)
{
downloadList
.
remove
(
download
)
;
await
download
.
finalize
(
true
)
;
}
allDownloads
=
[
]
;
}
async
function
takeNodeScreenshot
(
inspector
)
{
registerCleanupFunction
(
resetDownloads
)
;
info
(
"
Call
screenshotNode
(
)
and
wait
until
the
screenshot
is
found
in
the
Downloads
"
)
;
const
whenScreenshotSucceeded
=
waitUntilScreenshot
(
)
;
inspector
.
screenshotNode
(
)
;
const
filePath
=
await
whenScreenshotSucceeded
;
info
(
"
Create
an
image
using
the
downloaded
fileas
source
"
)
;
const
image
=
new
Image
(
)
;
const
onImageLoad
=
once
(
image
"
load
"
)
;
image
.
src
=
PathUtils
.
toFileURI
(
filePath
)
;
await
onImageLoad
;
info
(
"
Remove
the
downloaded
screenshot
file
"
)
;
await
IOUtils
.
remove
(
filePath
)
;
info
(
"
Wait
for
one
second
to
make
sure
future
screenshots
will
use
a
different
name
"
)
;
await
new
Promise
(
r
=
>
setTimeout
(
r
1000
)
)
;
return
image
;
}
async
function
assertSingleColorScreenshotImage
(
image
width
height
{
r
g
b
}
)
{
info
(
Assert
{
image
.
src
}
content
)
;
const
ratio
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
(
)
=
>
content
.
wrappedJSObject
.
devicePixelRatio
)
;
is
(
image
.
width
ratio
*
width
node
screenshot
has
the
expected
width
(
dpr
=
{
ratio
}
)
)
;
is
(
image
.
height
height
*
ratio
node
screenshot
has
the
expected
height
(
dpr
=
{
ratio
}
)
)
;
const
color
=
colorAt
(
image
0
0
)
;
is
(
color
.
r
r
"
node
screenshot
has
the
expected
red
component
"
)
;
is
(
color
.
g
g
"
node
screenshot
has
the
expected
green
component
"
)
;
is
(
color
.
b
b
"
node
screenshot
has
the
expected
blue
component
"
)
;
}
function
checkImageColorAt
(
{
image
x
=
0
y
expectedColor
label
}
)
{
const
color
=
colorAt
(
image
x
y
)
;
is
(
rgb
(
{
Object
.
values
(
color
)
.
join
(
"
"
)
}
)
expectedColor
label
)
;
}
function
waitUntilState
(
store
predicate
)
{
return
new
Promise
(
resolve
=
>
{
const
unsubscribe
=
store
.
subscribe
(
check
)
;
info
(
Waiting
for
state
predicate
"
{
predicate
}
"
)
;
function
check
(
)
{
if
(
predicate
(
store
.
getState
(
)
)
)
{
info
(
Found
state
predicate
"
{
predicate
}
"
)
;
unsubscribe
(
)
;
resolve
(
)
;
}
}
check
(
)
;
}
)
;
}
function
waitForDispatch
(
store
actionType
repeat
=
1
)
{
let
count
=
0
;
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
{
const
isDone
=
!
action
.
status
|
|
action
.
status
=
=
=
"
done
"
|
|
action
.
status
=
=
=
"
error
"
;
if
(
action
.
type
=
=
=
actionType
&
&
isDone
&
&
+
+
count
=
=
repeat
)
{
return
true
;
}
return
false
;
}
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
async
function
getBrowsingContextInFrames
(
browsingContext
selectors
)
{
let
context
=
browsingContext
;
if
(
!
Array
.
isArray
(
selectors
)
)
{
throw
new
Error
(
"
getBrowsingContextInFrames
called
with
an
invalid
selectors
argument
"
)
;
}
if
(
selectors
.
length
=
=
=
0
)
{
throw
new
Error
(
"
getBrowsingContextInFrames
called
with
an
empty
selectors
array
"
)
;
}
const
clonedSelectors
=
[
.
.
.
selectors
]
;
while
(
clonedSelectors
.
length
)
{
const
selector
=
clonedSelectors
.
shift
(
)
;
context
=
await
SpecialPowers
.
spawn
(
context
[
selector
]
_selector
=
>
{
return
content
.
document
.
querySelector
(
_selector
)
.
browsingContext
;
}
)
;
}
return
context
;
}
async
function
safeSynthesizeMouseEventInContentPage
(
selector
x
y
options
=
{
}
)
{
let
context
=
gBrowser
.
selectedBrowser
.
browsingContext
;
if
(
Array
.
isArray
(
selector
)
)
{
if
(
selector
.
length
=
=
=
1
)
{
selector
=
selector
[
0
]
;
}
else
{
context
=
await
getBrowsingContextInFrames
(
context
selector
.
slice
(
0
-
1
)
)
;
selector
=
selector
.
at
(
-
1
)
;
}
}
await
scrollContentPageNodeIntoView
(
context
selector
)
;
BrowserTestUtils
.
synthesizeMouse
(
selector
x
y
options
context
)
;
}
async
function
safeSynthesizeMouseEventAtCenterInContentPage
(
selector
options
=
{
}
)
{
let
context
=
gBrowser
.
selectedBrowser
.
browsingContext
;
if
(
Array
.
isArray
(
selector
)
)
{
if
(
selector
.
length
=
=
=
1
)
{
selector
=
selector
[
0
]
;
}
else
{
context
=
await
getBrowsingContextInFrames
(
context
selector
.
slice
(
0
-
1
)
)
;
selector
=
selector
.
at
(
-
1
)
;
}
}
await
scrollContentPageNodeIntoView
(
context
selector
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
selector
options
context
)
;
}
function
scrollContentPageNodeIntoView
(
browsingContext
selector
)
{
return
SpecialPowers
.
spawn
(
browsingContext
[
selector
]
function
(
innerSelector
)
{
const
node
=
content
.
wrappedJSObject
.
document
.
querySelector
(
innerSelector
)
;
node
.
scrollIntoView
(
)
;
}
)
;
}
function
setContentPageZoomLevel
(
zoomLevel
)
{
gBrowser
.
selectedBrowser
.
fullZoom
=
zoomLevel
;
}
async
function
waitForNextTopLevelDomCompleteResource
(
commands
)
{
const
{
onResource
:
onDomCompleteResource
}
=
await
commands
.
resourceCommand
.
waitForNextResource
(
commands
.
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
{
ignoreExistingResources
:
true
predicate
:
resource
=
>
resource
.
name
=
=
=
"
dom
-
complete
"
&
&
resource
.
targetFront
.
isTopLevel
}
)
;
return
{
onDomCompleteResource
}
;
}
function
waitForPresShell
(
context
)
{
return
SpecialPowers
.
spawn
(
context
[
]
async
(
)
=
>
{
const
winUtils
=
SpecialPowers
.
getDOMWindowUtils
(
content
)
;
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
try
{
return
!
!
winUtils
.
getPresShellId
(
)
;
}
catch
(
e
)
{
return
false
;
}
}
"
Waiting
for
a
valid
presShell
"
)
;
}
)
;
}
async
function
getFluentStringHelper
(
resourceIds
)
{
const
locales
=
Services
.
locale
.
appLocalesAsBCP47
;
const
generator
=
L10nRegistry
.
getInstance
(
)
.
generateBundles
(
locales
resourceIds
)
;
const
bundles
=
[
]
;
for
await
(
const
bundle
of
generator
)
{
bundles
.
push
(
bundle
)
;
}
const
reactLocalization
=
new
FluentReact
.
ReactLocalization
(
bundles
)
;
return
(
id
attributeName
args
)
=
>
{
let
string
;
if
(
!
attributeName
)
{
string
=
reactLocalization
.
getString
(
id
args
)
;
}
else
{
for
(
const
bundle
of
reactLocalization
.
bundles
)
{
const
msg
=
bundle
.
getMessage
(
id
)
;
if
(
msg
?
.
attributes
[
attributeName
]
)
{
string
=
bundle
.
formatPattern
(
msg
.
attributes
[
attributeName
]
args
[
]
)
;
break
;
}
}
}
if
(
!
string
)
{
throw
new
Error
(
Could
not
find
a
string
for
"
{
id
}
"
{
attributeName
?
and
attribute
"
{
attributeName
}
"
)
:
"
"
}
.
Was
the
correct
resource
bundle
loaded
?
)
;
}
return
string
;
}
;
}
async
function
openRDM
(
tab
{
waitForDeviceList
=
true
}
=
{
}
)
{
info
(
"
Opening
responsive
design
mode
"
)
;
const
manager
=
ResponsiveUIManager
;
const
ui
=
await
manager
.
openIfNeeded
(
tab
.
ownerGlobal
tab
{
trigger
:
"
test
"
}
)
;
info
(
"
Responsive
design
mode
opened
"
)
;
await
ResponsiveMessageHelper
.
wait
(
ui
.
toolWindow
"
post
-
init
"
)
;
info
(
"
Responsive
design
initialized
"
)
;
await
waitForRDMLoaded
(
ui
{
waitForDeviceList
}
)
;
return
{
ui
manager
}
;
}
async
function
waitForRDMLoaded
(
ui
{
waitForDeviceList
=
true
}
=
{
}
)
{
const
{
store
}
=
ui
.
toolWindow
;
await
waitUntilState
(
store
state
=
>
state
.
viewports
.
length
=
=
1
)
;
if
(
waitForDeviceList
)
{
await
waitUntilState
(
store
state
=
>
state
.
devices
.
listState
=
=
localTypes
.
loadableState
.
LOADED
)
;
}
}
async
function
closeRDM
(
tab
options
)
{
info
(
"
Closing
responsive
design
mode
"
)
;
const
manager
=
ResponsiveUIManager
;
await
manager
.
closeIfNeeded
(
tab
.
ownerGlobal
tab
options
)
;
info
(
"
Responsive
design
mode
closed
"
)
;
}
function
getInputStream
(
data
)
{
const
BufferStream
=
Components
.
Constructor
(
"
mozilla
.
org
/
io
/
arraybuffer
-
input
-
stream
;
1
"
"
nsIArrayBufferInputStream
"
"
setData
"
)
;
const
buffer
=
new
TextEncoder
(
)
.
encode
(
data
)
.
buffer
;
return
new
BufferStream
(
buffer
0
buffer
.
byteLength
)
;
}
function
waitForTargetProcessed
(
commands
isExpectedTargetFn
)
{
return
new
Promise
(
resolve
=
>
{
const
onProcessed
=
targetFront
=
>
{
try
{
if
(
isExpectedTargetFn
(
targetFront
)
)
{
commands
.
targetCommand
.
off
(
"
processed
-
available
-
target
"
onProcessed
)
;
resolve
(
)
;
}
}
catch
{
}
}
;
commands
.
targetCommand
.
on
(
"
processed
-
available
-
target
"
onProcessed
)
;
}
)
;
}
function
createVersionizedHttpTestServer
(
testFolderName
)
{
const
httpServer
=
createTestHTTPServer
(
)
;
let
currentVersion
=
1
;
httpServer
.
registerPrefixHandler
(
"
/
"
async
(
request
response
)
=
>
{
response
.
processAsync
(
)
;
response
.
setStatusLine
(
request
.
httpVersion
200
"
OK
"
)
;
if
(
request
.
path
.
endsWith
(
"
.
js
"
)
)
{
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
javascript
"
)
;
}
else
if
(
request
.
path
.
endsWith
(
"
.
js
.
map
"
)
)
{
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
)
;
}
if
(
request
.
path
=
=
"
/
"
|
|
request
.
path
.
endsWith
(
"
.
html
"
)
)
{
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
html
"
)
;
}
let
fetchResponse
;
if
(
request
.
queryString
)
{
const
url
=
{
URL_ROOT_SSL
}
{
testFolderName
}
/
v
{
currentVersion
}
{
request
.
path
}
.
{
request
.
queryString
}
;
try
{
fetchResponse
=
await
fetch
(
url
)
;
info
(
[
test
-
http
-
server
]
serving
:
{
url
}
)
;
}
catch
(
e
)
{
fetchResponse
=
null
;
}
}
if
(
!
fetchResponse
)
{
const
url
=
{
URL_ROOT_SSL
}
{
testFolderName
}
/
v
{
currentVersion
}
{
request
.
path
}
;
info
(
[
test
-
http
-
server
]
serving
:
{
url
}
)
;
fetchResponse
=
await
fetch
(
url
)
;
}
for
(
const
[
name
value
]
of
fetchResponse
.
headers
.
entries
(
)
)
{
response
.
setHeader
(
name
value
)
;
}
response
.
setHeader
(
"
Cache
-
Control
"
"
no
-
store
"
)
;
const
text
=
await
fetchResponse
.
text
(
)
;
response
.
write
(
text
)
;
response
.
finish
(
)
;
}
)
;
return
{
switchToNextVersion
(
)
{
currentVersion
+
+
;
}
backToFirstVersion
(
)
{
currentVersion
=
1
;
}
urlFor
(
path
)
{
const
port
=
httpServer
.
identity
.
primaryPort
;
return
http
:
/
/
localhost
:
{
port
}
/
{
path
}
;
}
}
;
}
function
simulateLinkClick
(
element
)
{
const
browserWindow
=
Services
.
wm
.
getMostRecentWindow
(
gDevTools
.
chromeWindowType
)
;
const
onOpenLink
=
new
Promise
(
resolve
=
>
{
const
openLinkIn
=
(
link
where
)
=
>
resolve
(
{
link
where
}
)
;
sinon
.
replace
(
browserWindow
"
openTrustedLinkIn
"
openLinkIn
)
;
sinon
.
replace
(
browserWindow
"
openWebLinkIn
"
openLinkIn
)
;
}
)
;
element
.
click
(
)
;
const
onTimeout
=
new
Promise
(
function
(
resolve
)
{
setTimeout
(
(
)
=
>
{
resolve
(
{
link
:
null
where
:
null
}
)
;
}
1000
)
;
}
)
;
const
raceResult
=
Promise
.
race
(
[
onOpenLink
onTimeout
]
)
;
sinon
.
restore
(
)
;
return
raceResult
;
}
function
logCssCompatDataPropertiesWithoutMDNUrl
(
)
{
const
cssPropertiesCompatData
=
require
(
"
resource
:
/
/
devtools
/
shared
/
compatibility
/
dataset
/
css
-
properties
.
json
"
)
;
function
walk
(
node
)
{
for
(
const
propertyName
in
node
)
{
const
property
=
node
[
propertyName
]
;
if
(
property
.
__compat
)
{
if
(
!
property
.
__compat
.
mdn_url
)
{
dump
(
"
{
propertyName
}
"
-
MDN
URL
:
{
property
.
__compat
.
mdn_url
|
|
"
"
}
-
Spec
URL
:
{
property
.
__compat
.
spec_url
|
|
"
"
}
\
n
)
;
}
}
else
if
(
typeof
property
=
=
"
object
"
)
{
walk
(
property
)
;
}
}
}
walk
(
cssPropertiesCompatData
)
;
}
function
getClientCssProperties
(
)
{
const
{
generateCssProperties
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
css
-
properties
.
js
"
)
;
const
{
CssProperties
normalizeCssData
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
fronts
/
css
-
properties
.
js
"
)
;
return
new
CssProperties
(
normalizeCssData
(
{
properties
:
generateCssProperties
(
document
)
}
)
)
;
}
async
function
stopServiceWorker
(
workerUrl
)
{
info
(
Stop
Service
Worker
:
{
workerUrl
}
\
n
)
;
Services
.
prefs
.
setIntPref
(
"
dom
.
serviceWorkers
.
idle_timeout
"
0
)
;
const
swm
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
const
registrations
=
swm
.
getAllRegistrations
(
)
;
let
matchedInfo
;
for
(
let
i
=
0
;
i
<
registrations
.
length
;
i
+
+
)
{
const
info
=
registrations
.
queryElementAt
(
i
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
if
(
info
.
scriptSpec
=
=
=
workerUrl
)
{
matchedInfo
=
info
;
break
;
}
}
ok
(
!
!
matchedInfo
"
Found
the
service
worker
info
"
)
;
info
(
"
Wait
for
the
worker
to
be
active
"
)
;
await
waitFor
(
(
)
=
>
matchedInfo
.
activeWorker
"
Wait
for
the
SW
to
be
active
"
)
;
function
resetWorkerTimeout
(
worker
)
{
worker
.
attachDebugger
(
)
;
worker
.
detachDebugger
(
)
;
}
resetWorkerTimeout
(
matchedInfo
.
activeWorker
)
;
if
(
matchedInfo
.
evaluatingWorker
)
{
resetWorkerTimeout
(
matchedInfo
.
evaluatingWorker
)
;
}
if
(
matchedInfo
.
installingWorker
)
{
resetWorkerTimeout
(
matchedInfo
.
installingWorker
)
;
}
if
(
matchedInfo
.
waitingWorker
)
{
resetWorkerTimeout
(
matchedInfo
.
waitingWorker
)
;
}
Services
.
prefs
.
clearUserPref
(
"
dom
.
serviceWorkers
.
idle_timeout
"
)
;
await
wait
(
0
)
;
return
matchedInfo
;
}
async
function
unregisterServiceWorker
(
workerUrl
)
{
const
swInfo
=
await
stopServiceWorker
(
workerUrl
)
;
info
(
Unregister
Service
Worker
:
{
workerUrl
}
\
n
)
;
const
swm
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
const
unregisterSuccess
=
await
new
Promise
(
resolve
=
>
{
swm
.
unregister
(
swInfo
.
principal
{
unregisterSucceeded
(
success
)
{
resolve
(
success
)
;
}
}
swInfo
.
scope
)
;
}
)
;
ok
(
unregisterSuccess
"
Service
worker
successfully
unregistered
"
)
;
}
async
function
toggleJsTracer
(
toolbox
)
{
const
{
tracerCommand
}
=
toolbox
.
commands
;
const
{
isTracingEnabled
}
=
tracerCommand
;
const
{
logMethod
traceOnNextInteraction
traceOnNextLoad
}
=
toolbox
.
commands
.
tracerCommand
.
getTracingOptions
(
)
;
const
shouldWaitForToggle
=
!
traceOnNextInteraction
&
&
!
traceOnNextLoad
;
let
onTracingToggled
;
if
(
shouldWaitForToggle
)
{
onTracingToggled
=
new
Promise
(
resolve
=
>
{
tracerCommand
.
on
(
"
toggle
"
async
function
listener
(
)
{
if
(
tracerCommand
.
isTracingActive
=
=
isTracingEnabled
)
{
return
;
}
tracerCommand
.
off
(
"
toggle
"
listener
)
;
resolve
(
)
;
}
)
;
}
)
;
}
const
toolbarButton
=
toolbox
.
doc
.
getElementById
(
"
command
-
button
-
jstracer
"
)
;
toolbarButton
.
click
(
)
;
if
(
shouldWaitForToggle
)
{
info
(
"
Waiting
for
the
tracer
to
be
active
"
)
;
await
onTracingToggled
;
}
const
{
TRACER_LOG_METHODS
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
tracer
.
js
"
)
;
if
(
logMethod
!
=
TRACER_LOG_METHODS
.
CONSOLE
)
{
return
;
}
if
(
isTracingEnabled
)
{
const
{
hud
}
=
await
toolbox
.
getPanel
(
"
webconsole
"
)
;
info
(
"
Wait
for
tracing
to
be
disabled
"
)
;
await
waitFor
(
(
)
=
>
[
.
.
.
hud
.
ui
.
outputNode
.
querySelectorAll
(
"
.
message
"
)
]
.
some
(
msg
=
>
msg
.
textContent
.
includes
(
"
Stopped
tracing
"
)
)
)
;
hud
.
ui
.
clearOutput
(
)
;
await
waitFor
(
(
)
=
>
hud
.
ui
.
outputNode
.
querySelectorAll
(
"
.
message
"
)
.
length
=
=
=
0
)
;
}
else
{
const
{
hud
}
=
await
toolbox
.
getPanelWhenReady
(
"
webconsole
"
)
;
if
(
!
traceOnNextInteraction
&
&
!
traceOnNextLoad
)
{
await
waitFor
(
(
)
=
>
[
.
.
.
hud
.
ui
.
outputNode
.
querySelectorAll
(
"
.
message
"
)
]
.
some
(
msg
=
>
msg
.
textContent
.
includes
(
"
Started
tracing
to
Web
Console
"
)
)
)
;
}
}
}
