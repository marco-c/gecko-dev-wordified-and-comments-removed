"
use
strict
"
;
const
Babel
=
require
(
"
.
/
babel
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
_path
=
require
(
"
path
"
)
;
const
mappings
=
{
react
:
"
devtools
/
client
/
shared
/
vendor
/
react
"
"
react
-
dom
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
"
react
-
dom
-
factories
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
"
react
-
redux
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
"
prop
-
types
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
"
wasmparser
/
dist
/
cjs
/
WasmParser
"
:
"
devtools
/
client
/
shared
/
vendor
/
WasmParser
"
"
wasmparser
/
dist
/
cjs
/
WasmDis
"
:
"
devtools
/
client
/
shared
/
vendor
/
WasmDis
"
}
;
const
mappingValues
=
Object
.
values
(
mappings
)
;
function
isRequire
(
t
node
)
{
return
node
&
&
t
.
isCallExpression
(
node
)
&
&
node
.
callee
.
name
=
=
"
require
"
;
}
function
shouldLazyLoad
(
value
)
{
return
(
!
value
.
includes
(
"
codemirror
/
"
)
&
&
!
value
.
endsWith
(
"
.
properties
"
)
&
&
!
value
.
startsWith
(
"
devtools
/
"
)
&
&
value
!
=
=
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
}
function
transformMC
(
{
types
:
t
}
)
{
return
{
visitor
:
{
ModuleDeclaration
(
path
state
)
{
const
source
=
path
.
node
.
source
;
const
value
=
source
&
&
source
.
value
;
if
(
value
&
&
value
.
includes
(
"
.
css
"
)
)
{
path
.
remove
(
)
;
}
}
StringLiteral
(
path
state
)
{
const
{
filePath
}
=
state
.
opts
;
let
value
=
path
.
node
.
value
;
if
(
!
isRequire
(
t
path
.
parent
)
)
{
return
;
}
if
(
Object
.
keys
(
mappings
)
.
includes
(
value
)
)
{
path
.
replaceWith
(
t
.
stringLiteral
(
mappings
[
value
]
)
)
;
return
;
}
const
dir
=
_path
.
dirname
(
filePath
)
;
const
depPath
=
_path
.
join
(
dir
{
value
}
.
js
)
;
const
exists
=
fs
.
existsSync
(
depPath
)
;
if
(
!
exists
&
&
!
value
.
endsWith
(
"
index
"
)
&
&
!
value
.
endsWith
(
"
.
jsm
"
)
&
&
!
(
value
.
startsWith
(
"
devtools
"
)
|
|
mappingValues
.
includes
(
value
)
)
)
{
value
=
{
value
}
/
index
;
path
.
replaceWith
(
t
.
stringLiteral
(
value
)
)
;
}
if
(
shouldLazyLoad
(
value
)
)
{
const
requireCall
=
path
.
parentPath
;
const
declarator
=
requireCall
.
parentPath
;
const
declaration
=
declarator
.
parentPath
;
if
(
declarator
.
type
!
=
=
"
VariableDeclarator
"
)
{
return
;
}
if
(
value
.
startsWith
(
"
.
"
)
)
{
let
newValue
=
_path
.
join
(
_path
.
dirname
(
filePath
)
value
)
;
if
(
!
newValue
.
startsWith
(
"
devtools
"
)
)
{
newValue
=
newValue
.
match
(
/
^
(
.
*
?
)
(
devtools
.
*
)
/
)
[
2
]
;
}
newValue
=
newValue
.
replace
(
/
\
\
/
g
"
/
"
)
;
value
=
newValue
;
}
const
lazyRequire
=
t
.
callExpression
(
t
.
memberExpression
(
t
.
identifier
(
"
loader
"
)
t
.
identifier
(
"
lazyRequireGetter
"
)
)
[
t
.
thisExpression
(
)
t
.
stringLiteral
(
declarator
.
node
.
id
.
name
|
|
"
"
)
t
.
stringLiteral
(
value
)
]
)
;
declaration
.
replaceWith
(
lazyRequire
)
;
}
}
}
}
;
}
Babel
.
registerPlugin
(
"
transform
-
mc
"
transformMC
)
;
module
.
exports
=
function
(
filePath
)
{
return
[
"
proposal
-
class
-
properties
"
"
transform
-
modules
-
commonjs
"
[
"
transform
-
mc
"
{
mappings
filePath
}
]
]
;
}
;
