"
use
strict
"
;
const
Babel
=
require
(
"
.
/
babel
"
)
;
const
_path
=
require
(
"
path
"
)
;
function
isRequire
(
t
node
)
{
return
node
&
&
t
.
isCallExpression
(
node
)
&
&
node
.
callee
.
name
=
=
"
require
"
;
}
function
shouldLazyLoad
(
value
)
{
return
(
!
value
.
includes
(
"
codemirror
/
"
)
&
&
!
value
.
endsWith
(
"
.
properties
"
)
&
&
!
value
.
startsWith
(
"
devtools
/
"
)
&
&
value
!
=
=
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
}
function
transformMC
(
{
types
:
t
}
)
{
return
{
visitor
:
{
StringLiteral
(
path
state
)
{
const
{
filePath
}
=
state
.
opts
;
let
value
=
path
.
node
.
value
;
if
(
!
isRequire
(
t
path
.
parent
)
)
{
return
;
}
if
(
shouldLazyLoad
(
value
)
)
{
const
requireCall
=
path
.
parentPath
;
const
declarator
=
requireCall
.
parentPath
;
const
declaration
=
declarator
.
parentPath
;
if
(
declarator
.
type
!
=
=
"
VariableDeclarator
"
)
{
return
;
}
if
(
value
.
startsWith
(
"
.
"
)
)
{
let
newValue
=
_path
.
join
(
_path
.
dirname
(
filePath
)
value
)
;
if
(
!
newValue
.
startsWith
(
"
devtools
"
)
)
{
newValue
=
newValue
.
match
(
/
^
(
.
*
?
)
(
devtools
.
*
)
/
)
[
2
]
;
}
newValue
=
newValue
.
replace
(
/
\
\
/
g
"
/
"
)
;
value
=
newValue
;
}
const
lazyRequire
=
t
.
callExpression
(
t
.
memberExpression
(
t
.
identifier
(
"
loader
"
)
t
.
identifier
(
"
lazyRequireGetter
"
)
)
[
t
.
thisExpression
(
)
t
.
stringLiteral
(
declarator
.
node
.
id
.
name
|
|
"
"
)
t
.
stringLiteral
(
value
)
]
)
;
declaration
.
replaceWith
(
lazyRequire
)
;
}
}
}
}
;
}
Babel
.
registerPlugin
(
"
transform
-
mc
"
transformMC
)
;
module
.
exports
=
function
(
filePath
)
{
return
[
"
proposal
-
class
-
properties
"
"
transform
-
modules
-
commonjs
"
[
"
transform
-
mc
"
{
filePath
}
]
]
;
}
;
