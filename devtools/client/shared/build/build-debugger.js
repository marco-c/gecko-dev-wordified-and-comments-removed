"
use
strict
"
;
const
Babel
=
require
(
"
.
/
babel
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
_path
=
require
(
"
path
"
)
;
const
EXCLUDED_FILES
=
{
"
.
.
/
assets
/
panel
/
debugger
.
properties
"
:
"
devtools
/
shared
/
flags
"
"
devtools
-
connection
"
:
"
devtools
/
shared
/
flags
"
"
chrome
-
remote
-
interface
"
:
"
devtools
/
shared
/
flags
"
"
devtools
-
launchpad
"
:
"
devtools
/
shared
/
flags
"
}
;
const
mappings
=
Object
.
assign
(
{
"
.
/
source
-
editor
"
:
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
"
.
.
/
editor
/
source
-
editor
"
:
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
"
.
/
test
-
flag
"
:
"
devtools
/
shared
/
flags
"
"
.
/
fronts
-
device
"
:
"
devtools
/
shared
/
fronts
/
device
"
immutable
:
"
devtools
/
client
/
shared
/
vendor
/
immutable
"
lodash
:
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
react
:
"
devtools
/
client
/
shared
/
vendor
/
react
"
"
react
-
dom
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
"
react
-
dom
-
factories
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
"
react
-
redux
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
redux
:
"
devtools
/
client
/
shared
/
vendor
/
redux
"
reselect
:
"
devtools
/
client
/
shared
/
vendor
/
reselect
"
"
prop
-
types
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
"
devtools
-
services
"
:
"
Services
"
"
wasmparser
/
dist
/
WasmParser
"
:
"
devtools
/
client
/
shared
/
vendor
/
WasmParser
"
"
wasmparser
/
dist
/
WasmDis
"
:
"
devtools
/
client
/
shared
/
vendor
/
WasmDis
"
"
whatwg
-
url
"
:
"
devtools
/
client
/
shared
/
vendor
/
whatwg
-
url
"
}
EXCLUDED_FILES
)
;
const
mappingValues
=
Object
.
values
(
mappings
)
;
mappings
[
"
devtools
-
reps
"
]
=
"
devtools
/
client
/
shared
/
components
/
reps
/
reps
.
js
"
;
mappings
[
"
devtools
-
source
-
map
"
]
=
"
devtools
/
client
/
shared
/
source
-
map
/
index
.
js
"
;
function
isRequire
(
t
node
)
{
return
node
&
&
t
.
isCallExpression
(
node
)
&
&
node
.
callee
.
name
=
=
"
require
"
;
}
const
VENDORS
=
[
"
classnames
"
"
devtools
-
components
"
"
devtools
-
config
"
"
devtools
-
contextmenu
"
"
devtools
-
environment
"
"
devtools
-
modules
"
"
devtools
-
splitter
"
"
devtools
-
utils
"
"
fuzzaldrin
-
plus
"
"
lodash
-
move
"
"
react
-
aria
-
components
/
src
/
tabs
"
"
react
-
transition
-
group
/
Transition
"
"
Svg
"
]
;
const
moduleMapping
=
{
Telemetry
:
"
devtools
/
client
/
shared
/
telemetry
"
asyncStoreHelper
:
"
devtools
/
client
/
shared
/
async
-
store
-
helper
"
asyncStorage
:
"
devtools
/
shared
/
async
-
storage
"
PluralForm
:
"
devtools
/
shared
/
plural
-
form
"
}
;
function
updateDevtoolsModulesImport
(
path
t
)
{
const
specifiers
=
path
.
node
.
specifiers
;
for
(
let
i
=
0
;
i
<
specifiers
.
length
;
i
+
+
)
{
const
specifier
=
specifiers
[
i
]
;
const
localName
=
specifier
.
local
.
name
;
if
(
localName
in
moduleMapping
)
{
const
newImport
=
t
.
importDeclaration
(
[
t
.
importDefaultSpecifier
(
specifier
.
local
)
]
t
.
stringLiteral
(
moduleMapping
[
localName
]
)
)
;
if
(
specifiers
.
length
>
1
)
{
path
.
insertAfter
(
newImport
)
;
specifiers
.
splice
(
i
1
)
;
}
else
if
(
path
.
node
.
source
)
{
if
(
path
.
node
.
specifiers
[
0
]
.
type
!
=
=
"
ImportDefaultSpecifier
"
)
{
path
.
replaceWith
(
newImport
)
;
}
}
}
}
}
function
shouldLazyLoad
(
value
)
{
return
(
!
value
.
includes
(
"
vendors
"
)
&
&
!
value
.
includes
(
"
codemirror
/
"
)
&
&
!
value
.
endsWith
(
"
.
properties
"
)
&
&
!
value
.
startsWith
(
"
devtools
/
"
)
)
;
}
function
transformMC
(
{
types
:
t
}
)
{
return
{
visitor
:
{
ModuleDeclaration
(
path
state
)
{
const
source
=
path
.
node
.
source
;
const
value
=
source
&
&
source
.
value
;
if
(
value
&
&
value
.
includes
(
"
.
css
"
)
)
{
path
.
remove
(
)
;
}
if
(
value
&
&
value
=
=
"
devtools
-
modules
"
)
{
updateDevtoolsModulesImport
(
path
t
)
;
}
}
StringLiteral
(
path
state
)
{
const
{
filePath
}
=
state
.
opts
;
let
value
=
path
.
node
.
value
;
if
(
!
isRequire
(
t
path
.
parent
)
)
{
return
;
}
if
(
Object
.
keys
(
mappings
)
.
includes
(
value
)
)
{
path
.
replaceWith
(
t
.
stringLiteral
(
mappings
[
value
]
)
)
;
return
;
}
if
(
value
.
startsWith
(
"
lodash
/
"
)
)
{
const
lodashSubModule
=
value
.
split
(
"
/
"
)
.
pop
(
)
;
path
.
replaceWith
(
t
.
stringLiteral
(
mappings
.
lodash
)
)
;
path
.
parentPath
.
replaceWith
(
t
.
memberExpression
(
path
.
parent
t
.
identifier
(
lodashSubModule
)
)
)
;
return
;
}
const
isVendored
=
VENDORS
.
some
(
vendored
=
>
value
.
endsWith
(
vendored
)
)
;
if
(
isVendored
)
{
if
(
value
.
endsWith
(
"
/
Svg
"
)
)
{
value
=
"
Svg
"
;
}
path
.
replaceWith
(
t
.
stringLiteral
(
"
devtools
/
client
/
debugger
/
dist
/
vendors
"
)
)
;
path
.
parentPath
.
replaceWith
(
t
.
memberExpression
(
t
.
memberExpression
(
path
.
parent
t
.
identifier
(
"
vendored
"
)
)
t
.
stringLiteral
(
value
)
true
)
)
;
return
;
}
const
dir
=
_path
.
dirname
(
filePath
)
;
const
depPath
=
_path
.
join
(
dir
{
value
}
.
js
)
;
const
exists
=
fs
.
existsSync
(
depPath
)
;
if
(
!
exists
&
&
!
value
.
endsWith
(
"
index
"
)
&
&
!
(
value
.
startsWith
(
"
devtools
"
)
|
|
mappingValues
.
includes
(
value
)
)
)
{
value
=
{
value
}
/
index
;
path
.
replaceWith
(
t
.
stringLiteral
(
value
)
)
;
}
if
(
shouldLazyLoad
(
value
)
)
{
const
requireCall
=
path
.
parentPath
;
const
declarator
=
requireCall
.
parentPath
;
const
declaration
=
declarator
.
parentPath
;
if
(
declarator
.
type
!
=
=
"
VariableDeclarator
"
)
{
return
;
}
if
(
value
.
startsWith
(
"
.
"
)
)
{
let
newValue
=
_path
.
join
(
_path
.
dirname
(
filePath
)
value
)
;
if
(
!
newValue
.
startsWith
(
"
devtools
"
)
)
{
newValue
=
newValue
.
match
(
/
^
(
.
*
?
)
(
devtools
.
*
)
/
)
[
2
]
;
}
newValue
=
newValue
.
replace
(
/
\
\
/
g
"
/
"
)
;
value
=
newValue
;
}
const
lazyRequire
=
t
.
callExpression
(
t
.
memberExpression
(
t
.
identifier
(
"
loader
"
)
t
.
identifier
(
"
lazyRequireGetter
"
)
)
[
t
.
thisExpression
(
)
t
.
stringLiteral
(
declarator
.
node
.
id
.
name
|
|
"
"
)
t
.
stringLiteral
(
value
)
]
)
;
declaration
.
replaceWith
(
lazyRequire
)
;
}
}
}
}
;
}
Babel
.
registerPlugin
(
"
transform
-
mc
"
transformMC
)
;
module
.
exports
=
function
(
filePath
)
{
return
[
"
transform
-
flow
-
strip
-
types
"
"
syntax
-
trailing
-
function
-
commas
"
"
transform
-
class
-
properties
"
"
transform
-
es2015
-
modules
-
commonjs
"
"
transform
-
react
-
jsx
"
"
syntax
-
object
-
rest
-
spread
"
[
"
transform
-
mc
"
{
mappings
vendors
:
VENDORS
filePath
}
]
]
;
}
;
