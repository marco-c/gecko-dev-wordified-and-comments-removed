"
use
strict
"
;
const
Babel
=
require
(
"
.
/
babel
"
)
;
const
fs
=
require
(
"
fs
"
)
;
const
_path
=
require
(
"
path
"
)
;
const
mappings
=
{
"
.
/
source
-
editor
"
:
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
"
.
.
/
editor
/
source
-
editor
"
:
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
"
immutable
:
"
devtools
/
client
/
shared
/
vendor
/
immutable
"
lodash
:
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
react
:
"
devtools
/
client
/
shared
/
vendor
/
react
"
"
react
-
dom
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
"
react
-
dom
-
factories
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
"
react
-
redux
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
redux
:
"
devtools
/
client
/
shared
/
vendor
/
redux
"
reselect
:
"
devtools
/
client
/
shared
/
vendor
/
reselect
"
"
prop
-
types
"
:
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
"
devtools
-
services
"
:
"
Services
"
"
wasmparser
/
dist
/
cjs
/
WasmParser
"
:
"
devtools
/
client
/
shared
/
vendor
/
WasmParser
"
"
wasmparser
/
dist
/
cjs
/
WasmDis
"
:
"
devtools
/
client
/
shared
/
vendor
/
WasmDis
"
"
whatwg
-
url
"
:
"
devtools
/
client
/
shared
/
vendor
/
whatwg
-
url
"
"
framework
-
actions
"
:
"
devtools
/
client
/
framework
/
actions
/
index
"
"
inspector
-
shared
-
utils
"
:
"
devtools
/
client
/
inspector
/
shared
/
utils
"
}
;
const
mappingValues
=
Object
.
values
(
mappings
)
;
mappings
[
"
devtools
-
source
-
map
"
]
=
"
devtools
/
client
/
shared
/
source
-
map
/
index
.
js
"
;
function
isRequire
(
t
node
)
{
return
node
&
&
t
.
isCallExpression
(
node
)
&
&
node
.
callee
.
name
=
=
"
require
"
;
}
const
VENDORS
=
[
"
classnames
"
"
devtools
-
environment
"
"
devtools
-
utils
"
"
fuzzaldrin
-
plus
"
"
lodash
-
move
"
"
react
-
aria
-
components
/
src
/
tabs
"
"
react
-
transition
-
group
/
Transition
"
"
Svg
"
]
;
function
shouldLazyLoad
(
value
)
{
return
(
!
value
.
includes
(
"
vendors
"
)
&
&
!
value
.
includes
(
"
codemirror
/
"
)
&
&
!
value
.
endsWith
(
"
.
properties
"
)
&
&
!
value
.
startsWith
(
"
devtools
/
"
)
&
&
value
!
=
=
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
}
function
transformMC
(
{
types
:
t
}
)
{
return
{
visitor
:
{
ModuleDeclaration
(
path
state
)
{
const
source
=
path
.
node
.
source
;
const
value
=
source
&
&
source
.
value
;
if
(
value
&
&
value
.
includes
(
"
.
css
"
)
)
{
path
.
remove
(
)
;
}
}
StringLiteral
(
path
state
)
{
const
{
filePath
}
=
state
.
opts
;
let
value
=
path
.
node
.
value
;
if
(
!
isRequire
(
t
path
.
parent
)
)
{
return
;
}
if
(
Object
.
keys
(
mappings
)
.
includes
(
value
)
)
{
path
.
replaceWith
(
t
.
stringLiteral
(
mappings
[
value
]
)
)
;
return
;
}
if
(
value
.
startsWith
(
"
lodash
/
"
)
)
{
const
lodashSubModule
=
value
.
split
(
"
/
"
)
.
pop
(
)
;
path
.
replaceWith
(
t
.
stringLiteral
(
mappings
.
lodash
)
)
;
path
.
parentPath
.
replaceWith
(
t
.
memberExpression
(
path
.
parent
t
.
identifier
(
lodashSubModule
)
)
)
;
return
;
}
const
isVendored
=
VENDORS
.
some
(
vendored
=
>
value
.
endsWith
(
vendored
)
)
;
if
(
isVendored
)
{
if
(
value
.
endsWith
(
"
/
Svg
"
)
)
{
value
=
"
Svg
"
;
}
path
.
replaceWith
(
t
.
stringLiteral
(
"
devtools
/
client
/
debugger
/
dist
/
vendors
"
)
)
;
path
.
parentPath
.
replaceWith
(
t
.
memberExpression
(
t
.
memberExpression
(
path
.
parent
t
.
identifier
(
"
vendored
"
)
)
t
.
stringLiteral
(
value
)
true
)
)
;
return
;
}
const
dir
=
_path
.
dirname
(
filePath
)
;
const
depPath
=
_path
.
join
(
dir
{
value
}
.
js
)
;
const
exists
=
fs
.
existsSync
(
depPath
)
;
if
(
!
exists
&
&
!
value
.
endsWith
(
"
index
"
)
&
&
!
value
.
endsWith
(
"
.
jsm
"
)
&
&
!
(
value
.
startsWith
(
"
devtools
"
)
|
|
mappingValues
.
includes
(
value
)
)
)
{
value
=
{
value
}
/
index
;
path
.
replaceWith
(
t
.
stringLiteral
(
value
)
)
;
}
if
(
shouldLazyLoad
(
value
)
)
{
const
requireCall
=
path
.
parentPath
;
const
declarator
=
requireCall
.
parentPath
;
const
declaration
=
declarator
.
parentPath
;
if
(
declarator
.
type
!
=
=
"
VariableDeclarator
"
)
{
return
;
}
if
(
value
.
startsWith
(
"
.
"
)
)
{
let
newValue
=
_path
.
join
(
_path
.
dirname
(
filePath
)
value
)
;
if
(
!
newValue
.
startsWith
(
"
devtools
"
)
)
{
newValue
=
newValue
.
match
(
/
^
(
.
*
?
)
(
devtools
.
*
)
/
)
[
2
]
;
}
newValue
=
newValue
.
replace
(
/
\
\
/
g
"
/
"
)
;
value
=
newValue
;
}
const
lazyRequire
=
t
.
callExpression
(
t
.
memberExpression
(
t
.
identifier
(
"
loader
"
)
t
.
identifier
(
"
lazyRequireGetter
"
)
)
[
t
.
thisExpression
(
)
t
.
stringLiteral
(
declarator
.
node
.
id
.
name
|
|
"
"
)
t
.
stringLiteral
(
value
)
]
)
;
declaration
.
replaceWith
(
lazyRequire
)
;
}
}
}
}
;
}
Babel
.
registerPlugin
(
"
transform
-
mc
"
transformMC
)
;
module
.
exports
=
function
(
filePath
)
{
return
[
"
proposal
-
optional
-
chaining
"
"
proposal
-
class
-
properties
"
"
transform
-
modules
-
commonjs
"
"
transform
-
react
-
jsx
"
[
"
transform
-
mc
"
{
mappings
vendors
:
VENDORS
filePath
}
]
]
;
}
;
