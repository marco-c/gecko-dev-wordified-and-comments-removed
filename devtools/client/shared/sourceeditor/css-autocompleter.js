"
use
strict
"
;
const
{
cssTokenizer
cssTokenizerWithLineColumn
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
css
/
parsing
-
utils
.
js
"
)
;
class
CSSCompleter
{
static
CSS_STATE_NULL
=
Symbol
(
"
state_null
"
)
;
static
CSS_STATE_PROPERTY
=
Symbol
(
"
state_property
"
)
;
static
CSS_STATE_VALUE
=
Symbol
(
"
state_value
"
)
;
static
CSS_STATE_SELECTOR
=
Symbol
(
"
state_selector
"
)
;
static
CSS_STATE_MEDIA
=
Symbol
(
"
state_media
"
)
;
static
CSS_STATE_KEYFRAMES
=
Symbol
(
"
state_keyframes
"
)
;
static
CSS_STATE_FRAME
=
Symbol
(
"
state_frame
"
)
;
static
CSS_SELECTOR_STATE_NULL
=
Symbol
(
"
selector_state_null
"
)
;
static
CSS_SELECTOR_STATE_ID
=
Symbol
(
"
selector_state_id
"
)
;
static
CSS_SELECTOR_STATE_CLASS
=
Symbol
(
"
selector_state_class
"
)
;
static
CSS_SELECTOR_STATE_TAG
=
Symbol
(
"
selector_state_tag
"
)
;
static
CSS_SELECTOR_STATE_PSEUDO
=
Symbol
(
"
selector_state_pseudo
"
)
;
static
CSS_SELECTOR_STATE_ATTRIBUTE
=
Symbol
(
"
selector_state_attribute
"
)
;
static
CSS_SELECTOR_STATE_VALUE
=
Symbol
(
"
selector_state_value
"
)
;
static
SELECTOR_STATE_STRING_BY_SYMBOL
=
new
Map
(
[
[
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
"
null
"
]
[
CSSCompleter
.
CSS_SELECTOR_STATE_ID
"
id
"
]
[
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
"
class
"
]
[
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
"
tag
"
]
[
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
"
pseudo
"
]
[
CSSCompleter
.
CSS_SELECTOR_STATE_ATTRIBUTE
"
attribute
"
]
[
CSSCompleter
.
CSS_SELECTOR_STATE_VALUE
"
value
"
]
]
)
;
constructor
(
options
=
{
}
)
{
this
.
walker
=
options
.
walker
;
this
.
maxEntries
=
options
.
maxEntries
|
|
15
;
this
.
cssProperties
=
options
.
cssProperties
;
this
.
propertyNames
=
this
.
cssProperties
.
getNames
(
)
.
sort
(
)
;
this
.
nullStates
=
[
]
;
}
complete
(
source
cursor
)
{
if
(
!
this
.
resolveState
(
{
source
line
:
cursor
.
line
column
:
cursor
.
ch
}
)
)
{
return
Promise
.
resolve
(
[
]
)
;
}
switch
(
this
.
state
)
{
case
CSSCompleter
.
CSS_STATE_PROPERTY
:
return
this
.
completeProperties
(
this
.
completing
)
;
case
CSSCompleter
.
CSS_STATE_VALUE
:
return
this
.
completeValues
(
this
.
propertyName
this
.
completing
)
;
case
CSSCompleter
.
CSS_STATE_SELECTOR
:
return
this
.
suggestSelectors
(
)
;
case
CSSCompleter
.
CSS_STATE_MEDIA
:
case
CSSCompleter
.
CSS_STATE_KEYFRAMES
:
if
(
"
media
"
.
startsWith
(
this
.
completing
)
)
{
return
Promise
.
resolve
(
[
{
label
:
"
media
"
preLabel
:
this
.
completing
text
:
"
media
"
}
]
)
;
}
else
if
(
"
keyframes
"
.
startsWith
(
this
.
completing
)
)
{
return
Promise
.
resolve
(
[
{
label
:
"
keyframes
"
preLabel
:
this
.
completing
text
:
"
keyframes
"
}
]
)
;
}
}
return
Promise
.
resolve
(
[
]
)
;
}
resolveState
(
{
sourceTokens
source
line
column
}
)
{
if
(
sourceTokens
&
&
source
)
{
throw
new
Error
(
"
This
function
only
accepts
sourceTokens
or
source
not
both
"
)
;
}
let
_state
=
CSSCompleter
.
CSS_STATE_NULL
;
let
selector
=
"
"
;
let
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
let
propertyName
=
null
;
let
scopeStack
=
[
]
;
let
selectors
=
[
]
;
const
matchedStateIndex
=
!
sourceTokens
?
this
.
findNearestNullState
(
line
)
:
-
1
;
if
(
matchedStateIndex
>
-
1
)
{
const
state
=
this
.
nullStates
[
matchedStateIndex
]
;
line
-
=
state
[
0
]
;
if
(
line
=
=
0
)
{
column
-
=
state
[
1
]
;
}
source
=
source
.
split
(
"
\
n
"
)
.
slice
(
state
[
0
]
)
;
source
[
0
]
=
source
[
0
]
.
slice
(
state
[
1
]
)
;
source
=
source
.
join
(
"
\
n
"
)
;
scopeStack
=
[
.
.
.
state
[
2
]
]
;
this
.
nullStates
.
length
=
matchedStateIndex
+
1
;
}
else
{
this
.
nullStates
=
[
]
;
}
const
tokens
=
sourceTokens
|
|
cssTokenizerWithLineColumn
(
source
)
;
const
tokIndex
=
tokens
.
length
-
1
;
if
(
!
sourceTokens
&
&
tokIndex
>
=
0
&
&
(
tokens
[
tokIndex
]
.
loc
.
end
.
line
<
line
|
|
(
tokens
[
tokIndex
]
.
loc
.
end
.
line
=
=
=
line
&
&
tokens
[
tokIndex
]
.
loc
.
end
.
column
<
column
)
)
)
{
return
null
;
}
let
cursor
=
0
;
let
token
=
null
;
let
selectorBeforeNot
=
null
;
while
(
cursor
<
=
tokIndex
&
&
(
token
=
tokens
[
cursor
+
+
]
)
)
{
switch
(
_state
)
{
case
CSSCompleter
.
CSS_STATE_PROPERTY
:
if
(
token
.
tokenType
=
=
=
"
Colon
"
)
{
scopeStack
.
push
(
"
:
"
)
;
if
(
tokens
[
cursor
-
2
]
.
tokenType
!
=
"
WhiteSpace
"
)
{
propertyName
=
tokens
[
cursor
-
2
]
.
text
;
}
else
{
propertyName
=
tokens
[
cursor
-
3
]
.
text
;
}
_state
=
CSSCompleter
.
CSS_STATE_VALUE
;
}
if
(
token
.
tokenType
=
=
=
"
CloseCurlyBracket
"
)
{
if
(
/
[
{
f
]
/
.
test
(
scopeStack
.
at
(
-
1
)
)
)
{
const
popped
=
scopeStack
.
pop
(
)
;
if
(
popped
=
=
"
f
"
)
{
_state
=
CSSCompleter
.
CSS_STATE_FRAME
;
}
else
{
selector
=
"
"
;
selectors
=
[
]
;
_state
=
CSSCompleter
.
CSS_STATE_NULL
;
}
}
}
break
;
case
CSSCompleter
.
CSS_STATE_VALUE
:
if
(
token
.
tokenType
=
=
=
"
Semicolon
"
)
{
if
(
/
[
:
]
/
.
test
(
scopeStack
.
at
(
-
1
)
)
)
{
scopeStack
.
pop
(
)
;
_state
=
CSSCompleter
.
CSS_STATE_PROPERTY
;
}
}
if
(
token
.
tokenType
=
=
=
"
CloseCurlyBracket
"
)
{
if
(
scopeStack
.
at
(
-
1
)
=
=
"
:
"
)
{
scopeStack
.
pop
(
)
;
}
if
(
/
[
{
f
]
/
.
test
(
scopeStack
.
at
(
-
1
)
)
)
{
const
popped
=
scopeStack
.
pop
(
)
;
if
(
popped
=
=
"
f
"
)
{
_state
=
CSSCompleter
.
CSS_STATE_FRAME
;
}
else
{
selector
=
"
"
;
selectors
=
[
]
;
_state
=
CSSCompleter
.
CSS_STATE_NULL
;
}
}
}
break
;
case
CSSCompleter
.
CSS_STATE_SELECTOR
:
if
(
token
.
tokenType
=
=
=
"
CurlyBracketBlock
"
)
{
scopeStack
.
push
(
"
{
"
)
;
_state
=
CSSCompleter
.
CSS_STATE_PROPERTY
;
selectors
.
push
(
selector
)
;
selector
=
"
"
;
break
;
}
switch
(
selectorState
)
{
case
CSSCompleter
.
CSS_SELECTOR_STATE_ID
:
case
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
:
case
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
:
switch
(
token
.
tokenType
)
{
case
"
Hash
"
:
case
"
IDHash
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ID
;
selector
+
=
token
.
text
;
break
;
case
"
Delim
"
:
if
(
token
.
text
=
=
"
.
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
;
selector
+
=
"
.
"
;
if
(
cursor
<
=
tokIndex
&
&
tokens
[
cursor
]
.
tokenType
=
=
"
Ident
"
)
{
token
=
tokens
[
cursor
+
+
]
;
selector
+
=
token
.
text
;
}
}
else
if
(
token
.
text
=
=
"
#
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ID
;
selector
+
=
"
#
"
;
}
else
if
(
token
.
text
=
=
"
+
"
|
|
token
.
text
=
=
"
~
"
|
|
token
.
text
=
=
"
>
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selector
+
=
token
.
text
;
}
break
;
case
"
Comma
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selectors
.
push
(
selector
)
;
selector
=
"
"
;
break
;
case
"
Colon
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
;
selector
+
=
"
:
"
;
if
(
cursor
>
tokIndex
)
{
break
;
}
token
=
tokens
[
cursor
+
+
]
;
switch
(
token
.
tokenType
)
{
case
"
Function
"
:
if
(
token
.
value
=
=
"
not
"
)
{
selectorBeforeNot
=
selector
;
selector
=
"
"
;
scopeStack
.
push
(
"
(
"
)
;
}
else
{
selector
+
=
token
.
text
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
break
;
case
"
Ident
"
:
selector
+
=
token
.
text
;
break
;
}
break
;
case
"
SquareBracketBlock
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ATTRIBUTE
;
scopeStack
.
push
(
"
[
"
)
;
selector
+
=
"
[
"
;
break
;
case
"
CloseParenthesis
"
:
if
(
scopeStack
.
at
(
-
1
)
=
=
"
(
"
)
{
scopeStack
.
pop
(
)
;
selector
=
selectorBeforeNot
+
"
not
(
"
+
selector
+
"
)
"
;
selectorBeforeNot
=
null
;
}
else
{
selector
+
=
"
)
"
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
break
;
case
"
WhiteSpace
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selector
&
&
(
selector
+
=
"
"
)
;
break
;
}
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
:
switch
(
token
.
tokenType
)
{
case
"
Hash
"
:
case
"
IDHash
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ID
;
selector
+
=
token
.
text
;
break
;
case
"
Ident
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
;
selector
+
=
token
.
text
;
break
;
case
"
Delim
"
:
if
(
token
.
text
=
=
"
.
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
;
selector
+
=
"
.
"
;
if
(
cursor
<
=
tokIndex
&
&
tokens
[
cursor
]
.
tokenType
=
=
"
Ident
"
)
{
token
=
tokens
[
cursor
+
+
]
;
selector
+
=
token
.
text
;
}
}
else
if
(
token
.
text
=
=
"
#
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ID
;
selector
+
=
"
#
"
;
}
else
if
(
token
.
text
=
=
"
*
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
;
selector
+
=
"
*
"
;
}
else
if
(
token
.
text
=
=
"
+
"
|
|
token
.
text
=
=
"
~
"
|
|
token
.
text
=
=
"
>
"
)
{
selector
+
=
token
.
text
;
}
break
;
case
"
Comma
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selectors
.
push
(
selector
)
;
selector
=
"
"
;
break
;
case
"
Colon
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
;
selector
+
=
"
:
"
;
if
(
cursor
>
tokIndex
)
{
break
;
}
token
=
tokens
[
cursor
+
+
]
;
switch
(
token
.
tokenType
)
{
case
"
Function
"
:
if
(
token
.
value
=
=
"
not
"
)
{
selectorBeforeNot
=
selector
;
selector
=
"
"
;
scopeStack
.
push
(
"
(
"
)
;
}
else
{
selector
+
=
token
.
text
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
break
;
case
"
Ident
"
:
selector
+
=
token
.
text
;
break
;
}
break
;
case
"
SquareBracketBlock
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ATTRIBUTE
;
scopeStack
.
push
(
"
[
"
)
;
selector
+
=
"
[
"
;
break
;
case
"
CloseParenthesis
"
:
if
(
scopeStack
.
at
(
-
1
)
=
=
"
(
"
)
{
scopeStack
.
pop
(
)
;
selector
=
selectorBeforeNot
+
"
not
(
"
+
selector
+
"
)
"
;
selectorBeforeNot
=
null
;
}
else
{
selector
+
=
"
)
"
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
break
;
case
"
WhiteSpace
"
:
selector
&
&
(
selector
+
=
"
"
)
;
break
;
}
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
:
switch
(
token
.
tokenType
)
{
case
"
Delim
"
:
if
(
token
.
text
=
=
"
+
"
|
|
token
.
text
=
=
"
~
"
|
|
token
.
text
=
=
"
>
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selector
+
=
token
.
text
;
}
break
;
case
"
Comma
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selectors
.
push
(
selector
)
;
selector
=
"
"
;
break
;
case
"
Colon
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
;
selector
+
=
"
:
"
;
if
(
cursor
>
tokIndex
)
{
break
;
}
token
=
tokens
[
cursor
+
+
]
;
switch
(
token
.
tokenType
)
{
case
"
Function
"
:
if
(
token
.
value
=
=
"
not
"
)
{
selectorBeforeNot
=
selector
;
selector
=
"
"
;
scopeStack
.
push
(
"
(
"
)
;
}
else
{
selector
+
=
token
.
text
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
break
;
case
"
Ident
"
:
selector
+
=
token
.
text
;
break
;
}
break
;
case
"
SquareBracketBlock
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ATTRIBUTE
;
scopeStack
.
push
(
"
[
"
)
;
selector
+
=
"
[
"
;
break
;
case
"
WhiteSpace
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selector
&
&
(
selector
+
=
"
"
)
;
break
;
}
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_ATTRIBUTE
:
switch
(
token
.
tokenType
)
{
case
"
IncludeMatch
"
:
case
"
DashMatch
"
:
case
"
PrefixMatch
"
:
case
"
IncludeSuffixMatchMatch
"
:
case
"
SubstringMatch
"
:
selector
+
=
token
.
text
;
token
=
tokens
[
cursor
+
+
]
;
break
;
case
"
Delim
"
:
if
(
token
.
text
=
=
"
=
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_VALUE
;
selector
+
=
token
.
text
;
}
break
;
case
"
CloseSquareBracket
"
:
if
(
scopeStack
.
at
(
-
1
)
=
=
"
[
"
)
{
scopeStack
.
pop
(
)
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selector
+
=
"
]
"
;
break
;
case
"
Ident
"
:
selector
+
=
token
.
text
;
break
;
case
"
QuotedString
"
:
selector
+
=
token
.
value
;
break
;
case
"
WhiteSpace
"
:
selector
&
&
(
selector
+
=
"
"
)
;
break
;
}
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_VALUE
:
switch
(
token
.
tokenType
)
{
case
"
Ident
"
:
selector
+
=
token
.
text
;
break
;
case
"
QuotedString
"
:
selector
+
=
token
.
value
;
break
;
case
"
CloseSquareBracket
"
:
if
(
scopeStack
.
at
(
-
1
)
=
=
"
[
"
)
{
scopeStack
.
pop
(
)
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
selector
+
=
"
]
"
;
break
;
case
"
WhiteSpace
"
:
selector
&
&
(
selector
+
=
"
"
)
;
break
;
}
break
;
}
break
;
case
CSSCompleter
.
CSS_STATE_NULL
:
switch
(
token
.
tokenType
)
{
case
"
Hash
"
:
case
"
IDHash
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ID
;
selector
=
token
.
text
;
_state
=
CSSCompleter
.
CSS_STATE_SELECTOR
;
break
;
case
"
Ident
"
:
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
;
selector
=
token
.
text
;
_state
=
CSSCompleter
.
CSS_STATE_SELECTOR
;
break
;
case
"
Delim
"
:
if
(
token
.
text
=
=
"
.
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
;
selector
=
"
.
"
;
_state
=
CSSCompleter
.
CSS_STATE_SELECTOR
;
if
(
cursor
<
=
tokIndex
&
&
tokens
[
cursor
]
.
tokenType
=
=
"
Ident
"
)
{
token
=
tokens
[
cursor
+
+
]
;
selector
+
=
token
.
text
;
}
}
else
if
(
token
.
text
=
=
"
#
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ID
;
selector
=
"
#
"
;
_state
=
CSSCompleter
.
CSS_STATE_SELECTOR
;
}
else
if
(
token
.
text
=
=
"
*
"
)
{
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
;
selector
=
"
*
"
;
_state
=
CSSCompleter
.
CSS_STATE_SELECTOR
;
}
break
;
case
"
Colon
"
:
_state
=
CSSCompleter
.
CSS_STATE_SELECTOR
;
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
;
selector
+
=
"
:
"
;
if
(
cursor
>
tokIndex
)
{
break
;
}
token
=
tokens
[
cursor
+
+
]
;
switch
(
token
.
tokenType
)
{
case
"
Function
"
:
if
(
token
.
value
=
=
"
not
"
)
{
selectorBeforeNot
=
selector
;
selector
=
"
"
;
scopeStack
.
push
(
"
(
"
)
;
}
else
{
selector
+
=
token
.
text
;
}
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
;
break
;
case
"
Ident
"
:
selector
+
=
token
.
text
;
break
;
}
break
;
case
"
CloseSquareBracket
"
:
_state
=
CSSCompleter
.
CSS_STATE_SELECTOR
;
selectorState
=
CSSCompleter
.
CSS_SELECTOR_STATE_ATTRIBUTE
;
scopeStack
.
push
(
"
[
"
)
;
selector
+
=
"
[
"
;
break
;
case
"
CurlyBracketBlock
"
:
if
(
scopeStack
.
at
(
-
1
)
=
=
"
m
"
)
{
scopeStack
.
pop
(
)
;
}
break
;
case
"
AtKeyword
"
:
_state
=
token
.
value
.
startsWith
(
"
m
"
)
?
CSSCompleter
.
CSS_STATE_MEDIA
:
CSSCompleter
.
CSS_STATE_KEYFRAMES
;
break
;
}
break
;
case
CSSCompleter
.
CSS_STATE_MEDIA
:
if
(
token
.
tokenType
=
=
"
CurlyBracketBlock
"
)
{
scopeStack
.
push
(
"
m
"
)
;
_state
=
CSSCompleter
.
CSS_STATE_NULL
;
}
break
;
case
CSSCompleter
.
CSS_STATE_KEYFRAMES
:
if
(
token
.
tokenType
=
=
"
CurlyBracketBlock
"
)
{
scopeStack
.
push
(
"
k
"
)
;
_state
=
CSSCompleter
.
CSS_STATE_FRAME
;
}
break
;
case
CSSCompleter
.
CSS_STATE_FRAME
:
if
(
token
.
tokenType
=
=
"
CurlyBracketBlock
"
)
{
scopeStack
.
push
(
"
f
"
)
;
_state
=
CSSCompleter
.
CSS_STATE_PROPERTY
;
}
else
if
(
token
.
tokenType
=
=
"
CloseCurlyBracket
"
)
{
if
(
scopeStack
.
at
(
-
1
)
=
=
"
k
"
)
{
scopeStack
.
pop
(
)
;
}
_state
=
CSSCompleter
.
CSS_STATE_NULL
;
}
break
;
}
if
(
_state
=
=
CSSCompleter
.
CSS_STATE_NULL
)
{
if
(
!
this
.
nullStates
.
length
)
{
this
.
nullStates
.
push
(
[
token
.
loc
.
end
.
line
token
.
loc
.
end
.
column
[
.
.
.
scopeStack
]
]
)
;
continue
;
}
let
tokenLine
=
token
.
loc
.
end
.
line
;
const
tokenCh
=
token
.
loc
.
end
.
column
;
if
(
tokenLine
=
=
0
)
{
continue
;
}
if
(
matchedStateIndex
>
-
1
)
{
tokenLine
+
=
this
.
nullStates
[
matchedStateIndex
]
[
0
]
;
}
this
.
nullStates
.
push
(
[
tokenLine
tokenCh
[
.
.
.
scopeStack
]
]
)
;
}
}
this
.
state
=
_state
;
this
.
propertyName
=
_state
=
=
CSSCompleter
.
CSS_STATE_VALUE
?
propertyName
:
null
;
this
.
selectorState
=
_state
=
=
CSSCompleter
.
CSS_STATE_SELECTOR
?
selectorState
:
null
;
this
.
selectorBeforeNot
=
selectorBeforeNot
=
=
null
?
null
:
selectorBeforeNot
;
if
(
token
)
{
if
(
!
sourceTokens
)
{
selector
=
selector
.
slice
(
0
selector
.
length
+
token
.
loc
.
end
.
column
-
column
)
;
}
this
.
selector
=
selector
;
}
else
{
this
.
selector
=
"
"
;
}
this
.
selectors
=
selectors
;
if
(
token
&
&
token
.
tokenType
!
=
"
WhiteSpace
"
)
{
let
text
;
if
(
token
.
tokenType
=
=
=
"
IDHash
"
|
|
token
.
tokenType
=
=
=
"
Hash
"
|
|
token
.
tokenType
=
=
=
"
AtKeyword
"
|
|
token
.
tokenType
=
=
=
"
Function
"
|
|
token
.
tokenType
=
=
=
"
QuotedString
"
)
{
text
=
token
.
value
;
}
else
{
text
=
token
.
text
;
}
this
.
completing
=
(
sourceTokens
?
text
:
text
.
slice
(
0
column
-
token
.
loc
.
start
.
column
)
)
.
replace
(
/
^
[
.
#
]
/
"
"
)
;
}
else
{
this
.
completing
=
"
"
;
}
if
(
this
.
completing
=
=
"
:
"
&
&
_state
=
=
CSSCompleter
.
CSS_STATE_VALUE
)
{
this
.
completing
=
"
"
;
}
if
(
token
&
&
tokens
[
cursor
-
2
]
&
&
tokens
[
cursor
-
2
]
.
text
=
=
"
!
"
&
&
this
.
completing
=
=
"
important
"
.
slice
(
0
this
.
completing
.
length
)
)
{
this
.
completing
=
"
!
"
+
this
.
completing
;
}
return
_state
;
}
suggestSelectors
(
)
{
const
walker
=
this
.
walker
;
if
(
!
walker
)
{
return
Promise
.
resolve
(
[
]
)
;
}
let
query
=
this
.
selector
;
switch
(
this
.
selectorState
)
{
case
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
:
if
(
this
.
completing
=
=
=
"
"
)
{
return
Promise
.
resolve
(
[
]
)
;
}
query
+
=
"
*
"
;
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
:
query
=
query
.
slice
(
0
query
.
length
-
this
.
completing
.
length
)
;
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_ID
:
case
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
:
case
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
:
if
(
/
^
[
.
:
#
]
/
.
test
(
this
.
completing
)
)
{
query
=
query
.
slice
(
0
query
.
length
-
this
.
completing
.
length
)
;
this
.
completing
=
"
"
;
}
else
{
query
=
query
.
slice
(
0
query
.
length
-
this
.
completing
.
length
-
1
)
;
}
break
;
}
if
(
/
[
\
s
+
>
~
]
/
.
test
(
query
)
&
&
this
.
selectorState
!
=
CSSCompleter
.
CSS_SELECTOR_STATE_ATTRIBUTE
&
&
this
.
selectorState
!
=
CSSCompleter
.
CSS_SELECTOR_STATE_VALUE
)
{
query
+
=
"
*
"
;
}
this
.
_currentQuery
=
query
;
return
walker
.
getSuggestionsForQuery
(
query
this
.
completing
CSSCompleter
.
SELECTOR_STATE_STRING_BY_SYMBOL
.
get
(
this
.
selectorState
)
)
.
then
(
result
=
>
this
.
prepareSelectorResults
(
result
)
)
;
}
prepareSelectorResults
(
result
)
{
if
(
this
.
_currentQuery
!
=
result
.
query
)
{
return
[
]
;
}
result
=
result
.
suggestions
;
const
query
=
this
.
selector
;
const
completion
=
[
]
;
for
(
let
[
value
count
state
]
of
result
)
{
switch
(
this
.
selectorState
)
{
case
CSSCompleter
.
CSS_SELECTOR_STATE_ID
:
case
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
:
case
CSSCompleter
.
CSS_SELECTOR_STATE_PSEUDO
:
if
(
/
^
[
.
:
#
]
/
.
test
(
this
.
completing
)
)
{
value
=
query
.
slice
(
0
query
.
length
-
this
.
completing
.
length
)
+
value
;
}
else
{
value
=
query
.
slice
(
0
query
.
length
-
this
.
completing
.
length
-
1
)
+
value
;
}
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
:
value
=
query
.
slice
(
0
query
.
length
-
this
.
completing
.
length
)
+
value
;
break
;
case
CSSCompleter
.
CSS_SELECTOR_STATE_NULL
:
value
=
query
+
value
;
break
;
default
:
value
=
query
.
slice
(
0
query
.
length
-
this
.
completing
.
length
)
+
value
;
}
const
item
=
{
label
:
value
preLabel
:
query
text
:
value
score
:
count
}
;
if
(
this
.
selectorState
=
=
=
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
&
&
state
=
=
=
CSSCompleter
.
CSS_SELECTOR_STATE_CLASS
)
{
item
.
preLabel
=
"
.
"
+
item
.
preLabel
;
}
if
(
this
.
selectorState
=
=
=
CSSCompleter
.
CSS_SELECTOR_STATE_TAG
&
&
state
=
=
=
CSSCompleter
.
CSS_SELECTOR_STATE_ID
)
{
item
.
preLabel
=
"
#
"
+
item
.
preLabel
;
}
completion
.
push
(
item
)
;
if
(
completion
.
length
>
this
.
maxEntries
-
1
)
{
break
;
}
}
return
completion
;
}
completeProperties
(
startProp
)
{
const
finalList
=
[
]
;
if
(
!
startProp
)
{
return
Promise
.
resolve
(
finalList
)
;
}
const
length
=
this
.
propertyNames
.
length
;
let
i
=
0
count
=
0
;
for
(
;
i
<
length
&
&
count
<
this
.
maxEntries
;
i
+
+
)
{
if
(
this
.
propertyNames
[
i
]
.
startsWith
(
startProp
)
)
{
count
+
+
;
const
propName
=
this
.
propertyNames
[
i
]
;
finalList
.
push
(
{
preLabel
:
startProp
label
:
propName
text
:
propName
+
"
:
"
}
)
;
}
else
if
(
this
.
propertyNames
[
i
]
>
startProp
)
{
break
;
}
}
return
Promise
.
resolve
(
finalList
)
;
}
completeValues
(
propName
startValue
)
{
const
finalList
=
[
]
;
const
list
=
[
"
!
important
;
"
.
.
.
this
.
cssProperties
.
getValues
(
propName
)
]
;
if
(
!
startValue
)
{
list
.
splice
(
0
1
)
;
}
const
length
=
list
.
length
;
let
i
=
0
count
=
0
;
for
(
;
i
<
length
&
&
count
<
this
.
maxEntries
;
i
+
+
)
{
if
(
list
[
i
]
.
startsWith
(
startValue
)
)
{
count
+
+
;
const
value
=
list
[
i
]
;
finalList
.
push
(
{
preLabel
:
startValue
label
:
value
text
:
value
}
)
;
}
else
if
(
list
[
i
]
>
startValue
)
{
break
;
}
}
return
Promise
.
resolve
(
finalList
)
;
}
findNearestNullState
(
line
)
{
const
arr
=
this
.
nullStates
;
let
high
=
arr
.
length
-
1
;
let
low
=
0
;
let
target
=
0
;
if
(
high
<
0
)
{
return
-
1
;
}
if
(
arr
[
high
]
[
0
]
<
=
line
)
{
return
high
;
}
if
(
arr
[
low
]
[
0
]
>
line
)
{
return
-
1
;
}
while
(
high
>
low
)
{
if
(
arr
[
low
]
[
0
]
<
=
line
&
&
arr
[
low
[
0
]
+
1
]
>
line
)
{
return
low
;
}
if
(
arr
[
high
]
[
0
]
>
line
&
&
arr
[
high
-
1
]
[
0
]
<
=
line
)
{
return
high
-
1
;
}
target
=
(
(
(
line
-
arr
[
low
]
[
0
]
)
/
(
arr
[
high
]
[
0
]
-
arr
[
low
]
[
0
]
)
)
*
(
high
-
low
)
)
|
0
;
if
(
arr
[
target
]
[
0
]
<
=
line
&
&
arr
[
target
+
1
]
[
0
]
>
line
)
{
return
target
;
}
else
if
(
line
>
arr
[
target
]
[
0
]
)
{
low
=
target
+
1
;
high
-
-
;
}
else
{
high
=
target
-
1
;
low
+
+
;
}
}
return
-
1
;
}
invalidateCache
(
line
)
{
this
.
nullStates
.
length
=
this
.
findNearestNullState
(
line
)
+
1
;
}
getInfoAt
(
source
caret
)
{
let
{
line
ch
}
=
caret
;
const
sourceArray
=
source
.
split
(
"
\
n
"
)
;
const
limit
=
function
(
)
{
if
(
sourceArray
.
length
<
=
line
)
{
return
source
;
}
const
list
=
sourceArray
.
slice
(
0
line
+
1
)
;
list
[
line
]
=
list
[
line
]
.
slice
(
0
ch
)
;
return
list
.
join
(
"
\
n
"
)
;
}
;
const
originalLimitedSource
=
limit
(
source
)
;
let
limitedSource
=
originalLimitedSource
;
const
limitedSourceTokens
=
cssTokenizerWithLineColumn
(
limitedSource
)
;
const
state
=
this
.
resolveState
(
{
sourceTokens
:
limitedSourceTokens
}
)
;
const
propertyName
=
this
.
propertyName
;
const
traverseForward
=
check
=
>
{
do
{
let
lineText
=
sourceArray
[
line
]
;
if
(
line
=
=
caret
.
line
)
{
lineText
=
lineText
.
substring
(
caret
.
ch
)
;
}
let
prevToken
=
undefined
;
const
tokensIterator
=
cssTokenizer
(
lineText
)
;
const
ech
=
line
=
=
caret
.
line
?
caret
.
ch
:
0
;
for
(
let
token
of
tokensIterator
)
{
limitedSource
+
=
sourceArray
[
line
]
.
substring
(
ech
+
token
.
startOffset
ech
+
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
"
WhiteSpace
"
)
{
prevToken
=
token
;
continue
;
}
const
forwState
=
this
.
resolveState
(
{
source
:
limitedSource
line
column
:
token
.
endOffset
+
ech
}
)
;
if
(
check
(
forwState
)
)
{
if
(
prevToken
&
&
prevToken
.
tokenType
=
=
"
WhiteSpace
"
)
{
token
=
prevToken
;
}
return
{
line
ch
:
token
.
startOffset
+
ech
}
;
}
prevToken
=
token
;
}
limitedSource
+
=
"
\
n
"
;
}
while
(
line
+
+
<
sourceArray
.
length
)
;
return
null
;
}
;
const
traverseBackwards
=
(
check
isValue
)
=
>
{
let
token
;
let
previousToken
;
const
remainingTokens
=
Array
.
from
(
limitedSourceTokens
)
;
while
(
(
(
previousToken
=
token
)
(
token
=
remainingTokens
.
pop
(
)
)
)
)
{
const
length
=
token
.
endOffset
-
token
.
startOffset
;
limitedSource
=
limitedSource
.
slice
(
0
-
1
*
length
)
;
if
(
token
.
tokenType
=
=
"
WhiteSpace
"
)
{
continue
;
}
const
backState
=
this
.
resolveState
(
{
sourceTokens
:
remainingTokens
}
)
;
if
(
check
(
backState
)
)
{
if
(
previousToken
?
.
tokenType
=
=
"
WhiteSpace
"
)
{
token
=
previousToken
;
}
const
loc
=
isValue
?
token
.
loc
.
end
:
token
.
loc
.
start
;
return
{
line
:
loc
.
line
ch
:
loc
.
column
}
;
}
}
return
null
;
}
;
if
(
state
=
=
CSSCompleter
.
CSS_STATE_SELECTOR
)
{
const
start
=
traverseBackwards
(
backState
=
>
{
return
(
backState
!
=
CSSCompleter
.
CSS_STATE_SELECTOR
|
|
(
this
.
selector
=
=
"
"
&
&
this
.
selectorBeforeNot
=
=
null
)
)
;
}
)
;
line
=
caret
.
line
;
limitedSource
=
originalLimitedSource
;
const
end
=
traverseForward
(
forwState
=
>
{
return
(
forwState
!
=
CSSCompleter
.
CSS_STATE_SELECTOR
|
|
(
this
.
selector
=
=
"
"
&
&
this
.
selectorBeforeNot
=
=
null
)
)
;
}
)
;
let
selector
=
sourceArray
.
slice
(
start
.
line
end
.
line
+
1
)
;
selector
[
selector
.
length
-
1
]
=
selector
[
selector
.
length
-
1
]
.
substring
(
0
end
.
ch
)
;
selector
[
0
]
=
selector
[
0
]
.
substring
(
start
.
ch
)
;
selector
=
selector
.
join
(
"
\
n
"
)
;
return
{
state
selector
loc
:
{
start
end
}
}
;
}
else
if
(
state
=
=
CSSCompleter
.
CSS_STATE_PROPERTY
)
{
const
tokensIterator
=
cssTokenizer
(
sourceArray
[
line
]
)
;
for
(
const
token
of
tokensIterator
)
{
if
(
token
.
startOffset
<
=
ch
&
&
token
.
endOffset
>
=
ch
)
{
return
{
state
propertyName
:
token
.
text
selectors
:
this
.
selectors
loc
:
{
start
:
{
line
ch
:
token
.
startOffset
}
end
:
{
line
ch
:
token
.
endOffset
}
}
}
;
}
}
}
else
if
(
state
=
=
CSSCompleter
.
CSS_STATE_VALUE
)
{
const
start
=
traverseBackwards
(
backState
=
>
backState
!
=
CSSCompleter
.
CSS_STATE_VALUE
true
)
;
line
=
caret
.
line
;
const
remainingSource
=
source
.
substring
(
originalLimitedSource
.
length
)
;
const
parser
=
new
InspectorCSSParser
(
remainingSource
)
;
let
end
;
while
(
true
)
{
const
token
=
parser
.
nextToken
(
)
;
if
(
!
token
|
|
token
.
tokenType
=
=
=
"
Semicolon
"
|
|
token
.
tokenType
=
=
=
"
CloseCurlyBracket
"
)
{
end
=
{
line
:
parser
.
lineNumber
+
line
ch
:
parser
.
columnNumber
}
;
if
(
end
.
line
=
=
=
line
)
{
end
.
ch
=
end
.
ch
+
ch
;
}
break
;
}
}
let
value
=
sourceArray
.
slice
(
start
.
line
end
.
line
+
1
)
;
value
[
value
.
length
-
1
]
=
value
[
value
.
length
-
1
]
.
substring
(
0
end
.
ch
)
;
value
[
0
]
=
value
[
0
]
.
substring
(
start
.
ch
)
;
value
=
value
.
join
(
"
\
n
"
)
;
return
{
state
propertyName
selectors
:
this
.
selectors
value
loc
:
{
start
end
}
}
;
}
return
null
;
}
}
module
.
exports
=
CSSCompleter
;
