"
use
strict
"
;
function
containsPosition
(
functionLocation
position
)
{
return
(
functionLocation
.
startLine
<
=
position
.
line
&
&
functionLocation
.
endLine
>
=
position
.
line
)
;
}
function
containsLocation
(
parentLocation
childLocation
)
{
return
(
parentLocation
.
startLine
<
=
childLocation
.
startLine
&
&
parentLocation
.
endLine
>
=
childLocation
.
endLine
)
;
}
function
getInnerLocations
(
locations
position
)
{
let
parentIndex
;
for
(
let
i
=
locations
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
containsPosition
(
locations
[
i
]
position
)
)
{
parentIndex
=
i
;
break
;
}
}
if
(
parentIndex
=
=
undefined
)
{
return
[
]
;
}
const
parentLoc
=
locations
[
parentIndex
]
;
const
innerLocations
=
[
]
;
for
(
let
i
=
parentIndex
+
1
;
i
<
locations
.
length
;
i
+
+
)
{
const
loc
=
locations
[
i
]
;
if
(
!
containsLocation
(
parentLoc
loc
)
)
{
break
;
}
innerLocations
.
push
(
loc
)
;
}
return
innerLocations
;
}
function
sortByStart
(
locations
)
{
return
locations
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
startLine
<
b
.
startLine
)
{
return
-
1
;
}
else
if
(
a
.
startLine
=
=
=
b
.
startLine
)
{
return
b
.
endLine
-
a
.
endLine
;
}
return
1
;
}
)
;
}
function
removeOverlapLocations
(
locations
)
{
if
(
!
locations
.
length
)
{
return
[
]
;
}
const
firstParent
=
locations
[
0
]
;
return
locations
.
reduce
(
deduplicateNode
[
firstParent
]
)
;
}
function
deduplicateNode
(
nodes
location
)
{
const
parent
=
nodes
[
nodes
.
length
-
1
]
;
if
(
!
containsLocation
(
parent
location
)
)
{
nodes
.
push
(
location
)
;
}
return
nodes
;
}
function
getOutOfScopeLines
(
outOfScopeLocations
)
{
if
(
!
outOfScopeLocations
)
{
return
new
Set
(
)
;
}
const
uniqueLines
=
new
Set
(
)
;
for
(
const
location
of
outOfScopeLocations
)
{
for
(
let
i
=
location
.
startLine
;
i
<
location
.
endLine
;
i
+
+
)
{
uniqueLines
.
add
(
i
)
;
}
}
return
uniqueLines
;
}
module
.
exports
=
{
containsPosition
containsLocation
getInnerLocations
removeOverlapLocations
getOutOfScopeLines
sortByStart
}
;
