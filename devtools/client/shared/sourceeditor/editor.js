"
use
strict
"
;
const
{
EXPAND_TAB
TAB_SIZE
DETECT_INDENT
getIndentationFromIteration
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
indentation
.
js
"
)
;
const
{
debounce
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
debounce
.
js
"
)
;
const
nodeConstants
=
require
(
"
resource
:
/
/
devtools
/
shared
/
dom
-
node
-
constants
.
js
"
)
;
const
ENABLE_CODE_FOLDING
=
"
devtools
.
editor
.
enableCodeFolding
"
;
const
KEYMAP_PREF
=
"
devtools
.
editor
.
keymap
"
;
const
AUTO_CLOSE
=
"
devtools
.
editor
.
autoclosebrackets
"
;
const
AUTOCOMPLETE
=
"
devtools
.
editor
.
autocomplete
"
;
const
CARET_BLINK_TIME
=
"
ui
.
caretBlinkTime
"
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
VALID_KEYMAPS
=
new
Map
(
[
[
"
emacs
"
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
keymap
/
emacs
.
js
"
]
[
"
vim
"
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
keymap
/
vim
.
js
"
]
[
"
sublime
"
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
keymap
/
sublime
.
js
"
]
]
)
;
const
MAX_VERTICAL_OFFSET
=
3
;
const
RE_JUMP_TO_LINE
=
/
^
(
\
d
+
)
:
?
(
\
d
+
)
?
/
;
const
AUTOCOMPLETE_MARK_CLASSNAME
=
"
cm
-
auto
-
complete
-
shadow
-
text
"
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
PrefObserver
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
prefs
.
js
"
)
;
const
KeyShortcuts
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
key
-
shortcuts
.
js
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
sourceeditor
.
properties
"
)
;
loader
.
lazyRequireGetter
(
this
"
wasm
"
"
resource
:
/
/
devtools
/
client
/
shared
/
sourceeditor
/
wasm
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
scopeUtils
"
"
resource
:
/
/
devtools
/
client
/
shared
/
sourceeditor
/
scope
-
utils
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
lezerUtils
"
"
resource
:
/
/
devtools
/
client
/
shared
/
sourceeditor
/
lezer
-
utils
.
js
"
)
;
const
{
OS
}
=
Services
.
appinfo
;
const
CM_BUNDLE
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
codemirror
.
bundle
.
js
"
;
const
CM_IFRAME
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
cmiframe
.
html
"
;
const
CM_MAPPING
=
[
"
clearHistory
"
"
defaultCharWidth
"
"
extendSelection
"
"
focus
"
"
getCursor
"
"
getLine
"
"
getScrollInfo
"
"
getSelection
"
"
getViewport
"
"
hasFocus
"
"
lineCount
"
"
openDialog
"
"
redo
"
"
refresh
"
"
replaceSelection
"
"
setSelection
"
"
somethingSelected
"
"
undo
"
]
;
const
ONLY_SPACES_REGEXP
=
/
^
\
s
*
/
;
const
editors
=
new
WeakMap
(
)
;
class
Editor
extends
EventEmitter
{
static
accel
(
key
modifiers
=
{
}
)
{
return
(
(
modifiers
.
shift
?
"
Shift
-
"
:
"
"
)
+
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
?
"
Cmd
-
"
:
"
Ctrl
-
"
)
+
(
modifiers
.
alt
?
"
Alt
-
"
:
"
"
)
+
key
)
;
}
static
keyFor
(
cmd
opts
=
{
noaccel
:
false
}
)
{
const
key
=
L10N
.
getStr
(
cmd
+
"
.
commandkey
"
)
;
return
opts
.
noaccel
?
key
:
Editor
.
accel
(
key
)
;
}
static
modes
=
{
cljs
:
{
name
:
"
text
/
x
-
clojure
"
}
css
:
{
name
:
"
css
"
}
fs
:
{
name
:
"
x
-
shader
/
x
-
fragment
"
}
haxe
:
{
name
:
"
haxe
"
}
http
:
{
name
:
"
http
"
}
html
:
{
name
:
"
htmlmixed
"
}
js
:
{
name
:
"
javascript
"
}
text
:
{
name
:
"
text
"
}
vs
:
{
name
:
"
x
-
shader
/
x
-
vertex
"
}
wasm
:
{
name
:
"
wasm
"
}
}
;
container
=
null
;
version
=
null
;
config
=
null
;
Doc
=
null
;
searchState
=
{
cursors
:
[
]
currentCursorIndex
:
-
1
query
:
"
"
}
;
#
abortController
;
#
currentDocumentId
=
null
;
#
currentDocument
=
null
;
#
CodeMirror6
;
#
compartments
;
#
effects
;
#
lastDirty
;
#
loadedKeyMaps
;
#
ownerDoc
;
#
prefObserver
;
#
win
;
#
lineGutterMarkers
=
new
Map
(
)
;
#
lineContentMarkers
=
new
Map
(
)
;
#
posContentMarkers
=
new
Map
(
)
;
#
editorDOMEventHandlers
=
{
}
;
#
gutterDOMEventHandlers
=
{
}
;
#
scrollSnapshots
=
new
Map
(
)
;
#
updateListener
=
null
;
#
languageModes
=
new
Map
(
)
;
#
sources
=
new
Map
(
)
;
constructor
(
config
)
{
super
(
)
;
const
tabSize
=
Services
.
prefs
.
getIntPref
(
TAB_SIZE
)
;
const
useTabs
=
!
Services
.
prefs
.
getBoolPref
(
EXPAND_TAB
)
;
const
useAutoClose
=
Services
.
prefs
.
getBoolPref
(
AUTO_CLOSE
)
;
this
.
version
=
null
;
this
.
config
=
{
cm6
:
false
value
:
"
"
mode
:
Editor
.
modes
.
text
indentUnit
:
tabSize
tabSize
contextMenu
:
null
matchBrackets
:
true
highlightSelectionMatches
:
{
wordsOnly
:
true
}
extraKeys
:
{
}
indentWithTabs
:
useTabs
inputStyle
:
"
accessibleTextArea
"
pollInterval
:
Math
.
pow
(
2
31
)
-
1
styleActiveLine
:
true
autoCloseBrackets
:
"
(
)
[
]
{
}
'
'
\
"
\
"
"
autoCloseEnabled
:
useAutoClose
theme
:
"
mozilla
"
themeSwitching
:
true
autocomplete
:
false
autocompleteOpts
:
{
}
cssProperties
:
null
disableSearchAddon
:
false
maxHighlightLength
:
1000
cursorBlinkRate
:
0
specialChars
:
/
[
\
u0000
-
\
u001f
\
u007f
-
\
u009f
\
u00ad
\
u061c
\
u200b
-
\
u200f
\
u2028
\
u2029
\
u202d
\
u202e
\
u2066
\
u2067
\
u2069
\
ufeff
\
ufff9
-
\
ufffc
]
/
specialCharPlaceholder
:
char
=
>
{
const
doc
=
this
.
#
ownerDoc
;
const
el
=
doc
.
createElement
(
"
span
"
)
;
el
.
classList
.
add
(
"
cm
-
non
-
printable
-
char
"
)
;
el
.
append
(
doc
.
createTextNode
(
\
\
u
{
char
.
codePointAt
(
0
)
.
toString
(
16
)
}
)
)
;
return
el
;
}
styleSelectedText
:
true
}
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
jumpToLine
"
)
]
=
(
)
=
>
this
.
jumpToLine
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
moveLineUp
"
{
noaccel
:
true
}
)
]
=
(
)
=
>
this
.
moveLineUp
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
moveLineDown
"
{
noaccel
:
true
}
)
]
=
(
)
=
>
this
.
moveLineDown
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
toggleComment
"
)
]
=
"
toggleComment
"
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
indentLess
"
)
]
=
false
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
indentMore
"
)
]
=
false
;
this
.
config
.
extraKeys
[
"
Alt
-
B
"
]
=
false
;
this
.
config
.
extraKeys
[
"
Alt
-
F
"
]
=
false
;
this
.
config
.
extraKeys
[
Editor
.
accel
(
"
U
"
)
]
=
false
;
if
(
!
config
.
disableSearchAddon
)
{
this
.
config
.
extraKeys
[
Editor
.
accel
(
"
F
"
)
]
=
(
)
=
>
editors
.
get
(
this
)
.
execCommand
(
"
findPersistent
"
)
;
}
this
.
config
.
extraKeys
[
"
'
\
u0000
'
"
]
=
false
;
Object
.
keys
(
config
)
.
forEach
(
k
=
>
{
if
(
k
!
=
"
extraKeys
"
)
{
this
.
config
[
k
]
=
config
[
k
]
;
return
;
}
if
(
!
config
.
extraKeys
)
{
return
;
}
Object
.
keys
(
config
.
extraKeys
)
.
forEach
(
key
=
>
{
this
.
config
.
extraKeys
[
key
]
=
config
.
extraKeys
[
key
]
;
}
)
;
}
)
;
if
(
!
this
.
config
.
gutters
)
{
this
.
config
.
gutters
=
[
]
;
}
if
(
this
.
config
.
lineNumbers
&
&
!
this
.
config
.
gutters
.
includes
(
"
CodeMirror
-
linenumbers
"
)
)
{
this
.
config
.
gutters
.
push
(
"
CodeMirror
-
linenumbers
"
)
;
}
this
.
config
.
autoCloseBracketsSaved
=
this
.
config
.
autoCloseBrackets
;
if
(
this
.
config
.
extraKeys
.
Tab
!
=
=
false
)
{
this
.
config
.
extraKeys
.
Tab
=
cm
=
>
{
if
(
config
.
extraKeys
?
.
Tab
)
{
const
res
=
config
.
extraKeys
.
Tab
(
cm
)
;
if
(
res
=
=
=
false
)
{
return
;
}
}
if
(
cm
.
somethingSelected
(
)
)
{
cm
.
indentSelection
(
"
add
"
)
;
return
;
}
if
(
this
.
config
.
indentWithTabs
)
{
cm
.
replaceSelection
(
"
\
t
"
"
end
"
"
+
input
"
)
;
return
;
}
let
num
=
cm
.
getOption
(
"
indentUnit
"
)
;
if
(
cm
.
getCursor
(
)
.
ch
!
=
=
0
)
{
num
-
=
cm
.
getCursor
(
)
.
ch
%
num
;
}
cm
.
replaceSelection
(
"
"
.
repeat
(
num
)
"
end
"
"
+
input
"
)
;
}
;
if
(
this
.
config
.
cssProperties
)
{
this
.
config
.
autocompleteOpts
.
cssProperties
=
this
.
config
.
cssProperties
;
}
}
}
get
CodeMirror
(
)
{
const
codeMirror
=
editors
.
get
(
this
)
;
return
codeMirror
?
.
constructor
;
}
get
codeMirror
(
)
{
if
(
!
editors
.
has
(
this
)
)
{
throw
new
Error
(
"
CodeMirror
instance
does
not
exist
.
You
must
wait
"
+
"
for
it
to
be
appended
to
the
DOM
.
"
)
;
}
return
editors
.
get
(
this
)
;
}
get
hasCodeMirror
(
)
{
return
editors
.
has
(
this
)
;
}
appendTo
(
el
env
)
{
return
new
Promise
(
resolve
=
>
{
const
cm
=
editors
.
get
(
this
)
;
if
(
!
env
)
{
env
=
el
.
ownerDocument
.
createElementNS
(
XHTML_NS
"
iframe
"
)
;
env
.
className
=
"
source
-
editor
-
frame
"
;
}
if
(
cm
)
{
throw
new
Error
(
"
You
can
append
an
editor
only
once
.
"
)
;
}
const
onLoad
=
(
)
=
>
{
env
.
style
.
visibility
=
"
"
;
const
win
=
env
.
contentWindow
.
wrappedJSObject
;
this
.
container
=
env
;
const
editorEl
=
win
.
document
.
body
;
const
editorDoc
=
el
.
ownerDocument
;
if
(
this
.
config
.
cm6
)
{
this
.
#
setupCm6
(
editorEl
editorDoc
)
;
}
else
{
this
.
#
setup
(
editorEl
editorDoc
)
;
}
resolve
(
)
;
}
;
env
.
style
.
visibility
=
"
hidden
"
;
env
.
addEventListener
(
"
load
"
onLoad
{
capture
:
true
once
:
true
signal
:
this
.
#
abortController
?
.
signal
}
)
;
env
.
src
=
CM_IFRAME
;
el
.
appendChild
(
env
)
;
this
.
once
(
"
destroy
"
(
)
=
>
el
.
removeChild
(
env
)
)
;
}
)
;
}
appendToLocalElement
(
el
)
{
const
win
=
el
.
ownerDocument
.
defaultView
;
this
.
#
abortController
=
new
win
.
AbortController
(
)
;
if
(
this
.
config
.
cm6
)
{
this
.
#
setupCm6
(
el
)
;
}
else
{
this
.
#
setup
(
el
)
;
}
}
setUpdateListener
(
listener
=
null
)
{
this
.
#
updateListener
=
listener
;
}
#
setup
(
el
doc
)
{
this
.
#
ownerDoc
=
doc
|
|
el
.
ownerDocument
;
const
win
=
el
.
ownerDocument
.
defaultView
;
Services
.
scriptloader
.
loadSubScript
(
CM_BUNDLE
win
)
;
this
.
#
win
=
win
;
if
(
this
.
config
.
cssProperties
)
{
const
{
propertyKeywords
colorKeywords
valueKeywords
}
=
getCSSKeywords
(
this
.
config
.
cssProperties
)
;
const
cssSpec
=
win
.
CodeMirror
.
resolveMode
(
"
text
/
css
"
)
;
cssSpec
.
propertyKeywords
=
propertyKeywords
;
cssSpec
.
colorKeywords
=
colorKeywords
;
cssSpec
.
valueKeywords
=
valueKeywords
;
win
.
CodeMirror
.
defineMIME
(
"
text
/
css
"
cssSpec
)
;
const
scssSpec
=
win
.
CodeMirror
.
resolveMode
(
"
text
/
x
-
scss
"
)
;
scssSpec
.
propertyKeywords
=
propertyKeywords
;
scssSpec
.
colorKeywords
=
colorKeywords
;
scssSpec
.
valueKeywords
=
valueKeywords
;
win
.
CodeMirror
.
defineMIME
(
"
text
/
x
-
scss
"
scssSpec
)
;
}
win
.
CodeMirror
.
commands
.
save
=
(
)
=
>
this
.
emit
(
"
saveRequested
"
)
;
const
cm
=
win
.
CodeMirror
(
el
this
.
config
)
;
this
.
Doc
=
win
.
CodeMirror
.
Doc
;
cm
.
getScrollerElement
(
)
.
addEventListener
(
"
wheel
"
ev
=
>
{
ev
.
preventDefault
(
)
;
let
{
deltaX
deltaY
}
=
ev
;
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_LINE
)
{
deltaX
*
=
cm
.
defaultCharWidth
(
)
;
deltaY
*
=
cm
.
defaultTextHeight
(
)
;
}
else
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_PAGE
)
{
deltaX
*
=
cm
.
getWrapperElement
(
)
.
clientWidth
;
deltaY
*
=
cm
.
getWrapperElement
(
)
.
clientHeight
;
}
cm
.
getScrollerElement
(
)
.
scrollBy
(
deltaX
deltaY
)
;
}
{
signal
:
this
.
#
abortController
?
.
signal
}
)
;
cm
.
getWrapperElement
(
)
.
addEventListener
(
"
contextmenu
"
ev
=
>
{
if
(
!
this
.
config
.
contextMenu
)
{
return
;
}
ev
.
stopPropagation
(
)
;
ev
.
preventDefault
(
)
;
let
popup
=
this
.
config
.
contextMenu
;
if
(
typeof
popup
=
=
"
string
"
)
{
popup
=
this
.
#
ownerDoc
.
getElementById
(
this
.
config
.
contextMenu
)
;
}
this
.
emit
(
"
popupOpen
"
ev
popup
)
;
popup
.
openPopupAtScreen
(
ev
.
screenX
ev
.
screenY
true
)
;
}
{
signal
:
this
.
#
abortController
?
.
signal
}
)
;
const
pipedEvents
=
[
"
beforeChange
"
"
blur
"
"
changes
"
"
cursorActivity
"
"
focus
"
"
keyHandled
"
"
scroll
"
]
;
for
(
const
eventName
of
pipedEvents
)
{
cm
.
on
(
eventName
(
.
.
.
args
)
=
>
this
.
emit
(
eventName
.
.
.
args
)
)
;
}
cm
.
on
(
"
change
"
(
)
=
>
{
this
.
emit
(
"
change
"
)
;
if
(
!
this
.
#
lastDirty
)
{
this
.
#
lastDirty
=
true
;
this
.
emit
(
"
dirty
-
change
"
)
;
}
}
)
;
cm
.
on
(
"
gutterClick
"
(
cmArg
line
gutter
ev
)
=
>
{
const
lineOrOffset
=
!
this
.
isWasm
?
line
:
this
.
lineToWasmOffset
(
line
)
;
this
.
emit
(
"
gutterClick
"
lineOrOffset
ev
.
button
)
;
}
)
;
win
.
CodeMirror
.
defineExtension
(
"
l10n
"
name
=
>
{
return
L10N
.
getStr
(
name
)
;
}
)
;
if
(
!
this
.
config
.
disableSearchAddon
)
{
this
.
#
initSearchShortcuts
(
win
)
;
}
else
{
Object
.
assign
(
win
.
CodeMirror
.
commands
{
find
:
null
findPersistent
:
null
findPersistentNext
:
null
findPersistentPrev
:
null
findNext
:
null
findPrev
:
null
clearSearch
:
null
replace
:
null
replaceAll
:
null
}
)
;
}
let
cursorBlinkingRate
=
win
.
CodeMirror
.
defaults
.
cursorBlinkRate
;
if
(
Services
.
prefs
.
prefHasUserValue
(
CARET_BLINK_TIME
)
)
{
cursorBlinkingRate
=
Services
.
prefs
.
getIntPref
(
CARET_BLINK_TIME
cursorBlinkingRate
)
;
}
cm
.
getWrapperElement
(
)
.
style
.
setProperty
(
"
-
-
caret
-
blink
-
time
"
{
Math
.
max
(
0
cursorBlinkingRate
)
}
ms
)
;
editors
.
set
(
this
cm
)
;
this
.
reloadPreferences
=
this
.
reloadPreferences
.
bind
(
this
)
;
this
.
setKeyMap
=
this
.
setKeyMap
.
bind
(
this
win
)
;
this
.
#
prefObserver
=
new
PrefObserver
(
"
devtools
.
editor
.
"
)
;
this
.
#
prefObserver
.
on
(
TAB_SIZE
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
on
(
EXPAND_TAB
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
on
(
AUTO_CLOSE
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
on
(
AUTOCOMPLETE
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
on
(
DETECT_INDENT
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
on
(
ENABLE_CODE_FOLDING
this
.
reloadPreferences
)
;
this
.
reloadPreferences
(
)
;
this
.
#
loadedKeyMaps
=
new
Set
(
)
;
this
.
#
prefObserver
.
on
(
KEYMAP_PREF
this
.
setKeyMap
)
;
this
.
setKeyMap
(
)
;
win
.
editor
=
this
;
const
editorReadyEvent
=
new
win
.
CustomEvent
(
"
editorReady
"
)
;
win
.
dispatchEvent
(
editorReadyEvent
)
;
}
#
setupLanguageModes
(
)
{
if
(
!
this
.
config
.
cm6
)
{
return
;
}
const
{
codemirrorLangJavascript
}
=
this
.
#
CodeMirror6
;
this
.
#
languageModes
.
set
(
Editor
.
modes
.
js
.
name
codemirrorLangJavascript
.
javascript
(
)
)
;
}
#
setupCm6
(
el
doc
)
{
this
.
#
ownerDoc
=
doc
|
|
el
.
ownerDocument
;
const
win
=
el
.
ownerDocument
.
defaultView
;
this
.
#
win
=
win
;
this
.
#
CodeMirror6
=
this
.
#
win
.
ChromeUtils
.
importESModule
(
"
resource
:
/
/
devtools
/
client
/
shared
/
sourceeditor
/
codemirror6
/
codemirror6
.
bundle
.
mjs
"
{
global
:
"
current
"
}
)
;
const
{
codemirror
codemirrorView
:
{
drawSelection
EditorView
keymap
lineNumbers
placeholder
}
codemirrorState
:
{
EditorState
Compartment
Prec
}
codemirrorSearch
:
{
highlightSelectionMatches
}
codemirrorLanguage
:
{
syntaxTreeAvailable
indentUnit
codeFolding
syntaxHighlighting
bracketMatching
}
lezerHighlight
}
=
this
.
#
CodeMirror6
;
const
tabSizeCompartment
=
new
Compartment
(
)
;
const
indentCompartment
=
new
Compartment
(
)
;
const
lineWrapCompartment
=
new
Compartment
(
)
;
const
lineNumberCompartment
=
new
Compartment
(
)
;
const
lineNumberMarkersCompartment
=
new
Compartment
(
)
;
const
searchHighlightCompartment
=
new
Compartment
(
)
;
const
domEventHandlersCompartment
=
new
Compartment
(
)
;
const
foldGutterCompartment
=
new
Compartment
(
)
;
const
languageCompartment
=
new
Compartment
(
)
;
this
.
#
compartments
=
{
tabSizeCompartment
indentCompartment
lineWrapCompartment
lineNumberCompartment
lineNumberMarkersCompartment
searchHighlightCompartment
domEventHandlersCompartment
foldGutterCompartment
languageCompartment
}
;
const
{
lineContentMarkerEffect
lineContentMarkerExtension
}
=
this
.
#
createlineContentMarkersExtension
(
)
;
const
{
positionContentMarkerEffect
positionContentMarkerExtension
}
=
this
.
#
createPositionContentMarkersExtension
(
)
;
this
.
#
effects
=
{
lineContentMarkerEffect
positionContentMarkerEffect
}
;
const
indentStr
=
(
this
.
config
.
indentWithTabs
?
"
\
t
"
:
"
"
)
.
repeat
(
this
.
config
.
indentUnit
|
|
2
)
;
this
.
#
editorDOMEventHandlers
.
scroll
=
[
debounce
(
this
.
#
cacheScrollSnapshot
250
)
]
;
this
.
#
setupLanguageModes
(
)
;
const
languageMode
=
[
]
;
if
(
this
.
config
.
mode
&
&
this
.
#
languageModes
.
has
(
this
.
config
.
mode
.
name
)
)
{
languageMode
.
push
(
this
.
#
languageModes
.
get
(
this
.
config
.
mode
.
name
)
)
;
}
const
extensions
=
[
bracketMatching
(
)
indentCompartment
.
of
(
indentUnit
.
of
(
indentStr
)
)
tabSizeCompartment
.
of
(
EditorState
.
tabSize
.
of
(
this
.
config
.
tabSize
)
)
lineWrapCompartment
.
of
(
this
.
config
.
lineWrapping
?
EditorView
.
lineWrapping
:
[
]
)
EditorState
.
readOnly
.
of
(
this
.
config
.
readOnly
)
lineNumberCompartment
.
of
(
this
.
config
.
lineNumbers
?
lineNumbers
(
)
:
[
]
)
codeFolding
(
{
placeholderText
:
"
"
}
)
foldGutterCompartment
.
of
(
[
]
)
syntaxHighlighting
(
lezerHighlight
.
classHighlighter
)
EditorView
.
updateListener
.
of
(
v
=
>
{
if
(
!
cm
.
isDocumentLoadComplete
)
{
if
(
syntaxTreeAvailable
(
v
.
state
v
.
view
.
viewState
.
viewport
.
to
)
)
{
cm
.
isDocumentLoadComplete
=
true
;
}
}
if
(
v
.
viewportChanged
|
|
v
.
docChanged
)
{
if
(
v
.
docChanged
)
{
cm
.
isDocumentLoadComplete
=
false
;
}
if
(
this
.
#
lineGutterMarkers
.
size
>
0
)
{
this
.
setLineGutterMarkers
(
)
;
}
}
if
(
typeof
this
.
#
updateListener
=
=
"
function
"
)
{
this
.
#
updateListener
(
v
)
;
}
}
)
domEventHandlersCompartment
.
of
(
EditorView
.
domEventHandlers
(
this
.
#
createEventHandlers
(
)
)
)
lineNumberMarkersCompartment
.
of
(
[
]
)
lineContentMarkerExtension
positionContentMarkerExtension
searchHighlightCompartment
.
of
(
this
.
#
searchHighlighterExtension
(
[
]
)
)
languageCompartment
.
of
(
languageMode
)
highlightSelectionMatches
(
)
codemirror
.
minimalSetup
]
;
if
(
this
.
config
.
placeholder
)
{
extensions
.
push
(
placeholder
(
this
.
config
.
placeholder
)
)
;
}
if
(
this
.
config
.
keyMap
)
{
extensions
.
push
(
Prec
.
highest
(
keymap
.
of
(
this
.
config
.
keyMap
)
)
)
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
CARET_BLINK_TIME
)
)
{
const
cursorBlinkRate
=
Services
.
prefs
.
getIntPref
(
CARET_BLINK_TIME
)
*
2
;
extensions
.
push
(
drawSelection
(
{
cursorBlinkRate
}
)
)
;
}
const
cm
=
new
EditorView
(
{
parent
:
el
extensions
}
)
;
cm
.
isDocumentLoadComplete
=
false
;
editors
.
set
(
this
cm
)
;
cm
.
contentDOM
.
addEventListener
(
"
blur
"
e
=
>
this
.
emit
(
"
blur
"
e
)
{
signal
:
this
.
#
abortController
?
.
signal
}
)
;
}
#
createlineContentMarkersExtension
(
)
{
const
{
codemirrorView
:
{
Decoration
WidgetType
EditorView
}
codemirrorState
:
{
StateField
StateEffect
}
}
=
this
.
#
CodeMirror6
;
const
lineContentMarkers
=
this
.
#
lineContentMarkers
;
class
LineContentWidget
extends
WidgetType
{
constructor
(
line
value
markerId
createElementNode
)
{
super
(
)
;
this
.
line
=
line
;
this
.
value
=
value
;
this
.
markerId
=
markerId
;
this
.
createElementNode
=
createElementNode
;
}
toDOM
(
)
{
return
this
.
createElementNode
(
this
.
line
this
.
value
)
;
}
eq
(
widget
)
{
return
(
widget
.
line
=
=
this
.
line
&
&
widget
.
markerId
=
=
this
.
markerId
&
&
widget
.
value
=
=
this
.
value
)
;
}
}
function
_buildDecorationsForMarker
(
marker
transaction
newMarkerDecorations
)
{
const
vStartLine
=
transaction
.
state
.
doc
.
lineAt
(
marker
.
_view
.
viewport
.
from
)
;
const
vEndLine
=
transaction
.
state
.
doc
.
lineAt
(
marker
.
_view
.
viewport
.
to
)
;
let
decorationLines
;
if
(
marker
.
shouldMarkAllLines
)
{
decorationLines
=
[
]
;
for
(
let
i
=
vStartLine
.
number
;
i
<
=
vEndLine
.
number
;
i
+
+
)
{
decorationLines
.
push
(
{
line
:
i
}
)
;
}
}
else
{
decorationLines
=
marker
.
lines
;
}
for
(
const
{
line
value
}
of
decorationLines
)
{
if
(
line
<
vStartLine
.
number
|
|
line
>
vEndLine
.
number
)
{
continue
;
}
const
lo
=
transaction
.
state
.
doc
.
line
(
line
)
;
if
(
marker
.
lineClassName
)
{
const
classDecoration
=
Decoration
.
line
(
{
class
:
marker
.
lineClassName
}
)
;
classDecoration
.
markerType
=
marker
.
id
;
newMarkerDecorations
.
push
(
classDecoration
.
range
(
lo
.
from
)
)
;
}
else
if
(
marker
.
createLineElementNode
)
{
const
nodeDecoration
=
Decoration
.
widget
(
{
widget
:
new
LineContentWidget
(
line
value
marker
.
id
marker
.
createLineElementNode
)
side
:
1
block
:
!
!
marker
.
renderAsBlock
}
)
;
nodeDecoration
.
markerType
=
marker
.
id
;
newMarkerDecorations
.
push
(
nodeDecoration
.
range
(
lo
.
to
)
)
;
}
}
}
function
updateDecorations
(
markerDecorations
marker
transaction
)
{
const
newDecorations
=
[
]
;
_buildDecorationsForMarker
(
marker
transaction
newDecorations
)
;
return
markerDecorations
.
update
(
{
filter
:
(
from
to
decoration
)
=
>
{
return
decoration
.
markerType
!
=
=
marker
.
id
;
}
add
:
newDecorations
sort
:
true
}
)
;
}
function
updateDecorationsForAllMarkers
(
markerDecorations
allMarkers
transaction
)
{
const
allNewDecorations
=
[
]
;
for
(
const
marker
of
allMarkers
)
{
_buildDecorationsForMarker
(
marker
transaction
allNewDecorations
)
;
}
return
markerDecorations
.
update
(
{
filter
:
(
)
=
>
false
add
:
allNewDecorations
sort
:
true
}
)
;
}
function
removeDecorations
(
markerDecorations
markerId
)
{
return
markerDecorations
.
update
(
{
filter
:
(
from
to
decoration
)
=
>
{
return
decoration
.
markerType
!
=
=
markerId
;
}
}
)
;
}
/
/
The
effects
used
to
create
the
transaction
when
markers
are
/
/
either
added
and
removed
.
const
addEffect
=
StateEffect
.
define
(
)
;
const
removeEffect
=
StateEffect
.
define
(
)
;
const
lineContentMarkerExtension
=
StateField
.
define
(
{
create
(
)
{
return
Decoration
.
none
;
}
update
(
markerDecorations
transaction
)
{
markerDecorations
=
markerDecorations
.
map
(
transaction
.
changes
)
;
for
(
const
effect
of
transaction
.
effects
)
{
if
(
effect
.
is
(
addEffect
)
)
{
markerDecorations
=
updateDecorations
(
markerDecorations
effect
.
value
transaction
)
;
}
else
if
(
effect
.
is
(
removeEffect
)
)
{
markerDecorations
=
removeDecorations
(
markerDecorations
effect
.
value
)
;
}
else
{
const
cachedMarkers
=
lineContentMarkers
.
values
(
)
;
markerDecorations
=
updateDecorationsForAllMarkers
(
markerDecorations
cachedMarkers
transaction
)
;
}
}
return
markerDecorations
;
}
provide
:
field
=
>
EditorView
.
decorations
.
from
(
field
)
}
)
;
return
{
lineContentMarkerExtension
lineContentMarkerEffect
:
{
addEffect
removeEffect
}
}
;
}
#
createEventHandlers
(
)
{
const
eventHandlers
=
{
}
;
for
(
const
eventName
in
this
.
#
editorDOMEventHandlers
)
{
const
handlers
=
this
.
#
editorDOMEventHandlers
[
eventName
]
;
eventHandlers
[
eventName
]
=
(
event
editor
)
=
>
{
if
(
!
event
.
target
)
{
return
;
}
for
(
const
handler
of
handlers
)
{
event
.
target
.
ownerGlobal
.
setTimeout
(
(
)
=
>
{
const
view
=
editor
.
viewState
;
const
cursorPos
=
lezerUtils
.
positionToLocation
(
view
.
state
.
doc
view
.
state
.
selection
.
main
.
head
)
;
handler
(
event
view
cursorPos
.
line
cursorPos
.
column
)
;
}
0
)
;
}
}
;
}
return
eventHandlers
;
}
addEditorDOMEventListeners
(
domEventHandlers
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorView
:
{
EditorView
}
}
=
this
.
#
CodeMirror6
;
for
(
const
eventName
in
domEventHandlers
)
{
if
(
!
this
.
#
editorDOMEventHandlers
[
eventName
]
)
{
this
.
#
editorDOMEventHandlers
[
eventName
]
=
[
]
;
}
this
.
#
editorDOMEventHandlers
[
eventName
]
.
push
(
domEventHandlers
[
eventName
]
)
;
}
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
domEventHandlersCompartment
.
reconfigure
(
EditorView
.
domEventHandlers
(
this
.
#
createEventHandlers
(
)
)
)
}
)
;
}
#
cacheScrollSnapshot
=
(
)
=
>
{
const
cm
=
editors
.
get
(
this
)
;
if
(
!
this
.
#
currentDocumentId
)
{
return
;
}
this
.
#
scrollSnapshots
.
set
(
this
.
#
currentDocumentId
cm
.
scrollSnapshot
(
)
)
;
this
.
emitForTests
(
"
cm
-
editor
-
scrolled
"
)
;
}
;
removeEditorDOMEventListeners
(
domEventHandlers
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorView
:
{
EditorView
}
}
=
this
.
#
CodeMirror6
;
for
(
const
eventName
in
domEventHandlers
)
{
const
domEventHandler
=
domEventHandlers
[
eventName
]
;
const
cachedEventHandlers
=
this
.
#
editorDOMEventHandlers
[
eventName
]
;
if
(
!
domEventHandler
|
|
!
cachedEventHandlers
)
{
continue
;
}
const
index
=
cachedEventHandlers
.
findIndex
(
handler
=
>
handler
=
=
domEventHandler
)
;
this
.
#
editorDOMEventHandlers
[
eventName
]
.
splice
(
index
1
)
;
}
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
domEventHandlersCompartment
.
reconfigure
(
EditorView
.
domEventHandlers
(
this
.
#
createEventHandlers
(
)
)
)
}
)
;
}
#
clearEditorDOMEventListeners
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorView
:
{
EditorView
}
}
=
this
.
#
CodeMirror6
;
this
.
#
editorDOMEventHandlers
=
{
}
;
this
.
#
gutterDOMEventHandlers
=
{
}
;
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
domEventHandlersCompartment
.
reconfigure
(
EditorView
.
domEventHandlers
(
{
}
)
)
}
)
;
}
setLineContentMarker
(
marker
)
{
const
cm
=
editors
.
get
(
this
)
;
marker
.
_view
=
cm
;
this
.
#
lineContentMarkers
.
set
(
marker
.
id
marker
)
;
cm
.
dispatch
(
{
effects
:
this
.
#
effects
.
lineContentMarkerEffect
.
addEffect
.
of
(
marker
)
}
)
;
}
removeLineContentMarker
(
markerId
)
{
const
cm
=
editors
.
get
(
this
)
;
this
.
#
lineContentMarkers
.
delete
(
markerId
)
;
cm
.
dispatch
(
{
effects
:
this
.
#
effects
.
lineContentMarkerEffect
.
removeEffect
.
of
(
markerId
)
}
)
;
}
#
createPositionContentMarkersExtension
(
)
{
const
{
codemirrorView
:
{
Decoration
EditorView
WidgetType
}
codemirrorState
:
{
StateField
StateEffect
}
codemirrorLanguage
:
{
syntaxTree
}
}
=
this
.
#
CodeMirror6
;
const
cachedPositionContentMarkers
=
this
.
#
posContentMarkers
;
class
NodeWidget
extends
WidgetType
{
constructor
(
{
line
column
isFirstNonSpaceColumn
positionData
markerId
createElementNode
customEq
}
)
{
super
(
)
;
this
.
line
=
line
;
this
.
column
=
column
;
this
.
isFirstNonSpaceColumn
=
isFirstNonSpaceColumn
;
this
.
positionData
=
positionData
;
this
.
markerId
=
markerId
;
this
.
customEq
=
customEq
;
this
.
toDOM
=
(
)
=
>
createElementNode
(
line
column
isFirstNonSpaceColumn
positionData
)
;
}
eq
(
widget
)
{
let
eq
=
this
.
line
=
=
widget
.
line
&
&
this
.
column
=
=
widget
.
column
&
&
this
.
markerId
=
=
widget
.
markerId
;
if
(
this
.
positionData
&
&
this
.
customEq
)
{
eq
=
eq
&
&
this
.
customEq
(
this
.
positionData
widget
.
positionData
)
;
}
return
eq
;
}
}
function
getIndentation
(
lineText
)
{
if
(
!
lineText
)
{
return
0
;
}
const
lineMatch
=
lineText
.
match
(
/
^
\
s
*
/
)
;
if
(
!
lineMatch
)
{
return
0
;
}
return
lineMatch
[
0
]
.
length
;
}
function
_buildDecorationsForPositionMarkers
(
marker
transaction
newMarkerDecorations
)
{
const
viewport
=
marker
.
_view
.
viewport
;
const
vStartLine
=
transaction
.
state
.
doc
.
lineAt
(
viewport
.
from
)
;
const
vEndLine
=
transaction
.
state
.
doc
.
lineAt
(
viewport
.
to
)
;
for
(
const
position
of
marker
.
positions
)
{
if
(
position
.
from
&
&
position
.
to
)
{
if
(
position
.
from
>
=
viewport
.
from
&
&
position
.
to
<
=
viewport
.
to
)
{
if
(
marker
.
positionClassName
)
{
const
classDecoration
=
Decoration
.
mark
(
{
class
:
marker
.
positionClassName
}
)
;
classDecoration
.
markerType
=
marker
.
id
;
newMarkerDecorations
.
push
(
classDecoration
.
range
(
position
.
from
position
.
to
)
)
;
}
}
continue
;
}
if
(
position
.
line
>
=
vStartLine
.
number
&
&
position
.
line
<
=
vEndLine
.
number
)
{
const
line
=
transaction
.
state
.
doc
.
line
(
position
.
line
)
;
const
column
=
Math
.
max
(
position
.
column
getIndentation
(
line
.
text
)
)
;
const
pos
=
line
.
from
+
column
;
if
(
marker
.
createPositionElementNode
)
{
const
isFirstNonSpaceColumn
=
ONLY_SPACES_REGEXP
.
test
(
line
.
text
.
substr
(
0
column
)
)
;
const
nodeDecoration
=
Decoration
.
widget
(
{
widget
:
new
NodeWidget
(
{
line
:
position
.
line
column
:
position
.
column
isFirstNonSpaceColumn
positionData
:
position
.
positionData
markerId
:
marker
.
id
createElementNode
:
marker
.
createPositionElementNode
customEq
:
marker
.
customEq
}
)
side
:
1
}
)
;
nodeDecoration
.
markerType
=
marker
.
id
;
newMarkerDecorations
.
push
(
nodeDecoration
.
range
(
pos
pos
)
)
;
}
if
(
marker
.
positionClassName
)
{
const
tokenAtPos
=
syntaxTree
(
transaction
.
state
)
.
resolve
(
pos
1
)
;
if
(
tokenAtPos
.
from
!
=
=
pos
)
{
continue
;
}
const
tokenString
=
line
.
text
.
slice
(
position
.
column
tokenAtPos
.
to
-
line
.
from
)
;
/
/
Ignore
any
empty
strings
and
opening
braces
if
(
tokenString
=
=
=
"
"
|
|
tokenString
=
=
=
"
{
"
|
|
tokenString
=
=
=
"
[
"
)
{
continue
;
}
const
classDecoration
=
Decoration
.
mark
(
{
class
:
marker
.
positionClassName
}
)
;
classDecoration
.
markerType
=
marker
.
id
;
newMarkerDecorations
.
push
(
classDecoration
.
range
(
pos
tokenAtPos
.
to
)
)
;
}
}
}
}
/
*
*
*
This
updates
the
decorations
for
the
marker
specified
*
*
param
{
Array
}
markerDecorations
-
The
current
decorations
displayed
in
the
document
*
param
{
Array
}
marker
-
The
current
marker
whose
decoration
should
be
update
*
param
{
Transaction
}
transaction
*
returns
*
/
function
updateDecorations
(
markerDecorations
marker
transaction
)
{
const
newDecorations
=
[
]
;
_buildDecorationsForPositionMarkers
(
marker
transaction
newDecorations
)
;
return
markerDecorations
.
update
(
{
filter
:
(
from
to
decoration
)
=
>
{
return
decoration
.
markerType
!
=
=
marker
.
id
;
}
add
:
newDecorations
sort
:
true
}
)
;
}
/
*
*
*
This
updates
all
the
decorations
for
all
the
markers
.
This
*
used
in
scenarios
when
an
update
to
view
(
e
.
g
vertically
scrolling
into
a
new
viewport
)
*
requires
all
the
marker
decoraions
.
*
*
param
{
Array
}
markerDecorations
-
The
current
decorations
displayed
in
the
document
*
param
{
Array
}
markers
-
All
the
cached
markers
*
param
{
Object
}
transaction
*
returns
*
/
function
updateDecorationsForAllMarkers
(
markerDecorations
markers
transaction
)
{
const
allNewDecorations
=
[
]
;
/
/
Sort
the
markers
iterator
thanks
to
displayLast
boolean
.
/
/
This
is
typically
used
by
the
paused
location
marker
to
be
shown
after
the
column
breakpoints
.
markers
=
Array
.
from
(
markers
)
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
displayLast
)
{
return
1
;
}
if
(
b
.
displayLast
)
{
return
-
1
;
}
return
0
;
}
)
;
for
(
const
marker
of
markers
)
{
_buildDecorationsForPositionMarkers
(
marker
transaction
allNewDecorations
)
;
}
return
markerDecorations
.
update
(
{
filter
:
(
)
=
>
false
add
:
allNewDecorations
sort
:
true
}
)
;
}
function
removeDecorations
(
markerDecorations
markerId
)
{
return
markerDecorations
.
update
(
{
filter
:
(
from
to
decoration
)
=
>
{
return
decoration
.
markerType
!
=
=
markerId
;
}
}
)
;
}
const
addEffect
=
StateEffect
.
define
(
)
;
const
removeEffect
=
StateEffect
.
define
(
)
;
const
positionContentMarkerExtension
=
StateField
.
define
(
{
create
(
)
{
return
Decoration
.
none
;
}
update
(
markerDecorations
transaction
)
{
/
/
Map
the
decorations
through
the
transaction
changes
this
is
important
/
/
as
it
remaps
the
decorations
from
positions
in
the
old
document
to
/
/
positions
in
the
new
document
.
markerDecorations
=
markerDecorations
.
map
(
transaction
.
changes
)
;
for
(
const
effect
of
transaction
.
effects
)
{
if
(
effect
.
is
(
addEffect
)
)
{
/
/
When
a
new
marker
is
added
markerDecorations
=
updateDecorations
(
markerDecorations
effect
.
value
transaction
)
;
}
else
if
(
effect
.
is
(
removeEffect
)
)
{
/
/
When
a
marker
is
removed
markerDecorations
=
removeDecorations
(
markerDecorations
effect
.
value
)
;
}
else
{
/
/
For
updates
that
are
not
related
to
this
marker
decoration
/
/
we
want
to
update
the
decorations
when
the
editor
is
scrolled
/
/
and
a
new
viewport
is
loaded
.
markerDecorations
=
updateDecorationsForAllMarkers
(
markerDecorations
cachedPositionContentMarkers
.
values
(
)
transaction
)
;
}
}
return
markerDecorations
;
}
provide
:
field
=
>
EditorView
.
decorations
.
from
(
field
)
}
)
;
return
{
positionContentMarkerExtension
positionContentMarkerEffect
:
{
addEffect
removeEffect
}
}
;
}
/
*
*
*
This
adds
a
marker
used
to
decorate
token
/
content
at
a
specific
position
.
*
param
{
Object
}
marker
*
param
{
String
}
marker
.
id
*
param
{
Array
<
Object
>
}
marker
.
positions
-
This
includes
the
line
/
column
and
any
optional
positionData
which
defines
each
position
.
*
param
{
Function
}
marker
.
createPositionElementNode
-
This
describes
how
to
render
the
marker
.
*
The
position
data
(
i
.
e
line
column
and
positionData
)
are
passed
as
arguments
.
*
param
{
Function
}
marker
.
customEq
-
A
custom
function
to
determine
the
equality
of
the
marker
.
This
allows
the
user
define
special
conditions
*
for
when
position
details
have
changed
and
an
update
of
the
marker
should
happen
.
*
The
positionData
defined
for
the
current
and
the
previous
instance
of
the
marker
are
passed
as
arguments
.
*
/
setPositionContentMarker
(
marker
)
{
const
cm
=
editors
.
get
(
this
)
;
/
/
We
store
the
marker
an
the
view
state
this
is
gives
access
to
viewport
data
/
/
when
defining
updates
to
the
StateField
.
marker
.
_view
=
cm
;
this
.
#
posContentMarkers
.
set
(
marker
.
id
marker
)
;
cm
.
dispatch
(
{
effects
:
this
.
#
effects
.
positionContentMarkerEffect
.
addEffect
.
of
(
marker
)
}
)
;
}
/
*
*
*
This
removes
the
marker
which
has
the
specified
id
*
param
{
string
}
markerId
-
The
unique
identifier
for
this
marker
*
/
removePositionContentMarker
(
markerId
)
{
const
cm
=
editors
.
get
(
this
)
;
this
.
#
posContentMarkers
.
delete
(
markerId
)
;
cm
.
dispatch
(
{
effects
:
this
.
#
effects
.
positionContentMarkerEffect
.
removeEffect
.
of
(
markerId
)
}
)
;
}
/
*
*
*
Set
event
listeners
for
the
line
gutter
*
param
{
Object
}
domEventHandlers
*
*
example
usage
:
*
const
domEventHandlers
=
{
click
(
event
)
{
console
.
log
(
event
)
;
}
}
*
/
setGutterEventListeners
(
domEventHandlers
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorView
:
{
lineNumbers
}
codemirrorLanguage
:
{
foldGutter
}
}
=
this
.
#
CodeMirror6
;
for
(
const
eventName
in
domEventHandlers
)
{
const
handler
=
domEventHandlers
[
eventName
]
;
this
.
#
gutterDOMEventHandlers
[
eventName
]
=
(
view
line
event
)
=
>
{
line
=
view
.
state
.
doc
.
lineAt
(
line
.
from
)
;
handler
(
event
view
line
.
number
)
;
}
;
}
cm
.
dispatch
(
{
effects
:
[
this
.
#
compartments
.
lineNumberCompartment
.
reconfigure
(
lineNumbers
(
{
domEventHandlers
:
this
.
#
gutterDOMEventHandlers
}
)
)
this
.
#
compartments
.
foldGutterCompartment
.
reconfigure
(
foldGutter
(
{
class
:
"
cm6
-
dt
-
foldgutter
"
markerDOM
:
open
=
>
{
if
(
!
this
.
#
ownerDoc
)
{
return
null
;
}
const
button
=
this
.
#
ownerDoc
.
createElement
(
"
button
"
)
;
button
.
classList
.
add
(
"
cm6
-
dt
-
foldgutter__toggle
-
button
"
)
;
button
.
setAttribute
(
"
aria
-
expanded
"
open
)
;
return
button
;
}
domEventHandlers
:
this
.
#
gutterDOMEventHandlers
}
)
)
]
}
)
;
}
setLineGutterMarkers
(
markers
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
markers
)
{
for
(
const
marker
of
markers
)
{
if
(
!
marker
.
id
)
{
throw
new
Error
(
"
Marker
has
no
unique
identifier
"
)
;
}
this
.
#
lineGutterMarkers
.
set
(
marker
.
id
marker
)
;
}
}
else
if
(
!
this
.
#
lineGutterMarkers
.
size
)
{
return
;
}
markers
=
Array
.
from
(
this
.
#
lineGutterMarkers
.
values
(
)
)
;
const
{
codemirrorView
:
{
lineNumberMarkers
GutterMarker
}
codemirrorState
:
{
RangeSetBuilder
}
}
=
this
.
#
CodeMirror6
;
class
LineGutterMarker
extends
GutterMarker
{
constructor
(
className
lineNumber
createElementNode
conditionResult
)
{
super
(
)
;
this
.
elementClass
=
className
|
|
null
;
this
.
lineNumber
=
lineNumber
;
this
.
createElementNode
=
createElementNode
;
this
.
conditionResult
=
conditionResult
;
this
.
toDOM
=
createElementNode
?
(
)
=
>
createElementNode
(
lineNumber
conditionResult
)
:
null
;
}
eq
(
marker
)
{
return
(
marker
.
lineNumber
=
=
this
.
lineNumber
&
&
marker
.
conditionResult
=
=
this
.
conditionResult
)
;
}
}
const
builder
=
new
RangeSetBuilder
(
)
;
const
{
from
to
}
=
cm
.
viewport
;
let
pos
=
from
;
while
(
pos
<
=
to
)
{
const
line
=
cm
.
state
.
doc
.
lineAt
(
pos
)
;
for
(
const
{
lineClassName
condition
createLineElementNode
}
of
markers
)
{
if
(
typeof
condition
!
=
=
"
function
"
)
{
throw
new
Error
(
"
The
condition
is
not
a
valid
function
"
)
;
}
const
conditionResult
=
condition
(
line
.
number
)
;
if
(
conditionResult
!
=
=
false
)
{
builder
.
add
(
line
.
from
line
.
to
new
LineGutterMarker
(
lineClassName
line
.
number
createLineElementNode
conditionResult
)
)
;
}
}
pos
=
line
.
to
+
1
;
}
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
lineNumberMarkersCompartment
.
reconfigure
(
lineNumberMarkers
.
of
(
builder
.
finish
(
)
)
)
}
)
;
}
#
searchHighlighterExtension
(
{
pattern
=
/
.
^
/
g
className
=
"
"
}
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
!
cm
)
{
return
[
]
;
}
const
{
codemirrorView
:
{
Decoration
ViewPlugin
EditorView
MatchDecorator
}
codemirrorSearch
:
{
RegExpCursor
}
}
=
this
.
#
CodeMirror6
;
this
.
searchState
.
query
=
pattern
;
const
searchCursor
=
new
RegExpCursor
(
cm
.
state
.
doc
pattern
{
ignoreCase
:
pattern
.
ignoreCase
}
)
;
this
.
searchState
.
cursors
=
Array
.
from
(
searchCursor
)
;
this
.
searchState
.
currentCursorIndex
=
-
1
;
const
patternMatcher
=
new
MatchDecorator
(
{
regexp
:
pattern
decorate
:
(
add
from
to
)
=
>
{
add
(
from
to
Decoration
.
mark
(
{
class
:
className
}
)
)
;
}
}
)
;
const
searchHighlightView
=
ViewPlugin
.
fromClass
(
class
{
decorations
;
constructor
(
view
)
{
this
.
decorations
=
patternMatcher
.
createDeco
(
view
)
;
}
update
(
viewUpdate
)
{
this
.
decorations
=
patternMatcher
.
updateDeco
(
viewUpdate
this
.
decorations
)
;
}
}
{
decorations
:
instance
=
>
instance
.
decorations
provide
:
plugin
=
>
EditorView
.
atomicRanges
.
of
(
view
=
>
{
return
view
.
plugin
(
plugin
)
?
.
decorations
|
|
Decoration
.
none
;
}
)
}
)
;
return
[
searchHighlightView
]
;
}
highlightSearchMatches
(
pattern
className
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
searchHighlightCompartment
.
reconfigure
(
this
.
#
searchHighlighterExtension
(
{
pattern
className
}
)
)
}
)
;
}
clearSearchMatches
(
)
{
this
.
highlightSearchMatches
(
undefined
"
"
)
;
}
getNextSearchCursor
(
reverse
)
{
if
(
reverse
)
{
if
(
this
.
searchState
.
currentCursorIndex
=
=
0
)
{
this
.
searchState
.
currentCursorIndex
=
this
.
searchState
.
cursors
.
length
-
1
;
}
else
{
this
.
searchState
.
currentCursorIndex
-
-
;
}
}
else
if
(
this
.
searchState
.
currentCursorIndex
=
=
this
.
searchState
.
cursors
.
length
-
1
)
{
this
.
searchState
.
currentCursorIndex
=
0
;
}
else
{
this
.
searchState
.
currentCursorIndex
+
+
;
}
return
this
.
searchState
.
cursors
[
this
.
searchState
.
currentCursorIndex
]
;
}
getLocationsInViewport
(
offsetHorizontalCharacters
=
0
offsetVerticalLines
=
0
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
null
;
}
const
cm
=
editors
.
get
(
this
)
;
let
startLine
endLine
scrollLeft
charWidth
rightPosition
;
if
(
this
.
config
.
cm6
)
{
if
(
!
this
.
#
currentDocumentId
)
{
return
null
;
}
const
{
from
to
}
=
cm
.
viewport
;
startLine
=
cm
.
state
.
doc
.
lineAt
(
from
)
.
number
-
offsetVerticalLines
;
endLine
=
cm
.
state
.
doc
.
lineAt
(
to
)
.
number
+
offsetVerticalLines
;
scrollLeft
=
cm
.
scrollDOM
.
scrollLeft
;
charWidth
=
cm
.
defaultCharacterWidth
;
rightPosition
=
scrollLeft
+
cm
.
dom
.
getBoundingClientRect
(
)
.
width
;
}
else
{
if
(
!
cm
)
{
return
null
;
}
const
scrollArea
=
cm
.
getScrollInfo
(
)
;
const
rect
=
cm
.
getWrapperElement
(
)
.
getBoundingClientRect
(
)
;
startLine
=
cm
.
lineAtHeight
(
rect
.
top
"
window
"
)
-
offsetVerticalLines
;
endLine
=
cm
.
lineAtHeight
(
rect
.
bottom
"
window
"
)
+
offsetVerticalLines
;
scrollLeft
=
cm
.
doc
.
scrollLeft
;
charWidth
=
cm
.
defaultCharWidth
(
)
;
rightPosition
=
scrollLeft
+
(
scrollArea
.
clientWidth
-
30
)
;
}
return
{
start
:
{
line
:
startLine
column
:
scrollLeft
>
0
?
Math
.
floor
(
scrollLeft
/
charWidth
)
-
offsetHorizontalCharacters
:
0
}
end
:
{
line
:
endLine
column
:
Math
.
floor
(
rightPosition
/
charWidth
)
+
offsetHorizontalCharacters
}
}
;
}
getSelectionCursor
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
selection
=
cm
.
state
.
selection
.
ranges
[
0
]
;
const
lineFrom
=
cm
.
state
.
doc
.
lineAt
(
selection
.
from
)
;
const
lineTo
=
cm
.
state
.
doc
.
lineAt
(
selection
.
to
)
;
return
{
from
:
{
line
:
lineFrom
.
number
ch
:
selection
.
from
-
lineFrom
.
from
}
to
:
{
line
:
lineTo
.
number
ch
:
selection
.
to
-
lineTo
.
from
}
}
;
}
return
{
from
:
cm
.
getCursor
(
"
from
"
)
to
:
cm
.
getCursor
(
"
to
"
)
}
;
}
getSelectedText
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
selection
=
cm
.
state
.
selection
.
ranges
[
0
]
;
return
cm
.
state
.
doc
.
sliceString
(
selection
.
from
selection
.
to
)
;
}
return
cm
.
getSelection
(
)
.
trim
(
)
;
}
getPositionAtScreenCoords
(
left
top
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
position
=
cm
.
posAtCoords
(
{
x
:
left
y
:
top
}
false
)
;
const
line
=
cm
.
state
.
doc
.
lineAt
(
position
)
;
return
{
line
:
line
.
number
column
:
position
-
line
.
from
}
;
}
const
{
line
ch
}
=
cm
.
coordsChar
(
{
left
top
}
"
window
"
)
;
return
{
line
:
line
+
1
column
:
ch
}
;
}
isTextSelected
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
selection
=
cm
.
state
.
selection
.
ranges
[
0
]
;
return
selection
.
from
!
=
=
selection
.
to
;
}
return
cm
.
somethingSelected
(
)
;
}
isAppended
(
)
{
return
editors
.
has
(
this
)
;
}
getMode
(
)
{
return
this
.
getOption
(
"
mode
"
)
;
}
loadScript
(
url
)
{
if
(
!
this
.
container
)
{
throw
new
Error
(
"
Can
'
t
load
a
script
until
the
editor
is
loaded
.
"
)
;
}
const
win
=
this
.
container
.
contentWindow
.
wrappedJSObject
;
Services
.
scriptloader
.
loadSubScript
(
url
win
)
;
}
createDocument
(
text
=
"
"
mode
)
{
return
new
this
.
Doc
(
text
mode
)
;
}
replaceDocument
(
doc
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
swapDoc
(
doc
)
;
}
setMode
(
value
)
{
if
(
this
.
config
.
cm6
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
languageCompartment
.
reconfigure
(
[
this
.
#
languageModes
.
get
(
value
)
]
)
}
)
;
}
this
.
setOption
(
"
mode
"
value
)
;
/
/
If
autocomplete
was
set
up
and
the
mode
is
changing
then
/
/
turn
it
off
and
back
on
again
so
the
proper
mode
can
be
used
.
if
(
this
.
config
.
autocomplete
)
{
this
.
setOption
(
"
autocomplete
"
false
)
;
this
.
setOption
(
"
autocomplete
"
true
)
;
}
return
null
;
}
/
*
*
*
The
source
editor
can
expose
several
commands
linked
from
system
and
context
menus
.
*
Kept
for
backward
compatibility
with
styleeditor
.
*
/
insertCommandsController
(
)
{
const
{
insertCommandsController
}
=
require
(
"
resource
:
insertCommandsController
(
this
)
;
}
getText
(
line
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
line
=
=
null
)
{
return
this
.
config
.
cm6
?
cm
.
state
.
doc
.
toString
(
)
:
cm
.
getValue
(
)
;
}
const
info
=
this
.
lineInfo
(
line
)
;
return
info
?
info
.
text
:
"
"
;
}
getDoc
(
)
{
if
(
!
this
.
config
)
{
return
null
;
}
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
if
(
!
this
.
#
currentDocument
)
{
this
.
#
currentDocument
=
{
id
:
this
.
#
currentDocumentId
}
;
}
return
this
.
#
currentDocument
;
}
return
cm
.
getDoc
(
)
;
}
get
isWasm
(
)
{
return
wasm
.
isWasm
(
this
.
getDoc
(
)
)
;
}
getWasmLineNumberFormatter
(
)
{
return
wasm
.
getWasmLineNumberFormatter
(
this
.
getDoc
(
)
)
;
}
wasmOffsetToLine
(
offset
)
{
return
wasm
.
wasmOffsetToLine
(
this
.
getDoc
(
)
offset
)
;
}
lineToWasmOffset
(
number
)
{
return
wasm
.
lineToWasmOffset
(
this
.
getDoc
(
)
number
)
;
}
toLineIfWasmOffset
(
maybeOffset
)
{
if
(
typeof
maybeOffset
!
=
=
"
number
"
|
|
!
this
.
isWasm
)
{
return
maybeOffset
;
}
return
this
.
wasmOffsetToLine
(
maybeOffset
)
;
}
renderWasmText
(
content
)
{
return
wasm
.
renderWasmText
(
this
.
getDoc
(
)
content
)
;
}
lineInfo
(
line
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
el
=
this
.
getElementAtLine
(
line
)
;
return
{
text
:
el
.
innerText
line
:
null
gutterMarkers
:
null
textClass
:
null
bgClass
:
null
wrapClass
:
el
.
className
widgets
:
null
}
;
}
return
cm
.
lineInfo
(
line
)
;
}
async
getFunctionSymbols
(
maxResults
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorLanguage
}
=
this
.
#
CodeMirror6
;
const
functionSymbols
=
[
]
;
let
resultsCount
=
0
;
await
lezerUtils
.
walkTree
(
cm
codemirrorLanguage
{
filterSet
:
lezerUtils
.
nodeTypeSets
.
functionsDeclAndExpr
enterVisitor
:
node
=
>
{
if
(
resultsCount
=
=
maxResults
)
{
return
;
}
const
syntaxNode
=
node
.
node
;
const
name
=
lezerUtils
.
getFunctionName
(
cm
.
state
.
doc
syntaxNode
)
;
if
(
name
=
=
null
)
{
return
;
}
functionSymbols
.
push
(
{
name
klass
:
lezerUtils
.
getFunctionClass
(
cm
.
state
.
doc
syntaxNode
)
location
:
{
start
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
from
)
end
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
to
)
}
parameterNames
:
lezerUtils
.
getFunctionParameterNames
(
cm
.
state
.
doc
syntaxNode
)
identifier
:
null
index
:
node
.
index
}
)
;
resultsCount
+
+
;
}
forceParseTo
:
cm
.
state
.
doc
.
length
}
)
;
return
functionSymbols
;
}
async
getClassSymbols
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorLanguage
}
=
this
.
#
CodeMirror6
;
const
classSymbols
=
[
]
;
await
lezerUtils
.
walkTree
(
cm
codemirrorLanguage
{
filterSet
:
lezerUtils
.
nodeTypeSets
.
classes
enterVisitor
:
node
=
>
{
const
classVarDefNode
=
node
.
node
.
firstChild
.
nextSibling
;
classSymbols
.
push
(
{
name
:
cm
.
state
.
doc
.
sliceString
(
classVarDefNode
.
from
classVarDefNode
.
to
)
location
:
{
start
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
from
)
end
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
to
)
}
}
)
;
}
forceParseTo
:
cm
.
state
.
doc
.
length
}
)
;
return
classSymbols
;
}
async
getClosestFunctionName
(
location
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorLangJavascript
:
{
javascriptLanguage
}
codemirrorLanguage
:
{
forceParsing
syntaxTree
}
}
=
this
.
#
CodeMirror6
;
let
doc
tree
;
const
sourceId
=
location
.
source
.
id
;
if
(
this
.
#
currentDocumentId
=
=
=
sourceId
)
{
doc
=
cm
.
state
.
doc
;
await
forceParsing
(
cm
doc
.
length
10000
)
;
tree
=
syntaxTree
(
cm
.
state
)
;
}
else
{
const
sourceContent
=
this
.
#
sources
.
get
(
location
.
source
.
id
)
;
if
(
!
sourceContent
)
{
console
.
error
(
Can
'
t
find
source
content
for
{
location
.
source
.
id
}
no
function
name
can
be
determined
)
;
return
"
"
;
}
doc
=
cm
.
state
.
toText
(
sourceContent
)
;
tree
=
lezerUtils
.
getTree
(
javascriptLanguage
sourceId
sourceContent
)
;
}
const
token
=
lezerUtils
.
getTreeNodeAtLocation
(
doc
tree
location
)
;
if
(
!
token
)
{
return
null
;
}
const
enclosingScope
=
lezerUtils
.
getEnclosingFunction
(
doc
token
)
;
return
enclosingScope
?
enclosingScope
.
funcName
:
"
"
;
}
async
findBestMatchExpressions
(
tokenLocation
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorLanguage
}
=
this
.
#
CodeMirror6
;
const
expressions
=
[
]
;
const
line
=
cm
.
state
.
doc
.
line
(
tokenLocation
.
line
)
;
const
tokPos
=
line
.
from
+
tokenLocation
.
column
;
await
lezerUtils
.
walkTree
(
cm
codemirrorLanguage
{
filterSet
:
lezerUtils
.
nodeTypeSets
.
expressions
enterVisitor
:
node
=
>
{
if
(
node
.
from
<
=
tokPos
&
&
node
.
to
>
=
tokPos
)
{
expressions
.
push
(
{
type
:
node
.
name
computed
:
false
expression
:
cm
.
state
.
doc
.
sliceString
(
node
.
from
node
.
to
)
location
:
{
start
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
from
)
end
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
to
)
}
from
:
node
.
from
to
:
node
.
to
}
)
;
}
}
walkFrom
:
line
.
from
walkTo
:
line
.
to
}
)
;
return
expressions
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
to
<
b
.
to
)
{
return
-
1
;
}
else
if
(
a
.
to
>
b
.
to
)
{
return
1
;
}
return
0
;
}
)
;
}
async
getInScopeLines
(
location
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorLanguage
}
=
this
.
#
CodeMirror6
;
const
functionLocations
=
[
]
;
await
lezerUtils
.
walkTree
(
cm
codemirrorLanguage
{
filterSet
:
lezerUtils
.
nodeTypeSets
.
functions
enterVisitor
:
node
=
>
{
functionLocations
.
push
(
{
name
:
node
.
name
start
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
from
)
end
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
to
)
}
)
;
}
forceParseTo
:
cm
.
viewport
.
to
}
)
;
const
sortedLocations
=
scopeUtils
.
sortByStart
(
functionLocations
)
;
const
innerLocations
=
scopeUtils
.
getInnerLocations
(
sortedLocations
location
)
;
const
outerLocations
=
sortedLocations
.
filter
(
loc
=
>
{
if
(
innerLocations
.
includes
(
loc
)
)
{
return
false
;
}
return
!
scopeUtils
.
containsPosition
(
loc
location
)
;
}
)
;
const
outOfScopeLines
=
scopeUtils
.
getOutOfScopeLines
(
scopeUtils
.
removeOverlapLocations
(
outerLocations
)
)
;
const
sourceNumLines
=
cm
.
state
.
doc
.
lines
;
const
sourceLines
=
new
Array
(
sourceNumLines
)
;
for
(
let
i
=
0
;
i
<
sourceNumLines
;
i
+
+
)
{
const
line
=
i
+
1
;
if
(
outOfScopeLines
.
size
=
=
0
|
|
!
outOfScopeLines
.
has
(
line
)
)
{
sourceLines
[
i
]
=
line
;
}
}
return
sourceLines
.
filter
(
i
=
>
i
!
=
undefined
)
;
}
async
getBindingReferences
(
location
scope
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
codemirrorLanguage
:
{
syntaxTree
}
}
=
this
.
#
CodeMirror6
;
const
token
=
lezerUtils
.
getTreeNodeAtLocation
(
cm
.
state
.
doc
syntaxTree
(
cm
.
state
)
location
)
;
if
(
!
token
)
{
return
null
;
}
let
scopeNode
=
null
;
let
level
=
0
;
const
bindingReferences
=
{
}
;
while
(
scope
&
&
scope
.
bindings
)
{
const
bindings
=
lezerUtils
.
getScopeBindings
(
scope
.
bindings
)
;
const
seen
=
new
Set
(
)
;
scopeNode
=
lezerUtils
.
getParentScopeOfType
(
scopeNode
|
|
token
scope
.
type
)
;
if
(
!
scopeNode
)
{
break
;
}
await
lezerUtils
.
walkCursor
(
scopeNode
.
node
.
cursor
(
)
{
filterSet
:
lezerUtils
.
nodeTypeSets
.
bindingReferences
enterVisitor
:
node
=
>
{
let
bindingName
=
cm
.
state
.
doc
.
sliceString
(
node
.
from
node
.
to
)
;
if
(
!
(
bindingName
in
bindings
)
|
|
seen
.
has
(
bindingName
)
)
{
return
;
}
const
bindingData
=
bindings
[
bindingName
]
;
const
ref
=
{
start
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
from
)
end
:
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
node
.
to
)
}
;
const
syntaxNode
=
node
.
node
;
if
(
syntaxNode
.
parent
.
name
=
=
lezerUtils
.
nodeTypes
.
MemberExpression
)
{
ref
.
meta
=
lezerUtils
.
getMetaBindings
(
cm
.
state
.
doc
syntaxNode
.
parent
)
;
bindingName
=
cm
.
state
.
doc
.
sliceString
(
syntaxNode
.
parent
.
from
syntaxNode
.
parent
.
to
)
;
const
dotIndex
=
bindingName
.
indexOf
(
"
.
"
)
;
if
(
dotIndex
>
-
1
)
{
bindingName
=
bindingName
.
substring
(
0
dotIndex
)
;
}
}
if
(
!
bindingReferences
[
level
]
)
{
bindingReferences
[
level
]
=
{
}
;
}
if
(
!
bindingReferences
[
level
]
[
bindingName
]
)
{
bindingReferences
[
level
]
[
bindingName
]
=
{
.
.
.
bindingData
refs
:
[
]
}
;
}
bindingReferences
[
level
]
[
bindingName
]
.
refs
.
push
(
ref
)
;
seen
.
add
(
bindingName
)
;
}
}
)
;
if
(
scope
.
type
=
=
=
"
function
"
)
{
break
;
}
level
+
+
;
scope
=
scope
.
parent
;
}
return
bindingReferences
;
}
async
setText
(
value
documentId
)
{
const
cm
=
editors
.
get
(
this
)
;
const
isWasm
=
typeof
value
!
=
=
"
string
"
&
&
"
binary
"
in
value
;
if
(
documentId
)
{
this
.
#
currentDocumentId
=
documentId
;
}
else
{
this
.
#
currentDocumentId
=
null
;
}
if
(
isWasm
)
{
const
binary
=
value
.
binary
;
const
data
=
new
Uint8Array
(
binary
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
data
[
i
]
=
binary
.
charCodeAt
(
i
)
;
}
const
{
lines
done
}
=
wasm
.
getWasmText
(
this
.
getDoc
(
)
data
)
;
const
MAX_LINES
=
10000000
;
if
(
lines
.
length
>
MAX_LINES
)
{
lines
.
splice
(
MAX_LINES
lines
.
length
-
MAX_LINES
)
;
lines
.
push
(
"
;
;
.
.
.
.
text
is
truncated
due
to
the
size
"
)
;
}
if
(
!
done
)
{
lines
.
push
(
"
;
;
.
.
.
.
possible
error
during
wast
conversion
"
)
;
}
if
(
this
.
config
.
cm6
)
{
value
=
lines
.
join
(
"
\
n
"
)
;
}
else
{
value
=
{
split
:
(
)
=
>
lines
}
;
}
}
if
(
this
.
config
.
cm6
)
{
if
(
cm
.
state
.
doc
.
toString
(
)
=
=
value
)
{
return
;
}
const
{
codemirrorView
:
{
EditorView
lineNumbers
}
}
=
this
.
#
CodeMirror6
;
await
cm
.
dispatch
(
{
changes
:
{
from
:
0
to
:
cm
.
state
.
doc
.
length
insert
:
value
}
selection
:
{
anchor
:
0
}
}
)
;
const
effects
=
[
]
;
if
(
this
.
config
?
.
lineNumbers
)
{
const
lineNumbersConfig
=
{
domEventHandlers
:
this
.
#
gutterDOMEventHandlers
}
;
if
(
isWasm
)
{
lineNumbersConfig
.
formatNumber
=
this
.
getWasmLineNumberFormatter
(
)
;
}
effects
.
push
(
this
.
#
compartments
.
lineNumberCompartment
.
reconfigure
(
lineNumbers
(
lineNumbersConfig
)
)
)
;
}
const
scrollSnapshot
=
this
.
#
scrollSnapshots
.
get
(
documentId
)
;
effects
.
push
(
scrollSnapshot
?
scrollSnapshot
:
EditorView
.
scrollIntoView
(
0
)
)
;
await
cm
.
dispatch
(
{
effects
}
)
;
if
(
this
.
currentDocumentId
)
{
if
(
!
scrollSnapshot
)
{
this
.
#
cacheScrollSnapshot
(
)
;
}
}
}
else
{
cm
.
setValue
(
value
)
;
}
this
.
resetIndentUnit
(
)
;
}
addSource
(
id
sourceText
)
{
this
.
#
sources
.
set
(
id
sourceText
)
;
}
clearSources
(
ids
)
{
if
(
ids
)
{
for
(
const
id
of
ids
)
{
this
.
#
sources
.
delete
(
id
)
;
}
}
else
{
this
.
#
sources
.
clear
(
)
;
lezerUtils
.
clear
(
)
;
}
}
sourcesCount
(
)
{
return
this
.
#
sources
.
size
;
}
reloadPreferences
(
)
{
const
useAutoClose
=
Services
.
prefs
.
getBoolPref
(
AUTO_CLOSE
)
;
this
.
setOption
(
"
autoCloseBrackets
"
useAutoClose
?
this
.
config
.
autoCloseBracketsSaved
:
false
)
;
this
.
updateCodeFoldingGutter
(
)
;
this
.
resetIndentUnit
(
)
;
this
.
setupAutoCompletion
(
)
;
}
setKeyMap
(
win
)
{
if
(
this
.
config
.
isReadOnly
)
{
return
;
}
const
keyMap
=
Services
.
prefs
.
getCharPref
(
KEYMAP_PREF
)
;
if
(
VALID_KEYMAPS
.
has
(
keyMap
)
)
{
if
(
!
this
.
#
loadedKeyMaps
.
has
(
keyMap
)
)
{
Services
.
scriptloader
.
loadSubScript
(
VALID_KEYMAPS
.
get
(
keyMap
)
win
)
;
this
.
#
loadedKeyMaps
.
add
(
keyMap
)
;
}
this
.
setOption
(
"
keyMap
"
keyMap
)
;
}
else
{
this
.
setOption
(
"
keyMap
"
"
default
"
)
;
}
}
resetIndentUnit
(
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
const
cm
=
editors
.
get
(
this
)
;
const
iterFn
=
(
start
maxEnd
callback
)
=
>
{
if
(
!
this
.
config
.
cm6
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
;
}
cm
.
eachLine
(
start
maxEnd
line
=
>
{
return
callback
(
line
.
text
)
;
}
)
;
}
else
{
const
iterator
=
cm
.
state
.
doc
.
iterLines
(
start
+
1
Math
.
min
(
cm
.
state
.
doc
.
lines
maxEnd
)
+
1
)
;
let
callbackRes
;
do
{
iterator
.
next
(
)
;
callbackRes
=
callback
(
iterator
.
value
)
;
}
while
(
iterator
.
done
!
=
=
true
&
&
!
callbackRes
)
;
}
}
;
const
{
indentUnit
indentWithTabs
}
=
getIndentationFromIteration
(
iterFn
)
;
if
(
!
this
.
config
.
cm6
)
{
cm
.
setOption
(
"
tabSize
"
indentUnit
)
;
cm
.
setOption
(
"
indentUnit
"
indentUnit
)
;
cm
.
setOption
(
"
indentWithTabs
"
indentWithTabs
)
;
}
else
{
const
{
codemirrorState
:
{
EditorState
}
codemirrorLanguage
}
=
this
.
#
CodeMirror6
;
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
tabSizeCompartment
.
reconfigure
(
EditorState
.
tabSize
.
of
(
indentUnit
)
)
}
)
;
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
indentCompartment
.
reconfigure
(
codemirrorLanguage
.
indentUnit
.
of
(
(
indentWithTabs
?
"
\
t
"
:
"
"
)
.
repeat
(
indentUnit
)
)
)
}
)
;
}
}
replaceText
(
value
from
to
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
!
from
)
{
this
.
setText
(
value
)
;
return
;
}
if
(
!
to
)
{
const
text
=
cm
.
getRange
(
{
line
:
0
ch
:
0
}
from
)
;
this
.
setText
(
text
+
value
)
;
return
;
}
cm
.
replaceRange
(
value
from
to
)
;
}
insertText
(
value
at
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
replaceRange
(
value
at
at
)
;
}
dropSelection
(
)
{
if
(
!
this
.
somethingSelected
(
)
)
{
return
;
}
this
.
setCursor
(
this
.
getCursor
(
)
)
;
}
hasMultipleSelections
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
listSelections
(
)
.
length
>
1
;
}
getFirstVisibleLine
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
lineAtHeight
(
0
"
local
"
)
;
}
setFirstVisibleLine
(
line
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
top
}
=
cm
.
charCoords
(
{
line
ch
:
0
}
"
local
"
)
;
cm
.
scrollTo
(
0
top
)
;
}
setCursor
(
{
line
ch
}
align
)
{
const
cm
=
editors
.
get
(
this
)
;
this
.
alignLine
(
line
align
)
;
cm
.
setCursor
(
{
line
ch
}
)
;
this
.
emit
(
"
cursorActivity
"
)
;
}
alignLine
(
line
align
)
{
const
cm
=
editors
.
get
(
this
)
;
const
from
=
cm
.
lineAtHeight
(
0
"
page
"
)
;
const
to
=
cm
.
lineAtHeight
(
cm
.
getWrapperElement
(
)
.
clientHeight
"
page
"
)
;
const
linesVisible
=
to
-
from
;
const
halfVisible
=
Math
.
round
(
linesVisible
/
2
)
;
if
(
line
<
=
to
&
&
line
>
=
from
)
{
return
;
}
const
offset
=
Math
.
min
(
halfVisible
MAX_VERTICAL_OFFSET
)
;
let
topLine
=
{
center
:
Math
.
max
(
line
-
halfVisible
0
)
bottom
:
Math
.
max
(
line
-
linesVisible
+
offset
0
)
top
:
Math
.
max
(
line
-
offset
0
)
}
[
align
|
|
"
top
"
]
|
|
offset
;
topLine
=
Math
.
min
(
topLine
this
.
lineCount
(
)
)
;
this
.
setFirstVisibleLine
(
topLine
)
;
}
hasMarker
(
line
gutterName
markerClass
)
{
const
marker
=
this
.
getMarker
(
line
gutterName
)
;
if
(
!
marker
)
{
return
false
;
}
return
marker
.
classList
.
contains
(
markerClass
)
;
}
addMarker
(
line
gutterName
markerClass
)
{
const
cm
=
editors
.
get
(
this
)
;
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
const
gutterMarkers
=
info
.
gutterMarkers
;
let
marker
;
if
(
gutterMarkers
)
{
marker
=
gutterMarkers
[
gutterName
]
;
if
(
marker
)
{
marker
.
classList
.
add
(
markerClass
)
;
return
;
}
}
marker
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
div
"
)
;
marker
.
className
=
markerClass
;
cm
.
setGutterMarker
(
info
.
line
gutterName
marker
)
;
}
removeMarker
(
line
gutterName
markerClass
)
{
if
(
!
this
.
hasMarker
(
line
gutterName
markerClass
)
)
{
return
;
}
this
.
lineInfo
(
line
)
.
gutterMarkers
[
gutterName
]
.
classList
.
remove
(
markerClass
)
;
}
addContentMarker
(
line
gutterName
markerClass
content
)
{
const
cm
=
editors
.
get
(
this
)
;
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
const
marker
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
div
"
)
;
marker
.
className
=
markerClass
;
marker
.
innerHTML
=
content
;
cm
.
setGutterMarker
(
info
.
line
gutterName
marker
)
;
}
removeContentMarker
(
line
gutterName
)
{
const
cm
=
editors
.
get
(
this
)
;
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
cm
.
setGutterMarker
(
info
.
line
gutterName
null
)
;
}
getMarker
(
line
gutterName
)
{
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
null
;
}
const
gutterMarkers
=
info
.
gutterMarkers
;
if
(
!
gutterMarkers
)
{
return
null
;
}
return
gutterMarkers
[
gutterName
]
;
}
removeAllMarkers
(
gutterName
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
clearGutter
(
gutterName
)
;
}
setMarkerListeners
(
line
gutterName
markerClass
eventsArg
data
)
{
if
(
!
this
.
hasMarker
(
line
gutterName
markerClass
)
)
{
return
;
}
const
cm
=
editors
.
get
(
this
)
;
const
marker
=
cm
.
lineInfo
(
line
)
.
gutterMarkers
[
gutterName
]
;
for
(
const
name
in
eventsArg
)
{
const
listener
=
eventsArg
[
name
]
.
bind
(
this
line
marker
data
)
;
marker
.
addEventListener
(
name
listener
{
signal
:
this
.
#
abortController
?
.
signal
}
)
;
}
}
hasLineClass
(
line
className
)
{
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
|
|
!
info
.
wrapClass
)
{
return
false
;
}
return
info
.
wrapClass
.
split
(
"
"
)
.
includes
(
className
)
;
}
addLineClass
(
lineOrOffset
className
)
{
const
cm
=
editors
.
get
(
this
)
;
const
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
cm
.
addLineClass
(
line
"
wrap
"
className
)
;
}
removeLineClass
(
lineOrOffset
className
)
{
const
cm
=
editors
.
get
(
this
)
;
const
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
cm
.
removeLineClass
(
line
"
wrap
"
className
)
;
}
markText
(
from
to
className
=
"
marked
-
text
"
)
{
const
cm
=
editors
.
get
(
this
)
;
const
text
=
cm
.
getRange
(
from
to
)
;
const
span
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
span
"
)
;
span
.
className
=
className
;
span
.
textContent
=
text
;
const
mark
=
cm
.
markText
(
from
to
{
replacedWith
:
span
}
)
;
return
{
anchor
:
span
clear
:
(
)
=
>
mark
.
clear
(
)
}
;
}
getPosition
(
.
.
.
args
)
{
const
cm
=
editors
.
get
(
this
)
;
const
res
=
args
.
map
(
ind
=
>
cm
.
posFromIndex
(
ind
)
)
;
return
args
.
length
=
=
=
1
?
res
[
0
]
:
res
;
}
getOffset
(
.
.
.
args
)
{
const
cm
=
editors
.
get
(
this
)
;
const
res
=
args
.
map
(
pos
=
>
cm
.
indexFromPos
(
pos
)
)
;
return
args
.
length
>
1
?
res
:
res
[
0
]
;
}
getPositionFromCoords
(
{
left
top
}
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
coordsChar
(
{
left
top
}
)
;
}
canUndo
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
historySize
(
)
.
undo
>
0
;
}
canRedo
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
historySize
(
)
.
redo
>
0
;
}
setClean
(
)
{
const
cm
=
editors
.
get
(
this
)
;
this
.
version
=
cm
.
changeGeneration
(
)
;
this
.
#
lastDirty
=
false
;
this
.
emit
(
"
dirty
-
change
"
)
;
return
this
.
version
;
}
isClean
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
isClean
(
this
.
version
)
;
}
jumpToLine
(
)
{
const
doc
=
editors
.
get
(
this
)
.
getWrapperElement
(
)
.
ownerDocument
;
const
div
=
doc
.
createElement
(
"
div
"
)
;
const
inp
=
doc
.
createElement
(
"
input
"
)
;
const
txt
=
doc
.
createTextNode
(
L10N
.
getStr
(
"
gotoLineCmd
.
promptTitle
"
)
)
;
inp
.
type
=
"
text
"
;
inp
.
style
.
width
=
"
10em
"
;
inp
.
style
.
marginInlineStart
=
"
1em
"
;
div
.
appendChild
(
txt
)
;
div
.
appendChild
(
inp
)
;
this
.
openDialog
(
div
line
=
>
{
const
match
=
line
.
toString
(
)
.
match
(
RE_JUMP_TO_LINE
)
;
if
(
match
)
{
const
[
matchLine
column
]
=
match
;
this
.
setCursor
(
{
line
:
matchLine
-
1
ch
:
column
?
column
-
1
:
0
}
)
;
}
}
)
;
}
moveLineUp
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
start
=
cm
.
getCursor
(
"
start
"
)
;
const
end
=
cm
.
getCursor
(
"
end
"
)
;
if
(
start
.
line
=
=
=
0
)
{
return
;
}
let
value
;
if
(
start
.
line
!
=
=
end
.
line
)
{
value
=
cm
.
getRange
(
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
+
"
\
n
"
;
}
else
{
value
=
cm
.
getLine
(
start
.
line
)
+
"
\
n
"
;
}
value
+
=
cm
.
getLine
(
start
.
line
-
1
)
;
cm
.
replaceRange
(
value
{
line
:
start
.
line
-
1
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
;
cm
.
setSelection
(
{
line
:
start
.
line
-
1
ch
:
start
.
ch
}
{
line
:
end
.
line
-
1
ch
:
end
.
ch
}
)
;
}
moveLineDown
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
start
=
cm
.
getCursor
(
"
start
"
)
;
const
end
=
cm
.
getCursor
(
"
end
"
)
;
if
(
end
.
line
+
1
=
=
=
cm
.
lineCount
(
)
)
{
return
;
}
let
value
=
cm
.
getLine
(
end
.
line
+
1
)
+
"
\
n
"
;
if
(
start
.
line
!
=
=
end
.
line
)
{
value
+
=
cm
.
getRange
(
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
;
}
else
{
value
+
=
cm
.
getLine
(
start
.
line
)
;
}
cm
.
replaceRange
(
value
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
+
1
ch
:
cm
.
getLine
(
end
.
line
+
1
)
.
length
}
)
;
cm
.
setSelection
(
{
line
:
start
.
line
+
1
ch
:
start
.
ch
}
{
line
:
end
.
line
+
1
ch
:
end
.
ch
}
)
;
}
findOrReplace
(
node
isReplaceAll
)
{
const
cm
=
editors
.
get
(
this
)
;
const
isInput
=
node
.
tagName
=
=
=
"
INPUT
"
;
const
isSearchInput
=
isInput
&
&
node
.
type
=
=
=
"
search
"
;
const
isDialogInput
=
isInput
&
&
node
.
parentNode
&
&
node
.
parentNode
.
classList
.
contains
(
"
CodeMirror
-
dialog
"
)
;
if
(
!
(
isSearchInput
|
|
isDialogInput
)
)
{
return
;
}
if
(
isSearchInput
|
|
isReplaceAll
)
{
node
.
select
(
)
;
}
cm
.
execCommand
(
"
findPersistent
"
)
;
}
findNextOrPrev
(
node
isFindPrev
)
{
const
cm
=
editors
.
get
(
this
)
;
const
isInput
=
node
.
tagName
=
=
=
"
INPUT
"
;
const
isSearchInput
=
isInput
&
&
node
.
type
=
=
=
"
search
"
;
if
(
!
isSearchInput
)
{
return
;
}
const
query
=
node
.
value
;
if
(
!
cm
.
state
.
search
|
|
cm
.
state
.
search
.
query
!
=
=
query
)
{
cm
.
state
.
search
=
{
posFrom
:
null
posTo
:
null
overlay
:
null
query
}
;
}
if
(
isFindPrev
)
{
cm
.
execCommand
(
"
findPrev
"
)
;
}
else
{
cm
.
execCommand
(
"
findNext
"
)
;
}
}
getFontSize
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
el
=
cm
.
getWrapperElement
(
)
;
const
win
=
el
.
ownerDocument
.
defaultView
;
return
parseInt
(
win
.
getComputedStyle
(
el
)
.
getPropertyValue
(
"
font
-
size
"
)
10
)
;
}
setFontSize
(
size
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
getWrapperElement
(
)
.
style
.
fontSize
=
parseInt
(
size
10
)
+
"
px
"
;
cm
.
refresh
(
)
;
}
setLineWrapping
(
value
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
{
codemirrorView
:
{
EditorView
}
}
=
this
.
#
CodeMirror6
;
cm
.
dispatch
(
{
effects
:
this
.
#
compartments
.
lineWrapCompartment
.
reconfigure
(
value
?
EditorView
.
lineWrapping
:
[
]
)
}
)
;
}
else
{
cm
.
setOption
(
"
lineWrapping
"
value
)
;
}
this
.
config
.
lineWrapping
=
value
;
}
setOption
(
o
v
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
o
=
=
=
"
autoCloseBrackets
"
&
&
v
)
{
this
.
config
.
autoCloseBracketsSaved
=
v
;
}
if
(
o
=
=
=
"
autocomplete
"
)
{
this
.
config
.
autocomplete
=
v
;
this
.
setupAutoCompletion
(
)
;
}
else
{
cm
.
setOption
(
o
v
)
;
this
.
config
[
o
]
=
v
;
}
if
(
o
=
=
=
"
enableCodeFolding
"
)
{
this
.
updateCodeFoldingGutter
(
)
;
}
}
getOption
(
o
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
o
=
=
=
"
autocomplete
"
)
{
return
this
.
config
.
autocomplete
;
}
return
cm
.
getOption
(
o
)
;
}
setupAutoCompletion
(
)
{
if
(
!
this
.
config
.
autocomplete
&
&
!
this
.
initializeAutoCompletion
)
{
return
;
}
if
(
!
this
.
initializeAutoCompletion
)
{
this
.
extend
(
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
sourceeditor
/
autocomplete
.
js
"
)
)
;
}
if
(
this
.
config
.
autocomplete
&
&
Services
.
prefs
.
getBoolPref
(
AUTOCOMPLETE
)
)
{
this
.
initializeAutoCompletion
(
this
.
config
.
autocompleteOpts
)
;
}
else
{
this
.
destroyAutoCompletion
(
)
;
}
}
getAutoCompletionText
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
mark
=
cm
.
getAllMarks
(
)
.
find
(
m
=
>
m
.
className
=
=
=
AUTOCOMPLETE_MARK_CLASSNAME
)
;
if
(
!
mark
)
{
return
"
"
;
}
return
mark
.
attributes
[
"
data
-
completion
"
]
|
|
"
"
;
}
setAutoCompletionText
(
text
)
{
const
cursor
=
this
.
getCursor
(
)
;
const
cm
=
editors
.
get
(
this
)
;
const
className
=
AUTOCOMPLETE_MARK_CLASSNAME
;
cm
.
operation
(
(
)
=
>
{
cm
.
getAllMarks
(
)
.
forEach
(
mark
=
>
{
if
(
mark
.
className
=
=
=
className
)
{
mark
.
clear
(
)
;
}
}
)
;
if
(
text
)
{
cm
.
markText
(
{
.
.
.
cursor
ch
:
cursor
.
ch
-
1
}
cursor
{
className
attributes
:
{
"
data
-
completion
"
:
text
}
}
)
;
}
}
)
;
}
#
getElementAtOffset
(
offset
)
{
const
cm
=
editors
.
get
(
this
)
;
const
el
=
cm
.
domAtPos
(
offset
)
.
node
;
if
(
!
el
)
{
return
null
;
}
if
(
el
.
nodeType
=
=
nodeConstants
.
TEXT_NODE
)
{
return
el
.
parentElement
;
}
return
el
;
}
isPositionVisible
(
line
column
)
{
const
cm
=
editors
.
get
(
this
)
;
let
inXView
inYView
;
function
withinBounds
(
x
min
max
)
{
return
x
>
=
min
&
&
x
<
=
max
;
}
if
(
this
.
config
.
cm6
)
{
const
pos
=
this
.
#
positionToOffset
(
line
column
)
;
if
(
pos
=
=
null
)
{
return
false
;
}
const
coords
=
cm
.
coordsAtPos
(
pos
)
;
if
(
!
coords
)
{
return
false
;
}
const
{
x
y
width
height
}
=
cm
.
dom
.
getBoundingClientRect
(
)
;
const
gutterWidth
=
cm
.
dom
.
querySelector
(
"
.
cm
-
gutters
"
)
.
clientWidth
;
inXView
=
coords
.
left
>
x
+
gutterWidth
&
&
coords
.
right
<
x
+
width
;
inYView
=
coords
.
top
>
y
&
&
coords
.
bottom
<
y
+
height
;
}
else
{
const
{
top
left
}
=
cm
.
charCoords
(
{
line
ch
:
column
}
"
local
"
)
;
const
scrollArea
=
cm
.
getScrollInfo
(
)
;
const
charWidth
=
cm
.
defaultCharWidth
(
)
;
const
fontHeight
=
cm
.
defaultTextHeight
(
)
;
const
{
scrollTop
scrollLeft
}
=
cm
.
doc
;
inXView
=
withinBounds
(
left
scrollLeft
scrollLeft
+
(
scrollArea
.
clientWidth
-
30
)
-
charWidth
)
;
inYView
=
withinBounds
(
top
scrollTop
scrollTop
+
scrollArea
.
clientHeight
-
fontHeight
)
;
}
return
inXView
&
&
inYView
;
}
#
positionToOffset
(
line
col
=
0
)
{
const
cm
=
editors
.
get
(
this
)
;
try
{
const
offset
=
cm
.
state
.
doc
.
line
(
line
)
;
return
offset
.
from
+
col
;
}
catch
(
e
)
{
console
.
warn
(
e
.
message
)
;
}
return
null
;
}
getPositionFromSearchCursor
(
searchCursor
)
{
const
cm
=
editors
.
get
(
this
)
;
const
lineFrom
=
cm
.
state
.
doc
.
lineAt
(
searchCursor
.
from
)
;
return
{
line
:
lineFrom
.
number
-
1
ch
:
searchCursor
.
to
-
searchCursor
.
match
[
0
]
.
length
-
lineFrom
.
from
}
;
}
scrollToPosition
(
position
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
!
this
.
config
.
cm6
)
{
throw
new
Error
(
"
This
function
is
only
compatible
with
CM6
"
)
;
}
const
{
codemirrorView
:
{
EditorView
}
}
=
this
.
#
CodeMirror6
;
return
cm
.
dispatch
(
{
effects
:
EditorView
.
scrollIntoView
(
position
{
x
:
"
nearest
"
y
:
"
center
"
}
)
}
)
;
}
async
scrollTo
(
line
column
yAlign
)
{
if
(
this
.
isDestroyed
(
)
)
{
return
null
;
}
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
{
codemirrorView
:
{
EditorView
}
}
=
this
.
#
CodeMirror6
;
if
(
!
this
.
isPositionVisible
(
line
column
)
)
{
const
offset
=
this
.
#
positionToOffset
(
line
column
)
;
if
(
offset
=
=
null
)
{
return
null
;
}
return
cm
.
dispatch
(
{
effects
:
EditorView
.
scrollIntoView
(
offset
{
x
:
"
center
"
y
:
yAlign
|
|
"
center
"
}
)
}
)
;
}
}
else
{
if
(
!
line
&
&
!
column
)
{
cm
.
scrollTo
(
0
0
)
;
return
null
;
}
const
{
top
left
}
=
cm
.
charCoords
(
{
line
ch
:
column
}
"
local
"
)
;
if
(
!
this
.
isPositionVisible
(
line
column
)
)
{
const
scroller
=
cm
.
getScrollerElement
(
)
;
const
centeredX
=
Math
.
max
(
left
-
scroller
.
offsetWidth
/
2
0
)
;
const
centeredY
=
Math
.
max
(
top
-
scroller
.
offsetHeight
/
2
0
)
;
return
cm
.
scrollTo
(
centeredX
centeredY
)
;
}
}
return
null
;
}
setSelectionAt
(
start
end
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
from
=
this
.
#
positionToOffset
(
start
.
line
start
.
column
)
;
const
to
=
this
.
#
positionToOffset
(
end
.
line
end
.
column
)
;
if
(
from
=
=
null
|
|
to
=
=
null
)
{
return
;
}
cm
.
dispatch
(
{
selection
:
{
anchor
:
from
head
:
to
}
}
)
;
}
else
{
cm
.
setSelection
(
{
line
:
start
.
line
-
1
ch
:
start
.
column
}
{
line
:
end
.
line
-
1
ch
:
end
.
column
}
)
;
}
}
setCursorAt
(
line
column
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
{
lines
}
=
cm
.
state
.
doc
;
if
(
line
>
lines
)
{
console
.
error
(
Trying
to
set
the
cursor
on
a
non
-
existing
line
{
line
}
>
{
lines
}
)
;
return
null
;
}
const
lineInfo
=
cm
.
state
.
doc
.
line
(
line
+
1
)
;
if
(
column
>
=
lineInfo
.
length
)
{
console
.
error
(
Trying
to
set
the
cursor
on
a
non
-
existing
column
{
column
}
>
=
{
lineInfo
.
length
}
)
;
return
null
;
}
const
position
=
lineInfo
.
from
+
column
;
return
cm
.
dispatch
(
{
selection
:
{
anchor
:
position
head
:
position
}
}
)
;
}
return
cm
.
setCursor
(
{
line
ch
:
column
}
)
;
}
getEditorFileMode
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
return
cm
.
contentDOM
.
dataset
.
language
;
}
return
cm
.
getOption
(
"
mode
"
)
.
name
;
}
getEditorContent
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
return
cm
.
state
.
doc
.
toString
(
)
;
}
return
cm
.
getValue
(
)
;
}
isSearchStateReady
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
return
!
!
this
.
searchState
.
cursors
;
}
return
!
!
cm
.
state
.
search
;
}
getCoords
(
line
column
=
0
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
offset
=
this
.
#
positionToOffset
(
line
column
)
;
if
(
offset
=
=
null
)
{
return
null
;
}
return
cm
.
coordsAtPos
(
offset
)
;
}
return
cm
.
charCoords
(
{
line
:
~
~
line
ch
:
~
~
column
}
)
;
}
getElementAtLine
(
line
)
{
const
offset
=
this
.
#
positionToOffset
(
line
)
;
const
el
=
this
.
#
getElementAtOffset
(
offset
)
;
return
el
.
closest
(
"
.
cm
-
line
"
)
;
}
getSearchQuery
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
return
this
.
searchState
.
query
.
toString
(
)
;
}
return
cm
.
state
.
search
.
query
;
}
getSearchSelection
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
const
cursor
=
this
.
searchState
.
cursors
[
this
.
searchState
.
currentCursorIndex
]
;
if
(
!
cursor
)
{
return
{
text
:
"
"
line
:
-
1
column
:
-
1
}
;
}
const
cursorPosition
=
lezerUtils
.
positionToLocation
(
cm
.
state
.
doc
cursor
.
to
)
;
return
{
text
:
cursor
.
match
[
0
]
line
:
cursorPosition
.
line
-
1
column
:
cursorPosition
.
column
}
;
}
const
cursor
=
cm
.
getCursor
(
)
;
return
{
text
:
cm
.
getSelection
(
)
line
:
cursor
.
line
column
:
cursor
.
ch
}
;
}
getElementAtPos
(
line
column
)
{
const
offset
=
this
.
#
positionToOffset
(
line
column
)
;
const
el
=
this
.
#
getElementAtOffset
(
offset
)
;
return
el
;
}
getLineCount
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
return
cm
.
state
.
doc
.
lines
;
}
return
cm
.
lineCount
(
)
;
}
extend
(
funcs
)
{
Object
.
keys
(
funcs
)
.
forEach
(
name
=
>
{
const
cm
=
editors
.
get
(
this
)
;
const
ctx
=
{
ed
:
this
cm
Editor
}
;
if
(
name
=
=
=
"
initialize
"
)
{
funcs
[
name
]
(
ctx
)
;
return
;
}
this
[
name
]
=
funcs
[
name
]
.
bind
(
null
ctx
)
;
}
)
;
}
isDestroyed
(
)
{
return
!
this
.
config
|
|
!
editors
.
get
(
this
)
;
}
destroy
(
)
{
if
(
this
.
config
.
cm6
&
&
this
.
#
CodeMirror6
)
{
this
.
#
clearEditorDOMEventListeners
(
)
;
}
if
(
this
.
#
abortController
)
{
this
.
#
abortController
.
abort
(
)
;
this
.
#
abortController
=
null
;
}
this
.
container
=
null
;
this
.
config
=
null
;
this
.
version
=
null
;
this
.
#
ownerDoc
=
null
;
this
.
#
updateListener
=
null
;
this
.
#
lineGutterMarkers
.
clear
(
)
;
this
.
#
lineContentMarkers
.
clear
(
)
;
this
.
#
scrollSnapshots
.
clear
(
)
;
this
.
#
languageModes
.
clear
(
)
;
this
.
clearSources
(
)
;
if
(
this
.
#
prefObserver
)
{
this
.
#
prefObserver
.
off
(
KEYMAP_PREF
this
.
setKeyMap
)
;
this
.
#
prefObserver
.
off
(
TAB_SIZE
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
off
(
EXPAND_TAB
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
off
(
AUTO_CLOSE
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
off
(
AUTOCOMPLETE
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
off
(
DETECT_INDENT
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
off
(
ENABLE_CODE_FOLDING
this
.
reloadPreferences
)
;
this
.
#
prefObserver
.
destroy
(
)
;
}
const
cm
=
editors
.
get
(
this
)
;
if
(
cm
?
.
doc
)
{
cm
.
doc
.
cm
=
null
;
}
if
(
cm
?
.
destroy
)
{
cm
.
destroy
(
)
;
}
this
.
emit
(
"
destroy
"
)
;
}
updateCodeFoldingGutter
(
)
{
let
shouldFoldGutter
=
this
.
config
.
enableCodeFolding
;
const
foldGutterIndex
=
this
.
config
.
gutters
.
indexOf
(
"
CodeMirror
-
foldgutter
"
)
;
const
cm
=
editors
.
get
(
this
)
;
if
(
shouldFoldGutter
=
=
=
undefined
)
{
shouldFoldGutter
=
Services
.
prefs
.
getBoolPref
(
ENABLE_CODE_FOLDING
)
;
}
if
(
shouldFoldGutter
)
{
if
(
foldGutterIndex
=
=
=
-
1
)
{
const
gutters
=
this
.
config
.
gutters
.
slice
(
)
;
gutters
.
push
(
"
CodeMirror
-
foldgutter
"
)
;
this
.
setOption
(
"
gutters
"
gutters
)
;
}
this
.
setOption
(
"
foldGutter
"
true
)
;
}
else
{
if
(
cm
)
{
cm
.
execCommand
(
"
unfoldAll
"
)
;
}
if
(
foldGutterIndex
!
=
=
-
1
)
{
const
gutters
=
this
.
config
.
gutters
.
slice
(
)
;
gutters
.
splice
(
foldGutterIndex
1
)
;
this
.
setOption
(
"
gutters
"
gutters
)
;
}
this
.
setOption
(
"
foldGutter
"
false
)
;
}
}
#
initSearchShortcuts
(
win
)
{
const
shortcuts
=
new
KeyShortcuts
(
{
window
:
win
}
)
;
const
keys
=
[
"
find
.
key
"
"
findNext
.
key
"
"
findPrev
.
key
"
]
;
if
(
OS
=
=
=
"
Darwin
"
)
{
keys
.
push
(
"
replaceAllMac
.
key
"
)
;
}
else
{
keys
.
push
(
"
replaceAll
.
key
"
)
;
}
keys
.
forEach
(
name
=
>
{
const
key
=
L10N
.
getStr
(
name
)
;
shortcuts
.
on
(
key
event
=
>
this
.
#
onSearchShortcut
(
name
event
)
)
;
}
)
;
}
#
onSearchShortcut
=
(
name
event
)
=
>
{
if
(
!
this
.
#
isInputOrTextarea
(
event
.
target
)
)
{
return
;
}
const
node
=
event
.
originalTarget
;
switch
(
name
)
{
case
"
replaceAllMac
.
key
"
:
this
.
findOrReplace
(
node
true
)
;
break
;
case
"
replaceAll
.
key
"
:
this
.
findOrReplace
(
node
true
)
;
break
;
case
"
find
.
key
"
:
this
.
findOrReplace
(
node
false
)
;
break
;
case
"
findPrev
.
key
"
:
this
.
findNextOrPrev
(
node
true
)
;
break
;
case
"
findNext
.
key
"
:
this
.
findNextOrPrev
(
node
false
)
;
break
;
default
:
console
.
error
(
"
Unexpected
editor
key
shortcut
"
name
)
;
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
;
#
isInputOrTextarea
(
element
)
{
const
name
=
element
.
tagName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
|
|
name
=
=
=
"
textarea
"
;
}
highlightText
(
doc
code
)
{
if
(
!
doc
)
{
return
code
;
}
const
outputNode
=
doc
.
createElement
(
"
div
"
)
;
if
(
!
this
.
config
.
cm6
)
{
this
.
CodeMirror
.
runMode
(
code
"
application
/
javascript
"
outputNode
)
;
}
else
{
const
{
codemirrorLangJavascript
lezerHighlight
}
=
this
.
#
CodeMirror6
;
const
{
highlightCode
classHighlighter
}
=
lezerHighlight
;
function
emit
(
text
classes
)
{
const
textNode
=
doc
.
createTextNode
(
text
)
;
if
(
classes
)
{
const
span
=
doc
.
createElement
(
"
span
"
)
;
span
.
appendChild
(
textNode
)
;
span
.
className
=
classes
;
outputNode
.
appendChild
(
span
)
;
}
else
{
outputNode
.
appendChild
(
textNode
)
;
}
}
function
emitBreak
(
)
{
outputNode
.
appendChild
(
doc
.
createTextNode
(
"
\
n
"
)
)
;
}
highlightCode
(
code
codemirrorLangJavascript
.
javascriptLanguage
.
parser
.
parse
(
code
)
classHighlighter
emit
emitBreak
)
;
}
return
outputNode
.
innerHTML
;
}
focus
(
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
focus
(
)
;
}
selectAll
(
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
this
.
config
.
cm6
)
{
cm
.
dispatch
(
{
selection
:
{
anchor
:
0
head
:
cm
.
state
.
doc
.
length
}
userEvent
:
"
select
"
}
)
;
}
else
{
cm
.
execCommand
(
"
selectAll
"
)
;
}
}
}
CM_MAPPING
.
forEach
(
name
=
>
{
Editor
.
prototype
[
name
]
=
function
(
.
.
.
args
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
[
name
]
.
apply
(
cm
args
)
;
}
;
}
)
;
function
getCSSKeywords
(
cssProperties
)
{
function
keySet
(
array
)
{
const
keys
=
{
}
;
for
(
let
i
=
0
;
i
<
array
.
length
;
+
+
i
)
{
keys
[
array
[
i
]
]
=
true
;
}
return
keys
;
}
const
propertyKeywords
=
cssProperties
.
getNames
(
)
;
const
colorKeywords
=
{
}
;
const
valueKeywords
=
{
}
;
propertyKeywords
.
forEach
(
property
=
>
{
if
(
property
.
includes
(
"
color
"
)
)
{
cssProperties
.
getValues
(
property
)
.
forEach
(
value
=
>
{
colorKeywords
[
value
]
=
true
;
}
)
;
}
else
{
cssProperties
.
getValues
(
property
)
.
forEach
(
value
=
>
{
valueKeywords
[
value
]
=
true
;
}
)
;
}
}
)
;
return
{
propertyKeywords
:
keySet
(
propertyKeywords
)
colorKeywords
valueKeywords
}
;
}
module
.
exports
=
Editor
;
