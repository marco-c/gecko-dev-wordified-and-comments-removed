"
use
strict
"
;
const
{
EXPAND_TAB
TAB_SIZE
DETECT_INDENT
getIndentationFromIteration
}
=
require
(
"
devtools
/
shared
/
indentation
"
)
;
const
ENABLE_CODE_FOLDING
=
"
devtools
.
editor
.
enableCodeFolding
"
;
const
KEYMAP_PREF
=
"
devtools
.
editor
.
keymap
"
;
const
AUTO_CLOSE
=
"
devtools
.
editor
.
autoclosebrackets
"
;
const
AUTOCOMPLETE
=
"
devtools
.
editor
.
autocomplete
"
;
const
CARET_BLINK_TIME
=
"
ui
.
caretBlinkTime
"
;
const
XUL_NS
=
"
http
:
/
/
www
.
mozilla
.
org
/
keymaster
/
gatekeeper
/
there
.
is
.
only
.
xul
"
;
const
VALID_KEYMAPS
=
new
Map
(
[
[
"
emacs
"
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
keymap
/
emacs
.
js
"
]
[
"
vim
"
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
keymap
/
vim
.
js
"
]
[
"
sublime
"
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
keymap
/
sublime
.
js
"
]
]
)
;
const
MAX_VERTICAL_OFFSET
=
3
;
const
RE_JUMP_TO_LINE
=
/
^
(
\
d
+
)
:
?
(
\
d
+
)
?
/
;
const
AUTOCOMPLETE_MARK_CLASSNAME
=
"
cm
-
auto
-
complete
-
shadow
-
text
"
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
sourceeditor
.
properties
"
)
;
loader
.
lazyRequireGetter
(
this
"
wasm
"
"
devtools
/
client
/
shared
/
sourceeditor
/
wasm
"
)
;
const
{
OS
}
=
Services
.
appinfo
;
const
CM_BUNDLE
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
codemirror
.
bundle
.
js
"
;
const
CM_IFRAME
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
cmiframe
.
html
"
;
const
CM_MAPPING
=
[
"
clearHistory
"
"
defaultCharWidth
"
"
extendSelection
"
"
focus
"
"
getCursor
"
"
getLine
"
"
getScrollInfo
"
"
getSelection
"
"
getViewport
"
"
hasFocus
"
"
lineCount
"
"
openDialog
"
"
redo
"
"
refresh
"
"
replaceSelection
"
"
setSelection
"
"
somethingSelected
"
"
undo
"
]
;
const
editors
=
new
WeakMap
(
)
;
Editor
.
modes
=
{
cljs
:
{
name
:
"
text
/
x
-
clojure
"
}
css
:
{
name
:
"
css
"
}
fs
:
{
name
:
"
x
-
shader
/
x
-
fragment
"
}
haxe
:
{
name
:
"
haxe
"
}
html
:
{
name
:
"
htmlmixed
"
}
js
:
{
name
:
"
javascript
"
}
text
:
{
name
:
"
text
"
}
vs
:
{
name
:
"
x
-
shader
/
x
-
vertex
"
}
wasm
:
{
name
:
"
wasm
"
}
}
;
function
Editor
(
config
)
{
const
tabSize
=
Services
.
prefs
.
getIntPref
(
TAB_SIZE
)
;
const
useTabs
=
!
Services
.
prefs
.
getBoolPref
(
EXPAND_TAB
)
;
const
useAutoClose
=
Services
.
prefs
.
getBoolPref
(
AUTO_CLOSE
)
;
this
.
version
=
null
;
this
.
config
=
{
value
:
"
"
mode
:
Editor
.
modes
.
text
indentUnit
:
tabSize
tabSize
:
tabSize
contextMenu
:
null
matchBrackets
:
true
extraKeys
:
{
}
indentWithTabs
:
useTabs
inputStyle
:
"
accessibleTextArea
"
pollInterval
:
Math
.
pow
(
2
31
)
-
1
styleActiveLine
:
true
autoCloseBrackets
:
"
(
)
[
]
{
}
'
'
\
"
\
"
"
autoCloseEnabled
:
useAutoClose
theme
:
"
mozilla
"
themeSwitching
:
true
autocomplete
:
false
autocompleteOpts
:
{
}
cssProperties
:
null
disableSearchAddon
:
false
maxHighlightLength
:
1000
}
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
jumpToLine
"
)
]
=
(
)
=
>
this
.
jumpToLine
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
moveLineUp
"
{
noaccel
:
true
}
)
]
=
(
)
=
>
this
.
moveLineUp
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
moveLineDown
"
{
noaccel
:
true
}
)
]
=
(
)
=
>
this
.
moveLineDown
(
)
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
toggleComment
"
)
]
=
"
toggleComment
"
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
indentLess
"
)
]
=
false
;
this
.
config
.
extraKeys
[
Editor
.
keyFor
(
"
indentMore
"
)
]
=
false
;
this
.
config
.
extraKeys
[
"
Alt
-
B
"
]
=
false
;
this
.
config
.
extraKeys
[
"
Alt
-
F
"
]
=
false
;
Object
.
keys
(
config
)
.
forEach
(
k
=
>
{
if
(
k
!
=
"
extraKeys
"
)
{
this
.
config
[
k
]
=
config
[
k
]
;
return
;
}
if
(
!
config
.
extraKeys
)
{
return
;
}
Object
.
keys
(
config
.
extraKeys
)
.
forEach
(
key
=
>
{
this
.
config
.
extraKeys
[
key
]
=
config
.
extraKeys
[
key
]
;
}
)
;
}
)
;
if
(
!
this
.
config
.
gutters
)
{
this
.
config
.
gutters
=
[
]
;
}
if
(
this
.
config
.
lineNumbers
&
&
!
this
.
config
.
gutters
.
includes
(
"
CodeMirror
-
linenumbers
"
)
)
{
this
.
config
.
gutters
.
push
(
"
CodeMirror
-
linenumbers
"
)
;
}
this
.
config
.
autoCloseBracketsSaved
=
this
.
config
.
autoCloseBrackets
;
this
.
config
.
extraKeys
.
Tab
=
cm
=
>
{
if
(
config
.
extraKeys
&
&
config
.
extraKeys
.
Tab
)
{
const
res
=
config
.
extraKeys
.
Tab
(
cm
)
;
if
(
res
=
=
=
false
)
{
return
;
}
}
if
(
cm
.
somethingSelected
(
)
)
{
cm
.
indentSelection
(
"
add
"
)
;
return
;
}
if
(
this
.
config
.
indentWithTabs
)
{
cm
.
replaceSelection
(
"
\
t
"
"
end
"
"
+
input
"
)
;
return
;
}
let
num
=
cm
.
getOption
(
"
indentUnit
"
)
;
if
(
cm
.
getCursor
(
)
.
ch
!
=
=
0
)
{
num
-
=
cm
.
getCursor
(
)
.
ch
%
num
;
}
cm
.
replaceSelection
(
"
"
.
repeat
(
num
)
"
end
"
"
+
input
"
)
;
}
;
if
(
this
.
config
.
cssProperties
)
{
this
.
config
.
autocompleteOpts
.
cssProperties
=
this
.
config
.
cssProperties
;
}
if
(
Services
.
prefs
.
prefHasUserValue
(
CARET_BLINK_TIME
)
)
{
this
.
config
.
cursorBlinkRate
=
Services
.
prefs
.
getIntPref
(
CARET_BLINK_TIME
530
)
;
}
EventEmitter
.
decorate
(
this
)
;
}
Editor
.
prototype
=
{
container
:
null
version
:
null
config
:
null
Doc
:
null
get
CodeMirror
(
)
{
const
codeMirror
=
editors
.
get
(
this
)
;
return
codeMirror
&
&
codeMirror
.
constructor
;
}
get
codeMirror
(
)
{
if
(
!
editors
.
has
(
this
)
)
{
throw
new
Error
(
"
CodeMirror
instance
does
not
exist
.
You
must
wait
"
+
"
for
it
to
be
appended
to
the
DOM
.
"
)
;
}
return
editors
.
get
(
this
)
;
}
get
hasCodeMirror
(
)
{
return
editors
.
has
(
this
)
;
}
appendTo
:
function
(
el
env
)
{
return
new
Promise
(
resolve
=
>
{
const
cm
=
editors
.
get
(
this
)
;
if
(
!
env
)
{
env
=
el
.
ownerDocument
.
createElementNS
(
el
.
namespaceURI
"
iframe
"
)
;
if
(
el
.
namespaceURI
=
=
=
XUL_NS
)
{
env
.
flex
=
1
;
}
}
if
(
cm
)
{
throw
new
Error
(
"
You
can
append
an
editor
only
once
.
"
)
;
}
const
onLoad
=
(
)
=
>
{
const
win
=
env
.
contentWindow
.
wrappedJSObject
;
if
(
!
this
.
config
.
themeSwitching
)
{
win
.
document
.
documentElement
.
setAttribute
(
"
force
-
theme
"
"
light
"
)
;
}
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
devtools
/
content
/
shared
/
theme
-
switching
.
js
"
win
)
;
this
.
container
=
env
;
this
.
_setup
(
win
.
document
.
body
el
.
ownerDocument
)
;
env
.
removeEventListener
(
"
load
"
onLoad
true
)
;
resolve
(
)
;
}
;
env
.
addEventListener
(
"
load
"
onLoad
true
)
;
env
.
setAttribute
(
"
src
"
CM_IFRAME
)
;
el
.
appendChild
(
env
)
;
this
.
once
(
"
destroy
"
(
)
=
>
el
.
removeChild
(
env
)
)
;
}
)
;
}
appendToLocalElement
:
function
(
el
)
{
this
.
_setup
(
el
)
;
}
_setup
:
function
(
el
doc
)
{
doc
=
doc
|
|
el
.
ownerDocument
;
const
win
=
el
.
ownerDocument
.
defaultView
;
Services
.
scriptloader
.
loadSubScript
(
CM_BUNDLE
win
)
;
if
(
this
.
config
.
cssProperties
)
{
const
{
propertyKeywords
colorKeywords
valueKeywords
}
=
getCSSKeywords
(
this
.
config
.
cssProperties
)
;
const
cssSpec
=
win
.
CodeMirror
.
resolveMode
(
"
text
/
css
"
)
;
cssSpec
.
propertyKeywords
=
propertyKeywords
;
cssSpec
.
colorKeywords
=
colorKeywords
;
cssSpec
.
valueKeywords
=
valueKeywords
;
win
.
CodeMirror
.
defineMIME
(
"
text
/
css
"
cssSpec
)
;
const
scssSpec
=
win
.
CodeMirror
.
resolveMode
(
"
text
/
x
-
scss
"
)
;
scssSpec
.
propertyKeywords
=
propertyKeywords
;
scssSpec
.
colorKeywords
=
colorKeywords
;
scssSpec
.
valueKeywords
=
valueKeywords
;
win
.
CodeMirror
.
defineMIME
(
"
text
/
x
-
scss
"
scssSpec
)
;
}
win
.
CodeMirror
.
commands
.
save
=
(
)
=
>
this
.
emit
(
"
saveRequested
"
)
;
const
cm
=
win
.
CodeMirror
(
el
this
.
config
)
;
this
.
Doc
=
win
.
CodeMirror
.
Doc
;
cm
.
getScrollerElement
(
)
.
addEventListener
(
"
wheel
"
ev
=
>
{
ev
.
preventDefault
(
)
;
let
{
deltaX
deltaY
}
=
ev
;
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_LINE
)
{
deltaX
*
=
cm
.
defaultCharWidth
(
)
;
deltaY
*
=
cm
.
defaultTextHeight
(
)
;
}
else
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_PAGE
)
{
deltaX
*
=
cm
.
getWrapperElement
(
)
.
clientWidth
;
deltaY
*
=
cm
.
getWrapperElement
(
)
.
clientHeight
;
}
cm
.
getScrollerElement
(
)
.
scrollBy
(
deltaX
deltaY
)
;
}
)
;
cm
.
getWrapperElement
(
)
.
addEventListener
(
"
contextmenu
"
ev
=
>
{
if
(
!
this
.
config
.
contextMenu
)
{
return
;
}
ev
.
stopPropagation
(
)
;
ev
.
preventDefault
(
)
;
let
popup
=
this
.
config
.
contextMenu
;
if
(
typeof
popup
=
=
"
string
"
)
{
popup
=
doc
.
getElementById
(
this
.
config
.
contextMenu
)
;
}
this
.
emit
(
"
popupOpen
"
ev
popup
)
;
popup
.
openPopupAtScreen
(
ev
.
screenX
ev
.
screenY
true
)
;
}
)
;
const
pipedEvents
=
[
"
beforeChange
"
"
changes
"
"
cursorActivity
"
"
focus
"
"
scroll
"
]
;
for
(
const
eventName
of
pipedEvents
)
{
cm
.
on
(
eventName
(
.
.
.
args
)
=
>
this
.
emit
(
eventName
.
.
.
args
)
)
;
}
cm
.
on
(
"
change
"
(
)
=
>
{
this
.
emit
(
"
change
"
)
;
if
(
!
this
.
_lastDirty
)
{
this
.
_lastDirty
=
true
;
this
.
emit
(
"
dirty
-
change
"
)
;
}
}
)
;
cm
.
on
(
"
gutterClick
"
(
cmArg
line
gutter
ev
)
=
>
{
const
lineOrOffset
=
!
this
.
isWasm
?
line
:
this
.
lineToWasmOffset
(
line
)
;
this
.
emit
(
"
gutterClick
"
lineOrOffset
ev
.
button
)
;
}
)
;
win
.
CodeMirror
.
defineExtension
(
"
l10n
"
name
=
>
{
return
L10N
.
getStr
(
name
)
;
}
)
;
if
(
!
this
.
config
.
disableSearchAddon
)
{
this
.
_initSearchShortcuts
(
win
)
;
}
else
{
Object
.
assign
(
win
.
CodeMirror
.
commands
{
find
:
null
findPersistent
:
null
findPersistentNext
:
null
findPersistentPrev
:
null
findNext
:
null
findPrev
:
null
clearSearch
:
null
replace
:
null
replaceAll
:
null
}
)
;
}
editors
.
set
(
this
cm
)
;
this
.
reloadPreferences
=
this
.
reloadPreferences
.
bind
(
this
)
;
this
.
setKeyMap
=
this
.
setKeyMap
.
bind
(
this
win
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
editor
.
"
)
;
this
.
_prefObserver
.
on
(
TAB_SIZE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
EXPAND_TAB
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
AUTO_CLOSE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
AUTOCOMPLETE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
DETECT_INDENT
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
on
(
ENABLE_CODE_FOLDING
this
.
reloadPreferences
)
;
this
.
reloadPreferences
(
)
;
this
.
_loadedKeyMaps
=
new
Set
(
)
;
this
.
_prefObserver
.
on
(
KEYMAP_PREF
this
.
setKeyMap
)
;
this
.
setKeyMap
(
)
;
win
.
editor
=
this
;
const
editorReadyEvent
=
new
win
.
CustomEvent
(
"
editorReady
"
)
;
win
.
dispatchEvent
(
editorReadyEvent
)
;
}
isAppended
:
function
(
)
{
return
editors
.
has
(
this
)
;
}
getMode
:
function
(
)
{
return
this
.
getOption
(
"
mode
"
)
;
}
loadScript
:
function
(
url
)
{
if
(
!
this
.
container
)
{
throw
new
Error
(
"
Can
'
t
load
a
script
until
the
editor
is
loaded
.
"
)
;
}
const
win
=
this
.
container
.
contentWindow
.
wrappedJSObject
;
Services
.
scriptloader
.
loadSubScript
(
url
win
)
;
}
createDocument
:
function
(
)
{
return
new
this
.
Doc
(
"
"
)
;
}
replaceDocument
:
function
(
doc
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
swapDoc
(
doc
)
;
}
setMode
:
function
(
value
)
{
this
.
setOption
(
"
mode
"
value
)
;
if
(
this
.
config
.
autocomplete
)
{
this
.
setOption
(
"
autocomplete
"
false
)
;
this
.
setOption
(
"
autocomplete
"
true
)
;
}
}
insertCommandsController
:
function
(
)
{
const
{
insertCommandsController
}
=
require
(
"
devtools
/
client
/
shared
/
sourceeditor
/
editor
-
commands
-
controller
"
)
;
insertCommandsController
(
this
)
;
}
getText
:
function
(
line
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
line
=
=
null
)
{
return
cm
.
getValue
(
)
;
}
const
info
=
this
.
lineInfo
(
line
)
;
return
info
?
info
.
text
:
"
"
;
}
getDoc
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
getDoc
(
)
;
}
get
isWasm
(
)
{
return
wasm
.
isWasm
(
this
.
getDoc
(
)
)
;
}
wasmOffsetToLine
:
function
(
offset
)
{
return
wasm
.
wasmOffsetToLine
(
this
.
getDoc
(
)
offset
)
;
}
lineToWasmOffset
:
function
(
number
)
{
return
wasm
.
lineToWasmOffset
(
this
.
getDoc
(
)
number
)
;
}
toLineIfWasmOffset
:
function
(
maybeOffset
)
{
if
(
typeof
maybeOffset
!
=
=
"
number
"
|
|
!
this
.
isWasm
)
{
return
maybeOffset
;
}
return
this
.
wasmOffsetToLine
(
maybeOffset
)
;
}
lineInfo
:
function
(
lineOrOffset
)
{
const
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
if
(
line
=
=
undefined
)
{
return
null
;
}
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
lineInfo
(
line
)
;
}
getLineOrOffset
:
function
(
line
)
{
return
this
.
isWasm
?
this
.
lineToWasmOffset
(
line
)
:
line
;
}
setText
:
function
(
value
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
typeof
value
!
=
=
"
string
"
&
&
"
binary
"
in
value
)
{
const
binary
=
value
.
binary
;
const
data
=
new
Uint8Array
(
binary
.
length
)
;
for
(
let
i
=
0
;
i
<
data
.
length
;
i
+
+
)
{
data
[
i
]
=
binary
.
charCodeAt
(
i
)
;
}
const
{
lines
done
}
=
wasm
.
getWasmText
(
this
.
getDoc
(
)
data
)
;
const
MAX_LINES
=
10000000
;
if
(
lines
.
length
>
MAX_LINES
)
{
lines
.
splice
(
MAX_LINES
lines
.
length
-
MAX_LINES
)
;
lines
.
push
(
"
;
;
.
.
.
.
text
is
truncated
due
to
the
size
"
)
;
}
if
(
!
done
)
{
lines
.
push
(
"
;
;
.
.
.
.
possible
error
during
wast
conversion
"
)
;
}
value
=
{
split
:
(
)
=
>
lines
}
;
}
cm
.
setValue
(
value
)
;
this
.
resetIndentUnit
(
)
;
}
reloadPreferences
:
function
(
)
{
const
useAutoClose
=
Services
.
prefs
.
getBoolPref
(
AUTO_CLOSE
)
;
this
.
setOption
(
"
autoCloseBrackets
"
useAutoClose
?
this
.
config
.
autoCloseBracketsSaved
:
false
)
;
this
.
updateCodeFoldingGutter
(
)
;
this
.
resetIndentUnit
(
)
;
this
.
setupAutoCompletion
(
)
;
}
setKeyMap
(
win
)
{
if
(
this
.
config
.
isReadOnly
)
{
return
;
}
const
keyMap
=
Services
.
prefs
.
getCharPref
(
KEYMAP_PREF
)
;
if
(
VALID_KEYMAPS
.
has
(
keyMap
)
)
{
if
(
!
this
.
_loadedKeyMaps
.
has
(
keyMap
)
)
{
Services
.
scriptloader
.
loadSubScript
(
VALID_KEYMAPS
.
get
(
keyMap
)
win
)
;
this
.
_loadedKeyMaps
.
add
(
keyMap
)
;
}
this
.
setOption
(
"
keyMap
"
keyMap
)
;
}
else
{
this
.
setOption
(
"
keyMap
"
"
default
"
)
;
}
}
resetIndentUnit
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
iterFn
=
function
(
start
end
callback
)
{
cm
.
eachLine
(
start
end
line
=
>
{
return
callback
(
line
.
text
)
;
}
)
;
}
;
const
{
indentUnit
indentWithTabs
}
=
getIndentationFromIteration
(
iterFn
)
;
cm
.
setOption
(
"
tabSize
"
indentUnit
)
;
cm
.
setOption
(
"
indentUnit
"
indentUnit
)
;
cm
.
setOption
(
"
indentWithTabs
"
indentWithTabs
)
;
}
replaceText
:
function
(
value
from
to
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
!
from
)
{
this
.
setText
(
value
)
;
return
;
}
if
(
!
to
)
{
const
text
=
cm
.
getRange
(
{
line
:
0
ch
:
0
}
from
)
;
this
.
setText
(
text
+
value
)
;
return
;
}
cm
.
replaceRange
(
value
from
to
)
;
}
insertText
:
function
(
value
at
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
replaceRange
(
value
at
at
)
;
}
dropSelection
:
function
(
)
{
if
(
!
this
.
somethingSelected
(
)
)
{
return
;
}
this
.
setCursor
(
this
.
getCursor
(
)
)
;
}
hasMultipleSelections
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
listSelections
(
)
.
length
>
1
;
}
getFirstVisibleLine
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
lineAtHeight
(
0
"
local
"
)
;
}
setFirstVisibleLine
:
function
(
line
)
{
const
cm
=
editors
.
get
(
this
)
;
const
{
top
}
=
cm
.
charCoords
(
{
line
:
line
ch
:
0
}
"
local
"
)
;
cm
.
scrollTo
(
0
top
)
;
}
setCursor
:
function
(
{
line
ch
}
align
)
{
const
cm
=
editors
.
get
(
this
)
;
this
.
alignLine
(
line
align
)
;
cm
.
setCursor
(
{
line
:
line
ch
:
ch
}
)
;
this
.
emit
(
"
cursorActivity
"
)
;
}
alignLine
:
function
(
line
align
)
{
const
cm
=
editors
.
get
(
this
)
;
const
from
=
cm
.
lineAtHeight
(
0
"
page
"
)
;
const
to
=
cm
.
lineAtHeight
(
cm
.
getWrapperElement
(
)
.
clientHeight
"
page
"
)
;
const
linesVisible
=
to
-
from
;
const
halfVisible
=
Math
.
round
(
linesVisible
/
2
)
;
if
(
line
<
=
to
&
&
line
>
=
from
)
{
return
;
}
const
offset
=
Math
.
min
(
halfVisible
MAX_VERTICAL_OFFSET
)
;
let
topLine
=
{
center
:
Math
.
max
(
line
-
halfVisible
0
)
bottom
:
Math
.
max
(
line
-
linesVisible
+
offset
0
)
top
:
Math
.
max
(
line
-
offset
0
)
}
[
align
|
|
"
top
"
]
|
|
offset
;
topLine
=
Math
.
min
(
topLine
this
.
lineCount
(
)
)
;
this
.
setFirstVisibleLine
(
topLine
)
;
}
hasMarker
:
function
(
line
gutterName
markerClass
)
{
const
marker
=
this
.
getMarker
(
line
gutterName
)
;
if
(
!
marker
)
{
return
false
;
}
return
marker
.
classList
.
contains
(
markerClass
)
;
}
addMarker
:
function
(
line
gutterName
markerClass
)
{
const
cm
=
editors
.
get
(
this
)
;
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
const
gutterMarkers
=
info
.
gutterMarkers
;
let
marker
;
if
(
gutterMarkers
)
{
marker
=
gutterMarkers
[
gutterName
]
;
if
(
marker
)
{
marker
.
classList
.
add
(
markerClass
)
;
return
;
}
}
marker
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
div
"
)
;
marker
.
className
=
markerClass
;
cm
.
setGutterMarker
(
info
.
line
gutterName
marker
)
;
}
removeMarker
:
function
(
line
gutterName
markerClass
)
{
if
(
!
this
.
hasMarker
(
line
gutterName
markerClass
)
)
{
return
;
}
this
.
lineInfo
(
line
)
.
gutterMarkers
[
gutterName
]
.
classList
.
remove
(
markerClass
)
;
}
addContentMarker
:
function
(
line
gutterName
markerClass
content
)
{
const
cm
=
editors
.
get
(
this
)
;
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
const
marker
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
div
"
)
;
marker
.
className
=
markerClass
;
marker
.
innerHTML
=
content
;
cm
.
setGutterMarker
(
info
.
line
gutterName
marker
)
;
}
removeContentMarker
:
function
(
line
gutterName
)
{
const
cm
=
editors
.
get
(
this
)
;
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
;
}
cm
.
setGutterMarker
(
info
.
line
gutterName
null
)
;
}
getMarker
:
function
(
line
gutterName
)
{
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
)
{
return
null
;
}
const
gutterMarkers
=
info
.
gutterMarkers
;
if
(
!
gutterMarkers
)
{
return
null
;
}
return
gutterMarkers
[
gutterName
]
;
}
removeAllMarkers
:
function
(
gutterName
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
clearGutter
(
gutterName
)
;
}
setMarkerListeners
:
function
(
line
gutterName
markerClass
eventsArg
data
)
{
if
(
!
this
.
hasMarker
(
line
gutterName
markerClass
)
)
{
return
;
}
const
cm
=
editors
.
get
(
this
)
;
const
marker
=
cm
.
lineInfo
(
line
)
.
gutterMarkers
[
gutterName
]
;
for
(
const
name
in
eventsArg
)
{
const
listener
=
eventsArg
[
name
]
.
bind
(
this
line
marker
data
)
;
marker
.
addEventListener
(
name
listener
)
;
}
}
hasLineClass
:
function
(
line
className
)
{
const
info
=
this
.
lineInfo
(
line
)
;
if
(
!
info
|
|
!
info
.
wrapClass
)
{
return
false
;
}
return
info
.
wrapClass
.
split
(
"
"
)
.
includes
(
className
)
;
}
addLineClass
:
function
(
lineOrOffset
className
)
{
const
cm
=
editors
.
get
(
this
)
;
const
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
cm
.
addLineClass
(
line
"
wrap
"
className
)
;
}
removeLineClass
:
function
(
lineOrOffset
className
)
{
const
cm
=
editors
.
get
(
this
)
;
const
line
=
this
.
toLineIfWasmOffset
(
lineOrOffset
)
;
cm
.
removeLineClass
(
line
"
wrap
"
className
)
;
}
markText
:
function
(
from
to
className
=
"
marked
-
text
"
)
{
const
cm
=
editors
.
get
(
this
)
;
const
text
=
cm
.
getRange
(
from
to
)
;
const
span
=
cm
.
getWrapperElement
(
)
.
ownerDocument
.
createElement
(
"
span
"
)
;
span
.
className
=
className
;
span
.
textContent
=
text
;
const
mark
=
cm
.
markText
(
from
to
{
replacedWith
:
span
}
)
;
return
{
anchor
:
span
clear
:
(
)
=
>
mark
.
clear
(
)
}
;
}
getPosition
:
function
(
.
.
.
args
)
{
const
cm
=
editors
.
get
(
this
)
;
const
res
=
args
.
map
(
ind
=
>
cm
.
posFromIndex
(
ind
)
)
;
return
args
.
length
=
=
=
1
?
res
[
0
]
:
res
;
}
getOffset
:
function
(
.
.
.
args
)
{
const
cm
=
editors
.
get
(
this
)
;
const
res
=
args
.
map
(
pos
=
>
cm
.
indexFromPos
(
pos
)
)
;
return
args
.
length
>
1
?
res
:
res
[
0
]
;
}
getPositionFromCoords
:
function
(
{
left
top
}
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
coordsChar
(
{
left
:
left
top
:
top
}
)
;
}
getCoordsFromPosition
:
function
(
{
line
ch
}
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
charCoords
(
{
line
:
~
~
line
ch
:
~
~
ch
}
)
;
}
canUndo
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
historySize
(
)
.
undo
>
0
;
}
canRedo
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
historySize
(
)
.
redo
>
0
;
}
setClean
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
this
.
version
=
cm
.
changeGeneration
(
)
;
this
.
_lastDirty
=
false
;
this
.
emit
(
"
dirty
-
change
"
)
;
return
this
.
version
;
}
isClean
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
.
isClean
(
this
.
version
)
;
}
jumpToLine
:
function
(
)
{
const
doc
=
editors
.
get
(
this
)
.
getWrapperElement
(
)
.
ownerDocument
;
const
div
=
doc
.
createElement
(
"
div
"
)
;
const
inp
=
doc
.
createElement
(
"
input
"
)
;
const
txt
=
doc
.
createTextNode
(
L10N
.
getStr
(
"
gotoLineCmd
.
promptTitle
"
)
)
;
inp
.
type
=
"
text
"
;
inp
.
style
.
width
=
"
10em
"
;
inp
.
style
.
marginInlineStart
=
"
1em
"
;
div
.
appendChild
(
txt
)
;
div
.
appendChild
(
inp
)
;
this
.
openDialog
(
div
line
=
>
{
const
match
=
line
.
toString
(
)
.
match
(
RE_JUMP_TO_LINE
)
;
if
(
match
)
{
const
[
matchLine
column
]
=
match
;
this
.
setCursor
(
{
line
:
matchLine
-
1
ch
:
column
?
column
-
1
:
0
}
)
;
}
}
)
;
}
moveLineUp
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
start
=
cm
.
getCursor
(
"
start
"
)
;
const
end
=
cm
.
getCursor
(
"
end
"
)
;
if
(
start
.
line
=
=
=
0
)
{
return
;
}
let
value
;
if
(
start
.
line
!
=
=
end
.
line
)
{
value
=
cm
.
getRange
(
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
+
"
\
n
"
;
}
else
{
value
=
cm
.
getLine
(
start
.
line
)
+
"
\
n
"
;
}
value
+
=
cm
.
getLine
(
start
.
line
-
1
)
;
cm
.
replaceRange
(
value
{
line
:
start
.
line
-
1
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
;
cm
.
setSelection
(
{
line
:
start
.
line
-
1
ch
:
start
.
ch
}
{
line
:
end
.
line
-
1
ch
:
end
.
ch
}
)
;
}
moveLineDown
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
start
=
cm
.
getCursor
(
"
start
"
)
;
const
end
=
cm
.
getCursor
(
"
end
"
)
;
if
(
end
.
line
+
1
=
=
=
cm
.
lineCount
(
)
)
{
return
;
}
let
value
=
cm
.
getLine
(
end
.
line
+
1
)
+
"
\
n
"
;
if
(
start
.
line
!
=
=
end
.
line
)
{
value
+
=
cm
.
getRange
(
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
ch
:
cm
.
getLine
(
end
.
line
)
.
length
}
)
;
}
else
{
value
+
=
cm
.
getLine
(
start
.
line
)
;
}
cm
.
replaceRange
(
value
{
line
:
start
.
line
ch
:
0
}
{
line
:
end
.
line
+
1
ch
:
cm
.
getLine
(
end
.
line
+
1
)
.
length
}
)
;
cm
.
setSelection
(
{
line
:
start
.
line
+
1
ch
:
start
.
ch
}
{
line
:
end
.
line
+
1
ch
:
end
.
ch
}
)
;
}
findOrReplace
:
function
(
node
isReplaceAll
)
{
const
cm
=
editors
.
get
(
this
)
;
const
isInput
=
node
.
tagName
=
=
=
"
INPUT
"
;
const
isSearchInput
=
isInput
&
&
node
.
type
=
=
=
"
search
"
;
const
isDialogInput
=
isInput
&
&
node
.
parentNode
&
&
node
.
parentNode
.
classList
.
contains
(
"
CodeMirror
-
dialog
"
)
;
if
(
!
(
isSearchInput
|
|
isDialogInput
)
)
{
return
;
}
if
(
isSearchInput
|
|
isReplaceAll
)
{
node
.
select
(
)
;
}
cm
.
execCommand
(
"
find
"
)
;
}
findNextOrPrev
:
function
(
node
isFindPrev
)
{
const
cm
=
editors
.
get
(
this
)
;
const
isInput
=
node
.
tagName
=
=
=
"
INPUT
"
;
const
isSearchInput
=
isInput
&
&
node
.
type
=
=
=
"
search
"
;
if
(
!
isSearchInput
)
{
return
;
}
const
query
=
node
.
value
;
if
(
!
cm
.
state
.
search
|
|
cm
.
state
.
search
.
query
!
=
=
query
)
{
cm
.
state
.
search
=
{
posFrom
:
null
posTo
:
null
overlay
:
null
query
}
;
}
if
(
isFindPrev
)
{
cm
.
execCommand
(
"
findPrev
"
)
;
}
else
{
cm
.
execCommand
(
"
findNext
"
)
;
}
}
getFontSize
:
function
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
el
=
cm
.
getWrapperElement
(
)
;
const
win
=
el
.
ownerDocument
.
defaultView
;
return
parseInt
(
win
.
getComputedStyle
(
el
)
.
getPropertyValue
(
"
font
-
size
"
)
10
)
;
}
setFontSize
:
function
(
size
)
{
const
cm
=
editors
.
get
(
this
)
;
cm
.
getWrapperElement
(
)
.
style
.
fontSize
=
parseInt
(
size
10
)
+
"
px
"
;
cm
.
refresh
(
)
;
}
setOption
:
function
(
o
v
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
o
=
=
=
"
autoCloseBrackets
"
&
&
v
)
{
this
.
config
.
autoCloseBracketsSaved
=
v
;
}
if
(
o
=
=
=
"
autocomplete
"
)
{
this
.
config
.
autocomplete
=
v
;
this
.
setupAutoCompletion
(
)
;
}
else
{
cm
.
setOption
(
o
v
)
;
this
.
config
[
o
]
=
v
;
}
if
(
o
=
=
=
"
enableCodeFolding
"
)
{
this
.
updateCodeFoldingGutter
(
)
;
}
}
getOption
:
function
(
o
)
{
const
cm
=
editors
.
get
(
this
)
;
if
(
o
=
=
=
"
autocomplete
"
)
{
return
this
.
config
.
autocomplete
;
}
return
cm
.
getOption
(
o
)
;
}
setupAutoCompletion
:
function
(
)
{
if
(
!
this
.
config
.
autocomplete
&
&
!
this
.
initializeAutoCompletion
)
{
return
;
}
if
(
!
this
.
initializeAutoCompletion
)
{
this
.
extend
(
require
(
"
devtools
/
client
/
shared
/
sourceeditor
/
autocomplete
"
)
)
;
}
if
(
this
.
config
.
autocomplete
&
&
Services
.
prefs
.
getBoolPref
(
AUTOCOMPLETE
)
)
{
this
.
initializeAutoCompletion
(
this
.
config
.
autocompleteOpts
)
;
}
else
{
this
.
destroyAutoCompletion
(
)
;
}
}
getAutoCompletionText
(
)
{
const
cm
=
editors
.
get
(
this
)
;
const
mark
=
cm
.
getAllMarks
(
)
.
find
(
m
=
>
m
.
className
=
=
=
AUTOCOMPLETE_MARK_CLASSNAME
)
;
if
(
!
mark
)
{
return
"
"
;
}
return
mark
.
title
|
|
"
"
;
}
setAutoCompletionText
:
function
(
text
)
{
const
cursor
=
this
.
getCursor
(
)
;
const
cm
=
editors
.
get
(
this
)
;
const
className
=
AUTOCOMPLETE_MARK_CLASSNAME
;
cm
.
operation
(
(
)
=
>
{
cm
.
getAllMarks
(
)
.
forEach
(
mark
=
>
{
if
(
mark
.
className
=
=
=
className
)
{
mark
.
clear
(
)
;
}
}
)
;
if
(
text
)
{
cm
.
markText
(
{
.
.
.
cursor
ch
:
cursor
.
ch
-
1
}
cursor
{
className
title
:
text
}
)
;
}
}
)
;
}
extend
:
function
(
funcs
)
{
Object
.
keys
(
funcs
)
.
forEach
(
name
=
>
{
const
cm
=
editors
.
get
(
this
)
;
const
ctx
=
{
ed
:
this
cm
:
cm
Editor
:
Editor
}
;
if
(
name
=
=
=
"
initialize
"
)
{
funcs
[
name
]
(
ctx
)
;
return
;
}
this
[
name
]
=
funcs
[
name
]
.
bind
(
null
ctx
)
;
}
)
;
}
isDestroyed
:
function
(
)
{
return
!
editors
.
get
(
this
)
;
}
destroy
:
function
(
)
{
this
.
container
=
null
;
this
.
config
=
null
;
this
.
version
=
null
;
if
(
this
.
_prefObserver
)
{
this
.
_prefObserver
.
off
(
KEYMAP_PREF
this
.
setKeyMap
)
;
this
.
_prefObserver
.
off
(
TAB_SIZE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
EXPAND_TAB
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
AUTO_CLOSE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
AUTOCOMPLETE
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
DETECT_INDENT
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
off
(
ENABLE_CODE_FOLDING
this
.
reloadPreferences
)
;
this
.
_prefObserver
.
destroy
(
)
;
}
const
cm
=
editors
.
get
(
this
)
;
if
(
cm
&
&
cm
.
doc
)
{
cm
.
doc
.
cm
=
null
;
}
this
.
emit
(
"
destroy
"
)
;
}
updateCodeFoldingGutter
:
function
(
)
{
let
shouldFoldGutter
=
this
.
config
.
enableCodeFolding
;
const
foldGutterIndex
=
this
.
config
.
gutters
.
indexOf
(
"
CodeMirror
-
foldgutter
"
)
;
const
cm
=
editors
.
get
(
this
)
;
if
(
shouldFoldGutter
=
=
=
undefined
)
{
shouldFoldGutter
=
Services
.
prefs
.
getBoolPref
(
ENABLE_CODE_FOLDING
)
;
}
if
(
shouldFoldGutter
)
{
if
(
foldGutterIndex
=
=
=
-
1
)
{
const
gutters
=
this
.
config
.
gutters
.
slice
(
)
;
gutters
.
push
(
"
CodeMirror
-
foldgutter
"
)
;
this
.
setOption
(
"
gutters
"
gutters
)
;
}
this
.
setOption
(
"
foldGutter
"
true
)
;
}
else
{
if
(
cm
)
{
cm
.
execCommand
(
"
unfoldAll
"
)
;
}
if
(
foldGutterIndex
!
=
=
-
1
)
{
const
gutters
=
this
.
config
.
gutters
.
slice
(
)
;
gutters
.
splice
(
foldGutterIndex
1
)
;
this
.
setOption
(
"
gutters
"
gutters
)
;
}
this
.
setOption
(
"
foldGutter
"
false
)
;
}
}
_initSearchShortcuts
:
function
(
win
)
{
const
shortcuts
=
new
KeyShortcuts
(
{
window
:
win
}
)
;
this
.
_onSearchShortcut
=
this
.
_onSearchShortcut
.
bind
(
this
)
;
const
keys
=
[
"
find
.
key
"
"
findNext
.
key
"
"
findPrev
.
key
"
]
;
if
(
OS
=
=
=
"
Darwin
"
)
{
keys
.
push
(
"
replaceAllMac
.
key
"
)
;
}
else
{
keys
.
push
(
"
replaceAll
.
key
"
)
;
}
keys
.
forEach
(
name
=
>
{
const
key
=
L10N
.
getStr
(
name
)
;
shortcuts
.
on
(
key
event
=
>
this
.
_onSearchShortcut
(
name
event
)
)
;
}
)
;
}
_onSearchShortcut
:
function
(
name
event
)
{
if
(
!
this
.
_isInputOrTextarea
(
event
.
target
)
)
{
return
;
}
const
node
=
event
.
originalTarget
;
switch
(
name
)
{
case
"
replaceAllMac
.
key
"
:
this
.
findOrReplace
(
node
true
)
;
break
;
case
"
replaceAll
.
key
"
:
this
.
findOrReplace
(
node
true
)
;
break
;
case
"
find
.
key
"
:
this
.
findOrReplace
(
node
false
)
;
break
;
case
"
findPrev
.
key
"
:
this
.
findNextOrPrev
(
node
true
)
;
break
;
case
"
findNext
.
key
"
:
this
.
findNextOrPrev
(
node
false
)
;
break
;
default
:
console
.
error
(
"
Unexpected
editor
key
shortcut
"
name
)
;
return
;
}
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
_isInputOrTextarea
:
function
(
element
)
{
const
name
=
element
.
tagName
.
toLowerCase
(
)
;
return
name
=
=
=
"
input
"
|
|
name
=
=
=
"
textarea
"
;
}
}
;
CM_MAPPING
.
forEach
(
name
=
>
{
Editor
.
prototype
[
name
]
=
function
(
.
.
.
args
)
{
const
cm
=
editors
.
get
(
this
)
;
return
cm
[
name
]
.
apply
(
cm
args
)
;
}
;
}
)
;
Editor
.
accel
=
function
(
key
modifiers
=
{
}
)
{
return
(
(
modifiers
.
shift
?
"
Shift
-
"
:
"
"
)
+
(
Services
.
appinfo
.
OS
=
=
"
Darwin
"
?
"
Cmd
-
"
:
"
Ctrl
-
"
)
+
(
modifiers
.
alt
?
"
Alt
-
"
:
"
"
)
+
key
)
;
}
;
Editor
.
keyFor
=
function
(
cmd
opts
=
{
noaccel
:
false
}
)
{
const
key
=
L10N
.
getStr
(
cmd
+
"
.
commandkey
"
)
;
return
opts
.
noaccel
?
key
:
Editor
.
accel
(
key
)
;
}
;
function
getCSSKeywords
(
cssProperties
)
{
function
keySet
(
array
)
{
const
keys
=
{
}
;
for
(
let
i
=
0
;
i
<
array
.
length
;
+
+
i
)
{
keys
[
array
[
i
]
]
=
true
;
}
return
keys
;
}
const
propertyKeywords
=
cssProperties
.
getNames
(
)
;
const
colorKeywords
=
{
}
;
const
valueKeywords
=
{
}
;
propertyKeywords
.
forEach
(
property
=
>
{
if
(
property
.
includes
(
"
color
"
)
)
{
cssProperties
.
getValues
(
property
)
.
forEach
(
value
=
>
{
colorKeywords
[
value
]
=
true
;
}
)
;
}
else
{
cssProperties
.
getValues
(
property
)
.
forEach
(
value
=
>
{
valueKeywords
[
value
]
=
true
;
}
)
;
}
}
)
;
return
{
propertyKeywords
:
keySet
(
propertyKeywords
)
colorKeywords
:
colorKeywords
valueKeywords
:
valueKeywords
}
;
}
module
.
exports
=
Editor
;
