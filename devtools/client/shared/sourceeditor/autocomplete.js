"
use
strict
"
;
const
AutocompletePopup
=
require
(
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyCodes
"
"
devtools
/
client
/
shared
/
keycodes
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CSSCompleter
"
"
devtools
/
client
/
shared
/
sourceeditor
/
css
-
autocompleter
"
)
;
const
autocompleteMap
=
new
WeakMap
(
)
;
function
initializeAutoCompletion
(
ctx
options
=
{
}
)
{
const
{
cm
ed
Editor
}
=
ctx
;
if
(
autocompleteMap
.
has
(
ed
)
)
{
return
;
}
const
win
=
ed
.
container
.
contentWindow
.
wrappedJSObject
;
const
{
CodeMirror
}
=
win
;
let
completer
=
null
;
const
autocompleteKey
=
"
Ctrl
-
"
+
Editor
.
keyFor
(
"
autocompletion
"
{
noaccel
:
true
}
)
;
if
(
ed
.
config
.
mode
=
=
Editor
.
modes
.
css
)
{
completer
=
new
CSSCompleter
(
{
walker
:
options
.
walker
cssProperties
:
options
.
cssProperties
}
)
;
}
function
insertSelectedPopupItem
(
)
{
const
autocompleteState
=
autocompleteMap
.
get
(
ed
)
;
if
(
!
popup
|
|
!
popup
.
isOpen
|
|
!
autocompleteState
)
{
return
false
;
}
if
(
!
autocompleteState
.
suggestionInsertedOnce
&
&
popup
.
selectedItem
)
{
autocompleteMap
.
get
(
ed
)
.
insertingSuggestion
=
true
;
insertPopupItem
(
ed
popup
.
selectedItem
)
;
}
popup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
ed
.
emit
(
"
popup
-
hidden
"
)
;
}
)
;
popup
.
hidePopup
(
)
;
return
true
;
}
let
popup
=
new
AutocompletePopup
(
win
.
parent
.
document
{
position
:
"
bottom
"
autoSelect
:
true
onClick
:
insertSelectedPopupItem
}
)
;
const
cycle
=
reverse
=
>
{
if
(
popup
?
.
isOpen
)
{
cycleSuggestions
(
ed
reverse
=
=
true
)
;
return
null
;
}
return
CodeMirror
.
Pass
;
}
;
let
keyMap
=
{
Tab
:
cycle
Down
:
cycle
"
Shift
-
Tab
"
:
cycle
.
bind
(
null
true
)
Up
:
cycle
.
bind
(
null
true
)
Enter
:
(
)
=
>
{
const
wasHandled
=
insertSelectedPopupItem
(
)
;
return
wasHandled
?
true
:
CodeMirror
.
Pass
;
}
}
;
const
autoCompleteCallback
=
autoComplete
.
bind
(
null
ctx
)
;
const
keypressCallback
=
onEditorKeypress
.
bind
(
null
ctx
)
;
keyMap
[
autocompleteKey
]
=
autoCompleteCallback
;
cm
.
addKeyMap
(
keyMap
)
;
cm
.
on
(
"
keydown
"
keypressCallback
)
;
ed
.
on
(
"
change
"
autoCompleteCallback
)
;
ed
.
on
(
"
destroy
"
destroy
)
;
function
destroy
(
)
{
ed
.
off
(
"
destroy
"
destroy
)
;
cm
.
off
(
"
keydown
"
keypressCallback
)
;
ed
.
off
(
"
change
"
autoCompleteCallback
)
;
cm
.
removeKeyMap
(
keyMap
)
;
popup
.
destroy
(
)
;
keyMap
=
popup
=
completer
=
null
;
autocompleteMap
.
delete
(
ed
)
;
}
autocompleteMap
.
set
(
ed
{
popup
completer
keyMap
destroy
insertingSuggestion
:
false
suggestionInsertedOnce
:
false
}
)
;
}
function
destroyAutoCompletion
(
ctx
)
{
const
{
ed
}
=
ctx
;
if
(
!
autocompleteMap
.
has
(
ed
)
)
{
return
;
}
const
{
destroy
}
=
autocompleteMap
.
get
(
ed
)
;
destroy
(
)
;
}
function
autoComplete
(
{
ed
cm
}
)
{
const
autocompleteOpts
=
autocompleteMap
.
get
(
ed
)
;
const
{
completer
popup
}
=
autocompleteOpts
;
if
(
!
completer
|
|
autocompleteOpts
.
insertingSuggestion
|
|
autocompleteOpts
.
doNotAutocomplete
)
{
autocompleteOpts
.
insertingSuggestion
=
false
;
return
;
}
const
cur
=
ed
.
getCursor
(
)
;
completer
.
complete
(
cm
.
getRange
(
{
line
:
0
ch
:
0
}
cur
)
cur
)
.
then
(
suggestions
=
>
{
if
(
!
suggestions
|
|
!
suggestions
.
length
|
|
suggestions
[
0
]
.
preLabel
=
=
null
)
{
autocompleteOpts
.
suggestionInsertedOnce
=
false
;
popup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
ed
.
emit
(
"
after
-
suggest
"
)
;
}
)
;
popup
.
hidePopup
(
)
;
return
;
}
const
cursorElement
=
cm
.
display
.
cursorDiv
.
querySelector
(
"
.
CodeMirror
-
cursor
"
)
;
const
left
=
suggestions
[
0
]
.
preLabel
.
length
*
cm
.
defaultCharWidth
(
)
;
popup
.
hidePopup
(
)
;
popup
.
setItems
(
suggestions
)
;
popup
.
once
(
"
popup
-
opened
"
(
)
=
>
{
ed
.
emit
(
"
after
-
suggest
"
)
;
}
)
;
popup
.
openPopup
(
cursorElement
-
1
*
left
0
)
;
autocompleteOpts
.
suggestionInsertedOnce
=
false
;
}
)
.
catch
(
console
.
error
)
;
}
function
insertPopupItem
(
ed
popupItem
)
{
const
{
preLabel
text
}
=
popupItem
;
const
cur
=
ed
.
getCursor
(
)
;
const
textBeforeCursor
=
ed
.
getText
(
cur
.
line
)
.
substring
(
0
cur
.
ch
)
;
const
backwardsTextBeforeCursor
=
textBeforeCursor
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
;
const
backwardsPreLabel
=
preLabel
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
;
if
(
backwardsPreLabel
.
indexOf
(
backwardsTextBeforeCursor
)
=
=
=
0
)
{
ed
.
replaceText
(
text
{
line
:
cur
.
line
ch
:
0
}
cur
)
;
}
else
{
ed
.
replaceText
(
text
.
slice
(
preLabel
.
length
)
cur
cur
)
;
}
}
function
cycleSuggestions
(
ed
reverse
)
{
const
autocompleteOpts
=
autocompleteMap
.
get
(
ed
)
;
const
{
popup
}
=
autocompleteOpts
;
const
cur
=
ed
.
getCursor
(
)
;
autocompleteOpts
.
insertingSuggestion
=
true
;
if
(
!
autocompleteOpts
.
suggestionInsertedOnce
)
{
autocompleteOpts
.
suggestionInsertedOnce
=
true
;
let
firstItem
;
if
(
reverse
)
{
firstItem
=
popup
.
getItemAtIndex
(
popup
.
itemCount
-
1
)
;
popup
.
selectPreviousItem
(
)
;
}
else
{
firstItem
=
popup
.
getItemAtIndex
(
0
)
;
if
(
firstItem
.
label
=
=
firstItem
.
preLabel
&
&
popup
.
itemCount
>
1
)
{
firstItem
=
popup
.
getItemAtIndex
(
1
)
;
popup
.
selectNextItem
(
)
;
}
}
if
(
popup
.
itemCount
=
=
1
)
{
popup
.
hidePopup
(
)
;
}
insertPopupItem
(
ed
firstItem
)
;
}
else
{
const
fromCur
=
{
line
:
cur
.
line
ch
:
cur
.
ch
-
popup
.
selectedItem
.
text
.
length
}
;
if
(
reverse
)
{
popup
.
selectPreviousItem
(
)
;
}
else
{
popup
.
selectNextItem
(
)
;
}
ed
.
replaceText
(
popup
.
selectedItem
.
text
fromCur
cur
)
;
}
ed
.
emit
(
"
suggestion
-
entered
"
)
;
}
function
onEditorKeypress
(
{
ed
Editor
}
cm
event
)
{
const
autocompleteOpts
=
autocompleteMap
.
get
(
ed
)
;
if
(
ed
.
hasMultipleSelections
(
)
)
{
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
return
;
}
if
(
(
event
.
ctrlKey
|
|
event
.
metaKey
)
&
&
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_SPACE
)
{
autocompleteOpts
.
doNotAutocomplete
=
false
;
return
;
}
if
(
event
.
ctrlKey
|
|
event
.
metaKey
|
|
event
.
altKey
)
{
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
return
;
}
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_RETURN
:
autocompleteOpts
.
doNotAutocomplete
=
true
;
break
;
case
KeyCodes
.
DOM_VK_ESCAPE
:
if
(
autocompleteOpts
.
popup
.
isOpen
)
{
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_LEFT
:
case
KeyCodes
.
DOM_VK_RIGHT
:
case
KeyCodes
.
DOM_VK_HOME
:
case
KeyCodes
.
DOM_VK_END
:
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
break
;
case
KeyCodes
.
DOM_VK_BACK_SPACE
:
case
KeyCodes
.
DOM_VK_DELETE
:
if
(
ed
.
config
.
mode
=
=
Editor
.
modes
.
css
)
{
autocompleteOpts
.
completer
.
invalidateCache
(
ed
.
getCursor
(
)
.
line
)
;
}
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
break
;
default
:
autocompleteOpts
.
doNotAutocomplete
=
false
;
}
}
function
getPopup
(
{
ed
}
)
{
if
(
autocompleteMap
.
has
(
ed
)
)
{
return
autocompleteMap
.
get
(
ed
)
.
popup
;
}
return
null
;
}
function
getInfoAt
(
{
ed
}
caret
)
{
if
(
autocompleteMap
.
has
(
ed
)
)
{
const
completer
=
autocompleteMap
.
get
(
ed
)
.
completer
;
if
(
completer
?
.
getInfoAt
)
{
return
completer
.
getInfoAt
(
ed
.
getText
(
)
caret
)
;
}
}
return
null
;
}
function
isAutocompletionEnabled
(
{
ed
}
)
{
return
autocompleteMap
.
has
(
ed
)
;
}
module
.
exports
.
initializeAutoCompletion
=
initializeAutoCompletion
;
module
.
exports
.
destroyAutoCompletion
=
destroyAutoCompletion
;
module
.
exports
.
getAutocompletionPopup
=
getPopup
;
module
.
exports
.
getInfoAt
=
getInfoAt
;
module
.
exports
.
isAutocompletionEnabled
=
isAutocompletionEnabled
;
