"
use
strict
"
;
const
AutocompletePopup
=
require
(
"
devtools
/
client
/
shared
/
autocomplete
-
popup
"
)
;
loader
.
lazyRequireGetter
(
this
"
KeyCodes
"
"
devtools
/
client
/
shared
/
keycodes
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
CSSCompleter
"
"
devtools
/
client
/
shared
/
sourceeditor
/
css
-
autocompleter
"
)
;
const
CM_TERN_SCRIPTS
=
[
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
addon
/
tern
/
tern
.
js
"
"
chrome
:
/
/
devtools
/
content
/
shared
/
sourceeditor
/
codemirror
/
addon
/
hint
/
show
-
hint
.
js
"
]
;
const
autocompleteMap
=
new
WeakMap
(
)
;
function
initializeAutoCompletion
(
ctx
options
=
{
}
)
{
const
{
cm
ed
Editor
}
=
ctx
;
if
(
autocompleteMap
.
has
(
ed
)
)
{
return
;
}
const
win
=
ed
.
container
.
contentWindow
.
wrappedJSObject
;
const
{
CodeMirror
document
}
=
win
;
let
completer
=
null
;
const
autocompleteKey
=
"
Ctrl
-
"
+
Editor
.
keyFor
(
"
autocompletion
"
{
noaccel
:
true
}
)
;
if
(
ed
.
config
.
mode
=
=
Editor
.
modes
.
js
)
{
const
defs
=
[
require
(
"
.
/
tern
/
browser
"
)
require
(
"
.
/
tern
/
ecma5
"
)
]
;
CM_TERN_SCRIPTS
.
forEach
(
ed
.
loadScript
ed
)
;
win
.
tern
=
require
(
"
.
/
tern
/
tern
"
)
;
cm
.
tern
=
new
CodeMirror
.
TernServer
(
{
defs
:
defs
typeTip
:
function
(
data
)
{
const
tip
=
document
.
createElement
(
"
span
"
)
;
tip
.
className
=
"
CodeMirror
-
Tern
-
information
"
;
const
tipType
=
document
.
createElement
(
"
strong
"
)
;
const
tipText
=
document
.
createTextNode
(
data
.
type
|
|
cm
.
l10n
(
"
autocompletion
.
notFound
"
)
)
;
tipType
.
appendChild
(
tipText
)
;
tip
.
appendChild
(
tipType
)
;
if
(
data
.
doc
)
{
tip
.
appendChild
(
document
.
createTextNode
(
"
"
+
data
.
doc
)
)
;
}
if
(
data
.
url
)
{
tip
.
appendChild
(
document
.
createTextNode
(
"
"
)
)
;
const
docLink
=
document
.
createElement
(
"
a
"
)
;
docLink
.
textContent
=
"
[
"
+
cm
.
l10n
(
"
autocompletion
.
docsLink
"
)
+
"
]
"
;
docLink
.
href
=
data
.
url
;
docLink
.
className
=
"
theme
-
link
"
;
docLink
.
setAttribute
(
"
target
"
"
_blank
"
)
;
tip
.
appendChild
(
docLink
)
;
}
return
tip
;
}
}
)
;
const
keyMap
=
{
}
;
const
updateArgHintsCallback
=
cm
.
tern
.
updateArgHints
.
bind
(
cm
.
tern
cm
)
;
cm
.
on
(
"
cursorActivity
"
updateArgHintsCallback
)
;
keyMap
[
autocompleteKey
]
=
cmArg
=
>
{
cmArg
.
tern
.
getHint
(
cmArg
data
=
>
{
CodeMirror
.
on
(
data
"
shown
"
(
)
=
>
ed
.
emit
(
"
before
-
suggest
"
)
)
;
CodeMirror
.
on
(
data
"
close
"
(
)
=
>
ed
.
emit
(
"
after
-
suggest
"
)
)
;
CodeMirror
.
on
(
data
"
select
"
(
)
=
>
ed
.
emit
(
"
suggestion
-
entered
"
)
)
;
CodeMirror
.
showHint
(
cmArg
(
cmIgnore
cb
)
=
>
cb
(
data
)
{
async
:
true
}
)
;
}
)
;
}
;
keyMap
[
Editor
.
keyFor
(
"
showInformation2
"
{
noaccel
:
true
}
)
]
=
cmArg
=
>
{
cmArg
.
tern
.
showType
(
cmArg
null
(
)
=
>
{
ed
.
emit
(
"
show
-
information
"
)
;
}
)
;
}
;
cm
.
addKeyMap
(
keyMap
)
;
const
destroyTern
=
function
(
)
{
ed
.
off
(
"
destroy
"
destroyTern
)
;
cm
.
off
(
"
cursorActivity
"
updateArgHintsCallback
)
;
cm
.
removeKeyMap
(
keyMap
)
;
win
.
tern
=
cm
.
tern
=
null
;
autocompleteMap
.
delete
(
ed
)
;
}
;
ed
.
on
(
"
destroy
"
destroyTern
)
;
autocompleteMap
.
set
(
ed
{
destroy
:
destroyTern
}
)
;
return
;
}
else
if
(
ed
.
config
.
mode
=
=
Editor
.
modes
.
css
)
{
completer
=
new
CSSCompleter
(
{
walker
:
options
.
walker
cssProperties
:
options
.
cssProperties
}
)
;
}
function
insertSelectedPopupItem
(
)
{
const
autocompleteState
=
autocompleteMap
.
get
(
ed
)
;
if
(
!
popup
|
|
!
popup
.
isOpen
|
|
!
autocompleteState
)
{
return
false
;
}
if
(
!
autocompleteState
.
suggestionInsertedOnce
&
&
popup
.
selectedItem
)
{
autocompleteMap
.
get
(
ed
)
.
insertingSuggestion
=
true
;
insertPopupItem
(
ed
popup
.
selectedItem
)
;
}
popup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
ed
.
emit
(
"
popup
-
hidden
"
)
;
}
)
;
popup
.
hidePopup
(
)
;
return
true
;
}
let
popup
=
new
AutocompletePopup
(
win
.
parent
.
document
{
position
:
"
bottom
"
autoSelect
:
true
onClick
:
insertSelectedPopupItem
}
)
;
const
cycle
=
reverse
=
>
{
if
(
popup
&
&
popup
.
isOpen
)
{
cycleSuggestions
(
ed
reverse
=
=
true
)
;
return
null
;
}
return
CodeMirror
.
Pass
;
}
;
let
keyMap
=
{
"
Tab
"
:
cycle
"
Down
"
:
cycle
"
Shift
-
Tab
"
:
cycle
.
bind
(
null
true
)
"
Up
"
:
cycle
.
bind
(
null
true
)
"
Enter
"
:
(
)
=
>
{
const
wasHandled
=
insertSelectedPopupItem
(
)
;
return
wasHandled
?
true
:
CodeMirror
.
Pass
;
}
}
;
const
autoCompleteCallback
=
autoComplete
.
bind
(
null
ctx
)
;
const
keypressCallback
=
onEditorKeypress
.
bind
(
null
ctx
)
;
keyMap
[
autocompleteKey
]
=
autoCompleteCallback
;
cm
.
addKeyMap
(
keyMap
)
;
cm
.
on
(
"
keydown
"
keypressCallback
)
;
ed
.
on
(
"
change
"
autoCompleteCallback
)
;
ed
.
on
(
"
destroy
"
destroy
)
;
function
destroy
(
)
{
ed
.
off
(
"
destroy
"
destroy
)
;
cm
.
off
(
"
keydown
"
keypressCallback
)
;
ed
.
off
(
"
change
"
autoCompleteCallback
)
;
cm
.
removeKeyMap
(
keyMap
)
;
popup
.
destroy
(
)
;
keyMap
=
popup
=
completer
=
null
;
autocompleteMap
.
delete
(
ed
)
;
}
autocompleteMap
.
set
(
ed
{
popup
:
popup
completer
:
completer
keyMap
:
keyMap
destroy
:
destroy
insertingSuggestion
:
false
suggestionInsertedOnce
:
false
}
)
;
}
function
destroyAutoCompletion
(
ctx
)
{
const
{
ed
}
=
ctx
;
if
(
!
autocompleteMap
.
has
(
ed
)
)
{
return
;
}
const
{
destroy
}
=
autocompleteMap
.
get
(
ed
)
;
destroy
(
)
;
}
function
autoComplete
(
{
ed
cm
}
)
{
const
autocompleteOpts
=
autocompleteMap
.
get
(
ed
)
;
const
{
completer
popup
}
=
autocompleteOpts
;
if
(
!
completer
|
|
autocompleteOpts
.
insertingSuggestion
|
|
autocompleteOpts
.
doNotAutocomplete
)
{
autocompleteOpts
.
insertingSuggestion
=
false
;
return
;
}
const
cur
=
ed
.
getCursor
(
)
;
completer
.
complete
(
cm
.
getRange
(
{
line
:
0
ch
:
0
}
cur
)
cur
)
.
then
(
suggestions
=
>
{
if
(
!
suggestions
|
|
!
suggestions
.
length
|
|
suggestions
[
0
]
.
preLabel
=
=
null
)
{
autocompleteOpts
.
suggestionInsertedOnce
=
false
;
popup
.
once
(
"
popup
-
closed
"
(
)
=
>
{
ed
.
emit
(
"
after
-
suggest
"
)
;
}
)
;
popup
.
hidePopup
(
)
;
return
;
}
const
cursorElement
=
cm
.
display
.
cursorDiv
.
querySelector
(
"
.
CodeMirror
-
cursor
"
)
;
const
left
=
suggestions
[
0
]
.
preLabel
.
length
*
cm
.
defaultCharWidth
(
)
;
popup
.
hidePopup
(
)
;
popup
.
setItems
(
suggestions
)
;
popup
.
once
(
"
popup
-
opened
"
(
)
=
>
{
ed
.
emit
(
"
after
-
suggest
"
)
;
}
)
;
popup
.
openPopup
(
cursorElement
-
1
*
left
0
)
;
autocompleteOpts
.
suggestionInsertedOnce
=
false
;
}
)
.
catch
(
console
.
error
)
;
}
function
insertPopupItem
(
ed
popupItem
)
{
const
{
preLabel
text
}
=
popupItem
;
const
cur
=
ed
.
getCursor
(
)
;
const
textBeforeCursor
=
ed
.
getText
(
cur
.
line
)
.
substring
(
0
cur
.
ch
)
;
const
backwardsTextBeforeCursor
=
textBeforeCursor
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
;
const
backwardsPreLabel
=
preLabel
.
split
(
"
"
)
.
reverse
(
)
.
join
(
"
"
)
;
if
(
backwardsPreLabel
.
indexOf
(
backwardsTextBeforeCursor
)
=
=
=
0
)
{
ed
.
replaceText
(
text
{
line
:
cur
.
line
ch
:
0
}
cur
)
;
}
else
{
ed
.
replaceText
(
text
.
slice
(
preLabel
.
length
)
cur
cur
)
;
}
}
function
cycleSuggestions
(
ed
reverse
)
{
const
autocompleteOpts
=
autocompleteMap
.
get
(
ed
)
;
const
{
popup
}
=
autocompleteOpts
;
const
cur
=
ed
.
getCursor
(
)
;
autocompleteOpts
.
insertingSuggestion
=
true
;
if
(
!
autocompleteOpts
.
suggestionInsertedOnce
)
{
autocompleteOpts
.
suggestionInsertedOnce
=
true
;
let
firstItem
;
if
(
reverse
)
{
firstItem
=
popup
.
getItemAtIndex
(
popup
.
itemCount
-
1
)
;
popup
.
selectPreviousItem
(
)
;
}
else
{
firstItem
=
popup
.
getItemAtIndex
(
0
)
;
if
(
firstItem
.
label
=
=
firstItem
.
preLabel
&
&
popup
.
itemCount
>
1
)
{
firstItem
=
popup
.
getItemAtIndex
(
1
)
;
popup
.
selectNextItem
(
)
;
}
}
if
(
popup
.
itemCount
=
=
1
)
{
popup
.
hidePopup
(
)
;
}
insertPopupItem
(
ed
firstItem
)
;
}
else
{
const
fromCur
=
{
line
:
cur
.
line
ch
:
cur
.
ch
-
popup
.
selectedItem
.
text
.
length
}
;
if
(
reverse
)
{
popup
.
selectPreviousItem
(
)
;
}
else
{
popup
.
selectNextItem
(
)
;
}
ed
.
replaceText
(
popup
.
selectedItem
.
text
fromCur
cur
)
;
}
ed
.
emit
(
"
suggestion
-
entered
"
)
;
}
function
onEditorKeypress
(
{
ed
Editor
}
cm
event
)
{
const
autocompleteOpts
=
autocompleteMap
.
get
(
ed
)
;
if
(
ed
.
hasMultipleSelections
(
)
)
{
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
return
;
}
if
(
(
event
.
ctrlKey
|
|
event
.
metaKey
)
&
&
event
.
keyCode
=
=
KeyCodes
.
DOM_VK_SPACE
)
{
autocompleteOpts
.
doNotAutocomplete
=
false
;
return
;
}
if
(
event
.
ctrlKey
|
|
event
.
metaKey
|
|
event
.
altKey
)
{
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
return
;
}
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_RETURN
:
autocompleteOpts
.
doNotAutocomplete
=
true
;
break
;
case
KeyCodes
.
DOM_VK_ESCAPE
:
if
(
autocompleteOpts
.
popup
.
isOpen
)
{
event
.
preventDefault
(
)
;
}
break
;
case
KeyCodes
.
DOM_VK_LEFT
:
case
KeyCodes
.
DOM_VK_RIGHT
:
case
KeyCodes
.
DOM_VK_HOME
:
case
KeyCodes
.
DOM_VK_END
:
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
break
;
case
KeyCodes
.
DOM_VK_BACK_SPACE
:
case
KeyCodes
.
DOM_VK_DELETE
:
if
(
ed
.
config
.
mode
=
=
Editor
.
modes
.
css
)
{
autocompleteOpts
.
completer
.
invalidateCache
(
ed
.
getCursor
(
)
.
line
)
;
}
autocompleteOpts
.
doNotAutocomplete
=
true
;
autocompleteOpts
.
popup
.
hidePopup
(
)
;
break
;
default
:
autocompleteOpts
.
doNotAutocomplete
=
false
;
}
}
function
getPopup
(
{
ed
}
)
{
if
(
autocompleteMap
.
has
(
ed
)
)
{
return
autocompleteMap
.
get
(
ed
)
.
popup
;
}
return
null
;
}
function
getInfoAt
(
{
ed
}
caret
)
{
if
(
autocompleteMap
.
has
(
ed
)
)
{
const
completer
=
autocompleteMap
.
get
(
ed
)
.
completer
;
if
(
completer
&
&
completer
.
getInfoAt
)
{
return
completer
.
getInfoAt
(
ed
.
getText
(
)
caret
)
;
}
}
return
null
;
}
function
isAutocompletionEnabled
(
{
ed
}
)
{
return
autocompleteMap
.
has
(
ed
)
;
}
module
.
exports
.
initializeAutoCompletion
=
initializeAutoCompletion
;
module
.
exports
.
destroyAutoCompletion
=
destroyAutoCompletion
;
module
.
exports
.
getAutocompletionPopup
=
getPopup
;
module
.
exports
.
getInfoAt
=
getInfoAt
;
module
.
exports
.
isAutocompletionEnabled
=
isAutocompletionEnabled
;
