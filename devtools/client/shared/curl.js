"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
DEFAULT_HTTP_VERSION
=
"
HTTP
/
1
.
1
"
;
const
Curl
=
{
generateCommand
:
function
(
data
)
{
let
utils
=
CurlUtils
;
let
command
=
[
"
curl
"
]
;
let
ignoredHeaders
=
new
Set
(
)
;
let
escapeString
=
Services
.
appinfo
.
OS
=
=
"
WINNT
"
?
utils
.
escapeStringWin
:
utils
.
escapeStringPosix
;
command
.
push
(
escapeString
(
data
.
url
)
)
;
let
postDataText
=
null
;
let
multipartRequest
=
utils
.
isMultipartRequest
(
data
)
;
let
postData
=
[
]
;
if
(
utils
.
isUrlEncodedRequest
(
data
)
|
|
data
.
method
=
=
"
PUT
"
)
{
postDataText
=
data
.
postDataText
;
postData
.
push
(
"
-
-
data
"
)
;
postData
.
push
(
escapeString
(
utils
.
writePostDataTextParams
(
postDataText
)
)
)
;
ignoredHeaders
.
add
(
"
Content
-
Length
"
)
;
}
else
if
(
multipartRequest
)
{
postDataText
=
data
.
postDataText
;
postData
.
push
(
"
-
-
data
-
binary
"
)
;
let
boundary
=
utils
.
getMultipartBoundary
(
data
)
;
let
text
=
utils
.
removeBinaryDataFromMultipartText
(
postDataText
boundary
)
;
postData
.
push
(
escapeString
(
text
)
)
;
ignoredHeaders
.
add
(
"
Content
-
Length
"
)
;
}
if
(
!
(
data
.
method
=
=
"
GET
"
|
|
data
.
method
=
=
"
POST
"
)
)
{
command
.
push
(
"
-
X
"
)
;
command
.
push
(
data
.
method
)
;
}
if
(
data
.
method
=
=
"
HEAD
"
)
{
command
.
push
(
"
-
I
"
)
;
}
if
(
data
.
httpVersion
&
&
data
.
httpVersion
!
=
DEFAULT_HTTP_VERSION
)
{
command
.
push
(
"
-
-
"
+
data
.
httpVersion
.
split
(
"
/
"
)
[
1
]
)
;
}
let
headers
=
data
.
headers
;
if
(
multipartRequest
)
{
let
multipartHeaders
=
utils
.
getHeadersFromMultipartText
(
postDataText
)
;
headers
=
headers
.
concat
(
multipartHeaders
)
;
}
for
(
let
i
=
0
;
i
<
headers
.
length
;
i
+
+
)
{
let
header
=
headers
[
i
]
;
if
(
header
.
name
=
=
=
"
Accept
-
Encoding
"
)
{
command
.
push
(
"
-
-
compressed
"
)
;
continue
;
}
if
(
ignoredHeaders
.
has
(
header
.
name
)
)
{
continue
;
}
command
.
push
(
"
-
H
"
)
;
command
.
push
(
escapeString
(
header
.
name
+
"
:
"
+
header
.
value
)
)
;
}
command
=
command
.
concat
(
postData
)
;
return
command
.
join
(
"
"
)
;
}
}
;
exports
.
Curl
=
Curl
;
const
CurlUtils
=
{
isUrlEncodedRequest
:
function
(
data
)
{
let
postDataText
=
data
.
postDataText
;
if
(
!
postDataText
)
{
return
false
;
}
postDataText
=
postDataText
.
toLowerCase
(
)
;
if
(
postDataText
.
includes
(
"
content
-
type
:
application
/
x
-
www
-
form
-
urlencoded
"
)
)
{
return
true
;
}
let
contentType
=
this
.
findHeader
(
data
.
headers
"
content
-
type
"
)
;
return
(
contentType
&
&
contentType
.
toLowerCase
(
)
.
includes
(
"
application
/
x
-
www
-
form
-
urlencoded
"
)
)
;
}
isMultipartRequest
:
function
(
data
)
{
let
postDataText
=
data
.
postDataText
;
if
(
!
postDataText
)
{
return
false
;
}
postDataText
=
postDataText
.
toLowerCase
(
)
;
if
(
postDataText
.
includes
(
"
content
-
type
:
multipart
/
form
-
data
"
)
)
{
return
true
;
}
let
contentType
=
this
.
findHeader
(
data
.
headers
"
content
-
type
"
)
;
return
(
contentType
&
&
contentType
.
toLowerCase
(
)
.
includes
(
"
multipart
/
form
-
data
;
"
)
)
;
}
writePostDataTextParams
:
function
(
postDataText
)
{
let
lines
=
postDataText
.
split
(
"
\
r
\
n
"
)
;
return
lines
[
lines
.
length
-
1
]
;
}
findHeader
:
function
(
headers
name
)
{
if
(
!
headers
)
{
return
null
;
}
name
=
name
.
toLowerCase
(
)
;
for
(
let
header
of
headers
)
{
if
(
name
=
=
header
.
name
.
toLowerCase
(
)
)
{
return
header
.
value
;
}
}
return
null
;
}
getMultipartBoundary
:
function
(
data
)
{
let
boundaryRe
=
/
\
bboundary
=
(
-
{
3
}
\
w
+
)
/
i
;
let
contentType
=
this
.
findHeader
(
data
.
headers
"
Content
-
Type
"
)
;
if
(
boundaryRe
.
test
(
contentType
)
)
{
return
contentType
.
match
(
boundaryRe
)
[
1
]
;
}
let
boundaryString
=
data
.
postDataText
.
match
(
boundaryRe
)
[
1
]
;
if
(
boundaryString
)
{
return
boundaryString
;
}
return
null
;
}
removeBinaryDataFromMultipartText
:
function
(
multipartText
boundary
)
{
let
result
=
"
"
;
boundary
=
"
-
-
"
+
boundary
;
let
parts
=
multipartText
.
split
(
boundary
)
;
for
(
let
part
of
parts
)
{
let
contentDispositionLine
=
part
.
trimLeft
(
)
.
split
(
"
\
r
\
n
"
)
[
0
]
;
if
(
!
contentDispositionLine
)
{
continue
;
}
contentDispositionLine
=
contentDispositionLine
.
toLowerCase
(
)
;
if
(
contentDispositionLine
.
includes
(
"
content
-
disposition
:
form
-
data
"
)
)
{
if
(
contentDispositionLine
.
includes
(
"
filename
=
"
)
)
{
let
headers
=
part
.
split
(
"
\
r
\
n
\
r
\
n
"
)
[
0
]
;
result
+
=
boundary
+
"
\
r
\
n
"
+
headers
+
"
\
r
\
n
\
r
\
n
"
;
}
else
{
result
+
=
boundary
+
"
\
r
\
n
"
+
part
;
}
}
}
result
+
=
boundary
+
"
-
-
\
r
\
n
"
;
return
result
;
}
getHeadersFromMultipartText
:
function
(
multipartText
)
{
let
headers
=
[
]
;
if
(
!
multipartText
|
|
multipartText
.
startsWith
(
"
-
-
-
"
)
)
{
return
headers
;
}
let
index
=
multipartText
.
indexOf
(
"
\
r
\
n
\
r
\
n
"
)
;
if
(
index
=
=
-
1
)
{
return
headers
;
}
let
headersText
=
multipartText
.
substring
(
0
index
)
;
let
headerLines
=
headersText
.
split
(
"
\
r
\
n
"
)
;
let
lastHeaderName
=
null
;
for
(
let
line
of
headerLines
)
{
if
(
lastHeaderName
&
&
/
^
\
s
+
/
.
test
(
line
)
)
{
headers
.
push
(
{
name
:
lastHeaderName
value
:
line
.
trim
(
)
}
)
;
continue
;
}
let
indexOfColon
=
line
.
indexOf
(
"
:
"
)
;
if
(
indexOfColon
=
=
-
1
)
{
continue
;
}
let
header
=
[
line
.
slice
(
0
indexOfColon
)
line
.
slice
(
indexOfColon
+
1
)
]
;
if
(
header
.
length
!
=
2
)
{
continue
;
}
lastHeaderName
=
header
[
0
]
.
trim
(
)
;
headers
.
push
(
{
name
:
lastHeaderName
value
:
header
[
1
]
.
trim
(
)
}
)
;
}
return
headers
;
}
escapeStringPosix
:
function
(
str
)
{
function
escapeCharacter
(
x
)
{
let
code
=
x
.
charCodeAt
(
0
)
;
if
(
code
<
256
)
{
return
code
<
16
?
"
\
\
x0
"
+
code
.
toString
(
16
)
:
"
\
\
x
"
+
code
.
toString
(
16
)
;
}
code
=
code
.
toString
(
16
)
;
return
"
\
\
u
"
+
(
"
0000
"
+
code
)
.
substr
(
code
.
length
4
)
;
}
if
(
/
[
^
\
x20
-
\
x7E
]
|
\
'
/
.
test
(
str
)
)
{
return
"
\
'
"
+
str
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
.
replace
(
/
\
'
/
g
"
\
\
\
'
"
)
.
replace
(
/
\
n
/
g
"
\
\
n
"
)
.
replace
(
/
\
r
/
g
"
\
\
r
"
)
.
replace
(
/
[
^
\
x20
-
\
x7E
]
/
g
escapeCharacter
)
+
"
'
"
;
}
return
"
'
"
+
str
+
"
'
"
;
}
escapeStringWin
:
function
(
str
)
{
return
"
\
"
"
+
str
.
replace
(
/
"
/
g
"
\
"
\
"
"
)
.
replace
(
/
%
/
g
"
\
"
%
\
"
"
)
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
.
replace
(
/
[
\
r
\
n
]
+
/
g
"
\
"
^
&
\
"
"
)
+
"
\
"
"
;
}
}
;
exports
.
CurlUtils
=
CurlUtils
;
