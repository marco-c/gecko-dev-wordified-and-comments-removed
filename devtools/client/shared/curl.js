"
use
strict
"
;
const
Curl
=
{
generateCommand
(
data
platform
)
{
const
utils
=
CurlUtils
;
let
commandParts
=
[
]
;
const
escapeStringifNeeded
=
value
=
>
{
return
/
^
[
a
-
zA
-
Z
-
]
+
/
.
test
(
value
)
?
value
:
escapeString
(
value
)
;
}
;
const
ignoredHeaders
=
new
Set
(
)
;
const
currentPlatform
=
platform
|
|
Services
.
appinfo
.
OS
;
const
escapeString
=
currentPlatform
=
=
=
"
WINNT
"
?
utils
.
escapeStringWin
:
utils
.
escapeStringPosix
;
commandParts
.
push
(
escapeString
(
data
.
url
)
)
;
if
(
data
.
url
.
includes
(
"
[
"
)
|
|
data
.
url
.
includes
(
"
]
"
)
)
{
commandParts
.
push
(
"
-
-
globoff
"
)
;
}
let
postDataText
=
null
;
const
multipartRequest
=
utils
.
isMultipartRequest
(
data
)
;
const
postData
=
[
]
;
if
(
multipartRequest
)
{
postDataText
=
data
.
postDataText
;
postData
.
push
(
"
-
-
data
-
binary
"
)
;
const
boundary
=
utils
.
getMultipartBoundary
(
data
)
;
const
text
=
utils
.
removeBinaryDataFromMultipartText
(
postDataText
boundary
)
;
postData
.
push
(
escapeStringifNeeded
(
text
)
)
;
ignoredHeaders
.
add
(
"
content
-
length
"
)
;
}
else
if
(
data
.
postDataText
&
&
(
utils
.
isUrlEncodedRequest
(
data
)
|
|
[
"
PUT
"
"
POST
"
"
PATCH
"
]
.
includes
(
data
.
method
)
)
)
{
postDataText
=
data
.
postDataText
;
postData
.
push
(
"
-
-
data
-
raw
"
+
escapeStringifNeeded
(
{
utils
.
writePostDataTextParams
(
postDataText
)
}
)
)
;
ignoredHeaders
.
add
(
"
content
-
length
"
)
;
}
ignoredHeaders
.
add
(
"
host
"
)
;
if
(
utils
.
isContentEncodedResponse
(
data
)
)
{
commandParts
.
push
(
"
-
-
compressed
"
)
;
}
if
(
data
.
method
=
=
=
"
HEAD
"
)
{
commandParts
.
push
(
"
-
I
"
)
;
}
else
if
(
data
.
method
!
=
=
"
GET
"
)
{
commandParts
.
push
(
"
-
X
"
+
escapeStringifNeeded
(
{
data
.
method
}
)
)
;
}
let
headers
=
data
.
headers
;
if
(
multipartRequest
)
{
const
multipartHeaders
=
utils
.
getHeadersFromMultipartText
(
postDataText
)
;
headers
=
headers
.
concat
(
multipartHeaders
)
;
}
for
(
let
i
=
0
;
i
<
headers
.
length
;
i
+
+
)
{
const
header
=
headers
[
i
]
;
if
(
ignoredHeaders
.
has
(
header
.
name
.
toLowerCase
(
)
)
)
{
continue
;
}
commandParts
.
push
(
"
-
H
"
+
escapeStringifNeeded
(
{
header
.
name
}
:
{
header
.
value
}
)
)
;
}
commandParts
=
commandParts
.
concat
(
postData
)
;
const
joinStr
=
currentPlatform
=
=
=
"
WINNT
"
?
"
^
\
n
"
:
"
\
\
\
n
"
;
const
CMD
=
currentPlatform
=
=
"
WINNT
"
?
"
curl
.
exe
"
:
"
curl
"
;
return
CMD
+
commandParts
.
join
(
commandParts
.
length
>
=
3
?
joinStr
:
"
"
)
;
}
}
;
exports
.
Curl
=
Curl
;
const
CurlUtils
=
{
isUrlEncodedRequest
(
data
)
{
let
postDataText
=
data
.
postDataText
;
if
(
!
postDataText
)
{
return
false
;
}
postDataText
=
postDataText
.
toLowerCase
(
)
;
if
(
postDataText
.
includes
(
"
content
-
type
:
application
/
x
-
www
-
form
-
urlencoded
"
)
)
{
return
true
;
}
const
contentType
=
this
.
findHeader
(
data
.
headers
"
content
-
type
"
)
;
return
(
contentType
&
&
contentType
.
toLowerCase
(
)
.
includes
(
"
application
/
x
-
www
-
form
-
urlencoded
"
)
)
;
}
isMultipartRequest
(
data
)
{
let
postDataText
=
data
.
postDataText
;
if
(
!
postDataText
)
{
return
false
;
}
postDataText
=
postDataText
.
toLowerCase
(
)
;
if
(
postDataText
.
includes
(
"
content
-
type
:
multipart
/
form
-
data
"
)
)
{
return
true
;
}
const
contentType
=
this
.
findHeader
(
data
.
headers
"
content
-
type
"
)
;
return
(
contentType
&
&
contentType
.
toLowerCase
(
)
.
includes
(
"
multipart
/
form
-
data
;
"
)
)
;
}
isContentEncodedResponse
(
data
)
{
return
!
!
this
.
findHeader
(
data
.
responseHeaders
"
content
-
encoding
"
)
;
}
writePostDataTextParams
(
postDataText
)
{
if
(
!
postDataText
)
{
return
"
"
;
}
const
lines
=
postDataText
.
split
(
"
\
r
\
n
"
)
;
return
lines
[
lines
.
length
-
1
]
;
}
findHeader
(
headers
name
)
{
if
(
!
headers
)
{
return
null
;
}
name
=
name
.
toLowerCase
(
)
;
for
(
const
header
of
headers
)
{
if
(
name
=
=
header
.
name
.
toLowerCase
(
)
)
{
return
header
.
value
;
}
}
return
null
;
}
getMultipartBoundary
(
data
)
{
const
boundaryRe
=
/
\
bboundary
=
(
-
{
3
}
\
w
+
)
/
i
;
const
contentType
=
this
.
findHeader
(
data
.
headers
"
Content
-
Type
"
)
;
if
(
boundaryRe
.
test
(
contentType
)
)
{
return
contentType
.
match
(
boundaryRe
)
[
1
]
;
}
const
boundaryString
=
data
.
postDataText
.
match
(
boundaryRe
)
[
1
]
;
if
(
boundaryString
)
{
return
boundaryString
;
}
return
null
;
}
removeBinaryDataFromMultipartText
(
multipartText
boundary
)
{
let
result
=
"
"
;
boundary
=
"
-
-
"
+
boundary
;
const
parts
=
multipartText
.
split
(
boundary
)
;
for
(
const
part
of
parts
)
{
let
contentDispositionLine
=
part
.
trimLeft
(
)
.
split
(
"
\
r
\
n
"
)
[
0
]
;
if
(
!
contentDispositionLine
)
{
continue
;
}
contentDispositionLine
=
contentDispositionLine
.
toLowerCase
(
)
;
if
(
contentDispositionLine
.
includes
(
"
content
-
disposition
:
form
-
data
"
)
)
{
if
(
contentDispositionLine
.
includes
(
"
filename
=
"
)
)
{
const
headers
=
part
.
split
(
"
\
r
\
n
\
r
\
n
"
)
[
0
]
;
result
+
=
boundary
+
headers
+
"
\
r
\
n
\
r
\
n
"
;
}
else
{
result
+
=
boundary
+
part
;
}
}
}
result
+
=
boundary
+
"
-
-
\
r
\
n
"
;
return
result
;
}
getHeadersFromMultipartText
(
multipartText
)
{
const
headers
=
[
]
;
if
(
!
multipartText
|
|
multipartText
.
startsWith
(
"
-
-
-
"
)
)
{
return
headers
;
}
const
index
=
multipartText
.
indexOf
(
"
\
r
\
n
\
r
\
n
"
)
;
if
(
index
=
=
-
1
)
{
return
headers
;
}
const
headersText
=
multipartText
.
substring
(
0
index
)
;
const
headerLines
=
headersText
.
split
(
"
\
r
\
n
"
)
;
let
lastHeaderName
=
null
;
for
(
const
line
of
headerLines
)
{
if
(
lastHeaderName
&
&
/
^
\
s
+
/
.
test
(
line
)
)
{
headers
.
push
(
{
name
:
lastHeaderName
value
:
line
.
trim
(
)
}
)
;
continue
;
}
const
indexOfColon
=
line
.
indexOf
(
"
:
"
)
;
if
(
indexOfColon
=
=
-
1
)
{
continue
;
}
const
header
=
[
line
.
slice
(
0
indexOfColon
)
line
.
slice
(
indexOfColon
+
1
)
]
;
if
(
header
.
length
!
=
2
)
{
continue
;
}
lastHeaderName
=
header
[
0
]
.
trim
(
)
;
headers
.
push
(
{
name
:
lastHeaderName
value
:
header
[
1
]
.
trim
(
)
}
)
;
}
return
headers
;
}
escapeStringPosix
(
str
)
{
function
escapeCharacter
(
x
)
{
let
code
=
x
.
charCodeAt
(
0
)
;
if
(
code
<
256
)
{
return
code
<
16
?
"
\
\
x0
"
+
code
.
toString
(
16
)
:
"
\
\
x
"
+
code
.
toString
(
16
)
;
}
code
=
code
.
toString
(
16
)
;
return
"
\
\
u
"
+
(
"
0000
"
+
code
)
.
substr
(
code
.
length
4
)
;
}
if
(
/
[
^
\
x20
-
\
x7E
]
|
!
|
\
'
/
.
test
(
str
)
)
{
return
(
"
'
"
+
str
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
.
replace
(
/
\
'
/
g
"
\
\
'
"
)
.
replace
(
/
\
n
/
g
"
\
\
n
"
)
.
replace
(
/
\
r
/
g
"
\
\
r
"
)
.
replace
(
/
!
/
g
"
\
\
041
"
)
.
replace
(
/
[
^
\
x20
-
\
x7E
]
/
g
escapeCharacter
)
+
"
'
"
)
;
}
return
"
'
"
+
str
+
"
'
"
;
}
escapeStringWin
(
str
)
{
const
encapsChars
=
'
^
"
'
;
return
(
encapsChars
+
str
.
replace
(
/
"
/
g
'
\
\
"
'
)
.
replace
(
/
[
^
a
-
zA
-
Z0
-
9
\
s_
\
-
:
=
+
~
\
/
.
'
?
;
(
)
*
]
/
g
"
^
&
"
)
.
replace
(
/
%
(
?
=
[
a
-
zA
-
Z0
-
9_
]
)
/
g
"
%
^
"
)
.
replace
(
/
\
r
\
n
?
/
g
"
\
n
"
)
.
replace
(
/
\
n
/
g
'
"
^
\
r
\
n
\
r
\
n
"
'
)
+
encapsChars
)
;
}
}
;
exports
.
CurlUtils
=
CurlUtils
;
