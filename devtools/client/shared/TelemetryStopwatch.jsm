"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
TelemetryStopwatch
"
]
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
Log
"
"
resource
:
/
/
gre
/
modules
/
Log
.
jsm
"
)
;
const
NULL_OBJECT
=
{
}
;
const
NULL_KEY
=
{
}
;
const
Timers
=
{
_timers
:
new
Map
(
)
_validTypes
(
histogram
obj
key
)
{
const
nonEmptyString
=
value
=
>
{
return
typeof
value
=
=
=
"
string
"
&
&
value
!
=
=
"
"
&
&
value
.
length
>
0
;
}
;
return
nonEmptyString
(
histogram
)
&
&
typeof
obj
=
=
"
object
"
&
&
(
key
=
=
=
NULL_KEY
|
|
nonEmptyString
(
key
)
)
;
}
get
(
histogram
obj
key
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
if
(
!
this
.
has
(
histogram
obj
key
)
)
{
return
null
;
}
return
this
.
_timers
.
get
(
histogram
)
.
get
(
obj
)
.
get
(
key
)
;
}
put
(
histogram
obj
key
startTime
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
if
(
!
this
.
_validTypes
(
histogram
obj
key
)
)
{
return
false
;
}
const
objectMap
=
this
.
_timers
.
get
(
histogram
)
|
|
new
WeakMap
(
)
;
const
keyedInfo
=
objectMap
.
get
(
obj
)
|
|
new
Map
(
)
;
keyedInfo
.
set
(
key
startTime
)
;
objectMap
.
set
(
obj
keyedInfo
)
;
this
.
_timers
.
set
(
histogram
objectMap
)
;
return
true
;
}
has
(
histogram
obj
key
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
return
this
.
_timers
.
has
(
histogram
)
&
&
this
.
_timers
.
get
(
histogram
)
.
has
(
obj
)
&
&
this
.
_timers
.
get
(
histogram
)
.
get
(
obj
)
.
has
(
key
)
;
}
delete
(
histogram
obj
key
)
{
key
=
key
=
=
=
null
?
NULL_KEY
:
key
;
obj
=
obj
|
|
NULL_OBJECT
;
if
(
!
this
.
has
(
histogram
obj
key
)
)
{
return
false
;
}
const
objectMap
=
this
.
_timers
.
get
(
histogram
)
;
const
keyedInfo
=
objectMap
.
get
(
obj
)
;
if
(
keyedInfo
.
size
>
1
)
{
keyedInfo
.
delete
(
key
)
;
return
true
;
}
objectMap
.
delete
(
obj
)
;
return
true
;
}
}
;
var
TelemetryStopwatch
=
{
start
(
aHistogram
aObj
)
{
return
TelemetryStopwatchImpl
.
start
(
aHistogram
aObj
null
)
;
}
running
(
aHistogram
aObj
)
{
return
TelemetryStopwatchImpl
.
running
(
aHistogram
aObj
null
)
;
}
cancel
(
aHistogram
aObj
)
{
return
TelemetryStopwatchImpl
.
cancel
(
aHistogram
aObj
null
)
;
}
timeElapsed
(
aHistogram
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
timeElapsed
(
aHistogram
aObj
null
aCanceledOkay
)
;
}
finish
(
aHistogram
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
finish
(
aHistogram
aObj
null
aCanceledOkay
)
;
}
startKeyed
(
aHistogram
aKey
aObj
)
{
return
TelemetryStopwatchImpl
.
start
(
aHistogram
aObj
aKey
)
;
}
runningKeyed
(
aHistogram
aKey
aObj
)
{
return
TelemetryStopwatchImpl
.
running
(
aHistogram
aObj
aKey
)
;
}
cancelKeyed
(
aHistogram
aKey
aObj
)
{
return
TelemetryStopwatchImpl
.
cancel
(
aHistogram
aObj
aKey
)
;
}
timeElapsedKeyed
(
aHistogram
aKey
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
timeElapsed
(
aHistogram
aObj
aKey
aCanceledOkay
)
;
}
finishKeyed
(
aHistogram
aKey
aObj
aCanceledOkay
)
{
return
TelemetryStopwatchImpl
.
finish
(
aHistogram
aObj
aKey
aCanceledOkay
)
;
}
setTestModeEnabled
(
testing
)
{
TelemetryStopwatchImpl
.
suppressErrors
(
true
)
;
}
}
;
var
TelemetryStopwatchImpl
=
{
_suppressErrors
:
false
suppressErrors
(
suppress
)
{
this
.
_suppressErrors
=
suppress
;
}
start
(
histogram
object
key
)
{
if
(
Timers
.
has
(
histogram
object
key
)
)
{
Timers
.
delete
(
histogram
object
key
)
;
if
(
!
this
.
_suppressErrors
)
{
Cu
.
reportError
(
TelemetryStopwatch
:
key
"
{
histogram
}
"
was
already
+
"
initialized
"
)
;
}
return
false
;
}
return
Timers
.
put
(
histogram
object
key
Cu
.
now
(
)
)
;
}
running
(
histogram
object
key
)
{
return
Timers
.
has
(
histogram
object
key
)
;
}
cancel
(
histogram
object
key
)
{
return
Timers
.
delete
(
histogram
object
key
)
;
}
timeElapsed
(
histogram
object
key
aCanceledOkay
)
{
const
startTime
=
Timers
.
get
(
histogram
object
key
)
;
if
(
startTime
=
=
=
null
)
{
if
(
!
aCanceledOkay
&
&
!
this
.
_suppressErrors
)
{
Cu
.
reportError
(
"
TelemetryStopwatch
:
requesting
elapsed
time
for
"
+
nonexisting
stopwatch
.
Histogram
:
"
{
histogram
}
"
+
key
:
"
{
key
}
"
)
;
}
return
-
1
;
}
try
{
const
delta
=
Cu
.
now
(
)
-
startTime
;
return
Math
.
round
(
delta
/
1000
)
;
}
catch
(
e
)
{
if
(
!
this
.
_suppressErrors
)
{
Cu
.
reportError
(
"
TelemetryStopwatch
:
failed
to
calculate
elapsed
time
"
+
for
Histogram
:
"
{
histogram
}
"
key
:
"
{
key
}
"
+
exception
:
{
Log
.
exceptionStr
(
e
)
}
)
;
}
return
-
1
;
}
}
finish
(
histogram
object
key
aCanceledOkay
)
{
const
delta
=
this
.
timeElapsed
(
histogram
object
key
aCanceledOkay
)
;
if
(
delta
=
=
-
1
)
{
return
false
;
}
try
{
if
(
key
)
{
Services
.
telemetry
.
getKeyedHistogramById
(
histogram
)
.
add
(
key
delta
)
;
}
else
{
Services
.
telemetry
.
getHistogramById
(
histogram
)
.
add
(
delta
)
;
}
}
catch
(
e
)
{
if
(
!
this
.
_suppressErrors
)
{
Cu
.
reportError
(
"
TelemetryStopwatch
:
failed
to
update
the
Histogram
"
+
"
{
histogram
}
"
using
key
:
"
{
key
}
"
+
exception
:
{
Log
.
exceptionStr
(
e
)
}
)
;
}
return
false
;
}
return
Timers
.
delete
(
histogram
object
key
)
;
}
}
;
