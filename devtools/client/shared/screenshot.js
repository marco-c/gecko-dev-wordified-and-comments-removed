"
use
strict
"
;
const
{
Cc
Ci
}
=
require
(
"
chrome
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyImporter
(
this
"
Downloads
"
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
loader
.
lazyImporter
(
this
"
PrivateBrowsingUtils
"
"
resource
:
/
/
gre
/
modules
/
PrivateBrowsingUtils
.
jsm
"
)
;
const
STRINGS_URI
=
"
devtools
/
shared
/
locales
/
screenshot
.
properties
"
;
const
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
async
function
captureAndSaveScreenshot
(
targetFront
window
args
=
{
}
)
{
if
(
args
.
help
)
{
return
[
{
text
:
getFormattedHelpData
(
)
}
]
;
}
const
captureResponse
=
await
captureScreenshot
(
targetFront
args
)
;
if
(
captureResponse
.
error
)
{
return
captureResponse
.
messages
|
|
[
]
;
}
const
saveMessages
=
await
saveScreenshot
(
window
args
captureResponse
)
;
return
(
captureResponse
.
messages
|
|
[
]
)
.
concat
(
saveMessages
)
;
}
async
function
captureScreenshot
(
targetFront
args
)
{
const
supportsContentScreenshot
=
targetFront
.
hasActor
(
"
screenshotContent
"
)
;
if
(
!
supportsContentScreenshot
)
{
const
screenshotFront
=
await
targetFront
.
getFront
(
"
screenshot
"
)
;
return
screenshotFront
.
capture
(
args
)
;
}
if
(
args
.
delay
>
0
)
{
await
new
Promise
(
res
=
>
setTimeout
(
res
args
.
delay
*
1000
)
)
;
}
const
screenshotContentFront
=
await
targetFront
.
getFront
(
"
screenshot
-
content
"
)
;
const
{
rect
windowDpr
windowZoom
messages
error
}
=
await
screenshotContentFront
.
prepareCapture
(
args
)
;
if
(
error
)
{
return
{
error
messages
}
;
}
if
(
rect
)
{
args
.
rect
=
rect
;
}
args
.
dpr
|
|
=
windowDpr
;
args
.
snapshotScale
=
args
.
dpr
*
windowZoom
;
if
(
args
.
ignoreDprForFileScale
)
{
args
.
fileScale
=
windowZoom
;
}
args
.
browsingContextID
=
targetFront
.
browsingContextID
;
const
rootFront
=
targetFront
.
client
.
mainRoot
;
const
parentProcessScreenshotFront
=
await
rootFront
.
getFront
(
"
screenshot
"
)
;
const
captureResponse
=
await
parentProcessScreenshotFront
.
capture
(
args
)
;
return
{
.
.
.
captureResponse
messages
:
(
messages
|
|
[
]
)
.
concat
(
captureResponse
.
messages
|
|
[
]
)
}
;
}
const
screenshotDescription
=
L10N
.
getStr
(
"
screenshotDesc
"
)
;
const
screenshotGroupOptions
=
L10N
.
getStr
(
"
screenshotGroupOptions
"
)
;
const
screenshotCommandParams
=
[
{
name
:
"
clipboard
"
type
:
"
boolean
"
description
:
L10N
.
getStr
(
"
screenshotClipboardDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotClipboardManual
"
)
}
{
name
:
"
delay
"
type
:
"
number
"
description
:
L10N
.
getStr
(
"
screenshotDelayDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotDelayManual
"
)
}
{
name
:
"
dpr
"
type
:
"
number
"
description
:
L10N
.
getStr
(
"
screenshotDPRDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotDPRManual
"
)
}
{
name
:
"
fullpage
"
type
:
"
boolean
"
description
:
L10N
.
getStr
(
"
screenshotFullPageDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotFullPageManual
"
)
}
{
name
:
"
selector
"
type
:
"
string
"
description
:
L10N
.
getStr
(
"
inspectNodeDesc
"
)
manual
:
L10N
.
getStr
(
"
inspectNodeManual
"
)
}
{
name
:
"
file
"
type
:
"
boolean
"
description
:
L10N
.
getStr
(
"
screenshotFileDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotFileManual
"
)
}
{
name
:
"
filename
"
type
:
"
string
"
description
:
L10N
.
getStr
(
"
screenshotFilenameDesc
"
)
manual
:
L10N
.
getStr
(
"
screenshotFilenameManual
"
)
}
]
;
function
formatHelpField
(
param
)
{
const
padding
=
"
"
.
repeat
(
5
)
;
return
Object
.
entries
(
param
)
.
map
(
(
[
key
value
]
)
=
>
{
if
(
key
=
=
=
"
name
"
)
{
const
name
=
{
padding
}
-
-
{
value
}
;
return
name
;
}
return
{
padding
.
repeat
(
2
)
}
{
key
}
:
{
value
}
;
}
)
.
join
(
"
\
n
"
)
;
}
function
getFormattedHelpData
(
)
{
const
formattedParams
=
screenshotCommandParams
.
map
(
formatHelpField
)
.
join
(
"
\
n
\
n
"
)
;
return
{
screenshotDescription
}
\
n
{
screenshotGroupOptions
}
\
n
\
n
{
formattedParams
}
;
}
function
saveScreenshot
(
window
args
=
{
}
value
)
{
if
(
args
.
help
)
{
return
[
{
text
:
getFormattedHelpData
(
)
}
]
;
}
if
(
!
value
.
data
)
{
return
[
]
;
}
simulateCameraShutter
(
window
)
;
return
save
(
window
args
value
)
;
}
function
simulateCameraShutter
(
window
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
screenshot
.
audio
.
enabled
"
)
)
{
const
audioCamera
=
new
window
.
Audio
(
"
resource
:
/
/
devtools
/
client
/
themes
/
audio
/
shutter
.
wav
"
)
;
audioCamera
.
play
(
)
;
}
}
async
function
save
(
window
args
image
)
{
const
fileNeeded
=
args
.
filename
|
|
!
args
.
clipboard
|
|
args
.
file
;
const
results
=
[
]
;
if
(
args
.
clipboard
)
{
const
result
=
saveToClipboard
(
image
.
data
)
;
results
.
push
(
result
)
;
}
if
(
fileNeeded
)
{
const
result
=
await
saveToFile
(
window
image
)
;
results
.
push
(
result
)
;
}
return
results
;
}
function
saveToClipboard
(
base64URI
)
{
try
{
const
imageTools
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
;
const
base64Data
=
base64URI
.
replace
(
"
data
:
image
/
png
;
base64
"
"
"
)
;
const
image
=
atob
(
base64Data
)
;
const
img
=
imageTools
.
decodeImageFromBuffer
(
image
image
.
length
"
image
/
png
"
)
;
const
transferable
=
Cc
[
"
mozilla
.
org
/
widget
/
transferable
;
1
"
]
.
createInstance
(
Ci
.
nsITransferable
)
;
transferable
.
init
(
null
)
;
transferable
.
addDataFlavor
(
"
image
/
png
"
)
;
transferable
.
setTransferData
(
"
image
/
png
"
img
)
;
Services
.
clipboard
.
setData
(
transferable
null
Services
.
clipboard
.
kGlobalClipboard
)
;
return
{
text
:
L10N
.
getStr
(
"
screenshotCopied
"
)
}
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
{
level
:
"
error
"
text
:
L10N
.
getStr
(
"
screenshotErrorCopying
"
)
}
;
}
}
async
function
saveToFile
(
window
image
)
{
let
filename
=
image
.
filename
;
if
(
!
image
.
data
)
{
return
"
"
;
}
if
(
!
filename
.
match
(
/
.
png
/
i
)
)
{
filename
+
=
"
.
png
"
;
}
const
downloadsDir
=
await
Downloads
.
getPreferredDownloadsDirectory
(
)
;
const
downloadsDirExists
=
await
IOUtils
.
exists
(
downloadsDir
)
;
if
(
downloadsDirExists
)
{
filename
=
PathUtils
.
isAbsolute
(
filename
)
?
filename
:
PathUtils
.
joinRelative
(
downloadsDir
filename
)
;
}
const
targetFile
=
new
FileUtils
.
File
(
filename
)
;
try
{
const
download
=
await
Downloads
.
createDownload
(
{
source
:
{
url
:
image
.
data
isPrivate
:
window
.
isChromeWindow
?
PrivateBrowsingUtils
.
isWindowPrivate
(
window
)
:
PrivateBrowsingUtils
.
isBrowserPrivate
(
window
.
browsingContext
.
embedderElement
)
}
target
:
targetFile
}
)
;
const
list
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
list
.
add
(
download
)
;
await
download
.
start
(
)
;
return
{
text
:
L10N
.
getFormatStr
(
"
screenshotSavedToFile
"
filename
)
}
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
return
{
level
:
"
error
"
text
:
L10N
.
getFormatStr
(
"
screenshotErrorSavingToFile
"
filename
)
}
;
}
}
module
.
exports
=
{
captureAndSaveScreenshot
captureScreenshot
saveScreenshot
}
;
