"
use
strict
"
;
const
{
SourceMapConsumer
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
source
-
map
/
source
-
map
.
js
"
)
;
SourceMapConsumer
.
initialize
(
{
"
lib
/
mappings
.
wasm
"
:
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
source
-
map
/
lib
/
mappings
.
wasm
"
}
)
;
const
{
networkRequest
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
-
loader
/
utils
/
network
-
request
.
js
"
)
;
const
assert
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
-
loader
/
utils
/
assert
.
js
"
)
;
const
{
fetchSourceMap
resolveSourceMapURL
hasOriginalURL
clearOriginalURLs
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
-
loader
/
utils
/
fetchSourceMap
.
js
"
)
;
const
{
getSourceMap
getSourceMapWithMetadata
setSourceMap
clearSourceMaps
:
clearSourceMapsRequests
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
-
loader
/
utils
/
sourceMapRequests
.
js
"
)
;
const
{
originalToGeneratedId
generatedToOriginalId
isGeneratedId
isOriginalId
getContentType
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
-
loader
/
utils
/
index
.
js
"
)
;
const
{
clearWasmXScopes
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
map
-
loader
/
wasm
-
dwarf
/
wasmXScopes
.
js
"
)
;
function
mapToOriginalSourceInfos
(
generatedId
urls
)
{
return
urls
.
map
(
url
=
>
{
return
{
id
:
generatedToOriginalId
(
generatedId
url
)
url
}
;
}
)
;
}
async
function
getOriginalURLs
(
generatedSource
)
{
const
{
resolvedSourceMapURL
baseURL
}
=
resolveSourceMapURL
(
generatedSource
)
;
const
map
=
await
fetchSourceMap
(
generatedSource
resolvedSourceMapURL
baseURL
)
;
return
map
?
mapToOriginalSourceInfos
(
generatedSource
.
id
map
.
sources
)
:
null
;
}
async
function
loadSourceMap
(
generatedSource
)
{
const
{
resolvedSourceMapURL
baseURL
}
=
resolveSourceMapURL
(
generatedSource
)
;
try
{
const
map
=
await
fetchSourceMap
(
generatedSource
resolvedSourceMapURL
baseURL
)
;
if
(
!
map
.
sources
.
length
)
{
throw
new
Error
(
"
No
sources
are
declared
in
this
source
map
.
"
)
;
}
let
ignoreListUrls
=
[
]
;
if
(
map
.
x_google_ignoreList
?
.
length
)
{
ignoreListUrls
=
map
.
x_google_ignoreList
.
map
(
sourceIndex
=
>
map
.
sources
[
sourceIndex
]
)
;
}
return
{
sources
:
mapToOriginalSourceInfos
(
generatedSource
.
id
map
.
sources
)
resolvedSourceMapURL
ignoreListUrls
}
;
}
catch
(
e
)
{
return
{
sources
:
[
]
resolvedSourceMapURL
ignoreListUrls
:
[
]
exception
:
e
.
message
}
;
}
}
const
COMPUTED_SPANS
=
new
WeakSet
(
)
;
const
SOURCE_MAPPINGS
=
new
WeakMap
(
)
;
async
function
getOriginalRanges
(
sourceId
)
{
if
(
!
isOriginalId
(
sourceId
)
)
{
return
[
]
;
}
const
generatedSourceId
=
originalToGeneratedId
(
sourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
[
]
;
}
const
{
map
}
=
data
;
const
url
=
data
.
urlsById
.
get
(
sourceId
)
;
let
mappings
=
SOURCE_MAPPINGS
.
get
(
map
)
;
if
(
!
mappings
)
{
mappings
=
new
Map
(
)
;
SOURCE_MAPPINGS
.
set
(
map
mappings
)
;
}
let
fileMappings
=
mappings
.
get
(
url
)
;
if
(
!
fileMappings
)
{
fileMappings
=
[
]
;
mappings
.
set
(
url
fileMappings
)
;
const
originalMappings
=
fileMappings
;
map
.
eachMapping
(
mapping
=
>
{
if
(
mapping
.
source
!
=
=
url
)
{
return
;
}
const
last
=
originalMappings
[
originalMappings
.
length
-
1
]
;
if
(
last
&
&
last
.
line
=
=
=
mapping
.
originalLine
)
{
if
(
last
.
columnStart
<
mapping
.
originalColumn
)
{
last
.
columnEnd
=
mapping
.
originalColumn
;
}
else
{
return
;
}
}
originalMappings
.
push
(
{
line
:
mapping
.
originalLine
columnStart
:
mapping
.
originalColumn
columnEnd
:
Infinity
}
)
;
}
null
SourceMapConsumer
.
ORIGINAL_ORDER
)
;
}
return
fileMappings
;
}
async
function
getGeneratedRanges
(
location
)
{
if
(
!
isOriginalId
(
location
.
sourceId
)
)
{
return
[
]
;
}
const
generatedSourceId
=
originalToGeneratedId
(
location
.
sourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
[
]
;
}
const
{
urlsById
map
}
=
data
;
if
(
!
COMPUTED_SPANS
.
has
(
map
)
)
{
COMPUTED_SPANS
.
add
(
map
)
;
map
.
computeColumnSpans
(
)
;
}
const
genPos
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
location
.
sourceId
)
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
bias
:
SourceMapConsumer
.
GREATEST_LOWER_BOUND
}
)
;
if
(
genPos
.
line
=
=
=
null
)
{
return
[
]
;
}
const
positions
=
map
.
allGeneratedPositionsFor
(
map
.
originalPositionFor
(
{
line
:
genPos
.
line
column
:
genPos
.
column
}
)
)
;
return
positions
.
map
(
mapping
=
>
(
{
line
:
mapping
.
line
columnStart
:
mapping
.
column
columnEnd
:
mapping
.
lastColumn
}
)
)
.
sort
(
(
a
b
)
=
>
{
const
line
=
a
.
line
-
b
.
line
;
return
line
=
=
=
0
?
a
.
column
-
b
.
column
:
line
;
}
)
;
}
async
function
getGeneratedLocation
(
location
)
{
if
(
!
isOriginalId
(
location
.
sourceId
)
)
{
return
null
;
}
const
generatedSourceId
=
originalToGeneratedId
(
location
.
sourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
null
;
}
const
{
urlsById
map
}
=
data
;
const
positions
=
map
.
allGeneratedPositionsFor
(
{
source
:
urlsById
.
get
(
location
.
sourceId
)
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
}
)
;
let
match
;
for
(
const
pos
of
positions
)
{
if
(
!
match
|
|
pos
.
line
<
match
.
line
|
|
pos
.
column
<
match
.
column
)
{
match
=
pos
;
}
}
if
(
!
match
)
{
match
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
location
.
sourceId
)
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
bias
:
SourceMapConsumer
.
LEAST_UPPER_BOUND
}
)
;
}
return
{
sourceId
:
generatedSourceId
line
:
match
.
line
column
:
match
.
column
}
;
}
async
function
getOriginalLocations
(
breakpointPositions
sourceId
)
{
const
map
=
await
getSourceMap
(
sourceId
)
;
if
(
!
map
)
{
return
null
;
}
for
(
const
line
in
breakpointPositions
)
{
const
breakableColumnsPerLine
=
breakpointPositions
[
line
]
;
for
(
let
i
=
0
;
i
<
breakableColumnsPerLine
.
length
;
i
+
+
)
{
const
column
=
breakableColumnsPerLine
[
i
]
;
const
mappedLocation
=
getOriginalLocationSync
(
map
{
sourceId
line
:
parseInt
(
line
10
)
column
}
)
;
if
(
mappedLocation
)
{
mappedLocation
.
generatedColumn
=
column
;
breakableColumnsPerLine
[
i
]
=
mappedLocation
;
}
}
}
return
breakpointPositions
;
}
function
getOriginalLocationSync
(
map
location
{
looseSearch
=
false
}
=
{
}
)
{
let
match
=
map
.
originalPositionFor
(
{
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
}
)
;
if
(
match
.
sourceUrl
=
=
null
&
&
looseSearch
)
{
let
line
=
location
.
line
;
let
firstLineChecked
=
(
location
.
column
|
|
0
)
!
=
=
0
;
while
(
match
.
sourceUrl
=
=
=
null
&
&
line
<
location
.
line
+
10
)
{
if
(
firstLineChecked
)
{
line
+
+
;
}
else
{
firstLineChecked
=
true
;
}
match
=
map
.
originalPositionFor
(
{
line
column
:
0
bias
:
SourceMapConsumer
.
LEAST_UPPER_BOUND
}
)
;
}
}
const
{
source
:
sourceUrl
line
column
}
=
match
;
if
(
sourceUrl
=
=
null
)
{
return
null
;
}
return
{
sourceId
:
generatedToOriginalId
(
location
.
sourceId
sourceUrl
)
sourceUrl
line
column
}
;
}
async
function
getOriginalLocation
(
location
options
)
{
if
(
!
isGeneratedId
(
location
.
sourceId
)
)
{
return
null
;
}
const
map
=
await
getSourceMap
(
location
.
sourceId
)
;
if
(
!
map
)
{
return
null
;
}
return
getOriginalLocationSync
(
map
location
options
)
;
}
async
function
getOriginalSourceText
(
originalSourceId
)
{
assert
(
isOriginalId
(
originalSourceId
)
"
Source
is
not
an
original
source
"
)
;
const
generatedSourceId
=
originalToGeneratedId
(
originalSourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
null
;
}
const
{
urlsById
map
}
=
data
;
const
url
=
urlsById
.
get
(
originalSourceId
)
;
let
text
=
map
.
sourceContentFor
(
url
true
)
;
if
(
!
text
)
{
try
{
const
response
=
await
networkRequest
(
url
{
sourceMapBaseURL
:
map
.
sourceMapBaseURL
loadFromCache
:
false
allowsRedirects
:
false
}
)
;
text
=
response
.
content
;
}
catch
(
err
)
{
err
.
metadata
=
{
url
}
;
throw
err
;
}
}
return
{
text
contentType
:
getContentType
(
url
|
|
"
"
)
}
;
}
const
GENERATED_MAPPINGS
=
new
WeakMap
(
)
;
async
function
getGeneratedRangesForOriginal
(
sourceId
mergeUnmappedRegions
=
false
)
{
assert
(
isOriginalId
(
sourceId
)
"
Source
is
not
an
original
source
"
)
;
const
data
=
await
getSourceMapWithMetadata
(
originalToGeneratedId
(
sourceId
)
)
;
if
(
!
data
)
{
return
[
]
;
}
const
{
urlsById
map
}
=
data
;
const
url
=
urlsById
.
get
(
sourceId
)
;
if
(
!
COMPUTED_SPANS
.
has
(
map
)
)
{
COMPUTED_SPANS
.
add
(
map
)
;
map
.
computeColumnSpans
(
)
;
}
if
(
!
GENERATED_MAPPINGS
.
has
(
map
)
)
{
GENERATED_MAPPINGS
.
set
(
map
new
Map
(
)
)
;
}
const
generatedRangesMap
=
GENERATED_MAPPINGS
.
get
(
map
)
;
if
(
!
generatedRangesMap
)
{
return
[
]
;
}
if
(
generatedRangesMap
.
has
(
sourceId
)
)
{
return
generatedRangesMap
.
get
(
sourceId
)
|
|
[
]
;
}
let
currentGroup
=
[
]
;
const
originalGroups
=
[
currentGroup
]
;
map
.
eachMapping
(
mapping
=
>
{
if
(
mapping
.
source
=
=
=
url
)
{
currentGroup
.
push
(
{
start
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
generatedColumn
}
end
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
lastGeneratedColumn
+
1
}
}
)
;
}
else
if
(
typeof
mapping
.
source
=
=
=
"
string
"
&
&
currentGroup
.
length
)
{
currentGroup
=
[
]
;
originalGroups
.
push
(
currentGroup
)
;
}
}
null
SourceMapConsumer
.
GENERATED_ORDER
)
;
const
generatedMappingsForOriginal
=
[
]
;
if
(
mergeUnmappedRegions
)
{
for
(
const
group
of
originalGroups
)
{
if
(
group
.
length
)
{
generatedMappingsForOriginal
.
push
(
{
start
:
group
[
0
]
.
start
end
:
group
[
group
.
length
-
1
]
.
end
}
)
;
}
}
}
else
{
let
lastEntry
;
for
(
const
group
of
originalGroups
)
{
lastEntry
=
null
;
for
(
const
{
start
end
}
of
group
)
{
const
lastEnd
=
lastEntry
?
wrappedMappingPosition
(
lastEntry
.
end
)
:
null
;
if
(
lastEntry
&
&
lastEnd
&
&
lastEnd
.
line
=
=
=
start
.
line
&
&
lastEnd
.
column
=
=
=
start
.
column
)
{
lastEntry
.
end
=
end
;
}
else
{
const
newEntry
=
{
start
end
}
;
generatedMappingsForOriginal
.
push
(
newEntry
)
;
lastEntry
=
newEntry
;
}
}
}
}
generatedRangesMap
.
set
(
sourceId
generatedMappingsForOriginal
)
;
return
generatedMappingsForOriginal
;
}
function
wrappedMappingPosition
(
pos
)
{
if
(
pos
.
column
!
=
=
Infinity
)
{
return
pos
;
}
return
{
line
:
pos
.
line
+
1
column
:
0
}
;
}
async
function
getFileGeneratedRange
(
originalSourceId
)
{
assert
(
isOriginalId
(
originalSourceId
)
"
Source
is
not
an
original
source
"
)
;
const
data
=
await
getSourceMapWithMetadata
(
originalToGeneratedId
(
originalSourceId
)
)
;
if
(
!
data
)
{
return
null
;
}
const
{
urlsById
map
}
=
data
;
const
start
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
originalSourceId
)
line
:
1
column
:
0
bias
:
SourceMapConsumer
.
LEAST_UPPER_BOUND
}
)
;
const
end
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
originalSourceId
)
line
:
Number
.
MAX_SAFE_INTEGER
column
:
Number
.
MAX_SAFE_INTEGER
bias
:
SourceMapConsumer
.
GREATEST_LOWER_BOUND
}
)
;
return
{
start
end
}
;
}
function
setSourceMapForGeneratedSources
(
generatedSourceIds
map
)
{
const
sourceMapConsumer
=
new
SourceMapConsumer
(
map
)
;
for
(
const
generatedId
of
generatedSourceIds
)
{
setSourceMap
(
generatedId
Promise
.
resolve
(
sourceMapConsumer
)
)
;
}
}
function
clearSourceMaps
(
)
{
clearSourceMapsRequests
(
)
;
clearWasmXScopes
(
)
;
clearOriginalURLs
(
)
;
}
module
.
exports
=
{
getOriginalURLs
loadSourceMap
hasOriginalURL
getOriginalRanges
getGeneratedRanges
getGeneratedLocation
getOriginalLocation
getOriginalLocations
getOriginalSourceText
getGeneratedRangesForOriginal
getFileGeneratedRange
setSourceMapForGeneratedSources
clearSourceMaps
}
;
