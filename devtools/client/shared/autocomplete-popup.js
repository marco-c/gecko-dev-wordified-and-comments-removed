"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
)
;
const
{
PrefObserver
}
=
require
(
"
devtools
/
client
/
shared
/
prefs
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
let
itemIdCounter
=
0
;
function
AutocompletePopup
(
toolboxDoc
options
=
{
}
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_document
=
toolboxDoc
;
this
.
autoSelect
=
options
.
autoSelect
|
|
false
;
this
.
position
=
options
.
position
|
|
"
bottom
"
;
let
theme
=
options
.
theme
|
|
"
dark
"
;
this
.
onSelectCallback
=
options
.
onSelect
;
this
.
onClickCallback
=
options
.
onClick
;
if
(
theme
=
=
=
"
auto
"
)
{
theme
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
this
.
autoThemeEnabled
=
true
;
this
.
_handleThemeChange
=
this
.
_handleThemeChange
.
bind
(
this
)
;
this
.
_prefObserver
=
new
PrefObserver
(
"
devtools
.
"
)
;
this
.
_prefObserver
.
on
(
"
devtools
.
theme
"
this
.
_handleThemeChange
)
;
this
.
_currentTheme
=
theme
;
}
this
.
_tooltip
=
new
HTMLTooltip
(
this
.
_document
)
;
this
.
_tooltip
.
panel
.
classList
.
add
(
"
devtools
-
autocomplete
-
popup
"
"
devtools
-
monospace
"
theme
+
"
-
theme
"
)
;
this
.
_tooltip
.
panel
.
setAttribute
(
"
role
"
"
presentation
"
)
;
this
.
_list
=
this
.
_document
.
createElementNS
(
HTML_NS
"
ul
"
)
;
this
.
_list
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_listClone
=
this
.
_list
.
cloneNode
(
)
;
this
.
_listClone
.
className
=
"
devtools
-
autocomplete
-
list
-
aria
-
clone
"
;
if
(
options
.
listId
)
{
this
.
_list
.
setAttribute
(
"
id
"
options
.
listId
)
;
}
this
.
_list
.
className
=
"
devtools
-
autocomplete
-
listbox
"
+
theme
+
"
-
theme
"
;
this
.
_tooltip
.
setContent
(
this
.
_list
{
height
:
Infinity
}
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
_list
.
addEventListener
(
"
click
"
this
.
onClick
)
;
this
.
items
=
[
]
;
this
.
elements
=
new
WeakMap
(
)
;
this
.
selectedIndex
=
-
1
;
}
AutocompletePopup
.
prototype
=
{
_document
:
null
_tooltip
:
null
_list
:
null
onSelect
:
function
(
e
)
{
if
(
this
.
onSelectCallback
)
{
this
.
onSelectCallback
(
e
)
;
}
}
onClick
:
function
(
e
)
{
const
item
=
e
.
target
.
closest
(
"
.
autocomplete
-
item
"
)
;
if
(
item
&
&
typeof
item
.
dataset
.
index
!
=
=
"
undefined
"
)
{
this
.
selectedIndex
=
parseInt
(
item
.
dataset
.
index
10
)
;
}
this
.
emit
(
"
popup
-
click
"
)
;
if
(
this
.
onClickCallback
)
{
this
.
onClickCallback
(
e
)
;
}
}
openPopup
:
function
(
anchor
xOffset
=
0
yOffset
=
0
index
)
{
this
.
__maxLabelLength
=
-
1
;
this
.
_updateSize
(
)
;
this
.
_activeElement
=
anchor
.
ownerDocument
.
activeElement
;
this
.
_tooltip
.
show
(
anchor
{
x
:
xOffset
y
:
yOffset
position
:
this
.
position
}
)
;
this
.
_tooltip
.
once
(
"
shown
"
(
)
=
>
{
if
(
this
.
autoSelect
)
{
this
.
selectItemAtIndex
(
index
)
;
}
this
.
emit
(
"
popup
-
opened
"
)
;
}
)
;
}
selectItemAtIndex
:
function
(
index
)
{
if
(
typeof
index
!
=
=
"
number
"
)
{
const
isAboveInput
=
this
.
position
=
=
=
"
top
"
;
index
=
isAboveInput
?
this
.
itemCount
-
1
:
0
;
}
this
.
selectedIndex
=
index
;
}
hidePopup
:
function
(
)
{
this
.
_tooltip
.
once
(
"
hidden
"
(
)
=
>
{
this
.
emit
(
"
popup
-
closed
"
)
;
}
)
;
this
.
_clearActiveDescendant
(
)
;
this
.
_activeElement
=
null
;
this
.
_tooltip
.
hide
(
)
;
}
get
isOpen
(
)
{
return
this
.
_tooltip
&
&
this
.
_tooltip
.
isVisible
(
)
;
}
destroy
:
function
(
)
{
if
(
this
.
isOpen
)
{
this
.
hidePopup
(
)
;
}
this
.
_list
.
removeEventListener
(
"
click
"
this
.
onClick
)
;
if
(
this
.
autoThemeEnabled
)
{
this
.
_prefObserver
.
off
(
"
devtools
.
theme
"
this
.
_handleThemeChange
)
;
this
.
_prefObserver
.
destroy
(
)
;
}
this
.
_list
.
remove
(
)
;
this
.
_listClone
.
remove
(
)
;
this
.
_tooltip
.
destroy
(
)
;
this
.
_document
=
null
;
this
.
_list
=
null
;
this
.
_tooltip
=
null
;
}
getItemAtIndex
:
function
(
index
)
{
return
this
.
items
[
index
]
;
}
getItems
:
function
(
)
{
return
this
.
items
.
slice
(
0
)
;
}
setItems
:
function
(
items
index
)
{
this
.
clearItems
(
)
;
items
.
forEach
(
this
.
appendItem
this
)
;
if
(
this
.
isOpen
&
&
this
.
autoSelect
)
{
this
.
selectItemAtIndex
(
index
)
;
}
}
__maxLabelLength
:
-
1
get
_maxLabelLength
(
)
{
if
(
this
.
__maxLabelLength
!
=
=
-
1
)
{
return
this
.
__maxLabelLength
;
}
let
max
=
0
;
for
(
let
{
label
postLabel
count
}
of
this
.
items
)
{
if
(
count
)
{
label
+
=
count
+
"
"
;
}
if
(
postLabel
)
{
label
+
=
postLabel
;
}
const
length
=
label
.
length
+
(
postLabel
?
3
:
0
)
;
max
=
Math
.
max
(
length
max
)
;
}
this
.
__maxLabelLength
=
max
;
return
this
.
__maxLabelLength
;
}
_updateSize
:
function
(
)
{
if
(
!
this
.
_tooltip
)
{
return
;
}
this
.
_list
.
style
.
width
=
(
this
.
_maxLabelLength
+
3
)
+
"
ch
"
;
const
selectedItem
=
this
.
selectedItem
;
if
(
selectedItem
)
{
this
.
_scrollElementIntoViewIfNeeded
(
this
.
elements
.
get
(
selectedItem
)
)
;
}
}
_scrollElementIntoViewIfNeeded
:
function
(
element
)
{
const
quads
=
element
.
getBoxQuads
(
{
relativeTo
:
this
.
_tooltip
.
panel
}
)
;
if
(
!
quads
|
|
!
quads
[
0
]
)
{
return
;
}
const
{
top
height
}
=
quads
[
0
]
.
getBounds
(
)
;
const
containerHeight
=
this
.
_tooltip
.
panel
.
getBoundingClientRect
(
)
.
height
;
if
(
top
<
0
)
{
element
.
scrollIntoView
(
true
)
;
}
else
if
(
(
top
+
height
)
>
containerHeight
)
{
element
.
scrollIntoView
(
false
)
;
}
}
clearItems
:
function
(
)
{
this
.
selectedIndex
=
-
1
;
this
.
_list
.
innerHTML
=
"
"
;
this
.
__maxLabelLength
=
-
1
;
this
.
items
=
[
]
;
this
.
elements
=
new
WeakMap
(
)
;
}
get
selectedIndex
(
)
{
return
this
.
_selectedIndex
;
}
set
selectedIndex
(
index
)
{
const
previousSelected
=
this
.
_list
.
querySelector
(
"
.
autocomplete
-
selected
"
)
;
if
(
previousSelected
)
{
previousSelected
.
classList
.
remove
(
"
autocomplete
-
selected
"
)
;
}
const
item
=
this
.
items
[
index
]
;
if
(
this
.
isOpen
&
&
item
)
{
const
element
=
this
.
elements
.
get
(
item
)
;
element
.
classList
.
add
(
"
autocomplete
-
selected
"
)
;
this
.
_scrollElementIntoViewIfNeeded
(
element
)
;
this
.
_setActiveDescendant
(
element
.
id
)
;
}
else
{
this
.
_clearActiveDescendant
(
)
;
}
this
.
_selectedIndex
=
index
;
if
(
this
.
isOpen
&
&
item
&
&
this
.
onSelectCallback
)
{
this
.
onSelectCallback
(
)
;
}
}
get
selectedItem
(
)
{
return
this
.
items
[
this
.
_selectedIndex
]
;
}
set
selectedItem
(
item
)
{
const
index
=
this
.
items
.
indexOf
(
item
)
;
if
(
index
!
=
=
-
1
&
&
this
.
isOpen
)
{
this
.
selectedIndex
=
index
;
}
}
_setActiveDescendant
:
function
(
id
)
{
if
(
!
this
.
_activeElement
)
{
return
;
}
const
anchorDoc
=
this
.
_activeElement
.
ownerDocument
;
if
(
!
this
.
_listClone
.
parentNode
|
|
this
.
_listClone
.
ownerDocument
!
=
=
anchorDoc
)
{
anchorDoc
.
documentElement
.
appendChild
(
this
.
_listClone
)
;
}
const
clone
=
this
.
_list
.
cloneNode
(
true
)
;
clone
.
className
=
"
devtools
-
autocomplete
-
list
-
aria
-
clone
"
;
this
.
_listClone
.
replaceWith
(
clone
)
;
this
.
_listClone
=
clone
;
this
.
_activeElement
.
setAttribute
(
"
aria
-
activedescendant
"
id
)
;
}
_clearActiveDescendant
:
function
(
)
{
if
(
!
this
.
_activeElement
)
{
return
;
}
this
.
_activeElement
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
appendItem
:
function
(
item
)
{
const
listItem
=
this
.
_document
.
createElementNS
(
HTML_NS
"
li
"
)
;
listItem
.
setAttribute
(
"
id
"
"
autocomplete
-
item
-
"
+
itemIdCounter
+
+
)
;
listItem
.
className
=
"
autocomplete
-
item
"
;
listItem
.
setAttribute
(
"
data
-
index
"
this
.
items
.
length
)
;
if
(
this
.
direction
)
{
listItem
.
setAttribute
(
"
dir
"
this
.
direction
)
;
}
const
label
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
label
.
textContent
=
item
.
label
;
label
.
className
=
"
autocomplete
-
value
"
;
if
(
item
.
preLabel
)
{
const
preDesc
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
preDesc
.
textContent
=
item
.
preLabel
;
preDesc
.
className
=
"
initial
-
value
"
;
listItem
.
appendChild
(
preDesc
)
;
label
.
textContent
=
item
.
label
.
slice
(
item
.
preLabel
.
length
)
;
}
listItem
.
appendChild
(
label
)
;
if
(
item
.
postLabel
)
{
const
postDesc
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
postDesc
.
className
=
"
autocomplete
-
postlabel
"
;
postDesc
.
textContent
=
item
.
postLabel
;
if
(
this
.
_isValidColor
(
item
.
postLabel
)
)
{
const
colorSwatch
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
colorSwatch
.
className
=
"
autocomplete
-
swatch
autocomplete
-
colorswatch
"
;
colorSwatch
.
style
.
cssText
=
"
background
-
color
:
"
+
item
.
postLabel
;
postDesc
.
insertBefore
(
colorSwatch
postDesc
.
childNodes
[
0
]
)
;
}
listItem
.
appendChild
(
postDesc
)
;
}
if
(
item
.
count
&
&
item
.
count
>
1
)
{
const
countDesc
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
countDesc
.
textContent
=
item
.
count
;
countDesc
.
setAttribute
(
"
flex
"
"
1
"
)
;
countDesc
.
className
=
"
autocomplete
-
count
"
;
listItem
.
appendChild
(
countDesc
)
;
}
this
.
_list
.
appendChild
(
listItem
)
;
this
.
items
.
push
(
item
)
;
this
.
elements
.
set
(
item
listItem
)
;
}
removeItem
:
function
(
item
)
{
if
(
!
this
.
items
.
includes
(
item
)
)
{
return
;
}
const
itemIndex
=
this
.
items
.
indexOf
(
item
)
;
const
selectedIndex
=
this
.
selectedIndex
;
this
.
items
.
splice
(
itemIndex
1
)
;
const
elementToRemove
=
this
.
elements
.
get
(
item
)
;
this
.
elements
.
delete
(
elementToRemove
)
;
elementToRemove
.
remove
(
)
;
if
(
itemIndex
<
=
selectedIndex
)
{
this
.
selectedIndex
=
Math
.
max
(
0
selectedIndex
-
1
)
;
}
}
get
itemCount
(
)
{
return
this
.
items
.
length
;
}
get
_itemsPerPane
(
)
{
if
(
this
.
items
.
length
)
{
const
listHeight
=
this
.
_tooltip
.
panel
.
clientHeight
;
const
element
=
this
.
elements
.
get
(
this
.
items
[
0
]
)
;
const
elementHeight
=
element
.
getBoundingClientRect
(
)
.
height
;
return
Math
.
floor
(
listHeight
/
elementHeight
)
;
}
return
0
;
}
selectNextItem
:
function
(
)
{
if
(
this
.
selectedIndex
<
(
this
.
items
.
length
-
1
)
)
{
this
.
selectedIndex
+
+
;
}
else
{
this
.
selectedIndex
=
0
;
}
return
this
.
selectedItem
;
}
selectPreviousItem
:
function
(
)
{
if
(
this
.
selectedIndex
>
0
)
{
this
.
selectedIndex
-
-
;
}
else
{
this
.
selectedIndex
=
this
.
items
.
length
-
1
;
}
return
this
.
selectedItem
;
}
selectNextPageItem
:
function
(
)
{
const
nextPageIndex
=
this
.
selectedIndex
+
this
.
_itemsPerPane
+
1
;
this
.
selectedIndex
=
Math
.
min
(
nextPageIndex
this
.
itemCount
-
1
)
;
return
this
.
selectedItem
;
}
selectPreviousPageItem
:
function
(
)
{
const
prevPageIndex
=
this
.
selectedIndex
-
this
.
_itemsPerPane
-
1
;
this
.
selectedIndex
=
Math
.
max
(
prevPageIndex
0
)
;
return
this
.
selectedItem
;
}
_handleThemeChange
:
function
(
)
{
const
oldValue
=
this
.
_currentTheme
;
const
newValue
=
Services
.
prefs
.
getCharPref
(
"
devtools
.
theme
"
)
;
this
.
_tooltip
.
panel
.
classList
.
toggle
(
oldValue
+
"
-
theme
"
false
)
;
this
.
_tooltip
.
panel
.
classList
.
toggle
(
newValue
+
"
-
theme
"
true
)
;
this
.
_list
.
classList
.
toggle
(
oldValue
+
"
-
theme
"
false
)
;
this
.
_list
.
classList
.
toggle
(
newValue
+
"
-
theme
"
true
)
;
this
.
_currentTheme
=
newValue
;
}
_isValidColor
:
function
(
color
)
{
const
colorObj
=
new
colorUtils
.
CssColor
(
color
)
;
return
(
colorObj
.
valid
&
&
(
!
colorObj
.
specialValue
)
)
;
}
get
_panel
(
)
{
return
this
.
_tooltip
.
panel
;
}
get
_window
(
)
{
return
this
.
_document
.
defaultView
;
}
}
;
module
.
exports
=
AutocompletePopup
;
