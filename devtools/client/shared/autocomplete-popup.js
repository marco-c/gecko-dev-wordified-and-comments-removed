"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
"
HTMLTooltip
"
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
colorUtils
"
"
devtools
/
shared
/
css
/
color
"
true
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
let
itemIdCounter
=
0
;
function
AutocompletePopup
(
toolboxDoc
options
=
{
}
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_document
=
toolboxDoc
;
this
.
autoSelect
=
options
.
autoSelect
|
|
false
;
this
.
listId
=
options
.
listId
|
|
null
;
this
.
position
=
options
.
position
|
|
"
bottom
"
;
this
.
useXulWrapper
=
options
.
useXulWrapper
|
|
false
;
this
.
onSelectCallback
=
options
.
onSelect
;
this
.
onClickCallback
=
options
.
onClick
;
this
.
items
=
[
]
;
this
.
elements
=
new
WeakMap
(
)
;
this
.
selectedIndex
=
-
1
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onInputKeyDown
=
this
.
onInputKeyDown
.
bind
(
this
)
;
this
.
onInputBlur
=
this
.
onInputBlur
.
bind
(
this
)
;
if
(
options
.
input
)
{
this
.
input
=
options
.
input
;
options
.
input
.
addEventListener
(
"
keydown
"
this
.
onInputKeyDown
)
;
options
.
input
.
addEventListener
(
"
blur
"
this
.
onInputBlur
)
;
}
}
AutocompletePopup
.
prototype
=
{
_document
:
null
get
list
(
)
{
if
(
this
.
_list
)
{
return
this
.
_list
;
}
this
.
_list
=
this
.
_document
.
createElementNS
(
HTML_NS
"
ul
"
)
;
this
.
_list
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_listClone
=
this
.
_list
.
cloneNode
(
)
;
this
.
_listClone
.
className
=
"
devtools
-
autocomplete
-
list
-
aria
-
clone
"
;
if
(
this
.
listId
)
{
this
.
_list
.
setAttribute
(
"
id
"
this
.
listId
)
;
}
this
.
_list
.
className
=
"
devtools
-
autocomplete
-
listbox
"
;
const
paddingPropertyName
=
"
-
-
autocomplete
-
item
-
padding
-
inline
"
;
const
listPadding
=
this
.
_document
.
defaultView
.
getComputedStyle
(
this
.
_list
)
.
getPropertyValue
(
paddingPropertyName
)
.
replace
(
"
px
"
"
"
)
;
this
.
_listPadding
=
0
;
if
(
!
Number
.
isNaN
(
Number
(
listPadding
)
)
)
{
this
.
_listPadding
=
Number
(
listPadding
)
;
}
this
.
_list
.
addEventListener
(
"
click
"
this
.
onClick
)
;
return
this
.
_list
;
}
get
tooltip
(
)
{
if
(
this
.
_tooltip
)
{
return
this
.
_tooltip
;
}
this
.
_tooltip
=
new
HTMLTooltip
(
this
.
_document
{
useXulWrapper
:
this
.
useXulWrapper
}
)
;
this
.
_tooltip
.
panel
.
classList
.
add
(
"
devtools
-
autocomplete
-
popup
"
"
devtools
-
monospace
"
)
;
this
.
_tooltip
.
panel
.
appendChild
(
this
.
list
)
;
this
.
_tooltip
.
setContentSize
(
{
height
:
"
auto
"
}
)
;
return
this
.
_tooltip
;
}
onInputKeyDown
(
event
)
{
if
(
!
this
.
isOpen
)
{
return
;
}
if
(
this
.
selectedItem
&
&
this
.
onClickCallback
&
&
(
event
.
key
=
=
=
"
Enter
"
|
|
(
event
.
key
=
=
=
"
ArrowRight
"
&
&
!
event
.
shiftKey
)
|
|
(
event
.
key
=
=
=
"
Tab
"
&
&
!
event
.
shiftKey
)
)
)
{
this
.
onClickCallback
(
event
this
.
selectedItem
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
if
(
event
.
key
=
=
=
"
ArrowLeft
"
&
&
!
event
.
shiftKey
)
{
this
.
clearItems
(
)
;
this
.
hidePopup
(
)
;
return
;
}
if
(
event
.
key
=
=
=
"
Escape
"
)
{
this
.
clearItems
(
)
;
this
.
hidePopup
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
if
(
event
.
key
=
=
=
"
ArrowDown
"
)
{
this
.
selectNextItem
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
return
;
}
if
(
event
.
key
=
=
=
"
ArrowUp
"
)
{
this
.
selectPreviousItem
(
)
;
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
}
}
onInputBlur
(
event
)
{
if
(
this
.
isOpen
)
{
this
.
clearItems
(
)
;
this
.
hidePopup
(
)
;
}
}
onSelect
(
e
)
{
if
(
this
.
onSelectCallback
)
{
this
.
onSelectCallback
(
e
)
;
}
}
onClick
(
e
)
{
const
itemEl
=
e
.
target
.
closest
(
"
.
autocomplete
-
item
"
)
;
const
index
=
typeof
itemEl
?
.
dataset
?
.
index
!
=
=
"
undefined
"
?
parseInt
(
itemEl
.
dataset
.
index
10
)
:
null
;
if
(
index
!
=
=
null
)
{
this
.
selectItemAtIndex
(
index
)
;
}
this
.
emit
(
"
popup
-
click
"
)
;
if
(
this
.
onClickCallback
)
{
const
item
=
index
!
=
=
null
?
this
.
items
[
index
]
:
null
;
this
.
onClickCallback
(
e
item
)
;
}
}
async
openPopup
(
anchor
xOffset
=
0
yOffset
=
0
index
options
)
{
if
(
!
anchor
&
&
this
.
input
)
{
anchor
=
this
.
input
;
}
this
.
_activeElement
=
anchor
.
ownerDocument
.
activeElement
;
const
leftBorderSize
=
1
;
if
(
this
.
_pendingShowPromise
)
{
await
this
.
_pendingShowPromise
;
}
this
.
_pendingShowPromise
=
this
.
tooltip
.
show
(
anchor
{
x
:
xOffset
-
this
.
_listPadding
-
leftBorderSize
y
:
yOffset
position
:
this
.
position
}
)
;
await
this
.
_pendingShowPromise
;
this
.
_pendingShowPromise
=
null
;
if
(
this
.
autoSelect
)
{
this
.
selectItemAtIndex
(
index
options
)
;
}
this
.
emit
(
"
popup
-
opened
"
)
;
}
selectItemAtIndex
(
index
options
=
{
}
)
{
const
{
preventSelectCallback
}
=
options
;
if
(
!
Number
.
isInteger
(
index
)
)
{
index
=
0
;
}
const
item
=
this
.
items
[
index
]
;
const
element
=
this
.
elements
.
get
(
item
)
;
const
previousSelected
=
this
.
list
.
querySelector
(
"
.
autocomplete
-
selected
"
)
;
if
(
previousSelected
&
&
previousSelected
!
=
=
element
)
{
previousSelected
.
classList
.
remove
(
"
autocomplete
-
selected
"
)
;
}
if
(
element
&
&
!
element
.
classList
.
contains
(
"
autocomplete
-
selected
"
)
)
{
element
.
classList
.
add
(
"
autocomplete
-
selected
"
)
;
}
if
(
this
.
isOpen
&
&
item
)
{
this
.
_scrollElementIntoViewIfNeeded
(
element
)
;
this
.
_setActiveDescendant
(
element
.
id
)
;
}
else
{
this
.
_clearActiveDescendant
(
)
;
}
this
.
selectedIndex
=
index
;
if
(
this
.
isOpen
&
&
item
&
&
this
.
onSelectCallback
&
&
!
preventSelectCallback
)
{
this
.
onSelectCallback
(
item
)
;
}
}
hidePopup
(
)
{
this
.
_pendingShowPromise
=
null
;
this
.
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
this
.
emit
(
"
popup
-
closed
"
)
;
}
)
;
this
.
_clearActiveDescendant
(
)
;
this
.
_activeElement
=
null
;
this
.
tooltip
.
hide
(
)
;
}
get
isOpen
(
)
{
return
!
!
this
.
_tooltip
&
&
this
.
tooltip
.
isVisible
(
)
;
}
destroy
(
)
{
this
.
_pendingShowPromise
=
null
;
if
(
this
.
isOpen
)
{
this
.
hidePopup
(
)
;
}
if
(
this
.
_list
)
{
this
.
_list
.
removeEventListener
(
"
click
"
this
.
onClick
)
;
this
.
_list
.
remove
(
)
;
this
.
_listClone
.
remove
(
)
;
this
.
_list
=
null
;
}
if
(
this
.
_tooltip
)
{
this
.
_tooltip
.
destroy
(
)
;
this
.
_tooltip
=
null
;
}
if
(
this
.
input
)
{
this
.
input
.
addEventListener
(
"
keydown
"
this
.
onInputKeyDown
)
;
this
.
input
.
addEventListener
(
"
blur
"
this
.
onInputBlur
)
;
this
.
input
=
null
;
}
this
.
_document
=
null
;
}
getItemAtIndex
(
index
)
{
return
this
.
items
[
index
]
;
}
getItems
(
)
{
return
this
.
items
.
slice
(
0
)
;
}
setItems
(
items
selectedIndex
options
)
{
this
.
clearItems
(
)
;
if
(
items
.
length
=
=
=
0
)
{
return
;
}
if
(
!
Number
.
isInteger
(
selectedIndex
)
&
&
this
.
autoSelect
)
{
selectedIndex
=
0
;
}
let
maxLabelLength
=
0
;
const
fragment
=
this
.
_document
.
createDocumentFragment
(
)
;
items
.
forEach
(
(
item
i
)
=
>
{
const
selected
=
selectedIndex
=
=
=
i
;
const
listItem
=
this
.
createListItem
(
item
i
selected
)
;
this
.
items
.
push
(
item
)
;
this
.
elements
.
set
(
item
listItem
)
;
fragment
.
appendChild
(
listItem
)
;
let
{
label
postLabel
count
}
=
item
;
if
(
count
)
{
label
+
=
count
+
"
"
;
}
if
(
postLabel
)
{
label
+
=
postLabel
;
}
maxLabelLength
=
Math
.
max
(
label
.
length
maxLabelLength
)
;
}
)
;
const
fragmentClone
=
fragment
.
cloneNode
(
true
)
;
this
.
list
.
style
.
width
=
maxLabelLength
+
3
+
"
ch
"
;
this
.
list
.
appendChild
(
fragment
)
;
this
.
_listClone
.
appendChild
(
fragmentClone
)
;
this
.
selectItemAtIndex
(
selectedIndex
options
)
;
}
_scrollElementIntoViewIfNeeded
(
element
)
{
const
quads
=
element
.
getBoxQuads
(
{
relativeTo
:
this
.
tooltip
.
panel
createFramesForSuppressedWhitespace
:
false
}
)
;
if
(
!
quads
|
|
!
quads
[
0
]
)
{
return
;
}
const
{
top
height
}
=
quads
[
0
]
.
getBounds
(
)
;
const
containerHeight
=
this
.
tooltip
.
panel
.
getBoundingClientRect
(
)
.
height
;
if
(
top
<
0
)
{
element
.
scrollIntoView
(
true
)
;
}
else
if
(
top
+
height
>
containerHeight
)
{
element
.
scrollIntoView
(
false
)
;
}
}
clearItems
(
)
{
if
(
this
.
_list
)
{
this
.
_list
.
innerHTML
=
"
"
;
}
if
(
this
.
_listClone
)
{
this
.
_listClone
.
innerHTML
=
"
"
;
}
this
.
items
=
[
]
;
this
.
elements
=
new
WeakMap
(
)
;
this
.
selectItemAtIndex
(
-
1
)
;
}
get
selectedItem
(
)
{
return
this
.
items
[
this
.
selectedIndex
]
;
}
set
selectedItem
(
item
)
{
const
index
=
this
.
items
.
indexOf
(
item
)
;
if
(
index
!
=
=
-
1
&
&
this
.
isOpen
)
{
this
.
selectItemAtIndex
(
index
)
;
}
}
_setActiveDescendant
(
id
)
{
if
(
!
this
.
_activeElement
)
{
return
;
}
const
anchorDoc
=
this
.
_activeElement
.
ownerDocument
;
if
(
!
this
.
_listClone
.
parentNode
|
|
this
.
_listClone
.
ownerDocument
!
=
=
anchorDoc
)
{
anchorDoc
.
documentElement
.
appendChild
(
this
.
_listClone
)
;
}
this
.
_activeElement
.
setAttribute
(
"
aria
-
activedescendant
"
id
)
;
}
_clearActiveDescendant
(
)
{
if
(
!
this
.
_activeElement
)
{
return
;
}
this
.
_activeElement
.
removeAttribute
(
"
aria
-
activedescendant
"
)
;
}
createListItem
(
item
index
selected
)
{
const
listItem
=
this
.
_document
.
createElementNS
(
HTML_NS
"
li
"
)
;
listItem
.
setAttribute
(
"
id
"
"
autocomplete
-
item
-
"
+
itemIdCounter
+
+
)
;
listItem
.
classList
.
add
(
"
autocomplete
-
item
"
)
;
if
(
selected
)
{
listItem
.
classList
.
add
(
"
autocomplete
-
selected
"
)
;
}
listItem
.
setAttribute
(
"
data
-
index
"
index
)
;
if
(
this
.
direction
)
{
listItem
.
setAttribute
(
"
dir
"
this
.
direction
)
;
}
const
label
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
label
.
textContent
=
item
.
label
;
label
.
className
=
"
autocomplete
-
value
"
;
if
(
item
.
preLabel
)
{
const
preDesc
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
preDesc
.
textContent
=
item
.
preLabel
;
preDesc
.
className
=
"
initial
-
value
"
;
listItem
.
appendChild
(
preDesc
)
;
label
.
textContent
=
item
.
label
.
slice
(
item
.
preLabel
.
length
)
;
}
listItem
.
appendChild
(
label
)
;
if
(
item
.
postLabel
)
{
const
postDesc
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
postDesc
.
className
=
"
autocomplete
-
postlabel
"
;
postDesc
.
textContent
=
item
.
postLabel
;
if
(
this
.
_isValidColor
(
item
.
postLabel
)
)
{
const
colorSwatch
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
colorSwatch
.
className
=
"
autocomplete
-
swatch
autocomplete
-
colorswatch
"
;
colorSwatch
.
style
.
cssText
=
"
background
-
color
:
"
+
item
.
postLabel
;
postDesc
.
insertBefore
(
colorSwatch
postDesc
.
childNodes
[
0
]
)
;
}
listItem
.
appendChild
(
postDesc
)
;
}
if
(
item
.
count
&
&
item
.
count
>
1
)
{
const
countDesc
=
this
.
_document
.
createElementNS
(
HTML_NS
"
span
"
)
;
countDesc
.
textContent
=
item
.
count
;
countDesc
.
setAttribute
(
"
flex
"
"
1
"
)
;
countDesc
.
className
=
"
autocomplete
-
count
"
;
listItem
.
appendChild
(
countDesc
)
;
}
return
listItem
;
}
get
itemCount
(
)
{
return
this
.
items
.
length
;
}
get
_itemsPerPane
(
)
{
if
(
this
.
items
.
length
)
{
const
listHeight
=
this
.
tooltip
.
panel
.
clientHeight
;
const
element
=
this
.
elements
.
get
(
this
.
items
[
0
]
)
;
const
elementHeight
=
element
.
getBoundingClientRect
(
)
.
height
;
return
Math
.
floor
(
listHeight
/
elementHeight
)
;
}
return
0
;
}
selectNextItem
(
)
{
if
(
this
.
selectedIndex
<
this
.
items
.
length
-
1
)
{
this
.
selectItemAtIndex
(
this
.
selectedIndex
+
1
)
;
}
else
{
this
.
selectItemAtIndex
(
0
)
;
}
return
this
.
selectedItem
;
}
selectPreviousItem
(
)
{
if
(
this
.
selectedIndex
>
0
)
{
this
.
selectItemAtIndex
(
this
.
selectedIndex
-
1
)
;
}
else
{
this
.
selectItemAtIndex
(
this
.
items
.
length
-
1
)
;
}
return
this
.
selectedItem
;
}
selectNextPageItem
(
)
{
const
nextPageIndex
=
this
.
selectedIndex
+
this
.
_itemsPerPane
+
1
;
this
.
selectItemAtIndex
(
Math
.
min
(
nextPageIndex
this
.
itemCount
-
1
)
)
;
return
this
.
selectedItem
;
}
selectPreviousPageItem
(
)
{
const
prevPageIndex
=
this
.
selectedIndex
-
this
.
_itemsPerPane
-
1
;
this
.
selectItemAtIndex
(
Math
.
max
(
prevPageIndex
0
)
)
;
return
this
.
selectedItem
;
}
_isValidColor
(
color
)
{
const
colorObj
=
new
colorUtils
.
CssColor
(
color
)
;
return
colorObj
.
valid
&
&
!
colorObj
.
specialValue
;
}
get
_panel
(
)
{
return
this
.
tooltip
.
panel
;
}
get
_window
(
)
{
return
this
.
_document
.
defaultView
;
}
}
;
module
.
exports
=
AutocompletePopup
;
