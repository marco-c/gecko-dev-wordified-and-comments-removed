"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
Services
=
require
(
"
Services
"
)
;
function
LocalizationHelper
(
stringBundleName
)
{
loader
.
lazyGetter
(
this
"
stringBundle
"
(
)
=
>
Services
.
strings
.
createBundle
(
stringBundleName
)
)
;
loader
.
lazyGetter
(
this
"
ellipsis
"
(
)
=
>
Services
.
prefs
.
getComplexValue
(
"
intl
.
ellipsis
"
Ci
.
nsIPrefLocalizedString
)
.
data
)
;
}
LocalizationHelper
.
prototype
=
{
getStr
:
function
(
name
)
{
return
this
.
stringBundle
.
GetStringFromName
(
name
)
;
}
getFormatStr
:
function
(
name
.
.
.
args
)
{
return
this
.
stringBundle
.
formatStringFromName
(
name
args
args
.
length
)
;
}
getFormatStrWithNumbers
:
function
(
name
.
.
.
args
)
{
let
newArgs
=
args
.
map
(
x
=
>
typeof
x
=
=
"
number
"
?
this
.
numberWithDecimals
(
x
2
)
:
x
)
;
return
this
.
stringBundle
.
formatStringFromName
(
name
newArgs
newArgs
.
length
)
;
}
numberWithDecimals
:
function
(
number
decimals
=
0
)
{
if
(
number
=
=
=
(
number
|
0
)
)
{
return
number
;
}
if
(
isNaN
(
number
)
|
|
number
=
=
=
null
)
{
return
"
0
"
;
}
let
localized
=
number
.
toLocaleString
(
)
;
if
(
!
localized
.
match
(
/
[
^
\
d
]
/
)
)
{
return
localized
;
}
return
number
.
toLocaleString
(
undefined
{
maximumFractionDigits
:
decimals
minimumFractionDigits
:
decimals
}
)
;
}
}
;
function
MultiLocalizationHelper
(
.
.
.
stringBundleNames
)
{
let
instances
=
stringBundleNames
.
map
(
bundle
=
>
new
LocalizationHelper
(
bundle
)
)
;
Object
.
getOwnPropertyNames
(
LocalizationHelper
.
prototype
)
.
map
(
name
=
>
(
{
name
:
name
descriptor
:
Object
.
getOwnPropertyDescriptor
(
LocalizationHelper
.
prototype
name
)
}
)
)
.
filter
(
(
{
descriptor
}
)
=
>
descriptor
.
value
instanceof
Function
)
.
forEach
(
method
=
>
{
this
[
method
.
name
]
=
(
.
.
.
args
)
=
>
{
for
(
let
l10n
of
instances
)
{
try
{
return
method
.
descriptor
.
value
.
apply
(
l10n
args
)
;
}
catch
(
e
)
{
}
}
}
;
}
)
;
}
exports
.
LocalizationHelper
=
LocalizationHelper
;
exports
.
MultiLocalizationHelper
=
MultiLocalizationHelper
;
