"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
loaders
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
commonjs
/
toolkit
/
loader
.
js
"
{
}
)
;
const
{
devtools
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
joinURI
}
=
devtools
.
require
(
"
devtools
/
shared
/
path
"
)
;
const
{
Services
}
=
devtools
.
require
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
const
BROWSER_BASED_DIRS
=
[
"
resource
:
/
/
devtools
/
client
/
jsonview
"
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
"
"
resource
:
/
/
devtools
/
client
/
shared
/
components
"
"
resource
:
/
/
devtools
/
client
/
shared
/
redux
"
]
;
function
BrowserLoader
(
baseURI
window
)
{
const
browserLoaderBuilder
=
new
BrowserLoaderBuilder
(
baseURI
window
)
;
return
{
loader
:
browserLoaderBuilder
.
loader
require
:
browserLoaderBuilder
.
require
}
;
}
function
BrowserLoaderBuilder
(
baseURI
window
)
{
const
loaderOptions
=
devtools
.
require
(
"
loader
/
options
"
)
;
const
dynamicPaths
=
{
}
;
const
componentProxies
=
new
Map
(
)
;
const
hotReloadEnabled
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
loader
.
hotreload
"
)
;
if
(
AppConstants
.
DEBUG
|
|
AppConstants
.
DEBUG_JS_MODULES
)
{
dynamicPaths
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
=
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dev
"
;
}
;
const
opts
=
{
id
:
"
browser
-
loader
"
sharedGlobal
:
true
sandboxPrototype
:
window
paths
:
Object
.
assign
(
{
}
dynamicPaths
loaderOptions
.
paths
)
invisibleToDebugger
:
loaderOptions
.
invisibleToDebugger
requireHook
:
(
id
require
)
=
>
{
const
uri
=
require
.
resolve
(
id
)
;
const
isBrowserDir
=
BROWSER_BASED_DIRS
.
filter
(
dir
=
>
{
return
uri
.
startsWith
(
dir
)
;
}
)
.
length
>
0
;
if
(
!
uri
.
startsWith
(
baseURI
)
&
&
!
isBrowserDir
)
{
return
devtools
.
require
(
uri
)
;
}
return
require
(
uri
)
;
}
globals
:
{
console
:
window
.
console
define
(
factory
)
{
factory
(
this
.
require
this
.
exports
this
.
module
)
;
}
loader
:
{
lazyGetter
:
devtools
.
lazyGetter
lazyImporter
:
devtools
.
lazyImporter
lazyServiceGetter
:
devtools
.
lazyServiceGetter
lazyRequireGetter
:
this
.
lazyRequireGetter
.
bind
(
this
)
}
}
}
;
if
(
hotReloadEnabled
)
{
opts
.
loadModuleHook
=
(
module
require
)
=
>
{
const
{
uri
exports
}
=
module
;
if
(
exports
.
prototype
&
&
exports
.
prototype
.
isReactComponent
)
{
const
{
createProxy
getForceUpdate
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
proxy
"
)
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
if
(
!
componentProxies
.
get
(
uri
)
)
{
const
proxy
=
createProxy
(
exports
)
;
componentProxies
.
set
(
uri
proxy
)
;
module
.
exports
=
proxy
.
get
(
)
;
}
else
{
const
proxy
=
componentProxies
.
get
(
uri
)
;
const
instances
=
proxy
.
update
(
exports
)
;
instances
.
forEach
(
getForceUpdate
(
React
)
)
;
module
.
exports
=
proxy
.
get
(
)
;
}
}
return
exports
;
}
}
const
mainModule
=
loaders
.
Module
(
baseURI
joinURI
(
baseURI
"
main
.
js
"
)
)
;
this
.
loader
=
loaders
.
Loader
(
opts
)
;
this
.
require
=
loaders
.
Require
(
this
.
loader
mainModule
)
;
if
(
hotReloadEnabled
)
{
const
watcher
=
devtools
.
require
(
"
devtools
/
client
/
shared
/
file
-
watcher
"
)
;
const
onFileChanged
=
(
_
fileURI
)
=
>
{
this
.
hotReloadFile
(
window
componentProxies
fileURI
)
;
}
;
watcher
.
on
(
"
file
-
changed
"
onFileChanged
)
;
window
.
addEventListener
(
"
unload
"
(
)
=
>
{
watcher
.
off
(
"
file
-
changed
"
onFileChanged
)
;
}
)
;
}
}
BrowserLoaderBuilder
.
prototype
=
{
lazyRequireGetter
:
function
(
obj
property
module
destructure
)
{
devtools
.
lazyGetter
(
obj
property
(
)
=
>
{
return
destructure
?
this
.
require
(
module
)
[
property
]
:
this
.
require
(
module
|
|
property
)
;
}
)
;
}
clearCache
:
function
(
)
{
Services
.
obs
.
notifyObservers
(
null
"
startupcache
-
invalidate
"
null
)
;
}
hotReloadFile
:
function
(
window
componentProxies
fileURI
)
{
dump
(
"
Hot
reloading
:
"
+
fileURI
+
"
\
n
"
)
;
if
(
fileURI
.
match
(
/
\
.
js
/
)
)
{
const
proxy
=
componentProxies
.
get
(
fileURI
)
;
if
(
proxy
)
{
delete
this
.
loader
.
modules
[
fileURI
]
;
this
.
clearCache
(
)
;
this
.
require
(
fileURI
)
;
}
}
else
if
(
fileURI
.
match
(
/
\
.
css
/
)
)
{
const
links
=
[
.
.
.
window
.
document
.
getElementsByTagNameNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
link
"
)
]
;
links
.
forEach
(
link
=
>
{
if
(
link
.
href
.
indexOf
(
fileURI
)
=
=
=
0
)
{
const
parentNode
=
link
.
parentNode
;
const
newLink
=
window
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
link
"
)
;
newLink
.
rel
=
"
stylesheet
"
;
newLink
.
type
=
"
text
/
css
"
;
newLink
.
href
=
fileURI
+
"
?
s
=
"
+
Math
.
random
(
)
;
parentNode
.
insertBefore
(
newLink
link
)
;
parentNode
.
removeChild
(
link
)
;
}
}
)
;
}
}
}
;
this
.
BrowserLoader
=
BrowserLoader
;
this
.
EXPORTED_SYMBOLS
=
[
"
BrowserLoader
"
]
;
