(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
]
factory
)
;
else
{
var
a
=
factory
(
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
typeof
self
!
=
=
'
undefined
'
?
self
:
this
function
(
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
{
return
installedModules
[
moduleId
]
.
exports
;
}
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
389
)
;
}
)
(
{
104
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
generatedToOriginalId
}
=
__webpack_require__
(
64
)
;
const
sourceMapRequests
=
new
Map
(
)
;
function
clearSourceMaps
(
)
{
sourceMapRequests
.
clear
(
)
;
}
function
getSourceMapWithMetadata
(
generatedSourceId
)
{
return
sourceMapRequests
.
get
(
generatedSourceId
)
;
}
function
getSourceMap
(
generatedSourceId
)
{
const
request
=
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
request
)
{
return
null
;
}
return
request
.
then
(
result
=
>
result
?
result
.
map
:
null
)
;
}
function
setSourceMap
(
generatedId
request
)
{
sourceMapRequests
.
set
(
generatedId
request
.
then
(
map
=
>
{
if
(
!
map
|
|
!
map
.
sources
)
{
return
null
;
}
const
urlsById
=
new
Map
(
)
;
const
sources
=
[
]
;
for
(
const
url
of
map
.
sources
)
{
const
id
=
generatedToOriginalId
(
generatedId
url
)
;
urlsById
.
set
(
id
url
)
;
sources
.
push
(
{
id
url
}
)
;
}
return
{
map
urlsById
sources
}
;
}
)
)
;
}
module
.
exports
=
{
clearSourceMaps
getSourceMapWithMetadata
getSourceMap
setSourceMap
}
;
}
)
105
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
crypt
=
__webpack_require__
(
106
)
utf8
=
__webpack_require__
(
36
)
.
utf8
isBuffer
=
__webpack_require__
(
107
)
bin
=
__webpack_require__
(
36
)
.
bin
md5
=
function
(
message
options
)
{
if
(
message
.
constructor
=
=
String
)
if
(
options
&
&
options
.
encoding
=
=
=
'
binary
'
)
message
=
bin
.
stringToBytes
(
message
)
;
else
message
=
utf8
.
stringToBytes
(
message
)
;
else
if
(
isBuffer
(
message
)
)
message
=
Array
.
prototype
.
slice
.
call
(
message
0
)
;
else
if
(
!
Array
.
isArray
(
message
)
)
message
=
message
.
toString
(
)
;
var
m
=
crypt
.
bytesToWords
(
message
)
l
=
message
.
length
*
8
a
=
1732584193
b
=
-
271733879
c
=
-
1732584194
d
=
271733878
;
for
(
var
i
=
0
;
i
<
m
.
length
;
i
+
+
)
{
m
[
i
]
=
(
(
m
[
i
]
<
<
8
)
|
(
m
[
i
]
>
>
>
24
)
)
&
0x00FF00FF
|
(
(
m
[
i
]
<
<
24
)
|
(
m
[
i
]
>
>
>
8
)
)
&
0xFF00FF00
;
}
m
[
l
>
>
>
5
]
|
=
0x80
<
<
(
l
%
32
)
;
m
[
(
(
(
l
+
64
)
>
>
>
9
)
<
<
4
)
+
14
]
=
l
;
var
FF
=
md5
.
_ff
GG
=
md5
.
_gg
HH
=
md5
.
_hh
II
=
md5
.
_ii
;
for
(
var
i
=
0
;
i
<
m
.
length
;
i
+
=
16
)
{
var
aa
=
a
bb
=
b
cc
=
c
dd
=
d
;
a
=
FF
(
a
b
c
d
m
[
i
+
0
]
7
-
680876936
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
1
]
12
-
389564586
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
2
]
17
606105819
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
3
]
22
-
1044525330
)
;
a
=
FF
(
a
b
c
d
m
[
i
+
4
]
7
-
176418897
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
5
]
12
1200080426
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
6
]
17
-
1473231341
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
7
]
22
-
45705983
)
;
a
=
FF
(
a
b
c
d
m
[
i
+
8
]
7
1770035416
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
9
]
12
-
1958414417
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
10
]
17
-
42063
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
11
]
22
-
1990404162
)
;
a
=
FF
(
a
b
c
d
m
[
i
+
12
]
7
1804603682
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
13
]
12
-
40341101
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
14
]
17
-
1502002290
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
15
]
22
1236535329
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
1
]
5
-
165796510
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
6
]
9
-
1069501632
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
11
]
14
643717713
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
0
]
20
-
373897302
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
5
]
5
-
701558691
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
10
]
9
38016083
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
15
]
14
-
660478335
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
4
]
20
-
405537848
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
9
]
5
568446438
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
14
]
9
-
1019803690
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
3
]
14
-
187363961
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
8
]
20
1163531501
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
13
]
5
-
1444681467
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
2
]
9
-
51403784
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
7
]
14
1735328473
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
12
]
20
-
1926607734
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
5
]
4
-
378558
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
8
]
11
-
2022574463
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
11
]
16
1839030562
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
14
]
23
-
35309556
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
1
]
4
-
1530992060
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
4
]
11
1272893353
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
7
]
16
-
155497632
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
10
]
23
-
1094730640
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
13
]
4
681279174
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
0
]
11
-
358537222
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
3
]
16
-
722521979
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
6
]
23
76029189
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
9
]
4
-
640364487
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
12
]
11
-
421815835
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
15
]
16
530742520
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
2
]
23
-
995338651
)
;
a
=
II
(
a
b
c
d
m
[
i
+
0
]
6
-
198630844
)
;
d
=
II
(
d
a
b
c
m
[
i
+
7
]
10
1126891415
)
;
c
=
II
(
c
d
a
b
m
[
i
+
14
]
15
-
1416354905
)
;
b
=
II
(
b
c
d
a
m
[
i
+
5
]
21
-
57434055
)
;
a
=
II
(
a
b
c
d
m
[
i
+
12
]
6
1700485571
)
;
d
=
II
(
d
a
b
c
m
[
i
+
3
]
10
-
1894986606
)
;
c
=
II
(
c
d
a
b
m
[
i
+
10
]
15
-
1051523
)
;
b
=
II
(
b
c
d
a
m
[
i
+
1
]
21
-
2054922799
)
;
a
=
II
(
a
b
c
d
m
[
i
+
8
]
6
1873313359
)
;
d
=
II
(
d
a
b
c
m
[
i
+
15
]
10
-
30611744
)
;
c
=
II
(
c
d
a
b
m
[
i
+
6
]
15
-
1560198380
)
;
b
=
II
(
b
c
d
a
m
[
i
+
13
]
21
1309151649
)
;
a
=
II
(
a
b
c
d
m
[
i
+
4
]
6
-
145523070
)
;
d
=
II
(
d
a
b
c
m
[
i
+
11
]
10
-
1120210379
)
;
c
=
II
(
c
d
a
b
m
[
i
+
2
]
15
718787259
)
;
b
=
II
(
b
c
d
a
m
[
i
+
9
]
21
-
343485551
)
;
a
=
(
a
+
aa
)
>
>
>
0
;
b
=
(
b
+
bb
)
>
>
>
0
;
c
=
(
c
+
cc
)
>
>
>
0
;
d
=
(
d
+
dd
)
>
>
>
0
;
}
return
crypt
.
endian
(
[
a
b
c
d
]
)
;
}
;
md5
.
_ff
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
b
&
c
|
~
b
&
d
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_gg
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
b
&
d
|
c
&
~
d
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_hh
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
b
^
c
^
d
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_ii
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
c
^
(
b
|
~
d
)
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_blocksize
=
16
;
md5
.
_digestsize
=
16
;
module
.
exports
=
function
(
message
options
)
{
if
(
message
=
=
=
undefined
|
|
message
=
=
=
null
)
throw
new
Error
(
'
Illegal
argument
'
+
message
)
;
var
digestbytes
=
crypt
.
wordsToBytes
(
md5
(
message
options
)
)
;
return
options
&
&
options
.
asBytes
?
digestbytes
:
options
&
&
options
.
asString
?
bin
.
bytesToString
(
digestbytes
)
:
crypt
.
bytesToHex
(
digestbytes
)
;
}
;
}
)
(
)
;
}
)
106
:
(
function
(
module
exports
)
{
(
function
(
)
{
var
base64map
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
crypt
=
{
rotl
:
function
(
n
b
)
{
return
(
n
<
<
b
)
|
(
n
>
>
>
(
32
-
b
)
)
;
}
rotr
:
function
(
n
b
)
{
return
(
n
<
<
(
32
-
b
)
)
|
(
n
>
>
>
b
)
;
}
endian
:
function
(
n
)
{
if
(
n
.
constructor
=
=
Number
)
{
return
crypt
.
rotl
(
n
8
)
&
0x00FF00FF
|
crypt
.
rotl
(
n
24
)
&
0xFF00FF00
;
}
for
(
var
i
=
0
;
i
<
n
.
length
;
i
+
+
)
n
[
i
]
=
crypt
.
endian
(
n
[
i
]
)
;
return
n
;
}
randomBytes
:
function
(
n
)
{
for
(
var
bytes
=
[
]
;
n
>
0
;
n
-
-
)
bytes
.
push
(
Math
.
floor
(
Math
.
random
(
)
*
256
)
)
;
return
bytes
;
}
bytesToWords
:
function
(
bytes
)
{
for
(
var
words
=
[
]
i
=
0
b
=
0
;
i
<
bytes
.
length
;
i
+
+
b
+
=
8
)
words
[
b
>
>
>
5
]
|
=
bytes
[
i
]
<
<
(
24
-
b
%
32
)
;
return
words
;
}
wordsToBytes
:
function
(
words
)
{
for
(
var
bytes
=
[
]
b
=
0
;
b
<
words
.
length
*
32
;
b
+
=
8
)
bytes
.
push
(
(
words
[
b
>
>
>
5
]
>
>
>
(
24
-
b
%
32
)
)
&
0xFF
)
;
return
bytes
;
}
bytesToHex
:
function
(
bytes
)
{
for
(
var
hex
=
[
]
i
=
0
;
i
<
bytes
.
length
;
i
+
+
)
{
hex
.
push
(
(
bytes
[
i
]
>
>
>
4
)
.
toString
(
16
)
)
;
hex
.
push
(
(
bytes
[
i
]
&
0xF
)
.
toString
(
16
)
)
;
}
return
hex
.
join
(
'
'
)
;
}
hexToBytes
:
function
(
hex
)
{
for
(
var
bytes
=
[
]
c
=
0
;
c
<
hex
.
length
;
c
+
=
2
)
bytes
.
push
(
parseInt
(
hex
.
substr
(
c
2
)
16
)
)
;
return
bytes
;
}
bytesToBase64
:
function
(
bytes
)
{
for
(
var
base64
=
[
]
i
=
0
;
i
<
bytes
.
length
;
i
+
=
3
)
{
var
triplet
=
(
bytes
[
i
]
<
<
16
)
|
(
bytes
[
i
+
1
]
<
<
8
)
|
bytes
[
i
+
2
]
;
for
(
var
j
=
0
;
j
<
4
;
j
+
+
)
if
(
i
*
8
+
j
*
6
<
=
bytes
.
length
*
8
)
base64
.
push
(
base64map
.
charAt
(
(
triplet
>
>
>
6
*
(
3
-
j
)
)
&
0x3F
)
)
;
else
base64
.
push
(
'
=
'
)
;
}
return
base64
.
join
(
'
'
)
;
}
base64ToBytes
:
function
(
base64
)
{
base64
=
base64
.
replace
(
/
[
^
A
-
Z0
-
9
+
\
/
]
/
ig
'
'
)
;
for
(
var
bytes
=
[
]
i
=
0
imod4
=
0
;
i
<
base64
.
length
;
imod4
=
+
+
i
%
4
)
{
if
(
imod4
=
=
0
)
continue
;
bytes
.
push
(
(
(
base64map
.
indexOf
(
base64
.
charAt
(
i
-
1
)
)
&
(
Math
.
pow
(
2
-
2
*
imod4
+
8
)
-
1
)
)
<
<
(
imod4
*
2
)
)
|
(
base64map
.
indexOf
(
base64
.
charAt
(
i
)
)
>
>
>
(
6
-
imod4
*
2
)
)
)
;
}
return
bytes
;
}
}
;
module
.
exports
=
crypt
;
}
)
(
)
;
}
)
107
:
(
function
(
module
exports
)
{
module
.
exports
=
function
(
obj
)
{
return
obj
!
=
null
&
&
(
isBuffer
(
obj
)
|
|
isSlowBuffer
(
obj
)
|
|
!
!
obj
.
_isBuffer
)
}
function
isBuffer
(
obj
)
{
return
!
!
obj
.
constructor
&
&
typeof
obj
.
constructor
.
isBuffer
=
=
=
'
function
'
&
&
obj
.
constructor
.
isBuffer
(
obj
)
}
function
isSlowBuffer
(
obj
)
{
return
typeof
obj
.
readFloatLE
=
=
=
'
function
'
&
&
typeof
obj
.
slice
=
=
=
'
function
'
&
&
isBuffer
(
obj
.
slice
(
0
0
)
)
}
}
)
13
:
(
function
(
module
exports
)
{
function
networkRequest
(
url
opts
)
{
return
fetch
(
url
{
cache
:
opts
.
loadFromCache
?
"
default
"
:
"
no
-
cache
"
}
)
.
then
(
res
=
>
{
if
(
res
.
status
>
=
200
&
&
res
.
status
<
300
)
{
if
(
res
.
headers
.
get
(
"
Content
-
Type
"
)
=
=
=
"
application
/
wasm
"
)
{
return
res
.
arrayBuffer
(
)
.
then
(
buffer
=
>
(
{
content
:
buffer
isDwarf
:
true
}
)
)
;
}
return
res
.
text
(
)
.
then
(
text
=
>
(
{
content
:
text
}
)
)
;
}
return
Promise
.
reject
(
request
failed
with
status
{
res
.
status
}
)
;
}
)
;
}
module
.
exports
=
networkRequest
;
}
)
14
:
(
function
(
module
exports
)
{
function
WorkerDispatcher
(
)
{
this
.
msgId
=
1
;
this
.
worker
=
null
;
}
WorkerDispatcher
.
prototype
=
{
start
(
url
win
=
window
)
{
this
.
worker
=
new
win
.
Worker
(
url
)
;
this
.
worker
.
onerror
=
err
=
>
{
console
.
error
(
Error
in
worker
{
url
}
err
.
message
)
;
}
;
}
stop
(
)
{
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
terminate
(
)
;
this
.
worker
=
null
;
}
task
(
method
{
queue
=
false
}
=
{
}
)
{
const
calls
=
[
]
;
const
push
=
args
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
queue
&
&
calls
.
length
=
=
=
0
)
{
Promise
.
resolve
(
)
.
then
(
flush
)
;
}
calls
.
push
(
[
args
resolve
reject
]
)
;
if
(
!
queue
)
{
flush
(
)
;
}
}
)
;
}
;
const
flush
=
(
)
=
>
{
const
items
=
calls
.
slice
(
)
;
calls
.
length
=
0
;
if
(
!
this
.
worker
)
{
return
;
}
const
id
=
this
.
msgId
+
+
;
this
.
worker
.
postMessage
(
{
id
method
calls
:
items
.
map
(
item
=
>
item
[
0
]
)
}
)
;
const
listener
=
(
{
data
:
result
}
)
=
>
{
if
(
result
.
id
!
=
=
id
)
{
return
;
}
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
removeEventListener
(
"
message
"
listener
)
;
result
.
results
.
forEach
(
(
resultData
i
)
=
>
{
const
[
resolve
reject
]
=
items
[
i
]
;
if
(
resultData
.
error
)
{
const
err
=
new
Error
(
resultData
.
message
)
;
err
.
metadata
=
resultData
.
metadata
;
reject
(
err
)
;
}
else
{
resolve
(
resultData
.
response
)
;
}
}
)
;
}
;
this
.
worker
.
addEventListener
(
"
message
"
listener
)
;
}
;
return
(
.
.
.
args
)
=
>
push
(
args
)
;
}
invoke
(
method
.
.
.
args
)
{
return
this
.
task
(
method
)
(
.
.
.
args
)
;
}
}
;
function
workerHandler
(
publicInterface
)
{
return
function
(
msg
)
{
const
{
id
method
calls
}
=
msg
.
data
;
Promise
.
all
(
calls
.
map
(
args
=
>
{
try
{
const
response
=
publicInterface
[
method
]
.
apply
(
undefined
args
)
;
if
(
response
instanceof
Promise
)
{
return
response
.
then
(
val
=
>
(
{
response
:
val
}
)
err
=
>
asErrorMessage
(
err
)
)
;
}
return
{
response
}
;
}
catch
(
error
)
{
return
asErrorMessage
(
error
)
;
}
}
)
)
.
then
(
results
=
>
{
self
.
postMessage
(
{
id
results
}
)
;
}
)
;
}
;
}
function
asErrorMessage
(
error
)
{
if
(
typeof
error
=
=
=
"
object
"
&
&
error
&
&
"
message
"
in
error
)
{
return
{
error
:
true
message
:
error
.
message
metadata
:
error
.
metadata
}
;
}
return
{
error
:
true
message
:
error
=
=
null
?
error
:
error
.
toString
(
)
metadata
:
undefined
}
;
}
module
.
exports
=
{
WorkerDispatcher
workerHandler
}
;
}
)
171
:
(
function
(
module
exports
__webpack_require__
)
{
const
base64VLQ
=
__webpack_require__
(
172
)
;
const
util
=
__webpack_require__
(
61
)
;
const
ArraySet
=
__webpack_require__
(
177
)
.
ArraySet
;
const
MappingList
=
__webpack_require__
(
402
)
.
MappingList
;
class
SourceMapGenerator
{
constructor
(
aArgs
)
{
if
(
!
aArgs
)
{
aArgs
=
{
}
;
}
this
.
_file
=
util
.
getArg
(
aArgs
"
file
"
null
)
;
this
.
_sourceRoot
=
util
.
getArg
(
aArgs
"
sourceRoot
"
null
)
;
this
.
_skipValidation
=
util
.
getArg
(
aArgs
"
skipValidation
"
false
)
;
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
this
.
_mappings
=
new
MappingList
(
)
;
this
.
_sourcesContents
=
null
;
}
static
fromSourceMap
(
aSourceMapConsumer
)
{
const
sourceRoot
=
aSourceMapConsumer
.
sourceRoot
;
const
generator
=
new
SourceMapGenerator
(
{
file
:
aSourceMapConsumer
.
file
sourceRoot
}
)
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
const
newMapping
=
{
generated
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
generatedColumn
}
}
;
if
(
mapping
.
source
!
=
null
)
{
newMapping
.
source
=
mapping
.
source
;
if
(
sourceRoot
!
=
null
)
{
newMapping
.
source
=
util
.
relative
(
sourceRoot
newMapping
.
source
)
;
}
newMapping
.
original
=
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
;
if
(
mapping
.
name
!
=
null
)
{
newMapping
.
name
=
mapping
.
name
;
}
}
generator
.
addMapping
(
newMapping
)
;
}
)
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
let
sourceRelative
=
sourceFile
;
if
(
sourceRoot
!
=
=
null
)
{
sourceRelative
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
if
(
!
generator
.
_sources
.
has
(
sourceRelative
)
)
{
generator
.
_sources
.
add
(
sourceRelative
)
;
}
const
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
generator
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
generator
;
}
addMapping
(
aArgs
)
{
const
generated
=
util
.
getArg
(
aArgs
"
generated
"
)
;
const
original
=
util
.
getArg
(
aArgs
"
original
"
null
)
;
let
source
=
util
.
getArg
(
aArgs
"
source
"
null
)
;
let
name
=
util
.
getArg
(
aArgs
"
name
"
null
)
;
if
(
!
this
.
_skipValidation
)
{
this
.
_validateMapping
(
generated
original
source
name
)
;
}
if
(
source
!
=
null
)
{
source
=
String
(
source
)
;
if
(
!
this
.
_sources
.
has
(
source
)
)
{
this
.
_sources
.
add
(
source
)
;
}
}
if
(
name
!
=
null
)
{
name
=
String
(
name
)
;
if
(
!
this
.
_names
.
has
(
name
)
)
{
this
.
_names
.
add
(
name
)
;
}
}
this
.
_mappings
.
add
(
{
generatedLine
:
generated
.
line
generatedColumn
:
generated
.
column
originalLine
:
original
!
=
null
&
&
original
.
line
originalColumn
:
original
!
=
null
&
&
original
.
column
source
name
}
)
;
}
setSourceContent
(
aSourceFile
aSourceContent
)
{
let
source
=
aSourceFile
;
if
(
this
.
_sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
_sourceRoot
source
)
;
}
if
(
aSourceContent
!
=
null
)
{
if
(
!
this
.
_sourcesContents
)
{
this
.
_sourcesContents
=
Object
.
create
(
null
)
;
}
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
=
aSourceContent
;
}
else
if
(
this
.
_sourcesContents
)
{
delete
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
;
if
(
Object
.
keys
(
this
.
_sourcesContents
)
.
length
=
=
=
0
)
{
this
.
_sourcesContents
=
null
;
}
}
}
applySourceMap
(
aSourceMapConsumer
aSourceFile
aSourceMapPath
)
{
let
sourceFile
=
aSourceFile
;
if
(
aSourceFile
=
=
null
)
{
if
(
aSourceMapConsumer
.
file
=
=
null
)
{
throw
new
Error
(
"
SourceMapGenerator
.
prototype
.
applySourceMap
requires
either
an
explicit
source
file
"
+
'
or
the
source
map
\
'
s
"
file
"
property
.
Both
were
omitted
.
'
)
;
}
sourceFile
=
aSourceMapConsumer
.
file
;
}
const
sourceRoot
=
this
.
_sourceRoot
;
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
const
newSources
=
this
.
_mappings
.
toArray
(
)
.
length
>
0
?
new
ArraySet
(
)
:
this
.
_sources
;
const
newNames
=
new
ArraySet
(
)
;
this
.
_mappings
.
unsortedForEach
(
function
(
mapping
)
{
if
(
mapping
.
source
=
=
=
sourceFile
&
&
mapping
.
originalLine
!
=
null
)
{
const
original
=
aSourceMapConsumer
.
originalPositionFor
(
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
)
;
if
(
original
.
source
!
=
null
)
{
mapping
.
source
=
original
.
source
;
if
(
aSourceMapPath
!
=
null
)
{
mapping
.
source
=
util
.
join
(
aSourceMapPath
mapping
.
source
)
;
}
if
(
sourceRoot
!
=
null
)
{
mapping
.
source
=
util
.
relative
(
sourceRoot
mapping
.
source
)
;
}
mapping
.
originalLine
=
original
.
line
;
mapping
.
originalColumn
=
original
.
column
;
if
(
original
.
name
!
=
null
)
{
mapping
.
name
=
original
.
name
;
}
}
}
const
source
=
mapping
.
source
;
if
(
source
!
=
null
&
&
!
newSources
.
has
(
source
)
)
{
newSources
.
add
(
source
)
;
}
const
name
=
mapping
.
name
;
if
(
name
!
=
null
&
&
!
newNames
.
has
(
name
)
)
{
newNames
.
add
(
name
)
;
}
}
this
)
;
this
.
_sources
=
newSources
;
this
.
_names
=
newNames
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
srcFile
)
{
const
content
=
aSourceMapConsumer
.
sourceContentFor
(
srcFile
)
;
if
(
content
!
=
null
)
{
if
(
aSourceMapPath
!
=
null
)
{
srcFile
=
util
.
join
(
aSourceMapPath
srcFile
)
;
}
if
(
sourceRoot
!
=
null
)
{
srcFile
=
util
.
relative
(
sourceRoot
srcFile
)
;
}
this
.
setSourceContent
(
srcFile
content
)
;
}
}
this
)
;
}
_validateMapping
(
aGenerated
aOriginal
aSource
aName
)
{
if
(
aOriginal
&
&
typeof
aOriginal
.
line
!
=
=
"
number
"
&
&
typeof
aOriginal
.
column
!
=
=
"
number
"
)
{
throw
new
Error
(
"
original
.
line
and
original
.
column
are
not
numbers
-
-
you
probably
meant
to
omit
"
+
"
the
original
mapping
entirely
and
only
map
the
generated
position
.
If
so
pass
"
+
"
null
for
the
original
mapping
instead
of
an
object
with
empty
or
null
values
.
"
)
;
}
if
(
aGenerated
&
&
"
line
"
in
aGenerated
&
&
"
column
"
in
aGenerated
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
!
aOriginal
&
&
!
aSource
&
&
!
aName
)
{
}
else
if
(
aGenerated
&
&
"
line
"
in
aGenerated
&
&
"
column
"
in
aGenerated
&
&
aOriginal
&
&
"
line
"
in
aOriginal
&
&
"
column
"
in
aOriginal
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
aOriginal
.
line
>
0
&
&
aOriginal
.
column
>
=
0
&
&
aSource
)
{
}
else
{
throw
new
Error
(
"
Invalid
mapping
:
"
+
JSON
.
stringify
(
{
generated
:
aGenerated
source
:
aSource
original
:
aOriginal
name
:
aName
}
)
)
;
}
}
_serializeMappings
(
)
{
let
previousGeneratedColumn
=
0
;
let
previousGeneratedLine
=
1
;
let
previousOriginalColumn
=
0
;
let
previousOriginalLine
=
0
;
let
previousName
=
0
;
let
previousSource
=
0
;
let
result
=
"
"
;
let
next
;
let
mapping
;
let
nameIdx
;
let
sourceIdx
;
const
mappings
=
this
.
_mappings
.
toArray
(
)
;
for
(
let
i
=
0
len
=
mappings
.
length
;
i
<
len
;
i
+
+
)
{
mapping
=
mappings
[
i
]
;
next
=
"
"
;
if
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
previousGeneratedColumn
=
0
;
while
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
next
+
=
"
;
"
;
previousGeneratedLine
+
+
;
}
}
else
if
(
i
>
0
)
{
if
(
!
util
.
compareByGeneratedPositionsInflated
(
mapping
mappings
[
i
-
1
]
)
)
{
continue
;
}
next
+
=
"
"
;
}
next
+
=
base64VLQ
.
encode
(
mapping
.
generatedColumn
-
previousGeneratedColumn
)
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
mapping
.
source
!
=
null
)
{
sourceIdx
=
this
.
_sources
.
indexOf
(
mapping
.
source
)
;
next
+
=
base64VLQ
.
encode
(
sourceIdx
-
previousSource
)
;
previousSource
=
sourceIdx
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalLine
-
1
-
previousOriginalLine
)
;
previousOriginalLine
=
mapping
.
originalLine
-
1
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalColumn
-
previousOriginalColumn
)
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
mapping
.
name
!
=
null
)
{
nameIdx
=
this
.
_names
.
indexOf
(
mapping
.
name
)
;
next
+
=
base64VLQ
.
encode
(
nameIdx
-
previousName
)
;
previousName
=
nameIdx
;
}
}
result
+
=
next
;
}
return
result
;
}
_generateSourcesContent
(
aSources
aSourceRoot
)
{
return
aSources
.
map
(
function
(
source
)
{
if
(
!
this
.
_sourcesContents
)
{
return
null
;
}
if
(
aSourceRoot
!
=
null
)
{
source
=
util
.
relative
(
aSourceRoot
source
)
;
}
const
key
=
util
.
toSetString
(
source
)
;
return
Object
.
prototype
.
hasOwnProperty
.
call
(
this
.
_sourcesContents
key
)
?
this
.
_sourcesContents
[
key
]
:
null
;
}
this
)
;
}
toJSON
(
)
{
const
map
=
{
version
:
this
.
_version
sources
:
this
.
_sources
.
toArray
(
)
names
:
this
.
_names
.
toArray
(
)
mappings
:
this
.
_serializeMappings
(
)
}
;
if
(
this
.
_file
!
=
null
)
{
map
.
file
=
this
.
_file
;
}
if
(
this
.
_sourceRoot
!
=
null
)
{
map
.
sourceRoot
=
this
.
_sourceRoot
;
}
if
(
this
.
_sourcesContents
)
{
map
.
sourcesContent
=
this
.
_generateSourcesContent
(
map
.
sources
map
.
sourceRoot
)
;
}
return
map
;
}
toString
(
)
{
return
JSON
.
stringify
(
this
.
toJSON
(
)
)
;
}
}
SourceMapGenerator
.
prototype
.
_version
=
3
;
exports
.
SourceMapGenerator
=
SourceMapGenerator
;
}
)
172
:
(
function
(
module
exports
__webpack_require__
)
{
const
base64
=
__webpack_require__
(
392
)
;
const
VLQ_BASE_SHIFT
=
5
;
const
VLQ_BASE
=
1
<
<
VLQ_BASE_SHIFT
;
const
VLQ_BASE_MASK
=
VLQ_BASE
-
1
;
const
VLQ_CONTINUATION_BIT
=
VLQ_BASE
;
function
toVLQSigned
(
aValue
)
{
return
aValue
<
0
?
(
(
-
aValue
)
<
<
1
)
+
1
:
(
aValue
<
<
1
)
+
0
;
}
function
fromVLQSigned
(
aValue
)
{
const
isNegative
=
(
aValue
&
1
)
=
=
=
1
;
const
shifted
=
aValue
>
>
1
;
return
isNegative
?
-
shifted
:
shifted
;
}
exports
.
encode
=
function
base64VLQ_encode
(
aValue
)
{
let
encoded
=
"
"
;
let
digit
;
let
vlq
=
toVLQSigned
(
aValue
)
;
do
{
digit
=
vlq
&
VLQ_BASE_MASK
;
vlq
>
>
>
=
VLQ_BASE_SHIFT
;
if
(
vlq
>
0
)
{
digit
|
=
VLQ_CONTINUATION_BIT
;
}
encoded
+
=
base64
.
encode
(
digit
)
;
}
while
(
vlq
>
0
)
;
return
encoded
;
}
;
}
)
177
:
(
function
(
module
exports
)
{
class
ArraySet
{
constructor
(
)
{
this
.
_array
=
[
]
;
this
.
_set
=
new
Map
(
)
;
}
static
fromArray
(
aArray
aAllowDuplicates
)
{
const
set
=
new
ArraySet
(
)
;
for
(
let
i
=
0
len
=
aArray
.
length
;
i
<
len
;
i
+
+
)
{
set
.
add
(
aArray
[
i
]
aAllowDuplicates
)
;
}
return
set
;
}
size
(
)
{
return
this
.
_set
.
size
;
}
add
(
aStr
aAllowDuplicates
)
{
const
isDuplicate
=
this
.
has
(
aStr
)
;
const
idx
=
this
.
_array
.
length
;
if
(
!
isDuplicate
|
|
aAllowDuplicates
)
{
this
.
_array
.
push
(
aStr
)
;
}
if
(
!
isDuplicate
)
{
this
.
_set
.
set
(
aStr
idx
)
;
}
}
has
(
aStr
)
{
return
this
.
_set
.
has
(
aStr
)
;
}
indexOf
(
aStr
)
{
const
idx
=
this
.
_set
.
get
(
aStr
)
;
if
(
idx
>
=
0
)
{
return
idx
;
}
throw
new
Error
(
'
"
'
+
aStr
+
'
"
is
not
in
the
set
.
'
)
;
}
at
(
aIdx
)
{
if
(
aIdx
>
=
0
&
&
aIdx
<
this
.
_array
.
length
)
{
return
this
.
_array
[
aIdx
]
;
}
throw
new
Error
(
"
No
element
indexed
by
"
+
aIdx
)
;
}
toArray
(
)
{
return
this
.
_array
.
slice
(
)
;
}
}
exports
.
ArraySet
=
ArraySet
;
}
)
178
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
let
mappingsWasm
=
null
;
module
.
exports
=
function
readWasm
(
)
{
if
(
typeof
mappingsWasm
=
=
=
"
string
"
)
{
return
fetch
(
mappingsWasm
)
.
then
(
response
=
>
response
.
arrayBuffer
(
)
)
;
}
if
(
mappingsWasm
instanceof
ArrayBuffer
)
{
return
Promise
.
resolve
(
mappingsWasm
)
;
}
throw
new
Error
(
"
You
must
provide
the
string
URL
or
ArrayBuffer
contents
"
+
"
of
lib
/
mappings
.
wasm
by
calling
"
+
"
SourceMapConsumer
.
initialize
(
{
'
lib
/
mappings
.
wasm
'
:
.
.
.
}
)
"
+
"
before
using
SourceMapConsumer
"
)
;
}
;
module
.
exports
.
initialize
=
input
=
>
{
mappingsWasm
=
input
;
}
;
}
)
179
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
SourceMapConsumer
}
=
__webpack_require__
(
60
)
;
async
function
createConsumer
(
map
sourceMapUrl
)
{
return
new
SourceMapConsumer
(
map
sourceMapUrl
)
;
}
module
.
exports
=
{
createConsumer
}
;
}
)
36
:
(
function
(
module
exports
)
{
var
charenc
=
{
utf8
:
{
stringToBytes
:
function
(
str
)
{
return
charenc
.
bin
.
stringToBytes
(
unescape
(
encodeURIComponent
(
str
)
)
)
;
}
bytesToString
:
function
(
bytes
)
{
return
decodeURIComponent
(
escape
(
charenc
.
bin
.
bytesToString
(
bytes
)
)
)
;
}
}
bin
:
{
stringToBytes
:
function
(
str
)
{
for
(
var
bytes
=
[
]
i
=
0
;
i
<
str
.
length
;
i
+
+
)
bytes
.
push
(
str
.
charCodeAt
(
i
)
&
0xFF
)
;
return
bytes
;
}
bytesToString
:
function
(
bytes
)
{
for
(
var
str
=
[
]
i
=
0
;
i
<
bytes
.
length
;
i
+
+
)
str
.
push
(
String
.
fromCharCode
(
bytes
[
i
]
)
)
;
return
str
.
join
(
'
'
)
;
}
}
}
;
module
.
exports
=
charenc
;
}
)
389
:
(
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
390
)
;
}
)
390
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
getOriginalURLs
hasOriginalURL
getOriginalRanges
getGeneratedRanges
getGeneratedLocation
getAllGeneratedLocations
getOriginalLocation
getOriginalLocations
getOriginalSourceText
getGeneratedRangesForOriginal
getFileGeneratedRange
clearSourceMaps
applySourceMap
}
=
__webpack_require__
(
391
)
;
const
{
getOriginalStackFrames
}
=
__webpack_require__
(
411
)
;
const
{
setAssetRootURL
}
=
__webpack_require__
(
515
)
;
const
{
workerUtils
:
{
workerHandler
}
}
=
__webpack_require__
(
7
)
;
self
.
onmessage
=
workerHandler
(
{
setAssetRootURL
getOriginalURLs
hasOriginalURL
getOriginalRanges
getGeneratedRanges
getGeneratedLocation
getAllGeneratedLocations
getOriginalLocation
getOriginalLocations
getOriginalSourceText
getOriginalStackFrames
getGeneratedRangesForOriginal
getFileGeneratedRange
applySourceMap
clearSourceMaps
}
)
;
}
)
391
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
networkRequest
}
=
__webpack_require__
(
7
)
;
const
{
SourceMapConsumer
SourceMapGenerator
}
=
__webpack_require__
(
60
)
;
const
{
createConsumer
}
=
__webpack_require__
(
179
)
;
const
assert
=
__webpack_require__
(
407
)
;
const
{
fetchSourceMap
hasOriginalURL
clearOriginalURLs
}
=
__webpack_require__
(
408
)
;
const
{
getSourceMap
getSourceMapWithMetadata
setSourceMap
clearSourceMaps
:
clearSourceMapsRequests
}
=
__webpack_require__
(
104
)
;
const
{
originalToGeneratedId
generatedToOriginalId
isGeneratedId
isOriginalId
getContentType
}
=
__webpack_require__
(
64
)
;
const
{
clearWasmXScopes
}
=
__webpack_require__
(
510
)
;
async
function
getOriginalURLs
(
generatedSource
)
{
await
fetchSourceMap
(
generatedSource
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSource
.
id
)
;
return
data
?
data
.
sources
:
null
;
}
const
COMPUTED_SPANS
=
new
WeakSet
(
)
;
const
SOURCE_MAPPINGS
=
new
WeakMap
(
)
;
async
function
getOriginalRanges
(
sourceId
)
{
if
(
!
isOriginalId
(
sourceId
)
)
{
return
[
]
;
}
const
generatedSourceId
=
originalToGeneratedId
(
sourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
[
]
;
}
const
{
map
}
=
data
;
const
url
=
data
.
urlsById
.
get
(
sourceId
)
;
let
mappings
=
SOURCE_MAPPINGS
.
get
(
map
)
;
if
(
!
mappings
)
{
mappings
=
new
Map
(
)
;
SOURCE_MAPPINGS
.
set
(
map
mappings
)
;
}
let
fileMappings
=
mappings
.
get
(
url
)
;
if
(
!
fileMappings
)
{
fileMappings
=
[
]
;
mappings
.
set
(
url
fileMappings
)
;
const
originalMappings
=
fileMappings
;
map
.
eachMapping
(
mapping
=
>
{
if
(
mapping
.
source
!
=
=
url
)
{
return
;
}
const
last
=
originalMappings
[
originalMappings
.
length
-
1
]
;
if
(
last
&
&
last
.
line
=
=
=
mapping
.
originalLine
)
{
if
(
last
.
columnStart
<
mapping
.
originalColumn
)
{
last
.
columnEnd
=
mapping
.
originalColumn
;
}
else
{
return
;
}
}
originalMappings
.
push
(
{
line
:
mapping
.
originalLine
columnStart
:
mapping
.
originalColumn
columnEnd
:
Infinity
}
)
;
}
null
SourceMapConsumer
.
ORIGINAL_ORDER
)
;
}
return
fileMappings
;
}
async
function
getGeneratedRanges
(
location
)
{
if
(
!
isOriginalId
(
location
.
sourceId
)
)
{
return
[
]
;
}
const
generatedSourceId
=
originalToGeneratedId
(
location
.
sourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
[
]
;
}
const
{
urlsById
map
}
=
data
;
if
(
!
COMPUTED_SPANS
.
has
(
map
)
)
{
COMPUTED_SPANS
.
add
(
map
)
;
map
.
computeColumnSpans
(
)
;
}
const
genPos
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
location
.
sourceId
)
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
bias
:
SourceMapConsumer
.
GREATEST_LOWER_BOUND
}
)
;
if
(
genPos
.
line
=
=
=
null
)
{
return
[
]
;
}
const
positions
=
map
.
allGeneratedPositionsFor
(
map
.
originalPositionFor
(
{
line
:
genPos
.
line
column
:
genPos
.
column
}
)
)
;
return
positions
.
map
(
mapping
=
>
(
{
line
:
mapping
.
line
columnStart
:
mapping
.
column
columnEnd
:
mapping
.
lastColumn
}
)
)
.
sort
(
(
a
b
)
=
>
{
const
line
=
a
.
line
-
b
.
line
;
return
line
=
=
=
0
?
a
.
column
-
b
.
column
:
line
;
}
)
;
}
async
function
getGeneratedLocation
(
location
)
{
if
(
!
isOriginalId
(
location
.
sourceId
)
)
{
return
location
;
}
const
generatedSourceId
=
originalToGeneratedId
(
location
.
sourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
location
;
}
const
{
urlsById
map
}
=
data
;
const
positions
=
map
.
allGeneratedPositionsFor
(
{
source
:
urlsById
.
get
(
location
.
sourceId
)
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
}
)
;
let
match
;
for
(
const
pos
of
positions
)
{
if
(
!
match
|
|
pos
.
line
<
match
.
line
|
|
pos
.
column
<
match
.
column
)
{
match
=
pos
;
}
}
if
(
!
match
)
{
match
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
location
.
sourceId
)
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
bias
:
SourceMapConsumer
.
LEAST_UPPER_BOUND
}
)
;
}
return
{
sourceId
:
generatedSourceId
line
:
match
.
line
column
:
match
.
column
}
;
}
async
function
getAllGeneratedLocations
(
location
)
{
if
(
!
isOriginalId
(
location
.
sourceId
)
)
{
return
[
]
;
}
const
generatedSourceId
=
originalToGeneratedId
(
location
.
sourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
[
]
;
}
const
{
urlsById
map
}
=
data
;
const
positions
=
map
.
allGeneratedPositionsFor
(
{
source
:
urlsById
.
get
(
location
.
sourceId
)
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
}
)
;
return
positions
.
map
(
(
{
line
column
}
)
=
>
(
{
sourceId
:
generatedSourceId
line
column
}
)
)
;
}
async
function
getOriginalLocations
(
locations
options
=
{
}
)
{
const
maps
=
{
}
;
const
results
=
[
]
;
for
(
const
location
of
locations
)
{
let
map
=
maps
[
location
.
sourceId
]
;
if
(
map
=
=
=
undefined
)
{
map
=
await
getSourceMap
(
location
.
sourceId
)
;
maps
[
location
.
sourceId
]
=
map
|
|
null
;
}
results
.
push
(
map
?
getOriginalLocationSync
(
map
location
options
)
:
location
)
;
}
return
results
;
}
function
getOriginalLocationSync
(
map
location
{
search
}
=
{
}
)
{
let
match
=
map
.
originalPositionFor
(
{
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
}
)
;
if
(
search
)
{
let
line
=
location
.
line
;
let
column
=
location
.
column
=
=
null
?
0
:
location
.
column
;
while
(
match
.
source
=
=
=
null
)
{
match
=
map
.
originalPositionFor
(
{
line
column
bias
:
SourceMapConsumer
[
search
]
}
)
;
line
+
=
search
=
=
"
LEAST_UPPER_BOUND
"
?
1
:
-
1
;
column
=
search
=
=
"
LEAST_UPPER_BOUND
"
?
0
:
Infinity
;
}
}
const
{
source
:
sourceUrl
line
column
}
=
match
;
if
(
sourceUrl
=
=
null
)
{
return
location
;
}
return
{
sourceId
:
generatedToOriginalId
(
location
.
sourceId
sourceUrl
)
sourceUrl
line
column
}
;
}
async
function
getOriginalLocation
(
location
options
=
{
}
)
{
if
(
!
isGeneratedId
(
location
.
sourceId
)
)
{
return
location
;
}
const
map
=
await
getSourceMap
(
location
.
sourceId
)
;
if
(
!
map
)
{
return
location
;
}
return
getOriginalLocationSync
(
map
location
options
)
;
}
async
function
getOriginalSourceText
(
originalSourceId
)
{
assert
(
isOriginalId
(
originalSourceId
)
"
Source
is
not
an
original
source
"
)
;
const
generatedSourceId
=
originalToGeneratedId
(
originalSourceId
)
;
const
data
=
await
getSourceMapWithMetadata
(
generatedSourceId
)
;
if
(
!
data
)
{
return
null
;
}
const
{
urlsById
map
}
=
data
;
const
url
=
urlsById
.
get
(
originalSourceId
)
;
let
text
=
map
.
sourceContentFor
(
url
)
;
if
(
!
text
)
{
try
{
const
response
=
await
networkRequest
(
url
{
loadFromCache
:
false
}
)
;
text
=
response
.
content
;
}
catch
(
err
)
{
err
.
metadata
=
{
.
.
.
err
.
metadata
url
}
;
throw
err
;
}
}
return
{
text
contentType
:
getContentType
(
url
|
|
"
"
)
}
;
}
const
GENERATED_MAPPINGS
=
new
WeakMap
(
)
;
async
function
getGeneratedRangesForOriginal
(
sourceId
mergeUnmappedRegions
=
false
)
{
assert
(
isOriginalId
(
sourceId
)
"
Source
is
not
an
original
source
"
)
;
const
data
=
await
getSourceMapWithMetadata
(
originalToGeneratedId
(
sourceId
)
)
;
if
(
!
data
)
{
return
[
]
;
}
const
{
urlsById
map
}
=
data
;
const
url
=
urlsById
.
get
(
sourceId
)
;
if
(
!
COMPUTED_SPANS
.
has
(
map
)
)
{
COMPUTED_SPANS
.
add
(
map
)
;
map
.
computeColumnSpans
(
)
;
}
if
(
!
GENERATED_MAPPINGS
.
has
(
map
)
)
{
GENERATED_MAPPINGS
.
set
(
map
new
Map
(
)
)
;
}
const
generatedRangesMap
=
GENERATED_MAPPINGS
.
get
(
map
)
;
if
(
!
generatedRangesMap
)
{
return
[
]
;
}
if
(
generatedRangesMap
.
has
(
sourceId
)
)
{
return
generatedRangesMap
.
get
(
sourceId
)
|
|
[
]
;
}
let
currentGroup
=
[
]
;
const
originalGroups
=
[
currentGroup
]
;
map
.
eachMapping
(
mapping
=
>
{
if
(
mapping
.
source
=
=
=
url
)
{
currentGroup
.
push
(
{
start
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
generatedColumn
}
end
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
lastGeneratedColumn
+
1
}
}
)
;
}
else
if
(
typeof
mapping
.
source
=
=
=
"
string
"
&
&
currentGroup
.
length
>
0
)
{
currentGroup
=
[
]
;
originalGroups
.
push
(
currentGroup
)
;
}
}
null
SourceMapConsumer
.
GENERATED_ORDER
)
;
const
generatedMappingsForOriginal
=
[
]
;
if
(
mergeUnmappedRegions
)
{
for
(
const
group
of
originalGroups
)
{
if
(
group
.
length
>
0
)
{
generatedMappingsForOriginal
.
push
(
{
start
:
group
[
0
]
.
start
end
:
group
[
group
.
length
-
1
]
.
end
}
)
;
}
}
}
else
{
let
lastEntry
;
for
(
const
group
of
originalGroups
)
{
lastEntry
=
null
;
for
(
const
{
start
end
}
of
group
)
{
const
lastEnd
=
lastEntry
?
wrappedMappingPosition
(
lastEntry
.
end
)
:
null
;
if
(
lastEntry
&
&
lastEnd
&
&
lastEnd
.
line
=
=
=
start
.
line
&
&
lastEnd
.
column
=
=
=
start
.
column
)
{
lastEntry
.
end
=
end
;
}
else
{
const
newEntry
=
{
start
end
}
;
generatedMappingsForOriginal
.
push
(
newEntry
)
;
lastEntry
=
newEntry
;
}
}
}
}
generatedRangesMap
.
set
(
sourceId
generatedMappingsForOriginal
)
;
return
generatedMappingsForOriginal
;
}
function
wrappedMappingPosition
(
pos
)
{
if
(
pos
.
column
!
=
=
Infinity
)
{
return
pos
;
}
return
{
line
:
pos
.
line
+
1
column
:
0
}
;
}
async
function
getFileGeneratedRange
(
originalSourceId
)
{
assert
(
isOriginalId
(
originalSourceId
)
"
Source
is
not
an
original
source
"
)
;
const
data
=
await
getSourceMapWithMetadata
(
originalToGeneratedId
(
originalSourceId
)
)
;
if
(
!
data
)
{
return
;
}
const
{
urlsById
map
}
=
data
;
const
start
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
originalSourceId
)
line
:
1
column
:
0
bias
:
SourceMapConsumer
.
LEAST_UPPER_BOUND
}
)
;
const
end
=
map
.
generatedPositionFor
(
{
source
:
urlsById
.
get
(
originalSourceId
)
line
:
Number
.
MAX_SAFE_INTEGER
column
:
Number
.
MAX_SAFE_INTEGER
bias
:
SourceMapConsumer
.
GREATEST_LOWER_BOUND
}
)
;
return
{
start
end
}
;
}
function
applySourceMap
(
generatedId
url
code
mappings
)
{
const
generator
=
new
SourceMapGenerator
(
{
file
:
url
}
)
;
mappings
.
forEach
(
mapping
=
>
generator
.
addMapping
(
mapping
)
)
;
generator
.
setSourceContent
(
url
code
)
;
const
map
=
createConsumer
(
generator
.
toJSON
(
)
)
;
setSourceMap
(
generatedId
Promise
.
resolve
(
map
)
)
;
}
function
clearSourceMaps
(
)
{
clearSourceMapsRequests
(
)
;
clearWasmXScopes
(
)
;
clearOriginalURLs
(
)
;
}
module
.
exports
=
{
getOriginalURLs
hasOriginalURL
getOriginalRanges
getGeneratedRanges
getGeneratedLocation
getAllGeneratedLocations
getOriginalLocation
getOriginalLocations
getOriginalSourceText
getGeneratedRangesForOriginal
getFileGeneratedRange
applySourceMap
clearSourceMaps
}
;
}
)
392
:
(
function
(
module
exports
)
{
const
intToCharMap
=
"
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
"
.
split
(
"
"
)
;
exports
.
encode
=
function
(
number
)
{
if
(
0
<
=
number
&
&
number
<
intToCharMap
.
length
)
{
return
intToCharMap
[
number
]
;
}
throw
new
TypeError
(
"
Must
be
between
0
and
63
:
"
+
number
)
;
}
;
}
)
393
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
module
.
exports
=
__webpack_require__
(
523
)
.
URL
;
}
)
402
:
(
function
(
module
exports
__webpack_require__
)
{
const
util
=
__webpack_require__
(
61
)
;
function
generatedPositionAfter
(
mappingA
mappingB
)
{
const
lineA
=
mappingA
.
generatedLine
;
const
lineB
=
mappingB
.
generatedLine
;
const
columnA
=
mappingA
.
generatedColumn
;
const
columnB
=
mappingB
.
generatedColumn
;
return
lineB
>
lineA
|
|
lineB
=
=
lineA
&
&
columnB
>
=
columnA
|
|
util
.
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
<
=
0
;
}
class
MappingList
{
constructor
(
)
{
this
.
_array
=
[
]
;
this
.
_sorted
=
true
;
this
.
_last
=
{
generatedLine
:
-
1
generatedColumn
:
0
}
;
}
unsortedForEach
(
aCallback
aThisArg
)
{
this
.
_array
.
forEach
(
aCallback
aThisArg
)
;
}
add
(
aMapping
)
{
if
(
generatedPositionAfter
(
this
.
_last
aMapping
)
)
{
this
.
_last
=
aMapping
;
this
.
_array
.
push
(
aMapping
)
;
}
else
{
this
.
_sorted
=
false
;
this
.
_array
.
push
(
aMapping
)
;
}
}
toArray
(
)
{
if
(
!
this
.
_sorted
)
{
this
.
_array
.
sort
(
util
.
compareByGeneratedPositionsInflated
)
;
this
.
_sorted
=
true
;
}
return
this
.
_array
;
}
}
exports
.
MappingList
=
MappingList
;
}
)
403
:
(
function
(
module
exports
__webpack_require__
)
{
const
util
=
__webpack_require__
(
61
)
;
const
binarySearch
=
__webpack_require__
(
404
)
;
const
ArraySet
=
__webpack_require__
(
177
)
.
ArraySet
;
const
base64VLQ
=
__webpack_require__
(
172
)
;
const
readWasm
=
__webpack_require__
(
178
)
;
const
wasm
=
__webpack_require__
(
405
)
;
const
INTERNAL
=
Symbol
(
"
smcInternal
"
)
;
class
SourceMapConsumer
{
constructor
(
aSourceMap
aSourceMapURL
)
{
if
(
aSourceMap
=
=
INTERNAL
)
{
return
Promise
.
resolve
(
this
)
;
}
return
_factory
(
aSourceMap
aSourceMapURL
)
;
}
static
initialize
(
opts
)
{
readWasm
.
initialize
(
opts
[
"
lib
/
mappings
.
wasm
"
]
)
;
}
static
fromSourceMap
(
aSourceMap
aSourceMapURL
)
{
return
_factoryBSM
(
aSourceMap
aSourceMapURL
)
;
}
static
async
with
(
rawSourceMap
sourceMapUrl
f
)
{
const
consumer
=
await
new
SourceMapConsumer
(
rawSourceMap
sourceMapUrl
)
;
try
{
return
await
f
(
consumer
)
;
}
finally
{
consumer
.
destroy
(
)
;
}
}
eachMapping
(
aCallback
aContext
aOrder
)
{
throw
new
Error
(
"
Subclasses
must
implement
eachMapping
"
)
;
}
allGeneratedPositionsFor
(
aArgs
)
{
throw
new
Error
(
"
Subclasses
must
implement
allGeneratedPositionsFor
"
)
;
}
destroy
(
)
{
throw
new
Error
(
"
Subclasses
must
implement
destroy
"
)
;
}
}
SourceMapConsumer
.
prototype
.
_version
=
3
;
SourceMapConsumer
.
GENERATED_ORDER
=
1
;
SourceMapConsumer
.
ORIGINAL_ORDER
=
2
;
SourceMapConsumer
.
GREATEST_LOWER_BOUND
=
1
;
SourceMapConsumer
.
LEAST_UPPER_BOUND
=
2
;
exports
.
SourceMapConsumer
=
SourceMapConsumer
;
class
BasicSourceMapConsumer
extends
SourceMapConsumer
{
constructor
(
aSourceMap
aSourceMapURL
)
{
return
super
(
INTERNAL
)
.
then
(
that
=
>
{
let
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
"
string
"
)
{
sourceMap
=
util
.
parseSourceMapInput
(
aSourceMap
)
;
}
const
version
=
util
.
getArg
(
sourceMap
"
version
"
)
;
const
sources
=
util
.
getArg
(
sourceMap
"
sources
"
)
.
map
(
String
)
;
const
names
=
util
.
getArg
(
sourceMap
"
names
"
[
]
)
;
const
sourceRoot
=
util
.
getArg
(
sourceMap
"
sourceRoot
"
null
)
;
const
sourcesContent
=
util
.
getArg
(
sourceMap
"
sourcesContent
"
null
)
;
const
mappings
=
util
.
getArg
(
sourceMap
"
mappings
"
)
;
const
file
=
util
.
getArg
(
sourceMap
"
file
"
null
)
;
if
(
version
!
=
that
.
_version
)
{
throw
new
Error
(
"
Unsupported
version
:
"
+
version
)
;
}
that
.
_sourceLookupCache
=
new
Map
(
)
;
that
.
_names
=
ArraySet
.
fromArray
(
names
.
map
(
String
)
true
)
;
that
.
_sources
=
ArraySet
.
fromArray
(
sources
true
)
;
that
.
_absoluteSources
=
ArraySet
.
fromArray
(
that
.
_sources
.
toArray
(
)
.
map
(
function
(
s
)
{
return
util
.
computeSourceURL
(
sourceRoot
s
aSourceMapURL
)
;
}
)
true
)
;
that
.
sourceRoot
=
sourceRoot
;
that
.
sourcesContent
=
sourcesContent
;
that
.
_mappings
=
mappings
;
that
.
_sourceMapURL
=
aSourceMapURL
;
that
.
file
=
file
;
that
.
_computedColumnSpans
=
false
;
that
.
_mappingsPtr
=
0
;
that
.
_wasm
=
null
;
return
wasm
(
)
.
then
(
w
=
>
{
that
.
_wasm
=
w
;
return
that
;
}
)
;
}
)
;
}
_findSourceIndex
(
aSource
)
{
const
cachedIndex
=
this
.
_sourceLookupCache
.
get
(
aSource
)
;
if
(
typeof
cachedIndex
=
=
=
"
number
"
)
{
return
cachedIndex
;
}
const
sourceAsMapRelative
=
util
.
computeSourceURL
(
null
aSource
this
.
_sourceMapURL
)
;
if
(
this
.
_absoluteSources
.
has
(
sourceAsMapRelative
)
)
{
const
index
=
this
.
_absoluteSources
.
indexOf
(
sourceAsMapRelative
)
;
this
.
_sourceLookupCache
.
set
(
aSource
index
)
;
return
index
;
}
const
sourceAsSourceRootRelative
=
util
.
computeSourceURL
(
this
.
sourceRoot
aSource
this
.
_sourceMapURL
)
;
if
(
this
.
_absoluteSources
.
has
(
sourceAsSourceRootRelative
)
)
{
const
index
=
this
.
_absoluteSources
.
indexOf
(
sourceAsSourceRootRelative
)
;
this
.
_sourceLookupCache
.
set
(
aSource
index
)
;
return
index
;
}
return
-
1
;
}
static
fromSourceMap
(
aSourceMap
aSourceMapURL
)
{
return
new
BasicSourceMapConsumer
(
aSourceMap
.
toString
(
)
)
;
}
get
sources
(
)
{
return
this
.
_absoluteSources
.
toArray
(
)
;
}
_getMappingsPtr
(
)
{
if
(
this
.
_mappingsPtr
=
=
=
0
)
{
this
.
_parseMappings
(
)
;
}
return
this
.
_mappingsPtr
;
}
_parseMappings
(
)
{
const
aStr
=
this
.
_mappings
;
const
size
=
aStr
.
length
;
const
mappingsBufPtr
=
this
.
_wasm
.
exports
.
allocate_mappings
(
size
)
;
const
mappingsBuf
=
new
Uint8Array
(
this
.
_wasm
.
exports
.
memory
.
buffer
mappingsBufPtr
size
)
;
for
(
let
i
=
0
;
i
<
size
;
i
+
+
)
{
mappingsBuf
[
i
]
=
aStr
.
charCodeAt
(
i
)
;
}
const
mappingsPtr
=
this
.
_wasm
.
exports
.
parse_mappings
(
mappingsBufPtr
)
;
if
(
!
mappingsPtr
)
{
const
error
=
this
.
_wasm
.
exports
.
get_last_error
(
)
;
let
msg
=
Error
parsing
mappings
(
code
{
error
}
)
:
;
switch
(
error
)
{
case
1
:
msg
+
=
"
the
mappings
contained
a
negative
line
column
source
index
or
name
index
"
;
break
;
case
2
:
msg
+
=
"
the
mappings
contained
a
number
larger
than
2
*
*
32
"
;
break
;
case
3
:
msg
+
=
"
reached
EOF
while
in
the
middle
of
parsing
a
VLQ
"
;
break
;
case
4
:
msg
+
=
"
invalid
base
64
character
while
parsing
a
VLQ
"
;
break
;
default
:
msg
+
=
"
unknown
error
code
"
;
break
;
}
throw
new
Error
(
msg
)
;
}
this
.
_mappingsPtr
=
mappingsPtr
;
}
eachMapping
(
aCallback
aContext
aOrder
)
{
const
context
=
aContext
|
|
null
;
const
order
=
aOrder
|
|
SourceMapConsumer
.
GENERATED_ORDER
;
this
.
_wasm
.
withMappingCallback
(
mapping
=
>
{
if
(
mapping
.
source
!
=
=
null
)
{
mapping
.
source
=
this
.
_absoluteSources
.
at
(
mapping
.
source
)
;
if
(
mapping
.
name
!
=
=
null
)
{
mapping
.
name
=
this
.
_names
.
at
(
mapping
.
name
)
;
}
}
if
(
this
.
_computedColumnSpans
&
&
mapping
.
lastGeneratedColumn
=
=
=
null
)
{
mapping
.
lastGeneratedColumn
=
Infinity
;
}
aCallback
.
call
(
context
mapping
)
;
}
(
)
=
>
{
switch
(
order
)
{
case
SourceMapConsumer
.
GENERATED_ORDER
:
this
.
_wasm
.
exports
.
by_generated_location
(
this
.
_getMappingsPtr
(
)
)
;
break
;
case
SourceMapConsumer
.
ORIGINAL_ORDER
:
this
.
_wasm
.
exports
.
by_original_location
(
this
.
_getMappingsPtr
(
)
)
;
break
;
default
:
throw
new
Error
(
"
Unknown
order
of
iteration
.
"
)
;
}
}
)
;
}
allGeneratedPositionsFor
(
aArgs
)
{
let
source
=
util
.
getArg
(
aArgs
"
source
"
)
;
const
originalLine
=
util
.
getArg
(
aArgs
"
line
"
)
;
const
originalColumn
=
aArgs
.
column
|
|
0
;
source
=
this
.
_findSourceIndex
(
source
)
;
if
(
source
<
0
)
{
return
[
]
;
}
if
(
originalLine
<
1
)
{
throw
new
Error
(
"
Line
numbers
must
be
>
=
1
"
)
;
}
if
(
originalColumn
<
0
)
{
throw
new
Error
(
"
Column
numbers
must
be
>
=
0
"
)
;
}
const
mappings
=
[
]
;
this
.
_wasm
.
withMappingCallback
(
m
=
>
{
let
lastColumn
=
m
.
lastGeneratedColumn
;
if
(
this
.
_computedColumnSpans
&
&
lastColumn
=
=
=
null
)
{
lastColumn
=
Infinity
;
}
mappings
.
push
(
{
line
:
m
.
generatedLine
column
:
m
.
generatedColumn
lastColumn
}
)
;
}
(
)
=
>
{
this
.
_wasm
.
exports
.
all_generated_locations_for
(
this
.
_getMappingsPtr
(
)
source
originalLine
-
1
"
column
"
in
aArgs
originalColumn
)
;
}
)
;
return
mappings
;
}
destroy
(
)
{
if
(
this
.
_mappingsPtr
!
=
=
0
)
{
this
.
_wasm
.
exports
.
free_mappings
(
this
.
_mappingsPtr
)
;
this
.
_mappingsPtr
=
0
;
}
}
computeColumnSpans
(
)
{
if
(
this
.
_computedColumnSpans
)
{
return
;
}
this
.
_wasm
.
exports
.
compute_column_spans
(
this
.
_getMappingsPtr
(
)
)
;
this
.
_computedColumnSpans
=
true
;
}
originalPositionFor
(
aArgs
)
{
const
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
"
line
"
)
generatedColumn
:
util
.
getArg
(
aArgs
"
column
"
)
}
;
if
(
needle
.
generatedLine
<
1
)
{
throw
new
Error
(
"
Line
numbers
must
be
>
=
1
"
)
;
}
if
(
needle
.
generatedColumn
<
0
)
{
throw
new
Error
(
"
Column
numbers
must
be
>
=
0
"
)
;
}
let
bias
=
util
.
getArg
(
aArgs
"
bias
"
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
;
if
(
bias
=
=
null
)
{
bias
=
SourceMapConsumer
.
GREATEST_LOWER_BOUND
;
}
let
mapping
;
this
.
_wasm
.
withMappingCallback
(
m
=
>
mapping
=
m
(
)
=
>
{
this
.
_wasm
.
exports
.
original_location_for
(
this
.
_getMappingsPtr
(
)
needle
.
generatedLine
-
1
needle
.
generatedColumn
bias
)
;
}
)
;
if
(
mapping
)
{
if
(
mapping
.
generatedLine
=
=
=
needle
.
generatedLine
)
{
let
source
=
util
.
getArg
(
mapping
"
source
"
null
)
;
if
(
source
!
=
=
null
)
{
source
=
this
.
_absoluteSources
.
at
(
source
)
;
}
let
name
=
util
.
getArg
(
mapping
"
name
"
null
)
;
if
(
name
!
=
=
null
)
{
name
=
this
.
_names
.
at
(
name
)
;
}
return
{
source
line
:
util
.
getArg
(
mapping
"
originalLine
"
null
)
column
:
util
.
getArg
(
mapping
"
originalColumn
"
null
)
name
}
;
}
}
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
hasContentsOfAllSources
(
)
{
if
(
!
this
.
sourcesContent
)
{
return
false
;
}
return
this
.
sourcesContent
.
length
>
=
this
.
_sources
.
size
(
)
&
&
!
this
.
sourcesContent
.
some
(
function
(
sc
)
{
return
sc
=
=
null
;
}
)
;
}
sourceContentFor
(
aSource
nullOnMissing
)
{
if
(
!
this
.
sourcesContent
)
{
return
null
;
}
const
index
=
this
.
_findSourceIndex
(
aSource
)
;
if
(
index
>
=
0
)
{
return
this
.
sourcesContent
[
index
]
;
}
if
(
nullOnMissing
)
{
return
null
;
}
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
generatedPositionFor
(
aArgs
)
{
let
source
=
util
.
getArg
(
aArgs
"
source
"
)
;
source
=
this
.
_findSourceIndex
(
source
)
;
if
(
source
<
0
)
{
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
const
needle
=
{
source
originalLine
:
util
.
getArg
(
aArgs
"
line
"
)
originalColumn
:
util
.
getArg
(
aArgs
"
column
"
)
}
;
if
(
needle
.
originalLine
<
1
)
{
throw
new
Error
(
"
Line
numbers
must
be
>
=
1
"
)
;
}
if
(
needle
.
originalColumn
<
0
)
{
throw
new
Error
(
"
Column
numbers
must
be
>
=
0
"
)
;
}
let
bias
=
util
.
getArg
(
aArgs
"
bias
"
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
;
if
(
bias
=
=
null
)
{
bias
=
SourceMapConsumer
.
GREATEST_LOWER_BOUND
;
}
let
mapping
;
this
.
_wasm
.
withMappingCallback
(
m
=
>
mapping
=
m
(
)
=
>
{
this
.
_wasm
.
exports
.
generated_location_for
(
this
.
_getMappingsPtr
(
)
needle
.
source
needle
.
originalLine
-
1
needle
.
originalColumn
bias
)
;
}
)
;
if
(
mapping
)
{
if
(
mapping
.
source
=
=
=
needle
.
source
)
{
let
lastColumn
=
mapping
.
lastGeneratedColumn
;
if
(
this
.
_computedColumnSpans
&
&
lastColumn
=
=
=
null
)
{
lastColumn
=
Infinity
;
}
return
{
line
:
util
.
getArg
(
mapping
"
generatedLine
"
null
)
column
:
util
.
getArg
(
mapping
"
generatedColumn
"
null
)
lastColumn
}
;
}
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
}
BasicSourceMapConsumer
.
prototype
.
consumer
=
SourceMapConsumer
;
exports
.
BasicSourceMapConsumer
=
BasicSourceMapConsumer
;
class
IndexedSourceMapConsumer
extends
SourceMapConsumer
{
constructor
(
aSourceMap
aSourceMapURL
)
{
return
super
(
INTERNAL
)
.
then
(
that
=
>
{
let
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
"
string
"
)
{
sourceMap
=
util
.
parseSourceMapInput
(
aSourceMap
)
;
}
const
version
=
util
.
getArg
(
sourceMap
"
version
"
)
;
const
sections
=
util
.
getArg
(
sourceMap
"
sections
"
)
;
if
(
version
!
=
that
.
_version
)
{
throw
new
Error
(
"
Unsupported
version
:
"
+
version
)
;
}
let
lastOffset
=
{
line
:
-
1
column
:
0
}
;
return
Promise
.
all
(
sections
.
map
(
s
=
>
{
if
(
s
.
url
)
{
throw
new
Error
(
"
Support
for
url
field
in
sections
not
implemented
.
"
)
;
}
const
offset
=
util
.
getArg
(
s
"
offset
"
)
;
const
offsetLine
=
util
.
getArg
(
offset
"
line
"
)
;
const
offsetColumn
=
util
.
getArg
(
offset
"
column
"
)
;
if
(
offsetLine
<
lastOffset
.
line
|
|
(
offsetLine
=
=
=
lastOffset
.
line
&
&
offsetColumn
<
lastOffset
.
column
)
)
{
throw
new
Error
(
"
Section
offsets
must
be
ordered
and
non
-
overlapping
.
"
)
;
}
lastOffset
=
offset
;
const
cons
=
new
SourceMapConsumer
(
util
.
getArg
(
s
"
map
"
)
aSourceMapURL
)
;
return
cons
.
then
(
consumer
=
>
{
return
{
generatedOffset
:
{
generatedLine
:
offsetLine
+
1
generatedColumn
:
offsetColumn
+
1
}
consumer
}
;
}
)
;
}
)
)
.
then
(
s
=
>
{
that
.
_sections
=
s
;
return
that
;
}
)
;
}
)
;
}
get
sources
(
)
{
const
sources
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
this
.
_sections
[
i
]
.
consumer
.
sources
.
length
;
j
+
+
)
{
sources
.
push
(
this
.
_sections
[
i
]
.
consumer
.
sources
[
j
]
)
;
}
}
return
sources
;
}
originalPositionFor
(
aArgs
)
{
const
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
"
line
"
)
generatedColumn
:
util
.
getArg
(
aArgs
"
column
"
)
}
;
const
sectionIndex
=
binarySearch
.
search
(
needle
this
.
_sections
function
(
aNeedle
section
)
{
const
cmp
=
aNeedle
.
generatedLine
-
section
.
generatedOffset
.
generatedLine
;
if
(
cmp
)
{
return
cmp
;
}
return
(
aNeedle
.
generatedColumn
-
section
.
generatedOffset
.
generatedColumn
)
;
}
)
;
const
section
=
this
.
_sections
[
sectionIndex
]
;
if
(
!
section
)
{
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
return
section
.
consumer
.
originalPositionFor
(
{
line
:
needle
.
generatedLine
-
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
needle
.
generatedColumn
-
(
section
.
generatedOffset
.
generatedLine
=
=
=
needle
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
bias
:
aArgs
.
bias
}
)
;
}
hasContentsOfAllSources
(
)
{
return
this
.
_sections
.
every
(
function
(
s
)
{
return
s
.
consumer
.
hasContentsOfAllSources
(
)
;
}
)
;
}
sourceContentFor
(
aSource
nullOnMissing
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
const
section
=
this
.
_sections
[
i
]
;
const
content
=
section
.
consumer
.
sourceContentFor
(
aSource
true
)
;
if
(
content
)
{
return
content
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
_findSectionIndex
(
source
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
const
{
consumer
}
=
this
.
_sections
[
i
]
;
if
(
consumer
.
_findSourceIndex
(
source
)
!
=
=
-
1
)
{
return
i
;
}
}
return
-
1
;
}
generatedPositionFor
(
aArgs
)
{
const
index
=
this
.
_findSectionIndex
(
util
.
getArg
(
aArgs
"
source
"
)
)
;
const
section
=
index
>
=
0
?
this
.
_sections
[
index
]
:
null
;
const
nextSection
=
index
>
=
0
&
&
index
+
1
<
this
.
_sections
.
length
?
this
.
_sections
[
index
+
1
]
:
null
;
const
generatedPosition
=
section
&
&
section
.
consumer
.
generatedPositionFor
(
aArgs
)
;
if
(
generatedPosition
&
&
generatedPosition
.
line
!
=
=
null
)
{
const
lineShift
=
section
.
generatedOffset
.
generatedLine
-
1
;
const
columnShift
=
section
.
generatedOffset
.
generatedColumn
-
1
;
if
(
generatedPosition
.
line
=
=
=
1
)
{
generatedPosition
.
column
+
=
columnShift
;
if
(
typeof
generatedPosition
.
lastColumn
=
=
=
"
number
"
)
{
generatedPosition
.
lastColumn
+
=
columnShift
;
}
}
if
(
generatedPosition
.
lastColumn
=
=
=
Infinity
&
&
nextSection
&
&
generatedPosition
.
line
=
=
=
nextSection
.
generatedOffset
.
generatedLine
)
{
generatedPosition
.
lastColumn
=
nextSection
.
generatedOffset
.
generatedColumn
-
2
;
}
generatedPosition
.
line
+
=
lineShift
;
return
generatedPosition
;
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
allGeneratedPositionsFor
(
aArgs
)
{
const
index
=
this
.
_findSectionIndex
(
util
.
getArg
(
aArgs
"
source
"
)
)
;
const
section
=
index
>
=
0
?
this
.
_sections
[
index
]
:
null
;
const
nextSection
=
index
>
=
0
&
&
index
+
1
<
this
.
_sections
.
length
?
this
.
_sections
[
index
+
1
]
:
null
;
if
(
!
section
)
return
[
]
;
return
section
.
consumer
.
allGeneratedPositionsFor
(
aArgs
)
.
map
(
generatedPosition
=
>
{
const
lineShift
=
section
.
generatedOffset
.
generatedLine
-
1
;
const
columnShift
=
section
.
generatedOffset
.
generatedColumn
-
1
;
if
(
generatedPosition
.
line
=
=
=
1
)
{
generatedPosition
.
column
+
=
columnShift
;
if
(
typeof
generatedPosition
.
lastColumn
=
=
=
"
number
"
)
{
generatedPosition
.
lastColumn
+
=
columnShift
;
}
}
if
(
generatedPosition
.
lastColumn
=
=
=
Infinity
&
&
nextSection
&
&
generatedPosition
.
line
=
=
=
nextSection
.
generatedOffset
.
generatedLine
)
{
generatedPosition
.
lastColumn
=
nextSection
.
generatedOffset
.
generatedColumn
-
2
;
}
generatedPosition
.
line
+
=
lineShift
;
return
generatedPosition
;
}
)
;
}
eachMapping
(
aCallback
aContext
aOrder
)
{
this
.
_sections
.
forEach
(
(
section
index
)
=
>
{
const
nextSection
=
index
+
1
<
this
.
_sections
.
length
?
this
.
_sections
[
index
+
1
]
:
null
;
const
{
generatedOffset
}
=
section
;
const
lineShift
=
generatedOffset
.
generatedLine
-
1
;
const
columnShift
=
generatedOffset
.
generatedColumn
-
1
;
section
.
consumer
.
eachMapping
(
function
(
mapping
)
{
if
(
mapping
.
generatedLine
=
=
=
1
)
{
mapping
.
generatedColumn
+
=
columnShift
;
if
(
typeof
mapping
.
lastGeneratedColumn
=
=
=
"
number
"
)
{
mapping
.
lastGeneratedColumn
+
=
columnShift
;
}
}
if
(
mapping
.
lastGeneratedColumn
=
=
=
Infinity
&
&
nextSection
&
&
mapping
.
generatedLine
=
=
=
nextSection
.
generatedOffset
.
generatedLine
)
{
mapping
.
lastGeneratedColumn
=
nextSection
.
generatedOffset
.
generatedColumn
-
2
;
}
mapping
.
generatedLine
+
=
lineShift
;
aCallback
.
call
(
this
mapping
)
;
}
aContext
aOrder
)
;
}
)
;
}
computeColumnSpans
(
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
this
.
_sections
[
i
]
.
consumer
.
computeColumnSpans
(
)
;
}
}
destroy
(
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
this
.
_sections
[
i
]
.
consumer
.
destroy
(
)
;
}
}
}
exports
.
IndexedSourceMapConsumer
=
IndexedSourceMapConsumer
;
function
_factory
(
aSourceMap
aSourceMapURL
)
{
let
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
"
string
"
)
{
sourceMap
=
util
.
parseSourceMapInput
(
aSourceMap
)
;
}
const
consumer
=
sourceMap
.
sections
!
=
null
?
new
IndexedSourceMapConsumer
(
sourceMap
aSourceMapURL
)
:
new
BasicSourceMapConsumer
(
sourceMap
aSourceMapURL
)
;
return
Promise
.
resolve
(
consumer
)
;
}
function
_factoryBSM
(
aSourceMap
aSourceMapURL
)
{
return
BasicSourceMapConsumer
.
fromSourceMap
(
aSourceMap
aSourceMapURL
)
;
}
}
)
404
:
(
function
(
module
exports
)
{
exports
.
GREATEST_LOWER_BOUND
=
1
;
exports
.
LEAST_UPPER_BOUND
=
2
;
function
recursiveSearch
(
aLow
aHigh
aNeedle
aHaystack
aCompare
aBias
)
{
const
mid
=
Math
.
floor
(
(
aHigh
-
aLow
)
/
2
)
+
aLow
;
const
cmp
=
aCompare
(
aNeedle
aHaystack
[
mid
]
true
)
;
if
(
cmp
=
=
=
0
)
{
return
mid
;
}
else
if
(
cmp
>
0
)
{
if
(
aHigh
-
mid
>
1
)
{
return
recursiveSearch
(
mid
aHigh
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
aHigh
<
aHaystack
.
length
?
aHigh
:
-
1
;
}
return
mid
;
}
if
(
mid
-
aLow
>
1
)
{
return
recursiveSearch
(
aLow
mid
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
mid
;
}
return
aLow
<
0
?
-
1
:
aLow
;
}
exports
.
search
=
function
search
(
aNeedle
aHaystack
aCompare
aBias
)
{
if
(
aHaystack
.
length
=
=
=
0
)
{
return
-
1
;
}
let
index
=
recursiveSearch
(
-
1
aHaystack
.
length
aNeedle
aHaystack
aCompare
aBias
|
|
exports
.
GREATEST_LOWER_BOUND
)
;
if
(
index
<
0
)
{
return
-
1
;
}
while
(
index
-
1
>
=
0
)
{
if
(
aCompare
(
aHaystack
[
index
]
aHaystack
[
index
-
1
]
true
)
!
=
=
0
)
{
break
;
}
-
-
index
;
}
return
index
;
}
;
}
)
405
:
(
function
(
module
exports
__webpack_require__
)
{
const
readWasm
=
__webpack_require__
(
178
)
;
function
Mapping
(
)
{
this
.
generatedLine
=
0
;
this
.
generatedColumn
=
0
;
this
.
lastGeneratedColumn
=
null
;
this
.
source
=
null
;
this
.
originalLine
=
null
;
this
.
originalColumn
=
null
;
this
.
name
=
null
;
}
let
cachedWasm
=
null
;
module
.
exports
=
function
wasm
(
)
{
if
(
cachedWasm
)
{
return
cachedWasm
;
}
const
callbackStack
=
[
]
;
cachedWasm
=
readWasm
(
)
.
then
(
buffer
=
>
{
return
WebAssembly
.
instantiate
(
buffer
{
env
:
{
mapping_callback
(
generatedLine
generatedColumn
hasLastGeneratedColumn
lastGeneratedColumn
hasOriginal
source
originalLine
originalColumn
hasName
name
)
{
const
mapping
=
new
Mapping
(
)
;
mapping
.
generatedLine
=
generatedLine
+
1
;
mapping
.
generatedColumn
=
generatedColumn
;
if
(
hasLastGeneratedColumn
)
{
mapping
.
lastGeneratedColumn
=
lastGeneratedColumn
-
1
;
}
if
(
hasOriginal
)
{
mapping
.
source
=
source
;
mapping
.
originalLine
=
originalLine
+
1
;
mapping
.
originalColumn
=
originalColumn
;
if
(
hasName
)
{
mapping
.
name
=
name
;
}
}
callbackStack
[
callbackStack
.
length
-
1
]
(
mapping
)
;
}
start_all_generated_locations_for
(
)
{
console
.
time
(
"
all_generated_locations_for
"
)
;
}
end_all_generated_locations_for
(
)
{
console
.
timeEnd
(
"
all_generated_locations_for
"
)
;
}
start_compute_column_spans
(
)
{
console
.
time
(
"
compute_column_spans
"
)
;
}
end_compute_column_spans
(
)
{
console
.
timeEnd
(
"
compute_column_spans
"
)
;
}
start_generated_location_for
(
)
{
console
.
time
(
"
generated_location_for
"
)
;
}
end_generated_location_for
(
)
{
console
.
timeEnd
(
"
generated_location_for
"
)
;
}
start_original_location_for
(
)
{
console
.
time
(
"
original_location_for
"
)
;
}
end_original_location_for
(
)
{
console
.
timeEnd
(
"
original_location_for
"
)
;
}
start_parse_mappings
(
)
{
console
.
time
(
"
parse_mappings
"
)
;
}
end_parse_mappings
(
)
{
console
.
timeEnd
(
"
parse_mappings
"
)
;
}
start_sort_by_generated_location
(
)
{
console
.
time
(
"
sort_by_generated_location
"
)
;
}
end_sort_by_generated_location
(
)
{
console
.
timeEnd
(
"
sort_by_generated_location
"
)
;
}
start_sort_by_original_location
(
)
{
console
.
time
(
"
sort_by_original_location
"
)
;
}
end_sort_by_original_location
(
)
{
console
.
timeEnd
(
"
sort_by_original_location
"
)
;
}
}
}
)
;
}
)
.
then
(
Wasm
=
>
{
return
{
exports
:
Wasm
.
instance
.
exports
withMappingCallback
:
(
mappingCallback
f
)
=
>
{
callbackStack
.
push
(
mappingCallback
)
;
try
{
f
(
)
;
}
finally
{
callbackStack
.
pop
(
)
;
}
}
}
;
}
)
.
then
(
null
e
=
>
{
cachedWasm
=
null
;
throw
e
;
}
)
;
return
cachedWasm
;
}
;
}
)
406
:
(
function
(
module
exports
__webpack_require__
)
{
const
SourceMapGenerator
=
__webpack_require__
(
171
)
.
SourceMapGenerator
;
const
util
=
__webpack_require__
(
61
)
;
const
REGEX_NEWLINE
=
/
(
\
r
?
\
n
)
/
;
const
NEWLINE_CODE
=
10
;
const
isSourceNode
=
"
isSourceNode
"
;
class
SourceNode
{
constructor
(
aLine
aColumn
aSource
aChunks
aName
)
{
this
.
children
=
[
]
;
this
.
sourceContents
=
{
}
;
this
.
line
=
aLine
=
=
null
?
null
:
aLine
;
this
.
column
=
aColumn
=
=
null
?
null
:
aColumn
;
this
.
source
=
aSource
=
=
null
?
null
:
aSource
;
this
.
name
=
aName
=
=
null
?
null
:
aName
;
this
[
isSourceNode
]
=
true
;
if
(
aChunks
!
=
null
)
this
.
add
(
aChunks
)
;
}
static
fromStringWithSourceMap
(
aGeneratedCode
aSourceMapConsumer
aRelativePath
)
{
const
node
=
new
SourceNode
(
)
;
const
remainingLines
=
aGeneratedCode
.
split
(
REGEX_NEWLINE
)
;
let
remainingLinesIndex
=
0
;
const
shiftNextLine
=
function
(
)
{
const
lineContents
=
getNextLine
(
)
;
const
newLine
=
getNextLine
(
)
|
|
"
"
;
return
lineContents
+
newLine
;
function
getNextLine
(
)
{
return
remainingLinesIndex
<
remainingLines
.
length
?
remainingLines
[
remainingLinesIndex
+
+
]
:
undefined
;
}
}
;
let
lastGeneratedLine
=
1
lastGeneratedColumn
=
0
;
let
lastMapping
=
null
;
let
nextLine
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
if
(
lastMapping
!
=
=
null
)
{
if
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
lastGeneratedColumn
=
0
;
}
else
{
nextLine
=
remainingLines
[
remainingLinesIndex
]
|
|
"
"
;
const
code
=
nextLine
.
substr
(
0
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
remainingLines
[
remainingLinesIndex
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
addMappingWithCode
(
lastMapping
code
)
;
lastMapping
=
mapping
;
return
;
}
}
while
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
node
.
add
(
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
}
if
(
lastGeneratedColumn
<
mapping
.
generatedColumn
)
{
nextLine
=
remainingLines
[
remainingLinesIndex
]
|
|
"
"
;
node
.
add
(
nextLine
.
substr
(
0
mapping
.
generatedColumn
)
)
;
remainingLines
[
remainingLinesIndex
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
}
lastMapping
=
mapping
;
}
this
)
;
if
(
remainingLinesIndex
<
remainingLines
.
length
)
{
if
(
lastMapping
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
}
node
.
add
(
remainingLines
.
splice
(
remainingLinesIndex
)
.
join
(
"
"
)
)
;
}
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
const
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aRelativePath
!
=
null
)
{
sourceFile
=
util
.
join
(
aRelativePath
sourceFile
)
;
}
node
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
node
;
function
addMappingWithCode
(
mapping
code
)
{
if
(
mapping
=
=
=
null
|
|
mapping
.
source
=
=
=
undefined
)
{
node
.
add
(
code
)
;
}
else
{
const
source
=
aRelativePath
?
util
.
join
(
aRelativePath
mapping
.
source
)
:
mapping
.
source
;
node
.
add
(
new
SourceNode
(
mapping
.
originalLine
mapping
.
originalColumn
source
code
mapping
.
name
)
)
;
}
}
}
add
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
aChunk
.
forEach
(
function
(
chunk
)
{
this
.
add
(
chunk
)
;
}
this
)
;
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
if
(
aChunk
)
{
this
.
children
.
push
(
aChunk
)
;
}
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
prepend
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
for
(
let
i
=
aChunk
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
prepend
(
aChunk
[
i
]
)
;
}
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
this
.
children
.
unshift
(
aChunk
)
;
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
walk
(
aFn
)
{
let
chunk
;
for
(
let
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
chunk
=
this
.
children
[
i
]
;
if
(
chunk
[
isSourceNode
]
)
{
chunk
.
walk
(
aFn
)
;
}
else
if
(
chunk
!
=
=
"
"
)
{
aFn
(
chunk
{
source
:
this
.
source
line
:
this
.
line
column
:
this
.
column
name
:
this
.
name
}
)
;
}
}
}
join
(
aSep
)
{
let
newChildren
;
let
i
;
const
len
=
this
.
children
.
length
;
if
(
len
>
0
)
{
newChildren
=
[
]
;
for
(
i
=
0
;
i
<
len
-
1
;
i
+
+
)
{
newChildren
.
push
(
this
.
children
[
i
]
)
;
newChildren
.
push
(
aSep
)
;
}
newChildren
.
push
(
this
.
children
[
i
]
)
;
this
.
children
=
newChildren
;
}
return
this
;
}
replaceRight
(
aPattern
aReplacement
)
{
const
lastChild
=
this
.
children
[
this
.
children
.
length
-
1
]
;
if
(
lastChild
[
isSourceNode
]
)
{
lastChild
.
replaceRight
(
aPattern
aReplacement
)
;
}
else
if
(
typeof
lastChild
=
=
=
"
string
"
)
{
this
.
children
[
this
.
children
.
length
-
1
]
=
lastChild
.
replace
(
aPattern
aReplacement
)
;
}
else
{
this
.
children
.
push
(
"
"
.
replace
(
aPattern
aReplacement
)
)
;
}
return
this
;
}
setSourceContent
(
aSourceFile
aSourceContent
)
{
this
.
sourceContents
[
util
.
toSetString
(
aSourceFile
)
]
=
aSourceContent
;
}
walkSourceContents
(
aFn
)
{
for
(
let
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
if
(
this
.
children
[
i
]
[
isSourceNode
]
)
{
this
.
children
[
i
]
.
walkSourceContents
(
aFn
)
;
}
}
const
sources
=
Object
.
keys
(
this
.
sourceContents
)
;
for
(
let
i
=
0
len
=
sources
.
length
;
i
<
len
;
i
+
+
)
{
aFn
(
util
.
fromSetString
(
sources
[
i
]
)
this
.
sourceContents
[
sources
[
i
]
]
)
;
}
}
toString
(
)
{
let
str
=
"
"
;
this
.
walk
(
function
(
chunk
)
{
str
+
=
chunk
;
}
)
;
return
str
;
}
toStringWithSourceMap
(
aArgs
)
{
const
generated
=
{
code
:
"
"
line
:
1
column
:
0
}
;
const
map
=
new
SourceMapGenerator
(
aArgs
)
;
let
sourceMappingActive
=
false
;
let
lastOriginalSource
=
null
;
let
lastOriginalLine
=
null
;
let
lastOriginalColumn
=
null
;
let
lastOriginalName
=
null
;
this
.
walk
(
function
(
chunk
original
)
{
generated
.
code
+
=
chunk
;
if
(
original
.
source
!
=
=
null
&
&
original
.
line
!
=
=
null
&
&
original
.
column
!
=
=
null
)
{
if
(
lastOriginalSource
!
=
=
original
.
source
|
|
lastOriginalLine
!
=
=
original
.
line
|
|
lastOriginalColumn
!
=
=
original
.
column
|
|
lastOriginalName
!
=
=
original
.
name
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
lastOriginalSource
=
original
.
source
;
lastOriginalLine
=
original
.
line
;
lastOriginalColumn
=
original
.
column
;
lastOriginalName
=
original
.
name
;
sourceMappingActive
=
true
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
}
)
;
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
for
(
let
idx
=
0
length
=
chunk
.
length
;
idx
<
length
;
idx
+
+
)
{
if
(
chunk
.
charCodeAt
(
idx
)
=
=
=
NEWLINE_CODE
)
{
generated
.
line
+
+
;
generated
.
column
=
0
;
if
(
idx
+
1
=
=
=
length
)
{
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
}
else
{
generated
.
column
+
+
;
}
}
}
)
;
this
.
walkSourceContents
(
function
(
sourceFile
sourceContent
)
{
map
.
setSourceContent
(
sourceFile
sourceContent
)
;
}
)
;
return
{
code
:
generated
.
code
map
}
;
}
}
exports
.
SourceNode
=
SourceNode
;
}
)
407
:
(
function
(
module
exports
)
{
function
assert
(
condition
message
)
{
if
(
!
condition
)
{
throw
new
Error
(
Assertion
failure
:
{
message
}
)
;
}
}
module
.
exports
=
assert
;
}
)
408
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
networkRequest
}
=
__webpack_require__
(
7
)
;
const
{
getSourceMap
setSourceMap
}
=
__webpack_require__
(
104
)
;
const
{
WasmRemap
}
=
__webpack_require__
(
409
)
;
const
{
SourceMapConsumer
}
=
__webpack_require__
(
60
)
;
const
{
convertToJSON
}
=
__webpack_require__
(
510
)
;
const
{
createConsumer
}
=
__webpack_require__
(
179
)
;
const
originalURLs
=
new
Set
(
)
;
function
clearOriginalURLs
(
)
{
originalURLs
.
clear
(
)
;
}
function
hasOriginalURL
(
url
)
{
return
originalURLs
.
has
(
url
)
;
}
function
_resolveSourceMapURL
(
source
)
{
const
{
url
=
"
"
sourceMapURL
=
"
"
}
=
source
;
if
(
!
url
)
{
return
{
sourceMapURL
baseURL
:
sourceMapURL
}
;
}
const
resolvedURL
=
new
URL
(
sourceMapURL
url
)
;
const
resolvedString
=
resolvedURL
.
toString
(
)
;
let
baseURL
=
resolvedString
;
if
(
resolvedURL
.
protocol
=
=
"
data
:
"
)
{
baseURL
=
url
;
}
return
{
sourceMapURL
:
resolvedString
baseURL
}
;
}
async
function
_resolveAndFetch
(
generatedSource
)
{
const
{
sourceMapURL
baseURL
}
=
_resolveSourceMapURL
(
generatedSource
)
;
let
fetched
=
await
networkRequest
(
sourceMapURL
{
loadFromCache
:
false
}
)
;
if
(
fetched
.
isDwarf
)
{
fetched
=
{
content
:
await
convertToJSON
(
fetched
.
content
)
}
;
}
let
map
=
await
createConsumer
(
fetched
.
content
baseURL
)
;
if
(
generatedSource
.
isWasm
)
{
map
=
new
WasmRemap
(
map
)
;
if
(
fetched
.
content
.
includes
(
"
x
-
scopes
"
)
)
{
const
parsedJSON
=
JSON
.
parse
(
fetched
.
content
)
;
map
.
xScopes
=
parsedJSON
[
"
x
-
scopes
"
]
;
}
}
if
(
map
&
&
map
.
sources
)
{
map
.
sources
.
forEach
(
url
=
>
originalURLs
.
add
(
url
)
)
;
}
return
map
;
}
function
fetchSourceMap
(
generatedSource
)
{
const
existingRequest
=
getSourceMap
(
generatedSource
.
id
)
;
if
(
existingRequest
)
{
return
existingRequest
;
}
if
(
!
generatedSource
.
sourceMapURL
)
{
return
null
;
}
const
req
=
_resolveAndFetch
(
generatedSource
)
;
setSourceMap
(
generatedSource
.
id
req
.
catch
(
(
)
=
>
null
)
)
;
return
req
;
}
module
.
exports
=
{
fetchSourceMap
hasOriginalURL
clearOriginalURLs
}
;
}
)
409
:
(
function
(
module
exports
)
{
class
WasmRemap
{
constructor
(
map
)
{
this
.
_map
=
map
;
this
.
version
=
map
.
version
;
this
.
file
=
map
.
file
;
this
.
_computeColumnSpans
=
false
;
}
get
sources
(
)
{
return
this
.
_map
.
sources
;
}
get
sourceRoot
(
)
{
return
this
.
_map
.
sourceRoot
;
}
get
names
(
)
{
return
this
.
_map
.
names
;
}
get
sourcesContent
(
)
{
return
this
.
_map
.
sourcesContent
;
}
get
mappings
(
)
{
throw
new
Error
(
"
not
supported
"
)
;
}
computeColumnSpans
(
)
{
this
.
_computeColumnSpans
=
true
;
}
originalPositionFor
(
generatedPosition
)
{
const
result
=
this
.
_map
.
originalPositionFor
(
{
line
:
1
column
:
generatedPosition
.
line
bias
:
generatedPosition
.
bias
}
)
;
return
result
;
}
_remapGeneratedPosition
(
position
)
{
const
generatedPosition
=
{
line
:
position
.
column
column
:
0
}
;
if
(
this
.
_computeColumnSpans
)
{
generatedPosition
.
lastColumn
=
0
;
}
return
generatedPosition
;
}
generatedPositionFor
(
originalPosition
)
{
const
position
=
this
.
_map
.
generatedPositionFor
(
originalPosition
)
;
return
this
.
_remapGeneratedPosition
(
position
)
;
}
allGeneratedPositionsFor
(
originalPosition
)
{
const
positions
=
this
.
_map
.
allGeneratedPositionsFor
(
originalPosition
)
;
return
positions
.
map
(
position
=
>
{
return
this
.
_remapGeneratedPosition
(
position
)
;
}
)
;
}
hasContentsOfAllSources
(
)
{
return
this
.
_map
.
hasContentsOfAllSources
(
)
;
}
sourceContentFor
(
source
returnNullOnMissing
)
{
return
this
.
_map
.
sourceContentFor
(
source
returnNullOnMissing
)
;
}
eachMapping
(
callback
context
order
)
{
this
.
_map
.
eachMapping
(
entry
=
>
{
const
{
source
generatedColumn
originalLine
originalColumn
name
}
=
entry
;
callback
(
{
source
generatedLine
:
generatedColumn
generatedColumn
:
0
lastGeneratedColumn
:
0
originalLine
originalColumn
name
}
)
;
}
context
order
)
;
}
}
exports
.
WasmRemap
=
WasmRemap
;
}
)
411
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
getWasmXScopes
}
=
__webpack_require__
(
510
)
;
const
{
getSourceMap
}
=
__webpack_require__
(
104
)
;
const
{
generatedToOriginalId
}
=
__webpack_require__
(
64
)
;
async
function
getOriginalStackFrames
(
generatedLocation
)
{
const
wasmXScopes
=
await
getWasmXScopes
(
generatedLocation
.
sourceId
{
getSourceMap
generatedToOriginalId
}
)
;
if
(
!
wasmXScopes
)
{
return
null
;
}
const
scopes
=
wasmXScopes
.
search
(
generatedLocation
)
;
if
(
scopes
.
length
=
=
=
0
)
{
console
.
warn
(
"
Something
wrong
with
debug
data
:
none
original
frames
found
"
)
;
return
null
;
}
return
scopes
;
}
module
.
exports
=
{
getOriginalStackFrames
}
;
}
)
510
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
convertToJSON
}
=
__webpack_require__
(
512
)
;
const
{
setAssetRootURL
}
=
__webpack_require__
(
511
)
;
const
{
getWasmXScopes
clearWasmXScopes
}
=
__webpack_require__
(
513
)
;
module
.
exports
=
{
convertToJSON
setAssetRootURL
getWasmXScopes
clearWasmXScopes
}
;
}
)
511
:
(
function
(
module
exports
)
{
let
root
;
function
setAssetRootURL
(
assetRoot
)
{
root
=
assetRoot
;
}
async
function
getDwarfToWasmData
(
name
)
{
if
(
!
root
)
{
throw
new
Error
(
No
wasm
path
-
Unable
to
resolve
{
name
}
)
;
}
const
response
=
await
fetch
(
{
root
}
/
dwarf_to_json
.
wasm
)
;
return
response
.
arrayBuffer
(
)
;
}
module
.
exports
=
{
setAssetRootURL
getDwarfToWasmData
}
;
}
)
512
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
getDwarfToWasmData
}
=
__webpack_require__
(
511
)
;
let
cachedWasmModule
;
let
utf8Decoder
;
function
convertDwarf
(
wasm
instance
)
{
const
{
memory
alloc_mem
free_mem
convert_dwarf
}
=
instance
.
exports
;
const
wasmPtr
=
alloc_mem
(
wasm
.
byteLength
)
;
new
Uint8Array
(
memory
.
buffer
wasmPtr
wasm
.
byteLength
)
.
set
(
new
Uint8Array
(
wasm
)
)
;
const
resultPtr
=
alloc_mem
(
12
)
;
const
enableXScopes
=
true
;
const
success
=
convert_dwarf
(
wasmPtr
wasm
.
byteLength
resultPtr
resultPtr
+
4
enableXScopes
)
;
free_mem
(
wasmPtr
)
;
const
resultView
=
new
DataView
(
memory
.
buffer
resultPtr
12
)
;
const
outputPtr
=
resultView
.
getUint32
(
0
true
)
outputLen
=
resultView
.
getUint32
(
4
true
)
;
free_mem
(
resultPtr
)
;
if
(
!
success
)
{
throw
new
Error
(
"
Unable
to
convert
from
DWARF
sections
"
)
;
}
if
(
!
utf8Decoder
)
{
utf8Decoder
=
new
TextDecoder
(
"
utf
-
8
"
)
;
}
const
output
=
utf8Decoder
.
decode
(
new
Uint8Array
(
memory
.
buffer
outputPtr
outputLen
)
)
;
free_mem
(
outputPtr
)
;
return
output
;
}
async
function
convertToJSON
(
buffer
)
{
cachedWasmModule
=
cachedWasmModule
|
|
loadConverterModule
(
)
;
return
convertDwarf
(
buffer
(
await
cachedWasmModule
)
)
;
}
async
function
loadConverterModule
(
)
{
const
wasm
=
await
getDwarfToWasmData
(
)
;
const
imports
=
{
}
;
const
{
instance
}
=
await
WebAssembly
.
instantiate
(
wasm
imports
)
;
return
instance
;
}
module
.
exports
=
{
convertToJSON
}
;
}
)
513
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
decodeExpr
}
=
__webpack_require__
(
514
)
;
const
xScopes
=
new
Map
(
)
;
function
indexLinkingNames
(
items
)
{
const
result
=
new
Map
(
)
;
let
queue
=
[
.
.
.
items
]
;
while
(
queue
.
length
>
0
)
{
const
item
=
queue
.
shift
(
)
;
if
(
"
uid
"
in
item
)
{
result
.
set
(
item
.
uid
item
)
;
}
else
if
(
"
linkage_name
"
in
item
)
{
result
.
set
(
item
.
linkage_name
item
)
;
}
if
(
"
children
"
in
item
)
{
queue
=
[
.
.
.
queue
.
.
.
item
.
children
]
;
}
}
return
result
;
}
function
getIndexedItem
(
index
key
)
{
if
(
typeof
key
=
=
=
"
object
"
&
&
key
!
=
null
)
{
return
index
.
get
(
key
.
uid
)
;
}
if
(
typeof
key
=
=
=
"
string
"
)
{
return
index
.
get
(
key
)
;
}
return
null
;
}
async
function
getXScopes
(
sourceId
getSourceMap
)
{
if
(
xScopes
.
has
(
sourceId
)
)
{
return
xScopes
.
get
(
sourceId
)
;
}
const
map
=
await
getSourceMap
(
sourceId
)
;
if
(
!
map
|
|
!
map
.
xScopes
)
{
xScopes
.
set
(
sourceId
null
)
;
return
null
;
}
const
{
code_section_offset
debug_info
}
=
map
.
xScopes
;
const
xScope
=
{
code_section_offset
debug_info
idIndex
:
indexLinkingNames
(
debug_info
)
sources
:
map
.
sources
}
;
xScopes
.
set
(
sourceId
xScope
)
;
return
xScope
;
}
function
isInRange
(
item
pc
)
{
if
(
"
ranges
"
in
item
)
{
return
item
.
ranges
.
some
(
r
=
>
r
[
0
]
<
=
pc
&
&
pc
<
r
[
1
]
)
;
}
if
(
"
high_pc
"
in
item
)
{
return
item
.
low_pc
<
=
pc
&
&
pc
<
item
.
high_pc
;
}
return
false
;
}
function
decodeExprAt
(
expr
pc
)
{
if
(
typeof
expr
=
=
=
"
string
"
)
{
return
decodeExpr
(
expr
)
;
}
const
foundAt
=
expr
.
find
(
i
=
>
i
.
range
[
0
]
<
=
pc
&
&
pc
<
i
.
range
[
1
]
)
;
return
foundAt
?
decodeExpr
(
foundAt
.
expr
)
:
null
;
}
function
getVariables
(
scope
pc
)
{
const
vars
=
scope
.
children
?
scope
.
children
.
reduce
(
(
result
item
)
=
>
{
switch
(
item
.
tag
)
{
case
"
variable
"
:
case
"
formal_parameter
"
:
result
.
push
(
{
name
:
item
.
name
|
|
"
"
expr
:
item
.
location
?
decodeExprAt
(
item
.
location
pc
)
:
null
}
)
;
break
;
case
"
lexical_block
"
:
const
tmp
=
getVariables
(
item
pc
)
;
result
=
[
.
.
.
tmp
.
vars
.
.
.
result
]
;
break
;
}
return
result
;
}
[
]
)
:
[
]
;
const
frameBase
=
scope
.
frame_base
?
decodeExpr
(
scope
.
frame_base
)
:
null
;
return
{
vars
frameBase
}
;
}
function
filterScopes
(
items
pc
lastItem
index
)
{
if
(
!
items
)
{
return
[
]
;
}
return
items
.
reduce
(
(
result
item
)
=
>
{
switch
(
item
.
tag
)
{
case
"
compile_unit
"
:
if
(
isInRange
(
item
pc
)
)
{
result
=
[
.
.
.
result
.
.
.
filterScopes
(
item
.
children
pc
lastItem
index
)
]
;
}
break
;
case
"
namespace
"
:
case
"
structure_type
"
:
case
"
union_type
"
:
result
=
[
.
.
.
result
.
.
.
filterScopes
(
item
.
children
pc
lastItem
index
)
]
;
break
;
case
"
subprogram
"
:
if
(
isInRange
(
item
pc
)
)
{
const
s
=
{
id
:
item
.
linkage_name
name
:
item
.
name
variables
:
getVariables
(
item
pc
)
}
;
result
=
[
.
.
.
result
s
.
.
.
filterScopes
(
item
.
children
pc
s
index
)
]
;
}
break
;
case
"
inlined_subroutine
"
:
if
(
isInRange
(
item
pc
)
)
{
const
linkedItem
=
getIndexedItem
(
index
item
.
abstract_origin
)
;
const
s
=
{
id
:
item
.
abstract_origin
name
:
linkedItem
?
linkedItem
.
name
:
void
0
variables
:
getVariables
(
item
pc
)
}
;
if
(
lastItem
)
{
lastItem
.
file
=
item
.
call_file
;
lastItem
.
line
=
item
.
call_line
;
}
result
=
[
.
.
.
result
s
.
.
.
filterScopes
(
item
.
children
pc
s
index
)
]
;
}
break
;
}
return
result
;
}
[
]
)
;
}
class
XScope
{
constructor
(
xScopeData
sourceMapContext
)
{
this
.
xScope
=
xScopeData
;
this
.
sourceMapContext
=
sourceMapContext
;
}
search
(
generatedLocation
)
{
const
{
code_section_offset
debug_info
sources
idIndex
}
=
this
.
xScope
;
const
pc
=
generatedLocation
.
line
-
(
code_section_offset
|
|
0
)
;
const
scopes
=
filterScopes
(
debug_info
pc
null
idIndex
)
;
scopes
.
reverse
(
)
;
return
scopes
.
map
(
i
=
>
{
if
(
!
(
"
file
"
in
i
)
)
{
return
{
displayName
:
i
.
name
|
|
"
"
variables
:
i
.
variables
}
;
}
const
sourceId
=
this
.
sourceMapContext
.
generatedToOriginalId
(
generatedLocation
.
sourceId
sources
[
i
.
file
|
|
0
]
)
;
return
{
displayName
:
i
.
name
|
|
"
"
variables
:
i
.
variables
location
:
{
line
:
i
.
line
|
|
0
sourceId
}
}
;
}
)
;
}
}
async
function
getWasmXScopes
(
sourceId
sourceMapContext
)
{
const
{
getSourceMap
}
=
sourceMapContext
;
const
xScopeData
=
await
getXScopes
(
sourceId
getSourceMap
)
;
if
(
!
xScopeData
)
{
return
null
;
}
return
new
XScope
(
xScopeData
sourceMapContext
)
;
}
function
clearWasmXScopes
(
)
{
xScopes
.
clear
(
)
;
}
module
.
exports
=
{
getWasmXScopes
clearWasmXScopes
}
;
}
)
514
:
(
function
(
module
exports
)
{
class
Value
{
constructor
(
val
)
{
this
.
val
=
val
;
}
toString
(
)
{
return
{
this
.
val
}
;
}
}
const
Int32Formatter
=
{
fromAddr
(
addr
)
{
return
(
new
DataView
(
memory0
.
buffer
)
.
getInt32
(
{
addr
}
true
)
)
;
}
fromValue
(
value
)
{
return
{
value
.
val
}
;
}
}
;
const
Uint32Formatter
=
{
fromAddr
(
addr
)
{
return
(
new
DataView
(
memory0
.
buffer
)
.
getUint32
(
{
addr
}
true
)
)
;
}
fromValue
(
value
)
{
return
(
{
value
.
val
}
>
>
>
0
)
;
}
}
;
function
createPieceFormatter
(
bytes
)
{
let
getter
;
switch
(
bytes
)
{
case
0
:
case
1
:
getter
=
"
getUint8
"
;
break
;
case
2
:
getter
=
"
getUint16
"
;
break
;
case
3
:
case
4
:
default
:
getter
=
"
getUint32
"
;
break
;
}
const
mask
=
(
1
<
<
8
*
bytes
)
-
1
;
return
{
fromAddr
(
addr
)
{
return
(
new
DataView
(
memory0
.
buffer
)
.
{
getter
}
(
{
addr
}
true
)
)
;
}
fromValue
(
value
)
{
return
(
(
{
value
.
val
}
&
{
mask
}
)
>
>
>
0
)
;
}
}
;
}
function
toJS
(
buf
typeFormatter
frame_base
=
"
fp
(
)
"
)
{
const
readU8
=
function
(
)
{
return
buf
[
i
+
+
]
;
}
;
const
readS8
=
function
(
)
{
return
readU8
(
)
<
<
24
>
>
24
;
}
;
const
readU16
=
function
(
)
{
const
w
=
buf
[
i
]
|
buf
[
i
+
1
]
<
<
8
;
i
+
=
2
;
return
w
;
}
;
const
readS16
=
function
(
)
{
return
readU16
(
)
<
<
16
>
>
16
;
}
;
const
readS32
=
function
(
)
{
const
w
=
buf
[
i
]
|
buf
[
i
+
1
]
<
<
8
|
buf
[
i
+
2
]
<
<
16
|
buf
[
i
+
3
]
<
<
24
;
i
+
=
4
;
return
w
;
}
;
const
readU32
=
function
(
)
{
return
readS32
(
)
>
>
>
0
;
}
;
const
readU
=
function
(
)
{
let
n
=
0
shift
=
0
b
;
while
(
(
b
=
readU8
(
)
)
&
0x80
)
{
n
|
=
(
b
&
0x7f
)
<
<
shift
;
shift
+
=
7
;
}
return
n
|
b
<
<
shift
;
}
;
const
readS
=
function
(
)
{
let
n
=
0
shift
=
0
b
;
while
(
(
b
=
readU8
(
)
)
&
0x80
)
{
n
|
=
(
b
&
0x7f
)
<
<
shift
;
shift
+
=
7
;
}
n
|
=
b
<
<
shift
;
shift
+
=
7
;
return
shift
>
32
?
n
<
<
32
-
shift
>
>
32
-
shift
:
n
;
}
;
const
popValue
=
function
(
formatter
)
{
const
loc
=
stack
.
pop
(
)
;
if
(
loc
instanceof
Value
)
{
return
formatter
.
fromValue
(
loc
)
;
}
return
formatter
.
fromAddr
(
loc
)
;
}
;
let
i
=
0
a
b
;
const
stack
=
[
frame_base
]
;
while
(
i
<
buf
.
length
)
{
const
code
=
buf
[
i
+
+
]
;
switch
(
code
)
{
case
0x03
:
stack
.
push
(
Uint32Formatter
.
fromAddr
(
readU32
(
)
)
)
;
break
;
case
0x08
:
stack
.
push
(
readU8
(
)
)
;
break
;
case
0x09
:
stack
.
push
(
readS8
(
)
)
;
break
;
case
0x0a
:
stack
.
push
(
readU16
(
)
)
;
break
;
case
0x0b
:
stack
.
push
(
readS16
(
)
)
;
break
;
case
0x0c
:
stack
.
push
(
readU32
(
)
)
;
break
;
case
0x0d
:
stack
.
push
(
readS32
(
)
)
;
break
;
case
0x10
:
stack
.
push
(
readU
(
)
)
;
break
;
case
0x11
:
stack
.
push
(
readS
(
)
)
;
break
;
case
0x1c
:
b
=
stack
.
pop
(
)
;
a
=
stack
.
pop
(
)
;
stack
.
push
(
{
a
}
-
{
b
}
)
;
break
;
case
0x22
:
b
=
stack
.
pop
(
)
;
a
=
stack
.
pop
(
)
;
stack
.
push
(
{
a
}
+
{
b
}
)
;
break
;
case
0x23
:
b
=
readU
(
)
;
a
=
stack
.
pop
(
)
;
stack
.
push
(
{
a
}
+
{
b
}
)
;
break
;
case
0x30
:
case
0x31
:
case
0x32
:
case
0x33
:
case
0x34
:
case
0x35
:
case
0x36
:
case
0x37
:
case
0x38
:
case
0x39
:
case
0x3a
:
case
0x3b
:
case
0x3c
:
case
0x3d
:
case
0x3e
:
case
0x3f
:
case
0x40
:
case
0x41
:
case
0x42
:
case
0x43
:
case
0x44
:
case
0x45
:
case
0x46
:
case
0x47
:
case
0x48
:
case
0x49
:
case
0x4a
:
case
0x4b
:
case
0x4c
:
case
0x4d
:
case
0x4e
:
case
0x4f
:
stack
.
push
(
{
code
-
0x30
}
)
;
break
;
case
0x93
:
{
a
=
readU
(
)
;
const
formatter
=
createPieceFormatter
(
a
)
;
stack
.
push
(
popValue
(
formatter
)
)
;
break
;
}
case
0x9f
:
stack
.
push
(
new
Value
(
stack
.
pop
(
)
)
)
;
break
;
case
0xf6
:
case
0xed
:
b
=
readU
(
)
;
a
=
readS
(
)
;
switch
(
b
)
{
case
0
:
stack
.
push
(
var
{
a
}
)
;
break
;
case
1
:
stack
.
push
(
global
{
a
}
)
;
break
;
default
:
stack
.
push
(
ti
{
b
}
(
{
a
}
)
)
;
break
;
}
break
;
default
:
return
null
;
}
}
return
popValue
(
typeFormatter
)
;
}
function
decodeExpr
(
expr
)
{
if
(
expr
.
includes
(
"
/
/
"
)
)
{
expr
=
expr
.
slice
(
0
expr
.
indexOf
(
"
/
/
"
)
)
.
trim
(
)
;
}
const
code
=
new
Uint8Array
(
expr
.
length
>
>
1
)
;
for
(
let
i
=
0
;
i
<
code
.
length
;
i
+
+
)
{
code
[
i
]
=
parseInt
(
expr
.
substr
(
i
<
<
1
2
)
16
)
;
}
const
typeFormatter
=
Int32Formatter
;
return
toJS
(
code
typeFormatter
)
|
|
dwarf
(
"
{
expr
}
"
)
;
}
module
.
exports
=
{
decodeExpr
}
;
}
)
515
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
SourceMapConsumer
}
=
__webpack_require__
(
60
)
;
const
{
setAssetRootURL
:
wasmDwarfSetAssetRootURL
}
=
__webpack_require__
(
510
)
;
function
setAssetRootURL
(
assetRoot
)
{
const
root
=
assetRoot
.
replace
(
/
\
/
/
"
"
)
;
wasmDwarfSetAssetRootURL
(
root
)
;
SourceMapConsumer
.
initialize
(
{
"
lib
/
mappings
.
wasm
"
:
{
root
}
/
source
-
map
-
mappings
.
wasm
}
)
;
}
module
.
exports
=
{
setAssetRootURL
}
;
}
)
523
:
(
function
(
module
exports
)
{
module
.
exports
=
(
(
)
=
>
{
let
factory
;
function
define
(
.
.
.
args
)
{
if
(
factory
)
{
throw
new
Error
(
"
expected
a
single
define
call
"
)
;
}
if
(
args
.
length
!
=
=
2
|
|
!
Array
.
isArray
(
args
[
0
]
)
|
|
args
[
0
]
.
length
!
=
=
0
|
|
typeof
args
[
1
]
!
=
=
"
function
"
)
{
throw
new
Error
(
"
whatwg
-
url
had
unexpected
factory
arguments
.
"
)
;
}
factory
=
args
[
1
]
;
}
define
.
amd
=
true
;
const
existingDefine
=
Object
.
getOwnPropertyDescriptor
(
globalThis
"
define
"
)
;
globalThis
.
define
=
define
;
let
err
;
try
{
importScripts
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
whatwg
-
url
.
js
"
)
;
if
(
!
factory
)
{
throw
new
Error
(
"
Failed
to
load
whatwg
-
url
factory
"
)
;
}
}
finally
{
if
(
existingDefine
)
{
Object
.
defineProperty
(
globalThis
"
define
"
existingDefine
)
;
}
else
{
delete
globalThis
.
define
;
}
}
return
factory
(
)
;
}
)
(
)
;
}
)
60
:
(
function
(
module
exports
__webpack_require__
)
{
exports
.
SourceMapGenerator
=
__webpack_require__
(
171
)
.
SourceMapGenerator
;
exports
.
SourceMapConsumer
=
__webpack_require__
(
403
)
.
SourceMapConsumer
;
exports
.
SourceNode
=
__webpack_require__
(
406
)
.
SourceNode
;
}
)
61
:
(
function
(
module
exports
__webpack_require__
)
{
const
URL
=
__webpack_require__
(
393
)
;
function
getArg
(
aArgs
aName
aDefaultValue
)
{
if
(
aName
in
aArgs
)
{
return
aArgs
[
aName
]
;
}
else
if
(
arguments
.
length
=
=
=
3
)
{
return
aDefaultValue
;
}
throw
new
Error
(
'
"
'
+
aName
+
'
"
is
a
required
argument
.
'
)
;
}
exports
.
getArg
=
getArg
;
const
supportsNullProto
=
(
function
(
)
{
const
obj
=
Object
.
create
(
null
)
;
return
!
(
"
__proto__
"
in
obj
)
;
}
(
)
)
;
function
identity
(
s
)
{
return
s
;
}
function
toSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
"
"
+
aStr
;
}
return
aStr
;
}
exports
.
toSetString
=
supportsNullProto
?
identity
:
toSetString
;
function
fromSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
aStr
.
slice
(
1
)
;
}
return
aStr
;
}
exports
.
fromSetString
=
supportsNullProto
?
identity
:
fromSetString
;
function
isProtoString
(
s
)
{
if
(
!
s
)
{
return
false
;
}
const
length
=
s
.
length
;
if
(
length
<
9
)
{
return
false
;
}
if
(
s
.
charCodeAt
(
length
-
1
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
2
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
3
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
4
)
!
=
=
116
|
|
s
.
charCodeAt
(
length
-
5
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
6
)
!
=
=
114
|
|
s
.
charCodeAt
(
length
-
7
)
!
=
=
112
|
|
s
.
charCodeAt
(
length
-
8
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
9
)
!
=
=
95
)
{
return
false
;
}
for
(
let
i
=
length
-
10
;
i
>
=
0
;
i
-
-
)
{
if
(
s
.
charCodeAt
(
i
)
!
=
=
36
)
{
return
false
;
}
}
return
true
;
}
function
strcmp
(
aStr1
aStr2
)
{
if
(
aStr1
=
=
=
aStr2
)
{
return
0
;
}
if
(
aStr1
=
=
=
null
)
{
return
1
;
}
if
(
aStr2
=
=
=
null
)
{
return
-
1
;
}
if
(
aStr1
>
aStr2
)
{
return
1
;
}
return
-
1
;
}
function
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
{
let
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
strcmp
(
mappingA
.
source
mappingB
.
source
)
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
strcmp
(
mappingA
.
name
mappingB
.
name
)
;
}
exports
.
compareByGeneratedPositionsInflated
=
compareByGeneratedPositionsInflated
;
function
parseSourceMapInput
(
str
)
{
return
JSON
.
parse
(
str
.
replace
(
/
^
\
)
]
}
'
[
^
\
n
]
*
\
n
/
"
"
)
)
;
}
exports
.
parseSourceMapInput
=
parseSourceMapInput
;
const
PROTOCOL
=
"
http
:
"
;
const
PROTOCOL_AND_HOST
=
{
PROTOCOL
}
/
/
host
;
function
createSafeHandler
(
cb
)
{
return
input
=
>
{
const
type
=
getURLType
(
input
)
;
const
base
=
buildSafeBase
(
input
)
;
const
url
=
new
URL
(
input
base
)
;
cb
(
url
)
;
const
result
=
url
.
toString
(
)
;
if
(
type
=
=
=
"
absolute
"
)
{
return
result
;
}
else
if
(
type
=
=
=
"
scheme
-
relative
"
)
{
return
result
.
slice
(
PROTOCOL
.
length
)
;
}
else
if
(
type
=
=
=
"
path
-
absolute
"
)
{
return
result
.
slice
(
PROTOCOL_AND_HOST
.
length
)
;
}
return
computeRelativeURL
(
base
result
)
;
}
;
}
function
withBase
(
url
base
)
{
return
new
URL
(
url
base
)
.
toString
(
)
;
}
function
buildUniqueSegment
(
prefix
str
)
{
let
id
=
0
;
do
{
const
ident
=
prefix
+
(
id
+
+
)
;
if
(
str
.
indexOf
(
ident
)
=
=
=
-
1
)
return
ident
;
}
while
(
true
)
;
}
function
buildSafeBase
(
str
)
{
const
maxDotParts
=
str
.
split
(
"
.
.
"
)
.
length
-
1
;
const
segment
=
buildUniqueSegment
(
"
p
"
str
)
;
let
base
=
{
PROTOCOL_AND_HOST
}
/
;
for
(
let
i
=
0
;
i
<
maxDotParts
;
i
+
+
)
{
base
+
=
{
segment
}
/
;
}
return
base
;
}
const
ABSOLUTE_SCHEME
=
/
^
[
A
-
Za
-
z0
-
9
\
+
\
-
\
.
]
+
:
/
;
function
getURLType
(
url
)
{
if
(
url
[
0
]
=
=
=
"
/
"
)
{
if
(
url
[
1
]
=
=
=
"
/
"
)
return
"
scheme
-
relative
"
;
return
"
path
-
absolute
"
;
}
return
ABSOLUTE_SCHEME
.
test
(
url
)
?
"
absolute
"
:
"
path
-
relative
"
;
}
function
computeRelativeURL
(
rootURL
targetURL
)
{
if
(
typeof
rootURL
=
=
=
"
string
"
)
rootURL
=
new
URL
(
rootURL
)
;
if
(
typeof
targetURL
=
=
=
"
string
"
)
targetURL
=
new
URL
(
targetURL
)
;
const
targetParts
=
targetURL
.
pathname
.
split
(
"
/
"
)
;
const
rootParts
=
rootURL
.
pathname
.
split
(
"
/
"
)
;
if
(
rootParts
.
length
>
0
&
&
!
rootParts
[
rootParts
.
length
-
1
]
)
{
rootParts
.
pop
(
)
;
}
while
(
targetParts
.
length
>
0
&
&
rootParts
.
length
>
0
&
&
targetParts
[
0
]
=
=
=
rootParts
[
0
]
)
{
targetParts
.
shift
(
)
;
rootParts
.
shift
(
)
;
}
const
relativePath
=
rootParts
.
map
(
(
)
=
>
"
.
.
"
)
.
concat
(
targetParts
)
.
join
(
"
/
"
)
;
return
relativePath
+
targetURL
.
search
+
targetURL
.
hash
;
}
const
ensureDirectory
=
createSafeHandler
(
url
=
>
{
url
.
pathname
=
url
.
pathname
.
replace
(
/
\
/
?
/
"
/
"
)
;
}
)
;
const
trimFilename
=
createSafeHandler
(
url
=
>
{
url
.
href
=
new
URL
(
"
.
"
url
.
toString
(
)
)
.
toString
(
)
;
}
)
;
const
normalize
=
createSafeHandler
(
url
=
>
{
}
)
;
exports
.
normalize
=
normalize
;
function
join
(
aRoot
aPath
)
{
const
pathType
=
getURLType
(
aPath
)
;
const
rootType
=
getURLType
(
aRoot
)
;
aRoot
=
ensureDirectory
(
aRoot
)
;
if
(
pathType
=
=
=
"
absolute
"
)
{
return
withBase
(
aPath
undefined
)
;
}
if
(
rootType
=
=
=
"
absolute
"
)
{
return
withBase
(
aPath
aRoot
)
;
}
if
(
pathType
=
=
=
"
scheme
-
relative
"
)
{
return
normalize
(
aPath
)
;
}
if
(
rootType
=
=
=
"
scheme
-
relative
"
)
{
return
withBase
(
aPath
withBase
(
aRoot
PROTOCOL_AND_HOST
)
)
.
slice
(
PROTOCOL
.
length
)
;
}
if
(
pathType
=
=
=
"
path
-
absolute
"
)
{
return
normalize
(
aPath
)
;
}
if
(
rootType
=
=
=
"
path
-
absolute
"
)
{
return
withBase
(
aPath
withBase
(
aRoot
PROTOCOL_AND_HOST
)
)
.
slice
(
PROTOCOL_AND_HOST
.
length
)
;
}
const
base
=
buildSafeBase
(
aPath
+
aRoot
)
;
const
newPath
=
withBase
(
aPath
withBase
(
aRoot
base
)
)
;
return
computeRelativeURL
(
base
newPath
)
;
}
exports
.
join
=
join
;
function
relative
(
rootURL
targetURL
)
{
const
result
=
relativeIfPossible
(
rootURL
targetURL
)
;
return
typeof
result
=
=
=
"
string
"
?
result
:
normalize
(
targetURL
)
;
}
exports
.
relative
=
relative
;
function
relativeIfPossible
(
rootURL
targetURL
)
{
const
urlType
=
getURLType
(
rootURL
)
;
if
(
urlType
!
=
=
getURLType
(
targetURL
)
)
{
return
null
;
}
const
base
=
buildSafeBase
(
rootURL
+
targetURL
)
;
const
root
=
new
URL
(
rootURL
base
)
;
const
target
=
new
URL
(
targetURL
base
)
;
try
{
new
URL
(
"
"
target
.
toString
(
)
)
;
}
catch
(
err
)
{
return
null
;
}
if
(
target
.
protocol
!
=
=
root
.
protocol
|
|
target
.
user
!
=
=
root
.
user
|
|
target
.
password
!
=
=
root
.
password
|
|
target
.
hostname
!
=
=
root
.
hostname
|
|
target
.
port
!
=
=
root
.
port
)
{
return
null
;
}
return
computeRelativeURL
(
root
target
)
;
}
function
computeSourceURL
(
sourceRoot
sourceURL
sourceMapURL
)
{
if
(
sourceRoot
&
&
getURLType
(
sourceURL
)
=
=
=
"
path
-
absolute
"
)
{
sourceURL
=
sourceURL
.
replace
(
/
^
\
/
/
"
"
)
;
}
let
url
=
normalize
(
sourceURL
|
|
"
"
)
;
if
(
sourceRoot
)
url
=
join
(
sourceRoot
url
)
;
if
(
sourceMapURL
)
url
=
join
(
trimFilename
(
sourceMapURL
)
url
)
;
return
url
;
}
exports
.
computeSourceURL
=
computeSourceURL
;
}
)
64
:
(
function
(
module
exports
__webpack_require__
)
{
const
md5
=
__webpack_require__
(
105
)
;
function
originalToGeneratedId
(
sourceId
)
{
if
(
isGeneratedId
(
sourceId
)
)
{
return
sourceId
;
}
const
lastIndex
=
sourceId
.
lastIndexOf
(
"
/
originalSource
"
)
;
return
lastIndex
!
=
=
-
1
?
sourceId
.
slice
(
0
lastIndex
)
:
"
"
;
}
const
getMd5
=
memoize
(
url
=
>
md5
(
url
)
)
;
function
generatedToOriginalId
(
generatedId
url
)
{
return
{
generatedId
}
/
originalSource
-
{
getMd5
(
url
)
}
;
}
function
isOriginalId
(
id
)
{
return
id
.
includes
(
"
/
originalSource
"
)
;
}
function
isGeneratedId
(
id
)
{
return
!
isOriginalId
(
id
)
;
}
function
trimUrlQuery
(
url
)
{
const
length
=
url
.
length
;
for
(
let
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
url
[
i
]
=
=
=
"
?
"
|
|
url
[
i
]
=
=
=
"
&
"
|
|
url
[
i
]
=
=
=
"
#
"
)
{
return
url
.
slice
(
0
i
)
;
}
}
return
url
;
}
const
contentMap
=
{
js
:
"
text
/
javascript
"
jsm
:
"
text
/
javascript
"
mjs
:
"
text
/
javascript
"
ts
:
"
text
/
typescript
"
tsx
:
"
text
/
typescript
-
jsx
"
jsx
:
"
text
/
jsx
"
vue
:
"
text
/
vue
"
coffee
:
"
text
/
coffeescript
"
elm
:
"
text
/
elm
"
cljc
:
"
text
/
x
-
clojure
"
cljs
:
"
text
/
x
-
clojurescript
"
}
;
function
getContentType
(
url
)
{
url
=
trimUrlQuery
(
url
)
;
const
dot
=
url
.
lastIndexOf
(
"
.
"
)
;
if
(
dot
>
=
0
)
{
const
name
=
url
.
substring
(
dot
+
1
)
;
if
(
name
in
contentMap
)
{
return
contentMap
[
name
]
;
}
}
return
"
text
/
plain
"
;
}
function
memoize
(
func
)
{
const
map
=
new
Map
(
)
;
return
arg
=
>
{
if
(
map
.
has
(
arg
)
)
{
return
map
.
get
(
arg
)
;
}
const
result
=
func
(
arg
)
;
map
.
set
(
arg
result
)
;
return
result
;
}
;
}
module
.
exports
=
{
originalToGeneratedId
generatedToOriginalId
isOriginalId
isGeneratedId
getContentType
contentMapForTesting
:
contentMap
}
;
}
)
7
:
(
function
(
module
exports
__webpack_require__
)
{
const
networkRequest
=
__webpack_require__
(
13
)
;
const
workerUtils
=
__webpack_require__
(
14
)
;
module
.
exports
=
{
networkRequest
workerUtils
}
;
}
)
}
)
;
}
)
;
