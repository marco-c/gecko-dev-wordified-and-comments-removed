(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
]
factory
)
;
else
{
var
a
=
factory
(
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
this
function
(
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
exports
:
{
}
id
:
moduleId
loaded
:
false
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
p
=
"
"
;
return
__webpack_require__
(
0
)
;
}
)
(
[
function
(
module
exports
__webpack_require__
)
{
const
{
getOriginalURLs
getGeneratedLocation
getOriginalLocation
getOriginalSourceText
hasMappedSource
applySourceMap
clearSourceMaps
}
=
__webpack_require__
(
9
)
;
const
{
workerUtils
:
{
workerHandler
}
}
=
__webpack_require__
(
6
)
;
self
.
onmessage
=
workerHandler
(
{
getOriginalURLs
getGeneratedLocation
getOriginalLocation
getOriginalSourceText
hasMappedSource
applySourceMap
clearSourceMaps
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
const
md5
=
__webpack_require__
(
2
)
;
function
originalToGeneratedId
(
originalId
)
{
const
match
=
originalId
.
match
(
/
(
.
*
)
\
/
originalSource
/
)
;
return
match
?
match
[
1
]
:
"
"
;
}
function
generatedToOriginalId
(
generatedId
url
)
{
return
{
generatedId
}
/
originalSource
-
{
md5
(
url
)
}
;
}
function
isOriginalId
(
id
)
{
return
!
!
id
.
match
(
/
\
/
originalSource
/
)
;
}
function
isGeneratedId
(
id
)
{
return
!
isOriginalId
(
id
)
;
}
function
trimUrlQuery
(
url
)
{
let
length
=
url
.
length
;
let
q1
=
url
.
indexOf
(
"
?
"
)
;
let
q2
=
url
.
indexOf
(
"
&
"
)
;
let
q3
=
url
.
indexOf
(
"
#
"
)
;
let
q
=
Math
.
min
(
q1
!
=
-
1
?
q1
:
length
q2
!
=
-
1
?
q2
:
length
q3
!
=
-
1
?
q3
:
length
)
;
return
url
.
slice
(
0
q
)
;
}
const
contentMap
=
{
"
js
"
:
"
text
/
javascript
"
"
jsm
"
:
"
text
/
javascript
"
"
ts
"
:
"
text
/
typescript
"
"
tsx
"
:
"
text
/
typescript
-
jsx
"
"
jsx
"
:
"
text
/
jsx
"
"
coffee
"
:
"
text
/
coffeescript
"
"
elm
"
:
"
text
/
elm
"
"
cljs
"
:
"
text
/
x
-
clojure
"
}
;
function
getContentType
(
url
)
{
url
=
trimUrlQuery
(
url
)
;
let
dot
=
url
.
lastIndexOf
(
"
.
"
)
;
if
(
dot
>
=
0
)
{
let
name
=
url
.
substring
(
dot
+
1
)
;
if
(
name
in
contentMap
)
{
return
contentMap
[
name
]
;
}
}
return
"
text
/
plain
"
;
}
module
.
exports
=
{
originalToGeneratedId
generatedToOriginalId
isOriginalId
isGeneratedId
getContentType
contentMapForTesting
:
contentMap
}
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
crypt
=
__webpack_require__
(
3
)
utf8
=
__webpack_require__
(
4
)
.
utf8
isBuffer
=
__webpack_require__
(
5
)
bin
=
__webpack_require__
(
4
)
.
bin
md5
=
function
(
message
options
)
{
if
(
message
.
constructor
=
=
String
)
if
(
options
&
&
options
.
encoding
=
=
=
'
binary
'
)
message
=
bin
.
stringToBytes
(
message
)
;
else
message
=
utf8
.
stringToBytes
(
message
)
;
else
if
(
isBuffer
(
message
)
)
message
=
Array
.
prototype
.
slice
.
call
(
message
0
)
;
else
if
(
!
Array
.
isArray
(
message
)
)
message
=
message
.
toString
(
)
;
var
m
=
crypt
.
bytesToWords
(
message
)
l
=
message
.
length
*
8
a
=
1732584193
b
=
-
271733879
c
=
-
1732584194
d
=
271733878
;
for
(
var
i
=
0
;
i
<
m
.
length
;
i
+
+
)
{
m
[
i
]
=
(
(
m
[
i
]
<
<
8
)
|
(
m
[
i
]
>
>
>
24
)
)
&
0x00FF00FF
|
(
(
m
[
i
]
<
<
24
)
|
(
m
[
i
]
>
>
>
8
)
)
&
0xFF00FF00
;
}
m
[
l
>
>
>
5
]
|
=
0x80
<
<
(
l
%
32
)
;
m
[
(
(
(
l
+
64
)
>
>
>
9
)
<
<
4
)
+
14
]
=
l
;
var
FF
=
md5
.
_ff
GG
=
md5
.
_gg
HH
=
md5
.
_hh
II
=
md5
.
_ii
;
for
(
var
i
=
0
;
i
<
m
.
length
;
i
+
=
16
)
{
var
aa
=
a
bb
=
b
cc
=
c
dd
=
d
;
a
=
FF
(
a
b
c
d
m
[
i
+
0
]
7
-
680876936
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
1
]
12
-
389564586
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
2
]
17
606105819
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
3
]
22
-
1044525330
)
;
a
=
FF
(
a
b
c
d
m
[
i
+
4
]
7
-
176418897
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
5
]
12
1200080426
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
6
]
17
-
1473231341
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
7
]
22
-
45705983
)
;
a
=
FF
(
a
b
c
d
m
[
i
+
8
]
7
1770035416
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
9
]
12
-
1958414417
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
10
]
17
-
42063
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
11
]
22
-
1990404162
)
;
a
=
FF
(
a
b
c
d
m
[
i
+
12
]
7
1804603682
)
;
d
=
FF
(
d
a
b
c
m
[
i
+
13
]
12
-
40341101
)
;
c
=
FF
(
c
d
a
b
m
[
i
+
14
]
17
-
1502002290
)
;
b
=
FF
(
b
c
d
a
m
[
i
+
15
]
22
1236535329
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
1
]
5
-
165796510
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
6
]
9
-
1069501632
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
11
]
14
643717713
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
0
]
20
-
373897302
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
5
]
5
-
701558691
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
10
]
9
38016083
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
15
]
14
-
660478335
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
4
]
20
-
405537848
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
9
]
5
568446438
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
14
]
9
-
1019803690
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
3
]
14
-
187363961
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
8
]
20
1163531501
)
;
a
=
GG
(
a
b
c
d
m
[
i
+
13
]
5
-
1444681467
)
;
d
=
GG
(
d
a
b
c
m
[
i
+
2
]
9
-
51403784
)
;
c
=
GG
(
c
d
a
b
m
[
i
+
7
]
14
1735328473
)
;
b
=
GG
(
b
c
d
a
m
[
i
+
12
]
20
-
1926607734
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
5
]
4
-
378558
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
8
]
11
-
2022574463
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
11
]
16
1839030562
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
14
]
23
-
35309556
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
1
]
4
-
1530992060
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
4
]
11
1272893353
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
7
]
16
-
155497632
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
10
]
23
-
1094730640
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
13
]
4
681279174
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
0
]
11
-
358537222
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
3
]
16
-
722521979
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
6
]
23
76029189
)
;
a
=
HH
(
a
b
c
d
m
[
i
+
9
]
4
-
640364487
)
;
d
=
HH
(
d
a
b
c
m
[
i
+
12
]
11
-
421815835
)
;
c
=
HH
(
c
d
a
b
m
[
i
+
15
]
16
530742520
)
;
b
=
HH
(
b
c
d
a
m
[
i
+
2
]
23
-
995338651
)
;
a
=
II
(
a
b
c
d
m
[
i
+
0
]
6
-
198630844
)
;
d
=
II
(
d
a
b
c
m
[
i
+
7
]
10
1126891415
)
;
c
=
II
(
c
d
a
b
m
[
i
+
14
]
15
-
1416354905
)
;
b
=
II
(
b
c
d
a
m
[
i
+
5
]
21
-
57434055
)
;
a
=
II
(
a
b
c
d
m
[
i
+
12
]
6
1700485571
)
;
d
=
II
(
d
a
b
c
m
[
i
+
3
]
10
-
1894986606
)
;
c
=
II
(
c
d
a
b
m
[
i
+
10
]
15
-
1051523
)
;
b
=
II
(
b
c
d
a
m
[
i
+
1
]
21
-
2054922799
)
;
a
=
II
(
a
b
c
d
m
[
i
+
8
]
6
1873313359
)
;
d
=
II
(
d
a
b
c
m
[
i
+
15
]
10
-
30611744
)
;
c
=
II
(
c
d
a
b
m
[
i
+
6
]
15
-
1560198380
)
;
b
=
II
(
b
c
d
a
m
[
i
+
13
]
21
1309151649
)
;
a
=
II
(
a
b
c
d
m
[
i
+
4
]
6
-
145523070
)
;
d
=
II
(
d
a
b
c
m
[
i
+
11
]
10
-
1120210379
)
;
c
=
II
(
c
d
a
b
m
[
i
+
2
]
15
718787259
)
;
b
=
II
(
b
c
d
a
m
[
i
+
9
]
21
-
343485551
)
;
a
=
(
a
+
aa
)
>
>
>
0
;
b
=
(
b
+
bb
)
>
>
>
0
;
c
=
(
c
+
cc
)
>
>
>
0
;
d
=
(
d
+
dd
)
>
>
>
0
;
}
return
crypt
.
endian
(
[
a
b
c
d
]
)
;
}
;
md5
.
_ff
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
b
&
c
|
~
b
&
d
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_gg
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
b
&
d
|
c
&
~
d
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_hh
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
b
^
c
^
d
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_ii
=
function
(
a
b
c
d
x
s
t
)
{
var
n
=
a
+
(
c
^
(
b
|
~
d
)
)
+
(
x
>
>
>
0
)
+
t
;
return
(
(
n
<
<
s
)
|
(
n
>
>
>
(
32
-
s
)
)
)
+
b
;
}
;
md5
.
_blocksize
=
16
;
md5
.
_digestsize
=
16
;
module
.
exports
=
function
(
message
options
)
{
if
(
message
=
=
=
undefined
|
|
message
=
=
=
null
)
throw
new
Error
(
'
Illegal
argument
'
+
message
)
;
var
digestbytes
=
crypt
.
wordsToBytes
(
md5
(
message
options
)
)
;
return
options
&
&
options
.
asBytes
?
digestbytes
:
options
&
&
options
.
asString
?
bin
.
bytesToString
(
digestbytes
)
:
crypt
.
bytesToHex
(
digestbytes
)
;
}
;
}
)
(
)
;
}
function
(
module
exports
)
{
(
function
(
)
{
var
base64map
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
crypt
=
{
rotl
:
function
(
n
b
)
{
return
(
n
<
<
b
)
|
(
n
>
>
>
(
32
-
b
)
)
;
}
rotr
:
function
(
n
b
)
{
return
(
n
<
<
(
32
-
b
)
)
|
(
n
>
>
>
b
)
;
}
endian
:
function
(
n
)
{
if
(
n
.
constructor
=
=
Number
)
{
return
crypt
.
rotl
(
n
8
)
&
0x00FF00FF
|
crypt
.
rotl
(
n
24
)
&
0xFF00FF00
;
}
for
(
var
i
=
0
;
i
<
n
.
length
;
i
+
+
)
n
[
i
]
=
crypt
.
endian
(
n
[
i
]
)
;
return
n
;
}
randomBytes
:
function
(
n
)
{
for
(
var
bytes
=
[
]
;
n
>
0
;
n
-
-
)
bytes
.
push
(
Math
.
floor
(
Math
.
random
(
)
*
256
)
)
;
return
bytes
;
}
bytesToWords
:
function
(
bytes
)
{
for
(
var
words
=
[
]
i
=
0
b
=
0
;
i
<
bytes
.
length
;
i
+
+
b
+
=
8
)
words
[
b
>
>
>
5
]
|
=
bytes
[
i
]
<
<
(
24
-
b
%
32
)
;
return
words
;
}
wordsToBytes
:
function
(
words
)
{
for
(
var
bytes
=
[
]
b
=
0
;
b
<
words
.
length
*
32
;
b
+
=
8
)
bytes
.
push
(
(
words
[
b
>
>
>
5
]
>
>
>
(
24
-
b
%
32
)
)
&
0xFF
)
;
return
bytes
;
}
bytesToHex
:
function
(
bytes
)
{
for
(
var
hex
=
[
]
i
=
0
;
i
<
bytes
.
length
;
i
+
+
)
{
hex
.
push
(
(
bytes
[
i
]
>
>
>
4
)
.
toString
(
16
)
)
;
hex
.
push
(
(
bytes
[
i
]
&
0xF
)
.
toString
(
16
)
)
;
}
return
hex
.
join
(
'
'
)
;
}
hexToBytes
:
function
(
hex
)
{
for
(
var
bytes
=
[
]
c
=
0
;
c
<
hex
.
length
;
c
+
=
2
)
bytes
.
push
(
parseInt
(
hex
.
substr
(
c
2
)
16
)
)
;
return
bytes
;
}
bytesToBase64
:
function
(
bytes
)
{
for
(
var
base64
=
[
]
i
=
0
;
i
<
bytes
.
length
;
i
+
=
3
)
{
var
triplet
=
(
bytes
[
i
]
<
<
16
)
|
(
bytes
[
i
+
1
]
<
<
8
)
|
bytes
[
i
+
2
]
;
for
(
var
j
=
0
;
j
<
4
;
j
+
+
)
if
(
i
*
8
+
j
*
6
<
=
bytes
.
length
*
8
)
base64
.
push
(
base64map
.
charAt
(
(
triplet
>
>
>
6
*
(
3
-
j
)
)
&
0x3F
)
)
;
else
base64
.
push
(
'
=
'
)
;
}
return
base64
.
join
(
'
'
)
;
}
base64ToBytes
:
function
(
base64
)
{
base64
=
base64
.
replace
(
/
[
^
A
-
Z0
-
9
+
\
/
]
/
ig
'
'
)
;
for
(
var
bytes
=
[
]
i
=
0
imod4
=
0
;
i
<
base64
.
length
;
imod4
=
+
+
i
%
4
)
{
if
(
imod4
=
=
0
)
continue
;
bytes
.
push
(
(
(
base64map
.
indexOf
(
base64
.
charAt
(
i
-
1
)
)
&
(
Math
.
pow
(
2
-
2
*
imod4
+
8
)
-
1
)
)
<
<
(
imod4
*
2
)
)
|
(
base64map
.
indexOf
(
base64
.
charAt
(
i
)
)
>
>
>
(
6
-
imod4
*
2
)
)
)
;
}
return
bytes
;
}
}
;
module
.
exports
=
crypt
;
}
)
(
)
;
}
function
(
module
exports
)
{
var
charenc
=
{
utf8
:
{
stringToBytes
:
function
(
str
)
{
return
charenc
.
bin
.
stringToBytes
(
unescape
(
encodeURIComponent
(
str
)
)
)
;
}
bytesToString
:
function
(
bytes
)
{
return
decodeURIComponent
(
escape
(
charenc
.
bin
.
bytesToString
(
bytes
)
)
)
;
}
}
bin
:
{
stringToBytes
:
function
(
str
)
{
for
(
var
bytes
=
[
]
i
=
0
;
i
<
str
.
length
;
i
+
+
)
bytes
.
push
(
str
.
charCodeAt
(
i
)
&
0xFF
)
;
return
bytes
;
}
bytesToString
:
function
(
bytes
)
{
for
(
var
str
=
[
]
i
=
0
;
i
<
bytes
.
length
;
i
+
+
)
str
.
push
(
String
.
fromCharCode
(
bytes
[
i
]
)
)
;
return
str
.
join
(
'
'
)
;
}
}
}
;
module
.
exports
=
charenc
;
}
function
(
module
exports
)
{
module
.
exports
=
function
(
obj
)
{
return
obj
!
=
null
&
&
(
isBuffer
(
obj
)
|
|
isSlowBuffer
(
obj
)
|
|
!
!
obj
.
_isBuffer
)
}
function
isBuffer
(
obj
)
{
return
!
!
obj
.
constructor
&
&
typeof
obj
.
constructor
.
isBuffer
=
=
=
'
function
'
&
&
obj
.
constructor
.
isBuffer
(
obj
)
}
function
isSlowBuffer
(
obj
)
{
return
typeof
obj
.
readFloatLE
=
=
=
'
function
'
&
&
typeof
obj
.
slice
=
=
=
'
function
'
&
&
isBuffer
(
obj
.
slice
(
0
0
)
)
}
}
function
(
module
exports
__webpack_require__
)
{
const
networkRequest
=
__webpack_require__
(
7
)
;
const
workerUtils
=
__webpack_require__
(
8
)
;
module
.
exports
=
{
networkRequest
workerUtils
}
;
}
function
(
module
exports
)
{
function
networkRequest
(
url
opts
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
req
=
new
XMLHttpRequest
(
)
;
req
.
addEventListener
(
"
readystatechange
"
(
)
=
>
{
if
(
req
.
readyState
=
=
=
XMLHttpRequest
.
DONE
)
{
if
(
req
.
status
=
=
=
200
)
{
resolve
(
{
content
:
req
.
responseText
}
)
;
}
else
{
resolve
(
req
.
statusText
)
;
}
}
}
)
;
req
.
open
(
"
GET
"
url
)
;
req
.
send
(
)
;
}
)
;
}
module
.
exports
=
networkRequest
;
}
function
(
module
exports
)
{
function
WorkerDispatcher
(
)
{
this
.
msgId
=
1
;
this
.
worker
=
null
;
}
WorkerDispatcher
.
prototype
=
{
start
(
url
)
{
this
.
worker
=
new
Worker
(
url
)
;
this
.
worker
.
onerror
=
(
)
=
>
{
console
.
error
(
Error
in
worker
{
url
}
)
;
}
;
}
stop
(
)
{
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
terminate
(
)
;
this
.
worker
=
null
;
}
task
(
method
)
{
return
(
.
.
.
args
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
id
=
this
.
msgId
+
+
;
this
.
worker
.
postMessage
(
{
id
method
args
}
)
;
const
listener
=
(
{
data
:
result
}
)
=
>
{
if
(
result
.
id
!
=
=
id
)
{
return
;
}
this
.
worker
.
removeEventListener
(
"
message
"
listener
)
;
if
(
result
.
error
)
{
reject
(
result
.
error
)
;
}
else
{
resolve
(
result
.
response
)
;
}
}
;
this
.
worker
.
addEventListener
(
"
message
"
listener
)
;
}
)
;
}
;
}
}
;
function
workerHandler
(
publicInterface
)
{
return
function
workerHandler
(
msg
)
{
const
{
id
method
args
}
=
msg
.
data
;
const
response
=
publicInterface
[
method
]
.
apply
(
undefined
args
)
;
if
(
response
instanceof
Promise
)
{
response
.
then
(
val
=
>
self
.
postMessage
(
{
id
response
:
val
}
)
err
=
>
self
.
postMessage
(
{
id
error
:
err
}
)
)
;
}
else
{
self
.
postMessage
(
{
id
response
}
)
;
}
}
;
}
module
.
exports
=
{
WorkerDispatcher
workerHandler
}
;
}
function
(
module
exports
__webpack_require__
)
{
let
_resolveAndFetch
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
generatedSource
)
{
const
sourceMapURL
=
_resolveSourceMapURL
(
generatedSource
)
;
const
fetched
=
yield
networkRequest
(
sourceMapURL
{
loadFromCache
:
false
}
)
;
const
map
=
new
SourceMapConsumer
(
fetched
.
content
)
;
_setSourceMapRoot
(
map
sourceMapURL
generatedSource
)
;
return
map
;
}
)
;
return
function
_resolveAndFetch
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
getOriginalURLs
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
generatedSource
)
{
const
map
=
yield
_fetchSourceMap
(
generatedSource
)
;
return
map
&
&
map
.
sources
;
}
)
;
return
function
getOriginalURLs
(
_x2
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
getGeneratedLocation
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
location
originalSource
)
{
if
(
!
isOriginalId
(
location
.
sourceId
)
)
{
return
location
;
}
const
generatedSourceId
=
originalToGeneratedId
(
location
.
sourceId
)
;
const
map
=
yield
_getSourceMap
(
generatedSourceId
)
;
if
(
!
map
)
{
return
location
;
}
const
{
line
column
}
=
map
.
generatedPositionFor
(
{
source
:
originalSource
.
url
line
:
location
.
line
column
:
location
.
column
=
=
null
?
0
:
location
.
column
bias
:
SourceMapConsumer
.
LEAST_UPPER_BOUND
}
)
;
return
{
sourceId
:
generatedSourceId
line
:
line
column
:
column
=
=
=
0
?
undefined
:
column
}
;
}
)
;
return
function
getGeneratedLocation
(
_x3
_x4
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
getOriginalLocation
=
(
(
)
=
>
{
var
_ref4
=
_asyncToGenerator
(
function
*
(
location
)
{
if
(
!
isGeneratedId
(
location
.
sourceId
)
)
{
return
location
;
}
const
map
=
yield
_getSourceMap
(
location
.
sourceId
)
;
if
(
!
map
)
{
return
location
;
}
const
{
source
:
url
line
column
}
=
map
.
originalPositionFor
(
{
line
:
location
.
line
column
:
location
.
column
=
=
null
?
Infinity
:
location
.
column
}
)
;
if
(
url
=
=
null
)
{
return
location
;
}
return
{
sourceId
:
generatedToOriginalId
(
location
.
sourceId
url
)
sourceUrl
:
url
line
column
}
;
}
)
;
return
function
getOriginalLocation
(
_x5
)
{
return
_ref4
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
getOriginalSourceText
=
(
(
)
=
>
{
var
_ref5
=
_asyncToGenerator
(
function
*
(
originalSource
)
{
assert
(
isOriginalId
(
originalSource
.
id
)
"
Source
is
not
an
original
source
"
)
;
const
generatedSourceId
=
originalToGeneratedId
(
originalSource
.
id
)
;
const
map
=
yield
_getSourceMap
(
generatedSourceId
)
;
if
(
!
map
)
{
return
null
;
}
let
text
=
map
.
sourceContentFor
(
originalSource
.
url
)
;
if
(
!
text
)
{
text
=
(
yield
networkRequest
(
originalSource
.
url
{
loadFromCache
:
false
}
)
)
.
content
;
}
return
{
text
contentType
:
getContentType
(
originalSource
.
url
|
|
"
"
)
}
;
}
)
;
return
function
getOriginalSourceText
(
_x6
)
{
return
_ref5
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
hasMappedSource
=
(
(
)
=
>
{
var
_ref6
=
_asyncToGenerator
(
function
*
(
location
)
{
if
(
isOriginalId
(
location
.
sourceId
)
)
{
return
true
;
}
const
loc
=
yield
getOriginalLocation
(
location
)
;
return
loc
.
sourceId
!
=
=
location
.
sourceId
;
}
)
;
return
function
hasMappedSource
(
_x7
)
{
return
_ref6
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
const
{
networkRequest
}
=
__webpack_require__
(
6
)
;
const
{
parse
}
=
__webpack_require__
(
10
)
;
const
path
=
__webpack_require__
(
17
)
;
const
{
SourceMapConsumer
SourceMapGenerator
}
=
__webpack_require__
(
18
)
;
const
assert
=
__webpack_require__
(
29
)
;
const
{
originalToGeneratedId
generatedToOriginalId
isGeneratedId
isOriginalId
getContentType
}
=
__webpack_require__
(
1
)
;
let
sourceMapRequests
=
new
Map
(
)
;
function
clearSourceMaps
(
)
{
sourceMapRequests
.
clear
(
)
;
}
function
_resolveSourceMapURL
(
source
)
{
const
{
url
=
"
"
sourceMapURL
=
"
"
}
=
source
;
if
(
path
.
isURL
(
sourceMapURL
)
|
|
url
=
=
"
"
)
{
return
sourceMapURL
;
}
else
if
(
path
.
isAbsolute
(
sourceMapURL
)
)
{
const
{
protocol
=
"
"
host
=
"
"
}
=
parse
(
url
)
;
return
{
protocol
}
/
/
{
host
}
{
sourceMapURL
}
;
}
return
{
path
.
dirname
(
url
)
}
/
{
sourceMapURL
}
;
}
function
_setSourceMapRoot
(
sourceMap
absSourceMapURL
source
)
{
if
(
sourceMap
.
hasContentsOfAllSources
(
)
)
{
return
;
}
const
base
=
path
.
dirname
(
absSourceMapURL
.
indexOf
(
"
data
:
"
)
=
=
=
0
&
&
source
.
url
?
source
.
url
:
absSourceMapURL
)
;
if
(
sourceMap
.
sourceRoot
)
{
sourceMap
.
sourceRoot
=
path
.
join
(
base
sourceMap
.
sourceRoot
)
;
}
else
{
sourceMap
.
sourceRoot
=
base
;
}
return
sourceMap
;
}
function
_getSourceMap
(
generatedSourceId
)
{
return
sourceMapRequests
.
get
(
generatedSourceId
)
;
}
function
_fetchSourceMap
(
generatedSource
)
{
const
existingRequest
=
sourceMapRequests
.
get
(
generatedSource
.
id
)
;
if
(
existingRequest
)
{
return
existingRequest
;
}
else
if
(
!
generatedSource
.
sourceMapURL
)
{
return
Promise
.
resolve
(
null
)
;
}
const
req
=
_resolveAndFetch
(
generatedSource
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
sourceMapRequests
.
set
(
generatedSource
.
id
req
)
;
return
req
;
}
function
applySourceMap
(
generatedId
url
code
mappings
)
{
const
generator
=
new
SourceMapGenerator
(
{
file
:
url
}
)
;
mappings
.
forEach
(
mapping
=
>
generator
.
addMapping
(
mapping
)
)
;
generator
.
setSourceContent
(
url
code
)
;
const
map
=
SourceMapConsumer
(
generator
.
toJSON
(
)
)
;
sourceMapRequests
.
set
(
generatedId
Promise
.
resolve
(
map
)
)
;
}
module
.
exports
=
{
getOriginalURLs
getGeneratedLocation
getOriginalLocation
getOriginalSourceText
applySourceMap
clearSourceMaps
hasMappedSource
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
punycode
=
__webpack_require__
(
11
)
;
var
util
=
__webpack_require__
(
13
)
;
exports
.
parse
=
urlParse
;
exports
.
resolve
=
urlResolve
;
exports
.
resolveObject
=
urlResolveObject
;
exports
.
format
=
urlFormat
;
exports
.
Url
=
Url
;
function
Url
(
)
{
this
.
protocol
=
null
;
this
.
slashes
=
null
;
this
.
auth
=
null
;
this
.
host
=
null
;
this
.
port
=
null
;
this
.
hostname
=
null
;
this
.
hash
=
null
;
this
.
search
=
null
;
this
.
query
=
null
;
this
.
pathname
=
null
;
this
.
path
=
null
;
this
.
href
=
null
;
}
var
protocolPattern
=
/
^
(
[
a
-
z0
-
9
.
+
-
]
+
:
)
/
i
portPattern
=
/
:
[
0
-
9
]
*
/
simplePathPattern
=
/
^
(
\
/
\
/
?
(
?
!
\
/
)
[
^
\
?
\
s
]
*
)
(
\
?
[
^
\
s
]
*
)
?
/
delims
=
[
'
<
'
'
>
'
'
"
'
'
'
'
'
'
\
r
'
'
\
n
'
'
\
t
'
]
unwise
=
[
'
{
'
'
}
'
'
|
'
'
\
\
'
'
^
'
'
'
]
.
concat
(
delims
)
autoEscape
=
[
'
\
'
'
]
.
concat
(
unwise
)
nonHostChars
=
[
'
%
'
'
/
'
'
?
'
'
;
'
'
#
'
]
.
concat
(
autoEscape
)
hostEndingChars
=
[
'
/
'
'
?
'
'
#
'
]
hostnameMaxLen
=
255
hostnamePartPattern
=
/
^
[
+
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
/
hostnamePartStart
=
/
^
(
[
+
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
)
(
.
*
)
/
unsafeProtocol
=
{
'
javascript
'
:
true
'
javascript
:
'
:
true
}
hostlessProtocol
=
{
'
javascript
'
:
true
'
javascript
:
'
:
true
}
slashedProtocol
=
{
'
http
'
:
true
'
https
'
:
true
'
ftp
'
:
true
'
gopher
'
:
true
'
file
'
:
true
'
http
:
'
:
true
'
https
:
'
:
true
'
ftp
:
'
:
true
'
gopher
:
'
:
true
'
file
:
'
:
true
}
querystring
=
__webpack_require__
(
14
)
;
function
urlParse
(
url
parseQueryString
slashesDenoteHost
)
{
if
(
url
&
&
util
.
isObject
(
url
)
&
&
url
instanceof
Url
)
return
url
;
var
u
=
new
Url
;
u
.
parse
(
url
parseQueryString
slashesDenoteHost
)
;
return
u
;
}
Url
.
prototype
.
parse
=
function
(
url
parseQueryString
slashesDenoteHost
)
{
if
(
!
util
.
isString
(
url
)
)
{
throw
new
TypeError
(
"
Parameter
'
url
'
must
be
a
string
not
"
+
typeof
url
)
;
}
var
queryIndex
=
url
.
indexOf
(
'
?
'
)
splitter
=
(
queryIndex
!
=
=
-
1
&
&
queryIndex
<
url
.
indexOf
(
'
#
'
)
)
?
'
?
'
:
'
#
'
uSplit
=
url
.
split
(
splitter
)
slashRegex
=
/
\
\
/
g
;
uSplit
[
0
]
=
uSplit
[
0
]
.
replace
(
slashRegex
'
/
'
)
;
url
=
uSplit
.
join
(
splitter
)
;
var
rest
=
url
;
rest
=
rest
.
trim
(
)
;
if
(
!
slashesDenoteHost
&
&
url
.
split
(
'
#
'
)
.
length
=
=
=
1
)
{
var
simplePath
=
simplePathPattern
.
exec
(
rest
)
;
if
(
simplePath
)
{
this
.
path
=
rest
;
this
.
href
=
rest
;
this
.
pathname
=
simplePath
[
1
]
;
if
(
simplePath
[
2
]
)
{
this
.
search
=
simplePath
[
2
]
;
if
(
parseQueryString
)
{
this
.
query
=
querystring
.
parse
(
this
.
search
.
substr
(
1
)
)
;
}
else
{
this
.
query
=
this
.
search
.
substr
(
1
)
;
}
}
else
if
(
parseQueryString
)
{
this
.
search
=
'
'
;
this
.
query
=
{
}
;
}
return
this
;
}
}
var
proto
=
protocolPattern
.
exec
(
rest
)
;
if
(
proto
)
{
proto
=
proto
[
0
]
;
var
lowerProto
=
proto
.
toLowerCase
(
)
;
this
.
protocol
=
lowerProto
;
rest
=
rest
.
substr
(
proto
.
length
)
;
}
if
(
slashesDenoteHost
|
|
proto
|
|
rest
.
match
(
/
^
\
/
\
/
[
^
\
/
]
+
[
^
\
/
]
+
/
)
)
{
var
slashes
=
rest
.
substr
(
0
2
)
=
=
=
'
/
/
'
;
if
(
slashes
&
&
!
(
proto
&
&
hostlessProtocol
[
proto
]
)
)
{
rest
=
rest
.
substr
(
2
)
;
this
.
slashes
=
true
;
}
}
if
(
!
hostlessProtocol
[
proto
]
&
&
(
slashes
|
|
(
proto
&
&
!
slashedProtocol
[
proto
]
)
)
)
{
var
hostEnd
=
-
1
;
for
(
var
i
=
0
;
i
<
hostEndingChars
.
length
;
i
+
+
)
{
var
hec
=
rest
.
indexOf
(
hostEndingChars
[
i
]
)
;
if
(
hec
!
=
=
-
1
&
&
(
hostEnd
=
=
=
-
1
|
|
hec
<
hostEnd
)
)
hostEnd
=
hec
;
}
var
auth
atSign
;
if
(
hostEnd
=
=
=
-
1
)
{
atSign
=
rest
.
lastIndexOf
(
'
'
)
;
}
else
{
atSign
=
rest
.
lastIndexOf
(
'
'
hostEnd
)
;
}
if
(
atSign
!
=
=
-
1
)
{
auth
=
rest
.
slice
(
0
atSign
)
;
rest
=
rest
.
slice
(
atSign
+
1
)
;
this
.
auth
=
decodeURIComponent
(
auth
)
;
}
hostEnd
=
-
1
;
for
(
var
i
=
0
;
i
<
nonHostChars
.
length
;
i
+
+
)
{
var
hec
=
rest
.
indexOf
(
nonHostChars
[
i
]
)
;
if
(
hec
!
=
=
-
1
&
&
(
hostEnd
=
=
=
-
1
|
|
hec
<
hostEnd
)
)
hostEnd
=
hec
;
}
if
(
hostEnd
=
=
=
-
1
)
hostEnd
=
rest
.
length
;
this
.
host
=
rest
.
slice
(
0
hostEnd
)
;
rest
=
rest
.
slice
(
hostEnd
)
;
this
.
parseHost
(
)
;
this
.
hostname
=
this
.
hostname
|
|
'
'
;
var
ipv6Hostname
=
this
.
hostname
[
0
]
=
=
=
'
[
'
&
&
this
.
hostname
[
this
.
hostname
.
length
-
1
]
=
=
=
'
]
'
;
if
(
!
ipv6Hostname
)
{
var
hostparts
=
this
.
hostname
.
split
(
/
\
.
/
)
;
for
(
var
i
=
0
l
=
hostparts
.
length
;
i
<
l
;
i
+
+
)
{
var
part
=
hostparts
[
i
]
;
if
(
!
part
)
continue
;
if
(
!
part
.
match
(
hostnamePartPattern
)
)
{
var
newpart
=
'
'
;
for
(
var
j
=
0
k
=
part
.
length
;
j
<
k
;
j
+
+
)
{
if
(
part
.
charCodeAt
(
j
)
>
127
)
{
newpart
+
=
'
x
'
;
}
else
{
newpart
+
=
part
[
j
]
;
}
}
if
(
!
newpart
.
match
(
hostnamePartPattern
)
)
{
var
validParts
=
hostparts
.
slice
(
0
i
)
;
var
notHost
=
hostparts
.
slice
(
i
+
1
)
;
var
bit
=
part
.
match
(
hostnamePartStart
)
;
if
(
bit
)
{
validParts
.
push
(
bit
[
1
]
)
;
notHost
.
unshift
(
bit
[
2
]
)
;
}
if
(
notHost
.
length
)
{
rest
=
'
/
'
+
notHost
.
join
(
'
.
'
)
+
rest
;
}
this
.
hostname
=
validParts
.
join
(
'
.
'
)
;
break
;
}
}
}
}
if
(
this
.
hostname
.
length
>
hostnameMaxLen
)
{
this
.
hostname
=
'
'
;
}
else
{
this
.
hostname
=
this
.
hostname
.
toLowerCase
(
)
;
}
if
(
!
ipv6Hostname
)
{
this
.
hostname
=
punycode
.
toASCII
(
this
.
hostname
)
;
}
var
p
=
this
.
port
?
'
:
'
+
this
.
port
:
'
'
;
var
h
=
this
.
hostname
|
|
'
'
;
this
.
host
=
h
+
p
;
this
.
href
+
=
this
.
host
;
if
(
ipv6Hostname
)
{
this
.
hostname
=
this
.
hostname
.
substr
(
1
this
.
hostname
.
length
-
2
)
;
if
(
rest
[
0
]
!
=
=
'
/
'
)
{
rest
=
'
/
'
+
rest
;
}
}
}
if
(
!
unsafeProtocol
[
lowerProto
]
)
{
for
(
var
i
=
0
l
=
autoEscape
.
length
;
i
<
l
;
i
+
+
)
{
var
ae
=
autoEscape
[
i
]
;
if
(
rest
.
indexOf
(
ae
)
=
=
=
-
1
)
continue
;
var
esc
=
encodeURIComponent
(
ae
)
;
if
(
esc
=
=
=
ae
)
{
esc
=
escape
(
ae
)
;
}
rest
=
rest
.
split
(
ae
)
.
join
(
esc
)
;
}
}
var
hash
=
rest
.
indexOf
(
'
#
'
)
;
if
(
hash
!
=
=
-
1
)
{
this
.
hash
=
rest
.
substr
(
hash
)
;
rest
=
rest
.
slice
(
0
hash
)
;
}
var
qm
=
rest
.
indexOf
(
'
?
'
)
;
if
(
qm
!
=
=
-
1
)
{
this
.
search
=
rest
.
substr
(
qm
)
;
this
.
query
=
rest
.
substr
(
qm
+
1
)
;
if
(
parseQueryString
)
{
this
.
query
=
querystring
.
parse
(
this
.
query
)
;
}
rest
=
rest
.
slice
(
0
qm
)
;
}
else
if
(
parseQueryString
)
{
this
.
search
=
'
'
;
this
.
query
=
{
}
;
}
if
(
rest
)
this
.
pathname
=
rest
;
if
(
slashedProtocol
[
lowerProto
]
&
&
this
.
hostname
&
&
!
this
.
pathname
)
{
this
.
pathname
=
'
/
'
;
}
if
(
this
.
pathname
|
|
this
.
search
)
{
var
p
=
this
.
pathname
|
|
'
'
;
var
s
=
this
.
search
|
|
'
'
;
this
.
path
=
p
+
s
;
}
this
.
href
=
this
.
format
(
)
;
return
this
;
}
;
function
urlFormat
(
obj
)
{
if
(
util
.
isString
(
obj
)
)
obj
=
urlParse
(
obj
)
;
if
(
!
(
obj
instanceof
Url
)
)
return
Url
.
prototype
.
format
.
call
(
obj
)
;
return
obj
.
format
(
)
;
}
Url
.
prototype
.
format
=
function
(
)
{
var
auth
=
this
.
auth
|
|
'
'
;
if
(
auth
)
{
auth
=
encodeURIComponent
(
auth
)
;
auth
=
auth
.
replace
(
/
%
3A
/
i
'
:
'
)
;
auth
+
=
'
'
;
}
var
protocol
=
this
.
protocol
|
|
'
'
pathname
=
this
.
pathname
|
|
'
'
hash
=
this
.
hash
|
|
'
'
host
=
false
query
=
'
'
;
if
(
this
.
host
)
{
host
=
auth
+
this
.
host
;
}
else
if
(
this
.
hostname
)
{
host
=
auth
+
(
this
.
hostname
.
indexOf
(
'
:
'
)
=
=
=
-
1
?
this
.
hostname
:
'
[
'
+
this
.
hostname
+
'
]
'
)
;
if
(
this
.
port
)
{
host
+
=
'
:
'
+
this
.
port
;
}
}
if
(
this
.
query
&
&
util
.
isObject
(
this
.
query
)
&
&
Object
.
keys
(
this
.
query
)
.
length
)
{
query
=
querystring
.
stringify
(
this
.
query
)
;
}
var
search
=
this
.
search
|
|
(
query
&
&
(
'
?
'
+
query
)
)
|
|
'
'
;
if
(
protocol
&
&
protocol
.
substr
(
-
1
)
!
=
=
'
:
'
)
protocol
+
=
'
:
'
;
if
(
this
.
slashes
|
|
(
!
protocol
|
|
slashedProtocol
[
protocol
]
)
&
&
host
!
=
=
false
)
{
host
=
'
/
/
'
+
(
host
|
|
'
'
)
;
if
(
pathname
&
&
pathname
.
charAt
(
0
)
!
=
=
'
/
'
)
pathname
=
'
/
'
+
pathname
;
}
else
if
(
!
host
)
{
host
=
'
'
;
}
if
(
hash
&
&
hash
.
charAt
(
0
)
!
=
=
'
#
'
)
hash
=
'
#
'
+
hash
;
if
(
search
&
&
search
.
charAt
(
0
)
!
=
=
'
?
'
)
search
=
'
?
'
+
search
;
pathname
=
pathname
.
replace
(
/
[
?
#
]
/
g
function
(
match
)
{
return
encodeURIComponent
(
match
)
;
}
)
;
search
=
search
.
replace
(
'
#
'
'
%
23
'
)
;
return
protocol
+
host
+
pathname
+
search
+
hash
;
}
;
function
urlResolve
(
source
relative
)
{
return
urlParse
(
source
false
true
)
.
resolve
(
relative
)
;
}
Url
.
prototype
.
resolve
=
function
(
relative
)
{
return
this
.
resolveObject
(
urlParse
(
relative
false
true
)
)
.
format
(
)
;
}
;
function
urlResolveObject
(
source
relative
)
{
if
(
!
source
)
return
relative
;
return
urlParse
(
source
false
true
)
.
resolveObject
(
relative
)
;
}
Url
.
prototype
.
resolveObject
=
function
(
relative
)
{
if
(
util
.
isString
(
relative
)
)
{
var
rel
=
new
Url
(
)
;
rel
.
parse
(
relative
false
true
)
;
relative
=
rel
;
}
var
result
=
new
Url
(
)
;
var
tkeys
=
Object
.
keys
(
this
)
;
for
(
var
tk
=
0
;
tk
<
tkeys
.
length
;
tk
+
+
)
{
var
tkey
=
tkeys
[
tk
]
;
result
[
tkey
]
=
this
[
tkey
]
;
}
result
.
hash
=
relative
.
hash
;
if
(
relative
.
href
=
=
=
'
'
)
{
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
relative
.
slashes
&
&
!
relative
.
protocol
)
{
var
rkeys
=
Object
.
keys
(
relative
)
;
for
(
var
rk
=
0
;
rk
<
rkeys
.
length
;
rk
+
+
)
{
var
rkey
=
rkeys
[
rk
]
;
if
(
rkey
!
=
=
'
protocol
'
)
result
[
rkey
]
=
relative
[
rkey
]
;
}
if
(
slashedProtocol
[
result
.
protocol
]
&
&
result
.
hostname
&
&
!
result
.
pathname
)
{
result
.
path
=
result
.
pathname
=
'
/
'
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
relative
.
protocol
&
&
relative
.
protocol
!
=
=
result
.
protocol
)
{
if
(
!
slashedProtocol
[
relative
.
protocol
]
)
{
var
keys
=
Object
.
keys
(
relative
)
;
for
(
var
v
=
0
;
v
<
keys
.
length
;
v
+
+
)
{
var
k
=
keys
[
v
]
;
result
[
k
]
=
relative
[
k
]
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
result
.
protocol
=
relative
.
protocol
;
if
(
!
relative
.
host
&
&
!
hostlessProtocol
[
relative
.
protocol
]
)
{
var
relPath
=
(
relative
.
pathname
|
|
'
'
)
.
split
(
'
/
'
)
;
while
(
relPath
.
length
&
&
!
(
relative
.
host
=
relPath
.
shift
(
)
)
)
;
if
(
!
relative
.
host
)
relative
.
host
=
'
'
;
if
(
!
relative
.
hostname
)
relative
.
hostname
=
'
'
;
if
(
relPath
[
0
]
!
=
=
'
'
)
relPath
.
unshift
(
'
'
)
;
if
(
relPath
.
length
<
2
)
relPath
.
unshift
(
'
'
)
;
result
.
pathname
=
relPath
.
join
(
'
/
'
)
;
}
else
{
result
.
pathname
=
relative
.
pathname
;
}
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
result
.
host
=
relative
.
host
|
|
'
'
;
result
.
auth
=
relative
.
auth
;
result
.
hostname
=
relative
.
hostname
|
|
relative
.
host
;
result
.
port
=
relative
.
port
;
if
(
result
.
pathname
|
|
result
.
search
)
{
var
p
=
result
.
pathname
|
|
'
'
;
var
s
=
result
.
search
|
|
'
'
;
result
.
path
=
p
+
s
;
}
result
.
slashes
=
result
.
slashes
|
|
relative
.
slashes
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
var
isSourceAbs
=
(
result
.
pathname
&
&
result
.
pathname
.
charAt
(
0
)
=
=
=
'
/
'
)
isRelAbs
=
(
relative
.
host
|
|
relative
.
pathname
&
&
relative
.
pathname
.
charAt
(
0
)
=
=
=
'
/
'
)
mustEndAbs
=
(
isRelAbs
|
|
isSourceAbs
|
|
(
result
.
host
&
&
relative
.
pathname
)
)
removeAllDots
=
mustEndAbs
srcPath
=
result
.
pathname
&
&
result
.
pathname
.
split
(
'
/
'
)
|
|
[
]
relPath
=
relative
.
pathname
&
&
relative
.
pathname
.
split
(
'
/
'
)
|
|
[
]
psychotic
=
result
.
protocol
&
&
!
slashedProtocol
[
result
.
protocol
]
;
if
(
psychotic
)
{
result
.
hostname
=
'
'
;
result
.
port
=
null
;
if
(
result
.
host
)
{
if
(
srcPath
[
0
]
=
=
=
'
'
)
srcPath
[
0
]
=
result
.
host
;
else
srcPath
.
unshift
(
result
.
host
)
;
}
result
.
host
=
'
'
;
if
(
relative
.
protocol
)
{
relative
.
hostname
=
null
;
relative
.
port
=
null
;
if
(
relative
.
host
)
{
if
(
relPath
[
0
]
=
=
=
'
'
)
relPath
[
0
]
=
relative
.
host
;
else
relPath
.
unshift
(
relative
.
host
)
;
}
relative
.
host
=
null
;
}
mustEndAbs
=
mustEndAbs
&
&
(
relPath
[
0
]
=
=
=
'
'
|
|
srcPath
[
0
]
=
=
=
'
'
)
;
}
if
(
isRelAbs
)
{
result
.
host
=
(
relative
.
host
|
|
relative
.
host
=
=
=
'
'
)
?
relative
.
host
:
result
.
host
;
result
.
hostname
=
(
relative
.
hostname
|
|
relative
.
hostname
=
=
=
'
'
)
?
relative
.
hostname
:
result
.
hostname
;
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
srcPath
=
relPath
;
}
else
if
(
relPath
.
length
)
{
if
(
!
srcPath
)
srcPath
=
[
]
;
srcPath
.
pop
(
)
;
srcPath
=
srcPath
.
concat
(
relPath
)
;
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
}
else
if
(
!
util
.
isNullOrUndefined
(
relative
.
search
)
)
{
if
(
psychotic
)
{
result
.
hostname
=
result
.
host
=
srcPath
.
shift
(
)
;
var
authInHost
=
result
.
host
&
&
result
.
host
.
indexOf
(
'
'
)
>
0
?
result
.
host
.
split
(
'
'
)
:
false
;
if
(
authInHost
)
{
result
.
auth
=
authInHost
.
shift
(
)
;
result
.
host
=
result
.
hostname
=
authInHost
.
shift
(
)
;
}
}
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
if
(
!
util
.
isNull
(
result
.
pathname
)
|
|
!
util
.
isNull
(
result
.
search
)
)
{
result
.
path
=
(
result
.
pathname
?
result
.
pathname
:
'
'
)
+
(
result
.
search
?
result
.
search
:
'
'
)
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
!
srcPath
.
length
)
{
result
.
pathname
=
null
;
if
(
result
.
search
)
{
result
.
path
=
'
/
'
+
result
.
search
;
}
else
{
result
.
path
=
null
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
var
last
=
srcPath
.
slice
(
-
1
)
[
0
]
;
var
hasTrailingSlash
=
(
(
result
.
host
|
|
relative
.
host
|
|
srcPath
.
length
>
1
)
&
&
(
last
=
=
=
'
.
'
|
|
last
=
=
=
'
.
.
'
)
|
|
last
=
=
=
'
'
)
;
var
up
=
0
;
for
(
var
i
=
srcPath
.
length
;
i
>
=
0
;
i
-
-
)
{
last
=
srcPath
[
i
]
;
if
(
last
=
=
=
'
.
'
)
{
srcPath
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
srcPath
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
srcPath
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
!
mustEndAbs
&
&
!
removeAllDots
)
{
for
(
;
up
-
-
;
up
)
{
srcPath
.
unshift
(
'
.
.
'
)
;
}
}
if
(
mustEndAbs
&
&
srcPath
[
0
]
!
=
=
'
'
&
&
(
!
srcPath
[
0
]
|
|
srcPath
[
0
]
.
charAt
(
0
)
!
=
=
'
/
'
)
)
{
srcPath
.
unshift
(
'
'
)
;
}
if
(
hasTrailingSlash
&
&
(
srcPath
.
join
(
'
/
'
)
.
substr
(
-
1
)
!
=
=
'
/
'
)
)
{
srcPath
.
push
(
'
'
)
;
}
var
isAbsolute
=
srcPath
[
0
]
=
=
=
'
'
|
|
(
srcPath
[
0
]
&
&
srcPath
[
0
]
.
charAt
(
0
)
=
=
=
'
/
'
)
;
if
(
psychotic
)
{
result
.
hostname
=
result
.
host
=
isAbsolute
?
'
'
:
srcPath
.
length
?
srcPath
.
shift
(
)
:
'
'
;
var
authInHost
=
result
.
host
&
&
result
.
host
.
indexOf
(
'
'
)
>
0
?
result
.
host
.
split
(
'
'
)
:
false
;
if
(
authInHost
)
{
result
.
auth
=
authInHost
.
shift
(
)
;
result
.
host
=
result
.
hostname
=
authInHost
.
shift
(
)
;
}
}
mustEndAbs
=
mustEndAbs
|
|
(
result
.
host
&
&
srcPath
.
length
)
;
if
(
mustEndAbs
&
&
!
isAbsolute
)
{
srcPath
.
unshift
(
'
'
)
;
}
if
(
!
srcPath
.
length
)
{
result
.
pathname
=
null
;
result
.
path
=
null
;
}
else
{
result
.
pathname
=
srcPath
.
join
(
'
/
'
)
;
}
if
(
!
util
.
isNull
(
result
.
pathname
)
|
|
!
util
.
isNull
(
result
.
search
)
)
{
result
.
path
=
(
result
.
pathname
?
result
.
pathname
:
'
'
)
+
(
result
.
search
?
result
.
search
:
'
'
)
;
}
result
.
auth
=
relative
.
auth
|
|
result
.
auth
;
result
.
slashes
=
result
.
slashes
|
|
relative
.
slashes
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
;
Url
.
prototype
.
parseHost
=
function
(
)
{
var
host
=
this
.
host
;
var
port
=
portPattern
.
exec
(
host
)
;
if
(
port
)
{
port
=
port
[
0
]
;
if
(
port
!
=
=
'
:
'
)
{
this
.
port
=
port
.
substr
(
1
)
;
}
host
=
host
.
substr
(
0
host
.
length
-
port
.
length
)
;
}
if
(
host
)
this
.
hostname
=
host
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
module
global
)
{
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
&
&
!
exports
.
nodeType
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
!
module
.
nodeType
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
|
|
freeGlobal
.
self
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
punycode
maxInt
=
2147483647
base
=
36
tMin
=
1
tMax
=
26
skew
=
38
damp
=
700
initialBias
=
72
initialN
=
128
delimiter
=
'
-
'
regexPunycode
=
/
^
xn
-
-
/
regexNonASCII
=
/
[
^
\
x20
-
\
x7E
]
/
regexSeparators
=
/
[
\
x2E
\
u3002
\
uFF0E
\
uFF61
]
/
g
errors
=
{
'
overflow
'
:
'
Overflow
:
input
needs
wider
integers
to
process
'
'
not
-
basic
'
:
'
Illegal
input
>
=
0x80
(
not
a
basic
code
point
)
'
'
invalid
-
input
'
:
'
Invalid
input
'
}
baseMinusTMin
=
base
-
tMin
floor
=
Math
.
floor
stringFromCharCode
=
String
.
fromCharCode
key
;
function
error
(
type
)
{
throw
RangeError
(
errors
[
type
]
)
;
}
function
map
(
array
fn
)
{
var
length
=
array
.
length
;
var
result
=
[
]
;
while
(
length
-
-
)
{
result
[
length
]
=
fn
(
array
[
length
]
)
;
}
return
result
;
}
function
mapDomain
(
string
fn
)
{
var
parts
=
string
.
split
(
'
'
)
;
var
result
=
'
'
;
if
(
parts
.
length
>
1
)
{
result
=
parts
[
0
]
+
'
'
;
string
=
parts
[
1
]
;
}
string
=
string
.
replace
(
regexSeparators
'
\
x2E
'
)
;
var
labels
=
string
.
split
(
'
.
'
)
;
var
encoded
=
map
(
labels
fn
)
.
join
(
'
.
'
)
;
return
result
+
encoded
;
}
function
ucs2decode
(
string
)
{
var
output
=
[
]
counter
=
0
length
=
string
.
length
value
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
return
map
(
array
function
(
value
)
{
var
output
=
'
'
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
return
output
;
}
)
.
join
(
'
'
)
;
}
function
basicToDigit
(
codePoint
)
{
if
(
codePoint
-
48
<
10
)
{
return
codePoint
-
22
;
}
if
(
codePoint
-
65
<
26
)
{
return
codePoint
-
65
;
}
if
(
codePoint
-
97
<
26
)
{
return
codePoint
-
97
;
}
return
base
;
}
function
digitToBasic
(
digit
flag
)
{
return
digit
+
22
+
75
*
(
digit
<
26
)
-
(
(
flag
!
=
0
)
<
<
5
)
;
}
function
adapt
(
delta
numPoints
firstTime
)
{
var
k
=
0
;
delta
=
firstTime
?
floor
(
delta
/
damp
)
:
delta
>
>
1
;
delta
+
=
floor
(
delta
/
numPoints
)
;
for
(
;
delta
>
baseMinusTMin
*
tMax
>
>
1
;
k
+
=
base
)
{
delta
=
floor
(
delta
/
baseMinusTMin
)
;
}
return
floor
(
k
+
(
baseMinusTMin
+
1
)
*
delta
/
(
delta
+
skew
)
)
;
}
function
decode
(
input
)
{
var
output
=
[
]
inputLength
=
input
.
length
out
i
=
0
n
=
initialN
bias
=
initialBias
basic
j
index
oldi
w
k
digit
t
baseMinusT
;
basic
=
input
.
lastIndexOf
(
delimiter
)
;
if
(
basic
<
0
)
{
basic
=
0
;
}
for
(
j
=
0
;
j
<
basic
;
+
+
j
)
{
if
(
input
.
charCodeAt
(
j
)
>
=
0x80
)
{
error
(
'
not
-
basic
'
)
;
}
output
.
push
(
input
.
charCodeAt
(
j
)
)
;
}
for
(
index
=
basic
>
0
?
basic
+
1
:
0
;
index
<
inputLength
;
)
{
for
(
oldi
=
i
w
=
1
k
=
base
;
;
k
+
=
base
)
{
if
(
index
>
=
inputLength
)
{
error
(
'
invalid
-
input
'
)
;
}
digit
=
basicToDigit
(
input
.
charCodeAt
(
index
+
+
)
)
;
if
(
digit
>
=
base
|
|
digit
>
floor
(
(
maxInt
-
i
)
/
w
)
)
{
error
(
'
overflow
'
)
;
}
i
+
=
digit
*
w
;
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
digit
<
t
)
{
break
;
}
baseMinusT
=
base
-
t
;
if
(
w
>
floor
(
maxInt
/
baseMinusT
)
)
{
error
(
'
overflow
'
)
;
}
w
*
=
baseMinusT
;
}
out
=
output
.
length
+
1
;
bias
=
adapt
(
i
-
oldi
out
oldi
=
=
0
)
;
if
(
floor
(
i
/
out
)
>
maxInt
-
n
)
{
error
(
'
overflow
'
)
;
}
n
+
=
floor
(
i
/
out
)
;
i
%
=
out
;
output
.
splice
(
i
+
+
0
n
)
;
}
return
ucs2encode
(
output
)
;
}
function
encode
(
input
)
{
var
n
delta
handledCPCount
basicLength
bias
j
m
q
k
t
currentValue
output
=
[
]
inputLength
handledCPCountPlusOne
baseMinusT
qMinusT
;
input
=
ucs2decode
(
input
)
;
inputLength
=
input
.
length
;
n
=
initialN
;
delta
=
0
;
bias
=
initialBias
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
0x80
)
{
output
.
push
(
stringFromCharCode
(
currentValue
)
)
;
}
}
handledCPCount
=
basicLength
=
output
.
length
;
if
(
basicLength
)
{
output
.
push
(
delimiter
)
;
}
while
(
handledCPCount
<
inputLength
)
{
for
(
m
=
maxInt
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
>
=
n
&
&
currentValue
<
m
)
{
m
=
currentValue
;
}
}
handledCPCountPlusOne
=
handledCPCount
+
1
;
if
(
m
-
n
>
floor
(
(
maxInt
-
delta
)
/
handledCPCountPlusOne
)
)
{
error
(
'
overflow
'
)
;
}
delta
+
=
(
m
-
n
)
*
handledCPCountPlusOne
;
n
=
m
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
n
&
&
+
+
delta
>
maxInt
)
{
error
(
'
overflow
'
)
;
}
if
(
currentValue
=
=
n
)
{
for
(
q
=
delta
k
=
base
;
;
k
+
=
base
)
{
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
q
<
t
)
{
break
;
}
qMinusT
=
q
-
t
;
baseMinusT
=
base
-
t
;
output
.
push
(
stringFromCharCode
(
digitToBasic
(
t
+
qMinusT
%
baseMinusT
0
)
)
)
;
q
=
floor
(
qMinusT
/
baseMinusT
)
;
}
output
.
push
(
stringFromCharCode
(
digitToBasic
(
q
0
)
)
)
;
bias
=
adapt
(
delta
handledCPCountPlusOne
handledCPCount
=
=
basicLength
)
;
delta
=
0
;
+
+
handledCPCount
;
}
}
+
+
delta
;
+
+
n
;
}
return
output
.
join
(
'
'
)
;
}
function
toUnicode
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexPunycode
.
test
(
string
)
?
decode
(
string
.
slice
(
4
)
.
toLowerCase
(
)
)
:
string
;
}
)
;
}
function
toASCII
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexNonASCII
.
test
(
string
)
?
'
xn
-
-
'
+
encode
(
string
)
:
string
;
}
)
;
}
punycode
=
{
'
version
'
:
'
1
.
3
.
2
'
'
ucs2
'
:
{
'
decode
'
:
ucs2decode
'
encode
'
:
ucs2encode
}
'
decode
'
:
decode
'
encode
'
:
encode
'
toASCII
'
:
toASCII
'
toUnicode
'
:
toUnicode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
punycode
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
freeModule
)
{
if
(
module
.
exports
=
=
freeExports
)
{
freeModule
.
exports
=
punycode
;
}
else
{
for
(
key
in
punycode
)
{
punycode
.
hasOwnProperty
(
key
)
&
&
(
freeExports
[
key
]
=
punycode
[
key
]
)
;
}
}
}
else
{
root
.
punycode
=
punycode
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
12
)
(
module
)
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
)
{
module
.
exports
=
function
(
module
)
{
if
(
!
module
.
webpackPolyfill
)
{
module
.
deprecate
=
function
(
)
{
}
;
module
.
paths
=
[
]
;
module
.
children
=
[
]
;
module
.
webpackPolyfill
=
1
;
}
return
module
;
}
}
function
(
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
{
isString
:
function
(
arg
)
{
return
typeof
(
arg
)
=
=
=
'
string
'
;
}
isObject
:
function
(
arg
)
{
return
typeof
(
arg
)
=
=
=
'
object
'
&
&
arg
!
=
=
null
;
}
isNull
:
function
(
arg
)
{
return
arg
=
=
=
null
;
}
isNullOrUndefined
:
function
(
arg
)
{
return
arg
=
=
null
;
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
decode
=
exports
.
parse
=
__webpack_require__
(
15
)
;
exports
.
encode
=
exports
.
stringify
=
__webpack_require__
(
16
)
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
hasOwnProperty
(
obj
prop
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
prop
)
;
}
module
.
exports
=
function
(
qs
sep
eq
options
)
{
sep
=
sep
|
|
'
&
'
;
eq
=
eq
|
|
'
=
'
;
var
obj
=
{
}
;
if
(
typeof
qs
!
=
=
'
string
'
|
|
qs
.
length
=
=
=
0
)
{
return
obj
;
}
var
regexp
=
/
\
+
/
g
;
qs
=
qs
.
split
(
sep
)
;
var
maxKeys
=
1000
;
if
(
options
&
&
typeof
options
.
maxKeys
=
=
=
'
number
'
)
{
maxKeys
=
options
.
maxKeys
;
}
var
len
=
qs
.
length
;
if
(
maxKeys
>
0
&
&
len
>
maxKeys
)
{
len
=
maxKeys
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
var
x
=
qs
[
i
]
.
replace
(
regexp
'
%
20
'
)
idx
=
x
.
indexOf
(
eq
)
kstr
vstr
k
v
;
if
(
idx
>
=
0
)
{
kstr
=
x
.
substr
(
0
idx
)
;
vstr
=
x
.
substr
(
idx
+
1
)
;
}
else
{
kstr
=
x
;
vstr
=
'
'
;
}
k
=
decodeURIComponent
(
kstr
)
;
v
=
decodeURIComponent
(
vstr
)
;
if
(
!
hasOwnProperty
(
obj
k
)
)
{
obj
[
k
]
=
v
;
}
else
if
(
Array
.
isArray
(
obj
[
k
]
)
)
{
obj
[
k
]
.
push
(
v
)
;
}
else
{
obj
[
k
]
=
[
obj
[
k
]
v
]
;
}
}
return
obj
;
}
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
stringifyPrimitive
=
function
(
v
)
{
switch
(
typeof
v
)
{
case
'
string
'
:
return
v
;
case
'
boolean
'
:
return
v
?
'
true
'
:
'
false
'
;
case
'
number
'
:
return
isFinite
(
v
)
?
v
:
'
'
;
default
:
return
'
'
;
}
}
;
module
.
exports
=
function
(
obj
sep
eq
name
)
{
sep
=
sep
|
|
'
&
'
;
eq
=
eq
|
|
'
=
'
;
if
(
obj
=
=
=
null
)
{
obj
=
undefined
;
}
if
(
typeof
obj
=
=
=
'
object
'
)
{
return
Object
.
keys
(
obj
)
.
map
(
function
(
k
)
{
var
ks
=
encodeURIComponent
(
stringifyPrimitive
(
k
)
)
+
eq
;
if
(
Array
.
isArray
(
obj
[
k
]
)
)
{
return
obj
[
k
]
.
map
(
function
(
v
)
{
return
ks
+
encodeURIComponent
(
stringifyPrimitive
(
v
)
)
;
}
)
.
join
(
sep
)
;
}
else
{
return
ks
+
encodeURIComponent
(
stringifyPrimitive
(
obj
[
k
]
)
)
;
}
}
)
.
join
(
sep
)
;
}
if
(
!
name
)
return
'
'
;
return
encodeURIComponent
(
stringifyPrimitive
(
name
)
)
+
eq
+
encodeURIComponent
(
stringifyPrimitive
(
obj
)
)
;
}
;
}
function
(
module
exports
)
{
function
basename
(
path
)
{
return
path
.
split
(
"
/
"
)
.
pop
(
)
;
}
function
dirname
(
path
)
{
const
idx
=
path
.
lastIndexOf
(
"
/
"
)
;
return
path
.
slice
(
0
idx
)
;
}
function
isURL
(
str
)
{
return
str
.
indexOf
(
"
:
/
/
"
)
!
=
=
-
1
;
}
function
isAbsolute
(
str
)
{
return
str
[
0
]
=
=
=
"
/
"
;
}
function
join
(
base
dir
)
{
return
{
base
}
/
{
dir
}
;
}
module
.
exports
=
{
basename
dirname
isURL
isAbsolute
join
}
;
}
function
(
module
exports
__webpack_require__
)
{
exports
.
SourceMapGenerator
=
__webpack_require__
(
19
)
.
SourceMapGenerator
;
exports
.
SourceMapConsumer
=
__webpack_require__
(
25
)
.
SourceMapConsumer
;
exports
.
SourceNode
=
__webpack_require__
(
28
)
.
SourceNode
;
}
function
(
module
exports
__webpack_require__
)
{
var
base64VLQ
=
__webpack_require__
(
20
)
;
var
util
=
__webpack_require__
(
22
)
;
var
ArraySet
=
__webpack_require__
(
23
)
.
ArraySet
;
var
MappingList
=
__webpack_require__
(
24
)
.
MappingList
;
function
SourceMapGenerator
(
aArgs
)
{
if
(
!
aArgs
)
{
aArgs
=
{
}
;
}
this
.
_file
=
util
.
getArg
(
aArgs
'
file
'
null
)
;
this
.
_sourceRoot
=
util
.
getArg
(
aArgs
'
sourceRoot
'
null
)
;
this
.
_skipValidation
=
util
.
getArg
(
aArgs
'
skipValidation
'
false
)
;
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
this
.
_mappings
=
new
MappingList
(
)
;
this
.
_sourcesContents
=
null
;
}
SourceMapGenerator
.
prototype
.
_version
=
3
;
SourceMapGenerator
.
fromSourceMap
=
function
SourceMapGenerator_fromSourceMap
(
aSourceMapConsumer
)
{
var
sourceRoot
=
aSourceMapConsumer
.
sourceRoot
;
var
generator
=
new
SourceMapGenerator
(
{
file
:
aSourceMapConsumer
.
file
sourceRoot
:
sourceRoot
}
)
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
var
newMapping
=
{
generated
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
generatedColumn
}
}
;
if
(
mapping
.
source
!
=
null
)
{
newMapping
.
source
=
mapping
.
source
;
if
(
sourceRoot
!
=
null
)
{
newMapping
.
source
=
util
.
relative
(
sourceRoot
newMapping
.
source
)
;
}
newMapping
.
original
=
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
;
if
(
mapping
.
name
!
=
null
)
{
newMapping
.
name
=
mapping
.
name
;
}
}
generator
.
addMapping
(
newMapping
)
;
}
)
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
generator
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
generator
;
}
;
SourceMapGenerator
.
prototype
.
addMapping
=
function
SourceMapGenerator_addMapping
(
aArgs
)
{
var
generated
=
util
.
getArg
(
aArgs
'
generated
'
)
;
var
original
=
util
.
getArg
(
aArgs
'
original
'
null
)
;
var
source
=
util
.
getArg
(
aArgs
'
source
'
null
)
;
var
name
=
util
.
getArg
(
aArgs
'
name
'
null
)
;
if
(
!
this
.
_skipValidation
)
{
this
.
_validateMapping
(
generated
original
source
name
)
;
}
if
(
source
!
=
null
)
{
source
=
String
(
source
)
;
if
(
!
this
.
_sources
.
has
(
source
)
)
{
this
.
_sources
.
add
(
source
)
;
}
}
if
(
name
!
=
null
)
{
name
=
String
(
name
)
;
if
(
!
this
.
_names
.
has
(
name
)
)
{
this
.
_names
.
add
(
name
)
;
}
}
this
.
_mappings
.
add
(
{
generatedLine
:
generated
.
line
generatedColumn
:
generated
.
column
originalLine
:
original
!
=
null
&
&
original
.
line
originalColumn
:
original
!
=
null
&
&
original
.
column
source
:
source
name
:
name
}
)
;
}
;
SourceMapGenerator
.
prototype
.
setSourceContent
=
function
SourceMapGenerator_setSourceContent
(
aSourceFile
aSourceContent
)
{
var
source
=
aSourceFile
;
if
(
this
.
_sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
_sourceRoot
source
)
;
}
if
(
aSourceContent
!
=
null
)
{
if
(
!
this
.
_sourcesContents
)
{
this
.
_sourcesContents
=
Object
.
create
(
null
)
;
}
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
=
aSourceContent
;
}
else
if
(
this
.
_sourcesContents
)
{
delete
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
;
if
(
Object
.
keys
(
this
.
_sourcesContents
)
.
length
=
=
=
0
)
{
this
.
_sourcesContents
=
null
;
}
}
}
;
SourceMapGenerator
.
prototype
.
applySourceMap
=
function
SourceMapGenerator_applySourceMap
(
aSourceMapConsumer
aSourceFile
aSourceMapPath
)
{
var
sourceFile
=
aSourceFile
;
if
(
aSourceFile
=
=
null
)
{
if
(
aSourceMapConsumer
.
file
=
=
null
)
{
throw
new
Error
(
'
SourceMapGenerator
.
prototype
.
applySourceMap
requires
either
an
explicit
source
file
'
+
'
or
the
source
map
\
'
s
"
file
"
property
.
Both
were
omitted
.
'
)
;
}
sourceFile
=
aSourceMapConsumer
.
file
;
}
var
sourceRoot
=
this
.
_sourceRoot
;
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
var
newSources
=
new
ArraySet
(
)
;
var
newNames
=
new
ArraySet
(
)
;
this
.
_mappings
.
unsortedForEach
(
function
(
mapping
)
{
if
(
mapping
.
source
=
=
=
sourceFile
&
&
mapping
.
originalLine
!
=
null
)
{
var
original
=
aSourceMapConsumer
.
originalPositionFor
(
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
)
;
if
(
original
.
source
!
=
null
)
{
mapping
.
source
=
original
.
source
;
if
(
aSourceMapPath
!
=
null
)
{
mapping
.
source
=
util
.
join
(
aSourceMapPath
mapping
.
source
)
}
if
(
sourceRoot
!
=
null
)
{
mapping
.
source
=
util
.
relative
(
sourceRoot
mapping
.
source
)
;
}
mapping
.
originalLine
=
original
.
line
;
mapping
.
originalColumn
=
original
.
column
;
if
(
original
.
name
!
=
null
)
{
mapping
.
name
=
original
.
name
;
}
}
}
var
source
=
mapping
.
source
;
if
(
source
!
=
null
&
&
!
newSources
.
has
(
source
)
)
{
newSources
.
add
(
source
)
;
}
var
name
=
mapping
.
name
;
if
(
name
!
=
null
&
&
!
newNames
.
has
(
name
)
)
{
newNames
.
add
(
name
)
;
}
}
this
)
;
this
.
_sources
=
newSources
;
this
.
_names
=
newNames
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aSourceMapPath
!
=
null
)
{
sourceFile
=
util
.
join
(
aSourceMapPath
sourceFile
)
;
}
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
this
.
setSourceContent
(
sourceFile
content
)
;
}
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
_validateMapping
=
function
SourceMapGenerator_validateMapping
(
aGenerated
aOriginal
aSource
aName
)
{
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
!
aOriginal
&
&
!
aSource
&
&
!
aName
)
{
return
;
}
else
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aOriginal
&
&
'
line
'
in
aOriginal
&
&
'
column
'
in
aOriginal
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
aOriginal
.
line
>
0
&
&
aOriginal
.
column
>
=
0
&
&
aSource
)
{
return
;
}
else
{
throw
new
Error
(
'
Invalid
mapping
:
'
+
JSON
.
stringify
(
{
generated
:
aGenerated
source
:
aSource
original
:
aOriginal
name
:
aName
}
)
)
;
}
}
;
SourceMapGenerator
.
prototype
.
_serializeMappings
=
function
SourceMapGenerator_serializeMappings
(
)
{
var
previousGeneratedColumn
=
0
;
var
previousGeneratedLine
=
1
;
var
previousOriginalColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousName
=
0
;
var
previousSource
=
0
;
var
result
=
'
'
;
var
next
;
var
mapping
;
var
nameIdx
;
var
sourceIdx
;
var
mappings
=
this
.
_mappings
.
toArray
(
)
;
for
(
var
i
=
0
len
=
mappings
.
length
;
i
<
len
;
i
+
+
)
{
mapping
=
mappings
[
i
]
;
next
=
'
'
if
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
previousGeneratedColumn
=
0
;
while
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
next
+
=
'
;
'
;
previousGeneratedLine
+
+
;
}
}
else
{
if
(
i
>
0
)
{
if
(
!
util
.
compareByGeneratedPositionsInflated
(
mapping
mappings
[
i
-
1
]
)
)
{
continue
;
}
next
+
=
'
'
;
}
}
next
+
=
base64VLQ
.
encode
(
mapping
.
generatedColumn
-
previousGeneratedColumn
)
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
mapping
.
source
!
=
null
)
{
sourceIdx
=
this
.
_sources
.
indexOf
(
mapping
.
source
)
;
next
+
=
base64VLQ
.
encode
(
sourceIdx
-
previousSource
)
;
previousSource
=
sourceIdx
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalLine
-
1
-
previousOriginalLine
)
;
previousOriginalLine
=
mapping
.
originalLine
-
1
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalColumn
-
previousOriginalColumn
)
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
mapping
.
name
!
=
null
)
{
nameIdx
=
this
.
_names
.
indexOf
(
mapping
.
name
)
;
next
+
=
base64VLQ
.
encode
(
nameIdx
-
previousName
)
;
previousName
=
nameIdx
;
}
}
result
+
=
next
;
}
return
result
;
}
;
SourceMapGenerator
.
prototype
.
_generateSourcesContent
=
function
SourceMapGenerator_generateSourcesContent
(
aSources
aSourceRoot
)
{
return
aSources
.
map
(
function
(
source
)
{
if
(
!
this
.
_sourcesContents
)
{
return
null
;
}
if
(
aSourceRoot
!
=
null
)
{
source
=
util
.
relative
(
aSourceRoot
source
)
;
}
var
key
=
util
.
toSetString
(
source
)
;
return
Object
.
prototype
.
hasOwnProperty
.
call
(
this
.
_sourcesContents
key
)
?
this
.
_sourcesContents
[
key
]
:
null
;
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
toJSON
=
function
SourceMapGenerator_toJSON
(
)
{
var
map
=
{
version
:
this
.
_version
sources
:
this
.
_sources
.
toArray
(
)
names
:
this
.
_names
.
toArray
(
)
mappings
:
this
.
_serializeMappings
(
)
}
;
if
(
this
.
_file
!
=
null
)
{
map
.
file
=
this
.
_file
;
}
if
(
this
.
_sourceRoot
!
=
null
)
{
map
.
sourceRoot
=
this
.
_sourceRoot
;
}
if
(
this
.
_sourcesContents
)
{
map
.
sourcesContent
=
this
.
_generateSourcesContent
(
map
.
sources
map
.
sourceRoot
)
;
}
return
map
;
}
;
SourceMapGenerator
.
prototype
.
toString
=
function
SourceMapGenerator_toString
(
)
{
return
JSON
.
stringify
(
this
.
toJSON
(
)
)
;
}
;
exports
.
SourceMapGenerator
=
SourceMapGenerator
;
}
function
(
module
exports
__webpack_require__
)
{
var
base64
=
__webpack_require__
(
21
)
;
var
VLQ_BASE_SHIFT
=
5
;
var
VLQ_BASE
=
1
<
<
VLQ_BASE_SHIFT
;
var
VLQ_BASE_MASK
=
VLQ_BASE
-
1
;
var
VLQ_CONTINUATION_BIT
=
VLQ_BASE
;
function
toVLQSigned
(
aValue
)
{
return
aValue
<
0
?
(
(
-
aValue
)
<
<
1
)
+
1
:
(
aValue
<
<
1
)
+
0
;
}
function
fromVLQSigned
(
aValue
)
{
var
isNegative
=
(
aValue
&
1
)
=
=
=
1
;
var
shifted
=
aValue
>
>
1
;
return
isNegative
?
-
shifted
:
shifted
;
}
exports
.
encode
=
function
base64VLQ_encode
(
aValue
)
{
var
encoded
=
"
"
;
var
digit
;
var
vlq
=
toVLQSigned
(
aValue
)
;
do
{
digit
=
vlq
&
VLQ_BASE_MASK
;
vlq
>
>
>
=
VLQ_BASE_SHIFT
;
if
(
vlq
>
0
)
{
digit
|
=
VLQ_CONTINUATION_BIT
;
}
encoded
+
=
base64
.
encode
(
digit
)
;
}
while
(
vlq
>
0
)
;
return
encoded
;
}
;
exports
.
decode
=
function
base64VLQ_decode
(
aStr
aIndex
aOutParam
)
{
var
strLen
=
aStr
.
length
;
var
result
=
0
;
var
shift
=
0
;
var
continuation
digit
;
do
{
if
(
aIndex
>
=
strLen
)
{
throw
new
Error
(
"
Expected
more
digits
in
base
64
VLQ
value
.
"
)
;
}
digit
=
base64
.
decode
(
aStr
.
charCodeAt
(
aIndex
+
+
)
)
;
if
(
digit
=
=
=
-
1
)
{
throw
new
Error
(
"
Invalid
base64
digit
:
"
+
aStr
.
charAt
(
aIndex
-
1
)
)
;
}
continuation
=
!
!
(
digit
&
VLQ_CONTINUATION_BIT
)
;
digit
&
=
VLQ_BASE_MASK
;
result
=
result
+
(
digit
<
<
shift
)
;
shift
+
=
VLQ_BASE_SHIFT
;
}
while
(
continuation
)
;
aOutParam
.
value
=
fromVLQSigned
(
result
)
;
aOutParam
.
rest
=
aIndex
;
}
;
}
function
(
module
exports
)
{
var
intToCharMap
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
.
split
(
'
'
)
;
exports
.
encode
=
function
(
number
)
{
if
(
0
<
=
number
&
&
number
<
intToCharMap
.
length
)
{
return
intToCharMap
[
number
]
;
}
throw
new
TypeError
(
"
Must
be
between
0
and
63
:
"
+
number
)
;
}
;
exports
.
decode
=
function
(
charCode
)
{
var
bigA
=
65
;
var
bigZ
=
90
;
var
littleA
=
97
;
var
littleZ
=
122
;
var
zero
=
48
;
var
nine
=
57
;
var
plus
=
43
;
var
slash
=
47
;
var
littleOffset
=
26
;
var
numberOffset
=
52
;
if
(
bigA
<
=
charCode
&
&
charCode
<
=
bigZ
)
{
return
(
charCode
-
bigA
)
;
}
if
(
littleA
<
=
charCode
&
&
charCode
<
=
littleZ
)
{
return
(
charCode
-
littleA
+
littleOffset
)
;
}
if
(
zero
<
=
charCode
&
&
charCode
<
=
nine
)
{
return
(
charCode
-
zero
+
numberOffset
)
;
}
if
(
charCode
=
=
plus
)
{
return
62
;
}
if
(
charCode
=
=
slash
)
{
return
63
;
}
return
-
1
;
}
;
}
function
(
module
exports
)
{
function
getArg
(
aArgs
aName
aDefaultValue
)
{
if
(
aName
in
aArgs
)
{
return
aArgs
[
aName
]
;
}
else
if
(
arguments
.
length
=
=
=
3
)
{
return
aDefaultValue
;
}
else
{
throw
new
Error
(
'
"
'
+
aName
+
'
"
is
a
required
argument
.
'
)
;
}
}
exports
.
getArg
=
getArg
;
var
urlRegexp
=
/
^
(
?
:
(
[
\
w
+
\
-
.
]
+
)
:
)
?
\
/
\
/
(
?
:
(
\
w
+
:
\
w
+
)
)
?
(
[
\
w
.
]
*
)
(
?
:
:
(
\
d
+
)
)
?
(
\
S
*
)
/
;
var
dataUrlRegexp
=
/
^
data
:
.
+
\
.
+
/
;
function
urlParse
(
aUrl
)
{
var
match
=
aUrl
.
match
(
urlRegexp
)
;
if
(
!
match
)
{
return
null
;
}
return
{
scheme
:
match
[
1
]
auth
:
match
[
2
]
host
:
match
[
3
]
port
:
match
[
4
]
path
:
match
[
5
]
}
;
}
exports
.
urlParse
=
urlParse
;
function
urlGenerate
(
aParsedUrl
)
{
var
url
=
'
'
;
if
(
aParsedUrl
.
scheme
)
{
url
+
=
aParsedUrl
.
scheme
+
'
:
'
;
}
url
+
=
'
/
/
'
;
if
(
aParsedUrl
.
auth
)
{
url
+
=
aParsedUrl
.
auth
+
'
'
;
}
if
(
aParsedUrl
.
host
)
{
url
+
=
aParsedUrl
.
host
;
}
if
(
aParsedUrl
.
port
)
{
url
+
=
"
:
"
+
aParsedUrl
.
port
}
if
(
aParsedUrl
.
path
)
{
url
+
=
aParsedUrl
.
path
;
}
return
url
;
}
exports
.
urlGenerate
=
urlGenerate
;
function
normalize
(
aPath
)
{
var
path
=
aPath
;
var
url
=
urlParse
(
aPath
)
;
if
(
url
)
{
if
(
!
url
.
path
)
{
return
aPath
;
}
path
=
url
.
path
;
}
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
;
var
parts
=
path
.
split
(
/
\
/
+
/
)
;
for
(
var
part
up
=
0
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
part
=
parts
[
i
]
;
if
(
part
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
part
=
=
=
'
.
.
'
)
{
up
+
+
;
}
else
if
(
up
>
0
)
{
if
(
part
=
=
=
'
'
)
{
parts
.
splice
(
i
+
1
up
)
;
up
=
0
;
}
else
{
parts
.
splice
(
i
2
)
;
up
-
-
;
}
}
}
path
=
parts
.
join
(
'
/
'
)
;
if
(
path
=
=
=
'
'
)
{
path
=
isAbsolute
?
'
/
'
:
'
.
'
;
}
if
(
url
)
{
url
.
path
=
path
;
return
urlGenerate
(
url
)
;
}
return
path
;
}
exports
.
normalize
=
normalize
;
function
join
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
if
(
aPath
=
=
=
"
"
)
{
aPath
=
"
.
"
;
}
var
aPathUrl
=
urlParse
(
aPath
)
;
var
aRootUrl
=
urlParse
(
aRoot
)
;
if
(
aRootUrl
)
{
aRoot
=
aRootUrl
.
path
|
|
'
/
'
;
}
if
(
aPathUrl
&
&
!
aPathUrl
.
scheme
)
{
if
(
aRootUrl
)
{
aPathUrl
.
scheme
=
aRootUrl
.
scheme
;
}
return
urlGenerate
(
aPathUrl
)
;
}
if
(
aPathUrl
|
|
aPath
.
match
(
dataUrlRegexp
)
)
{
return
aPath
;
}
if
(
aRootUrl
&
&
!
aRootUrl
.
host
&
&
!
aRootUrl
.
path
)
{
aRootUrl
.
host
=
aPath
;
return
urlGenerate
(
aRootUrl
)
;
}
var
joined
=
aPath
.
charAt
(
0
)
=
=
=
'
/
'
?
aPath
:
normalize
(
aRoot
.
replace
(
/
\
/
+
/
'
'
)
+
'
/
'
+
aPath
)
;
if
(
aRootUrl
)
{
aRootUrl
.
path
=
joined
;
return
urlGenerate
(
aRootUrl
)
;
}
return
joined
;
}
exports
.
join
=
join
;
exports
.
isAbsolute
=
function
(
aPath
)
{
return
aPath
.
charAt
(
0
)
=
=
=
'
/
'
|
|
!
!
aPath
.
match
(
urlRegexp
)
;
}
;
function
relative
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
aRoot
=
aRoot
.
replace
(
/
\
/
/
'
'
)
;
var
level
=
0
;
while
(
aPath
.
indexOf
(
aRoot
+
'
/
'
)
!
=
=
0
)
{
var
index
=
aRoot
.
lastIndexOf
(
"
/
"
)
;
if
(
index
<
0
)
{
return
aPath
;
}
aRoot
=
aRoot
.
slice
(
0
index
)
;
if
(
aRoot
.
match
(
/
^
(
[
^
\
/
]
+
:
\
/
)
?
\
/
*
/
)
)
{
return
aPath
;
}
+
+
level
;
}
return
Array
(
level
+
1
)
.
join
(
"
.
.
/
"
)
+
aPath
.
substr
(
aRoot
.
length
+
1
)
;
}
exports
.
relative
=
relative
;
var
supportsNullProto
=
(
function
(
)
{
var
obj
=
Object
.
create
(
null
)
;
return
!
(
'
__proto__
'
in
obj
)
;
}
(
)
)
;
function
identity
(
s
)
{
return
s
;
}
function
toSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
'
'
+
aStr
;
}
return
aStr
;
}
exports
.
toSetString
=
supportsNullProto
?
identity
:
toSetString
;
function
fromSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
aStr
.
slice
(
1
)
;
}
return
aStr
;
}
exports
.
fromSetString
=
supportsNullProto
?
identity
:
fromSetString
;
function
isProtoString
(
s
)
{
if
(
!
s
)
{
return
false
;
}
var
length
=
s
.
length
;
if
(
length
<
9
)
{
return
false
;
}
if
(
s
.
charCodeAt
(
length
-
1
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
2
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
3
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
4
)
!
=
=
116
|
|
s
.
charCodeAt
(
length
-
5
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
6
)
!
=
=
114
|
|
s
.
charCodeAt
(
length
-
7
)
!
=
=
112
|
|
s
.
charCodeAt
(
length
-
8
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
9
)
!
=
=
95
)
{
return
false
;
}
for
(
var
i
=
length
-
10
;
i
>
=
0
;
i
-
-
)
{
if
(
s
.
charCodeAt
(
i
)
!
=
=
36
)
{
return
false
;
}
}
return
true
;
}
function
compareByOriginalPositions
(
mappingA
mappingB
onlyCompareOriginal
)
{
var
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareOriginal
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByOriginalPositions
=
compareByOriginalPositions
;
function
compareByGeneratedPositionsDeflated
(
mappingA
mappingB
onlyCompareGenerated
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareGenerated
)
{
return
cmp
;
}
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByGeneratedPositionsDeflated
=
compareByGeneratedPositionsDeflated
;
function
strcmp
(
aStr1
aStr2
)
{
if
(
aStr1
=
=
=
aStr2
)
{
return
0
;
}
if
(
aStr1
>
aStr2
)
{
return
1
;
}
return
-
1
;
}
function
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
strcmp
(
mappingA
.
source
mappingB
.
source
)
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
strcmp
(
mappingA
.
name
mappingB
.
name
)
;
}
exports
.
compareByGeneratedPositionsInflated
=
compareByGeneratedPositionsInflated
;
}
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
22
)
;
var
has
=
Object
.
prototype
.
hasOwnProperty
;
function
ArraySet
(
)
{
this
.
_array
=
[
]
;
this
.
_set
=
Object
.
create
(
null
)
;
}
ArraySet
.
fromArray
=
function
ArraySet_fromArray
(
aArray
aAllowDuplicates
)
{
var
set
=
new
ArraySet
(
)
;
for
(
var
i
=
0
len
=
aArray
.
length
;
i
<
len
;
i
+
+
)
{
set
.
add
(
aArray
[
i
]
aAllowDuplicates
)
;
}
return
set
;
}
;
ArraySet
.
prototype
.
size
=
function
ArraySet_size
(
)
{
return
Object
.
getOwnPropertyNames
(
this
.
_set
)
.
length
;
}
;
ArraySet
.
prototype
.
add
=
function
ArraySet_add
(
aStr
aAllowDuplicates
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
var
isDuplicate
=
has
.
call
(
this
.
_set
sStr
)
;
var
idx
=
this
.
_array
.
length
;
if
(
!
isDuplicate
|
|
aAllowDuplicates
)
{
this
.
_array
.
push
(
aStr
)
;
}
if
(
!
isDuplicate
)
{
this
.
_set
[
sStr
]
=
idx
;
}
}
;
ArraySet
.
prototype
.
has
=
function
ArraySet_has
(
aStr
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
return
has
.
call
(
this
.
_set
sStr
)
;
}
;
ArraySet
.
prototype
.
indexOf
=
function
ArraySet_indexOf
(
aStr
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
if
(
has
.
call
(
this
.
_set
sStr
)
)
{
return
this
.
_set
[
sStr
]
;
}
throw
new
Error
(
'
"
'
+
aStr
+
'
"
is
not
in
the
set
.
'
)
;
}
;
ArraySet
.
prototype
.
at
=
function
ArraySet_at
(
aIdx
)
{
if
(
aIdx
>
=
0
&
&
aIdx
<
this
.
_array
.
length
)
{
return
this
.
_array
[
aIdx
]
;
}
throw
new
Error
(
'
No
element
indexed
by
'
+
aIdx
)
;
}
;
ArraySet
.
prototype
.
toArray
=
function
ArraySet_toArray
(
)
{
return
this
.
_array
.
slice
(
)
;
}
;
exports
.
ArraySet
=
ArraySet
;
}
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
22
)
;
function
generatedPositionAfter
(
mappingA
mappingB
)
{
var
lineA
=
mappingA
.
generatedLine
;
var
lineB
=
mappingB
.
generatedLine
;
var
columnA
=
mappingA
.
generatedColumn
;
var
columnB
=
mappingB
.
generatedColumn
;
return
lineB
>
lineA
|
|
lineB
=
=
lineA
&
&
columnB
>
=
columnA
|
|
util
.
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
<
=
0
;
}
function
MappingList
(
)
{
this
.
_array
=
[
]
;
this
.
_sorted
=
true
;
this
.
_last
=
{
generatedLine
:
-
1
generatedColumn
:
0
}
;
}
MappingList
.
prototype
.
unsortedForEach
=
function
MappingList_forEach
(
aCallback
aThisArg
)
{
this
.
_array
.
forEach
(
aCallback
aThisArg
)
;
}
;
MappingList
.
prototype
.
add
=
function
MappingList_add
(
aMapping
)
{
if
(
generatedPositionAfter
(
this
.
_last
aMapping
)
)
{
this
.
_last
=
aMapping
;
this
.
_array
.
push
(
aMapping
)
;
}
else
{
this
.
_sorted
=
false
;
this
.
_array
.
push
(
aMapping
)
;
}
}
;
MappingList
.
prototype
.
toArray
=
function
MappingList_toArray
(
)
{
if
(
!
this
.
_sorted
)
{
this
.
_array
.
sort
(
util
.
compareByGeneratedPositionsInflated
)
;
this
.
_sorted
=
true
;
}
return
this
.
_array
;
}
;
exports
.
MappingList
=
MappingList
;
}
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
22
)
;
var
binarySearch
=
__webpack_require__
(
26
)
;
var
ArraySet
=
__webpack_require__
(
23
)
.
ArraySet
;
var
base64VLQ
=
__webpack_require__
(
20
)
;
var
quickSort
=
__webpack_require__
(
27
)
.
quickSort
;
function
SourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
return
sourceMap
.
sections
!
=
null
?
new
IndexedSourceMapConsumer
(
sourceMap
)
:
new
BasicSourceMapConsumer
(
sourceMap
)
;
}
SourceMapConsumer
.
fromSourceMap
=
function
(
aSourceMap
)
{
return
BasicSourceMapConsumer
.
fromSourceMap
(
aSourceMap
)
;
}
SourceMapConsumer
.
prototype
.
_version
=
3
;
SourceMapConsumer
.
prototype
.
__generatedMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_generatedMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__generatedMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__generatedMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
__originalMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_originalMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__originalMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__originalMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
_charIsMappingSeparator
=
function
SourceMapConsumer_charIsMappingSeparator
(
aStr
index
)
{
var
c
=
aStr
.
charAt
(
index
)
;
return
c
=
=
=
"
;
"
|
|
c
=
=
=
"
"
;
}
;
SourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
throw
new
Error
(
"
Subclasses
must
implement
_parseMappings
"
)
;
}
;
SourceMapConsumer
.
GENERATED_ORDER
=
1
;
SourceMapConsumer
.
ORIGINAL_ORDER
=
2
;
SourceMapConsumer
.
GREATEST_LOWER_BOUND
=
1
;
SourceMapConsumer
.
LEAST_UPPER_BOUND
=
2
;
SourceMapConsumer
.
prototype
.
eachMapping
=
function
SourceMapConsumer_eachMapping
(
aCallback
aContext
aOrder
)
{
var
context
=
aContext
|
|
null
;
var
order
=
aOrder
|
|
SourceMapConsumer
.
GENERATED_ORDER
;
var
mappings
;
switch
(
order
)
{
case
SourceMapConsumer
.
GENERATED_ORDER
:
mappings
=
this
.
_generatedMappings
;
break
;
case
SourceMapConsumer
.
ORIGINAL_ORDER
:
mappings
=
this
.
_originalMappings
;
break
;
default
:
throw
new
Error
(
"
Unknown
order
of
iteration
.
"
)
;
}
var
sourceRoot
=
this
.
sourceRoot
;
mappings
.
map
(
function
(
mapping
)
{
var
source
=
mapping
.
source
=
=
=
null
?
null
:
this
.
_sources
.
at
(
mapping
.
source
)
;
if
(
source
!
=
null
&
&
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
sourceRoot
source
)
;
}
return
{
source
:
source
generatedLine
:
mapping
.
generatedLine
generatedColumn
:
mapping
.
generatedColumn
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
mapping
.
name
=
=
=
null
?
null
:
this
.
_names
.
at
(
mapping
.
name
)
}
;
}
this
)
.
forEach
(
aCallback
context
)
;
}
;
SourceMapConsumer
.
prototype
.
allGeneratedPositionsFor
=
function
SourceMapConsumer_allGeneratedPositionsFor
(
aArgs
)
{
var
line
=
util
.
getArg
(
aArgs
'
line
'
)
;
var
needle
=
{
source
:
util
.
getArg
(
aArgs
'
source
'
)
originalLine
:
line
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
0
)
}
;
if
(
this
.
sourceRoot
!
=
null
)
{
needle
.
source
=
util
.
relative
(
this
.
sourceRoot
needle
.
source
)
;
}
if
(
!
this
.
_sources
.
has
(
needle
.
source
)
)
{
return
[
]
;
}
needle
.
source
=
this
.
_sources
.
indexOf
(
needle
.
source
)
;
var
mappings
=
[
]
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
binarySearch
.
LEAST_UPPER_BOUND
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
aArgs
.
column
=
=
=
undefined
)
{
var
originalLine
=
mapping
.
originalLine
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
originalLine
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
else
{
var
originalColumn
=
mapping
.
originalColumn
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
line
&
&
mapping
.
originalColumn
=
=
originalColumn
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
}
return
mappings
;
}
;
exports
.
SourceMapConsumer
=
SourceMapConsumer
;
function
BasicSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sources
=
util
.
getArg
(
sourceMap
'
sources
'
)
;
var
names
=
util
.
getArg
(
sourceMap
'
names
'
[
]
)
;
var
sourceRoot
=
util
.
getArg
(
sourceMap
'
sourceRoot
'
null
)
;
var
sourcesContent
=
util
.
getArg
(
sourceMap
'
sourcesContent
'
null
)
;
var
mappings
=
util
.
getArg
(
sourceMap
'
mappings
'
)
;
var
file
=
util
.
getArg
(
sourceMap
'
file
'
null
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
sources
=
sources
.
map
(
String
)
.
map
(
util
.
normalize
)
.
map
(
function
(
source
)
{
return
sourceRoot
&
&
util
.
isAbsolute
(
sourceRoot
)
&
&
util
.
isAbsolute
(
source
)
?
util
.
relative
(
sourceRoot
source
)
:
source
;
}
)
;
this
.
_names
=
ArraySet
.
fromArray
(
names
.
map
(
String
)
true
)
;
this
.
_sources
=
ArraySet
.
fromArray
(
sources
true
)
;
this
.
sourceRoot
=
sourceRoot
;
this
.
sourcesContent
=
sourcesContent
;
this
.
_mappings
=
mappings
;
this
.
file
=
file
;
}
BasicSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
BasicSourceMapConsumer
.
prototype
.
consumer
=
SourceMapConsumer
;
BasicSourceMapConsumer
.
fromSourceMap
=
function
SourceMapConsumer_fromSourceMap
(
aSourceMap
)
{
var
smc
=
Object
.
create
(
BasicSourceMapConsumer
.
prototype
)
;
var
names
=
smc
.
_names
=
ArraySet
.
fromArray
(
aSourceMap
.
_names
.
toArray
(
)
true
)
;
var
sources
=
smc
.
_sources
=
ArraySet
.
fromArray
(
aSourceMap
.
_sources
.
toArray
(
)
true
)
;
smc
.
sourceRoot
=
aSourceMap
.
_sourceRoot
;
smc
.
sourcesContent
=
aSourceMap
.
_generateSourcesContent
(
smc
.
_sources
.
toArray
(
)
smc
.
sourceRoot
)
;
smc
.
file
=
aSourceMap
.
_file
;
var
generatedMappings
=
aSourceMap
.
_mappings
.
toArray
(
)
.
slice
(
)
;
var
destGeneratedMappings
=
smc
.
__generatedMappings
=
[
]
;
var
destOriginalMappings
=
smc
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
length
=
generatedMappings
.
length
;
i
<
length
;
i
+
+
)
{
var
srcMapping
=
generatedMappings
[
i
]
;
var
destMapping
=
new
Mapping
;
destMapping
.
generatedLine
=
srcMapping
.
generatedLine
;
destMapping
.
generatedColumn
=
srcMapping
.
generatedColumn
;
if
(
srcMapping
.
source
)
{
destMapping
.
source
=
sources
.
indexOf
(
srcMapping
.
source
)
;
destMapping
.
originalLine
=
srcMapping
.
originalLine
;
destMapping
.
originalColumn
=
srcMapping
.
originalColumn
;
if
(
srcMapping
.
name
)
{
destMapping
.
name
=
names
.
indexOf
(
srcMapping
.
name
)
;
}
destOriginalMappings
.
push
(
destMapping
)
;
}
destGeneratedMappings
.
push
(
destMapping
)
;
}
quickSort
(
smc
.
__originalMappings
util
.
compareByOriginalPositions
)
;
return
smc
;
}
;
BasicSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
BasicSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
return
this
.
_sources
.
toArray
(
)
.
map
(
function
(
s
)
{
return
this
.
sourceRoot
!
=
null
?
util
.
join
(
this
.
sourceRoot
s
)
:
s
;
}
this
)
;
}
}
)
;
function
Mapping
(
)
{
this
.
generatedLine
=
0
;
this
.
generatedColumn
=
0
;
this
.
source
=
null
;
this
.
originalLine
=
null
;
this
.
originalColumn
=
null
;
this
.
name
=
null
;
}
BasicSourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
var
generatedLine
=
1
;
var
previousGeneratedColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousOriginalColumn
=
0
;
var
previousSource
=
0
;
var
previousName
=
0
;
var
length
=
aStr
.
length
;
var
index
=
0
;
var
cachedSegments
=
{
}
;
var
temp
=
{
}
;
var
originalMappings
=
[
]
;
var
generatedMappings
=
[
]
;
var
mapping
str
segment
end
value
;
while
(
index
<
length
)
{
if
(
aStr
.
charAt
(
index
)
=
=
=
'
;
'
)
{
generatedLine
+
+
;
index
+
+
;
previousGeneratedColumn
=
0
;
}
else
if
(
aStr
.
charAt
(
index
)
=
=
=
'
'
)
{
index
+
+
;
}
else
{
mapping
=
new
Mapping
(
)
;
mapping
.
generatedLine
=
generatedLine
;
for
(
end
=
index
;
end
<
length
;
end
+
+
)
{
if
(
this
.
_charIsMappingSeparator
(
aStr
end
)
)
{
break
;
}
}
str
=
aStr
.
slice
(
index
end
)
;
segment
=
cachedSegments
[
str
]
;
if
(
segment
)
{
index
+
=
str
.
length
;
}
else
{
segment
=
[
]
;
while
(
index
<
end
)
{
base64VLQ
.
decode
(
aStr
index
temp
)
;
value
=
temp
.
value
;
index
=
temp
.
rest
;
segment
.
push
(
value
)
;
}
if
(
segment
.
length
=
=
=
2
)
{
throw
new
Error
(
'
Found
a
source
but
no
line
and
column
'
)
;
}
if
(
segment
.
length
=
=
=
3
)
{
throw
new
Error
(
'
Found
a
source
and
line
but
no
column
'
)
;
}
cachedSegments
[
str
]
=
segment
;
}
mapping
.
generatedColumn
=
previousGeneratedColumn
+
segment
[
0
]
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
segment
.
length
>
1
)
{
mapping
.
source
=
previousSource
+
segment
[
1
]
;
previousSource
+
=
segment
[
1
]
;
mapping
.
originalLine
=
previousOriginalLine
+
segment
[
2
]
;
previousOriginalLine
=
mapping
.
originalLine
;
mapping
.
originalLine
+
=
1
;
mapping
.
originalColumn
=
previousOriginalColumn
+
segment
[
3
]
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
segment
.
length
>
4
)
{
mapping
.
name
=
previousName
+
segment
[
4
]
;
previousName
+
=
segment
[
4
]
;
}
}
generatedMappings
.
push
(
mapping
)
;
if
(
typeof
mapping
.
originalLine
=
=
=
'
number
'
)
{
originalMappings
.
push
(
mapping
)
;
}
}
}
quickSort
(
generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
this
.
__generatedMappings
=
generatedMappings
;
quickSort
(
originalMappings
util
.
compareByOriginalPositions
)
;
this
.
__originalMappings
=
originalMappings
;
}
;
BasicSourceMapConsumer
.
prototype
.
_findMapping
=
function
SourceMapConsumer_findMapping
(
aNeedle
aMappings
aLineName
aColumnName
aComparator
aBias
)
{
if
(
aNeedle
[
aLineName
]
<
=
0
)
{
throw
new
TypeError
(
'
Line
must
be
greater
than
or
equal
to
1
got
'
+
aNeedle
[
aLineName
]
)
;
}
if
(
aNeedle
[
aColumnName
]
<
0
)
{
throw
new
TypeError
(
'
Column
must
be
greater
than
or
equal
to
0
got
'
+
aNeedle
[
aColumnName
]
)
;
}
return
binarySearch
.
search
(
aNeedle
aMappings
aComparator
aBias
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
computeColumnSpans
=
function
SourceMapConsumer_computeColumnSpans
(
)
{
for
(
var
index
=
0
;
index
<
this
.
_generatedMappings
.
length
;
+
+
index
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
index
+
1
<
this
.
_generatedMappings
.
length
)
{
var
nextMapping
=
this
.
_generatedMappings
[
index
+
1
]
;
if
(
mapping
.
generatedLine
=
=
=
nextMapping
.
generatedLine
)
{
mapping
.
lastGeneratedColumn
=
nextMapping
.
generatedColumn
-
1
;
continue
;
}
}
mapping
.
lastGeneratedColumn
=
Infinity
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
SourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_generatedMappings
"
generatedLine
"
"
generatedColumn
"
util
.
compareByGeneratedPositionsDeflated
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
mapping
.
generatedLine
=
=
=
needle
.
generatedLine
)
{
var
source
=
util
.
getArg
(
mapping
'
source
'
null
)
;
if
(
source
!
=
=
null
)
{
source
=
this
.
_sources
.
at
(
source
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
this
.
sourceRoot
source
)
;
}
}
var
name
=
util
.
getArg
(
mapping
'
name
'
null
)
;
if
(
name
!
=
=
null
)
{
name
=
this
.
_names
.
at
(
name
)
;
}
return
{
source
:
source
line
:
util
.
getArg
(
mapping
'
originalLine
'
null
)
column
:
util
.
getArg
(
mapping
'
originalColumn
'
null
)
name
:
name
}
;
}
}
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
;
BasicSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
BasicSourceMapConsumer_hasContentsOfAllSources
(
)
{
if
(
!
this
.
sourcesContent
)
{
return
false
;
}
return
this
.
sourcesContent
.
length
>
=
this
.
_sources
.
size
(
)
&
&
!
this
.
sourcesContent
.
some
(
function
(
sc
)
{
return
sc
=
=
null
;
}
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
SourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
if
(
!
this
.
sourcesContent
)
{
return
null
;
}
if
(
this
.
sourceRoot
!
=
null
)
{
aSource
=
util
.
relative
(
this
.
sourceRoot
aSource
)
;
}
if
(
this
.
_sources
.
has
(
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
aSource
)
]
;
}
var
url
;
if
(
this
.
sourceRoot
!
=
null
&
&
(
url
=
util
.
urlParse
(
this
.
sourceRoot
)
)
)
{
var
fileUriAbsPath
=
aSource
.
replace
(
/
^
file
:
\
/
\
/
/
"
"
)
;
if
(
url
.
scheme
=
=
"
file
"
&
&
this
.
_sources
.
has
(
fileUriAbsPath
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
fileUriAbsPath
)
]
}
if
(
(
!
url
.
path
|
|
url
.
path
=
=
"
/
"
)
&
&
this
.
_sources
.
has
(
"
/
"
+
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
"
/
"
+
aSource
)
]
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
SourceMapConsumer_generatedPositionFor
(
aArgs
)
{
var
source
=
util
.
getArg
(
aArgs
'
source
'
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
sourceRoot
source
)
;
}
if
(
!
this
.
_sources
.
has
(
source
)
)
{
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
needle
=
{
source
:
source
originalLine
:
util
.
getArg
(
aArgs
'
line
'
)
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
mapping
.
source
=
=
=
needle
.
source
)
{
return
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
;
}
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
;
exports
.
BasicSourceMapConsumer
=
BasicSourceMapConsumer
;
function
IndexedSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sections
=
util
.
getArg
(
sourceMap
'
sections
'
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
var
lastOffset
=
{
line
:
-
1
column
:
0
}
;
this
.
_sections
=
sections
.
map
(
function
(
s
)
{
if
(
s
.
url
)
{
throw
new
Error
(
'
Support
for
url
field
in
sections
not
implemented
.
'
)
;
}
var
offset
=
util
.
getArg
(
s
'
offset
'
)
;
var
offsetLine
=
util
.
getArg
(
offset
'
line
'
)
;
var
offsetColumn
=
util
.
getArg
(
offset
'
column
'
)
;
if
(
offsetLine
<
lastOffset
.
line
|
|
(
offsetLine
=
=
=
lastOffset
.
line
&
&
offsetColumn
<
lastOffset
.
column
)
)
{
throw
new
Error
(
'
Section
offsets
must
be
ordered
and
non
-
overlapping
.
'
)
;
}
lastOffset
=
offset
;
return
{
generatedOffset
:
{
generatedLine
:
offsetLine
+
1
generatedColumn
:
offsetColumn
+
1
}
consumer
:
new
SourceMapConsumer
(
util
.
getArg
(
s
'
map
'
)
)
}
}
)
;
}
IndexedSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
IndexedSourceMapConsumer
.
prototype
.
constructor
=
SourceMapConsumer
;
IndexedSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
IndexedSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
var
sources
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
this
.
_sections
[
i
]
.
consumer
.
sources
.
length
;
j
+
+
)
{
sources
.
push
(
this
.
_sections
[
i
]
.
consumer
.
sources
[
j
]
)
;
}
}
return
sources
;
}
}
)
;
IndexedSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
IndexedSourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
sectionIndex
=
binarySearch
.
search
(
needle
this
.
_sections
function
(
needle
section
)
{
var
cmp
=
needle
.
generatedLine
-
section
.
generatedOffset
.
generatedLine
;
if
(
cmp
)
{
return
cmp
;
}
return
(
needle
.
generatedColumn
-
section
.
generatedOffset
.
generatedColumn
)
;
}
)
;
var
section
=
this
.
_sections
[
sectionIndex
]
;
if
(
!
section
)
{
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
return
section
.
consumer
.
originalPositionFor
(
{
line
:
needle
.
generatedLine
-
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
needle
.
generatedColumn
-
(
section
.
generatedOffset
.
generatedLine
=
=
=
needle
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
bias
:
aArgs
.
bias
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
IndexedSourceMapConsumer_hasContentsOfAllSources
(
)
{
return
this
.
_sections
.
every
(
function
(
s
)
{
return
s
.
consumer
.
hasContentsOfAllSources
(
)
;
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
IndexedSourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
content
=
section
.
consumer
.
sourceContentFor
(
aSource
true
)
;
if
(
content
)
{
return
content
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
IndexedSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
IndexedSourceMapConsumer_generatedPositionFor
(
aArgs
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
if
(
section
.
consumer
.
sources
.
indexOf
(
util
.
getArg
(
aArgs
'
source
'
)
)
=
=
=
-
1
)
{
continue
;
}
var
generatedPosition
=
section
.
consumer
.
generatedPositionFor
(
aArgs
)
;
if
(
generatedPosition
)
{
var
ret
=
{
line
:
generatedPosition
.
line
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
generatedPosition
.
column
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
generatedPosition
.
line
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
}
;
return
ret
;
}
}
return
{
line
:
null
column
:
null
}
;
}
;
IndexedSourceMapConsumer
.
prototype
.
_parseMappings
=
function
IndexedSourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
this
.
__generatedMappings
=
[
]
;
this
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
sectionMappings
=
section
.
consumer
.
_generatedMappings
;
for
(
var
j
=
0
;
j
<
sectionMappings
.
length
;
j
+
+
)
{
var
mapping
=
sectionMappings
[
j
]
;
var
source
=
section
.
consumer
.
_sources
.
at
(
mapping
.
source
)
;
if
(
section
.
consumer
.
sourceRoot
!
=
=
null
)
{
source
=
util
.
join
(
section
.
consumer
.
sourceRoot
source
)
;
}
this
.
_sources
.
add
(
source
)
;
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
name
=
section
.
consumer
.
_names
.
at
(
mapping
.
name
)
;
this
.
_names
.
add
(
name
)
;
name
=
this
.
_names
.
indexOf
(
name
)
;
var
adjustedMapping
=
{
source
:
source
generatedLine
:
mapping
.
generatedLine
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
generatedColumn
:
mapping
.
generatedColumn
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
mapping
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
name
}
;
this
.
__generatedMappings
.
push
(
adjustedMapping
)
;
if
(
typeof
adjustedMapping
.
originalLine
=
=
=
'
number
'
)
{
this
.
__originalMappings
.
push
(
adjustedMapping
)
;
}
}
}
quickSort
(
this
.
__generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
quickSort
(
this
.
__originalMappings
util
.
compareByOriginalPositions
)
;
}
;
exports
.
IndexedSourceMapConsumer
=
IndexedSourceMapConsumer
;
}
function
(
module
exports
)
{
exports
.
GREATEST_LOWER_BOUND
=
1
;
exports
.
LEAST_UPPER_BOUND
=
2
;
function
recursiveSearch
(
aLow
aHigh
aNeedle
aHaystack
aCompare
aBias
)
{
var
mid
=
Math
.
floor
(
(
aHigh
-
aLow
)
/
2
)
+
aLow
;
var
cmp
=
aCompare
(
aNeedle
aHaystack
[
mid
]
true
)
;
if
(
cmp
=
=
=
0
)
{
return
mid
;
}
else
if
(
cmp
>
0
)
{
if
(
aHigh
-
mid
>
1
)
{
return
recursiveSearch
(
mid
aHigh
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
aHigh
<
aHaystack
.
length
?
aHigh
:
-
1
;
}
else
{
return
mid
;
}
}
else
{
if
(
mid
-
aLow
>
1
)
{
return
recursiveSearch
(
aLow
mid
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
mid
;
}
else
{
return
aLow
<
0
?
-
1
:
aLow
;
}
}
}
exports
.
search
=
function
search
(
aNeedle
aHaystack
aCompare
aBias
)
{
if
(
aHaystack
.
length
=
=
=
0
)
{
return
-
1
;
}
var
index
=
recursiveSearch
(
-
1
aHaystack
.
length
aNeedle
aHaystack
aCompare
aBias
|
|
exports
.
GREATEST_LOWER_BOUND
)
;
if
(
index
<
0
)
{
return
-
1
;
}
while
(
index
-
1
>
=
0
)
{
if
(
aCompare
(
aHaystack
[
index
]
aHaystack
[
index
-
1
]
true
)
!
=
=
0
)
{
break
;
}
-
-
index
;
}
return
index
;
}
;
}
function
(
module
exports
)
{
function
swap
(
ary
x
y
)
{
var
temp
=
ary
[
x
]
;
ary
[
x
]
=
ary
[
y
]
;
ary
[
y
]
=
temp
;
}
function
randomIntInRange
(
low
high
)
{
return
Math
.
round
(
low
+
(
Math
.
random
(
)
*
(
high
-
low
)
)
)
;
}
function
doQuickSort
(
ary
comparator
p
r
)
{
if
(
p
<
r
)
{
var
pivotIndex
=
randomIntInRange
(
p
r
)
;
var
i
=
p
-
1
;
swap
(
ary
pivotIndex
r
)
;
var
pivot
=
ary
[
r
]
;
for
(
var
j
=
p
;
j
<
r
;
j
+
+
)
{
if
(
comparator
(
ary
[
j
]
pivot
)
<
=
0
)
{
i
+
=
1
;
swap
(
ary
i
j
)
;
}
}
swap
(
ary
i
+
1
j
)
;
var
q
=
i
+
1
;
doQuickSort
(
ary
comparator
p
q
-
1
)
;
doQuickSort
(
ary
comparator
q
+
1
r
)
;
}
}
exports
.
quickSort
=
function
(
ary
comparator
)
{
doQuickSort
(
ary
comparator
0
ary
.
length
-
1
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
SourceMapGenerator
=
__webpack_require__
(
19
)
.
SourceMapGenerator
;
var
util
=
__webpack_require__
(
22
)
;
var
REGEX_NEWLINE
=
/
(
\
r
?
\
n
)
/
;
var
NEWLINE_CODE
=
10
;
var
isSourceNode
=
"
isSourceNode
"
;
function
SourceNode
(
aLine
aColumn
aSource
aChunks
aName
)
{
this
.
children
=
[
]
;
this
.
sourceContents
=
{
}
;
this
.
line
=
aLine
=
=
null
?
null
:
aLine
;
this
.
column
=
aColumn
=
=
null
?
null
:
aColumn
;
this
.
source
=
aSource
=
=
null
?
null
:
aSource
;
this
.
name
=
aName
=
=
null
?
null
:
aName
;
this
[
isSourceNode
]
=
true
;
if
(
aChunks
!
=
null
)
this
.
add
(
aChunks
)
;
}
SourceNode
.
fromStringWithSourceMap
=
function
SourceNode_fromStringWithSourceMap
(
aGeneratedCode
aSourceMapConsumer
aRelativePath
)
{
var
node
=
new
SourceNode
(
)
;
var
remainingLines
=
aGeneratedCode
.
split
(
REGEX_NEWLINE
)
;
var
shiftNextLine
=
function
(
)
{
var
lineContents
=
remainingLines
.
shift
(
)
;
var
newLine
=
remainingLines
.
shift
(
)
|
|
"
"
;
return
lineContents
+
newLine
;
}
;
var
lastGeneratedLine
=
1
lastGeneratedColumn
=
0
;
var
lastMapping
=
null
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
if
(
lastMapping
!
=
=
null
)
{
if
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
lastGeneratedColumn
=
0
;
}
else
{
var
nextLine
=
remainingLines
[
0
]
;
var
code
=
nextLine
.
substr
(
0
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
remainingLines
[
0
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
addMappingWithCode
(
lastMapping
code
)
;
lastMapping
=
mapping
;
return
;
}
}
while
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
node
.
add
(
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
}
if
(
lastGeneratedColumn
<
mapping
.
generatedColumn
)
{
var
nextLine
=
remainingLines
[
0
]
;
node
.
add
(
nextLine
.
substr
(
0
mapping
.
generatedColumn
)
)
;
remainingLines
[
0
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
}
lastMapping
=
mapping
;
}
this
)
;
if
(
remainingLines
.
length
>
0
)
{
if
(
lastMapping
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
}
node
.
add
(
remainingLines
.
join
(
"
"
)
)
;
}
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aRelativePath
!
=
null
)
{
sourceFile
=
util
.
join
(
aRelativePath
sourceFile
)
;
}
node
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
node
;
function
addMappingWithCode
(
mapping
code
)
{
if
(
mapping
=
=
=
null
|
|
mapping
.
source
=
=
=
undefined
)
{
node
.
add
(
code
)
;
}
else
{
var
source
=
aRelativePath
?
util
.
join
(
aRelativePath
mapping
.
source
)
:
mapping
.
source
;
node
.
add
(
new
SourceNode
(
mapping
.
originalLine
mapping
.
originalColumn
source
code
mapping
.
name
)
)
;
}
}
}
;
SourceNode
.
prototype
.
add
=
function
SourceNode_add
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
aChunk
.
forEach
(
function
(
chunk
)
{
this
.
add
(
chunk
)
;
}
this
)
;
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
if
(
aChunk
)
{
this
.
children
.
push
(
aChunk
)
;
}
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
prepend
=
function
SourceNode_prepend
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
for
(
var
i
=
aChunk
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
prepend
(
aChunk
[
i
]
)
;
}
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
this
.
children
.
unshift
(
aChunk
)
;
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
walk
=
function
SourceNode_walk
(
aFn
)
{
var
chunk
;
for
(
var
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
chunk
=
this
.
children
[
i
]
;
if
(
chunk
[
isSourceNode
]
)
{
chunk
.
walk
(
aFn
)
;
}
else
{
if
(
chunk
!
=
=
'
'
)
{
aFn
(
chunk
{
source
:
this
.
source
line
:
this
.
line
column
:
this
.
column
name
:
this
.
name
}
)
;
}
}
}
}
;
SourceNode
.
prototype
.
join
=
function
SourceNode_join
(
aSep
)
{
var
newChildren
;
var
i
;
var
len
=
this
.
children
.
length
;
if
(
len
>
0
)
{
newChildren
=
[
]
;
for
(
i
=
0
;
i
<
len
-
1
;
i
+
+
)
{
newChildren
.
push
(
this
.
children
[
i
]
)
;
newChildren
.
push
(
aSep
)
;
}
newChildren
.
push
(
this
.
children
[
i
]
)
;
this
.
children
=
newChildren
;
}
return
this
;
}
;
SourceNode
.
prototype
.
replaceRight
=
function
SourceNode_replaceRight
(
aPattern
aReplacement
)
{
var
lastChild
=
this
.
children
[
this
.
children
.
length
-
1
]
;
if
(
lastChild
[
isSourceNode
]
)
{
lastChild
.
replaceRight
(
aPattern
aReplacement
)
;
}
else
if
(
typeof
lastChild
=
=
=
'
string
'
)
{
this
.
children
[
this
.
children
.
length
-
1
]
=
lastChild
.
replace
(
aPattern
aReplacement
)
;
}
else
{
this
.
children
.
push
(
'
'
.
replace
(
aPattern
aReplacement
)
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
setSourceContent
=
function
SourceNode_setSourceContent
(
aSourceFile
aSourceContent
)
{
this
.
sourceContents
[
util
.
toSetString
(
aSourceFile
)
]
=
aSourceContent
;
}
;
SourceNode
.
prototype
.
walkSourceContents
=
function
SourceNode_walkSourceContents
(
aFn
)
{
for
(
var
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
if
(
this
.
children
[
i
]
[
isSourceNode
]
)
{
this
.
children
[
i
]
.
walkSourceContents
(
aFn
)
;
}
}
var
sources
=
Object
.
keys
(
this
.
sourceContents
)
;
for
(
var
i
=
0
len
=
sources
.
length
;
i
<
len
;
i
+
+
)
{
aFn
(
util
.
fromSetString
(
sources
[
i
]
)
this
.
sourceContents
[
sources
[
i
]
]
)
;
}
}
;
SourceNode
.
prototype
.
toString
=
function
SourceNode_toString
(
)
{
var
str
=
"
"
;
this
.
walk
(
function
(
chunk
)
{
str
+
=
chunk
;
}
)
;
return
str
;
}
;
SourceNode
.
prototype
.
toStringWithSourceMap
=
function
SourceNode_toStringWithSourceMap
(
aArgs
)
{
var
generated
=
{
code
:
"
"
line
:
1
column
:
0
}
;
var
map
=
new
SourceMapGenerator
(
aArgs
)
;
var
sourceMappingActive
=
false
;
var
lastOriginalSource
=
null
;
var
lastOriginalLine
=
null
;
var
lastOriginalColumn
=
null
;
var
lastOriginalName
=
null
;
this
.
walk
(
function
(
chunk
original
)
{
generated
.
code
+
=
chunk
;
if
(
original
.
source
!
=
=
null
&
&
original
.
line
!
=
=
null
&
&
original
.
column
!
=
=
null
)
{
if
(
lastOriginalSource
!
=
=
original
.
source
|
|
lastOriginalLine
!
=
=
original
.
line
|
|
lastOriginalColumn
!
=
=
original
.
column
|
|
lastOriginalName
!
=
=
original
.
name
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
lastOriginalSource
=
original
.
source
;
lastOriginalLine
=
original
.
line
;
lastOriginalColumn
=
original
.
column
;
lastOriginalName
=
original
.
name
;
sourceMappingActive
=
true
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
}
)
;
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
for
(
var
idx
=
0
length
=
chunk
.
length
;
idx
<
length
;
idx
+
+
)
{
if
(
chunk
.
charCodeAt
(
idx
)
=
=
=
NEWLINE_CODE
)
{
generated
.
line
+
+
;
generated
.
column
=
0
;
if
(
idx
+
1
=
=
=
length
)
{
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
}
else
{
generated
.
column
+
+
;
}
}
}
)
;
this
.
walkSourceContents
(
function
(
sourceFile
sourceContent
)
{
map
.
setSourceContent
(
sourceFile
sourceContent
)
;
}
)
;
return
{
code
:
generated
.
code
map
:
map
}
;
}
;
exports
.
SourceNode
=
SourceNode
;
}
function
(
module
exports
)
{
function
assert
(
condition
message
)
{
if
(
!
condition
)
{
throw
new
Error
(
Assertion
failure
:
{
message
}
)
;
}
}
module
.
exports
=
assert
;
}
]
)
}
)
;
;
