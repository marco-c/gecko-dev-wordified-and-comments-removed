"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
loader
.
lazyRequireGetter
(
this
[
"
clearNamedTimeout
"
"
setNamedTimeout
"
]
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
naturalSortCaseInsensitive
"
"
devtools
/
shared
/
natural
-
sort
"
true
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
AFTER_SCROLL_DELAY
=
100
;
const
EVENTS
=
{
CELL_EDIT
:
"
cell
-
edit
"
COLUMN_SORTED
:
"
column
-
sorted
"
COLUMN_TOGGLED
:
"
column
-
toggled
"
FIELDS_EDITABLE
:
"
fields
-
editable
"
HEADER_CONTEXT_MENU
:
"
header
-
context
-
menu
"
ROW_EDIT
:
"
row
-
edit
"
ROW_CONTEXT_MENU
:
"
row
-
context
-
menu
"
ROW_REMOVED
:
"
row
-
removed
"
ROW_SELECTED
:
"
row
-
selected
"
ROW_UPDATED
:
"
row
-
updated
"
TABLE_CLEARED
:
"
table
-
cleared
"
TABLE_FILTERED
:
"
table
-
filtered
"
SCROLL_END
:
"
scroll
-
end
"
}
;
Object
.
defineProperty
(
this
"
EVENTS
"
{
value
:
EVENTS
enumerable
:
true
writable
:
false
}
)
;
function
TableWidget
(
node
options
=
{
}
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
document
=
node
.
ownerDocument
;
this
.
window
=
this
.
document
.
defaultView
;
this
.
_parent
=
node
;
const
{
initialColumns
emptyText
uniqueId
highlightUpdated
removableColumns
firstColumn
wrapTextInElements
cellContextMenuId
l10n
}
=
options
;
this
.
emptyText
=
emptyText
|
|
"
"
;
this
.
uniqueId
=
uniqueId
|
|
"
name
"
;
this
.
wrapTextInElements
=
wrapTextInElements
|
|
false
;
this
.
firstColumn
=
firstColumn
|
|
"
"
;
this
.
highlightUpdated
=
highlightUpdated
|
|
false
;
this
.
removableColumns
=
removableColumns
!
=
=
false
;
this
.
cellContextMenuId
=
cellContextMenuId
;
this
.
l10n
=
l10n
;
this
.
tbody
=
this
.
document
.
createXULElement
(
"
hbox
"
)
;
this
.
tbody
.
className
=
"
table
-
widget
-
body
theme
-
body
"
;
this
.
tbody
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
tbody
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
_parent
.
appendChild
(
this
.
tbody
)
;
this
.
afterScroll
=
this
.
afterScroll
.
bind
(
this
)
;
this
.
tbody
.
addEventListener
(
"
scroll
"
this
.
onScroll
.
bind
(
this
)
)
;
this
.
placeholder
=
this
.
document
.
createElement
(
"
div
"
)
;
this
.
placeholder
.
className
=
"
plain
table
-
widget
-
empty
-
text
"
;
this
.
_parent
.
appendChild
(
this
.
placeholder
)
;
this
.
setPlaceholder
(
this
.
emptyText
)
;
this
.
items
=
new
Map
(
)
;
this
.
columns
=
new
Map
(
)
;
if
(
this
.
removableColumns
)
{
this
.
onPopupCommand
=
this
.
onPopupCommand
.
bind
(
this
)
;
this
.
setupHeadersContextMenu
(
)
;
}
if
(
initialColumns
)
{
this
.
setColumns
(
initialColumns
uniqueId
)
;
}
this
.
bindSelectedRow
=
id
=
>
{
this
.
selectedRow
=
id
;
}
;
this
.
on
(
EVENTS
.
ROW_SELECTED
this
.
bindSelectedRow
)
;
this
.
onChange
=
this
.
onChange
.
bind
(
this
)
;
this
.
onEditorDestroyed
=
this
.
onEditorDestroyed
.
bind
(
this
)
;
this
.
onEditorTab
=
this
.
onEditorTab
.
bind
(
this
)
;
this
.
onKeydown
=
this
.
onKeydown
.
bind
(
this
)
;
this
.
onMousedown
=
this
.
onMousedown
.
bind
(
this
)
;
this
.
onRowRemoved
=
this
.
onRowRemoved
.
bind
(
this
)
;
this
.
document
.
addEventListener
(
"
keydown
"
this
.
onKeydown
)
;
this
.
document
.
addEventListener
(
"
mousedown
"
this
.
onMousedown
)
;
}
TableWidget
.
prototype
=
{
items
:
null
editBookmark
:
null
scrollIntoViewOnUpdate
:
null
get
hasScrollbar
(
)
{
return
this
.
tbody
.
scrollHeight
>
this
.
tbody
.
clientHeight
;
}
get
headersContextMenu
(
)
{
if
(
this
.
menupopup
)
{
return
this
.
menupopup
.
id
;
}
return
null
;
}
set
selectedRow
(
id
)
{
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
if
(
id
|
|
id
=
=
=
"
"
)
{
column
.
selectRow
(
id
[
this
.
uniqueId
]
|
|
id
)
;
}
else
{
column
.
selectedRow
=
null
;
column
.
selectRow
(
null
)
;
}
}
}
get
hasSelectedRow
(
)
{
return
(
this
.
columns
.
get
(
this
.
uniqueId
)
&
&
this
.
columns
.
get
(
this
.
uniqueId
)
.
selectedRow
)
;
}
get
selectedRow
(
)
{
return
this
.
items
.
get
(
this
.
columns
.
get
(
this
.
uniqueId
)
.
selectedRow
)
;
}
set
selectedIndex
(
index
)
{
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
column
.
selectRowAt
(
index
)
;
}
}
get
selectedIndex
(
)
{
return
this
.
columns
.
get
(
this
.
uniqueId
)
.
selectedIndex
;
}
get
visibleSelectedIndex
(
)
{
const
column
=
this
.
firstVisibleColumn
;
const
cells
=
column
.
visibleCellNodes
;
for
(
let
i
=
0
;
i
<
cells
.
length
;
i
+
+
)
{
if
(
cells
[
i
]
.
classList
.
contains
(
"
theme
-
selected
"
)
)
{
return
i
;
}
}
return
-
1
;
}
get
firstVisibleColumn
(
)
{
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
if
(
column
.
_private
)
{
continue
;
}
if
(
column
.
column
.
clientHeight
>
0
)
{
return
column
;
}
}
return
null
;
}
get
editableColumns
(
)
{
const
filter
=
columns
=
>
{
columns
=
[
.
.
.
columns
]
.
filter
(
col
=
>
{
if
(
col
.
clientWidth
=
=
=
0
)
{
return
false
;
}
const
cell
=
col
.
querySelector
(
"
.
table
-
widget
-
cell
"
)
;
for
(
const
selector
of
this
.
_editableFieldsEngine
.
selectors
)
{
if
(
cell
.
matches
(
selector
)
)
{
return
true
;
}
}
return
false
;
}
)
;
return
columns
;
}
;
const
columns
=
this
.
_parent
.
querySelectorAll
(
"
.
table
-
widget
-
column
"
)
;
return
filter
(
columns
)
;
}
onChange
(
data
)
{
const
changedField
=
data
.
change
.
field
;
const
colName
=
changedField
.
parentNode
.
id
;
const
column
=
this
.
columns
.
get
(
colName
)
;
const
uniqueId
=
column
.
table
.
uniqueId
;
const
itemIndex
=
column
.
cellNodes
.
indexOf
(
changedField
)
;
const
items
=
{
}
;
for
(
const
[
name
col
]
of
this
.
columns
)
{
items
[
name
]
=
col
.
cellNodes
[
itemIndex
]
.
value
;
}
const
change
=
{
host
:
this
.
host
key
:
uniqueId
field
:
colName
oldValue
:
data
.
change
.
oldValue
newValue
:
data
.
change
.
newValue
items
}
;
this
.
editBookmark
=
colName
=
=
=
uniqueId
?
change
.
newValue
:
items
[
uniqueId
]
;
this
.
emit
(
EVENTS
.
CELL_EDIT
change
)
;
}
onEditorDestroyed
(
)
{
this
.
_editableFieldsEngine
=
null
;
}
onEditorTab
(
event
)
{
const
textbox
=
event
.
target
;
const
editor
=
this
.
_editableFieldsEngine
;
if
(
textbox
.
id
!
=
=
editor
.
INPUT_ID
)
{
return
;
}
const
column
=
textbox
.
parentNode
;
if
(
editor
.
changePending
)
{
this
.
once
(
EVENTS
.
ROW_EDIT
uniqueId
=
>
{
let
columnObj
;
const
cols
=
this
.
editableColumns
;
let
rowIndex
=
this
.
visibleSelectedIndex
;
const
colIndex
=
cols
.
indexOf
(
column
)
;
let
newIndex
;
if
(
!
uniqueId
)
{
return
;
}
if
(
event
.
shiftKey
)
{
if
(
colIndex
=
=
=
0
)
{
if
(
rowIndex
=
=
=
0
)
{
return
;
}
newIndex
=
cols
.
length
-
1
;
}
else
{
newIndex
=
colIndex
-
1
;
}
}
else
if
(
colIndex
=
=
=
cols
.
length
-
1
)
{
const
id
=
cols
[
0
]
.
id
;
columnObj
=
this
.
columns
.
get
(
id
)
;
const
maxRowIndex
=
columnObj
.
visibleCellNodes
.
length
-
1
;
if
(
rowIndex
=
=
=
maxRowIndex
)
{
return
;
}
newIndex
=
0
;
}
else
{
newIndex
=
colIndex
+
1
;
}
const
newcol
=
cols
[
newIndex
]
;
columnObj
=
this
.
columns
.
get
(
newcol
.
id
)
;
const
dataId
=
editor
.
currentTarget
.
getAttribute
(
"
data
-
id
"
)
;
if
(
this
.
items
.
get
(
dataId
)
)
{
this
.
emit
(
EVENTS
.
ROW_SELECTED
dataId
)
;
}
else
{
this
.
emit
(
EVENTS
.
ROW_SELECTED
uniqueId
)
;
}
rowIndex
=
this
.
visibleSelectedIndex
;
const
cells
=
columnObj
.
visibleCellNodes
;
const
cell
=
cells
[
rowIndex
]
;
editor
.
edit
(
cell
)
;
cell
.
classList
.
remove
(
"
flash
-
out
"
)
;
}
)
;
}
const
cell
=
this
.
getEditedCellOnTab
(
event
column
)
;
editor
.
edit
(
cell
)
;
event
.
preventDefault
(
)
;
}
getEditedCellOnTab
(
event
column
)
{
let
cell
=
null
;
const
cols
=
this
.
editableColumns
;
const
rowIndex
=
this
.
visibleSelectedIndex
;
const
colIndex
=
cols
.
indexOf
(
column
)
;
const
maxCol
=
cols
.
length
-
1
;
const
maxRow
=
this
.
columns
.
get
(
column
.
id
)
.
visibleCellNodes
.
length
-
1
;
if
(
event
.
shiftKey
)
{
if
(
colIndex
=
=
=
0
)
{
if
(
rowIndex
=
=
=
0
)
{
this
.
_editableFieldsEngine
.
completeEdit
(
)
;
return
null
;
}
column
=
cols
[
cols
.
length
-
1
]
;
const
cells
=
this
.
columns
.
get
(
column
.
id
)
.
visibleCellNodes
;
cell
=
cells
[
rowIndex
-
1
]
;
const
rowId
=
cell
.
getAttribute
(
"
data
-
id
"
)
;
this
.
emit
(
EVENTS
.
ROW_SELECTED
rowId
)
;
}
else
{
column
=
cols
[
colIndex
-
1
]
;
const
cells
=
this
.
columns
.
get
(
column
.
id
)
.
visibleCellNodes
;
cell
=
cells
[
rowIndex
]
;
}
}
else
if
(
colIndex
=
=
=
maxCol
)
{
if
(
rowIndex
=
=
=
maxRow
)
{
this
.
_editableFieldsEngine
.
completeEdit
(
)
;
return
null
;
}
column
=
cols
[
0
]
;
const
cells
=
this
.
columns
.
get
(
column
.
id
)
.
visibleCellNodes
;
cell
=
cells
[
rowIndex
+
1
]
;
const
rowId
=
cell
.
getAttribute
(
"
data
-
id
"
)
;
this
.
emit
(
EVENTS
.
ROW_SELECTED
rowId
)
;
}
else
{
column
=
cols
[
colIndex
+
1
]
;
const
cells
=
this
.
columns
.
get
(
column
.
id
)
.
visibleCellNodes
;
cell
=
cells
[
rowIndex
]
;
}
return
cell
;
}
onRowRemoved
(
row
)
{
if
(
!
this
.
_editableFieldsEngine
|
|
!
this
.
_editableFieldsEngine
.
isEditing
)
{
return
;
}
const
removedKey
=
row
[
this
.
uniqueId
]
;
const
column
=
this
.
columns
.
get
(
this
.
uniqueId
)
;
if
(
removedKey
in
column
.
items
)
{
return
;
}
this
.
onEditorTargetLost
(
)
;
}
onEditorTargetLost
(
)
{
const
editor
=
this
.
_editableFieldsEngine
;
if
(
!
editor
|
|
!
editor
.
isEditing
)
{
return
;
}
editor
.
cancelEdit
(
)
;
}
onKeydown
(
event
)
{
if
(
this
.
_editableFieldsEngine
&
&
this
.
_editableFieldsEngine
.
isEditing
)
{
return
;
}
const
selectedCells
=
[
.
.
.
this
.
tbody
.
querySelectorAll
(
"
.
theme
-
selected
"
)
]
.
filter
(
cell
=
>
cell
.
clientWidth
>
0
)
;
const
selectedCell
=
selectedCells
[
0
]
;
if
(
!
selectedCell
)
{
return
;
}
let
colName
;
let
column
;
let
visibleCells
;
let
index
;
let
cell
;
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_UP
:
event
.
preventDefault
(
)
;
colName
=
selectedCell
.
parentNode
.
id
;
column
=
this
.
columns
.
get
(
colName
)
;
visibleCells
=
column
.
visibleCellNodes
;
index
=
visibleCells
.
indexOf
(
selectedCell
)
;
if
(
index
>
0
)
{
index
-
-
;
}
else
{
index
=
visibleCells
.
length
-
1
;
}
cell
=
visibleCells
[
index
]
;
this
.
emit
(
EVENTS
.
ROW_SELECTED
cell
.
getAttribute
(
"
data
-
id
"
)
)
;
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
event
.
preventDefault
(
)
;
colName
=
selectedCell
.
parentNode
.
id
;
column
=
this
.
columns
.
get
(
colName
)
;
visibleCells
=
column
.
visibleCellNodes
;
index
=
visibleCells
.
indexOf
(
selectedCell
)
;
if
(
index
=
=
=
visibleCells
.
length
-
1
)
{
index
=
0
;
}
else
{
index
+
+
;
}
cell
=
visibleCells
[
index
]
;
this
.
emit
(
EVENTS
.
ROW_SELECTED
cell
.
getAttribute
(
"
data
-
id
"
)
)
;
break
;
}
}
onMousedown
(
{
target
}
)
{
const
localName
=
target
.
localName
;
if
(
localName
=
=
=
"
input
"
|
|
!
this
.
_editableFieldsEngine
)
{
return
;
}
this
.
_editableFieldsEngine
.
blur
(
)
;
}
makeFieldsEditable
(
editableColumns
)
{
const
selectors
=
[
]
;
if
(
typeof
editableColumns
=
=
=
"
string
"
)
{
editableColumns
=
[
editableColumns
]
;
}
for
(
const
id
of
editableColumns
)
{
selectors
.
push
(
"
#
"
+
id
+
"
.
table
-
widget
-
cell
"
)
;
}
for
(
const
[
name
column
]
of
this
.
columns
)
{
if
(
!
editableColumns
.
includes
(
name
)
)
{
column
.
column
.
setAttribute
(
"
readonly
"
"
"
)
;
}
}
if
(
this
.
_editableFieldsEngine
)
{
this
.
_editableFieldsEngine
.
selectors
=
selectors
;
this
.
_editableFieldsEngine
.
items
=
this
.
items
;
}
else
{
this
.
_editableFieldsEngine
=
new
EditableFieldsEngine
(
{
root
:
this
.
tbody
onTab
:
this
.
onEditorTab
onTriggerEvent
:
"
dblclick
"
selectors
items
:
this
.
items
}
)
;
this
.
_editableFieldsEngine
.
on
(
"
change
"
this
.
onChange
)
;
this
.
_editableFieldsEngine
.
on
(
"
destroyed
"
this
.
onEditorDestroyed
)
;
this
.
on
(
EVENTS
.
ROW_REMOVED
this
.
onRowRemoved
)
;
this
.
on
(
EVENTS
.
TABLE_CLEARED
this
.
_editableFieldsEngine
.
cancelEdit
)
;
this
.
emit
(
EVENTS
.
FIELDS_EDITABLE
this
.
_editableFieldsEngine
)
;
}
}
destroy
(
)
{
this
.
off
(
EVENTS
.
ROW_SELECTED
this
.
bindSelectedRow
)
;
this
.
off
(
EVENTS
.
ROW_REMOVED
this
.
onRowRemoved
)
;
this
.
document
.
removeEventListener
(
"
keydown
"
this
.
onKeydown
)
;
this
.
document
.
removeEventListener
(
"
mousedown
"
this
.
onMousedown
)
;
if
(
this
.
_editableFieldsEngine
)
{
this
.
off
(
EVENTS
.
TABLE_CLEARED
this
.
_editableFieldsEngine
.
cancelEdit
)
;
this
.
_editableFieldsEngine
.
off
(
"
change
"
this
.
onChange
)
;
this
.
_editableFieldsEngine
.
off
(
"
destroyed
"
this
.
onEditorDestroyed
)
;
this
.
_editableFieldsEngine
.
destroy
(
)
;
this
.
_editableFieldsEngine
=
null
;
}
if
(
this
.
menupopup
)
{
this
.
menupopup
.
removeEventListener
(
"
command
"
this
.
onPopupCommand
)
;
this
.
menupopup
.
remove
(
)
;
}
}
setPlaceholder
(
l10nID
learnMoreURL
)
{
if
(
learnMoreURL
)
{
let
placeholderLink
=
this
.
placeholder
.
firstElementChild
;
if
(
!
placeholderLink
)
{
placeholderLink
=
this
.
document
.
createElement
(
"
a
"
)
;
placeholderLink
.
setAttribute
(
"
target
"
"
_blank
"
)
;
placeholderLink
.
setAttribute
(
"
data
-
l10n
-
name
"
"
learn
-
more
-
link
"
)
;
this
.
placeholder
.
appendChild
(
placeholderLink
)
;
}
placeholderLink
.
setAttribute
(
"
href
"
learnMoreURL
)
;
}
else
{
this
.
placeholder
.
firstElementChild
?
.
remove
(
)
;
}
this
.
l10n
.
setAttributes
(
this
.
placeholder
l10nID
)
;
}
setupHeadersContextMenu
(
)
{
let
popupset
=
this
.
document
.
getElementsByTagName
(
"
popupset
"
)
[
0
]
;
if
(
!
popupset
)
{
popupset
=
this
.
document
.
createXULElement
(
"
popupset
"
)
;
this
.
document
.
documentElement
.
appendChild
(
popupset
)
;
}
this
.
menupopup
=
this
.
document
.
createXULElement
(
"
menupopup
"
)
;
this
.
menupopup
.
id
=
"
table
-
widget
-
column
-
select
"
;
this
.
menupopup
.
addEventListener
(
"
command
"
this
.
onPopupCommand
)
;
popupset
.
appendChild
(
this
.
menupopup
)
;
this
.
populateMenuPopup
(
)
;
}
populateMenuPopup
(
privateColumns
=
[
]
)
{
if
(
!
this
.
menupopup
)
{
return
;
}
while
(
this
.
menupopup
.
firstChild
)
{
this
.
menupopup
.
firstChild
.
remove
(
)
;
}
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
if
(
privateColumns
.
includes
(
column
.
id
)
)
{
continue
;
}
const
menuitem
=
this
.
document
.
createXULElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
column
.
header
.
getAttribute
(
"
value
"
)
)
;
menuitem
.
setAttribute
(
"
data
-
id
"
column
.
id
)
;
menuitem
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
menuitem
.
setAttribute
(
"
checked
"
!
column
.
wrapper
.
hidden
)
;
if
(
column
.
id
=
=
this
.
uniqueId
)
{
menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
this
.
menupopup
.
appendChild
(
menuitem
)
;
}
const
checked
=
this
.
menupopup
.
querySelectorAll
(
"
menuitem
[
checked
]
"
)
;
if
(
checked
.
length
=
=
2
)
{
checked
[
checked
.
length
-
1
]
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
}
onPopupCommand
(
event
)
{
const
item
=
event
.
originalTarget
;
let
checked
=
!
!
item
.
getAttribute
(
"
checked
"
)
;
const
id
=
item
.
getAttribute
(
"
data
-
id
"
)
;
this
.
emit
(
EVENTS
.
HEADER_CONTEXT_MENU
id
checked
)
;
checked
=
this
.
menupopup
.
querySelectorAll
(
"
menuitem
[
checked
]
"
)
;
const
disabled
=
this
.
menupopup
.
querySelectorAll
(
"
menuitem
[
disabled
]
"
)
;
if
(
checked
.
length
=
=
2
)
{
checked
[
checked
.
length
-
1
]
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
else
if
(
disabled
.
length
>
1
)
{
disabled
[
disabled
.
length
-
1
]
.
removeAttribute
(
"
disabled
"
)
;
}
}
setColumns
(
columns
sortOn
=
this
.
sortedOn
hiddenColumns
=
[
]
privateColumns
=
[
]
)
{
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
column
.
destroy
(
)
;
}
this
.
columns
.
clear
(
)
;
if
(
!
(
sortOn
in
columns
)
)
{
sortOn
=
null
;
}
if
(
!
(
this
.
firstColumn
in
columns
)
)
{
this
.
firstColumn
=
null
;
}
if
(
this
.
firstColumn
)
{
this
.
columns
.
set
(
this
.
firstColumn
new
Column
(
this
this
.
firstColumn
columns
[
this
.
firstColumn
]
)
)
;
}
for
(
const
id
in
columns
)
{
if
(
!
sortOn
)
{
sortOn
=
id
;
}
if
(
this
.
firstColumn
&
&
id
=
=
this
.
firstColumn
)
{
continue
;
}
this
.
columns
.
set
(
id
new
Column
(
this
id
columns
[
id
]
)
)
;
if
(
hiddenColumns
.
includes
(
id
)
|
|
privateColumns
.
includes
(
id
)
)
{
this
.
columns
.
get
(
id
)
.
toggleColumn
(
)
;
if
(
privateColumns
.
includes
(
id
)
)
{
this
.
columns
.
get
(
id
)
.
private
=
true
;
}
}
}
this
.
sortedOn
=
sortOn
;
this
.
sortBy
(
this
.
sortedOn
)
;
this
.
populateMenuPopup
(
privateColumns
)
;
}
isSelected
(
item
)
{
if
(
typeof
item
=
=
"
object
"
)
{
item
=
item
[
this
.
uniqueId
]
;
}
return
this
.
selectedRow
&
&
item
=
=
this
.
selectedRow
[
this
.
uniqueId
]
;
}
selectRow
(
id
)
{
this
.
selectedRow
=
id
;
}
selectNextRow
(
)
{
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
column
.
selectNextRow
(
)
;
}
}
selectPreviousRow
(
)
{
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
column
.
selectPreviousRow
(
)
;
}
}
clearSelection
(
)
{
this
.
selectedIndex
=
-
1
;
}
push
(
item
suppressFlash
)
{
if
(
!
this
.
sortedOn
|
|
!
this
.
columns
)
{
console
.
error
(
"
Can
'
t
insert
item
without
defining
columns
first
"
)
;
return
;
}
if
(
this
.
items
.
has
(
item
[
this
.
uniqueId
]
)
)
{
this
.
update
(
item
)
;
return
;
}
if
(
this
.
editBookmark
&
&
!
this
.
items
.
has
(
this
.
editBookmark
)
)
{
this
.
editBookmark
=
item
[
this
.
uniqueId
]
;
}
const
index
=
this
.
columns
.
get
(
this
.
sortedOn
)
.
push
(
item
)
;
for
(
const
[
key
column
]
of
this
.
columns
)
{
if
(
key
!
=
this
.
sortedOn
)
{
column
.
insertAt
(
item
index
)
;
}
column
.
updateZebra
(
)
;
}
this
.
items
.
set
(
item
[
this
.
uniqueId
]
item
)
;
this
.
tbody
.
removeAttribute
(
"
empty
"
)
;
if
(
!
suppressFlash
)
{
this
.
emit
(
EVENTS
.
ROW_UPDATED
item
[
this
.
uniqueId
]
)
;
}
this
.
emit
(
EVENTS
.
ROW_EDIT
item
[
this
.
uniqueId
]
)
;
}
remove
(
item
)
{
if
(
typeof
item
!
=
"
object
"
)
{
item
=
this
.
items
.
get
(
item
)
;
}
if
(
!
item
)
{
return
;
}
const
removed
=
this
.
items
.
delete
(
item
[
this
.
uniqueId
]
)
;
if
(
!
removed
)
{
return
;
}
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
column
.
remove
(
item
)
;
column
.
updateZebra
(
)
;
}
if
(
this
.
items
.
size
=
=
=
0
)
{
this
.
selectedRow
=
null
;
this
.
tbody
.
setAttribute
(
"
empty
"
"
empty
"
)
;
}
this
.
emit
(
EVENTS
.
ROW_REMOVED
item
)
;
}
update
(
item
)
{
const
oldItem
=
this
.
items
.
get
(
item
[
this
.
uniqueId
]
)
;
if
(
!
oldItem
)
{
return
;
}
this
.
items
.
set
(
item
[
this
.
uniqueId
]
item
)
;
let
changed
=
false
;
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
if
(
item
[
column
.
id
]
!
=
oldItem
[
column
.
id
]
)
{
column
.
update
(
item
)
;
changed
=
true
;
}
}
if
(
changed
)
{
this
.
emit
(
EVENTS
.
ROW_UPDATED
item
[
this
.
uniqueId
]
)
;
this
.
emit
(
EVENTS
.
ROW_EDIT
item
[
this
.
uniqueId
]
)
;
}
}
clear
(
)
{
this
.
items
.
clear
(
)
;
for
(
const
column
of
this
.
columns
.
values
(
)
)
{
column
.
clear
(
)
;
}
this
.
tbody
.
setAttribute
(
"
empty
"
"
empty
"
)
;
this
.
setPlaceholder
(
this
.
emptyText
)
;
this
.
selectedRow
=
null
;
this
.
emit
(
EVENTS
.
TABLE_CLEARED
this
)
;
}
sortBy
(
column
)
{
this
.
emit
(
EVENTS
.
COLUMN_SORTED
column
)
;
this
.
sortedOn
=
column
;
if
(
!
this
.
items
.
size
)
{
return
;
}
const
sortedItems
=
this
.
columns
.
get
(
column
)
.
sort
(
[
.
.
.
this
.
items
.
values
(
)
]
)
;
for
(
const
[
id
col
]
of
this
.
columns
)
{
if
(
id
=
=
=
col
)
{
col
.
sort
(
sortedItems
)
;
}
}
}
filterItems
(
value
ignoreProps
=
[
]
)
{
if
(
this
.
filteredValue
=
=
value
)
{
return
;
}
if
(
this
.
_editableFieldsEngine
)
{
this
.
_editableFieldsEngine
.
completeEdit
(
)
;
}
this
.
filteredValue
=
value
;
if
(
!
value
)
{
this
.
emit
(
EVENTS
.
TABLE_FILTERED
[
]
)
;
return
;
}
value
=
value
.
toLowerCase
(
)
;
const
itemsToHide
=
[
.
.
.
this
.
items
.
keys
(
)
]
;
for
(
const
[
id
val
]
of
this
.
items
)
{
for
(
const
prop
in
val
)
{
const
column
=
this
.
columns
.
get
(
prop
)
;
if
(
ignoreProps
.
includes
(
prop
)
|
|
column
.
hidden
)
{
continue
;
}
const
propValue
=
val
[
prop
]
.
toString
(
)
.
toLowerCase
(
)
;
if
(
propValue
.
includes
(
value
)
)
{
itemsToHide
.
splice
(
itemsToHide
.
indexOf
(
id
)
1
)
;
break
;
}
}
}
this
.
emit
(
EVENTS
.
TABLE_FILTERED
itemsToHide
)
;
}
onScroll
(
)
{
clearNamedTimeout
(
"
table
-
scroll
"
)
;
setNamedTimeout
(
"
table
-
scroll
"
AFTER_SCROLL_DELAY
this
.
afterScroll
)
;
}
afterScroll
(
)
{
const
maxScrollTop
=
this
.
tbody
.
scrollHeight
-
this
.
tbody
.
clientHeight
;
if
(
this
.
tbody
.
scrollTop
>
=
0
.
9
*
maxScrollTop
)
{
this
.
emit
(
"
scroll
-
end
"
)
;
}
}
}
;
TableWidget
.
EVENTS
=
EVENTS
;
module
.
exports
.
TableWidget
=
TableWidget
;
function
Column
(
table
id
header
)
{
this
.
_private
=
false
;
this
.
tbody
=
table
.
tbody
;
this
.
document
=
table
.
document
;
this
.
window
=
table
.
window
;
this
.
id
=
id
;
this
.
uniqueId
=
table
.
uniqueId
;
this
.
wrapTextInElements
=
table
.
wrapTextInElements
;
this
.
table
=
table
;
this
.
cells
=
[
]
;
this
.
items
=
{
}
;
this
.
highlightUpdated
=
table
.
highlightUpdated
;
this
.
wrapper
=
this
.
document
.
createXULElement
(
"
vbox
"
)
;
this
.
wrapper
.
className
=
"
table
-
widget
-
wrapper
"
;
this
.
wrapper
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
wrapper
.
setAttribute
(
"
tabindex
"
"
0
"
)
;
this
.
tbody
.
appendChild
(
this
.
wrapper
)
;
this
.
splitter
=
this
.
document
.
createXULElement
(
"
splitter
"
)
;
this
.
splitter
.
className
=
"
devtools
-
side
-
splitter
"
;
this
.
tbody
.
appendChild
(
this
.
splitter
)
;
this
.
column
=
this
.
document
.
createElementNS
(
HTML_NS
"
div
"
)
;
this
.
column
.
id
=
id
;
this
.
column
.
className
=
"
table
-
widget
-
column
"
;
this
.
wrapper
.
appendChild
(
this
.
column
)
;
this
.
header
=
this
.
document
.
createXULElement
(
"
label
"
)
;
this
.
header
.
className
=
"
devtools
-
toolbar
table
-
widget
-
column
-
header
"
;
this
.
header
.
setAttribute
(
"
value
"
header
)
;
this
.
column
.
appendChild
(
this
.
header
)
;
if
(
table
.
headersContextMenu
)
{
this
.
header
.
setAttribute
(
"
context
"
table
.
headersContextMenu
)
;
}
this
.
toggleColumn
=
this
.
toggleColumn
.
bind
(
this
)
;
this
.
table
.
on
(
EVENTS
.
HEADER_CONTEXT_MENU
this
.
toggleColumn
)
;
this
.
onColumnSorted
=
this
.
onColumnSorted
.
bind
(
this
)
;
this
.
table
.
on
(
EVENTS
.
COLUMN_SORTED
this
.
onColumnSorted
)
;
this
.
onRowUpdated
=
this
.
onRowUpdated
.
bind
(
this
)
;
this
.
table
.
on
(
EVENTS
.
ROW_UPDATED
this
.
onRowUpdated
)
;
this
.
onTableFiltered
=
this
.
onTableFiltered
.
bind
(
this
)
;
this
.
table
.
on
(
EVENTS
.
TABLE_FILTERED
this
.
onTableFiltered
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onMousedown
=
this
.
onMousedown
.
bind
(
this
)
;
this
.
column
.
addEventListener
(
"
click
"
this
.
onClick
)
;
this
.
column
.
addEventListener
(
"
mousedown
"
this
.
onMousedown
)
;
}
Column
.
prototype
=
{
items
:
null
_itemsDirty
:
null
selectedRow
:
null
cells
:
null
get
sorted
(
)
{
return
this
.
_sortState
|
|
0
;
}
get
hidden
(
)
{
return
this
.
wrapper
.
hidden
;
}
get
private
(
)
{
return
this
.
_private
;
}
set
private
(
state
)
{
this
.
_private
=
state
;
}
set
sorted
(
value
)
{
if
(
!
value
)
{
this
.
header
.
removeAttribute
(
"
sorted
"
)
;
}
else
{
this
.
header
.
setAttribute
(
"
sorted
"
value
=
=
1
?
"
ascending
"
:
"
descending
"
)
;
}
this
.
_sortState
=
value
;
}
get
selectedIndex
(
)
{
if
(
!
this
.
selectedRow
)
{
return
-
1
;
}
return
this
.
items
[
this
.
selectedRow
]
;
}
get
cellNodes
(
)
{
return
[
.
.
.
this
.
column
.
querySelectorAll
(
"
.
table
-
widget
-
cell
"
)
]
;
}
get
visibleCellNodes
(
)
{
const
editor
=
this
.
table
.
_editableFieldsEngine
;
const
nodes
=
this
.
cellNodes
.
filter
(
node
=
>
{
if
(
editor
&
&
editor
.
currentTarget
=
=
=
node
)
{
return
true
;
}
return
node
.
clientWidth
!
=
=
0
;
}
)
;
return
nodes
;
}
onColumnSorted
(
column
)
{
if
(
column
!
=
this
.
id
)
{
this
.
sorted
=
0
;
return
;
}
else
if
(
this
.
sorted
=
=
0
|
|
this
.
sorted
=
=
2
)
{
this
.
sorted
=
1
;
}
else
{
this
.
sorted
=
2
;
}
this
.
updateZebra
(
)
;
}
onTableFiltered
(
itemsToHide
)
{
this
.
_updateItems
(
)
;
if
(
!
this
.
cells
)
{
return
;
}
for
(
const
cell
of
this
.
cells
)
{
cell
.
hidden
=
false
;
}
for
(
const
id
of
itemsToHide
)
{
this
.
cells
[
this
.
items
[
id
]
]
.
hidden
=
true
;
}
this
.
updateZebra
(
)
;
}
onRowUpdated
(
id
)
{
this
.
_updateItems
(
)
;
if
(
this
.
highlightUpdated
&
&
this
.
items
[
id
]
!
=
null
)
{
if
(
this
.
table
.
scrollIntoViewOnUpdate
)
{
const
cell
=
this
.
cells
[
this
.
items
[
id
]
]
;
if
(
cell
.
label
.
clientHeight
>
0
)
{
cell
.
scrollIntoView
(
)
;
this
.
table
.
scrollIntoViewOnUpdate
=
null
;
}
}
if
(
this
.
table
.
editBookmark
)
{
this
.
table
.
emit
(
EVENTS
.
ROW_SELECTED
this
.
table
.
editBookmark
)
;
this
.
table
.
editBookmark
=
null
;
}
this
.
cells
[
this
.
items
[
id
]
]
.
flash
(
)
;
}
this
.
updateZebra
(
)
;
}
destroy
(
)
{
this
.
table
.
off
(
EVENTS
.
COLUMN_SORTED
this
.
onColumnSorted
)
;
this
.
table
.
off
(
EVENTS
.
HEADER_CONTEXT_MENU
this
.
toggleColumn
)
;
this
.
table
.
off
(
EVENTS
.
ROW_UPDATED
this
.
onRowUpdated
)
;
this
.
table
.
off
(
EVENTS
.
TABLE_FILTERED
this
.
onTableFiltered
)
;
this
.
column
.
removeEventListener
(
"
click
"
this
.
onClick
)
;
this
.
column
.
removeEventListener
(
"
mousedown
"
this
.
onMousedown
)
;
this
.
splitter
.
remove
(
)
;
this
.
column
.
parentNode
.
remove
(
)
;
this
.
cells
=
null
;
this
.
items
=
null
;
this
.
selectedRow
=
null
;
}
selectRowAt
(
index
)
{
if
(
this
.
selectedRow
!
=
null
)
{
this
.
cells
[
this
.
items
[
this
.
selectedRow
]
]
.
classList
.
remove
(
"
theme
-
selected
"
)
;
}
const
cell
=
this
.
cells
[
index
]
;
if
(
cell
)
{
cell
.
classList
.
add
(
"
theme
-
selected
"
)
;
this
.
selectedRow
=
cell
.
id
;
}
else
{
this
.
selectedRow
=
null
;
}
}
selectRow
(
id
)
{
this
.
_updateItems
(
)
;
this
.
selectRowAt
(
this
.
items
[
id
]
)
;
}
selectNextRow
(
)
{
this
.
_updateItems
(
)
;
let
index
=
this
.
items
[
this
.
selectedRow
]
+
1
;
if
(
index
=
=
this
.
cells
.
length
)
{
index
=
0
;
}
this
.
selectRowAt
(
index
)
;
}
selectPreviousRow
(
)
{
this
.
_updateItems
(
)
;
let
index
=
this
.
items
[
this
.
selectedRow
]
-
1
;
if
(
index
=
=
-
1
)
{
index
=
this
.
cells
.
length
-
1
;
}
this
.
selectRowAt
(
index
)
;
}
push
(
item
)
{
const
value
=
item
[
this
.
id
]
;
if
(
this
.
sorted
)
{
let
index
;
if
(
this
.
sorted
=
=
1
)
{
index
=
this
.
cells
.
findIndex
(
element
=
>
{
return
naturalSortCaseInsensitive
(
value
element
.
value
)
=
=
=
-
1
;
}
)
;
}
else
{
index
=
this
.
cells
.
findIndex
(
element
=
>
{
return
naturalSortCaseInsensitive
(
value
element
.
value
)
=
=
=
1
;
}
)
;
}
index
=
index
>
=
0
?
index
:
this
.
cells
.
length
;
if
(
index
<
this
.
cells
.
length
)
{
this
.
_itemsDirty
=
true
;
}
this
.
items
[
item
[
this
.
uniqueId
]
]
=
index
;
this
.
cells
.
splice
(
index
0
new
Cell
(
this
item
this
.
cells
[
index
]
)
)
;
return
index
;
}
this
.
items
[
item
[
this
.
uniqueId
]
]
=
this
.
cells
.
length
;
return
this
.
cells
.
push
(
new
Cell
(
this
item
)
)
-
1
;
}
insertAt
(
item
index
)
{
if
(
index
<
this
.
cells
.
length
)
{
this
.
_itemsDirty
=
true
;
}
this
.
items
[
item
[
this
.
uniqueId
]
]
=
index
;
this
.
cells
.
splice
(
index
0
new
Cell
(
this
item
this
.
cells
[
index
]
)
)
;
this
.
updateZebra
(
)
;
}
toggleColumn
(
id
checked
)
{
if
(
arguments
.
length
=
=
0
)
{
id
=
this
.
id
;
checked
=
this
.
wrapper
.
hidden
;
}
if
(
id
!
=
this
.
id
)
{
return
;
}
if
(
checked
)
{
this
.
wrapper
.
hidden
=
false
;
this
.
tbody
.
insertBefore
(
this
.
splitter
this
.
wrapper
.
nextSibling
)
;
}
else
{
this
.
wrapper
.
hidden
=
true
;
this
.
splitter
.
remove
(
)
;
}
}
remove
(
item
)
{
this
.
_updateItems
(
)
;
const
index
=
this
.
items
[
item
[
this
.
uniqueId
]
]
;
if
(
index
=
=
null
)
{
return
;
}
if
(
index
<
this
.
cells
.
length
)
{
this
.
_itemsDirty
=
true
;
}
this
.
cells
[
index
]
.
destroy
(
)
;
this
.
cells
.
splice
(
index
1
)
;
delete
this
.
items
[
item
[
this
.
uniqueId
]
]
;
}
update
(
item
)
{
this
.
_updateItems
(
)
;
const
index
=
this
.
items
[
item
[
this
.
uniqueId
]
]
;
if
(
index
=
=
null
)
{
return
;
}
this
.
cells
[
index
]
.
value
=
item
[
this
.
id
]
;
}
_updateItems
(
)
{
if
(
!
this
.
_itemsDirty
)
{
return
;
}
for
(
let
i
=
0
;
i
<
this
.
cells
.
length
;
i
+
+
)
{
this
.
items
[
this
.
cells
[
i
]
.
id
]
=
i
;
}
this
.
_itemsDirty
=
false
;
}
clear
(
)
{
this
.
cells
=
[
]
;
this
.
items
=
{
}
;
this
.
_itemsDirty
=
false
;
while
(
this
.
header
.
nextSibling
)
{
this
.
header
.
nextSibling
.
remove
(
)
;
}
}
sort
(
items
)
{
if
(
this
.
sorted
=
=
1
)
{
items
.
sort
(
(
a
b
)
=
>
{
const
val1
=
Node
.
isInstance
(
a
[
this
.
id
]
)
?
a
[
this
.
id
]
.
textContent
:
a
[
this
.
id
]
;
const
val2
=
Node
.
isInstance
(
b
[
this
.
id
]
)
?
b
[
this
.
id
]
.
textContent
:
b
[
this
.
id
]
;
return
naturalSortCaseInsensitive
(
val1
val2
)
;
}
)
;
}
else
if
(
this
.
sorted
>
1
)
{
items
.
sort
(
(
a
b
)
=
>
{
const
val1
=
Node
.
isInstance
(
a
[
this
.
id
]
)
?
a
[
this
.
id
]
.
textContent
:
a
[
this
.
id
]
;
const
val2
=
Node
.
isInstance
(
b
[
this
.
id
]
)
?
b
[
this
.
id
]
.
textContent
:
b
[
this
.
id
]
;
return
naturalSortCaseInsensitive
(
val2
val1
)
;
}
)
;
}
if
(
this
.
selectedRow
)
{
this
.
cells
[
this
.
items
[
this
.
selectedRow
]
]
.
classList
.
remove
(
"
theme
-
selected
"
)
;
}
this
.
items
=
{
}
;
for
(
const
[
i
item
]
of
items
.
entries
(
)
)
{
if
(
!
this
.
cells
[
i
]
)
{
continue
;
}
this
.
items
[
item
[
this
.
uniqueId
]
]
=
i
;
this
.
cells
[
i
]
.
value
=
item
[
this
.
id
]
;
this
.
cells
[
i
]
.
id
=
item
[
this
.
uniqueId
]
;
}
if
(
this
.
selectedRow
)
{
this
.
cells
[
this
.
items
[
this
.
selectedRow
]
]
.
classList
.
add
(
"
theme
-
selected
"
)
;
}
this
.
_itemsDirty
=
false
;
this
.
updateZebra
(
)
;
return
items
;
}
updateZebra
(
)
{
this
.
_updateItems
(
)
;
let
i
=
0
;
for
(
const
cell
of
this
.
cells
)
{
if
(
!
cell
.
hidden
)
{
i
+
+
;
}
const
even
=
!
(
i
%
2
)
;
cell
.
classList
.
toggle
(
"
even
"
even
)
;
}
}
onClick
(
event
)
{
const
target
=
event
.
originalTarget
;
if
(
target
.
nodeType
!
=
=
target
.
ELEMENT_NODE
|
|
target
=
=
this
.
column
)
{
return
;
}
if
(
event
.
button
=
=
0
&
&
target
=
=
this
.
header
)
{
this
.
table
.
sortBy
(
this
.
id
)
;
}
}
onMousedown
(
event
)
{
const
target
=
event
.
originalTarget
;
if
(
target
.
nodeType
!
=
=
target
.
ELEMENT_NODE
|
|
target
=
=
this
.
column
|
|
target
=
=
this
.
header
)
{
return
;
}
if
(
event
.
button
=
=
0
)
{
const
closest
=
target
.
closest
(
"
[
data
-
id
]
"
)
;
if
(
!
closest
)
{
return
;
}
const
dataid
=
closest
.
getAttribute
(
"
data
-
id
"
)
;
this
.
table
.
emit
(
EVENTS
.
ROW_SELECTED
dataid
)
;
}
}
}
;
function
Cell
(
column
item
nextCell
)
{
const
document
=
column
.
document
;
this
.
wrapTextInElements
=
column
.
wrapTextInElements
;
this
.
label
=
document
.
createXULElement
(
"
label
"
)
;
this
.
label
.
setAttribute
(
"
crop
"
"
end
"
)
;
this
.
label
.
className
=
"
plain
table
-
widget
-
cell
"
;
if
(
nextCell
)
{
column
.
column
.
insertBefore
(
this
.
label
nextCell
.
label
)
;
}
else
{
column
.
column
.
appendChild
(
this
.
label
)
;
}
if
(
column
.
table
.
cellContextMenuId
)
{
this
.
label
.
setAttribute
(
"
context
"
column
.
table
.
cellContextMenuId
)
;
this
.
label
.
addEventListener
(
"
contextmenu
"
event
=
>
{
column
.
table
.
contextMenuRowId
=
this
.
id
;
}
)
;
}
this
.
value
=
item
[
column
.
id
]
;
this
.
id
=
item
[
column
.
uniqueId
]
;
}
Cell
.
prototype
=
{
set
id
(
value
)
{
this
.
_id
=
value
;
this
.
label
.
setAttribute
(
"
data
-
id
"
value
)
;
}
get
id
(
)
{
return
this
.
_id
;
}
get
hidden
(
)
{
return
this
.
label
.
hidden
;
}
set
hidden
(
value
)
{
this
.
label
.
hidden
=
value
;
}
set
value
(
value
)
{
this
.
_value
=
value
;
if
(
value
=
=
null
)
{
this
.
label
.
setAttribute
(
"
value
"
"
"
)
;
return
;
}
if
(
this
.
wrapTextInElements
&
&
!
Node
.
isInstance
(
value
)
)
{
const
span
=
this
.
label
.
ownerDocument
.
createElementNS
(
HTML_NS
"
span
"
)
;
span
.
textContent
=
value
;
value
=
span
;
}
if
(
Node
.
isInstance
(
value
)
)
{
this
.
label
.
removeAttribute
(
"
value
"
)
;
while
(
this
.
label
.
firstChild
)
{
this
.
label
.
firstChild
.
remove
(
)
;
}
this
.
label
.
appendChild
(
value
)
;
}
else
{
this
.
label
.
setAttribute
(
"
value
"
value
+
"
"
)
;
}
}
get
value
(
)
{
return
this
.
_value
;
}
get
classList
(
)
{
return
this
.
label
.
classList
;
}
flash
(
)
{
if
(
!
this
.
label
.
parentNode
)
{
return
;
}
this
.
label
.
classList
.
remove
(
"
flash
-
out
"
)
;
let
a
=
this
.
label
.
parentNode
.
offsetWidth
;
const
onAnimEnd
=
(
)
=
>
{
this
.
label
.
classList
.
remove
(
"
flash
-
out
"
)
;
this
.
label
.
removeEventListener
(
"
animationend
"
onAnimEnd
)
;
}
;
this
.
label
.
addEventListener
(
"
animationend
"
onAnimEnd
)
;
this
.
label
.
classList
.
add
(
"
flash
-
out
"
)
;
}
focus
(
)
{
this
.
label
.
focus
(
)
;
}
scrollIntoView
(
)
{
this
.
label
.
scrollIntoView
(
false
)
;
}
destroy
(
)
{
this
.
label
.
remove
(
)
;
this
.
label
=
null
;
}
}
;
function
EditableFieldsEngine
(
options
)
{
EventEmitter
.
decorate
(
this
)
;
if
(
!
Array
.
isArray
(
options
.
selectors
)
)
{
options
.
selectors
=
[
options
.
selectors
]
;
}
this
.
root
=
options
.
root
;
this
.
selectors
=
options
.
selectors
;
this
.
onTab
=
options
.
onTab
;
this
.
onTriggerEvent
=
options
.
onTriggerEvent
|
|
"
dblclick
"
;
this
.
items
=
options
.
items
;
this
.
edit
=
this
.
edit
.
bind
(
this
)
;
this
.
cancelEdit
=
this
.
cancelEdit
.
bind
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
onTrigger
=
this
.
onTrigger
.
bind
(
this
)
;
this
.
root
.
addEventListener
(
this
.
onTriggerEvent
this
.
onTrigger
)
;
}
EditableFieldsEngine
.
prototype
=
{
INPUT_ID
:
"
inlineEditor
"
get
changePending
(
)
{
return
this
.
isEditing
&
&
this
.
textbox
.
value
!
=
=
this
.
currentValue
;
}
get
isEditing
(
)
{
return
this
.
root
&
&
!
this
.
textbox
.
hidden
;
}
get
textbox
(
)
{
if
(
!
this
.
_textbox
)
{
const
doc
=
this
.
root
.
ownerDocument
;
this
.
_textbox
=
doc
.
createElementNS
(
HTML_NS
"
input
"
)
;
this
.
_textbox
.
id
=
this
.
INPUT_ID
;
this
.
onKeydown
=
this
.
onKeydown
.
bind
(
this
)
;
this
.
_textbox
.
addEventListener
(
"
keydown
"
this
.
onKeydown
)
;
this
.
completeEdit
=
this
.
completeEdit
.
bind
(
this
)
;
doc
.
addEventListener
(
"
blur
"
this
.
completeEdit
)
;
}
return
this
.
_textbox
;
}
onTrigger
(
{
target
}
)
{
this
.
edit
(
target
)
;
}
onKeydown
(
event
)
{
if
(
!
this
.
textbox
)
{
return
;
}
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_ESCAPE
:
this
.
cancelEdit
(
)
;
event
.
preventDefault
(
)
;
break
;
case
KeyCodes
.
DOM_VK_RETURN
:
this
.
completeEdit
(
)
;
break
;
case
KeyCodes
.
DOM_VK_TAB
:
if
(
this
.
onTab
)
{
this
.
onTab
(
event
)
;
}
break
;
}
}
edit
(
target
)
{
if
(
!
target
)
{
return
;
}
const
name
=
target
.
getAttribute
(
"
data
-
id
"
)
;
const
item
=
this
.
items
.
get
(
name
)
;
if
(
"
isValueEditable
"
in
item
&
&
!
item
.
isValueEditable
)
{
return
;
}
target
.
scrollIntoView
(
false
)
;
target
.
focus
(
)
;
if
(
!
target
.
matches
(
this
.
selectors
.
join
(
"
"
)
)
)
{
return
;
}
if
(
this
.
isEditing
)
{
this
.
completeEdit
(
)
;
}
this
.
copyStyles
(
target
this
.
textbox
)
;
target
.
parentNode
.
insertBefore
(
this
.
textbox
target
)
;
this
.
currentTarget
=
target
;
this
.
textbox
.
value
=
this
.
currentValue
=
target
.
value
;
target
.
hidden
=
true
;
this
.
textbox
.
hidden
=
false
;
this
.
textbox
.
focus
(
)
;
this
.
textbox
.
select
(
)
;
}
completeEdit
(
)
{
if
(
!
this
.
isEditing
)
{
return
;
}
const
oldValue
=
this
.
currentValue
;
const
newValue
=
this
.
textbox
.
value
;
const
changed
=
oldValue
!
=
=
newValue
;
this
.
textbox
.
hidden
=
true
;
if
(
!
this
.
currentTarget
)
{
return
;
}
this
.
currentTarget
.
hidden
=
false
;
if
(
changed
)
{
this
.
currentTarget
.
value
=
newValue
;
const
data
=
{
change
:
{
field
:
this
.
currentTarget
oldValue
newValue
}
}
;
this
.
emit
(
"
change
"
data
)
;
}
}
cancelEdit
(
)
{
if
(
!
this
.
isEditing
)
{
return
;
}
if
(
this
.
currentTarget
)
{
this
.
currentTarget
.
hidden
=
false
;
}
this
.
textbox
.
hidden
=
true
;
}
blur
(
)
{
if
(
this
.
isEditing
)
{
this
.
completeEdit
(
)
;
}
}
copyStyles
(
source
destination
)
{
const
style
=
source
.
ownerDocument
.
defaultView
.
getComputedStyle
(
source
)
;
const
props
=
[
"
borderTopWidth
"
"
borderRightWidth
"
"
borderBottomWidth
"
"
borderLeftWidth
"
"
fontFamily
"
"
fontSize
"
"
fontWeight
"
"
height
"
"
marginTop
"
"
marginRight
"
"
marginBottom
"
"
marginLeft
"
"
marginInlineStart
"
"
marginInlineEnd
"
]
;
for
(
const
prop
of
props
)
{
destination
.
style
[
prop
]
=
style
[
prop
]
;
}
destination
.
style
.
width
=
"
100
%
"
;
}
destroy
(
)
{
if
(
this
.
textbox
)
{
this
.
textbox
.
removeEventListener
(
"
keydown
"
this
.
onKeydown
)
;
this
.
textbox
.
remove
(
)
;
}
if
(
this
.
root
)
{
this
.
root
.
removeEventListener
(
this
.
onTriggerEvent
this
.
onTrigger
)
;
this
.
root
.
ownerDocument
.
removeEventListener
(
"
blur
"
this
.
completeEdit
)
;
}
this
.
_textbox
=
this
.
root
=
this
.
selectors
=
this
.
onTab
=
null
;
this
.
currentTarget
=
this
.
currentValue
=
null
;
this
.
emit
(
"
destroyed
"
)
;
}
}
;
