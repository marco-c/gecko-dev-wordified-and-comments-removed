"
use
strict
"
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
debounce
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
debounce
.
js
"
)
;
class
ShapesInContextEditor
{
constructor
(
highlighter
inspector
state
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
inspector
=
inspector
;
this
.
highlighter
=
highlighter
;
this
.
highlighterTargetNode
=
null
;
this
.
highligherEventHandlers
=
{
}
;
this
.
highligherEventHandlers
[
"
shape
-
change
"
]
=
this
.
onShapeChange
;
this
.
highligherEventHandlers
[
"
shape
-
hover
-
on
"
]
=
this
.
onShapeHover
;
this
.
highligherEventHandlers
[
"
shape
-
hover
-
off
"
]
=
this
.
onShapeHover
;
this
.
mode
=
null
;
this
.
ruleView
=
this
.
inspector
.
getPanel
(
"
ruleview
"
)
.
view
;
this
.
state
=
state
;
this
.
swatch
=
null
;
this
.
commit
=
debounce
(
this
.
commit
200
this
)
;
this
.
onHighlighterEvent
=
this
.
onHighlighterEvent
.
bind
(
this
)
;
this
.
onNodeFrontChanged
=
this
.
onNodeFrontChanged
.
bind
(
this
)
;
this
.
onShapeValueUpdated
=
this
.
onShapeValueUpdated
.
bind
(
this
)
;
this
.
onRuleViewChanged
=
this
.
onRuleViewChanged
.
bind
(
this
)
;
this
.
highlighter
.
on
(
"
highlighter
-
event
"
this
.
onHighlighterEvent
)
;
this
.
ruleView
.
on
(
"
ruleview
-
changed
"
this
.
onRuleViewChanged
)
;
}
get
textProperty
(
)
{
if
(
!
this
.
rule
|
|
!
this
.
rule
.
textProps
)
{
return
null
;
}
const
textProp
=
this
.
rule
.
textProps
[
this
.
textPropIndex
]
;
return
textProp
&
&
textProp
.
name
=
=
=
this
.
textPropName
?
textProp
:
null
;
}
async
onRuleViewChanged
(
)
{
if
(
this
.
textProperty
&
&
(
!
this
.
textProperty
.
enabled
|
|
this
.
textProperty
.
overridden
)
)
{
await
this
.
hide
(
)
;
}
}
async
toggle
(
node
options
prop
)
{
if
(
node
=
=
this
.
highlighterTargetNode
&
&
this
.
mode
=
=
=
options
.
mode
)
{
if
(
!
options
.
transformMode
)
{
await
this
.
hide
(
)
;
return
;
}
options
.
transformMode
=
!
this
.
state
.
shapes
.
options
.
transformMode
;
}
if
(
node
=
=
this
.
highlighterTargetNode
&
&
this
.
mode
!
=
=
options
.
mode
)
{
await
this
.
hide
(
)
;
}
this
.
rule
=
prop
.
rule
;
this
.
textPropIndex
=
this
.
rule
.
textProps
.
indexOf
(
prop
)
;
this
.
textPropName
=
prop
.
name
;
this
.
findSwatch
(
)
;
await
this
.
show
(
node
options
)
;
}
async
show
(
node
options
)
{
const
isShown
=
await
this
.
highlighter
.
show
(
node
options
)
;
if
(
!
isShown
)
{
return
;
}
this
.
inspector
.
selection
.
on
(
"
detached
-
front
"
this
.
onNodeFrontChanged
)
;
this
.
inspector
.
selection
.
on
(
"
new
-
node
-
front
"
this
.
onNodeFrontChanged
)
;
this
.
ruleView
.
on
(
"
property
-
value
-
updated
"
this
.
onShapeValueUpdated
)
;
this
.
highlighterTargetNode
=
node
;
this
.
mode
=
options
.
mode
;
this
.
emit
(
"
show
"
{
node
options
}
)
;
}
async
hide
(
)
{
try
{
await
this
.
highlighter
.
hide
(
)
;
}
catch
(
err
)
{
}
if
(
this
.
destroyed
)
{
return
;
}
if
(
this
.
swatch
)
{
this
.
swatch
.
classList
.
remove
(
"
active
"
)
;
}
this
.
swatch
=
null
;
this
.
rule
=
null
;
this
.
textPropIndex
=
-
1
;
this
.
textPropName
=
null
;
this
.
emit
(
"
hide
"
{
node
:
this
.
highlighterTargetNode
}
)
;
this
.
inspector
.
selection
.
off
(
"
detached
-
front
"
this
.
onNodeFrontChanged
)
;
this
.
inspector
.
selection
.
off
(
"
new
-
node
-
front
"
this
.
onNodeFrontChanged
)
;
this
.
ruleView
.
off
(
"
property
-
value
-
updated
"
this
.
onShapeValueUpdated
)
;
this
.
highlighterTargetNode
=
null
;
}
findSwatch
(
)
{
if
(
!
this
.
textProperty
)
{
return
;
}
const
valueSpan
=
this
.
textProperty
.
editor
.
valueSpan
;
this
.
swatch
=
valueSpan
.
querySelector
(
"
.
ruleview
-
shapeswatch
"
)
;
if
(
this
.
swatch
)
{
this
.
swatch
.
classList
.
add
(
"
active
"
)
;
}
}
onHighlighterEvent
(
data
)
{
const
handler
=
this
.
highligherEventHandlers
[
data
.
type
]
;
if
(
!
handler
|
|
typeof
handler
!
=
=
"
function
"
)
{
return
;
}
handler
.
call
(
this
data
)
;
this
.
inspector
.
highlighters
.
emit
(
"
highlighter
-
event
-
handled
"
)
;
}
async
onNodeFrontChanged
(
)
{
try
{
await
this
.
hide
(
)
;
}
catch
(
err
)
{
}
}
onShapeChange
(
data
)
{
this
.
preview
(
data
.
value
)
;
this
.
commit
(
data
.
value
)
;
}
onShapeHover
(
data
)
{
const
shapeValueEl
=
this
.
swatch
&
&
this
.
swatch
.
nextSibling
;
if
(
!
shapeValueEl
)
{
return
;
}
const
pointSelector
=
"
.
ruleview
-
shape
-
point
"
;
for
(
const
node
of
shapeValueEl
.
querySelectorAll
(
{
pointSelector
}
.
active
)
)
{
node
.
classList
.
remove
(
"
active
"
)
;
}
if
(
typeof
data
.
point
!
=
=
"
string
"
)
{
return
;
}
const
point
=
data
.
point
.
includes
(
"
"
)
?
data
.
point
.
split
(
"
"
)
[
0
]
:
data
.
point
;
const
INSET_POINT_TYPES
=
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
;
const
selector
=
INSET_POINT_TYPES
.
includes
(
point
)
?
{
pointSelector
}
.
{
point
}
:
{
pointSelector
}
[
data
-
point
=
'
{
point
}
'
]
;
for
(
const
node
of
shapeValueEl
.
querySelectorAll
(
selector
)
)
{
node
.
classList
.
add
(
"
active
"
)
;
}
}
async
onShapeValueUpdated
(
)
{
if
(
this
.
textProperty
)
{
this
.
findSwatch
(
)
;
this
.
inspector
.
highlighters
.
emit
(
"
shapes
-
highlighter
-
changes
-
applied
"
)
;
}
else
{
await
this
.
hide
(
)
;
}
}
preview
(
value
)
{
if
(
!
this
.
textProperty
)
{
return
;
}
this
.
textProperty
.
rule
.
previewPropertyValue
(
this
.
textProperty
value
)
;
this
.
swatch
.
nextSibling
.
textContent
=
value
;
}
commit
(
value
)
{
if
(
!
this
.
textProperty
)
{
return
;
}
this
.
textProperty
.
setValue
(
value
)
;
}
destroy
(
)
{
this
.
highlighter
.
off
(
"
highlighter
-
event
"
this
.
onHighlighterEvent
)
;
this
.
ruleView
.
off
(
"
ruleview
-
changed
"
this
.
onRuleViewChanged
)
;
this
.
highligherEventHandlers
=
{
}
;
this
.
destroyed
=
true
;
}
}
module
.
exports
=
ShapesInContextEditor
;
