"
use
strict
"
;
const
{
BrowserLoader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
loader
/
browser
-
loader
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
openDocLink
"
"
resource
:
/
/
devtools
/
client
/
shared
/
link
.
js
"
true
)
;
class
CssCompatibilityTooltipHelper
{
constructor
(
)
{
this
.
addTab
=
this
.
addTab
.
bind
(
this
)
;
}
#
currentTooltip
=
null
;
#
currentUrl
=
null
;
#
createElement
(
doc
tag
classList
=
[
]
attributeList
=
{
}
)
{
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
newElement
=
doc
.
createElementNS
(
XHTML_NS
tag
)
;
for
(
const
elementClass
of
classList
)
{
newElement
.
classList
.
add
(
elementClass
)
;
}
for
(
const
key
in
attributeList
)
{
newElement
.
setAttribute
(
key
attributeList
[
key
]
)
;
}
return
newElement
;
}
#
renderUnsupportedBrowserList
(
container
unsupportedBrowsers
)
{
if
(
!
unsupportedBrowsers
.
length
)
{
return
;
}
const
{
require
}
=
BrowserLoader
(
{
baseURI
:
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
tooltip
/
"
window
:
this
.
#
currentTooltip
.
doc
.
defaultView
}
)
;
const
{
createFactory
createElement
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
.
js
"
)
;
const
ReactDOM
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dom
.
js
"
)
;
const
UnsupportedBrowserList
=
createFactory
(
require
(
"
resource
:
/
/
devtools
/
client
/
inspector
/
compatibility
/
components
/
UnsupportedBrowserList
.
js
"
)
)
;
const
unsupportedBrowserList
=
createElement
(
UnsupportedBrowserList
{
browsers
:
unsupportedBrowsers
}
)
;
ReactDOM
.
render
(
unsupportedBrowserList
container
.
querySelector
(
"
.
compatibility
-
browser
-
list
-
wrapper
"
)
)
;
}
#
getCompatibilityMessage
(
doc
data
)
{
const
{
msgId
property
}
=
data
;
return
this
.
#
createElement
(
doc
"
p
"
[
]
{
"
data
-
l10n
-
id
"
:
msgId
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
{
property
}
)
}
)
;
}
#
getBrowserListContainer
(
doc
unsupportedBrowsers
)
{
if
(
!
unsupportedBrowsers
.
length
)
{
return
null
;
}
const
browserList
=
this
.
#
createElement
(
doc
"
p
"
)
;
const
browserListWrapper
=
this
.
#
createElement
(
doc
"
div
"
[
"
compatibility
-
browser
-
list
-
wrapper
"
]
)
;
browserList
.
appendChild
(
browserListWrapper
)
;
return
browserList
;
}
/
*
*
This
is
the
learn
more
message
element
linking
to
the
MDN
documentation
*
for
the
particular
incompatible
CSS
declaration
.
*
The
element
returned
is
:
*
<
p
data
-
l10n
-
id
=
"
css
-
compatibility
-
learn
-
more
-
message
"
*
data
-
l10n
-
args
=
"
{
&
quot
;
property
&
quot
;
:
&
quot
;
user
-
select
&
quot
;
}
"
>
*
<
span
data
-
l10n
-
name
=
"
link
"
class
=
"
link
"
>
<
/
span
>
*
<
/
p
>
*
/
#
getLearnMoreMessage
(
doc
{
rootProperty
}
)
{
const
learnMoreMessage
=
this
.
#
createElement
(
doc
"
p
"
[
]
{
"
data
-
l10n
-
id
"
:
"
css
-
compatibility
-
learn
-
more
-
message
"
"
data
-
l10n
-
args
"
:
JSON
.
stringify
(
{
rootProperty
}
)
}
)
;
learnMoreMessage
.
appendChild
(
this
.
#
createElement
(
doc
"
span
"
[
"
link
"
]
{
"
data
-
l10n
-
name
"
:
"
link
"
}
)
)
;
return
learnMoreMessage
;
}
async
setContent
(
data
tooltip
)
{
const
fragment
=
this
.
getTemplate
(
data
tooltip
)
;
const
{
doc
}
=
tooltip
;
tooltip
.
panel
.
innerHTML
=
"
"
;
tooltip
.
panel
.
addEventListener
(
"
click
"
this
.
addTab
)
;
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
tooltip
.
panel
.
removeEventListener
(
"
click
"
this
.
addTab
)
;
}
)
;
await
doc
.
l10n
.
translateFragment
(
fragment
)
;
doc
.
l10n
.
pauseObserving
(
)
;
tooltip
.
panel
.
appendChild
(
fragment
)
;
doc
.
l10n
.
resumeObserving
(
)
;
tooltip
.
setContentSize
(
{
width
:
267
height
:
Infinity
}
)
;
}
getTemplate
(
data
tooltip
)
{
const
{
doc
}
=
tooltip
;
const
{
specUrl
url
unsupportedBrowsers
}
=
data
;
this
.
#
currentTooltip
=
tooltip
;
this
.
#
currentUrl
=
url
?
{
url
}
?
utm_source
=
devtools
&
utm_medium
=
inspector
-
css
-
compatibility
&
utm_campaign
=
default
:
specUrl
;
const
templateNode
=
this
.
#
createElement
(
doc
"
template
"
)
;
const
tooltipContainer
=
this
.
#
createElement
(
doc
"
div
"
[
"
devtools
-
tooltip
-
css
-
compatibility
"
]
)
;
tooltipContainer
.
appendChild
(
this
.
#
getCompatibilityMessage
(
doc
data
)
)
;
const
browserListContainer
=
this
.
#
getBrowserListContainer
(
doc
unsupportedBrowsers
)
;
if
(
browserListContainer
)
{
tooltipContainer
.
appendChild
(
browserListContainer
)
;
this
.
#
renderUnsupportedBrowserList
(
tooltipContainer
unsupportedBrowsers
)
;
}
if
(
this
.
#
currentUrl
)
{
tooltipContainer
.
appendChild
(
this
.
#
getLearnMoreMessage
(
doc
data
)
)
;
}
templateNode
.
content
.
appendChild
(
tooltipContainer
)
;
return
doc
.
importNode
(
templateNode
.
content
true
)
;
}
/
*
*
*
Hide
the
tooltip
open
this
.
#
currentUrl
in
a
new
tab
and
focus
it
.
*
*
param
{
DOMEvent
}
event
*
The
click
event
originating
from
the
tooltip
.
*
*
/
addTab
(
event
)
{
/
/
The
XUL
panel
swallows
click
events
so
handlers
can
'
t
be
added
directly
/
/
to
the
link
span
.
As
a
workaround
we
listen
to
all
click
events
in
the
/
/
panel
and
if
a
link
span
is
clicked
we
proceed
.
if
(
event
.
target
.
className
!
=
=
"
link
"
)
{
return
;
}
const
tooltip
=
this
.
#
currentTooltip
;
tooltip
.
hide
(
)
;
const
isMacOS
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
openDocLink
(
this
.
#
currentUrl
{
relatedToCurrent
:
true
inBackground
:
isMacOS
?
event
.
metaKey
:
event
.
ctrlKey
}
)
;
}
destroy
(
)
{
this
.
#
currentTooltip
=
null
;
this
.
#
currentUrl
=
null
;
}
}
module
.
exports
=
CssCompatibilityTooltipHelper
;
