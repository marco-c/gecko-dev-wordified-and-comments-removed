"
use
strict
"
;
const
DEFAULT_TOGGLE_DELAY
=
50
;
class
TooltipToggle
{
constructor
(
tooltip
)
{
this
.
tooltip
=
tooltip
;
this
.
win
=
tooltip
.
doc
.
defaultView
;
this
.
_onMouseMove
=
this
.
_onMouseMove
.
bind
(
this
)
;
this
.
_onMouseOut
=
this
.
_onMouseOut
.
bind
(
this
)
;
this
.
_onTooltipMouseOver
=
this
.
_onTooltipMouseOver
.
bind
(
this
)
;
this
.
_onTooltipMouseOut
=
this
.
_onTooltipMouseOut
.
bind
(
this
)
;
}
start
(
baseNode
targetNodeCb
{
toggleDelay
=
DEFAULT_TOGGLE_DELAY
interactive
=
false
}
=
{
}
)
{
this
.
stop
(
)
;
if
(
!
baseNode
)
{
return
;
}
this
.
_baseNode
=
baseNode
;
this
.
_targetNodeCb
=
targetNodeCb
|
|
(
(
)
=
>
true
)
;
this
.
_toggleDelay
=
toggleDelay
;
this
.
_interactive
=
interactive
;
baseNode
.
addEventListener
(
"
mousemove
"
this
.
_onMouseMove
)
;
baseNode
.
addEventListener
(
"
mouseout
"
this
.
_onMouseOut
)
;
const
target
=
this
.
tooltip
.
xulPanelWrapper
|
|
this
.
tooltip
.
container
;
if
(
this
.
_interactive
)
{
target
.
addEventListener
(
"
mouseover
"
this
.
_onTooltipMouseOver
)
;
target
.
addEventListener
(
"
mouseout
"
this
.
_onTooltipMouseOut
)
;
}
else
{
target
.
classList
.
add
(
"
non
-
interactive
-
toggle
"
)
;
}
}
stop
(
)
{
this
.
win
.
clearTimeout
(
this
.
toggleTimer
)
;
if
(
!
this
.
_baseNode
)
{
return
;
}
this
.
_baseNode
.
removeEventListener
(
"
mousemove
"
this
.
_onMouseMove
)
;
this
.
_baseNode
.
removeEventListener
(
"
mouseout
"
this
.
_onMouseOut
)
;
const
target
=
this
.
tooltip
.
xulPanelWrapper
|
|
this
.
tooltip
.
container
;
if
(
this
.
_interactive
)
{
target
.
removeEventListener
(
"
mouseover
"
this
.
_onTooltipMouseOver
)
;
target
.
removeEventListener
(
"
mouseout
"
this
.
_onTooltipMouseOut
)
;
}
else
{
target
.
classList
.
remove
(
"
non
-
interactive
-
toggle
"
)
;
}
this
.
_baseNode
=
null
;
this
.
_targetNodeCb
=
null
;
this
.
_lastHovered
=
null
;
}
_onMouseMove
(
event
)
{
if
(
event
.
target
!
=
=
this
.
_lastHovered
)
{
this
.
_lastHovered
=
event
.
target
;
this
.
win
.
clearTimeout
(
this
.
toggleTimer
)
;
this
.
toggleTimer
=
this
.
win
.
setTimeout
(
(
)
=
>
{
this
.
tooltip
.
hide
(
)
;
this
.
isValidHoverTarget
(
event
.
target
)
.
then
(
target
=
>
{
if
(
target
=
=
=
null
|
|
!
this
.
_baseNode
)
{
return
;
}
this
.
tooltip
.
show
(
target
)
;
}
reason
=
>
{
console
.
error
(
"
isValidHoverTarget
rejected
with
unexpected
reason
:
"
)
;
console
.
error
(
reason
)
;
}
)
;
}
this
.
_toggleDelay
)
;
}
}
async
isValidHoverTarget
(
target
)
{
const
res
=
await
this
.
_targetNodeCb
(
target
this
.
tooltip
)
;
if
(
res
)
{
return
res
.
nodeName
?
res
:
target
;
}
return
null
;
}
_onMouseOut
(
event
)
{
if
(
event
&
&
this
.
_baseNode
&
&
this
.
_baseNode
.
contains
(
event
.
relatedTarget
)
)
{
return
;
}
this
.
_lastHovered
=
null
;
this
.
win
.
clearTimeout
(
this
.
toggleTimer
)
;
this
.
toggleTimer
=
this
.
win
.
setTimeout
(
(
)
=
>
{
this
.
tooltip
.
hide
(
)
;
}
this
.
_toggleDelay
)
;
}
_onTooltipMouseOver
(
)
{
this
.
win
.
clearTimeout
(
this
.
toggleTimer
)
;
}
_onTooltipMouseOut
(
)
{
this
.
win
.
clearTimeout
(
this
.
toggleTimer
)
;
this
.
toggleTimer
=
this
.
win
.
setTimeout
(
(
)
=
>
{
this
.
tooltip
.
hide
(
)
;
}
this
.
_toggleDelay
)
;
}
destroy
(
)
{
this
.
stop
(
)
;
}
}
module
.
exports
.
TooltipToggle
=
TooltipToggle
;
