"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
KeyShortcuts
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
)
;
const
InlineTooltip
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
InlineTooltip
"
)
;
const
INLINE_TOOLTIP_CLASS
=
"
inline
-
tooltip
-
container
"
;
class
SwatchBasedEditorTooltip
{
constructor
(
document
useInline
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
useInline
=
useInline
;
if
(
useInline
)
{
this
.
tooltip
=
new
InlineTooltip
(
document
)
;
}
else
{
this
.
tooltip
=
new
HTMLTooltip
(
document
{
type
:
"
arrow
"
consumeOutsideClicks
:
true
useXulWrapper
:
true
}
)
;
}
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
tooltip
.
topWindow
}
)
;
this
.
shortcuts
.
on
(
"
Escape
"
event
=
>
{
if
(
!
this
.
tooltip
.
isVisible
(
)
)
{
return
;
}
this
.
revert
(
)
;
this
.
hide
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
"
Return
"
event
=
>
{
if
(
!
this
.
tooltip
.
isVisible
(
)
)
{
return
;
}
this
.
commit
(
)
;
this
.
hide
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
swatches
=
new
Map
(
)
;
this
.
activeSwatch
=
null
;
this
.
_onSwatchClick
=
this
.
_onSwatchClick
.
bind
(
this
)
;
}
isVisible
(
)
{
return
this
.
tooltip
.
isVisible
(
)
;
}
isEditing
(
)
{
return
this
.
isVisible
(
)
;
}
show
(
)
{
if
(
this
.
tooltipAnchor
)
{
const
onShown
=
this
.
tooltip
.
once
(
"
shown
"
)
;
this
.
tooltip
.
show
(
this
.
tooltipAnchor
)
;
this
.
tooltip
.
once
(
"
hidden
"
(
)
=
>
this
.
onTooltipHidden
(
)
)
;
return
onShown
;
}
return
Promise
.
resolve
(
)
;
}
onTooltipHidden
(
)
{
if
(
!
this
.
_reverted
)
{
this
.
commit
(
)
;
}
this
.
_reverted
=
false
;
this
.
activeSwatch
=
null
;
}
hide
(
)
{
this
.
tooltip
.
hide
(
)
;
}
addSwatch
(
swatchEl
callbacks
=
{
}
)
{
if
(
!
callbacks
.
onShow
)
{
callbacks
.
onShow
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onPreview
)
{
callbacks
.
onPreview
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onRevert
)
{
callbacks
.
onRevert
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onCommit
)
{
callbacks
.
onCommit
=
function
(
)
{
}
;
}
this
.
swatches
.
set
(
swatchEl
{
callbacks
:
callbacks
}
)
;
swatchEl
.
addEventListener
(
"
click
"
this
.
_onSwatchClick
)
;
}
removeSwatch
(
swatchEl
)
{
if
(
this
.
swatches
.
has
(
swatchEl
)
)
{
if
(
this
.
activeSwatch
=
=
=
swatchEl
)
{
this
.
hide
(
)
;
this
.
activeSwatch
=
null
;
}
swatchEl
.
removeEventListener
(
"
click
"
this
.
_onSwatchClick
)
;
this
.
swatches
.
delete
(
swatchEl
)
;
}
}
_onSwatchClick
(
event
)
{
const
swatch
=
this
.
swatches
.
get
(
event
.
target
)
;
if
(
event
.
shiftKey
)
{
event
.
stopPropagation
(
)
;
return
;
}
if
(
swatch
)
{
this
.
activeSwatch
=
event
.
target
;
this
.
show
(
)
;
swatch
.
callbacks
.
onShow
(
)
;
event
.
stopPropagation
(
)
;
}
}
preview
(
value
)
{
if
(
this
.
activeSwatch
)
{
const
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
swatch
.
callbacks
.
onPreview
(
value
)
;
}
}
revert
(
)
{
if
(
this
.
activeSwatch
)
{
this
.
_reverted
=
true
;
const
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
this
.
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
swatch
.
callbacks
.
onRevert
(
)
;
}
)
;
}
}
commit
(
)
{
if
(
this
.
activeSwatch
)
{
const
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
swatch
.
callbacks
.
onCommit
(
)
;
}
}
get
tooltipAnchor
(
)
{
return
this
.
useInline
?
this
.
activeSwatch
.
closest
(
.
{
INLINE_TOOLTIP_CLASS
}
)
:
this
.
activeSwatch
;
}
destroy
(
)
{
this
.
swatches
.
clear
(
)
;
this
.
activeSwatch
=
null
;
this
.
tooltip
.
off
(
"
keydown
"
this
.
_onTooltipKeydown
)
;
this
.
tooltip
.
destroy
(
)
;
this
.
shortcuts
.
destroy
(
)
;
}
}
module
.
exports
=
SwatchBasedEditorTooltip
;
