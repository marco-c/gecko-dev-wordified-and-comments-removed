"
use
strict
"
;
var
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
)
;
var
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
var
{
VariablesView
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
promise
=
require
(
"
promise
"
)
;
var
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
var
{
LocalizationHelper
ELLIPSIS
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
Object
.
defineProperty
(
this
"
WebConsoleUtils
"
{
get
:
function
(
)
{
return
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
.
Utils
;
}
configurable
:
true
enumerable
:
true
}
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
VARIABLES_SORTING_ENABLED
"
(
)
=
>
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
ui
.
variables
-
sorting
-
enabled
"
)
)
;
const
MAX_LONG_STRING_LENGTH
=
200000
;
const
MAX_PROPERTY_ITEMS
=
2000
;
const
DBG_STRINGS_URI
=
"
devtools
/
client
/
locales
/
debugger
.
properties
"
;
this
.
EXPORTED_SYMBOLS
=
[
"
VariablesViewController
"
"
StackFrameUtils
"
]
;
var
L10N
=
new
LocalizationHelper
(
DBG_STRINGS_URI
)
;
function
VariablesViewController
(
aView
aOptions
=
{
}
)
{
this
.
addExpander
=
this
.
addExpander
.
bind
(
this
)
;
this
.
_setClientGetters
(
aOptions
)
;
this
.
_setEvaluationMacros
(
aOptions
)
;
this
.
_actors
=
new
Set
(
)
;
this
.
view
=
aView
;
this
.
view
.
controller
=
this
;
}
this
.
VariablesViewController
=
VariablesViewController
;
VariablesViewController
.
prototype
=
{
_getterOrSetterEvalMacro
:
VariablesView
.
getterOrSetterEvalMacro
_overrideValueEvalMacro
:
VariablesView
.
overrideValueEvalMacro
_simpleValueEvalMacro
:
VariablesView
.
simpleValueEvalMacro
_setClientGetters
:
function
(
aOptions
)
{
if
(
aOptions
.
getObjectClient
)
{
this
.
_getObjectClient
=
aOptions
.
getObjectClient
;
}
if
(
aOptions
.
getLongStringClient
)
{
this
.
_getLongStringClient
=
aOptions
.
getLongStringClient
;
}
if
(
aOptions
.
getEnvironmentClient
)
{
this
.
_getEnvironmentClient
=
aOptions
.
getEnvironmentClient
;
}
if
(
aOptions
.
releaseActor
)
{
this
.
_releaseActor
=
aOptions
.
releaseActor
;
}
}
_setEvaluationMacros
:
function
(
aOptions
)
{
if
(
aOptions
.
overrideValueEvalMacro
)
{
this
.
_overrideValueEvalMacro
=
aOptions
.
overrideValueEvalMacro
;
}
if
(
aOptions
.
getterOrSetterEvalMacro
)
{
this
.
_getterOrSetterEvalMacro
=
aOptions
.
getterOrSetterEvalMacro
;
}
if
(
aOptions
.
simpleValueEvalMacro
)
{
this
.
_simpleValueEvalMacro
=
aOptions
.
simpleValueEvalMacro
;
}
}
_populateFromLongString
:
function
(
aTarget
aGrip
)
{
const
deferred
=
defer
(
)
;
const
from
=
aGrip
.
initial
.
length
;
const
to
=
Math
.
min
(
aGrip
.
length
MAX_LONG_STRING_LENGTH
)
;
this
.
_getLongStringClient
(
aGrip
)
.
substring
(
from
to
aResponse
=
>
{
this
.
releaseActor
(
aGrip
)
;
aTarget
.
onexpand
=
null
;
aTarget
.
setGrip
(
aGrip
.
initial
+
aResponse
.
substring
)
;
aTarget
.
hideArrow
(
)
;
deferred
.
resolve
(
)
;
}
)
;
return
deferred
.
promise
;
}
_populatePropertySlices
:
function
(
aTarget
aGrip
)
{
if
(
aGrip
.
count
<
MAX_PROPERTY_ITEMS
)
{
return
this
.
_populateFromPropertyIterator
(
aTarget
aGrip
)
;
}
const
items
=
Math
.
ceil
(
aGrip
.
count
/
4
)
;
const
iterator
=
aGrip
.
propertyIterator
;
const
promises
=
[
]
;
for
(
let
i
=
0
;
i
<
4
;
i
+
+
)
{
const
start
=
aGrip
.
start
+
i
*
items
;
const
count
=
i
!
=
3
?
items
:
aGrip
.
count
-
i
*
items
;
const
sliceGrip
=
{
type
:
"
property
-
iterator
"
propertyIterator
:
iterator
start
:
start
count
:
count
}
;
const
deferred
=
defer
(
)
;
iterator
.
names
(
[
start
start
+
count
-
1
]
(
{
names
}
)
=
>
{
const
label
=
"
[
"
+
names
[
0
]
+
ELLIPSIS
+
names
[
1
]
+
"
]
"
;
const
item
=
aTarget
.
addItem
(
label
{
}
{
internalItem
:
true
}
)
;
item
.
showArrow
(
)
;
this
.
addExpander
(
item
sliceGrip
)
;
deferred
.
resolve
(
)
;
}
)
;
promises
.
push
(
deferred
.
promise
)
;
}
return
promise
.
all
(
promises
)
;
}
_populateFromPropertyIterator
:
function
(
aTarget
aGrip
)
{
if
(
aGrip
.
count
>
=
MAX_PROPERTY_ITEMS
)
{
return
this
.
_populatePropertySlices
(
aTarget
aGrip
)
;
}
const
deferred
=
defer
(
)
;
aGrip
.
propertyIterator
.
slice
(
aGrip
.
start
aGrip
.
count
(
{
ownProperties
}
)
=
>
{
if
(
Object
.
keys
(
ownProperties
)
.
length
>
0
)
{
aTarget
.
addItems
(
ownProperties
{
sorted
:
true
callback
:
this
.
addExpander
}
)
;
}
deferred
.
resolve
(
)
;
}
)
;
return
deferred
.
promise
;
}
_populateFromObjectWithIterator
:
function
(
aTarget
aGrip
aQuery
)
{
const
deferred
=
defer
(
)
;
const
objectClient
=
this
.
_getObjectClient
(
aGrip
)
;
const
isArray
=
aGrip
.
preview
&
&
aGrip
.
preview
.
kind
=
=
=
"
ArrayLike
"
;
if
(
isArray
)
{
const
options
=
{
ignoreNonIndexedProperties
:
true
query
:
aQuery
}
;
objectClient
.
enumProperties
(
options
(
{
iterator
}
)
=
>
{
const
sliceGrip
=
{
type
:
"
property
-
iterator
"
propertyIterator
:
iterator
start
:
0
count
:
iterator
.
count
}
;
this
.
_populatePropertySlices
(
aTarget
sliceGrip
)
.
then
(
(
)
=
>
{
const
options
=
{
ignoreIndexedProperties
:
true
sort
:
true
query
:
aQuery
}
;
objectClient
.
enumProperties
(
options
(
{
iterator
}
)
=
>
{
const
sliceGrip
=
{
type
:
"
property
-
iterator
"
propertyIterator
:
iterator
start
:
0
count
:
iterator
.
count
}
;
deferred
.
resolve
(
this
.
_populatePropertySlices
(
aTarget
sliceGrip
)
)
;
}
)
;
}
)
;
}
)
;
}
else
{
objectClient
.
enumProperties
(
{
sort
:
true
query
:
aQuery
}
(
{
iterator
}
)
=
>
{
const
sliceGrip
=
{
type
:
"
property
-
iterator
"
propertyIterator
:
iterator
start
:
0
count
:
iterator
.
count
}
;
deferred
.
resolve
(
this
.
_populatePropertySlices
(
aTarget
sliceGrip
)
)
;
}
)
;
}
return
deferred
.
promise
;
}
_populateObjectPrototype
:
function
(
aTarget
aPrototype
)
{
if
(
aPrototype
&
&
aPrototype
.
type
!
=
"
null
"
)
{
const
proto
=
aTarget
.
addItem
(
"
__proto__
"
{
value
:
aPrototype
}
)
;
this
.
addExpander
(
proto
aPrototype
)
;
}
}
_populateFromObject
:
function
(
aTarget
aGrip
)
{
if
(
aGrip
.
class
=
=
=
"
Proxy
"
)
{
this
.
addExpander
(
aTarget
.
addItem
(
"
<
target
>
"
{
value
:
aGrip
.
proxyTarget
}
{
internalItem
:
true
}
)
aGrip
.
proxyTarget
)
;
this
.
addExpander
(
aTarget
.
addItem
(
"
<
handler
>
"
{
value
:
aGrip
.
proxyHandler
}
{
internalItem
:
true
}
)
aGrip
.
proxyHandler
)
;
const
deferred
=
defer
(
)
;
deferred
.
resolve
(
)
;
return
deferred
.
promise
;
}
if
(
aGrip
.
class
=
=
=
"
Promise
"
&
&
aGrip
.
promiseState
)
{
const
{
state
value
reason
}
=
aGrip
.
promiseState
;
aTarget
.
addItem
(
"
<
state
>
"
{
value
:
state
}
{
internalItem
:
true
}
)
;
if
(
state
=
=
=
"
fulfilled
"
)
{
this
.
addExpander
(
aTarget
.
addItem
(
"
<
value
>
"
{
value
}
{
internalItem
:
true
}
)
value
)
;
}
else
if
(
state
=
=
=
"
rejected
"
)
{
this
.
addExpander
(
aTarget
.
addItem
(
"
<
reason
>
"
{
value
:
reason
}
{
internalItem
:
true
}
)
reason
)
;
}
}
else
if
(
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
aGrip
.
class
)
)
{
const
entriesList
=
aTarget
.
addItem
(
"
<
entries
>
"
{
}
{
internalItem
:
true
}
)
;
entriesList
.
showArrow
(
)
;
this
.
addExpander
(
entriesList
{
type
:
"
entries
-
list
"
obj
:
aGrip
}
)
;
}
if
(
"
ownPropertyLength
"
in
aGrip
&
&
aGrip
.
ownPropertyLength
>
=
MAX_PROPERTY_ITEMS
)
{
return
this
.
_populateFromObjectWithIterator
(
aTarget
aGrip
)
.
then
(
(
)
=
>
{
const
deferred
=
defer
(
)
;
const
objectClient
=
this
.
_getObjectClient
(
aGrip
)
;
objectClient
.
getPrototype
(
(
{
prototype
}
)
=
>
{
this
.
_populateObjectPrototype
(
aTarget
prototype
)
;
deferred
.
resolve
(
)
;
}
)
;
return
deferred
.
promise
;
}
)
;
}
return
this
.
_populateProperties
(
aTarget
aGrip
)
;
}
_populateProperties
:
function
(
aTarget
aGrip
aOptions
)
{
const
deferred
=
defer
(
)
;
const
objectClient
=
this
.
_getObjectClient
(
aGrip
)
;
objectClient
.
getPrototypeAndProperties
(
aResponse
=
>
{
const
ownProperties
=
aResponse
.
ownProperties
|
|
{
}
;
const
prototype
=
aResponse
.
prototype
|
|
null
;
const
safeGetterValues
=
aResponse
.
safeGetterValues
|
|
{
}
;
const
sortable
=
VariablesView
.
isSortable
(
aGrip
.
class
)
;
for
(
const
name
of
Object
.
keys
(
safeGetterValues
)
)
{
if
(
name
in
ownProperties
)
{
const
{
getterValue
getterPrototypeLevel
}
=
safeGetterValues
[
name
]
;
ownProperties
[
name
]
.
getterValue
=
getterValue
;
ownProperties
[
name
]
.
getterPrototypeLevel
=
getterPrototypeLevel
;
}
else
{
ownProperties
[
name
]
=
safeGetterValues
[
name
]
;
}
}
aTarget
.
addItems
(
ownProperties
{
sorted
:
sortable
callback
:
this
.
addExpander
}
)
;
this
.
_populateObjectPrototype
(
aTarget
prototype
)
;
if
(
aGrip
.
class
=
=
"
Function
"
)
{
objectClient
.
getScope
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
console
.
warn
(
aResponse
.
error
+
"
:
"
+
aResponse
.
message
)
;
return
void
deferred
.
resolve
(
)
;
}
this
.
_populateWithClosure
(
aTarget
aResponse
.
scope
)
.
then
(
deferred
.
resolve
)
;
}
)
;
}
else
{
deferred
.
resolve
(
)
;
}
}
)
;
return
deferred
.
promise
;
}
_populateWithClosure
:
function
(
aTarget
aScope
)
{
const
objectScopes
=
[
]
;
let
environment
=
aScope
;
const
funcScope
=
aTarget
.
addItem
(
"
<
Closure
>
"
)
;
funcScope
.
target
.
setAttribute
(
"
scope
"
"
"
)
;
funcScope
.
showArrow
(
)
;
do
{
const
label
=
StackFrameUtils
.
getScopeLabel
(
environment
)
;
const
closure
=
funcScope
.
addItem
(
label
undefined
{
relaxed
:
true
}
)
;
closure
.
target
.
setAttribute
(
"
scope
"
"
"
)
;
closure
.
showArrow
(
)
;
if
(
environment
.
bindings
)
{
this
.
_populateWithEnvironmentBindings
(
closure
environment
.
bindings
)
;
}
else
{
const
deferred
=
defer
(
)
;
objectScopes
.
push
(
deferred
.
promise
)
;
this
.
_getEnvironmentClient
(
environment
)
.
getBindings
(
response
=
>
{
this
.
_populateWithEnvironmentBindings
(
closure
response
.
bindings
)
;
deferred
.
resolve
(
)
;
}
)
;
}
}
while
(
(
environment
=
environment
.
parent
)
)
;
return
promise
.
all
(
objectScopes
)
.
then
(
(
)
=
>
{
this
.
view
.
emit
(
"
fetched
"
"
scopes
"
funcScope
)
;
}
)
;
}
_populateWithEnvironmentBindings
:
function
(
aTarget
aBindings
)
{
aTarget
.
addItems
(
aBindings
.
arguments
.
reduce
(
(
accumulator
arg
)
=
>
{
const
name
=
Object
.
getOwnPropertyNames
(
arg
)
[
0
]
;
const
descriptor
=
arg
[
name
]
;
accumulator
[
name
]
=
descriptor
;
return
accumulator
;
}
{
}
)
{
sorted
:
false
callback
:
this
.
addExpander
}
)
;
aTarget
.
addItems
(
aBindings
.
variables
{
sorted
:
VARIABLES_SORTING_ENABLED
callback
:
this
.
addExpander
}
)
;
}
_populateFromEntries
:
function
(
target
grip
)
{
const
objGrip
=
grip
.
obj
;
const
objectClient
=
this
.
_getObjectClient
(
objGrip
)
;
return
new
promise
(
(
resolve
reject
)
=
>
{
objectClient
.
enumEntries
(
(
response
)
=
>
{
if
(
response
.
error
)
{
console
.
warn
(
response
.
error
+
"
:
"
+
response
.
message
)
;
resolve
(
)
;
}
else
{
const
sliceGrip
=
{
type
:
"
property
-
iterator
"
propertyIterator
:
response
.
iterator
start
:
0
count
:
response
.
iterator
.
count
}
;
resolve
(
this
.
_populatePropertySlices
(
target
sliceGrip
)
)
;
}
}
)
;
}
)
;
}
addExpander
:
function
(
aTarget
aSource
)
{
if
(
aTarget
.
getter
|
|
aTarget
.
setter
)
{
aTarget
.
evaluationMacro
=
this
.
_overrideValueEvalMacro
;
const
getter
=
aTarget
.
get
(
"
get
"
)
;
if
(
getter
)
{
getter
.
evaluationMacro
=
this
.
_getterOrSetterEvalMacro
;
}
const
setter
=
aTarget
.
get
(
"
set
"
)
;
if
(
setter
)
{
setter
.
evaluationMacro
=
this
.
_getterOrSetterEvalMacro
;
}
}
else
{
aTarget
.
evaluationMacro
=
this
.
_simpleValueEvalMacro
;
}
if
(
VariablesView
.
isPrimitive
(
{
value
:
aSource
}
)
)
{
return
;
}
if
(
WebConsoleUtils
.
isActorGrip
(
aSource
)
&
&
aSource
.
type
=
=
"
longString
"
)
{
aTarget
.
showArrow
(
)
;
}
aTarget
.
onexpand
=
(
)
=
>
this
.
populate
(
aTarget
aSource
)
;
if
(
aTarget
.
shouldPrefetch
)
{
aTarget
.
addEventListener
(
"
mouseover
"
aTarget
.
onexpand
)
;
}
for
(
const
grip
of
[
aTarget
.
value
aTarget
.
getter
aTarget
.
setter
]
)
{
if
(
WebConsoleUtils
.
isActorGrip
(
grip
)
)
{
this
.
_actors
.
add
(
grip
.
actor
)
;
}
}
}
populate
:
function
(
aTarget
aSource
)
{
if
(
aTarget
.
_fetched
)
{
return
aTarget
.
_fetched
;
}
if
(
!
aSource
)
{
return
promise
.
reject
(
new
Error
(
"
No
actor
grip
was
given
for
the
variable
.
"
)
)
;
}
const
deferred
=
defer
(
)
;
aTarget
.
_fetched
=
deferred
.
promise
;
if
(
aSource
.
type
=
=
=
"
property
-
iterator
"
)
{
return
this
.
_populateFromPropertyIterator
(
aTarget
aSource
)
;
}
if
(
aSource
.
type
=
=
=
"
entries
-
list
"
)
{
return
this
.
_populateFromEntries
(
aTarget
aSource
)
;
}
if
(
aSource
.
type
=
=
=
"
mapEntry
"
|
|
aSource
.
type
=
=
=
"
storageEntry
"
)
{
aTarget
.
addItems
(
{
key
:
{
value
:
aSource
.
preview
.
key
}
value
:
{
value
:
aSource
.
preview
.
value
}
}
{
callback
:
this
.
addExpander
}
)
;
return
promise
.
resolve
(
)
;
}
if
(
VariablesView
.
isVariable
(
aTarget
)
)
{
this
.
_populateFromObject
(
aTarget
aSource
)
.
then
(
(
)
=
>
{
this
.
view
.
emit
(
"
fetched
"
"
properties
"
aTarget
)
;
this
.
view
.
commitHierarchy
(
)
;
deferred
.
resolve
(
)
;
}
)
;
return
deferred
.
promise
;
}
switch
(
aSource
.
type
)
{
case
"
longString
"
:
this
.
_populateFromLongString
(
aTarget
aSource
)
.
then
(
(
)
=
>
{
this
.
view
.
emit
(
"
fetched
"
"
longString
"
aTarget
)
;
deferred
.
resolve
(
)
;
}
)
;
break
;
case
"
with
"
:
case
"
object
"
:
this
.
_populateFromObject
(
aTarget
aSource
.
object
)
.
then
(
(
)
=
>
{
this
.
view
.
emit
(
"
fetched
"
"
variables
"
aTarget
)
;
this
.
view
.
commitHierarchy
(
)
;
deferred
.
resolve
(
)
;
}
)
;
break
;
case
"
block
"
:
case
"
function
"
:
this
.
_populateWithEnvironmentBindings
(
aTarget
aSource
.
bindings
)
;
this
.
view
.
commitHierarchy
(
)
;
deferred
.
resolve
(
)
;
break
;
default
:
const
error
=
"
Unknown
Debugger
.
Environment
type
:
"
+
aSource
.
type
;
console
.
error
(
error
)
;
deferred
.
reject
(
error
)
;
}
return
deferred
.
promise
;
}
supportsSearch
:
function
(
)
{
return
this
.
objectActor
&
&
(
"
ownPropertyLength
"
in
this
.
objectActor
)
;
}
performSearch
:
function
(
aScope
aToken
)
{
this
.
_populateFromObjectWithIterator
(
aScope
this
.
objectActor
aToken
)
.
then
(
(
)
=
>
{
this
.
view
.
emit
(
"
fetched
"
"
search
"
aScope
)
;
}
)
;
}
releaseActor
:
function
(
aActor
)
{
if
(
this
.
_releaseActor
)
{
this
.
_releaseActor
(
aActor
)
;
}
this
.
_actors
.
delete
(
aActor
)
;
}
releaseActors
:
function
(
aFilter
)
{
for
(
const
actor
of
this
.
_actors
)
{
if
(
!
aFilter
|
|
aFilter
(
actor
)
)
{
this
.
releaseActor
(
actor
)
;
}
}
}
setSingleVariable
:
function
(
options
configuration
=
{
}
)
{
this
.
_setEvaluationMacros
(
configuration
)
;
this
.
view
.
empty
(
)
;
const
scope
=
this
.
view
.
addScope
(
options
.
label
)
;
scope
.
expanded
=
true
;
scope
.
locked
=
true
;
const
variable
=
scope
.
addItem
(
undefined
{
enumerable
:
true
}
)
;
let
populated
;
if
(
options
.
objectActor
)
{
this
.
objectActor
=
options
.
objectActor
;
if
(
VariablesView
.
isPrimitive
(
{
value
:
this
.
objectActor
}
)
)
{
populated
=
promise
.
resolve
(
)
;
}
else
{
populated
=
this
.
populate
(
variable
options
.
objectActor
)
;
variable
.
expand
(
)
;
}
}
else
if
(
options
.
rawObject
)
{
variable
.
populate
(
options
.
rawObject
{
expanded
:
true
}
)
;
populated
=
promise
.
resolve
(
)
;
}
return
{
variable
:
variable
expanded
:
populated
}
;
}
}
;
VariablesViewController
.
attach
=
function
(
aView
aOptions
)
{
if
(
aView
.
controller
)
{
return
aView
.
controller
;
}
return
new
VariablesViewController
(
aView
aOptions
)
;
}
;
var
StackFrameUtils
=
this
.
StackFrameUtils
=
{
getFrameTitle
:
function
(
aFrame
)
{
if
(
aFrame
.
type
=
=
"
call
"
)
{
const
c
=
aFrame
.
callee
;
return
(
c
.
name
|
|
c
.
userDisplayName
|
|
c
.
displayName
|
|
"
(
anonymous
)
"
)
;
}
return
"
(
"
+
aFrame
.
type
+
"
)
"
;
}
getScopeLabel
:
function
(
aEnv
)
{
let
name
=
"
"
;
if
(
!
aEnv
.
parent
)
{
name
=
L10N
.
getStr
(
"
globalScopeLabel
"
)
;
}
else
{
name
=
aEnv
.
type
.
charAt
(
0
)
.
toUpperCase
(
)
+
aEnv
.
type
.
slice
(
1
)
;
}
let
label
=
L10N
.
getFormatStr
(
"
scopeLabel
"
name
)
;
switch
(
aEnv
.
type
)
{
case
"
with
"
:
case
"
object
"
:
label
+
=
"
[
"
+
aEnv
.
object
.
class
+
"
]
"
;
break
;
case
"
function
"
:
const
f
=
aEnv
.
function
;
label
+
=
"
[
"
+
(
f
.
name
|
|
f
.
userDisplayName
|
|
f
.
displayName
|
|
"
(
anonymous
)
"
)
+
"
]
"
;
break
;
}
return
label
;
}
}
;
