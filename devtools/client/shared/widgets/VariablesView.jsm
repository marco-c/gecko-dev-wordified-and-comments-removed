"
use
strict
"
;
const
DBG_STRINGS_URI
=
"
devtools
/
client
/
locales
/
debugger
.
properties
"
;
const
LAZY_EMPTY_DELAY
=
150
;
const
SCROLL_PAGE_SIZE_DEFAULT
=
0
;
const
PAGE_SIZE_SCROLL_HEIGHT_RATIO
=
100
;
const
PAGE_SIZE_MAX_JUMPS
=
30
;
const
SEARCH_ACTION_MAX_DELAY
=
300
;
const
ITEM_FLASH_DURATION
=
300
;
const
{
require
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
getSourceNames
}
=
require
(
"
devtools
/
client
/
shared
/
source
-
utils
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
ViewHelpers
setNamedTimeout
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
nodeConstants
=
require
(
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
const
{
LocalizationHelper
ELLIPSIS
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
DBG_STRINGS_URI
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
Object
.
defineProperty
(
this
"
WebConsoleUtils
"
{
get
:
function
(
)
{
return
require
(
"
devtools
/
client
/
webconsole
/
utils
"
)
.
Utils
;
}
configurable
:
true
enumerable
:
true
}
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
VariablesView
"
"
escapeHTML
"
]
;
this
.
VariablesView
=
function
VariablesView
(
aParentNode
aFlags
=
{
}
)
{
this
.
_store
=
[
]
;
this
.
_itemsByElement
=
new
WeakMap
(
)
;
this
.
_prevHierarchy
=
new
Map
(
)
;
this
.
_currHierarchy
=
new
Map
(
)
;
this
.
_parent
=
aParentNode
;
this
.
_parent
.
classList
.
add
(
"
variables
-
view
-
container
"
)
;
this
.
_parent
.
classList
.
add
(
"
theme
-
body
"
)
;
this
.
_appendEmptyNotice
(
)
;
this
.
_onSearchboxInput
=
this
.
_onSearchboxInput
.
bind
(
this
)
;
this
.
_onSearchboxKeyDown
=
this
.
_onSearchboxKeyDown
.
bind
(
this
)
;
this
.
_onViewKeyDown
=
this
.
_onViewKeyDown
.
bind
(
this
)
;
this
.
_list
=
this
.
document
.
createXULElement
(
"
scrollbox
"
)
;
this
.
_list
.
setAttribute
(
"
orient
"
"
vertical
"
)
;
this
.
_list
.
addEventListener
(
"
keydown
"
this
.
_onViewKeyDown
)
;
this
.
_parent
.
appendChild
(
this
.
_list
)
;
for
(
const
name
in
aFlags
)
{
this
[
name
]
=
aFlags
[
name
]
;
}
EventEmitter
.
decorate
(
this
)
;
}
;
VariablesView
.
prototype
=
{
set
rawObject
(
aObject
)
{
this
.
empty
(
)
;
this
.
addScope
(
)
.
addItem
(
undefined
{
enumerable
:
true
}
)
.
populate
(
aObject
{
sorted
:
true
}
)
;
}
addScope
:
function
(
aName
=
"
"
aCustomClass
=
"
"
)
{
this
.
_removeEmptyNotice
(
)
;
this
.
_toggleSearchVisibility
(
true
)
;
const
scope
=
new
Scope
(
this
aName
{
customClass
:
aCustomClass
}
)
;
this
.
_store
.
push
(
scope
)
;
this
.
_itemsByElement
.
set
(
scope
.
_target
scope
)
;
this
.
_currHierarchy
.
set
(
aName
scope
)
;
scope
.
header
=
!
!
aName
;
return
scope
;
}
empty
:
function
(
aTimeout
=
this
.
lazyEmptyDelay
)
{
if
(
!
this
.
_store
.
length
)
{
return
;
}
this
.
_store
.
length
=
0
;
this
.
_itemsByElement
=
new
WeakMap
(
)
;
this
.
_prevHierarchy
=
this
.
_currHierarchy
;
this
.
_currHierarchy
=
new
Map
(
)
;
if
(
this
.
lazyEmpty
&
&
aTimeout
>
0
)
{
this
.
_emptySoon
(
aTimeout
)
;
return
;
}
while
(
this
.
_list
.
hasChildNodes
(
)
)
{
this
.
_list
.
firstChild
.
remove
(
)
;
}
this
.
_appendEmptyNotice
(
)
;
this
.
_toggleSearchVisibility
(
false
)
;
}
_emptySoon
:
function
(
aTimeout
)
{
const
prevList
=
this
.
_list
;
const
currList
=
this
.
_list
=
this
.
document
.
createXULElement
(
"
scrollbox
"
)
;
this
.
window
.
setTimeout
(
(
)
=
>
{
prevList
.
removeEventListener
(
"
keydown
"
this
.
_onViewKeyDown
)
;
currList
.
addEventListener
(
"
keydown
"
this
.
_onViewKeyDown
)
;
currList
.
setAttribute
(
"
orient
"
"
vertical
"
)
;
this
.
_parent
.
removeChild
(
prevList
)
;
this
.
_parent
.
appendChild
(
currList
)
;
if
(
!
this
.
_store
.
length
)
{
this
.
_appendEmptyNotice
(
)
;
this
.
_toggleSearchVisibility
(
false
)
;
}
}
aTimeout
)
;
}
toolbox
:
null
controller
:
null
lazyEmptyDelay
:
LAZY_EMPTY_DELAY
lazyEmpty
:
false
lazySearch
:
true
scrollPageSize
:
SCROLL_PAGE_SIZE_DEFAULT
eval
:
null
switch
:
null
delete
:
null
new
:
null
preventDisableOnChange
:
false
preventDescriptorModifiers
:
false
editableValueTooltip
:
L10N
.
getStr
(
"
variablesEditableValueTooltip
"
)
editableNameTooltip
:
L10N
.
getStr
(
"
variablesEditableNameTooltip
"
)
editButtonTooltip
:
L10N
.
getStr
(
"
variablesEditButtonTooltip
"
)
domNodeValueTooltip
:
L10N
.
getStr
(
"
variablesDomNodeValueTooltip
"
)
deleteButtonTooltip
:
L10N
.
getStr
(
"
variablesCloseButtonTooltip
"
)
contextMenuId
:
"
"
separatorStr
:
L10N
.
getStr
(
"
variablesSeparatorLabel
"
)
set
enumVisible
(
aFlag
)
{
this
.
_enumVisible
=
aFlag
;
for
(
const
scope
of
this
.
_store
)
{
scope
.
_enumVisible
=
aFlag
;
}
}
set
nonEnumVisible
(
aFlag
)
{
this
.
_nonEnumVisible
=
aFlag
;
for
(
const
scope
of
this
.
_store
)
{
scope
.
_nonEnumVisible
=
aFlag
;
}
}
set
onlyEnumVisible
(
aFlag
)
{
if
(
aFlag
)
{
this
.
enumVisible
=
true
;
this
.
nonEnumVisible
=
false
;
}
else
{
this
.
enumVisible
=
true
;
this
.
nonEnumVisible
=
true
;
}
}
set
searchEnabled
(
aFlag
)
{
aFlag
?
this
.
_enableSearch
(
)
:
this
.
_disableSearch
(
)
;
}
get
searchEnabled
(
)
{
return
!
!
this
.
_searchboxContainer
;
}
set
searchPlaceholder
(
aValue
)
{
if
(
this
.
_searchboxNode
)
{
this
.
_searchboxNode
.
setAttribute
(
"
placeholder
"
aValue
)
;
}
this
.
_searchboxPlaceholder
=
aValue
;
}
get
searchPlaceholder
(
)
{
return
this
.
_searchboxPlaceholder
;
}
_enableSearch
:
function
(
)
{
if
(
this
.
_searchboxContainer
)
{
return
;
}
const
document
=
this
.
document
;
const
ownerNode
=
this
.
_parent
.
parentNode
;
const
container
=
this
.
_searchboxContainer
=
document
.
createXULElement
(
"
hbox
"
)
;
container
.
className
=
"
devtools
-
toolbar
"
;
container
.
hidden
=
!
this
.
_store
.
length
;
const
searchbox
=
this
.
_searchboxNode
=
document
.
createXULElement
(
"
textbox
"
)
;
searchbox
.
className
=
"
variables
-
view
-
searchinput
devtools
-
filterinput
"
;
searchbox
.
setAttribute
(
"
placeholder
"
this
.
_searchboxPlaceholder
)
;
searchbox
.
setAttribute
(
"
type
"
"
search
"
)
;
searchbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
searchbox
.
addEventListener
(
"
command
"
this
.
_onSearchboxInput
)
;
searchbox
.
addEventListener
(
"
keydown
"
this
.
_onSearchboxKeyDown
)
;
container
.
appendChild
(
searchbox
)
;
ownerNode
.
insertBefore
(
container
this
.
_parent
)
;
}
_disableSearch
:
function
(
)
{
if
(
!
this
.
_searchboxContainer
)
{
return
;
}
this
.
_searchboxContainer
.
remove
(
)
;
this
.
_searchboxNode
.
removeEventListener
(
"
command
"
this
.
_onSearchboxInput
)
;
this
.
_searchboxNode
.
removeEventListener
(
"
keydown
"
this
.
_onSearchboxKeyDown
)
;
this
.
_searchboxContainer
=
null
;
this
.
_searchboxNode
=
null
;
}
_toggleSearchVisibility
:
function
(
aVisibleFlag
)
{
if
(
!
this
.
_searchboxContainer
)
{
return
;
}
this
.
_searchboxContainer
.
hidden
=
!
aVisibleFlag
;
}
_onSearchboxInput
:
function
(
)
{
this
.
scheduleSearch
(
this
.
_searchboxNode
.
value
)
;
}
_onSearchboxKeyDown
:
function
(
e
)
{
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_RETURN
:
this
.
_onSearchboxInput
(
)
;
return
;
case
KeyCodes
.
DOM_VK_ESCAPE
:
this
.
_searchboxNode
.
value
=
"
"
;
this
.
_onSearchboxInput
(
)
;
}
}
scheduleSearch
:
function
(
aToken
aWait
)
{
if
(
!
this
.
lazySearch
)
{
this
.
_doSearch
(
aToken
)
;
return
;
}
const
maxDelay
=
SEARCH_ACTION_MAX_DELAY
;
const
delay
=
aWait
=
=
=
undefined
?
maxDelay
/
aToken
.
length
:
aWait
;
setNamedTimeout
(
"
vview
-
search
"
delay
(
)
=
>
this
.
_doSearch
(
aToken
)
)
;
}
_doSearch
:
function
(
aToken
)
{
if
(
this
.
controller
&
&
this
.
controller
.
supportsSearch
(
)
)
{
const
scope
=
this
.
_store
[
0
]
.
_store
.
get
(
undefined
)
;
if
(
!
aToken
)
{
for
(
const
property
of
scope
.
_store
.
values
(
)
)
{
property
.
remove
(
)
;
}
}
this
.
controller
.
performSearch
(
scope
aToken
)
;
if
(
aToken
)
{
scope
.
_performSearch
(
aToken
.
toLowerCase
(
)
)
;
}
return
;
}
for
(
const
scope
of
this
.
_store
)
{
switch
(
aToken
)
{
case
"
"
:
case
null
:
case
undefined
:
scope
.
expand
(
)
;
scope
.
_performSearch
(
"
"
)
;
break
;
default
:
scope
.
_performSearch
(
aToken
.
toLowerCase
(
)
)
;
break
;
}
}
}
_findInVisibleItems
:
function
(
aPredicate
)
{
for
(
const
scope
of
this
.
_store
)
{
const
result
=
scope
.
_findInVisibleItems
(
aPredicate
)
;
if
(
result
)
{
return
result
;
}
}
return
null
;
}
_findInVisibleItemsReverse
:
function
(
aPredicate
)
{
for
(
let
i
=
this
.
_store
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
scope
=
this
.
_store
[
i
]
;
const
result
=
scope
.
_findInVisibleItemsReverse
(
aPredicate
)
;
if
(
result
)
{
return
result
;
}
}
return
null
;
}
getScopeAtIndex
:
function
(
aIndex
)
{
return
this
.
_store
[
aIndex
]
;
}
getItemForNode
:
function
(
aNode
)
{
return
this
.
_itemsByElement
.
get
(
aNode
)
;
}
getOwnerScopeForVariableOrProperty
:
function
(
aItem
)
{
if
(
!
aItem
)
{
return
null
;
}
if
(
!
(
aItem
instanceof
Variable
)
)
{
return
aItem
;
}
if
(
aItem
instanceof
Variable
&
&
aItem
.
ownerView
)
{
return
this
.
getOwnerScopeForVariableOrProperty
(
aItem
.
ownerView
)
;
}
return
null
;
}
getParentScopesForVariableOrProperty
:
function
(
aItem
)
{
const
scope
=
this
.
getOwnerScopeForVariableOrProperty
(
aItem
)
;
return
this
.
_store
.
slice
(
0
Math
.
max
(
this
.
_store
.
indexOf
(
scope
)
0
)
)
;
}
getFocusedItem
:
function
(
)
{
const
focused
=
this
.
document
.
commandDispatcher
.
focusedElement
;
return
this
.
getItemForNode
(
focused
)
;
}
focusFirstVisibleItem
:
function
(
)
{
const
focusableItem
=
this
.
_findInVisibleItems
(
item
=
>
item
.
focusable
)
;
if
(
focusableItem
)
{
this
.
_focusItem
(
focusableItem
)
;
}
this
.
_parent
.
scrollTop
=
0
;
this
.
_parent
.
scrollLeft
=
0
;
}
focusLastVisibleItem
:
function
(
)
{
const
focusableItem
=
this
.
_findInVisibleItemsReverse
(
item
=
>
item
.
focusable
)
;
if
(
focusableItem
)
{
this
.
_focusItem
(
focusableItem
)
;
}
this
.
_parent
.
scrollTop
=
this
.
_parent
.
scrollHeight
;
this
.
_parent
.
scrollLeft
=
0
;
}
focusNextItem
:
function
(
)
{
this
.
focusItemAtDelta
(
+
1
)
;
}
focusPrevItem
:
function
(
)
{
this
.
focusItemAtDelta
(
-
1
)
;
}
focusItemAtDelta
:
function
(
aDelta
)
{
const
direction
=
aDelta
>
0
?
"
advanceFocus
"
:
"
rewindFocus
"
;
let
distance
=
Math
.
abs
(
Math
[
aDelta
>
0
?
"
ceil
"
:
"
floor
"
]
(
aDelta
)
)
;
while
(
distance
-
-
)
{
if
(
!
this
.
_focusChange
(
direction
)
)
{
break
;
}
}
}
_focusChange
:
function
(
aDirection
)
{
const
commandDispatcher
=
this
.
document
.
commandDispatcher
;
const
prevFocusedElement
=
commandDispatcher
.
focusedElement
;
let
currFocusedItem
=
null
;
do
{
commandDispatcher
[
aDirection
]
(
)
;
if
(
!
(
currFocusedItem
=
this
.
getFocusedItem
(
)
)
)
{
prevFocusedElement
.
focus
(
)
;
return
false
;
}
}
while
(
!
currFocusedItem
.
focusable
)
;
return
true
;
}
_focusItem
:
function
(
aItem
aCollapseFlag
)
{
if
(
!
aItem
.
focusable
)
{
return
false
;
}
if
(
aCollapseFlag
)
{
aItem
.
collapse
(
)
;
}
aItem
.
_target
.
focus
(
)
;
this
.
_list
.
ensureElementIsVisible
(
aItem
.
_arrow
)
;
return
true
;
}
_onViewKeyDown
:
function
(
e
)
{
const
item
=
this
.
getFocusedItem
(
)
;
ViewHelpers
.
preventScrolling
(
e
)
;
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_C
:
if
(
e
.
ctrlKey
|
|
e
.
metaKey
)
{
const
item
=
this
.
getFocusedItem
(
)
;
clipboardHelper
.
copyString
(
item
.
_nameString
+
item
.
separatorStr
+
item
.
_valueString
)
;
}
return
;
case
KeyCodes
.
DOM_VK_UP
:
this
.
focusPrevItem
(
true
)
;
return
;
case
KeyCodes
.
DOM_VK_DOWN
:
this
.
focusNextItem
(
true
)
;
return
;
case
KeyCodes
.
DOM_VK_LEFT
:
if
(
item
.
_isExpanded
&
&
item
.
_isArrowVisible
)
{
item
.
collapse
(
)
;
}
else
{
this
.
_focusItem
(
item
.
ownerView
)
;
}
return
;
case
KeyCodes
.
DOM_VK_RIGHT
:
if
(
!
item
.
_isArrowVisible
)
{
return
;
}
if
(
!
item
.
_isExpanded
)
{
item
.
expand
(
)
;
}
else
{
this
.
focusNextItem
(
true
)
;
}
return
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
this
.
focusItemAtDelta
(
-
(
this
.
scrollPageSize
|
|
Math
.
min
(
Math
.
floor
(
this
.
_list
.
scrollHeight
/
PAGE_SIZE_SCROLL_HEIGHT_RATIO
)
PAGE_SIZE_MAX_JUMPS
)
)
)
;
return
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
this
.
focusItemAtDelta
(
+
(
this
.
scrollPageSize
|
|
Math
.
min
(
Math
.
floor
(
this
.
_list
.
scrollHeight
/
PAGE_SIZE_SCROLL_HEIGHT_RATIO
)
PAGE_SIZE_MAX_JUMPS
)
)
)
;
return
;
case
KeyCodes
.
DOM_VK_HOME
:
this
.
focusFirstVisibleItem
(
)
;
return
;
case
KeyCodes
.
DOM_VK_END
:
this
.
focusLastVisibleItem
(
)
;
return
;
case
KeyCodes
.
DOM_VK_RETURN
:
if
(
item
instanceof
Variable
)
{
if
(
e
.
metaKey
|
|
e
.
altKey
|
|
e
.
shiftKey
)
{
item
.
_activateNameInput
(
)
;
}
else
{
item
.
_activateValueInput
(
)
;
}
}
return
;
case
KeyCodes
.
DOM_VK_DELETE
:
case
KeyCodes
.
DOM_VK_BACK_SPACE
:
if
(
item
instanceof
Variable
)
{
item
.
_onDelete
(
e
)
;
}
return
;
case
KeyCodes
.
DOM_VK_INSERT
:
item
.
_onAddProperty
(
e
)
;
}
}
set
emptyText
(
aValue
)
{
if
(
this
.
_emptyTextNode
)
{
this
.
_emptyTextNode
.
setAttribute
(
"
value
"
aValue
)
;
}
this
.
_emptyTextValue
=
aValue
;
this
.
_appendEmptyNotice
(
)
;
}
_appendEmptyNotice
:
function
(
)
{
if
(
this
.
_emptyTextNode
|
|
!
this
.
_emptyTextValue
)
{
return
;
}
const
label
=
this
.
document
.
createXULElement
(
"
label
"
)
;
label
.
className
=
"
variables
-
view
-
empty
-
notice
"
;
label
.
setAttribute
(
"
value
"
this
.
_emptyTextValue
)
;
this
.
_parent
.
appendChild
(
label
)
;
this
.
_emptyTextNode
=
label
;
}
_removeEmptyNotice
:
function
(
)
{
if
(
!
this
.
_emptyTextNode
)
{
return
;
}
this
.
_parent
.
removeChild
(
this
.
_emptyTextNode
)
;
this
.
_emptyTextNode
=
null
;
}
get
alignedValues
(
)
{
return
this
.
_alignedValues
;
}
set
alignedValues
(
aFlag
)
{
this
.
_alignedValues
=
aFlag
;
if
(
aFlag
)
{
this
.
_parent
.
setAttribute
(
"
aligned
-
values
"
"
"
)
;
}
else
{
this
.
_parent
.
removeAttribute
(
"
aligned
-
values
"
)
;
}
}
get
actionsFirst
(
)
{
return
this
.
_actionsFirst
;
}
set
actionsFirst
(
aFlag
)
{
this
.
_actionsFirst
=
aFlag
;
if
(
aFlag
)
{
this
.
_parent
.
setAttribute
(
"
actions
-
first
"
"
"
)
;
}
else
{
this
.
_parent
.
removeAttribute
(
"
actions
-
first
"
)
;
}
}
get
boxObject
(
)
{
return
this
.
_list
.
boxObject
;
}
get
parentNode
(
)
{
return
this
.
_parent
;
}
get
document
(
)
{
return
this
.
_document
|
|
(
this
.
_document
=
this
.
_parent
.
ownerDocument
)
;
}
get
window
(
)
{
return
this
.
_window
|
|
(
this
.
_window
=
this
.
document
.
defaultView
)
;
}
_document
:
null
_window
:
null
_store
:
null
_itemsByElement
:
null
_prevHierarchy
:
null
_currHierarchy
:
null
_enumVisible
:
true
_nonEnumVisible
:
true
_alignedValues
:
false
_actionsFirst
:
false
_parent
:
null
_list
:
null
_searchboxNode
:
null
_searchboxContainer
:
null
_searchboxPlaceholder
:
"
"
_emptyTextNode
:
null
_emptyTextValue
:
"
"
}
;
VariablesView
.
NON_SORTABLE_CLASSES
=
[
"
Array
"
"
Int8Array
"
"
Uint8Array
"
"
Uint8ClampedArray
"
"
Int16Array
"
"
Uint16Array
"
"
Int32Array
"
"
Uint32Array
"
"
Float32Array
"
"
Float64Array
"
"
NodeList
"
]
;
VariablesView
.
isSortable
=
function
(
aClassName
)
{
return
!
VariablesView
.
NON_SORTABLE_CLASSES
.
includes
(
aClassName
)
;
}
;
VariablesView
.
simpleValueEvalMacro
=
function
(
aItem
aCurrentString
aPrefix
=
"
"
)
{
return
aPrefix
+
aItem
.
symbolicName
+
"
=
"
+
aCurrentString
;
}
;
VariablesView
.
overrideValueEvalMacro
=
function
(
aItem
aCurrentString
aPrefix
=
"
"
)
{
const
property
=
escapeString
(
aItem
.
_nameString
)
;
const
parent
=
aPrefix
+
aItem
.
ownerView
.
symbolicName
|
|
"
this
"
;
return
"
Object
.
defineProperty
(
"
+
parent
+
"
"
+
property
+
"
"
+
"
{
value
:
"
+
aCurrentString
+
"
enumerable
:
"
+
parent
+
"
.
propertyIsEnumerable
(
"
+
property
+
"
)
"
+
"
configurable
:
true
"
+
"
writable
:
true
"
+
"
}
)
"
;
}
;
VariablesView
.
getterOrSetterEvalMacro
=
function
(
aItem
aCurrentString
aPrefix
=
"
"
)
{
const
type
=
aItem
.
_nameString
;
const
propertyObject
=
aItem
.
ownerView
;
const
parentObject
=
propertyObject
.
ownerView
;
const
property
=
escapeString
(
propertyObject
.
_nameString
)
;
const
parent
=
aPrefix
+
parentObject
.
symbolicName
|
|
"
this
"
;
switch
(
aCurrentString
)
{
case
"
"
:
case
"
null
"
:
case
"
undefined
"
:
const
mirrorType
=
type
=
=
"
get
"
?
"
set
"
:
"
get
"
;
const
mirrorLookup
=
type
=
=
"
get
"
?
"
__lookupSetter__
"
:
"
__lookupGetter__
"
;
if
(
(
type
=
=
"
set
"
&
&
propertyObject
.
getter
.
type
=
=
"
undefined
"
)
|
|
(
type
=
=
"
get
"
&
&
propertyObject
.
setter
.
type
=
=
"
undefined
"
)
)
{
return
propertyObject
.
evaluationMacro
(
propertyObject
"
undefined
"
aPrefix
)
;
}
return
"
Object
.
defineProperty
(
"
+
parent
+
"
"
+
property
+
"
"
+
"
{
"
+
mirrorType
+
"
:
"
+
parent
+
"
.
"
+
mirrorLookup
+
"
(
"
+
property
+
"
)
"
+
"
"
+
type
+
"
:
"
+
undefined
+
"
enumerable
:
"
+
parent
+
"
.
propertyIsEnumerable
(
"
+
property
+
"
)
"
+
"
configurable
:
true
"
+
"
}
)
"
;
default
:
if
(
!
aCurrentString
.
startsWith
(
"
function
"
)
)
{
const
header
=
"
function
(
"
+
(
type
=
=
"
set
"
?
"
value
"
:
"
"
)
+
"
)
"
;
let
body
=
"
"
;
if
(
aCurrentString
.
includes
(
"
return
"
)
)
{
body
=
"
{
"
+
aCurrentString
+
"
}
"
;
}
else
if
(
aCurrentString
.
startsWith
(
"
{
"
)
)
{
body
=
aCurrentString
;
}
else
{
body
=
"
(
"
+
aCurrentString
+
"
)
"
;
}
aCurrentString
=
header
+
body
;
}
const
defineType
=
type
=
=
"
get
"
?
"
__defineGetter__
"
:
"
__defineSetter__
"
;
const
defineFunc
=
"
eval
(
\
"
(
"
+
aCurrentString
.
replace
(
/
"
/
g
"
\
\
&
"
)
+
"
)
\
"
)
"
;
return
parent
+
"
.
"
+
defineType
+
"
(
"
+
property
+
"
"
+
defineFunc
+
"
)
"
;
}
}
;
VariablesView
.
getterOrSetterDeleteCallback
=
function
(
aItem
)
{
aItem
.
_disable
(
)
;
aItem
.
ownerView
.
eval
(
aItem
"
"
)
;
return
true
;
}
;
function
Scope
(
aView
aName
aFlags
=
{
}
)
{
this
.
ownerView
=
aView
;
this
.
_onClick
=
this
.
_onClick
.
bind
(
this
)
;
this
.
_openEnum
=
this
.
_openEnum
.
bind
(
this
)
;
this
.
_openNonEnum
=
this
.
_openNonEnum
.
bind
(
this
)
;
this
.
scrollPageSize
=
aView
.
scrollPageSize
;
this
.
eval
=
aView
.
eval
;
this
.
switch
=
aView
.
switch
;
this
.
delete
=
aView
.
delete
;
this
.
new
=
aView
.
new
;
this
.
preventDisableOnChange
=
aView
.
preventDisableOnChange
;
this
.
preventDescriptorModifiers
=
aView
.
preventDescriptorModifiers
;
this
.
editableNameTooltip
=
aView
.
editableNameTooltip
;
this
.
editableValueTooltip
=
aView
.
editableValueTooltip
;
this
.
editButtonTooltip
=
aView
.
editButtonTooltip
;
this
.
deleteButtonTooltip
=
aView
.
deleteButtonTooltip
;
this
.
domNodeValueTooltip
=
aView
.
domNodeValueTooltip
;
this
.
contextMenuId
=
aView
.
contextMenuId
;
this
.
separatorStr
=
aView
.
separatorStr
;
this
.
_init
(
aName
aFlags
)
;
}
Scope
.
prototype
=
{
shouldPrefetch
:
true
allowPaginate
:
false
targetClassName
:
"
variables
-
view
-
scope
"
_createChild
:
function
(
aName
aDescriptor
aOptions
)
{
return
new
Variable
(
this
aName
aDescriptor
aOptions
)
;
}
addItem
:
function
(
aName
aDescriptor
=
{
}
aOptions
=
{
}
)
{
const
{
relaxed
}
=
aOptions
;
if
(
this
.
_store
.
has
(
aName
)
&
&
!
relaxed
)
{
return
this
.
_store
.
get
(
aName
)
;
}
const
child
=
this
.
_createChild
(
aName
aDescriptor
aOptions
)
;
this
.
_store
.
set
(
aName
child
)
;
this
.
_variablesView
.
_itemsByElement
.
set
(
child
.
_target
child
)
;
this
.
_variablesView
.
_currHierarchy
.
set
(
child
.
absoluteName
child
)
;
child
.
header
=
aName
!
=
=
undefined
;
return
child
;
}
addItems
:
function
(
aItems
aOptions
=
{
}
)
{
const
names
=
Object
.
keys
(
aItems
)
;
if
(
aOptions
.
sorted
)
{
names
.
sort
(
this
.
_naturalSort
)
;
}
for
(
const
name
of
names
)
{
const
descriptor
=
aItems
[
name
]
;
const
item
=
this
.
addItem
(
name
descriptor
)
;
if
(
aOptions
.
callback
)
{
aOptions
.
callback
(
item
descriptor
&
&
descriptor
.
value
)
;
}
}
}
remove
:
function
(
)
{
const
view
=
this
.
_variablesView
;
view
.
_store
.
splice
(
view
.
_store
.
indexOf
(
this
)
1
)
;
view
.
_itemsByElement
.
delete
(
this
.
_target
)
;
view
.
_currHierarchy
.
delete
(
this
.
_nameString
)
;
this
.
_target
.
remove
(
)
;
for
(
const
variable
of
this
.
_store
.
values
(
)
)
{
variable
.
remove
(
)
;
}
}
get
:
function
(
aName
)
{
return
this
.
_store
.
get
(
aName
)
;
}
find
:
function
(
aNode
)
{
for
(
const
[
variable
]
of
this
.
_store
)
{
let
match
;
if
(
variable
.
_target
=
=
aNode
)
{
match
=
variable
;
}
else
{
match
=
variable
.
find
(
aNode
)
;
}
if
(
match
)
{
return
match
;
}
}
return
null
;
}
isChildOf
:
function
(
aParent
)
{
return
this
.
ownerView
=
=
aParent
;
}
isDescendantOf
:
function
(
aParent
)
{
if
(
this
.
isChildOf
(
aParent
)
)
{
return
true
;
}
if
(
this
.
ownerView
instanceof
Scope
)
{
return
this
.
ownerView
.
isDescendantOf
(
aParent
)
;
}
return
false
;
}
show
:
function
(
)
{
this
.
_target
.
hidden
=
false
;
this
.
_isContentVisible
=
true
;
if
(
this
.
onshow
)
{
this
.
onshow
(
this
)
;
}
}
hide
:
function
(
)
{
this
.
_target
.
hidden
=
true
;
this
.
_isContentVisible
=
false
;
if
(
this
.
onhide
)
{
this
.
onhide
(
this
)
;
}
}
expand
:
function
(
)
{
if
(
this
.
_isExpanded
|
|
this
.
_isLocked
)
{
return
;
}
if
(
this
.
_variablesView
.
_enumVisible
)
{
this
.
_openEnum
(
)
;
}
if
(
this
.
_variablesView
.
_nonEnumVisible
)
{
Services
.
tm
.
dispatchToMainThread
(
{
run
:
this
.
_openNonEnum
}
)
;
}
this
.
_isExpanded
=
true
;
if
(
this
.
onexpand
)
{
return
this
.
onexpand
(
this
)
;
}
}
collapse
:
function
(
)
{
if
(
!
this
.
_isExpanded
|
|
this
.
_isLocked
)
{
return
;
}
this
.
_arrow
.
removeAttribute
(
"
open
"
)
;
this
.
_enum
.
removeAttribute
(
"
open
"
)
;
this
.
_nonenum
.
removeAttribute
(
"
open
"
)
;
this
.
_isExpanded
=
false
;
if
(
this
.
oncollapse
)
{
this
.
oncollapse
(
this
)
;
}
}
toggle
:
function
(
e
)
{
if
(
e
&
&
e
.
button
!
=
0
)
{
return
;
}
this
.
expanded
^
=
1
;
for
(
const
[
variable
]
of
this
.
_store
)
{
variable
.
header
=
true
;
variable
.
_matched
=
true
;
}
if
(
this
.
ontoggle
)
{
this
.
ontoggle
(
this
)
;
}
}
showHeader
:
function
(
)
{
if
(
this
.
_isHeaderVisible
|
|
!
this
.
_nameString
)
{
return
;
}
this
.
_target
.
removeAttribute
(
"
untitled
"
)
;
this
.
_isHeaderVisible
=
true
;
}
hideHeader
:
function
(
)
{
if
(
!
this
.
_isHeaderVisible
)
{
return
;
}
this
.
expand
(
)
;
this
.
_target
.
setAttribute
(
"
untitled
"
"
"
)
;
this
.
_isHeaderVisible
=
false
;
}
_naturalSort
:
function
(
a
b
)
{
if
(
isNaN
(
parseFloat
(
a
)
)
&
&
isNaN
(
parseFloat
(
b
)
)
)
{
return
a
<
b
?
-
1
:
1
;
}
}
showArrow
:
function
(
)
{
if
(
this
.
_isArrowVisible
)
{
return
;
}
this
.
_arrow
.
removeAttribute
(
"
invisible
"
)
;
this
.
_isArrowVisible
=
true
;
}
hideArrow
:
function
(
)
{
if
(
!
this
.
_isArrowVisible
)
{
return
;
}
this
.
_arrow
.
setAttribute
(
"
invisible
"
"
"
)
;
this
.
_isArrowVisible
=
false
;
}
get
visible
(
)
{
return
this
.
_isContentVisible
;
}
get
expanded
(
)
{
return
this
.
_isExpanded
;
}
get
header
(
)
{
return
this
.
_isHeaderVisible
;
}
get
twisty
(
)
{
return
this
.
_isArrowVisible
;
}
get
locked
(
)
{
return
this
.
_isLocked
;
}
set
visible
(
aFlag
)
{
aFlag
?
this
.
show
(
)
:
this
.
hide
(
)
;
}
set
expanded
(
aFlag
)
{
aFlag
?
this
.
expand
(
)
:
this
.
collapse
(
)
;
}
set
header
(
aFlag
)
{
aFlag
?
this
.
showHeader
(
)
:
this
.
hideHeader
(
)
;
}
set
twisty
(
aFlag
)
{
aFlag
?
this
.
showArrow
(
)
:
this
.
hideArrow
(
)
;
}
set
locked
(
aFlag
)
{
this
.
_isLocked
=
aFlag
;
}
get
focusable
(
)
{
if
(
!
this
.
_nameString
|
|
!
this
.
_isContentVisible
|
|
!
this
.
_isHeaderVisible
|
|
!
this
.
_isMatch
)
{
return
false
;
}
let
item
=
this
;
while
(
(
item
=
item
.
ownerView
)
&
&
item
instanceof
Scope
)
{
if
(
!
item
.
_isExpanded
)
{
return
false
;
}
}
return
true
;
}
focus
:
function
(
)
{
this
.
_variablesView
.
_focusItem
(
this
)
;
}
addEventListener
:
function
(
aName
aCallback
aCapture
)
{
this
.
_title
.
addEventListener
(
aName
aCallback
aCapture
)
;
}
removeEventListener
:
function
(
aName
aCallback
aCapture
)
{
this
.
_title
.
removeEventListener
(
aName
aCallback
aCapture
)
;
}
get
id
(
)
{
return
this
.
_idString
;
}
get
name
(
)
{
return
this
.
_nameString
;
}
get
displayValue
(
)
{
return
this
.
_valueString
;
}
get
displayValueClassName
(
)
{
return
this
.
_valueClassName
;
}
get
target
(
)
{
return
this
.
_target
;
}
_init
:
function
(
aName
aFlags
)
{
this
.
_idString
=
generateId
(
this
.
_nameString
=
aName
)
;
this
.
_displayScope
(
aName
{
this
.
targetClassName
}
{
aFlags
.
customClass
}
"
devtools
-
toolbar
"
)
;
this
.
_addEventListeners
(
)
;
this
.
parentNode
.
appendChild
(
this
.
_target
)
;
}
_displayScope
:
function
(
aName
=
"
"
aTargetClassName
aTitleClassName
=
"
"
)
{
const
document
=
this
.
document
;
const
element
=
this
.
_target
=
document
.
createXULElement
(
"
vbox
"
)
;
element
.
id
=
this
.
_idString
;
element
.
className
=
aTargetClassName
;
const
arrow
=
this
.
_arrow
=
document
.
createXULElement
(
"
hbox
"
)
;
arrow
.
className
=
"
arrow
theme
-
twisty
"
;
const
name
=
this
.
_name
=
document
.
createXULElement
(
"
label
"
)
;
name
.
className
=
"
plain
name
"
;
name
.
setAttribute
(
"
value
"
aName
.
trim
(
)
)
;
name
.
setAttribute
(
"
crop
"
"
end
"
)
;
const
title
=
this
.
_title
=
document
.
createXULElement
(
"
hbox
"
)
;
title
.
className
=
"
title
"
+
aTitleClassName
;
title
.
setAttribute
(
"
align
"
"
center
"
)
;
const
enumerable
=
this
.
_enum
=
document
.
createXULElement
(
"
vbox
"
)
;
const
nonenum
=
this
.
_nonenum
=
document
.
createXULElement
(
"
vbox
"
)
;
enumerable
.
className
=
"
variables
-
view
-
element
-
details
enum
"
;
nonenum
.
className
=
"
variables
-
view
-
element
-
details
nonenum
"
;
title
.
appendChild
(
arrow
)
;
title
.
appendChild
(
name
)
;
element
.
appendChild
(
title
)
;
element
.
appendChild
(
enumerable
)
;
element
.
appendChild
(
nonenum
)
;
}
_addEventListeners
:
function
(
)
{
this
.
_title
.
addEventListener
(
"
mousedown
"
this
.
_onClick
)
;
}
_onClick
:
function
(
e
)
{
if
(
this
.
editing
|
|
e
.
button
!
=
0
|
|
e
.
target
=
=
this
.
_editNode
|
|
e
.
target
=
=
this
.
_deleteNode
|
|
e
.
target
=
=
this
.
_addPropertyNode
)
{
return
;
}
this
.
toggle
(
)
;
this
.
focus
(
)
;
}
_openEnum
:
function
(
)
{
this
.
_arrow
.
setAttribute
(
"
open
"
"
"
)
;
this
.
_enum
.
setAttribute
(
"
open
"
"
"
)
;
}
_openNonEnum
:
function
(
)
{
this
.
_nonenum
.
setAttribute
(
"
open
"
"
"
)
;
}
set
_enumVisible
(
aFlag
)
{
for
(
const
[
variable
]
of
this
.
_store
)
{
variable
.
_enumVisible
=
aFlag
;
if
(
!
this
.
_isExpanded
)
{
continue
;
}
if
(
aFlag
)
{
this
.
_enum
.
setAttribute
(
"
open
"
"
"
)
;
}
else
{
this
.
_enum
.
removeAttribute
(
"
open
"
)
;
}
}
}
set
_nonEnumVisible
(
aFlag
)
{
for
(
const
[
variable
]
of
this
.
_store
)
{
variable
.
_nonEnumVisible
=
aFlag
;
if
(
!
this
.
_isExpanded
)
{
continue
;
}
if
(
aFlag
)
{
this
.
_nonenum
.
setAttribute
(
"
open
"
"
"
)
;
}
else
{
this
.
_nonenum
.
removeAttribute
(
"
open
"
)
;
}
}
}
_performSearch
:
function
(
aLowerCaseQuery
)
{
for
(
let
[
variable
]
of
this
.
_store
)
{
const
currentObject
=
variable
;
const
lowerCaseName
=
variable
.
_nameString
.
toLowerCase
(
)
;
const
lowerCaseValue
=
variable
.
_valueString
.
toLowerCase
(
)
;
if
(
!
lowerCaseName
.
includes
(
aLowerCaseQuery
)
&
&
!
lowerCaseValue
.
includes
(
aLowerCaseQuery
)
)
{
variable
.
_matched
=
false
;
}
else
{
variable
.
_matched
=
true
;
if
(
variable
.
_store
.
size
)
{
variable
.
expand
(
)
;
}
while
(
(
variable
=
variable
.
ownerView
)
&
&
variable
instanceof
Scope
)
{
variable
.
_matched
=
true
;
variable
.
expand
(
)
;
}
}
if
(
currentObject
.
_store
.
size
|
|
currentObject
.
getter
|
|
currentObject
.
setter
)
{
currentObject
.
_performSearch
(
aLowerCaseQuery
)
;
}
}
}
set
_matched
(
aStatus
)
{
if
(
this
.
_isMatch
=
=
aStatus
)
{
return
;
}
if
(
aStatus
)
{
this
.
_isMatch
=
true
;
this
.
target
.
removeAttribute
(
"
unmatched
"
)
;
}
else
{
this
.
_isMatch
=
false
;
this
.
target
.
setAttribute
(
"
unmatched
"
"
"
)
;
}
}
_findInVisibleItems
:
function
(
aPredicate
)
{
if
(
aPredicate
(
this
)
)
{
return
this
;
}
if
(
this
.
_isExpanded
)
{
if
(
this
.
_variablesView
.
_enumVisible
)
{
for
(
const
item
of
this
.
_enumItems
)
{
const
result
=
item
.
_findInVisibleItems
(
aPredicate
)
;
if
(
result
)
{
return
result
;
}
}
}
if
(
this
.
_variablesView
.
_nonEnumVisible
)
{
for
(
const
item
of
this
.
_nonEnumItems
)
{
const
result
=
item
.
_findInVisibleItems
(
aPredicate
)
;
if
(
result
)
{
return
result
;
}
}
}
}
return
null
;
}
_findInVisibleItemsReverse
:
function
(
aPredicate
)
{
if
(
this
.
_isExpanded
)
{
if
(
this
.
_variablesView
.
_nonEnumVisible
)
{
for
(
let
i
=
this
.
_nonEnumItems
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
item
=
this
.
_nonEnumItems
[
i
]
;
const
result
=
item
.
_findInVisibleItemsReverse
(
aPredicate
)
;
if
(
result
)
{
return
result
;
}
}
}
if
(
this
.
_variablesView
.
_enumVisible
)
{
for
(
let
i
=
this
.
_enumItems
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
item
=
this
.
_enumItems
[
i
]
;
const
result
=
item
.
_findInVisibleItemsReverse
(
aPredicate
)
;
if
(
result
)
{
return
result
;
}
}
}
}
if
(
aPredicate
(
this
)
)
{
return
this
;
}
return
null
;
}
get
_variablesView
(
)
{
return
this
.
_topView
|
|
(
this
.
_topView
=
(
(
)
=
>
{
let
parentView
=
this
.
ownerView
;
let
topView
;
while
(
(
topView
=
parentView
.
ownerView
)
)
{
parentView
=
topView
;
}
return
parentView
;
}
)
(
)
)
;
}
get
parentNode
(
)
{
return
this
.
ownerView
.
_list
;
}
get
document
(
)
{
return
this
.
_document
|
|
(
this
.
_document
=
this
.
ownerView
.
document
)
;
}
get
window
(
)
{
return
this
.
_window
|
|
(
this
.
_window
=
this
.
ownerView
.
window
)
;
}
_topView
:
null
_document
:
null
_window
:
null
ownerView
:
null
eval
:
null
switch
:
null
delete
:
null
new
:
null
preventDisableOnChange
:
false
preventDescriptorModifiers
:
false
editing
:
false
editableNameTooltip
:
"
"
editableValueTooltip
:
"
"
editButtonTooltip
:
"
"
deleteButtonTooltip
:
"
"
domNodeValueTooltip
:
"
"
contextMenuId
:
"
"
separatorStr
:
"
"
_store
:
null
_enumItems
:
null
_nonEnumItems
:
null
_fetched
:
false
_committed
:
false
_isLocked
:
false
_isExpanded
:
false
_isContentVisible
:
true
_isHeaderVisible
:
true
_isArrowVisible
:
true
_isMatch
:
true
_idString
:
"
"
_nameString
:
"
"
_target
:
null
_arrow
:
null
_name
:
null
_title
:
null
_enum
:
null
_nonenum
:
null
}
;
DevToolsUtils
.
defineLazyPrototypeGetter
(
Scope
.
prototype
"
_store
"
(
)
=
>
new
Map
(
)
)
;
DevToolsUtils
.
defineLazyPrototypeGetter
(
Scope
.
prototype
"
_enumItems
"
Array
)
;
DevToolsUtils
.
defineLazyPrototypeGetter
(
Scope
.
prototype
"
_nonEnumItems
"
Array
)
;
function
Variable
(
aScope
aName
aDescriptor
aOptions
)
{
this
.
_setTooltips
=
this
.
_setTooltips
.
bind
(
this
)
;
this
.
_activateNameInput
=
this
.
_activateNameInput
.
bind
(
this
)
;
this
.
_activateValueInput
=
this
.
_activateValueInput
.
bind
(
this
)
;
this
.
openNodeInInspector
=
this
.
openNodeInInspector
.
bind
(
this
)
;
this
.
highlightDomNode
=
this
.
highlightDomNode
.
bind
(
this
)
;
this
.
unhighlightDomNode
=
this
.
unhighlightDomNode
.
bind
(
this
)
;
this
.
_internalItem
=
aOptions
.
internalItem
;
if
(
"
getterValue
"
in
aDescriptor
)
{
aDescriptor
.
value
=
aDescriptor
.
getterValue
;
delete
aDescriptor
.
get
;
delete
aDescriptor
.
set
;
}
Scope
.
call
(
this
aScope
aName
this
.
_initialDescriptor
=
aDescriptor
)
;
this
.
setGrip
(
aDescriptor
.
value
)
;
}
Variable
.
prototype
=
extend
(
Scope
.
prototype
{
get
shouldPrefetch
(
)
{
return
this
.
name
=
=
"
window
"
|
|
this
.
name
=
=
"
this
"
;
}
get
allowPaginate
(
)
{
return
this
.
name
!
=
"
window
"
&
&
this
.
name
!
=
"
this
"
;
}
targetClassName
:
"
variables
-
view
-
variable
variable
-
or
-
property
"
_createChild
:
function
(
aName
aDescriptor
aOptions
)
{
return
new
Property
(
this
aName
aDescriptor
aOptions
)
;
}
remove
:
function
(
)
{
if
(
this
.
_linkedToInspector
)
{
this
.
unhighlightDomNode
(
)
;
this
.
_valueLabel
.
removeEventListener
(
"
mouseover
"
this
.
highlightDomNode
)
;
this
.
_valueLabel
.
removeEventListener
(
"
mouseout
"
this
.
unhighlightDomNode
)
;
this
.
_openInspectorNode
.
removeEventListener
(
"
mousedown
"
this
.
openNodeInInspector
)
;
}
this
.
ownerView
.
_store
.
delete
(
this
.
_nameString
)
;
this
.
_variablesView
.
_itemsByElement
.
delete
(
this
.
_target
)
;
this
.
_variablesView
.
_currHierarchy
.
delete
(
this
.
absoluteName
)
;
this
.
_target
.
remove
(
)
;
for
(
const
property
of
this
.
_store
.
values
(
)
)
{
property
.
remove
(
)
;
}
}
populate
:
function
(
aObject
aOptions
=
{
}
)
{
if
(
this
.
_fetched
)
{
return
;
}
this
.
_fetched
=
true
;
const
propertyNames
=
Object
.
getOwnPropertyNames
(
aObject
)
;
const
prototype
=
Object
.
getPrototypeOf
(
aObject
)
;
if
(
aOptions
.
sorted
)
{
propertyNames
.
sort
(
this
.
_naturalSort
)
;
}
for
(
const
name
of
propertyNames
)
{
const
descriptor
=
Object
.
getOwnPropertyDescriptor
(
aObject
name
)
;
if
(
descriptor
.
get
|
|
descriptor
.
set
)
{
const
prop
=
this
.
_addRawNonValueProperty
(
name
descriptor
)
;
if
(
aOptions
.
expanded
)
{
prop
.
expanded
=
true
;
}
}
else
{
const
prop
=
this
.
_addRawValueProperty
(
name
descriptor
aObject
[
name
]
)
;
if
(
aOptions
.
expanded
)
{
prop
.
expanded
=
true
;
}
}
}
if
(
prototype
)
{
this
.
_addRawValueProperty
(
"
__proto__
"
{
}
prototype
)
;
}
}
_populateTarget
:
function
(
aVar
aObject
=
aVar
.
_sourceValue
)
{
aVar
.
populate
(
aObject
)
;
}
_addRawValueProperty
:
function
(
aName
aDescriptor
aValue
)
{
const
descriptor
=
Object
.
create
(
aDescriptor
)
;
descriptor
.
value
=
VariablesView
.
getGrip
(
aValue
)
;
const
propertyItem
=
this
.
addItem
(
aName
descriptor
)
;
propertyItem
.
_sourceValue
=
aValue
;
if
(
!
VariablesView
.
isPrimitive
(
descriptor
)
)
{
propertyItem
.
onexpand
=
this
.
_populateTarget
;
}
return
propertyItem
;
}
_addRawNonValueProperty
:
function
(
aName
aDescriptor
)
{
const
descriptor
=
Object
.
create
(
aDescriptor
)
;
descriptor
.
get
=
VariablesView
.
getGrip
(
aDescriptor
.
get
)
;
descriptor
.
set
=
VariablesView
.
getGrip
(
aDescriptor
.
set
)
;
return
this
.
addItem
(
aName
descriptor
)
;
}
get
symbolicName
(
)
{
return
this
.
_nameString
|
|
"
"
;
}
get
absoluteName
(
)
{
if
(
this
.
_absoluteName
)
{
return
this
.
_absoluteName
;
}
this
.
_absoluteName
=
this
.
ownerView
.
_nameString
+
"
[
"
+
escapeString
(
this
.
_nameString
)
+
"
]
"
;
return
this
.
_absoluteName
;
}
get
symbolicPath
(
)
{
if
(
this
.
_symbolicPath
)
{
return
this
.
_symbolicPath
;
}
this
.
_symbolicPath
=
this
.
_buildSymbolicPath
(
)
;
return
this
.
_symbolicPath
;
}
_buildSymbolicPath
:
function
(
path
=
[
]
)
{
if
(
this
.
name
)
{
path
.
unshift
(
this
.
name
)
;
if
(
this
.
ownerView
instanceof
Variable
)
{
return
this
.
ownerView
.
_buildSymbolicPath
(
path
)
;
}
}
return
path
;
}
get
value
(
)
{
return
this
.
_initialDescriptor
.
value
;
}
get
getter
(
)
{
return
this
.
_initialDescriptor
.
get
;
}
get
setter
(
)
{
return
this
.
_initialDescriptor
.
set
;
}
setGrip
:
function
(
aGrip
)
{
if
(
this
.
_nameString
=
=
=
undefined
|
|
aGrip
=
=
=
undefined
|
|
aGrip
=
=
=
null
)
{
return
;
}
if
(
this
.
getter
|
|
this
.
setter
)
{
return
;
}
const
prevGrip
=
this
.
_valueGrip
;
if
(
prevGrip
)
{
this
.
_valueLabel
.
classList
.
remove
(
VariablesView
.
getClass
(
prevGrip
)
)
;
}
this
.
_valueGrip
=
aGrip
;
if
(
aGrip
&
&
(
aGrip
.
optimizedOut
|
|
aGrip
.
uninitialized
|
|
aGrip
.
missingArguments
)
)
{
if
(
aGrip
.
optimizedOut
)
{
this
.
_valueString
=
L10N
.
getStr
(
"
variablesViewOptimizedOut
"
)
;
}
else
if
(
aGrip
.
uninitialized
)
{
this
.
_valueString
=
L10N
.
getStr
(
"
variablesViewUninitialized
"
)
;
}
else
if
(
aGrip
.
missingArguments
)
{
this
.
_valueString
=
L10N
.
getStr
(
"
variablesViewMissingArgs
"
)
;
}
this
.
eval
=
null
;
}
else
{
this
.
_valueString
=
VariablesView
.
getString
(
aGrip
{
concise
:
true
noEllipsis
:
true
}
)
;
this
.
eval
=
this
.
ownerView
.
eval
;
}
this
.
_valueClassName
=
VariablesView
.
getClass
(
aGrip
)
;
this
.
_valueLabel
.
classList
.
add
(
this
.
_valueClassName
)
;
this
.
_valueLabel
.
setAttribute
(
"
value
"
this
.
_valueString
)
;
this
.
_separatorLabel
.
hidden
=
false
;
if
(
this
.
_valueGrip
.
preview
&
&
this
.
_valueGrip
.
preview
.
kind
=
=
=
"
DOMNode
"
)
{
this
.
_linkToInspector
(
)
;
}
}
setOverridden
:
function
(
aFlag
)
{
if
(
aFlag
)
{
this
.
_target
.
setAttribute
(
"
overridden
"
"
"
)
;
}
else
{
this
.
_target
.
removeAttribute
(
"
overridden
"
)
;
}
}
flash
:
function
(
aDuration
=
ITEM_FLASH_DURATION
)
{
const
fadeInDelay
=
this
.
_variablesView
.
lazyEmptyDelay
+
1
;
const
fadeOutDelay
=
fadeInDelay
+
aDuration
;
setNamedTimeout
(
"
vview
-
flash
-
in
"
+
this
.
absoluteName
fadeInDelay
(
)
=
>
this
.
_target
.
setAttribute
(
"
changed
"
"
"
)
)
;
setNamedTimeout
(
"
vview
-
flash
-
out
"
+
this
.
absoluteName
fadeOutDelay
(
)
=
>
this
.
_target
.
removeAttribute
(
"
changed
"
)
)
;
}
_init
:
function
(
aName
aDescriptor
)
{
this
.
_idString
=
generateId
(
this
.
_nameString
=
aName
)
;
this
.
_displayScope
(
aName
this
.
targetClassName
)
;
this
.
_displayVariable
(
)
;
this
.
_customizeVariable
(
)
;
this
.
_prepareTooltips
(
)
;
this
.
_setAttributes
(
)
;
this
.
_addEventListeners
(
)
;
if
(
this
.
_initialDescriptor
.
enumerable
|
|
this
.
_nameString
=
=
"
this
"
|
|
this
.
_internalItem
)
{
this
.
ownerView
.
_enum
.
appendChild
(
this
.
_target
)
;
this
.
ownerView
.
_enumItems
.
push
(
this
)
;
}
else
{
this
.
ownerView
.
_nonenum
.
appendChild
(
this
.
_target
)
;
this
.
ownerView
.
_nonEnumItems
.
push
(
this
)
;
}
}
_displayVariable
:
function
(
)
{
const
document
=
this
.
document
;
const
descriptor
=
this
.
_initialDescriptor
;
const
separatorLabel
=
this
.
_separatorLabel
=
document
.
createXULElement
(
"
label
"
)
;
separatorLabel
.
className
=
"
plain
separator
"
;
separatorLabel
.
setAttribute
(
"
value
"
this
.
separatorStr
+
"
"
)
;
const
valueLabel
=
this
.
_valueLabel
=
document
.
createXULElement
(
"
label
"
)
;
valueLabel
.
className
=
"
plain
value
"
;
valueLabel
.
setAttribute
(
"
flex
"
"
1
"
)
;
valueLabel
.
setAttribute
(
"
crop
"
"
center
"
)
;
this
.
_title
.
appendChild
(
separatorLabel
)
;
this
.
_title
.
appendChild
(
valueLabel
)
;
if
(
VariablesView
.
isPrimitive
(
descriptor
)
)
{
this
.
hideArrow
(
)
;
}
if
(
!
descriptor
.
get
&
&
!
descriptor
.
set
&
&
!
(
"
value
"
in
descriptor
)
)
{
separatorLabel
.
hidden
=
true
;
}
if
(
descriptor
.
get
|
|
descriptor
.
set
)
{
separatorLabel
.
hidden
=
true
;
valueLabel
.
hidden
=
true
;
this
.
switch
=
null
;
if
(
this
.
ownerView
.
eval
)
{
this
.
delete
=
VariablesView
.
getterOrSetterDeleteCallback
;
this
.
evaluationMacro
=
VariablesView
.
overrideValueEvalMacro
;
}
else
{
this
.
delete
=
null
;
this
.
evaluationMacro
=
null
;
}
const
getter
=
this
.
addItem
(
"
get
"
{
value
:
descriptor
.
get
}
)
;
const
setter
=
this
.
addItem
(
"
set
"
{
value
:
descriptor
.
set
}
)
;
getter
.
evaluationMacro
=
VariablesView
.
getterOrSetterEvalMacro
;
setter
.
evaluationMacro
=
VariablesView
.
getterOrSetterEvalMacro
;
getter
.
hideArrow
(
)
;
setter
.
hideArrow
(
)
;
this
.
expand
(
)
;
}
}
_customizeVariable
:
function
(
)
{
const
ownerView
=
this
.
ownerView
;
const
descriptor
=
this
.
_initialDescriptor
;
if
(
ownerView
.
eval
&
&
this
.
getter
|
|
this
.
setter
)
{
const
editNode
=
this
.
_editNode
=
this
.
document
.
createXULElement
(
"
toolbarbutton
"
)
;
editNode
.
className
=
"
plain
variables
-
view
-
edit
"
;
editNode
.
addEventListener
(
"
mousedown
"
this
.
_onEdit
.
bind
(
this
)
)
;
this
.
_title
.
insertBefore
(
editNode
this
.
_spacer
)
;
}
if
(
ownerView
.
delete
)
{
const
deleteNode
=
this
.
_deleteNode
=
this
.
document
.
createXULElement
(
"
toolbarbutton
"
)
;
deleteNode
.
className
=
"
plain
variables
-
view
-
delete
"
;
deleteNode
.
addEventListener
(
"
click
"
this
.
_onDelete
.
bind
(
this
)
)
;
this
.
_title
.
appendChild
(
deleteNode
)
;
}
if
(
ownerView
.
new
)
{
const
addPropertyNode
=
this
.
_addPropertyNode
=
this
.
document
.
createXULElement
(
"
toolbarbutton
"
)
;
addPropertyNode
.
className
=
"
plain
variables
-
view
-
add
-
property
"
;
addPropertyNode
.
addEventListener
(
"
mousedown
"
this
.
_onAddProperty
.
bind
(
this
)
)
;
this
.
_title
.
appendChild
(
addPropertyNode
)
;
if
(
VariablesView
.
isPrimitive
(
descriptor
)
)
{
addPropertyNode
.
setAttribute
(
"
invisible
"
"
"
)
;
}
}
if
(
ownerView
.
contextMenuId
)
{
this
.
_title
.
setAttribute
(
"
context
"
ownerView
.
contextMenuId
)
;
}
if
(
ownerView
.
preventDescriptorModifiers
)
{
return
;
}
if
(
!
descriptor
.
writable
&
&
!
ownerView
.
getter
&
&
!
ownerView
.
setter
)
{
const
nonWritableIcon
=
this
.
document
.
createXULElement
(
"
hbox
"
)
;
nonWritableIcon
.
className
=
"
plain
variable
-
or
-
property
-
non
-
writable
-
icon
"
;
nonWritableIcon
.
setAttribute
(
"
optional
-
visibility
"
"
"
)
;
this
.
_title
.
appendChild
(
nonWritableIcon
)
;
}
if
(
descriptor
.
value
&
&
typeof
descriptor
.
value
=
=
"
object
"
)
{
if
(
descriptor
.
value
.
frozen
)
{
const
frozenLabel
=
this
.
document
.
createXULElement
(
"
label
"
)
;
frozenLabel
.
className
=
"
plain
variable
-
or
-
property
-
frozen
-
label
"
;
frozenLabel
.
setAttribute
(
"
optional
-
visibility
"
"
"
)
;
frozenLabel
.
setAttribute
(
"
value
"
"
F
"
)
;
this
.
_title
.
appendChild
(
frozenLabel
)
;
}
if
(
descriptor
.
value
.
sealed
)
{
const
sealedLabel
=
this
.
document
.
createXULElement
(
"
label
"
)
;
sealedLabel
.
className
=
"
plain
variable
-
or
-
property
-
sealed
-
label
"
;
sealedLabel
.
setAttribute
(
"
optional
-
visibility
"
"
"
)
;
sealedLabel
.
setAttribute
(
"
value
"
"
S
"
)
;
this
.
_title
.
appendChild
(
sealedLabel
)
;
}
if
(
!
descriptor
.
value
.
extensible
)
{
const
nonExtensibleLabel
=
this
.
document
.
createXULElement
(
"
label
"
)
;
nonExtensibleLabel
.
className
=
"
plain
variable
-
or
-
property
-
non
-
extensible
-
label
"
;
nonExtensibleLabel
.
setAttribute
(
"
optional
-
visibility
"
"
"
)
;
nonExtensibleLabel
.
setAttribute
(
"
value
"
"
N
"
)
;
this
.
_title
.
appendChild
(
nonExtensibleLabel
)
;
}
}
}
_prepareTooltips
:
function
(
)
{
this
.
_target
.
addEventListener
(
"
mouseover
"
this
.
_setTooltips
)
;
}
_setTooltips
:
function
(
)
{
this
.
_target
.
removeEventListener
(
"
mouseover
"
this
.
_setTooltips
)
;
const
ownerView
=
this
.
ownerView
;
if
(
ownerView
.
preventDescriptorModifiers
)
{
return
;
}
const
tooltip
=
this
.
document
.
createXULElement
(
"
tooltip
"
)
;
tooltip
.
id
=
"
tooltip
-
"
+
this
.
_idString
;
tooltip
.
setAttribute
(
"
orient
"
"
horizontal
"
)
;
const
labels
=
[
"
configurable
"
"
enumerable
"
"
writable
"
"
frozen
"
"
sealed
"
"
extensible
"
"
overridden
"
"
WebIDL
"
]
;
for
(
const
type
of
labels
)
{
const
labelElement
=
this
.
document
.
createXULElement
(
"
label
"
)
;
labelElement
.
className
=
type
;
labelElement
.
setAttribute
(
"
value
"
L10N
.
getStr
(
type
+
"
Tooltip
"
)
)
;
tooltip
.
appendChild
(
labelElement
)
;
}
this
.
_target
.
appendChild
(
tooltip
)
;
this
.
_target
.
setAttribute
(
"
tooltip
"
tooltip
.
id
)
;
if
(
this
.
_editNode
&
&
ownerView
.
eval
)
{
this
.
_editNode
.
setAttribute
(
"
tooltiptext
"
ownerView
.
editButtonTooltip
)
;
}
if
(
this
.
_openInspectorNode
&
&
this
.
_linkedToInspector
)
{
this
.
_openInspectorNode
.
setAttribute
(
"
tooltiptext
"
this
.
ownerView
.
domNodeValueTooltip
)
;
}
if
(
this
.
_valueLabel
&
&
ownerView
.
eval
)
{
this
.
_valueLabel
.
setAttribute
(
"
tooltiptext
"
ownerView
.
editableValueTooltip
)
;
}
if
(
this
.
_name
&
&
ownerView
.
switch
)
{
this
.
_name
.
setAttribute
(
"
tooltiptext
"
ownerView
.
editableNameTooltip
)
;
}
if
(
this
.
_deleteNode
&
&
ownerView
.
delete
)
{
this
.
_deleteNode
.
setAttribute
(
"
tooltiptext
"
ownerView
.
deleteButtonTooltip
)
;
}
}
get
toolbox
(
)
{
return
this
.
_variablesView
.
toolbox
;
}
_isLinkableToInspector
:
function
(
)
{
const
isDomNode
=
this
.
_valueGrip
&
&
this
.
_valueGrip
.
preview
.
kind
=
=
=
"
DOMNode
"
;
const
hasBeenLinked
=
this
.
_linkedToInspector
;
const
hasToolbox
=
!
!
this
.
toolbox
;
return
isDomNode
&
&
!
hasBeenLinked
&
&
hasToolbox
;
}
_linkToInspector
:
function
(
)
{
if
(
!
this
.
_isLinkableToInspector
(
)
)
{
return
;
}
this
.
_valueLabel
.
addEventListener
(
"
mouseover
"
this
.
highlightDomNode
)
;
this
.
_valueLabel
.
addEventListener
(
"
mouseout
"
this
.
unhighlightDomNode
)
;
this
.
_openInspectorNode
=
this
.
document
.
createXULElement
(
"
toolbarbutton
"
)
;
this
.
_openInspectorNode
.
className
=
"
plain
variables
-
view
-
open
-
inspector
"
;
this
.
_openInspectorNode
.
addEventListener
(
"
mousedown
"
this
.
openNodeInInspector
)
;
this
.
_title
.
appendChild
(
this
.
_openInspectorNode
)
;
this
.
_linkedToInspector
=
true
;
}
openNodeInInspector
:
function
(
event
)
{
if
(
!
this
.
toolbox
)
{
return
promise
.
reject
(
new
Error
(
"
Toolbox
not
available
"
)
)
;
}
event
&
&
event
.
stopPropagation
(
)
;
return
(
async
function
(
)
{
await
this
.
toolbox
.
initInspector
(
)
;
let
nodeFront
=
this
.
_nodeFront
;
if
(
!
nodeFront
)
{
nodeFront
=
await
this
.
toolbox
.
walker
.
getNodeActorFromObjectActor
(
this
.
_valueGrip
.
actor
)
;
}
if
(
nodeFront
)
{
await
this
.
toolbox
.
selectTool
(
"
inspector
"
)
;
const
inspectorReady
=
defer
(
)
;
this
.
toolbox
.
getPanel
(
"
inspector
"
)
.
once
(
"
inspector
-
updated
"
inspectorReady
.
resolve
)
;
await
this
.
toolbox
.
selection
.
setNodeFront
(
nodeFront
{
reason
:
"
variables
-
view
"
}
)
;
await
inspectorReady
.
promise
;
}
}
.
bind
(
this
)
)
(
)
;
}
highlightDomNode
:
function
(
)
{
if
(
this
.
toolbox
)
{
if
(
this
.
_nodeFront
)
{
this
.
toolbox
.
highlighterUtils
.
highlightNodeFront
(
this
.
_nodeFront
)
;
return
;
}
this
.
toolbox
.
highlighterUtils
.
highlightDomValueGrip
(
this
.
_valueGrip
)
.
then
(
front
=
>
{
this
.
_nodeFront
=
front
;
}
)
;
}
}
unhighlightDomNode
:
function
(
)
{
if
(
this
.
toolbox
)
{
this
.
toolbox
.
highlighterUtils
.
unhighlight
(
)
;
}
}
_setAttributes
:
function
(
)
{
const
ownerView
=
this
.
ownerView
;
if
(
ownerView
.
preventDescriptorModifiers
)
{
return
;
}
const
descriptor
=
this
.
_initialDescriptor
;
const
target
=
this
.
_target
;
const
name
=
this
.
_nameString
;
if
(
ownerView
.
eval
)
{
target
.
setAttribute
(
"
editable
"
"
"
)
;
}
if
(
!
descriptor
.
configurable
)
{
target
.
setAttribute
(
"
non
-
configurable
"
"
"
)
;
}
if
(
!
descriptor
.
enumerable
)
{
target
.
setAttribute
(
"
non
-
enumerable
"
"
"
)
;
}
if
(
!
descriptor
.
writable
&
&
!
ownerView
.
getter
&
&
!
ownerView
.
setter
)
{
target
.
setAttribute
(
"
non
-
writable
"
"
"
)
;
}
if
(
descriptor
.
value
&
&
typeof
descriptor
.
value
=
=
"
object
"
)
{
if
(
descriptor
.
value
.
frozen
)
{
target
.
setAttribute
(
"
frozen
"
"
"
)
;
}
if
(
descriptor
.
value
.
sealed
)
{
target
.
setAttribute
(
"
sealed
"
"
"
)
;
}
if
(
!
descriptor
.
value
.
extensible
)
{
target
.
setAttribute
(
"
non
-
extensible
"
"
"
)
;
}
}
if
(
descriptor
&
&
"
getterValue
"
in
descriptor
)
{
target
.
setAttribute
(
"
safe
-
getter
"
"
"
)
;
}
if
(
name
=
=
"
this
"
)
{
target
.
setAttribute
(
"
self
"
"
"
)
;
}
else
if
(
this
.
_internalItem
&
&
name
=
=
"
<
exception
>
"
)
{
target
.
setAttribute
(
"
exception
"
"
"
)
;
target
.
setAttribute
(
"
pseudo
-
item
"
"
"
)
;
}
else
if
(
this
.
_internalItem
&
&
name
=
=
"
<
return
>
"
)
{
target
.
setAttribute
(
"
return
"
"
"
)
;
target
.
setAttribute
(
"
pseudo
-
item
"
"
"
)
;
}
else
if
(
name
=
=
"
__proto__
"
)
{
target
.
setAttribute
(
"
proto
"
"
"
)
;
target
.
setAttribute
(
"
pseudo
-
item
"
"
"
)
;
}
if
(
Object
.
keys
(
descriptor
)
.
length
=
=
0
)
{
target
.
setAttribute
(
"
pseudo
-
item
"
"
"
)
;
}
}
_addEventListeners
:
function
(
)
{
this
.
_name
.
addEventListener
(
"
dblclick
"
this
.
_activateNameInput
)
;
this
.
_valueLabel
.
addEventListener
(
"
mousedown
"
this
.
_activateValueInput
)
;
this
.
_title
.
addEventListener
(
"
mousedown
"
this
.
_onClick
)
;
}
_activateNameInput
:
function
(
e
)
{
if
(
!
this
.
_variablesView
.
alignedValues
)
{
this
.
_separatorLabel
.
hidden
=
true
;
this
.
_valueLabel
.
hidden
=
true
;
}
EditableName
.
create
(
this
{
onSave
:
aKey
=
>
{
if
(
!
this
.
_variablesView
.
preventDisableOnChange
)
{
this
.
_disable
(
)
;
}
this
.
ownerView
.
switch
(
this
aKey
)
;
}
onCleanup
:
(
)
=
>
{
if
(
!
this
.
_variablesView
.
alignedValues
)
{
this
.
_separatorLabel
.
hidden
=
false
;
this
.
_valueLabel
.
hidden
=
false
;
}
}
}
e
)
;
}
_activateValueInput
:
function
(
e
)
{
EditableValue
.
create
(
this
{
onSave
:
aString
=
>
{
if
(
this
.
_linkedToInspector
)
{
this
.
unhighlightDomNode
(
)
;
}
if
(
!
this
.
_variablesView
.
preventDisableOnChange
)
{
this
.
_disable
(
)
;
}
this
.
ownerView
.
eval
(
this
aString
)
;
}
}
e
)
;
}
_disable
:
function
(
)
{
this
.
hideArrow
(
)
;
for
(
const
node
of
this
.
_title
.
childNodes
)
{
node
.
hidden
=
node
!
=
this
.
_arrow
&
&
node
!
=
this
.
_name
;
}
this
.
_enum
.
hidden
=
true
;
this
.
_nonenum
.
hidden
=
true
;
}
evaluationMacro
:
VariablesView
.
simpleValueEvalMacro
_onEdit
:
function
(
e
)
{
if
(
e
.
button
!
=
0
)
{
return
;
}
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
this
.
_activateValueInput
(
)
;
}
_onDelete
:
function
(
e
)
{
if
(
"
button
"
in
e
&
&
e
.
button
!
=
0
)
{
return
;
}
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
this
.
ownerView
.
delete
)
{
if
(
!
this
.
ownerView
.
delete
(
this
)
)
{
this
.
hide
(
)
;
}
}
}
_onAddProperty
:
function
(
e
)
{
if
(
"
button
"
in
e
&
&
e
.
button
!
=
0
)
{
return
;
}
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
this
.
expanded
=
true
;
const
item
=
this
.
addItem
(
"
"
{
value
:
undefined
configurable
:
true
enumerable
:
true
writable
:
true
}
{
relaxed
:
true
}
)
;
item
.
_separatorLabel
.
hidden
=
false
;
EditableNameAndValue
.
create
(
item
{
onSave
:
(
[
aKey
aValue
]
)
=
>
{
if
(
!
this
.
_variablesView
.
preventDisableOnChange
)
{
this
.
_disable
(
)
;
}
this
.
ownerView
.
new
(
this
aKey
aValue
)
;
}
}
e
)
;
}
_symbolicName
:
null
_symbolicPath
:
null
_absoluteName
:
null
_initialDescriptor
:
null
_separatorLabel
:
null
_valueLabel
:
null
_spacer
:
null
_editNode
:
null
_deleteNode
:
null
_addPropertyNode
:
null
_tooltip
:
null
_valueGrip
:
null
_valueString
:
"
"
_valueClassName
:
"
"
_prevExpandable
:
false
_prevExpanded
:
false
}
)
;
function
Property
(
aVar
aName
aDescriptor
aOptions
)
{
Variable
.
call
(
this
aVar
aName
aDescriptor
aOptions
)
;
}
Property
.
prototype
=
extend
(
Variable
.
prototype
{
targetClassName
:
"
variables
-
view
-
property
variable
-
or
-
property
"
get
symbolicName
(
)
{
if
(
this
.
_symbolicName
)
{
return
this
.
_symbolicName
;
}
this
.
_symbolicName
=
this
.
ownerView
.
symbolicName
+
"
[
"
+
escapeString
(
this
.
_nameString
)
+
"
]
"
;
return
this
.
_symbolicName
;
}
get
absoluteName
(
)
{
if
(
this
.
_absoluteName
)
{
return
this
.
_absoluteName
;
}
this
.
_absoluteName
=
this
.
ownerView
.
absoluteName
+
"
[
"
+
escapeString
(
this
.
_nameString
)
+
"
]
"
;
return
this
.
_absoluteName
;
}
}
)
;
VariablesView
.
prototype
[
Symbol
.
iterator
]
=
Scope
.
prototype
[
Symbol
.
iterator
]
=
Variable
.
prototype
[
Symbol
.
iterator
]
=
Property
.
prototype
[
Symbol
.
iterator
]
=
function
*
(
)
{
yield
*
this
.
_store
;
}
;
VariablesView
.
prototype
.
clearHierarchy
=
function
(
)
{
this
.
_prevHierarchy
.
clear
(
)
;
this
.
_currHierarchy
.
clear
(
)
;
}
;
VariablesView
.
prototype
.
commitHierarchy
=
function
(
)
{
for
(
const
[
currItem
]
of
this
.
_currHierarchy
)
{
if
(
this
.
commitHierarchyIgnoredItems
[
currItem
.
_nameString
]
)
{
continue
;
}
const
overridden
=
this
.
isOverridden
(
currItem
)
;
if
(
overridden
)
{
currItem
.
setOverridden
(
true
)
;
}
const
expanded
=
!
currItem
.
_committed
&
&
this
.
wasExpanded
(
currItem
)
;
if
(
expanded
)
{
currItem
.
expand
(
)
;
}
const
changed
=
!
currItem
.
_committed
&
&
this
.
hasChanged
(
currItem
)
;
if
(
changed
)
{
currItem
.
flash
(
)
;
}
currItem
.
_committed
=
true
;
}
if
(
this
.
oncommit
)
{
this
.
oncommit
(
this
)
;
}
}
;
VariablesView
.
prototype
.
commitHierarchyIgnoredItems
=
extend
(
null
{
"
window
"
:
true
"
this
"
:
true
}
)
;
VariablesView
.
prototype
.
wasExpanded
=
function
(
aItem
)
{
if
(
!
(
aItem
instanceof
Scope
)
)
{
return
false
;
}
const
prevItem
=
this
.
_prevHierarchy
.
get
(
aItem
.
absoluteName
|
|
aItem
.
_nameString
)
;
return
prevItem
?
prevItem
.
_isExpanded
:
false
;
}
;
VariablesView
.
prototype
.
hasChanged
=
function
(
aItem
)
{
if
(
!
(
aItem
instanceof
Variable
)
)
{
return
false
;
}
const
prevItem
=
this
.
_prevHierarchy
.
get
(
aItem
.
absoluteName
)
;
return
prevItem
?
prevItem
.
_valueString
!
=
aItem
.
_valueString
:
false
;
}
;
VariablesView
.
prototype
.
isOverridden
=
function
(
aItem
)
{
if
(
!
(
aItem
instanceof
Variable
)
|
|
aItem
instanceof
Property
)
{
return
false
;
}
const
currVariableName
=
aItem
.
_nameString
;
const
parentScopes
=
this
.
getParentScopesForVariableOrProperty
(
aItem
)
;
for
(
const
otherScope
of
parentScopes
)
{
for
(
const
[
otherVariableName
]
of
otherScope
)
{
if
(
otherVariableName
=
=
currVariableName
)
{
return
true
;
}
}
}
return
false
;
}
;
VariablesView
.
isPrimitive
=
function
(
aDescriptor
)
{
const
getter
=
aDescriptor
.
get
;
const
setter
=
aDescriptor
.
set
;
if
(
getter
|
|
setter
)
{
return
false
;
}
const
grip
=
aDescriptor
.
value
;
if
(
typeof
grip
!
=
"
object
"
)
{
return
true
;
}
const
type
=
grip
.
type
;
if
(
type
=
=
"
undefined
"
|
|
type
=
=
"
null
"
|
|
type
=
=
"
Infinity
"
|
|
type
=
=
"
-
Infinity
"
|
|
type
=
=
"
NaN
"
|
|
type
=
=
"
-
0
"
|
|
type
=
=
"
symbol
"
|
|
type
=
=
"
longString
"
)
{
return
true
;
}
return
false
;
}
;
VariablesView
.
isUndefined
=
function
(
aDescriptor
)
{
const
getter
=
aDescriptor
.
get
;
const
setter
=
aDescriptor
.
set
;
if
(
typeof
getter
=
=
"
object
"
&
&
getter
.
type
=
=
"
undefined
"
&
&
typeof
setter
=
=
"
object
"
&
&
setter
.
type
=
=
"
undefined
"
)
{
return
true
;
}
const
grip
=
aDescriptor
.
value
;
if
(
typeof
grip
=
=
"
object
"
&
&
grip
.
type
=
=
"
undefined
"
)
{
return
true
;
}
return
false
;
}
;
VariablesView
.
isFalsy
=
function
(
aDescriptor
)
{
const
grip
=
aDescriptor
.
value
;
if
(
typeof
grip
!
=
"
object
"
)
{
return
!
grip
;
}
const
type
=
grip
.
type
;
if
(
type
=
=
"
undefined
"
|
|
type
=
=
"
null
"
|
|
type
=
=
"
NaN
"
|
|
type
=
=
"
-
0
"
)
{
return
true
;
}
return
false
;
}
;
VariablesView
.
isVariable
=
function
(
aValue
)
{
return
aValue
instanceof
Variable
;
}
;
VariablesView
.
getGrip
=
function
(
aValue
)
{
switch
(
typeof
aValue
)
{
case
"
boolean
"
:
case
"
string
"
:
return
aValue
;
case
"
number
"
:
if
(
aValue
=
=
=
Infinity
)
{
return
{
type
:
"
Infinity
"
}
;
}
else
if
(
aValue
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
Infinity
"
}
;
}
else
if
(
Number
.
isNaN
(
aValue
)
)
{
return
{
type
:
"
NaN
"
}
;
}
else
if
(
1
/
aValue
=
=
=
-
Infinity
)
{
return
{
type
:
"
-
0
"
}
;
}
return
aValue
;
case
"
undefined
"
:
if
(
aValue
=
=
=
undefined
)
{
return
{
type
:
"
undefined
"
}
;
}
case
"
object
"
:
if
(
aValue
=
=
=
null
)
{
return
{
type
:
"
null
"
}
;
}
case
"
function
"
:
return
{
type
:
"
object
"
class
:
WebConsoleUtils
.
getObjectClassName
(
aValue
)
}
;
default
:
console
.
error
(
"
Failed
to
provide
a
grip
for
value
of
"
+
typeof
value
+
"
:
"
+
aValue
)
;
return
null
;
}
}
;
VariablesView
.
getString
=
function
(
aGrip
aOptions
=
{
}
)
{
if
(
aGrip
&
&
typeof
aGrip
=
=
"
object
"
)
{
switch
(
aGrip
.
type
)
{
case
"
undefined
"
:
case
"
null
"
:
case
"
NaN
"
:
case
"
Infinity
"
:
case
"
-
Infinity
"
:
case
"
-
0
"
:
return
aGrip
.
type
;
default
:
const
stringifier
=
VariablesView
.
stringifiers
.
byType
[
aGrip
.
type
]
;
if
(
stringifier
)
{
const
result
=
stringifier
(
aGrip
aOptions
)
;
if
(
result
!
=
null
)
{
return
result
;
}
}
if
(
aGrip
.
displayString
)
{
return
VariablesView
.
getString
(
aGrip
.
displayString
aOptions
)
;
}
if
(
aGrip
.
type
=
=
"
object
"
&
&
aOptions
.
concise
)
{
return
aGrip
.
class
;
}
return
"
[
"
+
aGrip
.
type
+
"
"
+
aGrip
.
class
+
"
]
"
;
}
}
switch
(
typeof
aGrip
)
{
case
"
string
"
:
return
VariablesView
.
stringifiers
.
byType
.
string
(
aGrip
aOptions
)
;
case
"
boolean
"
:
return
aGrip
?
"
true
"
:
"
false
"
;
case
"
number
"
:
if
(
!
aGrip
&
&
1
/
aGrip
=
=
=
-
Infinity
)
{
return
"
-
0
"
;
}
default
:
return
aGrip
+
"
"
;
}
}
;
VariablesView
.
stringifiers
=
{
}
;
VariablesView
.
stringifiers
.
byType
=
{
string
:
function
(
aGrip
{
noStringQuotes
}
)
{
if
(
noStringQuotes
)
{
return
aGrip
;
}
return
'
"
'
+
aGrip
+
'
"
'
;
}
longString
:
function
(
{
initial
}
{
noStringQuotes
noEllipsis
}
)
{
const
ellipsis
=
noEllipsis
?
"
"
:
ELLIPSIS
;
if
(
noStringQuotes
)
{
return
initial
+
ellipsis
;
}
const
result
=
'
"
'
+
initial
+
'
"
'
;
if
(
!
ellipsis
)
{
return
result
;
}
return
result
.
substr
(
0
result
.
length
-
1
)
+
ellipsis
+
'
"
'
;
}
object
:
function
(
aGrip
aOptions
)
{
const
{
preview
}
=
aGrip
;
let
stringifier
;
if
(
aGrip
.
class
)
{
stringifier
=
VariablesView
.
stringifiers
.
byObjectClass
[
aGrip
.
class
]
;
}
if
(
!
stringifier
&
&
preview
&
&
preview
.
kind
)
{
stringifier
=
VariablesView
.
stringifiers
.
byObjectKind
[
preview
.
kind
]
;
}
if
(
stringifier
)
{
return
stringifier
(
aGrip
aOptions
)
;
}
return
null
;
}
symbol
:
function
(
aGrip
aOptions
)
{
const
name
=
aGrip
.
name
|
|
"
"
;
return
"
Symbol
(
"
+
name
+
"
)
"
;
}
mapEntry
:
function
(
aGrip
{
concise
}
)
{
const
{
preview
:
{
key
value
}
}
=
aGrip
;
const
keyString
=
VariablesView
.
getString
(
key
{
concise
:
true
noStringQuotes
:
true
}
)
;
const
valueString
=
VariablesView
.
getString
(
value
{
concise
:
true
}
)
;
return
keyString
+
"
\
u2192
"
+
valueString
;
}
}
;
VariablesView
.
stringifiers
.
byObjectClass
=
{
Function
:
function
(
aGrip
{
concise
}
)
{
let
name
=
aGrip
.
userDisplayName
|
|
aGrip
.
displayName
|
|
aGrip
.
name
|
|
"
"
;
name
=
VariablesView
.
getString
(
name
{
noStringQuotes
:
true
}
)
;
const
params
=
aGrip
.
parameterNames
|
|
"
"
;
if
(
!
concise
)
{
return
"
function
"
+
name
+
"
(
"
+
params
+
"
)
"
;
}
return
(
name
|
|
"
function
"
)
+
"
(
"
+
params
+
"
)
"
;
}
RegExp
:
function
(
{
displayString
}
)
{
return
VariablesView
.
getString
(
displayString
{
noStringQuotes
:
true
}
)
;
}
Date
:
function
(
{
preview
}
)
{
if
(
!
preview
|
|
!
(
"
timestamp
"
in
preview
)
)
{
return
null
;
}
if
(
typeof
preview
.
timestamp
!
=
"
number
"
)
{
return
new
Date
(
preview
.
timestamp
)
.
toString
(
)
;
}
return
"
Date
"
+
new
Date
(
preview
.
timestamp
)
.
toISOString
(
)
;
}
Number
:
function
(
aGrip
)
{
const
{
preview
}
=
aGrip
;
if
(
preview
=
=
=
undefined
)
{
return
null
;
}
return
aGrip
.
class
+
"
{
"
+
VariablesView
.
getString
(
preview
.
wrappedValue
)
+
"
}
"
;
}
}
;
VariablesView
.
stringifiers
.
byObjectClass
.
Boolean
=
VariablesView
.
stringifiers
.
byObjectClass
.
Number
;
VariablesView
.
stringifiers
.
byObjectKind
=
{
ArrayLike
:
function
(
aGrip
{
concise
}
)
{
const
{
preview
}
=
aGrip
;
if
(
concise
)
{
return
aGrip
.
class
+
"
[
"
+
preview
.
length
+
"
]
"
;
}
if
(
!
preview
.
items
)
{
return
null
;
}
let
shown
=
0
lastHole
=
null
;
const
result
=
[
]
;
for
(
const
item
of
preview
.
items
)
{
if
(
item
=
=
=
null
)
{
if
(
lastHole
!
=
=
null
)
{
result
[
lastHole
]
+
=
"
"
;
}
else
{
result
.
push
(
"
"
)
;
}
lastHole
=
result
.
length
-
1
;
}
else
{
lastHole
=
null
;
result
.
push
(
VariablesView
.
getString
(
item
{
concise
:
true
}
)
)
;
}
shown
+
+
;
}
if
(
shown
<
preview
.
length
)
{
const
n
=
preview
.
length
-
shown
;
result
.
push
(
VariablesView
.
stringifiers
.
_getNMoreString
(
n
)
)
;
}
else
if
(
lastHole
!
=
=
null
)
{
result
[
lastHole
]
+
=
"
"
;
}
const
prefix
=
aGrip
.
class
=
=
"
Array
"
?
"
"
:
aGrip
.
class
+
"
"
;
return
prefix
+
"
[
"
+
result
.
join
(
"
"
)
+
"
]
"
;
}
MapLike
:
function
(
aGrip
{
concise
}
)
{
const
{
preview
}
=
aGrip
;
if
(
concise
|
|
!
preview
.
entries
)
{
const
size
=
typeof
preview
.
size
=
=
"
number
"
?
"
[
"
+
preview
.
size
+
"
]
"
:
"
"
;
return
aGrip
.
class
+
size
;
}
const
entries
=
[
]
;
for
(
const
[
key
value
]
of
preview
.
entries
)
{
const
keyString
=
VariablesView
.
getString
(
key
{
concise
:
true
noStringQuotes
:
true
}
)
;
const
valueString
=
VariablesView
.
getString
(
value
{
concise
:
true
}
)
;
entries
.
push
(
keyString
+
"
:
"
+
valueString
)
;
}
if
(
typeof
preview
.
size
=
=
"
number
"
&
&
preview
.
size
>
entries
.
length
)
{
const
n
=
preview
.
size
-
entries
.
length
;
entries
.
push
(
VariablesView
.
stringifiers
.
_getNMoreString
(
n
)
)
;
}
return
aGrip
.
class
+
"
{
"
+
entries
.
join
(
"
"
)
+
"
}
"
;
}
ObjectWithText
:
function
(
aGrip
{
concise
}
)
{
if
(
concise
)
{
return
aGrip
.
class
;
}
return
aGrip
.
class
+
"
"
+
VariablesView
.
getString
(
aGrip
.
preview
.
text
)
;
}
ObjectWithURL
:
function
(
aGrip
{
concise
}
)
{
let
result
=
aGrip
.
class
;
const
url
=
aGrip
.
preview
.
url
;
if
(
!
VariablesView
.
isFalsy
(
{
value
:
url
}
)
)
{
result
+
=
\
u2192
{
getSourceNames
(
url
)
[
concise
?
"
short
"
:
"
long
"
]
}
;
}
return
result
;
}
Object
:
function
(
aGrip
{
concise
}
)
{
if
(
concise
)
{
return
aGrip
.
class
;
}
const
{
preview
}
=
aGrip
;
const
props
=
[
]
;
if
(
aGrip
.
class
=
=
"
Promise
"
&
&
aGrip
.
promiseState
)
{
const
{
state
value
reason
}
=
aGrip
.
promiseState
;
props
.
push
(
"
<
state
>
:
"
+
VariablesView
.
getString
(
state
)
)
;
if
(
state
=
=
"
fulfilled
"
)
{
props
.
push
(
"
<
value
>
:
"
+
VariablesView
.
getString
(
value
{
concise
:
true
}
)
)
;
}
else
if
(
state
=
=
"
rejected
"
)
{
props
.
push
(
"
<
reason
>
:
"
+
VariablesView
.
getString
(
reason
{
concise
:
true
}
)
)
;
}
}
for
(
const
key
of
Object
.
keys
(
preview
.
ownProperties
|
|
{
}
)
)
{
const
value
=
preview
.
ownProperties
[
key
]
;
let
valueString
=
"
"
;
if
(
value
.
get
)
{
valueString
=
"
Getter
"
;
}
else
if
(
value
.
set
)
{
valueString
=
"
Setter
"
;
}
else
{
valueString
=
VariablesView
.
getString
(
value
.
value
{
concise
:
true
}
)
;
}
props
.
push
(
key
+
"
:
"
+
valueString
)
;
}
for
(
const
key
of
Object
.
keys
(
preview
.
safeGetterValues
|
|
{
}
)
)
{
const
value
=
preview
.
safeGetterValues
[
key
]
;
const
valueString
=
VariablesView
.
getString
(
value
.
getterValue
{
concise
:
true
}
)
;
props
.
push
(
key
+
"
:
"
+
valueString
)
;
}
if
(
!
props
.
length
)
{
return
null
;
}
if
(
preview
.
ownPropertiesLength
)
{
const
previewLength
=
Object
.
keys
(
preview
.
ownProperties
)
.
length
;
const
diff
=
preview
.
ownPropertiesLength
-
previewLength
;
if
(
diff
>
0
)
{
props
.
push
(
VariablesView
.
stringifiers
.
_getNMoreString
(
diff
)
)
;
}
}
const
prefix
=
aGrip
.
class
!
=
"
Object
"
?
aGrip
.
class
+
"
"
:
"
"
;
return
prefix
+
"
{
"
+
props
.
join
(
"
"
)
+
"
}
"
;
}
Error
:
function
(
aGrip
{
concise
}
)
{
const
{
preview
}
=
aGrip
;
const
name
=
VariablesView
.
getString
(
preview
.
name
{
noStringQuotes
:
true
}
)
;
if
(
concise
)
{
return
name
|
|
aGrip
.
class
;
}
let
msg
=
name
+
"
:
"
+
VariablesView
.
getString
(
preview
.
message
{
noStringQuotes
:
true
}
)
;
if
(
!
VariablesView
.
isFalsy
(
{
value
:
preview
.
stack
}
)
)
{
msg
+
=
"
\
n
"
+
L10N
.
getStr
(
"
variablesViewErrorStacktrace
"
)
+
"
\
n
"
+
preview
.
stack
;
}
return
msg
;
}
DOMException
:
function
(
aGrip
{
concise
}
)
{
const
{
preview
}
=
aGrip
;
if
(
concise
)
{
return
preview
.
name
|
|
aGrip
.
class
;
}
let
msg
=
aGrip
.
class
+
"
[
"
+
preview
.
name
+
"
:
"
+
VariablesView
.
getString
(
preview
.
message
)
+
"
\
n
"
+
"
code
:
"
+
preview
.
code
+
"
\
n
"
+
"
nsresult
:
0x
"
+
(
+
preview
.
result
)
.
toString
(
16
)
;
if
(
preview
.
filename
)
{
msg
+
=
"
\
nlocation
:
"
+
preview
.
filename
;
if
(
preview
.
lineNumber
)
{
msg
+
=
"
:
"
+
preview
.
lineNumber
;
}
}
return
msg
+
"
]
"
;
}
DOMEvent
:
function
(
aGrip
{
concise
}
)
{
const
{
preview
}
=
aGrip
;
if
(
!
preview
.
type
)
{
return
null
;
}
if
(
concise
)
{
return
aGrip
.
class
+
"
"
+
preview
.
type
;
}
let
result
=
preview
.
type
;
if
(
preview
.
eventKind
=
=
"
key
"
&
&
preview
.
modifiers
&
&
preview
.
modifiers
.
length
)
{
result
+
=
"
"
+
preview
.
modifiers
.
join
(
"
-
"
)
;
}
const
props
=
[
]
;
if
(
preview
.
target
)
{
const
target
=
VariablesView
.
getString
(
preview
.
target
{
concise
:
true
}
)
;
props
.
push
(
"
target
:
"
+
target
)
;
}
for
(
const
prop
in
preview
.
properties
)
{
const
value
=
preview
.
properties
[
prop
]
;
props
.
push
(
prop
+
"
:
"
+
VariablesView
.
getString
(
value
{
concise
:
true
}
)
)
;
}
return
result
+
"
{
"
+
props
.
join
(
"
"
)
+
"
}
"
;
}
DOMNode
:
function
(
aGrip
{
concise
}
)
{
const
{
preview
}
=
aGrip
;
switch
(
preview
.
nodeType
)
{
case
nodeConstants
.
DOCUMENT_NODE
:
{
let
result
=
aGrip
.
class
;
if
(
preview
.
location
)
{
result
+
=
\
u2192
{
getSourceNames
(
preview
.
location
)
[
concise
?
"
short
"
:
"
long
"
]
}
;
}
return
result
;
}
case
nodeConstants
.
ATTRIBUTE_NODE
:
{
const
value
=
VariablesView
.
getString
(
preview
.
value
{
noStringQuotes
:
true
}
)
;
return
preview
.
nodeName
+
'
=
"
'
+
escapeHTML
(
value
)
+
'
"
'
;
}
case
nodeConstants
.
TEXT_NODE
:
return
preview
.
nodeName
+
"
"
+
VariablesView
.
getString
(
preview
.
textContent
)
;
case
nodeConstants
.
COMMENT_NODE
:
{
const
comment
=
VariablesView
.
getString
(
preview
.
textContent
{
noStringQuotes
:
true
}
)
;
return
"
<
!
-
-
"
+
comment
+
"
-
-
>
"
;
}
case
nodeConstants
.
DOCUMENT_FRAGMENT_NODE
:
{
if
(
concise
|
|
!
preview
.
childNodes
)
{
return
aGrip
.
class
+
"
[
"
+
preview
.
childNodesLength
+
"
]
"
;
}
const
nodes
=
[
]
;
for
(
const
node
of
preview
.
childNodes
)
{
nodes
.
push
(
VariablesView
.
getString
(
node
)
)
;
}
if
(
nodes
.
length
<
preview
.
childNodesLength
)
{
const
n
=
preview
.
childNodesLength
-
nodes
.
length
;
nodes
.
push
(
VariablesView
.
stringifiers
.
_getNMoreString
(
n
)
)
;
}
return
aGrip
.
class
+
"
[
"
+
nodes
.
join
(
"
"
)
+
"
]
"
;
}
case
nodeConstants
.
ELEMENT_NODE
:
{
const
attrs
=
preview
.
attributes
;
if
(
!
concise
)
{
let
n
=
0
result
=
"
<
"
+
preview
.
nodeName
;
for
(
const
name
in
attrs
)
{
const
value
=
VariablesView
.
getString
(
attrs
[
name
]
{
noStringQuotes
:
true
}
)
;
result
+
=
"
"
+
name
+
'
=
"
'
+
escapeHTML
(
value
)
+
'
"
'
;
n
+
+
;
}
if
(
preview
.
attributesLength
>
n
)
{
result
+
=
"
"
+
ELLIPSIS
;
}
return
result
+
"
>
"
;
}
let
result
=
"
<
"
+
preview
.
nodeName
;
if
(
attrs
.
id
)
{
result
+
=
"
#
"
+
attrs
.
id
;
}
if
(
attrs
.
class
)
{
result
+
=
"
.
"
+
attrs
.
class
.
trim
(
)
.
replace
(
/
\
s
+
/
"
.
"
)
;
}
return
result
+
"
>
"
;
}
default
:
return
null
;
}
}
}
;
VariablesView
.
stringifiers
.
_getNMoreString
=
function
(
aNumber
)
{
const
str
=
L10N
.
getStr
(
"
variablesViewMoreObjects
"
)
;
return
PluralForm
.
get
(
aNumber
str
)
.
replace
(
"
#
1
"
aNumber
)
;
}
;
VariablesView
.
getClass
=
function
(
aGrip
)
{
if
(
aGrip
&
&
typeof
aGrip
=
=
"
object
"
)
{
if
(
aGrip
.
preview
)
{
switch
(
aGrip
.
preview
.
kind
)
{
case
"
DOMNode
"
:
return
"
token
-
domnode
"
;
}
}
switch
(
aGrip
.
type
)
{
case
"
undefined
"
:
return
"
token
-
undefined
"
;
case
"
null
"
:
return
"
token
-
null
"
;
case
"
Infinity
"
:
case
"
-
Infinity
"
:
case
"
NaN
"
:
case
"
-
0
"
:
return
"
token
-
number
"
;
case
"
longString
"
:
return
"
token
-
string
"
;
}
}
switch
(
typeof
aGrip
)
{
case
"
string
"
:
return
"
token
-
string
"
;
case
"
boolean
"
:
return
"
token
-
boolean
"
;
case
"
number
"
:
return
"
token
-
number
"
;
default
:
return
"
token
-
other
"
;
}
}
;
var
generateId
=
(
function
(
)
{
let
count
=
0
;
return
function
(
aName
=
"
"
)
{
return
aName
.
toLowerCase
(
)
.
trim
(
)
.
replace
(
/
\
s
+
/
g
"
-
"
)
+
(
+
+
count
)
;
}
;
}
)
(
)
;
function
escapeString
(
aString
)
{
if
(
typeof
aString
!
=
=
"
string
"
)
{
return
"
"
;
}
return
JSON
.
stringify
(
aString
)
.
replace
(
/
\
u2028
/
g
"
\
\
u2028
"
)
.
replace
(
/
\
u2029
/
g
"
\
\
u2029
"
)
;
}
function
escapeHTML
(
aString
)
{
return
aString
.
replace
(
/
&
/
g
"
&
amp
;
"
)
.
replace
(
/
"
/
g
"
&
quot
;
"
)
.
replace
(
/
<
/
g
"
&
lt
;
"
)
.
replace
(
/
>
/
g
"
&
gt
;
"
)
;
}
function
Editable
(
aVariable
aOptions
)
{
this
.
_variable
=
aVariable
;
this
.
_onSave
=
aOptions
.
onSave
;
this
.
_onCleanup
=
aOptions
.
onCleanup
;
}
Editable
.
create
=
function
(
aVariable
aOptions
aEvent
)
{
const
editable
=
new
this
(
aVariable
aOptions
)
;
editable
.
activate
(
aEvent
)
;
return
editable
;
}
;
Editable
.
prototype
=
{
className
:
null
shouldActivate
:
null
label
:
null
activate
:
function
(
e
)
{
if
(
!
this
.
shouldActivate
)
{
this
.
_onCleanup
&
&
this
.
_onCleanup
(
)
;
return
;
}
const
{
label
}
=
this
;
const
initialString
=
label
.
getAttribute
(
"
value
"
)
;
if
(
e
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
const
input
=
this
.
_input
=
this
.
_variable
.
document
.
createXULElement
(
"
textbox
"
)
;
input
.
className
=
"
plain
"
+
this
.
className
;
input
.
setAttribute
(
"
value
"
initialString
)
;
input
.
setAttribute
(
"
flex
"
"
1
"
)
;
label
.
parentNode
.
replaceChild
(
input
label
)
;
this
.
_variable
.
_variablesView
.
_list
.
ensureElementIsVisible
(
input
)
;
input
.
select
(
)
;
if
(
initialString
.
match
(
/
^
"
.
+
"
/
)
)
{
input
.
selectionEnd
-
-
;
input
.
selectionStart
+
+
;
}
this
.
_onKeydown
=
this
.
_onKeydown
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
input
.
addEventListener
(
"
keydown
"
this
.
_onKeydown
)
;
input
.
addEventListener
(
"
blur
"
this
.
_onBlur
)
;
this
.
_prevExpandable
=
this
.
_variable
.
twisty
;
this
.
_prevExpanded
=
this
.
_variable
.
expanded
;
this
.
_variable
.
collapse
(
)
;
this
.
_variable
.
hideArrow
(
)
;
this
.
_variable
.
locked
=
true
;
this
.
_variable
.
editing
=
true
;
}
deactivate
:
function
(
)
{
this
.
_input
.
removeEventListener
(
"
keydown
"
this
.
_onKeydown
)
;
this
.
_input
.
removeEventListener
(
"
blur
"
this
.
deactivate
)
;
this
.
_input
.
parentNode
.
replaceChild
(
this
.
label
this
.
_input
)
;
this
.
_input
=
null
;
const
scrollbox
=
this
.
_variable
.
_variablesView
.
_list
;
scrollbox
.
scrollBy
(
-
this
.
_variable
.
_target
0
)
;
this
.
_variable
.
locked
=
false
;
this
.
_variable
.
twisty
=
this
.
_prevExpandable
;
this
.
_variable
.
expanded
=
this
.
_prevExpanded
;
this
.
_variable
.
editing
=
false
;
this
.
_onCleanup
&
&
this
.
_onCleanup
(
)
;
}
_save
:
function
(
)
{
const
initial
=
this
.
label
.
getAttribute
(
"
value
"
)
;
const
current
=
this
.
_input
.
value
.
trim
(
)
;
this
.
deactivate
(
)
;
if
(
initial
!
=
current
)
{
this
.
_onSave
(
current
)
;
}
}
_next
:
function
(
)
{
this
.
_save
(
)
;
}
_reset
:
function
(
)
{
this
.
deactivate
(
)
;
this
.
_variable
.
focus
(
)
;
}
_onBlur
:
function
(
)
{
this
.
deactivate
(
)
;
}
_onKeydown
:
function
(
e
)
{
e
.
stopPropagation
(
)
;
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_TAB
:
this
.
_next
(
)
;
break
;
case
KeyCodes
.
DOM_VK_RETURN
:
this
.
_save
(
)
;
break
;
case
KeyCodes
.
DOM_VK_ESCAPE
:
this
.
_reset
(
)
;
break
;
}
}
}
;
function
EditableName
(
aVariable
aOptions
)
{
Editable
.
call
(
this
aVariable
aOptions
)
;
}
EditableName
.
create
=
Editable
.
create
;
EditableName
.
prototype
=
extend
(
Editable
.
prototype
{
className
:
"
element
-
name
-
input
"
get
label
(
)
{
return
this
.
_variable
.
_name
;
}
get
shouldActivate
(
)
{
return
!
!
this
.
_variable
.
ownerView
.
switch
;
}
}
)
;
function
EditableValue
(
aVariable
aOptions
)
{
Editable
.
call
(
this
aVariable
aOptions
)
;
}
EditableValue
.
create
=
Editable
.
create
;
EditableValue
.
prototype
=
extend
(
Editable
.
prototype
{
className
:
"
element
-
value
-
input
"
get
label
(
)
{
return
this
.
_variable
.
_valueLabel
;
}
get
shouldActivate
(
)
{
return
!
!
this
.
_variable
.
ownerView
.
eval
;
}
}
)
;
function
EditableNameAndValue
(
aVariable
aOptions
)
{
EditableName
.
call
(
this
aVariable
aOptions
)
;
}
EditableNameAndValue
.
create
=
Editable
.
create
;
EditableNameAndValue
.
prototype
=
extend
(
EditableName
.
prototype
{
_reset
:
function
(
e
)
{
this
.
_variable
.
remove
(
)
;
this
.
deactivate
(
)
;
}
_next
:
function
(
e
)
{
const
key
=
this
.
_input
.
value
;
this
.
label
.
setAttribute
(
"
value
"
key
)
;
const
valueEditable
=
EditableValue
.
create
(
this
.
_variable
{
onSave
:
aValue
=
>
{
this
.
_onSave
(
[
key
aValue
]
)
;
}
}
)
;
valueEditable
.
_reset
=
(
)
=
>
{
this
.
_variable
.
remove
(
)
;
valueEditable
.
deactivate
(
)
;
}
;
}
_save
:
function
(
e
)
{
this
.
_next
(
e
)
;
}
}
)
;
