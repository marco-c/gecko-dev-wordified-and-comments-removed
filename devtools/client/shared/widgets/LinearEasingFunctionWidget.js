"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
{
throttle
}
=
require
(
"
devtools
/
shared
/
throttle
"
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
SVG_NS
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
const
numberFormatter
=
new
Intl
.
NumberFormat
(
"
en
"
{
maximumFractionDigits
:
3
}
)
;
const
percentFormatter
=
new
Intl
.
NumberFormat
(
"
en
"
{
maximumFractionDigits
:
2
style
:
"
percent
"
}
)
;
class
LinearEasingFunctionWidget
extends
EventEmitter
{
constructor
(
parent
)
{
super
(
)
;
this
.
parent
=
parent
;
this
.
#
initMarkup
(
)
;
this
.
#
svgEl
.
addEventListener
(
"
mousedown
"
this
.
#
onMouseDown
.
bind
(
this
)
{
signal
:
this
.
#
abortController
.
signal
}
)
;
this
.
#
svgEl
.
addEventListener
(
"
dblclick
"
this
.
#
onDoubleClick
.
bind
(
this
)
{
signal
:
this
.
#
abortController
.
signal
}
)
;
this
.
#
reducedMotion
=
parent
.
ownerGlobal
.
matchMedia
(
"
(
prefers
-
reduced
-
motion
)
"
)
;
if
(
!
this
.
#
reducedMotion
.
matches
)
{
this
.
#
timingPreview
=
new
TimingFunctionPreviewWidget
(
this
.
#
wrapperEl
)
;
}
this
.
#
reducedMotion
.
addEventListener
(
"
change
"
event
=
>
{
if
(
event
.
matches
)
{
if
(
this
.
#
timingPreview
)
{
this
.
#
timingPreview
.
destroy
(
)
;
}
this
.
#
timingPreview
=
undefined
;
}
else
if
(
!
this
.
#
timingPreview
)
{
this
.
#
timingPreview
=
new
TimingFunctionPreviewWidget
(
this
.
#
wrapperEl
)
;
}
}
{
signal
:
this
.
#
abortController
.
signal
}
)
;
}
static
CONTROL_POINTS_CLASSNAME
=
"
control
-
point
"
;
#
abortController
=
new
AbortController
(
)
;
#
functionPoints
;
#
reducedMotion
;
#
timingPreview
;
#
draggedEl
=
null
;
#
dragAbortController
;
#
wrapperEl
;
#
svgEl
;
#
linearLineEl
;
#
controlPointGroupEl
;
#
initMarkup
(
)
{
const
doc
=
this
.
parent
.
ownerDocument
;
const
wrap
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
wrap
.
className
=
"
display
-
wrap
"
;
this
.
#
wrapperEl
=
wrap
;
const
svg
=
doc
.
createElementNS
(
SVG_NS
"
svg
"
)
;
svg
.
classList
.
add
(
"
chart
"
)
;
const
padding
=
0
.
1
;
const
length
=
1
+
padding
*
2
;
svg
.
setAttribute
(
"
viewBox
"
{
0
-
padding
}
{
0
-
padding
}
{
length
}
{
length
}
)
;
const
chartGrid
=
doc
.
createElementNS
(
SVG_NS
"
g
"
)
;
chartGrid
.
setAttribute
(
"
stroke
-
width
"
"
0
.
005
"
)
;
chartGrid
.
classList
.
add
(
"
chart
-
grid
"
)
;
for
(
let
i
=
0
;
i
<
=
10
;
i
+
+
)
{
const
value
=
i
/
10
;
const
hLine
=
doc
.
createElementNS
(
SVG_NS
"
line
"
)
;
hLine
.
setAttribute
(
"
x1
"
0
)
;
hLine
.
setAttribute
(
"
y1
"
value
)
;
hLine
.
setAttribute
(
"
x2
"
1
)
;
hLine
.
setAttribute
(
"
y2
"
value
)
;
const
vLine
=
doc
.
createElementNS
(
SVG_NS
"
line
"
)
;
vLine
.
setAttribute
(
"
x1
"
value
)
;
vLine
.
setAttribute
(
"
y1
"
0
)
;
vLine
.
setAttribute
(
"
x2
"
value
)
;
vLine
.
setAttribute
(
"
y2
"
1
)
;
chartGrid
.
append
(
hLine
vLine
)
;
}
const
linearLine
=
doc
.
createElementNS
(
SVG_NS
"
polyline
"
)
;
linearLine
.
classList
.
add
(
"
chart
-
linear
"
)
;
linearLine
.
setAttribute
(
"
fill
"
"
none
"
)
;
linearLine
.
setAttribute
(
"
stroke
"
"
context
-
stroke
black
"
)
;
linearLine
.
setAttribute
(
"
stroke
-
width
"
"
0
.
01
"
)
;
const
controlPointGroup
=
doc
.
createElementNS
(
SVG_NS
"
g
"
)
;
controlPointGroup
.
classList
.
add
(
"
control
-
points
-
group
"
)
;
this
.
#
linearLineEl
=
linearLine
;
this
.
#
svgEl
=
svg
;
this
.
#
controlPointGroupEl
=
controlPointGroup
;
svg
.
append
(
chartGrid
linearLine
controlPointGroup
)
;
wrap
.
append
(
svg
)
;
this
.
parent
.
append
(
wrap
)
;
}
#
removeMarkup
(
)
{
this
.
#
wrapperEl
.
remove
(
)
;
}
#
onMouseDown
(
event
)
{
if
(
!
event
.
target
.
classList
.
contains
(
LinearEasingFunctionWidget
.
CONTROL_POINTS_CLASSNAME
)
)
{
return
;
}
this
.
#
draggedEl
=
event
.
target
;
this
.
#
draggedEl
.
setPointerCapture
(
event
.
pointerId
)
;
this
.
#
dragAbortController
=
new
AbortController
(
)
;
this
.
#
draggedEl
.
addEventListener
(
"
mousemove
"
this
.
#
onMouseMove
.
bind
(
this
)
{
signal
:
this
.
#
dragAbortController
.
signal
}
)
;
this
.
#
draggedEl
.
addEventListener
(
"
mouseup
"
this
.
#
onMouseUp
.
bind
(
this
)
{
signal
:
this
.
#
dragAbortController
.
signal
}
)
;
}
#
onMouseMove
=
throttle
(
event
=
>
{
if
(
!
this
.
#
draggedEl
)
{
return
;
}
const
{
x
y
}
=
this
.
#
getPositionInSvgFromEvent
(
event
)
;
let
cx
=
clamp
(
0
1
x
)
;
let
cy
=
clamp
(
0
1
y
)
;
if
(
this
.
#
draggedEl
.
previousSibling
)
{
cx
=
Math
.
max
(
cx
parseFloat
(
this
.
#
draggedEl
.
previousSibling
.
getAttribute
(
"
cx
"
)
)
)
;
}
if
(
this
.
#
draggedEl
.
nextSibling
)
{
cx
=
Math
.
min
(
cx
parseFloat
(
this
.
#
draggedEl
.
nextSibling
.
getAttribute
(
"
cx
"
)
)
)
;
}
if
(
event
.
shiftKey
)
{
cx
=
Math
.
round
(
cx
*
10
)
/
10
;
cy
=
Math
.
round
(
cy
*
10
)
/
10
;
}
this
.
#
draggedEl
.
setAttribute
(
"
cx
"
cx
)
;
this
.
#
draggedEl
.
setAttribute
(
"
cy
"
cy
)
;
this
.
#
updateFunctionPointsFromControlPoints
(
)
;
this
.
#
redrawLineFromFunctionPoints
(
)
;
this
.
emit
(
"
updated
"
this
.
getCssLinearValue
(
)
)
;
}
20
)
;
#
onMouseUp
(
event
)
{
this
.
#
draggedEl
.
releasePointerCapture
(
event
.
pointerId
)
;
this
.
#
draggedEl
=
null
;
this
.
#
dragAbortController
.
abort
(
)
;
this
.
#
dragAbortController
=
null
;
}
#
onDoubleClick
(
event
)
{
const
existingPoints
=
Array
.
from
(
this
.
#
controlPointGroupEl
.
querySelectorAll
(
.
{
LinearEasingFunctionWidget
.
CONTROL_POINTS_CLASSNAME
}
)
)
;
if
(
event
.
target
.
classList
.
contains
(
LinearEasingFunctionWidget
.
CONTROL_POINTS_CLASSNAME
)
)
{
if
(
existingPoints
.
length
<
=
2
)
{
return
;
}
event
.
target
.
remove
(
)
;
this
.
#
updateFunctionPointsFromControlPoints
(
)
;
this
.
#
redrawFromFunctionPoints
(
)
;
}
else
{
let
{
x
y
}
=
this
.
#
getPositionInSvgFromEvent
(
event
)
;
if
(
event
.
shiftKey
)
{
x
=
clamp
(
0
1
Math
.
round
(
x
*
10
)
/
10
)
;
y
=
clamp
(
0
1
Math
.
round
(
y
*
10
)
/
10
)
;
}
const
nextSibling
=
existingPoints
.
find
(
el
=
>
parseFloat
(
el
.
getAttribute
(
"
cx
"
)
)
>
=
x
)
;
this
.
#
controlPointGroupEl
.
insertBefore
(
this
.
#
createSvgControlPointEl
(
x
y
)
nextSibling
)
;
this
.
#
updateFunctionPointsFromControlPoints
(
)
;
this
.
#
redrawLineFromFunctionPoints
(
)
;
}
}
#
updateFunctionPointsFromControlPoints
(
)
{
this
.
#
functionPoints
=
Array
.
from
(
this
.
#
controlPointGroupEl
.
querySelectorAll
(
.
{
LinearEasingFunctionWidget
.
CONTROL_POINTS_CLASSNAME
}
)
)
.
map
(
el
=
>
{
const
input
=
parseFloat
(
el
.
getAttribute
(
"
cx
"
)
)
;
const
output
=
1
-
parseFloat
(
el
.
getAttribute
(
"
cy
"
)
)
;
return
{
input
output
}
;
}
)
;
}
#
redrawFromFunctionPoints
(
)
{
this
.
#
controlPointGroupEl
.
querySelectorAll
(
.
{
LinearEasingFunctionWidget
.
CONTROL_POINTS_CLASSNAME
}
)
.
forEach
(
el
=
>
el
.
remove
(
)
)
;
if
(
this
.
#
functionPoints
)
{
this
.
#
functionPoints
.
forEach
(
(
{
input
output
}
)
=
>
{
this
.
#
controlPointGroupEl
.
append
(
this
.
#
createSvgControlPointEl
(
input
1
-
output
)
)
;
}
)
;
}
this
.
#
redrawLineFromFunctionPoints
(
)
;
}
#
redrawLineFromFunctionPoints
(
)
{
this
.
#
linearLineEl
.
setAttribute
(
"
points
"
(
this
.
#
functionPoints
|
|
[
]
)
.
map
(
(
{
input
output
}
)
=
>
{
input
}
{
1
-
output
}
)
.
join
(
"
"
)
)
;
const
cssLinearValue
=
this
.
getCssLinearValue
(
)
;
if
(
this
.
#
timingPreview
)
{
this
.
#
timingPreview
.
preview
(
cssLinearValue
)
;
}
this
.
emit
(
"
updated
"
cssLinearValue
)
;
}
#
createSvgControlPointEl
(
cx
cy
)
{
const
controlEl
=
this
.
parent
.
ownerDocument
.
createElementNS
(
SVG_NS
"
circle
"
)
;
controlEl
.
classList
.
add
(
"
control
-
point
"
)
;
controlEl
.
setAttribute
(
"
cx
"
cx
)
;
controlEl
.
setAttribute
(
"
cy
"
cy
)
;
controlEl
.
setAttribute
(
"
r
"
0
.
025
)
;
controlEl
.
setAttribute
(
"
fill
"
"
context
-
fill
"
)
;
controlEl
.
setAttribute
(
"
stroke
-
width
"
0
)
;
return
controlEl
;
}
#
getPositionInSvgFromEvent
(
event
)
{
const
position
=
this
.
#
svgEl
.
createSVGPoint
(
)
;
position
.
x
=
event
.
clientX
;
position
.
y
=
event
.
clientY
;
const
matrix
=
this
.
#
svgEl
.
getScreenCTM
(
)
;
const
inverseSvgMatrix
=
matrix
.
inverse
(
)
;
const
transformedPosition
=
position
.
matrixTransform
(
inverseSvgMatrix
)
;
return
{
x
:
transformedPosition
.
x
y
:
transformedPosition
.
y
}
;
}
setCssLinearValue
(
linearFunctionValue
)
{
if
(
!
linearFunctionValue
)
{
return
;
}
const
points
=
parseTimingFunction
(
linearFunctionValue
)
;
this
.
#
functionPoints
=
points
;
this
.
#
redrawFromFunctionPoints
(
)
;
}
getCssLinearValue
(
)
{
if
(
!
this
.
#
functionPoints
)
{
return
null
;
}
return
linear
(
{
this
.
#
functionPoints
.
map
(
(
{
input
output
}
)
=
>
{
numberFormatter
.
format
(
output
)
}
{
percentFormatter
.
format
(
input
)
}
)
.
join
(
"
"
)
}
)
;
}
destroy
(
)
{
this
.
#
abortController
.
abort
(
)
;
this
.
#
dragAbortController
?
.
abort
(
)
;
this
.
#
removeMarkup
(
)
;
this
.
#
reducedMotion
=
null
;
if
(
this
.
#
timingPreview
)
{
this
.
#
timingPreview
.
destroy
(
)
;
this
.
#
timingPreview
=
null
;
}
}
}
exports
.
LinearEasingFunctionWidget
=
LinearEasingFunctionWidget
;
class
TimingFunctionPreviewWidget
{
constructor
(
parent
)
{
this
.
#
initMarkup
(
parent
)
;
}
#
PREVIEW_DURATION
=
1000
;
#
dotEl
;
#
previousValue
;
#
initMarkup
(
parent
)
{
const
doc
=
parent
.
ownerDocument
;
const
container
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
container
.
className
=
"
timing
-
function
-
preview
"
;
this
.
#
dotEl
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
this
.
#
dotEl
.
className
=
"
dot
"
;
container
.
appendChild
(
this
.
#
dotEl
)
;
parent
.
appendChild
(
container
)
;
}
destroy
(
)
{
this
.
#
dotEl
.
getAnimations
(
)
.
forEach
(
anim
=
>
anim
.
cancel
(
)
)
;
this
.
#
dotEl
.
parentElement
.
remove
(
)
;
}
preview
(
timingFunction
)
{
if
(
this
.
#
previousValue
=
=
timingFunction
)
{
return
;
}
this
.
#
restartAnimation
(
timingFunction
)
;
this
.
#
previousValue
=
timingFunction
;
}
#
restartAnimation
=
throttle
(
timingFunction
=
>
{
this
.
#
dotEl
.
getAnimations
(
)
.
forEach
(
anim
=
>
anim
.
cancel
(
)
)
;
this
.
#
dotEl
.
animate
(
[
{
translate
:
"
0
%
"
opacity
:
0
.
5
offset
:
0
}
{
translate
:
"
0
%
"
opacity
:
0
.
5
offset
:
0
.
19
}
{
translate
:
"
0
%
"
opacity
:
1
offset
:
0
.
2
easing
:
timingFunction
}
{
translate
:
"
100
%
"
opacity
:
1
offset
:
0
.
5
}
{
translate
:
"
100
%
"
opacity
:
0
.
5
offset
:
0
.
51
}
{
translate
:
"
100
%
"
opacity
:
0
.
5
offset
:
0
.
7
}
{
translate
:
"
100
%
"
opacity
:
1
offset
:
0
.
71
easing
:
timingFunction
}
{
translate
:
"
0
%
"
opacity
:
1
offset
:
1
}
]
{
duration
:
this
.
#
PREVIEW_DURATION
*
2
iterations
:
Infinity
}
)
;
}
250
)
;
}
function
parseTimingFunction
(
value
)
{
value
=
value
.
trim
(
)
;
const
tokenStream
=
getCSSLexer
(
value
true
)
;
const
getNextToken
=
(
)
=
>
{
while
(
true
)
{
const
token
=
tokenStream
.
nextToken
(
)
;
if
(
!
token
|
|
(
token
.
tokenType
!
=
=
"
WhiteSpace
"
&
&
token
.
tokenType
!
=
=
"
Comment
"
)
)
{
return
token
;
}
}
}
;
let
token
=
getNextToken
(
)
;
if
(
!
token
|
|
token
.
tokenType
!
=
=
"
Function
"
|
|
token
.
value
!
=
=
"
linear
"
)
{
return
undefined
;
}
const
points
=
[
]
;
let
largestInput
=
-
Infinity
;
while
(
(
token
=
getNextToken
(
)
)
)
{
if
(
token
.
tokenType
=
=
=
"
CloseParenthesis
"
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
Number
"
)
{
const
point
=
{
input
:
null
output
:
token
.
number
}
;
points
.
push
(
point
)
;
token
=
getNextToken
(
)
;
if
(
token
&
&
token
.
tokenType
=
=
=
"
Percentage
"
)
{
point
.
input
=
Math
.
max
(
token
.
number
largestInput
)
;
largestInput
=
point
.
input
;
token
=
getNextToken
(
)
;
if
(
token
&
&
token
.
tokenType
=
=
=
"
Percentage
"
)
{
const
extraPoint
=
{
input
:
null
output
:
point
.
output
}
;
points
.
push
(
extraPoint
)
;
extraPoint
.
input
=
Math
.
max
(
token
.
number
largestInput
)
;
largestInput
=
extraPoint
.
input
;
}
}
else
if
(
points
.
length
=
=
1
)
{
point
.
input
=
0
;
largestInput
=
0
;
}
}
}
if
(
points
.
length
<
2
)
{
return
undefined
;
}
if
(
points
.
at
(
-
1
)
.
input
=
=
=
null
)
{
points
.
at
(
-
1
)
.
input
=
Math
.
max
(
largestInput
1
)
;
}
const
nullInputPoints
=
[
]
;
points
.
forEach
(
(
point
index
array
)
=
>
{
if
(
point
.
input
=
=
null
)
{
const
previousNonNull
=
array
.
findLast
(
(
item
i
)
=
>
i
<
index
&
&
item
.
input
!
=
=
null
)
.
input
;
const
nextNonNull
=
array
.
find
(
(
item
i
)
=
>
i
>
index
&
&
item
.
input
!
=
=
null
)
.
input
;
if
(
nullInputPoints
.
at
(
-
1
)
?
.
indexes
?
.
at
(
-
1
)
=
=
index
-
1
)
{
nullInputPoints
.
at
(
-
1
)
.
indexes
.
push
(
index
)
;
}
else
{
nullInputPoints
.
push
(
{
indexes
:
[
index
]
previousNonNull
nextNonNull
}
)
;
}
}
}
)
;
nullInputPoints
.
forEach
(
(
{
indexes
previousNonNull
nextNonNull
}
)
=
>
{
indexes
.
forEach
(
(
index
i
)
=
>
{
points
[
index
]
.
input
=
lerp
(
previousNonNull
nextNonNull
(
i
+
1
)
/
(
indexes
.
length
+
1
)
)
;
}
)
;
}
)
;
return
points
;
}
function
lerp
(
x
y
a
)
{
return
x
*
(
1
-
a
)
+
y
*
a
;
}
function
clamp
(
min
max
value
)
{
return
Math
.
max
(
min
Math
.
min
(
value
max
)
)
;
}
exports
.
parseTimingFunction
=
parseTimingFunction
;
