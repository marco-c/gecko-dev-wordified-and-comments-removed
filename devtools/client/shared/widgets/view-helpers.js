"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
PANE_APPEARANCE_DELAY
=
50
;
const
PAGE_SIZE_ITEM_COUNT_RATIO
=
5
;
const
WIDGET_FOCUSABLE_NODES
=
new
Set
(
[
"
vbox
"
"
hbox
"
]
)
;
var
namedTimeoutsStore
=
new
Map
(
)
;
const
setNamedTimeout
=
function
setNamedTimeout
(
id
wait
callback
)
{
clearNamedTimeout
(
id
)
;
namedTimeoutsStore
.
set
(
id
setTimeout
(
(
)
=
>
namedTimeoutsStore
.
delete
(
id
)
&
&
callback
(
)
wait
)
)
;
}
;
exports
.
setNamedTimeout
=
setNamedTimeout
;
const
clearNamedTimeout
=
function
clearNamedTimeout
(
id
)
{
if
(
!
namedTimeoutsStore
)
{
return
;
}
clearTimeout
(
namedTimeoutsStore
.
get
(
id
)
)
;
namedTimeoutsStore
.
delete
(
id
)
;
}
;
exports
.
clearNamedTimeout
=
clearNamedTimeout
;
const
setConditionalTimeout
=
function
setConditionalTimeout
(
id
wait
predicate
callback
)
{
setNamedTimeout
(
id
wait
function
maybeCallback
(
)
{
if
(
predicate
(
)
)
{
callback
(
)
;
return
;
}
setConditionalTimeout
(
id
wait
predicate
callback
)
;
}
)
;
}
;
exports
.
setConditionalTimeout
=
setConditionalTimeout
;
const
clearConditionalTimeout
=
function
clearConditionalTimeout
(
id
)
{
clearNamedTimeout
(
id
)
;
}
;
exports
.
clearConditionalTimeout
=
clearConditionalTimeout
;
const
ViewHelpers
=
exports
.
ViewHelpers
=
{
dispatchEvent
:
function
(
target
type
detail
)
{
if
(
!
(
target
instanceof
Node
)
)
{
return
true
;
}
const
document
=
target
.
ownerDocument
|
|
target
;
const
dispatcher
=
target
.
ownerDocument
?
target
:
document
.
documentElement
;
const
event
=
document
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
type
true
true
detail
)
;
return
dispatcher
.
dispatchEvent
(
event
)
;
}
delegateWidgetAttributeMethods
:
function
(
widget
node
)
{
widget
.
getAttribute
=
widget
.
getAttribute
|
|
node
.
getAttribute
.
bind
(
node
)
;
widget
.
setAttribute
=
widget
.
setAttribute
|
|
node
.
setAttribute
.
bind
(
node
)
;
widget
.
removeAttribute
=
widget
.
removeAttribute
|
|
node
.
removeAttribute
.
bind
(
node
)
;
}
delegateWidgetEventMethods
:
function
(
widget
node
)
{
widget
.
addEventListener
=
widget
.
addEventListener
|
|
node
.
addEventListener
.
bind
(
node
)
;
widget
.
removeEventListener
=
widget
.
removeEventListener
|
|
node
.
removeEventListener
.
bind
(
node
)
;
}
isEventEmitter
:
function
(
object
)
{
return
object
&
&
object
.
on
&
&
object
.
off
&
&
object
.
once
&
&
object
.
emit
;
}
isNode
:
function
(
object
)
{
return
object
instanceof
Node
|
|
object
instanceof
Element
|
|
Cu
.
getClassName
(
object
)
=
=
"
DocumentFragment
"
;
}
preventScrolling
:
function
(
e
)
{
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_UP
:
case
KeyCodes
.
DOM_VK_DOWN
:
case
KeyCodes
.
DOM_VK_LEFT
:
case
KeyCodes
.
DOM_VK_RIGHT
:
case
KeyCodes
.
DOM_VK_PAGE_UP
:
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
case
KeyCodes
.
DOM_VK_HOME
:
case
KeyCodes
.
DOM_VK_END
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
}
isSpaceOrReturn
:
function
(
event
)
{
return
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_SPACE
|
|
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RETURN
;
}
togglePane
:
function
(
flags
pane
)
{
if
(
!
pane
)
{
return
;
}
pane
.
removeAttribute
(
"
hidden
"
)
;
pane
.
classList
.
add
(
"
generic
-
toggled
-
pane
"
)
;
if
(
pane
.
hasAttribute
(
"
animated
"
)
)
{
return
;
}
if
(
flags
.
visible
=
=
!
pane
.
classList
.
contains
(
"
pane
-
collapsed
"
)
)
{
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
return
;
}
if
(
flags
.
animated
)
{
pane
.
setAttribute
(
"
animated
"
"
"
)
;
}
else
{
pane
.
removeAttribute
(
"
animated
"
)
;
}
const
doToggle
=
(
)
=
>
{
if
(
flags
.
visible
)
{
pane
.
style
.
marginLeft
=
"
0
"
;
pane
.
style
.
marginRight
=
"
0
"
;
pane
.
style
.
marginBottom
=
"
0
"
;
pane
.
classList
.
remove
(
"
pane
-
collapsed
"
)
;
}
else
{
const
width
=
Math
.
floor
(
pane
.
getAttribute
(
"
width
"
)
)
+
1
;
const
height
=
Math
.
floor
(
pane
.
getAttribute
(
"
height
"
)
)
+
1
;
pane
.
style
.
marginLeft
=
-
width
+
"
px
"
;
pane
.
style
.
marginRight
=
-
width
+
"
px
"
;
pane
.
style
.
marginBottom
=
-
height
+
"
px
"
;
}
if
(
flags
.
animated
)
{
const
options
=
{
useCapture
:
false
once
:
true
}
;
pane
.
addEventListener
(
"
transitionend
"
(
)
=
>
{
pane
.
removeAttribute
(
"
animated
"
)
;
if
(
!
flags
.
visible
)
{
pane
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
}
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
}
options
)
;
}
else
{
if
(
!
flags
.
visible
)
{
pane
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
}
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
}
}
;
if
(
flags
.
delayed
)
{
pane
.
ownerDocument
.
defaultView
.
setTimeout
(
doToggle
PANE_APPEARANCE_DELAY
)
;
}
else
{
doToggle
(
)
;
}
}
}
;
function
Item
(
ownerView
element
value
attachment
)
{
this
.
ownerView
=
ownerView
;
this
.
attachment
=
attachment
;
this
.
_value
=
value
+
"
"
;
this
.
_prebuiltNode
=
element
;
this
.
_itemsByElement
=
new
Map
(
)
;
}
Item
.
prototype
=
{
get
value
(
)
{
return
this
.
_value
;
}
get
target
(
)
{
return
this
.
_target
;
}
get
prebuiltNode
(
)
{
return
this
.
_prebuiltNode
;
}
append
:
function
(
element
options
=
{
}
)
{
const
item
=
new
Item
(
this
element
"
"
options
.
attachment
)
;
this
.
_entangleItem
(
item
this
.
_target
.
appendChild
(
element
)
)
;
if
(
options
.
attributes
)
{
options
.
attributes
.
forEach
(
e
=
>
item
.
_target
.
setAttribute
(
e
[
0
]
e
[
1
]
)
)
;
}
if
(
options
.
finalize
)
{
item
.
finalize
=
options
.
finalize
;
}
return
item
;
}
remove
:
function
(
item
)
{
if
(
!
item
)
{
return
;
}
this
.
_target
.
removeChild
(
item
.
_target
)
;
this
.
_untangleItem
(
item
)
;
}
_entangleItem
:
function
(
item
element
)
{
this
.
_itemsByElement
.
set
(
element
item
)
;
item
.
_target
=
element
;
}
_untangleItem
:
function
(
item
)
{
if
(
item
.
finalize
)
{
item
.
finalize
(
item
)
;
}
for
(
const
childItem
of
item
)
{
item
.
remove
(
childItem
)
;
}
this
.
_unlinkItem
(
item
)
;
item
.
_target
=
null
;
}
_unlinkItem
:
function
(
item
)
{
this
.
_itemsByElement
.
delete
(
item
.
_target
)
;
}
stringify
:
function
(
)
{
return
JSON
.
stringify
(
{
value
:
this
.
_value
target
:
this
.
_target
+
"
"
prebuiltNode
:
this
.
_prebuiltNode
+
"
"
attachment
:
this
.
attachment
}
null
2
)
;
}
_value
:
"
"
_target
:
null
_prebuiltNode
:
null
finalize
:
null
attachment
:
null
}
;
const
WidgetMethods
=
exports
.
WidgetMethods
=
{
set
widget
(
widget
)
{
this
.
_widget
=
widget
;
this
.
_itemsByValue
=
new
Map
(
)
;
this
.
_itemsByElement
=
new
Map
(
)
;
this
.
_stagedItems
=
[
]
;
if
(
ViewHelpers
.
isEventEmitter
(
widget
)
)
{
widget
.
on
(
"
keyDown
"
this
.
_onWidgetKeyDown
.
bind
(
this
)
)
;
widget
.
on
(
"
mousePress
"
this
.
_onWidgetMousePress
.
bind
(
this
)
)
;
}
}
get
widget
(
)
{
return
this
.
_widget
;
}
push
:
function
(
[
element
value
]
options
=
{
}
)
{
const
item
=
new
Item
(
this
element
value
options
.
attachment
)
;
if
(
options
.
staged
)
{
options
.
index
=
undefined
;
return
void
this
.
_stagedItems
.
push
(
{
item
:
item
options
:
options
}
)
;
}
if
(
!
(
"
index
"
in
options
)
)
{
return
this
.
_insertItemAt
(
this
.
_findExpectedIndexFor
(
item
)
item
options
)
;
}
return
this
.
_insertItemAt
(
options
.
index
item
options
)
;
}
commit
:
function
(
options
=
{
}
)
{
const
stagedItems
=
this
.
_stagedItems
;
if
(
options
.
sorted
)
{
stagedItems
.
sort
(
(
a
b
)
=
>
this
.
_currentSortPredicate
(
a
.
item
b
.
item
)
)
;
}
for
(
const
{
item
opt
}
of
stagedItems
)
{
this
.
_insertItemAt
(
-
1
item
opt
)
;
}
this
.
_stagedItems
.
length
=
0
;
}
remove
:
function
(
item
)
{
if
(
!
item
)
{
return
;
}
this
.
_widget
.
removeChild
(
item
.
_target
)
;
this
.
_untangleItem
(
item
)
;
if
(
!
this
.
_itemsByElement
.
size
)
{
this
.
_preferredValue
=
this
.
selectedValue
;
this
.
_widget
.
selectedItem
=
null
;
this
.
_widget
.
setAttribute
(
"
emptyText
"
this
.
_emptyText
)
;
}
}
removeAt
:
function
(
index
)
{
this
.
remove
(
this
.
getItemAtIndex
(
index
)
)
;
}
removeForPredicate
:
function
(
predicate
)
{
let
item
;
while
(
(
item
=
this
.
getItemForPredicate
(
predicate
)
)
)
{
this
.
remove
(
item
)
;
}
}
empty
:
function
(
)
{
this
.
_preferredValue
=
this
.
selectedValue
;
this
.
_widget
.
selectedItem
=
null
;
this
.
_widget
.
removeAllItems
(
)
;
this
.
_widget
.
setAttribute
(
"
emptyText
"
this
.
_emptyText
)
;
for
(
const
[
item
]
of
this
.
_itemsByElement
)
{
this
.
_untangleItem
(
item
)
;
}
this
.
_itemsByValue
.
clear
(
)
;
this
.
_itemsByElement
.
clear
(
)
;
this
.
_stagedItems
.
length
=
0
;
}
ensureItemIsVisible
:
function
(
item
)
{
this
.
_widget
.
ensureElementIsVisible
(
item
.
_target
)
;
}
ensureIndexIsVisible
:
function
(
index
)
{
this
.
ensureItemIsVisible
(
this
.
getItemAtIndex
(
index
)
)
;
}
ensureSelectedItemIsVisible
:
function
(
)
{
this
.
ensureItemIsVisible
(
this
.
selectedItem
)
;
}
set
emptyText
(
value
)
{
this
.
_emptyText
=
value
;
if
(
!
this
.
_itemsByElement
.
size
)
{
this
.
_widget
.
setAttribute
(
"
emptyText
"
value
)
;
}
}
set
headerText
(
value
)
{
this
.
_headerText
=
value
;
this
.
_widget
.
setAttribute
(
"
headerText
"
value
)
;
}
toggleContents
:
function
(
visibleFlag
)
{
for
(
const
[
element
]
of
this
.
_itemsByElement
)
{
element
.
hidden
=
!
visibleFlag
;
}
}
filterContents
:
function
(
predicate
=
this
.
_currentFilterPredicate
)
{
this
.
_currentFilterPredicate
=
predicate
;
for
(
const
[
element
item
]
of
this
.
_itemsByElement
)
{
element
.
hidden
=
!
predicate
(
item
)
;
}
}
sortContents
:
function
(
predicate
=
this
.
_currentSortPredicate
)
{
const
sortedItems
=
this
.
items
.
sort
(
this
.
_currentSortPredicate
=
predicate
)
;
for
(
let
i
=
0
len
=
sortedItems
.
length
;
i
<
len
;
i
+
+
)
{
this
.
swapItems
(
this
.
getItemAtIndex
(
i
)
sortedItems
[
i
]
)
;
}
}
swapItems
:
function
(
first
second
)
{
if
(
first
=
=
second
)
{
return
;
}
const
{
_prebuiltNode
:
firstPrebuiltTarget
_target
:
firstTarget
}
=
first
;
const
{
_prebuiltNode
:
secondPrebuiltTarget
_target
:
secondTarget
}
=
second
;
if
(
Cu
.
getClassName
(
firstPrebuiltTarget
)
=
=
"
DocumentFragment
"
)
{
for
(
const
node
of
firstTarget
.
childNodes
)
{
firstPrebuiltTarget
.
appendChild
(
node
.
cloneNode
(
true
)
)
;
}
}
if
(
Cu
.
getClassName
(
secondPrebuiltTarget
)
=
=
"
DocumentFragment
"
)
{
for
(
const
node
of
secondTarget
.
childNodes
)
{
secondPrebuiltTarget
.
appendChild
(
node
.
cloneNode
(
true
)
)
;
}
}
const
i
=
this
.
_indexOfElement
(
firstTarget
)
;
const
j
=
this
.
_indexOfElement
(
secondTarget
)
;
const
selectedTarget
=
this
.
_widget
.
selectedItem
;
let
selectedIndex
=
-
1
;
if
(
selectedTarget
=
=
firstTarget
)
{
selectedIndex
=
i
;
}
else
if
(
selectedTarget
=
=
secondTarget
)
{
selectedIndex
=
j
;
}
this
.
_widget
.
removeChild
(
firstTarget
)
;
this
.
_widget
.
removeChild
(
secondTarget
)
;
this
.
_unlinkItem
(
first
)
;
this
.
_unlinkItem
(
second
)
;
this
.
_insertItemAt
.
apply
(
this
i
<
j
?
[
i
second
]
:
[
j
first
]
)
;
this
.
_insertItemAt
.
apply
(
this
i
<
j
?
[
j
first
]
:
[
i
second
]
)
;
if
(
selectedIndex
=
=
i
)
{
this
.
_widget
.
selectedItem
=
first
.
_target
;
}
else
if
(
selectedIndex
=
=
j
)
{
this
.
_widget
.
selectedItem
=
second
.
_target
;
}
ViewHelpers
.
dispatchEvent
(
first
.
target
"
swap
"
[
second
first
]
)
;
}
swapItemsAtIndices
:
function
(
first
second
)
{
this
.
swapItems
(
this
.
getItemAtIndex
(
first
)
this
.
getItemAtIndex
(
second
)
)
;
}
containsValue
:
function
(
value
)
{
return
this
.
_itemsByValue
.
has
(
value
)
|
|
this
.
_stagedItems
.
some
(
(
{
item
}
)
=
>
item
.
_value
=
=
value
)
;
}
get
preferredValue
(
)
{
return
this
.
_preferredValue
;
}
get
selectedItem
(
)
{
const
selectedElement
=
this
.
_widget
.
selectedItem
;
if
(
selectedElement
)
{
return
this
.
_itemsByElement
.
get
(
selectedElement
)
;
}
return
null
;
}
get
selectedIndex
(
)
{
const
selectedElement
=
this
.
_widget
.
selectedItem
;
if
(
selectedElement
)
{
return
this
.
_indexOfElement
(
selectedElement
)
;
}
return
-
1
;
}
get
selectedValue
(
)
{
const
selectedElement
=
this
.
_widget
.
selectedItem
;
if
(
selectedElement
)
{
return
this
.
_itemsByElement
.
get
(
selectedElement
)
.
_value
;
}
return
"
"
;
}
get
selectedAttachment
(
)
{
const
selectedElement
=
this
.
_widget
.
selectedItem
;
if
(
selectedElement
)
{
return
this
.
_itemsByElement
.
get
(
selectedElement
)
.
attachment
;
}
return
null
;
}
_selectItem
:
function
(
item
)
{
const
targetElement
=
item
?
item
.
_target
:
null
;
const
prevElement
=
this
.
_widget
.
selectedItem
;
if
(
this
.
autoFocusOnSelection
&
&
targetElement
)
{
targetElement
.
focus
(
)
;
}
if
(
targetElement
!
=
prevElement
)
{
this
.
_widget
.
selectedItem
=
targetElement
;
}
}
set
selectedItem
(
item
)
{
if
(
typeof
item
=
=
"
function
"
)
{
item
=
this
.
getItemForPredicate
(
item
)
;
}
const
targetElement
=
item
?
item
.
_target
:
null
;
const
prevElement
=
this
.
_widget
.
selectedItem
;
if
(
this
.
maintainSelectionVisible
&
&
targetElement
)
{
if
(
"
ensureElementIsVisible
"
in
this
.
_widget
)
{
this
.
_widget
.
ensureElementIsVisible
(
targetElement
)
;
}
}
this
.
_selectItem
(
item
)
;
if
(
targetElement
!
=
prevElement
)
{
const
dispTarget
=
targetElement
|
|
prevElement
;
const
dispName
=
this
.
suppressSelectionEvents
?
"
suppressed
-
select
"
:
"
select
"
;
ViewHelpers
.
dispatchEvent
(
dispTarget
dispName
item
)
;
}
}
set
selectedIndex
(
index
)
{
const
targetElement
=
this
.
_widget
.
getItemAtIndex
(
index
)
;
if
(
targetElement
)
{
this
.
selectedItem
=
this
.
_itemsByElement
.
get
(
targetElement
)
;
return
;
}
this
.
selectedItem
=
null
;
}
set
selectedValue
(
value
)
{
this
.
selectedItem
=
this
.
_itemsByValue
.
get
(
value
)
;
}
forceSelect
:
function
(
item
)
{
this
.
selectedItem
=
null
;
this
.
selectedItem
=
item
;
}
maintainSelectionVisible
:
true
suppressSelectionEvents
:
false
autoFocusOnFirstItem
:
true
autoFocusOnSelection
:
true
autoFocusOnInput
:
true
allowFocusOnRightClick
:
false
pageSize
:
0
focusFirstVisibleItem
:
function
(
)
{
this
.
focusItemAtDelta
(
-
this
.
itemCount
)
;
}
focusLastVisibleItem
:
function
(
)
{
this
.
focusItemAtDelta
(
+
this
.
itemCount
)
;
}
focusNextItem
:
function
(
)
{
this
.
focusItemAtDelta
(
+
1
)
;
}
focusPrevItem
:
function
(
)
{
this
.
focusItemAtDelta
(
-
1
)
;
}
focusItemAtDelta
:
function
(
delta
)
{
const
selectedElement
=
this
.
_widget
.
selectedItem
;
if
(
selectedElement
)
{
selectedElement
.
focus
(
)
;
}
else
{
this
.
selectedIndex
=
Math
.
max
(
0
delta
-
1
)
;
return
;
}
const
direction
=
delta
>
0
?
"
advanceFocus
"
:
"
rewindFocus
"
;
let
distance
=
Math
.
abs
(
Math
[
delta
>
0
?
"
ceil
"
:
"
floor
"
]
(
delta
)
)
;
while
(
distance
-
-
)
{
if
(
!
this
.
_focusChange
(
direction
)
)
{
break
;
}
}
this
.
selectedItem
=
this
.
getItemForElement
(
this
.
_focusedElement
)
;
}
_focusChange
:
function
(
direction
)
{
const
commandDispatcher
=
this
.
_commandDispatcher
;
const
prevFocusedElement
=
commandDispatcher
.
focusedElement
;
let
currFocusedElement
;
do
{
commandDispatcher
[
direction
]
(
)
;
currFocusedElement
=
commandDispatcher
.
focusedElement
;
if
(
!
this
.
getItemForElement
(
currFocusedElement
)
)
{
prevFocusedElement
.
focus
(
)
;
return
false
;
}
}
while
(
!
WIDGET_FOCUSABLE_NODES
.
has
(
currFocusedElement
.
tagName
)
)
;
return
true
;
}
get
_commandDispatcher
(
)
{
if
(
this
.
_cachedCommandDispatcher
)
{
return
this
.
_cachedCommandDispatcher
;
}
const
someElement
=
this
.
_widget
.
getItemAtIndex
(
0
)
;
if
(
someElement
)
{
const
commandDispatcher
=
someElement
.
ownerDocument
.
commandDispatcher
;
this
.
_cachedCommandDispatcher
=
commandDispatcher
;
return
commandDispatcher
;
}
return
null
;
}
get
_focusedElement
(
)
{
const
commandDispatcher
=
this
.
_commandDispatcher
;
if
(
commandDispatcher
)
{
return
commandDispatcher
.
focusedElement
;
}
return
null
;
}
getItemAtIndex
:
function
(
index
)
{
return
this
.
getItemForElement
(
this
.
_widget
.
getItemAtIndex
(
index
)
)
;
}
getItemByValue
:
function
(
value
)
{
return
this
.
_itemsByValue
.
get
(
value
)
;
}
getItemForElement
:
function
(
element
flags
=
{
}
)
{
while
(
element
)
{
let
item
=
this
.
_itemsByElement
.
get
(
element
)
;
if
(
!
flags
.
noSiblings
)
{
item
=
item
|
|
this
.
_itemsByElement
.
get
(
element
.
nextElementSibling
)
|
|
this
.
_itemsByElement
.
get
(
element
.
previousElementSibling
)
;
}
if
(
item
)
{
return
item
;
}
element
=
element
.
parentNode
;
}
return
null
;
}
getItemForPredicate
:
function
(
predicate
owner
=
this
)
{
for
(
const
[
element
item
]
of
owner
.
_itemsByElement
)
{
let
match
;
if
(
predicate
(
item
)
&
&
!
element
.
hidden
)
{
match
=
item
;
}
else
{
match
=
this
.
getItemForPredicate
(
predicate
item
)
;
}
if
(
match
)
{
return
match
;
}
}
for
(
const
{
item
}
of
this
.
_stagedItems
)
{
if
(
predicate
(
item
)
)
{
return
item
;
}
}
return
null
;
}
getItemForAttachment
:
function
(
predicate
owner
=
this
)
{
return
this
.
getItemForPredicate
(
e
=
>
predicate
(
e
.
attachment
)
)
;
}
indexOfItem
:
function
(
item
)
{
return
this
.
_indexOfElement
(
item
.
_target
)
;
}
_indexOfElement
:
function
(
element
)
{
for
(
let
i
=
0
;
i
<
this
.
_itemsByElement
.
size
;
i
+
+
)
{
if
(
this
.
_widget
.
getItemAtIndex
(
i
)
=
=
element
)
{
return
i
;
}
}
return
-
1
;
}
get
itemCount
(
)
{
return
this
.
_itemsByElement
.
size
;
}
get
items
(
)
{
const
store
=
[
]
;
const
itemCount
=
this
.
itemCount
;
for
(
let
i
=
0
;
i
<
itemCount
;
i
+
+
)
{
store
.
push
(
this
.
getItemAtIndex
(
i
)
)
;
}
return
store
;
}
get
values
(
)
{
return
this
.
items
.
map
(
e
=
>
e
.
_value
)
;
}
get
attachments
(
)
{
return
this
.
items
.
map
(
e
=
>
e
.
attachment
)
;
}
get
visibleItems
(
)
{
return
this
.
items
.
filter
(
e
=
>
!
e
.
_target
.
hidden
)
;
}
isUnique
:
function
(
item
)
{
const
value
=
item
.
_value
;
if
(
value
=
=
"
"
|
|
value
=
=
"
undefined
"
|
|
value
=
=
"
null
"
)
{
return
true
;
}
return
!
this
.
_itemsByValue
.
has
(
value
)
;
}
isEligible
:
function
(
item
)
{
return
this
.
isUnique
(
item
)
&
&
item
.
_prebuiltNode
;
}
_findExpectedIndexFor
:
function
(
item
)
{
const
itemCount
=
this
.
itemCount
;
for
(
let
i
=
0
;
i
<
itemCount
;
i
+
+
)
{
if
(
this
.
_currentSortPredicate
(
this
.
getItemAtIndex
(
i
)
item
)
>
0
)
{
return
i
;
}
}
return
itemCount
;
}
_insertItemAt
:
function
(
index
item
options
=
{
}
)
{
if
(
!
this
.
isEligible
(
item
)
)
{
return
null
;
}
const
node
=
item
.
_prebuiltNode
;
const
attachment
=
item
.
attachment
;
this
.
_entangleItem
(
item
this
.
_widget
.
insertItemAt
(
index
node
attachment
)
)
;
if
(
!
this
.
_currentFilterPredicate
(
item
)
)
{
item
.
_target
.
hidden
=
true
;
}
if
(
this
.
autoFocusOnFirstItem
&
&
this
.
_itemsByElement
.
size
=
=
1
)
{
item
.
_target
.
focus
(
)
;
}
if
(
options
.
attributes
)
{
options
.
attributes
.
forEach
(
e
=
>
item
.
_target
.
setAttribute
(
e
[
0
]
e
[
1
]
)
)
;
}
if
(
options
.
finalize
)
{
item
.
finalize
=
options
.
finalize
;
}
this
.
_widget
.
removeAttribute
(
"
emptyText
"
)
;
return
item
;
}
_entangleItem
:
function
(
item
element
)
{
this
.
_itemsByValue
.
set
(
item
.
_value
item
)
;
this
.
_itemsByElement
.
set
(
element
item
)
;
item
.
_target
=
element
;
}
_untangleItem
:
function
(
item
)
{
if
(
item
.
finalize
)
{
item
.
finalize
(
item
)
;
}
for
(
const
childItem
of
item
)
{
item
.
remove
(
childItem
)
;
}
this
.
_unlinkItem
(
item
)
;
item
.
_target
=
null
;
}
_unlinkItem
:
function
(
item
)
{
this
.
_itemsByValue
.
delete
(
item
.
_value
)
;
this
.
_itemsByElement
.
delete
(
item
.
_target
)
;
}
_onWidgetKeyDown
:
function
(
event
)
{
ViewHelpers
.
preventScrolling
(
event
)
;
switch
(
event
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_UP
:
case
KeyCodes
.
DOM_VK_LEFT
:
this
.
focusPrevItem
(
)
;
break
;
case
KeyCodes
.
DOM_VK_DOWN
:
case
KeyCodes
.
DOM_VK_RIGHT
:
this
.
focusNextItem
(
)
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
this
.
focusItemAtDelta
(
-
(
this
.
pageSize
|
|
(
this
.
itemCount
/
PAGE_SIZE_ITEM_COUNT_RATIO
)
)
)
;
break
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
this
.
focusItemAtDelta
(
+
(
this
.
pageSize
|
|
(
this
.
itemCount
/
PAGE_SIZE_ITEM_COUNT_RATIO
)
)
)
;
break
;
case
KeyCodes
.
DOM_VK_HOME
:
this
.
focusFirstVisibleItem
(
)
;
break
;
case
KeyCodes
.
DOM_VK_END
:
this
.
focusLastVisibleItem
(
)
;
break
;
}
}
_onWidgetMousePress
:
function
(
event
)
{
if
(
event
.
button
!
=
0
&
&
!
this
.
allowFocusOnRightClick
)
{
return
;
}
const
item
=
this
.
getItemForElement
(
event
.
target
)
;
if
(
item
)
{
this
.
selectedItem
=
item
;
this
.
autoFocusOnInput
&
&
item
.
_target
.
focus
(
)
;
}
}
_currentFilterPredicate
:
function
(
item
)
{
return
true
;
}
_currentSortPredicate
:
function
(
first
second
)
{
return
+
(
first
.
_value
.
toLowerCase
(
)
>
second
.
_value
.
toLowerCase
(
)
)
;
}
callMethod
:
function
(
methodName
.
.
.
args
)
{
return
this
.
_widget
[
methodName
]
.
apply
(
this
.
_widget
args
)
;
}
_widget
:
null
_emptyText
:
"
"
_headerText
:
"
"
_preferredValue
:
"
"
_cachedCommandDispatcher
:
null
}
;
Item
.
prototype
[
Symbol
.
iterator
]
=
WidgetMethods
[
Symbol
.
iterator
]
=
function
*
(
)
{
yield
*
this
.
_itemsByElement
.
values
(
)
;
}
;
