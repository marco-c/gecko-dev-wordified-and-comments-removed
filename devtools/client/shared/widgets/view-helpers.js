"
use
strict
"
;
const
{
KeyCodes
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
keycodes
.
js
"
)
;
const
PANE_APPEARANCE_DELAY
=
50
;
var
namedTimeoutsStore
=
new
Map
(
)
;
const
setNamedTimeout
=
function
setNamedTimeout
(
id
wait
callback
)
{
clearNamedTimeout
(
id
)
;
namedTimeoutsStore
.
set
(
id
setTimeout
(
(
)
=
>
namedTimeoutsStore
.
delete
(
id
)
&
&
callback
(
)
wait
)
)
;
}
;
exports
.
setNamedTimeout
=
setNamedTimeout
;
const
clearNamedTimeout
=
function
clearNamedTimeout
(
id
)
{
if
(
!
namedTimeoutsStore
)
{
return
;
}
clearTimeout
(
namedTimeoutsStore
.
get
(
id
)
)
;
namedTimeoutsStore
.
delete
(
id
)
;
}
;
exports
.
clearNamedTimeout
=
clearNamedTimeout
;
exports
.
ViewHelpers
=
{
dispatchEvent
(
target
type
detail
)
{
if
(
!
(
target
instanceof
Node
)
)
{
return
true
;
}
const
document
=
target
.
ownerDocument
|
|
target
;
const
dispatcher
=
target
.
ownerDocument
?
target
:
document
.
documentElement
;
const
event
=
document
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
type
true
true
detail
)
;
return
dispatcher
.
dispatchEvent
(
event
)
;
}
delegateWidgetAttributeMethods
(
widget
node
)
{
widget
.
getAttribute
=
widget
.
getAttribute
|
|
node
.
getAttribute
.
bind
(
node
)
;
widget
.
setAttribute
=
widget
.
setAttribute
|
|
node
.
setAttribute
.
bind
(
node
)
;
widget
.
removeAttribute
=
widget
.
removeAttribute
|
|
node
.
removeAttribute
.
bind
(
node
)
;
}
delegateWidgetEventMethods
(
widget
node
)
{
widget
.
addEventListener
=
widget
.
addEventListener
|
|
node
.
addEventListener
.
bind
(
node
)
;
widget
.
removeEventListener
=
widget
.
removeEventListener
|
|
node
.
removeEventListener
.
bind
(
node
)
;
}
isEventEmitter
(
object
)
{
return
object
?
.
on
&
&
object
?
.
off
&
&
object
?
.
once
&
&
object
?
.
emit
;
}
isNode
(
object
)
{
return
(
object
instanceof
Node
|
|
object
instanceof
Element
|
|
Cu
.
getClassName
(
object
)
=
=
"
DocumentFragment
"
)
;
}
preventScrolling
(
e
)
{
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_UP
:
case
KeyCodes
.
DOM_VK_DOWN
:
case
KeyCodes
.
DOM_VK_LEFT
:
case
KeyCodes
.
DOM_VK_RIGHT
:
case
KeyCodes
.
DOM_VK_PAGE_UP
:
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
case
KeyCodes
.
DOM_VK_HOME
:
case
KeyCodes
.
DOM_VK_END
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
}
isSpaceOrReturn
(
event
)
{
return
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_SPACE
|
|
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RETURN
)
;
}
togglePane
(
flags
pane
)
{
if
(
!
pane
)
{
return
;
}
pane
.
removeAttribute
(
"
hidden
"
)
;
pane
.
classList
.
add
(
"
generic
-
toggled
-
pane
"
)
;
if
(
pane
.
hasAttribute
(
"
animated
"
)
)
{
return
;
}
if
(
flags
.
visible
=
=
!
pane
.
classList
.
contains
(
"
pane
-
collapsed
"
)
)
{
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
return
;
}
if
(
flags
.
animated
)
{
pane
.
setAttribute
(
"
animated
"
"
"
)
;
}
else
{
pane
.
removeAttribute
(
"
animated
"
)
;
}
const
doToggle
=
(
)
=
>
{
if
(
flags
.
visible
)
{
pane
.
style
.
marginLeft
=
"
0
"
;
pane
.
style
.
marginRight
=
"
0
"
;
pane
.
style
.
marginBottom
=
"
0
"
;
pane
.
classList
.
remove
(
"
pane
-
collapsed
"
)
;
}
else
{
const
width
=
Math
.
floor
(
pane
.
getAttribute
(
"
width
"
)
)
+
1
;
const
height
=
Math
.
floor
(
pane
.
getAttribute
(
"
height
"
)
)
+
1
;
pane
.
style
.
marginLeft
=
-
width
+
"
px
"
;
pane
.
style
.
marginRight
=
-
width
+
"
px
"
;
pane
.
style
.
marginBottom
=
-
height
+
"
px
"
;
}
if
(
flags
.
animated
)
{
const
options
=
{
useCapture
:
false
once
:
true
}
;
pane
.
addEventListener
(
"
transitionend
"
(
)
=
>
{
pane
.
removeAttribute
(
"
animated
"
)
;
if
(
!
flags
.
visible
)
{
pane
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
}
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
}
options
)
;
}
else
{
if
(
!
flags
.
visible
)
{
pane
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
}
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
}
}
;
if
(
flags
.
delayed
)
{
pane
.
ownerDocument
.
defaultView
.
setTimeout
(
doToggle
PANE_APPEARANCE_DELAY
)
;
}
else
{
doToggle
(
)
;
}
}
}
;
