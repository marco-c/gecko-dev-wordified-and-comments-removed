"
use
strict
"
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
PANE_APPEARANCE_DELAY
=
50
;
var
namedTimeoutsStore
=
new
Map
(
)
;
const
setNamedTimeout
=
function
setNamedTimeout
(
id
wait
callback
)
{
clearNamedTimeout
(
id
)
;
namedTimeoutsStore
.
set
(
id
setTimeout
(
(
)
=
>
namedTimeoutsStore
.
delete
(
id
)
&
&
callback
(
)
wait
)
)
;
}
;
exports
.
setNamedTimeout
=
setNamedTimeout
;
const
clearNamedTimeout
=
function
clearNamedTimeout
(
id
)
{
if
(
!
namedTimeoutsStore
)
{
return
;
}
clearTimeout
(
namedTimeoutsStore
.
get
(
id
)
)
;
namedTimeoutsStore
.
delete
(
id
)
;
}
;
exports
.
clearNamedTimeout
=
clearNamedTimeout
;
exports
.
ViewHelpers
=
{
dispatchEvent
(
target
type
detail
)
{
if
(
!
(
target
instanceof
Node
)
)
{
return
true
;
}
const
document
=
target
.
ownerDocument
|
|
target
;
const
dispatcher
=
target
.
ownerDocument
?
target
:
document
.
documentElement
;
const
event
=
document
.
createEvent
(
"
CustomEvent
"
)
;
event
.
initCustomEvent
(
type
true
true
detail
)
;
return
dispatcher
.
dispatchEvent
(
event
)
;
}
delegateWidgetAttributeMethods
(
widget
node
)
{
widget
.
getAttribute
=
widget
.
getAttribute
|
|
node
.
getAttribute
.
bind
(
node
)
;
widget
.
setAttribute
=
widget
.
setAttribute
|
|
node
.
setAttribute
.
bind
(
node
)
;
widget
.
removeAttribute
=
widget
.
removeAttribute
|
|
node
.
removeAttribute
.
bind
(
node
)
;
}
delegateWidgetEventMethods
(
widget
node
)
{
widget
.
addEventListener
=
widget
.
addEventListener
|
|
node
.
addEventListener
.
bind
(
node
)
;
widget
.
removeEventListener
=
widget
.
removeEventListener
|
|
node
.
removeEventListener
.
bind
(
node
)
;
}
isEventEmitter
(
object
)
{
return
object
?
.
on
&
&
object
?
.
off
&
&
object
?
.
once
&
&
object
?
.
emit
;
}
isNode
(
object
)
{
return
(
object
instanceof
Node
|
|
object
instanceof
Element
|
|
Cu
.
getClassName
(
object
)
=
=
"
DocumentFragment
"
)
;
}
preventScrolling
(
e
)
{
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_UP
:
case
KeyCodes
.
DOM_VK_DOWN
:
case
KeyCodes
.
DOM_VK_LEFT
:
case
KeyCodes
.
DOM_VK_RIGHT
:
case
KeyCodes
.
DOM_VK_PAGE_UP
:
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
case
KeyCodes
.
DOM_VK_HOME
:
case
KeyCodes
.
DOM_VK_END
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
}
isSpaceOrReturn
(
event
)
{
return
(
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_SPACE
|
|
event
.
keyCode
=
=
=
KeyCodes
.
DOM_VK_RETURN
)
;
}
togglePane
(
flags
pane
)
{
if
(
!
pane
)
{
return
;
}
pane
.
removeAttribute
(
"
hidden
"
)
;
pane
.
classList
.
add
(
"
generic
-
toggled
-
pane
"
)
;
if
(
pane
.
hasAttribute
(
"
animated
"
)
)
{
return
;
}
if
(
flags
.
visible
=
=
!
pane
.
classList
.
contains
(
"
pane
-
collapsed
"
)
)
{
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
return
;
}
if
(
flags
.
animated
)
{
pane
.
setAttribute
(
"
animated
"
"
"
)
;
}
else
{
pane
.
removeAttribute
(
"
animated
"
)
;
}
const
doToggle
=
(
)
=
>
{
if
(
flags
.
visible
)
{
pane
.
style
.
marginLeft
=
"
0
"
;
pane
.
style
.
marginRight
=
"
0
"
;
pane
.
style
.
marginBottom
=
"
0
"
;
pane
.
classList
.
remove
(
"
pane
-
collapsed
"
)
;
}
else
{
const
width
=
Math
.
floor
(
pane
.
getAttribute
(
"
width
"
)
)
+
1
;
const
height
=
Math
.
floor
(
pane
.
getAttribute
(
"
height
"
)
)
+
1
;
pane
.
style
.
marginLeft
=
-
width
+
"
px
"
;
pane
.
style
.
marginRight
=
-
width
+
"
px
"
;
pane
.
style
.
marginBottom
=
-
height
+
"
px
"
;
}
if
(
flags
.
animated
)
{
const
options
=
{
useCapture
:
false
once
:
true
}
;
pane
.
addEventListener
(
"
transitionend
"
(
)
=
>
{
pane
.
removeAttribute
(
"
animated
"
)
;
if
(
!
flags
.
visible
)
{
pane
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
}
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
}
options
)
;
}
else
{
if
(
!
flags
.
visible
)
{
pane
.
classList
.
add
(
"
pane
-
collapsed
"
)
;
}
if
(
flags
.
callback
)
{
flags
.
callback
(
)
;
}
}
}
;
if
(
flags
.
delayed
)
{
pane
.
ownerDocument
.
defaultView
.
setTimeout
(
doToggle
PANE_APPEARANCE_DELAY
)
;
}
else
{
doToggle
(
)
;
}
}
}
;
function
Item
(
ownerView
element
value
attachment
)
{
this
.
ownerView
=
ownerView
;
this
.
attachment
=
attachment
;
this
.
_value
=
value
+
"
"
;
this
.
_prebuiltNode
=
element
;
this
.
_itemsByElement
=
new
Map
(
)
;
}
Item
.
prototype
=
{
get
value
(
)
{
return
this
.
_value
;
}
get
target
(
)
{
return
this
.
_target
;
}
get
prebuiltNode
(
)
{
return
this
.
_prebuiltNode
;
}
append
(
element
options
=
{
}
)
{
const
item
=
new
Item
(
this
element
"
"
options
.
attachment
)
;
this
.
_entangleItem
(
item
this
.
_target
.
appendChild
(
element
)
)
;
if
(
options
.
attributes
)
{
options
.
attributes
.
forEach
(
e
=
>
item
.
_target
.
setAttribute
(
e
[
0
]
e
[
1
]
)
)
;
}
if
(
options
.
finalize
)
{
item
.
finalize
=
options
.
finalize
;
}
return
item
;
}
remove
(
item
)
{
if
(
!
item
)
{
return
;
}
this
.
_target
.
removeChild
(
item
.
_target
)
;
this
.
_untangleItem
(
item
)
;
}
_entangleItem
(
item
element
)
{
this
.
_itemsByElement
.
set
(
element
item
)
;
item
.
_target
=
element
;
}
_untangleItem
(
item
)
{
if
(
item
.
finalize
)
{
item
.
finalize
(
item
)
;
}
for
(
const
childItem
of
item
)
{
item
.
remove
(
childItem
)
;
}
this
.
_unlinkItem
(
item
)
;
item
.
_target
=
null
;
}
_unlinkItem
(
item
)
{
this
.
_itemsByElement
.
delete
(
item
.
_target
)
;
}
stringify
(
)
{
return
JSON
.
stringify
(
{
value
:
this
.
_value
target
:
this
.
_target
+
"
"
prebuiltNode
:
this
.
_prebuiltNode
+
"
"
attachment
:
this
.
attachment
}
null
2
)
;
}
_value
:
"
"
_target
:
null
_prebuiltNode
:
null
finalize
:
null
attachment
:
null
}
;
