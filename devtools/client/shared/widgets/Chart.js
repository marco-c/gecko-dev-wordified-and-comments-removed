"
use
strict
"
;
const
NET_STRINGS_URI
=
"
devtools
/
client
/
locales
/
netmonitor
.
properties
"
;
const
SVG_NS
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
;
const
PI
=
Math
.
PI
;
const
TAU
=
PI
*
2
;
const
EPSILON
=
0
.
0000001
;
const
NAMED_SLICE_MIN_ANGLE
=
TAU
/
8
;
const
NAMED_SLICE_TEXT_DISTANCE_RATIO
=
1
.
9
;
const
HOVERED_SLICE_TRANSLATE_DISTANCE_RATIO
=
20
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
NET_STRINGS_URI
)
;
var
Chart
=
{
Pie
:
createPieChart
Table
:
createTableChart
PieTable
:
createPieTableChart
}
;
function
PieChart
(
node
)
{
this
.
node
=
node
;
this
.
slices
=
new
WeakMap
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
function
TableChart
(
node
)
{
this
.
node
=
node
;
this
.
rows
=
new
WeakMap
(
)
;
EventEmitter
.
decorate
(
this
)
;
}
function
PieTableChart
(
node
pie
table
)
{
this
.
node
=
node
;
this
.
pie
=
pie
;
this
.
table
=
table
;
EventEmitter
.
decorate
(
this
)
;
}
function
createPieTableChart
(
document
{
title
diameter
data
strings
totals
sorted
header
}
)
{
if
(
data
&
&
sorted
)
{
data
=
data
.
slice
(
)
.
sort
(
(
a
b
)
=
>
+
(
a
.
size
<
b
.
size
)
)
;
}
const
pie
=
Chart
.
Pie
(
document
{
width
:
diameter
data
}
)
;
const
table
=
Chart
.
Table
(
document
{
title
data
strings
totals
header
}
)
;
const
container
=
document
.
createElement
(
"
div
"
)
;
container
.
className
=
"
pie
-
table
-
chart
-
container
"
;
container
.
appendChild
(
pie
.
node
)
;
container
.
appendChild
(
table
.
node
)
;
const
proxy
=
new
PieTableChart
(
container
pie
table
)
;
pie
.
on
(
"
click
"
item
=
>
{
proxy
.
emit
(
"
click
"
item
)
;
}
)
;
table
.
on
(
"
click
"
item
=
>
{
proxy
.
emit
(
"
click
"
item
)
;
}
)
;
pie
.
on
(
"
mouseover
"
item
=
>
{
proxy
.
emit
(
"
mouseover
"
item
)
;
if
(
table
.
rows
.
has
(
item
)
)
{
table
.
rows
.
get
(
item
)
.
setAttribute
(
"
focused
"
"
"
)
;
}
}
)
;
pie
.
on
(
"
mouseout
"
item
=
>
{
proxy
.
emit
(
"
mouseout
"
item
)
;
if
(
table
.
rows
.
has
(
item
)
)
{
table
.
rows
.
get
(
item
)
.
removeAttribute
(
"
focused
"
)
;
}
}
)
;
table
.
on
(
"
mouseover
"
item
=
>
{
proxy
.
emit
(
"
mouseover
"
item
)
;
if
(
pie
.
slices
.
has
(
item
)
)
{
pie
.
slices
.
get
(
item
)
.
setAttribute
(
"
focused
"
"
"
)
;
}
}
)
;
table
.
on
(
"
mouseout
"
item
=
>
{
proxy
.
emit
(
"
mouseout
"
item
)
;
if
(
pie
.
slices
.
has
(
item
)
)
{
pie
.
slices
.
get
(
item
)
.
removeAttribute
(
"
focused
"
)
;
}
}
)
;
return
proxy
;
}
function
createPieChart
(
document
{
data
width
height
centerX
centerY
radius
}
)
{
height
=
height
|
|
width
;
centerX
=
centerX
|
|
width
/
2
;
centerY
=
centerY
|
|
height
/
2
;
radius
=
radius
|
|
(
width
+
height
)
/
4
;
let
isPlaceholder
=
false
;
data
=
data
?
data
.
filter
(
e
=
>
e
.
size
>
EPSILON
)
:
null
;
if
(
!
data
)
{
data
=
loadingPieChartData
(
)
;
isPlaceholder
=
true
;
}
if
(
!
data
.
length
)
{
data
=
emptyPieChartData
(
)
;
isPlaceholder
=
true
;
}
const
container
=
document
.
createElementNS
(
SVG_NS
"
svg
"
)
;
container
.
setAttribute
(
"
class
"
"
generic
-
chart
-
container
pie
-
chart
-
container
"
)
;
container
.
setAttribute
(
"
pack
"
"
center
"
)
;
container
.
setAttribute
(
"
flex
"
"
1
"
)
;
container
.
setAttribute
(
"
width
"
width
)
;
container
.
setAttribute
(
"
height
"
height
)
;
container
.
setAttribute
(
"
viewBox
"
"
0
0
"
+
width
+
"
"
+
height
)
;
container
.
setAttribute
(
"
slices
"
data
.
length
)
;
container
.
setAttribute
(
"
placeholder
"
isPlaceholder
)
;
const
proxy
=
new
PieChart
(
container
)
;
const
total
=
data
.
reduce
(
(
acc
e
)
=
>
acc
+
e
.
size
0
)
;
const
angles
=
data
.
map
(
e
=
>
(
e
.
size
/
total
)
*
(
TAU
-
EPSILON
)
)
;
const
largest
=
data
.
reduce
(
(
a
b
)
=
>
(
a
.
size
>
b
.
size
?
a
:
b
)
)
;
const
smallest
=
data
.
reduce
(
(
a
b
)
=
>
(
a
.
size
<
b
.
size
?
a
:
b
)
)
;
const
textDistance
=
radius
/
NAMED_SLICE_TEXT_DISTANCE_RATIO
;
const
translateDistance
=
radius
/
HOVERED_SLICE_TRANSLATE_DISTANCE_RATIO
;
let
startAngle
=
TAU
;
let
endAngle
=
0
;
let
midAngle
=
0
;
radius
-
=
translateDistance
;
for
(
let
i
=
data
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
sliceInfo
=
data
[
i
]
;
const
sliceAngle
=
angles
[
i
]
;
if
(
!
sliceInfo
.
size
|
|
sliceAngle
<
EPSILON
)
{
continue
;
}
endAngle
=
startAngle
-
sliceAngle
;
midAngle
=
(
startAngle
+
endAngle
)
/
2
;
const
x1
=
centerX
+
radius
*
Math
.
sin
(
startAngle
)
;
const
y1
=
centerY
-
radius
*
Math
.
cos
(
startAngle
)
;
const
x2
=
centerX
+
radius
*
Math
.
sin
(
endAngle
)
;
const
y2
=
centerY
-
radius
*
Math
.
cos
(
endAngle
)
;
const
largeArcFlag
=
Math
.
abs
(
startAngle
-
endAngle
)
>
PI
?
1
:
0
;
const
pathNode
=
document
.
createElementNS
(
SVG_NS
"
path
"
)
;
pathNode
.
setAttribute
(
"
class
"
"
pie
-
chart
-
slice
chart
-
colored
-
blob
"
)
;
pathNode
.
setAttribute
(
"
name
"
sliceInfo
.
label
)
;
pathNode
.
setAttribute
(
"
d
"
"
M
"
+
centerX
+
"
"
+
centerY
+
"
L
"
+
x2
+
"
"
+
y2
+
"
A
"
+
radius
+
"
"
+
radius
+
"
0
"
+
largeArcFlag
+
"
1
"
+
x1
+
"
"
+
y1
+
"
Z
"
)
;
if
(
sliceInfo
=
=
largest
)
{
pathNode
.
setAttribute
(
"
largest
"
"
"
)
;
}
if
(
sliceInfo
=
=
smallest
)
{
pathNode
.
setAttribute
(
"
smallest
"
"
"
)
;
}
const
hoverX
=
translateDistance
*
Math
.
sin
(
midAngle
)
;
const
hoverY
=
-
translateDistance
*
Math
.
cos
(
midAngle
)
;
const
hoverTransform
=
"
transform
:
translate
(
"
+
hoverX
+
"
px
"
+
hoverY
+
"
px
)
"
;
pathNode
.
setAttribute
(
"
style
"
data
.
length
>
1
?
hoverTransform
:
"
"
)
;
proxy
.
slices
.
set
(
sliceInfo
pathNode
)
;
delegate
(
proxy
[
"
click
"
"
mouseover
"
"
mouseout
"
]
pathNode
sliceInfo
)
;
container
.
appendChild
(
pathNode
)
;
if
(
sliceInfo
.
label
&
&
sliceAngle
>
NAMED_SLICE_MIN_ANGLE
)
{
const
textX
=
centerX
+
textDistance
*
Math
.
sin
(
midAngle
)
;
const
textY
=
centerY
-
textDistance
*
Math
.
cos
(
midAngle
)
;
const
label
=
document
.
createElementNS
(
SVG_NS
"
text
"
)
;
label
.
appendChild
(
document
.
createTextNode
(
sliceInfo
.
label
)
)
;
label
.
setAttribute
(
"
class
"
"
pie
-
chart
-
label
"
)
;
label
.
setAttribute
(
"
style
"
data
.
length
>
1
?
hoverTransform
:
"
"
)
;
label
.
setAttribute
(
"
x
"
data
.
length
>
1
?
textX
:
centerX
)
;
label
.
setAttribute
(
"
y
"
data
.
length
>
1
?
textY
:
centerY
)
;
container
.
appendChild
(
label
)
;
}
startAngle
=
endAngle
;
}
return
proxy
;
}
function
createTableChart
(
document
{
title
data
strings
totals
header
}
)
{
strings
=
strings
|
|
{
}
;
totals
=
totals
|
|
{
}
;
header
=
header
|
|
{
}
;
let
isPlaceholder
=
false
;
if
(
!
data
)
{
data
=
loadingTableChartData
(
)
;
isPlaceholder
=
true
;
}
if
(
!
data
.
length
)
{
data
=
emptyTableChartData
(
)
;
isPlaceholder
=
true
;
}
const
container
=
document
.
createElement
(
"
div
"
)
;
container
.
className
=
"
generic
-
chart
-
container
table
-
chart
-
container
"
;
container
.
setAttribute
(
"
pack
"
"
center
"
)
;
container
.
setAttribute
(
"
flex
"
"
1
"
)
;
container
.
setAttribute
(
"
rows
"
data
.
length
)
;
container
.
setAttribute
(
"
placeholder
"
isPlaceholder
)
;
container
.
setAttribute
(
"
style
"
"
-
moz
-
box
-
orient
:
vertical
"
)
;
const
proxy
=
new
TableChart
(
container
)
;
const
titleNode
=
document
.
createElement
(
"
span
"
)
;
titleNode
.
className
=
"
plain
table
-
chart
-
title
"
;
titleNode
.
textContent
=
title
;
container
.
appendChild
(
titleNode
)
;
const
tableNode
=
document
.
createElement
(
"
div
"
)
;
tableNode
.
className
=
"
plain
table
-
chart
-
grid
"
;
tableNode
.
setAttribute
(
"
style
"
"
-
moz
-
box
-
orient
:
vertical
"
)
;
container
.
appendChild
(
tableNode
)
;
const
headerNode
=
document
.
createElement
(
"
div
"
)
;
headerNode
.
className
=
"
table
-
chart
-
row
"
;
const
headerBoxNode
=
document
.
createElement
(
"
div
"
)
;
headerBoxNode
.
className
=
"
table
-
chart
-
row
-
box
"
;
headerNode
.
appendChild
(
headerBoxNode
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
header
)
)
{
const
headerLabelNode
=
document
.
createElement
(
"
span
"
)
;
headerLabelNode
.
className
=
"
plain
table
-
chart
-
row
-
label
"
;
headerLabelNode
.
setAttribute
(
"
name
"
key
)
;
headerLabelNode
.
textContent
=
value
;
headerNode
.
appendChild
(
headerLabelNode
)
;
}
tableNode
.
appendChild
(
headerNode
)
;
for
(
const
rowInfo
of
data
)
{
const
rowNode
=
document
.
createElement
(
"
div
"
)
;
rowNode
.
className
=
"
table
-
chart
-
row
"
;
rowNode
.
setAttribute
(
"
align
"
"
center
"
)
;
const
boxNode
=
document
.
createElement
(
"
div
"
)
;
boxNode
.
className
=
"
table
-
chart
-
row
-
box
chart
-
colored
-
blob
"
;
boxNode
.
setAttribute
(
"
name
"
rowInfo
.
label
)
;
rowNode
.
appendChild
(
boxNode
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
rowInfo
)
)
{
const
index
=
data
.
indexOf
(
rowInfo
)
;
const
stringified
=
strings
[
key
]
?
strings
[
key
]
(
value
index
)
:
value
;
const
labelNode
=
document
.
createElement
(
"
span
"
)
;
labelNode
.
className
=
"
plain
table
-
chart
-
row
-
label
"
;
labelNode
.
setAttribute
(
"
name
"
key
)
;
labelNode
.
textContent
=
stringified
;
rowNode
.
appendChild
(
labelNode
)
;
}
proxy
.
rows
.
set
(
rowInfo
rowNode
)
;
delegate
(
proxy
[
"
click
"
"
mouseover
"
"
mouseout
"
]
rowNode
rowInfo
)
;
tableNode
.
appendChild
(
rowNode
)
;
}
const
totalsNode
=
document
.
createElement
(
"
div
"
)
;
totalsNode
.
className
=
"
table
-
chart
-
totals
"
;
totalsNode
.
setAttribute
(
"
style
"
"
-
moz
-
box
-
orient
:
vertical
"
)
;
for
(
const
[
key
value
]
of
Object
.
entries
(
totals
)
)
{
const
total
=
data
.
reduce
(
(
acc
e
)
=
>
acc
+
e
[
key
]
0
)
;
const
stringified
=
value
?
value
(
total
|
|
0
)
:
total
;
const
labelNode
=
document
.
createElement
(
"
span
"
)
;
labelNode
.
className
=
"
plain
table
-
chart
-
summary
-
label
"
;
labelNode
.
setAttribute
(
"
name
"
key
)
;
labelNode
.
textContent
=
stringified
;
totalsNode
.
appendChild
(
labelNode
)
;
}
container
.
appendChild
(
totalsNode
)
;
return
proxy
;
}
function
loadingPieChartData
(
)
{
return
[
{
size
:
1
label
:
L10N
.
getStr
(
"
pieChart
.
loading
"
)
}
]
;
}
function
emptyPieChartData
(
)
{
return
[
{
size
:
1
label
:
L10N
.
getStr
(
"
pieChart
.
unavailable
"
)
}
]
;
}
function
loadingTableChartData
(
)
{
return
[
{
size
:
"
"
label
:
L10N
.
getStr
(
"
tableChart
.
loading
"
)
}
]
;
}
function
emptyTableChartData
(
)
{
return
[
{
size
:
"
"
label
:
L10N
.
getStr
(
"
tableChart
.
unavailable
"
)
}
]
;
}
function
delegate
(
emitter
events
node
args
)
{
for
(
const
event
of
events
)
{
node
.
addEventListener
(
event
emitter
.
emit
.
bind
(
emitter
event
args
)
)
;
}
}
exports
.
Chart
=
Chart
;
