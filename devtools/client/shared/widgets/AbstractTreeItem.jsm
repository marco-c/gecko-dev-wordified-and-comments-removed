"
use
strict
"
;
const
{
require
loader
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
{
ViewHelpers
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
AbstractTreeItem
"
]
;
function
AbstractTreeItem
(
{
parent
level
}
)
{
this
.
_rootItem
=
parent
?
parent
.
_rootItem
:
this
;
this
.
_parentItem
=
parent
;
this
.
_level
=
level
|
|
0
;
this
.
_childTreeItems
=
[
]
;
if
(
this
=
=
this
.
_rootItem
)
{
EventEmitter
.
decorate
(
this
)
;
}
}
this
.
AbstractTreeItem
=
AbstractTreeItem
;
AbstractTreeItem
.
prototype
=
{
_containerNode
:
null
_targetNode
:
null
_arrowNode
:
null
_constructed
:
false
_populated
:
false
_expanded
:
false
autoExpandDepth
:
0
_displaySelf
:
function
(
document
arrowNode
)
{
throw
new
Error
(
"
The
_displaySelf
method
needs
to
be
implemented
by
inheriting
classes
.
"
)
;
}
_populateSelf
:
function
(
children
)
{
throw
new
Error
(
"
The
_populateSelf
method
needs
to
be
implemented
by
inheriting
classes
.
"
)
;
}
get
document
(
)
{
return
this
.
_containerNode
.
ownerDocument
;
}
get
root
(
)
{
return
this
.
_rootItem
;
}
get
parent
(
)
{
return
this
.
_parentItem
;
}
get
level
(
)
{
return
this
.
_level
;
}
get
target
(
)
{
return
this
.
_targetNode
;
}
get
container
(
)
{
return
this
.
_containerNode
;
}
get
populated
(
)
{
return
this
.
_populated
;
}
get
expanded
(
)
{
return
this
.
_expanded
;
}
get
bounds
(
)
{
const
win
=
this
.
document
.
defaultView
;
const
utils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
return
utils
.
getBoundsWithoutFlushing
(
this
.
_containerNode
)
;
}
attachTo
:
function
(
containerNode
fragmentNode
=
containerNode
beforeNode
=
null
)
{
this
.
_containerNode
=
containerNode
;
this
.
_constructTargetNode
(
)
;
if
(
beforeNode
)
{
fragmentNode
.
insertBefore
(
this
.
_targetNode
beforeNode
)
;
}
else
{
fragmentNode
.
appendChild
(
this
.
_targetNode
)
;
}
if
(
this
.
_level
<
this
.
autoExpandDepth
)
{
this
.
expand
(
)
;
}
}
remove
:
function
(
)
{
this
.
_targetNode
.
remove
(
)
;
this
.
_hideChildren
(
)
;
this
.
_childTreeItems
.
length
=
0
;
}
focus
:
function
(
)
{
this
.
_targetNode
.
focus
(
)
;
}
expand
:
function
(
)
{
if
(
this
.
_expanded
)
{
return
;
}
this
.
_expanded
=
true
;
this
.
_arrowNode
.
setAttribute
(
"
open
"
"
"
)
;
this
.
_targetNode
.
setAttribute
(
"
expanded
"
"
"
)
;
this
.
_toggleChildren
(
true
)
;
this
.
_rootItem
.
emit
(
"
expand
"
this
)
;
}
collapse
:
function
(
)
{
if
(
!
this
.
_expanded
)
{
return
;
}
this
.
_expanded
=
false
;
this
.
_arrowNode
.
removeAttribute
(
"
open
"
)
;
this
.
_targetNode
.
removeAttribute
(
"
expanded
"
"
"
)
;
this
.
_toggleChildren
(
false
)
;
this
.
_rootItem
.
emit
(
"
collapse
"
this
)
;
}
getChild
:
function
(
index
=
0
)
{
return
this
.
_childTreeItems
[
index
]
;
}
traverse
:
function
(
cb
)
{
for
(
const
child
of
this
.
_childTreeItems
)
{
cb
(
child
)
;
child
.
bfs
(
)
;
}
}
find
:
function
(
predicate
)
{
for
(
const
child
of
this
.
_childTreeItems
)
{
if
(
predicate
(
child
)
|
|
child
.
find
(
predicate
)
)
{
return
child
;
}
}
return
null
;
}
_toggleChildren
:
function
(
visible
)
{
if
(
visible
)
{
if
(
!
this
.
_populated
)
{
this
.
_populateSelf
(
this
.
_childTreeItems
)
;
this
.
_populated
=
this
.
_childTreeItems
.
length
>
0
;
}
this
.
_showChildren
(
)
;
}
else
{
this
.
_hideChildren
(
)
;
}
}
_showChildren
:
function
(
)
{
if
(
this
=
=
this
.
_rootItem
&
&
this
.
autoExpandDepth
=
=
0
)
{
this
.
_appendChildrenBatch
(
)
;
}
else
{
this
.
_appendChildrenSuccessive
(
)
;
}
}
_hideChildren
:
function
(
)
{
for
(
const
item
of
this
.
_childTreeItems
)
{
item
.
_targetNode
.
remove
(
)
;
item
.
_hideChildren
(
)
;
}
}
_appendChildrenBatch
:
function
(
)
{
if
(
this
.
_fragment
=
=
=
undefined
)
{
this
.
_fragment
=
this
.
document
.
createDocumentFragment
(
)
;
}
const
childTreeItems
=
this
.
_childTreeItems
;
for
(
let
i
=
0
len
=
childTreeItems
.
length
;
i
<
len
;
i
+
+
)
{
childTreeItems
[
i
]
.
attachTo
(
this
.
_containerNode
this
.
_fragment
)
;
}
this
.
_containerNode
.
appendChild
(
this
.
_fragment
)
;
}
_appendChildrenSuccessive
:
function
(
)
{
const
childTreeItems
=
this
.
_childTreeItems
;
const
expandedChildTreeItems
=
childTreeItems
.
filter
(
e
=
>
e
.
_expanded
)
;
const
nextNode
=
this
.
_getSiblingAtDelta
(
1
)
;
for
(
let
i
=
0
len
=
childTreeItems
.
length
;
i
<
len
;
i
+
+
)
{
childTreeItems
[
i
]
.
attachTo
(
this
.
_containerNode
undefined
nextNode
)
;
}
for
(
let
i
=
0
len
=
expandedChildTreeItems
.
length
;
i
<
len
;
i
+
+
)
{
expandedChildTreeItems
[
i
]
.
_showChildren
(
)
;
}
}
_constructTargetNode
:
function
(
)
{
if
(
this
.
_constructed
)
{
return
;
}
this
.
_onArrowClick
=
this
.
_onArrowClick
.
bind
(
this
)
;
this
.
_onClick
=
this
.
_onClick
.
bind
(
this
)
;
this
.
_onDoubleClick
=
this
.
_onDoubleClick
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
_onFocus
=
this
.
_onFocus
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
const
document
=
this
.
document
;
const
arrowNode
=
this
.
_arrowNode
=
document
.
createElement
(
"
hbox
"
)
;
arrowNode
.
className
=
"
arrow
theme
-
twisty
"
;
arrowNode
.
addEventListener
(
"
mousedown
"
this
.
_onArrowClick
)
;
const
targetNode
=
this
.
_targetNode
=
this
.
_displaySelf
(
document
arrowNode
)
;
targetNode
.
style
.
MozUserFocus
=
"
normal
"
;
targetNode
.
addEventListener
(
"
mousedown
"
this
.
_onClick
)
;
targetNode
.
addEventListener
(
"
dblclick
"
this
.
_onDoubleClick
)
;
targetNode
.
addEventListener
(
"
keydown
"
this
.
_onKeyDown
)
;
targetNode
.
addEventListener
(
"
focus
"
this
.
_onFocus
)
;
targetNode
.
addEventListener
(
"
blur
"
this
.
_onBlur
)
;
this
.
_constructed
=
true
;
}
_getSiblingAtDelta
:
function
(
delta
)
{
const
childNodes
=
this
.
_containerNode
.
childNodes
;
const
indexOfSelf
=
Array
.
indexOf
(
childNodes
this
.
_targetNode
)
;
if
(
indexOfSelf
+
delta
>
=
0
)
{
return
childNodes
[
indexOfSelf
+
delta
]
;
}
return
undefined
;
}
_getNodesPerPageSize
:
function
(
)
{
const
childNodes
=
this
.
_containerNode
.
childNodes
;
const
nodeHeight
=
this
.
_getHeight
(
childNodes
[
childNodes
.
length
-
1
]
)
;
const
containerHeight
=
this
.
bounds
.
height
;
return
Math
.
ceil
(
containerHeight
/
nodeHeight
)
;
}
_getHeight
:
function
(
elem
)
{
const
win
=
this
.
document
.
defaultView
;
const
utils
=
win
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
return
utils
.
getBoundsWithoutFlushing
(
elem
)
.
height
;
}
_focusFirstNode
:
function
(
)
{
const
childNodes
=
this
.
_containerNode
.
childNodes
;
for
(
let
i
=
0
;
i
<
childNodes
.
length
;
i
+
+
)
{
if
(
this
.
_getHeight
(
childNodes
[
i
]
)
)
{
childNodes
[
i
]
.
focus
(
)
;
return
;
}
}
}
_focusLastNode
:
function
(
)
{
const
childNodes
=
this
.
_containerNode
.
childNodes
;
childNodes
[
childNodes
.
length
-
1
]
.
focus
(
)
;
}
_focusNextNode
:
function
(
)
{
const
nextElement
=
this
.
_getSiblingAtDelta
(
1
)
;
if
(
nextElement
)
{
nextElement
.
focus
(
)
;
}
}
_focusPrevNode
:
function
(
)
{
const
prevElement
=
this
.
_getSiblingAtDelta
(
-
1
)
;
if
(
prevElement
)
{
prevElement
.
focus
(
)
;
}
}
_focusParentNode
:
function
(
)
{
const
parentItem
=
this
.
_parentItem
;
if
(
parentItem
)
{
parentItem
.
focus
(
)
;
}
}
_onArrowClick
:
function
(
e
)
{
if
(
!
this
.
_expanded
)
{
this
.
expand
(
)
;
}
else
{
this
.
collapse
(
)
;
}
}
_onClick
:
function
(
e
)
{
e
.
stopPropagation
(
)
;
this
.
focus
(
)
;
}
_onDoubleClick
:
function
(
e
)
{
if
(
!
e
.
target
.
classList
.
contains
(
"
arrow
"
)
)
{
this
.
_onArrowClick
(
e
)
;
}
this
.
focus
(
)
;
}
_onKeyDown
:
function
(
e
)
{
ViewHelpers
.
preventScrolling
(
e
)
;
switch
(
e
.
keyCode
)
{
case
KeyCodes
.
DOM_VK_UP
:
this
.
_focusPrevNode
(
)
;
return
;
case
KeyCodes
.
DOM_VK_DOWN
:
this
.
_focusNextNode
(
)
;
return
;
case
KeyCodes
.
DOM_VK_LEFT
:
if
(
this
.
_expanded
&
&
this
.
_populated
)
{
this
.
collapse
(
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
KeyCodes
.
DOM_VK_RIGHT
:
if
(
!
this
.
_expanded
)
{
this
.
expand
(
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
;
case
KeyCodes
.
DOM_VK_PAGE_UP
:
const
pageUpElement
=
this
.
_getSiblingAtDelta
(
-
this
.
_getNodesPerPageSize
(
)
)
;
if
(
pageUpElement
&
&
this
.
_getHeight
(
pageUpElement
)
)
{
pageUpElement
.
focus
(
)
;
}
else
{
this
.
_focusFirstNode
(
)
;
}
return
;
case
KeyCodes
.
DOM_VK_PAGE_DOWN
:
const
pageDownElement
=
this
.
_getSiblingAtDelta
(
this
.
_getNodesPerPageSize
(
)
)
;
if
(
pageDownElement
)
{
pageDownElement
.
focus
(
)
;
}
else
{
this
.
_focusLastNode
(
)
;
}
return
;
case
KeyCodes
.
DOM_VK_HOME
:
this
.
_focusFirstNode
(
)
;
return
;
case
KeyCodes
.
DOM_VK_END
:
this
.
_focusLastNode
(
)
;
}
}
_onFocus
:
function
(
e
)
{
this
.
_rootItem
.
emit
(
"
focus
"
this
)
;
}
_onBlur
:
function
(
e
)
{
this
.
_rootItem
.
emit
(
"
blur
"
this
)
;
}
}
;
