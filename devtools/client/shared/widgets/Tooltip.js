"
use
strict
"
;
const
{
Cu
Ci
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
Spectrum
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
Spectrum
"
)
;
const
{
CubicBezierWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
CubicBezierWidget
"
)
;
const
{
MdnDocsWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
MdnDocsWidget
"
)
;
const
{
CSSFilterEditorWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
FilterWidget
"
)
;
const
{
TooltipToggle
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
TooltipToggle
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
client
/
shared
/
css
-
color
"
)
;
const
Heritage
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
Eyedropper
}
=
require
(
"
devtools
/
client
/
eyedropper
/
eyedropper
"
)
;
const
Services
=
require
(
"
Services
"
)
;
loader
.
lazyRequireGetter
(
this
"
beautify
"
"
devtools
/
shared
/
jsbeautify
/
beautify
"
)
;
loader
.
lazyRequireGetter
(
this
"
setNamedTimeout
"
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
clearNamedTimeout
"
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
setNamedTimeout
"
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
true
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
VariablesViewController
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
SPECTRUM_FRAME
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
spectrum
-
frame
.
xhtml
"
;
const
CUBIC_BEZIER_FRAME
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
cubic
-
bezier
-
frame
.
xhtml
"
;
const
MDN_DOCS_FRAME
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
mdn
-
docs
-
frame
.
xhtml
"
;
const
FILTER_FRAME
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
filter
-
frame
.
xhtml
"
;
const
ESCAPE_KEYCODE
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_ESCAPE
;
const
RETURN_KEYCODE
=
Ci
.
nsIDOMKeyEvent
.
DOM_VK_RETURN
;
const
POPUP_EVENTS
=
[
"
shown
"
"
hidden
"
"
showing
"
"
hiding
"
]
;
function
OptionsStore
(
defaults
options
)
{
this
.
defaults
=
defaults
|
|
{
}
;
this
.
options
=
options
|
|
{
}
;
}
OptionsStore
.
prototype
=
{
get
:
function
(
name
)
{
if
(
typeof
this
.
options
[
name
]
!
=
=
"
undefined
"
)
{
return
this
.
options
[
name
]
;
}
return
this
.
defaults
[
name
]
;
}
}
;
var
PanelFactory
=
{
get
:
function
(
doc
options
)
{
let
panel
=
doc
.
createElement
(
"
panel
"
)
;
panel
.
setAttribute
(
"
hidden
"
true
)
;
panel
.
setAttribute
(
"
ignorekeys
"
true
)
;
panel
.
setAttribute
(
"
animate
"
false
)
;
panel
.
setAttribute
(
"
consumeoutsideclicks
"
options
.
get
(
"
consumeOutsideClick
"
)
)
;
panel
.
setAttribute
(
"
noautofocus
"
options
.
get
(
"
noAutoFocus
"
)
)
;
panel
.
setAttribute
(
"
type
"
"
arrow
"
)
;
panel
.
setAttribute
(
"
level
"
"
top
"
)
;
panel
.
setAttribute
(
"
class
"
"
devtools
-
tooltip
theme
-
tooltip
-
panel
"
)
;
doc
.
querySelector
(
"
window
"
)
.
appendChild
(
panel
)
;
return
panel
;
}
}
;
function
Tooltip
(
doc
options
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
doc
=
doc
;
this
.
options
=
new
OptionsStore
(
{
consumeOutsideClick
:
false
closeOnKeys
:
[
ESCAPE_KEYCODE
]
noAutoFocus
:
true
closeOnEvents
:
[
]
}
options
)
;
this
.
panel
=
PanelFactory
.
get
(
doc
this
.
options
)
;
this
.
_toggle
=
new
TooltipToggle
(
this
)
;
this
.
startTogglingOnHover
=
this
.
_toggle
.
start
.
bind
(
this
.
_toggle
)
;
this
.
stopTogglingOnHover
=
this
.
_toggle
.
stop
.
bind
(
this
.
_toggle
)
;
for
(
let
eventName
of
POPUP_EVENTS
)
{
this
[
"
_onPopup
"
+
eventName
]
=
(
name
=
>
{
return
e
=
>
{
if
(
e
.
target
=
=
=
this
.
panel
)
{
this
.
emit
(
name
)
;
}
}
;
}
)
(
eventName
)
;
this
.
panel
.
addEventListener
(
"
popup
"
+
eventName
this
[
"
_onPopup
"
+
eventName
]
false
)
;
}
let
win
=
this
.
doc
.
querySelector
(
"
window
"
)
;
this
.
_onKeyPress
=
event
=
>
{
if
(
this
.
panel
.
hidden
)
{
return
;
}
this
.
emit
(
"
keypress
"
event
.
keyCode
)
;
if
(
this
.
options
.
get
(
"
closeOnKeys
"
)
.
indexOf
(
event
.
keyCode
)
!
=
=
-
1
&
&
this
.
isShown
(
)
)
{
event
.
stopPropagation
(
)
;
this
.
hide
(
)
;
}
}
;
win
.
addEventListener
(
"
keypress
"
this
.
_onKeyPress
false
)
;
this
.
hide
=
this
.
hide
.
bind
(
this
)
;
let
closeOnEvents
=
this
.
options
.
get
(
"
closeOnEvents
"
)
;
for
(
let
{
emitter
event
useCapture
}
of
closeOnEvents
)
{
for
(
let
add
of
[
"
addEventListener
"
"
on
"
]
)
{
if
(
add
in
emitter
)
{
emitter
[
add
]
(
event
this
.
hide
useCapture
)
;
break
;
}
}
}
}
module
.
exports
.
Tooltip
=
Tooltip
;
Tooltip
.
prototype
=
{
defaultPosition
:
"
before_start
"
defaultOffsetX
:
0
defaultOffsetY
:
0
show
:
function
(
anchor
position
=
this
.
defaultPosition
x
=
this
.
defaultOffsetX
y
=
this
.
defaultOffsetY
)
{
this
.
panel
.
hidden
=
false
;
this
.
panel
.
openPopup
(
anchor
position
x
y
)
;
}
hide
:
function
(
)
{
this
.
panel
.
hidden
=
true
;
this
.
panel
.
hidePopup
(
)
;
}
isShown
:
function
(
)
{
return
this
.
panel
&
&
this
.
panel
.
state
!
=
=
"
closed
"
&
&
this
.
panel
.
state
!
=
=
"
hiding
"
;
}
setSize
:
function
(
width
height
)
{
this
.
panel
.
sizeTo
(
width
height
)
;
}
empty
:
function
(
)
{
while
(
this
.
panel
.
hasChildNodes
(
)
)
{
this
.
panel
.
removeChild
(
this
.
panel
.
firstChild
)
;
}
}
isHidden
:
function
(
)
{
return
this
.
panel
.
state
=
=
"
closed
"
|
|
this
.
panel
.
state
=
=
"
hiding
"
;
}
isEmpty
:
function
(
)
{
return
!
this
.
panel
.
hasChildNodes
(
)
;
}
destroy
:
function
(
)
{
this
.
hide
(
)
;
for
(
let
eventName
of
POPUP_EVENTS
)
{
this
.
panel
.
removeEventListener
(
"
popup
"
+
eventName
this
[
"
_onPopup
"
+
eventName
]
false
)
;
}
let
win
=
this
.
doc
.
querySelector
(
"
window
"
)
;
win
.
removeEventListener
(
"
keypress
"
this
.
_onKeyPress
false
)
;
let
closeOnEvents
=
this
.
options
.
get
(
"
closeOnEvents
"
)
;
for
(
let
{
emitter
event
useCapture
}
of
closeOnEvents
)
{
for
(
let
remove
of
[
"
removeEventListener
"
"
off
"
]
)
{
if
(
remove
in
emitter
)
{
emitter
[
remove
]
(
event
this
.
hide
useCapture
)
;
break
;
}
}
}
this
.
content
=
null
;
this
.
_toggle
.
destroy
(
)
;
this
.
doc
=
null
;
this
.
panel
.
remove
(
)
;
this
.
panel
=
null
;
}
get
container
(
)
{
return
this
.
panel
;
}
set
content
(
content
)
{
if
(
this
.
content
=
=
content
)
{
return
;
}
this
.
empty
(
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
"
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
-
no
-
min
-
height
"
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
-
no
-
max
-
or
-
min
-
height
"
)
;
this
.
panel
.
removeAttribute
(
"
wide
"
)
;
if
(
content
)
{
this
.
panel
.
appendChild
(
content
)
;
}
}
get
content
(
)
{
return
this
.
panel
.
firstChild
;
}
setTextContent
:
function
(
{
messages
messagesClass
containerClass
isAlertTooltip
}
extraButtons
=
[
]
)
{
messagesClass
=
messagesClass
|
|
"
default
-
tooltip
-
simple
-
text
-
colors
"
;
containerClass
=
containerClass
|
|
"
default
-
tooltip
-
simple
-
text
-
colors
"
;
let
vbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
vbox
.
className
=
"
devtools
-
tooltip
-
simple
-
text
-
container
"
+
containerClass
;
vbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
for
(
let
text
of
messages
)
{
let
description
=
this
.
doc
.
createElement
(
"
description
"
)
;
description
.
setAttribute
(
"
flex
"
"
1
"
)
;
description
.
className
=
"
devtools
-
tooltip
-
simple
-
text
"
+
messagesClass
;
description
.
textContent
=
text
;
vbox
.
appendChild
(
description
)
;
}
for
(
let
{
label
className
command
}
of
extraButtons
)
{
let
button
=
this
.
doc
.
createElement
(
"
button
"
)
;
button
.
className
=
className
;
button
.
setAttribute
(
"
label
"
label
)
;
button
.
addEventListener
(
"
command
"
command
)
;
vbox
.
appendChild
(
button
)
;
}
if
(
isAlertTooltip
)
{
let
hbox
=
this
.
doc
.
createElement
(
"
hbox
"
)
;
hbox
.
setAttribute
(
"
align
"
"
start
"
)
;
let
alertImg
=
this
.
doc
.
createElement
(
"
image
"
)
;
alertImg
.
className
=
"
devtools
-
tooltip
-
alert
-
icon
"
;
hbox
.
appendChild
(
alertImg
)
;
hbox
.
appendChild
(
vbox
)
;
this
.
content
=
hbox
;
}
else
{
this
.
content
=
vbox
;
}
}
setVariableContent
:
function
(
objectActor
viewOptions
=
{
}
controllerOptions
=
{
}
relayEvents
=
{
}
extraButtons
=
[
]
toolbox
=
null
)
{
let
vbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
vbox
.
className
=
"
devtools
-
tooltip
-
variables
-
view
-
box
"
;
vbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
let
innerbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
innerbox
.
className
=
"
devtools
-
tooltip
-
variables
-
view
-
innerbox
"
;
innerbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
vbox
.
appendChild
(
innerbox
)
;
for
(
let
{
label
className
command
}
of
extraButtons
)
{
let
button
=
this
.
doc
.
createElement
(
"
button
"
)
;
button
.
className
=
className
;
button
.
setAttribute
(
"
label
"
label
)
;
button
.
addEventListener
(
"
command
"
command
)
;
vbox
.
appendChild
(
button
)
;
}
let
widget
=
new
VariablesView
(
innerbox
viewOptions
)
;
if
(
toolbox
)
{
widget
.
toolbox
=
toolbox
;
}
widget
.
commitHierarchy
=
(
)
=
>
{
}
;
for
(
let
e
in
relayEvents
)
{
widget
.
on
(
e
relayEvents
[
e
]
)
;
}
VariablesViewController
.
attach
(
widget
controllerOptions
)
;
widget
.
searchPlaceholder
=
viewOptions
.
searchPlaceholder
;
widget
.
searchEnabled
=
viewOptions
.
searchEnabled
;
widget
.
controller
.
setSingleVariable
(
{
objectActor
:
objectActor
}
controllerOptions
)
;
this
.
content
=
vbox
;
this
.
panel
.
setAttribute
(
"
clamped
-
dimensions
"
"
"
)
;
}
setBrokenImageContent
:
function
(
)
{
this
.
setTextContent
(
{
messages
:
[
l10n
.
strings
.
GetStringFromName
(
"
previewTooltip
.
image
.
brokenImage
"
)
]
}
)
;
}
setImageContent
:
function
(
imageUrl
options
=
{
}
)
{
if
(
!
imageUrl
)
{
return
;
}
let
vbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
vbox
.
setAttribute
(
"
align
"
"
center
"
)
;
let
image
=
this
.
doc
.
createElement
(
"
image
"
)
;
image
.
setAttribute
(
"
src
"
imageUrl
)
;
if
(
options
.
maxDim
)
{
image
.
style
.
maxWidth
=
options
.
maxDim
+
"
px
"
;
image
.
style
.
maxHeight
=
options
.
maxDim
+
"
px
"
;
}
vbox
.
appendChild
(
image
)
;
if
(
!
options
.
hideDimensionLabel
)
{
let
label
=
this
.
doc
.
createElement
(
"
label
"
)
;
label
.
classList
.
add
(
"
devtools
-
tooltip
-
caption
"
)
;
label
.
classList
.
add
(
"
theme
-
comment
"
)
;
if
(
options
.
naturalWidth
&
&
options
.
naturalHeight
)
{
label
.
textContent
=
this
.
_getImageDimensionLabel
(
options
.
naturalWidth
options
.
naturalHeight
)
;
}
else
{
label
.
textContent
=
l10n
.
strings
.
GetStringFromName
(
"
previewTooltip
.
image
.
brokenImage
"
)
;
let
imgObj
=
new
this
.
doc
.
defaultView
.
Image
(
)
;
imgObj
.
src
=
imageUrl
;
imgObj
.
onload
=
(
)
=
>
{
imgObj
.
onload
=
null
;
label
.
textContent
=
this
.
_getImageDimensionLabel
(
imgObj
.
naturalWidth
imgObj
.
naturalHeight
)
;
}
;
}
vbox
.
appendChild
(
label
)
;
}
this
.
content
=
vbox
;
}
_getImageDimensionLabel
:
(
w
h
)
=
>
w
+
"
\
u00D7
"
+
h
setIFrameContent
:
function
(
{
width
height
}
url
)
{
let
def
=
promise
.
defer
(
)
;
let
iframe
=
this
.
doc
.
createElementNS
(
XHTML_NS
"
iframe
"
)
;
iframe
.
setAttribute
(
"
transparent
"
true
)
;
iframe
.
setAttribute
(
"
width
"
width
)
;
iframe
.
setAttribute
(
"
height
"
height
)
;
iframe
.
setAttribute
(
"
flex
"
"
1
"
)
;
iframe
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
iframe
.
setAttribute
(
"
class
"
"
devtools
-
tooltip
-
iframe
"
)
;
function
onLoad
(
)
{
iframe
.
removeEventListener
(
"
load
"
onLoad
true
)
;
def
.
resolve
(
iframe
)
;
}
iframe
.
addEventListener
(
"
load
"
onLoad
true
)
;
iframe
.
setAttribute
(
"
src
"
url
)
;
this
.
content
=
iframe
;
return
def
.
promise
;
}
setColorPickerContent
:
function
(
color
)
{
let
dimensions
=
{
width
:
"
210
"
height
:
"
216
"
}
;
let
panel
=
this
.
panel
;
return
this
.
setIFrameContent
(
dimensions
SPECTRUM_FRAME
)
.
then
(
onLoaded
)
;
function
onLoaded
(
iframe
)
{
let
win
=
iframe
.
contentWindow
.
wrappedJSObject
;
let
def
=
promise
.
defer
(
)
;
let
container
=
win
.
document
.
getElementById
(
"
spectrum
"
)
;
let
spectrum
=
new
Spectrum
(
container
color
)
;
function
finalizeSpectrum
(
)
{
spectrum
.
show
(
)
;
def
.
resolve
(
spectrum
)
;
}
if
(
panel
.
state
=
=
"
open
"
)
{
finalizeSpectrum
(
)
;
}
else
{
panel
.
addEventListener
(
"
popupshown
"
function
shown
(
)
{
panel
.
removeEventListener
(
"
popupshown
"
shown
true
)
;
finalizeSpectrum
(
)
;
}
true
)
;
}
return
def
.
promise
;
}
}
setCubicBezierContent
:
function
(
bezier
)
{
let
dimensions
=
{
width
:
"
500
"
height
:
"
360
"
}
;
let
panel
=
this
.
panel
;
return
this
.
setIFrameContent
(
dimensions
CUBIC_BEZIER_FRAME
)
.
then
(
onLoaded
)
;
function
onLoaded
(
iframe
)
{
let
win
=
iframe
.
contentWindow
.
wrappedJSObject
;
let
def
=
promise
.
defer
(
)
;
let
container
=
win
.
document
.
getElementById
(
"
container
"
)
;
let
widget
=
new
CubicBezierWidget
(
container
bezier
)
;
if
(
panel
.
state
=
=
"
open
"
)
{
def
.
resolve
(
widget
)
;
}
else
{
panel
.
addEventListener
(
"
popupshown
"
function
shown
(
)
{
panel
.
removeEventListener
(
"
popupshown
"
shown
true
)
;
def
.
resolve
(
widget
)
;
}
true
)
;
}
return
def
.
promise
;
}
}
setFilterContent
:
function
(
filter
)
{
let
dimensions
=
{
width
:
"
500
"
height
:
"
200
"
}
;
let
panel
=
this
.
panel
;
return
this
.
setIFrameContent
(
dimensions
FILTER_FRAME
)
.
then
(
onLoaded
)
;
function
onLoaded
(
iframe
)
{
let
win
=
iframe
.
contentWindow
.
wrappedJSObject
;
let
def
=
promise
.
defer
(
)
;
let
container
=
win
.
document
.
getElementById
(
"
container
"
)
;
let
widget
=
new
CSSFilterEditorWidget
(
container
filter
)
;
if
(
panel
.
state
=
=
=
"
open
"
)
{
def
.
resolve
(
widget
)
;
}
else
{
panel
.
addEventListener
(
"
popupshown
"
function
shown
(
)
{
panel
.
removeEventListener
(
"
popupshown
"
shown
true
)
;
def
.
resolve
(
widget
)
;
}
true
)
;
}
return
def
.
promise
;
}
}
setMdnDocsContent
:
function
(
)
{
let
dimensions
=
{
width
:
"
410
"
height
:
"
300
"
}
;
return
this
.
setIFrameContent
(
dimensions
MDN_DOCS_FRAME
)
.
then
(
onLoaded
)
;
function
onLoaded
(
iframe
)
{
let
win
=
iframe
.
contentWindow
.
wrappedJSObject
;
let
widget
=
new
MdnDocsWidget
(
win
.
document
)
;
return
widget
;
}
}
}
;
function
SwatchBasedEditorTooltip
(
doc
)
{
this
.
tooltip
=
new
Tooltip
(
doc
{
consumeOutsideClick
:
true
closeOnKeys
:
[
ESCAPE_KEYCODE
RETURN_KEYCODE
]
noAutoFocus
:
false
}
)
;
this
.
_onTooltipKeypress
=
(
event
code
)
=
>
{
if
(
code
=
=
=
ESCAPE_KEYCODE
)
{
this
.
revert
(
)
;
}
else
if
(
code
=
=
=
RETURN_KEYCODE
)
{
this
.
commit
(
)
;
}
}
;
this
.
tooltip
.
on
(
"
keypress
"
this
.
_onTooltipKeypress
)
;
this
.
swatches
=
new
Map
(
)
;
this
.
activeSwatch
=
null
;
this
.
_onSwatchClick
=
this
.
_onSwatchClick
.
bind
(
this
)
;
}
SwatchBasedEditorTooltip
.
prototype
=
{
show
:
function
(
)
{
if
(
this
.
activeSwatch
)
{
this
.
tooltip
.
show
(
this
.
activeSwatch
"
topcenter
bottomleft
"
)
;
this
.
tooltip
.
once
(
"
hiding
"
(
)
=
>
{
if
(
!
this
.
_reverted
&
&
!
this
.
eyedropperOpen
)
{
this
.
commit
(
)
;
}
this
.
_reverted
=
false
;
}
)
;
this
.
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
if
(
!
this
.
eyedropperOpen
)
{
this
.
activeSwatch
=
null
;
}
}
)
;
}
}
hide
:
function
(
)
{
this
.
tooltip
.
hide
(
)
;
}
addSwatch
:
function
(
swatchEl
callbacks
=
{
}
)
{
if
(
!
callbacks
.
onShow
)
{
callbacks
.
onShow
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onPreview
)
{
callbacks
.
onPreview
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onRevert
)
{
callbacks
.
onRevert
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onCommit
)
{
callbacks
.
onCommit
=
function
(
)
{
}
;
}
this
.
swatches
.
set
(
swatchEl
{
callbacks
:
callbacks
}
)
;
swatchEl
.
addEventListener
(
"
click
"
this
.
_onSwatchClick
false
)
;
}
removeSwatch
:
function
(
swatchEl
)
{
if
(
this
.
swatches
.
has
(
swatchEl
)
)
{
if
(
this
.
activeSwatch
=
=
=
swatchEl
)
{
this
.
hide
(
)
;
this
.
activeSwatch
=
null
;
}
swatchEl
.
removeEventListener
(
"
click
"
this
.
_onSwatchClick
false
)
;
this
.
swatches
.
delete
(
swatchEl
)
;
}
}
_onSwatchClick
:
function
(
event
)
{
let
swatch
=
this
.
swatches
.
get
(
event
.
target
)
;
if
(
event
.
shiftKey
)
{
event
.
stopPropagation
(
)
;
return
;
}
if
(
swatch
)
{
this
.
activeSwatch
=
event
.
target
;
this
.
show
(
)
;
swatch
.
callbacks
.
onShow
(
)
;
event
.
stopPropagation
(
)
;
}
}
preview
:
function
(
value
)
{
if
(
this
.
activeSwatch
)
{
let
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
swatch
.
callbacks
.
onPreview
(
value
)
;
}
}
revert
:
function
(
)
{
if
(
this
.
activeSwatch
)
{
this
.
_reverted
=
true
;
let
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
this
.
tooltip
.
once
(
"
hiding
"
(
)
=
>
{
swatch
.
callbacks
.
onRevert
(
)
;
}
)
;
}
}
commit
:
function
(
)
{
if
(
this
.
activeSwatch
)
{
let
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
swatch
.
callbacks
.
onCommit
(
)
;
}
}
destroy
:
function
(
)
{
this
.
swatches
.
clear
(
)
;
this
.
activeSwatch
=
null
;
this
.
tooltip
.
off
(
"
keypress
"
this
.
_onTooltipKeypress
)
;
this
.
tooltip
.
destroy
(
)
;
}
}
;
function
SwatchColorPickerTooltip
(
doc
)
{
SwatchBasedEditorTooltip
.
call
(
this
doc
)
;
this
.
spectrum
=
this
.
tooltip
.
setColorPickerContent
(
[
0
0
0
1
]
)
;
this
.
_onSpectrumColorChange
=
this
.
_onSpectrumColorChange
.
bind
(
this
)
;
this
.
_openEyeDropper
=
this
.
_openEyeDropper
.
bind
(
this
)
;
}
module
.
exports
.
SwatchColorPickerTooltip
=
SwatchColorPickerTooltip
;
SwatchColorPickerTooltip
.
prototype
=
Heritage
.
extend
(
SwatchBasedEditorTooltip
.
prototype
{
show
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
show
.
call
(
this
)
;
if
(
this
.
activeSwatch
)
{
this
.
currentSwatchColor
=
this
.
activeSwatch
.
nextSibling
;
this
.
_originalColor
=
this
.
currentSwatchColor
.
textContent
;
let
color
=
this
.
activeSwatch
.
style
.
backgroundColor
;
this
.
spectrum
.
then
(
spectrum
=
>
{
spectrum
.
off
(
"
changed
"
this
.
_onSpectrumColorChange
)
;
spectrum
.
rgb
=
this
.
_colorToRgba
(
color
)
;
spectrum
.
on
(
"
changed
"
this
.
_onSpectrumColorChange
)
;
spectrum
.
updateUI
(
)
;
}
)
;
}
let
tooltipDoc
=
this
.
tooltip
.
content
.
contentDocument
;
let
eyeButton
=
tooltipDoc
.
querySelector
(
"
#
eyedropper
-
button
"
)
;
eyeButton
.
addEventListener
(
"
click
"
this
.
_openEyeDropper
)
;
}
_onSpectrumColorChange
:
function
(
event
rgba
cssColor
)
{
this
.
_selectColor
(
cssColor
)
;
}
_selectColor
:
function
(
color
)
{
if
(
this
.
activeSwatch
)
{
this
.
activeSwatch
.
style
.
backgroundColor
=
color
;
this
.
activeSwatch
.
parentNode
.
dataset
.
color
=
color
;
color
=
this
.
_toDefaultType
(
color
)
;
this
.
currentSwatchColor
.
textContent
=
color
;
this
.
preview
(
color
)
;
if
(
this
.
eyedropperOpen
)
{
this
.
commit
(
)
;
}
}
}
_openEyeDropper
:
function
(
)
{
let
chromeWindow
=
this
.
tooltip
.
doc
.
defaultView
.
top
;
let
windowType
=
chromeWindow
.
document
.
documentElement
.
getAttribute
(
"
windowtype
"
)
;
let
toolboxWindow
;
if
(
windowType
!
=
"
navigator
:
browser
"
)
{
toolboxWindow
=
chromeWindow
;
chromeWindow
=
Services
.
wm
.
getMostRecentWindow
(
"
navigator
:
browser
"
)
;
chromeWindow
.
focus
(
)
;
}
let
dropper
=
new
Eyedropper
(
chromeWindow
{
copyOnSelect
:
false
context
:
"
picker
"
}
)
;
dropper
.
once
(
"
select
"
(
event
color
)
=
>
{
if
(
toolboxWindow
)
{
toolboxWindow
.
focus
(
)
;
}
this
.
_selectColor
(
color
)
;
}
)
;
dropper
.
once
(
"
destroy
"
(
)
=
>
{
this
.
eyedropperOpen
=
false
;
this
.
activeSwatch
=
null
;
}
)
;
dropper
.
open
(
)
;
this
.
eyedropperOpen
=
true
;
this
.
hide
(
)
;
this
.
tooltip
.
emit
(
"
eyedropper
-
opened
"
dropper
)
;
}
_colorToRgba
:
function
(
color
)
{
color
=
new
colorUtils
.
CssColor
(
color
)
;
let
rgba
=
color
.
_getRGBATuple
(
)
;
return
[
rgba
.
r
rgba
.
g
rgba
.
b
rgba
.
a
]
;
}
_toDefaultType
:
function
(
color
)
{
let
colorObj
=
new
colorUtils
.
CssColor
(
color
)
;
colorObj
.
setAuthoredUnitFromColor
(
this
.
_originalColor
)
;
return
colorObj
.
toString
(
)
;
}
destroy
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
destroy
.
call
(
this
)
;
this
.
currentSwatchColor
=
null
;
this
.
spectrum
.
then
(
spectrum
=
>
{
spectrum
.
off
(
"
changed
"
this
.
_onSpectrumColorChange
)
;
spectrum
.
destroy
(
)
;
}
)
;
}
}
)
;
function
SwatchCubicBezierTooltip
(
doc
)
{
SwatchBasedEditorTooltip
.
call
(
this
doc
)
;
this
.
widget
=
this
.
tooltip
.
setCubicBezierContent
(
[
0
0
1
1
]
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
}
module
.
exports
.
SwatchCubicBezierTooltip
=
SwatchCubicBezierTooltip
;
SwatchCubicBezierTooltip
.
prototype
=
Heritage
.
extend
(
SwatchBasedEditorTooltip
.
prototype
{
show
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
show
.
call
(
this
)
;
if
(
this
.
activeSwatch
)
{
this
.
currentBezierValue
=
this
.
activeSwatch
.
nextSibling
;
this
.
widget
.
then
(
widget
=
>
{
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
widget
.
cssCubicBezierValue
=
this
.
currentBezierValue
.
textContent
;
widget
.
on
(
"
updated
"
this
.
_onUpdate
)
;
}
)
;
}
}
_onUpdate
:
function
(
event
bezier
)
{
if
(
!
this
.
activeSwatch
)
{
return
;
}
this
.
currentBezierValue
.
textContent
=
bezier
+
"
"
;
this
.
preview
(
bezier
+
"
"
)
;
}
destroy
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
destroy
.
call
(
this
)
;
this
.
currentBezierValue
=
null
;
this
.
widget
.
then
(
widget
=
>
{
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
widget
.
destroy
(
)
;
}
)
;
}
}
)
;
function
CssDocsTooltip
(
doc
)
{
this
.
tooltip
=
new
Tooltip
(
doc
{
consumeOutsideClick
:
true
closeOnKeys
:
[
ESCAPE_KEYCODE
RETURN_KEYCODE
]
noAutoFocus
:
false
}
)
;
this
.
widget
=
this
.
tooltip
.
setMdnDocsContent
(
)
;
}
module
.
exports
.
CssDocsTooltip
=
CssDocsTooltip
;
CssDocsTooltip
.
prototype
=
{
show
:
function
(
anchor
propertyName
)
{
function
loadCssDocs
(
widget
)
{
return
widget
.
loadCssDocs
(
propertyName
)
;
}
this
.
widget
.
then
(
loadCssDocs
)
;
this
.
tooltip
.
show
(
anchor
"
topcenter
bottomleft
"
)
;
}
hide
:
function
(
)
{
this
.
tooltip
.
hide
(
)
;
}
destroy
:
function
(
)
{
this
.
tooltip
.
destroy
(
)
;
}
}
;
function
SwatchFilterTooltip
(
doc
)
{
SwatchBasedEditorTooltip
.
call
(
this
doc
)
;
this
.
widget
=
this
.
tooltip
.
setFilterContent
(
"
none
"
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
}
exports
.
SwatchFilterTooltip
=
SwatchFilterTooltip
;
SwatchFilterTooltip
.
prototype
=
Heritage
.
extend
(
SwatchBasedEditorTooltip
.
prototype
{
show
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
show
.
call
(
this
)
;
if
(
this
.
activeSwatch
)
{
this
.
currentFilterValue
=
this
.
activeSwatch
.
nextSibling
;
this
.
widget
.
then
(
widget
=
>
{
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
widget
.
on
(
"
updated
"
this
.
_onUpdate
)
;
widget
.
setCssValue
(
this
.
currentFilterValue
.
textContent
)
;
widget
.
render
(
)
;
}
)
;
}
}
_onUpdate
:
function
(
event
filters
)
{
if
(
!
this
.
activeSwatch
)
{
return
;
}
while
(
this
.
currentFilterValue
.
firstChild
)
{
this
.
currentFilterValue
.
firstChild
.
remove
(
)
;
}
let
node
=
this
.
_parser
.
parseCssProperty
(
"
filter
"
filters
this
.
_options
)
;
this
.
currentFilterValue
.
appendChild
(
node
)
;
this
.
preview
(
)
;
}
destroy
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
destroy
.
call
(
this
)
;
this
.
currentFilterValue
=
null
;
this
.
widget
.
then
(
widget
=
>
{
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
widget
.
destroy
(
)
;
}
)
;
}
addSwatch
:
function
(
swatchEl
callbacks
parser
options
)
{
SwatchBasedEditorTooltip
.
prototype
.
addSwatch
.
call
(
this
swatchEl
callbacks
)
;
this
.
_parser
=
parser
;
this
.
_options
=
options
;
}
}
)
;
function
L10N
(
)
{
}
L10N
.
prototype
=
{
}
;
var
l10n
=
new
L10N
(
)
;
loader
.
lazyGetter
(
L10N
.
prototype
"
strings
"
(
)
=
>
{
return
Services
.
strings
.
createBundle
(
"
chrome
:
/
/
devtools
/
locale
/
inspector
.
properties
"
)
;
}
)
;
