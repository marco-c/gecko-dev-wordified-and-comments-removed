"
use
strict
"
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
{
Spectrum
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
Spectrum
"
)
;
const
{
CubicBezierWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
CubicBezierWidget
"
)
;
const
{
CSSFilterEditorWidget
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
FilterWidget
"
)
;
const
{
TooltipToggle
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
TooltipToggle
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
-
color
"
)
;
const
Heritage
=
require
(
"
sdk
/
core
/
heritage
"
)
;
const
{
XPCOMUtils
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
HTMLTooltip
"
)
;
const
{
KeyShortcuts
}
=
require
(
"
devtools
/
client
/
shared
/
key
-
shortcuts
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
loader
.
lazyRequireGetter
(
this
"
beautify
"
"
devtools
/
shared
/
jsbeautify
/
beautify
"
)
;
loader
.
lazyRequireGetter
(
this
"
setNamedTimeout
"
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
clearNamedTimeout
"
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
setNamedTimeout
"
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
true
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
VariablesView
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
VariablesViewController
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
ESCAPE_KEYCODE
=
KeyCodes
.
DOM_VK_ESCAPE
;
const
POPUP_EVENTS
=
[
"
shown
"
"
hidden
"
"
showing
"
"
hiding
"
]
;
function
OptionsStore
(
defaults
options
)
{
this
.
defaults
=
defaults
|
|
{
}
;
this
.
options
=
options
|
|
{
}
;
}
OptionsStore
.
prototype
=
{
get
:
function
(
name
)
{
if
(
typeof
this
.
options
[
name
]
!
=
=
"
undefined
"
)
{
return
this
.
options
[
name
]
;
}
return
this
.
defaults
[
name
]
;
}
}
;
var
PanelFactory
=
{
get
:
function
(
doc
options
)
{
let
panel
=
doc
.
createElement
(
"
panel
"
)
;
panel
.
setAttribute
(
"
hidden
"
true
)
;
panel
.
setAttribute
(
"
ignorekeys
"
true
)
;
panel
.
setAttribute
(
"
animate
"
false
)
;
panel
.
setAttribute
(
"
consumeoutsideclicks
"
options
.
get
(
"
consumeOutsideClick
"
)
)
;
panel
.
setAttribute
(
"
noautofocus
"
options
.
get
(
"
noAutoFocus
"
)
)
;
panel
.
setAttribute
(
"
type
"
"
arrow
"
)
;
panel
.
setAttribute
(
"
level
"
"
top
"
)
;
panel
.
setAttribute
(
"
class
"
"
devtools
-
tooltip
theme
-
tooltip
-
panel
"
)
;
doc
.
querySelector
(
"
window
"
)
.
appendChild
(
panel
)
;
return
panel
;
}
}
;
function
Tooltip
(
doc
options
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
doc
=
doc
;
this
.
options
=
new
OptionsStore
(
{
consumeOutsideClick
:
false
closeOnKeys
:
[
ESCAPE_KEYCODE
]
noAutoFocus
:
true
closeOnEvents
:
[
]
}
options
)
;
this
.
panel
=
PanelFactory
.
get
(
doc
this
.
options
)
;
this
.
_toggle
=
new
TooltipToggle
(
this
)
;
this
.
startTogglingOnHover
=
this
.
_toggle
.
start
.
bind
(
this
.
_toggle
)
;
this
.
stopTogglingOnHover
=
this
.
_toggle
.
stop
.
bind
(
this
.
_toggle
)
;
for
(
let
eventName
of
POPUP_EVENTS
)
{
this
[
"
_onPopup
"
+
eventName
]
=
(
name
=
>
{
return
e
=
>
{
if
(
e
.
target
=
=
=
this
.
panel
)
{
this
.
emit
(
name
)
;
}
}
;
}
)
(
eventName
)
;
this
.
panel
.
addEventListener
(
"
popup
"
+
eventName
this
[
"
_onPopup
"
+
eventName
]
false
)
;
}
let
win
=
this
.
doc
.
querySelector
(
"
window
"
)
;
this
.
_onKeyPress
=
event
=
>
{
if
(
this
.
panel
.
hidden
)
{
return
;
}
this
.
emit
(
"
keypress
"
event
.
keyCode
)
;
if
(
this
.
options
.
get
(
"
closeOnKeys
"
)
.
indexOf
(
event
.
keyCode
)
!
=
=
-
1
&
&
this
.
isShown
(
)
)
{
event
.
stopPropagation
(
)
;
this
.
hide
(
)
;
}
}
;
win
.
addEventListener
(
"
keypress
"
this
.
_onKeyPress
false
)
;
this
.
hide
=
this
.
hide
.
bind
(
this
)
;
let
closeOnEvents
=
this
.
options
.
get
(
"
closeOnEvents
"
)
;
for
(
let
{
emitter
event
useCapture
}
of
closeOnEvents
)
{
for
(
let
add
of
[
"
addEventListener
"
"
on
"
]
)
{
if
(
add
in
emitter
)
{
emitter
[
add
]
(
event
this
.
hide
useCapture
)
;
break
;
}
}
}
}
module
.
exports
.
Tooltip
=
Tooltip
;
Tooltip
.
prototype
=
{
defaultPosition
:
"
before_start
"
defaultOffsetX
:
0
defaultOffsetY
:
0
show
:
function
(
anchor
position
=
this
.
defaultPosition
x
=
this
.
defaultOffsetX
y
=
this
.
defaultOffsetY
)
{
this
.
panel
.
hidden
=
false
;
this
.
panel
.
openPopup
(
anchor
position
x
y
)
;
}
hide
:
function
(
)
{
this
.
panel
.
hidden
=
true
;
this
.
panel
.
hidePopup
(
)
;
}
isShown
:
function
(
)
{
return
this
.
panel
&
&
this
.
panel
.
state
!
=
=
"
closed
"
&
&
this
.
panel
.
state
!
=
=
"
hiding
"
;
}
setSize
:
function
(
width
height
)
{
this
.
panel
.
sizeTo
(
width
height
)
;
}
empty
:
function
(
)
{
while
(
this
.
panel
.
hasChildNodes
(
)
)
{
this
.
panel
.
removeChild
(
this
.
panel
.
firstChild
)
;
}
}
isHidden
:
function
(
)
{
return
this
.
panel
.
state
=
=
"
closed
"
|
|
this
.
panel
.
state
=
=
"
hiding
"
;
}
isEmpty
:
function
(
)
{
return
!
this
.
panel
.
hasChildNodes
(
)
;
}
destroy
:
function
(
)
{
this
.
hide
(
)
;
for
(
let
eventName
of
POPUP_EVENTS
)
{
this
.
panel
.
removeEventListener
(
"
popup
"
+
eventName
this
[
"
_onPopup
"
+
eventName
]
false
)
;
}
let
win
=
this
.
doc
.
querySelector
(
"
window
"
)
;
win
.
removeEventListener
(
"
keypress
"
this
.
_onKeyPress
false
)
;
let
closeOnEvents
=
this
.
options
.
get
(
"
closeOnEvents
"
)
;
for
(
let
{
emitter
event
useCapture
}
of
closeOnEvents
)
{
for
(
let
remove
of
[
"
removeEventListener
"
"
off
"
]
)
{
if
(
remove
in
emitter
)
{
emitter
[
remove
]
(
event
this
.
hide
useCapture
)
;
break
;
}
}
}
this
.
content
=
null
;
this
.
_toggle
.
destroy
(
)
;
this
.
doc
=
null
;
this
.
panel
.
remove
(
)
;
this
.
panel
=
null
;
}
get
container
(
)
{
return
this
.
panel
;
}
set
content
(
content
)
{
if
(
this
.
content
=
=
content
)
{
return
;
}
this
.
empty
(
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
"
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
-
no
-
min
-
height
"
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
-
no
-
max
-
or
-
min
-
height
"
)
;
this
.
panel
.
removeAttribute
(
"
wide
"
)
;
if
(
content
)
{
this
.
panel
.
appendChild
(
content
)
;
}
}
get
content
(
)
{
return
this
.
panel
.
firstChild
;
}
setTextContent
:
function
(
{
messages
messagesClass
containerClass
isAlertTooltip
}
extraButtons
=
[
]
)
{
messagesClass
=
messagesClass
|
|
"
default
-
tooltip
-
simple
-
text
-
colors
"
;
containerClass
=
containerClass
|
|
"
default
-
tooltip
-
simple
-
text
-
colors
"
;
let
vbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
vbox
.
className
=
"
devtools
-
tooltip
-
simple
-
text
-
container
"
+
containerClass
;
vbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
for
(
let
text
of
messages
)
{
let
description
=
this
.
doc
.
createElement
(
"
description
"
)
;
description
.
setAttribute
(
"
flex
"
"
1
"
)
;
description
.
className
=
"
devtools
-
tooltip
-
simple
-
text
"
+
messagesClass
;
description
.
textContent
=
text
;
vbox
.
appendChild
(
description
)
;
}
for
(
let
{
label
className
command
}
of
extraButtons
)
{
let
button
=
this
.
doc
.
createElement
(
"
button
"
)
;
button
.
className
=
className
;
button
.
setAttribute
(
"
label
"
label
)
;
button
.
addEventListener
(
"
command
"
command
)
;
vbox
.
appendChild
(
button
)
;
}
if
(
isAlertTooltip
)
{
let
hbox
=
this
.
doc
.
createElement
(
"
hbox
"
)
;
hbox
.
setAttribute
(
"
align
"
"
start
"
)
;
let
alertImg
=
this
.
doc
.
createElement
(
"
image
"
)
;
alertImg
.
className
=
"
devtools
-
tooltip
-
alert
-
icon
"
;
hbox
.
appendChild
(
alertImg
)
;
hbox
.
appendChild
(
vbox
)
;
this
.
content
=
hbox
;
}
else
{
this
.
content
=
vbox
;
}
}
setVariableContent
:
function
(
objectActor
viewOptions
=
{
}
controllerOptions
=
{
}
relayEvents
=
{
}
extraButtons
=
[
]
toolbox
=
null
)
{
let
vbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
vbox
.
className
=
"
devtools
-
tooltip
-
variables
-
view
-
box
"
;
vbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
let
innerbox
=
this
.
doc
.
createElement
(
"
vbox
"
)
;
innerbox
.
className
=
"
devtools
-
tooltip
-
variables
-
view
-
innerbox
"
;
innerbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
vbox
.
appendChild
(
innerbox
)
;
for
(
let
{
label
className
command
}
of
extraButtons
)
{
let
button
=
this
.
doc
.
createElement
(
"
button
"
)
;
button
.
className
=
className
;
button
.
setAttribute
(
"
label
"
label
)
;
button
.
addEventListener
(
"
command
"
command
)
;
vbox
.
appendChild
(
button
)
;
}
let
widget
=
new
VariablesView
(
innerbox
viewOptions
)
;
if
(
toolbox
)
{
widget
.
toolbox
=
toolbox
;
}
widget
.
commitHierarchy
=
(
)
=
>
{
}
;
for
(
let
e
in
relayEvents
)
{
widget
.
on
(
e
relayEvents
[
e
]
)
;
}
VariablesViewController
.
attach
(
widget
controllerOptions
)
;
widget
.
searchPlaceholder
=
viewOptions
.
searchPlaceholder
;
widget
.
searchEnabled
=
viewOptions
.
searchEnabled
;
widget
.
controller
.
setSingleVariable
(
{
objectActor
:
objectActor
}
controllerOptions
)
;
this
.
content
=
vbox
;
this
.
panel
.
setAttribute
(
"
clamped
-
dimensions
"
"
"
)
;
}
setIFrameContent
:
function
(
{
width
height
}
url
)
{
let
def
=
defer
(
)
;
let
iframe
=
this
.
doc
.
createElementNS
(
XHTML_NS
"
iframe
"
)
;
iframe
.
setAttribute
(
"
transparent
"
true
)
;
iframe
.
setAttribute
(
"
width
"
width
)
;
iframe
.
setAttribute
(
"
height
"
height
)
;
iframe
.
setAttribute
(
"
flex
"
"
1
"
)
;
iframe
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
iframe
.
setAttribute
(
"
class
"
"
devtools
-
tooltip
-
iframe
"
)
;
function
onLoad
(
)
{
iframe
.
removeEventListener
(
"
load
"
onLoad
true
)
;
def
.
resolve
(
iframe
)
;
}
iframe
.
addEventListener
(
"
load
"
onLoad
true
)
;
iframe
.
setAttribute
(
"
src
"
url
)
;
this
.
content
=
iframe
;
return
def
.
promise
;
}
}
;
function
SwatchBasedEditorTooltip
(
toolbox
stylesheet
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
tooltip
=
new
HTMLTooltip
(
toolbox
{
type
:
"
arrow
"
consumeOutsideClicks
:
true
useXulWrapper
:
true
stylesheet
}
)
;
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
:
this
.
tooltip
.
topWindow
}
)
;
this
.
shortcuts
.
on
(
"
Escape
"
(
name
event
)
=
>
{
if
(
!
this
.
tooltip
.
isVisible
(
)
)
{
return
;
}
this
.
revert
(
)
;
this
.
hide
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
shortcuts
.
on
(
"
Return
"
(
name
event
)
=
>
{
if
(
!
this
.
tooltip
.
isVisible
(
)
)
{
return
;
}
this
.
commit
(
)
;
this
.
hide
(
)
;
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
}
)
;
this
.
swatches
=
new
Map
(
)
;
this
.
activeSwatch
=
null
;
this
.
_onSwatchClick
=
this
.
_onSwatchClick
.
bind
(
this
)
;
}
SwatchBasedEditorTooltip
.
prototype
=
{
show
:
function
(
)
{
if
(
this
.
activeSwatch
)
{
let
onShown
=
this
.
tooltip
.
once
(
"
shown
"
)
;
this
.
tooltip
.
show
(
this
.
activeSwatch
"
topcenter
bottomleft
"
)
;
this
.
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
if
(
!
this
.
_reverted
&
&
!
this
.
eyedropperOpen
)
{
this
.
commit
(
)
;
}
this
.
_reverted
=
false
;
if
(
!
this
.
eyedropperOpen
)
{
this
.
activeSwatch
=
null
;
}
}
)
;
return
onShown
;
}
return
Promise
.
resolve
(
)
;
}
hide
:
function
(
)
{
this
.
tooltip
.
hide
(
)
;
}
addSwatch
:
function
(
swatchEl
callbacks
=
{
}
)
{
if
(
!
callbacks
.
onShow
)
{
callbacks
.
onShow
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onPreview
)
{
callbacks
.
onPreview
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onRevert
)
{
callbacks
.
onRevert
=
function
(
)
{
}
;
}
if
(
!
callbacks
.
onCommit
)
{
callbacks
.
onCommit
=
function
(
)
{
}
;
}
this
.
swatches
.
set
(
swatchEl
{
callbacks
:
callbacks
}
)
;
swatchEl
.
addEventListener
(
"
click
"
this
.
_onSwatchClick
false
)
;
}
removeSwatch
:
function
(
swatchEl
)
{
if
(
this
.
swatches
.
has
(
swatchEl
)
)
{
if
(
this
.
activeSwatch
=
=
=
swatchEl
)
{
this
.
hide
(
)
;
this
.
activeSwatch
=
null
;
}
swatchEl
.
removeEventListener
(
"
click
"
this
.
_onSwatchClick
false
)
;
this
.
swatches
.
delete
(
swatchEl
)
;
}
}
_onSwatchClick
:
function
(
event
)
{
let
swatch
=
this
.
swatches
.
get
(
event
.
target
)
;
if
(
event
.
shiftKey
)
{
event
.
stopPropagation
(
)
;
return
;
}
if
(
swatch
)
{
this
.
activeSwatch
=
event
.
target
;
this
.
show
(
)
;
swatch
.
callbacks
.
onShow
(
)
;
event
.
stopPropagation
(
)
;
}
}
preview
:
function
(
value
)
{
if
(
this
.
activeSwatch
)
{
let
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
swatch
.
callbacks
.
onPreview
(
value
)
;
}
}
revert
:
function
(
)
{
if
(
this
.
activeSwatch
)
{
this
.
_reverted
=
true
;
let
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
this
.
tooltip
.
once
(
"
hidden
"
(
)
=
>
{
swatch
.
callbacks
.
onRevert
(
)
;
}
)
;
}
}
commit
:
function
(
)
{
if
(
this
.
activeSwatch
)
{
let
swatch
=
this
.
swatches
.
get
(
this
.
activeSwatch
)
;
swatch
.
callbacks
.
onCommit
(
)
;
}
}
destroy
:
function
(
)
{
this
.
swatches
.
clear
(
)
;
this
.
activeSwatch
=
null
;
this
.
tooltip
.
off
(
"
keypress
"
this
.
_onTooltipKeypress
)
;
this
.
tooltip
.
destroy
(
)
;
this
.
shortcuts
.
destroy
(
)
;
}
}
;
function
SwatchColorPickerTooltip
(
toolbox
inspector
)
{
let
stylesheet
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
spectrum
.
css
"
;
SwatchBasedEditorTooltip
.
call
(
this
toolbox
stylesheet
)
;
this
.
inspector
=
inspector
;
this
.
spectrum
=
this
.
setColorPickerContent
(
[
0
0
0
1
]
)
;
this
.
_onSpectrumColorChange
=
this
.
_onSpectrumColorChange
.
bind
(
this
)
;
this
.
_openEyeDropper
=
this
.
_openEyeDropper
.
bind
(
this
)
;
}
module
.
exports
.
SwatchColorPickerTooltip
=
SwatchColorPickerTooltip
;
SwatchColorPickerTooltip
.
prototype
=
Heritage
.
extend
(
SwatchBasedEditorTooltip
.
prototype
{
setColorPickerContent
:
function
(
color
)
{
let
{
doc
}
=
this
.
tooltip
;
let
container
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
container
.
id
=
"
spectrum
-
tooltip
"
;
let
spectrumNode
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
spectrumNode
.
id
=
"
spectrum
"
;
container
.
appendChild
(
spectrumNode
)
;
let
eyedropper
=
doc
.
createElementNS
(
XHTML_NS
"
button
"
)
;
eyedropper
.
id
=
"
eyedropper
-
button
"
;
eyedropper
.
className
=
"
devtools
-
button
"
;
container
.
appendChild
(
eyedropper
)
;
this
.
tooltip
.
setContent
(
container
{
width
:
218
height
:
224
}
)
;
let
spectrum
=
new
Spectrum
(
spectrumNode
color
)
;
this
.
tooltip
.
once
(
"
shown
"
(
)
=
>
{
spectrum
.
show
(
)
;
}
)
;
return
spectrum
;
}
show
:
Task
.
async
(
function
*
(
)
{
yield
SwatchBasedEditorTooltip
.
prototype
.
show
.
call
(
this
)
;
if
(
this
.
activeSwatch
)
{
this
.
currentSwatchColor
=
this
.
activeSwatch
.
nextSibling
;
this
.
_originalColor
=
this
.
currentSwatchColor
.
textContent
;
let
color
=
this
.
activeSwatch
.
style
.
backgroundColor
;
this
.
spectrum
.
off
(
"
changed
"
this
.
_onSpectrumColorChange
)
;
this
.
spectrum
.
rgb
=
this
.
_colorToRgba
(
color
)
;
this
.
spectrum
.
on
(
"
changed
"
this
.
_onSpectrumColorChange
)
;
this
.
spectrum
.
updateUI
(
)
;
}
let
{
target
}
=
this
.
inspector
.
toolbox
;
target
.
actorHasMethod
(
"
inspector
"
"
pickColorFromPage
"
)
.
then
(
value
=
>
{
let
tooltipDoc
=
this
.
tooltip
.
doc
;
let
eyeButton
=
tooltipDoc
.
querySelector
(
"
#
eyedropper
-
button
"
)
;
if
(
value
)
{
eyeButton
.
addEventListener
(
"
click
"
this
.
_openEyeDropper
)
;
}
else
{
eyeButton
.
style
.
display
=
"
none
"
;
}
this
.
emit
(
"
ready
"
)
;
}
e
=
>
console
.
error
(
e
)
)
;
}
)
_onSpectrumColorChange
:
function
(
event
rgba
cssColor
)
{
this
.
_selectColor
(
cssColor
)
;
}
_selectColor
:
function
(
color
)
{
if
(
this
.
activeSwatch
)
{
this
.
activeSwatch
.
style
.
backgroundColor
=
color
;
this
.
activeSwatch
.
parentNode
.
dataset
.
color
=
color
;
color
=
this
.
_toDefaultType
(
color
)
;
this
.
currentSwatchColor
.
textContent
=
color
;
this
.
preview
(
color
)
;
if
(
this
.
eyedropperOpen
)
{
this
.
commit
(
)
;
}
}
}
_openEyeDropper
:
function
(
)
{
let
{
inspector
toolbox
telemetry
}
=
this
.
inspector
;
telemetry
.
toolOpened
(
"
pickereyedropper
"
)
;
inspector
.
pickColorFromPage
(
{
copyOnSelect
:
false
}
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
inspector
.
once
(
"
color
-
picked
"
color
=
>
{
toolbox
.
win
.
focus
(
)
;
this
.
_selectColor
(
color
)
;
this
.
_onEyeDropperDone
(
)
;
}
)
;
inspector
.
once
(
"
color
-
pick
-
canceled
"
(
)
=
>
{
this
.
_onEyeDropperDone
(
)
;
}
)
;
this
.
eyedropperOpen
=
true
;
this
.
hide
(
)
;
this
.
tooltip
.
emit
(
"
eyedropper
-
opened
"
)
;
}
_onEyeDropperDone
:
function
(
)
{
this
.
eyedropperOpen
=
false
;
this
.
activeSwatch
=
null
;
}
_colorToRgba
:
function
(
color
)
{
color
=
new
colorUtils
.
CssColor
(
color
)
;
let
rgba
=
color
.
_getRGBATuple
(
)
;
return
[
rgba
.
r
rgba
.
g
rgba
.
b
rgba
.
a
]
;
}
_toDefaultType
:
function
(
color
)
{
let
colorObj
=
new
colorUtils
.
CssColor
(
color
)
;
colorObj
.
setAuthoredUnitFromColor
(
this
.
_originalColor
)
;
return
colorObj
.
toString
(
)
;
}
destroy
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
destroy
.
call
(
this
)
;
this
.
inspector
=
null
;
this
.
currentSwatchColor
=
null
;
this
.
spectrum
.
off
(
"
changed
"
this
.
_onSpectrumColorChange
)
;
this
.
spectrum
.
destroy
(
)
;
}
}
)
;
function
SwatchCubicBezierTooltip
(
toolbox
)
{
let
stylesheet
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
cubic
-
bezier
.
css
"
;
SwatchBasedEditorTooltip
.
call
(
this
toolbox
stylesheet
)
;
this
.
widget
=
this
.
setCubicBezierContent
(
[
0
0
1
1
]
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
}
module
.
exports
.
SwatchCubicBezierTooltip
=
SwatchCubicBezierTooltip
;
SwatchCubicBezierTooltip
.
prototype
=
Heritage
.
extend
(
SwatchBasedEditorTooltip
.
prototype
{
setCubicBezierContent
:
function
(
bezier
)
{
let
{
doc
}
=
this
.
tooltip
;
let
container
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
container
.
className
=
"
cubic
-
bezier
-
container
"
;
this
.
tooltip
.
setContent
(
container
{
width
:
510
height
:
370
}
)
;
let
def
=
defer
(
)
;
this
.
tooltip
.
once
(
"
shown
"
(
)
=
>
{
let
widget
=
new
CubicBezierWidget
(
container
bezier
)
;
def
.
resolve
(
widget
)
;
}
)
;
return
def
.
promise
;
}
show
:
Task
.
async
(
function
*
(
)
{
yield
SwatchBasedEditorTooltip
.
prototype
.
show
.
call
(
this
)
;
if
(
this
.
activeSwatch
)
{
this
.
currentBezierValue
=
this
.
activeSwatch
.
nextSibling
;
this
.
widget
.
then
(
widget
=
>
{
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
widget
.
cssCubicBezierValue
=
this
.
currentBezierValue
.
textContent
;
widget
.
on
(
"
updated
"
this
.
_onUpdate
)
;
this
.
emit
(
"
ready
"
)
;
}
)
;
}
}
)
_onUpdate
:
function
(
event
bezier
)
{
if
(
!
this
.
activeSwatch
)
{
return
;
}
this
.
currentBezierValue
.
textContent
=
bezier
+
"
"
;
this
.
preview
(
bezier
+
"
"
)
;
}
destroy
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
destroy
.
call
(
this
)
;
this
.
currentBezierValue
=
null
;
this
.
widget
.
then
(
widget
=
>
{
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
widget
.
destroy
(
)
;
}
)
;
}
}
)
;
function
SwatchFilterTooltip
(
toolbox
)
{
let
stylesheet
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
widgets
/
filter
-
widget
.
css
"
;
SwatchBasedEditorTooltip
.
call
(
this
toolbox
stylesheet
)
;
this
.
widget
=
this
.
setFilterContent
(
"
none
"
)
;
this
.
_onUpdate
=
this
.
_onUpdate
.
bind
(
this
)
;
}
exports
.
SwatchFilterTooltip
=
SwatchFilterTooltip
;
SwatchFilterTooltip
.
prototype
=
Heritage
.
extend
(
SwatchBasedEditorTooltip
.
prototype
{
setFilterContent
:
function
(
filter
)
{
let
{
doc
}
=
this
.
tooltip
;
let
container
=
doc
.
createElementNS
(
XHTML_NS
"
div
"
)
;
container
.
id
=
"
filter
-
container
"
;
this
.
tooltip
.
setContent
(
container
{
width
:
510
height
:
200
}
)
;
return
new
CSSFilterEditorWidget
(
container
filter
)
;
}
show
:
Task
.
async
(
function
*
(
)
{
yield
SwatchBasedEditorTooltip
.
prototype
.
show
.
call
(
this
)
;
if
(
this
.
activeSwatch
)
{
this
.
currentFilterValue
=
this
.
activeSwatch
.
nextSibling
;
this
.
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
this
.
widget
.
on
(
"
updated
"
this
.
_onUpdate
)
;
this
.
widget
.
setCssValue
(
this
.
currentFilterValue
.
textContent
)
;
this
.
widget
.
render
(
)
;
this
.
emit
(
"
ready
"
)
;
}
}
)
_onUpdate
:
function
(
event
filters
)
{
if
(
!
this
.
activeSwatch
)
{
return
;
}
while
(
this
.
currentFilterValue
.
firstChild
)
{
this
.
currentFilterValue
.
firstChild
.
remove
(
)
;
}
let
node
=
this
.
_parser
.
parseCssProperty
(
"
filter
"
filters
this
.
_options
)
;
this
.
currentFilterValue
.
appendChild
(
node
)
;
this
.
preview
(
)
;
}
destroy
:
function
(
)
{
SwatchBasedEditorTooltip
.
prototype
.
destroy
.
call
(
this
)
;
this
.
currentFilterValue
=
null
;
this
.
widget
.
off
(
"
updated
"
this
.
_onUpdate
)
;
this
.
widget
.
destroy
(
)
;
}
addSwatch
:
function
(
swatchEl
callbacks
parser
options
)
{
SwatchBasedEditorTooltip
.
prototype
.
addSwatch
.
call
(
this
swatchEl
callbacks
)
;
this
.
_parser
=
parser
;
this
.
_options
=
options
;
}
}
)
;
