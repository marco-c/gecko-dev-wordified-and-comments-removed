"
use
strict
"
;
const
{
Ci
}
=
require
(
"
chrome
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
Telemetry
=
require
(
"
devtools
/
client
/
shared
/
telemetry
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
NS_XHTML
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
{
PluralForm
}
=
require
(
"
devtools
/
shared
/
plural
-
form
"
)
;
loader
.
lazyGetter
(
this
"
prefBranch
"
function
(
)
{
return
Services
.
prefs
.
getBranch
(
null
)
.
QueryInterface
(
Ci
.
nsIPrefBranch2
)
;
}
)
;
loader
.
lazyRequireGetter
(
this
"
gcliInit
"
"
devtools
/
shared
/
gcli
/
commands
/
index
"
)
;
loader
.
lazyRequireGetter
(
this
"
util
"
"
gcli
/
util
/
util
"
)
;
loader
.
lazyRequireGetter
(
this
"
ConsoleServiceListener
"
"
devtools
/
server
/
actors
/
utils
/
webconsole
-
listeners
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevTools
"
"
devtools
/
client
/
framework
/
devtools
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
gDevToolsBrowser
"
"
devtools
/
client
/
framework
/
devtools
-
browser
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
nodeConstants
"
"
devtools
/
shared
/
dom
-
node
-
constants
"
)
;
loader
.
lazyRequireGetter
(
this
"
EventEmitter
"
"
devtools
/
shared
/
event
-
emitter
"
)
;
var
CommandUtils
=
{
_requisitions
:
new
WeakMap
(
)
executeOnTarget
:
Task
.
async
(
function
*
(
target
command
)
{
let
requisitionPromise
=
this
.
_requisitions
.
get
(
target
)
;
if
(
!
requisitionPromise
)
{
requisitionPromise
=
this
.
createRequisition
(
target
{
environment
:
CommandUtils
.
createEnvironment
(
{
target
}
"
target
"
)
}
)
;
this
.
_requisitions
.
set
(
target
requisitionPromise
)
;
}
let
requisition
=
yield
requisitionPromise
;
requisition
.
updateExec
(
command
)
;
}
)
createRequisition
:
function
(
target
options
)
{
if
(
!
gcliInit
)
{
return
promise
.
reject
(
"
Unable
to
load
gcli
"
)
;
}
return
gcliInit
.
getSystem
(
target
)
.
then
(
system
=
>
{
let
Requisition
=
require
(
"
gcli
/
cli
"
)
.
Requisition
;
return
new
Requisition
(
system
options
)
;
}
)
;
}
destroyRequisition
:
function
(
requisition
target
)
{
requisition
.
destroy
(
)
;
gcliInit
.
releaseSystem
(
target
)
;
}
createEnvironment
:
function
(
container
targetProperty
=
"
target
"
)
{
if
(
!
container
[
targetProperty
]
.
toString
|
|
!
/
TabTarget
/
.
test
(
container
[
targetProperty
]
.
toString
(
)
)
)
{
throw
new
Error
(
"
Missing
target
"
)
;
}
return
{
get
target
(
)
{
if
(
!
container
[
targetProperty
]
.
toString
|
|
!
/
TabTarget
/
.
test
(
container
[
targetProperty
]
.
toString
(
)
)
)
{
throw
new
Error
(
"
Removed
target
"
)
;
}
return
container
[
targetProperty
]
;
}
get
chromeWindow
(
)
{
return
this
.
target
.
tab
.
ownerDocument
.
defaultView
;
}
get
chromeDocument
(
)
{
return
this
.
target
.
tab
.
ownerDocument
.
defaultView
.
document
;
}
get
window
(
)
{
return
this
.
chromeWindow
.
gBrowser
.
contentWindowAsCPOW
;
}
get
document
(
)
{
return
this
.
chromeWindow
.
gBrowser
.
contentDocumentAsCPOW
;
}
}
;
}
}
;
exports
.
CommandUtils
=
CommandUtils
;
loader
.
lazyGetter
(
this
"
isLinux
"
function
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
Linux
"
;
}
)
;
loader
.
lazyGetter
(
this
"
isMac
"
function
(
)
{
return
Services
.
appinfo
.
OS
=
=
"
Darwin
"
;
}
)
;
function
DeveloperToolbar
(
chromeWindow
)
{
this
.
_chromeWindow
=
chromeWindow
;
this
.
target
=
null
;
this
.
_showPromise
=
null
;
this
.
_hidePromise
=
null
;
this
.
_doc
=
chromeWindow
.
document
;
this
.
_telemetry
=
new
Telemetry
(
)
;
this
.
_errorsCount
=
{
}
;
this
.
_warningsCount
=
{
}
;
this
.
_errorListeners
=
{
}
;
this
.
_onToolboxReady
=
this
.
_onToolboxReady
.
bind
(
this
)
;
this
.
_onToolboxDestroyed
=
this
.
_onToolboxDestroyed
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
DeveloperToolbar
=
DeveloperToolbar
;
const
NOTIFICATIONS
=
{
LOAD
:
"
developer
-
toolbar
-
load
"
SHOW
:
"
developer
-
toolbar
-
show
"
HIDE
:
"
developer
-
toolbar
-
hide
"
}
;
DeveloperToolbar
.
prototype
.
NOTIFICATIONS
=
NOTIFICATIONS
;
Object
.
defineProperty
(
DeveloperToolbar
.
prototype
"
visible
"
{
get
:
function
(
)
{
return
this
.
_element
&
&
!
this
.
_element
.
hidden
;
}
enumerable
:
true
}
)
;
var
_gSequenceId
=
0
;
Object
.
defineProperty
(
DeveloperToolbar
.
prototype
"
sequenceId
"
{
get
:
function
(
)
{
return
_gSequenceId
+
+
;
}
enumerable
:
true
}
)
;
DeveloperToolbar
.
prototype
.
createToolbar
=
function
(
)
{
if
(
this
.
_element
)
{
return
;
}
let
toolbar
=
this
.
_doc
.
createElement
(
"
toolbar
"
)
;
toolbar
.
setAttribute
(
"
id
"
"
developer
-
toolbar
"
)
;
toolbar
.
setAttribute
(
"
hidden
"
"
true
"
)
;
let
close
=
this
.
_doc
.
createElement
(
"
toolbarbutton
"
)
;
close
.
setAttribute
(
"
id
"
"
developer
-
toolbar
-
closebutton
"
)
;
close
.
setAttribute
(
"
class
"
"
close
-
icon
"
)
;
close
.
setAttribute
(
"
oncommand
"
"
DeveloperToolbar
.
hide
(
)
;
"
)
;
let
closeTooltip
=
L10N
.
getStr
(
"
toolbar
.
closeButton
.
tooltip
"
)
;
close
.
setAttribute
(
"
tooltiptext
"
closeTooltip
)
;
let
stack
=
this
.
_doc
.
createElement
(
"
stack
"
)
;
stack
.
setAttribute
(
"
flex
"
"
1
"
)
;
let
input
=
this
.
_doc
.
createElement
(
"
textbox
"
)
;
input
.
setAttribute
(
"
class
"
"
gclitoolbar
-
input
-
node
"
)
;
input
.
setAttribute
(
"
rows
"
"
1
"
)
;
stack
.
appendChild
(
input
)
;
let
hbox
=
this
.
_doc
.
createElement
(
"
hbox
"
)
;
hbox
.
setAttribute
(
"
class
"
"
gclitoolbar
-
complete
-
node
"
)
;
stack
.
appendChild
(
hbox
)
;
let
toolboxBtn
=
this
.
_doc
.
createElement
(
"
toolbarbutton
"
)
;
toolboxBtn
.
setAttribute
(
"
id
"
"
developer
-
toolbar
-
toolbox
-
button
"
)
;
toolboxBtn
.
setAttribute
(
"
class
"
"
developer
-
toolbar
-
button
"
)
;
let
toolboxTooltip
=
L10N
.
getStr
(
"
toolbar
.
toolsButton
.
tooltip
"
)
;
toolboxBtn
.
setAttribute
(
"
tooltiptext
"
toolboxTooltip
)
;
let
toolboxOpen
=
gDevToolsBrowser
.
hasToolboxOpened
(
this
.
_chromeWindow
)
;
toolboxBtn
.
setAttribute
(
"
checked
"
toolboxOpen
)
;
toolboxBtn
.
addEventListener
(
"
command
"
function
(
event
)
{
let
window
=
event
.
target
.
ownerDocument
.
defaultView
;
gDevToolsBrowser
.
toggleToolboxCommand
(
window
.
gBrowser
)
;
}
)
;
this
.
_errorCounterButton
=
toolboxBtn
;
this
.
_errorCounterButton
.
_defaultTooltipText
=
toolboxTooltip
;
if
(
isMac
)
{
toolbar
.
appendChild
(
close
)
;
toolbar
.
appendChild
(
stack
)
;
toolbar
.
appendChild
(
toolboxBtn
)
;
}
else
{
toolbar
.
appendChild
(
stack
)
;
toolbar
.
appendChild
(
toolboxBtn
)
;
toolbar
.
appendChild
(
close
)
;
}
this
.
_element
=
toolbar
;
let
bottomBox
=
this
.
_doc
.
getElementById
(
"
browser
-
bottombox
"
)
;
if
(
bottomBox
)
{
bottomBox
.
appendChild
(
this
.
_element
)
;
}
else
{
let
statusBar
=
this
.
_doc
.
getElementById
(
"
status
-
bar
"
)
;
if
(
statusBar
)
{
statusBar
.
parentNode
.
insertBefore
(
this
.
_element
statusBar
)
;
}
}
}
;
DeveloperToolbar
.
prototype
.
toggle
=
function
(
)
{
if
(
this
.
visible
)
{
return
this
.
hide
(
)
.
catch
(
console
.
error
)
;
}
return
this
.
show
(
true
)
.
catch
(
console
.
error
)
;
}
;
DeveloperToolbar
.
prototype
.
focus
=
function
(
)
{
if
(
this
.
visible
)
{
let
waitForBinding
=
defer
(
)
;
let
checkBinding
=
(
)
=
>
{
if
(
!
this
.
_input
)
{
waitForBinding
.
reject
(
)
;
return
;
}
if
(
typeof
this
.
_input
.
mInputField
!
=
"
undefined
"
)
{
this
.
_input
.
focus
(
)
;
waitForBinding
.
resolve
(
)
;
}
else
{
this
.
_input
.
ownerDocument
.
defaultView
.
setTimeout
(
checkBinding
50
)
;
}
}
;
checkBinding
(
)
;
return
waitForBinding
.
promise
;
}
return
this
.
show
(
true
)
;
}
;
DeveloperToolbar
.
prototype
.
focusToggle
=
function
(
)
{
if
(
this
.
visible
)
{
let
active
=
this
.
_chromeWindow
.
document
.
activeElement
;
let
position
=
this
.
_input
.
compareDocumentPosition
(
active
)
;
if
(
position
&
nodeConstants
.
DOCUMENT_POSITION_CONTAINED_BY
)
{
this
.
hide
(
)
;
}
else
{
this
.
_input
.
focus
(
)
;
}
}
else
{
this
.
show
(
true
)
;
}
}
;
DeveloperToolbar
.
introShownThisSession
=
false
;
DeveloperToolbar
.
prototype
.
show
=
function
(
focus
)
{
if
(
this
.
_showPromise
!
=
=
null
)
{
if
(
focus
)
{
return
this
.
focus
(
)
;
}
return
this
.
_showPromise
;
}
this
.
_showPromise
=
Task
.
spawn
(
(
function
*
(
)
{
yield
this
.
_hidePromise
;
this
.
createToolbar
(
)
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
toolbar
.
visible
"
true
)
;
this
.
_telemetry
.
toolOpened
(
"
developertoolbar
"
)
;
this
.
_notify
(
NOTIFICATIONS
.
LOAD
)
;
this
.
_input
=
this
.
_doc
.
querySelector
(
"
.
gclitoolbar
-
input
-
node
"
)
;
let
panelPromises
=
[
TooltipPanel
.
create
(
this
)
OutputPanel
.
create
(
this
)
]
;
let
panels
=
yield
promise
.
all
(
panelPromises
)
;
[
this
.
tooltipPanel
this
.
outputPanel
]
=
panels
;
this
.
_doc
.
getElementById
(
"
menu_devToolbar
"
)
.
setAttribute
(
"
checked
"
"
true
"
)
;
this
.
target
=
TargetFactory
.
forTab
(
this
.
_chromeWindow
.
gBrowser
.
selectedTab
)
;
const
options
=
{
environment
:
CommandUtils
.
createEnvironment
(
this
"
target
"
)
document
:
this
.
outputPanel
.
document
}
;
let
requisition
=
yield
CommandUtils
.
createRequisition
(
this
.
target
options
)
;
this
.
requisition
=
requisition
;
let
value
=
this
.
_input
.
value
|
|
"
"
;
yield
this
.
requisition
.
update
(
value
)
;
const
Inputter
=
require
(
"
gcli
/
mozui
/
inputter
"
)
.
Inputter
;
const
Completer
=
require
(
"
gcli
/
mozui
/
completer
"
)
.
Completer
;
const
Tooltip
=
require
(
"
gcli
/
mozui
/
tooltip
"
)
.
Tooltip
;
const
FocusManager
=
require
(
"
gcli
/
ui
/
focus
"
)
.
FocusManager
;
this
.
onOutput
=
this
.
requisition
.
commandOutputManager
.
onOutput
;
this
.
focusManager
=
new
FocusManager
(
this
.
_doc
requisition
.
system
.
settings
)
;
this
.
inputter
=
new
Inputter
(
{
requisition
:
this
.
requisition
focusManager
:
this
.
focusManager
element
:
this
.
_input
}
)
;
this
.
completer
=
new
Completer
(
{
requisition
:
this
.
requisition
inputter
:
this
.
inputter
backgroundElement
:
this
.
_doc
.
querySelector
(
"
.
gclitoolbar
-
stack
-
node
"
)
element
:
this
.
_doc
.
querySelector
(
"
.
gclitoolbar
-
complete
-
node
"
)
}
)
;
this
.
tooltip
=
new
Tooltip
(
{
requisition
:
this
.
requisition
focusManager
:
this
.
focusManager
inputter
:
this
.
inputter
element
:
this
.
tooltipPanel
.
hintElement
}
)
;
this
.
inputter
.
tooltip
=
this
.
tooltip
;
this
.
focusManager
.
addMonitoredElement
(
this
.
outputPanel
.
_frame
)
;
this
.
focusManager
.
addMonitoredElement
(
this
.
_element
)
;
this
.
focusManager
.
onVisibilityChange
.
add
(
this
.
outputPanel
.
_visibilityChanged
this
.
outputPanel
)
;
this
.
focusManager
.
onVisibilityChange
.
add
(
this
.
tooltipPanel
.
_visibilityChanged
this
.
tooltipPanel
)
;
this
.
onOutput
.
add
(
this
.
outputPanel
.
_outputChanged
this
.
outputPanel
)
;
let
tabbrowser
=
this
.
_chromeWindow
.
gBrowser
;
tabbrowser
.
tabContainer
.
addEventListener
(
"
TabSelect
"
this
)
;
tabbrowser
.
tabContainer
.
addEventListener
(
"
TabClose
"
this
)
;
tabbrowser
.
addEventListener
(
"
load
"
this
true
)
;
tabbrowser
.
addEventListener
(
"
beforeunload
"
this
true
)
;
gDevTools
.
on
(
"
toolbox
-
ready
"
this
.
_onToolboxReady
)
;
gDevTools
.
on
(
"
toolbox
-
destroyed
"
this
.
_onToolboxDestroyed
)
;
this
.
_initErrorsCount
(
tabbrowser
.
selectedTab
)
;
this
.
_element
.
hidden
=
false
;
if
(
focus
)
{
yield
this
.
focus
(
)
;
}
this
.
_notify
(
NOTIFICATIONS
.
SHOW
)
;
if
(
!
DeveloperToolbar
.
introShownThisSession
)
{
let
intro
=
require
(
"
gcli
/
ui
/
intro
"
)
;
intro
.
maybeShowIntro
(
this
.
requisition
.
commandOutputManager
this
.
requisition
.
conversionContext
this
.
outputPanel
)
;
DeveloperToolbar
.
introShownThisSession
=
true
;
}
}
)
.
bind
(
this
)
)
;
return
this
.
_showPromise
;
}
;
DeveloperToolbar
.
prototype
.
hide
=
function
(
)
{
if
(
this
.
_hidePromise
!
=
=
null
)
{
return
this
.
_hidePromise
;
}
if
(
this
.
_showPromise
=
=
=
null
)
{
return
promise
.
resolve
(
)
;
}
this
.
_hidePromise
=
this
.
_showPromise
.
then
(
(
)
=
>
{
this
.
_element
.
hidden
=
true
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
toolbar
.
visible
"
false
)
;
this
.
_doc
.
getElementById
(
"
menu_devToolbar
"
)
.
setAttribute
(
"
checked
"
"
false
"
)
;
this
.
destroy
(
)
;
this
.
_telemetry
.
toolClosed
(
"
developertoolbar
"
)
;
this
.
_notify
(
NOTIFICATIONS
.
HIDE
)
;
this
.
_showPromise
=
null
;
this
.
_hidePromise
=
null
;
}
)
;
return
this
.
_hidePromise
;
}
;
DeveloperToolbar
.
prototype
.
_initErrorsCount
=
function
(
tab
)
{
let
tabId
=
tab
.
linkedPanel
;
if
(
tabId
in
this
.
_errorsCount
)
{
this
.
_updateErrorsCount
(
)
;
return
;
}
let
window
=
tab
.
linkedBrowser
.
contentWindow
;
let
listener
=
new
ConsoleServiceListener
(
window
{
onConsoleServiceMessage
:
this
.
_onPageError
.
bind
(
this
tabId
)
}
)
;
listener
.
init
(
)
;
this
.
_errorListeners
[
tabId
]
=
listener
;
this
.
_errorsCount
[
tabId
]
=
0
;
this
.
_warningsCount
[
tabId
]
=
0
;
let
messages
=
listener
.
getCachedMessages
(
)
;
messages
.
forEach
(
this
.
_onPageError
.
bind
(
this
tabId
)
)
;
this
.
_updateErrorsCount
(
)
;
}
;
DeveloperToolbar
.
prototype
.
_stopErrorsCount
=
function
(
tab
)
{
let
tabId
=
tab
.
linkedPanel
;
if
(
!
(
tabId
in
this
.
_errorsCount
)
|
|
!
(
tabId
in
this
.
_warningsCount
)
)
{
this
.
_updateErrorsCount
(
)
;
return
;
}
this
.
_errorListeners
[
tabId
]
.
destroy
(
)
;
delete
this
.
_errorListeners
[
tabId
]
;
delete
this
.
_errorsCount
[
tabId
]
;
delete
this
.
_warningsCount
[
tabId
]
;
this
.
_updateErrorsCount
(
)
;
}
;
DeveloperToolbar
.
prototype
.
destroy
=
function
(
)
{
if
(
this
.
_input
=
=
null
)
{
return
;
}
let
tabbrowser
=
this
.
_chromeWindow
.
gBrowser
;
tabbrowser
.
tabContainer
.
removeEventListener
(
"
TabSelect
"
this
)
;
tabbrowser
.
tabContainer
.
removeEventListener
(
"
TabClose
"
this
)
;
tabbrowser
.
removeEventListener
(
"
load
"
this
true
)
;
tabbrowser
.
removeEventListener
(
"
beforeunload
"
this
true
)
;
gDevTools
.
off
(
"
toolbox
-
ready
"
this
.
_onToolboxReady
)
;
gDevTools
.
off
(
"
toolbox
-
destroyed
"
this
.
_onToolboxDestroyed
)
;
Array
.
prototype
.
forEach
.
call
(
tabbrowser
.
tabs
this
.
_stopErrorsCount
this
)
;
this
.
focusManager
.
removeMonitoredElement
(
this
.
outputPanel
.
_frame
)
;
this
.
focusManager
.
removeMonitoredElement
(
this
.
_element
)
;
this
.
focusManager
.
onVisibilityChange
.
remove
(
this
.
outputPanel
.
_visibilityChanged
this
.
outputPanel
)
;
this
.
focusManager
.
onVisibilityChange
.
remove
(
this
.
tooltipPanel
.
_visibilityChanged
this
.
tooltipPanel
)
;
this
.
onOutput
.
remove
(
this
.
outputPanel
.
_outputChanged
this
.
outputPanel
)
;
this
.
tooltip
.
destroy
(
)
;
this
.
completer
.
destroy
(
)
;
this
.
inputter
.
destroy
(
)
;
this
.
focusManager
.
destroy
(
)
;
this
.
outputPanel
.
destroy
(
)
;
this
.
tooltipPanel
.
destroy
(
)
;
delete
this
.
_input
;
CommandUtils
.
destroyRequisition
(
this
.
requisition
this
.
target
)
;
this
.
target
=
undefined
;
this
.
_element
.
remove
(
)
;
delete
this
.
_element
;
}
;
DeveloperToolbar
.
prototype
.
_notify
=
function
(
topic
)
{
let
data
=
{
toolbar
:
this
}
;
data
.
wrappedJSObject
=
data
;
Services
.
obs
.
notifyObservers
(
data
topic
null
)
;
}
;
DeveloperToolbar
.
prototype
.
handleEvent
=
function
(
ev
)
{
if
(
ev
.
type
=
=
"
TabSelect
"
|
|
ev
.
type
=
=
"
load
"
)
{
if
(
this
.
visible
)
{
let
tab
=
this
.
_chromeWindow
.
gBrowser
.
selectedTab
;
this
.
target
=
TargetFactory
.
forTab
(
tab
)
;
gcliInit
.
getSystem
(
this
.
target
)
.
then
(
system
=
>
{
this
.
requisition
.
system
=
system
;
}
error
=
>
{
if
(
!
this
.
_chromeWindow
.
gBrowser
.
getBrowserForTab
(
tab
)
)
{
console
.
warn
(
"
An
error
occurred
as
the
tab
was
closed
while
"
+
"
updating
Developer
Toolbar
state
.
The
error
was
:
"
error
)
;
return
;
}
throw
error
;
}
)
;
if
(
ev
.
type
=
=
"
TabSelect
"
)
{
let
toolboxOpen
=
gDevToolsBrowser
.
hasToolboxOpened
(
this
.
_chromeWindow
)
;
this
.
_errorCounterButton
.
setAttribute
(
"
checked
"
toolboxOpen
)
;
this
.
_initErrorsCount
(
ev
.
target
)
;
}
}
}
else
if
(
ev
.
type
=
=
"
TabClose
"
)
{
this
.
_stopErrorsCount
(
ev
.
target
)
;
}
else
if
(
ev
.
type
=
=
"
beforeunload
"
)
{
this
.
_onPageBeforeUnload
(
ev
)
;
}
}
;
DeveloperToolbar
.
prototype
.
_onToolboxReady
=
function
(
)
{
this
.
_errorCounterButton
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
;
DeveloperToolbar
.
prototype
.
_onToolboxDestroyed
=
function
(
)
{
this
.
_errorCounterButton
.
setAttribute
(
"
checked
"
"
false
"
)
;
}
;
DeveloperToolbar
.
prototype
.
_onPageError
=
function
(
tabId
pageError
)
{
if
(
pageError
.
category
=
=
"
CSS
Parser
"
|
|
pageError
.
category
=
=
"
CSS
Loader
"
)
{
return
;
}
if
(
(
pageError
.
flags
&
pageError
.
warningFlag
)
|
|
(
pageError
.
flags
&
pageError
.
strictFlag
)
)
{
this
.
_warningsCount
[
tabId
]
+
+
;
}
else
{
this
.
_errorsCount
[
tabId
]
+
+
;
}
this
.
_updateErrorsCount
(
tabId
)
;
}
;
DeveloperToolbar
.
prototype
.
_onPageBeforeUnload
=
function
(
ev
)
{
let
window
=
ev
.
target
.
defaultView
;
if
(
window
.
top
!
=
=
window
)
{
return
;
}
let
tabs
=
this
.
_chromeWindow
.
gBrowser
.
tabs
;
Array
.
prototype
.
some
.
call
(
tabs
function
(
tab
)
{
if
(
tab
.
linkedBrowser
.
contentWindow
=
=
=
window
)
{
let
tabId
=
tab
.
linkedPanel
;
if
(
tabId
in
this
.
_errorsCount
|
|
tabId
in
this
.
_warningsCount
)
{
this
.
_errorsCount
[
tabId
]
=
0
;
this
.
_warningsCount
[
tabId
]
=
0
;
this
.
_updateErrorsCount
(
tabId
)
;
}
return
true
;
}
return
false
;
}
this
)
;
}
;
DeveloperToolbar
.
prototype
.
_updateErrorsCount
=
function
(
changedTabId
)
{
let
tabId
=
this
.
_chromeWindow
.
gBrowser
.
selectedTab
.
linkedPanel
;
if
(
changedTabId
&
&
tabId
!
=
changedTabId
)
{
return
;
}
let
errors
=
this
.
_errorsCount
[
tabId
]
;
let
warnings
=
this
.
_warningsCount
[
tabId
]
;
let
btn
=
this
.
_errorCounterButton
;
if
(
errors
)
{
let
errorsText
=
L10N
.
getStr
(
"
toolboxToggleButton
.
errors
"
)
;
errorsText
=
PluralForm
.
get
(
errors
errorsText
)
.
replace
(
"
#
1
"
errors
)
;
let
warningsText
=
L10N
.
getStr
(
"
toolboxToggleButton
.
warnings
"
)
;
warningsText
=
PluralForm
.
get
(
warnings
warningsText
)
.
replace
(
"
#
1
"
warnings
)
;
let
tooltiptext
=
L10N
.
getFormatStr
(
"
toolboxToggleButton
.
tooltip
"
errorsText
warningsText
)
;
btn
.
setAttribute
(
"
error
-
count
"
errors
)
;
btn
.
setAttribute
(
"
tooltiptext
"
tooltiptext
)
;
}
else
{
btn
.
removeAttribute
(
"
error
-
count
"
)
;
btn
.
setAttribute
(
"
tooltiptext
"
btn
.
_defaultTooltipText
)
;
}
this
.
emit
(
"
errors
-
counter
-
updated
"
)
;
}
;
DeveloperToolbar
.
prototype
.
resetErrorsCount
=
function
(
tab
)
{
let
tabId
=
tab
.
linkedPanel
;
if
(
tabId
in
this
.
_errorsCount
|
|
tabId
in
this
.
_warningsCount
)
{
this
.
_errorsCount
[
tabId
]
=
0
;
this
.
_warningsCount
[
tabId
]
=
0
;
this
.
_updateErrorsCount
(
tabId
)
;
}
}
;
function
OutputPanel
(
)
{
throw
new
Error
(
"
Use
OutputPanel
.
create
(
)
"
)
;
}
OutputPanel
.
create
=
function
(
devtoolbar
)
{
let
outputPanel
=
Object
.
create
(
OutputPanel
.
prototype
)
;
return
outputPanel
.
_init
(
devtoolbar
)
;
}
;
OutputPanel
.
prototype
.
_init
=
function
(
devtoolbar
)
{
this
.
_devtoolbar
=
devtoolbar
;
this
.
_input
=
this
.
_devtoolbar
.
_input
;
this
.
_toolbar
=
this
.
_devtoolbar
.
_doc
.
getElementById
(
"
developer
-
toolbar
"
)
;
this
.
_panel
=
this
.
_devtoolbar
.
_doc
.
createElement
(
isLinux
?
"
tooltip
"
:
"
panel
"
)
;
this
.
_panel
.
id
=
"
gcli
-
output
"
;
this
.
_panel
.
classList
.
add
(
"
gcli
-
panel
"
)
;
if
(
isLinux
)
{
this
.
canHide
=
false
;
this
.
_onpopuphiding
=
this
.
_onpopuphiding
.
bind
(
this
)
;
this
.
_panel
.
addEventListener
(
"
popuphiding
"
this
.
_onpopuphiding
true
)
;
}
else
{
this
.
_panel
.
setAttribute
(
"
noautofocus
"
"
true
"
)
;
this
.
_panel
.
setAttribute
(
"
noautohide
"
"
true
"
)
;
this
.
_panel
.
setAttribute
(
"
height
"
"
1px
"
)
;
}
this
.
_toolbar
.
parentElement
.
insertBefore
(
this
.
_panel
this
.
_toolbar
)
;
this
.
_frame
=
this
.
_devtoolbar
.
_doc
.
createElementNS
(
NS_XHTML
"
iframe
"
)
;
this
.
_frame
.
id
=
"
gcli
-
output
-
frame
"
;
this
.
_frame
.
setAttribute
(
"
src
"
"
chrome
:
/
/
devtools
/
content
/
commandline
/
commandlineoutput
.
xhtml
"
)
;
this
.
_frame
.
setAttribute
(
"
sandbox
"
"
allow
-
same
-
origin
"
)
;
this
.
_panel
.
appendChild
(
this
.
_frame
)
;
this
.
displayedOutput
=
undefined
;
this
.
_update
=
this
.
_update
.
bind
(
this
)
;
let
deferred
=
defer
(
)
;
let
onload
=
(
)
=
>
{
this
.
_frame
.
removeEventListener
(
"
load
"
onload
true
)
;
this
.
document
=
this
.
_frame
.
contentDocument
;
this
.
_copyTheme
(
)
;
this
.
_div
=
this
.
document
.
getElementById
(
"
gcli
-
output
-
root
"
)
;
this
.
_div
.
classList
.
add
(
"
gcli
-
row
-
out
"
)
;
this
.
_div
.
setAttribute
(
"
aria
-
live
"
"
assertive
"
)
;
let
styles
=
this
.
_toolbar
.
ownerDocument
.
defaultView
.
getComputedStyle
(
this
.
_toolbar
)
;
this
.
_div
.
setAttribute
(
"
dir
"
styles
.
direction
)
;
deferred
.
resolve
(
this
)
;
}
;
this
.
_frame
.
addEventListener
(
"
load
"
onload
true
)
;
return
deferred
.
promise
;
}
;
OutputPanel
.
prototype
.
_copyTheme
=
function
(
)
{
if
(
this
.
document
)
{
let
theme
=
this
.
_devtoolbar
.
_doc
.
getElementById
(
"
browser
-
bottombox
"
)
.
getAttribute
(
"
devtoolstheme
"
)
;
this
.
document
.
documentElement
.
setAttribute
(
"
devtoolstheme
"
theme
)
;
}
}
;
OutputPanel
.
prototype
.
_onpopuphiding
=
function
(
ev
)
{
if
(
isLinux
&
&
!
this
.
canHide
)
{
ev
.
preventDefault
(
)
;
}
}
;
OutputPanel
.
prototype
.
show
=
function
(
)
{
if
(
isLinux
)
{
this
.
canHide
=
false
;
}
this
.
_frame
.
style
.
minHeight
=
this
.
_frame
.
style
.
maxHeight
=
0
;
this
.
_frame
.
style
.
minWidth
=
0
;
this
.
_copyTheme
(
)
;
this
.
_panel
.
openPopup
(
this
.
_input
"
before_start
"
0
0
false
false
null
)
;
this
.
_resize
(
)
;
this
.
_input
.
focus
(
)
;
}
;
OutputPanel
.
prototype
.
_resize
=
function
(
)
{
if
(
this
.
_panel
=
=
null
|
|
this
.
document
=
=
null
|
|
!
this
.
_panel
.
state
=
=
"
closed
"
)
{
return
;
}
let
maxWidth
=
this
.
_panel
.
ownerDocument
.
documentElement
.
clientWidth
;
switch
(
Services
.
appinfo
.
OS
)
{
case
"
Linux
"
:
maxWidth
-
=
5
;
break
;
case
"
Darwin
"
:
maxWidth
-
=
25
;
break
;
case
"
WINNT
"
:
maxWidth
-
=
5
;
break
;
}
this
.
document
.
body
.
style
.
width
=
"
-
moz
-
max
-
content
"
;
let
style
=
this
.
_frame
.
contentWindow
.
getComputedStyle
(
this
.
document
.
body
)
;
let
frameWidth
=
parseInt
(
style
.
width
10
)
;
let
width
=
Math
.
min
(
maxWidth
frameWidth
)
;
this
.
document
.
body
.
style
.
width
=
width
+
"
px
"
;
this
.
_frame
.
style
.
minWidth
=
width
+
"
px
"
;
this
.
_panel
.
style
.
maxWidth
=
maxWidth
+
"
px
"
;
const
browserAdjustment
=
15
;
let
maxHeight
=
this
.
_panel
.
ownerDocument
.
documentElement
.
clientHeight
-
browserAdjustment
;
let
height
=
Math
.
min
(
maxHeight
this
.
document
.
documentElement
.
scrollHeight
)
;
this
.
_frame
.
style
.
minHeight
=
this
.
_frame
.
style
.
maxHeight
=
height
+
"
px
"
;
this
.
_panel
.
sizeTo
(
width
height
)
;
let
screenX
=
this
.
_input
.
boxObject
.
screenX
;
let
screenY
=
this
.
_toolbar
.
boxObject
.
screenY
;
this
.
_panel
.
moveTo
(
screenX
screenY
-
height
)
;
}
;
OutputPanel
.
prototype
.
_outputChanged
=
function
(
ev
)
{
if
(
ev
.
output
.
hidden
)
{
return
;
}
this
.
remove
(
)
;
this
.
displayedOutput
=
ev
.
output
;
if
(
this
.
displayedOutput
.
completed
)
{
this
.
_update
(
)
;
}
else
{
this
.
displayedOutput
.
promise
.
then
(
this
.
_update
this
.
_update
)
.
then
(
null
console
.
error
)
;
}
}
;
OutputPanel
.
prototype
.
_update
=
function
(
)
{
if
(
this
.
_div
=
=
null
)
{
return
;
}
while
(
this
.
_div
.
hasChildNodes
(
)
)
{
this
.
_div
.
removeChild
(
this
.
_div
.
firstChild
)
;
}
if
(
this
.
displayedOutput
.
data
!
=
null
)
{
let
context
=
this
.
_devtoolbar
.
requisition
.
conversionContext
;
this
.
displayedOutput
.
convert
(
"
dom
"
context
)
.
then
(
node
=
>
{
if
(
node
=
=
null
)
{
return
;
}
while
(
this
.
_div
.
hasChildNodes
(
)
)
{
this
.
_div
.
removeChild
(
this
.
_div
.
firstChild
)
;
}
let
links
=
node
.
querySelectorAll
(
"
*
[
href
]
"
)
;
for
(
let
i
=
0
;
i
<
links
.
length
;
i
+
+
)
{
links
[
i
]
.
setAttribute
(
"
target
"
"
_blank
"
)
;
}
this
.
_div
.
appendChild
(
node
)
;
this
.
show
(
)
;
}
)
;
}
}
;
OutputPanel
.
prototype
.
remove
=
function
(
)
{
if
(
isLinux
)
{
this
.
canHide
=
true
;
}
if
(
this
.
_panel
&
&
this
.
_panel
.
hidePopup
)
{
this
.
_panel
.
hidePopup
(
)
;
}
if
(
this
.
displayedOutput
)
{
delete
this
.
displayedOutput
;
}
}
;
OutputPanel
.
prototype
.
destroy
=
function
(
)
{
this
.
remove
(
)
;
this
.
_panel
.
removeEventListener
(
"
popuphiding
"
this
.
_onpopuphiding
true
)
;
this
.
_panel
.
removeChild
(
this
.
_frame
)
;
this
.
_toolbar
.
parentElement
.
removeChild
(
this
.
_panel
)
;
delete
this
.
_devtoolbar
;
delete
this
.
_input
;
delete
this
.
_toolbar
;
delete
this
.
_onpopuphiding
;
delete
this
.
_panel
;
delete
this
.
_frame
;
delete
this
.
_content
;
delete
this
.
_div
;
delete
this
.
document
;
}
;
OutputPanel
.
prototype
.
_visibilityChanged
=
function
(
ev
)
{
if
(
ev
.
outputVisible
=
=
=
true
)
{
}
else
{
if
(
isLinux
)
{
this
.
canHide
=
true
;
}
this
.
_panel
.
hidePopup
(
)
;
}
}
;
function
TooltipPanel
(
)
{
throw
new
Error
(
"
Use
TooltipPanel
.
create
(
)
"
)
;
}
TooltipPanel
.
create
=
function
(
devtoolbar
)
{
let
tooltipPanel
=
Object
.
create
(
TooltipPanel
.
prototype
)
;
return
tooltipPanel
.
_init
(
devtoolbar
)
;
}
;
TooltipPanel
.
prototype
.
_init
=
function
(
devtoolbar
)
{
let
deferred
=
defer
(
)
;
this
.
_devtoolbar
=
devtoolbar
;
this
.
_input
=
devtoolbar
.
_doc
.
querySelector
(
"
.
gclitoolbar
-
input
-
node
"
)
;
this
.
_toolbar
=
devtoolbar
.
_doc
.
querySelector
(
"
#
developer
-
toolbar
"
)
;
this
.
_dimensions
=
{
start
:
0
end
:
0
}
;
this
.
_panel
=
devtoolbar
.
_doc
.
createElement
(
isLinux
?
"
tooltip
"
:
"
panel
"
)
;
this
.
_panel
.
id
=
"
gcli
-
tooltip
"
;
this
.
_panel
.
classList
.
add
(
"
gcli
-
panel
"
)
;
if
(
isLinux
)
{
this
.
canHide
=
false
;
this
.
_onpopuphiding
=
this
.
_onpopuphiding
.
bind
(
this
)
;
this
.
_panel
.
addEventListener
(
"
popuphiding
"
this
.
_onpopuphiding
true
)
;
}
else
{
this
.
_panel
.
setAttribute
(
"
noautofocus
"
"
true
"
)
;
this
.
_panel
.
setAttribute
(
"
noautohide
"
"
true
"
)
;
this
.
_panel
.
setAttribute
(
"
height
"
"
1px
"
)
;
}
this
.
_toolbar
.
parentElement
.
insertBefore
(
this
.
_panel
this
.
_toolbar
)
;
this
.
_frame
=
devtoolbar
.
_doc
.
createElementNS
(
NS_XHTML
"
iframe
"
)
;
this
.
_frame
.
id
=
"
gcli
-
tooltip
-
frame
"
;
this
.
_frame
.
setAttribute
(
"
src
"
"
chrome
:
/
/
devtools
/
content
/
commandline
/
commandlinetooltip
.
xhtml
"
)
;
this
.
_frame
.
setAttribute
(
"
flex
"
"
1
"
)
;
this
.
_frame
.
setAttribute
(
"
sandbox
"
"
allow
-
same
-
origin
"
)
;
this
.
_panel
.
appendChild
(
this
.
_frame
)
;
let
onload
=
(
)
=
>
{
this
.
_frame
.
removeEventListener
(
"
load
"
onload
true
)
;
this
.
document
=
this
.
_frame
.
contentDocument
;
this
.
_copyTheme
(
)
;
this
.
hintElement
=
this
.
document
.
getElementById
(
"
gcli
-
tooltip
-
root
"
)
;
this
.
_connector
=
this
.
document
.
getElementById
(
"
gcli
-
tooltip
-
connector
"
)
;
let
styles
=
this
.
_toolbar
.
ownerDocument
.
defaultView
.
getComputedStyle
(
this
.
_toolbar
)
;
this
.
hintElement
.
setAttribute
(
"
dir
"
styles
.
direction
)
;
deferred
.
resolve
(
this
)
;
}
;
this
.
_frame
.
addEventListener
(
"
load
"
onload
true
)
;
return
deferred
.
promise
;
}
;
TooltipPanel
.
prototype
.
_copyTheme
=
function
(
)
{
if
(
this
.
document
)
{
let
theme
=
this
.
_devtoolbar
.
_doc
.
getElementById
(
"
browser
-
bottombox
"
)
.
getAttribute
(
"
devtoolstheme
"
)
;
this
.
document
.
documentElement
.
setAttribute
(
"
devtoolstheme
"
theme
)
;
}
}
;
TooltipPanel
.
prototype
.
_onpopuphiding
=
function
(
ev
)
{
if
(
isLinux
&
&
!
this
.
canHide
)
{
ev
.
preventDefault
(
)
;
}
}
;
TooltipPanel
.
prototype
.
show
=
function
(
dimensions
)
{
if
(
!
dimensions
)
{
dimensions
=
{
start
:
0
end
:
0
}
;
}
this
.
_dimensions
=
dimensions
;
this
.
_panel
.
ownerDocument
.
defaultView
.
setTimeout
(
(
)
=
>
{
this
.
_resize
(
)
;
}
0
)
;
if
(
isLinux
)
{
this
.
canHide
=
false
;
}
this
.
_copyTheme
(
)
;
this
.
_resize
(
)
;
this
.
_panel
.
openPopup
(
this
.
_input
"
before_start
"
dimensions
.
start
*
10
0
false
false
null
)
;
this
.
_input
.
focus
(
)
;
}
;
const
AVE_CHAR_WIDTH
=
4
.
5
;
TooltipPanel
.
prototype
.
_resize
=
function
(
)
{
if
(
this
.
_panel
=
=
null
|
|
this
.
document
=
=
null
|
|
!
this
.
_panel
.
state
=
=
"
closed
"
)
{
return
;
}
let
offset
=
10
+
Math
.
floor
(
this
.
_dimensions
.
start
*
AVE_CHAR_WIDTH
)
;
this
.
_panel
.
style
.
marginLeft
=
offset
+
"
px
"
;
this
.
_frame
.
height
=
this
.
document
.
body
.
scrollHeight
;
}
;
TooltipPanel
.
prototype
.
remove
=
function
(
)
{
if
(
isLinux
)
{
this
.
canHide
=
true
;
}
if
(
this
.
_panel
&
&
this
.
_panel
.
hidePopup
)
{
this
.
_panel
.
hidePopup
(
)
;
}
}
;
TooltipPanel
.
prototype
.
destroy
=
function
(
)
{
this
.
remove
(
)
;
this
.
_panel
.
removeEventListener
(
"
popuphiding
"
this
.
_onpopuphiding
true
)
;
this
.
_panel
.
removeChild
(
this
.
_frame
)
;
this
.
_toolbar
.
parentElement
.
removeChild
(
this
.
_panel
)
;
delete
this
.
_connector
;
delete
this
.
_dimensions
;
delete
this
.
_input
;
delete
this
.
_onpopuphiding
;
delete
this
.
_panel
;
delete
this
.
_frame
;
delete
this
.
_toolbar
;
delete
this
.
_content
;
delete
this
.
document
;
delete
this
.
hintElement
;
}
;
TooltipPanel
.
prototype
.
_visibilityChanged
=
function
(
ev
)
{
if
(
ev
.
tooltipVisible
=
=
=
true
)
{
this
.
show
(
ev
.
dimensions
)
;
}
else
{
if
(
isLinux
)
{
this
.
canHide
=
true
;
}
this
.
_panel
.
hidePopup
(
)
;
}
}
;
