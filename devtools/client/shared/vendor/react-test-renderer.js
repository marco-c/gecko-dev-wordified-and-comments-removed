(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
module
.
exports
=
factory
(
require
(
'
devtools
/
client
/
shared
/
vendor
/
react
'
)
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
[
'
devtools
/
client
/
shared
/
vendor
/
react
'
]
factory
)
:
(
global
.
ReactTestRenderer
=
factory
(
global
.
React
)
)
;
}
(
this
(
function
(
React
)
{
'
use
strict
'
;
function
invariant
(
condition
format
a
b
c
d
e
f
)
{
if
(
!
condition
)
{
var
error
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
var
invariant_1
=
invariant
;
function
reactProdInvariant
(
code
)
{
var
argCount
=
arguments
.
length
-
1
;
var
url
=
'
https
:
/
/
reactjs
.
org
/
docs
/
error
-
decoder
.
html
?
invariant
=
'
+
code
;
for
(
var
argIdx
=
0
;
argIdx
<
argCount
;
argIdx
+
+
)
{
url
+
=
'
&
args
[
]
=
'
+
encodeURIComponent
(
arguments
[
argIdx
+
1
]
)
;
}
var
i
=
invariant_1
;
i
(
false
'
Minified
React
error
#
'
+
code
+
'
;
visit
%
s
'
+
'
for
the
full
message
or
use
the
non
-
minified
dev
environment
'
+
'
for
full
errors
and
additional
helpful
warnings
.
'
url
)
;
}
var
ReactInternals
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_assign
=
ReactInternals
.
assign
;
function
get
(
key
)
{
return
key
.
_reactInternalFiber
;
}
function
set
(
key
value
)
{
key
.
_reactInternalFiber
=
value
;
}
var
ReactInternals
1
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
ReactCurrentOwner
=
ReactInternals
1
.
ReactCurrentOwner
;
var
hasSymbol
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
for
;
var
REACT_ELEMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
element
'
)
:
0xeac7
;
var
REACT_PORTAL_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
portal
'
)
:
0xeaca
;
var
REACT_FRAGMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
fragment
'
)
:
0xeacb
;
var
REACT_STRICT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
strict_mode
'
)
:
0xeacc
;
var
REACT_PROFILER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
profiler
'
)
:
0xead2
;
var
REACT_PROVIDER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
provider
'
)
:
0xeacd
;
var
REACT_CONTEXT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
context
'
)
:
0xeace
;
var
REACT_ASYNC_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
async_mode
'
)
:
0xeacf
;
var
REACT_FORWARD_REF_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
forward_ref
'
)
:
0xead0
;
var
REACT_TIMEOUT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
timeout
'
)
:
0xead1
;
var
MAYBE_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
if
(
maybeIterable
=
=
=
null
|
|
typeof
maybeIterable
=
=
=
'
undefined
'
)
{
return
null
;
}
var
maybeIterator
=
MAYBE_ITERATOR_SYMBOL
&
&
maybeIterable
[
MAYBE_ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
;
if
(
typeof
maybeIterator
=
=
=
'
function
'
)
{
return
maybeIterator
;
}
return
null
;
}
function
getComponentName
(
fiber
)
{
var
type
=
fiber
.
type
;
if
(
typeof
type
=
=
=
'
function
'
)
{
return
type
.
displayName
|
|
type
.
name
;
}
if
(
typeof
type
=
=
=
'
string
'
)
{
return
type
;
}
switch
(
type
)
{
case
REACT_ASYNC_MODE_TYPE
:
return
'
AsyncMode
'
;
case
REACT_CONTEXT_TYPE
:
return
'
Context
.
Consumer
'
;
case
REACT_FRAGMENT_TYPE
:
return
'
ReactFragment
'
;
case
REACT_PORTAL_TYPE
:
return
'
ReactPortal
'
;
case
REACT_PROFILER_TYPE
:
return
'
Profiler
(
'
+
fiber
.
pendingProps
.
id
+
'
)
'
;
case
REACT_PROVIDER_TYPE
:
return
'
Context
.
Provider
'
;
case
REACT_STRICT_MODE_TYPE
:
return
'
StrictMode
'
;
case
REACT_TIMEOUT_TYPE
:
return
'
Timeout
'
;
}
if
(
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
)
{
switch
(
type
.
typeof
)
{
case
REACT_FORWARD_REF_TYPE
:
var
functionName
=
type
.
render
.
displayName
|
|
type
.
render
.
name
|
|
'
'
;
return
functionName
!
=
=
'
'
?
'
ForwardRef
(
'
+
functionName
+
'
)
'
:
'
ForwardRef
'
;
}
}
return
null
;
}
var
IndeterminateComponent
=
0
;
var
FunctionalComponent
=
1
;
var
ClassComponent
=
2
;
var
HostRoot
=
3
;
var
HostPortal
=
4
;
var
HostComponent
=
5
;
var
HostText
=
6
;
var
Fragment
=
10
;
var
Mode
=
11
;
var
ContextConsumer
=
12
;
var
ContextProvider
=
13
;
var
ForwardRef
=
14
;
var
Profiler
=
15
;
var
TimeoutComponent
=
16
;
var
NoEffect
=
0
;
var
PerformedWork
=
1
;
var
Placement
=
2
;
var
Update
=
4
;
var
PlacementAndUpdate
=
6
;
var
Deletion
=
8
;
var
ContentReset
=
16
;
var
Callback
=
32
;
var
DidCapture
=
64
;
var
Ref
=
128
;
var
Snapshot
=
256
;
var
HostEffectMask
=
511
;
var
Incomplete
=
512
;
var
ShouldCapture
=
1024
;
var
MOUNTING
=
1
;
var
MOUNTED
=
2
;
var
UNMOUNTED
=
3
;
function
isFiberMountedImpl
(
fiber
)
{
var
node
=
fiber
;
if
(
!
fiber
.
alternate
)
{
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
while
(
node
.
return
)
{
node
=
node
.
return
;
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
}
}
else
{
while
(
node
.
return
)
{
node
=
node
.
return
;
}
}
if
(
node
.
tag
=
=
=
HostRoot
)
{
return
MOUNTED
;
}
return
UNMOUNTED
;
}
function
isFiberMounted
(
fiber
)
{
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
isMounted
(
component
)
{
var
fiber
=
get
(
component
)
;
if
(
!
fiber
)
{
return
false
;
}
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
assertIsMounted
(
fiber
)
{
!
(
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
}
function
findCurrentFiberUsingSlowPath
(
fiber
)
{
var
alternate
=
fiber
.
alternate
;
if
(
!
alternate
)
{
var
state
=
isFiberMountedImpl
(
fiber
)
;
!
(
state
!
=
=
UNMOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
state
=
=
=
MOUNTING
)
{
return
null
;
}
return
fiber
;
}
var
a
=
fiber
;
var
b
=
alternate
;
while
(
true
)
{
var
parentA
=
a
.
return
;
var
parentB
=
parentA
?
parentA
.
alternate
:
null
;
if
(
!
parentA
|
|
!
parentB
)
{
break
;
}
if
(
parentA
.
child
=
=
=
parentB
.
child
)
{
var
child
=
parentA
.
child
;
while
(
child
)
{
if
(
child
=
=
=
a
)
{
assertIsMounted
(
parentA
)
;
return
fiber
;
}
if
(
child
=
=
=
b
)
{
assertIsMounted
(
parentA
)
;
return
alternate
;
}
child
=
child
.
sibling
;
}
reactProdInvariant
(
'
188
'
)
;
}
if
(
a
.
return
!
=
=
b
.
return
)
{
a
=
parentA
;
b
=
parentB
;
}
else
{
var
didFindChild
=
false
;
var
_child
=
parentA
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentA
;
b
=
parentB
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentA
;
a
=
parentB
;
break
;
}
_child
=
_child
.
sibling
;
}
if
(
!
didFindChild
)
{
_child
=
parentB
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentB
;
b
=
parentA
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentB
;
a
=
parentA
;
break
;
}
_child
=
_child
.
sibling
;
}
!
didFindChild
?
reactProdInvariant
(
'
189
'
)
:
void
0
;
}
}
!
(
a
.
alternate
=
=
=
b
)
?
reactProdInvariant
(
'
190
'
)
:
void
0
;
}
!
(
a
.
tag
=
=
=
HostRoot
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
a
.
stateNode
.
current
=
=
=
a
)
{
return
fiber
;
}
return
alternate
;
}
var
emptyObject
=
{
}
;
var
emptyObject_1
=
emptyObject
;
var
nowImplementation
=
function
(
)
{
return
0
;
}
;
var
scheduledCallback
=
null
;
var
yieldedValues
=
null
;
function
scheduleDeferredCallback
1
(
callback
options
)
{
scheduledCallback
=
callback
;
var
fakeCallbackId
=
0
;
return
fakeCallbackId
;
}
function
cancelDeferredCallback
1
(
timeoutID
)
{
scheduledCallback
=
null
;
}
function
setNowImplementation
(
implementation
)
{
nowImplementation
=
implementation
;
}
function
flushAll
(
)
{
yieldedValues
=
null
;
while
(
scheduledCallback
!
=
=
null
)
{
var
cb
=
scheduledCallback
;
scheduledCallback
=
null
;
cb
(
{
timeRemaining
:
function
(
)
{
return
999
;
}
didTimeout
:
false
}
)
;
}
if
(
yieldedValues
=
=
=
null
)
{
return
[
]
;
}
return
yieldedValues
;
}
function
flushThrough
(
expectedValues
)
{
var
didStop
=
false
;
yieldedValues
=
null
;
while
(
scheduledCallback
!
=
=
null
&
&
!
didStop
)
{
var
cb
=
scheduledCallback
;
scheduledCallback
=
null
;
cb
(
{
timeRemaining
:
function
(
)
{
if
(
yieldedValues
!
=
=
null
&
&
yieldedValues
.
length
>
=
expectedValues
.
length
)
{
didStop
=
true
;
return
0
;
}
return
999
;
}
didTimeout
:
false
}
)
;
}
if
(
yieldedValues
=
=
=
null
)
{
yieldedValues
=
[
]
;
}
for
(
var
i
=
0
;
i
<
expectedValues
.
length
;
i
+
+
)
{
var
expectedValue
=
'
"
'
+
expectedValues
[
i
]
+
'
"
'
;
var
yieldedValue
=
i
<
yieldedValues
.
length
?
'
"
'
+
yieldedValues
[
i
]
+
'
"
'
:
'
nothing
'
;
if
(
yieldedValue
!
=
=
expectedValue
)
{
var
error
=
new
Error
(
'
flushThrough
expected
to
yield
'
+
expectedValue
+
'
but
'
+
yieldedValue
+
'
was
yielded
'
)
;
error
.
expectedValues
=
expectedValues
;
error
.
actualValues
=
yieldedValues
;
throw
error
;
}
}
return
yieldedValues
;
}
function
yieldValue
(
value
)
{
if
(
yieldedValues
=
=
=
null
)
{
yieldedValues
=
[
value
]
;
}
else
{
yieldedValues
.
push
(
value
)
;
}
}
function
withCleanYields
(
fn
)
{
yieldedValues
=
[
]
;
fn
(
)
;
return
yieldedValues
;
}
function
shim
(
)
{
reactProdInvariant
(
'
270
'
)
;
}
var
supportsPersistence
=
false
;
var
cloneInstance
=
shim
;
var
createContainerChildSet
=
shim
;
var
appendChildToContainerChildSet
=
shim
;
var
finalizeContainerChildren
=
shim
;
var
replaceContainerChildren
=
shim
;
function
shim
1
(
)
{
reactProdInvariant
(
'
272
'
)
;
}
var
supportsHydration
=
false
;
var
canHydrateInstance
=
shim
1
;
var
canHydrateTextInstance
=
shim
1
;
var
getNextHydratableSibling
=
shim
1
;
var
getFirstHydratableChild
=
shim
1
;
var
hydrateInstance
=
shim
1
;
var
hydrateTextInstance
=
shim
1
;
var
UPDATE_SIGNAL
=
{
}
;
function
getPublicInstance
(
inst
)
{
switch
(
inst
.
tag
)
{
case
'
INSTANCE
'
:
var
_createNodeMock
=
inst
.
rootContainerInstance
.
createNodeMock
;
return
_createNodeMock
(
{
type
:
inst
.
type
props
:
inst
.
props
}
)
;
default
:
return
inst
;
}
}
function
appendChild
(
parentInstance
child
)
{
var
index
=
parentInstance
.
children
.
indexOf
(
child
)
;
if
(
index
!
=
=
-
1
)
{
parentInstance
.
children
.
splice
(
index
1
)
;
}
parentInstance
.
children
.
push
(
child
)
;
}
function
insertBefore
(
parentInstance
child
beforeChild
)
{
var
index
=
parentInstance
.
children
.
indexOf
(
child
)
;
if
(
index
!
=
=
-
1
)
{
parentInstance
.
children
.
splice
(
index
1
)
;
}
var
beforeIndex
=
parentInstance
.
children
.
indexOf
(
beforeChild
)
;
parentInstance
.
children
.
splice
(
beforeIndex
0
child
)
;
}
function
removeChild
(
parentInstance
child
)
{
var
index
=
parentInstance
.
children
.
indexOf
(
child
)
;
parentInstance
.
children
.
splice
(
index
1
)
;
}
function
getRootHostContext
(
rootContainerInstance
)
{
return
emptyObject_1
;
}
function
getChildHostContext
(
parentHostContext
type
rootContainerInstance
)
{
return
emptyObject_1
;
}
function
prepareForCommit
(
containerInfo
)
{
}
function
resetAfterCommit
(
containerInfo
)
{
}
function
createInstance
(
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
return
{
type
:
type
props
:
props
children
:
[
]
rootContainerInstance
:
rootContainerInstance
tag
:
'
INSTANCE
'
}
;
}
function
appendInitialChild
(
parentInstance
child
)
{
var
index
=
parentInstance
.
children
.
indexOf
(
child
)
;
if
(
index
!
=
=
-
1
)
{
parentInstance
.
children
.
splice
(
index
1
)
;
}
parentInstance
.
children
.
push
(
child
)
;
}
function
finalizeInitialChildren
(
testElement
type
props
rootContainerInstance
hostContext
)
{
return
false
;
}
function
prepareUpdate
(
testElement
type
oldProps
newProps
rootContainerInstance
hostContext
)
{
return
UPDATE_SIGNAL
;
}
function
shouldSetTextContent
(
type
props
)
{
return
false
;
}
function
shouldDeprioritizeSubtree
(
type
props
)
{
return
false
;
}
function
createTextInstance
(
text
rootContainerInstance
hostContext
internalInstanceHandle
)
{
return
{
text
:
text
tag
:
'
TEXT
'
}
;
}
var
isPrimaryRenderer
=
true
;
var
now
=
function
(
)
{
return
nowImplementation
(
)
;
}
;
var
scheduleDeferredCallback
=
scheduleDeferredCallback
1
;
var
cancelDeferredCallback
=
cancelDeferredCallback
1
;
var
supportsMutation
=
true
;
function
commitUpdate
(
instance
updatePayload
type
oldProps
newProps
internalInstanceHandle
)
{
instance
.
type
=
type
;
instance
.
props
=
newProps
;
}
function
commitTextUpdate
(
textInstance
oldText
newText
)
{
textInstance
.
text
=
newText
;
}
function
resetTextContent
(
testElement
)
{
}
var
appendChildToContainer
=
appendChild
;
var
insertInContainerBefore
=
insertBefore
;
var
removeChildFromContainer
=
removeChild
;
var
describeComponentFrame
=
function
(
name
source
ownerName
)
{
return
'
\
n
in
'
+
(
name
|
|
'
Unknown
'
)
+
(
source
?
'
(
at
'
+
source
.
fileName
.
replace
(
/
^
.
*
[
\
\
\
/
]
/
'
'
)
+
'
:
'
+
source
.
lineNumber
+
'
)
'
:
ownerName
?
'
(
created
by
'
+
ownerName
+
'
)
'
:
'
'
)
;
}
;
function
describeFiber
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
IndeterminateComponent
:
case
FunctionalComponent
:
case
ClassComponent
:
case
HostComponent
:
var
owner
=
fiber
.
_debugOwner
;
var
source
=
fiber
.
_debugSource
;
var
name
=
getComponentName
(
fiber
)
;
var
ownerName
=
null
;
if
(
owner
)
{
ownerName
=
getComponentName
(
owner
)
;
}
return
describeComponentFrame
(
name
source
ownerName
)
;
default
:
return
'
'
;
}
}
function
getStackAddendumByWorkInProgressFiber
(
workInProgress
)
{
var
info
=
'
'
;
var
node
=
workInProgress
;
do
{
info
+
=
describeFiber
(
node
)
;
node
=
node
.
return
;
}
while
(
node
)
;
return
info
;
}
var
enableUserTimingAPI
=
false
;
var
enableGetDerivedStateFromCatch
=
false
;
var
enableSuspense
=
false
;
var
enableProfilerTimer
=
false
;
var
reactEmoji
=
'
\
u269B
'
;
var
warningEmoji
=
'
\
u26D4
'
;
var
supportsUserTiming
=
typeof
performance
!
=
=
'
undefined
'
&
&
typeof
performance
.
mark
=
=
=
'
function
'
&
&
typeof
performance
.
clearMarks
=
=
=
'
function
'
&
&
typeof
performance
.
measure
=
=
=
'
function
'
&
&
typeof
performance
.
clearMeasures
=
=
=
'
function
'
;
var
currentFiber
=
null
;
var
currentPhase
=
null
;
var
currentPhaseFiber
=
null
;
var
isCommitting
=
false
;
var
hasScheduledUpdateInCurrentCommit
=
false
;
var
hasScheduledUpdateInCurrentPhase
=
false
;
var
commitCountInCurrentWorkLoop
=
0
;
var
effectCountInCurrentCommit
=
0
;
var
isWaitingForCallback
=
false
;
var
labelsInCurrentCommit
=
new
Set
(
)
;
var
formatMarkName
=
function
(
markName
)
{
return
reactEmoji
+
'
'
+
markName
;
}
;
var
formatLabel
=
function
(
label
warning
)
{
var
prefix
=
warning
?
warningEmoji
+
'
'
:
reactEmoji
+
'
'
;
var
suffix
=
warning
?
'
Warning
:
'
+
warning
:
'
'
;
return
'
'
+
prefix
+
label
+
suffix
;
}
;
var
beginMark
=
function
(
markName
)
{
performance
.
mark
(
formatMarkName
(
markName
)
)
;
}
;
var
clearMark
=
function
(
markName
)
{
performance
.
clearMarks
(
formatMarkName
(
markName
)
)
;
}
;
var
endMark
=
function
(
label
markName
warning
)
{
var
formattedMarkName
=
formatMarkName
(
markName
)
;
var
formattedLabel
=
formatLabel
(
label
warning
)
;
try
{
performance
.
measure
(
formattedLabel
formattedMarkName
)
;
}
catch
(
err
)
{
}
performance
.
clearMarks
(
formattedMarkName
)
;
performance
.
clearMeasures
(
formattedLabel
)
;
}
;
var
getFiberMarkName
=
function
(
label
debugID
)
{
return
label
+
'
(
#
'
+
debugID
+
'
)
'
;
}
;
var
getFiberLabel
=
function
(
componentName
isMounted
phase
)
{
if
(
phase
=
=
=
null
)
{
return
componentName
+
'
[
'
+
(
isMounted
?
'
update
'
:
'
mount
'
)
+
'
]
'
;
}
else
{
return
componentName
+
'
.
'
+
phase
;
}
}
;
var
beginFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
if
(
isCommitting
&
&
labelsInCurrentCommit
.
has
(
label
)
)
{
return
false
;
}
labelsInCurrentCommit
.
add
(
label
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
beginMark
(
markName
)
;
return
true
;
}
;
var
clearFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
clearMark
(
markName
)
;
}
;
var
endFiberMark
=
function
(
fiber
phase
warning
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
endMark
(
label
markName
warning
)
;
}
;
var
shouldIgnoreFiber
=
function
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
case
Fragment
:
case
ContextProvider
:
case
ContextConsumer
:
case
Mode
:
return
true
;
default
:
return
false
;
}
}
;
var
clearPendingPhaseMeasurement
=
function
(
)
{
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
clearFiberMark
(
currentPhaseFiber
currentPhase
)
;
}
currentPhaseFiber
=
null
;
currentPhase
=
null
;
hasScheduledUpdateInCurrentPhase
=
false
;
}
;
var
pauseTimers
=
function
(
)
{
var
fiber
=
currentFiber
;
while
(
fiber
)
{
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
endFiberMark
(
fiber
null
null
)
;
}
fiber
=
fiber
.
return
;
}
}
;
var
resumeTimersRecursively
=
function
(
fiber
)
{
if
(
fiber
.
return
!
=
=
null
)
{
resumeTimersRecursively
(
fiber
.
return
)
;
}
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
beginFiberMark
(
fiber
null
)
;
}
}
;
var
resumeTimers
=
function
(
)
{
if
(
currentFiber
!
=
=
null
)
{
resumeTimersRecursively
(
currentFiber
)
;
}
}
;
function
recordEffect
(
)
{
if
(
enableUserTimingAPI
)
{
effectCountInCurrentCommit
+
+
;
}
}
function
recordScheduleUpdate
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
isCommitting
)
{
hasScheduledUpdateInCurrentCommit
=
true
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhase
!
=
=
'
componentWillMount
'
&
&
currentPhase
!
=
=
'
componentWillReceiveProps
'
)
{
hasScheduledUpdateInCurrentPhase
=
true
;
}
}
}
function
startRequestCallbackTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
&
&
!
isWaitingForCallback
)
{
isWaitingForCallback
=
true
;
beginMark
(
'
(
Waiting
for
async
callback
.
.
.
)
'
)
;
}
}
}
function
stopRequestCallbackTimer
(
didExpire
expirationTime
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
)
{
isWaitingForCallback
=
false
;
var
warning
=
didExpire
?
'
React
was
blocked
by
main
thread
'
:
null
;
endMark
(
'
(
Waiting
for
async
callback
.
.
.
will
force
flush
in
'
+
expirationTime
+
'
ms
)
'
'
(
Waiting
for
async
callback
.
.
.
)
'
warning
)
;
}
}
}
function
startWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
;
if
(
!
beginFiberMark
(
fiber
null
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
true
;
}
}
function
cancelWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
clearFiberMark
(
fiber
null
)
;
}
}
function
stopWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
endFiberMark
(
fiber
null
null
)
;
}
}
function
stopFailedWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
var
warning
=
'
An
error
was
thrown
inside
this
error
boundary
'
;
endFiberMark
(
fiber
null
warning
)
;
}
}
function
startPhaseTimer
(
fiber
phase
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
clearPendingPhaseMeasurement
(
)
;
if
(
!
beginFiberMark
(
fiber
phase
)
)
{
return
;
}
currentPhaseFiber
=
fiber
;
currentPhase
=
phase
;
}
}
function
stopPhaseTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
var
warning
=
hasScheduledUpdateInCurrentPhase
?
'
Scheduled
a
cascading
update
'
:
null
;
endFiberMark
(
currentPhaseFiber
currentPhase
warning
)
;
}
currentPhase
=
null
;
currentPhaseFiber
=
null
;
}
}
function
startWorkLoopTimer
(
nextUnitOfWork
)
{
if
(
enableUserTimingAPI
)
{
currentFiber
=
nextUnitOfWork
;
if
(
!
supportsUserTiming
)
{
return
;
}
commitCountInCurrentWorkLoop
=
0
;
beginMark
(
'
(
React
Tree
Reconciliation
)
'
)
;
resumeTimers
(
)
;
}
}
function
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
interruptedBy
!
=
=
null
)
{
if
(
interruptedBy
.
tag
=
=
=
HostRoot
)
{
warning
=
'
A
top
-
level
update
interrupted
the
previous
render
'
;
}
else
{
var
componentName
=
getComponentName
(
interruptedBy
)
|
|
'
Unknown
'
;
warning
=
'
An
update
to
'
+
componentName
+
'
interrupted
the
previous
render
'
;
}
}
else
if
(
commitCountInCurrentWorkLoop
>
1
)
{
warning
=
'
There
were
cascading
updates
'
;
}
commitCountInCurrentWorkLoop
=
0
;
var
label
=
didCompleteRoot
?
'
(
React
Tree
Reconciliation
:
Completed
Root
)
'
:
'
(
React
Tree
Reconciliation
:
Yielded
)
'
;
pauseTimers
(
)
;
endMark
(
label
'
(
React
Tree
Reconciliation
)
'
warning
)
;
}
}
function
startCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
isCommitting
=
true
;
hasScheduledUpdateInCurrentCommit
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
beginMark
(
'
(
Committing
Changes
)
'
)
;
}
}
function
stopCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
hasScheduledUpdateInCurrentCommit
)
{
warning
=
'
Lifecycle
hook
scheduled
a
cascading
update
'
;
}
else
if
(
commitCountInCurrentWorkLoop
>
0
)
{
warning
=
'
Caused
by
a
cascading
update
in
earlier
commit
'
;
}
hasScheduledUpdateInCurrentCommit
=
false
;
commitCountInCurrentWorkLoop
+
+
;
isCommitting
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
endMark
(
'
(
Committing
Changes
)
'
'
(
Committing
Changes
)
'
warning
)
;
}
}
function
startCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Snapshot
Effects
)
'
)
;
}
}
function
stopCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Committing
Snapshot
Effects
:
'
+
count
+
'
Total
)
'
'
(
Committing
Snapshot
Effects
)
'
null
)
;
}
}
function
startCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Host
Effects
)
'
)
;
}
}
function
stopCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Committing
Host
Effects
:
'
+
count
+
'
Total
)
'
'
(
Committing
Host
Effects
)
'
null
)
;
}
}
function
startCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Calling
Lifecycle
Methods
)
'
)
;
}
}
function
stopCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Calling
Lifecycle
Methods
:
'
+
count
+
'
Total
)
'
'
(
Calling
Lifecycle
Methods
)
'
null
)
;
}
}
var
valueStack
=
[
]
;
var
index
=
-
1
;
function
createCursor
(
defaultValue
)
{
return
{
current
:
defaultValue
}
;
}
function
pop
(
cursor
fiber
)
{
if
(
index
<
0
)
{
return
;
}
cursor
.
current
=
valueStack
[
index
]
;
valueStack
[
index
]
=
null
;
index
-
-
;
}
function
push
(
cursor
value
fiber
)
{
index
+
+
;
valueStack
[
index
]
=
cursor
.
current
;
cursor
.
current
=
value
;
}
var
contextStackCursor
=
createCursor
(
emptyObject_1
)
;
var
didPerformWorkStackCursor
=
createCursor
(
false
)
;
var
previousContext
=
emptyObject_1
;
function
getUnmaskedContext
(
workInProgress
)
{
var
hasOwnContext
=
isContextProvider
(
workInProgress
)
;
if
(
hasOwnContext
)
{
return
previousContext
;
}
return
contextStackCursor
.
current
;
}
function
cacheContext
(
workInProgress
unmaskedContext
maskedContext
)
{
var
instance
=
workInProgress
.
stateNode
;
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
unmaskedContext
;
instance
.
__reactInternalMemoizedMaskedChildContext
=
maskedContext
;
}
function
getMaskedContext
(
workInProgress
unmaskedContext
)
{
var
type
=
workInProgress
.
type
;
var
contextTypes
=
type
.
contextTypes
;
if
(
!
contextTypes
)
{
return
emptyObject_1
;
}
var
instance
=
workInProgress
.
stateNode
;
if
(
instance
&
&
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
=
=
unmaskedContext
)
{
return
instance
.
__reactInternalMemoizedMaskedChildContext
;
}
var
context
=
{
}
;
for
(
var
key
in
contextTypes
)
{
context
[
key
]
=
unmaskedContext
[
key
]
;
}
if
(
instance
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
context
;
}
function
hasContextChanged
(
)
{
return
didPerformWorkStackCursor
.
current
;
}
function
isContextConsumer
(
fiber
)
{
return
fiber
.
tag
=
=
=
ClassComponent
&
&
fiber
.
type
.
contextTypes
!
=
null
;
}
function
isContextProvider
(
fiber
)
{
return
fiber
.
tag
=
=
=
ClassComponent
&
&
fiber
.
type
.
childContextTypes
!
=
null
;
}
function
popContextProvider
(
fiber
)
{
if
(
!
isContextProvider
(
fiber
)
)
{
return
;
}
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
popTopLevelContextObject
(
fiber
)
{
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
pushTopLevelContextObject
(
fiber
context
didChange
)
{
!
(
contextStackCursor
.
current
=
=
=
emptyObject_1
)
?
reactProdInvariant
(
'
168
'
)
:
void
0
;
push
(
contextStackCursor
context
fiber
)
;
push
(
didPerformWorkStackCursor
didChange
fiber
)
;
}
function
processChildContext
(
fiber
parentContext
)
{
var
instance
=
fiber
.
stateNode
;
var
childContextTypes
=
fiber
.
type
.
childContextTypes
;
if
(
typeof
instance
.
getChildContext
!
=
=
'
function
'
)
{
return
parentContext
;
}
var
childContext
=
void
0
;
startPhaseTimer
(
fiber
'
getChildContext
'
)
;
childContext
=
instance
.
getChildContext
(
)
;
stopPhaseTimer
(
)
;
for
(
var
contextKey
in
childContext
)
{
!
(
contextKey
in
childContextTypes
)
?
reactProdInvariant
(
'
108
'
getComponentName
(
fiber
)
|
|
'
Unknown
'
contextKey
)
:
void
0
;
}
return
_assign
(
{
}
parentContext
childContext
)
;
}
function
pushContextProvider
(
workInProgress
)
{
if
(
!
isContextProvider
(
workInProgress
)
)
{
return
false
;
}
var
instance
=
workInProgress
.
stateNode
;
var
memoizedMergedChildContext
=
instance
&
&
instance
.
__reactInternalMemoizedMergedChildContext
|
|
emptyObject_1
;
previousContext
=
contextStackCursor
.
current
;
push
(
contextStackCursor
memoizedMergedChildContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didPerformWorkStackCursor
.
current
workInProgress
)
;
return
true
;
}
function
invalidateContextProvider
(
workInProgress
didChange
)
{
var
instance
=
workInProgress
.
stateNode
;
!
instance
?
reactProdInvariant
(
'
169
'
)
:
void
0
;
if
(
didChange
)
{
var
mergedContext
=
processChildContext
(
workInProgress
previousContext
)
;
instance
.
__reactInternalMemoizedMergedChildContext
=
mergedContext
;
pop
(
didPerformWorkStackCursor
workInProgress
)
;
pop
(
contextStackCursor
workInProgress
)
;
push
(
contextStackCursor
mergedContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
else
{
pop
(
didPerformWorkStackCursor
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
}
function
findCurrentUnmaskedContext
(
fiber
)
{
!
(
isFiberMounted
(
fiber
)
&
&
fiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
170
'
)
:
void
0
;
var
node
=
fiber
;
while
(
node
.
tag
!
=
=
HostRoot
)
{
if
(
isContextProvider
(
node
)
)
{
return
node
.
stateNode
.
__reactInternalMemoizedMergedChildContext
;
}
var
parent
=
node
.
return
;
!
parent
?
reactProdInvariant
(
'
171
'
)
:
void
0
;
node
=
parent
;
}
return
node
.
stateNode
.
context
;
}
var
MAX_SIGNED_31_BIT_INT
=
1073741823
;
var
NoWork
=
0
;
var
Sync
=
1
;
var
Never
=
MAX_SIGNED_31_BIT_INT
;
var
UNIT_SIZE
=
10
;
var
MAGIC_NUMBER_OFFSET
=
2
;
function
msToExpirationTime
(
ms
)
{
return
(
ms
/
UNIT_SIZE
|
0
)
+
MAGIC_NUMBER_OFFSET
;
}
function
expirationTimeToMs
(
expirationTime
)
{
return
(
expirationTime
-
MAGIC_NUMBER_OFFSET
)
*
UNIT_SIZE
;
}
function
ceiling
(
num
precision
)
{
return
(
(
num
/
precision
|
0
)
+
1
)
*
precision
;
}
function
computeExpirationBucket
(
currentTime
expirationInMs
bucketSizeMs
)
{
return
MAGIC_NUMBER_OFFSET
+
ceiling
(
currentTime
-
MAGIC_NUMBER_OFFSET
+
expirationInMs
/
UNIT_SIZE
bucketSizeMs
/
UNIT_SIZE
)
;
}
var
NoContext
=
0
;
var
AsyncMode
=
1
;
var
StrictMode
=
2
;
var
ProfileMode
=
4
;
function
FiberNode
(
tag
pendingProps
key
mode
)
{
this
.
tag
=
tag
;
this
.
key
=
key
;
this
.
type
=
null
;
this
.
stateNode
=
null
;
this
.
return
=
null
;
this
.
child
=
null
;
this
.
sibling
=
null
;
this
.
index
=
0
;
this
.
ref
=
null
;
this
.
pendingProps
=
pendingProps
;
this
.
memoizedProps
=
null
;
this
.
updateQueue
=
null
;
this
.
memoizedState
=
null
;
this
.
mode
=
mode
;
this
.
effectTag
=
NoEffect
;
this
.
nextEffect
=
null
;
this
.
firstEffect
=
null
;
this
.
lastEffect
=
null
;
this
.
expirationTime
=
NoWork
;
this
.
alternate
=
null
;
if
(
enableProfilerTimer
)
{
this
.
actualDuration
=
0
;
this
.
actualStartTime
=
0
;
this
.
selfBaseTime
=
0
;
this
.
treeBaseTime
=
0
;
}
}
var
createFiber
=
function
(
tag
pendingProps
key
mode
)
{
return
new
FiberNode
(
tag
pendingProps
key
mode
)
;
}
;
function
shouldConstruct
(
Component
)
{
return
!
!
(
Component
.
prototype
&
&
Component
.
prototype
.
isReactComponent
)
;
}
function
createWorkInProgress
(
current
pendingProps
expirationTime
)
{
var
workInProgress
=
current
.
alternate
;
if
(
workInProgress
=
=
=
null
)
{
workInProgress
=
createFiber
(
current
.
tag
pendingProps
current
.
key
current
.
mode
)
;
workInProgress
.
type
=
current
.
type
;
workInProgress
.
stateNode
=
current
.
stateNode
;
workInProgress
.
alternate
=
current
;
current
.
alternate
=
workInProgress
;
}
else
{
workInProgress
.
pendingProps
=
pendingProps
;
workInProgress
.
effectTag
=
NoEffect
;
workInProgress
.
nextEffect
=
null
;
workInProgress
.
firstEffect
=
null
;
workInProgress
.
lastEffect
=
null
;
if
(
enableProfilerTimer
)
{
workInProgress
.
actualDuration
=
0
;
workInProgress
.
actualStartTime
=
0
;
}
}
workInProgress
.
expirationTime
=
expirationTime
;
workInProgress
.
child
=
current
.
child
;
workInProgress
.
memoizedProps
=
current
.
memoizedProps
;
workInProgress
.
memoizedState
=
current
.
memoizedState
;
workInProgress
.
updateQueue
=
current
.
updateQueue
;
workInProgress
.
sibling
=
current
.
sibling
;
workInProgress
.
index
=
current
.
index
;
workInProgress
.
ref
=
current
.
ref
;
if
(
enableProfilerTimer
)
{
workInProgress
.
selfBaseTime
=
current
.
selfBaseTime
;
workInProgress
.
treeBaseTime
=
current
.
treeBaseTime
;
}
return
workInProgress
;
}
function
createHostRootFiber
(
isAsync
)
{
var
mode
=
isAsync
?
AsyncMode
|
StrictMode
:
NoContext
;
return
createFiber
(
HostRoot
null
null
mode
)
;
}
function
createFiberFromElement
(
element
mode
expirationTime
)
{
var
owner
=
null
;
var
fiber
=
void
0
;
var
type
=
element
.
type
;
var
key
=
element
.
key
;
var
pendingProps
=
element
.
props
;
var
fiberTag
=
void
0
;
if
(
typeof
type
=
=
=
'
function
'
)
{
fiberTag
=
shouldConstruct
(
type
)
?
ClassComponent
:
IndeterminateComponent
;
}
else
if
(
typeof
type
=
=
=
'
string
'
)
{
fiberTag
=
HostComponent
;
}
else
{
switch
(
type
)
{
case
REACT_FRAGMENT_TYPE
:
return
createFiberFromFragment
(
pendingProps
.
children
mode
expirationTime
key
)
;
case
REACT_ASYNC_MODE_TYPE
:
fiberTag
=
Mode
;
mode
|
=
AsyncMode
|
StrictMode
;
break
;
case
REACT_STRICT_MODE_TYPE
:
fiberTag
=
Mode
;
mode
|
=
StrictMode
;
break
;
case
REACT_PROFILER_TYPE
:
return
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
;
case
REACT_TIMEOUT_TYPE
:
fiberTag
=
TimeoutComponent
;
mode
|
=
StrictMode
;
break
;
default
:
fiberTag
=
getFiberTagFromObjectType
(
type
owner
)
;
break
;
}
}
fiber
=
createFiber
(
fiberTag
pendingProps
key
mode
)
;
fiber
.
type
=
type
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
getFiberTagFromObjectType
(
type
owner
)
{
var
typeof
=
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
?
type
.
typeof
:
null
;
switch
(
typeof
)
{
case
REACT_PROVIDER_TYPE
:
return
ContextProvider
;
case
REACT_CONTEXT_TYPE
:
return
ContextConsumer
;
case
REACT_FORWARD_REF_TYPE
:
return
ForwardRef
;
default
:
{
var
info
=
'
'
;
reactProdInvariant
(
'
130
'
type
=
=
null
?
type
:
typeof
type
info
)
;
}
}
}
function
createFiberFromFragment
(
elements
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Fragment
elements
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Profiler
pendingProps
key
mode
|
ProfileMode
)
;
fiber
.
type
=
REACT_PROFILER_TYPE
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromText
(
content
mode
expirationTime
)
{
var
fiber
=
createFiber
(
HostText
content
null
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromHostInstanceForDeletion
(
)
{
var
fiber
=
createFiber
(
HostComponent
null
null
NoContext
)
;
fiber
.
type
=
'
DELETED
'
;
return
fiber
;
}
function
createFiberFromPortal
(
portal
mode
expirationTime
)
{
var
pendingProps
=
portal
.
children
!
=
=
null
?
portal
.
children
:
[
]
;
var
fiber
=
createFiber
(
HostPortal
pendingProps
portal
.
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
fiber
.
stateNode
=
{
containerInfo
:
portal
.
containerInfo
pendingChildren
:
null
implementation
:
portal
.
implementation
}
;
return
fiber
;
}
function
createFiberRoot
(
containerInfo
isAsync
hydrate
)
{
var
uninitializedFiber
=
createHostRootFiber
(
isAsync
)
;
var
root
=
{
current
:
uninitializedFiber
containerInfo
:
containerInfo
pendingChildren
:
null
earliestPendingTime
:
NoWork
latestPendingTime
:
NoWork
earliestSuspendedTime
:
NoWork
latestSuspendedTime
:
NoWork
latestPingedTime
:
NoWork
pendingCommitExpirationTime
:
NoWork
finishedWork
:
null
context
:
null
pendingContext
:
null
hydrate
:
hydrate
remainingExpirationTime
:
NoWork
firstBatch
:
null
nextScheduledRoot
:
null
}
;
uninitializedFiber
.
stateNode
=
root
;
return
root
;
}
var
onCommitFiberRoot
=
null
;
var
onCommitFiberUnmount
=
null
;
function
onCommitRoot
(
root
)
{
if
(
typeof
onCommitFiberRoot
=
=
=
'
function
'
)
{
onCommitFiberRoot
(
root
)
;
}
}
function
onCommitUnmount
(
fiber
)
{
if
(
typeof
onCommitFiberUnmount
=
=
=
'
function
'
)
{
onCommitFiberUnmount
(
fiber
)
;
}
}
function
markPendingPriorityLevel
(
root
expirationTime
)
{
if
(
enableSuspense
)
{
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestPendingTime
=
=
=
NoWork
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
expirationTime
;
}
else
{
if
(
earliestPendingTime
>
expirationTime
)
{
root
.
earliestPendingTime
=
expirationTime
;
}
else
{
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
latestPendingTime
<
expirationTime
)
{
root
.
latestPendingTime
=
expirationTime
;
}
}
}
}
}
function
markCommittedPriorityLevels
(
root
currentTime
earliestRemainingTime
)
{
if
(
enableSuspense
)
{
if
(
earliestRemainingTime
=
=
=
NoWork
)
{
root
.
earliestPendingTime
=
NoWork
;
root
.
latestPendingTime
=
NoWork
;
root
.
earliestSuspendedTime
=
NoWork
;
root
.
latestSuspendedTime
=
NoWork
;
root
.
latestPingedTime
=
NoWork
;
return
;
}
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
latestPendingTime
!
=
=
NoWork
)
{
if
(
latestPendingTime
<
earliestRemainingTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
NoWork
;
}
else
{
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestPendingTime
<
earliestRemainingTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
;
}
}
}
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
return
;
}
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
earliestRemainingTime
>
latestSuspendedTime
)
{
root
.
earliestSuspendedTime
=
NoWork
;
root
.
latestSuspendedTime
=
NoWork
;
root
.
latestPingedTime
=
NoWork
;
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
return
;
}
if
(
earliestRemainingTime
<
earliestSuspendedTime
)
{
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
return
;
}
}
}
function
markSuspendedPriorityLevel
(
root
suspendedTime
)
{
if
(
enableSuspense
)
{
var
earliestPendingTime
=
root
.
earliestPendingTime
;
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
earliestPendingTime
=
=
=
suspendedTime
)
{
if
(
latestPendingTime
=
=
=
suspendedTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
NoWork
;
}
else
{
root
.
earliestPendingTime
=
latestPendingTime
;
}
}
else
if
(
latestPendingTime
=
=
=
suspendedTime
)
{
root
.
latestPendingTime
=
earliestPendingTime
;
}
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
latestSuspendedTime
=
=
=
suspendedTime
)
{
root
.
latestPingedTime
=
NoWork
;
}
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
root
.
earliestSuspendedTime
=
root
.
latestSuspendedTime
=
suspendedTime
;
}
else
{
if
(
earliestSuspendedTime
>
suspendedTime
)
{
root
.
earliestSuspendedTime
=
suspendedTime
;
}
else
if
(
latestSuspendedTime
<
suspendedTime
)
{
root
.
latestSuspendedTime
=
suspendedTime
;
}
}
}
}
function
markPingedPriorityLevel
(
root
pingedTime
)
{
if
(
enableSuspense
)
{
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
latestSuspendedTime
!
=
=
NoWork
&
&
latestSuspendedTime
<
=
pingedTime
)
{
var
latestPingedTime
=
root
.
latestPingedTime
;
if
(
latestPingedTime
=
=
=
NoWork
|
|
latestPingedTime
<
pingedTime
)
{
root
.
latestPingedTime
=
pingedTime
;
}
}
}
}
function
findNextPendingPriorityLevel
(
root
)
{
if
(
enableSuspense
)
{
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
return
earliestPendingTime
;
}
if
(
earliestPendingTime
!
=
=
NoWork
)
{
return
earliestPendingTime
;
}
return
root
.
latestPingedTime
;
}
else
{
return
root
.
current
.
expirationTime
;
}
}
var
UpdateState
=
0
;
var
ReplaceState
=
1
;
var
ForceUpdate
=
2
;
var
CaptureUpdate
=
3
;
var
hasForceUpdate
=
false
;
function
createUpdateQueue
(
baseState
)
{
var
queue
=
{
expirationTime
:
NoWork
baseState
:
baseState
firstUpdate
:
null
lastUpdate
:
null
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
cloneUpdateQueue
(
currentQueue
)
{
var
queue
=
{
expirationTime
:
currentQueue
.
expirationTime
baseState
:
currentQueue
.
baseState
firstUpdate
:
currentQueue
.
firstUpdate
lastUpdate
:
currentQueue
.
lastUpdate
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
createUpdate
(
expirationTime
)
{
return
{
expirationTime
:
expirationTime
tag
:
UpdateState
payload
:
null
callback
:
null
next
:
null
nextEffect
:
null
}
;
}
function
appendUpdateToQueue
(
queue
update
expirationTime
)
{
if
(
queue
.
lastUpdate
=
=
=
null
)
{
queue
.
firstUpdate
=
queue
.
lastUpdate
=
update
;
}
else
{
queue
.
lastUpdate
.
next
=
update
;
queue
.
lastUpdate
=
update
;
}
if
(
queue
.
expirationTime
=
=
=
NoWork
|
|
queue
.
expirationTime
>
expirationTime
)
{
queue
.
expirationTime
=
expirationTime
;
}
}
function
enqueueUpdate
(
fiber
update
expirationTime
)
{
var
alternate
=
fiber
.
alternate
;
var
queue1
=
void
0
;
var
queue2
=
void
0
;
if
(
alternate
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
;
queue2
=
null
;
if
(
queue1
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
}
}
else
{
queue1
=
fiber
.
updateQueue
;
queue2
=
alternate
.
updateQueue
;
if
(
queue1
=
=
=
null
)
{
if
(
queue2
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
queue2
=
alternate
.
updateQueue
=
createUpdateQueue
(
alternate
.
memoizedState
)
;
}
else
{
queue1
=
fiber
.
updateQueue
=
cloneUpdateQueue
(
queue2
)
;
}
}
else
{
if
(
queue2
=
=
=
null
)
{
queue2
=
alternate
.
updateQueue
=
cloneUpdateQueue
(
queue1
)
;
}
else
{
}
}
}
if
(
queue2
=
=
=
null
|
|
queue1
=
=
=
queue2
)
{
appendUpdateToQueue
(
queue1
update
expirationTime
)
;
}
else
{
if
(
queue1
.
lastUpdate
=
=
=
null
|
|
queue2
.
lastUpdate
=
=
=
null
)
{
appendUpdateToQueue
(
queue1
update
expirationTime
)
;
appendUpdateToQueue
(
queue2
update
expirationTime
)
;
}
else
{
appendUpdateToQueue
(
queue1
update
expirationTime
)
;
queue2
.
lastUpdate
=
update
;
}
}
}
function
enqueueCapturedUpdate
(
workInProgress
update
renderExpirationTime
)
{
var
workInProgressQueue
=
workInProgress
.
updateQueue
;
if
(
workInProgressQueue
=
=
=
null
)
{
workInProgressQueue
=
workInProgress
.
updateQueue
=
createUpdateQueue
(
workInProgress
.
memoizedState
)
;
}
else
{
workInProgressQueue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
workInProgressQueue
)
;
}
if
(
workInProgressQueue
.
lastCapturedUpdate
=
=
=
null
)
{
workInProgressQueue
.
firstCapturedUpdate
=
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
else
{
workInProgressQueue
.
lastCapturedUpdate
.
next
=
update
;
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
if
(
workInProgressQueue
.
expirationTime
=
=
=
NoWork
|
|
workInProgressQueue
.
expirationTime
>
renderExpirationTime
)
{
workInProgressQueue
.
expirationTime
=
renderExpirationTime
;
}
}
function
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
{
var
current
=
workInProgress
.
alternate
;
if
(
current
!
=
=
null
)
{
if
(
queue
=
=
=
current
.
updateQueue
)
{
queue
=
workInProgress
.
updateQueue
=
cloneUpdateQueue
(
queue
)
;
}
}
return
queue
;
}
function
getStateFromUpdate
(
workInProgress
queue
update
prevState
nextProps
instance
)
{
switch
(
update
.
tag
)
{
case
ReplaceState
:
{
var
_payload
=
update
.
payload
;
if
(
typeof
_payload
=
=
=
'
function
'
)
{
return
_payload
.
call
(
instance
prevState
nextProps
)
;
}
return
_payload
;
}
case
CaptureUpdate
:
{
workInProgress
.
effectTag
=
workInProgress
.
effectTag
&
~
ShouldCapture
|
DidCapture
;
}
case
UpdateState
:
{
var
_payload2
=
update
.
payload
;
var
partialState
=
void
0
;
if
(
typeof
_payload2
=
=
=
'
function
'
)
{
partialState
=
_payload2
.
call
(
instance
prevState
nextProps
)
;
}
else
{
partialState
=
_payload2
;
}
if
(
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
)
{
return
prevState
;
}
return
_assign
(
{
}
prevState
partialState
)
;
}
case
ForceUpdate
:
{
hasForceUpdate
=
true
;
return
prevState
;
}
}
return
prevState
;
}
function
processUpdateQueue
(
workInProgress
queue
props
instance
renderExpirationTime
)
{
hasForceUpdate
=
false
;
if
(
queue
.
expirationTime
=
=
=
NoWork
|
|
queue
.
expirationTime
>
renderExpirationTime
)
{
return
;
}
queue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
;
var
newBaseState
=
queue
.
baseState
;
var
newFirstUpdate
=
null
;
var
newExpirationTime
=
NoWork
;
var
update
=
queue
.
firstUpdate
;
var
resultState
=
newBaseState
;
while
(
update
!
=
=
null
)
{
var
updateExpirationTime
=
update
.
expirationTime
;
if
(
updateExpirationTime
>
renderExpirationTime
)
{
if
(
newFirstUpdate
=
=
=
null
)
{
newFirstUpdate
=
update
;
newBaseState
=
resultState
;
}
if
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
updateExpirationTime
)
{
newExpirationTime
=
updateExpirationTime
;
}
}
else
{
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
_callback
=
update
.
callback
;
if
(
_callback
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastEffect
=
=
=
null
)
{
queue
.
firstEffect
=
queue
.
lastEffect
=
update
;
}
else
{
queue
.
lastEffect
.
nextEffect
=
update
;
queue
.
lastEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
var
newFirstCapturedUpdate
=
null
;
update
=
queue
.
firstCapturedUpdate
;
while
(
update
!
=
=
null
)
{
var
_updateExpirationTime
=
update
.
expirationTime
;
if
(
_updateExpirationTime
>
renderExpirationTime
)
{
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
newFirstCapturedUpdate
=
update
;
if
(
newFirstUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
}
if
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
_updateExpirationTime
)
{
newExpirationTime
=
_updateExpirationTime
;
}
}
else
{
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
_callback2
=
update
.
callback
;
if
(
_callback2
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastCapturedEffect
=
=
=
null
)
{
queue
.
firstCapturedEffect
=
queue
.
lastCapturedEffect
=
update
;
}
else
{
queue
.
lastCapturedEffect
.
nextEffect
=
update
;
queue
.
lastCapturedEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
if
(
newFirstUpdate
=
=
=
null
)
{
queue
.
lastUpdate
=
null
;
}
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
queue
.
lastCapturedUpdate
=
null
;
}
else
{
workInProgress
.
effectTag
|
=
Callback
;
}
if
(
newFirstUpdate
=
=
=
null
&
&
newFirstCapturedUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
queue
.
baseState
=
newBaseState
;
queue
.
firstUpdate
=
newFirstUpdate
;
queue
.
firstCapturedUpdate
=
newFirstCapturedUpdate
;
queue
.
expirationTime
=
newExpirationTime
;
workInProgress
.
memoizedState
=
resultState
;
}
function
callCallback
(
callback
context
)
{
!
(
typeof
callback
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
191
'
callback
)
:
void
0
;
callback
.
call
(
context
)
;
}
function
resetHasForceUpdateBeforeProcessing
(
)
{
hasForceUpdate
=
false
;
}
function
checkHasForceUpdateAfterProcessing
(
)
{
return
hasForceUpdate
;
}
function
commitUpdateQueue
(
finishedWork
finishedQueue
instance
renderExpirationTime
)
{
if
(
finishedQueue
.
firstCapturedUpdate
!
=
=
null
)
{
if
(
finishedQueue
.
lastUpdate
!
=
=
null
)
{
finishedQueue
.
lastUpdate
.
next
=
finishedQueue
.
firstCapturedUpdate
;
finishedQueue
.
lastUpdate
=
finishedQueue
.
lastCapturedUpdate
;
}
finishedQueue
.
firstCapturedUpdate
=
finishedQueue
.
lastCapturedUpdate
=
null
;
}
var
effect
=
finishedQueue
.
firstEffect
;
finishedQueue
.
firstEffect
=
finishedQueue
.
lastEffect
=
null
;
while
(
effect
!
=
=
null
)
{
var
_callback3
=
effect
.
callback
;
if
(
_callback3
!
=
=
null
)
{
effect
.
callback
=
null
;
callCallback
(
_callback3
instance
)
;
}
effect
=
effect
.
nextEffect
;
}
effect
=
finishedQueue
.
firstCapturedEffect
;
finishedQueue
.
firstCapturedEffect
=
finishedQueue
.
lastCapturedEffect
=
null
;
while
(
effect
!
=
=
null
)
{
var
_callback4
=
effect
.
callback
;
if
(
_callback4
!
=
=
null
)
{
effect
.
callback
=
null
;
callCallback
(
_callback4
instance
)
;
}
effect
=
effect
.
nextEffect
;
}
}
function
createCapturedValue
(
value
source
)
{
return
{
value
:
value
source
:
source
stack
:
getStackAddendumByWorkInProgressFiber
(
source
)
}
;
}
var
providerCursor
=
createCursor
(
null
)
;
var
valueCursor
=
createCursor
(
null
)
;
var
changedBitsCursor
=
createCursor
(
0
)
;
function
pushProvider
(
providerFiber
)
{
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
push
(
changedBitsCursor
context
.
_changedBits
providerFiber
)
;
push
(
valueCursor
context
.
_currentValue
providerFiber
)
;
push
(
providerCursor
providerFiber
providerFiber
)
;
context
.
_currentValue
=
providerFiber
.
pendingProps
.
value
;
context
.
_changedBits
=
providerFiber
.
stateNode
;
}
else
{
push
(
changedBitsCursor
context
.
_changedBits2
providerFiber
)
;
push
(
valueCursor
context
.
_currentValue2
providerFiber
)
;
push
(
providerCursor
providerFiber
providerFiber
)
;
context
.
_currentValue2
=
providerFiber
.
pendingProps
.
value
;
context
.
_changedBits2
=
providerFiber
.
stateNode
;
}
}
function
popProvider
(
providerFiber
)
{
var
changedBits
=
changedBitsCursor
.
current
;
var
currentValue
=
valueCursor
.
current
;
pop
(
providerCursor
providerFiber
)
;
pop
(
valueCursor
providerFiber
)
;
pop
(
changedBitsCursor
providerFiber
)
;
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
context
.
_currentValue
=
currentValue
;
context
.
_changedBits
=
changedBits
;
}
else
{
context
.
_currentValue2
=
currentValue
;
context
.
_changedBits2
=
changedBits
;
}
}
function
getContextCurrentValue
(
context
)
{
return
isPrimaryRenderer
?
context
.
_currentValue
:
context
.
_currentValue2
;
}
function
getContextChangedBits
(
context
)
{
return
isPrimaryRenderer
?
context
.
_changedBits
:
context
.
_changedBits2
;
}
var
NO_CONTEXT
=
{
}
;
var
contextStackCursor
1
=
createCursor
(
NO_CONTEXT
)
;
var
contextFiberStackCursor
=
createCursor
(
NO_CONTEXT
)
;
var
rootInstanceStackCursor
=
createCursor
(
NO_CONTEXT
)
;
function
requiredContext
(
c
)
{
!
(
c
!
=
=
NO_CONTEXT
)
?
reactProdInvariant
(
'
174
'
)
:
void
0
;
return
c
;
}
function
getRootHostContainer
(
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
return
rootInstance
;
}
function
pushHostContainer
(
fiber
nextRootInstance
)
{
push
(
rootInstanceStackCursor
nextRootInstance
fiber
)
;
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
NO_CONTEXT
fiber
)
;
var
nextRootContext
=
getRootHostContext
(
nextRootInstance
)
;
pop
(
contextStackCursor
1
fiber
)
;
push
(
contextStackCursor
1
nextRootContext
fiber
)
;
}
function
popHostContainer
(
fiber
)
{
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
pop
(
rootInstanceStackCursor
fiber
)
;
}
function
getHostContext
(
)
{
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
return
context
;
}
function
pushHostContext
(
fiber
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
var
nextContext
=
getChildHostContext
(
context
fiber
.
type
rootInstance
)
;
if
(
context
=
=
=
nextContext
)
{
return
;
}
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
nextContext
fiber
)
;
}
function
popHostContext
(
fiber
)
{
if
(
contextFiberStackCursor
.
current
!
=
=
fiber
)
{
return
;
}
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
}
var
commitTime
=
0
;
function
getCommitTime
(
)
{
return
commitTime
;
}
function
recordCommitTime
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
commitTime
=
now
(
)
;
}
var
timerPausedAt
=
0
;
var
totalElapsedPauseTime
=
0
;
function
markActualRenderTimeStarted
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
fiber
.
actualDuration
=
now
(
)
-
fiber
.
actualDuration
-
totalElapsedPauseTime
;
fiber
.
actualStartTime
=
now
(
)
;
}
function
pauseActualRenderTimerIfRunning
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
timerPausedAt
=
=
=
0
)
{
timerPausedAt
=
now
(
)
;
}
}
function
recordElapsedActualRenderTime
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
fiber
.
actualDuration
=
now
(
)
-
totalElapsedPauseTime
-
fiber
.
actualDuration
;
}
function
resetActualRenderTimer
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
totalElapsedPauseTime
=
0
;
}
function
resumeActualRenderTimerIfPaused
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
timerPausedAt
>
0
)
{
totalElapsedPauseTime
+
=
now
(
)
-
timerPausedAt
;
timerPausedAt
=
0
;
}
}
var
baseStartTime
=
-
1
;
function
recordElapsedBaseRenderTimeIfRunning
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
baseStartTime
!
=
=
-
1
)
{
fiber
.
selfBaseTime
=
now
(
)
-
baseStartTime
;
}
}
function
startBaseRenderTimer
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
baseStartTime
=
now
(
)
;
}
function
stopBaseRenderTimerIfRunning
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
baseStartTime
=
-
1
;
}
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
is
(
x
y
)
{
if
(
x
=
=
=
y
)
{
return
x
!
=
=
0
|
|
y
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
;
}
else
{
return
x
!
=
=
x
&
&
y
!
=
=
y
;
}
}
function
shallowEqual
(
objA
objB
)
{
if
(
is
(
objA
objB
)
)
{
return
true
;
}
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwnProperty
.
call
(
objB
keysA
[
i
]
)
|
|
!
is
(
objA
[
keysA
[
i
]
]
objB
[
keysA
[
i
]
]
)
)
{
return
false
;
}
}
return
true
;
}
var
shallowEqual_1
=
shallowEqual
;
function
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
nextProps
)
{
var
prevState
=
workInProgress
.
memoizedState
;
var
partialState
=
getDerivedStateFromProps
(
nextProps
prevState
)
;
var
memoizedState
=
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
?
prevState
:
_assign
(
{
}
prevState
partialState
)
;
workInProgress
.
memoizedState
=
memoizedState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
&
&
updateQueue
.
expirationTime
=
=
=
NoWork
)
{
updateQueue
.
baseState
=
memoizedState
;
}
}
var
classComponentUpdater
=
{
isMounted
:
isMounted
enqueueSetState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueReplaceState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
ReplaceState
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueForceUpdate
:
function
(
inst
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
ForceUpdate
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
}
;
function
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
{
var
instance
=
workInProgress
.
stateNode
;
var
ctor
=
workInProgress
.
type
;
if
(
typeof
instance
.
shouldComponentUpdate
=
=
=
'
function
'
)
{
startPhaseTimer
(
workInProgress
'
shouldComponentUpdate
'
)
;
var
shouldUpdate
=
instance
.
shouldComponentUpdate
(
newProps
newState
newContext
)
;
stopPhaseTimer
(
)
;
return
shouldUpdate
;
}
if
(
ctor
.
prototype
&
&
ctor
.
prototype
.
isPureReactComponent
)
{
return
!
shallowEqual_1
(
oldProps
newProps
)
|
|
!
shallowEqual_1
(
oldState
newState
)
;
}
return
true
;
}
function
adoptClassInstance
(
workInProgress
instance
)
{
instance
.
updater
=
classComponentUpdater
;
workInProgress
.
stateNode
=
instance
;
set
(
instance
workInProgress
)
;
}
function
constructClassInstance
(
workInProgress
props
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
needsContext
=
isContextConsumer
(
workInProgress
)
;
var
context
=
needsContext
?
getMaskedContext
(
workInProgress
unmaskedContext
)
:
emptyObject_1
;
var
instance
=
new
ctor
(
props
context
)
;
var
state
=
workInProgress
.
memoizedState
=
instance
.
state
!
=
=
null
&
&
instance
.
state
!
=
=
undefined
?
instance
.
state
:
null
;
adoptClassInstance
(
workInProgress
instance
)
;
if
(
needsContext
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
instance
;
}
function
callComponentWillMount
(
workInProgress
instance
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
var
oldState
=
instance
.
state
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
if
(
oldState
!
=
=
instance
.
state
)
{
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
{
var
oldState
=
instance
.
state
;
startPhaseTimer
(
workInProgress
'
componentWillReceiveProps
'
)
;
if
(
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
componentWillReceiveProps
(
newProps
newContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillReceiveProps
(
newProps
newContext
)
;
}
stopPhaseTimer
(
)
;
if
(
instance
.
state
!
=
=
oldState
)
{
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
mountClassInstance
(
workInProgress
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
var
props
=
workInProgress
.
pendingProps
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
instance
.
props
=
props
;
instance
.
state
=
workInProgress
.
memoizedState
;
instance
.
refs
=
emptyObject_1
;
instance
.
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
props
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
var
getDerivedStateFromProps
=
workInProgress
.
type
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
props
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
if
(
typeof
ctor
.
getDerivedStateFromProps
!
=
=
'
function
'
&
&
typeof
instance
.
getSnapshotBeforeUpdate
!
=
=
'
function
'
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
callComponentWillMount
(
workInProgress
instance
)
;
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
props
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
function
resumeMountClassInstance
(
workInProgress
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newProps
=
workInProgress
.
pendingProps
;
instance
.
props
=
oldProps
;
var
oldContext
=
instance
.
context
;
var
newUnmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
newContext
=
getMaskedContext
(
workInProgress
newUnmaskedContext
)
;
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
newContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
else
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
newContext
;
return
shouldUpdate
;
}
function
updateClassInstance
(
current
workInProgress
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newProps
=
workInProgress
.
pendingProps
;
instance
.
props
=
oldProps
;
var
oldContext
=
instance
.
context
;
var
newUnmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
newContext
=
getMaskedContext
(
workInProgress
newUnmaskedContext
)
;
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
newContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillUpdate
'
)
;
if
(
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
componentWillUpdate
(
newProps
newState
newContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillUpdate
(
newProps
newState
newContext
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
else
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
newContext
;
return
shouldUpdate
;
}
var
isArray
1
=
Array
.
isArray
;
function
coerceRef
(
returnFiber
current
element
)
{
var
mixedRef
=
element
.
ref
;
if
(
mixedRef
!
=
=
null
&
&
typeof
mixedRef
!
=
=
'
function
'
&
&
typeof
mixedRef
!
=
=
'
object
'
)
{
if
(
element
.
_owner
)
{
var
owner
=
element
.
_owner
;
var
inst
=
void
0
;
if
(
owner
)
{
var
ownerFiber
=
owner
;
!
(
ownerFiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
110
'
)
:
void
0
;
inst
=
ownerFiber
.
stateNode
;
}
!
inst
?
reactProdInvariant
(
'
147
'
mixedRef
)
:
void
0
;
var
stringRef
=
'
'
+
mixedRef
;
if
(
current
!
=
=
null
&
&
current
.
ref
!
=
=
null
&
&
typeof
current
.
ref
=
=
=
'
function
'
&
&
current
.
ref
.
_stringRef
=
=
=
stringRef
)
{
return
current
.
ref
;
}
var
ref
=
function
(
value
)
{
var
refs
=
inst
.
refs
=
=
=
emptyObject_1
?
inst
.
refs
=
{
}
:
inst
.
refs
;
if
(
value
=
=
=
null
)
{
delete
refs
[
stringRef
]
;
}
else
{
refs
[
stringRef
]
=
value
;
}
}
;
ref
.
_stringRef
=
stringRef
;
return
ref
;
}
else
{
!
(
typeof
mixedRef
=
=
=
'
string
'
)
?
reactProdInvariant
(
'
148
'
)
:
void
0
;
!
element
.
_owner
?
reactProdInvariant
(
'
254
'
mixedRef
)
:
void
0
;
}
}
return
mixedRef
;
}
function
throwOnInvalidObjectType
(
returnFiber
newChild
)
{
if
(
returnFiber
.
type
!
=
=
'
textarea
'
)
{
var
addendum
=
'
'
;
reactProdInvariant
(
'
31
'
Object
.
prototype
.
toString
.
call
(
newChild
)
=
=
=
'
[
object
Object
]
'
?
'
object
with
keys
{
'
+
Object
.
keys
(
newChild
)
.
join
(
'
'
)
+
'
}
'
:
newChild
addendum
)
;
}
}
function
ChildReconciler
(
shouldTrackSideEffects
)
{
function
deleteChild
(
returnFiber
childToDelete
)
{
if
(
!
shouldTrackSideEffects
)
{
return
;
}
var
last
=
returnFiber
.
lastEffect
;
if
(
last
!
=
=
null
)
{
last
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
childToDelete
.
nextEffect
=
null
;
childToDelete
.
effectTag
=
Deletion
;
}
function
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
{
if
(
!
shouldTrackSideEffects
)
{
return
null
;
}
var
childToDelete
=
currentFirstChild
;
while
(
childToDelete
!
=
=
null
)
{
deleteChild
(
returnFiber
childToDelete
)
;
childToDelete
=
childToDelete
.
sibling
;
}
return
null
;
}
function
mapRemainingChildren
(
returnFiber
currentFirstChild
)
{
var
existingChildren
=
new
Map
(
)
;
var
existingChild
=
currentFirstChild
;
while
(
existingChild
!
=
=
null
)
{
if
(
existingChild
.
key
!
=
=
null
)
{
existingChildren
.
set
(
existingChild
.
key
existingChild
)
;
}
else
{
existingChildren
.
set
(
existingChild
.
index
existingChild
)
;
}
existingChild
=
existingChild
.
sibling
;
}
return
existingChildren
;
}
function
useFiber
(
fiber
pendingProps
expirationTime
)
{
var
clone
=
createWorkInProgress
(
fiber
pendingProps
expirationTime
)
;
clone
.
index
=
0
;
clone
.
sibling
=
null
;
return
clone
;
}
function
placeChild
(
newFiber
lastPlacedIndex
newIndex
)
{
newFiber
.
index
=
newIndex
;
if
(
!
shouldTrackSideEffects
)
{
return
lastPlacedIndex
;
}
var
current
=
newFiber
.
alternate
;
if
(
current
!
=
=
null
)
{
var
oldIndex
=
current
.
index
;
if
(
oldIndex
<
lastPlacedIndex
)
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
else
{
return
oldIndex
;
}
}
else
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
}
function
placeSingleChild
(
newFiber
)
{
if
(
shouldTrackSideEffects
&
&
newFiber
.
alternate
=
=
=
null
)
{
newFiber
.
effectTag
=
Placement
;
}
return
newFiber
;
}
function
updateTextNode
(
returnFiber
current
textContent
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
HostText
)
{
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateElement
(
returnFiber
current
element
expirationTime
)
{
if
(
current
!
=
=
null
&
&
current
.
type
=
=
=
element
.
type
)
{
var
existing
=
useFiber
(
current
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
current
element
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
var
created
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
created
.
ref
=
coerceRef
(
returnFiber
current
element
)
;
created
.
return
=
returnFiber
;
return
created
;
}
}
function
updatePortal
(
returnFiber
current
portal
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
HostPortal
|
|
current
.
stateNode
.
containerInfo
!
=
=
portal
.
containerInfo
|
|
current
.
stateNode
.
implementation
!
=
=
portal
.
implementation
)
{
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateFragment
(
returnFiber
current
fragment
expirationTime
key
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
Fragment
)
{
var
created
=
createFiberFromFragment
(
fragment
returnFiber
.
mode
expirationTime
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
fragment
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
createChild
(
returnFiber
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
created
=
createFiberFromText
(
'
'
+
newChild
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_created
=
createFiberFromElement
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created
.
ref
=
coerceRef
(
returnFiber
null
newChild
)
;
_created
.
return
=
returnFiber
;
return
_created
;
}
case
REACT_PORTAL_TYPE
:
{
var
_created2
=
createFiberFromPortal
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created2
.
return
=
returnFiber
;
return
_created2
;
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_created3
=
createFiberFromFragment
(
newChild
returnFiber
.
mode
expirationTime
null
)
;
_created3
.
return
=
returnFiber
;
return
_created3
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateSlot
(
returnFiber
oldFiber
newChild
expirationTime
)
{
var
key
=
oldFiber
!
=
=
null
?
oldFiber
.
key
:
null
;
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateTextNode
(
returnFiber
oldFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
oldFiber
newChild
.
props
.
children
expirationTime
key
)
;
}
return
updateElement
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
case
REACT_PORTAL_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
return
updatePortal
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateFragment
(
returnFiber
oldFiber
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateFromMap
(
existingChildren
returnFiber
newIdx
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
matchedFiber
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateTextNode
(
returnFiber
matchedFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_matchedFiber
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
_matchedFiber
newChild
.
props
.
children
expirationTime
newChild
.
key
)
;
}
return
updateElement
(
returnFiber
_matchedFiber
newChild
expirationTime
)
;
}
case
REACT_PORTAL_TYPE
:
{
var
_matchedFiber2
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
return
updatePortal
(
returnFiber
_matchedFiber2
newChild
expirationTime
)
;
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_matchedFiber3
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateFragment
(
returnFiber
_matchedFiber3
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChildren
expirationTime
)
{
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
for
(
;
oldFiber
!
=
=
null
&
&
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
oldFiber
=
=
=
null
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
newIdx
=
=
=
newChildren
.
length
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber
=
createChild
(
returnFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
!
_newFiber
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber
;
}
previousNewFiber
=
_newFiber
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber2
=
updateFromMap
(
existingChildren
returnFiber
newIdx
newChildren
[
newIdx
]
expirationTime
)
;
if
(
_newFiber2
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber2
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber2
.
key
=
=
=
null
?
newIdx
:
_newFiber2
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber2
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber2
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber2
;
}
previousNewFiber
=
_newFiber2
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChildrenIterable
expirationTime
)
{
var
iteratorFn
=
getIteratorFn
(
newChildrenIterable
)
;
!
(
typeof
iteratorFn
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
150
'
)
:
void
0
;
var
newChildren
=
iteratorFn
.
call
(
newChildrenIterable
)
;
!
(
newChildren
!
=
null
)
?
reactProdInvariant
(
'
151
'
)
:
void
0
;
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
var
step
=
newChildren
.
next
(
)
;
for
(
;
oldFiber
!
=
=
null
&
&
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
step
.
value
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
!
oldFiber
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
step
.
done
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber3
=
createChild
(
returnFiber
step
.
value
expirationTime
)
;
if
(
_newFiber3
=
=
=
null
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber3
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber3
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber3
;
}
previousNewFiber
=
_newFiber3
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber4
=
updateFromMap
(
existingChildren
returnFiber
newIdx
step
.
value
expirationTime
)
;
if
(
_newFiber4
!
=
=
null
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber4
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber4
.
key
=
=
=
null
?
newIdx
:
_newFiber4
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber4
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber4
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber4
;
}
previousNewFiber
=
_newFiber4
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileSingleTextNode
(
returnFiber
currentFirstChild
textContent
expirationTime
)
{
if
(
currentFirstChild
!
=
=
null
&
&
currentFirstChild
.
tag
=
=
=
HostText
)
{
deleteRemainingChildren
(
returnFiber
currentFirstChild
.
sibling
)
;
var
existing
=
useFiber
(
currentFirstChild
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileSingleElement
(
returnFiber
currentFirstChild
element
expirationTime
)
{
var
key
=
element
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
Fragment
?
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
:
child
.
type
=
=
=
element
.
type
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
?
element
.
props
.
children
:
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
child
element
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
if
(
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
var
created
=
createFiberFromFragment
(
element
.
props
.
children
returnFiber
.
mode
expirationTime
element
.
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
_created4
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
_created4
.
ref
=
coerceRef
(
returnFiber
currentFirstChild
element
)
;
_created4
.
return
=
returnFiber
;
return
_created4
;
}
}
function
reconcileSinglePortal
(
returnFiber
currentFirstChild
portal
expirationTime
)
{
var
key
=
portal
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
HostPortal
&
&
child
.
stateNode
.
containerInfo
=
=
=
portal
.
containerInfo
&
&
child
.
stateNode
.
implementation
=
=
=
portal
.
implementation
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileChildFibers
(
returnFiber
currentFirstChild
newChild
expirationTime
)
{
var
isUnkeyedTopLevelFragment
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
&
&
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
&
&
newChild
.
key
=
=
=
null
;
if
(
isUnkeyedTopLevelFragment
)
{
newChild
=
newChild
.
props
.
children
;
}
var
isObject
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
;
if
(
isObject
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
return
placeSingleChild
(
reconcileSingleElement
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
case
REACT_PORTAL_TYPE
:
return
placeSingleChild
(
reconcileSinglePortal
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
}
}
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
return
placeSingleChild
(
reconcileSingleTextNode
(
returnFiber
currentFirstChild
'
'
+
newChild
expirationTime
)
)
;
}
if
(
isArray
1
(
newChild
)
)
{
return
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
getIteratorFn
(
newChild
)
)
{
return
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
isObject
)
{
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
if
(
typeof
newChild
=
=
=
'
undefined
'
&
&
!
isUnkeyedTopLevelFragment
)
{
switch
(
returnFiber
.
tag
)
{
case
ClassComponent
:
{
}
case
FunctionalComponent
:
{
var
Component
=
returnFiber
.
type
;
reactProdInvariant
(
'
152
'
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
;
}
}
}
return
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
}
return
reconcileChildFibers
;
}
var
reconcileChildFibers
=
ChildReconciler
(
true
)
;
var
mountChildFibers
=
ChildReconciler
(
false
)
;
function
cloneChildFibers
(
current
workInProgress
)
{
!
(
current
=
=
=
null
|
|
workInProgress
.
child
=
=
=
current
.
child
)
?
reactProdInvariant
(
'
153
'
)
:
void
0
;
if
(
workInProgress
.
child
=
=
=
null
)
{
return
;
}
var
currentChild
=
workInProgress
.
child
;
var
newChild
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
workInProgress
.
child
=
newChild
;
newChild
.
return
=
workInProgress
;
while
(
currentChild
.
sibling
!
=
=
null
)
{
currentChild
=
currentChild
.
sibling
;
newChild
=
newChild
.
sibling
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
newChild
.
return
=
workInProgress
;
}
newChild
.
sibling
=
null
;
}
var
hydrationParentFiber
=
null
;
var
nextHydratableInstance
=
null
;
var
isHydrating
=
false
;
function
enterHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
var
parentInstance
=
fiber
.
stateNode
.
containerInfo
;
nextHydratableInstance
=
getFirstHydratableChild
(
parentInstance
)
;
hydrationParentFiber
=
fiber
;
isHydrating
=
true
;
return
true
;
}
function
deleteHydratableInstance
(
returnFiber
instance
)
{
var
childToDelete
=
createFiberFromHostInstanceForDeletion
(
)
;
childToDelete
.
stateNode
=
instance
;
childToDelete
.
return
=
returnFiber
;
childToDelete
.
effectTag
=
Deletion
;
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
}
function
insertNonHydratedInstance
(
returnFiber
fiber
)
{
fiber
.
effectTag
|
=
Placement
;
}
function
tryHydrate
(
fiber
nextInstance
)
{
switch
(
fiber
.
tag
)
{
case
HostComponent
:
{
var
type
=
fiber
.
type
;
var
props
=
fiber
.
pendingProps
;
var
instance
=
canHydrateInstance
(
nextInstance
type
props
)
;
if
(
instance
!
=
=
null
)
{
fiber
.
stateNode
=
instance
;
return
true
;
}
return
false
;
}
case
HostText
:
{
var
text
=
fiber
.
pendingProps
;
var
textInstance
=
canHydrateTextInstance
(
nextInstance
text
)
;
if
(
textInstance
!
=
=
null
)
{
fiber
.
stateNode
=
textInstance
;
return
true
;
}
return
false
;
}
default
:
return
false
;
}
}
function
tryToClaimNextHydratableInstance
(
fiber
)
{
if
(
!
isHydrating
)
{
return
;
}
var
nextInstance
=
nextHydratableInstance
;
if
(
!
nextInstance
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
var
firstAttemptedInstance
=
nextInstance
;
if
(
!
tryHydrate
(
fiber
nextInstance
)
)
{
nextInstance
=
getNextHydratableSibling
(
firstAttemptedInstance
)
;
if
(
!
nextInstance
|
|
!
tryHydrate
(
fiber
nextInstance
)
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
deleteHydratableInstance
(
hydrationParentFiber
firstAttemptedInstance
)
;
}
hydrationParentFiber
=
fiber
;
nextHydratableInstance
=
getFirstHydratableChild
(
nextInstance
)
;
}
function
prepareToHydrateHostInstance
(
fiber
rootContainerInstance
hostContext
)
{
if
(
!
supportsHydration
)
{
reactProdInvariant
(
'
175
'
)
;
}
var
instance
=
fiber
.
stateNode
;
var
updatePayload
=
hydrateInstance
(
instance
fiber
.
type
fiber
.
memoizedProps
rootContainerInstance
hostContext
fiber
)
;
fiber
.
updateQueue
=
updatePayload
;
if
(
updatePayload
!
=
=
null
)
{
return
true
;
}
return
false
;
}
function
prepareToHydrateHostTextInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
reactProdInvariant
(
'
176
'
)
;
}
var
textInstance
=
fiber
.
stateNode
;
var
textContent
=
fiber
.
memoizedProps
;
var
shouldUpdate
=
hydrateTextInstance
(
textInstance
textContent
fiber
)
;
return
shouldUpdate
;
}
function
popToNextHostParent
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
&
&
parent
.
tag
!
=
=
HostComponent
&
&
parent
.
tag
!
=
=
HostRoot
)
{
parent
=
parent
.
return
;
}
hydrationParentFiber
=
parent
;
}
function
popHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
if
(
fiber
!
=
=
hydrationParentFiber
)
{
return
false
;
}
if
(
!
isHydrating
)
{
popToNextHostParent
(
fiber
)
;
isHydrating
=
true
;
return
false
;
}
var
type
=
fiber
.
type
;
if
(
fiber
.
tag
!
=
=
HostComponent
|
|
type
!
=
=
'
head
'
&
&
type
!
=
=
'
body
'
&
&
!
shouldSetTextContent
(
type
fiber
.
memoizedProps
)
)
{
var
nextInstance
=
nextHydratableInstance
;
while
(
nextInstance
)
{
deleteHydratableInstance
(
fiber
nextInstance
)
;
nextInstance
=
getNextHydratableSibling
(
nextInstance
)
;
}
}
popToNextHostParent
(
fiber
)
;
nextHydratableInstance
=
hydrationParentFiber
?
getNextHydratableSibling
(
fiber
.
stateNode
)
:
null
;
return
true
;
}
function
resetHydrationState
(
)
{
if
(
!
supportsHydration
)
{
return
;
}
hydrationParentFiber
=
null
;
nextHydratableInstance
=
null
;
isHydrating
=
false
;
}
function
reconcileChildren
(
current
workInProgress
nextChildren
)
{
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
workInProgress
.
expirationTime
)
;
}
function
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
renderExpirationTime
)
{
if
(
current
=
=
=
null
)
{
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
current
.
child
nextChildren
renderExpirationTime
)
;
}
}
function
updateForwardRef
(
current
workInProgress
)
{
var
render
=
workInProgress
.
type
.
render
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
ref
=
workInProgress
.
ref
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
workInProgress
.
memoizedProps
=
=
=
nextProps
)
{
var
currentRef
=
current
!
=
=
null
?
current
.
ref
:
null
;
if
(
ref
=
=
=
currentRef
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
var
nextChildren
=
void
0
;
{
nextChildren
=
render
(
nextProps
ref
)
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateFragment
(
current
workInProgress
)
{
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
return
workInProgress
.
child
;
}
function
updateMode
(
current
workInProgress
)
{
var
nextChildren
=
workInProgress
.
pendingProps
.
children
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
nextChildren
=
=
=
null
|
|
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
return
workInProgress
.
child
;
}
function
updateProfiler
(
current
workInProgress
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
if
(
enableProfilerTimer
)
{
workInProgress
.
effectTag
|
=
Update
;
}
if
(
workInProgress
.
memoizedProps
=
=
=
nextProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
nextChildren
=
nextProps
.
children
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
markRef
(
current
workInProgress
)
{
var
ref
=
workInProgress
.
ref
;
if
(
current
=
=
=
null
&
&
ref
!
=
=
null
|
|
current
!
=
=
null
&
&
current
.
ref
!
=
=
ref
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
}
function
updateFunctionalComponent
(
current
workInProgress
)
{
var
fn
=
workInProgress
.
type
;
var
nextProps
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
}
else
{
if
(
workInProgress
.
memoizedProps
=
=
=
nextProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
nextChildren
=
void
0
;
{
nextChildren
=
fn
(
nextProps
context
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateClassComponent
(
current
workInProgress
renderExpirationTime
)
{
var
hasContext
=
pushContextProvider
(
workInProgress
)
;
var
shouldUpdate
=
void
0
;
if
(
current
=
=
=
null
)
{
if
(
workInProgress
.
stateNode
=
=
=
null
)
{
constructClassInstance
(
workInProgress
workInProgress
.
pendingProps
renderExpirationTime
)
;
mountClassInstance
(
workInProgress
renderExpirationTime
)
;
shouldUpdate
=
true
;
}
else
{
shouldUpdate
=
resumeMountClassInstance
(
workInProgress
renderExpirationTime
)
;
}
}
else
{
shouldUpdate
=
updateClassInstance
(
current
workInProgress
renderExpirationTime
)
;
}
return
finishClassComponent
(
current
workInProgress
shouldUpdate
hasContext
renderExpirationTime
)
;
}
function
finishClassComponent
(
current
workInProgress
shouldUpdate
hasContext
renderExpirationTime
)
{
markRef
(
current
workInProgress
)
;
var
didCaptureError
=
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
if
(
!
shouldUpdate
&
&
!
didCaptureError
)
{
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
false
)
;
}
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
ReactCurrentOwner
.
current
=
workInProgress
;
var
nextChildren
=
void
0
;
if
(
didCaptureError
&
&
(
!
enableGetDerivedStateFromCatch
|
|
typeof
ctor
.
getDerivedStateFromCatch
!
=
=
'
function
'
)
)
{
nextChildren
=
null
;
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
}
else
{
{
nextChildren
=
instance
.
render
(
)
;
}
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
didCaptureError
)
{
reconcileChildrenAtExpirationTime
(
current
workInProgress
null
renderExpirationTime
)
;
workInProgress
.
child
=
null
;
}
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
renderExpirationTime
)
;
memoizeState
(
workInProgress
instance
.
state
)
;
memoizeProps
(
workInProgress
instance
.
props
)
;
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
true
)
;
}
return
workInProgress
.
child
;
}
function
pushHostRootContext
(
workInProgress
)
{
var
root
=
workInProgress
.
stateNode
;
if
(
root
.
pendingContext
)
{
pushTopLevelContextObject
(
workInProgress
root
.
pendingContext
root
.
pendingContext
!
=
=
root
.
context
)
;
}
else
if
(
root
.
context
)
{
pushTopLevelContextObject
(
workInProgress
root
.
context
false
)
;
}
pushHostContainer
(
workInProgress
root
.
containerInfo
)
;
}
function
updateHostRoot
(
current
workInProgress
renderExpirationTime
)
{
pushHostRootContext
(
workInProgress
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevState
=
workInProgress
.
memoizedState
;
var
prevChildren
=
prevState
!
=
=
null
?
prevState
.
element
:
null
;
processUpdateQueue
(
workInProgress
updateQueue
nextProps
null
renderExpirationTime
)
;
var
nextState
=
workInProgress
.
memoizedState
;
var
nextChildren
=
nextState
.
element
;
if
(
nextChildren
=
=
=
prevChildren
)
{
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
root
=
workInProgress
.
stateNode
;
if
(
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
&
&
root
.
hydrate
&
&
enterHydrationState
(
workInProgress
)
)
{
workInProgress
.
effectTag
|
=
Placement
;
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
resetHydrationState
(
)
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
}
return
workInProgress
.
child
;
}
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
function
updateHostComponent
(
current
workInProgress
renderExpirationTime
)
{
pushHostContext
(
workInProgress
)
;
if
(
current
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
type
=
workInProgress
.
type
;
var
memoizedProps
=
workInProgress
.
memoizedProps
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevProps
=
current
!
=
=
null
?
current
.
memoizedProps
:
null
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
memoizedProps
=
=
=
nextProps
)
{
var
isHidden
=
workInProgress
.
mode
&
AsyncMode
&
&
shouldDeprioritizeSubtree
(
type
nextProps
)
;
if
(
isHidden
)
{
workInProgress
.
expirationTime
=
Never
;
}
if
(
!
isHidden
|
|
renderExpirationTime
!
=
=
Never
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
var
nextChildren
=
nextProps
.
children
;
var
isDirectTextChild
=
shouldSetTextContent
(
type
nextProps
)
;
if
(
isDirectTextChild
)
{
nextChildren
=
null
;
}
else
if
(
prevProps
&
&
shouldSetTextContent
(
type
prevProps
)
)
{
workInProgress
.
effectTag
|
=
ContentReset
;
}
markRef
(
current
workInProgress
)
;
if
(
renderExpirationTime
!
=
=
Never
&
&
workInProgress
.
mode
&
AsyncMode
&
&
shouldDeprioritizeSubtree
(
type
nextProps
)
)
{
workInProgress
.
expirationTime
=
Never
;
workInProgress
.
memoizedProps
=
nextProps
;
return
null
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateHostText
(
current
workInProgress
)
{
if
(
current
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
nextProps
=
workInProgress
.
pendingProps
;
memoizeProps
(
workInProgress
nextProps
)
;
return
null
;
}
function
mountIndeterminateComponent
(
current
workInProgress
renderExpirationTime
)
{
!
(
current
=
=
=
null
)
?
reactProdInvariant
(
'
155
'
)
:
void
0
;
var
fn
=
workInProgress
.
type
;
var
props
=
workInProgress
.
pendingProps
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
value
=
void
0
;
{
value
=
fn
(
props
context
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
&
&
typeof
value
.
render
=
=
=
'
function
'
&
&
value
.
typeof
=
=
=
undefined
)
{
var
Component
=
workInProgress
.
type
;
workInProgress
.
tag
=
ClassComponent
;
workInProgress
.
memoizedState
=
value
.
state
!
=
=
null
&
&
value
.
state
!
=
=
undefined
?
value
.
state
:
null
;
var
getDerivedStateFromProps
=
Component
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
props
)
;
}
var
hasContext
=
pushContextProvider
(
workInProgress
)
;
adoptClassInstance
(
workInProgress
value
)
;
mountClassInstance
(
workInProgress
renderExpirationTime
)
;
return
finishClassComponent
(
current
workInProgress
true
hasContext
renderExpirationTime
)
;
}
else
{
workInProgress
.
tag
=
FunctionalComponent
;
reconcileChildren
(
current
workInProgress
value
)
;
memoizeProps
(
workInProgress
props
)
;
return
workInProgress
.
child
;
}
}
function
updateTimeoutComponent
(
current
workInProgress
renderExpirationTime
)
{
if
(
enableSuspense
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevProps
=
workInProgress
.
memoizedProps
;
var
prevDidTimeout
=
workInProgress
.
memoizedState
;
var
alreadyCaptured
=
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
;
var
nextDidTimeout
=
!
alreadyCaptured
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
nextProps
=
=
=
prevProps
&
&
nextDidTimeout
=
=
=
prevDidTimeout
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
render
=
nextProps
.
children
;
var
nextChildren
=
render
(
nextDidTimeout
)
;
workInProgress
.
memoizedProps
=
nextProps
;
workInProgress
.
memoizedState
=
nextDidTimeout
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
return
workInProgress
.
child
;
}
else
{
return
null
;
}
}
function
updatePortalComponent
(
current
workInProgress
renderExpirationTime
)
{
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
if
(
current
=
=
=
null
)
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
}
else
{
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
}
return
workInProgress
.
child
;
}
function
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
{
var
fiber
=
workInProgress
.
child
;
if
(
fiber
!
=
=
null
)
{
fiber
.
return
=
workInProgress
;
}
while
(
fiber
!
=
=
null
)
{
var
nextFiber
=
void
0
;
switch
(
fiber
.
tag
)
{
case
ContextConsumer
:
var
observedBits
=
fiber
.
stateNode
|
0
;
if
(
fiber
.
type
=
=
=
context
&
&
(
observedBits
&
changedBits
)
!
=
=
0
)
{
var
node
=
fiber
;
while
(
node
!
=
=
null
)
{
var
alternate
=
node
.
alternate
;
if
(
node
.
expirationTime
=
=
=
NoWork
|
|
node
.
expirationTime
>
renderExpirationTime
)
{
node
.
expirationTime
=
renderExpirationTime
;
if
(
alternate
!
=
=
null
&
&
(
alternate
.
expirationTime
=
=
=
NoWork
|
|
alternate
.
expirationTime
>
renderExpirationTime
)
)
{
alternate
.
expirationTime
=
renderExpirationTime
;
}
}
else
if
(
alternate
!
=
=
null
&
&
(
alternate
.
expirationTime
=
=
=
NoWork
|
|
alternate
.
expirationTime
>
renderExpirationTime
)
)
{
alternate
.
expirationTime
=
renderExpirationTime
;
}
else
{
break
;
}
node
=
node
.
return
;
}
nextFiber
=
null
;
}
else
{
nextFiber
=
fiber
.
child
;
}
break
;
case
ContextProvider
:
nextFiber
=
fiber
.
type
=
=
=
workInProgress
.
type
?
null
:
fiber
.
child
;
break
;
default
:
nextFiber
=
fiber
.
child
;
break
;
}
if
(
nextFiber
!
=
=
null
)
{
nextFiber
.
return
=
fiber
;
}
else
{
nextFiber
=
fiber
;
while
(
nextFiber
!
=
=
null
)
{
if
(
nextFiber
=
=
=
workInProgress
)
{
nextFiber
=
null
;
break
;
}
var
sibling
=
nextFiber
.
sibling
;
if
(
sibling
!
=
=
null
)
{
sibling
.
return
=
nextFiber
.
return
;
nextFiber
=
sibling
;
break
;
}
nextFiber
=
nextFiber
.
return
;
}
}
fiber
=
nextFiber
;
}
}
function
updateContextProvider
(
current
workInProgress
renderExpirationTime
)
{
var
providerType
=
workInProgress
.
type
;
var
context
=
providerType
.
_context
;
var
newProps
=
workInProgress
.
pendingProps
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
canBailOnProps
=
true
;
if
(
hasContextChanged
(
)
)
{
canBailOnProps
=
false
;
}
else
if
(
oldProps
=
=
=
newProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
newValue
=
newProps
.
value
;
workInProgress
.
memoizedProps
=
newProps
;
var
changedBits
=
void
0
;
if
(
oldProps
=
=
=
null
)
{
changedBits
=
MAX_SIGNED_31_BIT_INT
;
}
else
{
if
(
oldProps
.
value
=
=
=
newProps
.
value
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
canBailOnProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
changedBits
=
0
;
}
else
{
var
oldValue
=
oldProps
.
value
;
if
(
oldValue
=
=
=
newValue
&
&
(
oldValue
!
=
=
0
|
|
1
/
oldValue
=
=
=
1
/
newValue
)
|
|
oldValue
!
=
=
oldValue
&
&
newValue
!
=
=
newValue
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
canBailOnProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
changedBits
=
0
;
}
else
{
changedBits
=
typeof
context
.
_calculateChangedBits
=
=
=
'
function
'
?
context
.
_calculateChangedBits
(
oldValue
newValue
)
:
MAX_SIGNED_31_BIT_INT
;
changedBits
|
=
0
;
if
(
changedBits
=
=
=
0
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
canBailOnProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
else
{
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
;
}
}
}
}
workInProgress
.
stateNode
=
changedBits
;
pushProvider
(
workInProgress
)
;
var
newChildren
=
newProps
.
children
;
reconcileChildren
(
current
workInProgress
newChildren
)
;
return
workInProgress
.
child
;
}
function
updateContextConsumer
(
current
workInProgress
renderExpirationTime
)
{
var
context
=
workInProgress
.
type
;
var
newProps
=
workInProgress
.
pendingProps
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newValue
=
getContextCurrentValue
(
context
)
;
var
changedBits
=
getContextChangedBits
(
context
)
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
changedBits
=
=
=
0
&
&
oldProps
=
=
=
newProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
workInProgress
.
memoizedProps
=
newProps
;
var
observedBits
=
newProps
.
unstable_observedBits
;
if
(
observedBits
=
=
=
undefined
|
|
observedBits
=
=
=
null
)
{
observedBits
=
MAX_SIGNED_31_BIT_INT
;
}
workInProgress
.
stateNode
=
observedBits
;
if
(
(
changedBits
&
observedBits
)
!
=
=
0
)
{
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
;
}
else
if
(
oldProps
=
=
=
newProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
render
=
newProps
.
children
;
var
newChildren
=
void
0
;
{
newChildren
=
render
(
newValue
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
workInProgress
newChildren
)
;
return
workInProgress
.
child
;
}
function
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
{
cancelWorkTimer
(
workInProgress
)
;
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
cloneChildFibers
(
current
workInProgress
)
;
return
workInProgress
.
child
;
}
function
bailoutOnLowPriority
(
current
workInProgress
)
{
cancelWorkTimer
(
workInProgress
)
;
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
pushHostRootContext
(
workInProgress
)
;
break
;
case
ClassComponent
:
pushContextProvider
(
workInProgress
)
;
break
;
case
HostPortal
:
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
break
;
case
ContextProvider
:
pushProvider
(
workInProgress
)
;
break
;
}
return
null
;
}
function
memoizeProps
(
workInProgress
nextProps
)
{
workInProgress
.
memoizedProps
=
nextProps
;
}
function
memoizeState
(
workInProgress
nextState
)
{
workInProgress
.
memoizedState
=
nextState
;
}
function
beginWork
(
current
workInProgress
renderExpirationTime
)
{
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
markActualRenderTimeStarted
(
workInProgress
)
;
}
}
if
(
workInProgress
.
expirationTime
=
=
=
NoWork
|
|
workInProgress
.
expirationTime
>
renderExpirationTime
)
{
return
bailoutOnLowPriority
(
current
workInProgress
)
;
}
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
return
mountIndeterminateComponent
(
current
workInProgress
renderExpirationTime
)
;
case
FunctionalComponent
:
return
updateFunctionalComponent
(
current
workInProgress
)
;
case
ClassComponent
:
return
updateClassComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostRoot
:
return
updateHostRoot
(
current
workInProgress
renderExpirationTime
)
;
case
HostComponent
:
return
updateHostComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostText
:
return
updateHostText
(
current
workInProgress
)
;
case
TimeoutComponent
:
return
updateTimeoutComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostPortal
:
return
updatePortalComponent
(
current
workInProgress
renderExpirationTime
)
;
case
ForwardRef
:
return
updateForwardRef
(
current
workInProgress
)
;
case
Fragment
:
return
updateFragment
(
current
workInProgress
)
;
case
Mode
:
return
updateMode
(
current
workInProgress
)
;
case
Profiler
:
return
updateProfiler
(
current
workInProgress
)
;
case
ContextProvider
:
return
updateContextProvider
(
current
workInProgress
renderExpirationTime
)
;
case
ContextConsumer
:
return
updateContextConsumer
(
current
workInProgress
renderExpirationTime
)
;
default
:
reactProdInvariant
(
'
156
'
)
;
}
}
function
markUpdate
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Update
;
}
function
markRef
1
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
function
appendAllChildren
(
parent
workInProgress
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendInitialChild
(
parent
node
.
stateNode
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
var
updateHostContainer
=
void
0
;
var
updateHostComponent
1
=
void
0
;
var
updateHostText
1
=
void
0
;
if
(
supportsMutation
)
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
{
workInProgress
.
updateQueue
=
updatePayload
;
if
(
updatePayload
)
{
markUpdate
(
workInProgress
)
;
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
markUpdate
(
workInProgress
)
;
}
}
;
}
else
if
(
supportsPersistence
)
{
var
appendAllChildrenToContainer
=
function
(
containerChildSet
workInProgress
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendChildToContainerChildSet
(
containerChildSet
node
.
stateNode
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
updateHostContainer
=
function
(
workInProgress
)
{
var
portalOrRoot
=
workInProgress
.
stateNode
;
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
if
(
childrenUnchanged
)
{
}
else
{
var
container
=
portalOrRoot
.
containerInfo
;
var
newChildSet
=
createContainerChildSet
(
container
)
;
appendAllChildrenToContainer
(
newChildSet
workInProgress
)
;
portalOrRoot
.
pendingChildren
=
newChildSet
;
markUpdate
(
workInProgress
)
;
finalizeContainerChildren
(
container
newChildSet
)
;
}
}
;
updateHostComponent
1
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
{
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
var
currentInstance
=
current
.
stateNode
;
if
(
childrenUnchanged
&
&
updatePayload
=
=
=
null
)
{
workInProgress
.
stateNode
=
currentInstance
;
}
else
{
var
recyclableInstance
=
workInProgress
.
stateNode
;
var
newInstance
=
cloneInstance
(
currentInstance
updatePayload
type
oldProps
newProps
workInProgress
childrenUnchanged
recyclableInstance
)
;
if
(
finalizeInitialChildren
(
newInstance
type
newProps
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
newInstance
;
if
(
childrenUnchanged
)
{
markUpdate
(
workInProgress
)
;
}
else
{
appendAllChildren
(
newInstance
workInProgress
)
;
}
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
currentHostContext
=
getHostContext
(
)
;
workInProgress
.
stateNode
=
createTextInstance
(
newText
rootContainerInstance
currentHostContext
workInProgress
)
;
markUpdate
(
workInProgress
)
;
}
}
;
}
else
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
{
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
}
;
}
function
completeWork
(
current
workInProgress
renderExpirationTime
)
{
var
newProps
=
workInProgress
.
pendingProps
;
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
recordElapsedActualRenderTime
(
workInProgress
)
;
}
}
switch
(
workInProgress
.
tag
)
{
case
FunctionalComponent
:
return
null
;
case
ClassComponent
:
{
popContextProvider
(
workInProgress
)
;
return
null
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
fiberRoot
=
workInProgress
.
stateNode
;
if
(
fiberRoot
.
pendingContext
)
{
fiberRoot
.
context
=
fiberRoot
.
pendingContext
;
fiberRoot
.
pendingContext
=
null
;
}
if
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
{
popHydrationState
(
workInProgress
)
;
workInProgress
.
effectTag
&
=
~
Placement
;
}
updateHostContainer
(
workInProgress
)
;
return
null
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
type
=
workInProgress
.
type
;
if
(
current
!
=
=
null
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldProps
=
current
.
memoizedProps
;
var
instance
=
workInProgress
.
stateNode
;
var
currentHostContext
=
getHostContext
(
)
;
var
updatePayload
=
prepareUpdate
(
instance
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
updateHostComponent
1
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
if
(
current
.
ref
!
=
=
workInProgress
.
ref
)
{
markRef
1
(
workInProgress
)
;
}
}
else
{
if
(
!
newProps
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
return
null
;
}
var
_currentHostContext
=
getHostContext
(
)
;
var
wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
wasHydrated
)
{
if
(
prepareToHydrateHostInstance
(
workInProgress
rootContainerInstance
_currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
var
_instance
=
createInstance
(
type
newProps
rootContainerInstance
_currentHostContext
workInProgress
)
;
appendAllChildren
(
_instance
workInProgress
)
;
if
(
finalizeInitialChildren
(
_instance
type
newProps
rootContainerInstance
_currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
_instance
;
}
if
(
workInProgress
.
ref
!
=
=
null
)
{
markRef
1
(
workInProgress
)
;
}
}
return
null
;
}
case
HostText
:
{
var
newText
=
newProps
;
if
(
current
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldText
=
current
.
memoizedProps
;
updateHostText
1
(
current
workInProgress
oldText
newText
)
;
}
else
{
if
(
typeof
newText
!
=
=
'
string
'
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
return
null
;
}
var
_rootContainerInstance
=
getRootHostContainer
(
)
;
var
_currentHostContext2
=
getHostContext
(
)
;
var
_wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
_wasHydrated
)
{
if
(
prepareToHydrateHostTextInstance
(
workInProgress
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
workInProgress
.
stateNode
=
createTextInstance
(
newText
_rootContainerInstance
_currentHostContext2
workInProgress
)
;
}
}
return
null
;
}
case
ForwardRef
:
return
null
;
case
TimeoutComponent
:
return
null
;
case
Fragment
:
return
null
;
case
Mode
:
return
null
;
case
Profiler
:
return
null
;
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
updateHostContainer
(
workInProgress
)
;
return
null
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
return
null
;
case
ContextConsumer
:
return
null
;
case
IndeterminateComponent
:
reactProdInvariant
(
'
167
'
)
;
default
:
reactProdInvariant
(
'
156
'
)
;
}
}
function
showErrorDialog
(
capturedError
)
{
return
true
;
}
function
logCapturedError
(
capturedError
)
{
var
logError
=
showErrorDialog
(
capturedError
)
;
if
(
logError
=
=
=
false
)
{
return
;
}
var
error
=
capturedError
.
error
;
var
suppressLogging
=
error
&
&
error
.
suppressReactErrorLogging
;
if
(
suppressLogging
)
{
return
;
}
{
console
.
error
(
error
)
;
}
}
function
logError
(
boundary
errorInfo
)
{
var
source
=
errorInfo
.
source
;
var
stack
=
errorInfo
.
stack
;
if
(
stack
=
=
=
null
&
&
source
!
=
=
null
)
{
stack
=
getStackAddendumByWorkInProgressFiber
(
source
)
;
}
var
capturedError
=
{
componentName
:
source
!
=
=
null
?
getComponentName
(
source
)
:
null
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
error
:
errorInfo
.
value
errorBoundary
:
null
errorBoundaryName
:
null
errorBoundaryFound
:
false
willRetry
:
false
}
;
if
(
boundary
!
=
=
null
&
&
boundary
.
tag
=
=
=
ClassComponent
)
{
capturedError
.
errorBoundary
=
boundary
.
stateNode
;
capturedError
.
errorBoundaryName
=
getComponentName
(
boundary
)
;
capturedError
.
errorBoundaryFound
=
true
;
capturedError
.
willRetry
=
true
;
}
try
{
logCapturedError
(
capturedError
)
;
}
catch
(
e
)
{
var
suppressLogging
=
e
&
&
e
.
suppressReactErrorLogging
;
if
(
!
suppressLogging
)
{
console
.
error
(
e
)
;
}
}
}
var
callComponentWillUnmountWithTimer
=
function
(
current
instance
)
{
startPhaseTimer
(
current
'
componentWillUnmount
'
)
;
instance
.
props
=
current
.
memoizedProps
;
instance
.
state
=
current
.
memoizedState
;
instance
.
componentWillUnmount
(
)
;
stopPhaseTimer
(
)
;
}
;
function
safelyCallComponentWillUnmount
(
current
instance
)
{
{
try
{
callComponentWillUnmountWithTimer
(
current
instance
)
;
}
catch
(
unmountError
)
{
captureCommitPhaseError
(
current
unmountError
)
;
}
}
}
function
safelyDetachRef
(
current
)
{
var
ref
=
current
.
ref
;
if
(
ref
!
=
=
null
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
{
try
{
ref
(
null
)
;
}
catch
(
refError
)
{
captureCommitPhaseError
(
current
refError
)
;
}
}
}
else
{
ref
.
current
=
null
;
}
}
}
function
commitBeforeMutationLifeCycles
(
current
finishedWork
)
{
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
if
(
finishedWork
.
effectTag
&
Snapshot
)
{
if
(
current
!
=
=
null
)
{
var
prevProps
=
current
.
memoizedProps
;
var
prevState
=
current
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
getSnapshotBeforeUpdate
'
)
;
var
instance
=
finishedWork
.
stateNode
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
var
snapshot
=
instance
.
getSnapshotBeforeUpdate
(
prevProps
prevState
)
;
instance
.
__reactInternalSnapshotBeforeUpdate
=
snapshot
;
stopPhaseTimer
(
)
;
}
}
return
;
}
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
return
;
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitLifeCycles
(
finishedRoot
current
finishedWork
currentTime
committedExpirationTime
)
{
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
finishedWork
.
effectTag
&
Update
)
{
if
(
current
=
=
=
null
)
{
startPhaseTimer
(
finishedWork
'
componentDidMount
'
)
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
instance
.
componentDidMount
(
)
;
stopPhaseTimer
(
)
;
}
else
{
var
prevProps
=
current
.
memoizedProps
;
var
prevState
=
current
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
componentDidUpdate
'
)
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
instance
.
componentDidUpdate
(
prevProps
prevState
instance
.
__reactInternalSnapshotBeforeUpdate
)
;
stopPhaseTimer
(
)
;
}
}
var
updateQueue
=
finishedWork
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
commitUpdateQueue
(
finishedWork
updateQueue
instance
committedExpirationTime
)
;
}
return
;
}
case
HostRoot
:
{
var
_updateQueue
=
finishedWork
.
updateQueue
;
if
(
_updateQueue
!
=
=
null
)
{
var
_instance
=
null
;
if
(
finishedWork
.
child
!
=
=
null
)
{
switch
(
finishedWork
.
child
.
tag
)
{
case
HostComponent
:
_instance
=
getPublicInstance
(
finishedWork
.
child
.
stateNode
)
;
break
;
case
ClassComponent
:
_instance
=
finishedWork
.
child
.
stateNode
;
break
;
}
}
commitUpdateQueue
(
finishedWork
_updateQueue
_instance
committedExpirationTime
)
;
}
return
;
}
case
HostComponent
:
{
var
_instance2
=
finishedWork
.
stateNode
;
if
(
current
=
=
=
null
&
&
finishedWork
.
effectTag
&
Update
)
{
var
type
=
finishedWork
.
type
;
var
props
=
finishedWork
.
memoizedProps
;
}
return
;
}
case
HostText
:
{
return
;
}
case
HostPortal
:
{
return
;
}
case
Profiler
:
{
return
;
}
case
TimeoutComponent
:
{
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitAttachRef
(
finishedWork
)
{
var
ref
=
finishedWork
.
ref
;
if
(
ref
!
=
=
null
)
{
var
instance
=
finishedWork
.
stateNode
;
var
instanceToUse
=
void
0
;
switch
(
finishedWork
.
tag
)
{
case
HostComponent
:
instanceToUse
=
getPublicInstance
(
instance
)
;
break
;
default
:
instanceToUse
=
instance
;
}
if
(
typeof
ref
=
=
=
'
function
'
)
{
ref
(
instanceToUse
)
;
}
else
{
ref
.
current
=
instanceToUse
;
}
}
}
function
commitDetachRef
(
current
)
{
var
currentRef
=
current
.
ref
;
if
(
currentRef
!
=
=
null
)
{
if
(
typeof
currentRef
=
=
=
'
function
'
)
{
currentRef
(
null
)
;
}
else
{
currentRef
.
current
=
null
;
}
}
}
function
commitUnmount
(
current
)
{
if
(
typeof
onCommitUnmount
=
=
=
'
function
'
)
{
onCommitUnmount
(
current
)
;
}
switch
(
current
.
tag
)
{
case
ClassComponent
:
{
safelyDetachRef
(
current
)
;
var
instance
=
current
.
stateNode
;
if
(
typeof
instance
.
componentWillUnmount
=
=
=
'
function
'
)
{
safelyCallComponentWillUnmount
(
current
instance
)
;
}
return
;
}
case
HostComponent
:
{
safelyDetachRef
(
current
)
;
return
;
}
case
HostPortal
:
{
if
(
supportsMutation
)
{
unmountHostComponents
(
current
)
;
}
else
if
(
supportsPersistence
)
{
emptyPortalContainer
(
current
)
;
}
return
;
}
}
}
function
commitNestedUnmounts
(
root
)
{
var
node
=
root
;
while
(
true
)
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
&
&
(
!
supportsMutation
|
|
node
.
tag
!
=
=
HostPortal
)
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
root
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
root
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
detachFiber
(
current
)
{
current
.
return
=
null
;
current
.
child
=
null
;
if
(
current
.
alternate
)
{
current
.
alternate
.
child
=
null
;
current
.
alternate
.
return
=
null
;
}
}
function
emptyPortalContainer
(
current
)
{
if
(
!
supportsPersistence
)
{
return
;
}
var
portal
=
current
.
stateNode
;
var
containerInfo
=
portal
.
containerInfo
;
var
emptyChildSet
=
createContainerChildSet
(
containerInfo
)
;
replaceContainerChildren
(
containerInfo
emptyChildSet
)
;
}
function
commitContainer
(
finishedWork
)
{
if
(
!
supportsPersistence
)
{
return
;
}
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
return
;
}
case
HostText
:
{
return
;
}
case
HostRoot
:
case
HostPortal
:
{
var
portalOrRoot
=
finishedWork
.
stateNode
;
var
containerInfo
=
portalOrRoot
.
containerInfo
_pendingChildren
=
portalOrRoot
.
pendingChildren
;
replaceContainerChildren
(
containerInfo
_pendingChildren
)
;
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
getHostParentFiber
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
)
{
if
(
isHostParent
(
parent
)
)
{
return
parent
;
}
parent
=
parent
.
return
;
}
reactProdInvariant
(
'
160
'
)
;
}
function
isHostParent
(
fiber
)
{
return
fiber
.
tag
=
=
=
HostComponent
|
|
fiber
.
tag
=
=
=
HostRoot
|
|
fiber
.
tag
=
=
=
HostPortal
;
}
function
getHostSibling
(
fiber
)
{
var
node
=
fiber
;
siblings
:
while
(
true
)
{
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
isHostParent
(
node
.
return
)
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
while
(
node
.
tag
!
=
=
HostComponent
&
&
node
.
tag
!
=
=
HostText
)
{
if
(
node
.
effectTag
&
Placement
)
{
continue
siblings
;
}
if
(
node
.
child
=
=
=
null
|
|
node
.
tag
=
=
=
HostPortal
)
{
continue
siblings
;
}
else
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
}
}
if
(
!
(
node
.
effectTag
&
Placement
)
)
{
return
node
.
stateNode
;
}
}
}
function
commitPlacement
(
finishedWork
)
{
if
(
!
supportsMutation
)
{
return
;
}
var
parentFiber
=
getHostParentFiber
(
finishedWork
)
;
var
parent
=
void
0
;
var
isContainer
=
void
0
;
switch
(
parentFiber
.
tag
)
{
case
HostComponent
:
parent
=
parentFiber
.
stateNode
;
isContainer
=
false
;
break
;
case
HostRoot
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
case
HostPortal
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
default
:
reactProdInvariant
(
'
161
'
)
;
}
if
(
parentFiber
.
effectTag
&
ContentReset
)
{
parentFiber
.
effectTag
&
=
~
ContentReset
;
}
var
before
=
getHostSibling
(
finishedWork
)
;
var
node
=
finishedWork
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
if
(
before
)
{
if
(
isContainer
)
{
insertInContainerBefore
(
parent
node
.
stateNode
before
)
;
}
else
{
insertBefore
(
parent
node
.
stateNode
before
)
;
}
}
else
{
if
(
isContainer
)
{
appendChildToContainer
(
parent
node
.
stateNode
)
;
}
else
{
appendChild
(
parent
node
.
stateNode
)
;
}
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
finishedWork
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
finishedWork
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
unmountHostComponents
(
current
)
{
var
node
=
current
;
var
currentParentIsValid
=
false
;
var
currentParent
=
void
0
;
var
currentParentIsContainer
=
void
0
;
while
(
true
)
{
if
(
!
currentParentIsValid
)
{
var
parent
=
node
.
return
;
findParent
:
while
(
true
)
{
!
(
parent
!
=
=
null
)
?
reactProdInvariant
(
'
160
'
)
:
void
0
;
switch
(
parent
.
tag
)
{
case
HostComponent
:
currentParent
=
parent
.
stateNode
;
currentParentIsContainer
=
false
;
break
findParent
;
case
HostRoot
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
case
HostPortal
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
}
parent
=
parent
.
return
;
}
currentParentIsValid
=
true
;
}
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
commitNestedUnmounts
(
node
)
;
if
(
currentParentIsContainer
)
{
removeChildFromContainer
(
currentParent
node
.
stateNode
)
;
}
else
{
removeChild
(
currentParent
node
.
stateNode
)
;
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParent
=
node
.
stateNode
.
containerInfo
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
if
(
node
=
=
=
current
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
current
)
{
return
;
}
node
=
node
.
return
;
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParentIsValid
=
false
;
}
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
commitDeletion
(
current
)
{
if
(
supportsMutation
)
{
unmountHostComponents
(
current
)
;
}
else
{
commitNestedUnmounts
(
current
)
;
}
detachFiber
(
current
)
;
}
function
commitWork
(
current
finishedWork
)
{
if
(
!
supportsMutation
)
{
commitContainer
(
finishedWork
)
;
return
;
}
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
instance
!
=
null
)
{
var
newProps
=
finishedWork
.
memoizedProps
;
var
oldProps
=
current
!
=
=
null
?
current
.
memoizedProps
:
newProps
;
var
type
=
finishedWork
.
type
;
var
updatePayload
=
finishedWork
.
updateQueue
;
finishedWork
.
updateQueue
=
null
;
if
(
updatePayload
!
=
=
null
)
{
commitUpdate
(
instance
updatePayload
type
oldProps
newProps
finishedWork
)
;
}
}
return
;
}
case
HostText
:
{
!
(
finishedWork
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
162
'
)
:
void
0
;
var
textInstance
=
finishedWork
.
stateNode
;
var
newText
=
finishedWork
.
memoizedProps
;
var
oldText
=
current
!
=
=
null
?
current
.
memoizedProps
:
newText
;
commitTextUpdate
(
textInstance
oldText
newText
)
;
return
;
}
case
HostRoot
:
{
return
;
}
case
Profiler
:
{
if
(
enableProfilerTimer
)
{
var
onRender
=
finishedWork
.
memoizedProps
.
onRender
;
onRender
(
finishedWork
.
memoizedProps
.
id
current
=
=
=
null
?
'
mount
'
:
'
update
'
finishedWork
.
actualDuration
finishedWork
.
treeBaseTime
finishedWork
.
actualStartTime
getCommitTime
(
)
)
;
}
return
;
}
case
TimeoutComponent
:
{
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitResetTextContent
(
current
)
{
if
(
!
supportsMutation
)
{
return
;
}
resetTextContent
(
current
.
stateNode
)
;
}
function
createRootErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
CaptureUpdate
;
update
.
payload
=
{
element
:
null
}
;
var
error
=
errorInfo
.
value
;
update
.
callback
=
function
(
)
{
onUncaughtError
(
error
)
;
logError
(
fiber
errorInfo
)
;
}
;
return
update
;
}
function
createClassErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
CaptureUpdate
;
var
getDerivedStateFromCatch
=
fiber
.
type
.
getDerivedStateFromCatch
;
if
(
enableGetDerivedStateFromCatch
&
&
typeof
getDerivedStateFromCatch
=
=
=
'
function
'
)
{
var
error
=
errorInfo
.
value
;
update
.
payload
=
function
(
)
{
return
getDerivedStateFromCatch
(
error
)
;
}
;
}
var
inst
=
fiber
.
stateNode
;
if
(
inst
!
=
=
null
&
&
typeof
inst
.
componentDidCatch
=
=
=
'
function
'
)
{
update
.
callback
=
function
callback
(
)
{
if
(
!
enableGetDerivedStateFromCatch
|
|
getDerivedStateFromCatch
!
=
=
'
function
'
)
{
markLegacyErrorBoundaryAsFailed
(
this
)
;
}
var
error
=
errorInfo
.
value
;
var
stack
=
errorInfo
.
stack
;
logError
(
fiber
errorInfo
)
;
this
.
componentDidCatch
(
error
{
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
}
)
;
}
;
}
return
update
;
}
function
schedulePing
(
finishedWork
)
{
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
finishedWork
)
;
var
recoveryUpdate
=
createUpdate
(
expirationTime
)
;
enqueueUpdate
(
finishedWork
recoveryUpdate
expirationTime
)
;
scheduleWork
(
finishedWork
expirationTime
)
;
}
function
throwException
(
root
returnFiber
sourceFiber
value
renderIsExpired
renderExpirationTime
currentTimeMs
)
{
sourceFiber
.
effectTag
|
=
Incomplete
;
sourceFiber
.
firstEffect
=
sourceFiber
.
lastEffect
=
null
;
if
(
enableSuspense
&
&
value
!
=
=
null
&
&
typeof
value
=
=
=
'
object
'
&
&
typeof
value
.
then
=
=
=
'
function
'
)
{
var
thenable
=
value
;
var
expirationTimeMs
=
expirationTimeToMs
(
renderExpirationTime
)
;
var
startTimeMs
=
expirationTimeMs
-
5000
;
var
elapsedMs
=
currentTimeMs
-
startTimeMs
;
if
(
elapsedMs
<
0
)
{
elapsedMs
=
0
;
}
var
remainingTimeMs
=
expirationTimeMs
-
currentTimeMs
;
var
_workInProgress
=
returnFiber
;
var
earliestTimeoutMs
=
-
1
;
searchForEarliestTimeout
:
do
{
if
(
_workInProgress
.
tag
=
=
=
TimeoutComponent
)
{
var
current
=
_workInProgress
.
alternate
;
if
(
current
!
=
=
null
&
&
current
.
memoizedState
=
=
=
true
)
{
earliestTimeoutMs
=
0
;
break
searchForEarliestTimeout
;
}
var
timeoutPropMs
=
_workInProgress
.
pendingProps
.
ms
;
if
(
typeof
timeoutPropMs
=
=
=
'
number
'
)
{
if
(
timeoutPropMs
<
=
0
)
{
earliestTimeoutMs
=
0
;
break
searchForEarliestTimeout
;
}
else
if
(
earliestTimeoutMs
=
=
=
-
1
|
|
timeoutPropMs
<
earliestTimeoutMs
)
{
earliestTimeoutMs
=
timeoutPropMs
;
}
}
else
if
(
earliestTimeoutMs
=
=
=
-
1
)
{
earliestTimeoutMs
=
remainingTimeMs
;
}
}
_workInProgress
=
_workInProgress
.
return
;
}
while
(
_workInProgress
!
=
=
null
)
;
var
msUntilTimeout
=
earliestTimeoutMs
-
elapsedMs
;
if
(
renderExpirationTime
=
=
=
Never
|
|
msUntilTimeout
>
0
)
{
suspendRoot
(
root
thenable
msUntilTimeout
renderExpirationTime
)
;
var
onResolveOrReject
=
function
(
)
{
retrySuspendedRoot
(
root
renderExpirationTime
)
;
}
;
thenable
.
then
(
onResolveOrReject
onResolveOrReject
)
;
return
;
}
else
{
_workInProgress
=
returnFiber
;
do
{
switch
(
_workInProgress
.
tag
)
{
case
HostRoot
:
{
var
message
=
renderExpirationTime
=
=
=
Sync
?
'
A
synchronous
update
was
suspended
but
no
fallback
UI
'
+
'
was
provided
.
'
:
'
An
update
was
suspended
for
longer
than
the
timeout
'
+
'
but
no
fallback
UI
was
provided
.
'
;
value
=
new
Error
(
message
)
;
break
;
}
case
TimeoutComponent
:
{
if
(
(
_workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
)
{
_workInProgress
.
effectTag
|
=
ShouldCapture
;
var
_onResolveOrReject
=
schedulePing
.
bind
(
null
_workInProgress
)
;
thenable
.
then
(
_onResolveOrReject
_onResolveOrReject
)
;
return
;
}
break
;
}
}
_workInProgress
=
_workInProgress
.
return
;
}
while
(
_workInProgress
!
=
=
null
)
;
}
}
value
=
createCapturedValue
(
value
sourceFiber
)
;
var
workInProgress
=
returnFiber
;
do
{
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
{
var
_errorInfo
=
value
;
workInProgress
.
effectTag
|
=
ShouldCapture
;
var
update
=
createRootErrorUpdate
(
workInProgress
_errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
update
renderExpirationTime
)
;
return
;
}
case
ClassComponent
:
var
errorInfo
=
value
;
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
&
&
(
typeof
ctor
.
getDerivedStateFromCatch
=
=
=
'
function
'
&
&
enableGetDerivedStateFromCatch
|
|
instance
!
=
=
null
&
&
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
)
{
workInProgress
.
effectTag
|
=
ShouldCapture
;
var
_update
=
createClassErrorUpdate
(
workInProgress
errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
_update
renderExpirationTime
)
;
return
;
}
break
;
default
:
break
;
}
workInProgress
=
workInProgress
.
return
;
}
while
(
workInProgress
!
=
=
null
)
;
}
function
unwindWork
(
workInProgress
renderIsExpired
renderExpirationTime
)
{
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
recordElapsedActualRenderTime
(
workInProgress
)
;
}
}
switch
(
workInProgress
.
tag
)
{
case
ClassComponent
:
{
popContextProvider
(
workInProgress
)
;
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
_effectTag
=
workInProgress
.
effectTag
;
if
(
_effectTag
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
_effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
return
null
;
}
case
TimeoutComponent
:
{
var
_effectTag2
=
workInProgress
.
effectTag
;
if
(
_effectTag2
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
_effectTag2
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
return
null
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
return
null
;
default
:
return
null
;
}
}
function
unwindInterruptedWork
(
interruptedWork
)
{
if
(
enableProfilerTimer
)
{
if
(
interruptedWork
.
mode
&
ProfileMode
)
{
resumeActualRenderTimerIfPaused
(
)
;
recordElapsedActualRenderTime
(
interruptedWork
)
;
}
}
switch
(
interruptedWork
.
tag
)
{
case
ClassComponent
:
{
popContextProvider
(
interruptedWork
)
;
break
;
}
case
HostRoot
:
{
popHostContainer
(
interruptedWork
)
;
popTopLevelContextObject
(
interruptedWork
)
;
break
;
}
case
HostComponent
:
{
popHostContext
(
interruptedWork
)
;
break
;
}
case
HostPortal
:
popHostContainer
(
interruptedWork
)
;
break
;
case
ContextProvider
:
popProvider
(
interruptedWork
)
;
break
;
default
:
break
;
}
}
var
originalStartTimeMs
=
now
(
)
;
var
mostRecentCurrentTime
=
msToExpirationTime
(
0
)
;
var
mostRecentCurrentTimeMs
=
originalStartTimeMs
;
var
expirationContext
=
NoWork
;
var
isWorking
=
false
;
var
nextUnitOfWork
=
null
;
var
nextRoot
=
null
;
var
nextRenderExpirationTime
=
NoWork
;
var
nextLatestTimeoutMs
=
-
1
;
var
nextRenderIsExpired
=
false
;
var
nextEffect
=
null
;
var
isCommitting
1
=
false
;
var
isRootReadyForCommit
=
false
;
var
legacyErrorBoundariesThatAlreadyFailed
=
null
;
var
interruptedBy
=
null
;
function
resetStack
(
)
{
if
(
nextUnitOfWork
!
=
=
null
)
{
var
interruptedWork
=
nextUnitOfWork
.
return
;
while
(
interruptedWork
!
=
=
null
)
{
unwindInterruptedWork
(
interruptedWork
)
;
interruptedWork
=
interruptedWork
.
return
;
}
}
nextRoot
=
null
;
nextRenderExpirationTime
=
NoWork
;
nextLatestTimeoutMs
=
-
1
;
nextRenderIsExpired
=
false
;
nextUnitOfWork
=
null
;
isRootReadyForCommit
=
false
;
}
function
commitAllHostEffects
(
)
{
while
(
nextEffect
!
=
=
null
)
{
recordEffect
(
)
;
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
ContentReset
)
{
commitResetTextContent
(
nextEffect
)
;
}
if
(
effectTag
&
Ref
)
{
var
current
=
nextEffect
.
alternate
;
if
(
current
!
=
=
null
)
{
commitDetachRef
(
current
)
;
}
}
var
primaryEffectTag
=
effectTag
&
(
Placement
|
Update
|
Deletion
)
;
switch
(
primaryEffectTag
)
{
case
Placement
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
break
;
}
case
PlacementAndUpdate
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
var
_current
=
nextEffect
.
alternate
;
commitWork
(
_current
nextEffect
)
;
break
;
}
case
Update
:
{
var
_current2
=
nextEffect
.
alternate
;
commitWork
(
_current2
nextEffect
)
;
break
;
}
case
Deletion
:
{
commitDeletion
(
nextEffect
)
;
break
;
}
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitBeforeMutationLifecycles
(
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
Snapshot
)
{
recordEffect
(
)
;
var
current
=
nextEffect
.
alternate
;
commitBeforeMutationLifeCycles
(
current
nextEffect
)
;
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitAllLifeCycles
(
finishedRoot
currentTime
committedExpirationTime
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
(
Update
|
Callback
)
)
{
recordEffect
(
)
;
var
current
=
nextEffect
.
alternate
;
commitLifeCycles
(
finishedRoot
current
nextEffect
currentTime
committedExpirationTime
)
;
}
if
(
effectTag
&
Ref
)
{
recordEffect
(
)
;
commitAttachRef
(
nextEffect
)
;
}
var
next
=
nextEffect
.
nextEffect
;
nextEffect
.
nextEffect
=
null
;
nextEffect
=
next
;
}
}
function
isAlreadyFailedLegacyErrorBoundary
(
instance
)
{
return
legacyErrorBoundariesThatAlreadyFailed
!
=
=
null
&
&
legacyErrorBoundariesThatAlreadyFailed
.
has
(
instance
)
;
}
function
markLegacyErrorBoundaryAsFailed
(
instance
)
{
if
(
legacyErrorBoundariesThatAlreadyFailed
=
=
=
null
)
{
legacyErrorBoundariesThatAlreadyFailed
=
new
Set
(
[
instance
]
)
;
}
else
{
legacyErrorBoundariesThatAlreadyFailed
.
add
(
instance
)
;
}
}
function
commitRoot
(
finishedWork
)
{
isWorking
=
true
;
isCommitting
1
=
true
;
startCommitTimer
(
)
;
var
root
=
finishedWork
.
stateNode
;
!
(
root
.
current
!
=
=
finishedWork
)
?
reactProdInvariant
(
'
177
'
)
:
void
0
;
var
committedExpirationTime
=
root
.
pendingCommitExpirationTime
;
!
(
committedExpirationTime
!
=
=
NoWork
)
?
reactProdInvariant
(
'
261
'
)
:
void
0
;
root
.
pendingCommitExpirationTime
=
NoWork
;
var
currentTime
=
recalculateCurrentTime
(
)
;
ReactCurrentOwner
.
current
=
null
;
var
firstEffect
=
void
0
;
if
(
finishedWork
.
effectTag
>
PerformedWork
)
{
if
(
finishedWork
.
lastEffect
!
=
=
null
)
{
finishedWork
.
lastEffect
.
nextEffect
=
finishedWork
;
firstEffect
=
finishedWork
.
firstEffect
;
}
else
{
firstEffect
=
finishedWork
;
}
}
else
{
firstEffect
=
finishedWork
.
firstEffect
;
}
prepareForCommit
(
root
.
containerInfo
)
;
nextEffect
=
firstEffect
;
startCommitSnapshotEffectsTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
didError
=
false
;
var
error
=
void
0
;
{
try
{
commitBeforeMutationLifecycles
(
)
;
}
catch
(
e
)
{
didError
=
true
;
error
=
e
;
}
}
if
(
didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
error
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
stopCommitSnapshotEffectsTimer
(
)
;
if
(
enableProfilerTimer
)
{
recordCommitTime
(
)
;
}
nextEffect
=
firstEffect
;
startCommitHostEffectsTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
_didError
=
false
;
var
_error
=
void
0
;
{
try
{
commitAllHostEffects
(
)
;
}
catch
(
e
)
{
_didError
=
true
;
_error
=
e
;
}
}
if
(
_didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
_error
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
stopCommitHostEffectsTimer
(
)
;
resetAfterCommit
(
root
.
containerInfo
)
;
root
.
current
=
finishedWork
;
nextEffect
=
firstEffect
;
startCommitLifeCyclesTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
_didError2
=
false
;
var
_error2
=
void
0
;
{
try
{
commitAllLifeCycles
(
root
currentTime
committedExpirationTime
)
;
}
catch
(
e
)
{
_didError2
=
true
;
_error2
=
e
;
}
}
if
(
_didError2
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
_error2
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
if
(
enableProfilerTimer
)
{
resetActualRenderTimer
(
)
;
}
isCommitting
1
=
false
;
isWorking
=
false
;
stopCommitLifeCyclesTimer
(
)
;
stopCommitTimer
(
)
;
if
(
typeof
onCommitRoot
=
=
=
'
function
'
)
{
onCommitRoot
(
finishedWork
.
stateNode
)
;
}
markCommittedPriorityLevels
(
root
currentTime
root
.
current
.
expirationTime
)
;
var
remainingTime
=
findNextPendingPriorityLevel
(
root
)
;
if
(
remainingTime
=
=
=
NoWork
)
{
legacyErrorBoundariesThatAlreadyFailed
=
null
;
}
return
remainingTime
;
}
function
resetExpirationTime
(
workInProgress
renderTime
)
{
if
(
renderTime
!
=
=
Never
&
&
workInProgress
.
expirationTime
=
=
=
Never
)
{
return
;
}
var
newExpirationTime
=
NoWork
;
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
case
ClassComponent
:
{
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
newExpirationTime
=
updateQueue
.
expirationTime
;
}
}
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
treeBaseTime
=
workInProgress
.
selfBaseTime
;
var
child
=
workInProgress
.
child
;
while
(
child
!
=
=
null
)
{
treeBaseTime
+
=
child
.
treeBaseTime
;
if
(
child
.
expirationTime
!
=
=
NoWork
&
&
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
child
.
expirationTime
)
)
{
newExpirationTime
=
child
.
expirationTime
;
}
child
=
child
.
sibling
;
}
workInProgress
.
treeBaseTime
=
treeBaseTime
;
}
else
{
var
_child
=
workInProgress
.
child
;
while
(
_child
!
=
=
null
)
{
if
(
_child
.
expirationTime
!
=
=
NoWork
&
&
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
_child
.
expirationTime
)
)
{
newExpirationTime
=
_child
.
expirationTime
;
}
_child
=
_child
.
sibling
;
}
}
workInProgress
.
expirationTime
=
newExpirationTime
;
}
function
completeUnitOfWork
(
workInProgress
)
{
while
(
true
)
{
var
current
=
workInProgress
.
alternate
;
var
returnFiber
=
workInProgress
.
return
;
var
siblingFiber
=
workInProgress
.
sibling
;
if
(
(
workInProgress
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
var
next
=
completeWork
(
current
workInProgress
nextRenderExpirationTime
)
;
stopWorkTimer
(
workInProgress
)
;
resetExpirationTime
(
workInProgress
nextRenderExpirationTime
)
;
if
(
next
!
=
=
null
)
{
stopWorkTimer
(
workInProgress
)
;
return
next
;
}
if
(
returnFiber
!
=
=
null
&
&
(
returnFiber
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
if
(
returnFiber
.
firstEffect
=
=
=
null
)
{
returnFiber
.
firstEffect
=
workInProgress
.
firstEffect
;
}
if
(
workInProgress
.
lastEffect
!
=
=
null
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
.
firstEffect
;
}
returnFiber
.
lastEffect
=
workInProgress
.
lastEffect
;
}
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
>
PerformedWork
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
;
}
else
{
returnFiber
.
firstEffect
=
workInProgress
;
}
returnFiber
.
lastEffect
=
workInProgress
;
}
}
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
else
if
(
returnFiber
!
=
=
null
)
{
workInProgress
=
returnFiber
;
continue
;
}
else
{
isRootReadyForCommit
=
true
;
return
null
;
}
}
else
{
var
_next
=
unwindWork
(
workInProgress
nextRenderIsExpired
nextRenderExpirationTime
)
;
if
(
workInProgress
.
effectTag
&
DidCapture
)
{
stopFailedWorkTimer
(
workInProgress
)
;
}
else
{
stopWorkTimer
(
workInProgress
)
;
}
if
(
_next
!
=
=
null
)
{
stopWorkTimer
(
workInProgress
)
;
_next
.
effectTag
&
=
HostEffectMask
;
return
_next
;
}
if
(
returnFiber
!
=
=
null
)
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
null
;
returnFiber
.
effectTag
|
=
Incomplete
;
}
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
else
if
(
returnFiber
!
=
=
null
)
{
workInProgress
=
returnFiber
;
continue
;
}
else
{
return
null
;
}
}
}
return
null
;
}
function
performUnitOfWork
(
workInProgress
)
{
var
current
=
workInProgress
.
alternate
;
startWorkTimer
(
workInProgress
)
;
var
next
=
void
0
;
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
startBaseRenderTimer
(
)
;
}
next
=
beginWork
(
current
workInProgress
nextRenderExpirationTime
)
;
if
(
workInProgress
.
mode
&
ProfileMode
)
{
recordElapsedBaseRenderTimeIfRunning
(
workInProgress
)
;
stopBaseRenderTimerIfRunning
(
)
;
}
}
else
{
next
=
beginWork
(
current
workInProgress
nextRenderExpirationTime
)
;
}
if
(
next
=
=
=
null
)
{
next
=
completeUnitOfWork
(
workInProgress
)
;
}
ReactCurrentOwner
.
current
=
null
;
return
next
;
}
function
workLoop
(
isAsync
)
{
if
(
!
isAsync
)
{
while
(
nextUnitOfWork
!
=
=
null
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
else
{
while
(
nextUnitOfWork
!
=
=
null
&
&
!
shouldYield
(
)
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
if
(
enableProfilerTimer
)
{
pauseActualRenderTimerIfRunning
(
)
;
}
}
}
function
renderRoot
(
root
expirationTime
isAsync
)
{
!
!
isWorking
?
reactProdInvariant
(
'
243
'
)
:
void
0
;
isWorking
=
true
;
if
(
expirationTime
!
=
=
nextRenderExpirationTime
|
|
root
!
=
=
nextRoot
|
|
nextUnitOfWork
=
=
=
null
)
{
resetStack
(
)
;
nextRoot
=
root
;
nextRenderExpirationTime
=
expirationTime
;
nextLatestTimeoutMs
=
-
1
;
nextUnitOfWork
=
createWorkInProgress
(
nextRoot
.
current
null
nextRenderExpirationTime
)
;
root
.
pendingCommitExpirationTime
=
NoWork
;
}
var
didFatal
=
false
;
nextRenderIsExpired
=
!
isAsync
|
|
nextRenderExpirationTime
<
=
mostRecentCurrentTime
;
startWorkLoopTimer
(
nextUnitOfWork
)
;
do
{
try
{
workLoop
(
isAsync
)
;
}
catch
(
thrownValue
)
{
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
if
(
nextUnitOfWork
=
=
=
null
)
{
didFatal
=
true
;
onUncaughtError
(
thrownValue
)
;
}
else
{
!
(
nextUnitOfWork
!
=
=
null
)
?
reactProdInvariant
(
'
271
'
)
:
void
0
;
var
sourceFiber
=
nextUnitOfWork
;
var
returnFiber
=
sourceFiber
.
return
;
if
(
returnFiber
=
=
=
null
)
{
didFatal
=
true
;
onUncaughtError
(
thrownValue
)
;
break
;
}
throwException
(
root
returnFiber
sourceFiber
thrownValue
nextRenderIsExpired
nextRenderExpirationTime
mostRecentCurrentTimeMs
)
;
nextUnitOfWork
=
completeUnitOfWork
(
sourceFiber
)
;
}
}
break
;
}
while
(
true
)
;
var
didCompleteRoot
=
false
;
isWorking
=
false
;
if
(
didFatal
)
{
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
return
null
;
}
else
if
(
nextUnitOfWork
=
=
=
null
)
{
if
(
isRootReadyForCommit
)
{
didCompleteRoot
=
true
;
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
root
.
pendingCommitExpirationTime
=
expirationTime
;
var
finishedWork
=
root
.
current
.
alternate
;
return
finishedWork
;
}
else
{
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
!
!
nextRenderIsExpired
?
reactProdInvariant
(
'
262
'
)
:
void
0
;
markSuspendedPriorityLevel
(
root
expirationTime
)
;
if
(
nextLatestTimeoutMs
>
=
0
)
{
setTimeout
(
function
(
)
{
retrySuspendedRoot
(
root
expirationTime
)
;
}
nextLatestTimeoutMs
)
;
}
var
firstUnblockedExpirationTime
=
findNextPendingPriorityLevel
(
root
)
;
onBlock
(
firstUnblockedExpirationTime
)
;
return
null
;
}
}
else
{
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
return
null
;
}
}
function
dispatch
(
sourceFiber
value
expirationTime
)
{
!
(
!
isWorking
|
|
isCommitting
1
)
?
reactProdInvariant
(
'
263
'
)
:
void
0
;
var
fiber
=
sourceFiber
.
return
;
while
(
fiber
!
=
=
null
)
{
switch
(
fiber
.
tag
)
{
case
ClassComponent
:
var
ctor
=
fiber
.
type
;
var
instance
=
fiber
.
stateNode
;
if
(
typeof
ctor
.
getDerivedStateFromCatch
=
=
=
'
function
'
|
|
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
{
var
errorInfo
=
createCapturedValue
(
value
sourceFiber
)
;
var
update
=
createClassErrorUpdate
(
fiber
errorInfo
expirationTime
)
;
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
(
fiber
expirationTime
)
;
return
;
}
break
;
case
HostRoot
:
{
var
_errorInfo
=
createCapturedValue
(
value
sourceFiber
)
;
var
_update
=
createRootErrorUpdate
(
fiber
_errorInfo
expirationTime
)
;
enqueueUpdate
(
fiber
_update
expirationTime
)
;
scheduleWork
(
fiber
expirationTime
)
;
return
;
}
}
fiber
=
fiber
.
return
;
}
if
(
sourceFiber
.
tag
=
=
=
HostRoot
)
{
var
rootFiber
=
sourceFiber
;
var
_errorInfo2
=
createCapturedValue
(
value
rootFiber
)
;
var
_update2
=
createRootErrorUpdate
(
rootFiber
_errorInfo2
expirationTime
)
;
enqueueUpdate
(
rootFiber
_update2
expirationTime
)
;
scheduleWork
(
rootFiber
expirationTime
)
;
}
}
function
captureCommitPhaseError
(
fiber
error
)
{
return
dispatch
(
fiber
error
Sync
)
;
}
function
computeAsyncExpiration
(
currentTime
)
{
var
expirationMs
=
5000
;
var
bucketSizeMs
=
250
;
return
computeExpirationBucket
(
currentTime
expirationMs
bucketSizeMs
)
;
}
function
computeInteractiveExpiration
(
currentTime
)
{
var
expirationMs
=
void
0
;
{
expirationMs
=
150
;
}
var
bucketSizeMs
=
100
;
return
computeExpirationBucket
(
currentTime
expirationMs
bucketSizeMs
)
;
}
function
computeExpirationForFiber
(
currentTime
fiber
)
{
var
expirationTime
=
void
0
;
if
(
expirationContext
!
=
=
NoWork
)
{
expirationTime
=
expirationContext
;
}
else
if
(
isWorking
)
{
if
(
isCommitting
1
)
{
expirationTime
=
Sync
;
}
else
{
expirationTime
=
nextRenderExpirationTime
;
}
}
else
{
if
(
fiber
.
mode
&
AsyncMode
)
{
if
(
isBatchingInteractiveUpdates
)
{
expirationTime
=
computeInteractiveExpiration
(
currentTime
)
;
}
else
{
expirationTime
=
computeAsyncExpiration
(
currentTime
)
;
}
}
else
{
expirationTime
=
Sync
;
}
}
return
expirationTime
;
}
function
suspendRoot
(
root
thenable
timeoutMs
suspendedTime
)
{
if
(
timeoutMs
>
=
0
&
&
nextLatestTimeoutMs
<
timeoutMs
)
{
nextLatestTimeoutMs
=
timeoutMs
;
}
}
function
retrySuspendedRoot
(
root
suspendedTime
)
{
markPingedPriorityLevel
(
root
suspendedTime
)
;
var
retryTime
=
findNextPendingPriorityLevel
(
root
)
;
if
(
retryTime
!
=
=
NoWork
)
{
requestRetry
(
root
retryTime
)
;
}
}
function
scheduleWork
(
fiber
expirationTime
)
{
recordScheduleUpdate
(
)
;
var
node
=
fiber
;
while
(
node
!
=
=
null
)
{
if
(
node
.
expirationTime
=
=
=
NoWork
|
|
node
.
expirationTime
>
expirationTime
)
{
node
.
expirationTime
=
expirationTime
;
}
if
(
node
.
alternate
!
=
=
null
)
{
if
(
node
.
alternate
.
expirationTime
=
=
=
NoWork
|
|
node
.
alternate
.
expirationTime
>
expirationTime
)
{
node
.
alternate
.
expirationTime
=
expirationTime
;
}
}
if
(
node
.
return
=
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostRoot
)
{
var
root
=
node
.
stateNode
;
if
(
!
isWorking
&
&
nextRenderExpirationTime
!
=
=
NoWork
&
&
expirationTime
<
nextRenderExpirationTime
)
{
interruptedBy
=
fiber
;
resetStack
(
)
;
}
markPendingPriorityLevel
(
root
expirationTime
)
;
var
nextExpirationTimeToWorkOn
=
findNextPendingPriorityLevel
(
root
)
;
if
(
!
isWorking
|
|
isCommitting
1
|
|
nextRoot
!
=
=
root
)
{
requestWork
(
root
nextExpirationTimeToWorkOn
)
;
}
if
(
nestedUpdateCount
>
NESTED_UPDATE_LIMIT
)
{
reactProdInvariant
(
'
185
'
)
;
}
}
else
{
return
;
}
}
node
=
node
.
return
;
}
}
function
recalculateCurrentTime
(
)
{
mostRecentCurrentTimeMs
=
now
(
)
-
originalStartTimeMs
;
mostRecentCurrentTime
=
msToExpirationTime
(
mostRecentCurrentTimeMs
)
;
return
mostRecentCurrentTime
;
}
function
syncUpdates
(
fn
a
b
c
d
)
{
var
previousExpirationContext
=
expirationContext
;
expirationContext
=
Sync
;
try
{
return
fn
(
a
b
c
d
)
;
}
finally
{
expirationContext
=
previousExpirationContext
;
}
}
var
firstScheduledRoot
=
null
;
var
lastScheduledRoot
=
null
;
var
callbackExpirationTime
=
NoWork
;
var
callbackID
=
void
0
;
var
isRendering
=
false
;
var
nextFlushedRoot
=
null
;
var
nextFlushedExpirationTime
=
NoWork
;
var
deadlineDidExpire
=
false
;
var
hasUnhandledError
=
false
;
var
unhandledError
=
null
;
var
deadline
=
null
;
var
isBatchingUpdates
=
false
;
var
isUnbatchingUpdates
=
false
;
var
isBatchingInteractiveUpdates
=
false
;
var
completedBatches
=
null
;
var
NESTED_UPDATE_LIMIT
=
1000
;
var
nestedUpdateCount
=
0
;
var
timeHeuristicForUnitOfWork
=
1
;
function
scheduleCallbackWithExpiration
(
expirationTime
)
{
if
(
callbackExpirationTime
!
=
=
NoWork
)
{
if
(
expirationTime
>
callbackExpirationTime
)
{
return
;
}
else
{
if
(
callbackID
!
=
=
null
)
{
cancelDeferredCallback
(
callbackID
)
;
}
}
}
else
{
startRequestCallbackTimer
(
)
;
}
var
currentMs
=
now
(
)
-
originalStartTimeMs
;
var
expirationMs
=
expirationTimeToMs
(
expirationTime
)
;
var
timeout
=
expirationMs
-
currentMs
;
callbackExpirationTime
=
expirationTime
;
callbackID
=
scheduleDeferredCallback
(
performAsyncWork
{
timeout
:
timeout
}
)
;
}
function
requestRetry
(
root
expirationTime
)
{
if
(
root
.
remainingExpirationTime
=
=
=
NoWork
|
|
root
.
remainingExpirationTime
<
expirationTime
)
{
requestWork
(
root
expirationTime
)
;
}
}
function
requestWork
(
root
expirationTime
)
{
addRootToSchedule
(
root
expirationTime
)
;
if
(
isRendering
)
{
return
;
}
if
(
isBatchingUpdates
)
{
if
(
isUnbatchingUpdates
)
{
nextFlushedRoot
=
root
;
nextFlushedExpirationTime
=
Sync
;
performWorkOnRoot
(
root
Sync
false
)
;
}
return
;
}
if
(
expirationTime
=
=
=
Sync
)
{
performSyncWork
(
)
;
}
else
{
scheduleCallbackWithExpiration
(
expirationTime
)
;
}
}
function
addRootToSchedule
(
root
expirationTime
)
{
if
(
root
.
nextScheduledRoot
=
=
=
null
)
{
root
.
remainingExpirationTime
=
expirationTime
;
if
(
lastScheduledRoot
=
=
=
null
)
{
firstScheduledRoot
=
lastScheduledRoot
=
root
;
root
.
nextScheduledRoot
=
root
;
}
else
{
lastScheduledRoot
.
nextScheduledRoot
=
root
;
lastScheduledRoot
=
root
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
}
}
else
{
var
remainingExpirationTime
=
root
.
remainingExpirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
|
|
expirationTime
<
remainingExpirationTime
)
{
root
.
remainingExpirationTime
=
expirationTime
;
}
}
}
function
findHighestPriorityRoot
(
)
{
var
highestPriorityWork
=
NoWork
;
var
highestPriorityRoot
=
null
;
if
(
lastScheduledRoot
!
=
=
null
)
{
var
previousScheduledRoot
=
lastScheduledRoot
;
var
root
=
firstScheduledRoot
;
while
(
root
!
=
=
null
)
{
var
remainingExpirationTime
=
root
.
remainingExpirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
)
{
!
(
previousScheduledRoot
!
=
=
null
&
&
lastScheduledRoot
!
=
=
null
)
?
reactProdInvariant
(
'
244
'
)
:
void
0
;
if
(
root
=
=
=
root
.
nextScheduledRoot
)
{
root
.
nextScheduledRoot
=
null
;
firstScheduledRoot
=
lastScheduledRoot
=
null
;
break
;
}
else
if
(
root
=
=
=
firstScheduledRoot
)
{
var
next
=
root
.
nextScheduledRoot
;
firstScheduledRoot
=
next
;
lastScheduledRoot
.
nextScheduledRoot
=
next
;
root
.
nextScheduledRoot
=
null
;
}
else
if
(
root
=
=
=
lastScheduledRoot
)
{
lastScheduledRoot
=
previousScheduledRoot
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
break
;
}
else
{
previousScheduledRoot
.
nextScheduledRoot
=
root
.
nextScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
}
root
=
previousScheduledRoot
.
nextScheduledRoot
;
}
else
{
if
(
highestPriorityWork
=
=
=
NoWork
|
|
remainingExpirationTime
<
highestPriorityWork
)
{
highestPriorityWork
=
remainingExpirationTime
;
highestPriorityRoot
=
root
;
}
if
(
root
=
=
=
lastScheduledRoot
)
{
break
;
}
previousScheduledRoot
=
root
;
root
=
root
.
nextScheduledRoot
;
}
}
}
var
previousFlushedRoot
=
nextFlushedRoot
;
if
(
previousFlushedRoot
!
=
=
null
&
&
previousFlushedRoot
=
=
=
highestPriorityRoot
&
&
highestPriorityWork
=
=
=
Sync
)
{
nestedUpdateCount
+
+
;
}
else
{
nestedUpdateCount
=
0
;
}
nextFlushedRoot
=
highestPriorityRoot
;
nextFlushedExpirationTime
=
highestPriorityWork
;
}
function
performAsyncWork
(
dl
)
{
performWork
(
NoWork
true
dl
)
;
}
function
performSyncWork
(
)
{
performWork
(
Sync
false
null
)
;
}
function
performWork
(
minExpirationTime
isAsync
dl
)
{
deadline
=
dl
;
findHighestPriorityRoot
(
)
;
if
(
enableProfilerTimer
)
{
resumeActualRenderTimerIfPaused
(
)
;
}
if
(
enableUserTimingAPI
&
&
deadline
!
=
=
null
)
{
var
didExpire
=
nextFlushedExpirationTime
<
recalculateCurrentTime
(
)
;
var
timeout
=
expirationTimeToMs
(
nextFlushedExpirationTime
)
;
stopRequestCallbackTimer
(
didExpire
timeout
)
;
}
if
(
isAsync
)
{
while
(
nextFlushedRoot
!
=
=
null
&
&
nextFlushedExpirationTime
!
=
=
NoWork
&
&
(
minExpirationTime
=
=
=
NoWork
|
|
minExpirationTime
>
=
nextFlushedExpirationTime
)
&
&
(
!
deadlineDidExpire
|
|
recalculateCurrentTime
(
)
>
=
nextFlushedExpirationTime
)
)
{
recalculateCurrentTime
(
)
;
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
!
deadlineDidExpire
)
;
findHighestPriorityRoot
(
)
;
}
}
else
{
while
(
nextFlushedRoot
!
=
=
null
&
&
nextFlushedExpirationTime
!
=
=
NoWork
&
&
(
minExpirationTime
=
=
=
NoWork
|
|
minExpirationTime
>
=
nextFlushedExpirationTime
)
)
{
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
false
)
;
findHighestPriorityRoot
(
)
;
}
}
if
(
deadline
!
=
=
null
)
{
callbackExpirationTime
=
NoWork
;
callbackID
=
null
;
}
if
(
nextFlushedExpirationTime
!
=
=
NoWork
)
{
scheduleCallbackWithExpiration
(
nextFlushedExpirationTime
)
;
}
deadline
=
null
;
deadlineDidExpire
=
false
;
finishRendering
(
)
;
}
function
finishRendering
(
)
{
nestedUpdateCount
=
0
;
if
(
completedBatches
!
=
=
null
)
{
var
batches
=
completedBatches
;
completedBatches
=
null
;
for
(
var
i
=
0
;
i
<
batches
.
length
;
i
+
+
)
{
var
batch
=
batches
[
i
]
;
try
{
batch
.
_onComplete
(
)
;
}
catch
(
error
)
{
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
}
}
if
(
hasUnhandledError
)
{
var
error
=
unhandledError
;
unhandledError
=
null
;
hasUnhandledError
=
false
;
throw
error
;
}
}
function
performWorkOnRoot
(
root
expirationTime
isAsync
)
{
!
!
isRendering
?
reactProdInvariant
(
'
245
'
)
:
void
0
;
isRendering
=
true
;
if
(
!
isAsync
)
{
var
finishedWork
=
root
.
finishedWork
;
if
(
finishedWork
!
=
=
null
)
{
completeRoot
(
root
finishedWork
expirationTime
)
;
}
else
{
finishedWork
=
renderRoot
(
root
expirationTime
false
)
;
if
(
finishedWork
!
=
=
null
)
{
completeRoot
(
root
finishedWork
expirationTime
)
;
}
}
}
else
{
var
_finishedWork
=
root
.
finishedWork
;
if
(
_finishedWork
!
=
=
null
)
{
completeRoot
(
root
_finishedWork
expirationTime
)
;
}
else
{
_finishedWork
=
renderRoot
(
root
expirationTime
true
)
;
if
(
_finishedWork
!
=
=
null
)
{
if
(
!
shouldYield
(
)
)
{
completeRoot
(
root
_finishedWork
expirationTime
)
;
}
else
{
root
.
finishedWork
=
_finishedWork
;
if
(
enableProfilerTimer
)
{
pauseActualRenderTimerIfRunning
(
)
;
}
}
}
}
}
isRendering
=
false
;
}
function
completeRoot
(
root
finishedWork
expirationTime
)
{
var
firstBatch
=
root
.
firstBatch
;
if
(
firstBatch
!
=
=
null
&
&
firstBatch
.
_expirationTime
<
=
expirationTime
)
{
if
(
completedBatches
=
=
=
null
)
{
completedBatches
=
[
firstBatch
]
;
}
else
{
completedBatches
.
push
(
firstBatch
)
;
}
if
(
firstBatch
.
_defer
)
{
root
.
finishedWork
=
finishedWork
;
root
.
remainingExpirationTime
=
NoWork
;
return
;
}
}
root
.
finishedWork
=
null
;
root
.
remainingExpirationTime
=
commitRoot
(
finishedWork
)
;
}
function
shouldYield
(
)
{
if
(
deadline
=
=
=
null
)
{
return
false
;
}
if
(
deadline
.
timeRemaining
(
)
>
timeHeuristicForUnitOfWork
)
{
return
false
;
}
deadlineDidExpire
=
true
;
return
true
;
}
function
onUncaughtError
(
error
)
{
!
(
nextFlushedRoot
!
=
=
null
)
?
reactProdInvariant
(
'
246
'
)
:
void
0
;
nextFlushedRoot
.
remainingExpirationTime
=
NoWork
;
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
function
onBlock
(
remainingExpirationTime
)
{
!
(
nextFlushedRoot
!
=
=
null
)
?
reactProdInvariant
(
'
246
'
)
:
void
0
;
nextFlushedRoot
.
remainingExpirationTime
=
remainingExpirationTime
;
}
function
flushSync
(
fn
a
)
{
!
!
isRendering
?
reactProdInvariant
(
'
187
'
)
:
void
0
;
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
syncUpdates
(
fn
a
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
performSyncWork
(
)
;
}
}
function
getContextForSubtree
(
parentComponent
)
{
if
(
!
parentComponent
)
{
return
emptyObject_1
;
}
var
fiber
=
get
(
parentComponent
)
;
var
parentContext
=
findCurrentUnmaskedContext
(
fiber
)
;
return
isContextProvider
(
fiber
)
?
processChildContext
(
fiber
parentContext
)
:
parentContext
;
}
function
scheduleRootUpdate
(
current
element
expirationTime
callback
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
payload
=
{
element
:
element
}
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
current
update
expirationTime
)
;
scheduleWork
(
current
expirationTime
)
;
return
expirationTime
;
}
function
updateContainerAtExpirationTime
(
element
container
parentComponent
expirationTime
callback
)
{
var
current
=
container
.
current
;
var
context
=
getContextForSubtree
(
parentComponent
)
;
if
(
container
.
context
=
=
=
null
)
{
container
.
context
=
context
;
}
else
{
container
.
pendingContext
=
context
;
}
return
scheduleRootUpdate
(
current
element
expirationTime
callback
)
;
}
function
createContainer
(
containerInfo
isAsync
hydrate
)
{
return
createFiberRoot
(
containerInfo
isAsync
hydrate
)
;
}
function
updateContainer
(
element
container
parentComponent
callback
)
{
var
current
=
container
.
current
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
current
)
;
return
updateContainerAtExpirationTime
(
element
container
parentComponent
expirationTime
callback
)
;
}
function
getPublicRootInstance
(
container
)
{
var
containerFiber
=
container
.
current
;
if
(
!
containerFiber
.
child
)
{
return
null
;
}
switch
(
containerFiber
.
child
.
tag
)
{
case
HostComponent
:
return
getPublicInstance
(
containerFiber
.
child
.
stateNode
)
;
default
:
return
containerFiber
.
child
.
stateNode
;
}
}
var
getFiberCurrentPropsFromNode
=
null
;
var
getInstanceFromNode
=
null
;
var
fiberHostComponent
=
null
;
var
restoreTarget
=
null
;
var
restoreQueue
=
null
;
function
restoreStateOfTarget
(
target
)
{
var
internalInstance
=
getInstanceFromNode
(
target
)
;
if
(
!
internalInstance
)
{
return
;
}
!
(
fiberHostComponent
&
&
typeof
fiberHostComponent
.
restoreControlledState
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
194
'
)
:
void
0
;
var
props
=
getFiberCurrentPropsFromNode
(
internalInstance
.
stateNode
)
;
fiberHostComponent
.
restoreControlledState
(
internalInstance
.
stateNode
internalInstance
.
type
props
)
;
}
function
needsStateRestore
(
)
{
return
restoreTarget
!
=
=
null
|
|
restoreQueue
!
=
=
null
;
}
function
restoreStateIfNeeded
(
)
{
if
(
!
restoreTarget
)
{
return
;
}
var
target
=
restoreTarget
;
var
queuedTargets
=
restoreQueue
;
restoreTarget
=
null
;
restoreQueue
=
null
;
restoreStateOfTarget
(
target
)
;
if
(
queuedTargets
)
{
for
(
var
i
=
0
;
i
<
queuedTargets
.
length
;
i
+
+
)
{
restoreStateOfTarget
(
queuedTargets
[
i
]
)
;
}
}
}
var
_batchedUpdates
=
function
(
fn
bookkeeping
)
{
return
fn
(
bookkeeping
)
;
}
;
var
_flushInteractiveUpdates
=
function
(
)
{
}
;
var
isBatching
=
false
;
function
batchedUpdates
1
(
fn
bookkeeping
)
{
if
(
isBatching
)
{
return
fn
(
bookkeeping
)
;
}
isBatching
=
true
;
try
{
return
_batchedUpdates
(
fn
bookkeeping
)
;
}
finally
{
isBatching
=
false
;
var
controlledComponentsHavePendingUpdates
=
needsStateRestore
(
)
;
if
(
controlledComponentsHavePendingUpdates
)
{
_flushInteractiveUpdates
(
)
;
restoreStateIfNeeded
(
)
;
}
}
}
var
_createClass
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_objectWithoutProperties
(
obj
keys
)
{
var
target
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
keys
.
indexOf
(
i
)
>
=
0
)
continue
;
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
continue
;
target
[
i
]
=
obj
[
i
]
;
}
return
target
;
}
var
defaultTestOptions
=
{
createNodeMock
:
function
(
)
{
return
null
;
}
}
;
function
toJSON
(
inst
)
{
switch
(
inst
.
tag
)
{
case
'
TEXT
'
:
return
inst
.
text
;
case
'
INSTANCE
'
:
var
_inst
props
=
inst
.
props
_children
=
_inst
props
.
children
_props
=
_objectWithoutProperties
(
_inst
props
[
'
children
'
]
)
;
var
renderedChildren
=
null
;
if
(
inst
.
children
&
&
inst
.
children
.
length
)
{
renderedChildren
=
inst
.
children
.
map
(
toJSON
)
;
}
var
json
=
{
type
:
inst
.
type
props
:
_props
children
:
renderedChildren
}
;
Object
.
defineProperty
(
json
'
typeof
'
{
value
:
Symbol
.
for
(
'
react
.
test
.
json
'
)
}
)
;
return
json
;
default
:
throw
new
Error
(
'
Unexpected
node
type
in
toJSON
:
'
+
inst
.
tag
)
;
}
}
function
childrenToTree
(
node
)
{
if
(
!
node
)
{
return
null
;
}
var
children
=
nodeAndSiblingsArray
(
node
)
;
if
(
children
.
length
=
=
=
0
)
{
return
null
;
}
else
if
(
children
.
length
=
=
=
1
)
{
return
toTree
(
children
[
0
]
)
;
}
return
flatten
(
children
.
map
(
toTree
)
)
;
}
function
nodeAndSiblingsArray
(
nodeWithSibling
)
{
var
array
=
[
]
;
var
node
=
nodeWithSibling
;
while
(
node
!
=
null
)
{
array
.
push
(
node
)
;
node
=
node
.
sibling
;
}
return
array
;
}
function
flatten
(
arr
)
{
var
result
=
[
]
;
var
stack
=
[
{
i
:
0
array
:
arr
}
]
;
while
(
stack
.
length
)
{
var
n
=
stack
.
pop
(
)
;
while
(
n
.
i
<
n
.
array
.
length
)
{
var
el
=
n
.
array
[
n
.
i
]
;
n
.
i
+
=
1
;
if
(
Array
.
isArray
(
el
)
)
{
stack
.
push
(
n
)
;
stack
.
push
(
{
i
:
0
array
:
el
}
)
;
break
;
}
result
.
push
(
el
)
;
}
}
return
result
;
}
function
toTree
(
node
)
{
if
(
node
=
=
null
)
{
return
null
;
}
switch
(
node
.
tag
)
{
case
HostRoot
:
return
childrenToTree
(
node
.
child
)
;
case
HostPortal
:
return
childrenToTree
(
node
.
child
)
;
case
ClassComponent
:
return
{
nodeType
:
'
component
'
type
:
node
.
type
props
:
_assign
(
{
}
node
.
memoizedProps
)
instance
:
node
.
stateNode
rendered
:
childrenToTree
(
node
.
child
)
}
;
case
FunctionalComponent
:
return
{
nodeType
:
'
component
'
type
:
node
.
type
props
:
_assign
(
{
}
node
.
memoizedProps
)
instance
:
null
rendered
:
childrenToTree
(
node
.
child
)
}
;
case
HostComponent
:
{
return
{
nodeType
:
'
host
'
type
:
node
.
type
props
:
_assign
(
{
}
node
.
memoizedProps
)
instance
:
null
rendered
:
flatten
(
nodeAndSiblingsArray
(
node
.
child
)
.
map
(
toTree
)
)
}
;
}
case
HostText
:
return
node
.
stateNode
.
text
;
case
Fragment
:
case
ContextProvider
:
case
ContextConsumer
:
case
Mode
:
case
Profiler
:
case
ForwardRef
:
return
childrenToTree
(
node
.
child
)
;
default
:
reactProdInvariant
(
'
214
'
node
.
tag
)
;
}
}
var
fiberToWrapper
=
new
WeakMap
(
)
;
function
wrapFiber
(
fiber
)
{
var
wrapper
=
fiberToWrapper
.
get
(
fiber
)
;
if
(
wrapper
=
=
=
undefined
&
&
fiber
.
alternate
!
=
=
null
)
{
wrapper
=
fiberToWrapper
.
get
(
fiber
.
alternate
)
;
}
if
(
wrapper
=
=
=
undefined
)
{
wrapper
=
new
ReactTestInstance
(
fiber
)
;
fiberToWrapper
.
set
(
fiber
wrapper
)
;
}
return
wrapper
;
}
var
validWrapperTypes
=
new
Set
(
[
FunctionalComponent
ClassComponent
HostComponent
ForwardRef
HostRoot
]
)
;
function
getChildren
(
parent
)
{
var
children
=
[
]
;
var
startingNode
=
parent
;
var
node
=
startingNode
;
if
(
node
.
child
=
=
=
null
)
{
return
children
;
}
node
.
child
.
return
=
node
;
node
=
node
.
child
;
outer
:
while
(
true
)
{
var
descend
=
false
;
if
(
validWrapperTypes
.
has
(
node
.
tag
)
)
{
children
.
push
(
wrapFiber
(
node
)
)
;
}
else
if
(
node
.
tag
=
=
=
HostText
)
{
children
.
push
(
'
'
+
node
.
memoizedProps
)
;
}
else
{
descend
=
true
;
}
if
(
descend
&
&
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
startingNode
)
{
break
outer
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
return
children
;
}
var
ReactTestInstance
=
function
(
)
{
ReactTestInstance
.
prototype
.
_currentFiber
=
function
_currentFiber
(
)
{
var
fiber
=
findCurrentFiberUsingSlowPath
(
this
.
_fiber
)
;
!
(
fiber
!
=
=
null
)
?
reactProdInvariant
(
'
224
'
)
:
void
0
;
return
fiber
;
}
;
function
ReactTestInstance
(
fiber
)
{
_classCallCheck
(
this
ReactTestInstance
)
;
!
validWrapperTypes
.
has
(
fiber
.
tag
)
?
reactProdInvariant
(
'
225
'
fiber
.
tag
)
:
void
0
;
this
.
_fiber
=
fiber
;
}
ReactTestInstance
.
prototype
.
find
=
function
find
(
predicate
)
{
return
expectOne
(
this
.
findAll
(
predicate
{
deep
:
false
}
)
'
matching
custom
predicate
:
'
+
predicate
.
toString
(
)
)
;
}
;
ReactTestInstance
.
prototype
.
findByType
=
function
findByType
(
type
)
{
return
expectOne
(
this
.
findAllByType
(
type
{
deep
:
false
}
)
'
with
node
type
:
"
'
+
(
type
.
displayName
|
|
type
.
name
)
+
'
"
'
)
;
}
;
ReactTestInstance
.
prototype
.
findByProps
=
function
findByProps
(
props
)
{
return
expectOne
(
this
.
findAllByProps
(
props
{
deep
:
false
}
)
'
with
props
:
'
+
JSON
.
stringify
(
props
)
)
;
}
;
ReactTestInstance
.
prototype
.
findAll
=
function
findAll
(
predicate
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
return
_findAll
(
this
predicate
options
)
;
}
;
ReactTestInstance
.
prototype
.
findAllByType
=
function
findAllByType
(
type
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
return
_findAll
(
this
function
(
node
)
{
return
node
.
type
=
=
=
type
;
}
options
)
;
}
;
ReactTestInstance
.
prototype
.
findAllByProps
=
function
findAllByProps
(
props
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
null
;
return
_findAll
(
this
function
(
node
)
{
return
node
.
props
&
&
propsMatch
(
node
.
props
props
)
;
}
options
)
;
}
;
_createClass
(
ReactTestInstance
[
{
key
:
'
instance
'
get
:
function
(
)
{
if
(
this
.
_fiber
.
tag
=
=
=
HostComponent
)
{
return
getPublicInstance
(
this
.
_fiber
.
stateNode
)
;
}
else
{
return
this
.
_fiber
.
stateNode
;
}
}
}
{
key
:
'
type
'
get
:
function
(
)
{
return
this
.
_fiber
.
type
;
}
}
{
key
:
'
props
'
get
:
function
(
)
{
return
this
.
_currentFiber
(
)
.
memoizedProps
;
}
}
{
key
:
'
parent
'
get
:
function
(
)
{
var
parent
=
this
.
_fiber
.
return
;
while
(
parent
!
=
=
null
)
{
if
(
validWrapperTypes
.
has
(
parent
.
tag
)
)
{
if
(
parent
.
tag
=
=
=
HostRoot
)
{
if
(
getChildren
(
parent
)
.
length
<
2
)
{
return
null
;
}
}
return
wrapFiber
(
parent
)
;
}
parent
=
parent
.
return
;
}
return
null
;
}
}
{
key
:
'
children
'
get
:
function
(
)
{
return
getChildren
(
this
.
_currentFiber
(
)
)
;
}
}
]
)
;
return
ReactTestInstance
;
}
(
)
;
function
_findAll
(
root
predicate
options
)
{
var
deep
=
options
?
options
.
deep
:
true
;
var
results
=
[
]
;
if
(
predicate
(
root
)
)
{
results
.
push
(
root
)
;
if
(
!
deep
)
{
return
results
;
}
}
root
.
children
.
forEach
(
function
(
child
)
{
if
(
typeof
child
=
=
=
'
string
'
)
{
return
;
}
results
.
push
.
apply
(
results
_findAll
(
child
predicate
options
)
)
;
}
)
;
return
results
;
}
function
expectOne
(
all
message
)
{
if
(
all
.
length
=
=
=
1
)
{
return
all
[
0
]
;
}
var
prefix
=
all
.
length
=
=
=
0
?
'
No
instances
found
'
:
'
Expected
1
but
found
'
+
all
.
length
+
'
instances
'
;
throw
new
Error
(
prefix
+
message
)
;
}
function
propsMatch
(
props
filter
)
{
for
(
var
key
in
filter
)
{
if
(
props
[
key
]
!
=
=
filter
[
key
]
)
{
return
false
;
}
}
return
true
;
}
var
ReactTestRendererFiber
=
{
create
:
function
(
element
options
)
{
var
createNodeMock
=
defaultTestOptions
.
createNodeMock
;
var
isAsync
=
false
;
if
(
typeof
options
=
=
=
'
object
'
&
&
options
!
=
=
null
)
{
if
(
typeof
options
.
createNodeMock
=
=
=
'
function
'
)
{
createNodeMock
=
options
.
createNodeMock
;
}
if
(
options
.
unstable_isAsync
=
=
=
true
)
{
isAsync
=
true
;
}
}
var
container
=
{
children
:
[
]
createNodeMock
:
createNodeMock
tag
:
'
CONTAINER
'
}
;
var
root
=
createContainer
(
container
isAsync
false
)
;
!
(
root
!
=
null
)
?
reactProdInvariant
(
'
215
'
)
:
void
0
;
updateContainer
(
element
root
null
null
)
;
var
entry
=
{
root
:
undefined
toJSON
:
function
(
)
{
if
(
root
=
=
null
|
|
root
.
current
=
=
null
|
|
container
=
=
null
)
{
return
null
;
}
if
(
container
.
children
.
length
=
=
=
0
)
{
return
null
;
}
if
(
container
.
children
.
length
=
=
=
1
)
{
return
toJSON
(
container
.
children
[
0
]
)
;
}
return
container
.
children
.
map
(
toJSON
)
;
}
toTree
:
function
(
)
{
if
(
root
=
=
null
|
|
root
.
current
=
=
null
)
{
return
null
;
}
return
toTree
(
root
.
current
)
;
}
update
:
function
(
newElement
)
{
if
(
root
=
=
null
|
|
root
.
current
=
=
null
)
{
return
;
}
updateContainer
(
newElement
root
null
null
)
;
}
unmount
:
function
(
)
{
if
(
root
=
=
null
|
|
root
.
current
=
=
null
)
{
return
;
}
updateContainer
(
null
root
null
null
)
;
container
=
null
;
root
=
null
;
}
getInstance
:
function
(
)
{
if
(
root
=
=
null
|
|
root
.
current
=
=
null
)
{
return
null
;
}
return
getPublicRootInstance
(
root
)
;
}
unstable_flushAll
:
flushAll
unstable_flushSync
:
function
(
fn
)
{
return
withCleanYields
(
function
(
)
{
flushSync
(
fn
)
;
}
)
;
}
unstable_flushThrough
:
flushThrough
unstable_yield
:
yieldValue
}
;
Object
.
defineProperty
(
entry
'
root
'
{
configurable
:
true
enumerable
:
true
get
:
function
(
)
{
if
(
root
=
=
=
null
)
{
throw
new
Error
(
"
Can
'
t
access
.
root
on
unmounted
test
renderer
"
)
;
}
var
children
=
getChildren
(
root
.
current
)
;
if
(
children
.
length
=
=
=
0
)
{
throw
new
Error
(
"
Can
'
t
access
.
root
on
unmounted
test
renderer
"
)
;
}
else
if
(
children
.
length
=
=
=
1
)
{
return
children
[
0
]
;
}
else
{
return
wrapFiber
(
root
.
current
)
;
}
}
}
)
;
return
entry
;
}
unstable_batchedUpdates
:
batchedUpdates
1
unstable_setNowImplementation
:
setNowImplementation
}
;
var
ReactTestRenderer
=
(
{
default
:
ReactTestRendererFiber
}
)
;
var
ReactTestRenderer
1
=
(
ReactTestRenderer
&
&
ReactTestRendererFiber
)
|
|
ReactTestRenderer
;
var
reactTestRenderer
=
ReactTestRenderer
1
.
default
?
ReactTestRenderer
1
.
default
:
ReactTestRenderer
1
;
return
reactTestRenderer
;
}
)
)
)
;
