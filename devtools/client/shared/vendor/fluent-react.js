'
use
strict
'
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
function
_interopDefault
(
ex
)
{
return
(
ex
&
&
(
typeof
ex
=
=
=
'
object
'
)
&
&
'
default
'
in
ex
)
?
ex
[
'
default
'
]
:
ex
;
}
const
react
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
.
js
"
)
;
const
PropTypes
=
_interopDefault
(
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
.
js
"
)
)
;
function
mapBundleSync
(
iterable
ids
)
{
if
(
!
Array
.
isArray
(
ids
)
)
{
return
getBundleForId
(
iterable
ids
)
;
}
return
ids
.
map
(
id
=
>
getBundleForId
(
iterable
id
)
)
;
}
function
getBundleForId
(
iterable
id
)
{
for
(
const
bundle
of
iterable
)
{
if
(
bundle
.
hasMessage
(
id
)
)
{
return
bundle
;
}
}
return
null
;
}
class
CachedIterable
extends
Array
{
static
from
(
iterable
)
{
if
(
iterable
instanceof
this
)
{
return
iterable
;
}
return
new
this
(
iterable
)
;
}
}
class
CachedSyncIterable
extends
CachedIterable
{
constructor
(
iterable
)
{
super
(
)
;
if
(
Symbol
.
iterator
in
Object
(
iterable
)
)
{
this
.
iterator
=
iterable
[
Symbol
.
iterator
]
(
)
;
}
else
{
throw
new
TypeError
(
"
Argument
must
implement
the
iteration
protocol
.
"
)
;
}
}
[
Symbol
.
iterator
]
(
)
{
const
cached
=
this
;
let
cur
=
0
;
return
{
next
(
)
{
if
(
cached
.
length
<
=
cur
)
{
cached
.
push
(
cached
.
iterator
.
next
(
)
)
;
}
return
cached
[
cur
+
+
]
;
}
}
;
}
touchNext
(
count
=
1
)
{
let
idx
=
0
;
while
(
idx
+
+
<
count
)
{
const
last
=
this
[
this
.
length
-
1
]
;
if
(
last
&
&
last
.
done
)
{
break
;
}
this
.
push
(
this
.
iterator
.
next
(
)
)
;
}
return
this
[
this
.
length
-
1
]
;
}
}
class
ReactLocalization
{
constructor
(
bundles
)
{
this
.
bundles
=
CachedSyncIterable
.
from
(
bundles
)
;
this
.
subs
=
new
Set
(
)
;
}
subscribe
(
comp
)
{
this
.
subs
.
add
(
comp
)
;
}
unsubscribe
(
comp
)
{
this
.
subs
.
delete
(
comp
)
;
}
setBundles
(
bundles
)
{
this
.
bundles
=
CachedSyncIterable
.
from
(
bundles
)
;
this
.
subs
.
forEach
(
comp
=
>
comp
.
relocalize
(
)
)
;
}
getBundle
(
id
)
{
return
mapBundleSync
(
this
.
bundles
id
)
;
}
getString
(
id
args
fallback
)
{
const
bundle
=
this
.
getBundle
(
id
)
;
if
(
bundle
)
{
const
msg
=
bundle
.
getMessage
(
id
)
;
if
(
msg
&
&
msg
.
value
)
{
let
errors
=
[
]
;
let
value
=
bundle
.
formatPattern
(
msg
.
value
args
errors
)
;
for
(
let
error
of
errors
)
{
this
.
reportError
(
error
)
;
}
return
value
;
}
}
return
fallback
|
|
id
;
}
reportError
(
error
)
{
console
.
warn
(
[
fluent
/
react
]
{
error
.
name
}
:
{
error
.
message
}
)
;
}
}
function
isReactLocalization
(
props
propName
)
{
const
prop
=
props
[
propName
]
;
if
(
prop
instanceof
ReactLocalization
)
{
return
null
;
}
return
new
Error
(
The
{
propName
}
context
field
must
be
an
instance
of
ReactLocalization
.
)
;
}
let
cachedParseMarkup
;
function
createParseMarkup
(
)
{
if
(
typeof
(
document
)
=
=
=
"
undefined
"
)
{
throw
new
Error
(
"
document
is
undefined
.
Without
it
translations
cannot
"
+
"
be
safely
sanitized
.
Consult
the
documentation
at
"
+
"
https
:
/
/
github
.
com
/
projectfluent
/
fluent
.
js
/
wiki
/
React
-
Overlays
.
"
)
;
}
if
(
!
cachedParseMarkup
)
{
const
template
=
document
.
createElement
(
"
template
"
)
;
cachedParseMarkup
=
function
parseMarkup
(
str
)
{
template
.
innerHTML
=
str
;
return
Array
.
from
(
template
.
content
.
childNodes
)
;
}
;
}
return
cachedParseMarkup
;
}
class
LocalizationProvider
extends
react
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
const
{
bundles
parseMarkup
}
=
props
;
if
(
bundles
=
=
=
undefined
)
{
throw
new
Error
(
"
LocalizationProvider
must
receive
the
bundles
prop
.
"
)
;
}
if
(
!
bundles
[
Symbol
.
iterator
]
)
{
throw
new
Error
(
"
The
bundles
prop
must
be
an
iterable
.
"
)
;
}
this
.
l10n
=
new
ReactLocalization
(
bundles
)
;
this
.
parseMarkup
=
parseMarkup
|
|
createParseMarkup
(
)
;
}
getChildContext
(
)
{
return
{
l10n
:
this
.
l10n
parseMarkup
:
this
.
parseMarkup
}
;
}
componentWillReceiveProps
(
next
)
{
const
{
bundles
}
=
next
;
if
(
bundles
!
=
=
this
.
props
.
bundles
)
{
this
.
l10n
.
setBundles
(
bundles
)
;
}
}
render
(
)
{
return
react
.
Children
.
only
(
this
.
props
.
children
)
;
}
}
LocalizationProvider
.
childContextTypes
=
{
l10n
:
isReactLocalization
parseMarkup
:
PropTypes
.
func
}
;
LocalizationProvider
.
propTypes
=
{
children
:
PropTypes
.
element
.
isRequired
bundles
:
isIterable
parseMarkup
:
PropTypes
.
func
}
;
function
isIterable
(
props
propName
componentName
)
{
const
prop
=
props
[
propName
]
;
if
(
Symbol
.
iterator
in
Object
(
prop
)
)
{
return
null
;
}
return
new
Error
(
The
{
propName
}
prop
supplied
to
{
componentName
}
must
be
an
iterable
.
)
;
}
function
withLocalization
(
Inner
)
{
class
WithLocalization
extends
react
.
Component
{
componentDidMount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
subscribe
(
this
)
;
}
}
componentWillUnmount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
unsubscribe
(
this
)
;
}
}
relocalize
(
)
{
this
.
forceUpdate
(
)
;
}
getString
(
id
args
fallback
)
{
const
{
l10n
}
=
this
.
context
;
if
(
!
l10n
)
{
return
fallback
|
|
id
;
}
return
l10n
.
getString
(
id
args
fallback
)
;
}
render
(
)
{
return
react
.
createElement
(
Inner
Object
.
assign
(
{
getString
:
(
.
.
.
args
)
=
>
this
.
getString
(
.
.
.
args
)
}
this
.
props
)
)
;
}
}
WithLocalization
.
displayName
=
WithLocalization
(
{
displayName
(
Inner
)
}
)
;
WithLocalization
.
contextTypes
=
{
l10n
:
isReactLocalization
}
;
return
WithLocalization
;
}
function
displayName
(
component
)
{
return
component
.
displayName
|
|
component
.
name
|
|
"
Component
"
;
}
var
omittedCloseTags
=
{
area
:
true
base
:
true
br
:
true
col
:
true
embed
:
true
hr
:
true
img
:
true
input
:
true
keygen
:
true
link
:
true
meta
:
true
param
:
true
source
:
true
track
:
true
wbr
:
true
}
;
var
voidElementTags
=
{
menuitem
:
true
.
.
.
omittedCloseTags
}
;
const
reMarkup
=
/
<
|
&
#
?
\
w
+
;
/
;
function
toArguments
(
props
)
{
const
args
=
{
}
;
const
elems
=
{
}
;
for
(
const
[
propname
propval
]
of
Object
.
entries
(
props
)
)
{
if
(
propname
.
startsWith
(
"
"
)
)
{
const
name
=
propname
.
substr
(
1
)
;
args
[
name
]
=
propval
;
}
else
if
(
react
.
isValidElement
(
propval
)
)
{
const
name
=
propname
.
toLowerCase
(
)
;
elems
[
name
]
=
propval
;
}
}
return
[
args
elems
]
;
}
class
Localized
extends
react
.
Component
{
componentDidMount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
subscribe
(
this
)
;
}
}
componentWillUnmount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
unsubscribe
(
this
)
;
}
}
relocalize
(
)
{
this
.
forceUpdate
(
)
;
}
render
(
)
{
const
{
l10n
parseMarkup
}
=
this
.
context
;
const
{
id
attrs
children
:
child
=
null
}
=
this
.
props
;
if
(
Array
.
isArray
(
child
)
)
{
throw
new
Error
(
"
<
Localized
/
>
expected
to
receive
a
single
"
+
"
React
node
child
"
)
;
}
if
(
!
l10n
)
{
return
child
;
}
const
bundle
=
l10n
.
getBundle
(
id
)
;
if
(
bundle
=
=
=
null
)
{
return
child
;
}
const
msg
=
bundle
.
getMessage
(
id
)
;
const
[
args
elems
]
=
toArguments
(
this
.
props
)
;
let
errors
=
[
]
;
if
(
!
react
.
isValidElement
(
child
)
)
{
if
(
msg
.
value
)
{
let
value
=
bundle
.
formatPattern
(
msg
.
value
args
errors
)
;
for
(
let
error
of
errors
)
{
l10n
.
reportError
(
error
)
;
}
return
value
;
}
return
child
;
}
let
localizedProps
;
if
(
attrs
&
&
msg
.
attributes
)
{
localizedProps
=
{
}
;
errors
=
[
]
;
for
(
const
[
name
allowed
]
of
Object
.
entries
(
attrs
)
)
{
if
(
allowed
&
&
name
in
msg
.
attributes
)
{
localizedProps
[
name
]
=
bundle
.
formatPattern
(
msg
.
attributes
[
name
]
args
errors
)
;
}
}
for
(
let
error
of
errors
)
{
l10n
.
reportError
(
error
)
;
}
}
if
(
child
.
type
in
voidElementTags
)
{
return
react
.
cloneElement
(
child
localizedProps
)
;
}
if
(
msg
.
value
=
=
=
null
)
{
return
react
.
cloneElement
(
child
localizedProps
)
;
}
errors
=
[
]
;
const
messageValue
=
bundle
.
formatPattern
(
msg
.
value
args
errors
)
;
for
(
let
error
of
errors
)
{
l10n
.
reportError
(
error
)
;
}
if
(
!
reMarkup
.
test
(
messageValue
)
)
{
return
react
.
cloneElement
(
child
localizedProps
messageValue
)
;
}
const
translationNodes
=
parseMarkup
(
messageValue
)
;
const
translatedChildren
=
translationNodes
.
map
(
childNode
=
>
{
if
(
childNode
.
nodeType
=
=
=
childNode
.
TEXT_NODE
)
{
return
childNode
.
textContent
;
}
if
(
!
elems
.
hasOwnProperty
(
childNode
.
localName
)
)
{
return
childNode
.
textContent
;
}
const
sourceChild
=
elems
[
childNode
.
localName
]
;
if
(
sourceChild
.
type
in
voidElementTags
)
{
return
sourceChild
;
}
return
react
.
cloneElement
(
sourceChild
null
childNode
.
textContent
)
;
}
)
;
return
react
.
cloneElement
(
child
localizedProps
.
.
.
translatedChildren
)
;
}
}
Localized
.
contextTypes
=
{
l10n
:
isReactLocalization
parseMarkup
:
PropTypes
.
func
}
;
Localized
.
propTypes
=
{
children
:
PropTypes
.
node
}
;
exports
.
LocalizationProvider
=
LocalizationProvider
;
exports
.
Localized
=
Localized
;
exports
.
ReactLocalization
=
ReactLocalization
;
exports
.
isReactLocalization
=
isReactLocalization
;
exports
.
withLocalization
=
withLocalization
;
