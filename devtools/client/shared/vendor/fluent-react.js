(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
factory
(
exports
require
(
'
devtools
/
client
/
shared
/
vendor
/
fluent
'
)
require
(
'
devtools
/
client
/
shared
/
vendor
/
react
'
)
require
(
'
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
'
)
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
'
fluent
-
react
'
[
'
exports
'
'
fluent
'
'
react
'
'
prop
-
types
'
]
factory
)
:
(
factory
(
(
global
.
FluentReact
=
{
}
)
global
.
Fluent
global
.
React
global
.
PropTypes
)
)
;
}
(
this
(
function
(
exports
fluent
react
PropTypes
)
{
'
use
strict
'
;
PropTypes
=
PropTypes
&
&
PropTypes
.
hasOwnProperty
(
'
default
'
)
?
PropTypes
[
'
default
'
]
:
PropTypes
;
class
ReactLocalization
{
constructor
(
messages
)
{
this
.
contexts
=
new
fluent
.
CachedIterable
(
messages
)
;
this
.
subs
=
new
Set
(
)
;
}
subscribe
(
comp
)
{
this
.
subs
.
add
(
comp
)
;
}
unsubscribe
(
comp
)
{
this
.
subs
.
delete
(
comp
)
;
}
setMessages
(
messages
)
{
this
.
contexts
=
new
fluent
.
CachedIterable
(
messages
)
;
this
.
subs
.
forEach
(
comp
=
>
comp
.
relocalize
(
)
)
;
}
getMessageContext
(
id
)
{
return
fluent
.
mapContextSync
(
this
.
contexts
id
)
;
}
formatCompound
(
mcx
msg
args
)
{
const
value
=
mcx
.
format
(
msg
args
)
;
if
(
msg
.
attrs
)
{
var
attrs
=
{
}
;
for
(
const
name
of
Object
.
keys
(
msg
.
attrs
)
)
{
attrs
[
name
]
=
mcx
.
format
(
msg
.
attrs
[
name
]
args
)
;
}
}
return
{
value
attrs
}
;
}
getString
(
id
args
fallback
)
{
const
mcx
=
this
.
getMessageContext
(
id
)
;
if
(
mcx
=
=
=
null
)
{
return
fallback
|
|
id
;
}
const
msg
=
mcx
.
getMessage
(
id
)
;
return
mcx
.
format
(
msg
args
)
;
}
}
function
isReactLocalization
(
props
propName
)
{
const
prop
=
props
[
propName
]
;
if
(
prop
instanceof
ReactLocalization
)
{
return
null
;
}
return
new
Error
(
The
{
propName
}
context
field
must
be
an
instance
of
ReactLocalization
.
)
;
}
class
LocalizationProvider
extends
react
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
const
{
messages
}
=
props
;
if
(
messages
=
=
=
undefined
)
{
throw
new
Error
(
"
LocalizationProvider
must
receive
the
messages
prop
.
"
)
;
}
if
(
!
messages
[
Symbol
.
iterator
]
)
{
throw
new
Error
(
"
The
messages
prop
must
be
an
iterable
.
"
)
;
}
this
.
l10n
=
new
ReactLocalization
(
messages
)
;
}
getChildContext
(
)
{
return
{
l10n
:
this
.
l10n
}
;
}
componentWillReceiveProps
(
next
)
{
const
{
messages
}
=
next
;
if
(
messages
!
=
=
this
.
props
.
messages
)
{
this
.
l10n
.
setMessages
(
messages
)
;
}
}
render
(
)
{
return
react
.
Children
.
only
(
this
.
props
.
children
)
;
}
}
LocalizationProvider
.
childContextTypes
=
{
l10n
:
isReactLocalization
}
;
LocalizationProvider
.
propTypes
=
{
children
:
PropTypes
.
element
.
isRequired
messages
:
isIterable
}
;
function
isIterable
(
props
propName
componentName
)
{
const
prop
=
props
[
propName
]
;
if
(
Symbol
.
iterator
in
Object
(
prop
)
)
{
return
null
;
}
return
new
Error
(
The
{
propName
}
prop
supplied
to
{
componentName
}
must
be
an
iterable
.
)
;
}
function
withLocalization
(
Inner
)
{
class
WithLocalization
extends
react
.
Component
{
componentDidMount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
subscribe
(
this
)
;
}
}
componentWillUnmount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
unsubscribe
(
this
)
;
}
}
relocalize
(
)
{
this
.
forceUpdate
(
)
;
}
getString
(
id
args
fallback
)
{
const
{
l10n
}
=
this
.
context
;
if
(
!
l10n
)
{
return
fallback
|
|
id
;
}
return
l10n
.
getString
(
id
args
fallback
)
;
}
render
(
)
{
return
react
.
createElement
(
Inner
Object
.
assign
(
{
getString
:
(
.
.
.
args
)
=
>
this
.
getString
(
.
.
.
args
)
}
this
.
props
)
)
;
}
}
WithLocalization
.
displayName
=
WithLocalization
(
{
displayName
(
Inner
)
}
)
;
WithLocalization
.
contextTypes
=
{
l10n
:
isReactLocalization
}
;
return
WithLocalization
;
}
function
displayName
(
component
)
{
return
component
.
displayName
|
|
component
.
name
|
|
"
Component
"
;
}
const
TEMPLATE
=
document
.
createElement
(
"
template
"
)
;
function
parseMarkup
(
str
)
{
TEMPLATE
.
innerHTML
=
str
;
return
TEMPLATE
.
content
;
}
var
omittedCloseTags
=
{
area
:
true
base
:
true
br
:
true
col
:
true
embed
:
true
hr
:
true
img
:
true
input
:
true
keygen
:
true
link
:
true
meta
:
true
param
:
true
source
:
true
track
:
true
wbr
:
true
}
;
var
voidElementTags
=
{
menuitem
:
true
.
.
.
omittedCloseTags
}
;
const
reMarkup
=
/
<
|
&
#
?
\
w
+
;
/
;
function
toArguments
(
props
)
{
const
args
=
{
}
;
const
elems
=
{
}
;
for
(
const
[
propname
propval
]
of
Object
.
entries
(
props
)
)
{
if
(
propname
.
startsWith
(
"
"
)
)
{
const
name
=
propname
.
substr
(
1
)
;
args
[
name
]
=
propval
;
}
else
if
(
react
.
isValidElement
(
propval
)
)
{
const
name
=
propname
.
toLowerCase
(
)
;
elems
[
name
]
=
propval
;
}
}
return
[
args
elems
]
;
}
class
Localized
extends
react
.
Component
{
componentDidMount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
subscribe
(
this
)
;
}
}
componentWillUnmount
(
)
{
const
{
l10n
}
=
this
.
context
;
if
(
l10n
)
{
l10n
.
unsubscribe
(
this
)
;
}
}
relocalize
(
)
{
this
.
forceUpdate
(
)
;
}
render
(
)
{
const
{
l10n
}
=
this
.
context
;
const
{
id
attrs
children
}
=
this
.
props
;
const
elem
=
react
.
Children
.
only
(
children
)
;
if
(
!
l10n
)
{
return
elem
;
}
const
mcx
=
l10n
.
getMessageContext
(
id
)
;
if
(
mcx
=
=
=
null
)
{
return
elem
;
}
const
msg
=
mcx
.
getMessage
(
id
)
;
const
[
args
elems
]
=
toArguments
(
this
.
props
)
;
const
{
value
:
messageValue
attrs
:
messageAttrs
}
=
l10n
.
formatCompound
(
mcx
msg
args
)
;
if
(
attrs
&
&
messageAttrs
)
{
var
localizedProps
=
{
}
;
for
(
const
[
name
value
]
of
Object
.
entries
(
messageAttrs
)
)
{
if
(
attrs
[
name
]
)
{
localizedProps
[
name
]
=
value
;
}
}
}
if
(
elem
.
type
in
voidElementTags
)
{
return
react
.
cloneElement
(
elem
localizedProps
)
;
}
if
(
messageValue
=
=
=
null
)
{
return
react
.
cloneElement
(
elem
localizedProps
)
;
}
if
(
!
reMarkup
.
test
(
messageValue
)
)
{
return
react
.
cloneElement
(
elem
localizedProps
messageValue
)
;
}
const
translationNodes
=
Array
.
from
(
parseMarkup
(
messageValue
)
.
childNodes
)
;
const
translatedChildren
=
translationNodes
.
map
(
childNode
=
>
{
if
(
childNode
.
nodeType
=
=
=
childNode
.
TEXT_NODE
)
{
return
childNode
.
textContent
;
}
if
(
!
elems
.
hasOwnProperty
(
childNode
.
localName
)
)
{
return
childNode
.
textContent
;
}
const
sourceChild
=
elems
[
childNode
.
localName
]
;
if
(
sourceChild
.
type
in
voidElementTags
)
{
return
sourceChild
;
}
return
react
.
cloneElement
(
sourceChild
null
childNode
.
textContent
)
;
}
)
;
return
react
.
cloneElement
(
elem
localizedProps
.
.
.
translatedChildren
)
;
}
}
Localized
.
contextTypes
=
{
l10n
:
isReactLocalization
}
;
Localized
.
propTypes
=
{
children
:
PropTypes
.
element
.
isRequired
}
;
exports
.
LocalizationProvider
=
LocalizationProvider
;
exports
.
withLocalization
=
withLocalization
;
exports
.
Localized
=
Localized
;
exports
.
ReactLocalization
=
ReactLocalization
;
exports
.
isReactLocalization
=
isReactLocalization
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
)
)
)
;
