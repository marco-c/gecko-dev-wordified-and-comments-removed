(
function
(
)
{
"
use
strict
"
;
function
addPropertyTo
(
target
methodName
value
)
{
Object
.
defineProperty
(
target
methodName
{
enumerable
:
false
configurable
:
false
writable
:
false
value
:
value
}
)
;
}
function
banProperty
(
target
methodName
)
{
addPropertyTo
(
target
methodName
function
(
)
{
throw
new
ImmutableError
(
"
The
"
+
methodName
+
"
method
cannot
be
invoked
on
an
Immutable
data
structure
.
"
)
;
}
)
;
}
var
immutabilityTag
=
"
__immutable_invariants_hold
"
;
function
addImmutabilityTag
(
target
)
{
addPropertyTo
(
target
immutabilityTag
true
)
;
}
function
isImmutable
(
target
)
{
if
(
typeof
target
=
=
=
"
object
"
)
{
return
target
=
=
=
null
|
|
target
.
hasOwnProperty
(
immutabilityTag
)
;
}
else
{
return
true
;
}
}
function
isMergableObject
(
target
)
{
return
target
!
=
=
null
&
&
typeof
target
=
=
=
"
object
"
&
&
!
(
target
instanceof
Array
)
&
&
!
(
target
instanceof
Date
)
;
}
var
mutatingObjectMethods
=
[
"
setPrototypeOf
"
]
;
var
nonMutatingObjectMethods
=
[
"
keys
"
]
;
var
mutatingArrayMethods
=
mutatingObjectMethods
.
concat
(
[
"
push
"
"
pop
"
"
sort
"
"
splice
"
"
shift
"
"
unshift
"
"
reverse
"
]
)
;
var
nonMutatingArrayMethods
=
nonMutatingObjectMethods
.
concat
(
[
"
map
"
"
filter
"
"
slice
"
"
concat
"
"
reduce
"
"
reduceRight
"
]
)
;
function
ImmutableError
(
message
)
{
var
err
=
new
Error
(
message
)
;
err
.
__proto__
=
ImmutableError
;
return
err
;
}
ImmutableError
.
prototype
=
Error
.
prototype
;
function
makeImmutable
(
obj
bannedMethods
)
{
addImmutabilityTag
(
obj
)
;
if
(
"
development
"
=
=
=
"
development
"
)
{
for
(
var
index
in
bannedMethods
)
{
if
(
bannedMethods
.
hasOwnProperty
(
index
)
)
{
banProperty
(
obj
bannedMethods
[
index
]
)
;
}
}
Object
.
freeze
(
obj
)
;
}
return
obj
;
}
function
makeMethodReturnImmutable
(
obj
methodName
)
{
var
currentMethod
=
obj
[
methodName
]
;
addPropertyTo
(
obj
methodName
function
(
)
{
return
Immutable
(
currentMethod
.
apply
(
obj
arguments
)
)
;
}
)
;
}
function
makeImmutableArray
(
array
)
{
for
(
var
index
in
nonMutatingArrayMethods
)
{
if
(
nonMutatingArrayMethods
.
hasOwnProperty
(
index
)
)
{
var
methodName
=
nonMutatingArrayMethods
[
index
]
;
makeMethodReturnImmutable
(
array
methodName
)
;
}
}
addPropertyTo
(
array
"
flatMap
"
flatMap
)
;
addPropertyTo
(
array
"
asObject
"
asObject
)
;
addPropertyTo
(
array
"
asMutable
"
asMutableArray
)
;
for
(
var
i
=
0
length
=
array
.
length
;
i
<
length
;
i
+
+
)
{
array
[
i
]
=
Immutable
(
array
[
i
]
)
;
}
return
makeImmutable
(
array
mutatingArrayMethods
)
;
}
function
flatMap
(
iterator
)
{
if
(
arguments
.
length
=
=
=
0
)
{
return
this
;
}
var
result
=
[
]
length
=
this
.
length
index
;
for
(
index
=
0
;
index
<
length
;
index
+
+
)
{
var
iteratorResult
=
iterator
(
this
[
index
]
index
this
)
;
if
(
iteratorResult
instanceof
Array
)
{
result
.
push
.
apply
(
result
iteratorResult
)
;
}
else
{
result
.
push
(
iteratorResult
)
;
}
}
return
makeImmutableArray
(
result
)
;
}
function
without
(
keysToRemove
)
{
if
(
arguments
.
length
=
=
=
0
)
{
return
this
;
}
if
(
!
(
keysToRemove
instanceof
Array
)
)
{
keysToRemove
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
}
var
result
=
this
.
instantiateEmptyObject
(
)
;
for
(
var
key
in
this
)
{
if
(
this
.
hasOwnProperty
(
key
)
&
&
(
keysToRemove
.
indexOf
(
key
)
=
=
=
-
1
)
)
{
result
[
key
]
=
this
[
key
]
;
}
}
return
makeImmutableObject
(
result
{
instantiateEmptyObject
:
this
.
instantiateEmptyObject
}
)
;
}
function
asMutableArray
(
opts
)
{
var
result
=
[
]
i
length
;
if
(
opts
&
&
opts
.
deep
)
{
for
(
i
=
0
length
=
this
.
length
;
i
<
length
;
i
+
+
)
{
result
.
push
(
asDeepMutable
(
this
[
i
]
)
)
;
}
}
else
{
for
(
i
=
0
length
=
this
.
length
;
i
<
length
;
i
+
+
)
{
result
.
push
(
this
[
i
]
)
;
}
}
return
result
;
}
function
asObject
(
iterator
)
{
if
(
typeof
iterator
!
=
=
"
function
"
)
{
iterator
=
function
(
value
)
{
return
value
;
}
;
}
var
result
=
{
}
length
=
this
.
length
index
;
for
(
index
=
0
;
index
<
length
;
index
+
+
)
{
var
pair
=
iterator
(
this
[
index
]
index
this
)
key
=
pair
[
0
]
value
=
pair
[
1
]
;
result
[
key
]
=
value
;
}
return
makeImmutableObject
(
result
)
;
}
function
asDeepMutable
(
obj
)
{
if
(
!
obj
|
|
!
obj
.
hasOwnProperty
(
immutabilityTag
)
|
|
obj
instanceof
Date
)
{
return
obj
;
}
return
obj
.
asMutable
(
{
deep
:
true
}
)
;
}
function
quickCopy
(
src
dest
)
{
for
(
var
key
in
src
)
{
if
(
src
.
hasOwnProperty
(
key
)
)
{
dest
[
key
]
=
src
[
key
]
;
}
}
return
dest
;
}
function
merge
(
other
config
)
{
if
(
arguments
.
length
=
=
=
0
)
{
return
this
;
}
if
(
other
=
=
=
null
|
|
(
typeof
other
!
=
=
"
object
"
)
)
{
throw
new
TypeError
(
"
Immutable
#
merge
can
only
be
invoked
with
objects
or
arrays
not
"
+
JSON
.
stringify
(
other
)
)
;
}
var
anyChanges
=
false
result
=
quickCopy
(
this
this
.
instantiateEmptyObject
(
)
)
receivedArray
=
(
other
instanceof
Array
)
deep
=
config
&
&
config
.
deep
merger
=
config
&
&
config
.
merger
key
;
function
addToResult
(
currentObj
otherObj
key
)
{
var
immutableValue
=
Immutable
(
otherObj
[
key
]
)
;
var
mergerResult
=
merger
&
&
merger
(
currentObj
[
key
]
immutableValue
config
)
;
if
(
merger
&
&
mergerResult
&
&
mergerResult
=
=
=
currentObj
[
key
]
)
return
;
anyChanges
=
anyChanges
|
|
mergerResult
!
=
=
undefined
|
|
(
!
currentObj
.
hasOwnProperty
(
key
)
|
|
(
(
immutableValue
!
=
=
currentObj
[
key
]
)
&
&
(
immutableValue
=
=
=
immutableValue
)
)
)
;
if
(
mergerResult
)
{
result
[
key
]
=
mergerResult
;
}
else
if
(
deep
&
&
isMergableObject
(
currentObj
[
key
]
)
&
&
isMergableObject
(
immutableValue
)
)
{
result
[
key
]
=
currentObj
[
key
]
.
merge
(
immutableValue
config
)
;
}
else
{
result
[
key
]
=
immutableValue
;
}
}
if
(
!
receivedArray
)
{
for
(
key
in
other
)
{
if
(
other
.
hasOwnProperty
(
key
)
)
{
addToResult
(
this
other
key
)
;
}
}
}
else
{
for
(
var
index
=
0
;
index
<
other
.
length
;
index
+
+
)
{
var
otherFromArray
=
other
[
index
]
;
for
(
key
in
otherFromArray
)
{
if
(
otherFromArray
.
hasOwnProperty
(
key
)
)
{
addToResult
(
this
otherFromArray
key
)
;
}
}
}
}
if
(
anyChanges
)
{
return
makeImmutableObject
(
result
{
instantiateEmptyObject
:
this
.
instantiateEmptyObject
}
)
;
}
else
{
return
this
;
}
}
function
asMutableObject
(
opts
)
{
var
result
=
this
.
instantiateEmptyObject
(
)
key
;
if
(
opts
&
&
opts
.
deep
)
{
for
(
key
in
this
)
{
if
(
this
.
hasOwnProperty
(
key
)
)
{
result
[
key
]
=
asDeepMutable
(
this
[
key
]
)
;
}
}
}
else
{
for
(
key
in
this
)
{
if
(
this
.
hasOwnProperty
(
key
)
)
{
result
[
key
]
=
this
[
key
]
;
}
}
}
return
result
;
}
function
instantiatePlainObject
(
)
{
return
{
}
;
}
function
makeImmutableObject
(
obj
options
)
{
var
instantiateEmptyObject
=
(
options
&
&
options
.
instantiateEmptyObject
)
?
options
.
instantiateEmptyObject
:
instantiatePlainObject
;
addPropertyTo
(
obj
"
merge
"
merge
)
;
addPropertyTo
(
obj
"
without
"
without
)
;
addPropertyTo
(
obj
"
asMutable
"
asMutableObject
)
;
addPropertyTo
(
obj
"
instantiateEmptyObject
"
instantiateEmptyObject
)
;
return
makeImmutable
(
obj
mutatingObjectMethods
)
;
}
function
Immutable
(
obj
options
)
{
if
(
isImmutable
(
obj
)
)
{
return
obj
;
}
else
if
(
obj
instanceof
Array
)
{
return
makeImmutableArray
(
obj
.
slice
(
)
)
;
}
else
if
(
obj
instanceof
Date
)
{
return
makeImmutable
(
new
Date
(
obj
.
getTime
(
)
)
)
;
}
else
{
var
prototype
=
options
&
&
options
.
prototype
;
var
instantiateEmptyObject
=
(
!
prototype
|
|
prototype
=
=
=
Object
.
prototype
)
?
instantiatePlainObject
:
(
function
(
)
{
return
Object
.
create
(
prototype
)
;
}
)
;
var
clone
=
instantiateEmptyObject
(
)
;
for
(
var
key
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
key
)
)
{
clone
[
key
]
=
Immutable
(
obj
[
key
]
)
;
}
}
return
makeImmutableObject
(
clone
{
instantiateEmptyObject
:
instantiateEmptyObject
}
)
;
}
}
Immutable
.
isImmutable
=
isImmutable
;
Immutable
.
ImmutableError
=
ImmutableError
;
Object
.
freeze
(
Immutable
)
;
if
(
typeof
module
=
=
=
"
object
"
)
{
module
.
exports
=
Immutable
;
}
else
if
(
typeof
exports
=
=
=
"
object
"
)
{
exports
.
Immutable
=
Immutable
;
}
else
if
(
typeof
window
=
=
=
"
object
"
)
{
window
.
Immutable
=
Immutable
;
}
else
if
(
typeof
global
=
=
=
"
object
"
)
{
global
.
Immutable
=
Immutable
;
}
}
)
(
)
;
