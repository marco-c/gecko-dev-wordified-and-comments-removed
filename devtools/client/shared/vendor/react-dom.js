(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
module
.
exports
=
factory
(
require
(
'
devtools
/
client
/
shared
/
vendor
/
react
'
)
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
[
'
devtools
/
client
/
shared
/
vendor
/
react
'
]
factory
)
:
(
global
.
ReactDOM
=
factory
(
global
.
React
)
)
;
}
(
this
(
function
(
React
)
{
'
use
strict
'
;
function
reactProdInvariant
(
code
)
{
var
argCount
=
arguments
.
length
-
1
;
var
message
=
'
Minified
React
error
#
'
+
code
+
'
;
visit
'
+
'
http
:
/
/
facebook
.
github
.
io
/
react
/
docs
/
error
-
decoder
.
html
?
invariant
=
'
+
code
;
for
(
var
argIdx
=
0
;
argIdx
<
argCount
;
argIdx
+
+
)
{
message
+
=
'
&
args
[
]
=
'
+
encodeURIComponent
(
arguments
[
argIdx
+
1
]
)
;
}
message
+
=
'
for
the
full
message
or
use
the
non
-
minified
dev
environment
'
+
'
for
full
errors
and
additional
helpful
warnings
.
'
;
var
error
=
new
Error
(
message
)
;
error
.
name
=
'
Invariant
Violation
'
;
error
.
framesToPop
=
1
;
throw
error
;
}
!
React
?
reactProdInvariant
(
'
227
'
)
:
void
0
;
var
RESERVED_PROPS
=
{
children
:
true
dangerouslySetInnerHTML
:
true
defaultValue
:
true
defaultChecked
:
true
innerHTML
:
true
suppressContentEditableWarning
:
true
suppressHydrationWarning
:
true
style
:
true
}
;
function
checkMask
(
value
bitmask
)
{
return
(
value
&
bitmask
)
=
=
=
bitmask
;
}
var
DOMPropertyInjection
=
{
MUST_USE_PROPERTY
:
0x1
HAS_BOOLEAN_VALUE
:
0x4
HAS_NUMERIC_VALUE
:
0x8
HAS_POSITIVE_NUMERIC_VALUE
:
0x10
|
0x8
HAS_OVERLOADED_BOOLEAN_VALUE
:
0x20
HAS_STRING_BOOLEAN_VALUE
:
0x40
injectDOMPropertyConfig
:
function
(
domPropertyConfig
)
{
var
Injection
=
DOMPropertyInjection
;
var
Properties
=
domPropertyConfig
.
Properties
|
|
{
}
;
var
DOMAttributeNamespaces
=
domPropertyConfig
.
DOMAttributeNamespaces
|
|
{
}
;
var
DOMAttributeNames
=
domPropertyConfig
.
DOMAttributeNames
|
|
{
}
;
var
DOMMutationMethods
=
domPropertyConfig
.
DOMMutationMethods
|
|
{
}
;
for
(
var
propName
in
Properties
)
{
!
!
properties
.
hasOwnProperty
(
propName
)
?
reactProdInvariant
(
"
48
"
propName
)
:
void
0
;
var
lowerCased
=
propName
.
toLowerCase
(
)
;
var
propConfig
=
Properties
[
propName
]
;
var
propertyInfo
=
{
attributeName
:
lowerCased
attributeNamespace
:
null
propertyName
:
propName
mutationMethod
:
null
mustUseProperty
:
checkMask
(
propConfig
Injection
.
MUST_USE_PROPERTY
)
hasBooleanValue
:
checkMask
(
propConfig
Injection
.
HAS_BOOLEAN_VALUE
)
hasNumericValue
:
checkMask
(
propConfig
Injection
.
HAS_NUMERIC_VALUE
)
hasPositiveNumericValue
:
checkMask
(
propConfig
Injection
.
HAS_POSITIVE_NUMERIC_VALUE
)
hasOverloadedBooleanValue
:
checkMask
(
propConfig
Injection
.
HAS_OVERLOADED_BOOLEAN_VALUE
)
hasStringBooleanValue
:
checkMask
(
propConfig
Injection
.
HAS_STRING_BOOLEAN_VALUE
)
}
;
!
(
propertyInfo
.
hasBooleanValue
+
propertyInfo
.
hasNumericValue
+
propertyInfo
.
hasOverloadedBooleanValue
<
=
1
)
?
reactProdInvariant
(
"
50
"
propName
)
:
void
0
;
if
(
DOMAttributeNames
.
hasOwnProperty
(
propName
)
)
{
var
attributeName
=
DOMAttributeNames
[
propName
]
;
propertyInfo
.
attributeName
=
attributeName
;
}
if
(
DOMAttributeNamespaces
.
hasOwnProperty
(
propName
)
)
{
propertyInfo
.
attributeNamespace
=
DOMAttributeNamespaces
[
propName
]
;
}
if
(
DOMMutationMethods
.
hasOwnProperty
(
propName
)
)
{
propertyInfo
.
mutationMethod
=
DOMMutationMethods
[
propName
]
;
}
properties
[
propName
]
=
propertyInfo
;
}
}
}
;
var
ATTRIBUTE_NAME_START_CHAR
=
"
:
A
-
Z_a
-
z
\
\
u00C0
-
\
\
u00D6
\
\
u00D8
-
\
\
u00F6
\
\
u00F8
-
\
\
u02FF
\
\
u0370
-
\
\
u037D
\
\
u037F
-
\
\
u1FFF
\
\
u200C
-
\
\
u200D
\
\
u2070
-
\
\
u218F
\
\
u2C00
-
\
\
u2FEF
\
\
u3001
-
\
\
uD7FF
\
\
uF900
-
\
\
uFDCF
\
\
uFDF0
-
\
\
uFFFD
"
;
var
ATTRIBUTE_NAME_CHAR
=
ATTRIBUTE_NAME_START_CHAR
+
"
\
\
-
.
0
-
9
\
\
u00B7
\
\
u0300
-
\
\
u036F
\
\
u203F
-
\
\
u2040
"
;
var
ROOT_ATTRIBUTE_NAME
=
'
data
-
reactroot
'
;
var
properties
=
{
}
;
function
shouldSetAttribute
(
name
value
)
{
if
(
isReservedProp
(
name
)
)
{
return
false
;
}
if
(
name
.
length
>
2
&
&
(
name
[
0
]
=
=
=
'
o
'
|
|
name
[
0
]
=
=
=
'
O
'
)
&
&
(
name
[
1
]
=
=
=
'
n
'
|
|
name
[
1
]
=
=
=
'
N
'
)
)
{
return
false
;
}
if
(
value
=
=
=
null
)
{
return
true
;
}
switch
(
typeof
value
)
{
case
'
boolean
'
:
return
shouldAttributeAcceptBooleanValue
(
name
)
;
case
'
undefined
'
:
case
'
number
'
:
case
'
string
'
:
case
'
object
'
:
return
true
;
default
:
return
false
;
}
}
function
getPropertyInfo
(
name
)
{
return
properties
.
hasOwnProperty
(
name
)
?
properties
[
name
]
:
null
;
}
function
shouldAttributeAcceptBooleanValue
(
name
)
{
if
(
isReservedProp
(
name
)
)
{
return
true
;
}
var
propertyInfo
=
getPropertyInfo
(
name
)
;
if
(
propertyInfo
)
{
return
propertyInfo
.
hasBooleanValue
|
|
propertyInfo
.
hasStringBooleanValue
|
|
propertyInfo
.
hasOverloadedBooleanValue
;
}
var
prefix
=
name
.
toLowerCase
(
)
.
slice
(
0
5
)
;
return
prefix
=
=
=
'
data
-
'
|
|
prefix
=
=
=
'
aria
-
'
;
}
function
isReservedProp
(
name
)
{
return
RESERVED_PROPS
.
hasOwnProperty
(
name
)
;
}
var
injection
=
DOMPropertyInjection
;
var
MUST_USE_PROPERTY
=
injection
.
MUST_USE_PROPERTY
;
var
HAS_BOOLEAN_VALUE
=
injection
.
HAS_BOOLEAN_VALUE
;
var
HAS_NUMERIC_VALUE
=
injection
.
HAS_NUMERIC_VALUE
;
var
HAS_POSITIVE_NUMERIC_VALUE
=
injection
.
HAS_POSITIVE_NUMERIC_VALUE
;
var
HAS_OVERLOADED_BOOLEAN_VALUE
=
injection
.
HAS_OVERLOADED_BOOLEAN_VALUE
;
var
HAS_STRING_BOOLEAN_VALUE
=
injection
.
HAS_STRING_BOOLEAN_VALUE
;
var
HTMLDOMPropertyConfig
=
{
Properties
:
{
allowFullScreen
:
HAS_BOOLEAN_VALUE
async
:
HAS_BOOLEAN_VALUE
autoFocus
:
HAS_BOOLEAN_VALUE
autoPlay
:
HAS_BOOLEAN_VALUE
capture
:
HAS_OVERLOADED_BOOLEAN_VALUE
checked
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
cols
:
HAS_POSITIVE_NUMERIC_VALUE
contentEditable
:
HAS_STRING_BOOLEAN_VALUE
controls
:
HAS_BOOLEAN_VALUE
'
default
'
:
HAS_BOOLEAN_VALUE
defer
:
HAS_BOOLEAN_VALUE
disabled
:
HAS_BOOLEAN_VALUE
download
:
HAS_OVERLOADED_BOOLEAN_VALUE
draggable
:
HAS_STRING_BOOLEAN_VALUE
formNoValidate
:
HAS_BOOLEAN_VALUE
hidden
:
HAS_BOOLEAN_VALUE
loop
:
HAS_BOOLEAN_VALUE
multiple
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
muted
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
noValidate
:
HAS_BOOLEAN_VALUE
open
:
HAS_BOOLEAN_VALUE
playsInline
:
HAS_BOOLEAN_VALUE
readOnly
:
HAS_BOOLEAN_VALUE
required
:
HAS_BOOLEAN_VALUE
reversed
:
HAS_BOOLEAN_VALUE
rows
:
HAS_POSITIVE_NUMERIC_VALUE
rowSpan
:
HAS_NUMERIC_VALUE
scoped
:
HAS_BOOLEAN_VALUE
seamless
:
HAS_BOOLEAN_VALUE
selected
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
size
:
HAS_POSITIVE_NUMERIC_VALUE
start
:
HAS_NUMERIC_VALUE
span
:
HAS_POSITIVE_NUMERIC_VALUE
spellCheck
:
HAS_STRING_BOOLEAN_VALUE
style
:
0
tabIndex
:
0
itemScope
:
HAS_BOOLEAN_VALUE
acceptCharset
:
0
className
:
0
htmlFor
:
0
httpEquiv
:
0
value
:
HAS_STRING_BOOLEAN_VALUE
}
DOMAttributeNames
:
{
acceptCharset
:
'
accept
-
charset
'
className
:
'
class
'
htmlFor
:
'
for
'
httpEquiv
:
'
http
-
equiv
'
}
DOMMutationMethods
:
{
value
:
function
(
node
value
)
{
if
(
value
=
=
null
)
{
return
node
.
removeAttribute
(
'
value
'
)
;
}
if
(
node
.
type
!
=
=
'
number
'
|
|
node
.
hasAttribute
(
'
value
'
)
=
=
=
false
)
{
node
.
setAttribute
(
'
value
'
'
'
+
value
)
;
}
else
if
(
node
.
validity
&
&
!
node
.
validity
.
badInput
&
&
node
.
ownerDocument
.
activeElement
!
=
=
node
)
{
node
.
setAttribute
(
'
value
'
'
'
+
value
)
;
}
}
}
}
;
var
HAS_STRING_BOOLEAN_VALUE
1
=
injection
.
HAS_STRING_BOOLEAN_VALUE
;
var
NS
=
{
xlink
:
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
xml
:
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
}
;
var
ATTRS
=
[
'
accent
-
height
'
'
alignment
-
baseline
'
'
arabic
-
form
'
'
baseline
-
shift
'
'
cap
-
height
'
'
clip
-
path
'
'
clip
-
rule
'
'
color
-
interpolation
'
'
color
-
interpolation
-
filters
'
'
color
-
profile
'
'
color
-
rendering
'
'
dominant
-
baseline
'
'
enable
-
background
'
'
fill
-
opacity
'
'
fill
-
rule
'
'
flood
-
color
'
'
flood
-
opacity
'
'
font
-
family
'
'
font
-
size
'
'
font
-
size
-
adjust
'
'
font
-
stretch
'
'
font
-
style
'
'
font
-
variant
'
'
font
-
weight
'
'
glyph
-
name
'
'
glyph
-
orientation
-
horizontal
'
'
glyph
-
orientation
-
vertical
'
'
horiz
-
adv
-
x
'
'
horiz
-
origin
-
x
'
'
image
-
rendering
'
'
letter
-
spacing
'
'
lighting
-
color
'
'
marker
-
end
'
'
marker
-
mid
'
'
marker
-
start
'
'
overline
-
position
'
'
overline
-
thickness
'
'
paint
-
order
'
'
panose
-
1
'
'
pointer
-
events
'
'
rendering
-
intent
'
'
shape
-
rendering
'
'
stop
-
color
'
'
stop
-
opacity
'
'
strikethrough
-
position
'
'
strikethrough
-
thickness
'
'
stroke
-
dasharray
'
'
stroke
-
dashoffset
'
'
stroke
-
linecap
'
'
stroke
-
linejoin
'
'
stroke
-
miterlimit
'
'
stroke
-
opacity
'
'
stroke
-
width
'
'
text
-
anchor
'
'
text
-
decoration
'
'
text
-
rendering
'
'
underline
-
position
'
'
underline
-
thickness
'
'
unicode
-
bidi
'
'
unicode
-
range
'
'
units
-
per
-
em
'
'
v
-
alphabetic
'
'
v
-
hanging
'
'
v
-
ideographic
'
'
v
-
mathematical
'
'
vector
-
effect
'
'
vert
-
adv
-
y
'
'
vert
-
origin
-
x
'
'
vert
-
origin
-
y
'
'
word
-
spacing
'
'
writing
-
mode
'
'
x
-
height
'
'
xlink
:
actuate
'
'
xlink
:
arcrole
'
'
xlink
:
href
'
'
xlink
:
role
'
'
xlink
:
show
'
'
xlink
:
title
'
'
xlink
:
type
'
'
xml
:
base
'
'
xmlns
:
xlink
'
'
xml
:
lang
'
'
xml
:
space
'
]
;
var
SVGDOMPropertyConfig
=
{
Properties
:
{
autoReverse
:
HAS_STRING_BOOLEAN_VALUE
1
externalResourcesRequired
:
HAS_STRING_BOOLEAN_VALUE
1
preserveAlpha
:
HAS_STRING_BOOLEAN_VALUE
1
}
DOMAttributeNames
:
{
autoReverse
:
'
autoReverse
'
externalResourcesRequired
:
'
externalResourcesRequired
'
preserveAlpha
:
'
preserveAlpha
'
}
DOMAttributeNamespaces
:
{
xlinkActuate
:
NS
.
xlink
xlinkArcrole
:
NS
.
xlink
xlinkHref
:
NS
.
xlink
xlinkRole
:
NS
.
xlink
xlinkShow
:
NS
.
xlink
xlinkTitle
:
NS
.
xlink
xlinkType
:
NS
.
xlink
xmlBase
:
NS
.
xml
xmlLang
:
NS
.
xml
xmlSpace
:
NS
.
xml
}
}
;
var
CAMELIZE
=
/
[
\
-
\
:
]
(
[
a
-
z
]
)
/
g
;
var
capitalize
=
function
(
token
)
{
return
token
[
1
]
.
toUpperCase
(
)
;
}
;
ATTRS
.
forEach
(
function
(
original
)
{
var
reactName
=
original
.
replace
(
CAMELIZE
capitalize
)
;
SVGDOMPropertyConfig
.
Properties
[
reactName
]
=
0
;
SVGDOMPropertyConfig
.
DOMAttributeNames
[
reactName
]
=
original
;
}
)
;
injection
.
injectDOMPropertyConfig
(
HTMLDOMPropertyConfig
)
;
injection
.
injectDOMPropertyConfig
(
SVGDOMPropertyConfig
)
;
var
ReactErrorUtils
=
{
_caughtError
:
null
_hasCaughtError
:
false
_rethrowError
:
null
_hasRethrowError
:
false
injection
:
{
injectErrorUtils
:
function
(
injectedErrorUtils
)
{
!
(
typeof
injectedErrorUtils
.
invokeGuardedCallback
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
197
'
)
:
void
0
;
invokeGuardedCallback
=
injectedErrorUtils
.
invokeGuardedCallback
;
}
}
invokeGuardedCallback
:
function
(
name
func
context
a
b
c
d
e
f
)
{
invokeGuardedCallback
.
apply
(
ReactErrorUtils
arguments
)
;
}
invokeGuardedCallbackAndCatchFirstError
:
function
(
name
func
context
a
b
c
d
e
f
)
{
ReactErrorUtils
.
invokeGuardedCallback
.
apply
(
this
arguments
)
;
if
(
ReactErrorUtils
.
hasCaughtError
(
)
)
{
var
error
=
ReactErrorUtils
.
clearCaughtError
(
)
;
if
(
!
ReactErrorUtils
.
_hasRethrowError
)
{
ReactErrorUtils
.
_hasRethrowError
=
true
;
ReactErrorUtils
.
_rethrowError
=
error
;
}
}
}
rethrowCaughtError
:
function
(
)
{
return
rethrowCaughtError
.
apply
(
ReactErrorUtils
arguments
)
;
}
hasCaughtError
:
function
(
)
{
return
ReactErrorUtils
.
_hasCaughtError
;
}
clearCaughtError
:
function
(
)
{
if
(
ReactErrorUtils
.
_hasCaughtError
)
{
var
error
=
ReactErrorUtils
.
_caughtError
;
ReactErrorUtils
.
_caughtError
=
null
;
ReactErrorUtils
.
_hasCaughtError
=
false
;
return
error
;
}
else
{
reactProdInvariant
(
'
198
'
)
;
}
}
}
;
var
invokeGuardedCallback
=
function
(
name
func
context
a
b
c
d
e
f
)
{
ReactErrorUtils
.
_hasCaughtError
=
false
;
ReactErrorUtils
.
_caughtError
=
null
;
var
funcArgs
=
Array
.
prototype
.
slice
.
call
(
arguments
3
)
;
try
{
func
.
apply
(
context
funcArgs
)
;
}
catch
(
error
)
{
ReactErrorUtils
.
_caughtError
=
error
;
ReactErrorUtils
.
_hasCaughtError
=
true
;
}
}
;
var
rethrowCaughtError
=
function
(
)
{
if
(
ReactErrorUtils
.
_hasRethrowError
)
{
var
error
=
ReactErrorUtils
.
_rethrowError
;
ReactErrorUtils
.
_rethrowError
=
null
;
ReactErrorUtils
.
_hasRethrowError
=
false
;
throw
error
;
}
}
;
var
eventPluginOrder
=
null
;
var
namesToPlugins
=
{
}
;
function
recomputePluginOrdering
(
)
{
if
(
!
eventPluginOrder
)
{
return
;
}
for
(
var
pluginName
in
namesToPlugins
)
{
var
pluginModule
=
namesToPlugins
[
pluginName
]
;
var
pluginIndex
=
eventPluginOrder
.
indexOf
(
pluginName
)
;
!
(
pluginIndex
>
-
1
)
?
reactProdInvariant
(
'
96
'
pluginName
)
:
void
0
;
if
(
plugins
[
pluginIndex
]
)
{
continue
;
}
!
pluginModule
.
extractEvents
?
reactProdInvariant
(
'
97
'
pluginName
)
:
void
0
;
plugins
[
pluginIndex
]
=
pluginModule
;
var
publishedEvents
=
pluginModule
.
eventTypes
;
for
(
var
eventName
in
publishedEvents
)
{
!
publishEventForPlugin
(
publishedEvents
[
eventName
]
pluginModule
eventName
)
?
reactProdInvariant
(
'
98
'
eventName
pluginName
)
:
void
0
;
}
}
}
function
publishEventForPlugin
(
dispatchConfig
pluginModule
eventName
)
{
!
!
eventNameDispatchConfigs
.
hasOwnProperty
(
eventName
)
?
reactProdInvariant
(
'
99
'
eventName
)
:
void
0
;
eventNameDispatchConfigs
[
eventName
]
=
dispatchConfig
;
var
phasedRegistrationNames
=
dispatchConfig
.
phasedRegistrationNames
;
if
(
phasedRegistrationNames
)
{
for
(
var
phaseName
in
phasedRegistrationNames
)
{
if
(
phasedRegistrationNames
.
hasOwnProperty
(
phaseName
)
)
{
var
phasedRegistrationName
=
phasedRegistrationNames
[
phaseName
]
;
publishRegistrationName
(
phasedRegistrationName
pluginModule
eventName
)
;
}
}
return
true
;
}
else
if
(
dispatchConfig
.
registrationName
)
{
publishRegistrationName
(
dispatchConfig
.
registrationName
pluginModule
eventName
)
;
return
true
;
}
return
false
;
}
function
publishRegistrationName
(
registrationName
pluginModule
eventName
)
{
!
!
registrationNameModules
[
registrationName
]
?
reactProdInvariant
(
'
100
'
registrationName
)
:
void
0
;
registrationNameModules
[
registrationName
]
=
pluginModule
;
registrationNameDependencies
[
registrationName
]
=
pluginModule
.
eventTypes
[
eventName
]
.
dependencies
;
}
var
plugins
=
[
]
;
var
eventNameDispatchConfigs
=
{
}
;
var
registrationNameModules
=
{
}
;
var
registrationNameDependencies
=
{
}
;
var
possibleRegistrationNames
=
null
;
function
injectEventPluginOrder
(
injectedEventPluginOrder
)
{
!
!
eventPluginOrder
?
reactProdInvariant
(
'
101
'
)
:
void
0
;
eventPluginOrder
=
Array
.
prototype
.
slice
.
call
(
injectedEventPluginOrder
)
;
recomputePluginOrdering
(
)
;
}
function
injectEventPluginsByName
(
injectedNamesToPlugins
)
{
var
isOrderingDirty
=
false
;
for
(
var
pluginName
in
injectedNamesToPlugins
)
{
if
(
!
injectedNamesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
continue
;
}
var
pluginModule
=
injectedNamesToPlugins
[
pluginName
]
;
if
(
!
namesToPlugins
.
hasOwnProperty
(
pluginName
)
|
|
namesToPlugins
[
pluginName
]
!
=
=
pluginModule
)
{
!
!
namesToPlugins
[
pluginName
]
?
reactProdInvariant
(
'
102
'
pluginName
)
:
void
0
;
namesToPlugins
[
pluginName
]
=
pluginModule
;
isOrderingDirty
=
true
;
}
}
if
(
isOrderingDirty
)
{
recomputePluginOrdering
(
)
;
}
}
var
EventPluginRegistry
=
Object
.
freeze
(
{
plugins
:
plugins
eventNameDispatchConfigs
:
eventNameDispatchConfigs
registrationNameModules
:
registrationNameModules
registrationNameDependencies
:
registrationNameDependencies
possibleRegistrationNames
:
possibleRegistrationNames
injectEventPluginOrder
:
injectEventPluginOrder
injectEventPluginsByName
:
injectEventPluginsByName
}
)
;
function
makeEmptyFunction
(
arg
)
{
return
function
(
)
{
return
arg
;
}
;
}
var
emptyFunction
=
function
emptyFunction
(
)
{
}
;
emptyFunction
.
thatReturns
=
makeEmptyFunction
;
emptyFunction
.
thatReturnsFalse
=
makeEmptyFunction
(
false
)
;
emptyFunction
.
thatReturnsTrue
=
makeEmptyFunction
(
true
)
;
emptyFunction
.
thatReturnsNull
=
makeEmptyFunction
(
null
)
;
emptyFunction
.
thatReturnsThis
=
function
(
)
{
return
this
;
}
;
emptyFunction
.
thatReturnsArgument
=
function
(
arg
)
{
return
arg
;
}
;
var
emptyFunction_1
=
emptyFunction
;
var
getFiberCurrentPropsFromNode
=
null
;
var
getInstanceFromNode
=
null
;
var
getNodeFromInstance
=
null
;
var
injection
2
=
{
injectComponentTree
:
function
(
Injected
)
{
getFiberCurrentPropsFromNode
=
Injected
.
getFiberCurrentPropsFromNode
;
getInstanceFromNode
=
Injected
.
getInstanceFromNode
;
getNodeFromInstance
=
Injected
.
getNodeFromInstance
;
}
}
;
function
executeDispatch
(
event
simulated
listener
inst
)
{
var
type
=
event
.
type
|
|
'
unknown
-
event
'
;
event
.
currentTarget
=
getNodeFromInstance
(
inst
)
;
ReactErrorUtils
.
invokeGuardedCallbackAndCatchFirstError
(
type
listener
undefined
event
)
;
event
.
currentTarget
=
null
;
}
function
executeDispatchesInOrder
(
event
simulated
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchInstances
=
event
.
_dispatchInstances
;
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
executeDispatch
(
event
simulated
dispatchListeners
[
i
]
dispatchInstances
[
i
]
)
;
}
}
else
if
(
dispatchListeners
)
{
executeDispatch
(
event
simulated
dispatchListeners
dispatchInstances
)
;
}
event
.
_dispatchListeners
=
null
;
event
.
_dispatchInstances
=
null
;
}
function
accumulateInto
(
current
next
)
{
!
(
next
!
=
null
)
?
reactProdInvariant
(
'
30
'
)
:
void
0
;
if
(
current
=
=
null
)
{
return
next
;
}
if
(
Array
.
isArray
(
current
)
)
{
if
(
Array
.
isArray
(
next
)
)
{
current
.
push
.
apply
(
current
next
)
;
return
current
;
}
current
.
push
(
next
)
;
return
current
;
}
if
(
Array
.
isArray
(
next
)
)
{
return
[
current
]
.
concat
(
next
)
;
}
return
[
current
next
]
;
}
function
forEachAccumulated
(
arr
cb
scope
)
{
if
(
Array
.
isArray
(
arr
)
)
{
arr
.
forEach
(
cb
scope
)
;
}
else
if
(
arr
)
{
cb
.
call
(
scope
arr
)
;
}
}
var
eventQueue
=
null
;
var
executeDispatchesAndRelease
=
function
(
event
simulated
)
{
if
(
event
)
{
executeDispatchesInOrder
(
event
simulated
)
;
if
(
!
event
.
isPersistent
(
)
)
{
event
.
constructor
.
release
(
event
)
;
}
}
}
;
var
executeDispatchesAndReleaseSimulated
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
true
)
;
}
;
var
executeDispatchesAndReleaseTopLevel
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
false
)
;
}
;
function
isInteractive
(
tag
)
{
return
tag
=
=
=
'
button
'
|
|
tag
=
=
=
'
input
'
|
|
tag
=
=
=
'
select
'
|
|
tag
=
=
=
'
textarea
'
;
}
function
shouldPreventMouseEvent
(
name
type
props
)
{
switch
(
name
)
{
case
'
onClick
'
:
case
'
onClickCapture
'
:
case
'
onDoubleClick
'
:
case
'
onDoubleClickCapture
'
:
case
'
onMouseDown
'
:
case
'
onMouseDownCapture
'
:
case
'
onMouseMove
'
:
case
'
onMouseMoveCapture
'
:
case
'
onMouseUp
'
:
case
'
onMouseUpCapture
'
:
return
!
!
(
props
.
disabled
&
&
isInteractive
(
type
)
)
;
default
:
return
false
;
}
}
var
injection
1
=
{
injectEventPluginOrder
:
injectEventPluginOrder
injectEventPluginsByName
:
injectEventPluginsByName
}
;
function
getListener
(
inst
registrationName
)
{
var
listener
;
var
stateNode
=
inst
.
stateNode
;
if
(
!
stateNode
)
{
return
null
;
}
var
props
=
getFiberCurrentPropsFromNode
(
stateNode
)
;
if
(
!
props
)
{
return
null
;
}
listener
=
props
[
registrationName
]
;
if
(
shouldPreventMouseEvent
(
registrationName
inst
.
type
props
)
)
{
return
null
;
}
!
(
!
listener
|
|
typeof
listener
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
231
'
registrationName
typeof
listener
)
:
void
0
;
return
listener
;
}
function
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
events
;
for
(
var
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
var
possiblePlugin
=
plugins
[
i
]
;
if
(
possiblePlugin
)
{
var
extractedEvents
=
possiblePlugin
.
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
extractedEvents
)
{
events
=
accumulateInto
(
events
extractedEvents
)
;
}
}
}
return
events
;
}
function
enqueueEvents
(
events
)
{
if
(
events
)
{
eventQueue
=
accumulateInto
(
eventQueue
events
)
;
}
}
function
processEventQueue
(
simulated
)
{
var
processingEventQueue
=
eventQueue
;
eventQueue
=
null
;
if
(
!
processingEventQueue
)
{
return
;
}
if
(
simulated
)
{
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseSimulated
)
;
}
else
{
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseTopLevel
)
;
}
!
!
eventQueue
?
reactProdInvariant
(
'
95
'
)
:
void
0
;
ReactErrorUtils
.
rethrowCaughtError
(
)
;
}
var
EventPluginHub
=
Object
.
freeze
(
{
injection
:
injection
1
getListener
:
getListener
extractEvents
:
extractEvents
enqueueEvents
:
enqueueEvents
processEventQueue
:
processEventQueue
}
)
;
var
IndeterminateComponent
=
0
;
var
FunctionalComponent
=
1
;
var
ClassComponent
=
2
;
var
HostRoot
=
3
;
var
HostPortal
=
4
;
var
HostComponent
=
5
;
var
HostText
=
6
;
var
CallComponent
=
7
;
var
CallHandlerPhase
=
8
;
var
ReturnComponent
=
9
;
var
Fragment
=
10
;
var
randomKey
=
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
var
internalInstanceKey
=
'
__reactInternalInstance
'
+
randomKey
;
var
internalEventHandlersKey
=
'
__reactEventHandlers
'
+
randomKey
;
function
precacheFiberNode
1
(
hostInst
node
)
{
node
[
internalInstanceKey
]
=
hostInst
;
}
function
getClosestInstanceFromNode
(
node
)
{
if
(
node
[
internalInstanceKey
]
)
{
return
node
[
internalInstanceKey
]
;
}
var
parents
=
[
]
;
while
(
!
node
[
internalInstanceKey
]
)
{
parents
.
push
(
node
)
;
if
(
node
.
parentNode
)
{
node
=
node
.
parentNode
;
}
else
{
return
null
;
}
}
var
closest
=
void
0
;
var
inst
=
node
[
internalInstanceKey
]
;
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
;
}
for
(
;
node
&
&
(
inst
=
node
[
internalInstanceKey
]
)
;
node
=
parents
.
pop
(
)
)
{
closest
=
inst
;
}
return
closest
;
}
function
getInstanceFromNode
1
(
node
)
{
var
inst
=
node
[
internalInstanceKey
]
;
if
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
;
}
else
{
return
null
;
}
}
return
null
;
}
function
getNodeFromInstance
1
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
.
stateNode
;
}
reactProdInvariant
(
'
33
'
)
;
}
function
getFiberCurrentPropsFromNode
1
(
node
)
{
return
node
[
internalEventHandlersKey
]
|
|
null
;
}
function
updateFiberProps
1
(
node
props
)
{
node
[
internalEventHandlersKey
]
=
props
;
}
var
ReactDOMComponentTree
=
Object
.
freeze
(
{
precacheFiberNode
:
precacheFiberNode
1
getClosestInstanceFromNode
:
getClosestInstanceFromNode
getInstanceFromNode
:
getInstanceFromNode
1
getNodeFromInstance
:
getNodeFromInstance
1
getFiberCurrentPropsFromNode
:
getFiberCurrentPropsFromNode
1
updateFiberProps
:
updateFiberProps
1
}
)
;
function
getParent
(
inst
)
{
do
{
inst
=
inst
[
'
return
'
]
;
}
while
(
inst
&
&
inst
.
tag
!
=
=
HostComponent
)
;
if
(
inst
)
{
return
inst
;
}
return
null
;
}
function
getLowestCommonAncestor
(
instA
instB
)
{
var
depthA
=
0
;
for
(
var
tempA
=
instA
;
tempA
;
tempA
=
getParent
(
tempA
)
)
{
depthA
+
+
;
}
var
depthB
=
0
;
for
(
var
tempB
=
instB
;
tempB
;
tempB
=
getParent
(
tempB
)
)
{
depthB
+
+
;
}
while
(
depthA
-
depthB
>
0
)
{
instA
=
getParent
(
instA
)
;
depthA
-
-
;
}
while
(
depthB
-
depthA
>
0
)
{
instB
=
getParent
(
instB
)
;
depthB
-
-
;
}
var
depth
=
depthA
;
while
(
depth
-
-
)
{
if
(
instA
=
=
=
instB
|
|
instA
=
=
=
instB
.
alternate
)
{
return
instA
;
}
instA
=
getParent
(
instA
)
;
instB
=
getParent
(
instB
)
;
}
return
null
;
}
function
getParentInstance
(
inst
)
{
return
getParent
(
inst
)
;
}
function
traverseTwoPhase
(
inst
fn
arg
)
{
var
path
=
[
]
;
while
(
inst
)
{
path
.
push
(
inst
)
;
inst
=
getParent
(
inst
)
;
}
var
i
;
for
(
i
=
path
.
length
;
i
-
-
>
0
;
)
{
fn
(
path
[
i
]
'
captured
'
arg
)
;
}
for
(
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
fn
(
path
[
i
]
'
bubbled
'
arg
)
;
}
}
function
traverseEnterLeave
(
from
to
fn
argFrom
argTo
)
{
var
common
=
from
&
&
to
?
getLowestCommonAncestor
(
from
to
)
:
null
;
var
pathFrom
=
[
]
;
while
(
true
)
{
if
(
!
from
)
{
break
;
}
if
(
from
=
=
=
common
)
{
break
;
}
var
alternate
=
from
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
=
=
=
common
)
{
break
;
}
pathFrom
.
push
(
from
)
;
from
=
getParent
(
from
)
;
}
var
pathTo
=
[
]
;
while
(
true
)
{
if
(
!
to
)
{
break
;
}
if
(
to
=
=
=
common
)
{
break
;
}
var
_alternate
=
to
.
alternate
;
if
(
_alternate
!
=
=
null
&
&
_alternate
=
=
=
common
)
{
break
;
}
pathTo
.
push
(
to
)
;
to
=
getParent
(
to
)
;
}
for
(
var
i
=
0
;
i
<
pathFrom
.
length
;
i
+
+
)
{
fn
(
pathFrom
[
i
]
'
bubbled
'
argFrom
)
;
}
for
(
var
_i
=
pathTo
.
length
;
_i
-
-
>
0
;
)
{
fn
(
pathTo
[
_i
]
'
captured
'
argTo
)
;
}
}
function
listenerAtPhase
(
inst
event
propagationPhase
)
{
var
registrationName
=
event
.
dispatchConfig
.
phasedRegistrationNames
[
propagationPhase
]
;
return
getListener
(
inst
registrationName
)
;
}
function
accumulateDirectionalDispatches
(
inst
phase
event
)
{
var
listener
=
listenerAtPhase
(
inst
event
phase
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
function
accumulateTwoPhaseDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
traverseTwoPhase
(
event
.
_targetInst
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateTwoPhaseDispatchesSingleSkipTarget
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
var
targetInst
=
event
.
_targetInst
;
var
parentInst
=
targetInst
?
getParentInstance
(
targetInst
)
:
null
;
traverseTwoPhase
(
parentInst
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateDispatches
(
inst
ignoredDirection
event
)
{
if
(
inst
&
&
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
var
registrationName
=
event
.
dispatchConfig
.
registrationName
;
var
listener
=
getListener
(
inst
registrationName
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
}
function
accumulateDirectDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
accumulateDispatches
(
event
.
_targetInst
null
event
)
;
}
}
function
accumulateTwoPhaseDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingle
)
;
}
function
accumulateTwoPhaseDispatchesSkipTarget
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingleSkipTarget
)
;
}
function
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
{
traverseEnterLeave
(
from
to
accumulateDispatches
leave
enter
)
;
}
function
accumulateDirectDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateDirectDispatchesSingle
)
;
}
var
EventPropagators
=
Object
.
freeze
(
{
accumulateTwoPhaseDispatches
:
accumulateTwoPhaseDispatches
accumulateTwoPhaseDispatchesSkipTarget
:
accumulateTwoPhaseDispatchesSkipTarget
accumulateEnterLeaveDispatches
:
accumulateEnterLeaveDispatches
accumulateDirectDispatches
:
accumulateDirectDispatches
}
)
;
var
canUseDOM
=
!
!
(
typeof
window
!
=
=
'
undefined
'
&
&
window
.
document
&
&
window
.
document
.
createElement
)
;
var
ExecutionEnvironment
=
{
canUseDOM
:
canUseDOM
canUseWorkers
:
typeof
Worker
!
=
=
'
undefined
'
canUseEventListeners
:
canUseDOM
&
&
!
!
(
window
.
addEventListener
|
|
window
.
attachEvent
)
canUseViewport
:
canUseDOM
&
&
!
!
window
.
screen
isInWorker
:
!
canUseDOM
}
;
var
ExecutionEnvironment_1
=
ExecutionEnvironment
;
var
contentKey
=
null
;
function
getTextContentAccessor
(
)
{
if
(
!
contentKey
&
&
ExecutionEnvironment_1
.
canUseDOM
)
{
contentKey
=
'
textContent
'
in
document
.
documentElement
?
'
textContent
'
:
'
innerText
'
;
}
return
contentKey
;
}
var
compositionState
=
{
_root
:
null
_startText
:
null
_fallbackText
:
null
}
;
function
initialize
(
nativeEventTarget
)
{
compositionState
.
_root
=
nativeEventTarget
;
compositionState
.
_startText
=
getText
(
)
;
return
true
;
}
function
reset
(
)
{
compositionState
.
_root
=
null
;
compositionState
.
_startText
=
null
;
compositionState
.
_fallbackText
=
null
;
}
function
getData
(
)
{
if
(
compositionState
.
_fallbackText
)
{
return
compositionState
.
_fallbackText
;
}
var
start
;
var
startValue
=
compositionState
.
_startText
;
var
startLength
=
startValue
.
length
;
var
end
;
var
endValue
=
getText
(
)
;
var
endLength
=
endValue
.
length
;
for
(
start
=
0
;
start
<
startLength
;
start
+
+
)
{
if
(
startValue
[
start
]
!
=
=
endValue
[
start
]
)
{
break
;
}
}
var
minEnd
=
startLength
-
start
;
for
(
end
=
1
;
end
<
=
minEnd
;
end
+
+
)
{
if
(
startValue
[
startLength
-
end
]
!
=
=
endValue
[
endLength
-
end
]
)
{
break
;
}
}
var
sliceTail
=
end
>
1
?
1
-
end
:
undefined
;
compositionState
.
_fallbackText
=
endValue
.
slice
(
start
sliceTail
)
;
return
compositionState
.
_fallbackText
;
}
function
getText
(
)
{
if
(
'
value
'
in
compositionState
.
_root
)
{
return
compositionState
.
_root
.
value
;
}
return
compositionState
.
_root
[
getTextContentAccessor
(
)
]
;
}
var
ReactInternals
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_assign
=
ReactInternals
.
assign
;
var
EVENT_POOL_SIZE
=
10
;
var
shouldBeReleasedProperties
=
[
'
dispatchConfig
'
'
_targetInst
'
'
nativeEvent
'
'
isDefaultPrevented
'
'
isPropagationStopped
'
'
_dispatchListeners
'
'
_dispatchInstances
'
]
;
var
EventInterface
=
{
type
:
null
target
:
null
currentTarget
:
emptyFunction_1
.
thatReturnsNull
eventPhase
:
null
bubbles
:
null
cancelable
:
null
timeStamp
:
function
(
event
)
{
return
event
.
timeStamp
|
|
Date
.
now
(
)
;
}
defaultPrevented
:
null
isTrusted
:
null
}
;
function
SyntheticEvent
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
{
this
.
dispatchConfig
=
dispatchConfig
;
this
.
_targetInst
=
targetInst
;
this
.
nativeEvent
=
nativeEvent
;
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
if
(
!
Interface
.
hasOwnProperty
(
propName
)
)
{
continue
;
}
var
normalize
=
Interface
[
propName
]
;
if
(
normalize
)
{
this
[
propName
]
=
normalize
(
nativeEvent
)
;
}
else
{
if
(
propName
=
=
=
'
target
'
)
{
this
.
target
=
nativeEventTarget
;
}
else
{
this
[
propName
]
=
nativeEvent
[
propName
]
;
}
}
}
var
defaultPrevented
=
nativeEvent
.
defaultPrevented
!
=
null
?
nativeEvent
.
defaultPrevented
:
nativeEvent
.
returnValue
=
=
=
false
;
if
(
defaultPrevented
)
{
this
.
isDefaultPrevented
=
emptyFunction_1
.
thatReturnsTrue
;
}
else
{
this
.
isDefaultPrevented
=
emptyFunction_1
.
thatReturnsFalse
;
}
this
.
isPropagationStopped
=
emptyFunction_1
.
thatReturnsFalse
;
return
this
;
}
_assign
(
SyntheticEvent
.
prototype
{
preventDefault
:
function
(
)
{
this
.
defaultPrevented
=
true
;
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
preventDefault
)
{
event
.
preventDefault
(
)
;
}
else
if
(
typeof
event
.
returnValue
!
=
=
'
unknown
'
)
{
event
.
returnValue
=
false
;
}
this
.
isDefaultPrevented
=
emptyFunction_1
.
thatReturnsTrue
;
}
stopPropagation
:
function
(
)
{
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
stopPropagation
)
{
event
.
stopPropagation
(
)
;
}
else
if
(
typeof
event
.
cancelBubble
!
=
=
'
unknown
'
)
{
event
.
cancelBubble
=
true
;
}
this
.
isPropagationStopped
=
emptyFunction_1
.
thatReturnsTrue
;
}
persist
:
function
(
)
{
this
.
isPersistent
=
emptyFunction_1
.
thatReturnsTrue
;
}
isPersistent
:
emptyFunction_1
.
thatReturnsFalse
destructor
:
function
(
)
{
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
{
this
[
propName
]
=
null
;
}
}
for
(
var
i
=
0
;
i
<
shouldBeReleasedProperties
.
length
;
i
+
+
)
{
this
[
shouldBeReleasedProperties
[
i
]
]
=
null
;
}
}
}
)
;
SyntheticEvent
.
Interface
=
EventInterface
;
SyntheticEvent
.
augmentClass
=
function
(
Class
Interface
)
{
var
Super
=
this
;
var
E
=
function
(
)
{
}
;
E
.
prototype
=
Super
.
prototype
;
var
prototype
=
new
E
(
)
;
_assign
(
prototype
Class
.
prototype
)
;
Class
.
prototype
=
prototype
;
Class
.
prototype
.
constructor
=
Class
;
Class
.
Interface
=
_assign
(
{
}
Super
.
Interface
Interface
)
;
Class
.
augmentClass
=
Super
.
augmentClass
;
addEventPoolingTo
(
Class
)
;
}
;
addEventPoolingTo
(
SyntheticEvent
)
;
function
getPooledEvent
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
{
var
EventConstructor
=
this
;
if
(
EventConstructor
.
eventPool
.
length
)
{
var
instance
=
EventConstructor
.
eventPool
.
pop
(
)
;
EventConstructor
.
call
(
instance
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
return
instance
;
}
return
new
EventConstructor
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
}
function
releasePooledEvent
(
event
)
{
var
EventConstructor
=
this
;
!
(
event
instanceof
EventConstructor
)
?
reactProdInvariant
(
'
223
'
)
:
void
0
;
event
.
destructor
(
)
;
if
(
EventConstructor
.
eventPool
.
length
<
EVENT_POOL_SIZE
)
{
EventConstructor
.
eventPool
.
push
(
event
)
;
}
}
function
addEventPoolingTo
(
EventConstructor
)
{
EventConstructor
.
eventPool
=
[
]
;
EventConstructor
.
getPooled
=
getPooledEvent
;
EventConstructor
.
release
=
releasePooledEvent
;
}
var
CompositionEventInterface
=
{
data
:
null
}
;
function
SyntheticCompositionEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticCompositionEvent
CompositionEventInterface
)
;
var
InputEventInterface
=
{
data
:
null
}
;
function
SyntheticInputEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticInputEvent
InputEventInterface
)
;
var
END_KEYCODES
=
[
9
13
27
32
]
;
var
START_KEYCODE
=
229
;
var
canUseCompositionEvent
=
ExecutionEnvironment_1
.
canUseDOM
&
&
'
CompositionEvent
'
in
window
;
var
documentMode
=
null
;
if
(
ExecutionEnvironment_1
.
canUseDOM
&
&
'
documentMode
'
in
document
)
{
documentMode
=
document
.
documentMode
;
}
var
canUseTextInputEvent
=
ExecutionEnvironment_1
.
canUseDOM
&
&
'
TextEvent
'
in
window
&
&
!
documentMode
&
&
!
isPresto
(
)
;
var
useFallbackCompositionData
=
ExecutionEnvironment_1
.
canUseDOM
&
&
(
!
canUseCompositionEvent
|
|
documentMode
&
&
documentMode
>
8
&
&
documentMode
<
=
11
)
;
function
isPresto
(
)
{
var
opera
=
window
.
opera
;
return
typeof
opera
=
=
=
'
object
'
&
&
typeof
opera
.
version
=
=
=
'
function
'
&
&
parseInt
(
opera
.
version
(
)
10
)
<
=
12
;
}
var
SPACEBAR_CODE
=
32
;
var
SPACEBAR_CHAR
=
String
.
fromCharCode
(
SPACEBAR_CODE
)
;
var
eventTypes
=
{
beforeInput
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onBeforeInput
'
captured
:
'
onBeforeInputCapture
'
}
dependencies
:
[
'
topCompositionEnd
'
'
topKeyPress
'
'
topTextInput
'
'
topPaste
'
]
}
compositionEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionEnd
'
captured
:
'
onCompositionEndCapture
'
}
dependencies
:
[
'
topBlur
'
'
topCompositionEnd
'
'
topKeyDown
'
'
topKeyPress
'
'
topKeyUp
'
'
topMouseDown
'
]
}
compositionStart
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionStart
'
captured
:
'
onCompositionStartCapture
'
}
dependencies
:
[
'
topBlur
'
'
topCompositionStart
'
'
topKeyDown
'
'
topKeyPress
'
'
topKeyUp
'
'
topMouseDown
'
]
}
compositionUpdate
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionUpdate
'
captured
:
'
onCompositionUpdateCapture
'
}
dependencies
:
[
'
topBlur
'
'
topCompositionUpdate
'
'
topKeyDown
'
'
topKeyPress
'
'
topKeyUp
'
'
topMouseDown
'
]
}
}
;
var
hasSpaceKeypress
=
false
;
function
isKeypressCommand
(
nativeEvent
)
{
return
(
nativeEvent
.
ctrlKey
|
|
nativeEvent
.
altKey
|
|
nativeEvent
.
metaKey
)
&
&
!
(
nativeEvent
.
ctrlKey
&
&
nativeEvent
.
altKey
)
;
}
function
getCompositionEventType
(
topLevelType
)
{
switch
(
topLevelType
)
{
case
'
topCompositionStart
'
:
return
eventTypes
.
compositionStart
;
case
'
topCompositionEnd
'
:
return
eventTypes
.
compositionEnd
;
case
'
topCompositionUpdate
'
:
return
eventTypes
.
compositionUpdate
;
}
}
function
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
{
return
topLevelType
=
=
=
'
topKeyDown
'
&
&
nativeEvent
.
keyCode
=
=
=
START_KEYCODE
;
}
function
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
'
topKeyUp
'
:
return
END_KEYCODES
.
indexOf
(
nativeEvent
.
keyCode
)
!
=
=
-
1
;
case
'
topKeyDown
'
:
return
nativeEvent
.
keyCode
!
=
=
START_KEYCODE
;
case
'
topKeyPress
'
:
case
'
topMouseDown
'
:
case
'
topBlur
'
:
return
true
;
default
:
return
false
;
}
}
function
getDataFromCustomEvent
(
nativeEvent
)
{
var
detail
=
nativeEvent
.
detail
;
if
(
typeof
detail
=
=
=
'
object
'
&
&
'
data
'
in
detail
)
{
return
detail
.
data
;
}
return
null
;
}
var
isComposing
=
false
;
function
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
eventType
;
var
fallbackData
;
if
(
canUseCompositionEvent
)
{
eventType
=
getCompositionEventType
(
topLevelType
)
;
}
else
if
(
!
isComposing
)
{
if
(
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionStart
;
}
}
else
if
(
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionEnd
;
}
if
(
!
eventType
)
{
return
null
;
}
if
(
useFallbackCompositionData
)
{
if
(
!
isComposing
&
&
eventType
=
=
=
eventTypes
.
compositionStart
)
{
isComposing
=
initialize
(
nativeEventTarget
)
;
}
else
if
(
eventType
=
=
=
eventTypes
.
compositionEnd
)
{
if
(
isComposing
)
{
fallbackData
=
getData
(
)
;
}
}
}
var
event
=
SyntheticCompositionEvent
.
getPooled
(
eventType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
fallbackData
)
{
event
.
data
=
fallbackData
;
}
else
{
var
customData
=
getDataFromCustomEvent
(
nativeEvent
)
;
if
(
customData
!
=
=
null
)
{
event
.
data
=
customData
;
}
}
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
function
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
'
topCompositionEnd
'
:
return
getDataFromCustomEvent
(
nativeEvent
)
;
case
'
topKeyPress
'
:
var
which
=
nativeEvent
.
which
;
if
(
which
!
=
=
SPACEBAR_CODE
)
{
return
null
;
}
hasSpaceKeypress
=
true
;
return
SPACEBAR_CHAR
;
case
'
topTextInput
'
:
var
chars
=
nativeEvent
.
data
;
if
(
chars
=
=
=
SPACEBAR_CHAR
&
&
hasSpaceKeypress
)
{
return
null
;
}
return
chars
;
default
:
return
null
;
}
}
function
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
{
if
(
isComposing
)
{
if
(
topLevelType
=
=
=
'
topCompositionEnd
'
|
|
!
canUseCompositionEvent
&
&
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
var
chars
=
getData
(
)
;
reset
(
)
;
isComposing
=
false
;
return
chars
;
}
return
null
;
}
switch
(
topLevelType
)
{
case
'
topPaste
'
:
return
null
;
case
'
topKeyPress
'
:
if
(
!
isKeypressCommand
(
nativeEvent
)
)
{
if
(
nativeEvent
.
char
&
&
nativeEvent
.
char
.
length
>
1
)
{
return
nativeEvent
.
char
;
}
else
if
(
nativeEvent
.
which
)
{
return
String
.
fromCharCode
(
nativeEvent
.
which
)
;
}
}
return
null
;
case
'
topCompositionEnd
'
:
return
useFallbackCompositionData
?
null
:
nativeEvent
.
data
;
default
:
return
null
;
}
}
function
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
chars
;
if
(
canUseTextInputEvent
)
{
chars
=
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
else
{
chars
=
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
if
(
!
chars
)
{
return
null
;
}
var
event
=
SyntheticInputEvent
.
getPooled
(
eventTypes
.
beforeInput
targetInst
nativeEvent
nativeEventTarget
)
;
event
.
data
=
chars
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
BeforeInputEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
return
[
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
]
;
}
}
;
var
fiberHostComponent
=
null
;
var
ReactControlledComponentInjection
=
{
injectFiberControlledHostComponent
:
function
(
hostComponentImpl
)
{
fiberHostComponent
=
hostComponentImpl
;
}
}
;
var
restoreTarget
=
null
;
var
restoreQueue
=
null
;
function
restoreStateOfTarget
(
target
)
{
var
internalInstance
=
getInstanceFromNode
(
target
)
;
if
(
!
internalInstance
)
{
return
;
}
!
(
fiberHostComponent
&
&
typeof
fiberHostComponent
.
restoreControlledState
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
194
'
)
:
void
0
;
var
props
=
getFiberCurrentPropsFromNode
(
internalInstance
.
stateNode
)
;
fiberHostComponent
.
restoreControlledState
(
internalInstance
.
stateNode
internalInstance
.
type
props
)
;
}
var
injection
3
=
ReactControlledComponentInjection
;
function
enqueueStateRestore
(
target
)
{
if
(
restoreTarget
)
{
if
(
restoreQueue
)
{
restoreQueue
.
push
(
target
)
;
}
else
{
restoreQueue
=
[
target
]
;
}
}
else
{
restoreTarget
=
target
;
}
}
function
restoreStateIfNeeded
(
)
{
if
(
!
restoreTarget
)
{
return
;
}
var
target
=
restoreTarget
;
var
queuedTargets
=
restoreQueue
;
restoreTarget
=
null
;
restoreQueue
=
null
;
restoreStateOfTarget
(
target
)
;
if
(
queuedTargets
)
{
for
(
var
i
=
0
;
i
<
queuedTargets
.
length
;
i
+
+
)
{
restoreStateOfTarget
(
queuedTargets
[
i
]
)
;
}
}
}
var
ReactControlledComponent
=
Object
.
freeze
(
{
injection
:
injection
3
enqueueStateRestore
:
enqueueStateRestore
restoreStateIfNeeded
:
restoreStateIfNeeded
}
)
;
var
fiberBatchedUpdates
=
function
(
fn
bookkeeping
)
{
return
fn
(
bookkeeping
)
;
}
;
var
isNestingBatched
=
false
;
function
batchedUpdates
(
fn
bookkeeping
)
{
if
(
isNestingBatched
)
{
return
fiberBatchedUpdates
(
fn
bookkeeping
)
;
}
isNestingBatched
=
true
;
try
{
return
fiberBatchedUpdates
(
fn
bookkeeping
)
;
}
finally
{
isNestingBatched
=
false
;
restoreStateIfNeeded
(
)
;
}
}
var
ReactGenericBatchingInjection
=
{
injectFiberBatchedUpdates
:
function
(
_batchedUpdates
)
{
fiberBatchedUpdates
=
_batchedUpdates
;
}
}
;
var
injection
4
=
ReactGenericBatchingInjection
;
var
supportedInputTypes
=
{
color
:
true
date
:
true
datetime
:
true
'
datetime
-
local
'
:
true
email
:
true
month
:
true
number
:
true
password
:
true
range
:
true
search
:
true
tel
:
true
text
:
true
time
:
true
url
:
true
week
:
true
}
;
function
isTextInputElement
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
if
(
nodeName
=
=
=
'
input
'
)
{
return
!
!
supportedInputTypes
[
elem
.
type
]
;
}
if
(
nodeName
=
=
=
'
textarea
'
)
{
return
true
;
}
return
false
;
}
var
ELEMENT_NODE
=
1
;
var
TEXT_NODE
=
3
;
var
COMMENT_NODE
=
8
;
var
DOCUMENT_NODE
=
9
;
var
DOCUMENT_FRAGMENT_NODE
=
11
;
function
getEventTarget
(
nativeEvent
)
{
var
target
=
nativeEvent
.
target
|
|
nativeEvent
.
srcElement
|
|
window
;
if
(
target
.
correspondingUseElement
)
{
target
=
target
.
correspondingUseElement
;
}
return
target
.
nodeType
=
=
=
TEXT_NODE
?
target
.
parentNode
:
target
;
}
var
useHasFeature
;
if
(
ExecutionEnvironment_1
.
canUseDOM
)
{
useHasFeature
=
document
.
implementation
&
&
document
.
implementation
.
hasFeature
&
&
document
.
implementation
.
hasFeature
(
'
'
'
'
)
!
=
=
true
;
}
function
isEventSupported
(
eventNameSuffix
capture
)
{
if
(
!
ExecutionEnvironment_1
.
canUseDOM
|
|
capture
&
&
!
(
'
addEventListener
'
in
document
)
)
{
return
false
;
}
var
eventName
=
'
on
'
+
eventNameSuffix
;
var
isSupported
=
eventName
in
document
;
if
(
!
isSupported
)
{
var
element
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
element
.
setAttribute
(
eventName
'
return
;
'
)
;
isSupported
=
typeof
element
[
eventName
]
=
=
=
'
function
'
;
}
if
(
!
isSupported
&
&
useHasFeature
&
&
eventNameSuffix
=
=
=
'
wheel
'
)
{
isSupported
=
document
.
implementation
.
hasFeature
(
'
Events
.
wheel
'
'
3
.
0
'
)
;
}
return
isSupported
;
}
function
isCheckable
(
elem
)
{
var
type
=
elem
.
type
;
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
type
=
=
=
'
checkbox
'
|
|
type
=
=
=
'
radio
'
)
;
}
function
getTracker
(
node
)
{
return
node
.
_valueTracker
;
}
function
detachTracker
(
node
)
{
node
.
_valueTracker
=
null
;
}
function
getValueFromNode
(
node
)
{
var
value
=
'
'
;
if
(
!
node
)
{
return
value
;
}
if
(
isCheckable
(
node
)
)
{
value
=
node
.
checked
?
'
true
'
:
'
false
'
;
}
else
{
value
=
node
.
value
;
}
return
value
;
}
function
trackValueOnNode
(
node
)
{
var
valueField
=
isCheckable
(
node
)
?
'
checked
'
:
'
value
'
;
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
node
.
constructor
.
prototype
valueField
)
;
var
currentValue
=
'
'
+
node
[
valueField
]
;
if
(
node
.
hasOwnProperty
(
valueField
)
|
|
typeof
descriptor
.
get
!
=
=
'
function
'
|
|
typeof
descriptor
.
set
!
=
=
'
function
'
)
{
return
;
}
Object
.
defineProperty
(
node
valueField
{
enumerable
:
descriptor
.
enumerable
configurable
:
true
get
:
function
(
)
{
return
descriptor
.
get
.
call
(
this
)
;
}
set
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
descriptor
.
set
.
call
(
this
value
)
;
}
}
)
;
var
tracker
=
{
getValue
:
function
(
)
{
return
currentValue
;
}
setValue
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
}
stopTracking
:
function
(
)
{
detachTracker
(
node
)
;
delete
node
[
valueField
]
;
}
}
;
return
tracker
;
}
function
track
(
node
)
{
if
(
getTracker
(
node
)
)
{
return
;
}
node
.
_valueTracker
=
trackValueOnNode
(
node
)
;
}
function
updateValueIfChanged
(
node
)
{
if
(
!
node
)
{
return
false
;
}
var
tracker
=
getTracker
(
node
)
;
if
(
!
tracker
)
{
return
true
;
}
var
lastValue
=
tracker
.
getValue
(
)
;
var
nextValue
=
getValueFromNode
(
node
)
;
if
(
nextValue
!
=
=
lastValue
)
{
tracker
.
setValue
(
nextValue
)
;
return
true
;
}
return
false
;
}
var
eventTypes
1
=
{
change
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onChange
'
captured
:
'
onChangeCapture
'
}
dependencies
:
[
'
topBlur
'
'
topChange
'
'
topClick
'
'
topFocus
'
'
topInput
'
'
topKeyDown
'
'
topKeyUp
'
'
topSelectionChange
'
]
}
}
;
function
createAndAccumulateChangeEvent
(
inst
nativeEvent
target
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
1
.
change
inst
nativeEvent
target
)
;
event
.
type
=
'
change
'
;
enqueueStateRestore
(
target
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
activeElement
=
null
;
var
activeElementInst
=
null
;
function
shouldUseChangeEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
=
=
=
'
select
'
|
|
nodeName
=
=
=
'
input
'
&
&
elem
.
type
=
=
=
'
file
'
;
}
function
manualDispatchChangeEvent
(
nativeEvent
)
{
var
event
=
createAndAccumulateChangeEvent
(
activeElementInst
nativeEvent
getEventTarget
(
nativeEvent
)
)
;
batchedUpdates
(
runEventInBatch
event
)
;
}
function
runEventInBatch
(
event
)
{
enqueueEvents
(
event
)
;
processEventQueue
(
false
)
;
}
function
getInstIfValueChanged
(
targetInst
)
{
var
targetNode
=
getNodeFromInstance
1
(
targetInst
)
;
if
(
updateValueIfChanged
(
targetNode
)
)
{
return
targetInst
;
}
}
function
getTargetInstForChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
'
topChange
'
)
{
return
targetInst
;
}
}
var
isInputEventSupported
=
false
;
if
(
ExecutionEnvironment_1
.
canUseDOM
)
{
isInputEventSupported
=
isEventSupported
(
'
input
'
)
&
&
(
!
document
.
documentMode
|
|
document
.
documentMode
>
9
)
;
}
function
startWatchingForValueChange
(
target
targetInst
)
{
activeElement
=
target
;
activeElementInst
=
targetInst
;
activeElement
.
attachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
}
function
stopWatchingForValueChange
(
)
{
if
(
!
activeElement
)
{
return
;
}
activeElement
.
detachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
activeElement
=
null
;
activeElementInst
=
null
;
}
function
handlePropertyChange
(
nativeEvent
)
{
if
(
nativeEvent
.
propertyName
!
=
=
'
value
'
)
{
return
;
}
if
(
getInstIfValueChanged
(
activeElementInst
)
)
{
manualDispatchChangeEvent
(
nativeEvent
)
;
}
}
function
handleEventsForInputEventPolyfill
(
topLevelType
target
targetInst
)
{
if
(
topLevelType
=
=
=
'
topFocus
'
)
{
stopWatchingForValueChange
(
)
;
startWatchingForValueChange
(
target
targetInst
)
;
}
else
if
(
topLevelType
=
=
=
'
topBlur
'
)
{
stopWatchingForValueChange
(
)
;
}
}
function
getTargetInstForInputEventPolyfill
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
'
topSelectionChange
'
|
|
topLevelType
=
=
=
'
topKeyUp
'
|
|
topLevelType
=
=
=
'
topKeyDown
'
)
{
return
getInstIfValueChanged
(
activeElementInst
)
;
}
}
function
shouldUseClickEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
checkbox
'
|
|
elem
.
type
=
=
=
'
radio
'
)
;
}
function
getTargetInstForClickEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
'
topClick
'
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
getTargetInstForInputOrChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
'
topInput
'
|
|
topLevelType
=
=
=
'
topChange
'
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
handleControlledInputBlur
(
inst
node
)
{
if
(
inst
=
=
null
)
{
return
;
}
var
state
=
inst
.
_wrapperState
|
|
node
.
_wrapperState
;
if
(
!
state
|
|
!
state
.
controlled
|
|
node
.
type
!
=
=
'
number
'
)
{
return
;
}
var
value
=
'
'
+
node
.
value
;
if
(
node
.
getAttribute
(
'
value
'
)
!
=
=
value
)
{
node
.
setAttribute
(
'
value
'
value
)
;
}
}
var
ChangeEventPlugin
=
{
eventTypes
:
eventTypes
1
_isInputEventSupported
:
isInputEventSupported
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
var
getTargetInstFunc
handleEventFunc
;
if
(
shouldUseChangeEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForChangeEvent
;
}
else
if
(
isTextInputElement
(
targetNode
)
)
{
if
(
isInputEventSupported
)
{
getTargetInstFunc
=
getTargetInstForInputOrChangeEvent
;
}
else
{
getTargetInstFunc
=
getTargetInstForInputEventPolyfill
;
handleEventFunc
=
handleEventsForInputEventPolyfill
;
}
}
else
if
(
shouldUseClickEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForClickEvent
;
}
if
(
getTargetInstFunc
)
{
var
inst
=
getTargetInstFunc
(
topLevelType
targetInst
)
;
if
(
inst
)
{
var
event
=
createAndAccumulateChangeEvent
(
inst
nativeEvent
nativeEventTarget
)
;
return
event
;
}
}
if
(
handleEventFunc
)
{
handleEventFunc
(
topLevelType
targetNode
targetInst
)
;
}
if
(
topLevelType
=
=
=
'
topBlur
'
)
{
handleControlledInputBlur
(
targetInst
targetNode
)
;
}
}
}
;
var
DOMEventPluginOrder
=
[
'
ResponderEventPlugin
'
'
SimpleEventPlugin
'
'
TapEventPlugin
'
'
EnterLeaveEventPlugin
'
'
ChangeEventPlugin
'
'
SelectEventPlugin
'
'
BeforeInputEventPlugin
'
]
;
var
UIEventInterface
=
{
view
:
null
detail
:
null
}
;
function
SyntheticUIEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticUIEvent
UIEventInterface
)
;
var
modifierKeyToProp
=
{
Alt
:
'
altKey
'
Control
:
'
ctrlKey
'
Meta
:
'
metaKey
'
Shift
:
'
shiftKey
'
}
;
function
modifierStateGetter
(
keyArg
)
{
var
syntheticEvent
=
this
;
var
nativeEvent
=
syntheticEvent
.
nativeEvent
;
if
(
nativeEvent
.
getModifierState
)
{
return
nativeEvent
.
getModifierState
(
keyArg
)
;
}
var
keyProp
=
modifierKeyToProp
[
keyArg
]
;
return
keyProp
?
!
!
nativeEvent
[
keyProp
]
:
false
;
}
function
getEventModifierState
(
nativeEvent
)
{
return
modifierStateGetter
;
}
var
MouseEventInterface
=
{
screenX
:
null
screenY
:
null
clientX
:
null
clientY
:
null
pageX
:
null
pageY
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
getModifierState
:
getEventModifierState
button
:
null
buttons
:
null
relatedTarget
:
function
(
event
)
{
return
event
.
relatedTarget
|
|
(
event
.
fromElement
=
=
=
event
.
srcElement
?
event
.
toElement
:
event
.
fromElement
)
;
}
}
;
function
SyntheticMouseEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticMouseEvent
MouseEventInterface
)
;
var
eventTypes
2
=
{
mouseEnter
:
{
registrationName
:
'
onMouseEnter
'
dependencies
:
[
'
topMouseOut
'
'
topMouseOver
'
]
}
mouseLeave
:
{
registrationName
:
'
onMouseLeave
'
dependencies
:
[
'
topMouseOut
'
'
topMouseOver
'
]
}
}
;
var
EnterLeaveEventPlugin
=
{
eventTypes
:
eventTypes
2
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
if
(
topLevelType
=
=
=
'
topMouseOver
'
&
&
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
fromElement
)
)
{
return
null
;
}
if
(
topLevelType
!
=
=
'
topMouseOut
'
&
&
topLevelType
!
=
=
'
topMouseOver
'
)
{
return
null
;
}
var
win
;
if
(
nativeEventTarget
.
window
=
=
=
nativeEventTarget
)
{
win
=
nativeEventTarget
;
}
else
{
var
doc
=
nativeEventTarget
.
ownerDocument
;
if
(
doc
)
{
win
=
doc
.
defaultView
|
|
doc
.
parentWindow
;
}
else
{
win
=
window
;
}
}
var
from
;
var
to
;
if
(
topLevelType
=
=
=
'
topMouseOut
'
)
{
from
=
targetInst
;
var
related
=
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
toElement
;
to
=
related
?
getClosestInstanceFromNode
(
related
)
:
null
;
}
else
{
from
=
null
;
to
=
targetInst
;
}
if
(
from
=
=
=
to
)
{
return
null
;
}
var
fromNode
=
from
=
=
null
?
win
:
getNodeFromInstance
1
(
from
)
;
var
toNode
=
to
=
=
null
?
win
:
getNodeFromInstance
1
(
to
)
;
var
leave
=
SyntheticMouseEvent
.
getPooled
(
eventTypes
2
.
mouseLeave
from
nativeEvent
nativeEventTarget
)
;
leave
.
type
=
'
mouseleave
'
;
leave
.
target
=
fromNode
;
leave
.
relatedTarget
=
toNode
;
var
enter
=
SyntheticMouseEvent
.
getPooled
(
eventTypes
2
.
mouseEnter
to
nativeEvent
nativeEventTarget
)
;
enter
.
type
=
'
mouseenter
'
;
enter
.
target
=
toNode
;
enter
.
relatedTarget
=
fromNode
;
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
;
return
[
leave
enter
]
;
}
}
;
function
get
(
key
)
{
return
key
.
_reactInternalFiber
;
}
function
has
(
key
)
{
return
key
.
_reactInternalFiber
!
=
=
undefined
;
}
function
set
(
key
value
)
{
key
.
_reactInternalFiber
=
value
;
}
var
ReactInternals
1
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
ReactCurrentOwner
=
ReactInternals
1
.
ReactCurrentOwner
;
function
getComponentName
(
fiber
)
{
var
type
=
fiber
.
type
;
if
(
typeof
type
=
=
=
'
string
'
)
{
return
type
;
}
if
(
typeof
type
=
=
=
'
function
'
)
{
return
type
.
displayName
|
|
type
.
name
;
}
return
null
;
}
var
NoEffect
=
0
;
var
PerformedWork
=
1
;
var
Placement
=
2
;
var
Update
=
4
;
var
PlacementAndUpdate
=
6
;
var
Deletion
=
8
;
var
ContentReset
=
16
;
var
Callback
=
32
;
var
Err
=
64
;
var
Ref
=
128
;
var
MOUNTING
=
1
;
var
MOUNTED
=
2
;
var
UNMOUNTED
=
3
;
function
isFiberMountedImpl
(
fiber
)
{
var
node
=
fiber
;
if
(
!
fiber
.
alternate
)
{
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
while
(
node
[
'
return
'
]
)
{
node
=
node
[
'
return
'
]
;
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
}
}
else
{
while
(
node
[
'
return
'
]
)
{
node
=
node
[
'
return
'
]
;
}
}
if
(
node
.
tag
=
=
=
HostRoot
)
{
return
MOUNTED
;
}
return
UNMOUNTED
;
}
function
isFiberMounted
(
fiber
)
{
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
isMounted
(
component
)
{
var
fiber
=
get
(
component
)
;
if
(
!
fiber
)
{
return
false
;
}
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
assertIsMounted
(
fiber
)
{
!
(
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
}
function
findCurrentFiberUsingSlowPath
(
fiber
)
{
var
alternate
=
fiber
.
alternate
;
if
(
!
alternate
)
{
var
state
=
isFiberMountedImpl
(
fiber
)
;
!
(
state
!
=
=
UNMOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
state
=
=
=
MOUNTING
)
{
return
null
;
}
return
fiber
;
}
var
a
=
fiber
;
var
b
=
alternate
;
while
(
true
)
{
var
parentA
=
a
[
'
return
'
]
;
var
parentB
=
parentA
?
parentA
.
alternate
:
null
;
if
(
!
parentA
|
|
!
parentB
)
{
break
;
}
if
(
parentA
.
child
=
=
=
parentB
.
child
)
{
var
child
=
parentA
.
child
;
while
(
child
)
{
if
(
child
=
=
=
a
)
{
assertIsMounted
(
parentA
)
;
return
fiber
;
}
if
(
child
=
=
=
b
)
{
assertIsMounted
(
parentA
)
;
return
alternate
;
}
child
=
child
.
sibling
;
}
reactProdInvariant
(
'
188
'
)
;
}
if
(
a
[
'
return
'
]
!
=
=
b
[
'
return
'
]
)
{
a
=
parentA
;
b
=
parentB
;
}
else
{
var
didFindChild
=
false
;
var
_child
=
parentA
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentA
;
b
=
parentB
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentA
;
a
=
parentB
;
break
;
}
_child
=
_child
.
sibling
;
}
if
(
!
didFindChild
)
{
_child
=
parentB
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentB
;
b
=
parentA
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentB
;
a
=
parentA
;
break
;
}
_child
=
_child
.
sibling
;
}
!
didFindChild
?
reactProdInvariant
(
'
189
'
)
:
void
0
;
}
}
!
(
a
.
alternate
=
=
=
b
)
?
reactProdInvariant
(
'
190
'
)
:
void
0
;
}
!
(
a
.
tag
=
=
=
HostRoot
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
a
.
stateNode
.
current
=
=
=
a
)
{
return
fiber
;
}
return
alternate
;
}
function
findCurrentHostFiber
(
parent
)
{
var
currentParent
=
findCurrentFiberUsingSlowPath
(
parent
)
;
if
(
!
currentParent
)
{
return
null
;
}
var
node
=
currentParent
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
return
node
;
}
else
if
(
node
.
child
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
currentParent
)
{
return
null
;
}
while
(
!
node
.
sibling
)
{
if
(
!
node
[
'
return
'
]
|
|
node
[
'
return
'
]
=
=
=
currentParent
)
{
return
null
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
return
null
;
}
function
findCurrentHostFiberWithNoPortals
(
parent
)
{
var
currentParent
=
findCurrentFiberUsingSlowPath
(
parent
)
;
if
(
!
currentParent
)
{
return
null
;
}
var
node
=
currentParent
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
return
node
;
}
else
if
(
node
.
child
&
&
node
.
tag
!
=
=
HostPortal
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
currentParent
)
{
return
null
;
}
while
(
!
node
.
sibling
)
{
if
(
!
node
[
'
return
'
]
|
|
node
[
'
return
'
]
=
=
=
currentParent
)
{
return
null
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
return
null
;
}
var
EventListener
=
{
listen
:
function
listen
(
target
eventType
callback
)
{
if
(
target
.
addEventListener
)
{
target
.
addEventListener
(
eventType
callback
false
)
;
return
{
remove
:
function
remove
(
)
{
target
.
removeEventListener
(
eventType
callback
false
)
;
}
}
;
}
else
if
(
target
.
attachEvent
)
{
target
.
attachEvent
(
'
on
'
+
eventType
callback
)
;
return
{
remove
:
function
remove
(
)
{
target
.
detachEvent
(
'
on
'
+
eventType
callback
)
;
}
}
;
}
}
capture
:
function
capture
(
target
eventType
callback
)
{
if
(
target
.
addEventListener
)
{
target
.
addEventListener
(
eventType
callback
true
)
;
return
{
remove
:
function
remove
(
)
{
target
.
removeEventListener
(
eventType
callback
true
)
;
}
}
;
}
else
{
return
{
remove
:
emptyFunction_1
}
;
}
}
registerDefault
:
function
registerDefault
(
)
{
}
}
;
var
EventListener_1
=
EventListener
;
var
CALLBACK_BOOKKEEPING_POOL_SIZE
=
10
;
var
callbackBookkeepingPool
=
[
]
;
function
findRootContainerNode
(
inst
)
{
while
(
inst
[
'
return
'
]
)
{
inst
=
inst
[
'
return
'
]
;
}
if
(
inst
.
tag
!
=
=
HostRoot
)
{
return
null
;
}
return
inst
.
stateNode
.
containerInfo
;
}
function
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
)
{
if
(
callbackBookkeepingPool
.
length
)
{
var
instance
=
callbackBookkeepingPool
.
pop
(
)
;
instance
.
topLevelType
=
topLevelType
;
instance
.
nativeEvent
=
nativeEvent
;
instance
.
targetInst
=
targetInst
;
return
instance
;
}
return
{
topLevelType
:
topLevelType
nativeEvent
:
nativeEvent
targetInst
:
targetInst
ancestors
:
[
]
}
;
}
function
releaseTopLevelCallbackBookKeeping
(
instance
)
{
instance
.
topLevelType
=
null
;
instance
.
nativeEvent
=
null
;
instance
.
targetInst
=
null
;
instance
.
ancestors
.
length
=
0
;
if
(
callbackBookkeepingPool
.
length
<
CALLBACK_BOOKKEEPING_POOL_SIZE
)
{
callbackBookkeepingPool
.
push
(
instance
)
;
}
}
function
handleTopLevelImpl
(
bookKeeping
)
{
var
targetInst
=
bookKeeping
.
targetInst
;
var
ancestor
=
targetInst
;
do
{
if
(
!
ancestor
)
{
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
break
;
}
var
root
=
findRootContainerNode
(
ancestor
)
;
if
(
!
root
)
{
break
;
}
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
ancestor
=
getClosestInstanceFromNode
(
root
)
;
}
while
(
ancestor
)
;
for
(
var
i
=
0
;
i
<
bookKeeping
.
ancestors
.
length
;
i
+
+
)
{
targetInst
=
bookKeeping
.
ancestors
[
i
]
;
_handleTopLevel
(
bookKeeping
.
topLevelType
targetInst
bookKeeping
.
nativeEvent
getEventTarget
(
bookKeeping
.
nativeEvent
)
)
;
}
}
var
_enabled
=
true
;
var
_handleTopLevel
=
void
0
;
function
setHandleTopLevel
(
handleTopLevel
)
{
_handleTopLevel
=
handleTopLevel
;
}
function
setEnabled
(
enabled
)
{
_enabled
=
!
!
enabled
;
}
function
isEnabled
(
)
{
return
_enabled
;
}
function
trapBubbledEvent
(
topLevelType
handlerBaseName
element
)
{
if
(
!
element
)
{
return
null
;
}
return
EventListener_1
.
listen
(
element
handlerBaseName
dispatchEvent
.
bind
(
null
topLevelType
)
)
;
}
function
trapCapturedEvent
(
topLevelType
handlerBaseName
element
)
{
if
(
!
element
)
{
return
null
;
}
return
EventListener_1
.
capture
(
element
handlerBaseName
dispatchEvent
.
bind
(
null
topLevelType
)
)
;
}
function
dispatchEvent
(
topLevelType
nativeEvent
)
{
if
(
!
_enabled
)
{
return
;
}
var
nativeEventTarget
=
getEventTarget
(
nativeEvent
)
;
var
targetInst
=
getClosestInstanceFromNode
(
nativeEventTarget
)
;
if
(
targetInst
!
=
=
null
&
&
typeof
targetInst
.
tag
=
=
=
'
number
'
&
&
!
isFiberMounted
(
targetInst
)
)
{
targetInst
=
null
;
}
var
bookKeeping
=
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
)
;
try
{
batchedUpdates
(
handleTopLevelImpl
bookKeeping
)
;
}
finally
{
releaseTopLevelCallbackBookKeeping
(
bookKeeping
)
;
}
}
var
ReactDOMEventListener
=
Object
.
freeze
(
{
get
_enabled
(
)
{
return
_enabled
;
}
get
_handleTopLevel
(
)
{
return
_handleTopLevel
;
}
setHandleTopLevel
:
setHandleTopLevel
setEnabled
:
setEnabled
isEnabled
:
isEnabled
trapBubbledEvent
:
trapBubbledEvent
trapCapturedEvent
:
trapCapturedEvent
dispatchEvent
:
dispatchEvent
}
)
;
function
makePrefixMap
(
styleProp
eventName
)
{
var
prefixes
=
{
}
;
prefixes
[
styleProp
.
toLowerCase
(
)
]
=
eventName
.
toLowerCase
(
)
;
prefixes
[
'
Webkit
'
+
styleProp
]
=
'
webkit
'
+
eventName
;
prefixes
[
'
Moz
'
+
styleProp
]
=
'
moz
'
+
eventName
;
prefixes
[
'
ms
'
+
styleProp
]
=
'
MS
'
+
eventName
;
prefixes
[
'
O
'
+
styleProp
]
=
'
o
'
+
eventName
.
toLowerCase
(
)
;
return
prefixes
;
}
var
vendorPrefixes
=
{
animationend
:
makePrefixMap
(
'
Animation
'
'
AnimationEnd
'
)
animationiteration
:
makePrefixMap
(
'
Animation
'
'
AnimationIteration
'
)
animationstart
:
makePrefixMap
(
'
Animation
'
'
AnimationStart
'
)
transitionend
:
makePrefixMap
(
'
Transition
'
'
TransitionEnd
'
)
}
;
var
prefixedEventNames
=
{
}
;
var
style
=
{
}
;
if
(
ExecutionEnvironment_1
.
canUseDOM
)
{
style
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
.
style
;
if
(
!
(
'
AnimationEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
animationend
.
animation
;
delete
vendorPrefixes
.
animationiteration
.
animation
;
delete
vendorPrefixes
.
animationstart
.
animation
;
}
if
(
!
(
'
TransitionEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
transitionend
.
transition
;
}
}
function
getVendorPrefixedEventName
(
eventName
)
{
if
(
prefixedEventNames
[
eventName
]
)
{
return
prefixedEventNames
[
eventName
]
;
}
else
if
(
!
vendorPrefixes
[
eventName
]
)
{
return
eventName
;
}
var
prefixMap
=
vendorPrefixes
[
eventName
]
;
for
(
var
styleProp
in
prefixMap
)
{
if
(
prefixMap
.
hasOwnProperty
(
styleProp
)
&
&
styleProp
in
style
)
{
return
prefixedEventNames
[
eventName
]
=
prefixMap
[
styleProp
]
;
}
}
return
'
'
;
}
var
topLevelTypes
1
=
{
topAbort
:
'
abort
'
topAnimationEnd
:
getVendorPrefixedEventName
(
'
animationend
'
)
|
|
'
animationend
'
topAnimationIteration
:
getVendorPrefixedEventName
(
'
animationiteration
'
)
|
|
'
animationiteration
'
topAnimationStart
:
getVendorPrefixedEventName
(
'
animationstart
'
)
|
|
'
animationstart
'
topBlur
:
'
blur
'
topCancel
:
'
cancel
'
topCanPlay
:
'
canplay
'
topCanPlayThrough
:
'
canplaythrough
'
topChange
:
'
change
'
topClick
:
'
click
'
topClose
:
'
close
'
topCompositionEnd
:
'
compositionend
'
topCompositionStart
:
'
compositionstart
'
topCompositionUpdate
:
'
compositionupdate
'
topContextMenu
:
'
contextmenu
'
topCopy
:
'
copy
'
topCut
:
'
cut
'
topDoubleClick
:
'
dblclick
'
topDrag
:
'
drag
'
topDragEnd
:
'
dragend
'
topDragEnter
:
'
dragenter
'
topDragExit
:
'
dragexit
'
topDragLeave
:
'
dragleave
'
topDragOver
:
'
dragover
'
topDragStart
:
'
dragstart
'
topDrop
:
'
drop
'
topDurationChange
:
'
durationchange
'
topEmptied
:
'
emptied
'
topEncrypted
:
'
encrypted
'
topEnded
:
'
ended
'
topError
:
'
error
'
topFocus
:
'
focus
'
topInput
:
'
input
'
topKeyDown
:
'
keydown
'
topKeyPress
:
'
keypress
'
topKeyUp
:
'
keyup
'
topLoadedData
:
'
loadeddata
'
topLoad
:
'
load
'
topLoadedMetadata
:
'
loadedmetadata
'
topLoadStart
:
'
loadstart
'
topMouseDown
:
'
mousedown
'
topMouseMove
:
'
mousemove
'
topMouseOut
:
'
mouseout
'
topMouseOver
:
'
mouseover
'
topMouseUp
:
'
mouseup
'
topPaste
:
'
paste
'
topPause
:
'
pause
'
topPlay
:
'
play
'
topPlaying
:
'
playing
'
topProgress
:
'
progress
'
topRateChange
:
'
ratechange
'
topScroll
:
'
scroll
'
topSeeked
:
'
seeked
'
topSeeking
:
'
seeking
'
topSelectionChange
:
'
selectionchange
'
topStalled
:
'
stalled
'
topSuspend
:
'
suspend
'
topTextInput
:
'
textInput
'
topTimeUpdate
:
'
timeupdate
'
topToggle
:
'
toggle
'
topTouchCancel
:
'
touchcancel
'
topTouchEnd
:
'
touchend
'
topTouchMove
:
'
touchmove
'
topTouchStart
:
'
touchstart
'
topTransitionEnd
:
getVendorPrefixedEventName
(
'
transitionend
'
)
|
|
'
transitionend
'
topVolumeChange
:
'
volumechange
'
topWaiting
:
'
waiting
'
topWheel
:
'
wheel
'
}
;
var
BrowserEventConstants
=
{
topLevelTypes
:
topLevelTypes
1
}
;
function
runEventQueueInBatch
(
events
)
{
enqueueEvents
(
events
)
;
processEventQueue
(
false
)
;
}
function
handleTopLevel
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
events
=
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
runEventQueueInBatch
(
events
)
;
}
var
topLevelTypes
=
BrowserEventConstants
.
topLevelTypes
;
var
alreadyListeningTo
=
{
}
;
var
reactTopListenersCounter
=
0
;
var
topListenersIDKey
=
'
_reactListenersID
'
+
(
'
'
+
Math
.
random
(
)
)
.
slice
(
2
)
;
function
getListeningForDocument
(
mountAt
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
mountAt
topListenersIDKey
)
)
{
mountAt
[
topListenersIDKey
]
=
reactTopListenersCounter
+
+
;
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
=
{
}
;
}
return
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
;
}
function
listenTo
(
registrationName
contentDocumentHandle
)
{
var
mountAt
=
contentDocumentHandle
;
var
isListening
=
getListeningForDocument
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
(
isListening
.
hasOwnProperty
(
dependency
)
&
&
isListening
[
dependency
]
)
)
{
if
(
dependency
=
=
=
'
topScroll
'
)
{
trapCapturedEvent
(
'
topScroll
'
'
scroll
'
mountAt
)
;
}
else
if
(
dependency
=
=
=
'
topFocus
'
|
|
dependency
=
=
=
'
topBlur
'
)
{
trapCapturedEvent
(
'
topFocus
'
'
focus
'
mountAt
)
;
trapCapturedEvent
(
'
topBlur
'
'
blur
'
mountAt
)
;
isListening
.
topBlur
=
true
;
isListening
.
topFocus
=
true
;
}
else
if
(
dependency
=
=
=
'
topCancel
'
)
{
if
(
isEventSupported
(
'
cancel
'
true
)
)
{
trapCapturedEvent
(
'
topCancel
'
'
cancel
'
mountAt
)
;
}
isListening
.
topCancel
=
true
;
}
else
if
(
dependency
=
=
=
'
topClose
'
)
{
if
(
isEventSupported
(
'
close
'
true
)
)
{
trapCapturedEvent
(
'
topClose
'
'
close
'
mountAt
)
;
}
isListening
.
topClose
=
true
;
}
else
if
(
topLevelTypes
.
hasOwnProperty
(
dependency
)
)
{
trapBubbledEvent
(
dependency
topLevelTypes
[
dependency
]
mountAt
)
;
}
isListening
[
dependency
]
=
true
;
}
}
}
function
isListeningToAllDependencies
(
registrationName
mountAt
)
{
var
isListening
=
getListeningForDocument
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
(
isListening
.
hasOwnProperty
(
dependency
)
&
&
isListening
[
dependency
]
)
)
{
return
false
;
}
}
return
true
;
}
function
getActiveElement
(
doc
)
{
doc
=
doc
|
|
(
typeof
document
!
=
=
'
undefined
'
?
document
:
undefined
)
;
if
(
typeof
doc
=
=
=
'
undefined
'
)
{
return
null
;
}
try
{
return
doc
.
activeElement
|
|
doc
.
body
;
}
catch
(
e
)
{
return
doc
.
body
;
}
}
var
getActiveElement_1
=
getActiveElement
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
is
(
x
y
)
{
if
(
x
=
=
=
y
)
{
return
x
!
=
=
0
|
|
y
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
;
}
else
{
return
x
!
=
=
x
&
&
y
!
=
=
y
;
}
}
function
shallowEqual
(
objA
objB
)
{
if
(
is
(
objA
objB
)
)
{
return
true
;
}
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwnProperty
.
call
(
objB
keysA
[
i
]
)
|
|
!
is
(
objA
[
keysA
[
i
]
]
objB
[
keysA
[
i
]
]
)
)
{
return
false
;
}
}
return
true
;
}
var
shallowEqual_1
=
shallowEqual
;
function
isNode
(
object
)
{
var
doc
=
object
?
object
.
ownerDocument
|
|
object
:
document
;
var
defaultView
=
doc
.
defaultView
|
|
window
;
return
!
!
(
object
&
&
(
typeof
defaultView
.
Node
=
=
=
'
function
'
?
object
instanceof
defaultView
.
Node
:
typeof
object
=
=
=
'
object
'
&
&
typeof
object
.
nodeType
=
=
=
'
number
'
&
&
typeof
object
.
nodeName
=
=
=
'
string
'
)
)
;
}
var
isNode_1
=
isNode
;
function
isTextNode
(
object
)
{
return
isNode_1
(
object
)
&
&
object
.
nodeType
=
=
3
;
}
var
isTextNode_1
=
isTextNode
;
function
containsNode
(
outerNode
innerNode
)
{
if
(
!
outerNode
|
|
!
innerNode
)
{
return
false
;
}
else
if
(
outerNode
=
=
=
innerNode
)
{
return
true
;
}
else
if
(
isTextNode_1
(
outerNode
)
)
{
return
false
;
}
else
if
(
isTextNode_1
(
innerNode
)
)
{
return
containsNode
(
outerNode
innerNode
.
parentNode
)
;
}
else
if
(
'
contains
'
in
outerNode
)
{
return
outerNode
.
contains
(
innerNode
)
;
}
else
if
(
outerNode
.
compareDocumentPosition
)
{
return
!
!
(
outerNode
.
compareDocumentPosition
(
innerNode
)
&
16
)
;
}
else
{
return
false
;
}
}
var
containsNode_1
=
containsNode
;
function
focusNode
(
node
)
{
try
{
node
.
focus
(
)
;
}
catch
(
e
)
{
}
}
var
focusNode_1
=
focusNode
;
function
getLeafNode
(
node
)
{
while
(
node
&
&
node
.
firstChild
)
{
node
=
node
.
firstChild
;
}
return
node
;
}
function
getSiblingNode
(
node
)
{
while
(
node
)
{
if
(
node
.
nextSibling
)
{
return
node
.
nextSibling
;
}
node
=
node
.
parentNode
;
}
}
function
getNodeForCharacterOffset
(
root
offset
)
{
var
node
=
getLeafNode
(
root
)
;
var
nodeStart
=
0
;
var
nodeEnd
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
nodeEnd
=
nodeStart
+
node
.
textContent
.
length
;
if
(
nodeStart
<
=
offset
&
&
nodeEnd
>
=
offset
)
{
return
{
node
:
node
offset
:
offset
-
nodeStart
}
;
}
nodeStart
=
nodeEnd
;
}
node
=
getLeafNode
(
getSiblingNode
(
node
)
)
;
}
}
function
getOffsets
(
outerNode
)
{
var
selection
=
window
.
getSelection
&
&
window
.
getSelection
(
)
;
if
(
!
selection
|
|
selection
.
rangeCount
=
=
=
0
)
{
return
null
;
}
var
anchorNode
=
selection
.
anchorNode
anchorOffset
=
selection
.
anchorOffset
focusNode
=
selection
.
focusNode
focusOffset
=
selection
.
focusOffset
;
try
{
anchorNode
.
nodeType
;
focusNode
.
nodeType
;
}
catch
(
e
)
{
return
null
;
}
return
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
;
}
function
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
{
var
length
=
0
;
var
start
=
-
1
;
var
end
=
-
1
;
var
indexWithinAnchor
=
0
;
var
indexWithinFocus
=
0
;
var
node
=
outerNode
;
var
parentNode
=
null
;
outer
:
while
(
true
)
{
var
next
=
null
;
while
(
true
)
{
if
(
node
=
=
=
anchorNode
&
&
(
anchorOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
start
=
length
+
anchorOffset
;
}
if
(
node
=
=
=
focusNode
&
&
(
focusOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
end
=
length
+
focusOffset
;
}
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
length
+
=
node
.
nodeValue
.
length
;
}
if
(
(
next
=
node
.
firstChild
)
=
=
=
null
)
{
break
;
}
parentNode
=
node
;
node
=
next
;
}
while
(
true
)
{
if
(
node
=
=
=
outerNode
)
{
break
outer
;
}
if
(
parentNode
=
=
=
anchorNode
&
&
+
+
indexWithinAnchor
=
=
=
anchorOffset
)
{
start
=
length
;
}
if
(
parentNode
=
=
=
focusNode
&
&
+
+
indexWithinFocus
=
=
=
focusOffset
)
{
end
=
length
;
}
if
(
(
next
=
node
.
nextSibling
)
!
=
=
null
)
{
break
;
}
node
=
parentNode
;
parentNode
=
node
.
parentNode
;
}
node
=
next
;
}
if
(
start
=
=
=
-
1
|
|
end
=
=
=
-
1
)
{
return
null
;
}
return
{
start
:
start
end
:
end
}
;
}
function
setOffsets
(
node
offsets
)
{
if
(
!
window
.
getSelection
)
{
return
;
}
var
selection
=
window
.
getSelection
(
)
;
var
length
=
node
[
getTextContentAccessor
(
)
]
.
length
;
var
start
=
Math
.
min
(
offsets
.
start
length
)
;
var
end
=
offsets
.
end
=
=
=
undefined
?
start
:
Math
.
min
(
offsets
.
end
length
)
;
if
(
!
selection
.
extend
&
&
start
>
end
)
{
var
temp
=
end
;
end
=
start
;
start
=
temp
;
}
var
startMarker
=
getNodeForCharacterOffset
(
node
start
)
;
var
endMarker
=
getNodeForCharacterOffset
(
node
end
)
;
if
(
startMarker
&
&
endMarker
)
{
if
(
selection
.
rangeCount
=
=
=
1
&
&
selection
.
anchorNode
=
=
=
startMarker
.
node
&
&
selection
.
anchorOffset
=
=
=
startMarker
.
offset
&
&
selection
.
focusNode
=
=
=
endMarker
.
node
&
&
selection
.
focusOffset
=
=
=
endMarker
.
offset
)
{
return
;
}
var
range
=
document
.
createRange
(
)
;
range
.
setStart
(
startMarker
.
node
startMarker
.
offset
)
;
selection
.
removeAllRanges
(
)
;
if
(
start
>
end
)
{
selection
.
addRange
(
range
)
;
selection
.
extend
(
endMarker
.
node
endMarker
.
offset
)
;
}
else
{
range
.
setEnd
(
endMarker
.
node
endMarker
.
offset
)
;
selection
.
addRange
(
range
)
;
}
}
}
function
isInDocument
(
node
)
{
return
containsNode_1
(
document
.
documentElement
node
)
;
}
function
hasSelectionCapabilities
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
&
&
(
nodeName
=
=
=
'
input
'
&
&
elem
.
type
=
=
=
'
text
'
|
|
nodeName
=
=
=
'
textarea
'
|
|
elem
.
contentEditable
=
=
=
'
true
'
)
;
}
function
getSelectionInformation
(
)
{
var
focusedElem
=
getActiveElement_1
(
)
;
return
{
focusedElem
:
focusedElem
selectionRange
:
hasSelectionCapabilities
(
focusedElem
)
?
getSelection
1
(
focusedElem
)
:
null
}
;
}
function
restoreSelection
(
priorSelectionInformation
)
{
var
curFocusedElem
=
getActiveElement_1
(
)
;
var
priorFocusedElem
=
priorSelectionInformation
.
focusedElem
;
var
priorSelectionRange
=
priorSelectionInformation
.
selectionRange
;
if
(
curFocusedElem
!
=
=
priorFocusedElem
&
&
isInDocument
(
priorFocusedElem
)
)
{
if
(
hasSelectionCapabilities
(
priorFocusedElem
)
)
{
setSelection
(
priorFocusedElem
priorSelectionRange
)
;
}
var
ancestors
=
[
]
;
var
ancestor
=
priorFocusedElem
;
while
(
ancestor
=
ancestor
.
parentNode
)
{
if
(
ancestor
.
nodeType
=
=
=
ELEMENT_NODE
)
{
ancestors
.
push
(
{
element
:
ancestor
left
:
ancestor
.
scrollLeft
top
:
ancestor
.
scrollTop
}
)
;
}
}
focusNode_1
(
priorFocusedElem
)
;
for
(
var
i
=
0
;
i
<
ancestors
.
length
;
i
+
+
)
{
var
info
=
ancestors
[
i
]
;
info
.
element
.
scrollLeft
=
info
.
left
;
info
.
element
.
scrollTop
=
info
.
top
;
}
}
}
function
getSelection
1
(
input
)
{
var
selection
=
void
0
;
if
(
'
selectionStart
'
in
input
)
{
selection
=
{
start
:
input
.
selectionStart
end
:
input
.
selectionEnd
}
;
}
else
{
selection
=
getOffsets
(
input
)
;
}
return
selection
|
|
{
start
:
0
end
:
0
}
;
}
function
setSelection
(
input
offsets
)
{
var
start
=
offsets
.
start
end
=
offsets
.
end
;
if
(
end
=
=
=
undefined
)
{
end
=
start
;
}
if
(
'
selectionStart
'
in
input
)
{
input
.
selectionStart
=
start
;
input
.
selectionEnd
=
Math
.
min
(
end
input
.
value
.
length
)
;
}
else
{
setOffsets
(
input
offsets
)
;
}
}
var
skipSelectionChangeEvent
=
ExecutionEnvironment_1
.
canUseDOM
&
&
'
documentMode
'
in
document
&
&
document
.
documentMode
<
=
11
;
var
eventTypes
3
=
{
select
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onSelect
'
captured
:
'
onSelectCapture
'
}
dependencies
:
[
'
topBlur
'
'
topContextMenu
'
'
topFocus
'
'
topKeyDown
'
'
topKeyUp
'
'
topMouseDown
'
'
topMouseUp
'
'
topSelectionChange
'
]
}
}
;
var
activeElement
1
=
null
;
var
activeElementInst
1
=
null
;
var
lastSelection
=
null
;
var
mouseDown
=
false
;
function
getSelection
(
node
)
{
if
(
'
selectionStart
'
in
node
&
&
hasSelectionCapabilities
(
node
)
)
{
return
{
start
:
node
.
selectionStart
end
:
node
.
selectionEnd
}
;
}
else
if
(
window
.
getSelection
)
{
var
selection
=
window
.
getSelection
(
)
;
return
{
anchorNode
:
selection
.
anchorNode
anchorOffset
:
selection
.
anchorOffset
focusNode
:
selection
.
focusNode
focusOffset
:
selection
.
focusOffset
}
;
}
}
function
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
{
if
(
mouseDown
|
|
activeElement
1
=
=
null
|
|
activeElement
1
!
=
=
getActiveElement_1
(
)
)
{
return
null
;
}
var
currentSelection
=
getSelection
(
activeElement
1
)
;
if
(
!
lastSelection
|
|
!
shallowEqual_1
(
lastSelection
currentSelection
)
)
{
lastSelection
=
currentSelection
;
var
syntheticEvent
=
SyntheticEvent
.
getPooled
(
eventTypes
3
.
select
activeElementInst
1
nativeEvent
nativeEventTarget
)
;
syntheticEvent
.
type
=
'
select
'
;
syntheticEvent
.
target
=
activeElement
1
;
accumulateTwoPhaseDispatches
(
syntheticEvent
)
;
return
syntheticEvent
;
}
return
null
;
}
var
SelectEventPlugin
=
{
eventTypes
:
eventTypes
3
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
doc
=
nativeEventTarget
.
window
=
=
=
nativeEventTarget
?
nativeEventTarget
.
document
:
nativeEventTarget
.
nodeType
=
=
=
DOCUMENT_NODE
?
nativeEventTarget
:
nativeEventTarget
.
ownerDocument
;
if
(
!
doc
|
|
!
isListeningToAllDependencies
(
'
onSelect
'
doc
)
)
{
return
null
;
}
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
switch
(
topLevelType
)
{
case
'
topFocus
'
:
if
(
isTextInputElement
(
targetNode
)
|
|
targetNode
.
contentEditable
=
=
=
'
true
'
)
{
activeElement
1
=
targetNode
;
activeElementInst
1
=
targetInst
;
lastSelection
=
null
;
}
break
;
case
'
topBlur
'
:
activeElement
1
=
null
;
activeElementInst
1
=
null
;
lastSelection
=
null
;
break
;
case
'
topMouseDown
'
:
mouseDown
=
true
;
break
;
case
'
topContextMenu
'
:
case
'
topMouseUp
'
:
mouseDown
=
false
;
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
case
'
topSelectionChange
'
:
if
(
skipSelectionChangeEvent
)
{
break
;
}
case
'
topKeyDown
'
:
case
'
topKeyUp
'
:
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
}
return
null
;
}
}
;
var
AnimationEventInterface
=
{
animationName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
;
function
SyntheticAnimationEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticAnimationEvent
AnimationEventInterface
)
;
var
ClipboardEventInterface
=
{
clipboardData
:
function
(
event
)
{
return
'
clipboardData
'
in
event
?
event
.
clipboardData
:
window
.
clipboardData
;
}
}
;
function
SyntheticClipboardEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticClipboardEvent
ClipboardEventInterface
)
;
var
FocusEventInterface
=
{
relatedTarget
:
null
}
;
function
SyntheticFocusEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticFocusEvent
FocusEventInterface
)
;
function
getEventCharCode
(
nativeEvent
)
{
var
charCode
;
var
keyCode
=
nativeEvent
.
keyCode
;
if
(
'
charCode
'
in
nativeEvent
)
{
charCode
=
nativeEvent
.
charCode
;
if
(
charCode
=
=
=
0
&
&
keyCode
=
=
=
13
)
{
charCode
=
13
;
}
}
else
{
charCode
=
keyCode
;
}
if
(
charCode
>
=
32
|
|
charCode
=
=
=
13
)
{
return
charCode
;
}
return
0
;
}
var
normalizeKey
=
{
Esc
:
'
Escape
'
Spacebar
:
'
'
Left
:
'
ArrowLeft
'
Up
:
'
ArrowUp
'
Right
:
'
ArrowRight
'
Down
:
'
ArrowDown
'
Del
:
'
Delete
'
Win
:
'
OS
'
Menu
:
'
ContextMenu
'
Apps
:
'
ContextMenu
'
Scroll
:
'
ScrollLock
'
MozPrintableKey
:
'
Unidentified
'
}
;
var
translateToKey
=
{
'
8
'
:
'
Backspace
'
'
9
'
:
'
Tab
'
'
12
'
:
'
Clear
'
'
13
'
:
'
Enter
'
'
16
'
:
'
Shift
'
'
17
'
:
'
Control
'
'
18
'
:
'
Alt
'
'
19
'
:
'
Pause
'
'
20
'
:
'
CapsLock
'
'
27
'
:
'
Escape
'
'
32
'
:
'
'
'
33
'
:
'
PageUp
'
'
34
'
:
'
PageDown
'
'
35
'
:
'
End
'
'
36
'
:
'
Home
'
'
37
'
:
'
ArrowLeft
'
'
38
'
:
'
ArrowUp
'
'
39
'
:
'
ArrowRight
'
'
40
'
:
'
ArrowDown
'
'
45
'
:
'
Insert
'
'
46
'
:
'
Delete
'
'
112
'
:
'
F1
'
'
113
'
:
'
F2
'
'
114
'
:
'
F3
'
'
115
'
:
'
F4
'
'
116
'
:
'
F5
'
'
117
'
:
'
F6
'
'
118
'
:
'
F7
'
'
119
'
:
'
F8
'
'
120
'
:
'
F9
'
'
121
'
:
'
F10
'
'
122
'
:
'
F11
'
'
123
'
:
'
F12
'
'
144
'
:
'
NumLock
'
'
145
'
:
'
ScrollLock
'
'
224
'
:
'
Meta
'
}
;
function
getEventKey
(
nativeEvent
)
{
if
(
nativeEvent
.
key
)
{
var
key
=
normalizeKey
[
nativeEvent
.
key
]
|
|
nativeEvent
.
key
;
if
(
key
!
=
=
'
Unidentified
'
)
{
return
key
;
}
}
if
(
nativeEvent
.
type
=
=
=
'
keypress
'
)
{
var
charCode
=
getEventCharCode
(
nativeEvent
)
;
return
charCode
=
=
=
13
?
'
Enter
'
:
String
.
fromCharCode
(
charCode
)
;
}
if
(
nativeEvent
.
type
=
=
=
'
keydown
'
|
|
nativeEvent
.
type
=
=
=
'
keyup
'
)
{
return
translateToKey
[
nativeEvent
.
keyCode
]
|
|
'
Unidentified
'
;
}
return
'
'
;
}
var
KeyboardEventInterface
=
{
key
:
getEventKey
location
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
repeat
:
null
locale
:
null
getModifierState
:
getEventModifierState
charCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
return
0
;
}
keyCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
which
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
}
;
function
SyntheticKeyboardEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticKeyboardEvent
KeyboardEventInterface
)
;
var
DragEventInterface
=
{
dataTransfer
:
null
}
;
function
SyntheticDragEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticMouseEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticMouseEvent
.
augmentClass
(
SyntheticDragEvent
DragEventInterface
)
;
var
TouchEventInterface
=
{
touches
:
null
targetTouches
:
null
changedTouches
:
null
altKey
:
null
metaKey
:
null
ctrlKey
:
null
shiftKey
:
null
getModifierState
:
getEventModifierState
}
;
function
SyntheticTouchEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticTouchEvent
TouchEventInterface
)
;
var
TransitionEventInterface
=
{
propertyName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
;
function
SyntheticTransitionEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticTransitionEvent
TransitionEventInterface
)
;
var
WheelEventInterface
=
{
deltaX
:
function
(
event
)
{
return
'
deltaX
'
in
event
?
event
.
deltaX
:
'
wheelDeltaX
'
in
event
?
-
event
.
wheelDeltaX
:
0
;
}
deltaY
:
function
(
event
)
{
return
'
deltaY
'
in
event
?
event
.
deltaY
:
'
wheelDeltaY
'
in
event
?
-
event
.
wheelDeltaY
:
'
wheelDelta
'
in
event
?
-
event
.
wheelDelta
:
0
;
}
deltaZ
:
null
deltaMode
:
null
}
;
function
SyntheticWheelEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
return
SyntheticMouseEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticMouseEvent
.
augmentClass
(
SyntheticWheelEvent
WheelEventInterface
)
;
var
eventTypes
4
=
{
}
;
var
topLevelEventsToDispatchConfig
=
{
}
;
[
'
abort
'
'
animationEnd
'
'
animationIteration
'
'
animationStart
'
'
blur
'
'
cancel
'
'
canPlay
'
'
canPlayThrough
'
'
click
'
'
close
'
'
contextMenu
'
'
copy
'
'
cut
'
'
doubleClick
'
'
drag
'
'
dragEnd
'
'
dragEnter
'
'
dragExit
'
'
dragLeave
'
'
dragOver
'
'
dragStart
'
'
drop
'
'
durationChange
'
'
emptied
'
'
encrypted
'
'
ended
'
'
error
'
'
focus
'
'
input
'
'
invalid
'
'
keyDown
'
'
keyPress
'
'
keyUp
'
'
load
'
'
loadedData
'
'
loadedMetadata
'
'
loadStart
'
'
mouseDown
'
'
mouseMove
'
'
mouseOut
'
'
mouseOver
'
'
mouseUp
'
'
paste
'
'
pause
'
'
play
'
'
playing
'
'
progress
'
'
rateChange
'
'
reset
'
'
scroll
'
'
seeked
'
'
seeking
'
'
stalled
'
'
submit
'
'
suspend
'
'
timeUpdate
'
'
toggle
'
'
touchCancel
'
'
touchEnd
'
'
touchMove
'
'
touchStart
'
'
transitionEnd
'
'
volumeChange
'
'
waiting
'
'
wheel
'
]
.
forEach
(
function
(
event
)
{
var
capitalizedEvent
=
event
[
0
]
.
toUpperCase
(
)
+
event
.
slice
(
1
)
;
var
onEvent
=
'
on
'
+
capitalizedEvent
;
var
topEvent
=
'
top
'
+
capitalizedEvent
;
var
type
=
{
phasedRegistrationNames
:
{
bubbled
:
onEvent
captured
:
onEvent
+
'
Capture
'
}
dependencies
:
[
topEvent
]
}
;
eventTypes
4
[
event
]
=
type
;
topLevelEventsToDispatchConfig
[
topEvent
]
=
type
;
}
)
;
var
SimpleEventPlugin
=
{
eventTypes
:
eventTypes
4
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
dispatchConfig
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
if
(
!
dispatchConfig
)
{
return
null
;
}
var
EventConstructor
;
switch
(
topLevelType
)
{
case
'
topKeyPress
'
:
if
(
getEventCharCode
(
nativeEvent
)
=
=
=
0
)
{
return
null
;
}
case
'
topKeyDown
'
:
case
'
topKeyUp
'
:
EventConstructor
=
SyntheticKeyboardEvent
;
break
;
case
'
topBlur
'
:
case
'
topFocus
'
:
EventConstructor
=
SyntheticFocusEvent
;
break
;
case
'
topClick
'
:
if
(
nativeEvent
.
button
=
=
=
2
)
{
return
null
;
}
case
'
topDoubleClick
'
:
case
'
topMouseDown
'
:
case
'
topMouseMove
'
:
case
'
topMouseUp
'
:
case
'
topMouseOut
'
:
case
'
topMouseOver
'
:
case
'
topContextMenu
'
:
EventConstructor
=
SyntheticMouseEvent
;
break
;
case
'
topDrag
'
:
case
'
topDragEnd
'
:
case
'
topDragEnter
'
:
case
'
topDragExit
'
:
case
'
topDragLeave
'
:
case
'
topDragOver
'
:
case
'
topDragStart
'
:
case
'
topDrop
'
:
EventConstructor
=
SyntheticDragEvent
;
break
;
case
'
topTouchCancel
'
:
case
'
topTouchEnd
'
:
case
'
topTouchMove
'
:
case
'
topTouchStart
'
:
EventConstructor
=
SyntheticTouchEvent
;
break
;
case
'
topAnimationEnd
'
:
case
'
topAnimationIteration
'
:
case
'
topAnimationStart
'
:
EventConstructor
=
SyntheticAnimationEvent
;
break
;
case
'
topTransitionEnd
'
:
EventConstructor
=
SyntheticTransitionEvent
;
break
;
case
'
topScroll
'
:
EventConstructor
=
SyntheticUIEvent
;
break
;
case
'
topWheel
'
:
EventConstructor
=
SyntheticWheelEvent
;
break
;
case
'
topCopy
'
:
case
'
topCut
'
:
case
'
topPaste
'
:
EventConstructor
=
SyntheticClipboardEvent
;
break
;
default
:
EventConstructor
=
SyntheticEvent
;
break
;
}
var
event
=
EventConstructor
.
getPooled
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
}
;
setHandleTopLevel
(
handleTopLevel
)
;
injection
1
.
injectEventPluginOrder
(
DOMEventPluginOrder
)
;
injection
2
.
injectComponentTree
(
ReactDOMComponentTree
)
;
injection
1
.
injectEventPluginsByName
(
{
SimpleEventPlugin
:
SimpleEventPlugin
EnterLeaveEventPlugin
:
EnterLeaveEventPlugin
ChangeEventPlugin
:
ChangeEventPlugin
SelectEventPlugin
:
SelectEventPlugin
BeforeInputEventPlugin
:
BeforeInputEventPlugin
}
)
;
var
enableAsyncSubtreeAPI
=
true
;
var
enableAsyncSchedulingByDefaultInReactDOM
=
false
;
var
enableCreateRoot
=
false
;
var
enableUserTimingAPI
=
false
;
var
enableMutatingReconciler
=
true
;
var
enableNoopReconciler
=
false
;
var
enablePersistentReconciler
=
false
;
var
debugRenderPhaseSideEffects
=
false
;
var
emptyObject
=
{
}
;
var
emptyObject_1
=
emptyObject
;
var
valueStack
=
[
]
;
var
index
=
-
1
;
function
createCursor
(
defaultValue
)
{
return
{
current
:
defaultValue
}
;
}
function
pop
(
cursor
fiber
)
{
if
(
index
<
0
)
{
return
;
}
cursor
.
current
=
valueStack
[
index
]
;
valueStack
[
index
]
=
null
;
index
-
-
;
}
function
push
(
cursor
value
fiber
)
{
index
+
+
;
valueStack
[
index
]
=
cursor
.
current
;
cursor
.
current
=
value
;
}
function
reset
1
(
)
{
while
(
index
>
-
1
)
{
valueStack
[
index
]
=
null
;
index
-
-
;
}
}
var
describeComponentFrame
=
function
(
name
source
ownerName
)
{
return
'
\
n
in
'
+
(
name
|
|
'
Unknown
'
)
+
(
source
?
'
(
at
'
+
source
.
fileName
.
replace
(
/
^
.
*
[
\
\
\
/
]
/
'
'
)
+
'
:
'
+
source
.
lineNumber
+
'
)
'
:
ownerName
?
'
(
created
by
'
+
ownerName
+
'
)
'
:
'
'
)
;
}
;
function
describeFiber
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
IndeterminateComponent
:
case
FunctionalComponent
:
case
ClassComponent
:
case
HostComponent
:
var
owner
=
fiber
.
_debugOwner
;
var
source
=
fiber
.
_debugSource
;
var
name
=
getComponentName
(
fiber
)
;
var
ownerName
=
null
;
if
(
owner
)
{
ownerName
=
getComponentName
(
owner
)
;
}
return
describeComponentFrame
(
name
source
ownerName
)
;
default
:
return
'
'
;
}
}
function
getStackAddendumByWorkInProgressFiber
(
workInProgress
)
{
var
info
=
'
'
;
var
node
=
workInProgress
;
do
{
info
+
=
describeFiber
(
node
)
;
node
=
node
[
'
return
'
]
;
}
while
(
node
)
;
return
info
;
}
var
reactEmoji
=
'
\
u269B
'
;
var
warningEmoji
=
'
\
u26D4
'
;
var
supportsUserTiming
=
typeof
performance
!
=
=
'
undefined
'
&
&
typeof
performance
.
mark
=
=
=
'
function
'
&
&
typeof
performance
.
clearMarks
=
=
=
'
function
'
&
&
typeof
performance
.
measure
=
=
=
'
function
'
&
&
typeof
performance
.
clearMeasures
=
=
=
'
function
'
;
var
currentFiber
=
null
;
var
currentPhase
=
null
;
var
currentPhaseFiber
=
null
;
var
isCommitting
=
false
;
var
hasScheduledUpdateInCurrentCommit
=
false
;
var
hasScheduledUpdateInCurrentPhase
=
false
;
var
commitCountInCurrentWorkLoop
=
0
;
var
effectCountInCurrentCommit
=
0
;
var
isWaitingForCallback
=
false
;
var
labelsInCurrentCommit
=
new
Set
(
)
;
var
formatMarkName
=
function
(
markName
)
{
return
reactEmoji
+
'
'
+
markName
;
}
;
var
formatLabel
=
function
(
label
warning
)
{
var
prefix
=
warning
?
warningEmoji
+
'
'
:
reactEmoji
+
'
'
;
var
suffix
=
warning
?
'
Warning
:
'
+
warning
:
'
'
;
return
'
'
+
prefix
+
label
+
suffix
;
}
;
var
beginMark
=
function
(
markName
)
{
performance
.
mark
(
formatMarkName
(
markName
)
)
;
}
;
var
clearMark
=
function
(
markName
)
{
performance
.
clearMarks
(
formatMarkName
(
markName
)
)
;
}
;
var
endMark
=
function
(
label
markName
warning
)
{
var
formattedMarkName
=
formatMarkName
(
markName
)
;
var
formattedLabel
=
formatLabel
(
label
warning
)
;
try
{
performance
.
measure
(
formattedLabel
formattedMarkName
)
;
}
catch
(
err
)
{
}
performance
.
clearMarks
(
formattedMarkName
)
;
performance
.
clearMeasures
(
formattedLabel
)
;
}
;
var
getFiberMarkName
=
function
(
label
debugID
)
{
return
label
+
'
(
#
'
+
debugID
+
'
)
'
;
}
;
var
getFiberLabel
=
function
(
componentName
isMounted
phase
)
{
if
(
phase
=
=
=
null
)
{
return
componentName
+
'
[
'
+
(
isMounted
?
'
update
'
:
'
mount
'
)
+
'
]
'
;
}
else
{
return
componentName
+
'
.
'
+
phase
;
}
}
;
var
beginFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
if
(
isCommitting
&
&
labelsInCurrentCommit
.
has
(
label
)
)
{
return
false
;
}
labelsInCurrentCommit
.
add
(
label
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
beginMark
(
markName
)
;
return
true
;
}
;
var
clearFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
clearMark
(
markName
)
;
}
;
var
endFiberMark
=
function
(
fiber
phase
warning
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
endMark
(
label
markName
warning
)
;
}
;
var
shouldIgnoreFiber
=
function
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
case
ReturnComponent
:
case
Fragment
:
return
true
;
default
:
return
false
;
}
}
;
var
clearPendingPhaseMeasurement
=
function
(
)
{
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
clearFiberMark
(
currentPhaseFiber
currentPhase
)
;
}
currentPhaseFiber
=
null
;
currentPhase
=
null
;
hasScheduledUpdateInCurrentPhase
=
false
;
}
;
var
pauseTimers
=
function
(
)
{
var
fiber
=
currentFiber
;
while
(
fiber
)
{
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
endFiberMark
(
fiber
null
null
)
;
}
fiber
=
fiber
[
'
return
'
]
;
}
}
;
var
resumeTimersRecursively
=
function
(
fiber
)
{
if
(
fiber
[
'
return
'
]
!
=
=
null
)
{
resumeTimersRecursively
(
fiber
[
'
return
'
]
)
;
}
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
beginFiberMark
(
fiber
null
)
;
}
}
;
var
resumeTimers
=
function
(
)
{
if
(
currentFiber
!
=
=
null
)
{
resumeTimersRecursively
(
currentFiber
)
;
}
}
;
function
recordEffect
(
)
{
if
(
enableUserTimingAPI
)
{
effectCountInCurrentCommit
+
+
;
}
}
function
recordScheduleUpdate
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
isCommitting
)
{
hasScheduledUpdateInCurrentCommit
=
true
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhase
!
=
=
'
componentWillMount
'
&
&
currentPhase
!
=
=
'
componentWillReceiveProps
'
)
{
hasScheduledUpdateInCurrentPhase
=
true
;
}
}
}
function
startRequestCallbackTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
&
&
!
isWaitingForCallback
)
{
isWaitingForCallback
=
true
;
beginMark
(
'
(
Waiting
for
async
callback
.
.
.
)
'
)
;
}
}
}
function
stopRequestCallbackTimer
(
didExpire
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
)
{
isWaitingForCallback
=
false
;
var
warning
=
didExpire
?
'
React
was
blocked
by
main
thread
'
:
null
;
endMark
(
'
(
Waiting
for
async
callback
.
.
.
)
'
'
(
Waiting
for
async
callback
.
.
.
)
'
warning
)
;
}
}
}
function
startWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
;
if
(
!
beginFiberMark
(
fiber
null
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
true
;
}
}
function
cancelWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
clearFiberMark
(
fiber
null
)
;
}
}
function
stopWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
[
'
return
'
]
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
endFiberMark
(
fiber
null
null
)
;
}
}
function
stopFailedWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
[
'
return
'
]
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
var
warning
=
'
An
error
was
thrown
inside
this
error
boundary
'
;
endFiberMark
(
fiber
null
warning
)
;
}
}
function
startPhaseTimer
(
fiber
phase
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
clearPendingPhaseMeasurement
(
)
;
if
(
!
beginFiberMark
(
fiber
phase
)
)
{
return
;
}
currentPhaseFiber
=
fiber
;
currentPhase
=
phase
;
}
}
function
stopPhaseTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
var
warning
=
hasScheduledUpdateInCurrentPhase
?
'
Scheduled
a
cascading
update
'
:
null
;
endFiberMark
(
currentPhaseFiber
currentPhase
warning
)
;
}
currentPhase
=
null
;
currentPhaseFiber
=
null
;
}
}
function
startWorkLoopTimer
(
nextUnitOfWork
)
{
if
(
enableUserTimingAPI
)
{
currentFiber
=
nextUnitOfWork
;
if
(
!
supportsUserTiming
)
{
return
;
}
commitCountInCurrentWorkLoop
=
0
;
beginMark
(
'
(
React
Tree
Reconciliation
)
'
)
;
resumeTimers
(
)
;
}
}
function
stopWorkLoopTimer
(
interruptedBy
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
interruptedBy
!
=
=
null
)
{
if
(
interruptedBy
.
tag
=
=
=
HostRoot
)
{
warning
=
'
A
top
-
level
update
interrupted
the
previous
render
'
;
}
else
{
var
componentName
=
getComponentName
(
interruptedBy
)
|
|
'
Unknown
'
;
warning
=
'
An
update
to
'
+
componentName
+
'
interrupted
the
previous
render
'
;
}
}
else
if
(
commitCountInCurrentWorkLoop
>
1
)
{
warning
=
'
There
were
cascading
updates
'
;
}
commitCountInCurrentWorkLoop
=
0
;
pauseTimers
(
)
;
endMark
(
'
(
React
Tree
Reconciliation
)
'
'
(
React
Tree
Reconciliation
)
'
warning
)
;
}
}
function
startCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
isCommitting
=
true
;
hasScheduledUpdateInCurrentCommit
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
beginMark
(
'
(
Committing
Changes
)
'
)
;
}
}
function
stopCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
hasScheduledUpdateInCurrentCommit
)
{
warning
=
'
Lifecycle
hook
scheduled
a
cascading
update
'
;
}
else
if
(
commitCountInCurrentWorkLoop
>
0
)
{
warning
=
'
Caused
by
a
cascading
update
in
earlier
commit
'
;
}
hasScheduledUpdateInCurrentCommit
=
false
;
commitCountInCurrentWorkLoop
+
+
;
isCommitting
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
endMark
(
'
(
Committing
Changes
)
'
'
(
Committing
Changes
)
'
warning
)
;
}
}
function
startCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Host
Effects
)
'
)
;
}
}
function
stopCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Committing
Host
Effects
:
'
+
count
+
'
Total
)
'
'
(
Committing
Host
Effects
)
'
null
)
;
}
}
function
startCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Calling
Lifecycle
Methods
)
'
)
;
}
}
function
stopCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Calling
Lifecycle
Methods
:
'
+
count
+
'
Total
)
'
'
(
Calling
Lifecycle
Methods
)
'
null
)
;
}
}
var
contextStackCursor
=
createCursor
(
emptyObject_1
)
;
var
didPerformWorkStackCursor
=
createCursor
(
false
)
;
var
previousContext
=
emptyObject_1
;
function
getUnmaskedContext
(
workInProgress
)
{
var
hasOwnContext
=
isContextProvider
(
workInProgress
)
;
if
(
hasOwnContext
)
{
return
previousContext
;
}
return
contextStackCursor
.
current
;
}
function
cacheContext
(
workInProgress
unmaskedContext
maskedContext
)
{
var
instance
=
workInProgress
.
stateNode
;
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
unmaskedContext
;
instance
.
__reactInternalMemoizedMaskedChildContext
=
maskedContext
;
}
function
getMaskedContext
(
workInProgress
unmaskedContext
)
{
var
type
=
workInProgress
.
type
;
var
contextTypes
=
type
.
contextTypes
;
if
(
!
contextTypes
)
{
return
emptyObject_1
;
}
var
instance
=
workInProgress
.
stateNode
;
if
(
instance
&
&
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
=
=
unmaskedContext
)
{
return
instance
.
__reactInternalMemoizedMaskedChildContext
;
}
var
context
=
{
}
;
for
(
var
key
in
contextTypes
)
{
context
[
key
]
=
unmaskedContext
[
key
]
;
}
if
(
instance
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
context
;
}
function
hasContextChanged
(
)
{
return
didPerformWorkStackCursor
.
current
;
}
function
isContextConsumer
(
fiber
)
{
return
fiber
.
tag
=
=
=
ClassComponent
&
&
fiber
.
type
.
contextTypes
!
=
null
;
}
function
isContextProvider
(
fiber
)
{
return
fiber
.
tag
=
=
=
ClassComponent
&
&
fiber
.
type
.
childContextTypes
!
=
null
;
}
function
popContextProvider
(
fiber
)
{
if
(
!
isContextProvider
(
fiber
)
)
{
return
;
}
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
popTopLevelContextObject
(
fiber
)
{
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
pushTopLevelContextObject
(
fiber
context
didChange
)
{
!
(
contextStackCursor
.
cursor
=
=
null
)
?
reactProdInvariant
(
'
168
'
)
:
void
0
;
push
(
contextStackCursor
context
fiber
)
;
push
(
didPerformWorkStackCursor
didChange
fiber
)
;
}
function
processChildContext
(
fiber
parentContext
)
{
var
instance
=
fiber
.
stateNode
;
var
childContextTypes
=
fiber
.
type
.
childContextTypes
;
if
(
typeof
instance
.
getChildContext
!
=
=
'
function
'
)
{
return
parentContext
;
}
var
childContext
=
void
0
;
startPhaseTimer
(
fiber
'
getChildContext
'
)
;
childContext
=
instance
.
getChildContext
(
)
;
stopPhaseTimer
(
)
;
for
(
var
contextKey
in
childContext
)
{
!
(
contextKey
in
childContextTypes
)
?
reactProdInvariant
(
'
108
'
getComponentName
(
fiber
)
|
|
'
Unknown
'
contextKey
)
:
void
0
;
}
return
_assign
(
{
}
parentContext
childContext
)
;
}
function
pushContextProvider
(
workInProgress
)
{
if
(
!
isContextProvider
(
workInProgress
)
)
{
return
false
;
}
var
instance
=
workInProgress
.
stateNode
;
var
memoizedMergedChildContext
=
instance
&
&
instance
.
__reactInternalMemoizedMergedChildContext
|
|
emptyObject_1
;
previousContext
=
contextStackCursor
.
current
;
push
(
contextStackCursor
memoizedMergedChildContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didPerformWorkStackCursor
.
current
workInProgress
)
;
return
true
;
}
function
invalidateContextProvider
(
workInProgress
didChange
)
{
var
instance
=
workInProgress
.
stateNode
;
!
instance
?
reactProdInvariant
(
'
169
'
)
:
void
0
;
if
(
didChange
)
{
var
mergedContext
=
processChildContext
(
workInProgress
previousContext
)
;
instance
.
__reactInternalMemoizedMergedChildContext
=
mergedContext
;
pop
(
didPerformWorkStackCursor
workInProgress
)
;
pop
(
contextStackCursor
workInProgress
)
;
push
(
contextStackCursor
mergedContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
else
{
pop
(
didPerformWorkStackCursor
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
}
function
resetContext
(
)
{
previousContext
=
emptyObject_1
;
contextStackCursor
.
current
=
emptyObject_1
;
didPerformWorkStackCursor
.
current
=
false
;
}
function
findCurrentUnmaskedContext
(
fiber
)
{
!
(
isFiberMounted
(
fiber
)
&
&
fiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
170
'
)
:
void
0
;
var
node
=
fiber
;
while
(
node
.
tag
!
=
=
HostRoot
)
{
if
(
isContextProvider
(
node
)
)
{
return
node
.
stateNode
.
__reactInternalMemoizedMergedChildContext
;
}
var
parent
=
node
[
'
return
'
]
;
!
parent
?
reactProdInvariant
(
'
171
'
)
:
void
0
;
node
=
parent
;
}
return
node
.
stateNode
.
context
;
}
var
NoWork
=
0
;
var
Sync
=
1
;
var
Never
=
2147483647
;
var
UNIT_SIZE
=
10
;
var
MAGIC_NUMBER_OFFSET
=
2
;
function
msToExpirationTime
(
ms
)
{
return
(
ms
/
UNIT_SIZE
|
0
)
+
MAGIC_NUMBER_OFFSET
;
}
function
expirationTimeToMs
(
expirationTime
)
{
return
(
expirationTime
-
MAGIC_NUMBER_OFFSET
)
*
UNIT_SIZE
;
}
function
ceiling
(
num
precision
)
{
return
(
(
num
/
precision
|
0
)
+
1
)
*
precision
;
}
function
computeExpirationBucket
(
currentTime
expirationInMs
bucketSizeMs
)
{
return
ceiling
(
currentTime
+
expirationInMs
/
UNIT_SIZE
bucketSizeMs
/
UNIT_SIZE
)
;
}
var
NoContext
=
0
;
var
AsyncUpdates
=
1
;
function
FiberNode
(
tag
key
internalContextTag
)
{
this
.
tag
=
tag
;
this
.
key
=
key
;
this
.
type
=
null
;
this
.
stateNode
=
null
;
this
[
'
return
'
]
=
null
;
this
.
child
=
null
;
this
.
sibling
=
null
;
this
.
index
=
0
;
this
.
ref
=
null
;
this
.
pendingProps
=
null
;
this
.
memoizedProps
=
null
;
this
.
updateQueue
=
null
;
this
.
memoizedState
=
null
;
this
.
internalContextTag
=
internalContextTag
;
this
.
effectTag
=
NoEffect
;
this
.
nextEffect
=
null
;
this
.
firstEffect
=
null
;
this
.
lastEffect
=
null
;
this
.
expirationTime
=
NoWork
;
this
.
alternate
=
null
;
}
var
createFiber
=
function
(
tag
key
internalContextTag
)
{
return
new
FiberNode
(
tag
key
internalContextTag
)
;
}
;
function
shouldConstruct
(
Component
)
{
return
!
!
(
Component
.
prototype
&
&
Component
.
prototype
.
isReactComponent
)
;
}
function
createWorkInProgress
(
current
pendingProps
expirationTime
)
{
var
workInProgress
=
current
.
alternate
;
if
(
workInProgress
=
=
=
null
)
{
workInProgress
=
createFiber
(
current
.
tag
current
.
key
current
.
internalContextTag
)
;
workInProgress
.
type
=
current
.
type
;
workInProgress
.
stateNode
=
current
.
stateNode
;
workInProgress
.
alternate
=
current
;
current
.
alternate
=
workInProgress
;
}
else
{
workInProgress
.
effectTag
=
NoEffect
;
workInProgress
.
nextEffect
=
null
;
workInProgress
.
firstEffect
=
null
;
workInProgress
.
lastEffect
=
null
;
}
workInProgress
.
expirationTime
=
expirationTime
;
workInProgress
.
pendingProps
=
pendingProps
;
workInProgress
.
child
=
current
.
child
;
workInProgress
.
memoizedProps
=
current
.
memoizedProps
;
workInProgress
.
memoizedState
=
current
.
memoizedState
;
workInProgress
.
updateQueue
=
current
.
updateQueue
;
workInProgress
.
sibling
=
current
.
sibling
;
workInProgress
.
index
=
current
.
index
;
workInProgress
.
ref
=
current
.
ref
;
return
workInProgress
;
}
function
createHostRootFiber
(
)
{
var
fiber
=
createFiber
(
HostRoot
null
NoContext
)
;
return
fiber
;
}
function
createFiberFromElement
(
element
internalContextTag
expirationTime
)
{
var
fiber
=
void
0
;
var
type
=
element
.
type
key
=
element
.
key
;
if
(
typeof
type
=
=
=
'
function
'
)
{
fiber
=
shouldConstruct
(
type
)
?
createFiber
(
ClassComponent
key
internalContextTag
)
:
createFiber
(
IndeterminateComponent
key
internalContextTag
)
;
fiber
.
type
=
type
;
fiber
.
pendingProps
=
element
.
props
;
}
else
if
(
typeof
type
=
=
=
'
string
'
)
{
fiber
=
createFiber
(
HostComponent
key
internalContextTag
)
;
fiber
.
type
=
type
;
fiber
.
pendingProps
=
element
.
props
;
}
else
if
(
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
&
&
typeof
type
.
tag
=
=
=
'
number
'
)
{
fiber
=
type
;
fiber
.
pendingProps
=
element
.
props
;
}
else
{
var
info
=
'
'
;
reactProdInvariant
(
'
130
'
type
=
=
null
?
type
:
typeof
type
info
)
;
}
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromFragment
(
elements
internalContextTag
expirationTime
key
)
{
var
fiber
=
createFiber
(
Fragment
key
internalContextTag
)
;
fiber
.
pendingProps
=
elements
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromText
(
content
internalContextTag
expirationTime
)
{
var
fiber
=
createFiber
(
HostText
null
internalContextTag
)
;
fiber
.
pendingProps
=
content
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromHostInstanceForDeletion
(
)
{
var
fiber
=
createFiber
(
HostComponent
null
NoContext
)
;
fiber
.
type
=
'
DELETED
'
;
return
fiber
;
}
function
createFiberFromCall
(
call
internalContextTag
expirationTime
)
{
var
fiber
=
createFiber
(
CallComponent
call
.
key
internalContextTag
)
;
fiber
.
type
=
call
.
handler
;
fiber
.
pendingProps
=
call
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromReturn
(
returnNode
internalContextTag
expirationTime
)
{
var
fiber
=
createFiber
(
ReturnComponent
null
internalContextTag
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromPortal
(
portal
internalContextTag
expirationTime
)
{
var
fiber
=
createFiber
(
HostPortal
portal
.
key
internalContextTag
)
;
fiber
.
pendingProps
=
portal
.
children
|
|
[
]
;
fiber
.
expirationTime
=
expirationTime
;
fiber
.
stateNode
=
{
containerInfo
:
portal
.
containerInfo
pendingChildren
:
null
implementation
:
portal
.
implementation
}
;
return
fiber
;
}
function
createFiberRoot
(
containerInfo
hydrate
)
{
var
uninitializedFiber
=
createHostRootFiber
(
)
;
var
root
=
{
current
:
uninitializedFiber
containerInfo
:
containerInfo
pendingChildren
:
null
remainingExpirationTime
:
NoWork
isReadyForCommit
:
false
finishedWork
:
null
context
:
null
pendingContext
:
null
hydrate
:
hydrate
nextScheduledRoot
:
null
}
;
uninitializedFiber
.
stateNode
=
root
;
return
root
;
}
var
onCommitFiberRoot
=
null
;
var
onCommitFiberUnmount
=
null
;
function
catchErrors
(
fn
)
{
return
function
(
arg
)
{
try
{
return
fn
(
arg
)
;
}
catch
(
err
)
{
}
}
;
}
function
injectInternals
(
internals
)
{
if
(
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
=
=
=
'
undefined
'
)
{
return
false
;
}
var
hook
=
__REACT_DEVTOOLS_GLOBAL_HOOK__
;
if
(
hook
.
isDisabled
)
{
return
true
;
}
if
(
!
hook
.
supportsFiber
)
{
return
true
;
}
try
{
var
rendererID
=
hook
.
inject
(
internals
)
;
onCommitFiberRoot
=
catchErrors
(
function
(
root
)
{
return
hook
.
onCommitFiberRoot
(
rendererID
root
)
;
}
)
;
onCommitFiberUnmount
=
catchErrors
(
function
(
fiber
)
{
return
hook
.
onCommitFiberUnmount
(
rendererID
fiber
)
;
}
)
;
}
catch
(
err
)
{
}
return
true
;
}
function
onCommitRoot
(
root
)
{
if
(
typeof
onCommitFiberRoot
=
=
=
'
function
'
)
{
onCommitFiberRoot
(
root
)
;
}
}
function
onCommitUnmount
(
fiber
)
{
if
(
typeof
onCommitFiberUnmount
=
=
=
'
function
'
)
{
onCommitFiberUnmount
(
fiber
)
;
}
}
function
createUpdateQueue
(
baseState
)
{
var
queue
=
{
baseState
:
baseState
expirationTime
:
NoWork
first
:
null
last
:
null
callbackList
:
null
hasForceUpdate
:
false
isInitialized
:
false
}
;
return
queue
;
}
function
insertUpdateIntoQueue
(
queue
update
)
{
if
(
queue
.
last
=
=
=
null
)
{
queue
.
first
=
queue
.
last
=
update
;
}
else
{
queue
.
last
.
next
=
update
;
queue
.
last
=
update
;
}
if
(
queue
.
expirationTime
=
=
=
NoWork
|
|
queue
.
expirationTime
>
update
.
expirationTime
)
{
queue
.
expirationTime
=
update
.
expirationTime
;
}
}
function
insertUpdateIntoFiber
(
fiber
update
)
{
var
alternateFiber
=
fiber
.
alternate
;
var
queue1
=
fiber
.
updateQueue
;
if
(
queue1
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
null
)
;
}
var
queue2
=
void
0
;
if
(
alternateFiber
!
=
=
null
)
{
queue2
=
alternateFiber
.
updateQueue
;
if
(
queue2
=
=
=
null
)
{
queue2
=
alternateFiber
.
updateQueue
=
createUpdateQueue
(
null
)
;
}
}
else
{
queue2
=
null
;
}
queue2
=
queue2
!
=
=
queue1
?
queue2
:
null
;
if
(
queue2
=
=
=
null
)
{
insertUpdateIntoQueue
(
queue1
update
)
;
return
;
}
if
(
queue1
.
last
=
=
=
null
|
|
queue2
.
last
=
=
=
null
)
{
insertUpdateIntoQueue
(
queue1
update
)
;
insertUpdateIntoQueue
(
queue2
update
)
;
return
;
}
insertUpdateIntoQueue
(
queue1
update
)
;
queue2
.
last
=
update
;
}
function
getUpdateExpirationTime
(
fiber
)
{
if
(
fiber
.
tag
!
=
=
ClassComponent
&
&
fiber
.
tag
!
=
=
HostRoot
)
{
return
NoWork
;
}
var
updateQueue
=
fiber
.
updateQueue
;
if
(
updateQueue
=
=
=
null
)
{
return
NoWork
;
}
return
updateQueue
.
expirationTime
;
}
function
getStateFromUpdate
(
update
instance
prevState
props
)
{
var
partialState
=
update
.
partialState
;
if
(
typeof
partialState
=
=
=
'
function
'
)
{
var
updateFn
=
partialState
;
if
(
debugRenderPhaseSideEffects
)
{
updateFn
.
call
(
instance
prevState
props
)
;
}
return
updateFn
.
call
(
instance
prevState
props
)
;
}
else
{
return
partialState
;
}
}
function
processUpdateQueue
(
current
workInProgress
queue
instance
props
renderExpirationTime
)
{
if
(
current
!
=
=
null
&
&
current
.
updateQueue
=
=
=
queue
)
{
var
currentQueue
=
queue
;
queue
=
workInProgress
.
updateQueue
=
{
baseState
:
currentQueue
.
baseState
expirationTime
:
currentQueue
.
expirationTime
first
:
currentQueue
.
first
last
:
currentQueue
.
last
isInitialized
:
currentQueue
.
isInitialized
callbackList
:
null
hasForceUpdate
:
false
}
;
}
queue
.
expirationTime
=
NoWork
;
var
state
=
void
0
;
if
(
queue
.
isInitialized
)
{
state
=
queue
.
baseState
;
}
else
{
state
=
queue
.
baseState
=
workInProgress
.
memoizedState
;
queue
.
isInitialized
=
true
;
}
var
dontMutatePrevState
=
true
;
var
update
=
queue
.
first
;
var
didSkip
=
false
;
while
(
update
!
=
=
null
)
{
var
updateExpirationTime
=
update
.
expirationTime
;
if
(
updateExpirationTime
>
renderExpirationTime
)
{
var
remainingExpirationTime
=
queue
.
expirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
|
|
remainingExpirationTime
>
updateExpirationTime
)
{
queue
.
expirationTime
=
updateExpirationTime
;
}
if
(
!
didSkip
)
{
didSkip
=
true
;
queue
.
baseState
=
state
;
}
update
=
update
.
next
;
continue
;
}
if
(
!
didSkip
)
{
queue
.
first
=
update
.
next
;
if
(
queue
.
first
=
=
=
null
)
{
queue
.
last
=
null
;
}
}
var
_partialState
=
void
0
;
if
(
update
.
isReplace
)
{
state
=
getStateFromUpdate
(
update
instance
state
props
)
;
dontMutatePrevState
=
true
;
}
else
{
_partialState
=
getStateFromUpdate
(
update
instance
state
props
)
;
if
(
_partialState
)
{
if
(
dontMutatePrevState
)
{
state
=
_assign
(
{
}
state
_partialState
)
;
}
else
{
state
=
_assign
(
state
_partialState
)
;
}
dontMutatePrevState
=
false
;
}
}
if
(
update
.
isForced
)
{
queue
.
hasForceUpdate
=
true
;
}
if
(
update
.
callback
!
=
=
null
)
{
var
_callbackList
=
queue
.
callbackList
;
if
(
_callbackList
=
=
=
null
)
{
_callbackList
=
queue
.
callbackList
=
[
]
;
}
_callbackList
.
push
(
update
)
;
}
update
=
update
.
next
;
}
if
(
queue
.
callbackList
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
}
else
if
(
queue
.
first
=
=
=
null
&
&
!
queue
.
hasForceUpdate
)
{
workInProgress
.
updateQueue
=
null
;
}
if
(
!
didSkip
)
{
didSkip
=
true
;
queue
.
baseState
=
state
;
}
return
state
;
}
function
commitCallbacks
(
queue
context
)
{
var
callbackList
=
queue
.
callbackList
;
if
(
callbackList
=
=
=
null
)
{
return
;
}
queue
.
callbackList
=
null
;
for
(
var
i
=
0
;
i
<
callbackList
.
length
;
i
+
+
)
{
var
update
=
callbackList
[
i
]
;
var
_callback
=
update
.
callback
;
update
.
callback
=
null
;
!
(
typeof
_callback
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
191
'
_callback
)
:
void
0
;
_callback
.
call
(
context
)
;
}
}
var
ReactFiberClassComponent
=
function
(
scheduleWork
computeExpirationForFiber
memoizeProps
memoizeState
)
{
var
updater
=
{
isMounted
:
isMounted
enqueueSetState
:
function
(
instance
partialState
callback
)
{
var
fiber
=
get
(
instance
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
var
expirationTime
=
computeExpirationForFiber
(
fiber
)
;
var
update
=
{
expirationTime
:
expirationTime
partialState
:
partialState
callback
:
callback
isReplace
:
false
isForced
:
false
nextCallback
:
null
next
:
null
}
;
insertUpdateIntoFiber
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueReplaceState
:
function
(
instance
state
callback
)
{
var
fiber
=
get
(
instance
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
var
expirationTime
=
computeExpirationForFiber
(
fiber
)
;
var
update
=
{
expirationTime
:
expirationTime
partialState
:
state
callback
:
callback
isReplace
:
true
isForced
:
false
nextCallback
:
null
next
:
null
}
;
insertUpdateIntoFiber
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueForceUpdate
:
function
(
instance
callback
)
{
var
fiber
=
get
(
instance
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
var
expirationTime
=
computeExpirationForFiber
(
fiber
)
;
var
update
=
{
expirationTime
:
expirationTime
partialState
:
null
callback
:
callback
isReplace
:
false
isForced
:
true
nextCallback
:
null
next
:
null
}
;
insertUpdateIntoFiber
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
}
;
function
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
{
if
(
oldProps
=
=
=
null
|
|
workInProgress
.
updateQueue
!
=
=
null
&
&
workInProgress
.
updateQueue
.
hasForceUpdate
)
{
return
true
;
}
var
instance
=
workInProgress
.
stateNode
;
var
type
=
workInProgress
.
type
;
if
(
typeof
instance
.
shouldComponentUpdate
=
=
=
'
function
'
)
{
startPhaseTimer
(
workInProgress
'
shouldComponentUpdate
'
)
;
var
shouldUpdate
=
instance
.
shouldComponentUpdate
(
newProps
newState
newContext
)
;
stopPhaseTimer
(
)
;
if
(
debugRenderPhaseSideEffects
)
{
instance
.
shouldComponentUpdate
(
newProps
newState
newContext
)
;
}
return
shouldUpdate
;
}
if
(
type
.
prototype
&
&
type
.
prototype
.
isPureReactComponent
)
{
return
!
shallowEqual_1
(
oldProps
newProps
)
|
|
!
shallowEqual_1
(
oldState
newState
)
;
}
return
true
;
}
function
resetInputPointers
(
workInProgress
instance
)
{
instance
.
props
=
workInProgress
.
memoizedProps
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
function
adoptClassInstance
(
workInProgress
instance
)
{
instance
.
updater
=
updater
;
workInProgress
.
stateNode
=
instance
;
set
(
instance
workInProgress
)
;
}
function
constructClassInstance
(
workInProgress
props
)
{
var
ctor
=
workInProgress
.
type
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
needsContext
=
isContextConsumer
(
workInProgress
)
;
var
context
=
needsContext
?
getMaskedContext
(
workInProgress
unmaskedContext
)
:
emptyObject_1
;
var
instance
=
new
ctor
(
props
context
)
;
adoptClassInstance
(
workInProgress
instance
)
;
if
(
needsContext
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
instance
;
}
function
callComponentWillMount
(
workInProgress
instance
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
var
oldState
=
instance
.
state
;
instance
.
componentWillMount
(
)
;
stopPhaseTimer
(
)
;
if
(
debugRenderPhaseSideEffects
)
{
instance
.
componentWillMount
(
)
;
}
if
(
oldState
!
=
=
instance
.
state
)
{
updater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
{
startPhaseTimer
(
workInProgress
'
componentWillReceiveProps
'
)
;
var
oldState
=
instance
.
state
;
instance
.
componentWillReceiveProps
(
newProps
newContext
)
;
stopPhaseTimer
(
)
;
if
(
debugRenderPhaseSideEffects
)
{
instance
.
componentWillReceiveProps
(
newProps
newContext
)
;
}
if
(
instance
.
state
!
=
=
oldState
)
{
updater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
mountClassInstance
(
workInProgress
renderExpirationTime
)
{
var
current
=
workInProgress
.
alternate
;
var
instance
=
workInProgress
.
stateNode
;
var
state
=
instance
.
state
|
|
null
;
var
props
=
workInProgress
.
pendingProps
;
!
props
?
reactProdInvariant
(
'
158
'
)
:
void
0
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
instance
.
props
=
props
;
instance
.
state
=
workInProgress
.
memoizedState
=
state
;
instance
.
refs
=
emptyObject_1
;
instance
.
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
if
(
enableAsyncSubtreeAPI
&
&
workInProgress
.
type
!
=
null
&
&
workInProgress
.
type
.
prototype
!
=
null
&
&
workInProgress
.
type
.
prototype
.
unstable_isAsyncReactComponent
=
=
=
true
)
{
workInProgress
.
internalContextTag
|
=
AsyncUpdates
;
}
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
callComponentWillMount
(
workInProgress
instance
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
instance
.
state
=
processUpdateQueue
(
current
workInProgress
updateQueue
instance
props
renderExpirationTime
)
;
}
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
function
updateClassInstance
(
current
workInProgress
renderExpirationTime
)
{
var
instance
=
workInProgress
.
stateNode
;
resetInputPointers
(
workInProgress
instance
)
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newProps
=
workInProgress
.
pendingProps
;
if
(
!
newProps
)
{
newProps
=
oldProps
;
!
(
newProps
!
=
null
)
?
reactProdInvariant
(
'
159
'
)
:
void
0
;
}
var
oldContext
=
instance
.
context
;
var
newUnmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
newContext
=
getMaskedContext
(
workInProgress
newUnmaskedContext
)
;
if
(
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
&
&
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
newContext
)
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
;
}
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
void
0
;
if
(
workInProgress
.
updateQueue
!
=
=
null
)
{
newState
=
processUpdateQueue
(
current
workInProgress
workInProgress
.
updateQueue
instance
newProps
renderExpirationTime
)
;
}
else
{
newState
=
oldState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
(
workInProgress
.
updateQueue
!
=
=
null
&
&
workInProgress
.
updateQueue
.
hasForceUpdate
)
)
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
return
false
;
}
var
shouldUpdate
=
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
;
if
(
shouldUpdate
)
{
if
(
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
{
startPhaseTimer
(
workInProgress
'
componentWillUpdate
'
)
;
instance
.
componentWillUpdate
(
newProps
newState
newContext
)
;
stopPhaseTimer
(
)
;
if
(
debugRenderPhaseSideEffects
)
{
instance
.
componentWillUpdate
(
newProps
newState
newContext
)
;
}
}
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
else
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
memoizeProps
(
workInProgress
newProps
)
;
memoizeState
(
workInProgress
newState
)
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
newContext
;
return
shouldUpdate
;
}
return
{
adoptClassInstance
:
adoptClassInstance
constructClassInstance
:
constructClassInstance
mountClassInstance
:
mountClassInstance
updateClassInstance
:
updateClassInstance
}
;
}
;
var
hasSymbol
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
[
'
for
'
]
;
var
REACT_ELEMENT_TYPE
=
hasSymbol
?
Symbol
[
'
for
'
]
(
'
react
.
element
'
)
:
0xeac7
;
var
REACT_CALL_TYPE
=
hasSymbol
?
Symbol
[
'
for
'
]
(
'
react
.
call
'
)
:
0xeac8
;
var
REACT_RETURN_TYPE
=
hasSymbol
?
Symbol
[
'
for
'
]
(
'
react
.
return
'
)
:
0xeac9
;
var
REACT_PORTAL_TYPE
=
hasSymbol
?
Symbol
[
'
for
'
]
(
'
react
.
portal
'
)
:
0xeaca
;
var
REACT_FRAGMENT_TYPE
=
hasSymbol
?
Symbol
[
'
for
'
]
(
'
react
.
fragment
'
)
:
0xeacb
;
var
MAYBE_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
if
(
maybeIterable
=
=
=
null
|
|
typeof
maybeIterable
=
=
=
'
undefined
'
)
{
return
null
;
}
var
maybeIterator
=
MAYBE_ITERATOR_SYMBOL
&
&
maybeIterable
[
MAYBE_ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
;
if
(
typeof
maybeIterator
=
=
=
'
function
'
)
{
return
maybeIterator
;
}
return
null
;
}
var
isArray
1
=
Array
.
isArray
;
function
coerceRef
(
current
element
)
{
var
mixedRef
=
element
.
ref
;
if
(
mixedRef
!
=
=
null
&
&
typeof
mixedRef
!
=
=
'
function
'
)
{
if
(
element
.
_owner
)
{
var
owner
=
element
.
_owner
;
var
inst
=
void
0
;
if
(
owner
)
{
var
ownerFiber
=
owner
;
!
(
ownerFiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
110
'
)
:
void
0
;
inst
=
ownerFiber
.
stateNode
;
}
!
inst
?
reactProdInvariant
(
'
147
'
mixedRef
)
:
void
0
;
var
stringRef
=
'
'
+
mixedRef
;
if
(
current
!
=
=
null
&
&
current
.
ref
!
=
=
null
&
&
current
.
ref
.
_stringRef
=
=
=
stringRef
)
{
return
current
.
ref
;
}
var
ref
=
function
(
value
)
{
var
refs
=
inst
.
refs
=
=
=
emptyObject_1
?
inst
.
refs
=
{
}
:
inst
.
refs
;
if
(
value
=
=
=
null
)
{
delete
refs
[
stringRef
]
;
}
else
{
refs
[
stringRef
]
=
value
;
}
}
;
ref
.
_stringRef
=
stringRef
;
return
ref
;
}
else
{
!
(
typeof
mixedRef
=
=
=
'
string
'
)
?
reactProdInvariant
(
'
148
'
)
:
void
0
;
!
element
.
_owner
?
reactProdInvariant
(
'
149
'
mixedRef
)
:
void
0
;
}
}
return
mixedRef
;
}
function
throwOnInvalidObjectType
(
returnFiber
newChild
)
{
if
(
returnFiber
.
type
!
=
=
'
textarea
'
)
{
var
addendum
=
'
'
;
reactProdInvariant
(
'
31
'
Object
.
prototype
.
toString
.
call
(
newChild
)
=
=
=
'
[
object
Object
]
'
?
'
object
with
keys
{
'
+
Object
.
keys
(
newChild
)
.
join
(
'
'
)
+
'
}
'
:
newChild
addendum
)
;
}
}
function
ChildReconciler
(
shouldTrackSideEffects
)
{
function
deleteChild
(
returnFiber
childToDelete
)
{
if
(
!
shouldTrackSideEffects
)
{
return
;
}
var
last
=
returnFiber
.
lastEffect
;
if
(
last
!
=
=
null
)
{
last
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
childToDelete
.
nextEffect
=
null
;
childToDelete
.
effectTag
=
Deletion
;
}
function
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
{
if
(
!
shouldTrackSideEffects
)
{
return
null
;
}
var
childToDelete
=
currentFirstChild
;
while
(
childToDelete
!
=
=
null
)
{
deleteChild
(
returnFiber
childToDelete
)
;
childToDelete
=
childToDelete
.
sibling
;
}
return
null
;
}
function
mapRemainingChildren
(
returnFiber
currentFirstChild
)
{
var
existingChildren
=
new
Map
(
)
;
var
existingChild
=
currentFirstChild
;
while
(
existingChild
!
=
=
null
)
{
if
(
existingChild
.
key
!
=
=
null
)
{
existingChildren
.
set
(
existingChild
.
key
existingChild
)
;
}
else
{
existingChildren
.
set
(
existingChild
.
index
existingChild
)
;
}
existingChild
=
existingChild
.
sibling
;
}
return
existingChildren
;
}
function
useFiber
(
fiber
pendingProps
expirationTime
)
{
var
clone
=
createWorkInProgress
(
fiber
pendingProps
expirationTime
)
;
clone
.
index
=
0
;
clone
.
sibling
=
null
;
return
clone
;
}
function
placeChild
(
newFiber
lastPlacedIndex
newIndex
)
{
newFiber
.
index
=
newIndex
;
if
(
!
shouldTrackSideEffects
)
{
return
lastPlacedIndex
;
}
var
current
=
newFiber
.
alternate
;
if
(
current
!
=
=
null
)
{
var
oldIndex
=
current
.
index
;
if
(
oldIndex
<
lastPlacedIndex
)
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
else
{
return
oldIndex
;
}
}
else
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
}
function
placeSingleChild
(
newFiber
)
{
if
(
shouldTrackSideEffects
&
&
newFiber
.
alternate
=
=
=
null
)
{
newFiber
.
effectTag
=
Placement
;
}
return
newFiber
;
}
function
updateTextNode
(
returnFiber
current
textContent
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
HostText
)
{
var
created
=
createFiberFromText
(
textContent
returnFiber
.
internalContextTag
expirationTime
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
textContent
expirationTime
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
}
function
updateElement
(
returnFiber
current
element
expirationTime
)
{
if
(
current
!
=
=
null
&
&
current
.
type
=
=
=
element
.
type
)
{
var
existing
=
useFiber
(
current
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
current
element
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
else
{
var
created
=
createFiberFromElement
(
element
returnFiber
.
internalContextTag
expirationTime
)
;
created
.
ref
=
coerceRef
(
current
element
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
}
function
updateCall
(
returnFiber
current
call
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
CallComponent
)
{
var
created
=
createFiberFromCall
(
call
returnFiber
.
internalContextTag
expirationTime
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
call
expirationTime
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
}
function
updateReturn
(
returnFiber
current
returnNode
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
ReturnComponent
)
{
var
created
=
createFiberFromReturn
(
returnNode
returnFiber
.
internalContextTag
expirationTime
)
;
created
.
type
=
returnNode
.
value
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
null
expirationTime
)
;
existing
.
type
=
returnNode
.
value
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
}
function
updatePortal
(
returnFiber
current
portal
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
HostPortal
|
|
current
.
stateNode
.
containerInfo
!
=
=
portal
.
containerInfo
|
|
current
.
stateNode
.
implementation
!
=
=
portal
.
implementation
)
{
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
internalContextTag
expirationTime
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
portal
.
children
|
|
[
]
expirationTime
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
}
function
updateFragment
(
returnFiber
current
fragment
expirationTime
key
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
Fragment
)
{
var
created
=
createFiberFromFragment
(
fragment
returnFiber
.
internalContextTag
expirationTime
key
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
fragment
expirationTime
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
}
function
createChild
(
returnFiber
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
created
=
createFiberFromText
(
'
'
+
newChild
returnFiber
.
internalContextTag
expirationTime
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
var
_created
=
createFiberFromFragment
(
newChild
.
props
.
children
returnFiber
.
internalContextTag
expirationTime
newChild
.
key
)
;
_created
[
'
return
'
]
=
returnFiber
;
return
_created
;
}
else
{
var
_created2
=
createFiberFromElement
(
newChild
returnFiber
.
internalContextTag
expirationTime
)
;
_created2
.
ref
=
coerceRef
(
null
newChild
)
;
_created2
[
'
return
'
]
=
returnFiber
;
return
_created2
;
}
}
case
REACT_CALL_TYPE
:
{
var
_created3
=
createFiberFromCall
(
newChild
returnFiber
.
internalContextTag
expirationTime
)
;
_created3
[
'
return
'
]
=
returnFiber
;
return
_created3
;
}
case
REACT_RETURN_TYPE
:
{
var
_created4
=
createFiberFromReturn
(
newChild
returnFiber
.
internalContextTag
expirationTime
)
;
_created4
.
type
=
newChild
.
value
;
_created4
[
'
return
'
]
=
returnFiber
;
return
_created4
;
}
case
REACT_PORTAL_TYPE
:
{
var
_created5
=
createFiberFromPortal
(
newChild
returnFiber
.
internalContextTag
expirationTime
)
;
_created5
[
'
return
'
]
=
returnFiber
;
return
_created5
;
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_created6
=
createFiberFromFragment
(
newChild
returnFiber
.
internalContextTag
expirationTime
null
)
;
_created6
[
'
return
'
]
=
returnFiber
;
return
_created6
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateSlot
(
returnFiber
oldFiber
newChild
expirationTime
)
{
var
key
=
oldFiber
!
=
=
null
?
oldFiber
.
key
:
null
;
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateTextNode
(
returnFiber
oldFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
oldFiber
newChild
.
props
.
children
expirationTime
key
)
;
}
return
updateElement
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
case
REACT_CALL_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
return
updateCall
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
case
REACT_RETURN_TYPE
:
{
if
(
key
=
=
=
null
)
{
return
updateReturn
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
case
REACT_PORTAL_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
return
updatePortal
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateFragment
(
returnFiber
oldFiber
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateFromMap
(
existingChildren
returnFiber
newIdx
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
matchedFiber
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateTextNode
(
returnFiber
matchedFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_matchedFiber
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
_matchedFiber
newChild
.
props
.
children
expirationTime
newChild
.
key
)
;
}
return
updateElement
(
returnFiber
_matchedFiber
newChild
expirationTime
)
;
}
case
REACT_CALL_TYPE
:
{
var
_matchedFiber2
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
return
updateCall
(
returnFiber
_matchedFiber2
newChild
expirationTime
)
;
}
case
REACT_RETURN_TYPE
:
{
var
_matchedFiber3
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateReturn
(
returnFiber
_matchedFiber3
newChild
expirationTime
)
;
}
case
REACT_PORTAL_TYPE
:
{
var
_matchedFiber4
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
return
updatePortal
(
returnFiber
_matchedFiber4
newChild
expirationTime
)
;
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_matchedFiber5
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateFragment
(
returnFiber
_matchedFiber5
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChildren
expirationTime
)
{
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
for
(
;
oldFiber
!
=
=
null
&
&
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
oldFiber
=
=
=
null
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
newIdx
=
=
=
newChildren
.
length
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber
=
createChild
(
returnFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
!
_newFiber
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber
;
}
previousNewFiber
=
_newFiber
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber2
=
updateFromMap
(
existingChildren
returnFiber
newIdx
newChildren
[
newIdx
]
expirationTime
)
;
if
(
_newFiber2
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber2
.
alternate
!
=
=
null
)
{
existingChildren
[
'
delete
'
]
(
_newFiber2
.
key
=
=
=
null
?
newIdx
:
_newFiber2
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber2
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber2
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber2
;
}
previousNewFiber
=
_newFiber2
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChildrenIterable
expirationTime
)
{
var
iteratorFn
=
getIteratorFn
(
newChildrenIterable
)
;
!
(
typeof
iteratorFn
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
150
'
)
:
void
0
;
var
newChildren
=
iteratorFn
.
call
(
newChildrenIterable
)
;
!
(
newChildren
!
=
null
)
?
reactProdInvariant
(
'
151
'
)
:
void
0
;
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
var
step
=
newChildren
.
next
(
)
;
for
(
;
oldFiber
!
=
=
null
&
&
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
step
.
value
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
!
oldFiber
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
step
.
done
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber3
=
createChild
(
returnFiber
step
.
value
expirationTime
)
;
if
(
_newFiber3
=
=
=
null
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber3
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber3
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber3
;
}
previousNewFiber
=
_newFiber3
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber4
=
updateFromMap
(
existingChildren
returnFiber
newIdx
step
.
value
expirationTime
)
;
if
(
_newFiber4
!
=
=
null
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber4
.
alternate
!
=
=
null
)
{
existingChildren
[
'
delete
'
]
(
_newFiber4
.
key
=
=
=
null
?
newIdx
:
_newFiber4
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber4
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber4
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber4
;
}
previousNewFiber
=
_newFiber4
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileSingleTextNode
(
returnFiber
currentFirstChild
textContent
expirationTime
)
{
if
(
currentFirstChild
!
=
=
null
&
&
currentFirstChild
.
tag
=
=
=
HostText
)
{
deleteRemainingChildren
(
returnFiber
currentFirstChild
.
sibling
)
;
var
existing
=
useFiber
(
currentFirstChild
textContent
expirationTime
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
var
created
=
createFiberFromText
(
textContent
returnFiber
.
internalContextTag
expirationTime
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
function
reconcileSingleElement
(
returnFiber
currentFirstChild
element
expirationTime
)
{
var
key
=
element
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
Fragment
?
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
:
child
.
type
=
=
=
element
.
type
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
?
element
.
props
.
children
:
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
child
element
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
if
(
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
var
created
=
createFiberFromFragment
(
element
.
props
.
children
returnFiber
.
internalContextTag
expirationTime
element
.
key
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
else
{
var
_created7
=
createFiberFromElement
(
element
returnFiber
.
internalContextTag
expirationTime
)
;
_created7
.
ref
=
coerceRef
(
currentFirstChild
element
)
;
_created7
[
'
return
'
]
=
returnFiber
;
return
_created7
;
}
}
function
reconcileSingleCall
(
returnFiber
currentFirstChild
call
expirationTime
)
{
var
key
=
call
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
CallComponent
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
call
expirationTime
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
var
created
=
createFiberFromCall
(
call
returnFiber
.
internalContextTag
expirationTime
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
function
reconcileSingleReturn
(
returnFiber
currentFirstChild
returnNode
expirationTime
)
{
var
child
=
currentFirstChild
;
if
(
child
!
=
=
null
)
{
if
(
child
.
tag
=
=
=
ReturnComponent
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
null
expirationTime
)
;
existing
.
type
=
returnNode
.
value
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
}
}
var
created
=
createFiberFromReturn
(
returnNode
returnFiber
.
internalContextTag
expirationTime
)
;
created
.
type
=
returnNode
.
value
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
function
reconcileSinglePortal
(
returnFiber
currentFirstChild
portal
expirationTime
)
{
var
key
=
portal
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
HostPortal
&
&
child
.
stateNode
.
containerInfo
=
=
=
portal
.
containerInfo
&
&
child
.
stateNode
.
implementation
=
=
=
portal
.
implementation
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
portal
.
children
|
|
[
]
expirationTime
)
;
existing
[
'
return
'
]
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
internalContextTag
expirationTime
)
;
created
[
'
return
'
]
=
returnFiber
;
return
created
;
}
function
reconcileChildFibers
(
returnFiber
currentFirstChild
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
&
&
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
&
&
newChild
.
key
=
=
=
null
)
{
newChild
=
newChild
.
props
.
children
;
}
var
isObject
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
;
if
(
isObject
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
return
placeSingleChild
(
reconcileSingleElement
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
case
REACT_CALL_TYPE
:
return
placeSingleChild
(
reconcileSingleCall
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
case
REACT_RETURN_TYPE
:
return
placeSingleChild
(
reconcileSingleReturn
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
case
REACT_PORTAL_TYPE
:
return
placeSingleChild
(
reconcileSinglePortal
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
}
}
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
return
placeSingleChild
(
reconcileSingleTextNode
(
returnFiber
currentFirstChild
'
'
+
newChild
expirationTime
)
)
;
}
if
(
isArray
1
(
newChild
)
)
{
return
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
getIteratorFn
(
newChild
)
)
{
return
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
isObject
)
{
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
if
(
typeof
newChild
=
=
=
'
undefined
'
)
{
switch
(
returnFiber
.
tag
)
{
case
ClassComponent
:
{
}
case
FunctionalComponent
:
{
var
Component
=
returnFiber
.
type
;
reactProdInvariant
(
'
152
'
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
;
}
}
}
return
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
}
return
reconcileChildFibers
;
}
var
reconcileChildFibers
=
ChildReconciler
(
true
)
;
var
mountChildFibers
=
ChildReconciler
(
false
)
;
function
cloneChildFibers
(
current
workInProgress
)
{
!
(
current
=
=
=
null
|
|
workInProgress
.
child
=
=
=
current
.
child
)
?
reactProdInvariant
(
'
153
'
)
:
void
0
;
if
(
workInProgress
.
child
=
=
=
null
)
{
return
;
}
var
currentChild
=
workInProgress
.
child
;
var
newChild
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
workInProgress
.
child
=
newChild
;
newChild
[
'
return
'
]
=
workInProgress
;
while
(
currentChild
.
sibling
!
=
=
null
)
{
currentChild
=
currentChild
.
sibling
;
newChild
=
newChild
.
sibling
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
newChild
[
'
return
'
]
=
workInProgress
;
}
newChild
.
sibling
=
null
;
}
var
ReactFiberBeginWork
=
function
(
config
hostContext
hydrationContext
scheduleWork
computeExpirationForFiber
)
{
var
shouldSetTextContent
=
config
.
shouldSetTextContent
useSyncScheduling
=
config
.
useSyncScheduling
shouldDeprioritizeSubtree
=
config
.
shouldDeprioritizeSubtree
;
var
pushHostContext
=
hostContext
.
pushHostContext
pushHostContainer
=
hostContext
.
pushHostContainer
;
var
enterHydrationState
=
hydrationContext
.
enterHydrationState
resetHydrationState
=
hydrationContext
.
resetHydrationState
tryToClaimNextHydratableInstance
=
hydrationContext
.
tryToClaimNextHydratableInstance
;
var
_ReactFiberClassCompo
=
ReactFiberClassComponent
(
scheduleWork
computeExpirationForFiber
memoizeProps
memoizeState
)
adoptClassInstance
=
_ReactFiberClassCompo
.
adoptClassInstance
constructClassInstance
=
_ReactFiberClassCompo
.
constructClassInstance
mountClassInstance
=
_ReactFiberClassCompo
.
mountClassInstance
updateClassInstance
=
_ReactFiberClassCompo
.
updateClassInstance
;
function
reconcileChildren
(
current
workInProgress
nextChildren
)
{
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
workInProgress
.
expirationTime
)
;
}
function
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
renderExpirationTime
)
{
if
(
current
=
=
=
null
)
{
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
current
.
child
nextChildren
renderExpirationTime
)
;
}
}
function
updateFragment
(
current
workInProgress
)
{
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
if
(
nextChildren
=
=
=
null
)
{
nextChildren
=
workInProgress
.
memoizedProps
;
}
}
else
if
(
nextChildren
=
=
=
null
|
|
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
return
workInProgress
.
child
;
}
function
markRef
(
current
workInProgress
)
{
var
ref
=
workInProgress
.
ref
;
if
(
ref
!
=
=
null
&
&
(
!
current
|
|
current
.
ref
!
=
=
ref
)
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
}
function
updateFunctionalComponent
(
current
workInProgress
)
{
var
fn
=
workInProgress
.
type
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
memoizedProps
=
workInProgress
.
memoizedProps
;
if
(
hasContextChanged
(
)
)
{
if
(
nextProps
=
=
=
null
)
{
nextProps
=
memoizedProps
;
}
}
else
{
if
(
nextProps
=
=
=
null
|
|
memoizedProps
=
=
=
nextProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
nextChildren
;
{
nextChildren
=
fn
(
nextProps
context
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateClassComponent
(
current
workInProgress
renderExpirationTime
)
{
var
hasContext
=
pushContextProvider
(
workInProgress
)
;
var
shouldUpdate
=
void
0
;
if
(
current
=
=
=
null
)
{
if
(
!
workInProgress
.
stateNode
)
{
constructClassInstance
(
workInProgress
workInProgress
.
pendingProps
)
;
mountClassInstance
(
workInProgress
renderExpirationTime
)
;
shouldUpdate
=
true
;
}
else
{
reactProdInvariant
(
'
153
'
)
;
}
}
else
{
shouldUpdate
=
updateClassInstance
(
current
workInProgress
renderExpirationTime
)
;
}
return
finishClassComponent
(
current
workInProgress
shouldUpdate
hasContext
)
;
}
function
finishClassComponent
(
current
workInProgress
shouldUpdate
hasContext
)
{
markRef
(
current
workInProgress
)
;
if
(
!
shouldUpdate
)
{
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
false
)
;
}
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
instance
=
workInProgress
.
stateNode
;
ReactCurrentOwner
.
current
=
workInProgress
;
var
nextChildren
=
void
0
;
{
if
(
debugRenderPhaseSideEffects
)
{
instance
.
render
(
)
;
}
nextChildren
=
instance
.
render
(
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeState
(
workInProgress
instance
.
state
)
;
memoizeProps
(
workInProgress
instance
.
props
)
;
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
true
)
;
}
return
workInProgress
.
child
;
}
function
pushHostRootContext
(
workInProgress
)
{
var
root
=
workInProgress
.
stateNode
;
if
(
root
.
pendingContext
)
{
pushTopLevelContextObject
(
workInProgress
root
.
pendingContext
root
.
pendingContext
!
=
=
root
.
context
)
;
}
else
if
(
root
.
context
)
{
pushTopLevelContextObject
(
workInProgress
root
.
context
false
)
;
}
pushHostContainer
(
workInProgress
root
.
containerInfo
)
;
}
function
updateHostRoot
(
current
workInProgress
renderExpirationTime
)
{
pushHostRootContext
(
workInProgress
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
var
prevState
=
workInProgress
.
memoizedState
;
var
state
=
processUpdateQueue
(
current
workInProgress
updateQueue
null
null
renderExpirationTime
)
;
if
(
prevState
=
=
=
state
)
{
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
element
=
state
.
element
;
var
root
=
workInProgress
.
stateNode
;
if
(
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
&
&
root
.
hydrate
&
&
enterHydrationState
(
workInProgress
)
)
{
workInProgress
.
effectTag
|
=
Placement
;
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
element
renderExpirationTime
)
;
}
else
{
resetHydrationState
(
)
;
reconcileChildren
(
current
workInProgress
element
)
;
}
memoizeState
(
workInProgress
state
)
;
return
workInProgress
.
child
;
}
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
function
updateHostComponent
(
current
workInProgress
renderExpirationTime
)
{
pushHostContext
(
workInProgress
)
;
if
(
current
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
type
=
workInProgress
.
type
;
var
memoizedProps
=
workInProgress
.
memoizedProps
;
var
nextProps
=
workInProgress
.
pendingProps
;
if
(
nextProps
=
=
=
null
)
{
nextProps
=
memoizedProps
;
!
(
nextProps
!
=
=
null
)
?
reactProdInvariant
(
'
154
'
)
:
void
0
;
}
var
prevProps
=
current
!
=
=
null
?
current
.
memoizedProps
:
null
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
nextProps
=
=
=
null
|
|
memoizedProps
=
=
=
nextProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
nextChildren
=
nextProps
.
children
;
var
isDirectTextChild
=
shouldSetTextContent
(
type
nextProps
)
;
if
(
isDirectTextChild
)
{
nextChildren
=
null
;
}
else
if
(
prevProps
&
&
shouldSetTextContent
(
type
prevProps
)
)
{
workInProgress
.
effectTag
|
=
ContentReset
;
}
markRef
(
current
workInProgress
)
;
if
(
renderExpirationTime
!
=
=
Never
&
&
!
useSyncScheduling
&
&
shouldDeprioritizeSubtree
(
type
nextProps
)
)
{
workInProgress
.
expirationTime
=
Never
;
return
null
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateHostText
(
current
workInProgress
)
{
if
(
current
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
nextProps
=
workInProgress
.
pendingProps
;
if
(
nextProps
=
=
=
null
)
{
nextProps
=
workInProgress
.
memoizedProps
;
}
memoizeProps
(
workInProgress
nextProps
)
;
return
null
;
}
function
mountIndeterminateComponent
(
current
workInProgress
renderExpirationTime
)
{
!
(
current
=
=
=
null
)
?
reactProdInvariant
(
'
155
'
)
:
void
0
;
var
fn
=
workInProgress
.
type
;
var
props
=
workInProgress
.
pendingProps
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
value
;
{
value
=
fn
(
props
context
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
&
&
typeof
value
.
render
=
=
=
'
function
'
)
{
workInProgress
.
tag
=
ClassComponent
;
var
hasContext
=
pushContextProvider
(
workInProgress
)
;
adoptClassInstance
(
workInProgress
value
)
;
mountClassInstance
(
workInProgress
renderExpirationTime
)
;
return
finishClassComponent
(
current
workInProgress
true
hasContext
)
;
}
else
{
workInProgress
.
tag
=
FunctionalComponent
;
reconcileChildren
(
current
workInProgress
value
)
;
memoizeProps
(
workInProgress
props
)
;
return
workInProgress
.
child
;
}
}
function
updateCallComponent
(
current
workInProgress
renderExpirationTime
)
{
var
nextCall
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
if
(
nextCall
=
=
=
null
)
{
nextCall
=
current
&
&
current
.
memoizedProps
;
!
(
nextCall
!
=
=
null
)
?
reactProdInvariant
(
'
154
'
)
:
void
0
;
}
}
else
if
(
nextCall
=
=
=
null
|
|
workInProgress
.
memoizedProps
=
=
=
nextCall
)
{
nextCall
=
workInProgress
.
memoizedProps
;
}
var
nextChildren
=
nextCall
.
children
;
if
(
current
=
=
=
null
)
{
workInProgress
.
stateNode
=
mountChildFibers
(
workInProgress
workInProgress
.
stateNode
nextChildren
renderExpirationTime
)
;
}
else
{
workInProgress
.
stateNode
=
reconcileChildFibers
(
workInProgress
workInProgress
.
stateNode
nextChildren
renderExpirationTime
)
;
}
memoizeProps
(
workInProgress
nextCall
)
;
return
workInProgress
.
stateNode
;
}
function
updatePortalComponent
(
current
workInProgress
renderExpirationTime
)
{
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
if
(
nextChildren
=
=
=
null
)
{
nextChildren
=
current
&
&
current
.
memoizedProps
;
!
(
nextChildren
!
=
null
)
?
reactProdInvariant
(
'
154
'
)
:
void
0
;
}
}
else
if
(
nextChildren
=
=
=
null
|
|
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
if
(
current
=
=
=
null
)
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
}
else
{
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
}
return
workInProgress
.
child
;
}
function
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
{
cancelWorkTimer
(
workInProgress
)
;
cloneChildFibers
(
current
workInProgress
)
;
return
workInProgress
.
child
;
}
function
bailoutOnLowPriority
(
current
workInProgress
)
{
cancelWorkTimer
(
workInProgress
)
;
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
pushHostRootContext
(
workInProgress
)
;
break
;
case
ClassComponent
:
pushContextProvider
(
workInProgress
)
;
break
;
case
HostPortal
:
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
break
;
}
return
null
;
}
function
memoizeProps
(
workInProgress
nextProps
)
{
workInProgress
.
memoizedProps
=
nextProps
;
}
function
memoizeState
(
workInProgress
nextState
)
{
workInProgress
.
memoizedState
=
nextState
;
}
function
beginWork
(
current
workInProgress
renderExpirationTime
)
{
if
(
workInProgress
.
expirationTime
=
=
=
NoWork
|
|
workInProgress
.
expirationTime
>
renderExpirationTime
)
{
return
bailoutOnLowPriority
(
current
workInProgress
)
;
}
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
return
mountIndeterminateComponent
(
current
workInProgress
renderExpirationTime
)
;
case
FunctionalComponent
:
return
updateFunctionalComponent
(
current
workInProgress
)
;
case
ClassComponent
:
return
updateClassComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostRoot
:
return
updateHostRoot
(
current
workInProgress
renderExpirationTime
)
;
case
HostComponent
:
return
updateHostComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostText
:
return
updateHostText
(
current
workInProgress
)
;
case
CallHandlerPhase
:
workInProgress
.
tag
=
CallComponent
;
case
CallComponent
:
return
updateCallComponent
(
current
workInProgress
renderExpirationTime
)
;
case
ReturnComponent
:
return
null
;
case
HostPortal
:
return
updatePortalComponent
(
current
workInProgress
renderExpirationTime
)
;
case
Fragment
:
return
updateFragment
(
current
workInProgress
)
;
default
:
reactProdInvariant
(
'
156
'
)
;
}
}
function
beginFailedWork
(
current
workInProgress
renderExpirationTime
)
{
switch
(
workInProgress
.
tag
)
{
case
ClassComponent
:
pushContextProvider
(
workInProgress
)
;
break
;
case
HostRoot
:
pushHostRootContext
(
workInProgress
)
;
break
;
default
:
reactProdInvariant
(
'
157
'
)
;
}
workInProgress
.
effectTag
|
=
Err
;
if
(
current
=
=
=
null
)
{
workInProgress
.
child
=
null
;
}
else
if
(
workInProgress
.
child
!
=
=
current
.
child
)
{
workInProgress
.
child
=
current
.
child
;
}
if
(
workInProgress
.
expirationTime
=
=
=
NoWork
|
|
workInProgress
.
expirationTime
>
renderExpirationTime
)
{
return
bailoutOnLowPriority
(
current
workInProgress
)
;
}
workInProgress
.
firstEffect
=
null
;
workInProgress
.
lastEffect
=
null
;
var
nextChildren
=
null
;
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
renderExpirationTime
)
;
if
(
workInProgress
.
tag
=
=
=
ClassComponent
)
{
var
instance
=
workInProgress
.
stateNode
;
workInProgress
.
memoizedProps
=
instance
.
props
;
workInProgress
.
memoizedState
=
instance
.
state
;
}
return
workInProgress
.
child
;
}
return
{
beginWork
:
beginWork
beginFailedWork
:
beginFailedWork
}
;
}
;
var
ReactFiberCompleteWork
=
function
(
config
hostContext
hydrationContext
)
{
var
createInstance
=
config
.
createInstance
createTextInstance
=
config
.
createTextInstance
appendInitialChild
=
config
.
appendInitialChild
finalizeInitialChildren
=
config
.
finalizeInitialChildren
prepareUpdate
=
config
.
prepareUpdate
mutation
=
config
.
mutation
persistence
=
config
.
persistence
;
var
getRootHostContainer
=
hostContext
.
getRootHostContainer
popHostContext
=
hostContext
.
popHostContext
getHostContext
=
hostContext
.
getHostContext
popHostContainer
=
hostContext
.
popHostContainer
;
var
prepareToHydrateHostInstance
=
hydrationContext
.
prepareToHydrateHostInstance
prepareToHydrateHostTextInstance
=
hydrationContext
.
prepareToHydrateHostTextInstance
popHydrationState
=
hydrationContext
.
popHydrationState
;
function
markUpdate
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Update
;
}
function
markRef
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
function
appendAllReturns
(
returns
workInProgress
)
{
var
node
=
workInProgress
.
stateNode
;
if
(
node
)
{
node
[
'
return
'
]
=
workInProgress
;
}
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
|
|
node
.
tag
=
=
=
HostPortal
)
{
reactProdInvariant
(
'
247
'
)
;
}
else
if
(
node
.
tag
=
=
=
ReturnComponent
)
{
returns
.
push
(
node
.
type
)
;
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
[
'
return
'
]
=
=
=
null
|
|
node
[
'
return
'
]
=
=
=
workInProgress
)
{
return
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
}
function
moveCallToHandlerPhase
(
current
workInProgress
renderExpirationTime
)
{
var
call
=
workInProgress
.
memoizedProps
;
!
call
?
reactProdInvariant
(
'
165
'
)
:
void
0
;
workInProgress
.
tag
=
CallHandlerPhase
;
var
returns
=
[
]
;
appendAllReturns
(
returns
workInProgress
)
;
var
fn
=
call
.
handler
;
var
props
=
call
.
props
;
var
nextChildren
=
fn
(
props
returns
)
;
var
currentFirstChild
=
current
!
=
=
null
?
current
.
child
:
null
;
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
currentFirstChild
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
appendAllChildren
(
parent
workInProgress
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendInitialChild
(
parent
node
.
stateNode
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
[
'
return
'
]
=
=
=
null
|
|
node
[
'
return
'
]
=
=
=
workInProgress
)
{
return
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
}
var
updateHostContainer
=
void
0
;
var
updateHostComponent
=
void
0
;
var
updateHostText
=
void
0
;
if
(
mutation
)
{
if
(
enableMutatingReconciler
)
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
)
{
workInProgress
.
updateQueue
=
updatePayload
;
if
(
updatePayload
)
{
markUpdate
(
workInProgress
)
;
}
}
;
updateHostText
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
markUpdate
(
workInProgress
)
;
}
}
;
}
else
{
reactProdInvariant
(
'
237
'
)
;
}
}
else
if
(
persistence
)
{
if
(
enablePersistentReconciler
)
{
var
cloneInstance
=
persistence
.
cloneInstance
createContainerChildSet
=
persistence
.
createContainerChildSet
appendChildToContainerChildSet
=
persistence
.
appendChildToContainerChildSet
finalizeContainerChildren
=
persistence
.
finalizeContainerChildren
;
var
appendAllChildrenToContainer
=
function
(
containerChildSet
workInProgress
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendChildToContainerChildSet
(
containerChildSet
node
.
stateNode
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
[
'
return
'
]
=
=
=
null
|
|
node
[
'
return
'
]
=
=
=
workInProgress
)
{
return
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
}
;
updateHostContainer
=
function
(
workInProgress
)
{
var
portalOrRoot
=
workInProgress
.
stateNode
;
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
if
(
childrenUnchanged
)
{
}
else
{
var
container
=
portalOrRoot
.
containerInfo
;
var
newChildSet
=
createContainerChildSet
(
container
)
;
if
(
finalizeContainerChildren
(
container
newChildSet
)
)
{
markUpdate
(
workInProgress
)
;
}
portalOrRoot
.
pendingChildren
=
newChildSet
;
appendAllChildrenToContainer
(
newChildSet
workInProgress
)
;
markUpdate
(
workInProgress
)
;
}
}
;
updateHostComponent
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
)
{
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
var
currentInstance
=
current
.
stateNode
;
if
(
childrenUnchanged
&
&
updatePayload
=
=
=
null
)
{
workInProgress
.
stateNode
=
currentInstance
;
}
else
{
var
recyclableInstance
=
workInProgress
.
stateNode
;
var
newInstance
=
cloneInstance
(
currentInstance
updatePayload
type
oldProps
newProps
workInProgress
childrenUnchanged
recyclableInstance
)
;
if
(
finalizeInitialChildren
(
newInstance
type
newProps
rootContainerInstance
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
newInstance
;
if
(
childrenUnchanged
)
{
markUpdate
(
workInProgress
)
;
}
else
{
appendAllChildren
(
newInstance
workInProgress
)
;
}
}
}
;
updateHostText
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
currentHostContext
=
getHostContext
(
)
;
workInProgress
.
stateNode
=
createTextInstance
(
newText
rootContainerInstance
currentHostContext
workInProgress
)
;
markUpdate
(
workInProgress
)
;
}
}
;
}
else
{
reactProdInvariant
(
'
235
'
)
;
}
}
else
{
if
(
enableNoopReconciler
)
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
)
{
}
;
updateHostText
=
function
(
current
workInProgress
oldText
newText
)
{
}
;
}
else
{
reactProdInvariant
(
'
236
'
)
;
}
}
function
completeWork
(
current
workInProgress
renderExpirationTime
)
{
var
newProps
=
workInProgress
.
pendingProps
;
if
(
newProps
=
=
=
null
)
{
newProps
=
workInProgress
.
memoizedProps
;
}
else
if
(
workInProgress
.
expirationTime
!
=
=
Never
|
|
renderExpirationTime
=
=
=
Never
)
{
workInProgress
.
pendingProps
=
null
;
}
switch
(
workInProgress
.
tag
)
{
case
FunctionalComponent
:
return
null
;
case
ClassComponent
:
{
popContextProvider
(
workInProgress
)
;
return
null
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
fiberRoot
=
workInProgress
.
stateNode
;
if
(
fiberRoot
.
pendingContext
)
{
fiberRoot
.
context
=
fiberRoot
.
pendingContext
;
fiberRoot
.
pendingContext
=
null
;
}
if
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
{
popHydrationState
(
workInProgress
)
;
workInProgress
.
effectTag
&
=
~
Placement
;
}
updateHostContainer
(
workInProgress
)
;
return
null
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
type
=
workInProgress
.
type
;
if
(
current
!
=
=
null
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldProps
=
current
.
memoizedProps
;
var
instance
=
workInProgress
.
stateNode
;
var
currentHostContext
=
getHostContext
(
)
;
var
updatePayload
=
prepareUpdate
(
instance
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
updateHostComponent
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
)
;
if
(
current
.
ref
!
=
=
workInProgress
.
ref
)
{
markRef
(
workInProgress
)
;
}
}
else
{
if
(
!
newProps
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
return
null
;
}
var
_currentHostContext
=
getHostContext
(
)
;
var
wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
wasHydrated
)
{
if
(
prepareToHydrateHostInstance
(
workInProgress
rootContainerInstance
_currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
var
_instance
=
createInstance
(
type
newProps
rootContainerInstance
_currentHostContext
workInProgress
)
;
appendAllChildren
(
_instance
workInProgress
)
;
if
(
finalizeInitialChildren
(
_instance
type
newProps
rootContainerInstance
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
_instance
;
}
if
(
workInProgress
.
ref
!
=
=
null
)
{
markRef
(
workInProgress
)
;
}
}
return
null
;
}
case
HostText
:
{
var
newText
=
newProps
;
if
(
current
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldText
=
current
.
memoizedProps
;
updateHostText
(
current
workInProgress
oldText
newText
)
;
}
else
{
if
(
typeof
newText
!
=
=
'
string
'
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
return
null
;
}
var
_rootContainerInstance
=
getRootHostContainer
(
)
;
var
_currentHostContext2
=
getHostContext
(
)
;
var
_wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
_wasHydrated
)
{
if
(
prepareToHydrateHostTextInstance
(
workInProgress
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
workInProgress
.
stateNode
=
createTextInstance
(
newText
_rootContainerInstance
_currentHostContext2
workInProgress
)
;
}
}
return
null
;
}
case
CallComponent
:
return
moveCallToHandlerPhase
(
current
workInProgress
renderExpirationTime
)
;
case
CallHandlerPhase
:
workInProgress
.
tag
=
CallComponent
;
return
null
;
case
ReturnComponent
:
return
null
;
case
Fragment
:
return
null
;
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
updateHostContainer
(
workInProgress
)
;
return
null
;
case
IndeterminateComponent
:
reactProdInvariant
(
'
167
'
)
;
default
:
reactProdInvariant
(
'
156
'
)
;
}
}
return
{
completeWork
:
completeWork
}
;
}
;
var
ReactFiberCommitWork
=
function
(
config
captureError
)
{
var
getPublicInstance
=
config
.
getPublicInstance
mutation
=
config
.
mutation
persistence
=
config
.
persistence
;
var
callComponentWillUnmountWithTimer
=
function
(
current
instance
)
{
startPhaseTimer
(
current
'
componentWillUnmount
'
)
;
instance
.
props
=
current
.
memoizedProps
;
instance
.
state
=
current
.
memoizedState
;
instance
.
componentWillUnmount
(
)
;
stopPhaseTimer
(
)
;
}
;
function
safelyCallComponentWillUnmount
(
current
instance
)
{
{
try
{
callComponentWillUnmountWithTimer
(
current
instance
)
;
}
catch
(
unmountError
)
{
captureError
(
current
unmountError
)
;
}
}
}
function
safelyDetachRef
(
current
)
{
var
ref
=
current
.
ref
;
if
(
ref
!
=
=
null
)
{
{
try
{
ref
(
null
)
;
}
catch
(
refError
)
{
captureError
(
current
refError
)
;
}
}
}
}
function
commitLifeCycles
(
current
finishedWork
)
{
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
finishedWork
.
effectTag
&
Update
)
{
if
(
current
=
=
=
null
)
{
startPhaseTimer
(
finishedWork
'
componentDidMount
'
)
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
instance
.
componentDidMount
(
)
;
stopPhaseTimer
(
)
;
}
else
{
var
prevProps
=
current
.
memoizedProps
;
var
prevState
=
current
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
componentDidUpdate
'
)
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
instance
.
componentDidUpdate
(
prevProps
prevState
)
;
stopPhaseTimer
(
)
;
}
}
var
updateQueue
=
finishedWork
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
commitCallbacks
(
updateQueue
instance
)
;
}
return
;
}
case
HostRoot
:
{
var
_updateQueue
=
finishedWork
.
updateQueue
;
if
(
_updateQueue
!
=
=
null
)
{
var
_instance
=
finishedWork
.
child
!
=
=
null
?
finishedWork
.
child
.
stateNode
:
null
;
commitCallbacks
(
_updateQueue
_instance
)
;
}
return
;
}
case
HostComponent
:
{
var
_instance2
=
finishedWork
.
stateNode
;
if
(
current
=
=
=
null
&
&
finishedWork
.
effectTag
&
Update
)
{
var
type
=
finishedWork
.
type
;
var
props
=
finishedWork
.
memoizedProps
;
commitMount
(
_instance2
type
props
finishedWork
)
;
}
return
;
}
case
HostText
:
{
return
;
}
case
HostPortal
:
{
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitAttachRef
(
finishedWork
)
{
var
ref
=
finishedWork
.
ref
;
if
(
ref
!
=
=
null
)
{
var
instance
=
finishedWork
.
stateNode
;
switch
(
finishedWork
.
tag
)
{
case
HostComponent
:
ref
(
getPublicInstance
(
instance
)
)
;
break
;
default
:
ref
(
instance
)
;
}
}
}
function
commitDetachRef
(
current
)
{
var
currentRef
=
current
.
ref
;
if
(
currentRef
!
=
=
null
)
{
currentRef
(
null
)
;
}
}
function
commitUnmount
(
current
)
{
if
(
typeof
onCommitUnmount
=
=
=
'
function
'
)
{
onCommitUnmount
(
current
)
;
}
switch
(
current
.
tag
)
{
case
ClassComponent
:
{
safelyDetachRef
(
current
)
;
var
instance
=
current
.
stateNode
;
if
(
typeof
instance
.
componentWillUnmount
=
=
=
'
function
'
)
{
safelyCallComponentWillUnmount
(
current
instance
)
;
}
return
;
}
case
HostComponent
:
{
safelyDetachRef
(
current
)
;
return
;
}
case
CallComponent
:
{
commitNestedUnmounts
(
current
.
stateNode
)
;
return
;
}
case
HostPortal
:
{
if
(
enableMutatingReconciler
&
&
mutation
)
{
unmountHostComponents
(
current
)
;
}
else
if
(
enablePersistentReconciler
&
&
persistence
)
{
emptyPortalContainer
(
current
)
;
}
return
;
}
}
}
function
commitNestedUnmounts
(
root
)
{
var
node
=
root
;
while
(
true
)
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
&
&
(
!
mutation
|
|
node
.
tag
!
=
=
HostPortal
)
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
root
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
[
'
return
'
]
=
=
=
null
|
|
node
[
'
return
'
]
=
=
=
root
)
{
return
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
}
function
detachFiber
(
current
)
{
current
[
'
return
'
]
=
null
;
current
.
child
=
null
;
if
(
current
.
alternate
)
{
current
.
alternate
.
child
=
null
;
current
.
alternate
[
'
return
'
]
=
null
;
}
}
if
(
!
mutation
)
{
var
commitContainer
=
void
0
;
if
(
persistence
)
{
var
replaceContainerChildren
=
persistence
.
replaceContainerChildren
createContainerChildSet
=
persistence
.
createContainerChildSet
;
var
emptyPortalContainer
=
function
(
current
)
{
var
portal
=
current
.
stateNode
;
var
containerInfo
=
portal
.
containerInfo
;
var
emptyChildSet
=
createContainerChildSet
(
containerInfo
)
;
replaceContainerChildren
(
containerInfo
emptyChildSet
)
;
}
;
commitContainer
=
function
(
finishedWork
)
{
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
return
;
}
case
HostText
:
{
return
;
}
case
HostRoot
:
case
HostPortal
:
{
var
portalOrRoot
=
finishedWork
.
stateNode
;
var
containerInfo
=
portalOrRoot
.
containerInfo
_pendingChildren
=
portalOrRoot
.
pendingChildren
;
replaceContainerChildren
(
containerInfo
_pendingChildren
)
;
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
;
}
else
{
commitContainer
=
function
(
finishedWork
)
{
}
;
}
if
(
enablePersistentReconciler
|
|
enableNoopReconciler
)
{
return
{
commitResetTextContent
:
function
(
finishedWork
)
{
}
commitPlacement
:
function
(
finishedWork
)
{
}
commitDeletion
:
function
(
current
)
{
commitNestedUnmounts
(
current
)
;
detachFiber
(
current
)
;
}
commitWork
:
function
(
current
finishedWork
)
{
commitContainer
(
finishedWork
)
;
}
commitLifeCycles
:
commitLifeCycles
commitAttachRef
:
commitAttachRef
commitDetachRef
:
commitDetachRef
}
;
}
else
if
(
persistence
)
{
reactProdInvariant
(
'
235
'
)
;
}
else
{
reactProdInvariant
(
'
236
'
)
;
}
}
var
commitMount
=
mutation
.
commitMount
commitUpdate
=
mutation
.
commitUpdate
resetTextContent
=
mutation
.
resetTextContent
commitTextUpdate
=
mutation
.
commitTextUpdate
appendChild
=
mutation
.
appendChild
appendChildToContainer
=
mutation
.
appendChildToContainer
insertBefore
=
mutation
.
insertBefore
insertInContainerBefore
=
mutation
.
insertInContainerBefore
removeChild
=
mutation
.
removeChild
removeChildFromContainer
=
mutation
.
removeChildFromContainer
;
function
getHostParentFiber
(
fiber
)
{
var
parent
=
fiber
[
'
return
'
]
;
while
(
parent
!
=
=
null
)
{
if
(
isHostParent
(
parent
)
)
{
return
parent
;
}
parent
=
parent
[
'
return
'
]
;
}
reactProdInvariant
(
'
160
'
)
;
}
function
isHostParent
(
fiber
)
{
return
fiber
.
tag
=
=
=
HostComponent
|
|
fiber
.
tag
=
=
=
HostRoot
|
|
fiber
.
tag
=
=
=
HostPortal
;
}
function
getHostSibling
(
fiber
)
{
var
node
=
fiber
;
siblings
:
while
(
true
)
{
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
[
'
return
'
]
=
=
=
null
|
|
isHostParent
(
node
[
'
return
'
]
)
)
{
return
null
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
while
(
node
.
tag
!
=
=
HostComponent
&
&
node
.
tag
!
=
=
HostText
)
{
if
(
node
.
effectTag
&
Placement
)
{
continue
siblings
;
}
if
(
node
.
child
=
=
=
null
|
|
node
.
tag
=
=
=
HostPortal
)
{
continue
siblings
;
}
else
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
}
}
if
(
!
(
node
.
effectTag
&
Placement
)
)
{
return
node
.
stateNode
;
}
}
}
function
commitPlacement
(
finishedWork
)
{
var
parentFiber
=
getHostParentFiber
(
finishedWork
)
;
var
parent
=
void
0
;
var
isContainer
=
void
0
;
switch
(
parentFiber
.
tag
)
{
case
HostComponent
:
parent
=
parentFiber
.
stateNode
;
isContainer
=
false
;
break
;
case
HostRoot
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
case
HostPortal
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
default
:
reactProdInvariant
(
'
161
'
)
;
}
if
(
parentFiber
.
effectTag
&
ContentReset
)
{
resetTextContent
(
parent
)
;
parentFiber
.
effectTag
&
=
~
ContentReset
;
}
var
before
=
getHostSibling
(
finishedWork
)
;
var
node
=
finishedWork
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
if
(
before
)
{
if
(
isContainer
)
{
insertInContainerBefore
(
parent
node
.
stateNode
before
)
;
}
else
{
insertBefore
(
parent
node
.
stateNode
before
)
;
}
}
else
{
if
(
isContainer
)
{
appendChildToContainer
(
parent
node
.
stateNode
)
;
}
else
{
appendChild
(
parent
node
.
stateNode
)
;
}
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
finishedWork
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
[
'
return
'
]
=
=
=
null
|
|
node
[
'
return
'
]
=
=
=
finishedWork
)
{
return
;
}
node
=
node
[
'
return
'
]
;
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
}
function
unmountHostComponents
(
current
)
{
var
node
=
current
;
var
currentParentIsValid
=
false
;
var
currentParent
=
void
0
;
var
currentParentIsContainer
=
void
0
;
while
(
true
)
{
if
(
!
currentParentIsValid
)
{
var
parent
=
node
[
'
return
'
]
;
findParent
:
while
(
true
)
{
!
(
parent
!
=
=
null
)
?
reactProdInvariant
(
'
160
'
)
:
void
0
;
switch
(
parent
.
tag
)
{
case
HostComponent
:
currentParent
=
parent
.
stateNode
;
currentParentIsContainer
=
false
;
break
findParent
;
case
HostRoot
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
case
HostPortal
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
}
parent
=
parent
[
'
return
'
]
;
}
currentParentIsValid
=
true
;
}
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
commitNestedUnmounts
(
node
)
;
if
(
currentParentIsContainer
)
{
removeChildFromContainer
(
currentParent
node
.
stateNode
)
;
}
else
{
removeChild
(
currentParent
node
.
stateNode
)
;
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParent
=
node
.
stateNode
.
containerInfo
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
[
'
return
'
]
=
node
;
node
=
node
.
child
;
continue
;
}
}
if
(
node
=
=
=
current
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
[
'
return
'
]
=
=
=
null
|
|
node
[
'
return
'
]
=
=
=
current
)
{
return
;
}
node
=
node
[
'
return
'
]
;
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParentIsValid
=
false
;
}
}
node
.
sibling
[
'
return
'
]
=
node
[
'
return
'
]
;
node
=
node
.
sibling
;
}
}
function
commitDeletion
(
current
)
{
unmountHostComponents
(
current
)
;
detachFiber
(
current
)
;
}
function
commitWork
(
current
finishedWork
)
{
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
instance
!
=
null
)
{
var
newProps
=
finishedWork
.
memoizedProps
;
var
oldProps
=
current
!
=
=
null
?
current
.
memoizedProps
:
newProps
;
var
type
=
finishedWork
.
type
;
var
updatePayload
=
finishedWork
.
updateQueue
;
finishedWork
.
updateQueue
=
null
;
if
(
updatePayload
!
=
=
null
)
{
commitUpdate
(
instance
updatePayload
type
oldProps
newProps
finishedWork
)
;
}
}
return
;
}
case
HostText
:
{
!
(
finishedWork
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
162
'
)
:
void
0
;
var
textInstance
=
finishedWork
.
stateNode
;
var
newText
=
finishedWork
.
memoizedProps
;
var
oldText
=
current
!
=
=
null
?
current
.
memoizedProps
:
newText
;
commitTextUpdate
(
textInstance
oldText
newText
)
;
return
;
}
case
HostRoot
:
{
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitResetTextContent
(
current
)
{
resetTextContent
(
current
.
stateNode
)
;
}
if
(
enableMutatingReconciler
)
{
return
{
commitResetTextContent
:
commitResetTextContent
commitPlacement
:
commitPlacement
commitDeletion
:
commitDeletion
commitWork
:
commitWork
commitLifeCycles
:
commitLifeCycles
commitAttachRef
:
commitAttachRef
commitDetachRef
:
commitDetachRef
}
;
}
else
{
reactProdInvariant
(
'
237
'
)
;
}
}
;
var
NO_CONTEXT
=
{
}
;
var
ReactFiberHostContext
=
function
(
config
)
{
var
getChildHostContext
=
config
.
getChildHostContext
getRootHostContext
=
config
.
getRootHostContext
;
var
contextStackCursor
=
createCursor
(
NO_CONTEXT
)
;
var
contextFiberStackCursor
=
createCursor
(
NO_CONTEXT
)
;
var
rootInstanceStackCursor
=
createCursor
(
NO_CONTEXT
)
;
function
requiredContext
(
c
)
{
!
(
c
!
=
=
NO_CONTEXT
)
?
reactProdInvariant
(
'
174
'
)
:
void
0
;
return
c
;
}
function
getRootHostContainer
(
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
return
rootInstance
;
}
function
pushHostContainer
(
fiber
nextRootInstance
)
{
push
(
rootInstanceStackCursor
nextRootInstance
fiber
)
;
var
nextRootContext
=
getRootHostContext
(
nextRootInstance
)
;
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
nextRootContext
fiber
)
;
}
function
popHostContainer
(
fiber
)
{
pop
(
contextStackCursor
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
pop
(
rootInstanceStackCursor
fiber
)
;
}
function
getHostContext
(
)
{
var
context
=
requiredContext
(
contextStackCursor
.
current
)
;
return
context
;
}
function
pushHostContext
(
fiber
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
var
context
=
requiredContext
(
contextStackCursor
.
current
)
;
var
nextContext
=
getChildHostContext
(
context
fiber
.
type
rootInstance
)
;
if
(
context
=
=
=
nextContext
)
{
return
;
}
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
nextContext
fiber
)
;
}
function
popHostContext
(
fiber
)
{
if
(
contextFiberStackCursor
.
current
!
=
=
fiber
)
{
return
;
}
pop
(
contextStackCursor
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
}
function
resetHostContainer
(
)
{
contextStackCursor
.
current
=
NO_CONTEXT
;
rootInstanceStackCursor
.
current
=
NO_CONTEXT
;
}
return
{
getHostContext
:
getHostContext
getRootHostContainer
:
getRootHostContainer
popHostContainer
:
popHostContainer
popHostContext
:
popHostContext
pushHostContainer
:
pushHostContainer
pushHostContext
:
pushHostContext
resetHostContainer
:
resetHostContainer
}
;
}
;
var
ReactFiberHydrationContext
=
function
(
config
)
{
var
shouldSetTextContent
=
config
.
shouldSetTextContent
hydration
=
config
.
hydration
;
if
(
!
hydration
)
{
return
{
enterHydrationState
:
function
(
)
{
return
false
;
}
resetHydrationState
:
function
(
)
{
}
tryToClaimNextHydratableInstance
:
function
(
)
{
}
prepareToHydrateHostInstance
:
function
(
)
{
reactProdInvariant
(
'
175
'
)
;
}
prepareToHydrateHostTextInstance
:
function
(
)
{
reactProdInvariant
(
'
176
'
)
;
}
popHydrationState
:
function
(
fiber
)
{
return
false
;
}
}
;
}
var
canHydrateInstance
=
hydration
.
canHydrateInstance
canHydrateTextInstance
=
hydration
.
canHydrateTextInstance
getNextHydratableSibling
=
hydration
.
getNextHydratableSibling
getFirstHydratableChild
=
hydration
.
getFirstHydratableChild
hydrateInstance
=
hydration
.
hydrateInstance
hydrateTextInstance
=
hydration
.
hydrateTextInstance
didNotMatchHydratedContainerTextInstance
=
hydration
.
didNotMatchHydratedContainerTextInstance
didNotMatchHydratedTextInstance
=
hydration
.
didNotMatchHydratedTextInstance
didNotHydrateContainerInstance
=
hydration
.
didNotHydrateContainerInstance
didNotHydrateInstance
=
hydration
.
didNotHydrateInstance
didNotFindHydratableContainerInstance
=
hydration
.
didNotFindHydratableContainerInstance
didNotFindHydratableContainerTextInstance
=
hydration
.
didNotFindHydratableContainerTextInstance
didNotFindHydratableInstance
=
hydration
.
didNotFindHydratableInstance
didNotFindHydratableTextInstance
=
hydration
.
didNotFindHydratableTextInstance
;
var
hydrationParentFiber
=
null
;
var
nextHydratableInstance
=
null
;
var
isHydrating
=
false
;
function
enterHydrationState
(
fiber
)
{
var
parentInstance
=
fiber
.
stateNode
.
containerInfo
;
nextHydratableInstance
=
getFirstHydratableChild
(
parentInstance
)
;
hydrationParentFiber
=
fiber
;
isHydrating
=
true
;
return
true
;
}
function
deleteHydratableInstance
(
returnFiber
instance
)
{
var
childToDelete
=
createFiberFromHostInstanceForDeletion
(
)
;
childToDelete
.
stateNode
=
instance
;
childToDelete
[
'
return
'
]
=
returnFiber
;
childToDelete
.
effectTag
=
Deletion
;
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
}
function
insertNonHydratedInstance
(
returnFiber
fiber
)
{
fiber
.
effectTag
|
=
Placement
;
}
function
tryHydrate
(
fiber
nextInstance
)
{
switch
(
fiber
.
tag
)
{
case
HostComponent
:
{
var
type
=
fiber
.
type
;
var
props
=
fiber
.
pendingProps
;
var
instance
=
canHydrateInstance
(
nextInstance
type
props
)
;
if
(
instance
!
=
=
null
)
{
fiber
.
stateNode
=
instance
;
return
true
;
}
return
false
;
}
case
HostText
:
{
var
text
=
fiber
.
pendingProps
;
var
textInstance
=
canHydrateTextInstance
(
nextInstance
text
)
;
if
(
textInstance
!
=
=
null
)
{
fiber
.
stateNode
=
textInstance
;
return
true
;
}
return
false
;
}
default
:
return
false
;
}
}
function
tryToClaimNextHydratableInstance
(
fiber
)
{
if
(
!
isHydrating
)
{
return
;
}
var
nextInstance
=
nextHydratableInstance
;
if
(
!
nextInstance
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
if
(
!
tryHydrate
(
fiber
nextInstance
)
)
{
nextInstance
=
getNextHydratableSibling
(
nextInstance
)
;
if
(
!
nextInstance
|
|
!
tryHydrate
(
fiber
nextInstance
)
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
deleteHydratableInstance
(
hydrationParentFiber
nextHydratableInstance
)
;
}
hydrationParentFiber
=
fiber
;
nextHydratableInstance
=
getFirstHydratableChild
(
nextInstance
)
;
}
function
prepareToHydrateHostInstance
(
fiber
rootContainerInstance
hostContext
)
{
var
instance
=
fiber
.
stateNode
;
var
updatePayload
=
hydrateInstance
(
instance
fiber
.
type
fiber
.
memoizedProps
rootContainerInstance
hostContext
fiber
)
;
fiber
.
updateQueue
=
updatePayload
;
if
(
updatePayload
!
=
=
null
)
{
return
true
;
}
return
false
;
}
function
prepareToHydrateHostTextInstance
(
fiber
)
{
var
textInstance
=
fiber
.
stateNode
;
var
textContent
=
fiber
.
memoizedProps
;
var
shouldUpdate
=
hydrateTextInstance
(
textInstance
textContent
fiber
)
;
return
shouldUpdate
;
}
function
popToNextHostParent
(
fiber
)
{
var
parent
=
fiber
[
'
return
'
]
;
while
(
parent
!
=
=
null
&
&
parent
.
tag
!
=
=
HostComponent
&
&
parent
.
tag
!
=
=
HostRoot
)
{
parent
=
parent
[
'
return
'
]
;
}
hydrationParentFiber
=
parent
;
}
function
popHydrationState
(
fiber
)
{
if
(
fiber
!
=
=
hydrationParentFiber
)
{
return
false
;
}
if
(
!
isHydrating
)
{
popToNextHostParent
(
fiber
)
;
isHydrating
=
true
;
return
false
;
}
var
type
=
fiber
.
type
;
if
(
fiber
.
tag
!
=
=
HostComponent
|
|
type
!
=
=
'
head
'
&
&
type
!
=
=
'
body
'
&
&
!
shouldSetTextContent
(
type
fiber
.
memoizedProps
)
)
{
var
nextInstance
=
nextHydratableInstance
;
while
(
nextInstance
)
{
deleteHydratableInstance
(
fiber
nextInstance
)
;
nextInstance
=
getNextHydratableSibling
(
nextInstance
)
;
}
}
popToNextHostParent
(
fiber
)
;
nextHydratableInstance
=
hydrationParentFiber
?
getNextHydratableSibling
(
fiber
.
stateNode
)
:
null
;
return
true
;
}
function
resetHydrationState
(
)
{
hydrationParentFiber
=
null
;
nextHydratableInstance
=
null
;
isHydrating
=
false
;
}
return
{
enterHydrationState
:
enterHydrationState
resetHydrationState
:
resetHydrationState
tryToClaimNextHydratableInstance
:
tryToClaimNextHydratableInstance
prepareToHydrateHostInstance
:
prepareToHydrateHostInstance
prepareToHydrateHostTextInstance
:
prepareToHydrateHostTextInstance
popHydrationState
:
popHydrationState
}
;
}
;
var
defaultShowDialog
=
function
(
capturedError
)
{
return
true
;
}
;
var
showDialog
=
defaultShowDialog
;
function
logCapturedError
(
capturedError
)
{
var
logError
=
showDialog
(
capturedError
)
;
if
(
logError
=
=
=
false
)
{
return
;
}
var
error
=
capturedError
.
error
;
var
suppressLogging
=
error
&
&
error
.
suppressReactErrorLogging
;
if
(
suppressLogging
)
{
return
;
}
{
console
.
error
(
error
)
;
}
}
var
ReactFiberScheduler
=
function
(
config
)
{
var
hostContext
=
ReactFiberHostContext
(
config
)
;
var
hydrationContext
=
ReactFiberHydrationContext
(
config
)
;
var
popHostContainer
=
hostContext
.
popHostContainer
popHostContext
=
hostContext
.
popHostContext
resetHostContainer
=
hostContext
.
resetHostContainer
;
var
_ReactFiberBeginWork
=
ReactFiberBeginWork
(
config
hostContext
hydrationContext
scheduleWork
computeExpirationForFiber
)
beginWork
=
_ReactFiberBeginWork
.
beginWork
beginFailedWork
=
_ReactFiberBeginWork
.
beginFailedWork
;
var
_ReactFiberCompleteWo
=
ReactFiberCompleteWork
(
config
hostContext
hydrationContext
)
completeWork
=
_ReactFiberCompleteWo
.
completeWork
;
var
_ReactFiberCommitWork
=
ReactFiberCommitWork
(
config
captureError
)
commitResetTextContent
=
_ReactFiberCommitWork
.
commitResetTextContent
commitPlacement
=
_ReactFiberCommitWork
.
commitPlacement
commitDeletion
=
_ReactFiberCommitWork
.
commitDeletion
commitWork
=
_ReactFiberCommitWork
.
commitWork
commitLifeCycles
=
_ReactFiberCommitWork
.
commitLifeCycles
commitAttachRef
=
_ReactFiberCommitWork
.
commitAttachRef
commitDetachRef
=
_ReactFiberCommitWork
.
commitDetachRef
;
var
now
=
config
.
now
scheduleDeferredCallback
=
config
.
scheduleDeferredCallback
cancelDeferredCallback
=
config
.
cancelDeferredCallback
useSyncScheduling
=
config
.
useSyncScheduling
prepareForCommit
=
config
.
prepareForCommit
resetAfterCommit
=
config
.
resetAfterCommit
;
var
startTime
=
now
(
)
;
var
mostRecentCurrentTime
=
msToExpirationTime
(
0
)
;
var
expirationContext
=
NoWork
;
var
isWorking
=
false
;
var
nextUnitOfWork
=
null
;
var
nextRoot
=
null
;
var
nextRenderExpirationTime
=
NoWork
;
var
nextEffect
=
null
;
var
capturedErrors
=
null
;
var
failedBoundaries
=
null
;
var
commitPhaseBoundaries
=
null
;
var
firstUncaughtError
=
null
;
var
didFatal
=
false
;
var
isCommitting
=
false
;
var
isUnmounting
=
false
;
var
interruptedBy
=
null
;
function
resetContextStack
(
)
{
reset
1
(
)
;
resetContext
(
)
;
resetHostContainer
(
)
;
}
function
commitAllHostEffects
(
)
{
while
(
nextEffect
!
=
=
null
)
{
recordEffect
(
)
;
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
ContentReset
)
{
commitResetTextContent
(
nextEffect
)
;
}
if
(
effectTag
&
Ref
)
{
var
current
=
nextEffect
.
alternate
;
if
(
current
!
=
=
null
)
{
commitDetachRef
(
current
)
;
}
}
var
primaryEffectTag
=
effectTag
&
~
(
Callback
|
Err
|
ContentReset
|
Ref
|
PerformedWork
)
;
switch
(
primaryEffectTag
)
{
case
Placement
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
break
;
}
case
PlacementAndUpdate
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
var
_current
=
nextEffect
.
alternate
;
commitWork
(
_current
nextEffect
)
;
break
;
}
case
Update
:
{
var
_current2
=
nextEffect
.
alternate
;
commitWork
(
_current2
nextEffect
)
;
break
;
}
case
Deletion
:
{
isUnmounting
=
true
;
commitDeletion
(
nextEffect
)
;
isUnmounting
=
false
;
break
;
}
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitAllLifeCycles
(
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
(
Update
|
Callback
)
)
{
recordEffect
(
)
;
var
current
=
nextEffect
.
alternate
;
commitLifeCycles
(
current
nextEffect
)
;
}
if
(
effectTag
&
Ref
)
{
recordEffect
(
)
;
commitAttachRef
(
nextEffect
)
;
}
if
(
effectTag
&
Err
)
{
recordEffect
(
)
;
commitErrorHandling
(
nextEffect
)
;
}
var
next
=
nextEffect
.
nextEffect
;
nextEffect
.
nextEffect
=
null
;
nextEffect
=
next
;
}
}
function
commitRoot
(
finishedWork
)
{
isWorking
=
true
;
isCommitting
=
true
;
startCommitTimer
(
)
;
var
root
=
finishedWork
.
stateNode
;
!
(
root
.
current
!
=
=
finishedWork
)
?
reactProdInvariant
(
'
177
'
)
:
void
0
;
root
.
isReadyForCommit
=
false
;
ReactCurrentOwner
.
current
=
null
;
var
firstEffect
=
void
0
;
if
(
finishedWork
.
effectTag
>
PerformedWork
)
{
if
(
finishedWork
.
lastEffect
!
=
=
null
)
{
finishedWork
.
lastEffect
.
nextEffect
=
finishedWork
;
firstEffect
=
finishedWork
.
firstEffect
;
}
else
{
firstEffect
=
finishedWork
;
}
}
else
{
firstEffect
=
finishedWork
.
firstEffect
;
}
prepareForCommit
(
)
;
nextEffect
=
firstEffect
;
startCommitHostEffectsTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
didError
=
false
;
var
_error
=
void
0
;
{
try
{
commitAllHostEffects
(
)
;
}
catch
(
e
)
{
didError
=
true
;
_error
=
e
;
}
}
if
(
didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureError
(
nextEffect
_error
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
stopCommitHostEffectsTimer
(
)
;
resetAfterCommit
(
)
;
root
.
current
=
finishedWork
;
nextEffect
=
firstEffect
;
startCommitLifeCyclesTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
_didError
=
false
;
var
_error2
=
void
0
;
{
try
{
commitAllLifeCycles
(
)
;
}
catch
(
e
)
{
_didError
=
true
;
_error2
=
e
;
}
}
if
(
_didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureError
(
nextEffect
_error2
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
isCommitting
=
false
;
isWorking
=
false
;
stopCommitLifeCyclesTimer
(
)
;
stopCommitTimer
(
)
;
if
(
typeof
onCommitRoot
=
=
=
'
function
'
)
{
onCommitRoot
(
finishedWork
.
stateNode
)
;
}
if
(
commitPhaseBoundaries
)
{
commitPhaseBoundaries
.
forEach
(
scheduleErrorRecovery
)
;
commitPhaseBoundaries
=
null
;
}
if
(
firstUncaughtError
!
=
=
null
)
{
var
_error3
=
firstUncaughtError
;
firstUncaughtError
=
null
;
onUncaughtError
(
_error3
)
;
}
var
remainingTime
=
root
.
current
.
expirationTime
;
if
(
remainingTime
=
=
=
NoWork
)
{
capturedErrors
=
null
;
failedBoundaries
=
null
;
}
return
remainingTime
;
}
function
resetExpirationTime
(
workInProgress
renderTime
)
{
if
(
renderTime
!
=
=
Never
&
&
workInProgress
.
expirationTime
=
=
=
Never
)
{
return
;
}
var
newExpirationTime
=
getUpdateExpirationTime
(
workInProgress
)
;
var
child
=
workInProgress
.
child
;
while
(
child
!
=
=
null
)
{
if
(
child
.
expirationTime
!
=
=
NoWork
&
&
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
child
.
expirationTime
)
)
{
newExpirationTime
=
child
.
expirationTime
;
}
child
=
child
.
sibling
;
}
workInProgress
.
expirationTime
=
newExpirationTime
;
}
function
completeUnitOfWork
(
workInProgress
)
{
while
(
true
)
{
var
current
=
workInProgress
.
alternate
;
var
next
=
completeWork
(
current
workInProgress
nextRenderExpirationTime
)
;
var
returnFiber
=
workInProgress
[
'
return
'
]
;
var
siblingFiber
=
workInProgress
.
sibling
;
resetExpirationTime
(
workInProgress
nextRenderExpirationTime
)
;
if
(
next
!
=
=
null
)
{
stopWorkTimer
(
workInProgress
)
;
return
next
;
}
if
(
returnFiber
!
=
=
null
)
{
if
(
returnFiber
.
firstEffect
=
=
=
null
)
{
returnFiber
.
firstEffect
=
workInProgress
.
firstEffect
;
}
if
(
workInProgress
.
lastEffect
!
=
=
null
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
.
firstEffect
;
}
returnFiber
.
lastEffect
=
workInProgress
.
lastEffect
;
}
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
>
PerformedWork
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
;
}
else
{
returnFiber
.
firstEffect
=
workInProgress
;
}
returnFiber
.
lastEffect
=
workInProgress
;
}
}
stopWorkTimer
(
workInProgress
)
;
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
else
if
(
returnFiber
!
=
=
null
)
{
workInProgress
=
returnFiber
;
continue
;
}
else
{
var
root
=
workInProgress
.
stateNode
;
root
.
isReadyForCommit
=
true
;
return
null
;
}
}
return
null
;
}
function
performUnitOfWork
(
workInProgress
)
{
var
current
=
workInProgress
.
alternate
;
startWorkTimer
(
workInProgress
)
;
var
next
=
beginWork
(
current
workInProgress
nextRenderExpirationTime
)
;
if
(
next
=
=
=
null
)
{
next
=
completeUnitOfWork
(
workInProgress
)
;
}
ReactCurrentOwner
.
current
=
null
;
return
next
;
}
function
performFailedUnitOfWork
(
workInProgress
)
{
var
current
=
workInProgress
.
alternate
;
startWorkTimer
(
workInProgress
)
;
var
next
=
beginFailedWork
(
current
workInProgress
nextRenderExpirationTime
)
;
if
(
next
=
=
=
null
)
{
next
=
completeUnitOfWork
(
workInProgress
)
;
}
ReactCurrentOwner
.
current
=
null
;
return
next
;
}
function
workLoop
(
expirationTime
)
{
if
(
capturedErrors
!
=
=
null
)
{
slowWorkLoopThatChecksForFailedWork
(
expirationTime
)
;
return
;
}
if
(
nextRenderExpirationTime
=
=
=
NoWork
|
|
nextRenderExpirationTime
>
expirationTime
)
{
return
;
}
if
(
nextRenderExpirationTime
<
=
mostRecentCurrentTime
)
{
while
(
nextUnitOfWork
!
=
=
null
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
else
{
while
(
nextUnitOfWork
!
=
=
null
&
&
!
shouldYield
(
)
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
}
function
slowWorkLoopThatChecksForFailedWork
(
expirationTime
)
{
if
(
nextRenderExpirationTime
=
=
=
NoWork
|
|
nextRenderExpirationTime
>
expirationTime
)
{
return
;
}
if
(
nextRenderExpirationTime
<
=
mostRecentCurrentTime
)
{
while
(
nextUnitOfWork
!
=
=
null
)
{
if
(
hasCapturedError
(
nextUnitOfWork
)
)
{
nextUnitOfWork
=
performFailedUnitOfWork
(
nextUnitOfWork
)
;
}
else
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
}
else
{
while
(
nextUnitOfWork
!
=
=
null
&
&
!
shouldYield
(
)
)
{
if
(
hasCapturedError
(
nextUnitOfWork
)
)
{
nextUnitOfWork
=
performFailedUnitOfWork
(
nextUnitOfWork
)
;
}
else
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
}
}
function
renderRootCatchBlock
(
root
failedWork
boundary
expirationTime
)
{
unwindContexts
(
failedWork
boundary
)
;
nextUnitOfWork
=
performFailedUnitOfWork
(
boundary
)
;
workLoop
(
expirationTime
)
;
}
function
renderRoot
(
root
expirationTime
)
{
!
!
isWorking
?
reactProdInvariant
(
'
243
'
)
:
void
0
;
isWorking
=
true
;
root
.
isReadyForCommit
=
false
;
if
(
root
!
=
=
nextRoot
|
|
expirationTime
!
=
=
nextRenderExpirationTime
|
|
nextUnitOfWork
=
=
=
null
)
{
resetContextStack
(
)
;
nextRoot
=
root
;
nextRenderExpirationTime
=
expirationTime
;
nextUnitOfWork
=
createWorkInProgress
(
nextRoot
.
current
null
expirationTime
)
;
}
startWorkLoopTimer
(
nextUnitOfWork
)
;
var
didError
=
false
;
var
error
=
null
;
{
try
{
workLoop
(
expirationTime
)
;
}
catch
(
e
)
{
didError
=
true
;
error
=
e
;
}
}
while
(
didError
)
{
if
(
didFatal
)
{
firstUncaughtError
=
error
;
break
;
}
var
failedWork
=
nextUnitOfWork
;
if
(
failedWork
=
=
=
null
)
{
didFatal
=
true
;
continue
;
}
var
boundary
=
captureError
(
failedWork
error
)
;
!
(
boundary
!
=
=
null
)
?
reactProdInvariant
(
'
183
'
)
:
void
0
;
if
(
didFatal
)
{
continue
;
}
didError
=
false
;
error
=
null
;
{
try
{
renderRootCatchBlock
(
root
failedWork
boundary
expirationTime
)
;
error
=
null
;
}
catch
(
e
)
{
didError
=
true
;
error
=
e
;
continue
;
}
}
break
;
}
var
uncaughtError
=
firstUncaughtError
;
stopWorkLoopTimer
(
interruptedBy
)
;
interruptedBy
=
null
;
isWorking
=
false
;
didFatal
=
false
;
firstUncaughtError
=
null
;
if
(
uncaughtError
!
=
=
null
)
{
onUncaughtError
(
uncaughtError
)
;
}
return
root
.
isReadyForCommit
?
root
.
current
.
alternate
:
null
;
}
function
captureError
(
failedWork
error
)
{
ReactCurrentOwner
.
current
=
null
;
var
boundary
=
null
;
var
errorBoundaryFound
=
false
;
var
willRetry
=
false
;
var
errorBoundaryName
=
null
;
if
(
failedWork
.
tag
=
=
=
HostRoot
)
{
boundary
=
failedWork
;
if
(
isFailedBoundary
(
failedWork
)
)
{
didFatal
=
true
;
}
}
else
{
var
node
=
failedWork
[
'
return
'
]
;
while
(
node
!
=
=
null
&
&
boundary
=
=
=
null
)
{
if
(
node
.
tag
=
=
=
ClassComponent
)
{
var
instance
=
node
.
stateNode
;
if
(
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
)
{
errorBoundaryFound
=
true
;
errorBoundaryName
=
getComponentName
(
node
)
;
boundary
=
node
;
willRetry
=
true
;
}
}
else
if
(
node
.
tag
=
=
=
HostRoot
)
{
boundary
=
node
;
}
if
(
isFailedBoundary
(
node
)
)
{
if
(
isUnmounting
)
{
return
null
;
}
if
(
commitPhaseBoundaries
!
=
=
null
&
&
(
commitPhaseBoundaries
.
has
(
node
)
|
|
node
.
alternate
!
=
=
null
&
&
commitPhaseBoundaries
.
has
(
node
.
alternate
)
)
)
{
return
null
;
}
boundary
=
null
;
willRetry
=
false
;
}
node
=
node
[
'
return
'
]
;
}
}
if
(
boundary
!
=
=
null
)
{
if
(
failedBoundaries
=
=
=
null
)
{
failedBoundaries
=
new
Set
(
)
;
}
failedBoundaries
.
add
(
boundary
)
;
var
_componentStack
=
getStackAddendumByWorkInProgressFiber
(
failedWork
)
;
var
_componentName
=
getComponentName
(
failedWork
)
;
if
(
capturedErrors
=
=
=
null
)
{
capturedErrors
=
new
Map
(
)
;
}
var
capturedError
=
{
componentName
:
_componentName
componentStack
:
_componentStack
error
:
error
errorBoundary
:
errorBoundaryFound
?
boundary
.
stateNode
:
null
errorBoundaryFound
:
errorBoundaryFound
errorBoundaryName
:
errorBoundaryName
willRetry
:
willRetry
}
;
capturedErrors
.
set
(
boundary
capturedError
)
;
try
{
logCapturedError
(
capturedError
)
;
}
catch
(
e
)
{
var
suppressLogging
=
e
&
&
e
.
suppressReactErrorLogging
;
if
(
!
suppressLogging
)
{
console
.
error
(
e
)
;
}
}
if
(
isCommitting
)
{
if
(
commitPhaseBoundaries
=
=
=
null
)
{
commitPhaseBoundaries
=
new
Set
(
)
;
}
commitPhaseBoundaries
.
add
(
boundary
)
;
}
else
{
scheduleErrorRecovery
(
boundary
)
;
}
return
boundary
;
}
else
if
(
firstUncaughtError
=
=
=
null
)
{
firstUncaughtError
=
error
;
}
return
null
;
}
function
hasCapturedError
(
fiber
)
{
return
capturedErrors
!
=
=
null
&
&
(
capturedErrors
.
has
(
fiber
)
|
|
fiber
.
alternate
!
=
=
null
&
&
capturedErrors
.
has
(
fiber
.
alternate
)
)
;
}
function
isFailedBoundary
(
fiber
)
{
return
failedBoundaries
!
=
=
null
&
&
(
failedBoundaries
.
has
(
fiber
)
|
|
fiber
.
alternate
!
=
=
null
&
&
failedBoundaries
.
has
(
fiber
.
alternate
)
)
;
}
function
commitErrorHandling
(
effectfulFiber
)
{
var
capturedError
=
void
0
;
if
(
capturedErrors
!
=
=
null
)
{
capturedError
=
capturedErrors
.
get
(
effectfulFiber
)
;
capturedErrors
[
'
delete
'
]
(
effectfulFiber
)
;
if
(
capturedError
=
=
null
)
{
if
(
effectfulFiber
.
alternate
!
=
=
null
)
{
effectfulFiber
=
effectfulFiber
.
alternate
;
capturedError
=
capturedErrors
.
get
(
effectfulFiber
)
;
capturedErrors
[
'
delete
'
]
(
effectfulFiber
)
;
}
}
}
!
(
capturedError
!
=
null
)
?
reactProdInvariant
(
'
184
'
)
:
void
0
;
switch
(
effectfulFiber
.
tag
)
{
case
ClassComponent
:
var
instance
=
effectfulFiber
.
stateNode
;
var
info
=
{
componentStack
:
capturedError
.
componentStack
}
;
instance
.
componentDidCatch
(
capturedError
.
error
info
)
;
return
;
case
HostRoot
:
if
(
firstUncaughtError
=
=
=
null
)
{
firstUncaughtError
=
capturedError
.
error
;
}
return
;
default
:
reactProdInvariant
(
'
157
'
)
;
}
}
function
unwindContexts
(
from
to
)
{
var
node
=
from
;
while
(
node
!
=
=
null
)
{
switch
(
node
.
tag
)
{
case
ClassComponent
:
popContextProvider
(
node
)
;
break
;
case
HostComponent
:
popHostContext
(
node
)
;
break
;
case
HostRoot
:
popHostContainer
(
node
)
;
break
;
case
HostPortal
:
popHostContainer
(
node
)
;
break
;
}
if
(
node
=
=
=
to
|
|
node
.
alternate
=
=
=
to
)
{
stopFailedWorkTimer
(
node
)
;
break
;
}
else
{
stopWorkTimer
(
node
)
;
}
node
=
node
[
'
return
'
]
;
}
}
function
computeAsyncExpiration
(
)
{
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationMs
=
1000
;
var
bucketSizeMs
=
200
;
return
computeExpirationBucket
(
currentTime
expirationMs
bucketSizeMs
)
;
}
function
computeExpirationForFiber
(
fiber
)
{
var
expirationTime
=
void
0
;
if
(
expirationContext
!
=
=
NoWork
)
{
expirationTime
=
expirationContext
;
}
else
if
(
isWorking
)
{
if
(
isCommitting
)
{
expirationTime
=
Sync
;
}
else
{
expirationTime
=
nextRenderExpirationTime
;
}
}
else
{
if
(
useSyncScheduling
&
&
!
(
fiber
.
internalContextTag
&
AsyncUpdates
)
)
{
expirationTime
=
Sync
;
}
else
{
expirationTime
=
computeAsyncExpiration
(
)
;
}
}
return
expirationTime
;
}
function
scheduleWork
(
fiber
expirationTime
)
{
return
scheduleWorkImpl
(
fiber
expirationTime
false
)
;
}
function
checkRootNeedsClearing
(
root
fiber
expirationTime
)
{
if
(
!
isWorking
&
&
root
=
=
=
nextRoot
&
&
expirationTime
<
nextRenderExpirationTime
)
{
if
(
nextUnitOfWork
!
=
=
null
)
{
interruptedBy
=
fiber
;
}
nextRoot
=
null
;
nextUnitOfWork
=
null
;
nextRenderExpirationTime
=
NoWork
;
}
}
function
scheduleWorkImpl
(
fiber
expirationTime
isErrorRecovery
)
{
recordScheduleUpdate
(
)
;
var
node
=
fiber
;
while
(
node
!
=
=
null
)
{
if
(
node
.
expirationTime
=
=
=
NoWork
|
|
node
.
expirationTime
>
expirationTime
)
{
node
.
expirationTime
=
expirationTime
;
}
if
(
node
.
alternate
!
=
=
null
)
{
if
(
node
.
alternate
.
expirationTime
=
=
=
NoWork
|
|
node
.
alternate
.
expirationTime
>
expirationTime
)
{
node
.
alternate
.
expirationTime
=
expirationTime
;
}
}
if
(
node
[
'
return
'
]
=
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostRoot
)
{
var
root
=
node
.
stateNode
;
checkRootNeedsClearing
(
root
fiber
expirationTime
)
;
requestWork
(
root
expirationTime
)
;
checkRootNeedsClearing
(
root
fiber
expirationTime
)
;
}
else
{
return
;
}
}
node
=
node
[
'
return
'
]
;
}
}
function
scheduleErrorRecovery
(
fiber
)
{
scheduleWorkImpl
(
fiber
Sync
true
)
;
}
function
recalculateCurrentTime
(
)
{
var
ms
=
now
(
)
-
startTime
;
mostRecentCurrentTime
=
msToExpirationTime
(
ms
)
;
return
mostRecentCurrentTime
;
}
function
deferredUpdates
(
fn
)
{
var
previousExpirationContext
=
expirationContext
;
expirationContext
=
computeAsyncExpiration
(
)
;
try
{
return
fn
(
)
;
}
finally
{
expirationContext
=
previousExpirationContext
;
}
}
function
syncUpdates
(
fn
)
{
var
previousExpirationContext
=
expirationContext
;
expirationContext
=
Sync
;
try
{
return
fn
(
)
;
}
finally
{
expirationContext
=
previousExpirationContext
;
}
}
var
firstScheduledRoot
=
null
;
var
lastScheduledRoot
=
null
;
var
callbackExpirationTime
=
NoWork
;
var
callbackID
=
-
1
;
var
isRendering
=
false
;
var
nextFlushedRoot
=
null
;
var
nextFlushedExpirationTime
=
NoWork
;
var
deadlineDidExpire
=
false
;
var
hasUnhandledError
=
false
;
var
unhandledError
=
null
;
var
deadline
=
null
;
var
isBatchingUpdates
=
false
;
var
isUnbatchingUpdates
=
false
;
var
NESTED_UPDATE_LIMIT
=
1000
;
var
nestedUpdateCount
=
0
;
var
timeHeuristicForUnitOfWork
=
1
;
function
scheduleCallbackWithExpiration
(
expirationTime
)
{
if
(
callbackExpirationTime
!
=
=
NoWork
)
{
if
(
expirationTime
>
callbackExpirationTime
)
{
return
;
}
else
{
cancelDeferredCallback
(
callbackID
)
;
}
}
else
{
startRequestCallbackTimer
(
)
;
}
var
currentMs
=
now
(
)
-
startTime
;
var
expirationMs
=
expirationTimeToMs
(
expirationTime
)
;
var
timeout
=
expirationMs
-
currentMs
;
callbackExpirationTime
=
expirationTime
;
callbackID
=
scheduleDeferredCallback
(
performAsyncWork
{
timeout
:
timeout
}
)
;
}
function
requestWork
(
root
expirationTime
)
{
if
(
nestedUpdateCount
>
NESTED_UPDATE_LIMIT
)
{
reactProdInvariant
(
'
185
'
)
;
}
if
(
root
.
nextScheduledRoot
=
=
=
null
)
{
root
.
remainingExpirationTime
=
expirationTime
;
if
(
lastScheduledRoot
=
=
=
null
)
{
firstScheduledRoot
=
lastScheduledRoot
=
root
;
root
.
nextScheduledRoot
=
root
;
}
else
{
lastScheduledRoot
.
nextScheduledRoot
=
root
;
lastScheduledRoot
=
root
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
}
}
else
{
var
remainingExpirationTime
=
root
.
remainingExpirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
|
|
expirationTime
<
remainingExpirationTime
)
{
root
.
remainingExpirationTime
=
expirationTime
;
}
}
if
(
isRendering
)
{
return
;
}
if
(
isBatchingUpdates
)
{
if
(
isUnbatchingUpdates
)
{
nextFlushedRoot
=
root
;
nextFlushedExpirationTime
=
Sync
;
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
)
;
}
return
;
}
if
(
expirationTime
=
=
=
Sync
)
{
performWork
(
Sync
null
)
;
}
else
{
scheduleCallbackWithExpiration
(
expirationTime
)
;
}
}
function
findHighestPriorityRoot
(
)
{
var
highestPriorityWork
=
NoWork
;
var
highestPriorityRoot
=
null
;
if
(
lastScheduledRoot
!
=
=
null
)
{
var
previousScheduledRoot
=
lastScheduledRoot
;
var
root
=
firstScheduledRoot
;
while
(
root
!
=
=
null
)
{
var
remainingExpirationTime
=
root
.
remainingExpirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
)
{
!
(
previousScheduledRoot
!
=
=
null
&
&
lastScheduledRoot
!
=
=
null
)
?
reactProdInvariant
(
'
244
'
)
:
void
0
;
if
(
root
=
=
=
root
.
nextScheduledRoot
)
{
root
.
nextScheduledRoot
=
null
;
firstScheduledRoot
=
lastScheduledRoot
=
null
;
break
;
}
else
if
(
root
=
=
=
firstScheduledRoot
)
{
var
next
=
root
.
nextScheduledRoot
;
firstScheduledRoot
=
next
;
lastScheduledRoot
.
nextScheduledRoot
=
next
;
root
.
nextScheduledRoot
=
null
;
}
else
if
(
root
=
=
=
lastScheduledRoot
)
{
lastScheduledRoot
=
previousScheduledRoot
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
break
;
}
else
{
previousScheduledRoot
.
nextScheduledRoot
=
root
.
nextScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
}
root
=
previousScheduledRoot
.
nextScheduledRoot
;
}
else
{
if
(
highestPriorityWork
=
=
=
NoWork
|
|
remainingExpirationTime
<
highestPriorityWork
)
{
highestPriorityWork
=
remainingExpirationTime
;
highestPriorityRoot
=
root
;
}
if
(
root
=
=
=
lastScheduledRoot
)
{
break
;
}
previousScheduledRoot
=
root
;
root
=
root
.
nextScheduledRoot
;
}
}
}
var
previousFlushedRoot
=
nextFlushedRoot
;
if
(
previousFlushedRoot
!
=
=
null
&
&
previousFlushedRoot
=
=
=
highestPriorityRoot
)
{
nestedUpdateCount
+
+
;
}
else
{
nestedUpdateCount
=
0
;
}
nextFlushedRoot
=
highestPriorityRoot
;
nextFlushedExpirationTime
=
highestPriorityWork
;
}
function
performAsyncWork
(
dl
)
{
performWork
(
NoWork
dl
)
;
}
function
performWork
(
minExpirationTime
dl
)
{
deadline
=
dl
;
findHighestPriorityRoot
(
)
;
if
(
enableUserTimingAPI
&
&
deadline
!
=
=
null
)
{
var
didExpire
=
nextFlushedExpirationTime
<
recalculateCurrentTime
(
)
;
stopRequestCallbackTimer
(
didExpire
)
;
}
while
(
nextFlushedRoot
!
=
=
null
&
&
nextFlushedExpirationTime
!
=
=
NoWork
&
&
(
minExpirationTime
=
=
=
NoWork
|
|
nextFlushedExpirationTime
<
=
minExpirationTime
)
&
&
!
deadlineDidExpire
)
{
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
)
;
findHighestPriorityRoot
(
)
;
}
if
(
deadline
!
=
=
null
)
{
callbackExpirationTime
=
NoWork
;
callbackID
=
-
1
;
}
if
(
nextFlushedExpirationTime
!
=
=
NoWork
)
{
scheduleCallbackWithExpiration
(
nextFlushedExpirationTime
)
;
}
deadline
=
null
;
deadlineDidExpire
=
false
;
nestedUpdateCount
=
0
;
if
(
hasUnhandledError
)
{
var
_error4
=
unhandledError
;
unhandledError
=
null
;
hasUnhandledError
=
false
;
throw
_error4
;
}
}
function
performWorkOnRoot
(
root
expirationTime
)
{
!
!
isRendering
?
reactProdInvariant
(
'
245
'
)
:
void
0
;
isRendering
=
true
;
if
(
expirationTime
<
=
recalculateCurrentTime
(
)
)
{
var
finishedWork
=
root
.
finishedWork
;
if
(
finishedWork
!
=
=
null
)
{
root
.
finishedWork
=
null
;
root
.
remainingExpirationTime
=
commitRoot
(
finishedWork
)
;
}
else
{
root
.
finishedWork
=
null
;
finishedWork
=
renderRoot
(
root
expirationTime
)
;
if
(
finishedWork
!
=
=
null
)
{
root
.
remainingExpirationTime
=
commitRoot
(
finishedWork
)
;
}
}
}
else
{
var
_finishedWork
=
root
.
finishedWork
;
if
(
_finishedWork
!
=
=
null
)
{
root
.
finishedWork
=
null
;
root
.
remainingExpirationTime
=
commitRoot
(
_finishedWork
)
;
}
else
{
root
.
finishedWork
=
null
;
_finishedWork
=
renderRoot
(
root
expirationTime
)
;
if
(
_finishedWork
!
=
=
null
)
{
if
(
!
shouldYield
(
)
)
{
root
.
remainingExpirationTime
=
commitRoot
(
_finishedWork
)
;
}
else
{
root
.
finishedWork
=
_finishedWork
;
}
}
}
}
isRendering
=
false
;
}
function
shouldYield
(
)
{
if
(
deadline
=
=
=
null
)
{
return
false
;
}
if
(
deadline
.
timeRemaining
(
)
>
timeHeuristicForUnitOfWork
)
{
return
false
;
}
deadlineDidExpire
=
true
;
return
true
;
}
function
onUncaughtError
(
error
)
{
!
(
nextFlushedRoot
!
=
=
null
)
?
reactProdInvariant
(
'
246
'
)
:
void
0
;
nextFlushedRoot
.
remainingExpirationTime
=
NoWork
;
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
function
batchedUpdates
(
fn
a
)
{
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
fn
(
a
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performWork
(
Sync
null
)
;
}
}
}
function
unbatchedUpdates
(
fn
)
{
if
(
isBatchingUpdates
&
&
!
isUnbatchingUpdates
)
{
isUnbatchingUpdates
=
true
;
try
{
return
fn
(
)
;
}
finally
{
isUnbatchingUpdates
=
false
;
}
}
return
fn
(
)
;
}
function
flushSync
(
fn
)
{
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
syncUpdates
(
fn
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
!
!
isRendering
?
reactProdInvariant
(
'
187
'
)
:
void
0
;
performWork
(
Sync
null
)
;
}
}
return
{
computeAsyncExpiration
:
computeAsyncExpiration
computeExpirationForFiber
:
computeExpirationForFiber
scheduleWork
:
scheduleWork
batchedUpdates
:
batchedUpdates
unbatchedUpdates
:
unbatchedUpdates
flushSync
:
flushSync
deferredUpdates
:
deferredUpdates
}
;
}
;
function
getContextForSubtree
(
parentComponent
)
{
if
(
!
parentComponent
)
{
return
emptyObject_1
;
}
var
fiber
=
get
(
parentComponent
)
;
var
parentContext
=
findCurrentUnmaskedContext
(
fiber
)
;
return
isContextProvider
(
fiber
)
?
processChildContext
(
fiber
parentContext
)
:
parentContext
;
}
var
ReactFiberReconciler
1
=
function
(
config
)
{
var
getPublicInstance
=
config
.
getPublicInstance
;
var
_ReactFiberScheduler
=
ReactFiberScheduler
(
config
)
computeAsyncExpiration
=
_ReactFiberScheduler
.
computeAsyncExpiration
computeExpirationForFiber
=
_ReactFiberScheduler
.
computeExpirationForFiber
scheduleWork
=
_ReactFiberScheduler
.
scheduleWork
batchedUpdates
=
_ReactFiberScheduler
.
batchedUpdates
unbatchedUpdates
=
_ReactFiberScheduler
.
unbatchedUpdates
flushSync
=
_ReactFiberScheduler
.
flushSync
deferredUpdates
=
_ReactFiberScheduler
.
deferredUpdates
;
function
scheduleTopLevelUpdate
(
current
element
callback
)
{
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
var
expirationTime
=
void
0
;
if
(
enableAsyncSubtreeAPI
&
&
element
!
=
null
&
&
element
.
type
!
=
null
&
&
element
.
type
.
prototype
!
=
null
&
&
element
.
type
.
prototype
.
unstable_isAsyncReactComponent
=
=
=
true
)
{
expirationTime
=
computeAsyncExpiration
(
)
;
}
else
{
expirationTime
=
computeExpirationForFiber
(
current
)
;
}
var
update
=
{
expirationTime
:
expirationTime
partialState
:
{
element
:
element
}
callback
:
callback
isReplace
:
false
isForced
:
false
nextCallback
:
null
next
:
null
}
;
insertUpdateIntoFiber
(
current
update
)
;
scheduleWork
(
current
expirationTime
)
;
}
function
findHostInstance
(
fiber
)
{
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
return
{
createContainer
:
function
(
containerInfo
hydrate
)
{
return
createFiberRoot
(
containerInfo
hydrate
)
;
}
updateContainer
:
function
(
element
container
parentComponent
callback
)
{
var
current
=
container
.
current
;
var
context
=
getContextForSubtree
(
parentComponent
)
;
if
(
container
.
context
=
=
=
null
)
{
container
.
context
=
context
;
}
else
{
container
.
pendingContext
=
context
;
}
scheduleTopLevelUpdate
(
current
element
callback
)
;
}
batchedUpdates
:
batchedUpdates
unbatchedUpdates
:
unbatchedUpdates
deferredUpdates
:
deferredUpdates
flushSync
:
flushSync
getPublicRootInstance
:
function
(
container
)
{
var
containerFiber
=
container
.
current
;
if
(
!
containerFiber
.
child
)
{
return
null
;
}
switch
(
containerFiber
.
child
.
tag
)
{
case
HostComponent
:
return
getPublicInstance
(
containerFiber
.
child
.
stateNode
)
;
default
:
return
containerFiber
.
child
.
stateNode
;
}
}
findHostInstance
:
findHostInstance
findHostInstanceWithNoPortals
:
function
(
fiber
)
{
var
hostFiber
=
findCurrentHostFiberWithNoPortals
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
injectIntoDevTools
:
function
(
devToolsConfig
)
{
var
findFiberByHostInstance
=
devToolsConfig
.
findFiberByHostInstance
;
return
injectInternals
(
_assign
(
{
}
devToolsConfig
{
findHostInstanceByFiber
:
function
(
fiber
)
{
return
findHostInstance
(
fiber
)
;
}
findFiberByHostInstance
:
function
(
instance
)
{
if
(
!
findFiberByHostInstance
)
{
return
null
;
}
return
findFiberByHostInstance
(
instance
)
;
}
}
)
)
;
}
}
;
}
;
var
ReactFiberReconciler
2
=
Object
.
freeze
(
{
default
:
ReactFiberReconciler
1
}
)
;
var
ReactFiberReconciler
3
=
(
ReactFiberReconciler
2
&
&
ReactFiberReconciler
1
)
|
|
ReactFiberReconciler
2
;
var
reactReconciler
=
ReactFiberReconciler
3
[
'
default
'
]
?
ReactFiberReconciler
3
[
'
default
'
]
:
ReactFiberReconciler
3
;
function
createPortal
1
(
children
containerInfo
implementation
)
{
var
key
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
null
;
return
{
typeof
:
REACT_PORTAL_TYPE
key
:
key
=
=
null
?
null
:
'
'
+
key
children
:
children
containerInfo
:
containerInfo
implementation
:
implementation
}
;
}
var
ReactVersion
=
'
16
.
2
.
0
'
;
var
hasNativePerformanceNow
=
typeof
performance
=
=
=
'
object
'
&
&
typeof
performance
.
now
=
=
=
'
function
'
;
var
now
=
void
0
;
if
(
hasNativePerformanceNow
)
{
now
=
function
(
)
{
return
performance
.
now
(
)
;
}
;
}
else
{
now
=
function
(
)
{
return
Date
.
now
(
)
;
}
;
}
var
rIC
=
void
0
;
var
cIC
=
void
0
;
if
(
!
ExecutionEnvironment_1
.
canUseDOM
)
{
rIC
=
function
(
frameCallback
)
{
return
setTimeout
(
function
(
)
{
frameCallback
(
{
timeRemaining
:
function
(
)
{
return
Infinity
;
}
}
)
;
}
)
;
}
;
cIC
=
function
(
timeoutID
)
{
clearTimeout
(
timeoutID
)
;
}
;
}
else
if
(
typeof
requestIdleCallback
!
=
=
'
function
'
|
|
typeof
cancelIdleCallback
!
=
=
'
function
'
)
{
var
scheduledRICCallback
=
null
;
var
isIdleScheduled
=
false
;
var
timeoutTime
=
-
1
;
var
isAnimationFrameScheduled
=
false
;
var
frameDeadline
=
0
;
var
previousFrameTime
=
33
;
var
activeFrameTime
=
33
;
var
frameDeadlineObject
;
if
(
hasNativePerformanceNow
)
{
frameDeadlineObject
=
{
didTimeout
:
false
timeRemaining
:
function
(
)
{
var
remaining
=
frameDeadline
-
performance
.
now
(
)
;
return
remaining
>
0
?
remaining
:
0
;
}
}
;
}
else
{
frameDeadlineObject
=
{
didTimeout
:
false
timeRemaining
:
function
(
)
{
var
remaining
=
frameDeadline
-
Date
.
now
(
)
;
return
remaining
>
0
?
remaining
:
0
;
}
}
;
}
var
messageKey
=
'
__reactIdleCallback
'
+
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
var
idleTick
=
function
(
event
)
{
if
(
event
.
source
!
=
=
window
|
|
event
.
data
!
=
=
messageKey
)
{
return
;
}
isIdleScheduled
=
false
;
var
currentTime
=
now
(
)
;
if
(
frameDeadline
-
currentTime
<
=
0
)
{
if
(
timeoutTime
!
=
=
-
1
&
&
timeoutTime
<
=
currentTime
)
{
frameDeadlineObject
.
didTimeout
=
true
;
}
else
{
if
(
!
isAnimationFrameScheduled
)
{
isAnimationFrameScheduled
=
true
;
requestAnimationFrame
(
animationTick
)
;
}
return
;
}
}
else
{
frameDeadlineObject
.
didTimeout
=
false
;
}
timeoutTime
=
-
1
;
var
callback
=
scheduledRICCallback
;
scheduledRICCallback
=
null
;
if
(
callback
!
=
=
null
)
{
callback
(
frameDeadlineObject
)
;
}
}
;
window
.
addEventListener
(
'
message
'
idleTick
false
)
;
var
animationTick
=
function
(
rafTime
)
{
isAnimationFrameScheduled
=
false
;
var
nextFrameTime
=
rafTime
-
frameDeadline
+
activeFrameTime
;
if
(
nextFrameTime
<
activeFrameTime
&
&
previousFrameTime
<
activeFrameTime
)
{
if
(
nextFrameTime
<
8
)
{
nextFrameTime
=
8
;
}
activeFrameTime
=
nextFrameTime
<
previousFrameTime
?
previousFrameTime
:
nextFrameTime
;
}
else
{
previousFrameTime
=
nextFrameTime
;
}
frameDeadline
=
rafTime
+
activeFrameTime
;
if
(
!
isIdleScheduled
)
{
isIdleScheduled
=
true
;
window
.
postMessage
(
messageKey
'
*
'
)
;
}
}
;
rIC
=
function
(
callback
options
)
{
scheduledRICCallback
=
callback
;
if
(
options
!
=
null
&
&
typeof
options
.
timeout
=
=
=
'
number
'
)
{
timeoutTime
=
now
(
)
+
options
.
timeout
;
}
if
(
!
isAnimationFrameScheduled
)
{
isAnimationFrameScheduled
=
true
;
requestAnimationFrame
(
animationTick
)
;
}
return
0
;
}
;
cIC
=
function
(
)
{
scheduledRICCallback
=
null
;
isIdleScheduled
=
false
;
timeoutTime
=
-
1
;
}
;
}
else
{
rIC
=
window
.
requestIdleCallback
;
cIC
=
window
.
cancelIdleCallback
;
}
var
VALID_ATTRIBUTE_NAME_REGEX
=
new
RegExp
(
'
^
[
'
+
ATTRIBUTE_NAME_START_CHAR
+
'
]
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
var
illegalAttributeNameCache
=
{
}
;
var
validatedAttributeNameCache
=
{
}
;
function
isAttributeNameSafe
(
attributeName
)
{
if
(
validatedAttributeNameCache
.
hasOwnProperty
(
attributeName
)
)
{
return
true
;
}
if
(
illegalAttributeNameCache
.
hasOwnProperty
(
attributeName
)
)
{
return
false
;
}
if
(
VALID_ATTRIBUTE_NAME_REGEX
.
test
(
attributeName
)
)
{
validatedAttributeNameCache
[
attributeName
]
=
true
;
return
true
;
}
illegalAttributeNameCache
[
attributeName
]
=
true
;
return
false
;
}
function
shouldIgnoreValue
(
propertyInfo
value
)
{
return
value
=
=
null
|
|
propertyInfo
.
hasBooleanValue
&
&
!
value
|
|
propertyInfo
.
hasNumericValue
&
&
isNaN
(
value
)
|
|
propertyInfo
.
hasPositiveNumericValue
&
&
value
<
1
|
|
propertyInfo
.
hasOverloadedBooleanValue
&
&
value
=
=
=
false
;
}
function
setValueForProperty
(
node
name
value
)
{
var
propertyInfo
=
getPropertyInfo
(
name
)
;
if
(
propertyInfo
&
&
shouldSetAttribute
(
name
value
)
)
{
var
mutationMethod
=
propertyInfo
.
mutationMethod
;
if
(
mutationMethod
)
{
mutationMethod
(
node
value
)
;
}
else
if
(
shouldIgnoreValue
(
propertyInfo
value
)
)
{
deleteValueForProperty
(
node
name
)
;
return
;
}
else
if
(
propertyInfo
.
mustUseProperty
)
{
node
[
propertyInfo
.
propertyName
]
=
value
;
}
else
{
var
attributeName
=
propertyInfo
.
attributeName
;
var
namespace
=
propertyInfo
.
attributeNamespace
;
if
(
namespace
)
{
node
.
setAttributeNS
(
namespace
attributeName
'
'
+
value
)
;
}
else
if
(
propertyInfo
.
hasBooleanValue
|
|
propertyInfo
.
hasOverloadedBooleanValue
&
&
value
=
=
=
true
)
{
node
.
setAttribute
(
attributeName
'
'
)
;
}
else
{
node
.
setAttribute
(
attributeName
'
'
+
value
)
;
}
}
}
else
{
setValueForAttribute
(
node
name
shouldSetAttribute
(
name
value
)
?
value
:
null
)
;
return
;
}
}
function
setValueForAttribute
(
node
name
value
)
{
if
(
!
isAttributeNameSafe
(
name
)
)
{
return
;
}
if
(
value
=
=
null
)
{
node
.
removeAttribute
(
name
)
;
}
else
{
node
.
setAttribute
(
name
'
'
+
value
)
;
}
}
function
deleteValueForAttribute
(
node
name
)
{
node
.
removeAttribute
(
name
)
;
}
function
deleteValueForProperty
(
node
name
)
{
var
propertyInfo
=
getPropertyInfo
(
name
)
;
if
(
propertyInfo
)
{
var
mutationMethod
=
propertyInfo
.
mutationMethod
;
if
(
mutationMethod
)
{
mutationMethod
(
node
undefined
)
;
}
else
if
(
propertyInfo
.
mustUseProperty
)
{
var
propName
=
propertyInfo
.
propertyName
;
if
(
propertyInfo
.
hasBooleanValue
)
{
node
[
propName
]
=
false
;
}
else
{
node
[
propName
]
=
'
'
;
}
}
else
{
node
.
removeAttribute
(
propertyInfo
.
attributeName
)
;
}
}
else
{
node
.
removeAttribute
(
name
)
;
}
}
function
isControlled
(
props
)
{
var
usesChecked
=
props
.
type
=
=
=
'
checkbox
'
|
|
props
.
type
=
=
=
'
radio
'
;
return
usesChecked
?
props
.
checked
!
=
null
:
props
.
value
!
=
null
;
}
function
getHostProps
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
var
checked
=
props
.
checked
;
var
hostProps
=
_assign
(
{
type
:
undefined
step
:
undefined
min
:
undefined
max
:
undefined
}
props
{
defaultChecked
:
undefined
defaultValue
:
undefined
value
:
value
!
=
null
?
value
:
node
.
_wrapperState
.
initialValue
checked
:
checked
!
=
null
?
checked
:
node
.
_wrapperState
.
initialChecked
}
)
;
return
hostProps
;
}
function
initWrapperState
(
element
props
)
{
var
defaultValue
=
props
.
defaultValue
;
var
node
=
element
;
node
.
_wrapperState
=
{
initialChecked
:
props
.
checked
!
=
null
?
props
.
checked
:
props
.
defaultChecked
initialValue
:
props
.
value
!
=
null
?
props
.
value
:
defaultValue
controlled
:
isControlled
(
props
)
}
;
}
function
updateChecked
(
element
props
)
{
var
node
=
element
;
var
checked
=
props
.
checked
;
if
(
checked
!
=
null
)
{
setValueForProperty
(
node
'
checked
'
checked
)
;
}
}
function
updateWrapper
(
element
props
)
{
var
node
=
element
;
updateChecked
(
element
props
)
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
if
(
value
=
=
=
0
&
&
node
.
value
=
=
=
'
'
)
{
node
.
value
=
'
0
'
;
}
else
if
(
props
.
type
=
=
=
'
number
'
)
{
var
valueAsNumber
=
parseFloat
(
node
.
value
)
|
|
0
;
if
(
value
!
=
valueAsNumber
|
|
value
=
=
valueAsNumber
&
&
node
.
value
!
=
value
)
{
node
.
value
=
'
'
+
value
;
}
}
else
if
(
node
.
value
!
=
=
'
'
+
value
)
{
node
.
value
=
'
'
+
value
;
}
}
else
{
if
(
props
.
value
=
=
null
&
&
props
.
defaultValue
!
=
null
)
{
if
(
node
.
defaultValue
!
=
=
'
'
+
props
.
defaultValue
)
{
node
.
defaultValue
=
'
'
+
props
.
defaultValue
;
}
}
if
(
props
.
checked
=
=
null
&
&
props
.
defaultChecked
!
=
null
)
{
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
}
function
postMountWrapper
(
element
props
)
{
var
node
=
element
;
switch
(
props
.
type
)
{
case
'
submit
'
:
case
'
reset
'
:
break
;
case
'
color
'
:
case
'
date
'
:
case
'
datetime
'
:
case
'
datetime
-
local
'
:
case
'
month
'
:
case
'
time
'
:
case
'
week
'
:
node
.
value
=
'
'
;
node
.
value
=
node
.
defaultValue
;
break
;
default
:
node
.
value
=
node
.
value
;
break
;
}
var
name
=
node
.
name
;
if
(
name
!
=
=
'
'
)
{
node
.
name
=
'
'
;
}
node
.
defaultChecked
=
!
node
.
defaultChecked
;
node
.
defaultChecked
=
!
node
.
defaultChecked
;
if
(
name
!
=
=
'
'
)
{
node
.
name
=
name
;
}
}
function
restoreControlledState
1
(
element
props
)
{
var
node
=
element
;
updateWrapper
(
node
props
)
;
updateNamedCousins
(
node
props
)
;
}
function
updateNamedCousins
(
rootNode
props
)
{
var
name
=
props
.
name
;
if
(
props
.
type
=
=
=
'
radio
'
&
&
name
!
=
null
)
{
var
queryRoot
=
rootNode
;
while
(
queryRoot
.
parentNode
)
{
queryRoot
=
queryRoot
.
parentNode
;
}
var
group
=
queryRoot
.
querySelectorAll
(
'
input
[
name
=
'
+
JSON
.
stringify
(
'
'
+
name
)
+
'
]
[
type
=
"
radio
"
]
'
)
;
for
(
var
i
=
0
;
i
<
group
.
length
;
i
+
+
)
{
var
otherNode
=
group
[
i
]
;
if
(
otherNode
=
=
=
rootNode
|
|
otherNode
.
form
!
=
=
rootNode
.
form
)
{
continue
;
}
var
otherProps
=
getFiberCurrentPropsFromNode
1
(
otherNode
)
;
!
otherProps
?
reactProdInvariant
(
'
90
'
)
:
void
0
;
updateValueIfChanged
(
otherNode
)
;
updateWrapper
(
otherNode
otherProps
)
;
}
}
}
function
flattenChildren
(
children
)
{
var
content
=
'
'
;
React
.
Children
.
forEach
(
children
function
(
child
)
{
if
(
child
=
=
null
)
{
return
;
}
if
(
typeof
child
=
=
=
'
string
'
|
|
typeof
child
=
=
=
'
number
'
)
{
content
+
=
child
;
}
}
)
;
return
content
;
}
function
postMountWrapper
1
(
element
props
)
{
if
(
props
.
value
!
=
null
)
{
element
.
setAttribute
(
'
value
'
props
.
value
)
;
}
}
function
getHostProps
1
(
element
props
)
{
var
hostProps
=
_assign
(
{
children
:
undefined
}
props
)
;
var
content
=
flattenChildren
(
props
.
children
)
;
if
(
content
)
{
hostProps
.
children
=
content
;
}
return
hostProps
;
}
function
updateOptions
(
node
multiple
propValue
setDefaultSelected
)
{
var
options
=
node
.
options
;
if
(
multiple
)
{
var
selectedValues
=
propValue
;
var
selectedValue
=
{
}
;
for
(
var
i
=
0
;
i
<
selectedValues
.
length
;
i
+
+
)
{
selectedValue
[
'
'
+
selectedValues
[
i
]
]
=
true
;
}
for
(
var
_i
=
0
;
_i
<
options
.
length
;
_i
+
+
)
{
var
selected
=
selectedValue
.
hasOwnProperty
(
'
'
+
options
[
_i
]
.
value
)
;
if
(
options
[
_i
]
.
selected
!
=
=
selected
)
{
options
[
_i
]
.
selected
=
selected
;
}
if
(
selected
&
&
setDefaultSelected
)
{
options
[
_i
]
.
defaultSelected
=
true
;
}
}
}
else
{
var
_selectedValue
=
'
'
+
propValue
;
var
defaultSelected
=
null
;
for
(
var
_i2
=
0
;
_i2
<
options
.
length
;
_i2
+
+
)
{
if
(
options
[
_i2
]
.
value
=
=
=
_selectedValue
)
{
options
[
_i2
]
.
selected
=
true
;
if
(
setDefaultSelected
)
{
options
[
_i2
]
.
defaultSelected
=
true
;
}
return
;
}
if
(
defaultSelected
=
=
=
null
&
&
!
options
[
_i2
]
.
disabled
)
{
defaultSelected
=
options
[
_i2
]
;
}
}
if
(
defaultSelected
!
=
=
null
)
{
defaultSelected
.
selected
=
true
;
}
}
}
function
getHostProps
2
(
element
props
)
{
return
_assign
(
{
}
props
{
value
:
undefined
}
)
;
}
function
initWrapperState
1
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
node
.
_wrapperState
=
{
initialValue
:
value
!
=
null
?
value
:
props
.
defaultValue
wasMultiple
:
!
!
props
.
multiple
}
;
}
function
postMountWrapper
2
(
element
props
)
{
var
node
=
element
;
node
.
multiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
}
function
postUpdateWrapper
(
element
props
)
{
var
node
=
element
;
node
.
_wrapperState
.
initialValue
=
undefined
;
var
wasMultiple
=
node
.
_wrapperState
.
wasMultiple
;
node
.
_wrapperState
.
wasMultiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
wasMultiple
!
=
=
!
!
props
.
multiple
)
{
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
else
{
updateOptions
(
node
!
!
props
.
multiple
props
.
multiple
?
[
]
:
'
'
false
)
;
}
}
}
function
restoreControlledState
2
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
}
function
getHostProps
3
(
element
props
)
{
var
node
=
element
;
!
(
props
.
dangerouslySetInnerHTML
=
=
null
)
?
reactProdInvariant
(
'
91
'
)
:
void
0
;
var
hostProps
=
_assign
(
{
}
props
{
value
:
undefined
defaultValue
:
undefined
children
:
'
'
+
node
.
_wrapperState
.
initialValue
}
)
;
return
hostProps
;
}
function
initWrapperState
2
(
element
props
)
{
var
node
=
element
;
var
initialValue
=
props
.
value
;
if
(
initialValue
=
=
null
)
{
var
defaultValue
=
props
.
defaultValue
;
var
children
=
props
.
children
;
if
(
children
!
=
null
)
{
!
(
defaultValue
=
=
null
)
?
reactProdInvariant
(
'
92
'
)
:
void
0
;
if
(
Array
.
isArray
(
children
)
)
{
!
(
children
.
length
<
=
1
)
?
reactProdInvariant
(
'
93
'
)
:
void
0
;
children
=
children
[
0
]
;
}
defaultValue
=
'
'
+
children
;
}
if
(
defaultValue
=
=
null
)
{
defaultValue
=
'
'
;
}
initialValue
=
defaultValue
;
}
node
.
_wrapperState
=
{
initialValue
:
'
'
+
initialValue
}
;
}
function
updateWrapper
1
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
var
newValue
=
'
'
+
value
;
if
(
newValue
!
=
=
node
.
value
)
{
node
.
value
=
newValue
;
}
if
(
props
.
defaultValue
=
=
null
)
{
node
.
defaultValue
=
newValue
;
}
}
if
(
props
.
defaultValue
!
=
null
)
{
node
.
defaultValue
=
props
.
defaultValue
;
}
}
function
postMountWrapper
3
(
element
props
)
{
var
node
=
element
;
var
textContent
=
node
.
textContent
;
if
(
textContent
=
=
=
node
.
_wrapperState
.
initialValue
)
{
node
.
value
=
textContent
;
}
}
function
restoreControlledState
3
(
element
props
)
{
updateWrapper
1
(
element
props
)
;
}
var
HTML_NAMESPACE
1
=
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
;
var
MATH_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
'
;
var
SVG_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
var
Namespaces
=
{
html
:
HTML_NAMESPACE
1
mathml
:
MATH_NAMESPACE
svg
:
SVG_NAMESPACE
}
;
function
getIntrinsicNamespace
(
type
)
{
switch
(
type
)
{
case
'
svg
'
:
return
SVG_NAMESPACE
;
case
'
math
'
:
return
MATH_NAMESPACE
;
default
:
return
HTML_NAMESPACE
1
;
}
}
function
getChildNamespace
(
parentNamespace
type
)
{
if
(
parentNamespace
=
=
null
|
|
parentNamespace
=
=
=
HTML_NAMESPACE
1
)
{
return
getIntrinsicNamespace
(
type
)
;
}
if
(
parentNamespace
=
=
=
SVG_NAMESPACE
&
&
type
=
=
=
'
foreignObject
'
)
{
return
HTML_NAMESPACE
1
;
}
return
parentNamespace
;
}
var
createMicrosoftUnsafeLocalFunction
=
function
(
func
)
{
if
(
typeof
MSApp
!
=
=
'
undefined
'
&
&
MSApp
.
execUnsafeLocalFunction
)
{
return
function
(
arg0
arg1
arg2
arg3
)
{
MSApp
.
execUnsafeLocalFunction
(
function
(
)
{
return
func
(
arg0
arg1
arg2
arg3
)
;
}
)
;
}
;
}
else
{
return
func
;
}
}
;
var
reusableSVGContainer
=
void
0
;
var
setInnerHTML
=
createMicrosoftUnsafeLocalFunction
(
function
(
node
html
)
{
if
(
node
.
namespaceURI
=
=
=
Namespaces
.
svg
&
&
!
(
'
innerHTML
'
in
node
)
)
{
reusableSVGContainer
=
reusableSVGContainer
|
|
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
reusableSVGContainer
.
innerHTML
=
'
<
svg
>
'
+
html
+
'
<
/
svg
>
'
;
var
svgNode
=
reusableSVGContainer
.
firstChild
;
while
(
node
.
firstChild
)
{
node
.
removeChild
(
node
.
firstChild
)
;
}
while
(
svgNode
.
firstChild
)
{
node
.
appendChild
(
svgNode
.
firstChild
)
;
}
}
else
{
node
.
innerHTML
=
html
;
}
}
)
;
var
setTextContent
=
function
(
node
text
)
{
if
(
text
)
{
var
firstChild
=
node
.
firstChild
;
if
(
firstChild
&
&
firstChild
=
=
=
node
.
lastChild
&
&
firstChild
.
nodeType
=
=
=
TEXT_NODE
)
{
firstChild
.
nodeValue
=
text
;
return
;
}
}
node
.
textContent
=
text
;
}
;
var
isUnitlessNumber
=
{
animationIterationCount
:
true
borderImageOutset
:
true
borderImageSlice
:
true
borderImageWidth
:
true
boxFlex
:
true
boxFlexGroup
:
true
boxOrdinalGroup
:
true
columnCount
:
true
columns
:
true
flex
:
true
flexGrow
:
true
flexPositive
:
true
flexShrink
:
true
flexNegative
:
true
flexOrder
:
true
gridRow
:
true
gridRowEnd
:
true
gridRowSpan
:
true
gridRowStart
:
true
gridColumn
:
true
gridColumnEnd
:
true
gridColumnSpan
:
true
gridColumnStart
:
true
fontWeight
:
true
lineClamp
:
true
lineHeight
:
true
opacity
:
true
order
:
true
orphans
:
true
tabSize
:
true
widows
:
true
zIndex
:
true
zoom
:
true
fillOpacity
:
true
floodOpacity
:
true
stopOpacity
:
true
strokeDasharray
:
true
strokeDashoffset
:
true
strokeMiterlimit
:
true
strokeOpacity
:
true
strokeWidth
:
true
}
;
function
prefixKey
(
prefix
key
)
{
return
prefix
+
key
.
charAt
(
0
)
.
toUpperCase
(
)
+
key
.
substring
(
1
)
;
}
var
prefixes
=
[
'
Webkit
'
'
ms
'
'
Moz
'
'
O
'
]
;
Object
.
keys
(
isUnitlessNumber
)
.
forEach
(
function
(
prop
)
{
prefixes
.
forEach
(
function
(
prefix
)
{
isUnitlessNumber
[
prefixKey
(
prefix
prop
)
]
=
isUnitlessNumber
[
prop
]
;
}
)
;
}
)
;
function
dangerousStyleValue
(
name
value
isCustomProperty
)
{
var
isEmpty
=
value
=
=
null
|
|
typeof
value
=
=
=
'
boolean
'
|
|
value
=
=
=
'
'
;
if
(
isEmpty
)
{
return
'
'
;
}
if
(
!
isCustomProperty
&
&
typeof
value
=
=
=
'
number
'
&
&
value
!
=
=
0
&
&
!
(
isUnitlessNumber
.
hasOwnProperty
(
name
)
&
&
isUnitlessNumber
[
name
]
)
)
{
return
value
+
'
px
'
;
}
return
(
'
'
+
value
)
.
trim
(
)
;
}
function
setValueForStyles
(
node
styles
getStack
)
{
var
style
=
node
.
style
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
isCustomProperty
=
styleName
.
indexOf
(
'
-
-
'
)
=
=
=
0
;
var
styleValue
=
dangerousStyleValue
(
styleName
styles
[
styleName
]
isCustomProperty
)
;
if
(
styleName
=
=
=
'
float
'
)
{
styleName
=
'
cssFloat
'
;
}
if
(
isCustomProperty
)
{
style
.
setProperty
(
styleName
styleValue
)
;
}
else
{
style
[
styleName
]
=
styleValue
;
}
}
}
var
omittedCloseTags
=
{
area
:
true
base
:
true
br
:
true
col
:
true
embed
:
true
hr
:
true
img
:
true
input
:
true
keygen
:
true
link
:
true
meta
:
true
param
:
true
source
:
true
track
:
true
wbr
:
true
}
;
var
voidElementTags
=
_assign
(
{
menuitem
:
true
}
omittedCloseTags
)
;
var
HTML
1
=
'
__html
'
;
function
assertValidProps
(
tag
props
getStack
)
{
if
(
!
props
)
{
return
;
}
if
(
voidElementTags
[
tag
]
)
{
!
(
props
.
children
=
=
null
&
&
props
.
dangerouslySetInnerHTML
=
=
null
)
?
reactProdInvariant
(
'
137
'
tag
getStack
(
)
)
:
void
0
;
}
if
(
props
.
dangerouslySetInnerHTML
!
=
null
)
{
!
(
props
.
children
=
=
null
)
?
reactProdInvariant
(
'
60
'
)
:
void
0
;
!
(
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
HTML
1
in
props
.
dangerouslySetInnerHTML
)
?
reactProdInvariant
(
'
61
'
)
:
void
0
;
}
!
(
props
.
style
=
=
null
|
|
typeof
props
.
style
=
=
=
'
object
'
)
?
reactProdInvariant
(
'
62
'
getStack
(
)
)
:
void
0
;
}
function
isCustomComponent
(
tagName
props
)
{
if
(
tagName
.
indexOf
(
'
-
'
)
=
=
=
-
1
)
{
return
typeof
props
.
is
=
=
=
'
string
'
;
}
switch
(
tagName
)
{
case
'
annotation
-
xml
'
:
case
'
color
-
profile
'
:
case
'
font
-
face
'
:
case
'
font
-
face
-
src
'
:
case
'
font
-
face
-
uri
'
:
case
'
font
-
face
-
format
'
:
case
'
font
-
face
-
name
'
:
case
'
missing
-
glyph
'
:
return
false
;
default
:
return
true
;
}
}
var
DANGEROUSLY_SET_INNER_HTML
=
'
dangerouslySetInnerHTML
'
;
var
SUPPRESS_CONTENT_EDITABLE_WARNING
=
'
suppressContentEditableWarning
'
;
var
SUPPRESS_HYDRATION_WARNING
1
=
'
suppressHydrationWarning
'
;
var
AUTOFOCUS
=
'
autoFocus
'
;
var
CHILDREN
=
'
children
'
;
var
STYLE
=
'
style
'
;
var
HTML
=
'
__html
'
;
var
HTML_NAMESPACE
=
Namespaces
.
html
;
var
getStack
=
emptyFunction_1
.
thatReturns
(
'
'
)
;
function
ensureListeningTo
(
rootContainerElement
registrationName
)
{
var
isDocumentOrFragment
=
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
;
var
doc
=
isDocumentOrFragment
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
listenTo
(
registrationName
doc
)
;
}
function
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
{
return
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
}
var
mediaEvents
=
{
topAbort
:
'
abort
'
topCanPlay
:
'
canplay
'
topCanPlayThrough
:
'
canplaythrough
'
topDurationChange
:
'
durationchange
'
topEmptied
:
'
emptied
'
topEncrypted
:
'
encrypted
'
topEnded
:
'
ended
'
topError
:
'
error
'
topLoadedData
:
'
loadeddata
'
topLoadedMetadata
:
'
loadedmetadata
'
topLoadStart
:
'
loadstart
'
topPause
:
'
pause
'
topPlay
:
'
play
'
topPlaying
:
'
playing
'
topProgress
:
'
progress
'
topRateChange
:
'
ratechange
'
topSeeked
:
'
seeked
'
topSeeking
:
'
seeking
'
topStalled
:
'
stalled
'
topSuspend
:
'
suspend
'
topTimeUpdate
:
'
timeupdate
'
topVolumeChange
:
'
volumechange
'
topWaiting
:
'
waiting
'
}
;
function
trapClickOnNonInteractiveElement
(
node
)
{
node
.
onclick
=
emptyFunction_1
;
}
function
setInitialDOMProperties
(
tag
domElement
rootContainerElement
nextProps
isCustomComponentTag
)
{
for
(
var
propKey
in
nextProps
)
{
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
nextProps
[
propKey
]
;
if
(
propKey
=
=
=
STYLE
)
{
setValueForStyles
(
domElement
nextProp
getStack
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
setInnerHTML
(
domElement
nextHtml
)
;
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
var
canSetTextContent
=
tag
!
=
=
'
textarea
'
|
|
nextProp
!
=
=
'
'
;
if
(
canSetTextContent
)
{
setTextContent
(
domElement
nextProp
)
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
setTextContent
(
domElement
'
'
+
nextProp
)
;
}
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
if
(
isCustomComponentTag
)
{
setValueForAttribute
(
domElement
propKey
nextProp
)
;
}
else
if
(
nextProp
!
=
null
)
{
setValueForProperty
(
domElement
propKey
nextProp
)
;
}
}
}
function
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
{
for
(
var
i
=
0
;
i
<
updatePayload
.
length
;
i
+
=
2
)
{
var
propKey
=
updatePayload
[
i
]
;
var
propValue
=
updatePayload
[
i
+
1
]
;
if
(
propKey
=
=
=
STYLE
)
{
setValueForStyles
(
domElement
propValue
getStack
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
setInnerHTML
(
domElement
propValue
)
;
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
setTextContent
(
domElement
propValue
)
;
}
else
if
(
isCustomComponentTag
)
{
if
(
propValue
!
=
null
)
{
setValueForAttribute
(
domElement
propKey
propValue
)
;
}
else
{
deleteValueForAttribute
(
domElement
propKey
)
;
}
}
else
if
(
propValue
!
=
null
)
{
setValueForProperty
(
domElement
propKey
propValue
)
;
}
else
{
deleteValueForProperty
(
domElement
propKey
)
;
}
}
}
function
createElement
1
(
type
props
rootContainerElement
parentNamespace
)
{
var
ownerDocument
=
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
;
var
domElement
;
var
namespaceURI
=
parentNamespace
;
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
namespaceURI
=
getIntrinsicNamespace
(
type
)
;
}
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
if
(
type
=
=
=
'
script
'
)
{
var
div
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
div
.
innerHTML
=
'
<
script
>
<
'
+
'
/
script
>
'
;
var
firstChild
=
div
.
firstChild
;
domElement
=
div
.
removeChild
(
firstChild
)
;
}
else
if
(
typeof
props
.
is
=
=
=
'
string
'
)
{
domElement
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
type
{
is
:
props
.
is
}
)
;
}
else
{
domElement
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
type
)
;
}
}
else
{
domElement
=
ownerDocument
.
createElementNS
(
namespaceURI
type
)
;
}
return
domElement
;
}
function
createTextNode
1
(
text
rootContainerElement
)
{
return
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
.
createTextNode
(
text
)
;
}
function
setInitialProperties
1
(
domElement
tag
rawProps
rootContainerElement
)
{
var
isCustomComponentTag
=
isCustomComponent
(
tag
rawProps
)
;
var
props
;
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
trapBubbledEvent
(
'
topLoad
'
'
load
'
domElement
)
;
props
=
rawProps
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
event
in
mediaEvents
)
{
if
(
mediaEvents
.
hasOwnProperty
(
event
)
)
{
trapBubbledEvent
(
event
mediaEvents
[
event
]
domElement
)
;
}
}
props
=
rawProps
;
break
;
case
'
source
'
:
trapBubbledEvent
(
'
topError
'
'
error
'
domElement
)
;
props
=
rawProps
;
break
;
case
'
img
'
:
case
'
image
'
:
trapBubbledEvent
(
'
topError
'
'
error
'
domElement
)
;
trapBubbledEvent
(
'
topLoad
'
'
load
'
domElement
)
;
props
=
rawProps
;
break
;
case
'
form
'
:
trapBubbledEvent
(
'
topReset
'
'
reset
'
domElement
)
;
trapBubbledEvent
(
'
topSubmit
'
'
submit
'
domElement
)
;
props
=
rawProps
;
break
;
case
'
details
'
:
trapBubbledEvent
(
'
topToggle
'
'
toggle
'
domElement
)
;
props
=
rawProps
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
props
=
getHostProps
(
domElement
rawProps
)
;
trapBubbledEvent
(
'
topInvalid
'
'
invalid
'
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
props
=
getHostProps
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
props
=
getHostProps
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
'
topInvalid
'
'
invalid
'
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
props
=
getHostProps
3
(
domElement
rawProps
)
;
trapBubbledEvent
(
'
topInvalid
'
'
invalid
'
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
default
:
props
=
rawProps
;
}
assertValidProps
(
tag
props
getStack
)
;
setInitialDOMProperties
(
tag
domElement
rootContainerElement
props
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
option
'
:
postMountWrapper
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
postMountWrapper
2
(
domElement
rawProps
)
;
break
;
default
:
if
(
typeof
props
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
}
function
diffProperties
1
(
domElement
tag
lastRawProps
nextRawProps
rootContainerElement
)
{
var
updatePayload
=
null
;
var
lastProps
;
var
nextProps
;
switch
(
tag
)
{
case
'
input
'
:
lastProps
=
getHostProps
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
option
'
:
lastProps
=
getHostProps
1
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
1
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
select
'
:
lastProps
=
getHostProps
2
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
2
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
textarea
'
:
lastProps
=
getHostProps
3
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
3
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
default
:
lastProps
=
lastRawProps
;
nextProps
=
nextRawProps
;
if
(
typeof
lastProps
.
onClick
!
=
=
'
function
'
&
&
typeof
nextProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
assertValidProps
(
tag
nextProps
getStack
)
;
var
propKey
;
var
styleName
;
var
styleUpdates
=
null
;
for
(
propKey
in
lastProps
)
{
if
(
nextProps
.
hasOwnProperty
(
propKey
)
|
|
!
lastProps
.
hasOwnProperty
(
propKey
)
|
|
lastProps
[
propKey
]
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
var
lastStyle
=
lastProps
[
propKey
]
;
for
(
styleName
in
lastStyle
)
{
if
(
lastStyle
.
hasOwnProperty
(
styleName
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
|
|
propKey
=
=
=
CHILDREN
)
{
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
null
)
;
}
}
for
(
propKey
in
nextProps
)
{
var
nextProp
=
nextProps
[
propKey
]
;
var
lastProp
=
lastProps
!
=
null
?
lastProps
[
propKey
]
:
undefined
;
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
|
|
nextProp
=
=
=
lastProp
|
|
nextProp
=
=
null
&
&
lastProp
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
if
(
lastProp
)
{
for
(
styleName
in
lastProp
)
{
if
(
lastProp
.
hasOwnProperty
(
styleName
)
&
&
(
!
nextProp
|
|
!
nextProp
.
hasOwnProperty
(
styleName
)
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
for
(
styleName
in
nextProp
)
{
if
(
nextProp
.
hasOwnProperty
(
styleName
)
&
&
lastProp
[
styleName
]
!
=
=
nextProp
[
styleName
]
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
nextProp
[
styleName
]
;
}
}
}
else
{
if
(
!
styleUpdates
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
updatePayload
.
push
(
propKey
styleUpdates
)
;
}
styleUpdates
=
nextProp
;
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
var
lastHtml
=
lastProp
?
lastProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
if
(
lastHtml
!
=
=
nextHtml
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
'
'
+
nextHtml
)
;
}
}
else
{
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
lastProp
!
=
=
nextProp
&
&
(
typeof
nextProp
=
=
=
'
string
'
|
|
typeof
nextProp
=
=
=
'
number
'
)
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
'
'
+
nextProp
)
;
}
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
if
(
!
updatePayload
&
&
lastProp
!
=
=
nextProp
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
nextProp
)
;
}
}
if
(
styleUpdates
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
STYLE
styleUpdates
)
;
}
return
updatePayload
;
}
function
updateProperties
1
(
domElement
updatePayload
tag
lastRawProps
nextRawProps
)
{
if
(
tag
=
=
=
'
input
'
&
&
nextRawProps
.
type
=
=
=
'
radio
'
&
&
nextRawProps
.
name
!
=
null
)
{
updateChecked
(
domElement
nextRawProps
)
;
}
var
wasCustomComponentTag
=
isCustomComponent
(
tag
lastRawProps
)
;
var
isCustomComponentTag
=
isCustomComponent
(
tag
nextRawProps
)
;
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
updateWrapper
(
domElement
nextRawProps
)
;
break
;
case
'
textarea
'
:
updateWrapper
1
(
domElement
nextRawProps
)
;
break
;
case
'
select
'
:
postUpdateWrapper
(
domElement
nextRawProps
)
;
break
;
}
}
function
diffHydratedProperties
1
(
domElement
tag
rawProps
parentNamespace
rootContainerElement
)
{
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
trapBubbledEvent
(
'
topLoad
'
'
load
'
domElement
)
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
event
in
mediaEvents
)
{
if
(
mediaEvents
.
hasOwnProperty
(
event
)
)
{
trapBubbledEvent
(
event
mediaEvents
[
event
]
domElement
)
;
}
}
break
;
case
'
source
'
:
trapBubbledEvent
(
'
topError
'
'
error
'
domElement
)
;
break
;
case
'
img
'
:
case
'
image
'
:
trapBubbledEvent
(
'
topError
'
'
error
'
domElement
)
;
trapBubbledEvent
(
'
topLoad
'
'
load
'
domElement
)
;
break
;
case
'
form
'
:
trapBubbledEvent
(
'
topReset
'
'
reset
'
domElement
)
;
trapBubbledEvent
(
'
topSubmit
'
'
submit
'
domElement
)
;
break
;
case
'
details
'
:
trapBubbledEvent
(
'
topToggle
'
'
toggle
'
domElement
)
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
trapBubbledEvent
(
'
topInvalid
'
'
invalid
'
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
trapBubbledEvent
(
'
topInvalid
'
'
invalid
'
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
'
topInvalid
'
'
invalid
'
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
}
assertValidProps
(
tag
rawProps
getStack
)
;
var
updatePayload
=
null
;
for
(
var
propKey
in
rawProps
)
{
if
(
!
rawProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
rawProps
[
propKey
]
;
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
if
(
domElement
.
textContent
!
=
=
nextProp
)
{
updatePayload
=
[
CHILDREN
nextProp
]
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
if
(
domElement
.
textContent
!
=
=
'
'
+
nextProp
)
{
updatePayload
=
[
CHILDREN
'
'
+
nextProp
]
;
}
}
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
{
}
}
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
case
'
option
'
:
break
;
default
:
if
(
typeof
rawProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
return
updatePayload
;
}
function
diffHydratedText
1
(
textNode
text
)
{
var
isDifferent
=
textNode
.
nodeValue
!
=
=
text
;
return
isDifferent
;
}
function
warnForUnmatchedText
1
(
textNode
text
)
{
}
function
warnForDeletedHydratableElement
1
(
parentNode
child
)
{
}
function
warnForDeletedHydratableText
1
(
parentNode
child
)
{
}
function
warnForInsertedHydratedElement
1
(
parentNode
tag
props
)
{
}
function
warnForInsertedHydratedText
1
(
parentNode
text
)
{
}
function
restoreControlledState
(
domElement
tag
props
)
{
switch
(
tag
)
{
case
'
input
'
:
restoreControlledState
1
(
domElement
props
)
;
return
;
case
'
textarea
'
:
restoreControlledState
3
(
domElement
props
)
;
return
;
case
'
select
'
:
restoreControlledState
2
(
domElement
props
)
;
return
;
}
}
var
ReactDOMFiberComponent
=
Object
.
freeze
(
{
createElement
:
createElement
1
createTextNode
:
createTextNode
1
setInitialProperties
:
setInitialProperties
1
diffProperties
:
diffProperties
1
updateProperties
:
updateProperties
1
diffHydratedProperties
:
diffHydratedProperties
1
diffHydratedText
:
diffHydratedText
1
warnForUnmatchedText
:
warnForUnmatchedText
1
warnForDeletedHydratableElement
:
warnForDeletedHydratableElement
1
warnForDeletedHydratableText
:
warnForDeletedHydratableText
1
warnForInsertedHydratedElement
:
warnForInsertedHydratedElement
1
warnForInsertedHydratedText
:
warnForInsertedHydratedText
1
restoreControlledState
:
restoreControlledState
}
)
;
var
createElement
=
createElement
1
;
var
createTextNode
=
createTextNode
1
;
var
setInitialProperties
=
setInitialProperties
1
;
var
diffProperties
=
diffProperties
1
;
var
updateProperties
=
updateProperties
1
;
var
diffHydratedProperties
=
diffHydratedProperties
1
;
var
diffHydratedText
=
diffHydratedText
1
;
var
precacheFiberNode
=
precacheFiberNode
1
;
var
updateFiberProps
=
updateFiberProps
1
;
injection
3
.
injectFiberControlledHostComponent
(
ReactDOMFiberComponent
)
;
var
eventsEnabled
=
null
;
var
selectionInformation
=
null
;
function
isValidContainer
(
node
)
{
return
!
!
(
node
&
&
(
node
.
nodeType
=
=
=
ELEMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
|
|
node
.
nodeType
=
=
=
COMMENT_NODE
&
&
node
.
nodeValue
=
=
=
'
react
-
mount
-
point
-
unstable
'
)
)
;
}
function
getReactRootElementInContainer
(
container
)
{
if
(
!
container
)
{
return
null
;
}
if
(
container
.
nodeType
=
=
=
DOCUMENT_NODE
)
{
return
container
.
documentElement
;
}
else
{
return
container
.
firstChild
;
}
}
function
shouldHydrateDueToLegacyHeuristic
(
container
)
{
var
rootElement
=
getReactRootElementInContainer
(
container
)
;
return
!
!
(
rootElement
&
&
rootElement
.
nodeType
=
=
=
ELEMENT_NODE
&
&
rootElement
.
hasAttribute
(
ROOT_ATTRIBUTE_NAME
)
)
;
}
function
shouldAutoFocusHostComponent
(
type
props
)
{
switch
(
type
)
{
case
'
button
'
:
case
'
input
'
:
case
'
select
'
:
case
'
textarea
'
:
return
!
!
props
.
autoFocus
;
}
return
false
;
}
var
DOMRenderer
=
reactReconciler
(
{
getRootHostContext
:
function
(
rootContainerInstance
)
{
var
type
=
void
0
;
var
namespace
=
void
0
;
var
nodeType
=
rootContainerInstance
.
nodeType
;
switch
(
nodeType
)
{
case
DOCUMENT_NODE
:
case
DOCUMENT_FRAGMENT_NODE
:
{
type
=
nodeType
=
=
=
DOCUMENT_NODE
?
'
#
document
'
:
'
#
fragment
'
;
var
root
=
rootContainerInstance
.
documentElement
;
namespace
=
root
?
root
.
namespaceURI
:
getChildNamespace
(
null
'
'
)
;
break
;
}
default
:
{
var
container
=
nodeType
=
=
=
COMMENT_NODE
?
rootContainerInstance
.
parentNode
:
rootContainerInstance
;
var
ownNamespace
=
container
.
namespaceURI
|
|
null
;
type
=
container
.
tagName
;
namespace
=
getChildNamespace
(
ownNamespace
type
)
;
break
;
}
}
return
namespace
;
}
getChildHostContext
:
function
(
parentHostContext
type
)
{
var
parentNamespace
=
parentHostContext
;
return
getChildNamespace
(
parentNamespace
type
)
;
}
getPublicInstance
:
function
(
instance
)
{
return
instance
;
}
prepareForCommit
:
function
(
)
{
eventsEnabled
=
isEnabled
(
)
;
selectionInformation
=
getSelectionInformation
(
)
;
setEnabled
(
false
)
;
}
resetAfterCommit
:
function
(
)
{
restoreSelection
(
selectionInformation
)
;
selectionInformation
=
null
;
setEnabled
(
eventsEnabled
)
;
eventsEnabled
=
null
;
}
createInstance
:
function
(
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
var
parentNamespace
=
void
0
;
{
parentNamespace
=
hostContext
;
}
var
domElement
=
createElement
(
type
props
rootContainerInstance
parentNamespace
)
;
precacheFiberNode
(
internalInstanceHandle
domElement
)
;
updateFiberProps
(
domElement
props
)
;
return
domElement
;
}
appendInitialChild
:
function
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
finalizeInitialChildren
:
function
(
domElement
type
props
rootContainerInstance
)
{
setInitialProperties
(
domElement
type
props
rootContainerInstance
)
;
return
shouldAutoFocusHostComponent
(
type
props
)
;
}
prepareUpdate
:
function
(
domElement
type
oldProps
newProps
rootContainerInstance
hostContext
)
{
return
diffProperties
(
domElement
type
oldProps
newProps
rootContainerInstance
)
;
}
shouldSetTextContent
:
function
(
type
props
)
{
return
type
=
=
=
'
textarea
'
|
|
typeof
props
.
children
=
=
=
'
string
'
|
|
typeof
props
.
children
=
=
=
'
number
'
|
|
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
props
.
dangerouslySetInnerHTML
!
=
=
null
&
&
typeof
props
.
dangerouslySetInnerHTML
.
__html
=
=
=
'
string
'
;
}
shouldDeprioritizeSubtree
:
function
(
type
props
)
{
return
!
!
props
.
hidden
;
}
createTextInstance
:
function
(
text
rootContainerInstance
hostContext
internalInstanceHandle
)
{
var
textNode
=
createTextNode
(
text
rootContainerInstance
)
;
precacheFiberNode
(
internalInstanceHandle
textNode
)
;
return
textNode
;
}
now
:
now
mutation
:
{
commitMount
:
function
(
domElement
type
newProps
internalInstanceHandle
)
{
domElement
.
focus
(
)
;
}
commitUpdate
:
function
(
domElement
updatePayload
type
oldProps
newProps
internalInstanceHandle
)
{
updateFiberProps
(
domElement
newProps
)
;
updateProperties
(
domElement
updatePayload
type
oldProps
newProps
)
;
}
resetTextContent
:
function
(
domElement
)
{
domElement
.
textContent
=
'
'
;
}
commitTextUpdate
:
function
(
textInstance
oldText
newText
)
{
textInstance
.
nodeValue
=
newText
;
}
appendChild
:
function
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
appendChildToContainer
:
function
(
container
child
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
insertBefore
(
child
container
)
;
}
else
{
container
.
appendChild
(
child
)
;
}
}
insertBefore
:
function
(
parentInstance
child
beforeChild
)
{
parentInstance
.
insertBefore
(
child
beforeChild
)
;
}
insertInContainerBefore
:
function
(
container
child
beforeChild
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
insertBefore
(
child
beforeChild
)
;
}
else
{
container
.
insertBefore
(
child
beforeChild
)
;
}
}
removeChild
:
function
(
parentInstance
child
)
{
parentInstance
.
removeChild
(
child
)
;
}
removeChildFromContainer
:
function
(
container
child
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
removeChild
(
child
)
;
}
else
{
container
.
removeChild
(
child
)
;
}
}
}
hydration
:
{
canHydrateInstance
:
function
(
instance
type
props
)
{
if
(
instance
.
nodeType
!
=
=
ELEMENT_NODE
|
|
type
.
toLowerCase
(
)
!
=
=
instance
.
nodeName
.
toLowerCase
(
)
)
{
return
null
;
}
return
instance
;
}
canHydrateTextInstance
:
function
(
instance
text
)
{
if
(
text
=
=
=
'
'
|
|
instance
.
nodeType
!
=
=
TEXT_NODE
)
{
return
null
;
}
return
instance
;
}
getNextHydratableSibling
:
function
(
instance
)
{
var
node
=
instance
.
nextSibling
;
while
(
node
&
&
node
.
nodeType
!
=
=
ELEMENT_NODE
&
&
node
.
nodeType
!
=
=
TEXT_NODE
)
{
node
=
node
.
nextSibling
;
}
return
node
;
}
getFirstHydratableChild
:
function
(
parentInstance
)
{
var
next
=
parentInstance
.
firstChild
;
while
(
next
&
&
next
.
nodeType
!
=
=
ELEMENT_NODE
&
&
next
.
nodeType
!
=
=
TEXT_NODE
)
{
next
=
next
.
nextSibling
;
}
return
next
;
}
hydrateInstance
:
function
(
instance
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
precacheFiberNode
(
internalInstanceHandle
instance
)
;
updateFiberProps
(
instance
props
)
;
var
parentNamespace
=
void
0
;
{
parentNamespace
=
hostContext
;
}
return
diffHydratedProperties
(
instance
type
props
parentNamespace
rootContainerInstance
)
;
}
hydrateTextInstance
:
function
(
textInstance
text
internalInstanceHandle
)
{
precacheFiberNode
(
internalInstanceHandle
textInstance
)
;
return
diffHydratedText
(
textInstance
text
)
;
}
didNotMatchHydratedContainerTextInstance
:
function
(
parentContainer
textInstance
text
)
{
}
didNotMatchHydratedTextInstance
:
function
(
parentType
parentProps
parentInstance
textInstance
text
)
{
}
didNotHydrateContainerInstance
:
function
(
parentContainer
instance
)
{
}
didNotHydrateInstance
:
function
(
parentType
parentProps
parentInstance
instance
)
{
}
didNotFindHydratableContainerInstance
:
function
(
parentContainer
type
props
)
{
}
didNotFindHydratableContainerTextInstance
:
function
(
parentContainer
text
)
{
}
didNotFindHydratableInstance
:
function
(
parentType
parentProps
parentInstance
type
props
)
{
}
didNotFindHydratableTextInstance
:
function
(
parentType
parentProps
parentInstance
text
)
{
}
}
scheduleDeferredCallback
:
rIC
cancelDeferredCallback
:
cIC
useSyncScheduling
:
!
enableAsyncSchedulingByDefaultInReactDOM
}
)
;
injection
4
.
injectFiberBatchedUpdates
(
DOMRenderer
.
batchedUpdates
)
;
function
renderSubtreeIntoContainer
(
parentComponent
children
container
forceHydrate
callback
)
{
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
var
root
=
container
.
_reactRootContainer
;
if
(
!
root
)
{
var
shouldHydrate
=
forceHydrate
|
|
shouldHydrateDueToLegacyHeuristic
(
container
)
;
if
(
!
shouldHydrate
)
{
var
rootSibling
=
void
0
;
while
(
rootSibling
=
container
.
lastChild
)
{
container
.
removeChild
(
rootSibling
)
;
}
}
var
newRoot
=
DOMRenderer
.
createContainer
(
container
shouldHydrate
)
;
root
=
container
.
_reactRootContainer
=
newRoot
;
DOMRenderer
.
unbatchedUpdates
(
function
(
)
{
DOMRenderer
.
updateContainer
(
children
newRoot
parentComponent
callback
)
;
}
)
;
}
else
{
DOMRenderer
.
updateContainer
(
children
root
parentComponent
callback
)
;
}
return
DOMRenderer
.
getPublicRootInstance
(
root
)
;
}
function
createPortal
(
children
container
)
{
var
key
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
null
;
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
return
createPortal
1
(
children
container
null
key
)
;
}
function
ReactRoot
(
container
hydrate
)
{
var
root
=
DOMRenderer
.
createContainer
(
container
hydrate
)
;
this
.
_reactRootContainer
=
root
;
}
ReactRoot
.
prototype
.
render
=
function
(
children
callback
)
{
var
root
=
this
.
_reactRootContainer
;
DOMRenderer
.
updateContainer
(
children
root
null
callback
)
;
}
;
ReactRoot
.
prototype
.
unmount
=
function
(
callback
)
{
var
root
=
this
.
_reactRootContainer
;
DOMRenderer
.
updateContainer
(
null
root
null
callback
)
;
}
;
var
ReactDOM
=
{
createPortal
:
createPortal
findDOMNode
:
function
(
componentOrElement
)
{
if
(
componentOrElement
=
=
null
)
{
return
null
;
}
if
(
componentOrElement
.
nodeType
=
=
=
ELEMENT_NODE
)
{
return
componentOrElement
;
}
var
inst
=
get
(
componentOrElement
)
;
if
(
inst
)
{
return
DOMRenderer
.
findHostInstance
(
inst
)
;
}
if
(
typeof
componentOrElement
.
render
=
=
=
'
function
'
)
{
reactProdInvariant
(
'
188
'
)
;
}
else
{
reactProdInvariant
(
'
213
'
Object
.
keys
(
componentOrElement
)
)
;
}
}
hydrate
:
function
(
element
container
callback
)
{
return
renderSubtreeIntoContainer
(
null
element
container
true
callback
)
;
}
render
:
function
(
element
container
callback
)
{
return
renderSubtreeIntoContainer
(
null
element
container
false
callback
)
;
}
unstable_renderSubtreeIntoContainer
:
function
(
parentComponent
element
containerNode
callback
)
{
!
(
parentComponent
!
=
null
&
&
has
(
parentComponent
)
)
?
reactProdInvariant
(
'
38
'
)
:
void
0
;
return
renderSubtreeIntoContainer
(
parentComponent
element
containerNode
false
callback
)
;
}
unmountComponentAtNode
:
function
(
container
)
{
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
40
'
)
:
void
0
;
if
(
container
.
_reactRootContainer
)
{
DOMRenderer
.
unbatchedUpdates
(
function
(
)
{
renderSubtreeIntoContainer
(
null
null
container
false
function
(
)
{
container
.
_reactRootContainer
=
null
;
}
)
;
}
)
;
return
true
;
}
else
{
return
false
;
}
}
unstable_createPortal
:
createPortal
unstable_batchedUpdates
:
batchedUpdates
unstable_deferredUpdates
:
DOMRenderer
.
deferredUpdates
flushSync
:
DOMRenderer
.
flushSync
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
:
{
EventPluginHub
:
EventPluginHub
EventPluginRegistry
:
EventPluginRegistry
EventPropagators
:
EventPropagators
ReactControlledComponent
:
ReactControlledComponent
ReactDOMComponentTree
:
ReactDOMComponentTree
ReactDOMEventListener
:
ReactDOMEventListener
}
}
;
if
(
enableCreateRoot
)
{
ReactDOM
.
createRoot
=
function
createRoot
(
container
options
)
{
var
hydrate
=
options
!
=
null
&
&
options
.
hydrate
=
=
=
true
;
return
new
ReactRoot
(
container
hydrate
)
;
}
;
}
var
foundDevTools
=
DOMRenderer
.
injectIntoDevTools
(
{
findFiberByHostInstance
:
getClosestInstanceFromNode
bundleType
:
0
version
:
ReactVersion
rendererPackageName
:
'
react
-
dom
'
}
)
;
var
ReactDOM
2
=
Object
.
freeze
(
{
default
:
ReactDOM
}
)
;
var
ReactDOM
3
=
(
ReactDOM
2
&
&
ReactDOM
)
|
|
ReactDOM
2
;
var
reactDom
=
ReactDOM
3
[
'
default
'
]
?
ReactDOM
3
[
'
default
'
]
:
ReactDOM
3
;
return
reactDom
;
}
)
)
)
;
