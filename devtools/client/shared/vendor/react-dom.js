(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
module
.
exports
=
factory
(
require
(
'
devtools
/
client
/
shared
/
vendor
/
react
'
)
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
[
'
devtools
/
client
/
shared
/
vendor
/
react
'
]
factory
)
:
(
global
.
ReactDOM
=
factory
(
global
.
React
)
)
;
}
(
this
(
function
(
React
)
{
'
use
strict
'
;
function
invariant
(
condition
format
a
b
c
d
e
f
)
{
if
(
!
condition
)
{
var
error
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
var
invariant_1
=
invariant
;
function
reactProdInvariant
(
code
)
{
var
argCount
=
arguments
.
length
-
1
;
var
url
=
'
https
:
/
/
reactjs
.
org
/
docs
/
error
-
decoder
.
html
?
invariant
=
'
+
code
;
for
(
var
argIdx
=
0
;
argIdx
<
argCount
;
argIdx
+
+
)
{
url
+
=
'
&
args
[
]
=
'
+
encodeURIComponent
(
arguments
[
argIdx
+
1
]
)
;
}
var
i
=
invariant_1
;
i
(
false
'
Minified
React
error
#
'
+
code
+
'
;
visit
%
s
'
+
'
for
the
full
message
or
use
the
non
-
minified
dev
environment
'
+
'
for
full
errors
and
additional
helpful
warnings
.
'
url
)
;
}
!
React
?
reactProdInvariant
(
'
227
'
)
:
void
0
;
var
invokeGuardedCallback
=
function
(
name
func
context
a
b
c
d
e
f
)
{
this
.
_hasCaughtError
=
false
;
this
.
_caughtError
=
null
;
var
funcArgs
=
Array
.
prototype
.
slice
.
call
(
arguments
3
)
;
try
{
func
.
apply
(
context
funcArgs
)
;
}
catch
(
error
)
{
this
.
_caughtError
=
error
;
this
.
_hasCaughtError
=
true
;
}
}
;
var
ReactErrorUtils
=
{
_caughtError
:
null
_hasCaughtError
:
false
_rethrowError
:
null
_hasRethrowError
:
false
invokeGuardedCallback
:
function
(
name
func
context
a
b
c
d
e
f
)
{
invokeGuardedCallback
.
apply
(
ReactErrorUtils
arguments
)
;
}
invokeGuardedCallbackAndCatchFirstError
:
function
(
name
func
context
a
b
c
d
e
f
)
{
ReactErrorUtils
.
invokeGuardedCallback
.
apply
(
this
arguments
)
;
if
(
ReactErrorUtils
.
hasCaughtError
(
)
)
{
var
error
=
ReactErrorUtils
.
clearCaughtError
(
)
;
if
(
!
ReactErrorUtils
.
_hasRethrowError
)
{
ReactErrorUtils
.
_hasRethrowError
=
true
;
ReactErrorUtils
.
_rethrowError
=
error
;
}
}
}
rethrowCaughtError
:
function
(
)
{
return
rethrowCaughtError
.
apply
(
ReactErrorUtils
arguments
)
;
}
hasCaughtError
:
function
(
)
{
return
ReactErrorUtils
.
_hasCaughtError
;
}
clearCaughtError
:
function
(
)
{
if
(
ReactErrorUtils
.
_hasCaughtError
)
{
var
error
=
ReactErrorUtils
.
_caughtError
;
ReactErrorUtils
.
_caughtError
=
null
;
ReactErrorUtils
.
_hasCaughtError
=
false
;
return
error
;
}
else
{
reactProdInvariant
(
'
198
'
)
;
}
}
}
;
var
rethrowCaughtError
=
function
(
)
{
if
(
ReactErrorUtils
.
_hasRethrowError
)
{
var
error
=
ReactErrorUtils
.
_rethrowError
;
ReactErrorUtils
.
_rethrowError
=
null
;
ReactErrorUtils
.
_hasRethrowError
=
false
;
throw
error
;
}
}
;
var
eventPluginOrder
=
null
;
var
namesToPlugins
=
{
}
;
function
recomputePluginOrdering
(
)
{
if
(
!
eventPluginOrder
)
{
return
;
}
for
(
var
pluginName
in
namesToPlugins
)
{
var
pluginModule
=
namesToPlugins
[
pluginName
]
;
var
pluginIndex
=
eventPluginOrder
.
indexOf
(
pluginName
)
;
!
(
pluginIndex
>
-
1
)
?
reactProdInvariant
(
'
96
'
pluginName
)
:
void
0
;
if
(
plugins
[
pluginIndex
]
)
{
continue
;
}
!
pluginModule
.
extractEvents
?
reactProdInvariant
(
'
97
'
pluginName
)
:
void
0
;
plugins
[
pluginIndex
]
=
pluginModule
;
var
publishedEvents
=
pluginModule
.
eventTypes
;
for
(
var
eventName
in
publishedEvents
)
{
!
publishEventForPlugin
(
publishedEvents
[
eventName
]
pluginModule
eventName
)
?
reactProdInvariant
(
'
98
'
eventName
pluginName
)
:
void
0
;
}
}
}
function
publishEventForPlugin
(
dispatchConfig
pluginModule
eventName
)
{
!
!
eventNameDispatchConfigs
.
hasOwnProperty
(
eventName
)
?
reactProdInvariant
(
'
99
'
eventName
)
:
void
0
;
eventNameDispatchConfigs
[
eventName
]
=
dispatchConfig
;
var
phasedRegistrationNames
=
dispatchConfig
.
phasedRegistrationNames
;
if
(
phasedRegistrationNames
)
{
for
(
var
phaseName
in
phasedRegistrationNames
)
{
if
(
phasedRegistrationNames
.
hasOwnProperty
(
phaseName
)
)
{
var
phasedRegistrationName
=
phasedRegistrationNames
[
phaseName
]
;
publishRegistrationName
(
phasedRegistrationName
pluginModule
eventName
)
;
}
}
return
true
;
}
else
if
(
dispatchConfig
.
registrationName
)
{
publishRegistrationName
(
dispatchConfig
.
registrationName
pluginModule
eventName
)
;
return
true
;
}
return
false
;
}
function
publishRegistrationName
(
registrationName
pluginModule
eventName
)
{
!
!
registrationNameModules
[
registrationName
]
?
reactProdInvariant
(
'
100
'
registrationName
)
:
void
0
;
registrationNameModules
[
registrationName
]
=
pluginModule
;
registrationNameDependencies
[
registrationName
]
=
pluginModule
.
eventTypes
[
eventName
]
.
dependencies
;
}
var
plugins
=
[
]
;
var
eventNameDispatchConfigs
=
{
}
;
var
registrationNameModules
=
{
}
;
var
registrationNameDependencies
=
{
}
;
var
possibleRegistrationNames
=
null
;
function
injectEventPluginOrder
(
injectedEventPluginOrder
)
{
!
!
eventPluginOrder
?
reactProdInvariant
(
'
101
'
)
:
void
0
;
eventPluginOrder
=
Array
.
prototype
.
slice
.
call
(
injectedEventPluginOrder
)
;
recomputePluginOrdering
(
)
;
}
function
injectEventPluginsByName
(
injectedNamesToPlugins
)
{
var
isOrderingDirty
=
false
;
for
(
var
pluginName
in
injectedNamesToPlugins
)
{
if
(
!
injectedNamesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
continue
;
}
var
pluginModule
=
injectedNamesToPlugins
[
pluginName
]
;
if
(
!
namesToPlugins
.
hasOwnProperty
(
pluginName
)
|
|
namesToPlugins
[
pluginName
]
!
=
=
pluginModule
)
{
!
!
namesToPlugins
[
pluginName
]
?
reactProdInvariant
(
'
102
'
pluginName
)
:
void
0
;
namesToPlugins
[
pluginName
]
=
pluginModule
;
isOrderingDirty
=
true
;
}
}
if
(
isOrderingDirty
)
{
recomputePluginOrdering
(
)
;
}
}
var
EventPluginRegistry
=
(
{
plugins
:
plugins
eventNameDispatchConfigs
:
eventNameDispatchConfigs
registrationNameModules
:
registrationNameModules
registrationNameDependencies
:
registrationNameDependencies
possibleRegistrationNames
:
possibleRegistrationNames
injectEventPluginOrder
:
injectEventPluginOrder
injectEventPluginsByName
:
injectEventPluginsByName
}
)
;
function
makeEmptyFunction
(
arg
)
{
return
function
(
)
{
return
arg
;
}
;
}
var
emptyFunction
=
function
emptyFunction
(
)
{
}
;
emptyFunction
.
thatReturns
=
makeEmptyFunction
;
emptyFunction
.
thatReturnsFalse
=
makeEmptyFunction
(
false
)
;
emptyFunction
.
thatReturnsTrue
=
makeEmptyFunction
(
true
)
;
emptyFunction
.
thatReturnsNull
=
makeEmptyFunction
(
null
)
;
emptyFunction
.
thatReturnsThis
=
function
(
)
{
return
this
;
}
;
emptyFunction
.
thatReturnsArgument
=
function
(
arg
)
{
return
arg
;
}
;
var
emptyFunction_1
=
emptyFunction
;
var
getFiberCurrentPropsFromNode
=
null
;
var
getInstanceFromNode
=
null
;
var
getNodeFromInstance
=
null
;
var
injection
1
=
{
injectComponentTree
:
function
(
Injected
)
{
getFiberCurrentPropsFromNode
=
Injected
.
getFiberCurrentPropsFromNode
;
getInstanceFromNode
=
Injected
.
getInstanceFromNode
;
getNodeFromInstance
=
Injected
.
getNodeFromInstance
;
}
}
;
function
executeDispatch
(
event
simulated
listener
inst
)
{
var
type
=
event
.
type
|
|
'
unknown
-
event
'
;
event
.
currentTarget
=
getNodeFromInstance
(
inst
)
;
ReactErrorUtils
.
invokeGuardedCallbackAndCatchFirstError
(
type
listener
undefined
event
)
;
event
.
currentTarget
=
null
;
}
function
executeDispatchesInOrder
(
event
simulated
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchInstances
=
event
.
_dispatchInstances
;
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
executeDispatch
(
event
simulated
dispatchListeners
[
i
]
dispatchInstances
[
i
]
)
;
}
}
else
if
(
dispatchListeners
)
{
executeDispatch
(
event
simulated
dispatchListeners
dispatchInstances
)
;
}
event
.
_dispatchListeners
=
null
;
event
.
_dispatchInstances
=
null
;
}
function
accumulateInto
(
current
next
)
{
!
(
next
!
=
null
)
?
reactProdInvariant
(
'
30
'
)
:
void
0
;
if
(
current
=
=
null
)
{
return
next
;
}
if
(
Array
.
isArray
(
current
)
)
{
if
(
Array
.
isArray
(
next
)
)
{
current
.
push
.
apply
(
current
next
)
;
return
current
;
}
current
.
push
(
next
)
;
return
current
;
}
if
(
Array
.
isArray
(
next
)
)
{
return
[
current
]
.
concat
(
next
)
;
}
return
[
current
next
]
;
}
function
forEachAccumulated
(
arr
cb
scope
)
{
if
(
Array
.
isArray
(
arr
)
)
{
arr
.
forEach
(
cb
scope
)
;
}
else
if
(
arr
)
{
cb
.
call
(
scope
arr
)
;
}
}
var
eventQueue
=
null
;
var
executeDispatchesAndRelease
=
function
(
event
simulated
)
{
if
(
event
)
{
executeDispatchesInOrder
(
event
simulated
)
;
if
(
!
event
.
isPersistent
(
)
)
{
event
.
constructor
.
release
(
event
)
;
}
}
}
;
var
executeDispatchesAndReleaseSimulated
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
true
)
;
}
;
var
executeDispatchesAndReleaseTopLevel
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
false
)
;
}
;
function
isInteractive
(
tag
)
{
return
tag
=
=
=
'
button
'
|
|
tag
=
=
=
'
input
'
|
|
tag
=
=
=
'
select
'
|
|
tag
=
=
=
'
textarea
'
;
}
function
shouldPreventMouseEvent
(
name
type
props
)
{
switch
(
name
)
{
case
'
onClick
'
:
case
'
onClickCapture
'
:
case
'
onDoubleClick
'
:
case
'
onDoubleClickCapture
'
:
case
'
onMouseDown
'
:
case
'
onMouseDownCapture
'
:
case
'
onMouseMove
'
:
case
'
onMouseMoveCapture
'
:
case
'
onMouseUp
'
:
case
'
onMouseUpCapture
'
:
return
!
!
(
props
.
disabled
&
&
isInteractive
(
type
)
)
;
default
:
return
false
;
}
}
var
injection
=
{
injectEventPluginOrder
:
injectEventPluginOrder
injectEventPluginsByName
:
injectEventPluginsByName
}
;
function
getListener
(
inst
registrationName
)
{
var
listener
=
void
0
;
var
stateNode
=
inst
.
stateNode
;
if
(
!
stateNode
)
{
return
null
;
}
var
props
=
getFiberCurrentPropsFromNode
(
stateNode
)
;
if
(
!
props
)
{
return
null
;
}
listener
=
props
[
registrationName
]
;
if
(
shouldPreventMouseEvent
(
registrationName
inst
.
type
props
)
)
{
return
null
;
}
!
(
!
listener
|
|
typeof
listener
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
231
'
registrationName
typeof
listener
)
:
void
0
;
return
listener
;
}
function
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
events
=
null
;
for
(
var
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
var
possiblePlugin
=
plugins
[
i
]
;
if
(
possiblePlugin
)
{
var
extractedEvents
=
possiblePlugin
.
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
extractedEvents
)
{
events
=
accumulateInto
(
events
extractedEvents
)
;
}
}
}
return
events
;
}
function
runEventsInBatch
(
events
simulated
)
{
if
(
events
!
=
=
null
)
{
eventQueue
=
accumulateInto
(
eventQueue
events
)
;
}
var
processingEventQueue
=
eventQueue
;
eventQueue
=
null
;
if
(
!
processingEventQueue
)
{
return
;
}
if
(
simulated
)
{
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseSimulated
)
;
}
else
{
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseTopLevel
)
;
}
!
!
eventQueue
?
reactProdInvariant
(
'
95
'
)
:
void
0
;
ReactErrorUtils
.
rethrowCaughtError
(
)
;
}
function
runExtractedEventsInBatch
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
events
=
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
runEventsInBatch
(
events
false
)
;
}
var
EventPluginHub
=
(
{
injection
:
injection
getListener
:
getListener
runEventsInBatch
:
runEventsInBatch
runExtractedEventsInBatch
:
runExtractedEventsInBatch
}
)
;
var
IndeterminateComponent
=
0
;
var
FunctionalComponent
=
1
;
var
ClassComponent
=
2
;
var
HostRoot
=
3
;
var
HostPortal
=
4
;
var
HostComponent
=
5
;
var
HostText
=
6
;
var
Fragment
=
10
;
var
Mode
=
11
;
var
ContextConsumer
=
12
;
var
ContextProvider
=
13
;
var
ForwardRef
=
14
;
var
Profiler
=
15
;
var
TimeoutComponent
=
16
;
var
randomKey
=
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
var
internalInstanceKey
=
'
__reactInternalInstance
'
+
randomKey
;
var
internalEventHandlersKey
=
'
__reactEventHandlers
'
+
randomKey
;
function
precacheFiberNode
(
hostInst
node
)
{
node
[
internalInstanceKey
]
=
hostInst
;
}
function
getClosestInstanceFromNode
(
node
)
{
if
(
node
[
internalInstanceKey
]
)
{
return
node
[
internalInstanceKey
]
;
}
while
(
!
node
[
internalInstanceKey
]
)
{
if
(
node
.
parentNode
)
{
node
=
node
.
parentNode
;
}
else
{
return
null
;
}
}
var
inst
=
node
[
internalInstanceKey
]
;
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
;
}
return
null
;
}
function
getInstanceFromNode
1
(
node
)
{
var
inst
=
node
[
internalInstanceKey
]
;
if
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
;
}
else
{
return
null
;
}
}
return
null
;
}
function
getNodeFromInstance
1
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
.
stateNode
;
}
reactProdInvariant
(
'
33
'
)
;
}
function
getFiberCurrentPropsFromNode
1
(
node
)
{
return
node
[
internalEventHandlersKey
]
|
|
null
;
}
function
updateFiberProps
(
node
props
)
{
node
[
internalEventHandlersKey
]
=
props
;
}
var
ReactDOMComponentTree
=
(
{
precacheFiberNode
:
precacheFiberNode
getClosestInstanceFromNode
:
getClosestInstanceFromNode
getInstanceFromNode
:
getInstanceFromNode
1
getNodeFromInstance
:
getNodeFromInstance
1
getFiberCurrentPropsFromNode
:
getFiberCurrentPropsFromNode
1
updateFiberProps
:
updateFiberProps
}
)
;
function
getParent
(
inst
)
{
do
{
inst
=
inst
.
return
;
}
while
(
inst
&
&
inst
.
tag
!
=
=
HostComponent
)
;
if
(
inst
)
{
return
inst
;
}
return
null
;
}
function
getLowestCommonAncestor
(
instA
instB
)
{
var
depthA
=
0
;
for
(
var
tempA
=
instA
;
tempA
;
tempA
=
getParent
(
tempA
)
)
{
depthA
+
+
;
}
var
depthB
=
0
;
for
(
var
tempB
=
instB
;
tempB
;
tempB
=
getParent
(
tempB
)
)
{
depthB
+
+
;
}
while
(
depthA
-
depthB
>
0
)
{
instA
=
getParent
(
instA
)
;
depthA
-
-
;
}
while
(
depthB
-
depthA
>
0
)
{
instB
=
getParent
(
instB
)
;
depthB
-
-
;
}
var
depth
=
depthA
;
while
(
depth
-
-
)
{
if
(
instA
=
=
=
instB
|
|
instA
=
=
=
instB
.
alternate
)
{
return
instA
;
}
instA
=
getParent
(
instA
)
;
instB
=
getParent
(
instB
)
;
}
return
null
;
}
function
getParentInstance
(
inst
)
{
return
getParent
(
inst
)
;
}
function
traverseTwoPhase
(
inst
fn
arg
)
{
var
path
=
[
]
;
while
(
inst
)
{
path
.
push
(
inst
)
;
inst
=
getParent
(
inst
)
;
}
var
i
=
void
0
;
for
(
i
=
path
.
length
;
i
-
-
>
0
;
)
{
fn
(
path
[
i
]
'
captured
'
arg
)
;
}
for
(
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
fn
(
path
[
i
]
'
bubbled
'
arg
)
;
}
}
function
traverseEnterLeave
(
from
to
fn
argFrom
argTo
)
{
var
common
=
from
&
&
to
?
getLowestCommonAncestor
(
from
to
)
:
null
;
var
pathFrom
=
[
]
;
while
(
true
)
{
if
(
!
from
)
{
break
;
}
if
(
from
=
=
=
common
)
{
break
;
}
var
alternate
=
from
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
=
=
=
common
)
{
break
;
}
pathFrom
.
push
(
from
)
;
from
=
getParent
(
from
)
;
}
var
pathTo
=
[
]
;
while
(
true
)
{
if
(
!
to
)
{
break
;
}
if
(
to
=
=
=
common
)
{
break
;
}
var
_alternate
=
to
.
alternate
;
if
(
_alternate
!
=
=
null
&
&
_alternate
=
=
=
common
)
{
break
;
}
pathTo
.
push
(
to
)
;
to
=
getParent
(
to
)
;
}
for
(
var
i
=
0
;
i
<
pathFrom
.
length
;
i
+
+
)
{
fn
(
pathFrom
[
i
]
'
bubbled
'
argFrom
)
;
}
for
(
var
_i
=
pathTo
.
length
;
_i
-
-
>
0
;
)
{
fn
(
pathTo
[
_i
]
'
captured
'
argTo
)
;
}
}
function
listenerAtPhase
(
inst
event
propagationPhase
)
{
var
registrationName
=
event
.
dispatchConfig
.
phasedRegistrationNames
[
propagationPhase
]
;
return
getListener
(
inst
registrationName
)
;
}
function
accumulateDirectionalDispatches
(
inst
phase
event
)
{
var
listener
=
listenerAtPhase
(
inst
event
phase
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
function
accumulateTwoPhaseDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
traverseTwoPhase
(
event
.
_targetInst
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateTwoPhaseDispatchesSingleSkipTarget
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
var
targetInst
=
event
.
_targetInst
;
var
parentInst
=
targetInst
?
getParentInstance
(
targetInst
)
:
null
;
traverseTwoPhase
(
parentInst
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateDispatches
(
inst
ignoredDirection
event
)
{
if
(
inst
&
&
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
var
registrationName
=
event
.
dispatchConfig
.
registrationName
;
var
listener
=
getListener
(
inst
registrationName
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
}
function
accumulateDirectDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
accumulateDispatches
(
event
.
_targetInst
null
event
)
;
}
}
function
accumulateTwoPhaseDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingle
)
;
}
function
accumulateTwoPhaseDispatchesSkipTarget
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingleSkipTarget
)
;
}
function
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
{
traverseEnterLeave
(
from
to
accumulateDispatches
leave
enter
)
;
}
function
accumulateDirectDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateDirectDispatchesSingle
)
;
}
var
EventPropagators
=
(
{
accumulateTwoPhaseDispatches
:
accumulateTwoPhaseDispatches
accumulateTwoPhaseDispatchesSkipTarget
:
accumulateTwoPhaseDispatchesSkipTarget
accumulateEnterLeaveDispatches
:
accumulateEnterLeaveDispatches
accumulateDirectDispatches
:
accumulateDirectDispatches
}
)
;
var
canUseDOM
=
!
!
(
typeof
window
!
=
=
'
undefined
'
&
&
window
.
document
&
&
window
.
document
.
createElement
)
;
var
ExecutionEnvironment
=
{
canUseDOM
:
canUseDOM
canUseWorkers
:
typeof
Worker
!
=
=
'
undefined
'
canUseEventListeners
:
canUseDOM
&
&
!
!
(
window
.
addEventListener
|
|
window
.
attachEvent
)
canUseViewport
:
canUseDOM
&
&
!
!
window
.
screen
isInWorker
:
!
canUseDOM
}
;
var
ExecutionEnvironment_1
=
ExecutionEnvironment
;
function
unsafeCastStringToDOMTopLevelType
(
topLevelType
)
{
return
topLevelType
;
}
function
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
{
return
topLevelType
;
}
function
makePrefixMap
(
styleProp
eventName
)
{
var
prefixes
=
{
}
;
prefixes
[
styleProp
.
toLowerCase
(
)
]
=
eventName
.
toLowerCase
(
)
;
prefixes
[
'
Webkit
'
+
styleProp
]
=
'
webkit
'
+
eventName
;
prefixes
[
'
Moz
'
+
styleProp
]
=
'
moz
'
+
eventName
;
prefixes
[
'
ms
'
+
styleProp
]
=
'
MS
'
+
eventName
;
prefixes
[
'
O
'
+
styleProp
]
=
'
o
'
+
eventName
.
toLowerCase
(
)
;
return
prefixes
;
}
var
vendorPrefixes
=
{
animationend
:
makePrefixMap
(
'
Animation
'
'
AnimationEnd
'
)
animationiteration
:
makePrefixMap
(
'
Animation
'
'
AnimationIteration
'
)
animationstart
:
makePrefixMap
(
'
Animation
'
'
AnimationStart
'
)
transitionend
:
makePrefixMap
(
'
Transition
'
'
TransitionEnd
'
)
}
;
var
prefixedEventNames
=
{
}
;
var
style
=
{
}
;
if
(
ExecutionEnvironment_1
.
canUseDOM
)
{
style
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
.
style
;
if
(
!
(
'
AnimationEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
animationend
.
animation
;
delete
vendorPrefixes
.
animationiteration
.
animation
;
delete
vendorPrefixes
.
animationstart
.
animation
;
}
if
(
!
(
'
TransitionEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
transitionend
.
transition
;
}
}
function
getVendorPrefixedEventName
(
eventName
)
{
if
(
prefixedEventNames
[
eventName
]
)
{
return
prefixedEventNames
[
eventName
]
;
}
else
if
(
!
vendorPrefixes
[
eventName
]
)
{
return
eventName
;
}
var
prefixMap
=
vendorPrefixes
[
eventName
]
;
for
(
var
styleProp
in
prefixMap
)
{
if
(
prefixMap
.
hasOwnProperty
(
styleProp
)
&
&
styleProp
in
style
)
{
return
prefixedEventNames
[
eventName
]
=
prefixMap
[
styleProp
]
;
}
}
return
eventName
;
}
var
TOP_ABORT
=
unsafeCastStringToDOMTopLevelType
(
'
abort
'
)
;
var
TOP_ANIMATION_END
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationend
'
)
)
;
var
TOP_ANIMATION_ITERATION
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationiteration
'
)
)
;
var
TOP_ANIMATION_START
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationstart
'
)
)
;
var
TOP_BLUR
=
unsafeCastStringToDOMTopLevelType
(
'
blur
'
)
;
var
TOP_CAN_PLAY
=
unsafeCastStringToDOMTopLevelType
(
'
canplay
'
)
;
var
TOP_CAN_PLAY_THROUGH
=
unsafeCastStringToDOMTopLevelType
(
'
canplaythrough
'
)
;
var
TOP_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
cancel
'
)
;
var
TOP_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
change
'
)
;
var
TOP_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
click
'
)
;
var
TOP_CLOSE
=
unsafeCastStringToDOMTopLevelType
(
'
close
'
)
;
var
TOP_COMPOSITION_END
=
unsafeCastStringToDOMTopLevelType
(
'
compositionend
'
)
;
var
TOP_COMPOSITION_START
=
unsafeCastStringToDOMTopLevelType
(
'
compositionstart
'
)
;
var
TOP_COMPOSITION_UPDATE
=
unsafeCastStringToDOMTopLevelType
(
'
compositionupdate
'
)
;
var
TOP_CONTEXT_MENU
=
unsafeCastStringToDOMTopLevelType
(
'
contextmenu
'
)
;
var
TOP_COPY
=
unsafeCastStringToDOMTopLevelType
(
'
copy
'
)
;
var
TOP_CUT
=
unsafeCastStringToDOMTopLevelType
(
'
cut
'
)
;
var
TOP_DOUBLE_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
dblclick
'
)
;
var
TOP_DRAG
=
unsafeCastStringToDOMTopLevelType
(
'
drag
'
)
;
var
TOP_DRAG_END
=
unsafeCastStringToDOMTopLevelType
(
'
dragend
'
)
;
var
TOP_DRAG_ENTER
=
unsafeCastStringToDOMTopLevelType
(
'
dragenter
'
)
;
var
TOP_DRAG_EXIT
=
unsafeCastStringToDOMTopLevelType
(
'
dragexit
'
)
;
var
TOP_DRAG_LEAVE
=
unsafeCastStringToDOMTopLevelType
(
'
dragleave
'
)
;
var
TOP_DRAG_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
dragover
'
)
;
var
TOP_DRAG_START
=
unsafeCastStringToDOMTopLevelType
(
'
dragstart
'
)
;
var
TOP_DROP
=
unsafeCastStringToDOMTopLevelType
(
'
drop
'
)
;
var
TOP_DURATION_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
durationchange
'
)
;
var
TOP_EMPTIED
=
unsafeCastStringToDOMTopLevelType
(
'
emptied
'
)
;
var
TOP_ENCRYPTED
=
unsafeCastStringToDOMTopLevelType
(
'
encrypted
'
)
;
var
TOP_ENDED
=
unsafeCastStringToDOMTopLevelType
(
'
ended
'
)
;
var
TOP_ERROR
=
unsafeCastStringToDOMTopLevelType
(
'
error
'
)
;
var
TOP_FOCUS
=
unsafeCastStringToDOMTopLevelType
(
'
focus
'
)
;
var
TOP_GOT_POINTER_CAPTURE
=
unsafeCastStringToDOMTopLevelType
(
'
gotpointercapture
'
)
;
var
TOP_INPUT
=
unsafeCastStringToDOMTopLevelType
(
'
input
'
)
;
var
TOP_INVALID
=
unsafeCastStringToDOMTopLevelType
(
'
invalid
'
)
;
var
TOP_KEY_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
keydown
'
)
;
var
TOP_KEY_PRESS
=
unsafeCastStringToDOMTopLevelType
(
'
keypress
'
)
;
var
TOP_KEY_UP
=
unsafeCastStringToDOMTopLevelType
(
'
keyup
'
)
;
var
TOP_LOAD
=
unsafeCastStringToDOMTopLevelType
(
'
load
'
)
;
var
TOP_LOAD_START
=
unsafeCastStringToDOMTopLevelType
(
'
loadstart
'
)
;
var
TOP_LOADED_DATA
=
unsafeCastStringToDOMTopLevelType
(
'
loadeddata
'
)
;
var
TOP_LOADED_METADATA
=
unsafeCastStringToDOMTopLevelType
(
'
loadedmetadata
'
)
;
var
TOP_LOST_POINTER_CAPTURE
=
unsafeCastStringToDOMTopLevelType
(
'
lostpointercapture
'
)
;
var
TOP_MOUSE_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
mousedown
'
)
;
var
TOP_MOUSE_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
mousemove
'
)
;
var
TOP_MOUSE_OUT
=
unsafeCastStringToDOMTopLevelType
(
'
mouseout
'
)
;
var
TOP_MOUSE_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
mouseover
'
)
;
var
TOP_MOUSE_UP
=
unsafeCastStringToDOMTopLevelType
(
'
mouseup
'
)
;
var
TOP_PASTE
=
unsafeCastStringToDOMTopLevelType
(
'
paste
'
)
;
var
TOP_PAUSE
=
unsafeCastStringToDOMTopLevelType
(
'
pause
'
)
;
var
TOP_PLAY
=
unsafeCastStringToDOMTopLevelType
(
'
play
'
)
;
var
TOP_PLAYING
=
unsafeCastStringToDOMTopLevelType
(
'
playing
'
)
;
var
TOP_POINTER_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
pointercancel
'
)
;
var
TOP_POINTER_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
pointerdown
'
)
;
var
TOP_POINTER_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
pointermove
'
)
;
var
TOP_POINTER_OUT
=
unsafeCastStringToDOMTopLevelType
(
'
pointerout
'
)
;
var
TOP_POINTER_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
pointerover
'
)
;
var
TOP_POINTER_UP
=
unsafeCastStringToDOMTopLevelType
(
'
pointerup
'
)
;
var
TOP_PROGRESS
=
unsafeCastStringToDOMTopLevelType
(
'
progress
'
)
;
var
TOP_RATE_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
ratechange
'
)
;
var
TOP_RESET
=
unsafeCastStringToDOMTopLevelType
(
'
reset
'
)
;
var
TOP_SCROLL
=
unsafeCastStringToDOMTopLevelType
(
'
scroll
'
)
;
var
TOP_SEEKED
=
unsafeCastStringToDOMTopLevelType
(
'
seeked
'
)
;
var
TOP_SEEKING
=
unsafeCastStringToDOMTopLevelType
(
'
seeking
'
)
;
var
TOP_SELECTION_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
selectionchange
'
)
;
var
TOP_STALLED
=
unsafeCastStringToDOMTopLevelType
(
'
stalled
'
)
;
var
TOP_SUBMIT
=
unsafeCastStringToDOMTopLevelType
(
'
submit
'
)
;
var
TOP_SUSPEND
=
unsafeCastStringToDOMTopLevelType
(
'
suspend
'
)
;
var
TOP_TEXT_INPUT
=
unsafeCastStringToDOMTopLevelType
(
'
textInput
'
)
;
var
TOP_TIME_UPDATE
=
unsafeCastStringToDOMTopLevelType
(
'
timeupdate
'
)
;
var
TOP_TOGGLE
=
unsafeCastStringToDOMTopLevelType
(
'
toggle
'
)
;
var
TOP_TOUCH_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
touchcancel
'
)
;
var
TOP_TOUCH_END
=
unsafeCastStringToDOMTopLevelType
(
'
touchend
'
)
;
var
TOP_TOUCH_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
touchmove
'
)
;
var
TOP_TOUCH_START
=
unsafeCastStringToDOMTopLevelType
(
'
touchstart
'
)
;
var
TOP_TRANSITION_END
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
transitionend
'
)
)
;
var
TOP_VOLUME_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
volumechange
'
)
;
var
TOP_WAITING
=
unsafeCastStringToDOMTopLevelType
(
'
waiting
'
)
;
var
TOP_WHEEL
=
unsafeCastStringToDOMTopLevelType
(
'
wheel
'
)
;
var
mediaEventTypes
=
[
TOP_ABORT
TOP_CAN_PLAY
TOP_CAN_PLAY_THROUGH
TOP_DURATION_CHANGE
TOP_EMPTIED
TOP_ENCRYPTED
TOP_ENDED
TOP_ERROR
TOP_LOADED_DATA
TOP_LOADED_METADATA
TOP_LOAD_START
TOP_PAUSE
TOP_PLAY
TOP_PLAYING
TOP_PROGRESS
TOP_RATE_CHANGE
TOP_SEEKED
TOP_SEEKING
TOP_STALLED
TOP_SUSPEND
TOP_TIME_UPDATE
TOP_VOLUME_CHANGE
TOP_WAITING
]
;
function
getRawEventName
(
topLevelType
)
{
return
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
;
}
var
contentKey
=
null
;
function
getTextContentAccessor
(
)
{
if
(
!
contentKey
&
&
ExecutionEnvironment_1
.
canUseDOM
)
{
contentKey
=
'
textContent
'
in
document
.
documentElement
?
'
textContent
'
:
'
innerText
'
;
}
return
contentKey
;
}
var
compositionState
=
{
_root
:
null
_startText
:
null
_fallbackText
:
null
}
;
function
initialize
(
nativeEventTarget
)
{
compositionState
.
_root
=
nativeEventTarget
;
compositionState
.
_startText
=
getText
(
)
;
return
true
;
}
function
reset
(
)
{
compositionState
.
_root
=
null
;
compositionState
.
_startText
=
null
;
compositionState
.
_fallbackText
=
null
;
}
function
getData
(
)
{
if
(
compositionState
.
_fallbackText
)
{
return
compositionState
.
_fallbackText
;
}
var
start
=
void
0
;
var
startValue
=
compositionState
.
_startText
;
var
startLength
=
startValue
.
length
;
var
end
=
void
0
;
var
endValue
=
getText
(
)
;
var
endLength
=
endValue
.
length
;
for
(
start
=
0
;
start
<
startLength
;
start
+
+
)
{
if
(
startValue
[
start
]
!
=
=
endValue
[
start
]
)
{
break
;
}
}
var
minEnd
=
startLength
-
start
;
for
(
end
=
1
;
end
<
=
minEnd
;
end
+
+
)
{
if
(
startValue
[
startLength
-
end
]
!
=
=
endValue
[
endLength
-
end
]
)
{
break
;
}
}
var
sliceTail
=
end
>
1
?
1
-
end
:
undefined
;
compositionState
.
_fallbackText
=
endValue
.
slice
(
start
sliceTail
)
;
return
compositionState
.
_fallbackText
;
}
function
getText
(
)
{
if
(
'
value
'
in
compositionState
.
_root
)
{
return
compositionState
.
_root
.
value
;
}
return
compositionState
.
_root
[
getTextContentAccessor
(
)
]
;
}
var
ReactInternals
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_assign
=
ReactInternals
.
assign
;
var
EVENT_POOL_SIZE
=
10
;
var
shouldBeReleasedProperties
=
[
'
dispatchConfig
'
'
_targetInst
'
'
nativeEvent
'
'
isDefaultPrevented
'
'
isPropagationStopped
'
'
_dispatchListeners
'
'
_dispatchInstances
'
]
;
var
EventInterface
=
{
type
:
null
target
:
null
currentTarget
:
emptyFunction_1
.
thatReturnsNull
eventPhase
:
null
bubbles
:
null
cancelable
:
null
timeStamp
:
function
(
event
)
{
return
event
.
timeStamp
|
|
Date
.
now
(
)
;
}
defaultPrevented
:
null
isTrusted
:
null
}
;
function
SyntheticEvent
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
{
this
.
dispatchConfig
=
dispatchConfig
;
this
.
_targetInst
=
targetInst
;
this
.
nativeEvent
=
nativeEvent
;
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
if
(
!
Interface
.
hasOwnProperty
(
propName
)
)
{
continue
;
}
var
normalize
=
Interface
[
propName
]
;
if
(
normalize
)
{
this
[
propName
]
=
normalize
(
nativeEvent
)
;
}
else
{
if
(
propName
=
=
=
'
target
'
)
{
this
.
target
=
nativeEventTarget
;
}
else
{
this
[
propName
]
=
nativeEvent
[
propName
]
;
}
}
}
var
defaultPrevented
=
nativeEvent
.
defaultPrevented
!
=
null
?
nativeEvent
.
defaultPrevented
:
nativeEvent
.
returnValue
=
=
=
false
;
if
(
defaultPrevented
)
{
this
.
isDefaultPrevented
=
emptyFunction_1
.
thatReturnsTrue
;
}
else
{
this
.
isDefaultPrevented
=
emptyFunction_1
.
thatReturnsFalse
;
}
this
.
isPropagationStopped
=
emptyFunction_1
.
thatReturnsFalse
;
return
this
;
}
_assign
(
SyntheticEvent
.
prototype
{
preventDefault
:
function
(
)
{
this
.
defaultPrevented
=
true
;
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
preventDefault
)
{
event
.
preventDefault
(
)
;
}
else
if
(
typeof
event
.
returnValue
!
=
=
'
unknown
'
)
{
event
.
returnValue
=
false
;
}
this
.
isDefaultPrevented
=
emptyFunction_1
.
thatReturnsTrue
;
}
stopPropagation
:
function
(
)
{
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
stopPropagation
)
{
event
.
stopPropagation
(
)
;
}
else
if
(
typeof
event
.
cancelBubble
!
=
=
'
unknown
'
)
{
event
.
cancelBubble
=
true
;
}
this
.
isPropagationStopped
=
emptyFunction_1
.
thatReturnsTrue
;
}
persist
:
function
(
)
{
this
.
isPersistent
=
emptyFunction_1
.
thatReturnsTrue
;
}
isPersistent
:
emptyFunction_1
.
thatReturnsFalse
destructor
:
function
(
)
{
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
{
this
[
propName
]
=
null
;
}
}
for
(
var
i
=
0
;
i
<
shouldBeReleasedProperties
.
length
;
i
+
+
)
{
this
[
shouldBeReleasedProperties
[
i
]
]
=
null
;
}
}
}
)
;
SyntheticEvent
.
Interface
=
EventInterface
;
SyntheticEvent
.
extend
=
function
(
Interface
)
{
var
Super
=
this
;
var
E
=
function
(
)
{
}
;
E
.
prototype
=
Super
.
prototype
;
var
prototype
=
new
E
(
)
;
function
Class
(
)
{
return
Super
.
apply
(
this
arguments
)
;
}
_assign
(
prototype
Class
.
prototype
)
;
Class
.
prototype
=
prototype
;
Class
.
prototype
.
constructor
=
Class
;
Class
.
Interface
=
_assign
(
{
}
Super
.
Interface
Interface
)
;
Class
.
extend
=
Super
.
extend
;
addEventPoolingTo
(
Class
)
;
return
Class
;
}
;
addEventPoolingTo
(
SyntheticEvent
)
;
function
getPooledEvent
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
{
var
EventConstructor
=
this
;
if
(
EventConstructor
.
eventPool
.
length
)
{
var
instance
=
EventConstructor
.
eventPool
.
pop
(
)
;
EventConstructor
.
call
(
instance
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
return
instance
;
}
return
new
EventConstructor
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
}
function
releasePooledEvent
(
event
)
{
var
EventConstructor
=
this
;
!
(
event
instanceof
EventConstructor
)
?
reactProdInvariant
(
'
223
'
)
:
void
0
;
event
.
destructor
(
)
;
if
(
EventConstructor
.
eventPool
.
length
<
EVENT_POOL_SIZE
)
{
EventConstructor
.
eventPool
.
push
(
event
)
;
}
}
function
addEventPoolingTo
(
EventConstructor
)
{
EventConstructor
.
eventPool
=
[
]
;
EventConstructor
.
getPooled
=
getPooledEvent
;
EventConstructor
.
release
=
releasePooledEvent
;
}
var
SyntheticCompositionEvent
=
SyntheticEvent
.
extend
(
{
data
:
null
}
)
;
var
SyntheticInputEvent
=
SyntheticEvent
.
extend
(
{
data
:
null
}
)
;
var
END_KEYCODES
=
[
9
13
27
32
]
;
var
START_KEYCODE
=
229
;
var
canUseCompositionEvent
=
ExecutionEnvironment_1
.
canUseDOM
&
&
'
CompositionEvent
'
in
window
;
var
documentMode
=
null
;
if
(
ExecutionEnvironment_1
.
canUseDOM
&
&
'
documentMode
'
in
document
)
{
documentMode
=
document
.
documentMode
;
}
var
canUseTextInputEvent
=
ExecutionEnvironment_1
.
canUseDOM
&
&
'
TextEvent
'
in
window
&
&
!
documentMode
;
var
useFallbackCompositionData
=
ExecutionEnvironment_1
.
canUseDOM
&
&
(
!
canUseCompositionEvent
|
|
documentMode
&
&
documentMode
>
8
&
&
documentMode
<
=
11
)
;
var
SPACEBAR_CODE
=
32
;
var
SPACEBAR_CHAR
=
String
.
fromCharCode
(
SPACEBAR_CODE
)
;
var
eventTypes
=
{
beforeInput
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onBeforeInput
'
captured
:
'
onBeforeInputCapture
'
}
dependencies
:
[
TOP_COMPOSITION_END
TOP_KEY_PRESS
TOP_TEXT_INPUT
TOP_PASTE
]
}
compositionEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionEnd
'
captured
:
'
onCompositionEndCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_END
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
compositionStart
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionStart
'
captured
:
'
onCompositionStartCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_START
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
compositionUpdate
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionUpdate
'
captured
:
'
onCompositionUpdateCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_UPDATE
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
}
;
var
hasSpaceKeypress
=
false
;
function
isKeypressCommand
(
nativeEvent
)
{
return
(
nativeEvent
.
ctrlKey
|
|
nativeEvent
.
altKey
|
|
nativeEvent
.
metaKey
)
&
&
!
(
nativeEvent
.
ctrlKey
&
&
nativeEvent
.
altKey
)
;
}
function
getCompositionEventType
(
topLevelType
)
{
switch
(
topLevelType
)
{
case
TOP_COMPOSITION_START
:
return
eventTypes
.
compositionStart
;
case
TOP_COMPOSITION_END
:
return
eventTypes
.
compositionEnd
;
case
TOP_COMPOSITION_UPDATE
:
return
eventTypes
.
compositionUpdate
;
}
}
function
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
{
return
topLevelType
=
=
=
TOP_KEY_DOWN
&
&
nativeEvent
.
keyCode
=
=
=
START_KEYCODE
;
}
function
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_KEY_UP
:
return
END_KEYCODES
.
indexOf
(
nativeEvent
.
keyCode
)
!
=
=
-
1
;
case
TOP_KEY_DOWN
:
return
nativeEvent
.
keyCode
!
=
=
START_KEYCODE
;
case
TOP_KEY_PRESS
:
case
TOP_MOUSE_DOWN
:
case
TOP_BLUR
:
return
true
;
default
:
return
false
;
}
}
function
getDataFromCustomEvent
(
nativeEvent
)
{
var
detail
=
nativeEvent
.
detail
;
if
(
typeof
detail
=
=
=
'
object
'
&
&
'
data
'
in
detail
)
{
return
detail
.
data
;
}
return
null
;
}
var
isComposing
=
false
;
function
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
eventType
=
void
0
;
var
fallbackData
=
void
0
;
if
(
canUseCompositionEvent
)
{
eventType
=
getCompositionEventType
(
topLevelType
)
;
}
else
if
(
!
isComposing
)
{
if
(
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionStart
;
}
}
else
if
(
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionEnd
;
}
if
(
!
eventType
)
{
return
null
;
}
if
(
useFallbackCompositionData
)
{
if
(
!
isComposing
&
&
eventType
=
=
=
eventTypes
.
compositionStart
)
{
isComposing
=
initialize
(
nativeEventTarget
)
;
}
else
if
(
eventType
=
=
=
eventTypes
.
compositionEnd
)
{
if
(
isComposing
)
{
fallbackData
=
getData
(
)
;
}
}
}
var
event
=
SyntheticCompositionEvent
.
getPooled
(
eventType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
fallbackData
)
{
event
.
data
=
fallbackData
;
}
else
{
var
customData
=
getDataFromCustomEvent
(
nativeEvent
)
;
if
(
customData
!
=
=
null
)
{
event
.
data
=
customData
;
}
}
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
function
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_COMPOSITION_END
:
return
getDataFromCustomEvent
(
nativeEvent
)
;
case
TOP_KEY_PRESS
:
var
which
=
nativeEvent
.
which
;
if
(
which
!
=
=
SPACEBAR_CODE
)
{
return
null
;
}
hasSpaceKeypress
=
true
;
return
SPACEBAR_CHAR
;
case
TOP_TEXT_INPUT
:
var
chars
=
nativeEvent
.
data
;
if
(
chars
=
=
=
SPACEBAR_CHAR
&
&
hasSpaceKeypress
)
{
return
null
;
}
return
chars
;
default
:
return
null
;
}
}
function
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
{
if
(
isComposing
)
{
if
(
topLevelType
=
=
=
TOP_COMPOSITION_END
|
|
!
canUseCompositionEvent
&
&
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
var
chars
=
getData
(
)
;
reset
(
)
;
isComposing
=
false
;
return
chars
;
}
return
null
;
}
switch
(
topLevelType
)
{
case
TOP_PASTE
:
return
null
;
case
TOP_KEY_PRESS
:
if
(
!
isKeypressCommand
(
nativeEvent
)
)
{
if
(
nativeEvent
.
char
&
&
nativeEvent
.
char
.
length
>
1
)
{
return
nativeEvent
.
char
;
}
else
if
(
nativeEvent
.
which
)
{
return
String
.
fromCharCode
(
nativeEvent
.
which
)
;
}
}
return
null
;
case
TOP_COMPOSITION_END
:
return
useFallbackCompositionData
?
null
:
nativeEvent
.
data
;
default
:
return
null
;
}
}
function
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
chars
=
void
0
;
if
(
canUseTextInputEvent
)
{
chars
=
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
else
{
chars
=
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
if
(
!
chars
)
{
return
null
;
}
var
event
=
SyntheticInputEvent
.
getPooled
(
eventTypes
.
beforeInput
targetInst
nativeEvent
nativeEventTarget
)
;
event
.
data
=
chars
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
BeforeInputEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
composition
=
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
var
beforeInput
=
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
composition
=
=
=
null
)
{
return
beforeInput
;
}
if
(
beforeInput
=
=
=
null
)
{
return
composition
;
}
return
[
composition
beforeInput
]
;
}
}
;
var
fiberHostComponent
=
null
;
var
ReactControlledComponentInjection
=
{
injectFiberControlledHostComponent
:
function
(
hostComponentImpl
)
{
fiberHostComponent
=
hostComponentImpl
;
}
}
;
var
restoreTarget
=
null
;
var
restoreQueue
=
null
;
function
restoreStateOfTarget
(
target
)
{
var
internalInstance
=
getInstanceFromNode
(
target
)
;
if
(
!
internalInstance
)
{
return
;
}
!
(
fiberHostComponent
&
&
typeof
fiberHostComponent
.
restoreControlledState
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
194
'
)
:
void
0
;
var
props
=
getFiberCurrentPropsFromNode
(
internalInstance
.
stateNode
)
;
fiberHostComponent
.
restoreControlledState
(
internalInstance
.
stateNode
internalInstance
.
type
props
)
;
}
var
injection
2
=
ReactControlledComponentInjection
;
function
enqueueStateRestore
(
target
)
{
if
(
restoreTarget
)
{
if
(
restoreQueue
)
{
restoreQueue
.
push
(
target
)
;
}
else
{
restoreQueue
=
[
target
]
;
}
}
else
{
restoreTarget
=
target
;
}
}
function
needsStateRestore
(
)
{
return
restoreTarget
!
=
=
null
|
|
restoreQueue
!
=
=
null
;
}
function
restoreStateIfNeeded
(
)
{
if
(
!
restoreTarget
)
{
return
;
}
var
target
=
restoreTarget
;
var
queuedTargets
=
restoreQueue
;
restoreTarget
=
null
;
restoreQueue
=
null
;
restoreStateOfTarget
(
target
)
;
if
(
queuedTargets
)
{
for
(
var
i
=
0
;
i
<
queuedTargets
.
length
;
i
+
+
)
{
restoreStateOfTarget
(
queuedTargets
[
i
]
)
;
}
}
}
var
ReactControlledComponent
=
(
{
injection
:
injection
2
enqueueStateRestore
:
enqueueStateRestore
needsStateRestore
:
needsStateRestore
restoreStateIfNeeded
:
restoreStateIfNeeded
}
)
;
var
_batchedUpdates
=
function
(
fn
bookkeeping
)
{
return
fn
(
bookkeeping
)
;
}
;
var
_interactiveUpdates
=
function
(
fn
a
b
)
{
return
fn
(
a
b
)
;
}
;
var
_flushInteractiveUpdates
=
function
(
)
{
}
;
var
isBatching
=
false
;
function
batchedUpdates
(
fn
bookkeeping
)
{
if
(
isBatching
)
{
return
fn
(
bookkeeping
)
;
}
isBatching
=
true
;
try
{
return
_batchedUpdates
(
fn
bookkeeping
)
;
}
finally
{
isBatching
=
false
;
var
controlledComponentsHavePendingUpdates
=
needsStateRestore
(
)
;
if
(
controlledComponentsHavePendingUpdates
)
{
_flushInteractiveUpdates
(
)
;
restoreStateIfNeeded
(
)
;
}
}
}
function
interactiveUpdates
(
fn
a
b
)
{
return
_interactiveUpdates
(
fn
a
b
)
;
}
var
injection
3
=
{
injectRenderer
:
function
(
renderer
)
{
_batchedUpdates
=
renderer
.
batchedUpdates
;
_interactiveUpdates
=
renderer
.
interactiveUpdates
;
_flushInteractiveUpdates
=
renderer
.
flushInteractiveUpdates
;
}
}
;
var
supportedInputTypes
=
{
color
:
true
date
:
true
datetime
:
true
'
datetime
-
local
'
:
true
email
:
true
month
:
true
number
:
true
password
:
true
range
:
true
search
:
true
tel
:
true
text
:
true
time
:
true
url
:
true
week
:
true
}
;
function
isTextInputElement
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
if
(
nodeName
=
=
=
'
input
'
)
{
return
!
!
supportedInputTypes
[
elem
.
type
]
;
}
if
(
nodeName
=
=
=
'
textarea
'
)
{
return
true
;
}
return
false
;
}
var
ELEMENT_NODE
=
1
;
var
TEXT_NODE
=
3
;
var
COMMENT_NODE
=
8
;
var
DOCUMENT_NODE
=
9
;
var
DOCUMENT_FRAGMENT_NODE
=
11
;
function
getEventTarget
(
nativeEvent
)
{
var
target
=
nativeEvent
.
target
|
|
nativeEvent
.
srcElement
|
|
window
;
if
(
target
.
correspondingUseElement
)
{
target
=
target
.
correspondingUseElement
;
}
return
target
.
nodeType
=
=
=
TEXT_NODE
?
target
.
parentNode
:
target
;
}
function
isEventSupported
(
eventNameSuffix
capture
)
{
if
(
!
ExecutionEnvironment_1
.
canUseDOM
|
|
capture
&
&
!
(
'
addEventListener
'
in
document
)
)
{
return
false
;
}
var
eventName
=
'
on
'
+
eventNameSuffix
;
var
isSupported
=
eventName
in
document
;
if
(
!
isSupported
)
{
var
element
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
element
.
setAttribute
(
eventName
'
return
;
'
)
;
isSupported
=
typeof
element
[
eventName
]
=
=
=
'
function
'
;
}
return
isSupported
;
}
function
isCheckable
(
elem
)
{
var
type
=
elem
.
type
;
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
type
=
=
=
'
checkbox
'
|
|
type
=
=
=
'
radio
'
)
;
}
function
getTracker
(
node
)
{
return
node
.
_valueTracker
;
}
function
detachTracker
(
node
)
{
node
.
_valueTracker
=
null
;
}
function
getValueFromNode
(
node
)
{
var
value
=
'
'
;
if
(
!
node
)
{
return
value
;
}
if
(
isCheckable
(
node
)
)
{
value
=
node
.
checked
?
'
true
'
:
'
false
'
;
}
else
{
value
=
node
.
value
;
}
return
value
;
}
function
trackValueOnNode
(
node
)
{
var
valueField
=
isCheckable
(
node
)
?
'
checked
'
:
'
value
'
;
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
node
.
constructor
.
prototype
valueField
)
;
var
currentValue
=
'
'
+
node
[
valueField
]
;
if
(
node
.
hasOwnProperty
(
valueField
)
|
|
typeof
descriptor
=
=
=
'
undefined
'
|
|
typeof
descriptor
.
get
!
=
=
'
function
'
|
|
typeof
descriptor
.
set
!
=
=
'
function
'
)
{
return
;
}
var
get
=
descriptor
.
get
set
=
descriptor
.
set
;
Object
.
defineProperty
(
node
valueField
{
configurable
:
true
get
:
function
(
)
{
return
get
.
call
(
this
)
;
}
set
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
set
.
call
(
this
value
)
;
}
}
)
;
Object
.
defineProperty
(
node
valueField
{
enumerable
:
descriptor
.
enumerable
}
)
;
var
tracker
=
{
getValue
:
function
(
)
{
return
currentValue
;
}
setValue
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
}
stopTracking
:
function
(
)
{
detachTracker
(
node
)
;
delete
node
[
valueField
]
;
}
}
;
return
tracker
;
}
function
track
(
node
)
{
if
(
getTracker
(
node
)
)
{
return
;
}
node
.
_valueTracker
=
trackValueOnNode
(
node
)
;
}
function
updateValueIfChanged
(
node
)
{
if
(
!
node
)
{
return
false
;
}
var
tracker
=
getTracker
(
node
)
;
if
(
!
tracker
)
{
return
true
;
}
var
lastValue
=
tracker
.
getValue
(
)
;
var
nextValue
=
getValueFromNode
(
node
)
;
if
(
nextValue
!
=
=
lastValue
)
{
tracker
.
setValue
(
nextValue
)
;
return
true
;
}
return
false
;
}
var
ReactInternals
1
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
ReactCurrentOwner
=
ReactInternals
1
.
ReactCurrentOwner
;
var
describeComponentFrame
=
function
(
name
source
ownerName
)
{
return
'
\
n
in
'
+
(
name
|
|
'
Unknown
'
)
+
(
source
?
'
(
at
'
+
source
.
fileName
.
replace
(
/
^
.
*
[
\
\
\
/
]
/
'
'
)
+
'
:
'
+
source
.
lineNumber
+
'
)
'
:
ownerName
?
'
(
created
by
'
+
ownerName
+
'
)
'
:
'
'
)
;
}
;
var
hasSymbol
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
for
;
var
REACT_ELEMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
element
'
)
:
0xeac7
;
var
REACT_PORTAL_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
portal
'
)
:
0xeaca
;
var
REACT_FRAGMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
fragment
'
)
:
0xeacb
;
var
REACT_STRICT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
strict_mode
'
)
:
0xeacc
;
var
REACT_PROFILER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
profiler
'
)
:
0xead2
;
var
REACT_PROVIDER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
provider
'
)
:
0xeacd
;
var
REACT_CONTEXT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
context
'
)
:
0xeace
;
var
REACT_ASYNC_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
async_mode
'
)
:
0xeacf
;
var
REACT_FORWARD_REF_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
forward_ref
'
)
:
0xead0
;
var
REACT_TIMEOUT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
timeout
'
)
:
0xead1
;
var
MAYBE_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
if
(
maybeIterable
=
=
=
null
|
|
typeof
maybeIterable
=
=
=
'
undefined
'
)
{
return
null
;
}
var
maybeIterator
=
MAYBE_ITERATOR_SYMBOL
&
&
maybeIterable
[
MAYBE_ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
;
if
(
typeof
maybeIterator
=
=
=
'
function
'
)
{
return
maybeIterator
;
}
return
null
;
}
function
getComponentName
(
fiber
)
{
var
type
=
fiber
.
type
;
if
(
typeof
type
=
=
=
'
function
'
)
{
return
type
.
displayName
|
|
type
.
name
;
}
if
(
typeof
type
=
=
=
'
string
'
)
{
return
type
;
}
switch
(
type
)
{
case
REACT_ASYNC_MODE_TYPE
:
return
'
AsyncMode
'
;
case
REACT_CONTEXT_TYPE
:
return
'
Context
.
Consumer
'
;
case
REACT_FRAGMENT_TYPE
:
return
'
ReactFragment
'
;
case
REACT_PORTAL_TYPE
:
return
'
ReactPortal
'
;
case
REACT_PROFILER_TYPE
:
return
'
Profiler
(
'
+
fiber
.
pendingProps
.
id
+
'
)
'
;
case
REACT_PROVIDER_TYPE
:
return
'
Context
.
Provider
'
;
case
REACT_STRICT_MODE_TYPE
:
return
'
StrictMode
'
;
case
REACT_TIMEOUT_TYPE
:
return
'
Timeout
'
;
}
if
(
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
)
{
switch
(
type
.
typeof
)
{
case
REACT_FORWARD_REF_TYPE
:
var
functionName
=
type
.
render
.
displayName
|
|
type
.
render
.
name
|
|
'
'
;
return
functionName
!
=
=
'
'
?
'
ForwardRef
(
'
+
functionName
+
'
)
'
:
'
ForwardRef
'
;
}
}
return
null
;
}
function
describeFiber
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
IndeterminateComponent
:
case
FunctionalComponent
:
case
ClassComponent
:
case
HostComponent
:
var
owner
=
fiber
.
_debugOwner
;
var
source
=
fiber
.
_debugSource
;
var
name
=
getComponentName
(
fiber
)
;
var
ownerName
=
null
;
if
(
owner
)
{
ownerName
=
getComponentName
(
owner
)
;
}
return
describeComponentFrame
(
name
source
ownerName
)
;
default
:
return
'
'
;
}
}
function
getStackAddendumByWorkInProgressFiber
(
workInProgress
)
{
var
info
=
'
'
;
var
node
=
workInProgress
;
do
{
info
+
=
describeFiber
(
node
)
;
node
=
node
.
return
;
}
while
(
node
)
;
return
info
;
}
var
RESERVED
=
0
;
var
STRING
=
1
;
var
BOOLEANISH_STRING
=
2
;
var
BOOLEAN
=
3
;
var
OVERLOADED_BOOLEAN
=
4
;
var
NUMERIC
=
5
;
var
POSITIVE_NUMERIC
=
6
;
var
ATTRIBUTE_NAME_START_CHAR
=
'
:
A
-
Z_a
-
z
\
\
u00C0
-
\
\
u00D6
\
\
u00D8
-
\
\
u00F6
\
\
u00F8
-
\
\
u02FF
\
\
u0370
-
\
\
u037D
\
\
u037F
-
\
\
u1FFF
\
\
u200C
-
\
\
u200D
\
\
u2070
-
\
\
u218F
\
\
u2C00
-
\
\
u2FEF
\
\
u3001
-
\
\
uD7FF
\
\
uF900
-
\
\
uFDCF
\
\
uFDF0
-
\
\
uFFFD
'
;
var
ATTRIBUTE_NAME_CHAR
=
ATTRIBUTE_NAME_START_CHAR
+
'
\
\
-
.
0
-
9
\
\
u00B7
\
\
u0300
-
\
\
u036F
\
\
u203F
-
\
\
u2040
'
;
var
ROOT_ATTRIBUTE_NAME
=
'
data
-
reactroot
'
;
var
VALID_ATTRIBUTE_NAME_REGEX
=
new
RegExp
(
'
^
[
'
+
ATTRIBUTE_NAME_START_CHAR
+
'
]
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
var
illegalAttributeNameCache
=
{
}
;
var
validatedAttributeNameCache
=
{
}
;
function
isAttributeNameSafe
(
attributeName
)
{
if
(
validatedAttributeNameCache
.
hasOwnProperty
(
attributeName
)
)
{
return
true
;
}
if
(
illegalAttributeNameCache
.
hasOwnProperty
(
attributeName
)
)
{
return
false
;
}
if
(
VALID_ATTRIBUTE_NAME_REGEX
.
test
(
attributeName
)
)
{
validatedAttributeNameCache
[
attributeName
]
=
true
;
return
true
;
}
illegalAttributeNameCache
[
attributeName
]
=
true
;
return
false
;
}
function
shouldIgnoreAttribute
(
name
propertyInfo
isCustomComponentTag
)
{
if
(
propertyInfo
!
=
=
null
)
{
return
propertyInfo
.
type
=
=
=
RESERVED
;
}
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
name
.
length
>
2
&
&
(
name
[
0
]
=
=
=
'
o
'
|
|
name
[
0
]
=
=
=
'
O
'
)
&
&
(
name
[
1
]
=
=
=
'
n
'
|
|
name
[
1
]
=
=
=
'
N
'
)
)
{
return
true
;
}
return
false
;
}
function
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
isCustomComponentTag
)
{
if
(
propertyInfo
!
=
=
null
&
&
propertyInfo
.
type
=
=
=
RESERVED
)
{
return
false
;
}
switch
(
typeof
value
)
{
case
'
function
'
:
case
'
symbol
'
:
return
true
;
case
'
boolean
'
:
{
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
propertyInfo
!
=
=
null
)
{
return
!
propertyInfo
.
acceptsBooleans
;
}
else
{
var
prefix
=
name
.
toLowerCase
(
)
.
slice
(
0
5
)
;
return
prefix
!
=
=
'
data
-
'
&
&
prefix
!
=
=
'
aria
-
'
;
}
}
default
:
return
false
;
}
}
function
shouldRemoveAttribute
(
name
value
propertyInfo
isCustomComponentTag
)
{
if
(
value
=
=
=
null
|
|
typeof
value
=
=
=
'
undefined
'
)
{
return
true
;
}
if
(
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
isCustomComponentTag
)
)
{
return
true
;
}
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
propertyInfo
!
=
=
null
)
{
switch
(
propertyInfo
.
type
)
{
case
BOOLEAN
:
return
!
value
;
case
OVERLOADED_BOOLEAN
:
return
value
=
=
=
false
;
case
NUMERIC
:
return
isNaN
(
value
)
;
case
POSITIVE_NUMERIC
:
return
isNaN
(
value
)
|
|
value
<
1
;
}
}
return
false
;
}
function
getPropertyInfo
(
name
)
{
return
properties
.
hasOwnProperty
(
name
)
?
properties
[
name
]
:
null
;
}
function
PropertyInfoRecord
(
name
type
mustUseProperty
attributeName
attributeNamespace
)
{
this
.
acceptsBooleans
=
type
=
=
=
BOOLEANISH_STRING
|
|
type
=
=
=
BOOLEAN
|
|
type
=
=
=
OVERLOADED_BOOLEAN
;
this
.
attributeName
=
attributeName
;
this
.
attributeNamespace
=
attributeNamespace
;
this
.
mustUseProperty
=
mustUseProperty
;
this
.
propertyName
=
name
;
this
.
type
=
type
;
}
var
properties
=
{
}
;
[
'
children
'
'
dangerouslySetInnerHTML
'
'
defaultValue
'
'
defaultChecked
'
'
innerHTML
'
'
suppressContentEditableWarning
'
'
suppressHydrationWarning
'
'
style
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
RESERVED
false
name
null
)
;
}
)
;
[
[
'
acceptCharset
'
'
accept
-
charset
'
]
[
'
className
'
'
class
'
]
[
'
htmlFor
'
'
for
'
]
[
'
httpEquiv
'
'
http
-
equiv
'
]
]
.
forEach
(
function
(
_ref
)
{
var
name
=
_ref
[
0
]
attributeName
=
_ref
[
1
]
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
null
)
;
}
)
;
[
'
contentEditable
'
'
draggable
'
'
spellCheck
'
'
value
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEANISH_STRING
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
[
'
autoReverse
'
'
externalResourcesRequired
'
'
preserveAlpha
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEANISH_STRING
false
name
null
)
;
}
)
;
[
'
allowFullScreen
'
'
async
'
'
autoFocus
'
'
autoPlay
'
'
controls
'
'
default
'
'
defer
'
'
disabled
'
'
formNoValidate
'
'
hidden
'
'
loop
'
'
noModule
'
'
noValidate
'
'
open
'
'
playsInline
'
'
readOnly
'
'
required
'
'
reversed
'
'
scoped
'
'
seamless
'
'
itemScope
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEAN
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
[
'
checked
'
'
multiple
'
'
muted
'
'
selected
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEAN
true
name
.
toLowerCase
(
)
null
)
;
}
)
;
[
'
capture
'
'
download
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
OVERLOADED_BOOLEAN
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
[
'
cols
'
'
rows
'
'
size
'
'
span
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
POSITIVE_NUMERIC
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
[
'
rowSpan
'
'
start
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
NUMERIC
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
var
CAMELIZE
=
/
[
\
-
\
:
]
(
[
a
-
z
]
)
/
g
;
var
capitalize
=
function
(
token
)
{
return
token
[
1
]
.
toUpperCase
(
)
;
}
;
[
'
accent
-
height
'
'
alignment
-
baseline
'
'
arabic
-
form
'
'
baseline
-
shift
'
'
cap
-
height
'
'
clip
-
path
'
'
clip
-
rule
'
'
color
-
interpolation
'
'
color
-
interpolation
-
filters
'
'
color
-
profile
'
'
color
-
rendering
'
'
dominant
-
baseline
'
'
enable
-
background
'
'
fill
-
opacity
'
'
fill
-
rule
'
'
flood
-
color
'
'
flood
-
opacity
'
'
font
-
family
'
'
font
-
size
'
'
font
-
size
-
adjust
'
'
font
-
stretch
'
'
font
-
style
'
'
font
-
variant
'
'
font
-
weight
'
'
glyph
-
name
'
'
glyph
-
orientation
-
horizontal
'
'
glyph
-
orientation
-
vertical
'
'
horiz
-
adv
-
x
'
'
horiz
-
origin
-
x
'
'
image
-
rendering
'
'
letter
-
spacing
'
'
lighting
-
color
'
'
marker
-
end
'
'
marker
-
mid
'
'
marker
-
start
'
'
overline
-
position
'
'
overline
-
thickness
'
'
paint
-
order
'
'
panose
-
1
'
'
pointer
-
events
'
'
rendering
-
intent
'
'
shape
-
rendering
'
'
stop
-
color
'
'
stop
-
opacity
'
'
strikethrough
-
position
'
'
strikethrough
-
thickness
'
'
stroke
-
dasharray
'
'
stroke
-
dashoffset
'
'
stroke
-
linecap
'
'
stroke
-
linejoin
'
'
stroke
-
miterlimit
'
'
stroke
-
opacity
'
'
stroke
-
width
'
'
text
-
anchor
'
'
text
-
decoration
'
'
text
-
rendering
'
'
underline
-
position
'
'
underline
-
thickness
'
'
unicode
-
bidi
'
'
unicode
-
range
'
'
units
-
per
-
em
'
'
v
-
alphabetic
'
'
v
-
hanging
'
'
v
-
ideographic
'
'
v
-
mathematical
'
'
vector
-
effect
'
'
vert
-
adv
-
y
'
'
vert
-
origin
-
x
'
'
vert
-
origin
-
y
'
'
word
-
spacing
'
'
writing
-
mode
'
'
xmlns
:
xlink
'
'
x
-
height
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
null
)
;
}
)
;
[
'
xlink
:
actuate
'
'
xlink
:
arcrole
'
'
xlink
:
href
'
'
xlink
:
role
'
'
xlink
:
show
'
'
xlink
:
title
'
'
xlink
:
type
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
)
;
}
)
;
[
'
xml
:
base
'
'
xml
:
lang
'
'
xml
:
space
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
)
;
}
)
;
properties
.
tabIndex
=
new
PropertyInfoRecord
(
'
tabIndex
'
STRING
false
'
tabindex
'
null
)
;
function
setValueForProperty
(
node
name
value
isCustomComponentTag
)
{
var
propertyInfo
=
getPropertyInfo
(
name
)
;
if
(
shouldIgnoreAttribute
(
name
propertyInfo
isCustomComponentTag
)
)
{
return
;
}
if
(
shouldRemoveAttribute
(
name
value
propertyInfo
isCustomComponentTag
)
)
{
value
=
null
;
}
if
(
isCustomComponentTag
|
|
propertyInfo
=
=
=
null
)
{
if
(
isAttributeNameSafe
(
name
)
)
{
var
_attributeName
=
name
;
if
(
value
=
=
=
null
)
{
node
.
removeAttribute
(
_attributeName
)
;
}
else
{
node
.
setAttribute
(
_attributeName
'
'
+
value
)
;
}
}
return
;
}
var
mustUseProperty
=
propertyInfo
.
mustUseProperty
;
if
(
mustUseProperty
)
{
var
propertyName
=
propertyInfo
.
propertyName
;
if
(
value
=
=
=
null
)
{
var
type
=
propertyInfo
.
type
;
node
[
propertyName
]
=
type
=
=
=
BOOLEAN
?
false
:
'
'
;
}
else
{
node
[
propertyName
]
=
value
;
}
return
;
}
var
attributeName
=
propertyInfo
.
attributeName
attributeNamespace
=
propertyInfo
.
attributeNamespace
;
if
(
value
=
=
=
null
)
{
node
.
removeAttribute
(
attributeName
)
;
}
else
{
var
_type
=
propertyInfo
.
type
;
var
attributeValue
=
void
0
;
if
(
_type
=
=
=
BOOLEAN
|
|
_type
=
=
=
OVERLOADED_BOOLEAN
&
&
value
=
=
=
true
)
{
attributeValue
=
'
'
;
}
else
{
attributeValue
=
'
'
+
value
;
}
if
(
attributeNamespace
)
{
node
.
setAttributeNS
(
attributeNamespace
attributeName
attributeValue
)
;
}
else
{
node
.
setAttribute
(
attributeName
attributeValue
)
;
}
}
}
function
isControlled
(
props
)
{
var
usesChecked
=
props
.
type
=
=
=
'
checkbox
'
|
|
props
.
type
=
=
=
'
radio
'
;
return
usesChecked
?
props
.
checked
!
=
null
:
props
.
value
!
=
null
;
}
function
getHostProps
(
element
props
)
{
var
node
=
element
;
var
checked
=
props
.
checked
;
var
hostProps
=
_assign
(
{
}
props
{
defaultChecked
:
undefined
defaultValue
:
undefined
value
:
undefined
checked
:
checked
!
=
null
?
checked
:
node
.
_wrapperState
.
initialChecked
}
)
;
return
hostProps
;
}
function
initWrapperState
(
element
props
)
{
var
node
=
element
;
var
defaultValue
=
props
.
defaultValue
=
=
null
?
'
'
:
props
.
defaultValue
;
node
.
_wrapperState
=
{
initialChecked
:
props
.
checked
!
=
null
?
props
.
checked
:
props
.
defaultChecked
initialValue
:
getSafeValue
(
props
.
value
!
=
null
?
props
.
value
:
defaultValue
)
controlled
:
isControlled
(
props
)
}
;
}
function
updateChecked
(
element
props
)
{
var
node
=
element
;
var
checked
=
props
.
checked
;
if
(
checked
!
=
null
)
{
setValueForProperty
(
node
'
checked
'
checked
false
)
;
}
}
function
updateWrapper
(
element
props
)
{
var
node
=
element
;
updateChecked
(
element
props
)
;
var
value
=
getSafeValue
(
props
.
value
)
;
if
(
value
!
=
null
)
{
if
(
props
.
type
=
=
=
'
number
'
)
{
if
(
value
=
=
=
0
&
&
node
.
value
=
=
=
'
'
|
|
node
.
value
!
=
value
)
{
node
.
value
=
'
'
+
value
;
}
}
else
if
(
node
.
value
!
=
=
'
'
+
value
)
{
node
.
value
=
'
'
+
value
;
}
}
if
(
props
.
hasOwnProperty
(
'
value
'
)
)
{
setDefaultValue
(
node
props
.
type
value
)
;
}
else
if
(
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
setDefaultValue
(
node
props
.
type
getSafeValue
(
props
.
defaultValue
)
)
;
}
if
(
props
.
checked
=
=
null
&
&
props
.
defaultChecked
!
=
null
)
{
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
function
postMountWrapper
(
element
props
isHydrating
)
{
var
node
=
element
;
if
(
props
.
hasOwnProperty
(
'
value
'
)
|
|
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
var
_initialValue
=
'
'
+
node
.
_wrapperState
.
initialValue
;
var
currentValue
=
node
.
value
;
if
(
!
isHydrating
)
{
if
(
_initialValue
!
=
=
currentValue
)
{
node
.
value
=
_initialValue
;
}
}
node
.
defaultValue
=
_initialValue
;
}
var
name
=
node
.
name
;
if
(
name
!
=
=
'
'
)
{
node
.
name
=
'
'
;
}
node
.
defaultChecked
=
!
node
.
defaultChecked
;
node
.
defaultChecked
=
!
node
.
defaultChecked
;
if
(
name
!
=
=
'
'
)
{
node
.
name
=
name
;
}
}
function
restoreControlledState
(
element
props
)
{
var
node
=
element
;
updateWrapper
(
node
props
)
;
updateNamedCousins
(
node
props
)
;
}
function
updateNamedCousins
(
rootNode
props
)
{
var
name
=
props
.
name
;
if
(
props
.
type
=
=
=
'
radio
'
&
&
name
!
=
null
)
{
var
queryRoot
=
rootNode
;
while
(
queryRoot
.
parentNode
)
{
queryRoot
=
queryRoot
.
parentNode
;
}
var
group
=
queryRoot
.
querySelectorAll
(
'
input
[
name
=
'
+
JSON
.
stringify
(
'
'
+
name
)
+
'
]
[
type
=
"
radio
"
]
'
)
;
for
(
var
i
=
0
;
i
<
group
.
length
;
i
+
+
)
{
var
otherNode
=
group
[
i
]
;
if
(
otherNode
=
=
=
rootNode
|
|
otherNode
.
form
!
=
=
rootNode
.
form
)
{
continue
;
}
var
otherProps
=
getFiberCurrentPropsFromNode
1
(
otherNode
)
;
!
otherProps
?
reactProdInvariant
(
'
90
'
)
:
void
0
;
updateValueIfChanged
(
otherNode
)
;
updateWrapper
(
otherNode
otherProps
)
;
}
}
}
function
setDefaultValue
(
node
type
value
)
{
if
(
type
!
=
=
'
number
'
|
|
node
.
ownerDocument
.
activeElement
!
=
=
node
)
{
if
(
value
=
=
null
)
{
node
.
defaultValue
=
'
'
+
node
.
_wrapperState
.
initialValue
;
}
else
if
(
node
.
defaultValue
!
=
=
'
'
+
value
)
{
node
.
defaultValue
=
'
'
+
value
;
}
}
}
function
getSafeValue
(
value
)
{
switch
(
typeof
value
)
{
case
'
boolean
'
:
case
'
number
'
:
case
'
object
'
:
case
'
string
'
:
case
'
undefined
'
:
return
value
;
default
:
return
'
'
;
}
}
var
eventTypes
1
=
{
change
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onChange
'
captured
:
'
onChangeCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_CHANGE
TOP_CLICK
TOP_FOCUS
TOP_INPUT
TOP_KEY_DOWN
TOP_KEY_UP
TOP_SELECTION_CHANGE
]
}
}
;
function
createAndAccumulateChangeEvent
(
inst
nativeEvent
target
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
1
.
change
inst
nativeEvent
target
)
;
event
.
type
=
'
change
'
;
enqueueStateRestore
(
target
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
activeElement
=
null
;
var
activeElementInst
=
null
;
function
shouldUseChangeEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
=
=
=
'
select
'
|
|
nodeName
=
=
=
'
input
'
&
&
elem
.
type
=
=
=
'
file
'
;
}
function
manualDispatchChangeEvent
(
nativeEvent
)
{
var
event
=
createAndAccumulateChangeEvent
(
activeElementInst
nativeEvent
getEventTarget
(
nativeEvent
)
)
;
batchedUpdates
(
runEventInBatch
event
)
;
}
function
runEventInBatch
(
event
)
{
runEventsInBatch
(
event
false
)
;
}
function
getInstIfValueChanged
(
targetInst
)
{
var
targetNode
=
getNodeFromInstance
1
(
targetInst
)
;
if
(
updateValueIfChanged
(
targetNode
)
)
{
return
targetInst
;
}
}
function
getTargetInstForChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_CHANGE
)
{
return
targetInst
;
}
}
var
isInputEventSupported
=
false
;
if
(
ExecutionEnvironment_1
.
canUseDOM
)
{
isInputEventSupported
=
isEventSupported
(
'
input
'
)
&
&
(
!
document
.
documentMode
|
|
document
.
documentMode
>
9
)
;
}
function
startWatchingForValueChange
(
target
targetInst
)
{
activeElement
=
target
;
activeElementInst
=
targetInst
;
activeElement
.
attachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
}
function
stopWatchingForValueChange
(
)
{
if
(
!
activeElement
)
{
return
;
}
activeElement
.
detachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
activeElement
=
null
;
activeElementInst
=
null
;
}
function
handlePropertyChange
(
nativeEvent
)
{
if
(
nativeEvent
.
propertyName
!
=
=
'
value
'
)
{
return
;
}
if
(
getInstIfValueChanged
(
activeElementInst
)
)
{
manualDispatchChangeEvent
(
nativeEvent
)
;
}
}
function
handleEventsForInputEventPolyfill
(
topLevelType
target
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_FOCUS
)
{
stopWatchingForValueChange
(
)
;
startWatchingForValueChange
(
target
targetInst
)
;
}
else
if
(
topLevelType
=
=
=
TOP_BLUR
)
{
stopWatchingForValueChange
(
)
;
}
}
function
getTargetInstForInputEventPolyfill
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_SELECTION_CHANGE
|
|
topLevelType
=
=
=
TOP_KEY_UP
|
|
topLevelType
=
=
=
TOP_KEY_DOWN
)
{
return
getInstIfValueChanged
(
activeElementInst
)
;
}
}
function
shouldUseClickEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
checkbox
'
|
|
elem
.
type
=
=
=
'
radio
'
)
;
}
function
getTargetInstForClickEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_CLICK
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
getTargetInstForInputOrChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_INPUT
|
|
topLevelType
=
=
=
TOP_CHANGE
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
handleControlledInputBlur
(
node
)
{
var
state
=
node
.
_wrapperState
;
if
(
!
state
|
|
!
state
.
controlled
|
|
node
.
type
!
=
=
'
number
'
)
{
return
;
}
setDefaultValue
(
node
'
number
'
node
.
value
)
;
}
var
ChangeEventPlugin
=
{
eventTypes
:
eventTypes
1
_isInputEventSupported
:
isInputEventSupported
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
var
getTargetInstFunc
=
void
0
handleEventFunc
=
void
0
;
if
(
shouldUseChangeEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForChangeEvent
;
}
else
if
(
isTextInputElement
(
targetNode
)
)
{
if
(
isInputEventSupported
)
{
getTargetInstFunc
=
getTargetInstForInputOrChangeEvent
;
}
else
{
getTargetInstFunc
=
getTargetInstForInputEventPolyfill
;
handleEventFunc
=
handleEventsForInputEventPolyfill
;
}
}
else
if
(
shouldUseClickEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForClickEvent
;
}
if
(
getTargetInstFunc
)
{
var
inst
=
getTargetInstFunc
(
topLevelType
targetInst
)
;
if
(
inst
)
{
var
event
=
createAndAccumulateChangeEvent
(
inst
nativeEvent
nativeEventTarget
)
;
return
event
;
}
}
if
(
handleEventFunc
)
{
handleEventFunc
(
topLevelType
targetNode
targetInst
)
;
}
if
(
topLevelType
=
=
=
TOP_BLUR
)
{
handleControlledInputBlur
(
targetNode
)
;
}
}
}
;
var
DOMEventPluginOrder
=
[
'
ResponderEventPlugin
'
'
SimpleEventPlugin
'
'
TapEventPlugin
'
'
EnterLeaveEventPlugin
'
'
ChangeEventPlugin
'
'
SelectEventPlugin
'
'
BeforeInputEventPlugin
'
]
;
var
SyntheticUIEvent
=
SyntheticEvent
.
extend
(
{
view
:
null
detail
:
null
}
)
;
var
modifierKeyToProp
=
{
Alt
:
'
altKey
'
Control
:
'
ctrlKey
'
Meta
:
'
metaKey
'
Shift
:
'
shiftKey
'
}
;
function
modifierStateGetter
(
keyArg
)
{
var
syntheticEvent
=
this
;
var
nativeEvent
=
syntheticEvent
.
nativeEvent
;
if
(
nativeEvent
.
getModifierState
)
{
return
nativeEvent
.
getModifierState
(
keyArg
)
;
}
var
keyProp
=
modifierKeyToProp
[
keyArg
]
;
return
keyProp
?
!
!
nativeEvent
[
keyProp
]
:
false
;
}
function
getEventModifierState
(
nativeEvent
)
{
return
modifierStateGetter
;
}
var
SyntheticMouseEvent
=
SyntheticUIEvent
.
extend
(
{
screenX
:
null
screenY
:
null
clientX
:
null
clientY
:
null
pageX
:
null
pageY
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
getModifierState
:
getEventModifierState
button
:
null
buttons
:
null
relatedTarget
:
function
(
event
)
{
return
event
.
relatedTarget
|
|
(
event
.
fromElement
=
=
=
event
.
srcElement
?
event
.
toElement
:
event
.
fromElement
)
;
}
}
)
;
var
SyntheticPointerEvent
=
SyntheticMouseEvent
.
extend
(
{
pointerId
:
null
width
:
null
height
:
null
pressure
:
null
tiltX
:
null
tiltY
:
null
pointerType
:
null
isPrimary
:
null
}
)
;
var
eventTypes
2
=
{
mouseEnter
:
{
registrationName
:
'
onMouseEnter
'
dependencies
:
[
TOP_MOUSE_OUT
TOP_MOUSE_OVER
]
}
mouseLeave
:
{
registrationName
:
'
onMouseLeave
'
dependencies
:
[
TOP_MOUSE_OUT
TOP_MOUSE_OVER
]
}
pointerEnter
:
{
registrationName
:
'
onPointerEnter
'
dependencies
:
[
TOP_POINTER_OUT
TOP_POINTER_OVER
]
}
pointerLeave
:
{
registrationName
:
'
onPointerLeave
'
dependencies
:
[
TOP_POINTER_OUT
TOP_POINTER_OVER
]
}
}
;
var
EnterLeaveEventPlugin
=
{
eventTypes
:
eventTypes
2
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
isOverEvent
=
topLevelType
=
=
=
TOP_MOUSE_OVER
|
|
topLevelType
=
=
=
TOP_POINTER_OVER
;
var
isOutEvent
=
topLevelType
=
=
=
TOP_MOUSE_OUT
|
|
topLevelType
=
=
=
TOP_POINTER_OUT
;
if
(
isOverEvent
&
&
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
fromElement
)
)
{
return
null
;
}
if
(
!
isOutEvent
&
&
!
isOverEvent
)
{
return
null
;
}
var
win
=
void
0
;
if
(
nativeEventTarget
.
window
=
=
=
nativeEventTarget
)
{
win
=
nativeEventTarget
;
}
else
{
var
doc
=
nativeEventTarget
.
ownerDocument
;
if
(
doc
)
{
win
=
doc
.
defaultView
|
|
doc
.
parentWindow
;
}
else
{
win
=
window
;
}
}
var
from
=
void
0
;
var
to
=
void
0
;
if
(
isOutEvent
)
{
from
=
targetInst
;
var
related
=
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
toElement
;
to
=
related
?
getClosestInstanceFromNode
(
related
)
:
null
;
}
else
{
from
=
null
;
to
=
targetInst
;
}
if
(
from
=
=
=
to
)
{
return
null
;
}
var
eventInterface
=
void
0
leaveEventType
=
void
0
enterEventType
=
void
0
eventTypePrefix
=
void
0
;
if
(
topLevelType
=
=
=
TOP_MOUSE_OUT
|
|
topLevelType
=
=
=
TOP_MOUSE_OVER
)
{
eventInterface
=
SyntheticMouseEvent
;
leaveEventType
=
eventTypes
2
.
mouseLeave
;
enterEventType
=
eventTypes
2
.
mouseEnter
;
eventTypePrefix
=
'
mouse
'
;
}
else
if
(
topLevelType
=
=
=
TOP_POINTER_OUT
|
|
topLevelType
=
=
=
TOP_POINTER_OVER
)
{
eventInterface
=
SyntheticPointerEvent
;
leaveEventType
=
eventTypes
2
.
pointerLeave
;
enterEventType
=
eventTypes
2
.
pointerEnter
;
eventTypePrefix
=
'
pointer
'
;
}
var
fromNode
=
from
=
=
null
?
win
:
getNodeFromInstance
1
(
from
)
;
var
toNode
=
to
=
=
null
?
win
:
getNodeFromInstance
1
(
to
)
;
var
leave
=
eventInterface
.
getPooled
(
leaveEventType
from
nativeEvent
nativeEventTarget
)
;
leave
.
type
=
eventTypePrefix
+
'
leave
'
;
leave
.
target
=
fromNode
;
leave
.
relatedTarget
=
toNode
;
var
enter
=
eventInterface
.
getPooled
(
enterEventType
to
nativeEvent
nativeEventTarget
)
;
enter
.
type
=
eventTypePrefix
+
'
enter
'
;
enter
.
target
=
toNode
;
enter
.
relatedTarget
=
fromNode
;
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
;
return
[
leave
enter
]
;
}
}
;
function
getActiveElement
(
doc
)
{
doc
=
doc
|
|
(
typeof
document
!
=
=
'
undefined
'
?
document
:
undefined
)
;
if
(
typeof
doc
=
=
=
'
undefined
'
)
{
return
null
;
}
try
{
return
doc
.
activeElement
|
|
doc
.
body
;
}
catch
(
e
)
{
return
doc
.
body
;
}
}
var
getActiveElement_1
=
getActiveElement
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
is
(
x
y
)
{
if
(
x
=
=
=
y
)
{
return
x
!
=
=
0
|
|
y
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
;
}
else
{
return
x
!
=
=
x
&
&
y
!
=
=
y
;
}
}
function
shallowEqual
(
objA
objB
)
{
if
(
is
(
objA
objB
)
)
{
return
true
;
}
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwnProperty
.
call
(
objB
keysA
[
i
]
)
|
|
!
is
(
objA
[
keysA
[
i
]
]
objB
[
keysA
[
i
]
]
)
)
{
return
false
;
}
}
return
true
;
}
var
shallowEqual_1
=
shallowEqual
;
function
get
(
key
)
{
return
key
.
_reactInternalFiber
;
}
function
has
(
key
)
{
return
key
.
_reactInternalFiber
!
=
=
undefined
;
}
function
set
(
key
value
)
{
key
.
_reactInternalFiber
=
value
;
}
var
NoEffect
=
0
;
var
PerformedWork
=
1
;
var
Placement
=
2
;
var
Update
=
4
;
var
PlacementAndUpdate
=
6
;
var
Deletion
=
8
;
var
ContentReset
=
16
;
var
Callback
=
32
;
var
DidCapture
=
64
;
var
Ref
=
128
;
var
Snapshot
=
256
;
var
HostEffectMask
=
511
;
var
Incomplete
=
512
;
var
ShouldCapture
=
1024
;
var
MOUNTING
=
1
;
var
MOUNTED
=
2
;
var
UNMOUNTED
=
3
;
function
isFiberMountedImpl
(
fiber
)
{
var
node
=
fiber
;
if
(
!
fiber
.
alternate
)
{
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
while
(
node
.
return
)
{
node
=
node
.
return
;
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
}
}
else
{
while
(
node
.
return
)
{
node
=
node
.
return
;
}
}
if
(
node
.
tag
=
=
=
HostRoot
)
{
return
MOUNTED
;
}
return
UNMOUNTED
;
}
function
isFiberMounted
(
fiber
)
{
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
isMounted
(
component
)
{
var
fiber
=
get
(
component
)
;
if
(
!
fiber
)
{
return
false
;
}
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
assertIsMounted
(
fiber
)
{
!
(
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
}
function
findCurrentFiberUsingSlowPath
(
fiber
)
{
var
alternate
=
fiber
.
alternate
;
if
(
!
alternate
)
{
var
state
=
isFiberMountedImpl
(
fiber
)
;
!
(
state
!
=
=
UNMOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
state
=
=
=
MOUNTING
)
{
return
null
;
}
return
fiber
;
}
var
a
=
fiber
;
var
b
=
alternate
;
while
(
true
)
{
var
parentA
=
a
.
return
;
var
parentB
=
parentA
?
parentA
.
alternate
:
null
;
if
(
!
parentA
|
|
!
parentB
)
{
break
;
}
if
(
parentA
.
child
=
=
=
parentB
.
child
)
{
var
child
=
parentA
.
child
;
while
(
child
)
{
if
(
child
=
=
=
a
)
{
assertIsMounted
(
parentA
)
;
return
fiber
;
}
if
(
child
=
=
=
b
)
{
assertIsMounted
(
parentA
)
;
return
alternate
;
}
child
=
child
.
sibling
;
}
reactProdInvariant
(
'
188
'
)
;
}
if
(
a
.
return
!
=
=
b
.
return
)
{
a
=
parentA
;
b
=
parentB
;
}
else
{
var
didFindChild
=
false
;
var
_child
=
parentA
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentA
;
b
=
parentB
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentA
;
a
=
parentB
;
break
;
}
_child
=
_child
.
sibling
;
}
if
(
!
didFindChild
)
{
_child
=
parentB
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentB
;
b
=
parentA
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentB
;
a
=
parentA
;
break
;
}
_child
=
_child
.
sibling
;
}
!
didFindChild
?
reactProdInvariant
(
'
189
'
)
:
void
0
;
}
}
!
(
a
.
alternate
=
=
=
b
)
?
reactProdInvariant
(
'
190
'
)
:
void
0
;
}
!
(
a
.
tag
=
=
=
HostRoot
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
a
.
stateNode
.
current
=
=
=
a
)
{
return
fiber
;
}
return
alternate
;
}
function
findCurrentHostFiber
(
parent
)
{
var
currentParent
=
findCurrentFiberUsingSlowPath
(
parent
)
;
if
(
!
currentParent
)
{
return
null
;
}
var
node
=
currentParent
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
return
node
;
}
else
if
(
node
.
child
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
currentParent
)
{
return
null
;
}
while
(
!
node
.
sibling
)
{
if
(
!
node
.
return
|
|
node
.
return
=
=
=
currentParent
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
return
null
;
}
function
findCurrentHostFiberWithNoPortals
(
parent
)
{
var
currentParent
=
findCurrentFiberUsingSlowPath
(
parent
)
;
if
(
!
currentParent
)
{
return
null
;
}
var
node
=
currentParent
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
return
node
;
}
else
if
(
node
.
child
&
&
node
.
tag
!
=
=
HostPortal
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
currentParent
)
{
return
null
;
}
while
(
!
node
.
sibling
)
{
if
(
!
node
.
return
|
|
node
.
return
=
=
=
currentParent
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
return
null
;
}
function
addEventBubbleListener
(
element
eventType
listener
)
{
element
.
addEventListener
(
eventType
listener
false
)
;
}
function
addEventCaptureListener
(
element
eventType
listener
)
{
element
.
addEventListener
(
eventType
listener
true
)
;
}
var
SyntheticAnimationEvent
=
SyntheticEvent
.
extend
(
{
animationName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
)
;
var
SyntheticClipboardEvent
=
SyntheticEvent
.
extend
(
{
clipboardData
:
function
(
event
)
{
return
'
clipboardData
'
in
event
?
event
.
clipboardData
:
window
.
clipboardData
;
}
}
)
;
var
SyntheticFocusEvent
=
SyntheticUIEvent
.
extend
(
{
relatedTarget
:
null
}
)
;
function
getEventCharCode
(
nativeEvent
)
{
var
charCode
=
void
0
;
var
keyCode
=
nativeEvent
.
keyCode
;
if
(
'
charCode
'
in
nativeEvent
)
{
charCode
=
nativeEvent
.
charCode
;
if
(
charCode
=
=
=
0
&
&
keyCode
=
=
=
13
)
{
charCode
=
13
;
}
}
else
{
charCode
=
keyCode
;
}
if
(
charCode
=
=
=
10
)
{
charCode
=
13
;
}
if
(
charCode
>
=
32
|
|
charCode
=
=
=
13
)
{
return
charCode
;
}
return
0
;
}
var
normalizeKey
=
{
Esc
:
'
Escape
'
Spacebar
:
'
'
Left
:
'
ArrowLeft
'
Up
:
'
ArrowUp
'
Right
:
'
ArrowRight
'
Down
:
'
ArrowDown
'
Del
:
'
Delete
'
Win
:
'
OS
'
Menu
:
'
ContextMenu
'
Apps
:
'
ContextMenu
'
Scroll
:
'
ScrollLock
'
MozPrintableKey
:
'
Unidentified
'
}
;
var
translateToKey
=
{
'
8
'
:
'
Backspace
'
'
9
'
:
'
Tab
'
'
12
'
:
'
Clear
'
'
13
'
:
'
Enter
'
'
16
'
:
'
Shift
'
'
17
'
:
'
Control
'
'
18
'
:
'
Alt
'
'
19
'
:
'
Pause
'
'
20
'
:
'
CapsLock
'
'
27
'
:
'
Escape
'
'
32
'
:
'
'
'
33
'
:
'
PageUp
'
'
34
'
:
'
PageDown
'
'
35
'
:
'
End
'
'
36
'
:
'
Home
'
'
37
'
:
'
ArrowLeft
'
'
38
'
:
'
ArrowUp
'
'
39
'
:
'
ArrowRight
'
'
40
'
:
'
ArrowDown
'
'
45
'
:
'
Insert
'
'
46
'
:
'
Delete
'
'
112
'
:
'
F1
'
'
113
'
:
'
F2
'
'
114
'
:
'
F3
'
'
115
'
:
'
F4
'
'
116
'
:
'
F5
'
'
117
'
:
'
F6
'
'
118
'
:
'
F7
'
'
119
'
:
'
F8
'
'
120
'
:
'
F9
'
'
121
'
:
'
F10
'
'
122
'
:
'
F11
'
'
123
'
:
'
F12
'
'
144
'
:
'
NumLock
'
'
145
'
:
'
ScrollLock
'
'
224
'
:
'
Meta
'
}
;
function
getEventKey
(
nativeEvent
)
{
if
(
nativeEvent
.
key
)
{
var
key
=
normalizeKey
[
nativeEvent
.
key
]
|
|
nativeEvent
.
key
;
if
(
key
!
=
=
'
Unidentified
'
)
{
return
key
;
}
}
if
(
nativeEvent
.
type
=
=
=
'
keypress
'
)
{
var
charCode
=
getEventCharCode
(
nativeEvent
)
;
return
charCode
=
=
=
13
?
'
Enter
'
:
String
.
fromCharCode
(
charCode
)
;
}
if
(
nativeEvent
.
type
=
=
=
'
keydown
'
|
|
nativeEvent
.
type
=
=
=
'
keyup
'
)
{
return
translateToKey
[
nativeEvent
.
keyCode
]
|
|
'
Unidentified
'
;
}
return
'
'
;
}
var
SyntheticKeyboardEvent
=
SyntheticUIEvent
.
extend
(
{
key
:
getEventKey
location
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
repeat
:
null
locale
:
null
getModifierState
:
getEventModifierState
charCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
return
0
;
}
keyCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
which
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
}
)
;
var
SyntheticDragEvent
=
SyntheticMouseEvent
.
extend
(
{
dataTransfer
:
null
}
)
;
var
SyntheticTouchEvent
=
SyntheticUIEvent
.
extend
(
{
touches
:
null
targetTouches
:
null
changedTouches
:
null
altKey
:
null
metaKey
:
null
ctrlKey
:
null
shiftKey
:
null
getModifierState
:
getEventModifierState
}
)
;
var
SyntheticTransitionEvent
=
SyntheticEvent
.
extend
(
{
propertyName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
)
;
var
SyntheticWheelEvent
=
SyntheticMouseEvent
.
extend
(
{
deltaX
:
function
(
event
)
{
return
'
deltaX
'
in
event
?
event
.
deltaX
:
'
wheelDeltaX
'
in
event
?
-
event
.
wheelDeltaX
:
0
;
}
deltaY
:
function
(
event
)
{
return
'
deltaY
'
in
event
?
event
.
deltaY
:
'
wheelDeltaY
'
in
event
?
-
event
.
wheelDeltaY
:
'
wheelDelta
'
in
event
?
-
event
.
wheelDelta
:
0
;
}
deltaZ
:
null
deltaMode
:
null
}
)
;
var
interactiveEventTypeNames
=
[
[
TOP_BLUR
'
blur
'
]
[
TOP_CANCEL
'
cancel
'
]
[
TOP_CLICK
'
click
'
]
[
TOP_CLOSE
'
close
'
]
[
TOP_CONTEXT_MENU
'
contextMenu
'
]
[
TOP_COPY
'
copy
'
]
[
TOP_CUT
'
cut
'
]
[
TOP_DOUBLE_CLICK
'
doubleClick
'
]
[
TOP_DRAG_END
'
dragEnd
'
]
[
TOP_DRAG_START
'
dragStart
'
]
[
TOP_DROP
'
drop
'
]
[
TOP_FOCUS
'
focus
'
]
[
TOP_INPUT
'
input
'
]
[
TOP_INVALID
'
invalid
'
]
[
TOP_KEY_DOWN
'
keyDown
'
]
[
TOP_KEY_PRESS
'
keyPress
'
]
[
TOP_KEY_UP
'
keyUp
'
]
[
TOP_MOUSE_DOWN
'
mouseDown
'
]
[
TOP_MOUSE_UP
'
mouseUp
'
]
[
TOP_PASTE
'
paste
'
]
[
TOP_PAUSE
'
pause
'
]
[
TOP_PLAY
'
play
'
]
[
TOP_POINTER_CANCEL
'
pointerCancel
'
]
[
TOP_POINTER_DOWN
'
pointerDown
'
]
[
TOP_POINTER_UP
'
pointerUp
'
]
[
TOP_RATE_CHANGE
'
rateChange
'
]
[
TOP_RESET
'
reset
'
]
[
TOP_SEEKED
'
seeked
'
]
[
TOP_SUBMIT
'
submit
'
]
[
TOP_TOUCH_CANCEL
'
touchCancel
'
]
[
TOP_TOUCH_END
'
touchEnd
'
]
[
TOP_TOUCH_START
'
touchStart
'
]
[
TOP_VOLUME_CHANGE
'
volumeChange
'
]
]
;
var
nonInteractiveEventTypeNames
=
[
[
TOP_ABORT
'
abort
'
]
[
TOP_ANIMATION_END
'
animationEnd
'
]
[
TOP_ANIMATION_ITERATION
'
animationIteration
'
]
[
TOP_ANIMATION_START
'
animationStart
'
]
[
TOP_CAN_PLAY
'
canPlay
'
]
[
TOP_CAN_PLAY_THROUGH
'
canPlayThrough
'
]
[
TOP_DRAG
'
drag
'
]
[
TOP_DRAG_ENTER
'
dragEnter
'
]
[
TOP_DRAG_EXIT
'
dragExit
'
]
[
TOP_DRAG_LEAVE
'
dragLeave
'
]
[
TOP_DRAG_OVER
'
dragOver
'
]
[
TOP_DURATION_CHANGE
'
durationChange
'
]
[
TOP_EMPTIED
'
emptied
'
]
[
TOP_ENCRYPTED
'
encrypted
'
]
[
TOP_ENDED
'
ended
'
]
[
TOP_ERROR
'
error
'
]
[
TOP_GOT_POINTER_CAPTURE
'
gotPointerCapture
'
]
[
TOP_LOAD
'
load
'
]
[
TOP_LOADED_DATA
'
loadedData
'
]
[
TOP_LOADED_METADATA
'
loadedMetadata
'
]
[
TOP_LOAD_START
'
loadStart
'
]
[
TOP_LOST_POINTER_CAPTURE
'
lostPointerCapture
'
]
[
TOP_MOUSE_MOVE
'
mouseMove
'
]
[
TOP_MOUSE_OUT
'
mouseOut
'
]
[
TOP_MOUSE_OVER
'
mouseOver
'
]
[
TOP_PLAYING
'
playing
'
]
[
TOP_POINTER_MOVE
'
pointerMove
'
]
[
TOP_POINTER_OUT
'
pointerOut
'
]
[
TOP_POINTER_OVER
'
pointerOver
'
]
[
TOP_PROGRESS
'
progress
'
]
[
TOP_SCROLL
'
scroll
'
]
[
TOP_SEEKING
'
seeking
'
]
[
TOP_STALLED
'
stalled
'
]
[
TOP_SUSPEND
'
suspend
'
]
[
TOP_TIME_UPDATE
'
timeUpdate
'
]
[
TOP_TOGGLE
'
toggle
'
]
[
TOP_TOUCH_MOVE
'
touchMove
'
]
[
TOP_TRANSITION_END
'
transitionEnd
'
]
[
TOP_WAITING
'
waiting
'
]
[
TOP_WHEEL
'
wheel
'
]
]
;
var
eventTypes
4
=
{
}
;
var
topLevelEventsToDispatchConfig
=
{
}
;
function
addEventTypeNameToConfig
(
_ref
isInteractive
)
{
var
topEvent
=
_ref
[
0
]
event
=
_ref
[
1
]
;
var
capitalizedEvent
=
event
[
0
]
.
toUpperCase
(
)
+
event
.
slice
(
1
)
;
var
onEvent
=
'
on
'
+
capitalizedEvent
;
var
type
=
{
phasedRegistrationNames
:
{
bubbled
:
onEvent
captured
:
onEvent
+
'
Capture
'
}
dependencies
:
[
topEvent
]
isInteractive
:
isInteractive
}
;
eventTypes
4
[
event
]
=
type
;
topLevelEventsToDispatchConfig
[
topEvent
]
=
type
;
}
interactiveEventTypeNames
.
forEach
(
function
(
eventTuple
)
{
addEventTypeNameToConfig
(
eventTuple
true
)
;
}
)
;
nonInteractiveEventTypeNames
.
forEach
(
function
(
eventTuple
)
{
addEventTypeNameToConfig
(
eventTuple
false
)
;
}
)
;
var
SimpleEventPlugin
=
{
eventTypes
:
eventTypes
4
isInteractiveTopLevelEventType
:
function
(
topLevelType
)
{
var
config
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
return
config
!
=
=
undefined
&
&
config
.
isInteractive
=
=
=
true
;
}
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
dispatchConfig
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
if
(
!
dispatchConfig
)
{
return
null
;
}
var
EventConstructor
=
void
0
;
switch
(
topLevelType
)
{
case
TOP_KEY_PRESS
:
if
(
getEventCharCode
(
nativeEvent
)
=
=
=
0
)
{
return
null
;
}
case
TOP_KEY_DOWN
:
case
TOP_KEY_UP
:
EventConstructor
=
SyntheticKeyboardEvent
;
break
;
case
TOP_BLUR
:
case
TOP_FOCUS
:
EventConstructor
=
SyntheticFocusEvent
;
break
;
case
TOP_CLICK
:
if
(
nativeEvent
.
button
=
=
=
2
)
{
return
null
;
}
case
TOP_DOUBLE_CLICK
:
case
TOP_MOUSE_DOWN
:
case
TOP_MOUSE_MOVE
:
case
TOP_MOUSE_UP
:
case
TOP_MOUSE_OUT
:
case
TOP_MOUSE_OVER
:
case
TOP_CONTEXT_MENU
:
EventConstructor
=
SyntheticMouseEvent
;
break
;
case
TOP_DRAG
:
case
TOP_DRAG_END
:
case
TOP_DRAG_ENTER
:
case
TOP_DRAG_EXIT
:
case
TOP_DRAG_LEAVE
:
case
TOP_DRAG_OVER
:
case
TOP_DRAG_START
:
case
TOP_DROP
:
EventConstructor
=
SyntheticDragEvent
;
break
;
case
TOP_TOUCH_CANCEL
:
case
TOP_TOUCH_END
:
case
TOP_TOUCH_MOVE
:
case
TOP_TOUCH_START
:
EventConstructor
=
SyntheticTouchEvent
;
break
;
case
TOP_ANIMATION_END
:
case
TOP_ANIMATION_ITERATION
:
case
TOP_ANIMATION_START
:
EventConstructor
=
SyntheticAnimationEvent
;
break
;
case
TOP_TRANSITION_END
:
EventConstructor
=
SyntheticTransitionEvent
;
break
;
case
TOP_SCROLL
:
EventConstructor
=
SyntheticUIEvent
;
break
;
case
TOP_WHEEL
:
EventConstructor
=
SyntheticWheelEvent
;
break
;
case
TOP_COPY
:
case
TOP_CUT
:
case
TOP_PASTE
:
EventConstructor
=
SyntheticClipboardEvent
;
break
;
case
TOP_GOT_POINTER_CAPTURE
:
case
TOP_LOST_POINTER_CAPTURE
:
case
TOP_POINTER_CANCEL
:
case
TOP_POINTER_DOWN
:
case
TOP_POINTER_MOVE
:
case
TOP_POINTER_OUT
:
case
TOP_POINTER_OVER
:
case
TOP_POINTER_UP
:
EventConstructor
=
SyntheticPointerEvent
;
break
;
default
:
EventConstructor
=
SyntheticEvent
;
break
;
}
var
event
=
EventConstructor
.
getPooled
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
}
;
var
isInteractiveTopLevelEventType
=
SimpleEventPlugin
.
isInteractiveTopLevelEventType
;
var
CALLBACK_BOOKKEEPING_POOL_SIZE
=
10
;
var
callbackBookkeepingPool
=
[
]
;
function
findRootContainerNode
(
inst
)
{
while
(
inst
.
return
)
{
inst
=
inst
.
return
;
}
if
(
inst
.
tag
!
=
=
HostRoot
)
{
return
null
;
}
return
inst
.
stateNode
.
containerInfo
;
}
function
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
)
{
if
(
callbackBookkeepingPool
.
length
)
{
var
instance
=
callbackBookkeepingPool
.
pop
(
)
;
instance
.
topLevelType
=
topLevelType
;
instance
.
nativeEvent
=
nativeEvent
;
instance
.
targetInst
=
targetInst
;
return
instance
;
}
return
{
topLevelType
:
topLevelType
nativeEvent
:
nativeEvent
targetInst
:
targetInst
ancestors
:
[
]
}
;
}
function
releaseTopLevelCallbackBookKeeping
(
instance
)
{
instance
.
topLevelType
=
null
;
instance
.
nativeEvent
=
null
;
instance
.
targetInst
=
null
;
instance
.
ancestors
.
length
=
0
;
if
(
callbackBookkeepingPool
.
length
<
CALLBACK_BOOKKEEPING_POOL_SIZE
)
{
callbackBookkeepingPool
.
push
(
instance
)
;
}
}
function
handleTopLevel
(
bookKeeping
)
{
var
targetInst
=
bookKeeping
.
targetInst
;
var
ancestor
=
targetInst
;
do
{
if
(
!
ancestor
)
{
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
break
;
}
var
root
=
findRootContainerNode
(
ancestor
)
;
if
(
!
root
)
{
break
;
}
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
ancestor
=
getClosestInstanceFromNode
(
root
)
;
}
while
(
ancestor
)
;
for
(
var
i
=
0
;
i
<
bookKeeping
.
ancestors
.
length
;
i
+
+
)
{
targetInst
=
bookKeeping
.
ancestors
[
i
]
;
runExtractedEventsInBatch
(
bookKeeping
.
topLevelType
targetInst
bookKeeping
.
nativeEvent
getEventTarget
(
bookKeeping
.
nativeEvent
)
)
;
}
}
var
_enabled
=
true
;
function
setEnabled
(
enabled
)
{
_enabled
=
!
!
enabled
;
}
function
isEnabled
(
)
{
return
_enabled
;
}
function
trapBubbledEvent
(
topLevelType
element
)
{
if
(
!
element
)
{
return
null
;
}
var
dispatch
=
isInteractiveTopLevelEventType
(
topLevelType
)
?
dispatchInteractiveEvent
:
dispatchEvent
;
addEventBubbleListener
(
element
getRawEventName
(
topLevelType
)
dispatch
.
bind
(
null
topLevelType
)
)
;
}
function
trapCapturedEvent
(
topLevelType
element
)
{
if
(
!
element
)
{
return
null
;
}
var
dispatch
=
isInteractiveTopLevelEventType
(
topLevelType
)
?
dispatchInteractiveEvent
:
dispatchEvent
;
addEventCaptureListener
(
element
getRawEventName
(
topLevelType
)
dispatch
.
bind
(
null
topLevelType
)
)
;
}
function
dispatchInteractiveEvent
(
topLevelType
nativeEvent
)
{
interactiveUpdates
(
dispatchEvent
topLevelType
nativeEvent
)
;
}
function
dispatchEvent
(
topLevelType
nativeEvent
)
{
if
(
!
_enabled
)
{
return
;
}
var
nativeEventTarget
=
getEventTarget
(
nativeEvent
)
;
var
targetInst
=
getClosestInstanceFromNode
(
nativeEventTarget
)
;
if
(
targetInst
!
=
=
null
&
&
typeof
targetInst
.
tag
=
=
=
'
number
'
&
&
!
isFiberMounted
(
targetInst
)
)
{
targetInst
=
null
;
}
var
bookKeeping
=
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
)
;
try
{
batchedUpdates
(
handleTopLevel
bookKeeping
)
;
}
finally
{
releaseTopLevelCallbackBookKeeping
(
bookKeeping
)
;
}
}
var
ReactDOMEventListener
=
(
{
get
_enabled
(
)
{
return
_enabled
;
}
setEnabled
:
setEnabled
isEnabled
:
isEnabled
trapBubbledEvent
:
trapBubbledEvent
trapCapturedEvent
:
trapCapturedEvent
dispatchEvent
:
dispatchEvent
}
)
;
var
alreadyListeningTo
=
{
}
;
var
reactTopListenersCounter
=
0
;
var
topListenersIDKey
=
'
_reactListenersID
'
+
(
'
'
+
Math
.
random
(
)
)
.
slice
(
2
)
;
function
getListeningForDocument
(
mountAt
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
mountAt
topListenersIDKey
)
)
{
mountAt
[
topListenersIDKey
]
=
reactTopListenersCounter
+
+
;
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
=
{
}
;
}
return
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
;
}
function
listenTo
(
registrationName
mountAt
)
{
var
isListening
=
getListeningForDocument
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
(
isListening
.
hasOwnProperty
(
dependency
)
&
&
isListening
[
dependency
]
)
)
{
switch
(
dependency
)
{
case
TOP_SCROLL
:
trapCapturedEvent
(
TOP_SCROLL
mountAt
)
;
break
;
case
TOP_FOCUS
:
case
TOP_BLUR
:
trapCapturedEvent
(
TOP_FOCUS
mountAt
)
;
trapCapturedEvent
(
TOP_BLUR
mountAt
)
;
isListening
[
TOP_BLUR
]
=
true
;
isListening
[
TOP_FOCUS
]
=
true
;
break
;
case
TOP_CANCEL
:
case
TOP_CLOSE
:
if
(
isEventSupported
(
getRawEventName
(
dependency
)
true
)
)
{
trapCapturedEvent
(
dependency
mountAt
)
;
}
break
;
case
TOP_INVALID
:
case
TOP_SUBMIT
:
case
TOP_RESET
:
break
;
default
:
var
isMediaEvent
=
mediaEventTypes
.
indexOf
(
dependency
)
!
=
=
-
1
;
if
(
!
isMediaEvent
)
{
trapBubbledEvent
(
dependency
mountAt
)
;
}
break
;
}
isListening
[
dependency
]
=
true
;
}
}
}
function
isListeningToAllDependencies
(
registrationName
mountAt
)
{
var
isListening
=
getListeningForDocument
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
(
isListening
.
hasOwnProperty
(
dependency
)
&
&
isListening
[
dependency
]
)
)
{
return
false
;
}
}
return
true
;
}
function
isNode
(
object
)
{
var
doc
=
object
?
object
.
ownerDocument
|
|
object
:
document
;
var
defaultView
=
doc
.
defaultView
|
|
window
;
return
!
!
(
object
&
&
(
typeof
defaultView
.
Node
=
=
=
'
function
'
?
object
instanceof
defaultView
.
Node
:
typeof
object
=
=
=
'
object
'
&
&
typeof
object
.
nodeType
=
=
=
'
number
'
&
&
typeof
object
.
nodeName
=
=
=
'
string
'
)
)
;
}
var
isNode_1
=
isNode
;
function
isTextNode
(
object
)
{
return
isNode_1
(
object
)
&
&
object
.
nodeType
=
=
3
;
}
var
isTextNode_1
=
isTextNode
;
function
containsNode
(
outerNode
innerNode
)
{
if
(
!
outerNode
|
|
!
innerNode
)
{
return
false
;
}
else
if
(
outerNode
=
=
=
innerNode
)
{
return
true
;
}
else
if
(
isTextNode_1
(
outerNode
)
)
{
return
false
;
}
else
if
(
isTextNode_1
(
innerNode
)
)
{
return
containsNode
(
outerNode
innerNode
.
parentNode
)
;
}
else
if
(
'
contains
'
in
outerNode
)
{
return
outerNode
.
contains
(
innerNode
)
;
}
else
if
(
outerNode
.
compareDocumentPosition
)
{
return
!
!
(
outerNode
.
compareDocumentPosition
(
innerNode
)
&
16
)
;
}
else
{
return
false
;
}
}
var
containsNode_1
=
containsNode
;
function
getLeafNode
(
node
)
{
while
(
node
&
&
node
.
firstChild
)
{
node
=
node
.
firstChild
;
}
return
node
;
}
function
getSiblingNode
(
node
)
{
while
(
node
)
{
if
(
node
.
nextSibling
)
{
return
node
.
nextSibling
;
}
node
=
node
.
parentNode
;
}
}
function
getNodeForCharacterOffset
(
root
offset
)
{
var
node
=
getLeafNode
(
root
)
;
var
nodeStart
=
0
;
var
nodeEnd
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
nodeEnd
=
nodeStart
+
node
.
textContent
.
length
;
if
(
nodeStart
<
=
offset
&
&
nodeEnd
>
=
offset
)
{
return
{
node
:
node
offset
:
offset
-
nodeStart
}
;
}
nodeStart
=
nodeEnd
;
}
node
=
getLeafNode
(
getSiblingNode
(
node
)
)
;
}
}
function
getOffsets
(
outerNode
)
{
var
selection
=
window
.
getSelection
&
&
window
.
getSelection
(
)
;
if
(
!
selection
|
|
selection
.
rangeCount
=
=
=
0
)
{
return
null
;
}
var
anchorNode
=
selection
.
anchorNode
anchorOffset
=
selection
.
anchorOffset
focusNode
=
selection
.
focusNode
focusOffset
=
selection
.
focusOffset
;
try
{
anchorNode
.
nodeType
;
focusNode
.
nodeType
;
}
catch
(
e
)
{
return
null
;
}
return
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
;
}
function
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
{
var
length
=
0
;
var
start
=
-
1
;
var
end
=
-
1
;
var
indexWithinAnchor
=
0
;
var
indexWithinFocus
=
0
;
var
node
=
outerNode
;
var
parentNode
=
null
;
outer
:
while
(
true
)
{
var
next
=
null
;
while
(
true
)
{
if
(
node
=
=
=
anchorNode
&
&
(
anchorOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
start
=
length
+
anchorOffset
;
}
if
(
node
=
=
=
focusNode
&
&
(
focusOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
end
=
length
+
focusOffset
;
}
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
length
+
=
node
.
nodeValue
.
length
;
}
if
(
(
next
=
node
.
firstChild
)
=
=
=
null
)
{
break
;
}
parentNode
=
node
;
node
=
next
;
}
while
(
true
)
{
if
(
node
=
=
=
outerNode
)
{
break
outer
;
}
if
(
parentNode
=
=
=
anchorNode
&
&
+
+
indexWithinAnchor
=
=
=
anchorOffset
)
{
start
=
length
;
}
if
(
parentNode
=
=
=
focusNode
&
&
+
+
indexWithinFocus
=
=
=
focusOffset
)
{
end
=
length
;
}
if
(
(
next
=
node
.
nextSibling
)
!
=
=
null
)
{
break
;
}
node
=
parentNode
;
parentNode
=
node
.
parentNode
;
}
node
=
next
;
}
if
(
start
=
=
=
-
1
|
|
end
=
=
=
-
1
)
{
return
null
;
}
return
{
start
:
start
end
:
end
}
;
}
function
setOffsets
(
node
offsets
)
{
if
(
!
window
.
getSelection
)
{
return
;
}
var
selection
=
window
.
getSelection
(
)
;
var
length
=
node
[
getTextContentAccessor
(
)
]
.
length
;
var
start
=
Math
.
min
(
offsets
.
start
length
)
;
var
end
=
offsets
.
end
=
=
=
undefined
?
start
:
Math
.
min
(
offsets
.
end
length
)
;
if
(
!
selection
.
extend
&
&
start
>
end
)
{
var
temp
=
end
;
end
=
start
;
start
=
temp
;
}
var
startMarker
=
getNodeForCharacterOffset
(
node
start
)
;
var
endMarker
=
getNodeForCharacterOffset
(
node
end
)
;
if
(
startMarker
&
&
endMarker
)
{
if
(
selection
.
rangeCount
=
=
=
1
&
&
selection
.
anchorNode
=
=
=
startMarker
.
node
&
&
selection
.
anchorOffset
=
=
=
startMarker
.
offset
&
&
selection
.
focusNode
=
=
=
endMarker
.
node
&
&
selection
.
focusOffset
=
=
=
endMarker
.
offset
)
{
return
;
}
var
range
=
document
.
createRange
(
)
;
range
.
setStart
(
startMarker
.
node
startMarker
.
offset
)
;
selection
.
removeAllRanges
(
)
;
if
(
start
>
end
)
{
selection
.
addRange
(
range
)
;
selection
.
extend
(
endMarker
.
node
endMarker
.
offset
)
;
}
else
{
range
.
setEnd
(
endMarker
.
node
endMarker
.
offset
)
;
selection
.
addRange
(
range
)
;
}
}
}
function
isInDocument
(
node
)
{
return
containsNode_1
(
document
.
documentElement
node
)
;
}
function
hasSelectionCapabilities
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
&
&
(
nodeName
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
text
'
|
|
elem
.
type
=
=
=
'
search
'
|
|
elem
.
type
=
=
=
'
tel
'
|
|
elem
.
type
=
=
=
'
url
'
|
|
elem
.
type
=
=
=
'
password
'
)
|
|
nodeName
=
=
=
'
textarea
'
|
|
elem
.
contentEditable
=
=
=
'
true
'
)
;
}
function
getSelectionInformation
(
)
{
var
focusedElem
=
getActiveElement_1
(
)
;
return
{
focusedElem
:
focusedElem
selectionRange
:
hasSelectionCapabilities
(
focusedElem
)
?
getSelection
1
(
focusedElem
)
:
null
}
;
}
function
restoreSelection
(
priorSelectionInformation
)
{
var
curFocusedElem
=
getActiveElement_1
(
)
;
var
priorFocusedElem
=
priorSelectionInformation
.
focusedElem
;
var
priorSelectionRange
=
priorSelectionInformation
.
selectionRange
;
if
(
curFocusedElem
!
=
=
priorFocusedElem
&
&
isInDocument
(
priorFocusedElem
)
)
{
if
(
priorSelectionRange
!
=
=
null
&
&
hasSelectionCapabilities
(
priorFocusedElem
)
)
{
setSelection
(
priorFocusedElem
priorSelectionRange
)
;
}
var
ancestors
=
[
]
;
var
ancestor
=
priorFocusedElem
;
while
(
ancestor
=
ancestor
.
parentNode
)
{
if
(
ancestor
.
nodeType
=
=
=
ELEMENT_NODE
)
{
ancestors
.
push
(
{
element
:
ancestor
left
:
ancestor
.
scrollLeft
top
:
ancestor
.
scrollTop
}
)
;
}
}
if
(
typeof
priorFocusedElem
.
focus
=
=
=
'
function
'
)
{
priorFocusedElem
.
focus
(
)
;
}
for
(
var
i
=
0
;
i
<
ancestors
.
length
;
i
+
+
)
{
var
info
=
ancestors
[
i
]
;
info
.
element
.
scrollLeft
=
info
.
left
;
info
.
element
.
scrollTop
=
info
.
top
;
}
}
}
function
getSelection
1
(
input
)
{
var
selection
=
void
0
;
if
(
'
selectionStart
'
in
input
)
{
selection
=
{
start
:
input
.
selectionStart
end
:
input
.
selectionEnd
}
;
}
else
{
selection
=
getOffsets
(
input
)
;
}
return
selection
|
|
{
start
:
0
end
:
0
}
;
}
function
setSelection
(
input
offsets
)
{
var
start
=
offsets
.
start
end
=
offsets
.
end
;
if
(
end
=
=
=
undefined
)
{
end
=
start
;
}
if
(
'
selectionStart
'
in
input
)
{
input
.
selectionStart
=
start
;
input
.
selectionEnd
=
Math
.
min
(
end
input
.
value
.
length
)
;
}
else
{
setOffsets
(
input
offsets
)
;
}
}
var
skipSelectionChangeEvent
=
ExecutionEnvironment_1
.
canUseDOM
&
&
'
documentMode
'
in
document
&
&
document
.
documentMode
<
=
11
;
var
eventTypes
3
=
{
select
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onSelect
'
captured
:
'
onSelectCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_CONTEXT_MENU
TOP_FOCUS
TOP_KEY_DOWN
TOP_KEY_UP
TOP_MOUSE_DOWN
TOP_MOUSE_UP
TOP_SELECTION_CHANGE
]
}
}
;
var
activeElement
1
=
null
;
var
activeElementInst
1
=
null
;
var
lastSelection
=
null
;
var
mouseDown
=
false
;
function
getSelection
(
node
)
{
if
(
'
selectionStart
'
in
node
&
&
hasSelectionCapabilities
(
node
)
)
{
return
{
start
:
node
.
selectionStart
end
:
node
.
selectionEnd
}
;
}
else
if
(
window
.
getSelection
)
{
var
selection
=
window
.
getSelection
(
)
;
return
{
anchorNode
:
selection
.
anchorNode
anchorOffset
:
selection
.
anchorOffset
focusNode
:
selection
.
focusNode
focusOffset
:
selection
.
focusOffset
}
;
}
}
function
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
{
if
(
mouseDown
|
|
activeElement
1
=
=
null
|
|
activeElement
1
!
=
=
getActiveElement_1
(
)
)
{
return
null
;
}
var
currentSelection
=
getSelection
(
activeElement
1
)
;
if
(
!
lastSelection
|
|
!
shallowEqual_1
(
lastSelection
currentSelection
)
)
{
lastSelection
=
currentSelection
;
var
syntheticEvent
=
SyntheticEvent
.
getPooled
(
eventTypes
3
.
select
activeElementInst
1
nativeEvent
nativeEventTarget
)
;
syntheticEvent
.
type
=
'
select
'
;
syntheticEvent
.
target
=
activeElement
1
;
accumulateTwoPhaseDispatches
(
syntheticEvent
)
;
return
syntheticEvent
;
}
return
null
;
}
var
SelectEventPlugin
=
{
eventTypes
:
eventTypes
3
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
doc
=
nativeEventTarget
.
window
=
=
=
nativeEventTarget
?
nativeEventTarget
.
document
:
nativeEventTarget
.
nodeType
=
=
=
DOCUMENT_NODE
?
nativeEventTarget
:
nativeEventTarget
.
ownerDocument
;
if
(
!
doc
|
|
!
isListeningToAllDependencies
(
'
onSelect
'
doc
)
)
{
return
null
;
}
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
switch
(
topLevelType
)
{
case
TOP_FOCUS
:
if
(
isTextInputElement
(
targetNode
)
|
|
targetNode
.
contentEditable
=
=
=
'
true
'
)
{
activeElement
1
=
targetNode
;
activeElementInst
1
=
targetInst
;
lastSelection
=
null
;
}
break
;
case
TOP_BLUR
:
activeElement
1
=
null
;
activeElementInst
1
=
null
;
lastSelection
=
null
;
break
;
case
TOP_MOUSE_DOWN
:
mouseDown
=
true
;
break
;
case
TOP_CONTEXT_MENU
:
case
TOP_MOUSE_UP
:
mouseDown
=
false
;
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
case
TOP_SELECTION_CHANGE
:
if
(
skipSelectionChangeEvent
)
{
break
;
}
case
TOP_KEY_DOWN
:
case
TOP_KEY_UP
:
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
}
return
null
;
}
}
;
injection
.
injectEventPluginOrder
(
DOMEventPluginOrder
)
;
injection
1
.
injectComponentTree
(
ReactDOMComponentTree
)
;
injection
.
injectEventPluginsByName
(
{
SimpleEventPlugin
:
SimpleEventPlugin
EnterLeaveEventPlugin
:
EnterLeaveEventPlugin
ChangeEventPlugin
:
ChangeEventPlugin
SelectEventPlugin
:
SelectEventPlugin
BeforeInputEventPlugin
:
BeforeInputEventPlugin
}
)
;
var
emptyObject
=
{
}
;
var
emptyObject_1
=
emptyObject
;
var
localRequestAnimationFrame
1
=
typeof
requestAnimationFrame
=
=
=
'
function
'
?
requestAnimationFrame
:
undefined
;
var
localDate
=
Date
;
var
localSetTimeout
=
setTimeout
;
var
localClearTimeout
=
clearTimeout
;
var
hasNativePerformanceNow
=
typeof
performance
=
=
=
'
object
'
&
&
typeof
performance
.
now
=
=
=
'
function
'
;
var
now
1
=
void
0
;
if
(
hasNativePerformanceNow
)
{
var
Performance
=
performance
;
now
1
=
function
(
)
{
return
Performance
.
now
(
)
;
}
;
}
else
{
now
1
=
function
(
)
{
return
localDate
.
now
(
)
;
}
;
}
var
scheduleWork
=
void
0
;
var
cancelScheduledWork
=
void
0
;
if
(
!
ExecutionEnvironment_1
.
canUseDOM
)
{
var
timeoutIds
=
new
Map
(
)
;
scheduleWork
=
function
(
callback
options
)
{
var
callbackConfig
=
{
scheduledCallback
:
callback
timeoutTime
:
0
next
:
null
prev
:
null
}
;
var
timeoutId
=
localSetTimeout
(
function
(
)
{
callback
(
{
timeRemaining
:
function
(
)
{
return
Infinity
;
}
didTimeout
:
false
}
)
;
}
)
;
timeoutIds
.
set
(
callback
timeoutId
)
;
return
callbackConfig
;
}
;
cancelScheduledWork
=
function
(
callbackId
)
{
var
callback
=
callbackId
.
scheduledCallback
;
var
timeoutId
=
timeoutIds
.
get
(
callback
)
;
timeoutIds
.
delete
(
callbackId
)
;
localClearTimeout
(
timeoutId
)
;
}
;
}
else
{
var
localRequestAnimationFrame
=
typeof
localRequestAnimationFrame
1
=
=
=
'
function
'
?
localRequestAnimationFrame
1
:
function
(
callback
)
{
reactProdInvariant
(
'
276
'
)
;
}
;
var
headOfPendingCallbacksLinkedList
=
null
;
var
tailOfPendingCallbacksLinkedList
=
null
;
var
nextSoonestTimeoutTime
=
-
1
;
var
isIdleScheduled
=
false
;
var
isAnimationFrameScheduled
=
false
;
var
frameDeadline
=
0
;
var
previousFrameTime
=
33
;
var
activeFrameTime
=
33
;
var
frameDeadlineObject
=
{
didTimeout
:
false
timeRemaining
:
function
(
)
{
var
remaining
=
frameDeadline
-
now
1
(
)
;
return
remaining
>
0
?
remaining
:
0
;
}
}
;
var
callUnsafely
=
function
(
callbackConfig
arg
)
{
var
callback
=
callbackConfig
.
scheduledCallback
;
var
finishedCalling
=
false
;
try
{
callback
(
arg
)
;
finishedCalling
=
true
;
}
finally
{
cancelScheduledWork
(
callbackConfig
)
;
if
(
!
finishedCalling
)
{
isIdleScheduled
=
true
;
window
.
postMessage
(
messageKey
'
*
'
)
;
}
}
}
;
var
callTimedOutCallbacks
=
function
(
)
{
if
(
headOfPendingCallbacksLinkedList
=
=
=
null
)
{
return
;
}
var
currentTime
=
now
1
(
)
;
if
(
nextSoonestTimeoutTime
=
=
=
-
1
|
|
nextSoonestTimeoutTime
>
currentTime
)
{
return
;
}
var
updatedNextSoonestTimeoutTime
=
-
1
;
var
timedOutCallbacks
=
[
]
;
var
currentCallbackConfig
=
headOfPendingCallbacksLinkedList
;
while
(
currentCallbackConfig
!
=
=
null
)
{
var
_timeoutTime
=
currentCallbackConfig
.
timeoutTime
;
if
(
_timeoutTime
!
=
=
-
1
&
&
_timeoutTime
<
=
currentTime
)
{
timedOutCallbacks
.
push
(
currentCallbackConfig
)
;
}
else
{
if
(
_timeoutTime
!
=
=
-
1
&
&
(
updatedNextSoonestTimeoutTime
=
=
=
-
1
|
|
_timeoutTime
<
updatedNextSoonestTimeoutTime
)
)
{
updatedNextSoonestTimeoutTime
=
_timeoutTime
;
}
}
currentCallbackConfig
=
currentCallbackConfig
.
next
;
}
if
(
timedOutCallbacks
.
length
>
0
)
{
frameDeadlineObject
.
didTimeout
=
true
;
for
(
var
i
=
0
len
=
timedOutCallbacks
.
length
;
i
<
len
;
i
+
+
)
{
callUnsafely
(
timedOutCallbacks
[
i
]
frameDeadlineObject
)
;
}
}
nextSoonestTimeoutTime
=
updatedNextSoonestTimeoutTime
;
}
;
var
messageKey
=
'
__reactIdleCallback
'
+
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
var
idleTick
=
function
(
event
)
{
if
(
event
.
source
!
=
=
window
|
|
event
.
data
!
=
=
messageKey
)
{
return
;
}
isIdleScheduled
=
false
;
if
(
headOfPendingCallbacksLinkedList
=
=
=
null
)
{
return
;
}
callTimedOutCallbacks
(
)
;
var
currentTime
=
now
1
(
)
;
while
(
frameDeadline
-
currentTime
>
0
&
&
headOfPendingCallbacksLinkedList
!
=
=
null
)
{
var
latestCallbackConfig
=
headOfPendingCallbacksLinkedList
;
frameDeadlineObject
.
didTimeout
=
false
;
callUnsafely
(
latestCallbackConfig
frameDeadlineObject
)
;
currentTime
=
now
1
(
)
;
}
if
(
headOfPendingCallbacksLinkedList
!
=
=
null
)
{
if
(
!
isAnimationFrameScheduled
)
{
isAnimationFrameScheduled
=
true
;
localRequestAnimationFrame
(
animationTick
)
;
}
}
}
;
window
.
addEventListener
(
'
message
'
idleTick
false
)
;
var
animationTick
=
function
(
rafTime
)
{
isAnimationFrameScheduled
=
false
;
var
nextFrameTime
=
rafTime
-
frameDeadline
+
activeFrameTime
;
if
(
nextFrameTime
<
activeFrameTime
&
&
previousFrameTime
<
activeFrameTime
)
{
if
(
nextFrameTime
<
8
)
{
nextFrameTime
=
8
;
}
activeFrameTime
=
nextFrameTime
<
previousFrameTime
?
previousFrameTime
:
nextFrameTime
;
}
else
{
previousFrameTime
=
nextFrameTime
;
}
frameDeadline
=
rafTime
+
activeFrameTime
;
if
(
!
isIdleScheduled
)
{
isIdleScheduled
=
true
;
window
.
postMessage
(
messageKey
'
*
'
)
;
}
}
;
scheduleWork
=
function
(
callback
options
)
{
var
timeoutTime
=
-
1
;
if
(
options
!
=
null
&
&
typeof
options
.
timeout
=
=
=
'
number
'
)
{
timeoutTime
=
now
1
(
)
+
options
.
timeout
;
}
if
(
nextSoonestTimeoutTime
=
=
=
-
1
|
|
timeoutTime
!
=
=
-
1
&
&
timeoutTime
<
nextSoonestTimeoutTime
)
{
nextSoonestTimeoutTime
=
timeoutTime
;
}
var
scheduledCallbackConfig
=
{
scheduledCallback
:
callback
timeoutTime
:
timeoutTime
prev
:
null
next
:
null
}
;
if
(
headOfPendingCallbacksLinkedList
=
=
=
null
)
{
headOfPendingCallbacksLinkedList
=
scheduledCallbackConfig
;
tailOfPendingCallbacksLinkedList
=
scheduledCallbackConfig
;
}
else
{
scheduledCallbackConfig
.
prev
=
tailOfPendingCallbacksLinkedList
;
var
oldTailOfPendingCallbacksLinkedList
=
tailOfPendingCallbacksLinkedList
;
if
(
oldTailOfPendingCallbacksLinkedList
!
=
=
null
)
{
oldTailOfPendingCallbacksLinkedList
.
next
=
scheduledCallbackConfig
;
}
tailOfPendingCallbacksLinkedList
=
scheduledCallbackConfig
;
}
if
(
!
isAnimationFrameScheduled
)
{
isAnimationFrameScheduled
=
true
;
localRequestAnimationFrame
(
animationTick
)
;
}
return
scheduledCallbackConfig
;
}
;
cancelScheduledWork
=
function
(
callbackConfig
)
{
if
(
callbackConfig
.
prev
=
=
=
null
&
&
headOfPendingCallbacksLinkedList
!
=
=
callbackConfig
)
{
return
;
}
var
next
=
callbackConfig
.
next
;
var
prev
=
callbackConfig
.
prev
;
callbackConfig
.
next
=
null
;
callbackConfig
.
prev
=
null
;
if
(
next
!
=
=
null
)
{
if
(
prev
!
=
=
null
)
{
prev
.
next
=
next
;
next
.
prev
=
prev
;
return
;
}
else
{
next
.
prev
=
null
;
headOfPendingCallbacksLinkedList
=
next
;
return
;
}
}
else
{
if
(
prev
!
=
=
null
)
{
prev
.
next
=
null
;
tailOfPendingCallbacksLinkedList
=
prev
;
return
;
}
else
{
headOfPendingCallbacksLinkedList
=
null
;
tailOfPendingCallbacksLinkedList
=
null
;
return
;
}
}
}
;
}
function
flattenChildren
(
children
)
{
var
content
=
'
'
;
React
.
Children
.
forEach
(
children
function
(
child
)
{
if
(
child
=
=
null
)
{
return
;
}
if
(
typeof
child
=
=
=
'
string
'
|
|
typeof
child
=
=
=
'
number
'
)
{
content
+
=
child
;
}
}
)
;
return
content
;
}
function
postMountWrapper
1
(
element
props
)
{
if
(
props
.
value
!
=
null
)
{
element
.
setAttribute
(
'
value
'
props
.
value
)
;
}
}
function
getHostProps
1
(
element
props
)
{
var
hostProps
=
_assign
(
{
children
:
undefined
}
props
)
;
var
content
=
flattenChildren
(
props
.
children
)
;
if
(
content
)
{
hostProps
.
children
=
content
;
}
return
hostProps
;
}
function
updateOptions
(
node
multiple
propValue
setDefaultSelected
)
{
var
options
=
node
.
options
;
if
(
multiple
)
{
var
selectedValues
=
propValue
;
var
selectedValue
=
{
}
;
for
(
var
i
=
0
;
i
<
selectedValues
.
length
;
i
+
+
)
{
selectedValue
[
'
'
+
selectedValues
[
i
]
]
=
true
;
}
for
(
var
_i
=
0
;
_i
<
options
.
length
;
_i
+
+
)
{
var
selected
=
selectedValue
.
hasOwnProperty
(
'
'
+
options
[
_i
]
.
value
)
;
if
(
options
[
_i
]
.
selected
!
=
=
selected
)
{
options
[
_i
]
.
selected
=
selected
;
}
if
(
selected
&
&
setDefaultSelected
)
{
options
[
_i
]
.
defaultSelected
=
true
;
}
}
}
else
{
var
_selectedValue
=
'
'
+
propValue
;
var
defaultSelected
=
null
;
for
(
var
_i2
=
0
;
_i2
<
options
.
length
;
_i2
+
+
)
{
if
(
options
[
_i2
]
.
value
=
=
=
_selectedValue
)
{
options
[
_i2
]
.
selected
=
true
;
if
(
setDefaultSelected
)
{
options
[
_i2
]
.
defaultSelected
=
true
;
}
return
;
}
if
(
defaultSelected
=
=
=
null
&
&
!
options
[
_i2
]
.
disabled
)
{
defaultSelected
=
options
[
_i2
]
;
}
}
if
(
defaultSelected
!
=
=
null
)
{
defaultSelected
.
selected
=
true
;
}
}
}
function
getHostProps
2
(
element
props
)
{
return
_assign
(
{
}
props
{
value
:
undefined
}
)
;
}
function
initWrapperState
1
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
node
.
_wrapperState
=
{
initialValue
:
value
!
=
null
?
value
:
props
.
defaultValue
wasMultiple
:
!
!
props
.
multiple
}
;
}
function
postMountWrapper
2
(
element
props
)
{
var
node
=
element
;
node
.
multiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
}
function
postUpdateWrapper
(
element
props
)
{
var
node
=
element
;
node
.
_wrapperState
.
initialValue
=
undefined
;
var
wasMultiple
=
node
.
_wrapperState
.
wasMultiple
;
node
.
_wrapperState
.
wasMultiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
wasMultiple
!
=
=
!
!
props
.
multiple
)
{
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
else
{
updateOptions
(
node
!
!
props
.
multiple
props
.
multiple
?
[
]
:
'
'
false
)
;
}
}
}
function
restoreControlledState
2
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
}
function
getHostProps
3
(
element
props
)
{
var
node
=
element
;
!
(
props
.
dangerouslySetInnerHTML
=
=
null
)
?
reactProdInvariant
(
'
91
'
)
:
void
0
;
var
hostProps
=
_assign
(
{
}
props
{
value
:
undefined
defaultValue
:
undefined
children
:
'
'
+
node
.
_wrapperState
.
initialValue
}
)
;
return
hostProps
;
}
function
initWrapperState
2
(
element
props
)
{
var
node
=
element
;
var
initialValue
=
props
.
value
;
if
(
initialValue
=
=
null
)
{
var
defaultValue
=
props
.
defaultValue
;
var
children
=
props
.
children
;
if
(
children
!
=
null
)
{
!
(
defaultValue
=
=
null
)
?
reactProdInvariant
(
'
92
'
)
:
void
0
;
if
(
Array
.
isArray
(
children
)
)
{
!
(
children
.
length
<
=
1
)
?
reactProdInvariant
(
'
93
'
)
:
void
0
;
children
=
children
[
0
]
;
}
defaultValue
=
'
'
+
children
;
}
if
(
defaultValue
=
=
null
)
{
defaultValue
=
'
'
;
}
initialValue
=
defaultValue
;
}
node
.
_wrapperState
=
{
initialValue
:
'
'
+
initialValue
}
;
}
function
updateWrapper
1
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
var
newValue
=
'
'
+
value
;
if
(
newValue
!
=
=
node
.
value
)
{
node
.
value
=
newValue
;
}
if
(
props
.
defaultValue
=
=
null
)
{
node
.
defaultValue
=
newValue
;
}
}
if
(
props
.
defaultValue
!
=
null
)
{
node
.
defaultValue
=
props
.
defaultValue
;
}
}
function
postMountWrapper
3
(
element
props
)
{
var
node
=
element
;
var
textContent
=
node
.
textContent
;
if
(
textContent
=
=
=
node
.
_wrapperState
.
initialValue
)
{
node
.
value
=
textContent
;
}
}
function
restoreControlledState
3
(
element
props
)
{
updateWrapper
1
(
element
props
)
;
}
var
HTML_NAMESPACE
1
=
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
;
var
MATH_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
'
;
var
SVG_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
var
Namespaces
=
{
html
:
HTML_NAMESPACE
1
mathml
:
MATH_NAMESPACE
svg
:
SVG_NAMESPACE
}
;
function
getIntrinsicNamespace
(
type
)
{
switch
(
type
)
{
case
'
svg
'
:
return
SVG_NAMESPACE
;
case
'
math
'
:
return
MATH_NAMESPACE
;
default
:
return
HTML_NAMESPACE
1
;
}
}
function
getChildNamespace
(
parentNamespace
type
)
{
if
(
parentNamespace
=
=
null
|
|
parentNamespace
=
=
=
HTML_NAMESPACE
1
)
{
return
getIntrinsicNamespace
(
type
)
;
}
if
(
parentNamespace
=
=
=
SVG_NAMESPACE
&
&
type
=
=
=
'
foreignObject
'
)
{
return
HTML_NAMESPACE
1
;
}
return
parentNamespace
;
}
var
createMicrosoftUnsafeLocalFunction
=
function
(
func
)
{
if
(
typeof
MSApp
!
=
=
'
undefined
'
&
&
MSApp
.
execUnsafeLocalFunction
)
{
return
function
(
arg0
arg1
arg2
arg3
)
{
MSApp
.
execUnsafeLocalFunction
(
function
(
)
{
return
func
(
arg0
arg1
arg2
arg3
)
;
}
)
;
}
;
}
else
{
return
func
;
}
}
;
var
reusableSVGContainer
=
void
0
;
var
setInnerHTML
=
createMicrosoftUnsafeLocalFunction
(
function
(
node
html
)
{
if
(
node
.
namespaceURI
=
=
=
Namespaces
.
svg
&
&
!
(
'
innerHTML
'
in
node
)
)
{
reusableSVGContainer
=
reusableSVGContainer
|
|
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
reusableSVGContainer
.
innerHTML
=
'
<
svg
>
'
+
html
+
'
<
/
svg
>
'
;
var
svgNode
=
reusableSVGContainer
.
firstChild
;
while
(
node
.
firstChild
)
{
node
.
removeChild
(
node
.
firstChild
)
;
}
while
(
svgNode
.
firstChild
)
{
node
.
appendChild
(
svgNode
.
firstChild
)
;
}
}
else
{
node
.
innerHTML
=
html
;
}
}
)
;
var
setTextContent
=
function
(
node
text
)
{
if
(
text
)
{
var
firstChild
=
node
.
firstChild
;
if
(
firstChild
&
&
firstChild
=
=
=
node
.
lastChild
&
&
firstChild
.
nodeType
=
=
=
TEXT_NODE
)
{
firstChild
.
nodeValue
=
text
;
return
;
}
}
node
.
textContent
=
text
;
}
;
var
isUnitlessNumber
=
{
animationIterationCount
:
true
borderImageOutset
:
true
borderImageSlice
:
true
borderImageWidth
:
true
boxFlex
:
true
boxFlexGroup
:
true
boxOrdinalGroup
:
true
columnCount
:
true
columns
:
true
flex
:
true
flexGrow
:
true
flexPositive
:
true
flexShrink
:
true
flexNegative
:
true
flexOrder
:
true
gridRow
:
true
gridRowEnd
:
true
gridRowSpan
:
true
gridRowStart
:
true
gridColumn
:
true
gridColumnEnd
:
true
gridColumnSpan
:
true
gridColumnStart
:
true
fontWeight
:
true
lineClamp
:
true
lineHeight
:
true
opacity
:
true
order
:
true
orphans
:
true
tabSize
:
true
widows
:
true
zIndex
:
true
zoom
:
true
fillOpacity
:
true
floodOpacity
:
true
stopOpacity
:
true
strokeDasharray
:
true
strokeDashoffset
:
true
strokeMiterlimit
:
true
strokeOpacity
:
true
strokeWidth
:
true
}
;
function
prefixKey
(
prefix
key
)
{
return
prefix
+
key
.
charAt
(
0
)
.
toUpperCase
(
)
+
key
.
substring
(
1
)
;
}
var
prefixes
=
[
'
Webkit
'
'
ms
'
'
Moz
'
'
O
'
]
;
Object
.
keys
(
isUnitlessNumber
)
.
forEach
(
function
(
prop
)
{
prefixes
.
forEach
(
function
(
prefix
)
{
isUnitlessNumber
[
prefixKey
(
prefix
prop
)
]
=
isUnitlessNumber
[
prop
]
;
}
)
;
}
)
;
function
dangerousStyleValue
(
name
value
isCustomProperty
)
{
var
isEmpty
=
value
=
=
null
|
|
typeof
value
=
=
=
'
boolean
'
|
|
value
=
=
=
'
'
;
if
(
isEmpty
)
{
return
'
'
;
}
if
(
!
isCustomProperty
&
&
typeof
value
=
=
=
'
number
'
&
&
value
!
=
=
0
&
&
!
(
isUnitlessNumber
.
hasOwnProperty
(
name
)
&
&
isUnitlessNumber
[
name
]
)
)
{
return
value
+
'
px
'
;
}
return
(
'
'
+
value
)
.
trim
(
)
;
}
function
setValueForStyles
(
node
styles
getStack
)
{
var
style
=
node
.
style
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
isCustomProperty
=
styleName
.
indexOf
(
'
-
-
'
)
=
=
=
0
;
var
styleValue
=
dangerousStyleValue
(
styleName
styles
[
styleName
]
isCustomProperty
)
;
if
(
styleName
=
=
=
'
float
'
)
{
styleName
=
'
cssFloat
'
;
}
if
(
isCustomProperty
)
{
style
.
setProperty
(
styleName
styleValue
)
;
}
else
{
style
[
styleName
]
=
styleValue
;
}
}
}
var
omittedCloseTags
=
{
area
:
true
base
:
true
br
:
true
col
:
true
embed
:
true
hr
:
true
img
:
true
input
:
true
keygen
:
true
link
:
true
meta
:
true
param
:
true
source
:
true
track
:
true
wbr
:
true
}
;
var
voidElementTags
=
_assign
(
{
menuitem
:
true
}
omittedCloseTags
)
;
var
HTML
1
=
'
__html
'
;
function
assertValidProps
(
tag
props
getStack
)
{
if
(
!
props
)
{
return
;
}
if
(
voidElementTags
[
tag
]
)
{
!
(
props
.
children
=
=
null
&
&
props
.
dangerouslySetInnerHTML
=
=
null
)
?
reactProdInvariant
(
'
137
'
tag
getStack
(
)
)
:
void
0
;
}
if
(
props
.
dangerouslySetInnerHTML
!
=
null
)
{
!
(
props
.
children
=
=
null
)
?
reactProdInvariant
(
'
60
'
)
:
void
0
;
!
(
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
HTML
1
in
props
.
dangerouslySetInnerHTML
)
?
reactProdInvariant
(
'
61
'
)
:
void
0
;
}
!
(
props
.
style
=
=
null
|
|
typeof
props
.
style
=
=
=
'
object
'
)
?
reactProdInvariant
(
'
62
'
getStack
(
)
)
:
void
0
;
}
function
isCustomComponent
(
tagName
props
)
{
if
(
tagName
.
indexOf
(
'
-
'
)
=
=
=
-
1
)
{
return
typeof
props
.
is
=
=
=
'
string
'
;
}
switch
(
tagName
)
{
case
'
annotation
-
xml
'
:
case
'
color
-
profile
'
:
case
'
font
-
face
'
:
case
'
font
-
face
-
src
'
:
case
'
font
-
face
-
uri
'
:
case
'
font
-
face
-
format
'
:
case
'
font
-
face
-
name
'
:
case
'
missing
-
glyph
'
:
return
false
;
default
:
return
true
;
}
}
var
DANGEROUSLY_SET_INNER_HTML
=
'
dangerouslySetInnerHTML
'
;
var
SUPPRESS_CONTENT_EDITABLE_WARNING
=
'
suppressContentEditableWarning
'
;
var
SUPPRESS_HYDRATION_WARNING
1
=
'
suppressHydrationWarning
'
;
var
AUTOFOCUS
=
'
autoFocus
'
;
var
CHILDREN
=
'
children
'
;
var
STYLE
=
'
style
'
;
var
HTML
=
'
__html
'
;
var
HTML_NAMESPACE
=
Namespaces
.
html
;
var
getStack
=
emptyFunction_1
.
thatReturns
(
'
'
)
;
function
ensureListeningTo
(
rootContainerElement
registrationName
)
{
var
isDocumentOrFragment
=
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
;
var
doc
=
isDocumentOrFragment
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
listenTo
(
registrationName
doc
)
;
}
function
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
{
return
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
}
function
trapClickOnNonInteractiveElement
(
node
)
{
node
.
onclick
=
emptyFunction_1
;
}
function
setInitialDOMProperties
(
tag
domElement
rootContainerElement
nextProps
isCustomComponentTag
)
{
for
(
var
propKey
in
nextProps
)
{
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
nextProps
[
propKey
]
;
if
(
propKey
=
=
=
STYLE
)
{
setValueForStyles
(
domElement
nextProp
getStack
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
setInnerHTML
(
domElement
nextHtml
)
;
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
var
canSetTextContent
=
tag
!
=
=
'
textarea
'
|
|
nextProp
!
=
=
'
'
;
if
(
canSetTextContent
)
{
setTextContent
(
domElement
nextProp
)
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
setTextContent
(
domElement
'
'
+
nextProp
)
;
}
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
if
(
nextProp
!
=
null
)
{
setValueForProperty
(
domElement
propKey
nextProp
isCustomComponentTag
)
;
}
}
}
function
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
{
for
(
var
i
=
0
;
i
<
updatePayload
.
length
;
i
+
=
2
)
{
var
propKey
=
updatePayload
[
i
]
;
var
propValue
=
updatePayload
[
i
+
1
]
;
if
(
propKey
=
=
=
STYLE
)
{
setValueForStyles
(
domElement
propValue
getStack
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
setInnerHTML
(
domElement
propValue
)
;
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
setTextContent
(
domElement
propValue
)
;
}
else
{
setValueForProperty
(
domElement
propKey
propValue
isCustomComponentTag
)
;
}
}
}
function
createElement
1
(
type
props
rootContainerElement
parentNamespace
)
{
var
ownerDocument
=
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
;
var
domElement
=
void
0
;
var
namespaceURI
=
parentNamespace
;
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
namespaceURI
=
getIntrinsicNamespace
(
type
)
;
}
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
if
(
type
=
=
=
'
script
'
)
{
var
div
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
div
.
innerHTML
=
'
<
script
>
<
'
+
'
/
script
>
'
;
var
firstChild
=
div
.
firstChild
;
domElement
=
div
.
removeChild
(
firstChild
)
;
}
else
if
(
typeof
props
.
is
=
=
=
'
string
'
)
{
domElement
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
type
{
is
:
props
.
is
}
)
;
}
else
{
domElement
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
type
)
;
}
}
else
{
domElement
=
ownerDocument
.
createElementNS
(
namespaceURI
type
)
;
}
return
domElement
;
}
function
createTextNode
1
(
text
rootContainerElement
)
{
return
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
.
createTextNode
(
text
)
;
}
function
setInitialProperties
1
(
domElement
tag
rawProps
rootContainerElement
)
{
var
isCustomComponentTag
=
isCustomComponent
(
tag
rawProps
)
;
var
props
=
void
0
;
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
props
=
rawProps
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
i
=
0
;
i
<
mediaEventTypes
.
length
;
i
+
+
)
{
trapBubbledEvent
(
mediaEventTypes
[
i
]
domElement
)
;
}
props
=
rawProps
;
break
;
case
'
source
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
props
=
rawProps
;
break
;
case
'
img
'
:
case
'
image
'
:
case
'
link
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
props
=
rawProps
;
break
;
case
'
form
'
:
trapBubbledEvent
(
TOP_RESET
domElement
)
;
trapBubbledEvent
(
TOP_SUBMIT
domElement
)
;
props
=
rawProps
;
break
;
case
'
details
'
:
trapBubbledEvent
(
TOP_TOGGLE
domElement
)
;
props
=
rawProps
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
props
=
getHostProps
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
props
=
getHostProps
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
props
=
getHostProps
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
props
=
getHostProps
3
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
default
:
props
=
rawProps
;
}
assertValidProps
(
tag
props
getStack
)
;
setInitialDOMProperties
(
tag
domElement
rootContainerElement
props
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
false
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
option
'
:
postMountWrapper
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
postMountWrapper
2
(
domElement
rawProps
)
;
break
;
default
:
if
(
typeof
props
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
}
function
diffProperties
1
(
domElement
tag
lastRawProps
nextRawProps
rootContainerElement
)
{
var
updatePayload
=
null
;
var
lastProps
=
void
0
;
var
nextProps
=
void
0
;
switch
(
tag
)
{
case
'
input
'
:
lastProps
=
getHostProps
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
option
'
:
lastProps
=
getHostProps
1
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
1
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
select
'
:
lastProps
=
getHostProps
2
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
2
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
textarea
'
:
lastProps
=
getHostProps
3
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
3
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
default
:
lastProps
=
lastRawProps
;
nextProps
=
nextRawProps
;
if
(
typeof
lastProps
.
onClick
!
=
=
'
function
'
&
&
typeof
nextProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
assertValidProps
(
tag
nextProps
getStack
)
;
var
propKey
=
void
0
;
var
styleName
=
void
0
;
var
styleUpdates
=
null
;
for
(
propKey
in
lastProps
)
{
if
(
nextProps
.
hasOwnProperty
(
propKey
)
|
|
!
lastProps
.
hasOwnProperty
(
propKey
)
|
|
lastProps
[
propKey
]
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
var
lastStyle
=
lastProps
[
propKey
]
;
for
(
styleName
in
lastStyle
)
{
if
(
lastStyle
.
hasOwnProperty
(
styleName
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
|
|
propKey
=
=
=
CHILDREN
)
{
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
null
)
;
}
}
for
(
propKey
in
nextProps
)
{
var
nextProp
=
nextProps
[
propKey
]
;
var
lastProp
=
lastProps
!
=
null
?
lastProps
[
propKey
]
:
undefined
;
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
|
|
nextProp
=
=
=
lastProp
|
|
nextProp
=
=
null
&
&
lastProp
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
if
(
lastProp
)
{
for
(
styleName
in
lastProp
)
{
if
(
lastProp
.
hasOwnProperty
(
styleName
)
&
&
(
!
nextProp
|
|
!
nextProp
.
hasOwnProperty
(
styleName
)
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
for
(
styleName
in
nextProp
)
{
if
(
nextProp
.
hasOwnProperty
(
styleName
)
&
&
lastProp
[
styleName
]
!
=
=
nextProp
[
styleName
]
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
nextProp
[
styleName
]
;
}
}
}
else
{
if
(
!
styleUpdates
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
updatePayload
.
push
(
propKey
styleUpdates
)
;
}
styleUpdates
=
nextProp
;
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
var
lastHtml
=
lastProp
?
lastProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
if
(
lastHtml
!
=
=
nextHtml
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
'
'
+
nextHtml
)
;
}
}
else
{
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
lastProp
!
=
=
nextProp
&
&
(
typeof
nextProp
=
=
=
'
string
'
|
|
typeof
nextProp
=
=
=
'
number
'
)
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
'
'
+
nextProp
)
;
}
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
if
(
!
updatePayload
&
&
lastProp
!
=
=
nextProp
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
nextProp
)
;
}
}
if
(
styleUpdates
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
STYLE
styleUpdates
)
;
}
return
updatePayload
;
}
function
updateProperties
1
(
domElement
updatePayload
tag
lastRawProps
nextRawProps
)
{
if
(
tag
=
=
=
'
input
'
&
&
nextRawProps
.
type
=
=
=
'
radio
'
&
&
nextRawProps
.
name
!
=
null
)
{
updateChecked
(
domElement
nextRawProps
)
;
}
var
wasCustomComponentTag
=
isCustomComponent
(
tag
lastRawProps
)
;
var
isCustomComponentTag
=
isCustomComponent
(
tag
nextRawProps
)
;
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
updateWrapper
(
domElement
nextRawProps
)
;
break
;
case
'
textarea
'
:
updateWrapper
1
(
domElement
nextRawProps
)
;
break
;
case
'
select
'
:
postUpdateWrapper
(
domElement
nextRawProps
)
;
break
;
}
}
function
diffHydratedProperties
1
(
domElement
tag
rawProps
parentNamespace
rootContainerElement
)
{
var
isCustomComponentTag
=
void
0
;
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
i
=
0
;
i
<
mediaEventTypes
.
length
;
i
+
+
)
{
trapBubbledEvent
(
mediaEventTypes
[
i
]
domElement
)
;
}
break
;
case
'
source
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
break
;
case
'
img
'
:
case
'
image
'
:
case
'
link
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
break
;
case
'
form
'
:
trapBubbledEvent
(
TOP_RESET
domElement
)
;
trapBubbledEvent
(
TOP_SUBMIT
domElement
)
;
break
;
case
'
details
'
:
trapBubbledEvent
(
TOP_TOGGLE
domElement
)
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
}
assertValidProps
(
tag
rawProps
getStack
)
;
var
updatePayload
=
null
;
for
(
var
propKey
in
rawProps
)
{
if
(
!
rawProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
rawProps
[
propKey
]
;
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
if
(
domElement
.
textContent
!
=
=
nextProp
)
{
updatePayload
=
[
CHILDREN
nextProp
]
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
if
(
domElement
.
textContent
!
=
=
'
'
+
nextProp
)
{
updatePayload
=
[
CHILDREN
'
'
+
nextProp
]
;
}
}
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
{
}
}
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
true
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
case
'
option
'
:
break
;
default
:
if
(
typeof
rawProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
return
updatePayload
;
}
function
diffHydratedText
1
(
textNode
text
)
{
var
isDifferent
=
textNode
.
nodeValue
!
=
=
text
;
return
isDifferent
;
}
function
warnForUnmatchedText
1
(
textNode
text
)
{
}
function
warnForDeletedHydratableElement
1
(
parentNode
child
)
{
}
function
warnForDeletedHydratableText
1
(
parentNode
child
)
{
}
function
warnForInsertedHydratedElement
1
(
parentNode
tag
props
)
{
}
function
warnForInsertedHydratedText
1
(
parentNode
text
)
{
}
function
restoreControlledState
1
(
domElement
tag
props
)
{
switch
(
tag
)
{
case
'
input
'
:
restoreControlledState
(
domElement
props
)
;
return
;
case
'
textarea
'
:
restoreControlledState
3
(
domElement
props
)
;
return
;
case
'
select
'
:
restoreControlledState
2
(
domElement
props
)
;
return
;
}
}
var
ReactDOMFiberComponent
=
(
{
createElement
:
createElement
1
createTextNode
:
createTextNode
1
setInitialProperties
:
setInitialProperties
1
diffProperties
:
diffProperties
1
updateProperties
:
updateProperties
1
diffHydratedProperties
:
diffHydratedProperties
1
diffHydratedText
:
diffHydratedText
1
warnForUnmatchedText
:
warnForUnmatchedText
1
warnForDeletedHydratableElement
:
warnForDeletedHydratableElement
1
warnForDeletedHydratableText
:
warnForDeletedHydratableText
1
warnForInsertedHydratedElement
:
warnForInsertedHydratedElement
1
warnForInsertedHydratedText
:
warnForInsertedHydratedText
1
restoreControlledState
:
restoreControlledState
1
}
)
;
function
shim
(
)
{
reactProdInvariant
(
'
270
'
)
;
}
var
supportsPersistence
=
false
;
var
cloneInstance
=
shim
;
var
createContainerChildSet
=
shim
;
var
appendChildToContainerChildSet
=
shim
;
var
finalizeContainerChildren
=
shim
;
var
replaceContainerChildren
=
shim
;
var
createElement
=
createElement
1
;
var
createTextNode
=
createTextNode
1
;
var
setInitialProperties
=
setInitialProperties
1
;
var
diffProperties
=
diffProperties
1
;
var
updateProperties
=
updateProperties
1
;
var
diffHydratedProperties
=
diffHydratedProperties
1
;
var
diffHydratedText
=
diffHydratedText
1
;
var
precacheFiberNode
1
=
precacheFiberNode
;
var
updateFiberProps
1
=
updateFiberProps
;
var
eventsEnabled
=
null
;
var
selectionInformation
=
null
;
function
shouldAutoFocusHostComponent
(
type
props
)
{
switch
(
type
)
{
case
'
button
'
:
case
'
input
'
:
case
'
select
'
:
case
'
textarea
'
:
return
!
!
props
.
autoFocus
;
}
return
false
;
}
function
getRootHostContext
(
rootContainerInstance
)
{
var
type
=
void
0
;
var
namespace
=
void
0
;
var
nodeType
=
rootContainerInstance
.
nodeType
;
switch
(
nodeType
)
{
case
DOCUMENT_NODE
:
case
DOCUMENT_FRAGMENT_NODE
:
{
type
=
nodeType
=
=
=
DOCUMENT_NODE
?
'
#
document
'
:
'
#
fragment
'
;
var
root
=
rootContainerInstance
.
documentElement
;
namespace
=
root
?
root
.
namespaceURI
:
getChildNamespace
(
null
'
'
)
;
break
;
}
default
:
{
var
container
=
nodeType
=
=
=
COMMENT_NODE
?
rootContainerInstance
.
parentNode
:
rootContainerInstance
;
var
ownNamespace
=
container
.
namespaceURI
|
|
null
;
type
=
container
.
tagName
;
namespace
=
getChildNamespace
(
ownNamespace
type
)
;
break
;
}
}
return
namespace
;
}
function
getChildHostContext
(
parentHostContext
type
rootContainerInstance
)
{
var
parentNamespace
=
parentHostContext
;
return
getChildNamespace
(
parentNamespace
type
)
;
}
function
getPublicInstance
(
instance
)
{
return
instance
;
}
function
prepareForCommit
(
containerInfo
)
{
eventsEnabled
=
isEnabled
(
)
;
selectionInformation
=
getSelectionInformation
(
)
;
setEnabled
(
false
)
;
}
function
resetAfterCommit
(
containerInfo
)
{
restoreSelection
(
selectionInformation
)
;
selectionInformation
=
null
;
setEnabled
(
eventsEnabled
)
;
eventsEnabled
=
null
;
}
function
createInstance
(
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
var
parentNamespace
=
void
0
;
{
parentNamespace
=
hostContext
;
}
var
domElement
=
createElement
(
type
props
rootContainerInstance
parentNamespace
)
;
precacheFiberNode
1
(
internalInstanceHandle
domElement
)
;
updateFiberProps
1
(
domElement
props
)
;
return
domElement
;
}
function
appendInitialChild
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
function
finalizeInitialChildren
(
domElement
type
props
rootContainerInstance
hostContext
)
{
setInitialProperties
(
domElement
type
props
rootContainerInstance
)
;
return
shouldAutoFocusHostComponent
(
type
props
)
;
}
function
prepareUpdate
(
domElement
type
oldProps
newProps
rootContainerInstance
hostContext
)
{
return
diffProperties
(
domElement
type
oldProps
newProps
rootContainerInstance
)
;
}
function
shouldSetTextContent
(
type
props
)
{
return
type
=
=
=
'
textarea
'
|
|
typeof
props
.
children
=
=
=
'
string
'
|
|
typeof
props
.
children
=
=
=
'
number
'
|
|
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
props
.
dangerouslySetInnerHTML
!
=
=
null
&
&
typeof
props
.
dangerouslySetInnerHTML
.
__html
=
=
=
'
string
'
;
}
function
shouldDeprioritizeSubtree
(
type
props
)
{
return
!
!
props
.
hidden
;
}
function
createTextInstance
(
text
rootContainerInstance
hostContext
internalInstanceHandle
)
{
var
textNode
=
createTextNode
(
text
rootContainerInstance
)
;
precacheFiberNode
1
(
internalInstanceHandle
textNode
)
;
return
textNode
;
}
var
now
=
now
1
;
var
isPrimaryRenderer
=
true
;
var
scheduleDeferredCallback
=
scheduleWork
;
var
cancelDeferredCallback
=
cancelScheduledWork
;
var
supportsMutation
=
true
;
function
commitMount
(
domElement
type
newProps
internalInstanceHandle
)
{
if
(
shouldAutoFocusHostComponent
(
type
newProps
)
)
{
domElement
.
focus
(
)
;
}
}
function
commitUpdate
(
domElement
updatePayload
type
oldProps
newProps
internalInstanceHandle
)
{
updateFiberProps
1
(
domElement
newProps
)
;
updateProperties
(
domElement
updatePayload
type
oldProps
newProps
)
;
}
function
resetTextContent
(
domElement
)
{
setTextContent
(
domElement
'
'
)
;
}
function
commitTextUpdate
(
textInstance
oldText
newText
)
{
textInstance
.
nodeValue
=
newText
;
}
function
appendChild
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
function
appendChildToContainer
(
container
child
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
insertBefore
(
child
container
)
;
}
else
{
container
.
appendChild
(
child
)
;
}
}
function
insertBefore
(
parentInstance
child
beforeChild
)
{
parentInstance
.
insertBefore
(
child
beforeChild
)
;
}
function
insertInContainerBefore
(
container
child
beforeChild
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
insertBefore
(
child
beforeChild
)
;
}
else
{
container
.
insertBefore
(
child
beforeChild
)
;
}
}
function
removeChild
(
parentInstance
child
)
{
parentInstance
.
removeChild
(
child
)
;
}
function
removeChildFromContainer
(
container
child
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
removeChild
(
child
)
;
}
else
{
container
.
removeChild
(
child
)
;
}
}
var
supportsHydration
=
true
;
function
canHydrateInstance
(
instance
type
props
)
{
if
(
instance
.
nodeType
!
=
=
ELEMENT_NODE
|
|
type
.
toLowerCase
(
)
!
=
=
instance
.
nodeName
.
toLowerCase
(
)
)
{
return
null
;
}
return
instance
;
}
function
canHydrateTextInstance
(
instance
text
)
{
if
(
text
=
=
=
'
'
|
|
instance
.
nodeType
!
=
=
TEXT_NODE
)
{
return
null
;
}
return
instance
;
}
function
getNextHydratableSibling
(
instance
)
{
var
node
=
instance
.
nextSibling
;
while
(
node
&
&
node
.
nodeType
!
=
=
ELEMENT_NODE
&
&
node
.
nodeType
!
=
=
TEXT_NODE
)
{
node
=
node
.
nextSibling
;
}
return
node
;
}
function
getFirstHydratableChild
(
parentInstance
)
{
var
next
=
parentInstance
.
firstChild
;
while
(
next
&
&
next
.
nodeType
!
=
=
ELEMENT_NODE
&
&
next
.
nodeType
!
=
=
TEXT_NODE
)
{
next
=
next
.
nextSibling
;
}
return
next
;
}
function
hydrateInstance
(
instance
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
precacheFiberNode
1
(
internalInstanceHandle
instance
)
;
updateFiberProps
1
(
instance
props
)
;
var
parentNamespace
=
void
0
;
{
parentNamespace
=
hostContext
;
}
return
diffHydratedProperties
(
instance
type
props
parentNamespace
rootContainerInstance
)
;
}
function
hydrateTextInstance
(
textInstance
text
internalInstanceHandle
)
{
precacheFiberNode
1
(
internalInstanceHandle
textInstance
)
;
return
diffHydratedText
(
textInstance
text
)
;
}
var
enableUserTimingAPI
=
false
;
var
enableGetDerivedStateFromCatch
=
false
;
var
enableSuspense
=
false
;
var
enableProfilerTimer
=
false
;
var
reactEmoji
=
'
\
u269B
'
;
var
warningEmoji
=
'
\
u26D4
'
;
var
supportsUserTiming
=
typeof
performance
!
=
=
'
undefined
'
&
&
typeof
performance
.
mark
=
=
=
'
function
'
&
&
typeof
performance
.
clearMarks
=
=
=
'
function
'
&
&
typeof
performance
.
measure
=
=
=
'
function
'
&
&
typeof
performance
.
clearMeasures
=
=
=
'
function
'
;
var
currentFiber
=
null
;
var
currentPhase
=
null
;
var
currentPhaseFiber
=
null
;
var
isCommitting
=
false
;
var
hasScheduledUpdateInCurrentCommit
=
false
;
var
hasScheduledUpdateInCurrentPhase
=
false
;
var
commitCountInCurrentWorkLoop
=
0
;
var
effectCountInCurrentCommit
=
0
;
var
isWaitingForCallback
=
false
;
var
labelsInCurrentCommit
=
new
Set
(
)
;
var
formatMarkName
=
function
(
markName
)
{
return
reactEmoji
+
'
'
+
markName
;
}
;
var
formatLabel
=
function
(
label
warning
)
{
var
prefix
=
warning
?
warningEmoji
+
'
'
:
reactEmoji
+
'
'
;
var
suffix
=
warning
?
'
Warning
:
'
+
warning
:
'
'
;
return
'
'
+
prefix
+
label
+
suffix
;
}
;
var
beginMark
=
function
(
markName
)
{
performance
.
mark
(
formatMarkName
(
markName
)
)
;
}
;
var
clearMark
=
function
(
markName
)
{
performance
.
clearMarks
(
formatMarkName
(
markName
)
)
;
}
;
var
endMark
=
function
(
label
markName
warning
)
{
var
formattedMarkName
=
formatMarkName
(
markName
)
;
var
formattedLabel
=
formatLabel
(
label
warning
)
;
try
{
performance
.
measure
(
formattedLabel
formattedMarkName
)
;
}
catch
(
err
)
{
}
performance
.
clearMarks
(
formattedMarkName
)
;
performance
.
clearMeasures
(
formattedLabel
)
;
}
;
var
getFiberMarkName
=
function
(
label
debugID
)
{
return
label
+
'
(
#
'
+
debugID
+
'
)
'
;
}
;
var
getFiberLabel
=
function
(
componentName
isMounted
phase
)
{
if
(
phase
=
=
=
null
)
{
return
componentName
+
'
[
'
+
(
isMounted
?
'
update
'
:
'
mount
'
)
+
'
]
'
;
}
else
{
return
componentName
+
'
.
'
+
phase
;
}
}
;
var
beginFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
if
(
isCommitting
&
&
labelsInCurrentCommit
.
has
(
label
)
)
{
return
false
;
}
labelsInCurrentCommit
.
add
(
label
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
beginMark
(
markName
)
;
return
true
;
}
;
var
clearFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
clearMark
(
markName
)
;
}
;
var
endFiberMark
=
function
(
fiber
phase
warning
)
{
var
componentName
=
getComponentName
(
fiber
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
endMark
(
label
markName
warning
)
;
}
;
var
shouldIgnoreFiber
=
function
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
case
Fragment
:
case
ContextProvider
:
case
ContextConsumer
:
case
Mode
:
return
true
;
default
:
return
false
;
}
}
;
var
clearPendingPhaseMeasurement
=
function
(
)
{
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
clearFiberMark
(
currentPhaseFiber
currentPhase
)
;
}
currentPhaseFiber
=
null
;
currentPhase
=
null
;
hasScheduledUpdateInCurrentPhase
=
false
;
}
;
var
pauseTimers
=
function
(
)
{
var
fiber
=
currentFiber
;
while
(
fiber
)
{
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
endFiberMark
(
fiber
null
null
)
;
}
fiber
=
fiber
.
return
;
}
}
;
var
resumeTimersRecursively
=
function
(
fiber
)
{
if
(
fiber
.
return
!
=
=
null
)
{
resumeTimersRecursively
(
fiber
.
return
)
;
}
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
beginFiberMark
(
fiber
null
)
;
}
}
;
var
resumeTimers
=
function
(
)
{
if
(
currentFiber
!
=
=
null
)
{
resumeTimersRecursively
(
currentFiber
)
;
}
}
;
function
recordEffect
(
)
{
if
(
enableUserTimingAPI
)
{
effectCountInCurrentCommit
+
+
;
}
}
function
recordScheduleUpdate
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
isCommitting
)
{
hasScheduledUpdateInCurrentCommit
=
true
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhase
!
=
=
'
componentWillMount
'
&
&
currentPhase
!
=
=
'
componentWillReceiveProps
'
)
{
hasScheduledUpdateInCurrentPhase
=
true
;
}
}
}
function
startRequestCallbackTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
&
&
!
isWaitingForCallback
)
{
isWaitingForCallback
=
true
;
beginMark
(
'
(
Waiting
for
async
callback
.
.
.
)
'
)
;
}
}
}
function
stopRequestCallbackTimer
(
didExpire
expirationTime
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
)
{
isWaitingForCallback
=
false
;
var
warning
=
didExpire
?
'
React
was
blocked
by
main
thread
'
:
null
;
endMark
(
'
(
Waiting
for
async
callback
.
.
.
will
force
flush
in
'
+
expirationTime
+
'
ms
)
'
'
(
Waiting
for
async
callback
.
.
.
)
'
warning
)
;
}
}
}
function
startWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
;
if
(
!
beginFiberMark
(
fiber
null
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
true
;
}
}
function
cancelWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
clearFiberMark
(
fiber
null
)
;
}
}
function
stopWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
endFiberMark
(
fiber
null
null
)
;
}
}
function
stopFailedWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
var
warning
=
'
An
error
was
thrown
inside
this
error
boundary
'
;
endFiberMark
(
fiber
null
warning
)
;
}
}
function
startPhaseTimer
(
fiber
phase
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
clearPendingPhaseMeasurement
(
)
;
if
(
!
beginFiberMark
(
fiber
phase
)
)
{
return
;
}
currentPhaseFiber
=
fiber
;
currentPhase
=
phase
;
}
}
function
stopPhaseTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
var
warning
=
hasScheduledUpdateInCurrentPhase
?
'
Scheduled
a
cascading
update
'
:
null
;
endFiberMark
(
currentPhaseFiber
currentPhase
warning
)
;
}
currentPhase
=
null
;
currentPhaseFiber
=
null
;
}
}
function
startWorkLoopTimer
(
nextUnitOfWork
)
{
if
(
enableUserTimingAPI
)
{
currentFiber
=
nextUnitOfWork
;
if
(
!
supportsUserTiming
)
{
return
;
}
commitCountInCurrentWorkLoop
=
0
;
beginMark
(
'
(
React
Tree
Reconciliation
)
'
)
;
resumeTimers
(
)
;
}
}
function
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
interruptedBy
!
=
=
null
)
{
if
(
interruptedBy
.
tag
=
=
=
HostRoot
)
{
warning
=
'
A
top
-
level
update
interrupted
the
previous
render
'
;
}
else
{
var
componentName
=
getComponentName
(
interruptedBy
)
|
|
'
Unknown
'
;
warning
=
'
An
update
to
'
+
componentName
+
'
interrupted
the
previous
render
'
;
}
}
else
if
(
commitCountInCurrentWorkLoop
>
1
)
{
warning
=
'
There
were
cascading
updates
'
;
}
commitCountInCurrentWorkLoop
=
0
;
var
label
=
didCompleteRoot
?
'
(
React
Tree
Reconciliation
:
Completed
Root
)
'
:
'
(
React
Tree
Reconciliation
:
Yielded
)
'
;
pauseTimers
(
)
;
endMark
(
label
'
(
React
Tree
Reconciliation
)
'
warning
)
;
}
}
function
startCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
isCommitting
=
true
;
hasScheduledUpdateInCurrentCommit
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
beginMark
(
'
(
Committing
Changes
)
'
)
;
}
}
function
stopCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
hasScheduledUpdateInCurrentCommit
)
{
warning
=
'
Lifecycle
hook
scheduled
a
cascading
update
'
;
}
else
if
(
commitCountInCurrentWorkLoop
>
0
)
{
warning
=
'
Caused
by
a
cascading
update
in
earlier
commit
'
;
}
hasScheduledUpdateInCurrentCommit
=
false
;
commitCountInCurrentWorkLoop
+
+
;
isCommitting
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
endMark
(
'
(
Committing
Changes
)
'
'
(
Committing
Changes
)
'
warning
)
;
}
}
function
startCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Snapshot
Effects
)
'
)
;
}
}
function
stopCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Committing
Snapshot
Effects
:
'
+
count
+
'
Total
)
'
'
(
Committing
Snapshot
Effects
)
'
null
)
;
}
}
function
startCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Host
Effects
)
'
)
;
}
}
function
stopCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Committing
Host
Effects
:
'
+
count
+
'
Total
)
'
'
(
Committing
Host
Effects
)
'
null
)
;
}
}
function
startCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Calling
Lifecycle
Methods
)
'
)
;
}
}
function
stopCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Calling
Lifecycle
Methods
:
'
+
count
+
'
Total
)
'
'
(
Calling
Lifecycle
Methods
)
'
null
)
;
}
}
var
valueStack
=
[
]
;
var
index
=
-
1
;
function
createCursor
(
defaultValue
)
{
return
{
current
:
defaultValue
}
;
}
function
pop
(
cursor
fiber
)
{
if
(
index
<
0
)
{
return
;
}
cursor
.
current
=
valueStack
[
index
]
;
valueStack
[
index
]
=
null
;
index
-
-
;
}
function
push
(
cursor
value
fiber
)
{
index
+
+
;
valueStack
[
index
]
=
cursor
.
current
;
cursor
.
current
=
value
;
}
var
contextStackCursor
=
createCursor
(
emptyObject_1
)
;
var
didPerformWorkStackCursor
=
createCursor
(
false
)
;
var
previousContext
=
emptyObject_1
;
function
getUnmaskedContext
(
workInProgress
)
{
var
hasOwnContext
=
isContextProvider
(
workInProgress
)
;
if
(
hasOwnContext
)
{
return
previousContext
;
}
return
contextStackCursor
.
current
;
}
function
cacheContext
(
workInProgress
unmaskedContext
maskedContext
)
{
var
instance
=
workInProgress
.
stateNode
;
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
unmaskedContext
;
instance
.
__reactInternalMemoizedMaskedChildContext
=
maskedContext
;
}
function
getMaskedContext
(
workInProgress
unmaskedContext
)
{
var
type
=
workInProgress
.
type
;
var
contextTypes
=
type
.
contextTypes
;
if
(
!
contextTypes
)
{
return
emptyObject_1
;
}
var
instance
=
workInProgress
.
stateNode
;
if
(
instance
&
&
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
=
=
unmaskedContext
)
{
return
instance
.
__reactInternalMemoizedMaskedChildContext
;
}
var
context
=
{
}
;
for
(
var
key
in
contextTypes
)
{
context
[
key
]
=
unmaskedContext
[
key
]
;
}
if
(
instance
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
context
;
}
function
hasContextChanged
(
)
{
return
didPerformWorkStackCursor
.
current
;
}
function
isContextConsumer
(
fiber
)
{
return
fiber
.
tag
=
=
=
ClassComponent
&
&
fiber
.
type
.
contextTypes
!
=
null
;
}
function
isContextProvider
(
fiber
)
{
return
fiber
.
tag
=
=
=
ClassComponent
&
&
fiber
.
type
.
childContextTypes
!
=
null
;
}
function
popContextProvider
(
fiber
)
{
if
(
!
isContextProvider
(
fiber
)
)
{
return
;
}
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
popTopLevelContextObject
(
fiber
)
{
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
pushTopLevelContextObject
(
fiber
context
didChange
)
{
!
(
contextStackCursor
.
current
=
=
=
emptyObject_1
)
?
reactProdInvariant
(
'
168
'
)
:
void
0
;
push
(
contextStackCursor
context
fiber
)
;
push
(
didPerformWorkStackCursor
didChange
fiber
)
;
}
function
processChildContext
(
fiber
parentContext
)
{
var
instance
=
fiber
.
stateNode
;
var
childContextTypes
=
fiber
.
type
.
childContextTypes
;
if
(
typeof
instance
.
getChildContext
!
=
=
'
function
'
)
{
return
parentContext
;
}
var
childContext
=
void
0
;
startPhaseTimer
(
fiber
'
getChildContext
'
)
;
childContext
=
instance
.
getChildContext
(
)
;
stopPhaseTimer
(
)
;
for
(
var
contextKey
in
childContext
)
{
!
(
contextKey
in
childContextTypes
)
?
reactProdInvariant
(
'
108
'
getComponentName
(
fiber
)
|
|
'
Unknown
'
contextKey
)
:
void
0
;
}
return
_assign
(
{
}
parentContext
childContext
)
;
}
function
pushContextProvider
(
workInProgress
)
{
if
(
!
isContextProvider
(
workInProgress
)
)
{
return
false
;
}
var
instance
=
workInProgress
.
stateNode
;
var
memoizedMergedChildContext
=
instance
&
&
instance
.
__reactInternalMemoizedMergedChildContext
|
|
emptyObject_1
;
previousContext
=
contextStackCursor
.
current
;
push
(
contextStackCursor
memoizedMergedChildContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didPerformWorkStackCursor
.
current
workInProgress
)
;
return
true
;
}
function
invalidateContextProvider
(
workInProgress
didChange
)
{
var
instance
=
workInProgress
.
stateNode
;
!
instance
?
reactProdInvariant
(
'
169
'
)
:
void
0
;
if
(
didChange
)
{
var
mergedContext
=
processChildContext
(
workInProgress
previousContext
)
;
instance
.
__reactInternalMemoizedMergedChildContext
=
mergedContext
;
pop
(
didPerformWorkStackCursor
workInProgress
)
;
pop
(
contextStackCursor
workInProgress
)
;
push
(
contextStackCursor
mergedContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
else
{
pop
(
didPerformWorkStackCursor
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
}
function
findCurrentUnmaskedContext
(
fiber
)
{
!
(
isFiberMounted
(
fiber
)
&
&
fiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
170
'
)
:
void
0
;
var
node
=
fiber
;
while
(
node
.
tag
!
=
=
HostRoot
)
{
if
(
isContextProvider
(
node
)
)
{
return
node
.
stateNode
.
__reactInternalMemoizedMergedChildContext
;
}
var
parent
=
node
.
return
;
!
parent
?
reactProdInvariant
(
'
171
'
)
:
void
0
;
node
=
parent
;
}
return
node
.
stateNode
.
context
;
}
var
MAX_SIGNED_31_BIT_INT
=
1073741823
;
var
NoWork
=
0
;
var
Sync
=
1
;
var
Never
=
MAX_SIGNED_31_BIT_INT
;
var
UNIT_SIZE
=
10
;
var
MAGIC_NUMBER_OFFSET
=
2
;
function
msToExpirationTime
(
ms
)
{
return
(
ms
/
UNIT_SIZE
|
0
)
+
MAGIC_NUMBER_OFFSET
;
}
function
expirationTimeToMs
(
expirationTime
)
{
return
(
expirationTime
-
MAGIC_NUMBER_OFFSET
)
*
UNIT_SIZE
;
}
function
ceiling
(
num
precision
)
{
return
(
(
num
/
precision
|
0
)
+
1
)
*
precision
;
}
function
computeExpirationBucket
(
currentTime
expirationInMs
bucketSizeMs
)
{
return
MAGIC_NUMBER_OFFSET
+
ceiling
(
currentTime
-
MAGIC_NUMBER_OFFSET
+
expirationInMs
/
UNIT_SIZE
bucketSizeMs
/
UNIT_SIZE
)
;
}
var
NoContext
=
0
;
var
AsyncMode
=
1
;
var
StrictMode
=
2
;
var
ProfileMode
=
4
;
function
FiberNode
(
tag
pendingProps
key
mode
)
{
this
.
tag
=
tag
;
this
.
key
=
key
;
this
.
type
=
null
;
this
.
stateNode
=
null
;
this
.
return
=
null
;
this
.
child
=
null
;
this
.
sibling
=
null
;
this
.
index
=
0
;
this
.
ref
=
null
;
this
.
pendingProps
=
pendingProps
;
this
.
memoizedProps
=
null
;
this
.
updateQueue
=
null
;
this
.
memoizedState
=
null
;
this
.
mode
=
mode
;
this
.
effectTag
=
NoEffect
;
this
.
nextEffect
=
null
;
this
.
firstEffect
=
null
;
this
.
lastEffect
=
null
;
this
.
expirationTime
=
NoWork
;
this
.
alternate
=
null
;
if
(
enableProfilerTimer
)
{
this
.
actualDuration
=
0
;
this
.
actualStartTime
=
0
;
this
.
selfBaseTime
=
0
;
this
.
treeBaseTime
=
0
;
}
}
var
createFiber
=
function
(
tag
pendingProps
key
mode
)
{
return
new
FiberNode
(
tag
pendingProps
key
mode
)
;
}
;
function
shouldConstruct
(
Component
)
{
return
!
!
(
Component
.
prototype
&
&
Component
.
prototype
.
isReactComponent
)
;
}
function
createWorkInProgress
(
current
pendingProps
expirationTime
)
{
var
workInProgress
=
current
.
alternate
;
if
(
workInProgress
=
=
=
null
)
{
workInProgress
=
createFiber
(
current
.
tag
pendingProps
current
.
key
current
.
mode
)
;
workInProgress
.
type
=
current
.
type
;
workInProgress
.
stateNode
=
current
.
stateNode
;
workInProgress
.
alternate
=
current
;
current
.
alternate
=
workInProgress
;
}
else
{
workInProgress
.
pendingProps
=
pendingProps
;
workInProgress
.
effectTag
=
NoEffect
;
workInProgress
.
nextEffect
=
null
;
workInProgress
.
firstEffect
=
null
;
workInProgress
.
lastEffect
=
null
;
if
(
enableProfilerTimer
)
{
workInProgress
.
actualDuration
=
0
;
workInProgress
.
actualStartTime
=
0
;
}
}
workInProgress
.
expirationTime
=
expirationTime
;
workInProgress
.
child
=
current
.
child
;
workInProgress
.
memoizedProps
=
current
.
memoizedProps
;
workInProgress
.
memoizedState
=
current
.
memoizedState
;
workInProgress
.
updateQueue
=
current
.
updateQueue
;
workInProgress
.
sibling
=
current
.
sibling
;
workInProgress
.
index
=
current
.
index
;
workInProgress
.
ref
=
current
.
ref
;
if
(
enableProfilerTimer
)
{
workInProgress
.
selfBaseTime
=
current
.
selfBaseTime
;
workInProgress
.
treeBaseTime
=
current
.
treeBaseTime
;
}
return
workInProgress
;
}
function
createHostRootFiber
(
isAsync
)
{
var
mode
=
isAsync
?
AsyncMode
|
StrictMode
:
NoContext
;
return
createFiber
(
HostRoot
null
null
mode
)
;
}
function
createFiberFromElement
(
element
mode
expirationTime
)
{
var
owner
=
null
;
var
fiber
=
void
0
;
var
type
=
element
.
type
;
var
key
=
element
.
key
;
var
pendingProps
=
element
.
props
;
var
fiberTag
=
void
0
;
if
(
typeof
type
=
=
=
'
function
'
)
{
fiberTag
=
shouldConstruct
(
type
)
?
ClassComponent
:
IndeterminateComponent
;
}
else
if
(
typeof
type
=
=
=
'
string
'
)
{
fiberTag
=
HostComponent
;
}
else
{
switch
(
type
)
{
case
REACT_FRAGMENT_TYPE
:
return
createFiberFromFragment
(
pendingProps
.
children
mode
expirationTime
key
)
;
case
REACT_ASYNC_MODE_TYPE
:
fiberTag
=
Mode
;
mode
|
=
AsyncMode
|
StrictMode
;
break
;
case
REACT_STRICT_MODE_TYPE
:
fiberTag
=
Mode
;
mode
|
=
StrictMode
;
break
;
case
REACT_PROFILER_TYPE
:
return
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
;
case
REACT_TIMEOUT_TYPE
:
fiberTag
=
TimeoutComponent
;
mode
|
=
StrictMode
;
break
;
default
:
fiberTag
=
getFiberTagFromObjectType
(
type
owner
)
;
break
;
}
}
fiber
=
createFiber
(
fiberTag
pendingProps
key
mode
)
;
fiber
.
type
=
type
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
getFiberTagFromObjectType
(
type
owner
)
{
var
typeof
=
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
?
type
.
typeof
:
null
;
switch
(
typeof
)
{
case
REACT_PROVIDER_TYPE
:
return
ContextProvider
;
case
REACT_CONTEXT_TYPE
:
return
ContextConsumer
;
case
REACT_FORWARD_REF_TYPE
:
return
ForwardRef
;
default
:
{
var
info
=
'
'
;
reactProdInvariant
(
'
130
'
type
=
=
null
?
type
:
typeof
type
info
)
;
}
}
}
function
createFiberFromFragment
(
elements
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Fragment
elements
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Profiler
pendingProps
key
mode
|
ProfileMode
)
;
fiber
.
type
=
REACT_PROFILER_TYPE
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromText
(
content
mode
expirationTime
)
{
var
fiber
=
createFiber
(
HostText
content
null
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromHostInstanceForDeletion
(
)
{
var
fiber
=
createFiber
(
HostComponent
null
null
NoContext
)
;
fiber
.
type
=
'
DELETED
'
;
return
fiber
;
}
function
createFiberFromPortal
(
portal
mode
expirationTime
)
{
var
pendingProps
=
portal
.
children
!
=
=
null
?
portal
.
children
:
[
]
;
var
fiber
=
createFiber
(
HostPortal
pendingProps
portal
.
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
fiber
.
stateNode
=
{
containerInfo
:
portal
.
containerInfo
pendingChildren
:
null
implementation
:
portal
.
implementation
}
;
return
fiber
;
}
function
createFiberRoot
(
containerInfo
isAsync
hydrate
)
{
var
uninitializedFiber
=
createHostRootFiber
(
isAsync
)
;
var
root
=
{
current
:
uninitializedFiber
containerInfo
:
containerInfo
pendingChildren
:
null
earliestPendingTime
:
NoWork
latestPendingTime
:
NoWork
earliestSuspendedTime
:
NoWork
latestSuspendedTime
:
NoWork
latestPingedTime
:
NoWork
pendingCommitExpirationTime
:
NoWork
finishedWork
:
null
context
:
null
pendingContext
:
null
hydrate
:
hydrate
remainingExpirationTime
:
NoWork
firstBatch
:
null
nextScheduledRoot
:
null
}
;
uninitializedFiber
.
stateNode
=
root
;
return
root
;
}
var
onCommitFiberRoot
=
null
;
var
onCommitFiberUnmount
=
null
;
function
catchErrors
(
fn
)
{
return
function
(
arg
)
{
try
{
return
fn
(
arg
)
;
}
catch
(
err
)
{
}
}
;
}
function
injectInternals
(
internals
)
{
if
(
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
=
=
=
'
undefined
'
)
{
return
false
;
}
var
hook
=
__REACT_DEVTOOLS_GLOBAL_HOOK__
;
if
(
hook
.
isDisabled
)
{
return
true
;
}
if
(
!
hook
.
supportsFiber
)
{
return
true
;
}
try
{
var
rendererID
=
hook
.
inject
(
internals
)
;
onCommitFiberRoot
=
catchErrors
(
function
(
root
)
{
return
hook
.
onCommitFiberRoot
(
rendererID
root
)
;
}
)
;
onCommitFiberUnmount
=
catchErrors
(
function
(
fiber
)
{
return
hook
.
onCommitFiberUnmount
(
rendererID
fiber
)
;
}
)
;
}
catch
(
err
)
{
}
return
true
;
}
function
onCommitRoot
(
root
)
{
if
(
typeof
onCommitFiberRoot
=
=
=
'
function
'
)
{
onCommitFiberRoot
(
root
)
;
}
}
function
onCommitUnmount
(
fiber
)
{
if
(
typeof
onCommitFiberUnmount
=
=
=
'
function
'
)
{
onCommitFiberUnmount
(
fiber
)
;
}
}
function
markPendingPriorityLevel
(
root
expirationTime
)
{
if
(
enableSuspense
)
{
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestPendingTime
=
=
=
NoWork
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
expirationTime
;
}
else
{
if
(
earliestPendingTime
>
expirationTime
)
{
root
.
earliestPendingTime
=
expirationTime
;
}
else
{
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
latestPendingTime
<
expirationTime
)
{
root
.
latestPendingTime
=
expirationTime
;
}
}
}
}
}
function
markCommittedPriorityLevels
(
root
currentTime
earliestRemainingTime
)
{
if
(
enableSuspense
)
{
if
(
earliestRemainingTime
=
=
=
NoWork
)
{
root
.
earliestPendingTime
=
NoWork
;
root
.
latestPendingTime
=
NoWork
;
root
.
earliestSuspendedTime
=
NoWork
;
root
.
latestSuspendedTime
=
NoWork
;
root
.
latestPingedTime
=
NoWork
;
return
;
}
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
latestPendingTime
!
=
=
NoWork
)
{
if
(
latestPendingTime
<
earliestRemainingTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
NoWork
;
}
else
{
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestPendingTime
<
earliestRemainingTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
;
}
}
}
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
return
;
}
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
earliestRemainingTime
>
latestSuspendedTime
)
{
root
.
earliestSuspendedTime
=
NoWork
;
root
.
latestSuspendedTime
=
NoWork
;
root
.
latestPingedTime
=
NoWork
;
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
return
;
}
if
(
earliestRemainingTime
<
earliestSuspendedTime
)
{
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
return
;
}
}
}
function
markSuspendedPriorityLevel
(
root
suspendedTime
)
{
if
(
enableSuspense
)
{
var
earliestPendingTime
=
root
.
earliestPendingTime
;
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
earliestPendingTime
=
=
=
suspendedTime
)
{
if
(
latestPendingTime
=
=
=
suspendedTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
NoWork
;
}
else
{
root
.
earliestPendingTime
=
latestPendingTime
;
}
}
else
if
(
latestPendingTime
=
=
=
suspendedTime
)
{
root
.
latestPendingTime
=
earliestPendingTime
;
}
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
latestSuspendedTime
=
=
=
suspendedTime
)
{
root
.
latestPingedTime
=
NoWork
;
}
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
root
.
earliestSuspendedTime
=
root
.
latestSuspendedTime
=
suspendedTime
;
}
else
{
if
(
earliestSuspendedTime
>
suspendedTime
)
{
root
.
earliestSuspendedTime
=
suspendedTime
;
}
else
if
(
latestSuspendedTime
<
suspendedTime
)
{
root
.
latestSuspendedTime
=
suspendedTime
;
}
}
}
}
function
markPingedPriorityLevel
(
root
pingedTime
)
{
if
(
enableSuspense
)
{
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
latestSuspendedTime
!
=
=
NoWork
&
&
latestSuspendedTime
<
=
pingedTime
)
{
var
latestPingedTime
=
root
.
latestPingedTime
;
if
(
latestPingedTime
=
=
=
NoWork
|
|
latestPingedTime
<
pingedTime
)
{
root
.
latestPingedTime
=
pingedTime
;
}
}
}
}
function
findNextPendingPriorityLevel
(
root
)
{
if
(
enableSuspense
)
{
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
return
earliestPendingTime
;
}
if
(
earliestPendingTime
!
=
=
NoWork
)
{
return
earliestPendingTime
;
}
return
root
.
latestPingedTime
;
}
else
{
return
root
.
current
.
expirationTime
;
}
}
var
UpdateState
=
0
;
var
ReplaceState
=
1
;
var
ForceUpdate
=
2
;
var
CaptureUpdate
=
3
;
var
hasForceUpdate
=
false
;
function
createUpdateQueue
(
baseState
)
{
var
queue
=
{
expirationTime
:
NoWork
baseState
:
baseState
firstUpdate
:
null
lastUpdate
:
null
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
cloneUpdateQueue
(
currentQueue
)
{
var
queue
=
{
expirationTime
:
currentQueue
.
expirationTime
baseState
:
currentQueue
.
baseState
firstUpdate
:
currentQueue
.
firstUpdate
lastUpdate
:
currentQueue
.
lastUpdate
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
createUpdate
(
expirationTime
)
{
return
{
expirationTime
:
expirationTime
tag
:
UpdateState
payload
:
null
callback
:
null
next
:
null
nextEffect
:
null
}
;
}
function
appendUpdateToQueue
(
queue
update
expirationTime
)
{
if
(
queue
.
lastUpdate
=
=
=
null
)
{
queue
.
firstUpdate
=
queue
.
lastUpdate
=
update
;
}
else
{
queue
.
lastUpdate
.
next
=
update
;
queue
.
lastUpdate
=
update
;
}
if
(
queue
.
expirationTime
=
=
=
NoWork
|
|
queue
.
expirationTime
>
expirationTime
)
{
queue
.
expirationTime
=
expirationTime
;
}
}
function
enqueueUpdate
(
fiber
update
expirationTime
)
{
var
alternate
=
fiber
.
alternate
;
var
queue1
=
void
0
;
var
queue2
=
void
0
;
if
(
alternate
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
;
queue2
=
null
;
if
(
queue1
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
}
}
else
{
queue1
=
fiber
.
updateQueue
;
queue2
=
alternate
.
updateQueue
;
if
(
queue1
=
=
=
null
)
{
if
(
queue2
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
queue2
=
alternate
.
updateQueue
=
createUpdateQueue
(
alternate
.
memoizedState
)
;
}
else
{
queue1
=
fiber
.
updateQueue
=
cloneUpdateQueue
(
queue2
)
;
}
}
else
{
if
(
queue2
=
=
=
null
)
{
queue2
=
alternate
.
updateQueue
=
cloneUpdateQueue
(
queue1
)
;
}
else
{
}
}
}
if
(
queue2
=
=
=
null
|
|
queue1
=
=
=
queue2
)
{
appendUpdateToQueue
(
queue1
update
expirationTime
)
;
}
else
{
if
(
queue1
.
lastUpdate
=
=
=
null
|
|
queue2
.
lastUpdate
=
=
=
null
)
{
appendUpdateToQueue
(
queue1
update
expirationTime
)
;
appendUpdateToQueue
(
queue2
update
expirationTime
)
;
}
else
{
appendUpdateToQueue
(
queue1
update
expirationTime
)
;
queue2
.
lastUpdate
=
update
;
}
}
}
function
enqueueCapturedUpdate
(
workInProgress
update
renderExpirationTime
)
{
var
workInProgressQueue
=
workInProgress
.
updateQueue
;
if
(
workInProgressQueue
=
=
=
null
)
{
workInProgressQueue
=
workInProgress
.
updateQueue
=
createUpdateQueue
(
workInProgress
.
memoizedState
)
;
}
else
{
workInProgressQueue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
workInProgressQueue
)
;
}
if
(
workInProgressQueue
.
lastCapturedUpdate
=
=
=
null
)
{
workInProgressQueue
.
firstCapturedUpdate
=
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
else
{
workInProgressQueue
.
lastCapturedUpdate
.
next
=
update
;
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
if
(
workInProgressQueue
.
expirationTime
=
=
=
NoWork
|
|
workInProgressQueue
.
expirationTime
>
renderExpirationTime
)
{
workInProgressQueue
.
expirationTime
=
renderExpirationTime
;
}
}
function
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
{
var
current
=
workInProgress
.
alternate
;
if
(
current
!
=
=
null
)
{
if
(
queue
=
=
=
current
.
updateQueue
)
{
queue
=
workInProgress
.
updateQueue
=
cloneUpdateQueue
(
queue
)
;
}
}
return
queue
;
}
function
getStateFromUpdate
(
workInProgress
queue
update
prevState
nextProps
instance
)
{
switch
(
update
.
tag
)
{
case
ReplaceState
:
{
var
_payload
=
update
.
payload
;
if
(
typeof
_payload
=
=
=
'
function
'
)
{
return
_payload
.
call
(
instance
prevState
nextProps
)
;
}
return
_payload
;
}
case
CaptureUpdate
:
{
workInProgress
.
effectTag
=
workInProgress
.
effectTag
&
~
ShouldCapture
|
DidCapture
;
}
case
UpdateState
:
{
var
_payload2
=
update
.
payload
;
var
partialState
=
void
0
;
if
(
typeof
_payload2
=
=
=
'
function
'
)
{
partialState
=
_payload2
.
call
(
instance
prevState
nextProps
)
;
}
else
{
partialState
=
_payload2
;
}
if
(
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
)
{
return
prevState
;
}
return
_assign
(
{
}
prevState
partialState
)
;
}
case
ForceUpdate
:
{
hasForceUpdate
=
true
;
return
prevState
;
}
}
return
prevState
;
}
function
processUpdateQueue
(
workInProgress
queue
props
instance
renderExpirationTime
)
{
hasForceUpdate
=
false
;
if
(
queue
.
expirationTime
=
=
=
NoWork
|
|
queue
.
expirationTime
>
renderExpirationTime
)
{
return
;
}
queue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
;
var
newBaseState
=
queue
.
baseState
;
var
newFirstUpdate
=
null
;
var
newExpirationTime
=
NoWork
;
var
update
=
queue
.
firstUpdate
;
var
resultState
=
newBaseState
;
while
(
update
!
=
=
null
)
{
var
updateExpirationTime
=
update
.
expirationTime
;
if
(
updateExpirationTime
>
renderExpirationTime
)
{
if
(
newFirstUpdate
=
=
=
null
)
{
newFirstUpdate
=
update
;
newBaseState
=
resultState
;
}
if
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
updateExpirationTime
)
{
newExpirationTime
=
updateExpirationTime
;
}
}
else
{
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
_callback
=
update
.
callback
;
if
(
_callback
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastEffect
=
=
=
null
)
{
queue
.
firstEffect
=
queue
.
lastEffect
=
update
;
}
else
{
queue
.
lastEffect
.
nextEffect
=
update
;
queue
.
lastEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
var
newFirstCapturedUpdate
=
null
;
update
=
queue
.
firstCapturedUpdate
;
while
(
update
!
=
=
null
)
{
var
_updateExpirationTime
=
update
.
expirationTime
;
if
(
_updateExpirationTime
>
renderExpirationTime
)
{
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
newFirstCapturedUpdate
=
update
;
if
(
newFirstUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
}
if
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
_updateExpirationTime
)
{
newExpirationTime
=
_updateExpirationTime
;
}
}
else
{
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
_callback2
=
update
.
callback
;
if
(
_callback2
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastCapturedEffect
=
=
=
null
)
{
queue
.
firstCapturedEffect
=
queue
.
lastCapturedEffect
=
update
;
}
else
{
queue
.
lastCapturedEffect
.
nextEffect
=
update
;
queue
.
lastCapturedEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
if
(
newFirstUpdate
=
=
=
null
)
{
queue
.
lastUpdate
=
null
;
}
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
queue
.
lastCapturedUpdate
=
null
;
}
else
{
workInProgress
.
effectTag
|
=
Callback
;
}
if
(
newFirstUpdate
=
=
=
null
&
&
newFirstCapturedUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
queue
.
baseState
=
newBaseState
;
queue
.
firstUpdate
=
newFirstUpdate
;
queue
.
firstCapturedUpdate
=
newFirstCapturedUpdate
;
queue
.
expirationTime
=
newExpirationTime
;
workInProgress
.
memoizedState
=
resultState
;
}
function
callCallback
(
callback
context
)
{
!
(
typeof
callback
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
191
'
callback
)
:
void
0
;
callback
.
call
(
context
)
;
}
function
resetHasForceUpdateBeforeProcessing
(
)
{
hasForceUpdate
=
false
;
}
function
checkHasForceUpdateAfterProcessing
(
)
{
return
hasForceUpdate
;
}
function
commitUpdateQueue
(
finishedWork
finishedQueue
instance
renderExpirationTime
)
{
if
(
finishedQueue
.
firstCapturedUpdate
!
=
=
null
)
{
if
(
finishedQueue
.
lastUpdate
!
=
=
null
)
{
finishedQueue
.
lastUpdate
.
next
=
finishedQueue
.
firstCapturedUpdate
;
finishedQueue
.
lastUpdate
=
finishedQueue
.
lastCapturedUpdate
;
}
finishedQueue
.
firstCapturedUpdate
=
finishedQueue
.
lastCapturedUpdate
=
null
;
}
var
effect
=
finishedQueue
.
firstEffect
;
finishedQueue
.
firstEffect
=
finishedQueue
.
lastEffect
=
null
;
while
(
effect
!
=
=
null
)
{
var
_callback3
=
effect
.
callback
;
if
(
_callback3
!
=
=
null
)
{
effect
.
callback
=
null
;
callCallback
(
_callback3
instance
)
;
}
effect
=
effect
.
nextEffect
;
}
effect
=
finishedQueue
.
firstCapturedEffect
;
finishedQueue
.
firstCapturedEffect
=
finishedQueue
.
lastCapturedEffect
=
null
;
while
(
effect
!
=
=
null
)
{
var
_callback4
=
effect
.
callback
;
if
(
_callback4
!
=
=
null
)
{
effect
.
callback
=
null
;
callCallback
(
_callback4
instance
)
;
}
effect
=
effect
.
nextEffect
;
}
}
function
createCapturedValue
(
value
source
)
{
return
{
value
:
value
source
:
source
stack
:
getStackAddendumByWorkInProgressFiber
(
source
)
}
;
}
var
providerCursor
=
createCursor
(
null
)
;
var
valueCursor
=
createCursor
(
null
)
;
var
changedBitsCursor
=
createCursor
(
0
)
;
function
pushProvider
(
providerFiber
)
{
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
push
(
changedBitsCursor
context
.
_changedBits
providerFiber
)
;
push
(
valueCursor
context
.
_currentValue
providerFiber
)
;
push
(
providerCursor
providerFiber
providerFiber
)
;
context
.
_currentValue
=
providerFiber
.
pendingProps
.
value
;
context
.
_changedBits
=
providerFiber
.
stateNode
;
}
else
{
push
(
changedBitsCursor
context
.
_changedBits2
providerFiber
)
;
push
(
valueCursor
context
.
_currentValue2
providerFiber
)
;
push
(
providerCursor
providerFiber
providerFiber
)
;
context
.
_currentValue2
=
providerFiber
.
pendingProps
.
value
;
context
.
_changedBits2
=
providerFiber
.
stateNode
;
}
}
function
popProvider
(
providerFiber
)
{
var
changedBits
=
changedBitsCursor
.
current
;
var
currentValue
=
valueCursor
.
current
;
pop
(
providerCursor
providerFiber
)
;
pop
(
valueCursor
providerFiber
)
;
pop
(
changedBitsCursor
providerFiber
)
;
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
context
.
_currentValue
=
currentValue
;
context
.
_changedBits
=
changedBits
;
}
else
{
context
.
_currentValue2
=
currentValue
;
context
.
_changedBits2
=
changedBits
;
}
}
function
getContextCurrentValue
(
context
)
{
return
isPrimaryRenderer
?
context
.
_currentValue
:
context
.
_currentValue2
;
}
function
getContextChangedBits
(
context
)
{
return
isPrimaryRenderer
?
context
.
_changedBits
:
context
.
_changedBits2
;
}
var
NO_CONTEXT
=
{
}
;
var
contextStackCursor
1
=
createCursor
(
NO_CONTEXT
)
;
var
contextFiberStackCursor
=
createCursor
(
NO_CONTEXT
)
;
var
rootInstanceStackCursor
=
createCursor
(
NO_CONTEXT
)
;
function
requiredContext
(
c
)
{
!
(
c
!
=
=
NO_CONTEXT
)
?
reactProdInvariant
(
'
174
'
)
:
void
0
;
return
c
;
}
function
getRootHostContainer
(
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
return
rootInstance
;
}
function
pushHostContainer
(
fiber
nextRootInstance
)
{
push
(
rootInstanceStackCursor
nextRootInstance
fiber
)
;
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
NO_CONTEXT
fiber
)
;
var
nextRootContext
=
getRootHostContext
(
nextRootInstance
)
;
pop
(
contextStackCursor
1
fiber
)
;
push
(
contextStackCursor
1
nextRootContext
fiber
)
;
}
function
popHostContainer
(
fiber
)
{
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
pop
(
rootInstanceStackCursor
fiber
)
;
}
function
getHostContext
(
)
{
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
return
context
;
}
function
pushHostContext
(
fiber
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
var
nextContext
=
getChildHostContext
(
context
fiber
.
type
rootInstance
)
;
if
(
context
=
=
=
nextContext
)
{
return
;
}
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
nextContext
fiber
)
;
}
function
popHostContext
(
fiber
)
{
if
(
contextFiberStackCursor
.
current
!
=
=
fiber
)
{
return
;
}
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
}
var
commitTime
=
0
;
function
getCommitTime
(
)
{
return
commitTime
;
}
function
recordCommitTime
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
commitTime
=
now
(
)
;
}
var
timerPausedAt
=
0
;
var
totalElapsedPauseTime
=
0
;
function
markActualRenderTimeStarted
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
fiber
.
actualDuration
=
now
(
)
-
fiber
.
actualDuration
-
totalElapsedPauseTime
;
fiber
.
actualStartTime
=
now
(
)
;
}
function
pauseActualRenderTimerIfRunning
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
timerPausedAt
=
=
=
0
)
{
timerPausedAt
=
now
(
)
;
}
}
function
recordElapsedActualRenderTime
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
fiber
.
actualDuration
=
now
(
)
-
totalElapsedPauseTime
-
fiber
.
actualDuration
;
}
function
resetActualRenderTimer
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
totalElapsedPauseTime
=
0
;
}
function
resumeActualRenderTimerIfPaused
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
timerPausedAt
>
0
)
{
totalElapsedPauseTime
+
=
now
(
)
-
timerPausedAt
;
timerPausedAt
=
0
;
}
}
var
baseStartTime
=
-
1
;
function
recordElapsedBaseRenderTimeIfRunning
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
baseStartTime
!
=
=
-
1
)
{
fiber
.
selfBaseTime
=
now
(
)
-
baseStartTime
;
}
}
function
startBaseRenderTimer
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
baseStartTime
=
now
(
)
;
}
function
stopBaseRenderTimerIfRunning
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
baseStartTime
=
-
1
;
}
function
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
nextProps
)
{
var
prevState
=
workInProgress
.
memoizedState
;
var
partialState
=
getDerivedStateFromProps
(
nextProps
prevState
)
;
var
memoizedState
=
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
?
prevState
:
_assign
(
{
}
prevState
partialState
)
;
workInProgress
.
memoizedState
=
memoizedState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
&
&
updateQueue
.
expirationTime
=
=
=
NoWork
)
{
updateQueue
.
baseState
=
memoizedState
;
}
}
var
classComponentUpdater
=
{
isMounted
:
isMounted
enqueueSetState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
1
(
fiber
expirationTime
)
;
}
enqueueReplaceState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
ReplaceState
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
1
(
fiber
expirationTime
)
;
}
enqueueForceUpdate
:
function
(
inst
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
ForceUpdate
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
1
(
fiber
expirationTime
)
;
}
}
;
function
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
{
var
instance
=
workInProgress
.
stateNode
;
var
ctor
=
workInProgress
.
type
;
if
(
typeof
instance
.
shouldComponentUpdate
=
=
=
'
function
'
)
{
startPhaseTimer
(
workInProgress
'
shouldComponentUpdate
'
)
;
var
shouldUpdate
=
instance
.
shouldComponentUpdate
(
newProps
newState
newContext
)
;
stopPhaseTimer
(
)
;
return
shouldUpdate
;
}
if
(
ctor
.
prototype
&
&
ctor
.
prototype
.
isPureReactComponent
)
{
return
!
shallowEqual_1
(
oldProps
newProps
)
|
|
!
shallowEqual_1
(
oldState
newState
)
;
}
return
true
;
}
function
adoptClassInstance
(
workInProgress
instance
)
{
instance
.
updater
=
classComponentUpdater
;
workInProgress
.
stateNode
=
instance
;
set
(
instance
workInProgress
)
;
}
function
constructClassInstance
(
workInProgress
props
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
needsContext
=
isContextConsumer
(
workInProgress
)
;
var
context
=
needsContext
?
getMaskedContext
(
workInProgress
unmaskedContext
)
:
emptyObject_1
;
var
instance
=
new
ctor
(
props
context
)
;
var
state
=
workInProgress
.
memoizedState
=
instance
.
state
!
=
=
null
&
&
instance
.
state
!
=
=
undefined
?
instance
.
state
:
null
;
adoptClassInstance
(
workInProgress
instance
)
;
if
(
needsContext
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
instance
;
}
function
callComponentWillMount
(
workInProgress
instance
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
var
oldState
=
instance
.
state
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
if
(
oldState
!
=
=
instance
.
state
)
{
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
{
var
oldState
=
instance
.
state
;
startPhaseTimer
(
workInProgress
'
componentWillReceiveProps
'
)
;
if
(
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
componentWillReceiveProps
(
newProps
newContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillReceiveProps
(
newProps
newContext
)
;
}
stopPhaseTimer
(
)
;
if
(
instance
.
state
!
=
=
oldState
)
{
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
mountClassInstance
(
workInProgress
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
var
props
=
workInProgress
.
pendingProps
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
instance
.
props
=
props
;
instance
.
state
=
workInProgress
.
memoizedState
;
instance
.
refs
=
emptyObject_1
;
instance
.
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
props
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
var
getDerivedStateFromProps
=
workInProgress
.
type
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
props
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
if
(
typeof
ctor
.
getDerivedStateFromProps
!
=
=
'
function
'
&
&
typeof
instance
.
getSnapshotBeforeUpdate
!
=
=
'
function
'
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
callComponentWillMount
(
workInProgress
instance
)
;
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
props
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
function
resumeMountClassInstance
(
workInProgress
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newProps
=
workInProgress
.
pendingProps
;
instance
.
props
=
oldProps
;
var
oldContext
=
instance
.
context
;
var
newUnmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
newContext
=
getMaskedContext
(
workInProgress
newUnmaskedContext
)
;
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
newContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
else
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
newContext
;
return
shouldUpdate
;
}
function
updateClassInstance
(
current
workInProgress
renderExpirationTime
)
{
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newProps
=
workInProgress
.
pendingProps
;
instance
.
props
=
oldProps
;
var
oldContext
=
instance
.
context
;
var
newUnmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
newContext
=
getMaskedContext
(
workInProgress
newUnmaskedContext
)
;
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
newContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
newContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
oldProps
newProps
oldState
newState
newContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillUpdate
'
)
;
if
(
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
componentWillUpdate
(
newProps
newState
newContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillUpdate
(
newProps
newState
newContext
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
else
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
newContext
;
return
shouldUpdate
;
}
var
isArray
1
=
Array
.
isArray
;
function
coerceRef
(
returnFiber
current
element
)
{
var
mixedRef
=
element
.
ref
;
if
(
mixedRef
!
=
=
null
&
&
typeof
mixedRef
!
=
=
'
function
'
&
&
typeof
mixedRef
!
=
=
'
object
'
)
{
if
(
element
.
_owner
)
{
var
owner
=
element
.
_owner
;
var
inst
=
void
0
;
if
(
owner
)
{
var
ownerFiber
=
owner
;
!
(
ownerFiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
110
'
)
:
void
0
;
inst
=
ownerFiber
.
stateNode
;
}
!
inst
?
reactProdInvariant
(
'
147
'
mixedRef
)
:
void
0
;
var
stringRef
=
'
'
+
mixedRef
;
if
(
current
!
=
=
null
&
&
current
.
ref
!
=
=
null
&
&
typeof
current
.
ref
=
=
=
'
function
'
&
&
current
.
ref
.
_stringRef
=
=
=
stringRef
)
{
return
current
.
ref
;
}
var
ref
=
function
(
value
)
{
var
refs
=
inst
.
refs
=
=
=
emptyObject_1
?
inst
.
refs
=
{
}
:
inst
.
refs
;
if
(
value
=
=
=
null
)
{
delete
refs
[
stringRef
]
;
}
else
{
refs
[
stringRef
]
=
value
;
}
}
;
ref
.
_stringRef
=
stringRef
;
return
ref
;
}
else
{
!
(
typeof
mixedRef
=
=
=
'
string
'
)
?
reactProdInvariant
(
'
148
'
)
:
void
0
;
!
element
.
_owner
?
reactProdInvariant
(
'
254
'
mixedRef
)
:
void
0
;
}
}
return
mixedRef
;
}
function
throwOnInvalidObjectType
(
returnFiber
newChild
)
{
if
(
returnFiber
.
type
!
=
=
'
textarea
'
)
{
var
addendum
=
'
'
;
reactProdInvariant
(
'
31
'
Object
.
prototype
.
toString
.
call
(
newChild
)
=
=
=
'
[
object
Object
]
'
?
'
object
with
keys
{
'
+
Object
.
keys
(
newChild
)
.
join
(
'
'
)
+
'
}
'
:
newChild
addendum
)
;
}
}
function
ChildReconciler
(
shouldTrackSideEffects
)
{
function
deleteChild
(
returnFiber
childToDelete
)
{
if
(
!
shouldTrackSideEffects
)
{
return
;
}
var
last
=
returnFiber
.
lastEffect
;
if
(
last
!
=
=
null
)
{
last
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
childToDelete
.
nextEffect
=
null
;
childToDelete
.
effectTag
=
Deletion
;
}
function
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
{
if
(
!
shouldTrackSideEffects
)
{
return
null
;
}
var
childToDelete
=
currentFirstChild
;
while
(
childToDelete
!
=
=
null
)
{
deleteChild
(
returnFiber
childToDelete
)
;
childToDelete
=
childToDelete
.
sibling
;
}
return
null
;
}
function
mapRemainingChildren
(
returnFiber
currentFirstChild
)
{
var
existingChildren
=
new
Map
(
)
;
var
existingChild
=
currentFirstChild
;
while
(
existingChild
!
=
=
null
)
{
if
(
existingChild
.
key
!
=
=
null
)
{
existingChildren
.
set
(
existingChild
.
key
existingChild
)
;
}
else
{
existingChildren
.
set
(
existingChild
.
index
existingChild
)
;
}
existingChild
=
existingChild
.
sibling
;
}
return
existingChildren
;
}
function
useFiber
(
fiber
pendingProps
expirationTime
)
{
var
clone
=
createWorkInProgress
(
fiber
pendingProps
expirationTime
)
;
clone
.
index
=
0
;
clone
.
sibling
=
null
;
return
clone
;
}
function
placeChild
(
newFiber
lastPlacedIndex
newIndex
)
{
newFiber
.
index
=
newIndex
;
if
(
!
shouldTrackSideEffects
)
{
return
lastPlacedIndex
;
}
var
current
=
newFiber
.
alternate
;
if
(
current
!
=
=
null
)
{
var
oldIndex
=
current
.
index
;
if
(
oldIndex
<
lastPlacedIndex
)
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
else
{
return
oldIndex
;
}
}
else
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
}
function
placeSingleChild
(
newFiber
)
{
if
(
shouldTrackSideEffects
&
&
newFiber
.
alternate
=
=
=
null
)
{
newFiber
.
effectTag
=
Placement
;
}
return
newFiber
;
}
function
updateTextNode
(
returnFiber
current
textContent
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
HostText
)
{
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateElement
(
returnFiber
current
element
expirationTime
)
{
if
(
current
!
=
=
null
&
&
current
.
type
=
=
=
element
.
type
)
{
var
existing
=
useFiber
(
current
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
current
element
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
var
created
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
created
.
ref
=
coerceRef
(
returnFiber
current
element
)
;
created
.
return
=
returnFiber
;
return
created
;
}
}
function
updatePortal
(
returnFiber
current
portal
expirationTime
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
HostPortal
|
|
current
.
stateNode
.
containerInfo
!
=
=
portal
.
containerInfo
|
|
current
.
stateNode
.
implementation
!
=
=
portal
.
implementation
)
{
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateFragment
(
returnFiber
current
fragment
expirationTime
key
)
{
if
(
current
=
=
=
null
|
|
current
.
tag
!
=
=
Fragment
)
{
var
created
=
createFiberFromFragment
(
fragment
returnFiber
.
mode
expirationTime
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
fragment
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
createChild
(
returnFiber
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
created
=
createFiberFromText
(
'
'
+
newChild
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_created
=
createFiberFromElement
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created
.
ref
=
coerceRef
(
returnFiber
null
newChild
)
;
_created
.
return
=
returnFiber
;
return
_created
;
}
case
REACT_PORTAL_TYPE
:
{
var
_created2
=
createFiberFromPortal
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created2
.
return
=
returnFiber
;
return
_created2
;
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_created3
=
createFiberFromFragment
(
newChild
returnFiber
.
mode
expirationTime
null
)
;
_created3
.
return
=
returnFiber
;
return
_created3
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateSlot
(
returnFiber
oldFiber
newChild
expirationTime
)
{
var
key
=
oldFiber
!
=
=
null
?
oldFiber
.
key
:
null
;
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateTextNode
(
returnFiber
oldFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
oldFiber
newChild
.
props
.
children
expirationTime
key
)
;
}
return
updateElement
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
case
REACT_PORTAL_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
return
updatePortal
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateFragment
(
returnFiber
oldFiber
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateFromMap
(
existingChildren
returnFiber
newIdx
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
matchedFiber
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateTextNode
(
returnFiber
matchedFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_matchedFiber
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
_matchedFiber
newChild
.
props
.
children
expirationTime
newChild
.
key
)
;
}
return
updateElement
(
returnFiber
_matchedFiber
newChild
expirationTime
)
;
}
case
REACT_PORTAL_TYPE
:
{
var
_matchedFiber2
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
return
updatePortal
(
returnFiber
_matchedFiber2
newChild
expirationTime
)
;
}
}
if
(
isArray
1
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_matchedFiber3
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateFragment
(
returnFiber
_matchedFiber3
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChildren
expirationTime
)
{
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
for
(
;
oldFiber
!
=
=
null
&
&
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
oldFiber
=
=
=
null
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
newIdx
=
=
=
newChildren
.
length
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber
=
createChild
(
returnFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
!
_newFiber
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber
;
}
previousNewFiber
=
_newFiber
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber2
=
updateFromMap
(
existingChildren
returnFiber
newIdx
newChildren
[
newIdx
]
expirationTime
)
;
if
(
_newFiber2
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber2
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber2
.
key
=
=
=
null
?
newIdx
:
_newFiber2
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber2
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber2
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber2
;
}
previousNewFiber
=
_newFiber2
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChildrenIterable
expirationTime
)
{
var
iteratorFn
=
getIteratorFn
(
newChildrenIterable
)
;
!
(
typeof
iteratorFn
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
150
'
)
:
void
0
;
var
newChildren
=
iteratorFn
.
call
(
newChildrenIterable
)
;
!
(
newChildren
!
=
null
)
?
reactProdInvariant
(
'
151
'
)
:
void
0
;
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
var
step
=
newChildren
.
next
(
)
;
for
(
;
oldFiber
!
=
=
null
&
&
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
step
.
value
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
!
oldFiber
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
step
.
done
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber3
=
createChild
(
returnFiber
step
.
value
expirationTime
)
;
if
(
_newFiber3
=
=
=
null
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber3
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber3
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber3
;
}
previousNewFiber
=
_newFiber3
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber4
=
updateFromMap
(
existingChildren
returnFiber
newIdx
step
.
value
expirationTime
)
;
if
(
_newFiber4
!
=
=
null
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber4
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber4
.
key
=
=
=
null
?
newIdx
:
_newFiber4
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber4
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber4
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber4
;
}
previousNewFiber
=
_newFiber4
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileSingleTextNode
(
returnFiber
currentFirstChild
textContent
expirationTime
)
{
if
(
currentFirstChild
!
=
=
null
&
&
currentFirstChild
.
tag
=
=
=
HostText
)
{
deleteRemainingChildren
(
returnFiber
currentFirstChild
.
sibling
)
;
var
existing
=
useFiber
(
currentFirstChild
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileSingleElement
(
returnFiber
currentFirstChild
element
expirationTime
)
{
var
key
=
element
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
Fragment
?
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
:
child
.
type
=
=
=
element
.
type
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
?
element
.
props
.
children
:
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
child
element
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
if
(
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
var
created
=
createFiberFromFragment
(
element
.
props
.
children
returnFiber
.
mode
expirationTime
element
.
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
_created4
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
_created4
.
ref
=
coerceRef
(
returnFiber
currentFirstChild
element
)
;
_created4
.
return
=
returnFiber
;
return
_created4
;
}
}
function
reconcileSinglePortal
(
returnFiber
currentFirstChild
portal
expirationTime
)
{
var
key
=
portal
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
HostPortal
&
&
child
.
stateNode
.
containerInfo
=
=
=
portal
.
containerInfo
&
&
child
.
stateNode
.
implementation
=
=
=
portal
.
implementation
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileChildFibers
(
returnFiber
currentFirstChild
newChild
expirationTime
)
{
var
isUnkeyedTopLevelFragment
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
&
&
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
&
&
newChild
.
key
=
=
=
null
;
if
(
isUnkeyedTopLevelFragment
)
{
newChild
=
newChild
.
props
.
children
;
}
var
isObject
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
;
if
(
isObject
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
return
placeSingleChild
(
reconcileSingleElement
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
case
REACT_PORTAL_TYPE
:
return
placeSingleChild
(
reconcileSinglePortal
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
}
}
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
return
placeSingleChild
(
reconcileSingleTextNode
(
returnFiber
currentFirstChild
'
'
+
newChild
expirationTime
)
)
;
}
if
(
isArray
1
(
newChild
)
)
{
return
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
getIteratorFn
(
newChild
)
)
{
return
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
isObject
)
{
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
if
(
typeof
newChild
=
=
=
'
undefined
'
&
&
!
isUnkeyedTopLevelFragment
)
{
switch
(
returnFiber
.
tag
)
{
case
ClassComponent
:
{
}
case
FunctionalComponent
:
{
var
Component
=
returnFiber
.
type
;
reactProdInvariant
(
'
152
'
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
;
}
}
}
return
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
}
return
reconcileChildFibers
;
}
var
reconcileChildFibers
=
ChildReconciler
(
true
)
;
var
mountChildFibers
=
ChildReconciler
(
false
)
;
function
cloneChildFibers
(
current
workInProgress
)
{
!
(
current
=
=
=
null
|
|
workInProgress
.
child
=
=
=
current
.
child
)
?
reactProdInvariant
(
'
153
'
)
:
void
0
;
if
(
workInProgress
.
child
=
=
=
null
)
{
return
;
}
var
currentChild
=
workInProgress
.
child
;
var
newChild
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
workInProgress
.
child
=
newChild
;
newChild
.
return
=
workInProgress
;
while
(
currentChild
.
sibling
!
=
=
null
)
{
currentChild
=
currentChild
.
sibling
;
newChild
=
newChild
.
sibling
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
newChild
.
return
=
workInProgress
;
}
newChild
.
sibling
=
null
;
}
var
hydrationParentFiber
=
null
;
var
nextHydratableInstance
=
null
;
var
isHydrating
=
false
;
function
enterHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
var
parentInstance
=
fiber
.
stateNode
.
containerInfo
;
nextHydratableInstance
=
getFirstHydratableChild
(
parentInstance
)
;
hydrationParentFiber
=
fiber
;
isHydrating
=
true
;
return
true
;
}
function
deleteHydratableInstance
(
returnFiber
instance
)
{
var
childToDelete
=
createFiberFromHostInstanceForDeletion
(
)
;
childToDelete
.
stateNode
=
instance
;
childToDelete
.
return
=
returnFiber
;
childToDelete
.
effectTag
=
Deletion
;
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
}
function
insertNonHydratedInstance
(
returnFiber
fiber
)
{
fiber
.
effectTag
|
=
Placement
;
}
function
tryHydrate
(
fiber
nextInstance
)
{
switch
(
fiber
.
tag
)
{
case
HostComponent
:
{
var
type
=
fiber
.
type
;
var
props
=
fiber
.
pendingProps
;
var
instance
=
canHydrateInstance
(
nextInstance
type
props
)
;
if
(
instance
!
=
=
null
)
{
fiber
.
stateNode
=
instance
;
return
true
;
}
return
false
;
}
case
HostText
:
{
var
text
=
fiber
.
pendingProps
;
var
textInstance
=
canHydrateTextInstance
(
nextInstance
text
)
;
if
(
textInstance
!
=
=
null
)
{
fiber
.
stateNode
=
textInstance
;
return
true
;
}
return
false
;
}
default
:
return
false
;
}
}
function
tryToClaimNextHydratableInstance
(
fiber
)
{
if
(
!
isHydrating
)
{
return
;
}
var
nextInstance
=
nextHydratableInstance
;
if
(
!
nextInstance
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
var
firstAttemptedInstance
=
nextInstance
;
if
(
!
tryHydrate
(
fiber
nextInstance
)
)
{
nextInstance
=
getNextHydratableSibling
(
firstAttemptedInstance
)
;
if
(
!
nextInstance
|
|
!
tryHydrate
(
fiber
nextInstance
)
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
deleteHydratableInstance
(
hydrationParentFiber
firstAttemptedInstance
)
;
}
hydrationParentFiber
=
fiber
;
nextHydratableInstance
=
getFirstHydratableChild
(
nextInstance
)
;
}
function
prepareToHydrateHostInstance
(
fiber
rootContainerInstance
hostContext
)
{
if
(
!
supportsHydration
)
{
reactProdInvariant
(
'
175
'
)
;
}
var
instance
=
fiber
.
stateNode
;
var
updatePayload
=
hydrateInstance
(
instance
fiber
.
type
fiber
.
memoizedProps
rootContainerInstance
hostContext
fiber
)
;
fiber
.
updateQueue
=
updatePayload
;
if
(
updatePayload
!
=
=
null
)
{
return
true
;
}
return
false
;
}
function
prepareToHydrateHostTextInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
reactProdInvariant
(
'
176
'
)
;
}
var
textInstance
=
fiber
.
stateNode
;
var
textContent
=
fiber
.
memoizedProps
;
var
shouldUpdate
=
hydrateTextInstance
(
textInstance
textContent
fiber
)
;
return
shouldUpdate
;
}
function
popToNextHostParent
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
&
&
parent
.
tag
!
=
=
HostComponent
&
&
parent
.
tag
!
=
=
HostRoot
)
{
parent
=
parent
.
return
;
}
hydrationParentFiber
=
parent
;
}
function
popHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
if
(
fiber
!
=
=
hydrationParentFiber
)
{
return
false
;
}
if
(
!
isHydrating
)
{
popToNextHostParent
(
fiber
)
;
isHydrating
=
true
;
return
false
;
}
var
type
=
fiber
.
type
;
if
(
fiber
.
tag
!
=
=
HostComponent
|
|
type
!
=
=
'
head
'
&
&
type
!
=
=
'
body
'
&
&
!
shouldSetTextContent
(
type
fiber
.
memoizedProps
)
)
{
var
nextInstance
=
nextHydratableInstance
;
while
(
nextInstance
)
{
deleteHydratableInstance
(
fiber
nextInstance
)
;
nextInstance
=
getNextHydratableSibling
(
nextInstance
)
;
}
}
popToNextHostParent
(
fiber
)
;
nextHydratableInstance
=
hydrationParentFiber
?
getNextHydratableSibling
(
fiber
.
stateNode
)
:
null
;
return
true
;
}
function
resetHydrationState
(
)
{
if
(
!
supportsHydration
)
{
return
;
}
hydrationParentFiber
=
null
;
nextHydratableInstance
=
null
;
isHydrating
=
false
;
}
function
reconcileChildren
(
current
workInProgress
nextChildren
)
{
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
workInProgress
.
expirationTime
)
;
}
function
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
renderExpirationTime
)
{
if
(
current
=
=
=
null
)
{
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
current
.
child
nextChildren
renderExpirationTime
)
;
}
}
function
updateForwardRef
(
current
workInProgress
)
{
var
render
=
workInProgress
.
type
.
render
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
ref
=
workInProgress
.
ref
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
workInProgress
.
memoizedProps
=
=
=
nextProps
)
{
var
currentRef
=
current
!
=
=
null
?
current
.
ref
:
null
;
if
(
ref
=
=
=
currentRef
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
var
nextChildren
=
void
0
;
{
nextChildren
=
render
(
nextProps
ref
)
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateFragment
(
current
workInProgress
)
{
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
return
workInProgress
.
child
;
}
function
updateMode
(
current
workInProgress
)
{
var
nextChildren
=
workInProgress
.
pendingProps
.
children
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
nextChildren
=
=
=
null
|
|
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
return
workInProgress
.
child
;
}
function
updateProfiler
(
current
workInProgress
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
if
(
enableProfilerTimer
)
{
workInProgress
.
effectTag
|
=
Update
;
}
if
(
workInProgress
.
memoizedProps
=
=
=
nextProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
nextChildren
=
nextProps
.
children
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
markRef
(
current
workInProgress
)
{
var
ref
=
workInProgress
.
ref
;
if
(
current
=
=
=
null
&
&
ref
!
=
=
null
|
|
current
!
=
=
null
&
&
current
.
ref
!
=
=
ref
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
}
function
updateFunctionalComponent
(
current
workInProgress
)
{
var
fn
=
workInProgress
.
type
;
var
nextProps
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
}
else
{
if
(
workInProgress
.
memoizedProps
=
=
=
nextProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
nextChildren
=
void
0
;
{
nextChildren
=
fn
(
nextProps
context
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateClassComponent
(
current
workInProgress
renderExpirationTime
)
{
var
hasContext
=
pushContextProvider
(
workInProgress
)
;
var
shouldUpdate
=
void
0
;
if
(
current
=
=
=
null
)
{
if
(
workInProgress
.
stateNode
=
=
=
null
)
{
constructClassInstance
(
workInProgress
workInProgress
.
pendingProps
renderExpirationTime
)
;
mountClassInstance
(
workInProgress
renderExpirationTime
)
;
shouldUpdate
=
true
;
}
else
{
shouldUpdate
=
resumeMountClassInstance
(
workInProgress
renderExpirationTime
)
;
}
}
else
{
shouldUpdate
=
updateClassInstance
(
current
workInProgress
renderExpirationTime
)
;
}
return
finishClassComponent
(
current
workInProgress
shouldUpdate
hasContext
renderExpirationTime
)
;
}
function
finishClassComponent
(
current
workInProgress
shouldUpdate
hasContext
renderExpirationTime
)
{
markRef
(
current
workInProgress
)
;
var
didCaptureError
=
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
if
(
!
shouldUpdate
&
&
!
didCaptureError
)
{
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
false
)
;
}
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
ReactCurrentOwner
.
current
=
workInProgress
;
var
nextChildren
=
void
0
;
if
(
didCaptureError
&
&
(
!
enableGetDerivedStateFromCatch
|
|
typeof
ctor
.
getDerivedStateFromCatch
!
=
=
'
function
'
)
)
{
nextChildren
=
null
;
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
}
else
{
{
nextChildren
=
instance
.
render
(
)
;
}
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
didCaptureError
)
{
reconcileChildrenAtExpirationTime
(
current
workInProgress
null
renderExpirationTime
)
;
workInProgress
.
child
=
null
;
}
reconcileChildrenAtExpirationTime
(
current
workInProgress
nextChildren
renderExpirationTime
)
;
memoizeState
(
workInProgress
instance
.
state
)
;
memoizeProps
(
workInProgress
instance
.
props
)
;
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
true
)
;
}
return
workInProgress
.
child
;
}
function
pushHostRootContext
(
workInProgress
)
{
var
root
=
workInProgress
.
stateNode
;
if
(
root
.
pendingContext
)
{
pushTopLevelContextObject
(
workInProgress
root
.
pendingContext
root
.
pendingContext
!
=
=
root
.
context
)
;
}
else
if
(
root
.
context
)
{
pushTopLevelContextObject
(
workInProgress
root
.
context
false
)
;
}
pushHostContainer
(
workInProgress
root
.
containerInfo
)
;
}
function
updateHostRoot
(
current
workInProgress
renderExpirationTime
)
{
pushHostRootContext
(
workInProgress
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevState
=
workInProgress
.
memoizedState
;
var
prevChildren
=
prevState
!
=
=
null
?
prevState
.
element
:
null
;
processUpdateQueue
(
workInProgress
updateQueue
nextProps
null
renderExpirationTime
)
;
var
nextState
=
workInProgress
.
memoizedState
;
var
nextChildren
=
nextState
.
element
;
if
(
nextChildren
=
=
=
prevChildren
)
{
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
root
=
workInProgress
.
stateNode
;
if
(
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
&
&
root
.
hydrate
&
&
enterHydrationState
(
workInProgress
)
)
{
workInProgress
.
effectTag
|
=
Placement
;
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
resetHydrationState
(
)
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
}
return
workInProgress
.
child
;
}
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
function
updateHostComponent
(
current
workInProgress
renderExpirationTime
)
{
pushHostContext
(
workInProgress
)
;
if
(
current
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
type
=
workInProgress
.
type
;
var
memoizedProps
=
workInProgress
.
memoizedProps
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevProps
=
current
!
=
=
null
?
current
.
memoizedProps
:
null
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
memoizedProps
=
=
=
nextProps
)
{
var
isHidden
=
workInProgress
.
mode
&
AsyncMode
&
&
shouldDeprioritizeSubtree
(
type
nextProps
)
;
if
(
isHidden
)
{
workInProgress
.
expirationTime
=
Never
;
}
if
(
!
isHidden
|
|
renderExpirationTime
!
=
=
Never
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
var
nextChildren
=
nextProps
.
children
;
var
isDirectTextChild
=
shouldSetTextContent
(
type
nextProps
)
;
if
(
isDirectTextChild
)
{
nextChildren
=
null
;
}
else
if
(
prevProps
&
&
shouldSetTextContent
(
type
prevProps
)
)
{
workInProgress
.
effectTag
|
=
ContentReset
;
}
markRef
(
current
workInProgress
)
;
if
(
renderExpirationTime
!
=
=
Never
&
&
workInProgress
.
mode
&
AsyncMode
&
&
shouldDeprioritizeSubtree
(
type
nextProps
)
)
{
workInProgress
.
expirationTime
=
Never
;
workInProgress
.
memoizedProps
=
nextProps
;
return
null
;
}
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextProps
)
;
return
workInProgress
.
child
;
}
function
updateHostText
(
current
workInProgress
)
{
if
(
current
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
nextProps
=
workInProgress
.
pendingProps
;
memoizeProps
(
workInProgress
nextProps
)
;
return
null
;
}
function
mountIndeterminateComponent
(
current
workInProgress
renderExpirationTime
)
{
!
(
current
=
=
=
null
)
?
reactProdInvariant
(
'
155
'
)
:
void
0
;
var
fn
=
workInProgress
.
type
;
var
props
=
workInProgress
.
pendingProps
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
value
=
void
0
;
{
value
=
fn
(
props
context
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
&
&
typeof
value
.
render
=
=
=
'
function
'
&
&
value
.
typeof
=
=
=
undefined
)
{
var
Component
=
workInProgress
.
type
;
workInProgress
.
tag
=
ClassComponent
;
workInProgress
.
memoizedState
=
value
.
state
!
=
=
null
&
&
value
.
state
!
=
=
undefined
?
value
.
state
:
null
;
var
getDerivedStateFromProps
=
Component
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
getDerivedStateFromProps
props
)
;
}
var
hasContext
=
pushContextProvider
(
workInProgress
)
;
adoptClassInstance
(
workInProgress
value
)
;
mountClassInstance
(
workInProgress
renderExpirationTime
)
;
return
finishClassComponent
(
current
workInProgress
true
hasContext
renderExpirationTime
)
;
}
else
{
workInProgress
.
tag
=
FunctionalComponent
;
reconcileChildren
(
current
workInProgress
value
)
;
memoizeProps
(
workInProgress
props
)
;
return
workInProgress
.
child
;
}
}
function
updateTimeoutComponent
(
current
workInProgress
renderExpirationTime
)
{
if
(
enableSuspense
)
{
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevProps
=
workInProgress
.
memoizedProps
;
var
prevDidTimeout
=
workInProgress
.
memoizedState
;
var
alreadyCaptured
=
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
;
var
nextDidTimeout
=
!
alreadyCaptured
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
nextProps
=
=
=
prevProps
&
&
nextDidTimeout
=
=
=
prevDidTimeout
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
render
=
nextProps
.
children
;
var
nextChildren
=
render
(
nextDidTimeout
)
;
workInProgress
.
memoizedProps
=
nextProps
;
workInProgress
.
memoizedState
=
nextDidTimeout
;
reconcileChildren
(
current
workInProgress
nextChildren
)
;
return
workInProgress
.
child
;
}
else
{
return
null
;
}
}
function
updatePortalComponent
(
current
workInProgress
renderExpirationTime
)
{
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
workInProgress
.
memoizedProps
=
=
=
nextChildren
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
if
(
current
=
=
=
null
)
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
}
else
{
reconcileChildren
(
current
workInProgress
nextChildren
)
;
memoizeProps
(
workInProgress
nextChildren
)
;
}
return
workInProgress
.
child
;
}
function
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
{
var
fiber
=
workInProgress
.
child
;
if
(
fiber
!
=
=
null
)
{
fiber
.
return
=
workInProgress
;
}
while
(
fiber
!
=
=
null
)
{
var
nextFiber
=
void
0
;
switch
(
fiber
.
tag
)
{
case
ContextConsumer
:
var
observedBits
=
fiber
.
stateNode
|
0
;
if
(
fiber
.
type
=
=
=
context
&
&
(
observedBits
&
changedBits
)
!
=
=
0
)
{
var
node
=
fiber
;
while
(
node
!
=
=
null
)
{
var
alternate
=
node
.
alternate
;
if
(
node
.
expirationTime
=
=
=
NoWork
|
|
node
.
expirationTime
>
renderExpirationTime
)
{
node
.
expirationTime
=
renderExpirationTime
;
if
(
alternate
!
=
=
null
&
&
(
alternate
.
expirationTime
=
=
=
NoWork
|
|
alternate
.
expirationTime
>
renderExpirationTime
)
)
{
alternate
.
expirationTime
=
renderExpirationTime
;
}
}
else
if
(
alternate
!
=
=
null
&
&
(
alternate
.
expirationTime
=
=
=
NoWork
|
|
alternate
.
expirationTime
>
renderExpirationTime
)
)
{
alternate
.
expirationTime
=
renderExpirationTime
;
}
else
{
break
;
}
node
=
node
.
return
;
}
nextFiber
=
null
;
}
else
{
nextFiber
=
fiber
.
child
;
}
break
;
case
ContextProvider
:
nextFiber
=
fiber
.
type
=
=
=
workInProgress
.
type
?
null
:
fiber
.
child
;
break
;
default
:
nextFiber
=
fiber
.
child
;
break
;
}
if
(
nextFiber
!
=
=
null
)
{
nextFiber
.
return
=
fiber
;
}
else
{
nextFiber
=
fiber
;
while
(
nextFiber
!
=
=
null
)
{
if
(
nextFiber
=
=
=
workInProgress
)
{
nextFiber
=
null
;
break
;
}
var
sibling
=
nextFiber
.
sibling
;
if
(
sibling
!
=
=
null
)
{
sibling
.
return
=
nextFiber
.
return
;
nextFiber
=
sibling
;
break
;
}
nextFiber
=
nextFiber
.
return
;
}
}
fiber
=
nextFiber
;
}
}
function
updateContextProvider
(
current
workInProgress
renderExpirationTime
)
{
var
providerType
=
workInProgress
.
type
;
var
context
=
providerType
.
_context
;
var
newProps
=
workInProgress
.
pendingProps
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
canBailOnProps
=
true
;
if
(
hasContextChanged
(
)
)
{
canBailOnProps
=
false
;
}
else
if
(
oldProps
=
=
=
newProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
newValue
=
newProps
.
value
;
workInProgress
.
memoizedProps
=
newProps
;
var
changedBits
=
void
0
;
if
(
oldProps
=
=
=
null
)
{
changedBits
=
MAX_SIGNED_31_BIT_INT
;
}
else
{
if
(
oldProps
.
value
=
=
=
newProps
.
value
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
canBailOnProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
changedBits
=
0
;
}
else
{
var
oldValue
=
oldProps
.
value
;
if
(
oldValue
=
=
=
newValue
&
&
(
oldValue
!
=
=
0
|
|
1
/
oldValue
=
=
=
1
/
newValue
)
|
|
oldValue
!
=
=
oldValue
&
&
newValue
!
=
=
newValue
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
canBailOnProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
changedBits
=
0
;
}
else
{
changedBits
=
typeof
context
.
_calculateChangedBits
=
=
=
'
function
'
?
context
.
_calculateChangedBits
(
oldValue
newValue
)
:
MAX_SIGNED_31_BIT_INT
;
changedBits
|
=
0
;
if
(
changedBits
=
=
=
0
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
canBailOnProps
)
{
workInProgress
.
stateNode
=
0
;
pushProvider
(
workInProgress
)
;
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
}
else
{
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
;
}
}
}
}
workInProgress
.
stateNode
=
changedBits
;
pushProvider
(
workInProgress
)
;
var
newChildren
=
newProps
.
children
;
reconcileChildren
(
current
workInProgress
newChildren
)
;
return
workInProgress
.
child
;
}
function
updateContextConsumer
(
current
workInProgress
renderExpirationTime
)
{
var
context
=
workInProgress
.
type
;
var
newProps
=
workInProgress
.
pendingProps
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newValue
=
getContextCurrentValue
(
context
)
;
var
changedBits
=
getContextChangedBits
(
context
)
;
if
(
hasContextChanged
(
)
)
{
}
else
if
(
changedBits
=
=
=
0
&
&
oldProps
=
=
=
newProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
workInProgress
.
memoizedProps
=
newProps
;
var
observedBits
=
newProps
.
unstable_observedBits
;
if
(
observedBits
=
=
=
undefined
|
|
observedBits
=
=
=
null
)
{
observedBits
=
MAX_SIGNED_31_BIT_INT
;
}
workInProgress
.
stateNode
=
observedBits
;
if
(
(
changedBits
&
observedBits
)
!
=
=
0
)
{
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
;
}
else
if
(
oldProps
=
=
=
newProps
)
{
return
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
;
}
var
render
=
newProps
.
children
;
var
newChildren
=
void
0
;
{
newChildren
=
render
(
newValue
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
workInProgress
newChildren
)
;
return
workInProgress
.
child
;
}
function
bailoutOnAlreadyFinishedWork
(
current
workInProgress
)
{
cancelWorkTimer
(
workInProgress
)
;
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
cloneChildFibers
(
current
workInProgress
)
;
return
workInProgress
.
child
;
}
function
bailoutOnLowPriority
(
current
workInProgress
)
{
cancelWorkTimer
(
workInProgress
)
;
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
pushHostRootContext
(
workInProgress
)
;
break
;
case
ClassComponent
:
pushContextProvider
(
workInProgress
)
;
break
;
case
HostPortal
:
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
break
;
case
ContextProvider
:
pushProvider
(
workInProgress
)
;
break
;
}
return
null
;
}
function
memoizeProps
(
workInProgress
nextProps
)
{
workInProgress
.
memoizedProps
=
nextProps
;
}
function
memoizeState
(
workInProgress
nextState
)
{
workInProgress
.
memoizedState
=
nextState
;
}
function
beginWork
(
current
workInProgress
renderExpirationTime
)
{
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
markActualRenderTimeStarted
(
workInProgress
)
;
}
}
if
(
workInProgress
.
expirationTime
=
=
=
NoWork
|
|
workInProgress
.
expirationTime
>
renderExpirationTime
)
{
return
bailoutOnLowPriority
(
current
workInProgress
)
;
}
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
return
mountIndeterminateComponent
(
current
workInProgress
renderExpirationTime
)
;
case
FunctionalComponent
:
return
updateFunctionalComponent
(
current
workInProgress
)
;
case
ClassComponent
:
return
updateClassComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostRoot
:
return
updateHostRoot
(
current
workInProgress
renderExpirationTime
)
;
case
HostComponent
:
return
updateHostComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostText
:
return
updateHostText
(
current
workInProgress
)
;
case
TimeoutComponent
:
return
updateTimeoutComponent
(
current
workInProgress
renderExpirationTime
)
;
case
HostPortal
:
return
updatePortalComponent
(
current
workInProgress
renderExpirationTime
)
;
case
ForwardRef
:
return
updateForwardRef
(
current
workInProgress
)
;
case
Fragment
:
return
updateFragment
(
current
workInProgress
)
;
case
Mode
:
return
updateMode
(
current
workInProgress
)
;
case
Profiler
:
return
updateProfiler
(
current
workInProgress
)
;
case
ContextProvider
:
return
updateContextProvider
(
current
workInProgress
renderExpirationTime
)
;
case
ContextConsumer
:
return
updateContextConsumer
(
current
workInProgress
renderExpirationTime
)
;
default
:
reactProdInvariant
(
'
156
'
)
;
}
}
function
markUpdate
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Update
;
}
function
markRef
1
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
function
appendAllChildren
(
parent
workInProgress
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendInitialChild
(
parent
node
.
stateNode
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
var
updateHostContainer
=
void
0
;
var
updateHostComponent
1
=
void
0
;
var
updateHostText
1
=
void
0
;
if
(
supportsMutation
)
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
{
workInProgress
.
updateQueue
=
updatePayload
;
if
(
updatePayload
)
{
markUpdate
(
workInProgress
)
;
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
markUpdate
(
workInProgress
)
;
}
}
;
}
else
if
(
supportsPersistence
)
{
var
appendAllChildrenToContainer
=
function
(
containerChildSet
workInProgress
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendChildToContainerChildSet
(
containerChildSet
node
.
stateNode
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
updateHostContainer
=
function
(
workInProgress
)
{
var
portalOrRoot
=
workInProgress
.
stateNode
;
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
if
(
childrenUnchanged
)
{
}
else
{
var
container
=
portalOrRoot
.
containerInfo
;
var
newChildSet
=
createContainerChildSet
(
container
)
;
appendAllChildrenToContainer
(
newChildSet
workInProgress
)
;
portalOrRoot
.
pendingChildren
=
newChildSet
;
markUpdate
(
workInProgress
)
;
finalizeContainerChildren
(
container
newChildSet
)
;
}
}
;
updateHostComponent
1
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
{
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
var
currentInstance
=
current
.
stateNode
;
if
(
childrenUnchanged
&
&
updatePayload
=
=
=
null
)
{
workInProgress
.
stateNode
=
currentInstance
;
}
else
{
var
recyclableInstance
=
workInProgress
.
stateNode
;
var
newInstance
=
cloneInstance
(
currentInstance
updatePayload
type
oldProps
newProps
workInProgress
childrenUnchanged
recyclableInstance
)
;
if
(
finalizeInitialChildren
(
newInstance
type
newProps
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
newInstance
;
if
(
childrenUnchanged
)
{
markUpdate
(
workInProgress
)
;
}
else
{
appendAllChildren
(
newInstance
workInProgress
)
;
}
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
currentHostContext
=
getHostContext
(
)
;
workInProgress
.
stateNode
=
createTextInstance
(
newText
rootContainerInstance
currentHostContext
workInProgress
)
;
markUpdate
(
workInProgress
)
;
}
}
;
}
else
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
{
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
}
;
}
function
completeWork
(
current
workInProgress
renderExpirationTime
)
{
var
newProps
=
workInProgress
.
pendingProps
;
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
recordElapsedActualRenderTime
(
workInProgress
)
;
}
}
switch
(
workInProgress
.
tag
)
{
case
FunctionalComponent
:
return
null
;
case
ClassComponent
:
{
popContextProvider
(
workInProgress
)
;
return
null
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
fiberRoot
=
workInProgress
.
stateNode
;
if
(
fiberRoot
.
pendingContext
)
{
fiberRoot
.
context
=
fiberRoot
.
pendingContext
;
fiberRoot
.
pendingContext
=
null
;
}
if
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
{
popHydrationState
(
workInProgress
)
;
workInProgress
.
effectTag
&
=
~
Placement
;
}
updateHostContainer
(
workInProgress
)
;
return
null
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
type
=
workInProgress
.
type
;
if
(
current
!
=
=
null
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldProps
=
current
.
memoizedProps
;
var
instance
=
workInProgress
.
stateNode
;
var
currentHostContext
=
getHostContext
(
)
;
var
updatePayload
=
prepareUpdate
(
instance
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
updateHostComponent
1
(
current
workInProgress
updatePayload
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
if
(
current
.
ref
!
=
=
workInProgress
.
ref
)
{
markRef
1
(
workInProgress
)
;
}
}
else
{
if
(
!
newProps
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
return
null
;
}
var
_currentHostContext
=
getHostContext
(
)
;
var
wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
wasHydrated
)
{
if
(
prepareToHydrateHostInstance
(
workInProgress
rootContainerInstance
_currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
var
_instance
=
createInstance
(
type
newProps
rootContainerInstance
_currentHostContext
workInProgress
)
;
appendAllChildren
(
_instance
workInProgress
)
;
if
(
finalizeInitialChildren
(
_instance
type
newProps
rootContainerInstance
_currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
_instance
;
}
if
(
workInProgress
.
ref
!
=
=
null
)
{
markRef
1
(
workInProgress
)
;
}
}
return
null
;
}
case
HostText
:
{
var
newText
=
newProps
;
if
(
current
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldText
=
current
.
memoizedProps
;
updateHostText
1
(
current
workInProgress
oldText
newText
)
;
}
else
{
if
(
typeof
newText
!
=
=
'
string
'
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
return
null
;
}
var
_rootContainerInstance
=
getRootHostContainer
(
)
;
var
_currentHostContext2
=
getHostContext
(
)
;
var
_wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
_wasHydrated
)
{
if
(
prepareToHydrateHostTextInstance
(
workInProgress
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
workInProgress
.
stateNode
=
createTextInstance
(
newText
_rootContainerInstance
_currentHostContext2
workInProgress
)
;
}
}
return
null
;
}
case
ForwardRef
:
return
null
;
case
TimeoutComponent
:
return
null
;
case
Fragment
:
return
null
;
case
Mode
:
return
null
;
case
Profiler
:
return
null
;
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
updateHostContainer
(
workInProgress
)
;
return
null
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
return
null
;
case
ContextConsumer
:
return
null
;
case
IndeterminateComponent
:
reactProdInvariant
(
'
167
'
)
;
default
:
reactProdInvariant
(
'
156
'
)
;
}
}
function
showErrorDialog
(
capturedError
)
{
return
true
;
}
function
logCapturedError
(
capturedError
)
{
var
logError
=
showErrorDialog
(
capturedError
)
;
if
(
logError
=
=
=
false
)
{
return
;
}
var
error
=
capturedError
.
error
;
var
suppressLogging
=
error
&
&
error
.
suppressReactErrorLogging
;
if
(
suppressLogging
)
{
return
;
}
{
console
.
error
(
error
)
;
}
}
function
logError
(
boundary
errorInfo
)
{
var
source
=
errorInfo
.
source
;
var
stack
=
errorInfo
.
stack
;
if
(
stack
=
=
=
null
&
&
source
!
=
=
null
)
{
stack
=
getStackAddendumByWorkInProgressFiber
(
source
)
;
}
var
capturedError
=
{
componentName
:
source
!
=
=
null
?
getComponentName
(
source
)
:
null
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
error
:
errorInfo
.
value
errorBoundary
:
null
errorBoundaryName
:
null
errorBoundaryFound
:
false
willRetry
:
false
}
;
if
(
boundary
!
=
=
null
&
&
boundary
.
tag
=
=
=
ClassComponent
)
{
capturedError
.
errorBoundary
=
boundary
.
stateNode
;
capturedError
.
errorBoundaryName
=
getComponentName
(
boundary
)
;
capturedError
.
errorBoundaryFound
=
true
;
capturedError
.
willRetry
=
true
;
}
try
{
logCapturedError
(
capturedError
)
;
}
catch
(
e
)
{
var
suppressLogging
=
e
&
&
e
.
suppressReactErrorLogging
;
if
(
!
suppressLogging
)
{
console
.
error
(
e
)
;
}
}
}
var
callComponentWillUnmountWithTimer
=
function
(
current
instance
)
{
startPhaseTimer
(
current
'
componentWillUnmount
'
)
;
instance
.
props
=
current
.
memoizedProps
;
instance
.
state
=
current
.
memoizedState
;
instance
.
componentWillUnmount
(
)
;
stopPhaseTimer
(
)
;
}
;
function
safelyCallComponentWillUnmount
(
current
instance
)
{
{
try
{
callComponentWillUnmountWithTimer
(
current
instance
)
;
}
catch
(
unmountError
)
{
captureCommitPhaseError
(
current
unmountError
)
;
}
}
}
function
safelyDetachRef
(
current
)
{
var
ref
=
current
.
ref
;
if
(
ref
!
=
=
null
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
{
try
{
ref
(
null
)
;
}
catch
(
refError
)
{
captureCommitPhaseError
(
current
refError
)
;
}
}
}
else
{
ref
.
current
=
null
;
}
}
}
function
commitBeforeMutationLifeCycles
(
current
finishedWork
)
{
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
if
(
finishedWork
.
effectTag
&
Snapshot
)
{
if
(
current
!
=
=
null
)
{
var
prevProps
=
current
.
memoizedProps
;
var
prevState
=
current
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
getSnapshotBeforeUpdate
'
)
;
var
instance
=
finishedWork
.
stateNode
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
var
snapshot
=
instance
.
getSnapshotBeforeUpdate
(
prevProps
prevState
)
;
instance
.
__reactInternalSnapshotBeforeUpdate
=
snapshot
;
stopPhaseTimer
(
)
;
}
}
return
;
}
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
return
;
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitLifeCycles
(
finishedRoot
current
finishedWork
currentTime
committedExpirationTime
)
{
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
finishedWork
.
effectTag
&
Update
)
{
if
(
current
=
=
=
null
)
{
startPhaseTimer
(
finishedWork
'
componentDidMount
'
)
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
instance
.
componentDidMount
(
)
;
stopPhaseTimer
(
)
;
}
else
{
var
prevProps
=
current
.
memoizedProps
;
var
prevState
=
current
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
componentDidUpdate
'
)
;
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
instance
.
componentDidUpdate
(
prevProps
prevState
instance
.
__reactInternalSnapshotBeforeUpdate
)
;
stopPhaseTimer
(
)
;
}
}
var
updateQueue
=
finishedWork
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
instance
.
props
=
finishedWork
.
memoizedProps
;
instance
.
state
=
finishedWork
.
memoizedState
;
commitUpdateQueue
(
finishedWork
updateQueue
instance
committedExpirationTime
)
;
}
return
;
}
case
HostRoot
:
{
var
_updateQueue
=
finishedWork
.
updateQueue
;
if
(
_updateQueue
!
=
=
null
)
{
var
_instance
=
null
;
if
(
finishedWork
.
child
!
=
=
null
)
{
switch
(
finishedWork
.
child
.
tag
)
{
case
HostComponent
:
_instance
=
getPublicInstance
(
finishedWork
.
child
.
stateNode
)
;
break
;
case
ClassComponent
:
_instance
=
finishedWork
.
child
.
stateNode
;
break
;
}
}
commitUpdateQueue
(
finishedWork
_updateQueue
_instance
committedExpirationTime
)
;
}
return
;
}
case
HostComponent
:
{
var
_instance2
=
finishedWork
.
stateNode
;
if
(
current
=
=
=
null
&
&
finishedWork
.
effectTag
&
Update
)
{
var
type
=
finishedWork
.
type
;
var
props
=
finishedWork
.
memoizedProps
;
commitMount
(
_instance2
type
props
finishedWork
)
;
}
return
;
}
case
HostText
:
{
return
;
}
case
HostPortal
:
{
return
;
}
case
Profiler
:
{
return
;
}
case
TimeoutComponent
:
{
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitAttachRef
(
finishedWork
)
{
var
ref
=
finishedWork
.
ref
;
if
(
ref
!
=
=
null
)
{
var
instance
=
finishedWork
.
stateNode
;
var
instanceToUse
=
void
0
;
switch
(
finishedWork
.
tag
)
{
case
HostComponent
:
instanceToUse
=
getPublicInstance
(
instance
)
;
break
;
default
:
instanceToUse
=
instance
;
}
if
(
typeof
ref
=
=
=
'
function
'
)
{
ref
(
instanceToUse
)
;
}
else
{
ref
.
current
=
instanceToUse
;
}
}
}
function
commitDetachRef
(
current
)
{
var
currentRef
=
current
.
ref
;
if
(
currentRef
!
=
=
null
)
{
if
(
typeof
currentRef
=
=
=
'
function
'
)
{
currentRef
(
null
)
;
}
else
{
currentRef
.
current
=
null
;
}
}
}
function
commitUnmount
(
current
)
{
if
(
typeof
onCommitUnmount
=
=
=
'
function
'
)
{
onCommitUnmount
(
current
)
;
}
switch
(
current
.
tag
)
{
case
ClassComponent
:
{
safelyDetachRef
(
current
)
;
var
instance
=
current
.
stateNode
;
if
(
typeof
instance
.
componentWillUnmount
=
=
=
'
function
'
)
{
safelyCallComponentWillUnmount
(
current
instance
)
;
}
return
;
}
case
HostComponent
:
{
safelyDetachRef
(
current
)
;
return
;
}
case
HostPortal
:
{
if
(
supportsMutation
)
{
unmountHostComponents
(
current
)
;
}
else
if
(
supportsPersistence
)
{
emptyPortalContainer
(
current
)
;
}
return
;
}
}
}
function
commitNestedUnmounts
(
root
)
{
var
node
=
root
;
while
(
true
)
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
&
&
(
!
supportsMutation
|
|
node
.
tag
!
=
=
HostPortal
)
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
root
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
root
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
detachFiber
(
current
)
{
current
.
return
=
null
;
current
.
child
=
null
;
if
(
current
.
alternate
)
{
current
.
alternate
.
child
=
null
;
current
.
alternate
.
return
=
null
;
}
}
function
emptyPortalContainer
(
current
)
{
if
(
!
supportsPersistence
)
{
return
;
}
var
portal
=
current
.
stateNode
;
var
containerInfo
=
portal
.
containerInfo
;
var
emptyChildSet
=
createContainerChildSet
(
containerInfo
)
;
replaceContainerChildren
(
containerInfo
emptyChildSet
)
;
}
function
commitContainer
(
finishedWork
)
{
if
(
!
supportsPersistence
)
{
return
;
}
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
return
;
}
case
HostText
:
{
return
;
}
case
HostRoot
:
case
HostPortal
:
{
var
portalOrRoot
=
finishedWork
.
stateNode
;
var
containerInfo
=
portalOrRoot
.
containerInfo
_pendingChildren
=
portalOrRoot
.
pendingChildren
;
replaceContainerChildren
(
containerInfo
_pendingChildren
)
;
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
getHostParentFiber
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
)
{
if
(
isHostParent
(
parent
)
)
{
return
parent
;
}
parent
=
parent
.
return
;
}
reactProdInvariant
(
'
160
'
)
;
}
function
isHostParent
(
fiber
)
{
return
fiber
.
tag
=
=
=
HostComponent
|
|
fiber
.
tag
=
=
=
HostRoot
|
|
fiber
.
tag
=
=
=
HostPortal
;
}
function
getHostSibling
(
fiber
)
{
var
node
=
fiber
;
siblings
:
while
(
true
)
{
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
isHostParent
(
node
.
return
)
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
while
(
node
.
tag
!
=
=
HostComponent
&
&
node
.
tag
!
=
=
HostText
)
{
if
(
node
.
effectTag
&
Placement
)
{
continue
siblings
;
}
if
(
node
.
child
=
=
=
null
|
|
node
.
tag
=
=
=
HostPortal
)
{
continue
siblings
;
}
else
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
}
}
if
(
!
(
node
.
effectTag
&
Placement
)
)
{
return
node
.
stateNode
;
}
}
}
function
commitPlacement
(
finishedWork
)
{
if
(
!
supportsMutation
)
{
return
;
}
var
parentFiber
=
getHostParentFiber
(
finishedWork
)
;
var
parent
=
void
0
;
var
isContainer
=
void
0
;
switch
(
parentFiber
.
tag
)
{
case
HostComponent
:
parent
=
parentFiber
.
stateNode
;
isContainer
=
false
;
break
;
case
HostRoot
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
case
HostPortal
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
default
:
reactProdInvariant
(
'
161
'
)
;
}
if
(
parentFiber
.
effectTag
&
ContentReset
)
{
resetTextContent
(
parent
)
;
parentFiber
.
effectTag
&
=
~
ContentReset
;
}
var
before
=
getHostSibling
(
finishedWork
)
;
var
node
=
finishedWork
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
if
(
before
)
{
if
(
isContainer
)
{
insertInContainerBefore
(
parent
node
.
stateNode
before
)
;
}
else
{
insertBefore
(
parent
node
.
stateNode
before
)
;
}
}
else
{
if
(
isContainer
)
{
appendChildToContainer
(
parent
node
.
stateNode
)
;
}
else
{
appendChild
(
parent
node
.
stateNode
)
;
}
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
finishedWork
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
finishedWork
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
unmountHostComponents
(
current
)
{
var
node
=
current
;
var
currentParentIsValid
=
false
;
var
currentParent
=
void
0
;
var
currentParentIsContainer
=
void
0
;
while
(
true
)
{
if
(
!
currentParentIsValid
)
{
var
parent
=
node
.
return
;
findParent
:
while
(
true
)
{
!
(
parent
!
=
=
null
)
?
reactProdInvariant
(
'
160
'
)
:
void
0
;
switch
(
parent
.
tag
)
{
case
HostComponent
:
currentParent
=
parent
.
stateNode
;
currentParentIsContainer
=
false
;
break
findParent
;
case
HostRoot
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
case
HostPortal
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
}
parent
=
parent
.
return
;
}
currentParentIsValid
=
true
;
}
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
commitNestedUnmounts
(
node
)
;
if
(
currentParentIsContainer
)
{
removeChildFromContainer
(
currentParent
node
.
stateNode
)
;
}
else
{
removeChild
(
currentParent
node
.
stateNode
)
;
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParent
=
node
.
stateNode
.
containerInfo
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
if
(
node
=
=
=
current
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
current
)
{
return
;
}
node
=
node
.
return
;
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParentIsValid
=
false
;
}
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
commitDeletion
(
current
)
{
if
(
supportsMutation
)
{
unmountHostComponents
(
current
)
;
}
else
{
commitNestedUnmounts
(
current
)
;
}
detachFiber
(
current
)
;
}
function
commitWork
(
current
finishedWork
)
{
if
(
!
supportsMutation
)
{
commitContainer
(
finishedWork
)
;
return
;
}
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
instance
!
=
null
)
{
var
newProps
=
finishedWork
.
memoizedProps
;
var
oldProps
=
current
!
=
=
null
?
current
.
memoizedProps
:
newProps
;
var
type
=
finishedWork
.
type
;
var
updatePayload
=
finishedWork
.
updateQueue
;
finishedWork
.
updateQueue
=
null
;
if
(
updatePayload
!
=
=
null
)
{
commitUpdate
(
instance
updatePayload
type
oldProps
newProps
finishedWork
)
;
}
}
return
;
}
case
HostText
:
{
!
(
finishedWork
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
162
'
)
:
void
0
;
var
textInstance
=
finishedWork
.
stateNode
;
var
newText
=
finishedWork
.
memoizedProps
;
var
oldText
=
current
!
=
=
null
?
current
.
memoizedProps
:
newText
;
commitTextUpdate
(
textInstance
oldText
newText
)
;
return
;
}
case
HostRoot
:
{
return
;
}
case
Profiler
:
{
if
(
enableProfilerTimer
)
{
var
onRender
=
finishedWork
.
memoizedProps
.
onRender
;
onRender
(
finishedWork
.
memoizedProps
.
id
current
=
=
=
null
?
'
mount
'
:
'
update
'
finishedWork
.
actualDuration
finishedWork
.
treeBaseTime
finishedWork
.
actualStartTime
getCommitTime
(
)
)
;
}
return
;
}
case
TimeoutComponent
:
{
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitResetTextContent
(
current
)
{
if
(
!
supportsMutation
)
{
return
;
}
resetTextContent
(
current
.
stateNode
)
;
}
function
createRootErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
CaptureUpdate
;
update
.
payload
=
{
element
:
null
}
;
var
error
=
errorInfo
.
value
;
update
.
callback
=
function
(
)
{
onUncaughtError
(
error
)
;
logError
(
fiber
errorInfo
)
;
}
;
return
update
;
}
function
createClassErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
CaptureUpdate
;
var
getDerivedStateFromCatch
=
fiber
.
type
.
getDerivedStateFromCatch
;
if
(
enableGetDerivedStateFromCatch
&
&
typeof
getDerivedStateFromCatch
=
=
=
'
function
'
)
{
var
error
=
errorInfo
.
value
;
update
.
payload
=
function
(
)
{
return
getDerivedStateFromCatch
(
error
)
;
}
;
}
var
inst
=
fiber
.
stateNode
;
if
(
inst
!
=
=
null
&
&
typeof
inst
.
componentDidCatch
=
=
=
'
function
'
)
{
update
.
callback
=
function
callback
(
)
{
if
(
!
enableGetDerivedStateFromCatch
|
|
getDerivedStateFromCatch
!
=
=
'
function
'
)
{
markLegacyErrorBoundaryAsFailed
(
this
)
;
}
var
error
=
errorInfo
.
value
;
var
stack
=
errorInfo
.
stack
;
logError
(
fiber
errorInfo
)
;
this
.
componentDidCatch
(
error
{
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
}
)
;
}
;
}
return
update
;
}
function
schedulePing
(
finishedWork
)
{
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
finishedWork
)
;
var
recoveryUpdate
=
createUpdate
(
expirationTime
)
;
enqueueUpdate
(
finishedWork
recoveryUpdate
expirationTime
)
;
scheduleWork
1
(
finishedWork
expirationTime
)
;
}
function
throwException
(
root
returnFiber
sourceFiber
value
renderIsExpired
renderExpirationTime
currentTimeMs
)
{
sourceFiber
.
effectTag
|
=
Incomplete
;
sourceFiber
.
firstEffect
=
sourceFiber
.
lastEffect
=
null
;
if
(
enableSuspense
&
&
value
!
=
=
null
&
&
typeof
value
=
=
=
'
object
'
&
&
typeof
value
.
then
=
=
=
'
function
'
)
{
var
thenable
=
value
;
var
expirationTimeMs
=
expirationTimeToMs
(
renderExpirationTime
)
;
var
startTimeMs
=
expirationTimeMs
-
5000
;
var
elapsedMs
=
currentTimeMs
-
startTimeMs
;
if
(
elapsedMs
<
0
)
{
elapsedMs
=
0
;
}
var
remainingTimeMs
=
expirationTimeMs
-
currentTimeMs
;
var
_workInProgress
=
returnFiber
;
var
earliestTimeoutMs
=
-
1
;
searchForEarliestTimeout
:
do
{
if
(
_workInProgress
.
tag
=
=
=
TimeoutComponent
)
{
var
current
=
_workInProgress
.
alternate
;
if
(
current
!
=
=
null
&
&
current
.
memoizedState
=
=
=
true
)
{
earliestTimeoutMs
=
0
;
break
searchForEarliestTimeout
;
}
var
timeoutPropMs
=
_workInProgress
.
pendingProps
.
ms
;
if
(
typeof
timeoutPropMs
=
=
=
'
number
'
)
{
if
(
timeoutPropMs
<
=
0
)
{
earliestTimeoutMs
=
0
;
break
searchForEarliestTimeout
;
}
else
if
(
earliestTimeoutMs
=
=
=
-
1
|
|
timeoutPropMs
<
earliestTimeoutMs
)
{
earliestTimeoutMs
=
timeoutPropMs
;
}
}
else
if
(
earliestTimeoutMs
=
=
=
-
1
)
{
earliestTimeoutMs
=
remainingTimeMs
;
}
}
_workInProgress
=
_workInProgress
.
return
;
}
while
(
_workInProgress
!
=
=
null
)
;
var
msUntilTimeout
=
earliestTimeoutMs
-
elapsedMs
;
if
(
renderExpirationTime
=
=
=
Never
|
|
msUntilTimeout
>
0
)
{
suspendRoot
(
root
thenable
msUntilTimeout
renderExpirationTime
)
;
var
onResolveOrReject
=
function
(
)
{
retrySuspendedRoot
(
root
renderExpirationTime
)
;
}
;
thenable
.
then
(
onResolveOrReject
onResolveOrReject
)
;
return
;
}
else
{
_workInProgress
=
returnFiber
;
do
{
switch
(
_workInProgress
.
tag
)
{
case
HostRoot
:
{
var
message
=
renderExpirationTime
=
=
=
Sync
?
'
A
synchronous
update
was
suspended
but
no
fallback
UI
'
+
'
was
provided
.
'
:
'
An
update
was
suspended
for
longer
than
the
timeout
'
+
'
but
no
fallback
UI
was
provided
.
'
;
value
=
new
Error
(
message
)
;
break
;
}
case
TimeoutComponent
:
{
if
(
(
_workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
)
{
_workInProgress
.
effectTag
|
=
ShouldCapture
;
var
_onResolveOrReject
=
schedulePing
.
bind
(
null
_workInProgress
)
;
thenable
.
then
(
_onResolveOrReject
_onResolveOrReject
)
;
return
;
}
break
;
}
}
_workInProgress
=
_workInProgress
.
return
;
}
while
(
_workInProgress
!
=
=
null
)
;
}
}
value
=
createCapturedValue
(
value
sourceFiber
)
;
var
workInProgress
=
returnFiber
;
do
{
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
{
var
_errorInfo
=
value
;
workInProgress
.
effectTag
|
=
ShouldCapture
;
var
update
=
createRootErrorUpdate
(
workInProgress
_errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
update
renderExpirationTime
)
;
return
;
}
case
ClassComponent
:
var
errorInfo
=
value
;
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
&
&
(
typeof
ctor
.
getDerivedStateFromCatch
=
=
=
'
function
'
&
&
enableGetDerivedStateFromCatch
|
|
instance
!
=
=
null
&
&
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
)
{
workInProgress
.
effectTag
|
=
ShouldCapture
;
var
_update
=
createClassErrorUpdate
(
workInProgress
errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
_update
renderExpirationTime
)
;
return
;
}
break
;
default
:
break
;
}
workInProgress
=
workInProgress
.
return
;
}
while
(
workInProgress
!
=
=
null
)
;
}
function
unwindWork
(
workInProgress
renderIsExpired
renderExpirationTime
)
{
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
recordElapsedActualRenderTime
(
workInProgress
)
;
}
}
switch
(
workInProgress
.
tag
)
{
case
ClassComponent
:
{
popContextProvider
(
workInProgress
)
;
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
_effectTag
=
workInProgress
.
effectTag
;
if
(
_effectTag
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
_effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
return
null
;
}
case
TimeoutComponent
:
{
var
_effectTag2
=
workInProgress
.
effectTag
;
if
(
_effectTag2
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
_effectTag2
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
return
null
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
return
null
;
default
:
return
null
;
}
}
function
unwindInterruptedWork
(
interruptedWork
)
{
if
(
enableProfilerTimer
)
{
if
(
interruptedWork
.
mode
&
ProfileMode
)
{
resumeActualRenderTimerIfPaused
(
)
;
recordElapsedActualRenderTime
(
interruptedWork
)
;
}
}
switch
(
interruptedWork
.
tag
)
{
case
ClassComponent
:
{
popContextProvider
(
interruptedWork
)
;
break
;
}
case
HostRoot
:
{
popHostContainer
(
interruptedWork
)
;
popTopLevelContextObject
(
interruptedWork
)
;
break
;
}
case
HostComponent
:
{
popHostContext
(
interruptedWork
)
;
break
;
}
case
HostPortal
:
popHostContainer
(
interruptedWork
)
;
break
;
case
ContextProvider
:
popProvider
(
interruptedWork
)
;
break
;
default
:
break
;
}
}
var
originalStartTimeMs
=
now
(
)
;
var
mostRecentCurrentTime
=
msToExpirationTime
(
0
)
;
var
mostRecentCurrentTimeMs
=
originalStartTimeMs
;
var
lastUniqueAsyncExpiration
=
0
;
var
expirationContext
=
NoWork
;
var
isWorking
=
false
;
var
nextUnitOfWork
=
null
;
var
nextRoot
=
null
;
var
nextRenderExpirationTime
=
NoWork
;
var
nextLatestTimeoutMs
=
-
1
;
var
nextRenderIsExpired
=
false
;
var
nextEffect
=
null
;
var
isCommitting
1
=
false
;
var
isRootReadyForCommit
=
false
;
var
legacyErrorBoundariesThatAlreadyFailed
=
null
;
var
interruptedBy
=
null
;
function
resetStack
(
)
{
if
(
nextUnitOfWork
!
=
=
null
)
{
var
interruptedWork
=
nextUnitOfWork
.
return
;
while
(
interruptedWork
!
=
=
null
)
{
unwindInterruptedWork
(
interruptedWork
)
;
interruptedWork
=
interruptedWork
.
return
;
}
}
nextRoot
=
null
;
nextRenderExpirationTime
=
NoWork
;
nextLatestTimeoutMs
=
-
1
;
nextRenderIsExpired
=
false
;
nextUnitOfWork
=
null
;
isRootReadyForCommit
=
false
;
}
function
commitAllHostEffects
(
)
{
while
(
nextEffect
!
=
=
null
)
{
recordEffect
(
)
;
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
ContentReset
)
{
commitResetTextContent
(
nextEffect
)
;
}
if
(
effectTag
&
Ref
)
{
var
current
=
nextEffect
.
alternate
;
if
(
current
!
=
=
null
)
{
commitDetachRef
(
current
)
;
}
}
var
primaryEffectTag
=
effectTag
&
(
Placement
|
Update
|
Deletion
)
;
switch
(
primaryEffectTag
)
{
case
Placement
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
break
;
}
case
PlacementAndUpdate
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
var
_current
=
nextEffect
.
alternate
;
commitWork
(
_current
nextEffect
)
;
break
;
}
case
Update
:
{
var
_current2
=
nextEffect
.
alternate
;
commitWork
(
_current2
nextEffect
)
;
break
;
}
case
Deletion
:
{
commitDeletion
(
nextEffect
)
;
break
;
}
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitBeforeMutationLifecycles
(
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
Snapshot
)
{
recordEffect
(
)
;
var
current
=
nextEffect
.
alternate
;
commitBeforeMutationLifeCycles
(
current
nextEffect
)
;
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitAllLifeCycles
(
finishedRoot
currentTime
committedExpirationTime
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
(
Update
|
Callback
)
)
{
recordEffect
(
)
;
var
current
=
nextEffect
.
alternate
;
commitLifeCycles
(
finishedRoot
current
nextEffect
currentTime
committedExpirationTime
)
;
}
if
(
effectTag
&
Ref
)
{
recordEffect
(
)
;
commitAttachRef
(
nextEffect
)
;
}
var
next
=
nextEffect
.
nextEffect
;
nextEffect
.
nextEffect
=
null
;
nextEffect
=
next
;
}
}
function
isAlreadyFailedLegacyErrorBoundary
(
instance
)
{
return
legacyErrorBoundariesThatAlreadyFailed
!
=
=
null
&
&
legacyErrorBoundariesThatAlreadyFailed
.
has
(
instance
)
;
}
function
markLegacyErrorBoundaryAsFailed
(
instance
)
{
if
(
legacyErrorBoundariesThatAlreadyFailed
=
=
=
null
)
{
legacyErrorBoundariesThatAlreadyFailed
=
new
Set
(
[
instance
]
)
;
}
else
{
legacyErrorBoundariesThatAlreadyFailed
.
add
(
instance
)
;
}
}
function
commitRoot
(
finishedWork
)
{
isWorking
=
true
;
isCommitting
1
=
true
;
startCommitTimer
(
)
;
var
root
=
finishedWork
.
stateNode
;
!
(
root
.
current
!
=
=
finishedWork
)
?
reactProdInvariant
(
'
177
'
)
:
void
0
;
var
committedExpirationTime
=
root
.
pendingCommitExpirationTime
;
!
(
committedExpirationTime
!
=
=
NoWork
)
?
reactProdInvariant
(
'
261
'
)
:
void
0
;
root
.
pendingCommitExpirationTime
=
NoWork
;
var
currentTime
=
recalculateCurrentTime
(
)
;
ReactCurrentOwner
.
current
=
null
;
var
firstEffect
=
void
0
;
if
(
finishedWork
.
effectTag
>
PerformedWork
)
{
if
(
finishedWork
.
lastEffect
!
=
=
null
)
{
finishedWork
.
lastEffect
.
nextEffect
=
finishedWork
;
firstEffect
=
finishedWork
.
firstEffect
;
}
else
{
firstEffect
=
finishedWork
;
}
}
else
{
firstEffect
=
finishedWork
.
firstEffect
;
}
prepareForCommit
(
root
.
containerInfo
)
;
nextEffect
=
firstEffect
;
startCommitSnapshotEffectsTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
didError
=
false
;
var
error
=
void
0
;
{
try
{
commitBeforeMutationLifecycles
(
)
;
}
catch
(
e
)
{
didError
=
true
;
error
=
e
;
}
}
if
(
didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
error
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
stopCommitSnapshotEffectsTimer
(
)
;
if
(
enableProfilerTimer
)
{
recordCommitTime
(
)
;
}
nextEffect
=
firstEffect
;
startCommitHostEffectsTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
_didError
=
false
;
var
_error
=
void
0
;
{
try
{
commitAllHostEffects
(
)
;
}
catch
(
e
)
{
_didError
=
true
;
_error
=
e
;
}
}
if
(
_didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
_error
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
stopCommitHostEffectsTimer
(
)
;
resetAfterCommit
(
root
.
containerInfo
)
;
root
.
current
=
finishedWork
;
nextEffect
=
firstEffect
;
startCommitLifeCyclesTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
_didError2
=
false
;
var
_error2
=
void
0
;
{
try
{
commitAllLifeCycles
(
root
currentTime
committedExpirationTime
)
;
}
catch
(
e
)
{
_didError2
=
true
;
_error2
=
e
;
}
}
if
(
_didError2
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
_error2
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
if
(
enableProfilerTimer
)
{
resetActualRenderTimer
(
)
;
}
isCommitting
1
=
false
;
isWorking
=
false
;
stopCommitLifeCyclesTimer
(
)
;
stopCommitTimer
(
)
;
if
(
typeof
onCommitRoot
=
=
=
'
function
'
)
{
onCommitRoot
(
finishedWork
.
stateNode
)
;
}
markCommittedPriorityLevels
(
root
currentTime
root
.
current
.
expirationTime
)
;
var
remainingTime
=
findNextPendingPriorityLevel
(
root
)
;
if
(
remainingTime
=
=
=
NoWork
)
{
legacyErrorBoundariesThatAlreadyFailed
=
null
;
}
return
remainingTime
;
}
function
resetExpirationTime
(
workInProgress
renderTime
)
{
if
(
renderTime
!
=
=
Never
&
&
workInProgress
.
expirationTime
=
=
=
Never
)
{
return
;
}
var
newExpirationTime
=
NoWork
;
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
case
ClassComponent
:
{
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
newExpirationTime
=
updateQueue
.
expirationTime
;
}
}
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
treeBaseTime
=
workInProgress
.
selfBaseTime
;
var
child
=
workInProgress
.
child
;
while
(
child
!
=
=
null
)
{
treeBaseTime
+
=
child
.
treeBaseTime
;
if
(
child
.
expirationTime
!
=
=
NoWork
&
&
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
child
.
expirationTime
)
)
{
newExpirationTime
=
child
.
expirationTime
;
}
child
=
child
.
sibling
;
}
workInProgress
.
treeBaseTime
=
treeBaseTime
;
}
else
{
var
_child
=
workInProgress
.
child
;
while
(
_child
!
=
=
null
)
{
if
(
_child
.
expirationTime
!
=
=
NoWork
&
&
(
newExpirationTime
=
=
=
NoWork
|
|
newExpirationTime
>
_child
.
expirationTime
)
)
{
newExpirationTime
=
_child
.
expirationTime
;
}
_child
=
_child
.
sibling
;
}
}
workInProgress
.
expirationTime
=
newExpirationTime
;
}
function
completeUnitOfWork
(
workInProgress
)
{
while
(
true
)
{
var
current
=
workInProgress
.
alternate
;
var
returnFiber
=
workInProgress
.
return
;
var
siblingFiber
=
workInProgress
.
sibling
;
if
(
(
workInProgress
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
var
next
=
completeWork
(
current
workInProgress
nextRenderExpirationTime
)
;
stopWorkTimer
(
workInProgress
)
;
resetExpirationTime
(
workInProgress
nextRenderExpirationTime
)
;
if
(
next
!
=
=
null
)
{
stopWorkTimer
(
workInProgress
)
;
return
next
;
}
if
(
returnFiber
!
=
=
null
&
&
(
returnFiber
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
if
(
returnFiber
.
firstEffect
=
=
=
null
)
{
returnFiber
.
firstEffect
=
workInProgress
.
firstEffect
;
}
if
(
workInProgress
.
lastEffect
!
=
=
null
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
.
firstEffect
;
}
returnFiber
.
lastEffect
=
workInProgress
.
lastEffect
;
}
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
>
PerformedWork
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
;
}
else
{
returnFiber
.
firstEffect
=
workInProgress
;
}
returnFiber
.
lastEffect
=
workInProgress
;
}
}
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
else
if
(
returnFiber
!
=
=
null
)
{
workInProgress
=
returnFiber
;
continue
;
}
else
{
isRootReadyForCommit
=
true
;
return
null
;
}
}
else
{
var
_next
=
unwindWork
(
workInProgress
nextRenderIsExpired
nextRenderExpirationTime
)
;
if
(
workInProgress
.
effectTag
&
DidCapture
)
{
stopFailedWorkTimer
(
workInProgress
)
;
}
else
{
stopWorkTimer
(
workInProgress
)
;
}
if
(
_next
!
=
=
null
)
{
stopWorkTimer
(
workInProgress
)
;
_next
.
effectTag
&
=
HostEffectMask
;
return
_next
;
}
if
(
returnFiber
!
=
=
null
)
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
null
;
returnFiber
.
effectTag
|
=
Incomplete
;
}
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
else
if
(
returnFiber
!
=
=
null
)
{
workInProgress
=
returnFiber
;
continue
;
}
else
{
return
null
;
}
}
}
return
null
;
}
function
performUnitOfWork
(
workInProgress
)
{
var
current
=
workInProgress
.
alternate
;
startWorkTimer
(
workInProgress
)
;
var
next
=
void
0
;
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
startBaseRenderTimer
(
)
;
}
next
=
beginWork
(
current
workInProgress
nextRenderExpirationTime
)
;
if
(
workInProgress
.
mode
&
ProfileMode
)
{
recordElapsedBaseRenderTimeIfRunning
(
workInProgress
)
;
stopBaseRenderTimerIfRunning
(
)
;
}
}
else
{
next
=
beginWork
(
current
workInProgress
nextRenderExpirationTime
)
;
}
if
(
next
=
=
=
null
)
{
next
=
completeUnitOfWork
(
workInProgress
)
;
}
ReactCurrentOwner
.
current
=
null
;
return
next
;
}
function
workLoop
(
isAsync
)
{
if
(
!
isAsync
)
{
while
(
nextUnitOfWork
!
=
=
null
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
else
{
while
(
nextUnitOfWork
!
=
=
null
&
&
!
shouldYield
(
)
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
if
(
enableProfilerTimer
)
{
pauseActualRenderTimerIfRunning
(
)
;
}
}
}
function
renderRoot
(
root
expirationTime
isAsync
)
{
!
!
isWorking
?
reactProdInvariant
(
'
243
'
)
:
void
0
;
isWorking
=
true
;
if
(
expirationTime
!
=
=
nextRenderExpirationTime
|
|
root
!
=
=
nextRoot
|
|
nextUnitOfWork
=
=
=
null
)
{
resetStack
(
)
;
nextRoot
=
root
;
nextRenderExpirationTime
=
expirationTime
;
nextLatestTimeoutMs
=
-
1
;
nextUnitOfWork
=
createWorkInProgress
(
nextRoot
.
current
null
nextRenderExpirationTime
)
;
root
.
pendingCommitExpirationTime
=
NoWork
;
}
var
didFatal
=
false
;
nextRenderIsExpired
=
!
isAsync
|
|
nextRenderExpirationTime
<
=
mostRecentCurrentTime
;
startWorkLoopTimer
(
nextUnitOfWork
)
;
do
{
try
{
workLoop
(
isAsync
)
;
}
catch
(
thrownValue
)
{
if
(
enableProfilerTimer
)
{
stopBaseRenderTimerIfRunning
(
)
;
}
if
(
nextUnitOfWork
=
=
=
null
)
{
didFatal
=
true
;
onUncaughtError
(
thrownValue
)
;
}
else
{
!
(
nextUnitOfWork
!
=
=
null
)
?
reactProdInvariant
(
'
271
'
)
:
void
0
;
var
sourceFiber
=
nextUnitOfWork
;
var
returnFiber
=
sourceFiber
.
return
;
if
(
returnFiber
=
=
=
null
)
{
didFatal
=
true
;
onUncaughtError
(
thrownValue
)
;
break
;
}
throwException
(
root
returnFiber
sourceFiber
thrownValue
nextRenderIsExpired
nextRenderExpirationTime
mostRecentCurrentTimeMs
)
;
nextUnitOfWork
=
completeUnitOfWork
(
sourceFiber
)
;
}
}
break
;
}
while
(
true
)
;
var
didCompleteRoot
=
false
;
isWorking
=
false
;
if
(
didFatal
)
{
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
return
null
;
}
else
if
(
nextUnitOfWork
=
=
=
null
)
{
if
(
isRootReadyForCommit
)
{
didCompleteRoot
=
true
;
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
root
.
pendingCommitExpirationTime
=
expirationTime
;
var
finishedWork
=
root
.
current
.
alternate
;
return
finishedWork
;
}
else
{
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
!
!
nextRenderIsExpired
?
reactProdInvariant
(
'
262
'
)
:
void
0
;
markSuspendedPriorityLevel
(
root
expirationTime
)
;
if
(
nextLatestTimeoutMs
>
=
0
)
{
setTimeout
(
function
(
)
{
retrySuspendedRoot
(
root
expirationTime
)
;
}
nextLatestTimeoutMs
)
;
}
var
firstUnblockedExpirationTime
=
findNextPendingPriorityLevel
(
root
)
;
onBlock
(
firstUnblockedExpirationTime
)
;
return
null
;
}
}
else
{
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
interruptedBy
=
null
;
return
null
;
}
}
function
dispatch
(
sourceFiber
value
expirationTime
)
{
!
(
!
isWorking
|
|
isCommitting
1
)
?
reactProdInvariant
(
'
263
'
)
:
void
0
;
var
fiber
=
sourceFiber
.
return
;
while
(
fiber
!
=
=
null
)
{
switch
(
fiber
.
tag
)
{
case
ClassComponent
:
var
ctor
=
fiber
.
type
;
var
instance
=
fiber
.
stateNode
;
if
(
typeof
ctor
.
getDerivedStateFromCatch
=
=
=
'
function
'
|
|
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
{
var
errorInfo
=
createCapturedValue
(
value
sourceFiber
)
;
var
update
=
createClassErrorUpdate
(
fiber
errorInfo
expirationTime
)
;
enqueueUpdate
(
fiber
update
expirationTime
)
;
scheduleWork
1
(
fiber
expirationTime
)
;
return
;
}
break
;
case
HostRoot
:
{
var
_errorInfo
=
createCapturedValue
(
value
sourceFiber
)
;
var
_update
=
createRootErrorUpdate
(
fiber
_errorInfo
expirationTime
)
;
enqueueUpdate
(
fiber
_update
expirationTime
)
;
scheduleWork
1
(
fiber
expirationTime
)
;
return
;
}
}
fiber
=
fiber
.
return
;
}
if
(
sourceFiber
.
tag
=
=
=
HostRoot
)
{
var
rootFiber
=
sourceFiber
;
var
_errorInfo2
=
createCapturedValue
(
value
rootFiber
)
;
var
_update2
=
createRootErrorUpdate
(
rootFiber
_errorInfo2
expirationTime
)
;
enqueueUpdate
(
rootFiber
_update2
expirationTime
)
;
scheduleWork
1
(
rootFiber
expirationTime
)
;
}
}
function
captureCommitPhaseError
(
fiber
error
)
{
return
dispatch
(
fiber
error
Sync
)
;
}
function
computeAsyncExpiration
(
currentTime
)
{
var
expirationMs
=
5000
;
var
bucketSizeMs
=
250
;
return
computeExpirationBucket
(
currentTime
expirationMs
bucketSizeMs
)
;
}
function
computeInteractiveExpiration
(
currentTime
)
{
var
expirationMs
=
void
0
;
{
expirationMs
=
150
;
}
var
bucketSizeMs
=
100
;
return
computeExpirationBucket
(
currentTime
expirationMs
bucketSizeMs
)
;
}
function
computeUniqueAsyncExpiration
(
)
{
var
currentTime
=
recalculateCurrentTime
(
)
;
var
result
=
computeAsyncExpiration
(
currentTime
)
;
if
(
result
<
=
lastUniqueAsyncExpiration
)
{
result
=
lastUniqueAsyncExpiration
+
1
;
}
lastUniqueAsyncExpiration
=
result
;
return
lastUniqueAsyncExpiration
;
}
function
computeExpirationForFiber
(
currentTime
fiber
)
{
var
expirationTime
=
void
0
;
if
(
expirationContext
!
=
=
NoWork
)
{
expirationTime
=
expirationContext
;
}
else
if
(
isWorking
)
{
if
(
isCommitting
1
)
{
expirationTime
=
Sync
;
}
else
{
expirationTime
=
nextRenderExpirationTime
;
}
}
else
{
if
(
fiber
.
mode
&
AsyncMode
)
{
if
(
isBatchingInteractiveUpdates
)
{
expirationTime
=
computeInteractiveExpiration
(
currentTime
)
;
}
else
{
expirationTime
=
computeAsyncExpiration
(
currentTime
)
;
}
}
else
{
expirationTime
=
Sync
;
}
}
if
(
isBatchingInteractiveUpdates
)
{
if
(
lowestPendingInteractiveExpirationTime
=
=
=
NoWork
|
|
expirationTime
>
lowestPendingInteractiveExpirationTime
)
{
lowestPendingInteractiveExpirationTime
=
expirationTime
;
}
}
return
expirationTime
;
}
function
suspendRoot
(
root
thenable
timeoutMs
suspendedTime
)
{
if
(
timeoutMs
>
=
0
&
&
nextLatestTimeoutMs
<
timeoutMs
)
{
nextLatestTimeoutMs
=
timeoutMs
;
}
}
function
retrySuspendedRoot
(
root
suspendedTime
)
{
markPingedPriorityLevel
(
root
suspendedTime
)
;
var
retryTime
=
findNextPendingPriorityLevel
(
root
)
;
if
(
retryTime
!
=
=
NoWork
)
{
requestRetry
(
root
retryTime
)
;
}
}
function
scheduleWork
1
(
fiber
expirationTime
)
{
recordScheduleUpdate
(
)
;
var
node
=
fiber
;
while
(
node
!
=
=
null
)
{
if
(
node
.
expirationTime
=
=
=
NoWork
|
|
node
.
expirationTime
>
expirationTime
)
{
node
.
expirationTime
=
expirationTime
;
}
if
(
node
.
alternate
!
=
=
null
)
{
if
(
node
.
alternate
.
expirationTime
=
=
=
NoWork
|
|
node
.
alternate
.
expirationTime
>
expirationTime
)
{
node
.
alternate
.
expirationTime
=
expirationTime
;
}
}
if
(
node
.
return
=
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostRoot
)
{
var
root
=
node
.
stateNode
;
if
(
!
isWorking
&
&
nextRenderExpirationTime
!
=
=
NoWork
&
&
expirationTime
<
nextRenderExpirationTime
)
{
interruptedBy
=
fiber
;
resetStack
(
)
;
}
markPendingPriorityLevel
(
root
expirationTime
)
;
var
nextExpirationTimeToWorkOn
=
findNextPendingPriorityLevel
(
root
)
;
if
(
!
isWorking
|
|
isCommitting
1
|
|
nextRoot
!
=
=
root
)
{
requestWork
(
root
nextExpirationTimeToWorkOn
)
;
}
if
(
nestedUpdateCount
>
NESTED_UPDATE_LIMIT
)
{
reactProdInvariant
(
'
185
'
)
;
}
}
else
{
return
;
}
}
node
=
node
.
return
;
}
}
function
recalculateCurrentTime
(
)
{
mostRecentCurrentTimeMs
=
now
(
)
-
originalStartTimeMs
;
mostRecentCurrentTime
=
msToExpirationTime
(
mostRecentCurrentTimeMs
)
;
return
mostRecentCurrentTime
;
}
function
deferredUpdates
(
fn
)
{
var
previousExpirationContext
=
expirationContext
;
var
currentTime
=
recalculateCurrentTime
(
)
;
expirationContext
=
computeAsyncExpiration
(
currentTime
)
;
try
{
return
fn
(
)
;
}
finally
{
expirationContext
=
previousExpirationContext
;
}
}
function
syncUpdates
(
fn
a
b
c
d
)
{
var
previousExpirationContext
=
expirationContext
;
expirationContext
=
Sync
;
try
{
return
fn
(
a
b
c
d
)
;
}
finally
{
expirationContext
=
previousExpirationContext
;
}
}
var
firstScheduledRoot
=
null
;
var
lastScheduledRoot
=
null
;
var
callbackExpirationTime
=
NoWork
;
var
callbackID
=
void
0
;
var
isRendering
=
false
;
var
nextFlushedRoot
=
null
;
var
nextFlushedExpirationTime
=
NoWork
;
var
lowestPendingInteractiveExpirationTime
=
NoWork
;
var
deadlineDidExpire
=
false
;
var
hasUnhandledError
=
false
;
var
unhandledError
=
null
;
var
deadline
=
null
;
var
isBatchingUpdates
=
false
;
var
isUnbatchingUpdates
=
false
;
var
isBatchingInteractiveUpdates
=
false
;
var
completedBatches
=
null
;
var
NESTED_UPDATE_LIMIT
=
1000
;
var
nestedUpdateCount
=
0
;
var
timeHeuristicForUnitOfWork
=
1
;
function
scheduleCallbackWithExpiration
(
expirationTime
)
{
if
(
callbackExpirationTime
!
=
=
NoWork
)
{
if
(
expirationTime
>
callbackExpirationTime
)
{
return
;
}
else
{
if
(
callbackID
!
=
=
null
)
{
cancelDeferredCallback
(
callbackID
)
;
}
}
}
else
{
startRequestCallbackTimer
(
)
;
}
var
currentMs
=
now
(
)
-
originalStartTimeMs
;
var
expirationMs
=
expirationTimeToMs
(
expirationTime
)
;
var
timeout
=
expirationMs
-
currentMs
;
callbackExpirationTime
=
expirationTime
;
callbackID
=
scheduleDeferredCallback
(
performAsyncWork
{
timeout
:
timeout
}
)
;
}
function
requestRetry
(
root
expirationTime
)
{
if
(
root
.
remainingExpirationTime
=
=
=
NoWork
|
|
root
.
remainingExpirationTime
<
expirationTime
)
{
requestWork
(
root
expirationTime
)
;
}
}
function
requestWork
(
root
expirationTime
)
{
addRootToSchedule
(
root
expirationTime
)
;
if
(
isRendering
)
{
return
;
}
if
(
isBatchingUpdates
)
{
if
(
isUnbatchingUpdates
)
{
nextFlushedRoot
=
root
;
nextFlushedExpirationTime
=
Sync
;
performWorkOnRoot
(
root
Sync
false
)
;
}
return
;
}
if
(
expirationTime
=
=
=
Sync
)
{
performSyncWork
(
)
;
}
else
{
scheduleCallbackWithExpiration
(
expirationTime
)
;
}
}
function
addRootToSchedule
(
root
expirationTime
)
{
if
(
root
.
nextScheduledRoot
=
=
=
null
)
{
root
.
remainingExpirationTime
=
expirationTime
;
if
(
lastScheduledRoot
=
=
=
null
)
{
firstScheduledRoot
=
lastScheduledRoot
=
root
;
root
.
nextScheduledRoot
=
root
;
}
else
{
lastScheduledRoot
.
nextScheduledRoot
=
root
;
lastScheduledRoot
=
root
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
}
}
else
{
var
remainingExpirationTime
=
root
.
remainingExpirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
|
|
expirationTime
<
remainingExpirationTime
)
{
root
.
remainingExpirationTime
=
expirationTime
;
}
}
}
function
findHighestPriorityRoot
(
)
{
var
highestPriorityWork
=
NoWork
;
var
highestPriorityRoot
=
null
;
if
(
lastScheduledRoot
!
=
=
null
)
{
var
previousScheduledRoot
=
lastScheduledRoot
;
var
root
=
firstScheduledRoot
;
while
(
root
!
=
=
null
)
{
var
remainingExpirationTime
=
root
.
remainingExpirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
)
{
!
(
previousScheduledRoot
!
=
=
null
&
&
lastScheduledRoot
!
=
=
null
)
?
reactProdInvariant
(
'
244
'
)
:
void
0
;
if
(
root
=
=
=
root
.
nextScheduledRoot
)
{
root
.
nextScheduledRoot
=
null
;
firstScheduledRoot
=
lastScheduledRoot
=
null
;
break
;
}
else
if
(
root
=
=
=
firstScheduledRoot
)
{
var
next
=
root
.
nextScheduledRoot
;
firstScheduledRoot
=
next
;
lastScheduledRoot
.
nextScheduledRoot
=
next
;
root
.
nextScheduledRoot
=
null
;
}
else
if
(
root
=
=
=
lastScheduledRoot
)
{
lastScheduledRoot
=
previousScheduledRoot
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
break
;
}
else
{
previousScheduledRoot
.
nextScheduledRoot
=
root
.
nextScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
}
root
=
previousScheduledRoot
.
nextScheduledRoot
;
}
else
{
if
(
highestPriorityWork
=
=
=
NoWork
|
|
remainingExpirationTime
<
highestPriorityWork
)
{
highestPriorityWork
=
remainingExpirationTime
;
highestPriorityRoot
=
root
;
}
if
(
root
=
=
=
lastScheduledRoot
)
{
break
;
}
previousScheduledRoot
=
root
;
root
=
root
.
nextScheduledRoot
;
}
}
}
var
previousFlushedRoot
=
nextFlushedRoot
;
if
(
previousFlushedRoot
!
=
=
null
&
&
previousFlushedRoot
=
=
=
highestPriorityRoot
&
&
highestPriorityWork
=
=
=
Sync
)
{
nestedUpdateCount
+
+
;
}
else
{
nestedUpdateCount
=
0
;
}
nextFlushedRoot
=
highestPriorityRoot
;
nextFlushedExpirationTime
=
highestPriorityWork
;
}
function
performAsyncWork
(
dl
)
{
performWork
(
NoWork
true
dl
)
;
}
function
performSyncWork
(
)
{
performWork
(
Sync
false
null
)
;
}
function
performWork
(
minExpirationTime
isAsync
dl
)
{
deadline
=
dl
;
findHighestPriorityRoot
(
)
;
if
(
enableProfilerTimer
)
{
resumeActualRenderTimerIfPaused
(
)
;
}
if
(
enableUserTimingAPI
&
&
deadline
!
=
=
null
)
{
var
didExpire
=
nextFlushedExpirationTime
<
recalculateCurrentTime
(
)
;
var
timeout
=
expirationTimeToMs
(
nextFlushedExpirationTime
)
;
stopRequestCallbackTimer
(
didExpire
timeout
)
;
}
if
(
isAsync
)
{
while
(
nextFlushedRoot
!
=
=
null
&
&
nextFlushedExpirationTime
!
=
=
NoWork
&
&
(
minExpirationTime
=
=
=
NoWork
|
|
minExpirationTime
>
=
nextFlushedExpirationTime
)
&
&
(
!
deadlineDidExpire
|
|
recalculateCurrentTime
(
)
>
=
nextFlushedExpirationTime
)
)
{
recalculateCurrentTime
(
)
;
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
!
deadlineDidExpire
)
;
findHighestPriorityRoot
(
)
;
}
}
else
{
while
(
nextFlushedRoot
!
=
=
null
&
&
nextFlushedExpirationTime
!
=
=
NoWork
&
&
(
minExpirationTime
=
=
=
NoWork
|
|
minExpirationTime
>
=
nextFlushedExpirationTime
)
)
{
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
false
)
;
findHighestPriorityRoot
(
)
;
}
}
if
(
deadline
!
=
=
null
)
{
callbackExpirationTime
=
NoWork
;
callbackID
=
null
;
}
if
(
nextFlushedExpirationTime
!
=
=
NoWork
)
{
scheduleCallbackWithExpiration
(
nextFlushedExpirationTime
)
;
}
deadline
=
null
;
deadlineDidExpire
=
false
;
finishRendering
(
)
;
}
function
flushRoot
(
root
expirationTime
)
{
!
!
isRendering
?
reactProdInvariant
(
'
253
'
)
:
void
0
;
nextFlushedRoot
=
root
;
nextFlushedExpirationTime
=
expirationTime
;
performWorkOnRoot
(
root
expirationTime
false
)
;
performSyncWork
(
)
;
finishRendering
(
)
;
}
function
finishRendering
(
)
{
nestedUpdateCount
=
0
;
if
(
completedBatches
!
=
=
null
)
{
var
batches
=
completedBatches
;
completedBatches
=
null
;
for
(
var
i
=
0
;
i
<
batches
.
length
;
i
+
+
)
{
var
batch
=
batches
[
i
]
;
try
{
batch
.
_onComplete
(
)
;
}
catch
(
error
)
{
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
}
}
if
(
hasUnhandledError
)
{
var
error
=
unhandledError
;
unhandledError
=
null
;
hasUnhandledError
=
false
;
throw
error
;
}
}
function
performWorkOnRoot
(
root
expirationTime
isAsync
)
{
!
!
isRendering
?
reactProdInvariant
(
'
245
'
)
:
void
0
;
isRendering
=
true
;
if
(
!
isAsync
)
{
var
finishedWork
=
root
.
finishedWork
;
if
(
finishedWork
!
=
=
null
)
{
completeRoot
(
root
finishedWork
expirationTime
)
;
}
else
{
finishedWork
=
renderRoot
(
root
expirationTime
false
)
;
if
(
finishedWork
!
=
=
null
)
{
completeRoot
(
root
finishedWork
expirationTime
)
;
}
}
}
else
{
var
_finishedWork
=
root
.
finishedWork
;
if
(
_finishedWork
!
=
=
null
)
{
completeRoot
(
root
_finishedWork
expirationTime
)
;
}
else
{
_finishedWork
=
renderRoot
(
root
expirationTime
true
)
;
if
(
_finishedWork
!
=
=
null
)
{
if
(
!
shouldYield
(
)
)
{
completeRoot
(
root
_finishedWork
expirationTime
)
;
}
else
{
root
.
finishedWork
=
_finishedWork
;
if
(
enableProfilerTimer
)
{
pauseActualRenderTimerIfRunning
(
)
;
}
}
}
}
}
isRendering
=
false
;
}
function
completeRoot
(
root
finishedWork
expirationTime
)
{
var
firstBatch
=
root
.
firstBatch
;
if
(
firstBatch
!
=
=
null
&
&
firstBatch
.
_expirationTime
<
=
expirationTime
)
{
if
(
completedBatches
=
=
=
null
)
{
completedBatches
=
[
firstBatch
]
;
}
else
{
completedBatches
.
push
(
firstBatch
)
;
}
if
(
firstBatch
.
_defer
)
{
root
.
finishedWork
=
finishedWork
;
root
.
remainingExpirationTime
=
NoWork
;
return
;
}
}
root
.
finishedWork
=
null
;
root
.
remainingExpirationTime
=
commitRoot
(
finishedWork
)
;
}
function
shouldYield
(
)
{
if
(
deadline
=
=
=
null
)
{
return
false
;
}
if
(
deadline
.
timeRemaining
(
)
>
timeHeuristicForUnitOfWork
)
{
return
false
;
}
deadlineDidExpire
=
true
;
return
true
;
}
function
onUncaughtError
(
error
)
{
!
(
nextFlushedRoot
!
=
=
null
)
?
reactProdInvariant
(
'
246
'
)
:
void
0
;
nextFlushedRoot
.
remainingExpirationTime
=
NoWork
;
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
function
onBlock
(
remainingExpirationTime
)
{
!
(
nextFlushedRoot
!
=
=
null
)
?
reactProdInvariant
(
'
246
'
)
:
void
0
;
nextFlushedRoot
.
remainingExpirationTime
=
remainingExpirationTime
;
}
function
batchedUpdates
1
(
fn
a
)
{
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
fn
(
a
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performSyncWork
(
)
;
}
}
}
function
unbatchedUpdates
(
fn
a
)
{
if
(
isBatchingUpdates
&
&
!
isUnbatchingUpdates
)
{
isUnbatchingUpdates
=
true
;
try
{
return
fn
(
a
)
;
}
finally
{
isUnbatchingUpdates
=
false
;
}
}
return
fn
(
a
)
;
}
function
flushSync
(
fn
a
)
{
!
!
isRendering
?
reactProdInvariant
(
'
187
'
)
:
void
0
;
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
syncUpdates
(
fn
a
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
performSyncWork
(
)
;
}
}
function
interactiveUpdates
1
(
fn
a
b
)
{
if
(
isBatchingInteractiveUpdates
)
{
return
fn
(
a
b
)
;
}
if
(
!
isBatchingUpdates
&
&
!
isRendering
&
&
lowestPendingInteractiveExpirationTime
!
=
=
NoWork
)
{
performWork
(
lowestPendingInteractiveExpirationTime
false
null
)
;
lowestPendingInteractiveExpirationTime
=
NoWork
;
}
var
previousIsBatchingInteractiveUpdates
=
isBatchingInteractiveUpdates
;
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingInteractiveUpdates
=
true
;
isBatchingUpdates
=
true
;
try
{
return
fn
(
a
b
)
;
}
finally
{
isBatchingInteractiveUpdates
=
previousIsBatchingInteractiveUpdates
;
isBatchingUpdates
=
previousIsBatchingUpdates
;
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performSyncWork
(
)
;
}
}
}
function
flushInteractiveUpdates
1
(
)
{
if
(
!
isRendering
&
&
lowestPendingInteractiveExpirationTime
!
=
=
NoWork
)
{
performWork
(
lowestPendingInteractiveExpirationTime
false
null
)
;
lowestPendingInteractiveExpirationTime
=
NoWork
;
}
}
function
flushControlled
(
fn
)
{
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
syncUpdates
(
fn
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performWork
(
Sync
false
null
)
;
}
}
}
function
getContextForSubtree
(
parentComponent
)
{
if
(
!
parentComponent
)
{
return
emptyObject_1
;
}
var
fiber
=
get
(
parentComponent
)
;
var
parentContext
=
findCurrentUnmaskedContext
(
fiber
)
;
return
isContextProvider
(
fiber
)
?
processChildContext
(
fiber
parentContext
)
:
parentContext
;
}
function
scheduleRootUpdate
(
current
element
expirationTime
callback
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
payload
=
{
element
:
element
}
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
enqueueUpdate
(
current
update
expirationTime
)
;
scheduleWork
1
(
current
expirationTime
)
;
return
expirationTime
;
}
function
updateContainerAtExpirationTime
(
element
container
parentComponent
expirationTime
callback
)
{
var
current
=
container
.
current
;
var
context
=
getContextForSubtree
(
parentComponent
)
;
if
(
container
.
context
=
=
=
null
)
{
container
.
context
=
context
;
}
else
{
container
.
pendingContext
=
context
;
}
return
scheduleRootUpdate
(
current
element
expirationTime
callback
)
;
}
function
findHostInstance
(
component
)
{
var
fiber
=
get
(
component
)
;
if
(
fiber
=
=
=
undefined
)
{
if
(
typeof
component
.
render
=
=
=
'
function
'
)
{
reactProdInvariant
(
'
188
'
)
;
}
else
{
reactProdInvariant
(
'
268
'
Object
.
keys
(
component
)
)
;
}
}
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
function
createContainer
(
containerInfo
isAsync
hydrate
)
{
return
createFiberRoot
(
containerInfo
isAsync
hydrate
)
;
}
function
updateContainer
(
element
container
parentComponent
callback
)
{
var
current
=
container
.
current
;
var
currentTime
=
recalculateCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
current
)
;
return
updateContainerAtExpirationTime
(
element
container
parentComponent
expirationTime
callback
)
;
}
function
getPublicRootInstance
(
container
)
{
var
containerFiber
=
container
.
current
;
if
(
!
containerFiber
.
child
)
{
return
null
;
}
switch
(
containerFiber
.
child
.
tag
)
{
case
HostComponent
:
return
getPublicInstance
(
containerFiber
.
child
.
stateNode
)
;
default
:
return
containerFiber
.
child
.
stateNode
;
}
}
function
findHostInstanceWithNoPortals
(
fiber
)
{
var
hostFiber
=
findCurrentHostFiberWithNoPortals
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
function
injectIntoDevTools
(
devToolsConfig
)
{
var
findFiberByHostInstance
=
devToolsConfig
.
findFiberByHostInstance
;
return
injectInternals
(
_assign
(
{
}
devToolsConfig
{
findHostInstanceByFiber
:
function
(
fiber
)
{
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
findFiberByHostInstance
:
function
(
instance
)
{
if
(
!
findFiberByHostInstance
)
{
return
null
;
}
return
findFiberByHostInstance
(
instance
)
;
}
}
)
)
;
}
var
DOMRenderer
=
(
{
updateContainerAtExpirationTime
:
updateContainerAtExpirationTime
createContainer
:
createContainer
updateContainer
:
updateContainer
flushRoot
:
flushRoot
requestWork
:
requestWork
computeUniqueAsyncExpiration
:
computeUniqueAsyncExpiration
batchedUpdates
:
batchedUpdates
1
unbatchedUpdates
:
unbatchedUpdates
deferredUpdates
:
deferredUpdates
syncUpdates
:
syncUpdates
interactiveUpdates
:
interactiveUpdates
1
flushInteractiveUpdates
:
flushInteractiveUpdates
1
flushControlled
:
flushControlled
flushSync
:
flushSync
getPublicRootInstance
:
getPublicRootInstance
findHostInstance
:
findHostInstance
findHostInstanceWithNoPortals
:
findHostInstanceWithNoPortals
injectIntoDevTools
:
injectIntoDevTools
}
)
;
function
createPortal
1
(
children
containerInfo
implementation
)
{
var
key
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
null
;
return
{
typeof
:
REACT_PORTAL_TYPE
key
:
key
=
=
null
?
null
:
'
'
+
key
children
:
children
containerInfo
:
containerInfo
implementation
:
implementation
}
;
}
var
ReactVersion
=
'
16
.
4
.
1
'
;
injection
2
.
injectFiberControlledHostComponent
(
ReactDOMFiberComponent
)
;
function
ReactBatch
(
root
)
{
var
expirationTime
=
computeUniqueAsyncExpiration
(
)
;
this
.
_expirationTime
=
expirationTime
;
this
.
_root
=
root
;
this
.
_next
=
null
;
this
.
_callbacks
=
null
;
this
.
_didComplete
=
false
;
this
.
_hasChildren
=
false
;
this
.
_children
=
null
;
this
.
_defer
=
true
;
}
ReactBatch
.
prototype
.
render
=
function
(
children
)
{
!
this
.
_defer
?
reactProdInvariant
(
'
250
'
)
:
void
0
;
this
.
_hasChildren
=
true
;
this
.
_children
=
children
;
var
internalRoot
=
this
.
_root
.
_internalRoot
;
var
expirationTime
=
this
.
_expirationTime
;
var
work
=
new
ReactWork
(
)
;
updateContainerAtExpirationTime
(
children
internalRoot
null
expirationTime
work
.
_onCommit
)
;
return
work
;
}
;
ReactBatch
.
prototype
.
then
=
function
(
onComplete
)
{
if
(
this
.
_didComplete
)
{
onComplete
(
)
;
return
;
}
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
callbacks
=
this
.
_callbacks
=
[
]
;
}
callbacks
.
push
(
onComplete
)
;
}
;
ReactBatch
.
prototype
.
commit
=
function
(
)
{
var
internalRoot
=
this
.
_root
.
_internalRoot
;
var
firstBatch
=
internalRoot
.
firstBatch
;
!
(
this
.
_defer
&
&
firstBatch
!
=
=
null
)
?
reactProdInvariant
(
'
251
'
)
:
void
0
;
if
(
!
this
.
_hasChildren
)
{
this
.
_next
=
null
;
this
.
_defer
=
false
;
return
;
}
var
expirationTime
=
this
.
_expirationTime
;
if
(
firstBatch
!
=
=
this
)
{
if
(
this
.
_hasChildren
)
{
expirationTime
=
this
.
_expirationTime
=
firstBatch
.
_expirationTime
;
this
.
render
(
this
.
_children
)
;
}
var
previous
=
null
;
var
batch
=
firstBatch
;
while
(
batch
!
=
=
this
)
{
previous
=
batch
;
batch
=
batch
.
_next
;
}
!
(
previous
!
=
=
null
)
?
reactProdInvariant
(
'
251
'
)
:
void
0
;
previous
.
_next
=
batch
.
_next
;
this
.
_next
=
firstBatch
;
firstBatch
=
internalRoot
.
firstBatch
=
this
;
}
this
.
_defer
=
false
;
flushRoot
(
internalRoot
expirationTime
)
;
var
next
=
this
.
_next
;
this
.
_next
=
null
;
firstBatch
=
internalRoot
.
firstBatch
=
next
;
if
(
firstBatch
!
=
=
null
&
&
firstBatch
.
_hasChildren
)
{
firstBatch
.
render
(
firstBatch
.
_children
)
;
}
}
;
ReactBatch
.
prototype
.
_onComplete
=
function
(
)
{
if
(
this
.
_didComplete
)
{
return
;
}
this
.
_didComplete
=
true
;
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
return
;
}
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
var
_callback
=
callbacks
[
i
]
;
_callback
(
)
;
}
}
;
function
ReactWork
(
)
{
this
.
_callbacks
=
null
;
this
.
_didCommit
=
false
;
this
.
_onCommit
=
this
.
_onCommit
.
bind
(
this
)
;
}
ReactWork
.
prototype
.
then
=
function
(
onCommit
)
{
if
(
this
.
_didCommit
)
{
onCommit
(
)
;
return
;
}
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
callbacks
=
this
.
_callbacks
=
[
]
;
}
callbacks
.
push
(
onCommit
)
;
}
;
ReactWork
.
prototype
.
_onCommit
=
function
(
)
{
if
(
this
.
_didCommit
)
{
return
;
}
this
.
_didCommit
=
true
;
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
return
;
}
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
var
_callback2
=
callbacks
[
i
]
;
!
(
typeof
_callback2
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
191
'
_callback2
)
:
void
0
;
_callback2
(
)
;
}
}
;
function
ReactRoot
(
container
isAsync
hydrate
)
{
var
root
=
createContainer
(
container
isAsync
hydrate
)
;
this
.
_internalRoot
=
root
;
}
ReactRoot
.
prototype
.
render
=
function
(
children
callback
)
{
var
root
=
this
.
_internalRoot
;
var
work
=
new
ReactWork
(
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
work
.
then
(
callback
)
;
}
updateContainer
(
children
root
null
work
.
_onCommit
)
;
return
work
;
}
;
ReactRoot
.
prototype
.
unmount
=
function
(
callback
)
{
var
root
=
this
.
_internalRoot
;
var
work
=
new
ReactWork
(
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
work
.
then
(
callback
)
;
}
updateContainer
(
null
root
null
work
.
_onCommit
)
;
return
work
;
}
;
ReactRoot
.
prototype
.
legacy_renderSubtreeIntoContainer
=
function
(
parentComponent
children
callback
)
{
var
root
=
this
.
_internalRoot
;
var
work
=
new
ReactWork
(
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
work
.
then
(
callback
)
;
}
updateContainer
(
children
root
parentComponent
work
.
_onCommit
)
;
return
work
;
}
;
ReactRoot
.
prototype
.
createBatch
=
function
(
)
{
var
batch
=
new
ReactBatch
(
this
)
;
var
expirationTime
=
batch
.
_expirationTime
;
var
internalRoot
=
this
.
_internalRoot
;
var
firstBatch
=
internalRoot
.
firstBatch
;
if
(
firstBatch
=
=
=
null
)
{
internalRoot
.
firstBatch
=
batch
;
batch
.
_next
=
null
;
}
else
{
var
insertAfter
=
null
;
var
insertBefore
=
firstBatch
;
while
(
insertBefore
!
=
=
null
&
&
insertBefore
.
_expirationTime
<
=
expirationTime
)
{
insertAfter
=
insertBefore
;
insertBefore
=
insertBefore
.
_next
;
}
batch
.
_next
=
insertBefore
;
if
(
insertAfter
!
=
=
null
)
{
insertAfter
.
_next
=
batch
;
}
}
return
batch
;
}
;
function
isValidContainer
(
node
)
{
return
!
!
(
node
&
&
(
node
.
nodeType
=
=
=
ELEMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
|
|
node
.
nodeType
=
=
=
COMMENT_NODE
&
&
node
.
nodeValue
=
=
=
'
react
-
mount
-
point
-
unstable
'
)
)
;
}
function
getReactRootElementInContainer
(
container
)
{
if
(
!
container
)
{
return
null
;
}
if
(
container
.
nodeType
=
=
=
DOCUMENT_NODE
)
{
return
container
.
documentElement
;
}
else
{
return
container
.
firstChild
;
}
}
function
shouldHydrateDueToLegacyHeuristic
(
container
)
{
var
rootElement
=
getReactRootElementInContainer
(
container
)
;
return
!
!
(
rootElement
&
&
rootElement
.
nodeType
=
=
=
ELEMENT_NODE
&
&
rootElement
.
hasAttribute
(
ROOT_ATTRIBUTE_NAME
)
)
;
}
injection
3
.
injectRenderer
(
DOMRenderer
)
;
function
legacyCreateRootFromDOMContainer
(
container
forceHydrate
)
{
var
shouldHydrate
=
forceHydrate
|
|
shouldHydrateDueToLegacyHeuristic
(
container
)
;
if
(
!
shouldHydrate
)
{
var
rootSibling
=
void
0
;
while
(
rootSibling
=
container
.
lastChild
)
{
container
.
removeChild
(
rootSibling
)
;
}
}
var
isAsync
=
false
;
return
new
ReactRoot
(
container
isAsync
shouldHydrate
)
;
}
function
legacyRenderSubtreeIntoContainer
(
parentComponent
children
container
forceHydrate
callback
)
{
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
var
root
=
container
.
_reactRootContainer
;
if
(
!
root
)
{
root
=
container
.
_reactRootContainer
=
legacyCreateRootFromDOMContainer
(
container
forceHydrate
)
;
if
(
typeof
callback
=
=
=
'
function
'
)
{
var
originalCallback
=
callback
;
callback
=
function
(
)
{
var
instance
=
getPublicRootInstance
(
root
.
_internalRoot
)
;
originalCallback
.
call
(
instance
)
;
}
;
}
unbatchedUpdates
(
function
(
)
{
if
(
parentComponent
!
=
null
)
{
root
.
legacy_renderSubtreeIntoContainer
(
parentComponent
children
callback
)
;
}
else
{
root
.
render
(
children
callback
)
;
}
}
)
;
}
else
{
if
(
typeof
callback
=
=
=
'
function
'
)
{
var
_originalCallback
=
callback
;
callback
=
function
(
)
{
var
instance
=
getPublicRootInstance
(
root
.
_internalRoot
)
;
_originalCallback
.
call
(
instance
)
;
}
;
}
if
(
parentComponent
!
=
null
)
{
root
.
legacy_renderSubtreeIntoContainer
(
parentComponent
children
callback
)
;
}
else
{
root
.
render
(
children
callback
)
;
}
}
return
getPublicRootInstance
(
root
.
_internalRoot
)
;
}
function
createPortal
(
children
container
)
{
var
key
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
null
;
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
return
createPortal
1
(
children
container
null
key
)
;
}
var
ReactDOM
=
{
createPortal
:
createPortal
findDOMNode
:
function
(
componentOrElement
)
{
if
(
componentOrElement
=
=
null
)
{
return
null
;
}
if
(
componentOrElement
.
nodeType
=
=
=
ELEMENT_NODE
)
{
return
componentOrElement
;
}
return
findHostInstance
(
componentOrElement
)
;
}
hydrate
:
function
(
element
container
callback
)
{
return
legacyRenderSubtreeIntoContainer
(
null
element
container
true
callback
)
;
}
render
:
function
(
element
container
callback
)
{
return
legacyRenderSubtreeIntoContainer
(
null
element
container
false
callback
)
;
}
unstable_renderSubtreeIntoContainer
:
function
(
parentComponent
element
containerNode
callback
)
{
!
(
parentComponent
!
=
null
&
&
has
(
parentComponent
)
)
?
reactProdInvariant
(
'
38
'
)
:
void
0
;
return
legacyRenderSubtreeIntoContainer
(
parentComponent
element
containerNode
false
callback
)
;
}
unmountComponentAtNode
:
function
(
container
)
{
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
40
'
)
:
void
0
;
if
(
container
.
_reactRootContainer
)
{
unbatchedUpdates
(
function
(
)
{
legacyRenderSubtreeIntoContainer
(
null
null
container
false
function
(
)
{
container
.
_reactRootContainer
=
null
;
}
)
;
}
)
;
return
true
;
}
else
{
return
false
;
}
}
unstable_createPortal
:
function
(
)
{
return
createPortal
.
apply
(
undefined
arguments
)
;
}
unstable_batchedUpdates
:
batchedUpdates
1
unstable_deferredUpdates
:
deferredUpdates
unstable_interactiveUpdates
:
interactiveUpdates
1
flushSync
:
flushSync
unstable_flushControlled
:
flushControlled
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
:
{
EventPluginHub
:
EventPluginHub
EventPluginRegistry
:
EventPluginRegistry
EventPropagators
:
EventPropagators
ReactControlledComponent
:
ReactControlledComponent
ReactDOMComponentTree
:
ReactDOMComponentTree
ReactDOMEventListener
:
ReactDOMEventListener
}
}
;
ReactDOM
.
unstable_createRoot
=
function
createRoot
(
container
options
)
{
var
hydrate
=
options
!
=
null
&
&
options
.
hydrate
=
=
=
true
;
return
new
ReactRoot
(
container
true
hydrate
)
;
}
;
var
foundDevTools
=
injectIntoDevTools
(
{
findFiberByHostInstance
:
getClosestInstanceFromNode
bundleType
:
0
version
:
ReactVersion
rendererPackageName
:
'
react
-
dom
'
}
)
;
var
ReactDOM
2
=
(
{
default
:
ReactDOM
}
)
;
var
ReactDOM
3
=
(
ReactDOM
2
&
&
ReactDOM
)
|
|
ReactDOM
2
;
var
reactDom
=
ReactDOM
3
.
default
?
ReactDOM
3
.
default
:
ReactDOM
3
;
return
reactDom
;
}
)
)
)
;
