(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
module
.
exports
=
factory
(
require
(
'
devtools
/
client
/
shared
/
vendor
/
react
'
)
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
[
'
devtools
/
client
/
shared
/
vendor
/
react
'
]
factory
)
:
(
global
.
ReactDOM
=
factory
(
global
.
React
)
)
;
}
(
this
(
function
(
React
)
{
'
use
strict
'
;
function
invariant
(
condition
format
a
b
c
d
e
f
)
{
if
(
!
condition
)
{
var
error
=
void
0
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
function
reactProdInvariant
(
code
)
{
var
argCount
=
arguments
.
length
-
1
;
var
url
=
'
https
:
/
/
reactjs
.
org
/
docs
/
error
-
decoder
.
html
?
invariant
=
'
+
code
;
for
(
var
argIdx
=
0
;
argIdx
<
argCount
;
argIdx
+
+
)
{
url
+
=
'
&
args
[
]
=
'
+
encodeURIComponent
(
arguments
[
argIdx
+
1
]
)
;
}
var
i
=
invariant
;
i
(
false
'
Minified
React
error
#
'
+
code
+
'
;
visit
%
s
'
+
'
for
the
full
message
or
use
the
non
-
minified
dev
environment
'
+
'
for
full
errors
and
additional
helpful
warnings
.
'
url
)
;
}
!
React
?
reactProdInvariant
(
'
227
'
)
:
void
0
;
var
invokeGuardedCallbackImpl
=
function
(
name
func
context
a
b
c
d
e
f
)
{
var
funcArgs
=
Array
.
prototype
.
slice
.
call
(
arguments
3
)
;
try
{
func
.
apply
(
context
funcArgs
)
;
}
catch
(
error
)
{
this
.
onError
(
error
)
;
}
}
;
var
hasError
=
false
;
var
caughtError
=
null
;
var
hasRethrowError
=
false
;
var
rethrowError
=
null
;
var
reporter
=
{
onError
:
function
(
error
)
{
hasError
=
true
;
caughtError
=
error
;
}
}
;
function
invokeGuardedCallback
(
name
func
context
a
b
c
d
e
f
)
{
hasError
=
false
;
caughtError
=
null
;
invokeGuardedCallbackImpl
.
apply
(
reporter
arguments
)
;
}
function
invokeGuardedCallbackAndCatchFirstError
(
name
func
context
a
b
c
d
e
f
)
{
invokeGuardedCallback
.
apply
(
this
arguments
)
;
if
(
hasError
)
{
var
error
=
clearCaughtError
(
)
;
if
(
!
hasRethrowError
)
{
hasRethrowError
=
true
;
rethrowError
=
error
;
}
}
}
function
rethrowCaughtError
(
)
{
if
(
hasRethrowError
)
{
var
error
=
rethrowError
;
hasRethrowError
=
false
;
rethrowError
=
null
;
throw
error
;
}
}
function
clearCaughtError
(
)
{
if
(
hasError
)
{
var
error
=
caughtError
;
hasError
=
false
;
caughtError
=
null
;
return
error
;
}
else
{
reactProdInvariant
(
'
198
'
)
;
}
}
var
eventPluginOrder
=
null
;
var
namesToPlugins
=
{
}
;
function
recomputePluginOrdering
(
)
{
if
(
!
eventPluginOrder
)
{
return
;
}
for
(
var
pluginName
in
namesToPlugins
)
{
var
pluginModule
=
namesToPlugins
[
pluginName
]
;
var
pluginIndex
=
eventPluginOrder
.
indexOf
(
pluginName
)
;
!
(
pluginIndex
>
-
1
)
?
reactProdInvariant
(
'
96
'
pluginName
)
:
void
0
;
if
(
plugins
[
pluginIndex
]
)
{
continue
;
}
!
pluginModule
.
extractEvents
?
reactProdInvariant
(
'
97
'
pluginName
)
:
void
0
;
plugins
[
pluginIndex
]
=
pluginModule
;
var
publishedEvents
=
pluginModule
.
eventTypes
;
for
(
var
eventName
in
publishedEvents
)
{
!
publishEventForPlugin
(
publishedEvents
[
eventName
]
pluginModule
eventName
)
?
reactProdInvariant
(
'
98
'
eventName
pluginName
)
:
void
0
;
}
}
}
function
publishEventForPlugin
(
dispatchConfig
pluginModule
eventName
)
{
!
!
eventNameDispatchConfigs
.
hasOwnProperty
(
eventName
)
?
reactProdInvariant
(
'
99
'
eventName
)
:
void
0
;
eventNameDispatchConfigs
[
eventName
]
=
dispatchConfig
;
var
phasedRegistrationNames
=
dispatchConfig
.
phasedRegistrationNames
;
if
(
phasedRegistrationNames
)
{
for
(
var
phaseName
in
phasedRegistrationNames
)
{
if
(
phasedRegistrationNames
.
hasOwnProperty
(
phaseName
)
)
{
var
phasedRegistrationName
=
phasedRegistrationNames
[
phaseName
]
;
publishRegistrationName
(
phasedRegistrationName
pluginModule
eventName
)
;
}
}
return
true
;
}
else
if
(
dispatchConfig
.
registrationName
)
{
publishRegistrationName
(
dispatchConfig
.
registrationName
pluginModule
eventName
)
;
return
true
;
}
return
false
;
}
function
publishRegistrationName
(
registrationName
pluginModule
eventName
)
{
!
!
registrationNameModules
[
registrationName
]
?
reactProdInvariant
(
'
100
'
registrationName
)
:
void
0
;
registrationNameModules
[
registrationName
]
=
pluginModule
;
registrationNameDependencies
[
registrationName
]
=
pluginModule
.
eventTypes
[
eventName
]
.
dependencies
;
}
var
plugins
=
[
]
;
var
eventNameDispatchConfigs
=
{
}
;
var
registrationNameModules
=
{
}
;
var
registrationNameDependencies
=
{
}
;
function
injectEventPluginOrder
(
injectedEventPluginOrder
)
{
!
!
eventPluginOrder
?
reactProdInvariant
(
'
101
'
)
:
void
0
;
eventPluginOrder
=
Array
.
prototype
.
slice
.
call
(
injectedEventPluginOrder
)
;
recomputePluginOrdering
(
)
;
}
function
injectEventPluginsByName
(
injectedNamesToPlugins
)
{
var
isOrderingDirty
=
false
;
for
(
var
pluginName
in
injectedNamesToPlugins
)
{
if
(
!
injectedNamesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
continue
;
}
var
pluginModule
=
injectedNamesToPlugins
[
pluginName
]
;
if
(
!
namesToPlugins
.
hasOwnProperty
(
pluginName
)
|
|
namesToPlugins
[
pluginName
]
!
=
=
pluginModule
)
{
!
!
namesToPlugins
[
pluginName
]
?
reactProdInvariant
(
'
102
'
pluginName
)
:
void
0
;
namesToPlugins
[
pluginName
]
=
pluginModule
;
isOrderingDirty
=
true
;
}
}
if
(
isOrderingDirty
)
{
recomputePluginOrdering
(
)
;
}
}
var
getFiberCurrentPropsFromNode
=
null
;
var
getInstanceFromNode
=
null
;
var
getNodeFromInstance
=
null
;
function
setComponentTree
(
getFiberCurrentPropsFromNodeImpl
getInstanceFromNodeImpl
getNodeFromInstanceImpl
)
{
getFiberCurrentPropsFromNode
=
getFiberCurrentPropsFromNodeImpl
;
getInstanceFromNode
=
getInstanceFromNodeImpl
;
getNodeFromInstance
=
getNodeFromInstanceImpl
;
}
function
executeDispatch
(
event
listener
inst
)
{
var
type
=
event
.
type
|
|
'
unknown
-
event
'
;
event
.
currentTarget
=
getNodeFromInstance
(
inst
)
;
invokeGuardedCallbackAndCatchFirstError
(
type
listener
undefined
event
)
;
event
.
currentTarget
=
null
;
}
function
executeDispatchesInOrder
(
event
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchInstances
=
event
.
_dispatchInstances
;
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
executeDispatch
(
event
dispatchListeners
[
i
]
dispatchInstances
[
i
]
)
;
}
}
else
if
(
dispatchListeners
)
{
executeDispatch
(
event
dispatchListeners
dispatchInstances
)
;
}
event
.
_dispatchListeners
=
null
;
event
.
_dispatchInstances
=
null
;
}
function
accumulateInto
(
current
next
)
{
!
(
next
!
=
null
)
?
reactProdInvariant
(
'
30
'
)
:
void
0
;
if
(
current
=
=
null
)
{
return
next
;
}
if
(
Array
.
isArray
(
current
)
)
{
if
(
Array
.
isArray
(
next
)
)
{
current
.
push
.
apply
(
current
next
)
;
return
current
;
}
current
.
push
(
next
)
;
return
current
;
}
if
(
Array
.
isArray
(
next
)
)
{
return
[
current
]
.
concat
(
next
)
;
}
return
[
current
next
]
;
}
function
forEachAccumulated
(
arr
cb
scope
)
{
if
(
Array
.
isArray
(
arr
)
)
{
arr
.
forEach
(
cb
scope
)
;
}
else
if
(
arr
)
{
cb
.
call
(
scope
arr
)
;
}
}
var
eventQueue
=
null
;
var
executeDispatchesAndRelease
=
function
(
event
)
{
if
(
event
)
{
executeDispatchesInOrder
(
event
)
;
if
(
!
event
.
isPersistent
(
)
)
{
event
.
constructor
.
release
(
event
)
;
}
}
}
;
var
executeDispatchesAndReleaseTopLevel
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
)
;
}
;
function
isInteractive
(
tag
)
{
return
tag
=
=
=
'
button
'
|
|
tag
=
=
=
'
input
'
|
|
tag
=
=
=
'
select
'
|
|
tag
=
=
=
'
textarea
'
;
}
function
shouldPreventMouseEvent
(
name
type
props
)
{
switch
(
name
)
{
case
'
onClick
'
:
case
'
onClickCapture
'
:
case
'
onDoubleClick
'
:
case
'
onDoubleClickCapture
'
:
case
'
onMouseDown
'
:
case
'
onMouseDownCapture
'
:
case
'
onMouseMove
'
:
case
'
onMouseMoveCapture
'
:
case
'
onMouseUp
'
:
case
'
onMouseUpCapture
'
:
return
!
!
(
props
.
disabled
&
&
isInteractive
(
type
)
)
;
default
:
return
false
;
}
}
var
injection
=
{
injectEventPluginOrder
:
injectEventPluginOrder
injectEventPluginsByName
:
injectEventPluginsByName
}
;
function
getListener
(
inst
registrationName
)
{
var
listener
=
void
0
;
var
stateNode
=
inst
.
stateNode
;
if
(
!
stateNode
)
{
return
null
;
}
var
props
=
getFiberCurrentPropsFromNode
(
stateNode
)
;
if
(
!
props
)
{
return
null
;
}
listener
=
props
[
registrationName
]
;
if
(
shouldPreventMouseEvent
(
registrationName
inst
.
type
props
)
)
{
return
null
;
}
!
(
!
listener
|
|
typeof
listener
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
231
'
registrationName
typeof
listener
)
:
void
0
;
return
listener
;
}
function
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
events
=
null
;
for
(
var
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
var
possiblePlugin
=
plugins
[
i
]
;
if
(
possiblePlugin
)
{
var
extractedEvents
=
possiblePlugin
.
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
extractedEvents
)
{
events
=
accumulateInto
(
events
extractedEvents
)
;
}
}
}
return
events
;
}
function
runEventsInBatch
(
events
)
{
if
(
events
!
=
=
null
)
{
eventQueue
=
accumulateInto
(
eventQueue
events
)
;
}
var
processingEventQueue
=
eventQueue
;
eventQueue
=
null
;
if
(
!
processingEventQueue
)
{
return
;
}
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseTopLevel
)
;
!
!
eventQueue
?
reactProdInvariant
(
'
95
'
)
:
void
0
;
rethrowCaughtError
(
)
;
}
function
runExtractedEventsInBatch
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
events
=
extractEvents
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
runEventsInBatch
(
events
)
;
}
var
FunctionComponent
=
0
;
var
ClassComponent
=
1
;
var
IndeterminateComponent
=
2
;
var
HostRoot
=
3
;
var
HostPortal
=
4
;
var
HostComponent
=
5
;
var
HostText
=
6
;
var
Fragment
=
7
;
var
Mode
=
8
;
var
ContextConsumer
=
9
;
var
ContextProvider
=
10
;
var
ForwardRef
=
11
;
var
Profiler
=
12
;
var
SuspenseComponent
=
13
;
var
MemoComponent
=
14
;
var
SimpleMemoComponent
=
15
;
var
LazyComponent
=
16
;
var
IncompleteClassComponent
=
17
;
var
DehydratedSuspenseComponent
=
18
;
var
randomKey
=
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
var
internalInstanceKey
=
'
__reactInternalInstance
'
+
randomKey
;
var
internalEventHandlersKey
=
'
__reactEventHandlers
'
+
randomKey
;
function
precacheFiberNode
(
hostInst
node
)
{
node
[
internalInstanceKey
]
=
hostInst
;
}
function
getClosestInstanceFromNode
(
node
)
{
if
(
node
[
internalInstanceKey
]
)
{
return
node
[
internalInstanceKey
]
;
}
while
(
!
node
[
internalInstanceKey
]
)
{
if
(
node
.
parentNode
)
{
node
=
node
.
parentNode
;
}
else
{
return
null
;
}
}
var
inst
=
node
[
internalInstanceKey
]
;
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
;
}
return
null
;
}
function
getInstanceFromNode
1
(
node
)
{
var
inst
=
node
[
internalInstanceKey
]
;
if
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
;
}
else
{
return
null
;
}
}
return
null
;
}
function
getNodeFromInstance
1
(
inst
)
{
if
(
inst
.
tag
=
=
=
HostComponent
|
|
inst
.
tag
=
=
=
HostText
)
{
return
inst
.
stateNode
;
}
reactProdInvariant
(
'
33
'
)
;
}
function
getFiberCurrentPropsFromNode
1
(
node
)
{
return
node
[
internalEventHandlersKey
]
|
|
null
;
}
function
updateFiberProps
(
node
props
)
{
node
[
internalEventHandlersKey
]
=
props
;
}
function
getParent
(
inst
)
{
do
{
inst
=
inst
.
return
;
}
while
(
inst
&
&
inst
.
tag
!
=
=
HostComponent
)
;
if
(
inst
)
{
return
inst
;
}
return
null
;
}
function
getLowestCommonAncestor
(
instA
instB
)
{
var
depthA
=
0
;
for
(
var
tempA
=
instA
;
tempA
;
tempA
=
getParent
(
tempA
)
)
{
depthA
+
+
;
}
var
depthB
=
0
;
for
(
var
tempB
=
instB
;
tempB
;
tempB
=
getParent
(
tempB
)
)
{
depthB
+
+
;
}
while
(
depthA
-
depthB
>
0
)
{
instA
=
getParent
(
instA
)
;
depthA
-
-
;
}
while
(
depthB
-
depthA
>
0
)
{
instB
=
getParent
(
instB
)
;
depthB
-
-
;
}
var
depth
=
depthA
;
while
(
depth
-
-
)
{
if
(
instA
=
=
=
instB
|
|
instA
=
=
=
instB
.
alternate
)
{
return
instA
;
}
instA
=
getParent
(
instA
)
;
instB
=
getParent
(
instB
)
;
}
return
null
;
}
function
traverseTwoPhase
(
inst
fn
arg
)
{
var
path
=
[
]
;
while
(
inst
)
{
path
.
push
(
inst
)
;
inst
=
getParent
(
inst
)
;
}
var
i
=
void
0
;
for
(
i
=
path
.
length
;
i
-
-
>
0
;
)
{
fn
(
path
[
i
]
'
captured
'
arg
)
;
}
for
(
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
fn
(
path
[
i
]
'
bubbled
'
arg
)
;
}
}
function
traverseEnterLeave
(
from
to
fn
argFrom
argTo
)
{
var
common
=
from
&
&
to
?
getLowestCommonAncestor
(
from
to
)
:
null
;
var
pathFrom
=
[
]
;
while
(
true
)
{
if
(
!
from
)
{
break
;
}
if
(
from
=
=
=
common
)
{
break
;
}
var
alternate
=
from
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
=
=
=
common
)
{
break
;
}
pathFrom
.
push
(
from
)
;
from
=
getParent
(
from
)
;
}
var
pathTo
=
[
]
;
while
(
true
)
{
if
(
!
to
)
{
break
;
}
if
(
to
=
=
=
common
)
{
break
;
}
var
_alternate
=
to
.
alternate
;
if
(
_alternate
!
=
=
null
&
&
_alternate
=
=
=
common
)
{
break
;
}
pathTo
.
push
(
to
)
;
to
=
getParent
(
to
)
;
}
for
(
var
i
=
0
;
i
<
pathFrom
.
length
;
i
+
+
)
{
fn
(
pathFrom
[
i
]
'
bubbled
'
argFrom
)
;
}
for
(
var
_i
=
pathTo
.
length
;
_i
-
-
>
0
;
)
{
fn
(
pathTo
[
_i
]
'
captured
'
argTo
)
;
}
}
function
listenerAtPhase
(
inst
event
propagationPhase
)
{
var
registrationName
=
event
.
dispatchConfig
.
phasedRegistrationNames
[
propagationPhase
]
;
return
getListener
(
inst
registrationName
)
;
}
function
accumulateDirectionalDispatches
(
inst
phase
event
)
{
var
listener
=
listenerAtPhase
(
inst
event
phase
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
function
accumulateTwoPhaseDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
traverseTwoPhase
(
event
.
_targetInst
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateDispatches
(
inst
ignoredDirection
event
)
{
if
(
inst
&
&
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
var
registrationName
=
event
.
dispatchConfig
.
registrationName
;
var
listener
=
getListener
(
inst
registrationName
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchInstances
=
accumulateInto
(
event
.
_dispatchInstances
inst
)
;
}
}
}
function
accumulateDirectDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
accumulateDispatches
(
event
.
_targetInst
null
event
)
;
}
}
function
accumulateTwoPhaseDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingle
)
;
}
function
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
{
traverseEnterLeave
(
from
to
accumulateDispatches
leave
enter
)
;
}
function
accumulateDirectDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateDirectDispatchesSingle
)
;
}
var
canUseDOM
=
!
!
(
typeof
window
!
=
=
'
undefined
'
&
&
window
.
document
&
&
window
.
document
.
createElement
)
;
function
unsafeCastStringToDOMTopLevelType
(
topLevelType
)
{
return
topLevelType
;
}
function
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
{
return
topLevelType
;
}
function
makePrefixMap
(
styleProp
eventName
)
{
var
prefixes
=
{
}
;
prefixes
[
styleProp
.
toLowerCase
(
)
]
=
eventName
.
toLowerCase
(
)
;
prefixes
[
'
Webkit
'
+
styleProp
]
=
'
webkit
'
+
eventName
;
prefixes
[
'
Moz
'
+
styleProp
]
=
'
moz
'
+
eventName
;
return
prefixes
;
}
var
vendorPrefixes
=
{
animationend
:
makePrefixMap
(
'
Animation
'
'
AnimationEnd
'
)
animationiteration
:
makePrefixMap
(
'
Animation
'
'
AnimationIteration
'
)
animationstart
:
makePrefixMap
(
'
Animation
'
'
AnimationStart
'
)
transitionend
:
makePrefixMap
(
'
Transition
'
'
TransitionEnd
'
)
}
;
var
prefixedEventNames
=
{
}
;
var
style
=
{
}
;
if
(
canUseDOM
)
{
style
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
.
style
;
if
(
!
(
'
AnimationEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
animationend
.
animation
;
delete
vendorPrefixes
.
animationiteration
.
animation
;
delete
vendorPrefixes
.
animationstart
.
animation
;
}
if
(
!
(
'
TransitionEvent
'
in
window
)
)
{
delete
vendorPrefixes
.
transitionend
.
transition
;
}
}
function
getVendorPrefixedEventName
(
eventName
)
{
if
(
prefixedEventNames
[
eventName
]
)
{
return
prefixedEventNames
[
eventName
]
;
}
else
if
(
!
vendorPrefixes
[
eventName
]
)
{
return
eventName
;
}
var
prefixMap
=
vendorPrefixes
[
eventName
]
;
for
(
var
styleProp
in
prefixMap
)
{
if
(
prefixMap
.
hasOwnProperty
(
styleProp
)
&
&
styleProp
in
style
)
{
return
prefixedEventNames
[
eventName
]
=
prefixMap
[
styleProp
]
;
}
}
return
eventName
;
}
var
TOP_ABORT
=
unsafeCastStringToDOMTopLevelType
(
'
abort
'
)
;
var
TOP_ANIMATION_END
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationend
'
)
)
;
var
TOP_ANIMATION_ITERATION
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationiteration
'
)
)
;
var
TOP_ANIMATION_START
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
animationstart
'
)
)
;
var
TOP_BLUR
=
unsafeCastStringToDOMTopLevelType
(
'
blur
'
)
;
var
TOP_CAN_PLAY
=
unsafeCastStringToDOMTopLevelType
(
'
canplay
'
)
;
var
TOP_CAN_PLAY_THROUGH
=
unsafeCastStringToDOMTopLevelType
(
'
canplaythrough
'
)
;
var
TOP_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
cancel
'
)
;
var
TOP_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
change
'
)
;
var
TOP_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
click
'
)
;
var
TOP_CLOSE
=
unsafeCastStringToDOMTopLevelType
(
'
close
'
)
;
var
TOP_COMPOSITION_END
=
unsafeCastStringToDOMTopLevelType
(
'
compositionend
'
)
;
var
TOP_COMPOSITION_START
=
unsafeCastStringToDOMTopLevelType
(
'
compositionstart
'
)
;
var
TOP_COMPOSITION_UPDATE
=
unsafeCastStringToDOMTopLevelType
(
'
compositionupdate
'
)
;
var
TOP_CONTEXT_MENU
=
unsafeCastStringToDOMTopLevelType
(
'
contextmenu
'
)
;
var
TOP_COPY
=
unsafeCastStringToDOMTopLevelType
(
'
copy
'
)
;
var
TOP_CUT
=
unsafeCastStringToDOMTopLevelType
(
'
cut
'
)
;
var
TOP_DOUBLE_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
dblclick
'
)
;
var
TOP_AUX_CLICK
=
unsafeCastStringToDOMTopLevelType
(
'
auxclick
'
)
;
var
TOP_DRAG
=
unsafeCastStringToDOMTopLevelType
(
'
drag
'
)
;
var
TOP_DRAG_END
=
unsafeCastStringToDOMTopLevelType
(
'
dragend
'
)
;
var
TOP_DRAG_ENTER
=
unsafeCastStringToDOMTopLevelType
(
'
dragenter
'
)
;
var
TOP_DRAG_EXIT
=
unsafeCastStringToDOMTopLevelType
(
'
dragexit
'
)
;
var
TOP_DRAG_LEAVE
=
unsafeCastStringToDOMTopLevelType
(
'
dragleave
'
)
;
var
TOP_DRAG_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
dragover
'
)
;
var
TOP_DRAG_START
=
unsafeCastStringToDOMTopLevelType
(
'
dragstart
'
)
;
var
TOP_DROP
=
unsafeCastStringToDOMTopLevelType
(
'
drop
'
)
;
var
TOP_DURATION_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
durationchange
'
)
;
var
TOP_EMPTIED
=
unsafeCastStringToDOMTopLevelType
(
'
emptied
'
)
;
var
TOP_ENCRYPTED
=
unsafeCastStringToDOMTopLevelType
(
'
encrypted
'
)
;
var
TOP_ENDED
=
unsafeCastStringToDOMTopLevelType
(
'
ended
'
)
;
var
TOP_ERROR
=
unsafeCastStringToDOMTopLevelType
(
'
error
'
)
;
var
TOP_FOCUS
=
unsafeCastStringToDOMTopLevelType
(
'
focus
'
)
;
var
TOP_GOT_POINTER_CAPTURE
=
unsafeCastStringToDOMTopLevelType
(
'
gotpointercapture
'
)
;
var
TOP_INPUT
=
unsafeCastStringToDOMTopLevelType
(
'
input
'
)
;
var
TOP_INVALID
=
unsafeCastStringToDOMTopLevelType
(
'
invalid
'
)
;
var
TOP_KEY_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
keydown
'
)
;
var
TOP_KEY_PRESS
=
unsafeCastStringToDOMTopLevelType
(
'
keypress
'
)
;
var
TOP_KEY_UP
=
unsafeCastStringToDOMTopLevelType
(
'
keyup
'
)
;
var
TOP_LOAD
=
unsafeCastStringToDOMTopLevelType
(
'
load
'
)
;
var
TOP_LOAD_START
=
unsafeCastStringToDOMTopLevelType
(
'
loadstart
'
)
;
var
TOP_LOADED_DATA
=
unsafeCastStringToDOMTopLevelType
(
'
loadeddata
'
)
;
var
TOP_LOADED_METADATA
=
unsafeCastStringToDOMTopLevelType
(
'
loadedmetadata
'
)
;
var
TOP_LOST_POINTER_CAPTURE
=
unsafeCastStringToDOMTopLevelType
(
'
lostpointercapture
'
)
;
var
TOP_MOUSE_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
mousedown
'
)
;
var
TOP_MOUSE_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
mousemove
'
)
;
var
TOP_MOUSE_OUT
=
unsafeCastStringToDOMTopLevelType
(
'
mouseout
'
)
;
var
TOP_MOUSE_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
mouseover
'
)
;
var
TOP_MOUSE_UP
=
unsafeCastStringToDOMTopLevelType
(
'
mouseup
'
)
;
var
TOP_PASTE
=
unsafeCastStringToDOMTopLevelType
(
'
paste
'
)
;
var
TOP_PAUSE
=
unsafeCastStringToDOMTopLevelType
(
'
pause
'
)
;
var
TOP_PLAY
=
unsafeCastStringToDOMTopLevelType
(
'
play
'
)
;
var
TOP_PLAYING
=
unsafeCastStringToDOMTopLevelType
(
'
playing
'
)
;
var
TOP_POINTER_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
pointercancel
'
)
;
var
TOP_POINTER_DOWN
=
unsafeCastStringToDOMTopLevelType
(
'
pointerdown
'
)
;
var
TOP_POINTER_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
pointermove
'
)
;
var
TOP_POINTER_OUT
=
unsafeCastStringToDOMTopLevelType
(
'
pointerout
'
)
;
var
TOP_POINTER_OVER
=
unsafeCastStringToDOMTopLevelType
(
'
pointerover
'
)
;
var
TOP_POINTER_UP
=
unsafeCastStringToDOMTopLevelType
(
'
pointerup
'
)
;
var
TOP_PROGRESS
=
unsafeCastStringToDOMTopLevelType
(
'
progress
'
)
;
var
TOP_RATE_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
ratechange
'
)
;
var
TOP_RESET
=
unsafeCastStringToDOMTopLevelType
(
'
reset
'
)
;
var
TOP_SCROLL
=
unsafeCastStringToDOMTopLevelType
(
'
scroll
'
)
;
var
TOP_SEEKED
=
unsafeCastStringToDOMTopLevelType
(
'
seeked
'
)
;
var
TOP_SEEKING
=
unsafeCastStringToDOMTopLevelType
(
'
seeking
'
)
;
var
TOP_SELECTION_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
selectionchange
'
)
;
var
TOP_STALLED
=
unsafeCastStringToDOMTopLevelType
(
'
stalled
'
)
;
var
TOP_SUBMIT
=
unsafeCastStringToDOMTopLevelType
(
'
submit
'
)
;
var
TOP_SUSPEND
=
unsafeCastStringToDOMTopLevelType
(
'
suspend
'
)
;
var
TOP_TEXT_INPUT
=
unsafeCastStringToDOMTopLevelType
(
'
textInput
'
)
;
var
TOP_TIME_UPDATE
=
unsafeCastStringToDOMTopLevelType
(
'
timeupdate
'
)
;
var
TOP_TOGGLE
=
unsafeCastStringToDOMTopLevelType
(
'
toggle
'
)
;
var
TOP_TOUCH_CANCEL
=
unsafeCastStringToDOMTopLevelType
(
'
touchcancel
'
)
;
var
TOP_TOUCH_END
=
unsafeCastStringToDOMTopLevelType
(
'
touchend
'
)
;
var
TOP_TOUCH_MOVE
=
unsafeCastStringToDOMTopLevelType
(
'
touchmove
'
)
;
var
TOP_TOUCH_START
=
unsafeCastStringToDOMTopLevelType
(
'
touchstart
'
)
;
var
TOP_TRANSITION_END
=
unsafeCastStringToDOMTopLevelType
(
getVendorPrefixedEventName
(
'
transitionend
'
)
)
;
var
TOP_VOLUME_CHANGE
=
unsafeCastStringToDOMTopLevelType
(
'
volumechange
'
)
;
var
TOP_WAITING
=
unsafeCastStringToDOMTopLevelType
(
'
waiting
'
)
;
var
TOP_WHEEL
=
unsafeCastStringToDOMTopLevelType
(
'
wheel
'
)
;
var
mediaEventTypes
=
[
TOP_ABORT
TOP_CAN_PLAY
TOP_CAN_PLAY_THROUGH
TOP_DURATION_CHANGE
TOP_EMPTIED
TOP_ENCRYPTED
TOP_ENDED
TOP_ERROR
TOP_LOADED_DATA
TOP_LOADED_METADATA
TOP_LOAD_START
TOP_PAUSE
TOP_PLAY
TOP_PLAYING
TOP_PROGRESS
TOP_RATE_CHANGE
TOP_SEEKED
TOP_SEEKING
TOP_STALLED
TOP_SUSPEND
TOP_TIME_UPDATE
TOP_VOLUME_CHANGE
TOP_WAITING
]
;
function
getRawEventName
(
topLevelType
)
{
return
unsafeCastDOMTopLevelTypeToString
(
topLevelType
)
;
}
var
root
=
null
;
var
startText
=
null
;
var
fallbackText
=
null
;
function
initialize
(
nativeEventTarget
)
{
root
=
nativeEventTarget
;
startText
=
getText
(
)
;
return
true
;
}
function
reset
(
)
{
root
=
null
;
startText
=
null
;
fallbackText
=
null
;
}
function
getData
(
)
{
if
(
fallbackText
)
{
return
fallbackText
;
}
var
start
=
void
0
;
var
startValue
=
startText
;
var
startLength
=
startValue
.
length
;
var
end
=
void
0
;
var
endValue
=
getText
(
)
;
var
endLength
=
endValue
.
length
;
for
(
start
=
0
;
start
<
startLength
;
start
+
+
)
{
if
(
startValue
[
start
]
!
=
=
endValue
[
start
]
)
{
break
;
}
}
var
minEnd
=
startLength
-
start
;
for
(
end
=
1
;
end
<
=
minEnd
;
end
+
+
)
{
if
(
startValue
[
startLength
-
end
]
!
=
=
endValue
[
endLength
-
end
]
)
{
break
;
}
}
var
sliceTail
=
end
>
1
?
1
-
end
:
undefined
;
fallbackText
=
endValue
.
slice
(
start
sliceTail
)
;
return
fallbackText
;
}
function
getText
(
)
{
if
(
'
value
'
in
root
)
{
return
root
.
value
;
}
return
root
.
textContent
;
}
var
ReactInternals
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_assign
=
ReactInternals
.
assign
;
var
EVENT_POOL_SIZE
=
10
;
var
EventInterface
=
{
type
:
null
target
:
null
currentTarget
:
function
(
)
{
return
null
;
}
eventPhase
:
null
bubbles
:
null
cancelable
:
null
timeStamp
:
function
(
event
)
{
return
event
.
timeStamp
|
|
Date
.
now
(
)
;
}
defaultPrevented
:
null
isTrusted
:
null
}
;
function
functionThatReturnsTrue
(
)
{
return
true
;
}
function
functionThatReturnsFalse
(
)
{
return
false
;
}
function
SyntheticEvent
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
{
this
.
dispatchConfig
=
dispatchConfig
;
this
.
_targetInst
=
targetInst
;
this
.
nativeEvent
=
nativeEvent
;
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
if
(
!
Interface
.
hasOwnProperty
(
propName
)
)
{
continue
;
}
var
normalize
=
Interface
[
propName
]
;
if
(
normalize
)
{
this
[
propName
]
=
normalize
(
nativeEvent
)
;
}
else
{
if
(
propName
=
=
=
'
target
'
)
{
this
.
target
=
nativeEventTarget
;
}
else
{
this
[
propName
]
=
nativeEvent
[
propName
]
;
}
}
}
var
defaultPrevented
=
nativeEvent
.
defaultPrevented
!
=
null
?
nativeEvent
.
defaultPrevented
:
nativeEvent
.
returnValue
=
=
=
false
;
if
(
defaultPrevented
)
{
this
.
isDefaultPrevented
=
functionThatReturnsTrue
;
}
else
{
this
.
isDefaultPrevented
=
functionThatReturnsFalse
;
}
this
.
isPropagationStopped
=
functionThatReturnsFalse
;
return
this
;
}
_assign
(
SyntheticEvent
.
prototype
{
preventDefault
:
function
(
)
{
this
.
defaultPrevented
=
true
;
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
preventDefault
)
{
event
.
preventDefault
(
)
;
}
else
if
(
typeof
event
.
returnValue
!
=
=
'
unknown
'
)
{
event
.
returnValue
=
false
;
}
this
.
isDefaultPrevented
=
functionThatReturnsTrue
;
}
stopPropagation
:
function
(
)
{
var
event
=
this
.
nativeEvent
;
if
(
!
event
)
{
return
;
}
if
(
event
.
stopPropagation
)
{
event
.
stopPropagation
(
)
;
}
else
if
(
typeof
event
.
cancelBubble
!
=
=
'
unknown
'
)
{
event
.
cancelBubble
=
true
;
}
this
.
isPropagationStopped
=
functionThatReturnsTrue
;
}
persist
:
function
(
)
{
this
.
isPersistent
=
functionThatReturnsTrue
;
}
isPersistent
:
functionThatReturnsFalse
destructor
:
function
(
)
{
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
{
this
[
propName
]
=
null
;
}
}
this
.
dispatchConfig
=
null
;
this
.
_targetInst
=
null
;
this
.
nativeEvent
=
null
;
this
.
isDefaultPrevented
=
functionThatReturnsFalse
;
this
.
isPropagationStopped
=
functionThatReturnsFalse
;
this
.
_dispatchListeners
=
null
;
this
.
_dispatchInstances
=
null
;
}
}
)
;
SyntheticEvent
.
Interface
=
EventInterface
;
SyntheticEvent
.
extend
=
function
(
Interface
)
{
var
Super
=
this
;
var
E
=
function
(
)
{
}
;
E
.
prototype
=
Super
.
prototype
;
var
prototype
=
new
E
(
)
;
function
Class
(
)
{
return
Super
.
apply
(
this
arguments
)
;
}
_assign
(
prototype
Class
.
prototype
)
;
Class
.
prototype
=
prototype
;
Class
.
prototype
.
constructor
=
Class
;
Class
.
Interface
=
_assign
(
{
}
Super
.
Interface
Interface
)
;
Class
.
extend
=
Super
.
extend
;
addEventPoolingTo
(
Class
)
;
return
Class
;
}
;
addEventPoolingTo
(
SyntheticEvent
)
;
function
getPooledEvent
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
{
var
EventConstructor
=
this
;
if
(
EventConstructor
.
eventPool
.
length
)
{
var
instance
=
EventConstructor
.
eventPool
.
pop
(
)
;
EventConstructor
.
call
(
instance
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
return
instance
;
}
return
new
EventConstructor
(
dispatchConfig
targetInst
nativeEvent
nativeInst
)
;
}
function
releasePooledEvent
(
event
)
{
var
EventConstructor
=
this
;
!
(
event
instanceof
EventConstructor
)
?
reactProdInvariant
(
'
279
'
)
:
void
0
;
event
.
destructor
(
)
;
if
(
EventConstructor
.
eventPool
.
length
<
EVENT_POOL_SIZE
)
{
EventConstructor
.
eventPool
.
push
(
event
)
;
}
}
function
addEventPoolingTo
(
EventConstructor
)
{
EventConstructor
.
eventPool
=
[
]
;
EventConstructor
.
getPooled
=
getPooledEvent
;
EventConstructor
.
release
=
releasePooledEvent
;
}
var
SyntheticCompositionEvent
=
SyntheticEvent
.
extend
(
{
data
:
null
}
)
;
var
SyntheticInputEvent
=
SyntheticEvent
.
extend
(
{
data
:
null
}
)
;
var
END_KEYCODES
=
[
9
13
27
32
]
;
var
START_KEYCODE
=
229
;
var
canUseCompositionEvent
=
canUseDOM
&
&
'
CompositionEvent
'
in
window
;
var
documentMode
=
null
;
if
(
canUseDOM
&
&
'
documentMode
'
in
document
)
{
documentMode
=
document
.
documentMode
;
}
var
canUseTextInputEvent
=
canUseDOM
&
&
'
TextEvent
'
in
window
&
&
!
documentMode
;
var
useFallbackCompositionData
=
canUseDOM
&
&
(
!
canUseCompositionEvent
|
|
documentMode
&
&
documentMode
>
8
&
&
documentMode
<
=
11
)
;
var
SPACEBAR_CODE
=
32
;
var
SPACEBAR_CHAR
=
String
.
fromCharCode
(
SPACEBAR_CODE
)
;
var
eventTypes
=
{
beforeInput
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onBeforeInput
'
captured
:
'
onBeforeInputCapture
'
}
dependencies
:
[
TOP_COMPOSITION_END
TOP_KEY_PRESS
TOP_TEXT_INPUT
TOP_PASTE
]
}
compositionEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionEnd
'
captured
:
'
onCompositionEndCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_END
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
compositionStart
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionStart
'
captured
:
'
onCompositionStartCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_START
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
compositionUpdate
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onCompositionUpdate
'
captured
:
'
onCompositionUpdateCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_COMPOSITION_UPDATE
TOP_KEY_DOWN
TOP_KEY_PRESS
TOP_KEY_UP
TOP_MOUSE_DOWN
]
}
}
;
var
hasSpaceKeypress
=
false
;
function
isKeypressCommand
(
nativeEvent
)
{
return
(
nativeEvent
.
ctrlKey
|
|
nativeEvent
.
altKey
|
|
nativeEvent
.
metaKey
)
&
&
!
(
nativeEvent
.
ctrlKey
&
&
nativeEvent
.
altKey
)
;
}
function
getCompositionEventType
(
topLevelType
)
{
switch
(
topLevelType
)
{
case
TOP_COMPOSITION_START
:
return
eventTypes
.
compositionStart
;
case
TOP_COMPOSITION_END
:
return
eventTypes
.
compositionEnd
;
case
TOP_COMPOSITION_UPDATE
:
return
eventTypes
.
compositionUpdate
;
}
}
function
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
{
return
topLevelType
=
=
=
TOP_KEY_DOWN
&
&
nativeEvent
.
keyCode
=
=
=
START_KEYCODE
;
}
function
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_KEY_UP
:
return
END_KEYCODES
.
indexOf
(
nativeEvent
.
keyCode
)
!
=
=
-
1
;
case
TOP_KEY_DOWN
:
return
nativeEvent
.
keyCode
!
=
=
START_KEYCODE
;
case
TOP_KEY_PRESS
:
case
TOP_MOUSE_DOWN
:
case
TOP_BLUR
:
return
true
;
default
:
return
false
;
}
}
function
getDataFromCustomEvent
(
nativeEvent
)
{
var
detail
=
nativeEvent
.
detail
;
if
(
typeof
detail
=
=
=
'
object
'
&
&
'
data
'
in
detail
)
{
return
detail
.
data
;
}
return
null
;
}
function
isUsingKoreanIME
(
nativeEvent
)
{
return
nativeEvent
.
locale
=
=
=
'
ko
'
;
}
var
isComposing
=
false
;
function
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
eventType
=
void
0
;
var
fallbackData
=
void
0
;
if
(
canUseCompositionEvent
)
{
eventType
=
getCompositionEventType
(
topLevelType
)
;
}
else
if
(
!
isComposing
)
{
if
(
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionStart
;
}
}
else
if
(
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionEnd
;
}
if
(
!
eventType
)
{
return
null
;
}
if
(
useFallbackCompositionData
&
&
!
isUsingKoreanIME
(
nativeEvent
)
)
{
if
(
!
isComposing
&
&
eventType
=
=
=
eventTypes
.
compositionStart
)
{
isComposing
=
initialize
(
nativeEventTarget
)
;
}
else
if
(
eventType
=
=
=
eventTypes
.
compositionEnd
)
{
if
(
isComposing
)
{
fallbackData
=
getData
(
)
;
}
}
}
var
event
=
SyntheticCompositionEvent
.
getPooled
(
eventType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
fallbackData
)
{
event
.
data
=
fallbackData
;
}
else
{
var
customData
=
getDataFromCustomEvent
(
nativeEvent
)
;
if
(
customData
!
=
=
null
)
{
event
.
data
=
customData
;
}
}
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
function
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
TOP_COMPOSITION_END
:
return
getDataFromCustomEvent
(
nativeEvent
)
;
case
TOP_KEY_PRESS
:
var
which
=
nativeEvent
.
which
;
if
(
which
!
=
=
SPACEBAR_CODE
)
{
return
null
;
}
hasSpaceKeypress
=
true
;
return
SPACEBAR_CHAR
;
case
TOP_TEXT_INPUT
:
var
chars
=
nativeEvent
.
data
;
if
(
chars
=
=
=
SPACEBAR_CHAR
&
&
hasSpaceKeypress
)
{
return
null
;
}
return
chars
;
default
:
return
null
;
}
}
function
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
{
if
(
isComposing
)
{
if
(
topLevelType
=
=
=
TOP_COMPOSITION_END
|
|
!
canUseCompositionEvent
&
&
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
var
chars
=
getData
(
)
;
reset
(
)
;
isComposing
=
false
;
return
chars
;
}
return
null
;
}
switch
(
topLevelType
)
{
case
TOP_PASTE
:
return
null
;
case
TOP_KEY_PRESS
:
if
(
!
isKeypressCommand
(
nativeEvent
)
)
{
if
(
nativeEvent
.
char
&
&
nativeEvent
.
char
.
length
>
1
)
{
return
nativeEvent
.
char
;
}
else
if
(
nativeEvent
.
which
)
{
return
String
.
fromCharCode
(
nativeEvent
.
which
)
;
}
}
return
null
;
case
TOP_COMPOSITION_END
:
return
useFallbackCompositionData
&
&
!
isUsingKoreanIME
(
nativeEvent
)
?
null
:
nativeEvent
.
data
;
default
:
return
null
;
}
}
function
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
chars
=
void
0
;
if
(
canUseTextInputEvent
)
{
chars
=
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
else
{
chars
=
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
if
(
!
chars
)
{
return
null
;
}
var
event
=
SyntheticInputEvent
.
getPooled
(
eventTypes
.
beforeInput
targetInst
nativeEvent
nativeEventTarget
)
;
event
.
data
=
chars
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
BeforeInputEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
composition
=
extractCompositionEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
var
beforeInput
=
extractBeforeInputEvent
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
;
if
(
composition
=
=
=
null
)
{
return
beforeInput
;
}
if
(
beforeInput
=
=
=
null
)
{
return
composition
;
}
return
[
composition
beforeInput
]
;
}
}
;
var
restoreImpl
=
null
;
var
restoreTarget
=
null
;
var
restoreQueue
=
null
;
function
restoreStateOfTarget
(
target
)
{
var
internalInstance
=
getInstanceFromNode
(
target
)
;
if
(
!
internalInstance
)
{
return
;
}
!
(
typeof
restoreImpl
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
280
'
)
:
void
0
;
var
props
=
getFiberCurrentPropsFromNode
(
internalInstance
.
stateNode
)
;
restoreImpl
(
internalInstance
.
stateNode
internalInstance
.
type
props
)
;
}
function
setRestoreImplementation
(
impl
)
{
restoreImpl
=
impl
;
}
function
enqueueStateRestore
(
target
)
{
if
(
restoreTarget
)
{
if
(
restoreQueue
)
{
restoreQueue
.
push
(
target
)
;
}
else
{
restoreQueue
=
[
target
]
;
}
}
else
{
restoreTarget
=
target
;
}
}
function
needsStateRestore
(
)
{
return
restoreTarget
!
=
=
null
|
|
restoreQueue
!
=
=
null
;
}
function
restoreStateIfNeeded
(
)
{
if
(
!
restoreTarget
)
{
return
;
}
var
target
=
restoreTarget
;
var
queuedTargets
=
restoreQueue
;
restoreTarget
=
null
;
restoreQueue
=
null
;
restoreStateOfTarget
(
target
)
;
if
(
queuedTargets
)
{
for
(
var
i
=
0
;
i
<
queuedTargets
.
length
;
i
+
+
)
{
restoreStateOfTarget
(
queuedTargets
[
i
]
)
;
}
}
}
var
_batchedUpdatesImpl
=
function
(
fn
bookkeeping
)
{
return
fn
(
bookkeeping
)
;
}
;
var
_interactiveUpdatesImpl
=
function
(
fn
a
b
)
{
return
fn
(
a
b
)
;
}
;
var
_flushInteractiveUpdatesImpl
=
function
(
)
{
}
;
var
isBatching
=
false
;
function
batchedUpdates
(
fn
bookkeeping
)
{
if
(
isBatching
)
{
return
fn
(
bookkeeping
)
;
}
isBatching
=
true
;
try
{
return
_batchedUpdatesImpl
(
fn
bookkeeping
)
;
}
finally
{
isBatching
=
false
;
var
controlledComponentsHavePendingUpdates
=
needsStateRestore
(
)
;
if
(
controlledComponentsHavePendingUpdates
)
{
_flushInteractiveUpdatesImpl
(
)
;
restoreStateIfNeeded
(
)
;
}
}
}
function
interactiveUpdates
(
fn
a
b
)
{
return
_interactiveUpdatesImpl
(
fn
a
b
)
;
}
function
setBatchingImplementation
(
batchedUpdatesImpl
interactiveUpdatesImpl
flushInteractiveUpdatesImpl
)
{
_batchedUpdatesImpl
=
batchedUpdatesImpl
;
_interactiveUpdatesImpl
=
interactiveUpdatesImpl
;
_flushInteractiveUpdatesImpl
=
flushInteractiveUpdatesImpl
;
}
var
supportedInputTypes
=
{
color
:
true
date
:
true
datetime
:
true
'
datetime
-
local
'
:
true
email
:
true
month
:
true
number
:
true
password
:
true
range
:
true
search
:
true
tel
:
true
text
:
true
time
:
true
url
:
true
week
:
true
}
;
function
isTextInputElement
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
if
(
nodeName
=
=
=
'
input
'
)
{
return
!
!
supportedInputTypes
[
elem
.
type
]
;
}
if
(
nodeName
=
=
=
'
textarea
'
)
{
return
true
;
}
return
false
;
}
var
ELEMENT_NODE
=
1
;
var
TEXT_NODE
=
3
;
var
COMMENT_NODE
=
8
;
var
DOCUMENT_NODE
=
9
;
var
DOCUMENT_FRAGMENT_NODE
=
11
;
function
getEventTarget
(
nativeEvent
)
{
var
target
=
nativeEvent
.
target
|
|
nativeEvent
.
srcElement
|
|
window
;
if
(
target
.
correspondingUseElement
)
{
target
=
target
.
correspondingUseElement
;
}
return
target
.
nodeType
=
=
=
TEXT_NODE
?
target
.
parentNode
:
target
;
}
function
isEventSupported
(
eventNameSuffix
)
{
if
(
!
canUseDOM
)
{
return
false
;
}
var
eventName
=
'
on
'
+
eventNameSuffix
;
var
isSupported
=
eventName
in
document
;
if
(
!
isSupported
)
{
var
element
=
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
element
.
setAttribute
(
eventName
'
return
;
'
)
;
isSupported
=
typeof
element
[
eventName
]
=
=
=
'
function
'
;
}
return
isSupported
;
}
function
isCheckable
(
elem
)
{
var
type
=
elem
.
type
;
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
type
=
=
=
'
checkbox
'
|
|
type
=
=
=
'
radio
'
)
;
}
function
getTracker
(
node
)
{
return
node
.
_valueTracker
;
}
function
detachTracker
(
node
)
{
node
.
_valueTracker
=
null
;
}
function
getValueFromNode
(
node
)
{
var
value
=
'
'
;
if
(
!
node
)
{
return
value
;
}
if
(
isCheckable
(
node
)
)
{
value
=
node
.
checked
?
'
true
'
:
'
false
'
;
}
else
{
value
=
node
.
value
;
}
return
value
;
}
function
trackValueOnNode
(
node
)
{
var
valueField
=
isCheckable
(
node
)
?
'
checked
'
:
'
value
'
;
var
descriptor
=
Object
.
getOwnPropertyDescriptor
(
node
.
constructor
.
prototype
valueField
)
;
var
currentValue
=
'
'
+
node
[
valueField
]
;
if
(
node
.
hasOwnProperty
(
valueField
)
|
|
typeof
descriptor
=
=
=
'
undefined
'
|
|
typeof
descriptor
.
get
!
=
=
'
function
'
|
|
typeof
descriptor
.
set
!
=
=
'
function
'
)
{
return
;
}
var
get
=
descriptor
.
get
set
=
descriptor
.
set
;
Object
.
defineProperty
(
node
valueField
{
configurable
:
true
get
:
function
(
)
{
return
get
.
call
(
this
)
;
}
set
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
set
.
call
(
this
value
)
;
}
}
)
;
Object
.
defineProperty
(
node
valueField
{
enumerable
:
descriptor
.
enumerable
}
)
;
var
tracker
=
{
getValue
:
function
(
)
{
return
currentValue
;
}
setValue
:
function
(
value
)
{
currentValue
=
'
'
+
value
;
}
stopTracking
:
function
(
)
{
detachTracker
(
node
)
;
delete
node
[
valueField
]
;
}
}
;
return
tracker
;
}
function
track
(
node
)
{
if
(
getTracker
(
node
)
)
{
return
;
}
node
.
_valueTracker
=
trackValueOnNode
(
node
)
;
}
function
updateValueIfChanged
(
node
)
{
if
(
!
node
)
{
return
false
;
}
var
tracker
=
getTracker
(
node
)
;
if
(
!
tracker
)
{
return
true
;
}
var
lastValue
=
tracker
.
getValue
(
)
;
var
nextValue
=
getValueFromNode
(
node
)
;
if
(
nextValue
!
=
=
lastValue
)
{
tracker
.
setValue
(
nextValue
)
;
return
true
;
}
return
false
;
}
var
ReactSharedInternals
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
if
(
!
ReactSharedInternals
.
hasOwnProperty
(
'
ReactCurrentDispatcher
'
)
)
{
ReactSharedInternals
.
ReactCurrentDispatcher
=
{
current
:
null
}
;
}
var
BEFORE_SLASH_RE
=
/
^
(
.
*
)
[
\
\
\
/
]
/
;
var
describeComponentFrame
=
function
(
name
source
ownerName
)
{
var
sourceInfo
=
'
'
;
if
(
source
)
{
var
path
=
source
.
fileName
;
var
fileName
=
path
.
replace
(
BEFORE_SLASH_RE
'
'
)
;
sourceInfo
=
'
(
at
'
+
fileName
+
'
:
'
+
source
.
lineNumber
+
'
)
'
;
}
else
if
(
ownerName
)
{
sourceInfo
=
'
(
created
by
'
+
ownerName
+
'
)
'
;
}
return
'
\
n
in
'
+
(
name
|
|
'
Unknown
'
)
+
sourceInfo
;
}
;
var
hasSymbol
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
for
;
var
REACT_ELEMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
element
'
)
:
0xeac7
;
var
REACT_PORTAL_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
portal
'
)
:
0xeaca
;
var
REACT_FRAGMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
fragment
'
)
:
0xeacb
;
var
REACT_STRICT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
strict_mode
'
)
:
0xeacc
;
var
REACT_PROFILER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
profiler
'
)
:
0xead2
;
var
REACT_PROVIDER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
provider
'
)
:
0xeacd
;
var
REACT_CONTEXT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
context
'
)
:
0xeace
;
var
REACT_CONCURRENT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
concurrent_mode
'
)
:
0xeacf
;
var
REACT_FORWARD_REF_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
forward_ref
'
)
:
0xead0
;
var
REACT_SUSPENSE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
suspense
'
)
:
0xead1
;
var
REACT_MEMO_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
memo
'
)
:
0xead3
;
var
REACT_LAZY_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
lazy
'
)
:
0xead4
;
var
MAYBE_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
if
(
maybeIterable
=
=
=
null
|
|
typeof
maybeIterable
!
=
=
'
object
'
)
{
return
null
;
}
var
maybeIterator
=
MAYBE_ITERATOR_SYMBOL
&
&
maybeIterable
[
MAYBE_ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
;
if
(
typeof
maybeIterator
=
=
=
'
function
'
)
{
return
maybeIterator
;
}
return
null
;
}
var
Pending
=
0
;
var
Resolved
=
1
;
var
Rejected
=
2
;
function
refineResolvedLazyComponent
(
lazyComponent
)
{
return
lazyComponent
.
_status
=
=
=
Resolved
?
lazyComponent
.
_result
:
null
;
}
function
getWrappedName
(
outerType
innerType
wrapperName
)
{
var
functionName
=
innerType
.
displayName
|
|
innerType
.
name
|
|
'
'
;
return
outerType
.
displayName
|
|
(
functionName
!
=
=
'
'
?
wrapperName
+
'
(
'
+
functionName
+
'
)
'
:
wrapperName
)
;
}
function
getComponentName
(
type
)
{
if
(
type
=
=
null
)
{
return
null
;
}
if
(
typeof
type
=
=
=
'
function
'
)
{
return
type
.
displayName
|
|
type
.
name
|
|
null
;
}
if
(
typeof
type
=
=
=
'
string
'
)
{
return
type
;
}
switch
(
type
)
{
case
REACT_CONCURRENT_MODE_TYPE
:
return
'
ConcurrentMode
'
;
case
REACT_FRAGMENT_TYPE
:
return
'
Fragment
'
;
case
REACT_PORTAL_TYPE
:
return
'
Portal
'
;
case
REACT_PROFILER_TYPE
:
return
'
Profiler
'
;
case
REACT_STRICT_MODE_TYPE
:
return
'
StrictMode
'
;
case
REACT_SUSPENSE_TYPE
:
return
'
Suspense
'
;
}
if
(
typeof
type
=
=
=
'
object
'
)
{
switch
(
type
.
typeof
)
{
case
REACT_CONTEXT_TYPE
:
return
'
Context
.
Consumer
'
;
case
REACT_PROVIDER_TYPE
:
return
'
Context
.
Provider
'
;
case
REACT_FORWARD_REF_TYPE
:
return
getWrappedName
(
type
type
.
render
'
ForwardRef
'
)
;
case
REACT_MEMO_TYPE
:
return
getComponentName
(
type
.
type
)
;
case
REACT_LAZY_TYPE
:
{
var
thenable
=
type
;
var
resolvedThenable
=
refineResolvedLazyComponent
(
thenable
)
;
if
(
resolvedThenable
)
{
return
getComponentName
(
resolvedThenable
)
;
}
}
}
}
return
null
;
}
var
ReactDebugCurrentFrame
=
ReactSharedInternals
.
ReactDebugCurrentFrame
;
function
describeFiber
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
case
HostPortal
:
case
HostText
:
case
Fragment
:
case
ContextProvider
:
case
ContextConsumer
:
return
'
'
;
default
:
var
owner
=
fiber
.
_debugOwner
;
var
source
=
fiber
.
_debugSource
;
var
name
=
getComponentName
(
fiber
.
type
)
;
var
ownerName
=
null
;
if
(
owner
)
{
ownerName
=
getComponentName
(
owner
.
type
)
;
}
return
describeComponentFrame
(
name
source
ownerName
)
;
}
}
function
getStackByFiberInDevAndProd
(
workInProgress
)
{
var
info
=
'
'
;
var
node
=
workInProgress
;
do
{
info
+
=
describeFiber
(
node
)
;
node
=
node
.
return
;
}
while
(
node
)
;
return
info
;
}
var
RESERVED
=
0
;
var
STRING
=
1
;
var
BOOLEANISH_STRING
=
2
;
var
BOOLEAN
=
3
;
var
OVERLOADED_BOOLEAN
=
4
;
var
NUMERIC
=
5
;
var
POSITIVE_NUMERIC
=
6
;
var
ATTRIBUTE_NAME_START_CHAR
=
'
:
A
-
Z_a
-
z
\
\
u00C0
-
\
\
u00D6
\
\
u00D8
-
\
\
u00F6
\
\
u00F8
-
\
\
u02FF
\
\
u0370
-
\
\
u037D
\
\
u037F
-
\
\
u1FFF
\
\
u200C
-
\
\
u200D
\
\
u2070
-
\
\
u218F
\
\
u2C00
-
\
\
u2FEF
\
\
u3001
-
\
\
uD7FF
\
\
uF900
-
\
\
uFDCF
\
\
uFDF0
-
\
\
uFFFD
'
;
var
ATTRIBUTE_NAME_CHAR
=
ATTRIBUTE_NAME_START_CHAR
+
'
\
\
-
.
0
-
9
\
\
u00B7
\
\
u0300
-
\
\
u036F
\
\
u203F
-
\
\
u2040
'
;
var
ROOT_ATTRIBUTE_NAME
=
'
data
-
reactroot
'
;
var
VALID_ATTRIBUTE_NAME_REGEX
=
new
RegExp
(
'
^
[
'
+
ATTRIBUTE_NAME_START_CHAR
+
'
]
[
'
+
ATTRIBUTE_NAME_CHAR
+
'
]
*
'
)
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
var
illegalAttributeNameCache
=
{
}
;
var
validatedAttributeNameCache
=
{
}
;
function
isAttributeNameSafe
(
attributeName
)
{
if
(
hasOwnProperty
.
call
(
validatedAttributeNameCache
attributeName
)
)
{
return
true
;
}
if
(
hasOwnProperty
.
call
(
illegalAttributeNameCache
attributeName
)
)
{
return
false
;
}
if
(
VALID_ATTRIBUTE_NAME_REGEX
.
test
(
attributeName
)
)
{
validatedAttributeNameCache
[
attributeName
]
=
true
;
return
true
;
}
illegalAttributeNameCache
[
attributeName
]
=
true
;
return
false
;
}
function
shouldIgnoreAttribute
(
name
propertyInfo
isCustomComponentTag
)
{
if
(
propertyInfo
!
=
=
null
)
{
return
propertyInfo
.
type
=
=
=
RESERVED
;
}
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
name
.
length
>
2
&
&
(
name
[
0
]
=
=
=
'
o
'
|
|
name
[
0
]
=
=
=
'
O
'
)
&
&
(
name
[
1
]
=
=
=
'
n
'
|
|
name
[
1
]
=
=
=
'
N
'
)
)
{
return
true
;
}
return
false
;
}
function
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
isCustomComponentTag
)
{
if
(
propertyInfo
!
=
=
null
&
&
propertyInfo
.
type
=
=
=
RESERVED
)
{
return
false
;
}
switch
(
typeof
value
)
{
case
'
function
'
:
case
'
symbol
'
:
return
true
;
case
'
boolean
'
:
{
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
propertyInfo
!
=
=
null
)
{
return
!
propertyInfo
.
acceptsBooleans
;
}
else
{
var
prefix
=
name
.
toLowerCase
(
)
.
slice
(
0
5
)
;
return
prefix
!
=
=
'
data
-
'
&
&
prefix
!
=
=
'
aria
-
'
;
}
}
default
:
return
false
;
}
}
function
shouldRemoveAttribute
(
name
value
propertyInfo
isCustomComponentTag
)
{
if
(
value
=
=
=
null
|
|
typeof
value
=
=
=
'
undefined
'
)
{
return
true
;
}
if
(
shouldRemoveAttributeWithWarning
(
name
value
propertyInfo
isCustomComponentTag
)
)
{
return
true
;
}
if
(
isCustomComponentTag
)
{
return
false
;
}
if
(
propertyInfo
!
=
=
null
)
{
switch
(
propertyInfo
.
type
)
{
case
BOOLEAN
:
return
!
value
;
case
OVERLOADED_BOOLEAN
:
return
value
=
=
=
false
;
case
NUMERIC
:
return
isNaN
(
value
)
;
case
POSITIVE_NUMERIC
:
return
isNaN
(
value
)
|
|
value
<
1
;
}
}
return
false
;
}
function
getPropertyInfo
(
name
)
{
return
properties
.
hasOwnProperty
(
name
)
?
properties
[
name
]
:
null
;
}
function
PropertyInfoRecord
(
name
type
mustUseProperty
attributeName
attributeNamespace
)
{
this
.
acceptsBooleans
=
type
=
=
=
BOOLEANISH_STRING
|
|
type
=
=
=
BOOLEAN
|
|
type
=
=
=
OVERLOADED_BOOLEAN
;
this
.
attributeName
=
attributeName
;
this
.
attributeNamespace
=
attributeNamespace
;
this
.
mustUseProperty
=
mustUseProperty
;
this
.
propertyName
=
name
;
this
.
type
=
type
;
}
var
properties
=
{
}
;
[
'
children
'
'
dangerouslySetInnerHTML
'
'
defaultValue
'
'
defaultChecked
'
'
innerHTML
'
'
suppressContentEditableWarning
'
'
suppressHydrationWarning
'
'
style
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
RESERVED
false
name
null
)
;
}
)
;
[
[
'
acceptCharset
'
'
accept
-
charset
'
]
[
'
className
'
'
class
'
]
[
'
htmlFor
'
'
for
'
]
[
'
httpEquiv
'
'
http
-
equiv
'
]
]
.
forEach
(
function
(
_ref
)
{
var
name
=
_ref
[
0
]
attributeName
=
_ref
[
1
]
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
null
)
;
}
)
;
[
'
contentEditable
'
'
draggable
'
'
spellCheck
'
'
value
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEANISH_STRING
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
[
'
autoReverse
'
'
externalResourcesRequired
'
'
focusable
'
'
preserveAlpha
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEANISH_STRING
false
name
null
)
;
}
)
;
[
'
allowFullScreen
'
'
async
'
'
autoFocus
'
'
autoPlay
'
'
controls
'
'
default
'
'
defer
'
'
disabled
'
'
formNoValidate
'
'
hidden
'
'
loop
'
'
noModule
'
'
noValidate
'
'
open
'
'
playsInline
'
'
readOnly
'
'
required
'
'
reversed
'
'
scoped
'
'
seamless
'
'
itemScope
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEAN
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
[
'
checked
'
'
multiple
'
'
muted
'
'
selected
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
BOOLEAN
true
name
null
)
;
}
)
;
[
'
capture
'
'
download
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
OVERLOADED_BOOLEAN
false
name
null
)
;
}
)
;
[
'
cols
'
'
rows
'
'
size
'
'
span
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
POSITIVE_NUMERIC
false
name
null
)
;
}
)
;
[
'
rowSpan
'
'
start
'
]
.
forEach
(
function
(
name
)
{
properties
[
name
]
=
new
PropertyInfoRecord
(
name
NUMERIC
false
name
.
toLowerCase
(
)
null
)
;
}
)
;
var
CAMELIZE
=
/
[
\
-
\
:
]
(
[
a
-
z
]
)
/
g
;
var
capitalize
=
function
(
token
)
{
return
token
[
1
]
.
toUpperCase
(
)
;
}
;
[
'
accent
-
height
'
'
alignment
-
baseline
'
'
arabic
-
form
'
'
baseline
-
shift
'
'
cap
-
height
'
'
clip
-
path
'
'
clip
-
rule
'
'
color
-
interpolation
'
'
color
-
interpolation
-
filters
'
'
color
-
profile
'
'
color
-
rendering
'
'
dominant
-
baseline
'
'
enable
-
background
'
'
fill
-
opacity
'
'
fill
-
rule
'
'
flood
-
color
'
'
flood
-
opacity
'
'
font
-
family
'
'
font
-
size
'
'
font
-
size
-
adjust
'
'
font
-
stretch
'
'
font
-
style
'
'
font
-
variant
'
'
font
-
weight
'
'
glyph
-
name
'
'
glyph
-
orientation
-
horizontal
'
'
glyph
-
orientation
-
vertical
'
'
horiz
-
adv
-
x
'
'
horiz
-
origin
-
x
'
'
image
-
rendering
'
'
letter
-
spacing
'
'
lighting
-
color
'
'
marker
-
end
'
'
marker
-
mid
'
'
marker
-
start
'
'
overline
-
position
'
'
overline
-
thickness
'
'
paint
-
order
'
'
panose
-
1
'
'
pointer
-
events
'
'
rendering
-
intent
'
'
shape
-
rendering
'
'
stop
-
color
'
'
stop
-
opacity
'
'
strikethrough
-
position
'
'
strikethrough
-
thickness
'
'
stroke
-
dasharray
'
'
stroke
-
dashoffset
'
'
stroke
-
linecap
'
'
stroke
-
linejoin
'
'
stroke
-
miterlimit
'
'
stroke
-
opacity
'
'
stroke
-
width
'
'
text
-
anchor
'
'
text
-
decoration
'
'
text
-
rendering
'
'
underline
-
position
'
'
underline
-
thickness
'
'
unicode
-
bidi
'
'
unicode
-
range
'
'
units
-
per
-
em
'
'
v
-
alphabetic
'
'
v
-
hanging
'
'
v
-
ideographic
'
'
v
-
mathematical
'
'
vector
-
effect
'
'
vert
-
adv
-
y
'
'
vert
-
origin
-
x
'
'
vert
-
origin
-
y
'
'
word
-
spacing
'
'
writing
-
mode
'
'
xmlns
:
xlink
'
'
x
-
height
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
null
)
;
}
)
;
[
'
xlink
:
actuate
'
'
xlink
:
arcrole
'
'
xlink
:
href
'
'
xlink
:
role
'
'
xlink
:
show
'
'
xlink
:
title
'
'
xlink
:
type
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
)
;
}
)
;
[
'
xml
:
base
'
'
xml
:
lang
'
'
xml
:
space
'
]
.
forEach
(
function
(
attributeName
)
{
var
name
=
attributeName
.
replace
(
CAMELIZE
capitalize
)
;
properties
[
name
]
=
new
PropertyInfoRecord
(
name
STRING
false
attributeName
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
)
;
}
)
;
[
'
tabIndex
'
'
crossOrigin
'
]
.
forEach
(
function
(
attributeName
)
{
properties
[
attributeName
]
=
new
PropertyInfoRecord
(
attributeName
STRING
false
attributeName
.
toLowerCase
(
)
null
)
;
}
)
;
function
setValueForProperty
(
node
name
value
isCustomComponentTag
)
{
var
propertyInfo
=
getPropertyInfo
(
name
)
;
if
(
shouldIgnoreAttribute
(
name
propertyInfo
isCustomComponentTag
)
)
{
return
;
}
if
(
shouldRemoveAttribute
(
name
value
propertyInfo
isCustomComponentTag
)
)
{
value
=
null
;
}
if
(
isCustomComponentTag
|
|
propertyInfo
=
=
=
null
)
{
if
(
isAttributeNameSafe
(
name
)
)
{
var
_attributeName
=
name
;
if
(
value
=
=
=
null
)
{
node
.
removeAttribute
(
_attributeName
)
;
}
else
{
node
.
setAttribute
(
_attributeName
'
'
+
value
)
;
}
}
return
;
}
var
mustUseProperty
=
propertyInfo
.
mustUseProperty
;
if
(
mustUseProperty
)
{
var
propertyName
=
propertyInfo
.
propertyName
;
if
(
value
=
=
=
null
)
{
var
type
=
propertyInfo
.
type
;
node
[
propertyName
]
=
type
=
=
=
BOOLEAN
?
false
:
'
'
;
}
else
{
node
[
propertyName
]
=
value
;
}
return
;
}
var
attributeName
=
propertyInfo
.
attributeName
attributeNamespace
=
propertyInfo
.
attributeNamespace
;
if
(
value
=
=
=
null
)
{
node
.
removeAttribute
(
attributeName
)
;
}
else
{
var
_type
=
propertyInfo
.
type
;
var
attributeValue
=
void
0
;
if
(
_type
=
=
=
BOOLEAN
|
|
_type
=
=
=
OVERLOADED_BOOLEAN
&
&
value
=
=
=
true
)
{
attributeValue
=
'
'
;
}
else
{
attributeValue
=
'
'
+
value
;
}
if
(
attributeNamespace
)
{
node
.
setAttributeNS
(
attributeNamespace
attributeName
attributeValue
)
;
}
else
{
node
.
setAttribute
(
attributeName
attributeValue
)
;
}
}
}
function
toString
(
value
)
{
return
'
'
+
value
;
}
function
getToStringValue
(
value
)
{
switch
(
typeof
value
)
{
case
'
boolean
'
:
case
'
number
'
:
case
'
object
'
:
case
'
string
'
:
case
'
undefined
'
:
return
value
;
default
:
return
'
'
;
}
}
var
enableUserTimingAPI
=
false
;
var
enableProfilerTimer
=
false
;
var
enableSchedulerTracing
=
false
;
var
enableSuspenseServerRenderer
=
false
;
var
disableInputAttributeSyncing
=
false
;
var
enableStableConcurrentModeAPIs
=
false
;
function
isControlled
(
props
)
{
var
usesChecked
=
props
.
type
=
=
=
'
checkbox
'
|
|
props
.
type
=
=
=
'
radio
'
;
return
usesChecked
?
props
.
checked
!
=
null
:
props
.
value
!
=
null
;
}
function
getHostProps
(
element
props
)
{
var
node
=
element
;
var
checked
=
props
.
checked
;
var
hostProps
=
_assign
(
{
}
props
{
defaultChecked
:
undefined
defaultValue
:
undefined
value
:
undefined
checked
:
checked
!
=
null
?
checked
:
node
.
_wrapperState
.
initialChecked
}
)
;
return
hostProps
;
}
function
initWrapperState
(
element
props
)
{
var
node
=
element
;
var
defaultValue
=
props
.
defaultValue
=
=
null
?
'
'
:
props
.
defaultValue
;
node
.
_wrapperState
=
{
initialChecked
:
props
.
checked
!
=
null
?
props
.
checked
:
props
.
defaultChecked
initialValue
:
getToStringValue
(
props
.
value
!
=
null
?
props
.
value
:
defaultValue
)
controlled
:
isControlled
(
props
)
}
;
}
function
updateChecked
(
element
props
)
{
var
node
=
element
;
var
checked
=
props
.
checked
;
if
(
checked
!
=
null
)
{
setValueForProperty
(
node
'
checked
'
checked
false
)
;
}
}
function
updateWrapper
(
element
props
)
{
var
node
=
element
;
updateChecked
(
element
props
)
;
var
value
=
getToStringValue
(
props
.
value
)
;
var
type
=
props
.
type
;
if
(
value
!
=
null
)
{
if
(
type
=
=
=
'
number
'
)
{
if
(
value
=
=
=
0
&
&
node
.
value
=
=
=
'
'
|
|
node
.
value
!
=
value
)
{
node
.
value
=
toString
(
value
)
;
}
}
else
if
(
node
.
value
!
=
=
toString
(
value
)
)
{
node
.
value
=
toString
(
value
)
;
}
}
else
if
(
type
=
=
=
'
submit
'
|
|
type
=
=
=
'
reset
'
)
{
node
.
removeAttribute
(
'
value
'
)
;
return
;
}
if
(
disableInputAttributeSyncing
)
{
if
(
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
setDefaultValue
(
node
props
.
type
getToStringValue
(
props
.
defaultValue
)
)
;
}
}
else
{
if
(
props
.
hasOwnProperty
(
'
value
'
)
)
{
setDefaultValue
(
node
props
.
type
value
)
;
}
else
if
(
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
setDefaultValue
(
node
props
.
type
getToStringValue
(
props
.
defaultValue
)
)
;
}
}
if
(
disableInputAttributeSyncing
)
{
if
(
props
.
defaultChecked
=
=
null
)
{
node
.
removeAttribute
(
'
checked
'
)
;
}
else
{
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
else
{
if
(
props
.
checked
=
=
null
&
&
props
.
defaultChecked
!
=
null
)
{
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
}
function
postMountWrapper
(
element
props
isHydrating
)
{
var
node
=
element
;
if
(
props
.
hasOwnProperty
(
'
value
'
)
|
|
props
.
hasOwnProperty
(
'
defaultValue
'
)
)
{
var
type
=
props
.
type
;
var
isButton
=
type
=
=
=
'
submit
'
|
|
type
=
=
=
'
reset
'
;
if
(
isButton
&
&
(
props
.
value
=
=
=
undefined
|
|
props
.
value
=
=
=
null
)
)
{
return
;
}
var
_initialValue
=
toString
(
node
.
_wrapperState
.
initialValue
)
;
if
(
!
isHydrating
)
{
if
(
disableInputAttributeSyncing
)
{
var
value
=
getToStringValue
(
props
.
value
)
;
if
(
value
!
=
null
)
{
if
(
isButton
|
|
value
!
=
=
node
.
value
)
{
node
.
value
=
toString
(
value
)
;
}
}
}
else
{
if
(
_initialValue
!
=
=
node
.
value
)
{
node
.
value
=
_initialValue
;
}
}
}
if
(
disableInputAttributeSyncing
)
{
var
defaultValue
=
getToStringValue
(
props
.
defaultValue
)
;
if
(
defaultValue
!
=
null
)
{
node
.
defaultValue
=
toString
(
defaultValue
)
;
}
}
else
{
node
.
defaultValue
=
_initialValue
;
}
}
var
name
=
node
.
name
;
if
(
name
!
=
=
'
'
)
{
node
.
name
=
'
'
;
}
if
(
disableInputAttributeSyncing
)
{
if
(
!
isHydrating
)
{
updateChecked
(
element
props
)
;
}
if
(
props
.
hasOwnProperty
(
'
defaultChecked
'
)
)
{
node
.
defaultChecked
=
!
node
.
defaultChecked
;
node
.
defaultChecked
=
!
!
props
.
defaultChecked
;
}
}
else
{
node
.
defaultChecked
=
!
node
.
defaultChecked
;
node
.
defaultChecked
=
!
!
node
.
_wrapperState
.
initialChecked
;
}
if
(
name
!
=
=
'
'
)
{
node
.
name
=
name
;
}
}
function
restoreControlledState
(
element
props
)
{
var
node
=
element
;
updateWrapper
(
node
props
)
;
updateNamedCousins
(
node
props
)
;
}
function
updateNamedCousins
(
rootNode
props
)
{
var
name
=
props
.
name
;
if
(
props
.
type
=
=
=
'
radio
'
&
&
name
!
=
null
)
{
var
queryRoot
=
rootNode
;
while
(
queryRoot
.
parentNode
)
{
queryRoot
=
queryRoot
.
parentNode
;
}
var
group
=
queryRoot
.
querySelectorAll
(
'
input
[
name
=
'
+
JSON
.
stringify
(
'
'
+
name
)
+
'
]
[
type
=
"
radio
"
]
'
)
;
for
(
var
i
=
0
;
i
<
group
.
length
;
i
+
+
)
{
var
otherNode
=
group
[
i
]
;
if
(
otherNode
=
=
=
rootNode
|
|
otherNode
.
form
!
=
=
rootNode
.
form
)
{
continue
;
}
var
otherProps
=
getFiberCurrentPropsFromNode
1
(
otherNode
)
;
!
otherProps
?
reactProdInvariant
(
'
90
'
)
:
void
0
;
updateValueIfChanged
(
otherNode
)
;
updateWrapper
(
otherNode
otherProps
)
;
}
}
}
function
setDefaultValue
(
node
type
value
)
{
if
(
type
!
=
=
'
number
'
|
|
node
.
ownerDocument
.
activeElement
!
=
=
node
)
{
if
(
value
=
=
null
)
{
node
.
defaultValue
=
toString
(
node
.
_wrapperState
.
initialValue
)
;
}
else
if
(
node
.
defaultValue
!
=
=
toString
(
value
)
)
{
node
.
defaultValue
=
toString
(
value
)
;
}
}
}
var
eventTypes
1
=
{
change
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onChange
'
captured
:
'
onChangeCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_CHANGE
TOP_CLICK
TOP_FOCUS
TOP_INPUT
TOP_KEY_DOWN
TOP_KEY_UP
TOP_SELECTION_CHANGE
]
}
}
;
function
createAndAccumulateChangeEvent
(
inst
nativeEvent
target
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
1
.
change
inst
nativeEvent
target
)
;
event
.
type
=
'
change
'
;
enqueueStateRestore
(
target
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
activeElement
=
null
;
var
activeElementInst
=
null
;
function
shouldUseChangeEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
=
=
=
'
select
'
|
|
nodeName
=
=
=
'
input
'
&
&
elem
.
type
=
=
=
'
file
'
;
}
function
manualDispatchChangeEvent
(
nativeEvent
)
{
var
event
=
createAndAccumulateChangeEvent
(
activeElementInst
nativeEvent
getEventTarget
(
nativeEvent
)
)
;
batchedUpdates
(
runEventInBatch
event
)
;
}
function
runEventInBatch
(
event
)
{
runEventsInBatch
(
event
)
;
}
function
getInstIfValueChanged
(
targetInst
)
{
var
targetNode
=
getNodeFromInstance
1
(
targetInst
)
;
if
(
updateValueIfChanged
(
targetNode
)
)
{
return
targetInst
;
}
}
function
getTargetInstForChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_CHANGE
)
{
return
targetInst
;
}
}
var
isInputEventSupported
=
false
;
if
(
canUseDOM
)
{
isInputEventSupported
=
isEventSupported
(
'
input
'
)
&
&
(
!
document
.
documentMode
|
|
document
.
documentMode
>
9
)
;
}
function
startWatchingForValueChange
(
target
targetInst
)
{
activeElement
=
target
;
activeElementInst
=
targetInst
;
activeElement
.
attachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
}
function
stopWatchingForValueChange
(
)
{
if
(
!
activeElement
)
{
return
;
}
activeElement
.
detachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
activeElement
=
null
;
activeElementInst
=
null
;
}
function
handlePropertyChange
(
nativeEvent
)
{
if
(
nativeEvent
.
propertyName
!
=
=
'
value
'
)
{
return
;
}
if
(
getInstIfValueChanged
(
activeElementInst
)
)
{
manualDispatchChangeEvent
(
nativeEvent
)
;
}
}
function
handleEventsForInputEventPolyfill
(
topLevelType
target
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_FOCUS
)
{
stopWatchingForValueChange
(
)
;
startWatchingForValueChange
(
target
targetInst
)
;
}
else
if
(
topLevelType
=
=
=
TOP_BLUR
)
{
stopWatchingForValueChange
(
)
;
}
}
function
getTargetInstForInputEventPolyfill
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_SELECTION_CHANGE
|
|
topLevelType
=
=
=
TOP_KEY_UP
|
|
topLevelType
=
=
=
TOP_KEY_DOWN
)
{
return
getInstIfValueChanged
(
activeElementInst
)
;
}
}
function
shouldUseClickEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
;
return
nodeName
&
&
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
checkbox
'
|
|
elem
.
type
=
=
=
'
radio
'
)
;
}
function
getTargetInstForClickEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_CLICK
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
getTargetInstForInputOrChangeEvent
(
topLevelType
targetInst
)
{
if
(
topLevelType
=
=
=
TOP_INPUT
|
|
topLevelType
=
=
=
TOP_CHANGE
)
{
return
getInstIfValueChanged
(
targetInst
)
;
}
}
function
handleControlledInputBlur
(
node
)
{
var
state
=
node
.
_wrapperState
;
if
(
!
state
|
|
!
state
.
controlled
|
|
node
.
type
!
=
=
'
number
'
)
{
return
;
}
if
(
!
disableInputAttributeSyncing
)
{
setDefaultValue
(
node
'
number
'
node
.
value
)
;
}
}
var
ChangeEventPlugin
=
{
eventTypes
:
eventTypes
1
_isInputEventSupported
:
isInputEventSupported
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
var
getTargetInstFunc
=
void
0
handleEventFunc
=
void
0
;
if
(
shouldUseChangeEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForChangeEvent
;
}
else
if
(
isTextInputElement
(
targetNode
)
)
{
if
(
isInputEventSupported
)
{
getTargetInstFunc
=
getTargetInstForInputOrChangeEvent
;
}
else
{
getTargetInstFunc
=
getTargetInstForInputEventPolyfill
;
handleEventFunc
=
handleEventsForInputEventPolyfill
;
}
}
else
if
(
shouldUseClickEvent
(
targetNode
)
)
{
getTargetInstFunc
=
getTargetInstForClickEvent
;
}
if
(
getTargetInstFunc
)
{
var
inst
=
getTargetInstFunc
(
topLevelType
targetInst
)
;
if
(
inst
)
{
var
event
=
createAndAccumulateChangeEvent
(
inst
nativeEvent
nativeEventTarget
)
;
return
event
;
}
}
if
(
handleEventFunc
)
{
handleEventFunc
(
topLevelType
targetNode
targetInst
)
;
}
if
(
topLevelType
=
=
=
TOP_BLUR
)
{
handleControlledInputBlur
(
targetNode
)
;
}
}
}
;
var
DOMEventPluginOrder
=
[
'
ResponderEventPlugin
'
'
SimpleEventPlugin
'
'
EnterLeaveEventPlugin
'
'
ChangeEventPlugin
'
'
SelectEventPlugin
'
'
BeforeInputEventPlugin
'
]
;
var
SyntheticUIEvent
=
SyntheticEvent
.
extend
(
{
view
:
null
detail
:
null
}
)
;
var
modifierKeyToProp
=
{
Alt
:
'
altKey
'
Control
:
'
ctrlKey
'
Meta
:
'
metaKey
'
Shift
:
'
shiftKey
'
}
;
function
modifierStateGetter
(
keyArg
)
{
var
syntheticEvent
=
this
;
var
nativeEvent
=
syntheticEvent
.
nativeEvent
;
if
(
nativeEvent
.
getModifierState
)
{
return
nativeEvent
.
getModifierState
(
keyArg
)
;
}
var
keyProp
=
modifierKeyToProp
[
keyArg
]
;
return
keyProp
?
!
!
nativeEvent
[
keyProp
]
:
false
;
}
function
getEventModifierState
(
nativeEvent
)
{
return
modifierStateGetter
;
}
var
previousScreenX
=
0
;
var
previousScreenY
=
0
;
var
isMovementXSet
=
false
;
var
isMovementYSet
=
false
;
var
SyntheticMouseEvent
=
SyntheticUIEvent
.
extend
(
{
screenX
:
null
screenY
:
null
clientX
:
null
clientY
:
null
pageX
:
null
pageY
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
getModifierState
:
getEventModifierState
button
:
null
buttons
:
null
relatedTarget
:
function
(
event
)
{
return
event
.
relatedTarget
|
|
(
event
.
fromElement
=
=
=
event
.
srcElement
?
event
.
toElement
:
event
.
fromElement
)
;
}
movementX
:
function
(
event
)
{
if
(
'
movementX
'
in
event
)
{
return
event
.
movementX
;
}
var
screenX
=
previousScreenX
;
previousScreenX
=
event
.
screenX
;
if
(
!
isMovementXSet
)
{
isMovementXSet
=
true
;
return
0
;
}
return
event
.
type
=
=
=
'
mousemove
'
?
event
.
screenX
-
screenX
:
0
;
}
movementY
:
function
(
event
)
{
if
(
'
movementY
'
in
event
)
{
return
event
.
movementY
;
}
var
screenY
=
previousScreenY
;
previousScreenY
=
event
.
screenY
;
if
(
!
isMovementYSet
)
{
isMovementYSet
=
true
;
return
0
;
}
return
event
.
type
=
=
=
'
mousemove
'
?
event
.
screenY
-
screenY
:
0
;
}
}
)
;
var
SyntheticPointerEvent
=
SyntheticMouseEvent
.
extend
(
{
pointerId
:
null
width
:
null
height
:
null
pressure
:
null
tangentialPressure
:
null
tiltX
:
null
tiltY
:
null
twist
:
null
pointerType
:
null
isPrimary
:
null
}
)
;
var
eventTypes
2
=
{
mouseEnter
:
{
registrationName
:
'
onMouseEnter
'
dependencies
:
[
TOP_MOUSE_OUT
TOP_MOUSE_OVER
]
}
mouseLeave
:
{
registrationName
:
'
onMouseLeave
'
dependencies
:
[
TOP_MOUSE_OUT
TOP_MOUSE_OVER
]
}
pointerEnter
:
{
registrationName
:
'
onPointerEnter
'
dependencies
:
[
TOP_POINTER_OUT
TOP_POINTER_OVER
]
}
pointerLeave
:
{
registrationName
:
'
onPointerLeave
'
dependencies
:
[
TOP_POINTER_OUT
TOP_POINTER_OVER
]
}
}
;
var
EnterLeaveEventPlugin
=
{
eventTypes
:
eventTypes
2
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
isOverEvent
=
topLevelType
=
=
=
TOP_MOUSE_OVER
|
|
topLevelType
=
=
=
TOP_POINTER_OVER
;
var
isOutEvent
=
topLevelType
=
=
=
TOP_MOUSE_OUT
|
|
topLevelType
=
=
=
TOP_POINTER_OUT
;
if
(
isOverEvent
&
&
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
fromElement
)
)
{
return
null
;
}
if
(
!
isOutEvent
&
&
!
isOverEvent
)
{
return
null
;
}
var
win
=
void
0
;
if
(
nativeEventTarget
.
window
=
=
=
nativeEventTarget
)
{
win
=
nativeEventTarget
;
}
else
{
var
doc
=
nativeEventTarget
.
ownerDocument
;
if
(
doc
)
{
win
=
doc
.
defaultView
|
|
doc
.
parentWindow
;
}
else
{
win
=
window
;
}
}
var
from
=
void
0
;
var
to
=
void
0
;
if
(
isOutEvent
)
{
from
=
targetInst
;
var
related
=
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
toElement
;
to
=
related
?
getClosestInstanceFromNode
(
related
)
:
null
;
}
else
{
from
=
null
;
to
=
targetInst
;
}
if
(
from
=
=
=
to
)
{
return
null
;
}
var
eventInterface
=
void
0
leaveEventType
=
void
0
enterEventType
=
void
0
eventTypePrefix
=
void
0
;
if
(
topLevelType
=
=
=
TOP_MOUSE_OUT
|
|
topLevelType
=
=
=
TOP_MOUSE_OVER
)
{
eventInterface
=
SyntheticMouseEvent
;
leaveEventType
=
eventTypes
2
.
mouseLeave
;
enterEventType
=
eventTypes
2
.
mouseEnter
;
eventTypePrefix
=
'
mouse
'
;
}
else
if
(
topLevelType
=
=
=
TOP_POINTER_OUT
|
|
topLevelType
=
=
=
TOP_POINTER_OVER
)
{
eventInterface
=
SyntheticPointerEvent
;
leaveEventType
=
eventTypes
2
.
pointerLeave
;
enterEventType
=
eventTypes
2
.
pointerEnter
;
eventTypePrefix
=
'
pointer
'
;
}
var
fromNode
=
from
=
=
null
?
win
:
getNodeFromInstance
1
(
from
)
;
var
toNode
=
to
=
=
null
?
win
:
getNodeFromInstance
1
(
to
)
;
var
leave
=
eventInterface
.
getPooled
(
leaveEventType
from
nativeEvent
nativeEventTarget
)
;
leave
.
type
=
eventTypePrefix
+
'
leave
'
;
leave
.
target
=
fromNode
;
leave
.
relatedTarget
=
toNode
;
var
enter
=
eventInterface
.
getPooled
(
enterEventType
to
nativeEvent
nativeEventTarget
)
;
enter
.
type
=
eventTypePrefix
+
'
enter
'
;
enter
.
target
=
toNode
;
enter
.
relatedTarget
=
fromNode
;
accumulateEnterLeaveDispatches
(
leave
enter
from
to
)
;
return
[
leave
enter
]
;
}
}
;
function
is
(
x
y
)
{
return
x
=
=
=
y
&
&
(
x
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
)
|
|
x
!
=
=
x
&
&
y
!
=
=
y
;
}
var
hasOwnProperty
1
=
Object
.
prototype
.
hasOwnProperty
;
function
shallowEqual
(
objA
objB
)
{
if
(
is
(
objA
objB
)
)
{
return
true
;
}
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwnProperty
1
.
call
(
objB
keysA
[
i
]
)
|
|
!
is
(
objA
[
keysA
[
i
]
]
objB
[
keysA
[
i
]
]
)
)
{
return
false
;
}
}
return
true
;
}
function
get
(
key
)
{
return
key
.
_reactInternalFiber
;
}
function
has
(
key
)
{
return
key
.
_reactInternalFiber
!
=
=
undefined
;
}
function
set
(
key
value
)
{
key
.
_reactInternalFiber
=
value
;
}
var
NoEffect
=
0
;
var
PerformedWork
=
1
;
var
Placement
=
2
;
var
Update
=
4
;
var
PlacementAndUpdate
=
6
;
var
Deletion
=
8
;
var
ContentReset
=
16
;
var
Callback
=
32
;
var
DidCapture
=
64
;
var
Ref
=
128
;
var
Snapshot
=
256
;
var
Passive
=
512
;
var
LifecycleEffectMask
=
932
;
var
HostEffectMask
=
1023
;
var
Incomplete
=
1024
;
var
ShouldCapture
=
2048
;
var
ReactCurrentOwner
1
=
ReactSharedInternals
.
ReactCurrentOwner
;
var
MOUNTING
=
1
;
var
MOUNTED
=
2
;
var
UNMOUNTED
=
3
;
function
isFiberMountedImpl
(
fiber
)
{
var
node
=
fiber
;
if
(
!
fiber
.
alternate
)
{
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
while
(
node
.
return
)
{
node
=
node
.
return
;
if
(
(
node
.
effectTag
&
Placement
)
!
=
=
NoEffect
)
{
return
MOUNTING
;
}
}
}
else
{
while
(
node
.
return
)
{
node
=
node
.
return
;
}
}
if
(
node
.
tag
=
=
=
HostRoot
)
{
return
MOUNTED
;
}
return
UNMOUNTED
;
}
function
isFiberMounted
(
fiber
)
{
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
isMounted
(
component
)
{
var
fiber
=
get
(
component
)
;
if
(
!
fiber
)
{
return
false
;
}
return
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
;
}
function
assertIsMounted
(
fiber
)
{
!
(
isFiberMountedImpl
(
fiber
)
=
=
=
MOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
}
function
findCurrentFiberUsingSlowPath
(
fiber
)
{
var
alternate
=
fiber
.
alternate
;
if
(
!
alternate
)
{
var
state
=
isFiberMountedImpl
(
fiber
)
;
!
(
state
!
=
=
UNMOUNTED
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
state
=
=
=
MOUNTING
)
{
return
null
;
}
return
fiber
;
}
var
a
=
fiber
;
var
b
=
alternate
;
while
(
true
)
{
var
parentA
=
a
.
return
;
var
parentB
=
parentA
?
parentA
.
alternate
:
null
;
if
(
!
parentA
|
|
!
parentB
)
{
break
;
}
if
(
parentA
.
child
=
=
=
parentB
.
child
)
{
var
child
=
parentA
.
child
;
while
(
child
)
{
if
(
child
=
=
=
a
)
{
assertIsMounted
(
parentA
)
;
return
fiber
;
}
if
(
child
=
=
=
b
)
{
assertIsMounted
(
parentA
)
;
return
alternate
;
}
child
=
child
.
sibling
;
}
reactProdInvariant
(
'
188
'
)
;
}
if
(
a
.
return
!
=
=
b
.
return
)
{
a
=
parentA
;
b
=
parentB
;
}
else
{
var
didFindChild
=
false
;
var
_child
=
parentA
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentA
;
b
=
parentB
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentA
;
a
=
parentB
;
break
;
}
_child
=
_child
.
sibling
;
}
if
(
!
didFindChild
)
{
_child
=
parentB
.
child
;
while
(
_child
)
{
if
(
_child
=
=
=
a
)
{
didFindChild
=
true
;
a
=
parentB
;
b
=
parentA
;
break
;
}
if
(
_child
=
=
=
b
)
{
didFindChild
=
true
;
b
=
parentB
;
a
=
parentA
;
break
;
}
_child
=
_child
.
sibling
;
}
!
didFindChild
?
reactProdInvariant
(
'
189
'
)
:
void
0
;
}
}
!
(
a
.
alternate
=
=
=
b
)
?
reactProdInvariant
(
'
190
'
)
:
void
0
;
}
!
(
a
.
tag
=
=
=
HostRoot
)
?
reactProdInvariant
(
'
188
'
)
:
void
0
;
if
(
a
.
stateNode
.
current
=
=
=
a
)
{
return
fiber
;
}
return
alternate
;
}
function
findCurrentHostFiber
(
parent
)
{
var
currentParent
=
findCurrentFiberUsingSlowPath
(
parent
)
;
if
(
!
currentParent
)
{
return
null
;
}
var
node
=
currentParent
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
return
node
;
}
else
if
(
node
.
child
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
currentParent
)
{
return
null
;
}
while
(
!
node
.
sibling
)
{
if
(
!
node
.
return
|
|
node
.
return
=
=
=
currentParent
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
return
null
;
}
function
addEventBubbleListener
(
element
eventType
listener
)
{
element
.
addEventListener
(
eventType
listener
false
)
;
}
function
addEventCaptureListener
(
element
eventType
listener
)
{
element
.
addEventListener
(
eventType
listener
true
)
;
}
var
SyntheticAnimationEvent
=
SyntheticEvent
.
extend
(
{
animationName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
)
;
var
SyntheticClipboardEvent
=
SyntheticEvent
.
extend
(
{
clipboardData
:
function
(
event
)
{
return
'
clipboardData
'
in
event
?
event
.
clipboardData
:
window
.
clipboardData
;
}
}
)
;
var
SyntheticFocusEvent
=
SyntheticUIEvent
.
extend
(
{
relatedTarget
:
null
}
)
;
function
getEventCharCode
(
nativeEvent
)
{
var
charCode
=
void
0
;
var
keyCode
=
nativeEvent
.
keyCode
;
if
(
'
charCode
'
in
nativeEvent
)
{
charCode
=
nativeEvent
.
charCode
;
if
(
charCode
=
=
=
0
&
&
keyCode
=
=
=
13
)
{
charCode
=
13
;
}
}
else
{
charCode
=
keyCode
;
}
if
(
charCode
=
=
=
10
)
{
charCode
=
13
;
}
if
(
charCode
>
=
32
|
|
charCode
=
=
=
13
)
{
return
charCode
;
}
return
0
;
}
var
normalizeKey
=
{
Esc
:
'
Escape
'
Spacebar
:
'
'
Left
:
'
ArrowLeft
'
Up
:
'
ArrowUp
'
Right
:
'
ArrowRight
'
Down
:
'
ArrowDown
'
Del
:
'
Delete
'
Win
:
'
OS
'
Menu
:
'
ContextMenu
'
Apps
:
'
ContextMenu
'
Scroll
:
'
ScrollLock
'
MozPrintableKey
:
'
Unidentified
'
}
;
var
translateToKey
=
{
'
8
'
:
'
Backspace
'
'
9
'
:
'
Tab
'
'
12
'
:
'
Clear
'
'
13
'
:
'
Enter
'
'
16
'
:
'
Shift
'
'
17
'
:
'
Control
'
'
18
'
:
'
Alt
'
'
19
'
:
'
Pause
'
'
20
'
:
'
CapsLock
'
'
27
'
:
'
Escape
'
'
32
'
:
'
'
'
33
'
:
'
PageUp
'
'
34
'
:
'
PageDown
'
'
35
'
:
'
End
'
'
36
'
:
'
Home
'
'
37
'
:
'
ArrowLeft
'
'
38
'
:
'
ArrowUp
'
'
39
'
:
'
ArrowRight
'
'
40
'
:
'
ArrowDown
'
'
45
'
:
'
Insert
'
'
46
'
:
'
Delete
'
'
112
'
:
'
F1
'
'
113
'
:
'
F2
'
'
114
'
:
'
F3
'
'
115
'
:
'
F4
'
'
116
'
:
'
F5
'
'
117
'
:
'
F6
'
'
118
'
:
'
F7
'
'
119
'
:
'
F8
'
'
120
'
:
'
F9
'
'
121
'
:
'
F10
'
'
122
'
:
'
F11
'
'
123
'
:
'
F12
'
'
144
'
:
'
NumLock
'
'
145
'
:
'
ScrollLock
'
'
224
'
:
'
Meta
'
}
;
function
getEventKey
(
nativeEvent
)
{
if
(
nativeEvent
.
key
)
{
var
key
=
normalizeKey
[
nativeEvent
.
key
]
|
|
nativeEvent
.
key
;
if
(
key
!
=
=
'
Unidentified
'
)
{
return
key
;
}
}
if
(
nativeEvent
.
type
=
=
=
'
keypress
'
)
{
var
charCode
=
getEventCharCode
(
nativeEvent
)
;
return
charCode
=
=
=
13
?
'
Enter
'
:
String
.
fromCharCode
(
charCode
)
;
}
if
(
nativeEvent
.
type
=
=
=
'
keydown
'
|
|
nativeEvent
.
type
=
=
=
'
keyup
'
)
{
return
translateToKey
[
nativeEvent
.
keyCode
]
|
|
'
Unidentified
'
;
}
return
'
'
;
}
var
SyntheticKeyboardEvent
=
SyntheticUIEvent
.
extend
(
{
key
:
getEventKey
location
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
repeat
:
null
locale
:
null
getModifierState
:
getEventModifierState
charCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
return
0
;
}
keyCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
which
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
}
)
;
var
SyntheticDragEvent
=
SyntheticMouseEvent
.
extend
(
{
dataTransfer
:
null
}
)
;
var
SyntheticTouchEvent
=
SyntheticUIEvent
.
extend
(
{
touches
:
null
targetTouches
:
null
changedTouches
:
null
altKey
:
null
metaKey
:
null
ctrlKey
:
null
shiftKey
:
null
getModifierState
:
getEventModifierState
}
)
;
var
SyntheticTransitionEvent
=
SyntheticEvent
.
extend
(
{
propertyName
:
null
elapsedTime
:
null
pseudoElement
:
null
}
)
;
var
SyntheticWheelEvent
=
SyntheticMouseEvent
.
extend
(
{
deltaX
:
function
(
event
)
{
return
'
deltaX
'
in
event
?
event
.
deltaX
:
'
wheelDeltaX
'
in
event
?
-
event
.
wheelDeltaX
:
0
;
}
deltaY
:
function
(
event
)
{
return
'
deltaY
'
in
event
?
event
.
deltaY
:
'
wheelDeltaY
'
in
event
?
-
event
.
wheelDeltaY
:
'
wheelDelta
'
in
event
?
-
event
.
wheelDelta
:
0
;
}
deltaZ
:
null
deltaMode
:
null
}
)
;
var
interactiveEventTypeNames
=
[
[
TOP_BLUR
'
blur
'
]
[
TOP_CANCEL
'
cancel
'
]
[
TOP_CLICK
'
click
'
]
[
TOP_CLOSE
'
close
'
]
[
TOP_CONTEXT_MENU
'
contextMenu
'
]
[
TOP_COPY
'
copy
'
]
[
TOP_CUT
'
cut
'
]
[
TOP_AUX_CLICK
'
auxClick
'
]
[
TOP_DOUBLE_CLICK
'
doubleClick
'
]
[
TOP_DRAG_END
'
dragEnd
'
]
[
TOP_DRAG_START
'
dragStart
'
]
[
TOP_DROP
'
drop
'
]
[
TOP_FOCUS
'
focus
'
]
[
TOP_INPUT
'
input
'
]
[
TOP_INVALID
'
invalid
'
]
[
TOP_KEY_DOWN
'
keyDown
'
]
[
TOP_KEY_PRESS
'
keyPress
'
]
[
TOP_KEY_UP
'
keyUp
'
]
[
TOP_MOUSE_DOWN
'
mouseDown
'
]
[
TOP_MOUSE_UP
'
mouseUp
'
]
[
TOP_PASTE
'
paste
'
]
[
TOP_PAUSE
'
pause
'
]
[
TOP_PLAY
'
play
'
]
[
TOP_POINTER_CANCEL
'
pointerCancel
'
]
[
TOP_POINTER_DOWN
'
pointerDown
'
]
[
TOP_POINTER_UP
'
pointerUp
'
]
[
TOP_RATE_CHANGE
'
rateChange
'
]
[
TOP_RESET
'
reset
'
]
[
TOP_SEEKED
'
seeked
'
]
[
TOP_SUBMIT
'
submit
'
]
[
TOP_TOUCH_CANCEL
'
touchCancel
'
]
[
TOP_TOUCH_END
'
touchEnd
'
]
[
TOP_TOUCH_START
'
touchStart
'
]
[
TOP_VOLUME_CHANGE
'
volumeChange
'
]
]
;
var
nonInteractiveEventTypeNames
=
[
[
TOP_ABORT
'
abort
'
]
[
TOP_ANIMATION_END
'
animationEnd
'
]
[
TOP_ANIMATION_ITERATION
'
animationIteration
'
]
[
TOP_ANIMATION_START
'
animationStart
'
]
[
TOP_CAN_PLAY
'
canPlay
'
]
[
TOP_CAN_PLAY_THROUGH
'
canPlayThrough
'
]
[
TOP_DRAG
'
drag
'
]
[
TOP_DRAG_ENTER
'
dragEnter
'
]
[
TOP_DRAG_EXIT
'
dragExit
'
]
[
TOP_DRAG_LEAVE
'
dragLeave
'
]
[
TOP_DRAG_OVER
'
dragOver
'
]
[
TOP_DURATION_CHANGE
'
durationChange
'
]
[
TOP_EMPTIED
'
emptied
'
]
[
TOP_ENCRYPTED
'
encrypted
'
]
[
TOP_ENDED
'
ended
'
]
[
TOP_ERROR
'
error
'
]
[
TOP_GOT_POINTER_CAPTURE
'
gotPointerCapture
'
]
[
TOP_LOAD
'
load
'
]
[
TOP_LOADED_DATA
'
loadedData
'
]
[
TOP_LOADED_METADATA
'
loadedMetadata
'
]
[
TOP_LOAD_START
'
loadStart
'
]
[
TOP_LOST_POINTER_CAPTURE
'
lostPointerCapture
'
]
[
TOP_MOUSE_MOVE
'
mouseMove
'
]
[
TOP_MOUSE_OUT
'
mouseOut
'
]
[
TOP_MOUSE_OVER
'
mouseOver
'
]
[
TOP_PLAYING
'
playing
'
]
[
TOP_POINTER_MOVE
'
pointerMove
'
]
[
TOP_POINTER_OUT
'
pointerOut
'
]
[
TOP_POINTER_OVER
'
pointerOver
'
]
[
TOP_PROGRESS
'
progress
'
]
[
TOP_SCROLL
'
scroll
'
]
[
TOP_SEEKING
'
seeking
'
]
[
TOP_STALLED
'
stalled
'
]
[
TOP_SUSPEND
'
suspend
'
]
[
TOP_TIME_UPDATE
'
timeUpdate
'
]
[
TOP_TOGGLE
'
toggle
'
]
[
TOP_TOUCH_MOVE
'
touchMove
'
]
[
TOP_TRANSITION_END
'
transitionEnd
'
]
[
TOP_WAITING
'
waiting
'
]
[
TOP_WHEEL
'
wheel
'
]
]
;
var
eventTypes
4
=
{
}
;
var
topLevelEventsToDispatchConfig
=
{
}
;
function
addEventTypeNameToConfig
(
_ref
isInteractive
)
{
var
topEvent
=
_ref
[
0
]
event
=
_ref
[
1
]
;
var
capitalizedEvent
=
event
[
0
]
.
toUpperCase
(
)
+
event
.
slice
(
1
)
;
var
onEvent
=
'
on
'
+
capitalizedEvent
;
var
type
=
{
phasedRegistrationNames
:
{
bubbled
:
onEvent
captured
:
onEvent
+
'
Capture
'
}
dependencies
:
[
topEvent
]
isInteractive
:
isInteractive
}
;
eventTypes
4
[
event
]
=
type
;
topLevelEventsToDispatchConfig
[
topEvent
]
=
type
;
}
interactiveEventTypeNames
.
forEach
(
function
(
eventTuple
)
{
addEventTypeNameToConfig
(
eventTuple
true
)
;
}
)
;
nonInteractiveEventTypeNames
.
forEach
(
function
(
eventTuple
)
{
addEventTypeNameToConfig
(
eventTuple
false
)
;
}
)
;
var
SimpleEventPlugin
=
{
eventTypes
:
eventTypes
4
isInteractiveTopLevelEventType
:
function
(
topLevelType
)
{
var
config
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
return
config
!
=
=
undefined
&
&
config
.
isInteractive
=
=
=
true
;
}
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
dispatchConfig
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
if
(
!
dispatchConfig
)
{
return
null
;
}
var
EventConstructor
=
void
0
;
switch
(
topLevelType
)
{
case
TOP_KEY_PRESS
:
if
(
getEventCharCode
(
nativeEvent
)
=
=
=
0
)
{
return
null
;
}
case
TOP_KEY_DOWN
:
case
TOP_KEY_UP
:
EventConstructor
=
SyntheticKeyboardEvent
;
break
;
case
TOP_BLUR
:
case
TOP_FOCUS
:
EventConstructor
=
SyntheticFocusEvent
;
break
;
case
TOP_CLICK
:
if
(
nativeEvent
.
button
=
=
=
2
)
{
return
null
;
}
case
TOP_AUX_CLICK
:
case
TOP_DOUBLE_CLICK
:
case
TOP_MOUSE_DOWN
:
case
TOP_MOUSE_MOVE
:
case
TOP_MOUSE_UP
:
case
TOP_MOUSE_OUT
:
case
TOP_MOUSE_OVER
:
case
TOP_CONTEXT_MENU
:
EventConstructor
=
SyntheticMouseEvent
;
break
;
case
TOP_DRAG
:
case
TOP_DRAG_END
:
case
TOP_DRAG_ENTER
:
case
TOP_DRAG_EXIT
:
case
TOP_DRAG_LEAVE
:
case
TOP_DRAG_OVER
:
case
TOP_DRAG_START
:
case
TOP_DROP
:
EventConstructor
=
SyntheticDragEvent
;
break
;
case
TOP_TOUCH_CANCEL
:
case
TOP_TOUCH_END
:
case
TOP_TOUCH_MOVE
:
case
TOP_TOUCH_START
:
EventConstructor
=
SyntheticTouchEvent
;
break
;
case
TOP_ANIMATION_END
:
case
TOP_ANIMATION_ITERATION
:
case
TOP_ANIMATION_START
:
EventConstructor
=
SyntheticAnimationEvent
;
break
;
case
TOP_TRANSITION_END
:
EventConstructor
=
SyntheticTransitionEvent
;
break
;
case
TOP_SCROLL
:
EventConstructor
=
SyntheticUIEvent
;
break
;
case
TOP_WHEEL
:
EventConstructor
=
SyntheticWheelEvent
;
break
;
case
TOP_COPY
:
case
TOP_CUT
:
case
TOP_PASTE
:
EventConstructor
=
SyntheticClipboardEvent
;
break
;
case
TOP_GOT_POINTER_CAPTURE
:
case
TOP_LOST_POINTER_CAPTURE
:
case
TOP_POINTER_CANCEL
:
case
TOP_POINTER_DOWN
:
case
TOP_POINTER_MOVE
:
case
TOP_POINTER_OUT
:
case
TOP_POINTER_OVER
:
case
TOP_POINTER_UP
:
EventConstructor
=
SyntheticPointerEvent
;
break
;
default
:
EventConstructor
=
SyntheticEvent
;
break
;
}
var
event
=
EventConstructor
.
getPooled
(
dispatchConfig
targetInst
nativeEvent
nativeEventTarget
)
;
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
}
;
var
isInteractiveTopLevelEventType
=
SimpleEventPlugin
.
isInteractiveTopLevelEventType
;
var
CALLBACK_BOOKKEEPING_POOL_SIZE
=
10
;
var
callbackBookkeepingPool
=
[
]
;
function
findRootContainerNode
(
inst
)
{
while
(
inst
.
return
)
{
inst
=
inst
.
return
;
}
if
(
inst
.
tag
!
=
=
HostRoot
)
{
return
null
;
}
return
inst
.
stateNode
.
containerInfo
;
}
function
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
)
{
if
(
callbackBookkeepingPool
.
length
)
{
var
instance
=
callbackBookkeepingPool
.
pop
(
)
;
instance
.
topLevelType
=
topLevelType
;
instance
.
nativeEvent
=
nativeEvent
;
instance
.
targetInst
=
targetInst
;
return
instance
;
}
return
{
topLevelType
:
topLevelType
nativeEvent
:
nativeEvent
targetInst
:
targetInst
ancestors
:
[
]
}
;
}
function
releaseTopLevelCallbackBookKeeping
(
instance
)
{
instance
.
topLevelType
=
null
;
instance
.
nativeEvent
=
null
;
instance
.
targetInst
=
null
;
instance
.
ancestors
.
length
=
0
;
if
(
callbackBookkeepingPool
.
length
<
CALLBACK_BOOKKEEPING_POOL_SIZE
)
{
callbackBookkeepingPool
.
push
(
instance
)
;
}
}
function
handleTopLevel
(
bookKeeping
)
{
var
targetInst
=
bookKeeping
.
targetInst
;
var
ancestor
=
targetInst
;
do
{
if
(
!
ancestor
)
{
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
break
;
}
var
root
=
findRootContainerNode
(
ancestor
)
;
if
(
!
root
)
{
break
;
}
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
ancestor
=
getClosestInstanceFromNode
(
root
)
;
}
while
(
ancestor
)
;
for
(
var
i
=
0
;
i
<
bookKeeping
.
ancestors
.
length
;
i
+
+
)
{
targetInst
=
bookKeeping
.
ancestors
[
i
]
;
runExtractedEventsInBatch
(
bookKeeping
.
topLevelType
targetInst
bookKeeping
.
nativeEvent
getEventTarget
(
bookKeeping
.
nativeEvent
)
)
;
}
}
var
_enabled
=
true
;
function
setEnabled
(
enabled
)
{
_enabled
=
!
!
enabled
;
}
function
isEnabled
(
)
{
return
_enabled
;
}
function
trapBubbledEvent
(
topLevelType
element
)
{
if
(
!
element
)
{
return
null
;
}
var
dispatch
=
isInteractiveTopLevelEventType
(
topLevelType
)
?
dispatchInteractiveEvent
:
dispatchEvent
;
addEventBubbleListener
(
element
getRawEventName
(
topLevelType
)
dispatch
.
bind
(
null
topLevelType
)
)
;
}
function
trapCapturedEvent
(
topLevelType
element
)
{
if
(
!
element
)
{
return
null
;
}
var
dispatch
=
isInteractiveTopLevelEventType
(
topLevelType
)
?
dispatchInteractiveEvent
:
dispatchEvent
;
addEventCaptureListener
(
element
getRawEventName
(
topLevelType
)
dispatch
.
bind
(
null
topLevelType
)
)
;
}
function
dispatchInteractiveEvent
(
topLevelType
nativeEvent
)
{
interactiveUpdates
(
dispatchEvent
topLevelType
nativeEvent
)
;
}
function
dispatchEvent
(
topLevelType
nativeEvent
)
{
if
(
!
_enabled
)
{
return
;
}
var
nativeEventTarget
=
getEventTarget
(
nativeEvent
)
;
var
targetInst
=
getClosestInstanceFromNode
(
nativeEventTarget
)
;
if
(
targetInst
!
=
=
null
&
&
typeof
targetInst
.
tag
=
=
=
'
number
'
&
&
!
isFiberMounted
(
targetInst
)
)
{
targetInst
=
null
;
}
var
bookKeeping
=
getTopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
targetInst
)
;
try
{
batchedUpdates
(
handleTopLevel
bookKeeping
)
;
}
finally
{
releaseTopLevelCallbackBookKeeping
(
bookKeeping
)
;
}
}
var
alreadyListeningTo
=
{
}
;
var
reactTopListenersCounter
=
0
;
var
topListenersIDKey
=
'
_reactListenersID
'
+
(
'
'
+
Math
.
random
(
)
)
.
slice
(
2
)
;
function
getListeningForDocument
(
mountAt
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
mountAt
topListenersIDKey
)
)
{
mountAt
[
topListenersIDKey
]
=
reactTopListenersCounter
+
+
;
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
=
{
}
;
}
return
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
;
}
function
listenTo
(
registrationName
mountAt
)
{
var
isListening
=
getListeningForDocument
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
(
isListening
.
hasOwnProperty
(
dependency
)
&
&
isListening
[
dependency
]
)
)
{
switch
(
dependency
)
{
case
TOP_SCROLL
:
trapCapturedEvent
(
TOP_SCROLL
mountAt
)
;
break
;
case
TOP_FOCUS
:
case
TOP_BLUR
:
trapCapturedEvent
(
TOP_FOCUS
mountAt
)
;
trapCapturedEvent
(
TOP_BLUR
mountAt
)
;
isListening
[
TOP_BLUR
]
=
true
;
isListening
[
TOP_FOCUS
]
=
true
;
break
;
case
TOP_CANCEL
:
case
TOP_CLOSE
:
if
(
isEventSupported
(
getRawEventName
(
dependency
)
)
)
{
trapCapturedEvent
(
dependency
mountAt
)
;
}
break
;
case
TOP_INVALID
:
case
TOP_SUBMIT
:
case
TOP_RESET
:
break
;
default
:
var
isMediaEvent
=
mediaEventTypes
.
indexOf
(
dependency
)
!
=
=
-
1
;
if
(
!
isMediaEvent
)
{
trapBubbledEvent
(
dependency
mountAt
)
;
}
break
;
}
isListening
[
dependency
]
=
true
;
}
}
}
function
isListeningToAllDependencies
(
registrationName
mountAt
)
{
var
isListening
=
getListeningForDocument
(
mountAt
)
;
var
dependencies
=
registrationNameDependencies
[
registrationName
]
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
(
isListening
.
hasOwnProperty
(
dependency
)
&
&
isListening
[
dependency
]
)
)
{
return
false
;
}
}
return
true
;
}
function
getActiveElement
(
doc
)
{
doc
=
doc
|
|
(
typeof
document
!
=
=
'
undefined
'
?
document
:
undefined
)
;
if
(
typeof
doc
=
=
=
'
undefined
'
)
{
return
null
;
}
try
{
return
doc
.
activeElement
|
|
doc
.
body
;
}
catch
(
e
)
{
return
doc
.
body
;
}
}
function
getLeafNode
(
node
)
{
while
(
node
&
&
node
.
firstChild
)
{
node
=
node
.
firstChild
;
}
return
node
;
}
function
getSiblingNode
(
node
)
{
while
(
node
)
{
if
(
node
.
nextSibling
)
{
return
node
.
nextSibling
;
}
node
=
node
.
parentNode
;
}
}
function
getNodeForCharacterOffset
(
root
offset
)
{
var
node
=
getLeafNode
(
root
)
;
var
nodeStart
=
0
;
var
nodeEnd
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
nodeEnd
=
nodeStart
+
node
.
textContent
.
length
;
if
(
nodeStart
<
=
offset
&
&
nodeEnd
>
=
offset
)
{
return
{
node
:
node
offset
:
offset
-
nodeStart
}
;
}
nodeStart
=
nodeEnd
;
}
node
=
getLeafNode
(
getSiblingNode
(
node
)
)
;
}
}
function
getOffsets
(
outerNode
)
{
var
ownerDocument
=
outerNode
.
ownerDocument
;
var
win
=
ownerDocument
&
&
ownerDocument
.
defaultView
|
|
window
;
var
selection
=
win
.
getSelection
&
&
win
.
getSelection
(
)
;
if
(
!
selection
|
|
selection
.
rangeCount
=
=
=
0
)
{
return
null
;
}
var
anchorNode
=
selection
.
anchorNode
anchorOffset
=
selection
.
anchorOffset
focusNode
=
selection
.
focusNode
focusOffset
=
selection
.
focusOffset
;
try
{
anchorNode
.
nodeType
;
focusNode
.
nodeType
;
}
catch
(
e
)
{
return
null
;
}
return
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
;
}
function
getModernOffsetsFromPoints
(
outerNode
anchorNode
anchorOffset
focusNode
focusOffset
)
{
var
length
=
0
;
var
start
=
-
1
;
var
end
=
-
1
;
var
indexWithinAnchor
=
0
;
var
indexWithinFocus
=
0
;
var
node
=
outerNode
;
var
parentNode
=
null
;
outer
:
while
(
true
)
{
var
next
=
null
;
while
(
true
)
{
if
(
node
=
=
=
anchorNode
&
&
(
anchorOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
start
=
length
+
anchorOffset
;
}
if
(
node
=
=
=
focusNode
&
&
(
focusOffset
=
=
=
0
|
|
node
.
nodeType
=
=
=
TEXT_NODE
)
)
{
end
=
length
+
focusOffset
;
}
if
(
node
.
nodeType
=
=
=
TEXT_NODE
)
{
length
+
=
node
.
nodeValue
.
length
;
}
if
(
(
next
=
node
.
firstChild
)
=
=
=
null
)
{
break
;
}
parentNode
=
node
;
node
=
next
;
}
while
(
true
)
{
if
(
node
=
=
=
outerNode
)
{
break
outer
;
}
if
(
parentNode
=
=
=
anchorNode
&
&
+
+
indexWithinAnchor
=
=
=
anchorOffset
)
{
start
=
length
;
}
if
(
parentNode
=
=
=
focusNode
&
&
+
+
indexWithinFocus
=
=
=
focusOffset
)
{
end
=
length
;
}
if
(
(
next
=
node
.
nextSibling
)
!
=
=
null
)
{
break
;
}
node
=
parentNode
;
parentNode
=
node
.
parentNode
;
}
node
=
next
;
}
if
(
start
=
=
=
-
1
|
|
end
=
=
=
-
1
)
{
return
null
;
}
return
{
start
:
start
end
:
end
}
;
}
function
setOffsets
(
node
offsets
)
{
var
doc
=
node
.
ownerDocument
|
|
document
;
var
win
=
doc
&
&
doc
.
defaultView
|
|
window
;
if
(
!
win
.
getSelection
)
{
return
;
}
var
selection
=
win
.
getSelection
(
)
;
var
length
=
node
.
textContent
.
length
;
var
start
=
Math
.
min
(
offsets
.
start
length
)
;
var
end
=
offsets
.
end
=
=
=
undefined
?
start
:
Math
.
min
(
offsets
.
end
length
)
;
if
(
!
selection
.
extend
&
&
start
>
end
)
{
var
temp
=
end
;
end
=
start
;
start
=
temp
;
}
var
startMarker
=
getNodeForCharacterOffset
(
node
start
)
;
var
endMarker
=
getNodeForCharacterOffset
(
node
end
)
;
if
(
startMarker
&
&
endMarker
)
{
if
(
selection
.
rangeCount
=
=
=
1
&
&
selection
.
anchorNode
=
=
=
startMarker
.
node
&
&
selection
.
anchorOffset
=
=
=
startMarker
.
offset
&
&
selection
.
focusNode
=
=
=
endMarker
.
node
&
&
selection
.
focusOffset
=
=
=
endMarker
.
offset
)
{
return
;
}
var
range
=
doc
.
createRange
(
)
;
range
.
setStart
(
startMarker
.
node
startMarker
.
offset
)
;
selection
.
removeAllRanges
(
)
;
if
(
start
>
end
)
{
selection
.
addRange
(
range
)
;
selection
.
extend
(
endMarker
.
node
endMarker
.
offset
)
;
}
else
{
range
.
setEnd
(
endMarker
.
node
endMarker
.
offset
)
;
selection
.
addRange
(
range
)
;
}
}
}
function
isTextNode
(
node
)
{
return
node
&
&
node
.
nodeType
=
=
=
TEXT_NODE
;
}
function
containsNode
(
outerNode
innerNode
)
{
if
(
!
outerNode
|
|
!
innerNode
)
{
return
false
;
}
else
if
(
outerNode
=
=
=
innerNode
)
{
return
true
;
}
else
if
(
isTextNode
(
outerNode
)
)
{
return
false
;
}
else
if
(
isTextNode
(
innerNode
)
)
{
return
containsNode
(
outerNode
innerNode
.
parentNode
)
;
}
else
if
(
'
contains
'
in
outerNode
)
{
return
outerNode
.
contains
(
innerNode
)
;
}
else
if
(
outerNode
.
compareDocumentPosition
)
{
return
!
!
(
outerNode
.
compareDocumentPosition
(
innerNode
)
&
16
)
;
}
else
{
return
false
;
}
}
function
isInDocument
(
node
)
{
return
node
&
&
node
.
ownerDocument
&
&
containsNode
(
node
.
ownerDocument
.
documentElement
node
)
;
}
function
isSameOriginFrame
(
iframe
)
{
try
{
return
typeof
iframe
.
contentWindow
.
location
.
href
=
=
=
'
string
'
;
}
catch
(
err
)
{
return
false
;
}
}
function
getActiveElementDeep
(
)
{
var
win
=
window
;
var
element
=
getActiveElement
(
)
;
while
(
element
instanceof
win
.
HTMLIFrameElement
)
{
if
(
isSameOriginFrame
(
element
)
)
{
win
=
element
.
contentWindow
;
}
else
{
return
element
;
}
element
=
getActiveElement
(
win
.
document
)
;
}
return
element
;
}
function
hasSelectionCapabilities
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
&
&
(
nodeName
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
text
'
|
|
elem
.
type
=
=
=
'
search
'
|
|
elem
.
type
=
=
=
'
tel
'
|
|
elem
.
type
=
=
=
'
url
'
|
|
elem
.
type
=
=
=
'
password
'
)
|
|
nodeName
=
=
=
'
textarea
'
|
|
elem
.
contentEditable
=
=
=
'
true
'
)
;
}
function
getSelectionInformation
(
)
{
var
focusedElem
=
getActiveElementDeep
(
)
;
return
{
focusedElem
:
focusedElem
selectionRange
:
hasSelectionCapabilities
(
focusedElem
)
?
getSelection
1
(
focusedElem
)
:
null
}
;
}
function
restoreSelection
(
priorSelectionInformation
)
{
var
curFocusedElem
=
getActiveElementDeep
(
)
;
var
priorFocusedElem
=
priorSelectionInformation
.
focusedElem
;
var
priorSelectionRange
=
priorSelectionInformation
.
selectionRange
;
if
(
curFocusedElem
!
=
=
priorFocusedElem
&
&
isInDocument
(
priorFocusedElem
)
)
{
if
(
priorSelectionRange
!
=
=
null
&
&
hasSelectionCapabilities
(
priorFocusedElem
)
)
{
setSelection
(
priorFocusedElem
priorSelectionRange
)
;
}
var
ancestors
=
[
]
;
var
ancestor
=
priorFocusedElem
;
while
(
ancestor
=
ancestor
.
parentNode
)
{
if
(
ancestor
.
nodeType
=
=
=
ELEMENT_NODE
)
{
ancestors
.
push
(
{
element
:
ancestor
left
:
ancestor
.
scrollLeft
top
:
ancestor
.
scrollTop
}
)
;
}
}
if
(
typeof
priorFocusedElem
.
focus
=
=
=
'
function
'
)
{
priorFocusedElem
.
focus
(
)
;
}
for
(
var
i
=
0
;
i
<
ancestors
.
length
;
i
+
+
)
{
var
info
=
ancestors
[
i
]
;
info
.
element
.
scrollLeft
=
info
.
left
;
info
.
element
.
scrollTop
=
info
.
top
;
}
}
}
function
getSelection
1
(
input
)
{
var
selection
=
void
0
;
if
(
'
selectionStart
'
in
input
)
{
selection
=
{
start
:
input
.
selectionStart
end
:
input
.
selectionEnd
}
;
}
else
{
selection
=
getOffsets
(
input
)
;
}
return
selection
|
|
{
start
:
0
end
:
0
}
;
}
function
setSelection
(
input
offsets
)
{
var
start
=
offsets
.
start
end
=
offsets
.
end
;
if
(
end
=
=
=
undefined
)
{
end
=
start
;
}
if
(
'
selectionStart
'
in
input
)
{
input
.
selectionStart
=
start
;
input
.
selectionEnd
=
Math
.
min
(
end
input
.
value
.
length
)
;
}
else
{
setOffsets
(
input
offsets
)
;
}
}
var
skipSelectionChangeEvent
=
canUseDOM
&
&
'
documentMode
'
in
document
&
&
document
.
documentMode
<
=
11
;
var
eventTypes
3
=
{
select
:
{
phasedRegistrationNames
:
{
bubbled
:
'
onSelect
'
captured
:
'
onSelectCapture
'
}
dependencies
:
[
TOP_BLUR
TOP_CONTEXT_MENU
TOP_DRAG_END
TOP_FOCUS
TOP_KEY_DOWN
TOP_KEY_UP
TOP_MOUSE_DOWN
TOP_MOUSE_UP
TOP_SELECTION_CHANGE
]
}
}
;
var
activeElement
1
=
null
;
var
activeElementInst
1
=
null
;
var
lastSelection
=
null
;
var
mouseDown
=
false
;
function
getSelection
(
node
)
{
if
(
'
selectionStart
'
in
node
&
&
hasSelectionCapabilities
(
node
)
)
{
return
{
start
:
node
.
selectionStart
end
:
node
.
selectionEnd
}
;
}
else
{
var
win
=
node
.
ownerDocument
&
&
node
.
ownerDocument
.
defaultView
|
|
window
;
var
selection
=
win
.
getSelection
(
)
;
return
{
anchorNode
:
selection
.
anchorNode
anchorOffset
:
selection
.
anchorOffset
focusNode
:
selection
.
focusNode
focusOffset
:
selection
.
focusOffset
}
;
}
}
function
getEventTargetDocument
(
eventTarget
)
{
return
eventTarget
.
window
=
=
=
eventTarget
?
eventTarget
.
document
:
eventTarget
.
nodeType
=
=
=
DOCUMENT_NODE
?
eventTarget
:
eventTarget
.
ownerDocument
;
}
function
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
{
var
doc
=
getEventTargetDocument
(
nativeEventTarget
)
;
if
(
mouseDown
|
|
activeElement
1
=
=
null
|
|
activeElement
1
!
=
=
getActiveElement
(
doc
)
)
{
return
null
;
}
var
currentSelection
=
getSelection
(
activeElement
1
)
;
if
(
!
lastSelection
|
|
!
shallowEqual
(
lastSelection
currentSelection
)
)
{
lastSelection
=
currentSelection
;
var
syntheticEvent
=
SyntheticEvent
.
getPooled
(
eventTypes
3
.
select
activeElementInst
1
nativeEvent
nativeEventTarget
)
;
syntheticEvent
.
type
=
'
select
'
;
syntheticEvent
.
target
=
activeElement
1
;
accumulateTwoPhaseDispatches
(
syntheticEvent
)
;
return
syntheticEvent
;
}
return
null
;
}
var
SelectEventPlugin
=
{
eventTypes
:
eventTypes
3
extractEvents
:
function
(
topLevelType
targetInst
nativeEvent
nativeEventTarget
)
{
var
doc
=
getEventTargetDocument
(
nativeEventTarget
)
;
if
(
!
doc
|
|
!
isListeningToAllDependencies
(
'
onSelect
'
doc
)
)
{
return
null
;
}
var
targetNode
=
targetInst
?
getNodeFromInstance
1
(
targetInst
)
:
window
;
switch
(
topLevelType
)
{
case
TOP_FOCUS
:
if
(
isTextInputElement
(
targetNode
)
|
|
targetNode
.
contentEditable
=
=
=
'
true
'
)
{
activeElement
1
=
targetNode
;
activeElementInst
1
=
targetInst
;
lastSelection
=
null
;
}
break
;
case
TOP_BLUR
:
activeElement
1
=
null
;
activeElementInst
1
=
null
;
lastSelection
=
null
;
break
;
case
TOP_MOUSE_DOWN
:
mouseDown
=
true
;
break
;
case
TOP_CONTEXT_MENU
:
case
TOP_MOUSE_UP
:
case
TOP_DRAG_END
:
mouseDown
=
false
;
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
case
TOP_SELECTION_CHANGE
:
if
(
skipSelectionChangeEvent
)
{
break
;
}
case
TOP_KEY_DOWN
:
case
TOP_KEY_UP
:
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
}
return
null
;
}
}
;
injection
.
injectEventPluginOrder
(
DOMEventPluginOrder
)
;
setComponentTree
(
getFiberCurrentPropsFromNode
1
getInstanceFromNode
1
getNodeFromInstance
1
)
;
injection
.
injectEventPluginsByName
(
{
SimpleEventPlugin
:
SimpleEventPlugin
EnterLeaveEventPlugin
:
EnterLeaveEventPlugin
ChangeEventPlugin
:
ChangeEventPlugin
SelectEventPlugin
:
SelectEventPlugin
BeforeInputEventPlugin
:
BeforeInputEventPlugin
}
)
;
function
flattenChildren
(
children
)
{
var
content
=
'
'
;
React
.
Children
.
forEach
(
children
function
(
child
)
{
if
(
child
=
=
null
)
{
return
;
}
content
+
=
child
;
}
)
;
return
content
;
}
function
postMountWrapper
1
(
element
props
)
{
if
(
props
.
value
!
=
null
)
{
element
.
setAttribute
(
'
value
'
toString
(
getToStringValue
(
props
.
value
)
)
)
;
}
}
function
getHostProps
1
(
element
props
)
{
var
hostProps
=
_assign
(
{
children
:
undefined
}
props
)
;
var
content
=
flattenChildren
(
props
.
children
)
;
if
(
content
)
{
hostProps
.
children
=
content
;
}
return
hostProps
;
}
function
updateOptions
(
node
multiple
propValue
setDefaultSelected
)
{
var
options
=
node
.
options
;
if
(
multiple
)
{
var
selectedValues
=
propValue
;
var
selectedValue
=
{
}
;
for
(
var
i
=
0
;
i
<
selectedValues
.
length
;
i
+
+
)
{
selectedValue
[
'
'
+
selectedValues
[
i
]
]
=
true
;
}
for
(
var
_i
=
0
;
_i
<
options
.
length
;
_i
+
+
)
{
var
selected
=
selectedValue
.
hasOwnProperty
(
'
'
+
options
[
_i
]
.
value
)
;
if
(
options
[
_i
]
.
selected
!
=
=
selected
)
{
options
[
_i
]
.
selected
=
selected
;
}
if
(
selected
&
&
setDefaultSelected
)
{
options
[
_i
]
.
defaultSelected
=
true
;
}
}
}
else
{
var
_selectedValue
=
toString
(
getToStringValue
(
propValue
)
)
;
var
defaultSelected
=
null
;
for
(
var
_i2
=
0
;
_i2
<
options
.
length
;
_i2
+
+
)
{
if
(
options
[
_i2
]
.
value
=
=
=
_selectedValue
)
{
options
[
_i2
]
.
selected
=
true
;
if
(
setDefaultSelected
)
{
options
[
_i2
]
.
defaultSelected
=
true
;
}
return
;
}
if
(
defaultSelected
=
=
=
null
&
&
!
options
[
_i2
]
.
disabled
)
{
defaultSelected
=
options
[
_i2
]
;
}
}
if
(
defaultSelected
!
=
=
null
)
{
defaultSelected
.
selected
=
true
;
}
}
}
function
getHostProps
2
(
element
props
)
{
return
_assign
(
{
}
props
{
value
:
undefined
}
)
;
}
function
initWrapperState
1
(
element
props
)
{
var
node
=
element
;
node
.
_wrapperState
=
{
wasMultiple
:
!
!
props
.
multiple
}
;
}
function
postMountWrapper
2
(
element
props
)
{
var
node
=
element
;
node
.
multiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
}
function
postUpdateWrapper
(
element
props
)
{
var
node
=
element
;
var
wasMultiple
=
node
.
_wrapperState
.
wasMultiple
;
node
.
_wrapperState
.
wasMultiple
=
!
!
props
.
multiple
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
else
if
(
wasMultiple
!
=
=
!
!
props
.
multiple
)
{
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
props
.
defaultValue
true
)
;
}
else
{
updateOptions
(
node
!
!
props
.
multiple
props
.
multiple
?
[
]
:
'
'
false
)
;
}
}
}
function
restoreControlledState
2
(
element
props
)
{
var
node
=
element
;
var
value
=
props
.
value
;
if
(
value
!
=
null
)
{
updateOptions
(
node
!
!
props
.
multiple
value
false
)
;
}
}
function
getHostProps
3
(
element
props
)
{
var
node
=
element
;
!
(
props
.
dangerouslySetInnerHTML
=
=
null
)
?
reactProdInvariant
(
'
91
'
)
:
void
0
;
var
hostProps
=
_assign
(
{
}
props
{
value
:
undefined
defaultValue
:
undefined
children
:
toString
(
node
.
_wrapperState
.
initialValue
)
}
)
;
return
hostProps
;
}
function
initWrapperState
2
(
element
props
)
{
var
node
=
element
;
var
initialValue
=
props
.
value
;
if
(
initialValue
=
=
null
)
{
var
defaultValue
=
props
.
defaultValue
;
var
children
=
props
.
children
;
if
(
children
!
=
null
)
{
!
(
defaultValue
=
=
null
)
?
reactProdInvariant
(
'
92
'
)
:
void
0
;
if
(
Array
.
isArray
(
children
)
)
{
!
(
children
.
length
<
=
1
)
?
reactProdInvariant
(
'
93
'
)
:
void
0
;
children
=
children
[
0
]
;
}
defaultValue
=
children
;
}
if
(
defaultValue
=
=
null
)
{
defaultValue
=
'
'
;
}
initialValue
=
defaultValue
;
}
node
.
_wrapperState
=
{
initialValue
:
getToStringValue
(
initialValue
)
}
;
}
function
updateWrapper
1
(
element
props
)
{
var
node
=
element
;
var
value
=
getToStringValue
(
props
.
value
)
;
var
defaultValue
=
getToStringValue
(
props
.
defaultValue
)
;
if
(
value
!
=
null
)
{
var
newValue
=
toString
(
value
)
;
if
(
newValue
!
=
=
node
.
value
)
{
node
.
value
=
newValue
;
}
if
(
props
.
defaultValue
=
=
null
&
&
node
.
defaultValue
!
=
=
newValue
)
{
node
.
defaultValue
=
newValue
;
}
}
if
(
defaultValue
!
=
null
)
{
node
.
defaultValue
=
toString
(
defaultValue
)
;
}
}
function
postMountWrapper
3
(
element
props
)
{
var
node
=
element
;
var
textContent
=
node
.
textContent
;
if
(
textContent
=
=
=
node
.
_wrapperState
.
initialValue
)
{
node
.
value
=
textContent
;
}
}
function
restoreControlledState
3
(
element
props
)
{
updateWrapper
1
(
element
props
)
;
}
var
HTML_NAMESPACE
1
=
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
;
var
MATH_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
'
;
var
SVG_NAMESPACE
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
var
Namespaces
=
{
html
:
HTML_NAMESPACE
1
mathml
:
MATH_NAMESPACE
svg
:
SVG_NAMESPACE
}
;
function
getIntrinsicNamespace
(
type
)
{
switch
(
type
)
{
case
'
svg
'
:
return
SVG_NAMESPACE
;
case
'
math
'
:
return
MATH_NAMESPACE
;
default
:
return
HTML_NAMESPACE
1
;
}
}
function
getChildNamespace
(
parentNamespace
type
)
{
if
(
parentNamespace
=
=
null
|
|
parentNamespace
=
=
=
HTML_NAMESPACE
1
)
{
return
getIntrinsicNamespace
(
type
)
;
}
if
(
parentNamespace
=
=
=
SVG_NAMESPACE
&
&
type
=
=
=
'
foreignObject
'
)
{
return
HTML_NAMESPACE
1
;
}
return
parentNamespace
;
}
var
createMicrosoftUnsafeLocalFunction
=
function
(
func
)
{
if
(
typeof
MSApp
!
=
=
'
undefined
'
&
&
MSApp
.
execUnsafeLocalFunction
)
{
return
function
(
arg0
arg1
arg2
arg3
)
{
MSApp
.
execUnsafeLocalFunction
(
function
(
)
{
return
func
(
arg0
arg1
arg2
arg3
)
;
}
)
;
}
;
}
else
{
return
func
;
}
}
;
var
reusableSVGContainer
=
void
0
;
var
setInnerHTML
=
createMicrosoftUnsafeLocalFunction
(
function
(
node
html
)
{
if
(
node
.
namespaceURI
=
=
=
Namespaces
.
svg
&
&
!
(
'
innerHTML
'
in
node
)
)
{
reusableSVGContainer
=
reusableSVGContainer
|
|
document
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
reusableSVGContainer
.
innerHTML
=
'
<
svg
>
'
+
html
+
'
<
/
svg
>
'
;
var
svgNode
=
reusableSVGContainer
.
firstChild
;
while
(
node
.
firstChild
)
{
node
.
removeChild
(
node
.
firstChild
)
;
}
while
(
svgNode
.
firstChild
)
{
node
.
appendChild
(
svgNode
.
firstChild
)
;
}
}
else
{
node
.
innerHTML
=
html
;
}
}
)
;
var
setTextContent
=
function
(
node
text
)
{
if
(
text
)
{
var
firstChild
=
node
.
firstChild
;
if
(
firstChild
&
&
firstChild
=
=
=
node
.
lastChild
&
&
firstChild
.
nodeType
=
=
=
TEXT_NODE
)
{
firstChild
.
nodeValue
=
text
;
return
;
}
}
node
.
textContent
=
text
;
}
;
var
isUnitlessNumber
=
{
animationIterationCount
:
true
borderImageOutset
:
true
borderImageSlice
:
true
borderImageWidth
:
true
boxFlex
:
true
boxFlexGroup
:
true
boxOrdinalGroup
:
true
columnCount
:
true
columns
:
true
flex
:
true
flexGrow
:
true
flexPositive
:
true
flexShrink
:
true
flexNegative
:
true
flexOrder
:
true
gridArea
:
true
gridRow
:
true
gridRowEnd
:
true
gridRowSpan
:
true
gridRowStart
:
true
gridColumn
:
true
gridColumnEnd
:
true
gridColumnSpan
:
true
gridColumnStart
:
true
fontWeight
:
true
lineClamp
:
true
lineHeight
:
true
opacity
:
true
order
:
true
orphans
:
true
tabSize
:
true
widows
:
true
zIndex
:
true
zoom
:
true
fillOpacity
:
true
floodOpacity
:
true
stopOpacity
:
true
strokeDasharray
:
true
strokeDashoffset
:
true
strokeMiterlimit
:
true
strokeOpacity
:
true
strokeWidth
:
true
}
;
function
prefixKey
(
prefix
key
)
{
return
prefix
+
key
.
charAt
(
0
)
.
toUpperCase
(
)
+
key
.
substring
(
1
)
;
}
var
prefixes
=
[
'
Webkit
'
'
ms
'
'
Moz
'
'
O
'
]
;
Object
.
keys
(
isUnitlessNumber
)
.
forEach
(
function
(
prop
)
{
prefixes
.
forEach
(
function
(
prefix
)
{
isUnitlessNumber
[
prefixKey
(
prefix
prop
)
]
=
isUnitlessNumber
[
prop
]
;
}
)
;
}
)
;
function
dangerousStyleValue
(
name
value
isCustomProperty
)
{
var
isEmpty
=
value
=
=
null
|
|
typeof
value
=
=
=
'
boolean
'
|
|
value
=
=
=
'
'
;
if
(
isEmpty
)
{
return
'
'
;
}
if
(
!
isCustomProperty
&
&
typeof
value
=
=
=
'
number
'
&
&
value
!
=
=
0
&
&
!
(
isUnitlessNumber
.
hasOwnProperty
(
name
)
&
&
isUnitlessNumber
[
name
]
)
)
{
return
value
+
'
px
'
;
}
return
(
'
'
+
value
)
.
trim
(
)
;
}
function
setValueForStyles
(
node
styles
)
{
var
style
=
node
.
style
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
isCustomProperty
=
styleName
.
indexOf
(
'
-
-
'
)
=
=
=
0
;
var
styleValue
=
dangerousStyleValue
(
styleName
styles
[
styleName
]
isCustomProperty
)
;
if
(
styleName
=
=
=
'
float
'
)
{
styleName
=
'
cssFloat
'
;
}
if
(
isCustomProperty
)
{
style
.
setProperty
(
styleName
styleValue
)
;
}
else
{
style
[
styleName
]
=
styleValue
;
}
}
}
var
omittedCloseTags
=
{
area
:
true
base
:
true
br
:
true
col
:
true
embed
:
true
hr
:
true
img
:
true
input
:
true
keygen
:
true
link
:
true
meta
:
true
param
:
true
source
:
true
track
:
true
wbr
:
true
}
;
var
voidElementTags
=
_assign
(
{
menuitem
:
true
}
omittedCloseTags
)
;
var
HTML
1
=
'
__html
'
;
function
assertValidProps
(
tag
props
)
{
if
(
!
props
)
{
return
;
}
if
(
voidElementTags
[
tag
]
)
{
!
(
props
.
children
=
=
null
&
&
props
.
dangerouslySetInnerHTML
=
=
null
)
?
reactProdInvariant
(
'
137
'
tag
'
'
)
:
void
0
;
}
if
(
props
.
dangerouslySetInnerHTML
!
=
null
)
{
!
(
props
.
children
=
=
null
)
?
reactProdInvariant
(
'
60
'
)
:
void
0
;
!
(
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
HTML
1
in
props
.
dangerouslySetInnerHTML
)
?
reactProdInvariant
(
'
61
'
)
:
void
0
;
}
!
(
props
.
style
=
=
null
|
|
typeof
props
.
style
=
=
=
'
object
'
)
?
reactProdInvariant
(
'
62
'
'
'
)
:
void
0
;
}
function
isCustomComponent
(
tagName
props
)
{
if
(
tagName
.
indexOf
(
'
-
'
)
=
=
=
-
1
)
{
return
typeof
props
.
is
=
=
=
'
string
'
;
}
switch
(
tagName
)
{
case
'
annotation
-
xml
'
:
case
'
color
-
profile
'
:
case
'
font
-
face
'
:
case
'
font
-
face
-
src
'
:
case
'
font
-
face
-
uri
'
:
case
'
font
-
face
-
format
'
:
case
'
font
-
face
-
name
'
:
case
'
missing
-
glyph
'
:
return
false
;
default
:
return
true
;
}
}
var
DANGEROUSLY_SET_INNER_HTML
=
'
dangerouslySetInnerHTML
'
;
var
SUPPRESS_CONTENT_EDITABLE_WARNING
=
'
suppressContentEditableWarning
'
;
var
SUPPRESS_HYDRATION_WARNING
1
=
'
suppressHydrationWarning
'
;
var
AUTOFOCUS
=
'
autoFocus
'
;
var
CHILDREN
=
'
children
'
;
var
STYLE
1
=
'
style
'
;
var
HTML
=
'
__html
'
;
var
HTML_NAMESPACE
=
Namespaces
.
html
;
function
ensureListeningTo
(
rootContainerElement
registrationName
)
{
var
isDocumentOrFragment
=
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
;
var
doc
=
isDocumentOrFragment
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
listenTo
(
registrationName
doc
)
;
}
function
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
{
return
rootContainerElement
.
nodeType
=
=
=
DOCUMENT_NODE
?
rootContainerElement
:
rootContainerElement
.
ownerDocument
;
}
function
noop
(
)
{
}
function
trapClickOnNonInteractiveElement
(
node
)
{
node
.
onclick
=
noop
;
}
function
setInitialDOMProperties
(
tag
domElement
rootContainerElement
nextProps
isCustomComponentTag
)
{
for
(
var
propKey
in
nextProps
)
{
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
nextProps
[
propKey
]
;
if
(
propKey
=
=
=
STYLE
1
)
{
setValueForStyles
(
domElement
nextProp
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
setInnerHTML
(
domElement
nextHtml
)
;
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
var
canSetTextContent
=
tag
!
=
=
'
textarea
'
|
|
nextProp
!
=
=
'
'
;
if
(
canSetTextContent
)
{
setTextContent
(
domElement
nextProp
)
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
setTextContent
(
domElement
'
'
+
nextProp
)
;
}
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
if
(
nextProp
!
=
null
)
{
setValueForProperty
(
domElement
propKey
nextProp
isCustomComponentTag
)
;
}
}
}
function
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
{
for
(
var
i
=
0
;
i
<
updatePayload
.
length
;
i
+
=
2
)
{
var
propKey
=
updatePayload
[
i
]
;
var
propValue
=
updatePayload
[
i
+
1
]
;
if
(
propKey
=
=
=
STYLE
1
)
{
setValueForStyles
(
domElement
propValue
)
;
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
setInnerHTML
(
domElement
propValue
)
;
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
setTextContent
(
domElement
propValue
)
;
}
else
{
setValueForProperty
(
domElement
propKey
propValue
isCustomComponentTag
)
;
}
}
}
function
createElement
(
type
props
rootContainerElement
parentNamespace
)
{
var
ownerDocument
=
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
;
var
domElement
=
void
0
;
var
namespaceURI
=
parentNamespace
;
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
namespaceURI
=
getIntrinsicNamespace
(
type
)
;
}
if
(
namespaceURI
=
=
=
HTML_NAMESPACE
)
{
if
(
type
=
=
=
'
script
'
)
{
var
div
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
'
div
'
)
;
div
.
innerHTML
=
'
<
script
>
<
'
+
'
/
script
>
'
;
var
firstChild
=
div
.
firstChild
;
domElement
=
div
.
removeChild
(
firstChild
)
;
}
else
if
(
typeof
props
.
is
=
=
=
'
string
'
)
{
domElement
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
type
{
is
:
props
.
is
}
)
;
}
else
{
domElement
=
ownerDocument
.
createElementNS
(
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
'
type
)
;
if
(
type
=
=
=
'
select
'
)
{
var
node
=
domElement
;
if
(
props
.
multiple
)
{
node
.
multiple
=
true
;
}
else
if
(
props
.
size
)
{
node
.
size
=
props
.
size
;
}
}
}
}
else
{
domElement
=
ownerDocument
.
createElementNS
(
namespaceURI
type
)
;
}
return
domElement
;
}
function
createTextNode
(
text
rootContainerElement
)
{
return
getOwnerDocumentFromRootContainer
(
rootContainerElement
)
.
createTextNode
(
text
)
;
}
function
setInitialProperties
(
domElement
tag
rawProps
rootContainerElement
)
{
var
isCustomComponentTag
=
isCustomComponent
(
tag
rawProps
)
;
var
props
=
void
0
;
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
props
=
rawProps
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
i
=
0
;
i
<
mediaEventTypes
.
length
;
i
+
+
)
{
trapBubbledEvent
(
mediaEventTypes
[
i
]
domElement
)
;
}
props
=
rawProps
;
break
;
case
'
source
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
props
=
rawProps
;
break
;
case
'
img
'
:
case
'
image
'
:
case
'
link
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
props
=
rawProps
;
break
;
case
'
form
'
:
trapBubbledEvent
(
TOP_RESET
domElement
)
;
trapBubbledEvent
(
TOP_SUBMIT
domElement
)
;
props
=
rawProps
;
break
;
case
'
details
'
:
trapBubbledEvent
(
TOP_TOGGLE
domElement
)
;
props
=
rawProps
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
props
=
getHostProps
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
props
=
getHostProps
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
props
=
getHostProps
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
props
=
getHostProps
3
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
default
:
props
=
rawProps
;
}
assertValidProps
(
tag
props
)
;
setInitialDOMProperties
(
tag
domElement
rootContainerElement
props
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
false
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
option
'
:
postMountWrapper
1
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
postMountWrapper
2
(
domElement
rawProps
)
;
break
;
default
:
if
(
typeof
props
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
}
function
diffProperties
(
domElement
tag
lastRawProps
nextRawProps
rootContainerElement
)
{
var
updatePayload
=
null
;
var
lastProps
=
void
0
;
var
nextProps
=
void
0
;
switch
(
tag
)
{
case
'
input
'
:
lastProps
=
getHostProps
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
option
'
:
lastProps
=
getHostProps
1
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
1
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
select
'
:
lastProps
=
getHostProps
2
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
2
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
case
'
textarea
'
:
lastProps
=
getHostProps
3
(
domElement
lastRawProps
)
;
nextProps
=
getHostProps
3
(
domElement
nextRawProps
)
;
updatePayload
=
[
]
;
break
;
default
:
lastProps
=
lastRawProps
;
nextProps
=
nextRawProps
;
if
(
typeof
lastProps
.
onClick
!
=
=
'
function
'
&
&
typeof
nextProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
assertValidProps
(
tag
nextProps
)
;
var
propKey
=
void
0
;
var
styleName
=
void
0
;
var
styleUpdates
=
null
;
for
(
propKey
in
lastProps
)
{
if
(
nextProps
.
hasOwnProperty
(
propKey
)
|
|
!
lastProps
.
hasOwnProperty
(
propKey
)
|
|
lastProps
[
propKey
]
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
1
)
{
var
lastStyle
=
lastProps
[
propKey
]
;
for
(
styleName
in
lastStyle
)
{
if
(
lastStyle
.
hasOwnProperty
(
styleName
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
|
|
propKey
=
=
=
CHILDREN
)
{
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
propKey
=
=
=
AUTOFOCUS
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
null
)
;
}
}
for
(
propKey
in
nextProps
)
{
var
nextProp
=
nextProps
[
propKey
]
;
var
lastProp
=
lastProps
!
=
null
?
lastProps
[
propKey
]
:
undefined
;
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
|
|
nextProp
=
=
=
lastProp
|
|
nextProp
=
=
null
&
&
lastProp
=
=
null
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
1
)
{
if
(
lastProp
)
{
for
(
styleName
in
lastProp
)
{
if
(
lastProp
.
hasOwnProperty
(
styleName
)
&
&
(
!
nextProp
|
|
!
nextProp
.
hasOwnProperty
(
styleName
)
)
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
'
'
;
}
}
for
(
styleName
in
nextProp
)
{
if
(
nextProp
.
hasOwnProperty
(
styleName
)
&
&
lastProp
[
styleName
]
!
=
=
nextProp
[
styleName
]
)
{
if
(
!
styleUpdates
)
{
styleUpdates
=
{
}
;
}
styleUpdates
[
styleName
]
=
nextProp
[
styleName
]
;
}
}
}
else
{
if
(
!
styleUpdates
)
{
if
(
!
updatePayload
)
{
updatePayload
=
[
]
;
}
updatePayload
.
push
(
propKey
styleUpdates
)
;
}
styleUpdates
=
nextProp
;
}
}
else
if
(
propKey
=
=
=
DANGEROUSLY_SET_INNER_HTML
)
{
var
nextHtml
=
nextProp
?
nextProp
[
HTML
]
:
undefined
;
var
lastHtml
=
lastProp
?
lastProp
[
HTML
]
:
undefined
;
if
(
nextHtml
!
=
null
)
{
if
(
lastHtml
!
=
=
nextHtml
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
'
'
+
nextHtml
)
;
}
}
else
{
}
}
else
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
lastProp
!
=
=
nextProp
&
&
(
typeof
nextProp
=
=
=
'
string
'
|
|
typeof
nextProp
=
=
=
'
number
'
)
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
'
'
+
nextProp
)
;
}
}
else
if
(
propKey
=
=
=
SUPPRESS_CONTENT_EDITABLE_WARNING
|
|
propKey
=
=
=
SUPPRESS_HYDRATION_WARNING
1
)
{
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
if
(
!
updatePayload
&
&
lastProp
!
=
=
nextProp
)
{
updatePayload
=
[
]
;
}
}
else
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
propKey
nextProp
)
;
}
}
if
(
styleUpdates
)
{
(
updatePayload
=
updatePayload
|
|
[
]
)
.
push
(
STYLE
1
styleUpdates
)
;
}
return
updatePayload
;
}
function
updateProperties
(
domElement
updatePayload
tag
lastRawProps
nextRawProps
)
{
if
(
tag
=
=
=
'
input
'
&
&
nextRawProps
.
type
=
=
=
'
radio
'
&
&
nextRawProps
.
name
!
=
null
)
{
updateChecked
(
domElement
nextRawProps
)
;
}
var
wasCustomComponentTag
=
isCustomComponent
(
tag
lastRawProps
)
;
var
isCustomComponentTag
=
isCustomComponent
(
tag
nextRawProps
)
;
updateDOMProperties
(
domElement
updatePayload
wasCustomComponentTag
isCustomComponentTag
)
;
switch
(
tag
)
{
case
'
input
'
:
updateWrapper
(
domElement
nextRawProps
)
;
break
;
case
'
textarea
'
:
updateWrapper
1
(
domElement
nextRawProps
)
;
break
;
case
'
select
'
:
postUpdateWrapper
(
domElement
nextRawProps
)
;
break
;
}
}
function
diffHydratedProperties
(
domElement
tag
rawProps
parentNamespace
rootContainerElement
)
{
var
isCustomComponentTag
=
void
0
;
switch
(
tag
)
{
case
'
iframe
'
:
case
'
object
'
:
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
break
;
case
'
video
'
:
case
'
audio
'
:
for
(
var
i
=
0
;
i
<
mediaEventTypes
.
length
;
i
+
+
)
{
trapBubbledEvent
(
mediaEventTypes
[
i
]
domElement
)
;
}
break
;
case
'
source
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
break
;
case
'
img
'
:
case
'
image
'
:
case
'
link
'
:
trapBubbledEvent
(
TOP_ERROR
domElement
)
;
trapBubbledEvent
(
TOP_LOAD
domElement
)
;
break
;
case
'
form
'
:
trapBubbledEvent
(
TOP_RESET
domElement
)
;
trapBubbledEvent
(
TOP_SUBMIT
domElement
)
;
break
;
case
'
details
'
:
trapBubbledEvent
(
TOP_TOGGLE
domElement
)
;
break
;
case
'
input
'
:
initWrapperState
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
option
'
:
break
;
case
'
select
'
:
initWrapperState
1
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
case
'
textarea
'
:
initWrapperState
2
(
domElement
rawProps
)
;
trapBubbledEvent
(
TOP_INVALID
domElement
)
;
ensureListeningTo
(
rootContainerElement
'
onChange
'
)
;
break
;
}
assertValidProps
(
tag
rawProps
)
;
var
updatePayload
=
null
;
for
(
var
propKey
in
rawProps
)
{
if
(
!
rawProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
nextProp
=
rawProps
[
propKey
]
;
if
(
propKey
=
=
=
CHILDREN
)
{
if
(
typeof
nextProp
=
=
=
'
string
'
)
{
if
(
domElement
.
textContent
!
=
=
nextProp
)
{
updatePayload
=
[
CHILDREN
nextProp
]
;
}
}
else
if
(
typeof
nextProp
=
=
=
'
number
'
)
{
if
(
domElement
.
textContent
!
=
=
'
'
+
nextProp
)
{
updatePayload
=
[
CHILDREN
'
'
+
nextProp
]
;
}
}
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
!
=
null
)
{
ensureListeningTo
(
rootContainerElement
propKey
)
;
}
}
else
{
}
}
switch
(
tag
)
{
case
'
input
'
:
track
(
domElement
)
;
postMountWrapper
(
domElement
rawProps
true
)
;
break
;
case
'
textarea
'
:
track
(
domElement
)
;
postMountWrapper
3
(
domElement
rawProps
)
;
break
;
case
'
select
'
:
case
'
option
'
:
break
;
default
:
if
(
typeof
rawProps
.
onClick
=
=
=
'
function
'
)
{
trapClickOnNonInteractiveElement
(
domElement
)
;
}
break
;
}
return
updatePayload
;
}
function
diffHydratedText
(
textNode
text
)
{
var
isDifferent
=
textNode
.
nodeValue
!
=
=
text
;
return
isDifferent
;
}
function
restoreControlledState
1
(
domElement
tag
props
)
{
switch
(
tag
)
{
case
'
input
'
:
restoreControlledState
(
domElement
props
)
;
return
;
case
'
textarea
'
:
restoreControlledState
3
(
domElement
props
)
;
return
;
case
'
select
'
:
restoreControlledState
2
(
domElement
props
)
;
return
;
}
}
var
ReactInternals
1
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_ReactInternals
Sched
=
ReactInternals
1
.
Scheduler
;
var
unstable_cancelCallback
=
_ReactInternals
Sched
.
unstable_cancelCallback
;
var
unstable_now
=
_ReactInternals
Sched
.
unstable_now
;
var
unstable_scheduleCallback
=
_ReactInternals
Sched
.
unstable_scheduleCallback
;
var
unstable_shouldYield
=
_ReactInternals
Sched
.
unstable_shouldYield
;
var
unstable_getFirstCallbackNode
=
_ReactInternals
Sched
.
unstable_getFirstCallbackNode
;
var
unstable_runWithPriority
=
_ReactInternals
Sched
.
unstable_runWithPriority
;
var
unstable_next
=
_ReactInternals
Sched
.
unstable_next
;
var
unstable_continueExecution
=
_ReactInternals
Sched
.
unstable_continueExecution
;
var
unstable_pauseExecution
=
_ReactInternals
Sched
.
unstable_pauseExecution
;
var
unstable_getCurrentPriorityLevel
=
_ReactInternals
Sched
.
unstable_getCurrentPriorityLevel
;
var
unstable_ImmediatePriority
=
_ReactInternals
Sched
.
unstable_ImmediatePriority
;
var
unstable_UserBlockingPriority
=
_ReactInternals
Sched
.
unstable_UserBlockingPriority
;
var
unstable_NormalPriority
=
_ReactInternals
Sched
.
unstable_NormalPriority
;
var
unstable_LowPriority
=
_ReactInternals
Sched
.
unstable_LowPriority
;
var
unstable_IdlePriority
=
_ReactInternals
Sched
.
unstable_IdlePriority
;
function
shim
(
)
{
reactProdInvariant
(
'
270
'
)
;
}
var
supportsPersistence
=
false
;
var
cloneInstance
=
shim
;
var
createContainerChildSet
=
shim
;
var
appendChildToContainerChildSet
=
shim
;
var
finalizeContainerChildren
=
shim
;
var
replaceContainerChildren
=
shim
;
var
cloneHiddenInstance
=
shim
;
var
cloneUnhiddenInstance
=
shim
;
var
createHiddenTextInstance
=
shim
;
var
SUSPENSE_START_DATA
=
'
'
;
var
SUSPENSE_END_DATA
=
'
/
'
;
var
STYLE
=
'
style
'
;
var
eventsEnabled
=
null
;
var
selectionInformation
=
null
;
function
shouldAutoFocusHostComponent
(
type
props
)
{
switch
(
type
)
{
case
'
button
'
:
case
'
input
'
:
case
'
select
'
:
case
'
textarea
'
:
return
!
!
props
.
autoFocus
;
}
return
false
;
}
function
getRootHostContext
(
rootContainerInstance
)
{
var
type
=
void
0
;
var
namespace
=
void
0
;
var
nodeType
=
rootContainerInstance
.
nodeType
;
switch
(
nodeType
)
{
case
DOCUMENT_NODE
:
case
DOCUMENT_FRAGMENT_NODE
:
{
type
=
nodeType
=
=
=
DOCUMENT_NODE
?
'
#
document
'
:
'
#
fragment
'
;
var
root
=
rootContainerInstance
.
documentElement
;
namespace
=
root
?
root
.
namespaceURI
:
getChildNamespace
(
null
'
'
)
;
break
;
}
default
:
{
var
container
=
nodeType
=
=
=
COMMENT_NODE
?
rootContainerInstance
.
parentNode
:
rootContainerInstance
;
var
ownNamespace
=
container
.
namespaceURI
|
|
null
;
type
=
container
.
tagName
;
namespace
=
getChildNamespace
(
ownNamespace
type
)
;
break
;
}
}
return
namespace
;
}
function
getChildHostContext
(
parentHostContext
type
rootContainerInstance
)
{
var
parentNamespace
=
parentHostContext
;
return
getChildNamespace
(
parentNamespace
type
)
;
}
function
getPublicInstance
(
instance
)
{
return
instance
;
}
function
prepareForCommit
(
containerInfo
)
{
eventsEnabled
=
isEnabled
(
)
;
selectionInformation
=
getSelectionInformation
(
)
;
setEnabled
(
false
)
;
}
function
resetAfterCommit
(
containerInfo
)
{
restoreSelection
(
selectionInformation
)
;
selectionInformation
=
null
;
setEnabled
(
eventsEnabled
)
;
eventsEnabled
=
null
;
}
function
createInstance
(
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
var
parentNamespace
=
void
0
;
{
parentNamespace
=
hostContext
;
}
var
domElement
=
createElement
(
type
props
rootContainerInstance
parentNamespace
)
;
precacheFiberNode
(
internalInstanceHandle
domElement
)
;
updateFiberProps
(
domElement
props
)
;
return
domElement
;
}
function
appendInitialChild
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
function
finalizeInitialChildren
(
domElement
type
props
rootContainerInstance
hostContext
)
{
setInitialProperties
(
domElement
type
props
rootContainerInstance
)
;
return
shouldAutoFocusHostComponent
(
type
props
)
;
}
function
prepareUpdate
(
domElement
type
oldProps
newProps
rootContainerInstance
hostContext
)
{
return
diffProperties
(
domElement
type
oldProps
newProps
rootContainerInstance
)
;
}
function
shouldSetTextContent
(
type
props
)
{
return
type
=
=
=
'
textarea
'
|
|
type
=
=
=
'
option
'
|
|
type
=
=
=
'
noscript
'
|
|
typeof
props
.
children
=
=
=
'
string
'
|
|
typeof
props
.
children
=
=
=
'
number
'
|
|
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
props
.
dangerouslySetInnerHTML
!
=
=
null
&
&
props
.
dangerouslySetInnerHTML
.
__html
!
=
null
;
}
function
shouldDeprioritizeSubtree
(
type
props
)
{
return
!
!
props
.
hidden
;
}
function
createTextInstance
(
text
rootContainerInstance
hostContext
internalInstanceHandle
)
{
var
textNode
=
createTextNode
(
text
rootContainerInstance
)
;
precacheFiberNode
(
internalInstanceHandle
textNode
)
;
return
textNode
;
}
var
isPrimaryRenderer
=
true
;
var
scheduleTimeout
=
typeof
setTimeout
=
=
=
'
function
'
?
setTimeout
:
undefined
;
var
cancelTimeout
=
typeof
clearTimeout
=
=
=
'
function
'
?
clearTimeout
:
undefined
;
var
noTimeout
=
-
1
;
var
schedulePassiveEffects
=
unstable_scheduleCallback
;
var
cancelPassiveEffects
=
unstable_cancelCallback
;
var
supportsMutation
=
true
;
function
commitMount
(
domElement
type
newProps
internalInstanceHandle
)
{
if
(
shouldAutoFocusHostComponent
(
type
newProps
)
)
{
domElement
.
focus
(
)
;
}
}
function
commitUpdate
(
domElement
updatePayload
type
oldProps
newProps
internalInstanceHandle
)
{
updateFiberProps
(
domElement
newProps
)
;
updateProperties
(
domElement
updatePayload
type
oldProps
newProps
)
;
}
function
resetTextContent
(
domElement
)
{
setTextContent
(
domElement
'
'
)
;
}
function
commitTextUpdate
(
textInstance
oldText
newText
)
{
textInstance
.
nodeValue
=
newText
;
}
function
appendChild
(
parentInstance
child
)
{
parentInstance
.
appendChild
(
child
)
;
}
function
appendChildToContainer
(
container
child
)
{
var
parentNode
=
void
0
;
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
parentNode
=
container
.
parentNode
;
parentNode
.
insertBefore
(
child
container
)
;
}
else
{
parentNode
=
container
;
parentNode
.
appendChild
(
child
)
;
}
var
reactRootContainer
=
container
.
_reactRootContainer
;
if
(
(
reactRootContainer
=
=
=
null
|
|
reactRootContainer
=
=
=
undefined
)
&
&
parentNode
.
onclick
=
=
=
null
)
{
trapClickOnNonInteractiveElement
(
parentNode
)
;
}
}
function
insertBefore
(
parentInstance
child
beforeChild
)
{
parentInstance
.
insertBefore
(
child
beforeChild
)
;
}
function
insertInContainerBefore
(
container
child
beforeChild
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
insertBefore
(
child
beforeChild
)
;
}
else
{
container
.
insertBefore
(
child
beforeChild
)
;
}
}
function
removeChild
(
parentInstance
child
)
{
parentInstance
.
removeChild
(
child
)
;
}
function
removeChildFromContainer
(
container
child
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
container
.
parentNode
.
removeChild
(
child
)
;
}
else
{
container
.
removeChild
(
child
)
;
}
}
function
clearSuspenseBoundary
(
parentInstance
suspenseInstance
)
{
var
node
=
suspenseInstance
;
var
depth
=
0
;
do
{
var
nextNode
=
node
.
nextSibling
;
parentInstance
.
removeChild
(
node
)
;
if
(
nextNode
&
&
nextNode
.
nodeType
=
=
=
COMMENT_NODE
)
{
var
data
=
nextNode
.
data
;
if
(
data
=
=
=
SUSPENSE_END_DATA
)
{
if
(
depth
=
=
=
0
)
{
parentInstance
.
removeChild
(
nextNode
)
;
return
;
}
else
{
depth
-
-
;
}
}
else
if
(
data
=
=
=
SUSPENSE_START_DATA
)
{
depth
+
+
;
}
}
node
=
nextNode
;
}
while
(
node
)
;
}
function
clearSuspenseBoundaryFromContainer
(
container
suspenseInstance
)
{
if
(
container
.
nodeType
=
=
=
COMMENT_NODE
)
{
clearSuspenseBoundary
(
container
.
parentNode
suspenseInstance
)
;
}
else
if
(
container
.
nodeType
=
=
=
ELEMENT_NODE
)
{
clearSuspenseBoundary
(
container
suspenseInstance
)
;
}
else
{
}
}
function
hideInstance
(
instance
)
{
instance
=
instance
;
instance
.
style
.
display
=
'
none
'
;
}
function
hideTextInstance
(
textInstance
)
{
textInstance
.
nodeValue
=
'
'
;
}
function
unhideInstance
(
instance
props
)
{
instance
=
instance
;
var
styleProp
=
props
[
STYLE
]
;
var
display
=
styleProp
!
=
=
undefined
&
&
styleProp
!
=
=
null
&
&
styleProp
.
hasOwnProperty
(
'
display
'
)
?
styleProp
.
display
:
null
;
instance
.
style
.
display
=
dangerousStyleValue
(
'
display
'
display
)
;
}
function
unhideTextInstance
(
textInstance
text
)
{
textInstance
.
nodeValue
=
text
;
}
var
supportsHydration
=
true
;
function
canHydrateInstance
(
instance
type
props
)
{
if
(
instance
.
nodeType
!
=
=
ELEMENT_NODE
|
|
type
.
toLowerCase
(
)
!
=
=
instance
.
nodeName
.
toLowerCase
(
)
)
{
return
null
;
}
return
instance
;
}
function
canHydrateTextInstance
(
instance
text
)
{
if
(
text
=
=
=
'
'
|
|
instance
.
nodeType
!
=
=
TEXT_NODE
)
{
return
null
;
}
return
instance
;
}
function
canHydrateSuspenseInstance
(
instance
)
{
if
(
instance
.
nodeType
!
=
=
COMMENT_NODE
)
{
return
null
;
}
return
instance
;
}
function
getNextHydratableSibling
(
instance
)
{
var
node
=
instance
.
nextSibling
;
while
(
node
&
&
node
.
nodeType
!
=
=
ELEMENT_NODE
&
&
node
.
nodeType
!
=
=
TEXT_NODE
&
&
(
!
enableSuspenseServerRenderer
|
|
node
.
nodeType
!
=
=
COMMENT_NODE
|
|
node
.
data
!
=
=
SUSPENSE_START_DATA
)
)
{
node
=
node
.
nextSibling
;
}
return
node
;
}
function
getFirstHydratableChild
(
parentInstance
)
{
var
next
=
parentInstance
.
firstChild
;
while
(
next
&
&
next
.
nodeType
!
=
=
ELEMENT_NODE
&
&
next
.
nodeType
!
=
=
TEXT_NODE
&
&
(
!
enableSuspenseServerRenderer
|
|
next
.
nodeType
!
=
=
COMMENT_NODE
|
|
next
.
data
!
=
=
SUSPENSE_START_DATA
)
)
{
next
=
next
.
nextSibling
;
}
return
next
;
}
function
hydrateInstance
(
instance
type
props
rootContainerInstance
hostContext
internalInstanceHandle
)
{
precacheFiberNode
(
internalInstanceHandle
instance
)
;
updateFiberProps
(
instance
props
)
;
var
parentNamespace
=
void
0
;
{
parentNamespace
=
hostContext
;
}
return
diffHydratedProperties
(
instance
type
props
parentNamespace
rootContainerInstance
)
;
}
function
hydrateTextInstance
(
textInstance
text
internalInstanceHandle
)
{
precacheFiberNode
(
internalInstanceHandle
textInstance
)
;
return
diffHydratedText
(
textInstance
text
)
;
}
function
getNextHydratableInstanceAfterSuspenseInstance
(
suspenseInstance
)
{
var
node
=
suspenseInstance
.
nextSibling
;
var
depth
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
COMMENT_NODE
)
{
var
data
=
node
.
data
;
if
(
data
=
=
=
SUSPENSE_END_DATA
)
{
if
(
depth
=
=
=
0
)
{
return
getNextHydratableSibling
(
node
)
;
}
else
{
depth
-
-
;
}
}
else
if
(
data
=
=
=
SUSPENSE_START_DATA
)
{
depth
+
+
;
}
}
node
=
node
.
nextSibling
;
}
return
null
;
}
var
reactEmoji
=
'
\
u269B
'
;
var
warningEmoji
=
'
\
u26D4
'
;
var
supportsUserTiming
=
typeof
performance
!
=
=
'
undefined
'
&
&
typeof
performance
.
mark
=
=
=
'
function
'
&
&
typeof
performance
.
clearMarks
=
=
=
'
function
'
&
&
typeof
performance
.
measure
=
=
=
'
function
'
&
&
typeof
performance
.
clearMeasures
=
=
=
'
function
'
;
var
currentFiber
=
null
;
var
currentPhase
=
null
;
var
currentPhaseFiber
=
null
;
var
isCommitting
=
false
;
var
hasScheduledUpdateInCurrentCommit
=
false
;
var
hasScheduledUpdateInCurrentPhase
=
false
;
var
commitCountInCurrentWorkLoop
=
0
;
var
effectCountInCurrentCommit
=
0
;
var
isWaitingForCallback
=
false
;
var
labelsInCurrentCommit
=
new
Set
(
)
;
var
formatMarkName
=
function
(
markName
)
{
return
reactEmoji
+
'
'
+
markName
;
}
;
var
formatLabel
=
function
(
label
warning
)
{
var
prefix
=
warning
?
warningEmoji
+
'
'
:
reactEmoji
+
'
'
;
var
suffix
=
warning
?
'
Warning
:
'
+
warning
:
'
'
;
return
'
'
+
prefix
+
label
+
suffix
;
}
;
var
beginMark
=
function
(
markName
)
{
performance
.
mark
(
formatMarkName
(
markName
)
)
;
}
;
var
clearMark
=
function
(
markName
)
{
performance
.
clearMarks
(
formatMarkName
(
markName
)
)
;
}
;
var
endMark
=
function
(
label
markName
warning
)
{
var
formattedMarkName
=
formatMarkName
(
markName
)
;
var
formattedLabel
=
formatLabel
(
label
warning
)
;
try
{
performance
.
measure
(
formattedLabel
formattedMarkName
)
;
}
catch
(
err
)
{
}
performance
.
clearMarks
(
formattedMarkName
)
;
performance
.
clearMeasures
(
formattedLabel
)
;
}
;
var
getFiberMarkName
=
function
(
label
debugID
)
{
return
label
+
'
(
#
'
+
debugID
+
'
)
'
;
}
;
var
getFiberLabel
=
function
(
componentName
isMounted
phase
)
{
if
(
phase
=
=
=
null
)
{
return
componentName
+
'
[
'
+
(
isMounted
?
'
update
'
:
'
mount
'
)
+
'
]
'
;
}
else
{
return
componentName
+
'
.
'
+
phase
;
}
}
;
var
beginFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
if
(
isCommitting
&
&
labelsInCurrentCommit
.
has
(
label
)
)
{
return
false
;
}
labelsInCurrentCommit
.
add
(
label
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
beginMark
(
markName
)
;
return
true
;
}
;
var
clearFiberMark
=
function
(
fiber
phase
)
{
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
clearMark
(
markName
)
;
}
;
var
endFiberMark
=
function
(
fiber
phase
warning
)
{
var
componentName
=
getComponentName
(
fiber
.
type
)
|
|
'
Unknown
'
;
var
debugID
=
fiber
.
_debugID
;
var
isMounted
=
fiber
.
alternate
!
=
=
null
;
var
label
=
getFiberLabel
(
componentName
isMounted
phase
)
;
var
markName
=
getFiberMarkName
(
label
debugID
)
;
endMark
(
label
markName
warning
)
;
}
;
var
shouldIgnoreFiber
=
function
(
fiber
)
{
switch
(
fiber
.
tag
)
{
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
case
Fragment
:
case
ContextProvider
:
case
ContextConsumer
:
case
Mode
:
return
true
;
default
:
return
false
;
}
}
;
var
clearPendingPhaseMeasurement
=
function
(
)
{
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
clearFiberMark
(
currentPhaseFiber
currentPhase
)
;
}
currentPhaseFiber
=
null
;
currentPhase
=
null
;
hasScheduledUpdateInCurrentPhase
=
false
;
}
;
var
pauseTimers
=
function
(
)
{
var
fiber
=
currentFiber
;
while
(
fiber
)
{
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
endFiberMark
(
fiber
null
null
)
;
}
fiber
=
fiber
.
return
;
}
}
;
var
resumeTimersRecursively
=
function
(
fiber
)
{
if
(
fiber
.
return
!
=
=
null
)
{
resumeTimersRecursively
(
fiber
.
return
)
;
}
if
(
fiber
.
_debugIsCurrentlyTiming
)
{
beginFiberMark
(
fiber
null
)
;
}
}
;
var
resumeTimers
=
function
(
)
{
if
(
currentFiber
!
=
=
null
)
{
resumeTimersRecursively
(
currentFiber
)
;
}
}
;
function
recordEffect
(
)
{
if
(
enableUserTimingAPI
)
{
effectCountInCurrentCommit
+
+
;
}
}
function
recordScheduleUpdate
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
isCommitting
)
{
hasScheduledUpdateInCurrentCommit
=
true
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhase
!
=
=
'
componentWillMount
'
&
&
currentPhase
!
=
=
'
componentWillReceiveProps
'
)
{
hasScheduledUpdateInCurrentPhase
=
true
;
}
}
}
function
startRequestCallbackTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
&
&
!
isWaitingForCallback
)
{
isWaitingForCallback
=
true
;
beginMark
(
'
(
Waiting
for
async
callback
.
.
.
)
'
)
;
}
}
}
function
stopRequestCallbackTimer
(
didExpire
expirationTime
)
{
if
(
enableUserTimingAPI
)
{
if
(
supportsUserTiming
)
{
isWaitingForCallback
=
false
;
var
warning
=
didExpire
?
'
React
was
blocked
by
main
thread
'
:
null
;
endMark
(
'
(
Waiting
for
async
callback
.
.
.
will
force
flush
in
'
+
expirationTime
+
'
ms
)
'
'
(
Waiting
for
async
callback
.
.
.
)
'
warning
)
;
}
}
}
function
startWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
;
if
(
!
beginFiberMark
(
fiber
null
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
true
;
}
}
function
cancelWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
clearFiberMark
(
fiber
null
)
;
}
}
function
stopWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
endFiberMark
(
fiber
null
null
)
;
}
}
function
stopFailedWorkTimer
(
fiber
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
|
|
shouldIgnoreFiber
(
fiber
)
)
{
return
;
}
currentFiber
=
fiber
.
return
;
if
(
!
fiber
.
_debugIsCurrentlyTiming
)
{
return
;
}
fiber
.
_debugIsCurrentlyTiming
=
false
;
var
warning
=
fiber
.
tag
=
=
=
SuspenseComponent
|
|
fiber
.
tag
=
=
=
DehydratedSuspenseComponent
?
'
Rendering
was
suspended
'
:
'
An
error
was
thrown
inside
this
error
boundary
'
;
endFiberMark
(
fiber
null
warning
)
;
}
}
function
startPhaseTimer
(
fiber
phase
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
clearPendingPhaseMeasurement
(
)
;
if
(
!
beginFiberMark
(
fiber
phase
)
)
{
return
;
}
currentPhaseFiber
=
fiber
;
currentPhase
=
phase
;
}
}
function
stopPhaseTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
if
(
currentPhase
!
=
=
null
&
&
currentPhaseFiber
!
=
=
null
)
{
var
warning
=
hasScheduledUpdateInCurrentPhase
?
'
Scheduled
a
cascading
update
'
:
null
;
endFiberMark
(
currentPhaseFiber
currentPhase
warning
)
;
}
currentPhase
=
null
;
currentPhaseFiber
=
null
;
}
}
function
startWorkLoopTimer
(
nextUnitOfWork
)
{
if
(
enableUserTimingAPI
)
{
currentFiber
=
nextUnitOfWork
;
if
(
!
supportsUserTiming
)
{
return
;
}
commitCountInCurrentWorkLoop
=
0
;
beginMark
(
'
(
React
Tree
Reconciliation
)
'
)
;
resumeTimers
(
)
;
}
}
function
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
interruptedBy
!
=
=
null
)
{
if
(
interruptedBy
.
tag
=
=
=
HostRoot
)
{
warning
=
'
A
top
-
level
update
interrupted
the
previous
render
'
;
}
else
{
var
componentName
=
getComponentName
(
interruptedBy
.
type
)
|
|
'
Unknown
'
;
warning
=
'
An
update
to
'
+
componentName
+
'
interrupted
the
previous
render
'
;
}
}
else
if
(
commitCountInCurrentWorkLoop
>
1
)
{
warning
=
'
There
were
cascading
updates
'
;
}
commitCountInCurrentWorkLoop
=
0
;
var
label
=
didCompleteRoot
?
'
(
React
Tree
Reconciliation
:
Completed
Root
)
'
:
'
(
React
Tree
Reconciliation
:
Yielded
)
'
;
pauseTimers
(
)
;
endMark
(
label
'
(
React
Tree
Reconciliation
)
'
warning
)
;
}
}
function
startCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
isCommitting
=
true
;
hasScheduledUpdateInCurrentCommit
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
beginMark
(
'
(
Committing
Changes
)
'
)
;
}
}
function
stopCommitTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
warning
=
null
;
if
(
hasScheduledUpdateInCurrentCommit
)
{
warning
=
'
Lifecycle
hook
scheduled
a
cascading
update
'
;
}
else
if
(
commitCountInCurrentWorkLoop
>
0
)
{
warning
=
'
Caused
by
a
cascading
update
in
earlier
commit
'
;
}
hasScheduledUpdateInCurrentCommit
=
false
;
commitCountInCurrentWorkLoop
+
+
;
isCommitting
=
false
;
labelsInCurrentCommit
.
clear
(
)
;
endMark
(
'
(
Committing
Changes
)
'
'
(
Committing
Changes
)
'
warning
)
;
}
}
function
startCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Snapshot
Effects
)
'
)
;
}
}
function
stopCommitSnapshotEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Committing
Snapshot
Effects
:
'
+
count
+
'
Total
)
'
'
(
Committing
Snapshot
Effects
)
'
null
)
;
}
}
function
startCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Committing
Host
Effects
)
'
)
;
}
}
function
stopCommitHostEffectsTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Committing
Host
Effects
:
'
+
count
+
'
Total
)
'
'
(
Committing
Host
Effects
)
'
null
)
;
}
}
function
startCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
effectCountInCurrentCommit
=
0
;
beginMark
(
'
(
Calling
Lifecycle
Methods
)
'
)
;
}
}
function
stopCommitLifeCyclesTimer
(
)
{
if
(
enableUserTimingAPI
)
{
if
(
!
supportsUserTiming
)
{
return
;
}
var
count
=
effectCountInCurrentCommit
;
effectCountInCurrentCommit
=
0
;
endMark
(
'
(
Calling
Lifecycle
Methods
:
'
+
count
+
'
Total
)
'
'
(
Calling
Lifecycle
Methods
)
'
null
)
;
}
}
var
valueStack
=
[
]
;
var
index
=
-
1
;
function
createCursor
(
defaultValue
)
{
return
{
current
:
defaultValue
}
;
}
function
pop
(
cursor
fiber
)
{
if
(
index
<
0
)
{
return
;
}
cursor
.
current
=
valueStack
[
index
]
;
valueStack
[
index
]
=
null
;
index
-
-
;
}
function
push
(
cursor
value
fiber
)
{
index
+
+
;
valueStack
[
index
]
=
cursor
.
current
;
cursor
.
current
=
value
;
}
var
emptyContextObject
=
{
}
;
var
contextStackCursor
=
createCursor
(
emptyContextObject
)
;
var
didPerformWorkStackCursor
=
createCursor
(
false
)
;
var
previousContext
=
emptyContextObject
;
function
getUnmaskedContext
(
workInProgress
Component
didPushOwnContextIfProvider
)
{
if
(
didPushOwnContextIfProvider
&
&
isContextProvider
(
Component
)
)
{
return
previousContext
;
}
return
contextStackCursor
.
current
;
}
function
cacheContext
(
workInProgress
unmaskedContext
maskedContext
)
{
var
instance
=
workInProgress
.
stateNode
;
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
unmaskedContext
;
instance
.
__reactInternalMemoizedMaskedChildContext
=
maskedContext
;
}
function
getMaskedContext
(
workInProgress
unmaskedContext
)
{
var
type
=
workInProgress
.
type
;
var
contextTypes
=
type
.
contextTypes
;
if
(
!
contextTypes
)
{
return
emptyContextObject
;
}
var
instance
=
workInProgress
.
stateNode
;
if
(
instance
&
&
instance
.
__reactInternalMemoizedUnmaskedChildContext
=
=
=
unmaskedContext
)
{
return
instance
.
__reactInternalMemoizedMaskedChildContext
;
}
var
context
=
{
}
;
for
(
var
key
in
contextTypes
)
{
context
[
key
]
=
unmaskedContext
[
key
]
;
}
if
(
instance
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
context
;
}
function
hasContextChanged
(
)
{
return
didPerformWorkStackCursor
.
current
;
}
function
isContextProvider
(
type
)
{
var
childContextTypes
=
type
.
childContextTypes
;
return
childContextTypes
!
=
=
null
&
&
childContextTypes
!
=
=
undefined
;
}
function
popContext
(
fiber
)
{
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
popTopLevelContextObject
(
fiber
)
{
pop
(
didPerformWorkStackCursor
fiber
)
;
pop
(
contextStackCursor
fiber
)
;
}
function
pushTopLevelContextObject
(
fiber
context
didChange
)
{
!
(
contextStackCursor
.
current
=
=
=
emptyContextObject
)
?
reactProdInvariant
(
'
168
'
)
:
void
0
;
push
(
contextStackCursor
context
fiber
)
;
push
(
didPerformWorkStackCursor
didChange
fiber
)
;
}
function
processChildContext
(
fiber
type
parentContext
)
{
var
instance
=
fiber
.
stateNode
;
var
childContextTypes
=
type
.
childContextTypes
;
if
(
typeof
instance
.
getChildContext
!
=
=
'
function
'
)
{
return
parentContext
;
}
var
childContext
=
void
0
;
startPhaseTimer
(
fiber
'
getChildContext
'
)
;
childContext
=
instance
.
getChildContext
(
)
;
stopPhaseTimer
(
)
;
for
(
var
contextKey
in
childContext
)
{
!
(
contextKey
in
childContextTypes
)
?
reactProdInvariant
(
'
108
'
getComponentName
(
type
)
|
|
'
Unknown
'
contextKey
)
:
void
0
;
}
return
_assign
(
{
}
parentContext
childContext
)
;
}
function
pushContextProvider
(
workInProgress
)
{
var
instance
=
workInProgress
.
stateNode
;
var
memoizedMergedChildContext
=
instance
&
&
instance
.
__reactInternalMemoizedMergedChildContext
|
|
emptyContextObject
;
previousContext
=
contextStackCursor
.
current
;
push
(
contextStackCursor
memoizedMergedChildContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didPerformWorkStackCursor
.
current
workInProgress
)
;
return
true
;
}
function
invalidateContextProvider
(
workInProgress
type
didChange
)
{
var
instance
=
workInProgress
.
stateNode
;
!
instance
?
reactProdInvariant
(
'
169
'
)
:
void
0
;
if
(
didChange
)
{
var
mergedContext
=
processChildContext
(
workInProgress
type
previousContext
)
;
instance
.
__reactInternalMemoizedMergedChildContext
=
mergedContext
;
pop
(
didPerformWorkStackCursor
workInProgress
)
;
pop
(
contextStackCursor
workInProgress
)
;
push
(
contextStackCursor
mergedContext
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
else
{
pop
(
didPerformWorkStackCursor
workInProgress
)
;
push
(
didPerformWorkStackCursor
didChange
workInProgress
)
;
}
}
function
findCurrentUnmaskedContext
(
fiber
)
{
!
(
isFiberMounted
(
fiber
)
&
&
fiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
170
'
)
:
void
0
;
var
node
=
fiber
;
do
{
switch
(
node
.
tag
)
{
case
HostRoot
:
return
node
.
stateNode
.
context
;
case
ClassComponent
:
{
var
Component
=
node
.
type
;
if
(
isContextProvider
(
Component
)
)
{
return
node
.
stateNode
.
__reactInternalMemoizedMergedChildContext
;
}
break
;
}
}
node
=
node
.
return
;
}
while
(
node
!
=
=
null
)
;
reactProdInvariant
(
'
171
'
)
;
}
var
onCommitFiberRoot
=
null
;
var
onCommitFiberUnmount
=
null
;
function
catchErrors
(
fn
)
{
return
function
(
arg
)
{
try
{
return
fn
(
arg
)
;
}
catch
(
err
)
{
}
}
;
}
var
isDevToolsPresent
=
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
!
=
=
'
undefined
'
;
function
injectInternals
(
internals
)
{
if
(
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
=
=
=
'
undefined
'
)
{
return
false
;
}
var
hook
=
__REACT_DEVTOOLS_GLOBAL_HOOK__
;
if
(
hook
.
isDisabled
)
{
return
true
;
}
if
(
!
hook
.
supportsFiber
)
{
return
true
;
}
try
{
var
rendererID
=
hook
.
inject
(
internals
)
;
onCommitFiberRoot
=
catchErrors
(
function
(
root
)
{
return
hook
.
onCommitFiberRoot
(
rendererID
root
)
;
}
)
;
onCommitFiberUnmount
=
catchErrors
(
function
(
fiber
)
{
return
hook
.
onCommitFiberUnmount
(
rendererID
fiber
)
;
}
)
;
}
catch
(
err
)
{
}
return
true
;
}
function
onCommitRoot
(
root
)
{
if
(
typeof
onCommitFiberRoot
=
=
=
'
function
'
)
{
onCommitFiberRoot
(
root
)
;
}
}
function
onCommitUnmount
(
fiber
)
{
if
(
typeof
onCommitFiberUnmount
=
=
=
'
function
'
)
{
onCommitFiberUnmount
(
fiber
)
;
}
}
var
maxSigned31BitInt
=
1073741823
;
var
NoWork
=
0
;
var
Never
=
1
;
var
Sync
=
maxSigned31BitInt
;
var
UNIT_SIZE
=
10
;
var
MAGIC_NUMBER_OFFSET
=
maxSigned31BitInt
-
1
;
function
msToExpirationTime
(
ms
)
{
return
MAGIC_NUMBER_OFFSET
-
(
ms
/
UNIT_SIZE
|
0
)
;
}
function
expirationTimeToMs
(
expirationTime
)
{
return
(
MAGIC_NUMBER_OFFSET
-
expirationTime
)
*
UNIT_SIZE
;
}
function
ceiling
(
num
precision
)
{
return
(
(
num
/
precision
|
0
)
+
1
)
*
precision
;
}
function
computeExpirationBucket
(
currentTime
expirationInMs
bucketSizeMs
)
{
return
MAGIC_NUMBER_OFFSET
-
ceiling
(
MAGIC_NUMBER_OFFSET
-
currentTime
+
expirationInMs
/
UNIT_SIZE
bucketSizeMs
/
UNIT_SIZE
)
;
}
var
LOW_PRIORITY_EXPIRATION
=
5000
;
var
LOW_PRIORITY_BATCH_SIZE
=
250
;
function
computeAsyncExpiration
(
currentTime
)
{
return
computeExpirationBucket
(
currentTime
LOW_PRIORITY_EXPIRATION
LOW_PRIORITY_BATCH_SIZE
)
;
}
var
HIGH_PRIORITY_EXPIRATION
=
150
;
var
HIGH_PRIORITY_BATCH_SIZE
=
100
;
function
computeInteractiveExpiration
(
currentTime
)
{
return
computeExpirationBucket
(
currentTime
HIGH_PRIORITY_EXPIRATION
HIGH_PRIORITY_BATCH_SIZE
)
;
}
var
NoContext
=
0
;
var
ConcurrentMode
=
1
;
var
StrictMode
=
2
;
var
ProfileMode
=
4
;
function
FiberNode
(
tag
pendingProps
key
mode
)
{
this
.
tag
=
tag
;
this
.
key
=
key
;
this
.
elementType
=
null
;
this
.
type
=
null
;
this
.
stateNode
=
null
;
this
.
return
=
null
;
this
.
child
=
null
;
this
.
sibling
=
null
;
this
.
index
=
0
;
this
.
ref
=
null
;
this
.
pendingProps
=
pendingProps
;
this
.
memoizedProps
=
null
;
this
.
updateQueue
=
null
;
this
.
memoizedState
=
null
;
this
.
contextDependencies
=
null
;
this
.
mode
=
mode
;
this
.
effectTag
=
NoEffect
;
this
.
nextEffect
=
null
;
this
.
firstEffect
=
null
;
this
.
lastEffect
=
null
;
this
.
expirationTime
=
NoWork
;
this
.
childExpirationTime
=
NoWork
;
this
.
alternate
=
null
;
if
(
enableProfilerTimer
)
{
this
.
actualDuration
=
Number
.
NaN
;
this
.
actualStartTime
=
Number
.
NaN
;
this
.
selfBaseDuration
=
Number
.
NaN
;
this
.
treeBaseDuration
=
Number
.
NaN
;
this
.
actualDuration
=
0
;
this
.
actualStartTime
=
-
1
;
this
.
selfBaseDuration
=
0
;
this
.
treeBaseDuration
=
0
;
}
}
var
createFiber
=
function
(
tag
pendingProps
key
mode
)
{
return
new
FiberNode
(
tag
pendingProps
key
mode
)
;
}
;
function
shouldConstruct
(
Component
)
{
var
prototype
=
Component
.
prototype
;
return
!
!
(
prototype
&
&
prototype
.
isReactComponent
)
;
}
function
isSimpleFunctionComponent
(
type
)
{
return
typeof
type
=
=
=
'
function
'
&
&
!
shouldConstruct
(
type
)
&
&
type
.
defaultProps
=
=
=
undefined
;
}
function
resolveLazyComponentTag
(
Component
)
{
if
(
typeof
Component
=
=
=
'
function
'
)
{
return
shouldConstruct
(
Component
)
?
ClassComponent
:
FunctionComponent
;
}
else
if
(
Component
!
=
=
undefined
&
&
Component
!
=
=
null
)
{
var
typeof
=
Component
.
typeof
;
if
(
typeof
=
=
=
REACT_FORWARD_REF_TYPE
)
{
return
ForwardRef
;
}
if
(
typeof
=
=
=
REACT_MEMO_TYPE
)
{
return
MemoComponent
;
}
}
return
IndeterminateComponent
;
}
function
createWorkInProgress
(
current
pendingProps
expirationTime
)
{
var
workInProgress
=
current
.
alternate
;
if
(
workInProgress
=
=
=
null
)
{
workInProgress
=
createFiber
(
current
.
tag
pendingProps
current
.
key
current
.
mode
)
;
workInProgress
.
elementType
=
current
.
elementType
;
workInProgress
.
type
=
current
.
type
;
workInProgress
.
stateNode
=
current
.
stateNode
;
workInProgress
.
alternate
=
current
;
current
.
alternate
=
workInProgress
;
}
else
{
workInProgress
.
pendingProps
=
pendingProps
;
workInProgress
.
effectTag
=
NoEffect
;
workInProgress
.
nextEffect
=
null
;
workInProgress
.
firstEffect
=
null
;
workInProgress
.
lastEffect
=
null
;
if
(
enableProfilerTimer
)
{
workInProgress
.
actualDuration
=
0
;
workInProgress
.
actualStartTime
=
-
1
;
}
}
workInProgress
.
childExpirationTime
=
current
.
childExpirationTime
;
workInProgress
.
expirationTime
=
current
.
expirationTime
;
workInProgress
.
child
=
current
.
child
;
workInProgress
.
memoizedProps
=
current
.
memoizedProps
;
workInProgress
.
memoizedState
=
current
.
memoizedState
;
workInProgress
.
updateQueue
=
current
.
updateQueue
;
workInProgress
.
contextDependencies
=
current
.
contextDependencies
;
workInProgress
.
sibling
=
current
.
sibling
;
workInProgress
.
index
=
current
.
index
;
workInProgress
.
ref
=
current
.
ref
;
if
(
enableProfilerTimer
)
{
workInProgress
.
selfBaseDuration
=
current
.
selfBaseDuration
;
workInProgress
.
treeBaseDuration
=
current
.
treeBaseDuration
;
}
return
workInProgress
;
}
function
createHostRootFiber
(
isConcurrent
)
{
var
mode
=
isConcurrent
?
ConcurrentMode
|
StrictMode
:
NoContext
;
if
(
enableProfilerTimer
&
&
isDevToolsPresent
)
{
mode
|
=
ProfileMode
;
}
return
createFiber
(
HostRoot
null
null
mode
)
;
}
function
createFiberFromTypeAndProps
(
type
key
pendingProps
owner
mode
expirationTime
)
{
var
fiber
=
void
0
;
var
fiberTag
=
IndeterminateComponent
;
var
resolvedType
=
type
;
if
(
typeof
type
=
=
=
'
function
'
)
{
if
(
shouldConstruct
(
type
)
)
{
fiberTag
=
ClassComponent
;
}
}
else
if
(
typeof
type
=
=
=
'
string
'
)
{
fiberTag
=
HostComponent
;
}
else
{
getTag
:
switch
(
type
)
{
case
REACT_FRAGMENT_TYPE
:
return
createFiberFromFragment
(
pendingProps
.
children
mode
expirationTime
key
)
;
case
REACT_CONCURRENT_MODE_TYPE
:
return
createFiberFromMode
(
pendingProps
mode
|
ConcurrentMode
|
StrictMode
expirationTime
key
)
;
case
REACT_STRICT_MODE_TYPE
:
return
createFiberFromMode
(
pendingProps
mode
|
StrictMode
expirationTime
key
)
;
case
REACT_PROFILER_TYPE
:
return
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
;
case
REACT_SUSPENSE_TYPE
:
return
createFiberFromSuspense
(
pendingProps
mode
expirationTime
key
)
;
default
:
{
if
(
typeof
type
=
=
=
'
object
'
&
&
type
!
=
=
null
)
{
switch
(
type
.
typeof
)
{
case
REACT_PROVIDER_TYPE
:
fiberTag
=
ContextProvider
;
break
getTag
;
case
REACT_CONTEXT_TYPE
:
fiberTag
=
ContextConsumer
;
break
getTag
;
case
REACT_FORWARD_REF_TYPE
:
fiberTag
=
ForwardRef
;
break
getTag
;
case
REACT_MEMO_TYPE
:
fiberTag
=
MemoComponent
;
break
getTag
;
case
REACT_LAZY_TYPE
:
fiberTag
=
LazyComponent
;
resolvedType
=
null
;
break
getTag
;
}
}
var
info
=
'
'
;
reactProdInvariant
(
'
130
'
type
=
=
null
?
type
:
typeof
type
info
)
;
}
}
}
fiber
=
createFiber
(
fiberTag
pendingProps
key
mode
)
;
fiber
.
elementType
=
type
;
fiber
.
type
=
resolvedType
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromElement
(
element
mode
expirationTime
)
{
var
owner
=
null
;
var
type
=
element
.
type
;
var
key
=
element
.
key
;
var
pendingProps
=
element
.
props
;
var
fiber
=
createFiberFromTypeAndProps
(
type
key
pendingProps
owner
mode
expirationTime
)
;
return
fiber
;
}
function
createFiberFromFragment
(
elements
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Fragment
elements
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromProfiler
(
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Profiler
pendingProps
key
mode
|
ProfileMode
)
;
fiber
.
elementType
=
REACT_PROFILER_TYPE
;
fiber
.
type
=
REACT_PROFILER_TYPE
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromMode
(
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
Mode
pendingProps
key
mode
)
;
var
type
=
(
mode
&
ConcurrentMode
)
=
=
=
NoContext
?
REACT_STRICT_MODE_TYPE
:
REACT_CONCURRENT_MODE_TYPE
;
fiber
.
elementType
=
type
;
fiber
.
type
=
type
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromSuspense
(
pendingProps
mode
expirationTime
key
)
{
var
fiber
=
createFiber
(
SuspenseComponent
pendingProps
key
mode
)
;
var
type
=
REACT_SUSPENSE_TYPE
;
fiber
.
elementType
=
type
;
fiber
.
type
=
type
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromText
(
content
mode
expirationTime
)
{
var
fiber
=
createFiber
(
HostText
content
null
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
return
fiber
;
}
function
createFiberFromHostInstanceForDeletion
(
)
{
var
fiber
=
createFiber
(
HostComponent
null
null
NoContext
)
;
fiber
.
elementType
=
'
DELETED
'
;
fiber
.
type
=
'
DELETED
'
;
return
fiber
;
}
function
createFiberFromPortal
(
portal
mode
expirationTime
)
{
var
pendingProps
=
portal
.
children
!
=
=
null
?
portal
.
children
:
[
]
;
var
fiber
=
createFiber
(
HostPortal
pendingProps
portal
.
key
mode
)
;
fiber
.
expirationTime
=
expirationTime
;
fiber
.
stateNode
=
{
containerInfo
:
portal
.
containerInfo
pendingChildren
:
null
implementation
:
portal
.
implementation
}
;
return
fiber
;
}
var
ReactInternals
2
=
React
.
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
;
var
_ReactInternals
Sched
1
=
ReactInternals
2
.
SchedulerTracing
;
var
__interactionsRef
=
_ReactInternals
Sched
1
.
__interactionsRef
;
var
__subscriberRef
=
_ReactInternals
Sched
1
.
__subscriberRef
;
var
unstable_clear
=
_ReactInternals
Sched
1
.
unstable_clear
;
var
unstable_getCurrent
=
_ReactInternals
Sched
1
.
unstable_getCurrent
;
var
unstable_getThreadID
=
_ReactInternals
Sched
1
.
unstable_getThreadID
;
var
unstable_subscribe
=
_ReactInternals
Sched
1
.
unstable_subscribe
;
var
unstable_trace
=
_ReactInternals
Sched
1
.
unstable_trace
;
var
unstable_unsubscribe
=
_ReactInternals
Sched
1
.
unstable_unsubscribe
;
var
unstable_wrap
=
_ReactInternals
Sched
1
.
unstable_wrap
;
function
createFiberRoot
(
containerInfo
isConcurrent
hydrate
)
{
var
uninitializedFiber
=
createHostRootFiber
(
isConcurrent
)
;
var
root
=
void
0
;
if
(
enableSchedulerTracing
)
{
root
=
{
current
:
uninitializedFiber
containerInfo
:
containerInfo
pendingChildren
:
null
earliestPendingTime
:
NoWork
latestPendingTime
:
NoWork
earliestSuspendedTime
:
NoWork
latestSuspendedTime
:
NoWork
latestPingedTime
:
NoWork
pingCache
:
null
didError
:
false
pendingCommitExpirationTime
:
NoWork
finishedWork
:
null
timeoutHandle
:
noTimeout
context
:
null
pendingContext
:
null
hydrate
:
hydrate
nextExpirationTimeToWorkOn
:
NoWork
expirationTime
:
NoWork
firstBatch
:
null
nextScheduledRoot
:
null
interactionThreadID
:
unstable_getThreadID
(
)
memoizedInteractions
:
new
Set
(
)
pendingInteractionMap
:
new
Map
(
)
}
;
}
else
{
root
=
{
current
:
uninitializedFiber
containerInfo
:
containerInfo
pendingChildren
:
null
pingCache
:
null
earliestPendingTime
:
NoWork
latestPendingTime
:
NoWork
earliestSuspendedTime
:
NoWork
latestSuspendedTime
:
NoWork
latestPingedTime
:
NoWork
didError
:
false
pendingCommitExpirationTime
:
NoWork
finishedWork
:
null
timeoutHandle
:
noTimeout
context
:
null
pendingContext
:
null
hydrate
:
hydrate
nextExpirationTimeToWorkOn
:
NoWork
expirationTime
:
NoWork
firstBatch
:
null
nextScheduledRoot
:
null
}
;
}
uninitializedFiber
.
stateNode
=
root
;
return
root
;
}
function
markPendingPriorityLevel
(
root
expirationTime
)
{
root
.
didError
=
false
;
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestPendingTime
=
=
=
NoWork
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
expirationTime
;
}
else
{
if
(
earliestPendingTime
<
expirationTime
)
{
root
.
earliestPendingTime
=
expirationTime
;
}
else
{
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
latestPendingTime
>
expirationTime
)
{
root
.
latestPendingTime
=
expirationTime
;
}
}
}
findNextExpirationTimeToWorkOn
(
expirationTime
root
)
;
}
function
markCommittedPriorityLevels
(
root
earliestRemainingTime
)
{
root
.
didError
=
false
;
if
(
earliestRemainingTime
=
=
=
NoWork
)
{
root
.
earliestPendingTime
=
NoWork
;
root
.
latestPendingTime
=
NoWork
;
root
.
earliestSuspendedTime
=
NoWork
;
root
.
latestSuspendedTime
=
NoWork
;
root
.
latestPingedTime
=
NoWork
;
findNextExpirationTimeToWorkOn
(
NoWork
root
)
;
return
;
}
if
(
earliestRemainingTime
<
root
.
latestPingedTime
)
{
root
.
latestPingedTime
=
NoWork
;
}
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
latestPendingTime
!
=
=
NoWork
)
{
if
(
latestPendingTime
>
earliestRemainingTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
NoWork
;
}
else
{
var
earliestPendingTime
=
root
.
earliestPendingTime
;
if
(
earliestPendingTime
>
earliestRemainingTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
;
}
}
}
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
findNextExpirationTimeToWorkOn
(
NoWork
root
)
;
return
;
}
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
earliestRemainingTime
<
latestSuspendedTime
)
{
root
.
earliestSuspendedTime
=
NoWork
;
root
.
latestSuspendedTime
=
NoWork
;
root
.
latestPingedTime
=
NoWork
;
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
findNextExpirationTimeToWorkOn
(
NoWork
root
)
;
return
;
}
if
(
earliestRemainingTime
>
earliestSuspendedTime
)
{
markPendingPriorityLevel
(
root
earliestRemainingTime
)
;
findNextExpirationTimeToWorkOn
(
NoWork
root
)
;
return
;
}
findNextExpirationTimeToWorkOn
(
NoWork
root
)
;
}
function
hasLowerPriorityWork
(
root
erroredExpirationTime
)
{
var
latestPendingTime
=
root
.
latestPendingTime
;
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
var
latestPingedTime
=
root
.
latestPingedTime
;
return
latestPendingTime
!
=
=
NoWork
&
&
latestPendingTime
<
erroredExpirationTime
|
|
latestSuspendedTime
!
=
=
NoWork
&
&
latestSuspendedTime
<
erroredExpirationTime
|
|
latestPingedTime
!
=
=
NoWork
&
&
latestPingedTime
<
erroredExpirationTime
;
}
function
isPriorityLevelSuspended
(
root
expirationTime
)
{
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
return
earliestSuspendedTime
!
=
=
NoWork
&
&
expirationTime
<
=
earliestSuspendedTime
&
&
expirationTime
>
=
latestSuspendedTime
;
}
function
markSuspendedPriorityLevel
(
root
suspendedTime
)
{
root
.
didError
=
false
;
clearPing
(
root
suspendedTime
)
;
var
earliestPendingTime
=
root
.
earliestPendingTime
;
var
latestPendingTime
=
root
.
latestPendingTime
;
if
(
earliestPendingTime
=
=
=
suspendedTime
)
{
if
(
latestPendingTime
=
=
=
suspendedTime
)
{
root
.
earliestPendingTime
=
root
.
latestPendingTime
=
NoWork
;
}
else
{
root
.
earliestPendingTime
=
latestPendingTime
;
}
}
else
if
(
latestPendingTime
=
=
=
suspendedTime
)
{
root
.
latestPendingTime
=
earliestPendingTime
;
}
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
if
(
earliestSuspendedTime
=
=
=
NoWork
)
{
root
.
earliestSuspendedTime
=
root
.
latestSuspendedTime
=
suspendedTime
;
}
else
{
if
(
earliestSuspendedTime
<
suspendedTime
)
{
root
.
earliestSuspendedTime
=
suspendedTime
;
}
else
if
(
latestSuspendedTime
>
suspendedTime
)
{
root
.
latestSuspendedTime
=
suspendedTime
;
}
}
findNextExpirationTimeToWorkOn
(
suspendedTime
root
)
;
}
function
markPingedPriorityLevel
(
root
pingedTime
)
{
root
.
didError
=
false
;
var
latestPingedTime
=
root
.
latestPingedTime
;
if
(
latestPingedTime
=
=
=
NoWork
|
|
latestPingedTime
>
pingedTime
)
{
root
.
latestPingedTime
=
pingedTime
;
}
findNextExpirationTimeToWorkOn
(
pingedTime
root
)
;
}
function
clearPing
(
root
completedTime
)
{
var
latestPingedTime
=
root
.
latestPingedTime
;
if
(
latestPingedTime
>
=
completedTime
)
{
root
.
latestPingedTime
=
NoWork
;
}
}
function
findEarliestOutstandingPriorityLevel
(
root
renderExpirationTime
)
{
var
earliestExpirationTime
=
renderExpirationTime
;
var
earliestPendingTime
=
root
.
earliestPendingTime
;
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
if
(
earliestPendingTime
>
earliestExpirationTime
)
{
earliestExpirationTime
=
earliestPendingTime
;
}
if
(
earliestSuspendedTime
>
earliestExpirationTime
)
{
earliestExpirationTime
=
earliestSuspendedTime
;
}
return
earliestExpirationTime
;
}
function
didExpireAtExpirationTime
(
root
currentTime
)
{
var
expirationTime
=
root
.
expirationTime
;
if
(
expirationTime
!
=
=
NoWork
&
&
currentTime
<
=
expirationTime
)
{
root
.
nextExpirationTimeToWorkOn
=
currentTime
;
}
}
function
findNextExpirationTimeToWorkOn
(
completedExpirationTime
root
)
{
var
earliestSuspendedTime
=
root
.
earliestSuspendedTime
;
var
latestSuspendedTime
=
root
.
latestSuspendedTime
;
var
earliestPendingTime
=
root
.
earliestPendingTime
;
var
latestPingedTime
=
root
.
latestPingedTime
;
var
nextExpirationTimeToWorkOn
=
earliestPendingTime
!
=
=
NoWork
?
earliestPendingTime
:
latestPingedTime
;
if
(
nextExpirationTimeToWorkOn
=
=
=
NoWork
&
&
(
completedExpirationTime
=
=
=
NoWork
|
|
latestSuspendedTime
<
completedExpirationTime
)
)
{
nextExpirationTimeToWorkOn
=
latestSuspendedTime
;
}
var
expirationTime
=
nextExpirationTimeToWorkOn
;
if
(
expirationTime
!
=
=
NoWork
&
&
earliestSuspendedTime
>
expirationTime
)
{
expirationTime
=
earliestSuspendedTime
;
}
root
.
nextExpirationTimeToWorkOn
=
nextExpirationTimeToWorkOn
;
root
.
expirationTime
=
expirationTime
;
}
function
resolveDefaultProps
(
Component
baseProps
)
{
if
(
Component
&
&
Component
.
defaultProps
)
{
var
props
=
_assign
(
{
}
baseProps
)
;
var
defaultProps
=
Component
.
defaultProps
;
for
(
var
propName
in
defaultProps
)
{
if
(
props
[
propName
]
=
=
=
undefined
)
{
props
[
propName
]
=
defaultProps
[
propName
]
;
}
}
return
props
;
}
return
baseProps
;
}
function
readLazyComponentType
(
lazyComponent
)
{
var
status
=
lazyComponent
.
_status
;
var
result
=
lazyComponent
.
_result
;
switch
(
status
)
{
case
Resolved
:
{
var
Component
=
result
;
return
Component
;
}
case
Rejected
:
{
var
error
=
result
;
throw
error
;
}
case
Pending
:
{
var
thenable
=
result
;
throw
thenable
;
}
default
:
{
lazyComponent
.
_status
=
Pending
;
var
ctor
=
lazyComponent
.
_ctor
;
var
_thenable
=
ctor
(
)
;
_thenable
.
then
(
function
(
moduleObject
)
{
if
(
lazyComponent
.
_status
=
=
=
Pending
)
{
var
defaultExport
=
moduleObject
.
default
;
lazyComponent
.
_status
=
Resolved
;
lazyComponent
.
_result
=
defaultExport
;
}
}
function
(
error
)
{
if
(
lazyComponent
.
_status
=
=
=
Pending
)
{
lazyComponent
.
_status
=
Rejected
;
lazyComponent
.
_result
=
error
;
}
}
)
;
switch
(
lazyComponent
.
_status
)
{
case
Resolved
:
return
lazyComponent
.
_result
;
case
Rejected
:
throw
lazyComponent
.
_result
;
}
lazyComponent
.
_result
=
_thenable
;
throw
_thenable
;
}
}
}
var
emptyRefsObject
=
new
React
.
Component
(
)
.
refs
;
function
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
nextProps
)
{
var
prevState
=
workInProgress
.
memoizedState
;
var
partialState
=
getDerivedStateFromProps
(
nextProps
prevState
)
;
var
memoizedState
=
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
?
prevState
:
_assign
(
{
}
prevState
partialState
)
;
workInProgress
.
memoizedState
=
memoizedState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
&
&
workInProgress
.
expirationTime
=
=
=
NoWork
)
{
updateQueue
.
baseState
=
memoizedState
;
}
}
var
classComponentUpdater
=
{
isMounted
:
isMounted
enqueueSetState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
requestCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
flushPassiveEffects
(
)
;
enqueueUpdate
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueReplaceState
:
function
(
inst
payload
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
requestCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
ReplaceState
;
update
.
payload
=
payload
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
flushPassiveEffects
(
)
;
enqueueUpdate
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
enqueueForceUpdate
:
function
(
inst
callback
)
{
var
fiber
=
get
(
inst
)
;
var
currentTime
=
requestCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
ForceUpdate
;
if
(
callback
!
=
=
undefined
&
&
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
flushPassiveEffects
(
)
;
enqueueUpdate
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
}
}
;
function
checkShouldComponentUpdate
(
workInProgress
ctor
oldProps
newProps
oldState
newState
nextContext
)
{
var
instance
=
workInProgress
.
stateNode
;
if
(
typeof
instance
.
shouldComponentUpdate
=
=
=
'
function
'
)
{
startPhaseTimer
(
workInProgress
'
shouldComponentUpdate
'
)
;
var
shouldUpdate
=
instance
.
shouldComponentUpdate
(
newProps
newState
nextContext
)
;
stopPhaseTimer
(
)
;
return
shouldUpdate
;
}
if
(
ctor
.
prototype
&
&
ctor
.
prototype
.
isPureReactComponent
)
{
return
!
shallowEqual
(
oldProps
newProps
)
|
|
!
shallowEqual
(
oldState
newState
)
;
}
return
true
;
}
function
adoptClassInstance
(
workInProgress
instance
)
{
instance
.
updater
=
classComponentUpdater
;
workInProgress
.
stateNode
=
instance
;
set
(
instance
workInProgress
)
;
}
function
constructClassInstance
(
workInProgress
ctor
props
renderExpirationTime
)
{
var
isLegacyContextConsumer
=
false
;
var
unmaskedContext
=
emptyContextObject
;
var
context
=
null
;
var
contextType
=
ctor
.
contextType
;
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
context
=
readContext
(
contextType
)
;
}
else
{
unmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
var
contextTypes
=
ctor
.
contextTypes
;
isLegacyContextConsumer
=
contextTypes
!
=
=
null
&
&
contextTypes
!
=
=
undefined
;
context
=
isLegacyContextConsumer
?
getMaskedContext
(
workInProgress
unmaskedContext
)
:
emptyContextObject
;
}
var
instance
=
new
ctor
(
props
context
)
;
var
state
=
workInProgress
.
memoizedState
=
instance
.
state
!
=
=
null
&
&
instance
.
state
!
=
=
undefined
?
instance
.
state
:
null
;
adoptClassInstance
(
workInProgress
instance
)
;
if
(
isLegacyContextConsumer
)
{
cacheContext
(
workInProgress
unmaskedContext
context
)
;
}
return
instance
;
}
function
callComponentWillMount
(
workInProgress
instance
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
var
oldState
=
instance
.
state
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
if
(
oldState
!
=
=
instance
.
state
)
{
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
callComponentWillReceiveProps
(
workInProgress
instance
newProps
nextContext
)
{
var
oldState
=
instance
.
state
;
startPhaseTimer
(
workInProgress
'
componentWillReceiveProps
'
)
;
if
(
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
componentWillReceiveProps
(
newProps
nextContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillReceiveProps
(
newProps
nextContext
)
;
}
stopPhaseTimer
(
)
;
if
(
instance
.
state
!
=
=
oldState
)
{
classComponentUpdater
.
enqueueReplaceState
(
instance
instance
.
state
null
)
;
}
}
function
mountClassInstance
(
workInProgress
ctor
newProps
renderExpirationTime
)
{
var
instance
=
workInProgress
.
stateNode
;
instance
.
props
=
newProps
;
instance
.
state
=
workInProgress
.
memoizedState
;
instance
.
refs
=
emptyRefsObject
;
var
contextType
=
ctor
.
contextType
;
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
instance
.
context
=
readContext
(
contextType
)
;
}
else
{
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
instance
.
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
}
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
newProps
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
if
(
typeof
ctor
.
getDerivedStateFromProps
!
=
=
'
function
'
&
&
typeof
instance
.
getSnapshotBeforeUpdate
!
=
=
'
function
'
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
callComponentWillMount
(
workInProgress
instance
)
;
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
instance
.
state
=
workInProgress
.
memoizedState
;
}
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
function
resumeMountClassInstance
(
workInProgress
ctor
newProps
renderExpirationTime
)
{
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
instance
.
props
=
oldProps
;
var
oldContext
=
instance
.
context
;
var
contextType
=
ctor
.
contextType
;
var
nextContext
=
void
0
;
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
nextContext
=
readContext
(
contextType
)
;
}
else
{
var
nextLegacyUnmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
nextContext
=
getMaskedContext
(
workInProgress
nextLegacyUnmaskedContext
)
;
}
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
nextContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
nextContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
ctor
oldProps
newProps
oldState
newState
nextContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillMount
'
)
;
if
(
typeof
instance
.
componentWillMount
=
=
=
'
function
'
)
{
instance
.
componentWillMount
(
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillMount
(
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
else
{
if
(
typeof
instance
.
componentDidMount
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
nextContext
;
return
shouldUpdate
;
}
function
updateClassInstance
(
current
workInProgress
ctor
newProps
renderExpirationTime
)
{
var
instance
=
workInProgress
.
stateNode
;
var
oldProps
=
workInProgress
.
memoizedProps
;
instance
.
props
=
workInProgress
.
type
=
=
=
workInProgress
.
elementType
?
oldProps
:
resolveDefaultProps
(
workInProgress
.
type
oldProps
)
;
var
oldContext
=
instance
.
context
;
var
contextType
=
ctor
.
contextType
;
var
nextContext
=
void
0
;
if
(
typeof
contextType
=
=
=
'
object
'
&
&
contextType
!
=
=
null
)
{
nextContext
=
readContext
(
contextType
)
;
}
else
{
var
nextUnmaskedContext
=
getUnmaskedContext
(
workInProgress
ctor
true
)
;
nextContext
=
getMaskedContext
(
workInProgress
nextUnmaskedContext
)
;
}
var
getDerivedStateFromProps
=
ctor
.
getDerivedStateFromProps
;
var
hasNewLifecycles
=
typeof
getDerivedStateFromProps
=
=
=
'
function
'
|
|
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
;
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillReceiveProps
=
=
=
'
function
'
)
)
{
if
(
oldProps
!
=
=
newProps
|
|
oldContext
!
=
=
nextContext
)
{
callComponentWillReceiveProps
(
workInProgress
instance
newProps
nextContext
)
;
}
}
resetHasForceUpdateBeforeProcessing
(
)
;
var
oldState
=
workInProgress
.
memoizedState
;
var
newState
=
instance
.
state
=
oldState
;
var
updateQueue
=
workInProgress
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
processUpdateQueue
(
workInProgress
updateQueue
newProps
instance
renderExpirationTime
)
;
newState
=
workInProgress
.
memoizedState
;
}
if
(
oldProps
=
=
=
newProps
&
&
oldState
=
=
=
newState
&
&
!
hasContextChanged
(
)
&
&
!
checkHasForceUpdateAfterProcessing
(
)
)
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
return
false
;
}
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
ctor
getDerivedStateFromProps
newProps
)
;
newState
=
workInProgress
.
memoizedState
;
}
var
shouldUpdate
=
checkHasForceUpdateAfterProcessing
(
)
|
|
checkShouldComponentUpdate
(
workInProgress
ctor
oldProps
newProps
oldState
newState
nextContext
)
;
if
(
shouldUpdate
)
{
if
(
!
hasNewLifecycles
&
&
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
|
|
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
)
{
startPhaseTimer
(
workInProgress
'
componentWillUpdate
'
)
;
if
(
typeof
instance
.
componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
componentWillUpdate
(
newProps
newState
nextContext
)
;
}
if
(
typeof
instance
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
instance
.
UNSAFE_componentWillUpdate
(
newProps
newState
nextContext
)
;
}
stopPhaseTimer
(
)
;
}
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Update
;
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
else
{
if
(
typeof
instance
.
componentDidUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Update
;
}
}
if
(
typeof
instance
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
oldProps
!
=
=
current
.
memoizedProps
|
|
oldState
!
=
=
current
.
memoizedState
)
{
workInProgress
.
effectTag
|
=
Snapshot
;
}
}
workInProgress
.
memoizedProps
=
newProps
;
workInProgress
.
memoizedState
=
newState
;
}
instance
.
props
=
newProps
;
instance
.
state
=
newState
;
instance
.
context
=
nextContext
;
return
shouldUpdate
;
}
var
isArray
=
Array
.
isArray
;
function
coerceRef
(
returnFiber
current
1
element
)
{
var
mixedRef
=
element
.
ref
;
if
(
mixedRef
!
=
=
null
&
&
typeof
mixedRef
!
=
=
'
function
'
&
&
typeof
mixedRef
!
=
=
'
object
'
)
{
if
(
element
.
_owner
)
{
var
owner
=
element
.
_owner
;
var
inst
=
void
0
;
if
(
owner
)
{
var
ownerFiber
=
owner
;
!
(
ownerFiber
.
tag
=
=
=
ClassComponent
)
?
reactProdInvariant
(
'
309
'
)
:
void
0
;
inst
=
ownerFiber
.
stateNode
;
}
!
inst
?
reactProdInvariant
(
'
147
'
mixedRef
)
:
void
0
;
var
stringRef
=
'
'
+
mixedRef
;
if
(
current
1
!
=
=
null
&
&
current
1
.
ref
!
=
=
null
&
&
typeof
current
1
.
ref
=
=
=
'
function
'
&
&
current
1
.
ref
.
_stringRef
=
=
=
stringRef
)
{
return
current
1
.
ref
;
}
var
ref
=
function
(
value
)
{
var
refs
=
inst
.
refs
;
if
(
refs
=
=
=
emptyRefsObject
)
{
refs
=
inst
.
refs
=
{
}
;
}
if
(
value
=
=
=
null
)
{
delete
refs
[
stringRef
]
;
}
else
{
refs
[
stringRef
]
=
value
;
}
}
;
ref
.
_stringRef
=
stringRef
;
return
ref
;
}
else
{
!
(
typeof
mixedRef
=
=
=
'
string
'
)
?
reactProdInvariant
(
'
284
'
)
:
void
0
;
!
element
.
_owner
?
reactProdInvariant
(
'
290
'
mixedRef
)
:
void
0
;
}
}
return
mixedRef
;
}
function
throwOnInvalidObjectType
(
returnFiber
newChild
)
{
if
(
returnFiber
.
type
!
=
=
'
textarea
'
)
{
var
addendum
=
'
'
;
reactProdInvariant
(
'
31
'
Object
.
prototype
.
toString
.
call
(
newChild
)
=
=
=
'
[
object
Object
]
'
?
'
object
with
keys
{
'
+
Object
.
keys
(
newChild
)
.
join
(
'
'
)
+
'
}
'
:
newChild
addendum
)
;
}
}
function
ChildReconciler
(
shouldTrackSideEffects
)
{
function
deleteChild
(
returnFiber
childToDelete
)
{
if
(
!
shouldTrackSideEffects
)
{
return
;
}
var
last
=
returnFiber
.
lastEffect
;
if
(
last
!
=
=
null
)
{
last
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
childToDelete
.
nextEffect
=
null
;
childToDelete
.
effectTag
=
Deletion
;
}
function
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
{
if
(
!
shouldTrackSideEffects
)
{
return
null
;
}
var
childToDelete
=
currentFirstChild
;
while
(
childToDelete
!
=
=
null
)
{
deleteChild
(
returnFiber
childToDelete
)
;
childToDelete
=
childToDelete
.
sibling
;
}
return
null
;
}
function
mapRemainingChildren
(
returnFiber
currentFirstChild
)
{
var
existingChildren
=
new
Map
(
)
;
var
existingChild
=
currentFirstChild
;
while
(
existingChild
!
=
=
null
)
{
if
(
existingChild
.
key
!
=
=
null
)
{
existingChildren
.
set
(
existingChild
.
key
existingChild
)
;
}
else
{
existingChildren
.
set
(
existingChild
.
index
existingChild
)
;
}
existingChild
=
existingChild
.
sibling
;
}
return
existingChildren
;
}
function
useFiber
(
fiber
pendingProps
expirationTime
)
{
var
clone
=
createWorkInProgress
(
fiber
pendingProps
expirationTime
)
;
clone
.
index
=
0
;
clone
.
sibling
=
null
;
return
clone
;
}
function
placeChild
(
newFiber
lastPlacedIndex
newIndex
)
{
newFiber
.
index
=
newIndex
;
if
(
!
shouldTrackSideEffects
)
{
return
lastPlacedIndex
;
}
var
current
1
=
newFiber
.
alternate
;
if
(
current
1
!
=
=
null
)
{
var
oldIndex
=
current
1
.
index
;
if
(
oldIndex
<
lastPlacedIndex
)
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
else
{
return
oldIndex
;
}
}
else
{
newFiber
.
effectTag
=
Placement
;
return
lastPlacedIndex
;
}
}
function
placeSingleChild
(
newFiber
)
{
if
(
shouldTrackSideEffects
&
&
newFiber
.
alternate
=
=
=
null
)
{
newFiber
.
effectTag
=
Placement
;
}
return
newFiber
;
}
function
updateTextNode
(
returnFiber
current
1
textContent
expirationTime
)
{
if
(
current
1
=
=
=
null
|
|
current
1
.
tag
!
=
=
HostText
)
{
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
1
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateElement
(
returnFiber
current
1
element
expirationTime
)
{
if
(
current
1
!
=
=
null
&
&
current
1
.
elementType
=
=
=
element
.
type
)
{
var
existing
=
useFiber
(
current
1
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
current
1
element
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
var
created
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
created
.
ref
=
coerceRef
(
returnFiber
current
1
element
)
;
created
.
return
=
returnFiber
;
return
created
;
}
}
function
updatePortal
(
returnFiber
current
1
portal
expirationTime
)
{
if
(
current
1
=
=
=
null
|
|
current
1
.
tag
!
=
=
HostPortal
|
|
current
1
.
stateNode
.
containerInfo
!
=
=
portal
.
containerInfo
|
|
current
1
.
stateNode
.
implementation
!
=
=
portal
.
implementation
)
{
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
1
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
updateFragment
(
returnFiber
current
1
fragment
expirationTime
key
)
{
if
(
current
1
=
=
=
null
|
|
current
1
.
tag
!
=
=
Fragment
)
{
var
created
=
createFiberFromFragment
(
fragment
returnFiber
.
mode
expirationTime
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
existing
=
useFiber
(
current
1
fragment
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
}
function
createChild
(
returnFiber
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
created
=
createFiberFromText
(
'
'
+
newChild
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_created
=
createFiberFromElement
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created
.
ref
=
coerceRef
(
returnFiber
null
newChild
)
;
_created
.
return
=
returnFiber
;
return
_created
;
}
case
REACT_PORTAL_TYPE
:
{
var
_created2
=
createFiberFromPortal
(
newChild
returnFiber
.
mode
expirationTime
)
;
_created2
.
return
=
returnFiber
;
return
_created2
;
}
}
if
(
isArray
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_created3
=
createFiberFromFragment
(
newChild
returnFiber
.
mode
expirationTime
null
)
;
_created3
.
return
=
returnFiber
;
return
_created3
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateSlot
(
returnFiber
oldFiber
newChild
expirationTime
)
{
var
key
=
oldFiber
!
=
=
null
?
oldFiber
.
key
:
null
;
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateTextNode
(
returnFiber
oldFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
oldFiber
newChild
.
props
.
children
expirationTime
key
)
;
}
return
updateElement
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
case
REACT_PORTAL_TYPE
:
{
if
(
newChild
.
key
=
=
=
key
)
{
return
updatePortal
(
returnFiber
oldFiber
newChild
expirationTime
)
;
}
else
{
return
null
;
}
}
}
if
(
isArray
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
if
(
key
!
=
=
null
)
{
return
null
;
}
return
updateFragment
(
returnFiber
oldFiber
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
updateFromMap
(
existingChildren
returnFiber
newIdx
newChild
expirationTime
)
{
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
var
matchedFiber
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateTextNode
(
returnFiber
matchedFiber
'
'
+
newChild
expirationTime
)
;
}
if
(
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
{
var
_matchedFiber
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
if
(
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
return
updateFragment
(
returnFiber
_matchedFiber
newChild
.
props
.
children
expirationTime
newChild
.
key
)
;
}
return
updateElement
(
returnFiber
_matchedFiber
newChild
expirationTime
)
;
}
case
REACT_PORTAL_TYPE
:
{
var
_matchedFiber2
=
existingChildren
.
get
(
newChild
.
key
=
=
=
null
?
newIdx
:
newChild
.
key
)
|
|
null
;
return
updatePortal
(
returnFiber
_matchedFiber2
newChild
expirationTime
)
;
}
}
if
(
isArray
(
newChild
)
|
|
getIteratorFn
(
newChild
)
)
{
var
_matchedFiber3
=
existingChildren
.
get
(
newIdx
)
|
|
null
;
return
updateFragment
(
returnFiber
_matchedFiber3
newChild
expirationTime
null
)
;
}
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
return
null
;
}
function
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChildren
expirationTime
)
{
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
for
(
;
oldFiber
!
=
=
null
&
&
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
oldFiber
=
=
=
null
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
newIdx
=
=
=
newChildren
.
length
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber
=
createChild
(
returnFiber
newChildren
[
newIdx
]
expirationTime
)
;
if
(
!
_newFiber
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber
;
}
previousNewFiber
=
_newFiber
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
newIdx
<
newChildren
.
length
;
newIdx
+
+
)
{
var
_newFiber2
=
updateFromMap
(
existingChildren
returnFiber
newIdx
newChildren
[
newIdx
]
expirationTime
)
;
if
(
_newFiber2
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber2
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber2
.
key
=
=
=
null
?
newIdx
:
_newFiber2
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber2
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber2
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber2
;
}
previousNewFiber
=
_newFiber2
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChildrenIterable
expirationTime
)
{
var
iteratorFn
=
getIteratorFn
(
newChildrenIterable
)
;
!
(
typeof
iteratorFn
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
150
'
)
:
void
0
;
var
newChildren
=
iteratorFn
.
call
(
newChildrenIterable
)
;
!
(
newChildren
!
=
null
)
?
reactProdInvariant
(
'
151
'
)
:
void
0
;
var
resultingFirstChild
=
null
;
var
previousNewFiber
=
null
;
var
oldFiber
=
currentFirstChild
;
var
lastPlacedIndex
=
0
;
var
newIdx
=
0
;
var
nextOldFiber
=
null
;
var
step
=
newChildren
.
next
(
)
;
for
(
;
oldFiber
!
=
=
null
&
&
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
if
(
oldFiber
.
index
>
newIdx
)
{
nextOldFiber
=
oldFiber
;
oldFiber
=
null
;
}
else
{
nextOldFiber
=
oldFiber
.
sibling
;
}
var
newFiber
=
updateSlot
(
returnFiber
oldFiber
step
.
value
expirationTime
)
;
if
(
newFiber
=
=
=
null
)
{
if
(
!
oldFiber
)
{
oldFiber
=
nextOldFiber
;
}
break
;
}
if
(
shouldTrackSideEffects
)
{
if
(
oldFiber
&
&
newFiber
.
alternate
=
=
=
null
)
{
deleteChild
(
returnFiber
oldFiber
)
;
}
}
lastPlacedIndex
=
placeChild
(
newFiber
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
newFiber
;
}
else
{
previousNewFiber
.
sibling
=
newFiber
;
}
previousNewFiber
=
newFiber
;
oldFiber
=
nextOldFiber
;
}
if
(
step
.
done
)
{
deleteRemainingChildren
(
returnFiber
oldFiber
)
;
return
resultingFirstChild
;
}
if
(
oldFiber
=
=
=
null
)
{
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber3
=
createChild
(
returnFiber
step
.
value
expirationTime
)
;
if
(
_newFiber3
=
=
=
null
)
{
continue
;
}
lastPlacedIndex
=
placeChild
(
_newFiber3
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber3
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber3
;
}
previousNewFiber
=
_newFiber3
;
}
return
resultingFirstChild
;
}
var
existingChildren
=
mapRemainingChildren
(
returnFiber
oldFiber
)
;
for
(
;
!
step
.
done
;
newIdx
+
+
step
=
newChildren
.
next
(
)
)
{
var
_newFiber4
=
updateFromMap
(
existingChildren
returnFiber
newIdx
step
.
value
expirationTime
)
;
if
(
_newFiber4
!
=
=
null
)
{
if
(
shouldTrackSideEffects
)
{
if
(
_newFiber4
.
alternate
!
=
=
null
)
{
existingChildren
.
delete
(
_newFiber4
.
key
=
=
=
null
?
newIdx
:
_newFiber4
.
key
)
;
}
}
lastPlacedIndex
=
placeChild
(
_newFiber4
lastPlacedIndex
newIdx
)
;
if
(
previousNewFiber
=
=
=
null
)
{
resultingFirstChild
=
_newFiber4
;
}
else
{
previousNewFiber
.
sibling
=
_newFiber4
;
}
previousNewFiber
=
_newFiber4
;
}
}
if
(
shouldTrackSideEffects
)
{
existingChildren
.
forEach
(
function
(
child
)
{
return
deleteChild
(
returnFiber
child
)
;
}
)
;
}
return
resultingFirstChild
;
}
function
reconcileSingleTextNode
(
returnFiber
currentFirstChild
textContent
expirationTime
)
{
if
(
currentFirstChild
!
=
=
null
&
&
currentFirstChild
.
tag
=
=
=
HostText
)
{
deleteRemainingChildren
(
returnFiber
currentFirstChild
.
sibling
)
;
var
existing
=
useFiber
(
currentFirstChild
textContent
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
var
created
=
createFiberFromText
(
textContent
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileSingleElement
(
returnFiber
currentFirstChild
element
expirationTime
)
{
var
key
=
element
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
Fragment
?
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
:
child
.
elementType
=
=
=
element
.
type
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
?
element
.
props
.
children
:
element
.
props
expirationTime
)
;
existing
.
ref
=
coerceRef
(
returnFiber
child
element
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
if
(
element
.
type
=
=
=
REACT_FRAGMENT_TYPE
)
{
var
created
=
createFiberFromFragment
(
element
.
props
.
children
returnFiber
.
mode
expirationTime
element
.
key
)
;
created
.
return
=
returnFiber
;
return
created
;
}
else
{
var
_created4
=
createFiberFromElement
(
element
returnFiber
.
mode
expirationTime
)
;
_created4
.
ref
=
coerceRef
(
returnFiber
currentFirstChild
element
)
;
_created4
.
return
=
returnFiber
;
return
_created4
;
}
}
function
reconcileSinglePortal
(
returnFiber
currentFirstChild
portal
expirationTime
)
{
var
key
=
portal
.
key
;
var
child
=
currentFirstChild
;
while
(
child
!
=
=
null
)
{
if
(
child
.
key
=
=
=
key
)
{
if
(
child
.
tag
=
=
=
HostPortal
&
&
child
.
stateNode
.
containerInfo
=
=
=
portal
.
containerInfo
&
&
child
.
stateNode
.
implementation
=
=
=
portal
.
implementation
)
{
deleteRemainingChildren
(
returnFiber
child
.
sibling
)
;
var
existing
=
useFiber
(
child
portal
.
children
|
|
[
]
expirationTime
)
;
existing
.
return
=
returnFiber
;
return
existing
;
}
else
{
deleteRemainingChildren
(
returnFiber
child
)
;
break
;
}
}
else
{
deleteChild
(
returnFiber
child
)
;
}
child
=
child
.
sibling
;
}
var
created
=
createFiberFromPortal
(
portal
returnFiber
.
mode
expirationTime
)
;
created
.
return
=
returnFiber
;
return
created
;
}
function
reconcileChildFibers
(
returnFiber
currentFirstChild
newChild
expirationTime
)
{
var
isUnkeyedTopLevelFragment
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
&
&
newChild
.
type
=
=
=
REACT_FRAGMENT_TYPE
&
&
newChild
.
key
=
=
=
null
;
if
(
isUnkeyedTopLevelFragment
)
{
newChild
=
newChild
.
props
.
children
;
}
var
isObject
=
typeof
newChild
=
=
=
'
object
'
&
&
newChild
!
=
=
null
;
if
(
isObject
)
{
switch
(
newChild
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
return
placeSingleChild
(
reconcileSingleElement
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
case
REACT_PORTAL_TYPE
:
return
placeSingleChild
(
reconcileSinglePortal
(
returnFiber
currentFirstChild
newChild
expirationTime
)
)
;
}
}
if
(
typeof
newChild
=
=
=
'
string
'
|
|
typeof
newChild
=
=
=
'
number
'
)
{
return
placeSingleChild
(
reconcileSingleTextNode
(
returnFiber
currentFirstChild
'
'
+
newChild
expirationTime
)
)
;
}
if
(
isArray
(
newChild
)
)
{
return
reconcileChildrenArray
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
getIteratorFn
(
newChild
)
)
{
return
reconcileChildrenIterator
(
returnFiber
currentFirstChild
newChild
expirationTime
)
;
}
if
(
isObject
)
{
throwOnInvalidObjectType
(
returnFiber
newChild
)
;
}
if
(
typeof
newChild
=
=
=
'
undefined
'
&
&
!
isUnkeyedTopLevelFragment
)
{
switch
(
returnFiber
.
tag
)
{
case
ClassComponent
:
{
}
case
FunctionComponent
:
{
var
Component
=
returnFiber
.
type
;
reactProdInvariant
(
'
152
'
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
;
}
}
}
return
deleteRemainingChildren
(
returnFiber
currentFirstChild
)
;
}
return
reconcileChildFibers
;
}
var
reconcileChildFibers
=
ChildReconciler
(
true
)
;
var
mountChildFibers
=
ChildReconciler
(
false
)
;
function
cloneChildFibers
(
current
1
workInProgress
)
{
!
(
current
1
=
=
=
null
|
|
workInProgress
.
child
=
=
=
current
1
.
child
)
?
reactProdInvariant
(
'
153
'
)
:
void
0
;
if
(
workInProgress
.
child
=
=
=
null
)
{
return
;
}
var
currentChild
=
workInProgress
.
child
;
var
newChild
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
workInProgress
.
child
=
newChild
;
newChild
.
return
=
workInProgress
;
while
(
currentChild
.
sibling
!
=
=
null
)
{
currentChild
=
currentChild
.
sibling
;
newChild
=
newChild
.
sibling
=
createWorkInProgress
(
currentChild
currentChild
.
pendingProps
currentChild
.
expirationTime
)
;
newChild
.
return
=
workInProgress
;
}
newChild
.
sibling
=
null
;
}
var
NO_CONTEXT
=
{
}
;
var
contextStackCursor
1
=
createCursor
(
NO_CONTEXT
)
;
var
contextFiberStackCursor
=
createCursor
(
NO_CONTEXT
)
;
var
rootInstanceStackCursor
=
createCursor
(
NO_CONTEXT
)
;
function
requiredContext
(
c
)
{
!
(
c
!
=
=
NO_CONTEXT
)
?
reactProdInvariant
(
'
174
'
)
:
void
0
;
return
c
;
}
function
getRootHostContainer
(
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
return
rootInstance
;
}
function
pushHostContainer
(
fiber
nextRootInstance
)
{
push
(
rootInstanceStackCursor
nextRootInstance
fiber
)
;
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
NO_CONTEXT
fiber
)
;
var
nextRootContext
=
getRootHostContext
(
nextRootInstance
)
;
pop
(
contextStackCursor
1
fiber
)
;
push
(
contextStackCursor
1
nextRootContext
fiber
)
;
}
function
popHostContainer
(
fiber
)
{
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
pop
(
rootInstanceStackCursor
fiber
)
;
}
function
getHostContext
(
)
{
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
return
context
;
}
function
pushHostContext
(
fiber
)
{
var
rootInstance
=
requiredContext
(
rootInstanceStackCursor
.
current
)
;
var
context
=
requiredContext
(
contextStackCursor
1
.
current
)
;
var
nextContext
=
getChildHostContext
(
context
fiber
.
type
rootInstance
)
;
if
(
context
=
=
=
nextContext
)
{
return
;
}
push
(
contextFiberStackCursor
fiber
fiber
)
;
push
(
contextStackCursor
1
nextContext
fiber
)
;
}
function
popHostContext
(
fiber
)
{
if
(
contextFiberStackCursor
.
current
!
=
=
fiber
)
{
return
;
}
pop
(
contextStackCursor
1
fiber
)
;
pop
(
contextFiberStackCursor
fiber
)
;
}
var
NoEffect
1
=
0
;
var
UnmountSnapshot
=
2
;
var
UnmountMutation
=
4
;
var
MountMutation
=
8
;
var
UnmountLayout
=
16
;
var
MountLayout
=
32
;
var
MountPassive
=
64
;
var
UnmountPassive
=
128
;
var
ReactCurrentDispatcher
1
=
ReactSharedInternals
.
ReactCurrentDispatcher
;
var
renderExpirationTime
=
NoWork
;
var
currentlyRenderingFiber
1
=
null
;
var
currentHook
=
null
;
var
nextCurrentHook
=
null
;
var
firstWorkInProgressHook
=
null
;
var
workInProgressHook
=
null
;
var
nextWorkInProgressHook
=
null
;
var
remainingExpirationTime
=
NoWork
;
var
componentUpdateQueue
=
null
;
var
sideEffectTag
=
0
;
var
didScheduleRenderPhaseUpdate
=
false
;
var
renderPhaseUpdates
=
null
;
var
numberOfReRenders
=
0
;
var
RE_RENDER_LIMIT
=
25
;
function
throwInvalidHookError
(
)
{
reactProdInvariant
(
'
321
'
)
;
}
function
areHookInputsEqual
(
nextDeps
prevDeps
)
{
if
(
prevDeps
=
=
=
null
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
prevDeps
.
length
&
&
i
<
nextDeps
.
length
;
i
+
+
)
{
if
(
is
(
nextDeps
[
i
]
prevDeps
[
i
]
)
)
{
continue
;
}
return
false
;
}
return
true
;
}
function
renderWithHooks
(
current
workInProgress
Component
props
refOrContext
nextRenderExpirationTime
)
{
renderExpirationTime
=
nextRenderExpirationTime
;
currentlyRenderingFiber
1
=
workInProgress
;
nextCurrentHook
=
current
!
=
=
null
?
current
.
memoizedState
:
null
;
{
ReactCurrentDispatcher
1
.
current
=
nextCurrentHook
=
=
=
null
?
HooksDispatcherOnMount
:
HooksDispatcherOnUpdate
;
}
var
children
=
Component
(
props
refOrContext
)
;
if
(
didScheduleRenderPhaseUpdate
)
{
do
{
didScheduleRenderPhaseUpdate
=
false
;
numberOfReRenders
+
=
1
;
nextCurrentHook
=
current
!
=
=
null
?
current
.
memoizedState
:
null
;
nextWorkInProgressHook
=
firstWorkInProgressHook
;
currentHook
=
null
;
workInProgressHook
=
null
;
componentUpdateQueue
=
null
;
ReactCurrentDispatcher
1
.
current
=
HooksDispatcherOnUpdate
;
children
=
Component
(
props
refOrContext
)
;
}
while
(
didScheduleRenderPhaseUpdate
)
;
renderPhaseUpdates
=
null
;
numberOfReRenders
=
0
;
}
ReactCurrentDispatcher
1
.
current
=
ContextOnlyDispatcher
;
var
renderedWork
=
currentlyRenderingFiber
1
;
renderedWork
.
memoizedState
=
firstWorkInProgressHook
;
renderedWork
.
expirationTime
=
remainingExpirationTime
;
renderedWork
.
updateQueue
=
componentUpdateQueue
;
renderedWork
.
effectTag
|
=
sideEffectTag
;
var
didRenderTooFewHooks
=
currentHook
!
=
=
null
&
&
currentHook
.
next
!
=
=
null
;
renderExpirationTime
=
NoWork
;
currentlyRenderingFiber
1
=
null
;
currentHook
=
null
;
nextCurrentHook
=
null
;
firstWorkInProgressHook
=
null
;
workInProgressHook
=
null
;
nextWorkInProgressHook
=
null
;
remainingExpirationTime
=
NoWork
;
componentUpdateQueue
=
null
;
sideEffectTag
=
0
;
!
!
didRenderTooFewHooks
?
reactProdInvariant
(
'
300
'
)
:
void
0
;
return
children
;
}
function
bailoutHooks
(
current
workInProgress
expirationTime
)
{
workInProgress
.
updateQueue
=
current
.
updateQueue
;
workInProgress
.
effectTag
&
=
~
(
Passive
|
Update
)
;
if
(
current
.
expirationTime
<
=
expirationTime
)
{
current
.
expirationTime
=
NoWork
;
}
}
function
resetHooks
(
)
{
ReactCurrentDispatcher
1
.
current
=
ContextOnlyDispatcher
;
renderExpirationTime
=
NoWork
;
currentlyRenderingFiber
1
=
null
;
currentHook
=
null
;
nextCurrentHook
=
null
;
firstWorkInProgressHook
=
null
;
workInProgressHook
=
null
;
nextWorkInProgressHook
=
null
;
remainingExpirationTime
=
NoWork
;
componentUpdateQueue
=
null
;
sideEffectTag
=
0
;
didScheduleRenderPhaseUpdate
=
false
;
renderPhaseUpdates
=
null
;
numberOfReRenders
=
0
;
}
function
mountWorkInProgressHook
(
)
{
var
hook
=
{
memoizedState
:
null
baseState
:
null
queue
:
null
baseUpdate
:
null
next
:
null
}
;
if
(
workInProgressHook
=
=
=
null
)
{
firstWorkInProgressHook
=
workInProgressHook
=
hook
;
}
else
{
workInProgressHook
=
workInProgressHook
.
next
=
hook
;
}
return
workInProgressHook
;
}
function
updateWorkInProgressHook
(
)
{
if
(
nextWorkInProgressHook
!
=
=
null
)
{
workInProgressHook
=
nextWorkInProgressHook
;
nextWorkInProgressHook
=
workInProgressHook
.
next
;
currentHook
=
nextCurrentHook
;
nextCurrentHook
=
currentHook
!
=
=
null
?
currentHook
.
next
:
null
;
}
else
{
!
(
nextCurrentHook
!
=
=
null
)
?
reactProdInvariant
(
'
310
'
)
:
void
0
;
currentHook
=
nextCurrentHook
;
var
newHook
=
{
memoizedState
:
currentHook
.
memoizedState
baseState
:
currentHook
.
baseState
queue
:
currentHook
.
queue
baseUpdate
:
currentHook
.
baseUpdate
next
:
null
}
;
if
(
workInProgressHook
=
=
=
null
)
{
workInProgressHook
=
firstWorkInProgressHook
=
newHook
;
}
else
{
workInProgressHook
=
workInProgressHook
.
next
=
newHook
;
}
nextCurrentHook
=
currentHook
.
next
;
}
return
workInProgressHook
;
}
function
createFunctionComponentUpdateQueue
(
)
{
return
{
lastEffect
:
null
}
;
}
function
basicStateReducer
(
state
action
)
{
return
typeof
action
=
=
=
'
function
'
?
action
(
state
)
:
action
;
}
function
mountReducer
(
reducer
initialArg
init
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
initialState
=
void
0
;
if
(
init
!
=
=
undefined
)
{
initialState
=
init
(
initialArg
)
;
}
else
{
initialState
=
initialArg
;
}
hook
.
memoizedState
=
hook
.
baseState
=
initialState
;
var
queue
=
hook
.
queue
=
{
last
:
null
dispatch
:
null
lastRenderedReducer
:
reducer
lastRenderedState
:
initialState
}
;
var
dispatch
=
queue
.
dispatch
=
dispatchAction
.
bind
(
null
currentlyRenderingFiber
1
queue
)
;
return
[
hook
.
memoizedState
dispatch
]
;
}
function
updateReducer
(
reducer
initialArg
init
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
queue
=
hook
.
queue
;
!
(
queue
!
=
=
null
)
?
reactProdInvariant
(
'
311
'
)
:
void
0
;
queue
.
lastRenderedReducer
=
reducer
;
if
(
numberOfReRenders
>
0
)
{
var
_dispatch
=
queue
.
dispatch
;
if
(
renderPhaseUpdates
!
=
=
null
)
{
var
firstRenderPhaseUpdate
=
renderPhaseUpdates
.
get
(
queue
)
;
if
(
firstRenderPhaseUpdate
!
=
=
undefined
)
{
renderPhaseUpdates
.
delete
(
queue
)
;
var
newState
=
hook
.
memoizedState
;
var
update
=
firstRenderPhaseUpdate
;
do
{
var
_action
=
update
.
action
;
newState
=
reducer
(
newState
_action
)
;
update
=
update
.
next
;
}
while
(
update
!
=
=
null
)
;
if
(
!
is
(
newState
hook
.
memoizedState
)
)
{
markWorkInProgressReceivedUpdate
(
)
;
}
hook
.
memoizedState
=
newState
;
if
(
hook
.
baseUpdate
=
=
=
queue
.
last
)
{
hook
.
baseState
=
newState
;
}
queue
.
lastRenderedState
=
newState
;
return
[
newState
_dispatch
]
;
}
}
return
[
hook
.
memoizedState
_dispatch
]
;
}
var
last
=
queue
.
last
;
var
baseUpdate
=
hook
.
baseUpdate
;
var
baseState
=
hook
.
baseState
;
var
first
=
void
0
;
if
(
baseUpdate
!
=
=
null
)
{
if
(
last
!
=
=
null
)
{
last
.
next
=
null
;
}
first
=
baseUpdate
.
next
;
}
else
{
first
=
last
!
=
=
null
?
last
.
next
:
null
;
}
if
(
first
!
=
=
null
)
{
var
_newState
=
baseState
;
var
newBaseState
=
null
;
var
newBaseUpdate
=
null
;
var
prevUpdate
=
baseUpdate
;
var
_update
=
first
;
var
didSkip
=
false
;
do
{
var
updateExpirationTime
=
_update
.
expirationTime
;
if
(
updateExpirationTime
<
renderExpirationTime
)
{
if
(
!
didSkip
)
{
didSkip
=
true
;
newBaseUpdate
=
prevUpdate
;
newBaseState
=
_newState
;
}
if
(
updateExpirationTime
>
remainingExpirationTime
)
{
remainingExpirationTime
=
updateExpirationTime
;
}
}
else
{
if
(
_update
.
eagerReducer
=
=
=
reducer
)
{
_newState
=
_update
.
eagerState
;
}
else
{
var
_action2
=
_update
.
action
;
_newState
=
reducer
(
_newState
_action2
)
;
}
}
prevUpdate
=
_update
;
_update
=
_update
.
next
;
}
while
(
_update
!
=
=
null
&
&
_update
!
=
=
first
)
;
if
(
!
didSkip
)
{
newBaseUpdate
=
prevUpdate
;
newBaseState
=
_newState
;
}
if
(
!
is
(
_newState
hook
.
memoizedState
)
)
{
markWorkInProgressReceivedUpdate
(
)
;
}
hook
.
memoizedState
=
_newState
;
hook
.
baseUpdate
=
newBaseUpdate
;
hook
.
baseState
=
newBaseState
;
queue
.
lastRenderedState
=
_newState
;
}
var
dispatch
=
queue
.
dispatch
;
return
[
hook
.
memoizedState
dispatch
]
;
}
function
mountState
(
initialState
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
if
(
typeof
initialState
=
=
=
'
function
'
)
{
initialState
=
initialState
(
)
;
}
hook
.
memoizedState
=
hook
.
baseState
=
initialState
;
var
queue
=
hook
.
queue
=
{
last
:
null
dispatch
:
null
lastRenderedReducer
:
basicStateReducer
lastRenderedState
:
initialState
}
;
var
dispatch
=
queue
.
dispatch
=
dispatchAction
.
bind
(
null
currentlyRenderingFiber
1
queue
)
;
return
[
hook
.
memoizedState
dispatch
]
;
}
function
updateState
(
initialState
)
{
return
updateReducer
(
basicStateReducer
initialState
)
;
}
function
pushEffect
(
tag
create
destroy
deps
)
{
var
effect
=
{
tag
:
tag
create
:
create
destroy
:
destroy
deps
:
deps
next
:
null
}
;
if
(
componentUpdateQueue
=
=
=
null
)
{
componentUpdateQueue
=
createFunctionComponentUpdateQueue
(
)
;
componentUpdateQueue
.
lastEffect
=
effect
.
next
=
effect
;
}
else
{
var
_lastEffect
=
componentUpdateQueue
.
lastEffect
;
if
(
_lastEffect
=
=
=
null
)
{
componentUpdateQueue
.
lastEffect
=
effect
.
next
=
effect
;
}
else
{
var
firstEffect
=
_lastEffect
.
next
;
_lastEffect
.
next
=
effect
;
effect
.
next
=
firstEffect
;
componentUpdateQueue
.
lastEffect
=
effect
;
}
}
return
effect
;
}
function
mountRef
(
initialValue
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
ref
=
{
current
:
initialValue
}
;
hook
.
memoizedState
=
ref
;
return
ref
;
}
function
updateRef
(
initialValue
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
return
hook
.
memoizedState
;
}
function
mountEffectImpl
(
fiberEffectTag
hookEffectTag
create
deps
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
sideEffectTag
|
=
fiberEffectTag
;
hook
.
memoizedState
=
pushEffect
(
hookEffectTag
create
undefined
nextDeps
)
;
}
function
updateEffectImpl
(
fiberEffectTag
hookEffectTag
create
deps
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
destroy
=
undefined
;
if
(
currentHook
!
=
=
null
)
{
var
prevEffect
=
currentHook
.
memoizedState
;
destroy
=
prevEffect
.
destroy
;
if
(
nextDeps
!
=
=
null
)
{
var
prevDeps
=
prevEffect
.
deps
;
if
(
areHookInputsEqual
(
nextDeps
prevDeps
)
)
{
pushEffect
(
NoEffect
1
create
destroy
nextDeps
)
;
return
;
}
}
}
sideEffectTag
|
=
fiberEffectTag
;
hook
.
memoizedState
=
pushEffect
(
hookEffectTag
create
destroy
nextDeps
)
;
}
function
mountEffect
(
create
deps
)
{
return
mountEffectImpl
(
Update
|
Passive
UnmountPassive
|
MountPassive
create
deps
)
;
}
function
updateEffect
(
create
deps
)
{
return
updateEffectImpl
(
Update
|
Passive
UnmountPassive
|
MountPassive
create
deps
)
;
}
function
mountLayoutEffect
(
create
deps
)
{
return
mountEffectImpl
(
Update
UnmountMutation
|
MountLayout
create
deps
)
;
}
function
updateLayoutEffect
(
create
deps
)
{
return
updateEffectImpl
(
Update
UnmountMutation
|
MountLayout
create
deps
)
;
}
function
imperativeHandleEffect
(
create
ref
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
var
refCallback
=
ref
;
var
_inst
=
create
(
)
;
refCallback
(
_inst
)
;
return
function
(
)
{
refCallback
(
null
)
;
}
;
}
else
if
(
ref
!
=
=
null
&
&
ref
!
=
=
undefined
)
{
var
refObject
=
ref
;
var
_inst2
=
create
(
)
;
refObject
.
current
=
_inst2
;
return
function
(
)
{
refObject
.
current
=
null
;
}
;
}
}
function
mountImperativeHandle
(
ref
create
deps
)
{
var
effectDeps
=
deps
!
=
=
null
&
&
deps
!
=
=
undefined
?
deps
.
concat
(
[
ref
]
)
:
null
;
return
mountEffectImpl
(
Update
UnmountMutation
|
MountLayout
imperativeHandleEffect
.
bind
(
null
create
ref
)
effectDeps
)
;
}
function
updateImperativeHandle
(
ref
create
deps
)
{
var
effectDeps
=
deps
!
=
=
null
&
&
deps
!
=
=
undefined
?
deps
.
concat
(
[
ref
]
)
:
null
;
return
updateEffectImpl
(
Update
UnmountMutation
|
MountLayout
imperativeHandleEffect
.
bind
(
null
create
ref
)
effectDeps
)
;
}
function
mountDebugValue
(
value
formatterFn
)
{
}
var
updateDebugValue
=
mountDebugValue
;
function
mountCallback
(
callback
deps
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
hook
.
memoizedState
=
[
callback
nextDeps
]
;
return
callback
;
}
function
updateCallback
(
callback
deps
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
prevState
=
hook
.
memoizedState
;
if
(
prevState
!
=
=
null
)
{
if
(
nextDeps
!
=
=
null
)
{
var
prevDeps
=
prevState
[
1
]
;
if
(
areHookInputsEqual
(
nextDeps
prevDeps
)
)
{
return
prevState
[
0
]
;
}
}
}
hook
.
memoizedState
=
[
callback
nextDeps
]
;
return
callback
;
}
function
mountMemo
(
nextCreate
deps
)
{
var
hook
=
mountWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
nextValue
=
nextCreate
(
)
;
hook
.
memoizedState
=
[
nextValue
nextDeps
]
;
return
nextValue
;
}
function
updateMemo
(
nextCreate
deps
)
{
var
hook
=
updateWorkInProgressHook
(
)
;
var
nextDeps
=
deps
=
=
=
undefined
?
null
:
deps
;
var
prevState
=
hook
.
memoizedState
;
if
(
prevState
!
=
=
null
)
{
if
(
nextDeps
!
=
=
null
)
{
var
prevDeps
=
prevState
[
1
]
;
if
(
areHookInputsEqual
(
nextDeps
prevDeps
)
)
{
return
prevState
[
0
]
;
}
}
}
var
nextValue
=
nextCreate
(
)
;
hook
.
memoizedState
=
[
nextValue
nextDeps
]
;
return
nextValue
;
}
function
dispatchAction
(
fiber
queue
action
)
{
!
(
numberOfReRenders
<
RE_RENDER_LIMIT
)
?
reactProdInvariant
(
'
301
'
)
:
void
0
;
var
alternate
=
fiber
.
alternate
;
if
(
fiber
=
=
=
currentlyRenderingFiber
1
|
|
alternate
!
=
=
null
&
&
alternate
=
=
=
currentlyRenderingFiber
1
)
{
didScheduleRenderPhaseUpdate
=
true
;
var
update
=
{
expirationTime
:
renderExpirationTime
action
:
action
eagerReducer
:
null
eagerState
:
null
next
:
null
}
;
if
(
renderPhaseUpdates
=
=
=
null
)
{
renderPhaseUpdates
=
new
Map
(
)
;
}
var
firstRenderPhaseUpdate
=
renderPhaseUpdates
.
get
(
queue
)
;
if
(
firstRenderPhaseUpdate
=
=
=
undefined
)
{
renderPhaseUpdates
.
set
(
queue
update
)
;
}
else
{
var
lastRenderPhaseUpdate
=
firstRenderPhaseUpdate
;
while
(
lastRenderPhaseUpdate
.
next
!
=
=
null
)
{
lastRenderPhaseUpdate
=
lastRenderPhaseUpdate
.
next
;
}
lastRenderPhaseUpdate
.
next
=
update
;
}
}
else
{
flushPassiveEffects
(
)
;
var
currentTime
=
requestCurrentTime
(
)
;
var
_expirationTime
=
computeExpirationForFiber
(
currentTime
fiber
)
;
var
_update2
=
{
expirationTime
:
_expirationTime
action
:
action
eagerReducer
:
null
eagerState
:
null
next
:
null
}
;
var
_last
=
queue
.
last
;
if
(
_last
=
=
=
null
)
{
_update2
.
next
=
_update2
;
}
else
{
var
first
=
_last
.
next
;
if
(
first
!
=
=
null
)
{
_update2
.
next
=
first
;
}
_last
.
next
=
_update2
;
}
queue
.
last
=
_update2
;
if
(
fiber
.
expirationTime
=
=
=
NoWork
&
&
(
alternate
=
=
=
null
|
|
alternate
.
expirationTime
=
=
=
NoWork
)
)
{
var
_lastRenderedReducer
=
queue
.
lastRenderedReducer
;
if
(
_lastRenderedReducer
!
=
=
null
)
{
try
{
var
currentState
=
queue
.
lastRenderedState
;
var
_eagerState
=
_lastRenderedReducer
(
currentState
action
)
;
_update2
.
eagerReducer
=
_lastRenderedReducer
;
_update2
.
eagerState
=
_eagerState
;
if
(
is
(
_eagerState
currentState
)
)
{
return
;
}
}
catch
(
error
)
{
}
finally
{
}
}
}
scheduleWork
(
fiber
_expirationTime
)
;
}
}
var
ContextOnlyDispatcher
=
{
readContext
:
readContext
useCallback
:
throwInvalidHookError
useContext
:
throwInvalidHookError
useEffect
:
throwInvalidHookError
useImperativeHandle
:
throwInvalidHookError
useLayoutEffect
:
throwInvalidHookError
useMemo
:
throwInvalidHookError
useReducer
:
throwInvalidHookError
useRef
:
throwInvalidHookError
useState
:
throwInvalidHookError
useDebugValue
:
throwInvalidHookError
}
;
var
HooksDispatcherOnMount
=
{
readContext
:
readContext
useCallback
:
mountCallback
useContext
:
readContext
useEffect
:
mountEffect
useImperativeHandle
:
mountImperativeHandle
useLayoutEffect
:
mountLayoutEffect
useMemo
:
mountMemo
useReducer
:
mountReducer
useRef
:
mountRef
useState
:
mountState
useDebugValue
:
mountDebugValue
}
;
var
HooksDispatcherOnUpdate
=
{
readContext
:
readContext
useCallback
:
updateCallback
useContext
:
readContext
useEffect
:
updateEffect
useImperativeHandle
:
updateImperativeHandle
useLayoutEffect
:
updateLayoutEffect
useMemo
:
updateMemo
useReducer
:
updateReducer
useRef
:
updateRef
useState
:
updateState
useDebugValue
:
updateDebugValue
}
;
var
commitTime
=
0
;
var
profilerStartTime
=
-
1
;
function
getCommitTime
(
)
{
return
commitTime
;
}
function
recordCommitTime
(
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
commitTime
=
unstable_now
(
)
;
}
function
startProfilerTimer
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
profilerStartTime
=
unstable_now
(
)
;
if
(
fiber
.
actualStartTime
<
0
)
{
fiber
.
actualStartTime
=
unstable_now
(
)
;
}
}
function
stopProfilerTimerIfRunning
(
fiber
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
profilerStartTime
=
-
1
;
}
function
stopProfilerTimerIfRunningAndRecordDelta
(
fiber
overrideBaseTime
)
{
if
(
!
enableProfilerTimer
)
{
return
;
}
if
(
profilerStartTime
>
=
0
)
{
var
elapsedTime
=
unstable_now
(
)
-
profilerStartTime
;
fiber
.
actualDuration
+
=
elapsedTime
;
if
(
overrideBaseTime
)
{
fiber
.
selfBaseDuration
=
elapsedTime
;
}
profilerStartTime
=
-
1
;
}
}
var
hydrationParentFiber
=
null
;
var
nextHydratableInstance
=
null
;
var
isHydrating
=
false
;
function
enterHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
var
parentInstance
=
fiber
.
stateNode
.
containerInfo
;
nextHydratableInstance
=
getFirstHydratableChild
(
parentInstance
)
;
hydrationParentFiber
=
fiber
;
isHydrating
=
true
;
return
true
;
}
function
reenterHydrationStateFromDehydratedSuspenseInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
var
suspenseInstance
=
fiber
.
stateNode
;
nextHydratableInstance
=
getNextHydratableSibling
(
suspenseInstance
)
;
popToNextHostParent
(
fiber
)
;
isHydrating
=
true
;
return
true
;
}
function
deleteHydratableInstance
(
returnFiber
instance
)
{
var
childToDelete
=
createFiberFromHostInstanceForDeletion
(
)
;
childToDelete
.
stateNode
=
instance
;
childToDelete
.
return
=
returnFiber
;
childToDelete
.
effectTag
=
Deletion
;
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
childToDelete
;
returnFiber
.
lastEffect
=
childToDelete
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
childToDelete
;
}
}
function
insertNonHydratedInstance
(
returnFiber
fiber
)
{
fiber
.
effectTag
|
=
Placement
;
}
function
tryHydrate
(
fiber
nextInstance
)
{
switch
(
fiber
.
tag
)
{
case
HostComponent
:
{
var
type
=
fiber
.
type
;
var
props
=
fiber
.
pendingProps
;
var
instance
=
canHydrateInstance
(
nextInstance
type
props
)
;
if
(
instance
!
=
=
null
)
{
fiber
.
stateNode
=
instance
;
return
true
;
}
return
false
;
}
case
HostText
:
{
var
text
=
fiber
.
pendingProps
;
var
textInstance
=
canHydrateTextInstance
(
nextInstance
text
)
;
if
(
textInstance
!
=
=
null
)
{
fiber
.
stateNode
=
textInstance
;
return
true
;
}
return
false
;
}
case
SuspenseComponent
:
{
if
(
enableSuspenseServerRenderer
)
{
var
suspenseInstance
=
canHydrateSuspenseInstance
(
nextInstance
)
;
if
(
suspenseInstance
!
=
=
null
)
{
fiber
.
tag
=
DehydratedSuspenseComponent
;
fiber
.
stateNode
=
suspenseInstance
;
return
true
;
}
}
return
false
;
}
default
:
return
false
;
}
}
function
tryToClaimNextHydratableInstance
(
fiber
)
{
if
(
!
isHydrating
)
{
return
;
}
var
nextInstance
=
nextHydratableInstance
;
if
(
!
nextInstance
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
var
firstAttemptedInstance
=
nextInstance
;
if
(
!
tryHydrate
(
fiber
nextInstance
)
)
{
nextInstance
=
getNextHydratableSibling
(
firstAttemptedInstance
)
;
if
(
!
nextInstance
|
|
!
tryHydrate
(
fiber
nextInstance
)
)
{
insertNonHydratedInstance
(
hydrationParentFiber
fiber
)
;
isHydrating
=
false
;
hydrationParentFiber
=
fiber
;
return
;
}
deleteHydratableInstance
(
hydrationParentFiber
firstAttemptedInstance
)
;
}
hydrationParentFiber
=
fiber
;
nextHydratableInstance
=
getFirstHydratableChild
(
nextInstance
)
;
}
function
prepareToHydrateHostInstance
(
fiber
rootContainerInstance
hostContext
)
{
if
(
!
supportsHydration
)
{
reactProdInvariant
(
'
175
'
)
;
}
var
instance
=
fiber
.
stateNode
;
var
updatePayload
=
hydrateInstance
(
instance
fiber
.
type
fiber
.
memoizedProps
rootContainerInstance
hostContext
fiber
)
;
fiber
.
updateQueue
=
updatePayload
;
if
(
updatePayload
!
=
=
null
)
{
return
true
;
}
return
false
;
}
function
prepareToHydrateHostTextInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
reactProdInvariant
(
'
176
'
)
;
}
var
textInstance
=
fiber
.
stateNode
;
var
textContent
=
fiber
.
memoizedProps
;
var
shouldUpdate
=
hydrateTextInstance
(
textInstance
textContent
fiber
)
;
return
shouldUpdate
;
}
function
skipPastDehydratedSuspenseInstance
(
fiber
)
{
if
(
!
supportsHydration
)
{
reactProdInvariant
(
'
316
'
)
;
}
var
suspenseInstance
=
fiber
.
stateNode
;
!
suspenseInstance
?
reactProdInvariant
(
'
317
'
)
:
void
0
;
nextHydratableInstance
=
getNextHydratableInstanceAfterSuspenseInstance
(
suspenseInstance
)
;
}
function
popToNextHostParent
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
&
&
parent
.
tag
!
=
=
HostComponent
&
&
parent
.
tag
!
=
=
HostRoot
&
&
parent
.
tag
!
=
=
DehydratedSuspenseComponent
)
{
parent
=
parent
.
return
;
}
hydrationParentFiber
=
parent
;
}
function
popHydrationState
(
fiber
)
{
if
(
!
supportsHydration
)
{
return
false
;
}
if
(
fiber
!
=
=
hydrationParentFiber
)
{
return
false
;
}
if
(
!
isHydrating
)
{
popToNextHostParent
(
fiber
)
;
isHydrating
=
true
;
return
false
;
}
var
type
=
fiber
.
type
;
if
(
fiber
.
tag
!
=
=
HostComponent
|
|
type
!
=
=
'
head
'
&
&
type
!
=
=
'
body
'
&
&
!
shouldSetTextContent
(
type
fiber
.
memoizedProps
)
)
{
var
nextInstance
=
nextHydratableInstance
;
while
(
nextInstance
)
{
deleteHydratableInstance
(
fiber
nextInstance
)
;
nextInstance
=
getNextHydratableSibling
(
nextInstance
)
;
}
}
popToNextHostParent
(
fiber
)
;
nextHydratableInstance
=
hydrationParentFiber
?
getNextHydratableSibling
(
fiber
.
stateNode
)
:
null
;
return
true
;
}
function
resetHydrationState
(
)
{
if
(
!
supportsHydration
)
{
return
;
}
hydrationParentFiber
=
null
;
nextHydratableInstance
=
null
;
isHydrating
=
false
;
}
var
ReactCurrentOwner
3
=
ReactSharedInternals
.
ReactCurrentOwner
;
var
didReceiveUpdate
=
false
;
function
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
{
if
(
current
1
=
=
=
null
)
{
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
current
1
.
child
nextChildren
renderExpirationTime
)
;
}
}
function
forceUnmountCurrentAndReconcile
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
current
1
.
child
null
renderExpirationTime
)
;
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
function
updateForwardRef
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
{
var
render
=
Component
.
render
;
var
ref
=
workInProgress
.
ref
;
var
nextChildren
=
void
0
;
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
{
nextChildren
=
renderWithHooks
(
current
1
workInProgress
render
nextProps
ref
renderExpirationTime
)
;
}
if
(
current
1
!
=
=
null
&
&
!
didReceiveUpdate
)
{
bailoutHooks
(
current
1
workInProgress
renderExpirationTime
)
;
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateMemoComponent
(
current
1
workInProgress
Component
nextProps
updateExpirationTime
renderExpirationTime
)
{
if
(
current
1
=
=
=
null
)
{
var
type
=
Component
.
type
;
if
(
isSimpleFunctionComponent
(
type
)
&
&
Component
.
compare
=
=
=
null
&
&
Component
.
defaultProps
=
=
=
undefined
)
{
workInProgress
.
tag
=
SimpleMemoComponent
;
workInProgress
.
type
=
type
;
return
updateSimpleMemoComponent
(
current
1
workInProgress
type
nextProps
updateExpirationTime
renderExpirationTime
)
;
}
var
child
=
createFiberFromTypeAndProps
(
Component
.
type
null
nextProps
null
workInProgress
.
mode
renderExpirationTime
)
;
child
.
ref
=
workInProgress
.
ref
;
child
.
return
=
workInProgress
;
workInProgress
.
child
=
child
;
return
child
;
}
var
currentChild
=
current
1
.
child
;
if
(
updateExpirationTime
<
renderExpirationTime
)
{
var
prevProps
=
currentChild
.
memoizedProps
;
var
compare
=
Component
.
compare
;
compare
=
compare
!
=
=
null
?
compare
:
shallowEqual
;
if
(
compare
(
prevProps
nextProps
)
&
&
current
1
.
ref
=
=
=
workInProgress
.
ref
)
{
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
}
workInProgress
.
effectTag
|
=
PerformedWork
;
var
newChild
=
createWorkInProgress
(
currentChild
nextProps
renderExpirationTime
)
;
newChild
.
ref
=
workInProgress
.
ref
;
newChild
.
return
=
workInProgress
;
workInProgress
.
child
=
newChild
;
return
newChild
;
}
function
updateSimpleMemoComponent
(
current
1
workInProgress
Component
nextProps
updateExpirationTime
renderExpirationTime
)
{
if
(
current
1
!
=
=
null
)
{
var
prevProps
=
current
1
.
memoizedProps
;
if
(
shallowEqual
(
prevProps
nextProps
)
&
&
current
1
.
ref
=
=
=
workInProgress
.
ref
)
{
didReceiveUpdate
=
false
;
if
(
updateExpirationTime
<
renderExpirationTime
)
{
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
}
}
return
updateFunctionComponent
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
;
}
function
updateFragment
(
current
1
workInProgress
renderExpirationTime
)
{
var
nextChildren
=
workInProgress
.
pendingProps
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateMode
(
current
1
workInProgress
renderExpirationTime
)
{
var
nextChildren
=
workInProgress
.
pendingProps
.
children
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateProfiler
(
current
1
workInProgress
renderExpirationTime
)
{
if
(
enableProfilerTimer
)
{
workInProgress
.
effectTag
|
=
Update
;
}
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextChildren
=
nextProps
.
children
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
markRef
(
current
1
workInProgress
)
{
var
ref
=
workInProgress
.
ref
;
if
(
current
1
=
=
=
null
&
&
ref
!
=
=
null
|
|
current
1
!
=
=
null
&
&
current
1
.
ref
!
=
=
ref
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
}
function
updateFunctionComponent
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
{
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
Component
true
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
var
nextChildren
=
void
0
;
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
{
nextChildren
=
renderWithHooks
(
current
1
workInProgress
Component
nextProps
context
renderExpirationTime
)
;
}
if
(
current
1
!
=
=
null
&
&
!
didReceiveUpdate
)
{
bailoutHooks
(
current
1
workInProgress
renderExpirationTime
)
;
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateClassComponent
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
{
var
hasContext
=
void
0
;
if
(
isContextProvider
(
Component
)
)
{
hasContext
=
true
;
pushContextProvider
(
workInProgress
)
;
}
else
{
hasContext
=
false
;
}
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
var
instance
=
workInProgress
.
stateNode
;
var
shouldUpdate
=
void
0
;
if
(
instance
=
=
=
null
)
{
if
(
current
1
!
=
=
null
)
{
current
1
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
constructClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
mountClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
shouldUpdate
=
true
;
}
else
if
(
current
1
=
=
=
null
)
{
shouldUpdate
=
resumeMountClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
}
else
{
shouldUpdate
=
updateClassInstance
(
current
1
workInProgress
Component
nextProps
renderExpirationTime
)
;
}
var
nextUnitOfWork
=
finishClassComponent
(
current
1
workInProgress
Component
shouldUpdate
hasContext
renderExpirationTime
)
;
return
nextUnitOfWork
;
}
function
finishClassComponent
(
current
1
workInProgress
Component
shouldUpdate
hasContext
renderExpirationTime
)
{
markRef
(
current
1
workInProgress
)
;
var
didCaptureError
=
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
;
if
(
!
shouldUpdate
&
&
!
didCaptureError
)
{
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
Component
false
)
;
}
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
var
instance
=
workInProgress
.
stateNode
;
ReactCurrentOwner
3
.
current
=
workInProgress
;
var
nextChildren
=
void
0
;
if
(
didCaptureError
&
&
typeof
Component
.
getDerivedStateFromError
!
=
=
'
function
'
)
{
nextChildren
=
null
;
if
(
enableProfilerTimer
)
{
stopProfilerTimerIfRunning
(
workInProgress
)
;
}
}
else
{
{
nextChildren
=
instance
.
render
(
)
;
}
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
current
1
!
=
=
null
&
&
didCaptureError
)
{
forceUnmountCurrentAndReconcile
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
}
else
{
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
}
workInProgress
.
memoizedState
=
instance
.
state
;
if
(
hasContext
)
{
invalidateContextProvider
(
workInProgress
Component
true
)
;
}
return
workInProgress
.
child
;
}
function
pushHostRootContext
(
workInProgress
)
{
var
root
=
workInProgress
.
stateNode
;
if
(
root
.
pendingContext
)
{
pushTopLevelContextObject
(
workInProgress
root
.
pendingContext
root
.
pendingContext
!
=
=
root
.
context
)
;
}
else
if
(
root
.
context
)
{
pushTopLevelContextObject
(
workInProgress
root
.
context
false
)
;
}
pushHostContainer
(
workInProgress
root
.
containerInfo
)
;
}
function
updateHostRoot
(
current
1
workInProgress
renderExpirationTime
)
{
pushHostRootContext
(
workInProgress
)
;
var
updateQueue
=
workInProgress
.
updateQueue
;
!
(
updateQueue
!
=
=
null
)
?
reactProdInvariant
(
'
282
'
)
:
void
0
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevState
=
workInProgress
.
memoizedState
;
var
prevChildren
=
prevState
!
=
=
null
?
prevState
.
element
:
null
;
processUpdateQueue
(
workInProgress
updateQueue
nextProps
null
renderExpirationTime
)
;
var
nextState
=
workInProgress
.
memoizedState
;
var
nextChildren
=
nextState
.
element
;
if
(
nextChildren
=
=
=
prevChildren
)
{
resetHydrationState
(
)
;
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
var
root
=
workInProgress
.
stateNode
;
if
(
(
current
1
=
=
=
null
|
|
current
1
.
child
=
=
=
null
)
&
&
root
.
hydrate
&
&
enterHydrationState
(
workInProgress
)
)
{
workInProgress
.
effectTag
|
=
Placement
;
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
resetHydrationState
(
)
;
}
return
workInProgress
.
child
;
}
function
updateHostComponent
(
current
1
workInProgress
renderExpirationTime
)
{
pushHostContext
(
workInProgress
)
;
if
(
current
1
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
var
type
=
workInProgress
.
type
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
prevProps
=
current
1
!
=
=
null
?
current
1
.
memoizedProps
:
null
;
var
nextChildren
=
nextProps
.
children
;
var
isDirectTextChild
=
shouldSetTextContent
(
type
nextProps
)
;
if
(
isDirectTextChild
)
{
nextChildren
=
null
;
}
else
if
(
prevProps
!
=
=
null
&
&
shouldSetTextContent
(
type
prevProps
)
)
{
workInProgress
.
effectTag
|
=
ContentReset
;
}
markRef
(
current
1
workInProgress
)
;
if
(
renderExpirationTime
!
=
=
Never
&
&
workInProgress
.
mode
&
ConcurrentMode
&
&
shouldDeprioritizeSubtree
(
type
nextProps
)
)
{
workInProgress
.
expirationTime
=
workInProgress
.
childExpirationTime
=
Never
;
return
null
;
}
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateHostText
(
current
1
workInProgress
)
{
if
(
current
1
=
=
=
null
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
}
return
null
;
}
function
mountLazyComponent
(
_current
workInProgress
elementType
updateExpirationTime
renderExpirationTime
)
{
if
(
_current
!
=
=
null
)
{
_current
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
var
props
=
workInProgress
.
pendingProps
;
cancelWorkTimer
(
workInProgress
)
;
var
Component
=
readLazyComponentType
(
elementType
)
;
workInProgress
.
type
=
Component
;
var
resolvedTag
=
workInProgress
.
tag
=
resolveLazyComponentTag
(
Component
)
;
startWorkTimer
(
workInProgress
)
;
var
resolvedProps
=
resolveDefaultProps
(
Component
props
)
;
var
child
=
void
0
;
switch
(
resolvedTag
)
{
case
FunctionComponent
:
{
child
=
updateFunctionComponent
(
null
workInProgress
Component
resolvedProps
renderExpirationTime
)
;
break
;
}
case
ClassComponent
:
{
child
=
updateClassComponent
(
null
workInProgress
Component
resolvedProps
renderExpirationTime
)
;
break
;
}
case
ForwardRef
:
{
child
=
updateForwardRef
(
null
workInProgress
Component
resolvedProps
renderExpirationTime
)
;
break
;
}
case
MemoComponent
:
{
child
=
updateMemoComponent
(
null
workInProgress
Component
resolveDefaultProps
(
Component
.
type
resolvedProps
)
updateExpirationTime
renderExpirationTime
)
;
break
;
}
default
:
{
var
hint
=
'
'
;
reactProdInvariant
(
'
306
'
Component
hint
)
;
}
}
return
child
;
}
function
mountIncompleteClassComponent
(
_current
workInProgress
Component
nextProps
renderExpirationTime
)
{
if
(
_current
!
=
=
null
)
{
_current
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
workInProgress
.
tag
=
ClassComponent
;
var
hasContext
=
void
0
;
if
(
isContextProvider
(
Component
)
)
{
hasContext
=
true
;
pushContextProvider
(
workInProgress
)
;
}
else
{
hasContext
=
false
;
}
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
constructClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
mountClassInstance
(
workInProgress
Component
nextProps
renderExpirationTime
)
;
return
finishClassComponent
(
null
workInProgress
Component
true
hasContext
renderExpirationTime
)
;
}
function
mountIndeterminateComponent
(
_current
workInProgress
Component
renderExpirationTime
)
{
if
(
_current
!
=
=
null
)
{
_current
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
}
var
props
=
workInProgress
.
pendingProps
;
var
unmaskedContext
=
getUnmaskedContext
(
workInProgress
Component
false
)
;
var
context
=
getMaskedContext
(
workInProgress
unmaskedContext
)
;
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
var
value
=
void
0
;
{
value
=
renderWithHooks
(
null
workInProgress
Component
props
context
renderExpirationTime
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
if
(
typeof
value
=
=
=
'
object
'
&
&
value
!
=
=
null
&
&
typeof
value
.
render
=
=
=
'
function
'
&
&
value
.
typeof
=
=
=
undefined
)
{
workInProgress
.
tag
=
ClassComponent
;
resetHooks
(
)
;
var
hasContext
=
false
;
if
(
isContextProvider
(
Component
)
)
{
hasContext
=
true
;
pushContextProvider
(
workInProgress
)
;
}
else
{
hasContext
=
false
;
}
workInProgress
.
memoizedState
=
value
.
state
!
=
=
null
&
&
value
.
state
!
=
=
undefined
?
value
.
state
:
null
;
var
getDerivedStateFromProps
=
Component
.
getDerivedStateFromProps
;
if
(
typeof
getDerivedStateFromProps
=
=
=
'
function
'
)
{
applyDerivedStateFromProps
(
workInProgress
Component
getDerivedStateFromProps
props
)
;
}
adoptClassInstance
(
workInProgress
value
)
;
mountClassInstance
(
workInProgress
Component
props
renderExpirationTime
)
;
return
finishClassComponent
(
null
workInProgress
Component
true
hasContext
renderExpirationTime
)
;
}
else
{
workInProgress
.
tag
=
FunctionComponent
;
reconcileChildren
(
null
workInProgress
value
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
}
function
updateSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
{
var
mode
=
workInProgress
.
mode
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextState
=
workInProgress
.
memoizedState
;
var
nextDidTimeout
=
void
0
;
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
)
{
nextState
=
null
;
nextDidTimeout
=
false
;
}
else
{
nextState
=
{
timedOutAt
:
nextState
!
=
=
null
?
nextState
.
timedOutAt
:
NoWork
}
;
nextDidTimeout
=
true
;
workInProgress
.
effectTag
&
=
~
DidCapture
;
}
var
child
=
void
0
;
var
next
=
void
0
;
if
(
current
1
=
=
=
null
)
{
if
(
enableSuspenseServerRenderer
)
{
if
(
nextProps
.
fallback
!
=
=
undefined
)
{
tryToClaimNextHydratableInstance
(
workInProgress
)
;
if
(
workInProgress
.
tag
=
=
=
DehydratedSuspenseComponent
)
{
return
updateDehydratedSuspenseComponent
(
null
workInProgress
renderExpirationTime
)
;
}
}
}
if
(
nextDidTimeout
)
{
var
nextFallbackChildren
=
nextProps
.
fallback
;
var
primaryChildFragment
=
createFiberFromFragment
(
null
mode
NoWork
null
)
;
if
(
(
workInProgress
.
mode
&
ConcurrentMode
)
=
=
=
NoContext
)
{
var
progressedState
=
workInProgress
.
memoizedState
;
var
progressedPrimaryChild
=
progressedState
!
=
=
null
?
workInProgress
.
child
.
child
:
workInProgress
.
child
;
primaryChildFragment
.
child
=
progressedPrimaryChild
;
}
var
fallbackChildFragment
=
createFiberFromFragment
(
nextFallbackChildren
mode
renderExpirationTime
null
)
;
primaryChildFragment
.
sibling
=
fallbackChildFragment
;
child
=
primaryChildFragment
;
next
=
fallbackChildFragment
;
child
.
return
=
next
.
return
=
workInProgress
;
}
else
{
var
nextPrimaryChildren
=
nextProps
.
children
;
child
=
next
=
mountChildFibers
(
workInProgress
null
nextPrimaryChildren
renderExpirationTime
)
;
}
}
else
{
var
prevState
=
current
1
.
memoizedState
;
var
prevDidTimeout
=
prevState
!
=
=
null
;
if
(
prevDidTimeout
)
{
var
currentPrimaryChildFragment
=
current
1
.
child
;
var
currentFallbackChildFragment
=
currentPrimaryChildFragment
.
sibling
;
if
(
nextDidTimeout
)
{
var
_nextFallbackChildren
=
nextProps
.
fallback
;
var
_primaryChildFragment
=
createWorkInProgress
(
currentPrimaryChildFragment
currentPrimaryChildFragment
.
pendingProps
NoWork
)
;
if
(
(
workInProgress
.
mode
&
ConcurrentMode
)
=
=
=
NoContext
)
{
var
_progressedState
=
workInProgress
.
memoizedState
;
var
_progressedPrimaryChild
=
_progressedState
!
=
=
null
?
workInProgress
.
child
.
child
:
workInProgress
.
child
;
if
(
_progressedPrimaryChild
!
=
=
currentPrimaryChildFragment
.
child
)
{
_primaryChildFragment
.
child
=
_progressedPrimaryChild
;
}
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
treeBaseDuration
=
0
;
var
hiddenChild
=
_primaryChildFragment
.
child
;
while
(
hiddenChild
!
=
=
null
)
{
treeBaseDuration
+
=
hiddenChild
.
treeBaseDuration
;
hiddenChild
=
hiddenChild
.
sibling
;
}
_primaryChildFragment
.
treeBaseDuration
=
treeBaseDuration
;
}
var
_fallbackChildFragment
=
_primaryChildFragment
.
sibling
=
createWorkInProgress
(
currentFallbackChildFragment
_nextFallbackChildren
currentFallbackChildFragment
.
expirationTime
)
;
child
=
_primaryChildFragment
;
_primaryChildFragment
.
childExpirationTime
=
NoWork
;
next
=
_fallbackChildFragment
;
child
.
return
=
next
.
return
=
workInProgress
;
}
else
{
var
_nextPrimaryChildren
=
nextProps
.
children
;
var
currentPrimaryChild
=
currentPrimaryChildFragment
.
child
;
var
primaryChild
=
reconcileChildFibers
(
workInProgress
currentPrimaryChild
_nextPrimaryChildren
renderExpirationTime
)
;
child
=
next
=
primaryChild
;
}
}
else
{
var
_currentPrimaryChild
=
current
1
.
child
;
if
(
nextDidTimeout
)
{
var
_nextFallbackChildren2
=
nextProps
.
fallback
;
var
_primaryChildFragment2
=
createFiberFromFragment
(
null
mode
NoWork
null
)
;
_primaryChildFragment2
.
child
=
_currentPrimaryChild
;
if
(
(
workInProgress
.
mode
&
ConcurrentMode
)
=
=
=
NoContext
)
{
var
_progressedState2
=
workInProgress
.
memoizedState
;
var
_progressedPrimaryChild2
=
_progressedState2
!
=
=
null
?
workInProgress
.
child
.
child
:
workInProgress
.
child
;
_primaryChildFragment2
.
child
=
_progressedPrimaryChild2
;
}
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
_treeBaseDuration
=
0
;
var
_hiddenChild
=
_primaryChildFragment2
.
child
;
while
(
_hiddenChild
!
=
=
null
)
{
_treeBaseDuration
+
=
_hiddenChild
.
treeBaseDuration
;
_hiddenChild
=
_hiddenChild
.
sibling
;
}
_primaryChildFragment2
.
treeBaseDuration
=
_treeBaseDuration
;
}
var
_fallbackChildFragment2
=
_primaryChildFragment2
.
sibling
=
createFiberFromFragment
(
_nextFallbackChildren2
mode
renderExpirationTime
null
)
;
_fallbackChildFragment2
.
effectTag
|
=
Placement
;
child
=
_primaryChildFragment2
;
_primaryChildFragment2
.
childExpirationTime
=
NoWork
;
next
=
_fallbackChildFragment2
;
child
.
return
=
next
.
return
=
workInProgress
;
}
else
{
var
_nextPrimaryChildren2
=
nextProps
.
children
;
next
=
child
=
reconcileChildFibers
(
workInProgress
_currentPrimaryChild
_nextPrimaryChildren2
renderExpirationTime
)
;
}
}
workInProgress
.
stateNode
=
current
1
.
stateNode
;
}
workInProgress
.
memoizedState
=
nextState
;
workInProgress
.
child
=
child
;
return
next
;
}
function
updateDehydratedSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
{
if
(
current
1
=
=
=
null
)
{
workInProgress
.
expirationTime
=
Never
;
return
null
;
}
var
hasContextChanged
1
=
current
1
.
childExpirationTime
>
=
renderExpirationTime
;
if
(
didReceiveUpdate
|
|
hasContextChanged
1
)
{
current
1
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
var
returnFiber
=
workInProgress
.
return
;
!
(
returnFiber
!
=
=
null
)
?
reactProdInvariant
(
'
315
'
)
:
void
0
;
var
last
=
returnFiber
.
lastEffect
;
if
(
last
!
=
=
null
)
{
last
.
nextEffect
=
current
1
;
returnFiber
.
lastEffect
=
current
1
;
}
else
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
current
1
;
}
current
1
.
nextEffect
=
null
;
current
1
.
effectTag
=
Deletion
;
workInProgress
.
tag
=
SuspenseComponent
;
workInProgress
.
stateNode
=
null
;
workInProgress
.
memoizedState
=
null
;
workInProgress
.
effectTag
|
=
Placement
;
return
updateSuspenseComponent
(
null
workInProgress
renderExpirationTime
)
;
}
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
)
{
reenterHydrationStateFromDehydratedSuspenseInstance
(
workInProgress
)
;
var
nextProps
=
workInProgress
.
pendingProps
;
var
nextChildren
=
nextProps
.
children
;
workInProgress
.
child
=
mountChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
else
{
workInProgress
.
child
=
null
;
return
null
;
}
}
function
updatePortalComponent
(
current
1
workInProgress
renderExpirationTime
)
{
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
var
nextChildren
=
workInProgress
.
pendingProps
;
if
(
current
1
=
=
=
null
)
{
workInProgress
.
child
=
reconcileChildFibers
(
workInProgress
null
nextChildren
renderExpirationTime
)
;
}
else
{
reconcileChildren
(
current
1
workInProgress
nextChildren
renderExpirationTime
)
;
}
return
workInProgress
.
child
;
}
function
updateContextProvider
(
current
1
workInProgress
renderExpirationTime
)
{
var
providerType
=
workInProgress
.
type
;
var
context
=
providerType
.
_context
;
var
newProps
=
workInProgress
.
pendingProps
;
var
oldProps
=
workInProgress
.
memoizedProps
;
var
newValue
=
newProps
.
value
;
pushProvider
(
workInProgress
newValue
)
;
if
(
oldProps
!
=
=
null
)
{
var
oldValue
=
oldProps
.
value
;
var
changedBits
=
calculateChangedBits
(
context
newValue
oldValue
)
;
if
(
changedBits
=
=
=
0
)
{
if
(
oldProps
.
children
=
=
=
newProps
.
children
&
&
!
hasContextChanged
(
)
)
{
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
}
else
{
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
;
}
}
var
newChildren
=
newProps
.
children
;
reconcileChildren
(
current
1
workInProgress
newChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
updateContextConsumer
(
current
1
workInProgress
renderExpirationTime
)
{
var
context
=
workInProgress
.
type
;
var
newProps
=
workInProgress
.
pendingProps
;
var
render
=
newProps
.
children
;
prepareToReadContext
(
workInProgress
renderExpirationTime
)
;
var
newValue
=
readContext
(
context
newProps
.
unstable_observedBits
)
;
var
newChildren
=
void
0
;
{
newChildren
=
render
(
newValue
)
;
}
workInProgress
.
effectTag
|
=
PerformedWork
;
reconcileChildren
(
current
1
workInProgress
newChildren
renderExpirationTime
)
;
return
workInProgress
.
child
;
}
function
markWorkInProgressReceivedUpdate
(
)
{
didReceiveUpdate
=
true
;
}
function
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
{
cancelWorkTimer
(
workInProgress
)
;
if
(
current
1
!
=
=
null
)
{
workInProgress
.
contextDependencies
=
current
1
.
contextDependencies
;
}
if
(
enableProfilerTimer
)
{
stopProfilerTimerIfRunning
(
workInProgress
)
;
}
var
childExpirationTime
=
workInProgress
.
childExpirationTime
;
if
(
childExpirationTime
<
renderExpirationTime
)
{
return
null
;
}
else
{
cloneChildFibers
(
current
1
workInProgress
)
;
return
workInProgress
.
child
;
}
}
function
beginWork
(
current
1
workInProgress
renderExpirationTime
)
{
var
updateExpirationTime
=
workInProgress
.
expirationTime
;
if
(
current
1
!
=
=
null
)
{
var
oldProps
=
current
1
.
memoizedProps
;
var
newProps
=
workInProgress
.
pendingProps
;
if
(
oldProps
!
=
=
newProps
|
|
hasContextChanged
(
)
)
{
didReceiveUpdate
=
true
;
}
else
if
(
updateExpirationTime
<
renderExpirationTime
)
{
didReceiveUpdate
=
false
;
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
pushHostRootContext
(
workInProgress
)
;
resetHydrationState
(
)
;
break
;
case
HostComponent
:
pushHostContext
(
workInProgress
)
;
break
;
case
ClassComponent
:
{
var
Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
Component
)
)
{
pushContextProvider
(
workInProgress
)
;
}
break
;
}
case
HostPortal
:
pushHostContainer
(
workInProgress
workInProgress
.
stateNode
.
containerInfo
)
;
break
;
case
ContextProvider
:
{
var
newValue
=
workInProgress
.
memoizedProps
.
value
;
pushProvider
(
workInProgress
newValue
)
;
break
;
}
case
Profiler
:
if
(
enableProfilerTimer
)
{
workInProgress
.
effectTag
|
=
Update
;
}
break
;
case
SuspenseComponent
:
{
var
state
=
workInProgress
.
memoizedState
;
var
didTimeout
=
state
!
=
=
null
;
if
(
didTimeout
)
{
var
primaryChildFragment
=
workInProgress
.
child
;
var
primaryChildExpirationTime
=
primaryChildFragment
.
childExpirationTime
;
if
(
primaryChildExpirationTime
!
=
=
NoWork
&
&
primaryChildExpirationTime
>
=
renderExpirationTime
)
{
return
updateSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
;
}
else
{
var
child
=
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
if
(
child
!
=
=
null
)
{
return
child
.
sibling
;
}
else
{
return
null
;
}
}
}
break
;
}
case
DehydratedSuspenseComponent
:
{
if
(
enableSuspenseServerRenderer
)
{
workInProgress
.
effectTag
|
=
DidCapture
;
break
;
}
}
}
return
bailoutOnAlreadyFinishedWork
(
current
1
workInProgress
renderExpirationTime
)
;
}
}
else
{
didReceiveUpdate
=
false
;
}
workInProgress
.
expirationTime
=
NoWork
;
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
{
var
elementType
=
workInProgress
.
elementType
;
return
mountIndeterminateComponent
(
current
1
workInProgress
elementType
renderExpirationTime
)
;
}
case
LazyComponent
:
{
var
_elementType
=
workInProgress
.
elementType
;
return
mountLazyComponent
(
current
1
workInProgress
_elementType
updateExpirationTime
renderExpirationTime
)
;
}
case
FunctionComponent
:
{
var
_Component
=
workInProgress
.
type
;
var
unresolvedProps
=
workInProgress
.
pendingProps
;
var
resolvedProps
=
workInProgress
.
elementType
=
=
=
_Component
?
unresolvedProps
:
resolveDefaultProps
(
_Component
unresolvedProps
)
;
return
updateFunctionComponent
(
current
1
workInProgress
_Component
resolvedProps
renderExpirationTime
)
;
}
case
ClassComponent
:
{
var
_Component2
=
workInProgress
.
type
;
var
_unresolvedProps
=
workInProgress
.
pendingProps
;
var
_resolvedProps
=
workInProgress
.
elementType
=
=
=
_Component2
?
_unresolvedProps
:
resolveDefaultProps
(
_Component2
_unresolvedProps
)
;
return
updateClassComponent
(
current
1
workInProgress
_Component2
_resolvedProps
renderExpirationTime
)
;
}
case
HostRoot
:
return
updateHostRoot
(
current
1
workInProgress
renderExpirationTime
)
;
case
HostComponent
:
return
updateHostComponent
(
current
1
workInProgress
renderExpirationTime
)
;
case
HostText
:
return
updateHostText
(
current
1
workInProgress
)
;
case
SuspenseComponent
:
return
updateSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
;
case
HostPortal
:
return
updatePortalComponent
(
current
1
workInProgress
renderExpirationTime
)
;
case
ForwardRef
:
{
var
type
=
workInProgress
.
type
;
var
_unresolvedProps2
=
workInProgress
.
pendingProps
;
var
_resolvedProps2
=
workInProgress
.
elementType
=
=
=
type
?
_unresolvedProps2
:
resolveDefaultProps
(
type
_unresolvedProps2
)
;
return
updateForwardRef
(
current
1
workInProgress
type
_resolvedProps2
renderExpirationTime
)
;
}
case
Fragment
:
return
updateFragment
(
current
1
workInProgress
renderExpirationTime
)
;
case
Mode
:
return
updateMode
(
current
1
workInProgress
renderExpirationTime
)
;
case
Profiler
:
return
updateProfiler
(
current
1
workInProgress
renderExpirationTime
)
;
case
ContextProvider
:
return
updateContextProvider
(
current
1
workInProgress
renderExpirationTime
)
;
case
ContextConsumer
:
return
updateContextConsumer
(
current
1
workInProgress
renderExpirationTime
)
;
case
MemoComponent
:
{
var
_type2
=
workInProgress
.
type
;
var
_unresolvedProps3
=
workInProgress
.
pendingProps
;
var
_resolvedProps3
=
resolveDefaultProps
(
_type2
_unresolvedProps3
)
;
_resolvedProps3
=
resolveDefaultProps
(
_type2
.
type
_resolvedProps3
)
;
return
updateMemoComponent
(
current
1
workInProgress
_type2
_resolvedProps3
updateExpirationTime
renderExpirationTime
)
;
}
case
SimpleMemoComponent
:
{
return
updateSimpleMemoComponent
(
current
1
workInProgress
workInProgress
.
type
workInProgress
.
pendingProps
updateExpirationTime
renderExpirationTime
)
;
}
case
IncompleteClassComponent
:
{
var
_Component3
=
workInProgress
.
type
;
var
_unresolvedProps4
=
workInProgress
.
pendingProps
;
var
_resolvedProps4
=
workInProgress
.
elementType
=
=
=
_Component3
?
_unresolvedProps4
:
resolveDefaultProps
(
_Component3
_unresolvedProps4
)
;
return
mountIncompleteClassComponent
(
current
1
workInProgress
_Component3
_resolvedProps4
renderExpirationTime
)
;
}
case
DehydratedSuspenseComponent
:
{
if
(
enableSuspenseServerRenderer
)
{
return
updateDehydratedSuspenseComponent
(
current
1
workInProgress
renderExpirationTime
)
;
}
break
;
}
}
reactProdInvariant
(
'
156
'
)
;
}
var
valueCursor
=
createCursor
(
null
)
;
var
currentlyRenderingFiber
=
null
;
var
lastContextDependency
=
null
;
var
lastContextWithAllBitsObserved
=
null
;
function
resetContextDependences
(
)
{
currentlyRenderingFiber
=
null
;
lastContextDependency
=
null
;
lastContextWithAllBitsObserved
=
null
;
}
function
pushProvider
(
providerFiber
nextValue
)
{
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
push
(
valueCursor
context
.
_currentValue
providerFiber
)
;
context
.
_currentValue
=
nextValue
;
}
else
{
push
(
valueCursor
context
.
_currentValue2
providerFiber
)
;
context
.
_currentValue2
=
nextValue
;
}
}
function
popProvider
(
providerFiber
)
{
var
currentValue
=
valueCursor
.
current
;
pop
(
valueCursor
providerFiber
)
;
var
context
=
providerFiber
.
type
.
_context
;
if
(
isPrimaryRenderer
)
{
context
.
_currentValue
=
currentValue
;
}
else
{
context
.
_currentValue2
=
currentValue
;
}
}
function
calculateChangedBits
(
context
newValue
oldValue
)
{
if
(
is
(
oldValue
newValue
)
)
{
return
0
;
}
else
{
var
changedBits
=
typeof
context
.
_calculateChangedBits
=
=
=
'
function
'
?
context
.
_calculateChangedBits
(
oldValue
newValue
)
:
maxSigned31BitInt
;
return
changedBits
|
0
;
}
}
function
scheduleWorkOnParentPath
(
parent
renderExpirationTime
)
{
var
node
=
parent
;
while
(
node
!
=
=
null
)
{
var
alternate
=
node
.
alternate
;
if
(
node
.
childExpirationTime
<
renderExpirationTime
)
{
node
.
childExpirationTime
=
renderExpirationTime
;
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
renderExpirationTime
)
{
alternate
.
childExpirationTime
=
renderExpirationTime
;
}
}
else
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
renderExpirationTime
)
{
alternate
.
childExpirationTime
=
renderExpirationTime
;
}
else
{
break
;
}
node
=
node
.
return
;
}
}
function
propagateContextChange
(
workInProgress
context
changedBits
renderExpirationTime
)
{
var
fiber
=
workInProgress
.
child
;
if
(
fiber
!
=
=
null
)
{
fiber
.
return
=
workInProgress
;
}
while
(
fiber
!
=
=
null
)
{
var
nextFiber
=
void
0
;
var
list
=
fiber
.
contextDependencies
;
if
(
list
!
=
=
null
)
{
nextFiber
=
fiber
.
child
;
var
dependency
=
list
.
first
;
while
(
dependency
!
=
=
null
)
{
if
(
dependency
.
context
=
=
=
context
&
&
(
dependency
.
observedBits
&
changedBits
)
!
=
=
0
)
{
if
(
fiber
.
tag
=
=
=
ClassComponent
)
{
var
update
=
createUpdate
(
renderExpirationTime
)
;
update
.
tag
=
ForceUpdate
;
enqueueUpdate
(
fiber
update
)
;
}
if
(
fiber
.
expirationTime
<
renderExpirationTime
)
{
fiber
.
expirationTime
=
renderExpirationTime
;
}
var
alternate
=
fiber
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
.
expirationTime
<
renderExpirationTime
)
{
alternate
.
expirationTime
=
renderExpirationTime
;
}
scheduleWorkOnParentPath
(
fiber
.
return
renderExpirationTime
)
;
if
(
list
.
expirationTime
<
renderExpirationTime
)
{
list
.
expirationTime
=
renderExpirationTime
;
}
break
;
}
dependency
=
dependency
.
next
;
}
}
else
if
(
fiber
.
tag
=
=
=
ContextProvider
)
{
nextFiber
=
fiber
.
type
=
=
=
workInProgress
.
type
?
null
:
fiber
.
child
;
}
else
if
(
enableSuspenseServerRenderer
&
&
fiber
.
tag
=
=
=
DehydratedSuspenseComponent
)
{
if
(
fiber
.
expirationTime
<
renderExpirationTime
)
{
fiber
.
expirationTime
=
renderExpirationTime
;
}
var
_alternate
=
fiber
.
alternate
;
if
(
_alternate
!
=
=
null
&
&
_alternate
.
expirationTime
<
renderExpirationTime
)
{
_alternate
.
expirationTime
=
renderExpirationTime
;
}
scheduleWorkOnParentPath
(
fiber
renderExpirationTime
)
;
nextFiber
=
fiber
.
sibling
;
}
else
{
nextFiber
=
fiber
.
child
;
}
if
(
nextFiber
!
=
=
null
)
{
nextFiber
.
return
=
fiber
;
}
else
{
nextFiber
=
fiber
;
while
(
nextFiber
!
=
=
null
)
{
if
(
nextFiber
=
=
=
workInProgress
)
{
nextFiber
=
null
;
break
;
}
var
sibling
=
nextFiber
.
sibling
;
if
(
sibling
!
=
=
null
)
{
sibling
.
return
=
nextFiber
.
return
;
nextFiber
=
sibling
;
break
;
}
nextFiber
=
nextFiber
.
return
;
}
}
fiber
=
nextFiber
;
}
}
function
prepareToReadContext
(
workInProgress
renderExpirationTime
)
{
currentlyRenderingFiber
=
workInProgress
;
lastContextDependency
=
null
;
lastContextWithAllBitsObserved
=
null
;
var
currentDependencies
=
workInProgress
.
contextDependencies
;
if
(
currentDependencies
!
=
=
null
&
&
currentDependencies
.
expirationTime
>
=
renderExpirationTime
)
{
markWorkInProgressReceivedUpdate
(
)
;
}
workInProgress
.
contextDependencies
=
null
;
}
function
readContext
(
context
observedBits
)
{
if
(
lastContextWithAllBitsObserved
=
=
=
context
)
{
}
else
if
(
observedBits
=
=
=
false
|
|
observedBits
=
=
=
0
)
{
}
else
{
var
resolvedObservedBits
=
void
0
;
if
(
typeof
observedBits
!
=
=
'
number
'
|
|
observedBits
=
=
=
maxSigned31BitInt
)
{
lastContextWithAllBitsObserved
=
context
;
resolvedObservedBits
=
maxSigned31BitInt
;
}
else
{
resolvedObservedBits
=
observedBits
;
}
var
contextItem
=
{
context
:
context
observedBits
:
resolvedObservedBits
next
:
null
}
;
if
(
lastContextDependency
=
=
=
null
)
{
!
(
currentlyRenderingFiber
!
=
=
null
)
?
reactProdInvariant
(
'
308
'
)
:
void
0
;
lastContextDependency
=
contextItem
;
currentlyRenderingFiber
.
contextDependencies
=
{
first
:
contextItem
expirationTime
:
NoWork
}
;
}
else
{
lastContextDependency
=
lastContextDependency
.
next
=
contextItem
;
}
}
return
isPrimaryRenderer
?
context
.
_currentValue
:
context
.
_currentValue2
;
}
var
UpdateState
=
0
;
var
ReplaceState
=
1
;
var
ForceUpdate
=
2
;
var
CaptureUpdate
=
3
;
var
hasForceUpdate
=
false
;
function
createUpdateQueue
(
baseState
)
{
var
queue
=
{
baseState
:
baseState
firstUpdate
:
null
lastUpdate
:
null
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
cloneUpdateQueue
(
currentQueue
)
{
var
queue
=
{
baseState
:
currentQueue
.
baseState
firstUpdate
:
currentQueue
.
firstUpdate
lastUpdate
:
currentQueue
.
lastUpdate
firstCapturedUpdate
:
null
lastCapturedUpdate
:
null
firstEffect
:
null
lastEffect
:
null
firstCapturedEffect
:
null
lastCapturedEffect
:
null
}
;
return
queue
;
}
function
createUpdate
(
expirationTime
)
{
return
{
expirationTime
:
expirationTime
tag
:
UpdateState
payload
:
null
callback
:
null
next
:
null
nextEffect
:
null
}
;
}
function
appendUpdateToQueue
(
queue
update
)
{
if
(
queue
.
lastUpdate
=
=
=
null
)
{
queue
.
firstUpdate
=
queue
.
lastUpdate
=
update
;
}
else
{
queue
.
lastUpdate
.
next
=
update
;
queue
.
lastUpdate
=
update
;
}
}
function
enqueueUpdate
(
fiber
update
)
{
var
alternate
=
fiber
.
alternate
;
var
queue1
=
void
0
;
var
queue2
=
void
0
;
if
(
alternate
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
;
queue2
=
null
;
if
(
queue1
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
}
}
else
{
queue1
=
fiber
.
updateQueue
;
queue2
=
alternate
.
updateQueue
;
if
(
queue1
=
=
=
null
)
{
if
(
queue2
=
=
=
null
)
{
queue1
=
fiber
.
updateQueue
=
createUpdateQueue
(
fiber
.
memoizedState
)
;
queue2
=
alternate
.
updateQueue
=
createUpdateQueue
(
alternate
.
memoizedState
)
;
}
else
{
queue1
=
fiber
.
updateQueue
=
cloneUpdateQueue
(
queue2
)
;
}
}
else
{
if
(
queue2
=
=
=
null
)
{
queue2
=
alternate
.
updateQueue
=
cloneUpdateQueue
(
queue1
)
;
}
else
{
}
}
}
if
(
queue2
=
=
=
null
|
|
queue1
=
=
=
queue2
)
{
appendUpdateToQueue
(
queue1
update
)
;
}
else
{
if
(
queue1
.
lastUpdate
=
=
=
null
|
|
queue2
.
lastUpdate
=
=
=
null
)
{
appendUpdateToQueue
(
queue1
update
)
;
appendUpdateToQueue
(
queue2
update
)
;
}
else
{
appendUpdateToQueue
(
queue1
update
)
;
queue2
.
lastUpdate
=
update
;
}
}
}
function
enqueueCapturedUpdate
(
workInProgress
update
)
{
var
workInProgressQueue
=
workInProgress
.
updateQueue
;
if
(
workInProgressQueue
=
=
=
null
)
{
workInProgressQueue
=
workInProgress
.
updateQueue
=
createUpdateQueue
(
workInProgress
.
memoizedState
)
;
}
else
{
workInProgressQueue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
workInProgressQueue
)
;
}
if
(
workInProgressQueue
.
lastCapturedUpdate
=
=
=
null
)
{
workInProgressQueue
.
firstCapturedUpdate
=
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
else
{
workInProgressQueue
.
lastCapturedUpdate
.
next
=
update
;
workInProgressQueue
.
lastCapturedUpdate
=
update
;
}
}
function
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
{
var
current
=
workInProgress
.
alternate
;
if
(
current
!
=
=
null
)
{
if
(
queue
=
=
=
current
.
updateQueue
)
{
queue
=
workInProgress
.
updateQueue
=
cloneUpdateQueue
(
queue
)
;
}
}
return
queue
;
}
function
getStateFromUpdate
(
workInProgress
queue
update
prevState
nextProps
instance
)
{
switch
(
update
.
tag
)
{
case
ReplaceState
:
{
var
_payload
=
update
.
payload
;
if
(
typeof
_payload
=
=
=
'
function
'
)
{
var
nextState
=
_payload
.
call
(
instance
prevState
nextProps
)
;
return
nextState
;
}
return
_payload
;
}
case
CaptureUpdate
:
{
workInProgress
.
effectTag
=
workInProgress
.
effectTag
&
~
ShouldCapture
|
DidCapture
;
}
case
UpdateState
:
{
var
_payload2
=
update
.
payload
;
var
partialState
=
void
0
;
if
(
typeof
_payload2
=
=
=
'
function
'
)
{
partialState
=
_payload2
.
call
(
instance
prevState
nextProps
)
;
}
else
{
partialState
=
_payload2
;
}
if
(
partialState
=
=
=
null
|
|
partialState
=
=
=
undefined
)
{
return
prevState
;
}
return
_assign
(
{
}
prevState
partialState
)
;
}
case
ForceUpdate
:
{
hasForceUpdate
=
true
;
return
prevState
;
}
}
return
prevState
;
}
function
processUpdateQueue
(
workInProgress
queue
props
instance
renderExpirationTime
)
{
hasForceUpdate
=
false
;
queue
=
ensureWorkInProgressQueueIsAClone
(
workInProgress
queue
)
;
var
newBaseState
=
queue
.
baseState
;
var
newFirstUpdate
=
null
;
var
newExpirationTime
=
NoWork
;
var
update
=
queue
.
firstUpdate
;
var
resultState
=
newBaseState
;
while
(
update
!
=
=
null
)
{
var
updateExpirationTime
=
update
.
expirationTime
;
if
(
updateExpirationTime
<
renderExpirationTime
)
{
if
(
newFirstUpdate
=
=
=
null
)
{
newFirstUpdate
=
update
;
newBaseState
=
resultState
;
}
if
(
newExpirationTime
<
updateExpirationTime
)
{
newExpirationTime
=
updateExpirationTime
;
}
}
else
{
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
_callback
=
update
.
callback
;
if
(
_callback
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastEffect
=
=
=
null
)
{
queue
.
firstEffect
=
queue
.
lastEffect
=
update
;
}
else
{
queue
.
lastEffect
.
nextEffect
=
update
;
queue
.
lastEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
var
newFirstCapturedUpdate
=
null
;
update
=
queue
.
firstCapturedUpdate
;
while
(
update
!
=
=
null
)
{
var
_updateExpirationTime
=
update
.
expirationTime
;
if
(
_updateExpirationTime
<
renderExpirationTime
)
{
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
newFirstCapturedUpdate
=
update
;
if
(
newFirstUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
}
if
(
newExpirationTime
<
_updateExpirationTime
)
{
newExpirationTime
=
_updateExpirationTime
;
}
}
else
{
resultState
=
getStateFromUpdate
(
workInProgress
queue
update
resultState
props
instance
)
;
var
_callback2
=
update
.
callback
;
if
(
_callback2
!
=
=
null
)
{
workInProgress
.
effectTag
|
=
Callback
;
update
.
nextEffect
=
null
;
if
(
queue
.
lastCapturedEffect
=
=
=
null
)
{
queue
.
firstCapturedEffect
=
queue
.
lastCapturedEffect
=
update
;
}
else
{
queue
.
lastCapturedEffect
.
nextEffect
=
update
;
queue
.
lastCapturedEffect
=
update
;
}
}
}
update
=
update
.
next
;
}
if
(
newFirstUpdate
=
=
=
null
)
{
queue
.
lastUpdate
=
null
;
}
if
(
newFirstCapturedUpdate
=
=
=
null
)
{
queue
.
lastCapturedUpdate
=
null
;
}
else
{
workInProgress
.
effectTag
|
=
Callback
;
}
if
(
newFirstUpdate
=
=
=
null
&
&
newFirstCapturedUpdate
=
=
=
null
)
{
newBaseState
=
resultState
;
}
queue
.
baseState
=
newBaseState
;
queue
.
firstUpdate
=
newFirstUpdate
;
queue
.
firstCapturedUpdate
=
newFirstCapturedUpdate
;
workInProgress
.
expirationTime
=
newExpirationTime
;
workInProgress
.
memoizedState
=
resultState
;
}
function
callCallback
(
callback
context
)
{
!
(
typeof
callback
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
191
'
callback
)
:
void
0
;
callback
.
call
(
context
)
;
}
function
resetHasForceUpdateBeforeProcessing
(
)
{
hasForceUpdate
=
false
;
}
function
checkHasForceUpdateAfterProcessing
(
)
{
return
hasForceUpdate
;
}
function
commitUpdateQueue
(
finishedWork
finishedQueue
instance
renderExpirationTime
)
{
if
(
finishedQueue
.
firstCapturedUpdate
!
=
=
null
)
{
if
(
finishedQueue
.
lastUpdate
!
=
=
null
)
{
finishedQueue
.
lastUpdate
.
next
=
finishedQueue
.
firstCapturedUpdate
;
finishedQueue
.
lastUpdate
=
finishedQueue
.
lastCapturedUpdate
;
}
finishedQueue
.
firstCapturedUpdate
=
finishedQueue
.
lastCapturedUpdate
=
null
;
}
commitUpdateEffects
(
finishedQueue
.
firstEffect
instance
)
;
finishedQueue
.
firstEffect
=
finishedQueue
.
lastEffect
=
null
;
commitUpdateEffects
(
finishedQueue
.
firstCapturedEffect
instance
)
;
finishedQueue
.
firstCapturedEffect
=
finishedQueue
.
lastCapturedEffect
=
null
;
}
function
commitUpdateEffects
(
effect
instance
)
{
while
(
effect
!
=
=
null
)
{
var
_callback3
=
effect
.
callback
;
if
(
_callback3
!
=
=
null
)
{
effect
.
callback
=
null
;
callCallback
(
_callback3
instance
)
;
}
effect
=
effect
.
nextEffect
;
}
}
function
createCapturedValue
(
value
source
)
{
return
{
value
:
value
source
:
source
stack
:
getStackByFiberInDevAndProd
(
source
)
}
;
}
function
markUpdate
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Update
;
}
function
markRef
1
(
workInProgress
)
{
workInProgress
.
effectTag
|
=
Ref
;
}
var
appendAllChildren
=
void
0
;
var
updateHostContainer
=
void
0
;
var
updateHostComponent
1
=
void
0
;
var
updateHostText
1
=
void
0
;
if
(
supportsMutation
)
{
appendAllChildren
=
function
(
parent
workInProgress
needsVisibilityToggle
isHidden
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
appendInitialChild
(
parent
node
.
stateNode
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
type
newProps
rootContainerInstance
)
{
var
oldProps
=
current
.
memoizedProps
;
if
(
oldProps
=
=
=
newProps
)
{
return
;
}
var
instance
=
workInProgress
.
stateNode
;
var
currentHostContext
=
getHostContext
(
)
;
var
updatePayload
=
prepareUpdate
(
instance
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
workInProgress
.
updateQueue
=
updatePayload
;
if
(
updatePayload
)
{
markUpdate
(
workInProgress
)
;
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
markUpdate
(
workInProgress
)
;
}
}
;
}
else
if
(
supportsPersistence
)
{
appendAllChildren
=
function
(
parent
workInProgress
needsVisibilityToggle
isHidden
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
branches
:
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
instance
=
node
.
stateNode
;
if
(
needsVisibilityToggle
)
{
var
props
=
node
.
memoizedProps
;
var
type
=
node
.
type
;
if
(
isHidden
)
{
instance
=
cloneHiddenInstance
(
instance
type
props
node
)
;
}
else
{
instance
=
cloneUnhiddenInstance
(
instance
type
props
node
)
;
}
node
.
stateNode
=
instance
;
}
appendInitialChild
(
parent
instance
)
;
}
else
if
(
node
.
tag
=
=
=
HostText
)
{
var
_instance
=
node
.
stateNode
;
if
(
needsVisibilityToggle
)
{
var
text
=
node
.
memoizedProps
;
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
currentHostContext
=
getHostContext
(
)
;
if
(
isHidden
)
{
_instance
=
createHiddenTextInstance
(
text
rootContainerInstance
currentHostContext
workInProgress
)
;
}
else
{
_instance
=
createTextInstance
(
text
rootContainerInstance
currentHostContext
workInProgress
)
;
}
node
.
stateNode
=
_instance
;
}
appendInitialChild
(
parent
_instance
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
tag
=
=
=
SuspenseComponent
)
{
var
current
=
node
.
alternate
;
if
(
current
!
=
=
null
)
{
var
oldState
=
current
.
memoizedState
;
var
newState
=
node
.
memoizedState
;
var
oldIsHidden
=
oldState
!
=
=
null
;
var
newIsHidden
=
newState
!
=
=
null
;
if
(
oldIsHidden
!
=
=
newIsHidden
)
{
var
primaryChildParent
=
newIsHidden
?
node
.
child
:
node
;
if
(
primaryChildParent
!
=
=
null
)
{
appendAllChildren
(
parent
primaryChildParent
true
newIsHidden
)
;
}
break
branches
;
}
}
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
node
=
node
;
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
var
appendAllChildrenToContainer
=
function
(
containerChildSet
workInProgress
needsVisibilityToggle
isHidden
)
{
var
node
=
workInProgress
.
child
;
while
(
node
!
=
=
null
)
{
branches
:
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
instance
=
node
.
stateNode
;
if
(
needsVisibilityToggle
)
{
var
props
=
node
.
memoizedProps
;
var
type
=
node
.
type
;
if
(
isHidden
)
{
instance
=
cloneHiddenInstance
(
instance
type
props
node
)
;
}
else
{
instance
=
cloneUnhiddenInstance
(
instance
type
props
node
)
;
}
node
.
stateNode
=
instance
;
}
appendChildToContainerChildSet
(
containerChildSet
instance
)
;
}
else
if
(
node
.
tag
=
=
=
HostText
)
{
var
_instance2
=
node
.
stateNode
;
if
(
needsVisibilityToggle
)
{
var
text
=
node
.
memoizedProps
;
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
currentHostContext
=
getHostContext
(
)
;
if
(
isHidden
)
{
_instance2
=
createHiddenTextInstance
(
text
rootContainerInstance
currentHostContext
workInProgress
)
;
}
else
{
_instance2
=
createTextInstance
(
text
rootContainerInstance
currentHostContext
workInProgress
)
;
}
node
.
stateNode
=
_instance2
;
}
appendChildToContainerChildSet
(
containerChildSet
_instance2
)
;
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
tag
=
=
=
SuspenseComponent
)
{
var
current
=
node
.
alternate
;
if
(
current
!
=
=
null
)
{
var
oldState
=
current
.
memoizedState
;
var
newState
=
node
.
memoizedState
;
var
oldIsHidden
=
oldState
!
=
=
null
;
var
newIsHidden
=
newState
!
=
=
null
;
if
(
oldIsHidden
!
=
=
newIsHidden
)
{
var
primaryChildParent
=
newIsHidden
?
node
.
child
:
node
;
if
(
primaryChildParent
!
=
=
null
)
{
appendAllChildrenToContainer
(
containerChildSet
primaryChildParent
true
newIsHidden
)
;
}
break
branches
;
}
}
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
node
=
node
;
if
(
node
=
=
=
workInProgress
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
workInProgress
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
;
updateHostContainer
=
function
(
workInProgress
)
{
var
portalOrRoot
=
workInProgress
.
stateNode
;
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
if
(
childrenUnchanged
)
{
}
else
{
var
container
=
portalOrRoot
.
containerInfo
;
var
newChildSet
=
createContainerChildSet
(
container
)
;
appendAllChildrenToContainer
(
newChildSet
workInProgress
false
false
)
;
portalOrRoot
.
pendingChildren
=
newChildSet
;
markUpdate
(
workInProgress
)
;
finalizeContainerChildren
(
container
newChildSet
)
;
}
}
;
updateHostComponent
1
=
function
(
current
workInProgress
type
newProps
rootContainerInstance
)
{
var
currentInstance
=
current
.
stateNode
;
var
oldProps
=
current
.
memoizedProps
;
var
childrenUnchanged
=
workInProgress
.
firstEffect
=
=
=
null
;
if
(
childrenUnchanged
&
&
oldProps
=
=
=
newProps
)
{
workInProgress
.
stateNode
=
currentInstance
;
return
;
}
var
recyclableInstance
=
workInProgress
.
stateNode
;
var
currentHostContext
=
getHostContext
(
)
;
var
updatePayload
=
null
;
if
(
oldProps
!
=
=
newProps
)
{
updatePayload
=
prepareUpdate
(
recyclableInstance
type
oldProps
newProps
rootContainerInstance
currentHostContext
)
;
}
if
(
childrenUnchanged
&
&
updatePayload
=
=
=
null
)
{
workInProgress
.
stateNode
=
currentInstance
;
return
;
}
var
newInstance
=
cloneInstance
(
currentInstance
updatePayload
type
oldProps
newProps
workInProgress
childrenUnchanged
recyclableInstance
)
;
if
(
finalizeInitialChildren
(
newInstance
type
newProps
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
newInstance
;
if
(
childrenUnchanged
)
{
markUpdate
(
workInProgress
)
;
}
else
{
appendAllChildren
(
newInstance
workInProgress
false
false
)
;
}
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
if
(
oldText
!
=
=
newText
)
{
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
currentHostContext
=
getHostContext
(
)
;
workInProgress
.
stateNode
=
createTextInstance
(
newText
rootContainerInstance
currentHostContext
workInProgress
)
;
markUpdate
(
workInProgress
)
;
}
}
;
}
else
{
updateHostContainer
=
function
(
workInProgress
)
{
}
;
updateHostComponent
1
=
function
(
current
workInProgress
type
newProps
rootContainerInstance
)
{
}
;
updateHostText
1
=
function
(
current
workInProgress
oldText
newText
)
{
}
;
}
function
completeWork
(
current
workInProgress
renderExpirationTime
)
{
var
newProps
=
workInProgress
.
pendingProps
;
switch
(
workInProgress
.
tag
)
{
case
IndeterminateComponent
:
break
;
case
LazyComponent
:
break
;
case
SimpleMemoComponent
:
case
FunctionComponent
:
break
;
case
ClassComponent
:
{
var
Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
Component
)
)
{
popContext
(
workInProgress
)
;
}
break
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
fiberRoot
=
workInProgress
.
stateNode
;
if
(
fiberRoot
.
pendingContext
)
{
fiberRoot
.
context
=
fiberRoot
.
pendingContext
;
fiberRoot
.
pendingContext
=
null
;
}
if
(
current
=
=
=
null
|
|
current
.
child
=
=
=
null
)
{
popHydrationState
(
workInProgress
)
;
workInProgress
.
effectTag
&
=
~
Placement
;
}
updateHostContainer
(
workInProgress
)
;
break
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
var
rootContainerInstance
=
getRootHostContainer
(
)
;
var
type
=
workInProgress
.
type
;
if
(
current
!
=
=
null
&
&
workInProgress
.
stateNode
!
=
null
)
{
updateHostComponent
1
(
current
workInProgress
type
newProps
rootContainerInstance
)
;
if
(
current
.
ref
!
=
=
workInProgress
.
ref
)
{
markRef
1
(
workInProgress
)
;
}
}
else
{
if
(
!
newProps
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
break
;
}
var
currentHostContext
=
getHostContext
(
)
;
var
wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
wasHydrated
)
{
if
(
prepareToHydrateHostInstance
(
workInProgress
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
var
instance
=
createInstance
(
type
newProps
rootContainerInstance
currentHostContext
workInProgress
)
;
appendAllChildren
(
instance
workInProgress
false
false
)
;
if
(
finalizeInitialChildren
(
instance
type
newProps
rootContainerInstance
currentHostContext
)
)
{
markUpdate
(
workInProgress
)
;
}
workInProgress
.
stateNode
=
instance
;
}
if
(
workInProgress
.
ref
!
=
=
null
)
{
markRef
1
(
workInProgress
)
;
}
}
break
;
}
case
HostText
:
{
var
newText
=
newProps
;
if
(
current
&
&
workInProgress
.
stateNode
!
=
null
)
{
var
oldText
=
current
.
memoizedProps
;
updateHostText
1
(
current
workInProgress
oldText
newText
)
;
}
else
{
if
(
typeof
newText
!
=
=
'
string
'
)
{
!
(
workInProgress
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
166
'
)
:
void
0
;
}
var
_rootContainerInstance
=
getRootHostContainer
(
)
;
var
_currentHostContext
=
getHostContext
(
)
;
var
_wasHydrated
=
popHydrationState
(
workInProgress
)
;
if
(
_wasHydrated
)
{
if
(
prepareToHydrateHostTextInstance
(
workInProgress
)
)
{
markUpdate
(
workInProgress
)
;
}
}
else
{
workInProgress
.
stateNode
=
createTextInstance
(
newText
_rootContainerInstance
_currentHostContext
workInProgress
)
;
}
}
break
;
}
case
ForwardRef
:
break
;
case
SuspenseComponent
:
{
var
nextState
=
workInProgress
.
memoizedState
;
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
!
=
=
NoEffect
)
{
workInProgress
.
expirationTime
=
renderExpirationTime
;
return
workInProgress
;
}
var
nextDidTimeout
=
nextState
!
=
=
null
;
var
prevDidTimeout
=
current
!
=
=
null
&
&
current
.
memoizedState
!
=
=
null
;
if
(
current
!
=
=
null
&
&
!
nextDidTimeout
&
&
prevDidTimeout
)
{
var
currentFallbackChild
=
current
.
child
.
sibling
;
if
(
currentFallbackChild
!
=
=
null
)
{
var
first
=
workInProgress
.
firstEffect
;
if
(
first
!
=
=
null
)
{
workInProgress
.
firstEffect
=
currentFallbackChild
;
currentFallbackChild
.
nextEffect
=
first
;
}
else
{
workInProgress
.
firstEffect
=
workInProgress
.
lastEffect
=
currentFallbackChild
;
currentFallbackChild
.
nextEffect
=
null
;
}
currentFallbackChild
.
effectTag
=
Deletion
;
}
}
if
(
nextDidTimeout
|
|
prevDidTimeout
)
{
workInProgress
.
effectTag
|
=
Update
;
}
break
;
}
case
Fragment
:
break
;
case
Mode
:
break
;
case
Profiler
:
break
;
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
updateHostContainer
(
workInProgress
)
;
break
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
break
;
case
ContextConsumer
:
break
;
case
MemoComponent
:
break
;
case
IncompleteClassComponent
:
{
var
_Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
_Component
)
)
{
popContext
(
workInProgress
)
;
}
break
;
}
case
DehydratedSuspenseComponent
:
{
if
(
enableSuspenseServerRenderer
)
{
if
(
current
=
=
=
null
)
{
var
_wasHydrated2
=
popHydrationState
(
workInProgress
)
;
!
_wasHydrated2
?
reactProdInvariant
(
'
318
'
)
:
void
0
;
skipPastDehydratedSuspenseInstance
(
workInProgress
)
;
}
else
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
)
{
current
.
alternate
=
null
;
workInProgress
.
alternate
=
null
;
workInProgress
.
tag
=
SuspenseComponent
;
workInProgress
.
memoizedState
=
null
;
workInProgress
.
stateNode
=
null
;
}
}
break
;
}
default
:
reactProdInvariant
(
'
156
'
)
;
}
return
null
;
}
function
shouldCaptureSuspense
(
workInProgress
)
{
if
(
workInProgress
.
memoizedProps
.
fallback
=
=
=
undefined
)
{
return
false
;
}
var
nextState
=
workInProgress
.
memoizedState
;
return
nextState
=
=
=
null
;
}
function
showErrorDialog
(
capturedError
)
{
return
true
;
}
function
logCapturedError
(
capturedError
)
{
var
logError
=
showErrorDialog
(
capturedError
)
;
if
(
logError
=
=
=
false
)
{
return
;
}
var
error
=
capturedError
.
error
;
{
console
.
error
(
error
)
;
}
}
var
PossiblyWeakSet
1
=
typeof
WeakSet
=
=
=
'
function
'
?
WeakSet
:
Set
;
function
logError
(
boundary
errorInfo
)
{
var
source
=
errorInfo
.
source
;
var
stack
=
errorInfo
.
stack
;
if
(
stack
=
=
=
null
&
&
source
!
=
=
null
)
{
stack
=
getStackByFiberInDevAndProd
(
source
)
;
}
var
capturedError
=
{
componentName
:
source
!
=
=
null
?
getComponentName
(
source
.
type
)
:
null
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
error
:
errorInfo
.
value
errorBoundary
:
null
errorBoundaryName
:
null
errorBoundaryFound
:
false
willRetry
:
false
}
;
if
(
boundary
!
=
=
null
&
&
boundary
.
tag
=
=
=
ClassComponent
)
{
capturedError
.
errorBoundary
=
boundary
.
stateNode
;
capturedError
.
errorBoundaryName
=
getComponentName
(
boundary
.
type
)
;
capturedError
.
errorBoundaryFound
=
true
;
capturedError
.
willRetry
=
true
;
}
try
{
logCapturedError
(
capturedError
)
;
}
catch
(
e
)
{
setTimeout
(
function
(
)
{
throw
e
;
}
)
;
}
}
var
callComponentWillUnmountWithTimer
=
function
(
current
1
instance
)
{
startPhaseTimer
(
current
1
'
componentWillUnmount
'
)
;
instance
.
props
=
current
1
.
memoizedProps
;
instance
.
state
=
current
1
.
memoizedState
;
instance
.
componentWillUnmount
(
)
;
stopPhaseTimer
(
)
;
}
;
function
safelyCallComponentWillUnmount
(
current
1
instance
)
{
{
try
{
callComponentWillUnmountWithTimer
(
current
1
instance
)
;
}
catch
(
unmountError
)
{
captureCommitPhaseError
(
current
1
unmountError
)
;
}
}
}
function
safelyDetachRef
(
current
1
)
{
var
ref
=
current
1
.
ref
;
if
(
ref
!
=
=
null
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
{
try
{
ref
(
null
)
;
}
catch
(
refError
)
{
captureCommitPhaseError
(
current
1
refError
)
;
}
}
}
else
{
ref
.
current
=
null
;
}
}
}
function
safelyCallDestroy
(
current
1
destroy
)
{
{
try
{
destroy
(
)
;
}
catch
(
error
)
{
captureCommitPhaseError
(
current
1
error
)
;
}
}
}
function
commitBeforeMutationLifeCycles
(
current
1
finishedWork
)
{
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountSnapshot
NoEffect
1
finishedWork
)
;
return
;
}
case
ClassComponent
:
{
if
(
finishedWork
.
effectTag
&
Snapshot
)
{
if
(
current
1
!
=
=
null
)
{
var
prevProps
=
current
1
.
memoizedProps
;
var
prevState
=
current
1
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
getSnapshotBeforeUpdate
'
)
;
var
instance
=
finishedWork
.
stateNode
;
var
snapshot
=
instance
.
getSnapshotBeforeUpdate
(
finishedWork
.
elementType
=
=
=
finishedWork
.
type
?
prevProps
:
resolveDefaultProps
(
finishedWork
.
type
prevProps
)
prevState
)
;
instance
.
__reactInternalSnapshotBeforeUpdate
=
snapshot
;
stopPhaseTimer
(
)
;
}
}
return
;
}
case
HostRoot
:
case
HostComponent
:
case
HostText
:
case
HostPortal
:
case
IncompleteClassComponent
:
return
;
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitHookEffectList
(
unmountTag
mountTag
finishedWork
)
{
var
updateQueue
=
finishedWork
.
updateQueue
;
var
lastEffect
=
updateQueue
!
=
=
null
?
updateQueue
.
lastEffect
:
null
;
if
(
lastEffect
!
=
=
null
)
{
var
firstEffect
=
lastEffect
.
next
;
var
effect
=
firstEffect
;
do
{
if
(
(
effect
.
tag
&
unmountTag
)
!
=
=
NoEffect
1
)
{
var
destroy
=
effect
.
destroy
;
effect
.
destroy
=
undefined
;
if
(
destroy
!
=
=
undefined
)
{
destroy
(
)
;
}
}
if
(
(
effect
.
tag
&
mountTag
)
!
=
=
NoEffect
1
)
{
var
create
=
effect
.
create
;
effect
.
destroy
=
create
(
)
;
}
effect
=
effect
.
next
;
}
while
(
effect
!
=
=
firstEffect
)
;
}
}
function
commitPassiveHookEffects
(
finishedWork
)
{
commitHookEffectList
(
UnmountPassive
NoEffect
1
finishedWork
)
;
commitHookEffectList
(
NoEffect
1
MountPassive
finishedWork
)
;
}
function
commitLifeCycles
(
finishedRoot
current
1
finishedWork
committedExpirationTime
)
{
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountLayout
MountLayout
finishedWork
)
;
break
;
}
case
ClassComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
finishedWork
.
effectTag
&
Update
)
{
if
(
current
1
=
=
=
null
)
{
startPhaseTimer
(
finishedWork
'
componentDidMount
'
)
;
instance
.
componentDidMount
(
)
;
stopPhaseTimer
(
)
;
}
else
{
var
prevProps
=
finishedWork
.
elementType
=
=
=
finishedWork
.
type
?
current
1
.
memoizedProps
:
resolveDefaultProps
(
finishedWork
.
type
current
1
.
memoizedProps
)
;
var
prevState
=
current
1
.
memoizedState
;
startPhaseTimer
(
finishedWork
'
componentDidUpdate
'
)
;
instance
.
componentDidUpdate
(
prevProps
prevState
instance
.
__reactInternalSnapshotBeforeUpdate
)
;
stopPhaseTimer
(
)
;
}
}
var
updateQueue
=
finishedWork
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
commitUpdateQueue
(
finishedWork
updateQueue
instance
committedExpirationTime
)
;
}
return
;
}
case
HostRoot
:
{
var
_updateQueue
=
finishedWork
.
updateQueue
;
if
(
_updateQueue
!
=
=
null
)
{
var
_instance
=
null
;
if
(
finishedWork
.
child
!
=
=
null
)
{
switch
(
finishedWork
.
child
.
tag
)
{
case
HostComponent
:
_instance
=
getPublicInstance
(
finishedWork
.
child
.
stateNode
)
;
break
;
case
ClassComponent
:
_instance
=
finishedWork
.
child
.
stateNode
;
break
;
}
}
commitUpdateQueue
(
finishedWork
_updateQueue
_instance
committedExpirationTime
)
;
}
return
;
}
case
HostComponent
:
{
var
_instance2
=
finishedWork
.
stateNode
;
if
(
current
1
=
=
=
null
&
&
finishedWork
.
effectTag
&
Update
)
{
var
type
=
finishedWork
.
type
;
var
props
=
finishedWork
.
memoizedProps
;
commitMount
(
_instance2
type
props
finishedWork
)
;
}
return
;
}
case
HostText
:
{
return
;
}
case
HostPortal
:
{
return
;
}
case
Profiler
:
{
if
(
enableProfilerTimer
)
{
var
onRender
=
finishedWork
.
memoizedProps
.
onRender
;
if
(
enableSchedulerTracing
)
{
onRender
(
finishedWork
.
memoizedProps
.
id
current
1
=
=
=
null
?
'
mount
'
:
'
update
'
finishedWork
.
actualDuration
finishedWork
.
treeBaseDuration
finishedWork
.
actualStartTime
getCommitTime
(
)
finishedRoot
.
memoizedInteractions
)
;
}
else
{
onRender
(
finishedWork
.
memoizedProps
.
id
current
1
=
=
=
null
?
'
mount
'
:
'
update
'
finishedWork
.
actualDuration
finishedWork
.
treeBaseDuration
finishedWork
.
actualStartTime
getCommitTime
(
)
)
;
}
}
return
;
}
case
SuspenseComponent
:
break
;
case
IncompleteClassComponent
:
break
;
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
hideOrUnhideAllChildren
(
finishedWork
isHidden
)
{
if
(
supportsMutation
)
{
var
node
=
finishedWork
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
)
{
var
instance
=
node
.
stateNode
;
if
(
isHidden
)
{
hideInstance
(
instance
)
;
}
else
{
unhideInstance
(
node
.
stateNode
node
.
memoizedProps
)
;
}
}
else
if
(
node
.
tag
=
=
=
HostText
)
{
var
_instance3
=
node
.
stateNode
;
if
(
isHidden
)
{
hideTextInstance
(
_instance3
)
;
}
else
{
unhideTextInstance
(
_instance3
node
.
memoizedProps
)
;
}
}
else
if
(
node
.
tag
=
=
=
SuspenseComponent
&
&
node
.
memoizedState
!
=
=
null
)
{
var
fallbackChildFragment
=
node
.
child
.
sibling
;
fallbackChildFragment
.
return
=
node
;
node
=
fallbackChildFragment
;
continue
;
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
finishedWork
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
finishedWork
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
}
function
commitAttachRef
(
finishedWork
)
{
var
ref
=
finishedWork
.
ref
;
if
(
ref
!
=
=
null
)
{
var
instance
=
finishedWork
.
stateNode
;
var
instanceToUse
=
void
0
;
switch
(
finishedWork
.
tag
)
{
case
HostComponent
:
instanceToUse
=
getPublicInstance
(
instance
)
;
break
;
default
:
instanceToUse
=
instance
;
}
if
(
typeof
ref
=
=
=
'
function
'
)
{
ref
(
instanceToUse
)
;
}
else
{
ref
.
current
=
instanceToUse
;
}
}
}
function
commitDetachRef
(
current
1
)
{
var
currentRef
=
current
1
.
ref
;
if
(
currentRef
!
=
=
null
)
{
if
(
typeof
currentRef
=
=
=
'
function
'
)
{
currentRef
(
null
)
;
}
else
{
currentRef
.
current
=
null
;
}
}
}
function
commitUnmount
(
current
1
)
{
onCommitUnmount
(
current
1
)
;
switch
(
current
1
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
MemoComponent
:
case
SimpleMemoComponent
:
{
var
updateQueue
=
current
1
.
updateQueue
;
if
(
updateQueue
!
=
=
null
)
{
var
lastEffect
=
updateQueue
.
lastEffect
;
if
(
lastEffect
!
=
=
null
)
{
var
firstEffect
=
lastEffect
.
next
;
var
effect
=
firstEffect
;
do
{
var
destroy
=
effect
.
destroy
;
if
(
destroy
!
=
=
undefined
)
{
safelyCallDestroy
(
current
1
destroy
)
;
}
effect
=
effect
.
next
;
}
while
(
effect
!
=
=
firstEffect
)
;
}
}
break
;
}
case
ClassComponent
:
{
safelyDetachRef
(
current
1
)
;
var
instance
=
current
1
.
stateNode
;
if
(
typeof
instance
.
componentWillUnmount
=
=
=
'
function
'
)
{
safelyCallComponentWillUnmount
(
current
1
instance
)
;
}
return
;
}
case
HostComponent
:
{
safelyDetachRef
(
current
1
)
;
return
;
}
case
HostPortal
:
{
if
(
supportsMutation
)
{
unmountHostComponents
(
current
1
)
;
}
else
if
(
supportsPersistence
)
{
emptyPortalContainer
(
current
1
)
;
}
return
;
}
}
}
function
commitNestedUnmounts
(
root
)
{
var
node
=
root
;
while
(
true
)
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
&
&
(
!
supportsMutation
|
|
node
.
tag
!
=
=
HostPortal
)
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
root
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
root
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
detachFiber
(
current
1
)
{
current
1
.
return
=
null
;
current
1
.
child
=
null
;
current
1
.
memoizedState
=
null
;
current
1
.
updateQueue
=
null
;
var
alternate
=
current
1
.
alternate
;
if
(
alternate
!
=
=
null
)
{
alternate
.
return
=
null
;
alternate
.
child
=
null
;
alternate
.
memoizedState
=
null
;
alternate
.
updateQueue
=
null
;
}
}
function
emptyPortalContainer
(
current
1
)
{
if
(
!
supportsPersistence
)
{
return
;
}
var
portal
=
current
1
.
stateNode
;
var
containerInfo
=
portal
.
containerInfo
;
var
emptyChildSet
=
createContainerChildSet
(
containerInfo
)
;
replaceContainerChildren
(
containerInfo
emptyChildSet
)
;
}
function
commitContainer
(
finishedWork
)
{
if
(
!
supportsPersistence
)
{
return
;
}
switch
(
finishedWork
.
tag
)
{
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
return
;
}
case
HostText
:
{
return
;
}
case
HostRoot
:
case
HostPortal
:
{
var
portalOrRoot
=
finishedWork
.
stateNode
;
var
containerInfo
=
portalOrRoot
.
containerInfo
_pendingChildren
=
portalOrRoot
.
pendingChildren
;
replaceContainerChildren
(
containerInfo
_pendingChildren
)
;
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
getHostParentFiber
(
fiber
)
{
var
parent
=
fiber
.
return
;
while
(
parent
!
=
=
null
)
{
if
(
isHostParent
(
parent
)
)
{
return
parent
;
}
parent
=
parent
.
return
;
}
reactProdInvariant
(
'
160
'
)
;
}
function
isHostParent
(
fiber
)
{
return
fiber
.
tag
=
=
=
HostComponent
|
|
fiber
.
tag
=
=
=
HostRoot
|
|
fiber
.
tag
=
=
=
HostPortal
;
}
function
getHostSibling
(
fiber
)
{
var
node
=
fiber
;
siblings
:
while
(
true
)
{
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
isHostParent
(
node
.
return
)
)
{
return
null
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
while
(
node
.
tag
!
=
=
HostComponent
&
&
node
.
tag
!
=
=
HostText
&
&
node
.
tag
!
=
=
DehydratedSuspenseComponent
)
{
if
(
node
.
effectTag
&
Placement
)
{
continue
siblings
;
}
if
(
node
.
child
=
=
=
null
|
|
node
.
tag
=
=
=
HostPortal
)
{
continue
siblings
;
}
else
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
}
}
if
(
!
(
node
.
effectTag
&
Placement
)
)
{
return
node
.
stateNode
;
}
}
}
function
commitPlacement
(
finishedWork
)
{
if
(
!
supportsMutation
)
{
return
;
}
var
parentFiber
=
getHostParentFiber
(
finishedWork
)
;
var
parent
=
void
0
;
var
isContainer
=
void
0
;
switch
(
parentFiber
.
tag
)
{
case
HostComponent
:
parent
=
parentFiber
.
stateNode
;
isContainer
=
false
;
break
;
case
HostRoot
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
case
HostPortal
:
parent
=
parentFiber
.
stateNode
.
containerInfo
;
isContainer
=
true
;
break
;
default
:
reactProdInvariant
(
'
161
'
)
;
}
if
(
parentFiber
.
effectTag
&
ContentReset
)
{
resetTextContent
(
parent
)
;
parentFiber
.
effectTag
&
=
~
ContentReset
;
}
var
before
=
getHostSibling
(
finishedWork
)
;
var
node
=
finishedWork
;
while
(
true
)
{
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
if
(
before
)
{
if
(
isContainer
)
{
insertInContainerBefore
(
parent
node
.
stateNode
before
)
;
}
else
{
insertBefore
(
parent
node
.
stateNode
before
)
;
}
}
else
{
if
(
isContainer
)
{
appendChildToContainer
(
parent
node
.
stateNode
)
;
}
else
{
appendChild
(
parent
node
.
stateNode
)
;
}
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
}
else
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
if
(
node
=
=
=
finishedWork
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
finishedWork
)
{
return
;
}
node
=
node
.
return
;
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
unmountHostComponents
(
current
1
)
{
var
node
=
current
1
;
var
currentParentIsValid
=
false
;
var
currentParent
=
void
0
;
var
currentParentIsContainer
=
void
0
;
while
(
true
)
{
if
(
!
currentParentIsValid
)
{
var
parent
=
node
.
return
;
findParent
:
while
(
true
)
{
!
(
parent
!
=
=
null
)
?
reactProdInvariant
(
'
160
'
)
:
void
0
;
switch
(
parent
.
tag
)
{
case
HostComponent
:
currentParent
=
parent
.
stateNode
;
currentParentIsContainer
=
false
;
break
findParent
;
case
HostRoot
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
case
HostPortal
:
currentParent
=
parent
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
break
findParent
;
}
parent
=
parent
.
return
;
}
currentParentIsValid
=
true
;
}
if
(
node
.
tag
=
=
=
HostComponent
|
|
node
.
tag
=
=
=
HostText
)
{
commitNestedUnmounts
(
node
)
;
if
(
currentParentIsContainer
)
{
removeChildFromContainer
(
currentParent
node
.
stateNode
)
;
}
else
{
removeChild
(
currentParent
node
.
stateNode
)
;
}
}
else
if
(
enableSuspenseServerRenderer
&
&
node
.
tag
=
=
=
DehydratedSuspenseComponent
)
{
if
(
currentParentIsContainer
)
{
clearSuspenseBoundaryFromContainer
(
currentParent
node
.
stateNode
)
;
}
else
{
clearSuspenseBoundary
(
currentParent
node
.
stateNode
)
;
}
}
else
if
(
node
.
tag
=
=
=
HostPortal
)
{
if
(
node
.
child
!
=
=
null
)
{
currentParent
=
node
.
stateNode
.
containerInfo
;
currentParentIsContainer
=
true
;
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
else
{
commitUnmount
(
node
)
;
if
(
node
.
child
!
=
=
null
)
{
node
.
child
.
return
=
node
;
node
=
node
.
child
;
continue
;
}
}
if
(
node
=
=
=
current
1
)
{
return
;
}
while
(
node
.
sibling
=
=
=
null
)
{
if
(
node
.
return
=
=
=
null
|
|
node
.
return
=
=
=
current
1
)
{
return
;
}
node
=
node
.
return
;
if
(
node
.
tag
=
=
=
HostPortal
)
{
currentParentIsValid
=
false
;
}
}
node
.
sibling
.
return
=
node
.
return
;
node
=
node
.
sibling
;
}
}
function
commitDeletion
(
current
1
)
{
if
(
supportsMutation
)
{
unmountHostComponents
(
current
1
)
;
}
else
{
commitNestedUnmounts
(
current
1
)
;
}
detachFiber
(
current
1
)
;
}
function
commitWork
(
current
1
finishedWork
)
{
if
(
!
supportsMutation
)
{
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
MemoComponent
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountMutation
MountMutation
finishedWork
)
;
return
;
}
}
commitContainer
(
finishedWork
)
;
return
;
}
switch
(
finishedWork
.
tag
)
{
case
FunctionComponent
:
case
ForwardRef
:
case
MemoComponent
:
case
SimpleMemoComponent
:
{
commitHookEffectList
(
UnmountMutation
MountMutation
finishedWork
)
;
return
;
}
case
ClassComponent
:
{
return
;
}
case
HostComponent
:
{
var
instance
=
finishedWork
.
stateNode
;
if
(
instance
!
=
null
)
{
var
newProps
=
finishedWork
.
memoizedProps
;
var
oldProps
=
current
1
!
=
=
null
?
current
1
.
memoizedProps
:
newProps
;
var
type
=
finishedWork
.
type
;
var
updatePayload
=
finishedWork
.
updateQueue
;
finishedWork
.
updateQueue
=
null
;
if
(
updatePayload
!
=
=
null
)
{
commitUpdate
(
instance
updatePayload
type
oldProps
newProps
finishedWork
)
;
}
}
return
;
}
case
HostText
:
{
!
(
finishedWork
.
stateNode
!
=
=
null
)
?
reactProdInvariant
(
'
162
'
)
:
void
0
;
var
textInstance
=
finishedWork
.
stateNode
;
var
newText
=
finishedWork
.
memoizedProps
;
var
oldText
=
current
1
!
=
=
null
?
current
1
.
memoizedProps
:
newText
;
commitTextUpdate
(
textInstance
oldText
newText
)
;
return
;
}
case
HostRoot
:
{
return
;
}
case
Profiler
:
{
return
;
}
case
SuspenseComponent
:
{
var
newState
=
finishedWork
.
memoizedState
;
var
newDidTimeout
=
void
0
;
var
primaryChildParent
=
finishedWork
;
if
(
newState
=
=
=
null
)
{
newDidTimeout
=
false
;
}
else
{
newDidTimeout
=
true
;
primaryChildParent
=
finishedWork
.
child
;
if
(
newState
.
timedOutAt
=
=
=
NoWork
)
{
newState
.
timedOutAt
=
requestCurrentTime
(
)
;
}
}
if
(
primaryChildParent
!
=
=
null
)
{
hideOrUnhideAllChildren
(
primaryChildParent
newDidTimeout
)
;
}
var
thenables
=
finishedWork
.
updateQueue
;
if
(
thenables
!
=
=
null
)
{
finishedWork
.
updateQueue
=
null
;
var
retryCache
=
finishedWork
.
stateNode
;
if
(
retryCache
=
=
=
null
)
{
retryCache
=
finishedWork
.
stateNode
=
new
PossiblyWeakSet
1
(
)
;
}
thenables
.
forEach
(
function
(
thenable
)
{
var
retry
=
retryTimedOutBoundary
.
bind
(
null
finishedWork
thenable
)
;
if
(
enableSchedulerTracing
)
{
retry
=
unstable_wrap
(
retry
)
;
}
if
(
!
retryCache
.
has
(
thenable
)
)
{
retryCache
.
add
(
thenable
)
;
thenable
.
then
(
retry
retry
)
;
}
}
)
;
}
return
;
}
case
IncompleteClassComponent
:
{
return
;
}
default
:
{
reactProdInvariant
(
'
163
'
)
;
}
}
}
function
commitResetTextContent
(
current
1
)
{
if
(
!
supportsMutation
)
{
return
;
}
resetTextContent
(
current
1
.
stateNode
)
;
}
var
PossiblyWeakSet
=
typeof
WeakSet
=
=
=
'
function
'
?
WeakSet
:
Set
;
var
PossiblyWeakMap
=
typeof
WeakMap
=
=
=
'
function
'
?
WeakMap
:
Map
;
function
createRootErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
CaptureUpdate
;
update
.
payload
=
{
element
:
null
}
;
var
error
=
errorInfo
.
value
;
update
.
callback
=
function
(
)
{
onUncaughtError
(
error
)
;
logError
(
fiber
errorInfo
)
;
}
;
return
update
;
}
function
createClassErrorUpdate
(
fiber
errorInfo
expirationTime
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
tag
=
CaptureUpdate
;
var
getDerivedStateFromError
=
fiber
.
type
.
getDerivedStateFromError
;
if
(
typeof
getDerivedStateFromError
=
=
=
'
function
'
)
{
var
error
=
errorInfo
.
value
;
update
.
payload
=
function
(
)
{
return
getDerivedStateFromError
(
error
)
;
}
;
}
var
inst
=
fiber
.
stateNode
;
if
(
inst
!
=
=
null
&
&
typeof
inst
.
componentDidCatch
=
=
=
'
function
'
)
{
update
.
callback
=
function
callback
(
)
{
if
(
typeof
getDerivedStateFromError
!
=
=
'
function
'
)
{
markLegacyErrorBoundaryAsFailed
(
this
)
;
}
var
error
=
errorInfo
.
value
;
var
stack
=
errorInfo
.
stack
;
logError
(
fiber
errorInfo
)
;
this
.
componentDidCatch
(
error
{
componentStack
:
stack
!
=
=
null
?
stack
:
'
'
}
)
;
}
;
}
return
update
;
}
function
attachPingListener
(
root
renderExpirationTime
thenable
)
{
var
pingCache
=
root
.
pingCache
;
var
threadIDs
=
void
0
;
if
(
pingCache
=
=
=
null
)
{
pingCache
=
root
.
pingCache
=
new
PossiblyWeakMap
(
)
;
threadIDs
=
new
Set
(
)
;
pingCache
.
set
(
thenable
threadIDs
)
;
}
else
{
threadIDs
=
pingCache
.
get
(
thenable
)
;
if
(
threadIDs
=
=
=
undefined
)
{
threadIDs
=
new
Set
(
)
;
pingCache
.
set
(
thenable
threadIDs
)
;
}
}
if
(
!
threadIDs
.
has
(
renderExpirationTime
)
)
{
threadIDs
.
add
(
renderExpirationTime
)
;
var
ping
=
pingSuspendedRoot
.
bind
(
null
root
thenable
renderExpirationTime
)
;
if
(
enableSchedulerTracing
)
{
ping
=
unstable_wrap
(
ping
)
;
}
thenable
.
then
(
ping
ping
)
;
}
}
function
throwException
(
root
returnFiber
sourceFiber
value
renderExpirationTime
)
{
sourceFiber
.
effectTag
|
=
Incomplete
;
sourceFiber
.
firstEffect
=
sourceFiber
.
lastEffect
=
null
;
if
(
value
!
=
=
null
&
&
typeof
value
=
=
=
'
object
'
&
&
typeof
value
.
then
=
=
=
'
function
'
)
{
var
thenable
=
value
;
var
_workInProgress
=
returnFiber
;
var
earliestTimeoutMs
=
-
1
;
var
startTimeMs
=
-
1
;
do
{
if
(
_workInProgress
.
tag
=
=
=
SuspenseComponent
)
{
var
current
1
=
_workInProgress
.
alternate
;
if
(
current
1
!
=
=
null
)
{
var
currentState
=
current
1
.
memoizedState
;
if
(
currentState
!
=
=
null
)
{
var
timedOutAt
=
currentState
.
timedOutAt
;
startTimeMs
=
expirationTimeToMs
(
timedOutAt
)
;
break
;
}
}
var
timeoutPropMs
=
_workInProgress
.
pendingProps
.
maxDuration
;
if
(
typeof
timeoutPropMs
=
=
=
'
number
'
)
{
if
(
timeoutPropMs
<
=
0
)
{
earliestTimeoutMs
=
0
;
}
else
if
(
earliestTimeoutMs
=
=
=
-
1
|
|
timeoutPropMs
<
earliestTimeoutMs
)
{
earliestTimeoutMs
=
timeoutPropMs
;
}
}
}
_workInProgress
=
_workInProgress
.
return
;
}
while
(
_workInProgress
!
=
=
null
)
;
_workInProgress
=
returnFiber
;
do
{
if
(
_workInProgress
.
tag
=
=
=
SuspenseComponent
&
&
shouldCaptureSuspense
(
_workInProgress
)
)
{
var
thenables
=
_workInProgress
.
updateQueue
;
if
(
thenables
=
=
=
null
)
{
var
updateQueue
=
new
Set
(
)
;
updateQueue
.
add
(
thenable
)
;
_workInProgress
.
updateQueue
=
updateQueue
;
}
else
{
thenables
.
add
(
thenable
)
;
}
if
(
(
_workInProgress
.
mode
&
ConcurrentMode
)
=
=
=
NoEffect
)
{
_workInProgress
.
effectTag
|
=
DidCapture
;
sourceFiber
.
effectTag
&
=
~
(
LifecycleEffectMask
|
Incomplete
)
;
if
(
sourceFiber
.
tag
=
=
=
ClassComponent
)
{
var
currentSourceFiber
=
sourceFiber
.
alternate
;
if
(
currentSourceFiber
=
=
=
null
)
{
sourceFiber
.
tag
=
IncompleteClassComponent
;
}
else
{
var
update
=
createUpdate
(
Sync
)
;
update
.
tag
=
ForceUpdate
;
enqueueUpdate
(
sourceFiber
update
)
;
}
}
sourceFiber
.
expirationTime
=
Sync
;
return
;
}
attachPingListener
(
root
renderExpirationTime
thenable
)
;
var
absoluteTimeoutMs
=
void
0
;
if
(
earliestTimeoutMs
=
=
=
-
1
)
{
absoluteTimeoutMs
=
maxSigned31BitInt
;
}
else
{
if
(
startTimeMs
=
=
=
-
1
)
{
var
earliestExpirationTime
=
findEarliestOutstandingPriorityLevel
(
root
renderExpirationTime
)
;
var
earliestExpirationTimeMs
=
expirationTimeToMs
(
earliestExpirationTime
)
;
startTimeMs
=
earliestExpirationTimeMs
-
LOW_PRIORITY_EXPIRATION
;
}
absoluteTimeoutMs
=
startTimeMs
+
earliestTimeoutMs
;
}
renderDidSuspend
(
root
absoluteTimeoutMs
renderExpirationTime
)
;
_workInProgress
.
effectTag
|
=
ShouldCapture
;
_workInProgress
.
expirationTime
=
renderExpirationTime
;
return
;
}
else
if
(
enableSuspenseServerRenderer
&
&
_workInProgress
.
tag
=
=
=
DehydratedSuspenseComponent
)
{
attachPingListener
(
root
renderExpirationTime
thenable
)
;
var
retryCache
=
_workInProgress
.
memoizedState
;
if
(
retryCache
=
=
=
null
)
{
retryCache
=
_workInProgress
.
memoizedState
=
new
PossiblyWeakSet
(
)
;
var
_current
=
_workInProgress
.
alternate
;
!
_current
?
reactProdInvariant
(
'
319
'
)
:
void
0
;
_current
.
memoizedState
=
retryCache
;
}
if
(
!
retryCache
.
has
(
thenable
)
)
{
retryCache
.
add
(
thenable
)
;
var
retry
=
retryTimedOutBoundary
.
bind
(
null
_workInProgress
thenable
)
;
if
(
enableSchedulerTracing
)
{
retry
=
unstable_wrap
(
retry
)
;
}
thenable
.
then
(
retry
retry
)
;
}
_workInProgress
.
effectTag
|
=
ShouldCapture
;
_workInProgress
.
expirationTime
=
renderExpirationTime
;
return
;
}
_workInProgress
=
_workInProgress
.
return
;
}
while
(
_workInProgress
!
=
=
null
)
;
value
=
new
Error
(
(
getComponentName
(
sourceFiber
.
type
)
|
|
'
A
React
component
'
)
+
'
suspended
while
rendering
but
no
fallback
UI
was
specified
.
\
n
'
+
'
\
n
'
+
'
Add
a
<
Suspense
fallback
=
.
.
.
>
component
higher
in
the
tree
to
'
+
'
provide
a
loading
indicator
or
placeholder
to
display
.
'
+
getStackByFiberInDevAndProd
(
sourceFiber
)
)
;
}
renderDidError
(
)
;
value
=
createCapturedValue
(
value
sourceFiber
)
;
var
workInProgress
=
returnFiber
;
do
{
switch
(
workInProgress
.
tag
)
{
case
HostRoot
:
{
var
_errorInfo
=
value
;
workInProgress
.
effectTag
|
=
ShouldCapture
;
workInProgress
.
expirationTime
=
renderExpirationTime
;
var
_update
=
createRootErrorUpdate
(
workInProgress
_errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
_update
)
;
return
;
}
case
ClassComponent
:
var
errorInfo
=
value
;
var
ctor
=
workInProgress
.
type
;
var
instance
=
workInProgress
.
stateNode
;
if
(
(
workInProgress
.
effectTag
&
DidCapture
)
=
=
=
NoEffect
&
&
(
typeof
ctor
.
getDerivedStateFromError
=
=
=
'
function
'
|
|
instance
!
=
=
null
&
&
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
)
{
workInProgress
.
effectTag
|
=
ShouldCapture
;
workInProgress
.
expirationTime
=
renderExpirationTime
;
var
_update2
=
createClassErrorUpdate
(
workInProgress
errorInfo
renderExpirationTime
)
;
enqueueCapturedUpdate
(
workInProgress
_update2
)
;
return
;
}
break
;
default
:
break
;
}
workInProgress
=
workInProgress
.
return
;
}
while
(
workInProgress
!
=
=
null
)
;
}
function
unwindWork
(
workInProgress
renderExpirationTime
)
{
switch
(
workInProgress
.
tag
)
{
case
ClassComponent
:
{
var
Component
=
workInProgress
.
type
;
if
(
isContextProvider
(
Component
)
)
{
popContext
(
workInProgress
)
;
}
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
HostRoot
:
{
popHostContainer
(
workInProgress
)
;
popTopLevelContextObject
(
workInProgress
)
;
var
_effectTag
=
workInProgress
.
effectTag
;
!
(
(
_effectTag
&
DidCapture
)
=
=
=
NoEffect
)
?
reactProdInvariant
(
'
285
'
)
:
void
0
;
workInProgress
.
effectTag
=
_effectTag
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
case
HostComponent
:
{
popHostContext
(
workInProgress
)
;
return
null
;
}
case
SuspenseComponent
:
{
var
_effectTag2
=
workInProgress
.
effectTag
;
if
(
_effectTag2
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
_effectTag2
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
return
null
;
}
case
DehydratedSuspenseComponent
:
{
if
(
enableSuspenseServerRenderer
)
{
var
_effectTag3
=
workInProgress
.
effectTag
;
if
(
_effectTag3
&
ShouldCapture
)
{
workInProgress
.
effectTag
=
_effectTag3
&
~
ShouldCapture
|
DidCapture
;
return
workInProgress
;
}
}
return
null
;
}
case
HostPortal
:
popHostContainer
(
workInProgress
)
;
return
null
;
case
ContextProvider
:
popProvider
(
workInProgress
)
;
return
null
;
default
:
return
null
;
}
}
function
unwindInterruptedWork
(
interruptedWork
)
{
switch
(
interruptedWork
.
tag
)
{
case
ClassComponent
:
{
var
childContextTypes
=
interruptedWork
.
type
.
childContextTypes
;
if
(
childContextTypes
!
=
=
null
&
&
childContextTypes
!
=
=
undefined
)
{
popContext
(
interruptedWork
)
;
}
break
;
}
case
HostRoot
:
{
popHostContainer
(
interruptedWork
)
;
popTopLevelContextObject
(
interruptedWork
)
;
break
;
}
case
HostComponent
:
{
popHostContext
(
interruptedWork
)
;
break
;
}
case
HostPortal
:
popHostContainer
(
interruptedWork
)
;
break
;
case
ContextProvider
:
popProvider
(
interruptedWork
)
;
break
;
default
:
break
;
}
}
var
ReactCurrentDispatcher
=
ReactSharedInternals
.
ReactCurrentDispatcher
;
var
ReactCurrentOwner
2
=
ReactSharedInternals
.
ReactCurrentOwner
;
if
(
enableSchedulerTracing
)
{
!
(
__interactionsRef
!
=
null
&
&
__interactionsRef
.
current
!
=
null
)
?
reactProdInvariant
(
'
302
'
)
:
void
0
;
}
var
lastUniqueAsyncExpiration
=
Sync
-
1
;
var
isWorking
=
false
;
var
nextUnitOfWork
=
null
;
var
nextRoot
=
null
;
var
nextRenderExpirationTime
=
NoWork
;
var
nextLatestAbsoluteTimeoutMs
=
-
1
;
var
nextRenderDidError
=
false
;
var
nextEffect
=
null
;
var
isCommitting
1
=
false
;
var
rootWithPendingPassiveEffects
=
null
;
var
passiveEffectCallbackHandle
=
null
;
var
passiveEffectCallback
=
null
;
var
legacyErrorBoundariesThatAlreadyFailed
=
null
;
var
interruptedBy
=
null
;
function
resetStack
(
)
{
if
(
nextUnitOfWork
!
=
=
null
)
{
var
interruptedWork
=
nextUnitOfWork
.
return
;
while
(
interruptedWork
!
=
=
null
)
{
unwindInterruptedWork
(
interruptedWork
)
;
interruptedWork
=
interruptedWork
.
return
;
}
}
nextRoot
=
null
;
nextRenderExpirationTime
=
NoWork
;
nextLatestAbsoluteTimeoutMs
=
-
1
;
nextRenderDidError
=
false
;
nextUnitOfWork
=
null
;
}
function
commitAllHostEffects
(
)
{
while
(
nextEffect
!
=
=
null
)
{
recordEffect
(
)
;
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
ContentReset
)
{
commitResetTextContent
(
nextEffect
)
;
}
if
(
effectTag
&
Ref
)
{
var
current
1
=
nextEffect
.
alternate
;
if
(
current
1
!
=
=
null
)
{
commitDetachRef
(
current
1
)
;
}
}
var
primaryEffectTag
=
effectTag
&
(
Placement
|
Update
|
Deletion
)
;
switch
(
primaryEffectTag
)
{
case
Placement
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
break
;
}
case
PlacementAndUpdate
:
{
commitPlacement
(
nextEffect
)
;
nextEffect
.
effectTag
&
=
~
Placement
;
var
_current
=
nextEffect
.
alternate
;
commitWork
(
_current
nextEffect
)
;
break
;
}
case
Update
:
{
var
_current2
=
nextEffect
.
alternate
;
commitWork
(
_current2
nextEffect
)
;
break
;
}
case
Deletion
:
{
commitDeletion
(
nextEffect
)
;
break
;
}
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitBeforeMutationLifecycles
(
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
Snapshot
)
{
recordEffect
(
)
;
var
current
1
=
nextEffect
.
alternate
;
commitBeforeMutationLifeCycles
(
current
1
nextEffect
)
;
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitAllLifeCycles
(
finishedRoot
committedExpirationTime
)
{
while
(
nextEffect
!
=
=
null
)
{
var
effectTag
=
nextEffect
.
effectTag
;
if
(
effectTag
&
(
Update
|
Callback
)
)
{
recordEffect
(
)
;
var
current
1
=
nextEffect
.
alternate
;
commitLifeCycles
(
finishedRoot
current
1
nextEffect
committedExpirationTime
)
;
}
if
(
effectTag
&
Ref
)
{
recordEffect
(
)
;
commitAttachRef
(
nextEffect
)
;
}
if
(
effectTag
&
Passive
)
{
rootWithPendingPassiveEffects
=
finishedRoot
;
}
nextEffect
=
nextEffect
.
nextEffect
;
}
}
function
commitPassiveEffects
(
root
firstEffect
)
{
rootWithPendingPassiveEffects
=
null
;
passiveEffectCallbackHandle
=
null
;
passiveEffectCallback
=
null
;
var
previousIsRendering
=
isRendering
;
isRendering
=
true
;
var
effect
=
firstEffect
;
do
{
if
(
effect
.
effectTag
&
Passive
)
{
var
didError
=
false
;
var
error
=
void
0
;
{
try
{
commitPassiveHookEffects
(
effect
)
;
}
catch
(
e
)
{
didError
=
true
;
error
=
e
;
}
}
if
(
didError
)
{
captureCommitPhaseError
(
effect
error
)
;
}
}
effect
=
effect
.
nextEffect
;
}
while
(
effect
!
=
=
null
)
;
isRendering
=
previousIsRendering
;
var
rootExpirationTime
=
root
.
expirationTime
;
if
(
rootExpirationTime
!
=
=
NoWork
)
{
requestWork
(
root
rootExpirationTime
)
;
}
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performSyncWork
(
)
;
}
}
function
isAlreadyFailedLegacyErrorBoundary
(
instance
)
{
return
legacyErrorBoundariesThatAlreadyFailed
!
=
=
null
&
&
legacyErrorBoundariesThatAlreadyFailed
.
has
(
instance
)
;
}
function
markLegacyErrorBoundaryAsFailed
(
instance
)
{
if
(
legacyErrorBoundariesThatAlreadyFailed
=
=
=
null
)
{
legacyErrorBoundariesThatAlreadyFailed
=
new
Set
(
[
instance
]
)
;
}
else
{
legacyErrorBoundariesThatAlreadyFailed
.
add
(
instance
)
;
}
}
function
flushPassiveEffects
(
)
{
if
(
passiveEffectCallbackHandle
!
=
=
null
)
{
cancelPassiveEffects
(
passiveEffectCallbackHandle
)
;
}
if
(
passiveEffectCallback
!
=
=
null
)
{
passiveEffectCallback
(
)
;
}
}
function
commitRoot
(
root
finishedWork
)
{
isWorking
=
true
;
isCommitting
1
=
true
;
startCommitTimer
(
)
;
!
(
root
.
current
!
=
=
finishedWork
)
?
reactProdInvariant
(
'
177
'
)
:
void
0
;
var
committedExpirationTime
=
root
.
pendingCommitExpirationTime
;
!
(
committedExpirationTime
!
=
=
NoWork
)
?
reactProdInvariant
(
'
261
'
)
:
void
0
;
root
.
pendingCommitExpirationTime
=
NoWork
;
var
updateExpirationTimeBeforeCommit
=
finishedWork
.
expirationTime
;
var
childExpirationTimeBeforeCommit
=
finishedWork
.
childExpirationTime
;
var
earliestRemainingTimeBeforeCommit
=
childExpirationTimeBeforeCommit
>
updateExpirationTimeBeforeCommit
?
childExpirationTimeBeforeCommit
:
updateExpirationTimeBeforeCommit
;
markCommittedPriorityLevels
(
root
earliestRemainingTimeBeforeCommit
)
;
var
prevInteractions
=
null
;
if
(
enableSchedulerTracing
)
{
prevInteractions
=
__interactionsRef
.
current
;
__interactionsRef
.
current
=
root
.
memoizedInteractions
;
}
ReactCurrentOwner
2
.
current
=
null
;
var
firstEffect
=
void
0
;
if
(
finishedWork
.
effectTag
>
PerformedWork
)
{
if
(
finishedWork
.
lastEffect
!
=
=
null
)
{
finishedWork
.
lastEffect
.
nextEffect
=
finishedWork
;
firstEffect
=
finishedWork
.
firstEffect
;
}
else
{
firstEffect
=
finishedWork
;
}
}
else
{
firstEffect
=
finishedWork
.
firstEffect
;
}
prepareForCommit
(
root
.
containerInfo
)
;
nextEffect
=
firstEffect
;
startCommitSnapshotEffectsTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
didError
=
false
;
var
error
=
void
0
;
{
try
{
commitBeforeMutationLifecycles
(
)
;
}
catch
(
e
)
{
didError
=
true
;
error
=
e
;
}
}
if
(
didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
error
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
stopCommitSnapshotEffectsTimer
(
)
;
if
(
enableProfilerTimer
)
{
recordCommitTime
(
)
;
}
nextEffect
=
firstEffect
;
startCommitHostEffectsTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
_didError
=
false
;
var
_error
=
void
0
;
{
try
{
commitAllHostEffects
(
)
;
}
catch
(
e
)
{
_didError
=
true
;
_error
=
e
;
}
}
if
(
_didError
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
_error
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
stopCommitHostEffectsTimer
(
)
;
resetAfterCommit
(
root
.
containerInfo
)
;
root
.
current
=
finishedWork
;
nextEffect
=
firstEffect
;
startCommitLifeCyclesTimer
(
)
;
while
(
nextEffect
!
=
=
null
)
{
var
_didError2
=
false
;
var
_error2
=
void
0
;
{
try
{
commitAllLifeCycles
(
root
committedExpirationTime
)
;
}
catch
(
e
)
{
_didError2
=
true
;
_error2
=
e
;
}
}
if
(
_didError2
)
{
!
(
nextEffect
!
=
=
null
)
?
reactProdInvariant
(
'
178
'
)
:
void
0
;
captureCommitPhaseError
(
nextEffect
_error2
)
;
if
(
nextEffect
!
=
=
null
)
{
nextEffect
=
nextEffect
.
nextEffect
;
}
}
}
if
(
firstEffect
!
=
=
null
&
&
rootWithPendingPassiveEffects
!
=
=
null
)
{
var
callback
=
commitPassiveEffects
.
bind
(
null
root
firstEffect
)
;
if
(
enableSchedulerTracing
)
{
callback
=
unstable_wrap
(
callback
)
;
}
passiveEffectCallbackHandle
=
unstable_runWithPriority
(
unstable_NormalPriority
function
(
)
{
return
schedulePassiveEffects
(
callback
)
;
}
)
;
passiveEffectCallback
=
callback
;
}
isCommitting
1
=
false
;
isWorking
=
false
;
stopCommitLifeCyclesTimer
(
)
;
stopCommitTimer
(
)
;
onCommitRoot
(
finishedWork
.
stateNode
)
;
var
updateExpirationTimeAfterCommit
=
finishedWork
.
expirationTime
;
var
childExpirationTimeAfterCommit
=
finishedWork
.
childExpirationTime
;
var
earliestRemainingTimeAfterCommit
=
childExpirationTimeAfterCommit
>
updateExpirationTimeAfterCommit
?
childExpirationTimeAfterCommit
:
updateExpirationTimeAfterCommit
;
if
(
earliestRemainingTimeAfterCommit
=
=
=
NoWork
)
{
legacyErrorBoundariesThatAlreadyFailed
=
null
;
}
onCommit
(
root
earliestRemainingTimeAfterCommit
)
;
if
(
enableSchedulerTracing
)
{
__interactionsRef
.
current
=
prevInteractions
;
var
subscriber
=
void
0
;
try
{
subscriber
=
__subscriberRef
.
current
;
if
(
subscriber
!
=
=
null
&
&
root
.
memoizedInteractions
.
size
>
0
)
{
var
threadID
=
computeThreadID
(
committedExpirationTime
root
.
interactionThreadID
)
;
subscriber
.
onWorkStopped
(
root
.
memoizedInteractions
threadID
)
;
}
}
catch
(
error
)
{
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
finally
{
var
pendingInteractionMap
=
root
.
pendingInteractionMap
;
pendingInteractionMap
.
forEach
(
function
(
scheduledInteractions
scheduledExpirationTime
)
{
if
(
scheduledExpirationTime
>
earliestRemainingTimeAfterCommit
)
{
pendingInteractionMap
.
delete
(
scheduledExpirationTime
)
;
scheduledInteractions
.
forEach
(
function
(
interaction
)
{
interaction
.
__count
-
-
;
if
(
subscriber
!
=
=
null
&
&
interaction
.
__count
=
=
=
0
)
{
try
{
subscriber
.
onInteractionScheduledWorkCompleted
(
interaction
)
;
}
catch
(
error
)
{
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
}
}
)
;
}
}
)
;
}
}
}
function
resetChildExpirationTime
(
workInProgress
renderTime
)
{
if
(
renderTime
!
=
=
Never
&
&
workInProgress
.
childExpirationTime
=
=
=
Never
)
{
return
;
}
var
newChildExpirationTime
=
NoWork
;
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
var
actualDuration
=
workInProgress
.
actualDuration
;
var
treeBaseDuration
=
workInProgress
.
selfBaseDuration
;
var
shouldBubbleActualDurations
=
workInProgress
.
alternate
=
=
=
null
|
|
workInProgress
.
child
!
=
=
workInProgress
.
alternate
.
child
;
var
child
=
workInProgress
.
child
;
while
(
child
!
=
=
null
)
{
var
childUpdateExpirationTime
=
child
.
expirationTime
;
var
childChildExpirationTime
=
child
.
childExpirationTime
;
if
(
childUpdateExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
childUpdateExpirationTime
;
}
if
(
childChildExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
childChildExpirationTime
;
}
if
(
shouldBubbleActualDurations
)
{
actualDuration
+
=
child
.
actualDuration
;
}
treeBaseDuration
+
=
child
.
treeBaseDuration
;
child
=
child
.
sibling
;
}
workInProgress
.
actualDuration
=
actualDuration
;
workInProgress
.
treeBaseDuration
=
treeBaseDuration
;
}
else
{
var
_child
=
workInProgress
.
child
;
while
(
_child
!
=
=
null
)
{
var
_childUpdateExpirationTime
=
_child
.
expirationTime
;
var
_childChildExpirationTime
=
_child
.
childExpirationTime
;
if
(
_childUpdateExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
_childUpdateExpirationTime
;
}
if
(
_childChildExpirationTime
>
newChildExpirationTime
)
{
newChildExpirationTime
=
_childChildExpirationTime
;
}
_child
=
_child
.
sibling
;
}
}
workInProgress
.
childExpirationTime
=
newChildExpirationTime
;
}
function
completeUnitOfWork
(
workInProgress
)
{
while
(
true
)
{
var
current
1
=
workInProgress
.
alternate
;
var
returnFiber
=
workInProgress
.
return
;
var
siblingFiber
=
workInProgress
.
sibling
;
if
(
(
workInProgress
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
nextUnitOfWork
=
workInProgress
;
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
startProfilerTimer
(
workInProgress
)
;
}
nextUnitOfWork
=
completeWork
(
current
1
workInProgress
nextRenderExpirationTime
)
;
if
(
workInProgress
.
mode
&
ProfileMode
)
{
stopProfilerTimerIfRunningAndRecordDelta
(
workInProgress
false
)
;
}
}
else
{
nextUnitOfWork
=
completeWork
(
current
1
workInProgress
nextRenderExpirationTime
)
;
}
stopWorkTimer
(
workInProgress
)
;
resetChildExpirationTime
(
workInProgress
nextRenderExpirationTime
)
;
if
(
nextUnitOfWork
!
=
=
null
)
{
return
nextUnitOfWork
;
}
if
(
returnFiber
!
=
=
null
&
&
(
returnFiber
.
effectTag
&
Incomplete
)
=
=
=
NoEffect
)
{
if
(
returnFiber
.
firstEffect
=
=
=
null
)
{
returnFiber
.
firstEffect
=
workInProgress
.
firstEffect
;
}
if
(
workInProgress
.
lastEffect
!
=
=
null
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
.
firstEffect
;
}
returnFiber
.
lastEffect
=
workInProgress
.
lastEffect
;
}
var
effectTag
=
workInProgress
.
effectTag
;
if
(
effectTag
>
PerformedWork
)
{
if
(
returnFiber
.
lastEffect
!
=
=
null
)
{
returnFiber
.
lastEffect
.
nextEffect
=
workInProgress
;
}
else
{
returnFiber
.
firstEffect
=
workInProgress
;
}
returnFiber
.
lastEffect
=
workInProgress
;
}
}
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
else
if
(
returnFiber
!
=
=
null
)
{
workInProgress
=
returnFiber
;
continue
;
}
else
{
return
null
;
}
}
else
{
if
(
enableProfilerTimer
&
&
workInProgress
.
mode
&
ProfileMode
)
{
stopProfilerTimerIfRunningAndRecordDelta
(
workInProgress
false
)
;
var
actualDuration
=
workInProgress
.
actualDuration
;
var
child
=
workInProgress
.
child
;
while
(
child
!
=
=
null
)
{
actualDuration
+
=
child
.
actualDuration
;
child
=
child
.
sibling
;
}
workInProgress
.
actualDuration
=
actualDuration
;
}
var
next
=
unwindWork
(
workInProgress
nextRenderExpirationTime
)
;
if
(
workInProgress
.
effectTag
&
DidCapture
)
{
stopFailedWorkTimer
(
workInProgress
)
;
}
else
{
stopWorkTimer
(
workInProgress
)
;
}
if
(
next
!
=
=
null
)
{
stopWorkTimer
(
workInProgress
)
;
next
.
effectTag
&
=
HostEffectMask
;
return
next
;
}
if
(
returnFiber
!
=
=
null
)
{
returnFiber
.
firstEffect
=
returnFiber
.
lastEffect
=
null
;
returnFiber
.
effectTag
|
=
Incomplete
;
}
if
(
siblingFiber
!
=
=
null
)
{
return
siblingFiber
;
}
else
if
(
returnFiber
!
=
=
null
)
{
workInProgress
=
returnFiber
;
continue
;
}
else
{
return
null
;
}
}
}
return
null
;
}
function
performUnitOfWork
(
workInProgress
)
{
var
current
1
=
workInProgress
.
alternate
;
startWorkTimer
(
workInProgress
)
;
var
next
=
void
0
;
if
(
enableProfilerTimer
)
{
if
(
workInProgress
.
mode
&
ProfileMode
)
{
startProfilerTimer
(
workInProgress
)
;
}
next
=
beginWork
(
current
1
workInProgress
nextRenderExpirationTime
)
;
workInProgress
.
memoizedProps
=
workInProgress
.
pendingProps
;
if
(
workInProgress
.
mode
&
ProfileMode
)
{
stopProfilerTimerIfRunningAndRecordDelta
(
workInProgress
true
)
;
}
}
else
{
next
=
beginWork
(
current
1
workInProgress
nextRenderExpirationTime
)
;
workInProgress
.
memoizedProps
=
workInProgress
.
pendingProps
;
}
if
(
next
=
=
=
null
)
{
next
=
completeUnitOfWork
(
workInProgress
)
;
}
ReactCurrentOwner
2
.
current
=
null
;
return
next
;
}
function
workLoop
(
isYieldy
)
{
if
(
!
isYieldy
)
{
while
(
nextUnitOfWork
!
=
=
null
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
else
{
while
(
nextUnitOfWork
!
=
=
null
&
&
!
shouldYieldToRenderer
(
)
)
{
nextUnitOfWork
=
performUnitOfWork
(
nextUnitOfWork
)
;
}
}
}
function
renderRoot
(
root
isYieldy
)
{
!
!
isWorking
?
reactProdInvariant
(
'
243
'
)
:
void
0
;
flushPassiveEffects
(
)
;
isWorking
=
true
;
var
previousDispatcher
=
ReactCurrentDispatcher
.
current
;
ReactCurrentDispatcher
.
current
=
ContextOnlyDispatcher
;
var
expirationTime
=
root
.
nextExpirationTimeToWorkOn
;
if
(
expirationTime
!
=
=
nextRenderExpirationTime
|
|
root
!
=
=
nextRoot
|
|
nextUnitOfWork
=
=
=
null
)
{
resetStack
(
)
;
nextRoot
=
root
;
nextRenderExpirationTime
=
expirationTime
;
nextUnitOfWork
=
createWorkInProgress
(
nextRoot
.
current
null
nextRenderExpirationTime
)
;
root
.
pendingCommitExpirationTime
=
NoWork
;
if
(
enableSchedulerTracing
)
{
var
interactions
=
new
Set
(
)
;
root
.
pendingInteractionMap
.
forEach
(
function
(
scheduledInteractions
scheduledExpirationTime
)
{
if
(
scheduledExpirationTime
>
=
expirationTime
)
{
scheduledInteractions
.
forEach
(
function
(
interaction
)
{
return
interactions
.
add
(
interaction
)
;
}
)
;
}
}
)
;
root
.
memoizedInteractions
=
interactions
;
if
(
interactions
.
size
>
0
)
{
var
subscriber
=
__subscriberRef
.
current
;
if
(
subscriber
!
=
=
null
)
{
var
threadID
=
computeThreadID
(
expirationTime
root
.
interactionThreadID
)
;
try
{
subscriber
.
onWorkStarted
(
interactions
threadID
)
;
}
catch
(
error
)
{
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
}
}
}
}
var
prevInteractions
=
null
;
if
(
enableSchedulerTracing
)
{
prevInteractions
=
__interactionsRef
.
current
;
__interactionsRef
.
current
=
root
.
memoizedInteractions
;
}
var
didFatal
=
false
;
startWorkLoopTimer
(
nextUnitOfWork
)
;
do
{
try
{
workLoop
(
isYieldy
)
;
}
catch
(
thrownValue
)
{
resetContextDependences
(
)
;
resetHooks
(
)
;
if
(
nextUnitOfWork
=
=
=
null
)
{
didFatal
=
true
;
onUncaughtError
(
thrownValue
)
;
}
else
{
if
(
enableProfilerTimer
&
&
nextUnitOfWork
.
mode
&
ProfileMode
)
{
stopProfilerTimerIfRunningAndRecordDelta
(
nextUnitOfWork
true
)
;
}
!
(
nextUnitOfWork
!
=
=
null
)
?
reactProdInvariant
(
'
271
'
)
:
void
0
;
var
sourceFiber
=
nextUnitOfWork
;
var
returnFiber
=
sourceFiber
.
return
;
if
(
returnFiber
=
=
=
null
)
{
didFatal
=
true
;
onUncaughtError
(
thrownValue
)
;
}
else
{
throwException
(
root
returnFiber
sourceFiber
thrownValue
nextRenderExpirationTime
)
;
nextUnitOfWork
=
completeUnitOfWork
(
sourceFiber
)
;
continue
;
}
}
}
break
;
}
while
(
true
)
;
if
(
enableSchedulerTracing
)
{
__interactionsRef
.
current
=
prevInteractions
;
}
isWorking
=
false
;
ReactCurrentDispatcher
.
current
=
previousDispatcher
;
resetContextDependences
(
)
;
resetHooks
(
)
;
if
(
didFatal
)
{
var
_didCompleteRoot
=
false
;
stopWorkLoopTimer
(
interruptedBy
_didCompleteRoot
)
;
interruptedBy
=
null
;
nextRoot
=
null
;
onFatal
(
root
)
;
return
;
}
if
(
nextUnitOfWork
!
=
=
null
)
{
var
_didCompleteRoot2
=
false
;
stopWorkLoopTimer
(
interruptedBy
_didCompleteRoot2
)
;
interruptedBy
=
null
;
onYield
(
root
)
;
return
;
}
var
didCompleteRoot
=
true
;
stopWorkLoopTimer
(
interruptedBy
didCompleteRoot
)
;
var
rootWorkInProgress
=
root
.
current
.
alternate
;
!
(
rootWorkInProgress
!
=
=
null
)
?
reactProdInvariant
(
'
281
'
)
:
void
0
;
nextRoot
=
null
;
interruptedBy
=
null
;
if
(
nextRenderDidError
)
{
if
(
hasLowerPriorityWork
(
root
expirationTime
)
)
{
markSuspendedPriorityLevel
(
root
expirationTime
)
;
var
suspendedExpirationTime
=
expirationTime
;
var
rootExpirationTime
=
root
.
expirationTime
;
onSuspend
(
root
rootWorkInProgress
suspendedExpirationTime
rootExpirationTime
-
1
)
;
return
;
}
else
if
(
!
root
.
didError
&
&
isYieldy
)
{
root
.
didError
=
true
;
var
_suspendedExpirationTime
=
root
.
nextExpirationTimeToWorkOn
=
expirationTime
;
var
_rootExpirationTime
=
root
.
expirationTime
=
Sync
;
onSuspend
(
root
rootWorkInProgress
_suspendedExpirationTime
_rootExpirationTime
-
1
)
;
return
;
}
}
if
(
isYieldy
&
&
nextLatestAbsoluteTimeoutMs
!
=
=
-
1
)
{
var
_suspendedExpirationTime2
=
expirationTime
;
markSuspendedPriorityLevel
(
root
_suspendedExpirationTime2
)
;
var
earliestExpirationTime
=
findEarliestOutstandingPriorityLevel
(
root
expirationTime
)
;
var
earliestExpirationTimeMs
=
expirationTimeToMs
(
earliestExpirationTime
)
;
if
(
earliestExpirationTimeMs
<
nextLatestAbsoluteTimeoutMs
)
{
nextLatestAbsoluteTimeoutMs
=
earliestExpirationTimeMs
;
}
var
currentTimeMs
=
expirationTimeToMs
(
requestCurrentTime
(
)
)
;
var
msUntilTimeout
=
nextLatestAbsoluteTimeoutMs
-
currentTimeMs
;
msUntilTimeout
=
msUntilTimeout
<
0
?
0
:
msUntilTimeout
;
var
_rootExpirationTime2
=
root
.
expirationTime
;
onSuspend
(
root
rootWorkInProgress
_suspendedExpirationTime2
_rootExpirationTime2
msUntilTimeout
)
;
return
;
}
onComplete
(
root
rootWorkInProgress
expirationTime
)
;
}
function
captureCommitPhaseError
(
sourceFiber
value
)
{
var
expirationTime
=
Sync
;
var
fiber
=
sourceFiber
.
return
;
while
(
fiber
!
=
=
null
)
{
switch
(
fiber
.
tag
)
{
case
ClassComponent
:
var
ctor
=
fiber
.
type
;
var
instance
=
fiber
.
stateNode
;
if
(
typeof
ctor
.
getDerivedStateFromError
=
=
=
'
function
'
|
|
typeof
instance
.
componentDidCatch
=
=
=
'
function
'
&
&
!
isAlreadyFailedLegacyErrorBoundary
(
instance
)
)
{
var
errorInfo
=
createCapturedValue
(
value
sourceFiber
)
;
var
update
=
createClassErrorUpdate
(
fiber
errorInfo
expirationTime
)
;
enqueueUpdate
(
fiber
update
)
;
scheduleWork
(
fiber
expirationTime
)
;
return
;
}
break
;
case
HostRoot
:
{
var
_errorInfo
=
createCapturedValue
(
value
sourceFiber
)
;
var
_update
=
createRootErrorUpdate
(
fiber
_errorInfo
expirationTime
)
;
enqueueUpdate
(
fiber
_update
)
;
scheduleWork
(
fiber
expirationTime
)
;
return
;
}
}
fiber
=
fiber
.
return
;
}
if
(
sourceFiber
.
tag
=
=
=
HostRoot
)
{
var
rootFiber
=
sourceFiber
;
var
_errorInfo2
=
createCapturedValue
(
value
rootFiber
)
;
var
_update2
=
createRootErrorUpdate
(
rootFiber
_errorInfo2
expirationTime
)
;
enqueueUpdate
(
rootFiber
_update2
)
;
scheduleWork
(
rootFiber
expirationTime
)
;
}
}
function
computeThreadID
(
expirationTime
interactionThreadID
)
{
return
expirationTime
*
1000
+
interactionThreadID
;
}
function
computeUniqueAsyncExpiration
(
)
{
var
currentTime
=
requestCurrentTime
(
)
;
var
result
=
computeAsyncExpiration
(
currentTime
)
;
if
(
result
>
=
lastUniqueAsyncExpiration
)
{
result
=
lastUniqueAsyncExpiration
-
1
;
}
lastUniqueAsyncExpiration
=
result
;
return
lastUniqueAsyncExpiration
;
}
function
computeExpirationForFiber
(
currentTime
fiber
)
{
var
priorityLevel
=
unstable_getCurrentPriorityLevel
(
)
;
var
expirationTime
=
void
0
;
if
(
(
fiber
.
mode
&
ConcurrentMode
)
=
=
=
NoContext
)
{
expirationTime
=
Sync
;
}
else
if
(
isWorking
&
&
!
isCommitting
1
)
{
expirationTime
=
nextRenderExpirationTime
;
}
else
{
switch
(
priorityLevel
)
{
case
unstable_ImmediatePriority
:
expirationTime
=
Sync
;
break
;
case
unstable_UserBlockingPriority
:
expirationTime
=
computeInteractiveExpiration
(
currentTime
)
;
break
;
case
unstable_NormalPriority
:
expirationTime
=
computeAsyncExpiration
(
currentTime
)
;
break
;
case
unstable_LowPriority
:
case
unstable_IdlePriority
:
expirationTime
=
Never
;
break
;
default
:
reactProdInvariant
(
'
313
'
)
;
}
if
(
nextRoot
!
=
=
null
&
&
expirationTime
=
=
=
nextRenderExpirationTime
)
{
expirationTime
-
=
1
;
}
}
if
(
priorityLevel
=
=
=
unstable_UserBlockingPriority
&
&
(
lowestPriorityPendingInteractiveExpirationTime
=
=
=
NoWork
|
|
expirationTime
<
lowestPriorityPendingInteractiveExpirationTime
)
)
{
lowestPriorityPendingInteractiveExpirationTime
=
expirationTime
;
}
return
expirationTime
;
}
function
renderDidSuspend
(
root
absoluteTimeoutMs
suspendedTime
)
{
if
(
absoluteTimeoutMs
>
=
0
&
&
nextLatestAbsoluteTimeoutMs
<
absoluteTimeoutMs
)
{
nextLatestAbsoluteTimeoutMs
=
absoluteTimeoutMs
;
}
}
function
renderDidError
(
)
{
nextRenderDidError
=
true
;
}
function
pingSuspendedRoot
(
root
thenable
pingTime
)
{
var
pingCache
=
root
.
pingCache
;
if
(
pingCache
!
=
=
null
)
{
pingCache
.
delete
(
thenable
)
;
}
if
(
nextRoot
!
=
=
null
&
&
nextRenderExpirationTime
=
=
=
pingTime
)
{
nextRoot
=
null
;
}
else
{
if
(
isPriorityLevelSuspended
(
root
pingTime
)
)
{
markPingedPriorityLevel
(
root
pingTime
)
;
var
rootExpirationTime
=
root
.
expirationTime
;
if
(
rootExpirationTime
!
=
=
NoWork
)
{
requestWork
(
root
rootExpirationTime
)
;
}
}
}
}
function
retryTimedOutBoundary
(
boundaryFiber
thenable
)
{
var
retryCache
=
void
0
;
if
(
enableSuspenseServerRenderer
)
{
switch
(
boundaryFiber
.
tag
)
{
case
SuspenseComponent
:
retryCache
=
boundaryFiber
.
stateNode
;
break
;
case
DehydratedSuspenseComponent
:
retryCache
=
boundaryFiber
.
memoizedState
;
break
;
default
:
reactProdInvariant
(
'
314
'
)
;
}
}
else
{
retryCache
=
boundaryFiber
.
stateNode
;
}
if
(
retryCache
!
=
=
null
)
{
retryCache
.
delete
(
thenable
)
;
}
var
currentTime
=
requestCurrentTime
(
)
;
var
retryTime
=
computeExpirationForFiber
(
currentTime
boundaryFiber
)
;
var
root
=
scheduleWorkToRoot
(
boundaryFiber
retryTime
)
;
if
(
root
!
=
=
null
)
{
markPendingPriorityLevel
(
root
retryTime
)
;
var
rootExpirationTime
=
root
.
expirationTime
;
if
(
rootExpirationTime
!
=
=
NoWork
)
{
requestWork
(
root
rootExpirationTime
)
;
}
}
}
function
scheduleWorkToRoot
(
fiber
expirationTime
)
{
recordScheduleUpdate
(
)
;
if
(
fiber
.
expirationTime
<
expirationTime
)
{
fiber
.
expirationTime
=
expirationTime
;
}
var
alternate
=
fiber
.
alternate
;
if
(
alternate
!
=
=
null
&
&
alternate
.
expirationTime
<
expirationTime
)
{
alternate
.
expirationTime
=
expirationTime
;
}
var
node
=
fiber
.
return
;
var
root
=
null
;
if
(
node
=
=
=
null
&
&
fiber
.
tag
=
=
=
HostRoot
)
{
root
=
fiber
.
stateNode
;
}
else
{
while
(
node
!
=
=
null
)
{
alternate
=
node
.
alternate
;
if
(
node
.
childExpirationTime
<
expirationTime
)
{
node
.
childExpirationTime
=
expirationTime
;
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
expirationTime
)
{
alternate
.
childExpirationTime
=
expirationTime
;
}
}
else
if
(
alternate
!
=
=
null
&
&
alternate
.
childExpirationTime
<
expirationTime
)
{
alternate
.
childExpirationTime
=
expirationTime
;
}
if
(
node
.
return
=
=
=
null
&
&
node
.
tag
=
=
=
HostRoot
)
{
root
=
node
.
stateNode
;
break
;
}
node
=
node
.
return
;
}
}
if
(
enableSchedulerTracing
)
{
if
(
root
!
=
=
null
)
{
var
interactions
=
__interactionsRef
.
current
;
if
(
interactions
.
size
>
0
)
{
var
pendingInteractionMap
=
root
.
pendingInteractionMap
;
var
pendingInteractions
=
pendingInteractionMap
.
get
(
expirationTime
)
;
if
(
pendingInteractions
!
=
null
)
{
interactions
.
forEach
(
function
(
interaction
)
{
if
(
!
pendingInteractions
.
has
(
interaction
)
)
{
interaction
.
__count
+
+
;
}
pendingInteractions
.
add
(
interaction
)
;
}
)
;
}
else
{
pendingInteractionMap
.
set
(
expirationTime
new
Set
(
interactions
)
)
;
interactions
.
forEach
(
function
(
interaction
)
{
interaction
.
__count
+
+
;
}
)
;
}
var
subscriber
=
__subscriberRef
.
current
;
if
(
subscriber
!
=
=
null
)
{
var
threadID
=
computeThreadID
(
expirationTime
root
.
interactionThreadID
)
;
subscriber
.
onWorkScheduled
(
interactions
threadID
)
;
}
}
}
}
return
root
;
}
function
scheduleWork
(
fiber
expirationTime
)
{
var
root
=
scheduleWorkToRoot
(
fiber
expirationTime
)
;
if
(
root
=
=
=
null
)
{
return
;
}
if
(
!
isWorking
&
&
nextRenderExpirationTime
!
=
=
NoWork
&
&
expirationTime
>
nextRenderExpirationTime
)
{
interruptedBy
=
fiber
;
resetStack
(
)
;
}
markPendingPriorityLevel
(
root
expirationTime
)
;
if
(
!
isWorking
|
|
isCommitting
1
|
|
nextRoot
!
=
=
root
)
{
var
rootExpirationTime
=
root
.
expirationTime
;
requestWork
(
root
rootExpirationTime
)
;
}
if
(
nestedUpdateCount
>
NESTED_UPDATE_LIMIT
)
{
nestedUpdateCount
=
0
;
reactProdInvariant
(
'
185
'
)
;
}
}
function
syncUpdates
(
fn
a
b
c
d
)
{
return
unstable_runWithPriority
(
unstable_ImmediatePriority
function
(
)
{
return
fn
(
a
b
c
d
)
;
}
)
;
}
var
firstScheduledRoot
=
null
;
var
lastScheduledRoot
=
null
;
var
callbackExpirationTime
=
NoWork
;
var
callbackID
=
void
0
;
var
isRendering
=
false
;
var
nextFlushedRoot
=
null
;
var
nextFlushedExpirationTime
=
NoWork
;
var
lowestPriorityPendingInteractiveExpirationTime
=
NoWork
;
var
hasUnhandledError
=
false
;
var
unhandledError
=
null
;
var
isBatchingUpdates
=
false
;
var
isUnbatchingUpdates
=
false
;
var
completedBatches
=
null
;
var
originalStartTimeMs
=
unstable_now
(
)
;
var
currentRendererTime
=
msToExpirationTime
(
originalStartTimeMs
)
;
var
currentSchedulerTime
=
currentRendererTime
;
var
NESTED_UPDATE_LIMIT
=
50
;
var
nestedUpdateCount
=
0
;
var
lastCommittedRootDuringThisBatch
=
null
;
function
recomputeCurrentRendererTime
(
)
{
var
currentTimeMs
=
unstable_now
(
)
-
originalStartTimeMs
;
currentRendererTime
=
msToExpirationTime
(
currentTimeMs
)
;
}
function
scheduleCallbackWithExpirationTime
(
root
expirationTime
)
{
if
(
callbackExpirationTime
!
=
=
NoWork
)
{
if
(
expirationTime
<
callbackExpirationTime
)
{
return
;
}
else
{
if
(
callbackID
!
=
=
null
)
{
unstable_cancelCallback
(
callbackID
)
;
}
}
}
else
{
startRequestCallbackTimer
(
)
;
}
callbackExpirationTime
=
expirationTime
;
var
currentMs
=
unstable_now
(
)
-
originalStartTimeMs
;
var
expirationTimeMs
=
expirationTimeToMs
(
expirationTime
)
;
var
timeout
=
expirationTimeMs
-
currentMs
;
callbackID
=
unstable_scheduleCallback
(
performAsyncWork
{
timeout
:
timeout
}
)
;
}
function
onFatal
(
root
)
{
root
.
finishedWork
=
null
;
}
function
onComplete
(
root
finishedWork
expirationTime
)
{
root
.
pendingCommitExpirationTime
=
expirationTime
;
root
.
finishedWork
=
finishedWork
;
}
function
onSuspend
(
root
finishedWork
suspendedExpirationTime
rootExpirationTime
msUntilTimeout
)
{
root
.
expirationTime
=
rootExpirationTime
;
if
(
msUntilTimeout
=
=
=
0
&
&
!
shouldYieldToRenderer
(
)
)
{
root
.
pendingCommitExpirationTime
=
suspendedExpirationTime
;
root
.
finishedWork
=
finishedWork
;
}
else
if
(
msUntilTimeout
>
0
)
{
root
.
timeoutHandle
=
scheduleTimeout
(
onTimeout
.
bind
(
null
root
finishedWork
suspendedExpirationTime
)
msUntilTimeout
)
;
}
}
function
onYield
(
root
)
{
root
.
finishedWork
=
null
;
}
function
onTimeout
(
root
finishedWork
suspendedExpirationTime
)
{
root
.
pendingCommitExpirationTime
=
suspendedExpirationTime
;
root
.
finishedWork
=
finishedWork
;
recomputeCurrentRendererTime
(
)
;
currentSchedulerTime
=
currentRendererTime
;
flushRoot
(
root
suspendedExpirationTime
)
;
}
function
onCommit
(
root
expirationTime
)
{
root
.
expirationTime
=
expirationTime
;
root
.
finishedWork
=
null
;
}
function
requestCurrentTime
(
)
{
if
(
isRendering
)
{
return
currentSchedulerTime
;
}
findHighestPriorityRoot
(
)
;
if
(
nextFlushedExpirationTime
=
=
=
NoWork
|
|
nextFlushedExpirationTime
=
=
=
Never
)
{
recomputeCurrentRendererTime
(
)
;
currentSchedulerTime
=
currentRendererTime
;
return
currentSchedulerTime
;
}
return
currentSchedulerTime
;
}
function
requestWork
(
root
expirationTime
)
{
addRootToSchedule
(
root
expirationTime
)
;
if
(
isRendering
)
{
return
;
}
if
(
isBatchingUpdates
)
{
if
(
isUnbatchingUpdates
)
{
nextFlushedRoot
=
root
;
nextFlushedExpirationTime
=
Sync
;
performWorkOnRoot
(
root
Sync
false
)
;
}
return
;
}
if
(
expirationTime
=
=
=
Sync
)
{
performSyncWork
(
)
;
}
else
{
scheduleCallbackWithExpirationTime
(
root
expirationTime
)
;
}
}
function
addRootToSchedule
(
root
expirationTime
)
{
if
(
root
.
nextScheduledRoot
=
=
=
null
)
{
root
.
expirationTime
=
expirationTime
;
if
(
lastScheduledRoot
=
=
=
null
)
{
firstScheduledRoot
=
lastScheduledRoot
=
root
;
root
.
nextScheduledRoot
=
root
;
}
else
{
lastScheduledRoot
.
nextScheduledRoot
=
root
;
lastScheduledRoot
=
root
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
}
}
else
{
var
remainingExpirationTime
=
root
.
expirationTime
;
if
(
expirationTime
>
remainingExpirationTime
)
{
root
.
expirationTime
=
expirationTime
;
}
}
}
function
findHighestPriorityRoot
(
)
{
var
highestPriorityWork
=
NoWork
;
var
highestPriorityRoot
=
null
;
if
(
lastScheduledRoot
!
=
=
null
)
{
var
previousScheduledRoot
=
lastScheduledRoot
;
var
root
=
firstScheduledRoot
;
while
(
root
!
=
=
null
)
{
var
remainingExpirationTime
=
root
.
expirationTime
;
if
(
remainingExpirationTime
=
=
=
NoWork
)
{
!
(
previousScheduledRoot
!
=
=
null
&
&
lastScheduledRoot
!
=
=
null
)
?
reactProdInvariant
(
'
244
'
)
:
void
0
;
if
(
root
=
=
=
root
.
nextScheduledRoot
)
{
root
.
nextScheduledRoot
=
null
;
firstScheduledRoot
=
lastScheduledRoot
=
null
;
break
;
}
else
if
(
root
=
=
=
firstScheduledRoot
)
{
var
next
=
root
.
nextScheduledRoot
;
firstScheduledRoot
=
next
;
lastScheduledRoot
.
nextScheduledRoot
=
next
;
root
.
nextScheduledRoot
=
null
;
}
else
if
(
root
=
=
=
lastScheduledRoot
)
{
lastScheduledRoot
=
previousScheduledRoot
;
lastScheduledRoot
.
nextScheduledRoot
=
firstScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
break
;
}
else
{
previousScheduledRoot
.
nextScheduledRoot
=
root
.
nextScheduledRoot
;
root
.
nextScheduledRoot
=
null
;
}
root
=
previousScheduledRoot
.
nextScheduledRoot
;
}
else
{
if
(
remainingExpirationTime
>
highestPriorityWork
)
{
highestPriorityWork
=
remainingExpirationTime
;
highestPriorityRoot
=
root
;
}
if
(
root
=
=
=
lastScheduledRoot
)
{
break
;
}
if
(
highestPriorityWork
=
=
=
Sync
)
{
break
;
}
previousScheduledRoot
=
root
;
root
=
root
.
nextScheduledRoot
;
}
}
}
nextFlushedRoot
=
highestPriorityRoot
;
nextFlushedExpirationTime
=
highestPriorityWork
;
}
var
didYield
=
false
;
function
shouldYieldToRenderer
(
)
{
if
(
didYield
)
{
return
true
;
}
if
(
unstable_shouldYield
(
)
)
{
didYield
=
true
;
return
true
;
}
return
false
;
}
function
performAsyncWork
(
)
{
try
{
if
(
!
shouldYieldToRenderer
(
)
)
{
if
(
firstScheduledRoot
!
=
=
null
)
{
recomputeCurrentRendererTime
(
)
;
var
root
=
firstScheduledRoot
;
do
{
didExpireAtExpirationTime
(
root
currentRendererTime
)
;
root
=
root
.
nextScheduledRoot
;
}
while
(
root
!
=
=
firstScheduledRoot
)
;
}
}
performWork
(
NoWork
true
)
;
}
finally
{
didYield
=
false
;
}
}
function
performSyncWork
(
)
{
performWork
(
Sync
false
)
;
}
function
performWork
(
minExpirationTime
isYieldy
)
{
findHighestPriorityRoot
(
)
;
if
(
isYieldy
)
{
recomputeCurrentRendererTime
(
)
;
currentSchedulerTime
=
currentRendererTime
;
if
(
enableUserTimingAPI
)
{
var
didExpire
=
nextFlushedExpirationTime
>
currentRendererTime
;
var
timeout
=
expirationTimeToMs
(
nextFlushedExpirationTime
)
;
stopRequestCallbackTimer
(
didExpire
timeout
)
;
}
while
(
nextFlushedRoot
!
=
=
null
&
&
nextFlushedExpirationTime
!
=
=
NoWork
&
&
minExpirationTime
<
=
nextFlushedExpirationTime
&
&
!
(
didYield
&
&
currentRendererTime
>
nextFlushedExpirationTime
)
)
{
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
currentRendererTime
>
nextFlushedExpirationTime
)
;
findHighestPriorityRoot
(
)
;
recomputeCurrentRendererTime
(
)
;
currentSchedulerTime
=
currentRendererTime
;
}
}
else
{
while
(
nextFlushedRoot
!
=
=
null
&
&
nextFlushedExpirationTime
!
=
=
NoWork
&
&
minExpirationTime
<
=
nextFlushedExpirationTime
)
{
performWorkOnRoot
(
nextFlushedRoot
nextFlushedExpirationTime
false
)
;
findHighestPriorityRoot
(
)
;
}
}
if
(
isYieldy
)
{
callbackExpirationTime
=
NoWork
;
callbackID
=
null
;
}
if
(
nextFlushedExpirationTime
!
=
=
NoWork
)
{
scheduleCallbackWithExpirationTime
(
nextFlushedRoot
nextFlushedExpirationTime
)
;
}
finishRendering
(
)
;
}
function
flushRoot
(
root
expirationTime
)
{
!
!
isRendering
?
reactProdInvariant
(
'
253
'
)
:
void
0
;
nextFlushedRoot
=
root
;
nextFlushedExpirationTime
=
expirationTime
;
performWorkOnRoot
(
root
expirationTime
false
)
;
performSyncWork
(
)
;
}
function
finishRendering
(
)
{
nestedUpdateCount
=
0
;
lastCommittedRootDuringThisBatch
=
null
;
if
(
completedBatches
!
=
=
null
)
{
var
batches
=
completedBatches
;
completedBatches
=
null
;
for
(
var
i
=
0
;
i
<
batches
.
length
;
i
+
+
)
{
var
batch
=
batches
[
i
]
;
try
{
batch
.
_onComplete
(
)
;
}
catch
(
error
)
{
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
}
}
if
(
hasUnhandledError
)
{
var
error
=
unhandledError
;
unhandledError
=
null
;
hasUnhandledError
=
false
;
throw
error
;
}
}
function
performWorkOnRoot
(
root
expirationTime
isYieldy
)
{
!
!
isRendering
?
reactProdInvariant
(
'
245
'
)
:
void
0
;
isRendering
=
true
;
if
(
!
isYieldy
)
{
var
finishedWork
=
root
.
finishedWork
;
if
(
finishedWork
!
=
=
null
)
{
completeRoot
(
root
finishedWork
expirationTime
)
;
}
else
{
root
.
finishedWork
=
null
;
var
timeoutHandle
=
root
.
timeoutHandle
;
if
(
timeoutHandle
!
=
=
noTimeout
)
{
root
.
timeoutHandle
=
noTimeout
;
cancelTimeout
(
timeoutHandle
)
;
}
renderRoot
(
root
isYieldy
)
;
finishedWork
=
root
.
finishedWork
;
if
(
finishedWork
!
=
=
null
)
{
completeRoot
(
root
finishedWork
expirationTime
)
;
}
}
}
else
{
var
_finishedWork
=
root
.
finishedWork
;
if
(
_finishedWork
!
=
=
null
)
{
completeRoot
(
root
_finishedWork
expirationTime
)
;
}
else
{
root
.
finishedWork
=
null
;
var
_timeoutHandle
=
root
.
timeoutHandle
;
if
(
_timeoutHandle
!
=
=
noTimeout
)
{
root
.
timeoutHandle
=
noTimeout
;
cancelTimeout
(
_timeoutHandle
)
;
}
renderRoot
(
root
isYieldy
)
;
_finishedWork
=
root
.
finishedWork
;
if
(
_finishedWork
!
=
=
null
)
{
if
(
!
shouldYieldToRenderer
(
)
)
{
completeRoot
(
root
_finishedWork
expirationTime
)
;
}
else
{
root
.
finishedWork
=
_finishedWork
;
}
}
}
}
isRendering
=
false
;
}
function
completeRoot
(
root
finishedWork
expirationTime
)
{
var
firstBatch
=
root
.
firstBatch
;
if
(
firstBatch
!
=
=
null
&
&
firstBatch
.
_expirationTime
>
=
expirationTime
)
{
if
(
completedBatches
=
=
=
null
)
{
completedBatches
=
[
firstBatch
]
;
}
else
{
completedBatches
.
push
(
firstBatch
)
;
}
if
(
firstBatch
.
_defer
)
{
root
.
finishedWork
=
finishedWork
;
root
.
expirationTime
=
NoWork
;
return
;
}
}
root
.
finishedWork
=
null
;
if
(
root
=
=
=
lastCommittedRootDuringThisBatch
)
{
nestedUpdateCount
+
+
;
}
else
{
lastCommittedRootDuringThisBatch
=
root
;
nestedUpdateCount
=
0
;
}
unstable_runWithPriority
(
unstable_ImmediatePriority
function
(
)
{
commitRoot
(
root
finishedWork
)
;
}
)
;
}
function
onUncaughtError
(
error
)
{
!
(
nextFlushedRoot
!
=
=
null
)
?
reactProdInvariant
(
'
246
'
)
:
void
0
;
nextFlushedRoot
.
expirationTime
=
NoWork
;
if
(
!
hasUnhandledError
)
{
hasUnhandledError
=
true
;
unhandledError
=
error
;
}
}
function
batchedUpdates
1
(
fn
a
)
{
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
fn
(
a
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performSyncWork
(
)
;
}
}
}
function
unbatchedUpdates
(
fn
a
)
{
if
(
isBatchingUpdates
&
&
!
isUnbatchingUpdates
)
{
isUnbatchingUpdates
=
true
;
try
{
return
fn
(
a
)
;
}
finally
{
isUnbatchingUpdates
=
false
;
}
}
return
fn
(
a
)
;
}
function
flushSync
(
fn
a
)
{
!
!
isRendering
?
reactProdInvariant
(
'
187
'
)
:
void
0
;
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
syncUpdates
(
fn
a
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
performSyncWork
(
)
;
}
}
function
interactiveUpdates
1
(
fn
a
b
)
{
if
(
!
isBatchingUpdates
&
&
!
isRendering
&
&
lowestPriorityPendingInteractiveExpirationTime
!
=
=
NoWork
)
{
performWork
(
lowestPriorityPendingInteractiveExpirationTime
false
)
;
lowestPriorityPendingInteractiveExpirationTime
=
NoWork
;
}
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
return
unstable_runWithPriority
(
unstable_UserBlockingPriority
function
(
)
{
return
fn
(
a
b
)
;
}
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performSyncWork
(
)
;
}
}
}
function
flushInteractiveUpdates
1
(
)
{
if
(
!
isRendering
&
&
lowestPriorityPendingInteractiveExpirationTime
!
=
=
NoWork
)
{
performWork
(
lowestPriorityPendingInteractiveExpirationTime
false
)
;
lowestPriorityPendingInteractiveExpirationTime
=
NoWork
;
}
}
function
flushControlled
(
fn
)
{
var
previousIsBatchingUpdates
=
isBatchingUpdates
;
isBatchingUpdates
=
true
;
try
{
syncUpdates
(
fn
)
;
}
finally
{
isBatchingUpdates
=
previousIsBatchingUpdates
;
if
(
!
isBatchingUpdates
&
&
!
isRendering
)
{
performSyncWork
(
)
;
}
}
}
function
getContextForSubtree
(
parentComponent
)
{
if
(
!
parentComponent
)
{
return
emptyContextObject
;
}
var
fiber
=
get
(
parentComponent
)
;
var
parentContext
=
findCurrentUnmaskedContext
(
fiber
)
;
if
(
fiber
.
tag
=
=
=
ClassComponent
)
{
var
Component
=
fiber
.
type
;
if
(
isContextProvider
(
Component
)
)
{
return
processChildContext
(
fiber
Component
parentContext
)
;
}
}
return
parentContext
;
}
function
scheduleRootUpdate
(
current
1
element
expirationTime
callback
)
{
var
update
=
createUpdate
(
expirationTime
)
;
update
.
payload
=
{
element
:
element
}
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
update
.
callback
=
callback
;
}
flushPassiveEffects
(
)
;
enqueueUpdate
(
current
1
update
)
;
scheduleWork
(
current
1
expirationTime
)
;
return
expirationTime
;
}
function
updateContainerAtExpirationTime
(
element
container
parentComponent
expirationTime
callback
)
{
var
current
1
=
container
.
current
;
var
context
=
getContextForSubtree
(
parentComponent
)
;
if
(
container
.
context
=
=
=
null
)
{
container
.
context
=
context
;
}
else
{
container
.
pendingContext
=
context
;
}
return
scheduleRootUpdate
(
current
1
element
expirationTime
callback
)
;
}
function
findHostInstance
(
component
)
{
var
fiber
=
get
(
component
)
;
if
(
fiber
=
=
=
undefined
)
{
if
(
typeof
component
.
render
=
=
=
'
function
'
)
{
reactProdInvariant
(
'
188
'
)
;
}
else
{
reactProdInvariant
(
'
268
'
Object
.
keys
(
component
)
)
;
}
}
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
function
createContainer
(
containerInfo
isConcurrent
hydrate
)
{
return
createFiberRoot
(
containerInfo
isConcurrent
hydrate
)
;
}
function
updateContainer
(
element
container
parentComponent
callback
)
{
var
current
1
=
container
.
current
;
var
currentTime
=
requestCurrentTime
(
)
;
var
expirationTime
=
computeExpirationForFiber
(
currentTime
current
1
)
;
return
updateContainerAtExpirationTime
(
element
container
parentComponent
expirationTime
callback
)
;
}
function
getPublicRootInstance
(
container
)
{
var
containerFiber
=
container
.
current
;
if
(
!
containerFiber
.
child
)
{
return
null
;
}
switch
(
containerFiber
.
child
.
tag
)
{
case
HostComponent
:
return
getPublicInstance
(
containerFiber
.
child
.
stateNode
)
;
default
:
return
containerFiber
.
child
.
stateNode
;
}
}
var
overrideProps
=
null
;
function
injectIntoDevTools
(
devToolsConfig
)
{
var
findFiberByHostInstance
=
devToolsConfig
.
findFiberByHostInstance
;
var
ReactCurrentDispatcher
=
ReactSharedInternals
.
ReactCurrentDispatcher
;
return
injectInternals
(
_assign
(
{
}
devToolsConfig
{
overrideProps
:
overrideProps
currentDispatcherRef
:
ReactCurrentDispatcher
findHostInstanceByFiber
:
function
(
fiber
)
{
var
hostFiber
=
findCurrentHostFiber
(
fiber
)
;
if
(
hostFiber
=
=
=
null
)
{
return
null
;
}
return
hostFiber
.
stateNode
;
}
findFiberByHostInstance
:
function
(
instance
)
{
if
(
!
findFiberByHostInstance
)
{
return
null
;
}
return
findFiberByHostInstance
(
instance
)
;
}
}
)
)
;
}
function
createPortal
1
(
children
containerInfo
implementation
)
{
var
key
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
null
;
return
{
typeof
:
REACT_PORTAL_TYPE
key
:
key
=
=
null
?
null
:
'
'
+
key
children
:
children
containerInfo
:
containerInfo
implementation
:
implementation
}
;
}
var
ReactVersion
=
'
16
.
8
.
6
'
;
var
ReactCurrentOwner
=
ReactSharedInternals
.
ReactCurrentOwner
;
setRestoreImplementation
(
restoreControlledState
1
)
;
function
ReactBatch
(
root
)
{
var
expirationTime
=
computeUniqueAsyncExpiration
(
)
;
this
.
_expirationTime
=
expirationTime
;
this
.
_root
=
root
;
this
.
_next
=
null
;
this
.
_callbacks
=
null
;
this
.
_didComplete
=
false
;
this
.
_hasChildren
=
false
;
this
.
_children
=
null
;
this
.
_defer
=
true
;
}
ReactBatch
.
prototype
.
render
=
function
(
children
)
{
!
this
.
_defer
?
reactProdInvariant
(
'
250
'
)
:
void
0
;
this
.
_hasChildren
=
true
;
this
.
_children
=
children
;
var
internalRoot
=
this
.
_root
.
_internalRoot
;
var
expirationTime
=
this
.
_expirationTime
;
var
work
=
new
ReactWork
(
)
;
updateContainerAtExpirationTime
(
children
internalRoot
null
expirationTime
work
.
_onCommit
)
;
return
work
;
}
;
ReactBatch
.
prototype
.
then
=
function
(
onComplete
)
{
if
(
this
.
_didComplete
)
{
onComplete
(
)
;
return
;
}
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
callbacks
=
this
.
_callbacks
=
[
]
;
}
callbacks
.
push
(
onComplete
)
;
}
;
ReactBatch
.
prototype
.
commit
=
function
(
)
{
var
internalRoot
=
this
.
_root
.
_internalRoot
;
var
firstBatch
=
internalRoot
.
firstBatch
;
!
(
this
.
_defer
&
&
firstBatch
!
=
=
null
)
?
reactProdInvariant
(
'
251
'
)
:
void
0
;
if
(
!
this
.
_hasChildren
)
{
this
.
_next
=
null
;
this
.
_defer
=
false
;
return
;
}
var
expirationTime
=
this
.
_expirationTime
;
if
(
firstBatch
!
=
=
this
)
{
if
(
this
.
_hasChildren
)
{
expirationTime
=
this
.
_expirationTime
=
firstBatch
.
_expirationTime
;
this
.
render
(
this
.
_children
)
;
}
var
previous
=
null
;
var
batch
=
firstBatch
;
while
(
batch
!
=
=
this
)
{
previous
=
batch
;
batch
=
batch
.
_next
;
}
!
(
previous
!
=
=
null
)
?
reactProdInvariant
(
'
251
'
)
:
void
0
;
previous
.
_next
=
batch
.
_next
;
this
.
_next
=
firstBatch
;
firstBatch
=
internalRoot
.
firstBatch
=
this
;
}
this
.
_defer
=
false
;
flushRoot
(
internalRoot
expirationTime
)
;
var
next
=
this
.
_next
;
this
.
_next
=
null
;
firstBatch
=
internalRoot
.
firstBatch
=
next
;
if
(
firstBatch
!
=
=
null
&
&
firstBatch
.
_hasChildren
)
{
firstBatch
.
render
(
firstBatch
.
_children
)
;
}
}
;
ReactBatch
.
prototype
.
_onComplete
=
function
(
)
{
if
(
this
.
_didComplete
)
{
return
;
}
this
.
_didComplete
=
true
;
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
return
;
}
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
var
_callback
=
callbacks
[
i
]
;
_callback
(
)
;
}
}
;
function
ReactWork
(
)
{
this
.
_callbacks
=
null
;
this
.
_didCommit
=
false
;
this
.
_onCommit
=
this
.
_onCommit
.
bind
(
this
)
;
}
ReactWork
.
prototype
.
then
=
function
(
onCommit
)
{
if
(
this
.
_didCommit
)
{
onCommit
(
)
;
return
;
}
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
callbacks
=
this
.
_callbacks
=
[
]
;
}
callbacks
.
push
(
onCommit
)
;
}
;
ReactWork
.
prototype
.
_onCommit
=
function
(
)
{
if
(
this
.
_didCommit
)
{
return
;
}
this
.
_didCommit
=
true
;
var
callbacks
=
this
.
_callbacks
;
if
(
callbacks
=
=
=
null
)
{
return
;
}
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
var
_callback2
=
callbacks
[
i
]
;
!
(
typeof
_callback2
=
=
=
'
function
'
)
?
reactProdInvariant
(
'
191
'
_callback2
)
:
void
0
;
_callback2
(
)
;
}
}
;
function
ReactRoot
(
container
isConcurrent
hydrate
)
{
var
root
=
createContainer
(
container
isConcurrent
hydrate
)
;
this
.
_internalRoot
=
root
;
}
ReactRoot
.
prototype
.
render
=
function
(
children
callback
)
{
var
root
=
this
.
_internalRoot
;
var
work
=
new
ReactWork
(
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
work
.
then
(
callback
)
;
}
updateContainer
(
children
root
null
work
.
_onCommit
)
;
return
work
;
}
;
ReactRoot
.
prototype
.
unmount
=
function
(
callback
)
{
var
root
=
this
.
_internalRoot
;
var
work
=
new
ReactWork
(
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
work
.
then
(
callback
)
;
}
updateContainer
(
null
root
null
work
.
_onCommit
)
;
return
work
;
}
;
ReactRoot
.
prototype
.
legacy_renderSubtreeIntoContainer
=
function
(
parentComponent
children
callback
)
{
var
root
=
this
.
_internalRoot
;
var
work
=
new
ReactWork
(
)
;
callback
=
callback
=
=
=
undefined
?
null
:
callback
;
if
(
callback
!
=
=
null
)
{
work
.
then
(
callback
)
;
}
updateContainer
(
children
root
parentComponent
work
.
_onCommit
)
;
return
work
;
}
;
ReactRoot
.
prototype
.
createBatch
=
function
(
)
{
var
batch
=
new
ReactBatch
(
this
)
;
var
expirationTime
=
batch
.
_expirationTime
;
var
internalRoot
=
this
.
_internalRoot
;
var
firstBatch
=
internalRoot
.
firstBatch
;
if
(
firstBatch
=
=
=
null
)
{
internalRoot
.
firstBatch
=
batch
;
batch
.
_next
=
null
;
}
else
{
var
insertAfter
=
null
;
var
insertBefore
=
firstBatch
;
while
(
insertBefore
!
=
=
null
&
&
insertBefore
.
_expirationTime
>
=
expirationTime
)
{
insertAfter
=
insertBefore
;
insertBefore
=
insertBefore
.
_next
;
}
batch
.
_next
=
insertBefore
;
if
(
insertAfter
!
=
=
null
)
{
insertAfter
.
_next
=
batch
;
}
}
return
batch
;
}
;
function
isValidContainer
(
node
)
{
return
!
!
(
node
&
&
(
node
.
nodeType
=
=
=
ELEMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_NODE
|
|
node
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE
|
|
node
.
nodeType
=
=
=
COMMENT_NODE
&
&
node
.
nodeValue
=
=
=
'
react
-
mount
-
point
-
unstable
'
)
)
;
}
function
getReactRootElementInContainer
(
container
)
{
if
(
!
container
)
{
return
null
;
}
if
(
container
.
nodeType
=
=
=
DOCUMENT_NODE
)
{
return
container
.
documentElement
;
}
else
{
return
container
.
firstChild
;
}
}
function
shouldHydrateDueToLegacyHeuristic
(
container
)
{
var
rootElement
=
getReactRootElementInContainer
(
container
)
;
return
!
!
(
rootElement
&
&
rootElement
.
nodeType
=
=
=
ELEMENT_NODE
&
&
rootElement
.
hasAttribute
(
ROOT_ATTRIBUTE_NAME
)
)
;
}
setBatchingImplementation
(
batchedUpdates
1
interactiveUpdates
1
flushInteractiveUpdates
1
)
;
function
legacyCreateRootFromDOMContainer
(
container
forceHydrate
)
{
var
shouldHydrate
=
forceHydrate
|
|
shouldHydrateDueToLegacyHeuristic
(
container
)
;
if
(
!
shouldHydrate
)
{
var
rootSibling
=
void
0
;
while
(
rootSibling
=
container
.
lastChild
)
{
container
.
removeChild
(
rootSibling
)
;
}
}
var
isConcurrent
=
false
;
return
new
ReactRoot
(
container
isConcurrent
shouldHydrate
)
;
}
function
legacyRenderSubtreeIntoContainer
(
parentComponent
children
container
forceHydrate
callback
)
{
var
root
=
container
.
_reactRootContainer
;
if
(
!
root
)
{
root
=
container
.
_reactRootContainer
=
legacyCreateRootFromDOMContainer
(
container
forceHydrate
)
;
if
(
typeof
callback
=
=
=
'
function
'
)
{
var
originalCallback
=
callback
;
callback
=
function
(
)
{
var
instance
=
getPublicRootInstance
(
root
.
_internalRoot
)
;
originalCallback
.
call
(
instance
)
;
}
;
}
unbatchedUpdates
(
function
(
)
{
if
(
parentComponent
!
=
null
)
{
root
.
legacy_renderSubtreeIntoContainer
(
parentComponent
children
callback
)
;
}
else
{
root
.
render
(
children
callback
)
;
}
}
)
;
}
else
{
if
(
typeof
callback
=
=
=
'
function
'
)
{
var
_originalCallback
=
callback
;
callback
=
function
(
)
{
var
instance
=
getPublicRootInstance
(
root
.
_internalRoot
)
;
_originalCallback
.
call
(
instance
)
;
}
;
}
if
(
parentComponent
!
=
null
)
{
root
.
legacy_renderSubtreeIntoContainer
(
parentComponent
children
callback
)
;
}
else
{
root
.
render
(
children
callback
)
;
}
}
return
getPublicRootInstance
(
root
.
_internalRoot
)
;
}
function
createPortal
1
(
children
container
)
{
var
key
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
null
;
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
return
createPortal
1
(
children
container
null
key
)
;
}
var
ReactDOM
=
{
createPortal
:
createPortal
1
findDOMNode
:
function
(
componentOrElement
)
{
if
(
componentOrElement
=
=
null
)
{
return
null
;
}
if
(
componentOrElement
.
nodeType
=
=
=
ELEMENT_NODE
)
{
return
componentOrElement
;
}
return
findHostInstance
(
componentOrElement
)
;
}
hydrate
:
function
(
element
container
callback
)
{
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
return
legacyRenderSubtreeIntoContainer
(
null
element
container
true
callback
)
;
}
render
:
function
(
element
container
callback
)
{
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
return
legacyRenderSubtreeIntoContainer
(
null
element
container
false
callback
)
;
}
unstable_renderSubtreeIntoContainer
:
function
(
parentComponent
element
containerNode
callback
)
{
!
isValidContainer
(
containerNode
)
?
reactProdInvariant
(
'
200
'
)
:
void
0
;
!
(
parentComponent
!
=
null
&
&
has
(
parentComponent
)
)
?
reactProdInvariant
(
'
38
'
)
:
void
0
;
return
legacyRenderSubtreeIntoContainer
(
parentComponent
element
containerNode
false
callback
)
;
}
unmountComponentAtNode
:
function
(
container
)
{
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
40
'
)
:
void
0
;
if
(
container
.
_reactRootContainer
)
{
unbatchedUpdates
(
function
(
)
{
legacyRenderSubtreeIntoContainer
(
null
null
container
false
function
(
)
{
container
.
_reactRootContainer
=
null
;
}
)
;
}
)
;
return
true
;
}
else
{
return
false
;
}
}
unstable_createPortal
:
function
(
)
{
return
createPortal
1
.
apply
(
undefined
arguments
)
;
}
unstable_batchedUpdates
:
batchedUpdates
1
unstable_interactiveUpdates
:
interactiveUpdates
1
flushSync
:
flushSync
unstable_createRoot
:
createRoot
unstable_flushControlled
:
flushControlled
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
:
{
Events
:
[
getInstanceFromNode
1
getNodeFromInstance
1
getFiberCurrentPropsFromNode
1
injection
.
injectEventPluginsByName
eventNameDispatchConfigs
accumulateTwoPhaseDispatches
accumulateDirectDispatches
enqueueStateRestore
restoreStateIfNeeded
dispatchEvent
runEventsInBatch
]
}
}
;
function
createRoot
(
container
options
)
{
var
functionName
=
enableStableConcurrentModeAPIs
?
'
createRoot
'
:
'
unstable_createRoot
'
;
!
isValidContainer
(
container
)
?
reactProdInvariant
(
'
299
'
functionName
)
:
void
0
;
var
hydrate
=
options
!
=
null
&
&
options
.
hydrate
=
=
=
true
;
return
new
ReactRoot
(
container
true
hydrate
)
;
}
if
(
enableStableConcurrentModeAPIs
)
{
ReactDOM
.
createRoot
=
createRoot
;
ReactDOM
.
unstable_createRoot
=
undefined
;
}
var
foundDevTools
=
injectIntoDevTools
(
{
findFiberByHostInstance
:
getClosestInstanceFromNode
bundleType
:
0
version
:
ReactVersion
rendererPackageName
:
'
react
-
dom
'
}
)
;
var
ReactDOM
2
=
(
{
default
:
ReactDOM
}
)
;
var
ReactDOM
3
=
(
ReactDOM
2
&
&
ReactDOM
)
|
|
ReactDOM
2
;
var
reactDom
=
ReactDOM
3
.
default
|
|
ReactDOM
3
;
return
reactDom
;
}
)
)
)
;
