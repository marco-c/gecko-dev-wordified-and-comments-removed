const
URL
=
require
(
"
.
/
url
"
)
;
function
getArg
(
aArgs
aName
aDefaultValue
)
{
if
(
aName
in
aArgs
)
{
return
aArgs
[
aName
]
;
}
else
if
(
arguments
.
length
=
=
=
3
)
{
return
aDefaultValue
;
}
throw
new
Error
(
'
"
'
+
aName
+
'
"
is
a
required
argument
.
'
)
;
}
exports
.
getArg
=
getArg
;
const
supportsNullProto
=
(
function
(
)
{
const
obj
=
Object
.
create
(
null
)
;
return
!
(
"
__proto__
"
in
obj
)
;
}
)
(
)
;
function
identity
(
s
)
{
return
s
;
}
function
toSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
"
"
+
aStr
;
}
return
aStr
;
}
exports
.
toSetString
=
supportsNullProto
?
identity
:
toSetString
;
function
fromSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
aStr
.
slice
(
1
)
;
}
return
aStr
;
}
exports
.
fromSetString
=
supportsNullProto
?
identity
:
fromSetString
;
function
isProtoString
(
s
)
{
if
(
!
s
)
{
return
false
;
}
const
length
=
s
.
length
;
if
(
length
<
9
)
{
return
false
;
}
if
(
s
.
charCodeAt
(
length
-
1
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
2
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
3
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
4
)
!
=
=
116
|
|
s
.
charCodeAt
(
length
-
5
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
6
)
!
=
=
114
|
|
s
.
charCodeAt
(
length
-
7
)
!
=
=
112
|
|
s
.
charCodeAt
(
length
-
8
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
9
)
!
=
=
95
)
{
return
false
;
}
for
(
let
i
=
length
-
10
;
i
>
=
0
;
i
-
-
)
{
if
(
s
.
charCodeAt
(
i
)
!
=
=
36
)
{
return
false
;
}
}
return
true
;
}
function
strcmp
(
aStr1
aStr2
)
{
if
(
aStr1
=
=
=
aStr2
)
{
return
0
;
}
if
(
aStr1
=
=
=
null
)
{
return
1
;
}
if
(
aStr2
=
=
=
null
)
{
return
-
1
;
}
if
(
aStr1
>
aStr2
)
{
return
1
;
}
return
-
1
;
}
function
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
{
let
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
strcmp
(
mappingA
.
source
mappingB
.
source
)
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
strcmp
(
mappingA
.
name
mappingB
.
name
)
;
}
exports
.
compareByGeneratedPositionsInflated
=
compareByGeneratedPositionsInflated
;
function
parseSourceMapInput
(
str
)
{
return
JSON
.
parse
(
str
.
replace
(
/
^
\
)
]
}
'
[
^
\
n
]
*
\
n
/
"
"
)
)
;
}
exports
.
parseSourceMapInput
=
parseSourceMapInput
;
const
PROTOCOL
=
"
http
:
"
;
const
PROTOCOL_AND_HOST
=
{
PROTOCOL
}
/
/
host
;
function
createSafeHandler
(
cb
)
{
return
input
=
>
{
const
type
=
getURLType
(
input
)
;
const
base
=
buildSafeBase
(
input
)
;
const
url
=
new
URL
(
input
base
)
;
cb
(
url
)
;
const
result
=
url
.
toString
(
)
;
if
(
type
=
=
=
"
absolute
"
)
{
return
result
;
}
else
if
(
type
=
=
=
"
scheme
-
relative
"
)
{
return
result
.
slice
(
PROTOCOL
.
length
)
;
}
else
if
(
type
=
=
=
"
path
-
absolute
"
)
{
return
result
.
slice
(
PROTOCOL_AND_HOST
.
length
)
;
}
return
computeRelativeURL
(
base
result
)
;
}
;
}
function
withBase
(
url
base
)
{
return
new
URL
(
url
base
)
.
toString
(
)
;
}
function
buildUniqueSegment
(
prefix
str
)
{
let
id
=
0
;
do
{
const
ident
=
prefix
+
id
+
+
;
if
(
str
.
indexOf
(
ident
)
=
=
=
-
1
)
return
ident
;
}
while
(
true
)
;
}
function
buildSafeBase
(
str
)
{
const
maxDotParts
=
str
.
split
(
"
.
.
"
)
.
length
-
1
;
const
segment
=
buildUniqueSegment
(
"
p
"
str
)
;
let
base
=
{
PROTOCOL_AND_HOST
}
/
;
for
(
let
i
=
0
;
i
<
maxDotParts
;
i
+
+
)
{
base
+
=
{
segment
}
/
;
}
return
base
;
}
const
ABSOLUTE_SCHEME
=
/
^
[
A
-
Za
-
z0
-
9
\
+
\
-
\
.
]
+
:
/
;
function
getURLType
(
url
)
{
if
(
url
[
0
]
=
=
=
"
/
"
)
{
if
(
url
[
1
]
=
=
=
"
/
"
)
return
"
scheme
-
relative
"
;
return
"
path
-
absolute
"
;
}
return
ABSOLUTE_SCHEME
.
test
(
url
)
?
"
absolute
"
:
"
path
-
relative
"
;
}
function
computeRelativeURL
(
rootURL
targetURL
)
{
if
(
typeof
rootURL
=
=
=
"
string
"
)
rootURL
=
new
URL
(
rootURL
)
;
if
(
typeof
targetURL
=
=
=
"
string
"
)
targetURL
=
new
URL
(
targetURL
)
;
const
targetParts
=
targetURL
.
pathname
.
split
(
"
/
"
)
;
const
rootParts
=
rootURL
.
pathname
.
split
(
"
/
"
)
;
if
(
rootParts
.
length
>
0
&
&
!
rootParts
[
rootParts
.
length
-
1
]
)
{
rootParts
.
pop
(
)
;
}
while
(
targetParts
.
length
>
0
&
&
rootParts
.
length
>
0
&
&
targetParts
[
0
]
=
=
=
rootParts
[
0
]
)
{
targetParts
.
shift
(
)
;
rootParts
.
shift
(
)
;
}
const
relativePath
=
rootParts
.
map
(
(
)
=
>
"
.
.
"
)
.
concat
(
targetParts
)
.
join
(
"
/
"
)
;
return
relativePath
+
targetURL
.
search
+
targetURL
.
hash
;
}
const
ensureDirectory
=
createSafeHandler
(
url
=
>
{
url
.
pathname
=
url
.
pathname
.
replace
(
/
\
/
?
/
"
/
"
)
;
}
)
;
const
trimFilename
=
createSafeHandler
(
url
=
>
{
url
.
href
=
new
URL
(
"
.
"
url
.
toString
(
)
)
.
toString
(
)
;
}
)
;
const
normalize
=
createSafeHandler
(
url
=
>
{
}
)
;
exports
.
normalize
=
normalize
;
function
join
(
aRoot
aPath
)
{
const
pathType
=
getURLType
(
aPath
)
;
const
rootType
=
getURLType
(
aRoot
)
;
aRoot
=
ensureDirectory
(
aRoot
)
;
if
(
pathType
=
=
=
"
absolute
"
)
{
return
withBase
(
aPath
undefined
)
;
}
if
(
rootType
=
=
=
"
absolute
"
)
{
return
withBase
(
aPath
aRoot
)
;
}
if
(
pathType
=
=
=
"
scheme
-
relative
"
)
{
return
normalize
(
aPath
)
;
}
if
(
rootType
=
=
=
"
scheme
-
relative
"
)
{
return
withBase
(
aPath
withBase
(
aRoot
PROTOCOL_AND_HOST
)
)
.
slice
(
PROTOCOL
.
length
)
;
}
if
(
pathType
=
=
=
"
path
-
absolute
"
)
{
return
normalize
(
aPath
)
;
}
if
(
rootType
=
=
=
"
path
-
absolute
"
)
{
return
withBase
(
aPath
withBase
(
aRoot
PROTOCOL_AND_HOST
)
)
.
slice
(
PROTOCOL_AND_HOST
.
length
)
;
}
const
base
=
buildSafeBase
(
aPath
+
aRoot
)
;
const
newPath
=
withBase
(
aPath
withBase
(
aRoot
base
)
)
;
return
computeRelativeURL
(
base
newPath
)
;
}
exports
.
join
=
join
;
function
relative
(
rootURL
targetURL
)
{
const
result
=
relativeIfPossible
(
rootURL
targetURL
)
;
return
typeof
result
=
=
=
"
string
"
?
result
:
normalize
(
targetURL
)
;
}
exports
.
relative
=
relative
;
function
relativeIfPossible
(
rootURL
targetURL
)
{
const
urlType
=
getURLType
(
rootURL
)
;
if
(
urlType
!
=
=
getURLType
(
targetURL
)
)
{
return
null
;
}
const
base
=
buildSafeBase
(
rootURL
+
targetURL
)
;
const
root
=
new
URL
(
rootURL
base
)
;
const
target
=
new
URL
(
targetURL
base
)
;
try
{
new
URL
(
"
"
target
.
toString
(
)
)
;
}
catch
(
err
)
{
return
null
;
}
if
(
target
.
protocol
!
=
=
root
.
protocol
|
|
target
.
user
!
=
=
root
.
user
|
|
target
.
password
!
=
=
root
.
password
|
|
target
.
hostname
!
=
=
root
.
hostname
|
|
target
.
port
!
=
=
root
.
port
)
{
return
null
;
}
return
computeRelativeURL
(
root
target
)
;
}
function
computeSourceURL
(
sourceRoot
sourceURL
sourceMapURL
)
{
if
(
sourceRoot
&
&
getURLType
(
sourceURL
)
=
=
=
"
path
-
absolute
"
)
{
sourceURL
=
sourceURL
.
replace
(
/
^
\
/
/
"
"
)
;
}
let
url
=
normalize
(
sourceURL
|
|
"
"
)
;
if
(
sourceRoot
)
url
=
join
(
sourceRoot
url
)
;
if
(
sourceMapURL
)
url
=
join
(
trimFilename
(
sourceMapURL
)
url
)
;
return
url
;
}
exports
.
computeSourceURL
=
computeSourceURL
;
