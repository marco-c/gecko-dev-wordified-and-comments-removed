const
util
=
require
(
"
.
/
util
"
)
;
const
binarySearch
=
require
(
"
.
/
binary
-
search
"
)
;
const
ArraySet
=
require
(
"
.
/
array
-
set
"
)
.
ArraySet
;
const
base64VLQ
=
require
(
"
.
/
base64
-
vlq
"
)
;
const
readWasm
=
require
(
"
.
.
/
lib
/
read
-
wasm
"
)
;
const
wasm
=
require
(
"
.
/
wasm
"
)
;
const
INTERNAL
=
Symbol
(
"
smcInternal
"
)
;
class
SourceMapConsumer
{
constructor
(
aSourceMap
aSourceMapURL
)
{
if
(
aSourceMap
=
=
INTERNAL
)
{
return
Promise
.
resolve
(
this
)
;
}
return
_factory
(
aSourceMap
aSourceMapURL
)
;
}
static
initialize
(
opts
)
{
readWasm
.
initialize
(
opts
[
"
lib
/
mappings
.
wasm
"
]
)
;
}
static
fromSourceMap
(
aSourceMap
aSourceMapURL
)
{
return
_factoryBSM
(
aSourceMap
aSourceMapURL
)
;
}
static
async
with
(
rawSourceMap
sourceMapUrl
f
)
{
const
consumer
=
await
new
SourceMapConsumer
(
rawSourceMap
sourceMapUrl
)
;
try
{
return
await
f
(
consumer
)
;
}
finally
{
consumer
.
destroy
(
)
;
}
}
eachMapping
(
aCallback
aContext
aOrder
)
{
throw
new
Error
(
"
Subclasses
must
implement
eachMapping
"
)
;
}
allGeneratedPositionsFor
(
aArgs
)
{
throw
new
Error
(
"
Subclasses
must
implement
allGeneratedPositionsFor
"
)
;
}
destroy
(
)
{
throw
new
Error
(
"
Subclasses
must
implement
destroy
"
)
;
}
}
SourceMapConsumer
.
prototype
.
_version
=
3
;
SourceMapConsumer
.
GENERATED_ORDER
=
1
;
SourceMapConsumer
.
ORIGINAL_ORDER
=
2
;
SourceMapConsumer
.
GREATEST_LOWER_BOUND
=
1
;
SourceMapConsumer
.
LEAST_UPPER_BOUND
=
2
;
exports
.
SourceMapConsumer
=
SourceMapConsumer
;
class
BasicSourceMapConsumer
extends
SourceMapConsumer
{
constructor
(
aSourceMap
aSourceMapURL
)
{
return
super
(
INTERNAL
)
.
then
(
that
=
>
{
let
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
"
string
"
)
{
sourceMap
=
util
.
parseSourceMapInput
(
aSourceMap
)
;
}
const
version
=
util
.
getArg
(
sourceMap
"
version
"
)
;
const
sources
=
util
.
getArg
(
sourceMap
"
sources
"
)
.
map
(
String
)
;
const
names
=
util
.
getArg
(
sourceMap
"
names
"
[
]
)
;
const
sourceRoot
=
util
.
getArg
(
sourceMap
"
sourceRoot
"
null
)
;
const
sourcesContent
=
util
.
getArg
(
sourceMap
"
sourcesContent
"
null
)
;
const
mappings
=
util
.
getArg
(
sourceMap
"
mappings
"
)
;
const
file
=
util
.
getArg
(
sourceMap
"
file
"
null
)
;
const
x_google_ignoreList
=
util
.
getArg
(
sourceMap
"
x_google_ignoreList
"
null
)
;
if
(
version
!
=
that
.
_version
)
{
throw
new
Error
(
"
Unsupported
version
:
"
+
version
)
;
}
that
.
_sourceLookupCache
=
new
Map
(
)
;
that
.
_names
=
ArraySet
.
fromArray
(
names
.
map
(
String
)
true
)
;
that
.
_sources
=
ArraySet
.
fromArray
(
sources
true
)
;
that
.
_absoluteSources
=
ArraySet
.
fromArray
(
that
.
_sources
.
toArray
(
)
.
map
(
function
(
s
)
{
return
util
.
computeSourceURL
(
sourceRoot
s
aSourceMapURL
)
;
}
)
true
)
;
that
.
sourceRoot
=
sourceRoot
;
that
.
sourcesContent
=
sourcesContent
;
that
.
_mappings
=
mappings
;
that
.
_sourceMapURL
=
aSourceMapURL
;
that
.
file
=
file
;
that
.
x_google_ignoreList
=
x_google_ignoreList
;
that
.
_computedColumnSpans
=
false
;
that
.
_mappingsPtr
=
0
;
that
.
_wasm
=
null
;
return
wasm
(
)
.
then
(
w
=
>
{
that
.
_wasm
=
w
;
return
that
;
}
)
;
}
)
;
}
_findSourceIndex
(
aSource
)
{
const
cachedIndex
=
this
.
_sourceLookupCache
.
get
(
aSource
)
;
if
(
typeof
cachedIndex
=
=
=
"
number
"
)
{
return
cachedIndex
;
}
const
sourceAsMapRelative
=
util
.
computeSourceURL
(
null
aSource
this
.
_sourceMapURL
)
;
if
(
this
.
_absoluteSources
.
has
(
sourceAsMapRelative
)
)
{
const
index
=
this
.
_absoluteSources
.
indexOf
(
sourceAsMapRelative
)
;
this
.
_sourceLookupCache
.
set
(
aSource
index
)
;
return
index
;
}
const
sourceAsSourceRootRelative
=
util
.
computeSourceURL
(
this
.
sourceRoot
aSource
this
.
_sourceMapURL
)
;
if
(
this
.
_absoluteSources
.
has
(
sourceAsSourceRootRelative
)
)
{
const
index
=
this
.
_absoluteSources
.
indexOf
(
sourceAsSourceRootRelative
)
;
this
.
_sourceLookupCache
.
set
(
aSource
index
)
;
return
index
;
}
return
-
1
;
}
static
fromSourceMap
(
aSourceMap
aSourceMapURL
)
{
return
new
BasicSourceMapConsumer
(
aSourceMap
.
toString
(
)
)
;
}
get
sources
(
)
{
return
this
.
_absoluteSources
.
toArray
(
)
;
}
_getMappingsPtr
(
)
{
if
(
this
.
_mappingsPtr
=
=
=
0
)
{
this
.
_parseMappings
(
)
;
}
return
this
.
_mappingsPtr
;
}
_parseMappings
(
)
{
const
aStr
=
this
.
_mappings
;
const
size
=
aStr
.
length
;
const
mappingsBufPtr
=
this
.
_wasm
.
exports
.
allocate_mappings
(
size
)
>
>
>
0
;
const
mappingsBuf
=
new
Uint8Array
(
this
.
_wasm
.
exports
.
memory
.
buffer
mappingsBufPtr
size
)
;
for
(
let
i
=
0
;
i
<
size
;
i
+
+
)
{
mappingsBuf
[
i
]
=
aStr
.
charCodeAt
(
i
)
;
}
const
mappingsPtr
=
this
.
_wasm
.
exports
.
parse_mappings
(
mappingsBufPtr
)
;
if
(
!
mappingsPtr
)
{
const
error
=
this
.
_wasm
.
exports
.
get_last_error
(
)
;
let
msg
=
Error
parsing
mappings
(
code
{
error
}
)
:
;
switch
(
error
)
{
case
1
:
msg
+
=
"
the
mappings
contained
a
negative
line
column
source
index
or
name
index
"
;
break
;
case
2
:
msg
+
=
"
the
mappings
contained
a
number
larger
than
2
*
*
32
"
;
break
;
case
3
:
msg
+
=
"
reached
EOF
while
in
the
middle
of
parsing
a
VLQ
"
;
break
;
case
4
:
msg
+
=
"
invalid
base
64
character
while
parsing
a
VLQ
"
;
break
;
default
:
msg
+
=
"
unknown
error
code
"
;
break
;
}
throw
new
Error
(
msg
)
;
}
this
.
_mappingsPtr
=
mappingsPtr
;
}
eachMapping
(
aCallback
aContext
aOrder
)
{
const
context
=
aContext
|
|
null
;
const
order
=
aOrder
|
|
SourceMapConsumer
.
GENERATED_ORDER
;
this
.
_wasm
.
withMappingCallback
(
mapping
=
>
{
if
(
mapping
.
source
!
=
=
null
)
{
mapping
.
source
=
this
.
_absoluteSources
.
at
(
mapping
.
source
)
;
if
(
mapping
.
name
!
=
=
null
)
{
mapping
.
name
=
this
.
_names
.
at
(
mapping
.
name
)
;
}
}
if
(
this
.
_computedColumnSpans
&
&
mapping
.
lastGeneratedColumn
=
=
=
null
)
{
mapping
.
lastGeneratedColumn
=
Infinity
;
}
aCallback
.
call
(
context
mapping
)
;
}
(
)
=
>
{
switch
(
order
)
{
case
SourceMapConsumer
.
GENERATED_ORDER
:
this
.
_wasm
.
exports
.
by_generated_location
(
this
.
_getMappingsPtr
(
)
)
;
break
;
case
SourceMapConsumer
.
ORIGINAL_ORDER
:
this
.
_wasm
.
exports
.
by_original_location
(
this
.
_getMappingsPtr
(
)
)
;
break
;
default
:
throw
new
Error
(
"
Unknown
order
of
iteration
.
"
)
;
}
}
)
;
}
allGeneratedPositionsFor
(
aArgs
)
{
let
source
=
util
.
getArg
(
aArgs
"
source
"
)
;
const
originalLine
=
util
.
getArg
(
aArgs
"
line
"
)
;
const
originalColumn
=
aArgs
.
column
|
|
0
;
source
=
this
.
_findSourceIndex
(
source
)
;
if
(
source
<
0
)
{
return
[
]
;
}
if
(
originalLine
<
1
)
{
throw
new
Error
(
"
Line
numbers
must
be
>
=
1
"
)
;
}
if
(
originalColumn
<
0
)
{
throw
new
Error
(
"
Column
numbers
must
be
>
=
0
"
)
;
}
const
mappings
=
[
]
;
this
.
_wasm
.
withMappingCallback
(
m
=
>
{
let
lastColumn
=
m
.
lastGeneratedColumn
;
if
(
this
.
_computedColumnSpans
&
&
lastColumn
=
=
=
null
)
{
lastColumn
=
Infinity
;
}
mappings
.
push
(
{
line
:
m
.
generatedLine
column
:
m
.
generatedColumn
lastColumn
}
)
;
}
(
)
=
>
{
this
.
_wasm
.
exports
.
all_generated_locations_for
(
this
.
_getMappingsPtr
(
)
source
originalLine
-
1
"
column
"
in
aArgs
originalColumn
)
;
}
)
;
return
mappings
;
}
destroy
(
)
{
if
(
this
.
_mappingsPtr
!
=
=
0
)
{
this
.
_wasm
.
exports
.
free_mappings
(
this
.
_mappingsPtr
)
;
this
.
_mappingsPtr
=
0
;
}
}
computeColumnSpans
(
)
{
if
(
this
.
_computedColumnSpans
)
{
return
;
}
this
.
_wasm
.
exports
.
compute_column_spans
(
this
.
_getMappingsPtr
(
)
)
;
this
.
_computedColumnSpans
=
true
;
}
originalPositionFor
(
aArgs
)
{
const
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
"
line
"
)
generatedColumn
:
util
.
getArg
(
aArgs
"
column
"
)
}
;
if
(
needle
.
generatedLine
<
1
)
{
throw
new
Error
(
"
Line
numbers
must
be
>
=
1
"
)
;
}
if
(
needle
.
generatedColumn
<
0
)
{
throw
new
Error
(
"
Column
numbers
must
be
>
=
0
"
)
;
}
let
bias
=
util
.
getArg
(
aArgs
"
bias
"
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
;
if
(
bias
=
=
null
)
{
bias
=
SourceMapConsumer
.
GREATEST_LOWER_BOUND
;
}
let
mapping
;
this
.
_wasm
.
withMappingCallback
(
m
=
>
(
mapping
=
m
)
(
)
=
>
{
this
.
_wasm
.
exports
.
original_location_for
(
this
.
_getMappingsPtr
(
)
needle
.
generatedLine
-
1
needle
.
generatedColumn
bias
)
;
}
)
;
if
(
mapping
)
{
if
(
mapping
.
generatedLine
=
=
=
needle
.
generatedLine
)
{
let
source
=
util
.
getArg
(
mapping
"
source
"
null
)
;
if
(
source
!
=
=
null
)
{
source
=
this
.
_absoluteSources
.
at
(
source
)
;
}
let
name
=
util
.
getArg
(
mapping
"
name
"
null
)
;
if
(
name
!
=
=
null
)
{
name
=
this
.
_names
.
at
(
name
)
;
}
return
{
source
line
:
util
.
getArg
(
mapping
"
originalLine
"
null
)
column
:
util
.
getArg
(
mapping
"
originalColumn
"
null
)
name
}
;
}
}
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
hasContentsOfAllSources
(
)
{
if
(
!
this
.
sourcesContent
)
{
return
false
;
}
return
(
this
.
sourcesContent
.
length
>
=
this
.
_sources
.
size
(
)
&
&
!
this
.
sourcesContent
.
some
(
function
(
sc
)
{
return
sc
=
=
null
;
}
)
)
;
}
sourceContentFor
(
aSource
nullOnMissing
)
{
if
(
!
this
.
sourcesContent
)
{
return
null
;
}
const
index
=
this
.
_findSourceIndex
(
aSource
)
;
if
(
index
>
=
0
)
{
return
this
.
sourcesContent
[
index
]
;
}
if
(
nullOnMissing
)
{
return
null
;
}
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
generatedPositionFor
(
aArgs
)
{
let
source
=
util
.
getArg
(
aArgs
"
source
"
)
;
source
=
this
.
_findSourceIndex
(
source
)
;
if
(
source
<
0
)
{
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
const
needle
=
{
source
originalLine
:
util
.
getArg
(
aArgs
"
line
"
)
originalColumn
:
util
.
getArg
(
aArgs
"
column
"
)
}
;
if
(
needle
.
originalLine
<
1
)
{
throw
new
Error
(
"
Line
numbers
must
be
>
=
1
"
)
;
}
if
(
needle
.
originalColumn
<
0
)
{
throw
new
Error
(
"
Column
numbers
must
be
>
=
0
"
)
;
}
let
bias
=
util
.
getArg
(
aArgs
"
bias
"
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
;
if
(
bias
=
=
null
)
{
bias
=
SourceMapConsumer
.
GREATEST_LOWER_BOUND
;
}
let
mapping
;
this
.
_wasm
.
withMappingCallback
(
m
=
>
(
mapping
=
m
)
(
)
=
>
{
this
.
_wasm
.
exports
.
generated_location_for
(
this
.
_getMappingsPtr
(
)
needle
.
source
needle
.
originalLine
-
1
needle
.
originalColumn
bias
)
;
}
)
;
if
(
mapping
)
{
if
(
mapping
.
source
=
=
=
needle
.
source
)
{
let
lastColumn
=
mapping
.
lastGeneratedColumn
;
if
(
this
.
_computedColumnSpans
&
&
lastColumn
=
=
=
null
)
{
lastColumn
=
Infinity
;
}
return
{
line
:
util
.
getArg
(
mapping
"
generatedLine
"
null
)
column
:
util
.
getArg
(
mapping
"
generatedColumn
"
null
)
lastColumn
}
;
}
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
}
BasicSourceMapConsumer
.
prototype
.
consumer
=
SourceMapConsumer
;
exports
.
BasicSourceMapConsumer
=
BasicSourceMapConsumer
;
class
IndexedSourceMapConsumer
extends
SourceMapConsumer
{
constructor
(
aSourceMap
aSourceMapURL
)
{
return
super
(
INTERNAL
)
.
then
(
that
=
>
{
let
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
"
string
"
)
{
sourceMap
=
util
.
parseSourceMapInput
(
aSourceMap
)
;
}
const
version
=
util
.
getArg
(
sourceMap
"
version
"
)
;
const
sections
=
util
.
getArg
(
sourceMap
"
sections
"
)
;
if
(
version
!
=
that
.
_version
)
{
throw
new
Error
(
"
Unsupported
version
:
"
+
version
)
;
}
let
lastOffset
=
{
line
:
-
1
column
:
0
}
;
return
Promise
.
all
(
sections
.
map
(
s
=
>
{
if
(
s
.
url
)
{
throw
new
Error
(
"
Support
for
url
field
in
sections
not
implemented
.
"
)
;
}
const
offset
=
util
.
getArg
(
s
"
offset
"
)
;
const
offsetLine
=
util
.
getArg
(
offset
"
line
"
)
;
const
offsetColumn
=
util
.
getArg
(
offset
"
column
"
)
;
if
(
offsetLine
<
lastOffset
.
line
|
|
(
offsetLine
=
=
=
lastOffset
.
line
&
&
offsetColumn
<
lastOffset
.
column
)
)
{
throw
new
Error
(
"
Section
offsets
must
be
ordered
and
non
-
overlapping
.
"
)
;
}
lastOffset
=
offset
;
const
cons
=
new
SourceMapConsumer
(
util
.
getArg
(
s
"
map
"
)
aSourceMapURL
)
;
return
cons
.
then
(
consumer
=
>
{
return
{
generatedOffset
:
{
generatedLine
:
offsetLine
+
1
generatedColumn
:
offsetColumn
+
1
}
consumer
}
;
}
)
;
}
)
)
.
then
(
s
=
>
{
that
.
_sections
=
s
;
return
that
;
}
)
;
}
)
;
}
get
sources
(
)
{
const
sources
=
[
]
;
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
for
(
let
j
=
0
;
j
<
this
.
_sections
[
i
]
.
consumer
.
sources
.
length
;
j
+
+
)
{
sources
.
push
(
this
.
_sections
[
i
]
.
consumer
.
sources
[
j
]
)
;
}
}
return
sources
;
}
originalPositionFor
(
aArgs
)
{
const
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
"
line
"
)
generatedColumn
:
util
.
getArg
(
aArgs
"
column
"
)
}
;
const
sectionIndex
=
binarySearch
.
search
(
needle
this
.
_sections
function
(
aNeedle
section
)
{
const
cmp
=
aNeedle
.
generatedLine
-
section
.
generatedOffset
.
generatedLine
;
if
(
cmp
)
{
return
cmp
;
}
return
(
aNeedle
.
generatedColumn
-
section
.
generatedOffset
.
generatedColumn
)
;
}
)
;
const
section
=
this
.
_sections
[
sectionIndex
]
;
if
(
!
section
)
{
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
return
section
.
consumer
.
originalPositionFor
(
{
line
:
needle
.
generatedLine
-
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
needle
.
generatedColumn
-
(
section
.
generatedOffset
.
generatedLine
=
=
=
needle
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
bias
:
aArgs
.
bias
}
)
;
}
hasContentsOfAllSources
(
)
{
return
this
.
_sections
.
every
(
function
(
s
)
{
return
s
.
consumer
.
hasContentsOfAllSources
(
)
;
}
)
;
}
sourceContentFor
(
aSource
nullOnMissing
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
const
section
=
this
.
_sections
[
i
]
;
const
content
=
section
.
consumer
.
sourceContentFor
(
aSource
true
)
;
if
(
content
)
{
return
content
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
_findSectionIndex
(
source
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
const
{
consumer
}
=
this
.
_sections
[
i
]
;
if
(
consumer
.
_findSourceIndex
(
source
)
!
=
=
-
1
)
{
return
i
;
}
}
return
-
1
;
}
generatedPositionFor
(
aArgs
)
{
const
index
=
this
.
_findSectionIndex
(
util
.
getArg
(
aArgs
"
source
"
)
)
;
const
section
=
index
>
=
0
?
this
.
_sections
[
index
]
:
null
;
const
nextSection
=
index
>
=
0
&
&
index
+
1
<
this
.
_sections
.
length
?
this
.
_sections
[
index
+
1
]
:
null
;
const
generatedPosition
=
section
&
&
section
.
consumer
.
generatedPositionFor
(
aArgs
)
;
if
(
generatedPosition
&
&
generatedPosition
.
line
!
=
=
null
)
{
const
lineShift
=
section
.
generatedOffset
.
generatedLine
-
1
;
const
columnShift
=
section
.
generatedOffset
.
generatedColumn
-
1
;
if
(
generatedPosition
.
line
=
=
=
1
)
{
generatedPosition
.
column
+
=
columnShift
;
if
(
typeof
generatedPosition
.
lastColumn
=
=
=
"
number
"
)
{
generatedPosition
.
lastColumn
+
=
columnShift
;
}
}
if
(
generatedPosition
.
lastColumn
=
=
=
Infinity
&
&
nextSection
&
&
generatedPosition
.
line
=
=
=
nextSection
.
generatedOffset
.
generatedLine
)
{
generatedPosition
.
lastColumn
=
nextSection
.
generatedOffset
.
generatedColumn
-
2
;
}
generatedPosition
.
line
+
=
lineShift
;
return
generatedPosition
;
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
allGeneratedPositionsFor
(
aArgs
)
{
const
index
=
this
.
_findSectionIndex
(
util
.
getArg
(
aArgs
"
source
"
)
)
;
const
section
=
index
>
=
0
?
this
.
_sections
[
index
]
:
null
;
const
nextSection
=
index
>
=
0
&
&
index
+
1
<
this
.
_sections
.
length
?
this
.
_sections
[
index
+
1
]
:
null
;
if
(
!
section
)
return
[
]
;
return
section
.
consumer
.
allGeneratedPositionsFor
(
aArgs
)
.
map
(
generatedPosition
=
>
{
const
lineShift
=
section
.
generatedOffset
.
generatedLine
-
1
;
const
columnShift
=
section
.
generatedOffset
.
generatedColumn
-
1
;
if
(
generatedPosition
.
line
=
=
=
1
)
{
generatedPosition
.
column
+
=
columnShift
;
if
(
typeof
generatedPosition
.
lastColumn
=
=
=
"
number
"
)
{
generatedPosition
.
lastColumn
+
=
columnShift
;
}
}
if
(
generatedPosition
.
lastColumn
=
=
=
Infinity
&
&
nextSection
&
&
generatedPosition
.
line
=
=
=
nextSection
.
generatedOffset
.
generatedLine
)
{
generatedPosition
.
lastColumn
=
nextSection
.
generatedOffset
.
generatedColumn
-
2
;
}
generatedPosition
.
line
+
=
lineShift
;
return
generatedPosition
;
}
)
;
}
eachMapping
(
aCallback
aContext
aOrder
)
{
this
.
_sections
.
forEach
(
(
section
index
)
=
>
{
const
nextSection
=
index
+
1
<
this
.
_sections
.
length
?
this
.
_sections
[
index
+
1
]
:
null
;
const
{
generatedOffset
}
=
section
;
const
lineShift
=
generatedOffset
.
generatedLine
-
1
;
const
columnShift
=
generatedOffset
.
generatedColumn
-
1
;
section
.
consumer
.
eachMapping
(
function
(
mapping
)
{
if
(
mapping
.
generatedLine
=
=
=
1
)
{
mapping
.
generatedColumn
+
=
columnShift
;
if
(
typeof
mapping
.
lastGeneratedColumn
=
=
=
"
number
"
)
{
mapping
.
lastGeneratedColumn
+
=
columnShift
;
}
}
if
(
mapping
.
lastGeneratedColumn
=
=
=
Infinity
&
&
nextSection
&
&
mapping
.
generatedLine
=
=
=
nextSection
.
generatedOffset
.
generatedLine
)
{
mapping
.
lastGeneratedColumn
=
nextSection
.
generatedOffset
.
generatedColumn
-
2
;
}
mapping
.
generatedLine
+
=
lineShift
;
aCallback
.
call
(
this
mapping
)
;
}
aContext
aOrder
)
;
}
)
;
}
computeColumnSpans
(
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
this
.
_sections
[
i
]
.
consumer
.
computeColumnSpans
(
)
;
}
}
destroy
(
)
{
for
(
let
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
this
.
_sections
[
i
]
.
consumer
.
destroy
(
)
;
}
}
}
exports
.
IndexedSourceMapConsumer
=
IndexedSourceMapConsumer
;
function
_factory
(
aSourceMap
aSourceMapURL
)
{
let
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
"
string
"
)
{
sourceMap
=
util
.
parseSourceMapInput
(
aSourceMap
)
;
}
const
consumer
=
sourceMap
.
sections
!
=
null
?
new
IndexedSourceMapConsumer
(
sourceMap
aSourceMapURL
)
:
new
BasicSourceMapConsumer
(
sourceMap
aSourceMapURL
)
;
return
Promise
.
resolve
(
consumer
)
;
}
function
_factoryBSM
(
aSourceMap
aSourceMapURL
)
{
return
BasicSourceMapConsumer
.
fromSourceMap
(
aSourceMap
aSourceMapURL
)
;
}
