(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
factory
(
exports
require
(
'
devtools
/
client
/
shared
/
vendor
/
react
'
)
require
(
'
devtools
/
client
/
shared
/
vendor
/
redux
'
)
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
[
'
exports
'
'
devtools
/
client
/
shared
/
vendor
/
react
'
'
devtools
/
client
/
shared
/
vendor
/
redux
'
]
factory
)
:
(
factory
(
(
global
.
ReactRedux
=
{
}
)
global
.
React
global
.
Redux
)
)
;
}
(
this
(
function
(
exports
react
redux
)
{
'
use
strict
'
;
var
commonjsGlobal
=
typeof
window
!
=
=
'
undefined
'
?
window
:
typeof
global
!
=
=
'
undefined
'
?
global
:
typeof
self
!
=
=
'
undefined
'
?
self
:
{
}
;
function
createCommonjsModule
(
fn
module
)
{
return
module
=
{
exports
:
{
}
}
fn
(
module
module
.
exports
)
module
.
exports
;
}
function
makeEmptyFunction
(
arg
)
{
return
function
(
)
{
return
arg
;
}
;
}
var
emptyFunction
=
function
emptyFunction
(
)
{
}
;
emptyFunction
.
thatReturns
=
makeEmptyFunction
;
emptyFunction
.
thatReturnsFalse
=
makeEmptyFunction
(
false
)
;
emptyFunction
.
thatReturnsTrue
=
makeEmptyFunction
(
true
)
;
emptyFunction
.
thatReturnsNull
=
makeEmptyFunction
(
null
)
;
emptyFunction
.
thatReturnsThis
=
function
(
)
{
return
this
;
}
;
emptyFunction
.
thatReturnsArgument
=
function
(
arg
)
{
return
arg
;
}
;
var
emptyFunction_1
=
emptyFunction
;
var
validateFormat
=
function
validateFormat
(
format
)
{
}
;
{
validateFormat
=
function
validateFormat
(
format
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
invariant
requires
an
error
message
argument
'
)
;
}
}
;
}
function
invariant
(
condition
format
a
b
c
d
e
f
)
{
validateFormat
(
format
)
;
if
(
!
condition
)
{
var
error
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
var
invariant_1
=
invariant
;
var
warning
=
emptyFunction_1
;
{
var
printWarning
=
function
printWarning
(
format
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
var
argIndex
=
0
;
var
message
=
'
Warning
:
'
+
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
;
if
(
typeof
console
!
=
=
'
undefined
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
x
)
{
}
}
;
warning
=
function
warning
(
condition
format
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
warning
(
condition
format
.
.
.
args
)
requires
a
warning
'
+
'
message
argument
'
)
;
}
if
(
format
.
indexOf
(
'
Failed
Composite
propType
:
'
)
=
=
=
0
)
{
return
;
}
if
(
!
condition
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
>
2
?
_len2
-
2
:
0
)
_key2
=
2
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
-
2
]
=
arguments
[
_key2
]
;
}
printWarning
.
apply
(
undefined
[
format
]
.
concat
(
args
)
)
;
}
}
;
}
var
warning_1
=
warning
;
var
getOwnPropertySymbols
=
Object
.
getOwnPropertySymbols
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
var
propIsEnumerable
=
Object
.
prototype
.
propertyIsEnumerable
;
function
toObject
(
val
)
{
if
(
val
=
=
=
null
|
|
val
=
=
=
undefined
)
{
throw
new
TypeError
(
'
Object
.
assign
cannot
be
called
with
null
or
undefined
'
)
;
}
return
Object
(
val
)
;
}
function
shouldUseNative
(
)
{
try
{
if
(
!
Object
.
assign
)
{
return
false
;
}
var
test1
=
new
String
(
'
abc
'
)
;
test1
[
5
]
=
'
de
'
;
if
(
Object
.
getOwnPropertyNames
(
test1
)
[
0
]
=
=
=
'
5
'
)
{
return
false
;
}
var
test2
=
{
}
;
for
(
var
i
=
0
;
i
<
10
;
i
+
+
)
{
test2
[
'
_
'
+
String
.
fromCharCode
(
i
)
]
=
i
;
}
var
order2
=
Object
.
getOwnPropertyNames
(
test2
)
.
map
(
function
(
n
)
{
return
test2
[
n
]
;
}
)
;
if
(
order2
.
join
(
'
'
)
!
=
=
'
0123456789
'
)
{
return
false
;
}
var
test3
=
{
}
;
'
abcdefghijklmnopqrst
'
.
split
(
'
'
)
.
forEach
(
function
(
letter
)
{
test3
[
letter
]
=
letter
;
}
)
;
if
(
Object
.
keys
(
Object
.
assign
(
{
}
test3
)
)
.
join
(
'
'
)
!
=
=
'
abcdefghijklmnopqrst
'
)
{
return
false
;
}
return
true
;
}
catch
(
err
)
{
return
false
;
}
}
var
objectAssign
=
shouldUseNative
(
)
?
Object
.
assign
:
function
(
target
source
)
{
var
from
;
var
to
=
toObject
(
target
)
;
var
symbols
;
for
(
var
s
=
1
;
s
<
arguments
.
length
;
s
+
+
)
{
from
=
Object
(
arguments
[
s
]
)
;
for
(
var
key
in
from
)
{
if
(
hasOwnProperty
.
call
(
from
key
)
)
{
to
[
key
]
=
from
[
key
]
;
}
}
if
(
getOwnPropertySymbols
)
{
symbols
=
getOwnPropertySymbols
(
from
)
;
for
(
var
i
=
0
;
i
<
symbols
.
length
;
i
+
+
)
{
if
(
propIsEnumerable
.
call
(
from
symbols
[
i
]
)
)
{
to
[
symbols
[
i
]
]
=
from
[
symbols
[
i
]
]
;
}
}
}
}
return
to
;
}
;
var
ReactPropTypesSecret
=
'
SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED
'
;
var
ReactPropTypesSecret_1
=
ReactPropTypesSecret
;
{
var
invariant
1
=
invariant_1
;
var
warning
1
=
warning_1
;
var
ReactPropTypesSecret
1
=
ReactPropTypesSecret_1
;
var
loggedTypeFailures
=
{
}
;
}
function
checkPropTypes
(
typeSpecs
values
location
componentName
getStack
)
{
{
for
(
var
typeSpecName
in
typeSpecs
)
{
if
(
typeSpecs
.
hasOwnProperty
(
typeSpecName
)
)
{
var
error
;
try
{
invariant
1
(
typeof
typeSpecs
[
typeSpecName
]
=
=
=
'
function
'
'
%
s
:
%
s
type
%
s
is
invalid
;
it
must
be
a
function
usually
from
'
+
'
the
prop
-
types
package
but
received
%
s
.
'
componentName
|
|
'
React
class
'
location
typeSpecName
typeof
typeSpecs
[
typeSpecName
]
)
;
error
=
typeSpecs
[
typeSpecName
]
(
values
typeSpecName
componentName
location
null
ReactPropTypesSecret
1
)
;
}
catch
(
ex
)
{
error
=
ex
;
}
warning
1
(
!
error
|
|
error
instanceof
Error
'
%
s
:
type
specification
of
%
s
%
s
is
invalid
;
the
type
checker
'
+
'
function
must
return
null
or
an
Error
but
returned
a
%
s
.
'
+
'
You
may
have
forgotten
to
pass
an
argument
to
the
type
checker
'
+
'
creator
(
arrayOf
instanceOf
objectOf
oneOf
oneOfType
and
'
+
'
shape
all
require
an
argument
)
.
'
componentName
|
|
'
React
class
'
location
typeSpecName
typeof
error
)
;
if
(
error
instanceof
Error
&
&
!
(
error
.
message
in
loggedTypeFailures
)
)
{
loggedTypeFailures
[
error
.
message
]
=
true
;
var
stack
=
getStack
?
getStack
(
)
:
'
'
;
warning
1
(
false
'
Failed
%
s
type
:
%
s
%
s
'
location
error
.
message
stack
!
=
null
?
stack
:
'
'
)
;
}
}
}
}
}
var
checkPropTypes_1
=
checkPropTypes
;
var
factoryWithTypeCheckers
=
function
(
isValidElement
throwOnDirectAccess
)
{
var
ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
var
iteratorFn
=
maybeIterable
&
&
(
ITERATOR_SYMBOL
&
&
maybeIterable
[
ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
)
;
if
(
typeof
iteratorFn
=
=
=
'
function
'
)
{
return
iteratorFn
;
}
}
var
ANONYMOUS
=
'
<
<
anonymous
>
>
'
;
var
ReactPropTypes
=
{
array
:
createPrimitiveTypeChecker
(
'
array
'
)
bool
:
createPrimitiveTypeChecker
(
'
boolean
'
)
func
:
createPrimitiveTypeChecker
(
'
function
'
)
number
:
createPrimitiveTypeChecker
(
'
number
'
)
object
:
createPrimitiveTypeChecker
(
'
object
'
)
string
:
createPrimitiveTypeChecker
(
'
string
'
)
symbol
:
createPrimitiveTypeChecker
(
'
symbol
'
)
any
:
createAnyTypeChecker
(
)
arrayOf
:
createArrayOfTypeChecker
element
:
createElementTypeChecker
(
)
instanceOf
:
createInstanceTypeChecker
node
:
createNodeChecker
(
)
objectOf
:
createObjectOfTypeChecker
oneOf
:
createEnumTypeChecker
oneOfType
:
createUnionTypeChecker
shape
:
createShapeTypeChecker
exact
:
createStrictShapeTypeChecker
}
;
function
is
(
x
y
)
{
if
(
x
=
=
=
y
)
{
return
x
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
;
}
else
{
return
x
!
=
=
x
&
&
y
!
=
=
y
;
}
}
function
PropTypeError
(
message
)
{
this
.
message
=
message
;
this
.
stack
=
'
'
;
}
PropTypeError
.
prototype
=
Error
.
prototype
;
function
createChainableTypeChecker
(
validate
)
{
{
var
manualPropTypeCallCache
=
{
}
;
var
manualPropTypeWarningCount
=
0
;
}
function
checkType
(
isRequired
props
propName
componentName
location
propFullName
secret
)
{
componentName
=
componentName
|
|
ANONYMOUS
;
propFullName
=
propFullName
|
|
propName
;
if
(
secret
!
=
=
ReactPropTypesSecret_1
)
{
if
(
throwOnDirectAccess
)
{
invariant_1
(
false
'
Calling
PropTypes
validators
directly
is
not
supported
by
the
prop
-
types
package
.
'
+
'
Use
PropTypes
.
checkPropTypes
(
)
to
call
them
.
'
+
'
Read
more
at
http
:
/
/
fb
.
me
/
use
-
check
-
prop
-
types
'
)
;
}
else
if
(
"
development
"
!
=
=
'
production
'
&
&
typeof
console
!
=
=
'
undefined
'
)
{
var
cacheKey
=
componentName
+
'
:
'
+
propName
;
if
(
!
manualPropTypeCallCache
[
cacheKey
]
&
&
manualPropTypeWarningCount
<
3
)
{
warning_1
(
false
'
You
are
manually
calling
a
React
.
PropTypes
validation
'
+
'
function
for
the
%
s
prop
on
%
s
.
This
is
deprecated
'
+
'
and
will
throw
in
the
standalone
prop
-
types
package
.
'
+
'
You
may
be
seeing
this
warning
due
to
a
third
-
party
PropTypes
'
+
'
library
.
See
https
:
/
/
fb
.
me
/
react
-
warning
-
dont
-
call
-
proptypes
'
+
'
for
details
.
'
propFullName
componentName
)
;
manualPropTypeCallCache
[
cacheKey
]
=
true
;
manualPropTypeWarningCount
+
+
;
}
}
}
if
(
props
[
propName
]
=
=
null
)
{
if
(
isRequired
)
{
if
(
props
[
propName
]
=
=
=
null
)
{
return
new
PropTypeError
(
'
The
'
+
location
+
'
'
+
propFullName
+
'
is
marked
as
required
'
+
(
'
in
'
+
componentName
+
'
but
its
value
is
null
.
'
)
)
;
}
return
new
PropTypeError
(
'
The
'
+
location
+
'
'
+
propFullName
+
'
is
marked
as
required
in
'
+
(
'
'
+
componentName
+
'
but
its
value
is
undefined
.
'
)
)
;
}
return
null
;
}
else
{
return
validate
(
props
propName
componentName
location
propFullName
)
;
}
}
var
chainedCheckType
=
checkType
.
bind
(
null
false
)
;
chainedCheckType
.
isRequired
=
checkType
.
bind
(
null
true
)
;
return
chainedCheckType
;
}
function
createPrimitiveTypeChecker
(
expectedType
)
{
function
validate
(
props
propName
componentName
location
propFullName
secret
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
!
=
=
expectedType
)
{
var
preciseType
=
getPreciseType
(
propValue
)
;
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
preciseType
+
'
supplied
to
'
+
componentName
+
'
expected
'
)
+
(
'
'
+
expectedType
+
'
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createAnyTypeChecker
(
)
{
return
createChainableTypeChecker
(
emptyFunction_1
.
thatReturnsNull
)
;
}
function
createArrayOfTypeChecker
(
typeChecker
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
if
(
typeof
typeChecker
!
=
=
'
function
'
)
{
return
new
PropTypeError
(
'
Property
'
+
propFullName
+
'
of
component
'
+
componentName
+
'
has
invalid
PropType
notation
inside
arrayOf
.
'
)
;
}
var
propValue
=
props
[
propName
]
;
if
(
!
Array
.
isArray
(
propValue
)
)
{
var
propType
=
getPropType
(
propValue
)
;
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
propType
+
'
supplied
to
'
+
componentName
+
'
expected
an
array
.
'
)
)
;
}
for
(
var
i
=
0
;
i
<
propValue
.
length
;
i
+
+
)
{
var
error
=
typeChecker
(
propValue
i
componentName
location
propFullName
+
'
[
'
+
i
+
'
]
'
ReactPropTypesSecret_1
)
;
if
(
error
instanceof
Error
)
{
return
error
;
}
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createElementTypeChecker
(
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
if
(
!
isValidElement
(
propValue
)
)
{
var
propType
=
getPropType
(
propValue
)
;
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
propType
+
'
supplied
to
'
+
componentName
+
'
expected
a
single
ReactElement
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createInstanceTypeChecker
(
expectedClass
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
if
(
!
(
props
[
propName
]
instanceof
expectedClass
)
)
{
var
expectedClassName
=
expectedClass
.
name
|
|
ANONYMOUS
;
var
actualClassName
=
getClassName
(
props
[
propName
]
)
;
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
actualClassName
+
'
supplied
to
'
+
componentName
+
'
expected
'
)
+
(
'
instance
of
'
+
expectedClassName
+
'
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createEnumTypeChecker
(
expectedValues
)
{
if
(
!
Array
.
isArray
(
expectedValues
)
)
{
warning_1
(
false
'
Invalid
argument
supplied
to
oneOf
expected
an
instance
of
array
.
'
)
;
return
emptyFunction_1
.
thatReturnsNull
;
}
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
for
(
var
i
=
0
;
i
<
expectedValues
.
length
;
i
+
+
)
{
if
(
is
(
propValue
expectedValues
[
i
]
)
)
{
return
null
;
}
}
var
valuesString
=
JSON
.
stringify
(
expectedValues
)
;
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
value
'
+
propValue
+
'
'
+
(
'
supplied
to
'
+
componentName
+
'
expected
one
of
'
+
valuesString
+
'
.
'
)
)
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createObjectOfTypeChecker
(
typeChecker
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
if
(
typeof
typeChecker
!
=
=
'
function
'
)
{
return
new
PropTypeError
(
'
Property
'
+
propFullName
+
'
of
component
'
+
componentName
+
'
has
invalid
PropType
notation
inside
objectOf
.
'
)
;
}
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
!
=
=
'
object
'
)
{
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
propType
+
'
supplied
to
'
+
componentName
+
'
expected
an
object
.
'
)
)
;
}
for
(
var
key
in
propValue
)
{
if
(
propValue
.
hasOwnProperty
(
key
)
)
{
var
error
=
typeChecker
(
propValue
key
componentName
location
propFullName
+
'
.
'
+
key
ReactPropTypesSecret_1
)
;
if
(
error
instanceof
Error
)
{
return
error
;
}
}
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createUnionTypeChecker
(
arrayOfTypeCheckers
)
{
if
(
!
Array
.
isArray
(
arrayOfTypeCheckers
)
)
{
warning_1
(
false
'
Invalid
argument
supplied
to
oneOfType
expected
an
instance
of
array
.
'
)
;
return
emptyFunction_1
.
thatReturnsNull
;
}
for
(
var
i
=
0
;
i
<
arrayOfTypeCheckers
.
length
;
i
+
+
)
{
var
checker
=
arrayOfTypeCheckers
[
i
]
;
if
(
typeof
checker
!
=
=
'
function
'
)
{
warning_1
(
false
'
Invalid
argument
supplied
to
oneOfType
.
Expected
an
array
of
check
functions
but
'
+
'
received
%
s
at
index
%
s
.
'
getPostfixForTypeWarning
(
checker
)
i
)
;
return
emptyFunction_1
.
thatReturnsNull
;
}
}
function
validate
(
props
propName
componentName
location
propFullName
)
{
for
(
var
i
=
0
;
i
<
arrayOfTypeCheckers
.
length
;
i
+
+
)
{
var
checker
=
arrayOfTypeCheckers
[
i
]
;
if
(
checker
(
props
propName
componentName
location
propFullName
ReactPropTypesSecret_1
)
=
=
null
)
{
return
null
;
}
}
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
supplied
to
'
+
(
'
'
+
componentName
+
'
.
'
)
)
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createNodeChecker
(
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
if
(
!
isNode
(
props
[
propName
]
)
)
{
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
supplied
to
'
+
(
'
'
+
componentName
+
'
expected
a
ReactNode
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createShapeTypeChecker
(
shapeTypes
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
!
=
=
'
object
'
)
{
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
type
'
+
propType
+
'
'
+
(
'
supplied
to
'
+
componentName
+
'
expected
object
.
'
)
)
;
}
for
(
var
key
in
shapeTypes
)
{
var
checker
=
shapeTypes
[
key
]
;
if
(
!
checker
)
{
continue
;
}
var
error
=
checker
(
propValue
key
componentName
location
propFullName
+
'
.
'
+
key
ReactPropTypesSecret_1
)
;
if
(
error
)
{
return
error
;
}
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createStrictShapeTypeChecker
(
shapeTypes
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
!
=
=
'
object
'
)
{
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
of
type
'
+
propType
+
'
'
+
(
'
supplied
to
'
+
componentName
+
'
expected
object
.
'
)
)
;
}
var
allKeys
=
objectAssign
(
{
}
props
[
propName
]
shapeTypes
)
;
for
(
var
key
in
allKeys
)
{
var
checker
=
shapeTypes
[
key
]
;
if
(
!
checker
)
{
return
new
PropTypeError
(
'
Invalid
'
+
location
+
'
'
+
propFullName
+
'
key
'
+
key
+
'
supplied
to
'
+
componentName
+
'
.
'
+
'
\
nBad
object
:
'
+
JSON
.
stringify
(
props
[
propName
]
null
'
'
)
+
'
\
nValid
keys
:
'
+
JSON
.
stringify
(
Object
.
keys
(
shapeTypes
)
null
'
'
)
)
;
}
var
error
=
checker
(
propValue
key
componentName
location
propFullName
+
'
.
'
+
key
ReactPropTypesSecret_1
)
;
if
(
error
)
{
return
error
;
}
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
isNode
(
propValue
)
{
switch
(
typeof
propValue
)
{
case
'
number
'
:
case
'
string
'
:
case
'
undefined
'
:
return
true
;
case
'
boolean
'
:
return
!
propValue
;
case
'
object
'
:
if
(
Array
.
isArray
(
propValue
)
)
{
return
propValue
.
every
(
isNode
)
;
}
if
(
propValue
=
=
=
null
|
|
isValidElement
(
propValue
)
)
{
return
true
;
}
var
iteratorFn
=
getIteratorFn
(
propValue
)
;
if
(
iteratorFn
)
{
var
iterator
=
iteratorFn
.
call
(
propValue
)
;
var
step
;
if
(
iteratorFn
!
=
=
propValue
.
entries
)
{
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
if
(
!
isNode
(
step
.
value
)
)
{
return
false
;
}
}
}
else
{
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
var
entry
=
step
.
value
;
if
(
entry
)
{
if
(
!
isNode
(
entry
[
1
]
)
)
{
return
false
;
}
}
}
}
}
else
{
return
false
;
}
return
true
;
default
:
return
false
;
}
}
function
isSymbol
(
propType
propValue
)
{
if
(
propType
=
=
=
'
symbol
'
)
{
return
true
;
}
if
(
propValue
[
'
toStringTag
'
]
=
=
=
'
Symbol
'
)
{
return
true
;
}
if
(
typeof
Symbol
=
=
=
'
function
'
&
&
propValue
instanceof
Symbol
)
{
return
true
;
}
return
false
;
}
function
getPropType
(
propValue
)
{
var
propType
=
typeof
propValue
;
if
(
Array
.
isArray
(
propValue
)
)
{
return
'
array
'
;
}
if
(
propValue
instanceof
RegExp
)
{
return
'
object
'
;
}
if
(
isSymbol
(
propType
propValue
)
)
{
return
'
symbol
'
;
}
return
propType
;
}
function
getPreciseType
(
propValue
)
{
if
(
typeof
propValue
=
=
=
'
undefined
'
|
|
propValue
=
=
=
null
)
{
return
'
'
+
propValue
;
}
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
=
=
=
'
object
'
)
{
if
(
propValue
instanceof
Date
)
{
return
'
date
'
;
}
else
if
(
propValue
instanceof
RegExp
)
{
return
'
regexp
'
;
}
}
return
propType
;
}
function
getPostfixForTypeWarning
(
value
)
{
var
type
=
getPreciseType
(
value
)
;
switch
(
type
)
{
case
'
array
'
:
case
'
object
'
:
return
'
an
'
+
type
;
case
'
boolean
'
:
case
'
date
'
:
case
'
regexp
'
:
return
'
a
'
+
type
;
default
:
return
type
;
}
}
function
getClassName
(
propValue
)
{
if
(
!
propValue
.
constructor
|
|
!
propValue
.
constructor
.
name
)
{
return
ANONYMOUS
;
}
return
propValue
.
constructor
.
name
;
}
ReactPropTypes
.
checkPropTypes
=
checkPropTypes_1
;
ReactPropTypes
.
PropTypes
=
ReactPropTypes
;
return
ReactPropTypes
;
}
;
var
propTypes
=
createCommonjsModule
(
function
(
module
)
{
{
var
REACT_ELEMENT_TYPE
=
(
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
for
&
&
Symbol
.
for
(
'
react
.
element
'
)
)
|
|
0xeac7
;
var
isValidElement
=
function
(
object
)
{
return
typeof
object
=
=
=
'
object
'
&
&
object
!
=
=
null
&
&
object
.
typeof
=
=
=
REACT_ELEMENT_TYPE
;
}
;
var
throwOnDirectAccess
=
true
;
module
.
exports
=
factoryWithTypeCheckers
(
isValidElement
throwOnDirectAccess
)
;
}
}
)
;
var
subscriptionShape
=
propTypes
.
shape
(
{
trySubscribe
:
propTypes
.
func
.
isRequired
tryUnsubscribe
:
propTypes
.
func
.
isRequired
notifyNestedSubs
:
propTypes
.
func
.
isRequired
isSubscribed
:
propTypes
.
func
.
isRequired
}
)
;
var
storeShape
=
propTypes
.
shape
(
{
subscribe
:
propTypes
.
func
.
isRequired
dispatch
:
propTypes
.
func
.
isRequired
getState
:
propTypes
.
func
.
isRequired
}
)
;
function
warning
2
(
message
)
{
if
(
typeof
console
!
=
=
'
undefined
'
&
&
typeof
console
.
error
=
=
=
'
function
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
e
)
{
}
}
var
classCallCheck
=
function
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
inherits
=
function
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
;
var
objectWithoutProperties
=
function
(
obj
keys
)
{
var
target
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
keys
.
indexOf
(
i
)
>
=
0
)
continue
;
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
continue
;
target
[
i
]
=
obj
[
i
]
;
}
return
target
;
}
;
var
possibleConstructorReturn
=
function
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
;
var
didWarnAboutReceivingStore
=
false
;
function
warnAboutReceivingStore
(
)
{
if
(
didWarnAboutReceivingStore
)
{
return
;
}
didWarnAboutReceivingStore
=
true
;
warning
2
(
'
<
Provider
>
does
not
support
changing
store
on
the
fly
.
'
+
'
It
is
most
likely
that
you
see
this
error
because
you
updated
to
'
+
'
Redux
2
.
x
and
React
Redux
2
.
x
which
no
longer
hot
reload
reducers
'
+
'
automatically
.
See
https
:
/
/
github
.
com
/
reactjs
/
react
-
redux
/
releases
/
'
+
'
tag
/
v2
.
0
.
0
for
the
migration
instructions
.
'
)
;
}
function
createProvider
(
)
{
var
_Provider
childContex
;
var
storeKey
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
'
store
'
;
var
subKey
=
arguments
[
1
]
;
var
subscriptionKey
=
subKey
|
|
storeKey
+
'
Subscription
'
;
var
Provider
=
function
(
_Component
)
{
inherits
(
Provider
_Component
)
;
Provider
.
prototype
.
getChildContext
=
function
getChildContext
(
)
{
var
_ref
;
return
_ref
=
{
}
_ref
[
storeKey
]
=
this
[
storeKey
]
_ref
[
subscriptionKey
]
=
null
_ref
;
}
;
function
Provider
(
props
context
)
{
classCallCheck
(
this
Provider
)
;
var
_this
=
possibleConstructorReturn
(
this
_Component
.
call
(
this
props
context
)
)
;
_this
[
storeKey
]
=
props
.
store
;
return
_this
;
}
Provider
.
prototype
.
render
=
function
render
(
)
{
return
react
.
Children
.
only
(
this
.
props
.
children
)
;
}
;
return
Provider
;
}
(
react
.
Component
)
;
{
Provider
.
prototype
.
componentWillReceiveProps
=
function
(
nextProps
)
{
if
(
this
[
storeKey
]
!
=
=
nextProps
.
store
)
{
warnAboutReceivingStore
(
)
;
}
}
;
}
Provider
.
propTypes
=
{
store
:
storeShape
.
isRequired
children
:
propTypes
.
element
.
isRequired
}
;
Provider
.
childContextTypes
=
(
_Provider
childContex
=
{
}
_Provider
childContex
[
storeKey
]
=
storeShape
.
isRequired
_Provider
childContex
[
subscriptionKey
]
=
subscriptionShape
_Provider
childContex
)
;
return
Provider
;
}
var
Provider
=
createProvider
(
)
;
var
hoistNonReactStatics
=
createCommonjsModule
(
function
(
module
exports
)
{
(
function
(
global
factory
)
{
module
.
exports
=
factory
(
)
;
}
(
commonjsGlobal
(
function
(
)
{
var
REACT_STATICS
=
{
childContextTypes
:
true
contextTypes
:
true
defaultProps
:
true
displayName
:
true
getDefaultProps
:
true
getDerivedStateFromProps
:
true
mixins
:
true
propTypes
:
true
type
:
true
}
;
var
KNOWN_STATICS
=
{
name
:
true
length
:
true
prototype
:
true
caller
:
true
callee
:
true
arguments
:
true
arity
:
true
}
;
var
defineProperty
=
Object
.
defineProperty
;
var
getOwnPropertyNames
=
Object
.
getOwnPropertyNames
;
var
getOwnPropertySymbols
=
Object
.
getOwnPropertySymbols
;
var
getOwnPropertyDescriptor
=
Object
.
getOwnPropertyDescriptor
;
var
getPrototypeOf
=
Object
.
getPrototypeOf
;
var
objectPrototype
=
getPrototypeOf
&
&
getPrototypeOf
(
Object
)
;
return
function
hoistNonReactStatics
(
targetComponent
sourceComponent
blacklist
)
{
if
(
typeof
sourceComponent
!
=
=
'
string
'
)
{
if
(
objectPrototype
)
{
var
inheritedComponent
=
getPrototypeOf
(
sourceComponent
)
;
if
(
inheritedComponent
&
&
inheritedComponent
!
=
=
objectPrototype
)
{
hoistNonReactStatics
(
targetComponent
inheritedComponent
blacklist
)
;
}
}
var
keys
=
getOwnPropertyNames
(
sourceComponent
)
;
if
(
getOwnPropertySymbols
)
{
keys
=
keys
.
concat
(
getOwnPropertySymbols
(
sourceComponent
)
)
;
}
for
(
var
i
=
0
;
i
<
keys
.
length
;
+
+
i
)
{
var
key
=
keys
[
i
]
;
if
(
!
REACT_STATICS
[
key
]
&
&
!
KNOWN_STATICS
[
key
]
&
&
(
!
blacklist
|
|
!
blacklist
[
key
]
)
)
{
var
descriptor
=
getOwnPropertyDescriptor
(
sourceComponent
key
)
;
try
{
defineProperty
(
targetComponent
key
descriptor
)
;
}
catch
(
e
)
{
}
}
}
return
targetComponent
;
}
return
targetComponent
;
}
;
}
)
)
)
;
}
)
;
var
NODE_ENV
=
"
development
"
;
var
invariant
2
=
function
(
condition
format
a
b
c
d
e
f
)
{
if
(
NODE_ENV
!
=
=
'
production
'
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
invariant
requires
an
error
message
argument
'
)
;
}
}
if
(
!
condition
)
{
var
error
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
;
var
invariant_1
2
=
invariant
2
;
var
CLEARED
=
null
;
var
nullListeners
=
{
notify
:
function
notify
(
)
{
}
}
;
function
createListenerCollection
(
)
{
var
current
=
[
]
;
var
next
=
[
]
;
return
{
clear
:
function
clear
(
)
{
next
=
CLEARED
;
current
=
CLEARED
;
}
notify
:
function
notify
(
)
{
var
listeners
=
current
=
next
;
for
(
var
i
=
0
;
i
<
listeners
.
length
;
i
+
+
)
{
listeners
[
i
]
(
)
;
}
}
get
:
function
get
1
(
)
{
return
next
;
}
subscribe
:
function
subscribe
(
listener
)
{
var
isSubscribed
=
true
;
if
(
next
=
=
=
current
)
next
=
current
.
slice
(
)
;
next
.
push
(
listener
)
;
return
function
unsubscribe
(
)
{
if
(
!
isSubscribed
|
|
current
=
=
=
CLEARED
)
return
;
isSubscribed
=
false
;
if
(
next
=
=
=
current
)
next
=
current
.
slice
(
)
;
next
.
splice
(
next
.
indexOf
(
listener
)
1
)
;
}
;
}
}
;
}
var
Subscription
=
function
(
)
{
function
Subscription
(
store
parentSub
onStateChange
)
{
classCallCheck
(
this
Subscription
)
;
this
.
store
=
store
;
this
.
parentSub
=
parentSub
;
this
.
onStateChange
=
onStateChange
;
this
.
unsubscribe
=
null
;
this
.
listeners
=
nullListeners
;
}
Subscription
.
prototype
.
addNestedSub
=
function
addNestedSub
(
listener
)
{
this
.
trySubscribe
(
)
;
return
this
.
listeners
.
subscribe
(
listener
)
;
}
;
Subscription
.
prototype
.
notifyNestedSubs
=
function
notifyNestedSubs
(
)
{
this
.
listeners
.
notify
(
)
;
}
;
Subscription
.
prototype
.
isSubscribed
=
function
isSubscribed
(
)
{
return
Boolean
(
this
.
unsubscribe
)
;
}
;
Subscription
.
prototype
.
trySubscribe
=
function
trySubscribe
(
)
{
if
(
!
this
.
unsubscribe
)
{
this
.
unsubscribe
=
this
.
parentSub
?
this
.
parentSub
.
addNestedSub
(
this
.
onStateChange
)
:
this
.
store
.
subscribe
(
this
.
onStateChange
)
;
this
.
listeners
=
createListenerCollection
(
)
;
}
}
;
Subscription
.
prototype
.
tryUnsubscribe
=
function
tryUnsubscribe
(
)
{
if
(
this
.
unsubscribe
)
{
this
.
unsubscribe
(
)
;
this
.
unsubscribe
=
null
;
this
.
listeners
.
clear
(
)
;
this
.
listeners
=
nullListeners
;
}
}
;
return
Subscription
;
}
(
)
;
var
hotReloadingVersion
=
0
;
var
dummyState
=
{
}
;
function
noop
(
)
{
}
function
makeSelectorStateful
(
sourceSelector
store
)
{
var
selector
=
{
run
:
function
runComponentSelector
(
props
)
{
try
{
var
nextProps
=
sourceSelector
(
store
.
getState
(
)
props
)
;
if
(
nextProps
!
=
=
selector
.
props
|
|
selector
.
error
)
{
selector
.
shouldComponentUpdate
=
true
;
selector
.
props
=
nextProps
;
selector
.
error
=
null
;
}
}
catch
(
error
)
{
selector
.
shouldComponentUpdate
=
true
;
selector
.
error
=
error
;
}
}
}
;
return
selector
;
}
function
connectAdvanced
(
selectorFactory
)
{
var
_contextTypes
_childContextTypes
;
var
_ref
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
_ref
getDisplayName
=
_ref
.
getDisplayName
getDisplayName
=
_ref
getDisplayName
=
=
=
undefined
?
function
(
name
)
{
return
'
ConnectAdvanced
(
'
+
name
+
'
)
'
;
}
:
_ref
getDisplayName
_ref
methodName
=
_ref
.
methodName
methodName
=
_ref
methodName
=
=
=
undefined
?
'
connectAdvanced
'
:
_ref
methodName
_ref
renderCountProp
=
_ref
.
renderCountProp
renderCountProp
=
_ref
renderCountProp
=
=
=
undefined
?
undefined
:
_ref
renderCountProp
_ref
shouldHandleStat
=
_ref
.
shouldHandleStateChanges
shouldHandleStateChanges
=
_ref
shouldHandleStat
=
=
=
undefined
?
true
:
_ref
shouldHandleStat
_ref
storeKey
=
_ref
.
storeKey
storeKey
=
_ref
storeKey
=
=
=
undefined
?
'
store
'
:
_ref
storeKey
_ref
withRef
=
_ref
.
withRef
withRef
=
_ref
withRef
=
=
=
undefined
?
false
:
_ref
withRef
connectOptions
=
objectWithoutProperties
(
_ref
[
'
getDisplayName
'
'
methodName
'
'
renderCountProp
'
'
shouldHandleStateChanges
'
'
storeKey
'
'
withRef
'
]
)
;
var
subscriptionKey
=
storeKey
+
'
Subscription
'
;
var
version
=
hotReloadingVersion
+
+
;
var
contextTypes
=
(
_contextTypes
=
{
}
_contextTypes
[
storeKey
]
=
storeShape
_contextTypes
[
subscriptionKey
]
=
subscriptionShape
_contextTypes
)
;
var
childContextTypes
=
(
_childContextTypes
=
{
}
_childContextTypes
[
subscriptionKey
]
=
subscriptionShape
_childContextTypes
)
;
return
function
wrapWithConnect
(
WrappedComponent
)
{
invariant_1
2
(
typeof
WrappedComponent
=
=
'
function
'
'
You
must
pass
a
component
to
the
function
returned
by
'
+
(
methodName
+
'
.
Instead
received
'
+
JSON
.
stringify
(
WrappedComponent
)
)
)
;
var
wrappedComponentName
=
WrappedComponent
.
displayName
|
|
WrappedComponent
.
name
|
|
'
Component
'
;
var
displayName
=
getDisplayName
(
wrappedComponentName
)
;
var
selectorFactoryOptions
=
_extends
(
{
}
connectOptions
{
getDisplayName
:
getDisplayName
methodName
:
methodName
renderCountProp
:
renderCountProp
shouldHandleStateChanges
:
shouldHandleStateChanges
storeKey
:
storeKey
withRef
:
withRef
displayName
:
displayName
wrappedComponentName
:
wrappedComponentName
WrappedComponent
:
WrappedComponent
}
)
;
var
Connect
=
function
(
_Component
)
{
inherits
(
Connect
_Component
)
;
function
Connect
(
props
context
)
{
classCallCheck
(
this
Connect
)
;
var
_this
=
possibleConstructorReturn
(
this
_Component
.
call
(
this
props
context
)
)
;
_this
.
version
=
version
;
_this
.
state
=
{
}
;
_this
.
renderCount
=
0
;
_this
.
store
=
props
[
storeKey
]
|
|
context
[
storeKey
]
;
_this
.
propsMode
=
Boolean
(
props
[
storeKey
]
)
;
_this
.
setWrappedInstance
=
_this
.
setWrappedInstance
.
bind
(
_this
)
;
invariant_1
2
(
_this
.
store
'
Could
not
find
"
'
+
storeKey
+
'
"
in
either
the
context
or
props
of
'
+
(
'
"
'
+
displayName
+
'
"
.
Either
wrap
the
root
component
in
a
<
Provider
>
'
)
+
(
'
or
explicitly
pass
"
'
+
storeKey
+
'
"
as
a
prop
to
"
'
+
displayName
+
'
"
.
'
)
)
;
_this
.
initSelector
(
)
;
_this
.
initSubscription
(
)
;
return
_this
;
}
Connect
.
prototype
.
getChildContext
=
function
getChildContext
(
)
{
var
_ref2
;
var
subscription
=
this
.
propsMode
?
null
:
this
.
subscription
;
return
_ref2
=
{
}
_ref2
[
subscriptionKey
]
=
subscription
|
|
this
.
context
[
subscriptionKey
]
_ref2
;
}
;
Connect
.
prototype
.
componentDidMount
=
function
componentDidMount
(
)
{
if
(
!
shouldHandleStateChanges
)
return
;
this
.
subscription
.
trySubscribe
(
)
;
this
.
selector
.
run
(
this
.
props
)
;
if
(
this
.
selector
.
shouldComponentUpdate
)
this
.
forceUpdate
(
)
;
}
;
Connect
.
prototype
.
componentWillReceiveProps
=
function
componentWillReceiveProps
(
nextProps
)
{
this
.
selector
.
run
(
nextProps
)
;
}
;
Connect
.
prototype
.
shouldComponentUpdate
=
function
shouldComponentUpdate
(
)
{
return
this
.
selector
.
shouldComponentUpdate
;
}
;
Connect
.
prototype
.
componentWillUnmount
=
function
componentWillUnmount
(
)
{
if
(
this
.
subscription
)
this
.
subscription
.
tryUnsubscribe
(
)
;
this
.
subscription
=
null
;
this
.
notifyNestedSubs
=
noop
;
this
.
store
=
null
;
this
.
selector
.
run
=
noop
;
this
.
selector
.
shouldComponentUpdate
=
false
;
}
;
Connect
.
prototype
.
getWrappedInstance
=
function
getWrappedInstance
(
)
{
invariant_1
2
(
withRef
'
To
access
the
wrapped
instance
you
need
to
specify
'
+
(
'
{
withRef
:
true
}
in
the
options
argument
of
the
'
+
methodName
+
'
(
)
call
.
'
)
)
;
return
this
.
wrappedInstance
;
}
;
Connect
.
prototype
.
setWrappedInstance
=
function
setWrappedInstance
(
ref
)
{
this
.
wrappedInstance
=
ref
;
}
;
Connect
.
prototype
.
initSelector
=
function
initSelector
(
)
{
var
sourceSelector
=
selectorFactory
(
this
.
store
.
dispatch
selectorFactoryOptions
)
;
this
.
selector
=
makeSelectorStateful
(
sourceSelector
this
.
store
)
;
this
.
selector
.
run
(
this
.
props
)
;
}
;
Connect
.
prototype
.
initSubscription
=
function
initSubscription
(
)
{
if
(
!
shouldHandleStateChanges
)
return
;
var
parentSub
=
(
this
.
propsMode
?
this
.
props
:
this
.
context
)
[
subscriptionKey
]
;
this
.
subscription
=
new
Subscription
(
this
.
store
parentSub
this
.
onStateChange
.
bind
(
this
)
)
;
this
.
notifyNestedSubs
=
this
.
subscription
.
notifyNestedSubs
.
bind
(
this
.
subscription
)
;
}
;
Connect
.
prototype
.
onStateChange
=
function
onStateChange
(
)
{
this
.
selector
.
run
(
this
.
props
)
;
if
(
!
this
.
selector
.
shouldComponentUpdate
)
{
this
.
notifyNestedSubs
(
)
;
}
else
{
this
.
componentDidUpdate
=
this
.
notifyNestedSubsOnComponentDidUpdate
;
this
.
setState
(
dummyState
)
;
}
}
;
Connect
.
prototype
.
notifyNestedSubsOnComponentDidUpdate
=
function
notifyNestedSubsOnComponentDidUpdate
(
)
{
this
.
componentDidUpdate
=
undefined
;
this
.
notifyNestedSubs
(
)
;
}
;
Connect
.
prototype
.
isSubscribed
=
function
isSubscribed
(
)
{
return
Boolean
(
this
.
subscription
)
&
&
this
.
subscription
.
isSubscribed
(
)
;
}
;
Connect
.
prototype
.
addExtraProps
=
function
addExtraProps
(
props
)
{
if
(
!
withRef
&
&
!
renderCountProp
&
&
!
(
this
.
propsMode
&
&
this
.
subscription
)
)
return
props
;
var
withExtras
=
_extends
(
{
}
props
)
;
if
(
withRef
)
withExtras
.
ref
=
this
.
setWrappedInstance
;
if
(
renderCountProp
)
withExtras
[
renderCountProp
]
=
this
.
renderCount
+
+
;
if
(
this
.
propsMode
&
&
this
.
subscription
)
withExtras
[
subscriptionKey
]
=
this
.
subscription
;
return
withExtras
;
}
;
Connect
.
prototype
.
render
=
function
render
(
)
{
var
selector
=
this
.
selector
;
selector
.
shouldComponentUpdate
=
false
;
if
(
selector
.
error
)
{
throw
selector
.
error
;
}
else
{
return
react
.
createElement
(
WrappedComponent
this
.
addExtraProps
(
selector
.
props
)
)
;
}
}
;
return
Connect
;
}
(
react
.
Component
)
;
Connect
.
WrappedComponent
=
WrappedComponent
;
Connect
.
displayName
=
displayName
;
Connect
.
childContextTypes
=
childContextTypes
;
Connect
.
contextTypes
=
contextTypes
;
Connect
.
propTypes
=
contextTypes
;
{
Connect
.
prototype
.
componentWillUpdate
=
function
componentWillUpdate
(
)
{
var
_this2
=
this
;
if
(
this
.
version
!
=
=
version
)
{
this
.
version
=
version
;
this
.
initSelector
(
)
;
var
oldListeners
=
[
]
;
if
(
this
.
subscription
)
{
oldListeners
=
this
.
subscription
.
listeners
.
get
(
)
;
this
.
subscription
.
tryUnsubscribe
(
)
;
}
this
.
initSubscription
(
)
;
if
(
shouldHandleStateChanges
)
{
this
.
subscription
.
trySubscribe
(
)
;
oldListeners
.
forEach
(
function
(
listener
)
{
return
_this2
.
subscription
.
listeners
.
subscribe
(
listener
)
;
}
)
;
}
}
}
;
}
return
hoistNonReactStatics
(
Connect
WrappedComponent
)
;
}
;
}
var
hasOwn
=
Object
.
prototype
.
hasOwnProperty
;
function
is
(
x
y
)
{
if
(
x
=
=
=
y
)
{
return
x
!
=
=
0
|
|
y
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
;
}
else
{
return
x
!
=
=
x
&
&
y
!
=
=
y
;
}
}
function
shallowEqual
(
objA
objB
)
{
if
(
is
(
objA
objB
)
)
return
true
;
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
return
false
;
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwn
.
call
(
objB
keysA
[
i
]
)
|
|
!
is
(
objA
[
keysA
[
i
]
]
objB
[
keysA
[
i
]
]
)
)
{
return
false
;
}
}
return
true
;
}
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
&
&
global
.
Object
=
=
=
Object
&
&
global
;
var
freeSelf
=
typeof
self
=
=
'
object
'
&
&
self
&
&
self
.
Object
=
=
=
Object
&
&
self
;
var
root
=
freeGlobal
|
|
freeSelf
|
|
globalThis
;
var
Symbol
1
=
root
.
Symbol
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
1
=
objectProto
.
hasOwnProperty
;
var
nativeObjectToString
=
objectProto
.
toString
;
var
symToStringTag
=
Symbol
1
?
Symbol
1
.
toStringTag
:
undefined
;
function
getRawTag
(
value
)
{
var
isOwn
=
hasOwnProperty
1
.
call
(
value
symToStringTag
)
tag
=
value
[
symToStringTag
]
;
try
{
value
[
symToStringTag
]
=
undefined
;
var
unmasked
=
true
;
}
catch
(
e
)
{
}
var
result
=
nativeObjectToString
.
call
(
value
)
;
if
(
unmasked
)
{
if
(
isOwn
)
{
value
[
symToStringTag
]
=
tag
;
}
else
{
delete
value
[
symToStringTag
]
;
}
}
return
result
;
}
var
objectProto
1
=
Object
.
prototype
;
var
nativeObjectToString
1
=
objectProto
1
.
toString
;
function
objectToString
(
value
)
{
return
nativeObjectToString
1
.
call
(
value
)
;
}
var
nullTag
=
'
[
object
Null
]
'
undefinedTag
=
'
[
object
Undefined
]
'
;
var
symToStringTag
1
=
Symbol
1
?
Symbol
1
.
toStringTag
:
undefined
;
function
baseGetTag
(
value
)
{
if
(
value
=
=
null
)
{
return
value
=
=
=
undefined
?
undefinedTag
:
nullTag
;
}
return
(
symToStringTag
1
&
&
symToStringTag
1
in
Object
(
value
)
)
?
getRawTag
(
value
)
:
objectToString
(
value
)
;
}
function
overArg
(
func
transform
)
{
return
function
(
arg
)
{
return
func
(
transform
(
arg
)
)
;
}
;
}
var
getPrototype
=
overArg
(
Object
.
getPrototypeOf
Object
)
;
function
isObjectLike
(
value
)
{
return
value
!
=
null
&
&
typeof
value
=
=
'
object
'
;
}
var
objectTag
=
'
[
object
Object
]
'
;
var
funcProto
=
Function
.
prototype
objectProto
2
=
Object
.
prototype
;
var
funcToString
=
funcProto
.
toString
;
var
hasOwnProperty
2
=
objectProto
2
.
hasOwnProperty
;
var
objectCtorString
=
funcToString
.
call
(
Object
)
;
function
isPlainObject
(
value
)
{
if
(
!
isObjectLike
(
value
)
|
|
baseGetTag
(
value
)
!
=
objectTag
)
{
return
false
;
}
var
proto
=
getPrototype
(
value
)
;
if
(
proto
=
=
=
null
)
{
return
true
;
}
var
Ctor
=
hasOwnProperty
2
.
call
(
proto
'
constructor
'
)
&
&
proto
.
constructor
;
return
typeof
Ctor
=
=
'
function
'
&
&
Ctor
instanceof
Ctor
&
&
funcToString
.
call
(
Ctor
)
=
=
objectCtorString
;
}
function
verifyPlainObject
(
value
displayName
methodName
)
{
if
(
!
isPlainObject
(
value
)
)
{
warning
2
(
methodName
+
'
(
)
in
'
+
displayName
+
'
must
return
a
plain
object
.
Instead
received
'
+
value
+
'
.
'
)
;
}
}
function
wrapMapToPropsConstant
(
getConstant
)
{
return
function
initConstantSelector
(
dispatch
options
)
{
var
constant
=
getConstant
(
dispatch
options
)
;
function
constantSelector
(
)
{
return
constant
;
}
constantSelector
.
dependsOnOwnProps
=
false
;
return
constantSelector
;
}
;
}
function
getDependsOnOwnProps
(
mapToProps
)
{
return
mapToProps
.
dependsOnOwnProps
!
=
=
null
&
&
mapToProps
.
dependsOnOwnProps
!
=
=
undefined
?
Boolean
(
mapToProps
.
dependsOnOwnProps
)
:
mapToProps
.
length
!
=
=
1
;
}
function
wrapMapToPropsFunc
(
mapToProps
methodName
)
{
return
function
initProxySelector
(
dispatch
_ref
)
{
var
displayName
=
_ref
.
displayName
;
var
proxy
=
function
mapToPropsProxy
(
stateOrDispatch
ownProps
)
{
return
proxy
.
dependsOnOwnProps
?
proxy
.
mapToProps
(
stateOrDispatch
ownProps
)
:
proxy
.
mapToProps
(
stateOrDispatch
)
;
}
;
proxy
.
dependsOnOwnProps
=
true
;
proxy
.
mapToProps
=
function
detectFactoryAndVerify
(
stateOrDispatch
ownProps
)
{
proxy
.
mapToProps
=
mapToProps
;
proxy
.
dependsOnOwnProps
=
getDependsOnOwnProps
(
mapToProps
)
;
var
props
=
proxy
(
stateOrDispatch
ownProps
)
;
if
(
typeof
props
=
=
=
'
function
'
)
{
proxy
.
mapToProps
=
props
;
proxy
.
dependsOnOwnProps
=
getDependsOnOwnProps
(
props
)
;
props
=
proxy
(
stateOrDispatch
ownProps
)
;
}
verifyPlainObject
(
props
displayName
methodName
)
;
return
props
;
}
;
return
proxy
;
}
;
}
function
whenMapDispatchToPropsIsFunction
(
mapDispatchToProps
)
{
return
typeof
mapDispatchToProps
=
=
=
'
function
'
?
wrapMapToPropsFunc
(
mapDispatchToProps
'
mapDispatchToProps
'
)
:
undefined
;
}
function
whenMapDispatchToPropsIsMissing
(
mapDispatchToProps
)
{
return
!
mapDispatchToProps
?
wrapMapToPropsConstant
(
function
(
dispatch
)
{
return
{
dispatch
:
dispatch
}
;
}
)
:
undefined
;
}
function
whenMapDispatchToPropsIsObject
(
mapDispatchToProps
)
{
return
mapDispatchToProps
&
&
typeof
mapDispatchToProps
=
=
=
'
object
'
?
wrapMapToPropsConstant
(
function
(
dispatch
)
{
return
redux
.
bindActionCreators
(
mapDispatchToProps
dispatch
)
;
}
)
:
undefined
;
}
var
defaultMapDispatchToPropsFactories
=
[
whenMapDispatchToPropsIsFunction
whenMapDispatchToPropsIsMissing
whenMapDispatchToPropsIsObject
]
;
function
whenMapStateToPropsIsFunction
(
mapStateToProps
)
{
return
typeof
mapStateToProps
=
=
=
'
function
'
?
wrapMapToPropsFunc
(
mapStateToProps
'
mapStateToProps
'
)
:
undefined
;
}
function
whenMapStateToPropsIsMissing
(
mapStateToProps
)
{
return
!
mapStateToProps
?
wrapMapToPropsConstant
(
function
(
)
{
return
{
}
;
}
)
:
undefined
;
}
var
defaultMapStateToPropsFactories
=
[
whenMapStateToPropsIsFunction
whenMapStateToPropsIsMissing
]
;
function
defaultMergeProps
(
stateProps
dispatchProps
ownProps
)
{
return
_extends
(
{
}
ownProps
stateProps
dispatchProps
)
;
}
function
wrapMergePropsFunc
(
mergeProps
)
{
return
function
initMergePropsProxy
(
dispatch
_ref
)
{
var
displayName
=
_ref
.
displayName
pure
=
_ref
.
pure
areMergedPropsEqual
=
_ref
.
areMergedPropsEqual
;
var
hasRunOnce
=
false
;
var
mergedProps
=
void
0
;
return
function
mergePropsProxy
(
stateProps
dispatchProps
ownProps
)
{
var
nextMergedProps
=
mergeProps
(
stateProps
dispatchProps
ownProps
)
;
if
(
hasRunOnce
)
{
if
(
!
pure
|
|
!
areMergedPropsEqual
(
nextMergedProps
mergedProps
)
)
mergedProps
=
nextMergedProps
;
}
else
{
hasRunOnce
=
true
;
mergedProps
=
nextMergedProps
;
verifyPlainObject
(
mergedProps
displayName
'
mergeProps
'
)
;
}
return
mergedProps
;
}
;
}
;
}
function
whenMergePropsIsFunction
(
mergeProps
)
{
return
typeof
mergeProps
=
=
=
'
function
'
?
wrapMergePropsFunc
(
mergeProps
)
:
undefined
;
}
function
whenMergePropsIsOmitted
(
mergeProps
)
{
return
!
mergeProps
?
function
(
)
{
return
defaultMergeProps
;
}
:
undefined
;
}
var
defaultMergePropsFactories
=
[
whenMergePropsIsFunction
whenMergePropsIsOmitted
]
;
function
verify
(
selector
methodName
displayName
)
{
if
(
!
selector
)
{
throw
new
Error
(
'
Unexpected
value
for
'
+
methodName
+
'
in
'
+
displayName
+
'
.
'
)
;
}
else
if
(
methodName
=
=
=
'
mapStateToProps
'
|
|
methodName
=
=
=
'
mapDispatchToProps
'
)
{
if
(
!
selector
.
hasOwnProperty
(
'
dependsOnOwnProps
'
)
)
{
warning
2
(
'
The
selector
for
'
+
methodName
+
'
of
'
+
displayName
+
'
did
not
specify
a
value
for
dependsOnOwnProps
.
'
)
;
}
}
}
function
verifySubselectors
(
mapStateToProps
mapDispatchToProps
mergeProps
displayName
)
{
verify
(
mapStateToProps
'
mapStateToProps
'
displayName
)
;
verify
(
mapDispatchToProps
'
mapDispatchToProps
'
displayName
)
;
verify
(
mergeProps
'
mergeProps
'
displayName
)
;
}
function
impureFinalPropsSelectorFactory
(
mapStateToProps
mapDispatchToProps
mergeProps
dispatch
)
{
return
function
impureFinalPropsSelector
(
state
ownProps
)
{
return
mergeProps
(
mapStateToProps
(
state
ownProps
)
mapDispatchToProps
(
dispatch
ownProps
)
ownProps
)
;
}
;
}
function
pureFinalPropsSelectorFactory
(
mapStateToProps
mapDispatchToProps
mergeProps
dispatch
_ref
)
{
var
areStatesEqual
=
_ref
.
areStatesEqual
areOwnPropsEqual
=
_ref
.
areOwnPropsEqual
areStatePropsEqual
=
_ref
.
areStatePropsEqual
;
var
hasRunAtLeastOnce
=
false
;
var
state
=
void
0
;
var
ownProps
=
void
0
;
var
stateProps
=
void
0
;
var
dispatchProps
=
void
0
;
var
mergedProps
=
void
0
;
function
handleFirstCall
(
firstState
firstOwnProps
)
{
state
=
firstState
;
ownProps
=
firstOwnProps
;
stateProps
=
mapStateToProps
(
state
ownProps
)
;
dispatchProps
=
mapDispatchToProps
(
dispatch
ownProps
)
;
mergedProps
=
mergeProps
(
stateProps
dispatchProps
ownProps
)
;
hasRunAtLeastOnce
=
true
;
return
mergedProps
;
}
function
handleNewPropsAndNewState
(
)
{
stateProps
=
mapStateToProps
(
state
ownProps
)
;
if
(
mapDispatchToProps
.
dependsOnOwnProps
)
dispatchProps
=
mapDispatchToProps
(
dispatch
ownProps
)
;
mergedProps
=
mergeProps
(
stateProps
dispatchProps
ownProps
)
;
return
mergedProps
;
}
function
handleNewProps
(
)
{
if
(
mapStateToProps
.
dependsOnOwnProps
)
stateProps
=
mapStateToProps
(
state
ownProps
)
;
if
(
mapDispatchToProps
.
dependsOnOwnProps
)
dispatchProps
=
mapDispatchToProps
(
dispatch
ownProps
)
;
mergedProps
=
mergeProps
(
stateProps
dispatchProps
ownProps
)
;
return
mergedProps
;
}
function
handleNewState
(
)
{
var
nextStateProps
=
mapStateToProps
(
state
ownProps
)
;
var
statePropsChanged
=
!
areStatePropsEqual
(
nextStateProps
stateProps
)
;
stateProps
=
nextStateProps
;
if
(
statePropsChanged
)
mergedProps
=
mergeProps
(
stateProps
dispatchProps
ownProps
)
;
return
mergedProps
;
}
function
handleSubsequentCalls
(
nextState
nextOwnProps
)
{
var
propsChanged
=
!
areOwnPropsEqual
(
nextOwnProps
ownProps
)
;
var
stateChanged
=
!
areStatesEqual
(
nextState
state
)
;
state
=
nextState
;
ownProps
=
nextOwnProps
;
if
(
propsChanged
&
&
stateChanged
)
return
handleNewPropsAndNewState
(
)
;
if
(
propsChanged
)
return
handleNewProps
(
)
;
if
(
stateChanged
)
return
handleNewState
(
)
;
return
mergedProps
;
}
return
function
pureFinalPropsSelector
(
nextState
nextOwnProps
)
{
return
hasRunAtLeastOnce
?
handleSubsequentCalls
(
nextState
nextOwnProps
)
:
handleFirstCall
(
nextState
nextOwnProps
)
;
}
;
}
function
finalPropsSelectorFactory
(
dispatch
_ref2
)
{
var
initMapStateToProps
=
_ref2
.
initMapStateToProps
initMapDispatchToProps
=
_ref2
.
initMapDispatchToProps
initMergeProps
=
_ref2
.
initMergeProps
options
=
objectWithoutProperties
(
_ref2
[
'
initMapStateToProps
'
'
initMapDispatchToProps
'
'
initMergeProps
'
]
)
;
var
mapStateToProps
=
initMapStateToProps
(
dispatch
options
)
;
var
mapDispatchToProps
=
initMapDispatchToProps
(
dispatch
options
)
;
var
mergeProps
=
initMergeProps
(
dispatch
options
)
;
{
verifySubselectors
(
mapStateToProps
mapDispatchToProps
mergeProps
options
.
displayName
)
;
}
var
selectorFactory
=
options
.
pure
?
pureFinalPropsSelectorFactory
:
impureFinalPropsSelectorFactory
;
return
selectorFactory
(
mapStateToProps
mapDispatchToProps
mergeProps
dispatch
options
)
;
}
function
match
(
arg
factories
name
)
{
for
(
var
i
=
factories
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
result
=
factories
[
i
]
(
arg
)
;
if
(
result
)
return
result
;
}
return
function
(
dispatch
options
)
{
throw
new
Error
(
'
Invalid
value
of
type
'
+
typeof
arg
+
'
for
'
+
name
+
'
argument
when
connecting
component
'
+
options
.
wrappedComponentName
+
'
.
'
)
;
}
;
}
function
strictEqual
(
a
b
)
{
return
a
=
=
=
b
;
}
function
createConnect
(
)
{
var
_ref
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
_ref
connectHOC
=
_ref
.
connectHOC
connectHOC
=
_ref
connectHOC
=
=
=
undefined
?
connectAdvanced
:
_ref
connectHOC
_ref
mapStateToPropsF
=
_ref
.
mapStateToPropsFactories
mapStateToPropsFactories
=
_ref
mapStateToPropsF
=
=
=
undefined
?
defaultMapStateToPropsFactories
:
_ref
mapStateToPropsF
_ref
mapDispatchToPro
=
_ref
.
mapDispatchToPropsFactories
mapDispatchToPropsFactories
=
_ref
mapDispatchToPro
=
=
=
undefined
?
defaultMapDispatchToPropsFactories
:
_ref
mapDispatchToPro
_ref
mergePropsFactor
=
_ref
.
mergePropsFactories
mergePropsFactories
=
_ref
mergePropsFactor
=
=
=
undefined
?
defaultMergePropsFactories
:
_ref
mergePropsFactor
_ref
selectorFactory
=
_ref
.
selectorFactory
selectorFactory
=
_ref
selectorFactory
=
=
=
undefined
?
finalPropsSelectorFactory
:
_ref
selectorFactory
;
return
function
connect
(
mapStateToProps
mapDispatchToProps
mergeProps
)
{
var
_ref2
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
{
}
_ref2
pure
=
_ref2
.
pure
pure
=
_ref2
pure
=
=
=
undefined
?
true
:
_ref2
pure
_ref2
areStatesEqual
=
_ref2
.
areStatesEqual
areStatesEqual
=
_ref2
areStatesEqual
=
=
=
undefined
?
strictEqual
:
_ref2
areStatesEqual
_ref2
areOwnPropsEqua
=
_ref2
.
areOwnPropsEqual
areOwnPropsEqual
=
_ref2
areOwnPropsEqua
=
=
=
undefined
?
shallowEqual
:
_ref2
areOwnPropsEqua
_ref2
areStatePropsEq
=
_ref2
.
areStatePropsEqual
areStatePropsEqual
=
_ref2
areStatePropsEq
=
=
=
undefined
?
shallowEqual
:
_ref2
areStatePropsEq
_ref2
areMergedPropsE
=
_ref2
.
areMergedPropsEqual
areMergedPropsEqual
=
_ref2
areMergedPropsE
=
=
=
undefined
?
shallowEqual
:
_ref2
areMergedPropsE
extraOptions
=
objectWithoutProperties
(
_ref2
[
'
pure
'
'
areStatesEqual
'
'
areOwnPropsEqual
'
'
areStatePropsEqual
'
'
areMergedPropsEqual
'
]
)
;
var
initMapStateToProps
=
match
(
mapStateToProps
mapStateToPropsFactories
'
mapStateToProps
'
)
;
var
initMapDispatchToProps
=
match
(
mapDispatchToProps
mapDispatchToPropsFactories
'
mapDispatchToProps
'
)
;
var
initMergeProps
=
match
(
mergeProps
mergePropsFactories
'
mergeProps
'
)
;
return
connectHOC
(
selectorFactory
_extends
(
{
methodName
:
'
connect
'
getDisplayName
:
function
getDisplayName
(
name
)
{
return
'
Connect
(
'
+
name
+
'
)
'
;
}
shouldHandleStateChanges
:
Boolean
(
mapStateToProps
)
initMapStateToProps
:
initMapStateToProps
initMapDispatchToProps
:
initMapDispatchToProps
initMergeProps
:
initMergeProps
pure
:
pure
areStatesEqual
:
areStatesEqual
areOwnPropsEqual
:
areOwnPropsEqual
areStatePropsEqual
:
areStatePropsEqual
areMergedPropsEqual
:
areMergedPropsEqual
}
extraOptions
)
)
;
}
;
}
var
connect
=
createConnect
(
)
;
exports
.
Provider
=
Provider
;
exports
.
createProvider
=
createProvider
;
exports
.
connectAdvanced
=
connectAdvanced
;
exports
.
connect
=
connect
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
)
)
)
;
