(
function
(
global
factory
)
{
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
!
=
=
'
undefined
'
?
module
.
exports
=
factory
(
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
factory
)
:
(
global
.
React
=
factory
(
)
)
;
}
(
this
(
function
(
)
{
'
use
strict
'
;
var
ReactVersion
=
'
16
.
8
.
6
'
;
var
hasSymbol
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
for
;
var
REACT_ELEMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
element
'
)
:
0xeac7
;
var
REACT_PORTAL_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
portal
'
)
:
0xeaca
;
var
REACT_FRAGMENT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
fragment
'
)
:
0xeacb
;
var
REACT_STRICT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
strict_mode
'
)
:
0xeacc
;
var
REACT_PROFILER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
profiler
'
)
:
0xead2
;
var
REACT_PROVIDER_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
provider
'
)
:
0xeacd
;
var
REACT_CONTEXT_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
context
'
)
:
0xeace
;
var
REACT_CONCURRENT_MODE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
concurrent_mode
'
)
:
0xeacf
;
var
REACT_FORWARD_REF_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
forward_ref
'
)
:
0xead0
;
var
REACT_SUSPENSE_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
suspense
'
)
:
0xead1
;
var
REACT_MEMO_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
memo
'
)
:
0xead3
;
var
REACT_LAZY_TYPE
=
hasSymbol
?
Symbol
.
for
(
'
react
.
lazy
'
)
:
0xead4
;
var
MAYBE_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
if
(
maybeIterable
=
=
=
null
|
|
typeof
maybeIterable
!
=
=
'
object
'
)
{
return
null
;
}
var
maybeIterator
=
MAYBE_ITERATOR_SYMBOL
&
&
maybeIterable
[
MAYBE_ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
;
if
(
typeof
maybeIterator
=
=
=
'
function
'
)
{
return
maybeIterator
;
}
return
null
;
}
var
getOwnPropertySymbols
=
Object
.
getOwnPropertySymbols
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
var
propIsEnumerable
=
Object
.
prototype
.
propertyIsEnumerable
;
function
toObject
(
val
)
{
if
(
val
=
=
=
null
|
|
val
=
=
=
undefined
)
{
throw
new
TypeError
(
'
Object
.
assign
cannot
be
called
with
null
or
undefined
'
)
;
}
return
Object
(
val
)
;
}
function
shouldUseNative
(
)
{
try
{
if
(
!
Object
.
assign
)
{
return
false
;
}
var
test1
=
new
String
(
'
abc
'
)
;
test1
[
5
]
=
'
de
'
;
if
(
Object
.
getOwnPropertyNames
(
test1
)
[
0
]
=
=
=
'
5
'
)
{
return
false
;
}
var
test2
=
{
}
;
for
(
var
i
=
0
;
i
<
10
;
i
+
+
)
{
test2
[
'
_
'
+
String
.
fromCharCode
(
i
)
]
=
i
;
}
var
order2
=
Object
.
getOwnPropertyNames
(
test2
)
.
map
(
function
(
n
)
{
return
test2
[
n
]
;
}
)
;
if
(
order2
.
join
(
'
'
)
!
=
=
'
0123456789
'
)
{
return
false
;
}
var
test3
=
{
}
;
'
abcdefghijklmnopqrst
'
.
split
(
'
'
)
.
forEach
(
function
(
letter
)
{
test3
[
letter
]
=
letter
;
}
)
;
if
(
Object
.
keys
(
Object
.
assign
(
{
}
test3
)
)
.
join
(
'
'
)
!
=
=
'
abcdefghijklmnopqrst
'
)
{
return
false
;
}
return
true
;
}
catch
(
err
)
{
return
false
;
}
}
var
objectAssign
=
shouldUseNative
(
)
?
Object
.
assign
:
function
(
target
source
)
{
var
from
;
var
to
=
toObject
(
target
)
;
var
symbols
;
for
(
var
s
=
1
;
s
<
arguments
.
length
;
s
+
+
)
{
from
=
Object
(
arguments
[
s
]
)
;
for
(
var
key
in
from
)
{
if
(
hasOwnProperty
.
call
(
from
key
)
)
{
to
[
key
]
=
from
[
key
]
;
}
}
if
(
getOwnPropertySymbols
)
{
symbols
=
getOwnPropertySymbols
(
from
)
;
for
(
var
i
=
0
;
i
<
symbols
.
length
;
i
+
+
)
{
if
(
propIsEnumerable
.
call
(
from
symbols
[
i
]
)
)
{
to
[
symbols
[
i
]
]
=
from
[
symbols
[
i
]
]
;
}
}
}
}
return
to
;
}
;
function
invariant
(
condition
format
a
b
c
d
e
f
)
{
if
(
!
condition
)
{
var
error
=
void
0
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
function
reactProdInvariant
(
code
)
{
var
argCount
=
arguments
.
length
-
1
;
var
url
=
'
https
:
/
/
reactjs
.
org
/
docs
/
error
-
decoder
.
html
?
invariant
=
'
+
code
;
for
(
var
argIdx
=
0
;
argIdx
<
argCount
;
argIdx
+
+
)
{
url
+
=
'
&
args
[
]
=
'
+
encodeURIComponent
(
arguments
[
argIdx
+
1
]
)
;
}
var
i
=
invariant
;
i
(
false
'
Minified
React
error
#
'
+
code
+
'
;
visit
%
s
'
+
'
for
the
full
message
or
use
the
non
-
minified
dev
environment
'
+
'
for
full
errors
and
additional
helpful
warnings
.
'
url
)
;
}
var
ReactNoopUpdateQueue
=
{
isMounted
:
function
(
publicInstance
)
{
return
false
;
}
enqueueForceUpdate
:
function
(
publicInstance
callback
callerName
)
{
}
enqueueReplaceState
:
function
(
publicInstance
completeState
callback
callerName
)
{
}
enqueueSetState
:
function
(
publicInstance
partialState
callback
callerName
)
{
}
}
;
var
emptyObject
=
{
}
;
function
Component
(
props
context
updater
)
{
this
.
props
=
props
;
this
.
context
=
context
;
this
.
refs
=
emptyObject
;
this
.
updater
=
updater
|
|
ReactNoopUpdateQueue
;
}
Component
.
prototype
.
isReactComponent
=
{
}
;
Component
.
prototype
.
setState
=
function
(
partialState
callback
)
{
!
(
typeof
partialState
=
=
=
'
object
'
|
|
typeof
partialState
=
=
=
'
function
'
|
|
partialState
=
=
null
)
?
reactProdInvariant
(
'
85
'
)
:
void
0
;
this
.
updater
.
enqueueSetState
(
this
partialState
callback
'
setState
'
)
;
}
;
Component
.
prototype
.
forceUpdate
=
function
(
callback
)
{
this
.
updater
.
enqueueForceUpdate
(
this
callback
'
forceUpdate
'
)
;
}
;
function
ComponentDummy
(
)
{
}
ComponentDummy
.
prototype
=
Component
.
prototype
;
function
PureComponent
(
props
context
updater
)
{
this
.
props
=
props
;
this
.
context
=
context
;
this
.
refs
=
emptyObject
;
this
.
updater
=
updater
|
|
ReactNoopUpdateQueue
;
}
var
pureComponentPrototype
=
PureComponent
.
prototype
=
new
ComponentDummy
(
)
;
pureComponentPrototype
.
constructor
=
PureComponent
;
objectAssign
(
pureComponentPrototype
Component
.
prototype
)
;
pureComponentPrototype
.
isPureReactComponent
=
true
;
function
createRef
(
)
{
var
refObject
=
{
current
:
null
}
;
return
refObject
;
}
var
enableSchedulerDebugging
=
false
;
var
ImmediatePriority
=
1
;
var
UserBlockingPriority
=
2
;
var
NormalPriority
=
3
;
var
LowPriority
=
4
;
var
IdlePriority
=
5
;
var
maxSigned31BitInt
=
1073741823
;
var
IMMEDIATE_PRIORITY_TIMEOUT
=
-
1
;
var
USER_BLOCKING_PRIORITY
=
250
;
var
NORMAL_PRIORITY_TIMEOUT
=
5000
;
var
LOW_PRIORITY_TIMEOUT
=
10000
;
var
IDLE_PRIORITY
=
maxSigned31BitInt
;
var
firstCallbackNode
=
null
;
var
currentDidTimeout
=
false
;
var
isSchedulerPaused
=
false
;
var
currentPriorityLevel
=
NormalPriority
;
var
currentEventStartTime
=
-
1
;
var
currentExpirationTime
=
-
1
;
var
isExecutingCallback
=
false
;
var
isHostCallbackScheduled
=
false
;
var
hasNativePerformanceNow
=
typeof
performance
=
=
=
'
object
'
&
&
typeof
performance
.
now
=
=
=
'
function
'
;
function
ensureHostCallbackIsScheduled
(
)
{
if
(
isExecutingCallback
)
{
return
;
}
var
expirationTime
=
firstCallbackNode
.
expirationTime
;
if
(
!
isHostCallbackScheduled
)
{
isHostCallbackScheduled
=
true
;
}
else
{
cancelHostCallback
(
)
;
}
requestHostCallback
(
flushWork
expirationTime
)
;
}
function
flushFirstCallback
(
)
{
var
flushedNode
=
firstCallbackNode
;
var
next
=
firstCallbackNode
.
next
;
if
(
firstCallbackNode
=
=
=
next
)
{
firstCallbackNode
=
null
;
next
=
null
;
}
else
{
var
lastCallbackNode
=
firstCallbackNode
.
previous
;
firstCallbackNode
=
lastCallbackNode
.
next
=
next
;
next
.
previous
=
lastCallbackNode
;
}
flushedNode
.
next
=
flushedNode
.
previous
=
null
;
var
callback
=
flushedNode
.
callback
;
var
expirationTime
=
flushedNode
.
expirationTime
;
var
priorityLevel
=
flushedNode
.
priorityLevel
;
var
previousPriorityLevel
=
currentPriorityLevel
;
var
previousExpirationTime
=
currentExpirationTime
;
currentPriorityLevel
=
priorityLevel
;
currentExpirationTime
=
expirationTime
;
var
continuationCallback
;
try
{
continuationCallback
=
callback
(
)
;
}
finally
{
currentPriorityLevel
=
previousPriorityLevel
;
currentExpirationTime
=
previousExpirationTime
;
}
if
(
typeof
continuationCallback
=
=
=
'
function
'
)
{
var
continuationNode
=
{
callback
:
continuationCallback
priorityLevel
:
priorityLevel
expirationTime
:
expirationTime
next
:
null
previous
:
null
}
;
if
(
firstCallbackNode
=
=
=
null
)
{
firstCallbackNode
=
continuationNode
.
next
=
continuationNode
.
previous
=
continuationNode
;
}
else
{
var
nextAfterContinuation
=
null
;
var
node
=
firstCallbackNode
;
do
{
if
(
node
.
expirationTime
>
=
expirationTime
)
{
nextAfterContinuation
=
node
;
break
;
}
node
=
node
.
next
;
}
while
(
node
!
=
=
firstCallbackNode
)
;
if
(
nextAfterContinuation
=
=
=
null
)
{
nextAfterContinuation
=
firstCallbackNode
;
}
else
if
(
nextAfterContinuation
=
=
=
firstCallbackNode
)
{
firstCallbackNode
=
continuationNode
;
ensureHostCallbackIsScheduled
(
)
;
}
var
previous
=
nextAfterContinuation
.
previous
;
previous
.
next
=
nextAfterContinuation
.
previous
=
continuationNode
;
continuationNode
.
next
=
nextAfterContinuation
;
continuationNode
.
previous
=
previous
;
}
}
}
function
flushImmediateWork
(
)
{
if
(
currentEventStartTime
=
=
=
-
1
&
&
firstCallbackNode
!
=
=
null
&
&
firstCallbackNode
.
priorityLevel
=
=
=
ImmediatePriority
)
{
isExecutingCallback
=
true
;
try
{
do
{
flushFirstCallback
(
)
;
}
while
(
firstCallbackNode
!
=
=
null
&
&
firstCallbackNode
.
priorityLevel
=
=
=
ImmediatePriority
)
;
}
finally
{
isExecutingCallback
=
false
;
if
(
firstCallbackNode
!
=
=
null
)
{
ensureHostCallbackIsScheduled
(
)
;
}
else
{
isHostCallbackScheduled
=
false
;
}
}
}
}
function
flushWork
(
didTimeout
)
{
if
(
enableSchedulerDebugging
&
&
isSchedulerPaused
)
{
return
;
}
isExecutingCallback
=
true
;
var
previousDidTimeout
=
currentDidTimeout
;
currentDidTimeout
=
didTimeout
;
try
{
if
(
didTimeout
)
{
while
(
firstCallbackNode
!
=
=
null
&
&
!
(
enableSchedulerDebugging
&
&
isSchedulerPaused
)
)
{
var
currentTime
=
getCurrentTime
(
)
;
if
(
firstCallbackNode
.
expirationTime
<
=
currentTime
)
{
do
{
flushFirstCallback
(
)
;
}
while
(
firstCallbackNode
!
=
=
null
&
&
firstCallbackNode
.
expirationTime
<
=
currentTime
&
&
!
(
enableSchedulerDebugging
&
&
isSchedulerPaused
)
)
;
continue
;
}
break
;
}
}
else
{
if
(
firstCallbackNode
!
=
=
null
)
{
do
{
if
(
enableSchedulerDebugging
&
&
isSchedulerPaused
)
{
break
;
}
flushFirstCallback
(
)
;
}
while
(
firstCallbackNode
!
=
=
null
&
&
!
shouldYieldToHost
(
)
)
;
}
}
}
finally
{
isExecutingCallback
=
false
;
currentDidTimeout
=
previousDidTimeout
;
if
(
firstCallbackNode
!
=
=
null
)
{
ensureHostCallbackIsScheduled
(
)
;
}
else
{
isHostCallbackScheduled
=
false
;
}
flushImmediateWork
(
)
;
}
}
function
unstable_runWithPriority
(
priorityLevel
eventHandler
)
{
switch
(
priorityLevel
)
{
case
ImmediatePriority
:
case
UserBlockingPriority
:
case
NormalPriority
:
case
LowPriority
:
case
IdlePriority
:
break
;
default
:
priorityLevel
=
NormalPriority
;
}
var
previousPriorityLevel
=
currentPriorityLevel
;
var
previousEventStartTime
=
currentEventStartTime
;
currentPriorityLevel
=
priorityLevel
;
currentEventStartTime
=
getCurrentTime
(
)
;
try
{
return
eventHandler
(
)
;
}
finally
{
currentPriorityLevel
=
previousPriorityLevel
;
currentEventStartTime
=
previousEventStartTime
;
flushImmediateWork
(
)
;
}
}
function
unstable_next
(
eventHandler
)
{
var
priorityLevel
=
void
0
;
switch
(
currentPriorityLevel
)
{
case
ImmediatePriority
:
case
UserBlockingPriority
:
case
NormalPriority
:
priorityLevel
=
NormalPriority
;
break
;
default
:
priorityLevel
=
currentPriorityLevel
;
break
;
}
var
previousPriorityLevel
=
currentPriorityLevel
;
var
previousEventStartTime
=
currentEventStartTime
;
currentPriorityLevel
=
priorityLevel
;
currentEventStartTime
=
getCurrentTime
(
)
;
try
{
return
eventHandler
(
)
;
}
finally
{
currentPriorityLevel
=
previousPriorityLevel
;
currentEventStartTime
=
previousEventStartTime
;
flushImmediateWork
(
)
;
}
}
function
unstable_wrapCallback
(
callback
)
{
var
parentPriorityLevel
=
currentPriorityLevel
;
return
function
(
)
{
var
previousPriorityLevel
=
currentPriorityLevel
;
var
previousEventStartTime
=
currentEventStartTime
;
currentPriorityLevel
=
parentPriorityLevel
;
currentEventStartTime
=
getCurrentTime
(
)
;
try
{
return
callback
.
apply
(
this
arguments
)
;
}
finally
{
currentPriorityLevel
=
previousPriorityLevel
;
currentEventStartTime
=
previousEventStartTime
;
flushImmediateWork
(
)
;
}
}
;
}
function
unstable_scheduleCallback
(
callback
deprecated_options
)
{
var
startTime
=
currentEventStartTime
!
=
=
-
1
?
currentEventStartTime
:
getCurrentTime
(
)
;
var
expirationTime
;
if
(
typeof
deprecated_options
=
=
=
'
object
'
&
&
deprecated_options
!
=
=
null
&
&
typeof
deprecated_options
.
timeout
=
=
=
'
number
'
)
{
expirationTime
=
startTime
+
deprecated_options
.
timeout
;
}
else
{
switch
(
currentPriorityLevel
)
{
case
ImmediatePriority
:
expirationTime
=
startTime
+
IMMEDIATE_PRIORITY_TIMEOUT
;
break
;
case
UserBlockingPriority
:
expirationTime
=
startTime
+
USER_BLOCKING_PRIORITY
;
break
;
case
IdlePriority
:
expirationTime
=
startTime
+
IDLE_PRIORITY
;
break
;
case
LowPriority
:
expirationTime
=
startTime
+
LOW_PRIORITY_TIMEOUT
;
break
;
case
NormalPriority
:
default
:
expirationTime
=
startTime
+
NORMAL_PRIORITY_TIMEOUT
;
}
}
var
newNode
=
{
callback
:
callback
priorityLevel
:
currentPriorityLevel
expirationTime
:
expirationTime
next
:
null
previous
:
null
}
;
if
(
firstCallbackNode
=
=
=
null
)
{
firstCallbackNode
=
newNode
.
next
=
newNode
.
previous
=
newNode
;
ensureHostCallbackIsScheduled
(
)
;
}
else
{
var
next
=
null
;
var
node
=
firstCallbackNode
;
do
{
if
(
node
.
expirationTime
>
expirationTime
)
{
next
=
node
;
break
;
}
node
=
node
.
next
;
}
while
(
node
!
=
=
firstCallbackNode
)
;
if
(
next
=
=
=
null
)
{
next
=
firstCallbackNode
;
}
else
if
(
next
=
=
=
firstCallbackNode
)
{
firstCallbackNode
=
newNode
;
ensureHostCallbackIsScheduled
(
)
;
}
var
previous
=
next
.
previous
;
previous
.
next
=
next
.
previous
=
newNode
;
newNode
.
next
=
next
;
newNode
.
previous
=
previous
;
}
return
newNode
;
}
function
unstable_pauseExecution
(
)
{
isSchedulerPaused
=
true
;
}
function
unstable_continueExecution
(
)
{
isSchedulerPaused
=
false
;
if
(
firstCallbackNode
!
=
=
null
)
{
ensureHostCallbackIsScheduled
(
)
;
}
}
function
unstable_getFirstCallbackNode
(
)
{
return
firstCallbackNode
;
}
function
unstable_cancelCallback
(
callbackNode
)
{
var
next
=
callbackNode
.
next
;
if
(
next
=
=
=
null
)
{
return
;
}
if
(
next
=
=
=
callbackNode
)
{
firstCallbackNode
=
null
;
}
else
{
if
(
callbackNode
=
=
=
firstCallbackNode
)
{
firstCallbackNode
=
next
;
}
var
previous
=
callbackNode
.
previous
;
previous
.
next
=
next
;
next
.
previous
=
previous
;
}
callbackNode
.
next
=
callbackNode
.
previous
=
null
;
}
function
unstable_getCurrentPriorityLevel
(
)
{
return
currentPriorityLevel
;
}
function
unstable_shouldYield
(
)
{
return
!
currentDidTimeout
&
&
(
firstCallbackNode
!
=
=
null
&
&
firstCallbackNode
.
expirationTime
<
currentExpirationTime
|
|
shouldYieldToHost
(
)
)
;
}
var
localDate
=
Date
;
var
localSetTimeout
=
typeof
setTimeout
=
=
=
'
function
'
?
setTimeout
:
undefined
;
var
localClearTimeout
=
typeof
clearTimeout
=
=
=
'
function
'
?
clearTimeout
:
undefined
;
var
localRequestAnimationFrame
=
typeof
requestAnimationFrame
=
=
=
'
function
'
?
requestAnimationFrame
:
undefined
;
var
localCancelAnimationFrame
=
typeof
cancelAnimationFrame
=
=
=
'
function
'
?
cancelAnimationFrame
:
undefined
;
var
getCurrentTime
;
var
ANIMATION_FRAME_TIMEOUT
=
100
;
var
rAFID
;
var
rAFTimeoutID
;
var
requestAnimationFrameWithTimeout
=
function
(
callback
)
{
rAFID
=
localRequestAnimationFrame
(
function
(
timestamp
)
{
localClearTimeout
(
rAFTimeoutID
)
;
callback
(
timestamp
)
;
}
)
;
rAFTimeoutID
=
localSetTimeout
(
function
(
)
{
localCancelAnimationFrame
(
rAFID
)
;
callback
(
getCurrentTime
(
)
)
;
}
ANIMATION_FRAME_TIMEOUT
)
;
}
;
if
(
hasNativePerformanceNow
)
{
var
Performance
=
performance
;
getCurrentTime
=
function
(
)
{
return
Performance
.
now
(
)
;
}
;
}
else
{
getCurrentTime
=
function
(
)
{
return
localDate
.
now
(
)
;
}
;
}
var
requestHostCallback
;
var
cancelHostCallback
;
var
shouldYieldToHost
;
var
globalValue
=
null
;
if
(
typeof
window
!
=
=
'
undefined
'
)
{
globalValue
=
window
;
}
else
if
(
typeof
global
!
=
=
'
undefined
'
)
{
globalValue
=
global
;
}
if
(
globalValue
&
&
globalValue
.
_schedMock
)
{
var
globalImpl
=
globalValue
.
_schedMock
;
requestHostCallback
=
globalImpl
[
0
]
;
cancelHostCallback
=
globalImpl
[
1
]
;
shouldYieldToHost
=
globalImpl
[
2
]
;
getCurrentTime
=
globalImpl
[
3
]
;
}
else
if
(
typeof
window
=
=
=
'
undefined
'
|
|
typeof
MessageChannel
!
=
=
'
function
'
)
{
var
_callback
=
null
;
var
_flushCallback
=
function
(
didTimeout
)
{
if
(
_callback
!
=
=
null
)
{
try
{
_callback
(
didTimeout
)
;
}
finally
{
_callback
=
null
;
}
}
}
;
requestHostCallback
=
function
(
cb
ms
)
{
if
(
_callback
!
=
=
null
)
{
setTimeout
(
requestHostCallback
0
cb
)
;
}
else
{
_callback
=
cb
;
setTimeout
(
_flushCallback
0
false
)
;
}
}
;
cancelHostCallback
=
function
(
)
{
_callback
=
null
;
}
;
shouldYieldToHost
=
function
(
)
{
return
false
;
}
;
}
else
{
if
(
typeof
console
!
=
=
'
undefined
'
)
{
if
(
typeof
localRequestAnimationFrame
!
=
=
'
function
'
)
{
console
.
error
(
"
This
browser
doesn
'
t
support
requestAnimationFrame
.
"
+
'
Make
sure
that
you
load
a
'
+
'
polyfill
in
older
browsers
.
https
:
/
/
fb
.
me
/
react
-
polyfills
'
)
;
}
if
(
typeof
localCancelAnimationFrame
!
=
=
'
function
'
)
{
console
.
error
(
"
This
browser
doesn
'
t
support
cancelAnimationFrame
.
"
+
'
Make
sure
that
you
load
a
'
+
'
polyfill
in
older
browsers
.
https
:
/
/
fb
.
me
/
react
-
polyfills
'
)
;
}
}
var
scheduledHostCallback
=
null
;
var
isMessageEventScheduled
=
false
;
var
timeoutTime
=
-
1
;
var
isAnimationFrameScheduled
=
false
;
var
isFlushingHostCallback
=
false
;
var
frameDeadline
=
0
;
var
previousFrameTime
=
33
;
var
activeFrameTime
=
33
;
shouldYieldToHost
=
function
(
)
{
return
frameDeadline
<
=
getCurrentTime
(
)
;
}
;
var
channel
=
new
MessageChannel
(
)
;
var
port
=
channel
.
port2
;
channel
.
port1
.
onmessage
=
function
(
event
)
{
isMessageEventScheduled
=
false
;
var
prevScheduledCallback
=
scheduledHostCallback
;
var
prevTimeoutTime
=
timeoutTime
;
scheduledHostCallback
=
null
;
timeoutTime
=
-
1
;
var
currentTime
=
getCurrentTime
(
)
;
var
didTimeout
=
false
;
if
(
frameDeadline
-
currentTime
<
=
0
)
{
if
(
prevTimeoutTime
!
=
=
-
1
&
&
prevTimeoutTime
<
=
currentTime
)
{
didTimeout
=
true
;
}
else
{
if
(
!
isAnimationFrameScheduled
)
{
isAnimationFrameScheduled
=
true
;
requestAnimationFrameWithTimeout
(
animationTick
)
;
}
scheduledHostCallback
=
prevScheduledCallback
;
timeoutTime
=
prevTimeoutTime
;
return
;
}
}
if
(
prevScheduledCallback
!
=
=
null
)
{
isFlushingHostCallback
=
true
;
try
{
prevScheduledCallback
(
didTimeout
)
;
}
finally
{
isFlushingHostCallback
=
false
;
}
}
}
;
var
animationTick
=
function
(
rafTime
)
{
if
(
scheduledHostCallback
!
=
=
null
)
{
requestAnimationFrameWithTimeout
(
animationTick
)
;
}
else
{
isAnimationFrameScheduled
=
false
;
return
;
}
var
nextFrameTime
=
rafTime
-
frameDeadline
+
activeFrameTime
;
if
(
nextFrameTime
<
activeFrameTime
&
&
previousFrameTime
<
activeFrameTime
)
{
if
(
nextFrameTime
<
8
)
{
nextFrameTime
=
8
;
}
activeFrameTime
=
nextFrameTime
<
previousFrameTime
?
previousFrameTime
:
nextFrameTime
;
}
else
{
previousFrameTime
=
nextFrameTime
;
}
frameDeadline
=
rafTime
+
activeFrameTime
;
if
(
!
isMessageEventScheduled
)
{
isMessageEventScheduled
=
true
;
port
.
postMessage
(
undefined
)
;
}
}
;
requestHostCallback
=
function
(
callback
absoluteTimeout
)
{
scheduledHostCallback
=
callback
;
timeoutTime
=
absoluteTimeout
;
if
(
isFlushingHostCallback
|
|
absoluteTimeout
<
0
)
{
port
.
postMessage
(
undefined
)
;
}
else
if
(
!
isAnimationFrameScheduled
)
{
isAnimationFrameScheduled
=
true
;
requestAnimationFrameWithTimeout
(
animationTick
)
;
}
}
;
cancelHostCallback
=
function
(
)
{
scheduledHostCallback
=
null
;
isMessageEventScheduled
=
false
;
timeoutTime
=
-
1
;
}
;
}
var
enableSchedulerTracing
=
false
;
var
enableStableConcurrentModeAPIs
=
false
;
var
DEFAULT_THREAD_ID
=
0
;
var
interactionIDCounter
=
0
;
var
threadIDCounter
=
0
;
var
interactionsRef
=
null
;
var
subscriberRef
=
null
;
if
(
enableSchedulerTracing
)
{
interactionsRef
=
{
current
:
new
Set
(
)
}
;
subscriberRef
=
{
current
:
null
}
;
}
function
unstable_clear
(
callback
)
{
if
(
!
enableSchedulerTracing
)
{
return
callback
(
)
;
}
var
prevInteractions
=
interactionsRef
.
current
;
interactionsRef
.
current
=
new
Set
(
)
;
try
{
return
callback
(
)
;
}
finally
{
interactionsRef
.
current
=
prevInteractions
;
}
}
function
unstable_getCurrent
(
)
{
if
(
!
enableSchedulerTracing
)
{
return
null
;
}
else
{
return
interactionsRef
.
current
;
}
}
function
unstable_getThreadID
(
)
{
return
+
+
threadIDCounter
;
}
function
unstable_trace
(
name
timestamp
callback
)
{
var
threadID
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
DEFAULT_THREAD_ID
;
if
(
!
enableSchedulerTracing
)
{
return
callback
(
)
;
}
var
interaction
=
{
__count
:
1
id
:
interactionIDCounter
+
+
name
:
name
timestamp
:
timestamp
}
;
var
prevInteractions
=
interactionsRef
.
current
;
var
interactions
=
new
Set
(
prevInteractions
)
;
interactions
.
add
(
interaction
)
;
interactionsRef
.
current
=
interactions
;
var
subscriber
=
subscriberRef
.
current
;
var
returnValue
=
void
0
;
try
{
if
(
subscriber
!
=
=
null
)
{
subscriber
.
onInteractionTraced
(
interaction
)
;
}
}
finally
{
try
{
if
(
subscriber
!
=
=
null
)
{
subscriber
.
onWorkStarted
(
interactions
threadID
)
;
}
}
finally
{
try
{
returnValue
=
callback
(
)
;
}
finally
{
interactionsRef
.
current
=
prevInteractions
;
try
{
if
(
subscriber
!
=
=
null
)
{
subscriber
.
onWorkStopped
(
interactions
threadID
)
;
}
}
finally
{
interaction
.
__count
-
-
;
if
(
subscriber
!
=
=
null
&
&
interaction
.
__count
=
=
=
0
)
{
subscriber
.
onInteractionScheduledWorkCompleted
(
interaction
)
;
}
}
}
}
}
return
returnValue
;
}
function
unstable_wrap
(
callback
)
{
var
threadID
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
DEFAULT_THREAD_ID
;
if
(
!
enableSchedulerTracing
)
{
return
callback
;
}
var
wrappedInteractions
=
interactionsRef
.
current
;
var
subscriber
=
subscriberRef
.
current
;
if
(
subscriber
!
=
=
null
)
{
subscriber
.
onWorkScheduled
(
wrappedInteractions
threadID
)
;
}
wrappedInteractions
.
forEach
(
function
(
interaction
)
{
interaction
.
__count
+
+
;
}
)
;
var
hasRun
=
false
;
function
wrapped
(
)
{
var
prevInteractions
=
interactionsRef
.
current
;
interactionsRef
.
current
=
wrappedInteractions
;
subscriber
=
subscriberRef
.
current
;
try
{
var
returnValue
=
void
0
;
try
{
if
(
subscriber
!
=
=
null
)
{
subscriber
.
onWorkStarted
(
wrappedInteractions
threadID
)
;
}
}
finally
{
try
{
returnValue
=
callback
.
apply
(
undefined
arguments
)
;
}
finally
{
interactionsRef
.
current
=
prevInteractions
;
if
(
subscriber
!
=
=
null
)
{
subscriber
.
onWorkStopped
(
wrappedInteractions
threadID
)
;
}
}
}
return
returnValue
;
}
finally
{
if
(
!
hasRun
)
{
hasRun
=
true
;
wrappedInteractions
.
forEach
(
function
(
interaction
)
{
interaction
.
__count
-
-
;
if
(
subscriber
!
=
=
null
&
&
interaction
.
__count
=
=
=
0
)
{
subscriber
.
onInteractionScheduledWorkCompleted
(
interaction
)
;
}
}
)
;
}
}
}
wrapped
.
cancel
=
function
cancel
(
)
{
subscriber
=
subscriberRef
.
current
;
try
{
if
(
subscriber
!
=
=
null
)
{
subscriber
.
onWorkCanceled
(
wrappedInteractions
threadID
)
;
}
}
finally
{
wrappedInteractions
.
forEach
(
function
(
interaction
)
{
interaction
.
__count
-
-
;
if
(
subscriber
&
&
interaction
.
__count
=
=
=
0
)
{
subscriber
.
onInteractionScheduledWorkCompleted
(
interaction
)
;
}
}
)
;
}
}
;
return
wrapped
;
}
var
subscribers
=
null
;
if
(
enableSchedulerTracing
)
{
subscribers
=
new
Set
(
)
;
}
function
unstable_subscribe
(
subscriber
)
{
if
(
enableSchedulerTracing
)
{
subscribers
.
add
(
subscriber
)
;
if
(
subscribers
.
size
=
=
=
1
)
{
subscriberRef
.
current
=
{
onInteractionScheduledWorkCompleted
:
onInteractionScheduledWorkCompleted
onInteractionTraced
:
onInteractionTraced
onWorkCanceled
:
onWorkCanceled
onWorkScheduled
:
onWorkScheduled
onWorkStarted
:
onWorkStarted
onWorkStopped
:
onWorkStopped
}
;
}
}
}
function
unstable_unsubscribe
(
subscriber
)
{
if
(
enableSchedulerTracing
)
{
subscribers
.
delete
(
subscriber
)
;
if
(
subscribers
.
size
=
=
=
0
)
{
subscriberRef
.
current
=
null
;
}
}
}
function
onInteractionTraced
(
interaction
)
{
var
didCatchError
=
false
;
var
caughtError
=
null
;
subscribers
.
forEach
(
function
(
subscriber
)
{
try
{
subscriber
.
onInteractionTraced
(
interaction
)
;
}
catch
(
error
)
{
if
(
!
didCatchError
)
{
didCatchError
=
true
;
caughtError
=
error
;
}
}
}
)
;
if
(
didCatchError
)
{
throw
caughtError
;
}
}
function
onInteractionScheduledWorkCompleted
(
interaction
)
{
var
didCatchError
=
false
;
var
caughtError
=
null
;
subscribers
.
forEach
(
function
(
subscriber
)
{
try
{
subscriber
.
onInteractionScheduledWorkCompleted
(
interaction
)
;
}
catch
(
error
)
{
if
(
!
didCatchError
)
{
didCatchError
=
true
;
caughtError
=
error
;
}
}
}
)
;
if
(
didCatchError
)
{
throw
caughtError
;
}
}
function
onWorkScheduled
(
interactions
threadID
)
{
var
didCatchError
=
false
;
var
caughtError
=
null
;
subscribers
.
forEach
(
function
(
subscriber
)
{
try
{
subscriber
.
onWorkScheduled
(
interactions
threadID
)
;
}
catch
(
error
)
{
if
(
!
didCatchError
)
{
didCatchError
=
true
;
caughtError
=
error
;
}
}
}
)
;
if
(
didCatchError
)
{
throw
caughtError
;
}
}
function
onWorkStarted
(
interactions
threadID
)
{
var
didCatchError
=
false
;
var
caughtError
=
null
;
subscribers
.
forEach
(
function
(
subscriber
)
{
try
{
subscriber
.
onWorkStarted
(
interactions
threadID
)
;
}
catch
(
error
)
{
if
(
!
didCatchError
)
{
didCatchError
=
true
;
caughtError
=
error
;
}
}
}
)
;
if
(
didCatchError
)
{
throw
caughtError
;
}
}
function
onWorkStopped
(
interactions
threadID
)
{
var
didCatchError
=
false
;
var
caughtError
=
null
;
subscribers
.
forEach
(
function
(
subscriber
)
{
try
{
subscriber
.
onWorkStopped
(
interactions
threadID
)
;
}
catch
(
error
)
{
if
(
!
didCatchError
)
{
didCatchError
=
true
;
caughtError
=
error
;
}
}
}
)
;
if
(
didCatchError
)
{
throw
caughtError
;
}
}
function
onWorkCanceled
(
interactions
threadID
)
{
var
didCatchError
=
false
;
var
caughtError
=
null
;
subscribers
.
forEach
(
function
(
subscriber
)
{
try
{
subscriber
.
onWorkCanceled
(
interactions
threadID
)
;
}
catch
(
error
)
{
if
(
!
didCatchError
)
{
didCatchError
=
true
;
caughtError
=
error
;
}
}
}
)
;
if
(
didCatchError
)
{
throw
caughtError
;
}
}
var
ReactCurrentDispatcher
=
{
current
:
null
}
;
var
ReactCurrentOwner
=
{
current
:
null
}
;
var
ReactSharedInternals
=
{
ReactCurrentDispatcher
:
ReactCurrentDispatcher
ReactCurrentOwner
:
ReactCurrentOwner
assign
:
objectAssign
}
;
{
objectAssign
(
ReactSharedInternals
{
Scheduler
:
{
unstable_cancelCallback
:
unstable_cancelCallback
unstable_shouldYield
:
unstable_shouldYield
unstable_now
:
getCurrentTime
unstable_scheduleCallback
:
unstable_scheduleCallback
unstable_runWithPriority
:
unstable_runWithPriority
unstable_next
:
unstable_next
unstable_wrapCallback
:
unstable_wrapCallback
unstable_getFirstCallbackNode
:
unstable_getFirstCallbackNode
unstable_pauseExecution
:
unstable_pauseExecution
unstable_continueExecution
:
unstable_continueExecution
unstable_getCurrentPriorityLevel
:
unstable_getCurrentPriorityLevel
unstable_IdlePriority
:
IdlePriority
unstable_ImmediatePriority
:
ImmediatePriority
unstable_LowPriority
:
LowPriority
unstable_NormalPriority
:
NormalPriority
unstable_UserBlockingPriority
:
UserBlockingPriority
}
SchedulerTracing
:
{
__interactionsRef
:
interactionsRef
__subscriberRef
:
subscriberRef
unstable_clear
:
unstable_clear
unstable_getCurrent
:
unstable_getCurrent
unstable_getThreadID
:
unstable_getThreadID
unstable_subscribe
:
unstable_subscribe
unstable_trace
:
unstable_trace
unstable_unsubscribe
:
unstable_unsubscribe
unstable_wrap
:
unstable_wrap
}
}
)
;
}
var
hasOwnProperty
1
=
Object
.
prototype
.
hasOwnProperty
;
var
RESERVED_PROPS
=
{
key
:
true
ref
:
true
__self
:
true
__source
:
true
}
;
function
hasValidRef
(
config
)
{
return
config
.
ref
!
=
=
undefined
;
}
function
hasValidKey
(
config
)
{
return
config
.
key
!
=
=
undefined
;
}
var
ReactElement
=
function
(
type
key
ref
self
source
owner
props
)
{
var
element
=
{
typeof
:
REACT_ELEMENT_TYPE
type
:
type
key
:
key
ref
:
ref
props
:
props
_owner
:
owner
}
;
return
element
;
}
;
function
createElement
(
type
config
children
)
{
var
propName
=
void
0
;
var
props
=
{
}
;
var
key
=
null
;
var
ref
=
null
;
var
self
=
null
;
var
source
=
null
;
if
(
config
!
=
null
)
{
if
(
hasValidRef
(
config
)
)
{
ref
=
config
.
ref
;
}
if
(
hasValidKey
(
config
)
)
{
key
=
'
'
+
config
.
key
;
}
self
=
config
.
__self
=
=
=
undefined
?
null
:
config
.
__self
;
source
=
config
.
__source
=
=
=
undefined
?
null
:
config
.
__source
;
for
(
propName
in
config
)
{
if
(
hasOwnProperty
1
.
call
(
config
propName
)
&
&
!
RESERVED_PROPS
.
hasOwnProperty
(
propName
)
)
{
props
[
propName
]
=
config
[
propName
]
;
}
}
}
var
childrenLength
=
arguments
.
length
-
2
;
if
(
childrenLength
=
=
=
1
)
{
props
.
children
=
children
;
}
else
if
(
childrenLength
>
1
)
{
var
childArray
=
Array
(
childrenLength
)
;
for
(
var
i
=
0
;
i
<
childrenLength
;
i
+
+
)
{
childArray
[
i
]
=
arguments
[
i
+
2
]
;
}
props
.
children
=
childArray
;
}
if
(
type
&
&
type
.
defaultProps
)
{
var
defaultProps
=
type
.
defaultProps
;
for
(
propName
in
defaultProps
)
{
if
(
props
[
propName
]
=
=
=
undefined
)
{
props
[
propName
]
=
defaultProps
[
propName
]
;
}
}
}
return
ReactElement
(
type
key
ref
self
source
ReactCurrentOwner
.
current
props
)
;
}
function
createFactory
(
type
)
{
var
factory
=
createElement
.
bind
(
null
type
)
;
factory
.
type
=
type
;
return
factory
;
}
function
cloneAndReplaceKey
(
oldElement
newKey
)
{
var
newElement
=
ReactElement
(
oldElement
.
type
newKey
oldElement
.
ref
oldElement
.
_self
oldElement
.
_source
oldElement
.
_owner
oldElement
.
props
)
;
return
newElement
;
}
function
cloneElement
(
element
config
children
)
{
!
!
(
element
=
=
=
null
|
|
element
=
=
=
undefined
)
?
reactProdInvariant
(
'
267
'
element
)
:
void
0
;
var
propName
=
void
0
;
var
props
=
objectAssign
(
{
}
element
.
props
)
;
var
key
=
element
.
key
;
var
ref
=
element
.
ref
;
var
self
=
element
.
_self
;
var
source
=
element
.
_source
;
var
owner
=
element
.
_owner
;
if
(
config
!
=
null
)
{
if
(
hasValidRef
(
config
)
)
{
ref
=
config
.
ref
;
owner
=
ReactCurrentOwner
.
current
;
}
if
(
hasValidKey
(
config
)
)
{
key
=
'
'
+
config
.
key
;
}
var
defaultProps
=
void
0
;
if
(
element
.
type
&
&
element
.
type
.
defaultProps
)
{
defaultProps
=
element
.
type
.
defaultProps
;
}
for
(
propName
in
config
)
{
if
(
hasOwnProperty
1
.
call
(
config
propName
)
&
&
!
RESERVED_PROPS
.
hasOwnProperty
(
propName
)
)
{
if
(
config
[
propName
]
=
=
=
undefined
&
&
defaultProps
!
=
=
undefined
)
{
props
[
propName
]
=
defaultProps
[
propName
]
;
}
else
{
props
[
propName
]
=
config
[
propName
]
;
}
}
}
}
var
childrenLength
=
arguments
.
length
-
2
;
if
(
childrenLength
=
=
=
1
)
{
props
.
children
=
children
;
}
else
if
(
childrenLength
>
1
)
{
var
childArray
=
Array
(
childrenLength
)
;
for
(
var
i
=
0
;
i
<
childrenLength
;
i
+
+
)
{
childArray
[
i
]
=
arguments
[
i
+
2
]
;
}
props
.
children
=
childArray
;
}
return
ReactElement
(
element
.
type
key
ref
self
source
owner
props
)
;
}
function
isValidElement
(
object
)
{
return
typeof
object
=
=
=
'
object
'
&
&
object
!
=
=
null
&
&
object
.
typeof
=
=
=
REACT_ELEMENT_TYPE
;
}
var
SEPARATOR
=
'
.
'
;
var
SUBSEPARATOR
=
'
:
'
;
function
escape
(
key
)
{
var
escapeRegex
=
/
[
=
:
]
/
g
;
var
escaperLookup
=
{
'
=
'
:
'
=
0
'
'
:
'
:
'
=
2
'
}
;
var
escapedString
=
(
'
'
+
key
)
.
replace
(
escapeRegex
function
(
match
)
{
return
escaperLookup
[
match
]
;
}
)
;
return
'
'
+
escapedString
;
}
var
userProvidedKeyEscapeRegex
=
/
\
/
+
/
g
;
function
escapeUserProvidedKey
(
text
)
{
return
(
'
'
+
text
)
.
replace
(
userProvidedKeyEscapeRegex
'
&
/
'
)
;
}
var
POOL_SIZE
=
10
;
var
traverseContextPool
=
[
]
;
function
getPooledTraverseContext
(
mapResult
keyPrefix
mapFunction
mapContext
)
{
if
(
traverseContextPool
.
length
)
{
var
traverseContext
=
traverseContextPool
.
pop
(
)
;
traverseContext
.
result
=
mapResult
;
traverseContext
.
keyPrefix
=
keyPrefix
;
traverseContext
.
func
=
mapFunction
;
traverseContext
.
context
=
mapContext
;
traverseContext
.
count
=
0
;
return
traverseContext
;
}
else
{
return
{
result
:
mapResult
keyPrefix
:
keyPrefix
func
:
mapFunction
context
:
mapContext
count
:
0
}
;
}
}
function
releaseTraverseContext
(
traverseContext
)
{
traverseContext
.
result
=
null
;
traverseContext
.
keyPrefix
=
null
;
traverseContext
.
func
=
null
;
traverseContext
.
context
=
null
;
traverseContext
.
count
=
0
;
if
(
traverseContextPool
.
length
<
POOL_SIZE
)
{
traverseContextPool
.
push
(
traverseContext
)
;
}
}
function
traverseAllChildrenImpl
(
children
nameSoFar
callback
traverseContext
)
{
var
type
=
typeof
children
;
if
(
type
=
=
=
'
undefined
'
|
|
type
=
=
=
'
boolean
'
)
{
children
=
null
;
}
var
invokeCallback
=
false
;
if
(
children
=
=
=
null
)
{
invokeCallback
=
true
;
}
else
{
switch
(
type
)
{
case
'
string
'
:
case
'
number
'
:
invokeCallback
=
true
;
break
;
case
'
object
'
:
switch
(
children
.
typeof
)
{
case
REACT_ELEMENT_TYPE
:
case
REACT_PORTAL_TYPE
:
invokeCallback
=
true
;
}
}
}
if
(
invokeCallback
)
{
callback
(
traverseContext
children
nameSoFar
=
=
=
'
'
?
SEPARATOR
+
getComponentKey
(
children
0
)
:
nameSoFar
)
;
return
1
;
}
var
child
=
void
0
;
var
nextName
=
void
0
;
var
subtreeCount
=
0
;
var
nextNamePrefix
=
nameSoFar
=
=
=
'
'
?
SEPARATOR
:
nameSoFar
+
SUBSEPARATOR
;
if
(
Array
.
isArray
(
children
)
)
{
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
child
=
children
[
i
]
;
nextName
=
nextNamePrefix
+
getComponentKey
(
child
i
)
;
subtreeCount
+
=
traverseAllChildrenImpl
(
child
nextName
callback
traverseContext
)
;
}
}
else
{
var
iteratorFn
=
getIteratorFn
(
children
)
;
if
(
typeof
iteratorFn
=
=
=
'
function
'
)
{
var
iterator
=
iteratorFn
.
call
(
children
)
;
var
step
=
void
0
;
var
ii
=
0
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
child
=
step
.
value
;
nextName
=
nextNamePrefix
+
getComponentKey
(
child
ii
+
+
)
;
subtreeCount
+
=
traverseAllChildrenImpl
(
child
nextName
callback
traverseContext
)
;
}
}
else
if
(
type
=
=
=
'
object
'
)
{
var
addendum
=
'
'
;
var
childrenString
=
'
'
+
children
;
reactProdInvariant
(
'
31
'
childrenString
=
=
=
'
[
object
Object
]
'
?
'
object
with
keys
{
'
+
Object
.
keys
(
children
)
.
join
(
'
'
)
+
'
}
'
:
childrenString
addendum
)
;
}
}
return
subtreeCount
;
}
function
traverseAllChildren
(
children
callback
traverseContext
)
{
if
(
children
=
=
null
)
{
return
0
;
}
return
traverseAllChildrenImpl
(
children
'
'
callback
traverseContext
)
;
}
function
getComponentKey
(
component
index
)
{
if
(
typeof
component
=
=
=
'
object
'
&
&
component
!
=
=
null
&
&
component
.
key
!
=
null
)
{
return
escape
(
component
.
key
)
;
}
return
index
.
toString
(
36
)
;
}
function
forEachSingleChild
(
bookKeeping
child
name
)
{
var
func
=
bookKeeping
.
func
context
=
bookKeeping
.
context
;
func
.
call
(
context
child
bookKeeping
.
count
+
+
)
;
}
function
forEachChildren
(
children
forEachFunc
forEachContext
)
{
if
(
children
=
=
null
)
{
return
children
;
}
var
traverseContext
=
getPooledTraverseContext
(
null
null
forEachFunc
forEachContext
)
;
traverseAllChildren
(
children
forEachSingleChild
traverseContext
)
;
releaseTraverseContext
(
traverseContext
)
;
}
function
mapSingleChildIntoContext
(
bookKeeping
child
childKey
)
{
var
result
=
bookKeeping
.
result
keyPrefix
=
bookKeeping
.
keyPrefix
func
=
bookKeeping
.
func
context
=
bookKeeping
.
context
;
var
mappedChild
=
func
.
call
(
context
child
bookKeeping
.
count
+
+
)
;
if
(
Array
.
isArray
(
mappedChild
)
)
{
mapIntoWithKeyPrefixInternal
(
mappedChild
result
childKey
function
(
c
)
{
return
c
;
}
)
;
}
else
if
(
mappedChild
!
=
null
)
{
if
(
isValidElement
(
mappedChild
)
)
{
mappedChild
=
cloneAndReplaceKey
(
mappedChild
keyPrefix
+
(
mappedChild
.
key
&
&
(
!
child
|
|
child
.
key
!
=
=
mappedChild
.
key
)
?
escapeUserProvidedKey
(
mappedChild
.
key
)
+
'
/
'
:
'
'
)
+
childKey
)
;
}
result
.
push
(
mappedChild
)
;
}
}
function
mapIntoWithKeyPrefixInternal
(
children
array
prefix
func
context
)
{
var
escapedPrefix
=
'
'
;
if
(
prefix
!
=
null
)
{
escapedPrefix
=
escapeUserProvidedKey
(
prefix
)
+
'
/
'
;
}
var
traverseContext
=
getPooledTraverseContext
(
array
escapedPrefix
func
context
)
;
traverseAllChildren
(
children
mapSingleChildIntoContext
traverseContext
)
;
releaseTraverseContext
(
traverseContext
)
;
}
function
mapChildren
(
children
func
context
)
{
if
(
children
=
=
null
)
{
return
children
;
}
var
result
=
[
]
;
mapIntoWithKeyPrefixInternal
(
children
result
null
func
context
)
;
return
result
;
}
function
countChildren
(
children
)
{
return
traverseAllChildren
(
children
function
(
)
{
return
null
;
}
null
)
;
}
function
toArray
(
children
)
{
var
result
=
[
]
;
mapIntoWithKeyPrefixInternal
(
children
result
null
function
(
child
)
{
return
child
;
}
)
;
return
result
;
}
function
onlyChild
(
children
)
{
!
isValidElement
(
children
)
?
reactProdInvariant
(
'
143
'
)
:
void
0
;
return
children
;
}
function
createContext
(
defaultValue
calculateChangedBits
)
{
if
(
calculateChangedBits
=
=
=
undefined
)
{
calculateChangedBits
=
null
;
}
else
{
}
var
context
=
{
typeof
:
REACT_CONTEXT_TYPE
_calculateChangedBits
:
calculateChangedBits
_currentValue
:
defaultValue
_currentValue2
:
defaultValue
_threadCount
:
0
Provider
:
null
Consumer
:
null
}
;
context
.
Provider
=
{
typeof
:
REACT_PROVIDER_TYPE
_context
:
context
}
;
{
context
.
Consumer
=
context
;
}
return
context
;
}
function
lazy
(
ctor
)
{
var
lazyType
=
{
typeof
:
REACT_LAZY_TYPE
_ctor
:
ctor
_status
:
-
1
_result
:
null
}
;
return
lazyType
;
}
function
forwardRef
(
render
)
{
return
{
typeof
:
REACT_FORWARD_REF_TYPE
render
:
render
}
;
}
function
memo
(
type
compare
)
{
return
{
typeof
:
REACT_MEMO_TYPE
type
:
type
compare
:
compare
=
=
=
undefined
?
null
:
compare
}
;
}
function
resolveDispatcher
(
)
{
var
dispatcher
=
ReactCurrentDispatcher
.
current
;
!
(
dispatcher
!
=
=
null
)
?
reactProdInvariant
(
'
321
'
)
:
void
0
;
return
dispatcher
;
}
function
useContext
(
Context
unstable_observedBits
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useContext
(
Context
unstable_observedBits
)
;
}
function
useState
(
initialState
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useState
(
initialState
)
;
}
function
useReducer
(
reducer
initialArg
init
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useReducer
(
reducer
initialArg
init
)
;
}
function
useRef
(
initialValue
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useRef
(
initialValue
)
;
}
function
useEffect
(
create
inputs
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useEffect
(
create
inputs
)
;
}
function
useLayoutEffect
(
create
inputs
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useLayoutEffect
(
create
inputs
)
;
}
function
useCallback
(
callback
inputs
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useCallback
(
callback
inputs
)
;
}
function
useMemo
(
create
inputs
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useMemo
(
create
inputs
)
;
}
function
useImperativeHandle
(
ref
create
inputs
)
{
var
dispatcher
=
resolveDispatcher
(
)
;
return
dispatcher
.
useImperativeHandle
(
ref
create
inputs
)
;
}
function
useDebugValue
(
value
formatterFn
)
{
}
var
React
=
{
Children
:
{
map
:
mapChildren
forEach
:
forEachChildren
count
:
countChildren
toArray
:
toArray
only
:
onlyChild
}
createRef
:
createRef
Component
:
Component
PureComponent
:
PureComponent
createContext
:
createContext
forwardRef
:
forwardRef
lazy
:
lazy
memo
:
memo
useCallback
:
useCallback
useContext
:
useContext
useEffect
:
useEffect
useImperativeHandle
:
useImperativeHandle
useDebugValue
:
useDebugValue
useLayoutEffect
:
useLayoutEffect
useMemo
:
useMemo
useReducer
:
useReducer
useRef
:
useRef
useState
:
useState
Fragment
:
REACT_FRAGMENT_TYPE
StrictMode
:
REACT_STRICT_MODE_TYPE
Suspense
:
REACT_SUSPENSE_TYPE
createElement
:
createElement
cloneElement
:
cloneElement
createFactory
:
createFactory
isValidElement
:
isValidElement
version
:
ReactVersion
unstable_ConcurrentMode
:
REACT_CONCURRENT_MODE_TYPE
unstable_Profiler
:
REACT_PROFILER_TYPE
__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
:
ReactSharedInternals
}
;
if
(
enableStableConcurrentModeAPIs
)
{
React
.
ConcurrentMode
=
REACT_CONCURRENT_MODE_TYPE
;
React
.
Profiler
=
REACT_PROFILER_TYPE
;
React
.
unstable_ConcurrentMode
=
undefined
;
React
.
unstable_Profiler
=
undefined
;
}
var
React
2
=
(
{
default
:
React
}
)
;
var
React
3
=
(
React
2
&
&
React
)
|
|
React
2
;
var
react
=
React
3
.
default
|
|
React
3
;
return
react
;
}
)
)
)
;
