"
use
strict
"
;
var
__extends
=
(
this
&
&
this
.
__extends
)
|
|
(
function
(
)
{
var
extendStatics
=
function
(
d
b
)
{
extendStatics
=
Object
.
setPrototypeOf
|
|
(
{
__proto__
:
[
]
}
instanceof
Array
&
&
function
(
d
b
)
{
d
.
__proto__
=
b
;
}
)
|
|
function
(
d
b
)
{
for
(
var
p
in
b
)
if
(
b
.
hasOwnProperty
(
p
)
)
d
[
p
]
=
b
[
p
]
;
}
;
return
extendStatics
(
d
b
)
;
}
;
return
function
(
d
b
)
{
extendStatics
(
d
b
)
;
function
__
(
)
{
this
.
constructor
=
d
;
}
d
.
prototype
=
b
=
=
=
null
?
Object
.
create
(
b
)
:
(
__
.
prototype
=
b
.
prototype
new
__
(
)
)
;
}
;
}
)
(
)
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
DevToolsNameGenerator
=
exports
.
NameSectionReader
=
exports
.
WasmDisassembler
=
exports
.
LabelMode
=
exports
.
NumericNameResolver
=
exports
.
DevToolsNameResolver
=
exports
.
DefaultNameResolver
=
void
0
;
var
WasmParser_js_1
=
require
(
"
.
/
WasmParser
.
js
"
)
;
var
NAME_SECTION_NAME
=
"
name
"
;
var
INVALID_NAME_SYMBOLS_REGEX
=
/
[
^
0
-
9A
-
Za
-
z
!
#
%
&
'
*
+
.
:
<
=
>
?
^
_
|
~
\
/
\
-
]
/
;
var
INVALID_NAME_SYMBOLS_REGEX_GLOBAL
=
new
RegExp
(
INVALID_NAME_SYMBOLS_REGEX
.
source
"
g
"
)
;
function
typeToString
(
type
)
{
switch
(
type
)
{
case
-
1
:
return
"
i32
"
;
case
-
2
:
return
"
i64
"
;
case
-
3
:
return
"
f32
"
;
case
-
4
:
return
"
f64
"
;
case
-
5
:
return
"
v128
"
;
case
-
16
:
return
"
anyfunc
"
;
case
-
17
:
return
"
anyref
"
;
default
:
throw
new
Error
(
"
Unexpected
type
"
+
type
)
;
}
}
function
formatFloat32
(
n
)
{
if
(
n
=
=
=
0
)
return
1
/
n
<
0
?
"
-
0
.
0
"
:
"
0
.
0
"
;
if
(
isFinite
(
n
)
)
return
n
.
toString
(
)
;
if
(
!
isNaN
(
n
)
)
return
n
<
0
?
"
-
inf
"
:
"
inf
"
;
var
view
=
new
DataView
(
new
ArrayBuffer
(
8
)
)
;
view
.
setFloat32
(
0
n
true
)
;
var
data
=
view
.
getInt32
(
0
true
)
;
var
payload
=
data
&
0x7fffff
;
var
canonicalBits
=
4194304
;
if
(
data
>
0
&
&
payload
=
=
=
canonicalBits
)
return
"
nan
"
;
else
if
(
payload
=
=
=
canonicalBits
)
return
"
-
nan
"
;
return
(
data
<
0
?
"
-
"
:
"
+
"
)
+
"
nan
:
0x
"
+
payload
.
toString
(
16
)
;
}
function
formatFloat64
(
n
)
{
if
(
n
=
=
=
0
)
return
1
/
n
<
0
?
"
-
0
.
0
"
:
"
0
.
0
"
;
if
(
isFinite
(
n
)
)
return
n
.
toString
(
)
;
if
(
!
isNaN
(
n
)
)
return
n
<
0
?
"
-
inf
"
:
"
inf
"
;
var
view
=
new
DataView
(
new
ArrayBuffer
(
8
)
)
;
view
.
setFloat64
(
0
n
true
)
;
var
data1
=
view
.
getUint32
(
0
true
)
;
var
data2
=
view
.
getInt32
(
4
true
)
;
var
payload
=
data1
+
(
data2
&
0xfffff
)
*
4294967296
;
var
canonicalBits
=
524288
*
4294967296
;
if
(
data2
>
0
&
&
payload
=
=
=
canonicalBits
)
return
"
nan
"
;
else
if
(
payload
=
=
=
canonicalBits
)
return
"
-
nan
"
;
return
(
data2
<
0
?
"
-
"
:
"
+
"
)
+
"
nan
:
0x
"
+
payload
.
toString
(
16
)
;
}
function
formatI32Array
(
bytes
count
)
{
var
dv
=
new
DataView
(
bytes
.
buffer
bytes
.
byteOffset
bytes
.
byteLength
)
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
count
;
i
+
+
)
result
.
push
(
"
0x
"
+
formatHex
(
dv
.
getInt32
(
i
<
<
2
true
)
8
)
)
;
return
result
.
join
(
"
"
)
;
}
function
formatI8Array
(
bytes
count
)
{
var
dv
=
new
DataView
(
bytes
.
buffer
bytes
.
byteOffset
bytes
.
byteLength
)
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
count
;
i
+
+
)
result
.
push
(
"
"
+
dv
.
getInt8
(
i
)
)
;
return
result
.
join
(
"
"
)
;
}
function
memoryAddressToString
(
address
code
)
{
var
defaultAlignFlags
;
switch
(
code
)
{
case
64768
:
case
64779
:
defaultAlignFlags
=
4
;
break
;
case
41
:
case
55
:
case
43
:
case
57
:
case
65026
:
case
65041
:
case
65048
:
case
65055
:
case
65062
:
case
65069
:
case
65076
:
case
65083
:
case
65090
:
case
65097
:
defaultAlignFlags
=
3
;
break
;
case
40
:
case
52
:
case
53
:
case
54
:
case
62
:
case
42
:
case
56
:
case
65024
:
case
65025
:
case
65040
:
case
65046
:
case
65047
:
case
65053
:
case
65054
:
case
65060
:
case
65061
:
case
65067
:
case
65068
:
case
65074
:
case
65075
:
case
65081
:
case
65082
:
case
65088
:
case
65089
:
case
65095
:
case
65096
:
case
65102
:
defaultAlignFlags
=
2
;
break
;
case
46
:
case
47
:
case
50
:
case
51
:
case
59
:
case
61
:
case
65043
:
case
65045
:
case
65050
:
case
65052
:
case
65057
:
case
65059
:
case
65064
:
case
65066
:
case
65071
:
case
65073
:
case
65078
:
case
65080
:
case
65085
:
case
65087
:
case
65092
:
case
65094
:
case
65099
:
case
65101
:
defaultAlignFlags
=
1
;
break
;
case
44
:
case
45
:
case
48
:
case
49
:
case
58
:
case
60
:
case
65042
:
case
65044
:
case
65049
:
case
65051
:
case
65056
:
case
65058
:
case
65063
:
case
65065
:
case
65070
:
case
65072
:
case
65077
:
case
65079
:
case
65084
:
case
65086
:
case
65091
:
case
65093
:
case
65098
:
case
65100
:
defaultAlignFlags
=
0
;
break
;
}
if
(
address
.
flags
=
=
defaultAlignFlags
)
return
!
address
.
offset
?
null
:
"
offset
=
"
+
address
.
offset
;
if
(
!
address
.
offset
)
return
"
align
=
"
+
(
1
<
<
address
.
flags
)
;
return
"
offset
=
"
+
(
address
.
offset
|
0
)
+
"
align
=
"
+
(
1
<
<
address
.
flags
)
;
}
function
globalTypeToString
(
type
)
{
var
typeStr
=
typeToString
(
type
.
contentType
)
;
return
type
.
mutability
?
"
(
mut
"
+
typeStr
+
"
)
"
:
typeStr
;
}
function
limitsToString
(
limits
)
{
return
(
limits
.
initial
+
(
limits
.
maximum
!
=
=
undefined
?
"
"
+
limits
.
maximum
:
"
"
)
)
;
}
var
paddingCache
=
[
"
0
"
"
00
"
"
000
"
]
;
function
formatHex
(
n
width
)
{
var
s
=
(
n
>
>
>
0
)
.
toString
(
16
)
.
toUpperCase
(
)
;
if
(
width
=
=
=
undefined
|
|
s
.
length
>
=
width
)
return
s
;
var
paddingIndex
=
width
-
s
.
length
-
1
;
while
(
paddingIndex
>
=
paddingCache
.
length
)
paddingCache
.
push
(
paddingCache
[
paddingCache
.
length
-
1
]
+
"
0
"
)
;
return
paddingCache
[
paddingIndex
]
+
s
;
}
var
IndentIncrement
=
"
"
;
function
isValidName
(
name
)
{
return
!
INVALID_NAME_SYMBOLS_REGEX
.
test
(
name
)
;
}
var
DefaultNameResolver
=
(
function
(
)
{
function
DefaultNameResolver
(
)
{
}
DefaultNameResolver
.
prototype
.
getTypeName
=
function
(
index
isRef
)
{
return
"
type
"
+
index
;
}
;
DefaultNameResolver
.
prototype
.
getTableName
=
function
(
index
isRef
)
{
return
"
table
"
+
index
;
}
;
DefaultNameResolver
.
prototype
.
getMemoryName
=
function
(
index
isRef
)
{
return
"
memory
"
+
index
;
}
;
DefaultNameResolver
.
prototype
.
getGlobalName
=
function
(
index
isRef
)
{
return
"
global
"
+
index
;
}
;
DefaultNameResolver
.
prototype
.
getFunctionName
=
function
(
index
isImport
isRef
)
{
return
(
isImport
?
"
import
"
:
"
func
"
)
+
index
;
}
;
DefaultNameResolver
.
prototype
.
getVariableName
=
function
(
funcIndex
index
isRef
)
{
return
"
var
"
+
index
;
}
;
DefaultNameResolver
.
prototype
.
getLabel
=
function
(
index
)
{
return
"
label
"
+
index
;
}
;
return
DefaultNameResolver
;
}
(
)
)
;
exports
.
DefaultNameResolver
=
DefaultNameResolver
;
var
EMPTY_STRING_ARRAY
=
[
]
;
var
DevToolsExportMetadata
=
(
function
(
)
{
function
DevToolsExportMetadata
(
functionExportNames
globalExportNames
memoryExportNames
tableExportNames
)
{
this
.
_functionExportNames
=
functionExportNames
;
this
.
_globalExportNames
=
globalExportNames
;
this
.
_memoryExportNames
=
memoryExportNames
;
this
.
_tableExportNames
=
tableExportNames
;
}
DevToolsExportMetadata
.
prototype
.
getFunctionExportNames
=
function
(
index
)
{
var
_a
;
return
(
_a
=
this
.
_functionExportNames
[
index
]
)
!
=
=
null
&
&
_a
!
=
=
void
0
?
_a
:
EMPTY_STRING_ARRAY
;
}
;
DevToolsExportMetadata
.
prototype
.
getGlobalExportNames
=
function
(
index
)
{
var
_a
;
return
(
_a
=
this
.
_globalExportNames
[
index
]
)
!
=
=
null
&
&
_a
!
=
=
void
0
?
_a
:
EMPTY_STRING_ARRAY
;
}
;
DevToolsExportMetadata
.
prototype
.
getMemoryExportNames
=
function
(
index
)
{
var
_a
;
return
(
_a
=
this
.
_memoryExportNames
[
index
]
)
!
=
=
null
&
&
_a
!
=
=
void
0
?
_a
:
EMPTY_STRING_ARRAY
;
}
;
DevToolsExportMetadata
.
prototype
.
getTableExportNames
=
function
(
index
)
{
var
_a
;
return
(
_a
=
this
.
_tableExportNames
[
index
]
)
!
=
=
null
&
&
_a
!
=
=
void
0
?
_a
:
EMPTY_STRING_ARRAY
;
}
;
return
DevToolsExportMetadata
;
}
(
)
)
;
var
DevToolsNameResolver
=
(
function
(
_super
)
{
__extends
(
DevToolsNameResolver
_super
)
;
function
DevToolsNameResolver
(
functionNames
localNames
memoryNames
tableNames
globalNames
)
{
var
_this
=
_super
.
call
(
this
)
|
|
this
;
_this
.
_functionNames
=
functionNames
;
_this
.
_localNames
=
localNames
;
_this
.
_memoryNames
=
memoryNames
;
_this
.
_tableNames
=
tableNames
;
_this
.
_globalNames
=
globalNames
;
return
_this
;
}
DevToolsNameResolver
.
prototype
.
getTableName
=
function
(
index
isRef
)
{
var
name
=
this
.
_tableNames
[
index
]
;
if
(
!
name
)
return
_super
.
prototype
.
getTableName
.
call
(
this
index
isRef
)
;
return
isRef
?
"
"
+
name
:
"
"
+
name
+
"
(
;
"
+
index
+
"
;
)
"
;
}
;
DevToolsNameResolver
.
prototype
.
getMemoryName
=
function
(
index
isRef
)
{
var
name
=
this
.
_memoryNames
[
index
]
;
if
(
!
name
)
return
_super
.
prototype
.
getMemoryName
.
call
(
this
index
isRef
)
;
return
isRef
?
"
"
+
name
:
"
"
+
name
+
"
(
;
"
+
index
+
"
;
)
"
;
}
;
DevToolsNameResolver
.
prototype
.
getGlobalName
=
function
(
index
isRef
)
{
var
name
=
this
.
_globalNames
[
index
]
;
if
(
!
name
)
return
_super
.
prototype
.
getGlobalName
.
call
(
this
index
isRef
)
;
return
isRef
?
"
"
+
name
:
"
"
+
name
+
"
(
;
"
+
index
+
"
;
)
"
;
}
;
DevToolsNameResolver
.
prototype
.
getFunctionName
=
function
(
index
isImport
isRef
)
{
var
name
=
this
.
_functionNames
[
index
]
;
if
(
!
name
)
return
_super
.
prototype
.
getFunctionName
.
call
(
this
index
isImport
isRef
)
;
return
isRef
?
"
"
+
name
:
"
"
+
name
+
"
(
;
"
+
index
+
"
;
)
"
;
}
;
DevToolsNameResolver
.
prototype
.
getVariableName
=
function
(
funcIndex
index
isRef
)
{
var
name
=
this
.
_localNames
[
funcIndex
]
&
&
this
.
_localNames
[
funcIndex
]
[
index
]
;
if
(
!
name
)
return
_super
.
prototype
.
getVariableName
.
call
(
this
funcIndex
index
isRef
)
;
return
isRef
?
"
"
+
name
:
"
"
+
name
+
"
(
;
"
+
index
+
"
;
)
"
;
}
;
return
DevToolsNameResolver
;
}
(
DefaultNameResolver
)
)
;
exports
.
DevToolsNameResolver
=
DevToolsNameResolver
;
var
NumericNameResolver
=
(
function
(
)
{
function
NumericNameResolver
(
)
{
}
NumericNameResolver
.
prototype
.
getTypeName
=
function
(
index
isRef
)
{
return
isRef
?
"
"
+
index
:
"
(
;
"
+
index
+
"
;
)
"
;
}
;
NumericNameResolver
.
prototype
.
getTableName
=
function
(
index
isRef
)
{
return
isRef
?
"
"
+
index
:
"
(
;
"
+
index
+
"
;
)
"
;
}
;
NumericNameResolver
.
prototype
.
getMemoryName
=
function
(
index
isRef
)
{
return
isRef
?
"
"
+
index
:
"
(
;
"
+
index
+
"
;
)
"
;
}
;
NumericNameResolver
.
prototype
.
getGlobalName
=
function
(
index
isRef
)
{
return
isRef
?
"
"
+
index
:
"
(
;
"
+
index
+
"
;
)
"
;
}
;
NumericNameResolver
.
prototype
.
getFunctionName
=
function
(
index
isImport
isRef
)
{
return
isRef
?
"
"
+
index
:
"
(
;
"
+
index
+
"
;
)
"
;
}
;
NumericNameResolver
.
prototype
.
getVariableName
=
function
(
funcIndex
index
isRef
)
{
return
isRef
?
"
"
+
index
:
"
(
;
"
+
index
+
"
;
)
"
;
}
;
NumericNameResolver
.
prototype
.
getLabel
=
function
(
index
)
{
return
null
;
}
;
return
NumericNameResolver
;
}
(
)
)
;
exports
.
NumericNameResolver
=
NumericNameResolver
;
var
LabelMode
;
(
function
(
LabelMode
)
{
LabelMode
[
LabelMode
[
"
Depth
"
]
=
0
]
=
"
Depth
"
;
LabelMode
[
LabelMode
[
"
WhenUsed
"
]
=
1
]
=
"
WhenUsed
"
;
LabelMode
[
LabelMode
[
"
Always
"
]
=
2
]
=
"
Always
"
;
}
)
(
LabelMode
=
exports
.
LabelMode
|
|
(
exports
.
LabelMode
=
{
}
)
)
;
var
WasmDisassembler
=
(
function
(
)
{
function
WasmDisassembler
(
)
{
this
.
_skipTypes
=
true
;
this
.
_exportMetadata
=
null
;
this
.
_lines
=
[
]
;
this
.
_offsets
=
[
]
;
this
.
_buffer
=
"
"
;
this
.
_indent
=
null
;
this
.
_indentLevel
=
0
;
this
.
_addOffsets
=
false
;
this
.
_done
=
false
;
this
.
_currentPosition
=
0
;
this
.
_nameResolver
=
new
DefaultNameResolver
(
)
;
this
.
_labelMode
=
LabelMode
.
WhenUsed
;
this
.
_functionBodyOffsets
=
[
]
;
this
.
_currentFunctionBodyOffset
=
null
;
this
.
_logFirstInstruction
=
false
;
this
.
_reset
(
)
;
}
WasmDisassembler
.
prototype
.
_reset
=
function
(
)
{
this
.
_types
=
[
]
;
this
.
_funcIndex
=
0
;
this
.
_funcTypes
=
[
]
;
this
.
_importCount
=
0
;
this
.
_globalCount
=
0
;
this
.
_memoryCount
=
0
;
this
.
_tableCount
=
0
;
this
.
_initExpression
=
[
]
;
this
.
_backrefLabels
=
null
;
this
.
_labelIndex
=
0
;
}
;
Object
.
defineProperty
(
WasmDisassembler
.
prototype
"
addOffsets
"
{
get
:
function
(
)
{
return
this
.
_addOffsets
;
}
set
:
function
(
value
)
{
if
(
this
.
_currentPosition
)
throw
new
Error
(
"
Cannot
switch
addOffsets
during
processing
.
"
)
;
this
.
_addOffsets
=
value
;
}
enumerable
:
false
configurable
:
true
}
)
;
Object
.
defineProperty
(
WasmDisassembler
.
prototype
"
skipTypes
"
{
get
:
function
(
)
{
return
this
.
_skipTypes
;
}
set
:
function
(
skipTypes
)
{
if
(
this
.
_currentPosition
)
throw
new
Error
(
"
Cannot
switch
skipTypes
during
processing
.
"
)
;
this
.
_skipTypes
=
skipTypes
;
}
enumerable
:
false
configurable
:
true
}
)
;
Object
.
defineProperty
(
WasmDisassembler
.
prototype
"
labelMode
"
{
get
:
function
(
)
{
return
this
.
_labelMode
;
}
set
:
function
(
value
)
{
if
(
this
.
_currentPosition
)
throw
new
Error
(
"
Cannot
switch
labelMode
during
processing
.
"
)
;
this
.
_labelMode
=
value
;
}
enumerable
:
false
configurable
:
true
}
)
;
Object
.
defineProperty
(
WasmDisassembler
.
prototype
"
exportMetadata
"
{
get
:
function
(
)
{
return
this
.
_exportMetadata
;
}
set
:
function
(
exportMetadata
)
{
if
(
this
.
_currentPosition
)
throw
new
Error
(
"
Cannot
switch
exportMetadata
during
processing
.
"
)
;
this
.
_exportMetadata
=
exportMetadata
;
}
enumerable
:
false
configurable
:
true
}
)
;
Object
.
defineProperty
(
WasmDisassembler
.
prototype
"
nameResolver
"
{
get
:
function
(
)
{
return
this
.
_nameResolver
;
}
set
:
function
(
resolver
)
{
if
(
this
.
_currentPosition
)
throw
new
Error
(
"
Cannot
switch
nameResolver
during
processing
.
"
)
;
this
.
_nameResolver
=
resolver
;
}
enumerable
:
false
configurable
:
true
}
)
;
WasmDisassembler
.
prototype
.
appendBuffer
=
function
(
s
)
{
this
.
_buffer
+
=
s
;
}
;
WasmDisassembler
.
prototype
.
newLine
=
function
(
)
{
if
(
this
.
addOffsets
)
this
.
_offsets
.
push
(
this
.
_currentPosition
)
;
this
.
_lines
.
push
(
this
.
_buffer
)
;
this
.
_buffer
=
"
"
;
}
;
WasmDisassembler
.
prototype
.
logStartOfFunctionBodyOffset
=
function
(
)
{
if
(
this
.
addOffsets
)
{
this
.
_currentFunctionBodyOffset
=
{
start
:
this
.
_currentPosition
}
;
}
}
;
WasmDisassembler
.
prototype
.
logEndOfFunctionBodyOffset
=
function
(
)
{
if
(
this
.
addOffsets
&
&
this
.
_currentFunctionBodyOffset
)
{
this
.
_currentFunctionBodyOffset
.
end
=
this
.
_currentPosition
;
this
.
_functionBodyOffsets
.
push
(
this
.
_currentFunctionBodyOffset
)
;
this
.
_currentFunctionBodyOffset
=
null
;
}
}
;
WasmDisassembler
.
prototype
.
printFuncType
=
function
(
typeIndex
)
{
var
type
=
this
.
_types
[
typeIndex
]
;
if
(
type
.
form
!
=
=
-
32
)
throw
new
Error
(
"
NYI
other
function
form
"
)
;
if
(
type
.
params
.
length
>
0
)
{
this
.
appendBuffer
(
"
(
param
"
)
;
for
(
var
i
=
0
;
i
<
type
.
params
.
length
;
i
+
+
)
{
this
.
appendBuffer
(
"
"
)
;
this
.
appendBuffer
(
typeToString
(
type
.
params
[
i
]
)
)
;
}
this
.
appendBuffer
(
"
)
"
)
;
}
if
(
type
.
returns
.
length
>
0
)
{
this
.
appendBuffer
(
"
(
result
"
)
;
for
(
var
i
=
0
;
i
<
type
.
returns
.
length
;
i
+
+
)
{
this
.
appendBuffer
(
"
"
)
;
this
.
appendBuffer
(
typeToString
(
type
.
returns
[
i
]
)
)
;
}
this
.
appendBuffer
(
"
)
"
)
;
}
}
;
WasmDisassembler
.
prototype
.
printBlockType
=
function
(
type
)
{
if
(
type
=
=
=
-
64
)
{
return
;
}
if
(
WasmParser_js_1
.
isTypeIndex
(
type
)
)
{
return
this
.
printFuncType
(
type
)
;
}
this
.
appendBuffer
(
"
(
result
"
)
;
this
.
appendBuffer
(
typeToString
(
type
)
)
;
this
.
appendBuffer
(
"
)
"
)
;
}
;
WasmDisassembler
.
prototype
.
printString
=
function
(
b
)
{
this
.
appendBuffer
(
'
"
'
)
;
for
(
var
i
=
0
;
i
<
b
.
length
;
i
+
+
)
{
var
byte
=
b
[
i
]
;
if
(
byte
<
0x20
|
|
byte
>
=
0x7f
|
|
byte
=
=
0x22
|
|
byte
=
=
0x5c
)
{
this
.
appendBuffer
(
"
\
\
"
+
(
byte
>
>
4
)
.
toString
(
16
)
+
(
byte
&
15
)
.
toString
(
16
)
)
;
}
else
{
this
.
appendBuffer
(
String
.
fromCharCode
(
byte
)
)
;
}
}
this
.
appendBuffer
(
'
"
'
)
;
}
;
WasmDisassembler
.
prototype
.
useLabel
=
function
(
depth
)
{
if
(
!
this
.
_backrefLabels
)
{
return
"
"
+
depth
;
}
var
i
=
this
.
_backrefLabels
.
length
-
depth
-
1
;
if
(
i
<
0
)
{
return
"
"
+
depth
;
}
var
backrefLabel
=
this
.
_backrefLabels
[
i
]
;
if
(
!
backrefLabel
.
useLabel
)
{
backrefLabel
.
useLabel
=
true
;
backrefLabel
.
label
=
this
.
_nameResolver
.
getLabel
(
this
.
_labelIndex
)
;
var
line
=
this
.
_lines
[
backrefLabel
.
line
]
;
this
.
_lines
[
backrefLabel
.
line
]
=
line
.
substring
(
0
backrefLabel
.
position
)
+
"
"
+
backrefLabel
.
label
+
line
.
substring
(
backrefLabel
.
position
)
;
this
.
_labelIndex
+
+
;
}
return
backrefLabel
.
label
|
|
"
"
+
depth
;
}
;
WasmDisassembler
.
prototype
.
printOperator
=
function
(
operator
)
{
var
code
=
operator
.
code
;
this
.
appendBuffer
(
WasmParser_js_1
.
OperatorCodeNames
[
code
]
)
;
switch
(
code
)
{
case
2
:
case
3
:
case
4
:
if
(
this
.
_labelMode
!
=
=
LabelMode
.
Depth
)
{
var
backrefLabel_1
=
{
line
:
this
.
_lines
.
length
position
:
this
.
_buffer
.
length
useLabel
:
false
label
:
null
}
;
if
(
this
.
_labelMode
=
=
=
LabelMode
.
Always
)
{
backrefLabel_1
.
useLabel
=
true
;
backrefLabel_1
.
label
=
this
.
_nameResolver
.
getLabel
(
this
.
_labelIndex
+
+
)
;
if
(
backrefLabel_1
.
label
)
{
this
.
appendBuffer
(
"
"
)
;
this
.
appendBuffer
(
backrefLabel_1
.
label
)
;
}
}
this
.
_backrefLabels
.
push
(
backrefLabel_1
)
;
}
this
.
printBlockType
(
operator
.
blockType
)
;
break
;
case
11
:
if
(
this
.
_labelMode
=
=
=
LabelMode
.
Depth
)
{
break
;
}
var
backrefLabel
=
this
.
_backrefLabels
.
pop
(
)
;
if
(
backrefLabel
.
label
)
{
this
.
appendBuffer
(
"
"
)
;
this
.
appendBuffer
(
backrefLabel
.
label
)
;
}
break
;
case
12
:
case
13
:
this
.
appendBuffer
(
"
"
)
;
this
.
appendBuffer
(
this
.
useLabel
(
operator
.
brDepth
)
)
;
break
;
case
14
:
for
(
var
i
=
0
;
i
<
operator
.
brTable
.
length
;
i
+
+
)
{
this
.
appendBuffer
(
"
"
)
;
this
.
appendBuffer
(
this
.
useLabel
(
operator
.
brTable
[
i
]
)
)
;
}
break
;
case
16
:
case
18
:
var
funcName
=
this
.
_nameResolver
.
getFunctionName
(
operator
.
funcIndex
operator
.
funcIndex
<
this
.
_importCount
true
)
;
this
.
appendBuffer
(
"
"
+
funcName
)
;
break
;
case
17
:
case
19
:
this
.
printFuncType
(
operator
.
typeIndex
)
;
break
;
case
32
:
case
33
:
case
34
:
var
paramName
=
this
.
_nameResolver
.
getVariableName
(
this
.
_funcIndex
operator
.
localIndex
true
)
;
this
.
appendBuffer
(
"
"
+
paramName
)
;
break
;
case
35
:
case
36
:
var
globalName
=
this
.
_nameResolver
.
getGlobalName
(
operator
.
globalIndex
true
)
;
this
.
appendBuffer
(
"
"
+
globalName
)
;
break
;
case
40
:
case
41
:
case
42
:
case
43
:
case
44
:
case
45
:
case
46
:
case
47
:
case
48
:
case
49
:
case
50
:
case
51
:
case
52
:
case
53
:
case
54
:
case
55
:
case
56
:
case
57
:
case
58
:
case
59
:
case
60
:
case
61
:
case
62
:
case
65024
:
case
65025
:
case
65026
:
case
65040
:
case
65041
:
case
65042
:
case
65043
:
case
65044
:
case
65045
:
case
65046
:
case
65047
:
case
65048
:
case
65049
:
case
65050
:
case
65051
:
case
65052
:
case
65053
:
case
65054
:
case
65055
:
case
65056
:
case
65057
:
case
65058
:
case
65059
:
case
65060
:
case
65061
:
case
65062
:
case
65063
:
case
65064
:
case
65065
:
case
65066
:
case
65067
:
case
65068
:
case
65069
:
case
65070
:
case
65071
:
case
65072
:
case
65073
:
case
65074
:
case
65075
:
case
65076
:
case
65077
:
case
65078
:
case
65079
:
case
65080
:
case
65081
:
case
65082
:
case
65083
:
case
65084
:
case
65085
:
case
65086
:
case
65087
:
case
65088
:
case
65089
:
case
65090
:
case
65091
:
case
65092
:
case
65093
:
case
65094
:
case
65095
:
case
65096
:
case
65097
:
case
65098
:
case
65099
:
case
65100
:
case
65101
:
case
65102
:
case
64768
:
case
64779
:
var
memoryAddress
=
memoryAddressToString
(
operator
.
memoryAddress
operator
.
code
)
;
if
(
memoryAddress
!
=
=
null
)
{
this
.
appendBuffer
(
"
"
)
;
this
.
appendBuffer
(
memoryAddress
)
;
}
break
;
case
63
:
case
64
:
break
;
case
65
:
this
.
appendBuffer
(
"
"
+
operator
.
literal
.
toString
(
)
)
;
break
;
case
66
:
this
.
appendBuffer
(
"
"
+
operator
.
literal
.
toString
(
)
)
;
break
;
case
67
:
this
.
appendBuffer
(
"
"
+
formatFloat32
(
operator
.
literal
)
)
;
break
;
case
68
:
this
.
appendBuffer
(
"
"
+
formatFloat64
(
operator
.
literal
)
)
;
break
;
case
64780
:
this
.
appendBuffer
(
"
i32x4
"
+
formatI32Array
(
operator
.
literal
4
)
)
;
break
;
case
64781
:
this
.
appendBuffer
(
"
"
+
formatI8Array
(
operator
.
lines
16
)
)
;
break
;
case
64789
:
case
64790
:
case
64791
:
case
64792
:
case
64793
:
case
64794
:
case
64795
:
case
64796
:
case
64799
:
case
64800
:
case
64797
:
case
64798
:
case
64801
:
case
64802
:
this
.
appendBuffer
(
"
"
+
operator
.
lineIndex
)
;
break
;
case
64520
:
case
64521
:
case
64525
:
this
.
appendBuffer
(
"
"
+
operator
.
segmentIndex
)
;
break
;
case
38
:
case
37
:
case
64529
:
{
var
tableName
=
this
.
_nameResolver
.
getTableName
(
operator
.
tableIndex
true
)
;
this
.
appendBuffer
(
"
"
+
tableName
)
;
break
;
}
case
64526
:
{
if
(
operator
.
tableIndex
=
=
=
0
&
&
operator
.
destinationIndex
=
=
=
0
)
break
;
var
tableName
=
this
.
_nameResolver
.
getTableName
(
operator
.
tableIndex
true
)
;
var
destinationName
=
this
.
_nameResolver
.
getTableName
(
operator
.
destinationIndex
true
)
;
this
.
appendBuffer
(
"
"
+
destinationName
+
"
"
+
tableName
)
;
break
;
}
case
64524
:
{
if
(
operator
.
tableIndex
=
=
=
0
)
{
this
.
appendBuffer
(
"
"
+
operator
.
segmentIndex
)
;
break
;
}
var
tableName
=
this
.
_nameResolver
.
getTableName
(
operator
.
tableIndex
true
)
;
this
.
appendBuffer
(
"
"
+
operator
.
segmentIndex
+
"
"
+
tableName
)
;
break
;
}
}
}
;
WasmDisassembler
.
prototype
.
printImportSource
=
function
(
info
)
{
this
.
printString
(
info
.
module
)
;
this
.
appendBuffer
(
"
"
)
;
this
.
printString
(
info
.
field
)
;
}
;
WasmDisassembler
.
prototype
.
increaseIndent
=
function
(
)
{
this
.
_indent
+
=
IndentIncrement
;
this
.
_indentLevel
+
+
;
}
;
WasmDisassembler
.
prototype
.
decreaseIndent
=
function
(
)
{
this
.
_indent
=
this
.
_indent
.
slice
(
0
-
IndentIncrement
.
length
)
;
this
.
_indentLevel
-
-
;
}
;
WasmDisassembler
.
prototype
.
disassemble
=
function
(
reader
)
{
var
_this
=
this
;
var
done
=
this
.
disassembleChunk
(
reader
)
;
if
(
!
done
)
return
null
;
var
lines
=
this
.
_lines
;
if
(
this
.
_addOffsets
)
{
lines
=
lines
.
map
(
function
(
line
index
)
{
var
position
=
formatHex
(
_this
.
_offsets
[
index
]
4
)
;
return
line
+
"
;
;
"
+
position
;
}
)
;
}
lines
.
push
(
"
"
)
;
var
result
=
lines
.
join
(
"
\
n
"
)
;
this
.
_lines
.
length
=
0
;
this
.
_offsets
.
length
=
0
;
this
.
_functionBodyOffsets
.
length
=
0
;
return
result
;
}
;
WasmDisassembler
.
prototype
.
getResult
=
function
(
)
{
var
linesReady
=
this
.
_lines
.
length
;
if
(
this
.
_backrefLabels
&
&
this
.
_labelMode
=
=
=
LabelMode
.
WhenUsed
)
{
this
.
_backrefLabels
.
some
(
function
(
backrefLabel
)
{
if
(
backrefLabel
.
useLabel
)
return
false
;
linesReady
=
backrefLabel
.
line
;
return
true
;
}
)
;
}
if
(
linesReady
=
=
=
0
)
{
return
{
lines
:
[
]
offsets
:
this
.
_addOffsets
?
[
]
:
undefined
done
:
this
.
_done
functionBodyOffsets
:
this
.
_addOffsets
?
[
]
:
undefined
}
;
}
if
(
linesReady
=
=
=
this
.
_lines
.
length
)
{
var
result_1
=
{
lines
:
this
.
_lines
offsets
:
this
.
_addOffsets
?
this
.
_offsets
:
undefined
done
:
this
.
_done
functionBodyOffsets
:
this
.
_addOffsets
?
this
.
_functionBodyOffsets
:
undefined
}
;
this
.
_lines
=
[
]
;
if
(
this
.
_addOffsets
)
{
this
.
_offsets
=
[
]
;
this
.
_functionBodyOffsets
=
[
]
;
}
return
result_1
;
}
var
result
=
{
lines
:
this
.
_lines
.
splice
(
0
linesReady
)
offsets
:
this
.
_addOffsets
?
this
.
_offsets
.
splice
(
0
linesReady
)
:
undefined
done
:
false
functionBodyOffsets
:
this
.
_addOffsets
?
this
.
_functionBodyOffsets
:
undefined
}
;
if
(
this
.
_backrefLabels
)
{
this
.
_backrefLabels
.
forEach
(
function
(
backrefLabel
)
{
backrefLabel
.
line
-
=
linesReady
;
}
)
;
}
return
result
;
}
;
WasmDisassembler
.
prototype
.
disassembleChunk
=
function
(
reader
offsetInModule
)
{
var
_this
=
this
;
if
(
offsetInModule
=
=
=
void
0
)
{
offsetInModule
=
0
;
}
if
(
this
.
_done
)
throw
new
Error
(
"
Invalid
state
:
disassembly
process
was
already
finished
.
"
)
;
var
_loop_1
=
function
(
)
{
this_1
.
_currentPosition
=
reader
.
position
+
offsetInModule
;
if
(
!
reader
.
read
(
)
)
return
{
value
:
false
}
;
switch
(
reader
.
state
)
{
case
2
:
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
newLine
(
)
;
this_1
.
_reset
(
)
;
if
(
!
reader
.
hasMoreBytes
(
)
)
{
this_1
.
_done
=
true
;
return
{
value
:
true
}
;
}
break
;
case
-
1
:
throw
reader
.
error
;
case
1
:
this_1
.
appendBuffer
(
"
(
module
"
)
;
this_1
.
newLine
(
)
;
break
;
case
4
:
break
;
case
3
:
sectionInfo
=
reader
.
result
;
switch
(
sectionInfo
.
id
)
{
case
1
:
case
2
:
case
7
:
case
6
:
case
3
:
case
8
:
case
10
:
case
5
:
case
11
:
case
4
:
case
9
:
break
;
default
:
reader
.
skipSection
(
)
;
break
;
}
break
;
case
15
:
memoryInfo
=
reader
.
result
;
memoryIndex
=
this_1
.
_memoryCount
+
+
;
memoryName
=
this_1
.
_nameResolver
.
getMemoryName
(
memoryIndex
false
)
;
this_1
.
appendBuffer
(
"
(
memory
"
+
memoryName
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_i
=
0
_a
=
this_1
.
_exportMetadata
.
getMemoryExportNames
(
memoryIndex
)
;
_i
<
_a
.
length
;
_i
+
+
)
{
var
exportName
=
_a
[
_i
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
this_1
.
appendBuffer
(
"
"
+
limitsToString
(
memoryInfo
.
limits
)
)
;
if
(
memoryInfo
.
shared
)
{
this_1
.
appendBuffer
(
"
shared
"
)
;
}
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
newLine
(
)
;
break
;
case
14
:
tableInfo
=
reader
.
result
;
tableIndex
=
this_1
.
_tableCount
+
+
;
tableName
=
this_1
.
_nameResolver
.
getTableName
(
tableIndex
false
)
;
this_1
.
appendBuffer
(
"
(
table
"
+
tableName
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_b
=
0
_c
=
this_1
.
_exportMetadata
.
getTableExportNames
(
tableIndex
)
;
_b
<
_c
.
length
;
_b
+
+
)
{
var
exportName
=
_c
[
_b
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
this_1
.
appendBuffer
(
"
"
+
limitsToString
(
tableInfo
.
limits
)
+
"
"
+
typeToString
(
tableInfo
.
elementType
)
+
"
)
"
)
;
this_1
.
newLine
(
)
;
break
;
case
17
:
if
(
this_1
.
_exportMetadata
=
=
=
null
)
{
exportInfo
=
reader
.
result
;
this_1
.
appendBuffer
(
"
(
export
"
)
;
this_1
.
printString
(
exportInfo
.
field
)
;
this_1
.
appendBuffer
(
"
"
)
;
switch
(
exportInfo
.
kind
)
{
case
0
:
funcName
=
this_1
.
_nameResolver
.
getFunctionName
(
exportInfo
.
index
exportInfo
.
index
<
this_1
.
_importCount
true
)
;
this_1
.
appendBuffer
(
"
(
func
"
+
funcName
+
"
)
"
)
;
break
;
case
1
:
tableName
=
this_1
.
_nameResolver
.
getTableName
(
exportInfo
.
index
true
)
;
this_1
.
appendBuffer
(
"
(
table
"
+
tableName
+
"
)
"
)
;
break
;
case
2
:
memoryName
=
this_1
.
_nameResolver
.
getMemoryName
(
exportInfo
.
index
true
)
;
this_1
.
appendBuffer
(
"
(
memory
"
+
memoryName
+
"
)
"
)
;
break
;
case
3
:
globalName
=
this_1
.
_nameResolver
.
getGlobalName
(
exportInfo
.
index
true
)
;
this_1
.
appendBuffer
(
"
(
global
"
+
globalName
+
"
)
"
)
;
break
;
default
:
throw
new
Error
(
"
Unsupported
export
"
+
exportInfo
.
kind
)
;
}
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
newLine
(
)
;
}
break
;
case
12
:
importInfo
=
reader
.
result
;
switch
(
importInfo
.
kind
)
{
case
0
:
this_1
.
_importCount
+
+
;
funcIndex
=
this_1
.
_funcIndex
+
+
;
funcName
=
this_1
.
_nameResolver
.
getFunctionName
(
funcIndex
true
false
)
;
this_1
.
appendBuffer
(
"
(
func
"
+
funcName
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_d
=
0
_e
=
this_1
.
_exportMetadata
.
getFunctionExportNames
(
funcIndex
)
;
_d
<
_e
.
length
;
_d
+
+
)
{
var
exportName
=
_e
[
_d
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
this_1
.
appendBuffer
(
"
(
import
"
)
;
this_1
.
printImportSource
(
importInfo
)
;
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
printFuncType
(
importInfo
.
funcTypeIndex
)
;
this_1
.
appendBuffer
(
"
)
"
)
;
break
;
case
3
:
globalImportInfo
=
importInfo
.
type
;
globalIndex
=
this_1
.
_globalCount
+
+
;
globalName
=
this_1
.
_nameResolver
.
getGlobalName
(
globalIndex
false
)
;
this_1
.
appendBuffer
(
"
(
global
"
+
globalName
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_f
=
0
_g
=
this_1
.
_exportMetadata
.
getGlobalExportNames
(
globalIndex
)
;
_f
<
_g
.
length
;
_f
+
+
)
{
var
exportName
=
_g
[
_f
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
this_1
.
appendBuffer
(
"
(
import
"
)
;
this_1
.
printImportSource
(
importInfo
)
;
this_1
.
appendBuffer
(
"
)
"
+
globalTypeToString
(
globalImportInfo
)
+
"
)
"
)
;
break
;
case
2
:
memoryImportInfo
=
importInfo
.
type
;
memoryIndex
=
this_1
.
_memoryCount
+
+
;
memoryName
=
this_1
.
_nameResolver
.
getMemoryName
(
memoryIndex
false
)
;
this_1
.
appendBuffer
(
"
(
memory
"
+
memoryName
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_h
=
0
_j
=
this_1
.
_exportMetadata
.
getMemoryExportNames
(
memoryIndex
)
;
_h
<
_j
.
length
;
_h
+
+
)
{
var
exportName
=
_j
[
_h
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
this_1
.
appendBuffer
(
"
(
import
"
)
;
this_1
.
printImportSource
(
importInfo
)
;
this_1
.
appendBuffer
(
"
)
"
+
limitsToString
(
memoryImportInfo
.
limits
)
)
;
if
(
memoryImportInfo
.
shared
)
{
this_1
.
appendBuffer
(
"
shared
"
)
;
}
this_1
.
appendBuffer
(
"
)
"
)
;
break
;
case
1
:
tableImportInfo
=
importInfo
.
type
;
tableIndex
=
this_1
.
_tableCount
+
+
;
tableName
=
this_1
.
_nameResolver
.
getTableName
(
tableIndex
false
)
;
this_1
.
appendBuffer
(
"
(
table
"
+
tableName
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_k
=
0
_l
=
this_1
.
_exportMetadata
.
getTableExportNames
(
tableIndex
)
;
_k
<
_l
.
length
;
_k
+
+
)
{
var
exportName
=
_l
[
_k
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
this_1
.
appendBuffer
(
"
(
import
"
)
;
this_1
.
printImportSource
(
importInfo
)
;
this_1
.
appendBuffer
(
"
)
"
+
limitsToString
(
tableImportInfo
.
limits
)
+
"
"
+
typeToString
(
tableImportInfo
.
elementType
)
+
"
)
"
)
;
break
;
default
:
throw
new
Error
(
"
NYI
other
import
types
:
"
+
importInfo
.
kind
)
;
}
this_1
.
newLine
(
)
;
break
;
case
33
:
elementSegmentInfo
=
reader
.
result
;
this_1
.
appendBuffer
(
"
(
elem
"
)
;
break
;
case
35
:
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
newLine
(
)
;
break
;
case
34
:
var
elementSegmentBody_1
=
reader
.
result
;
if
(
elementSegmentBody_1
.
elementType
!
=
0
)
{
var
typeName_1
=
typeToString
(
elementSegmentBody_1
.
elementType
)
;
this_1
.
appendBuffer
(
"
"
+
typeName_1
)
;
}
elementSegmentBody_1
.
elements
.
forEach
(
function
(
funcIndex
)
{
if
(
elementSegmentBody_1
.
asElements
)
{
if
(
funcIndex
=
=
WasmParser_js_1
.
NULL_FUNCTION_INDEX
)
{
_this
.
appendBuffer
(
"
(
ref
.
null
)
"
)
;
}
else
{
var
funcName_1
=
_this
.
_nameResolver
.
getFunctionName
(
funcIndex
funcIndex
<
_this
.
_importCount
true
)
;
_this
.
appendBuffer
(
"
(
ref
.
func
"
+
funcName_1
+
"
)
"
)
;
}
}
else
{
var
funcName_2
=
_this
.
_nameResolver
.
getFunctionName
(
funcIndex
funcIndex
<
_this
.
_importCount
true
)
;
_this
.
appendBuffer
(
"
"
+
funcName_2
)
;
}
}
)
;
break
;
case
39
:
globalInfo
=
reader
.
result
;
globalIndex
=
this_1
.
_globalCount
+
+
;
globalName
=
this_1
.
_nameResolver
.
getGlobalName
(
globalIndex
false
)
;
this_1
.
appendBuffer
(
"
(
global
"
+
globalName
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_m
=
0
_o
=
this_1
.
_exportMetadata
.
getGlobalExportNames
(
globalIndex
)
;
_m
<
_o
.
length
;
_m
+
+
)
{
var
exportName
=
_o
[
_m
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
this_1
.
appendBuffer
(
"
"
+
globalTypeToString
(
globalInfo
.
type
)
+
"
"
)
;
break
;
case
40
:
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
newLine
(
)
;
break
;
case
11
:
funcType
=
reader
.
result
;
typeIndex
=
this_1
.
_types
.
length
;
this_1
.
_types
.
push
(
funcType
)
;
if
(
!
this_1
.
_skipTypes
)
{
typeName
=
this_1
.
_nameResolver
.
getTypeName
(
typeIndex
false
)
;
this_1
.
appendBuffer
(
"
(
type
"
+
typeName
+
"
(
func
"
)
;
this_1
.
printFuncType
(
typeIndex
)
;
this_1
.
appendBuffer
(
"
)
)
"
)
;
this_1
.
newLine
(
)
;
}
break
;
case
22
:
startEntry
=
reader
.
result
;
funcName
=
this_1
.
_nameResolver
.
getFunctionName
(
startEntry
.
index
startEntry
.
index
<
this_1
.
_importCount
true
)
;
this_1
.
appendBuffer
(
"
(
start
"
+
funcName
+
"
)
"
)
;
this_1
.
newLine
(
)
;
break
;
case
36
:
this_1
.
appendBuffer
(
"
(
data
"
)
;
break
;
case
37
:
body
=
reader
.
result
;
this_1
.
appendBuffer
(
"
"
)
;
this_1
.
printString
(
body
.
data
)
;
break
;
case
38
:
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
newLine
(
)
;
break
;
case
25
:
break
;
case
26
:
this_1
.
_initExpression
.
push
(
reader
.
result
)
;
break
;
case
27
:
this_1
.
appendBuffer
(
"
(
"
)
;
this_1
.
_initExpression
.
forEach
(
function
(
op
index
)
{
if
(
op
.
code
=
=
=
11
)
{
return
;
}
if
(
index
>
0
)
{
_this
.
appendBuffer
(
"
"
)
;
}
_this
.
printOperator
(
op
)
;
}
)
;
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
_initExpression
.
length
=
0
;
break
;
case
13
:
this_1
.
_funcTypes
.
push
(
reader
.
result
.
typeIndex
)
;
break
;
case
28
:
func
=
reader
.
result
;
type
=
this_1
.
_types
[
this_1
.
_funcTypes
[
this_1
.
_funcIndex
-
this_1
.
_importCount
]
]
;
this_1
.
appendBuffer
(
"
(
func
"
)
;
this_1
.
appendBuffer
(
this_1
.
_nameResolver
.
getFunctionName
(
this_1
.
_funcIndex
false
false
)
)
;
if
(
this_1
.
_exportMetadata
!
=
=
null
)
{
for
(
var
_p
=
0
_q
=
this_1
.
_exportMetadata
.
getFunctionExportNames
(
this_1
.
_funcIndex
)
;
_p
<
_q
.
length
;
_p
+
+
)
{
var
exportName
=
_q
[
_p
]
;
this_1
.
appendBuffer
(
"
(
export
\
"
"
+
exportName
+
"
\
"
)
"
)
;
}
}
for
(
var
i
=
0
;
i
<
type
.
params
.
length
;
i
+
+
)
{
paramName
=
this_1
.
_nameResolver
.
getVariableName
(
this_1
.
_funcIndex
i
false
)
;
this_1
.
appendBuffer
(
"
(
param
"
+
paramName
+
"
"
+
typeToString
(
type
.
params
[
i
]
)
+
"
)
"
)
;
}
for
(
var
i
=
0
;
i
<
type
.
returns
.
length
;
i
+
+
)
{
this_1
.
appendBuffer
(
"
(
result
"
+
typeToString
(
type
.
returns
[
i
]
)
+
"
)
"
)
;
}
this_1
.
newLine
(
)
;
localIndex
=
type
.
params
.
length
;
if
(
func
.
locals
.
length
>
0
)
{
this_1
.
appendBuffer
(
"
"
)
;
for
(
var
_r
=
0
_s
=
func
.
locals
;
_r
<
_s
.
length
;
_r
+
+
)
{
var
l
=
_s
[
_r
]
;
for
(
var
i
=
0
;
i
<
l
.
count
;
i
+
+
)
{
paramName
=
this_1
.
_nameResolver
.
getVariableName
(
this_1
.
_funcIndex
localIndex
+
+
false
)
;
this_1
.
appendBuffer
(
"
(
local
"
+
paramName
+
"
"
+
typeToString
(
l
.
type
)
+
"
)
"
)
;
}
}
this_1
.
newLine
(
)
;
}
this_1
.
_indent
=
"
"
;
this_1
.
_indentLevel
=
0
;
this_1
.
_labelIndex
=
0
;
this_1
.
_backrefLabels
=
this_1
.
_labelMode
=
=
=
LabelMode
.
Depth
?
null
:
[
]
;
this_1
.
_logFirstInstruction
=
true
;
break
;
case
30
:
if
(
this_1
.
_logFirstInstruction
)
{
this_1
.
logStartOfFunctionBodyOffset
(
)
;
this_1
.
_logFirstInstruction
=
false
;
}
operator
=
reader
.
result
;
if
(
operator
.
code
=
=
11
&
&
this_1
.
_indentLevel
=
=
0
)
{
this_1
.
appendBuffer
(
"
)
"
)
;
this_1
.
newLine
(
)
;
break
;
}
switch
(
operator
.
code
)
{
case
11
:
case
5
:
this_1
.
decreaseIndent
(
)
;
break
;
}
this_1
.
appendBuffer
(
this_1
.
_indent
)
;
this_1
.
printOperator
(
operator
)
;
this_1
.
newLine
(
)
;
switch
(
operator
.
code
)
{
case
4
:
case
2
:
case
3
:
case
5
:
this_1
.
increaseIndent
(
)
;
break
;
}
break
;
case
31
:
this_1
.
_funcIndex
+
+
;
this_1
.
_backrefLabels
=
null
;
this_1
.
logEndOfFunctionBodyOffset
(
)
;
break
;
default
:
throw
new
Error
(
"
Expectected
state
:
"
+
reader
.
state
)
;
}
}
;
var
this_1
=
this
sectionInfo
memoryInfo
memoryIndex
memoryName
tableInfo
tableIndex
tableName
exportInfo
funcName
tableName
memoryName
globalName
importInfo
funcIndex
funcName
globalImportInfo
globalIndex
globalName
memoryImportInfo
memoryIndex
memoryName
tableImportInfo
tableIndex
tableName
elementSegmentInfo
globalInfo
globalIndex
globalName
funcType
typeIndex
typeName
startEntry
funcName
body
func
type
paramName
localIndex
paramName
operator
;
while
(
true
)
{
var
state_1
=
_loop_1
(
)
;
if
(
typeof
state_1
=
=
=
"
object
"
)
return
state_1
.
value
;
}
}
;
return
WasmDisassembler
;
}
(
)
)
;
exports
.
WasmDisassembler
=
WasmDisassembler
;
var
UNKNOWN_FUNCTION_PREFIX
=
"
unknown
"
;
var
NameSectionNameResolver
=
(
function
(
_super
)
{
__extends
(
NameSectionNameResolver
_super
)
;
function
NameSectionNameResolver
(
names
localNames
)
{
var
_this
=
_super
.
call
(
this
)
|
|
this
;
_this
.
_names
=
names
;
_this
.
_localNames
=
localNames
;
return
_this
;
}
NameSectionNameResolver
.
prototype
.
getFunctionName
=
function
(
index
isImport
isRef
)
{
var
name
=
this
.
_names
[
index
]
;
if
(
!
name
)
return
"
"
+
UNKNOWN_FUNCTION_PREFIX
+
index
;
return
isRef
?
"
"
+
name
:
"
"
+
name
+
"
(
;
"
+
index
+
"
;
)
"
;
}
;
NameSectionNameResolver
.
prototype
.
getVariableName
=
function
(
funcIndex
index
isRef
)
{
var
name
=
this
.
_localNames
[
funcIndex
]
&
&
this
.
_localNames
[
funcIndex
]
[
index
]
;
if
(
!
name
)
return
_super
.
prototype
.
getVariableName
.
call
(
this
funcIndex
index
isRef
)
;
return
isRef
?
"
"
+
name
:
"
"
+
name
+
"
(
;
"
+
index
+
"
;
)
"
;
}
;
return
NameSectionNameResolver
;
}
(
DefaultNameResolver
)
)
;
var
NameSectionReader
=
(
function
(
)
{
function
NameSectionReader
(
)
{
this
.
_done
=
false
;
this
.
_functionsCount
=
0
;
this
.
_functionImportsCount
=
0
;
this
.
_functionNames
=
null
;
this
.
_functionLocalNames
=
null
;
this
.
_hasNames
=
false
;
}
NameSectionReader
.
prototype
.
read
=
function
(
reader
)
{
var
_this
=
this
;
if
(
this
.
_done
)
throw
new
Error
(
"
Invalid
state
:
disassembly
process
was
already
finished
.
"
)
;
while
(
true
)
{
if
(
!
reader
.
read
(
)
)
return
false
;
switch
(
reader
.
state
)
{
case
2
:
if
(
!
reader
.
hasMoreBytes
(
)
)
{
this
.
_done
=
true
;
return
true
;
}
break
;
case
-
1
:
throw
reader
.
error
;
case
1
:
this
.
_functionsCount
=
0
;
this
.
_functionImportsCount
=
0
;
this
.
_functionNames
=
[
]
;
this
.
_functionLocalNames
=
[
]
;
this
.
_hasNames
=
false
;
break
;
case
4
:
break
;
case
3
:
var
sectionInfo
=
reader
.
result
;
if
(
sectionInfo
.
id
=
=
=
0
&
&
WasmParser_js_1
.
bytesToString
(
sectionInfo
.
name
)
=
=
=
NAME_SECTION_NAME
)
{
break
;
}
if
(
sectionInfo
.
id
=
=
=
3
|
|
sectionInfo
.
id
=
=
=
2
)
{
break
;
}
reader
.
skipSection
(
)
;
break
;
case
12
:
var
importInfo
=
reader
.
result
;
if
(
importInfo
.
kind
=
=
=
0
)
this
.
_functionImportsCount
+
+
;
break
;
case
13
:
this
.
_functionsCount
+
+
;
break
;
case
19
:
var
nameInfo
=
reader
.
result
;
if
(
nameInfo
.
type
=
=
=
1
)
{
var
functionNameInfo
=
nameInfo
;
functionNameInfo
.
names
.
forEach
(
function
(
naming
)
{
_this
.
_functionNames
[
naming
.
index
]
=
WasmParser_js_1
.
bytesToString
(
naming
.
name
)
;
}
)
;
this
.
_hasNames
=
true
;
}
else
if
(
nameInfo
.
type
=
=
=
2
)
{
var
localNameInfo
=
nameInfo
;
localNameInfo
.
funcs
.
forEach
(
function
(
localName
)
{
_this
.
_functionLocalNames
[
localName
.
index
]
=
[
]
;
localName
.
locals
.
forEach
(
function
(
naming
)
{
_this
.
_functionLocalNames
[
localName
.
index
]
[
naming
.
index
]
=
WasmParser_js_1
.
bytesToString
(
naming
.
name
)
;
}
)
;
}
)
;
this
.
_hasNames
=
true
;
}
break
;
default
:
throw
new
Error
(
"
Expectected
state
:
"
+
reader
.
state
)
;
}
}
}
;
NameSectionReader
.
prototype
.
hasValidNames
=
function
(
)
{
return
this
.
_hasNames
;
}
;
NameSectionReader
.
prototype
.
getNameResolver
=
function
(
)
{
if
(
!
this
.
hasValidNames
(
)
)
throw
new
Error
(
"
Has
no
valid
name
section
"
)
;
var
functionNamesLength
=
this
.
_functionImportsCount
+
this
.
_functionsCount
;
var
functionNames
=
this
.
_functionNames
.
slice
(
0
functionNamesLength
)
;
var
usedNameAt
=
Object
.
create
(
null
)
;
for
(
var
i
=
0
;
i
<
functionNames
.
length
;
i
+
+
)
{
var
name_1
=
functionNames
[
i
]
;
if
(
!
name_1
)
continue
;
var
goodName
=
!
(
name_1
in
usedNameAt
)
&
&
isValidName
(
name_1
)
&
&
name_1
.
indexOf
(
UNKNOWN_FUNCTION_PREFIX
)
!
=
=
0
;
if
(
!
goodName
)
{
if
(
usedNameAt
[
name_1
]
>
=
0
)
{
functionNames
[
usedNameAt
[
name_1
]
]
=
null
;
usedNameAt
[
name_1
]
=
-
1
;
}
functionNames
[
i
]
=
null
;
continue
;
}
usedNameAt
[
name_1
]
=
i
;
}
return
new
NameSectionNameResolver
(
functionNames
this
.
_functionLocalNames
)
;
}
;
return
NameSectionReader
;
}
(
)
)
;
exports
.
NameSectionReader
=
NameSectionReader
;
var
DevToolsNameGenerator
=
(
function
(
)
{
function
DevToolsNameGenerator
(
)
{
this
.
_done
=
false
;
this
.
_functionImportsCount
=
0
;
this
.
_memoryImportsCount
=
0
;
this
.
_tableImportsCount
=
0
;
this
.
_globalImportsCount
=
0
;
this
.
_functionNames
=
null
;
this
.
_functionLocalNames
=
null
;
this
.
_memoryNames
=
null
;
this
.
_tableNames
=
null
;
this
.
_globalNames
=
null
;
this
.
_functionExportNames
=
null
;
this
.
_globalExportNames
=
null
;
this
.
_memoryExportNames
=
null
;
this
.
_tableExportNames
=
null
;
}
DevToolsNameGenerator
.
prototype
.
_addExportName
=
function
(
exportNames
index
name
)
{
var
names
=
exportNames
[
index
]
;
if
(
names
)
{
names
.
push
(
name
)
;
}
else
{
exportNames
[
index
]
=
[
name
]
;
}
}
;
DevToolsNameGenerator
.
prototype
.
_setName
=
function
(
names
index
name
isNameSectionName
)
{
if
(
!
name
)
return
;
if
(
isNameSectionName
)
{
if
(
!
isValidName
(
name
)
)
return
;
names
[
index
]
=
name
;
}
else
if
(
!
names
[
index
]
)
{
names
[
index
]
=
name
.
replace
(
INVALID_NAME_SYMBOLS_REGEX_GLOBAL
"
_
"
)
;
}
}
;
DevToolsNameGenerator
.
prototype
.
read
=
function
(
reader
)
{
var
_this
=
this
;
if
(
this
.
_done
)
throw
new
Error
(
"
Invalid
state
:
disassembly
process
was
already
finished
.
"
)
;
while
(
true
)
{
if
(
!
reader
.
read
(
)
)
return
false
;
switch
(
reader
.
state
)
{
case
2
:
if
(
!
reader
.
hasMoreBytes
(
)
)
{
this
.
_done
=
true
;
return
true
;
}
break
;
case
-
1
:
throw
reader
.
error
;
case
1
:
this
.
_functionImportsCount
=
0
;
this
.
_memoryImportsCount
=
0
;
this
.
_tableImportsCount
=
0
;
this
.
_globalImportsCount
=
0
;
this
.
_functionNames
=
[
]
;
this
.
_functionLocalNames
=
[
]
;
this
.
_memoryNames
=
[
]
;
this
.
_tableNames
=
[
]
;
this
.
_globalNames
=
[
]
;
this
.
_functionExportNames
=
[
]
;
this
.
_globalExportNames
=
[
]
;
this
.
_memoryExportNames
=
[
]
;
this
.
_tableExportNames
=
[
]
;
break
;
case
4
:
break
;
case
3
:
var
sectionInfo
=
reader
.
result
;
if
(
sectionInfo
.
id
=
=
=
0
&
&
WasmParser_js_1
.
bytesToString
(
sectionInfo
.
name
)
=
=
=
NAME_SECTION_NAME
)
{
break
;
}
switch
(
sectionInfo
.
id
)
{
case
2
:
case
7
:
break
;
default
:
reader
.
skipSection
(
)
;
break
;
}
break
;
case
12
:
var
importInfo
=
reader
.
result
;
var
importName
=
WasmParser_js_1
.
bytesToString
(
importInfo
.
module
)
+
"
.
"
+
WasmParser_js_1
.
bytesToString
(
importInfo
.
field
)
;
switch
(
importInfo
.
kind
)
{
case
0
:
this
.
_setName
(
this
.
_functionNames
this
.
_functionImportsCount
+
+
importName
false
)
;
break
;
case
1
:
this
.
_setName
(
this
.
_tableNames
this
.
_tableImportsCount
+
+
importName
false
)
;
break
;
case
2
:
this
.
_setName
(
this
.
_memoryNames
this
.
_memoryImportsCount
+
+
importName
false
)
;
break
;
case
3
:
this
.
_setName
(
this
.
_globalNames
this
.
_globalImportsCount
+
+
importName
false
)
;
break
;
default
:
throw
new
Error
(
"
Unsupported
export
"
+
importInfo
.
kind
)
;
}
break
;
case
19
:
var
nameInfo
=
reader
.
result
;
if
(
nameInfo
.
type
=
=
=
1
)
{
var
functionNameInfo
=
nameInfo
;
functionNameInfo
.
names
.
forEach
(
function
(
naming
)
{
_this
.
_setName
(
_this
.
_functionNames
naming
.
index
WasmParser_js_1
.
bytesToString
(
naming
.
name
)
true
)
;
}
)
;
}
else
if
(
nameInfo
.
type
=
=
=
2
)
{
var
localNameInfo
=
nameInfo
;
localNameInfo
.
funcs
.
forEach
(
function
(
localName
)
{
_this
.
_functionLocalNames
[
localName
.
index
]
=
[
]
;
localName
.
locals
.
forEach
(
function
(
naming
)
{
_this
.
_functionLocalNames
[
localName
.
index
]
[
naming
.
index
]
=
WasmParser_js_1
.
bytesToString
(
naming
.
name
)
;
}
)
;
}
)
;
}
break
;
case
17
:
var
exportInfo
=
reader
.
result
;
var
exportName
=
WasmParser_js_1
.
bytesToString
(
exportInfo
.
field
)
;
switch
(
exportInfo
.
kind
)
{
case
0
:
this
.
_addExportName
(
this
.
_functionExportNames
exportInfo
.
index
exportName
)
;
this
.
_setName
(
this
.
_functionNames
exportInfo
.
index
exportName
false
)
;
break
;
case
3
:
this
.
_addExportName
(
this
.
_globalExportNames
exportInfo
.
index
exportName
)
;
this
.
_setName
(
this
.
_globalNames
exportInfo
.
index
exportName
false
)
;
break
;
case
2
:
this
.
_addExportName
(
this
.
_memoryExportNames
exportInfo
.
index
exportName
)
;
this
.
_setName
(
this
.
_memoryNames
exportInfo
.
index
exportName
false
)
;
break
;
case
1
:
this
.
_addExportName
(
this
.
_tableExportNames
exportInfo
.
index
exportName
)
;
this
.
_setName
(
this
.
_tableNames
exportInfo
.
index
exportName
false
)
;
break
;
default
:
throw
new
Error
(
"
Unsupported
export
"
+
exportInfo
.
kind
)
;
}
break
;
default
:
throw
new
Error
(
"
Expectected
state
:
"
+
reader
.
state
)
;
}
}
}
;
DevToolsNameGenerator
.
prototype
.
getExportMetadata
=
function
(
)
{
return
new
DevToolsExportMetadata
(
this
.
_functionExportNames
this
.
_globalExportNames
this
.
_memoryExportNames
this
.
_tableExportNames
)
;
}
;
DevToolsNameGenerator
.
prototype
.
getNameResolver
=
function
(
)
{
return
new
DevToolsNameResolver
(
this
.
_functionNames
this
.
_functionLocalNames
this
.
_memoryNames
this
.
_tableNames
this
.
_globalNames
)
;
}
;
return
DevToolsNameGenerator
;
}
(
)
)
;
exports
.
DevToolsNameGenerator
=
DevToolsNameGenerator
;
