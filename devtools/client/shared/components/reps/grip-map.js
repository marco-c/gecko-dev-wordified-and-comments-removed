"
use
strict
"
;
define
(
function
(
require
exports
module
)
{
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
createFactories
isGrip
wrapRender
}
=
require
(
"
.
/
rep
-
utils
"
)
;
const
{
Caption
}
=
createFactories
(
require
(
"
.
/
caption
"
)
)
;
const
{
PropRep
}
=
createFactories
(
require
(
"
.
/
prop
-
rep
"
)
)
;
const
{
MODE
}
=
require
(
"
.
/
constants
"
)
;
const
{
span
}
=
React
.
DOM
;
const
GripMap
=
React
.
createClass
(
{
displayName
:
"
GripMap
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
objectLink
:
React
.
PropTypes
.
func
isInterestingEntry
:
React
.
PropTypes
.
func
}
getTitle
(
object
)
{
let
title
=
object
&
&
object
.
class
?
object
.
class
:
"
Map
"
;
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
}
title
)
;
}
return
title
;
}
safeEntriesIterator
(
object
max
)
{
max
=
(
typeof
max
=
=
=
"
undefined
"
)
?
3
:
max
;
try
{
return
this
.
entriesIterator
(
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
entriesIterator
(
object
max
)
{
let
isInterestingEntry
=
this
.
props
.
isInterestingEntry
|
|
(
(
type
value
)
=
>
{
return
(
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
(
type
=
=
"
string
"
&
&
value
.
length
!
=
0
)
)
;
}
)
;
let
mapEntries
=
object
.
preview
&
&
object
.
preview
.
entries
?
object
.
preview
.
entries
:
[
]
;
let
indexes
=
this
.
getEntriesIndexes
(
mapEntries
max
isInterestingEntry
)
;
if
(
indexes
.
length
<
max
&
&
indexes
.
length
<
mapEntries
.
length
)
{
indexes
=
indexes
.
concat
(
this
.
getEntriesIndexes
(
mapEntries
max
-
indexes
.
length
(
t
value
name
)
=
>
{
return
!
isInterestingEntry
(
t
value
name
)
;
}
)
)
;
}
let
entries
=
this
.
getEntries
(
mapEntries
indexes
)
;
if
(
entries
.
length
<
mapEntries
.
length
)
{
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
entries
.
push
(
Caption
(
{
key
:
"
more
"
object
:
objectLink
(
{
object
}
{
mapEntries
.
length
-
max
}
more
)
}
)
)
;
}
return
entries
;
}
getEntries
(
entries
indexes
)
{
indexes
.
sort
(
function
(
a
b
)
{
return
a
-
b
;
}
)
;
return
indexes
.
map
(
(
index
i
)
=
>
{
let
[
key
entryValue
]
=
entries
[
index
]
;
let
value
=
entryValue
.
value
!
=
=
undefined
?
entryValue
.
value
:
entryValue
;
return
PropRep
(
{
name
:
key
equal
:
"
:
"
object
:
value
delim
:
(
i
<
indexes
.
length
-
1
|
|
indexes
.
length
<
entries
.
length
)
?
"
"
:
"
"
mode
:
MODE
.
TINY
objectLink
:
this
.
props
.
objectLink
}
)
;
}
)
;
}
getEntriesIndexes
(
entries
max
filter
)
{
return
entries
.
reduce
(
(
indexes
[
key
entry
]
i
)
=
>
{
if
(
indexes
.
length
<
max
)
{
let
value
=
(
entry
&
&
entry
.
value
!
=
=
undefined
)
?
entry
.
value
:
entry
;
let
type
=
(
value
&
&
value
.
class
?
value
.
class
:
typeof
value
)
.
toLowerCase
(
)
;
if
(
filter
(
type
value
key
)
)
{
indexes
.
push
(
i
)
;
}
}
return
indexes
;
}
[
]
)
;
}
render
:
wrapRender
(
function
(
)
{
let
object
=
this
.
props
.
object
;
let
props
=
this
.
safeEntriesIterator
(
object
(
this
.
props
.
mode
=
=
=
MODE
.
LONG
)
?
10
:
3
)
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
if
(
this
.
props
.
mode
=
=
=
MODE
.
TINY
)
{
return
(
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
}
"
"
)
)
)
;
}
return
(
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
}
"
{
"
)
props
objectLink
(
{
className
:
"
objectRightBrace
"
object
}
"
}
"
)
)
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
MapLike
"
)
;
}
exports
.
GripMap
=
{
rep
:
GripMap
supportsObject
}
;
}
)
;
