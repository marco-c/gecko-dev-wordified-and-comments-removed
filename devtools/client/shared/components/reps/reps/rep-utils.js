"
use
strict
"
;
define
(
function
(
require
exports
module
)
{
const
validProtocols
=
/
(
http
|
https
|
ftp
|
data
|
resource
|
chrome
)
:
/
i
;
const
urlRegex
=
/
(
^
|
[
\
s
(
;
'
"
]
)
(
(
?
:
https
?
:
\
/
(
\
/
)
?
|
www
\
d
{
0
3
}
[
.
]
[
a
-
z0
-
9
.
\
-
]
{
2
249
}
|
[
a
-
z0
-
9
.
\
-
]
{
2
250
}
[
.
]
[
a
-
z
]
{
2
4
}
\
/
)
[
-
\
w
.
!
~
*
'
(
)
;
/
?
:
&
=
+
#
%
]
*
)
/
im
;
const
uneatLastUrlCharsRegex
=
/
(
?
:
[
)
;
.
!
?
'
"
]
|
[
.
!
?
]
\
)
|
\
)
[
.
!
?
]
)
/
;
const
ELLIPSIS
=
"
\
u2026
"
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
span
}
=
dom
;
function
escapeNewLines
(
value
)
{
return
value
.
replace
(
/
\
r
/
gm
"
\
\
r
"
)
.
replace
(
/
\
n
/
gm
"
\
\
n
"
)
;
}
const
escapeMap
=
{
9
:
"
\
\
t
"
0xa
:
"
\
\
n
"
0xd
:
"
\
\
r
"
0x22
:
'
\
\
"
'
0x5c
:
"
\
\
\
\
"
}
;
const
commonEscapes
=
"
\
\
\
\
"
+
"
\
x00
-
\
x1f
"
+
"
\
x7f
-
\
x9f
"
+
"
\
ufeff
"
+
"
\
ufff0
-
\
ufffc
\
ufffe
\
uffff
"
+
"
\
ud800
-
\
udfff
"
+
"
\
u2061
-
\
u2064
"
+
"
\
u2028
-
\
u2029
"
+
"
\
ue000
-
\
uf8ff
"
;
const
escapeRegexp
=
new
RegExp
(
[
{
commonEscapes
}
]
"
g
"
)
;
const
escapeRegexpIncludingDoubleQuote
=
new
RegExp
(
[
{
commonEscapes
}
"
]
"
g
"
)
;
function
escapeString
(
str
escapeWhitespace
)
{
let
quote
=
'
"
'
;
let
regexp
=
escapeRegexp
;
if
(
str
.
includes
(
'
"
'
)
)
{
if
(
!
str
.
includes
(
"
'
"
)
)
{
quote
=
"
'
"
;
}
else
if
(
!
str
.
includes
(
"
"
)
&
&
!
str
.
includes
(
"
{
"
)
)
{
quote
=
"
"
;
}
else
{
regexp
=
escapeRegexpIncludingDoubleQuote
;
}
}
return
{
quote
}
{
str
.
replace
(
regexp
(
match
offset
)
=
>
{
const
c
=
match
.
charCodeAt
(
0
)
;
if
(
c
in
escapeMap
)
{
if
(
!
escapeWhitespace
&
&
(
c
=
=
=
9
|
|
c
=
=
=
0xa
|
|
c
=
=
=
0xd
)
)
{
return
match
[
0
]
;
}
return
escapeMap
[
c
]
;
}
if
(
c
>
=
0xd800
&
&
c
<
=
0xdfff
)
{
if
(
c
>
=
0xdc00
&
&
offset
>
0
)
{
-
-
offset
;
}
const
codePoint
=
str
.
codePointAt
(
offset
)
;
if
(
codePoint
>
=
0xd800
&
&
codePoint
<
=
0xdfff
)
{
return
\
\
u
{
codePoint
.
toString
(
16
)
}
;
}
else
if
(
codePoint
>
=
0xf0000
&
&
codePoint
<
=
0x10fffd
)
{
if
(
c
<
=
0xdbff
)
{
return
\
\
u
{
{
codePoint
.
toString
(
16
)
}
}
;
}
return
"
"
;
}
return
match
;
}
return
\
\
u
{
0000
{
c
.
toString
(
16
)
}
.
substr
(
-
4
)
}
;
}
)
}
{
quote
}
;
}
function
maybeEscapePropertyName
(
name
)
{
if
(
!
/
^
\
w
+
/
.
test
(
name
)
)
{
name
=
escapeString
(
name
)
;
}
return
name
;
}
function
cropMultipleLines
(
text
limit
)
{
return
escapeNewLines
(
cropString
(
text
limit
)
)
;
}
function
rawCropString
(
text
limit
alternativeText
=
ELLIPSIS
)
{
if
(
!
limit
|
|
limit
<
=
0
)
{
return
text
;
}
if
(
limit
<
=
alternativeText
.
length
)
{
limit
=
alternativeText
.
length
+
1
;
}
const
halfLimit
=
(
limit
-
alternativeText
.
length
)
/
2
;
if
(
text
.
length
>
limit
)
{
return
(
text
.
substr
(
0
Math
.
ceil
(
halfLimit
)
)
+
alternativeText
+
text
.
substr
(
text
.
length
-
Math
.
floor
(
halfLimit
)
)
)
;
}
return
text
;
}
function
cropString
(
text
limit
alternativeText
)
{
return
rawCropString
(
sanitizeString
(
{
text
}
)
limit
alternativeText
)
;
}
function
sanitizeString
(
text
)
{
const
re
=
new
RegExp
(
"
[
\
x00
-
\
x08
\
x0B
\
x0C
\
x0E
-
\
x1F
\
x7F
-
\
x9F
]
"
"
g
"
)
;
return
text
.
replace
(
re
"
\
ufffd
"
)
;
}
function
parseURLParams
(
url
)
{
url
=
new
URL
(
url
)
;
return
parseURLEncodedText
(
url
.
searchParams
)
;
}
function
parseURLEncodedText
(
text
)
{
const
params
=
[
]
;
if
(
text
=
=
"
"
)
{
return
params
;
}
const
searchParams
=
new
URLSearchParams
(
text
)
;
const
entries
=
[
.
.
.
searchParams
.
entries
(
)
]
;
return
entries
.
map
(
entry
=
>
{
return
{
name
:
entry
[
0
]
value
:
entry
[
1
]
}
;
}
)
;
}
function
getFileName
(
url
)
{
const
split
=
splitURLBase
(
url
)
;
return
split
.
name
;
}
function
splitURLBase
(
url
)
{
if
(
!
isDataURL
(
url
)
)
{
return
splitURLTrue
(
url
)
;
}
return
{
}
;
}
function
getURLDisplayString
(
url
)
{
return
cropString
(
url
)
;
}
function
isDataURL
(
url
)
{
return
url
&
&
url
.
substr
(
0
5
)
=
=
"
data
:
"
;
}
function
splitURLTrue
(
url
)
{
const
reSplitFile
=
/
(
.
*
?
)
:
\
/
{
2
3
}
(
[
^
\
/
]
*
)
(
.
*
?
)
(
[
^
\
/
]
*
?
)
(
|
\
?
.
*
)
/
;
const
m
=
reSplitFile
.
exec
(
url
)
;
if
(
!
m
)
{
return
{
name
:
url
path
:
url
}
;
}
else
if
(
m
[
4
]
=
=
"
"
&
&
m
[
5
]
=
=
"
"
)
{
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
3
]
name
:
m
[
3
]
!
=
"
/
"
?
m
[
3
]
:
m
[
2
]
}
;
}
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
2
]
+
m
[
3
]
name
:
m
[
4
]
+
m
[
5
]
}
;
}
function
wrapRender
(
renderMethod
)
{
const
wrappedFunction
=
function
(
props
)
{
try
{
return
renderMethod
.
call
(
this
props
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
span
(
{
className
:
"
objectBox
objectBox
-
failure
"
title
:
"
This
object
could
not
be
rendered
"
+
"
please
file
a
bug
on
bugzilla
.
mozilla
.
org
"
}
"
Invalid
object
"
)
;
}
}
;
wrappedFunction
.
propTypes
=
renderMethod
.
propTypes
;
return
wrappedFunction
;
}
function
getGripPreviewItems
(
grip
)
{
if
(
!
grip
)
{
return
[
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
items
)
{
return
grip
.
preview
.
items
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
childNodes
)
{
return
grip
.
preview
.
childNodes
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
entries
)
{
return
grip
.
preview
.
entries
.
reduce
(
(
res
entry
)
=
>
res
.
concat
(
entry
)
[
]
)
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
target
)
{
const
keys
=
Object
.
keys
(
grip
.
preview
.
properties
)
;
const
values
=
Object
.
values
(
grip
.
preview
.
properties
)
;
return
[
grip
.
preview
.
target
.
.
.
keys
.
.
.
values
]
;
}
if
(
grip
.
displayString
)
{
return
[
grip
.
displayString
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
ownProperties
)
{
let
propertiesValues
=
Object
.
values
(
grip
.
preview
.
ownProperties
)
.
map
(
property
=
>
property
.
value
|
|
property
)
;
const
propertyKeys
=
Object
.
keys
(
grip
.
preview
.
ownProperties
)
;
propertiesValues
=
propertiesValues
.
concat
(
propertyKeys
)
;
if
(
grip
.
preview
.
safeGetterValues
)
{
propertiesValues
=
propertiesValues
.
concat
(
Object
.
values
(
grip
.
preview
.
safeGetterValues
)
.
map
(
property
=
>
property
.
getterValue
|
|
property
)
)
;
}
return
propertiesValues
;
}
return
[
]
;
}
function
getGripType
(
object
noGrip
)
{
if
(
noGrip
|
|
Object
(
object
)
!
=
=
object
)
{
return
typeof
object
;
}
if
(
object
.
type
=
=
=
"
object
"
)
{
return
object
.
class
;
}
return
object
.
type
;
}
function
containsURL
(
grip
)
{
if
(
typeof
grip
!
=
=
"
string
"
|
|
grip
.
length
<
5
)
{
return
false
;
}
return
validProtocols
.
test
(
grip
)
;
}
function
isURL
(
token
)
{
try
{
if
(
!
validProtocols
.
test
(
token
)
)
{
return
false
;
}
new
URL
(
token
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
function
interleave
(
items
char
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
index
!
=
=
items
.
length
-
1
)
{
return
res
.
concat
(
item
char
)
;
}
return
res
.
concat
(
item
)
;
}
[
]
)
;
}
const
ellipsisElement
=
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
more
{
ELLIPSIS
}
}
ELLIPSIS
)
;
function
cleanupStyle
(
userProvidedStyle
createElement
)
{
const
allowedStylesRegex
=
new
RegExp
(
"
^
(
?
:
-
moz
-
)
?
(
?
:
align
|
background
|
border
|
box
|
clear
|
color
|
cursor
|
display
|
"
+
"
float
|
font
|
justify
|
line
|
margin
|
padding
|
position
|
text
|
transition
"
+
"
|
outline
|
vertical
-
align
|
white
-
space
|
word
|
writing
|
"
+
"
(
?
:
min
-
|
max
-
)
?
width
|
(
?
:
min
-
|
max
-
)
?
height
)
"
)
;
const
mozElementRegex
=
/
\
b
(
(
?
:
-
moz
-
)
?
element
)
[
\
s
(
'
"
]
+
/
gi
;
const
cssUrlRegex
=
/
url
\
(
[
\
'
\
"
]
?
(
[
^
\
)
]
*
)
/
g
;
const
dummy
=
createElement
(
"
div
"
)
;
dummy
.
style
=
userProvidedStyle
;
return
Array
.
from
(
dummy
.
style
)
.
filter
(
name
=
>
{
if
(
!
allowedStylesRegex
.
test
(
name
)
)
{
return
false
;
}
if
(
mozElementRegex
.
test
(
name
)
)
{
return
false
;
}
if
(
name
=
=
=
"
position
"
)
{
return
[
"
static
"
"
relative
"
]
.
includes
(
dummy
.
style
.
getPropertyValue
(
name
)
)
;
}
return
Array
.
from
(
dummy
.
style
[
name
]
.
matchAll
(
cssUrlRegex
)
)
.
map
(
match
=
>
match
[
1
]
)
.
every
(
potentialUrl
=
>
potentialUrl
.
startsWith
(
"
data
:
"
)
)
;
}
)
.
reduce
(
(
object
name
)
=
>
{
const
jsName
=
name
.
replace
(
/
-
(
[
a
-
z
]
)
/
g
(
_
char
)
=
>
char
.
toUpperCase
(
)
)
;
return
Object
.
assign
(
{
[
jsName
]
:
dummy
.
style
.
getPropertyValue
(
name
)
}
object
)
;
}
{
}
)
;
}
function
appendRTLClassNameIfNeeded
(
className
=
"
"
strToCheck
)
{
if
(
typeof
Services
=
=
"
undefined
"
|
|
!
Services
?
.
intl
?
.
stringHasRTLChars
(
strToCheck
)
)
{
return
className
;
}
return
{
className
}
has
-
rtl
-
char
;
}
module
.
exports
=
{
interleave
isURL
cropString
containsURL
rawCropString
appendRTLClassNameIfNeeded
sanitizeString
escapeString
wrapRender
cropMultipleLines
parseURLParams
parseURLEncodedText
getFileName
getURLDisplayString
maybeEscapePropertyName
getGripPreviewItems
getGripType
ellipsisElement
ELLIPSIS
uneatLastUrlCharsRegex
urlRegex
cleanupStyle
}
;
}
)
;
