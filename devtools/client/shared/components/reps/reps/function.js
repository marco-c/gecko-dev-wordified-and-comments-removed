const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
button
span
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
getGripType
isGrip
cropString
wrapRender
}
=
require
(
"
.
/
rep
-
utils
"
)
;
const
{
MODE
}
=
require
(
"
.
/
constants
"
)
;
const
IGNORED_SOURCE_URLS
=
[
"
debugger
eval
code
"
]
;
FunctionRep
.
propTypes
=
{
object
:
PropTypes
.
object
.
isRequired
onViewSourceInDebugger
:
PropTypes
.
func
shouldRenderTooltip
:
PropTypes
.
bool
}
;
function
FunctionRep
(
props
)
{
const
{
object
:
grip
onViewSourceInDebugger
recordTelemetryEvent
shouldRenderTooltip
}
=
props
;
let
jumpToDefinitionButton
;
if
(
onViewSourceInDebugger
&
&
grip
.
location
&
&
grip
.
location
.
url
&
&
!
IGNORED_SOURCE_URLS
.
includes
(
grip
.
location
.
url
)
)
{
jumpToDefinitionButton
=
button
(
{
className
:
"
jump
-
definition
"
draggable
:
false
title
:
"
Jump
to
definition
"
onClick
:
async
e
=
>
{
e
.
stopPropagation
(
)
;
if
(
recordTelemetryEvent
)
{
recordTelemetryEvent
(
"
jump_to_definition
"
)
;
}
onViewSourceInDebugger
(
grip
.
location
)
;
}
}
)
;
}
const
elProps
=
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
function
"
dir
:
"
ltr
"
}
;
const
parameterNames
=
(
grip
.
parameterNames
|
|
[
]
)
.
filter
(
Boolean
)
;
const
fnTitle
=
getFunctionTitle
(
grip
props
)
;
const
fnName
=
getFunctionName
(
grip
props
)
;
if
(
grip
.
isClassConstructor
)
{
const
classTitle
=
getClassTitle
(
grip
props
)
;
const
classBodyTooltip
=
getClassBody
(
parameterNames
true
props
)
;
const
classTooltip
=
{
classTitle
?
classTitle
.
props
.
children
:
"
"
}
{
fnName
?
fnName
:
"
"
}
{
classBodyTooltip
.
join
(
"
"
)
}
;
elProps
.
title
=
shouldRenderTooltip
?
classTooltip
:
null
;
return
span
(
elProps
classTitle
fnName
.
.
.
getClassBody
(
parameterNames
false
props
)
jumpToDefinitionButton
)
;
}
const
fnTooltip
=
{
fnTitle
?
fnTitle
.
props
.
children
:
"
"
}
{
fnName
?
fnName
:
"
"
}
(
{
parameterNames
.
join
(
"
"
)
}
)
;
elProps
.
title
=
shouldRenderTooltip
?
fnTooltip
:
null
;
const
returnSpan
=
span
(
elProps
fnTitle
fnName
"
(
"
.
.
.
getParams
(
parameterNames
)
"
)
"
jumpToDefinitionButton
)
;
return
returnSpan
;
}
function
getClassTitle
(
grip
)
{
return
span
(
{
className
:
"
objectTitle
"
}
"
class
"
)
;
}
function
getFunctionTitle
(
grip
props
)
{
const
{
mode
}
=
props
;
if
(
mode
=
=
=
MODE
.
TINY
&
&
!
grip
.
isGenerator
&
&
!
grip
.
isAsync
)
{
return
null
;
}
let
title
=
mode
=
=
=
MODE
.
TINY
?
"
"
:
"
function
"
;
if
(
grip
.
isGenerator
)
{
title
=
mode
=
=
=
MODE
.
TINY
?
"
*
"
:
"
function
*
"
;
}
if
(
grip
.
isAsync
)
{
title
=
{
"
async
"
+
"
"
}
{
title
}
;
}
return
span
(
{
className
:
"
objectTitle
"
}
title
)
;
}
function
getFunctionName
(
grip
props
=
{
}
)
{
let
{
functionName
}
=
props
;
let
name
;
if
(
functionName
)
{
const
end
=
functionName
.
length
-
1
;
functionName
=
functionName
.
startsWith
(
'
"
'
)
&
&
functionName
.
endsWith
(
'
"
'
)
?
functionName
.
substring
(
1
end
)
:
functionName
;
}
if
(
grip
.
displayName
!
=
undefined
&
&
functionName
!
=
undefined
&
&
grip
.
displayName
!
=
functionName
)
{
name
=
{
functionName
}
:
{
grip
.
displayName
}
;
}
else
{
name
=
cleanFunctionName
(
grip
.
userDisplayName
|
|
grip
.
displayName
|
|
grip
.
name
|
|
props
.
functionName
|
|
"
"
)
;
}
return
cropString
(
name
100
)
;
}
const
objectProperty
=
/
(
[
\
w
\
d
\
]
+
)
/
;
const
arrayProperty
=
/
\
[
(
.
*
?
)
\
]
/
;
const
functionProperty
=
/
(
[
\
w
\
d
]
+
)
[
\
/
\
.
<
]
*
?
/
;
const
annonymousProperty
=
/
(
[
\
w
\
d
]
+
)
\
(
\
^
\
)
/
;
function
cleanFunctionName
(
name
)
{
for
(
const
reg
of
[
objectProperty
arrayProperty
functionProperty
annonymousProperty
]
)
{
const
match
=
reg
.
exec
(
name
)
;
if
(
match
)
{
return
match
[
1
]
;
}
}
return
name
;
}
function
getClassBody
(
constructorParams
textOnly
=
false
props
)
{
const
{
mode
}
=
props
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
[
]
;
}
return
[
"
{
"
.
.
.
getClassConstructor
(
textOnly
constructorParams
)
"
}
"
]
;
}
function
getClassConstructor
(
textOnly
=
false
parameterNames
)
{
if
(
parameterNames
.
length
=
=
=
0
)
{
return
[
]
;
}
if
(
textOnly
)
{
return
[
constructor
(
{
parameterNames
.
join
(
"
"
)
}
)
]
;
}
return
[
"
constructor
(
"
.
.
.
getParams
(
parameterNames
)
"
)
"
]
;
}
function
getParams
(
parameterNames
)
{
return
parameterNames
.
flatMap
(
(
param
index
arr
)
=
>
{
return
[
span
(
{
className
:
"
param
"
}
param
)
index
=
=
=
arr
.
length
-
1
?
"
"
:
span
(
{
className
:
"
delimiter
"
}
"
"
)
]
;
}
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
const
type
=
getGripType
(
grip
noGrip
)
;
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
type
=
=
"
function
"
;
}
return
type
=
=
"
Function
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
FunctionRep
)
supportsObject
cleanFunctionName
getFunctionName
}
;
