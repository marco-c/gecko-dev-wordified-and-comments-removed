import
PropTypes
from
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
.
mjs
"
;
import
{
div
span
}
from
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
.
mjs
"
;
import
{
wrapRender
}
from
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
reps
/
reps
/
rep
-
utils
.
mjs
"
;
import
{
cleanFunctionName
}
from
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
reps
/
reps
/
function
.
mjs
"
;
import
{
isLongString
}
from
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
reps
/
reps
/
string
.
mjs
"
;
import
{
MODE
}
from
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
reps
/
reps
/
constants
.
mjs
"
;
import
{
Rep
}
from
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
reps
/
reps
/
rep
.
mjs
"
;
const
IGNORED_SOURCE_URLS
=
[
"
debugger
eval
code
"
]
;
ErrorRep
.
propTypes
=
{
object
:
PropTypes
.
object
.
isRequired
mode
:
PropTypes
.
oneOf
(
Object
.
values
(
MODE
)
)
renderStacktrace
:
PropTypes
.
func
shouldRenderTooltip
:
PropTypes
.
bool
}
;
function
ErrorRep
(
props
)
{
const
{
object
mode
shouldRenderTooltip
depth
}
=
props
;
const
preview
=
object
.
preview
;
const
customFormat
=
props
.
customFormat
&
&
mode
!
=
=
MODE
.
TINY
&
&
mode
!
=
=
MODE
.
HEADER
&
&
!
depth
;
const
name
=
getErrorName
(
props
)
;
const
errorTitle
=
mode
=
=
=
MODE
.
TINY
|
|
mode
=
=
=
MODE
.
HEADER
?
name
:
{
name
}
:
;
const
content
=
[
]
;
if
(
customFormat
)
{
content
.
push
(
errorTitle
)
;
}
else
{
content
.
push
(
span
(
{
className
:
"
objectTitle
"
key
:
"
title
"
}
errorTitle
)
)
;
}
if
(
mode
!
=
=
MODE
.
TINY
&
&
mode
!
=
=
MODE
.
HEADER
)
{
content
.
push
(
Rep
(
{
.
.
.
props
key
:
"
message
"
object
:
preview
.
message
mode
:
props
.
mode
|
|
MODE
.
TINY
useQuotes
:
false
}
)
)
;
}
const
renderStack
=
preview
.
stack
&
&
customFormat
;
if
(
renderStack
)
{
const
stacktrace
=
props
.
renderStacktrace
?
props
.
renderStacktrace
(
parseStackString
(
preview
.
stack
)
)
:
getStacktraceElements
(
props
preview
)
;
content
.
push
(
stacktrace
)
;
}
const
renderCause
=
customFormat
&
&
preview
.
hasOwnProperty
(
"
cause
"
)
;
if
(
renderCause
)
{
content
.
push
(
getCauseElement
(
props
preview
)
)
;
}
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
objectBox
-
stackTrace
{
customFormat
?
"
reps
-
custom
-
format
"
:
"
"
}
title
:
shouldRenderTooltip
?
{
name
}
:
"
{
preview
.
message
}
"
:
null
}
.
.
.
content
)
;
}
function
getErrorName
(
props
)
{
const
{
object
}
=
props
;
const
preview
=
object
.
preview
;
let
name
;
if
(
typeof
preview
?
.
name
=
=
=
"
string
"
&
&
preview
.
kind
)
{
switch
(
preview
.
kind
)
{
case
"
Error
"
:
name
=
preview
.
name
;
break
;
case
"
DOMException
"
:
name
=
preview
.
kind
;
break
;
default
:
throw
new
Error
(
"
Unknown
preview
kind
for
the
Error
rep
.
"
)
;
}
}
else
{
name
=
"
Error
"
;
}
return
name
;
}
function
getStacktraceElements
(
props
preview
)
{
const
stack
=
[
]
;
if
(
!
preview
.
stack
)
{
return
stack
;
}
parseStackString
(
preview
.
stack
)
.
forEach
(
(
frame
index
)
=
>
{
let
onLocationClick
;
const
{
filename
lineNumber
columnNumber
functionName
location
}
=
frame
;
if
(
props
.
onViewSourceInDebugger
&
&
!
IGNORED_SOURCE_URLS
.
includes
(
filename
)
)
{
onLocationClick
=
e
=
>
{
e
.
stopPropagation
(
)
;
props
.
onViewSourceInDebugger
(
{
url
:
filename
line
:
lineNumber
column
:
columnNumber
}
)
;
}
;
}
stack
.
push
(
"
\
t
"
span
(
{
key
:
fn
{
index
}
className
:
"
objectBox
-
stackTrace
-
fn
"
}
cleanFunctionName
(
functionName
)
)
"
"
span
(
{
key
:
location
{
index
}
className
:
"
objectBox
-
stackTrace
-
location
"
onClick
:
onLocationClick
title
:
onLocationClick
?
View
source
in
debugger
{
location
}
:
undefined
}
location
)
"
\
n
"
)
;
}
)
;
return
span
(
{
key
:
"
stack
"
className
:
"
objectBox
-
stackTrace
-
grid
"
}
stack
)
;
}
function
getCauseElement
(
props
preview
)
{
return
div
(
{
key
:
"
cause
-
container
"
className
:
"
error
-
rep
-
cause
"
}
"
Caused
by
:
"
Rep
(
{
.
.
.
props
key
:
"
cause
"
object
:
preview
.
cause
mode
:
props
.
mode
|
|
MODE
.
TINY
}
)
)
;
}
function
parseStackString
(
stack
)
{
if
(
!
stack
)
{
return
[
]
;
}
const
isStacktraceALongString
=
isLongString
(
stack
)
;
const
stackString
=
isStacktraceALongString
?
stack
.
initial
:
stack
;
if
(
typeof
stackString
!
=
=
"
string
"
)
{
return
[
]
;
}
const
res
=
[
]
;
stackString
.
split
(
"
\
n
"
)
.
forEach
(
(
frame
index
frames
)
=
>
{
if
(
!
frame
)
{
return
;
}
if
(
isStacktraceALongString
&
&
index
=
=
=
frames
.
length
-
1
)
{
return
;
}
let
functionName
;
let
location
;
const
atCharIndex
=
frame
.
indexOf
(
"
"
)
;
if
(
atCharIndex
>
-
1
)
{
functionName
=
frame
.
slice
(
0
atCharIndex
)
;
location
=
frame
.
slice
(
atCharIndex
+
1
)
;
}
if
(
location
&
&
location
.
includes
(
"
-
>
"
)
)
{
location
=
location
.
split
(
"
-
>
"
)
.
pop
(
)
;
}
if
(
!
functionName
)
{
functionName
=
"
<
anonymous
>
"
;
}
const
locationParts
=
location
?
location
.
match
(
/
^
(
.
*
)
:
(
\
d
+
)
:
(
\
d
+
)
/
)
:
null
;
if
(
location
&
&
locationParts
)
{
const
[
filename
line
column
]
=
locationParts
;
res
.
push
(
{
filename
functionName
location
columnNumber
:
Number
(
column
)
lineNumber
:
Number
(
line
)
}
)
;
}
}
)
;
return
res
;
}
function
supportsObject
(
object
)
{
return
(
object
?
.
isError
|
|
object
?
.
class
=
=
=
"
DOMException
"
|
|
object
?
.
class
=
=
=
"
Exception
"
)
;
}
const
rep
=
wrapRender
(
ErrorRep
)
;
export
{
rep
supportsObject
}
;
