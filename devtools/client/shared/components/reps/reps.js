(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
]
factory
)
;
else
{
var
a
=
typeof
exports
=
=
=
'
object
'
?
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
)
:
factory
(
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
]
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
this
function
(
__WEBPACK_EXTERNAL_MODULE_0__
__WEBPACK_EXTERNAL_MODULE_49__
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
{
return
installedModules
[
moduleId
]
.
exports
;
}
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
15
)
;
}
)
(
[
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_0__
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
validProtocols
=
/
^
(
http
|
https
|
ftp
|
data
|
javascript
|
resource
|
chrome
)
:
/
i
;
const
tokenSplitRegex
=
/
(
\
s
|
\
'
|
\
"
|
\
\
)
+
/
;
function
isGrip
(
object
)
{
return
object
&
&
object
.
actor
;
}
function
escapeNewLines
(
value
)
{
return
value
.
replace
(
/
\
r
/
gm
"
\
\
r
"
)
.
replace
(
/
\
n
/
gm
"
\
\
n
"
)
;
}
const
escapeMap
=
{
9
:
"
\
\
t
"
0xa
:
"
\
\
n
"
0xd
:
"
\
\
r
"
0x22
:
"
\
\
\
"
"
0x5c
:
"
\
\
\
\
"
}
;
const
escapeRegexp
=
new
RegExp
(
"
[
"
+
"
\
"
\
\
\
\
"
+
"
\
x00
-
\
x1f
"
+
"
\
x7f
-
\
x9f
"
+
"
\
ufeff
"
+
"
\
ufff0
-
\
ufffc
\
ufffe
\
uffff
"
+
"
\
ud800
-
\
udfff
"
+
"
\
u2061
-
\
u2064
"
+
"
\
u2028
-
\
u2029
"
+
"
\
ue000
-
\
uf8ff
"
+
"
]
"
"
g
"
)
;
function
escapeString
(
str
escapeWhitespace
)
{
return
"
\
"
"
+
str
.
replace
(
escapeRegexp
(
match
offset
)
=
>
{
let
c
=
match
.
charCodeAt
(
0
)
;
if
(
c
in
escapeMap
)
{
if
(
!
escapeWhitespace
&
&
(
c
=
=
=
9
|
|
c
=
=
=
0xa
|
|
c
=
=
=
0xd
)
)
{
return
match
[
0
]
;
}
return
escapeMap
[
c
]
;
}
if
(
c
>
=
0xd800
&
&
c
<
=
0xdfff
)
{
if
(
c
>
=
0xdc00
&
&
offset
>
0
)
{
-
-
offset
;
}
let
codePoint
=
str
.
codePointAt
(
offset
)
;
if
(
codePoint
>
=
0xd800
&
&
codePoint
<
=
0xdfff
)
{
return
"
\
\
u
"
+
codePoint
.
toString
(
16
)
;
}
else
if
(
codePoint
>
=
0xf0000
&
&
codePoint
<
=
0x10fffd
)
{
if
(
c
<
=
0xdbff
)
{
return
"
\
\
u
{
"
+
codePoint
.
toString
(
16
)
+
"
}
"
;
}
return
"
"
;
}
return
match
;
}
return
"
\
\
u
"
+
(
"
0000
"
+
c
.
toString
(
16
)
)
.
substr
(
-
4
)
;
}
)
+
"
\
"
"
;
}
function
maybeEscapePropertyName
(
name
)
{
if
(
!
/
^
\
w
+
/
.
test
(
name
)
)
{
name
=
escapeString
(
name
)
;
}
return
name
;
}
function
cropMultipleLines
(
text
limit
)
{
return
escapeNewLines
(
cropString
(
text
limit
)
)
;
}
function
rawCropString
(
text
limit
alternativeText
)
{
if
(
!
alternativeText
)
{
alternativeText
=
"
\
u2026
"
;
}
if
(
!
limit
|
|
limit
<
=
0
)
{
return
text
;
}
if
(
limit
<
=
alternativeText
.
length
)
{
limit
=
alternativeText
.
length
+
1
;
}
let
halfLimit
=
(
limit
-
alternativeText
.
length
)
/
2
;
if
(
text
.
length
>
limit
)
{
return
text
.
substr
(
0
Math
.
ceil
(
halfLimit
)
)
+
alternativeText
+
text
.
substr
(
text
.
length
-
Math
.
floor
(
halfLimit
)
)
;
}
return
text
;
}
function
cropString
(
text
limit
alternativeText
)
{
return
rawCropString
(
sanitizeString
(
text
+
"
"
)
limit
alternativeText
)
;
}
function
sanitizeString
(
text
)
{
let
re
=
new
RegExp
(
"
[
\
x00
-
\
x08
\
x0B
\
x0C
\
x0E
-
\
x1F
\
x7F
-
\
x9F
]
"
"
g
"
)
;
return
text
.
replace
(
re
"
\
ufffd
"
)
;
}
function
parseURLParams
(
url
)
{
url
=
new
URL
(
url
)
;
return
parseURLEncodedText
(
url
.
searchParams
)
;
}
function
parseURLEncodedText
(
text
)
{
let
params
=
[
]
;
if
(
text
=
=
"
"
)
{
return
params
;
}
let
searchParams
=
new
URLSearchParams
(
text
)
;
let
entries
=
[
.
.
.
searchParams
.
entries
(
)
]
;
return
entries
.
map
(
entry
=
>
{
return
{
name
:
entry
[
0
]
value
:
entry
[
1
]
}
;
}
)
;
}
function
getFileName
(
url
)
{
let
split
=
splitURLBase
(
url
)
;
return
split
.
name
;
}
function
splitURLBase
(
url
)
{
if
(
!
isDataURL
(
url
)
)
{
return
splitURLTrue
(
url
)
;
}
return
{
}
;
}
function
getURLDisplayString
(
url
)
{
return
cropString
(
url
)
;
}
function
isDataURL
(
url
)
{
return
url
&
&
url
.
substr
(
0
5
)
=
=
"
data
:
"
;
}
function
splitURLTrue
(
url
)
{
const
reSplitFile
=
/
(
.
*
?
)
:
\
/
{
2
3
}
(
[
^
\
/
]
*
)
(
.
*
?
)
(
[
^
\
/
]
*
?
)
(
|
\
?
.
*
)
/
;
let
m
=
reSplitFile
.
exec
(
url
)
;
if
(
!
m
)
{
return
{
name
:
url
path
:
url
}
;
}
else
if
(
m
[
4
]
=
=
"
"
&
&
m
[
5
]
=
=
"
"
)
{
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
3
]
name
:
m
[
3
]
!
=
"
/
"
?
m
[
3
]
:
m
[
2
]
}
;
}
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
2
]
+
m
[
3
]
name
:
m
[
4
]
+
m
[
5
]
}
;
}
function
wrapRender
(
renderMethod
)
{
const
wrappedFunction
=
function
(
props
)
{
try
{
return
renderMethod
.
call
(
this
props
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
React
.
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
failure
"
title
:
"
This
object
could
not
be
rendered
"
+
"
please
file
a
bug
on
bugzilla
.
mozilla
.
org
"
}
"
Invalid
object
"
)
;
}
}
;
wrappedFunction
.
propTypes
=
renderMethod
.
propTypes
;
return
wrappedFunction
;
}
function
getGripPreviewItems
(
grip
)
{
if
(
!
grip
)
{
return
[
]
;
}
if
(
grip
.
promiseState
&
&
grip
.
promiseState
.
value
)
{
return
[
grip
.
promiseState
.
value
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
items
)
{
return
grip
.
preview
.
items
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
childNodes
)
{
return
grip
.
preview
.
childNodes
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
entries
)
{
return
grip
.
preview
.
entries
.
reduce
(
(
res
entry
)
=
>
res
.
concat
(
entry
)
[
]
)
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
target
)
{
let
keys
=
Object
.
keys
(
grip
.
preview
.
properties
)
;
let
values
=
Object
.
values
(
grip
.
preview
.
properties
)
;
return
[
grip
.
preview
.
target
.
.
.
keys
.
.
.
values
]
;
}
if
(
grip
.
displayString
)
{
return
[
grip
.
displayString
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
ownProperties
)
{
let
propertiesValues
=
Object
.
values
(
grip
.
preview
.
ownProperties
)
.
map
(
property
=
>
property
.
value
|
|
property
)
;
let
propertyKeys
=
Object
.
keys
(
grip
.
preview
.
ownProperties
)
;
propertiesValues
=
propertiesValues
.
concat
(
propertyKeys
)
;
if
(
grip
.
preview
.
safeGetterValues
)
{
propertiesValues
=
propertiesValues
.
concat
(
Object
.
values
(
grip
.
preview
.
safeGetterValues
)
.
map
(
property
=
>
property
.
getterValue
|
|
property
)
)
;
}
return
propertiesValues
;
}
return
[
]
;
}
function
getGripType
(
object
noGrip
)
{
let
type
=
typeof
object
;
if
(
type
=
=
"
object
"
&
&
object
instanceof
String
)
{
type
=
"
string
"
;
}
else
if
(
object
&
&
type
=
=
"
object
"
&
&
object
.
type
&
&
noGrip
!
=
=
true
)
{
type
=
object
.
type
;
}
if
(
isGrip
(
object
)
)
{
type
=
object
.
class
;
}
return
type
;
}
function
containsURL
(
grip
)
{
if
(
typeof
grip
!
=
=
"
string
"
)
{
return
false
;
}
let
tokens
=
grip
.
split
(
tokenSplitRegex
)
;
return
tokens
.
some
(
isURL
)
;
}
function
isURL
(
token
)
{
try
{
if
(
!
validProtocols
.
test
(
token
)
)
{
return
false
;
}
new
URL
(
token
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
module
.
exports
=
{
isGrip
isURL
cropString
containsURL
rawCropString
sanitizeString
escapeString
wrapRender
cropMultipleLines
parseURLParams
parseURLEncodedText
getFileName
getURLDisplayString
maybeEscapePropertyName
getGripPreviewItems
getGripType
tokenSplitRegex
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
module
.
exports
=
{
MODE
:
{
TINY
:
Symbol
(
"
TINY
"
)
SHORT
:
Symbol
(
"
SHORT
"
)
LONG
:
Symbol
(
"
LONG
"
)
}
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
__webpack_require__
(
16
)
;
const
Undefined
=
__webpack_require__
(
17
)
;
const
Null
=
__webpack_require__
(
18
)
;
const
StringRep
=
__webpack_require__
(
5
)
;
const
LongStringRep
=
__webpack_require__
(
19
)
;
const
Number
=
__webpack_require__
(
20
)
;
const
ArrayRep
=
__webpack_require__
(
7
)
;
const
Obj
=
__webpack_require__
(
21
)
;
const
SymbolRep
=
__webpack_require__
(
22
)
;
const
InfinityRep
=
__webpack_require__
(
23
)
;
const
NaNRep
=
__webpack_require__
(
24
)
;
const
Accessor
=
__webpack_require__
(
25
)
;
const
Attribute
=
__webpack_require__
(
26
)
;
const
DateTime
=
__webpack_require__
(
27
)
;
const
Document
=
__webpack_require__
(
28
)
;
const
Event
=
__webpack_require__
(
29
)
;
const
Func
=
__webpack_require__
(
30
)
;
const
PromiseRep
=
__webpack_require__
(
31
)
;
const
RegExp
=
__webpack_require__
(
32
)
;
const
StyleSheet
=
__webpack_require__
(
33
)
;
const
CommentNode
=
__webpack_require__
(
34
)
;
const
ElementNode
=
__webpack_require__
(
35
)
;
const
TextNode
=
__webpack_require__
(
37
)
;
const
ErrorRep
=
__webpack_require__
(
38
)
;
const
Window
=
__webpack_require__
(
39
)
;
const
ObjectWithText
=
__webpack_require__
(
40
)
;
const
ObjectWithURL
=
__webpack_require__
(
41
)
;
const
GripArray
=
__webpack_require__
(
11
)
;
const
GripMap
=
__webpack_require__
(
12
)
;
const
GripMapEntry
=
__webpack_require__
(
13
)
;
const
Grip
=
__webpack_require__
(
6
)
;
let
reps
=
[
RegExp
StyleSheet
Event
DateTime
CommentNode
ElementNode
TextNode
Attribute
LongStringRep
Func
PromiseRep
ArrayRep
Document
Window
ObjectWithText
ObjectWithURL
ErrorRep
GripArray
GripMap
GripMapEntry
Grip
Undefined
Null
StringRep
Number
SymbolRep
InfinityRep
NaNRep
Accessor
]
;
const
Rep
=
function
(
props
)
{
let
{
object
defaultRep
}
=
props
;
let
rep
=
getRep
(
object
defaultRep
props
.
noGrip
)
;
return
rep
(
props
)
;
}
;
function
getRep
(
object
defaultRep
=
Obj
noGrip
=
false
)
{
for
(
let
i
=
0
;
i
<
reps
.
length
;
i
+
+
)
{
let
rep
=
reps
[
i
]
;
try
{
if
(
rep
.
supportsObject
(
object
noGrip
)
)
{
return
rep
.
rep
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
}
return
defaultRep
.
rep
;
}
module
.
exports
=
{
Rep
REPS
:
{
Accessor
ArrayRep
Attribute
CommentNode
DateTime
Document
ElementNode
ErrorRep
Event
Func
Grip
GripArray
GripMap
GripMapEntry
InfinityRep
LongStringRep
NaNRep
Null
Number
Obj
ObjectWithText
ObjectWithURL
PromiseRep
RegExp
Rep
StringRep
StyleSheet
SymbolRep
TextNode
Undefined
Window
}
getRep
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
maybeEscapePropertyName
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
PropRep
.
propTypes
=
{
name
:
React
.
PropTypes
.
oneOfType
(
[
React
.
PropTypes
.
string
React
.
PropTypes
.
object
]
)
.
isRequired
equal
:
React
.
PropTypes
.
string
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
suppressQuotes
:
React
.
PropTypes
.
bool
}
;
function
PropRep
(
props
)
{
const
Grip
=
__webpack_require__
(
6
)
;
const
{
Rep
}
=
__webpack_require__
(
3
)
;
let
{
name
mode
equal
suppressQuotes
}
=
props
;
let
key
;
if
(
typeof
name
=
=
=
"
string
"
)
{
if
(
!
suppressQuotes
)
{
name
=
maybeEscapePropertyName
(
name
)
;
}
key
=
span
(
{
"
className
"
:
"
nodeName
"
}
name
)
;
}
else
{
key
=
Rep
(
Object
.
assign
(
{
}
props
{
className
:
"
nodeName
"
object
:
name
mode
:
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
)
;
}
return
[
key
span
(
{
"
className
"
:
"
objectEqual
"
}
equal
)
Rep
(
Object
.
assign
(
{
}
props
)
)
]
;
}
module
.
exports
=
wrapRender
(
PropRep
)
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
containsURL
isURL
escapeString
getGripType
rawCropString
sanitizeString
wrapRender
tokenSplitRegex
}
=
__webpack_require__
(
1
)
;
const
{
a
span
}
=
React
.
DOM
;
StringRep
.
propTypes
=
{
useQuotes
:
React
.
PropTypes
.
bool
escapeWhitespace
:
React
.
PropTypes
.
bool
style
:
React
.
PropTypes
.
object
object
:
React
.
PropTypes
.
string
.
isRequired
member
:
React
.
PropTypes
.
any
cropLimit
:
React
.
PropTypes
.
number
openLink
:
React
.
PropTypes
.
func
className
:
React
.
PropTypes
.
string
omitLinkHref
:
React
.
PropTypes
.
bool
}
;
function
StringRep
(
props
)
{
let
{
className
cropLimit
object
:
text
member
style
useQuotes
=
true
escapeWhitespace
=
true
openLink
omitLinkHref
=
true
}
=
props
;
const
classNames
=
[
"
objectBox
"
"
objectBox
-
string
"
]
;
if
(
className
)
{
classNames
.
push
(
className
)
;
}
let
config
=
{
className
:
classNames
.
join
(
"
"
)
}
;
if
(
style
)
{
config
.
style
=
style
;
}
if
(
useQuotes
)
{
text
=
escapeString
(
text
escapeWhitespace
)
;
}
else
{
text
=
sanitizeString
(
text
)
;
}
if
(
(
!
member
|
|
!
member
.
open
)
&
&
cropLimit
)
{
text
=
rawCropString
(
text
cropLimit
)
;
}
if
(
!
containsURL
(
text
)
)
{
return
span
(
config
text
)
;
}
const
items
=
[
]
;
let
tokens
=
text
.
split
(
tokenSplitRegex
)
;
let
textIndex
=
0
;
let
tokenStart
;
tokens
.
forEach
(
(
token
i
)
=
>
{
tokenStart
=
text
.
indexOf
(
token
textIndex
)
;
if
(
isURL
(
token
)
)
{
items
.
push
(
text
.
slice
(
textIndex
tokenStart
)
)
;
textIndex
=
tokenStart
+
token
.
length
;
items
.
push
(
a
(
{
className
:
"
url
"
title
:
token
href
:
omitLinkHref
=
=
=
true
?
null
:
token
draggable
:
false
onClick
:
openLink
?
e
=
>
{
e
.
preventDefault
(
)
;
openLink
(
token
)
;
}
:
null
}
token
)
)
;
}
}
)
;
items
.
push
(
text
.
slice
(
textIndex
text
.
length
)
)
;
return
span
(
config
.
.
.
items
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
getGripType
(
object
noGrip
)
=
=
"
string
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
StringRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
GripRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
isInterestingProp
:
React
.
PropTypes
.
func
title
:
React
.
PropTypes
.
string
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
noGrip
:
React
.
PropTypes
.
bool
}
;
const
DEFAULT_TITLE
=
"
Object
"
;
function
GripRep
(
props
)
{
let
{
mode
=
MODE
.
SHORT
object
}
=
props
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
propertiesLength
=
getPropertiesLength
(
object
)
;
const
tinyModeItems
=
[
]
;
if
(
getTitle
(
props
object
)
!
=
=
DEFAULT_TITLE
)
{
tinyModeItems
.
push
(
getTitleElement
(
props
object
)
)
;
}
else
{
tinyModeItems
.
push
(
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
propertiesLength
>
0
?
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
:
null
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
return
span
(
config
.
.
.
tinyModeItems
)
;
}
let
propsArray
=
safePropIterator
(
props
object
maxLengthMap
.
get
(
mode
)
)
;
return
span
(
config
getTitleElement
(
props
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitleElement
(
props
object
)
{
return
span
(
{
className
:
"
objectTitle
"
}
getTitle
(
props
object
)
)
;
}
function
getTitle
(
props
object
)
{
return
props
.
title
|
|
object
.
class
|
|
DEFAULT_TITLE
;
}
function
getPropertiesLength
(
object
)
{
let
propertiesLength
=
object
.
preview
&
&
object
.
preview
.
ownPropertiesLength
?
object
.
preview
.
ownPropertiesLength
:
object
.
ownPropertyLength
;
if
(
object
.
preview
&
&
object
.
preview
.
safeGetterValues
)
{
propertiesLength
+
=
Object
.
keys
(
object
.
preview
.
safeGetterValues
)
.
length
;
}
if
(
object
.
preview
&
&
object
.
preview
.
ownSymbols
)
{
propertiesLength
+
=
object
.
preview
.
ownSymbolsLength
;
}
return
propertiesLength
;
}
function
safePropIterator
(
props
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
maxLengthMap
.
get
(
MODE
.
SHORT
)
:
max
;
try
{
return
propIterator
(
props
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
function
propIterator
(
props
object
max
)
{
if
(
object
.
preview
&
&
Object
.
keys
(
object
.
preview
)
.
includes
(
"
wrappedValue
"
)
)
{
const
{
Rep
}
=
__webpack_require__
(
3
)
;
return
[
Rep
(
{
object
:
object
.
preview
.
wrappedValue
mode
:
props
.
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
]
;
}
let
isInterestingProp
=
props
.
isInterestingProp
|
|
(
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
.
length
!
=
0
;
}
)
;
let
properties
=
object
.
preview
?
object
.
preview
.
ownProperties
:
{
}
;
let
propertiesLength
=
getPropertiesLength
(
object
)
;
if
(
object
.
preview
&
&
object
.
preview
.
safeGetterValues
)
{
properties
=
Object
.
assign
(
{
}
properties
object
.
preview
.
safeGetterValues
)
;
}
let
indexes
=
getPropIndexes
(
properties
max
isInterestingProp
)
;
if
(
indexes
.
length
<
max
&
&
indexes
.
length
<
propertiesLength
)
{
indexes
=
indexes
.
concat
(
getPropIndexes
(
properties
max
-
indexes
.
length
(
t
value
name
)
=
>
{
return
!
isInterestingProp
(
t
value
name
)
;
}
)
)
;
}
const
suppressQuotes
=
object
.
class
=
=
=
"
Proxy
"
;
let
propsArray
=
getProps
(
props
properties
indexes
suppressQuotes
)
;
if
(
object
.
preview
&
&
object
.
preview
.
ownSymbols
)
{
const
{
ownSymbols
}
=
object
.
preview
;
const
length
=
max
-
indexes
.
length
;
const
symbolsProps
=
ownSymbols
.
slice
(
0
length
)
.
map
(
symbolItem
=
>
{
return
PropRep
(
Object
.
assign
(
{
}
props
{
mode
:
MODE
.
TINY
name
:
symbolItem
object
:
symbolItem
.
descriptor
.
value
equal
:
"
:
"
defaultRep
:
Grip
title
:
null
suppressQuotes
}
)
)
;
}
)
;
propsArray
.
push
(
.
.
.
symbolsProps
)
;
}
if
(
Object
.
keys
(
properties
)
.
length
>
max
|
|
propertiesLength
>
max
|
|
propertiesLength
>
propsArray
.
length
)
{
propsArray
.
push
(
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
unfoldProps
(
propsArray
)
;
}
function
unfoldProps
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
Array
.
isArray
(
item
)
)
{
res
=
res
.
concat
(
item
)
;
}
else
{
res
.
push
(
item
)
;
}
if
(
index
!
=
=
items
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
getProps
(
componentProps
properties
indexes
suppressQuotes
)
{
indexes
.
sort
(
function
(
a
b
)
{
return
a
-
b
;
}
)
;
const
propertiesKeys
=
Object
.
keys
(
properties
)
;
return
indexes
.
map
(
i
=
>
{
let
name
=
propertiesKeys
[
i
]
;
let
value
=
getPropValue
(
properties
[
name
]
)
;
return
PropRep
(
Object
.
assign
(
{
}
componentProps
{
mode
:
MODE
.
TINY
name
object
:
value
equal
:
"
:
"
defaultRep
:
Grip
title
:
null
suppressQuotes
}
)
)
;
}
)
;
}
function
getPropIndexes
(
properties
max
filter
)
{
let
indexes
=
[
]
;
try
{
let
i
=
0
;
for
(
let
name
in
properties
)
{
if
(
indexes
.
length
>
=
max
)
{
return
indexes
;
}
let
value
=
getPropValue
(
properties
[
name
]
)
;
let
type
=
value
.
class
|
|
typeof
value
;
type
=
type
.
toLowerCase
(
)
;
if
(
filter
(
type
value
name
)
)
{
indexes
.
push
(
i
)
;
}
i
+
+
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
indexes
;
}
function
getPropValue
(
property
)
{
let
value
=
property
;
if
(
typeof
property
=
=
=
"
object
"
)
{
let
keys
=
Object
.
keys
(
property
)
;
if
(
keys
.
includes
(
"
value
"
)
)
{
value
=
property
.
value
;
}
else
if
(
keys
.
includes
(
"
getterValue
"
)
)
{
value
=
property
.
getterValue
;
}
}
return
value
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
?
typeof
object
.
preview
.
ownProperties
!
=
=
"
undefined
"
:
typeof
object
.
ownPropertyLength
!
=
=
"
undefined
"
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
let
Grip
=
{
rep
:
wrapRender
(
GripRep
)
supportsObject
maxLengthMap
}
;
module
.
exports
=
Grip
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
ModePropType
=
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
;
const
DOM
=
React
.
DOM
;
ArrayRep
.
propTypes
=
{
mode
:
ModePropType
object
:
React
.
PropTypes
.
array
.
isRequired
}
;
function
ArrayRep
(
props
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
props
;
let
items
;
let
brackets
;
let
needSpace
=
function
(
space
)
{
return
space
?
{
left
:
"
[
"
right
:
"
]
"
}
:
{
left
:
"
[
"
right
:
"
]
"
}
;
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
isEmpty
=
object
.
length
=
=
=
0
;
if
(
isEmpty
)
{
items
=
[
]
;
}
else
{
items
=
[
DOM
.
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
]
;
}
brackets
=
needSpace
(
false
)
;
}
else
{
items
=
arrayIterator
(
props
object
maxLengthMap
.
get
(
mode
)
)
;
brackets
=
needSpace
(
items
.
length
>
0
)
;
}
return
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
array
"
}
DOM
.
span
(
{
className
:
"
arrayLeftBracket
"
}
brackets
.
left
)
.
.
.
items
DOM
.
span
(
{
className
:
"
arrayRightBracket
"
}
brackets
.
right
)
DOM
.
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
;
}
function
arrayIterator
(
props
array
max
)
{
let
items
=
[
]
;
for
(
let
i
=
0
;
i
<
array
.
length
&
&
i
<
max
;
i
+
+
)
{
let
config
=
{
mode
:
MODE
.
TINY
delim
:
i
=
=
array
.
length
-
1
?
"
"
:
"
"
}
;
let
item
;
try
{
item
=
ItemRep
(
Object
.
assign
(
{
}
props
config
{
object
:
array
[
i
]
}
)
)
;
}
catch
(
exc
)
{
item
=
ItemRep
(
Object
.
assign
(
{
}
props
config
{
object
:
exc
}
)
)
;
}
items
.
push
(
item
)
;
}
if
(
array
.
length
>
max
)
{
items
.
push
(
DOM
.
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
items
;
}
ItemRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
any
.
isRequired
delim
:
React
.
PropTypes
.
string
.
isRequired
mode
:
ModePropType
}
;
function
ItemRep
(
props
)
{
const
{
Rep
}
=
__webpack_require__
(
3
)
;
let
{
object
delim
mode
}
=
props
;
return
DOM
.
span
(
{
}
Rep
(
Object
.
assign
(
{
}
props
{
object
:
object
mode
:
mode
}
)
)
delim
)
;
}
function
getLength
(
object
)
{
return
object
.
length
;
}
function
supportsObject
(
object
)
{
return
Array
.
isArray
(
object
)
|
|
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Arguments
]
"
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
module
.
exports
=
{
rep
:
wrapRender
(
ArrayRep
)
supportsObject
maxLengthMap
getLength
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
module
.
exports
=
{
ELEMENT_NODE
:
1
ATTRIBUTE_NODE
:
2
TEXT_NODE
:
3
CDATA_SECTION_NODE
:
4
ENTITY_REFERENCE_NODE
:
5
ENTITY_NODE
:
6
PROCESSING_INSTRUCTION_NODE
:
7
COMMENT_NODE
:
8
DOCUMENT_NODE
:
9
DOCUMENT_TYPE_NODE
:
10
DOCUMENT_FRAGMENT_NODE
:
11
NOTATION_NODE
:
12
DOCUMENT_POSITION_DISCONNECTED
:
0x01
DOCUMENT_POSITION_PRECEDING
:
0x02
DOCUMENT_POSITION_FOLLOWING
:
0x04
DOCUMENT_POSITION_CONTAINS
:
0x08
DOCUMENT_POSITION_CONTAINED_BY
:
0x10
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
:
0x20
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
InlineSVG
=
__webpack_require__
(
10
)
;
const
svg
=
{
"
open
-
inspector
"
:
__webpack_require__
(
36
)
}
;
Svg
.
propTypes
=
{
className
:
React
.
PropTypes
.
string
}
;
function
Svg
(
name
props
)
{
if
(
!
svg
[
name
]
)
{
throw
new
Error
(
"
Unknown
SVG
:
"
+
name
)
;
}
let
className
=
name
;
if
(
props
&
&
props
.
className
)
{
className
=
{
name
}
{
props
.
className
}
;
}
if
(
name
=
=
=
"
subSettings
"
)
{
className
=
"
"
;
}
props
=
Object
.
assign
(
{
}
props
{
className
src
:
svg
[
name
]
}
)
;
return
React
.
createElement
(
InlineSVG
props
)
;
}
module
.
exports
=
Svg
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_createClass
=
(
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
'
value
'
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
)
(
)
;
var
_get
=
function
get
(
_x
_x2
_x3
)
{
var
_again
=
true
;
_function
:
while
(
_again
)
{
var
object
=
_x
property
=
_x2
receiver
=
_x3
;
_again
=
false
;
if
(
object
=
=
=
null
)
object
=
Function
.
prototype
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
object
property
)
;
if
(
desc
=
=
=
undefined
)
{
var
parent
=
Object
.
getPrototypeOf
(
object
)
;
if
(
parent
=
=
=
null
)
{
return
undefined
;
}
else
{
_x
=
parent
;
_x2
=
property
;
_x3
=
receiver
;
_again
=
true
;
desc
=
parent
=
undefined
;
continue
_function
;
}
}
else
if
(
'
value
'
in
desc
)
{
return
desc
.
value
;
}
else
{
var
getter
=
desc
.
get
;
if
(
getter
=
=
=
undefined
)
{
return
undefined
;
}
return
getter
.
call
(
receiver
)
;
}
}
}
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
function
_objectWithoutProperties
(
obj
keys
)
{
var
target
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
keys
.
indexOf
(
i
)
>
=
0
)
continue
;
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
continue
;
target
[
i
]
=
obj
[
i
]
;
}
return
target
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
'
Cannot
call
a
class
as
a
function
'
)
;
}
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
'
function
'
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
'
Super
expression
must
either
be
null
or
a
function
not
'
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
_react
=
__webpack_require__
(
0
)
;
var
_react2
=
_interopRequireDefault
(
_react
)
;
var
DOMParser
=
typeof
window
!
=
=
'
undefined
'
&
&
window
.
DOMParser
;
var
process
=
process
|
|
{
}
;
process
.
env
=
process
.
env
|
|
{
}
;
var
parserAvailable
=
typeof
DOMParser
!
=
=
'
undefined
'
&
&
DOMParser
.
prototype
!
=
null
&
&
DOMParser
.
prototype
.
parseFromString
!
=
null
;
function
isParsable
(
src
)
{
return
parserAvailable
&
&
typeof
src
=
=
=
'
string
'
&
&
src
.
trim
(
)
.
substr
(
0
4
)
=
=
=
'
<
svg
'
;
}
function
parseFromSVGString
(
src
)
{
var
parser
=
new
DOMParser
(
)
;
return
parser
.
parseFromString
(
src
"
image
/
svg
+
xml
"
)
;
}
function
switchSVGAttrToReactProp
(
propName
)
{
switch
(
propName
)
{
case
'
class
'
:
return
'
className
'
;
default
:
return
propName
;
}
}
var
InlineSVG
=
(
function
(
_React
Component
)
{
_inherits
(
InlineSVG
_React
Component
)
;
_createClass
(
InlineSVG
null
[
{
key
:
'
defaultProps
'
value
:
{
element
:
'
i
'
raw
:
false
src
:
'
'
}
enumerable
:
true
}
{
key
:
'
propTypes
'
value
:
{
src
:
_react2
[
'
default
'
]
.
PropTypes
.
string
.
isRequired
element
:
_react2
[
'
default
'
]
.
PropTypes
.
string
raw
:
_react2
[
'
default
'
]
.
PropTypes
.
bool
}
enumerable
:
true
}
]
)
;
function
InlineSVG
(
props
)
{
_classCallCheck
(
this
InlineSVG
)
;
_get
(
Object
.
getPrototypeOf
(
InlineSVG
.
prototype
)
'
constructor
'
this
)
.
call
(
this
props
)
;
this
.
_extractSVGProps
=
this
.
_extractSVGProps
.
bind
(
this
)
;
}
_createClass
(
InlineSVG
[
{
key
:
'
_serializeAttrs
'
value
:
function
_serializeAttrs
(
map
)
{
var
ret
=
{
}
;
var
prop
=
undefined
;
for
(
var
i
=
0
;
i
<
map
.
length
;
i
+
+
)
{
prop
=
switchSVGAttrToReactProp
(
map
[
i
]
.
name
)
;
ret
[
prop
]
=
map
[
i
]
.
value
;
}
return
ret
;
}
}
{
key
:
'
_extractSVGProps
'
value
:
function
_extractSVGProps
(
src
)
{
var
map
=
parseFromSVGString
(
src
)
.
documentElement
.
attributes
;
return
map
.
length
>
0
?
this
.
_serializeAttrs
(
map
)
:
null
;
}
}
{
key
:
'
_stripSVG
'
value
:
function
_stripSVG
(
src
)
{
return
parseFromSVGString
(
src
)
.
documentElement
.
innerHTML
;
}
}
{
key
:
'
componentWillReceiveProps
'
value
:
function
componentWillReceiveProps
(
_ref
)
{
var
children
=
_ref
.
children
;
if
(
"
production
"
!
=
=
process
.
env
.
NODE_ENV
&
&
children
!
=
null
)
{
console
.
info
(
'
<
InlineSVG
/
>
:
children
prop
will
be
ignored
.
'
)
;
}
}
}
{
key
:
'
render
'
value
:
function
render
(
)
{
var
Element
=
undefined
__html
=
undefined
svgProps
=
undefined
;
var
_props
=
this
.
props
;
var
element
=
_props
.
element
;
var
raw
=
_props
.
raw
;
var
src
=
_props
.
src
;
var
otherProps
=
_objectWithoutProperties
(
_props
[
'
element
'
'
raw
'
'
src
'
]
)
;
if
(
raw
=
=
=
true
&
&
isParsable
(
src
)
)
{
Element
=
'
svg
'
;
svgProps
=
this
.
_extractSVGProps
(
src
)
;
__html
=
this
.
_stripSVG
(
src
)
;
}
__html
=
__html
|
|
src
;
Element
=
Element
|
|
element
;
svgProps
=
svgProps
|
|
{
}
;
return
_react2
[
'
default
'
]
.
createElement
(
Element
_extends
(
{
}
svgProps
otherProps
{
src
:
null
children
:
null
dangerouslySetInnerHTML
:
{
__html
:
__html
}
}
)
)
;
}
}
]
)
;
return
InlineSVG
;
}
)
(
_react2
[
'
default
'
]
.
Component
)
;
exports
[
'
default
'
]
=
InlineSVG
;
module
.
exports
=
exports
[
'
default
'
]
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
GripArray
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
provider
:
React
.
PropTypes
.
object
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
GripArray
(
props
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
props
;
let
items
;
let
brackets
;
let
needSpace
=
function
(
space
)
{
return
space
?
{
left
:
"
[
"
right
:
"
]
"
}
:
{
left
:
"
[
"
right
:
"
]
"
}
;
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
objectLength
=
getLength
(
object
)
;
let
isEmpty
=
objectLength
=
=
=
0
;
if
(
isEmpty
)
{
items
=
[
]
;
}
else
{
items
=
[
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
]
;
}
brackets
=
needSpace
(
false
)
;
}
else
{
let
max
=
maxLengthMap
.
get
(
mode
)
;
items
=
arrayIterator
(
props
object
max
)
;
brackets
=
needSpace
(
items
.
length
>
0
)
;
}
let
title
=
getTitle
(
props
object
)
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
array
"
}
title
span
(
{
className
:
"
arrayLeftBracket
"
}
brackets
.
left
)
.
.
.
interleaveCommas
(
items
)
span
(
{
className
:
"
arrayRightBracket
"
}
brackets
.
right
)
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
;
}
function
interleaveCommas
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
index
!
=
=
items
.
length
-
1
)
{
return
res
.
concat
(
item
"
"
)
;
}
return
res
.
concat
(
item
)
;
}
[
]
)
;
}
function
getLength
(
grip
)
{
if
(
!
grip
.
preview
)
{
return
0
;
}
return
grip
.
preview
.
length
|
|
grip
.
preview
.
childNodesLength
|
|
0
;
}
function
getTitle
(
props
object
)
{
if
(
props
.
mode
=
=
=
MODE
.
TINY
)
{
return
"
"
;
}
let
title
=
props
.
title
|
|
object
.
class
|
|
"
Array
"
;
return
span
(
{
className
:
"
objectTitle
"
}
title
+
"
"
)
;
}
function
getPreviewItems
(
grip
)
{
if
(
!
grip
.
preview
)
{
return
null
;
}
return
grip
.
preview
.
items
|
|
grip
.
preview
.
childNodes
|
|
[
]
;
}
function
arrayIterator
(
props
grip
max
)
{
let
{
Rep
}
=
__webpack_require__
(
3
)
;
let
items
=
[
]
;
const
gripLength
=
getLength
(
grip
)
;
if
(
!
gripLength
)
{
return
items
;
}
const
previewItems
=
getPreviewItems
(
grip
)
;
let
provider
=
props
.
provider
;
let
emptySlots
=
0
;
let
foldedEmptySlots
=
0
;
items
=
previewItems
.
reduce
(
(
res
itemGrip
)
=
>
{
if
(
res
.
length
>
=
max
)
{
return
res
;
}
let
object
;
try
{
if
(
!
provider
&
&
itemGrip
=
=
=
null
)
{
emptySlots
+
+
;
return
res
;
}
object
=
provider
?
provider
.
getValue
(
itemGrip
)
:
itemGrip
;
}
catch
(
exc
)
{
object
=
exc
;
}
if
(
emptySlots
>
0
)
{
res
.
push
(
getEmptySlotsElement
(
emptySlots
)
)
;
foldedEmptySlots
=
foldedEmptySlots
+
emptySlots
-
1
;
emptySlots
=
0
;
}
if
(
res
.
length
<
max
)
{
res
.
push
(
Rep
(
Object
.
assign
(
{
}
props
{
object
mode
:
MODE
.
TINY
title
:
undefined
}
)
)
)
;
}
return
res
;
}
[
]
)
;
if
(
items
.
length
<
max
&
&
emptySlots
>
0
)
{
items
.
push
(
getEmptySlotsElement
(
emptySlots
)
)
;
foldedEmptySlots
=
foldedEmptySlots
+
emptySlots
-
1
;
}
const
itemsShown
=
items
.
length
+
foldedEmptySlots
;
if
(
gripLength
>
itemsShown
)
{
items
.
push
(
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
items
;
}
function
getEmptySlotsElement
(
number
)
{
return
<
{
number
}
empty
slot
{
number
>
1
?
"
s
"
:
"
"
}
>
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
(
grip
.
preview
.
kind
=
=
"
ArrayLike
"
|
|
getGripType
(
grip
noGrip
)
=
=
=
"
DocumentFragment
"
)
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
module
.
exports
=
{
rep
:
wrapRender
(
GripArray
)
supportsObject
maxLengthMap
getLength
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
GripMap
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
isInterestingEntry
:
React
.
PropTypes
.
func
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
title
:
React
.
PropTypes
.
string
}
;
function
GripMap
(
props
)
{
let
{
mode
object
}
=
props
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
span
(
config
getTitle
(
props
object
)
)
;
}
let
propsArray
=
safeEntriesIterator
(
props
object
maxLengthMap
.
get
(
mode
)
)
;
return
span
(
config
getTitle
(
props
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitle
(
props
object
)
{
let
title
=
props
.
title
|
|
(
object
&
&
object
.
class
?
object
.
class
:
"
Map
"
)
;
return
span
(
{
className
:
"
objectTitle
"
}
title
)
;
}
function
safeEntriesIterator
(
props
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
3
:
max
;
try
{
return
entriesIterator
(
props
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
function
entriesIterator
(
props
object
max
)
{
let
isInterestingEntry
=
props
.
isInterestingEntry
|
|
(
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
.
length
!
=
0
;
}
)
;
let
mapEntries
=
object
.
preview
&
&
object
.
preview
.
entries
?
object
.
preview
.
entries
:
[
]
;
let
indexes
=
getEntriesIndexes
(
mapEntries
max
isInterestingEntry
)
;
if
(
indexes
.
length
<
max
&
&
indexes
.
length
<
mapEntries
.
length
)
{
indexes
=
indexes
.
concat
(
getEntriesIndexes
(
mapEntries
max
-
indexes
.
length
(
t
value
name
)
=
>
{
return
!
isInterestingEntry
(
t
value
name
)
;
}
)
)
;
}
let
entries
=
getEntries
(
props
mapEntries
indexes
)
;
if
(
entries
.
length
<
getLength
(
object
)
)
{
entries
.
push
(
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
unfoldEntries
(
entries
)
;
}
function
unfoldEntries
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
Array
.
isArray
(
item
)
)
{
res
=
res
.
concat
(
item
)
;
}
else
{
res
.
push
(
item
)
;
}
if
(
index
!
=
=
items
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
getEntries
(
props
entries
indexes
)
{
let
{
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
props
;
indexes
.
sort
(
function
(
a
b
)
{
return
a
-
b
;
}
)
;
return
indexes
.
map
(
(
index
i
)
=
>
{
let
[
key
entryValue
]
=
entries
[
index
]
;
let
value
=
entryValue
.
value
!
=
=
undefined
?
entryValue
.
value
:
entryValue
;
return
PropRep
(
{
name
:
key
equal
:
"
\
u2192
"
object
:
value
mode
:
MODE
.
TINY
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
)
;
}
)
;
}
function
getEntriesIndexes
(
entries
max
filter
)
{
return
entries
.
reduce
(
(
indexes
[
key
entry
]
i
)
=
>
{
if
(
indexes
.
length
<
max
)
{
let
value
=
entry
&
&
entry
.
value
!
=
=
undefined
?
entry
.
value
:
entry
;
let
type
=
(
value
&
&
value
.
class
?
value
.
class
:
typeof
value
)
.
toLowerCase
(
)
;
if
(
filter
(
type
value
key
)
)
{
indexes
.
push
(
i
)
;
}
}
return
indexes
;
}
[
]
)
;
}
function
getLength
(
grip
)
{
return
grip
.
preview
.
size
|
|
0
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
MapLike
"
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
module
.
exports
=
{
rep
:
wrapRender
(
GripMap
)
supportsObject
maxLengthMap
getLength
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
span
}
=
React
.
DOM
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
GripMapEntry
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
GripMapEntry
(
props
)
{
const
{
object
}
=
props
;
const
{
key
value
}
=
object
.
preview
;
return
span
(
{
className
:
"
objectBox
objectBox
-
map
-
entry
"
}
.
.
.
PropRep
(
Object
.
assign
(
{
}
props
{
name
:
key
object
:
value
equal
:
"
\
u2192
"
title
:
null
suppressQuotes
:
false
}
)
)
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
)
{
return
false
;
}
return
grip
&
&
grip
.
type
=
=
=
"
mapEntry
"
&
&
grip
.
preview
;
}
function
createGripMapEntry
(
key
value
)
{
return
{
type
:
"
mapEntry
"
preview
:
{
key
value
}
}
;
}
module
.
exports
=
{
rep
:
wrapRender
(
GripMapEntry
)
createGripMapEntry
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
get
has
}
=
__webpack_require__
(
49
)
;
const
{
maybeEscapePropertyName
}
=
__webpack_require__
(
1
)
;
const
ArrayRep
=
__webpack_require__
(
7
)
;
const
GripArrayRep
=
__webpack_require__
(
11
)
;
const
GripMap
=
__webpack_require__
(
12
)
;
const
GripMapEntryRep
=
__webpack_require__
(
13
)
;
const
MAX_NUMERICAL_PROPERTIES
=
100
;
const
NODE_TYPES
=
{
BUCKET
:
Symbol
(
"
[
n
n
]
"
)
DEFAULT_PROPERTIES
:
Symbol
(
"
[
default
properties
]
"
)
ENTRIES
:
Symbol
(
"
<
entries
>
"
)
GET
:
Symbol
(
"
<
get
>
"
)
GRIP
:
Symbol
(
"
GRIP
"
)
MAP_ENTRY_KEY
:
Symbol
(
"
<
key
>
"
)
MAP_ENTRY_VALUE
:
Symbol
(
"
<
value
>
"
)
PROMISE_REASON
:
Symbol
(
"
<
reason
>
"
)
PROMISE_STATE
:
Symbol
(
"
<
state
>
"
)
PROMISE_VALUE
:
Symbol
(
"
<
value
>
"
)
PROXY_HANDLER
:
Symbol
(
"
<
handler
>
"
)
PROXY_TARGET
:
Symbol
(
"
<
target
>
"
)
SET
:
Symbol
(
"
<
set
>
"
)
PROTOTYPE
:
Symbol
(
"
__proto__
"
)
}
;
let
WINDOW_PROPERTIES
=
{
}
;
if
(
typeof
window
=
=
=
"
object
"
)
{
WINDOW_PROPERTIES
=
Object
.
getOwnPropertyNames
(
window
)
;
}
const
SAFE_PATH_PREFIX
=
"
#
#
-
"
;
function
getType
(
item
)
{
return
item
.
type
;
}
function
getValue
(
item
)
{
if
(
has
(
item
"
contents
.
value
"
)
)
{
return
get
(
item
"
contents
.
value
"
)
;
}
if
(
has
(
item
"
contents
.
getterValue
"
)
)
{
return
get
(
item
"
contents
.
getterValue
"
undefined
)
;
}
if
(
nodeHasAccessors
(
item
)
)
{
return
item
.
contents
;
}
return
undefined
;
}
function
nodeIsBucket
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
BUCKET
;
}
function
nodeIsEntries
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
ENTRIES
;
}
function
nodeIsMapEntry
(
item
)
{
return
GripMapEntryRep
.
supportsObject
(
getValue
(
item
)
)
;
}
function
nodeHasChildren
(
item
)
{
return
Array
.
isArray
(
item
.
contents
)
;
}
function
nodeIsObject
(
item
)
{
const
value
=
getValue
(
item
)
;
return
value
&
&
value
.
type
=
=
=
"
object
"
;
}
function
nodeIsArrayLike
(
item
)
{
const
value
=
getValue
(
item
)
;
return
GripArrayRep
.
supportsObject
(
value
)
|
|
ArrayRep
.
supportsObject
(
value
)
;
}
function
nodeIsFunction
(
item
)
{
const
value
=
getValue
(
item
)
;
return
value
&
&
value
.
class
=
=
=
"
Function
"
;
}
function
nodeIsOptimizedOut
(
item
)
{
const
value
=
getValue
(
item
)
;
return
!
nodeHasChildren
(
item
)
&
&
value
&
&
value
.
optimizedOut
;
}
function
nodeIsMissingArguments
(
item
)
{
const
value
=
getValue
(
item
)
;
return
!
nodeHasChildren
(
item
)
&
&
value
&
&
value
.
missingArguments
;
}
function
nodeHasProperties
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
nodeIsObject
(
item
)
;
}
function
nodeIsPrimitive
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
!
nodeHasProperties
(
item
)
&
&
!
nodeIsEntries
(
item
)
&
&
!
nodeIsMapEntry
(
item
)
&
&
!
nodeHasAccessors
(
item
)
&
&
!
nodeIsBucket
(
item
)
;
}
function
nodeIsDefaultProperties
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
DEFAULT_PROPERTIES
;
}
function
isDefaultWindowProperty
(
name
)
{
return
WINDOW_PROPERTIES
.
includes
(
name
)
;
}
function
nodeIsPromise
(
item
)
{
const
value
=
getValue
(
item
)
;
if
(
!
value
)
{
return
false
;
}
return
value
.
class
=
=
"
Promise
"
;
}
function
nodeIsProxy
(
item
)
{
const
value
=
getValue
(
item
)
;
if
(
!
value
)
{
return
false
;
}
return
value
.
class
=
=
"
Proxy
"
;
}
function
nodeIsPrototype
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
PROTOTYPE
;
}
function
nodeIsWindow
(
item
)
{
const
value
=
getValue
(
item
)
;
if
(
!
value
)
{
return
false
;
}
return
value
.
class
=
=
"
Window
"
;
}
function
nodeIsGetter
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
GET
;
}
function
nodeIsSetter
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
SET
;
}
function
nodeHasAccessors
(
item
)
{
return
!
!
getNodeGetter
(
item
)
|
|
!
!
getNodeSetter
(
item
)
;
}
function
nodeSupportsNumericalBucketing
(
item
)
{
return
nodeIsArrayLike
(
item
)
&
&
!
nodeHasEntries
(
item
)
|
|
nodeIsEntries
(
item
)
|
|
nodeIsBucket
(
item
)
;
}
function
nodeHasEntries
(
item
)
{
const
value
=
getValue
(
item
)
;
if
(
!
value
)
{
return
false
;
}
return
value
.
class
=
=
=
"
Map
"
|
|
value
.
class
=
=
=
"
Set
"
|
|
value
.
class
=
=
=
"
WeakMap
"
|
|
value
.
class
=
=
=
"
WeakSet
"
;
}
function
nodeHasAllEntriesInPreview
(
item
)
{
const
{
preview
}
=
getValue
(
item
)
|
|
{
}
;
if
(
!
preview
)
{
return
false
;
}
const
{
entries
items
length
size
}
=
preview
;
if
(
!
entries
&
&
!
items
)
{
return
false
;
}
return
entries
?
entries
.
length
=
=
=
size
:
items
.
length
=
=
=
length
;
}
function
nodeNeedsNumericalBuckets
(
item
)
{
return
nodeSupportsNumericalBucketing
(
item
)
&
&
getNumericalPropertiesCount
(
item
)
>
MAX_NUMERICAL_PROPERTIES
;
}
function
makeNodesForPromiseProperties
(
item
)
{
const
{
promiseState
:
{
reason
value
state
}
}
=
getValue
(
item
)
;
const
properties
=
[
]
;
if
(
state
)
{
properties
.
push
(
createNode
(
item
"
<
state
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
state
{
value
:
state
}
NODE_TYPES
.
PROMISE_STATE
)
)
;
}
if
(
reason
)
{
properties
.
push
(
createNode
(
item
"
<
reason
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
reason
{
value
:
reason
}
NODE_TYPES
.
PROMISE_REASON
)
)
;
}
if
(
value
)
{
properties
.
push
(
createNode
(
item
"
<
value
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
value
{
value
:
value
}
NODE_TYPES
.
PROMISE_VALUE
)
)
;
}
return
properties
;
}
function
makeNodesForProxyProperties
(
item
)
{
const
{
proxyHandler
proxyTarget
}
=
getValue
(
item
)
;
return
[
createNode
(
item
"
<
target
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
target
{
value
:
proxyTarget
}
NODE_TYPES
.
PROXY_TARGET
)
createNode
(
item
"
<
handler
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
handler
{
value
:
proxyHandler
}
NODE_TYPES
.
PROXY_HANDLER
)
]
;
}
function
makeNodesForEntries
(
item
)
{
const
{
path
}
=
item
;
const
nodeName
=
"
<
entries
>
"
;
const
entriesPath
=
{
path
}
/
{
SAFE_PATH_PREFIX
}
entries
;
if
(
nodeHasAllEntriesInPreview
(
item
)
)
{
let
entriesNodes
=
[
]
;
const
{
preview
}
=
getValue
(
item
)
;
if
(
preview
.
entries
)
{
entriesNodes
=
preview
.
entries
.
map
(
(
[
key
value
]
index
)
=
>
{
return
createNode
(
item
index
{
entriesPath
}
/
{
index
}
{
value
:
GripMapEntryRep
.
createGripMapEntry
(
key
value
)
}
)
;
}
)
;
}
else
if
(
preview
.
items
)
{
entriesNodes
=
preview
.
items
.
map
(
(
value
index
)
=
>
{
return
createNode
(
item
index
{
entriesPath
}
/
{
index
}
{
value
}
)
;
}
)
;
}
return
createNode
(
item
nodeName
entriesPath
entriesNodes
NODE_TYPES
.
ENTRIES
)
;
}
return
createNode
(
item
nodeName
entriesPath
null
NODE_TYPES
.
ENTRIES
)
;
}
function
makeNodesForMapEntry
(
item
)
{
const
nodeValue
=
getValue
(
item
)
;
if
(
!
nodeValue
|
|
!
nodeValue
.
preview
)
{
return
[
]
;
}
const
{
key
value
}
=
nodeValue
.
preview
;
const
path
=
item
.
path
;
return
[
createNode
(
item
"
<
key
>
"
{
path
}
/
#
#
key
{
value
:
key
}
NODE_TYPES
.
MAP_ENTRY_KEY
)
createNode
(
item
"
<
value
>
"
{
path
}
/
#
#
value
{
value
}
NODE_TYPES
.
MAP_ENTRY_VALUE
)
]
;
}
function
getNodeGetter
(
item
)
{
return
get
(
item
"
contents
.
get
"
undefined
)
;
}
function
getNodeSetter
(
item
)
{
return
get
(
item
"
contents
.
set
"
undefined
)
;
}
function
makeNodesForAccessors
(
item
)
{
const
accessors
=
[
]
;
const
getter
=
getNodeGetter
(
item
)
;
if
(
getter
&
&
getter
.
type
!
=
=
"
undefined
"
)
{
accessors
.
push
(
createNode
(
item
"
<
get
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
get
{
value
:
getter
}
NODE_TYPES
.
GET
)
)
;
}
const
setter
=
getNodeSetter
(
item
)
;
if
(
setter
&
&
setter
.
type
!
=
=
"
undefined
"
)
{
accessors
.
push
(
createNode
(
item
"
<
set
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
set
{
value
:
setter
}
NODE_TYPES
.
SET
)
)
;
}
return
accessors
;
}
function
sortProperties
(
properties
)
{
return
properties
.
sort
(
(
a
b
)
=
>
{
const
aInt
=
parseInt
(
a
10
)
;
const
bInt
=
parseInt
(
b
10
)
;
if
(
isNaN
(
aInt
)
|
|
isNaN
(
bInt
)
)
{
return
a
>
b
?
1
:
-
1
;
}
return
aInt
-
bInt
;
}
)
;
}
function
makeNumericalBuckets
(
parent
)
{
const
parentPath
=
parent
.
path
;
const
numProperties
=
getNumericalPropertiesCount
(
parent
)
;
const
bucketSize
=
10
*
*
Math
.
max
(
2
Math
.
ceil
(
Math
.
log10
(
numProperties
)
)
-
2
)
;
const
numBuckets
=
Math
.
ceil
(
numProperties
/
bucketSize
)
;
let
buckets
=
[
]
;
for
(
let
i
=
1
;
i
<
=
numBuckets
;
i
+
+
)
{
const
minKey
=
(
i
-
1
)
*
bucketSize
;
const
maxKey
=
Math
.
min
(
i
*
bucketSize
-
1
numProperties
-
1
)
;
const
startIndex
=
nodeIsBucket
(
parent
)
?
parent
.
meta
.
startIndex
:
0
;
const
minIndex
=
startIndex
+
minKey
;
const
maxIndex
=
startIndex
+
maxKey
;
const
bucketKey
=
{
SAFE_PATH_PREFIX
}
bucket_
{
minIndex
}
-
{
maxIndex
}
;
const
bucketName
=
[
{
minIndex
}
{
maxIndex
}
]
;
buckets
.
push
(
createNode
(
parent
bucketName
{
parentPath
}
/
{
bucketKey
}
null
NODE_TYPES
.
BUCKET
{
startIndex
:
minIndex
endIndex
:
maxIndex
}
)
)
;
}
return
buckets
;
}
function
makeDefaultPropsBucket
(
propertiesNames
parent
ownProperties
)
{
const
parentPath
=
parent
.
path
;
const
userPropertiesNames
=
[
]
;
const
defaultProperties
=
[
]
;
propertiesNames
.
forEach
(
name
=
>
{
if
(
isDefaultWindowProperty
(
name
)
)
{
defaultProperties
.
push
(
name
)
;
}
else
{
userPropertiesNames
.
push
(
name
)
;
}
}
)
;
let
nodes
=
makeNodesForOwnProps
(
userPropertiesNames
parent
ownProperties
)
;
if
(
defaultProperties
.
length
>
0
)
{
const
defaultPropertiesNode
=
createNode
(
parent
"
[
default
properties
]
"
{
parentPath
}
/
{
SAFE_PATH_PREFIX
}
default
null
NODE_TYPES
.
DEFAULT_PROPERTIES
)
;
const
defaultNodes
=
defaultProperties
.
map
(
(
name
index
)
=
>
createNode
(
defaultPropertiesNode
maybeEscapePropertyName
(
name
)
{
parentPath
}
/
{
SAFE_PATH_PREFIX
}
bucket
{
index
}
/
{
name
}
ownProperties
[
name
]
)
)
;
nodes
.
push
(
setNodeChildren
(
defaultPropertiesNode
defaultNodes
)
)
;
}
return
nodes
;
}
function
makeNodesForOwnProps
(
propertiesNames
parent
ownProperties
)
{
const
parentPath
=
parent
.
path
;
return
propertiesNames
.
map
(
name
=
>
createNode
(
parent
maybeEscapePropertyName
(
name
)
{
parentPath
}
/
{
name
}
ownProperties
[
name
]
)
)
;
}
function
makeNodesForProperties
(
objProps
parent
)
{
const
{
ownProperties
=
{
}
ownSymbols
prototype
safeGetterValues
}
=
objProps
;
const
parentPath
=
parent
.
path
;
const
parentValue
=
getValue
(
parent
)
;
let
allProperties
=
Object
.
assign
(
{
}
ownProperties
safeGetterValues
)
;
const
propertiesNames
=
sortProperties
(
Object
.
keys
(
allProperties
)
)
.
filter
(
name
=
>
{
if
(
!
allProperties
[
name
]
)
{
return
false
;
}
const
properties
=
Object
.
getOwnPropertyNames
(
allProperties
[
name
]
)
;
return
properties
.
some
(
property
=
>
[
"
value
"
"
getterValue
"
"
get
"
"
set
"
]
.
includes
(
property
)
)
;
}
)
;
let
nodes
=
[
]
;
if
(
parentValue
&
&
parentValue
.
class
=
=
"
Window
"
)
{
nodes
=
makeDefaultPropsBucket
(
propertiesNames
parent
allProperties
)
;
}
else
{
nodes
=
makeNodesForOwnProps
(
propertiesNames
parent
allProperties
)
;
}
if
(
Array
.
isArray
(
ownSymbols
)
)
{
ownSymbols
.
forEach
(
(
ownSymbol
index
)
=
>
{
nodes
.
push
(
createNode
(
parent
ownSymbol
.
name
{
parentPath
}
/
{
SAFE_PATH_PREFIX
}
symbol
-
{
index
}
ownSymbol
.
descriptor
|
|
null
)
)
;
}
this
)
;
}
if
(
nodeIsPromise
(
parent
)
)
{
nodes
.
push
(
.
.
.
makeNodesForPromiseProperties
(
parent
)
)
;
}
if
(
nodeHasEntries
(
parent
)
)
{
nodes
.
push
(
makeNodesForEntries
(
parent
)
)
;
}
if
(
prototype
&
&
prototype
.
type
!
=
=
"
null
"
)
{
nodes
.
push
(
makeNodeForPrototype
(
objProps
parent
)
)
;
}
return
nodes
;
}
function
makeNodeForPrototype
(
objProps
parent
)
{
const
{
prototype
}
=
objProps
|
|
{
}
;
if
(
prototype
&
&
prototype
.
type
!
=
=
"
null
"
)
{
return
createNode
(
parent
"
__proto__
"
{
parent
.
path
}
/
__proto__
{
value
:
prototype
}
NODE_TYPES
.
PROTOTYPE
)
;
}
return
null
;
}
function
createNode
(
parent
name
path
contents
type
=
NODE_TYPES
.
GRIP
meta
)
{
if
(
contents
=
=
=
undefined
)
{
return
null
;
}
return
{
parent
name
path
contents
type
meta
}
;
}
function
setNodeChildren
(
node
children
)
{
node
.
contents
=
children
;
return
node
;
}
function
getChildren
(
options
)
{
const
{
cachedNodes
loadedProperties
=
new
Map
(
)
item
}
=
options
;
const
key
=
item
.
path
;
if
(
cachedNodes
&
&
cachedNodes
.
has
(
key
)
)
{
return
cachedNodes
.
get
(
key
)
;
}
const
loadedProps
=
loadedProperties
.
get
(
key
)
;
const
{
ownProperties
ownSymbols
safeGetterValues
prototype
}
=
loadedProps
|
|
{
}
;
const
hasLoadedProps
=
ownProperties
|
|
ownSymbols
|
|
safeGetterValues
|
|
prototype
;
const
addToCache
=
children
=
>
{
if
(
cachedNodes
)
{
cachedNodes
.
set
(
item
.
path
children
)
;
}
return
children
;
}
;
if
(
nodeHasChildren
(
item
)
)
{
return
addToCache
(
item
.
contents
)
;
}
if
(
nodeHasAccessors
(
item
)
)
{
return
addToCache
(
makeNodesForAccessors
(
item
)
)
;
}
if
(
nodeIsMapEntry
(
item
)
)
{
return
addToCache
(
makeNodesForMapEntry
(
item
)
)
;
}
if
(
nodeIsProxy
(
item
)
)
{
const
nodes
=
makeNodesForProxyProperties
(
item
)
;
const
protoNode
=
makeNodeForPrototype
(
loadedProps
item
)
;
if
(
protoNode
)
{
return
addToCache
(
nodes
.
concat
(
protoNode
)
)
;
}
return
nodes
;
}
if
(
nodeNeedsNumericalBuckets
(
item
)
)
{
const
bucketNodes
=
makeNumericalBuckets
(
item
)
;
if
(
hasLoadedProps
)
{
return
addToCache
(
bucketNodes
.
concat
(
makeNodesForProperties
(
loadedProps
item
)
)
)
;
}
return
bucketNodes
;
}
if
(
!
nodeIsEntries
(
item
)
&
&
!
nodeIsBucket
(
item
)
&
&
!
nodeHasProperties
(
item
)
)
{
return
[
]
;
}
if
(
!
hasLoadedProps
)
{
return
[
]
;
}
return
addToCache
(
makeNodesForProperties
(
loadedProps
item
)
)
;
}
function
getParent
(
item
)
{
return
item
.
parent
;
}
function
getNumericalPropertiesCount
(
item
)
{
if
(
nodeIsBucket
(
item
)
)
{
return
item
.
meta
.
endIndex
-
item
.
meta
.
startIndex
+
1
;
}
const
value
=
getValue
(
getClosestGripNode
(
item
)
)
;
if
(
!
value
)
{
return
0
;
}
if
(
GripArrayRep
.
supportsObject
(
value
)
)
{
return
GripArrayRep
.
getLength
(
value
)
;
}
if
(
GripMap
.
supportsObject
(
value
)
)
{
return
GripMap
.
getLength
(
value
)
;
}
return
0
;
}
function
getClosestGripNode
(
item
)
{
const
type
=
getType
(
item
)
;
if
(
type
!
=
=
NODE_TYPES
.
BUCKET
&
&
type
!
=
=
NODE_TYPES
.
DEFAULT_PROPERTIES
&
&
type
!
=
=
NODE_TYPES
.
ENTRIES
)
{
return
item
;
}
const
parent
=
getParent
(
item
)
;
if
(
!
parent
)
{
return
null
;
}
return
getClosestGripNode
(
parent
)
;
}
function
getClosestNonBucketNode
(
item
)
{
const
type
=
getType
(
item
)
;
if
(
type
!
=
=
NODE_TYPES
.
BUCKET
)
{
return
item
;
}
const
parent
=
getParent
(
item
)
;
if
(
!
parent
)
{
return
null
;
}
return
getClosestNonBucketNode
(
parent
)
;
}
function
shouldLoadItemIndexedProperties
(
item
loadedProperties
=
new
Map
(
)
)
{
const
gripItem
=
getClosestGripNode
(
item
)
;
const
value
=
getValue
(
gripItem
)
;
return
value
&
&
nodeHasProperties
(
gripItem
)
&
&
!
loadedProperties
.
has
(
item
.
path
)
&
&
!
nodeIsProxy
(
item
)
&
&
!
nodeNeedsNumericalBuckets
(
item
)
&
&
!
nodeIsEntries
(
getClosestNonBucketNode
(
item
)
)
&
&
!
nodeIsDefaultProperties
(
item
)
;
}
function
shouldLoadItemNonIndexedProperties
(
item
loadedProperties
=
new
Map
(
)
)
{
const
gripItem
=
getClosestGripNode
(
item
)
;
const
value
=
getValue
(
gripItem
)
;
return
value
&
&
nodeHasProperties
(
gripItem
)
&
&
!
loadedProperties
.
has
(
item
.
path
)
&
&
!
nodeIsProxy
(
item
)
&
&
!
nodeIsEntries
(
getClosestNonBucketNode
(
item
)
)
&
&
!
nodeIsBucket
(
item
)
&
&
!
nodeIsDefaultProperties
(
item
)
;
}
function
shouldLoadItemEntries
(
item
loadedProperties
=
new
Map
(
)
)
{
const
gripItem
=
getClosestGripNode
(
item
)
;
const
value
=
getValue
(
gripItem
)
;
return
value
&
&
nodeIsEntries
(
getClosestNonBucketNode
(
item
)
)
&
&
!
nodeHasAllEntriesInPreview
(
gripItem
)
&
&
!
loadedProperties
.
has
(
item
.
path
)
&
&
!
nodeNeedsNumericalBuckets
(
item
)
;
}
function
shouldLoadItemPrototype
(
item
loadedProperties
=
new
Map
(
)
)
{
const
value
=
getValue
(
item
)
;
return
value
&
&
!
loadedProperties
.
has
(
item
.
path
)
&
&
!
nodeIsBucket
(
item
)
&
&
!
nodeIsMapEntry
(
item
)
&
&
!
nodeIsEntries
(
item
)
&
&
!
nodeIsDefaultProperties
(
item
)
&
&
!
nodeHasAccessors
(
item
)
&
&
!
nodeIsPrimitive
(
item
)
;
}
function
shouldLoadItemSymbols
(
item
loadedProperties
=
new
Map
(
)
)
{
const
value
=
getValue
(
item
)
;
return
value
&
&
!
loadedProperties
.
has
(
item
.
path
)
&
&
!
nodeIsBucket
(
item
)
&
&
!
nodeIsMapEntry
(
item
)
&
&
!
nodeIsEntries
(
item
)
&
&
!
nodeIsDefaultProperties
(
item
)
&
&
!
nodeHasAccessors
(
item
)
&
&
!
nodeIsPrimitive
(
item
)
&
&
!
nodeIsProxy
(
item
)
;
}
module
.
exports
=
{
createNode
getChildren
getClosestGripNode
getClosestNonBucketNode
getParent
getNumericalPropertiesCount
getValue
makeNodesForEntries
makeNodesForPromiseProperties
makeNodesForProperties
makeNumericalBuckets
nodeHasAccessors
nodeHasAllEntriesInPreview
nodeHasChildren
nodeHasEntries
nodeHasProperties
nodeIsBucket
nodeIsDefaultProperties
nodeIsEntries
nodeIsFunction
nodeIsGetter
nodeIsMapEntry
nodeIsMissingArguments
nodeIsObject
nodeIsOptimizedOut
nodeIsPrimitive
nodeIsPromise
nodeIsPrototype
nodeIsProxy
nodeIsSetter
nodeIsWindow
nodeNeedsNumericalBuckets
nodeSupportsNumericalBucketing
setNodeChildren
shouldLoadItemEntries
shouldLoadItemIndexedProperties
shouldLoadItemNonIndexedProperties
shouldLoadItemPrototype
shouldLoadItemSymbols
sortProperties
NODE_TYPES
SAFE_PATH_PREFIX
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
REPS
getRep
}
=
__webpack_require__
(
3
)
;
const
ObjectInspector
=
__webpack_require__
(
42
)
;
const
ObjectInspectorUtils
=
__webpack_require__
(
14
)
;
const
{
parseURLEncodedText
parseURLParams
maybeEscapePropertyName
getGripPreviewItems
}
=
__webpack_require__
(
1
)
;
module
.
exports
=
{
REPS
getRep
MODE
maybeEscapePropertyName
parseURLEncodedText
parseURLParams
getGripPreviewItems
ObjectInspector
ObjectInspectorUtils
}
;
}
)
(
function
(
module
exports
)
{
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
const
Undefined
=
function
(
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
undefined
"
}
"
undefined
"
)
;
}
;
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
)
{
return
object
=
=
=
undefined
;
}
return
object
&
&
object
.
type
&
&
object
.
type
=
=
"
undefined
"
|
|
getGripType
(
object
noGrip
)
=
=
"
undefined
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Undefined
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
function
Null
(
props
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
null
"
}
"
null
"
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
)
{
return
object
=
=
=
null
;
}
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
null
"
)
{
return
true
;
}
return
object
=
=
null
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Null
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
escapeString
sanitizeString
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
LongStringRep
.
propTypes
=
{
useQuotes
:
React
.
PropTypes
.
bool
escapeWhitespace
:
React
.
PropTypes
.
bool
style
:
React
.
PropTypes
.
object
cropLimit
:
React
.
PropTypes
.
number
.
isRequired
member
:
React
.
PropTypes
.
string
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
LongStringRep
(
props
)
{
let
{
cropLimit
member
object
style
useQuotes
=
true
escapeWhitespace
=
true
}
=
props
;
let
{
fullText
initial
length
}
=
object
;
let
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
string
"
}
;
if
(
style
)
{
config
.
style
=
style
;
}
let
string
=
member
&
&
member
.
open
?
fullText
|
|
initial
:
initial
.
substring
(
0
cropLimit
)
;
if
(
string
.
length
<
length
)
{
string
+
=
"
\
u2026
"
;
}
let
formattedString
=
useQuotes
?
escapeString
(
string
escapeWhitespace
)
:
sanitizeString
(
string
)
;
return
span
(
config
formattedString
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
type
=
=
=
"
longString
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
LongStringRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
Number
.
propTypes
=
{
object
:
React
.
PropTypes
.
oneOfType
(
[
React
.
PropTypes
.
object
React
.
PropTypes
.
number
React
.
PropTypes
.
bool
]
)
.
isRequired
}
;
function
Number
(
props
)
{
let
value
=
props
.
object
;
return
span
(
{
className
:
"
objectBox
objectBox
-
number
"
}
stringify
(
value
)
)
;
}
function
stringify
(
object
)
{
let
isNegativeZero
=
Object
.
is
(
object
-
0
)
|
|
object
.
type
&
&
object
.
type
=
=
"
-
0
"
;
return
isNegativeZero
?
"
-
0
"
:
String
(
object
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
[
"
boolean
"
"
number
"
"
-
0
"
]
.
includes
(
getGripType
(
object
noGrip
)
)
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Number
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
const
DEFAULT_TITLE
=
"
Object
"
;
ObjectRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
title
:
React
.
PropTypes
.
string
}
;
function
ObjectRep
(
props
)
{
let
object
=
props
.
object
;
let
propsArray
=
safePropIterator
(
props
object
)
;
if
(
props
.
mode
=
=
=
MODE
.
TINY
)
{
const
tinyModeItems
=
[
]
;
if
(
getTitle
(
props
object
)
!
=
=
DEFAULT_TITLE
)
{
tinyModeItems
.
push
(
getTitleElement
(
props
object
)
)
;
}
else
{
tinyModeItems
.
push
(
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
propsArray
.
length
>
0
?
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
:
null
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
.
.
.
tinyModeItems
)
;
}
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
getTitleElement
(
props
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitleElement
(
props
object
)
{
return
span
(
{
className
:
"
objectTitle
"
}
getTitle
(
props
object
)
)
;
}
function
getTitle
(
props
object
)
{
return
props
.
title
|
|
object
.
class
|
|
DEFAULT_TITLE
;
}
function
safePropIterator
(
props
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
3
:
max
;
try
{
return
propIterator
(
props
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
function
propIterator
(
props
object
max
)
{
let
isInterestingProp
=
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
;
}
;
if
(
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Generator
]
"
)
{
object
=
Object
.
getPrototypeOf
(
object
)
;
}
let
interestingObject
=
getFilteredObject
(
object
max
isInterestingProp
)
;
if
(
Object
.
keys
(
interestingObject
)
.
length
<
max
)
{
interestingObject
=
Object
.
assign
(
{
}
interestingObject
getFilteredObject
(
object
max
-
Object
.
keys
(
interestingObject
)
.
length
(
type
value
)
=
>
!
isInterestingProp
(
type
value
)
)
)
;
}
let
propsArray
=
getPropsArray
(
interestingObject
props
)
;
if
(
Object
.
keys
(
object
)
.
length
>
max
)
{
propsArray
.
push
(
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
unfoldProps
(
propsArray
)
;
}
function
unfoldProps
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
Array
.
isArray
(
item
)
)
{
res
=
res
.
concat
(
item
)
;
}
else
{
res
.
push
(
item
)
;
}
if
(
index
!
=
=
items
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
getPropsArray
(
object
props
)
{
let
propsArray
=
[
]
;
if
(
!
object
)
{
return
propsArray
;
}
let
mode
=
MODE
.
TINY
;
const
objectKeys
=
Object
.
keys
(
object
)
;
return
objectKeys
.
map
(
(
name
i
)
=
>
PropRep
(
Object
.
assign
(
{
}
props
{
mode
name
object
:
object
[
name
]
equal
:
"
:
"
}
)
)
)
;
}
function
getFilteredObject
(
object
max
filter
)
{
let
filteredObject
=
{
}
;
try
{
for
(
let
name
in
object
)
{
if
(
Object
.
keys
(
filteredObject
)
.
length
>
=
max
)
{
return
filteredObject
;
}
let
value
;
try
{
value
=
object
[
name
]
;
}
catch
(
exc
)
{
continue
;
}
let
t
=
typeof
value
;
if
(
filter
(
t
value
)
)
{
filteredObject
[
name
]
=
value
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
filteredObject
;
}
function
supportsObject
(
object
)
{
return
true
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ObjectRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
SymbolRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
SymbolRep
(
props
)
{
let
{
className
=
"
objectBox
objectBox
-
symbol
"
object
}
=
props
;
let
{
name
}
=
object
;
return
span
(
{
className
}
Symbol
(
{
name
|
|
"
"
}
)
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
getGripType
(
object
noGrip
)
=
=
"
symbol
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
SymbolRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
InfinityRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
InfinityRep
(
props
)
{
const
{
object
}
=
props
;
return
span
(
{
className
:
"
objectBox
objectBox
-
number
"
}
object
.
type
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
const
type
=
getGripType
(
object
noGrip
)
;
return
type
=
=
"
Infinity
"
|
|
type
=
=
"
-
Infinity
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
InfinityRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
function
NaNRep
(
props
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
nan
"
}
"
NaN
"
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
getGripType
(
object
noGrip
)
=
=
"
NaN
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
NaNRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
Accessor
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
values
(
MODE
)
)
}
;
function
Accessor
(
props
)
{
const
{
object
}
=
props
;
const
accessors
=
[
]
;
if
(
hasGetter
(
object
)
)
{
accessors
.
push
(
"
Getter
"
)
;
}
if
(
hasSetter
(
object
)
)
{
accessors
.
push
(
"
Setter
"
)
;
}
const
title
=
accessors
.
join
(
"
&
"
)
;
return
span
(
{
className
:
"
objectBox
objectBox
-
accessor
"
}
span
(
{
className
:
"
objectTitle
"
}
title
)
)
;
}
function
hasGetter
(
object
)
{
return
object
&
&
object
.
get
&
&
object
.
get
.
type
!
=
=
"
undefined
"
;
}
function
hasSetter
(
object
)
{
return
object
&
&
object
.
set
&
&
object
.
set
.
type
!
=
=
"
undefined
"
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
!
=
=
true
&
&
(
hasGetter
(
object
)
|
|
hasSetter
(
object
)
)
)
{
return
true
;
}
return
false
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Accessor
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
rep
:
StringRep
}
=
__webpack_require__
(
5
)
;
const
{
span
}
=
React
.
DOM
;
Attribute
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
Attribute
(
props
)
{
let
{
object
}
=
props
;
let
value
=
object
.
preview
.
value
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
-
Attr
"
}
span
(
{
className
:
"
attrName
"
}
getTitle
(
object
)
)
span
(
{
className
:
"
attrEqual
"
}
"
=
"
)
StringRep
(
{
className
:
"
attrValue
"
object
:
value
}
)
)
;
}
function
getTitle
(
grip
)
{
return
grip
.
preview
.
nodeName
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
getGripType
(
grip
noGrip
)
=
=
"
Attr
"
&
&
grip
.
preview
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Attribute
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
DateTime
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
DateTime
(
props
)
{
let
grip
=
props
.
object
;
let
date
;
try
{
date
=
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
"
}
getTitle
(
grip
)
span
(
{
className
:
"
Date
"
}
new
Date
(
grip
.
preview
.
timestamp
)
.
toISOString
(
)
)
)
;
}
catch
(
e
)
{
date
=
span
(
{
className
:
"
objectBox
"
}
"
Invalid
Date
"
)
;
}
return
date
;
}
function
getTitle
(
grip
)
{
return
span
(
{
className
:
"
objectTitle
"
}
grip
.
class
+
"
"
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
getGripType
(
grip
noGrip
)
=
=
"
Date
"
&
&
grip
.
preview
;
}
module
.
exports
=
{
rep
:
wrapRender
(
DateTime
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
Document
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
Document
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
document
"
}
getTitle
(
grip
)
span
(
{
className
:
"
location
"
}
getLocation
(
grip
)
)
)
;
}
function
getLocation
(
grip
)
{
let
location
=
grip
.
preview
.
location
;
return
location
?
getURLDisplayString
(
location
)
:
"
"
;
}
function
getTitle
(
grip
)
{
return
span
(
{
className
:
"
objectTitle
"
}
grip
.
class
+
"
"
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
getGripType
(
object
noGrip
)
=
=
"
HTMLDocument
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Document
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
rep
}
=
__webpack_require__
(
6
)
;
Event
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
Event
(
props
)
{
let
gripProps
=
Object
.
assign
(
{
}
props
{
title
:
getTitle
(
props
)
}
)
;
gripProps
.
object
=
Object
.
assign
(
{
}
props
.
object
)
;
gripProps
.
object
.
preview
=
Object
.
assign
(
{
}
props
.
object
.
preview
)
;
gripProps
.
object
.
preview
.
ownProperties
=
{
}
;
if
(
gripProps
.
object
.
preview
.
target
)
{
Object
.
assign
(
gripProps
.
object
.
preview
.
ownProperties
{
target
:
gripProps
.
object
.
preview
.
target
}
)
;
}
Object
.
assign
(
gripProps
.
object
.
preview
.
ownProperties
gripProps
.
object
.
preview
.
properties
)
;
delete
gripProps
.
object
.
preview
.
properties
;
gripProps
.
object
.
ownPropertyLength
=
Object
.
keys
(
gripProps
.
object
.
preview
.
ownProperties
)
.
length
;
switch
(
gripProps
.
object
.
class
)
{
case
"
MouseEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
clientX
"
"
clientY
"
"
layerX
"
"
layerY
"
]
.
includes
(
name
)
;
}
;
break
;
case
"
KeyboardEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
key
"
"
charCode
"
"
keyCode
"
]
.
includes
(
name
)
;
}
;
break
;
case
"
MessageEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
isTrusted
"
"
data
"
]
.
includes
(
name
)
;
}
;
break
;
default
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
Object
.
keys
(
gripProps
.
object
.
preview
.
ownProperties
)
.
includes
(
name
)
;
}
;
}
return
rep
(
gripProps
)
;
}
function
getTitle
(
props
)
{
let
preview
=
props
.
object
.
preview
;
let
title
=
preview
.
type
;
if
(
preview
.
eventKind
=
=
"
key
"
&
&
preview
.
modifiers
&
&
preview
.
modifiers
.
length
)
{
title
=
{
title
}
{
preview
.
modifiers
.
join
(
"
-
"
)
}
;
}
return
title
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
DOMEvent
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Event
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
cropString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
FunctionRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
parameterNames
:
React
.
PropTypes
.
array
}
;
function
FunctionRep
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
function
"
dir
:
"
ltr
"
}
getTitle
(
grip
props
)
getFunctionName
(
grip
props
)
"
(
"
.
.
.
renderParams
(
props
)
"
)
"
)
;
}
function
getTitle
(
grip
props
)
{
const
{
mode
}
=
props
;
if
(
mode
=
=
=
MODE
.
TINY
&
&
!
grip
.
isGenerator
&
&
!
grip
.
isAsync
)
{
return
null
;
}
let
title
=
mode
=
=
=
MODE
.
TINY
?
"
"
:
"
function
"
;
if
(
grip
.
isGenerator
)
{
title
=
mode
=
=
=
MODE
.
TINY
?
"
*
"
:
"
function
*
"
;
}
if
(
grip
.
isAsync
)
{
title
=
"
async
"
+
"
"
+
title
;
}
return
span
(
{
className
:
"
objectTitle
"
}
title
)
;
}
function
getFunctionName
(
grip
props
)
{
let
name
=
grip
.
userDisplayName
|
|
grip
.
displayName
|
|
grip
.
name
|
|
props
.
functionName
|
|
"
"
;
return
cropString
(
name
100
)
;
}
function
renderParams
(
props
)
{
const
{
parameterNames
=
[
]
}
=
props
;
return
parameterNames
.
filter
(
param
=
>
param
)
.
reduce
(
(
res
param
index
arr
)
=
>
{
res
.
push
(
span
(
{
className
:
"
param
"
}
param
)
)
;
if
(
index
<
arr
.
length
-
1
)
{
res
.
push
(
span
(
{
className
:
"
delimiter
"
}
"
"
)
)
;
}
return
res
;
}
[
]
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
const
type
=
getGripType
(
grip
noGrip
)
;
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
type
=
=
"
function
"
;
}
return
type
=
=
"
Function
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
FunctionRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
PromiseRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
PromiseRep
(
props
)
{
const
object
=
props
.
object
;
const
{
promiseState
}
=
object
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
;
if
(
props
.
mode
=
=
=
MODE
.
TINY
)
{
let
{
Rep
}
=
__webpack_require__
(
3
)
;
return
span
(
config
getTitle
(
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
Rep
(
{
object
:
promiseState
.
state
}
)
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
const
propsArray
=
getProps
(
props
promiseState
)
;
return
span
(
config
getTitle
(
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitle
(
object
)
{
return
span
(
{
className
:
"
objectTitle
"
}
object
.
class
)
;
}
function
getProps
(
props
promiseState
)
{
const
keys
=
[
"
state
"
]
;
if
(
Object
.
keys
(
promiseState
)
.
includes
(
"
value
"
)
)
{
keys
.
push
(
"
value
"
)
;
}
return
keys
.
reduce
(
(
res
key
i
)
=
>
{
let
object
=
promiseState
[
key
]
;
res
=
res
.
concat
(
PropRep
(
Object
.
assign
(
{
}
props
{
mode
:
MODE
.
TINY
name
:
<
{
key
}
>
object
equal
:
"
:
"
suppressQuotes
:
true
}
)
)
)
;
if
(
i
!
=
=
keys
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
getGripType
(
object
noGrip
)
=
=
"
Promise
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
PromiseRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
RegExp
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
RegExp
(
props
)
{
let
{
object
}
=
props
;
return
React
.
DOM
.
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
regexp
regexpSource
"
}
getSource
(
object
)
)
;
}
function
getSource
(
grip
)
{
return
grip
.
displayString
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
getGripType
(
object
noGrip
)
=
=
"
RegExp
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
RegExp
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
StyleSheet
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
StyleSheet
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
getLocation
(
grip
)
)
)
;
}
function
getTitle
(
grip
)
{
let
title
=
"
StyleSheet
"
;
return
span
(
{
className
:
"
objectBoxTitle
"
}
title
)
;
}
function
getLocation
(
grip
)
{
let
url
=
grip
.
preview
?
grip
.
preview
.
url
:
"
"
;
return
url
?
getURLDisplayString
(
url
)
:
"
"
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
getGripType
(
object
noGrip
)
=
=
"
CSSStyleSheet
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
StyleSheet
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
cropString
cropMultipleLines
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
nodeConstants
=
__webpack_require__
(
8
)
;
const
{
span
}
=
React
.
DOM
;
CommentNode
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
}
;
function
CommentNode
(
props
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
props
;
let
{
textContent
}
=
object
.
preview
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
textContent
=
cropMultipleLines
(
textContent
30
)
;
}
else
if
(
mode
=
=
=
MODE
.
SHORT
)
{
textContent
=
cropString
(
textContent
50
)
;
}
return
span
(
{
className
:
"
objectBox
theme
-
comment
"
"
data
-
link
-
actor
-
id
"
:
object
.
actor
}
<
!
-
-
{
textContent
}
-
-
>
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
object
.
preview
.
nodeType
=
=
=
nodeConstants
.
COMMENT_NODE
;
}
module
.
exports
=
{
rep
:
wrapRender
(
CommentNode
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
rep
:
StringRep
}
=
__webpack_require__
(
5
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
nodeConstants
=
__webpack_require__
(
8
)
;
const
Svg
=
__webpack_require__
(
9
)
;
const
{
span
}
=
React
.
DOM
;
ElementNode
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
ElementNode
(
props
)
{
let
{
object
mode
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
props
;
let
elements
=
getElements
(
object
mode
)
;
let
isInTree
=
object
.
preview
&
&
object
.
preview
.
isConnected
=
=
=
true
;
let
baseConfig
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
node
"
}
;
let
inspectIcon
;
if
(
isInTree
)
{
if
(
onDOMNodeMouseOver
)
{
Object
.
assign
(
baseConfig
{
onMouseOver
:
_
=
>
onDOMNodeMouseOver
(
object
)
}
)
;
}
if
(
onDOMNodeMouseOut
)
{
Object
.
assign
(
baseConfig
{
onMouseOut
:
onDOMNodeMouseOut
}
)
;
}
if
(
onInspectIconClick
)
{
inspectIcon
=
Svg
(
"
open
-
inspector
"
{
element
:
"
a
"
draggable
:
false
title
:
"
Click
to
select
the
node
in
the
inspector
"
onClick
:
e
=
>
onInspectIconClick
(
object
e
)
}
)
;
}
}
return
span
(
baseConfig
.
.
.
elements
inspectIcon
)
;
}
function
getElements
(
grip
mode
)
{
let
{
attributes
nodeName
}
=
grip
.
preview
;
const
nodeNameElement
=
span
(
{
className
:
"
tag
-
name
"
}
nodeName
)
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
elements
=
[
nodeNameElement
]
;
if
(
attributes
.
id
)
{
elements
.
push
(
span
(
{
className
:
"
attrName
"
}
#
{
attributes
.
id
}
)
)
;
}
if
(
attributes
.
class
)
{
elements
.
push
(
span
(
{
className
:
"
attrName
"
}
attributes
.
class
.
trim
(
)
.
split
(
/
\
s
+
/
)
.
map
(
cls
=
>
.
{
cls
}
)
.
join
(
"
"
)
)
)
;
}
return
elements
;
}
let
attributeKeys
=
Object
.
keys
(
attributes
)
;
if
(
attributeKeys
.
includes
(
"
class
"
)
)
{
attributeKeys
.
splice
(
attributeKeys
.
indexOf
(
"
class
"
)
1
)
;
attributeKeys
.
unshift
(
"
class
"
)
;
}
if
(
attributeKeys
.
includes
(
"
id
"
)
)
{
attributeKeys
.
splice
(
attributeKeys
.
indexOf
(
"
id
"
)
1
)
;
attributeKeys
.
unshift
(
"
id
"
)
;
}
const
attributeElements
=
attributeKeys
.
reduce
(
(
arr
name
i
keys
)
=
>
{
let
value
=
attributes
[
name
]
;
let
attribute
=
span
(
{
}
span
(
{
className
:
"
attrName
"
}
name
)
span
(
{
className
:
"
attrEqual
"
}
"
=
"
)
StringRep
(
{
className
:
"
attrValue
"
object
:
value
}
)
)
;
return
arr
.
concat
(
[
"
"
attribute
]
)
;
}
[
]
)
;
return
[
span
(
{
className
:
"
angleBracket
"
}
"
<
"
)
nodeNameElement
.
.
.
attributeElements
span
(
{
className
:
"
angleBracket
"
}
"
>
"
)
]
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
object
.
preview
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ElementNode
)
supportsObject
}
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
>
<
path
d
=
\
"
M8
3L12
3L12
7L14
7L14
8L12
8L12
12L8
12L8
14L7
14L7
12L3
12L3
8L1
8L1
7L3
7L3
3L7
3L7
1L8
1L8
3ZM10
10L10
5L5
5L5
10L10
10Z
\
"
>
<
/
path
>
<
/
svg
>
"
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
cropString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
Svg
=
__webpack_require__
(
9
)
;
const
DOM
=
React
.
DOM
;
TextNode
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
TextNode
(
props
)
{
let
{
object
:
grip
mode
=
MODE
.
SHORT
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
props
;
let
baseConfig
=
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
textNode
"
}
;
let
inspectIcon
;
let
isInTree
=
grip
.
preview
&
&
grip
.
preview
.
isConnected
=
=
=
true
;
if
(
isInTree
)
{
if
(
onDOMNodeMouseOver
)
{
Object
.
assign
(
baseConfig
{
onMouseOver
:
_
=
>
onDOMNodeMouseOver
(
grip
)
}
)
;
}
if
(
onDOMNodeMouseOut
)
{
Object
.
assign
(
baseConfig
{
onMouseOut
:
onDOMNodeMouseOut
}
)
;
}
if
(
onInspectIconClick
)
{
inspectIcon
=
Svg
(
"
open
-
inspector
"
{
element
:
"
a
"
draggable
:
false
title
:
"
Click
to
select
the
node
in
the
inspector
"
onClick
:
e
=
>
onInspectIconClick
(
grip
e
)
}
)
;
}
}
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
DOM
.
span
(
baseConfig
getTitle
(
grip
)
inspectIcon
)
;
}
return
DOM
.
span
(
baseConfig
getTitle
(
grip
)
DOM
.
span
(
{
className
:
"
nodeValue
"
}
"
"
"
{
getTextContent
(
grip
)
}
"
)
inspectIcon
)
;
}
function
getTextContent
(
grip
)
{
return
cropString
(
grip
.
preview
.
textContent
)
;
}
function
getTitle
(
grip
)
{
const
title
=
"
#
text
"
;
return
DOM
.
span
(
{
}
title
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
class
=
=
"
Text
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
TextNode
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
ErrorRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
}
;
function
ErrorRep
(
props
)
{
let
object
=
props
.
object
;
let
preview
=
object
.
preview
;
let
name
=
preview
&
&
preview
.
name
?
preview
.
name
:
"
Error
"
;
let
content
=
props
.
mode
=
=
=
MODE
.
TINY
?
name
:
{
name
}
:
{
preview
.
message
}
;
if
(
preview
.
stack
&
&
props
.
mode
!
=
=
MODE
.
TINY
)
{
content
=
{
content
}
\
nStack
trace
:
\
n
{
preview
.
stack
}
;
}
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
-
stackTrace
"
}
content
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
getGripType
(
object
noGrip
)
=
=
=
"
Error
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ErrorRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
WindowRep
.
propTypes
=
{
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
WindowRep
(
props
)
{
let
{
mode
object
}
=
props
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
Window
"
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
span
(
config
getTitle
(
object
)
)
;
}
return
span
(
config
getTitle
(
object
)
"
"
span
(
{
className
:
"
location
"
}
getLocation
(
object
)
)
)
;
}
function
getTitle
(
object
)
{
let
title
=
object
.
displayClass
|
|
object
.
class
|
|
"
Window
"
;
return
span
(
{
className
:
"
objectTitle
"
}
title
)
;
}
function
getLocation
(
object
)
{
return
getURLDisplayString
(
object
.
preview
.
url
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
getGripType
(
object
noGrip
)
=
=
"
Window
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
WindowRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
ObjectWithText
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
ObjectWithText
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
"
+
getType
(
grip
)
}
span
(
{
className
:
"
objectPropValue
"
}
getDescription
(
grip
)
)
)
;
}
function
getType
(
grip
)
{
return
grip
.
class
;
}
function
getDescription
(
grip
)
{
return
"
\
"
"
+
grip
.
preview
.
text
+
"
\
"
"
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithText
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ObjectWithText
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
ObjectWithURL
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
ObjectWithURL
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
"
+
getType
(
grip
)
}
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
getDescription
(
grip
)
)
)
;
}
function
getTitle
(
grip
)
{
return
span
(
{
className
:
"
objectTitle
"
}
getType
(
grip
)
+
"
"
)
;
}
function
getType
(
grip
)
{
return
grip
.
class
;
}
function
getDescription
(
grip
)
{
return
getURLDisplayString
(
grip
.
preview
.
url
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithURL
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ObjectWithURL
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_devtoolsComponents
=
__webpack_require__
(
43
)
;
var
_devtoolsComponents2
=
_interopRequireDefault
(
_devtoolsComponents
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
const
{
Component
createFactory
DOM
:
dom
PropTypes
}
=
__webpack_require__
(
0
)
;
const
Tree
=
createFactory
(
_devtoolsComponents2
.
default
.
Tree
)
;
__webpack_require__
(
47
)
;
const
classnames
=
__webpack_require__
(
48
)
;
const
{
REPS
:
{
Rep
Grip
}
}
=
__webpack_require__
(
3
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
getChildren
getClosestGripNode
getParent
getValue
nodeHasAccessors
nodeHasProperties
nodeIsDefaultProperties
nodeIsFunction
nodeIsGetter
nodeIsMapEntry
nodeIsMissingArguments
nodeIsOptimizedOut
nodeIsPrimitive
nodeIsPrototype
nodeIsSetter
nodeIsWindow
shouldLoadItemEntries
shouldLoadItemIndexedProperties
shouldLoadItemNonIndexedProperties
shouldLoadItemPrototype
shouldLoadItemSymbols
}
=
__webpack_require__
(
14
)
;
const
{
enumEntries
enumIndexedProperties
enumNonIndexedProperties
getPrototype
enumSymbols
}
=
__webpack_require__
(
50
)
;
class
ObjectInspector
extends
Component
{
constructor
(
props
)
{
super
(
)
;
this
.
cachedNodes
=
new
Map
(
)
;
this
.
state
=
{
actors
:
new
Set
(
)
expandedPaths
:
new
Set
(
)
focusedItem
:
null
loadedProperties
:
props
.
loadedProperties
|
|
new
Map
(
)
loading
:
new
Map
(
)
}
;
const
self
=
this
;
self
.
getChildren
=
this
.
getChildren
.
bind
(
this
)
;
self
.
renderTreeItem
=
this
.
renderTreeItem
.
bind
(
this
)
;
self
.
setExpanded
=
this
.
setExpanded
.
bind
(
this
)
;
self
.
focusItem
=
this
.
focusItem
.
bind
(
this
)
;
self
.
getRoots
=
this
.
getRoots
.
bind
(
this
)
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
const
{
expandedPaths
loadedProperties
}
=
this
.
state
;
return
expandedPaths
.
size
!
=
=
nextState
.
expandedPaths
.
size
|
|
loadedProperties
.
size
!
=
=
nextState
.
loadedProperties
.
size
|
|
[
.
.
.
expandedPaths
]
.
some
(
key
=
>
!
nextState
.
expandedPaths
.
has
(
key
)
)
;
}
componentWillUnmount
(
)
{
const
{
releaseActor
}
=
this
.
props
;
if
(
typeof
releaseActor
!
=
=
"
function
"
)
{
return
;
}
const
{
actors
}
=
this
.
state
;
for
(
let
actor
of
actors
)
{
releaseActor
(
actor
)
;
}
}
getChildren
(
item
)
{
const
{
loadedProperties
}
=
this
.
state
;
const
{
cachedNodes
}
=
this
;
return
getChildren
(
{
loadedProperties
cachedNodes
item
}
)
;
}
getRoots
(
)
{
return
this
.
props
.
roots
;
}
getKey
(
item
)
{
return
item
.
path
;
}
setExpanded
(
item
expand
)
{
var
_this
=
this
;
return
_asyncToGenerator
(
function
*
(
)
{
if
(
nodeIsPrimitive
(
item
)
)
{
return
;
}
const
{
loadedProperties
}
=
_this
.
state
;
const
key
=
_this
.
getKey
(
item
)
;
_this
.
setState
(
function
(
prevState
props
)
{
const
newPaths
=
new
Set
(
prevState
.
expandedPaths
)
;
if
(
expand
=
=
=
true
)
{
newPaths
.
add
(
key
)
;
}
else
{
newPaths
.
delete
(
key
)
;
}
return
{
expandedPaths
:
newPaths
}
;
}
)
;
if
(
expand
=
=
=
true
)
{
const
gripItem
=
getClosestGripNode
(
item
)
;
const
value
=
getValue
(
gripItem
)
;
const
path
=
item
.
path
;
const
[
start
end
]
=
item
.
meta
?
[
item
.
meta
.
startIndex
item
.
meta
.
endIndex
]
:
[
]
;
let
promises
=
[
]
;
let
objectClient
;
const
getObjectClient
=
function
(
)
{
if
(
objectClient
)
{
return
objectClient
;
}
return
_this
.
props
.
createObjectClient
(
value
)
;
}
;
if
(
shouldLoadItemIndexedProperties
(
item
loadedProperties
)
)
{
promises
.
push
(
enumIndexedProperties
(
getObjectClient
(
)
start
end
)
)
;
}
if
(
shouldLoadItemNonIndexedProperties
(
item
loadedProperties
)
)
{
promises
.
push
(
enumNonIndexedProperties
(
getObjectClient
(
)
start
end
)
)
;
}
if
(
shouldLoadItemEntries
(
item
loadedProperties
)
)
{
promises
.
push
(
enumEntries
(
getObjectClient
(
)
start
end
)
)
;
}
if
(
shouldLoadItemPrototype
(
item
loadedProperties
)
)
{
promises
.
push
(
getPrototype
(
getObjectClient
(
)
)
)
;
}
if
(
shouldLoadItemSymbols
(
item
loadedProperties
)
)
{
promises
.
push
(
enumSymbols
(
getObjectClient
(
)
start
end
)
)
;
}
if
(
promises
.
length
>
0
)
{
_this
.
setState
(
function
(
prevState
props
)
{
const
nextLoading
=
new
Map
(
prevState
.
loading
)
;
nextLoading
.
set
(
path
promises
)
;
return
{
loading
:
nextLoading
}
;
}
)
;
const
responses
=
yield
Promise
.
all
(
promises
)
;
const
response
=
responses
.
reduce
(
function
(
accumulator
res
)
{
Object
.
entries
(
res
)
.
forEach
(
function
(
[
k
v
]
)
{
if
(
accumulator
.
hasOwnProperty
(
k
)
)
{
if
(
Array
.
isArray
(
accumulator
[
k
]
)
)
{
accumulator
[
k
]
.
push
(
.
.
.
v
)
;
}
else
if
(
typeof
accumulator
[
k
]
=
=
=
"
object
"
)
{
accumulator
[
k
]
=
Object
.
assign
(
{
}
accumulator
[
k
]
v
)
;
}
}
else
{
accumulator
[
k
]
=
v
;
}
}
)
;
return
accumulator
;
}
{
}
)
;
_this
.
setState
(
function
(
prevState
props
)
{
const
nextLoading
=
new
Map
(
prevState
.
loading
)
;
nextLoading
.
delete
(
path
)
;
const
isRoot
=
_this
.
props
.
roots
.
some
(
function
(
root
)
{
const
rootValue
=
getValue
(
root
)
;
return
rootValue
&
&
rootValue
.
actor
=
=
=
value
.
actor
;
}
)
;
return
{
actors
:
isRoot
?
prevState
.
actors
:
new
Set
(
prevState
.
actors
)
.
add
(
value
.
actor
)
loadedProperties
:
new
Map
(
prevState
.
loadedProperties
)
.
set
(
path
response
)
loading
:
nextLoading
}
;
}
)
;
}
}
}
)
(
)
;
}
focusItem
(
item
)
{
if
(
!
this
.
props
.
disabledFocus
&
&
this
.
state
.
focusedItem
!
=
=
item
)
{
this
.
setState
(
{
focusedItem
:
item
}
)
;
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
}
renderTreeItem
(
item
depth
focused
arrow
expanded
)
{
let
objectValue
;
let
label
=
item
.
name
;
let
itemValue
=
getValue
(
item
)
;
const
isPrimitive
=
nodeIsPrimitive
(
item
)
;
const
unavailable
=
isPrimitive
&
&
itemValue
&
&
itemValue
.
hasOwnProperty
&
&
itemValue
.
hasOwnProperty
(
"
unavailable
"
)
;
if
(
nodeIsOptimizedOut
(
item
)
)
{
objectValue
=
dom
.
span
(
{
className
:
"
unavailable
"
}
"
(
optimized
away
)
"
)
;
}
else
if
(
nodeIsMissingArguments
(
item
)
|
|
unavailable
)
{
objectValue
=
dom
.
span
(
{
className
:
"
unavailable
"
}
"
(
unavailable
)
"
)
;
}
else
if
(
nodeIsFunction
(
item
)
&
&
!
nodeIsGetter
(
item
)
&
&
!
nodeIsSetter
(
item
)
&
&
(
this
.
props
.
mode
=
=
=
MODE
.
TINY
|
|
!
this
.
props
.
mode
)
)
{
objectValue
=
undefined
;
label
=
this
.
renderGrip
(
item
Object
.
assign
(
{
}
this
.
props
{
functionName
:
label
}
)
)
;
}
else
if
(
nodeHasProperties
(
item
)
|
|
nodeHasAccessors
(
item
)
|
|
nodeIsMapEntry
(
item
)
|
|
isPrimitive
)
{
let
repsProp
=
Object
.
assign
(
{
}
this
.
props
)
;
if
(
depth
>
0
)
{
repsProp
.
mode
=
this
.
props
.
mode
=
=
=
MODE
.
LONG
?
MODE
.
SHORT
:
MODE
.
TINY
;
}
if
(
expanded
)
{
repsProp
.
mode
=
MODE
.
TINY
;
}
objectValue
=
this
.
renderGrip
(
item
repsProp
)
;
}
const
hasLabel
=
label
!
=
=
null
&
&
typeof
label
!
=
=
"
undefined
"
;
const
hasValue
=
typeof
objectValue
!
=
=
"
undefined
"
;
const
{
onDoubleClick
onLabelClick
dimTopLevelWindow
}
=
this
.
props
;
return
dom
.
div
(
{
className
:
classnames
(
"
node
object
-
node
"
{
focused
lessen
:
!
expanded
&
&
(
nodeIsDefaultProperties
(
item
)
|
|
nodeIsPrototype
(
item
)
|
|
dimTopLevelWindow
=
=
=
true
&
&
nodeIsWindow
(
item
)
&
&
depth
=
=
=
0
)
}
)
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
if
(
isPrimitive
=
=
=
false
)
{
this
.
setExpanded
(
item
!
expanded
)
;
}
}
onDoubleClick
:
onDoubleClick
?
e
=
>
{
e
.
stopPropagation
(
)
;
onDoubleClick
(
item
{
depth
focused
expanded
}
)
;
}
:
null
}
arrow
hasLabel
?
dom
.
span
(
{
className
:
"
object
-
label
"
onClick
:
onLabelClick
?
event
=
>
{
event
.
stopPropagation
(
)
;
onLabelClick
(
item
{
depth
focused
expanded
setExpanded
:
this
.
setExpanded
}
)
;
}
:
null
}
label
)
:
null
hasLabel
&
&
hasValue
?
dom
.
span
(
{
className
:
"
object
-
delimiter
"
}
"
:
"
)
:
null
hasValue
?
objectValue
:
null
)
;
}
renderGrip
(
item
props
)
{
const
object
=
getValue
(
item
)
;
return
Rep
(
Object
.
assign
(
{
}
props
{
object
mode
:
props
.
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
)
;
}
render
(
)
{
const
{
autoExpandDepth
=
1
autoExpandAll
=
true
disabledFocus
inline
itemHeight
=
20
disableWrap
=
false
}
=
this
.
props
;
const
{
expandedPaths
focusedItem
}
=
this
.
state
;
let
roots
=
this
.
getRoots
(
)
;
if
(
roots
.
length
=
=
=
1
)
{
const
root
=
roots
[
0
]
;
const
name
=
root
&
&
root
.
name
;
if
(
nodeIsPrimitive
(
root
)
&
&
(
name
=
=
=
null
|
|
typeof
name
=
=
=
"
undefined
"
)
)
{
return
this
.
renderGrip
(
root
this
.
props
)
;
}
}
return
Tree
(
{
className
:
classnames
(
{
inline
nowrap
:
disableWrap
"
object
-
inspector
"
:
true
}
)
autoExpandAll
autoExpandDepth
disabledFocus
itemHeight
isExpanded
:
item
=
>
expandedPaths
.
has
(
this
.
getKey
(
item
)
)
isExpandable
:
item
=
>
nodeIsPrimitive
(
item
)
=
=
=
false
focused
:
focusedItem
getRoots
:
this
.
getRoots
getParent
getChildren
:
this
.
getChildren
getKey
:
this
.
getKey
onExpand
:
item
=
>
this
.
setExpanded
(
item
true
)
onCollapse
:
item
=
>
this
.
setExpanded
(
item
false
)
onFocus
:
this
.
focusItem
renderItem
:
this
.
renderTreeItem
}
)
;
}
}
ObjectInspector
.
displayName
=
"
ObjectInspector
"
;
ObjectInspector
.
propTypes
=
{
autoExpandAll
:
PropTypes
.
bool
autoExpandDepth
:
PropTypes
.
number
disabledFocus
:
PropTypes
.
bool
disableWrap
:
PropTypes
.
bool
inline
:
PropTypes
.
bool
roots
:
PropTypes
.
array
itemHeight
:
PropTypes
.
number
mode
:
PropTypes
.
oneOf
(
Object
.
values
(
MODE
)
)
createObjectClient
:
PropTypes
.
func
.
isRequired
onFocus
:
PropTypes
.
func
onDoubleClick
:
PropTypes
.
func
onLabelClick
:
PropTypes
.
func
}
;
module
.
exports
=
ObjectInspector
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_tree
=
__webpack_require__
(
44
)
;
var
_tree2
=
_interopRequireDefault
(
_tree
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
exports
.
default
=
{
Tree
:
_tree2
.
default
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_react
=
__webpack_require__
(
0
)
;
var
_react2
=
_interopRequireDefault
(
_react
)
;
var
_svgInlineReact
=
__webpack_require__
(
10
)
;
var
_svgInlineReact2
=
_interopRequireDefault
(
_svgInlineReact
)
;
var
_arrow
=
__webpack_require__
(
45
)
;
var
_arrow2
=
_interopRequireDefault
(
_arrow
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
{
DOM
:
dom
createClass
createFactory
createElement
PropTypes
}
=
_react2
.
default
;
__webpack_require__
(
46
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
ArrowExpander
=
createFactory
(
createClass
(
{
displayName
:
"
ArrowExpander
"
propTypes
:
{
expanded
:
PropTypes
.
bool
}
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
{
expanded
}
=
this
.
props
;
const
classNames
=
[
"
arrow
"
]
;
if
(
expanded
)
{
classNames
.
push
(
"
expanded
"
)
;
}
return
createElement
(
_svgInlineReact2
.
default
{
className
:
classNames
.
join
(
"
"
)
src
:
_arrow2
.
default
}
)
;
}
}
)
)
;
const
TreeNode
=
createFactory
(
createClass
(
{
displayName
:
"
TreeNode
"
propTypes
:
{
id
:
PropTypes
.
any
.
isRequired
index
:
PropTypes
.
number
.
isRequired
depth
:
PropTypes
.
number
.
isRequired
focused
:
PropTypes
.
bool
.
isRequired
expanded
:
PropTypes
.
bool
.
isRequired
item
:
PropTypes
.
any
.
isRequired
isExpandable
:
PropTypes
.
bool
.
isRequired
onClick
:
PropTypes
.
func
renderItem
:
PropTypes
.
func
.
isRequired
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
focused
!
=
=
nextProps
.
focused
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
{
depth
id
item
focused
expanded
renderItem
isExpandable
}
=
this
.
props
;
const
arrow
=
isExpandable
?
ArrowExpander
(
{
item
expanded
}
)
:
null
;
const
treeIndentWidthVar
=
"
var
(
-
-
tree
-
indent
-
width
)
"
;
const
treeBorderColorVar
=
"
var
(
-
-
tree
-
indent
-
border
-
color
black
)
"
;
const
treeBorderWidthVar
=
"
var
(
-
-
tree
-
indent
-
border
-
width
1px
)
"
;
const
paddingInlineStart
=
calc
(
(
{
treeIndentWidthVar
}
*
{
depth
}
)
{
isExpandable
?
"
"
:
"
+
var
(
-
-
arrow
-
total
-
width
)
"
}
)
;
const
backgroundBorder
=
depth
=
=
=
0
?
null
:
"
linear
-
gradient
(
90deg
"
+
Array
.
from
(
{
length
:
depth
}
)
.
map
(
(
_
i
)
=
>
{
const
indentWidth
=
(
{
i
}
*
{
treeIndentWidthVar
}
)
;
const
alignIndent
=
(
var
(
-
-
arrow
-
width
)
/
2
)
;
const
start
=
calc
(
{
indentWidth
}
+
{
alignIndent
}
)
;
const
end
=
calc
(
{
indentWidth
}
+
{
alignIndent
}
+
{
treeBorderWidthVar
}
)
;
return
transparent
{
start
}
{
treeBorderColorVar
}
{
start
}
{
treeBorderColorVar
}
{
end
}
transparent
{
end
}
;
}
)
.
join
(
"
"
)
+
"
)
"
;
let
ariaExpanded
;
if
(
this
.
props
.
isExpandable
)
{
ariaExpanded
=
false
;
}
if
(
this
.
props
.
expanded
)
{
ariaExpanded
=
true
;
}
return
dom
.
div
(
{
id
className
:
"
tree
-
node
"
+
(
focused
?
"
focused
"
:
"
"
)
style
:
{
paddingInlineStart
backgroundImage
:
backgroundBorder
}
onClick
:
this
.
props
.
onClick
role
:
"
treeitem
"
"
aria
-
level
"
:
depth
"
aria
-
expanded
"
:
ariaExpanded
"
data
-
expandable
"
:
this
.
props
.
isExpandable
}
renderItem
(
item
depth
focused
arrow
expanded
)
)
;
}
}
)
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
const
Tree
=
createClass
(
{
displayName
:
"
Tree
"
propTypes
:
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
isExpanded
:
PropTypes
.
func
.
isRequired
focused
:
PropTypes
.
any
onFocus
:
PropTypes
.
func
autoExpandDepth
:
PropTypes
.
number
autoExpandAll
:
PropTypes
.
bool
labelledby
:
PropTypes
.
string
label
:
PropTypes
.
string
onExpand
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
isExpandable
:
PropTypes
.
func
className
:
PropTypes
.
string
style
:
PropTypes
.
object
}
getDefaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
autoExpandAll
:
true
}
;
}
getInitialState
(
)
{
return
{
seen
:
new
Set
(
)
}
;
}
componentDidMount
(
)
{
this
.
_autoExpand
(
)
;
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
)
;
}
_autoExpand
(
)
{
if
(
!
this
.
props
.
autoExpandDepth
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
if
(
currentDepth
>
=
this
.
props
.
autoExpandDepth
|
|
this
.
state
.
seen
.
has
(
item
)
)
{
return
;
}
this
.
props
.
onExpand
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
if
(
this
.
props
.
autoExpandAll
)
{
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
else
if
(
length
!
=
0
)
{
autoExpand
(
roots
[
0
]
0
)
;
}
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
:
oncePerAnimationFrame
(
function
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
)
_onCollapse
:
oncePerAnimationFrame
(
function
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
)
_focus
(
index
item
)
{
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_onBlur
(
)
{
this
.
_focus
(
0
undefined
)
;
}
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
_nodeIsExpandable
(
this
.
props
.
focused
)
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
}
}
_focusPrevNode
:
oncePerAnimationFrame
(
function
(
)
{
let
prev
;
let
prevIndex
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
prevIndex
=
i
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prevIndex
prev
)
;
}
)
_focusNextNode
:
oncePerAnimationFrame
(
function
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
i
+
1
traversal
[
i
+
1
]
.
item
)
;
}
}
)
_focusParentNode
:
oncePerAnimationFrame
(
function
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
return
;
}
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
parentIndex
=
0
;
for
(
;
parentIndex
<
length
;
parentIndex
+
+
)
{
if
(
traversal
[
parentIndex
]
.
item
=
=
=
parent
)
{
break
;
}
}
this
.
_focus
(
parentIndex
parent
)
;
}
)
_nodeIsExpandable
:
function
(
item
)
{
return
this
.
props
.
isExpandable
?
this
.
props
.
isExpandable
(
item
)
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
;
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
{
focused
}
=
this
.
props
;
const
nodes
=
traversal
.
map
(
(
v
i
)
=
>
{
const
{
item
depth
}
=
traversal
[
i
]
;
const
key
=
this
.
props
.
getKey
(
item
i
)
;
return
TreeNode
(
{
key
id
:
key
index
:
i
item
depth
renderItem
:
this
.
props
.
renderItem
focused
:
focused
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
isExpandable
:
this
.
_nodeIsExpandable
(
item
)
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onClick
:
e
=
>
{
this
.
_focus
(
i
item
)
;
if
(
this
.
props
.
isExpanded
(
item
)
)
{
this
.
props
.
onCollapse
(
item
)
;
}
else
{
this
.
props
.
onExpand
(
item
e
.
altKey
)
;
}
}
}
)
;
}
)
;
const
style
=
Object
.
assign
(
{
}
this
.
props
.
style
|
|
{
}
{
padding
:
0
margin
:
0
}
)
;
return
dom
.
div
(
{
className
:
tree
{
this
.
props
.
className
?
this
.
props
.
className
:
"
"
}
ref
:
"
tree
"
role
:
"
tree
"
tabIndex
:
"
0
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
onFocus
:
(
{
nativeEvent
}
)
=
>
{
if
(
focused
|
|
!
nativeEvent
|
|
!
this
.
refs
.
tree
)
{
return
;
}
let
{
explicitOriginalTarget
}
=
nativeEvent
;
if
(
explicitOriginalTarget
!
=
=
this
.
refs
.
tree
&
&
!
this
.
refs
.
tree
.
contains
(
explicitOriginalTarget
)
)
{
this
.
_focus
(
0
traversal
[
0
]
.
item
)
;
}
}
onBlur
:
this
.
_onBlur
onClick
:
(
)
=
>
{
this
.
refs
.
tree
.
focus
(
)
;
}
"
aria
-
label
"
:
this
.
props
.
label
"
aria
-
labelledby
"
:
this
.
props
.
labelledby
"
aria
-
activedescendant
"
:
focused
&
&
this
.
props
.
getKey
(
focused
)
style
}
nodes
)
;
}
}
)
;
exports
.
default
=
Tree
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
>
<
path
d
=
\
"
M8
13
.
4c
-
.
5
0
-
.
9
-
.
2
-
1
.
2
-
.
6L
.
4
5
.
2C0
4
.
7
-
.
1
4
.
3
.
2
3
.
7S1
3
1
.
6
3h12
.
8c
.
6
0
1
.
2
.
1
1
.
4
.
7
.
3
.
6
.
2
1
.
1
-
.
2
1
.
6l
-
6
.
4
7
.
6c
-
.
3
.
4
-
.
7
.
5
-
1
.
2
.
5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
)
(
function
(
module
exports
)
{
}
)
(
function
(
module
exports
)
{
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
)
{
'
use
strict
'
;
var
hasOwn
=
{
}
.
hasOwnProperty
;
function
classNames
(
)
{
var
classes
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
continue
;
var
argType
=
typeof
arg
;
if
(
argType
=
=
=
'
string
'
|
|
argType
=
=
=
'
number
'
)
{
classes
.
push
(
arg
)
;
}
else
if
(
Array
.
isArray
(
arg
)
)
{
classes
.
push
(
classNames
.
apply
(
null
arg
)
)
;
}
else
if
(
argType
=
=
=
'
object
'
)
{
for
(
var
key
in
arg
)
{
if
(
hasOwn
.
call
(
arg
key
)
&
&
arg
[
key
]
)
{
classes
.
push
(
key
)
;
}
}
}
}
return
classes
.
join
(
'
'
)
;
}
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
module
.
exports
=
classNames
;
}
else
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
]
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
classNames
;
}
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
window
.
classNames
=
classNames
;
}
}
(
)
)
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_49__
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
let
enumIndexedProperties
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
objectClient
start
end
)
{
try
{
const
{
iterator
}
=
yield
objectClient
.
enumProperties
(
{
ignoreNonIndexedProperties
:
true
}
)
;
const
response
=
yield
iteratorSlice
(
iterator
start
end
)
;
return
response
;
}
catch
(
e
)
{
console
.
error
(
"
Error
in
enumIndexedProperties
"
e
)
;
return
{
}
;
}
}
)
;
return
function
enumIndexedProperties
(
_x
_x2
_x3
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
enumNonIndexedProperties
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
objectClient
start
end
)
{
try
{
const
{
iterator
}
=
yield
objectClient
.
enumProperties
(
{
ignoreIndexedProperties
:
true
}
)
;
const
response
=
yield
iteratorSlice
(
iterator
start
end
)
;
return
response
;
}
catch
(
e
)
{
console
.
error
(
"
Error
in
enumNonIndexedProperties
"
e
)
;
return
{
}
;
}
}
)
;
return
function
enumNonIndexedProperties
(
_x4
_x5
_x6
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
enumEntries
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
objectClient
start
end
)
{
try
{
const
{
iterator
}
=
yield
objectClient
.
enumEntries
(
)
;
const
response
=
yield
iteratorSlice
(
iterator
start
end
)
;
return
response
;
}
catch
(
e
)
{
console
.
error
(
"
Error
in
enumEntries
"
e
)
;
return
{
}
;
}
}
)
;
return
function
enumEntries
(
_x7
_x8
_x9
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
enumSymbols
=
(
(
)
=
>
{
var
_ref4
=
_asyncToGenerator
(
function
*
(
objectClient
start
end
)
{
try
{
const
{
iterator
}
=
yield
objectClient
.
enumSymbols
(
)
;
const
response
=
yield
iteratorSlice
(
iterator
start
end
)
;
return
response
;
}
catch
(
e
)
{
console
.
error
(
"
Error
in
enumSymbols
"
e
)
;
return
{
}
;
}
}
)
;
return
function
enumSymbols
(
_x10
_x11
_x12
)
{
return
_ref4
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
let
getPrototype
=
(
(
)
=
>
{
var
_ref5
=
_asyncToGenerator
(
function
*
(
objectClient
)
{
if
(
typeof
objectClient
.
getPrototype
!
=
=
"
function
"
)
{
console
.
error
(
"
objectClient
.
getPrototype
is
not
a
function
"
)
;
return
Promise
.
resolve
(
{
}
)
;
}
return
objectClient
.
getPrototype
(
)
;
}
)
;
return
function
getPrototype
(
_x13
)
{
return
_ref5
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
function
iteratorSlice
(
iterator
start
end
)
{
start
=
start
|
|
0
;
const
count
=
end
?
end
-
start
+
1
:
iterator
.
count
;
return
iterator
.
slice
(
start
count
)
;
}
module
.
exports
=
{
enumEntries
enumIndexedProperties
enumNonIndexedProperties
enumSymbols
getPrototype
}
;
}
)
]
)
;
}
)
;
