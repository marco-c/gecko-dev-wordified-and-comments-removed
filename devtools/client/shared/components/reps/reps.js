(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
factory
)
;
else
{
var
a
=
typeof
exports
=
=
=
'
object
'
?
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
)
:
factory
(
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
this
function
(
__WEBPACK_EXTERNAL_MODULE_0__
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
{
return
installedModules
[
moduleId
]
.
exports
;
}
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
26
)
;
}
)
(
[
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_0__
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
validProtocols
=
/
^
(
http
|
https
|
ftp
|
data
|
javascript
|
resource
|
chrome
)
:
/
i
;
const
tokenSplitRegex
=
/
(
\
s
|
\
'
|
\
"
|
\
\
)
+
/
;
function
isGrip
(
object
)
{
return
object
&
&
object
.
actor
;
}
function
escapeNewLines
(
value
)
{
return
value
.
replace
(
/
\
r
/
gm
"
\
\
r
"
)
.
replace
(
/
\
n
/
gm
"
\
\
n
"
)
;
}
const
escapeMap
=
{
9
:
"
\
\
t
"
0xa
:
"
\
\
n
"
0xd
:
"
\
\
r
"
0x22
:
"
\
\
\
"
"
0x5c
:
"
\
\
\
\
"
}
;
const
escapeRegexp
=
new
RegExp
(
"
[
"
+
"
\
"
\
\
\
\
"
+
"
\
x00
-
\
x1f
"
+
"
\
x7f
-
\
x9f
"
+
"
\
ufeff
"
+
"
\
ufffc
-
\
uffff
"
+
"
\
ud800
-
\
udfff
"
+
"
\
u2061
-
\
u2064
"
+
"
\
u2028
-
\
u2029
"
+
"
\
ue000
-
\
uf8ff
"
+
"
]
"
"
g
"
)
;
function
escapeString
(
str
escapeWhitespace
)
{
return
"
\
"
"
+
str
.
replace
(
escapeRegexp
(
match
offset
)
=
>
{
let
c
=
match
.
charCodeAt
(
0
)
;
if
(
c
in
escapeMap
)
{
if
(
!
escapeWhitespace
&
&
(
c
=
=
=
9
|
|
c
=
=
=
0xa
|
|
c
=
=
=
0xd
)
)
{
return
match
[
0
]
;
}
return
escapeMap
[
c
]
;
}
if
(
c
>
=
0xd800
&
&
c
<
=
0xdfff
)
{
if
(
c
>
=
0xdc00
&
&
offset
>
0
)
{
-
-
offset
;
}
let
codePoint
=
str
.
codePointAt
(
offset
)
;
if
(
codePoint
>
=
0xd800
&
&
codePoint
<
=
0xdfff
)
{
return
"
\
\
u
"
+
codePoint
.
toString
(
16
)
;
}
else
if
(
codePoint
>
=
0xf0000
&
&
codePoint
<
=
0x10fffd
)
{
if
(
c
<
=
0xdbff
)
{
return
"
\
\
u
{
"
+
codePoint
.
toString
(
16
)
+
"
}
"
;
}
return
"
"
;
}
return
match
;
}
return
"
\
\
u
"
+
(
"
0000
"
+
c
.
toString
(
16
)
)
.
substr
(
-
4
)
;
}
)
+
"
\
"
"
;
}
function
maybeEscapePropertyName
(
name
)
{
if
(
!
/
^
\
w
+
/
.
test
(
name
)
)
{
name
=
escapeString
(
name
)
;
}
return
name
;
}
function
cropMultipleLines
(
text
limit
)
{
return
escapeNewLines
(
cropString
(
text
limit
)
)
;
}
function
rawCropString
(
text
limit
alternativeText
)
{
if
(
!
alternativeText
)
{
alternativeText
=
"
\
u2026
"
;
}
if
(
!
limit
|
|
limit
<
=
0
)
{
return
text
;
}
if
(
limit
<
=
alternativeText
.
length
)
{
limit
=
alternativeText
.
length
+
1
;
}
let
halfLimit
=
(
limit
-
alternativeText
.
length
)
/
2
;
if
(
text
.
length
>
limit
)
{
return
text
.
substr
(
0
Math
.
ceil
(
halfLimit
)
)
+
alternativeText
+
text
.
substr
(
text
.
length
-
Math
.
floor
(
halfLimit
)
)
;
}
return
text
;
}
function
cropString
(
text
limit
alternativeText
)
{
return
rawCropString
(
sanitizeString
(
text
+
"
"
)
limit
alternativeText
)
;
}
function
sanitizeString
(
text
)
{
let
re
=
new
RegExp
(
"
[
\
x00
-
\
x08
\
x0B
\
x0C
\
x0E
-
\
x1F
\
x7F
-
\
x9F
]
"
"
g
"
)
;
return
text
.
replace
(
re
"
\
ufffd
"
)
;
}
function
parseURLParams
(
url
)
{
url
=
new
URL
(
url
)
;
return
parseURLEncodedText
(
url
.
searchParams
)
;
}
function
parseURLEncodedText
(
text
)
{
let
params
=
[
]
;
if
(
text
=
=
"
"
)
{
return
params
;
}
let
searchParams
=
new
URLSearchParams
(
text
)
;
let
entries
=
[
.
.
.
searchParams
.
entries
(
)
]
;
return
entries
.
map
(
entry
=
>
{
return
{
name
:
entry
[
0
]
value
:
entry
[
1
]
}
;
}
)
;
}
function
getFileName
(
url
)
{
let
split
=
splitURLBase
(
url
)
;
return
split
.
name
;
}
function
splitURLBase
(
url
)
{
if
(
!
isDataURL
(
url
)
)
{
return
splitURLTrue
(
url
)
;
}
return
{
}
;
}
function
getURLDisplayString
(
url
)
{
return
cropString
(
url
)
;
}
function
isDataURL
(
url
)
{
return
url
&
&
url
.
substr
(
0
5
)
=
=
"
data
:
"
;
}
function
splitURLTrue
(
url
)
{
const
reSplitFile
=
/
(
.
*
?
)
:
\
/
{
2
3
}
(
[
^
\
/
]
*
)
(
.
*
?
)
(
[
^
\
/
]
*
?
)
(
|
\
?
.
*
)
/
;
let
m
=
reSplitFile
.
exec
(
url
)
;
if
(
!
m
)
{
return
{
name
:
url
path
:
url
}
;
}
else
if
(
m
[
4
]
=
=
"
"
&
&
m
[
5
]
=
=
"
"
)
{
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
3
]
name
:
m
[
3
]
!
=
"
/
"
?
m
[
3
]
:
m
[
2
]
}
;
}
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
2
]
+
m
[
3
]
name
:
m
[
4
]
+
m
[
5
]
}
;
}
function
wrapRender
(
renderMethod
)
{
const
wrappedFunction
=
function
(
props
)
{
try
{
return
renderMethod
.
call
(
this
props
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
return
React
.
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
failure
"
title
:
"
This
object
could
not
be
rendered
"
+
"
please
file
a
bug
on
bugzilla
.
mozilla
.
org
"
}
"
Invalid
object
"
)
;
}
}
;
wrappedFunction
.
propTypes
=
renderMethod
.
propTypes
;
return
wrappedFunction
;
}
function
getGripPreviewItems
(
grip
)
{
if
(
!
grip
)
{
return
[
]
;
}
if
(
grip
.
promiseState
&
&
grip
.
promiseState
.
value
)
{
return
[
grip
.
promiseState
.
value
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
items
)
{
return
grip
.
preview
.
items
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
childNodes
)
{
return
grip
.
preview
.
childNodes
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
entries
)
{
return
grip
.
preview
.
entries
.
reduce
(
(
res
entry
)
=
>
res
.
concat
(
entry
)
[
]
)
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
target
)
{
let
keys
=
Object
.
keys
(
grip
.
preview
.
properties
)
;
let
values
=
Object
.
values
(
grip
.
preview
.
properties
)
;
return
[
grip
.
preview
.
target
.
.
.
keys
.
.
.
values
]
;
}
if
(
grip
.
displayString
)
{
return
[
grip
.
displayString
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
ownProperties
)
{
let
propertiesValues
=
Object
.
values
(
grip
.
preview
.
ownProperties
)
.
map
(
property
=
>
property
.
value
|
|
property
)
;
let
propertyKeys
=
Object
.
keys
(
grip
.
preview
.
ownProperties
)
;
propertiesValues
=
propertiesValues
.
concat
(
propertyKeys
)
;
if
(
grip
.
preview
.
safeGetterValues
)
{
propertiesValues
=
propertiesValues
.
concat
(
Object
.
values
(
grip
.
preview
.
safeGetterValues
)
.
map
(
property
=
>
property
.
getterValue
|
|
property
)
)
;
}
return
propertiesValues
;
}
return
[
]
;
}
function
getGripType
(
object
noGrip
)
{
let
type
=
typeof
object
;
if
(
type
=
=
"
object
"
&
&
object
instanceof
String
)
{
type
=
"
string
"
;
}
else
if
(
object
&
&
type
=
=
"
object
"
&
&
object
.
type
&
&
noGrip
!
=
=
true
)
{
type
=
object
.
type
;
}
if
(
isGrip
(
object
)
)
{
type
=
object
.
class
;
}
return
type
;
}
function
containsURL
(
grip
)
{
if
(
typeof
grip
!
=
=
"
string
"
)
{
return
false
;
}
let
tokens
=
grip
.
split
(
tokenSplitRegex
)
;
return
tokens
.
some
(
isURL
)
;
}
function
isURL
(
token
)
{
try
{
if
(
!
validProtocols
.
test
(
token
)
)
{
return
false
;
}
new
URL
(
token
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
module
.
exports
=
{
isGrip
isURL
cropString
containsURL
rawCropString
sanitizeString
escapeString
wrapRender
cropMultipleLines
parseURLParams
parseURLEncodedText
getFileName
getURLDisplayString
maybeEscapePropertyName
getGripPreviewItems
getGripType
tokenSplitRegex
}
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
{
MODE
:
{
TINY
:
Symbol
(
"
TINY
"
)
SHORT
:
Symbol
(
"
SHORT
"
)
LONG
:
Symbol
(
"
LONG
"
)
}
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
__webpack_require__
(
27
)
;
const
Undefined
=
__webpack_require__
(
28
)
;
const
Null
=
__webpack_require__
(
29
)
;
const
StringRep
=
__webpack_require__
(
16
)
;
const
LongStringRep
=
__webpack_require__
(
30
)
;
const
Number
=
__webpack_require__
(
31
)
;
const
ArrayRep
=
__webpack_require__
(
17
)
;
const
Obj
=
__webpack_require__
(
32
)
;
const
SymbolRep
=
__webpack_require__
(
33
)
;
const
InfinityRep
=
__webpack_require__
(
34
)
;
const
NaNRep
=
__webpack_require__
(
35
)
;
const
Accessor
=
__webpack_require__
(
36
)
;
const
Attribute
=
__webpack_require__
(
37
)
;
const
DateTime
=
__webpack_require__
(
38
)
;
const
Document
=
__webpack_require__
(
39
)
;
const
Event
=
__webpack_require__
(
40
)
;
const
Func
=
__webpack_require__
(
41
)
;
const
PromiseRep
=
__webpack_require__
(
42
)
;
const
RegExp
=
__webpack_require__
(
43
)
;
const
StyleSheet
=
__webpack_require__
(
44
)
;
const
CommentNode
=
__webpack_require__
(
45
)
;
const
ElementNode
=
__webpack_require__
(
46
)
;
const
TextNode
=
__webpack_require__
(
50
)
;
const
ErrorRep
=
__webpack_require__
(
51
)
;
const
Window
=
__webpack_require__
(
52
)
;
const
ObjectWithText
=
__webpack_require__
(
53
)
;
const
ObjectWithURL
=
__webpack_require__
(
54
)
;
const
GripArray
=
__webpack_require__
(
19
)
;
const
GripMap
=
__webpack_require__
(
55
)
;
const
GripMapEntry
=
__webpack_require__
(
20
)
;
const
Grip
=
__webpack_require__
(
9
)
;
let
reps
=
[
RegExp
StyleSheet
Event
DateTime
CommentNode
ElementNode
TextNode
Attribute
LongStringRep
Func
PromiseRep
ArrayRep
Document
Window
ObjectWithText
ObjectWithURL
ErrorRep
GripArray
GripMap
GripMapEntry
Grip
Undefined
Null
StringRep
Number
SymbolRep
InfinityRep
NaNRep
Accessor
]
;
const
Rep
=
function
(
props
)
{
let
{
object
defaultRep
}
=
props
;
let
rep
=
getRep
(
object
defaultRep
props
.
noGrip
)
;
return
rep
(
props
)
;
}
;
function
getRep
(
object
defaultRep
=
Obj
noGrip
=
false
)
{
for
(
let
i
=
0
;
i
<
reps
.
length
;
i
+
+
)
{
let
rep
=
reps
[
i
]
;
try
{
if
(
rep
.
supportsObject
(
object
noGrip
)
)
{
return
rep
.
rep
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
}
return
defaultRep
.
rep
;
}
module
.
exports
=
{
Rep
REPS
:
{
Accessor
ArrayRep
Attribute
CommentNode
DateTime
Document
ElementNode
ErrorRep
Event
Func
Grip
GripArray
GripMap
GripMapEntry
InfinityRep
LongStringRep
NaNRep
Null
Number
Obj
ObjectWithText
ObjectWithURL
PromiseRep
RegExp
Rep
StringRep
StyleSheet
SymbolRep
TextNode
Undefined
Window
}
getRep
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
maybeEscapePropertyName
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
PropRep
.
propTypes
=
{
name
:
React
.
PropTypes
.
oneOfType
(
[
React
.
PropTypes
.
string
React
.
PropTypes
.
object
]
)
.
isRequired
equal
:
React
.
PropTypes
.
string
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
suppressQuotes
:
React
.
PropTypes
.
bool
}
;
function
PropRep
(
props
)
{
const
Grip
=
__webpack_require__
(
9
)
;
const
{
Rep
}
=
__webpack_require__
(
3
)
;
let
{
name
mode
equal
suppressQuotes
}
=
props
;
let
key
;
if
(
typeof
name
=
=
=
"
string
"
)
{
if
(
!
suppressQuotes
)
{
name
=
maybeEscapePropertyName
(
name
)
;
}
key
=
span
(
{
"
className
"
:
"
nodeName
"
}
name
)
;
}
else
{
key
=
Rep
(
Object
.
assign
(
{
}
props
{
className
:
"
nodeName
"
object
:
name
mode
:
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
)
;
}
return
[
key
span
(
{
"
className
"
:
"
objectEqual
"
}
equal
)
Rep
(
Object
.
assign
(
{
}
props
)
)
]
;
}
module
.
exports
=
wrapRender
(
PropRep
)
;
}
)
(
function
(
module
exports
)
{
var
isArray
=
Array
.
isArray
;
module
.
exports
=
isArray
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
23
)
;
var
nativeCreate
=
getNative
(
Object
'
create
'
)
;
module
.
exports
=
nativeCreate
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
eq
=
__webpack_require__
(
88
)
;
function
assocIndexOf
(
array
key
)
{
var
length
=
array
.
length
;
while
(
length
-
-
)
{
if
(
eq
(
array
[
length
]
[
0
]
key
)
)
{
return
length
;
}
}
return
-
1
;
}
module
.
exports
=
assocIndexOf
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
isKeyable
=
__webpack_require__
(
94
)
;
function
getMapData
(
map
key
)
{
var
data
=
map
.
__data__
;
return
isKeyable
(
key
)
?
data
[
typeof
key
=
=
'
string
'
?
'
string
'
:
'
hash
'
]
:
data
.
map
;
}
module
.
exports
=
getMapData
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
GripRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
isInterestingProp
:
React
.
PropTypes
.
func
title
:
React
.
PropTypes
.
string
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
noGrip
:
React
.
PropTypes
.
bool
}
;
const
DEFAULT_TITLE
=
"
Object
"
;
function
GripRep
(
props
)
{
let
{
mode
=
MODE
.
SHORT
object
}
=
props
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
propertiesLength
=
getPropertiesLength
(
object
)
;
const
tinyModeItems
=
[
]
;
if
(
getTitle
(
props
object
)
!
=
=
DEFAULT_TITLE
)
{
tinyModeItems
.
push
(
getTitleElement
(
props
object
)
)
;
}
else
{
tinyModeItems
.
push
(
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
propertiesLength
>
0
?
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
:
null
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
return
span
(
config
.
.
.
tinyModeItems
)
;
}
let
propsArray
=
safePropIterator
(
props
object
maxLengthMap
.
get
(
mode
)
)
;
return
span
(
config
getTitleElement
(
props
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitleElement
(
props
object
)
{
return
span
(
{
className
:
"
objectTitle
"
}
getTitle
(
props
object
)
)
;
}
function
getTitle
(
props
object
)
{
return
props
.
title
|
|
object
.
class
|
|
DEFAULT_TITLE
;
}
function
getPropertiesLength
(
object
)
{
let
propertiesLength
=
object
.
preview
&
&
object
.
preview
.
ownPropertiesLength
?
object
.
preview
.
ownPropertiesLength
:
object
.
ownPropertyLength
;
if
(
object
.
preview
&
&
object
.
preview
.
safeGetterValues
)
{
propertiesLength
+
=
Object
.
keys
(
object
.
preview
.
safeGetterValues
)
.
length
;
}
if
(
object
.
preview
&
&
object
.
preview
.
ownSymbols
)
{
propertiesLength
+
=
object
.
preview
.
ownSymbolsLength
;
}
return
propertiesLength
;
}
function
safePropIterator
(
props
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
maxLengthMap
.
get
(
MODE
.
SHORT
)
:
max
;
try
{
return
propIterator
(
props
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
function
propIterator
(
props
object
max
)
{
if
(
object
.
preview
&
&
Object
.
keys
(
object
.
preview
)
.
includes
(
"
wrappedValue
"
)
)
{
const
{
Rep
}
=
__webpack_require__
(
3
)
;
return
[
Rep
(
{
object
:
object
.
preview
.
wrappedValue
mode
:
props
.
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
]
;
}
let
isInterestingProp
=
props
.
isInterestingProp
|
|
(
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
.
length
!
=
0
;
}
)
;
let
properties
=
object
.
preview
?
object
.
preview
.
ownProperties
:
{
}
;
let
propertiesLength
=
getPropertiesLength
(
object
)
;
if
(
object
.
preview
&
&
object
.
preview
.
safeGetterValues
)
{
properties
=
Object
.
assign
(
{
}
properties
object
.
preview
.
safeGetterValues
)
;
}
let
indexes
=
getPropIndexes
(
properties
max
isInterestingProp
)
;
if
(
indexes
.
length
<
max
&
&
indexes
.
length
<
propertiesLength
)
{
indexes
=
indexes
.
concat
(
getPropIndexes
(
properties
max
-
indexes
.
length
(
t
value
name
)
=
>
{
return
!
isInterestingProp
(
t
value
name
)
;
}
)
)
;
}
const
suppressQuotes
=
object
.
class
=
=
=
"
Proxy
"
;
let
propsArray
=
getProps
(
props
properties
indexes
suppressQuotes
)
;
if
(
object
.
preview
&
&
object
.
preview
.
ownSymbols
)
{
const
{
ownSymbols
}
=
object
.
preview
;
const
length
=
max
-
indexes
.
length
;
const
symbolsProps
=
ownSymbols
.
slice
(
0
length
)
.
map
(
symbolItem
=
>
{
return
PropRep
(
Object
.
assign
(
{
}
props
{
mode
:
MODE
.
TINY
name
:
symbolItem
object
:
symbolItem
.
descriptor
.
value
equal
:
"
:
"
defaultRep
:
Grip
title
:
null
suppressQuotes
}
)
)
;
}
)
;
propsArray
.
push
(
.
.
.
symbolsProps
)
;
}
if
(
Object
.
keys
(
properties
)
.
length
>
max
|
|
propertiesLength
>
max
|
|
propertiesLength
>
propsArray
.
length
)
{
propsArray
.
push
(
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
unfoldProps
(
propsArray
)
;
}
function
unfoldProps
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
Array
.
isArray
(
item
)
)
{
res
=
res
.
concat
(
item
)
;
}
else
{
res
.
push
(
item
)
;
}
if
(
index
!
=
=
items
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
getProps
(
componentProps
properties
indexes
suppressQuotes
)
{
indexes
.
sort
(
function
(
a
b
)
{
return
a
-
b
;
}
)
;
const
propertiesKeys
=
Object
.
keys
(
properties
)
;
return
indexes
.
map
(
i
=
>
{
let
name
=
propertiesKeys
[
i
]
;
let
value
=
getPropValue
(
properties
[
name
]
)
;
return
PropRep
(
Object
.
assign
(
{
}
componentProps
{
mode
:
MODE
.
TINY
name
object
:
value
equal
:
"
:
"
defaultRep
:
Grip
title
:
null
suppressQuotes
}
)
)
;
}
)
;
}
function
getPropIndexes
(
properties
max
filter
)
{
let
indexes
=
[
]
;
try
{
let
i
=
0
;
for
(
let
name
in
properties
)
{
if
(
indexes
.
length
>
=
max
)
{
return
indexes
;
}
let
value
=
getPropValue
(
properties
[
name
]
)
;
let
type
=
value
.
class
|
|
typeof
value
;
type
=
type
.
toLowerCase
(
)
;
if
(
filter
(
type
value
name
)
)
{
indexes
.
push
(
i
)
;
}
i
+
+
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
indexes
;
}
function
getPropValue
(
property
)
{
let
value
=
property
;
if
(
typeof
property
=
=
=
"
object
"
)
{
let
keys
=
Object
.
keys
(
property
)
;
if
(
keys
.
includes
(
"
value
"
)
)
{
value
=
property
.
value
;
}
else
if
(
keys
.
includes
(
"
getterValue
"
)
)
{
value
=
property
.
getterValue
;
}
}
return
value
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
?
typeof
object
.
preview
.
ownProperties
!
=
=
"
undefined
"
:
typeof
object
.
ownPropertyLength
!
=
=
"
undefined
"
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
let
Grip
=
{
rep
:
wrapRender
(
GripRep
)
supportsObject
maxLengthMap
}
;
module
.
exports
=
Grip
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
InlineSVG
=
__webpack_require__
(
47
)
;
const
svg
=
{
"
arrow
"
:
__webpack_require__
(
48
)
"
open
-
inspector
"
:
__webpack_require__
(
49
)
}
;
Svg
.
propTypes
=
{
className
:
React
.
PropTypes
.
string
}
;
function
Svg
(
name
props
)
{
if
(
!
svg
[
name
]
)
{
throw
new
Error
(
"
Unknown
SVG
:
"
+
name
)
;
}
let
className
=
name
;
if
(
props
&
&
props
.
className
)
{
className
=
{
name
}
{
props
.
className
}
;
}
if
(
name
=
=
=
"
subSettings
"
)
{
className
=
"
"
;
}
props
=
Object
.
assign
(
{
}
props
{
className
src
:
svg
[
name
]
}
)
;
return
React
.
createElement
(
InlineSVG
props
)
;
}
module
.
exports
=
Svg
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseGetTag
=
__webpack_require__
(
12
)
isObjectLike
=
__webpack_require__
(
15
)
;
var
symbolTag
=
'
[
object
Symbol
]
'
;
function
isSymbol
(
value
)
{
return
typeof
value
=
=
'
symbol
'
|
|
(
isObjectLike
(
value
)
&
&
baseGetTag
(
value
)
=
=
symbolTag
)
;
}
module
.
exports
=
isSymbol
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
13
)
getRawTag
=
__webpack_require__
(
66
)
objectToString
=
__webpack_require__
(
67
)
;
var
nullTag
=
'
[
object
Null
]
'
undefinedTag
=
'
[
object
Undefined
]
'
;
var
symToStringTag
=
Symbol
?
Symbol
.
toStringTag
:
undefined
;
function
baseGetTag
(
value
)
{
if
(
value
=
=
null
)
{
return
value
=
=
=
undefined
?
undefinedTag
:
nullTag
;
}
return
(
symToStringTag
&
&
symToStringTag
in
Object
(
value
)
)
?
getRawTag
(
value
)
:
objectToString
(
value
)
;
}
module
.
exports
=
baseGetTag
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
14
)
;
var
Symbol
=
root
.
Symbol
;
module
.
exports
=
Symbol
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
freeGlobal
=
__webpack_require__
(
64
)
;
var
freeSelf
=
typeof
self
=
=
'
object
'
&
&
self
&
&
self
.
Object
=
=
=
Object
&
&
self
;
var
root
=
freeGlobal
|
|
freeSelf
|
|
Function
(
'
return
this
'
)
(
)
;
module
.
exports
=
root
;
}
)
(
function
(
module
exports
)
{
function
isObjectLike
(
value
)
{
return
value
!
=
null
&
&
typeof
value
=
=
'
object
'
;
}
module
.
exports
=
isObjectLike
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
containsURL
isURL
escapeString
getGripType
rawCropString
sanitizeString
wrapRender
tokenSplitRegex
}
=
__webpack_require__
(
1
)
;
const
{
a
span
}
=
React
.
DOM
;
StringRep
.
propTypes
=
{
useQuotes
:
React
.
PropTypes
.
bool
escapeWhitespace
:
React
.
PropTypes
.
bool
style
:
React
.
PropTypes
.
object
object
:
React
.
PropTypes
.
string
.
isRequired
member
:
React
.
PropTypes
.
any
cropLimit
:
React
.
PropTypes
.
number
openLink
:
React
.
PropTypes
.
func
}
;
function
StringRep
(
props
)
{
let
{
cropLimit
object
:
text
member
style
useQuotes
=
true
escapeWhitespace
=
true
openLink
}
=
props
;
let
config
=
{
className
:
"
objectBox
objectBox
-
string
"
}
;
if
(
style
)
{
config
.
style
=
style
;
}
if
(
useQuotes
)
{
text
=
escapeString
(
text
escapeWhitespace
)
;
}
else
{
text
=
sanitizeString
(
text
)
;
}
if
(
(
!
member
|
|
!
member
.
open
)
&
&
cropLimit
)
{
text
=
rawCropString
(
text
cropLimit
)
;
}
if
(
!
containsURL
(
text
)
)
{
return
span
(
config
text
)
;
}
const
items
=
[
]
;
let
tokens
=
text
.
split
(
tokenSplitRegex
)
;
let
textIndex
=
0
;
let
tokenStart
;
tokens
.
forEach
(
(
token
i
)
=
>
{
tokenStart
=
text
.
indexOf
(
token
textIndex
)
;
if
(
isURL
(
token
)
)
{
items
.
push
(
text
.
slice
(
textIndex
tokenStart
)
)
;
textIndex
=
tokenStart
+
token
.
length
;
items
.
push
(
a
(
{
className
:
"
url
"
title
:
token
href
:
token
draggable
:
false
onClick
:
openLink
?
e
=
>
{
e
.
preventDefault
(
)
;
openLink
(
token
)
;
}
:
null
}
token
)
)
;
}
}
)
;
items
.
push
(
text
.
slice
(
textIndex
text
.
length
)
)
;
return
span
(
config
.
.
.
items
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
getGripType
(
object
noGrip
)
=
=
"
string
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
StringRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
ModePropType
=
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
;
const
DOM
=
React
.
DOM
;
ArrayRep
.
propTypes
=
{
mode
:
ModePropType
object
:
React
.
PropTypes
.
array
.
isRequired
}
;
function
ArrayRep
(
props
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
props
;
let
items
;
let
brackets
;
let
needSpace
=
function
(
space
)
{
return
space
?
{
left
:
"
[
"
right
:
"
]
"
}
:
{
left
:
"
[
"
right
:
"
]
"
}
;
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
isEmpty
=
object
.
length
=
=
=
0
;
if
(
isEmpty
)
{
items
=
[
]
;
}
else
{
items
=
[
DOM
.
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
]
;
}
brackets
=
needSpace
(
false
)
;
}
else
{
items
=
arrayIterator
(
props
object
maxLengthMap
.
get
(
mode
)
)
;
brackets
=
needSpace
(
items
.
length
>
0
)
;
}
return
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
array
"
}
DOM
.
span
(
{
className
:
"
arrayLeftBracket
"
}
brackets
.
left
)
.
.
.
items
DOM
.
span
(
{
className
:
"
arrayRightBracket
"
}
brackets
.
right
)
DOM
.
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
;
}
function
arrayIterator
(
props
array
max
)
{
let
items
=
[
]
;
for
(
let
i
=
0
;
i
<
array
.
length
&
&
i
<
max
;
i
+
+
)
{
let
config
=
{
mode
:
MODE
.
TINY
delim
:
i
=
=
array
.
length
-
1
?
"
"
:
"
"
}
;
let
item
;
try
{
item
=
ItemRep
(
Object
.
assign
(
{
}
props
config
{
object
:
array
[
i
]
}
)
)
;
}
catch
(
exc
)
{
item
=
ItemRep
(
Object
.
assign
(
{
}
props
config
{
object
:
exc
}
)
)
;
}
items
.
push
(
item
)
;
}
if
(
array
.
length
>
max
)
{
items
.
push
(
DOM
.
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
items
;
}
ItemRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
any
.
isRequired
delim
:
React
.
PropTypes
.
string
.
isRequired
mode
:
ModePropType
}
;
function
ItemRep
(
props
)
{
const
{
Rep
}
=
__webpack_require__
(
3
)
;
let
{
object
delim
mode
}
=
props
;
return
DOM
.
span
(
{
}
Rep
(
Object
.
assign
(
{
}
props
{
object
:
object
mode
:
mode
}
)
)
delim
)
;
}
function
supportsObject
(
object
)
{
return
Array
.
isArray
(
object
)
|
|
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Arguments
]
"
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
module
.
exports
=
{
rep
:
wrapRender
(
ArrayRep
)
supportsObject
maxLengthMap
}
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
{
ELEMENT_NODE
:
1
ATTRIBUTE_NODE
:
2
TEXT_NODE
:
3
CDATA_SECTION_NODE
:
4
ENTITY_REFERENCE_NODE
:
5
ENTITY_NODE
:
6
PROCESSING_INSTRUCTION_NODE
:
7
COMMENT_NODE
:
8
DOCUMENT_NODE
:
9
DOCUMENT_TYPE_NODE
:
10
DOCUMENT_FRAGMENT_NODE
:
11
NOTATION_NODE
:
12
DOCUMENT_POSITION_DISCONNECTED
:
0x01
DOCUMENT_POSITION_PRECEDING
:
0x02
DOCUMENT_POSITION_FOLLOWING
:
0x04
DOCUMENT_POSITION_CONTAINS
:
0x08
DOCUMENT_POSITION_CONTAINED_BY
:
0x10
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
:
0x20
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
GripArray
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
provider
:
React
.
PropTypes
.
object
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
GripArray
(
props
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
props
;
let
items
;
let
brackets
;
let
needSpace
=
function
(
space
)
{
return
space
?
{
left
:
"
[
"
right
:
"
]
"
}
:
{
left
:
"
[
"
right
:
"
]
"
}
;
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
objectLength
=
getLength
(
object
)
;
let
isEmpty
=
objectLength
=
=
=
0
;
if
(
isEmpty
)
{
items
=
[
]
;
}
else
{
items
=
[
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
]
;
}
brackets
=
needSpace
(
false
)
;
}
else
{
let
max
=
maxLengthMap
.
get
(
mode
)
;
items
=
arrayIterator
(
props
object
max
)
;
brackets
=
needSpace
(
items
.
length
>
0
)
;
}
let
title
=
getTitle
(
props
object
)
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
array
"
}
title
span
(
{
className
:
"
arrayLeftBracket
"
}
brackets
.
left
)
.
.
.
interleaveCommas
(
items
)
span
(
{
className
:
"
arrayRightBracket
"
}
brackets
.
right
)
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
;
}
function
interleaveCommas
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
index
!
=
=
items
.
length
-
1
)
{
return
res
.
concat
(
item
"
"
)
;
}
return
res
.
concat
(
item
)
;
}
[
]
)
;
}
function
getLength
(
grip
)
{
if
(
!
grip
.
preview
)
{
return
0
;
}
return
grip
.
preview
.
length
|
|
grip
.
preview
.
childNodesLength
|
|
0
;
}
function
getTitle
(
props
object
)
{
if
(
props
.
mode
=
=
=
MODE
.
TINY
)
{
return
"
"
;
}
let
title
=
props
.
title
|
|
object
.
class
|
|
"
Array
"
;
return
span
(
{
className
:
"
objectTitle
"
}
title
+
"
"
)
;
}
function
getPreviewItems
(
grip
)
{
if
(
!
grip
.
preview
)
{
return
null
;
}
return
grip
.
preview
.
items
|
|
grip
.
preview
.
childNodes
|
|
[
]
;
}
function
arrayIterator
(
props
grip
max
)
{
let
{
Rep
}
=
__webpack_require__
(
3
)
;
let
items
=
[
]
;
const
gripLength
=
getLength
(
grip
)
;
if
(
!
gripLength
)
{
return
items
;
}
const
previewItems
=
getPreviewItems
(
grip
)
;
let
provider
=
props
.
provider
;
let
emptySlots
=
0
;
let
foldedEmptySlots
=
0
;
items
=
previewItems
.
reduce
(
(
res
itemGrip
)
=
>
{
if
(
res
.
length
>
=
max
)
{
return
res
;
}
let
object
;
try
{
if
(
!
provider
&
&
itemGrip
=
=
=
null
)
{
emptySlots
+
+
;
return
res
;
}
object
=
provider
?
provider
.
getValue
(
itemGrip
)
:
itemGrip
;
}
catch
(
exc
)
{
object
=
exc
;
}
if
(
emptySlots
>
0
)
{
res
.
push
(
getEmptySlotsElement
(
emptySlots
)
)
;
foldedEmptySlots
=
foldedEmptySlots
+
emptySlots
-
1
;
emptySlots
=
0
;
}
if
(
res
.
length
<
max
)
{
res
.
push
(
Rep
(
Object
.
assign
(
{
}
props
{
object
mode
:
MODE
.
TINY
title
:
undefined
}
)
)
)
;
}
return
res
;
}
[
]
)
;
if
(
items
.
length
<
max
&
&
emptySlots
>
0
)
{
items
.
push
(
getEmptySlotsElement
(
emptySlots
)
)
;
foldedEmptySlots
=
foldedEmptySlots
+
emptySlots
-
1
;
}
const
itemsShown
=
items
.
length
+
foldedEmptySlots
;
if
(
gripLength
>
itemsShown
)
{
items
.
push
(
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
items
;
}
function
getEmptySlotsElement
(
number
)
{
return
<
{
number
}
empty
slot
{
number
>
1
?
"
s
"
:
"
"
}
>
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
(
grip
.
preview
.
kind
=
=
"
ArrayLike
"
|
|
getGripType
(
grip
noGrip
)
=
=
=
"
DocumentFragment
"
)
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
module
.
exports
=
{
rep
:
wrapRender
(
GripArray
)
supportsObject
maxLengthMap
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
span
}
=
React
.
DOM
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
GripMapEntry
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
GripMapEntry
(
props
)
{
const
{
object
}
=
props
;
const
{
key
value
}
=
object
.
preview
;
return
span
(
{
className
:
"
objectBox
objectBox
-
map
-
entry
"
}
.
.
.
PropRep
(
Object
.
assign
(
{
}
props
{
name
:
key
object
:
value
equal
:
"
\
u2192
"
title
:
null
suppressQuotes
:
false
}
)
)
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
)
{
return
false
;
}
return
grip
&
&
grip
.
type
=
=
=
"
mapEntry
"
&
&
grip
.
preview
;
}
function
createGripMapEntry
(
key
value
)
{
return
{
type
:
"
mapEntry
"
preview
:
{
key
value
}
}
;
}
module
.
exports
=
{
rep
:
wrapRender
(
GripMapEntry
)
createGripMapEntry
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
get
=
__webpack_require__
(
61
)
;
const
has
=
__webpack_require__
(
101
)
;
const
{
maybeEscapePropertyName
}
=
__webpack_require__
(
1
)
;
const
ArrayRep
=
__webpack_require__
(
17
)
;
const
GripArrayRep
=
__webpack_require__
(
19
)
;
const
GripMapEntryRep
=
__webpack_require__
(
20
)
;
const
NODE_TYPES
=
{
BUCKET
:
Symbol
(
"
[
n
n
]
"
)
DEFAULT_PROPERTIES
:
Symbol
(
"
[
default
properties
]
"
)
ENTRIES
:
Symbol
(
"
<
entries
>
"
)
GET
:
Symbol
(
"
<
get
>
"
)
GRIP
:
Symbol
(
"
GRIP
"
)
MAP_ENTRY_KEY
:
Symbol
(
"
<
key
>
"
)
MAP_ENTRY_VALUE
:
Symbol
(
"
<
value
>
"
)
PROMISE_REASON
:
Symbol
(
"
<
reason
>
"
)
PROMISE_STATE
:
Symbol
(
"
<
state
>
"
)
PROMISE_VALUE
:
Symbol
(
"
<
value
>
"
)
SET
:
Symbol
(
"
<
set
>
"
)
PROTOTYPE
:
Symbol
(
"
__proto__
"
)
}
;
let
WINDOW_PROPERTIES
=
{
}
;
if
(
typeof
window
=
=
=
"
object
"
)
{
WINDOW_PROPERTIES
=
Object
.
getOwnPropertyNames
(
window
)
;
}
const
SAFE_PATH_PREFIX
=
"
#
#
-
"
;
function
getType
(
item
)
{
return
item
.
type
;
}
function
getValue
(
item
)
{
if
(
has
(
item
"
contents
.
value
"
)
)
{
return
get
(
item
"
contents
.
value
"
)
;
}
if
(
has
(
item
"
contents
.
getterValue
"
)
)
{
return
get
(
item
"
contents
.
getterValue
"
undefined
)
;
}
if
(
nodeHasAccessors
(
item
)
)
{
return
item
.
contents
;
}
return
undefined
;
}
function
nodeIsBucket
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
BUCKET
;
}
function
nodeIsEntries
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
ENTRIES
;
}
function
nodeIsMapEntry
(
item
)
{
return
GripMapEntryRep
.
supportsObject
(
getValue
(
item
)
)
;
}
function
nodeHasChildren
(
item
)
{
return
Array
.
isArray
(
item
.
contents
)
|
|
nodeIsBucket
(
item
)
;
}
function
nodeIsObject
(
item
)
{
const
value
=
getValue
(
item
)
;
return
value
&
&
value
.
type
=
=
=
"
object
"
;
}
function
nodeIsArrayLike
(
item
)
{
const
value
=
getValue
(
item
)
;
return
GripArrayRep
.
supportsObject
(
value
)
|
|
ArrayRep
.
supportsObject
(
value
)
;
}
function
nodeIsFunction
(
item
)
{
const
value
=
getValue
(
item
)
;
return
value
&
&
value
.
class
=
=
=
"
Function
"
;
}
function
nodeIsOptimizedOut
(
item
)
{
const
value
=
getValue
(
item
)
;
return
!
nodeHasChildren
(
item
)
&
&
value
&
&
value
.
optimizedOut
;
}
function
nodeIsMissingArguments
(
item
)
{
const
value
=
getValue
(
item
)
;
return
!
nodeHasChildren
(
item
)
&
&
value
&
&
value
.
missingArguments
;
}
function
nodeHasProperties
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
nodeIsObject
(
item
)
;
}
function
nodeIsPrimitive
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
!
nodeHasProperties
(
item
)
&
&
!
nodeIsEntries
(
item
)
&
&
!
nodeIsMapEntry
(
item
)
&
&
!
nodeHasAccessors
(
item
)
;
}
function
nodeIsDefaultProperties
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
DEFAULT_PROPERTIES
;
}
function
isDefaultWindowProperty
(
name
)
{
return
WINDOW_PROPERTIES
.
includes
(
name
)
;
}
function
nodeIsPromise
(
item
)
{
const
value
=
getValue
(
item
)
;
if
(
!
value
)
{
return
false
;
}
return
value
.
class
=
=
"
Promise
"
;
}
function
nodeIsPrototype
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
PROTOTYPE
;
}
function
nodeIsWindow
(
item
)
{
const
value
=
getValue
(
item
)
;
if
(
!
value
)
{
return
false
;
}
return
value
.
class
=
=
"
Window
"
;
}
function
nodeIsGetter
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
GET
;
}
function
nodeIsSetter
(
item
)
{
return
getType
(
item
)
=
=
=
NODE_TYPES
.
SET
;
}
function
nodeHasAccessors
(
item
)
{
return
!
!
getNodeGetter
(
item
)
|
|
!
!
getNodeSetter
(
item
)
;
}
function
nodeSupportsBucketing
(
item
)
{
return
nodeIsArrayLike
(
item
)
|
|
nodeIsEntries
(
item
)
;
}
function
nodeHasEntries
(
item
)
{
const
value
=
getValue
(
item
)
;
if
(
!
value
)
{
return
false
;
}
return
value
.
class
=
=
=
"
Map
"
|
|
value
.
class
=
=
=
"
Set
"
|
|
value
.
class
=
=
=
"
WeakMap
"
|
|
value
.
class
=
=
=
"
WeakSet
"
;
}
function
nodeHasAllEntriesInPreview
(
item
)
{
const
{
preview
}
=
getValue
(
item
)
|
|
{
}
;
if
(
!
preview
)
{
return
false
;
}
const
{
entries
items
length
size
}
=
preview
;
return
entries
?
entries
.
length
=
=
=
size
:
items
.
length
=
=
=
length
;
}
function
makeNodesForPromiseProperties
(
item
)
{
const
{
promiseState
:
{
reason
value
state
}
}
=
getValue
(
item
)
;
const
properties
=
[
]
;
if
(
state
)
{
properties
.
push
(
createNode
(
item
"
<
state
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
state
{
value
:
state
}
NODE_TYPES
.
PROMISE_STATE
)
)
;
}
if
(
reason
)
{
properties
.
push
(
createNode
(
item
"
<
reason
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
reason
{
value
:
reason
}
NODE_TYPES
.
PROMISE_REASON
)
)
;
}
if
(
value
)
{
properties
.
push
(
createNode
(
item
"
<
value
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
value
{
value
:
value
}
NODE_TYPES
.
PROMISE_VALUE
)
)
;
}
return
properties
;
}
function
makeNodesForEntries
(
item
)
{
const
{
path
}
=
item
;
const
{
preview
}
=
getValue
(
item
)
;
const
nodeName
=
"
<
entries
>
"
;
const
entriesPath
=
{
path
}
/
{
SAFE_PATH_PREFIX
}
entries
;
if
(
nodeHasAllEntriesInPreview
(
item
)
)
{
let
entriesNodes
=
[
]
;
if
(
preview
.
entries
)
{
entriesNodes
=
preview
.
entries
.
map
(
(
[
key
value
]
index
)
=
>
{
return
createNode
(
item
index
{
entriesPath
}
/
{
index
}
{
value
:
GripMapEntryRep
.
createGripMapEntry
(
key
value
)
}
)
;
}
)
;
}
else
if
(
preview
.
items
)
{
entriesNodes
=
preview
.
items
.
map
(
(
value
index
)
=
>
{
return
createNode
(
item
index
{
entriesPath
}
/
{
index
}
{
value
}
)
;
}
)
;
}
return
createNode
(
item
nodeName
entriesPath
entriesNodes
NODE_TYPES
.
ENTRIES
)
;
}
return
createNode
(
item
nodeName
entriesPath
null
NODE_TYPES
.
ENTRIES
)
;
}
function
makeNodesForMapEntry
(
item
)
{
const
nodeValue
=
getValue
(
item
)
;
if
(
!
nodeValue
|
|
!
nodeValue
.
preview
)
{
return
[
]
;
}
const
{
key
value
}
=
nodeValue
.
preview
;
const
path
=
item
.
path
;
return
[
createNode
(
item
"
<
key
>
"
{
path
}
/
#
#
key
{
value
:
key
}
NODE_TYPES
.
MAP_ENTRY_KEY
)
createNode
(
item
"
<
value
>
"
{
path
}
/
#
#
value
{
value
}
NODE_TYPES
.
MAP_ENTRY_VALUE
)
]
;
}
function
getNodeGetter
(
item
)
{
return
get
(
item
"
contents
.
get
"
undefined
)
;
}
function
getNodeSetter
(
item
)
{
return
get
(
item
"
contents
.
set
"
undefined
)
;
}
function
makeNodesForAccessors
(
item
)
{
const
accessors
=
[
]
;
const
getter
=
getNodeGetter
(
item
)
;
if
(
getter
&
&
getter
.
type
!
=
=
"
undefined
"
)
{
accessors
.
push
(
createNode
(
item
"
<
get
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
get
{
value
:
getter
}
NODE_TYPES
.
GET
)
)
;
}
const
setter
=
getNodeSetter
(
item
)
;
if
(
setter
&
&
setter
.
type
!
=
=
"
undefined
"
)
{
accessors
.
push
(
createNode
(
item
"
<
set
>
"
{
item
.
path
}
/
{
SAFE_PATH_PREFIX
}
set
{
value
:
setter
}
NODE_TYPES
.
SET
)
)
;
}
return
accessors
;
}
function
sortProperties
(
properties
)
{
return
properties
.
sort
(
(
a
b
)
=
>
{
const
aInt
=
parseInt
(
a
10
)
;
const
bInt
=
parseInt
(
b
10
)
;
if
(
isNaN
(
aInt
)
|
|
isNaN
(
bInt
)
)
{
return
a
>
b
?
1
:
-
1
;
}
return
aInt
-
bInt
;
}
)
;
}
function
makeNumericalBuckets
(
propertiesNames
parent
ownProperties
startIndex
=
0
)
{
const
parentPath
=
parent
.
path
;
const
numProperties
=
propertiesNames
.
length
;
const
bucketSize
=
10
*
*
Math
.
max
(
2
Math
.
ceil
(
Math
.
log10
(
numProperties
)
)
-
2
)
;
const
numBuckets
=
Math
.
ceil
(
numProperties
/
bucketSize
)
;
let
buckets
=
[
]
;
for
(
let
i
=
1
;
i
<
=
numBuckets
;
i
+
+
)
{
const
minKey
=
(
i
-
1
)
*
bucketSize
;
const
maxKey
=
Math
.
min
(
i
*
bucketSize
-
1
numProperties
-
1
)
;
if
(
maxKey
=
=
=
minKey
)
{
const
name
=
propertiesNames
[
maxKey
]
;
buckets
.
push
(
createNode
(
parent
name
{
parentPath
}
/
{
name
}
ownProperties
[
name
]
)
)
;
}
else
{
const
minIndex
=
startIndex
+
minKey
;
const
maxIndex
=
startIndex
+
maxKey
;
const
bucketKey
=
{
SAFE_PATH_PREFIX
}
bucket_
{
minIndex
}
-
{
maxIndex
}
;
const
bucketName
=
[
{
minIndex
}
{
maxIndex
}
]
;
const
bucketRoot
=
createNode
(
parent
bucketName
{
parentPath
}
/
{
bucketKey
}
[
]
NODE_TYPES
.
BUCKET
)
;
const
bucketProperties
=
propertiesNames
.
slice
(
minKey
maxKey
+
1
)
;
let
bucketNodes
;
if
(
bucketProperties
.
length
<
=
100
)
{
bucketNodes
=
bucketProperties
.
map
(
name
=
>
createNode
(
bucketRoot
name
{
parentPath
}
/
{
bucketKey
}
/
{
name
}
ownProperties
[
name
]
)
)
;
}
else
{
bucketNodes
=
makeNumericalBuckets
(
bucketProperties
bucketRoot
ownProperties
minIndex
)
;
}
setNodeChildren
(
bucketRoot
bucketNodes
)
;
buckets
.
push
(
bucketRoot
)
;
}
}
return
buckets
;
}
function
makeDefaultPropsBucket
(
propertiesNames
parent
ownProperties
)
{
const
parentPath
=
parent
.
path
;
const
userPropertiesNames
=
[
]
;
const
defaultProperties
=
[
]
;
propertiesNames
.
forEach
(
name
=
>
{
if
(
isDefaultWindowProperty
(
name
)
)
{
defaultProperties
.
push
(
name
)
;
}
else
{
userPropertiesNames
.
push
(
name
)
;
}
}
)
;
let
nodes
=
makeNodesForOwnProps
(
userPropertiesNames
parent
ownProperties
)
;
if
(
defaultProperties
.
length
>
0
)
{
const
defaultPropertiesNode
=
createNode
(
parent
"
[
default
properties
]
"
{
parentPath
}
/
{
SAFE_PATH_PREFIX
}
default
null
NODE_TYPES
.
DEFAULT_PROPERTIES
)
;
const
defaultNodes
=
defaultProperties
.
map
(
(
name
index
)
=
>
createNode
(
defaultPropertiesNode
maybeEscapePropertyName
(
name
)
{
parentPath
}
/
{
SAFE_PATH_PREFIX
}
bucket
{
index
}
/
{
name
}
ownProperties
[
name
]
)
)
;
nodes
.
push
(
setNodeChildren
(
defaultPropertiesNode
defaultNodes
)
)
;
}
return
nodes
;
}
function
makeNodesForOwnProps
(
propertiesNames
parent
ownProperties
)
{
const
parentPath
=
parent
.
path
;
return
propertiesNames
.
map
(
name
=
>
createNode
(
parent
maybeEscapePropertyName
(
name
)
{
parentPath
}
/
{
name
}
ownProperties
[
name
]
)
)
;
}
function
makeNodesForProperties
(
objProps
parent
)
{
const
{
ownProperties
=
{
}
ownSymbols
prototype
safeGetterValues
}
=
objProps
;
const
parentPath
=
parent
.
path
;
const
parentValue
=
getValue
(
parent
)
;
let
allProperties
=
Object
.
assign
(
{
}
ownProperties
safeGetterValues
)
;
const
propertiesNames
=
sortProperties
(
Object
.
keys
(
allProperties
)
)
.
filter
(
name
=
>
allProperties
[
name
]
.
hasOwnProperty
(
"
value
"
)
|
|
allProperties
[
name
]
.
hasOwnProperty
(
"
getterValue
"
)
|
|
allProperties
[
name
]
.
hasOwnProperty
(
"
get
"
)
|
|
allProperties
[
name
]
.
hasOwnProperty
(
"
set
"
)
)
;
const
numProperties
=
propertiesNames
.
length
;
let
nodes
=
[
]
;
if
(
nodeSupportsBucketing
(
parent
)
&
&
numProperties
>
100
)
{
nodes
=
makeNumericalBuckets
(
propertiesNames
parent
allProperties
)
;
}
else
if
(
parentValue
&
&
parentValue
.
class
=
=
"
Window
"
)
{
nodes
=
makeDefaultPropsBucket
(
propertiesNames
parent
allProperties
)
;
}
else
{
nodes
=
makeNodesForOwnProps
(
propertiesNames
parent
allProperties
)
;
}
if
(
Array
.
isArray
(
ownSymbols
)
)
{
ownSymbols
.
forEach
(
(
ownSymbol
index
)
=
>
{
nodes
.
push
(
createNode
(
parent
ownSymbol
.
name
{
parentPath
}
/
{
SAFE_PATH_PREFIX
}
symbol
-
{
index
}
ownSymbol
.
descriptor
)
)
;
}
this
)
;
}
if
(
nodeIsPromise
(
parent
)
)
{
nodes
.
push
(
.
.
.
makeNodesForPromiseProperties
(
parent
)
)
;
}
if
(
nodeHasEntries
(
parent
)
)
{
nodes
.
push
(
makeNodesForEntries
(
parent
)
)
;
}
if
(
prototype
&
&
prototype
.
type
!
=
=
"
null
"
)
{
nodes
.
push
(
createNode
(
parent
"
__proto__
"
{
parentPath
}
/
__proto__
{
value
:
prototype
}
NODE_TYPES
.
PROTOTYPE
)
)
;
}
return
nodes
;
}
function
createNode
(
parent
name
path
contents
type
=
NODE_TYPES
.
GRIP
)
{
if
(
contents
=
=
=
undefined
)
{
return
null
;
}
return
{
parent
name
path
contents
type
}
;
}
function
setNodeChildren
(
node
children
)
{
node
.
contents
=
children
;
return
node
;
}
function
getChildren
(
options
)
{
const
{
actors
=
{
}
getObjectEntries
getObjectProperties
item
}
=
options
;
if
(
nodeHasAccessors
(
item
)
)
{
return
makeNodesForAccessors
(
item
)
;
}
if
(
nodeIsMapEntry
(
item
)
)
{
return
makeNodesForMapEntry
(
item
)
;
}
if
(
nodeHasChildren
(
item
)
)
{
return
item
.
contents
;
}
if
(
!
nodeHasProperties
(
item
)
&
&
!
nodeIsEntries
(
item
)
)
{
return
[
]
;
}
const
key
=
item
.
path
;
if
(
actors
&
&
actors
[
key
]
)
{
return
actors
[
key
]
;
}
if
(
nodeIsBucket
(
item
)
)
{
return
item
.
contents
.
children
;
}
let
loadedProps
;
if
(
nodeIsEntries
(
item
)
)
{
const
parent
=
getParent
(
item
)
;
loadedProps
=
getObjectEntries
(
get
(
getValue
(
parent
)
"
actor
"
undefined
)
)
;
}
else
{
loadedProps
=
getObjectProperties
(
get
(
getValue
(
item
)
"
actor
"
undefined
)
)
;
}
const
{
ownProperties
ownSymbols
safeGetterValues
prototype
}
=
loadedProps
|
|
{
}
;
if
(
!
ownProperties
&
&
!
ownSymbols
&
&
!
safeGetterValues
&
&
!
prototype
)
{
return
[
]
;
}
let
children
=
makeNodesForProperties
(
loadedProps
item
)
;
actors
[
key
]
=
children
;
return
children
;
}
function
getParent
(
item
)
{
return
item
.
parent
;
}
module
.
exports
=
{
createNode
getChildren
getParent
getValue
makeNodesForEntries
makeNodesForPromiseProperties
makeNodesForProperties
nodeHasAccessors
nodeHasAllEntriesInPreview
nodeHasChildren
nodeHasEntries
nodeHasProperties
nodeIsDefaultProperties
nodeIsEntries
nodeIsFunction
nodeIsGetter
nodeIsMapEntry
nodeIsMissingArguments
nodeIsObject
nodeIsOptimizedOut
nodeIsPrimitive
nodeIsPromise
nodeIsPrototype
nodeIsSetter
nodeIsWindow
nodeSupportsBucketing
setNodeChildren
sortProperties
NODE_TYPES
SAFE_PATH_PREFIX
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
5
)
isKey
=
__webpack_require__
(
63
)
stringToPath
=
__webpack_require__
(
68
)
toString
=
__webpack_require__
(
98
)
;
function
castPath
(
value
object
)
{
if
(
isArray
(
value
)
)
{
return
value
;
}
return
isKey
(
value
object
)
?
[
value
]
:
stringToPath
(
toString
(
value
)
)
;
}
module
.
exports
=
castPath
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseIsNative
=
__webpack_require__
(
75
)
getValue
=
__webpack_require__
(
80
)
;
function
getNative
(
object
key
)
{
var
value
=
getValue
(
object
key
)
;
return
baseIsNative
(
value
)
?
value
:
undefined
;
}
module
.
exports
=
getNative
;
}
)
(
function
(
module
exports
)
{
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
value
!
=
null
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
module
.
exports
=
isObject
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
isSymbol
=
__webpack_require__
(
11
)
;
var
INFINITY
=
1
/
0
;
function
toKey
(
value
)
{
if
(
typeof
value
=
=
'
string
'
|
|
isSymbol
(
value
)
)
{
return
value
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
toKey
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
REPS
getRep
}
=
__webpack_require__
(
3
)
;
const
ObjectInspector
=
__webpack_require__
(
56
)
;
const
ObjectInspectorUtils
=
__webpack_require__
(
21
)
;
const
{
parseURLEncodedText
parseURLParams
maybeEscapePropertyName
getGripPreviewItems
}
=
__webpack_require__
(
1
)
;
module
.
exports
=
{
REPS
getRep
MODE
maybeEscapePropertyName
parseURLEncodedText
parseURLParams
getGripPreviewItems
ObjectInspector
ObjectInspectorUtils
}
;
}
)
(
function
(
module
exports
)
{
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
const
Undefined
=
function
(
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
undefined
"
}
"
undefined
"
)
;
}
;
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
)
{
return
false
;
}
return
object
&
&
object
.
type
&
&
object
.
type
=
=
"
undefined
"
|
|
getGripType
(
object
noGrip
)
=
=
"
undefined
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Undefined
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
function
Null
(
props
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
null
"
}
"
null
"
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
)
{
return
false
;
}
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
null
"
)
{
return
true
;
}
return
object
=
=
null
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Null
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
escapeString
sanitizeString
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
LongStringRep
.
propTypes
=
{
useQuotes
:
React
.
PropTypes
.
bool
escapeWhitespace
:
React
.
PropTypes
.
bool
style
:
React
.
PropTypes
.
object
cropLimit
:
React
.
PropTypes
.
number
.
isRequired
member
:
React
.
PropTypes
.
string
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
LongStringRep
(
props
)
{
let
{
cropLimit
member
object
style
useQuotes
=
true
escapeWhitespace
=
true
}
=
props
;
let
{
fullText
initial
length
}
=
object
;
let
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
string
"
}
;
if
(
style
)
{
config
.
style
=
style
;
}
let
string
=
member
&
&
member
.
open
?
fullText
|
|
initial
:
initial
.
substring
(
0
cropLimit
)
;
if
(
string
.
length
<
length
)
{
string
+
=
"
\
u2026
"
;
}
let
formattedString
=
useQuotes
?
escapeString
(
string
escapeWhitespace
)
:
sanitizeString
(
string
)
;
return
span
(
config
formattedString
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
type
=
=
=
"
longString
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
LongStringRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
Number
.
propTypes
=
{
object
:
React
.
PropTypes
.
oneOfType
(
[
React
.
PropTypes
.
object
React
.
PropTypes
.
number
React
.
PropTypes
.
bool
]
)
.
isRequired
}
;
function
Number
(
props
)
{
let
value
=
props
.
object
;
return
span
(
{
className
:
"
objectBox
objectBox
-
number
"
}
stringify
(
value
)
)
;
}
function
stringify
(
object
)
{
let
isNegativeZero
=
Object
.
is
(
object
-
0
)
|
|
object
.
type
&
&
object
.
type
=
=
"
-
0
"
;
return
isNegativeZero
?
"
-
0
"
:
String
(
object
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
[
"
boolean
"
"
number
"
"
-
0
"
]
.
includes
(
getGripType
(
object
noGrip
)
)
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Number
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
const
DEFAULT_TITLE
=
"
Object
"
;
ObjectRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
title
:
React
.
PropTypes
.
string
}
;
function
ObjectRep
(
props
)
{
let
object
=
props
.
object
;
let
propsArray
=
safePropIterator
(
props
object
)
;
if
(
props
.
mode
=
=
=
MODE
.
TINY
)
{
const
tinyModeItems
=
[
]
;
if
(
getTitle
(
props
object
)
!
=
=
DEFAULT_TITLE
)
{
tinyModeItems
.
push
(
getTitleElement
(
props
object
)
)
;
}
else
{
tinyModeItems
.
push
(
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
propsArray
.
length
>
0
?
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
:
null
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
.
.
.
tinyModeItems
)
;
}
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
getTitleElement
(
props
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitleElement
(
props
object
)
{
return
span
(
{
className
:
"
objectTitle
"
}
getTitle
(
props
object
)
)
;
}
function
getTitle
(
props
object
)
{
return
props
.
title
|
|
object
.
class
|
|
DEFAULT_TITLE
;
}
function
safePropIterator
(
props
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
3
:
max
;
try
{
return
propIterator
(
props
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
function
propIterator
(
props
object
max
)
{
let
isInterestingProp
=
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
;
}
;
if
(
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Generator
]
"
)
{
object
=
Object
.
getPrototypeOf
(
object
)
;
}
let
interestingObject
=
getFilteredObject
(
object
max
isInterestingProp
)
;
if
(
Object
.
keys
(
interestingObject
)
.
length
<
max
)
{
interestingObject
=
Object
.
assign
(
{
}
interestingObject
getFilteredObject
(
object
max
-
Object
.
keys
(
interestingObject
)
.
length
(
type
value
)
=
>
!
isInterestingProp
(
type
value
)
)
)
;
}
let
propsArray
=
getPropsArray
(
interestingObject
props
)
;
if
(
Object
.
keys
(
object
)
.
length
>
max
)
{
propsArray
.
push
(
span
(
{
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
unfoldProps
(
propsArray
)
;
}
function
unfoldProps
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
Array
.
isArray
(
item
)
)
{
res
=
res
.
concat
(
item
)
;
}
else
{
res
.
push
(
item
)
;
}
if
(
index
!
=
=
items
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
getPropsArray
(
object
props
)
{
let
propsArray
=
[
]
;
if
(
!
object
)
{
return
propsArray
;
}
let
mode
=
MODE
.
TINY
;
const
objectKeys
=
Object
.
keys
(
object
)
;
return
objectKeys
.
map
(
(
name
i
)
=
>
PropRep
(
Object
.
assign
(
{
}
props
{
mode
name
object
:
object
[
name
]
equal
:
"
:
"
}
)
)
)
;
}
function
getFilteredObject
(
object
max
filter
)
{
let
filteredObject
=
{
}
;
try
{
for
(
let
name
in
object
)
{
if
(
Object
.
keys
(
filteredObject
)
.
length
>
=
max
)
{
return
filteredObject
;
}
let
value
;
try
{
value
=
object
[
name
]
;
}
catch
(
exc
)
{
continue
;
}
let
t
=
typeof
value
;
if
(
filter
(
t
value
)
)
{
filteredObject
[
name
]
=
value
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
filteredObject
;
}
function
supportsObject
(
object
)
{
return
true
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ObjectRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
SymbolRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
SymbolRep
(
props
)
{
let
{
className
=
"
objectBox
objectBox
-
symbol
"
object
}
=
props
;
let
{
name
}
=
object
;
return
span
(
{
className
}
Symbol
(
{
name
|
|
"
"
}
)
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
getGripType
(
object
noGrip
)
=
=
"
symbol
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
SymbolRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
InfinityRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
InfinityRep
(
props
)
{
const
{
object
}
=
props
;
return
span
(
{
className
:
"
objectBox
objectBox
-
number
"
}
object
.
type
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
const
type
=
getGripType
(
object
noGrip
)
;
return
type
=
=
"
Infinity
"
|
|
type
=
=
"
-
Infinity
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
InfinityRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
function
NaNRep
(
props
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
nan
"
}
"
NaN
"
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
return
getGripType
(
object
noGrip
)
=
=
"
NaN
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
NaNRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
Accessor
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
values
(
MODE
)
)
}
;
function
Accessor
(
props
)
{
const
{
object
}
=
props
;
const
accessors
=
[
]
;
if
(
hasGetter
(
object
)
)
{
accessors
.
push
(
"
Getter
"
)
;
}
if
(
hasSetter
(
object
)
)
{
accessors
.
push
(
"
Setter
"
)
;
}
const
title
=
accessors
.
join
(
"
&
"
)
;
return
span
(
{
className
:
"
objectBox
objectBox
-
accessor
"
}
span
(
{
className
:
"
objectTitle
"
}
title
)
)
;
}
function
hasGetter
(
object
)
{
return
object
&
&
object
.
get
&
&
object
.
get
.
type
!
=
=
"
undefined
"
;
}
function
hasSetter
(
object
)
{
return
object
&
&
object
.
set
&
&
object
.
set
.
type
!
=
=
"
undefined
"
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
!
=
=
true
&
&
(
hasGetter
(
object
)
|
|
hasSetter
(
object
)
)
)
{
return
true
;
}
return
false
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Accessor
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
rep
:
StringRep
}
=
__webpack_require__
(
16
)
;
const
{
span
}
=
React
.
DOM
;
Attribute
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
Attribute
(
props
)
{
let
{
object
}
=
props
;
let
value
=
object
.
preview
.
value
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectLink
-
Attr
"
}
span
(
{
className
:
"
attrTitle
"
}
getTitle
(
object
)
)
span
(
{
className
:
"
attrEqual
"
}
"
=
"
)
StringRep
(
{
object
:
value
}
)
)
;
}
function
getTitle
(
grip
)
{
return
grip
.
preview
.
nodeName
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
getGripType
(
grip
noGrip
)
=
=
"
Attr
"
&
&
grip
.
preview
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Attribute
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
DateTime
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
DateTime
(
props
)
{
let
grip
=
props
.
object
;
let
date
;
try
{
date
=
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
"
}
getTitle
(
grip
)
span
(
{
className
:
"
Date
"
}
new
Date
(
grip
.
preview
.
timestamp
)
.
toISOString
(
)
)
)
;
}
catch
(
e
)
{
date
=
span
(
{
className
:
"
objectBox
"
}
"
Invalid
Date
"
)
;
}
return
date
;
}
function
getTitle
(
grip
)
{
return
span
(
{
className
:
"
objectTitle
"
}
grip
.
class
+
"
"
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
getGripType
(
grip
noGrip
)
=
=
"
Date
"
&
&
grip
.
preview
;
}
module
.
exports
=
{
rep
:
wrapRender
(
DateTime
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
Document
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
Document
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
getLocation
(
grip
)
)
)
;
}
function
getLocation
(
grip
)
{
let
location
=
grip
.
preview
.
location
;
return
location
?
getURLDisplayString
(
location
)
:
"
"
;
}
function
getTitle
(
grip
)
{
return
span
(
{
className
:
"
objectTitle
"
}
grip
.
class
+
"
"
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
getGripType
(
object
noGrip
)
=
=
"
HTMLDocument
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Document
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
rep
}
=
__webpack_require__
(
9
)
;
Event
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
Event
(
props
)
{
let
gripProps
=
Object
.
assign
(
{
}
props
{
title
:
getTitle
(
props
)
}
)
;
gripProps
.
object
=
Object
.
assign
(
{
}
props
.
object
)
;
gripProps
.
object
.
preview
=
Object
.
assign
(
{
}
props
.
object
.
preview
)
;
gripProps
.
object
.
preview
.
ownProperties
=
{
}
;
if
(
gripProps
.
object
.
preview
.
target
)
{
Object
.
assign
(
gripProps
.
object
.
preview
.
ownProperties
{
target
:
gripProps
.
object
.
preview
.
target
}
)
;
}
Object
.
assign
(
gripProps
.
object
.
preview
.
ownProperties
gripProps
.
object
.
preview
.
properties
)
;
delete
gripProps
.
object
.
preview
.
properties
;
gripProps
.
object
.
ownPropertyLength
=
Object
.
keys
(
gripProps
.
object
.
preview
.
ownProperties
)
.
length
;
switch
(
gripProps
.
object
.
class
)
{
case
"
MouseEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
clientX
"
"
clientY
"
"
layerX
"
"
layerY
"
]
.
includes
(
name
)
;
}
;
break
;
case
"
KeyboardEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
key
"
"
charCode
"
"
keyCode
"
]
.
includes
(
name
)
;
}
;
break
;
case
"
MessageEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
isTrusted
"
"
data
"
]
.
includes
(
name
)
;
}
;
break
;
default
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
Object
.
keys
(
gripProps
.
object
.
preview
.
ownProperties
)
.
includes
(
name
)
;
}
;
}
return
rep
(
gripProps
)
;
}
function
getTitle
(
props
)
{
let
preview
=
props
.
object
.
preview
;
let
title
=
preview
.
type
;
if
(
preview
.
eventKind
=
=
"
key
"
&
&
preview
.
modifiers
&
&
preview
.
modifiers
.
length
)
{
title
=
{
title
}
{
preview
.
modifiers
.
join
(
"
-
"
)
}
;
}
return
title
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
DOMEvent
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
Event
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
cropString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
FunctionRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
parameterNames
:
React
.
PropTypes
.
array
}
;
function
FunctionRep
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
function
"
dir
:
"
ltr
"
}
getTitle
(
props
grip
)
getFunctionName
(
grip
props
)
"
(
"
.
.
.
renderParams
(
props
)
"
)
"
)
;
}
function
getTitle
(
props
grip
)
{
const
{
simplified
}
=
props
;
if
(
simplified
=
=
=
true
&
&
!
grip
.
isGenerator
&
&
!
grip
.
isAsync
)
{
return
null
;
}
let
title
=
simplified
=
=
=
true
?
"
"
:
"
function
"
;
if
(
grip
.
isGenerator
)
{
title
=
simplified
=
=
=
true
?
"
*
"
:
"
function
*
"
;
}
if
(
grip
.
isAsync
)
{
title
=
"
async
"
+
"
"
+
title
;
}
return
span
(
{
className
:
"
objectTitle
"
}
title
)
;
}
function
getFunctionName
(
grip
props
)
{
let
name
=
grip
.
userDisplayName
|
|
grip
.
displayName
|
|
grip
.
name
|
|
props
.
functionName
|
|
"
"
;
return
cropString
(
name
100
)
;
}
function
renderParams
(
props
)
{
const
{
parameterNames
=
[
]
}
=
props
;
return
parameterNames
.
filter
(
param
=
>
param
)
.
reduce
(
(
res
param
index
arr
)
=
>
{
res
.
push
(
span
(
{
className
:
"
param
"
}
param
)
)
;
if
(
index
<
arr
.
length
-
1
)
{
res
.
push
(
span
(
{
className
:
"
delimiter
"
}
"
"
)
)
;
}
return
res
;
}
[
]
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
const
type
=
getGripType
(
grip
noGrip
)
;
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
type
=
=
"
function
"
;
}
return
type
=
=
"
Function
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
FunctionRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
PromiseRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
PromiseRep
(
props
)
{
const
object
=
props
.
object
;
const
{
promiseState
}
=
object
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
;
if
(
props
.
mode
=
=
=
MODE
.
TINY
)
{
let
{
Rep
}
=
__webpack_require__
(
3
)
;
return
span
(
config
getTitle
(
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
Rep
(
{
object
:
promiseState
.
state
}
)
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
const
propsArray
=
getProps
(
props
promiseState
)
;
return
span
(
config
getTitle
(
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitle
(
object
)
{
return
span
(
{
className
:
"
objectTitle
"
}
object
.
class
)
;
}
function
getProps
(
props
promiseState
)
{
const
keys
=
[
"
state
"
]
;
if
(
Object
.
keys
(
promiseState
)
.
includes
(
"
value
"
)
)
{
keys
.
push
(
"
value
"
)
;
}
return
keys
.
reduce
(
(
res
key
i
)
=
>
{
let
object
=
promiseState
[
key
]
;
res
=
res
.
concat
(
PropRep
(
Object
.
assign
(
{
}
props
{
mode
:
MODE
.
TINY
name
:
<
{
key
}
>
object
equal
:
"
:
"
suppressQuotes
:
true
}
)
)
)
;
if
(
i
!
=
=
keys
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
getGripType
(
object
noGrip
)
=
=
"
Promise
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
PromiseRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
RegExp
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
RegExp
(
props
)
{
let
{
object
}
=
props
;
return
React
.
DOM
.
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
regexp
regexpSource
"
}
getSource
(
object
)
)
;
}
function
getSource
(
grip
)
{
return
grip
.
displayString
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
getGripType
(
object
noGrip
)
=
=
"
RegExp
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
RegExp
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
StyleSheet
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
StyleSheet
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
getLocation
(
grip
)
)
)
;
}
function
getTitle
(
grip
)
{
let
title
=
"
StyleSheet
"
;
return
span
(
{
className
:
"
objectBoxTitle
"
}
title
)
;
}
function
getLocation
(
grip
)
{
let
url
=
grip
.
preview
?
grip
.
preview
.
url
:
"
"
;
return
url
?
getURLDisplayString
(
url
)
:
"
"
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
getGripType
(
object
noGrip
)
=
=
"
CSSStyleSheet
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
StyleSheet
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
cropString
cropMultipleLines
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
nodeConstants
=
__webpack_require__
(
18
)
;
const
{
span
}
=
React
.
DOM
;
CommentNode
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
}
;
function
CommentNode
(
props
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
props
;
let
{
textContent
}
=
object
.
preview
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
textContent
=
cropMultipleLines
(
textContent
30
)
;
}
else
if
(
mode
=
=
=
MODE
.
SHORT
)
{
textContent
=
cropString
(
textContent
50
)
;
}
return
span
(
{
className
:
"
objectBox
theme
-
comment
"
"
data
-
link
-
actor
-
id
"
:
object
.
actor
}
<
!
-
-
{
textContent
}
-
-
>
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
object
.
preview
.
nodeType
=
=
=
nodeConstants
.
COMMENT_NODE
;
}
module
.
exports
=
{
rep
:
wrapRender
(
CommentNode
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
nodeConstants
=
__webpack_require__
(
18
)
;
const
Svg
=
__webpack_require__
(
10
)
;
const
{
span
}
=
React
.
DOM
;
ElementNode
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
ElementNode
(
props
)
{
let
{
object
mode
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
props
;
let
elements
=
getElements
(
object
mode
)
;
let
isInTree
=
object
.
preview
&
&
object
.
preview
.
isConnected
=
=
=
true
;
let
baseConfig
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
node
"
}
;
let
inspectIcon
;
if
(
isInTree
)
{
if
(
onDOMNodeMouseOver
)
{
Object
.
assign
(
baseConfig
{
onMouseOver
:
_
=
>
onDOMNodeMouseOver
(
object
)
}
)
;
}
if
(
onDOMNodeMouseOut
)
{
Object
.
assign
(
baseConfig
{
onMouseOut
:
onDOMNodeMouseOut
}
)
;
}
if
(
onInspectIconClick
)
{
inspectIcon
=
Svg
(
"
open
-
inspector
"
{
element
:
"
a
"
draggable
:
false
title
:
"
Click
to
select
the
node
in
the
inspector
"
onClick
:
e
=
>
onInspectIconClick
(
object
e
)
}
)
;
}
}
return
span
(
baseConfig
.
.
.
elements
inspectIcon
)
;
}
function
getElements
(
grip
mode
)
{
let
{
attributes
nodeName
}
=
grip
.
preview
;
const
nodeNameElement
=
span
(
{
className
:
"
tag
-
name
theme
-
fg
-
color3
"
}
nodeName
)
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
elements
=
[
nodeNameElement
]
;
if
(
attributes
.
id
)
{
elements
.
push
(
span
(
{
className
:
"
attr
-
name
theme
-
fg
-
color2
"
}
#
{
attributes
.
id
}
)
)
;
}
if
(
attributes
.
class
)
{
elements
.
push
(
span
(
{
className
:
"
attr
-
name
theme
-
fg
-
color2
"
}
attributes
.
class
.
replace
(
/
(
^
\
s
+
)
|
(
\
s
+
)
/
g
"
"
)
.
split
(
"
"
)
.
map
(
cls
=
>
.
{
cls
}
)
.
join
(
"
"
)
)
)
;
}
return
elements
;
}
let
attributeKeys
=
Object
.
keys
(
attributes
)
;
if
(
attributeKeys
.
includes
(
"
class
"
)
)
{
attributeKeys
.
splice
(
attributeKeys
.
indexOf
(
"
class
"
)
1
)
;
attributeKeys
.
unshift
(
"
class
"
)
;
}
if
(
attributeKeys
.
includes
(
"
id
"
)
)
{
attributeKeys
.
splice
(
attributeKeys
.
indexOf
(
"
id
"
)
1
)
;
attributeKeys
.
unshift
(
"
id
"
)
;
}
const
attributeElements
=
attributeKeys
.
reduce
(
(
arr
name
i
keys
)
=
>
{
let
value
=
attributes
[
name
]
;
let
attribute
=
span
(
{
}
span
(
{
className
:
"
attr
-
name
theme
-
fg
-
color2
"
}
{
name
}
)
=
"
span
(
{
className
:
"
attr
-
value
theme
-
fg
-
color6
"
}
{
value
}
)
"
)
;
return
arr
.
concat
(
[
"
"
attribute
]
)
;
}
[
]
)
;
return
[
"
<
"
nodeNameElement
.
.
.
attributeElements
"
>
"
]
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
object
.
preview
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ElementNode
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_createClass
=
(
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
'
value
'
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
)
(
)
;
var
_get
=
function
get
(
_x
_x2
_x3
)
{
var
_again
=
true
;
_function
:
while
(
_again
)
{
var
object
=
_x
property
=
_x2
receiver
=
_x3
;
_again
=
false
;
if
(
object
=
=
=
null
)
object
=
Function
.
prototype
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
object
property
)
;
if
(
desc
=
=
=
undefined
)
{
var
parent
=
Object
.
getPrototypeOf
(
object
)
;
if
(
parent
=
=
=
null
)
{
return
undefined
;
}
else
{
_x
=
parent
;
_x2
=
property
;
_x3
=
receiver
;
_again
=
true
;
desc
=
parent
=
undefined
;
continue
_function
;
}
}
else
if
(
'
value
'
in
desc
)
{
return
desc
.
value
;
}
else
{
var
getter
=
desc
.
get
;
if
(
getter
=
=
=
undefined
)
{
return
undefined
;
}
return
getter
.
call
(
receiver
)
;
}
}
}
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
function
_objectWithoutProperties
(
obj
keys
)
{
var
target
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
keys
.
indexOf
(
i
)
>
=
0
)
continue
;
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
continue
;
target
[
i
]
=
obj
[
i
]
;
}
return
target
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
'
Cannot
call
a
class
as
a
function
'
)
;
}
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
'
function
'
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
'
Super
expression
must
either
be
null
or
a
function
not
'
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
_react
=
__webpack_require__
(
0
)
;
var
_react2
=
_interopRequireDefault
(
_react
)
;
var
DOMParser
=
typeof
window
!
=
=
'
undefined
'
&
&
window
.
DOMParser
;
var
process
=
process
|
|
{
}
;
process
.
env
=
process
.
env
|
|
{
}
;
var
parserAvailable
=
typeof
DOMParser
!
=
=
'
undefined
'
&
&
DOMParser
.
prototype
!
=
null
&
&
DOMParser
.
prototype
.
parseFromString
!
=
null
;
function
isParsable
(
src
)
{
return
parserAvailable
&
&
typeof
src
=
=
=
'
string
'
&
&
src
.
trim
(
)
.
substr
(
0
4
)
=
=
=
'
<
svg
'
;
}
function
parseFromSVGString
(
src
)
{
var
parser
=
new
DOMParser
(
)
;
return
parser
.
parseFromString
(
src
"
image
/
svg
+
xml
"
)
;
}
function
switchSVGAttrToReactProp
(
propName
)
{
switch
(
propName
)
{
case
'
class
'
:
return
'
className
'
;
default
:
return
propName
;
}
}
var
InlineSVG
=
(
function
(
_React
Component
)
{
_inherits
(
InlineSVG
_React
Component
)
;
_createClass
(
InlineSVG
null
[
{
key
:
'
defaultProps
'
value
:
{
element
:
'
i
'
raw
:
false
src
:
'
'
}
enumerable
:
true
}
{
key
:
'
propTypes
'
value
:
{
src
:
_react2
[
'
default
'
]
.
PropTypes
.
string
.
isRequired
element
:
_react2
[
'
default
'
]
.
PropTypes
.
string
raw
:
_react2
[
'
default
'
]
.
PropTypes
.
bool
}
enumerable
:
true
}
]
)
;
function
InlineSVG
(
props
)
{
_classCallCheck
(
this
InlineSVG
)
;
_get
(
Object
.
getPrototypeOf
(
InlineSVG
.
prototype
)
'
constructor
'
this
)
.
call
(
this
props
)
;
this
.
_extractSVGProps
=
this
.
_extractSVGProps
.
bind
(
this
)
;
}
_createClass
(
InlineSVG
[
{
key
:
'
_serializeAttrs
'
value
:
function
_serializeAttrs
(
map
)
{
var
ret
=
{
}
;
var
prop
=
undefined
;
for
(
var
i
=
0
;
i
<
map
.
length
;
i
+
+
)
{
prop
=
switchSVGAttrToReactProp
(
map
[
i
]
.
name
)
;
ret
[
prop
]
=
map
[
i
]
.
value
;
}
return
ret
;
}
}
{
key
:
'
_extractSVGProps
'
value
:
function
_extractSVGProps
(
src
)
{
var
map
=
parseFromSVGString
(
src
)
.
documentElement
.
attributes
;
return
map
.
length
>
0
?
this
.
_serializeAttrs
(
map
)
:
null
;
}
}
{
key
:
'
_stripSVG
'
value
:
function
_stripSVG
(
src
)
{
return
parseFromSVGString
(
src
)
.
documentElement
.
innerHTML
;
}
}
{
key
:
'
componentWillReceiveProps
'
value
:
function
componentWillReceiveProps
(
_ref
)
{
var
children
=
_ref
.
children
;
if
(
"
production
"
!
=
=
process
.
env
.
NODE_ENV
&
&
children
!
=
null
)
{
console
.
info
(
'
<
InlineSVG
/
>
:
children
prop
will
be
ignored
.
'
)
;
}
}
}
{
key
:
'
render
'
value
:
function
render
(
)
{
var
Element
=
undefined
__html
=
undefined
svgProps
=
undefined
;
var
_props
=
this
.
props
;
var
element
=
_props
.
element
;
var
raw
=
_props
.
raw
;
var
src
=
_props
.
src
;
var
otherProps
=
_objectWithoutProperties
(
_props
[
'
element
'
'
raw
'
'
src
'
]
)
;
if
(
raw
=
=
=
true
&
&
isParsable
(
src
)
)
{
Element
=
'
svg
'
;
svgProps
=
this
.
_extractSVGProps
(
src
)
;
__html
=
this
.
_stripSVG
(
src
)
;
}
__html
=
__html
|
|
src
;
Element
=
Element
|
|
element
;
svgProps
=
svgProps
|
|
{
}
;
return
_react2
[
'
default
'
]
.
createElement
(
Element
_extends
(
{
}
svgProps
otherProps
{
src
:
null
children
:
null
dangerouslySetInnerHTML
:
{
__html
:
__html
}
}
)
)
;
}
}
]
)
;
return
InlineSVG
;
}
)
(
_react2
[
'
default
'
]
.
Component
)
;
exports
[
'
default
'
]
=
InlineSVG
;
module
.
exports
=
exports
[
'
default
'
]
;
}
)
(
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
>
<
path
d
=
\
"
M8
13
.
4c
-
.
5
0
-
.
9
-
.
2
-
1
.
2
-
.
6L
.
4
5
.
2C0
4
.
7
-
.
1
4
.
3
.
2
3
.
7S1
3
1
.
6
3h12
.
8c
.
6
0
1
.
2
.
1
1
.
4
.
7
.
3
.
6
.
2
1
.
1
-
.
2
1
.
6l
-
6
.
4
7
.
6c
-
.
3
.
4
-
.
7
.
5
-
1
.
2
.
5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
)
(
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
>
<
path
d
=
\
"
M8
3L12
3L12
7L14
7L14
8L12
8L12
12L8
12L8
14L7
14L7
12L3
12L3
8L1
8L1
7L3
7L3
3L7
3L7
1L8
1L8
3ZM10
10L10
5L5
5L5
10L10
10Z
\
"
>
<
/
path
>
<
/
svg
>
"
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
cropString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
Svg
=
__webpack_require__
(
10
)
;
const
DOM
=
React
.
DOM
;
TextNode
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
;
function
TextNode
(
props
)
{
let
{
object
:
grip
mode
=
MODE
.
SHORT
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
props
;
let
baseConfig
=
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
textNode
"
}
;
let
inspectIcon
;
let
isInTree
=
grip
.
preview
&
&
grip
.
preview
.
isConnected
=
=
=
true
;
if
(
isInTree
)
{
if
(
onDOMNodeMouseOver
)
{
Object
.
assign
(
baseConfig
{
onMouseOver
:
_
=
>
onDOMNodeMouseOver
(
grip
)
}
)
;
}
if
(
onDOMNodeMouseOut
)
{
Object
.
assign
(
baseConfig
{
onMouseOut
:
onDOMNodeMouseOut
}
)
;
}
if
(
onInspectIconClick
)
{
inspectIcon
=
Svg
(
"
open
-
inspector
"
{
element
:
"
a
"
draggable
:
false
title
:
"
Click
to
select
the
node
in
the
inspector
"
onClick
:
e
=
>
onInspectIconClick
(
grip
e
)
}
)
;
}
}
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
DOM
.
span
(
baseConfig
getTitle
(
grip
)
inspectIcon
)
;
}
return
DOM
.
span
(
baseConfig
getTitle
(
grip
)
DOM
.
span
(
{
className
:
"
nodeValue
"
}
"
"
"
{
getTextContent
(
grip
)
}
"
)
inspectIcon
)
;
}
function
getTextContent
(
grip
)
{
return
cropString
(
grip
.
preview
.
textContent
)
;
}
function
getTitle
(
grip
)
{
const
title
=
"
#
text
"
;
return
DOM
.
span
(
{
}
title
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
class
=
=
"
Text
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
TextNode
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
ErrorRep
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
}
;
function
ErrorRep
(
props
)
{
let
object
=
props
.
object
;
let
preview
=
object
.
preview
;
let
name
=
preview
&
&
preview
.
name
?
preview
.
name
:
"
Error
"
;
let
content
=
props
.
mode
=
=
=
MODE
.
TINY
?
name
:
{
name
}
:
{
preview
.
message
}
;
if
(
preview
.
stack
&
&
props
.
mode
!
=
=
MODE
.
TINY
)
{
content
=
{
content
}
\
nStack
trace
:
\
n
{
preview
.
stack
}
;
}
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
-
stackTrace
"
}
content
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
getGripType
(
object
noGrip
)
=
=
=
"
Error
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ErrorRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
getGripType
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
WindowRep
.
propTypes
=
{
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
WindowRep
(
props
)
{
let
{
mode
object
}
=
props
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
Window
"
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
span
(
config
getTitle
(
object
)
)
;
}
return
span
(
config
getTitle
(
object
)
"
"
span
(
{
className
:
"
objectPropValue
"
}
getLocation
(
object
)
)
)
;
}
function
getTitle
(
object
)
{
let
title
=
object
.
displayClass
|
|
object
.
class
|
|
"
Window
"
;
return
span
(
{
className
:
"
objectBoxTitle
"
}
title
)
;
}
function
getLocation
(
object
)
{
return
getURLDisplayString
(
object
.
preview
.
url
)
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
getGripType
(
object
noGrip
)
=
=
"
Window
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
WindowRep
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
ObjectWithText
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
ObjectWithText
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
"
+
getType
(
grip
)
}
span
(
{
className
:
"
objectPropValue
"
}
getDescription
(
grip
)
)
)
;
}
function
getType
(
grip
)
{
return
grip
.
class
;
}
function
getDescription
(
grip
)
{
return
"
\
"
"
+
grip
.
preview
.
text
+
"
\
"
"
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithText
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ObjectWithText
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
ObjectWithURL
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
;
function
ObjectWithURL
(
props
)
{
let
grip
=
props
.
object
;
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
"
+
getType
(
grip
)
}
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
getDescription
(
grip
)
)
)
;
}
function
getTitle
(
grip
)
{
return
span
(
{
className
:
"
objectTitle
"
}
getType
(
grip
)
+
"
"
)
;
}
function
getType
(
grip
)
{
return
grip
.
class
;
}
function
getDescription
(
grip
)
{
return
getURLDisplayString
(
grip
.
preview
.
url
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithURL
"
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ObjectWithURL
)
supportsObject
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
0
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
1
)
;
const
PropRep
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
span
}
=
React
.
DOM
;
GripMap
.
propTypes
=
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
isInterestingEntry
:
React
.
PropTypes
.
func
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
title
:
React
.
PropTypes
.
string
}
;
function
GripMap
(
props
)
{
let
{
mode
object
}
=
props
;
const
config
=
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
objectBox
-
object
"
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
span
(
config
getTitle
(
props
object
)
)
;
}
let
propsArray
=
safeEntriesIterator
(
props
object
maxLengthMap
.
get
(
mode
)
)
;
return
span
(
config
getTitle
(
props
object
)
span
(
{
className
:
"
objectLeftBrace
"
}
"
{
"
)
.
.
.
propsArray
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
;
}
function
getTitle
(
props
object
)
{
let
title
=
props
.
title
|
|
(
object
&
&
object
.
class
?
object
.
class
:
"
Map
"
)
;
return
span
(
{
className
:
"
objectTitle
"
}
title
)
;
}
function
safeEntriesIterator
(
props
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
3
:
max
;
try
{
return
entriesIterator
(
props
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
function
entriesIterator
(
props
object
max
)
{
let
isInterestingEntry
=
props
.
isInterestingEntry
|
|
(
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
.
length
!
=
0
;
}
)
;
let
mapEntries
=
object
.
preview
&
&
object
.
preview
.
entries
?
object
.
preview
.
entries
:
[
]
;
let
indexes
=
getEntriesIndexes
(
mapEntries
max
isInterestingEntry
)
;
if
(
indexes
.
length
<
max
&
&
indexes
.
length
<
mapEntries
.
length
)
{
indexes
=
indexes
.
concat
(
getEntriesIndexes
(
mapEntries
max
-
indexes
.
length
(
t
value
name
)
=
>
{
return
!
isInterestingEntry
(
t
value
name
)
;
}
)
)
;
}
let
entries
=
getEntries
(
props
mapEntries
indexes
)
;
if
(
entries
.
length
<
object
.
preview
.
size
)
{
entries
.
push
(
span
(
{
key
:
"
more
"
className
:
"
more
-
ellipsis
"
title
:
"
more
"
}
"
"
)
)
;
}
return
unfoldEntries
(
entries
)
;
}
function
unfoldEntries
(
items
)
{
return
items
.
reduce
(
(
res
item
index
)
=
>
{
if
(
Array
.
isArray
(
item
)
)
{
res
=
res
.
concat
(
item
)
;
}
else
{
res
.
push
(
item
)
;
}
if
(
index
!
=
=
items
.
length
-
1
)
{
res
.
push
(
"
"
)
;
}
return
res
;
}
[
]
)
;
}
function
getEntries
(
props
entries
indexes
)
{
let
{
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
props
;
indexes
.
sort
(
function
(
a
b
)
{
return
a
-
b
;
}
)
;
return
indexes
.
map
(
(
index
i
)
=
>
{
let
[
key
entryValue
]
=
entries
[
index
]
;
let
value
=
entryValue
.
value
!
=
=
undefined
?
entryValue
.
value
:
entryValue
;
return
PropRep
(
{
name
:
key
equal
:
"
\
u2192
"
object
:
value
mode
:
MODE
.
TINY
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
)
;
}
)
;
}
function
getEntriesIndexes
(
entries
max
filter
)
{
return
entries
.
reduce
(
(
indexes
[
key
entry
]
i
)
=
>
{
if
(
indexes
.
length
<
max
)
{
let
value
=
entry
&
&
entry
.
value
!
=
=
undefined
?
entry
.
value
:
entry
;
let
type
=
(
value
&
&
value
.
class
?
value
.
class
:
typeof
value
)
.
toLowerCase
(
)
;
if
(
filter
(
type
value
key
)
)
{
indexes
.
push
(
i
)
;
}
}
return
indexes
;
}
[
]
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
MapLike
"
;
}
const
maxLengthMap
=
new
Map
(
)
;
maxLengthMap
.
set
(
MODE
.
SHORT
3
)
;
maxLengthMap
.
set
(
MODE
.
LONG
10
)
;
module
.
exports
=
{
rep
:
wrapRender
(
GripMap
)
supportsObject
maxLengthMap
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
{
Component
createFactory
DOM
:
dom
PropTypes
}
=
__webpack_require__
(
0
)
;
const
Tree
=
createFactory
(
__webpack_require__
(
57
)
.
Tree
)
;
__webpack_require__
(
59
)
;
const
classnames
=
__webpack_require__
(
60
)
;
const
Svg
=
__webpack_require__
(
10
)
;
const
{
REPS
:
{
Rep
Grip
}
}
=
__webpack_require__
(
3
)
;
const
{
MODE
}
=
__webpack_require__
(
2
)
;
const
{
getChildren
getParent
getValue
nodeHasAccessors
nodeHasAllEntriesInPreview
nodeHasProperties
nodeIsDefaultProperties
nodeIsEntries
nodeIsGetter
nodeIsMapEntry
nodeIsFunction
nodeIsMissingArguments
nodeIsOptimizedOut
nodeIsPrimitive
nodeIsPrototype
nodeIsSetter
nodeIsWindow
}
=
__webpack_require__
(
21
)
;
class
ObjectInspector
extends
Component
{
constructor
(
)
{
super
(
)
;
this
.
actors
=
{
}
;
this
.
state
=
{
expandedKeys
:
new
Set
(
)
focusedItem
:
null
}
;
const
self
=
this
;
self
.
getChildren
=
this
.
getChildren
.
bind
(
this
)
;
self
.
renderTreeItem
=
this
.
renderTreeItem
.
bind
(
this
)
;
self
.
setExpanded
=
this
.
setExpanded
.
bind
(
this
)
;
self
.
focusItem
=
this
.
focusItem
.
bind
(
this
)
;
self
.
getRoots
=
this
.
getRoots
.
bind
(
this
)
;
}
getChildren
(
item
)
{
const
{
getObjectEntries
getObjectProperties
}
=
this
.
props
;
const
{
actors
}
=
this
;
return
getChildren
(
{
getObjectEntries
getObjectProperties
actors
item
}
)
;
}
getRoots
(
)
{
return
this
.
props
.
roots
;
}
getKey
(
item
)
{
return
item
.
path
;
}
setExpanded
(
item
expand
)
{
const
{
expandedKeys
}
=
this
.
state
;
const
key
=
this
.
getKey
(
item
)
;
if
(
expand
=
=
=
true
)
{
expandedKeys
.
add
(
key
)
;
}
else
{
expandedKeys
.
delete
(
key
)
;
}
this
.
setState
(
{
expandedKeys
}
)
;
if
(
expand
=
=
=
true
)
{
const
{
getObjectProperties
getObjectEntries
loadObjectProperties
loadObjectEntries
}
=
this
.
props
;
const
value
=
getValue
(
item
)
;
const
parent
=
getParent
(
item
)
;
const
parentValue
=
getValue
(
parent
)
;
const
parentActor
=
parentValue
?
parentValue
.
actor
:
null
;
if
(
nodeHasProperties
(
item
)
&
&
value
&
&
!
getObjectProperties
(
value
.
actor
)
)
{
loadObjectProperties
(
value
)
;
}
if
(
nodeIsEntries
(
item
)
&
&
!
nodeHasAllEntriesInPreview
(
parent
)
&
&
parentActor
&
&
!
getObjectEntries
(
parentActor
)
)
{
loadObjectEntries
(
parentValue
)
;
}
}
}
focusItem
(
item
)
{
if
(
!
this
.
props
.
disabledFocus
&
&
this
.
state
.
focusedItem
!
=
=
item
)
{
this
.
setState
(
{
focusedItem
:
item
}
)
;
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
}
renderTreeItem
(
item
depth
focused
arrow
expanded
)
{
let
objectValue
;
let
label
=
item
.
name
;
let
itemValue
=
getValue
(
item
)
;
const
isPrimitive
=
nodeIsPrimitive
(
item
)
;
const
unavailable
=
isPrimitive
&
&
itemValue
&
&
itemValue
.
hasOwnProperty
&
&
itemValue
.
hasOwnProperty
(
"
unavailable
"
)
;
if
(
nodeIsOptimizedOut
(
item
)
)
{
objectValue
=
dom
.
span
(
{
className
:
"
unavailable
"
}
"
(
optimized
away
)
"
)
;
}
else
if
(
nodeIsMissingArguments
(
item
)
|
|
unavailable
)
{
objectValue
=
dom
.
span
(
{
className
:
"
unavailable
"
}
"
(
unavailable
)
"
)
;
}
else
if
(
nodeIsFunction
(
item
)
&
&
!
nodeIsGetter
(
item
)
&
&
!
nodeIsSetter
(
item
)
)
{
objectValue
=
undefined
;
label
=
this
.
renderGrip
(
item
Object
.
assign
(
{
}
this
.
props
{
simplified
:
depth
!
=
=
0
functionName
:
label
}
)
)
;
}
else
if
(
nodeHasProperties
(
item
)
|
|
nodeHasAccessors
(
item
)
|
|
nodeIsMapEntry
(
item
)
|
|
isPrimitive
)
{
let
repsProp
=
Object
.
assign
(
{
}
this
.
props
)
;
if
(
depth
>
0
)
{
repsProp
.
mode
=
this
.
props
.
mode
=
=
=
MODE
.
LONG
?
MODE
.
SHORT
:
MODE
.
TINY
;
}
objectValue
=
this
.
renderGrip
(
item
repsProp
)
;
}
const
hasLabel
=
label
!
=
=
null
&
&
typeof
label
!
=
=
"
undefined
"
;
const
hasValue
=
typeof
objectValue
!
=
=
"
undefined
"
;
const
SINGLE_INDENT_WIDTH
=
15
;
const
indentWidth
=
(
depth
+
(
isPrimitive
?
1
:
0
)
)
*
SINGLE_INDENT_WIDTH
;
const
{
onDoubleClick
onLabelClick
dimTopLevelWindow
}
=
this
.
props
;
return
dom
.
div
(
{
className
:
classnames
(
"
node
object
-
node
"
{
focused
lessen
:
!
expanded
&
&
(
nodeIsDefaultProperties
(
item
)
|
|
nodeIsPrototype
(
item
)
|
|
dimTopLevelWindow
=
=
=
true
&
&
nodeIsWindow
(
item
)
&
&
depth
=
=
=
0
)
}
)
style
:
{
marginLeft
:
indentWidth
}
onClick
:
isPrimitive
=
=
=
false
?
e
=
>
{
e
.
stopPropagation
(
)
;
this
.
setExpanded
(
item
!
expanded
)
;
}
:
null
onDoubleClick
:
onDoubleClick
?
e
=
>
{
e
.
stopPropagation
(
)
;
onDoubleClick
(
item
{
depth
focused
expanded
}
)
;
}
:
null
}
isPrimitive
=
=
=
false
?
Svg
(
"
arrow
"
{
className
:
classnames
(
{
expanded
:
expanded
}
)
}
)
:
null
hasLabel
?
dom
.
span
(
{
className
:
"
object
-
label
"
onClick
:
onLabelClick
?
event
=
>
{
event
.
stopPropagation
(
)
;
onLabelClick
(
item
{
depth
focused
expanded
setExpanded
:
this
.
setExpanded
}
)
;
}
:
null
}
label
)
:
null
hasLabel
&
&
hasValue
?
dom
.
span
(
{
className
:
"
object
-
delimiter
"
}
"
:
"
)
:
null
hasValue
?
objectValue
:
null
)
;
}
renderGrip
(
item
props
)
{
const
object
=
getValue
(
item
)
;
return
Rep
(
Object
.
assign
(
{
}
props
{
object
mode
:
props
.
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
)
;
}
render
(
)
{
const
{
autoExpandDepth
=
1
autoExpandAll
=
true
disabledFocus
inline
itemHeight
=
20
disableWrap
=
false
}
=
this
.
props
;
const
{
expandedKeys
focusedItem
}
=
this
.
state
;
let
roots
=
this
.
getRoots
(
)
;
if
(
roots
.
length
=
=
=
1
)
{
const
root
=
roots
[
0
]
;
const
name
=
root
&
&
root
.
name
;
if
(
nodeIsPrimitive
(
root
)
&
&
(
name
=
=
=
null
|
|
typeof
name
=
=
=
"
undefined
"
)
)
{
return
this
.
renderGrip
(
root
this
.
props
)
;
}
}
return
Tree
(
{
className
:
classnames
(
{
inline
nowrap
:
disableWrap
}
)
autoExpandAll
autoExpandDepth
disabledFocus
itemHeight
isExpanded
:
item
=
>
expandedKeys
.
has
(
this
.
getKey
(
item
)
)
focused
:
focusedItem
getRoots
:
this
.
getRoots
getParent
getChildren
:
this
.
getChildren
getKey
:
this
.
getKey
onExpand
:
item
=
>
this
.
setExpanded
(
item
true
)
onCollapse
:
item
=
>
this
.
setExpanded
(
item
false
)
onFocus
:
this
.
focusItem
renderItem
:
this
.
renderTreeItem
}
)
;
}
}
ObjectInspector
.
displayName
=
"
ObjectInspector
"
;
ObjectInspector
.
propTypes
=
{
autoExpandAll
:
PropTypes
.
bool
autoExpandDepth
:
PropTypes
.
number
disabledFocus
:
PropTypes
.
bool
disableWrap
:
PropTypes
.
bool
inline
:
PropTypes
.
bool
roots
:
PropTypes
.
array
getObjectProperties
:
PropTypes
.
func
.
isRequired
loadObjectProperties
:
PropTypes
.
func
.
isRequired
itemHeight
:
PropTypes
.
number
mode
:
PropTypes
.
oneOf
(
Object
.
values
(
MODE
)
)
onFocus
:
PropTypes
.
func
onDoubleClick
:
PropTypes
.
func
onLabelClick
:
PropTypes
.
func
}
;
module
.
exports
=
ObjectInspector
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
Tree
=
__webpack_require__
(
58
)
;
module
.
exports
=
{
Tree
}
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
const
{
DOM
:
dom
createClass
createFactory
PropTypes
}
=
__webpack_require__
(
0
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
ArrowExpander
=
createFactory
(
createClass
(
{
displayName
:
"
ArrowExpander
"
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
visible
!
=
=
nextProps
.
visible
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
attrs
=
{
className
:
"
arrow
theme
-
twisty
"
onClick
:
this
.
props
.
expanded
?
(
)
=
>
this
.
props
.
onCollapse
(
this
.
props
.
item
)
:
e
=
>
this
.
props
.
onExpand
(
this
.
props
.
item
e
.
altKey
)
}
;
if
(
this
.
props
.
expanded
)
{
attrs
.
className
+
=
"
open
"
;
}
if
(
!
this
.
props
.
visible
)
{
attrs
.
style
=
Object
.
assign
(
{
}
this
.
props
.
style
|
|
{
}
{
visibility
:
"
hidden
"
}
)
;
}
return
dom
.
div
(
attrs
this
.
props
.
children
)
;
}
}
)
)
;
const
TreeNode
=
createFactory
(
createClass
(
{
displayName
:
"
TreeNode
"
componentDidMount
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
componentDidUpdate
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
focused
!
=
=
nextProps
.
focused
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
arrow
=
ArrowExpander
(
{
item
:
this
.
props
.
item
expanded
:
this
.
props
.
expanded
visible
:
this
.
props
.
hasChildren
onExpand
:
this
.
props
.
onExpand
onCollapse
:
this
.
props
.
onCollapse
}
)
;
let
isOddRow
=
this
.
props
.
index
%
2
;
return
dom
.
div
(
{
className
:
tree
-
node
div
{
isOddRow
?
"
tree
-
node
-
odd
"
:
"
"
}
onFocus
:
this
.
props
.
onFocus
onClick
:
this
.
props
.
onFocus
onBlur
:
this
.
props
.
onBlur
style
:
{
padding
:
0
margin
:
0
}
}
this
.
props
.
renderItem
(
this
.
props
.
item
this
.
props
.
depth
this
.
props
.
focused
arrow
this
.
props
.
expanded
)
dom
.
button
(
this
.
_buttonAttrs
)
)
;
}
_buttonAttrs
:
{
ref
:
"
button
"
style
:
{
opacity
:
0
width
:
"
0
!
important
"
height
:
"
0
!
important
"
padding
:
"
0
!
important
"
outline
:
"
none
"
MozAppearance
:
"
none
"
MozMarginStart
:
"
-
1000px
!
important
"
}
}
}
)
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
const
NUMBER_OF_OFFSCREEN_ITEMS
=
1
;
const
Tree
=
module
.
exports
=
createClass
(
{
displayName
:
"
Tree
"
propTypes
:
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
isExpanded
:
PropTypes
.
func
.
isRequired
itemHeight
:
PropTypes
.
number
.
isRequired
focused
:
PropTypes
.
any
onFocus
:
PropTypes
.
func
autoExpandDepth
:
PropTypes
.
number
autoExpandAll
:
PropTypes
.
bool
onExpand
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
}
getDefaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
autoExpandAll
:
true
}
;
}
getInitialState
(
)
{
return
{
scroll
:
0
height
:
window
.
innerHeight
seen
:
new
Set
(
)
}
;
}
componentDidMount
(
)
{
window
.
addEventListener
(
"
resize
"
this
.
_updateHeight
)
;
this
.
_autoExpand
(
this
.
props
)
;
this
.
_updateHeight
(
)
;
}
componentWillUnmount
(
)
{
window
.
removeEventListener
(
"
resize
"
this
.
_updateHeight
)
;
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
nextProps
)
;
this
.
_updateHeight
(
)
;
}
_autoExpand
(
props
)
{
if
(
!
props
.
autoExpandDepth
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
if
(
currentDepth
>
=
props
.
autoExpandDepth
|
|
this
.
state
.
seen
.
has
(
item
)
)
{
return
;
}
props
.
onExpand
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
const
children
=
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
if
(
props
.
autoExpandAll
)
{
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
else
if
(
length
!
=
0
)
{
autoExpand
(
roots
[
0
]
0
)
;
}
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
renderItem
=
i
=
>
{
let
{
item
depth
}
=
traversal
[
i
]
;
return
TreeNode
(
{
key
:
this
.
props
.
getKey
(
item
i
)
index
:
i
item
:
item
depth
:
depth
renderItem
:
this
.
props
.
renderItem
focused
:
this
.
props
.
focused
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
hasChildren
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onFocus
:
(
)
=
>
this
.
_focus
(
i
item
)
}
)
;
}
;
const
style
=
Object
.
assign
(
{
}
this
.
props
.
style
|
|
{
}
{
padding
:
0
margin
:
0
}
)
;
return
dom
.
div
(
{
className
:
tree
{
this
.
props
.
className
?
this
.
props
.
className
:
"
"
}
ref
:
"
tree
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
onScroll
:
this
.
_onScroll
style
}
traversal
.
map
(
(
v
i
)
=
>
renderItem
(
i
)
)
)
;
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
}
_updateHeight
(
)
{
this
.
setState
(
{
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
:
oncePerAnimationFrame
(
function
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
)
_onCollapse
:
oncePerAnimationFrame
(
function
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
)
_focus
(
index
item
)
{
if
(
item
!
=
=
undefined
)
{
const
itemStartPosition
=
index
*
this
.
props
.
itemHeight
;
const
itemEndPosition
=
(
index
+
1
)
*
this
.
props
.
itemHeight
;
if
(
this
.
state
.
scroll
>
itemStartPosition
)
{
this
.
refs
.
tree
.
scrollTop
=
itemStartPosition
;
}
else
if
(
this
.
state
.
scroll
+
this
.
state
.
height
<
itemEndPosition
)
{
this
.
refs
.
tree
.
scrollTop
=
itemEndPosition
-
this
.
state
.
height
;
}
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_onBlur
(
)
{
this
.
_focus
(
0
undefined
)
;
}
_onScroll
:
oncePerAnimationFrame
(
function
(
e
)
{
this
.
setState
(
{
scroll
:
Math
.
max
(
this
.
refs
.
tree
.
scrollTop
0
)
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
)
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
props
.
getChildren
(
this
.
props
.
focused
)
.
length
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
return
;
}
}
_focusPrevNode
:
oncePerAnimationFrame
(
function
(
)
{
let
prev
;
let
prevIndex
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
prevIndex
=
i
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prevIndex
prev
)
;
}
)
_focusNextNode
:
oncePerAnimationFrame
(
function
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
i
+
1
traversal
[
i
+
1
]
.
item
)
;
}
}
)
_focusParentNode
:
oncePerAnimationFrame
(
function
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
return
;
}
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
parentIndex
=
0
;
for
(
;
parentIndex
<
length
;
parentIndex
+
+
)
{
if
(
traversal
[
parentIndex
]
.
item
=
=
=
parent
)
{
break
;
}
}
this
.
_focus
(
parentIndex
parent
)
;
}
)
}
)
;
}
)
(
function
(
module
exports
)
{
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
)
{
'
use
strict
'
;
var
hasOwn
=
{
}
.
hasOwnProperty
;
function
classNames
(
)
{
var
classes
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
continue
;
var
argType
=
typeof
arg
;
if
(
argType
=
=
=
'
string
'
|
|
argType
=
=
=
'
number
'
)
{
classes
.
push
(
arg
)
;
}
else
if
(
Array
.
isArray
(
arg
)
)
{
classes
.
push
(
classNames
.
apply
(
null
arg
)
)
;
}
else
if
(
argType
=
=
=
'
object
'
)
{
for
(
var
key
in
arg
)
{
if
(
hasOwn
.
call
(
arg
key
)
&
&
arg
[
key
]
)
{
classes
.
push
(
key
)
;
}
}
}
}
return
classes
.
join
(
'
'
)
;
}
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
module
.
exports
=
classNames
;
}
else
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
]
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
classNames
;
}
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
window
.
classNames
=
classNames
;
}
}
(
)
)
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseGet
=
__webpack_require__
(
62
)
;
function
get
(
object
path
defaultValue
)
{
var
result
=
object
=
=
null
?
undefined
:
baseGet
(
object
path
)
;
return
result
=
=
=
undefined
?
defaultValue
:
result
;
}
module
.
exports
=
get
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
castPath
=
__webpack_require__
(
22
)
toKey
=
__webpack_require__
(
25
)
;
function
baseGet
(
object
path
)
{
path
=
castPath
(
path
object
)
;
var
index
=
0
length
=
path
.
length
;
while
(
object
!
=
null
&
&
index
<
length
)
{
object
=
object
[
toKey
(
path
[
index
+
+
]
)
]
;
}
return
(
index
&
&
index
=
=
length
)
?
object
:
undefined
;
}
module
.
exports
=
baseGet
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
5
)
isSymbol
=
__webpack_require__
(
11
)
;
var
reIsDeepProp
=
/
\
.
|
\
[
(
?
:
[
^
[
\
]
]
*
|
(
[
"
'
]
)
(
?
:
(
?
!
\
1
)
[
^
\
\
]
|
\
\
.
)
*
?
\
1
)
\
]
/
reIsPlainProp
=
/
^
\
w
*
/
;
function
isKey
(
value
object
)
{
if
(
isArray
(
value
)
)
{
return
false
;
}
var
type
=
typeof
value
;
if
(
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
|
|
value
=
=
null
|
|
isSymbol
(
value
)
)
{
return
true
;
}
return
reIsPlainProp
.
test
(
value
)
|
|
!
reIsDeepProp
.
test
(
value
)
|
|
(
object
!
=
null
&
&
value
in
Object
(
object
)
)
;
}
module
.
exports
=
isKey
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
)
{
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
&
&
global
.
Object
=
=
=
Object
&
&
global
;
module
.
exports
=
freeGlobal
;
}
.
call
(
exports
__webpack_require__
(
65
)
)
)
}
)
(
function
(
module
exports
)
{
var
g
;
g
=
(
function
(
)
{
return
this
;
}
)
(
)
;
try
{
g
=
g
|
|
Function
(
"
return
this
"
)
(
)
|
|
(
1
eval
)
(
"
this
"
)
;
}
catch
(
e
)
{
if
(
typeof
window
=
=
=
"
object
"
)
g
=
window
;
}
module
.
exports
=
g
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
13
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
nativeObjectToString
=
objectProto
.
toString
;
var
symToStringTag
=
Symbol
?
Symbol
.
toStringTag
:
undefined
;
function
getRawTag
(
value
)
{
var
isOwn
=
hasOwnProperty
.
call
(
value
symToStringTag
)
tag
=
value
[
symToStringTag
]
;
try
{
value
[
symToStringTag
]
=
undefined
;
var
unmasked
=
true
;
}
catch
(
e
)
{
}
var
result
=
nativeObjectToString
.
call
(
value
)
;
if
(
unmasked
)
{
if
(
isOwn
)
{
value
[
symToStringTag
]
=
tag
;
}
else
{
delete
value
[
symToStringTag
]
;
}
}
return
result
;
}
module
.
exports
=
getRawTag
;
}
)
(
function
(
module
exports
)
{
var
objectProto
=
Object
.
prototype
;
var
nativeObjectToString
=
objectProto
.
toString
;
function
objectToString
(
value
)
{
return
nativeObjectToString
.
call
(
value
)
;
}
module
.
exports
=
objectToString
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
memoizeCapped
=
__webpack_require__
(
69
)
;
var
reLeadingDot
=
/
^
\
.
/
rePropName
=
/
[
^
.
[
\
]
]
+
|
\
[
(
?
:
(
-
?
\
d
+
(
?
:
\
.
\
d
+
)
?
)
|
(
[
"
'
]
)
(
(
?
:
(
?
!
\
2
)
[
^
\
\
]
|
\
\
.
)
*
?
)
\
2
)
\
]
|
(
?
=
(
?
:
\
.
|
\
[
\
]
)
(
?
:
\
.
|
\
[
\
]
|
)
)
/
g
;
var
reEscapeChar
=
/
\
\
(
\
\
)
?
/
g
;
var
stringToPath
=
memoizeCapped
(
function
(
string
)
{
var
result
=
[
]
;
if
(
reLeadingDot
.
test
(
string
)
)
{
result
.
push
(
'
'
)
;
}
string
.
replace
(
rePropName
function
(
match
number
quote
string
)
{
result
.
push
(
quote
?
string
.
replace
(
reEscapeChar
'
1
'
)
:
(
number
|
|
match
)
)
;
}
)
;
return
result
;
}
)
;
module
.
exports
=
stringToPath
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
memoize
=
__webpack_require__
(
70
)
;
var
MAX_MEMOIZE_SIZE
=
500
;
function
memoizeCapped
(
func
)
{
var
result
=
memoize
(
func
function
(
key
)
{
if
(
cache
.
size
=
=
=
MAX_MEMOIZE_SIZE
)
{
cache
.
clear
(
)
;
}
return
key
;
}
)
;
var
cache
=
result
.
cache
;
return
result
;
}
module
.
exports
=
memoizeCapped
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
MapCache
=
__webpack_require__
(
71
)
;
var
FUNC_ERROR_TEXT
=
'
Expected
a
function
'
;
function
memoize
(
func
resolver
)
{
if
(
typeof
func
!
=
'
function
'
|
|
(
resolver
!
=
null
&
&
typeof
resolver
!
=
'
function
'
)
)
{
throw
new
TypeError
(
FUNC_ERROR_TEXT
)
;
}
var
memoized
=
function
(
)
{
var
args
=
arguments
key
=
resolver
?
resolver
.
apply
(
this
args
)
:
args
[
0
]
cache
=
memoized
.
cache
;
if
(
cache
.
has
(
key
)
)
{
return
cache
.
get
(
key
)
;
}
var
result
=
func
.
apply
(
this
args
)
;
memoized
.
cache
=
cache
.
set
(
key
result
)
|
|
cache
;
return
result
;
}
;
memoized
.
cache
=
new
(
memoize
.
Cache
|
|
MapCache
)
;
return
memoized
;
}
memoize
.
Cache
=
MapCache
;
module
.
exports
=
memoize
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
mapCacheClear
=
__webpack_require__
(
72
)
mapCacheDelete
=
__webpack_require__
(
93
)
mapCacheGet
=
__webpack_require__
(
95
)
mapCacheHas
=
__webpack_require__
(
96
)
mapCacheSet
=
__webpack_require__
(
97
)
;
function
MapCache
(
entries
)
{
var
index
=
-
1
length
=
entries
=
=
null
?
0
:
entries
.
length
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
MapCache
.
prototype
.
clear
=
mapCacheClear
;
MapCache
.
prototype
[
'
delete
'
]
=
mapCacheDelete
;
MapCache
.
prototype
.
get
=
mapCacheGet
;
MapCache
.
prototype
.
has
=
mapCacheHas
;
MapCache
.
prototype
.
set
=
mapCacheSet
;
module
.
exports
=
MapCache
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
Hash
=
__webpack_require__
(
73
)
ListCache
=
__webpack_require__
(
85
)
Map
=
__webpack_require__
(
92
)
;
function
mapCacheClear
(
)
{
this
.
size
=
0
;
this
.
__data__
=
{
'
hash
'
:
new
Hash
'
map
'
:
new
(
Map
|
|
ListCache
)
'
string
'
:
new
Hash
}
;
}
module
.
exports
=
mapCacheClear
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
hashClear
=
__webpack_require__
(
74
)
hashDelete
=
__webpack_require__
(
81
)
hashGet
=
__webpack_require__
(
82
)
hashHas
=
__webpack_require__
(
83
)
hashSet
=
__webpack_require__
(
84
)
;
function
Hash
(
entries
)
{
var
index
=
-
1
length
=
entries
=
=
null
?
0
:
entries
.
length
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
Hash
.
prototype
.
clear
=
hashClear
;
Hash
.
prototype
[
'
delete
'
]
=
hashDelete
;
Hash
.
prototype
.
get
=
hashGet
;
Hash
.
prototype
.
has
=
hashHas
;
Hash
.
prototype
.
set
=
hashSet
;
module
.
exports
=
Hash
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
6
)
;
function
hashClear
(
)
{
this
.
__data__
=
nativeCreate
?
nativeCreate
(
null
)
:
{
}
;
this
.
size
=
0
;
}
module
.
exports
=
hashClear
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
76
)
isMasked
=
__webpack_require__
(
77
)
isObject
=
__webpack_require__
(
24
)
toSource
=
__webpack_require__
(
79
)
;
var
reRegExpChar
=
/
[
\
\
^
.
*
+
?
(
)
[
\
]
{
}
|
]
/
g
;
var
reIsHostCtor
=
/
^
\
[
object
.
+
?
Constructor
\
]
/
;
var
funcProto
=
Function
.
prototype
objectProto
=
Object
.
prototype
;
var
funcToString
=
funcProto
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
reIsNative
=
RegExp
(
'
^
'
+
funcToString
.
call
(
hasOwnProperty
)
.
replace
(
reRegExpChar
'
\
\
&
'
)
.
replace
(
/
hasOwnProperty
|
(
function
)
.
*
?
(
?
=
\
\
\
(
)
|
for
.
+
?
(
?
=
\
\
\
]
)
/
g
'
1
.
*
?
'
)
+
'
'
)
;
function
baseIsNative
(
value
)
{
if
(
!
isObject
(
value
)
|
|
isMasked
(
value
)
)
{
return
false
;
}
var
pattern
=
isFunction
(
value
)
?
reIsNative
:
reIsHostCtor
;
return
pattern
.
test
(
toSource
(
value
)
)
;
}
module
.
exports
=
baseIsNative
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseGetTag
=
__webpack_require__
(
12
)
isObject
=
__webpack_require__
(
24
)
;
var
asyncTag
=
'
[
object
AsyncFunction
]
'
funcTag
=
'
[
object
Function
]
'
genTag
=
'
[
object
GeneratorFunction
]
'
proxyTag
=
'
[
object
Proxy
]
'
;
function
isFunction
(
value
)
{
if
(
!
isObject
(
value
)
)
{
return
false
;
}
var
tag
=
baseGetTag
(
value
)
;
return
tag
=
=
funcTag
|
|
tag
=
=
genTag
|
|
tag
=
=
asyncTag
|
|
tag
=
=
proxyTag
;
}
module
.
exports
=
isFunction
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
coreJsData
=
__webpack_require__
(
78
)
;
var
maskSrcKey
=
(
function
(
)
{
var
uid
=
/
[
^
.
]
+
/
.
exec
(
coreJsData
&
&
coreJsData
.
keys
&
&
coreJsData
.
keys
.
IE_PROTO
|
|
'
'
)
;
return
uid
?
(
'
Symbol
(
src
)
_1
.
'
+
uid
)
:
'
'
;
}
(
)
)
;
function
isMasked
(
func
)
{
return
!
!
maskSrcKey
&
&
(
maskSrcKey
in
func
)
;
}
module
.
exports
=
isMasked
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
14
)
;
var
coreJsData
=
root
[
'
__core
-
js_shared__
'
]
;
module
.
exports
=
coreJsData
;
}
)
(
function
(
module
exports
)
{
var
funcProto
=
Function
.
prototype
;
var
funcToString
=
funcProto
.
toString
;
function
toSource
(
func
)
{
if
(
func
!
=
null
)
{
try
{
return
funcToString
.
call
(
func
)
;
}
catch
(
e
)
{
}
try
{
return
(
func
+
'
'
)
;
}
catch
(
e
)
{
}
}
return
'
'
;
}
module
.
exports
=
toSource
;
}
)
(
function
(
module
exports
)
{
function
getValue
(
object
key
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
module
.
exports
=
getValue
;
}
)
(
function
(
module
exports
)
{
function
hashDelete
(
key
)
{
var
result
=
this
.
has
(
key
)
&
&
delete
this
.
__data__
[
key
]
;
this
.
size
-
=
result
?
1
:
0
;
return
result
;
}
module
.
exports
=
hashDelete
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
6
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashGet
(
key
)
{
var
data
=
this
.
__data__
;
if
(
nativeCreate
)
{
var
result
=
data
[
key
]
;
return
result
=
=
=
HASH_UNDEFINED
?
undefined
:
result
;
}
return
hasOwnProperty
.
call
(
data
key
)
?
data
[
key
]
:
undefined
;
}
module
.
exports
=
hashGet
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
6
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashHas
(
key
)
{
var
data
=
this
.
__data__
;
return
nativeCreate
?
(
data
[
key
]
!
=
=
undefined
)
:
hasOwnProperty
.
call
(
data
key
)
;
}
module
.
exports
=
hashHas
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
6
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
function
hashSet
(
key
value
)
{
var
data
=
this
.
__data__
;
this
.
size
+
=
this
.
has
(
key
)
?
0
:
1
;
data
[
key
]
=
(
nativeCreate
&
&
value
=
=
=
undefined
)
?
HASH_UNDEFINED
:
value
;
return
this
;
}
module
.
exports
=
hashSet
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
listCacheClear
=
__webpack_require__
(
86
)
listCacheDelete
=
__webpack_require__
(
87
)
listCacheGet
=
__webpack_require__
(
89
)
listCacheHas
=
__webpack_require__
(
90
)
listCacheSet
=
__webpack_require__
(
91
)
;
function
ListCache
(
entries
)
{
var
index
=
-
1
length
=
entries
=
=
null
?
0
:
entries
.
length
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
ListCache
.
prototype
.
clear
=
listCacheClear
;
ListCache
.
prototype
[
'
delete
'
]
=
listCacheDelete
;
ListCache
.
prototype
.
get
=
listCacheGet
;
ListCache
.
prototype
.
has
=
listCacheHas
;
ListCache
.
prototype
.
set
=
listCacheSet
;
module
.
exports
=
ListCache
;
}
)
(
function
(
module
exports
)
{
function
listCacheClear
(
)
{
this
.
__data__
=
[
]
;
this
.
size
=
0
;
}
module
.
exports
=
listCacheClear
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
7
)
;
var
arrayProto
=
Array
.
prototype
;
var
splice
=
arrayProto
.
splice
;
function
listCacheDelete
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
return
false
;
}
var
lastIndex
=
data
.
length
-
1
;
if
(
index
=
=
lastIndex
)
{
data
.
pop
(
)
;
}
else
{
splice
.
call
(
data
index
1
)
;
}
-
-
this
.
size
;
return
true
;
}
module
.
exports
=
listCacheDelete
;
}
)
(
function
(
module
exports
)
{
function
eq
(
value
other
)
{
return
value
=
=
=
other
|
|
(
value
!
=
=
value
&
&
other
!
=
=
other
)
;
}
module
.
exports
=
eq
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
7
)
;
function
listCacheGet
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
return
index
<
0
?
undefined
:
data
[
index
]
[
1
]
;
}
module
.
exports
=
listCacheGet
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
7
)
;
function
listCacheHas
(
key
)
{
return
assocIndexOf
(
this
.
__data__
key
)
>
-
1
;
}
module
.
exports
=
listCacheHas
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
7
)
;
function
listCacheSet
(
key
value
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
+
+
this
.
size
;
data
.
push
(
[
key
value
]
)
;
}
else
{
data
[
index
]
[
1
]
=
value
;
}
return
this
;
}
module
.
exports
=
listCacheSet
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
23
)
root
=
__webpack_require__
(
14
)
;
var
Map
=
getNative
(
root
'
Map
'
)
;
module
.
exports
=
Map
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
8
)
;
function
mapCacheDelete
(
key
)
{
var
result
=
getMapData
(
this
key
)
[
'
delete
'
]
(
key
)
;
this
.
size
-
=
result
?
1
:
0
;
return
result
;
}
module
.
exports
=
mapCacheDelete
;
}
)
(
function
(
module
exports
)
{
function
isKeyable
(
value
)
{
var
type
=
typeof
value
;
return
(
type
=
=
'
string
'
|
|
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
)
?
(
value
!
=
=
'
__proto__
'
)
:
(
value
=
=
=
null
)
;
}
module
.
exports
=
isKeyable
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
8
)
;
function
mapCacheGet
(
key
)
{
return
getMapData
(
this
key
)
.
get
(
key
)
;
}
module
.
exports
=
mapCacheGet
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
8
)
;
function
mapCacheHas
(
key
)
{
return
getMapData
(
this
key
)
.
has
(
key
)
;
}
module
.
exports
=
mapCacheHas
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
8
)
;
function
mapCacheSet
(
key
value
)
{
var
data
=
getMapData
(
this
key
)
size
=
data
.
size
;
data
.
set
(
key
value
)
;
this
.
size
+
=
data
.
size
=
=
size
?
0
:
1
;
return
this
;
}
module
.
exports
=
mapCacheSet
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseToString
=
__webpack_require__
(
99
)
;
function
toString
(
value
)
{
return
value
=
=
null
?
'
'
:
baseToString
(
value
)
;
}
module
.
exports
=
toString
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
13
)
arrayMap
=
__webpack_require__
(
100
)
isArray
=
__webpack_require__
(
5
)
isSymbol
=
__webpack_require__
(
11
)
;
var
INFINITY
=
1
/
0
;
var
symbolProto
=
Symbol
?
Symbol
.
prototype
:
undefined
symbolToString
=
symbolProto
?
symbolProto
.
toString
:
undefined
;
function
baseToString
(
value
)
{
if
(
typeof
value
=
=
'
string
'
)
{
return
value
;
}
if
(
isArray
(
value
)
)
{
return
arrayMap
(
value
baseToString
)
+
'
'
;
}
if
(
isSymbol
(
value
)
)
{
return
symbolToString
?
symbolToString
.
call
(
value
)
:
'
'
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
baseToString
;
}
)
(
function
(
module
exports
)
{
function
arrayMap
(
array
iteratee
)
{
var
index
=
-
1
length
=
array
=
=
null
?
0
:
array
.
length
result
=
Array
(
length
)
;
while
(
+
+
index
<
length
)
{
result
[
index
]
=
iteratee
(
array
[
index
]
index
array
)
;
}
return
result
;
}
module
.
exports
=
arrayMap
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseHas
=
__webpack_require__
(
102
)
hasPath
=
__webpack_require__
(
103
)
;
function
has
(
object
path
)
{
return
object
!
=
null
&
&
hasPath
(
object
path
baseHas
)
;
}
module
.
exports
=
has
;
}
)
(
function
(
module
exports
)
{
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
baseHas
(
object
key
)
{
return
object
!
=
null
&
&
hasOwnProperty
.
call
(
object
key
)
;
}
module
.
exports
=
baseHas
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
castPath
=
__webpack_require__
(
22
)
isArguments
=
__webpack_require__
(
104
)
isArray
=
__webpack_require__
(
5
)
isIndex
=
__webpack_require__
(
106
)
isLength
=
__webpack_require__
(
107
)
toKey
=
__webpack_require__
(
25
)
;
function
hasPath
(
object
path
hasFunc
)
{
path
=
castPath
(
path
object
)
;
var
index
=
-
1
length
=
path
.
length
result
=
false
;
while
(
+
+
index
<
length
)
{
var
key
=
toKey
(
path
[
index
]
)
;
if
(
!
(
result
=
object
!
=
null
&
&
hasFunc
(
object
key
)
)
)
{
break
;
}
object
=
object
[
key
]
;
}
if
(
result
|
|
+
+
index
!
=
length
)
{
return
result
;
}
length
=
object
=
=
null
?
0
:
object
.
length
;
return
!
!
length
&
&
isLength
(
length
)
&
&
isIndex
(
key
length
)
&
&
(
isArray
(
object
)
|
|
isArguments
(
object
)
)
;
}
module
.
exports
=
hasPath
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseIsArguments
=
__webpack_require__
(
105
)
isObjectLike
=
__webpack_require__
(
15
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
propertyIsEnumerable
=
objectProto
.
propertyIsEnumerable
;
var
isArguments
=
baseIsArguments
(
function
(
)
{
return
arguments
;
}
(
)
)
?
baseIsArguments
:
function
(
value
)
{
return
isObjectLike
(
value
)
&
&
hasOwnProperty
.
call
(
value
'
callee
'
)
&
&
!
propertyIsEnumerable
.
call
(
value
'
callee
'
)
;
}
;
module
.
exports
=
isArguments
;
}
)
(
function
(
module
exports
__webpack_require__
)
{
var
baseGetTag
=
__webpack_require__
(
12
)
isObjectLike
=
__webpack_require__
(
15
)
;
var
argsTag
=
'
[
object
Arguments
]
'
;
function
baseIsArguments
(
value
)
{
return
isObjectLike
(
value
)
&
&
baseGetTag
(
value
)
=
=
argsTag
;
}
module
.
exports
=
baseIsArguments
;
}
)
(
function
(
module
exports
)
{
var
MAX_SAFE_INTEGER
=
9007199254740991
;
var
reIsUint
=
/
^
(
?
:
0
|
[
1
-
9
]
\
d
*
)
/
;
function
isIndex
(
value
length
)
{
length
=
length
=
=
null
?
MAX_SAFE_INTEGER
:
length
;
return
!
!
length
&
&
(
typeof
value
=
=
'
number
'
|
|
reIsUint
.
test
(
value
)
)
&
&
(
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
length
)
;
}
module
.
exports
=
isIndex
;
}
)
(
function
(
module
exports
)
{
var
MAX_SAFE_INTEGER
=
9007199254740991
;
function
isLength
(
value
)
{
return
typeof
value
=
=
'
number
'
&
&
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
=
MAX_SAFE_INTEGER
;
}
module
.
exports
=
isLength
;
}
)
]
)
;
}
)
;
