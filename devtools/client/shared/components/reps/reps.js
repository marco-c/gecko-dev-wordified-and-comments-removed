(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
factory
)
;
else
{
var
a
=
typeof
exports
=
=
=
'
object
'
?
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
)
:
factory
(
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
this
function
(
__WEBPACK_EXTERNAL_MODULE_3__
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
exports
:
{
}
id
:
moduleId
loaded
:
false
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
0
)
;
}
)
(
[
function
(
module
exports
__webpack_require__
)
{
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
REPS
}
=
__webpack_require__
(
2
)
;
const
{
createFactories
parseURLEncodedText
parseURLParams
getSelectableInInspectorGrips
maybeEscapePropertyName
}
=
__webpack_require__
(
4
)
;
module
.
exports
=
{
REPS
MODE
createFactories
maybeEscapePropertyName
parseURLEncodedText
parseURLParams
getSelectableInInspectorGrips
}
;
}
function
(
module
exports
)
{
module
.
exports
=
{
MODE
:
{
TINY
:
Symbol
(
"
TINY
"
)
SHORT
:
Symbol
(
"
SHORT
"
)
LONG
:
Symbol
(
"
LONG
"
)
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
}
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
Undefined
=
__webpack_require__
(
6
)
;
const
Null
=
__webpack_require__
(
7
)
;
const
StringRep
=
__webpack_require__
(
8
)
;
const
LongStringRep
=
__webpack_require__
(
9
)
;
const
Number
=
__webpack_require__
(
10
)
;
const
ArrayRep
=
__webpack_require__
(
11
)
;
const
Obj
=
__webpack_require__
(
13
)
;
const
SymbolRep
=
__webpack_require__
(
16
)
;
const
InfinityRep
=
__webpack_require__
(
17
)
;
const
NaNRep
=
__webpack_require__
(
18
)
;
const
Attribute
=
__webpack_require__
(
19
)
;
const
DateTime
=
__webpack_require__
(
20
)
;
const
Document
=
__webpack_require__
(
21
)
;
const
Event
=
__webpack_require__
(
22
)
;
const
Func
=
__webpack_require__
(
23
)
;
const
PromiseRep
=
__webpack_require__
(
24
)
;
const
RegExp
=
__webpack_require__
(
25
)
;
const
StyleSheet
=
__webpack_require__
(
26
)
;
const
CommentNode
=
__webpack_require__
(
27
)
;
const
ElementNode
=
__webpack_require__
(
28
)
;
const
TextNode
=
__webpack_require__
(
32
)
;
const
ErrorRep
=
__webpack_require__
(
33
)
;
const
Window
=
__webpack_require__
(
34
)
;
const
ObjectWithText
=
__webpack_require__
(
35
)
;
const
ObjectWithURL
=
__webpack_require__
(
36
)
;
const
GripArray
=
__webpack_require__
(
37
)
;
const
GripMap
=
__webpack_require__
(
38
)
;
const
Grip
=
__webpack_require__
(
15
)
;
let
reps
=
[
RegExp
StyleSheet
Event
DateTime
CommentNode
ElementNode
TextNode
Attribute
LongStringRep
Func
PromiseRep
ArrayRep
Document
Window
ObjectWithText
ObjectWithURL
ErrorRep
GripArray
GripMap
Grip
Undefined
Null
StringRep
Number
SymbolRep
InfinityRep
NaNRep
]
;
const
Rep
=
React
.
createClass
(
{
displayName
:
"
Rep
"
propTypes
:
{
object
:
React
.
PropTypes
.
any
defaultRep
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
}
render
:
function
(
)
{
let
rep
=
getRep
(
this
.
props
.
object
this
.
props
.
defaultRep
)
;
return
rep
(
this
.
props
)
;
}
}
)
;
function
getRep
(
object
defaultRep
=
Obj
)
{
let
type
=
typeof
object
;
if
(
type
=
=
"
object
"
&
&
object
instanceof
String
)
{
type
=
"
string
"
;
}
else
if
(
object
&
&
type
=
=
"
object
"
&
&
object
.
type
)
{
type
=
object
.
type
;
}
if
(
isGrip
(
object
)
)
{
type
=
object
.
class
;
}
for
(
let
i
=
0
;
i
<
reps
.
length
;
i
+
+
)
{
let
rep
=
reps
[
i
]
;
try
{
if
(
rep
.
supportsObject
(
object
type
)
)
{
return
React
.
createFactory
(
rep
.
rep
)
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
}
return
React
.
createFactory
(
defaultRep
.
rep
)
;
}
module
.
exports
=
{
Rep
REPS
:
{
ArrayRep
Attribute
CommentNode
DateTime
Document
ElementNode
ErrorRep
Event
Func
Grip
GripArray
GripMap
InfinityRep
LongStringRep
NaNRep
Null
Number
Obj
ObjectWithText
ObjectWithURL
PromiseRep
RegExp
Rep
StringRep
StyleSheet
SymbolRep
TextNode
Undefined
Window
}
}
;
}
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_3__
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
nodeConstants
=
__webpack_require__
(
5
)
;
function
createFactories
(
args
)
{
let
result
=
{
}
;
for
(
let
p
in
args
)
{
result
[
p
]
=
React
.
createFactory
(
args
[
p
]
)
;
}
return
result
;
}
function
isGrip
(
object
)
{
return
object
&
&
object
.
actor
;
}
function
escapeNewLines
(
value
)
{
return
value
.
replace
(
/
\
r
/
gm
"
\
\
r
"
)
.
replace
(
/
\
n
/
gm
"
\
\
n
"
)
;
}
const
escapeMap
=
{
9
:
"
\
\
t
"
0xa
:
"
\
\
n
"
0xd
:
"
\
\
r
"
0x22
:
"
\
\
\
"
"
0x5c
:
"
\
\
\
\
"
}
;
const
escapeRegexp
=
new
RegExp
(
"
[
"
+
"
\
"
\
\
\
\
"
+
"
\
x00
-
\
x1f
"
+
"
\
x7f
-
\
x9f
"
+
"
\
ufeff
"
+
"
\
ufffc
-
\
uffff
"
+
"
\
ud800
-
\
udfff
"
+
"
\
u2061
-
\
u2064
"
+
"
\
u2028
-
\
u2029
"
+
"
\
ue000
-
\
uf8ff
"
+
"
]
"
"
g
"
)
;
function
escapeString
(
str
)
{
return
"
\
"
"
+
str
.
replace
(
escapeRegexp
(
match
offset
)
=
>
{
let
c
=
match
.
charCodeAt
(
0
)
;
if
(
c
in
escapeMap
)
{
return
escapeMap
[
c
]
;
}
if
(
c
>
=
0xd800
&
&
c
<
=
0xdfff
)
{
if
(
c
>
=
0xdc00
&
&
offset
>
0
)
{
-
-
offset
;
}
let
codePoint
=
str
.
codePointAt
(
offset
)
;
if
(
codePoint
>
=
0xd800
&
&
codePoint
<
=
0xdfff
)
{
return
"
\
\
u
"
+
codePoint
.
toString
(
16
)
;
}
else
if
(
codePoint
>
=
0xf0000
&
&
codePoint
<
=
0x10fffd
)
{
if
(
c
<
=
0xdbff
)
{
return
"
\
\
u
{
"
+
codePoint
.
toString
(
16
)
+
"
}
"
;
}
return
"
"
;
}
return
match
;
}
return
"
\
\
u
"
+
(
"
0000
"
+
c
.
toString
(
16
)
)
.
substr
(
-
4
)
;
}
)
+
"
\
"
"
;
}
function
maybeEscapePropertyName
(
name
)
{
if
(
!
/
^
\
w
+
/
.
test
(
name
)
)
{
name
=
escapeString
(
name
)
;
}
return
name
;
}
function
cropMultipleLines
(
text
limit
)
{
return
escapeNewLines
(
cropString
(
text
limit
)
)
;
}
function
rawCropString
(
text
limit
alternativeText
)
{
if
(
!
alternativeText
)
{
alternativeText
=
"
\
u2026
"
;
}
if
(
!
limit
|
|
limit
<
=
0
)
{
return
text
;
}
if
(
limit
<
=
alternativeText
.
length
)
{
limit
=
alternativeText
.
length
+
1
;
}
let
halfLimit
=
(
limit
-
alternativeText
.
length
)
/
2
;
if
(
text
.
length
>
limit
)
{
return
text
.
substr
(
0
Math
.
ceil
(
halfLimit
)
)
+
alternativeText
+
text
.
substr
(
text
.
length
-
Math
.
floor
(
halfLimit
)
)
;
}
return
text
;
}
function
cropString
(
text
limit
alternativeText
)
{
return
rawCropString
(
sanitizeString
(
text
+
"
"
)
limit
alternativeText
)
;
}
function
sanitizeString
(
text
)
{
let
re
=
new
RegExp
(
"
[
\
x00
-
\
x08
\
x0B
\
x0C
\
x0E
-
\
x1F
\
x7F
-
\
x9F
]
"
"
g
"
)
;
return
text
.
replace
(
re
"
\
ufffd
"
)
;
}
function
parseURLParams
(
url
)
{
url
=
new
URL
(
url
)
;
return
parseURLEncodedText
(
url
.
searchParams
)
;
}
function
parseURLEncodedText
(
text
)
{
let
params
=
[
]
;
if
(
text
=
=
"
"
)
{
return
params
;
}
let
searchParams
=
new
URLSearchParams
(
text
)
;
let
entries
=
[
.
.
.
searchParams
.
entries
(
)
]
;
return
entries
.
map
(
entry
=
>
{
return
{
name
:
entry
[
0
]
value
:
entry
[
1
]
}
;
}
)
;
}
function
getFileName
(
url
)
{
let
split
=
splitURLBase
(
url
)
;
return
split
.
name
;
}
function
splitURLBase
(
url
)
{
if
(
!
isDataURL
(
url
)
)
{
return
splitURLTrue
(
url
)
;
}
return
{
}
;
}
function
getURLDisplayString
(
url
)
{
return
cropString
(
url
)
;
}
function
isDataURL
(
url
)
{
return
url
&
&
url
.
substr
(
0
5
)
=
=
"
data
:
"
;
}
function
splitURLTrue
(
url
)
{
const
reSplitFile
=
/
(
.
*
?
)
:
\
/
{
2
3
}
(
[
^
\
/
]
*
)
(
.
*
?
)
(
[
^
\
/
]
*
?
)
(
|
\
?
.
*
)
/
;
let
m
=
reSplitFile
.
exec
(
url
)
;
if
(
!
m
)
{
return
{
name
:
url
path
:
url
}
;
}
else
if
(
m
[
4
]
=
=
"
"
&
&
m
[
5
]
=
=
"
"
)
{
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
3
]
name
:
m
[
3
]
!
=
"
/
"
?
m
[
3
]
:
m
[
2
]
}
;
}
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
2
]
+
m
[
3
]
name
:
m
[
4
]
+
m
[
5
]
}
;
}
function
wrapRender
(
renderMethod
)
{
return
function
(
)
{
try
{
return
renderMethod
.
call
(
this
)
;
}
catch
(
e
)
{
return
React
.
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
failure
"
title
:
"
This
object
could
not
be
rendered
"
+
"
please
file
a
bug
on
bugzilla
.
mozilla
.
org
"
}
"
Invalid
object
"
)
;
}
}
;
}
function
getSelectableInInspectorGrips
(
grip
)
{
let
grips
=
new
Set
(
getFlattenedGrips
(
[
grip
]
)
)
;
return
[
.
.
.
grips
]
.
filter
(
isGripSelectableInInspector
)
;
}
function
isGripSelectableInInspector
(
grip
)
{
return
grip
&
&
typeof
grip
=
=
=
"
object
"
&
&
grip
.
preview
&
&
[
nodeConstants
.
TEXT_NODE
nodeConstants
.
ELEMENT_NODE
]
.
includes
(
grip
.
preview
.
nodeType
)
;
}
function
getFlattenedGrips
(
grips
)
{
return
grips
.
reduce
(
(
res
grip
)
=
>
{
let
previewItems
=
getGripPreviewItems
(
grip
)
;
let
flatPreviewItems
=
previewItems
.
length
>
0
?
getFlattenedGrips
(
previewItems
)
:
[
]
;
return
[
.
.
.
res
grip
.
.
.
flatPreviewItems
]
;
}
[
]
)
;
}
function
getGripPreviewItems
(
grip
)
{
if
(
!
grip
)
{
return
[
]
;
}
if
(
grip
.
promiseState
&
&
grip
.
promiseState
.
value
)
{
return
[
grip
.
promiseState
.
value
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
items
)
{
return
grip
.
preview
.
items
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
childNodes
)
{
return
grip
.
preview
.
childNodes
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
entries
)
{
return
grip
.
preview
.
entries
.
reduce
(
(
res
entry
)
=
>
res
.
concat
(
entry
)
[
]
)
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
target
)
{
return
[
grip
.
preview
.
target
]
;
}
if
(
grip
.
preview
&
&
grip
.
preview
.
ownProperties
)
{
let
propertiesValues
=
Object
.
values
(
grip
.
preview
.
ownProperties
)
.
map
(
property
=
>
property
.
value
|
|
property
)
;
if
(
grip
.
preview
.
safeGetterValues
)
{
propertiesValues
=
propertiesValues
.
concat
(
Object
.
values
(
grip
.
preview
.
safeGetterValues
)
.
map
(
property
=
>
property
.
getterValue
|
|
property
)
)
;
}
return
propertiesValues
;
}
return
[
]
;
}
module
.
exports
=
{
createFactories
isGrip
cropString
rawCropString
sanitizeString
escapeString
wrapRender
cropMultipleLines
parseURLParams
parseURLEncodedText
getFileName
getURLDisplayString
getSelectableInInspectorGrips
maybeEscapePropertyName
}
;
}
function
(
module
exports
)
{
module
.
exports
=
{
ELEMENT_NODE
:
1
ATTRIBUTE_NODE
:
2
TEXT_NODE
:
3
CDATA_SECTION_NODE
:
4
ENTITY_REFERENCE_NODE
:
5
ENTITY_NODE
:
6
PROCESSING_INSTRUCTION_NODE
:
7
COMMENT_NODE
:
8
DOCUMENT_NODE
:
9
DOCUMENT_TYPE_NODE
:
10
DOCUMENT_FRAGMENT_NODE
:
11
NOTATION_NODE
:
12
DOCUMENT_POSITION_DISCONNECTED
:
0x01
DOCUMENT_POSITION_PRECEDING
:
0x02
DOCUMENT_POSITION_FOLLOWING
:
0x04
DOCUMENT_POSITION_CONTAINS
:
0x08
DOCUMENT_POSITION_CONTAINED_BY
:
0x10
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
:
0x20
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
Undefined
=
React
.
createClass
(
{
displayName
:
"
UndefinedRep
"
render
:
wrapRender
(
function
(
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
undefined
"
}
"
undefined
"
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
undefined
"
)
{
return
true
;
}
return
type
=
=
"
undefined
"
;
}
module
.
exports
=
{
rep
:
Undefined
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
Null
=
React
.
createClass
(
{
displayName
:
"
NullRep
"
render
:
wrapRender
(
function
(
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
null
"
}
"
null
"
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
null
"
)
{
return
true
;
}
return
object
=
=
null
;
}
module
.
exports
=
{
rep
:
Null
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
escapeString
rawCropString
sanitizeString
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
StringRep
=
React
.
createClass
(
{
displayName
:
"
StringRep
"
propTypes
:
{
useQuotes
:
React
.
PropTypes
.
bool
style
:
React
.
PropTypes
.
object
object
:
React
.
PropTypes
.
string
.
isRequired
member
:
React
.
PropTypes
.
any
cropLimit
:
React
.
PropTypes
.
number
}
getDefaultProps
:
function
(
)
{
return
{
useQuotes
:
true
}
;
}
render
:
wrapRender
(
function
(
)
{
let
text
=
this
.
props
.
object
;
let
member
=
this
.
props
.
member
;
let
style
=
this
.
props
.
style
;
let
config
=
{
className
:
"
objectBox
objectBox
-
string
"
}
;
if
(
style
)
{
config
.
style
=
style
;
}
if
(
this
.
props
.
useQuotes
)
{
text
=
escapeString
(
text
)
;
}
else
{
text
=
sanitizeString
(
text
)
;
}
if
(
(
!
member
|
|
!
member
.
open
)
&
&
this
.
props
.
cropLimit
)
{
text
=
rawCropString
(
text
this
.
props
.
cropLimit
)
;
}
return
span
(
config
text
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
return
type
=
=
"
string
"
;
}
module
.
exports
=
{
rep
:
StringRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
escapeString
sanitizeString
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
LongStringRep
=
React
.
createClass
(
{
displayName
:
"
LongStringRep
"
propTypes
:
{
useQuotes
:
React
.
PropTypes
.
bool
style
:
React
.
PropTypes
.
object
cropLimit
:
React
.
PropTypes
.
number
.
isRequired
member
:
React
.
PropTypes
.
string
object
:
React
.
PropTypes
.
object
.
isRequired
}
getDefaultProps
:
function
(
)
{
return
{
useQuotes
:
true
}
;
}
render
:
wrapRender
(
function
(
)
{
let
{
cropLimit
member
object
style
useQuotes
}
=
this
.
props
;
let
{
fullText
initial
length
}
=
object
;
let
config
=
{
className
:
"
objectBox
objectBox
-
string
"
}
;
if
(
style
)
{
config
.
style
=
style
;
}
let
string
=
member
&
&
member
.
open
?
fullText
|
|
initial
:
initial
.
substring
(
0
cropLimit
)
;
if
(
string
.
length
<
length
)
{
string
+
=
"
\
u2026
"
;
}
let
formattedString
=
useQuotes
?
escapeString
(
string
)
:
sanitizeString
(
string
)
;
return
span
(
config
formattedString
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
type
=
=
=
"
longString
"
;
}
module
.
exports
=
{
rep
:
LongStringRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
Number
=
React
.
createClass
(
{
displayName
:
"
Number
"
propTypes
:
{
object
:
React
.
PropTypes
.
oneOfType
(
[
React
.
PropTypes
.
object
React
.
PropTypes
.
number
]
)
.
isRequired
}
stringify
:
function
(
object
)
{
let
isNegativeZero
=
Object
.
is
(
object
-
0
)
|
|
object
.
type
&
&
object
.
type
=
=
"
-
0
"
;
return
isNegativeZero
?
"
-
0
"
:
String
(
object
)
;
}
render
:
wrapRender
(
function
(
)
{
let
value
=
this
.
props
.
object
;
return
span
(
{
className
:
"
objectBox
objectBox
-
number
"
}
this
.
stringify
(
value
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
return
[
"
boolean
"
"
number
"
"
-
0
"
]
.
includes
(
type
)
;
}
module
.
exports
=
{
rep
:
Number
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
createFactories
wrapRender
}
=
__webpack_require__
(
4
)
;
const
Caption
=
React
.
createFactory
(
__webpack_require__
(
12
)
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
ModePropType
=
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
;
const
DOM
=
React
.
DOM
;
let
ArrayRep
=
React
.
createClass
(
{
displayName
:
"
ArrayRep
"
propTypes
:
{
mode
:
ModePropType
objectLink
:
React
.
PropTypes
.
func
object
:
React
.
PropTypes
.
array
.
isRequired
}
getTitle
:
function
(
object
context
)
{
return
"
[
"
+
object
.
length
+
"
]
"
;
}
arrayIterator
:
function
(
array
max
)
{
let
items
=
[
]
;
let
delim
;
for
(
let
i
=
0
;
i
<
array
.
length
&
&
i
<
max
;
i
+
+
)
{
try
{
let
value
=
array
[
i
]
;
delim
=
i
=
=
array
.
length
-
1
?
"
"
:
"
"
;
items
.
push
(
ItemRep
(
{
object
:
value
mode
:
MODE
.
TINY
delim
:
delim
}
)
)
;
}
catch
(
exc
)
{
items
.
push
(
ItemRep
(
{
object
:
exc
mode
:
MODE
.
TINY
delim
:
delim
}
)
)
;
}
}
if
(
array
.
length
>
max
)
{
let
objectLink
=
this
.
props
.
objectLink
|
|
DOM
.
span
;
items
.
push
(
Caption
(
{
object
:
objectLink
(
{
object
:
this
.
props
.
object
}
array
.
length
-
max
+
"
more
"
)
}
)
)
;
}
return
items
;
}
hasSpecialProperties
:
function
(
array
)
{
function
isInteger
(
x
)
{
let
y
=
parseInt
(
x
10
)
;
if
(
isNaN
(
y
)
)
{
return
false
;
}
return
x
=
=
=
y
.
toString
(
)
;
}
let
propsArray
=
Object
.
getOwnPropertyNames
(
array
)
;
for
(
let
i
=
0
;
i
<
propsArray
.
length
;
i
+
+
)
{
let
p
=
propsArray
[
i
]
;
if
(
isInteger
(
p
)
)
{
continue
;
}
if
(
p
!
=
"
length
"
)
{
return
true
;
}
}
return
false
;
}
onToggleProperties
:
function
(
event
)
{
}
onClickBracket
:
function
(
event
)
{
}
render
:
wrapRender
(
function
(
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
this
.
props
;
let
items
;
let
brackets
;
let
needSpace
=
function
(
space
)
{
return
space
?
{
left
:
"
[
"
right
:
"
]
"
}
:
{
left
:
"
[
"
right
:
"
]
"
}
;
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
isEmpty
=
object
.
length
=
=
=
0
;
items
=
[
DOM
.
span
(
{
className
:
"
length
"
}
isEmpty
?
"
"
:
object
.
length
)
]
;
brackets
=
needSpace
(
false
)
;
}
else
{
let
max
=
mode
=
=
=
MODE
.
SHORT
?
3
:
10
;
items
=
this
.
arrayIterator
(
object
max
)
;
brackets
=
needSpace
(
items
.
length
>
0
)
;
}
let
objectLink
=
this
.
props
.
objectLink
|
|
DOM
.
span
;
return
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
array
"
}
objectLink
(
{
className
:
"
arrayLeftBracket
"
object
:
object
}
brackets
.
left
)
.
.
.
items
objectLink
(
{
className
:
"
arrayRightBracket
"
object
:
object
}
brackets
.
right
)
DOM
.
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
;
}
)
}
)
;
let
ItemRep
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
ItemRep
"
propTypes
:
{
object
:
React
.
PropTypes
.
any
.
isRequired
delim
:
React
.
PropTypes
.
string
.
isRequired
mode
:
ModePropType
}
render
:
wrapRender
(
function
(
)
{
const
{
Rep
}
=
createFactories
(
__webpack_require__
(
2
)
)
;
let
object
=
this
.
props
.
object
;
let
delim
=
this
.
props
.
delim
;
let
mode
=
this
.
props
.
mode
;
return
DOM
.
span
(
{
}
Rep
(
{
object
:
object
mode
:
mode
}
)
delim
)
;
}
)
}
)
)
;
function
supportsObject
(
object
type
)
{
return
Array
.
isArray
(
object
)
|
|
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Arguments
]
"
;
}
module
.
exports
=
{
rep
:
ArrayRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
DOM
=
React
.
DOM
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
Caption
=
React
.
createClass
(
{
displayName
:
"
Caption
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
}
render
:
wrapRender
(
function
(
)
{
return
DOM
.
span
(
{
"
className
"
:
"
caption
"
}
this
.
props
.
object
)
;
}
)
}
)
;
module
.
exports
=
Caption
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
Caption
=
React
.
createFactory
(
__webpack_require__
(
12
)
)
;
const
PropRep
=
React
.
createFactory
(
__webpack_require__
(
14
)
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
const
Obj
=
React
.
createClass
(
{
displayName
:
"
Obj
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
objectLink
:
React
.
PropTypes
.
func
title
:
React
.
PropTypes
.
string
}
getTitle
:
function
(
object
)
{
let
title
=
this
.
props
.
title
|
|
object
.
class
|
|
"
Object
"
;
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
:
object
}
title
)
;
}
return
title
;
}
safePropIterator
:
function
(
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
3
:
max
;
try
{
return
this
.
propIterator
(
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
propIterator
:
function
(
object
max
)
{
let
isInterestingProp
=
(
t
value
)
=
>
{
return
t
=
=
"
boolean
"
|
|
t
=
=
"
number
"
|
|
t
=
=
"
string
"
&
&
value
;
}
;
if
(
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Generator
]
"
)
{
object
=
Object
.
getPrototypeOf
(
object
)
;
}
let
propsArray
=
this
.
getPropsArray
(
object
max
isInterestingProp
)
;
if
(
propsArray
.
length
<
=
max
)
{
propsArray
=
propsArray
.
concat
(
this
.
getPropsArray
(
object
max
(
t
value
)
=
>
{
return
!
isInterestingProp
(
t
value
)
;
}
)
)
;
}
if
(
propsArray
.
length
>
max
)
{
propsArray
.
pop
(
)
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
propsArray
.
push
(
Caption
(
{
object
:
objectLink
(
{
object
:
object
}
Object
.
keys
(
object
)
.
length
-
max
+
"
more
"
)
}
)
)
;
}
else
if
(
propsArray
.
length
>
0
)
{
propsArray
[
propsArray
.
length
-
1
]
=
React
.
cloneElement
(
propsArray
[
propsArray
.
length
-
1
]
{
delim
:
"
"
}
)
;
}
return
propsArray
;
}
getPropsArray
:
function
(
object
max
filter
)
{
let
propsArray
=
[
]
;
max
=
max
|
|
3
;
if
(
!
object
)
{
return
propsArray
;
}
let
mode
=
MODE
.
TINY
;
try
{
for
(
let
name
in
object
)
{
if
(
propsArray
.
length
>
max
)
{
return
propsArray
;
}
let
value
;
try
{
value
=
object
[
name
]
;
}
catch
(
exc
)
{
continue
;
}
let
t
=
typeof
value
;
if
(
filter
(
t
value
)
)
{
propsArray
.
push
(
PropRep
(
{
mode
:
mode
name
:
name
object
:
value
equal
:
"
:
"
delim
:
"
"
}
)
)
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
propsArray
;
}
render
:
wrapRender
(
function
(
)
{
let
object
=
this
.
props
.
object
;
let
propsArray
=
this
.
safePropIterator
(
object
)
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
if
(
this
.
props
.
mode
=
=
=
MODE
.
TINY
|
|
!
propsArray
.
length
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
objectLink
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
object
)
)
)
;
}
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
:
object
}
"
{
"
)
.
.
.
propsArray
objectLink
(
{
className
:
"
objectRightBrace
"
object
:
object
}
"
}
"
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
return
true
;
}
module
.
exports
=
{
rep
:
Obj
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
createFactories
maybeEscapePropertyName
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
let
PropRep
=
React
.
createClass
(
{
displayName
:
"
PropRep
"
propTypes
:
{
name
:
React
.
PropTypes
.
oneOfType
(
[
React
.
PropTypes
.
string
React
.
PropTypes
.
object
]
)
.
isRequired
equal
:
React
.
PropTypes
.
string
delim
:
React
.
PropTypes
.
string
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
objectLink
:
React
.
PropTypes
.
func
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
suppressQuotes
:
React
.
PropTypes
.
bool
}
render
:
wrapRender
(
function
(
)
{
const
Grip
=
__webpack_require__
(
15
)
;
let
{
Rep
}
=
createFactories
(
__webpack_require__
(
2
)
)
;
let
{
name
mode
equal
delim
suppressQuotes
}
=
this
.
props
;
let
key
;
if
(
typeof
name
=
=
=
"
string
"
)
{
if
(
!
suppressQuotes
)
{
name
=
maybeEscapePropertyName
(
name
)
;
}
key
=
span
(
{
"
className
"
:
"
nodeName
"
}
name
)
;
}
else
{
key
=
Rep
(
Object
.
assign
(
{
}
this
.
props
{
object
:
name
mode
:
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
)
;
}
return
span
(
{
}
key
span
(
{
"
className
"
:
"
objectEqual
"
}
equal
)
Rep
(
Object
.
assign
(
{
}
this
.
props
)
)
span
(
{
"
className
"
:
"
objectComma
"
}
delim
)
)
;
}
)
}
)
;
module
.
exports
=
PropRep
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
createFactories
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
Caption
=
React
.
createFactory
(
__webpack_require__
(
12
)
)
;
const
PropRep
=
React
.
createFactory
(
__webpack_require__
(
14
)
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
const
GripRep
=
React
.
createClass
(
{
displayName
:
"
Grip
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
isInterestingProp
:
React
.
PropTypes
.
func
title
:
React
.
PropTypes
.
string
objectLink
:
React
.
PropTypes
.
func
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
object
)
{
let
title
=
this
.
props
.
title
|
|
object
.
class
|
|
"
Object
"
;
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
:
object
}
title
)
;
}
return
title
;
}
safePropIterator
:
function
(
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
3
:
max
;
try
{
return
this
.
propIterator
(
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
propIterator
:
function
(
object
max
)
{
if
(
object
.
preview
&
&
Object
.
keys
(
object
.
preview
)
.
includes
(
"
wrappedValue
"
)
)
{
const
{
Rep
}
=
createFactories
(
__webpack_require__
(
2
)
)
;
return
[
Rep
(
{
object
:
object
.
preview
.
wrappedValue
mode
:
this
.
props
.
mode
|
|
MODE
.
TINY
defaultRep
:
Grip
}
)
]
;
}
let
isInterestingProp
=
this
.
props
.
isInterestingProp
|
|
(
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
.
length
!
=
0
;
}
)
;
let
properties
=
object
.
preview
?
object
.
preview
.
ownProperties
:
{
}
;
let
propertiesLength
=
object
.
preview
&
&
object
.
preview
.
ownPropertiesLength
?
object
.
preview
.
ownPropertiesLength
:
object
.
ownPropertyLength
;
if
(
object
.
preview
&
&
object
.
preview
.
safeGetterValues
)
{
properties
=
Object
.
assign
(
{
}
properties
object
.
preview
.
safeGetterValues
)
;
propertiesLength
+
=
Object
.
keys
(
object
.
preview
.
safeGetterValues
)
.
length
;
}
let
indexes
=
this
.
getPropIndexes
(
properties
max
isInterestingProp
)
;
if
(
indexes
.
length
<
max
&
&
indexes
.
length
<
propertiesLength
)
{
indexes
=
indexes
.
concat
(
this
.
getPropIndexes
(
properties
max
-
indexes
.
length
(
t
value
name
)
=
>
{
return
!
isInterestingProp
(
t
value
name
)
;
}
)
)
;
}
const
truncate
=
Object
.
keys
(
properties
)
.
length
>
max
;
const
suppressQuotes
=
object
.
class
=
=
=
"
Proxy
"
;
let
propsArray
=
this
.
getProps
(
properties
indexes
truncate
suppressQuotes
)
;
if
(
truncate
)
{
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
propsArray
.
push
(
Caption
(
{
object
:
objectLink
(
{
object
:
object
}
{
propertiesLength
-
max
}
more
)
}
)
)
;
}
return
propsArray
;
}
getProps
:
function
(
properties
indexes
truncate
suppressQuotes
)
{
let
propsArray
=
[
]
;
indexes
.
sort
(
function
(
a
b
)
{
return
a
-
b
;
}
)
;
indexes
.
forEach
(
i
=
>
{
let
name
=
Object
.
keys
(
properties
)
[
i
]
;
let
value
=
this
.
getPropValue
(
properties
[
name
]
)
;
propsArray
.
push
(
PropRep
(
Object
.
assign
(
{
}
this
.
props
{
mode
:
MODE
.
TINY
name
:
name
object
:
value
equal
:
"
:
"
delim
:
i
!
=
=
indexes
.
length
-
1
|
|
truncate
?
"
"
:
"
"
defaultRep
:
Grip
title
:
undefined
suppressQuotes
}
)
)
)
;
}
)
;
return
propsArray
;
}
getPropIndexes
:
function
(
properties
max
filter
)
{
let
indexes
=
[
]
;
try
{
let
i
=
0
;
for
(
let
name
in
properties
)
{
if
(
indexes
.
length
>
=
max
)
{
return
indexes
;
}
let
value
=
this
.
getPropValue
(
properties
[
name
]
)
;
let
type
=
value
.
class
|
|
typeof
value
;
type
=
type
.
toLowerCase
(
)
;
if
(
filter
(
type
value
name
)
)
{
indexes
.
push
(
i
)
;
}
i
+
+
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
indexes
;
}
getPropValue
:
function
(
property
)
{
let
value
=
property
;
if
(
typeof
property
=
=
=
"
object
"
)
{
let
keys
=
Object
.
keys
(
property
)
;
if
(
keys
.
includes
(
"
value
"
)
)
{
value
=
property
.
value
;
}
else
if
(
keys
.
includes
(
"
getterValue
"
)
)
{
value
=
property
.
getterValue
;
}
}
return
value
;
}
render
:
wrapRender
(
function
(
)
{
let
object
=
this
.
props
.
object
;
let
propsArray
=
this
.
safePropIterator
(
object
this
.
props
.
mode
=
=
=
MODE
.
LONG
?
10
:
3
)
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
if
(
this
.
props
.
mode
=
=
=
MODE
.
TINY
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
:
object
}
"
"
)
)
;
}
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
:
object
}
"
{
"
)
.
.
.
propsArray
objectLink
(
{
className
:
"
objectRightBrace
"
object
:
object
}
"
}
"
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
object
.
preview
.
ownProperties
;
}
let
Grip
=
{
rep
:
GripRep
supportsObject
:
supportsObject
}
;
module
.
exports
=
Grip
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
SymbolRep
=
React
.
createClass
(
{
displayName
:
"
SymbolRep
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
render
:
wrapRender
(
function
(
)
{
let
{
object
}
=
this
.
props
;
let
{
name
}
=
object
;
return
span
(
{
className
:
"
objectBox
objectBox
-
symbol
"
}
Symbol
(
{
name
|
|
"
"
}
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
return
type
=
=
"
symbol
"
;
}
module
.
exports
=
{
rep
:
SymbolRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
InfinityRep
=
React
.
createClass
(
{
displayName
:
"
Infinity
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
render
:
wrapRender
(
function
(
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
number
"
}
this
.
props
.
object
.
type
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
return
type
=
=
"
Infinity
"
|
|
type
=
=
"
-
Infinity
"
;
}
module
.
exports
=
{
rep
:
InfinityRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
const
NaNRep
=
React
.
createClass
(
{
displayName
:
"
NaN
"
render
:
wrapRender
(
function
(
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
nan
"
}
"
NaN
"
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
return
type
=
=
"
NaN
"
;
}
module
.
exports
=
{
rep
:
NaNRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
createFactories
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
StringRep
=
__webpack_require__
(
8
)
;
const
{
span
}
=
React
.
DOM
;
const
{
rep
:
StringRepFactory
}
=
createFactories
(
StringRep
)
;
let
Attribute
=
React
.
createClass
(
{
displayName
:
"
Attr
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
grip
)
{
return
grip
.
preview
.
nodeName
;
}
render
:
wrapRender
(
function
(
)
{
let
object
=
this
.
props
.
object
;
let
value
=
object
.
preview
.
value
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
return
objectLink
(
{
className
:
"
objectLink
-
Attr
"
object
}
span
(
{
}
span
(
{
className
:
"
attrTitle
"
}
this
.
getTitle
(
object
)
)
span
(
{
className
:
"
attrEqual
"
}
"
=
"
)
StringRepFactory
(
{
object
:
value
}
)
)
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
type
=
=
"
Attr
"
&
&
grip
.
preview
;
}
module
.
exports
=
{
rep
:
Attribute
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
let
DateTime
=
React
.
createClass
(
{
displayName
:
"
Date
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
grip
)
{
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
:
grip
}
grip
.
class
+
"
"
)
;
}
return
"
"
;
}
render
:
wrapRender
(
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
date
;
try
{
date
=
span
(
{
className
:
"
objectBox
"
}
this
.
getTitle
(
grip
)
span
(
{
className
:
"
Date
"
}
new
Date
(
grip
.
preview
.
timestamp
)
.
toISOString
(
)
)
)
;
}
catch
(
e
)
{
date
=
span
(
{
className
:
"
objectBox
"
}
"
Invalid
Date
"
)
;
}
return
date
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
type
=
=
"
Date
"
&
&
grip
.
preview
;
}
module
.
exports
=
{
rep
:
DateTime
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
let
Document
=
React
.
createClass
(
{
displayName
:
"
Document
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getLocation
:
function
(
grip
)
{
let
location
=
grip
.
preview
.
location
;
return
location
?
getURLDisplayString
(
location
)
:
"
"
;
}
getTitle
:
function
(
grip
)
{
if
(
this
.
props
.
objectLink
)
{
return
span
(
{
className
:
"
objectBox
"
}
this
.
props
.
objectLink
(
{
object
:
grip
}
grip
.
class
+
"
"
)
)
;
}
return
"
"
;
}
getTooltip
:
function
(
doc
)
{
return
doc
.
location
.
href
;
}
render
:
wrapRender
(
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
type
=
=
"
HTMLDocument
"
;
}
module
.
exports
=
{
rep
:
Document
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
createFactories
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
rep
}
=
createFactories
(
__webpack_require__
(
15
)
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
let
Event
=
React
.
createClass
(
{
displayName
:
"
event
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
props
)
{
let
preview
=
props
.
object
.
preview
;
let
title
=
preview
.
type
;
if
(
preview
.
eventKind
=
=
"
key
"
&
&
preview
.
modifiers
&
&
preview
.
modifiers
.
length
)
{
title
=
{
title
}
{
preview
.
modifiers
.
join
(
"
-
"
)
}
;
}
return
title
;
}
render
:
wrapRender
(
function
(
)
{
let
gripProps
=
Object
.
assign
(
{
}
this
.
props
{
title
:
this
.
getTitle
(
this
.
props
)
}
)
;
gripProps
.
object
=
Object
.
assign
(
{
}
this
.
props
.
object
)
;
gripProps
.
object
.
preview
=
Object
.
assign
(
{
}
this
.
props
.
object
.
preview
)
;
gripProps
.
object
.
preview
.
ownProperties
=
{
}
;
if
(
gripProps
.
object
.
preview
.
target
)
{
Object
.
assign
(
gripProps
.
object
.
preview
.
ownProperties
{
target
:
gripProps
.
object
.
preview
.
target
}
)
;
}
Object
.
assign
(
gripProps
.
object
.
preview
.
ownProperties
gripProps
.
object
.
preview
.
properties
)
;
delete
gripProps
.
object
.
preview
.
properties
;
gripProps
.
object
.
ownPropertyLength
=
Object
.
keys
(
gripProps
.
object
.
preview
.
ownProperties
)
.
length
;
switch
(
gripProps
.
object
.
class
)
{
case
"
MouseEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
clientX
"
"
clientY
"
"
layerX
"
"
layerY
"
]
.
includes
(
name
)
;
}
;
break
;
case
"
KeyboardEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
key
"
"
charCode
"
"
keyCode
"
]
.
includes
(
name
)
;
}
;
break
;
case
"
MessageEvent
"
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
[
"
target
"
"
isTrusted
"
"
data
"
]
.
includes
(
name
)
;
}
;
break
;
default
:
gripProps
.
isInterestingProp
=
(
type
value
name
)
=
>
{
return
Object
.
keys
(
gripProps
.
object
.
preview
.
ownProperties
)
.
includes
(
name
)
;
}
;
}
return
rep
(
gripProps
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
DOMEvent
"
;
}
module
.
exports
=
{
rep
:
Event
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
cropString
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
let
Func
=
React
.
createClass
(
{
displayName
:
"
Func
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
grip
)
{
let
title
=
"
function
"
;
if
(
grip
.
isGenerator
)
{
title
=
"
function
*
"
;
}
if
(
grip
.
isAsync
)
{
title
=
"
async
"
+
title
;
}
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
:
grip
}
title
)
;
}
return
title
;
}
summarizeFunction
:
function
(
grip
)
{
let
name
=
grip
.
userDisplayName
|
|
grip
.
displayName
|
|
grip
.
name
|
|
"
"
;
return
cropString
(
name
+
"
(
)
"
100
)
;
}
render
:
wrapRender
(
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
span
(
{
dir
:
"
ltr
"
className
:
"
objectBox
objectBox
-
function
"
}
this
.
getTitle
(
grip
)
this
.
summarizeFunction
(
grip
)
)
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
type
=
=
"
function
"
;
}
return
type
=
=
"
Function
"
;
}
module
.
exports
=
{
rep
:
Func
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
createFactories
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
PropRep
=
React
.
createFactory
(
__webpack_require__
(
14
)
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
const
PromiseRep
=
React
.
createClass
(
{
displayName
:
"
Promise
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
objectLink
:
React
.
PropTypes
.
func
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
object
)
{
const
title
=
object
.
class
;
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
:
object
}
title
)
;
}
return
title
;
}
getProps
:
function
(
promiseState
)
{
const
keys
=
[
"
state
"
]
;
if
(
Object
.
keys
(
promiseState
)
.
includes
(
"
value
"
)
)
{
keys
.
push
(
"
value
"
)
;
}
return
keys
.
map
(
(
key
i
)
=
>
{
let
object
=
promiseState
[
key
]
;
return
PropRep
(
Object
.
assign
(
{
}
this
.
props
{
mode
:
MODE
.
TINY
name
:
<
{
key
}
>
object
equal
:
"
:
"
delim
:
i
<
keys
.
length
-
1
?
"
"
:
"
"
suppressQuotes
:
true
}
)
)
;
}
)
;
}
render
:
wrapRender
(
function
(
)
{
const
object
=
this
.
props
.
object
;
const
{
promiseState
}
=
object
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
if
(
this
.
props
.
mode
=
=
=
MODE
.
TINY
)
{
let
{
Rep
}
=
createFactories
(
__webpack_require__
(
2
)
)
;
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
:
object
}
"
{
"
)
Rep
(
{
object
:
promiseState
.
state
}
)
objectLink
(
{
className
:
"
objectRightBrace
"
object
:
object
}
"
}
"
)
)
;
}
const
propsArray
=
this
.
getProps
(
promiseState
)
;
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
:
object
}
"
{
"
)
.
.
.
propsArray
objectLink
(
{
className
:
"
objectRightBrace
"
object
:
object
}
"
}
"
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
type
=
=
=
"
Promise
"
;
}
module
.
exports
=
{
rep
:
PromiseRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
let
RegExp
=
React
.
createClass
(
{
displayName
:
"
regexp
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getSource
:
function
(
grip
)
{
return
grip
.
displayString
;
}
render
:
wrapRender
(
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
return
span
(
{
className
:
"
objectBox
objectBox
-
regexp
"
}
objectLink
(
{
object
:
grip
className
:
"
regexpSource
"
}
this
.
getSource
(
grip
)
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
type
=
=
"
RegExp
"
;
}
module
.
exports
=
{
rep
:
RegExp
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
4
)
;
const
DOM
=
React
.
DOM
;
let
StyleSheet
=
React
.
createClass
(
{
displayName
:
"
object
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
grip
)
{
let
title
=
"
StyleSheet
"
;
if
(
this
.
props
.
objectLink
)
{
return
DOM
.
span
(
{
className
:
"
objectBox
"
}
this
.
props
.
objectLink
(
{
object
:
grip
}
title
)
)
;
}
return
title
;
}
getLocation
:
function
(
grip
)
{
let
url
=
grip
.
preview
?
grip
.
preview
.
url
:
"
"
;
return
url
?
getURLDisplayString
(
url
)
:
"
"
;
}
render
:
wrapRender
(
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
grip
)
DOM
.
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
type
=
=
"
CSSStyleSheet
"
;
}
module
.
exports
=
{
rep
:
StyleSheet
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
cropString
cropMultipleLines
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
nodeConstants
=
__webpack_require__
(
5
)
;
const
{
span
}
=
React
.
DOM
;
const
CommentNode
=
React
.
createClass
(
{
displayName
:
"
CommentNode
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
}
render
:
wrapRender
(
function
(
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
this
.
props
;
let
{
textContent
}
=
object
.
preview
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
textContent
=
cropMultipleLines
(
textContent
30
)
;
}
else
if
(
mode
=
=
=
MODE
.
SHORT
)
{
textContent
=
cropString
(
textContent
50
)
;
}
return
span
(
{
className
:
"
objectBox
theme
-
comment
"
}
<
!
-
-
{
textContent
}
-
-
>
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
object
.
preview
.
nodeType
=
=
=
nodeConstants
.
COMMENT_NODE
;
}
module
.
exports
=
{
rep
:
CommentNode
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
nodeConstants
=
__webpack_require__
(
5
)
;
const
Svg
=
__webpack_require__
(
29
)
;
const
{
span
}
=
React
.
DOM
;
const
ElementNode
=
React
.
createClass
(
{
displayName
:
"
ElementNode
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
objectLink
:
React
.
PropTypes
.
func
}
getElements
:
function
(
grip
mode
)
{
let
{
attributes
nodeName
}
=
grip
.
preview
;
const
nodeNameElement
=
span
(
{
className
:
"
tag
-
name
theme
-
fg
-
color3
"
}
nodeName
)
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
elements
=
[
nodeNameElement
]
;
if
(
attributes
.
id
)
{
elements
.
push
(
span
(
{
className
:
"
attr
-
name
theme
-
fg
-
color2
"
}
#
{
attributes
.
id
}
)
)
;
}
if
(
attributes
.
class
)
{
elements
.
push
(
span
(
{
className
:
"
attr
-
name
theme
-
fg
-
color2
"
}
attributes
.
class
.
replace
(
/
(
^
\
s
+
)
|
(
\
s
+
)
/
g
"
"
)
.
split
(
"
"
)
.
map
(
cls
=
>
.
{
cls
}
)
.
join
(
"
"
)
)
)
;
}
return
elements
;
}
let
attributeElements
=
Object
.
keys
(
attributes
)
.
sort
(
function
getIdAndClassFirst
(
a1
a2
)
{
if
(
[
a1
a2
]
.
includes
(
"
id
"
)
)
{
return
3
*
(
a1
=
=
=
"
id
"
?
-
1
:
1
)
;
}
if
(
[
a1
a2
]
.
includes
(
"
class
"
)
)
{
return
2
*
(
a1
=
=
=
"
class
"
?
-
1
:
1
)
;
}
return
0
;
}
)
.
reduce
(
(
arr
name
i
keys
)
=
>
{
let
value
=
attributes
[
name
]
;
let
attribute
=
span
(
{
}
span
(
{
className
:
"
attr
-
name
theme
-
fg
-
color2
"
}
{
name
}
)
=
"
span
(
{
className
:
"
attr
-
value
theme
-
fg
-
color6
"
}
{
value
}
)
"
)
;
return
arr
.
concat
(
[
"
"
attribute
]
)
;
}
[
]
)
;
return
[
"
<
"
nodeNameElement
.
.
.
attributeElements
"
>
"
]
;
}
render
:
wrapRender
(
function
(
)
{
let
{
object
mode
attachedActorIds
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
this
.
props
;
let
elements
=
this
.
getElements
(
object
mode
)
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
let
isInTree
=
attachedActorIds
?
attachedActorIds
.
includes
(
object
.
actor
)
:
true
;
let
baseConfig
=
{
className
:
"
objectBox
objectBox
-
node
"
}
;
let
inspectIcon
;
if
(
isInTree
)
{
if
(
onDOMNodeMouseOver
)
{
Object
.
assign
(
baseConfig
{
onMouseOver
:
_
=
>
onDOMNodeMouseOver
(
object
)
}
)
;
}
if
(
onDOMNodeMouseOut
)
{
Object
.
assign
(
baseConfig
{
onMouseOut
:
onDOMNodeMouseOut
}
)
;
}
if
(
onInspectIconClick
)
{
inspectIcon
=
Svg
(
"
open
-
inspector
"
{
element
:
"
a
"
draggable
:
false
title
:
"
Click
to
select
the
node
in
the
inspector
"
onClick
:
e
=
>
onInspectIconClick
(
object
e
)
}
)
;
}
}
return
span
(
baseConfig
objectLink
(
{
object
}
.
.
.
elements
)
inspectIcon
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
object
.
preview
.
nodeType
=
=
=
nodeConstants
.
ELEMENT_NODE
;
}
module
.
exports
=
{
rep
:
ElementNode
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
InlineSVG
=
__webpack_require__
(
30
)
;
const
svg
=
{
"
open
-
inspector
"
:
__webpack_require__
(
31
)
}
;
module
.
exports
=
function
(
name
props
)
{
if
(
!
svg
[
name
]
)
{
throw
new
Error
(
"
Unknown
SVG
:
"
+
name
)
;
}
let
className
=
name
;
if
(
props
&
&
props
.
className
)
{
className
=
{
name
}
{
props
.
className
}
;
}
if
(
name
=
=
=
"
subSettings
"
)
{
className
=
"
"
;
}
props
=
Object
.
assign
(
{
}
props
{
className
src
:
svg
[
name
]
}
)
;
return
React
.
createElement
(
InlineSVG
props
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_createClass
=
(
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
'
value
'
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
)
(
)
;
var
_get
=
function
get
(
_x
_x2
_x3
)
{
var
_again
=
true
;
_function
:
while
(
_again
)
{
var
object
=
_x
property
=
_x2
receiver
=
_x3
;
_again
=
false
;
if
(
object
=
=
=
null
)
object
=
Function
.
prototype
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
object
property
)
;
if
(
desc
=
=
=
undefined
)
{
var
parent
=
Object
.
getPrototypeOf
(
object
)
;
if
(
parent
=
=
=
null
)
{
return
undefined
;
}
else
{
_x
=
parent
;
_x2
=
property
;
_x3
=
receiver
;
_again
=
true
;
desc
=
parent
=
undefined
;
continue
_function
;
}
}
else
if
(
'
value
'
in
desc
)
{
return
desc
.
value
;
}
else
{
var
getter
=
desc
.
get
;
if
(
getter
=
=
=
undefined
)
{
return
undefined
;
}
return
getter
.
call
(
receiver
)
;
}
}
}
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
function
_objectWithoutProperties
(
obj
keys
)
{
var
target
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
keys
.
indexOf
(
i
)
>
=
0
)
continue
;
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
continue
;
target
[
i
]
=
obj
[
i
]
;
}
return
target
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
'
Cannot
call
a
class
as
a
function
'
)
;
}
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
'
function
'
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
'
Super
expression
must
either
be
null
or
a
function
not
'
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
_react
=
__webpack_require__
(
3
)
;
var
_react2
=
_interopRequireDefault
(
_react
)
;
var
DOMParser
=
typeof
window
!
=
=
'
undefined
'
&
&
window
.
DOMParser
;
var
process
=
process
|
|
{
}
;
process
.
env
=
process
.
env
|
|
{
}
;
var
parserAvailable
=
typeof
DOMParser
!
=
=
'
undefined
'
&
&
DOMParser
.
prototype
!
=
null
&
&
DOMParser
.
prototype
.
parseFromString
!
=
null
;
function
isParsable
(
src
)
{
return
parserAvailable
&
&
typeof
src
=
=
=
'
string
'
&
&
src
.
trim
(
)
.
substr
(
0
4
)
=
=
=
'
<
svg
'
;
}
function
parseFromSVGString
(
src
)
{
var
parser
=
new
DOMParser
(
)
;
return
parser
.
parseFromString
(
src
"
image
/
svg
+
xml
"
)
;
}
function
switchSVGAttrToReactProp
(
propName
)
{
switch
(
propName
)
{
case
'
class
'
:
return
'
className
'
;
default
:
return
propName
;
}
}
var
InlineSVG
=
(
function
(
_React
Component
)
{
_inherits
(
InlineSVG
_React
Component
)
;
_createClass
(
InlineSVG
null
[
{
key
:
'
defaultProps
'
value
:
{
element
:
'
i
'
raw
:
false
src
:
'
'
}
enumerable
:
true
}
{
key
:
'
propTypes
'
value
:
{
src
:
_react2
[
'
default
'
]
.
PropTypes
.
string
.
isRequired
element
:
_react2
[
'
default
'
]
.
PropTypes
.
string
raw
:
_react2
[
'
default
'
]
.
PropTypes
.
bool
}
enumerable
:
true
}
]
)
;
function
InlineSVG
(
props
)
{
_classCallCheck
(
this
InlineSVG
)
;
_get
(
Object
.
getPrototypeOf
(
InlineSVG
.
prototype
)
'
constructor
'
this
)
.
call
(
this
props
)
;
this
.
_extractSVGProps
=
this
.
_extractSVGProps
.
bind
(
this
)
;
}
_createClass
(
InlineSVG
[
{
key
:
'
_serializeAttrs
'
value
:
function
_serializeAttrs
(
map
)
{
var
ret
=
{
}
;
var
prop
=
undefined
;
for
(
var
i
=
0
;
i
<
map
.
length
;
i
+
+
)
{
prop
=
switchSVGAttrToReactProp
(
map
[
i
]
.
name
)
;
ret
[
prop
]
=
map
[
i
]
.
value
;
}
return
ret
;
}
}
{
key
:
'
_extractSVGProps
'
value
:
function
_extractSVGProps
(
src
)
{
var
map
=
parseFromSVGString
(
src
)
.
documentElement
.
attributes
;
return
map
.
length
>
0
?
this
.
_serializeAttrs
(
map
)
:
null
;
}
}
{
key
:
'
_stripSVG
'
value
:
function
_stripSVG
(
src
)
{
return
parseFromSVGString
(
src
)
.
documentElement
.
innerHTML
;
}
}
{
key
:
'
componentWillReceiveProps
'
value
:
function
componentWillReceiveProps
(
_ref
)
{
var
children
=
_ref
.
children
;
if
(
"
production
"
!
=
=
process
.
env
.
NODE_ENV
&
&
children
!
=
null
)
{
console
.
info
(
'
<
InlineSVG
/
>
:
children
prop
will
be
ignored
.
'
)
;
}
}
}
{
key
:
'
render
'
value
:
function
render
(
)
{
var
Element
=
undefined
__html
=
undefined
svgProps
=
undefined
;
var
_props
=
this
.
props
;
var
element
=
_props
.
element
;
var
raw
=
_props
.
raw
;
var
src
=
_props
.
src
;
var
otherProps
=
_objectWithoutProperties
(
_props
[
'
element
'
'
raw
'
'
src
'
]
)
;
if
(
raw
=
=
=
true
&
&
isParsable
(
src
)
)
{
Element
=
'
svg
'
;
svgProps
=
this
.
_extractSVGProps
(
src
)
;
__html
=
this
.
_stripSVG
(
src
)
;
}
__html
=
__html
|
|
src
;
Element
=
Element
|
|
element
;
svgProps
=
svgProps
|
|
{
}
;
return
_react2
[
'
default
'
]
.
createElement
(
Element
_extends
(
{
}
svgProps
otherProps
{
src
:
null
children
:
null
dangerouslySetInnerHTML
:
{
__html
:
__html
}
}
)
)
;
}
}
]
)
;
return
InlineSVG
;
}
)
(
_react2
[
'
default
'
]
.
Component
)
;
exports
[
'
default
'
]
=
InlineSVG
;
module
.
exports
=
exports
[
'
default
'
]
;
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
>
<
path
d
=
\
"
M8
3L12
3L12
7L14
7L14
8L12
8L12
12L8
12L8
14L7
14L7
12L3
12L3
8L1
8L1
7L3
7L3
3L7
3L7
1L8
1L8
3ZM10
10L10
5L5
5L5
10L10
10Z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
cropString
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
Svg
=
__webpack_require__
(
29
)
;
const
DOM
=
React
.
DOM
;
let
TextNode
=
React
.
createClass
(
{
displayName
:
"
TextNode
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
objectLink
:
React
.
PropTypes
.
func
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
getTextContent
:
function
(
grip
)
{
return
cropString
(
grip
.
preview
.
textContent
)
;
}
getTitle
:
function
(
grip
)
{
const
title
=
"
#
text
"
;
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
:
grip
}
title
)
;
}
return
title
;
}
render
:
wrapRender
(
function
(
)
{
let
{
object
:
grip
mode
=
MODE
.
SHORT
attachedActorIds
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
this
.
props
;
let
baseConfig
=
{
className
:
"
objectBox
objectBox
-
textNode
"
}
;
let
inspectIcon
;
let
isInTree
=
attachedActorIds
?
attachedActorIds
.
includes
(
grip
.
actor
)
:
true
;
if
(
isInTree
)
{
if
(
onDOMNodeMouseOver
)
{
Object
.
assign
(
baseConfig
{
onMouseOver
:
_
=
>
onDOMNodeMouseOver
(
grip
)
}
)
;
}
if
(
onDOMNodeMouseOut
)
{
Object
.
assign
(
baseConfig
{
onMouseOut
:
onDOMNodeMouseOut
}
)
;
}
if
(
onInspectIconClick
)
{
inspectIcon
=
Svg
(
"
open
-
inspector
"
{
element
:
"
a
"
draggable
:
false
title
:
"
Click
to
select
the
node
in
the
inspector
"
onClick
:
e
=
>
onInspectIconClick
(
grip
e
)
}
)
;
}
}
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
DOM
.
span
(
baseConfig
this
.
getTitle
(
grip
)
inspectIcon
)
;
}
return
DOM
.
span
(
baseConfig
this
.
getTitle
(
grip
)
DOM
.
span
(
{
className
:
"
nodeValue
"
}
"
"
"
{
this
.
getTextContent
(
grip
)
}
"
)
inspectIcon
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
class
=
=
"
Text
"
;
}
module
.
exports
=
{
rep
:
TextNode
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
const
ErrorRep
=
React
.
createClass
(
{
displayName
:
"
Error
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
objectLink
:
React
.
PropTypes
.
func
}
render
:
wrapRender
(
function
(
)
{
let
object
=
this
.
props
.
object
;
let
preview
=
object
.
preview
;
let
name
=
preview
&
&
preview
.
name
?
preview
.
name
:
"
Error
"
;
let
content
=
this
.
props
.
mode
=
=
=
MODE
.
TINY
?
name
:
{
name
}
:
{
preview
.
message
}
;
if
(
preview
.
stack
&
&
this
.
props
.
mode
!
=
=
MODE
.
TINY
)
{
content
=
{
content
}
\
nStack
trace
:
\
n
{
preview
.
stack
}
;
}
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
return
objectLink
(
{
object
className
:
"
objectBox
-
stackTrace
"
}
span
(
{
}
content
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
type
=
=
=
"
Error
"
;
}
module
.
exports
=
{
rep
:
ErrorRep
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
DOM
=
React
.
DOM
;
let
Window
=
React
.
createClass
(
{
displayName
:
"
Window
"
propTypes
:
{
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
object
)
{
let
title
=
object
.
displayClass
|
|
object
.
class
|
|
"
Window
"
;
if
(
this
.
props
.
objectLink
)
{
return
DOM
.
span
(
{
className
:
"
objectBox
"
}
this
.
props
.
objectLink
(
{
object
}
title
)
)
;
}
return
title
;
}
getLocation
:
function
(
object
)
{
return
getURLDisplayString
(
object
.
preview
.
url
)
;
}
render
:
wrapRender
(
function
(
)
{
let
{
mode
object
}
=
this
.
props
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
return
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
Window
"
}
this
.
getTitle
(
object
)
)
;
}
return
DOM
.
span
(
{
className
:
"
objectBox
objectBox
-
Window
"
}
this
.
getTitle
(
object
)
"
"
DOM
.
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
object
)
)
)
;
}
)
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
object
.
preview
&
&
type
=
=
"
Window
"
;
}
module
.
exports
=
{
rep
:
Window
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
let
ObjectWithText
=
React
.
createClass
(
{
displayName
:
"
ObjectWithText
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
grip
)
{
if
(
this
.
props
.
objectLink
)
{
return
span
(
{
className
:
"
objectBox
"
}
this
.
props
.
objectLink
(
{
object
:
grip
}
this
.
getType
(
grip
)
+
"
"
)
)
;
}
return
"
"
;
}
getType
:
function
(
grip
)
{
return
grip
.
class
;
}
getDescription
:
function
(
grip
)
{
return
"
\
"
"
+
grip
.
preview
.
text
+
"
\
"
"
;
}
render
:
wrapRender
(
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
span
(
{
className
:
"
objectBox
objectBox
-
"
+
this
.
getType
(
grip
)
}
this
.
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
this
.
getDescription
(
grip
)
)
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithText
"
;
}
module
.
exports
=
{
rep
:
ObjectWithText
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
getURLDisplayString
wrapRender
}
=
__webpack_require__
(
4
)
;
const
{
span
}
=
React
.
DOM
;
let
ObjectWithURL
=
React
.
createClass
(
{
displayName
:
"
ObjectWithURL
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
}
getTitle
:
function
(
grip
)
{
if
(
this
.
props
.
objectLink
)
{
return
span
(
{
className
:
"
objectBox
"
}
this
.
props
.
objectLink
(
{
object
:
grip
}
this
.
getType
(
grip
)
+
"
"
)
)
;
}
return
"
"
;
}
getType
:
function
(
grip
)
{
return
grip
.
class
;
}
getDescription
:
function
(
grip
)
{
return
getURLDisplayString
(
grip
.
preview
.
url
)
;
}
render
:
wrapRender
(
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
span
(
{
className
:
"
objectBox
objectBox
-
"
+
this
.
getType
(
grip
)
}
this
.
getTitle
(
grip
)
span
(
{
className
:
"
objectPropValue
"
}
this
.
getDescription
(
grip
)
)
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithURL
"
;
}
module
.
exports
=
{
rep
:
ObjectWithURL
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
createFactories
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
Caption
=
React
.
createFactory
(
__webpack_require__
(
12
)
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
let
GripArray
=
React
.
createClass
(
{
displayName
:
"
GripArray
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
provider
:
React
.
PropTypes
.
object
objectLink
:
React
.
PropTypes
.
func
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
getLength
:
function
(
grip
)
{
if
(
!
grip
.
preview
)
{
return
0
;
}
return
grip
.
preview
.
length
|
|
grip
.
preview
.
childNodesLength
|
|
0
;
}
getTitle
:
function
(
object
context
)
{
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
if
(
this
.
props
.
mode
!
=
=
MODE
.
TINY
)
{
let
title
=
this
.
props
.
title
|
|
object
.
class
|
|
"
Array
"
;
return
objectLink
(
{
object
:
object
}
title
"
"
)
;
}
return
"
"
;
}
getPreviewItems
:
function
(
grip
)
{
if
(
!
grip
.
preview
)
{
return
null
;
}
return
grip
.
preview
.
items
|
|
grip
.
preview
.
childNodes
|
|
null
;
}
arrayIterator
:
function
(
grip
max
)
{
let
items
=
[
]
;
const
gripLength
=
this
.
getLength
(
grip
)
;
if
(
!
gripLength
)
{
return
items
;
}
const
previewItems
=
this
.
getPreviewItems
(
grip
)
;
if
(
!
previewItems
)
{
return
items
;
}
let
delim
;
let
delimMax
=
gripLength
>
previewItems
.
length
?
previewItems
.
length
:
previewItems
.
length
-
1
;
let
provider
=
this
.
props
.
provider
;
for
(
let
i
=
0
;
i
<
previewItems
.
length
&
&
i
<
max
;
i
+
+
)
{
try
{
let
itemGrip
=
previewItems
[
i
]
;
let
value
=
provider
?
provider
.
getValue
(
itemGrip
)
:
itemGrip
;
delim
=
i
=
=
delimMax
?
"
"
:
"
"
;
items
.
push
(
GripArrayItem
(
Object
.
assign
(
{
}
this
.
props
{
object
:
value
delim
:
delim
title
:
undefined
}
)
)
)
;
}
catch
(
exc
)
{
items
.
push
(
GripArrayItem
(
Object
.
assign
(
{
}
this
.
props
{
object
:
exc
delim
:
delim
title
:
undefined
}
)
)
)
;
}
}
if
(
previewItems
.
length
>
max
|
|
gripLength
>
previewItems
.
length
)
{
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
let
leftItemNum
=
gripLength
-
max
>
0
?
gripLength
-
max
:
gripLength
-
previewItems
.
length
;
items
.
push
(
Caption
(
{
object
:
objectLink
(
{
object
:
this
.
props
.
object
}
leftItemNum
+
"
more
"
)
}
)
)
;
}
return
items
;
}
render
:
wrapRender
(
function
(
)
{
let
{
object
mode
=
MODE
.
SHORT
}
=
this
.
props
;
let
items
;
let
brackets
;
let
needSpace
=
function
(
space
)
{
return
space
?
{
left
:
"
[
"
right
:
"
]
"
}
:
{
left
:
"
[
"
right
:
"
]
"
}
;
}
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
let
objectLength
=
this
.
getLength
(
object
)
;
let
isEmpty
=
objectLength
=
=
=
0
;
items
=
[
span
(
{
className
:
"
length
"
}
isEmpty
?
"
"
:
objectLength
)
]
;
brackets
=
needSpace
(
false
)
;
}
else
{
let
max
=
mode
=
=
=
MODE
.
SHORT
?
3
:
10
;
items
=
this
.
arrayIterator
(
object
max
)
;
brackets
=
needSpace
(
items
.
length
>
0
)
;
}
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
let
title
=
this
.
getTitle
(
object
)
;
return
span
(
{
className
:
"
objectBox
objectBox
-
array
"
}
title
objectLink
(
{
className
:
"
arrayLeftBracket
"
object
:
object
}
brackets
.
left
)
.
.
.
items
objectLink
(
{
className
:
"
arrayRightBracket
"
object
:
object
}
brackets
.
right
)
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
;
}
)
}
)
;
let
GripArrayItem
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
GripArrayItem
"
propTypes
:
{
delim
:
React
.
PropTypes
.
string
object
:
React
.
PropTypes
.
object
.
isRequired
objectLink
:
React
.
PropTypes
.
func
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
provider
:
React
.
PropTypes
.
object
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
}
render
:
function
(
)
{
let
{
Rep
}
=
createFactories
(
__webpack_require__
(
2
)
)
;
return
span
(
{
}
Rep
(
Object
.
assign
(
{
}
this
.
props
{
mode
:
MODE
.
TINY
}
)
)
this
.
props
.
delim
)
;
}
}
)
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
(
grip
.
preview
.
kind
=
=
"
ArrayLike
"
|
|
type
=
=
=
"
DocumentFragment
"
)
;
}
module
.
exports
=
{
rep
:
GripArray
supportsObject
:
supportsObject
}
;
}
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
3
)
;
const
{
isGrip
wrapRender
}
=
__webpack_require__
(
4
)
;
const
Caption
=
React
.
createFactory
(
__webpack_require__
(
12
)
)
;
const
PropRep
=
React
.
createFactory
(
__webpack_require__
(
14
)
)
;
const
{
MODE
}
=
__webpack_require__
(
1
)
;
const
{
span
}
=
React
.
DOM
;
const
GripMap
=
React
.
createClass
(
{
displayName
:
"
GripMap
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
objectLink
:
React
.
PropTypes
.
func
isInterestingEntry
:
React
.
PropTypes
.
func
attachedActorIds
:
React
.
PropTypes
.
array
onDOMNodeMouseOver
:
React
.
PropTypes
.
func
onDOMNodeMouseOut
:
React
.
PropTypes
.
func
onInspectIconClick
:
React
.
PropTypes
.
func
title
:
React
.
PropTypes
.
string
}
getTitle
:
function
(
object
)
{
let
title
=
this
.
props
.
title
|
|
(
object
&
&
object
.
class
?
object
.
class
:
"
Map
"
)
;
if
(
this
.
props
.
objectLink
)
{
return
this
.
props
.
objectLink
(
{
object
:
object
}
title
)
;
}
return
title
;
}
safeEntriesIterator
:
function
(
object
max
)
{
max
=
typeof
max
=
=
=
"
undefined
"
?
3
:
max
;
try
{
return
this
.
entriesIterator
(
object
max
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
entriesIterator
:
function
(
object
max
)
{
let
isInterestingEntry
=
this
.
props
.
isInterestingEntry
|
|
(
(
type
value
)
=
>
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
&
&
value
.
length
!
=
0
;
}
)
;
let
mapEntries
=
object
.
preview
&
&
object
.
preview
.
entries
?
object
.
preview
.
entries
:
[
]
;
let
indexes
=
this
.
getEntriesIndexes
(
mapEntries
max
isInterestingEntry
)
;
if
(
indexes
.
length
<
max
&
&
indexes
.
length
<
mapEntries
.
length
)
{
indexes
=
indexes
.
concat
(
this
.
getEntriesIndexes
(
mapEntries
max
-
indexes
.
length
(
t
value
name
)
=
>
{
return
!
isInterestingEntry
(
t
value
name
)
;
}
)
)
;
}
let
entries
=
this
.
getEntries
(
mapEntries
indexes
)
;
if
(
entries
.
length
<
mapEntries
.
length
)
{
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
entries
.
push
(
Caption
(
{
key
:
"
more
"
object
:
objectLink
(
{
object
:
object
}
{
mapEntries
.
length
-
max
}
more
)
}
)
)
;
}
return
entries
;
}
getEntries
:
function
(
entries
indexes
)
{
let
{
objectLink
attachedActorIds
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
=
this
.
props
;
indexes
.
sort
(
function
(
a
b
)
{
return
a
-
b
;
}
)
;
return
indexes
.
map
(
(
index
i
)
=
>
{
let
[
key
entryValue
]
=
entries
[
index
]
;
let
value
=
entryValue
.
value
!
=
=
undefined
?
entryValue
.
value
:
entryValue
;
return
PropRep
(
{
name
:
key
equal
:
"
:
"
object
:
value
delim
:
i
<
indexes
.
length
-
1
|
|
indexes
.
length
<
entries
.
length
?
"
"
:
"
"
mode
:
MODE
.
TINY
objectLink
attachedActorIds
onDOMNodeMouseOver
onDOMNodeMouseOut
onInspectIconClick
}
)
;
}
)
;
}
getEntriesIndexes
:
function
(
entries
max
filter
)
{
return
entries
.
reduce
(
(
indexes
[
key
entry
]
i
)
=
>
{
if
(
indexes
.
length
<
max
)
{
let
value
=
entry
&
&
entry
.
value
!
=
=
undefined
?
entry
.
value
:
entry
;
let
type
=
(
value
&
&
value
.
class
?
value
.
class
:
typeof
value
)
.
toLowerCase
(
)
;
if
(
filter
(
type
value
key
)
)
{
indexes
.
push
(
i
)
;
}
}
return
indexes
;
}
[
]
)
;
}
render
:
wrapRender
(
function
(
)
{
let
object
=
this
.
props
.
object
;
let
propsArray
=
this
.
safeEntriesIterator
(
object
this
.
props
.
mode
=
=
=
MODE
.
LONG
?
10
:
3
)
;
let
objectLink
=
this
.
props
.
objectLink
|
|
span
;
if
(
this
.
props
.
mode
=
=
=
MODE
.
TINY
)
{
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
:
object
}
"
"
)
)
;
}
return
span
(
{
className
:
"
objectBox
objectBox
-
object
"
}
this
.
getTitle
(
object
)
objectLink
(
{
className
:
"
objectLeftBrace
"
object
:
object
}
"
{
"
)
propsArray
objectLink
(
{
className
:
"
objectRightBrace
"
object
:
object
}
"
}
"
)
)
;
}
)
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
MapLike
"
;
}
module
.
exports
=
{
rep
:
GripMap
supportsObject
:
supportsObject
}
;
}
]
)
}
)
;
;
