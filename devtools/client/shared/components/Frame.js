"
use
strict
"
;
const
{
Component
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
.
mjs
"
)
;
const
dom
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
.
js
"
)
;
const
PropTypes
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
.
mjs
"
)
;
const
{
getUnicodeUrl
getUnicodeUrlPath
getUnicodeHostname
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
unicode
-
url
.
js
"
)
;
const
{
getSourceNames
parseURL
getSourceMappedFile
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
source
-
utils
.
js
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
{
MESSAGE_SOURCE
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
webconsole
/
constants
.
js
"
)
;
const
l10n
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
components
.
properties
"
)
;
const
webl10n
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
webconsole
.
properties
"
)
;
function
savedFrameToDebuggerLocation
(
frame
)
{
const
{
source
:
url
line
column
sourceId
}
=
frame
;
return
{
url
line
column
:
column
>
=
1
?
column
-
1
:
null
id
:
typeof
sourceId
=
=
=
"
string
"
?
sourceId
:
null
}
;
}
function
getTooltipMessage
(
messageSource
url
)
{
if
(
messageSource
&
&
messageSource
=
=
=
MESSAGE_SOURCE
.
CSS
)
{
return
l10n
.
getFormatStr
(
"
frame
.
viewsourceinstyleeditor
"
url
)
;
}
return
l10n
.
getFormatStr
(
"
frame
.
viewsourceindebugger
"
url
)
;
}
class
Frame
extends
Component
{
static
get
propTypes
(
)
{
return
{
className
:
PropTypes
.
string
frame
:
PropTypes
.
shape
(
{
functionDisplayName
:
PropTypes
.
string
sourceId
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
number
]
)
source
:
PropTypes
.
string
.
isRequired
line
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
number
]
)
column
:
PropTypes
.
oneOfType
(
[
PropTypes
.
string
PropTypes
.
number
]
)
}
)
.
isRequired
onClick
:
PropTypes
.
func
showFunctionName
:
PropTypes
.
bool
showAnonymousFunctionName
:
PropTypes
.
bool
showHost
:
PropTypes
.
bool
showEmptyPathAsHost
:
PropTypes
.
bool
showFullSourceUrl
:
PropTypes
.
bool
sourceMapURLService
:
PropTypes
.
object
messageSource
:
PropTypes
.
string
}
;
}
static
get
defaultProps
(
)
{
return
{
showFunctionName
:
false
showAnonymousFunctionName
:
false
showHost
:
false
showEmptyPathAsHost
:
false
showFullSourceUrl
:
false
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
originalLocation
:
null
}
;
this
.
_locationChanged
=
this
.
_locationChanged
.
bind
(
this
)
;
}
componentDidMount
(
)
{
if
(
this
.
props
.
sourceMapURLService
)
{
const
location
=
savedFrameToDebuggerLocation
(
this
.
props
.
frame
)
;
this
.
unsubscribeSourceMapURLService
=
this
.
props
.
sourceMapURLService
.
subscribeByLocation
(
location
this
.
_locationChanged
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
unsubscribeSourceMapURLService
)
{
this
.
unsubscribeSourceMapURLService
(
)
;
}
}
_locationChanged
(
originalLocation
)
{
this
.
setState
(
{
originalLocation
}
)
;
}
#
getCurrentLocationInfo
=
(
)
=
>
{
const
{
frame
}
=
this
.
props
;
const
{
originalLocation
}
=
this
.
state
;
const
generatedLocation
=
savedFrameToDebuggerLocation
(
frame
)
;
const
currentLocation
=
originalLocation
|
|
generatedLocation
;
const
column
=
Number
.
parseInt
(
currentLocation
.
column
10
)
;
return
{
sourceURL
:
currentLocation
.
url
|
|
"
"
line
:
Number
(
currentLocation
.
line
)
|
|
null
column
:
typeof
column
=
=
"
number
"
?
column
+
1
:
null
}
;
}
;
#
getCurrentLocationUnicodeHostName
=
(
)
=
>
{
const
{
sourceURL
}
=
this
.
#
getCurrentLocationInfo
(
)
;
const
{
host
}
=
getSourceNames
(
sourceURL
)
;
return
host
?
getUnicodeHostname
(
host
)
:
"
"
;
}
;
#
isCurrentLocationLinkable
=
(
)
=
>
{
const
{
frame
}
=
this
.
props
;
const
{
originalLocation
}
=
this
.
state
;
const
generatedLocation
=
savedFrameToDebuggerLocation
(
frame
)
;
return
!
!
(
originalLocation
|
|
generatedLocation
.
id
|
|
!
!
parseURL
(
generatedLocation
.
url
)
)
;
}
;
#
getTopElementProps
=
(
)
=
>
{
const
{
className
}
=
this
.
props
;
const
{
sourceURL
line
column
}
=
this
.
#
getCurrentLocationInfo
(
)
;
const
{
long
}
=
getSourceNames
(
sourceURL
)
;
const
props
=
{
"
data
-
url
"
:
long
className
:
"
frame
-
link
"
+
(
className
?
{
className
}
:
"
"
)
}
;
if
(
line
)
{
props
[
"
data
-
line
"
]
=
line
;
if
(
column
)
{
props
[
"
data
-
column
"
]
=
column
;
}
}
return
props
;
}
;
#
getSourceElementsProps
=
(
)
=
>
{
const
{
frame
onClick
messageSource
}
=
this
.
props
;
const
generatedLocation
=
savedFrameToDebuggerLocation
(
frame
)
;
const
{
sourceURL
line
column
}
=
this
.
#
getCurrentLocationInfo
(
)
;
const
{
long
}
=
getSourceNames
(
sourceURL
)
;
let
url
=
getUnicodeUrl
(
long
)
;
if
(
line
)
{
url
+
=
:
{
line
}
;
if
(
column
)
{
url
+
=
:
{
column
}
;
}
}
const
isLinkable
=
this
.
#
isCurrentLocationLinkable
(
)
;
const
tooltipMessage
=
getTooltipMessage
(
messageSource
url
)
;
const
sourceElConfig
=
{
key
:
"
source
"
className
:
"
frame
-
link
-
source
"
title
:
isLinkable
?
tooltipMessage
:
url
}
;
if
(
isLinkable
)
{
return
{
.
.
.
sourceElConfig
onClick
:
e
=
>
{
e
.
preventDefault
(
)
;
if
(
onClick
)
{
e
.
stopPropagation
(
)
;
onClick
(
generatedLocation
)
;
}
}
href
:
sourceURL
draggable
:
false
}
;
}
return
sourceElConfig
;
}
;
#
renderSourceElements
=
(
)
=
>
{
const
{
line
column
}
=
this
.
#
getCurrentLocationInfo
(
)
;
const
sourceElements
=
[
this
.
#
renderDisplaySource
(
)
]
;
if
(
line
)
{
let
lineInfo
=
:
{
line
}
;
if
(
column
)
{
lineInfo
+
=
:
{
column
}
;
}
sourceElements
.
push
(
dom
.
span
(
{
key
:
"
line
"
className
:
"
frame
-
link
-
line
"
}
lineInfo
)
)
;
}
if
(
this
.
#
isCurrentLocationLinkable
(
)
)
{
return
dom
.
a
(
this
.
#
getSourceElementsProps
(
)
sourceElements
)
;
}
return
dom
.
span
(
this
.
#
getSourceElementsProps
(
)
sourceElements
)
;
}
;
#
renderDisplaySource
=
(
)
=
>
{
const
{
showEmptyPathAsHost
showFullSourceUrl
}
=
this
.
props
;
const
{
originalLocation
}
=
this
.
state
;
const
{
sourceURL
}
=
this
.
#
getCurrentLocationInfo
(
)
;
const
{
short
long
host
}
=
getSourceNames
(
sourceURL
)
;
const
unicodeShort
=
getUnicodeUrlPath
(
short
)
;
const
unicodeLong
=
getUnicodeUrl
(
long
)
;
let
displaySource
=
showFullSourceUrl
?
unicodeLong
:
unicodeShort
;
if
(
originalLocation
)
{
displaySource
=
getSourceMappedFile
(
displaySource
)
;
if
(
showEmptyPathAsHost
&
&
displaySource
=
=
"
:
formatted
"
)
{
displaySource
=
host
+
displaySource
;
}
}
else
if
(
showEmptyPathAsHost
&
&
(
displaySource
=
=
=
"
"
|
|
displaySource
=
=
=
"
/
"
)
)
{
displaySource
=
host
;
}
return
dom
.
span
(
{
key
:
"
filename
"
className
:
"
frame
-
link
-
filename
"
}
displaySource
)
;
}
;
#
renderFunctionDisplayName
=
(
)
=
>
{
const
{
frame
showFunctionName
showAnonymousFunctionName
}
=
this
.
props
;
if
(
!
showFunctionName
)
{
return
null
;
}
const
functionDisplayName
=
frame
.
functionDisplayName
;
if
(
functionDisplayName
|
|
showAnonymousFunctionName
)
{
return
[
dom
.
span
(
{
key
:
"
function
-
display
-
name
"
className
:
"
frame
-
link
-
function
-
display
-
name
"
}
functionDisplayName
|
|
webl10n
.
getStr
(
"
stacktrace
.
anonymousFunction
"
)
)
"
"
]
;
}
return
null
;
}
;
render
(
)
{
const
{
showHost
}
=
this
.
props
;
const
elements
=
[
this
.
#
renderFunctionDisplayName
(
)
this
.
#
renderSourceElements
(
)
]
;
const
unicodeHost
=
showHost
?
this
.
#
getCurrentLocationUnicodeHostName
(
)
:
null
;
if
(
unicodeHost
)
{
elements
.
push
(
"
"
)
;
elements
.
push
(
dom
.
span
(
{
key
:
"
host
"
className
:
"
frame
-
link
-
host
"
}
unicodeHost
)
)
;
}
return
dom
.
span
(
this
.
#
getTopElementProps
(
)
.
.
.
elements
)
;
}
}
module
.
exports
=
Frame
;
