"
use
strict
"
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
DOM
:
dom
createClass
createFactory
PropTypes
}
=
React
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
NUMBER_OF_OFFSCREEN_ITEMS
=
1
;
module
.
exports
=
createClass
(
{
displayName
:
"
Tree
"
propTypes
:
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
isExpanded
:
PropTypes
.
func
.
isRequired
itemHeight
:
PropTypes
.
number
.
isRequired
focused
:
PropTypes
.
any
onFocus
:
PropTypes
.
func
autoExpandDepth
:
PropTypes
.
number
onExpand
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
}
getDefaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
}
;
}
getInitialState
(
)
{
return
{
scroll
:
0
height
:
window
.
innerHeight
seen
:
new
Set
(
)
}
;
}
componentDidMount
(
)
{
window
.
addEventListener
(
"
resize
"
this
.
_updateHeight
)
;
this
.
_autoExpand
(
)
;
this
.
_updateHeight
(
)
;
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
)
;
this
.
_updateHeight
(
)
;
}
componentWillUnmount
(
)
{
window
.
removeEventListener
(
"
resize
"
this
.
_updateHeight
)
;
}
_autoExpand
(
)
{
if
(
!
this
.
props
.
autoExpandDepth
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
if
(
currentDepth
>
=
this
.
props
.
autoExpandDepth
|
|
this
.
state
.
seen
.
has
(
item
)
)
{
return
;
}
this
.
props
.
onExpand
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
}
_updateHeight
(
)
{
this
.
setState
(
{
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
:
oncePerAnimationFrame
(
function
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
)
_onCollapse
:
oncePerAnimationFrame
(
function
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
)
_focus
(
index
item
)
{
if
(
item
!
=
=
undefined
)
{
const
itemStartPosition
=
index
*
this
.
props
.
itemHeight
;
const
itemEndPosition
=
(
index
+
1
)
*
this
.
props
.
itemHeight
;
if
(
this
.
state
.
scroll
>
itemStartPosition
)
{
this
.
refs
.
tree
.
scrollTo
(
0
itemStartPosition
)
;
}
else
if
(
(
this
.
state
.
scroll
+
this
.
state
.
height
)
<
itemEndPosition
)
{
this
.
refs
.
tree
.
scrollTo
(
0
itemEndPosition
-
this
.
state
.
height
)
;
}
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_onBlur
(
)
{
this
.
_focus
(
0
undefined
)
;
}
_onScroll
:
oncePerAnimationFrame
(
function
(
e
)
{
this
.
setState
(
{
scroll
:
Math
.
max
(
this
.
refs
.
tree
.
scrollTop
0
)
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
)
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
props
.
getChildren
(
this
.
props
.
focused
)
.
length
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
;
}
}
_focusPrevNode
:
oncePerAnimationFrame
(
function
(
)
{
let
prev
;
let
prevIndex
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
prevIndex
=
i
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prevIndex
prev
)
;
}
)
_focusNextNode
:
oncePerAnimationFrame
(
function
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
i
+
1
traversal
[
i
+
1
]
.
item
)
;
}
}
)
_focusParentNode
:
oncePerAnimationFrame
(
function
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
return
;
}
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
parentIndex
=
0
;
for
(
;
parentIndex
<
length
;
parentIndex
+
+
)
{
if
(
traversal
[
parentIndex
]
.
item
=
=
=
parent
)
{
break
;
}
}
this
.
_focus
(
parentIndex
parent
)
;
}
)
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
{
itemHeight
}
=
this
.
props
;
const
{
scroll
height
}
=
this
.
state
;
const
begin
=
Math
.
max
(
(
(
scroll
/
itemHeight
)
|
0
)
-
NUMBER_OF_OFFSCREEN_ITEMS
0
)
;
const
end
=
Math
.
ceil
(
(
scroll
+
height
)
/
itemHeight
)
+
NUMBER_OF_OFFSCREEN_ITEMS
;
const
toRender
=
traversal
.
slice
(
begin
end
)
;
const
topSpacerHeight
=
begin
*
itemHeight
;
const
bottomSpacerHeight
=
Math
.
max
(
traversal
.
length
-
end
0
)
*
itemHeight
;
const
nodes
=
[
dom
.
div
(
{
key
:
"
top
-
spacer
"
style
:
{
padding
:
0
margin
:
0
height
:
topSpacerHeight
+
"
px
"
}
}
)
]
;
for
(
let
i
=
0
;
i
<
toRender
.
length
;
i
+
+
)
{
const
index
=
begin
+
i
;
const
first
=
index
=
=
0
;
const
last
=
index
=
=
traversal
.
length
-
1
;
const
{
item
depth
}
=
toRender
[
i
]
;
nodes
.
push
(
TreeNode
(
{
key
:
this
.
props
.
getKey
(
item
)
index
first
last
item
depth
renderItem
:
this
.
props
.
renderItem
focused
:
this
.
props
.
focused
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
hasChildren
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onFocus
:
(
)
=
>
this
.
_focus
(
begin
+
i
item
)
onFocusedNodeUnmount
:
(
)
=
>
this
.
refs
.
tree
&
&
this
.
refs
.
tree
.
focus
(
)
}
)
)
;
}
nodes
.
push
(
dom
.
div
(
{
key
:
"
bottom
-
spacer
"
style
:
{
padding
:
0
margin
:
0
height
:
bottomSpacerHeight
+
"
px
"
}
}
)
)
;
return
dom
.
div
(
{
className
:
"
tree
"
ref
:
"
tree
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
onScroll
:
this
.
_onScroll
style
:
{
padding
:
0
margin
:
0
}
}
nodes
)
;
}
}
)
;
const
ArrowExpander
=
createFactory
(
createClass
(
{
displayName
:
"
ArrowExpander
"
propTypes
:
{
item
:
PropTypes
.
any
.
isRequired
visible
:
PropTypes
.
bool
.
isRequired
expanded
:
PropTypes
.
bool
.
isRequired
onCollapse
:
PropTypes
.
func
.
isRequired
onExpand
:
PropTypes
.
func
.
isRequired
}
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
visible
!
=
=
nextProps
.
visible
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
attrs
=
{
className
:
"
arrow
theme
-
twisty
"
onClick
:
this
.
props
.
expanded
?
(
)
=
>
this
.
props
.
onCollapse
(
this
.
props
.
item
)
:
e
=
>
this
.
props
.
onExpand
(
this
.
props
.
item
e
.
altKey
)
}
;
if
(
this
.
props
.
expanded
)
{
attrs
.
className
+
=
"
open
"
;
}
if
(
!
this
.
props
.
visible
)
{
attrs
.
style
=
{
visibility
:
"
hidden
"
}
;
}
return
dom
.
div
(
attrs
)
;
}
}
)
)
;
const
TreeNode
=
createFactory
(
createClass
(
{
propTypes
:
{
focused
:
PropTypes
.
bool
.
isRequired
onFocusedNodeUnmount
:
PropTypes
.
func
item
:
PropTypes
.
any
.
isRequired
expanded
:
PropTypes
.
bool
.
isRequired
hasChildren
:
PropTypes
.
bool
.
isRequired
onExpand
:
PropTypes
.
func
.
isRequired
index
:
PropTypes
.
number
.
isRequired
first
:
PropTypes
.
bool
last
:
PropTypes
.
bool
onFocus
:
PropTypes
.
func
onBlur
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
.
isRequired
depth
:
PropTypes
.
number
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
}
componentDidMount
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
componentDidUpdate
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
componentWillUnmount
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
blur
(
)
;
if
(
this
.
props
.
onFocusedNodeUnmount
)
{
this
.
props
.
onFocusedNodeUnmount
(
)
;
}
}
}
_buttonAttrs
:
{
ref
:
"
button
"
style
:
{
opacity
:
0
width
:
"
0
!
important
"
height
:
"
0
!
important
"
padding
:
"
0
!
important
"
outline
:
"
none
"
MozAppearance
:
"
none
"
MozMarginStart
:
"
-
1000px
!
important
"
}
}
render
(
)
{
const
arrow
=
ArrowExpander
(
{
item
:
this
.
props
.
item
expanded
:
this
.
props
.
expanded
visible
:
this
.
props
.
hasChildren
onExpand
:
this
.
props
.
onExpand
onCollapse
:
this
.
props
.
onCollapse
}
)
;
let
classList
=
[
"
tree
-
node
"
"
div
"
]
;
if
(
this
.
props
.
index
%
2
)
{
classList
.
push
(
"
tree
-
node
-
odd
"
)
;
}
if
(
this
.
props
.
first
)
{
classList
.
push
(
"
tree
-
node
-
first
"
)
;
}
if
(
this
.
props
.
last
)
{
classList
.
push
(
"
tree
-
node
-
last
"
)
;
}
return
dom
.
div
(
{
className
:
classList
.
join
(
"
"
)
onFocus
:
this
.
props
.
onFocus
onClick
:
this
.
props
.
onFocus
onBlur
:
this
.
props
.
onBlur
"
data
-
expanded
"
:
this
.
props
.
expanded
?
"
"
:
undefined
"
data
-
depth
"
:
this
.
props
.
depth
style
:
{
padding
:
0
margin
:
0
}
}
this
.
props
.
renderItem
(
this
.
props
.
item
this
.
props
.
depth
this
.
props
.
focused
arrow
this
.
props
.
expanded
)
dom
.
button
(
this
.
_buttonAttrs
)
)
;
}
}
)
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
