"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
const
TEST_URI
=
"
data
:
text
/
html
;
charset
=
utf
-
8
stub
generation
"
;
const
EXPRESSIONS_BY_FILE
=
{
"
attribute
.
js
"
:
new
Map
(
[
[
"
Attribute
"
{
const
a
=
document
.
createAttribute
(
"
class
"
)
a
.
value
=
"
autocomplete
-
suggestions
"
;
a
;
}
]
]
)
"
comment
-
node
.
js
"
:
new
Map
(
[
[
"
Comment
"
{
document
.
createComment
(
"
test
\
\
nand
test
\
\
nand
test
\
\
nand
test
\
\
nand
test
\
\
nand
test
\
\
nand
test
"
)
}
]
]
)
"
date
-
time
.
js
"
:
new
Map
(
[
[
"
DateTime
"
new
Date
(
1459372644859
)
]
[
"
InvalidDateTime
"
new
Date
(
"
invalid
"
)
]
]
)
"
infinity
.
js
"
:
new
Map
(
[
[
"
Infinity
"
Infinity
]
[
"
NegativeInfinity
"
-
Infinity
]
]
)
"
nan
.
js
"
:
new
Map
(
[
[
"
NaN
"
2
*
document
]
]
)
"
null
.
js
"
:
new
Map
(
[
[
"
Null
"
null
]
]
)
"
number
.
js
"
:
new
Map
(
[
[
"
Int
"
2
+
3
]
[
"
True
"
true
]
[
"
False
"
false
]
[
"
NegZeroGrip
"
1
/
-
Infinity
]
]
)
"
text
-
node
.
js
"
:
new
Map
(
[
[
"
testRendering
"
let
tn
=
document
.
createTextNode
(
"
hello
world
"
)
;
document
.
body
.
append
(
tn
)
;
tn
;
]
[
"
testRenderingDisconnected
"
document
.
createTextNode
(
"
hello
world
"
)
]
[
"
testRenderingWithEOL
"
document
.
createTextNode
(
"
hello
\
\
nworld
"
)
]
[
"
testRenderingWithDoubleQuote
"
document
.
createTextNode
(
'
hello
"
world
'
)
]
[
"
testRenderingWithLongString
"
document
.
createTextNode
(
"
a
\
\
n
"
+
(
"
a
"
)
.
repeat
(
20000
)
)
]
]
)
"
undefined
.
js
"
:
new
Map
(
[
[
"
Undefined
"
undefined
]
]
)
"
window
.
js
"
:
new
Map
(
[
[
"
Window
"
window
]
]
)
}
;
add_task
(
async
function
(
)
{
const
isStubsUpdate
=
env
.
get
(
STUBS_UPDATE_ENV
)
=
=
"
true
"
;
const
tab
=
await
addTab
(
TEST_URI
)
;
const
{
CommandsFactory
}
=
require
(
"
devtools
/
shared
/
commands
/
commands
-
factory
"
)
;
const
commands
=
await
CommandsFactory
.
forTab
(
tab
)
;
await
commands
.
targetCommand
.
startListening
(
)
;
let
failed
=
false
;
for
(
const
stubFile
of
Object
.
keys
(
EXPRESSIONS_BY_FILE
)
)
{
info
(
{
isStubsUpdate
?
"
Update
"
:
"
Check
"
}
{
stubFile
}
)
;
const
generatedStubs
=
await
generateStubs
(
commands
stubFile
)
;
if
(
isStubsUpdate
)
{
await
writeStubsToFile
(
env
stubFile
generatedStubs
)
;
ok
(
true
{
stubFile
}
was
updated
)
;
continue
;
}
const
existingStubs
=
getStubFile
(
stubFile
)
;
if
(
generatedStubs
.
size
!
=
=
existingStubs
.
size
)
{
failed
=
true
;
continue
;
}
for
(
const
[
key
packet
]
of
generatedStubs
)
{
const
packetStr
=
getSerializedPacket
(
packet
{
sortKeys
:
true
replaceActorIds
:
true
}
)
;
const
grip
=
getSerializedPacket
(
existingStubs
.
get
(
key
)
{
sortKeys
:
true
replaceActorIds
:
true
}
)
;
is
(
packetStr
grip
"
{
key
}
"
packet
has
expected
value
)
;
failed
=
failed
|
|
packetStr
!
=
=
grip
;
}
}
if
(
failed
)
{
ok
(
false
"
The
reps
stubs
need
to
be
updated
by
running
"
+
mach
test
{
getCurrentTestFilePath
(
)
}
-
-
headless
-
-
setenv
STUBS_UPDATE
=
true
+
"
"
)
;
}
else
{
ok
(
true
"
Stubs
are
up
to
date
"
)
;
}
await
removeTab
(
tab
)
;
}
)
;
async
function
generateStubs
(
commands
stubFile
)
{
const
stubs
=
new
Map
(
)
;
for
(
const
[
key
expression
]
of
EXPRESSIONS_BY_FILE
[
stubFile
]
)
{
const
{
result
}
=
await
commands
.
scriptCommand
.
execute
(
expression
)
;
stubs
.
set
(
key
getCleanedPacket
(
stubFile
key
result
)
)
;
}
return
stubs
;
}
function
getCleanedPacket
(
stubFile
key
packet
)
{
delete
packet
.
targetFront
;
const
existingStubs
=
getStubFile
(
stubFile
)
;
if
(
!
existingStubs
)
{
return
packet
;
}
const
safeKey
=
key
.
replace
(
/
\
\
n
/
g
"
\
n
"
)
.
replace
(
/
\
\
r
/
g
"
\
r
"
)
.
replace
(
/
\
\
\
"
/
g
\
"
)
.
replace
(
/
\
\
\
'
/
g
\
'
)
;
if
(
!
existingStubs
.
has
(
safeKey
)
)
{
return
packet
;
}
const
existingPacket
=
existingStubs
.
get
(
safeKey
)
;
if
(
packet
.
_grip
?
.
contentDomReference
?
.
id
&
&
existingPacket
.
_grip
?
.
contentDomReference
?
.
id
)
{
packet
.
_grip
.
contentDomReference
=
existingPacket
.
_grip
.
contentDomReference
;
}
if
(
existingPacket
&
&
packet
.
_grip
?
.
class
=
=
=
"
Window
"
&
&
typeof
packet
.
_grip
.
ownPropertyLength
=
=
typeof
existingPacket
.
_grip
.
ownPropertyLength
)
{
packet
.
_grip
.
ownPropertyLength
=
existingPacket
.
_grip
.
ownPropertyLength
;
}
return
packet
;
}
const
CHROME_PREFIX
=
"
chrome
:
/
/
mochitests
/
content
/
browser
/
"
;
const
STUBS_FOLDER
=
"
devtools
/
client
/
shared
/
components
/
test
/
node
/
stubs
/
reps
/
"
;
const
STUBS_UPDATE_ENV
=
"
STUBS_UPDATE
"
;
async
function
writeStubsToFile
(
env
fileName
packets
)
{
const
mozRepo
=
env
.
get
(
"
MOZ_DEVELOPER_REPO_DIR
"
)
;
const
filePath
=
{
mozRepo
}
/
{
STUBS_FOLDER
+
fileName
}
;
const
stubs
=
Array
.
from
(
packets
.
entries
(
)
)
.
map
(
(
[
key
packet
]
)
=
>
{
const
stringifiedPacket
=
getSerializedPacket
(
packet
)
;
return
stubs
.
set
(
\
{
key
}
\
{
stringifiedPacket
}
)
;
;
}
)
;
const
fileContent
=
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
*
file
You
can
obtain
one
at
<
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
>
.
*
/
"
use
strict
"
;
/
*
*
THIS
FILE
IS
AUTOGENERATED
.
DO
NOT
MODIFY
BY
HAND
.
RUN
browser_reps_stubs
.
js
with
STUBS_UPDATE
=
true
env
TO
UPDATE
.
*
/
const
stubs
=
new
Map
(
)
;
{
stubs
.
join
(
"
\
n
\
n
"
)
}
module
.
exports
=
stubs
;
;
const
textEncoder
=
new
TextEncoder
(
)
;
await
IOUtils
.
write
(
filePath
textEncoder
.
encode
(
fileContent
)
)
;
}
function
getStubFile
(
fileName
)
{
return
require
(
CHROME_PREFIX
+
STUBS_FOLDER
+
fileName
)
;
}
function
sortObjectKeys
(
obj
)
{
const
isArray
=
Array
.
isArray
(
obj
)
;
const
isObject
=
Object
.
prototype
.
toString
.
call
(
obj
)
=
=
=
"
[
object
Object
]
"
;
const
isFront
=
obj
?
.
_grip
;
if
(
isObject
&
&
!
isFront
)
{
const
sortedKeys
=
Object
.
keys
(
obj
)
.
sort
(
(
k1
k2
)
=
>
k1
.
localeCompare
(
k2
)
)
;
const
withSortedKeys
=
{
}
;
sortedKeys
.
forEach
(
k
=
>
{
withSortedKeys
[
k
]
=
k
!
=
=
"
stacktrace
"
?
sortObjectKeys
(
obj
[
k
]
)
:
obj
[
k
]
;
}
)
;
return
withSortedKeys
;
}
else
if
(
isArray
)
{
return
obj
.
map
(
item
=
>
sortObjectKeys
(
item
)
)
;
}
return
obj
;
}
function
getSerializedPacket
(
packet
{
sortKeys
=
false
replaceActorIds
=
false
}
=
{
}
)
{
if
(
sortKeys
)
{
packet
=
sortObjectKeys
(
packet
)
;
}
const
actorIdPlaceholder
=
"
XXX
"
;
return
JSON
.
stringify
(
packet
function
(
key
value
)
{
if
(
value
&
&
value
.
_grip
)
{
return
{
_grip
:
value
.
_grip
actorID
:
replaceActorIds
?
actorIdPlaceholder
:
value
.
actorID
}
;
}
if
(
replaceActorIds
&
&
(
key
=
=
=
"
actor
"
|
|
key
=
=
=
"
actorID
"
|
|
key
=
=
=
"
sourceId
"
)
&
&
typeof
value
=
=
=
"
string
"
)
{
return
actorIdPlaceholder
;
}
return
value
;
}
2
)
;
}
