"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
flags
=
require
(
"
devtools
/
shared
/
flags
"
)
;
const
{
createRef
PureComponent
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
button
}
=
dom
;
const
{
HTMLTooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
"
)
;
loader
.
lazyRequireGetter
(
this
"
createPortal
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
true
)
;
const
omit
=
(
obj
fields
)
=
>
{
const
objCopy
=
{
.
.
.
obj
}
;
for
(
const
field
of
fields
)
{
delete
objCopy
[
field
]
;
}
return
objCopy
;
}
;
class
MenuButton
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
doc
:
PropTypes
.
object
.
isRequired
menuId
:
PropTypes
.
string
menuPosition
:
PropTypes
.
string
.
isRequired
menuOffset
:
PropTypes
.
number
.
isRequired
children
:
PropTypes
.
any
onClick
:
PropTypes
.
func
onCloseButton
:
PropTypes
.
func
}
;
}
static
get
defaultProps
(
)
{
return
{
menuPosition
:
"
bottom
"
menuOffset
:
-
5
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
showMenu
=
this
.
showMenu
.
bind
(
this
)
;
this
.
hideMenu
=
this
.
hideMenu
.
bind
(
this
)
;
this
.
toggleMenu
=
this
.
toggleMenu
.
bind
(
this
)
;
this
.
onHidden
=
this
.
onHidden
.
bind
(
this
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onTouchStart
=
this
.
onTouchStart
.
bind
(
this
)
;
this
.
buttonRef
=
createRef
(
)
;
this
.
state
=
{
expanded
:
false
isMenuInitialized
:
flags
.
testing
|
|
false
win
:
props
.
doc
.
defaultView
.
top
}
;
this
.
ignoreNextClick
=
false
;
this
.
initializeTooltip
(
)
;
}
componentDidMount
(
)
{
if
(
!
this
.
state
.
isMenuInitialized
)
{
for
(
const
event
of
[
"
focus
"
"
mousemove
"
]
)
{
this
.
buttonRef
.
current
.
addEventListener
(
event
(
)
=
>
{
if
(
!
this
.
state
.
isMenuInitialized
)
{
this
.
setState
(
{
isMenuInitialized
:
true
}
)
;
}
}
{
once
:
true
}
)
;
}
}
}
componentWillReceiveProps
(
nextProps
)
{
const
win
=
nextProps
.
doc
.
defaultView
.
top
;
if
(
nextProps
.
doc
!
=
=
this
.
props
.
doc
|
|
this
.
state
.
win
!
=
=
win
|
|
nextProps
.
menuId
!
=
=
this
.
props
.
menuId
)
{
this
.
setState
(
{
win
}
)
;
this
.
resetTooltip
(
)
;
this
.
initializeTooltip
(
)
;
}
}
componentDidUpdate
(
)
{
if
(
typeof
this
.
props
.
children
=
=
=
"
function
"
)
{
this
.
resizeContent
(
)
;
}
}
componentWillUnmount
(
)
{
this
.
resetTooltip
(
)
;
}
initializeTooltip
(
)
{
const
tooltipProps
=
{
type
:
"
doorhanger
"
useXulWrapper
:
true
}
;
if
(
this
.
props
.
menuId
)
{
tooltipProps
.
id
=
this
.
props
.
menuId
;
}
this
.
tooltip
=
new
HTMLTooltip
(
this
.
props
.
doc
tooltipProps
)
;
this
.
tooltip
.
on
(
"
hidden
"
this
.
onHidden
)
;
}
async
resetTooltip
(
)
{
if
(
!
this
.
tooltip
)
{
return
;
}
this
.
setState
(
{
expanded
:
false
}
)
;
this
.
tooltip
.
off
(
"
hidden
"
this
.
onHidden
)
;
this
.
tooltip
.
destroy
(
)
;
this
.
tooltip
=
null
;
}
async
showMenu
(
anchor
)
{
this
.
setState
(
{
expanded
:
true
}
)
;
if
(
!
this
.
tooltip
)
{
return
;
}
await
this
.
tooltip
.
show
(
anchor
{
position
:
this
.
props
.
menuPosition
y
:
this
.
props
.
menuOffset
}
)
;
}
async
hideMenu
(
)
{
this
.
setState
(
{
expanded
:
false
}
)
;
if
(
!
this
.
tooltip
)
{
return
;
}
await
this
.
tooltip
.
hide
(
)
;
}
async
toggleMenu
(
anchor
)
{
return
this
.
state
.
expanded
?
this
.
hideMenu
(
)
:
this
.
showMenu
(
anchor
)
;
}
resizeContent
(
)
{
if
(
!
this
.
state
.
expanded
|
|
!
this
.
tooltip
|
|
!
this
.
buttonRef
.
current
)
{
return
;
}
this
.
tooltip
.
updateContainerBounds
(
this
.
buttonRef
.
current
{
position
:
this
.
props
.
menuPosition
y
:
this
.
props
.
menuOffset
}
)
;
}
onTouchStart
(
evt
)
{
const
touchend
=
(
)
=
>
{
const
anchorRect
=
this
.
buttonRef
.
current
.
getClientRects
(
)
[
0
]
;
const
{
clientX
clientY
}
=
evt
.
changedTouches
[
0
]
;
if
(
anchorRect
.
x
<
=
clientX
&
&
clientX
<
=
anchorRect
.
x
+
anchorRect
.
width
&
&
anchorRect
.
y
<
=
clientY
&
&
clientY
<
=
anchorRect
.
y
+
anchorRect
.
height
)
{
this
.
ignoreNextClick
=
true
;
}
}
;
const
touchmove
=
(
)
=
>
{
this
.
state
.
win
.
removeEventListener
(
"
touchend
"
touchend
)
;
}
;
this
.
state
.
win
.
addEventListener
(
"
touchend
"
touchend
{
once
:
true
}
)
;
this
.
state
.
win
.
addEventListener
(
"
touchmove
"
touchmove
{
once
:
true
}
)
;
}
onHidden
(
)
{
this
.
setState
(
{
expanded
:
false
}
)
;
this
.
state
.
win
.
setTimeout
(
(
)
=
>
{
if
(
this
.
buttonRef
.
current
)
{
this
.
buttonRef
.
current
.
style
.
pointerEvents
=
"
auto
"
;
}
this
.
state
.
win
.
removeEventListener
(
"
touchstart
"
this
.
onTouchStart
true
)
;
}
0
)
;
this
.
state
.
win
.
addEventListener
(
"
touchstart
"
this
.
onTouchStart
true
)
;
if
(
this
.
props
.
onCloseButton
)
{
this
.
props
.
onCloseButton
(
)
;
}
}
async
onClick
(
e
)
{
if
(
this
.
ignoreNextClick
)
{
this
.
ignoreNextClick
=
false
;
return
;
}
if
(
e
.
target
=
=
=
this
.
buttonRef
.
current
)
{
this
.
buttonRef
.
current
.
focus
(
)
;
if
(
this
.
props
.
onClick
)
{
this
.
props
.
onClick
(
e
)
;
}
if
(
!
e
.
defaultPrevented
)
{
const
wasKeyboardEvent
=
e
.
screenX
=
=
=
0
&
&
e
.
screenY
=
=
=
0
;
if
(
!
this
.
state
.
expanded
&
&
!
Services
.
prefs
.
getBoolPref
(
"
ui
.
popup
.
disable_autohide
"
false
)
)
{
this
.
buttonRef
.
current
.
style
.
pointerEvents
=
"
none
"
;
}
await
this
.
toggleMenu
(
e
.
target
)
;
if
(
wasKeyboardEvent
&
&
this
.
tooltip
)
{
this
.
tooltip
.
focus
(
)
;
}
if
(
typeof
this
.
props
.
children
=
=
=
"
function
"
)
{
this
.
forceUpdate
(
)
;
}
}
}
else
if
(
this
.
state
.
expanded
&
&
!
e
.
defaultPrevented
)
{
this
.
hideMenu
(
)
;
}
}
onKeyDown
(
e
)
{
if
(
!
this
.
state
.
expanded
)
{
return
;
}
const
isButtonFocussed
=
this
.
props
.
doc
&
&
this
.
props
.
doc
.
activeElement
=
=
=
this
.
buttonRef
.
current
;
switch
(
e
.
key
)
{
case
"
Escape
"
:
this
.
hideMenu
(
)
;
e
.
preventDefault
(
)
;
break
;
case
"
Tab
"
:
case
"
ArrowDown
"
:
if
(
isButtonFocussed
&
&
this
.
tooltip
)
{
if
(
this
.
tooltip
.
focus
(
)
)
{
e
.
preventDefault
(
)
;
}
}
break
;
case
"
ArrowUp
"
:
if
(
isButtonFocussed
&
&
this
.
tooltip
)
{
if
(
this
.
tooltip
.
focusEnd
(
)
)
{
e
.
preventDefault
(
)
;
}
}
break
;
}
}
render
(
)
{
const
buttonProps
=
{
.
.
.
omit
(
this
.
props
Object
.
keys
(
MenuButton
.
propTypes
)
)
onClick
:
this
.
onClick
"
aria
-
expanded
"
:
this
.
state
.
expanded
"
aria
-
haspopup
"
:
"
menu
"
ref
:
this
.
buttonRef
}
;
if
(
this
.
state
.
expanded
)
{
buttonProps
.
onKeyDown
=
this
.
onKeyDown
;
}
if
(
this
.
props
.
menuId
)
{
buttonProps
[
"
aria
-
controls
"
]
=
this
.
props
.
menuId
;
}
if
(
this
.
state
.
isMenuInitialized
)
{
const
menu
=
createPortal
(
typeof
this
.
props
.
children
=
=
=
"
function
"
?
this
.
props
.
children
(
)
:
this
.
props
.
children
this
.
tooltip
.
panel
)
;
return
button
(
buttonProps
menu
)
;
}
return
button
(
buttonProps
)
;
}
}
module
.
exports
=
MenuButton
;
