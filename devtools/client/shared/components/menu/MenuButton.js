"
use
strict
"
;
const
flags
=
require
(
"
resource
:
/
/
devtools
/
shared
/
flags
.
js
"
)
;
const
{
createRef
PureComponent
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
.
js
"
)
;
const
PropTypes
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
.
js
"
)
;
const
dom
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
.
js
"
)
;
const
{
button
}
=
dom
;
const
isMacOS
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
loader
.
lazyRequireGetter
(
this
"
HTMLTooltip
"
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
focusableSelector
"
"
resource
:
/
/
devtools
/
client
/
shared
/
focus
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
createPortal
"
"
resource
:
/
/
devtools
/
client
/
shared
/
vendor
/
react
-
dom
.
js
"
true
)
;
const
omit
=
(
obj
fields
)
=
>
{
const
objCopy
=
{
.
.
.
obj
}
;
for
(
const
field
of
fields
)
{
delete
objCopy
[
field
]
;
}
return
objCopy
;
}
;
class
MenuButton
extends
PureComponent
{
static
get
propTypes
(
)
{
return
{
toolboxDoc
:
PropTypes
.
object
.
isRequired
label
:
PropTypes
.
string
icon
:
PropTypes
.
oneOfType
(
[
PropTypes
.
bool
PropTypes
.
string
]
)
menuId
:
PropTypes
.
string
menuPosition
:
PropTypes
.
string
.
isRequired
menuOffset
:
PropTypes
.
number
.
isRequired
children
:
PropTypes
.
any
onClick
:
PropTypes
.
func
onCloseButton
:
PropTypes
.
func
}
;
}
static
get
defaultProps
(
)
{
return
{
menuPosition
:
"
bottom
"
menuOffset
:
-
5
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
showMenu
=
this
.
showMenu
.
bind
(
this
)
;
this
.
hideMenu
=
this
.
hideMenu
.
bind
(
this
)
;
this
.
toggleMenu
=
this
.
toggleMenu
.
bind
(
this
)
;
this
.
onHidden
=
this
.
onHidden
.
bind
(
this
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onTouchStart
=
this
.
onTouchStart
.
bind
(
this
)
;
this
.
buttonRef
=
createRef
(
)
;
this
.
state
=
{
expanded
:
false
isMenuInitialized
:
flags
.
testing
|
|
false
win
:
props
.
toolboxDoc
.
defaultView
.
top
}
;
this
.
ignoreNextClick
=
false
;
this
.
initializeTooltip
(
)
;
}
componentDidMount
(
)
{
if
(
!
this
.
state
.
isMenuInitialized
)
{
for
(
const
event
of
[
"
focus
"
"
mousemove
"
]
)
{
this
.
buttonRef
.
current
.
addEventListener
(
event
(
)
=
>
{
if
(
!
this
.
state
.
isMenuInitialized
)
{
this
.
setState
(
{
isMenuInitialized
:
true
}
)
;
}
}
{
once
:
true
}
)
;
}
}
}
UNSAFE_componentWillReceiveProps
(
nextProps
)
{
const
win
=
nextProps
.
toolboxDoc
.
defaultView
.
top
;
if
(
nextProps
.
toolboxDoc
!
=
=
this
.
props
.
toolboxDoc
|
|
this
.
state
.
win
!
=
=
win
|
|
nextProps
.
menuId
!
=
=
this
.
props
.
menuId
)
{
this
.
setState
(
{
win
}
)
;
this
.
resetTooltip
(
)
;
this
.
initializeTooltip
(
)
;
}
}
componentDidUpdate
(
)
{
if
(
typeof
this
.
props
.
children
=
=
=
"
function
"
)
{
this
.
resizeContent
(
)
;
}
}
componentWillUnmount
(
)
{
this
.
resetTooltip
(
)
;
}
initializeTooltip
(
)
{
const
tooltipProps
=
{
type
:
"
doorhanger
"
useXulWrapper
:
true
isMenuTooltip
:
true
}
;
if
(
this
.
props
.
menuId
)
{
tooltipProps
.
id
=
this
.
props
.
menuId
;
}
this
.
tooltip
=
new
HTMLTooltip
(
this
.
props
.
toolboxDoc
tooltipProps
)
;
this
.
tooltip
.
on
(
"
hidden
"
this
.
onHidden
)
;
}
async
resetTooltip
(
)
{
if
(
!
this
.
tooltip
)
{
return
;
}
this
.
setState
(
{
expanded
:
false
}
)
;
this
.
tooltip
.
off
(
"
hidden
"
this
.
onHidden
)
;
this
.
tooltip
.
destroy
(
)
;
this
.
tooltip
=
null
;
}
async
showMenu
(
anchor
)
{
this
.
setState
(
{
expanded
:
true
}
)
;
if
(
!
this
.
tooltip
)
{
return
;
}
await
this
.
tooltip
.
show
(
anchor
{
position
:
this
.
props
.
menuPosition
y
:
this
.
props
.
menuOffset
}
)
;
}
async
hideMenu
(
)
{
this
.
setState
(
{
expanded
:
false
}
)
;
if
(
!
this
.
tooltip
)
{
return
;
}
await
this
.
tooltip
.
hide
(
)
;
}
async
toggleMenu
(
anchor
)
{
return
this
.
state
.
expanded
?
this
.
hideMenu
(
)
:
this
.
showMenu
(
anchor
)
;
}
resizeContent
(
)
{
if
(
!
this
.
state
.
expanded
|
|
!
this
.
tooltip
|
|
!
this
.
buttonRef
.
current
)
{
return
;
}
this
.
tooltip
.
show
(
this
.
buttonRef
.
current
{
position
:
this
.
props
.
menuPosition
y
:
this
.
props
.
menuOffset
}
)
;
}
onTouchStart
(
evt
)
{
const
touchend
=
(
)
=
>
{
const
anchorRect
=
this
.
buttonRef
.
current
.
getClientRects
(
)
[
0
]
;
const
{
clientX
clientY
}
=
evt
.
changedTouches
[
0
]
;
if
(
anchorRect
.
x
<
=
clientX
&
&
clientX
<
=
anchorRect
.
x
+
anchorRect
.
width
&
&
anchorRect
.
y
<
=
clientY
&
&
clientY
<
=
anchorRect
.
y
+
anchorRect
.
height
)
{
this
.
ignoreNextClick
=
true
;
}
}
;
const
touchmove
=
(
)
=
>
{
this
.
state
.
win
.
removeEventListener
(
"
touchend
"
touchend
)
;
}
;
this
.
state
.
win
.
addEventListener
(
"
touchend
"
touchend
{
once
:
true
}
)
;
this
.
state
.
win
.
addEventListener
(
"
touchmove
"
touchmove
{
once
:
true
}
)
;
}
onHidden
(
)
{
this
.
setState
(
{
expanded
:
false
}
)
;
this
.
state
.
win
.
setTimeout
(
(
)
=
>
{
if
(
this
.
buttonRef
.
current
)
{
this
.
buttonRef
.
current
.
style
.
pointerEvents
=
"
auto
"
;
}
this
.
state
.
win
.
removeEventListener
(
"
touchstart
"
this
.
onTouchStart
true
)
;
}
0
)
;
this
.
state
.
win
.
addEventListener
(
"
touchstart
"
this
.
onTouchStart
true
)
;
if
(
this
.
props
.
onCloseButton
)
{
this
.
props
.
onCloseButton
(
)
;
}
}
async
onClick
(
e
)
{
if
(
this
.
ignoreNextClick
)
{
this
.
ignoreNextClick
=
false
;
return
;
}
if
(
e
.
target
=
=
=
this
.
buttonRef
.
current
)
{
this
.
buttonRef
.
current
.
focus
(
)
;
if
(
this
.
props
.
onClick
)
{
this
.
props
.
onClick
(
e
)
;
}
if
(
!
e
.
defaultPrevented
)
{
const
wasKeyboardEvent
=
e
.
screenX
=
=
=
0
&
&
e
.
screenY
=
=
=
0
;
if
(
!
this
.
state
.
expanded
&
&
!
Services
.
prefs
.
getBoolPref
(
"
ui
.
popup
.
disable_autohide
"
false
)
)
{
this
.
buttonRef
.
current
.
style
.
pointerEvents
=
"
none
"
;
}
await
this
.
toggleMenu
(
e
.
target
)
;
if
(
wasKeyboardEvent
&
&
this
.
tooltip
)
{
this
.
tooltip
.
focus
(
)
;
}
if
(
typeof
this
.
props
.
children
=
=
=
"
function
"
)
{
this
.
forceUpdate
(
)
;
}
}
}
else
if
(
this
.
state
.
expanded
&
&
!
e
.
defaultPrevented
&
&
e
.
target
.
matches
(
focusableSelector
)
)
{
this
.
hideMenu
(
)
;
}
}
onKeyDown
(
e
)
{
if
(
!
this
.
state
.
expanded
)
{
return
;
}
const
isButtonFocussed
=
this
.
props
.
toolboxDoc
&
&
this
.
props
.
toolboxDoc
.
activeElement
=
=
=
this
.
buttonRef
.
current
;
switch
(
e
.
key
)
{
case
"
Escape
"
:
this
.
hideMenu
(
)
;
e
.
preventDefault
(
)
;
break
;
case
"
Tab
"
:
case
"
ArrowDown
"
:
if
(
isButtonFocussed
&
&
this
.
tooltip
)
{
if
(
this
.
tooltip
.
focus
(
)
)
{
e
.
preventDefault
(
)
;
}
}
break
;
case
"
ArrowUp
"
:
if
(
isButtonFocussed
&
&
this
.
tooltip
)
{
if
(
this
.
tooltip
.
focusEnd
(
)
)
{
e
.
preventDefault
(
)
;
}
}
break
;
case
"
t
"
:
if
(
(
isMacOS
&
&
e
.
metaKey
)
|
|
(
!
isMacOS
&
&
e
.
ctrlKey
)
)
{
this
.
hideMenu
(
)
;
}
break
;
}
}
render
(
)
{
const
buttonProps
=
{
.
.
.
omit
(
this
.
props
Object
.
keys
(
MenuButton
.
propTypes
)
)
onClick
:
this
.
onClick
"
aria
-
expanded
"
:
this
.
state
.
expanded
"
aria
-
haspopup
"
:
"
menu
"
ref
:
this
.
buttonRef
}
;
if
(
this
.
state
.
expanded
)
{
buttonProps
.
onKeyDown
=
this
.
onKeyDown
;
}
if
(
this
.
props
.
menuId
)
{
buttonProps
[
"
aria
-
controls
"
]
=
this
.
props
.
menuId
;
}
if
(
this
.
props
.
icon
)
{
const
iconClass
=
"
menu
-
button
-
-
iconic
"
;
buttonProps
.
className
=
buttonProps
.
className
?
{
buttonProps
.
className
}
{
iconClass
}
:
iconClass
;
if
(
typeof
this
.
props
.
icon
=
=
"
string
"
)
{
buttonProps
.
style
=
{
"
-
-
menuitem
-
icon
-
image
"
:
"
url
(
"
+
this
.
props
.
icon
+
"
)
"
}
;
}
}
if
(
this
.
state
.
isMenuInitialized
)
{
const
menu
=
createPortal
(
typeof
this
.
props
.
children
=
=
=
"
function
"
?
this
.
props
.
children
(
)
:
this
.
props
.
children
this
.
tooltip
.
panel
)
;
return
button
(
buttonProps
this
.
props
.
label
menu
)
;
}
return
button
(
buttonProps
this
.
props
.
label
)
;
}
}
module
.
exports
=
MenuButton
;
