"
use
strict
"
;
define
(
function
(
require
exports
module
)
{
const
{
Component
createFactory
createRef
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
findDOMNode
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
tr
}
=
dom
;
const
TreeCell
=
createFactory
(
require
(
"
.
/
TreeCell
"
)
)
;
const
LabelCell
=
createFactory
(
require
(
"
.
/
LabelCell
"
)
)
;
const
{
focusableSelector
}
=
require
(
"
devtools
/
client
/
shared
/
focus
"
)
;
const
UPDATE_ON_PROPS
=
[
"
name
"
"
open
"
"
value
"
"
loading
"
"
level
"
"
selected
"
"
active
"
"
hasChildren
"
]
;
class
TreeRow
extends
Component
{
static
get
propTypes
(
)
{
return
{
member
:
PropTypes
.
shape
(
{
object
:
PropTypes
.
obSject
name
:
PropTypes
.
sring
type
:
PropTypes
.
string
.
isRequired
rowClass
:
PropTypes
.
string
.
isRequired
level
:
PropTypes
.
number
.
isRequired
hasChildren
:
PropTypes
.
bool
value
:
PropTypes
.
any
open
:
PropTypes
.
bool
.
isRequired
path
:
PropTypes
.
string
.
isRequired
hidden
:
PropTypes
.
bool
selected
:
PropTypes
.
bool
active
:
PropTypes
.
bool
}
)
decorator
:
PropTypes
.
object
renderCell
:
PropTypes
.
object
renderLabelCell
:
PropTypes
.
object
columns
:
PropTypes
.
array
.
isRequired
id
:
PropTypes
.
string
.
isRequired
provider
:
PropTypes
.
object
.
isRequired
onClick
:
PropTypes
.
func
.
isRequired
onContextMenu
:
PropTypes
.
func
onMouseOver
:
PropTypes
.
func
onMouseOut
:
PropTypes
.
func
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
treeRowRef
=
createRef
(
)
;
this
.
getRowClass
=
this
.
getRowClass
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
}
componentDidMount
(
)
{
this
.
_setTabbableState
(
)
;
const
win
=
this
.
treeRowRef
.
current
.
ownerDocument
.
defaultView
;
const
{
MutationObserver
}
=
win
;
this
.
observer
=
new
MutationObserver
(
(
)
=
>
{
this
.
_setTabbableState
(
)
;
}
)
;
this
.
observer
.
observe
(
this
.
treeRowRef
.
current
{
childList
:
true
subtree
:
true
}
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
nextProps
.
member
.
hidden
!
=
this
.
props
.
member
.
hidden
)
{
const
row
=
findDOMNode
(
this
)
;
row
.
classList
.
toggle
(
"
hidden
"
)
;
}
}
shouldComponentUpdate
(
nextProps
)
{
for
(
const
prop
of
UPDATE_ON_PROPS
)
{
if
(
nextProps
.
member
[
prop
]
!
=
this
.
props
.
member
[
prop
]
)
{
return
true
;
}
}
return
false
;
}
componentWillUnmount
(
)
{
this
.
observer
.
disconnect
(
)
;
this
.
observer
=
null
;
}
_setTabbableState
(
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
if
(
elms
.
length
=
=
=
0
)
{
return
;
}
const
{
active
}
=
this
.
props
.
member
;
if
(
!
active
)
{
elms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
)
;
return
;
}
if
(
!
elms
.
includes
(
document
.
activeElement
)
)
{
elms
[
0
]
.
focus
(
)
;
}
}
getFocusableElements
(
)
{
return
Array
.
from
(
this
.
treeRowRef
.
current
.
querySelectorAll
(
focusableSelector
)
)
;
}
_wrapMoveFocus
(
current
back
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
let
next
;
if
(
elms
.
length
=
=
=
0
)
{
return
false
;
}
if
(
back
)
{
if
(
elms
.
indexOf
(
current
)
=
=
=
0
)
{
next
=
elms
[
elms
.
length
-
1
]
;
next
.
focus
(
)
;
}
}
else
if
(
elms
.
indexOf
(
current
)
=
=
=
elms
.
length
-
1
)
{
next
=
elms
[
0
]
;
next
.
focus
(
)
;
}
return
!
!
next
;
}
_onKeyDown
(
e
)
{
const
{
target
key
shiftKey
}
=
e
;
if
(
key
!
=
=
"
Tab
"
)
{
return
;
}
const
focusMoved
=
this
.
_wrapMoveFocus
(
target
shiftKey
)
;
if
(
focusMoved
)
{
e
.
preventDefault
(
)
;
}
e
.
stopPropagation
(
)
;
}
getRowClass
(
object
)
{
const
decorator
=
this
.
props
.
decorator
;
if
(
!
decorator
|
|
!
decorator
.
getRowClass
)
{
return
[
]
;
}
let
classNames
=
decorator
.
getRowClass
(
object
)
;
if
(
!
classNames
)
{
return
[
]
;
}
if
(
typeof
classNames
=
=
"
string
"
)
{
classNames
=
[
classNames
]
;
}
return
classNames
;
}
render
(
)
{
const
member
=
this
.
props
.
member
;
const
decorator
=
this
.
props
.
decorator
;
const
props
=
{
id
:
this
.
props
.
id
ref
:
this
.
treeRowRef
role
:
"
treeitem
"
"
aria
-
level
"
:
member
.
level
+
1
"
aria
-
selected
"
:
!
!
member
.
selected
onClick
:
this
.
props
.
onClick
onContextMenu
:
this
.
props
.
onContextMenu
onKeyDownCapture
:
member
.
active
?
this
.
_onKeyDown
:
undefined
onMouseOver
:
this
.
props
.
onMouseOver
onMouseOut
:
this
.
props
.
onMouseOut
}
;
const
classNames
=
this
.
getRowClass
(
member
.
object
)
|
|
[
]
;
classNames
.
push
(
"
treeRow
"
)
;
classNames
.
push
(
member
.
type
+
"
Row
"
)
;
if
(
member
.
hasChildren
)
{
classNames
.
push
(
"
hasChildren
"
)
;
props
[
"
aria
-
expanded
"
]
=
false
;
}
if
(
member
.
open
)
{
classNames
.
push
(
"
opened
"
)
;
props
[
"
aria
-
expanded
"
]
=
true
;
}
if
(
member
.
loading
)
{
classNames
.
push
(
"
loading
"
)
;
}
if
(
member
.
selected
)
{
classNames
.
push
(
"
selected
"
)
;
}
if
(
member
.
hidden
)
{
classNames
.
push
(
"
hidden
"
)
;
}
props
.
className
=
classNames
.
join
(
"
"
)
;
const
cells
=
[
]
;
let
renderCell
=
this
.
props
.
renderCell
|
|
RenderCell
;
let
renderLabelCell
=
this
.
props
.
renderLabelCell
|
|
RenderLabelCell
;
if
(
decorator
&
&
decorator
.
renderLabelCell
)
{
renderLabelCell
=
decorator
.
renderLabelCell
(
member
.
object
)
|
|
renderLabelCell
;
}
this
.
props
.
columns
.
forEach
(
col
=
>
{
const
cellProps
=
Object
.
assign
(
{
}
this
.
props
{
key
:
col
.
id
id
:
col
.
id
value
:
this
.
props
.
provider
.
getValue
(
member
.
object
col
.
id
)
}
)
;
if
(
decorator
&
&
decorator
.
renderCell
)
{
renderCell
=
decorator
.
renderCell
(
member
.
object
col
.
id
)
;
}
const
render
=
col
.
id
=
=
"
default
"
?
renderLabelCell
:
renderCell
;
if
(
render
)
{
cells
.
push
(
render
(
cellProps
)
)
;
}
}
)
;
return
tr
(
props
cells
)
;
}
}
const
RenderCell
=
props
=
>
{
return
TreeCell
(
props
)
;
}
;
const
RenderLabelCell
=
props
=
>
{
return
LabelCell
(
props
)
;
}
;
module
.
exports
=
TreeRow
;
}
)
;
