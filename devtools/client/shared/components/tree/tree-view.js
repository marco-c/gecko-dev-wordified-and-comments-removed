"
use
strict
"
;
define
(
function
(
require
exports
module
)
{
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
ObjectProvider
}
=
require
(
"
.
/
object
-
provider
"
)
;
const
TreeRow
=
React
.
createFactory
(
require
(
"
.
/
tree
-
row
"
)
)
;
const
TreeHeader
=
React
.
createFactory
(
require
(
"
.
/
tree
-
header
"
)
)
;
const
DOM
=
React
.
DOM
;
const
PropTypes
=
React
.
PropTypes
;
let
TreeView
=
React
.
createClass
(
{
displayName
:
"
TreeView
"
propTypes
:
{
object
:
PropTypes
.
any
className
:
PropTypes
.
string
provider
:
PropTypes
.
shape
(
{
getChildren
:
PropTypes
.
func
hasChildren
:
PropTypes
.
func
getLabel
:
PropTypes
.
func
getValue
:
PropTypes
.
func
getKey
:
PropTypes
.
func
getType
:
PropTypes
.
func
}
)
.
isRequired
decorator
:
PropTypes
.
shape
(
{
getRowClass
:
PropTypes
.
func
getCellClass
:
PropTypes
.
func
getHeaderClass
:
PropTypes
.
func
renderValue
:
PropTypes
.
func
renderRow
:
PropTypes
.
func
renderCelL
:
PropTypes
.
func
renderLabelCell
:
PropTypes
.
func
}
)
renderRow
:
PropTypes
.
func
renderCell
:
PropTypes
.
func
renderValue
:
PropTypes
.
func
renderLabelCell
:
PropTypes
.
func
expandedNodes
:
PropTypes
.
object
onFilter
:
PropTypes
.
func
onSort
:
PropTypes
.
func
header
:
PropTypes
.
bool
columns
:
PropTypes
.
arrayOf
(
PropTypes
.
shape
(
{
id
:
PropTypes
.
string
.
isRequired
title
:
PropTypes
.
string
width
:
PropTypes
.
string
}
)
)
}
getDefaultProps
:
function
(
)
{
return
{
object
:
null
renderRow
:
null
provider
:
ObjectProvider
expandedNodes
:
new
Set
(
)
columns
:
[
]
}
;
}
getInitialState
:
function
(
)
{
return
{
expandedNodes
:
this
.
props
.
expandedNodes
columns
:
ensureDefaultColumn
(
this
.
props
.
columns
)
}
;
}
toggle
:
function
(
nodePath
)
{
let
nodes
=
this
.
state
.
expandedNodes
;
if
(
this
.
isExpanded
(
nodePath
)
)
{
nodes
.
delete
(
nodePath
)
;
}
else
{
nodes
.
add
(
nodePath
)
;
}
this
.
setState
(
Object
.
assign
(
{
}
this
.
state
{
expandedNodes
:
nodes
}
)
)
;
}
isExpanded
:
function
(
nodePath
)
{
return
this
.
state
.
expandedNodes
.
has
(
nodePath
)
;
}
onClickRow
:
function
(
nodePath
event
)
{
event
.
stopPropagation
(
)
;
this
.
toggle
(
nodePath
)
;
}
onFilter
:
function
(
object
)
{
let
onFilter
=
this
.
props
.
onFilter
;
return
onFilter
?
onFilter
(
object
)
:
true
;
}
onSort
:
function
(
parent
children
)
{
let
onSort
=
this
.
props
.
onSort
;
return
onSort
?
onSort
(
parent
children
)
:
children
;
}
getMembers
:
function
(
parent
level
path
)
{
if
(
typeof
parent
=
=
"
string
"
)
{
return
[
]
;
}
let
provider
=
this
.
props
.
provider
;
let
children
=
provider
.
getChildren
(
parent
)
|
|
[
]
;
if
(
!
Array
.
isArray
(
children
)
)
{
return
children
;
}
children
=
this
.
onSort
(
parent
children
)
|
|
children
;
return
children
.
map
(
child
=
>
{
let
key
=
provider
.
getKey
(
child
)
;
let
nodePath
=
path
+
"
/
"
+
key
;
let
type
=
provider
.
getType
(
child
)
;
let
hasChildren
=
provider
.
hasChildren
(
child
)
;
let
value
=
provider
.
getValue
(
child
)
;
if
(
isLongString
(
value
)
)
{
hasChildren
=
true
;
}
return
{
object
:
child
name
:
provider
.
getLabel
(
child
)
type
:
type
rowClass
:
"
treeRow
-
"
+
type
level
:
level
hasChildren
:
hasChildren
value
:
value
open
:
this
.
isExpanded
(
nodePath
)
path
:
nodePath
hidden
:
!
this
.
onFilter
(
child
)
}
;
}
)
;
}
renderRows
:
function
(
parent
level
=
0
path
=
"
"
)
{
let
rows
=
[
]
;
let
decorator
=
this
.
props
.
decorator
;
let
renderRow
=
this
.
props
.
renderRow
|
|
TreeRow
;
let
members
=
this
.
getMembers
(
parent
level
path
)
;
if
(
!
Array
.
isArray
(
members
)
)
{
return
members
;
}
members
.
forEach
(
member
=
>
{
if
(
decorator
&
&
decorator
.
renderRow
)
{
renderRow
=
decorator
.
renderRow
(
member
.
object
)
|
|
renderRow
;
}
let
props
=
Object
.
assign
(
{
}
this
.
props
{
key
:
member
.
path
member
:
member
columns
:
this
.
state
.
columns
onClick
:
this
.
onClickRow
.
bind
(
this
member
.
path
)
}
)
;
rows
.
push
(
renderRow
(
props
)
)
;
if
(
member
.
hasChildren
&
&
member
.
open
)
{
let
childRows
=
this
.
renderRows
(
member
.
object
level
+
1
member
.
path
)
;
if
(
!
Array
.
isArray
(
childRows
)
)
{
let
lastIndex
=
rows
.
length
-
1
;
props
.
member
.
loading
=
true
;
rows
[
lastIndex
]
=
React
.
cloneElement
(
rows
[
lastIndex
]
props
)
;
}
else
{
rows
=
rows
.
concat
(
childRows
)
;
}
}
}
)
;
return
rows
;
}
render
:
function
(
)
{
let
root
=
this
.
props
.
object
;
let
classNames
=
[
"
treeTable
"
]
;
let
className
=
this
.
props
.
className
;
if
(
className
)
{
classNames
.
push
(
.
.
.
className
.
split
(
"
"
)
)
;
}
let
rows
=
this
.
renderRows
(
root
0
"
"
)
;
if
(
!
Array
.
isArray
(
rows
)
)
{
rows
=
[
]
;
}
let
props
=
Object
.
assign
(
{
}
this
.
props
{
columns
:
this
.
state
.
columns
}
)
;
return
(
DOM
.
table
(
{
className
:
classNames
.
join
(
"
"
)
cellPadding
:
0
cellSpacing
:
0
}
TreeHeader
(
props
)
DOM
.
tbody
(
{
}
rows
)
)
)
;
}
}
)
;
function
ensureDefaultColumn
(
columns
)
{
if
(
!
columns
)
{
columns
=
[
]
;
}
let
defaultColumn
=
columns
.
filter
(
col
=
>
col
.
id
=
=
"
default
"
)
;
if
(
defaultColumn
.
length
)
{
return
columns
;
}
return
[
{
id
:
"
default
"
}
.
.
.
columns
]
;
}
function
isLongString
(
value
)
{
return
typeof
value
=
=
"
string
"
&
&
value
.
length
>
50
;
}
module
.
exports
=
TreeView
;
}
)
;
