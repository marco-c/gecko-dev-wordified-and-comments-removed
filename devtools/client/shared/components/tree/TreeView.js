"
use
strict
"
;
define
(
function
(
require
exports
module
)
{
const
{
cloneElement
Component
createFactory
createRef
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
{
findDOMNode
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
ObjectProvider
}
=
require
(
"
.
/
ObjectProvider
"
)
;
const
TreeRow
=
createFactory
(
require
(
"
.
/
TreeRow
"
)
)
;
const
TreeHeader
=
createFactory
(
require
(
"
.
/
TreeHeader
"
)
)
;
const
{
scrollIntoView
}
=
require
(
"
devtools
/
client
/
shared
/
scroll
"
)
;
const
SUPPORTED_KEYS
=
[
"
ArrowUp
"
"
ArrowDown
"
"
ArrowLeft
"
"
ArrowRight
"
"
End
"
"
Home
"
"
Enter
"
"
"
"
Escape
"
]
;
const
defaultProps
=
{
object
:
null
renderRow
:
null
provider
:
ObjectProvider
expandedNodes
:
new
Set
(
)
selected
:
null
active
:
null
expandableStrings
:
true
columns
:
[
]
}
;
class
TreeView
extends
Component
{
static
get
propTypes
(
)
{
return
{
object
:
PropTypes
.
any
className
:
PropTypes
.
string
label
:
PropTypes
.
string
provider
:
PropTypes
.
shape
(
{
getChildren
:
PropTypes
.
func
hasChildren
:
PropTypes
.
func
getLabel
:
PropTypes
.
func
getValue
:
PropTypes
.
func
getKey
:
PropTypes
.
func
getType
:
PropTypes
.
func
}
)
.
isRequired
decorator
:
PropTypes
.
shape
(
{
getRowClass
:
PropTypes
.
func
getCellClass
:
PropTypes
.
func
getHeaderClass
:
PropTypes
.
func
renderValue
:
PropTypes
.
func
renderRow
:
PropTypes
.
func
renderCell
:
PropTypes
.
func
renderLabelCell
:
PropTypes
.
func
}
)
renderRow
:
PropTypes
.
func
renderCell
:
PropTypes
.
func
renderValue
:
PropTypes
.
func
renderLabelCell
:
PropTypes
.
func
expandedNodes
:
PropTypes
.
object
selected
:
PropTypes
.
string
active
:
PropTypes
.
string
onFilter
:
PropTypes
.
func
onSort
:
PropTypes
.
func
onClickRow
:
PropTypes
.
func
onContextMenuRow
:
PropTypes
.
func
onContextMenuTree
:
PropTypes
.
func
header
:
PropTypes
.
bool
expandableStrings
:
PropTypes
.
bool
columns
:
PropTypes
.
arrayOf
(
PropTypes
.
shape
(
{
id
:
PropTypes
.
string
.
isRequired
title
:
PropTypes
.
string
width
:
PropTypes
.
string
}
)
)
}
;
}
static
get
defaultProps
(
)
{
return
defaultProps
;
}
static
subPath
(
path
subKey
)
{
return
path
+
"
/
"
+
String
(
subKey
)
.
replace
(
/
[
\
\
/
]
/
g
"
\
\
&
"
)
;
}
static
getExpandedNodes
(
rootObj
{
maxLevel
=
Infinity
maxNodes
=
Infinity
}
=
{
}
)
{
const
expandedNodes
=
new
Set
(
)
;
const
queue
=
[
{
object
:
rootObj
level
:
1
path
:
"
"
}
]
;
while
(
queue
.
length
)
{
const
{
object
level
path
}
=
queue
.
shift
(
)
;
if
(
Object
(
object
)
!
=
=
object
)
{
continue
;
}
const
keys
=
Object
.
keys
(
object
)
;
if
(
expandedNodes
.
size
+
keys
.
length
>
maxNodes
)
{
break
;
}
for
(
const
key
of
keys
)
{
const
nodePath
=
TreeView
.
subPath
(
path
key
)
;
expandedNodes
.
add
(
nodePath
)
;
if
(
level
<
maxLevel
)
{
queue
.
push
(
{
object
:
object
[
key
]
level
:
level
+
1
path
:
nodePath
}
)
;
}
}
}
return
expandedNodes
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
expandedNodes
:
props
.
expandedNodes
columns
:
ensureDefaultColumn
(
props
.
columns
)
selected
:
props
.
selected
active
:
props
.
active
lastSelectedIndex
:
0
}
;
this
.
treeRef
=
createRef
(
)
;
this
.
toggle
=
this
.
toggle
.
bind
(
this
)
;
this
.
isExpanded
=
this
.
isExpanded
.
bind
(
this
)
;
this
.
onKeyDown
=
this
.
onKeyDown
.
bind
(
this
)
;
this
.
onClickRow
=
this
.
onClickRow
.
bind
(
this
)
;
this
.
getSelectedRow
=
this
.
getSelectedRow
.
bind
(
this
)
;
this
.
selectRow
=
this
.
selectRow
.
bind
(
this
)
;
this
.
activateRow
=
this
.
activateRow
.
bind
(
this
)
;
this
.
isSelected
=
this
.
isSelected
.
bind
(
this
)
;
this
.
onFilter
=
this
.
onFilter
.
bind
(
this
)
;
this
.
onSort
=
this
.
onSort
.
bind
(
this
)
;
this
.
getMembers
=
this
.
getMembers
.
bind
(
this
)
;
this
.
renderRows
=
this
.
renderRows
.
bind
(
this
)
;
}
componentWillReceiveProps
(
nextProps
)
{
const
{
expandedNodes
selected
}
=
nextProps
;
const
state
=
{
expandedNodes
lastSelectedIndex
:
this
.
getSelectedRowIndex
(
)
}
;
if
(
selected
)
{
state
.
selected
=
selected
;
}
this
.
setState
(
Object
.
assign
(
{
}
this
.
state
state
)
)
;
}
componentDidUpdate
(
)
{
const
selected
=
this
.
getSelectedRow
(
)
;
if
(
selected
)
{
return
;
}
const
rows
=
this
.
visibleRows
;
if
(
rows
.
length
=
=
=
0
)
{
return
;
}
this
.
selectRow
(
rows
[
Math
.
min
(
this
.
state
.
lastSelectedIndex
rows
.
length
-
1
)
]
{
alignTo
:
"
top
"
}
)
;
}
get
visibleRows
(
)
{
return
this
.
rows
.
filter
(
row
=
>
{
const
rowEl
=
findDOMNode
(
row
)
;
return
rowEl
&
&
rowEl
.
offsetParent
;
}
)
;
}
toggle
(
nodePath
)
{
const
nodes
=
this
.
state
.
expandedNodes
;
if
(
this
.
isExpanded
(
nodePath
)
)
{
nodes
.
delete
(
nodePath
)
;
}
else
{
nodes
.
add
(
nodePath
)
;
}
this
.
setState
(
Object
.
assign
(
{
}
this
.
state
{
expandedNodes
:
nodes
}
)
)
;
}
isExpanded
(
nodePath
)
{
return
this
.
state
.
expandedNodes
.
has
(
nodePath
)
;
}
onKeyDown
(
event
)
{
if
(
!
SUPPORTED_KEYS
.
includes
(
event
.
key
)
)
{
return
;
}
const
row
=
this
.
getSelectedRow
(
)
;
if
(
!
row
)
{
return
;
}
const
rows
=
this
.
visibleRows
;
const
index
=
rows
.
indexOf
(
row
)
;
switch
(
event
.
key
)
{
case
"
ArrowRight
"
:
const
{
hasChildren
open
}
=
row
.
props
.
member
;
if
(
hasChildren
&
&
!
open
)
{
this
.
toggle
(
this
.
state
.
selected
)
;
}
break
;
case
"
ArrowLeft
"
:
if
(
row
&
&
row
.
props
.
member
.
open
)
{
this
.
toggle
(
this
.
state
.
selected
)
;
}
else
{
const
parentRow
=
rows
.
slice
(
0
index
)
.
reverse
(
)
.
find
(
r
=
>
r
.
props
.
member
.
level
<
row
.
props
.
member
.
level
)
;
if
(
parentRow
)
{
this
.
selectRow
(
parentRow
{
alignTo
:
"
top
"
}
)
;
}
}
break
;
case
"
ArrowDown
"
:
const
nextRow
=
rows
[
index
+
1
]
;
if
(
nextRow
)
{
this
.
selectRow
(
nextRow
{
alignTo
:
"
bottom
"
}
)
;
}
break
;
case
"
ArrowUp
"
:
const
previousRow
=
rows
[
index
-
1
]
;
if
(
previousRow
)
{
this
.
selectRow
(
previousRow
{
alignTo
:
"
top
"
}
)
;
}
break
;
case
"
Home
"
:
const
firstRow
=
rows
[
0
]
;
if
(
firstRow
)
{
this
.
selectRow
(
firstRow
{
alignTo
:
"
top
"
}
)
;
}
break
;
case
"
End
"
:
const
lastRow
=
rows
[
rows
.
length
-
1
]
;
if
(
lastRow
)
{
this
.
selectRow
(
lastRow
{
alignTo
:
"
bottom
"
}
)
;
}
break
;
case
"
Enter
"
:
case
"
"
:
if
(
this
.
treeRef
.
current
=
=
=
document
.
activeElement
)
{
event
.
stopPropagation
(
)
;
event
.
preventDefault
(
)
;
if
(
this
.
state
.
active
!
=
=
this
.
state
.
selected
)
{
this
.
activateRow
(
this
.
state
.
selected
)
;
}
return
;
}
break
;
case
"
Escape
"
:
event
.
stopPropagation
(
)
;
if
(
this
.
state
.
active
!
=
null
)
{
this
.
activateRow
(
null
)
;
}
break
;
}
this
.
treeRef
.
current
.
focus
(
)
;
event
.
preventDefault
(
)
;
}
onClickRow
(
nodePath
event
)
{
const
onClickRow
=
this
.
props
.
onClickRow
;
if
(
onClickRow
)
{
onClickRow
.
call
(
this
nodePath
event
)
;
return
;
}
event
.
stopPropagation
(
)
;
const
cell
=
event
.
target
.
closest
(
"
td
"
)
;
if
(
cell
&
&
cell
.
classList
.
contains
(
"
treeLabelCell
"
)
)
{
this
.
toggle
(
nodePath
)
;
}
this
.
selectRow
(
this
.
visibleRows
.
find
(
row
=
>
row
.
props
.
member
.
path
=
=
=
nodePath
)
{
preventAutoScroll
:
true
}
)
;
}
onContextMenu
(
member
event
)
{
const
onContextMenuRow
=
this
.
props
.
onContextMenuRow
;
if
(
onContextMenuRow
)
{
onContextMenuRow
.
call
(
this
member
event
)
;
}
}
getSelectedRow
(
)
{
const
rows
=
this
.
visibleRows
;
if
(
!
this
.
state
.
selected
|
|
rows
.
length
=
=
=
0
)
{
return
null
;
}
return
rows
.
find
(
row
=
>
this
.
isSelected
(
row
.
props
.
member
.
path
)
)
;
}
getSelectedRowIndex
(
)
{
const
row
=
this
.
getSelectedRow
(
)
;
if
(
!
row
)
{
return
0
;
}
return
this
.
visibleRows
.
indexOf
(
row
)
;
}
_scrollIntoView
(
row
options
=
{
}
)
{
const
treeEl
=
this
.
treeRef
.
current
;
if
(
!
treeEl
|
|
!
row
)
{
return
;
}
const
{
props
:
{
member
:
{
path
}
=
{
}
}
=
{
}
}
=
row
;
if
(
!
path
)
{
return
;
}
const
element
=
treeEl
.
ownerDocument
.
getElementById
(
path
)
;
if
(
!
element
)
{
return
;
}
scrollIntoView
(
element
{
.
.
.
options
}
)
;
}
selectRow
(
row
options
=
{
}
)
{
const
{
props
:
{
member
:
{
path
}
=
{
}
}
=
{
}
}
=
row
;
if
(
this
.
isSelected
(
path
)
)
{
return
;
}
if
(
this
.
state
.
active
!
=
null
)
{
const
treeEl
=
this
.
treeRef
.
current
;
if
(
treeEl
&
&
treeEl
!
=
=
treeEl
.
ownerDocument
.
activeElement
)
{
treeEl
.
focus
(
)
;
}
}
if
(
!
options
.
preventAutoScroll
)
{
this
.
_scrollIntoView
(
row
options
)
;
}
this
.
setState
(
{
.
.
.
this
.
state
selected
:
path
active
:
null
}
)
;
}
activateRow
(
active
)
{
this
.
setState
(
{
.
.
.
this
.
state
active
}
)
;
}
isSelected
(
nodePath
)
{
return
nodePath
=
=
=
this
.
state
.
selected
;
}
isActive
(
nodePath
)
{
return
nodePath
=
=
=
this
.
state
.
active
;
}
onFilter
(
object
)
{
const
onFilter
=
this
.
props
.
onFilter
;
return
onFilter
?
onFilter
(
object
)
:
true
;
}
onSort
(
parent
children
)
{
const
onSort
=
this
.
props
.
onSort
;
return
onSort
?
onSort
(
parent
children
)
:
children
;
}
getMembers
(
parent
level
path
)
{
if
(
typeof
parent
=
=
"
string
"
)
{
return
[
]
;
}
const
{
expandableStrings
provider
}
=
this
.
props
;
let
children
=
provider
.
getChildren
(
parent
)
|
|
[
]
;
if
(
!
Array
.
isArray
(
children
)
)
{
return
children
;
}
children
=
this
.
onSort
(
parent
children
)
|
|
children
;
return
children
.
map
(
child
=
>
{
const
key
=
provider
.
getKey
(
child
)
;
const
nodePath
=
TreeView
.
subPath
(
path
key
)
;
const
type
=
provider
.
getType
(
child
)
;
let
hasChildren
=
provider
.
hasChildren
(
child
)
;
const
value
=
provider
.
getValue
(
child
)
;
if
(
expandableStrings
&
&
isLongString
(
value
)
)
{
hasChildren
=
true
;
}
return
{
object
:
child
name
:
provider
.
getLabel
(
child
)
type
:
type
rowClass
:
"
treeRow
-
"
+
type
level
:
provider
.
getLevel
?
provider
.
getLevel
(
child
level
)
:
level
hasChildren
:
hasChildren
value
:
value
open
:
this
.
isExpanded
(
nodePath
)
path
:
nodePath
hidden
:
!
this
.
onFilter
(
child
)
selected
:
this
.
isSelected
(
nodePath
)
active
:
this
.
isActive
(
nodePath
)
}
;
}
)
;
}
renderRows
(
parent
level
=
0
path
=
"
"
)
{
let
rows
=
[
]
;
const
decorator
=
this
.
props
.
decorator
;
let
renderRow
=
this
.
props
.
renderRow
|
|
TreeRow
;
const
members
=
this
.
getMembers
(
parent
level
path
)
;
if
(
!
Array
.
isArray
(
members
)
)
{
return
members
;
}
members
.
forEach
(
member
=
>
{
if
(
decorator
&
&
decorator
.
renderRow
)
{
renderRow
=
decorator
.
renderRow
(
member
.
object
)
|
|
renderRow
;
}
const
props
=
Object
.
assign
(
{
}
this
.
props
{
key
:
{
member
.
path
}
-
{
member
.
active
?
"
active
"
:
"
inactive
"
}
member
:
member
columns
:
this
.
state
.
columns
id
:
member
.
path
ref
:
row
=
>
row
&
&
this
.
rows
.
push
(
row
)
onClick
:
this
.
onClickRow
.
bind
(
this
member
.
path
)
onContextMenu
:
this
.
onContextMenu
.
bind
(
this
member
)
}
)
;
rows
.
push
(
renderRow
(
props
)
)
;
if
(
member
.
hasChildren
&
&
member
.
open
)
{
const
childRows
=
this
.
renderRows
(
member
.
object
level
+
1
member
.
path
)
;
if
(
!
Array
.
isArray
(
childRows
)
)
{
const
lastIndex
=
rows
.
length
-
1
;
props
.
member
.
loading
=
true
;
rows
[
lastIndex
]
=
cloneElement
(
rows
[
lastIndex
]
props
)
;
}
else
{
rows
=
rows
.
concat
(
childRows
)
;
}
}
}
)
;
return
rows
;
}
render
(
)
{
const
root
=
this
.
props
.
object
;
const
classNames
=
[
"
treeTable
"
]
;
this
.
rows
=
[
]
;
const
{
className
onContextMenuTree
}
=
this
.
props
;
if
(
className
)
{
classNames
.
push
(
.
.
.
className
.
split
(
"
"
)
)
;
}
let
rows
=
this
.
renderRows
(
root
0
"
"
)
;
if
(
!
Array
.
isArray
(
rows
)
)
{
rows
=
[
]
;
}
const
props
=
Object
.
assign
(
{
}
this
.
props
{
columns
:
this
.
state
.
columns
}
)
;
return
dom
.
table
(
{
className
:
classNames
.
join
(
"
"
)
role
:
"
tree
"
ref
:
this
.
treeRef
tabIndex
:
0
onKeyDown
:
this
.
onKeyDown
onContextMenu
:
onContextMenuTree
&
&
onContextMenuTree
.
bind
(
this
)
onClick
:
(
)
=
>
{
this
.
treeRef
.
current
.
focus
(
)
;
}
onBlur
:
event
=
>
{
if
(
this
.
state
.
active
!
=
null
)
{
const
{
relatedTarget
}
=
event
;
if
(
!
this
.
treeRef
.
current
.
contains
(
relatedTarget
)
)
{
this
.
activateRow
(
null
)
;
}
}
}
"
aria
-
label
"
:
this
.
props
.
label
|
|
"
"
"
aria
-
activedescendant
"
:
this
.
state
.
selected
cellPadding
:
0
cellSpacing
:
0
}
TreeHeader
(
props
)
dom
.
tbody
(
{
role
:
"
presentation
"
tabIndex
:
-
1
}
rows
)
)
;
}
}
function
ensureDefaultColumn
(
columns
)
{
if
(
!
columns
)
{
columns
=
[
]
;
}
const
defaultColumn
=
columns
.
filter
(
col
=
>
col
.
id
=
=
"
default
"
)
;
if
(
defaultColumn
.
length
)
{
return
columns
;
}
return
[
{
id
:
"
default
"
}
.
.
.
columns
]
;
}
function
isLongString
(
value
)
{
return
typeof
value
=
=
"
string
"
&
&
value
.
length
>
50
;
}
module
.
exports
=
TreeView
;
}
)
;
