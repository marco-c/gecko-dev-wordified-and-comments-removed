"
use
strict
"
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
Immutable
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
immutable
"
)
;
const
{
PropTypes
createClass
DOM
}
=
React
;
const
{
div
span
button
}
=
DOM
;
const
PriorityLevels
=
{
PRIORITY_INFO_LOW
:
1
PRIORITY_INFO_MEDIUM
:
2
PRIORITY_INFO_HIGH
:
3
PRIORITY_WARNING_LOW
:
4
PRIORITY_WARNING_MEDIUM
:
5
PRIORITY_WARNING_HIGH
:
6
PRIORITY_CRITICAL_LOW
:
7
PRIORITY_CRITICAL_MEDIUM
:
8
PRIORITY_CRITICAL_HIGH
:
9
PRIORITY_CRITICAL_BLOCK
:
10
}
;
var
NotificationBox
=
createClass
(
{
displayName
:
"
NotificationBox
"
propTypes
:
{
notifications
:
PropTypes
.
arrayOf
(
PropTypes
.
shape
(
{
label
:
PropTypes
.
string
.
isRequired
value
:
PropTypes
.
string
.
isRequired
image
:
PropTypes
.
string
.
isRequired
priority
:
PropTypes
.
number
.
isRequired
buttons
:
PropTypes
.
arrayOf
(
PropTypes
.
shape
(
{
callback
:
PropTypes
.
func
.
isRequired
label
:
PropTypes
.
string
.
isRequired
accesskey
:
PropTypes
.
string
}
)
)
eventCallback
:
PropTypes
.
func
}
)
)
}
getInitialState
(
)
{
return
{
notifications
:
new
Immutable
.
OrderedMap
(
)
}
;
}
appendNotification
(
label
value
image
priority
buttons
=
[
]
eventCallback
)
{
if
(
priority
<
PriorityLevels
.
PRIORITY_INFO_LOW
|
|
priority
>
PriorityLevels
.
PRIORITY_CRITICAL_BLOCK
)
{
throw
new
Error
(
"
Invalid
notification
priority
"
+
priority
)
;
}
if
(
image
)
{
throw
new
Error
(
"
Custom
image
URL
is
not
supported
yet
"
)
;
}
let
type
=
"
warning
"
;
if
(
priority
>
=
PriorityLevels
.
PRIORITY_CRITICAL_LOW
)
{
type
=
"
critical
"
;
}
else
if
(
priority
<
=
PriorityLevels
.
PRIORITY_INFO_HIGH
)
{
type
=
"
info
"
;
}
let
notifications
=
this
.
state
.
notifications
.
set
(
value
{
label
:
label
value
:
value
image
:
image
priority
:
priority
type
:
type
buttons
:
buttons
eventCallback
:
eventCallback
}
)
;
notifications
=
notifications
.
sortBy
(
(
val
key
)
=
>
{
return
-
val
.
priority
;
}
)
;
this
.
setState
(
{
notifications
:
notifications
}
)
;
}
removeNotification
(
notification
)
{
this
.
close
(
this
.
state
.
notifications
.
get
(
notification
.
value
)
)
;
}
getNotificationWithValue
(
value
)
{
let
notification
=
this
.
state
.
notifications
.
get
(
value
)
;
if
(
!
notification
)
{
return
null
;
}
return
Object
.
assign
(
{
}
notification
{
close
:
(
)
=
>
{
this
.
close
(
notification
)
;
}
}
)
;
}
getCurrentNotification
(
)
{
return
this
.
state
.
notifications
.
first
(
)
;
}
close
(
notification
)
{
if
(
!
notification
)
{
return
;
}
if
(
notification
.
eventCallback
)
{
notification
.
eventCallback
(
"
removed
"
)
;
}
this
.
setState
(
{
notifications
:
this
.
state
.
notifications
.
remove
(
notification
.
value
)
}
)
;
}
renderButton
(
props
notification
)
{
let
onClick
=
event
=
>
{
if
(
props
.
callback
)
{
let
result
=
props
.
callback
(
this
props
event
.
target
)
;
if
(
!
result
)
{
this
.
close
(
notification
)
;
}
event
.
stopPropagation
(
)
;
}
}
;
return
(
button
(
{
key
:
props
.
label
className
:
"
notification
-
button
"
accesskey
:
props
.
accesskey
onClick
:
onClick
}
props
.
label
)
)
;
}
renderNotification
(
notification
)
{
return
(
div
(
{
key
:
notification
.
value
className
:
"
notification
"
"
data
-
type
"
:
notification
.
type
}
div
(
{
className
:
"
notificationInner
"
}
div
(
{
className
:
"
details
"
}
div
(
{
className
:
"
messageImage
"
"
data
-
type
"
:
notification
.
type
}
)
span
(
{
className
:
"
messageText
"
}
notification
.
label
)
notification
.
buttons
.
map
(
props
=
>
this
.
renderButton
(
props
notification
)
)
)
div
(
{
className
:
"
messageCloseButton
"
onClick
:
this
.
close
.
bind
(
this
notification
)
}
)
)
)
)
;
}
render
(
)
{
let
notification
=
this
.
state
.
notifications
.
first
(
)
;
let
content
=
notification
?
this
.
renderNotification
(
notification
)
:
null
;
return
div
(
{
className
:
"
notificationbox
"
}
content
)
;
}
}
)
;
module
.
exports
.
NotificationBox
=
NotificationBox
;
module
.
exports
.
PriorityLevels
=
PriorityLevels
;
