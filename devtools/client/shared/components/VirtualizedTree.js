"
use
strict
"
;
const
{
Component
createFactory
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
dom
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
scrollIntoView
}
=
require
(
"
devtools
/
client
/
shared
/
scroll
"
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
NUMBER_OF_OFFSCREEN_ITEMS
=
1
;
class
Tree
extends
Component
{
static
get
propTypes
(
)
{
return
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
isExpanded
:
PropTypes
.
func
.
isRequired
itemHeight
:
PropTypes
.
number
.
isRequired
focused
:
PropTypes
.
any
onFocus
:
PropTypes
.
func
onActivate
:
PropTypes
.
func
preventNavigationOnArrowRight
:
PropTypes
.
bool
autoExpandDepth
:
PropTypes
.
number
labelledby
:
PropTypes
.
string
label
:
PropTypes
.
string
onExpand
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
}
;
}
static
get
defaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
preventNavigationOnArrowRight
:
true
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
scroll
:
0
height
:
window
.
innerHeight
seen
:
new
Set
(
)
mouseDown
:
false
}
;
this
.
_onExpand
=
oncePerAnimationFrame
(
this
.
_onExpand
)
.
bind
(
this
)
;
this
.
_onCollapse
=
oncePerAnimationFrame
(
this
.
_onCollapse
)
.
bind
(
this
)
;
this
.
_onScroll
=
oncePerAnimationFrame
(
this
.
_onScroll
)
.
bind
(
this
)
;
this
.
_focusPrevNode
=
oncePerAnimationFrame
(
this
.
_focusPrevNode
)
.
bind
(
this
)
;
this
.
_focusNextNode
=
oncePerAnimationFrame
(
this
.
_focusNextNode
)
.
bind
(
this
)
;
this
.
_focusParentNode
=
oncePerAnimationFrame
(
this
.
_focusParentNode
)
.
bind
(
this
)
;
this
.
_focusFirstNode
=
oncePerAnimationFrame
(
this
.
_focusFirstNode
)
.
bind
(
this
)
;
this
.
_focusLastNode
=
oncePerAnimationFrame
(
this
.
_focusLastNode
)
.
bind
(
this
)
;
this
.
_activateNode
=
oncePerAnimationFrame
(
this
.
_activateNode
)
.
bind
(
this
)
;
this
.
_autoExpand
=
this
.
_autoExpand
.
bind
(
this
)
;
this
.
_preventArrowKeyScrolling
=
this
.
_preventArrowKeyScrolling
.
bind
(
this
)
;
this
.
_updateHeight
=
this
.
_updateHeight
.
bind
(
this
)
;
this
.
_onResize
=
this
.
_onResize
.
bind
(
this
)
;
this
.
_dfs
=
this
.
_dfs
.
bind
(
this
)
;
this
.
_dfsFromRoots
=
this
.
_dfsFromRoots
.
bind
(
this
)
;
this
.
_focus
=
this
.
_focus
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
}
componentDidMount
(
)
{
window
.
addEventListener
(
"
resize
"
this
.
_onResize
)
;
this
.
_autoExpand
(
)
;
this
.
_updateHeight
(
)
;
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
)
;
this
.
_updateHeight
(
)
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
const
{
scroll
height
seen
mouseDown
}
=
this
.
state
;
return
scroll
!
=
=
nextState
.
scroll
|
|
height
!
=
=
nextState
.
height
|
|
seen
!
=
=
nextState
.
seen
|
|
mouseDown
=
=
=
nextState
.
mouseDown
;
}
componentWillUnmount
(
)
{
window
.
removeEventListener
(
"
resize
"
this
.
_onResize
)
;
}
_autoExpand
(
)
{
if
(
!
this
.
props
.
autoExpandDepth
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
if
(
currentDepth
>
=
this
.
props
.
autoExpandDepth
|
|
this
.
state
.
seen
.
has
(
item
)
)
{
return
;
}
this
.
props
.
onExpand
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
}
_updateHeight
(
)
{
this
.
setState
(
{
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
_onCollapse
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
_focus
(
index
item
options
=
{
}
)
{
if
(
item
!
=
=
undefined
&
&
!
options
.
preventAutoScroll
)
{
const
treeElement
=
this
.
refs
.
tree
;
const
element
=
document
.
getElementById
(
this
.
props
.
getKey
(
item
)
)
;
scrollIntoView
(
element
{
.
.
.
options
container
:
treeElement
}
)
;
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_onResize
(
)
{
if
(
this
.
state
.
scroll
!
=
=
this
.
refs
.
tree
.
scrollTop
)
{
this
.
refs
.
tree
.
scrollTo
(
{
left
:
0
top
:
this
.
state
.
scroll
}
)
;
}
this
.
_updateHeight
(
)
;
}
_onBlur
(
)
{
this
.
_focus
(
0
undefined
)
;
}
_onScroll
(
e
)
{
this
.
setState
(
{
scroll
:
Math
.
max
(
this
.
refs
.
tree
.
scrollTop
0
)
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
break
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
break
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
props
.
getChildren
(
this
.
props
.
focused
)
.
length
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
break
;
case
"
ArrowRight
"
:
if
(
this
.
props
.
getChildren
(
this
.
props
.
focused
)
.
length
&
&
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
if
(
!
this
.
props
.
preventNavigationOnArrowRight
)
{
this
.
_focusNextNode
(
)
;
}
break
;
case
"
Home
"
:
this
.
_focusFirstNode
(
)
;
break
;
case
"
End
"
:
this
.
_focusLastNode
(
)
;
break
;
case
"
Enter
"
:
case
"
"
:
this
.
_activateNode
(
)
;
break
;
}
}
_activateNode
(
)
{
if
(
this
.
props
.
onActivate
)
{
this
.
props
.
onActivate
(
this
.
props
.
focused
)
;
}
}
_focusFirstNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
this
.
_focus
(
0
traversal
[
0
]
.
item
{
alignTo
:
"
top
"
}
)
;
}
_focusLastNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
lastIndex
=
traversal
.
length
-
1
;
this
.
_focus
(
lastIndex
traversal
[
lastIndex
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
_focusPrevNode
(
)
{
let
prev
;
let
prevIndex
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
prevIndex
=
i
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prevIndex
prev
{
alignTo
:
"
top
"
}
)
;
}
_focusNextNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
i
+
1
traversal
[
i
+
1
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
}
_focusParentNode
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
return
;
}
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
parentIndex
=
0
;
for
(
;
parentIndex
<
length
;
parentIndex
+
+
)
{
if
(
traversal
[
parentIndex
]
.
item
=
=
=
parent
)
{
break
;
}
}
this
.
_focus
(
parentIndex
parent
{
alignTo
:
"
top
"
}
)
;
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
{
itemHeight
focused
}
=
this
.
props
;
const
{
scroll
height
}
=
this
.
state
;
const
begin
=
Math
.
max
(
(
(
scroll
/
itemHeight
)
|
0
)
-
NUMBER_OF_OFFSCREEN_ITEMS
0
)
;
const
end
=
Math
.
ceil
(
(
scroll
+
height
)
/
itemHeight
)
+
NUMBER_OF_OFFSCREEN_ITEMS
;
const
toRender
=
traversal
.
slice
(
begin
end
)
;
const
topSpacerHeight
=
begin
*
itemHeight
;
const
bottomSpacerHeight
=
Math
.
max
(
traversal
.
length
-
end
0
)
*
itemHeight
;
const
nodes
=
[
dom
.
div
(
{
key
:
"
top
-
spacer
"
role
:
"
presentation
"
style
:
{
padding
:
0
margin
:
0
height
:
topSpacerHeight
+
"
px
"
}
}
)
]
;
for
(
let
i
=
0
;
i
<
toRender
.
length
;
i
+
+
)
{
const
index
=
begin
+
i
;
const
first
=
index
=
=
0
;
const
last
=
index
=
=
traversal
.
length
-
1
;
const
{
item
depth
}
=
toRender
[
i
]
;
const
key
=
this
.
props
.
getKey
(
item
)
;
nodes
.
push
(
TreeNode
(
{
key
index
first
last
item
depth
id
:
key
renderItem
:
this
.
props
.
renderItem
focused
:
focused
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
hasChildren
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onClick
:
(
)
=
>
this
.
_focus
(
begin
+
i
item
{
preventAutoScroll
:
true
}
)
}
)
)
;
}
nodes
.
push
(
dom
.
div
(
{
key
:
"
bottom
-
spacer
"
role
:
"
presentation
"
style
:
{
padding
:
0
margin
:
0
height
:
bottomSpacerHeight
+
"
px
"
}
}
)
)
;
return
dom
.
div
(
{
className
:
"
tree
"
ref
:
"
tree
"
role
:
"
tree
"
tabIndex
:
"
0
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
onScroll
:
this
.
_onScroll
onMouseDown
:
(
)
=
>
this
.
setState
(
{
mouseDown
:
true
}
)
onMouseUp
:
(
)
=
>
this
.
setState
(
{
mouseDown
:
false
}
)
onFocus
:
(
)
=
>
{
if
(
focused
|
|
this
.
state
.
mouseDown
)
{
return
;
}
this
.
_focus
(
begin
toRender
[
0
]
.
item
)
;
}
onClick
:
(
)
=
>
{
this
.
refs
.
tree
.
focus
(
)
;
}
"
aria
-
label
"
:
this
.
props
.
label
"
aria
-
labelledby
"
:
this
.
props
.
labelledby
"
aria
-
activedescendant
"
:
focused
&
&
this
.
props
.
getKey
(
focused
)
style
:
{
padding
:
0
margin
:
0
}
}
nodes
)
;
}
}
class
ArrowExpanderClass
extends
Component
{
static
get
propTypes
(
)
{
return
{
item
:
PropTypes
.
any
.
isRequired
visible
:
PropTypes
.
bool
.
isRequired
expanded
:
PropTypes
.
bool
.
isRequired
onCollapse
:
PropTypes
.
func
.
isRequired
onExpand
:
PropTypes
.
func
.
isRequired
}
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
visible
!
=
=
nextProps
.
visible
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
attrs
=
{
className
:
"
arrow
theme
-
twisty
"
onClick
:
this
.
props
.
expanded
?
(
)
=
>
this
.
props
.
onCollapse
(
this
.
props
.
item
)
:
e
=
>
this
.
props
.
onExpand
(
this
.
props
.
item
e
.
altKey
)
}
;
if
(
this
.
props
.
expanded
)
{
attrs
.
className
+
=
"
open
"
;
}
if
(
!
this
.
props
.
visible
)
{
attrs
.
style
=
{
visibility
:
"
hidden
"
}
;
}
return
dom
.
div
(
attrs
)
;
}
}
class
TreeNodeClass
extends
Component
{
static
get
propTypes
(
)
{
return
{
id
:
PropTypes
.
any
.
isRequired
focused
:
PropTypes
.
bool
.
isRequired
item
:
PropTypes
.
any
.
isRequired
expanded
:
PropTypes
.
bool
.
isRequired
hasChildren
:
PropTypes
.
bool
.
isRequired
onExpand
:
PropTypes
.
func
.
isRequired
index
:
PropTypes
.
number
.
isRequired
first
:
PropTypes
.
bool
last
:
PropTypes
.
bool
onClick
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
.
isRequired
depth
:
PropTypes
.
number
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
}
;
}
render
(
)
{
const
arrow
=
ArrowExpander
(
{
item
:
this
.
props
.
item
expanded
:
this
.
props
.
expanded
visible
:
this
.
props
.
hasChildren
onExpand
:
this
.
props
.
onExpand
onCollapse
:
this
.
props
.
onCollapse
}
)
;
const
classList
=
[
"
tree
-
node
"
"
div
"
]
;
if
(
this
.
props
.
index
%
2
)
{
classList
.
push
(
"
tree
-
node
-
odd
"
)
;
}
if
(
this
.
props
.
first
)
{
classList
.
push
(
"
tree
-
node
-
first
"
)
;
}
if
(
this
.
props
.
last
)
{
classList
.
push
(
"
tree
-
node
-
last
"
)
;
}
let
ariaExpanded
;
if
(
this
.
props
.
hasChildren
)
{
ariaExpanded
=
false
;
}
if
(
this
.
props
.
expanded
)
{
ariaExpanded
=
true
;
}
return
dom
.
div
(
{
id
:
this
.
props
.
id
className
:
classList
.
join
(
"
"
)
role
:
"
treeitem
"
"
aria
-
level
"
:
this
.
props
.
depth
+
1
onClick
:
this
.
props
.
onClick
"
aria
-
expanded
"
:
ariaExpanded
"
data
-
expanded
"
:
this
.
props
.
expanded
?
"
"
:
undefined
"
data
-
depth
"
:
this
.
props
.
depth
style
:
{
padding
:
0
margin
:
0
}
}
this
.
props
.
renderItem
(
this
.
props
.
item
this
.
props
.
depth
this
.
props
.
focused
arrow
this
.
props
.
expanded
)
)
;
}
}
const
ArrowExpander
=
createFactory
(
ArrowExpanderClass
)
;
const
TreeNode
=
createFactory
(
TreeNodeClass
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
module
.
exports
=
Tree
;
