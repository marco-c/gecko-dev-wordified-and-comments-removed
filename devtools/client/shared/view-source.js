"
use
strict
"
;
var
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
var
Services
=
require
(
"
Services
"
)
;
var
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
var
{
getSourceText
}
=
require
(
"
devtools
/
client
/
debugger
/
content
/
queries
"
)
;
exports
.
viewSourceInStyleEditor
=
Task
.
async
(
function
*
(
toolbox
sourceURL
sourceLine
)
{
let
panel
=
yield
toolbox
.
loadTool
(
"
styleeditor
"
)
;
try
{
yield
panel
.
selectStyleSheet
(
sourceURL
sourceLine
)
;
yield
toolbox
.
selectTool
(
"
styleeditor
"
)
;
return
true
;
}
catch
(
e
)
{
exports
.
viewSource
(
toolbox
sourceURL
sourceLine
)
;
return
false
;
}
}
)
;
exports
.
viewSourceInDebugger
=
Task
.
async
(
function
*
(
toolbox
sourceURL
sourceLine
)
{
let
debuggerAlreadyOpen
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
let
dbg
=
yield
toolbox
.
loadTool
(
"
jsdebugger
"
)
;
if
(
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
new
-
debugger
-
frontend
"
)
)
{
const
source
=
dbg
.
getSource
(
sourceURL
)
;
if
(
source
)
{
yield
toolbox
.
selectTool
(
"
jsdebugger
"
)
;
dbg
.
selectSource
(
sourceURL
sourceLine
)
;
return
true
;
}
exports
.
viewSource
(
toolbox
sourceURL
sourceLine
)
;
return
false
;
}
const
win
=
dbg
.
panelWin
;
if
(
!
debuggerAlreadyOpen
)
{
yield
win
.
DebuggerController
.
waitForSourcesLoaded
(
)
;
}
let
{
DebuggerView
}
=
win
;
let
{
Sources
}
=
DebuggerView
;
let
item
=
Sources
.
getItemForAttachment
(
a
=
>
a
.
source
.
url
=
=
=
sourceURL
)
;
if
(
item
)
{
yield
toolbox
.
selectTool
(
"
jsdebugger
"
)
;
const
{
actor
}
=
item
.
attachment
.
source
;
const
state
=
win
.
DebuggerController
.
getState
(
)
;
const
selected
=
state
.
sources
.
selectedSource
;
const
isSelected
=
selected
=
=
=
actor
;
let
isLoading
=
false
;
if
(
isSelected
)
{
const
sourceTextInfo
=
getSourceText
(
state
selected
)
;
isLoading
=
sourceTextInfo
&
&
sourceTextInfo
.
loading
;
}
DebuggerView
.
setEditorLocation
(
actor
sourceLine
{
noDebug
:
true
}
)
;
if
(
!
isSelected
|
|
isLoading
)
{
yield
win
.
DebuggerController
.
waitForSourceShown
(
sourceURL
)
;
}
return
true
;
}
exports
.
viewSource
(
toolbox
sourceURL
sourceLine
)
;
return
false
;
}
)
;
exports
.
viewSourceInScratchpad
=
Task
.
async
(
function
*
(
sourceURL
sourceLine
)
{
let
wins
=
Services
.
wm
.
getEnumerator
(
"
devtools
:
scratchpad
"
)
;
while
(
wins
.
hasMoreElements
(
)
)
{
let
win
=
wins
.
getNext
(
)
;
if
(
!
win
.
closed
&
&
win
.
Scratchpad
.
uniqueName
=
=
=
sourceURL
)
{
win
.
focus
(
)
;
win
.
Scratchpad
.
editor
.
setCursor
(
{
line
:
sourceLine
ch
:
0
}
)
;
return
;
}
}
for
(
let
[
toolbox
]
of
gDevTools
)
{
let
scratchpadPanel
=
toolbox
.
getPanel
(
"
scratchpad
"
)
;
if
(
scratchpadPanel
)
{
let
{
scratchpad
}
=
scratchpadPanel
;
if
(
scratchpad
.
uniqueName
=
=
=
sourceURL
)
{
toolbox
.
selectTool
(
"
scratchpad
"
)
;
toolbox
.
raise
(
)
;
scratchpad
.
editor
.
focus
(
)
;
scratchpad
.
editor
.
setCursor
(
{
line
:
sourceLine
ch
:
0
}
)
;
return
;
}
}
}
}
)
;
exports
.
viewSource
=
Task
.
async
(
function
*
(
toolbox
sourceURL
sourceLine
)
{
let
browserWin
=
Services
.
wm
.
getMostRecentWindow
(
gDevTools
.
chromeWindowType
)
;
if
(
browserWin
&
&
browserWin
.
BrowserViewSourceOfDocument
)
{
return
browserWin
.
BrowserViewSourceOfDocument
(
{
URL
:
sourceURL
lineNumber
:
sourceLine
}
)
;
}
let
utils
=
toolbox
.
gViewSourceUtils
;
utils
.
viewSource
(
sourceURL
null
toolbox
.
doc
sourceLine
|
|
0
)
;
return
null
;
}
)
;
