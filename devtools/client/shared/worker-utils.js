"
use
strict
"
;
class
WorkerDispatcher
{
#
msgId
=
1
;
#
worker
=
null
;
#
pendingCalls
=
new
Map
(
)
;
start
(
url
)
{
if
(
typeof
ChromeWorker
=
=
"
function
"
)
{
this
.
#
worker
=
new
ChromeWorker
(
url
)
;
}
else
{
this
.
#
worker
=
new
Worker
(
url
)
;
}
this
.
#
worker
.
onerror
=
err
=
>
{
console
.
error
(
Error
in
worker
{
url
}
err
.
message
)
;
}
;
this
.
#
worker
.
addEventListener
(
"
message
"
this
.
#
onMessage
)
;
}
stop
(
)
{
if
(
!
this
.
#
worker
)
{
return
;
}
this
.
#
worker
.
removeEventListener
(
"
message
"
this
.
#
onMessage
)
;
this
.
#
worker
.
terminate
(
)
;
this
.
#
worker
=
null
;
this
.
#
pendingCalls
.
clear
(
)
;
}
task
(
method
{
queue
=
false
}
=
{
}
)
{
const
calls
=
[
]
;
const
push
=
args
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
queue
&
&
calls
.
length
=
=
=
0
)
{
Promise
.
resolve
(
)
.
then
(
flush
)
;
}
calls
.
push
(
{
args
resolve
reject
}
)
;
if
(
!
queue
)
{
flush
(
)
;
}
}
)
;
}
;
const
flush
=
(
)
=
>
{
const
items
=
calls
.
slice
(
)
;
calls
.
length
=
0
;
if
(
!
this
.
#
worker
)
{
return
;
}
const
id
=
this
.
#
msgId
+
+
;
this
.
#
worker
.
postMessage
(
{
id
method
calls
:
items
.
map
(
item
=
>
item
.
args
)
}
)
;
this
.
#
pendingCalls
.
set
(
id
items
)
;
}
;
return
(
.
.
.
args
)
=
>
push
(
args
)
;
}
invoke
(
method
.
.
.
args
)
{
return
this
.
task
(
method
)
(
.
.
.
args
)
;
}
#
onMessage
=
(
{
data
:
result
}
)
=
>
{
const
items
=
this
.
#
pendingCalls
.
get
(
result
.
id
)
;
this
.
#
pendingCalls
.
delete
(
result
.
id
)
;
if
(
!
items
)
{
return
;
}
if
(
!
this
.
#
worker
)
{
return
;
}
result
.
results
.
forEach
(
(
resultData
i
)
=
>
{
const
{
resolve
reject
}
=
items
[
i
]
;
if
(
resultData
.
error
)
{
const
err
=
new
Error
(
resultData
.
message
)
;
err
.
metadata
=
resultData
.
metadata
;
reject
(
err
)
;
}
else
{
resolve
(
resultData
.
response
)
;
}
}
)
;
}
;
}
function
workerHandler
(
publicInterface
)
{
return
function
(
msg
)
{
const
{
id
method
calls
}
=
msg
.
data
;
Promise
.
all
(
calls
.
map
(
args
=
>
{
try
{
const
response
=
publicInterface
[
method
]
.
apply
(
undefined
args
)
;
if
(
response
instanceof
Promise
)
{
return
response
.
then
(
val
=
>
(
{
response
:
val
}
)
err
=
>
asErrorMessage
(
err
)
)
;
}
return
{
response
}
;
}
catch
(
error
)
{
return
asErrorMessage
(
error
)
;
}
}
)
)
.
then
(
results
=
>
{
globalThis
.
postMessage
(
{
id
results
}
)
;
}
)
;
}
;
}
function
asErrorMessage
(
error
)
{
if
(
typeof
error
=
=
=
"
object
"
&
&
error
&
&
"
message
"
in
error
)
{
return
{
error
:
true
message
:
error
.
message
metadata
:
error
.
metadata
}
;
}
return
{
error
:
true
message
:
error
=
=
null
?
error
:
error
.
toString
(
)
metadata
:
undefined
}
;
}
if
(
typeof
module
!
=
=
"
undefined
"
)
{
module
.
exports
=
{
WorkerDispatcher
workerHandler
}
;
}
