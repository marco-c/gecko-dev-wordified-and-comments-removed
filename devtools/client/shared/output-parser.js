"
use
strict
"
;
const
Services
=
require
(
"
Services
"
)
;
const
{
angleUtils
}
=
require
(
"
devtools
/
client
/
shared
/
css
-
angle
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
appendText
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
loader
.
lazyRequireGetter
(
this
"
CSS_TYPES
"
"
devtools
/
shared
/
css
/
constants
"
true
)
;
const
STYLE_INSPECTOR_PROPERTIES
=
"
devtools
/
shared
/
locales
/
styleinspector
.
properties
"
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
STYLE_INSPECTOR_L10N
=
new
LocalizationHelper
(
STYLE_INSPECTOR_PROPERTIES
)
;
const
ANGLE_TAKING_FUNCTIONS
=
[
"
linear
-
gradient
"
"
-
moz
-
linear
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
rotate
"
"
rotateX
"
"
rotateY
"
"
rotateZ
"
"
rotate3d
"
"
skew
"
"
skewX
"
"
skewY
"
"
hue
-
rotate
"
]
;
const
BEZIER_KEYWORDS
=
[
"
linear
"
"
ease
-
in
-
out
"
"
ease
-
in
"
"
ease
-
out
"
"
ease
"
]
;
const
COLOR_TAKING_FUNCTIONS
=
[
"
linear
-
gradient
"
"
-
moz
-
linear
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
radial
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
drop
-
shadow
"
]
;
const
BASIC_SHAPE_FUNCTIONS
=
[
"
polygon
"
"
circle
"
"
ellipse
"
"
inset
"
]
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
function
OutputParser
(
document
{
supportsType
isValidOnClient
supportsCssColor4ColorFunction
}
)
{
this
.
parsed
=
[
]
;
this
.
doc
=
document
;
this
.
supportsType
=
supportsType
;
this
.
isValidOnClient
=
isValidOnClient
;
this
.
colorSwatches
=
new
WeakMap
(
)
;
this
.
angleSwatches
=
new
WeakMap
(
)
;
this
.
_onColorSwatchMouseDown
=
this
.
_onColorSwatchMouseDown
.
bind
(
this
)
;
this
.
_onAngleSwatchMouseDown
=
this
.
_onAngleSwatchMouseDown
.
bind
(
this
)
;
this
.
cssColor4
=
supportsCssColor4ColorFunction
(
)
;
}
OutputParser
.
prototype
=
{
parseCssProperty
:
function
(
name
value
options
=
{
}
)
{
options
=
this
.
_mergeOptions
(
options
)
;
options
.
expectCubicBezier
=
this
.
supportsType
(
name
CSS_TYPES
.
TIMING_FUNCTION
)
;
options
.
expectDisplay
=
name
=
=
=
"
display
"
;
options
.
expectFilter
=
name
=
=
=
"
filter
"
;
options
.
expectShape
=
name
=
=
=
"
clip
-
path
"
|
|
name
=
=
=
"
shape
-
outside
"
;
options
.
expectFont
=
name
=
=
=
"
font
-
family
"
;
options
.
supportsColor
=
this
.
supportsType
(
name
CSS_TYPES
.
COLOR
)
|
|
this
.
supportsType
(
name
CSS_TYPES
.
GRADIENT
)
;
if
(
options
.
expectFilter
|
|
this
.
_cssPropertySupportsValue
(
name
value
)
)
{
return
this
.
_parse
(
value
options
)
;
}
this
.
_appendTextNode
(
value
)
;
return
this
.
_toDOM
(
)
;
}
_parseMatchingParens
:
function
(
text
tokenStream
options
stopAtComma
)
{
let
depth
=
1
;
const
functionData
=
[
]
;
const
tokens
=
[
]
;
let
sawVariable
=
false
;
while
(
depth
>
0
)
{
const
token
=
tokenStream
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
continue
;
}
if
(
token
.
tokenType
=
=
=
"
symbol
"
)
{
if
(
stopAtComma
&
&
depth
=
=
=
1
&
&
token
.
text
=
=
=
"
"
)
{
return
{
tokens
functionData
sawComma
:
true
sawVariable
}
;
}
else
if
(
token
.
text
=
=
=
"
(
"
)
{
+
+
depth
;
}
else
if
(
token
.
text
=
=
=
"
)
"
)
{
-
-
depth
;
if
(
depth
=
=
=
0
)
{
break
;
}
}
}
else
if
(
token
.
tokenType
=
=
=
"
function
"
&
&
token
.
text
=
=
=
"
var
"
&
&
options
.
isVariableInUse
)
{
sawVariable
=
true
;
const
variableNode
=
this
.
_parseVariable
(
token
text
tokenStream
options
)
;
functionData
.
push
(
variableNode
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
+
+
depth
;
}
if
(
token
.
tokenType
!
=
=
"
function
"
|
|
token
.
text
!
=
=
"
var
"
|
|
!
options
.
isVariableInUse
)
{
functionData
.
push
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
if
(
token
.
tokenType
!
=
=
"
whitespace
"
)
{
tokens
.
push
(
token
)
;
}
}
return
{
tokens
functionData
sawComma
:
false
sawVariable
}
;
}
_parseVariable
:
function
(
initialToken
text
tokenStream
options
)
{
const
varText
=
text
.
substring
(
initialToken
.
startOffset
initialToken
.
endOffset
)
;
const
variableNode
=
this
.
_createNode
(
"
span
"
{
}
varText
)
;
const
{
tokens
functionData
sawComma
sawVariable
}
=
this
.
_parseMatchingParens
(
text
tokenStream
options
true
)
;
const
result
=
sawVariable
?
"
"
:
functionData
.
join
(
"
"
)
;
const
firstOpts
=
{
}
;
const
secondOpts
=
{
}
;
let
varValue
;
if
(
tokens
&
&
tokens
.
length
=
=
=
1
)
{
varValue
=
options
.
isVariableInUse
(
tokens
[
0
]
.
text
)
;
}
const
varName
=
text
.
substring
(
tokens
[
0
]
.
startOffset
tokens
[
0
]
.
endOffset
)
;
if
(
typeof
varValue
=
=
=
"
string
"
)
{
firstOpts
[
"
data
-
variable
"
]
=
STYLE_INSPECTOR_L10N
.
getFormatStr
(
"
rule
.
variableValue
"
varName
varValue
)
;
firstOpts
.
class
=
options
.
matchedVariableClass
;
secondOpts
.
class
=
options
.
unmatchedVariableClass
;
}
else
{
firstOpts
.
class
=
options
.
unmatchedVariableClass
;
firstOpts
[
"
data
-
variable
"
]
=
STYLE_INSPECTOR_L10N
.
getFormatStr
(
"
rule
.
variableUnset
"
varName
)
;
}
variableNode
.
appendChild
(
this
.
_createNode
(
"
span
"
firstOpts
result
)
)
;
if
(
sawComma
)
{
variableNode
.
appendChild
(
this
.
doc
.
createTextNode
(
"
"
)
)
;
const
subOptions
=
Object
.
assign
(
{
}
options
)
;
subOptions
.
expectFilter
=
false
;
const
saveParsed
=
this
.
parsed
;
this
.
parsed
=
[
]
;
const
rest
=
this
.
_doParse
(
text
subOptions
tokenStream
true
)
;
this
.
parsed
=
saveParsed
;
const
span
=
this
.
_createNode
(
"
span
"
secondOpts
)
;
span
.
appendChild
(
rest
)
;
variableNode
.
appendChild
(
span
)
;
}
variableNode
.
appendChild
(
this
.
doc
.
createTextNode
(
"
)
"
)
)
;
return
variableNode
;
}
_doParse
:
function
(
text
options
tokenStream
stopAtCloseParen
)
{
let
parenDepth
=
stopAtCloseParen
?
1
:
0
;
let
outerMostFunctionTakesColor
=
false
;
let
fontFamilyNameParts
=
[
]
;
let
previousWasBang
=
false
;
const
colorOK
=
function
(
)
{
return
options
.
supportsColor
|
|
(
options
.
expectFilter
&
&
parenDepth
=
=
=
1
&
&
outerMostFunctionTakesColor
)
;
}
;
const
angleOK
=
function
(
angle
)
{
return
(
new
angleUtils
.
CssAngle
(
angle
)
)
.
valid
;
}
;
let
spaceNeeded
=
false
;
let
done
=
false
;
while
(
!
done
)
{
const
token
=
tokenStream
.
nextToken
(
)
;
if
(
!
token
)
{
if
(
options
.
expectFont
&
&
fontFamilyNameParts
.
length
!
=
=
0
)
{
this
.
_appendFontFamily
(
fontFamilyNameParts
.
join
(
"
"
)
options
)
;
}
break
;
}
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
continue
;
}
switch
(
token
.
tokenType
)
{
case
"
function
"
:
{
if
(
COLOR_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
|
|
ANGLE_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
)
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
if
(
parenDepth
=
=
=
0
)
{
outerMostFunctionTakesColor
=
COLOR_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
;
}
+
+
parenDepth
;
}
else
if
(
token
.
text
=
=
=
"
var
"
&
&
options
.
isVariableInUse
)
{
const
variableNode
=
this
.
_parseVariable
(
token
text
tokenStream
options
)
;
this
.
parsed
.
push
(
variableNode
)
;
}
else
{
const
{
functionData
sawVariable
}
=
this
.
_parseMatchingParens
(
text
tokenStream
options
)
;
const
functionName
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
sawVariable
)
{
this
.
_appendTextNode
(
functionName
)
;
for
(
const
data
of
functionData
)
{
if
(
typeof
data
=
=
=
"
string
"
)
{
this
.
_appendTextNode
(
data
)
;
}
else
if
(
data
)
{
this
.
parsed
.
push
(
data
)
;
}
}
this
.
_appendTextNode
(
"
)
"
)
;
}
else
{
const
functionText
=
functionName
+
functionData
.
join
(
"
"
)
+
"
)
"
;
if
(
options
.
expectCubicBezier
&
&
token
.
text
=
=
=
"
cubic
-
bezier
"
)
{
this
.
_appendCubicBezier
(
functionText
options
)
;
}
else
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
functionText
this
.
cssColor4
)
)
{
this
.
_appendColor
(
functionText
options
)
;
}
else
if
(
options
.
expectShape
&
&
BASIC_SHAPE_FUNCTIONS
.
includes
(
token
.
text
)
)
{
this
.
_appendShape
(
functionText
options
)
;
}
else
{
this
.
_appendTextNode
(
functionText
)
;
}
}
}
break
;
}
case
"
ident
"
:
if
(
options
.
expectCubicBezier
&
&
BEZIER_KEYWORDS
.
includes
(
token
.
text
)
)
{
this
.
_appendCubicBezier
(
token
.
text
options
)
;
}
else
if
(
this
.
_isDisplayFlex
(
text
token
options
)
)
{
this
.
_appendHighlighterToggle
(
token
.
text
options
.
flexClass
)
;
}
else
if
(
this
.
_isDisplayGrid
(
text
token
options
)
)
{
this
.
_appendHighlighterToggle
(
token
.
text
options
.
gridClass
)
;
}
else
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
token
.
text
this
.
cssColor4
)
)
{
this
.
_appendColor
(
token
.
text
options
)
;
}
else
if
(
angleOK
(
token
.
text
)
)
{
this
.
_appendAngle
(
token
.
text
options
)
;
}
else
if
(
options
.
expectFont
&
&
!
previousWasBang
)
{
fontFamilyNameParts
.
push
(
token
.
text
)
;
}
else
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
break
;
case
"
id
"
:
case
"
hash
"
:
{
const
original
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
original
this
.
cssColor4
)
)
{
if
(
spaceNeeded
)
{
this
.
_appendTextNode
(
"
"
)
;
}
this
.
_appendColor
(
original
options
)
;
}
else
{
this
.
_appendTextNode
(
original
)
;
}
break
;
}
case
"
dimension
"
:
const
value
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
angleOK
(
value
)
)
{
this
.
_appendAngle
(
value
options
)
;
}
else
{
this
.
_appendTextNode
(
value
)
;
}
break
;
case
"
url
"
:
case
"
bad_url
"
:
this
.
_appendURL
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
token
.
text
options
)
;
break
;
case
"
string
"
:
if
(
options
.
expectFont
)
{
fontFamilyNameParts
.
push
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
break
;
case
"
whitespace
"
:
if
(
options
.
expectFont
)
{
fontFamilyNameParts
.
push
(
"
"
)
;
}
else
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
break
;
case
"
symbol
"
:
if
(
token
.
text
=
=
=
"
(
"
)
{
+
+
parenDepth
;
}
else
if
(
token
.
text
=
=
=
"
)
"
)
{
-
-
parenDepth
;
if
(
stopAtCloseParen
&
&
parenDepth
=
=
=
0
)
{
done
=
true
;
break
;
}
if
(
parenDepth
=
=
=
0
)
{
outerMostFunctionTakesColor
=
false
;
}
}
else
if
(
(
token
.
text
=
=
=
"
"
|
|
token
.
text
=
=
=
"
!
"
)
&
&
options
.
expectFont
&
&
fontFamilyNameParts
.
length
!
=
=
0
)
{
this
.
_appendFontFamily
(
fontFamilyNameParts
.
join
(
"
"
)
options
)
;
fontFamilyNameParts
=
[
]
;
}
default
:
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
break
;
}
spaceNeeded
=
(
token
.
tokenType
=
=
=
"
ident
"
|
|
token
.
tokenType
=
=
=
"
at
"
|
|
token
.
tokenType
=
=
=
"
id
"
|
|
token
.
tokenType
=
=
=
"
hash
"
|
|
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
)
;
previousWasBang
=
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
!
"
)
;
}
let
result
=
this
.
_toDOM
(
)
;
if
(
options
.
expectFilter
&
&
!
options
.
filterSwatch
)
{
result
=
this
.
_wrapFilter
(
text
options
result
)
;
}
return
result
;
}
_parse
:
function
(
text
options
=
{
}
)
{
text
=
text
.
trim
(
)
;
this
.
parsed
.
length
=
0
;
const
tokenStream
=
getCSSLexer
(
text
)
;
return
this
.
_doParse
(
text
options
tokenStream
false
)
;
}
_isDisplayFlex
:
function
(
text
token
options
)
{
return
options
.
expectDisplay
&
&
(
token
.
text
=
=
=
"
flex
"
|
|
token
.
text
=
=
=
"
inline
-
flex
"
)
;
}
_isDisplayGrid
:
function
(
text
token
options
)
{
return
options
.
expectDisplay
&
&
(
token
.
text
=
=
=
"
grid
"
|
|
token
.
text
=
=
=
"
inline
-
grid
"
)
;
}
_appendCubicBezier
:
function
(
bezier
options
)
{
const
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
bezier
"
:
bezier
}
)
;
if
(
options
.
bezierSwatchClass
)
{
const
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
bezierSwatchClass
}
)
;
container
.
appendChild
(
swatch
)
;
}
const
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
bezierClass
}
bezier
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_appendHighlighterToggle
:
function
(
text
className
)
{
const
container
=
this
.
_createNode
(
"
span
"
{
}
)
;
const
toggle
=
this
.
_createNode
(
"
span
"
{
class
:
className
}
)
;
const
value
=
this
.
_createNode
(
"
span
"
{
}
)
;
value
.
textContent
=
text
;
container
.
appendChild
(
toggle
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_appendShape
:
function
(
shape
options
)
{
const
shapeTypes
=
[
{
prefix
:
"
polygon
(
"
coordParser
:
this
.
_addPolygonPointNodes
.
bind
(
this
)
}
{
prefix
:
"
circle
(
"
coordParser
:
this
.
_addCirclePointNodes
.
bind
(
this
)
}
{
prefix
:
"
ellipse
(
"
coordParser
:
this
.
_addEllipsePointNodes
.
bind
(
this
)
}
{
prefix
:
"
inset
(
"
coordParser
:
this
.
_addInsetPointNodes
.
bind
(
this
)
}
]
;
const
container
=
this
.
_createNode
(
"
span
"
{
}
)
;
const
toggle
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
shapeSwatchClass
}
)
;
for
(
const
{
prefix
coordParser
}
of
shapeTypes
)
{
if
(
shape
.
includes
(
prefix
)
)
{
const
coordsBegin
=
prefix
.
length
;
const
coordsEnd
=
shape
.
lastIndexOf
(
"
)
"
)
;
let
valContainer
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
shapeClass
}
)
;
container
.
appendChild
(
toggle
)
;
appendText
(
valContainer
shape
.
substring
(
0
coordsBegin
)
)
;
const
coordsString
=
shape
.
substring
(
coordsBegin
coordsEnd
)
;
valContainer
=
coordParser
(
coordsString
valContainer
)
;
appendText
(
valContainer
shape
.
substring
(
coordsEnd
)
)
;
container
.
appendChild
(
valContainer
)
;
}
}
this
.
parsed
.
push
(
container
)
;
}
_addPolygonPointNodes
:
function
(
coords
container
)
{
const
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
coord
=
"
"
;
let
i
=
0
;
let
depth
=
0
;
let
isXCoord
=
true
;
let
fillRule
=
false
;
let
coordNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
}
)
;
while
(
token
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
"
)
{
if
(
!
isXCoord
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
(
isXCoord
)
?
"
x
"
:
"
y
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
coord
=
"
"
;
isXCoord
=
!
isXCoord
;
}
if
(
fillRule
)
{
fillRule
=
false
;
}
else
{
container
.
appendChild
(
coordNode
)
;
i
+
+
;
}
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
coord
=
"
"
;
depth
=
0
;
isXCoord
=
true
;
coordNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
}
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
(
isXCoord
)
?
"
x
"
:
"
y
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
appendText
(
coordNode
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
coord
=
"
"
;
isXCoord
=
!
isXCoord
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
isXCoord
&
&
coord
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
"
x
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
isXCoord
=
false
;
coord
=
"
"
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
(
token
.
text
=
=
=
"
nonzero
"
|
|
token
.
text
=
=
=
"
evenodd
"
)
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
fillRule
=
true
;
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
(
isXCoord
)
?
"
x
"
:
"
y
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
container
.
appendChild
(
coordNode
)
;
}
return
container
;
}
_addCirclePointNodes
:
function
(
coords
container
)
{
const
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
depth
=
0
;
let
coord
=
"
"
;
let
point
=
"
radius
"
;
const
centerNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
}
)
;
while
(
token
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
point
=
=
=
"
radius
"
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
radius
"
}
coord
)
;
container
.
appendChild
(
node
)
;
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
appendText
(
centerNode
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
(
point
=
=
=
"
cx
"
)
?
"
cy
"
:
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
token
.
text
=
=
=
"
at
"
)
{
if
(
point
=
=
=
"
radius
"
&
&
coord
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
radius
"
}
coord
)
;
container
.
appendChild
(
node
)
;
}
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
point
=
=
=
"
cx
"
&
&
coord
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
"
x
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
point
=
"
cy
"
;
coord
=
"
"
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
if
(
point
=
=
=
"
radius
"
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
radius
"
}
coord
)
;
container
.
appendChild
(
node
)
;
}
else
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
}
}
if
(
centerNode
.
textContent
)
{
container
.
appendChild
(
centerNode
)
;
}
return
container
;
}
_addEllipsePointNodes
:
function
(
coords
container
)
{
const
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
depth
=
0
;
let
coord
=
"
"
;
let
point
=
"
rx
"
;
const
centerNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
}
)
;
while
(
token
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
if
(
point
=
=
=
"
rx
"
|
|
point
=
=
=
"
ry
"
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
point
}
coord
)
;
container
.
appendChild
(
node
)
;
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
(
point
=
=
=
"
rx
"
)
?
"
ry
"
:
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
appendText
(
centerNode
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
(
point
=
=
=
"
cx
"
)
?
"
cy
"
:
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
token
.
text
=
=
=
"
at
"
)
{
if
(
point
=
=
=
"
ry
"
&
&
coord
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
ry
"
}
coord
)
;
container
.
appendChild
(
node
)
;
}
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
point
=
=
=
"
rx
"
&
&
coord
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
rx
"
}
coord
)
;
container
.
appendChild
(
node
)
;
point
=
"
ry
"
;
coord
=
"
"
;
}
if
(
point
=
=
=
"
cx
"
&
&
coord
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
"
x
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
point
=
"
cy
"
;
coord
=
"
"
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
if
(
point
=
=
=
"
rx
"
|
|
point
=
=
=
"
ry
"
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
point
}
coord
)
;
container
.
appendChild
(
node
)
;
}
else
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
}
}
if
(
centerNode
.
textContent
)
{
container
.
appendChild
(
centerNode
)
;
}
return
container
;
}
_addInsetPointNodes
:
function
(
coords
container
)
{
const
insetPoints
=
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
;
const
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
depth
=
0
;
let
coord
=
"
"
;
let
i
=
0
;
let
round
=
false
;
const
nodes
=
[
]
;
const
otherText
=
[
[
]
]
;
while
(
token
)
{
if
(
round
)
{
otherText
[
i
]
.
push
(
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
otherText
[
i
]
.
push
(
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
i
+
+
;
coord
=
"
"
;
otherText
[
i
]
=
[
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
]
;
depth
=
0
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
coord
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
i
+
+
;
coord
=
"
"
;
otherText
[
i
]
=
[
]
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
token
.
text
=
=
=
"
round
"
)
{
if
(
coord
&
&
depth
=
=
=
0
)
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
i
+
+
;
coord
=
"
"
;
otherText
[
i
]
=
[
]
;
}
round
=
true
;
otherText
[
i
]
.
push
(
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
if
(
round
)
{
otherText
[
i
]
.
push
(
coord
)
;
}
else
{
const
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
}
}
for
(
let
j
=
0
;
j
<
4
;
j
+
+
)
{
const
point
=
insetPoints
[
j
]
;
const
nodeIndex
=
(
point
=
=
=
"
left
"
&
&
nodes
.
length
=
=
=
3
)
?
1
:
j
%
nodes
.
length
;
nodes
[
nodeIndex
]
.
classList
.
add
(
point
)
;
}
nodes
.
forEach
(
(
node
j
array
)
=
>
{
for
(
const
text
of
otherText
[
j
]
)
{
appendText
(
container
text
)
;
}
container
.
appendChild
(
node
)
;
}
)
;
if
(
otherText
[
nodes
.
length
]
)
{
for
(
const
text
of
otherText
[
nodes
.
length
]
)
{
appendText
(
container
text
)
;
}
}
return
container
;
}
_appendAngle
:
function
(
angle
options
)
{
const
angleObj
=
new
angleUtils
.
CssAngle
(
angle
)
;
const
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
angle
"
:
angle
}
)
;
if
(
options
.
angleSwatchClass
)
{
const
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
angleSwatchClass
}
)
;
this
.
angleSwatches
.
set
(
swatch
angleObj
)
;
swatch
.
addEventListener
(
"
mousedown
"
this
.
_onAngleSwatchMouseDown
)
;
swatch
.
addEventListener
(
"
click
"
function
(
event
)
{
if
(
event
.
shiftKey
)
{
event
.
stopPropagation
(
)
;
}
}
)
;
EventEmitter
.
decorate
(
swatch
)
;
container
.
appendChild
(
swatch
)
;
}
const
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
angleClass
}
angle
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_cssPropertySupportsValue
:
function
(
name
value
)
{
return
this
.
isValidOnClient
(
name
value
this
.
doc
)
;
}
_isValidColor
:
function
(
colorObj
)
{
return
colorObj
.
valid
&
&
(
!
colorObj
.
specialValue
|
|
colorObj
.
specialValue
=
=
=
"
transparent
"
)
;
}
_appendColor
:
function
(
color
options
=
{
}
)
{
const
colorObj
=
new
colorUtils
.
CssColor
(
color
this
.
cssColor4
)
;
if
(
this
.
_isValidColor
(
colorObj
)
)
{
const
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
color
"
:
color
}
)
;
if
(
options
.
colorSwatchClass
)
{
const
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
colorSwatchClass
style
:
"
background
-
color
:
"
+
color
}
)
;
this
.
colorSwatches
.
set
(
swatch
colorObj
)
;
swatch
.
addEventListener
(
"
mousedown
"
this
.
_onColorSwatchMouseDown
)
;
EventEmitter
.
decorate
(
swatch
)
;
container
.
appendChild
(
swatch
)
;
}
if
(
!
options
.
defaultColorType
)
{
colorObj
.
colorUnit
=
colorUtils
.
classifyColor
(
color
)
;
}
color
=
colorObj
.
toString
(
)
;
container
.
dataset
.
color
=
color
;
const
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
colorClass
}
color
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
else
{
this
.
_appendTextNode
(
color
)
;
}
}
_wrapFilter
:
function
(
filters
options
nodes
)
{
const
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
filters
"
:
filters
}
)
;
if
(
options
.
filterSwatchClass
)
{
const
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
filterSwatchClass
}
)
;
container
.
appendChild
(
swatch
)
;
}
const
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
filterClass
}
)
;
value
.
appendChild
(
nodes
)
;
container
.
appendChild
(
value
)
;
return
container
;
}
_onColorSwatchMouseDown
:
function
(
event
)
{
if
(
!
event
.
shiftKey
)
{
return
;
}
event
.
stopPropagation
(
)
;
const
swatch
=
event
.
target
;
const
color
=
this
.
colorSwatches
.
get
(
swatch
)
;
const
val
=
color
.
nextColorUnit
(
)
;
swatch
.
nextElementSibling
.
textContent
=
val
;
swatch
.
emit
(
"
unit
-
change
"
val
)
;
}
_onAngleSwatchMouseDown
:
function
(
event
)
{
if
(
!
event
.
shiftKey
)
{
return
;
}
event
.
stopPropagation
(
)
;
const
swatch
=
event
.
target
;
const
angle
=
this
.
angleSwatches
.
get
(
swatch
)
;
const
val
=
angle
.
nextAngleUnit
(
)
;
swatch
.
nextElementSibling
.
textContent
=
val
;
swatch
.
emit
(
"
unit
-
change
"
val
)
;
}
_sanitizeURL
:
function
(
url
)
{
const
urlTokenizer
=
getCSSLexer
(
url
)
;
while
(
urlTokenizer
.
nextToken
(
)
)
{
}
return
urlTokenizer
.
performEOFFixup
(
url
true
)
;
}
_appendURL
:
function
(
match
url
options
)
{
if
(
options
.
urlClass
)
{
match
=
this
.
_sanitizeURL
(
match
)
;
const
[
leader
body
trailer
]
=
/
^
(
url
\
(
[
\
t
\
r
\
n
\
f
]
*
(
[
"
'
]
?
)
)
(
.
*
?
)
(
\
2
[
\
t
\
r
\
n
\
f
]
*
\
)
)
/
i
.
exec
(
match
)
;
this
.
_appendTextNode
(
leader
)
;
let
href
=
url
;
if
(
options
.
baseURI
)
{
try
{
href
=
new
URL
(
url
options
.
baseURI
)
.
href
;
}
catch
(
e
)
{
}
}
this
.
_appendNode
(
"
a
"
{
target
:
"
_blank
"
class
:
options
.
urlClass
href
:
href
}
body
)
;
this
.
_appendTextNode
(
trailer
)
;
}
else
{
this
.
_appendTextNode
(
match
)
;
}
}
_appendFontFamily
:
function
(
fontFamily
options
)
{
let
spanContents
=
fontFamily
;
let
quoteChar
=
null
;
let
trailingWhitespace
=
false
;
if
(
spanContents
[
0
]
=
=
=
"
"
)
{
this
.
_appendTextNode
(
"
"
)
;
spanContents
=
spanContents
.
slice
(
1
)
;
}
if
(
spanContents
[
spanContents
.
length
-
1
]
=
=
=
"
"
)
{
spanContents
=
spanContents
.
slice
(
0
-
1
)
;
trailingWhitespace
=
true
;
}
if
(
spanContents
[
0
]
=
=
=
"
'
"
|
|
spanContents
[
0
]
=
=
=
"
\
"
"
)
{
quoteChar
=
spanContents
[
0
]
;
}
if
(
quoteChar
)
{
this
.
_appendTextNode
(
quoteChar
)
;
spanContents
=
spanContents
.
slice
(
1
-
1
)
;
}
this
.
_appendNode
(
"
span
"
{
class
:
options
.
fontFamilyClass
}
spanContents
)
;
if
(
quoteChar
)
{
this
.
_appendTextNode
(
quoteChar
)
;
}
if
(
trailingWhitespace
)
{
this
.
_appendTextNode
(
"
"
)
;
}
}
_createNode
:
function
(
tagName
attributes
value
=
"
"
)
{
const
node
=
this
.
doc
.
createElementNS
(
HTML_NS
tagName
)
;
const
attrs
=
Object
.
getOwnPropertyNames
(
attributes
)
;
for
(
const
attr
of
attrs
)
{
if
(
attributes
[
attr
]
)
{
node
.
setAttribute
(
attr
attributes
[
attr
]
)
;
}
}
if
(
value
)
{
const
textNode
=
this
.
doc
.
createTextNode
(
value
)
;
node
.
appendChild
(
textNode
)
;
}
return
node
;
}
_appendNode
:
function
(
tagName
attributes
value
=
"
"
)
{
const
node
=
this
.
_createNode
(
tagName
attributes
value
)
;
this
.
parsed
.
push
(
node
)
;
}
_appendTextNode
:
function
(
text
)
{
const
lastItem
=
this
.
parsed
[
this
.
parsed
.
length
-
1
]
;
if
(
typeof
lastItem
=
=
=
"
string
"
)
{
this
.
parsed
[
this
.
parsed
.
length
-
1
]
=
lastItem
+
text
;
}
else
{
this
.
parsed
.
push
(
text
)
;
}
}
_toDOM
:
function
(
)
{
const
frag
=
this
.
doc
.
createDocumentFragment
(
)
;
for
(
const
item
of
this
.
parsed
)
{
if
(
typeof
item
=
=
=
"
string
"
)
{
frag
.
appendChild
(
this
.
doc
.
createTextNode
(
item
)
)
;
}
else
{
frag
.
appendChild
(
item
)
;
}
}
this
.
parsed
.
length
=
0
;
return
frag
;
}
_mergeOptions
:
function
(
overrides
)
{
const
defaults
=
{
defaultColorType
:
true
angleClass
:
"
"
angleSwatchClass
:
"
"
bezierClass
:
"
"
bezierSwatchClass
:
"
"
colorClass
:
"
"
colorSwatchClass
:
"
"
filterSwatch
:
false
flexClass
:
"
"
gridClass
:
"
"
shapeClass
:
"
"
shapeSwatchClass
:
"
"
supportsColor
:
false
urlClass
:
"
"
fontFamilyClass
:
"
"
baseURI
:
undefined
isVariableInUse
:
null
unmatchedVariableClass
:
null
}
;
for
(
const
item
in
overrides
)
{
defaults
[
item
]
=
overrides
[
item
]
;
}
return
defaults
;
}
}
;
module
.
exports
=
OutputParser
;
