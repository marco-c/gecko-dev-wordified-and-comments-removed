"
use
strict
"
;
const
{
angleUtils
}
=
require
(
"
devtools
/
client
/
shared
/
css
-
angle
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
ANGLE_TAKING_FUNCTIONS
BEZIER_KEYWORDS
COLOR_TAKING_FUNCTIONS
CSS_TYPES
}
=
require
(
"
devtools
/
shared
/
css
/
properties
-
db
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
CSS_GRID_ENABLED_PREF
=
"
layout
.
css
.
grid
.
enabled
"
;
function
OutputParser
(
document
{
supportsType
isValidOnClient
supportsCssColor4ColorFunction
}
)
{
this
.
parsed
=
[
]
;
this
.
doc
=
document
;
this
.
supportsType
=
supportsType
;
this
.
isValidOnClient
=
isValidOnClient
;
this
.
colorSwatches
=
new
WeakMap
(
)
;
this
.
angleSwatches
=
new
WeakMap
(
)
;
this
.
_onColorSwatchMouseDown
=
this
.
_onColorSwatchMouseDown
.
bind
(
this
)
;
this
.
_onAngleSwatchMouseDown
=
this
.
_onAngleSwatchMouseDown
.
bind
(
this
)
;
this
.
cssColor4
=
supportsCssColor4ColorFunction
(
)
;
}
OutputParser
.
prototype
=
{
parseCssProperty
(
name
value
options
=
{
}
)
{
options
=
this
.
_mergeOptions
(
options
)
;
options
.
expectCubicBezier
=
this
.
supportsType
(
name
CSS_TYPES
.
TIMING_FUNCTION
)
;
options
.
expectDisplay
=
name
=
=
=
"
display
"
;
options
.
expectFilter
=
name
=
=
=
"
filter
"
;
options
.
supportsColor
=
this
.
supportsType
(
name
CSS_TYPES
.
COLOR
)
|
|
this
.
supportsType
(
name
CSS_TYPES
.
GRADIENT
)
;
if
(
options
.
expectFilter
|
|
this
.
_cssPropertySupportsValue
(
name
value
)
)
{
return
this
.
_parse
(
value
options
)
;
}
this
.
_appendTextNode
(
value
)
;
return
this
.
_toDOM
(
)
;
}
_collectFunctionText
(
initialToken
text
tokenStream
)
{
let
result
=
text
.
substring
(
initialToken
.
startOffset
initialToken
.
endOffset
)
;
let
depth
=
1
;
while
(
depth
>
0
)
{
let
token
=
tokenStream
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
continue
;
}
result
+
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
symbol
"
)
{
if
(
token
.
text
=
=
=
"
(
"
)
{
+
+
depth
;
}
else
if
(
token
.
text
=
=
=
"
)
"
)
{
-
-
depth
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
+
+
depth
;
}
}
return
result
;
}
_parse
(
text
options
=
{
}
)
{
text
=
text
.
trim
(
)
;
this
.
parsed
.
length
=
0
;
let
tokenStream
=
getCSSLexer
(
text
)
;
let
parenDepth
=
0
;
let
outerMostFunctionTakesColor
=
false
;
let
colorOK
=
function
(
)
{
return
options
.
supportsColor
|
|
(
options
.
expectFilter
&
&
parenDepth
=
=
=
1
&
&
outerMostFunctionTakesColor
)
;
}
;
let
angleOK
=
function
(
angle
)
{
return
(
new
angleUtils
.
CssAngle
(
angle
)
)
.
valid
;
}
;
while
(
true
)
{
let
token
=
tokenStream
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
continue
;
}
switch
(
token
.
tokenType
)
{
case
"
function
"
:
{
if
(
COLOR_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
|
|
ANGLE_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
)
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
if
(
parenDepth
=
=
=
0
)
{
outerMostFunctionTakesColor
=
COLOR_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
;
}
+
+
parenDepth
;
}
else
{
let
functionText
=
this
.
_collectFunctionText
(
token
text
tokenStream
)
;
if
(
options
.
expectCubicBezier
&
&
token
.
text
=
=
=
"
cubic
-
bezier
"
)
{
this
.
_appendCubicBezier
(
functionText
options
)
;
}
else
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
functionText
this
.
cssColor4
)
)
{
this
.
_appendColor
(
functionText
options
)
;
}
else
{
this
.
_appendTextNode
(
functionText
)
;
}
}
break
;
}
case
"
ident
"
:
if
(
options
.
expectCubicBezier
&
&
BEZIER_KEYWORDS
.
indexOf
(
token
.
text
)
>
=
0
)
{
this
.
_appendCubicBezier
(
token
.
text
options
)
;
}
else
if
(
Services
.
prefs
.
getBoolPref
(
CSS_GRID_ENABLED_PREF
)
&
&
options
.
expectDisplay
&
&
token
.
text
=
=
=
"
grid
"
&
&
text
=
=
=
token
.
text
)
{
this
.
_appendGrid
(
token
.
text
options
)
;
}
else
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
token
.
text
this
.
cssColor4
)
)
{
this
.
_appendColor
(
token
.
text
options
)
;
}
else
if
(
angleOK
(
token
.
text
)
)
{
this
.
_appendAngle
(
token
.
text
options
)
;
}
else
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
break
;
case
"
id
"
:
case
"
hash
"
:
{
let
original
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
original
this
.
cssColor4
)
)
{
this
.
_appendColor
(
original
options
)
;
}
else
{
this
.
_appendTextNode
(
original
)
;
}
break
;
}
case
"
dimension
"
:
let
value
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
angleOK
(
value
)
)
{
this
.
_appendAngle
(
value
options
)
;
}
else
{
this
.
_appendTextNode
(
value
)
;
}
break
;
case
"
url
"
:
case
"
bad_url
"
:
this
.
_appendURL
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
token
.
text
options
)
;
break
;
case
"
symbol
"
:
if
(
token
.
text
=
=
=
"
(
"
)
{
+
+
parenDepth
;
}
else
if
(
token
.
text
=
=
=
"
)
"
)
{
-
-
parenDepth
;
if
(
parenDepth
=
=
=
0
)
{
outerMostFunctionTakesColor
=
false
;
}
}
default
:
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
break
;
}
}
let
result
=
this
.
_toDOM
(
)
;
if
(
options
.
expectFilter
&
&
!
options
.
filterSwatch
)
{
result
=
this
.
_wrapFilter
(
text
options
result
)
;
}
return
result
;
}
_appendCubicBezier
(
bezier
options
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
bezier
"
:
bezier
}
)
;
if
(
options
.
bezierSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
bezierSwatchClass
}
)
;
container
.
appendChild
(
swatch
)
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
bezierClass
}
bezier
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_appendGrid
(
grid
options
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
}
)
;
let
toggle
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
gridClass
}
)
;
let
value
=
this
.
_createNode
(
"
span
"
{
}
)
;
value
.
textContent
=
grid
;
container
.
appendChild
(
toggle
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_appendAngle
(
angle
options
)
{
let
angleObj
=
new
angleUtils
.
CssAngle
(
angle
)
;
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
angle
"
:
angle
}
)
;
if
(
options
.
angleSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
angleSwatchClass
}
)
;
this
.
angleSwatches
.
set
(
swatch
angleObj
)
;
swatch
.
addEventListener
(
"
mousedown
"
this
.
_onAngleSwatchMouseDown
false
)
;
swatch
.
addEventListener
(
"
click
"
function
(
event
)
{
if
(
event
.
shiftKey
)
{
event
.
stopPropagation
(
)
;
}
}
false
)
;
EventEmitter
.
decorate
(
swatch
)
;
container
.
appendChild
(
swatch
)
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
angleClass
}
angle
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_cssPropertySupportsValue
(
name
value
)
{
return
this
.
isValidOnClient
(
name
value
this
.
doc
)
;
}
_isValidColor
(
colorObj
)
{
return
colorObj
.
valid
&
&
(
!
colorObj
.
specialValue
|
|
colorObj
.
specialValue
=
=
=
"
transparent
"
)
;
}
_appendColor
(
color
options
=
{
}
)
{
let
colorObj
=
new
colorUtils
.
CssColor
(
color
this
.
cssColor4
)
;
if
(
this
.
_isValidColor
(
colorObj
)
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
color
"
:
color
}
)
;
if
(
options
.
colorSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
colorSwatchClass
style
:
"
background
-
color
:
"
+
color
}
)
;
this
.
colorSwatches
.
set
(
swatch
colorObj
)
;
swatch
.
addEventListener
(
"
mousedown
"
this
.
_onColorSwatchMouseDown
false
)
;
EventEmitter
.
decorate
(
swatch
)
;
container
.
appendChild
(
swatch
)
;
}
if
(
options
.
defaultColorType
)
{
color
=
colorObj
.
toString
(
)
;
container
.
dataset
.
color
=
color
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
colorClass
}
color
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
else
{
this
.
_appendTextNode
(
color
)
;
}
}
_wrapFilter
(
filters
options
nodes
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
filters
"
:
filters
}
)
;
if
(
options
.
filterSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
filterSwatchClass
}
)
;
container
.
appendChild
(
swatch
)
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
filterClass
}
)
;
value
.
appendChild
(
nodes
)
;
container
.
appendChild
(
value
)
;
return
container
;
}
_onColorSwatchMouseDown
(
event
)
{
if
(
!
event
.
shiftKey
)
{
return
;
}
event
.
stopPropagation
(
)
;
let
swatch
=
event
.
target
;
let
color
=
this
.
colorSwatches
.
get
(
swatch
)
;
let
val
=
color
.
nextColorUnit
(
)
;
swatch
.
nextElementSibling
.
textContent
=
val
;
swatch
.
emit
(
"
unit
-
change
"
val
)
;
}
_onAngleSwatchMouseDown
(
event
)
{
if
(
!
event
.
shiftKey
)
{
return
;
}
event
.
stopPropagation
(
)
;
let
swatch
=
event
.
target
;
let
angle
=
this
.
angleSwatches
.
get
(
swatch
)
;
let
val
=
angle
.
nextAngleUnit
(
)
;
swatch
.
nextElementSibling
.
textContent
=
val
;
swatch
.
emit
(
"
unit
-
change
"
val
)
;
}
_sanitizeURL
(
url
)
{
let
urlTokenizer
=
getCSSLexer
(
url
)
;
while
(
urlTokenizer
.
nextToken
(
)
)
{
}
return
urlTokenizer
.
performEOFFixup
(
url
true
)
;
}
_appendURL
(
match
url
options
)
{
if
(
options
.
urlClass
)
{
match
=
this
.
_sanitizeURL
(
match
)
;
let
[
leader
body
trailer
]
=
/
^
(
url
\
(
[
\
t
\
r
\
n
\
f
]
*
(
[
"
'
]
?
)
)
(
.
*
?
)
(
\
2
[
\
t
\
r
\
n
\
f
]
*
\
)
)
/
i
.
exec
(
match
)
;
this
.
_appendTextNode
(
leader
)
;
let
href
=
url
;
if
(
options
.
baseURI
)
{
try
{
href
=
new
URL
(
url
options
.
baseURI
)
.
href
;
}
catch
(
e
)
{
}
}
this
.
_appendNode
(
"
a
"
{
target
:
"
_blank
"
class
:
options
.
urlClass
href
}
body
)
;
this
.
_appendTextNode
(
trailer
)
;
}
else
{
this
.
_appendTextNode
(
match
)
;
}
}
_createNode
(
tagName
attributes
value
=
"
"
)
{
let
node
=
this
.
doc
.
createElementNS
(
HTML_NS
tagName
)
;
let
attrs
=
Object
.
getOwnPropertyNames
(
attributes
)
;
for
(
let
attr
of
attrs
)
{
if
(
attributes
[
attr
]
)
{
node
.
setAttribute
(
attr
attributes
[
attr
]
)
;
}
}
if
(
value
)
{
let
textNode
=
this
.
doc
.
createTextNode
(
value
)
;
node
.
appendChild
(
textNode
)
;
}
return
node
;
}
_appendNode
(
tagName
attributes
value
=
"
"
)
{
let
node
=
this
.
_createNode
(
tagName
attributes
value
)
;
this
.
parsed
.
push
(
node
)
;
}
_appendTextNode
(
text
)
{
let
lastItem
=
this
.
parsed
[
this
.
parsed
.
length
-
1
]
;
if
(
typeof
lastItem
=
=
=
"
string
"
)
{
this
.
parsed
[
this
.
parsed
.
length
-
1
]
=
lastItem
+
text
;
}
else
{
this
.
parsed
.
push
(
text
)
;
}
}
_toDOM
(
)
{
let
frag
=
this
.
doc
.
createDocumentFragment
(
)
;
for
(
let
item
of
this
.
parsed
)
{
if
(
typeof
item
=
=
=
"
string
"
)
{
frag
.
appendChild
(
this
.
doc
.
createTextNode
(
item
)
)
;
}
else
{
frag
.
appendChild
(
item
)
;
}
}
this
.
parsed
.
length
=
0
;
return
frag
;
}
_mergeOptions
(
overrides
)
{
let
defaults
=
{
defaultColorType
:
true
angleClass
:
"
"
angleSwatchClass
:
"
"
bezierClass
:
"
"
bezierSwatchClass
:
"
"
colorClass
:
"
"
colorSwatchClass
:
"
"
filterSwatch
:
false
gridClass
:
"
"
supportsColor
:
false
urlClass
:
"
"
baseURI
:
undefined
}
;
for
(
let
item
in
overrides
)
{
defaults
[
item
]
=
overrides
[
item
]
;
}
return
defaults
;
}
}
;
module
.
exports
=
OutputParser
;
