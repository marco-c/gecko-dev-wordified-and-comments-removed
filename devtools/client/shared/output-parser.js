"
use
strict
"
;
const
{
angleUtils
}
=
require
(
"
devtools
/
client
/
shared
/
css
-
angle
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
"
)
;
const
{
getCSSLexer
}
=
require
(
"
devtools
/
shared
/
css
/
lexer
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
ANGLE_TAKING_FUNCTIONS
BASIC_SHAPE_FUNCTIONS
BEZIER_KEYWORDS
COLOR_TAKING_FUNCTIONS
CSS_TYPES
}
=
require
(
"
devtools
/
shared
/
css
/
properties
-
db
"
)
;
const
{
appendText
}
=
require
(
"
devtools
/
client
/
inspector
/
shared
/
utils
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
HTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
CSS_GRID_ENABLED_PREF
=
"
layout
.
css
.
grid
.
enabled
"
;
const
CSS_SHAPES_ENABLED_PREF
=
"
devtools
.
inspector
.
shapesHighlighter
.
enabled
"
;
function
OutputParser
(
document
{
supportsType
isValidOnClient
supportsCssColor4ColorFunction
}
)
{
this
.
parsed
=
[
]
;
this
.
doc
=
document
;
this
.
supportsType
=
supportsType
;
this
.
isValidOnClient
=
isValidOnClient
;
this
.
colorSwatches
=
new
WeakMap
(
)
;
this
.
angleSwatches
=
new
WeakMap
(
)
;
this
.
_onColorSwatchMouseDown
=
this
.
_onColorSwatchMouseDown
.
bind
(
this
)
;
this
.
_onAngleSwatchMouseDown
=
this
.
_onAngleSwatchMouseDown
.
bind
(
this
)
;
this
.
cssColor4
=
supportsCssColor4ColorFunction
(
)
;
}
OutputParser
.
prototype
=
{
parseCssProperty
:
function
(
name
value
options
=
{
}
)
{
options
=
this
.
_mergeOptions
(
options
)
;
options
.
expectCubicBezier
=
this
.
supportsType
(
name
CSS_TYPES
.
TIMING_FUNCTION
)
;
options
.
expectDisplay
=
name
=
=
=
"
display
"
;
options
.
expectFilter
=
name
=
=
=
"
filter
"
;
options
.
expectShape
=
name
=
=
=
"
clip
-
path
"
|
|
name
=
=
=
"
shape
-
outside
"
;
options
.
supportsColor
=
this
.
supportsType
(
name
CSS_TYPES
.
COLOR
)
|
|
this
.
supportsType
(
name
CSS_TYPES
.
GRADIENT
)
;
if
(
options
.
expectFilter
|
|
this
.
_cssPropertySupportsValue
(
name
value
)
)
{
return
this
.
_parse
(
value
options
)
;
}
this
.
_appendTextNode
(
value
)
;
return
this
.
_toDOM
(
)
;
}
_collectFunctionText
:
function
(
initialToken
text
tokenStream
)
{
let
result
=
text
.
substring
(
initialToken
.
startOffset
initialToken
.
endOffset
)
;
let
depth
=
1
;
while
(
depth
>
0
)
{
let
token
=
tokenStream
.
nextToken
(
)
;
if
(
!
token
)
{
break
;
}
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
continue
;
}
result
+
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
symbol
"
)
{
if
(
token
.
text
=
=
=
"
(
"
)
{
+
+
depth
;
}
else
if
(
token
.
text
=
=
=
"
)
"
)
{
-
-
depth
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
+
+
depth
;
}
}
return
result
;
}
_parse
:
function
(
text
options
=
{
}
)
{
text
=
text
.
trim
(
)
;
this
.
parsed
.
length
=
0
;
let
tokenStream
=
getCSSLexer
(
text
)
;
let
parenDepth
=
0
;
let
outerMostFunctionTakesColor
=
false
;
let
colorOK
=
function
(
)
{
return
options
.
supportsColor
|
|
(
options
.
expectFilter
&
&
parenDepth
=
=
=
1
&
&
outerMostFunctionTakesColor
)
;
}
;
let
angleOK
=
function
(
angle
)
{
return
(
new
angleUtils
.
CssAngle
(
angle
)
)
.
valid
;
}
;
let
spaceNeeded
=
false
;
let
token
=
tokenStream
.
nextToken
(
)
;
while
(
token
)
{
if
(
token
.
tokenType
=
=
=
"
comment
"
)
{
token
=
tokenStream
.
nextToken
(
)
;
continue
;
}
switch
(
token
.
tokenType
)
{
case
"
function
"
:
{
if
(
COLOR_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
|
|
ANGLE_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
)
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
if
(
parenDepth
=
=
=
0
)
{
outerMostFunctionTakesColor
=
COLOR_TAKING_FUNCTIONS
.
includes
(
token
.
text
)
;
}
+
+
parenDepth
;
}
else
{
let
functionText
=
this
.
_collectFunctionText
(
token
text
tokenStream
)
;
if
(
options
.
expectCubicBezier
&
&
token
.
text
=
=
=
"
cubic
-
bezier
"
)
{
this
.
_appendCubicBezier
(
functionText
options
)
;
}
else
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
functionText
this
.
cssColor4
)
)
{
this
.
_appendColor
(
functionText
options
)
;
}
else
if
(
options
.
expectShape
&
&
Services
.
prefs
.
getBoolPref
(
CSS_SHAPES_ENABLED_PREF
)
&
&
BASIC_SHAPE_FUNCTIONS
.
includes
(
token
.
text
)
)
{
this
.
_appendShape
(
functionText
options
)
;
}
else
{
this
.
_appendTextNode
(
functionText
)
;
}
}
break
;
}
case
"
ident
"
:
if
(
options
.
expectCubicBezier
&
&
BEZIER_KEYWORDS
.
indexOf
(
token
.
text
)
>
=
0
)
{
this
.
_appendCubicBezier
(
token
.
text
options
)
;
}
else
if
(
Services
.
prefs
.
getBoolPref
(
CSS_GRID_ENABLED_PREF
)
&
&
this
.
_isDisplayGrid
(
text
token
options
)
)
{
this
.
_appendGrid
(
token
.
text
options
)
;
}
else
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
token
.
text
this
.
cssColor4
)
)
{
this
.
_appendColor
(
token
.
text
options
)
;
}
else
if
(
angleOK
(
token
.
text
)
)
{
this
.
_appendAngle
(
token
.
text
options
)
;
}
else
{
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
break
;
case
"
id
"
:
case
"
hash
"
:
{
let
original
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
colorOK
(
)
&
&
colorUtils
.
isValidCSSColor
(
original
this
.
cssColor4
)
)
{
if
(
spaceNeeded
)
{
this
.
_appendTextNode
(
"
"
)
;
}
this
.
_appendColor
(
original
options
)
;
}
else
{
this
.
_appendTextNode
(
original
)
;
}
break
;
}
case
"
dimension
"
:
let
value
=
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
angleOK
(
value
)
)
{
this
.
_appendAngle
(
value
options
)
;
}
else
{
this
.
_appendTextNode
(
value
)
;
}
break
;
case
"
url
"
:
case
"
bad_url
"
:
this
.
_appendURL
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
token
.
text
options
)
;
break
;
case
"
symbol
"
:
if
(
token
.
text
=
=
=
"
(
"
)
{
+
+
parenDepth
;
}
else
if
(
token
.
text
=
=
=
"
)
"
)
{
-
-
parenDepth
;
if
(
parenDepth
=
=
=
0
)
{
outerMostFunctionTakesColor
=
false
;
}
}
default
:
this
.
_appendTextNode
(
text
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
break
;
}
spaceNeeded
=
(
token
.
tokenType
=
=
=
"
ident
"
|
|
token
.
tokenType
=
=
=
"
at
"
|
|
token
.
tokenType
=
=
=
"
id
"
|
|
token
.
tokenType
=
=
=
"
hash
"
|
|
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
)
;
token
=
tokenStream
.
nextToken
(
)
;
}
let
result
=
this
.
_toDOM
(
)
;
if
(
options
.
expectFilter
&
&
!
options
.
filterSwatch
)
{
result
=
this
.
_wrapFilter
(
text
options
result
)
;
}
return
result
;
}
_isDisplayGrid
:
function
(
text
token
options
)
{
return
options
.
expectDisplay
&
&
(
token
.
text
=
=
=
"
grid
"
|
|
token
.
text
=
=
=
"
inline
-
grid
"
)
;
}
_appendCubicBezier
:
function
(
bezier
options
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
bezier
"
:
bezier
}
)
;
if
(
options
.
bezierSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
bezierSwatchClass
}
)
;
container
.
appendChild
(
swatch
)
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
bezierClass
}
bezier
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_appendGrid
:
function
(
grid
options
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
}
)
;
let
toggle
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
gridClass
}
)
;
let
value
=
this
.
_createNode
(
"
span
"
{
}
)
;
value
.
textContent
=
grid
;
container
.
appendChild
(
toggle
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_appendShape
:
function
(
shape
options
)
{
const
shapeTypes
=
[
{
prefix
:
"
polygon
(
"
coordParser
:
this
.
_addPolygonPointNodes
.
bind
(
this
)
}
{
prefix
:
"
circle
(
"
coordParser
:
this
.
_addCirclePointNodes
.
bind
(
this
)
}
{
prefix
:
"
ellipse
(
"
coordParser
:
this
.
_addEllipsePointNodes
.
bind
(
this
)
}
{
prefix
:
"
inset
(
"
coordParser
:
this
.
_addInsetPointNodes
.
bind
(
this
)
}
]
;
let
container
=
this
.
_createNode
(
"
span
"
{
}
)
;
let
toggle
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
shapeClass
}
)
;
for
(
let
{
prefix
coordParser
}
of
shapeTypes
)
{
if
(
shape
.
includes
(
prefix
)
)
{
let
coordsBegin
=
prefix
.
length
;
let
coordsEnd
=
shape
.
lastIndexOf
(
"
)
"
)
;
let
valContainer
=
this
.
_createNode
(
"
span
"
{
}
)
;
container
.
appendChild
(
toggle
)
;
appendText
(
valContainer
shape
.
substring
(
0
coordsBegin
)
)
;
let
coordsString
=
shape
.
substring
(
coordsBegin
coordsEnd
)
;
valContainer
=
coordParser
(
coordsString
valContainer
)
;
appendText
(
valContainer
shape
.
substring
(
coordsEnd
)
)
;
container
.
appendChild
(
valContainer
)
;
}
}
this
.
parsed
.
push
(
container
)
;
}
_addPolygonPointNodes
:
function
(
coords
container
)
{
let
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
coord
=
"
"
;
let
i
=
0
;
let
depth
=
0
;
let
isXCoord
=
true
;
let
fillRule
=
false
;
let
coordNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
}
)
;
while
(
token
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
"
)
{
if
(
!
isXCoord
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
(
isXCoord
)
?
"
x
"
:
"
y
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
coord
=
"
"
;
isXCoord
=
!
isXCoord
;
}
if
(
fillRule
)
{
fillRule
=
false
;
}
else
{
container
.
appendChild
(
coordNode
)
;
i
+
+
;
}
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
coord
=
"
"
;
depth
=
0
;
isXCoord
=
true
;
coordNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
}
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
(
isXCoord
)
?
"
x
"
:
"
y
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
appendText
(
coordNode
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
coord
=
"
"
;
isXCoord
=
!
isXCoord
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
isXCoord
&
&
coord
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
"
x
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
isXCoord
=
false
;
coord
=
"
"
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
(
token
.
text
=
=
=
"
nonzero
"
|
|
token
.
text
=
=
=
"
evenodd
"
)
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
fillRule
=
true
;
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
{
i
}
"
data
-
pair
"
:
(
isXCoord
)
?
"
x
"
:
"
y
"
}
coord
)
;
coordNode
.
appendChild
(
node
)
;
container
.
appendChild
(
coordNode
)
;
}
return
container
;
}
_addCirclePointNodes
:
function
(
coords
container
)
{
let
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
depth
=
0
;
let
coord
=
"
"
;
let
point
=
"
radius
"
;
let
centerNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
}
)
;
while
(
token
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
point
=
=
=
"
radius
"
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
radius
"
}
coord
)
;
container
.
appendChild
(
node
)
;
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
appendText
(
centerNode
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
(
point
=
=
=
"
cx
"
)
?
"
cy
"
:
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
token
.
text
=
=
=
"
at
"
)
{
if
(
point
=
=
=
"
radius
"
&
&
coord
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
radius
"
}
coord
)
;
container
.
appendChild
(
node
)
;
}
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
point
=
=
=
"
cx
"
&
&
coord
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
"
x
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
point
=
"
cy
"
;
coord
=
"
"
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
if
(
point
=
=
=
"
radius
"
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
radius
"
}
coord
)
;
container
.
appendChild
(
node
)
;
}
else
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
}
}
if
(
centerNode
.
textContent
)
{
container
.
appendChild
(
centerNode
)
;
}
return
container
;
}
_addEllipsePointNodes
:
function
(
coords
container
)
{
let
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
depth
=
0
;
let
coord
=
"
"
;
let
point
=
"
rx
"
;
let
centerNode
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
}
)
;
while
(
token
)
{
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
if
(
point
=
=
=
"
rx
"
|
|
point
=
=
=
"
ry
"
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
point
}
coord
)
;
container
.
appendChild
(
node
)
;
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
(
point
=
=
=
"
rx
"
)
?
"
ry
"
:
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
appendText
(
centerNode
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
(
point
=
=
=
"
cx
"
)
?
"
cy
"
:
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
token
.
text
=
=
=
"
at
"
)
{
if
(
point
=
=
=
"
ry
"
&
&
coord
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
ry
"
}
coord
)
;
container
.
appendChild
(
node
)
;
}
appendText
(
container
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
point
=
"
cx
"
;
coord
=
"
"
;
depth
=
0
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
point
=
=
=
"
rx
"
&
&
coord
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
rx
"
}
coord
)
;
container
.
appendChild
(
node
)
;
point
=
"
ry
"
;
coord
=
"
"
;
}
if
(
point
=
=
=
"
cx
"
&
&
coord
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
"
x
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
point
=
"
cy
"
;
coord
=
"
"
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
if
(
point
=
=
=
"
rx
"
|
|
point
=
=
=
"
ry
"
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
point
}
coord
)
;
container
.
appendChild
(
node
)
;
}
else
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
"
data
-
point
"
:
"
center
"
"
data
-
pair
"
:
(
point
=
=
=
"
cx
"
)
?
"
x
"
:
"
y
"
}
coord
)
;
centerNode
.
appendChild
(
node
)
;
}
}
if
(
centerNode
.
textContent
)
{
container
.
appendChild
(
centerNode
)
;
}
return
container
;
}
_addInsetPointNodes
:
function
(
coords
container
)
{
const
insetPoints
=
[
"
top
"
"
right
"
"
bottom
"
"
left
"
]
;
let
tokenStream
=
getCSSLexer
(
coords
)
;
let
token
=
tokenStream
.
nextToken
(
)
;
let
depth
=
0
;
let
coord
=
"
"
;
let
i
=
0
;
let
round
=
false
;
let
nodes
=
[
]
;
let
otherText
=
[
[
]
]
;
while
(
token
)
{
if
(
round
)
{
otherText
[
i
]
.
push
(
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
(
"
)
{
depth
+
+
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
symbol
"
&
&
token
.
text
=
=
=
"
)
"
)
{
depth
-
-
;
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
coord
=
=
=
"
"
)
{
otherText
[
i
]
.
push
(
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
if
(
token
.
tokenType
=
=
=
"
whitespace
"
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
i
+
+
;
coord
=
"
"
;
otherText
[
i
]
=
[
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
]
;
depth
=
0
;
}
else
if
(
(
token
.
tokenType
=
=
=
"
number
"
|
|
token
.
tokenType
=
=
=
"
dimension
"
|
|
token
.
tokenType
=
=
=
"
percentage
"
|
|
token
.
tokenType
=
=
=
"
function
"
)
)
{
if
(
coord
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
i
+
+
;
coord
=
"
"
;
otherText
[
i
]
=
[
]
;
}
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
if
(
token
.
tokenType
=
=
=
"
function
"
)
{
depth
+
+
;
}
}
else
if
(
token
.
tokenType
=
=
=
"
ident
"
&
&
token
.
text
=
=
=
"
round
"
)
{
if
(
coord
&
&
depth
=
=
=
0
)
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
i
+
+
;
coord
=
"
"
;
otherText
[
i
]
=
[
]
;
}
round
=
true
;
otherText
[
i
]
.
push
(
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
)
;
}
else
{
coord
+
=
coords
.
substring
(
token
.
startOffset
token
.
endOffset
)
;
}
token
=
tokenStream
.
nextToken
(
)
;
}
if
(
coord
)
{
if
(
round
)
{
otherText
[
i
]
.
push
(
coord
)
;
}
else
{
let
node
=
this
.
_createNode
(
"
span
"
{
class
:
"
ruleview
-
shape
-
point
"
}
coord
)
;
nodes
.
push
(
node
)
;
}
}
for
(
let
j
=
0
;
j
<
4
;
j
+
+
)
{
let
point
=
insetPoints
[
j
]
;
let
nodeIndex
=
(
point
=
=
=
"
left
"
&
&
nodes
.
length
=
=
=
3
)
?
1
:
j
%
nodes
.
length
;
nodes
[
nodeIndex
]
.
classList
.
add
(
point
)
;
}
nodes
.
forEach
(
(
node
j
array
)
=
>
{
for
(
let
text
of
otherText
[
j
]
)
{
appendText
(
container
text
)
;
}
container
.
appendChild
(
node
)
;
}
)
;
if
(
otherText
[
nodes
.
length
]
)
{
for
(
let
text
of
otherText
[
nodes
.
length
]
)
{
appendText
(
container
text
)
;
}
}
return
container
;
}
_appendAngle
:
function
(
angle
options
)
{
let
angleObj
=
new
angleUtils
.
CssAngle
(
angle
)
;
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
angle
"
:
angle
}
)
;
if
(
options
.
angleSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
angleSwatchClass
}
)
;
this
.
angleSwatches
.
set
(
swatch
angleObj
)
;
swatch
.
addEventListener
(
"
mousedown
"
this
.
_onAngleSwatchMouseDown
)
;
swatch
.
addEventListener
(
"
click
"
function
(
event
)
{
if
(
event
.
shiftKey
)
{
event
.
stopPropagation
(
)
;
}
}
)
;
EventEmitter
.
decorate
(
swatch
)
;
container
.
appendChild
(
swatch
)
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
angleClass
}
angle
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
_cssPropertySupportsValue
:
function
(
name
value
)
{
return
this
.
isValidOnClient
(
name
value
this
.
doc
)
;
}
_isValidColor
:
function
(
colorObj
)
{
return
colorObj
.
valid
&
&
(
!
colorObj
.
specialValue
|
|
colorObj
.
specialValue
=
=
=
"
transparent
"
)
;
}
_appendColor
:
function
(
color
options
=
{
}
)
{
let
colorObj
=
new
colorUtils
.
CssColor
(
color
this
.
cssColor4
)
;
if
(
this
.
_isValidColor
(
colorObj
)
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
color
"
:
color
}
)
;
if
(
options
.
colorSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
colorSwatchClass
style
:
"
background
-
color
:
"
+
color
}
)
;
this
.
colorSwatches
.
set
(
swatch
colorObj
)
;
swatch
.
addEventListener
(
"
mousedown
"
this
.
_onColorSwatchMouseDown
)
;
EventEmitter
.
decorate
(
swatch
)
;
container
.
appendChild
(
swatch
)
;
}
if
(
options
.
defaultColorType
)
{
color
=
colorObj
.
toString
(
)
;
container
.
dataset
.
color
=
color
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
colorClass
}
color
)
;
container
.
appendChild
(
value
)
;
this
.
parsed
.
push
(
container
)
;
}
else
{
this
.
_appendTextNode
(
color
)
;
}
}
_wrapFilter
:
function
(
filters
options
nodes
)
{
let
container
=
this
.
_createNode
(
"
span
"
{
"
data
-
filters
"
:
filters
}
)
;
if
(
options
.
filterSwatchClass
)
{
let
swatch
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
filterSwatchClass
}
)
;
container
.
appendChild
(
swatch
)
;
}
let
value
=
this
.
_createNode
(
"
span
"
{
class
:
options
.
filterClass
}
)
;
value
.
appendChild
(
nodes
)
;
container
.
appendChild
(
value
)
;
return
container
;
}
_onColorSwatchMouseDown
:
function
(
event
)
{
if
(
!
event
.
shiftKey
)
{
return
;
}
event
.
stopPropagation
(
)
;
let
swatch
=
event
.
target
;
let
color
=
this
.
colorSwatches
.
get
(
swatch
)
;
let
val
=
color
.
nextColorUnit
(
)
;
swatch
.
nextElementSibling
.
textContent
=
val
;
swatch
.
emit
(
"
unit
-
change
"
val
)
;
}
_onAngleSwatchMouseDown
:
function
(
event
)
{
if
(
!
event
.
shiftKey
)
{
return
;
}
event
.
stopPropagation
(
)
;
let
swatch
=
event
.
target
;
let
angle
=
this
.
angleSwatches
.
get
(
swatch
)
;
let
val
=
angle
.
nextAngleUnit
(
)
;
swatch
.
nextElementSibling
.
textContent
=
val
;
swatch
.
emit
(
"
unit
-
change
"
val
)
;
}
_sanitizeURL
:
function
(
url
)
{
let
urlTokenizer
=
getCSSLexer
(
url
)
;
while
(
urlTokenizer
.
nextToken
(
)
)
{
}
return
urlTokenizer
.
performEOFFixup
(
url
true
)
;
}
_appendURL
:
function
(
match
url
options
)
{
if
(
options
.
urlClass
)
{
match
=
this
.
_sanitizeURL
(
match
)
;
let
[
leader
body
trailer
]
=
/
^
(
url
\
(
[
\
t
\
r
\
n
\
f
]
*
(
[
"
'
]
?
)
)
(
.
*
?
)
(
\
2
[
\
t
\
r
\
n
\
f
]
*
\
)
)
/
i
.
exec
(
match
)
;
this
.
_appendTextNode
(
leader
)
;
let
href
=
url
;
if
(
options
.
baseURI
)
{
try
{
href
=
new
URL
(
url
options
.
baseURI
)
.
href
;
}
catch
(
e
)
{
}
}
this
.
_appendNode
(
"
a
"
{
target
:
"
_blank
"
class
:
options
.
urlClass
href
:
href
}
body
)
;
this
.
_appendTextNode
(
trailer
)
;
}
else
{
this
.
_appendTextNode
(
match
)
;
}
}
_createNode
:
function
(
tagName
attributes
value
=
"
"
)
{
let
node
=
this
.
doc
.
createElementNS
(
HTML_NS
tagName
)
;
let
attrs
=
Object
.
getOwnPropertyNames
(
attributes
)
;
for
(
let
attr
of
attrs
)
{
if
(
attributes
[
attr
]
)
{
node
.
setAttribute
(
attr
attributes
[
attr
]
)
;
}
}
if
(
value
)
{
let
textNode
=
this
.
doc
.
createTextNode
(
value
)
;
node
.
appendChild
(
textNode
)
;
}
return
node
;
}
_appendNode
:
function
(
tagName
attributes
value
=
"
"
)
{
let
node
=
this
.
_createNode
(
tagName
attributes
value
)
;
this
.
parsed
.
push
(
node
)
;
}
_appendTextNode
:
function
(
text
)
{
let
lastItem
=
this
.
parsed
[
this
.
parsed
.
length
-
1
]
;
if
(
typeof
lastItem
=
=
=
"
string
"
)
{
this
.
parsed
[
this
.
parsed
.
length
-
1
]
=
lastItem
+
text
;
}
else
{
this
.
parsed
.
push
(
text
)
;
}
}
_toDOM
:
function
(
)
{
let
frag
=
this
.
doc
.
createDocumentFragment
(
)
;
for
(
let
item
of
this
.
parsed
)
{
if
(
typeof
item
=
=
=
"
string
"
)
{
frag
.
appendChild
(
this
.
doc
.
createTextNode
(
item
)
)
;
}
else
{
frag
.
appendChild
(
item
)
;
}
}
this
.
parsed
.
length
=
0
;
return
frag
;
}
_mergeOptions
:
function
(
overrides
)
{
let
defaults
=
{
defaultColorType
:
true
angleClass
:
"
"
angleSwatchClass
:
"
"
bezierClass
:
"
"
bezierSwatchClass
:
"
"
colorClass
:
"
"
colorSwatchClass
:
"
"
filterSwatch
:
false
gridClass
:
"
"
shapeClass
:
"
"
supportsColor
:
false
urlClass
:
"
"
baseURI
:
undefined
}
;
for
(
let
item
in
overrides
)
{
defaults
[
item
]
=
overrides
[
item
]
;
}
return
defaults
;
}
}
;
module
.
exports
=
OutputParser
;
