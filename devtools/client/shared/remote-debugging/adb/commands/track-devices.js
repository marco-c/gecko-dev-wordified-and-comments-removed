"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
dumpn
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
setTimeout
}
=
require
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
const
{
adbProcess
}
=
require
(
"
devtools
/
client
/
shared
/
remote
-
debugging
/
adb
/
adb
-
process
"
)
;
const
client
=
require
(
"
devtools
/
client
/
shared
/
remote
-
debugging
/
adb
/
adb
-
client
"
)
;
const
ADB_STATUS_OFFLINE
=
"
offline
"
;
const
OKAY
=
0x59414b4f
;
class
TrackDevicesCommand
extends
EventEmitter
{
run
(
)
{
this
.
_waitForFirst
=
true
;
this
.
_devices
=
new
Map
(
)
;
this
.
_socket
=
client
.
connect
(
)
;
this
.
_socket
.
s
.
onopen
=
this
.
_onOpen
.
bind
(
this
)
;
this
.
_socket
.
s
.
onerror
=
this
.
_onError
.
bind
(
this
)
;
this
.
_socket
.
s
.
onclose
=
this
.
_onClose
.
bind
(
this
)
;
this
.
_socket
.
s
.
ondata
=
this
.
_onData
.
bind
(
this
)
;
}
stop
(
)
{
if
(
this
.
_socket
)
{
this
.
_socket
.
close
(
)
;
this
.
_socket
.
s
.
onopen
=
null
;
this
.
_socket
.
s
.
onerror
=
null
;
this
.
_socket
.
s
.
onclose
=
null
;
this
.
_socket
.
s
.
ondata
=
null
;
}
}
_onOpen
(
)
{
dumpn
(
"
trackDevices
onopen
"
)
;
const
req
=
client
.
createRequest
(
"
host
:
track
-
devices
"
)
;
this
.
_socket
.
send
(
req
)
;
}
_onError
(
event
)
{
dumpn
(
"
trackDevices
onerror
:
"
+
event
)
;
}
_onClose
(
)
{
dumpn
(
"
trackDevices
onclose
"
)
;
this
.
_disconnectAllDevices
(
)
;
setTimeout
(
(
)
=
>
{
if
(
adbProcess
.
ready
)
{
adbProcess
.
start
(
)
.
then
(
(
)
=
>
{
this
.
run
(
)
;
}
)
;
}
}
2000
)
;
}
_onData
(
event
)
{
dumpn
(
"
trackDevices
ondata
"
)
;
const
data
=
event
.
data
;
dumpn
(
"
length
=
"
+
data
.
byteLength
)
;
const
dec
=
new
TextDecoder
(
)
;
dumpn
(
dec
.
decode
(
new
Uint8Array
(
data
)
)
.
trim
(
)
)
;
if
(
this
.
_waitForFirst
)
{
if
(
!
client
.
checkResponse
(
data
OKAY
)
)
{
this
.
_socket
.
close
(
)
;
return
;
}
}
const
packet
=
client
.
unpackPacket
(
data
!
this
.
_waitForFirst
)
;
this
.
_waitForFirst
=
false
;
if
(
packet
.
data
=
=
"
"
)
{
this
.
_disconnectAllDevices
(
)
;
}
else
{
const
lines
=
packet
.
data
.
split
(
"
\
n
"
)
;
const
newDevices
=
new
Map
(
)
;
lines
.
forEach
(
function
(
line
)
{
if
(
line
.
length
=
=
0
)
{
return
;
}
const
[
deviceId
status
]
=
line
.
split
(
"
\
t
"
)
;
newDevices
.
set
(
deviceId
status
)
;
}
)
;
const
deviceIds
=
new
Set
(
[
.
.
.
this
.
_devices
.
keys
(
)
.
.
.
newDevices
.
keys
(
)
]
)
;
for
(
const
deviceId
of
deviceIds
)
{
const
currentStatus
=
this
.
_devices
.
get
(
deviceId
)
;
const
newStatus
=
newDevices
.
get
(
deviceId
)
;
this
.
_fireConnectionEventIfNeeded
(
deviceId
currentStatus
newStatus
)
;
}
this
.
_devices
=
newDevices
;
}
}
_disconnectAllDevices
(
)
{
if
(
this
.
_devices
.
size
=
=
=
0
)
{
this
.
emit
(
"
no
-
devices
-
detected
"
)
;
}
else
{
for
(
const
[
deviceId
status
]
of
this
.
_devices
.
entries
(
)
)
{
if
(
status
!
=
=
ADB_STATUS_OFFLINE
)
{
this
.
emit
(
"
device
-
disconnected
"
deviceId
)
;
}
}
}
this
.
_devices
=
new
Map
(
)
;
}
_fireConnectionEventIfNeeded
(
deviceId
currentStatus
newStatus
)
{
const
isCurrentOnline
=
!
!
(
currentStatus
&
&
currentStatus
!
=
=
ADB_STATUS_OFFLINE
)
;
const
isNewOnline
=
!
!
(
newStatus
&
&
newStatus
!
=
=
ADB_STATUS_OFFLINE
)
;
if
(
isCurrentOnline
=
=
=
isNewOnline
)
{
return
;
}
if
(
isNewOnline
)
{
this
.
emit
(
"
device
-
connected
"
deviceId
)
;
}
else
{
this
.
emit
(
"
device
-
disconnected
"
deviceId
)
;
}
}
}
exports
.
TrackDevicesCommand
=
TrackDevicesCommand
;
