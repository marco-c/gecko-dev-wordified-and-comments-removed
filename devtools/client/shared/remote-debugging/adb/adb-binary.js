"
use
strict
"
;
const
{
dumpn
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
ExtensionParent
"
"
resource
:
/
/
gre
/
modules
/
ExtensionParent
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
FileUtils
"
"
resource
:
/
/
gre
/
modules
/
FileUtils
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
lazy
"
NetUtil
"
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
loader
.
lazyGetter
(
this
"
UNPACKED_ROOT_PATH
"
(
)
=
>
{
return
PathUtils
.
join
(
PathUtils
.
localProfileDir
"
adb
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
EXTENSION_ID
"
(
)
=
>
{
return
Services
.
prefs
.
getCharPref
(
"
devtools
.
remote
.
adb
.
extensionID
"
)
;
}
)
;
loader
.
lazyGetter
(
this
"
ADB_BINARY_PATH
"
(
)
=
>
{
let
adbBinaryPath
=
PathUtils
.
join
(
UNPACKED_ROOT_PATH
"
adb
"
)
;
if
(
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
)
{
adbBinaryPath
+
=
"
.
exe
"
;
}
return
adbBinaryPath
;
}
)
;
const
MANIFEST
=
"
manifest
.
json
"
;
async
function
readFromExtension
(
fileUri
)
{
return
new
Promise
(
resolve
=
>
{
lazy
.
NetUtil
.
asyncFetch
(
{
uri
:
fileUri
loadUsingSystemPrincipal
:
true
}
input
=
>
{
try
{
const
string
=
lazy
.
NetUtil
.
readInputStreamToString
(
input
input
.
available
(
)
)
;
resolve
(
JSON
.
parse
(
string
)
)
;
}
catch
(
e
)
{
dumpn
(
Could
not
read
{
fileUri
}
in
the
extension
:
{
e
}
)
;
resolve
(
null
)
;
}
}
)
;
}
)
;
}
async
function
unpackFile
(
file
)
{
const
policy
=
lazy
.
ExtensionParent
.
WebExtensionPolicy
.
getByID
(
EXTENSION_ID
)
;
if
(
!
policy
)
{
return
;
}
const
basePath
=
file
.
substring
(
file
.
lastIndexOf
(
"
/
"
)
+
1
)
;
const
filePath
=
PathUtils
.
join
(
UNPACKED_ROOT_PATH
basePath
)
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
lazy
.
NetUtil
.
asyncFetch
(
{
uri
:
policy
.
getURL
(
file
)
loadUsingSystemPrincipal
:
true
}
input
=
>
{
try
{
const
outputFile
=
new
lazy
.
FileUtils
.
File
(
filePath
)
;
const
output
=
lazy
.
FileUtils
.
openAtomicFileOutputStream
(
outputFile
)
;
lazy
.
NetUtil
.
asyncCopy
(
input
output
resolve
)
;
}
catch
(
e
)
{
dumpn
(
Could
not
unpack
file
{
file
}
in
the
extension
:
{
e
}
)
;
reject
(
e
)
;
}
}
)
;
}
)
;
await
IOUtils
.
setPermissions
(
filePath
0o744
)
;
}
async
function
extractFiles
(
)
{
const
policy
=
lazy
.
ExtensionParent
.
WebExtensionPolicy
.
getByID
(
EXTENSION_ID
)
;
if
(
!
policy
)
{
return
false
;
}
const
uri
=
policy
.
getURL
(
"
adb
.
json
"
)
;
const
adbInfo
=
await
readFromExtension
(
uri
)
;
if
(
!
adbInfo
)
{
return
false
;
}
let
filesForAdb
;
try
{
let
architecture
=
Services
.
appinfo
.
XPCOMABI
.
split
(
"
-
"
)
[
0
]
;
if
(
architecture
=
=
=
"
aarch64
"
)
{
const
hasX86Binary
=
!
!
adbInfo
[
Services
.
appinfo
.
OS
]
.
x86
;
architecture
=
hasX86Binary
?
"
x86
"
:
"
x86_64
"
;
}
filesForAdb
=
adbInfo
[
Services
.
appinfo
.
OS
]
[
architecture
]
;
}
catch
(
e
)
{
return
false
;
}
filesForAdb
.
push
(
MANIFEST
)
;
await
IOUtils
.
makeDirectory
(
UNPACKED_ROOT_PATH
)
;
for
(
const
file
of
filesForAdb
)
{
try
{
await
unpackFile
(
file
)
;
}
catch
(
e
)
{
return
false
;
}
}
return
true
;
}
async
function
getManifestFromExtension
(
)
{
const
policy
=
lazy
.
ExtensionParent
.
WebExtensionPolicy
.
getByID
(
EXTENSION_ID
)
;
if
(
!
policy
)
{
return
null
;
}
const
manifestUri
=
policy
.
getURL
(
MANIFEST
)
;
return
readFromExtension
(
manifestUri
)
;
}
async
function
isManifestUnpacked
(
)
{
const
manifestPath
=
PathUtils
.
join
(
UNPACKED_ROOT_PATH
MANIFEST
)
;
return
IOUtils
.
exists
(
manifestPath
)
;
}
async
function
getManifestFromUnpacked
(
)
{
if
(
!
(
await
isManifestUnpacked
(
)
)
)
{
throw
new
Error
(
"
Manifest
doesn
'
t
exist
at
unpacked
path
"
)
;
}
const
manifestPath
=
PathUtils
.
join
(
UNPACKED_ROOT_PATH
MANIFEST
)
;
const
binary
=
await
IOUtils
.
read
(
manifestPath
)
;
const
json
=
new
TextDecoder
(
)
.
decode
(
binary
)
;
let
data
;
try
{
data
=
JSON
.
parse
(
json
)
;
}
catch
(
e
)
{
}
return
data
;
}
async
function
isUnpacked
(
)
{
if
(
!
(
await
isManifestUnpacked
(
)
)
)
{
dumpn
(
"
Needs
unpacking
no
manifest
found
"
)
;
return
false
;
}
const
manifestInExtension
=
await
getManifestFromExtension
(
)
;
const
unpackedManifest
=
await
getManifestFromUnpacked
(
)
;
if
(
manifestInExtension
.
version
!
=
unpackedManifest
.
version
)
{
dumpn
(
Needs
unpacking
extension
version
{
manifestInExtension
.
version
}
!
=
+
unpacked
version
{
unpackedManifest
.
version
}
)
;
return
false
;
}
dumpn
(
"
Already
unpacked
"
)
;
return
true
;
}
async
function
getFileForBinary
(
)
{
if
(
!
(
await
isUnpacked
(
)
)
&
&
!
(
await
extractFiles
(
)
)
)
{
return
null
;
}
const
file
=
new
lazy
.
FileUtils
.
File
(
ADB_BINARY_PATH
)
;
if
(
!
file
.
exists
(
)
)
{
return
null
;
}
return
file
;
}
exports
.
getFileForBinary
=
getFileForBinary
;
