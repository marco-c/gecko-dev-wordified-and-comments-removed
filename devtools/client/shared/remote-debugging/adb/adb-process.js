"
use
strict
"
;
const
{
dumpn
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
DevToolsUtils
.
js
"
)
;
const
EventEmitter
=
require
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
const
{
getFileForBinary
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
remote
-
debugging
/
adb
/
adb
-
binary
.
js
"
)
;
const
{
setTimeout
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
loader
.
lazyRequireGetter
(
this
"
runCommand
"
"
resource
:
/
/
devtools
/
client
/
shared
/
remote
-
debugging
/
adb
/
commands
/
index
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
check
"
"
resource
:
/
/
devtools
/
client
/
shared
/
remote
-
debugging
/
adb
/
adb
-
running
-
checker
.
js
"
true
)
;
async
function
waitUntil
(
predicate
retry
=
20
)
{
let
count
=
0
;
while
(
count
+
+
<
retry
)
{
if
(
await
predicate
(
)
)
{
return
true
;
}
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
100
)
)
;
}
return
false
;
}
class
AdbProcess
extends
EventEmitter
{
constructor
(
)
{
super
(
)
;
this
.
_ready
=
false
;
this
.
_didRunInitially
=
false
;
}
get
ready
(
)
{
return
this
.
_ready
;
}
_getAdbFile
(
)
{
if
(
this
.
_adbFilePromise
)
{
return
this
.
_adbFilePromise
;
}
this
.
_adbFilePromise
=
getFileForBinary
(
)
;
return
this
.
_adbFilePromise
;
}
async
_runProcess
(
process
params
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
process
.
runAsync
(
params
params
.
length
{
observe
(
subject
topic
data
)
{
switch
(
topic
)
{
case
"
process
-
finished
"
:
resolve
(
)
;
break
;
case
"
process
-
failed
"
:
reject
(
)
;
break
;
}
}
}
false
)
;
}
)
;
}
async
start
(
)
{
const
onSuccessfulStart
=
(
)
=
>
{
this
.
_ready
=
true
;
this
.
emit
(
"
adb
-
ready
"
)
;
}
;
const
isAdbRunning
=
await
check
(
)
;
if
(
isAdbRunning
)
{
dumpn
(
"
Found
ADB
process
running
not
restarting
"
)
;
onSuccessfulStart
(
)
;
return
;
}
dumpn
(
"
Didn
'
t
find
ADB
process
running
restarting
"
)
;
this
.
_didRunInitially
=
true
;
const
process
=
Cc
[
"
mozilla
.
org
/
process
/
util
;
1
"
]
.
createInstance
(
Ci
.
nsIProcess
)
;
const
adbFile
=
await
this
.
_getAdbFile
(
)
;
process
.
init
(
adbFile
)
;
process
.
startHidden
=
true
;
process
.
noShell
=
true
;
const
params
=
[
"
start
-
server
"
]
;
let
isStarted
=
false
;
try
{
await
this
.
_runProcess
(
process
params
)
;
isStarted
=
await
waitUntil
(
check
)
;
}
catch
(
e
)
{
}
if
(
isStarted
)
{
onSuccessfulStart
(
)
;
}
else
{
this
.
_ready
=
false
;
throw
new
Error
(
"
ADB
Process
didn
'
t
start
"
)
;
}
}
async
stop
(
)
{
if
(
!
this
.
_didRunInitially
)
{
return
;
}
await
this
.
kill
(
)
;
}
async
kill
(
)
{
try
{
await
runCommand
(
"
host
:
kill
"
)
;
}
catch
(
e
)
{
dumpn
(
"
Failed
to
send
host
:
kill
command
"
)
;
}
dumpn
(
"
adb
server
was
terminated
by
host
:
kill
"
)
;
this
.
_ready
=
false
;
this
.
_didRunInitially
=
false
;
}
}
exports
.
adbProcess
=
new
AdbProcess
(
)
;
