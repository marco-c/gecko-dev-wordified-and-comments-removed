"
use
strict
"
;
const
{
combineReducers
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
redux
"
)
;
function
makeStateBroadcaster
(
stillAliveFunc
)
{
const
listeners
=
{
}
;
let
enqueuedChanges
=
[
]
;
return
{
onChange
:
(
name
cb
)
=
>
{
if
(
!
listeners
[
name
]
)
{
listeners
[
name
]
=
[
]
;
}
listeners
[
name
]
.
push
(
cb
)
;
}
offChange
:
(
name
cb
)
=
>
{
listeners
[
name
]
=
listeners
[
name
]
.
filter
(
listener
=
>
listener
!
=
=
cb
)
;
}
emitChange
:
(
name
payload
)
=
>
{
enqueuedChanges
.
push
(
[
name
payload
]
)
;
}
subscribeToStore
:
store
=
>
{
store
.
subscribe
(
(
)
=
>
{
if
(
stillAliveFunc
(
)
)
{
enqueuedChanges
.
forEach
(
(
[
name
payload
]
)
=
>
{
if
(
listeners
[
name
]
)
{
let
payloadStr
=
payload
;
try
{
payloadStr
=
JSON
.
stringify
(
payload
)
;
}
catch
(
e
)
{
}
listeners
[
name
]
.
forEach
(
listener
=
>
{
listener
(
payload
)
}
)
;
}
}
)
;
enqueuedChanges
=
[
]
;
}
}
)
;
}
}
;
}
function
enhanceStoreWithBroadcaster
(
store
broadcaster
)
{
broadcaster
.
subscribeToStore
(
store
)
;
store
.
onChange
=
broadcaster
.
onChange
;
store
.
offChange
=
broadcaster
.
offChange
;
return
store
;
}
;
function
combineBroadcastingReducers
(
reducers
emitChange
)
{
function
wrapReduce
(
newReducers
key
)
{
newReducers
[
key
]
=
(
state
action
)
=
>
reducers
[
key
]
(
state
action
emitChange
)
;
return
newReducers
;
}
return
combineReducers
(
Object
.
keys
(
reducers
)
.
reduce
(
wrapReduce
Object
.
create
(
null
)
)
)
;
}
module
.
exports
=
{
makeStateBroadcaster
enhanceStoreWithBroadcaster
combineBroadcastingReducers
}
;
