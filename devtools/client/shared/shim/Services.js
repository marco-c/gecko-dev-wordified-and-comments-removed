"
use
strict
"
;
const
PREF_INVALID
=
0
;
const
PREF_STRING
=
32
;
const
PREF_INT
=
64
;
const
PREF_BOOL
=
128
;
const
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
=
"
nsPref
:
changed
"
;
const
PREFIX
=
"
Services
.
prefs
:
"
;
function
PrefBranch
(
parent
name
fullName
)
{
this
.
_parent
=
parent
;
this
.
_name
=
name
;
this
.
_fullName
=
fullName
;
this
.
_observers
=
{
}
;
this
.
_children
=
{
}
;
this
.
_defaultValue
=
null
;
this
.
_hasUserValue
=
false
;
this
.
_userValue
=
null
;
this
.
_type
=
PREF_INVALID
;
}
PrefBranch
.
prototype
=
{
PREF_INVALID
:
PREF_INVALID
PREF_STRING
:
PREF_STRING
PREF_INT
:
PREF_INT
PREF_BOOL
:
PREF_BOOL
get
root
(
)
{
return
this
.
_fullName
;
}
getPrefType
:
function
(
prefName
)
{
return
this
.
_findPref
(
prefName
)
.
_type
;
}
getBoolPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
_type
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
{
prefName
}
does
not
have
bool
type
)
;
}
return
thePref
.
_get
(
)
;
}
setBoolPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
non
-
bool
passed
to
setBoolPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
_type
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
{
prefName
}
does
not
have
bool
type
)
;
}
thePref
.
_set
(
value
)
;
}
getCharPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
_type
!
=
=
PREF_STRING
)
{
throw
new
Error
(
{
prefName
}
does
not
have
string
type
)
;
}
return
thePref
.
_get
(
)
;
}
setCharPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
string
"
)
{
throw
new
Error
(
"
non
-
string
passed
to
setCharPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
_type
!
=
=
PREF_STRING
)
{
throw
new
Error
(
{
prefName
}
does
not
have
string
type
)
;
}
thePref
.
_set
(
value
)
;
}
getIntPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
_type
!
=
=
PREF_INT
)
{
throw
new
Error
(
{
prefName
}
does
not
have
int
type
)
;
}
return
thePref
.
_get
(
)
;
}
setIntPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
number
"
)
{
throw
new
Error
(
"
non
-
number
passed
to
setIntPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
_type
!
=
=
PREF_INT
)
{
throw
new
Error
(
{
prefName
}
does
not
have
int
type
)
;
}
thePref
.
_set
(
value
)
;
}
clearUserPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
thePref
.
_clearUserValue
(
)
;
}
prefHasUserValue
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
return
thePref
.
_hasUserValue
;
}
addObserver
:
function
(
domain
observer
holdWeak
)
{
if
(
holdWeak
)
{
throw
new
Error
(
"
shim
prefs
only
supports
strong
observers
"
)
;
}
if
(
!
(
domain
in
this
.
_observers
)
)
{
this
.
_observers
[
domain
]
=
[
]
;
}
this
.
_observers
[
domain
]
.
push
(
observer
)
;
}
removeObserver
:
function
(
domain
observer
)
{
if
(
!
(
domain
in
this
.
_observers
)
)
{
return
;
}
let
index
=
this
.
_observers
[
domain
]
.
indexOf
(
observer
)
;
if
(
index
>
=
0
)
{
this
.
_observers
[
domain
]
.
splice
(
index
1
)
;
}
}
savePrefFile
:
function
(
file
)
{
if
(
file
)
{
throw
new
Error
(
"
shim
prefs
only
supports
null
file
in
savePrefFile
"
)
;
}
}
getBranch
:
function
(
prefRoot
)
{
if
(
!
prefRoot
)
{
return
this
;
}
if
(
prefRoot
.
endsWith
(
"
.
"
)
)
{
prefRoot
=
prefRoot
.
slice
(
0
-
1
)
;
}
return
this
.
_findPref
(
prefRoot
)
;
}
_get
:
function
(
)
{
if
(
this
.
_hasUserValue
)
{
return
this
.
_userValue
;
}
return
this
.
_defaultValue
;
}
_set
:
function
(
value
)
{
if
(
!
this
.
_hasUserValue
|
|
value
!
=
=
this
.
_userValue
)
{
this
.
_userValue
=
value
;
this
.
_hasUserValue
=
true
;
this
.
_saveAndNotify
(
)
;
}
}
_setDefault
:
function
(
value
)
{
if
(
this
.
_defaultValue
!
=
=
value
)
{
this
.
_defaultValue
=
value
;
if
(
!
this
.
_hasUserValue
)
{
this
.
_saveAndNotify
(
)
;
}
}
}
_clearUserValue
:
function
(
)
{
if
(
this
.
_hasUserValue
)
{
this
.
_userValue
=
null
;
this
.
_hasUserValue
=
false
;
this
.
_saveAndNotify
(
)
;
}
}
_saveAndNotify
:
function
(
)
{
let
store
=
{
type
:
this
.
_type
defaultValue
:
this
.
_defaultValue
hasUserValue
:
this
.
_hasUserValue
userValue
:
this
.
_userValue
}
;
localStorage
.
setItem
(
PREFIX
+
this
.
fullName
JSON
.
stringify
(
store
)
)
;
this
.
_parent
.
_notify
(
this
.
_name
)
;
}
_storageUpdated
:
function
(
type
userValue
hasUserValue
defaultValue
)
{
this
.
_type
=
type
;
this
.
_defaultValue
=
defaultValue
;
this
.
_hasUserValue
=
hasUserValue
;
this
.
_userValue
=
userValue
;
this
.
_parent
.
_notify
(
this
.
_name
)
;
}
_findPref
:
function
(
prefName
)
{
let
branchNames
=
prefName
.
split
(
"
.
"
)
;
let
branch
=
this
;
for
(
let
branchName
of
branchNames
)
{
branch
=
branch
.
_children
[
branchName
]
;
if
(
!
branch
)
{
throw
new
Error
(
"
could
not
find
pref
branch
"
+
prefName
)
;
}
}
return
branch
;
}
_notify
:
function
(
relativeName
)
{
for
(
let
domain
in
this
.
_observers
)
{
if
(
relativeName
=
=
=
domain
|
|
domain
=
=
=
"
"
|
|
(
domain
.
endsWith
(
"
.
"
)
&
&
relativeName
.
startsWith
(
domain
)
)
)
{
let
localList
=
this
.
_observers
[
domain
]
.
slice
(
)
;
for
(
let
observer
of
localList
)
{
try
{
observer
.
observe
(
this
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
relativeName
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
}
}
if
(
this
.
_parent
)
{
this
.
_parent
.
_notify
(
this
.
_name
+
"
.
"
+
relativeName
)
;
}
}
_createBranch
:
function
(
branchList
)
{
let
parent
=
this
;
for
(
let
branch
of
branchList
)
{
if
(
!
parent
.
_children
[
branch
]
)
{
parent
.
_children
[
branch
]
=
new
PrefBranch
(
parent
branch
parent
.
root
+
"
.
"
+
branch
)
;
}
parent
=
parent
.
_children
[
branch
]
;
}
return
parent
;
}
_findOrCreatePref
:
function
(
keyName
userValue
hasUserValue
defaultValue
init
=
false
)
{
let
branch
=
this
.
_createBranch
(
keyName
.
split
(
"
.
"
)
)
;
if
(
hasUserValue
&
&
typeof
(
userValue
)
!
=
=
typeof
(
defaultValue
)
)
{
throw
new
Error
(
"
inconsistent
values
when
creating
"
+
keyName
)
;
}
let
type
;
switch
(
typeof
(
defaultValue
)
)
{
case
"
boolean
"
:
type
=
PREF_BOOL
;
break
;
case
"
number
"
:
type
=
PREF_INT
;
break
;
case
"
string
"
:
type
=
PREF_STRING
;
break
;
default
:
throw
new
Error
(
"
unhandled
argument
type
:
"
+
typeof
(
defaultValue
)
)
;
}
if
(
init
|
|
branch
.
_type
=
=
=
PREF_INVALID
)
{
branch
.
_storageUpdated
(
type
userValue
hasUserValue
defaultValue
)
;
}
else
if
(
branch
.
_type
!
=
=
type
)
{
throw
new
Error
(
"
attempt
to
change
type
of
pref
"
+
keyName
)
;
}
return
branch
;
}
_onStorageChange
:
function
(
event
)
{
if
(
event
.
storageArea
!
=
=
localStorage
)
{
return
;
}
if
(
event
.
key
=
=
=
null
|
|
event
.
newValue
=
=
=
null
)
{
return
;
}
let
{
type
userValue
hasUserValue
defaultValue
}
=
JSON
.
parse
(
event
.
newValue
)
;
if
(
event
.
oldValue
=
=
=
null
)
{
this
.
_findOrCreatePref
(
event
.
key
userValue
hasUserValue
defaultValue
)
;
}
else
{
let
thePref
=
this
.
_findPref
(
event
.
key
)
;
thePref
.
_storageUpdated
(
type
userValue
hasUserValue
defaultValue
)
;
}
}
_initializeRoot
:
function
(
)
{
if
(
Services
.
_defaultPrefsEnabled
)
{
let
devtools
=
require
(
"
raw
!
prefs
!
devtools
/
client
/
preferences
/
devtools
"
)
;
eval
(
devtools
)
;
let
all
=
require
(
"
raw
!
prefs
!
modules
/
libpref
/
init
/
all
"
)
;
eval
(
all
)
;
}
for
(
let
i
=
0
;
i
<
localStorage
.
length
;
+
+
i
)
{
let
keyName
=
localStorage
.
key
(
i
)
;
if
(
keyName
.
startsWith
(
PREFIX
)
)
{
let
{
userValue
hasUserValue
defaultValue
}
=
JSON
.
parse
(
localStorage
.
getItem
(
keyName
)
)
;
this
.
_findOrCreatePref
(
keyName
.
slice
(
PREFIX
.
length
)
userValue
hasUserValue
defaultValue
true
)
;
}
}
this
.
_onStorageChange
=
this
.
_onStorageChange
.
bind
(
this
)
;
window
.
addEventListener
(
"
storage
"
this
.
_onStorageChange
)
;
}
}
;
const
Services
=
{
_prefs
:
null
_defaultPrefsEnabled
:
true
get
prefs
(
)
{
if
(
!
this
.
_prefs
)
{
this
.
_prefs
=
new
PrefBranch
(
null
"
"
"
"
)
;
this
.
_prefs
.
_initializeRoot
(
)
;
}
return
this
.
_prefs
;
}
appinfo
:
{
get
OS
(
)
{
const
os
=
window
.
navigator
.
userAgent
;
if
(
os
)
{
if
(
os
.
includes
(
"
Linux
"
)
)
{
return
"
Linux
"
;
}
else
if
(
os
.
includes
(
"
Windows
"
)
)
{
return
"
WINNT
"
;
}
else
if
(
os
.
includes
(
"
Mac
"
)
)
{
return
"
Darwin
"
;
}
}
return
"
Unknown
"
;
}
get
name
(
)
{
return
window
.
navigator
.
userAgent
;
}
get
version
(
)
{
return
window
.
navigator
.
appVersion
;
}
get
is64Bit
(
)
{
return
true
;
}
}
telemetry
:
{
getHistogramById
:
function
(
name
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
getKeyedHistogramById
:
function
(
name
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
}
focus
:
{
MOVEFOCUS_FORWARD
:
1
MOVEFOCUS_BACKWARD
:
2
get
focusedElement
(
)
{
if
(
!
document
.
hasFocus
(
)
)
{
return
null
;
}
return
document
.
activeElement
;
}
moveFocus
:
function
(
window
startElement
type
flags
)
{
if
(
flags
!
=
=
0
)
{
throw
new
Error
(
"
shim
Services
.
focus
.
moveFocus
only
accepts
flags
=
=
=
0
"
)
;
}
if
(
type
!
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
&
&
type
!
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
throw
new
Error
(
"
shim
Services
.
focus
.
moveFocus
only
supports
"
+
"
MOVEFOCUS_FORWARD
and
MOVEFOCUS_BACKWARD
"
)
;
}
if
(
!
startElement
)
{
startElement
=
document
.
activeElement
|
|
document
;
}
let
iter
=
document
.
createTreeWalker
(
document
NodeFilter
.
SHOW_ELEMENT
{
acceptNode
:
function
(
node
)
{
let
tabIndex
=
node
.
getAttribute
(
"
tabindex
"
)
;
if
(
tabIndex
=
=
=
"
-
1
"
)
{
return
NodeFilter
.
FILTER_SKIP
;
}
node
.
focus
(
)
;
if
(
document
.
activeElement
=
=
node
)
{
return
NodeFilter
.
FILTER_ACCEPT
;
}
return
NodeFilter
.
FILTER_SKIP
;
}
}
)
;
iter
.
currentNode
=
startElement
;
if
(
type
=
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
iter
.
nextNode
(
)
;
}
else
{
iter
.
previousNode
(
)
;
}
}
}
}
;
function
pref
(
name
value
)
{
let
thePref
=
Services
.
prefs
.
_findOrCreatePref
(
name
value
true
value
)
;
thePref
.
_setDefault
(
value
)
;
}
module
.
exports
=
Services
;
exports
.
pref
=
pref
;
