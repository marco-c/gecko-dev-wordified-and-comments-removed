"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
createNode
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
client
/
shared
/
l10n
"
)
;
const
STRINGS_URI
=
"
chrome
:
/
/
devtools
/
locale
/
animationinspector
.
properties
"
;
const
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
const
PLAYBACK_RATES
=
[
.
1
.
25
.
5
1
2
5
10
]
;
function
RateSelector
(
)
{
this
.
onRateChanged
=
this
.
onRateChanged
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
RateSelector
=
RateSelector
;
RateSelector
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
selectEl
=
createNode
(
{
parent
:
containerEl
nodeType
:
"
select
"
attributes
:
{
"
class
"
:
"
devtools
-
button
"
"
title
"
:
L10N
.
getStr
(
"
timeline
.
rateSelectorTooltip
"
)
}
}
)
;
this
.
selectEl
.
addEventListener
(
"
change
"
this
.
onRateChanged
)
;
}
destroy
:
function
(
)
{
this
.
selectEl
.
removeEventListener
(
"
change
"
this
.
onRateChanged
)
;
this
.
selectEl
.
remove
(
)
;
this
.
selectEl
=
null
;
}
getAnimationsRates
:
function
(
animations
)
{
return
sortedUnique
(
animations
.
map
(
a
=
>
a
.
state
.
playbackRate
)
)
;
}
getAllRates
:
function
(
animations
)
{
let
animationsRates
=
this
.
getAnimationsRates
(
animations
)
;
if
(
animationsRates
.
length
>
1
)
{
return
PLAYBACK_RATES
;
}
return
sortedUnique
(
PLAYBACK_RATES
.
concat
(
animationsRates
)
)
;
}
render
:
function
(
animations
)
{
let
allRates
=
this
.
getAnimationsRates
(
animations
)
;
let
hasOneRate
=
allRates
.
length
=
=
=
1
;
this
.
selectEl
.
innerHTML
=
"
"
;
if
(
!
hasOneRate
)
{
createNode
(
{
parent
:
this
.
selectEl
nodeType
:
"
option
"
attributes
:
{
value
:
"
"
selector
:
"
true
"
}
textContent
:
"
-
"
}
)
;
}
for
(
let
rate
of
this
.
getAllRates
(
animations
)
)
{
let
option
=
createNode
(
{
parent
:
this
.
selectEl
nodeType
:
"
option
"
attributes
:
{
value
:
rate
}
textContent
:
L10N
.
getFormatStr
(
"
player
.
playbackRateLabel
"
rate
)
}
)
;
if
(
hasOneRate
&
&
rate
=
=
=
allRates
[
0
]
)
{
option
.
setAttribute
(
"
selected
"
"
true
"
)
;
}
}
}
onRateChanged
:
function
(
)
{
let
rate
=
parseFloat
(
this
.
selectEl
.
value
)
;
if
(
!
isNaN
(
rate
)
)
{
this
.
emit
(
"
rate
-
changed
"
rate
)
;
}
}
}
;
let
sortedUnique
=
arr
=
>
[
.
.
.
new
Set
(
arr
)
]
.
sort
(
(
a
b
)
=
>
a
>
b
)
;
