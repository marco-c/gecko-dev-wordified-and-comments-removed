"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
createNode
findOptimalTimeInterval
TimeScale
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
AnimationDetails
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
animation
-
details
"
)
;
const
{
AnimationTargetNode
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
animation
-
target
-
node
"
)
;
const
{
AnimationTimeBlock
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
animation
-
time
-
block
"
)
;
const
TIME_GRADUATION_MIN_SPACING
=
40
;
const
TIMELINE_BACKGROUND_RESIZE_DEBOUNCE_TIMER
=
50
;
function
AnimationsTimeline
(
inspector
serverTraits
)
{
this
.
animations
=
[
]
;
this
.
targetNodes
=
[
]
;
this
.
timeBlocks
=
[
]
;
this
.
details
=
[
]
;
this
.
inspector
=
inspector
;
this
.
serverTraits
=
serverTraits
;
this
.
onAnimationStateChanged
=
this
.
onAnimationStateChanged
.
bind
(
this
)
;
this
.
onScrubberMouseDown
=
this
.
onScrubberMouseDown
.
bind
(
this
)
;
this
.
onScrubberMouseUp
=
this
.
onScrubberMouseUp
.
bind
(
this
)
;
this
.
onScrubberMouseOut
=
this
.
onScrubberMouseOut
.
bind
(
this
)
;
this
.
onScrubberMouseMove
=
this
.
onScrubberMouseMove
.
bind
(
this
)
;
this
.
onAnimationSelected
=
this
.
onAnimationSelected
.
bind
(
this
)
;
this
.
onWindowResize
=
this
.
onWindowResize
.
bind
(
this
)
;
this
.
onFrameSelected
=
this
.
onFrameSelected
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
AnimationsTimeline
=
AnimationsTimeline
;
AnimationsTimeline
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
win
=
containerEl
.
ownerDocument
.
defaultView
;
this
.
rootWrapperEl
=
createNode
(
{
parent
:
containerEl
attributes
:
{
"
class
"
:
"
animation
-
timeline
"
}
}
)
;
let
scrubberContainer
=
createNode
(
{
parent
:
this
.
rootWrapperEl
attributes
:
{
"
class
"
:
"
scrubber
-
wrapper
"
}
}
)
;
this
.
scrubberEl
=
createNode
(
{
parent
:
scrubberContainer
attributes
:
{
"
class
"
:
"
scrubber
"
}
}
)
;
this
.
scrubberHandleEl
=
createNode
(
{
parent
:
this
.
scrubberEl
attributes
:
{
"
class
"
:
"
scrubber
-
handle
"
}
}
)
;
this
.
scrubberHandleEl
.
addEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
headerWrapper
=
createNode
(
{
parent
:
this
.
rootWrapperEl
attributes
:
{
"
class
"
:
"
header
-
wrapper
"
}
}
)
;
this
.
timeHeaderEl
=
createNode
(
{
parent
:
this
.
headerWrapper
attributes
:
{
"
class
"
:
"
time
-
header
track
-
container
"
}
}
)
;
this
.
timeHeaderEl
.
addEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
timeTickEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
attributes
:
{
"
class
"
:
"
time
-
body
track
-
container
"
}
}
)
;
this
.
animationsEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
nodeType
:
"
ul
"
attributes
:
{
"
class
"
:
"
animations
"
}
}
)
;
this
.
win
.
addEventListener
(
"
resize
"
this
.
onWindowResize
)
;
}
destroy
:
function
(
)
{
this
.
stopAnimatingScrubber
(
)
;
this
.
unrender
(
)
;
this
.
win
.
removeEventListener
(
"
resize
"
this
.
onWindowResize
)
;
this
.
timeHeaderEl
.
removeEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
scrubberHandleEl
.
removeEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
rootWrapperEl
.
remove
(
)
;
this
.
animations
=
[
]
;
this
.
rootWrapperEl
=
null
;
this
.
timeHeaderEl
=
null
;
this
.
animationsEl
=
null
;
this
.
scrubberEl
=
null
;
this
.
scrubberHandleEl
=
null
;
this
.
win
=
null
;
this
.
inspector
=
null
;
this
.
serverTraits
=
null
;
}
destroySubComponents
:
function
(
name
handlers
=
[
]
)
{
for
(
let
component
of
this
[
name
]
)
{
for
(
let
{
event
fn
}
of
handlers
)
{
component
.
off
(
event
fn
)
;
}
component
.
destroy
(
)
;
}
this
[
name
]
=
[
]
;
}
unrender
:
function
(
)
{
for
(
let
animation
of
this
.
animations
)
{
animation
.
off
(
"
changed
"
this
.
onAnimationStateChanged
)
;
}
this
.
stopAnimatingScrubber
(
)
;
TimeScale
.
reset
(
)
;
this
.
destroySubComponents
(
"
targetNodes
"
)
;
this
.
destroySubComponents
(
"
timeBlocks
"
)
;
this
.
destroySubComponents
(
"
details
"
[
{
event
:
"
frame
-
selected
"
fn
:
this
.
onFrameSelected
}
]
)
;
this
.
animationsEl
.
innerHTML
=
"
"
;
}
onWindowResize
:
function
(
)
{
if
(
this
.
rootWrapperEl
.
offsetWidth
=
=
=
0
)
{
return
;
}
if
(
this
.
windowResizeTimer
)
{
this
.
win
.
clearTimeout
(
this
.
windowResizeTimer
)
;
}
this
.
windowResizeTimer
=
this
.
win
.
setTimeout
(
(
)
=
>
{
this
.
drawHeaderAndBackground
(
)
;
}
TIMELINE_BACKGROUND_RESIZE_DEBOUNCE_TIMER
)
;
}
onAnimationSelected
:
function
(
e
animation
)
{
let
index
=
this
.
animations
.
indexOf
(
animation
)
;
if
(
index
=
=
=
-
1
)
{
return
;
}
let
el
=
this
.
rootWrapperEl
;
let
animationEl
=
el
.
querySelectorAll
(
"
.
animation
"
)
[
index
]
;
let
propsEl
=
el
.
querySelectorAll
(
"
.
animated
-
properties
"
)
[
index
]
;
animationEl
.
classList
.
toggle
(
"
selected
"
)
;
propsEl
.
classList
.
toggle
(
"
selected
"
)
;
if
(
animationEl
.
classList
.
contains
(
"
selected
"
)
)
{
this
.
details
[
index
]
.
render
(
animation
)
;
this
.
emit
(
"
animation
-
selected
"
animation
)
;
}
else
{
this
.
emit
(
"
animation
-
unselected
"
animation
)
;
}
}
onFrameSelected
:
function
(
e
{
x
}
)
{
this
.
moveScrubberTo
(
x
true
)
;
}
onScrubberMouseDown
:
function
(
e
)
{
this
.
moveScrubberTo
(
e
.
pageX
)
;
this
.
win
.
addEventListener
(
"
mouseup
"
this
.
onScrubberMouseUp
)
;
this
.
win
.
addEventListener
(
"
mouseout
"
this
.
onScrubberMouseOut
)
;
this
.
win
.
addEventListener
(
"
mousemove
"
this
.
onScrubberMouseMove
)
;
e
.
preventDefault
(
)
;
}
onScrubberMouseUp
:
function
(
)
{
this
.
cancelTimeHeaderDragging
(
)
;
}
onScrubberMouseOut
:
function
(
e
)
{
if
(
!
this
.
win
.
document
.
contains
(
e
.
relatedTarget
)
)
{
this
.
cancelTimeHeaderDragging
(
)
;
}
}
cancelTimeHeaderDragging
:
function
(
)
{
this
.
win
.
removeEventListener
(
"
mouseup
"
this
.
onScrubberMouseUp
)
;
this
.
win
.
removeEventListener
(
"
mouseout
"
this
.
onScrubberMouseOut
)
;
this
.
win
.
removeEventListener
(
"
mousemove
"
this
.
onScrubberMouseMove
)
;
}
onScrubberMouseMove
:
function
(
e
)
{
this
.
moveScrubberTo
(
e
.
pageX
)
;
}
moveScrubberTo
:
function
(
pageX
noOffset
)
{
this
.
stopAnimatingScrubber
(
)
;
let
offset
=
pageX
;
if
(
!
noOffset
)
{
offset
-
=
this
.
timeHeaderEl
.
offsetLeft
;
}
offset
=
offset
*
100
/
this
.
timeHeaderEl
.
offsetWidth
;
if
(
offset
<
0
)
{
offset
=
0
;
}
this
.
scrubberEl
.
style
.
left
=
offset
+
"
%
"
;
let
time
=
TimeScale
.
distanceToRelativeTime
(
offset
)
;
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
true
isMoving
:
false
isUserDrag
:
true
time
:
time
}
)
;
}
getCompositorStatusClassName
:
function
(
state
)
{
let
className
=
state
.
isRunningOnCompositor
?
"
fast
-
track
"
:
"
"
;
if
(
state
.
isRunningOnCompositor
&
&
state
.
propertyState
)
{
className
+
=
state
.
propertyState
.
some
(
propState
=
>
!
propState
.
runningOnCompositor
)
?
"
some
-
properties
"
:
"
all
-
properties
"
;
}
return
className
;
}
render
:
function
(
animations
documentCurrentTime
)
{
this
.
unrender
(
)
;
this
.
animations
=
animations
;
if
(
!
this
.
animations
.
length
)
{
return
;
}
for
(
let
{
state
}
of
animations
)
{
TimeScale
.
addAnimation
(
state
)
;
}
this
.
drawHeaderAndBackground
(
)
;
for
(
let
animation
of
this
.
animations
)
{
animation
.
on
(
"
changed
"
this
.
onAnimationStateChanged
)
;
let
animationEl
=
createNode
(
{
parent
:
this
.
animationsEl
nodeType
:
"
li
"
attributes
:
{
"
class
"
:
"
animation
"
+
animation
.
state
.
type
+
this
.
getCompositorStatusClassName
(
animation
.
state
)
}
}
)
;
let
detailsEl
=
createNode
(
{
parent
:
this
.
animationsEl
nodeType
:
"
li
"
attributes
:
{
"
class
"
:
"
animated
-
properties
"
+
animation
.
state
.
type
}
}
)
;
let
details
=
new
AnimationDetails
(
this
.
serverTraits
)
;
details
.
init
(
detailsEl
)
;
details
.
on
(
"
frame
-
selected
"
this
.
onFrameSelected
)
;
this
.
details
.
push
(
details
)
;
let
animatedNodeEl
=
createNode
(
{
parent
:
animationEl
attributes
:
{
"
class
"
:
"
target
"
}
}
)
;
let
targetNode
=
new
AnimationTargetNode
(
this
.
inspector
{
compact
:
true
}
)
;
targetNode
.
init
(
animatedNodeEl
)
;
targetNode
.
render
(
animation
)
;
this
.
targetNodes
.
push
(
targetNode
)
;
let
timeBlockEl
=
createNode
(
{
parent
:
animationEl
attributes
:
{
"
class
"
:
"
time
-
block
track
-
container
"
}
}
)
;
let
timeBlock
=
new
AnimationTimeBlock
(
)
;
timeBlock
.
init
(
timeBlockEl
)
;
timeBlock
.
render
(
animation
)
;
this
.
timeBlocks
.
push
(
timeBlock
)
;
timeBlock
.
on
(
"
selected
"
this
.
onAnimationSelected
)
;
}
if
(
!
documentCurrentTime
)
{
this
.
scrubberEl
.
style
.
display
=
"
none
"
;
}
else
{
this
.
scrubberEl
.
style
.
display
=
"
block
"
;
this
.
startAnimatingScrubber
(
this
.
wasRewound
(
)
?
TimeScale
.
minStartTime
:
documentCurrentTime
)
;
}
}
isAtLeastOneAnimationPlaying
:
function
(
)
{
return
this
.
animations
.
some
(
(
{
state
}
)
=
>
state
.
playState
=
=
=
"
running
"
)
;
}
wasRewound
:
function
(
)
{
return
!
this
.
isAtLeastOneAnimationPlaying
(
)
&
&
this
.
animations
.
every
(
(
{
state
}
)
=
>
state
.
currentTime
=
=
=
0
)
;
}
hasInfiniteAnimations
:
function
(
)
{
return
this
.
animations
.
some
(
(
{
state
}
)
=
>
!
state
.
iterationCount
)
;
}
startAnimatingScrubber
:
function
(
time
)
{
let
isOutOfBounds
=
time
<
TimeScale
.
minStartTime
|
|
time
>
TimeScale
.
maxEndTime
;
let
isAllPaused
=
!
this
.
isAtLeastOneAnimationPlaying
(
)
;
let
hasInfinite
=
this
.
hasInfiniteAnimations
(
)
;
let
x
=
TimeScale
.
startTimeToDistance
(
time
)
;
if
(
x
>
100
&
&
!
hasInfinite
)
{
x
=
100
;
}
this
.
scrubberEl
.
style
.
left
=
x
+
"
%
"
;
if
(
isAllPaused
|
|
(
isOutOfBounds
&
&
!
hasInfinite
)
)
{
this
.
stopAnimatingScrubber
(
)
;
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
!
this
.
isAtLeastOneAnimationPlaying
(
)
isMoving
:
false
isUserDrag
:
false
time
:
TimeScale
.
distanceToRelativeTime
(
x
)
}
)
;
return
;
}
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
false
isMoving
:
true
isUserDrag
:
false
time
:
TimeScale
.
distanceToRelativeTime
(
x
)
}
)
;
let
now
=
this
.
win
.
performance
.
now
(
)
;
this
.
rafID
=
this
.
win
.
requestAnimationFrame
(
(
)
=
>
{
if
(
!
this
.
rafID
)
{
return
;
}
this
.
startAnimatingScrubber
(
time
+
this
.
win
.
performance
.
now
(
)
-
now
)
;
}
)
;
}
stopAnimatingScrubber
:
function
(
)
{
if
(
this
.
rafID
)
{
this
.
win
.
cancelAnimationFrame
(
this
.
rafID
)
;
this
.
rafID
=
null
;
}
}
onAnimationStateChanged
:
function
(
)
{
this
.
render
(
this
.
animations
)
;
}
drawHeaderAndBackground
:
function
(
)
{
let
width
=
this
.
timeHeaderEl
.
offsetWidth
;
let
animationDuration
=
TimeScale
.
maxEndTime
-
TimeScale
.
minStartTime
;
let
minTimeInterval
=
TIME_GRADUATION_MIN_SPACING
*
animationDuration
/
width
;
let
intervalLength
=
findOptimalTimeInterval
(
minTimeInterval
)
;
let
intervalWidth
=
intervalLength
*
width
/
animationDuration
;
this
.
timeHeaderEl
.
innerHTML
=
"
"
;
this
.
timeTickEl
.
innerHTML
=
"
"
;
for
(
let
i
=
0
;
i
<
=
width
/
intervalWidth
;
i
+
+
)
{
let
pos
=
100
*
i
*
intervalWidth
/
width
;
createNode
(
{
parent
:
this
.
timeHeaderEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
header
-
item
"
"
style
"
:
left
:
{
pos
}
%
}
textContent
:
TimeScale
.
formatTime
(
TimeScale
.
distanceToRelativeTime
(
pos
)
)
}
)
;
createNode
(
{
parent
:
this
.
timeTickEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
time
-
tick
"
"
style
"
:
left
:
{
pos
}
%
}
}
)
;
}
}
}
;
