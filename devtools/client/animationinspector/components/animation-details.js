"
use
strict
"
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
createNode
TimeScale
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
Keyframes
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
keyframes
"
)
;
function
AnimationDetails
(
serverTraits
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
onFrameSelected
=
this
.
onFrameSelected
.
bind
(
this
)
;
this
.
keyframeComponents
=
[
]
;
this
.
serverTraits
=
serverTraits
;
}
exports
.
AnimationDetails
=
AnimationDetails
;
AnimationDetails
.
prototype
=
{
NON_PROPERTIES
:
[
"
easing
"
"
composite
"
"
computedOffset
"
"
offset
"
"
simulateComputeValuesFailure
"
]
init
:
function
(
containerEl
)
{
this
.
containerEl
=
containerEl
;
}
destroy
:
function
(
)
{
this
.
unrender
(
)
;
this
.
containerEl
=
null
;
this
.
serverTraits
=
null
;
}
unrender
:
function
(
)
{
for
(
let
component
of
this
.
keyframeComponents
)
{
component
.
off
(
"
frame
-
selected
"
this
.
onFrameSelected
)
;
component
.
destroy
(
)
;
}
this
.
keyframeComponents
=
[
]
;
while
(
this
.
containerEl
.
firstChild
)
{
this
.
containerEl
.
firstChild
.
remove
(
)
;
}
}
getPerfDataForProperty
:
function
(
animation
propertyName
)
{
let
warning
=
"
"
;
let
className
=
"
"
;
if
(
animation
.
state
.
propertyState
)
{
let
isRunningOnCompositor
;
for
(
let
propState
of
animation
.
state
.
propertyState
)
{
if
(
propState
.
property
=
=
propertyName
)
{
isRunningOnCompositor
=
propState
.
runningOnCompositor
;
if
(
typeof
propState
.
warning
!
=
"
undefined
"
)
{
warning
=
propState
.
warning
;
}
break
;
}
}
if
(
isRunningOnCompositor
&
&
warning
=
=
"
"
)
{
className
=
"
oncompositor
"
;
}
else
if
(
!
isRunningOnCompositor
&
&
warning
!
=
"
"
)
{
className
=
"
warning
"
;
}
}
return
{
className
warning
}
;
}
getTracks
:
Task
.
async
(
function
*
(
)
{
let
tracks
=
{
}
;
if
(
this
.
serverTraits
.
hasGetProperties
)
{
let
properties
=
yield
this
.
animation
.
getProperties
(
)
;
for
(
let
{
name
values
}
of
properties
)
{
if
(
!
tracks
[
name
]
)
{
tracks
[
name
]
=
[
]
;
}
for
(
let
{
value
offset
easing
distance
}
of
values
)
{
distance
=
distance
?
distance
:
0
;
tracks
[
name
]
.
push
(
{
value
offset
easing
distance
}
)
;
}
}
}
else
{
let
frames
=
yield
this
.
animation
.
getFrames
(
)
;
for
(
let
frame
of
frames
)
{
for
(
let
name
in
frame
)
{
if
(
this
.
NON_PROPERTIES
.
indexOf
(
name
)
!
=
-
1
)
{
continue
;
}
const
propertyCSSName
=
getCssPropertyName
(
name
)
;
if
(
!
tracks
[
propertyCSSName
]
)
{
tracks
[
propertyCSSName
]
=
[
]
;
}
tracks
[
propertyCSSName
]
.
push
(
{
value
:
frame
[
name
]
offset
:
frame
.
computedOffset
easing
:
frame
.
easing
distance
:
0
}
)
;
}
}
}
return
tracks
;
}
)
getAnimationTypes
:
Task
.
async
(
function
*
(
propertyNames
)
{
if
(
this
.
serverTraits
.
hasGetAnimationTypes
)
{
return
yield
this
.
animation
.
getAnimationTypes
(
propertyNames
)
;
}
const
animationTypes
=
{
}
;
propertyNames
.
forEach
(
propertyName
=
>
{
animationTypes
[
propertyName
]
=
"
none
"
;
}
)
;
return
Promise
.
resolve
(
animationTypes
)
;
}
)
render
:
Task
.
async
(
function
*
(
animation
)
{
this
.
unrender
(
)
;
if
(
!
animation
)
{
return
;
}
this
.
animation
=
animation
;
if
(
!
this
.
containerEl
|
|
this
.
animation
!
=
=
animation
)
{
return
;
}
this
.
tracks
=
yield
this
.
getTracks
(
animation
this
.
serverTraits
)
;
const
animationTypes
=
yield
this
.
getAnimationTypes
(
Object
.
keys
(
this
.
tracks
)
)
;
for
(
let
propertyName
in
this
.
tracks
)
{
let
line
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
property
"
}
}
)
;
let
{
warning
className
}
=
this
.
getPerfDataForProperty
(
animation
propertyName
)
;
createNode
(
{
parent
:
createNode
(
{
parent
:
line
attributes
:
{
"
class
"
:
"
name
"
}
}
)
textContent
:
getCssPropertyName
(
propertyName
)
attributes
:
{
"
title
"
:
warning
"
class
"
:
className
}
}
)
;
let
framesWrapperEl
=
createNode
(
{
parent
:
line
attributes
:
{
"
class
"
:
"
track
-
container
"
}
}
)
;
let
framesEl
=
createNode
(
{
parent
:
framesWrapperEl
attributes
:
{
"
class
"
:
"
frames
"
}
}
)
;
let
{
x
w
}
=
TimeScale
.
getAnimationDimensions
(
animation
)
;
framesEl
.
style
.
left
=
{
x
}
%
;
framesEl
.
style
.
width
=
{
w
}
%
;
let
keyframesComponent
=
new
Keyframes
(
)
;
keyframesComponent
.
init
(
framesEl
)
;
keyframesComponent
.
render
(
{
keyframes
:
this
.
tracks
[
propertyName
]
propertyName
:
propertyName
animation
:
animation
animationType
:
animationTypes
[
propertyName
]
}
)
;
keyframesComponent
.
on
(
"
frame
-
selected
"
this
.
onFrameSelected
)
;
this
.
keyframeComponents
.
push
(
keyframesComponent
)
;
}
this
.
emit
(
"
animation
-
detail
-
rendering
-
completed
"
)
;
}
)
onFrameSelected
:
function
(
e
args
)
{
this
.
emit
(
e
args
)
;
}
}
;
function
getCssPropertyName
(
jsPropertyName
)
{
return
jsPropertyName
.
replace
(
/
[
A
-
Z
]
/
g
"
-
&
"
)
.
toLowerCase
(
)
;
}
exports
.
getCssPropertyName
=
getCssPropertyName
;
