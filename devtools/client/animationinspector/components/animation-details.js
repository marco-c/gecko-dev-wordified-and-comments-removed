"
use
strict
"
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
createNode
getCssPropertyName
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
Keyframes
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
keyframes
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
animationinspector
.
properties
"
)
;
function
AnimationDetails
(
serverTraits
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
keyframeComponents
=
[
]
;
this
.
serverTraits
=
serverTraits
;
}
exports
.
AnimationDetails
=
AnimationDetails
;
AnimationDetails
.
prototype
=
{
NON_PROPERTIES
:
[
"
easing
"
"
composite
"
"
computedOffset
"
"
offset
"
"
simulateComputeValuesFailure
"
]
init
:
function
(
containerEl
)
{
this
.
containerEl
=
containerEl
;
}
destroy
:
function
(
)
{
this
.
unrender
(
)
;
this
.
containerEl
=
null
;
this
.
serverTraits
=
null
;
this
.
progressIndicatorEl
=
null
;
}
unrender
:
function
(
)
{
for
(
let
component
of
this
.
keyframeComponents
)
{
component
.
destroy
(
)
;
}
this
.
keyframeComponents
=
[
]
;
while
(
this
.
containerEl
.
firstChild
)
{
this
.
containerEl
.
firstChild
.
remove
(
)
;
}
}
getPerfDataForProperty
:
function
(
animation
propertyName
)
{
let
warning
=
"
"
;
let
className
=
"
"
;
if
(
animation
.
state
.
propertyState
)
{
let
isRunningOnCompositor
;
for
(
let
propState
of
animation
.
state
.
propertyState
)
{
if
(
propState
.
property
=
=
propertyName
)
{
isRunningOnCompositor
=
propState
.
runningOnCompositor
;
if
(
typeof
propState
.
warning
!
=
"
undefined
"
)
{
warning
=
propState
.
warning
;
}
break
;
}
}
if
(
isRunningOnCompositor
&
&
warning
=
=
"
"
)
{
className
=
"
oncompositor
"
;
}
else
if
(
!
isRunningOnCompositor
&
&
warning
!
=
"
"
)
{
className
=
"
warning
"
;
}
}
return
{
className
warning
}
;
}
getAnimationTypes
:
Task
.
async
(
function
*
(
propertyNames
)
{
if
(
this
.
serverTraits
.
hasGetAnimationTypes
)
{
return
yield
this
.
animation
.
getAnimationTypes
(
propertyNames
)
;
}
const
animationTypes
=
{
}
;
propertyNames
.
forEach
(
propertyName
=
>
{
animationTypes
[
propertyName
]
=
"
none
"
;
}
)
;
return
Promise
.
resolve
(
animationTypes
)
;
}
)
render
:
Task
.
async
(
function
*
(
animation
tracks
)
{
this
.
unrender
(
)
;
if
(
!
animation
)
{
return
;
}
this
.
animation
=
animation
;
this
.
tracks
=
tracks
;
if
(
!
this
.
containerEl
|
|
this
.
animation
!
=
=
animation
)
{
return
;
}
const
animationTypes
=
yield
this
.
getAnimationTypes
(
Object
.
keys
(
this
.
tracks
)
)
;
this
.
renderProgressIndicator
(
)
;
this
.
renderAnimatedPropertiesHeader
(
)
;
this
.
renderAnimatedPropertiesBody
(
animationTypes
)
;
const
timing
=
Object
.
assign
(
{
}
animation
.
state
{
iterations
:
animation
.
state
.
iterationCount
?
animation
.
state
.
iterationCount
:
Infinity
}
)
;
this
.
dummyAnimation
=
new
this
.
win
.
Animation
(
new
this
.
win
.
KeyframeEffect
(
null
null
timing
)
null
)
;
}
)
renderAnimatedPropertiesHeader
:
function
(
)
{
const
headerEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
animated
-
properties
-
header
"
}
}
)
;
const
progressTickContainerEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
progress
-
tick
-
container
track
-
container
"
}
}
)
;
const
headerLabelContainerEl
=
createNode
(
{
parent
:
headerEl
attributes
:
{
"
class
"
:
"
track
-
container
"
}
}
)
;
for
(
let
label
of
[
L10N
.
getFormatStr
(
"
detail
.
propertiesHeader
.
percentage
"
0
)
L10N
.
getFormatStr
(
"
detail
.
propertiesHeader
.
percentage
"
50
)
L10N
.
getFormatStr
(
"
detail
.
propertiesHeader
.
percentage
"
100
)
]
)
{
createNode
(
{
parent
:
progressTickContainerEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
progress
-
tick
"
}
}
)
;
createNode
(
{
parent
:
headerLabelContainerEl
nodeType
:
"
label
"
attributes
:
{
"
class
"
:
"
header
-
item
"
}
textContent
:
label
}
)
;
}
}
renderAnimatedPropertiesBody
:
function
(
animationTypes
)
{
const
bodyEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
animated
-
properties
-
body
"
}
}
)
;
const
propertyNames
=
[
]
;
const
unchangedPropertyNames
=
[
]
;
for
(
let
propertyName
in
this
.
tracks
)
{
if
(
!
isUnchangedProperty
(
this
.
tracks
[
propertyName
]
)
)
{
propertyNames
.
push
(
propertyName
)
;
}
else
{
unchangedPropertyNames
.
push
(
propertyName
)
;
}
}
Array
.
prototype
.
push
.
apply
(
propertyNames
unchangedPropertyNames
)
;
for
(
let
propertyName
of
propertyNames
)
{
let
line
=
createNode
(
{
parent
:
bodyEl
attributes
:
{
"
class
"
:
"
property
"
}
}
)
;
if
(
unchangedPropertyNames
.
includes
(
propertyName
)
)
{
line
.
classList
.
add
(
"
unchanged
"
)
;
}
let
{
warning
className
}
=
this
.
getPerfDataForProperty
(
this
.
animation
propertyName
)
;
createNode
(
{
parent
:
createNode
(
{
parent
:
line
attributes
:
{
"
class
"
:
"
name
"
}
}
)
textContent
:
getCssPropertyName
(
propertyName
)
attributes
:
{
"
title
"
:
warning
"
class
"
:
className
}
}
)
;
let
framesWrapperEl
=
createNode
(
{
parent
:
line
attributes
:
{
"
class
"
:
"
track
-
container
"
}
}
)
;
let
framesEl
=
createNode
(
{
parent
:
framesWrapperEl
attributes
:
{
"
class
"
:
"
frames
"
}
}
)
;
let
keyframesComponent
=
new
Keyframes
(
)
;
keyframesComponent
.
init
(
framesEl
)
;
keyframesComponent
.
render
(
{
keyframes
:
this
.
tracks
[
propertyName
]
propertyName
:
propertyName
animation
:
this
.
animation
animationType
:
animationTypes
[
propertyName
]
}
)
;
this
.
keyframeComponents
.
push
(
keyframesComponent
)
;
}
}
renderProgressIndicator
:
function
(
)
{
const
progressIndicatorWrapperEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
track
-
container
progress
-
indicator
-
wrapper
"
}
}
)
;
this
.
progressIndicatorEl
=
createNode
(
{
parent
:
progressIndicatorWrapperEl
attributes
:
{
"
class
"
:
"
progress
-
indicator
"
}
}
)
;
createNode
(
{
parent
:
this
.
progressIndicatorEl
attributes
:
{
"
class
"
:
"
progress
-
indicator
-
shape
"
}
}
)
;
}
indicateProgress
:
function
(
time
)
{
if
(
!
this
.
progressIndicatorEl
)
{
return
;
}
const
startTime
=
this
.
animation
.
state
.
previousStartTime
|
|
0
;
this
.
dummyAnimation
.
currentTime
=
(
time
-
startTime
)
*
this
.
animation
.
state
.
playbackRate
;
this
.
progressIndicatorEl
.
style
.
left
=
{
this
.
dummyAnimation
.
effect
.
getComputedTiming
(
)
.
progress
*
100
}
%
;
}
get
win
(
)
{
return
this
.
containerEl
.
ownerDocument
.
defaultView
;
}
}
;
function
isUnchangedProperty
(
values
)
{
const
firstValue
=
values
[
0
]
.
value
;
for
(
let
i
=
1
;
i
<
values
.
length
;
i
+
+
)
{
if
(
values
[
i
]
.
value
!
=
=
firstValue
)
{
return
false
;
}
}
return
true
;
}
