"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
const
{
Task
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
{
}
)
;
const
{
createNode
TimeScale
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
Keyframes
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
keyframes
"
)
;
function
AnimationDetails
(
serverTraits
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
onFrameSelected
=
this
.
onFrameSelected
.
bind
(
this
)
;
this
.
keyframeComponents
=
[
]
;
this
.
serverTraits
=
serverTraits
;
}
exports
.
AnimationDetails
=
AnimationDetails
;
AnimationDetails
.
prototype
=
{
NON_PROPERTIES
:
[
"
easing
"
"
composite
"
"
computedOffset
"
"
offset
"
]
init
:
function
(
containerEl
)
{
this
.
containerEl
=
containerEl
;
}
destroy
:
function
(
)
{
this
.
unrender
(
)
;
this
.
containerEl
=
null
;
this
.
serverTraits
=
null
;
}
unrender
:
function
(
)
{
for
(
let
component
of
this
.
keyframeComponents
)
{
component
.
off
(
"
frame
-
selected
"
this
.
onFrameSelected
)
;
component
.
destroy
(
)
;
}
this
.
keyframeComponents
=
[
]
;
while
(
this
.
containerEl
.
firstChild
)
{
this
.
containerEl
.
firstChild
.
remove
(
)
;
}
}
getTracks
:
Task
.
async
(
function
*
(
)
{
let
tracks
=
{
}
;
if
(
this
.
serverTraits
.
hasGetProperties
)
{
let
properties
=
yield
this
.
animation
.
getProperties
(
)
;
for
(
let
propertyObject
of
properties
)
{
let
name
=
propertyObject
.
property
;
if
(
!
tracks
[
name
]
)
{
tracks
[
name
]
=
[
]
;
}
for
(
let
{
value
offset
}
of
propertyObject
.
values
)
{
tracks
[
name
]
.
push
(
{
value
offset
}
)
;
}
}
}
else
{
let
frames
=
yield
this
.
animation
.
getFrames
(
)
;
for
(
let
frame
of
frames
)
{
for
(
let
name
in
frame
)
{
if
(
this
.
NON_PROPERTIES
.
indexOf
(
name
)
!
=
-
1
)
{
continue
;
}
if
(
!
tracks
[
name
]
)
{
tracks
[
name
]
=
[
]
;
}
tracks
[
name
]
.
push
(
{
value
:
frame
[
name
]
offset
:
frame
.
computedOffset
}
)
;
}
}
}
return
tracks
;
}
)
render
:
Task
.
async
(
function
*
(
animation
)
{
this
.
unrender
(
)
;
if
(
!
animation
)
{
return
;
}
this
.
animation
=
animation
;
if
(
!
this
.
containerEl
|
|
this
.
animation
!
=
=
animation
)
{
return
;
}
this
.
tracks
=
yield
this
.
getTracks
(
animation
this
.
serverTraits
)
;
this
.
emit
(
"
keyframes
-
retrieved
"
)
;
for
(
let
propertyName
in
this
.
tracks
)
{
let
line
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
property
"
}
}
)
;
createNode
(
{
parent
:
createNode
(
{
parent
:
line
attributes
:
{
"
class
"
:
"
name
"
}
}
)
textContent
:
getCssPropertyName
(
propertyName
)
}
)
;
let
framesWrapperEl
=
createNode
(
{
parent
:
line
attributes
:
{
"
class
"
:
"
track
-
container
"
}
}
)
;
let
framesEl
=
createNode
(
{
parent
:
framesWrapperEl
attributes
:
{
"
class
"
:
"
frames
"
}
}
)
;
let
{
x
w
}
=
TimeScale
.
getAnimationDimensions
(
animation
)
;
framesEl
.
style
.
left
=
{
x
}
%
;
framesEl
.
style
.
width
=
{
w
}
%
;
let
keyframesComponent
=
new
Keyframes
(
)
;
keyframesComponent
.
init
(
framesEl
)
;
keyframesComponent
.
render
(
{
keyframes
:
this
.
tracks
[
propertyName
]
propertyName
:
propertyName
animation
:
animation
}
)
;
keyframesComponent
.
on
(
"
frame
-
selected
"
this
.
onFrameSelected
)
;
this
.
keyframeComponents
.
push
(
keyframesComponent
)
;
}
}
)
onFrameSelected
:
function
(
e
args
)
{
this
.
emit
(
e
args
)
;
}
}
;
function
getCssPropertyName
(
jsPropertyName
)
{
return
jsPropertyName
.
replace
(
/
[
A
-
Z
]
/
g
"
-
&
"
)
.
toLowerCase
(
)
;
}
exports
.
getCssPropertyName
=
getCssPropertyName
;
