"
use
strict
"
;
const
{
createNode
createSVGNode
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
ProgressGraphHelper
}
=
require
(
"
devtools
/
client
/
animationinspector
/
graph
-
helper
.
js
"
)
;
let
LINEAR_GRADIENT_ID_COUNTER
=
0
;
function
Keyframes
(
)
{
}
exports
.
Keyframes
=
Keyframes
;
Keyframes
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
containerEl
=
containerEl
;
this
.
keyframesEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
keyframes
"
}
}
)
;
}
destroy
:
function
(
)
{
this
.
keyframesEl
.
remove
(
)
;
this
.
containerEl
=
this
.
keyframesEl
=
this
.
animation
=
null
;
}
render
:
function
(
{
keyframes
propertyName
animation
animationType
}
)
{
this
.
keyframes
=
keyframes
;
this
.
propertyName
=
propertyName
;
this
.
animation
=
animation
;
const
graphEl
=
createSVGNode
(
{
parent
:
this
.
keyframesEl
nodeType
:
"
svg
"
attributes
:
{
"
preserveAspectRatio
"
:
"
none
"
}
}
)
;
const
totalDuration
=
animation
.
state
.
duration
;
const
minSegmentDuration
=
totalDuration
/
this
.
containerEl
.
clientWidth
;
const
win
=
this
.
containerEl
.
ownerGlobal
;
const
graphHelper
=
new
ProgressGraphHelper
(
win
propertyName
animationType
keyframes
totalDuration
)
;
renderPropertyGraph
(
graphEl
totalDuration
minSegmentDuration
graphHelper
)
;
graphHelper
.
destroy
(
)
;
const
maxStrokeWidth
=
win
.
getComputedStyle
(
graphEl
.
querySelector
(
"
.
keyframes
svg
.
hint
"
)
)
.
strokeWidth
;
const
invisibleStrokeWidthInViewBox
=
maxStrokeWidth
/
2
/
this
.
containerEl
.
clientHeight
;
graphEl
.
setAttribute
(
"
viewBox
"
0
-
{
1
+
invisibleStrokeWidthInViewBox
}
{
totalDuration
}
{
1
+
invisibleStrokeWidthInViewBox
*
2
}
)
;
this
.
keyframesEl
.
classList
.
add
(
animation
.
state
.
type
)
;
for
(
let
frame
of
this
.
keyframes
)
{
createNode
(
{
parent
:
this
.
keyframesEl
attributes
:
{
"
class
"
:
"
frame
"
"
style
"
:
left
:
{
frame
.
offset
*
100
}
%
;
"
data
-
offset
"
:
frame
.
offset
"
data
-
property
"
:
propertyName
"
title
"
:
frame
.
value
}
}
)
;
}
}
}
;
function
renderPropertyGraph
(
parentEl
duration
minSegmentDuration
graphHelper
)
{
const
segments
=
graphHelper
.
createPathSegments
(
duration
minSegmentDuration
)
;
const
graphType
=
graphHelper
.
getGraphType
(
)
;
if
(
graphType
!
=
=
"
color
"
)
{
graphHelper
.
appendShapePath
(
parentEl
segments
graphType
)
;
renderEasingHint
(
parentEl
segments
graphHelper
)
;
return
;
}
segments
.
forEach
(
segment
=
>
{
segment
.
y
=
1
;
}
)
;
const
path
=
graphHelper
.
appendShapePath
(
parentEl
segments
graphType
)
;
const
defEl
=
createSVGNode
(
{
parent
:
parentEl
nodeType
:
"
def
"
}
)
;
const
id
=
color
-
property
-
{
LINEAR_GRADIENT_ID_COUNTER
+
+
}
;
const
linearGradientEl
=
createSVGNode
(
{
parent
:
defEl
nodeType
:
"
linearGradient
"
attributes
:
{
"
id
"
:
id
}
}
)
;
segments
.
forEach
(
segment
=
>
{
createSVGNode
(
{
parent
:
linearGradientEl
nodeType
:
"
stop
"
attributes
:
{
"
stop
-
color
"
:
segment
.
style
"
offset
"
:
segment
.
x
/
duration
}
}
)
;
}
)
;
path
.
style
.
fill
=
url
(
#
{
id
}
)
;
renderEasingHintForColor
(
parentEl
graphHelper
)
;
}
function
renderEasingHint
(
parentEl
segments
helper
)
{
const
keyframes
=
helper
.
getKeyframes
(
)
;
const
duration
=
helper
.
getDuration
(
)
;
for
(
let
i
=
0
indexOfSegments
=
0
;
i
<
keyframes
.
length
-
1
;
i
+
+
)
{
const
startKeyframe
=
keyframes
[
i
]
;
const
endKeyframe
=
keyframes
[
i
+
1
]
;
const
endTime
=
endKeyframe
.
offset
*
duration
;
const
keyframeSegments
=
[
]
;
for
(
;
indexOfSegments
<
segments
.
length
;
indexOfSegments
+
+
)
{
const
segment
=
segments
[
indexOfSegments
]
;
keyframeSegments
.
push
(
segment
)
;
if
(
startKeyframe
.
offset
=
=
=
endKeyframe
.
offset
)
{
keyframeSegments
.
push
(
segments
[
+
+
indexOfSegments
]
)
;
break
;
}
else
if
(
segment
.
x
=
=
=
endTime
)
{
break
;
}
}
const
gEl
=
createSVGNode
(
{
parent
:
parentEl
nodeType
:
"
g
"
}
)
;
createSVGNode
(
{
parent
:
gEl
nodeType
:
"
title
"
textContent
:
startKeyframe
.
easing
}
)
;
helper
.
appendLinePath
(
gEl
keyframeSegments
{
helper
.
getGraphType
(
)
}
hint
)
;
}
}
function
renderEasingHintForColor
(
parentEl
helper
)
{
const
keyframes
=
helper
.
getKeyframes
(
)
;
const
duration
=
helper
.
getDuration
(
)
;
for
(
let
i
=
0
;
i
<
keyframes
.
length
-
1
;
i
+
+
)
{
const
startKeyframe
=
keyframes
[
i
]
;
const
startTime
=
startKeyframe
.
offset
*
duration
;
const
endKeyframe
=
keyframes
[
i
+
1
]
;
const
endTime
=
endKeyframe
.
offset
*
duration
;
const
gEl
=
createSVGNode
(
{
parent
:
parentEl
nodeType
:
"
g
"
}
)
;
createSVGNode
(
{
parent
:
gEl
nodeType
:
"
title
"
textContent
:
startKeyframe
.
easing
}
)
;
createSVGNode
(
{
parent
:
gEl
nodeType
:
"
rect
"
attributes
:
{
x
:
startTime
y
:
-
1
width
:
endTime
-
startTime
height
:
1
class
:
"
hint
"
}
}
)
;
}
}
