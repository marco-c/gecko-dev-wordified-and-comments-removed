"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
ViewHelpers
.
jsm
"
)
;
const
{
createNode
TimeScale
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
client
/
shared
/
l10n
"
)
;
const
STRINGS_URI
=
"
chrome
:
/
/
devtools
/
locale
/
animationinspector
.
properties
"
;
const
L10N
=
new
LocalizationHelper
(
STRINGS_URI
)
;
function
AnimationTimeBlock
(
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
exports
.
AnimationTimeBlock
=
AnimationTimeBlock
;
AnimationTimeBlock
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
containerEl
=
containerEl
;
this
.
containerEl
.
addEventListener
(
"
click
"
this
.
onClick
)
;
}
destroy
:
function
(
)
{
this
.
containerEl
.
removeEventListener
(
"
click
"
this
.
onClick
)
;
this
.
unrender
(
)
;
this
.
containerEl
=
null
;
this
.
animation
=
null
;
}
unrender
:
function
(
)
{
while
(
this
.
containerEl
.
firstChild
)
{
this
.
containerEl
.
firstChild
.
remove
(
)
;
}
}
render
:
function
(
animation
)
{
this
.
unrender
(
)
;
this
.
animation
=
animation
;
let
{
state
}
=
this
.
animation
;
let
{
x
iterationW
delayX
delayW
negativeDelayW
}
=
TimeScale
.
getAnimationDimensions
(
animation
)
;
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
iterations
"
+
(
state
.
iterationCount
?
"
"
:
"
infinite
"
)
"
style
"
:
left
:
{
x
}
%
;
width
:
{
iterationW
}
%
;
background
-
size
:
{
100
/
(
state
.
iterationCount
|
|
1
)
}
%
100
%
;
}
}
)
;
createNode
(
{
parent
:
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
name
"
"
title
"
:
this
.
getTooltipText
(
state
)
"
style
"
:
left
:
{
x
+
negativeDelayW
}
%
;
width
:
{
iterationW
-
negativeDelayW
}
%
;
}
}
)
textContent
:
state
.
name
}
)
;
if
(
state
.
delay
)
{
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
delay
"
+
(
state
.
delay
<
0
?
"
negative
"
:
"
"
)
"
style
"
:
left
:
{
delayX
}
%
;
width
:
{
delayW
}
%
;
}
}
)
;
}
}
getTooltipText
:
function
(
state
)
{
let
getTime
=
time
=
>
L10N
.
getFormatStr
(
"
player
.
timeLabel
"
L10N
.
numberWithDecimals
(
time
/
1000
2
)
)
;
let
text
=
"
"
;
text
+
=
getFormattedAnimationTitle
(
{
state
}
)
;
text
+
=
"
\
n
"
;
text
+
=
L10N
.
getStr
(
"
player
.
animationDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
delay
)
;
text
+
=
"
\
n
"
;
text
+
=
L10N
.
getStr
(
"
player
.
animationDurationLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
duration
)
;
text
+
=
"
\
n
"
;
if
(
state
.
iterationCount
!
=
=
1
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationIterationCountLabel
"
)
+
"
"
;
text
+
=
state
.
iterationCount
|
|
L10N
.
getStr
(
"
player
.
infiniteIterationCountText
"
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
iterationStart
!
=
=
0
)
{
let
iterationStartTime
=
state
.
iterationStart
*
state
.
duration
/
1000
;
text
+
=
L10N
.
getFormatStr
(
"
player
.
animationIterationStartLabel
"
state
.
iterationStart
L10N
.
numberWithDecimals
(
iterationStartTime
2
)
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
playbackRate
!
=
=
1
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationRateLabel
"
)
+
"
"
;
text
+
=
state
.
playbackRate
;
text
+
=
"
\
n
"
;
}
if
(
state
.
isRunningOnCompositor
)
{
text
+
=
L10N
.
getStr
(
"
player
.
runningOnCompositorTooltip
"
)
;
}
return
text
;
}
onClick
:
function
(
e
)
{
e
.
stopPropagation
(
)
;
this
.
emit
(
"
selected
"
this
.
animation
)
;
}
}
;
function
getFormattedAnimationTitle
(
{
state
}
)
{
if
(
!
state
.
type
)
{
return
state
.
name
;
}
if
(
state
.
type
=
=
=
"
scriptanimation
"
&
&
!
state
.
name
)
{
return
L10N
.
getStr
(
"
timeline
.
scriptanimation
.
unnamedLabel
"
)
;
}
return
L10N
.
getFormatStr
(
timeline
.
{
state
.
type
}
.
nameLabel
state
.
name
)
;
}
