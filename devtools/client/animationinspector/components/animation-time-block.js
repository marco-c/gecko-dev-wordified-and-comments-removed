"
use
strict
"
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
createNode
createSVGNode
TimeScale
getFormattedAnimationTitle
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
SummaryGraphHelper
getPreferredKeyframesProgressThreshold
getPreferredProgressThreshold
}
=
require
(
"
devtools
/
client
/
animationinspector
/
graph
-
helper
"
)
;
const
{
LocalizationHelper
}
=
require
(
"
devtools
/
shared
/
l10n
"
)
;
const
L10N
=
new
LocalizationHelper
(
"
devtools
/
client
/
locales
/
animationinspector
.
properties
"
)
;
const
MAX_INFINITE_ANIMATIONS_ITERATIONS
=
10
;
const
MIN_KEYFRAMES_EASING_OPACITY
=
.
5
;
function
AnimationTimeBlock
(
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
exports
.
AnimationTimeBlock
=
AnimationTimeBlock
;
AnimationTimeBlock
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
containerEl
=
containerEl
;
this
.
containerEl
.
addEventListener
(
"
click
"
this
.
onClick
)
;
}
destroy
:
function
(
)
{
this
.
containerEl
.
removeEventListener
(
"
click
"
this
.
onClick
)
;
this
.
unrender
(
)
;
this
.
containerEl
=
null
;
this
.
animation
=
null
;
}
unrender
:
function
(
)
{
while
(
this
.
containerEl
.
firstChild
)
{
this
.
containerEl
.
firstChild
.
remove
(
)
;
}
}
render
:
function
(
animation
tracks
)
{
this
.
unrender
(
)
;
this
.
animation
=
animation
;
const
summaryEl
=
createSVGNode
(
{
parent
:
this
.
containerEl
nodeType
:
"
svg
"
attributes
:
{
"
class
"
:
"
summary
"
"
preserveAspectRatio
"
:
"
none
"
}
}
)
;
this
.
updateSummaryGraphViewBox
(
summaryEl
)
;
const
{
state
}
=
this
.
animation
;
const
totalDisplayedDuration
=
this
.
getTotalDisplayedDuration
(
)
;
const
minSegmentDuration
=
totalDisplayedDuration
/
this
.
containerEl
.
clientWidth
;
const
minEffectProgressThreshold
=
getPreferredProgressThreshold
(
state
.
easing
)
;
const
graphHelper
=
new
SummaryGraphHelper
(
this
.
win
state
minSegmentDuration
)
;
renderKeyframesEasingGraph
(
summaryEl
state
totalDisplayedDuration
minEffectProgressThreshold
tracks
graphHelper
)
;
if
(
state
.
easing
!
=
=
"
linear
"
)
{
renderEffectEasingGraph
(
summaryEl
state
totalDisplayedDuration
minEffectProgressThreshold
graphHelper
)
;
}
graphHelper
.
destroy
(
)
;
const
nameEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
name
"
"
title
"
:
this
.
getTooltipText
(
state
)
}
}
)
;
createSVGNode
(
{
parent
:
createSVGNode
(
{
parent
:
nameEl
nodeType
:
"
svg
"
}
)
nodeType
:
"
text
"
attributes
:
{
"
y
"
:
"
50
%
"
"
x
"
:
"
100
%
"
}
textContent
:
state
.
name
}
)
;
if
(
state
.
delay
)
{
const
delayEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
delay
"
+
(
state
.
delay
<
0
?
"
negative
"
:
"
positive
"
)
+
(
state
.
fill
=
=
=
"
both
"
|
|
state
.
fill
=
=
=
"
backwards
"
?
"
fill
"
:
"
"
)
}
}
)
;
this
.
updateDelayBounds
(
delayEl
)
;
}
if
(
state
.
iterationCount
&
&
state
.
endDelay
)
{
const
endDelayEl
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
"
end
-
delay
"
+
(
state
.
endDelay
<
0
?
"
negative
"
:
"
positive
"
)
+
(
state
.
fill
=
=
=
"
both
"
|
|
state
.
fill
=
=
=
"
forwards
"
?
"
fill
"
:
"
"
)
}
}
)
;
this
.
updateEndDelayBounds
(
endDelayEl
)
;
}
}
update
:
function
(
animation
)
{
this
.
animation
=
animation
;
this
.
updateSummaryGraphViewBox
(
this
.
containerEl
.
querySelector
(
"
.
summary
"
)
)
;
const
delayEl
=
this
.
containerEl
.
querySelector
(
"
.
delay
"
)
;
if
(
delayEl
)
{
this
.
updateDelayBounds
(
delayEl
)
;
}
const
endDelayEl
=
this
.
containerEl
.
querySelector
(
"
.
end
-
delay
"
)
;
if
(
endDelayEl
)
{
this
.
updateEndDelayBounds
(
endDelayEl
)
;
}
}
updateSummaryGraphViewBox
:
function
(
summaryEl
)
{
const
{
x
delayW
}
=
TimeScale
.
getAnimationDimensions
(
this
.
animation
)
;
const
totalDisplayedDuration
=
this
.
getTotalDisplayedDuration
(
)
;
const
strokeHeightForViewBox
=
0
.
5
/
this
.
containerEl
.
clientHeight
;
const
{
state
}
=
this
.
animation
;
summaryEl
.
setAttribute
(
"
viewBox
"
{
state
.
delay
<
0
?
state
.
delay
:
0
}
+
-
{
1
+
strokeHeightForViewBox
}
+
{
totalDisplayedDuration
}
+
{
1
+
strokeHeightForViewBox
*
2
}
)
;
summaryEl
.
setAttribute
(
"
style
"
left
:
{
x
-
(
state
.
delay
>
0
?
delayW
:
0
)
}
%
)
;
}
updateDelayBounds
:
function
(
delayEl
)
{
const
{
delayX
delayW
}
=
TimeScale
.
getAnimationDimensions
(
this
.
animation
)
;
delayEl
.
style
.
left
=
{
delayX
}
%
;
delayEl
.
style
.
width
=
{
delayW
}
%
;
}
updateEndDelayBounds
:
function
(
endDelayEl
)
{
const
{
endDelayX
endDelayW
}
=
TimeScale
.
getAnimationDimensions
(
this
.
animation
)
;
endDelayEl
.
style
.
left
=
{
endDelayX
}
%
;
endDelayEl
.
style
.
width
=
{
endDelayW
}
%
;
}
getTotalDisplayedDuration
:
function
(
)
{
return
this
.
animation
.
state
.
playbackRate
*
TimeScale
.
getDuration
(
)
;
}
getTooltipText
:
function
(
state
)
{
let
getTime
=
time
=
>
L10N
.
getFormatStr
(
"
player
.
timeLabel
"
L10N
.
numberWithDecimals
(
time
/
1000
2
)
)
;
let
text
=
"
"
;
text
+
=
getFormattedAnimationTitle
(
{
state
}
)
;
text
+
=
"
\
n
"
;
if
(
state
.
delay
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
delay
)
;
text
+
=
"
\
n
"
;
}
text
+
=
L10N
.
getStr
(
"
player
.
animationDurationLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
duration
)
;
text
+
=
"
\
n
"
;
if
(
state
.
endDelay
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationEndDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
endDelay
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
iterationCount
!
=
=
1
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationIterationCountLabel
"
)
+
"
"
;
text
+
=
state
.
iterationCount
|
|
L10N
.
getStr
(
"
player
.
infiniteIterationCountText
"
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
iterationStart
!
=
=
0
)
{
let
iterationStartTime
=
state
.
iterationStart
*
state
.
duration
/
1000
;
text
+
=
L10N
.
getFormatStr
(
"
player
.
animationIterationStartLabel
"
state
.
iterationStart
L10N
.
numberWithDecimals
(
iterationStartTime
2
)
)
;
text
+
=
"
\
n
"
;
}
if
(
state
.
easing
&
&
state
.
easing
!
=
=
"
linear
"
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationOverallEasingLabel
"
)
+
"
"
;
text
+
=
state
.
easing
;
text
+
=
"
\
n
"
;
}
if
(
state
.
fill
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationFillLabel
"
)
+
"
"
;
text
+
=
state
.
fill
;
text
+
=
"
\
n
"
;
}
if
(
state
.
direction
&
&
state
.
direction
!
=
=
"
normal
"
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationDirectionLabel
"
)
+
"
"
;
text
+
=
state
.
direction
;
text
+
=
"
\
n
"
;
}
if
(
state
.
playbackRate
!
=
=
1
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationRateLabel
"
)
+
"
"
;
text
+
=
state
.
playbackRate
;
text
+
=
"
\
n
"
;
}
if
(
state
.
propertyState
)
{
if
(
state
.
propertyState
.
every
(
propState
=
>
propState
.
runningOnCompositor
)
)
{
text
+
=
L10N
.
getStr
(
"
player
.
allPropertiesOnCompositorTooltip
"
)
;
}
else
if
(
state
.
propertyState
.
some
(
propState
=
>
propState
.
runningOnCompositor
)
)
{
text
+
=
L10N
.
getStr
(
"
player
.
somePropertiesOnCompositorTooltip
"
)
;
}
}
else
if
(
state
.
isRunningOnCompositor
)
{
text
+
=
L10N
.
getStr
(
"
player
.
runningOnCompositorTooltip
"
)
;
}
return
text
;
}
onClick
:
function
(
e
)
{
e
.
stopPropagation
(
)
;
this
.
emit
(
"
selected
"
this
.
animation
)
;
}
get
win
(
)
{
return
this
.
containerEl
.
ownerDocument
.
defaultView
;
}
}
;
function
renderKeyframesEasingGraph
(
parentEl
state
totalDisplayedDuration
minEffectProgressThreshold
tracks
graphHelper
)
{
const
keyframesList
=
getOffsetAndEasingOnlyKeyframesList
(
tracks
)
;
const
keyframeEasingOpacity
=
Math
.
max
(
1
/
keyframesList
.
length
MIN_KEYFRAMES_EASING_OPACITY
)
;
for
(
let
keyframes
of
keyframesList
)
{
const
minProgressTreshold
=
Math
.
min
(
minEffectProgressThreshold
getPreferredKeyframesProgressThreshold
(
keyframes
)
)
;
graphHelper
.
setMinProgressThreshold
(
minProgressTreshold
)
;
graphHelper
.
setKeyframes
(
keyframes
)
;
graphHelper
.
setClosePathNeeded
(
true
)
;
const
element
=
renderGraph
(
parentEl
state
totalDisplayedDuration
"
keyframes
-
easing
"
graphHelper
)
;
element
.
style
.
opacity
=
keyframeEasingOpacity
;
}
}
function
renderEffectEasingGraph
(
parentEl
state
totalDisplayedDuration
minEffectProgressThreshold
graphHelper
)
{
graphHelper
.
setMinProgressThreshold
(
minEffectProgressThreshold
)
;
graphHelper
.
setKeyframes
(
null
)
;
graphHelper
.
setClosePathNeeded
(
false
)
;
renderGraph
(
parentEl
state
totalDisplayedDuration
"
effect
-
easing
"
graphHelper
)
;
}
function
renderGraph
(
parentEl
state
totalDisplayedDuration
className
graphHelper
)
{
const
graphEl
=
createSVGNode
(
{
parent
:
parentEl
nodeType
:
"
g
"
attributes
:
{
"
class
"
:
className
}
}
)
;
let
mainIterationStartTime
=
0
;
let
iterationStart
=
state
.
iterationStart
;
let
iterationCount
=
state
.
iterationCount
?
state
.
iterationCount
:
Infinity
;
graphHelper
.
setFillMode
(
state
.
fill
)
;
graphHelper
.
setOriginalBehavior
(
true
)
;
if
(
state
.
delay
>
0
)
{
renderDelay
(
graphEl
state
graphHelper
)
;
mainIterationStartTime
=
state
.
delay
;
}
else
{
const
negativeDelayCount
=
-
state
.
delay
/
state
.
duration
;
iterationStart
+
=
negativeDelayCount
;
if
(
iterationCount
!
=
=
Infinity
)
{
iterationCount
-
=
negativeDelayCount
;
}
}
const
firstSectionCount
=
iterationStart
%
1
=
=
=
0
?
0
:
Math
.
min
(
iterationCount
1
)
-
iterationStart
%
1
;
if
(
firstSectionCount
)
{
renderFirstIteration
(
graphEl
state
mainIterationStartTime
firstSectionCount
graphHelper
)
;
}
if
(
iterationCount
=
=
=
Infinity
)
{
renderInfinity
(
graphEl
state
mainIterationStartTime
firstSectionCount
totalDisplayedDuration
graphHelper
)
;
}
else
{
if
(
state
.
fill
=
=
=
"
both
"
|
|
state
.
fill
=
=
=
"
forwards
"
)
{
renderForwardsFill
(
graphEl
state
mainIterationStartTime
iterationCount
totalDisplayedDuration
graphHelper
)
;
}
const
middleSectionCount
=
Math
.
floor
(
iterationCount
-
firstSectionCount
)
;
renderMiddleIterations
(
graphEl
state
mainIterationStartTime
firstSectionCount
middleSectionCount
graphHelper
)
;
const
lastSectionCount
=
iterationCount
-
middleSectionCount
-
firstSectionCount
;
if
(
lastSectionCount
)
{
renderLastIteration
(
graphEl
state
mainIterationStartTime
firstSectionCount
middleSectionCount
lastSectionCount
graphHelper
)
;
}
if
(
state
.
endDelay
>
0
)
{
renderEndDelay
(
graphEl
state
mainIterationStartTime
iterationCount
graphHelper
)
;
}
}
if
(
state
.
delay
<
0
)
{
graphHelper
.
setFillMode
(
"
both
"
)
;
graphHelper
.
setOriginalBehavior
(
false
)
;
renderNegativeDelayHiddenProgress
(
graphEl
state
graphHelper
)
;
}
if
(
state
.
iterationCount
&
&
state
.
endDelay
<
0
)
{
graphHelper
.
setFillMode
(
"
both
"
)
;
graphHelper
.
setOriginalBehavior
(
false
)
;
renderNegativeEndDelayHiddenProgress
(
graphEl
state
graphHelper
)
;
}
return
graphEl
;
}
function
renderDelay
(
parentEl
state
graphHelper
)
{
const
startSegment
=
graphHelper
.
getSegment
(
0
)
;
const
endSegment
=
{
x
:
state
.
delay
y
:
startSegment
.
y
}
;
graphHelper
.
appendPathElement
(
parentEl
[
startSegment
endSegment
]
"
delay
-
path
"
)
;
}
function
renderFirstIteration
(
parentEl
state
mainIterationStartTime
firstSectionCount
graphHelper
)
{
const
startTime
=
mainIterationStartTime
;
const
endTime
=
startTime
+
firstSectionCount
*
state
.
duration
;
const
segments
=
graphHelper
.
createPathSegments
(
startTime
endTime
)
;
graphHelper
.
appendPathElement
(
parentEl
segments
"
iteration
-
path
"
)
;
}
function
renderMiddleIterations
(
parentEl
state
mainIterationStartTime
firstSectionCount
middleSectionCount
graphHelper
)
{
const
offset
=
mainIterationStartTime
+
firstSectionCount
*
state
.
duration
;
for
(
let
i
=
0
;
i
<
middleSectionCount
;
i
+
+
)
{
const
startTime
=
offset
+
i
*
state
.
duration
;
const
endTime
=
startTime
+
state
.
duration
;
const
segments
=
graphHelper
.
createPathSegments
(
startTime
endTime
)
;
graphHelper
.
appendPathElement
(
parentEl
segments
"
iteration
-
path
"
)
;
}
}
function
renderLastIteration
(
parentEl
state
mainIterationStartTime
firstSectionCount
middleSectionCount
lastSectionCount
graphHelper
)
{
const
startTime
=
mainIterationStartTime
+
(
firstSectionCount
+
middleSectionCount
)
*
state
.
duration
;
const
endTime
=
startTime
+
lastSectionCount
*
state
.
duration
;
const
segments
=
graphHelper
.
createPathSegments
(
startTime
endTime
)
;
graphHelper
.
appendPathElement
(
parentEl
segments
"
iteration
-
path
"
)
;
}
function
renderInfinity
(
parentEl
state
mainIterationStartTime
firstSectionCount
totalDuration
graphHelper
)
{
let
uncappedInfinityIterationCount
=
(
totalDuration
-
firstSectionCount
*
state
.
duration
)
/
state
.
duration
;
uncappedInfinityIterationCount
=
parseFloat
(
uncappedInfinityIterationCount
.
toPrecision
(
6
)
)
;
const
infinityIterationCount
=
Math
.
min
(
MAX_INFINITE_ANIMATIONS_ITERATIONS
Math
.
ceil
(
uncappedInfinityIterationCount
)
)
;
const
firstStartTime
=
mainIterationStartTime
+
firstSectionCount
*
state
.
duration
;
const
firstEndTime
=
firstStartTime
+
state
.
duration
;
const
firstSegments
=
graphHelper
.
createPathSegments
(
firstStartTime
firstEndTime
)
;
graphHelper
.
appendPathElement
(
parentEl
firstSegments
"
iteration
-
path
infinity
"
)
;
const
isAlternate
=
state
.
direction
.
match
(
/
alternate
/
)
;
for
(
let
i
=
1
;
i
<
infinityIterationCount
;
i
+
+
)
{
const
startTime
=
firstStartTime
+
i
*
state
.
duration
;
let
segments
;
if
(
isAlternate
&
&
i
%
2
)
{
segments
=
firstSegments
.
map
(
segment
=
>
{
return
{
x
:
firstEndTime
-
segment
.
x
+
startTime
y
:
segment
.
y
}
;
}
)
;
}
else
{
segments
=
firstSegments
.
map
(
segment
=
>
{
return
{
x
:
segment
.
x
-
firstStartTime
+
startTime
y
:
segment
.
y
}
;
}
)
;
}
graphHelper
.
appendPathElement
(
parentEl
segments
"
iteration
-
path
infinity
copied
"
)
;
}
}
function
renderEndDelay
(
parentEl
state
mainIterationStartTime
iterationCount
graphHelper
)
{
const
startTime
=
mainIterationStartTime
+
iterationCount
*
state
.
duration
;
const
startSegment
=
graphHelper
.
getSegment
(
startTime
)
;
const
endSegment
=
{
x
:
startTime
+
state
.
endDelay
y
:
startSegment
.
y
}
;
graphHelper
.
appendPathElement
(
parentEl
[
startSegment
endSegment
]
"
enddelay
-
path
"
)
;
}
function
renderForwardsFill
(
parentEl
state
mainIterationStartTime
iterationCount
totalDuration
graphHelper
)
{
const
startTime
=
mainIterationStartTime
+
iterationCount
*
state
.
duration
+
(
state
.
endDelay
>
0
?
state
.
endDelay
:
0
)
;
const
startSegment
=
graphHelper
.
getSegment
(
startTime
)
;
const
endSegment
=
{
x
:
totalDuration
y
:
startSegment
.
y
}
;
graphHelper
.
appendPathElement
(
parentEl
[
startSegment
endSegment
]
"
fill
-
forwards
-
path
"
)
;
}
function
renderNegativeDelayHiddenProgress
(
parentEl
state
graphHelper
)
{
const
startTime
=
state
.
delay
;
const
endTime
=
0
;
const
segments
=
graphHelper
.
createPathSegments
(
startTime
endTime
)
;
graphHelper
.
appendPathElement
(
parentEl
segments
"
delay
-
path
negative
"
)
;
}
function
renderNegativeEndDelayHiddenProgress
(
parentEl
state
graphHelper
)
{
const
endTime
=
state
.
delay
+
state
.
iterationCount
*
state
.
duration
;
const
startTime
=
endTime
+
state
.
endDelay
;
const
segments
=
graphHelper
.
createPathSegments
(
startTime
endTime
)
;
graphHelper
.
appendPathElement
(
parentEl
segments
"
enddelay
-
path
negative
"
)
;
}
function
getOffsetAndEasingOnlyKeyframesList
(
tracks
)
{
return
Object
.
keys
(
tracks
)
.
reduce
(
(
result
name
)
=
>
{
const
track
=
tracks
[
name
]
;
const
exists
=
result
.
find
(
keyframes
=
>
{
if
(
track
.
length
!
=
=
keyframes
.
length
)
{
return
false
;
}
for
(
let
i
=
0
;
i
<
track
.
length
;
i
+
+
)
{
const
keyframe1
=
track
[
i
]
;
const
keyframe2
=
keyframes
[
i
]
;
if
(
keyframe1
.
offset
!
=
=
keyframe2
.
offset
|
|
keyframe1
.
easing
!
=
=
keyframe2
.
easing
)
{
return
false
;
}
}
return
true
;
}
)
;
if
(
!
exists
)
{
const
keyframes
=
track
.
map
(
keyframe
=
>
{
return
{
offset
:
keyframe
.
offset
easing
:
keyframe
.
easing
}
;
}
)
;
result
.
push
(
keyframes
)
;
}
return
result
;
}
[
]
)
;
}
