"
use
strict
"
;
requestLongerTimeout
(
2
)
;
add_task
(
function
*
(
)
{
yield
addTab
(
URL_ROOT
+
"
doc_end_delay
.
html
"
)
;
let
{
inspector
panel
}
=
yield
openAnimationInspector
(
)
;
let
selectors
=
[
"
#
target1
"
"
#
target2
"
"
#
target3
"
"
#
target4
"
]
;
for
(
let
i
=
0
;
i
<
selectors
.
length
;
i
+
+
)
{
let
selector
=
selectors
[
i
]
;
yield
selectNode
(
selector
inspector
)
;
let
timelineEl
=
panel
.
animationsTimelineComponent
.
rootWrapperEl
;
let
animationEl
=
timelineEl
.
querySelectorAll
(
"
.
animation
"
)
[
0
]
;
checkEndDelayAndName
(
animationEl
)
;
}
}
)
;
function
checkEndDelayAndName
(
animationEl
)
{
let
endDelay
=
animationEl
.
querySelector
(
"
.
end
-
delay
"
)
;
let
name
=
animationEl
.
querySelector
(
"
.
name
"
)
;
let
targetNode
=
animationEl
.
querySelector
(
"
.
target
"
)
;
let
endDelayLeft
=
Math
.
round
(
endDelay
.
getBoundingClientRect
(
)
.
x
)
;
let
sidebarWidth
=
Math
.
round
(
targetNode
.
getBoundingClientRect
(
)
.
width
)
;
ok
(
endDelayLeft
>
=
sidebarWidth
"
The
endDelay
element
isn
'
t
displayed
over
the
sidebar
"
)
;
let
endDelayRight
=
Math
.
round
(
endDelay
.
getBoundingClientRect
(
)
.
right
)
;
let
nameLeft
=
Math
.
round
(
name
.
getBoundingClientRect
(
)
.
left
)
;
ok
(
endDelayRight
>
=
nameLeft
"
The
endDelay
element
does
not
span
over
the
name
element
"
)
;
}
