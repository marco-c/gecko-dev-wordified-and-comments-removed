"
use
strict
"
;
add_task
(
function
*
(
)
{
yield
addTab
(
URL_ROOT
+
"
doc_modify_playbackRate
.
html
"
)
;
let
{
panel
}
=
yield
openAnimationInspector
(
)
;
let
timelineEl
=
panel
.
animationsTimelineComponent
.
rootWrapperEl
;
let
timeBlocks
=
timelineEl
.
querySelectorAll
(
"
.
time
-
block
"
)
;
is
(
timeBlocks
.
length
2
"
2
animations
are
displayed
"
)
;
info
(
"
The
first
animation
has
its
rate
set
to
1
let
'
s
measure
it
"
)
;
let
el
=
timeBlocks
[
0
]
;
let
delay
=
parseInt
(
el
.
querySelector
(
"
.
delay
"
)
.
style
.
width
10
)
;
let
duration
=
null
;
el
.
querySelectorAll
(
"
svg
g
"
)
.
forEach
(
groupEl
=
>
{
const
dur
=
getDuration
(
groupEl
.
querySelector
(
"
path
"
)
)
;
if
(
!
duration
)
{
duration
=
dur
;
return
;
}
is
(
duration
dur
"
The
durations
shuld
be
same
at
all
paths
in
one
group
"
)
;
}
)
;
info
(
"
The
second
animation
has
its
rate
set
to
2
so
should
be
shorter
"
)
;
let
el2
=
timeBlocks
[
1
]
;
let
delay2
=
parseInt
(
el2
.
querySelector
(
"
.
delay
"
)
.
style
.
width
10
)
;
let
duration2
=
null
;
el2
.
querySelectorAll
(
"
svg
g
"
)
.
forEach
(
groupEl
=
>
{
const
dur
=
getDuration
(
groupEl
.
querySelector
(
"
path
"
)
)
;
if
(
!
duration2
)
{
duration2
=
dur
;
return
;
}
is
(
duration2
dur
"
The
durations
shuld
be
same
at
all
paths
in
one
group
"
)
;
}
)
;
let
durationDelta
=
(
2
*
duration2
)
-
duration
;
ok
(
durationDelta
<
=
1
"
The
duration
width
is
correct
"
)
;
let
delayDelta
=
(
2
*
delay2
)
-
delay
;
ok
(
delayDelta
<
=
1
"
The
delay
width
is
correct
"
)
;
}
)
;
function
getDuration
(
pathEl
)
{
const
pathSegList
=
pathEl
.
pathSegList
;
let
startingIterationIndex
=
0
;
const
firstPathSeg
=
pathSegList
.
getItem
(
1
)
;
for
(
let
i
=
2
n
=
pathSegList
.
numberOfItems
-
2
;
i
<
n
;
i
+
+
)
{
const
pathSeg
=
pathSegList
.
getItem
(
i
)
;
if
(
firstPathSeg
.
y
!
=
pathSeg
.
y
)
{
startingIterationIndex
=
i
;
break
;
}
}
let
endingIterationIndex
=
0
;
let
previousPathSegment
=
pathSegList
.
getItem
(
startingIterationIndex
)
;
for
(
let
i
=
startingIterationIndex
+
1
n
=
pathSegList
.
numberOfItems
-
2
;
i
<
n
;
i
+
+
)
{
const
pathSeg
=
pathSegList
.
getItem
(
i
)
;
if
(
previousPathSegment
.
y
=
=
pathSeg
.
y
)
{
endingIterationIndex
=
i
;
break
;
}
previousPathSegment
=
pathSeg
;
}
if
(
endingIterationIndex
)
{
endingIterationIndex
=
pathSegList
.
numberOfItems
-
2
;
}
const
startingIterationPathSegment
=
pathSegList
.
getItem
(
startingIterationIndex
)
;
const
endingIterationPathSegment
=
pathSegList
.
getItem
(
startingIterationIndex
)
;
return
endingIterationPathSegment
.
x
-
startingIterationPathSegment
.
x
;
}
