"
use
strict
"
;
var
Cu
=
Components
.
utils
;
const
{
gDevTools
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
framework
/
gDevTools
.
jsm
"
{
}
)
;
const
{
require
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
Loader
.
jsm
"
{
}
)
;
const
promise
=
require
(
"
promise
"
)
;
const
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
const
{
console
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
const
{
ViewHelpers
}
=
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
ViewHelpers
.
jsm
"
{
}
)
;
const
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
waitForExplicitFinish
(
)
;
const
TEST_URL_ROOT
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
animationinspector
/
test
/
"
;
const
ROOT_TEST_DIR
=
getRootDirectory
(
gTestPath
)
;
const
FRAME_SCRIPT_URL
=
ROOT_TEST_DIR
+
"
doc_frame_script
.
js
"
;
const
COMMON_FRAME_SCRIPT_URL
=
"
chrome
:
/
/
devtools
/
content
/
shared
/
frame
-
script
-
utils
.
js
"
;
const
TAB_NAME
=
"
animationinspector
"
;
registerCleanupFunction
(
function
*
(
)
{
yield
closeAnimationInspector
(
)
;
while
(
gBrowser
.
tabs
.
length
>
1
)
{
gBrowser
.
removeCurrentTab
(
)
;
}
}
)
;
DevToolsUtils
.
testing
=
true
;
registerCleanupFunction
(
(
)
=
>
DevToolsUtils
.
testing
=
false
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
dump
.
emit
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
log
"
)
;
}
)
;
function
addTab
(
url
)
{
info
(
"
Adding
a
new
tab
with
URL
:
'
"
+
url
+
"
'
"
)
;
let
def
=
promise
.
defer
(
)
;
window
.
focus
(
)
;
let
tab
=
window
.
gBrowser
.
selectedTab
=
window
.
gBrowser
.
addTab
(
url
)
;
let
browser
=
tab
.
linkedBrowser
;
info
(
"
Loading
the
helper
frame
script
"
+
FRAME_SCRIPT_URL
)
;
browser
.
messageManager
.
loadFrameScript
(
FRAME_SCRIPT_URL
false
)
;
info
(
"
Loading
the
helper
frame
script
"
+
COMMON_FRAME_SCRIPT_URL
)
;
browser
.
messageManager
.
loadFrameScript
(
COMMON_FRAME_SCRIPT_URL
false
)
;
browser
.
addEventListener
(
"
load
"
function
onload
(
)
{
browser
.
removeEventListener
(
"
load
"
onload
true
)
;
info
(
"
URL
'
"
+
url
+
"
'
loading
complete
"
)
;
def
.
resolve
(
tab
)
;
}
true
)
;
return
def
.
promise
;
}
function
*
reloadTab
(
inspector
)
{
let
onNewRoot
=
inspector
.
once
(
"
new
-
root
"
)
;
yield
executeInContent
(
"
devtools
:
test
:
reload
"
{
}
{
}
false
)
;
yield
onNewRoot
;
yield
inspector
.
once
(
"
inspector
-
updated
"
)
;
}
function
getNodeFront
(
selector
{
walker
}
)
{
return
walker
.
querySelector
(
walker
.
rootNode
selector
)
;
}
var
selectNode
=
Task
.
async
(
function
*
(
data
inspector
reason
=
"
test
"
)
{
info
(
"
Selecting
the
node
for
'
"
+
data
+
"
'
"
)
;
let
nodeFront
=
data
;
if
(
!
data
.
_form
)
{
nodeFront
=
yield
getNodeFront
(
data
inspector
)
;
}
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
inspector
.
selection
.
setNodeFront
(
nodeFront
reason
)
;
yield
updated
;
let
{
AnimationsPanel
}
=
inspector
.
sidebar
.
getWindowForTab
(
TAB_NAME
)
;
yield
waitForAllAnimationTargets
(
AnimationsPanel
)
;
}
)
;
function
assertAnimationsDisplayed
(
panel
nbAnimations
msg
=
"
"
)
{
msg
=
msg
|
|
There
are
{
nbAnimations
}
animations
in
the
panel
;
is
(
panel
.
animationsTimelineComponent
.
animationsEl
.
querySelectorAll
(
"
.
animation
"
)
.
length
nbAnimations
msg
)
;
}
var
waitForAnimationInspectorReady
=
Task
.
async
(
function
*
(
inspector
)
{
let
win
=
inspector
.
sidebar
.
getWindowForTab
(
TAB_NAME
)
;
let
updated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
let
tabReady
=
win
.
document
.
readyState
=
=
=
"
complete
"
?
promise
.
resolve
(
)
:
inspector
.
sidebar
.
once
(
"
animationinspector
-
ready
"
)
;
return
promise
.
all
(
[
updated
tabReady
]
)
;
}
)
;
var
openAnimationInspector
=
Task
.
async
(
function
*
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
info
(
"
Opening
the
toolbox
with
the
inspector
selected
"
)
;
let
toolbox
=
yield
gDevTools
.
showToolbox
(
target
"
inspector
"
)
;
info
(
"
Switching
to
the
animationinspector
"
)
;
let
inspector
=
toolbox
.
getPanel
(
"
inspector
"
)
;
let
panelReady
=
waitForAnimationInspectorReady
(
inspector
)
;
info
(
"
Waiting
for
toolbox
focus
"
)
;
yield
waitForToolboxFrameFocus
(
toolbox
)
;
inspector
.
sidebar
.
select
(
TAB_NAME
)
;
info
(
"
Waiting
for
the
inspector
and
sidebar
to
be
ready
"
)
;
yield
panelReady
;
let
win
=
inspector
.
sidebar
.
getWindowForTab
(
TAB_NAME
)
;
let
{
AnimationsController
AnimationsPanel
}
=
win
;
info
(
"
Waiting
for
the
animation
controller
and
panel
to
be
ready
"
)
;
if
(
AnimationsPanel
.
initialized
)
{
yield
AnimationsPanel
.
initialized
;
}
else
{
yield
AnimationsPanel
.
once
(
AnimationsPanel
.
PANEL_INITIALIZED
)
;
}
yield
waitForAllAnimationTargets
(
AnimationsPanel
)
;
return
{
toolbox
:
toolbox
inspector
:
inspector
controller
:
AnimationsController
panel
:
AnimationsPanel
window
:
win
}
;
}
)
;
var
closeAnimationInspector
=
Task
.
async
(
function
*
(
)
{
let
target
=
TargetFactory
.
forTab
(
gBrowser
.
selectedTab
)
;
yield
gDevTools
.
closeToolbox
(
target
)
;
}
)
;
function
waitForToolboxFrameFocus
(
toolbox
)
{
info
(
"
Making
sure
that
the
toolbox
'
s
frame
is
focused
"
)
;
let
def
=
promise
.
defer
(
)
;
let
win
=
toolbox
.
frame
.
contentWindow
;
waitForFocus
(
def
.
resolve
win
)
;
return
def
.
promise
;
}
function
hasSideBarTab
(
inspector
id
)
{
return
!
!
inspector
.
sidebar
.
getWindowForTab
(
id
)
;
}
function
once
(
target
eventName
useCapture
=
false
)
{
info
(
"
Waiting
for
event
:
'
"
+
eventName
+
"
'
on
"
+
target
+
"
.
"
)
;
let
deferred
=
promise
.
defer
(
)
;
for
(
let
[
add
remove
]
of
[
[
"
addEventListener
"
"
removeEventListener
"
]
[
"
addListener
"
"
removeListener
"
]
[
"
on
"
"
off
"
]
]
)
{
if
(
(
add
in
target
)
&
&
(
remove
in
target
)
)
{
target
[
add
]
(
eventName
function
onEvent
(
.
.
.
aArgs
)
{
target
[
remove
]
(
eventName
onEvent
useCapture
)
;
deferred
.
resolve
.
apply
(
deferred
aArgs
)
;
}
useCapture
)
;
break
;
}
}
return
deferred
.
promise
;
}
function
waitForContentMessage
(
name
)
{
info
(
"
Expecting
message
"
+
name
+
"
from
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
let
def
=
promise
.
defer
(
)
;
mm
.
addMessageListener
(
name
function
onMessage
(
msg
)
{
mm
.
removeMessageListener
(
name
onMessage
)
;
def
.
resolve
(
msg
.
data
)
;
}
)
;
return
def
.
promise
;
}
function
executeInContent
(
name
data
=
{
}
objects
=
{
}
expectResponse
=
true
)
{
info
(
"
Sending
message
"
+
name
+
"
to
content
"
)
;
let
mm
=
gBrowser
.
selectedBrowser
.
messageManager
;
mm
.
sendAsyncMessage
(
name
data
objects
)
;
if
(
expectResponse
)
{
return
waitForContentMessage
(
name
)
;
}
return
promise
.
resolve
(
)
;
}
var
getAnimationPlayerState
=
Task
.
async
(
function
*
(
selector
animationIndex
=
0
)
{
let
playState
=
yield
executeInContent
(
"
Test
:
GetAnimationPlayerState
"
{
selector
animationIndex
}
)
;
return
playState
;
}
)
;
function
isNodeVisible
(
node
)
{
return
!
!
node
.
getClientRects
(
)
.
length
;
}
var
waitForAllAnimationTargets
=
Task
.
async
(
function
*
(
panel
)
{
let
targets
=
panel
.
animationsTimelineComponent
.
targetNodes
;
yield
promise
.
all
(
targets
.
map
(
t
=
>
{
if
(
!
t
.
previewer
.
nodeFront
)
{
return
t
.
once
(
"
target
-
retrieved
"
)
;
}
return
false
;
}
)
)
;
return
targets
;
}
)
;
function
*
assertScrubberMoving
(
panel
isMoving
)
{
let
timeline
=
panel
.
animationsTimelineComponent
;
let
scrubberEl
=
timeline
.
scrubberEl
;
if
(
isMoving
)
{
let
{
time
:
time1
}
=
yield
timeline
.
once
(
"
timeline
-
data
-
changed
"
)
;
let
{
time
:
time2
}
=
yield
timeline
.
once
(
"
timeline
-
data
-
changed
"
)
;
ok
(
time2
>
time1
"
The
scrubber
is
moving
"
)
;
}
else
{
let
hasMoved
=
false
;
timeline
.
once
(
"
timeline
-
data
-
changed
"
(
)
=
>
hasMoved
=
true
)
;
yield
new
Promise
(
r
=
>
setTimeout
(
r
500
)
)
;
ok
(
!
hasMoved
"
The
scrubber
is
not
moving
"
)
;
}
}
function
*
clickTimelinePlayPauseButton
(
panel
)
{
let
onUiUpdated
=
panel
.
once
(
panel
.
UI_UPDATED_EVENT
)
;
let
btn
=
panel
.
playTimelineButtonEl
;
let
win
=
btn
.
ownerDocument
.
defaultView
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
btn
win
)
;
yield
onUiUpdated
;
yield
waitForAllAnimationTargets
(
panel
)
;
}
function
*
clickTimelineRewindButton
(
panel
)
{
let
onUiUpdated
=
panel
.
once
(
panel
.
UI_UPDATED_EVENT
)
;
let
btn
=
panel
.
rewindTimelineButtonEl
;
let
win
=
btn
.
ownerDocument
.
defaultView
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
btn
win
)
;
yield
onUiUpdated
;
yield
waitForAllAnimationTargets
(
panel
)
;
}
function
*
changeTimelinePlaybackRate
(
panel
rate
)
{
let
onUiUpdated
=
panel
.
once
(
panel
.
UI_UPDATED_EVENT
)
;
let
select
=
panel
.
rateSelectorEl
.
firstChild
;
let
win
=
select
.
ownerDocument
.
defaultView
;
let
option
=
[
.
.
.
select
.
options
]
.
filter
(
o
=
>
o
.
value
=
=
=
rate
+
"
"
)
[
0
]
;
if
(
!
option
)
{
ok
(
false
"
Could
not
find
an
option
for
rate
"
+
rate
+
"
in
the
rate
selector
.
"
+
"
Values
are
:
"
+
[
.
.
.
select
.
options
]
.
map
(
o
=
>
o
.
value
)
)
;
return
;
}
EventUtils
.
synthesizeMouseAtCenter
(
select
{
type
:
"
mousedown
"
}
win
)
;
EventUtils
.
synthesizeMouseAtCenter
(
option
{
type
:
"
mouseup
"
}
win
)
;
yield
onUiUpdated
;
yield
waitForAllAnimationTargets
(
panel
)
;
EventUtils
.
synthesizeMouseAtCenter
(
win
.
document
.
querySelector
(
"
#
timeline
-
toolbar
"
)
{
type
:
"
mousemove
"
}
win
)
;
}
function
disableHighlighter
(
toolbox
)
{
toolbox
.
_highlighter
=
{
showBoxModel
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
hideBoxModel
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
pick
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
cancelPick
:
(
)
=
>
new
Promise
(
r
=
>
r
(
)
)
destroy
:
(
)
=
>
{
}
traits
:
{
}
}
;
}
function
*
clickOnAnimation
(
panel
index
shouldClose
)
{
let
timeline
=
panel
.
animationsTimelineComponent
;
let
onSelectionChanged
=
timeline
.
once
(
shouldClose
?
"
animation
-
unselected
"
:
"
animation
-
selected
"
)
;
let
onReady
=
shouldClose
?
Promise
.
resolve
(
)
:
timeline
.
details
[
index
]
.
once
(
"
keyframes
-
retrieved
"
)
;
info
(
"
Click
on
animation
"
+
index
+
"
in
the
timeline
"
)
;
let
timeBlock
=
timeline
.
rootWrapperEl
.
querySelectorAll
(
"
.
time
-
block
"
)
[
index
]
;
EventUtils
.
sendMouseEvent
(
{
type
:
"
click
"
}
timeBlock
timeBlock
.
ownerDocument
.
defaultView
)
;
yield
onReady
;
return
yield
onSelectionChanged
;
}
function
getKeyframeComponent
(
panel
animationIndex
propertyName
)
{
let
timeline
=
panel
.
animationsTimelineComponent
;
let
detailsComponent
=
timeline
.
details
[
animationIndex
]
;
return
detailsComponent
.
keyframeComponents
.
find
(
c
=
>
c
.
propertyName
=
=
=
propertyName
)
;
}
function
getKeyframeEl
(
panel
animationIndex
propertyName
keyframeIndex
)
{
let
keyframeComponent
=
getKeyframeComponent
(
panel
animationIndex
propertyName
)
;
return
keyframeComponent
.
keyframesEl
.
querySelectorAll
(
"
.
frame
"
)
[
keyframeIndex
]
;
}
