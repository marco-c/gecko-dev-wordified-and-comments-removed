"
use
strict
"
;
add_task
(
function
*
(
)
{
yield
addTab
(
URL_ROOT
+
"
doc_script_animation
.
html
"
)
;
let
{
panel
}
=
yield
openAnimationInspector
(
)
;
let
timelineComponent
=
panel
.
animationsTimelineComponent
;
let
timeBlockComponents
=
timelineComponent
.
timeBlocks
;
let
detailsComponents
=
timelineComponent
.
details
;
for
(
let
i
=
0
;
i
<
timeBlockComponents
.
length
;
i
+
+
)
{
info
(
Expand
time
block
{
i
}
so
its
keyframes
are
visible
)
;
yield
clickOnAnimation
(
panel
i
)
;
info
(
Check
the
state
of
time
block
{
i
}
)
;
let
{
containerEl
animation
:
{
state
}
}
=
timeBlockComponents
[
i
]
;
checkAnimationTooltip
(
containerEl
state
)
;
checkProgressAtStartingTime
(
containerEl
state
)
;
let
keyframeComponent
=
detailsComponents
[
i
]
.
keyframeComponents
[
0
]
;
let
frameEl
=
keyframeComponent
.
keyframesEl
.
querySelector
(
"
.
frame
"
)
;
checkKeyframeOffset
(
containerEl
frameEl
state
)
;
}
}
)
;
function
checkAnimationTooltip
(
el
{
iterationStart
duration
}
)
{
info
(
"
Check
an
animation
'
s
iterationStart
data
in
its
tooltip
"
)
;
let
title
=
el
.
querySelector
(
"
.
name
"
)
.
getAttribute
(
"
title
"
)
;
let
iterationStartTime
=
iterationStart
*
duration
/
1000
;
let
iterationStartTimeString
=
iterationStartTime
.
toLocaleString
(
undefined
{
maximumFractionDigits
:
2
minimumFractionDigits
:
2
}
)
.
replace
(
"
.
"
"
\
\
.
"
)
;
let
iterationStartString
=
iterationStart
.
toString
(
)
.
replace
(
"
.
"
"
\
\
.
"
)
;
let
regex
=
new
RegExp
(
"
Iteration
start
:
"
+
iterationStartString
+
"
\
\
(
"
+
iterationStartTimeString
+
"
s
\
\
)
"
)
;
ok
(
title
.
match
(
regex
)
"
The
tooltip
shows
the
expected
iteration
start
"
)
;
}
function
checkProgressAtStartingTime
(
el
{
iterationStart
}
)
{
info
(
"
Check
the
progress
of
starting
time
"
)
;
const
pathEl
=
el
.
querySelector
(
"
.
iteration
-
path
"
)
;
const
pathSegList
=
pathEl
.
pathSegList
;
const
pathSeg
=
pathSegList
.
getItem
(
1
)
;
const
progress
=
pathSeg
.
y
;
is
(
progress
iterationStart
%
1
The
progress
at
starting
point
should
be
{
iterationStart
%
1
}
)
;
}
function
checkKeyframeOffset
(
timeBlockEl
frameEl
{
iterationStart
}
)
{
info
(
"
Check
that
the
first
keyframe
is
offset
correctly
"
)
;
let
start
=
getKeyframeOffset
(
frameEl
)
;
is
(
start
0
"
The
frame
offset
for
iteration
start
"
)
;
}
function
getKeyframeOffset
(
el
)
{
return
parseFloat
(
/
(
\
d
+
)
%
/
.
exec
(
el
.
style
.
left
)
[
1
]
)
;
}
