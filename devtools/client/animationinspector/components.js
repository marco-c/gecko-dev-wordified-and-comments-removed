"
use
strict
"
;
const
{
Cu
}
=
require
(
"
chrome
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
ViewHelpers
.
jsm
"
)
;
const
{
Task
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
{
}
)
;
const
{
createNode
drawGraphElementBackground
findOptimalTimeInterval
TargetNodeHighlighter
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
STRINGS_URI
=
"
chrome
:
/
/
devtools
/
locale
/
animationinspector
.
properties
"
;
const
L10N
=
new
ViewHelpers
.
L10N
(
STRINGS_URI
)
;
const
MILLIS_TIME_FORMAT_MAX_DURATION
=
4000
;
const
TIME_GRADUATION_MIN_SPACING
=
40
;
const
PLAYBACK_RATES
=
[
.
1
.
25
.
5
1
2
5
10
]
;
const
FAST_TRACK_ICON_SIZE
=
20
;
function
AnimationTargetNode
(
inspector
options
=
{
}
)
{
this
.
inspector
=
inspector
;
this
.
options
=
options
;
this
.
onPreviewMouseOver
=
this
.
onPreviewMouseOver
.
bind
(
this
)
;
this
.
onPreviewMouseOut
=
this
.
onPreviewMouseOut
.
bind
(
this
)
;
this
.
onSelectNodeClick
=
this
.
onSelectNodeClick
.
bind
(
this
)
;
this
.
onMarkupMutations
=
this
.
onMarkupMutations
.
bind
(
this
)
;
this
.
onHighlightNodeClick
=
this
.
onHighlightNodeClick
.
bind
(
this
)
;
this
.
onTargetHighlighterLocked
=
this
.
onTargetHighlighterLocked
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
AnimationTargetNode
=
AnimationTargetNode
;
AnimationTargetNode
.
prototype
=
{
init
:
function
(
containerEl
)
{
let
document
=
containerEl
.
ownerDocument
;
this
.
el
=
createNode
(
{
parent
:
containerEl
attributes
:
{
"
class
"
:
"
animation
-
target
"
}
}
)
;
this
.
highlightNodeEl
=
createNode
(
{
parent
:
this
.
el
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
node
-
highlighter
"
"
title
"
:
L10N
.
getStr
(
"
node
.
highlightNodeLabel
"
)
}
}
)
;
this
.
previewEl
=
createNode
(
{
parent
:
this
.
el
nodeType
:
"
span
"
attributes
:
{
"
title
"
:
L10N
.
getStr
(
"
node
.
selectNodeLabel
"
)
}
}
)
;
if
(
!
this
.
options
.
compact
)
{
this
.
previewEl
.
appendChild
(
document
.
createTextNode
(
"
<
"
)
)
;
}
this
.
tagNameEl
=
createNode
(
{
parent
:
this
.
previewEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
tag
-
name
theme
-
fg
-
color3
"
}
}
)
;
this
.
idEl
=
createNode
(
{
parent
:
this
.
previewEl
nodeType
:
"
span
"
}
)
;
if
(
!
this
.
options
.
compact
)
{
createNode
(
{
parent
:
this
.
idEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
name
theme
-
fg
-
color2
"
}
textContent
:
"
id
"
}
)
;
this
.
idEl
.
appendChild
(
document
.
createTextNode
(
"
=
\
"
"
)
)
;
}
else
{
createNode
(
{
parent
:
this
.
idEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
theme
-
fg
-
color2
"
}
textContent
:
"
#
"
}
)
;
}
createNode
(
{
parent
:
this
.
idEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
value
theme
-
fg
-
color6
"
}
}
)
;
if
(
!
this
.
options
.
compact
)
{
this
.
idEl
.
appendChild
(
document
.
createTextNode
(
"
\
"
"
)
)
;
}
this
.
classEl
=
createNode
(
{
parent
:
this
.
previewEl
nodeType
:
"
span
"
}
)
;
if
(
!
this
.
options
.
compact
)
{
createNode
(
{
parent
:
this
.
classEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
name
theme
-
fg
-
color2
"
}
textContent
:
"
class
"
}
)
;
this
.
classEl
.
appendChild
(
document
.
createTextNode
(
"
=
\
"
"
)
)
;
}
else
{
createNode
(
{
parent
:
this
.
classEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
theme
-
fg
-
color6
"
}
textContent
:
"
.
"
}
)
;
}
createNode
(
{
parent
:
this
.
classEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
attribute
-
value
theme
-
fg
-
color6
"
}
}
)
;
if
(
!
this
.
options
.
compact
)
{
this
.
classEl
.
appendChild
(
document
.
createTextNode
(
"
\
"
"
)
)
;
this
.
previewEl
.
appendChild
(
document
.
createTextNode
(
"
>
"
)
)
;
}
this
.
startListeners
(
)
;
}
startListeners
:
function
(
)
{
this
.
previewEl
.
addEventListener
(
"
mouseover
"
this
.
onPreviewMouseOver
)
;
this
.
previewEl
.
addEventListener
(
"
mouseout
"
this
.
onPreviewMouseOut
)
;
this
.
previewEl
.
addEventListener
(
"
click
"
this
.
onSelectNodeClick
)
;
this
.
highlightNodeEl
.
addEventListener
(
"
click
"
this
.
onHighlightNodeClick
)
;
this
.
inspector
.
on
(
"
markupmutation
"
this
.
onMarkupMutations
)
;
TargetNodeHighlighter
.
on
(
"
highlighted
"
this
.
onTargetHighlighterLocked
)
;
}
stopListeners
:
function
(
)
{
TargetNodeHighlighter
.
off
(
"
highlighted
"
this
.
onTargetHighlighterLocked
)
;
this
.
inspector
.
off
(
"
markupmutation
"
this
.
onMarkupMutations
)
;
this
.
previewEl
.
removeEventListener
(
"
mouseover
"
this
.
onPreviewMouseOver
)
;
this
.
previewEl
.
removeEventListener
(
"
mouseout
"
this
.
onPreviewMouseOut
)
;
this
.
previewEl
.
removeEventListener
(
"
click
"
this
.
onSelectNodeClick
)
;
this
.
highlightNodeEl
.
removeEventListener
(
"
click
"
this
.
onHighlightNodeClick
)
;
}
destroy
:
function
(
)
{
TargetNodeHighlighter
.
unhighlight
(
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
this
.
stopListeners
(
)
;
this
.
el
.
remove
(
)
;
this
.
el
=
this
.
tagNameEl
=
this
.
idEl
=
this
.
classEl
=
null
;
this
.
highlightNodeEl
=
this
.
previewEl
=
null
;
this
.
nodeFront
=
this
.
inspector
=
this
.
playerFront
=
null
;
}
get
highlighterUtils
(
)
{
if
(
this
.
inspector
&
&
this
.
inspector
.
toolbox
)
{
return
this
.
inspector
.
toolbox
.
highlighterUtils
;
}
return
null
;
}
onPreviewMouseOver
:
function
(
)
{
if
(
!
this
.
nodeFront
|
|
!
this
.
highlighterUtils
)
{
return
;
}
this
.
highlighterUtils
.
highlightNodeFront
(
this
.
nodeFront
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
onPreviewMouseOut
:
function
(
)
{
if
(
!
this
.
nodeFront
|
|
!
this
.
highlighterUtils
)
{
return
;
}
this
.
highlighterUtils
.
unhighlight
(
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
onSelectNodeClick
:
function
(
)
{
if
(
!
this
.
nodeFront
)
{
return
;
}
this
.
inspector
.
selection
.
setNodeFront
(
this
.
nodeFront
"
animationinspector
"
)
;
}
onHighlightNodeClick
:
function
(
)
{
let
classList
=
this
.
highlightNodeEl
.
classList
;
let
isHighlighted
=
classList
.
contains
(
"
selected
"
)
;
if
(
isHighlighted
)
{
classList
.
remove
(
"
selected
"
)
;
TargetNodeHighlighter
.
unhighlight
(
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
target
-
highlighter
-
unlocked
"
)
;
}
e
=
>
console
.
error
(
e
)
)
;
}
else
{
classList
.
add
(
"
selected
"
)
;
TargetNodeHighlighter
.
highlight
(
this
)
.
then
(
(
)
=
>
{
this
.
emit
(
"
target
-
highlighter
-
locked
"
)
;
}
e
=
>
console
.
error
(
e
)
)
;
}
}
onTargetHighlighterLocked
:
function
(
e
animationTargetNode
)
{
if
(
animationTargetNode
!
=
=
this
)
{
this
.
highlightNodeEl
.
classList
.
remove
(
"
selected
"
)
;
}
}
onMarkupMutations
:
function
(
e
mutations
)
{
if
(
!
this
.
nodeFront
|
|
!
this
.
playerFront
)
{
return
;
}
for
(
let
{
target
}
of
mutations
)
{
if
(
target
=
=
=
this
.
nodeFront
)
{
this
.
render
(
this
.
playerFront
)
;
break
;
}
}
}
render
:
Task
.
async
(
function
*
(
playerFront
)
{
this
.
playerFront
=
playerFront
;
this
.
nodeFront
=
undefined
;
try
{
this
.
nodeFront
=
yield
this
.
inspector
.
walker
.
getNodeFromActor
(
playerFront
.
actorID
[
"
node
"
]
)
;
}
catch
(
e
)
{
if
(
!
this
.
el
)
{
console
.
warn
(
"
Cound
'
t
retrieve
the
animation
target
node
widget
"
+
"
destroyed
"
)
;
}
else
{
console
.
error
(
e
)
;
}
return
;
}
if
(
!
this
.
nodeFront
|
|
!
this
.
el
)
{
return
;
}
let
{
tagName
attributes
}
=
this
.
nodeFront
;
this
.
tagNameEl
.
textContent
=
tagName
.
toLowerCase
(
)
;
let
idIndex
=
attributes
.
findIndex
(
(
{
name
}
)
=
>
name
=
=
=
"
id
"
)
;
if
(
idIndex
>
-
1
&
&
attributes
[
idIndex
]
.
value
)
{
this
.
idEl
.
querySelector
(
"
.
attribute
-
value
"
)
.
textContent
=
attributes
[
idIndex
]
.
value
;
this
.
idEl
.
style
.
display
=
"
inline
"
;
}
else
{
this
.
idEl
.
style
.
display
=
"
none
"
;
}
let
classIndex
=
attributes
.
findIndex
(
(
{
name
}
)
=
>
name
=
=
=
"
class
"
)
;
if
(
classIndex
>
-
1
&
&
attributes
[
classIndex
]
.
value
)
{
let
value
=
attributes
[
classIndex
]
.
value
;
if
(
this
.
options
.
compact
)
{
value
=
value
.
split
(
"
"
)
.
join
(
"
.
"
)
;
}
this
.
classEl
.
querySelector
(
"
.
attribute
-
value
"
)
.
textContent
=
value
;
this
.
classEl
.
style
.
display
=
"
inline
"
;
}
else
{
this
.
classEl
.
style
.
display
=
"
none
"
;
}
this
.
emit
(
"
target
-
retrieved
"
)
;
}
)
}
;
function
RateSelector
(
)
{
this
.
onRateChanged
=
this
.
onRateChanged
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
RateSelector
=
RateSelector
;
RateSelector
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
selectEl
=
createNode
(
{
parent
:
containerEl
nodeType
:
"
select
"
attributes
:
{
"
class
"
:
"
devtools
-
button
"
}
}
)
;
this
.
selectEl
.
addEventListener
(
"
change
"
this
.
onRateChanged
)
;
}
destroy
:
function
(
)
{
this
.
selectEl
.
removeEventListener
(
"
change
"
this
.
onRateChanged
)
;
this
.
selectEl
.
remove
(
)
;
this
.
selectEl
=
null
;
}
getAnimationsRates
:
function
(
animations
)
{
return
sortedUnique
(
animations
.
map
(
a
=
>
a
.
state
.
playbackRate
)
)
;
}
getAllRates
:
function
(
animations
)
{
let
animationsRates
=
this
.
getAnimationsRates
(
animations
)
;
if
(
animationsRates
.
length
>
1
)
{
return
PLAYBACK_RATES
;
}
return
sortedUnique
(
PLAYBACK_RATES
.
concat
(
animationsRates
)
)
;
}
render
:
function
(
animations
)
{
let
allRates
=
this
.
getAnimationsRates
(
animations
)
;
let
hasOneRate
=
allRates
.
length
=
=
=
1
;
this
.
selectEl
.
innerHTML
=
"
"
;
if
(
!
hasOneRate
)
{
createNode
(
{
parent
:
this
.
selectEl
nodeType
:
"
option
"
attributes
:
{
value
:
"
"
selector
:
"
true
"
}
textContent
:
"
-
"
}
)
;
}
for
(
let
rate
of
this
.
getAllRates
(
animations
)
)
{
let
option
=
createNode
(
{
parent
:
this
.
selectEl
nodeType
:
"
option
"
attributes
:
{
value
:
rate
}
textContent
:
L10N
.
getFormatStr
(
"
player
.
playbackRateLabel
"
rate
)
}
)
;
if
(
hasOneRate
&
&
rate
=
=
=
allRates
[
0
]
)
{
option
.
setAttribute
(
"
selected
"
"
true
"
)
;
}
}
}
onRateChanged
:
function
(
)
{
let
rate
=
parseFloat
(
this
.
selectEl
.
value
)
;
if
(
!
isNaN
(
rate
)
)
{
this
.
emit
(
"
rate
-
changed
"
rate
)
;
}
}
}
;
var
TimeScale
=
{
minStartTime
:
Infinity
maxEndTime
:
0
addAnimation
:
function
(
state
)
{
let
{
previousStartTime
delay
duration
iterationCount
playbackRate
}
=
state
;
let
relevantDelay
=
delay
<
0
?
delay
/
playbackRate
:
0
;
previousStartTime
=
previousStartTime
|
|
0
;
this
.
minStartTime
=
Math
.
min
(
this
.
minStartTime
previousStartTime
+
relevantDelay
)
;
let
length
=
(
delay
/
playbackRate
)
+
(
(
duration
/
playbackRate
)
*
(
!
iterationCount
?
1
:
iterationCount
)
)
;
this
.
maxEndTime
=
Math
.
max
(
this
.
maxEndTime
previousStartTime
+
length
)
;
}
reset
:
function
(
)
{
this
.
minStartTime
=
Infinity
;
this
.
maxEndTime
=
0
;
}
startTimeToDistance
:
function
(
time
containerWidth
)
{
time
-
=
this
.
minStartTime
;
return
this
.
durationToDistance
(
time
containerWidth
)
;
}
durationToDistance
:
function
(
duration
containerWidth
)
{
return
containerWidth
*
duration
/
(
this
.
maxEndTime
-
this
.
minStartTime
)
;
}
distanceToTime
:
function
(
distance
containerWidth
)
{
return
this
.
minStartTime
+
(
(
this
.
maxEndTime
-
this
.
minStartTime
)
*
distance
/
containerWidth
)
;
}
distanceToRelativeTime
:
function
(
distance
containerWidth
)
{
let
time
=
this
.
distanceToTime
(
distance
containerWidth
)
;
return
time
-
this
.
minStartTime
;
}
formatTime
:
function
(
time
)
{
let
duration
=
this
.
maxEndTime
-
this
.
minStartTime
;
if
(
duration
<
=
MILLIS_TIME_FORMAT_MAX_DURATION
)
{
return
L10N
.
getFormatStr
(
"
timeline
.
timeGraduationLabel
"
time
.
toFixed
(
0
)
)
;
}
return
L10N
.
getFormatStr
(
"
player
.
timeLabel
"
(
time
/
1000
)
.
toFixed
(
1
)
)
;
}
}
;
exports
.
TimeScale
=
TimeScale
;
function
AnimationsTimeline
(
inspector
)
{
this
.
animations
=
[
]
;
this
.
targetNodes
=
[
]
;
this
.
timeBlocks
=
[
]
;
this
.
inspector
=
inspector
;
this
.
onAnimationStateChanged
=
this
.
onAnimationStateChanged
.
bind
(
this
)
;
this
.
onScrubberMouseDown
=
this
.
onScrubberMouseDown
.
bind
(
this
)
;
this
.
onScrubberMouseUp
=
this
.
onScrubberMouseUp
.
bind
(
this
)
;
this
.
onScrubberMouseOut
=
this
.
onScrubberMouseOut
.
bind
(
this
)
;
this
.
onScrubberMouseMove
=
this
.
onScrubberMouseMove
.
bind
(
this
)
;
this
.
onAnimationSelected
=
this
.
onAnimationSelected
.
bind
(
this
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
AnimationsTimeline
=
AnimationsTimeline
;
AnimationsTimeline
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
win
=
containerEl
.
ownerDocument
.
defaultView
;
this
.
rootWrapperEl
=
createNode
(
{
parent
:
containerEl
attributes
:
{
"
class
"
:
"
animation
-
timeline
"
}
}
)
;
this
.
scrubberEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
attributes
:
{
"
class
"
:
"
scrubber
"
}
}
)
;
this
.
scrubberHandleEl
=
createNode
(
{
parent
:
this
.
scrubberEl
attributes
:
{
"
class
"
:
"
scrubber
-
handle
"
}
}
)
;
this
.
scrubberHandleEl
.
addEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
timeHeaderEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
attributes
:
{
"
class
"
:
"
time
-
header
"
}
}
)
;
this
.
timeHeaderEl
.
addEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
animationsEl
=
createNode
(
{
parent
:
this
.
rootWrapperEl
nodeType
:
"
ul
"
attributes
:
{
"
class
"
:
"
animations
"
}
}
)
;
}
destroy
:
function
(
)
{
this
.
stopAnimatingScrubber
(
)
;
this
.
unrender
(
)
;
this
.
timeHeaderEl
.
removeEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
scrubberHandleEl
.
removeEventListener
(
"
mousedown
"
this
.
onScrubberMouseDown
)
;
this
.
rootWrapperEl
.
remove
(
)
;
this
.
animations
=
[
]
;
this
.
rootWrapperEl
=
null
;
this
.
timeHeaderEl
=
null
;
this
.
animationsEl
=
null
;
this
.
scrubberEl
=
null
;
this
.
scrubberHandleEl
=
null
;
this
.
win
=
null
;
this
.
inspector
=
null
;
}
destroyTargetNodes
:
function
(
)
{
for
(
let
targetNode
of
this
.
targetNodes
)
{
targetNode
.
destroy
(
)
;
}
this
.
targetNodes
=
[
]
;
}
destroyTimeBlocks
:
function
(
)
{
for
(
let
timeBlock
of
this
.
timeBlocks
)
{
timeBlock
.
off
(
"
selected
"
this
.
onAnimationSelected
)
;
timeBlock
.
destroy
(
)
;
}
this
.
timeBlocks
=
[
]
;
}
unrender
:
function
(
)
{
for
(
let
animation
of
this
.
animations
)
{
animation
.
off
(
"
changed
"
this
.
onAnimationStateChanged
)
;
}
TimeScale
.
reset
(
)
;
this
.
destroyTargetNodes
(
)
;
this
.
destroyTimeBlocks
(
)
;
this
.
animationsEl
.
innerHTML
=
"
"
;
}
onAnimationSelected
:
function
(
e
animation
)
{
[
.
.
.
this
.
rootWrapperEl
.
querySelectorAll
(
"
.
animation
.
selected
"
)
]
.
forEach
(
el
=
>
{
el
.
classList
.
remove
(
"
selected
"
)
;
}
)
;
let
index
=
this
.
animations
.
indexOf
(
animation
)
;
if
(
index
=
=
=
-
1
)
{
return
;
}
this
.
rootWrapperEl
.
querySelectorAll
(
"
.
animation
"
)
[
index
]
.
classList
.
toggle
(
"
selected
"
)
;
this
.
emit
(
"
selected
"
animation
)
;
}
onScrubberMouseDown
:
function
(
e
)
{
this
.
moveScrubberTo
(
e
.
pageX
)
;
this
.
win
.
addEventListener
(
"
mouseup
"
this
.
onScrubberMouseUp
)
;
this
.
win
.
addEventListener
(
"
mouseout
"
this
.
onScrubberMouseOut
)
;
this
.
win
.
addEventListener
(
"
mousemove
"
this
.
onScrubberMouseMove
)
;
e
.
preventDefault
(
)
;
}
onScrubberMouseUp
:
function
(
)
{
this
.
cancelTimeHeaderDragging
(
)
;
}
onScrubberMouseOut
:
function
(
e
)
{
if
(
!
this
.
win
.
document
.
contains
(
e
.
relatedTarget
)
)
{
this
.
cancelTimeHeaderDragging
(
)
;
}
}
cancelTimeHeaderDragging
:
function
(
)
{
this
.
win
.
removeEventListener
(
"
mouseup
"
this
.
onScrubberMouseUp
)
;
this
.
win
.
removeEventListener
(
"
mouseout
"
this
.
onScrubberMouseOut
)
;
this
.
win
.
removeEventListener
(
"
mousemove
"
this
.
onScrubberMouseMove
)
;
}
onScrubberMouseMove
:
function
(
e
)
{
this
.
moveScrubberTo
(
e
.
pageX
)
;
}
moveScrubberTo
:
function
(
pageX
)
{
this
.
stopAnimatingScrubber
(
)
;
let
offset
=
pageX
-
this
.
scrubberEl
.
offsetWidth
;
if
(
offset
<
0
)
{
offset
=
0
;
}
this
.
scrubberEl
.
style
.
left
=
offset
+
"
px
"
;
let
time
=
TimeScale
.
distanceToRelativeTime
(
offset
this
.
timeHeaderEl
.
offsetWidth
)
;
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
true
isMoving
:
false
isUserDrag
:
true
time
:
time
}
)
;
}
render
:
function
(
animations
documentCurrentTime
)
{
this
.
unrender
(
)
;
this
.
animations
=
animations
;
if
(
!
this
.
animations
.
length
)
{
return
;
}
for
(
let
{
state
}
of
animations
)
{
TimeScale
.
addAnimation
(
state
)
;
}
this
.
drawHeaderAndBackground
(
)
;
for
(
let
animation
of
this
.
animations
)
{
animation
.
on
(
"
changed
"
this
.
onAnimationStateChanged
)
;
let
animationEl
=
createNode
(
{
parent
:
this
.
animationsEl
nodeType
:
"
li
"
attributes
:
{
"
class
"
:
"
animation
"
+
(
animation
.
state
.
isRunningOnCompositor
?
"
fast
-
track
"
:
"
"
)
}
}
)
;
let
animatedNodeEl
=
createNode
(
{
parent
:
animationEl
attributes
:
{
"
class
"
:
"
target
"
}
}
)
;
let
targetNode
=
new
AnimationTargetNode
(
this
.
inspector
{
compact
:
true
}
)
;
targetNode
.
init
(
animatedNodeEl
)
;
targetNode
.
render
(
animation
)
;
this
.
targetNodes
.
push
(
targetNode
)
;
let
timeBlockEl
=
createNode
(
{
parent
:
animationEl
attributes
:
{
"
class
"
:
"
time
-
block
"
}
}
)
;
let
timeBlock
=
new
AnimationTimeBlock
(
)
;
timeBlock
.
init
(
timeBlockEl
)
;
timeBlock
.
render
(
animation
)
;
this
.
timeBlocks
.
push
(
timeBlock
)
;
timeBlock
.
on
(
"
selected
"
this
.
onAnimationSelected
)
;
}
if
(
!
documentCurrentTime
)
{
this
.
scrubberEl
.
style
.
display
=
"
none
"
;
}
else
{
this
.
scrubberEl
.
style
.
display
=
"
block
"
;
this
.
startAnimatingScrubber
(
this
.
wasRewound
(
)
?
TimeScale
.
minStartTime
:
documentCurrentTime
)
;
}
}
isAtLeastOneAnimationPlaying
:
function
(
)
{
return
this
.
animations
.
some
(
(
{
state
}
)
=
>
state
.
playState
=
=
=
"
running
"
)
;
}
wasRewound
:
function
(
)
{
return
!
this
.
isAtLeastOneAnimationPlaying
(
)
&
&
this
.
animations
.
every
(
(
{
state
}
)
=
>
state
.
currentTime
=
=
=
0
)
;
}
hasInfiniteAnimations
:
function
(
)
{
return
this
.
animations
.
some
(
(
{
state
}
)
=
>
!
state
.
iterationCount
)
;
}
startAnimatingScrubber
:
function
(
time
)
{
let
x
=
TimeScale
.
startTimeToDistance
(
time
this
.
timeHeaderEl
.
offsetWidth
)
;
this
.
scrubberEl
.
style
.
left
=
x
+
"
px
"
;
let
isOutOfBounds
=
time
<
TimeScale
.
minStartTime
|
|
time
>
TimeScale
.
maxEndTime
;
let
isAllPaused
=
!
this
.
isAtLeastOneAnimationPlaying
(
)
;
let
hasInfinite
=
this
.
hasInfiniteAnimations
(
)
;
if
(
isAllPaused
|
|
(
isOutOfBounds
&
&
!
hasInfinite
)
)
{
this
.
stopAnimatingScrubber
(
)
;
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
!
this
.
isAtLeastOneAnimationPlaying
(
)
isMoving
:
false
isUserDrag
:
false
time
:
TimeScale
.
distanceToRelativeTime
(
x
this
.
timeHeaderEl
.
offsetWidth
)
}
)
;
return
;
}
this
.
emit
(
"
timeline
-
data
-
changed
"
{
isPaused
:
false
isMoving
:
true
isUserDrag
:
false
time
:
TimeScale
.
distanceToRelativeTime
(
x
this
.
timeHeaderEl
.
offsetWidth
)
}
)
;
let
now
=
this
.
win
.
performance
.
now
(
)
;
this
.
rafID
=
this
.
win
.
requestAnimationFrame
(
(
)
=
>
{
if
(
!
this
.
rafID
)
{
return
;
}
this
.
startAnimatingScrubber
(
time
+
this
.
win
.
performance
.
now
(
)
-
now
)
;
}
)
;
}
stopAnimatingScrubber
:
function
(
)
{
if
(
this
.
rafID
)
{
this
.
win
.
cancelAnimationFrame
(
this
.
rafID
)
;
this
.
rafID
=
null
;
}
}
onAnimationStateChanged
:
function
(
)
{
this
.
render
(
this
.
animations
)
;
}
drawHeaderAndBackground
:
function
(
)
{
let
width
=
this
.
timeHeaderEl
.
offsetWidth
;
let
scale
=
width
/
(
TimeScale
.
maxEndTime
-
TimeScale
.
minStartTime
)
;
drawGraphElementBackground
(
this
.
win
.
document
"
time
-
graduations
"
width
scale
)
;
this
.
timeHeaderEl
.
innerHTML
=
"
"
;
let
interval
=
findOptimalTimeInterval
(
scale
TIME_GRADUATION_MIN_SPACING
)
;
for
(
let
i
=
0
;
i
<
width
;
i
+
=
interval
)
{
createNode
(
{
parent
:
this
.
timeHeaderEl
nodeType
:
"
span
"
attributes
:
{
"
class
"
:
"
time
-
tick
"
"
style
"
:
left
:
{
i
}
px
}
textContent
:
TimeScale
.
formatTime
(
TimeScale
.
distanceToRelativeTime
(
i
width
)
)
}
)
;
}
}
}
;
function
AnimationTimeBlock
(
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
onClick
=
this
.
onClick
.
bind
(
this
)
;
}
exports
.
AnimationTimeBlock
=
AnimationTimeBlock
;
AnimationTimeBlock
.
prototype
=
{
init
:
function
(
containerEl
)
{
this
.
containerEl
=
containerEl
;
this
.
containerEl
.
addEventListener
(
"
click
"
this
.
onClick
)
;
}
destroy
:
function
(
)
{
this
.
containerEl
.
removeEventListener
(
"
click
"
this
.
onClick
)
;
while
(
this
.
containerEl
.
firstChild
)
{
this
.
containerEl
.
firstChild
.
remove
(
)
;
}
this
.
containerEl
=
null
;
this
.
animation
=
null
;
}
render
:
function
(
animation
)
{
this
.
animation
=
animation
;
let
{
state
}
=
this
.
animation
;
let
width
=
this
.
containerEl
.
offsetWidth
;
let
start
=
state
.
previousStartTime
|
|
0
;
let
duration
=
state
.
duration
;
let
rate
=
state
.
playbackRate
;
let
count
=
state
.
iterationCount
;
let
delay
=
state
.
delay
|
|
0
;
let
x
=
TimeScale
.
startTimeToDistance
(
start
+
(
delay
/
rate
)
width
)
;
let
w
=
TimeScale
.
durationToDistance
(
duration
/
rate
width
)
;
let
iterationW
=
w
*
(
count
|
|
1
)
;
let
delayW
=
TimeScale
.
durationToDistance
(
Math
.
abs
(
delay
)
/
rate
width
)
;
let
iterations
=
createNode
(
{
parent
:
this
.
containerEl
attributes
:
{
"
class
"
:
state
.
type
+
"
iterations
"
+
(
count
?
"
"
:
"
infinite
"
)
"
style
"
:
left
:
{
x
}
px
;
width
:
{
iterationW
}
px
;
background
-
size
:
{
Math
.
max
(
w
2
)
}
px
100
%
;
}
}
)
;
let
negativeDelayW
=
delay
<
0
?
delayW
:
0
;
createNode
(
{
parent
:
iterations
attributes
:
{
"
class
"
:
"
name
"
"
title
"
:
this
.
getTooltipText
(
state
)
"
style
"
:
"
background
-
position
:
"
+
(
iterationW
-
FAST_TRACK_ICON_SIZE
-
negativeDelayW
)
+
"
px
center
;
margin
-
left
:
"
+
negativeDelayW
+
"
px
"
}
textContent
:
state
.
name
}
)
;
if
(
delay
)
{
let
delayX
=
TimeScale
.
durationToDistance
(
(
delay
<
0
?
0
:
delay
)
/
rate
width
)
;
createNode
(
{
parent
:
iterations
attributes
:
{
"
class
"
:
"
delay
"
+
(
delay
<
0
?
"
negative
"
:
"
"
)
"
style
"
:
left
:
-
{
delayX
}
px
;
width
:
{
delayW
}
px
;
}
}
)
;
}
}
getTooltipText
:
function
(
state
)
{
let
getTime
=
time
=
>
L10N
.
getFormatStr
(
"
player
.
timeLabel
"
L10N
.
numberWithDecimals
(
time
/
1000
2
)
)
;
let
text
=
"
"
;
text
+
=
state
.
type
?
L10N
.
getFormatStr
(
"
timeline
.
"
+
state
.
type
+
"
.
nameLabel
"
state
.
name
)
:
state
.
name
;
text
+
=
"
\
n
"
;
text
+
=
L10N
.
getStr
(
"
player
.
animationDelayLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
delay
)
;
text
+
=
"
\
n
"
;
text
+
=
L10N
.
getStr
(
"
player
.
animationDurationLabel
"
)
+
"
"
;
text
+
=
getTime
(
state
.
duration
)
;
text
+
=
"
\
n
"
;
text
+
=
L10N
.
getStr
(
"
player
.
animationIterationCountLabel
"
)
+
"
"
;
text
+
=
state
.
iterationCount
|
|
L10N
.
getStr
(
"
player
.
infiniteIterationCountText
"
)
;
text
+
=
"
\
n
"
;
if
(
state
.
playbackRate
!
=
=
1
)
{
text
+
=
L10N
.
getStr
(
"
player
.
animationRateLabel
"
)
+
"
"
;
text
+
=
state
.
playbackRate
;
text
+
=
"
\
n
"
;
}
if
(
state
.
isRunningOnCompositor
)
{
text
+
=
L10N
.
getStr
(
"
player
.
runningOnCompositorTooltip
"
)
;
}
return
text
;
}
onClick
:
function
(
)
{
this
.
emit
(
"
selected
"
this
.
animation
)
;
}
}
;
let
sortedUnique
=
arr
=
>
[
.
.
.
new
Set
(
arr
)
]
.
sort
(
(
a
b
)
=
>
a
>
b
)
;
