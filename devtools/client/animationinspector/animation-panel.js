"
use
strict
"
;
const
{
AnimationsTimeline
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
animation
-
timeline
"
)
;
const
{
RateSelector
}
=
require
(
"
devtools
/
client
/
animationinspector
/
components
/
rate
-
selector
"
)
;
const
{
formatStopwatchTime
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
var
=
(
selector
target
=
document
)
=
>
target
.
querySelector
(
selector
)
;
var
AnimationsPanel
=
{
UI_UPDATED_EVENT
:
"
ui
-
updated
"
PANEL_INITIALIZED
:
"
panel
-
initialized
"
initialize
:
Task
.
async
(
function
*
(
)
{
if
(
AnimationsController
.
destroyed
)
{
console
.
warn
(
"
Could
not
initialize
the
animation
-
panel
controller
"
+
"
was
destroyed
"
)
;
return
;
}
if
(
this
.
initialized
)
{
yield
this
.
initialized
.
promise
;
return
;
}
this
.
initialized
=
promise
.
defer
(
)
;
this
.
playersEl
=
(
"
#
players
"
)
;
this
.
errorMessageEl
=
(
"
#
error
-
message
"
)
;
this
.
pickerButtonEl
=
(
"
#
element
-
picker
"
)
;
this
.
toggleAllButtonEl
=
(
"
#
toggle
-
all
"
)
;
this
.
playTimelineButtonEl
=
(
"
#
pause
-
resume
-
timeline
"
)
;
this
.
rewindTimelineButtonEl
=
(
"
#
rewind
-
timeline
"
)
;
this
.
timelineCurrentTimeEl
=
(
"
#
timeline
-
current
-
time
"
)
;
this
.
rateSelectorEl
=
(
"
#
timeline
-
rate
"
)
;
if
(
!
AnimationsController
.
traits
.
hasToggleAll
)
{
(
"
#
global
-
toolbar
"
)
.
style
.
display
=
"
none
"
;
}
for
(
let
functionName
of
[
"
onPickerStarted
"
"
onPickerStopped
"
"
refreshAnimationsUI
"
"
toggleAll
"
"
onTabNavigated
"
"
onTimelineDataChanged
"
"
playPauseTimeline
"
"
rewindTimeline
"
"
onRateChanged
"
]
)
{
this
[
functionName
]
=
this
[
functionName
]
.
bind
(
this
)
;
}
let
hUtils
=
gToolbox
.
highlighterUtils
;
this
.
togglePicker
=
hUtils
.
togglePicker
.
bind
(
hUtils
)
;
this
.
animationsTimelineComponent
=
new
AnimationsTimeline
(
gInspector
)
;
this
.
animationsTimelineComponent
.
init
(
this
.
playersEl
)
;
if
(
AnimationsController
.
traits
.
hasSetPlaybackRate
)
{
this
.
rateSelectorComponent
=
new
RateSelector
(
)
;
this
.
rateSelectorComponent
.
init
(
this
.
rateSelectorEl
)
;
}
this
.
startListeners
(
)
;
yield
this
.
refreshAnimationsUI
(
)
;
this
.
initialized
.
resolve
(
)
;
this
.
emit
(
this
.
PANEL_INITIALIZED
)
;
}
)
destroy
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
initialized
)
{
return
;
}
if
(
this
.
destroyed
)
{
yield
this
.
destroyed
.
promise
;
return
;
}
this
.
destroyed
=
promise
.
defer
(
)
;
this
.
stopListeners
(
)
;
this
.
animationsTimelineComponent
.
destroy
(
)
;
this
.
animationsTimelineComponent
=
null
;
if
(
this
.
rateSelectorComponent
)
{
this
.
rateSelectorComponent
.
destroy
(
)
;
this
.
rateSelectorComponent
=
null
;
}
this
.
playersEl
=
this
.
errorMessageEl
=
null
;
this
.
toggleAllButtonEl
=
this
.
pickerButtonEl
=
null
;
this
.
playTimelineButtonEl
=
this
.
rewindTimelineButtonEl
=
null
;
this
.
timelineCurrentTimeEl
=
this
.
rateSelectorEl
=
null
;
this
.
destroyed
.
resolve
(
)
;
}
)
startListeners
:
function
(
)
{
AnimationsController
.
on
(
AnimationsController
.
PLAYERS_UPDATED_EVENT
this
.
refreshAnimationsUI
)
;
this
.
pickerButtonEl
.
addEventListener
(
"
click
"
this
.
togglePicker
)
;
gToolbox
.
on
(
"
picker
-
started
"
this
.
onPickerStarted
)
;
gToolbox
.
on
(
"
picker
-
stopped
"
this
.
onPickerStopped
)
;
this
.
toggleAllButtonEl
.
addEventListener
(
"
click
"
this
.
toggleAll
)
;
this
.
playTimelineButtonEl
.
addEventListener
(
"
click
"
this
.
playPauseTimeline
)
;
this
.
rewindTimelineButtonEl
.
addEventListener
(
"
click
"
this
.
rewindTimeline
)
;
gToolbox
.
target
.
on
(
"
navigate
"
this
.
onTabNavigated
)
;
this
.
animationsTimelineComponent
.
on
(
"
timeline
-
data
-
changed
"
this
.
onTimelineDataChanged
)
;
if
(
this
.
rateSelectorComponent
)
{
this
.
rateSelectorComponent
.
on
(
"
rate
-
changed
"
this
.
onRateChanged
)
;
}
}
stopListeners
:
function
(
)
{
AnimationsController
.
off
(
AnimationsController
.
PLAYERS_UPDATED_EVENT
this
.
refreshAnimationsUI
)
;
this
.
pickerButtonEl
.
removeEventListener
(
"
click
"
this
.
togglePicker
)
;
gToolbox
.
off
(
"
picker
-
started
"
this
.
onPickerStarted
)
;
gToolbox
.
off
(
"
picker
-
stopped
"
this
.
onPickerStopped
)
;
this
.
toggleAllButtonEl
.
removeEventListener
(
"
click
"
this
.
toggleAll
)
;
this
.
playTimelineButtonEl
.
removeEventListener
(
"
click
"
this
.
playPauseTimeline
)
;
this
.
rewindTimelineButtonEl
.
removeEventListener
(
"
click
"
this
.
rewindTimeline
)
;
gToolbox
.
target
.
off
(
"
navigate
"
this
.
onTabNavigated
)
;
this
.
animationsTimelineComponent
.
off
(
"
timeline
-
data
-
changed
"
this
.
onTimelineDataChanged
)
;
if
(
this
.
rateSelectorComponent
)
{
this
.
rateSelectorComponent
.
off
(
"
rate
-
changed
"
this
.
onRateChanged
)
;
}
}
togglePlayers
:
function
(
isVisible
)
{
if
(
isVisible
)
{
document
.
body
.
removeAttribute
(
"
empty
"
)
;
document
.
body
.
setAttribute
(
"
timeline
"
"
true
"
)
;
}
else
{
document
.
body
.
setAttribute
(
"
empty
"
"
true
"
)
;
document
.
body
.
removeAttribute
(
"
timeline
"
)
;
}
}
onPickerStarted
:
function
(
)
{
this
.
pickerButtonEl
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
onPickerStopped
:
function
(
)
{
this
.
pickerButtonEl
.
removeAttribute
(
"
checked
"
)
;
}
toggleAll
:
Task
.
async
(
function
*
(
)
{
this
.
toggleAllButtonEl
.
classList
.
toggle
(
"
paused
"
)
;
yield
AnimationsController
.
toggleAll
(
)
;
}
)
playPauseTimeline
:
function
(
)
{
AnimationsController
.
toggleCurrentAnimations
(
this
.
timelineData
.
isMoving
)
.
then
(
(
)
=
>
this
.
refreshAnimationsStateAndUI
(
)
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
rewindTimeline
:
function
(
)
{
AnimationsController
.
setCurrentTimeAll
(
0
true
)
.
then
(
(
)
=
>
this
.
refreshAnimationsStateAndUI
(
)
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
onRateChanged
:
function
(
e
rate
)
{
AnimationsController
.
setPlaybackRateAll
(
rate
)
.
then
(
(
)
=
>
this
.
refreshAnimationsStateAndUI
(
)
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
}
onTabNavigated
:
function
(
)
{
this
.
toggleAllButtonEl
.
classList
.
remove
(
"
paused
"
)
;
}
onTimelineDataChanged
:
function
(
e
data
)
{
this
.
timelineData
=
data
;
let
{
isMoving
isUserDrag
time
}
=
data
;
this
.
playTimelineButtonEl
.
classList
.
toggle
(
"
paused
"
!
isMoving
)
;
if
(
isUserDrag
&
&
!
this
.
setCurrentTimeAllPromise
)
{
this
.
setCurrentTimeAllPromise
=
AnimationsController
.
setCurrentTimeAll
(
time
true
)
.
catch
(
error
=
>
console
.
error
(
error
)
)
.
then
(
(
)
=
>
this
.
setCurrentTimeAllPromise
=
null
)
;
}
this
.
displayTimelineCurrentTime
(
)
;
}
displayTimelineCurrentTime
:
function
(
)
{
let
{
time
}
=
this
.
timelineData
;
this
.
timelineCurrentTimeEl
.
textContent
=
formatStopwatchTime
(
time
)
;
}
refreshAnimationsStateAndUI
:
Task
.
async
(
function
*
(
)
{
for
(
let
player
of
AnimationsController
.
animationPlayers
)
{
yield
player
.
refreshState
(
)
;
}
yield
this
.
refreshAnimationsUI
(
)
;
}
)
refreshAnimationsUI
:
Task
.
async
(
function
*
(
)
{
this
.
togglePlayers
(
true
)
;
this
.
animationsTimelineComponent
.
render
(
AnimationsController
.
animationPlayers
AnimationsController
.
documentCurrentTime
)
;
if
(
this
.
rateSelectorComponent
)
{
this
.
rateSelectorComponent
.
render
(
AnimationsController
.
animationPlayers
)
;
}
if
(
!
AnimationsController
.
animationPlayers
.
length
)
{
this
.
togglePlayers
(
false
)
;
this
.
emit
(
this
.
UI_UPDATED_EVENT
)
;
return
;
}
this
.
emit
(
this
.
UI_UPDATED_EVENT
)
;
}
)
}
;
EventEmitter
.
decorate
(
AnimationsPanel
)
;
