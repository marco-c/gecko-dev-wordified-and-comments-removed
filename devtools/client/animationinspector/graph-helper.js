"
use
strict
"
;
const
{
createSVGNode
getJsPropertyName
}
=
require
(
"
devtools
/
client
/
animationinspector
/
utils
"
)
;
const
{
colorUtils
}
=
require
(
"
devtools
/
shared
/
css
/
color
.
js
"
)
;
const
{
parseTimingFunction
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
CubicBezierWidget
"
)
;
const
DURATION_RESOLUTION
=
4
;
const
DEFAULT_MIN_PROGRESS_THRESHOLD
=
0
.
1
;
exports
.
DEFAULT_MIN_PROGRESS_THRESHOLD
=
DEFAULT_MIN_PROGRESS_THRESHOLD
;
const
BOUND_EXCLUDING_TIME
=
0
.
001
;
function
ProgressGraphHelper
(
win
propertyCSSName
animationType
keyframes
duration
)
{
this
.
win
=
win
;
const
doc
=
this
.
win
.
document
;
this
.
targetEl
=
doc
.
createElement
(
"
div
"
)
;
doc
.
documentElement
.
appendChild
(
this
.
targetEl
)
;
this
.
propertyCSSName
=
propertyCSSName
;
this
.
propertyJSName
=
getJsPropertyName
(
this
.
propertyCSSName
)
;
this
.
animationType
=
animationType
;
const
keyframesObject
=
keyframes
.
map
(
keyframe
=
>
{
const
keyframeObject
=
Object
.
assign
(
{
}
keyframe
)
;
keyframeObject
[
this
.
propertyJSName
]
=
keyframe
.
value
;
return
keyframeObject
;
}
)
;
const
effectTiming
=
{
duration
:
duration
fill
:
"
forwards
"
}
;
this
.
keyframes
=
keyframesObject
;
this
.
devtoolsKeyframes
=
keyframes
;
this
.
animation
=
this
.
targetEl
.
animate
(
this
.
keyframes
effectTiming
)
;
this
.
animation
.
pause
(
)
;
this
.
valueHelperFunction
=
this
.
getValueHelperFunction
(
)
;
}
ProgressGraphHelper
.
prototype
=
{
destroy
:
function
(
)
{
this
.
targetEl
.
remove
(
)
;
this
.
animation
.
cancel
(
)
;
this
.
targetEl
=
null
;
this
.
animation
=
null
;
this
.
valueHelperFunction
=
null
;
this
.
propertyCSSName
=
null
;
this
.
propertyJSName
=
null
;
this
.
animationType
=
null
;
this
.
keyframes
=
null
;
this
.
win
=
null
;
}
getGraphType
:
function
(
)
{
return
(
this
.
propertyJSName
=
=
=
"
opacity
"
|
|
this
.
propertyJSName
=
=
=
"
transform
"
)
?
this
.
propertyJSName
:
this
.
animationType
;
}
getSegment
:
function
(
time
)
{
this
.
animation
.
currentTime
=
time
;
const
style
=
this
.
win
.
getComputedStyle
(
this
.
targetEl
)
[
this
.
propertyJSName
]
;
const
value
=
this
.
valueHelperFunction
(
style
)
;
return
{
x
:
time
y
:
value
style
:
style
}
;
}
getValueHelperFunction
:
function
(
)
{
switch
(
this
.
animationType
)
{
case
"
none
"
:
{
return
(
)
=
>
1
;
}
case
"
float
"
:
{
return
this
.
getFloatValueHelperFunction
(
)
;
}
case
"
coord
"
:
{
return
this
.
getCoordinateValueHelperFunction
(
)
;
}
case
"
color
"
:
{
return
this
.
getColorValueHelperFunction
(
)
;
}
case
"
discrete
"
:
{
return
this
.
getDiscreteValueHelperFunction
(
)
;
}
}
return
null
;
}
getFloatValueHelperFunction
:
function
(
)
{
let
maxValue
=
0
;
let
minValue
=
Infinity
;
this
.
keyframes
.
forEach
(
keyframe
=
>
{
maxValue
=
Math
.
max
(
maxValue
keyframe
.
value
)
;
minValue
=
Math
.
min
(
minValue
keyframe
.
value
)
;
}
)
;
const
distance
=
maxValue
-
minValue
;
return
value
=
>
{
return
(
value
-
minValue
)
/
distance
;
}
;
}
getCoordinateValueHelperFunction
:
function
(
)
{
let
maxValue
=
0
;
let
minValue
=
Infinity
;
for
(
let
i
=
0
n
=
this
.
keyframes
.
length
;
i
<
n
;
i
+
+
)
{
if
(
this
.
keyframes
[
i
]
.
value
.
match
(
/
calc
/
)
)
{
return
null
;
}
const
value
=
parseFloat
(
this
.
keyframes
[
i
]
.
value
)
;
minValue
=
Math
.
min
(
minValue
value
)
;
maxValue
=
Math
.
max
(
maxValue
value
)
;
}
const
distance
=
maxValue
-
minValue
;
return
value
=
>
{
return
(
parseFloat
(
value
)
-
minValue
)
/
distance
;
}
;
}
getColorValueHelperFunction
:
function
(
)
{
const
maxObject
=
{
distance
:
0
}
;
for
(
let
i
=
0
;
i
<
this
.
keyframes
.
length
-
1
;
i
+
+
)
{
const
value1
=
getRGBA
(
this
.
keyframes
[
i
]
.
value
)
;
for
(
let
j
=
i
+
1
;
j
<
this
.
keyframes
.
length
;
j
+
+
)
{
const
value2
=
getRGBA
(
this
.
keyframes
[
j
]
.
value
)
;
const
distance
=
getRGBADistance
(
value1
value2
)
;
if
(
maxObject
.
distance
>
=
distance
)
{
continue
;
}
maxObject
.
distance
=
distance
;
maxObject
.
value1
=
value1
;
maxObject
.
value2
=
value2
;
}
}
const
baseValue
=
maxObject
.
value1
<
maxObject
.
value2
?
maxObject
.
value1
:
maxObject
.
value2
;
return
value
=
>
{
const
colorValue
=
getRGBA
(
value
)
;
return
getRGBADistance
(
baseValue
colorValue
)
/
maxObject
.
distance
;
}
;
}
getDiscreteValueHelperFunction
:
function
(
)
{
const
discreteValues
=
[
]
;
this
.
keyframes
.
forEach
(
keyframe
=
>
{
if
(
!
discreteValues
.
includes
(
keyframe
.
value
)
)
{
discreteValues
.
push
(
keyframe
.
value
)
;
}
}
)
;
return
value
=
>
{
return
discreteValues
.
indexOf
(
value
)
/
(
discreteValues
.
length
-
1
)
;
}
;
}
createPathSegments
:
function
(
startTime
endTime
minSegmentDuration
minProgressThreshold
)
{
return
!
this
.
valueHelperFunction
?
createKeyframesPathSegments
(
endTime
-
startTime
this
.
devtoolsKeyframes
)
:
createPathSegments
(
startTime
endTime
minSegmentDuration
minProgressThreshold
this
)
;
}
}
;
exports
.
ProgressGraphHelper
=
ProgressGraphHelper
;
function
createPathSegments
(
startTime
endTime
minSegmentDuration
minProgressThreshold
segmentHelper
)
{
if
(
endTime
-
startTime
<
minSegmentDuration
)
{
return
[
segmentHelper
.
getSegment
(
startTime
)
segmentHelper
.
getSegment
(
endTime
)
]
;
}
let
pathSegments
=
[
]
;
const
startTimeSegment
=
segmentHelper
.
getSegment
(
startTime
)
;
pathSegments
.
push
(
startTimeSegment
)
;
let
previousSegment
=
startTimeSegment
;
const
interval
=
(
endTime
-
startTime
)
/
DURATION_RESOLUTION
;
for
(
let
index
=
1
;
index
<
=
DURATION_RESOLUTION
;
index
+
+
)
{
const
currentSegment
=
segmentHelper
.
getSegment
(
startTime
+
index
*
interval
)
;
if
(
Math
.
abs
(
currentSegment
.
y
-
previousSegment
.
y
)
>
minProgressThreshold
)
{
pathSegments
=
pathSegments
.
concat
(
createPathSegments
(
previousSegment
.
x
+
BOUND_EXCLUDING_TIME
currentSegment
.
x
-
BOUND_EXCLUDING_TIME
minSegmentDuration
minProgressThreshold
segmentHelper
)
)
;
}
pathSegments
.
push
(
currentSegment
)
;
previousSegment
=
currentSegment
;
}
return
pathSegments
;
}
exports
.
createPathSegments
=
createPathSegments
;
function
appendPathElement
(
parentEl
pathSegments
cls
)
{
let
path
=
M
{
pathSegments
[
0
]
.
x
}
0
;
for
(
let
i
=
0
;
i
<
pathSegments
.
length
;
i
+
+
)
{
const
pathSegment
=
pathSegments
[
i
]
;
if
(
!
pathSegment
.
easing
|
|
pathSegment
.
easing
=
=
=
"
linear
"
)
{
path
+
=
createLinePathString
(
pathSegment
)
;
continue
;
}
if
(
i
+
1
=
=
=
pathSegments
.
length
)
{
break
;
}
const
nextPathSegment
=
pathSegments
[
i
+
1
]
;
path
+
=
pathSegment
.
easing
.
startsWith
(
"
steps
"
)
?
createStepsPathString
(
pathSegment
nextPathSegment
)
:
createCubicBezierPathString
(
pathSegment
nextPathSegment
)
;
}
path
+
=
L
{
pathSegments
[
pathSegments
.
length
-
1
]
.
x
}
0
Z
;
return
createSVGNode
(
{
parent
:
parentEl
nodeType
:
"
path
"
attributes
:
{
"
d
"
:
path
"
class
"
:
cls
"
vector
-
effect
"
:
"
non
-
scaling
-
stroke
"
"
transform
"
:
"
scale
(
1
-
1
)
"
}
}
)
;
}
exports
.
appendPathElement
=
appendPathElement
;
function
createKeyframesPathSegments
(
duration
keyframes
)
{
return
keyframes
.
map
(
keyframe
=
>
{
return
{
x
:
keyframe
.
offset
*
duration
y
:
keyframe
.
distance
easing
:
keyframe
.
easing
style
:
keyframe
.
value
}
;
}
)
;
}
function
createLinePathString
(
segment
)
{
return
L
{
segment
.
x
}
{
segment
.
y
}
;
}
function
createStepsPathString
(
currentSegment
nextSegment
)
{
const
matches
=
currentSegment
.
easing
.
match
(
/
^
steps
\
(
(
\
d
+
)
(
\
sstart
)
?
\
)
/
)
;
const
stepNumber
=
parseInt
(
matches
[
1
]
10
)
;
const
oneStepX
=
(
nextSegment
.
x
-
currentSegment
.
x
)
/
stepNumber
;
const
oneStepY
=
(
nextSegment
.
y
-
currentSegment
.
y
)
/
stepNumber
;
const
isStepStart
=
matches
[
2
]
;
const
stepOffsetY
=
isStepStart
?
1
:
0
;
let
path
=
"
"
;
for
(
let
step
=
0
;
step
<
stepNumber
;
step
+
+
)
{
const
sx
=
currentSegment
.
x
+
step
*
oneStepX
;
const
ex
=
sx
+
oneStepX
;
const
y
=
currentSegment
.
y
+
(
step
+
stepOffsetY
)
*
oneStepY
;
path
+
=
L
{
sx
}
{
y
}
L
{
ex
}
{
y
}
;
}
if
(
!
isStepStart
)
{
path
+
=
L
{
nextSegment
.
x
}
{
nextSegment
.
y
}
;
}
return
path
;
}
function
createCubicBezierPathString
(
currentSegment
nextSegment
)
{
const
controlPoints
=
parseTimingFunction
(
currentSegment
.
easing
)
;
if
(
!
controlPoints
)
{
return
createLinePathString
(
currentSegment
)
;
}
const
cp1x
=
controlPoints
[
0
]
;
const
cp1y
=
controlPoints
[
1
]
;
const
cp2x
=
controlPoints
[
2
]
;
const
cp2y
=
controlPoints
[
3
]
;
const
diffX
=
nextSegment
.
x
-
currentSegment
.
x
;
const
diffY
=
nextSegment
.
y
-
currentSegment
.
y
;
let
path
=
C
{
currentSegment
.
x
+
diffX
*
cp1x
}
{
currentSegment
.
y
+
diffY
*
cp1y
}
;
path
+
=
{
currentSegment
.
x
+
diffX
*
cp2x
}
{
currentSegment
.
y
+
diffY
*
cp2y
}
;
path
+
=
{
nextSegment
.
x
}
{
nextSegment
.
y
}
;
return
path
;
}
function
getRGBA
(
colorString
)
{
const
color
=
new
colorUtils
.
CssColor
(
colorString
)
;
return
color
.
getRGBATuple
(
)
;
}
function
getRGBADistance
(
rgba1
rgba2
)
{
const
startA
=
rgba1
.
a
;
const
startR
=
rgba1
.
r
*
startA
;
const
startG
=
rgba1
.
g
*
startA
;
const
startB
=
rgba1
.
b
*
startA
;
const
endA
=
rgba2
.
a
;
const
endR
=
rgba2
.
r
*
endA
;
const
endG
=
rgba2
.
g
*
endA
;
const
endB
=
rgba2
.
b
*
endA
;
const
diffA
=
startA
-
endA
;
const
diffR
=
startR
-
endR
;
const
diffG
=
startG
-
endG
;
const
diffB
=
startB
-
endB
;
return
Math
.
sqrt
(
diffA
*
diffA
+
diffR
*
diffR
+
diffG
*
diffG
+
diffB
*
diffB
)
;
}
