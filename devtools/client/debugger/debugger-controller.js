"
use
strict
"
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
}
=
Components
;
const
DBG_STRINGS_URI
=
"
chrome
:
/
/
devtools
/
locale
/
debugger
.
properties
"
;
const
NEW_SOURCE_IGNORED_URLS
=
[
"
debugger
eval
code
"
"
XStringBundle
"
]
;
const
NEW_SOURCE_DISPLAY_DELAY
=
200
;
const
FETCH_SOURCE_RESPONSE_DELAY
=
200
;
const
FRAME_STEP_CLEAR_DELAY
=
100
;
const
CALL_STACK_PAGE_SIZE
=
25
;
const
EVENTS
=
{
EDITOR_LOADED
:
"
Debugger
:
EditorLoaded
"
EDITOR_UNLOADED
:
"
Debugger
:
EditorUnoaded
"
NEW_SOURCE
:
"
Debugger
:
NewSource
"
SOURCES_ADDED
:
"
Debugger
:
SourcesAdded
"
SOURCE_SHOWN
:
"
Debugger
:
EditorSourceShown
"
SOURCE_ERROR_SHOWN
:
"
Debugger
:
EditorSourceErrorShown
"
EDITOR_LOCATION_SET
:
"
Debugger
:
EditorLocationSet
"
FETCHED_SCOPES
:
"
Debugger
:
FetchedScopes
"
FETCHED_VARIABLES
:
"
Debugger
:
FetchedVariables
"
FETCHED_PROPERTIES
:
"
Debugger
:
FetchedProperties
"
FETCHED_BUBBLE_PROPERTIES
:
"
Debugger
:
FetchedBubbleProperties
"
FETCHED_WATCH_EXPRESSIONS
:
"
Debugger
:
FetchedWatchExpressions
"
BREAKPOINT_ADDED
:
"
Debugger
:
BreakpointAdded
"
BREAKPOINT_REMOVED
:
"
Debugger
:
BreakpointRemoved
"
BREAKPOINT_CLICKED
:
"
Debugger
:
BreakpointClicked
"
BREAKPOINT_SHOWN_IN_EDITOR
:
"
Debugger
:
BreakpointShownInEditor
"
BREAKPOINT_SHOWN_IN_PANE
:
"
Debugger
:
BreakpointShownInPane
"
BREAKPOINT_HIDDEN_IN_EDITOR
:
"
Debugger
:
BreakpointHiddenInEditor
"
BREAKPOINT_HIDDEN_IN_PANE
:
"
Debugger
:
BreakpointHiddenInPane
"
CONDITIONAL_BREAKPOINT_POPUP_SHOWING
:
"
Debugger
:
ConditionalBreakpointPopupShowing
"
CONDITIONAL_BREAKPOINT_POPUP_HIDING
:
"
Debugger
:
ConditionalBreakpointPopupHiding
"
EVENT_LISTENERS_FETCHED
:
"
Debugger
:
EventListenersFetched
"
EVENT_BREAKPOINTS_UPDATED
:
"
Debugger
:
EventBreakpointsUpdated
"
FILE_SEARCH_MATCH_FOUND
:
"
Debugger
:
FileSearch
:
MatchFound
"
FILE_SEARCH_MATCH_NOT_FOUND
:
"
Debugger
:
FileSearch
:
MatchNotFound
"
FUNCTION_SEARCH_MATCH_FOUND
:
"
Debugger
:
FunctionSearch
:
MatchFound
"
FUNCTION_SEARCH_MATCH_NOT_FOUND
:
"
Debugger
:
FunctionSearch
:
MatchNotFound
"
GLOBAL_SEARCH_MATCH_FOUND
:
"
Debugger
:
GlobalSearch
:
MatchFound
"
GLOBAL_SEARCH_MATCH_NOT_FOUND
:
"
Debugger
:
GlobalSearch
:
MatchNotFound
"
AFTER_FRAMES_REFILLED
:
"
Debugger
:
AfterFramesRefilled
"
AFTER_FRAMES_CLEARED
:
"
Debugger
:
AfterFramesCleared
"
OPTIONS_POPUP_SHOWING
:
"
Debugger
:
OptionsPopupShowing
"
OPTIONS_POPUP_HIDDEN
:
"
Debugger
:
OptionsPopupHidden
"
LAYOUT_CHANGED
:
"
Debugger
:
LayoutChanged
"
}
;
const
FRAME_TYPE
=
{
NORMAL
:
0
CONDITIONAL_BREAKPOINT_EVAL
:
1
WATCH_EXPRESSIONS_EVAL
:
2
PUBLIC_CLIENT_EVAL
:
3
}
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
shared
/
event
-
emitter
.
js
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
SimpleListWidget
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
BreadcrumbsWidget
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
SideMenuWidget
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesView
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
VariablesViewController
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
ViewHelpers
.
jsm
"
)
;
var
L10N
=
new
ViewHelpers
.
L10N
(
DBG_STRINGS_URI
)
;
Cu
.
import
(
"
resource
:
/
/
devtools
/
client
/
shared
/
browser
-
loader
.
js
"
)
;
const
require
=
BrowserLoader
(
"
resource
:
/
/
devtools
/
client
/
debugger
/
"
this
)
.
require
;
XPCOMUtils
.
defineConstant
(
this
"
require
"
require
)
;
const
React
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
;
const
ReactDOM
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
;
const
{
Provider
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
)
;
const
createStore
=
require
(
"
devtools
/
client
/
shared
/
redux
/
create
-
store
"
)
(
{
getTargetClient
:
(
)
=
>
DebuggerController
.
client
log
:
false
}
)
;
const
{
makeStateBroadcaster
enhanceStoreWithBroadcaster
combineBroadcastingReducers
}
=
require
(
"
devtools
/
client
/
shared
/
redux
/
non
-
react
-
subscriber
"
)
;
const
{
bindActionCreators
}
=
require
(
'
devtools
/
client
/
shared
/
vendor
/
redux
'
)
;
const
reducers
=
require
(
"
.
/
content
/
reducers
/
index
"
)
;
const
{
onReducerEvents
}
=
require
(
"
.
/
content
/
utils
"
)
;
const
waitUntilService
=
require
(
"
devtools
/
client
/
shared
/
redux
/
middleware
/
wait
-
service
"
)
;
var
services
=
{
WAIT_UNTIL
:
waitUntilService
.
NAME
}
;
var
{
TargetFactory
}
=
require
(
"
devtools
/
client
/
framework
/
target
"
)
;
var
{
Toolbox
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
;
var
DevToolsUtils
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
var
promise
=
require
(
"
devtools
/
shared
/
deprecated
-
sync
-
thenables
"
)
;
var
Editor
=
require
(
"
devtools
/
client
/
sourceeditor
/
editor
"
)
;
var
DebuggerEditor
=
require
(
"
devtools
/
client
/
sourceeditor
/
debugger
"
)
;
var
{
Tooltip
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
Tooltip
"
)
;
var
FastListWidget
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
FastListWidget
"
)
;
XPCOMUtils
.
defineConstant
(
this
"
EVENTS
"
EVENTS
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Task
"
"
resource
:
/
/
gre
/
modules
/
Task
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Parser
"
"
resource
:
/
/
devtools
/
shared
/
Parser
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
ShortcutUtils
"
"
resource
:
/
/
gre
/
modules
/
ShortcutUtils
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
clipboardHelper
"
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
"
nsIClipboardHelper
"
)
;
Object
.
defineProperty
(
this
"
NetworkHelper
"
{
get
:
function
(
)
{
return
require
(
"
devtools
/
shared
/
webconsole
/
network
-
helper
"
)
;
}
configurable
:
true
enumerable
:
true
}
)
;
var
DebuggerController
=
{
initialize
:
function
(
)
{
dumpn
(
"
Initializing
the
DebuggerController
"
)
;
this
.
startupDebugger
=
this
.
startupDebugger
.
bind
(
this
)
;
this
.
shutdownDebugger
=
this
.
shutdownDebugger
.
bind
(
this
)
;
this
.
_onNavigate
=
this
.
_onNavigate
.
bind
(
this
)
;
this
.
_onWillNavigate
=
this
.
_onWillNavigate
.
bind
(
this
)
;
this
.
_onTabDetached
=
this
.
_onTabDetached
.
bind
(
this
)
;
const
broadcaster
=
makeStateBroadcaster
(
(
)
=
>
!
!
this
.
activeThread
)
;
const
reducer
=
combineBroadcastingReducers
(
reducers
broadcaster
.
emitChange
)
;
let
store
=
createStore
(
(
state
action
)
=
>
{
if
(
action
.
seqId
&
&
(
action
.
status
=
=
=
'
done
'
|
|
action
.
status
=
=
=
'
error
'
)
&
&
state
&
&
state
.
asyncRequests
.
indexOf
(
action
.
seqId
)
=
=
=
-
1
)
{
return
state
;
}
return
reducer
(
state
action
)
;
}
)
;
store
=
enhanceStoreWithBroadcaster
(
store
broadcaster
)
;
Object
.
keys
(
store
)
.
forEach
(
name
=
>
{
this
[
name
]
=
store
[
name
]
;
}
)
;
}
startupDebugger
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_startup
)
{
return
;
}
DebuggerView
.
initialize
(
)
;
this
.
_startup
=
true
;
}
)
shutdownDebugger
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_shutdown
)
{
return
;
}
yield
this
.
_settleAllRequests
(
)
;
DebuggerView
.
destroy
(
)
;
this
.
StackFrames
.
disconnect
(
)
;
this
.
ThreadState
.
disconnect
(
)
;
if
(
this
.
_target
.
isTabActor
)
{
this
.
Workers
.
disconnect
(
)
;
}
this
.
disconnect
(
)
;
this
.
_shutdown
=
true
;
}
)
_settleAllRequests
:
function
(
)
{
const
requests
=
this
.
getState
(
)
.
asyncRequests
;
if
(
requests
.
length
>
0
)
{
const
deferred
=
promise
.
defer
(
)
;
this
.
onChange
(
'
open
-
requests
'
function
checkSettled
(
reqs
)
{
if
(
reqs
.
length
=
=
=
0
)
{
deferred
.
resolve
(
)
;
}
this
.
offChange
(
'
open
-
requests
'
checkSettled
)
;
}
.
bind
(
this
)
)
;
return
deferred
.
promise
;
}
return
promise
.
resolve
(
)
;
}
connect
:
Task
.
async
(
function
*
(
)
{
if
(
this
.
_connected
)
{
return
;
}
let
target
=
this
.
_target
;
let
{
client
form
:
{
chromeDebugger
actor
}
}
=
target
;
target
.
on
(
"
close
"
this
.
_onTabDetached
)
;
target
.
on
(
"
navigate
"
this
.
_onNavigate
)
;
target
.
on
(
"
will
-
navigate
"
this
.
_onWillNavigate
)
;
this
.
client
=
client
;
if
(
target
.
isAddon
)
{
yield
this
.
_startAddonDebugging
(
actor
)
;
}
else
if
(
!
target
.
isTabActor
)
{
yield
this
.
_startChromeDebugging
(
chromeDebugger
)
;
}
else
{
yield
this
.
_startDebuggingTab
(
)
;
}
this
.
_hideUnsupportedFeatures
(
)
;
}
)
connectThread
:
function
(
)
{
const
{
newSource
fetchEventListeners
}
=
bindActionCreators
(
actions
this
.
dispatch
)
;
this
.
activeThread
.
addListener
(
"
newSource
"
(
event
packet
)
=
>
{
newSource
(
packet
.
source
)
;
if
(
DebuggerView
.
instrumentsPaneTab
=
=
"
events
-
tab
"
)
{
fetchEventListeners
(
)
;
}
}
)
;
this
.
Workers
.
connect
(
)
;
this
.
ThreadState
.
connect
(
)
;
this
.
StackFrames
.
connect
(
)
;
this
.
dispatch
(
actions
.
loadSources
(
)
)
;
}
disconnect
:
function
(
)
{
if
(
!
this
.
client
)
{
return
;
}
this
.
client
.
removeListener
(
"
newGlobal
"
)
;
this
.
activeThread
.
removeListener
(
"
newSource
"
)
;
this
.
activeThread
.
removeListener
(
"
blackboxchange
"
)
;
this
.
_connected
=
false
;
this
.
client
=
null
;
this
.
activeThread
=
null
;
}
_hideUnsupportedFeatures
:
function
(
)
{
if
(
this
.
client
.
mainRoot
.
traits
.
noPrettyPrinting
)
{
DebuggerView
.
Sources
.
hidePrettyPrinting
(
)
;
}
if
(
this
.
client
.
mainRoot
.
traits
.
noBlackBoxing
)
{
DebuggerView
.
Sources
.
hideBlackBoxing
(
)
;
}
}
_onWillNavigate
:
function
(
opts
=
{
}
)
{
DebuggerView
.
handleTabNavigation
(
)
;
if
(
!
opts
.
noUnload
)
{
this
.
dispatch
(
actions
.
unload
(
)
)
;
}
DebuggerController
.
Parser
.
clearCache
(
)
;
SourceUtils
.
clearCache
(
)
;
clearNamedTimeout
(
"
new
-
source
"
)
;
clearNamedTimeout
(
"
event
-
breakpoints
-
update
"
)
;
clearNamedTimeout
(
"
event
-
listeners
-
fetch
"
)
;
}
_onNavigate
:
function
(
)
{
this
.
ThreadState
.
handleTabNavigation
(
)
;
this
.
StackFrames
.
handleTabNavigation
(
)
;
this
.
dispatch
(
actions
.
loadSources
(
)
)
;
}
_onTabDetached
:
function
(
)
{
this
.
shutdownDebugger
(
)
;
}
_ensureResumptionOrder
:
function
(
aResponse
)
{
if
(
aResponse
.
error
=
=
"
wrongOrder
"
)
{
DebuggerView
.
Toolbar
.
showResumeWarning
(
aResponse
.
lastPausedUrl
)
;
}
}
_startDebuggingTab
:
function
(
)
{
let
deferred
=
promise
.
defer
(
)
;
let
threadOptions
=
{
useSourceMaps
:
Prefs
.
sourceMapsEnabled
autoBlackBox
:
Prefs
.
autoBlackBox
}
;
this
.
_target
.
activeTab
.
attachThread
(
threadOptions
(
aResponse
aThreadClient
)
=
>
{
if
(
!
aThreadClient
)
{
deferred
.
reject
(
new
Error
(
"
Couldn
'
t
attach
to
thread
:
"
+
aResponse
.
error
)
)
;
return
;
}
this
.
activeThread
=
aThreadClient
;
this
.
connectThread
(
)
;
if
(
aThreadClient
.
paused
)
{
aThreadClient
.
resume
(
res
=
>
{
this
.
_ensureResumptionOrder
(
res
)
}
)
;
}
deferred
.
resolve
(
)
;
}
)
;
return
deferred
.
promise
;
}
_startAddonDebugging
:
function
(
aAddonActor
)
{
let
deferred
=
promise
.
defer
(
)
;
this
.
client
.
attachAddon
(
aAddonActor
aResponse
=
>
{
this
.
_startChromeDebugging
(
aResponse
.
threadActor
)
.
then
(
deferred
.
resolve
)
;
}
)
;
return
deferred
.
promise
;
}
_startChromeDebugging
:
function
(
aChromeDebugger
)
{
let
deferred
=
promise
.
defer
(
)
;
let
threadOptions
=
{
useSourceMaps
:
Prefs
.
sourceMapsEnabled
autoBlackBox
:
Prefs
.
autoBlackBox
}
;
this
.
client
.
attachThread
(
aChromeDebugger
(
aResponse
aThreadClient
)
=
>
{
if
(
!
aThreadClient
)
{
deferred
.
reject
(
new
Error
(
"
Couldn
'
t
attach
to
thread
:
"
+
aResponse
.
error
)
)
;
return
;
}
this
.
activeThread
=
aThreadClient
;
this
.
connectThread
(
)
;
if
(
aThreadClient
.
paused
)
{
aThreadClient
.
resume
(
this
.
_ensureResumptionOrder
)
;
}
deferred
.
resolve
(
)
;
}
threadOptions
)
;
return
deferred
.
promise
;
}
reconfigureThread
:
function
(
{
useSourceMaps
autoBlackBox
}
)
{
this
.
activeThread
.
reconfigure
(
{
useSourceMaps
:
useSourceMaps
autoBlackBox
:
autoBlackBox
}
aResponse
=
>
{
if
(
aResponse
.
error
)
{
let
msg
=
"
Couldn
'
t
reconfigure
thread
:
"
+
aResponse
.
message
;
Cu
.
reportError
(
msg
)
;
dumpn
(
msg
)
;
return
;
}
DebuggerView
.
handleTabNavigation
(
)
;
this
.
dispatch
(
actions
.
unload
(
)
)
;
this
.
dispatch
(
actions
.
loadSources
(
)
)
;
if
(
this
.
activeThread
.
paused
)
{
this
.
activeThread
.
_clearFrames
(
)
;
this
.
activeThread
.
fillFrames
(
CALL_STACK_PAGE_SIZE
)
;
}
}
)
;
}
waitForSourcesLoaded
:
function
(
)
{
const
deferred
=
promise
.
defer
(
)
;
this
.
dispatch
(
{
type
:
services
.
WAIT_UNTIL
predicate
:
action
=
>
(
action
.
type
=
=
=
constants
.
LOAD_SOURCES
&
&
action
.
status
=
=
=
"
done
"
)
run
:
deferred
.
resolve
}
)
;
return
deferred
.
promise
;
}
waitForSourceShown
:
function
(
name
)
{
const
deferred
=
promise
.
defer
(
)
;
window
.
on
(
EVENTS
.
SOURCE_SHOWN
function
onShown
(
_
source
)
{
if
(
source
.
url
.
includes
(
name
)
)
{
window
.
off
(
EVENTS
.
SOURCE_SHOWN
onShown
)
;
deferred
.
resolve
(
)
;
}
}
)
;
return
deferred
.
promise
;
}
_startup
:
false
_shutdown
:
false
_connected
:
false
client
:
null
activeThread
:
null
}
;
function
Workers
(
)
{
this
.
_workerForms
=
Object
.
create
(
null
)
;
this
.
_onWorkerListChanged
=
this
.
_onWorkerListChanged
.
bind
(
this
)
;
this
.
_onWorkerSelect
=
this
.
_onWorkerSelect
.
bind
(
this
)
;
}
Workers
.
prototype
=
{
get
_tabClient
(
)
{
return
DebuggerController
.
_target
.
activeTab
;
}
connect
:
function
(
)
{
if
(
!
Prefs
.
workersEnabled
)
{
return
;
}
this
.
_updateWorkerList
(
)
;
this
.
_tabClient
.
addListener
(
"
workerListChanged
"
this
.
_onWorkerListChanged
)
;
}
disconnect
:
function
(
)
{
this
.
_tabClient
.
removeListener
(
"
workerListChanged
"
this
.
_onWorkerListChanged
)
;
}
_updateWorkerList
:
function
(
)
{
if
(
!
this
.
_tabClient
.
listWorkers
)
{
return
;
}
this
.
_tabClient
.
listWorkers
(
(
response
)
=
>
{
let
workerForms
=
Object
.
create
(
null
)
;
for
(
let
worker
of
response
.
workers
)
{
workerForms
[
worker
.
actor
]
=
worker
;
}
for
(
let
workerActor
in
this
.
_workerForms
)
{
if
(
!
(
workerActor
in
workerForms
)
)
{
delete
this
.
_workerForms
[
workerActor
]
;
DebuggerView
.
Workers
.
removeWorker
(
workerActor
)
;
}
}
for
(
let
workerActor
in
workerForms
)
{
if
(
!
(
workerActor
in
this
.
_workerForms
)
)
{
let
workerForm
=
workerForms
[
workerActor
]
;
this
.
_workerForms
[
workerActor
]
=
workerForm
;
DebuggerView
.
Workers
.
addWorker
(
workerActor
workerForm
.
url
)
;
}
}
}
)
;
}
_onWorkerListChanged
:
function
(
)
{
this
.
_updateWorkerList
(
)
;
}
_onWorkerSelect
:
function
(
workerActor
)
{
DebuggerController
.
client
.
attachWorker
(
workerActor
(
response
workerClient
)
=
>
{
gDevTools
.
showToolbox
(
TargetFactory
.
forWorker
(
workerClient
)
"
jsdebugger
"
Toolbox
.
HostType
.
WINDOW
)
;
}
)
;
}
}
;
function
ThreadState
(
)
{
this
.
_update
=
this
.
_update
.
bind
(
this
)
;
this
.
interruptedByResumeButton
=
false
;
}
ThreadState
.
prototype
=
{
get
activeThread
(
)
{
return
DebuggerController
.
activeThread
;
}
connect
:
function
(
)
{
dumpn
(
"
ThreadState
is
connecting
.
.
.
"
)
;
this
.
activeThread
.
addListener
(
"
paused
"
this
.
_update
)
;
this
.
activeThread
.
addListener
(
"
resumed
"
this
.
_update
)
;
this
.
activeThread
.
pauseOnExceptions
(
Prefs
.
pauseOnExceptions
Prefs
.
ignoreCaughtExceptions
)
;
}
disconnect
:
function
(
)
{
if
(
!
this
.
activeThread
)
{
return
;
}
dumpn
(
"
ThreadState
is
disconnecting
.
.
.
"
)
;
this
.
activeThread
.
removeListener
(
"
paused
"
this
.
_update
)
;
this
.
activeThread
.
removeListener
(
"
resumed
"
this
.
_update
)
;
}
handleTabNavigation
:
function
(
)
{
if
(
!
this
.
activeThread
)
{
return
;
}
dumpn
(
"
Handling
tab
navigation
in
the
ThreadState
"
)
;
this
.
_update
(
)
;
}
_update
:
function
(
aEvent
aPacket
)
{
if
(
aEvent
=
=
"
paused
"
)
{
if
(
aPacket
.
why
.
type
=
=
"
interrupted
"
&
&
!
this
.
interruptedByResumeButton
)
{
return
;
}
else
if
(
aPacket
.
why
.
type
=
=
"
breakpointConditionThrown
"
&
&
aPacket
.
why
.
message
)
{
let
where
=
aPacket
.
frame
.
where
;
let
aLocation
=
{
line
:
where
.
line
column
:
where
.
column
actor
:
where
.
source
?
where
.
source
.
actor
:
null
}
;
DebuggerView
.
Sources
.
showBreakpointConditionThrownMessage
(
aLocation
aPacket
.
why
.
message
)
;
}
}
this
.
interruptedByResumeButton
=
false
;
DebuggerView
.
Toolbar
.
toggleResumeButtonState
(
this
.
activeThread
.
state
aPacket
?
aPacket
.
frame
:
false
)
;
if
(
gTarget
&
&
(
aEvent
=
=
"
paused
"
|
|
aEvent
=
=
"
resumed
"
)
)
{
gTarget
.
emit
(
"
thread
-
"
+
aEvent
)
;
}
}
}
;
function
StackFrames
(
)
{
this
.
_onPaused
=
this
.
_onPaused
.
bind
(
this
)
;
this
.
_onResumed
=
this
.
_onResumed
.
bind
(
this
)
;
this
.
_onFrames
=
this
.
_onFrames
.
bind
(
this
)
;
this
.
_onFramesCleared
=
this
.
_onFramesCleared
.
bind
(
this
)
;
this
.
_onBlackBoxChange
=
this
.
_onBlackBoxChange
.
bind
(
this
)
;
this
.
_onPrettyPrintChange
=
this
.
_onPrettyPrintChange
.
bind
(
this
)
;
this
.
_afterFramesCleared
=
this
.
_afterFramesCleared
.
bind
(
this
)
;
this
.
evaluate
=
this
.
evaluate
.
bind
(
this
)
;
}
StackFrames
.
prototype
=
{
get
activeThread
(
)
{
return
DebuggerController
.
activeThread
;
}
currentFrameDepth
:
-
1
_currentFrameDescription
:
FRAME_TYPE
.
NORMAL
_syncedWatchExpressions
:
null
_currentWatchExpressions
:
null
_currentBreakpointLocation
:
null
_currentEvaluation
:
null
_currentException
:
null
_currentReturnedValue
:
null
connect
:
function
(
)
{
dumpn
(
"
StackFrames
is
connecting
.
.
.
"
)
;
this
.
activeThread
.
addListener
(
"
paused
"
this
.
_onPaused
)
;
this
.
activeThread
.
addListener
(
"
resumed
"
this
.
_onResumed
)
;
this
.
activeThread
.
addListener
(
"
framesadded
"
this
.
_onFrames
)
;
this
.
activeThread
.
addListener
(
"
framescleared
"
this
.
_onFramesCleared
)
;
this
.
activeThread
.
addListener
(
"
blackboxchange
"
this
.
_onBlackBoxChange
)
;
this
.
activeThread
.
addListener
(
"
prettyprintchange
"
this
.
_onPrettyPrintChange
)
;
this
.
handleTabNavigation
(
)
;
}
disconnect
:
function
(
)
{
if
(
!
this
.
activeThread
)
{
return
;
}
dumpn
(
"
StackFrames
is
disconnecting
.
.
.
"
)
;
this
.
activeThread
.
removeListener
(
"
paused
"
this
.
_onPaused
)
;
this
.
activeThread
.
removeListener
(
"
resumed
"
this
.
_onResumed
)
;
this
.
activeThread
.
removeListener
(
"
framesadded
"
this
.
_onFrames
)
;
this
.
activeThread
.
removeListener
(
"
framescleared
"
this
.
_onFramesCleared
)
;
this
.
activeThread
.
removeListener
(
"
blackboxchange
"
this
.
_onBlackBoxChange
)
;
this
.
activeThread
.
removeListener
(
"
prettyprintchange
"
this
.
_onPrettyPrintChange
)
;
clearNamedTimeout
(
"
frames
-
cleared
"
)
;
}
handleTabNavigation
:
function
(
)
{
dumpn
(
"
Handling
tab
navigation
in
the
StackFrames
"
)
;
}
_onPaused
:
function
(
aEvent
aPacket
)
{
switch
(
aPacket
.
why
.
type
)
{
case
"
breakpoint
"
:
this
.
_currentBreakpointLocation
=
aPacket
.
frame
.
where
;
break
;
case
"
breakpointConditionThrown
"
:
this
.
_currentBreakpointLocation
=
aPacket
.
frame
.
where
;
this
.
_conditionThrowMessage
=
aPacket
.
why
.
message
;
break
;
case
"
clientEvaluated
"
:
this
.
_currentEvaluation
=
aPacket
.
why
.
frameFinished
;
break
;
case
"
exception
"
:
this
.
_currentException
=
aPacket
.
why
.
exception
;
break
;
case
"
resumeLimit
"
:
if
(
!
aPacket
.
why
.
frameFinished
)
{
break
;
}
else
if
(
aPacket
.
why
.
frameFinished
.
throw
)
{
this
.
_currentException
=
aPacket
.
why
.
frameFinished
.
throw
;
}
else
if
(
aPacket
.
why
.
frameFinished
.
return
)
{
this
.
_currentReturnedValue
=
aPacket
.
why
.
frameFinished
.
return
;
}
break
;
case
"
interrupted
"
:
if
(
!
aPacket
.
why
.
onNext
)
{
return
;
}
break
;
}
this
.
activeThread
.
fillFrames
(
CALL_STACK_PAGE_SIZE
)
;
if
(
!
DebuggerController
.
_toolbox
.
isSplitConsoleFocused
(
)
)
{
DebuggerView
.
editor
.
focus
(
)
;
}
}
_onResumed
:
function
(
)
{
if
(
this
.
_currentFrameDescription
!
=
FRAME_TYPE
.
WATCH_EXPRESSIONS_EVAL
)
{
this
.
_currentWatchExpressions
=
this
.
_syncedWatchExpressions
;
}
}
_onFrames
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
activeThread
|
|
!
this
.
activeThread
.
cachedFrames
.
length
)
{
return
;
}
if
(
this
.
_currentFrameDescription
!
=
FRAME_TYPE
.
NORMAL
&
&
this
.
_currentFrameDescription
!
=
FRAME_TYPE
.
PUBLIC_CLIENT_EVAL
)
{
return
;
}
yield
this
.
_handleConditionalBreakpoint
(
)
;
yield
this
.
_handleWatchExpressions
(
)
;
DebuggerView
.
showInstrumentsPane
(
)
;
this
.
_refillFrames
(
)
;
if
(
this
.
_currentFrameDescription
!
=
FRAME_TYPE
.
NORMAL
)
{
this
.
_currentFrameDescription
=
FRAME_TYPE
.
NORMAL
;
}
}
)
_refillFrames
:
function
(
)
{
DebuggerView
.
StackFrames
.
empty
(
)
;
for
(
let
frame
of
this
.
activeThread
.
cachedFrames
)
{
let
{
depth
source
where
:
{
line
}
}
=
frame
;
let
isBlackBoxed
=
source
?
this
.
activeThread
.
source
(
source
)
.
isBlackBoxed
:
false
;
DebuggerView
.
StackFrames
.
addFrame
(
frame
line
depth
isBlackBoxed
)
;
}
DebuggerView
.
StackFrames
.
selectedDepth
=
Math
.
max
(
this
.
currentFrameDepth
0
)
;
DebuggerView
.
StackFrames
.
dirty
=
this
.
activeThread
.
moreFrames
;
window
.
emit
(
EVENTS
.
AFTER_FRAMES_REFILLED
)
;
}
_onFramesCleared
:
function
(
)
{
switch
(
this
.
_currentFrameDescription
)
{
case
FRAME_TYPE
.
NORMAL
:
this
.
_currentEvaluation
=
null
;
this
.
_currentException
=
null
;
this
.
_currentReturnedValue
=
null
;
break
;
case
FRAME_TYPE
.
CONDITIONAL_BREAKPOINT_EVAL
:
this
.
_currentBreakpointLocation
=
null
;
break
;
case
FRAME_TYPE
.
WATCH_EXPRESSIONS_EVAL
:
this
.
_currentWatchExpressions
=
null
;
break
;
}
setNamedTimeout
(
"
frames
-
cleared
"
FRAME_STEP_CLEAR_DELAY
this
.
_afterFramesCleared
)
;
}
_onBlackBoxChange
:
function
(
)
{
if
(
this
.
activeThread
.
state
=
=
"
paused
"
)
{
this
.
currentFrameDepth
=
NaN
;
this
.
_refillFrames
(
)
;
}
}
_onPrettyPrintChange
:
function
(
)
{
if
(
this
.
activeThread
.
state
!
=
"
paused
"
)
{
return
;
}
const
source
=
DebuggerView
.
Sources
.
selectedValue
;
this
.
activeThread
.
fillFrames
(
CALL_STACK_PAGE_SIZE
(
)
=
>
{
DebuggerView
.
Sources
.
selectedValue
=
source
;
}
)
;
}
_afterFramesCleared
:
function
(
)
{
if
(
this
.
activeThread
.
cachedFrames
.
length
)
{
return
;
}
DebuggerView
.
editor
.
clearDebugLocation
(
)
;
DebuggerView
.
StackFrames
.
empty
(
)
;
DebuggerView
.
Sources
.
unhighlightBreakpoint
(
)
;
DebuggerView
.
WatchExpressions
.
toggleContents
(
true
)
;
DebuggerView
.
Variables
.
empty
(
0
)
;
window
.
emit
(
EVENTS
.
AFTER_FRAMES_CLEARED
)
;
}
selectFrame
:
function
(
aDepth
)
{
let
frame
=
this
.
activeThread
.
cachedFrames
[
this
.
currentFrameDepth
=
aDepth
]
;
if
(
!
frame
)
{
return
;
}
let
{
environment
where
source
}
=
frame
;
if
(
!
environment
)
{
return
;
}
let
isClientEval
=
this
.
_currentFrameDescription
=
=
FRAME_TYPE
.
PUBLIC_CLIENT_EVAL
;
let
isPopupShown
=
DebuggerView
.
VariableBubble
.
contentsShown
(
)
;
if
(
!
isClientEval
&
&
!
isPopupShown
)
{
DebuggerView
.
setEditorLocation
(
source
.
actor
where
.
line
)
;
}
else
{
DebuggerView
.
setEditorLocation
(
source
.
actor
where
.
line
{
noCaret
:
true
}
)
;
}
DebuggerView
.
Sources
.
highlightBreakpointAtCursor
(
)
;
DebuggerView
.
WatchExpressions
.
toggleContents
(
false
)
;
DebuggerView
.
Variables
.
empty
(
)
;
if
(
this
.
_syncedWatchExpressions
&
&
aDepth
=
=
0
)
{
let
label
=
L10N
.
getStr
(
"
watchExpressionsScopeLabel
"
)
;
let
scope
=
DebuggerView
.
Variables
.
addScope
(
label
)
;
scope
.
descriptorTooltip
=
false
;
scope
.
contextMenuId
=
"
debuggerWatchExpressionsContextMenu
"
;
scope
.
separatorStr
=
L10N
.
getStr
(
"
watchExpressionsSeparatorLabel2
"
)
;
scope
.
switch
=
DebuggerView
.
WatchExpressions
.
switchExpression
;
scope
.
delete
=
DebuggerView
.
WatchExpressions
.
deleteExpression
;
this
.
_fetchWatchExpressions
(
scope
this
.
_currentEvaluation
.
return
)
;
scope
.
expand
(
)
;
}
do
{
let
label
=
StackFrameUtils
.
getScopeLabel
(
environment
)
;
let
scope
=
DebuggerView
.
Variables
.
addScope
(
label
)
;
let
innermost
=
environment
=
=
frame
.
environment
;
if
(
innermost
)
{
this
.
_insertScopeFrameReferences
(
scope
frame
)
;
}
DebuggerView
.
Variables
.
controller
.
addExpander
(
scope
environment
)
;
if
(
innermost
|
|
DebuggerView
.
Variables
.
wasExpanded
(
scope
)
)
{
scope
.
expand
(
)
;
}
}
while
(
(
environment
=
environment
.
parent
)
)
;
window
.
emit
(
EVENTS
.
FETCHED_SCOPES
)
;
}
addMoreFrames
:
function
(
)
{
this
.
activeThread
.
fillFrames
(
this
.
activeThread
.
cachedFrames
.
length
+
CALL_STACK_PAGE_SIZE
)
;
}
evaluate
:
function
(
aExpression
aOptions
=
{
}
)
{
let
depth
=
"
depth
"
in
aOptions
?
aOptions
.
depth
:
this
.
currentFrameDepth
;
let
frame
=
this
.
activeThread
.
cachedFrames
[
depth
]
;
if
(
frame
=
=
null
)
{
return
promise
.
reject
(
new
Error
(
"
No
stack
frame
available
.
"
)
)
;
}
let
deferred
=
promise
.
defer
(
)
;
this
.
activeThread
.
addOneTimeListener
(
"
paused
"
(
aEvent
aPacket
)
=
>
{
let
{
type
frameFinished
}
=
aPacket
.
why
;
if
(
type
=
=
"
clientEvaluated
"
)
{
deferred
.
resolve
(
frameFinished
)
;
}
else
{
deferred
.
reject
(
new
Error
(
"
Active
thread
paused
unexpectedly
.
"
)
)
;
}
}
)
;
let
meta
=
"
meta
"
in
aOptions
?
aOptions
.
meta
:
FRAME_TYPE
.
PUBLIC_CLIENT_EVAL
;
this
.
_currentFrameDescription
=
meta
;
this
.
activeThread
.
eval
(
frame
.
actor
aExpression
)
;
return
deferred
.
promise
;
}
_insertScopeFrameReferences
:
function
(
aScope
aFrame
)
{
if
(
this
.
_currentException
)
{
let
excRef
=
aScope
.
addItem
(
"
<
exception
>
"
{
value
:
this
.
_currentException
}
{
internalItem
:
true
}
)
;
DebuggerView
.
Variables
.
controller
.
addExpander
(
excRef
this
.
_currentException
)
;
}
if
(
this
.
_currentReturnedValue
)
{
let
retRef
=
aScope
.
addItem
(
"
<
return
>
"
{
value
:
this
.
_currentReturnedValue
}
{
internalItem
:
true
}
)
;
DebuggerView
.
Variables
.
controller
.
addExpander
(
retRef
this
.
_currentReturnedValue
)
;
}
if
(
aFrame
.
this
)
{
let
thisRef
=
aScope
.
addItem
(
"
this
"
{
value
:
aFrame
.
this
}
)
;
DebuggerView
.
Variables
.
controller
.
addExpander
(
thisRef
aFrame
.
this
)
;
}
}
_handleConditionalBreakpoint
:
Task
.
async
(
function
*
(
)
{
if
(
gClient
.
mainRoot
.
traits
.
conditionalBreakpoints
)
{
return
;
}
let
breakLocation
=
this
.
_currentBreakpointLocation
;
if
(
!
breakLocation
)
{
return
;
}
let
bp
=
queries
.
getBreakpoint
(
DebuggerController
.
getState
(
)
{
actor
:
breakLocation
.
source
.
actor
line
:
breakLocation
.
line
}
)
;
let
conditionalExpression
=
bp
.
condition
;
if
(
!
conditionalExpression
)
{
return
;
}
let
evaluationOptions
=
{
depth
:
0
meta
:
FRAME_TYPE
.
CONDITIONAL_BREAKPOINT_EVAL
}
;
yield
this
.
evaluate
(
conditionalExpression
evaluationOptions
)
;
this
.
_currentFrameDescription
=
FRAME_TYPE
.
NORMAL
;
if
(
!
this
.
_currentEvaluation
.
throw
&
&
VariablesView
.
isFalsy
(
{
value
:
this
.
_currentEvaluation
.
return
}
)
)
{
this
.
activeThread
.
resume
(
DebuggerController
.
_ensureResumptionOrder
)
;
}
}
)
_handleWatchExpressions
:
Task
.
async
(
function
*
(
)
{
if
(
!
this
.
activeThread
|
|
!
this
.
activeThread
.
cachedFrames
.
length
)
{
return
;
}
let
watchExpressions
=
this
.
_currentWatchExpressions
;
if
(
!
watchExpressions
)
{
return
;
}
let
evaluationOptions
=
{
depth
:
0
meta
:
FRAME_TYPE
.
WATCH_EXPRESSIONS_EVAL
}
;
yield
this
.
evaluate
(
watchExpressions
evaluationOptions
)
;
this
.
_currentFrameDescription
=
FRAME_TYPE
.
NORMAL
;
if
(
this
.
_currentEvaluation
.
throw
|
|
this
.
_currentEvaluation
.
terminated
)
{
DebuggerView
.
WatchExpressions
.
removeAt
(
0
)
;
yield
DebuggerController
.
StackFrames
.
syncWatchExpressions
(
)
;
}
}
)
_fetchWatchExpressions
:
function
(
aScope
aExp
)
{
if
(
aScope
.
_fetched
)
{
return
;
}
aScope
.
_fetched
=
true
;
this
.
activeThread
.
pauseGrip
(
aExp
)
.
getPrototypeAndProperties
(
aResponse
=
>
{
let
ownProperties
=
aResponse
.
ownProperties
;
let
totalExpressions
=
DebuggerView
.
WatchExpressions
.
itemCount
;
for
(
let
i
=
0
;
i
<
totalExpressions
;
i
+
+
)
{
let
name
=
DebuggerView
.
WatchExpressions
.
getString
(
i
)
;
let
expVal
=
ownProperties
[
i
]
.
value
;
let
expRef
=
aScope
.
addItem
(
name
ownProperties
[
i
]
)
;
DebuggerView
.
Variables
.
controller
.
addExpander
(
expRef
expVal
)
;
expRef
.
switch
=
null
;
expRef
.
delete
=
null
;
expRef
.
descriptorTooltip
=
true
;
expRef
.
separatorStr
=
L10N
.
getStr
(
"
variablesSeparatorLabel
"
)
;
}
window
.
emit
(
EVENTS
.
FETCHED_WATCH_EXPRESSIONS
)
;
}
)
;
}
syncWatchExpressions
:
function
(
)
{
let
list
=
DebuggerView
.
WatchExpressions
.
getAllStrings
(
)
;
let
sanitizedExpressions
=
list
.
map
(
aString
=
>
{
try
{
Parser
.
reflectionAPI
.
parse
(
aString
)
;
return
aString
;
}
catch
(
e
)
{
return
"
\
"
"
+
e
.
name
+
"
:
"
+
e
.
message
+
"
\
"
"
;
}
}
)
;
if
(
!
sanitizedExpressions
.
length
)
{
this
.
_currentWatchExpressions
=
null
;
this
.
_syncedWatchExpressions
=
null
;
}
else
{
this
.
_syncedWatchExpressions
=
this
.
_currentWatchExpressions
=
"
[
"
+
sanitizedExpressions
.
map
(
aString
=
>
"
eval
(
\
"
"
+
"
try
{
"
+
aString
.
replace
(
/
"
/
g
"
\
\
&
"
)
+
"
\
"
+
"
+
"
'
\
\
n
'
"
+
"
+
\
"
"
+
"
}
catch
(
e
)
{
"
+
"
e
.
name
+
'
:
'
+
e
.
message
;
"
+
"
}
"
+
"
\
"
)
"
)
.
join
(
"
"
)
+
"
]
"
;
}
this
.
currentFrameDepth
=
-
1
;
return
this
.
_onFrames
(
)
;
}
}
;
var
Prefs
=
new
ViewHelpers
.
Prefs
(
"
devtools
"
{
workersAndSourcesWidth
:
[
"
Int
"
"
debugger
.
ui
.
panes
-
workers
-
and
-
sources
-
width
"
]
instrumentsWidth
:
[
"
Int
"
"
debugger
.
ui
.
panes
-
instruments
-
width
"
]
panesVisibleOnStartup
:
[
"
Bool
"
"
debugger
.
ui
.
panes
-
visible
-
on
-
startup
"
]
variablesSortingEnabled
:
[
"
Bool
"
"
debugger
.
ui
.
variables
-
sorting
-
enabled
"
]
variablesOnlyEnumVisible
:
[
"
Bool
"
"
debugger
.
ui
.
variables
-
only
-
enum
-
visible
"
]
variablesSearchboxVisible
:
[
"
Bool
"
"
debugger
.
ui
.
variables
-
searchbox
-
visible
"
]
pauseOnExceptions
:
[
"
Bool
"
"
debugger
.
pause
-
on
-
exceptions
"
]
ignoreCaughtExceptions
:
[
"
Bool
"
"
debugger
.
ignore
-
caught
-
exceptions
"
]
sourceMapsEnabled
:
[
"
Bool
"
"
debugger
.
source
-
maps
-
enabled
"
]
prettyPrintEnabled
:
[
"
Bool
"
"
debugger
.
pretty
-
print
-
enabled
"
]
autoPrettyPrint
:
[
"
Bool
"
"
debugger
.
auto
-
pretty
-
print
"
]
workersEnabled
:
[
"
Bool
"
"
debugger
.
workers
"
]
editorTabSize
:
[
"
Int
"
"
editor
.
tabsize
"
]
autoBlackBox
:
[
"
Bool
"
"
debugger
.
auto
-
black
-
box
"
]
promiseDebuggerEnabled
:
[
"
Bool
"
"
debugger
.
promise
"
]
}
)
;
EventEmitter
.
decorate
(
this
)
;
DebuggerController
.
initialize
(
)
;
DebuggerController
.
Parser
=
new
Parser
(
)
;
DebuggerController
.
Workers
=
new
Workers
(
)
;
DebuggerController
.
ThreadState
=
new
ThreadState
(
)
;
DebuggerController
.
StackFrames
=
new
StackFrames
(
)
;
Object
.
defineProperties
(
window
{
"
gTarget
"
:
{
get
:
function
(
)
{
return
DebuggerController
.
_target
;
}
configurable
:
true
}
"
gHostType
"
:
{
get
:
function
(
)
{
return
DebuggerView
.
_hostType
;
}
configurable
:
true
}
"
gClient
"
:
{
get
:
function
(
)
{
return
DebuggerController
.
client
;
}
configurable
:
true
}
"
gThreadClient
"
:
{
get
:
function
(
)
{
return
DebuggerController
.
activeThread
;
}
configurable
:
true
}
"
gCallStackPageSize
"
:
{
get
:
function
(
)
{
return
CALL_STACK_PAGE_SIZE
;
}
configurable
:
true
}
}
)
;
function
dumpn
(
str
)
{
if
(
wantLogging
)
{
dump
(
"
DBG
-
FRONTEND
:
"
+
str
+
"
\
n
"
)
;
}
}
var
wantLogging
=
Services
.
prefs
.
getBoolPref
(
"
devtools
.
debugger
.
log
"
)
;
