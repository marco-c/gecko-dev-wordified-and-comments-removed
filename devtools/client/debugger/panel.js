"
use
strict
"
;
const
{
MultiLocalizationHelper
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
l10n
.
js
"
)
;
const
{
FluentL10n
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
fluent
-
l10n
/
fluent
-
l10n
.
js
"
)
;
loader
.
lazyRequireGetter
(
this
"
openContentLink
"
"
resource
:
/
/
devtools
/
client
/
shared
/
link
.
js
"
true
)
;
loader
.
lazyRequireGetter
(
this
"
registerStoreObserver
"
"
resource
:
/
/
devtools
/
client
/
shared
/
redux
/
subscriber
.
js
"
true
)
;
const
DBG_STRINGS_URI
=
[
"
devtools
/
client
/
locales
/
debugger
.
properties
"
"
devtools
/
client
/
locales
/
sourceeditor
.
properties
"
"
devtools
/
client
/
locales
/
startup
.
properties
"
"
devtools
/
client
/
locales
/
components
.
properties
"
"
devtools
/
client
/
locales
/
toolbox
.
properties
"
]
;
const
L10N
=
new
MultiLocalizationHelper
(
.
.
.
DBG_STRINGS_URI
)
;
async
function
getNodeFront
(
gripOrFront
toolbox
)
{
if
(
"
actorID
"
in
gripOrFront
)
{
return
new
Promise
(
resolve
=
>
resolve
(
gripOrFront
)
)
;
}
const
inspectorFront
=
await
toolbox
.
target
.
getFront
(
"
inspector
"
)
;
return
inspectorFront
.
getNodeFrontFromNodeGrip
(
gripOrFront
)
;
}
class
DebuggerPanel
{
constructor
(
iframeWindow
toolbox
commands
)
{
this
.
panelWin
=
iframeWindow
;
this
.
panelWin
.
L10N
=
L10N
;
this
.
panelWin
.
sourceMapURLService
=
toolbox
.
sourceMapURLService
;
this
.
toolbox
=
toolbox
;
this
.
commands
=
commands
;
this
.
lazyModules
=
{
}
;
}
async
open
(
)
{
const
fluentL10n
=
new
FluentL10n
(
)
;
await
fluentL10n
.
init
(
[
"
devtools
/
shared
/
debugger
-
paused
-
reasons
.
ftl
"
]
)
;
const
{
browserLoader
}
=
this
.
panelWin
;
browserLoader
.
lazyRequireGetter
(
this
.
lazyModules
"
features
"
"
resource
:
/
/
devtools
/
client
/
debugger
/
src
/
utils
/
prefs
.
js
"
true
)
;
browserLoader
.
lazyRequireGetter
(
this
.
lazyModules
"
getOriginalLocation
"
"
resource
:
/
/
devtools
/
client
/
debugger
/
src
/
utils
/
source
-
maps
.
js
"
true
)
;
browserLoader
.
lazyRequireGetter
(
this
.
lazyModules
"
createLocation
"
"
resource
:
/
/
devtools
/
client
/
debugger
/
src
/
utils
/
location
.
js
"
true
)
;
browserLoader
.
lazyRequireGetter
(
this
.
lazyModules
"
getMappedExpression
"
"
resource
:
/
/
devtools
/
client
/
debugger
/
src
/
actions
/
expressions
.
js
"
true
)
;
const
{
actions
store
selectors
client
}
=
await
this
.
panelWin
.
Debugger
.
bootstrap
(
{
commands
:
this
.
commands
fluentBundles
:
fluentL10n
.
getBundles
(
)
resourceCommand
:
this
.
commands
.
resourceCommand
workers
:
{
sourceMapLoader
:
this
.
toolbox
.
sourceMapLoader
parserWorker
:
this
.
toolbox
.
parserWorker
}
panel
:
this
}
)
;
this
.
_actions
=
actions
;
this
.
_store
=
store
;
this
.
_selectors
=
selectors
;
this
.
_client
=
client
;
registerStoreObserver
(
this
.
_store
this
.
_onDebuggerStateChange
.
bind
(
this
)
)
;
return
this
;
}
async
_onDebuggerStateChange
(
state
oldState
)
{
const
{
getCurrentThread
}
=
this
.
_selectors
;
const
currentThreadActorID
=
getCurrentThread
(
state
)
;
if
(
currentThreadActorID
&
&
currentThreadActorID
!
=
=
getCurrentThread
(
oldState
)
)
{
const
threadFront
=
this
.
commands
.
client
.
getFrontByID
(
currentThreadActorID
)
;
this
.
toolbox
.
selectTarget
(
threadFront
?
.
targetFront
.
actorID
)
;
}
this
.
toolbox
.
emit
(
"
show
-
original
-
variable
-
mapping
-
warnings
"
this
.
shouldShowOriginalVariableMappingWarnings
(
)
)
;
}
shouldShowOriginalVariableMappingWarnings
(
)
{
const
{
getSelectedSource
isMapScopesEnabled
}
=
this
.
_selectors
;
if
(
!
this
.
isPaused
(
)
|
|
isMapScopesEnabled
(
this
.
_getState
(
)
)
)
{
return
false
;
}
const
selectedSource
=
getSelectedSource
(
this
.
_getState
(
)
)
;
return
selectedSource
?
.
isOriginal
&
&
!
selectedSource
?
.
isPrettyPrinted
;
}
getVarsForTests
(
)
{
return
{
store
:
this
.
_store
selectors
:
this
.
_selectors
actions
:
this
.
_actions
client
:
this
.
_client
}
;
}
_getState
(
)
{
return
this
.
_store
.
getState
(
)
;
}
getToolboxStore
(
)
{
return
this
.
toolbox
.
store
;
}
openLink
(
url
)
{
openContentLink
(
url
)
;
}
async
openConsoleAndEvaluate
(
input
)
{
const
{
hud
}
=
await
this
.
toolbox
.
selectTool
(
"
webconsole
"
)
;
hud
.
ui
.
wrapper
.
dispatchEvaluateExpression
(
input
)
;
}
async
openInspector
(
)
{
this
.
toolbox
.
selectTool
(
"
inspector
"
)
;
}
async
openElementInInspector
(
gripOrFront
)
{
const
onSelectInspector
=
this
.
toolbox
.
selectTool
(
"
inspector
"
)
;
const
onGripNodeToFront
=
getNodeFront
(
gripOrFront
this
.
toolbox
)
;
const
[
front
inspector
]
=
await
Promise
.
all
(
[
onGripNodeToFront
onSelectInspector
]
)
;
const
onInspectorUpdated
=
inspector
.
once
(
"
inspector
-
updated
"
)
;
const
onNodeFrontSet
=
this
.
toolbox
.
selection
.
setNodeFront
(
front
{
reason
:
"
debugger
"
}
)
;
return
Promise
.
all
(
[
onNodeFrontSet
onInspectorUpdated
]
)
;
}
highlightDomElement
(
gripOrFront
)
{
if
(
!
this
.
_highlight
)
{
const
{
highlight
unhighlight
}
=
this
.
toolbox
.
getHighlighter
(
)
;
this
.
_highlight
=
highlight
;
this
.
_unhighlight
=
unhighlight
;
}
return
this
.
_highlight
(
gripOrFront
)
;
}
unHighlightDomElement
(
)
{
if
(
!
this
.
_unhighlight
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
_unhighlight
(
)
;
}
getSelectedFrameActorID
(
)
{
const
selectedFrame
=
this
.
_selectors
.
getSelectedFrame
(
this
.
_getState
(
)
)
;
if
(
selectedFrame
)
{
return
selectedFrame
.
id
;
}
return
null
;
}
getMappedExpression
(
expression
)
{
const
thread
=
this
.
_selectors
.
getCurrentThread
(
this
.
_getState
(
)
)
;
return
this
.
lazyModules
.
getMappedExpression
(
expression
thread
{
getState
:
this
.
_store
.
getState
parserWorker
:
this
.
toolbox
.
parserWorker
}
)
;
}
getMappedVariables
(
)
{
if
(
!
this
.
_selectors
.
isMapScopesEnabled
(
this
.
_getState
(
)
)
)
{
return
null
;
}
const
thread
=
this
.
_selectors
.
getCurrentThread
(
this
.
_getState
(
)
)
;
return
this
.
_selectors
.
getSelectedScopeMappings
(
this
.
_getState
(
)
thread
)
;
}
isPaused
(
)
{
const
thread
=
this
.
_selectors
.
getCurrentThread
(
this
.
_getState
(
)
)
;
return
this
.
_selectors
.
getIsPaused
(
this
.
_getState
(
)
thread
)
;
}
selectSourceURL
(
url
line
column
)
{
return
this
.
_actions
.
selectSourceURL
(
url
{
line
column
}
)
;
}
async
openSourceInDebugger
(
{
generatedURL
generatedLine
generatedColumn
sourceActorId
reason
}
)
{
generatedURL
=
URL
.
parse
(
generatedURL
)
?
.
href
|
|
generatedURL
;
const
generatedSource
=
sourceActorId
?
this
.
_selectors
.
getSourceByActorId
(
this
.
_getState
(
)
sourceActorId
)
:
this
.
_selectors
.
getSourceByURL
(
this
.
_getState
(
)
generatedURL
)
;
if
(
!
generatedSource
|
|
!
this
.
_selectors
.
getSourceActorsForSource
(
this
.
_getState
(
)
generatedSource
.
id
)
.
length
)
{
return
false
;
}
const
generatedLocation
=
this
.
lazyModules
.
createLocation
(
{
source
:
generatedSource
line
:
generatedLine
column
:
generatedColumn
}
)
;
const
originalLocation
=
await
this
.
lazyModules
.
getOriginalLocation
(
generatedLocation
{
sourceMapLoader
:
this
.
toolbox
.
sourceMapLoader
getState
:
this
.
_store
.
getState
}
)
;
await
this
.
toolbox
.
selectTool
(
"
jsdebugger
"
reason
)
;
const
hasLogpoint
=
this
.
_selectors
.
hasLogpoint
(
this
.
_getState
(
)
originalLocation
)
;
await
this
.
_actions
.
selectLocation
(
originalLocation
{
keepContext
:
false
highlight
:
!
hasLogpoint
}
)
;
if
(
hasLogpoint
)
{
this
.
_actions
.
openConditionalPanel
(
originalLocation
true
)
;
}
return
true
;
}
async
selectServiceWorker
(
workerDescriptorFront
)
{
const
targets
=
this
.
commands
.
targetCommand
.
getAllTargets
(
[
this
.
commands
.
targetCommand
.
TYPES
.
SERVICE_WORKER
]
)
;
const
workerTarget
=
targets
.
find
(
target
=
>
target
.
id
=
=
workerDescriptorFront
.
id
)
;
const
threadFront
=
await
workerTarget
.
getFront
(
"
thread
"
)
;
const
threadActorID
=
threadFront
?
.
actorID
;
const
isThreadAvailable
=
this
.
_selectors
.
getThreads
(
this
.
_getState
(
)
)
.
find
(
x
=
>
x
.
actor
=
=
=
threadActorID
)
;
if
(
!
this
.
lazyModules
.
features
.
windowlessServiceWorkers
)
{
console
.
error
(
"
Selecting
a
worker
needs
the
pref
debugger
.
features
.
windowless
-
service
-
workers
set
to
true
"
)
;
return
;
}
if
(
!
isThreadAvailable
)
{
console
.
error
(
Worker
{
threadActorID
}
is
not
available
for
debugging
)
;
return
;
}
this
.
selectThread
(
threadActorID
)
;
const
source
=
this
.
_selectors
.
getSourceByURL
(
this
.
_getState
(
)
workerDescriptorFront
.
_url
)
;
const
sourceActor
=
this
.
_selectors
.
getFirstSourceActorForGeneratedSource
(
this
.
_getState
(
)
source
.
id
threadActorID
)
;
await
this
.
_actions
.
selectSource
(
source
sourceActor
)
;
}
selectThread
(
threadActorID
)
{
this
.
_actions
.
selectThread
(
threadActorID
)
;
}
showTracerSidebar
(
)
{
this
.
_actions
.
setPrimaryPaneTab
(
"
tracer
"
)
;
}
destroy
(
)
{
this
.
panelWin
.
Debugger
.
destroy
(
)
;
this
.
lazyModules
=
{
}
;
this
.
emit
(
"
destroyed
"
)
;
}
}
exports
.
DebuggerPanel
=
DebuggerPanel
;
