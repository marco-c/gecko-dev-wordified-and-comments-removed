import
{
getSettledSourceTextContent
isMapScopesEnabled
getSelectedFrame
getGeneratedFrameScope
getOriginalFrameScope
getFirstSourceActorForGeneratedSource
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
import
{
loadOriginalSourceText
loadGeneratedSourceText
}
from
"
.
.
/
sources
/
loadSourceText
"
;
import
{
validateSelectedFrame
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
const
{
PROMISE
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
redux
/
middleware
/
promise
.
js
"
)
;
import
{
log
}
from
"
.
.
/
.
.
/
utils
/
log
"
;
import
{
buildMappedScopes
}
from
"
.
.
/
.
.
/
utils
/
pause
/
mapScopes
/
index
"
;
import
{
isFulfilled
}
from
"
.
.
/
.
.
/
utils
/
async
-
value
"
;
import
{
getMappedLocation
}
from
"
.
.
/
.
.
/
utils
/
source
-
maps
"
;
const
expressionRegex
=
/
\
bfp
\
(
\
)
/
g
;
export
async
function
buildOriginalScopes
(
selectedFrame
client
generatedScopes
)
{
if
(
!
selectedFrame
.
originalVariables
)
{
throw
new
TypeError
(
"
(
frame
.
originalVariables
:
XScopeVariables
)
"
)
;
}
const
originalVariables
=
selectedFrame
.
originalVariables
;
const
frameBase
=
originalVariables
.
frameBase
|
|
"
"
;
const
inputs
=
[
]
;
for
(
let
i
=
0
;
i
<
originalVariables
.
vars
.
length
;
i
+
+
)
{
const
{
expr
}
=
originalVariables
.
vars
[
i
]
;
const
expression
=
expr
?
expr
.
replace
(
expressionRegex
frameBase
)
:
"
void
0
"
;
inputs
[
i
]
=
expression
;
}
const
results
=
await
client
.
evaluateExpressions
(
inputs
{
frameId
:
selectedFrame
.
id
}
)
;
const
variables
=
{
}
;
for
(
let
i
=
0
;
i
<
originalVariables
.
vars
.
length
;
i
+
+
)
{
const
{
name
}
=
originalVariables
.
vars
[
i
]
;
variables
[
name
]
=
{
value
:
results
[
i
]
.
result
}
;
}
const
bindings
=
{
arguments
:
[
]
variables
}
;
const
{
actor
}
=
await
generatedScopes
;
const
scope
=
{
type
:
"
function
"
scopeKind
:
"
"
actor
bindings
parent
:
null
function
:
null
block
:
null
}
;
return
{
mappings
:
{
}
scope
}
;
}
export
function
toggleMapScopes
(
)
{
return
async
function
(
{
dispatch
getState
}
)
{
if
(
isMapScopesEnabled
(
getState
(
)
)
)
{
dispatch
(
{
type
:
"
TOGGLE_MAP_SCOPES
"
mapScopes
:
false
}
)
;
return
;
}
dispatch
(
{
type
:
"
TOGGLE_MAP_SCOPES
"
mapScopes
:
true
}
)
;
const
state
=
getState
(
)
;
const
selectedFrame
=
getSelectedFrame
(
state
)
;
if
(
!
selectedFrame
)
{
return
;
}
if
(
getOriginalFrameScope
(
getState
(
)
selectedFrame
)
)
{
return
;
}
const
scopes
=
getGeneratedFrameScope
(
getState
(
)
selectedFrame
)
;
if
(
!
scopes
)
{
return
;
}
dispatch
(
mapScopes
(
selectedFrame
Promise
.
resolve
(
scopes
.
scope
)
)
)
;
}
;
}
export
function
mapScopes
(
selectedFrame
scopes
)
{
return
async
function
(
thunkArgs
)
{
const
{
getState
dispatch
client
}
=
thunkArgs
;
await
dispatch
(
{
type
:
"
MAP_SCOPES
"
selectedFrame
[
PROMISE
]
:
(
async
function
(
)
{
if
(
selectedFrame
.
isOriginal
&
&
selectedFrame
.
originalVariables
)
{
return
buildOriginalScopes
(
selectedFrame
client
scopes
)
;
}
validateSelectedFrame
(
getState
(
)
selectedFrame
)
;
return
dispatch
(
getMappedScopes
(
scopes
selectedFrame
)
)
;
}
)
(
)
}
)
;
}
;
}
export
function
getMappedScopes
(
scopes
locations
)
{
return
async
function
(
thunkArgs
)
{
const
{
getState
dispatch
}
=
thunkArgs
;
const
generatedSource
=
locations
.
generatedLocation
.
source
;
const
source
=
locations
.
location
.
source
;
if
(
!
isMapScopesEnabled
(
getState
(
)
)
|
|
!
source
|
|
!
generatedSource
|
|
generatedSource
.
isWasm
|
|
source
.
isPrettyPrinted
|
|
!
source
.
isOriginal
)
{
return
null
;
}
await
dispatch
(
loadOriginalSourceText
(
source
)
)
;
const
generatedSourceActor
=
getFirstSourceActorForGeneratedSource
(
getState
(
)
generatedSource
.
id
)
;
await
dispatch
(
loadGeneratedSourceText
(
generatedSourceActor
)
)
;
try
{
const
content
=
getSettledSourceTextContent
(
getState
(
)
locations
.
location
)
;
return
await
buildMappedScopes
(
source
content
&
&
isFulfilled
(
content
)
?
content
.
value
:
{
type
:
"
text
"
value
:
"
"
contentType
:
undefined
}
locations
await
scopes
thunkArgs
)
;
}
catch
(
e
)
{
log
(
e
)
;
return
null
;
}
}
;
}
export
function
getMappedScopesForLocation
(
location
)
{
return
async
function
(
thunkArgs
)
{
const
{
dispatch
}
=
thunkArgs
;
const
mappedLocation
=
await
getMappedLocation
(
location
thunkArgs
)
;
return
dispatch
(
getMappedScopes
(
null
mappedLocation
)
)
;
}
;
}
