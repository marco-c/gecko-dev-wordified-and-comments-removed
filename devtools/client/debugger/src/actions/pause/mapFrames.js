import
{
getFrames
getBlackBoxRanges
getSelectedFrame
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
isFrameBlackBoxed
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
assert
from
"
.
.
/
.
.
/
utils
/
assert
"
;
import
{
getOriginalLocation
}
from
"
.
.
/
.
.
/
utils
/
source
-
maps
"
;
import
{
debuggerToSourceMapLocation
sourceMapToDebuggerLocation
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
isGeneratedId
}
from
"
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
"
;
import
{
annotateFramesWithLibrary
}
from
"
.
.
/
.
.
/
utils
/
pause
/
frames
/
annotateFrames
"
;
import
{
createWasmOriginalFrame
}
from
"
.
.
/
.
.
/
client
/
firefox
/
create
"
;
function
getSelectedFrameId
(
state
thread
frames
)
{
let
selectedFrame
=
getSelectedFrame
(
state
thread
)
;
const
blackboxedRanges
=
getBlackBoxRanges
(
state
)
;
if
(
selectedFrame
&
&
!
isFrameBlackBoxed
(
selectedFrame
blackboxedRanges
)
)
{
return
selectedFrame
.
id
;
}
selectedFrame
=
frames
.
find
(
frame
=
>
{
return
!
isFrameBlackBoxed
(
frame
blackboxedRanges
)
;
}
)
;
return
selectedFrame
?
.
id
;
}
async
function
updateFrameLocation
(
frame
thunkArgs
)
{
if
(
frame
.
isOriginal
)
{
return
Promise
.
resolve
(
frame
)
;
}
const
location
=
await
getOriginalLocation
(
frame
.
location
thunkArgs
true
)
;
if
(
location
=
=
frame
.
location
)
{
return
frame
;
}
return
{
.
.
.
frame
location
generatedLocation
:
frame
.
generatedLocation
|
|
frame
.
location
}
;
}
function
updateFrameLocations
(
frames
thunkArgs
)
{
if
(
!
frames
|
|
!
frames
.
length
)
{
return
Promise
.
resolve
(
frames
)
;
}
return
Promise
.
all
(
frames
.
map
(
frame
=
>
updateFrameLocation
(
frame
thunkArgs
)
)
)
;
}
function
isWasmOriginalSourceFrame
(
frame
)
{
if
(
isGeneratedId
(
frame
.
location
.
source
.
id
)
)
{
return
false
;
}
return
Boolean
(
frame
.
generatedLocation
?
.
source
.
isWasm
)
;
}
async
function
expandWasmFrames
(
frames
{
getState
sourceMapLoader
}
)
{
const
result
=
[
]
;
for
(
let
i
=
0
;
i
<
frames
.
length
;
+
+
i
)
{
const
frame
=
frames
[
i
]
;
if
(
frame
.
isOriginal
|
|
!
isWasmOriginalSourceFrame
(
frame
)
)
{
result
.
push
(
frame
)
;
continue
;
}
const
originalFrames
=
await
sourceMapLoader
.
getOriginalStackFrames
(
debuggerToSourceMapLocation
(
frame
.
generatedLocation
)
)
;
if
(
!
originalFrames
)
{
result
.
push
(
frame
)
;
continue
;
}
assert
(
!
!
originalFrames
.
length
"
Expected
at
least
one
original
frame
"
)
;
originalFrames
[
0
]
.
location
=
frame
.
location
;
originalFrames
.
forEach
(
(
originalFrame
j
)
=
>
{
if
(
!
originalFrame
.
location
)
{
return
;
}
const
id
=
j
=
=
0
?
frame
.
id
:
{
frame
.
id
}
-
originalFrame
{
j
}
;
const
originalFrameLocation
=
sourceMapToDebuggerLocation
(
getState
(
)
originalFrame
.
location
)
;
result
.
push
(
createWasmOriginalFrame
(
frame
id
originalFrame
originalFrameLocation
)
)
;
}
)
;
}
return
result
;
}
export
function
mapFrames
(
thread
)
{
return
async
function
(
thunkArgs
)
{
const
{
dispatch
getState
}
=
thunkArgs
;
const
frames
=
getFrames
(
getState
(
)
thread
)
;
if
(
!
frames
)
{
return
;
}
let
mappedFrames
=
await
updateFrameLocations
(
frames
thunkArgs
)
;
mappedFrames
=
await
expandWasmFrames
(
mappedFrames
thunkArgs
)
;
annotateFramesWithLibrary
(
mappedFrames
)
;
const
selectedFrameId
=
getSelectedFrameId
(
getState
(
)
thread
mappedFrames
)
;
dispatch
(
{
type
:
"
MAP_FRAMES
"
thread
frames
:
mappedFrames
selectedFrameId
}
)
;
}
;
}
