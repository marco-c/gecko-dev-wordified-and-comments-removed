import
{
getSelectedFrame
getCurrentThread
getIsCurrentThreadPaused
getIsPaused
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
const
{
PROMISE
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
redux
/
middleware
/
promise
.
js
"
)
;
import
{
evaluateExpressions
}
from
"
.
.
/
expressions
"
;
import
{
selectLocation
}
from
"
.
.
/
sources
/
index
"
;
import
{
fetchScopes
}
from
"
.
/
fetchScopes
"
;
import
{
fetchFrames
}
from
"
.
/
fetchFrames
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
{
validateFrame
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
export
function
selectThread
(
thread
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
if
(
getCurrentThread
(
getState
(
)
)
=
=
=
thread
)
{
return
;
}
dispatch
(
{
type
:
"
SELECT_THREAD
"
thread
}
)
;
if
(
getCurrentThread
(
getState
(
)
)
!
=
=
thread
)
{
throw
new
Error
(
"
The
thread
wasn
'
t
selected
"
)
;
}
const
selectedFrame
=
getSelectedFrame
(
getState
(
)
)
;
const
serverRequests
=
[
]
;
serverRequests
.
push
(
dispatch
(
evaluateExpressions
(
selectedFrame
)
)
)
;
if
(
selectedFrame
)
{
serverRequests
.
push
(
dispatch
(
selectLocation
(
selectedFrame
.
location
)
)
)
;
serverRequests
.
push
(
dispatch
(
fetchFrames
(
thread
)
)
)
;
serverRequests
.
push
(
dispatch
(
fetchScopes
(
)
)
)
;
}
await
Promise
.
all
(
serverRequests
)
;
}
;
}
export
function
command
(
type
)
{
return
async
(
{
dispatch
getState
client
}
)
=
>
{
if
(
!
type
)
{
return
null
;
}
const
thread
=
getCurrentThread
(
getState
(
)
)
;
const
frame
=
getSelectedFrame
(
getState
(
)
)
;
return
dispatch
(
{
type
:
"
COMMAND
"
command
:
type
thread
[
PROMISE
]
:
client
[
type
]
(
thread
frame
?
.
id
)
}
)
;
}
;
}
export
function
stepIn
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
!
getIsCurrentThreadPaused
(
getState
(
)
)
)
{
return
null
;
}
return
dispatch
(
command
(
"
stepIn
"
)
)
;
}
;
}
export
function
stepOver
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
!
getIsCurrentThreadPaused
(
getState
(
)
)
)
{
return
null
;
}
return
dispatch
(
command
(
"
stepOver
"
)
)
;
}
;
}
export
function
stepOut
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
!
getIsCurrentThreadPaused
(
getState
(
)
)
)
{
return
null
;
}
return
dispatch
(
command
(
"
stepOut
"
)
)
;
}
;
}
export
function
resume
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
!
getIsCurrentThreadPaused
(
getState
(
)
)
)
{
return
null
;
}
recordEvent
(
"
continue
"
)
;
return
dispatch
(
command
(
"
resume
"
)
)
;
}
;
}
export
function
restart
(
frame
)
{
return
async
(
{
dispatch
getState
client
}
)
=
>
{
if
(
!
getIsPaused
(
getState
(
)
frame
.
thread
)
)
{
return
null
;
}
validateFrame
(
getState
(
)
frame
)
;
return
dispatch
(
{
type
:
"
COMMAND
"
command
:
"
restart
"
thread
:
frame
.
thread
[
PROMISE
]
:
client
.
restart
(
frame
.
thread
frame
.
id
)
}
)
;
}
;
}
