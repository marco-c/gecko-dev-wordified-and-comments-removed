import
{
getSelectedFrame
getThreadContext
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
PROMISE
}
from
"
.
.
/
utils
/
middleware
/
promise
"
;
import
{
evaluateExpressions
}
from
"
.
.
/
expressions
"
;
import
{
selectLocation
}
from
"
.
.
/
sources
"
;
import
{
fetchScopes
}
from
"
.
/
fetchScopes
"
;
import
{
fetchFrames
}
from
"
.
/
fetchFrames
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
assert
from
"
.
.
/
.
.
/
utils
/
assert
"
;
import
type
{
ThreadId
Context
ThreadContext
ExecutionPoint
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
ThunkArgs
}
from
"
.
.
/
types
"
;
import
type
{
Command
}
from
"
.
.
/
.
.
/
reducers
/
types
"
;
export
function
selectThread
(
cx
:
Context
thread
:
ThreadId
)
{
return
async
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
await
dispatch
(
{
cx
type
:
"
SELECT_THREAD
"
thread
}
)
;
const
threadcx
=
getThreadContext
(
getState
(
)
)
;
assert
(
threadcx
.
thread
=
=
thread
"
Thread
mismatch
"
)
;
const
serverRequests
=
[
]
;
serverRequests
.
push
(
dispatch
(
evaluateExpressions
(
threadcx
)
)
)
;
const
frame
=
getSelectedFrame
(
getState
(
)
thread
)
;
if
(
frame
)
{
serverRequests
.
push
(
dispatch
(
selectLocation
(
threadcx
frame
.
location
)
)
)
;
serverRequests
.
push
(
dispatch
(
fetchFrames
(
threadcx
)
)
)
;
serverRequests
.
push
(
dispatch
(
fetchScopes
(
threadcx
)
)
)
;
}
await
Promise
.
all
(
serverRequests
)
;
}
;
}
export
function
command
(
cx
:
ThreadContext
type
:
Command
)
{
return
async
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
if
(
type
)
{
return
dispatch
(
{
type
:
"
COMMAND
"
command
:
type
cx
thread
:
cx
.
thread
[
PROMISE
]
:
client
[
type
]
(
cx
.
thread
)
}
)
;
}
}
;
}
export
function
seekToPosition
(
position
:
ExecutionPoint
)
{
return
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
const
cx
=
getThreadContext
(
getState
(
)
)
;
client
.
timeWarp
(
position
)
;
dispatch
(
{
type
:
"
COMMAND
"
command
:
"
timeWarp
"
status
:
"
start
"
thread
:
cx
.
thread
}
)
;
}
;
}
export
function
stepIn
(
cx
:
ThreadContext
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
if
(
cx
.
isPaused
)
{
return
dispatch
(
command
(
cx
"
stepIn
"
)
)
;
}
}
;
}
export
function
stepOver
(
cx
:
ThreadContext
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
if
(
cx
.
isPaused
)
{
return
dispatch
(
command
(
cx
"
stepOver
"
)
)
;
}
}
;
}
export
function
stepOut
(
cx
:
ThreadContext
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
if
(
cx
.
isPaused
)
{
return
dispatch
(
command
(
cx
"
stepOut
"
)
)
;
}
}
;
}
export
function
resume
(
cx
:
ThreadContext
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
if
(
cx
.
isPaused
)
{
recordEvent
(
"
continue
"
)
;
return
dispatch
(
command
(
cx
"
resume
"
)
)
;
}
}
;
}
export
function
rewind
(
cx
:
ThreadContext
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
if
(
cx
.
isPaused
)
{
return
dispatch
(
command
(
cx
"
rewind
"
)
)
;
}
}
;
}
export
function
reverseStepOver
(
cx
:
ThreadContext
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
if
(
cx
.
isPaused
)
{
return
dispatch
(
command
(
cx
"
reverseStepOver
"
)
)
;
}
}
;
}
