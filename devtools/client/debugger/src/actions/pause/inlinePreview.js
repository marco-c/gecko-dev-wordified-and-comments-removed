import
{
getSelectedFrameInlinePreviews
getSelectedLocation
getSelectedScope
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
import
{
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
{
validateSelectedFrame
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
function
getScopeLevels
(
scope
)
{
let
levels
=
0
;
while
(
scope
&
&
scope
.
type
=
=
=
"
block
"
)
{
levels
+
+
;
scope
=
scope
.
parent
;
}
return
levels
;
}
export
function
generateInlinePreview
(
selectedFrame
)
{
return
async
function
(
{
dispatch
getState
parserWorker
client
}
)
{
if
(
!
features
.
inlinePreview
)
{
return
null
;
}
if
(
getSelectedFrameInlinePreviews
(
getState
(
)
)
)
{
return
null
;
}
let
scopes
=
getSelectedScope
(
getState
(
)
)
;
if
(
!
scopes
|
|
!
scopes
.
bindings
)
{
return
null
;
}
const
selectedLocation
=
getSelectedLocation
(
getState
(
)
)
;
if
(
!
selectedLocation
)
{
return
null
;
}
if
(
!
parserWorker
.
isLocationSupported
(
selectedLocation
)
)
{
return
null
;
}
const
originalAstScopes
=
await
parserWorker
.
getScopes
(
selectedLocation
)
;
validateSelectedFrame
(
getState
(
)
selectedFrame
)
;
if
(
!
originalAstScopes
)
{
return
null
;
}
const
allPreviews
=
[
]
;
const
pausedOnLine
=
selectedLocation
.
line
;
const
levels
=
getScopeLevels
(
scopes
)
;
for
(
let
curLevel
=
0
;
curLevel
<
=
levels
&
&
scopes
&
&
scopes
.
bindings
;
curLevel
+
+
)
{
const
bindings
=
getScopeBindings
(
scopes
)
;
const
allPreviewBindingsComplete
=
Object
.
keys
(
bindings
)
.
map
(
async
name
=
>
{
const
previews
=
await
generatePreviewsForBinding
(
originalAstScopes
[
curLevel
]
?
.
bindings
[
name
]
pausedOnLine
name
bindings
[
name
]
.
value
client
selectedFrame
.
thread
)
;
allPreviews
.
push
(
.
.
.
previews
)
;
}
)
;
await
Promise
.
all
(
allPreviewBindingsComplete
)
;
validateSelectedFrame
(
getState
(
)
selectedFrame
)
;
scopes
=
scopes
.
parent
;
}
allPreviews
.
sort
(
(
previewA
previewB
)
=
>
{
if
(
previewA
.
line
<
previewB
.
line
)
{
return
-
1
;
}
if
(
previewA
.
line
>
previewB
.
line
)
{
return
1
;
}
return
previewA
.
column
<
previewB
.
column
?
-
1
:
1
;
}
)
;
const
previews
=
{
}
;
for
(
const
preview
of
allPreviews
)
{
const
{
line
}
=
preview
;
if
(
!
previews
[
line
]
)
{
previews
[
line
]
=
[
]
;
}
previews
[
line
]
.
push
(
preview
)
;
}
return
dispatch
(
{
type
:
"
ADD_INLINE_PREVIEW
"
selectedFrame
previews
}
)
;
}
;
}
function
getScopeBindings
(
scopes
)
{
const
bindings
=
{
.
.
.
scopes
.
bindings
.
variables
}
;
scopes
.
bindings
.
arguments
.
forEach
(
argument
=
>
{
Object
.
keys
(
argument
)
.
forEach
(
key
=
>
{
bindings
[
key
]
=
argument
[
key
]
;
}
)
;
}
)
;
return
bindings
;
}
async
function
generatePreviewsForBinding
(
bindingData
pausedOnLine
name
value
client
thread
)
{
if
(
!
bindingData
)
{
return
[
]
;
}
const
identifiers
=
new
Set
(
)
;
const
previews
=
[
]
;
for
(
let
i
=
bindingData
.
refs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
ref
=
bindingData
.
refs
[
i
]
;
const
line
=
ref
.
start
.
line
-
1
;
const
column
=
ref
.
start
.
column
;
if
(
line
>
=
pausedOnLine
-
1
)
{
continue
;
}
const
{
displayName
displayValue
}
=
await
getExpressionNameAndValue
(
name
value
ref
client
thread
)
;
if
(
identifiers
.
has
(
displayName
)
)
{
continue
;
}
identifiers
.
add
(
displayName
)
;
previews
.
push
(
{
line
column
type
:
"
paused
"
name
:
displayName
value
:
displayValue
}
)
;
}
return
previews
;
}
async
function
getExpressionNameAndValue
(
name
value
ref
client
thread
)
{
let
displayName
=
name
;
let
displayValue
=
value
;
let
properties
=
null
;
if
(
value
.
actor
&
&
value
.
class
=
=
=
"
Object
"
)
{
properties
=
await
client
.
loadObjectProperties
(
{
name
path
:
name
contents
:
{
value
}
}
thread
)
;
}
if
(
properties
)
{
let
{
meta
}
=
ref
;
while
(
meta
)
{
if
(
displayValue
=
=
=
value
)
{
const
property
=
properties
.
find
(
prop
=
>
prop
.
name
=
=
=
meta
.
property
)
;
displayValue
=
property
?
.
contents
.
value
;
displayName
+
=
.
{
meta
.
property
}
;
}
else
if
(
displayValue
?
.
preview
?
.
ownProperties
)
{
const
{
ownProperties
}
=
displayValue
.
preview
;
Object
.
keys
(
ownProperties
)
.
forEach
(
prop
=
>
{
if
(
prop
=
=
=
meta
.
property
)
{
displayValue
=
ownProperties
[
prop
]
.
value
;
displayName
+
=
.
{
meta
.
property
}
;
}
}
)
;
}
meta
=
meta
.
parent
;
}
}
return
{
displayName
displayValue
}
;
}
