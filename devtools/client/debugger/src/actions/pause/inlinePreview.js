import
{
sortBy
}
from
"
lodash
"
;
import
{
getOriginalFrameScope
getGeneratedFrameScope
getInlinePreviews
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
{
validateThreadContext
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
import
type
{
OriginalScope
}
from
"
.
.
/
.
.
/
utils
/
pause
/
mapScopes
"
;
import
type
{
ThreadContext
Frame
Scope
Preview
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
ThunkArgs
}
from
"
.
.
/
types
"
;
function
getLocalScopeLevels
(
originalAstScopes
)
:
number
{
let
levels
=
0
;
while
(
originalAstScopes
[
levels
]
&
&
originalAstScopes
[
levels
]
.
type
=
=
=
"
block
"
)
{
levels
+
+
;
}
return
levels
;
}
export
function
generateInlinePreview
(
cx
:
ThreadContext
frame
:
?
Frame
)
{
return
async
function
(
{
dispatch
getState
parser
client
}
:
ThunkArgs
)
{
if
(
!
frame
|
|
!
features
.
inlinePreview
)
{
return
;
}
const
{
thread
}
=
cx
;
if
(
getInlinePreviews
(
getState
(
)
thread
frame
.
id
)
)
{
return
;
}
const
originalFrameScopes
=
getOriginalFrameScope
(
getState
(
)
thread
frame
.
location
.
sourceId
frame
.
id
)
;
const
generatedFrameScopes
=
getGeneratedFrameScope
(
getState
(
)
thread
frame
.
id
)
;
let
scopes
:
?
OriginalScope
|
Scope
|
null
=
(
originalFrameScopes
&
&
originalFrameScopes
.
scope
)
|
|
(
generatedFrameScopes
&
&
generatedFrameScopes
.
scope
)
;
if
(
!
scopes
|
|
!
scopes
.
bindings
)
{
return
;
}
const
originalAstScopes
=
await
parser
.
getScopes
(
frame
.
location
)
;
validateThreadContext
(
getState
(
)
cx
)
;
if
(
!
originalAstScopes
)
{
return
;
}
const
allPreviews
=
[
]
;
const
pausedOnLine
:
number
=
frame
.
location
.
line
;
const
levels
:
number
=
getLocalScopeLevels
(
originalAstScopes
)
;
for
(
let
curLevel
=
0
;
curLevel
<
=
levels
&
&
scopes
&
&
scopes
.
bindings
;
curLevel
+
+
)
{
const
bindings
=
{
.
.
.
scopes
.
bindings
.
variables
}
;
scopes
.
bindings
.
arguments
.
forEach
(
argument
=
>
{
Object
.
keys
(
argument
)
.
forEach
(
key
=
>
{
bindings
[
key
]
=
argument
[
key
]
;
}
)
;
}
)
;
const
previewBindings
=
Object
.
keys
(
bindings
)
.
map
(
async
name
=
>
{
let
properties
=
null
;
const
objectFront
=
bindings
[
name
]
.
value
;
if
(
objectFront
.
actorID
&
&
objectFront
.
class
=
=
=
"
Object
"
)
{
properties
=
await
client
.
loadObjectProperties
(
{
name
path
:
name
contents
:
{
value
:
objectFront
}
}
)
;
}
const
previewsFromBindings
:
Array
<
Preview
>
=
getBindingValues
(
originalAstScopes
pausedOnLine
name
bindings
[
name
]
.
value
curLevel
properties
)
;
allPreviews
.
push
(
.
.
.
previewsFromBindings
)
;
}
)
;
await
Promise
.
all
(
previewBindings
)
;
scopes
=
scopes
.
parent
;
}
const
previews
=
{
}
;
const
sortedPreviews
=
sortBy
(
allPreviews
[
"
line
"
"
column
"
]
)
;
sortedPreviews
.
forEach
(
preview
=
>
{
const
{
line
}
=
preview
;
if
(
!
previews
[
line
]
)
{
previews
[
line
]
=
[
preview
]
;
}
else
{
previews
[
line
]
.
push
(
preview
)
;
}
}
)
;
return
dispatch
(
{
type
:
"
ADD_INLINE_PREVIEW
"
thread
frame
previews
}
)
;
}
;
}
function
getBindingValues
(
originalAstScopes
:
Object
pausedOnLine
:
number
name
:
string
value
:
any
curLevel
:
number
properties
:
Array
<
Object
>
|
null
)
:
Array
<
Preview
>
{
const
previews
=
[
]
;
const
binding
=
originalAstScopes
[
curLevel
]
&
&
originalAstScopes
[
curLevel
]
.
bindings
[
name
]
;
if
(
!
binding
)
{
return
previews
;
}
const
identifiers
=
new
Set
(
)
;
for
(
let
i
=
binding
.
refs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
ref
=
binding
.
refs
[
i
]
;
const
line
=
ref
.
start
.
line
-
1
;
const
column
:
number
=
ref
.
start
.
column
;
if
(
line
>
=
pausedOnLine
-
1
)
{
continue
;
}
const
{
displayName
displayValue
}
=
getExpressionNameAndValue
(
name
value
ref
properties
)
;
if
(
identifiers
.
has
(
displayName
)
)
{
continue
;
}
identifiers
.
add
(
displayName
)
;
previews
.
push
(
{
line
column
name
:
displayName
value
:
displayValue
}
)
;
}
return
previews
;
}
function
getExpressionNameAndValue
(
name
:
string
value
:
any
ref
:
Object
properties
:
Array
<
Object
>
|
null
)
{
let
displayName
=
name
;
let
displayValue
=
value
;
if
(
properties
)
{
let
{
meta
}
=
ref
;
while
(
meta
)
{
if
(
displayValue
=
=
=
value
)
{
const
property
:
Object
=
properties
.
find
(
prop
=
>
prop
.
name
=
=
=
meta
.
property
)
;
displayValue
=
property
&
&
property
.
contents
.
value
;
displayName
+
=
.
{
meta
.
property
}
;
}
else
if
(
displayValue
&
&
displayValue
.
preview
&
&
displayValue
.
preview
.
ownProperties
)
{
const
{
ownProperties
}
=
displayValue
.
preview
;
Object
.
keys
(
ownProperties
)
.
forEach
(
prop
=
>
{
if
(
prop
=
=
=
meta
.
property
)
{
displayValue
=
ownProperties
[
prop
]
.
value
;
displayName
+
=
.
{
meta
.
property
}
;
}
}
)
;
}
meta
=
meta
.
parent
;
}
}
return
{
displayName
displayValue
}
;
}
