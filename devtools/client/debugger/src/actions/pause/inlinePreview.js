import
{
getSelectedFrameInlinePreviews
getSelectedLocation
getSelectedScope
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
import
{
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
{
getEditor
}
from
"
.
.
/
.
.
/
utils
/
editor
/
index
"
;
import
{
validateSelectedFrame
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
export
function
generateInlinePreview
(
selectedFrame
)
{
return
async
function
(
thunkArgs
)
{
const
{
dispatch
getState
}
=
thunkArgs
;
if
(
!
features
.
inlinePreview
)
{
return
null
;
}
if
(
getSelectedFrameInlinePreviews
(
getState
(
)
)
)
{
return
null
;
}
const
scope
=
getSelectedScope
(
getState
(
)
)
;
if
(
!
scope
|
|
!
scope
.
bindings
)
{
return
null
;
}
const
allPreviews
=
await
getPreviews
(
selectedFrame
scope
thunkArgs
)
;
allPreviews
.
sort
(
(
previewA
previewB
)
=
>
{
if
(
previewA
.
line
<
previewB
.
line
)
{
return
-
1
;
}
if
(
previewA
.
line
>
previewB
.
line
)
{
return
1
;
}
return
previewA
.
column
<
previewB
.
column
?
-
1
:
1
;
}
)
;
const
previews
=
{
}
;
for
(
const
preview
of
allPreviews
)
{
const
{
line
}
=
preview
;
if
(
!
previews
[
line
]
)
{
previews
[
line
]
=
[
]
;
}
previews
[
line
]
.
push
(
preview
)
;
}
validateSelectedFrame
(
getState
(
)
selectedFrame
)
;
return
dispatch
(
{
type
:
"
ADD_INLINE_PREVIEW
"
selectedFrame
previews
}
)
;
}
;
}
async
function
getPreviews
(
selectedFrame
scope
thunkArgs
)
{
const
{
client
getState
}
=
thunkArgs
;
const
selectedLocation
=
getSelectedLocation
(
getState
(
)
)
;
if
(
!
selectedLocation
)
{
return
[
]
;
}
const
editor
=
getEditor
(
)
;
if
(
editor
.
isWasm
)
{
return
[
]
;
}
const
allPreviews
=
[
]
;
const
seenBindings
=
{
}
;
const
bindingReferences
=
await
editor
.
getBindingReferences
(
selectedLocation
scope
)
;
validateSelectedFrame
(
getState
(
)
selectedFrame
)
;
for
(
const
level
in
bindingReferences
)
{
for
(
const
name
in
bindingReferences
[
level
]
)
{
const
valueActorID
=
bindingReferences
[
level
]
[
name
]
.
value
?
.
actor
;
if
(
seenBindings
[
name
]
&
&
seenBindings
[
name
]
=
=
valueActorID
)
{
continue
;
}
const
previews
=
await
generatePreviewsForBinding
(
bindingReferences
[
level
]
[
name
]
selectedLocation
.
line
name
client
selectedFrame
.
thread
)
;
seenBindings
[
name
]
=
valueActorID
;
allPreviews
.
push
(
.
.
.
previews
)
;
}
}
return
allPreviews
;
}
async
function
generatePreviewsForBinding
(
bindingData
pausedOnLine
name
client
thread
)
{
if
(
!
bindingData
)
{
return
[
]
;
}
const
identifiers
=
new
Set
(
)
;
const
previews
=
[
]
;
for
(
let
i
=
bindingData
.
refs
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
ref
=
bindingData
.
refs
[
i
]
;
const
line
=
ref
.
start
.
line
;
const
column
=
ref
.
start
.
column
;
if
(
line
>
=
pausedOnLine
)
{
continue
;
}
if
(
bindingData
.
value
=
=
undefined
)
{
continue
;
}
const
{
displayName
displayValue
}
=
await
getExpressionNameAndValue
(
name
bindingData
.
value
ref
client
thread
)
;
if
(
identifiers
.
has
(
displayName
)
)
{
continue
;
}
identifiers
.
add
(
displayName
)
;
previews
.
push
(
{
line
column
type
:
"
paused
"
name
:
displayName
value
:
displayValue
}
)
;
}
return
previews
;
}
async
function
getExpressionNameAndValue
(
name
value
ref
client
thread
)
{
let
displayName
=
name
;
let
displayValue
=
value
;
let
properties
=
null
;
if
(
value
.
actor
&
&
value
.
class
=
=
=
"
Object
"
)
{
properties
=
await
client
.
loadObjectProperties
(
{
name
path
:
name
contents
:
{
value
}
}
thread
)
;
}
let
{
meta
}
=
ref
;
while
(
meta
)
{
if
(
!
properties
)
{
displayName
+
=
.
{
meta
.
property
}
;
}
else
if
(
displayValue
=
=
=
value
)
{
const
property
=
properties
.
find
(
prop
=
>
prop
.
name
=
=
=
meta
.
property
)
;
displayValue
=
property
?
.
contents
.
value
;
displayName
+
=
.
{
meta
.
property
}
;
}
else
if
(
displayValue
?
.
preview
?
.
ownProperties
)
{
const
{
ownProperties
}
=
displayValue
.
preview
;
Object
.
keys
(
ownProperties
)
.
forEach
(
prop
=
>
{
if
(
prop
=
=
=
meta
.
property
)
{
displayValue
=
ownProperties
[
prop
]
.
value
;
displayName
+
=
.
{
meta
.
property
}
;
}
}
)
;
}
meta
=
meta
.
parent
;
}
return
{
displayName
displayValue
}
;
}
