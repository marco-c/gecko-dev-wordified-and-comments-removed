import
{
getAllTraces
getTraceFrames
getIsCurrentlyTracing
getCurrentThread
getSourceByActorId
getSourceActor
}
from
"
.
.
/
selectors
/
index
"
;
import
{
NO_SEARCH_VALUE
}
from
"
.
.
/
reducers
/
tracer
-
frames
"
;
import
{
createLocation
}
from
"
.
.
/
utils
/
location
"
;
import
{
getOriginalLocation
}
from
"
.
.
/
utils
/
source
-
maps
"
;
import
{
selectLocation
}
from
"
.
/
sources
/
select
.
js
"
;
const
{
TRACER_FIELDS_INDEXES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
.
js
"
)
;
export
function
tracingToggled
(
thread
enabled
traceValues
)
{
return
{
type
:
"
TRACING_TOGGLED
"
thread
enabled
traceValues
}
;
}
export
function
clearTracerData
(
)
{
return
{
type
:
"
TRACING_CLEAR
"
}
;
}
export
function
addTraces
(
traces
)
{
return
async
function
(
{
dispatch
getState
}
)
{
if
(
!
getIsCurrentlyTracing
(
getState
(
)
)
)
{
return
null
;
}
return
dispatch
(
{
type
:
"
ADD_TRACES
"
traces
}
)
;
}
;
}
export
function
selectTrace
(
traceIndex
)
{
return
async
function
(
thunkArgs
)
{
const
{
dispatch
getState
}
=
thunkArgs
;
const
traces
=
getAllTraces
(
getState
(
)
)
;
const
trace
=
traces
[
traceIndex
]
;
if
(
!
trace
)
{
return
;
}
let
location
=
null
;
if
(
trace
[
TRACER_FIELDS_INDEXES
.
TYPE
]
!
=
"
event
"
)
{
const
frameIndex
=
trace
[
TRACER_FIELDS_INDEXES
.
FRAME_INDEX
]
;
const
frames
=
getTraceFrames
(
getState
(
)
)
;
const
frame
=
frames
[
frameIndex
]
;
const
source
=
getSourceByActorId
(
getState
(
)
frame
.
sourceId
)
;
const
sourceActor
=
getSourceActor
(
getState
(
)
frame
.
sourceId
)
;
location
=
createLocation
(
{
source
sourceActor
line
:
frame
.
line
column
:
frame
.
column
}
)
;
location
=
await
getOriginalLocation
(
location
thunkArgs
)
;
}
const
thread
=
getCurrentThread
(
getState
(
)
)
;
dispatch
(
{
type
:
"
SELECT_TRACE
"
traceIndex
location
thread
}
)
;
if
(
location
)
{
await
dispatch
(
selectLocation
(
location
{
highlight
:
false
}
)
)
;
}
await
dispatch
(
updateSelectedLocationTraces
(
location
)
)
;
}
;
}
export
function
setLocalAndRemoteRuntimeVersion
(
localPlatformVersion
remotePlatformVersion
)
{
return
{
type
:
"
SET_RUNTIME_VERSIONS
"
localPlatformVersion
remotePlatformVersion
}
;
}
let
currentSearchSymbol
;
export
function
searchTraceArguments
(
searchString
)
{
return
async
function
(
{
dispatch
client
panel
}
)
{
searchString
=
searchString
.
trim
(
)
;
const
searchSymbol
=
Symbol
(
"
CURRENT_SEARCH_SYMBOL
"
)
;
currentSearchSymbol
=
searchSymbol
;
if
(
!
searchString
)
{
dispatch
(
{
type
:
"
SET_TRACE_SEARCH_STRING
"
searchValueOrGrip
:
NO_SEARCH_VALUE
}
)
;
return
;
}
if
(
searchString
=
=
=
"
undefined
"
)
{
dispatch
(
{
type
:
"
SET_TRACE_SEARCH_STRING
"
searchValueOrGrip
:
undefined
}
)
;
return
;
}
try
{
const
value
=
JSON
.
parse
(
searchString
)
;
if
(
typeof
value
=
=
"
object
"
&
&
value
!
=
=
null
)
{
dispatch
(
{
type
:
"
SET_TRACE_SEARCH_EXCEPTION
"
errorMessage
:
"
Invalid
search
.
Can
only
search
for
existing
page
JS
objects
"
}
)
;
return
;
}
dispatch
(
{
type
:
"
SET_TRACE_SEARCH_STRING
"
searchValueOrGrip
:
value
}
)
;
return
;
}
catch
(
e
)
{
}
const
inspector
=
panel
.
toolbox
.
getPanel
(
"
inspector
"
)
;
const
selectedNodeActor
=
inspector
?
.
selection
?
.
nodeFront
?
.
actorID
;
let
{
result
exception
}
=
await
client
.
evaluate
(
(
{
searchString
}
)
{
selectedNodeActor
evalInTracer
:
true
}
)
;
if
(
currentSearchSymbol
!
=
searchSymbol
)
{
return
;
}
if
(
result
.
type
=
=
"
null
"
)
{
result
=
null
;
}
else
if
(
result
.
type
=
=
"
undefined
"
)
{
result
=
undefined
;
}
if
(
exception
)
{
const
{
preview
}
=
exception
.
getGrip
(
)
;
const
errorMessage
=
{
preview
.
name
}
:
{
preview
.
message
}
;
dispatch
(
{
type
:
"
SET_TRACE_SEARCH_EXCEPTION
"
errorMessage
}
)
;
}
else
{
const
searchValueOrGrip
=
result
&
&
result
.
getGrip
?
result
.
getGrip
(
)
:
result
;
dispatch
(
{
type
:
"
SET_TRACE_SEARCH_STRING
"
searchValueOrGrip
}
)
;
}
}
;
}
export
function
updateSelectedLocationTraces
(
selectedLocation
)
{
return
async
function
(
{
getState
dispatch
}
)
{
if
(
!
selectedLocation
)
{
dispatch
(
{
type
:
"
SET_SELECTED_LOCACTION_TRACES
"
selectedLocationTraces
:
null
}
)
;
return
;
}
const
state
=
getState
(
)
;
let
location
=
selectedLocation
;
if
(
selectedLocation
.
source
.
isOriginal
)
{
location
=
state
.
sources
.
selectedGeneratedLocation
;
}
const
allTraces
=
getAllTraces
(
state
)
;
const
frames
=
getTraceFrames
(
state
)
;
const
selectedLocationTraces
=
allTraces
.
filter
(
trace
=
>
{
const
frameIndex
=
trace
[
TRACER_FIELDS_INDEXES
.
FRAME_INDEX
]
;
const
frame
=
frames
[
frameIndex
]
;
return
(
frame
&
&
frame
.
sourceId
=
=
location
.
sourceActor
.
id
&
&
frame
.
line
=
=
location
.
line
&
&
(
!
location
.
column
|
|
frame
.
column
=
=
location
.
column
)
)
;
}
)
;
dispatch
(
{
type
:
"
SET_SELECTED_LOCACTION_TRACES
"
selectedLocationTraces
:
!
selectedLocationTraces
.
length
?
null
:
selectedLocationTraces
}
)
;
}
;
}
