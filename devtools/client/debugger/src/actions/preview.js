import
{
isConsole
}
from
"
.
.
/
utils
/
preview
"
;
import
{
findBestMatchExpression
}
from
"
.
.
/
utils
/
ast
"
;
import
{
PROMISE
}
from
"
.
/
utils
/
middleware
/
promise
"
;
import
{
getExpressionFromCoords
}
from
"
.
.
/
utils
/
editor
/
get
-
expression
"
;
import
{
isOriginal
}
from
"
.
.
/
utils
/
source
"
;
import
{
getPreview
isLineInScope
isSelectedFrameVisible
getSelectedSource
getSelectedFrame
getSymbols
getCurrentThread
}
from
"
.
.
/
selectors
"
;
import
{
getMappedExpression
}
from
"
.
/
expressions
"
;
import
type
{
Action
ThunkArgs
}
from
"
.
/
types
"
;
import
type
{
Position
Context
}
from
"
.
.
/
types
"
;
import
type
{
AstLocation
}
from
"
.
.
/
workers
/
parser
"
;
function
findExpressionMatch
(
state
codeMirror
tokenPos
)
{
const
source
=
getSelectedSource
(
state
)
;
if
(
!
source
)
{
return
;
}
const
symbols
=
getSymbols
(
state
source
)
;
let
match
;
if
(
!
symbols
|
|
symbols
.
loading
)
{
match
=
getExpressionFromCoords
(
codeMirror
tokenPos
)
;
}
else
{
match
=
findBestMatchExpression
(
symbols
tokenPos
)
;
}
return
match
;
}
export
function
updatePreview
(
cx
:
Context
target
:
HTMLElement
tokenPos
:
Object
codeMirror
:
any
)
{
return
(
{
dispatch
getState
client
sourceMaps
}
:
ThunkArgs
)
=
>
{
const
cursorPos
=
target
.
getBoundingClientRect
(
)
;
if
(
!
isSelectedFrameVisible
(
getState
(
)
)
|
|
!
isLineInScope
(
getState
(
)
tokenPos
.
line
)
)
{
return
;
}
const
match
=
findExpressionMatch
(
getState
(
)
codeMirror
tokenPos
)
;
if
(
!
match
)
{
return
;
}
const
{
expression
location
}
=
match
;
if
(
isConsole
(
expression
)
)
{
return
;
}
dispatch
(
setPreview
(
cx
expression
location
tokenPos
cursorPos
target
)
)
;
}
;
}
export
function
setPreview
(
cx
:
Context
expression
:
string
location
:
AstLocation
tokenPos
:
Position
cursorPos
:
ClientRect
target
:
HTMLElement
)
{
return
async
(
{
dispatch
getState
client
sourceMaps
}
:
ThunkArgs
)
=
>
{
await
dispatch
(
{
type
:
"
SET_PREVIEW
"
cx
[
PROMISE
]
:
(
async
function
(
)
{
if
(
getPreview
(
getState
(
)
)
)
{
dispatch
(
clearPreview
(
cx
)
)
;
}
const
source
=
getSelectedSource
(
getState
(
)
)
;
if
(
!
source
)
{
return
;
}
const
thread
=
getCurrentThread
(
getState
(
)
)
;
const
selectedFrame
=
getSelectedFrame
(
getState
(
)
thread
)
;
if
(
location
&
&
isOriginal
(
source
)
)
{
const
mapResult
=
await
dispatch
(
getMappedExpression
(
expression
)
)
;
if
(
mapResult
)
{
expression
=
mapResult
.
expression
;
}
}
if
(
!
selectedFrame
)
{
return
;
}
const
{
result
}
=
await
client
.
evaluateInFrame
(
expression
{
frameId
:
selectedFrame
.
id
thread
}
)
;
if
(
result
=
=
=
null
)
{
return
;
}
if
(
result
.
class
&
&
result
.
class
.
includes
(
"
InvisibleToDebugger
"
)
)
{
return
;
}
const
root
=
{
name
:
expression
path
:
expression
contents
:
{
value
:
result
}
}
;
const
properties
=
await
client
.
loadObjectProperties
(
root
)
;
if
(
!
target
.
matches
(
"
:
hover
"
)
)
{
return
;
}
return
{
expression
result
properties
root
location
tokenPos
cursorPos
target
}
;
}
)
(
)
}
)
;
}
;
}
export
function
clearPreview
(
cx
:
Context
)
{
return
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
const
currentSelection
=
getPreview
(
getState
(
)
)
;
if
(
!
currentSelection
)
{
return
;
}
return
dispatch
(
(
{
type
:
"
CLEAR_SELECTION
"
cx
}
:
Action
)
)
;
}
;
}
