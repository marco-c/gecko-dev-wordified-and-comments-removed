import
{
PROMISE
}
from
"
.
.
/
utils
/
middleware
/
promise
"
;
import
{
getSource
getSourceFromId
getSourceWithContent
getSourceContent
getGeneratedSource
getSourcesEpoch
getBreakpointsForSource
getSourceActorsForSource
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
addBreakpoint
}
from
"
.
.
/
breakpoints
"
;
import
{
prettyPrintSource
}
from
"
.
/
prettyPrint
"
;
import
{
setBreakableLines
}
from
"
.
/
breakableLines
"
;
import
{
isFulfilled
}
from
"
.
.
/
.
.
/
utils
/
async
-
value
"
;
import
{
isOriginal
isPretty
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
memoizeableAction
type
MemoizedAction
}
from
"
.
.
/
.
.
/
utils
/
memoizableAction
"
;
import
{
Telemetry
}
from
"
devtools
-
modules
"
;
import
type
{
ThunkArgs
}
from
"
.
.
/
types
"
;
import
type
{
Source
Context
}
from
"
.
.
/
.
.
/
types
"
;
const
loadSourceHistogram
=
"
DEVTOOLS_DEBUGGER_LOAD_SOURCE_MS
"
;
const
telemetry
=
new
Telemetry
(
)
;
async
function
loadSource
(
state
source
:
Source
{
sourceMaps
client
getState
}
)
:
Promise
<
?
{
text
:
string
contentType
:
string
}
>
{
if
(
isPretty
(
source
)
&
&
isOriginal
(
source
)
)
{
const
generatedSource
=
getGeneratedSource
(
state
source
)
;
if
(
!
generatedSource
)
{
throw
new
Error
(
"
Unable
to
find
minified
original
.
"
)
;
}
const
content
=
getSourceContent
(
state
generatedSource
.
id
)
;
if
(
!
content
|
|
!
isFulfilled
(
content
)
)
{
throw
new
Error
(
"
Cannot
pretty
-
print
a
file
that
has
not
loaded
"
)
;
}
return
prettyPrintSource
(
sourceMaps
generatedSource
content
.
value
getSourceActorsForSource
(
state
generatedSource
.
id
)
)
;
}
if
(
isOriginal
(
source
)
)
{
const
result
=
await
sourceMaps
.
getOriginalSourceText
(
source
)
;
if
(
!
result
)
{
throw
new
Error
(
"
Original
source
text
unavailable
"
)
;
}
return
result
;
}
const
actors
=
getSourceActorsForSource
(
state
source
.
id
)
;
if
(
!
actors
.
length
)
{
throw
new
Error
(
"
No
source
actor
for
loadSource
"
)
;
}
telemetry
.
start
(
loadSourceHistogram
source
)
;
const
response
=
await
client
.
sourceContents
(
actors
[
0
]
)
;
telemetry
.
finish
(
loadSourceHistogram
source
)
;
return
{
text
:
response
.
source
contentType
:
response
.
contentType
|
|
"
text
/
javascript
"
}
;
}
async
function
loadSourceTextPromise
(
cx
:
Context
source
:
Source
{
dispatch
getState
client
sourceMaps
parser
}
:
ThunkArgs
)
:
Promise
<
?
Source
>
{
const
epoch
=
getSourcesEpoch
(
getState
(
)
)
;
await
dispatch
(
{
type
:
"
LOAD_SOURCE_TEXT
"
sourceId
:
source
.
id
epoch
[
PROMISE
]
:
loadSource
(
getState
(
)
source
{
sourceMaps
client
getState
}
)
}
)
;
const
newSource
=
getSource
(
getState
(
)
source
.
id
)
;
if
(
!
newSource
)
{
return
;
}
const
content
=
getSourceContent
(
getState
(
)
newSource
.
id
)
;
if
(
!
newSource
.
isWasm
&
&
content
)
{
parser
.
setSource
(
newSource
.
id
isFulfilled
(
content
)
?
content
.
value
:
{
type
:
"
text
"
value
:
"
"
contentType
:
undefined
}
)
;
await
dispatch
(
setBreakableLines
(
cx
source
.
id
)
)
;
const
breakpoints
=
getBreakpointsForSource
(
getState
(
)
source
.
id
)
;
for
(
const
{
location
options
disabled
}
of
breakpoints
)
{
await
dispatch
(
addBreakpoint
(
cx
location
options
disabled
)
)
;
}
}
return
newSource
;
}
export
function
loadSourceById
(
cx
:
Context
sourceId
:
string
)
{
return
(
{
getState
dispatch
}
:
ThunkArgs
)
=
>
{
const
source
=
getSourceFromId
(
getState
(
)
sourceId
)
;
return
dispatch
(
loadSourceText
(
{
cx
source
}
)
)
;
}
;
}
export
const
loadSourceText
:
MemoizedAction
<
{
cx
:
Context
source
:
Source
}
?
Source
>
=
memoizeableAction
(
"
loadSourceText
"
{
hasValue
:
(
{
source
}
{
getState
}
)
=
>
{
return
(
!
source
|
|
!
!
(
getSource
(
getState
(
)
source
.
id
)
&
&
getSourceWithContent
(
getState
(
)
source
.
id
)
.
content
)
)
;
}
getValue
:
(
{
source
}
{
getState
}
)
=
>
source
?
getSource
(
getState
(
)
source
.
id
)
:
null
createKey
:
(
{
source
}
{
getState
}
)
=
>
{
const
epoch
=
getSourcesEpoch
(
getState
(
)
)
;
return
{
epoch
}
:
{
source
.
id
}
;
}
action
:
(
{
cx
source
}
thunkArgs
)
=
>
loadSourceTextPromise
(
cx
source
thunkArgs
)
}
)
;
