import
{
PROMISE
}
from
"
.
.
/
utils
/
middleware
/
promise
"
;
import
{
getSource
getSourceTextContent
getSettledSourceTextContent
getGeneratedSource
getSourcesEpoch
getBreakpointsForSource
getSourceActorsForSource
getFirstSourceActorForGeneratedSource
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
addBreakpoint
}
from
"
.
.
/
breakpoints
"
;
import
{
prettyPrintSource
}
from
"
.
/
prettyPrint
"
;
import
{
isFulfilled
fulfilled
}
from
"
.
.
/
.
.
/
utils
/
async
-
value
"
;
import
{
isPretty
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
createLocation
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
memoizeableAction
}
from
"
.
.
/
.
.
/
utils
/
memoizableAction
"
;
async
function
loadGeneratedSource
(
state
sourceActor
client
)
{
if
(
!
sourceActor
)
{
throw
new
Error
(
"
Source
actor
is
null
or
not
defined
"
)
;
}
let
response
;
try
{
response
=
await
client
.
sourceContents
(
sourceActor
)
;
}
catch
(
e
)
{
throw
new
Error
(
sourceContents
failed
:
{
e
}
)
;
}
return
{
text
:
response
.
source
contentType
:
response
.
contentType
|
|
"
text
/
javascript
"
}
;
}
async
function
loadOriginalSource
(
state
source
client
sourceMapLoader
prettyPrintWorker
)
{
if
(
isPretty
(
source
)
)
{
const
generatedSource
=
getGeneratedSource
(
state
source
)
;
if
(
!
generatedSource
)
{
throw
new
Error
(
"
Unable
to
find
minified
original
.
"
)
;
}
const
content
=
getSettledSourceTextContent
(
state
createLocation
(
{
sourceId
:
generatedSource
.
id
}
)
)
;
return
prettyPrintSource
(
sourceMapLoader
prettyPrintWorker
generatedSource
content
getSourceActorsForSource
(
state
generatedSource
.
id
)
)
;
}
const
result
=
await
sourceMapLoader
.
getOriginalSourceText
(
source
.
id
)
;
if
(
!
result
)
{
throw
new
Error
(
"
Original
source
text
unavailable
"
)
;
}
return
result
;
}
async
function
loadGeneratedSourceTextPromise
(
cx
sourceActor
{
dispatch
getState
client
parserWorker
}
)
{
const
epoch
=
getSourcesEpoch
(
getState
(
)
)
;
await
dispatch
(
{
type
:
"
LOAD_GENERATED_SOURCE_TEXT
"
sourceActorId
:
sourceActor
.
actor
epoch
[
PROMISE
]
:
loadGeneratedSource
(
getState
(
)
sourceActor
client
)
}
)
;
await
setParserAndBreakpointsTextContent
(
cx
sourceActor
.
source
sourceActor
.
actor
{
state
:
getState
(
)
parserWorker
dispatch
}
)
;
}
async
function
loadOriginalSourceTextPromise
(
cx
source
{
dispatch
getState
client
sourceMapLoader
parserWorker
prettyPrintWorker
}
)
{
const
epoch
=
getSourcesEpoch
(
getState
(
)
)
;
await
dispatch
(
{
type
:
"
LOAD_ORIGINAL_SOURCE_TEXT
"
sourceId
:
source
.
id
epoch
[
PROMISE
]
:
loadOriginalSource
(
getState
(
)
source
client
sourceMapLoader
prettyPrintWorker
)
}
)
;
await
setParserAndBreakpointsTextContent
(
cx
source
.
id
null
{
state
:
getState
(
)
parserWorker
dispatch
}
)
;
}
async
function
setParserAndBreakpointsTextContent
(
cx
sourceId
sourceActorId
{
dispatch
state
parserWorker
}
)
{
const
source
=
getSource
(
state
sourceId
)
;
if
(
!
source
)
{
return
;
}
const
content
=
getSettledSourceTextContent
(
state
createLocation
(
{
sourceId
:
source
.
id
sourceActorId
}
)
)
;
if
(
!
source
.
isWasm
&
&
content
)
{
parserWorker
.
setSource
(
source
.
id
isFulfilled
(
content
)
?
content
.
value
:
{
type
:
"
text
"
value
:
"
"
contentType
:
undefined
}
)
;
const
breakpoints
=
getBreakpointsForSource
(
state
source
.
id
)
;
for
(
const
{
location
options
disabled
}
of
breakpoints
)
{
await
dispatch
(
addBreakpoint
(
cx
location
options
disabled
)
)
;
}
}
}
export
const
loadGeneratedSourceText
=
memoizeableAction
(
"
loadGeneratedSourceText
"
{
getValue
:
(
{
sourceActor
}
{
getState
}
)
=
>
{
if
(
!
sourceActor
)
{
return
null
;
}
const
sourceTextContent
=
getSourceTextContent
(
getState
(
)
createLocation
(
{
sourceId
:
sourceActor
.
source
sourceActorId
:
sourceActor
.
actor
}
)
)
;
if
(
!
sourceTextContent
|
|
sourceTextContent
.
state
=
=
=
"
pending
"
)
{
return
sourceTextContent
;
}
return
fulfilled
(
sourceTextContent
)
;
}
createKey
:
(
{
sourceActor
}
{
getState
}
)
=
>
{
const
epoch
=
getSourcesEpoch
(
getState
(
)
)
;
return
{
epoch
}
:
{
sourceActor
.
actor
}
;
}
action
:
(
{
cx
sourceActor
}
thunkArgs
)
=
>
loadGeneratedSourceTextPromise
(
cx
sourceActor
thunkArgs
)
}
)
;
export
const
loadOriginalSourceText
=
memoizeableAction
(
"
loadOriginalSourceText
"
{
getValue
:
(
{
source
}
{
getState
}
)
=
>
{
if
(
!
source
)
{
return
null
;
}
const
sourceTextContent
=
getSourceTextContent
(
getState
(
)
createLocation
(
{
sourceId
:
source
.
id
}
)
)
;
if
(
!
sourceTextContent
|
|
sourceTextContent
.
state
=
=
=
"
pending
"
)
{
return
sourceTextContent
;
}
return
fulfilled
(
sourceTextContent
)
;
}
createKey
:
(
{
source
}
{
getState
}
)
=
>
{
const
epoch
=
getSourcesEpoch
(
getState
(
)
)
;
return
{
epoch
}
:
{
source
.
id
}
;
}
action
:
(
{
cx
source
}
thunkArgs
)
=
>
loadOriginalSourceTextPromise
(
cx
source
thunkArgs
)
}
)
;
export
function
loadSourceText
(
cx
source
sourceActor
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
if
(
!
source
)
{
return
null
;
}
if
(
source
.
isOriginal
)
{
return
dispatch
(
loadOriginalSourceText
(
{
cx
source
}
)
)
;
}
if
(
!
sourceActor
)
{
sourceActor
=
getFirstSourceActorForGeneratedSource
(
getState
(
)
source
.
id
source
.
thread
)
;
}
return
dispatch
(
loadGeneratedSourceText
(
{
cx
sourceActor
}
)
)
;
}
;
}
