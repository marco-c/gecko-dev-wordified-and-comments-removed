import
{
insertSourceActors
}
from
"
.
.
/
.
.
/
actions
/
source
-
actors
"
;
import
{
makeSourceId
createGeneratedSource
createSourceMapOriginalSource
createSourceActor
}
from
"
.
.
/
.
.
/
client
/
firefox
/
create
"
;
import
{
toggleBlackBox
}
from
"
.
/
blackbox
"
;
import
{
syncBreakpoint
}
from
"
.
.
/
breakpoints
"
;
import
{
loadSourceText
}
from
"
.
/
loadSourceText
"
;
import
{
togglePrettyPrint
}
from
"
.
/
prettyPrint
"
;
import
{
selectLocation
setBreakableLines
}
from
"
.
.
/
sources
"
;
import
{
getRawSourceURL
isPrettyURL
isInlineScript
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
getBlackBoxRanges
getSource
getSourceFromId
hasSourceActor
getSourceByActorId
getPendingSelectedLocation
getPendingBreakpointsForSource
getContext
isSourceLoadingOrLoaded
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
prefs
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
sourceQueue
from
"
.
.
/
.
.
/
utils
/
source
-
queue
"
;
import
{
validateNavigateContext
ContextError
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
function
loadSourceMaps
(
cx
sources
)
{
return
async
function
(
{
dispatch
sourceMaps
}
)
{
try
{
const
sourceList
=
await
Promise
.
all
(
sources
.
map
(
async
sourceActor
=
>
{
const
originalSources
=
await
dispatch
(
loadSourceMap
(
cx
sourceActor
)
)
;
sourceQueue
.
queueOriginalSources
(
originalSources
)
;
return
originalSources
;
}
)
)
;
await
sourceQueue
.
flush
(
)
;
return
sourceList
.
flat
(
)
;
}
catch
(
error
)
{
if
(
!
(
error
instanceof
ContextError
)
)
{
throw
error
;
}
}
}
;
}
function
loadSourceMap
(
cx
sourceActor
)
{
return
async
function
(
{
dispatch
getState
sourceMaps
}
)
{
if
(
!
prefs
.
clientSourceMapsEnabled
|
|
!
sourceActor
.
sourceMapURL
)
{
return
[
]
;
}
let
data
=
null
;
try
{
const
source
=
getSourceByActorId
(
getState
(
)
sourceActor
.
id
)
;
if
(
source
)
{
data
=
await
sourceMaps
.
getOriginalURLs
(
{
id
:
source
.
id
url
:
sourceActor
.
url
|
|
"
"
sourceMapBaseURL
:
sourceActor
.
sourceMapBaseURL
|
|
"
"
sourceMapURL
:
sourceActor
.
sourceMapURL
|
|
"
"
isWasm
:
sourceActor
.
introductionType
=
=
=
"
wasm
"
}
)
;
}
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
if
(
!
data
)
{
dispatch
(
{
type
:
"
CLEAR_SOURCE_ACTOR_MAP_URL
"
cx
id
:
sourceActor
.
id
}
)
;
return
[
]
;
}
validateNavigateContext
(
getState
(
)
cx
)
;
return
data
;
}
;
}
function
checkSelectedSource
(
cx
sourceId
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
state
=
getState
(
)
;
const
pendingLocation
=
getPendingSelectedLocation
(
state
)
;
if
(
!
pendingLocation
|
|
!
pendingLocation
.
url
)
{
return
;
}
const
source
=
getSource
(
state
sourceId
)
;
if
(
!
source
|
|
!
source
.
url
)
{
return
;
}
const
pendingUrl
=
pendingLocation
.
url
;
const
rawPendingUrl
=
getRawSourceURL
(
pendingUrl
)
;
if
(
rawPendingUrl
=
=
=
source
.
url
)
{
if
(
isPrettyURL
(
pendingUrl
)
)
{
const
prettySource
=
await
dispatch
(
togglePrettyPrint
(
cx
source
.
id
)
)
;
return
dispatch
(
checkPendingBreakpoints
(
cx
prettySource
.
id
)
)
;
}
await
dispatch
(
selectLocation
(
cx
{
sourceId
:
source
.
id
line
:
typeof
pendingLocation
.
line
=
=
=
"
number
"
?
pendingLocation
.
line
:
0
column
:
pendingLocation
.
column
}
)
)
;
}
}
;
}
function
checkPendingBreakpoints
(
cx
sourceId
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
source
=
getSource
(
getState
(
)
sourceId
)
;
if
(
!
source
)
{
return
;
}
const
pendingBreakpoints
=
getPendingBreakpointsForSource
(
getState
(
)
source
)
;
if
(
pendingBreakpoints
.
length
=
=
=
0
)
{
return
;
}
await
dispatch
(
loadSourceText
(
{
cx
source
}
)
)
;
await
dispatch
(
setBreakableLines
(
cx
source
.
id
)
)
;
await
Promise
.
all
(
pendingBreakpoints
.
map
(
bp
=
>
{
return
dispatch
(
syncBreakpoint
(
cx
sourceId
bp
)
)
;
}
)
)
;
}
;
}
function
restoreBlackBoxedSources
(
cx
sources
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
currentRanges
=
getBlackBoxRanges
(
getState
(
)
)
;
if
(
Object
.
keys
(
currentRanges
)
.
length
=
=
0
)
{
return
;
}
for
(
const
source
of
sources
)
{
const
ranges
=
currentRanges
[
source
.
url
]
;
if
(
ranges
)
{
await
dispatch
(
toggleBlackBox
(
cx
source
true
ranges
)
)
;
}
}
}
;
}
export
function
newOriginalSource
(
sourceInfo
)
{
return
async
(
{
dispatch
}
)
=
>
{
const
sources
=
await
dispatch
(
newOriginalSources
(
[
sourceInfo
]
)
)
;
return
sources
[
0
]
;
}
;
}
export
function
newOriginalSources
(
sourceInfo
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
state
=
getState
(
)
;
const
seen
=
new
Set
(
)
;
const
sources
=
[
]
;
for
(
const
{
id
url
}
of
sourceInfo
)
{
if
(
seen
.
has
(
id
)
|
|
getSource
(
state
id
)
)
{
continue
;
}
seen
.
add
(
id
)
;
sources
.
push
(
createSourceMapOriginalSource
(
id
url
)
)
;
}
const
cx
=
getContext
(
state
)
;
dispatch
(
addSources
(
cx
sources
)
)
;
await
dispatch
(
checkNewSources
(
cx
sources
)
)
;
for
(
const
source
of
sources
)
{
dispatch
(
checkPendingBreakpoints
(
cx
source
.
id
)
)
;
}
return
sources
;
}
;
}
export
function
newGeneratedSource
(
sourceInfo
)
{
return
async
(
{
dispatch
}
)
=
>
{
const
sources
=
await
dispatch
(
newGeneratedSources
(
[
sourceInfo
]
)
)
;
return
sources
[
0
]
;
}
;
}
export
function
newGeneratedSources
(
sourceResources
)
{
return
async
(
{
dispatch
getState
client
}
)
=
>
{
if
(
sourceResources
.
length
=
=
0
)
{
return
[
]
;
}
const
resultIds
=
[
]
;
const
newSourcesObj
=
{
}
;
const
newSourceActors
=
[
]
;
for
(
const
sourceResource
of
sourceResources
)
{
if
(
sourceResource
.
targetFront
.
isDestroyed
(
)
)
{
continue
;
}
const
id
=
makeSourceId
(
sourceResource
)
;
if
(
!
getSource
(
getState
(
)
id
)
&
&
!
newSourcesObj
[
id
]
)
{
newSourcesObj
[
id
]
=
createGeneratedSource
(
sourceResource
)
;
}
const
actorId
=
sourceResource
.
actor
;
if
(
!
hasSourceActor
(
getState
(
)
actorId
)
)
{
newSourceActors
.
push
(
createSourceActor
(
sourceResource
)
)
;
}
resultIds
.
push
(
id
)
;
}
const
newSources
=
Object
.
values
(
newSourcesObj
)
;
const
cx
=
getContext
(
getState
(
)
)
;
dispatch
(
addSources
(
cx
newSources
)
)
;
dispatch
(
insertSourceActors
(
newSourceActors
)
)
;
for
(
const
newSourceActor
of
newSourceActors
)
{
if
(
isInlineScript
(
newSourceActor
)
&
&
isSourceLoadingOrLoaded
(
getState
(
)
newSourceActor
.
source
)
)
{
dispatch
(
setBreakableLines
(
cx
newSourceActor
.
source
)
)
.
catch
(
error
=
>
{
if
(
!
(
error
instanceof
ContextError
)
)
{
throw
error
;
}
}
)
;
}
}
await
dispatch
(
checkNewSources
(
cx
newSources
)
)
;
(
async
(
)
=
>
{
await
dispatch
(
loadSourceMaps
(
cx
newSourceActors
)
)
;
for
(
const
{
source
}
of
newSourceActors
)
{
dispatch
(
checkPendingBreakpoints
(
cx
source
)
)
;
}
}
)
(
)
;
return
resultIds
.
map
(
id
=
>
getSourceFromId
(
getState
(
)
id
)
)
;
}
;
}
function
addSources
(
cx
sources
)
{
return
(
{
dispatch
getState
}
)
=
>
{
dispatch
(
{
type
:
"
ADD_SOURCES
"
cx
sources
}
)
;
}
;
}
function
checkNewSources
(
cx
sources
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
for
(
const
source
of
sources
)
{
dispatch
(
checkSelectedSource
(
cx
source
.
id
)
)
;
}
await
dispatch
(
restoreBlackBoxedSources
(
cx
sources
)
)
;
return
sources
;
}
;
}
