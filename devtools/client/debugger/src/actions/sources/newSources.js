import
{
insertSourceActors
}
from
"
.
.
/
.
.
/
actions
/
source
-
actors
"
;
import
{
makeSourceId
createGeneratedSource
createSourceMapOriginalSource
createSourceActor
}
from
"
.
.
/
.
.
/
client
/
firefox
/
create
"
;
import
{
toggleBlackBox
}
from
"
.
/
blackbox
"
;
import
{
syncPendingBreakpoint
}
from
"
.
.
/
breakpoints
/
index
"
;
import
{
loadSourceText
}
from
"
.
/
loadSourceText
"
;
import
{
prettyPrintAndSelectSource
}
from
"
.
/
prettyPrint
"
;
import
{
toggleSourceMapIgnoreList
}
from
"
.
.
/
ui
"
;
import
{
selectLocation
setBreakableLines
}
from
"
.
.
/
sources
/
index
"
;
import
{
getRawSourceURL
isPrettyURL
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
createLocation
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
getBlackBoxRanges
getSource
getSourceFromId
hasSourceActor
getSourceByActorId
getPendingSelectedLocation
getPendingBreakpointsForSource
getSelectedLocation
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
import
{
prefs
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
sourceQueue
from
"
.
.
/
.
.
/
utils
/
source
-
queue
"
;
import
{
validateSourceActor
ContextError
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
function
loadSourceMapsForSourceActors
(
sourceActors
)
{
return
async
function
(
{
dispatch
}
)
{
try
{
await
Promise
.
all
(
sourceActors
.
map
(
sourceActor
=
>
dispatch
(
loadSourceMap
(
sourceActor
)
)
)
)
;
}
catch
(
error
)
{
if
(
!
(
error
instanceof
ContextError
)
)
{
throw
error
;
}
}
await
sourceQueue
.
flush
(
)
;
}
;
}
function
loadSourceMap
(
sourceActor
)
{
return
async
function
(
{
dispatch
getState
sourceMapLoader
panel
}
)
{
if
(
!
prefs
.
clientSourceMapsEnabled
|
|
!
sourceActor
.
sourceMapURL
)
{
return
;
}
let
sources
ignoreListUrls
resolvedSourceMapURL
exception
;
try
{
const
source
=
getSourceByActorId
(
getState
(
)
sourceActor
.
id
)
;
if
(
source
)
{
(
{
sources
ignoreListUrls
resolvedSourceMapURL
exception
}
=
await
sourceMapLoader
.
loadSourceMap
(
{
id
:
source
.
id
url
:
sourceActor
.
url
|
|
"
"
sourceMapBaseURL
:
sourceActor
.
sourceMapBaseURL
|
|
"
"
sourceMapURL
:
sourceActor
.
sourceMapURL
|
|
"
"
isWasm
:
sourceActor
.
introductionType
=
=
=
"
wasm
"
}
)
)
;
}
}
catch
(
e
)
{
exception
=
Internal
error
:
{
e
.
message
}
;
}
if
(
resolvedSourceMapURL
)
{
dispatch
(
{
type
:
"
RESOLVED_SOURCEMAP_URL
"
sourceActor
resolvedSourceMapURL
}
)
;
}
if
(
ignoreListUrls
?
.
length
)
{
dispatch
(
{
type
:
"
ADD_SOURCEMAP_IGNORE_LIST_SOURCES
"
ignoreListUrls
}
)
;
}
if
(
exception
)
{
const
message
=
L10N
.
getFormatStr
(
"
toolbox
.
sourceMapFailure
"
exception
sourceActor
.
url
sourceActor
.
sourceMapURL
)
;
panel
.
toolbox
.
commands
.
targetCommand
.
targetFront
.
logWarningInPage
(
message
"
source
map
"
resolvedSourceMapURL
)
;
dispatch
(
{
type
:
"
SOURCE_MAP_ERROR
"
sourceActor
errorMessage
:
exception
}
)
;
dispatch
(
{
type
:
"
CLEAR_SOURCE_ACTOR_MAP_URL
"
sourceActor
}
)
;
return
;
}
validateSourceActor
(
getState
(
)
sourceActor
)
;
for
(
const
originalSource
of
sources
)
{
originalSource
.
sourceActor
=
sourceActor
;
}
sourceQueue
.
queueOriginalSources
(
sources
)
;
}
;
}
function
checkSelectedSource
(
sourceId
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
state
=
getState
(
)
;
const
pendingLocation
=
getPendingSelectedLocation
(
state
)
;
if
(
!
pendingLocation
|
|
!
pendingLocation
.
url
)
{
return
;
}
const
source
=
getSource
(
state
sourceId
)
;
if
(
!
source
|
|
!
source
.
url
)
{
return
;
}
const
pendingUrl
=
pendingLocation
.
url
;
const
rawPendingUrl
=
getRawSourceURL
(
pendingUrl
)
;
if
(
rawPendingUrl
=
=
=
source
.
url
)
{
if
(
isPrettyURL
(
pendingUrl
)
)
{
const
prettySource
=
await
dispatch
(
prettyPrintAndSelectSource
(
source
)
)
;
dispatch
(
checkPendingBreakpoints
(
prettySource
null
)
)
;
return
;
}
await
dispatch
(
selectLocation
(
createLocation
(
{
source
line
:
typeof
pendingLocation
.
line
=
=
=
"
number
"
?
pendingLocation
.
line
:
0
column
:
pendingLocation
.
column
}
)
)
)
;
}
}
;
}
function
checkPendingBreakpoints
(
source
sourceActor
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
pendingBreakpoints
=
getPendingBreakpointsForSource
(
getState
(
)
source
)
;
if
(
pendingBreakpoints
.
length
=
=
=
0
)
{
return
;
}
await
dispatch
(
loadSourceText
(
source
sourceActor
)
)
;
await
dispatch
(
setBreakableLines
(
createLocation
(
{
source
sourceActor
}
)
)
)
;
await
Promise
.
all
(
pendingBreakpoints
.
map
(
pendingBp
=
>
{
return
dispatch
(
syncPendingBreakpoint
(
source
pendingBp
)
)
;
}
)
)
;
}
;
}
function
restoreBlackBoxedSources
(
sources
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
currentRanges
=
getBlackBoxRanges
(
getState
(
)
)
;
if
(
!
Object
.
keys
(
currentRanges
)
.
length
)
{
return
;
}
for
(
const
source
of
sources
)
{
const
ranges
=
currentRanges
[
source
.
url
]
;
if
(
ranges
)
{
await
dispatch
(
toggleBlackBox
(
source
true
ranges
)
)
;
}
}
if
(
prefs
.
sourceMapIgnoreListEnabled
)
{
await
dispatch
(
toggleSourceMapIgnoreList
(
true
)
)
;
}
}
;
}
export
function
newOriginalSources
(
originalSourcesInfo
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
state
=
getState
(
)
;
const
seen
=
new
Set
(
)
;
const
actors
=
[
]
;
const
actorsSources
=
{
}
;
for
(
const
{
id
url
sourceActor
}
of
originalSourcesInfo
)
{
if
(
seen
.
has
(
id
)
|
|
getSource
(
state
id
)
)
{
continue
;
}
seen
.
add
(
id
)
;
if
(
!
actorsSources
[
sourceActor
.
actor
]
)
{
actors
.
push
(
sourceActor
)
;
actorsSources
[
sourceActor
.
actor
]
=
[
]
;
}
actorsSources
[
sourceActor
.
actor
]
.
push
(
createSourceMapOriginalSource
(
id
url
sourceActor
.
sourceObject
)
)
;
}
actors
.
forEach
(
sourceActor
=
>
{
dispatch
(
{
type
:
"
ADD_ORIGINAL_SOURCES
"
originalSources
:
actorsSources
[
sourceActor
.
actor
]
generatedSourceActor
:
sourceActor
}
)
;
}
)
;
const
actorsSourcesValues
=
Object
.
values
(
actorsSources
)
;
let
sources
=
[
]
;
if
(
actorsSourcesValues
.
length
)
{
sources
=
actorsSourcesValues
.
reduce
(
(
acc
sourceList
)
=
>
acc
.
concat
(
sourceList
)
)
;
}
await
dispatch
(
checkNewSources
(
sources
)
)
;
for
(
const
source
of
sources
)
{
dispatch
(
checkPendingBreakpoints
(
source
null
)
)
;
}
return
sources
;
}
;
}
export
function
newGeneratedSource
(
sourceInfo
)
{
return
async
(
{
dispatch
}
)
=
>
{
const
sources
=
await
dispatch
(
newGeneratedSources
(
[
sourceInfo
]
)
)
;
return
sources
[
0
]
;
}
;
}
export
function
newGeneratedSources
(
sourceResources
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
if
(
!
sourceResources
.
length
)
{
return
[
]
;
}
const
resultIds
=
[
]
;
const
newSourcesObj
=
{
}
;
const
newSourceActors
=
[
]
;
for
(
const
sourceResource
of
sourceResources
)
{
if
(
sourceResource
.
targetFront
.
isDestroyed
(
)
)
{
continue
;
}
const
id
=
makeSourceId
(
sourceResource
)
;
if
(
!
getSource
(
getState
(
)
id
)
&
&
!
newSourcesObj
[
id
]
)
{
newSourcesObj
[
id
]
=
createGeneratedSource
(
sourceResource
)
;
}
const
actorId
=
sourceResource
.
actor
;
if
(
!
hasSourceActor
(
getState
(
)
actorId
)
)
{
newSourceActors
.
push
(
createSourceActor
(
sourceResource
getSource
(
getState
(
)
id
)
|
|
newSourcesObj
[
id
]
)
)
;
}
resultIds
.
push
(
id
)
;
}
const
newSources
=
Object
.
values
(
newSourcesObj
)
;
dispatch
(
{
type
:
"
ADD_SOURCES
"
sources
:
newSources
}
)
;
dispatch
(
insertSourceActors
(
newSourceActors
)
)
;
await
dispatch
(
checkNewSources
(
newSources
)
)
;
(
async
(
)
=
>
{
await
dispatch
(
loadSourceMapsForSourceActors
(
newSourceActors
)
)
;
const
selectedLocation
=
getSelectedLocation
(
getState
(
)
)
;
for
(
const
sourceActor
of
newSourceActors
)
{
if
(
selectedLocation
?
.
source
=
=
sourceActor
.
sourceObject
&
&
sourceActor
.
sourceObject
.
isHTML
)
{
await
dispatch
(
setBreakableLines
(
createLocation
(
{
source
:
sourceActor
.
sourceObject
sourceActor
}
)
)
)
;
}
}
for
(
const
sourceActor
of
newSourceActors
)
{
dispatch
(
checkPendingBreakpoints
(
sourceActor
.
sourceObject
sourceActor
)
)
;
}
}
)
(
)
;
return
resultIds
.
map
(
id
=
>
getSourceFromId
(
getState
(
)
id
)
)
;
}
;
}
function
checkNewSources
(
sources
)
{
return
async
(
{
dispatch
}
)
=
>
{
await
Promise
.
all
(
sources
.
map
(
async
source
=
>
await
dispatch
(
checkSelectedSource
(
source
.
id
)
)
)
)
;
await
dispatch
(
restoreBlackBoxedSources
(
sources
)
)
;
return
sources
;
}
;
}
