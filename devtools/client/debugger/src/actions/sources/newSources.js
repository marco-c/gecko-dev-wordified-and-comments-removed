import
{
flatten
}
from
"
lodash
"
;
import
{
stringToSourceActorId
type
SourceActor
}
from
"
.
.
/
.
.
/
reducers
/
source
-
actors
"
;
import
{
insertSourceActors
}
from
"
.
.
/
.
.
/
actions
/
source
-
actors
"
;
import
{
makeSourceId
}
from
"
.
.
/
.
.
/
client
/
firefox
/
create
"
;
import
{
toggleBlackBox
}
from
"
.
/
blackbox
"
;
import
{
syncBreakpoint
}
from
"
.
.
/
breakpoints
"
;
import
{
loadSourceText
}
from
"
.
/
loadSourceText
"
;
import
{
togglePrettyPrint
}
from
"
.
/
prettyPrint
"
;
import
{
selectLocation
setBreakableLines
}
from
"
.
.
/
sources
"
;
import
{
getRawSourceURL
isPrettyURL
isOriginal
isUrlExtension
isInlineScript
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
getBlackBoxList
getSource
getSourceFromId
hasSourceActor
getPendingSelectedLocation
getPendingBreakpointsForSource
getContext
isSourceLoadingOrLoaded
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
prefs
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
sourceQueue
from
"
.
.
/
.
.
/
utils
/
source
-
queue
"
;
import
{
validateNavigateContext
ContextError
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
import
type
{
Source
SourceId
Context
OriginalSourceData
GeneratedSourceData
QueuedSourceData
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
Action
ThunkArgs
}
from
"
.
.
/
types
"
;
function
loadSourceMaps
(
cx
:
Context
sources
:
Source
[
]
)
{
return
async
function
(
{
dispatch
sourceMaps
}
:
ThunkArgs
)
:
Promise
<
?
(
Promise
<
Source
>
[
]
)
>
{
try
{
const
sourceList
=
await
Promise
.
all
(
sources
.
map
(
async
(
{
id
}
)
=
>
{
const
originalSources
=
await
dispatch
(
loadSourceMap
(
cx
id
)
)
;
sourceQueue
.
queueSources
(
originalSources
.
map
(
data
=
>
(
{
type
:
"
original
"
data
}
)
)
)
;
return
originalSources
;
}
)
)
;
await
sourceQueue
.
flush
(
)
;
for
(
const
source
of
sources
)
{
dispatch
(
checkPendingBreakpoints
(
cx
source
.
id
)
)
;
}
return
flatten
(
sourceList
)
;
}
catch
(
error
)
{
if
(
!
(
error
instanceof
ContextError
)
)
{
throw
error
;
}
}
}
;
}
function
loadSourceMap
(
cx
:
Context
sourceId
:
SourceId
)
{
return
async
function
(
{
dispatch
getState
sourceMaps
}
:
ThunkArgs
)
:
Promise
<
OriginalSourceData
[
]
>
{
const
source
=
getSource
(
getState
(
)
sourceId
)
;
if
(
!
prefs
.
clientSourceMapsEnabled
|
|
!
source
|
|
isOriginal
(
source
)
|
|
!
source
.
sourceMapURL
)
{
return
[
]
;
}
let
data
=
null
;
try
{
const
urlInfo
:
Source
=
{
.
.
.
(
source
:
any
)
}
;
if
(
!
urlInfo
.
url
&
&
typeof
urlInfo
.
introductionUrl
=
=
=
"
string
"
)
{
(
urlInfo
:
any
)
.
url
=
urlInfo
.
introductionUrl
;
}
data
=
await
sourceMaps
.
getOriginalURLs
(
urlInfo
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
if
(
!
data
)
{
dispatch
(
(
{
type
:
"
CLEAR_SOURCE_MAP_URL
"
cx
sourceId
}
:
Action
)
)
;
return
[
]
;
}
validateNavigateContext
(
getState
(
)
cx
)
;
return
data
;
}
;
}
function
checkSelectedSource
(
cx
:
Context
sourceId
:
string
)
{
return
async
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
source
=
getSource
(
getState
(
)
sourceId
)
;
const
pendingLocation
=
getPendingSelectedLocation
(
getState
(
)
)
;
if
(
!
pendingLocation
|
|
!
pendingLocation
.
url
|
|
!
source
|
|
!
source
.
url
)
{
return
;
}
const
pendingUrl
=
pendingLocation
.
url
;
const
rawPendingUrl
=
getRawSourceURL
(
pendingUrl
)
;
if
(
rawPendingUrl
=
=
=
source
.
url
)
{
if
(
isPrettyURL
(
pendingUrl
)
)
{
const
prettySource
=
await
dispatch
(
togglePrettyPrint
(
cx
source
.
id
)
)
;
return
dispatch
(
checkPendingBreakpoints
(
cx
prettySource
.
id
)
)
;
}
await
dispatch
(
selectLocation
(
cx
{
sourceId
:
source
.
id
line
:
typeof
pendingLocation
.
line
=
=
=
"
number
"
?
pendingLocation
.
line
:
0
column
:
pendingLocation
.
column
}
)
)
;
}
}
;
}
function
checkPendingBreakpoints
(
cx
:
Context
sourceId
:
string
)
{
return
async
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
source
=
getSource
(
getState
(
)
sourceId
)
;
if
(
!
source
)
{
return
;
}
const
pendingBreakpoints
=
getPendingBreakpointsForSource
(
getState
(
)
source
)
;
if
(
pendingBreakpoints
.
length
=
=
=
0
)
{
return
;
}
await
dispatch
(
loadSourceText
(
{
cx
source
}
)
)
;
await
Promise
.
all
(
pendingBreakpoints
.
map
(
bp
=
>
{
return
dispatch
(
syncBreakpoint
(
cx
sourceId
bp
)
)
;
}
)
)
;
}
;
}
function
restoreBlackBoxedSources
(
cx
:
Context
sources
:
Source
[
]
)
{
return
async
(
{
dispatch
}
:
ThunkArgs
)
=
>
{
const
tabs
=
getBlackBoxList
(
)
;
if
(
tabs
.
length
=
=
0
)
{
return
;
}
for
(
const
source
of
sources
)
{
if
(
tabs
.
includes
(
source
.
url
)
&
&
!
source
.
isBlackBoxed
)
{
dispatch
(
toggleBlackBox
(
cx
source
)
)
;
}
}
}
;
}
export
function
newQueuedSources
(
sourceInfo
:
Array
<
QueuedSourceData
>
)
{
return
async
(
{
dispatch
}
:
ThunkArgs
)
=
>
{
const
generated
=
[
]
;
const
original
=
[
]
;
for
(
const
source
of
sourceInfo
)
{
if
(
source
.
type
=
=
=
"
generated
"
)
{
generated
.
push
(
source
.
data
)
;
}
else
{
original
.
push
(
source
.
data
)
;
}
}
if
(
generated
.
length
>
0
)
{
await
dispatch
(
newGeneratedSources
(
generated
)
)
;
}
if
(
original
.
length
>
0
)
{
await
dispatch
(
newOriginalSources
(
original
)
)
;
}
}
;
}
export
function
newOriginalSource
(
sourceInfo
:
OriginalSourceData
)
{
return
async
(
{
dispatch
}
:
ThunkArgs
)
=
>
{
const
sources
=
await
dispatch
(
newOriginalSources
(
[
sourceInfo
]
)
)
;
return
sources
[
0
]
;
}
;
}
export
function
newOriginalSources
(
sourceInfo
:
Array
<
OriginalSourceData
>
)
{
return
async
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
sources
:
Array
<
Source
>
=
sourceInfo
.
map
(
(
{
id
url
}
)
=
>
(
{
id
url
relativeUrl
:
url
isPrettyPrinted
:
false
isWasm
:
false
isBlackBoxed
:
false
introductionUrl
:
null
introductionType
:
undefined
isExtension
:
false
extensionName
:
null
}
)
)
;
const
cx
=
getContext
(
getState
(
)
)
;
dispatch
(
addSources
(
cx
sources
)
)
;
await
dispatch
(
checkNewSources
(
cx
sources
)
)
;
return
sources
;
}
;
}
export
function
newGeneratedSource
(
sourceInfo
:
GeneratedSourceData
)
{
return
async
(
{
dispatch
}
:
ThunkArgs
)
=
>
{
const
sources
=
await
dispatch
(
newGeneratedSources
(
[
sourceInfo
]
)
)
;
return
sources
[
0
]
;
}
;
}
export
function
newGeneratedSources
(
sourceInfo
:
Array
<
GeneratedSourceData
>
)
{
return
async
(
{
dispatch
getState
client
}
:
ThunkArgs
)
:
Promise
<
Array
<
Source
>
>
=
>
{
const
supportsWasm
=
client
.
hasWasmSupport
(
)
;
const
resultIds
=
[
]
;
const
newSourcesObj
=
{
}
;
const
newSourceActors
:
Array
<
SourceActor
>
=
[
]
;
for
(
const
{
thread
source
id
}
of
sourceInfo
)
{
const
newId
=
id
|
|
makeSourceId
(
source
)
;
if
(
!
getSource
(
getState
(
)
newId
)
&
&
!
newSourcesObj
[
newId
]
)
{
newSourcesObj
[
newId
]
=
(
{
id
:
newId
url
:
source
.
url
relativeUrl
:
source
.
url
isPrettyPrinted
:
false
extensionName
:
source
.
extensionName
sourceMapURL
:
source
.
sourceMapURL
introductionUrl
:
source
.
introductionUrl
introductionType
:
source
.
introductionType
isBlackBoxed
:
false
isWasm
:
!
!
supportsWasm
&
&
source
.
introductionType
=
=
=
"
wasm
"
isExtension
:
(
source
.
url
&
&
isUrlExtension
(
source
.
url
)
)
|
|
false
}
:
any
)
;
}
const
actorId
=
stringToSourceActorId
(
source
.
actor
)
;
if
(
!
hasSourceActor
(
getState
(
)
actorId
)
)
{
newSourceActors
.
push
(
{
id
:
actorId
actor
:
source
.
actor
thread
source
:
newId
isBlackBoxed
:
source
.
isBlackBoxed
sourceMapURL
:
source
.
sourceMapURL
url
:
source
.
url
introductionUrl
:
source
.
introductionUrl
introductionType
:
source
.
introductionType
}
)
;
}
resultIds
.
push
(
newId
)
;
}
const
newSources
:
Array
<
Source
>
=
(
Object
.
values
(
newSourcesObj
)
:
any
[
]
)
;
const
cx
=
getContext
(
getState
(
)
)
;
dispatch
(
addSources
(
cx
newSources
)
)
;
dispatch
(
insertSourceActors
(
newSourceActors
)
)
;
for
(
const
newSourceActor
of
newSourceActors
)
{
if
(
isInlineScript
(
newSourceActor
)
&
&
isSourceLoadingOrLoaded
(
getState
(
)
newSourceActor
.
source
)
)
{
dispatch
(
setBreakableLines
(
cx
newSourceActor
.
source
)
)
.
catch
(
error
=
>
{
if
(
!
(
error
instanceof
ContextError
)
)
{
throw
error
;
}
}
)
;
}
}
await
dispatch
(
checkNewSources
(
cx
newSources
)
)
;
return
resultIds
.
map
(
id
=
>
getSourceFromId
(
getState
(
)
id
)
)
;
}
;
}
function
addSources
(
cx
sources
:
Array
<
Source
>
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
dispatch
(
{
type
:
"
ADD_SOURCES
"
cx
sources
}
)
;
}
;
}
function
checkNewSources
(
cx
sources
:
Source
[
]
)
{
return
async
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
for
(
const
source
of
sources
)
{
dispatch
(
checkSelectedSource
(
cx
source
.
id
)
)
;
}
dispatch
(
restoreBlackBoxedSources
(
cx
sources
)
)
;
dispatch
(
loadSourceMaps
(
cx
sources
)
)
;
return
sources
;
}
;
}
