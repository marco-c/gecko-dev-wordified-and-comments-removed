import
{
isOriginalId
originalToGeneratedId
}
from
"
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
{
toggleBreakpoints
}
from
"
.
.
/
breakpoints
"
;
import
{
getSourceActorsForSource
isSourceBlackBoxed
getBlackBoxRanges
getBreakpointsForSource
}
from
"
.
.
/
.
.
/
selectors
"
;
export
async
function
blackboxSourceActorsForSource
(
thunkArgs
source
shouldBlackBox
ranges
=
[
]
)
{
const
{
getState
client
sourceMapLoader
}
=
thunkArgs
;
let
sourceId
=
source
.
id
;
if
(
isOriginalId
(
source
.
id
)
)
{
sourceId
=
originalToGeneratedId
(
source
.
id
)
;
const
range
=
await
sourceMapLoader
.
getFileGeneratedRange
(
source
.
id
)
;
ranges
=
[
]
;
if
(
range
)
{
ranges
.
push
(
range
)
;
console
.
warn
(
"
The
might
be
unxpected
issues
when
ignoring
lines
in
an
original
file
.
"
+
"
The
whole
original
source
is
being
blackboxed
.
"
)
;
}
else
{
throw
new
Error
(
Unable
to
retrieve
generated
ranges
for
original
source
{
source
.
url
}
)
;
}
}
for
(
const
actor
of
getSourceActorsForSource
(
getState
(
)
sourceId
)
)
{
await
client
.
blackBox
(
actor
shouldBlackBox
ranges
)
;
}
}
export
function
toggleBlackBox
(
cx
source
shouldBlackBox
ranges
=
[
]
)
{
return
async
thunkArgs
=
>
{
const
{
dispatch
getState
}
=
thunkArgs
;
shouldBlackBox
=
typeof
shouldBlackBox
=
=
"
boolean
"
?
shouldBlackBox
:
!
isSourceBlackBoxed
(
getState
(
)
source
)
;
await
blackboxSourceActorsForSource
(
thunkArgs
source
shouldBlackBox
ranges
)
;
if
(
shouldBlackBox
)
{
recordEvent
(
"
blackbox
"
)
;
if
(
!
ranges
.
length
)
{
dispatch
(
{
type
:
"
BLACKBOX_WHOLE_SOURCES
"
sources
:
[
source
]
}
)
;
await
toggleBreakpointsInBlackboxedSources
(
{
thunkArgs
cx
shouldDisable
:
true
sources
:
[
source
]
}
)
;
}
else
{
const
currentRanges
=
getBlackBoxRanges
(
getState
(
)
)
[
source
.
url
]
|
|
[
]
;
ranges
=
ranges
.
filter
(
newRange
=
>
{
const
duplicate
=
currentRanges
.
findIndex
(
r
=
>
r
.
start
.
line
=
=
newRange
.
start
.
line
&
&
r
.
end
.
line
=
=
newRange
.
end
.
line
)
;
return
duplicate
=
=
-
1
;
}
)
;
dispatch
(
{
type
:
"
BLACKBOX_SOURCE_RANGES
"
source
ranges
}
)
;
await
toggleBreakpointsInRangesForBlackboxedSource
(
{
thunkArgs
cx
shouldDisable
:
true
source
ranges
}
)
;
}
}
else
{
if
(
!
ranges
.
length
)
{
dispatch
(
{
type
:
"
UNBLACKBOX_WHOLE_SOURCES
"
sources
:
[
source
]
}
)
;
toggleBreakpointsInBlackboxedSources
(
{
thunkArgs
cx
shouldDisable
:
false
sources
:
[
source
]
}
)
;
}
else
{
dispatch
(
{
type
:
"
UNBLACKBOX_SOURCE_RANGES
"
source
ranges
}
)
;
const
blackboxRanges
=
getBlackBoxRanges
(
getState
(
)
)
;
if
(
!
blackboxRanges
[
source
.
url
]
.
length
)
{
dispatch
(
{
type
:
"
UNBLACKBOX_WHOLE_SOURCES
"
sources
:
[
source
]
}
)
;
}
await
toggleBreakpointsInRangesForBlackboxedSource
(
{
thunkArgs
cx
shouldDisable
:
false
source
ranges
}
)
;
}
}
}
;
}
async
function
toggleBreakpointsInRangesForBlackboxedSource
(
{
thunkArgs
cx
shouldDisable
source
ranges
}
)
{
const
{
dispatch
getState
}
=
thunkArgs
;
for
(
const
range
of
ranges
)
{
const
breakpoints
=
getBreakpointsForSource
(
getState
(
)
source
.
id
range
)
;
await
dispatch
(
toggleBreakpoints
(
cx
shouldDisable
breakpoints
)
)
;
}
}
async
function
toggleBreakpointsInBlackboxedSources
(
{
thunkArgs
cx
shouldDisable
sources
}
)
{
const
{
dispatch
getState
}
=
thunkArgs
;
for
(
const
source
of
sources
)
{
const
breakpoints
=
getBreakpointsForSource
(
getState
(
)
source
.
id
)
;
await
dispatch
(
toggleBreakpoints
(
cx
shouldDisable
breakpoints
)
)
;
}
}
export
function
blackBoxSources
(
cx
sourcesToBlackBox
shouldBlackBox
)
{
return
async
thunkArgs
=
>
{
const
{
dispatch
getState
}
=
thunkArgs
;
const
sources
=
sourcesToBlackBox
.
filter
(
source
=
>
isSourceBlackBoxed
(
getState
(
)
source
)
!
=
=
shouldBlackBox
)
;
if
(
!
sources
.
length
)
{
return
;
}
for
(
const
source
of
sources
)
{
await
blackboxSourceActorsForSource
(
thunkArgs
source
shouldBlackBox
)
;
}
if
(
shouldBlackBox
)
{
recordEvent
(
"
blackbox
"
)
;
}
dispatch
(
{
type
:
shouldBlackBox
?
"
BLACKBOX_WHOLE_SOURCES
"
:
"
UNBLACKBOX_WHOLE_SOURCES
"
sources
}
)
;
await
toggleBreakpointsInBlackboxedSources
(
{
thunkArgs
cx
shouldDisable
:
shouldBlackBox
sources
}
)
;
}
;
}
