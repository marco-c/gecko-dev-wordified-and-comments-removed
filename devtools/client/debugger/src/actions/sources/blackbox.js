import
{
isOriginalId
originalToGeneratedId
}
from
"
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
{
getSourceActorsForSource
isSourceBlackBoxed
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
PROMISE
}
from
"
.
.
/
utils
/
middleware
/
promise
"
;
async
function
blackboxSourceActors
(
thunkArgs
sources
shouldBlackBox
ranges
)
{
const
{
getState
client
sourceMapLoader
}
=
thunkArgs
;
const
blackboxSources
=
await
Promise
.
all
(
sources
.
map
(
async
source
=
>
{
let
sourceId
=
source
.
id
;
if
(
isOriginalId
(
source
.
id
)
)
{
sourceId
=
originalToGeneratedId
(
source
.
id
)
;
const
range
=
await
sourceMapLoader
.
getFileGeneratedRange
(
source
.
id
)
;
ranges
=
[
]
;
if
(
range
)
{
ranges
.
push
(
range
)
;
console
.
warn
(
"
The
might
be
unxpected
issues
when
ignoring
lines
in
an
original
file
.
"
+
"
The
whole
original
source
is
being
blackboxed
.
"
)
;
}
}
for
(
const
actor
of
getSourceActorsForSource
(
getState
(
)
sourceId
)
)
{
await
client
.
blackBox
(
actor
shouldBlackBox
ranges
)
;
}
return
{
source
shouldBlackBox
ranges
}
;
}
)
)
;
if
(
shouldBlackBox
)
{
recordEvent
(
"
blackbox
"
)
;
}
return
{
blackboxSources
}
;
}
export
function
toggleBlackBox
(
cx
source
shouldBlackBox
ranges
)
{
return
async
thunkArgs
=
>
{
const
{
dispatch
getState
}
=
thunkArgs
;
shouldBlackBox
=
typeof
shouldBlackBox
=
=
"
boolean
"
?
shouldBlackBox
:
!
isSourceBlackBoxed
(
getState
(
)
source
)
;
return
dispatch
(
{
type
:
"
BLACKBOX
"
cx
[
PROMISE
]
:
blackboxSourceActors
(
thunkArgs
[
source
]
shouldBlackBox
ranges
?
ranges
:
[
]
)
}
)
;
}
;
}
export
function
blackBoxSources
(
cx
sourcesToBlackBox
shouldBlackBox
)
{
return
async
thunkArgs
=
>
{
const
{
dispatch
getState
}
=
thunkArgs
;
const
sources
=
sourcesToBlackBox
.
filter
(
source
=
>
isSourceBlackBoxed
(
getState
(
)
source
)
!
=
=
shouldBlackBox
)
;
return
dispatch
(
{
type
:
"
BLACKBOX
"
cx
[
PROMISE
]
:
blackboxSourceActors
(
thunkArgs
sources
shouldBlackBox
[
]
)
}
)
;
}
;
}
