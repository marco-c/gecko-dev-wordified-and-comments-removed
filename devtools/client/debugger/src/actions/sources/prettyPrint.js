import
{
generatedToOriginalId
}
from
"
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
"
;
import
assert
from
"
.
.
/
.
.
/
utils
/
assert
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
{
updateBreakpointsForNewPrettyPrintedSource
}
from
"
.
.
/
breakpoints
/
index
"
;
import
{
getPrettySourceURL
isJavaScript
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
isFulfilled
fulfilled
}
from
"
.
.
/
.
.
/
utils
/
async
-
value
"
;
import
{
getOriginalLocation
}
from
"
.
.
/
.
.
/
utils
/
source
-
maps
"
;
import
{
prefs
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
{
loadGeneratedSourceText
loadOriginalSourceText
}
from
"
.
/
loadSourceText
"
;
import
{
mapFrames
}
from
"
.
.
/
pause
/
index
"
;
import
{
selectSpecificLocation
}
from
"
.
.
/
sources
/
index
"
;
import
{
createPrettyPrintOriginalSource
}
from
"
.
.
/
.
.
/
client
/
firefox
/
create
"
;
import
{
getFirstSourceActorForGeneratedSource
getSourceFromId
getSelectedLocation
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
import
{
selectSource
}
from
"
.
/
select
"
;
import
{
memoizeableAction
}
from
"
.
.
/
.
.
/
utils
/
memoizableAction
"
;
import
DevToolsUtils
from
"
devtools
/
shared
/
DevToolsUtils
"
;
const
LINE_BREAK_REGEX
=
/
\
r
\
n
?
|
\
n
|
\
u2028
|
\
u2029
/
g
;
function
matchAllLineBreaks
(
str
)
{
return
Array
.
from
(
str
.
matchAll
(
LINE_BREAK_REGEX
)
)
;
}
function
getPrettyOriginalSourceURL
(
generatedSource
)
{
return
getPrettySourceURL
(
generatedSource
.
url
|
|
generatedSource
.
id
)
;
}
export
async
function
prettyPrintSourceTextContent
(
sourceMapLoader
prettyPrintWorker
generatedSource
content
actors
)
{
if
(
!
content
|
|
!
isFulfilled
(
content
)
)
{
throw
new
Error
(
"
Cannot
pretty
-
print
a
file
that
has
not
loaded
"
)
;
}
const
contentValue
=
content
.
value
;
if
(
(
!
isJavaScript
(
generatedSource
contentValue
)
&
&
!
generatedSource
.
isHTML
)
|
|
contentValue
.
type
!
=
=
"
text
"
)
{
throw
new
Error
(
Can
'
t
prettify
{
contentValue
.
contentType
}
files
only
HTML
and
Javascript
.
)
;
}
const
url
=
getPrettyOriginalSourceURL
(
generatedSource
)
;
let
prettyPrintWorkerResult
;
if
(
generatedSource
.
isHTML
)
{
prettyPrintWorkerResult
=
await
prettyPrintHtmlFile
(
{
prettyPrintWorker
generatedSource
content
actors
}
)
;
}
else
{
prettyPrintWorkerResult
=
await
prettyPrintWorker
.
prettyPrint
(
{
sourceText
:
contentValue
.
value
indent
:
"
"
.
repeat
(
prefs
.
indentSize
)
url
}
)
;
}
const
generatedSourceIds
=
[
generatedSource
.
id
.
.
.
actors
.
map
(
item
=
>
item
.
actor
)
]
;
await
sourceMapLoader
.
setSourceMapForGeneratedSources
(
generatedSourceIds
prettyPrintWorkerResult
.
sourceMap
)
;
return
{
text
:
prettyPrintWorkerResult
.
code
contentType
:
contentValue
.
contentType
}
;
}
async
function
prettyPrintHtmlFile
(
{
prettyPrintWorker
generatedSource
content
actors
}
)
{
const
url
=
getPrettyOriginalSourceURL
(
generatedSource
)
;
const
contentValue
=
content
.
value
;
const
htmlFileText
=
contentValue
.
value
;
const
prettyPrintWorkerResult
=
{
code
:
htmlFileText
}
;
const
allLineBreaks
=
matchAllLineBreaks
(
htmlFileText
)
;
let
lineCountDelta
=
0
;
actors
.
sort
(
(
a
b
)
=
>
{
if
(
a
.
sourceStartLine
=
=
=
b
.
sourceStartLine
)
{
return
a
.
sourceStartColumn
>
b
.
sourceStartColumn
;
}
return
a
.
sourceStartLine
>
b
.
sourceStartLine
;
}
)
;
const
prettyPrintTaskId
=
generatedSource
.
id
;
const
replacements
=
[
]
;
const
seenLocations
=
new
Set
(
)
;
for
(
const
sourceInfo
of
actors
)
{
const
location
=
{
sourceInfo
.
sourceStartLine
}
:
{
sourceInfo
.
sourceStartColumn
}
;
if
(
!
sourceInfo
.
sourceLength
|
|
seenLocations
.
has
(
location
)
)
{
continue
;
}
seenLocations
.
add
(
location
)
;
const
indexAfterPreviousLineBreakInHtml
=
sourceInfo
.
sourceStartLine
>
1
?
allLineBreaks
[
sourceInfo
.
sourceStartLine
-
2
]
.
index
+
1
:
0
;
const
startIndex
=
indexAfterPreviousLineBreakInHtml
+
sourceInfo
.
sourceStartColumn
;
const
endIndex
=
startIndex
+
sourceInfo
.
sourceLength
;
const
scriptText
=
htmlFileText
.
substring
(
startIndex
endIndex
)
;
DevToolsUtils
.
assert
(
scriptText
.
length
=
=
sourceInfo
.
sourceLength
"
script
text
has
expected
length
"
)
;
const
prettyText
=
await
prettyPrintWorker
.
prettyPrintInlineScript
(
{
taskId
:
prettyPrintTaskId
sourceText
:
scriptText
indent
:
"
"
.
repeat
(
prefs
.
indentSize
)
url
originalStartLine
:
sourceInfo
.
sourceStartLine
originalStartColumn
:
sourceInfo
.
sourceStartColumn
generatedStartLine
:
sourceInfo
.
sourceStartLine
+
lineCountDelta
generatedStartColumn
:
sourceInfo
.
sourceStartColumn
lineCountDelta
}
)
;
lineCountDelta
+
=
matchAllLineBreaks
(
prettyText
)
.
length
-
matchAllLineBreaks
(
scriptText
)
.
length
;
replacements
.
push
(
{
startIndex
endIndex
prettyText
}
)
;
}
prettyPrintWorkerResult
.
sourceMap
=
await
prettyPrintWorker
.
getSourceMap
(
prettyPrintTaskId
)
;
replacements
.
sort
(
(
a
b
)
=
>
a
.
startIndex
<
b
.
startIndex
)
;
for
(
const
{
startIndex
endIndex
prettyText
}
of
replacements
)
{
prettyPrintWorkerResult
.
code
=
prettyPrintWorkerResult
.
code
.
substring
(
0
startIndex
)
+
prettyText
+
prettyPrintWorkerResult
.
code
.
substring
(
endIndex
)
;
}
return
prettyPrintWorkerResult
;
}
function
createPrettySource
(
source
sourceActor
)
{
return
async
(
{
dispatch
sourceMapLoader
getState
}
)
=
>
{
const
url
=
getPrettyOriginalSourceURL
(
source
)
;
const
id
=
generatedToOriginalId
(
source
.
id
url
)
;
const
prettySource
=
createPrettyPrintOriginalSource
(
id
url
)
;
dispatch
(
{
type
:
"
ADD_ORIGINAL_SOURCES
"
originalSources
:
[
prettySource
]
generatedSourceActor
:
sourceActor
}
)
;
return
prettySource
;
}
;
}
function
selectPrettyLocation
(
prettySource
)
{
return
async
thunkArgs
=
>
{
const
{
dispatch
getState
}
=
thunkArgs
;
let
location
=
getSelectedLocation
(
getState
(
)
)
;
if
(
location
&
&
location
.
line
>
=
1
&
&
getPrettySourceURL
(
location
.
source
.
url
)
=
=
prettySource
.
url
)
{
location
=
await
getOriginalLocation
(
location
thunkArgs
)
;
if
(
location
.
source
=
=
prettySource
)
{
return
dispatch
(
selectSpecificLocation
(
location
)
)
;
}
}
return
dispatch
(
selectSource
(
prettySource
)
)
;
}
;
}
export
async
function
prettyPrintSource
(
source
thunkArgs
)
{
const
{
dispatch
getState
}
=
thunkArgs
;
recordEvent
(
"
pretty_print
"
)
;
assert
(
!
source
.
isOriginal
"
Pretty
-
printing
only
allowed
on
generated
sources
"
)
;
const
sourceActor
=
getFirstSourceActorForGeneratedSource
(
getState
(
)
source
.
id
)
;
await
dispatch
(
loadGeneratedSourceText
(
sourceActor
)
)
;
const
newPrettySource
=
await
dispatch
(
createPrettySource
(
source
sourceActor
)
)
;
await
dispatch
(
loadOriginalSourceText
(
newPrettySource
)
)
;
await
dispatch
(
mapFrames
(
sourceActor
.
thread
)
)
;
await
dispatch
(
updateBreakpointsForNewPrettyPrintedSource
(
source
)
)
;
newPrettySource
.
_loaded
=
true
;
return
newPrettySource
;
}
const
memoizedPrettyPrintSource
=
memoizeableAction
(
"
setSymbols
"
{
getValue
:
(
source
{
getState
}
)
=
>
{
const
url
=
getPrettyOriginalSourceURL
(
source
)
;
const
id
=
generatedToOriginalId
(
source
.
id
url
)
;
const
s
=
getSourceFromId
(
getState
(
)
id
)
;
if
(
!
s
|
|
!
s
.
_loaded
)
{
return
undefined
;
}
return
fulfilled
(
s
)
;
}
createKey
:
source
=
>
source
.
id
action
:
(
source
thunkArgs
)
=
>
prettyPrintSource
(
source
thunkArgs
)
}
)
;
export
function
prettyPrintAndSelectSource
(
source
)
{
return
async
(
{
dispatch
sourceMapLoader
getState
}
)
=
>
{
const
prettySource
=
await
dispatch
(
memoizedPrettyPrintSource
(
source
)
)
;
await
dispatch
(
selectPrettyLocation
(
prettySource
)
)
;
return
prettySource
;
}
;
}
