import
{
makeBreakpointLocation
makeBreakpointId
getASTLocation
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
{
getBreakpoint
getBreakpointPositionsForLocation
getFirstBreakpointPosition
getSymbols
getSource
getSourceContent
getBreakpointsList
getPendingBreakpointList
isMapScopesEnabled
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
setBreakpointPositions
}
from
"
.
/
breakpointPositions
"
;
import
{
setSkipPausing
}
from
"
.
.
/
pause
/
skipPausing
"
;
import
{
PROMISE
}
from
"
.
.
/
utils
/
middleware
/
promise
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
{
comparePosition
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
getTextAtPosition
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
getMappedScopesForLocation
}
from
"
.
.
/
pause
/
mapScopes
"
;
import
{
validateNavigateContext
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
async
function
clientSetBreakpoint
(
client
cx
{
getState
dispatch
}
breakpoint
)
{
const
breakpointLocation
=
makeBreakpointLocation
(
getState
(
)
breakpoint
.
generatedLocation
)
;
const
shouldMapBreakpointExpressions
=
isMapScopesEnabled
(
getState
(
)
)
&
&
getSource
(
getState
(
)
breakpoint
.
location
?
.
sourceId
)
.
isOriginal
&
&
(
breakpoint
.
options
.
logValue
|
|
breakpoint
.
options
.
condition
)
;
if
(
shouldMapBreakpointExpressions
)
{
breakpoint
=
await
dispatch
(
updateBreakpointSourceMapping
(
cx
breakpoint
)
)
;
}
return
client
.
setBreakpoint
(
breakpointLocation
breakpoint
.
options
)
;
}
function
clientRemoveBreakpoint
(
client
state
generatedLocation
)
{
const
breakpointLocation
=
makeBreakpointLocation
(
state
generatedLocation
)
;
return
client
.
removeBreakpoint
(
breakpointLocation
)
;
}
export
function
enableBreakpoint
(
cx
initialBreakpoint
)
{
return
thunkArgs
=
>
{
const
{
dispatch
getState
client
}
=
thunkArgs
;
const
breakpoint
=
getBreakpoint
(
getState
(
)
initialBreakpoint
.
location
)
;
if
(
!
breakpoint
|
|
!
breakpoint
.
disabled
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
:
{
.
.
.
breakpoint
disabled
:
false
}
[
PROMISE
]
:
clientSetBreakpoint
(
client
cx
thunkArgs
breakpoint
)
}
)
;
}
;
}
export
function
addBreakpoint
(
cx
initialLocation
options
=
{
}
disabled
=
false
shouldCancel
=
(
)
=
>
false
)
{
return
async
thunkArgs
=
>
{
const
{
dispatch
getState
client
}
=
thunkArgs
;
recordEvent
(
"
add_breakpoint
"
)
;
const
{
sourceId
column
line
}
=
initialLocation
;
await
dispatch
(
setBreakpointPositions
(
{
cx
sourceId
line
}
)
)
;
const
position
=
column
?
getBreakpointPositionsForLocation
(
getState
(
)
initialLocation
)
:
getFirstBreakpointPosition
(
getState
(
)
initialLocation
)
;
if
(
!
position
)
{
return
;
}
const
{
location
generatedLocation
}
=
position
;
const
source
=
getSource
(
getState
(
)
location
.
sourceId
)
;
const
generatedSource
=
getSource
(
getState
(
)
generatedLocation
.
sourceId
)
;
if
(
!
source
|
|
!
generatedSource
)
{
return
;
}
const
symbols
=
getSymbols
(
getState
(
)
source
)
;
const
astLocation
=
getASTLocation
(
source
symbols
location
)
;
const
originalContent
=
getSourceContent
(
getState
(
)
source
.
id
)
;
const
originalText
=
getTextAtPosition
(
source
.
id
originalContent
location
)
;
const
content
=
getSourceContent
(
getState
(
)
generatedSource
.
id
)
;
const
text
=
getTextAtPosition
(
generatedSource
.
id
content
generatedLocation
)
;
const
id
=
makeBreakpointId
(
location
)
;
const
breakpoint
=
{
id
thread
:
generatedSource
.
thread
disabled
options
location
astLocation
generatedLocation
text
originalText
}
;
if
(
shouldCancel
(
)
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
[
PROMISE
]
:
disabled
?
clientRemoveBreakpoint
(
client
getState
(
)
generatedLocation
)
:
clientSetBreakpoint
(
client
cx
thunkArgs
breakpoint
)
}
)
;
}
;
}
export
function
removeBreakpoint
(
cx
initialBreakpoint
)
{
return
(
{
dispatch
getState
client
}
)
=
>
{
recordEvent
(
"
remove_breakpoint
"
)
;
const
breakpoint
=
getBreakpoint
(
getState
(
)
initialBreakpoint
.
location
)
;
if
(
!
breakpoint
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
REMOVE_BREAKPOINT
"
cx
breakpoint
[
PROMISE
]
:
breakpoint
.
disabled
?
Promise
.
resolve
(
)
:
clientRemoveBreakpoint
(
client
getState
(
)
breakpoint
.
generatedLocation
)
}
)
;
}
;
}
export
function
removeBreakpointAtGeneratedLocation
(
cx
target
)
{
return
(
{
dispatch
getState
client
}
)
=
>
{
const
onBreakpointRemoved
=
clientRemoveBreakpoint
(
client
getState
(
)
target
)
;
const
breakpoints
=
getBreakpointsList
(
getState
(
)
)
;
for
(
const
breakpoint
of
breakpoints
)
{
const
{
generatedLocation
}
=
breakpoint
;
if
(
generatedLocation
.
sourceId
=
=
target
.
sourceId
&
&
comparePosition
(
generatedLocation
target
)
)
{
dispatch
(
{
type
:
"
REMOVE_BREAKPOINT
"
cx
breakpoint
[
PROMISE
]
:
onBreakpointRemoved
}
)
;
}
}
const
pending
=
getPendingBreakpointList
(
getState
(
)
)
;
for
(
const
breakpoint
of
pending
)
{
const
{
generatedLocation
}
=
breakpoint
;
if
(
generatedLocation
.
sourceUrl
=
=
target
.
sourceUrl
&
&
comparePosition
(
generatedLocation
target
)
)
{
dispatch
(
{
type
:
"
REMOVE_PENDING_BREAKPOINT
"
cx
breakpoint
}
)
;
}
}
return
onBreakpointRemoved
;
}
;
}
export
function
disableBreakpoint
(
cx
initialBreakpoint
)
{
return
(
{
dispatch
getState
client
}
)
=
>
{
const
breakpoint
=
getBreakpoint
(
getState
(
)
initialBreakpoint
.
location
)
;
if
(
!
breakpoint
|
|
breakpoint
.
disabled
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
:
{
.
.
.
breakpoint
disabled
:
true
}
[
PROMISE
]
:
clientRemoveBreakpoint
(
client
getState
(
)
breakpoint
.
generatedLocation
)
}
)
;
}
;
}
export
function
setBreakpointOptions
(
cx
location
options
=
{
}
)
{
return
thunkArgs
=
>
{
const
{
dispatch
getState
client
}
=
thunkArgs
;
let
breakpoint
=
getBreakpoint
(
getState
(
)
location
)
;
if
(
!
breakpoint
)
{
return
dispatch
(
addBreakpoint
(
cx
location
options
)
)
;
}
breakpoint
=
{
.
.
.
breakpoint
disabled
:
false
options
}
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
[
PROMISE
]
:
clientSetBreakpoint
(
client
cx
thunkArgs
breakpoint
)
}
)
;
}
;
}
async
function
updateExpression
(
evaluationsParser
mappings
originalExpression
)
{
const
mapped
=
await
evaluationsParser
.
mapExpression
(
originalExpression
mappings
[
]
false
false
)
;
if
(
!
mapped
)
{
return
originalExpression
;
}
if
(
!
originalExpression
.
trimEnd
(
)
.
endsWith
(
"
;
"
)
)
{
return
mapped
.
expression
.
replace
(
/
;
/
"
"
)
;
}
return
mapped
.
expression
;
}
function
updateBreakpointSourceMapping
(
cx
breakpoint
)
{
return
async
(
{
getState
dispatch
evaluationsParser
}
)
=
>
{
const
options
=
{
.
.
.
breakpoint
.
options
}
;
const
mappedScopes
=
await
dispatch
(
getMappedScopesForLocation
(
breakpoint
.
location
)
)
;
if
(
!
mappedScopes
)
{
return
breakpoint
;
}
const
{
mappings
}
=
mappedScopes
;
if
(
options
.
condition
)
{
options
.
condition
=
await
updateExpression
(
evaluationsParser
mappings
options
.
condition
)
;
}
if
(
options
.
logValue
)
{
options
.
logValue
=
await
updateExpression
(
evaluationsParser
mappings
options
.
logValue
)
;
}
validateNavigateContext
(
getState
(
)
cx
)
;
return
{
.
.
.
breakpoint
options
}
;
}
;
}
