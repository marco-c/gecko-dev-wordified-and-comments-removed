import
{
makeBreakpointLocation
makeBreakpointId
getASTLocation
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
{
getBreakpoint
getBreakpointPositionsForLocation
getFirstBreakpointPosition
getSymbols
getSource
getSourceContent
getBreakpointsList
getPendingBreakpointList
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
setBreakpointPositions
}
from
"
.
/
breakpointPositions
"
;
import
{
setSkipPausing
}
from
"
.
.
/
pause
/
skipPausing
"
;
import
{
PROMISE
}
from
"
.
.
/
utils
/
middleware
/
promise
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
{
comparePosition
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
getTextAtPosition
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
type
{
ThunkArgs
}
from
"
.
.
/
types
"
;
import
type
{
Breakpoint
BreakpointOptions
BreakpointPosition
SourceLocation
Context
}
from
"
.
.
/
.
.
/
types
"
;
function
clientSetBreakpoint
(
client
state
breakpoint
:
Breakpoint
)
{
const
breakpointLocation
=
makeBreakpointLocation
(
state
breakpoint
.
generatedLocation
)
;
return
client
.
setBreakpoint
(
breakpointLocation
breakpoint
.
options
)
;
}
function
clientRemoveBreakpoint
(
client
state
generatedLocation
:
SourceLocation
)
{
const
breakpointLocation
=
makeBreakpointLocation
(
state
generatedLocation
)
;
return
client
.
removeBreakpoint
(
breakpointLocation
)
;
}
export
function
enableBreakpoint
(
cx
:
Context
initialBreakpoint
:
Breakpoint
)
{
return
(
{
dispatch
getState
client
sourceMaps
}
:
ThunkArgs
)
=
>
{
const
breakpoint
=
getBreakpoint
(
getState
(
)
initialBreakpoint
.
location
)
;
if
(
!
breakpoint
|
|
!
breakpoint
.
disabled
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
:
{
.
.
.
breakpoint
disabled
:
false
}
[
PROMISE
]
:
clientSetBreakpoint
(
client
getState
(
)
breakpoint
)
}
)
;
}
;
}
export
function
addBreakpoint
(
cx
:
Context
initialLocation
:
SourceLocation
options
:
BreakpointOptions
=
{
}
disabled
:
boolean
=
false
shouldCancel
:
(
)
=
>
boolean
=
(
)
=
>
false
)
{
return
async
(
{
dispatch
getState
sourceMaps
client
}
:
ThunkArgs
)
=
>
{
recordEvent
(
"
add_breakpoint
"
)
;
const
{
sourceId
column
line
}
=
initialLocation
;
await
dispatch
(
setBreakpointPositions
(
{
cx
sourceId
line
}
)
)
;
const
position
:
?
BreakpointPosition
=
column
?
getBreakpointPositionsForLocation
(
getState
(
)
initialLocation
)
:
getFirstBreakpointPosition
(
getState
(
)
initialLocation
)
;
if
(
!
position
)
{
return
;
}
const
{
location
generatedLocation
}
=
position
;
const
source
=
getSource
(
getState
(
)
location
.
sourceId
)
;
const
generatedSource
=
getSource
(
getState
(
)
generatedLocation
.
sourceId
)
;
if
(
!
source
|
|
!
generatedSource
)
{
return
;
}
const
symbols
=
getSymbols
(
getState
(
)
source
)
;
const
astLocation
=
getASTLocation
(
source
symbols
location
)
;
const
originalContent
=
getSourceContent
(
getState
(
)
source
.
id
)
;
const
originalText
=
getTextAtPosition
(
source
.
id
originalContent
location
)
;
const
content
=
getSourceContent
(
getState
(
)
generatedSource
.
id
)
;
const
text
=
getTextAtPosition
(
generatedSource
.
id
content
generatedLocation
)
;
const
id
=
makeBreakpointId
(
location
)
;
const
breakpoint
=
{
id
disabled
options
location
astLocation
generatedLocation
text
originalText
}
;
if
(
shouldCancel
(
)
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
[
PROMISE
]
:
disabled
?
clientRemoveBreakpoint
(
client
getState
(
)
generatedLocation
)
:
clientSetBreakpoint
(
client
getState
(
)
breakpoint
)
}
)
;
}
;
}
export
function
removeBreakpoint
(
cx
:
Context
initialBreakpoint
:
Breakpoint
)
{
return
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
recordEvent
(
"
remove_breakpoint
"
)
;
const
breakpoint
=
getBreakpoint
(
getState
(
)
initialBreakpoint
.
location
)
;
if
(
!
breakpoint
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
REMOVE_BREAKPOINT
"
cx
location
:
breakpoint
.
location
[
PROMISE
]
:
breakpoint
.
disabled
?
Promise
.
resolve
(
)
:
clientRemoveBreakpoint
(
client
getState
(
)
breakpoint
.
generatedLocation
)
}
)
;
}
;
}
export
function
removeBreakpointAtGeneratedLocation
(
cx
:
Context
target
:
SourceLocation
)
{
return
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
const
onBreakpointRemoved
=
clientRemoveBreakpoint
(
client
getState
(
)
target
)
;
const
breakpoints
=
getBreakpointsList
(
getState
(
)
)
;
for
(
const
{
location
generatedLocation
}
of
breakpoints
)
{
if
(
generatedLocation
.
sourceId
=
=
target
.
sourceId
&
&
comparePosition
(
generatedLocation
target
)
)
{
dispatch
(
{
type
:
"
REMOVE_BREAKPOINT
"
cx
location
[
PROMISE
]
:
onBreakpointRemoved
}
)
;
}
}
const
pending
=
getPendingBreakpointList
(
getState
(
)
)
;
for
(
const
{
location
generatedLocation
}
of
pending
)
{
if
(
generatedLocation
.
sourceUrl
=
=
target
.
sourceUrl
&
&
comparePosition
(
generatedLocation
target
)
)
{
dispatch
(
{
type
:
"
REMOVE_PENDING_BREAKPOINT
"
cx
location
}
)
;
}
}
return
onBreakpointRemoved
;
}
;
}
export
function
disableBreakpoint
(
cx
:
Context
initialBreakpoint
:
Breakpoint
)
{
return
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
const
breakpoint
=
getBreakpoint
(
getState
(
)
initialBreakpoint
.
location
)
;
if
(
!
breakpoint
|
|
breakpoint
.
disabled
)
{
return
;
}
dispatch
(
setSkipPausing
(
false
)
)
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
:
{
.
.
.
breakpoint
disabled
:
true
}
[
PROMISE
]
:
clientRemoveBreakpoint
(
client
getState
(
)
breakpoint
.
generatedLocation
)
}
)
;
}
;
}
export
function
setBreakpointOptions
(
cx
:
Context
location
:
SourceLocation
options
:
BreakpointOptions
=
{
}
)
{
return
(
{
dispatch
getState
client
sourceMaps
}
:
ThunkArgs
)
=
>
{
let
breakpoint
=
getBreakpoint
(
getState
(
)
location
)
;
if
(
!
breakpoint
)
{
return
dispatch
(
addBreakpoint
(
cx
location
options
)
)
;
}
breakpoint
=
{
.
.
.
breakpoint
disabled
:
false
options
}
;
return
dispatch
(
{
type
:
"
SET_BREAKPOINT
"
cx
breakpoint
[
PROMISE
]
:
clientSetBreakpoint
(
client
getState
(
)
breakpoint
)
}
)
;
}
;
}
