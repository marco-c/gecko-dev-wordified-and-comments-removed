import
{
getBreakpointPositionsForSource
getSourceActorsForSource
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
import
{
makeBreakpointId
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
/
index
"
;
import
{
memoizeableAction
}
from
"
.
.
/
.
.
/
utils
/
memoizableAction
"
;
import
{
fulfilled
}
from
"
.
.
/
.
.
/
utils
/
async
-
value
"
;
import
{
sourceMapToDebuggerLocation
createLocation
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
validateSource
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
async
function
mapToLocations
(
breakpointPositions
generatedSource
mappedLocation
{
getState
sourceMapLoader
}
)
{
let
mappedBreakpointPositions
=
await
sourceMapLoader
.
getOriginalLocations
(
breakpointPositions
generatedSource
.
id
)
;
if
(
!
mappedBreakpointPositions
)
{
mappedBreakpointPositions
=
breakpointPositions
;
}
const
positions
=
{
}
;
if
(
typeof
mappedLocation
.
line
=
=
=
"
number
"
)
{
positions
[
mappedLocation
.
line
]
=
[
]
;
}
const
handledBreakpointIds
=
new
Set
(
)
;
const
isOriginal
=
mappedLocation
.
source
.
isOriginal
;
const
originalSourceId
=
mappedLocation
.
source
.
id
;
for
(
let
line
in
mappedBreakpointPositions
)
{
line
=
parseInt
(
line
10
)
;
for
(
const
columnOrSourceMapLocation
of
mappedBreakpointPositions
[
line
]
)
{
let
location
generatedLocation
;
if
(
typeof
columnOrSourceMapLocation
=
=
"
number
"
)
{
if
(
isOriginal
)
{
continue
;
}
location
=
generatedLocation
=
createLocation
(
{
line
column
:
columnOrSourceMapLocation
source
:
generatedSource
}
)
;
}
else
{
if
(
isOriginal
&
&
columnOrSourceMapLocation
.
sourceId
!
=
originalSourceId
)
{
continue
;
}
location
=
sourceMapToDebuggerLocation
(
getState
(
)
columnOrSourceMapLocation
)
;
const
breakpointId
=
makeBreakpointId
(
location
)
;
if
(
handledBreakpointIds
.
has
(
breakpointId
)
)
{
continue
;
}
handledBreakpointIds
.
add
(
breakpointId
)
;
generatedLocation
=
createLocation
(
{
line
column
:
columnOrSourceMapLocation
.
generatedColumn
source
:
generatedSource
}
)
;
}
const
keyLocation
=
isOriginal
?
location
:
generatedLocation
;
const
keyLine
=
keyLocation
.
line
;
if
(
!
positions
[
keyLine
]
)
{
positions
[
keyLine
]
=
[
]
;
}
positions
[
keyLine
]
.
push
(
{
location
generatedLocation
}
)
;
}
}
return
positions
;
}
async
function
_setBreakpointPositions
(
location
thunkArgs
)
{
const
{
client
dispatch
getState
sourceMapLoader
}
=
thunkArgs
;
const
results
=
{
}
;
let
generatedSource
=
location
.
source
;
if
(
location
.
source
.
isOriginal
)
{
const
ranges
=
await
sourceMapLoader
.
getGeneratedRangesForOriginal
(
location
.
source
.
id
true
)
;
generatedSource
=
location
.
source
.
generatedSource
;
for
(
const
range
of
ranges
)
{
if
(
range
.
end
.
column
=
=
=
Infinity
)
{
range
.
end
=
{
line
:
range
.
end
.
line
+
1
column
:
0
}
;
}
const
allActorsPositions
=
await
Promise
.
all
(
getSourceActorsForSource
(
getState
(
)
generatedSource
.
id
)
.
map
(
actor
=
>
client
.
getSourceActorBreakpointPositions
(
actor
range
)
)
)
;
for
(
const
actorPositions
of
allActorsPositions
)
{
for
(
const
rangeLine
in
actorPositions
)
{
const
columns
=
actorPositions
[
rangeLine
]
;
const
existing
=
results
[
rangeLine
]
;
if
(
existing
)
{
for
(
const
column
of
columns
)
{
if
(
!
existing
.
includes
(
column
)
)
{
existing
.
push
(
column
)
;
}
}
}
else
{
results
[
rangeLine
]
=
columns
;
}
}
}
}
}
else
{
const
{
line
}
=
location
;
if
(
typeof
line
!
=
=
"
number
"
)
{
throw
new
Error
(
"
Line
is
required
for
generated
sources
"
)
;
}
const
allActorsBreakableColumns
=
await
Promise
.
all
(
getSourceActorsForSource
(
getState
(
)
location
.
source
.
id
)
.
map
(
async
actor
=
>
{
const
positions
=
await
client
.
getSourceActorBreakpointPositions
(
actor
{
start
:
{
line
column
:
0
}
end
:
{
line
:
line
+
1
column
:
0
}
}
)
;
return
positions
[
line
]
|
|
[
]
;
}
)
)
;
for
(
const
columns
of
allActorsBreakableColumns
)
{
const
existing
=
results
[
line
]
;
if
(
existing
)
{
for
(
const
column
of
columns
)
{
if
(
!
existing
.
includes
(
column
)
)
{
existing
.
push
(
column
)
;
}
}
}
else
{
results
[
line
]
=
columns
;
}
}
}
const
positions
=
await
mapToLocations
(
results
generatedSource
location
thunkArgs
)
;
validateSource
(
getState
(
)
location
.
source
)
;
dispatch
(
{
type
:
"
ADD_BREAKPOINT_POSITIONS
"
source
:
location
.
source
positions
}
)
;
}
function
generatedSourceActorKey
(
state
source
)
{
const
generatedSource
=
source
.
isOriginal
?
source
.
generatedSource
:
source
;
const
actors
=
generatedSource
?
getSourceActorsForSource
(
state
generatedSource
.
id
)
.
map
(
(
{
actor
}
)
=
>
actor
)
:
[
]
;
return
[
source
.
id
.
.
.
actors
]
.
join
(
"
:
"
)
;
}
export
const
setBreakpointPositions
=
memoizeableAction
(
"
setBreakpointPositions
"
{
getValue
:
(
location
{
getState
}
)
=
>
{
const
positions
=
getBreakpointPositionsForSource
(
getState
(
)
location
.
source
.
id
)
;
if
(
!
positions
)
{
return
null
;
}
if
(
!
location
.
source
.
isOriginal
&
&
location
.
line
&
&
!
positions
[
location
.
line
]
)
{
return
null
;
}
return
fulfilled
(
positions
)
;
}
createKey
(
location
{
getState
}
)
{
const
key
=
generatedSourceActorKey
(
getState
(
)
location
.
source
)
;
return
!
location
.
source
.
isOriginal
&
&
location
.
line
?
{
key
}
-
{
location
.
line
}
:
key
;
}
action
:
async
(
location
thunkArgs
)
=
>
_setBreakpointPositions
(
location
thunkArgs
)
}
)
;
export
function
updateBreakpointPositionsForNewPrettyPrintedSource
(
minifiedSource
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
oldPositions
=
getBreakpointPositionsForSource
(
getState
(
)
minifiedSource
.
id
)
;
if
(
!
oldPositions
)
{
return
;
}
const
lines
=
[
.
.
.
Object
.
keys
(
oldPositions
)
]
.
map
(
lineString
=
>
Number
(
lineString
)
)
;
dispatch
(
{
type
:
"
CLEAR_BREAKPOINT_POSITIONS
"
source
:
minifiedSource
}
)
;
await
Promise
.
all
(
lines
.
map
(
line
=
>
dispatch
(
setBreakpointPositions
(
{
source
:
minifiedSource
line
}
)
)
)
)
;
}
;
}
