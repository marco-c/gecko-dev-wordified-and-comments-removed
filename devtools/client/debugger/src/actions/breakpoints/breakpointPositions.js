import
{
isOriginalId
originalToGeneratedId
}
from
"
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
"
;
import
{
getSource
getSourceFromId
getBreakpointPositionsForSource
getSourceActorsForSource
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
makeBreakpointId
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
{
memoizeableAction
}
from
"
.
.
/
.
.
/
utils
/
memoizableAction
"
;
import
{
fulfilled
}
from
"
.
.
/
.
.
/
utils
/
async
-
value
"
;
import
{
debuggerToSourceMapLocation
sourceMapToDebuggerLocation
createLocation
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
validateSource
}
from
"
.
.
/
.
.
/
utils
/
context
"
;
async
function
mapLocations
(
generatedLocations
{
getState
sourceMapLoader
}
)
{
if
(
!
generatedLocations
.
length
)
{
return
[
]
;
}
const
originalLocations
=
await
sourceMapLoader
.
getOriginalLocations
(
generatedLocations
.
map
(
debuggerToSourceMapLocation
)
)
;
return
originalLocations
.
map
(
(
location
index
)
=
>
(
{
location
:
location
?
sourceMapToDebuggerLocation
(
getState
(
)
location
)
:
generatedLocations
[
index
]
generatedLocation
:
generatedLocations
[
index
]
}
)
)
;
}
function
filterBySource
(
positions
sourceId
)
{
if
(
!
isOriginalId
(
sourceId
)
)
{
return
positions
;
}
return
positions
.
filter
(
position
=
>
position
.
location
.
source
.
id
=
=
sourceId
)
;
}
function
filterByUniqLocation
(
positions
)
{
const
handledBreakpointIds
=
new
Set
(
)
;
return
positions
.
filter
(
(
{
location
}
)
=
>
{
const
breakpointId
=
makeBreakpointId
(
location
)
;
if
(
handledBreakpointIds
.
has
(
breakpointId
)
)
{
return
false
;
}
handledBreakpointIds
.
add
(
breakpointId
)
;
return
true
;
}
)
;
}
function
convertToList
(
results
source
)
{
const
positions
=
[
]
;
for
(
const
line
in
results
)
{
for
(
const
column
of
results
[
line
]
)
{
positions
.
push
(
createLocation
(
{
line
:
Number
(
line
)
column
source
}
)
)
;
}
}
return
positions
;
}
function
groupByLine
(
results
sourceId
line
)
{
const
isOriginal
=
isOriginalId
(
sourceId
)
;
const
positions
=
{
}
;
if
(
typeof
line
=
=
=
"
number
"
)
{
positions
[
line
]
=
[
]
;
}
for
(
const
result
of
results
)
{
const
location
=
isOriginal
?
result
.
location
:
result
.
generatedLocation
;
if
(
!
positions
[
location
.
line
]
)
{
positions
[
location
.
line
]
=
[
]
;
}
positions
[
location
.
line
]
.
push
(
result
)
;
}
return
positions
;
}
async
function
_setBreakpointPositions
(
location
thunkArgs
)
{
const
{
client
dispatch
getState
sourceMapLoader
}
=
thunkArgs
;
const
results
=
{
}
;
let
generatedSource
=
location
.
source
;
if
(
isOriginalId
(
location
.
source
.
id
)
)
{
const
ranges
=
await
sourceMapLoader
.
getGeneratedRangesForOriginal
(
location
.
source
.
id
true
)
;
const
generatedSourceId
=
originalToGeneratedId
(
location
.
source
.
id
)
;
generatedSource
=
getSourceFromId
(
getState
(
)
generatedSourceId
)
;
for
(
const
range
of
ranges
)
{
if
(
range
.
end
.
column
=
=
=
Infinity
)
{
range
.
end
=
{
line
:
range
.
end
.
line
+
1
column
:
0
}
;
}
const
actorBps
=
await
Promise
.
all
(
getSourceActorsForSource
(
getState
(
)
generatedSourceId
)
.
map
(
actor
=
>
client
.
getSourceActorBreakpointPositions
(
actor
range
)
)
)
;
for
(
const
actorPositions
of
actorBps
)
{
for
(
const
rangeLine
of
Object
.
keys
(
actorPositions
)
)
{
let
columns
=
actorPositions
[
parseInt
(
rangeLine
10
)
]
;
const
existing
=
results
[
rangeLine
]
;
if
(
existing
)
{
columns
=
[
.
.
.
new
Set
(
[
.
.
.
existing
.
.
.
columns
]
)
]
;
}
results
[
rangeLine
]
=
columns
;
}
}
}
}
else
{
const
{
line
}
=
location
;
if
(
typeof
line
!
=
=
"
number
"
)
{
throw
new
Error
(
"
Line
is
required
for
generated
sources
"
)
;
}
const
actorColumns
=
await
Promise
.
all
(
getSourceActorsForSource
(
getState
(
)
location
.
source
.
id
)
.
map
(
async
actor
=
>
{
const
positions
=
await
client
.
getSourceActorBreakpointPositions
(
actor
{
start
:
{
line
:
line
column
:
0
}
end
:
{
line
:
line
+
1
column
:
0
}
}
)
;
return
positions
[
line
]
|
|
[
]
;
}
)
)
;
for
(
const
columns
of
actorColumns
)
{
results
[
line
]
=
(
results
[
line
]
|
|
[
]
)
.
concat
(
columns
)
;
}
}
let
positions
=
convertToList
(
results
generatedSource
)
;
positions
=
await
mapLocations
(
positions
thunkArgs
)
;
validateSource
(
getState
(
)
location
.
source
)
;
positions
=
filterBySource
(
positions
location
.
source
.
id
)
;
positions
=
filterByUniqLocation
(
positions
)
;
positions
=
groupByLine
(
positions
location
.
source
.
id
location
.
line
)
;
dispatch
(
{
type
:
"
ADD_BREAKPOINT_POSITIONS
"
source
:
location
.
source
positions
}
)
;
}
function
generatedSourceActorKey
(
state
sourceId
)
{
const
generatedSource
=
getSource
(
state
isOriginalId
(
sourceId
)
?
originalToGeneratedId
(
sourceId
)
:
sourceId
)
;
const
actors
=
generatedSource
?
getSourceActorsForSource
(
state
generatedSource
.
id
)
.
map
(
(
{
actor
}
)
=
>
actor
)
:
[
]
;
return
[
sourceId
.
.
.
actors
]
.
join
(
"
:
"
)
;
}
export
const
setBreakpointPositions
=
memoizeableAction
(
"
setBreakpointPositions
"
{
getValue
:
(
location
{
getState
}
)
=
>
{
const
positions
=
getBreakpointPositionsForSource
(
getState
(
)
location
.
source
.
id
)
;
if
(
!
positions
)
{
return
null
;
}
if
(
!
location
.
source
.
isOriginal
&
&
location
.
line
&
&
!
positions
[
location
.
line
]
)
{
return
null
;
}
return
fulfilled
(
positions
)
;
}
createKey
(
location
{
getState
}
)
{
const
key
=
generatedSourceActorKey
(
getState
(
)
location
.
source
.
id
)
;
return
!
location
.
source
.
isOriginal
&
&
location
.
line
?
{
key
}
-
{
location
.
line
}
:
key
;
}
action
:
async
(
location
thunkArgs
)
=
>
_setBreakpointPositions
(
location
thunkArgs
)
}
)
;
