import
SourceMaps
{
isOriginalId
originalToGeneratedId
}
from
"
devtools
-
source
-
map
"
;
import
{
uniqBy
zip
}
from
"
lodash
"
;
import
{
getSource
getSourceFromId
hasBreakpointPositions
getBreakpointPositionsForSource
}
from
"
.
.
/
.
.
/
selectors
"
;
import
type
{
MappedLocation
Range
SourceLocation
BreakpointPositions
Context
}
from
"
.
.
/
.
.
/
types
"
;
import
{
makeBreakpointId
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
{
memoizeableAction
type
MemoizedAction
}
from
"
.
.
/
.
.
/
utils
/
memoizableAction
"
;
async
function
mapLocations
(
generatedLocations
:
SourceLocation
[
]
{
sourceMaps
}
:
{
sourceMaps
:
typeof
SourceMaps
}
)
{
const
originalLocations
=
await
sourceMaps
.
getOriginalLocations
(
generatedLocations
)
;
return
zip
(
originalLocations
generatedLocations
)
.
map
(
(
[
location
generatedLocation
]
)
=
>
(
{
location
generatedLocation
}
)
)
;
}
function
filterBySource
(
positions
sourceId
)
{
if
(
!
isOriginalId
(
sourceId
)
)
{
return
positions
;
}
return
positions
.
filter
(
position
=
>
position
.
location
.
sourceId
=
=
sourceId
)
;
}
function
filterByUniqLocation
(
positions
:
MappedLocation
[
]
)
{
return
uniqBy
(
positions
(
{
location
}
)
=
>
makeBreakpointId
(
location
)
)
;
}
function
convertToList
(
results
source
)
{
const
{
id
url
}
=
source
;
const
positions
=
[
]
;
for
(
const
line
in
results
)
{
for
(
const
column
of
results
[
line
]
)
{
positions
.
push
(
{
line
:
Number
(
line
)
column
:
column
sourceId
:
id
sourceUrl
:
url
}
)
;
}
}
return
positions
;
}
async
function
_setBreakpointPositions
(
cx
sourceId
thunkArgs
)
{
const
{
client
dispatch
getState
sourceMaps
}
=
thunkArgs
;
let
generatedSource
=
getSource
(
getState
(
)
sourceId
)
;
if
(
!
generatedSource
)
{
return
;
}
let
results
=
{
}
;
if
(
isOriginalId
(
sourceId
)
)
{
const
ranges
:
Range
[
]
=
await
sourceMaps
.
getGeneratedRangesForOriginal
(
sourceId
generatedSource
.
url
true
)
;
const
generatedSourceId
=
originalToGeneratedId
(
sourceId
)
;
generatedSource
=
getSourceFromId
(
getState
(
)
generatedSourceId
)
;
for
(
const
range
of
ranges
)
{
if
(
range
.
end
.
column
=
=
=
Infinity
)
{
range
.
end
=
{
line
:
range
.
end
.
line
+
1
column
:
0
}
;
}
const
bps
=
await
client
.
getBreakpointPositions
(
generatedSource
range
)
;
for
(
const
line
in
bps
)
{
results
[
line
]
=
(
results
[
line
]
|
|
[
]
)
.
concat
(
bps
[
line
]
)
;
}
}
}
else
{
results
=
await
client
.
getBreakpointPositions
(
generatedSource
)
;
}
let
positions
=
convertToList
(
results
generatedSource
)
;
positions
=
await
mapLocations
(
positions
thunkArgs
)
;
positions
=
filterBySource
(
positions
sourceId
)
;
positions
=
filterByUniqLocation
(
positions
)
;
const
source
=
getSource
(
getState
(
)
sourceId
)
;
if
(
!
source
)
{
return
;
}
dispatch
(
{
type
:
"
ADD_BREAKPOINT_POSITIONS
"
cx
source
:
source
positions
}
)
;
return
positions
;
}
export
const
setBreakpointPositions
:
MemoizedAction
<
{
cx
:
Context
sourceId
:
string
}
?
BreakpointPositions
>
=
memoizeableAction
(
"
setBreakpointPositions
"
{
hasValue
:
(
{
sourceId
}
{
getState
}
)
=
>
hasBreakpointPositions
(
getState
(
)
sourceId
)
getValue
:
(
{
sourceId
}
{
getState
}
)
=
>
getBreakpointPositionsForSource
(
getState
(
)
sourceId
)
createKey
(
{
sourceId
}
{
getState
}
)
{
const
generatedSource
=
getSource
(
getState
(
)
isOriginalId
(
sourceId
)
?
originalToGeneratedId
(
sourceId
)
:
sourceId
)
;
const
actors
=
generatedSource
?
generatedSource
.
actors
.
map
(
(
{
actor
}
)
=
>
actor
)
:
[
]
;
return
[
sourceId
.
.
.
actors
]
.
join
(
"
:
"
)
;
}
action
:
(
{
cx
sourceId
}
thunkArgs
)
=
>
_setBreakpointPositions
(
cx
sourceId
thunkArgs
)
}
)
;
