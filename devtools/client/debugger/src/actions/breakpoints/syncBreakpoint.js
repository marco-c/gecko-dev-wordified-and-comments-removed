import
{
setBreakpointPositions
}
from
"
.
/
breakpointPositions
"
;
import
{
findPosition
makeBreakpointServerLocation
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
{
comparePosition
createLocation
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
import
{
originalToGeneratedId
isOriginalId
}
from
"
devtools
/
client
/
shared
/
source
-
map
-
loader
/
index
"
;
import
{
getSource
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
addBreakpoint
removeBreakpointAtGeneratedLocation
}
from
"
.
"
;
async
function
findBreakpointPosition
(
cx
{
getState
dispatch
}
location
)
{
const
positions
=
await
dispatch
(
setBreakpointPositions
(
{
cx
location
}
)
)
;
const
position
=
findPosition
(
positions
location
)
;
return
position
;
}
export
function
syncPendingBreakpoint
(
cx
sourceId
pendingBreakpoint
)
{
return
async
thunkArgs
=
>
{
const
{
getState
client
dispatch
}
=
thunkArgs
;
const
source
=
getSource
(
getState
(
)
sourceId
)
;
const
generatedSourceId
=
isOriginalId
(
sourceId
)
?
originalToGeneratedId
(
sourceId
)
:
sourceId
;
const
generatedSource
=
getSource
(
getState
(
)
generatedSourceId
)
;
if
(
!
source
|
|
!
generatedSource
)
{
return
null
;
}
const
{
location
generatedLocation
}
=
pendingBreakpoint
;
const
isPendingBreakpointWithSourceMap
=
location
.
sourceUrl
!
=
generatedLocation
.
sourceUrl
;
const
sourceGeneratedLocation
=
createLocation
(
{
.
.
.
generatedLocation
source
:
generatedSource
}
)
;
if
(
source
=
=
generatedSource
&
&
isPendingBreakpointWithSourceMap
)
{
const
breakpointServerLocation
=
makeBreakpointServerLocation
(
getState
(
)
sourceGeneratedLocation
)
;
return
dispatch
(
addBreakpoint
(
cx
sourceGeneratedLocation
pendingBreakpoint
.
options
pendingBreakpoint
.
disabled
(
)
=
>
!
client
.
hasBreakpoint
(
breakpointServerLocation
)
)
)
;
}
const
originalLocation
=
createLocation
(
{
.
.
.
location
source
}
)
;
const
newPosition
=
await
findBreakpointPosition
(
cx
thunkArgs
originalLocation
)
;
const
newGeneratedLocation
=
newPosition
?
.
generatedLocation
;
if
(
!
newGeneratedLocation
)
{
if
(
isPendingBreakpointWithSourceMap
)
{
dispatch
(
removeBreakpointAtGeneratedLocation
(
cx
sourceGeneratedLocation
)
)
;
}
return
null
;
}
const
isSameLocation
=
comparePosition
(
generatedLocation
newGeneratedLocation
)
;
if
(
!
isSameLocation
)
{
dispatch
(
removeBreakpointAtGeneratedLocation
(
cx
sourceGeneratedLocation
)
)
;
}
return
dispatch
(
addBreakpoint
(
cx
newGeneratedLocation
pendingBreakpoint
.
options
pendingBreakpoint
.
disabled
)
)
;
}
;
}
