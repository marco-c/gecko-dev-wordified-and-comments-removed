import
{
createThread
createFrame
}
from
"
.
/
create
"
;
import
{
makePendingLocationId
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
Reps
from
"
devtools
/
client
/
shared
/
components
/
reps
/
index
"
;
import
type
{
BreakpointLocation
BreakpointOptions
PendingLocation
Frame
FrameId
OINode
Script
SourceActor
Range
URL
Thread
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
Target
DevToolsClient
TargetList
Grip
ThreadFront
ObjectFront
FrameFront
ExpressionResult
}
from
"
.
/
types
"
;
import
type
{
EventListenerCategoryList
}
from
"
.
.
/
.
.
/
actions
/
types
"
;
let
targets
:
{
[
string
]
:
Target
}
;
let
devToolsClient
:
DevToolsClient
;
let
targetList
:
TargetList
;
let
breakpoints
:
{
[
string
]
:
Object
}
;
const
CALL_STACK_PAGE_SIZE
=
1000
;
type
Dependencies
=
{
devToolsClient
:
DevToolsClient
targetList
:
TargetList
}
;
function
setupCommands
(
dependencies
:
Dependencies
)
:
void
{
devToolsClient
=
dependencies
.
devToolsClient
;
targetList
=
dependencies
.
targetList
;
targets
=
{
}
;
breakpoints
=
{
}
;
}
function
currentTarget
(
)
:
Target
{
return
targetList
.
targetFront
;
}
function
currentThreadFront
(
)
:
ThreadFront
{
return
currentTarget
(
)
.
threadFront
;
}
function
createObjectFront
(
grip
:
Grip
)
:
ObjectFront
{
if
(
!
grip
.
actor
)
{
throw
new
Error
(
"
Actor
is
missing
"
)
;
}
return
devToolsClient
.
createObjectFront
(
grip
currentThreadFront
(
)
)
;
}
async
function
loadObjectProperties
(
root
:
OINode
threadActorID
:
string
)
{
const
{
utils
}
=
Reps
.
objectInspector
;
const
properties
=
await
utils
.
loadProperties
.
loadItemProperties
(
root
devToolsClient
undefined
threadActorID
)
;
return
utils
.
node
.
getChildren
(
{
item
:
root
loadedProperties
:
new
Map
(
[
[
root
.
path
properties
]
]
)
}
)
;
}
function
releaseActor
(
actor
:
String
)
{
if
(
!
actor
)
{
return
;
}
const
objFront
=
devToolsClient
.
getFrontByID
(
actor
)
;
if
(
objFront
)
{
return
objFront
.
release
(
)
.
catch
(
(
)
=
>
{
}
)
;
}
}
function
getTargetsMap
(
)
:
{
string
:
Target
}
{
return
Object
.
assign
(
{
}
targets
)
;
}
function
lookupTarget
(
thread
:
string
)
{
if
(
thread
=
=
currentThreadFront
(
)
.
actor
)
{
return
currentTarget
(
)
;
}
const
targetsMap
=
getTargetsMap
(
)
;
if
(
!
targetsMap
[
thread
]
)
{
throw
new
Error
(
Unknown
thread
front
:
{
thread
}
)
;
}
return
targetsMap
[
thread
]
;
}
function
lookupThreadFront
(
thread
:
string
)
{
const
target
=
lookupTarget
(
thread
)
;
return
target
.
threadFront
;
}
function
listThreadFronts
(
)
{
const
list
=
(
Object
.
values
(
getTargetsMap
(
)
)
:
any
)
;
return
list
.
map
(
target
=
>
target
.
threadFront
)
.
filter
(
t
=
>
!
!
t
)
;
}
function
forEachThread
(
iteratee
)
{
const
promises
=
[
currentThreadFront
(
)
.
.
.
listThreadFronts
(
)
]
.
map
(
t
=
>
iteratee
(
t
)
.
catch
(
e
=
>
console
.
log
(
e
)
)
)
;
return
Promise
.
all
(
promises
)
;
}
function
resume
(
thread
:
string
frameId
:
?
FrameId
)
:
Promise
<
*
>
{
return
lookupThreadFront
(
thread
)
.
resume
(
)
;
}
function
stepIn
(
thread
:
string
frameId
:
?
FrameId
)
:
Promise
<
*
>
{
return
lookupThreadFront
(
thread
)
.
stepIn
(
frameId
)
;
}
function
stepOver
(
thread
:
string
frameId
:
?
FrameId
)
:
Promise
<
*
>
{
return
lookupThreadFront
(
thread
)
.
stepOver
(
frameId
)
;
}
function
stepOut
(
thread
:
string
frameId
:
?
FrameId
)
:
Promise
<
*
>
{
return
lookupThreadFront
(
thread
)
.
stepOut
(
frameId
)
;
}
function
restart
(
thread
:
string
frameId
:
FrameId
)
:
Promise
<
*
>
{
return
lookupThreadFront
(
thread
)
.
restart
(
frameId
)
;
}
function
breakOnNext
(
thread
:
string
)
:
Promise
<
*
>
{
return
lookupThreadFront
(
thread
)
.
breakOnNext
(
)
;
}
async
function
sourceContents
(
{
actor
thread
}
:
SourceActor
)
:
Promise
<
{
|
source
:
any
contentType
:
?
string
|
}
>
{
const
sourceThreadFront
=
lookupThreadFront
(
thread
)
;
const
sourceFront
=
sourceThreadFront
.
source
(
{
actor
}
)
;
const
{
source
contentType
}
=
await
sourceFront
.
source
(
)
;
return
{
source
contentType
}
;
}
function
setXHRBreakpoint
(
path
:
string
method
:
string
)
{
return
currentThreadFront
(
)
.
setXHRBreakpoint
(
path
method
)
;
}
function
removeXHRBreakpoint
(
path
:
string
method
:
string
)
{
return
currentThreadFront
(
)
.
removeXHRBreakpoint
(
path
method
)
;
}
export
function
toggleJavaScriptEnabled
(
enabled
:
Boolean
)
{
return
targetList
.
updateConfiguration
(
{
javascriptEnabled
:
enabled
}
)
;
}
function
addWatchpoint
(
object
:
Grip
property
:
string
label
:
string
watchpointType
:
string
)
{
if
(
currentTarget
(
)
.
traits
.
watchpoints
)
{
const
objectFront
=
createObjectFront
(
object
)
;
return
objectFront
.
addWatchpoint
(
property
label
watchpointType
)
;
}
}
async
function
removeWatchpoint
(
object
:
Grip
property
:
string
)
{
if
(
currentTarget
(
)
.
traits
.
watchpoints
)
{
const
objectFront
=
createObjectFront
(
object
)
;
await
objectFront
.
removeWatchpoint
(
property
)
;
}
}
function
hasBreakpoint
(
location
:
BreakpointLocation
)
{
return
!
!
breakpoints
[
makePendingLocationId
(
location
)
]
;
}
async
function
setBreakpoint
(
location
:
BreakpointLocation
options
:
BreakpointOptions
)
{
const
breakpoint
=
breakpoints
[
makePendingLocationId
(
location
)
]
;
if
(
breakpoint
&
&
JSON
.
stringify
(
breakpoint
.
options
)
=
=
JSON
.
stringify
(
options
)
)
{
return
;
}
breakpoints
[
makePendingLocationId
(
location
)
]
=
{
location
options
}
;
const
serverOptions
=
{
condition
:
options
.
condition
logValue
:
options
.
logValue
}
;
const
hasWatcherSupport
=
targetList
.
hasTargetWatcherSupport
(
"
set
-
breakpoints
"
)
;
if
(
!
hasWatcherSupport
)
{
return
forEachThread
(
async
thread
=
>
thread
.
setBreakpoint
(
location
serverOptions
)
)
;
}
const
breakpointsFront
=
await
targetList
.
watcherFront
.
getBreakpointListActor
(
)
;
await
breakpointsFront
.
setBreakpoint
(
location
serverOptions
)
;
return
forEachThread
(
async
thread
=
>
{
if
(
!
targetList
.
hasTargetWatcherSupport
(
thread
.
targetFront
.
targetType
)
)
{
return
thread
.
setBreakpoint
(
location
serverOptions
)
;
}
}
)
;
}
async
function
removeBreakpoint
(
location
:
PendingLocation
)
{
delete
breakpoints
[
makePendingLocationId
(
(
location
:
any
)
)
]
;
const
hasWatcherSupport
=
targetList
.
hasTargetWatcherSupport
(
"
set
-
breakpoints
"
)
;
if
(
!
hasWatcherSupport
)
{
return
forEachThread
(
async
thread
=
>
thread
.
removeBreakpoint
(
location
)
)
;
}
const
breakpointsFront
=
await
targetList
.
watcherFront
.
getBreakpointListActor
(
)
;
await
breakpointsFront
.
removeBreakpoint
(
location
)
;
return
forEachThread
(
async
thread
=
>
{
if
(
!
targetList
.
hasTargetWatcherSupport
(
thread
.
targetFront
.
targetType
)
)
{
return
thread
.
removeBreakpoint
(
location
)
;
}
}
)
;
}
function
evaluateInFrame
(
script
:
Script
options
:
EvaluateParam
)
:
Promise
<
{
result
:
ExpressionResult
}
>
{
return
evaluate
(
script
options
)
;
}
async
function
evaluateExpressions
(
scripts
:
Script
[
]
options
:
EvaluateParam
)
{
return
Promise
.
all
(
scripts
.
map
(
script
=
>
evaluate
(
script
options
)
)
)
;
}
type
EvaluateParam
=
{
thread
:
string
frameId
:
?
FrameId
}
;
async
function
evaluate
(
script
:
?
Script
{
thread
frameId
}
:
EvaluateParam
=
{
}
)
:
Promise
<
{
result
:
ExpressionResult
}
>
{
const
params
=
{
thread
frameActor
:
frameId
}
;
if
(
!
currentTarget
(
)
|
|
!
script
)
{
return
{
result
:
null
}
;
}
const
target
=
thread
?
lookupTarget
(
thread
)
:
currentTarget
(
)
;
const
consoleFront
=
await
target
.
getFront
(
"
console
"
)
;
if
(
!
consoleFront
)
{
return
{
result
:
null
}
;
}
return
consoleFront
.
evaluateJSAsync
(
script
params
)
;
}
async
function
autocomplete
(
input
:
string
cursor
:
number
frameId
:
?
string
)
:
Promise
<
mixed
>
{
if
(
!
currentTarget
(
)
|
|
!
input
)
{
return
{
}
;
}
const
consoleFront
=
await
currentTarget
(
)
.
getFront
(
"
console
"
)
;
if
(
!
consoleFront
)
{
return
{
}
;
}
return
new
Promise
(
resolve
=
>
{
consoleFront
.
autocomplete
(
input
cursor
result
=
>
resolve
(
result
)
frameId
)
;
}
)
;
}
function
navigate
(
url
:
URL
)
:
Promise
<
*
>
{
return
currentTarget
(
)
.
navigateTo
(
{
url
}
)
;
}
function
reload
(
)
:
Promise
<
*
>
{
return
currentTarget
(
)
.
reload
(
)
;
}
function
getProperties
(
thread
:
string
grip
:
Grip
)
:
Promise
<
*
>
{
const
objClient
=
lookupThreadFront
(
thread
)
.
pauseGrip
(
grip
)
;
return
objClient
.
getPrototypeAndProperties
(
)
.
then
(
resp
=
>
{
const
{
ownProperties
safeGetterValues
}
=
resp
;
for
(
const
name
in
safeGetterValues
)
{
const
{
enumerable
writable
getterValue
}
=
safeGetterValues
[
name
]
;
ownProperties
[
name
]
=
{
enumerable
writable
value
:
getterValue
}
;
}
return
resp
;
}
)
;
}
async
function
getFrames
(
thread
:
string
)
{
const
threadFront
=
lookupThreadFront
(
thread
)
;
const
response
=
(
await
threadFront
.
getFrames
(
0
CALL_STACK_PAGE_SIZE
)
:
any
)
;
return
Promise
.
all
(
response
.
frames
.
map
<
?
FrameFront
>
(
(
frame
i
)
=
>
createFrame
(
thread
frame
i
)
)
)
;
}
async
function
getFrameScopes
(
frame
:
Frame
)
:
Promise
<
*
>
{
const
frameFront
=
lookupThreadFront
(
frame
.
thread
)
.
getActorByID
(
frame
.
id
)
;
return
frameFront
.
getEnvironment
(
)
;
}
function
pauseOnExceptions
(
shouldPauseOnExceptions
:
boolean
shouldPauseOnCaughtExceptions
:
boolean
)
:
Promise
<
*
>
{
return
forEachThread
(
thread
=
>
thread
.
pauseOnExceptions
(
shouldPauseOnExceptions
!
shouldPauseOnCaughtExceptions
)
)
;
}
async
function
blackBox
(
sourceActor
:
SourceActor
isBlackBoxed
:
boolean
range
?
:
Range
)
:
Promise
<
*
>
{
const
sourceFront
=
currentThreadFront
(
)
.
source
(
{
actor
:
sourceActor
.
actor
}
)
;
if
(
isBlackBoxed
)
{
await
sourceFront
.
unblackBox
(
range
)
;
}
else
{
await
sourceFront
.
blackBox
(
range
)
;
}
}
function
setSkipPausing
(
shouldSkip
:
boolean
)
{
return
forEachThread
(
thread
=
>
thread
.
skipBreakpoints
(
shouldSkip
)
)
;
}
function
interrupt
(
thread
:
string
)
:
Promise
<
*
>
{
return
lookupThreadFront
(
thread
)
.
interrupt
(
)
;
}
function
setEventListenerBreakpoints
(
ids
:
string
[
]
)
{
return
forEachThread
(
thread
=
>
thread
.
setActiveEventBreakpoints
(
ids
)
)
;
}
async
function
getEventListenerBreakpointTypes
(
)
:
Promise
<
EventListenerCategoryList
>
{
let
categories
;
try
{
categories
=
await
currentThreadFront
(
)
.
getAvailableEventBreakpoints
(
)
;
if
(
!
Array
.
isArray
(
categories
)
)
{
categories
=
null
;
}
}
catch
(
err
)
{
}
return
categories
|
|
[
]
;
}
function
pauseGrip
(
thread
:
string
func
:
Function
)
:
ObjectFront
{
return
lookupThreadFront
(
thread
)
.
pauseGrip
(
func
)
;
}
async
function
toggleEventLogging
(
logEventBreakpoints
:
boolean
)
{
return
forEachThread
(
thread
=
>
thread
.
toggleEventLogging
(
logEventBreakpoints
)
)
;
}
async
function
addThread
(
targetFront
:
Target
)
{
const
threadActorID
=
targetFront
.
targetForm
.
threadActor
;
if
(
!
targets
[
threadActorID
]
)
{
targets
[
threadActorID
]
=
targetFront
;
}
return
createThread
(
threadActorID
targetFront
)
;
}
function
removeThread
(
thread
:
Thread
)
{
delete
targets
[
thread
.
actor
]
;
}
function
getMainThread
(
)
{
return
currentThreadFront
(
)
.
actor
;
}
async
function
getSourceActorBreakpointPositions
(
{
thread
actor
}
:
SourceActor
range
:
Range
)
:
Promise
<
{
[
number
]
:
number
[
]
}
>
{
const
sourceThreadFront
=
lookupThreadFront
(
thread
)
;
const
sourceFront
=
sourceThreadFront
.
source
(
{
actor
}
)
;
return
sourceFront
.
getBreakpointPositionsCompressed
(
range
)
;
}
async
function
getSourceActorBreakableLines
(
{
thread
actor
}
:
SourceActor
)
:
Promise
<
Array
<
number
>
>
{
let
sourceFront
;
let
actorLines
=
[
]
;
try
{
const
sourceThreadFront
=
lookupThreadFront
(
thread
)
;
sourceFront
=
sourceThreadFront
.
source
(
{
actor
}
)
;
actorLines
=
await
sourceFront
.
getBreakableLines
(
)
;
}
catch
(
e
)
{
if
(
e
.
message
&
&
e
.
message
.
match
(
/
does
not
recognize
the
packet
type
getBreakableLines
/
)
)
{
const
pos
=
await
(
sourceFront
:
any
)
.
getBreakpointPositionsCompressed
(
)
;
actorLines
=
Object
.
keys
(
pos
)
.
map
(
line
=
>
Number
(
line
)
)
;
}
else
{
console
.
warn
(
getSourceActorBreakableLines
failed
:
{
e
}
)
;
}
}
return
actorLines
;
}
function
getFrontByID
(
actorID
:
String
)
{
return
devToolsClient
.
getFrontByID
(
actorID
)
;
}
function
fetchAncestorFramePositions
(
index
:
number
)
{
currentThreadFront
(
)
.
fetchAncestorFramePositions
(
index
)
;
}
const
clientCommands
=
{
autocomplete
blackBox
createObjectFront
loadObjectProperties
releaseActor
interrupt
pauseGrip
resume
stepIn
stepOut
stepOver
restart
breakOnNext
sourceContents
getSourceActorBreakpointPositions
getSourceActorBreakableLines
hasBreakpoint
setBreakpoint
setXHRBreakpoint
removeXHRBreakpoint
addWatchpoint
removeWatchpoint
removeBreakpoint
evaluate
evaluateInFrame
evaluateExpressions
navigate
reload
getProperties
getFrameScopes
getFrames
pauseOnExceptions
toggleEventLogging
addThread
removeThread
getMainThread
setSkipPausing
setEventListenerBreakpoints
getEventListenerBreakpointTypes
lookupTarget
getFrontByID
fetchAncestorFramePositions
toggleJavaScriptEnabled
}
;
export
{
setupCommands
clientCommands
}
;
