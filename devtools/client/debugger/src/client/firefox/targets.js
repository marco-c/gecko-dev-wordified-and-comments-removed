import
{
addThreadEventListeners
attachAllTargets
}
from
"
.
/
events
"
;
import
{
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
{
sameOrigin
}
from
"
.
.
/
.
.
/
utils
/
url
"
;
import
type
{
DebuggerClient
Target
}
from
"
.
/
types
"
;
const
{
defaultThreadOptions
}
=
require
(
"
devtools
/
client
/
shared
/
thread
-
utils
"
)
;
type
Args
=
{
currentTarget
:
Target
debuggerClient
:
DebuggerClient
targets
:
{
[
string
]
:
Target
}
options
:
Object
}
;
async
function
attachTargets
(
targetLists
args
)
{
const
{
targets
}
=
args
;
for
(
const
actor
of
Object
.
keys
(
targets
)
)
{
if
(
!
targetLists
.
some
(
target
=
>
target
.
targetForm
.
threadActor
=
=
actor
)
)
{
delete
targets
[
actor
]
;
}
}
for
(
const
targetFront
of
targetLists
)
{
try
{
await
targetFront
.
attach
(
)
;
const
threadActorID
=
targetFront
.
targetForm
.
threadActor
;
if
(
targets
[
threadActorID
]
)
{
continue
;
}
targets
[
threadActorID
]
=
targetFront
;
let
threadFront
=
targetFront
.
threadFront
;
if
(
!
threadFront
)
{
[
threadFront
]
=
await
targetFront
.
attachThread
(
{
.
.
.
defaultThreadOptions
(
)
.
.
.
args
.
options
}
)
;
threadFront
.
resume
(
)
;
}
addThreadEventListeners
(
threadFront
)
;
}
catch
(
e
)
{
}
}
}
async
function
listWorkerTargets
(
args
:
Args
)
{
const
{
currentTarget
debuggerClient
}
=
args
;
if
(
!
currentTarget
.
isBrowsingContext
|
|
currentTarget
.
isContentProcess
)
{
return
[
]
;
}
const
{
workers
}
=
await
currentTarget
.
listWorkers
(
)
;
if
(
features
.
windowlessServiceWorkers
&
&
currentTarget
.
url
)
{
const
{
service
}
=
await
debuggerClient
.
mainRoot
.
listAllWorkers
(
)
;
for
(
const
{
active
id
url
}
of
service
)
{
if
(
active
&
&
sameOrigin
(
url
currentTarget
.
url
)
)
{
const
workerTarget
=
await
debuggerClient
.
mainRoot
.
getWorker
(
id
)
;
workers
.
push
(
workerTarget
)
;
}
}
}
else
if
(
attachAllTargets
(
currentTarget
)
)
{
const
{
other
service
shared
}
=
await
debuggerClient
.
mainRoot
.
listAllWorkers
(
)
;
for
(
const
{
workerTargetFront
url
}
of
[
.
.
.
other
.
.
.
shared
]
)
{
if
(
!
url
.
includes
(
"
subprocess_worker
"
)
)
{
workers
.
push
(
workerTargetFront
)
;
}
}
for
(
const
{
active
id
}
of
service
)
{
if
(
active
)
{
const
workerTarget
=
await
debuggerClient
.
mainRoot
.
getWorker
(
id
)
;
workers
.
push
(
workerTarget
)
;
}
}
}
return
workers
;
}
async
function
listProcessTargets
(
args
:
Args
)
{
const
{
currentTarget
debuggerClient
}
=
args
;
if
(
!
attachAllTargets
(
currentTarget
)
)
{
return
[
]
;
}
const
{
processes
}
=
await
debuggerClient
.
mainRoot
.
listProcesses
(
)
;
const
targets
=
await
Promise
.
all
(
processes
.
filter
(
descriptor
=
>
!
descriptor
.
isParent
)
.
map
(
descriptor
=
>
descriptor
.
getTarget
(
)
)
)
;
return
targets
;
}
export
async
function
updateTargets
(
args
:
Args
)
{
const
workers
=
await
listWorkerTargets
(
args
)
;
const
processes
=
await
listProcessTargets
(
args
)
;
await
attachTargets
(
[
.
.
.
workers
.
.
.
processes
]
args
)
;
}
