import
{
addThreadEventListeners
attachAllTargets
}
from
"
.
/
events
"
;
import
{
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
{
sameOrigin
}
from
"
.
.
/
.
.
/
utils
/
url
"
;
import
type
{
DevToolsClient
TargetList
Target
}
from
"
.
/
types
"
;
const
{
defaultThreadOptions
}
=
require
(
"
devtools
/
client
/
shared
/
thread
-
utils
"
)
;
type
Args
=
{
devToolsClient
:
DevToolsClient
targets
:
{
[
string
]
:
Target
}
options
:
Object
targetList
:
TargetList
}
;
export
async
function
attachTarget
(
targetFront
:
Target
targets
:
{
[
string
]
:
Target
}
options
:
Object
)
{
try
{
await
targetFront
.
attach
(
)
;
const
threadActorID
=
targetFront
.
targetForm
.
threadActor
;
if
(
targets
[
threadActorID
]
)
{
return
;
}
targets
[
threadActorID
]
=
targetFront
;
let
threadFront
=
targetFront
.
threadFront
;
if
(
!
threadFront
)
{
threadFront
=
await
targetFront
.
attachThread
(
{
.
.
.
defaultThreadOptions
(
)
.
.
.
options
}
)
;
threadFront
.
resume
(
)
;
}
addThreadEventListeners
(
threadFront
)
;
}
catch
(
e
)
{
}
}
async
function
attachTargets
(
targetLists
args
)
:
Promise
<
*
>
{
const
{
targets
}
=
args
;
targetLists
=
targetLists
.
filter
(
target
=
>
!
!
target
)
;
for
(
const
actor
of
Object
.
keys
(
targets
)
)
{
if
(
!
targetLists
.
some
(
target
=
>
target
.
targetForm
.
threadActor
=
=
actor
)
)
{
delete
targets
[
actor
]
;
}
}
for
(
const
targetFront
of
targetLists
)
{
await
attachTarget
(
targetFront
targets
args
.
options
)
;
}
}
async
function
listWorkerTargets
(
args
:
Args
)
:
Promise
<
*
>
{
const
{
targetList
devToolsClient
}
=
args
;
const
currentTarget
=
targetList
.
targetFront
;
if
(
!
currentTarget
.
isBrowsingContext
|
|
currentTarget
.
isContentProcess
)
{
return
[
]
;
}
let
workers
=
[
]
;
let
allWorkers
;
let
serviceWorkerRegistrations
=
[
]
;
if
(
attachAllTargets
(
currentTarget
)
)
{
workers
=
await
devToolsClient
.
mainRoot
.
listAllWorkerTargets
(
)
;
workers
=
workers
.
filter
(
(
{
url
}
)
=
>
!
url
.
includes
(
"
subprocess_worker
"
)
)
;
allWorkers
=
workers
;
const
{
registrations
}
=
await
devToolsClient
.
mainRoot
.
listServiceWorkerRegistrations
(
)
;
serviceWorkerRegistrations
=
registrations
;
}
else
{
workers
=
(
await
currentTarget
.
listWorkers
(
)
)
.
workers
;
if
(
currentTarget
.
url
&
&
features
.
windowlessServiceWorkers
)
{
allWorkers
=
await
devToolsClient
.
mainRoot
.
listAllWorkerTargets
(
)
;
const
{
registrations
}
=
await
devToolsClient
.
mainRoot
.
listServiceWorkerRegistrations
(
)
;
serviceWorkerRegistrations
=
registrations
.
filter
(
front
=
>
sameOrigin
(
front
.
url
currentTarget
.
url
)
)
;
await
pauseMatchingServiceWorkers
(
{
devToolsClient
currentTarget
}
)
;
}
}
for
(
const
front
of
serviceWorkerRegistrations
)
{
const
{
activeWorker
waitingWorker
installingWorker
evaluatingWorker
}
=
front
;
await
maybeMarkServiceWorker
(
activeWorker
)
;
await
maybeMarkServiceWorker
(
waitingWorker
)
;
await
maybeMarkServiceWorker
(
installingWorker
)
;
await
maybeMarkServiceWorker
(
evaluatingWorker
)
;
}
async
function
maybeMarkServiceWorker
(
info
)
:
Promise
<
*
>
{
if
(
!
info
)
{
return
;
}
const
worker
=
allWorkers
.
find
(
front
=
>
front
&
&
front
.
id
=
=
info
.
id
)
;
if
(
!
worker
)
{
return
;
}
worker
.
debuggerServiceWorkerStatus
=
info
.
stateText
;
if
(
!
workers
.
includes
(
worker
)
)
{
workers
.
push
(
worker
)
;
}
}
return
workers
;
}
async
function
pauseMatchingServiceWorkers
(
{
devToolsClient
currentTarget
}
)
{
const
origin
=
new
URL
(
currentTarget
.
url
)
.
origin
;
const
processes
=
await
devToolsClient
.
mainRoot
.
listProcesses
(
)
;
const
targets
=
await
Promise
.
all
(
processes
.
filter
(
descriptor
=
>
!
descriptor
.
isParent
)
.
map
(
descriptor
=
>
descriptor
.
getTarget
(
)
)
)
;
try
{
await
Promise
.
all
(
targets
.
map
(
t
=
>
t
.
pauseMatchingServiceWorkers
(
{
origin
}
)
)
)
;
}
catch
(
e
)
{
}
}
async
function
listProcessTargets
(
args
:
Args
)
:
Promise
<
*
>
{
const
{
targetList
}
=
args
;
return
targetList
.
getAllTargets
(
targetList
.
TYPES
.
PROCESS
)
;
}
export
async
function
updateTargets
(
args
:
Args
)
:
Promise
<
*
>
{
const
currentTopLevelTarget
=
args
.
targetList
.
targetFront
;
const
workers
=
await
listWorkerTargets
(
args
)
;
const
processes
=
await
listProcessTargets
(
args
)
;
await
attachTargets
(
[
currentTopLevelTarget
.
.
.
workers
.
.
.
processes
]
args
)
;
}
