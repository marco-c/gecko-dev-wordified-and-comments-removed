import
{
setupCommands
clientCommands
}
from
"
.
/
firefox
/
commands
"
;
import
{
setupCreate
createPause
}
from
"
.
/
firefox
/
create
"
;
import
{
features
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
recordEvent
}
from
"
.
.
/
utils
/
telemetry
"
;
import
sourceQueue
from
"
.
.
/
utils
/
source
-
queue
"
;
let
actions
;
let
commands
;
let
targetCommand
;
let
resourceCommand
;
export
async
function
onConnect
(
_commands
_resourceCommand
_actions
store
)
{
actions
=
_actions
;
commands
=
_commands
;
targetCommand
=
_commands
.
targetCommand
;
resourceCommand
=
_resourceCommand
;
setupCommands
(
commands
)
;
setupCreate
(
{
store
}
)
;
sourceQueue
.
initialize
(
actions
)
;
const
{
descriptorFront
}
=
commands
;
const
{
targetFront
}
=
targetCommand
;
if
(
descriptorFront
.
isTabDescriptor
|
|
descriptorFront
.
isWebExtensionDescriptor
|
|
descriptorFront
.
isBrowserProcessDescriptor
)
{
targetCommand
.
listenForWorkers
=
true
;
if
(
descriptorFront
.
isLocalTab
&
&
features
.
windowlessServiceWorkers
)
{
targetCommand
.
listenForServiceWorkers
=
true
;
targetCommand
.
destroyServiceWorkersOnNavigation
=
true
;
}
await
targetCommand
.
startListening
(
)
;
}
const
options
=
{
pauseWorkersUntilAttach
:
true
}
;
await
commands
.
threadConfigurationCommand
.
updateConfiguration
(
options
)
;
await
actions
.
connect
(
targetFront
.
url
targetFront
.
threadFront
.
actor
targetFront
.
isWebExtension
)
;
await
targetCommand
.
watchTargets
(
{
types
:
targetCommand
.
ALL_TYPES
onAvailable
:
onTargetAvailable
onDestroyed
:
onTargetDestroyed
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
THREAD_STATE
]
{
onAvailable
:
onThreadStateAvailable
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
ERROR_MESSAGE
]
{
onAvailable
:
actions
.
addExceptionFromResources
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
onDocumentEventAvailable
ignoreExistingResources
:
true
}
)
;
}
export
function
onDisconnect
(
)
{
targetCommand
.
unwatchTargets
(
{
types
:
targetCommand
.
ALL_TYPES
onAvailable
:
onTargetAvailable
onDestroyed
:
onTargetDestroyed
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
THREAD_STATE
]
{
onAvailable
:
onThreadStateAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
ERROR_MESSAGE
]
{
onAvailable
:
actions
.
addExceptionFromResources
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
onDocumentEventAvailable
}
)
;
sourceQueue
.
clear
(
)
;
}
async
function
onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
{
const
isBrowserToolbox
=
commands
.
descriptorFront
.
isBrowserProcessDescriptor
;
const
isNonTopLevelFrameTarget
=
!
targetFront
.
isTopLevel
&
&
targetFront
.
targetType
=
=
=
targetCommand
.
TYPES
.
FRAME
;
if
(
isBrowserToolbox
&
&
isNonTopLevelFrameTarget
)
{
return
;
}
if
(
!
targetFront
.
isTopLevel
)
{
await
actions
.
addTarget
(
targetFront
)
;
return
;
}
const
{
threadFront
}
=
targetFront
;
if
(
!
threadFront
)
{
console
.
error
(
"
The
thread
for
"
targetFront
"
isn
'
t
attached
.
"
)
;
return
;
}
actions
.
getEventListenerBreakpointTypes
(
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
actions
.
addEventListenerBreakpoints
(
[
]
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
await
actions
.
addTarget
(
targetFront
)
;
}
function
onTargetDestroyed
(
{
targetFront
}
)
{
actions
.
removeTarget
(
targetFront
)
;
}
async
function
onSourceAvailable
(
sources
)
{
await
actions
.
newGeneratedSources
(
sources
)
;
}
async
function
onThreadStateAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
targetFront
.
isDestroyed
(
)
)
{
continue
;
}
const
threadFront
=
await
resource
.
targetFront
.
getFront
(
"
thread
"
)
;
if
(
resource
.
state
=
=
"
paused
"
)
{
const
pause
=
await
createPause
(
threadFront
.
actor
resource
)
;
await
actions
.
paused
(
pause
)
;
recordEvent
(
"
pause
"
{
reason
:
resource
.
why
.
type
}
)
;
}
else
if
(
resource
.
state
=
=
"
resumed
"
)
{
await
actions
.
resumed
(
threadFront
.
actorID
)
;
}
}
}
function
onDocumentEventAvailable
(
events
)
{
for
(
const
event
of
events
)
{
if
(
!
event
.
targetFront
.
isTopLevel
)
continue
;
if
(
event
.
name
=
=
"
will
-
navigate
"
)
{
actions
.
willNavigate
(
{
url
:
event
.
newURI
}
)
;
}
else
if
(
event
.
name
=
=
"
dom
-
complete
"
)
{
actions
.
navigated
(
)
;
}
}
}
export
{
clientCommands
}
;
