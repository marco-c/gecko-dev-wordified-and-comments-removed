import
{
setupCommands
clientCommands
}
from
"
.
/
firefox
/
commands
"
;
import
{
setupEvents
clientEvents
}
from
"
.
/
firefox
/
events
"
;
import
{
features
prefs
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
prepareSourcePayload
}
from
"
.
/
firefox
/
create
"
;
let
actions
;
let
targetList
;
let
resourceWatcher
;
export
async
function
onConnect
(
connection
:
any
_actions
:
Object
store
:
any
)
:
Promise
<
void
>
{
const
{
devToolsClient
targetList
:
_targetList
resourceWatcher
:
_resourceWatcher
}
=
connection
;
actions
=
_actions
;
targetList
=
_targetList
;
resourceWatcher
=
_resourceWatcher
;
setupCommands
(
{
devToolsClient
targetList
}
)
;
setupEvents
(
{
actions
devToolsClient
store
resourceWatcher
}
)
;
const
{
targetFront
}
=
targetList
;
if
(
targetFront
.
isBrowsingContext
|
|
targetFront
.
isParentProcess
)
{
targetList
.
listenForWorkers
=
true
;
if
(
targetFront
.
localTab
&
&
features
.
windowlessServiceWorkers
)
{
targetList
.
listenForServiceWorkers
=
true
;
targetList
.
destroyServiceWorkersOnNavigation
=
true
;
}
await
targetList
.
startListening
(
)
;
}
await
targetList
.
watchTargets
(
targetList
.
ALL_TYPES
onTargetAvailable
onTargetDestroyed
)
;
await
resourceWatcher
.
watchResources
(
[
resourceWatcher
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
}
export
function
onDisconnect
(
)
{
targetList
.
unwatchTargets
(
targetList
.
ALL_TYPES
onTargetAvailable
onTargetDestroyed
)
;
resourceWatcher
.
unwatchResources
(
[
resourceWatcher
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
}
async
function
onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
:
Promise
<
void
>
{
const
isBrowserToolbox
=
targetList
.
targetFront
.
isParentProcess
;
const
isNonTopLevelFrameTarget
=
!
targetFront
.
isTopLevel
&
&
targetFront
.
targetType
=
=
=
targetList
.
TYPES
.
FRAME
;
if
(
isBrowserToolbox
&
&
isNonTopLevelFrameTarget
)
{
return
;
}
if
(
!
targetFront
.
isTopLevel
)
{
await
actions
.
addTarget
(
targetFront
)
;
return
;
}
if
(
isTargetSwitching
)
{
actions
.
willNavigate
(
{
url
:
targetFront
.
url
}
)
;
}
const
{
threadFront
}
=
targetFront
;
if
(
!
threadFront
)
{
console
.
error
(
"
The
thread
for
"
targetFront
"
isn
'
t
attached
.
"
)
;
return
;
}
targetFront
.
on
(
"
will
-
navigate
"
actions
.
willNavigate
)
;
targetFront
.
on
(
"
navigate
"
actions
.
navigated
)
;
await
threadFront
.
reconfigure
(
{
observeAsmJS
:
true
pauseWorkersUntilAttach
:
true
skipBreakpoints
:
prefs
.
skipPausing
logEventBreakpoints
:
prefs
.
logEventBreakpoints
}
)
;
actions
.
getEventListenerBreakpointTypes
(
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
actions
.
addEventListenerBreakpoints
(
[
]
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
const
{
traits
}
=
targetFront
;
await
actions
.
connect
(
targetFront
.
url
threadFront
.
actor
traits
targetFront
.
isWebExtension
)
;
await
clientCommands
.
checkIfAlreadyPaused
(
)
;
await
actions
.
addTarget
(
targetFront
)
;
}
function
onTargetDestroyed
(
{
targetFront
}
)
:
void
{
if
(
targetFront
.
isTopLevel
)
{
targetFront
.
off
(
"
will
-
navigate
"
actions
.
willNavigate
)
;
targetFront
.
off
(
"
navigate
"
actions
.
navigated
)
;
}
actions
.
removeTarget
(
targetFront
)
;
}
async
function
onSourceAvailable
(
sources
)
{
const
frontendSources
=
await
Promise
.
all
(
sources
.
map
(
async
source
=
>
{
const
threadFront
=
await
source
.
targetFront
.
getFront
(
"
thread
"
)
;
const
frontendSource
=
prepareSourcePayload
(
threadFront
source
)
;
return
frontendSource
;
}
)
)
;
await
actions
.
newGeneratedSources
(
frontendSources
)
;
}
export
{
clientCommands
clientEvents
}
;
