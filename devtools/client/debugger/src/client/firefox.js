import
{
setupCommands
clientCommands
}
from
"
.
/
firefox
/
commands
"
;
import
{
setupCreate
createPause
}
from
"
.
/
firefox
/
create
"
;
import
{
prefs
features
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
recordEvent
}
from
"
.
.
/
utils
/
telemetry
"
;
import
sourceQueue
from
"
.
.
/
utils
/
source
-
queue
"
;
const
{
TRACER_LOG_METHODS
}
=
require
(
"
resource
:
/
/
devtools
/
shared
/
specs
/
tracer
.
js
"
)
;
const
{
AppConstants
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
)
;
const
{
PrefObserver
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
prefs
.
js
"
)
;
let
actions
;
let
commands
;
let
targetCommand
;
let
resourceCommand
;
let
prefObserver
;
export
async
function
onConnect
(
_commands
_resourceCommand
_actions
store
)
{
actions
=
_actions
;
commands
=
_commands
;
targetCommand
=
_commands
.
targetCommand
;
resourceCommand
=
_resourceCommand
;
setupCommands
(
commands
)
;
setupCreate
(
{
store
}
)
;
sourceQueue
.
initialize
(
actions
)
;
const
{
descriptorFront
}
=
commands
;
if
(
descriptorFront
.
isTabDescriptor
|
|
descriptorFront
.
isWebExtensionDescriptor
|
|
descriptorFront
.
isBrowserProcessDescriptor
)
{
targetCommand
.
listenForWorkers
=
true
;
if
(
descriptorFront
.
isLocalTab
&
&
features
.
windowlessServiceWorkers
)
{
targetCommand
.
listenForServiceWorkers
=
true
;
}
await
targetCommand
.
startListening
(
)
;
}
const
options
=
{
pauseWorkersUntilAttach
:
true
observeWasm
:
true
}
;
await
commands
.
threadConfigurationCommand
.
updateConfiguration
(
options
)
;
const
targetTypes
=
prefs
.
showContentScripts
?
targetCommand
.
ALL_TYPES
:
targetCommand
.
ALL_TYPES
.
filter
(
type
=
>
type
!
=
targetCommand
.
TYPES
.
CONTENT_SCRIPT
)
;
await
targetCommand
.
watchTargets
(
{
types
:
targetTypes
onAvailable
:
onTargetAvailable
onDestroyed
:
onTargetDestroyed
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
THREAD_STATE
]
{
onAvailable
:
onThreadStateAvailable
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
ERROR_MESSAGE
]
{
onAvailable
:
actions
.
addExceptionFromResources
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
onDocumentEventAvailable
ignoreExistingResources
:
true
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_STATE
]
{
onAvailable
:
onTracingStateAvailable
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_TRACE
]
{
onAvailable
:
actions
.
addTraces
}
)
;
commands
.
tracerCommand
.
on
(
"
toggle
"
onTracingToggled
)
;
if
(
!
commands
.
client
.
isLocalClient
)
{
const
localPlatformVersion
=
AppConstants
.
MOZ_APP_VERSION
;
const
remotePlatformVersion
=
await
getRemotePlatformVersion
(
)
;
actions
.
setLocalAndRemoteRuntimeVersion
(
localPlatformVersion
remotePlatformVersion
)
;
}
prefObserver
=
new
PrefObserver
(
"
devtools
.
debugger
.
show
-
content
-
scripts
"
)
;
prefObserver
.
on
(
"
devtools
.
debugger
.
show
-
content
-
scripts
"
onToggleContentScripts
)
;
}
async
function
onToggleContentScripts
(
)
{
if
(
!
prefs
.
showContentScripts
)
{
await
targetCommand
.
watchTargets
(
{
types
:
[
targetCommand
.
TYPES
.
CONTENT_SCRIPT
]
onAvailable
:
onTargetAvailable
onDestroyed
:
onTargetDestroyed
}
)
;
}
else
{
const
existingTargets
=
targetCommand
.
getAllTargets
(
[
targetCommand
.
TYPES
.
CONTENT_SCRIPT
]
)
;
for
(
const
targetFront
of
existingTargets
)
{
await
actions
.
removeTarget
(
targetFront
)
;
}
targetCommand
.
unwatchTargets
(
{
types
:
[
targetCommand
.
TYPES
.
CONTENT_SCRIPT
]
onAvailable
:
onTargetAvailable
onDestroyed
:
onTargetDestroyed
}
)
;
}
}
export
function
onDisconnect
(
)
{
targetCommand
.
unwatchTargets
(
{
types
:
targetCommand
.
ALL_TYPES
onAvailable
:
onTargetAvailable
onDestroyed
:
onTargetDestroyed
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
THREAD_STATE
]
{
onAvailable
:
onThreadStateAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_STATE
]
{
onAvailable
:
onTracingStateAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
ERROR_MESSAGE
]
{
onAvailable
:
actions
.
addExceptionFromResources
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
onDocumentEventAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_STATE
]
{
onAvailable
:
onTracingStateAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
JSTRACER_TRACE
]
{
onAvailable
:
actions
.
addTraces
}
)
;
commands
.
tracerCommand
.
off
(
"
toggle
"
onTracingToggled
)
;
sourceQueue
.
clear
(
)
;
prefObserver
.
destroy
(
)
;
}
async
function
onTargetAvailable
(
{
targetFront
}
)
{
const
isBrowserToolbox
=
commands
.
descriptorFront
.
isBrowserProcessDescriptor
;
const
isNonTopLevelFrameTarget
=
!
targetFront
.
isTopLevel
&
&
targetFront
.
targetType
=
=
=
targetCommand
.
TYPES
.
FRAME
;
if
(
isBrowserToolbox
&
&
isNonTopLevelFrameTarget
)
{
return
;
}
if
(
!
targetFront
.
isTopLevel
)
{
await
actions
.
addTarget
(
targetFront
)
;
return
;
}
const
{
threadFront
}
=
targetFront
;
if
(
!
threadFront
)
{
console
.
error
(
"
The
thread
for
"
targetFront
"
isn
'
t
attached
.
"
)
;
return
;
}
actions
.
getEventListenerBreakpointTypes
(
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
actions
.
addEventListenerBreakpoints
(
"
breakpoint
"
[
]
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
await
actions
.
addTarget
(
targetFront
)
;
}
async
function
onTargetDestroyed
(
{
targetFront
}
)
{
await
actions
.
removeTarget
(
targetFront
)
;
}
async
function
onSourceAvailable
(
sources
)
{
await
actions
.
newGeneratedSources
(
sources
)
;
}
async
function
onThreadStateAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
targetFront
.
isDestroyed
(
)
)
{
continue
;
}
const
threadFront
=
await
resource
.
targetFront
.
getFront
(
"
thread
"
)
;
if
(
resource
.
state
=
=
"
paused
"
)
{
const
pause
=
await
createPause
(
threadFront
.
actorID
resource
)
;
await
actions
.
paused
(
pause
)
;
recordEvent
(
"
pause
"
{
reason
:
resource
.
why
.
type
}
)
;
}
else
if
(
resource
.
state
=
=
"
resumed
"
)
{
await
actions
.
resumed
(
threadFront
.
actorID
)
;
}
}
}
async
function
onTracingStateAvailable
(
resources
)
{
for
(
const
resource
of
resources
)
{
if
(
resource
.
targetFront
.
isDestroyed
(
)
)
{
continue
;
}
if
(
resource
.
logMethod
!
=
TRACER_LOG_METHODS
.
DEBUGGER_SIDEBAR
)
{
continue
;
}
if
(
!
resource
.
targetFront
.
isTopLevel
)
{
continue
;
}
const
threadFront
=
await
resource
.
targetFront
.
getFront
(
"
thread
"
)
;
await
actions
.
tracingToggled
(
threadFront
.
actor
resource
.
enabled
resource
.
traceValues
)
;
}
}
async
function
onTracingToggled
(
)
{
const
{
tracerCommand
}
=
commands
;
if
(
!
tracerCommand
.
isTracingEnabled
)
{
return
;
}
actions
.
clearTracerData
(
)
;
}
function
onDocumentEventAvailable
(
events
)
{
for
(
const
event
of
events
)
{
if
(
!
event
.
targetFront
.
isTopLevel
)
{
continue
;
}
if
(
event
.
isFrameSwitching
&
&
!
commands
.
descriptorFront
.
isWebExtensionDescriptor
)
{
continue
;
}
if
(
event
.
name
=
=
"
will
-
navigate
"
)
{
actions
.
willNavigate
(
{
url
:
event
.
newURI
}
)
;
}
else
if
(
event
.
name
=
=
"
dom
-
complete
"
)
{
actions
.
navigated
(
)
;
}
}
}
async
function
getRemotePlatformVersion
(
)
{
const
deviceFront
=
await
commands
.
client
.
mainRoot
.
getFront
(
"
device
"
)
;
const
description
=
await
deviceFront
.
getDescription
(
)
;
return
description
.
platformversion
;
}
export
{
clientCommands
}
;
