import
{
setupCommands
clientCommands
}
from
"
.
/
firefox
/
commands
"
;
import
{
setupCreate
createPause
prepareSourcePayload
}
from
"
.
/
firefox
/
create
"
;
import
{
features
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
recordEvent
}
from
"
.
.
/
utils
/
telemetry
"
;
import
sourceQueue
from
"
.
.
/
utils
/
source
-
queue
"
;
let
actions
;
let
targetCommand
;
let
resourceCommand
;
let
commands
;
export
async
function
onConnect
(
_commands
_resourceCommand
_actions
store
)
{
actions
=
_actions
;
targetCommand
=
_commands
.
targetCommand
;
resourceCommand
=
_resourceCommand
;
commands
=
_commands
;
setupCommands
(
commands
)
;
setupCreate
(
{
store
}
)
;
sourceQueue
.
initialize
(
actions
)
;
const
{
targetFront
}
=
targetCommand
;
if
(
targetFront
.
isBrowsingContext
|
|
targetFront
.
isParentProcess
)
{
targetCommand
.
listenForWorkers
=
true
;
if
(
targetFront
.
localTab
&
&
features
.
windowlessServiceWorkers
)
{
targetCommand
.
listenForServiceWorkers
=
true
;
targetCommand
.
destroyServiceWorkersOnNavigation
=
true
;
}
await
targetCommand
.
startListening
(
)
;
}
const
options
=
{
pauseWorkersUntilAttach
:
true
}
;
await
commands
.
threadConfigurationCommand
.
updateConfiguration
(
options
)
;
await
actions
.
connect
(
targetFront
.
url
targetFront
.
threadFront
.
actor
targetFront
.
isWebExtension
)
;
await
targetCommand
.
watchTargets
(
targetCommand
.
ALL_TYPES
onTargetAvailable
onTargetDestroyed
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
THREAD_STATE
]
{
onAvailable
:
onBreakpointAvailable
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
ERROR_MESSAGE
]
{
onAvailable
:
actions
.
addExceptionFromResources
}
)
;
await
resourceCommand
.
watchResources
(
[
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
onDocumentEventAvailable
ignoreExistingResources
:
true
}
)
;
}
export
function
onDisconnect
(
)
{
targetCommand
.
unwatchTargets
(
targetCommand
.
ALL_TYPES
onTargetAvailable
onTargetDestroyed
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
SOURCE
]
{
onAvailable
:
onSourceAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
THREAD_STATE
]
{
onAvailable
:
onBreakpointAvailable
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
ERROR_MESSAGE
]
{
onAvailable
:
actions
.
addExceptionFromResources
}
)
;
resourceCommand
.
unwatchResources
(
[
resourceCommand
.
TYPES
.
DOCUMENT_EVENT
]
{
onAvailable
:
onDocumentEventAvailable
}
)
;
sourceQueue
.
clear
(
)
;
}
async
function
onTargetAvailable
(
{
targetFront
isTargetSwitching
}
)
{
const
isBrowserToolbox
=
targetCommand
.
targetFront
.
isParentProcess
;
const
isNonTopLevelFrameTarget
=
!
targetFront
.
isTopLevel
&
&
targetFront
.
targetType
=
=
=
targetCommand
.
TYPES
.
FRAME
;
if
(
isBrowserToolbox
&
&
isNonTopLevelFrameTarget
)
{
return
;
}
if
(
!
targetFront
.
isTopLevel
)
{
await
actions
.
addTarget
(
targetFront
)
;
return
;
}
const
{
threadFront
}
=
targetFront
;
if
(
!
threadFront
)
{
console
.
error
(
"
The
thread
for
"
targetFront
"
isn
'
t
attached
.
"
)
;
return
;
}
actions
.
getEventListenerBreakpointTypes
(
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
actions
.
addEventListenerBreakpoints
(
[
]
)
.
catch
(
e
=
>
console
.
error
(
e
)
)
;
await
actions
.
addTarget
(
targetFront
)
;
}
function
onTargetDestroyed
(
{
targetFront
}
)
{
actions
.
removeTarget
(
targetFront
)
;
}
async
function
onSourceAvailable
(
sources
)
{
const
frontendSources
=
await
Promise
.
all
(
sources
.
filter
(
source
=
>
{
return
!
source
.
targetFront
.
isDestroyed
(
)
;
}
)
.
map
(
async
source
=
>
{
const
threadFront
=
await
source
.
targetFront
.
getFront
(
"
thread
"
)
;
const
frontendSource
=
prepareSourcePayload
(
threadFront
source
)
;
return
frontendSource
;
}
)
)
;
await
actions
.
newGeneratedSources
(
frontendSources
)
;
}
async
function
onBreakpointAvailable
(
breakpoints
)
{
for
(
const
resource
of
breakpoints
)
{
const
threadFront
=
await
resource
.
targetFront
.
getFront
(
"
thread
"
)
;
if
(
resource
.
state
=
=
"
paused
"
)
{
const
pause
=
await
createPause
(
threadFront
.
actor
resource
)
;
actions
.
paused
(
pause
)
;
recordEvent
(
"
pause
"
{
reason
:
resource
.
why
.
type
}
)
;
}
else
if
(
resource
.
state
=
=
"
resumed
"
)
{
actions
.
resumed
(
threadFront
.
actorID
)
;
}
}
}
function
onDocumentEventAvailable
(
events
)
{
for
(
const
event
of
events
)
{
if
(
!
event
.
targetFront
.
isTopLevel
)
continue
;
if
(
event
.
name
=
=
"
will
-
navigate
"
)
{
actions
.
willNavigate
(
{
url
:
event
.
newURI
}
)
;
}
else
if
(
event
.
name
=
=
"
dom
-
complete
"
)
{
actions
.
navigated
(
)
;
}
}
}
export
{
clientCommands
}
;
