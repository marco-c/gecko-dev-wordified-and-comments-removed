import
{
objectInspector
}
from
"
devtools
/
client
/
shared
/
components
/
reps
/
index
"
;
import
{
simplifyDisplayName
}
from
"
.
.
/
pause
/
frames
/
index
"
;
const
{
utils
:
{
node
:
{
NODE_TYPES
}
}
}
=
objectInspector
;
function
_getScopeTitle
(
type
scope
)
{
if
(
type
=
=
=
"
block
"
&
&
scope
.
block
&
&
scope
.
block
.
displayName
)
{
return
scope
.
block
.
displayName
;
}
if
(
type
=
=
=
"
function
"
&
&
scope
.
function
)
{
return
scope
.
function
.
displayName
?
simplifyDisplayName
(
scope
.
function
.
displayName
)
:
L10N
.
getStr
(
"
anonymousFunction
"
)
;
}
return
L10N
.
getStr
(
"
scopes
.
block
"
)
;
}
function
_getThisVariable
(
this_
path
)
{
if
(
!
this_
)
{
return
null
;
}
return
{
name
:
"
<
this
>
"
path
:
{
path
}
/
<
this
>
contents
:
{
value
:
this_
}
}
;
}
function
_getBindingVariables
(
bindings
parentName
)
{
if
(
!
bindings
)
{
return
[
]
;
}
const
nodes
=
[
]
;
const
addNode
=
(
name
contents
)
=
>
nodes
.
push
(
{
name
contents
path
:
{
parentName
}
/
{
name
}
}
)
;
for
(
const
arg
of
bindings
.
arguments
)
{
const
[
name
contents
]
=
Object
.
entries
(
arg
)
[
0
]
;
addNode
(
name
contents
)
;
}
for
(
const
name
in
bindings
.
variables
)
{
addNode
(
name
bindings
.
variables
[
name
]
)
;
}
return
nodes
;
}
function
_getScopeItem
(
scope
selectedFrame
frameScopes
why
scopeIndex
)
{
const
{
type
actor
}
=
scope
;
const
isLocalScope
=
scope
.
actor
=
=
=
frameScopes
.
actor
;
const
key
=
{
actor
}
-
{
scopeIndex
}
;
if
(
type
=
=
=
"
function
"
|
|
type
=
=
=
"
block
"
)
{
const
{
bindings
}
=
scope
;
let
vars
=
_getBindingVariables
(
bindings
key
)
;
if
(
isLocalScope
)
{
vars
=
vars
.
concat
(
_getFrameExceptionOrReturnedValueVariables
(
why
key
)
)
;
let
thisDesc_
=
selectedFrame
.
this
;
if
(
bindings
&
&
"
this
"
in
bindings
)
{
thisDesc_
=
bindings
.
this
?
bindings
.
this
.
value
:
null
;
}
const
this_
=
_getThisVariable
(
thisDesc_
key
)
;
if
(
this_
)
{
vars
.
push
(
this_
)
;
}
}
if
(
vars
?
.
length
)
{
const
title
=
_getScopeTitle
(
type
scope
)
|
|
"
"
;
vars
.
sort
(
(
a
b
)
=
>
a
.
name
.
localeCompare
(
b
.
name
)
)
;
return
{
name
:
title
path
:
key
contents
:
vars
type
:
NODE_TYPES
.
BLOCK
}
;
}
}
else
if
(
type
=
=
=
"
object
"
&
&
scope
.
object
)
{
let
value
=
scope
.
object
;
if
(
value
.
class
=
=
=
"
Window
"
)
{
value
=
{
.
.
.
value
displayClass
:
"
Global
"
}
;
}
return
{
name
:
scope
.
object
.
class
path
:
key
contents
:
{
value
}
}
;
}
return
null
;
}
export
function
_mergeLexicalScopesBindings
(
scope
parentScope
item
parentItem
)
{
if
(
scope
.
scopeKind
=
=
"
function
lexical
"
&
&
parentScope
.
type
=
=
"
function
"
)
{
const
contents
=
item
.
contents
.
concat
(
parentItem
.
contents
)
;
contents
.
sort
(
(
a
b
)
=
>
a
.
name
.
localeCompare
(
b
.
name
)
)
;
return
{
name
:
parentItem
.
name
path
:
parentItem
.
path
contents
type
:
NODE_TYPES
.
BLOCK
}
;
}
return
null
;
}
export
function
getScopeItemPath
(
item
)
{
return
item
.
path
.
toString
(
)
;
}
function
_getFrameExceptionOrReturnedValueVariables
(
why
path
)
{
const
vars
=
[
]
;
if
(
why
&
&
why
.
frameFinished
)
{
const
{
frameFinished
}
=
why
;
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
frameFinished
"
throw
"
)
)
{
vars
.
push
(
{
name
:
"
<
exception
>
"
path
:
{
path
}
/
<
exception
>
contents
:
{
value
:
frameFinished
.
throw
}
}
)
;
}
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
frameFinished
"
return
"
)
)
{
const
returned
=
frameFinished
.
return
;
if
(
typeof
returned
!
=
=
"
object
"
|
|
returned
.
type
!
=
=
"
undefined
"
)
{
vars
.
push
(
{
name
:
"
<
return
>
"
path
:
{
path
}
/
<
return
>
contents
:
{
value
:
returned
}
}
)
;
}
}
}
return
vars
;
}
export
function
getScopesItemsForSelectedFrame
(
why
selectedFrame
frameScopes
)
{
if
(
!
why
|
|
!
selectedFrame
)
{
return
null
;
}
if
(
!
frameScopes
)
{
return
null
;
}
const
scopes
=
[
]
;
let
currentScope
=
frameScopes
;
let
currentScopeIndex
=
1
;
let
prevScope
=
null
prevScopeItem
=
null
;
while
(
currentScope
)
{
let
currentScopeItem
=
_getScopeItem
(
currentScope
selectedFrame
frameScopes
why
currentScopeIndex
)
;
if
(
currentScopeItem
)
{
const
mergedItem
=
prevScope
&
&
prevScopeItem
?
_mergeLexicalScopesBindings
(
prevScope
currentScope
prevScopeItem
currentScopeItem
)
:
null
;
if
(
mergedItem
)
{
currentScopeItem
=
mergedItem
;
scopes
.
pop
(
)
;
}
scopes
.
push
(
currentScopeItem
)
;
}
prevScope
=
currentScope
;
prevScopeItem
=
currentScopeItem
;
currentScopeIndex
+
+
;
currentScope
=
currentScope
.
parent
;
}
return
scopes
;
}
