import
{
positionCmp
}
from
"
.
/
positionCmp
"
;
import
{
filterSortedArray
}
from
"
.
/
filtering
"
;
import
{
mappingContains
}
from
"
.
/
mappingContains
"
;
import
{
getGeneratedLocation
}
from
"
.
.
/
.
.
/
.
.
/
source
-
maps
"
;
export
async
function
originalRangeStartsInside
(
{
start
end
}
thunkArgs
)
{
const
endPosition
=
await
getGeneratedLocation
(
end
thunkArgs
)
;
const
startPosition
=
await
getGeneratedLocation
(
start
thunkArgs
)
;
return
positionCmp
(
startPosition
endPosition
)
!
=
=
0
;
}
export
async
function
getApplicableBindingsForOriginalPosition
(
generatedAstBindings
source
{
start
end
}
bindingType
locationType
thunkArgs
)
{
const
{
sourceMapLoader
}
=
thunkArgs
;
const
ranges
=
await
sourceMapLoader
.
getGeneratedRanges
(
start
)
;
const
resultRanges
=
ranges
.
map
(
mapRange
=
>
(
{
start
:
{
line
:
mapRange
.
line
column
:
mapRange
.
columnStart
}
end
:
{
line
:
mapRange
.
line
column
:
mapRange
.
columnEnd
+
1
}
}
)
)
;
if
(
bindingType
=
=
=
"
import
"
&
&
locationType
!
=
=
"
ref
"
)
{
const
endPosition
=
await
getGeneratedLocation
(
end
thunkArgs
)
;
const
startPosition
=
await
getGeneratedLocation
(
start
thunkArgs
)
;
for
(
const
range
of
resultRanges
)
{
if
(
mappingContains
(
range
{
start
:
startPosition
end
:
startPosition
}
)
&
&
positionCmp
(
range
.
end
endPosition
)
<
0
)
{
range
.
end
=
{
line
:
endPosition
.
line
column
:
endPosition
.
column
}
;
break
;
}
}
}
return
filterApplicableBindings
(
generatedAstBindings
resultRanges
)
;
}
function
filterApplicableBindings
(
bindings
ranges
)
{
const
result
=
[
]
;
for
(
const
range
of
ranges
)
{
const
filteredBindings
=
filterSortedArray
(
bindings
binding
=
>
{
if
(
positionCmp
(
binding
.
loc
.
end
range
.
start
)
<
=
0
)
{
return
-
1
;
}
if
(
positionCmp
(
binding
.
loc
.
start
range
.
end
)
>
=
0
)
{
return
1
;
}
return
0
;
}
)
;
let
firstInRange
=
true
;
let
firstOnLine
=
true
;
let
line
=
-
1
;
for
(
const
binding
of
filteredBindings
)
{
if
(
binding
.
loc
.
start
.
line
=
=
=
line
)
{
firstOnLine
=
false
;
}
else
{
line
=
binding
.
loc
.
start
.
line
;
firstOnLine
=
true
;
}
result
.
push
(
{
binding
range
firstOnLine
firstInRange
}
)
;
firstInRange
=
false
;
}
}
return
result
;
}
