import
type
{
BindingLocationType
BindingType
}
from
"
.
.
/
.
.
/
.
.
/
workers
/
parser
"
;
import
{
positionCmp
}
from
"
.
/
positionCmp
"
;
import
{
filterSortedArray
}
from
"
.
/
filtering
"
;
import
{
mappingContains
}
from
"
.
/
mappingContains
"
;
import
type
{
Source
SourceLocation
PartialPosition
}
from
"
.
.
/
.
.
/
.
.
/
types
"
;
import
type
{
GeneratedBindingLocation
}
from
"
.
/
buildGeneratedBindingList
"
;
export
type
ApplicableBinding
=
{
binding
:
GeneratedBindingLocation
range
:
GeneratedRange
firstInRange
:
boolean
firstOnLine
:
boolean
}
;
type
GeneratedRange
=
{
start
:
PartialPosition
end
:
PartialPosition
}
;
export
async
function
originalRangeStartsInside
(
source
:
Source
{
start
end
}
:
{
start
:
SourceLocation
end
:
SourceLocation
}
sourceMaps
:
any
)
{
const
endPosition
=
await
sourceMaps
.
getGeneratedLocation
(
end
source
)
;
const
startPosition
=
await
sourceMaps
.
getGeneratedLocation
(
start
source
)
;
return
positionCmp
(
startPosition
endPosition
)
!
=
=
0
;
}
export
async
function
getApplicableBindingsForOriginalPosition
(
generatedAstBindings
:
Array
<
GeneratedBindingLocation
>
source
:
Source
{
start
end
}
:
{
start
:
SourceLocation
end
:
SourceLocation
}
bindingType
:
BindingType
locationType
:
BindingLocationType
sourceMaps
:
any
)
:
Promise
<
Array
<
ApplicableBinding
>
>
{
const
ranges
=
await
sourceMaps
.
getGeneratedRanges
(
start
source
)
;
const
resultRanges
=
ranges
.
map
(
mapRange
=
>
(
{
start
:
{
line
:
mapRange
.
line
column
:
mapRange
.
columnStart
}
end
:
{
line
:
mapRange
.
line
column
:
mapRange
.
columnEnd
+
1
}
}
)
)
;
if
(
bindingType
=
=
=
"
import
"
&
&
locationType
!
=
=
"
ref
"
)
{
const
endPosition
=
await
sourceMaps
.
getGeneratedLocation
(
end
source
)
;
const
startPosition
=
await
sourceMaps
.
getGeneratedLocation
(
start
source
)
;
for
(
const
range
of
resultRanges
)
{
if
(
mappingContains
(
range
{
start
:
startPosition
end
:
startPosition
}
)
&
&
positionCmp
(
range
.
end
endPosition
)
<
0
)
{
range
.
end
.
line
=
endPosition
.
line
;
range
.
end
.
column
=
endPosition
.
column
;
break
;
}
}
}
return
filterApplicableBindings
(
generatedAstBindings
resultRanges
)
;
}
function
filterApplicableBindings
(
bindings
:
Array
<
GeneratedBindingLocation
>
ranges
:
Array
<
GeneratedRange
>
)
:
Array
<
ApplicableBinding
>
{
const
result
=
[
]
;
for
(
const
range
of
ranges
)
{
const
filteredBindings
=
filterSortedArray
(
bindings
binding
=
>
{
if
(
positionCmp
(
binding
.
loc
.
end
range
.
start
)
<
=
0
)
{
return
-
1
;
}
if
(
positionCmp
(
binding
.
loc
.
start
range
.
end
)
>
=
0
)
{
return
1
;
}
return
0
;
}
)
;
let
firstInRange
=
true
;
let
firstOnLine
=
true
;
let
line
=
-
1
;
for
(
const
binding
of
filteredBindings
)
{
if
(
binding
.
loc
.
start
.
line
=
=
=
line
)
{
firstOnLine
=
false
;
}
else
{
line
=
binding
.
loc
.
start
.
line
;
firstOnLine
=
true
;
}
result
.
push
(
{
binding
range
firstOnLine
firstInRange
}
)
;
firstInRange
=
false
;
}
}
return
result
;
}
