import
typeof
SourceMaps
from
"
devtools
-
source
-
map
"
;
import
{
type
SourceScope
type
BindingData
type
BindingLocation
}
from
"
.
.
/
.
.
/
.
.
/
workers
/
parser
"
;
import
type
{
RenderableScope
}
from
"
.
.
/
scopes
/
getScope
"
;
import
{
locColumn
}
from
"
.
/
locColumn
"
;
import
{
loadRangeMetadata
findMatchingRange
type
MappedOriginalRange
}
from
"
.
/
rangeMetadata
"
;
import
{
findGeneratedReference
findGeneratedImportReference
findGeneratedImportDeclaration
type
GeneratedDescriptor
}
from
"
.
/
findGeneratedBindingFromPosition
"
;
import
{
buildGeneratedBindingList
type
GeneratedBindingLocation
}
from
"
.
/
buildGeneratedBindingList
"
;
import
{
originalRangeStartsInside
getApplicableBindingsForOriginalPosition
}
from
"
.
/
getApplicableBindingsForOriginalPosition
"
;
import
{
log
}
from
"
.
.
/
.
.
/
log
"
;
import
type
{
ThunkArgs
}
from
"
.
.
/
.
.
/
.
.
/
actions
/
types
"
;
import
type
{
PartialPosition
Frame
Scope
Source
SourceContent
BindingContents
ScopeBindings
}
from
"
.
.
/
.
.
/
.
.
/
types
"
;
export
type
OriginalScope
=
RenderableScope
;
export
async
function
buildMappedScopes
(
source
:
Source
content
:
SourceContent
frame
:
Frame
scopes
:
Scope
{
client
parser
sourceMaps
}
:
ThunkArgs
)
:
Promise
<
?
{
mappings
:
{
[
string
]
:
string
}
scope
:
OriginalScope
}
>
{
const
originalAstScopes
=
await
parser
.
getScopes
(
frame
.
location
)
;
const
generatedAstScopes
=
await
parser
.
getScopes
(
frame
.
generatedLocation
)
;
if
(
!
originalAstScopes
|
|
!
generatedAstScopes
)
{
return
null
;
}
const
originalRanges
=
await
loadRangeMetadata
(
source
frame
originalAstScopes
sourceMaps
)
;
if
(
hasLineMappings
(
originalRanges
)
)
{
return
null
;
}
const
generatedAstBindings
=
buildGeneratedBindingList
(
scopes
generatedAstScopes
frame
.
this
)
;
const
{
mappedOriginalScopes
expressionLookup
}
=
await
mapOriginalBindingsToGenerated
(
source
content
originalRanges
originalAstScopes
generatedAstBindings
client
sourceMaps
)
;
const
mappedGeneratedScopes
=
generateClientScope
(
scopes
mappedOriginalScopes
)
;
return
isReliableScope
(
mappedGeneratedScopes
)
?
{
mappings
:
expressionLookup
scope
:
mappedGeneratedScopes
}
:
null
;
}
async
function
mapOriginalBindingsToGenerated
(
source
:
Source
content
:
SourceContent
originalRanges
:
Array
<
MappedOriginalRange
>
originalAstScopes
generatedAstBindings
client
sourceMaps
)
{
const
expressionLookup
=
{
}
;
const
mappedOriginalScopes
=
[
]
;
const
cachedSourceMaps
=
batchScopeMappings
(
originalAstScopes
source
sourceMaps
)
;
for
(
const
item
of
originalAstScopes
)
{
const
generatedBindings
=
{
}
;
for
(
const
name
of
Object
.
keys
(
item
.
bindings
)
)
{
const
binding
=
item
.
bindings
[
name
]
;
const
result
=
await
findGeneratedBinding
(
cachedSourceMaps
client
source
content
name
binding
originalRanges
generatedAstBindings
)
;
if
(
result
)
{
generatedBindings
[
name
]
=
result
.
grip
;
if
(
binding
.
refs
.
length
!
=
=
0
&
&
!
Object
.
prototype
.
hasOwnProperty
.
call
(
expressionLookup
name
)
)
{
expressionLookup
[
name
]
=
result
.
expression
;
}
}
}
mappedOriginalScopes
.
push
(
{
.
.
.
item
generatedBindings
}
)
;
}
return
{
mappedOriginalScopes
expressionLookup
}
;
}
function
isReliableScope
(
scope
:
OriginalScope
)
:
boolean
{
let
totalBindings
=
0
;
let
unknownBindings
=
0
;
for
(
let
s
=
scope
;
s
;
s
=
s
.
parent
)
{
const
vars
=
(
s
.
bindings
&
&
s
.
bindings
.
variables
)
|
|
{
}
;
for
(
const
key
of
Object
.
keys
(
vars
)
)
{
const
binding
=
vars
[
key
]
;
totalBindings
+
=
1
;
if
(
binding
.
value
&
&
typeof
binding
.
value
=
=
=
"
object
"
&
&
(
binding
.
value
.
type
=
=
=
"
unscoped
"
|
|
binding
.
value
.
type
=
=
=
"
unmapped
"
)
)
{
unknownBindings
+
=
1
;
}
}
}
return
totalBindings
=
=
=
0
|
|
unknownBindings
/
totalBindings
<
0
.
25
;
}
function
hasLineMappings
(
ranges
)
{
return
ranges
.
every
(
range
=
>
range
.
columnStart
=
=
=
0
&
&
range
.
columnEnd
=
=
=
Infinity
)
;
}
function
batchScopeMappings
(
originalAstScopes
:
Array
<
SourceScope
>
source
:
Source
sourceMaps
:
SourceMaps
)
{
const
precalculatedRanges
=
new
Map
(
)
;
const
precalculatedLocations
=
new
Map
(
)
;
for
(
const
item
of
originalAstScopes
)
{
for
(
const
name
of
Object
.
keys
(
item
.
bindings
)
)
{
for
(
const
ref
of
item
.
bindings
[
name
]
.
refs
)
{
const
locs
=
[
ref
]
;
if
(
ref
.
type
!
=
=
"
ref
"
)
{
locs
.
push
(
ref
.
declaration
)
;
}
for
(
const
loc
of
locs
)
{
precalculatedRanges
.
set
(
buildLocationKey
(
loc
.
start
)
sourceMaps
.
getGeneratedRanges
(
loc
.
start
source
)
)
;
precalculatedLocations
.
set
(
buildLocationKey
(
loc
.
start
)
sourceMaps
.
getGeneratedLocation
(
loc
.
start
source
)
)
;
precalculatedLocations
.
set
(
buildLocationKey
(
loc
.
end
)
sourceMaps
.
getGeneratedLocation
(
loc
.
end
source
)
)
;
}
}
}
}
return
{
async
getGeneratedRanges
(
pos
s
)
{
const
key
=
buildLocationKey
(
pos
)
;
if
(
s
!
=
=
source
|
|
!
precalculatedRanges
.
has
(
key
)
)
{
log
(
"
Bad
precalculated
mapping
"
)
;
return
sourceMaps
.
getGeneratedRanges
(
pos
s
)
;
}
return
precalculatedRanges
.
get
(
key
)
;
}
async
getGeneratedLocation
(
pos
s
)
{
const
key
=
buildLocationKey
(
pos
)
;
if
(
s
!
=
=
source
|
|
!
precalculatedLocations
.
has
(
key
)
)
{
log
(
"
Bad
precalculated
mapping
"
)
;
return
sourceMaps
.
getGeneratedLocation
(
pos
s
)
;
}
return
precalculatedLocations
.
get
(
key
)
;
}
}
;
}
function
buildLocationKey
(
loc
:
PartialPosition
)
:
string
{
return
{
loc
.
line
}
:
{
locColumn
(
loc
)
}
;
}
function
generateClientScope
(
scopes
:
Scope
originalScopes
:
Array
<
SourceScope
&
{
generatedBindings
:
ScopeBindings
}
>
)
:
OriginalScope
{
let
globalLexicalScope
:
?
OriginalScope
=
null
;
for
(
let
s
=
scopes
;
s
.
parent
;
s
=
s
.
parent
)
{
globalLexicalScope
=
s
;
}
if
(
!
globalLexicalScope
)
{
throw
new
Error
(
"
Assertion
failure
-
there
should
always
be
a
scope
"
)
;
}
const
result
=
originalScopes
.
slice
(
0
-
2
)
.
reverse
(
)
.
reduce
(
(
acc
orig
i
)
:
OriginalScope
=
>
{
const
{
this
:
_this
.
.
.
variables
}
=
orig
.
generatedBindings
;
return
{
parent
:
acc
actor
:
originalActor
{
i
}
type
:
orig
.
type
scopeKind
:
orig
.
scopeKind
bindings
:
{
arguments
:
[
]
variables
}
.
.
.
(
orig
.
type
=
=
=
"
function
"
?
{
function
:
{
displayName
:
orig
.
displayName
}
}
:
null
)
.
.
.
(
orig
.
type
=
=
=
"
block
"
?
{
block
:
{
displayName
:
orig
.
displayName
}
}
:
null
)
}
;
}
globalLexicalScope
)
;
const
thisScope
=
originalScopes
.
find
(
scope
=
>
scope
.
bindings
.
this
)
;
if
(
result
.
bindings
&
&
thisScope
)
{
result
.
bindings
.
this
=
thisScope
.
generatedBindings
.
this
|
|
null
;
}
return
result
;
}
function
hasValidIdent
(
range
:
MappedOriginalRange
pos
:
BindingLocation
)
{
return
(
range
.
type
=
=
=
"
match
"
|
|
(
pos
.
type
!
=
=
"
ref
"
&
&
range
.
type
=
=
=
"
contains
"
)
)
;
}
async
function
findGeneratedBinding
(
sourceMaps
:
any
client
:
any
source
:
Source
content
:
SourceContent
name
:
string
originalBinding
:
BindingData
originalRanges
:
Array
<
MappedOriginalRange
>
generatedAstBindings
:
Array
<
GeneratedBindingLocation
>
)
:
Promise
<
?
{
grip
:
BindingContents
expression
:
string
|
null
}
>
{
if
(
originalBinding
.
type
=
=
=
"
implicit
"
&
&
!
originalBinding
.
refs
.
some
(
item
=
>
item
.
type
=
=
=
"
ref
"
)
)
{
return
null
;
}
const
loadApplicableBindings
=
async
(
pos
locationType
)
=
>
{
let
applicableBindings
=
await
getApplicableBindingsForOriginalPosition
(
generatedAstBindings
source
pos
originalBinding
.
type
locationType
sourceMaps
)
;
if
(
applicableBindings
.
length
>
0
)
{
hadApplicableBindings
=
true
;
}
if
(
locationType
=
=
=
"
ref
"
)
{
applicableBindings
=
applicableBindings
.
filter
(
(
{
range
}
)
=
>
!
(
range
.
start
.
column
=
=
=
0
&
&
range
.
end
.
column
=
=
=
Infinity
)
)
;
}
if
(
locationType
!
=
=
"
ref
"
&
&
!
(
await
originalRangeStartsInside
(
source
pos
sourceMaps
)
)
)
{
applicableBindings
=
[
]
;
}
return
applicableBindings
;
}
;
const
{
refs
}
=
originalBinding
;
let
hadApplicableBindings
=
false
;
let
genContent
:
GeneratedDescriptor
|
null
=
null
;
for
(
const
pos
of
refs
)
{
const
applicableBindings
=
await
loadApplicableBindings
(
pos
pos
.
type
)
;
const
range
=
findMatchingRange
(
originalRanges
pos
)
;
if
(
range
&
&
hasValidIdent
(
range
pos
)
)
{
if
(
originalBinding
.
type
=
=
=
"
import
"
)
{
genContent
=
await
findGeneratedImportReference
(
applicableBindings
)
;
}
else
{
genContent
=
await
findGeneratedReference
(
applicableBindings
)
;
}
}
if
(
(
pos
.
type
=
=
=
"
class
-
decl
"
|
|
pos
.
type
=
=
=
"
class
-
inner
"
)
&
&
content
.
contentType
&
&
content
.
contentType
.
match
(
/
\
/
typescript
/
)
)
{
const
declRange
=
findMatchingRange
(
originalRanges
pos
.
declaration
)
;
if
(
declRange
&
&
declRange
.
type
!
=
=
"
multiple
"
)
{
const
applicableDeclBindings
=
await
loadApplicableBindings
(
pos
.
declaration
pos
.
type
)
;
const
declContent
=
await
findGeneratedReference
(
applicableDeclBindings
)
;
if
(
declContent
)
{
genContent
=
declContent
;
}
}
}
if
(
!
genContent
&
&
pos
.
type
=
=
=
"
import
-
decl
"
&
&
typeof
pos
.
importName
=
=
=
"
string
"
)
{
const
{
importName
}
=
pos
;
const
declRange
=
findMatchingRange
(
originalRanges
pos
.
declaration
)
;
if
(
declRange
&
&
declRange
.
singleDeclaration
)
{
const
applicableDeclBindings
=
await
loadApplicableBindings
(
pos
.
declaration
pos
.
type
)
;
genContent
=
await
findGeneratedImportDeclaration
(
applicableDeclBindings
importName
)
;
}
}
if
(
genContent
)
{
break
;
}
}
if
(
genContent
&
&
genContent
.
desc
)
{
return
{
grip
:
genContent
.
desc
expression
:
genContent
.
expression
}
;
}
else
if
(
genContent
)
{
if
(
name
=
=
=
"
this
"
)
{
return
null
;
}
return
{
grip
:
{
configurable
:
false
enumerable
:
true
writable
:
false
value
:
{
type
:
"
unscoped
"
unscoped
:
true
missingArguments
:
true
}
}
expression
:
null
}
;
}
else
if
(
!
hadApplicableBindings
&
&
name
!
=
=
"
this
"
)
{
return
{
grip
:
{
configurable
:
false
enumerable
:
true
writable
:
false
value
:
{
type
:
"
null
"
optimizedOut
:
true
}
}
expression
:
(
(
)
=
>
{
throw
new
Error
(
'
"
'
+
{
JSON
.
stringify
(
name
)
}
+
'
"
has
been
optimized
out
.
'
)
;
}
)
(
)
}
;
}
return
{
grip
:
{
configurable
:
false
enumerable
:
true
writable
:
false
value
:
{
type
:
"
unmapped
"
unmapped
:
true
missingArguments
:
true
}
}
expression
:
null
}
;
}
