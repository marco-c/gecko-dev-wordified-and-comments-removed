import
buildQuery
from
"
.
.
/
build
-
query
"
;
import
type
{
SearchModifiers
}
from
"
.
.
/
.
.
/
types
"
;
function
getSearchCursor
(
cm
query
:
string
pos
modifiers
:
SearchModifiers
)
{
const
regexQuery
=
buildQuery
(
query
modifiers
{
isGlobal
:
true
}
)
;
return
cm
.
getSearchCursor
(
regexQuery
pos
)
;
}
function
SearchState
(
)
:
void
{
this
.
posFrom
=
this
.
posTo
=
this
.
query
=
null
;
this
.
overlay
=
null
;
this
.
results
=
[
]
;
}
function
getSearchState
(
cm
:
any
query
:
string
)
{
const
state
=
cm
.
state
.
search
|
|
(
cm
.
state
.
search
=
new
SearchState
(
)
)
;
return
state
;
}
function
isWhitespace
(
query
)
:
boolean
{
return
!
query
.
match
(
/
\
S
/
)
;
}
function
searchOverlay
(
query
modifiers
)
{
const
regexQuery
=
buildQuery
(
query
modifiers
{
ignoreSpaces
:
true
isGlobal
:
true
}
)
;
return
{
token
:
function
(
stream
state
)
{
regexQuery
.
lastIndex
=
stream
.
pos
;
const
match
=
regexQuery
.
exec
(
stream
.
string
)
;
if
(
match
&
&
match
.
index
=
=
=
stream
.
pos
)
{
stream
.
pos
+
=
match
[
0
]
.
length
|
|
1
;
return
"
highlight
highlight
-
full
"
;
}
else
if
(
match
)
{
stream
.
pos
=
match
.
index
;
}
else
{
stream
.
skipToEnd
(
)
;
}
}
}
;
}
function
updateOverlay
(
cm
state
query
modifiers
)
:
void
{
cm
.
removeOverlay
(
state
.
overlay
)
;
state
.
overlay
=
searchOverlay
(
query
modifiers
)
;
cm
.
addOverlay
(
state
.
overlay
{
opaque
:
false
}
)
;
}
function
updateCursor
(
cm
state
keepSelection
)
:
void
{
state
.
posTo
=
cm
.
getCursor
(
"
anchor
"
)
;
state
.
posFrom
=
cm
.
getCursor
(
"
head
"
)
;
if
(
!
keepSelection
)
{
state
.
posTo
=
{
line
:
0
ch
:
0
}
;
state
.
posFrom
=
{
line
:
0
ch
:
0
}
;
}
}
export
function
getMatchIndex
(
count
:
number
currentIndex
:
number
rev
:
boolean
)
:
number
{
if
(
!
rev
)
{
if
(
currentIndex
=
=
count
-
1
)
{
return
0
;
}
return
currentIndex
+
1
;
}
if
(
currentIndex
=
=
0
)
{
return
count
-
1
;
}
return
currentIndex
-
1
;
}
function
doSearch
(
ctx
rev
query
keepSelection
modifiers
:
SearchModifiers
focusFirstResult
?
:
boolean
=
true
)
{
const
{
cm
ed
}
=
ctx
;
if
(
!
cm
)
{
return
;
}
const
defaultIndex
=
{
line
:
-
1
ch
:
-
1
}
;
return
cm
.
operation
(
function
(
)
{
if
(
!
query
|
|
isWhitespace
(
query
)
)
{
clearSearch
(
cm
query
)
;
return
;
}
const
state
=
getSearchState
(
cm
query
)
;
const
isNewQuery
=
state
.
query
!
=
=
query
;
state
.
query
=
query
;
updateOverlay
(
cm
state
query
modifiers
)
;
updateCursor
(
cm
state
keepSelection
)
;
const
searchLocation
=
searchNext
(
ctx
rev
query
isNewQuery
modifiers
)
;
if
(
!
cm
.
state
.
selectingText
&
&
searchLocation
&
&
focusFirstResult
)
{
ed
.
alignLine
(
searchLocation
.
from
.
line
"
center
"
)
;
cm
.
setSelection
(
searchLocation
.
from
searchLocation
.
to
)
;
}
return
searchLocation
?
searchLocation
.
from
:
defaultIndex
;
}
)
;
}
export
function
searchSourceForHighlight
(
ctx
:
Object
rev
:
boolean
query
:
string
keepSelection
:
boolean
modifiers
:
SearchModifiers
line
:
number
ch
:
number
)
{
const
{
cm
}
=
ctx
;
if
(
!
cm
)
{
return
;
}
return
cm
.
operation
(
function
(
)
{
const
state
=
getSearchState
(
cm
query
)
;
const
isNewQuery
=
state
.
query
!
=
=
query
;
state
.
query
=
query
;
updateOverlay
(
cm
state
query
modifiers
)
;
updateCursor
(
cm
state
keepSelection
)
;
findNextOnLine
(
ctx
rev
query
isNewQuery
modifiers
line
ch
)
;
}
)
;
}
function
getCursorPos
(
newQuery
rev
state
)
{
if
(
newQuery
)
{
return
rev
?
state
.
posFrom
:
state
.
posTo
;
}
return
rev
?
state
.
posTo
:
state
.
posFrom
;
}
function
searchNext
(
ctx
rev
query
newQuery
modifiers
)
{
const
{
cm
}
=
ctx
;
let
nextMatch
;
cm
.
operation
(
function
(
)
{
const
state
=
getSearchState
(
cm
query
)
;
const
pos
=
getCursorPos
(
newQuery
rev
state
)
;
if
(
!
state
.
query
)
{
return
;
}
let
cursor
=
getSearchCursor
(
cm
state
.
query
pos
modifiers
)
;
const
location
=
rev
?
{
line
:
cm
.
lastLine
(
)
ch
:
null
}
:
{
line
:
cm
.
firstLine
(
)
ch
:
0
}
;
if
(
!
cursor
.
find
(
rev
)
&
&
state
.
query
)
{
cursor
=
getSearchCursor
(
cm
state
.
query
location
modifiers
)
;
if
(
!
cursor
.
find
(
rev
)
)
{
return
;
}
}
nextMatch
=
{
from
:
cursor
.
from
(
)
to
:
cursor
.
to
(
)
}
;
}
)
;
return
nextMatch
;
}
function
findNextOnLine
(
ctx
rev
query
newQuery
modifiers
line
ch
)
:
void
{
const
{
cm
ed
}
=
ctx
;
cm
.
operation
(
function
(
)
{
const
pos
=
{
line
:
line
-
1
ch
}
;
let
cursor
=
getSearchCursor
(
cm
query
pos
modifiers
)
;
if
(
!
cursor
.
find
(
rev
)
&
&
query
)
{
cursor
=
getSearchCursor
(
cm
query
pos
modifiers
)
;
if
(
!
cursor
.
find
(
rev
)
)
{
return
;
}
}
if
(
!
cm
.
state
.
selectingText
)
{
ed
.
alignLine
(
cursor
.
from
(
)
.
line
"
center
"
)
;
cm
.
setSelection
(
cursor
.
from
(
)
cursor
.
to
(
)
)
;
}
}
)
;
}
export
function
removeOverlay
(
ctx
:
any
query
:
string
)
:
void
{
const
state
=
getSearchState
(
ctx
.
cm
query
)
;
ctx
.
cm
.
removeOverlay
(
state
.
overlay
)
;
const
{
line
ch
}
=
ctx
.
cm
.
getCursor
(
)
;
ctx
.
cm
.
doc
.
setSelection
(
{
line
ch
}
{
line
ch
}
{
scroll
:
false
}
)
;
}
export
function
clearSearch
(
cm
:
any
query
:
string
)
:
void
{
const
state
=
getSearchState
(
cm
query
)
;
state
.
results
=
[
]
;
if
(
!
state
.
query
)
{
return
;
}
cm
.
removeOverlay
(
state
.
overlay
)
;
state
.
query
=
null
;
}
export
function
find
(
ctx
:
any
query
:
string
keepSelection
:
boolean
modifiers
:
SearchModifiers
focusFirstResult
?
:
boolean
)
{
clearSearch
(
ctx
.
cm
query
)
;
return
doSearch
(
ctx
false
query
keepSelection
modifiers
focusFirstResult
)
;
}
export
function
findNext
(
ctx
:
any
query
:
string
keepSelection
:
boolean
modifiers
:
SearchModifiers
)
{
return
doSearch
(
ctx
false
query
keepSelection
modifiers
)
;
}
export
function
findPrev
(
ctx
:
any
query
:
string
keepSelection
:
boolean
modifiers
:
SearchModifiers
)
{
return
doSearch
(
ctx
true
query
keepSelection
modifiers
)
;
}
export
{
buildQuery
}
;
