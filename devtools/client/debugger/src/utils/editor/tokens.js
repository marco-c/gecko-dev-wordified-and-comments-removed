import
{
features
}
from
"
.
.
/
prefs
"
;
function
_isInvalidTarget
(
target
)
{
if
(
!
target
|
|
!
target
.
innerText
)
{
return
true
;
}
const
tokenText
=
target
.
innerText
.
trim
(
)
;
const
invalidToken
=
tokenText
=
=
=
"
"
|
|
tokenText
.
match
(
/
^
[
(
)
{
}
\
|
&
%
.
;
=
<
>
\
+
-
/
\
*
\
s
]
(
?
=
)
/
)
;
if
(
invalidToken
)
{
return
true
;
}
const
INVALID_TARGET_CLASSES
=
[
"
cm
-
atom
"
"
cm
-
number
"
"
cm
-
operator
"
"
cm
-
string
"
"
cm
-
tag
"
"
tok
-
string
"
"
tok
-
punctuation
"
"
tok
-
number
"
"
tok
-
operator
"
"
editor
-
mount
"
]
;
if
(
target
.
className
=
=
=
"
"
|
|
INVALID_TARGET_CLASSES
.
some
(
cls
=
>
target
.
classList
.
contains
(
cls
)
)
)
{
return
true
;
}
if
(
(
target
.
classList
.
contains
(
"
cm
-
keyword
"
)
|
|
target
.
classList
.
contains
(
"
tok
-
keyword
"
)
)
&
&
tokenText
!
=
=
"
this
"
)
{
return
true
;
}
if
(
target
.
closest
(
"
.
CodeMirror
-
widget
"
)
|
|
target
.
closest
(
"
.
inline
-
preview
"
)
|
|
target
.
matches
(
"
.
CodeMirror
-
line
.
CodeMirror
-
gutter
-
elt
"
)
|
|
(
!
target
.
closest
(
"
.
CodeMirror
-
line
"
)
&
&
!
target
.
closest
(
"
.
cm
-
line
"
)
)
|
|
target
.
getBoundingClientRect
(
)
.
top
=
=
0
|
|
target
.
classList
.
contains
(
"
cm
-
line
"
)
)
{
return
true
;
}
if
(
target
.
closest
(
"
.
popover
"
)
)
{
return
true
;
}
return
false
;
}
function
_dispatch
(
codeMirrorOrSourceEditor
eventName
data
)
{
if
(
features
.
codemirrorNext
)
{
codeMirrorOrSourceEditor
.
emit
(
eventName
data
)
;
}
else
{
codeMirrorOrSourceEditor
.
constructor
.
signal
(
codeMirrorOrSourceEditor
eventName
data
)
;
}
}
function
_invalidLeaveTarget
(
target
)
{
if
(
!
target
|
|
target
.
closest
(
"
.
popover
"
)
)
{
return
true
;
}
return
false
;
}
export
function
onMouseOver
(
codeMirrorOrEditor
)
{
let
prevTokenPos
=
null
;
function
onMouseLeave
(
event
)
{
if
(
_invalidLeaveTarget
(
event
.
relatedTarget
)
)
{
addMouseLeave
(
event
.
target
)
;
return
;
}
prevTokenPos
=
null
;
_dispatch
(
codeMirrorOrEditor
"
tokenleave
"
event
)
;
}
function
addMouseLeave
(
target
)
{
target
.
addEventListener
(
"
mouseleave
"
onMouseLeave
{
capture
:
true
once
:
true
}
)
;
}
return
(
enterEvent
cm
cursorLine
cursorColumn
eventLine
eventColumn
)
=
>
{
const
{
target
}
=
enterEvent
;
if
(
_isInvalidTarget
(
target
)
)
{
return
;
}
let
tokenPos
;
if
(
features
.
codemirrorNext
)
{
tokenPos
=
{
line
:
eventLine
column
:
eventColumn
}
;
}
else
{
tokenPos
=
getTokenLocation
(
codeMirrorOrEditor
target
)
;
}
if
(
prevTokenPos
?
.
line
!
=
=
tokenPos
?
.
line
|
|
prevTokenPos
?
.
column
!
=
=
tokenPos
?
.
column
)
{
addMouseLeave
(
target
)
;
_dispatch
(
codeMirrorOrEditor
"
tokenenter
"
{
event
:
enterEvent
target
tokenPos
}
)
;
prevTokenPos
=
tokenPos
;
}
}
;
}
export
function
getTokenEnd
(
codeMirror
line
column
)
{
const
token
=
codeMirror
.
getTokenAt
(
{
line
ch
:
column
+
1
}
)
;
const
tokenString
=
token
.
string
;
return
tokenString
=
=
=
"
{
"
|
|
tokenString
=
=
=
"
[
"
?
null
:
token
.
end
;
}
export
function
getTokenLocation
(
codeMirror
tokenEl
)
{
const
{
p1
p2
p3
}
=
tokenEl
.
getBoxQuads
(
)
[
0
]
;
const
left
=
p1
.
x
+
(
p2
.
x
-
p1
.
x
)
/
2
;
const
top
=
p1
.
y
+
(
p3
.
y
-
p1
.
y
)
/
2
;
const
{
line
ch
}
=
codeMirror
.
coordsChar
(
{
left
top
}
"
window
"
)
;
return
{
line
:
line
+
1
column
:
ch
}
;
}
