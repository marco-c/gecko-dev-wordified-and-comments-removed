import
{
nodeHasChildren
isPathDirectory
isInvalidUrl
partIsFile
createSourceNode
createDirectoryNode
}
from
"
.
/
utils
"
;
import
{
createTreeNodeMatcher
findNodeInContents
}
from
"
.
/
treeOrder
"
;
import
{
getURL
}
from
"
.
/
getURL
"
;
import
type
{
ParsedURL
}
from
"
.
/
getURL
"
;
import
type
{
TreeDirectory
TreeNode
}
from
"
.
/
types
"
;
import
type
{
Source
}
from
"
.
.
/
.
.
/
types
"
;
function
createNodeInTree
(
part
:
string
path
:
string
tree
:
TreeDirectory
index
:
number
)
:
TreeDirectory
{
const
node
=
createDirectoryNode
(
part
path
[
]
)
;
const
contents
=
tree
.
contents
.
slice
(
0
)
;
contents
.
splice
(
index
0
node
)
;
tree
.
contents
=
contents
;
return
node
;
}
function
findOrCreateNode
(
parts
:
string
[
]
subTree
:
TreeDirectory
path
:
string
part
:
string
index
:
number
url
:
Object
debuggeeHost
:
?
string
source
:
Source
)
:
TreeDirectory
{
const
addedPartIsFile
=
partIsFile
(
index
parts
url
)
;
const
{
found
:
childFound
index
:
childIndex
}
=
findNodeInContents
(
subTree
createTreeNodeMatcher
(
part
!
addedPartIsFile
debuggeeHost
)
)
;
if
(
!
childFound
)
{
return
createNodeInTree
(
part
path
subTree
childIndex
)
;
}
const
child
=
subTree
.
contents
[
childIndex
]
;
const
childIsFile
=
!
nodeHasChildren
(
child
)
;
if
(
child
.
type
=
=
=
"
source
"
|
|
(
!
childIsFile
&
&
addedPartIsFile
)
)
{
const
{
index
:
insertIndex
}
=
findNodeInContents
(
subTree
createTreeNodeMatcher
(
part
!
addedPartIsFile
debuggeeHost
source
true
)
)
;
return
createNodeInTree
(
part
path
subTree
insertIndex
)
;
}
return
child
;
}
function
traverseTree
(
url
:
ParsedURL
tree
:
TreeDirectory
debuggeeHost
:
?
string
source
:
Source
thread
:
string
)
:
TreeNode
{
const
parts
=
url
.
path
.
replace
(
/
\
/
/
"
"
)
.
split
(
"
/
"
)
;
parts
[
0
]
=
url
.
group
;
if
(
thread
)
{
parts
.
unshift
(
thread
)
;
}
let
path
=
"
"
;
return
parts
.
reduce
(
(
subTree
part
index
)
=
>
{
if
(
index
=
=
0
&
&
thread
)
{
path
=
thread
;
}
else
{
path
=
{
path
}
/
{
part
}
;
}
const
debuggeeHostIfRoot
=
index
=
=
=
1
?
debuggeeHost
:
null
;
return
findOrCreateNode
(
parts
subTree
path
part
index
url
debuggeeHostIfRoot
source
)
;
}
tree
)
;
}
function
addSourceToNode
(
node
:
TreeDirectory
url
:
ParsedURL
source
:
Source
)
:
Source
|
TreeNode
[
]
{
const
isFile
=
!
isPathDirectory
(
url
.
path
)
;
if
(
node
.
type
=
=
"
source
"
)
{
throw
new
Error
(
Unexpected
type
"
source
"
at
:
{
node
.
name
}
)
;
}
if
(
isFile
)
{
node
.
type
=
"
source
"
;
return
source
;
}
const
{
filename
}
=
url
;
const
{
found
:
childFound
index
:
childIndex
}
=
findNodeInContents
(
node
createTreeNodeMatcher
(
filename
false
null
)
)
;
if
(
childFound
)
{
const
existingNode
=
node
.
contents
[
childIndex
]
;
if
(
existingNode
.
type
=
=
=
"
source
"
)
{
existingNode
.
contents
=
source
;
}
return
node
.
contents
;
}
const
newNode
=
createSourceNode
(
filename
source
.
url
source
)
;
const
contents
=
node
.
contents
.
slice
(
0
)
;
contents
.
splice
(
childIndex
0
newNode
)
;
return
contents
;
}
export
function
addToTree
(
tree
:
TreeDirectory
source
:
Source
debuggeeHost
:
?
string
thread
:
string
)
{
const
url
=
getURL
(
source
debuggeeHost
)
;
if
(
isInvalidUrl
(
url
source
)
)
{
return
;
}
const
finalNode
=
traverseTree
(
url
tree
debuggeeHost
source
thread
)
;
finalNode
.
contents
=
addSourceToNode
(
finalNode
url
source
)
;
}
