import
{
addToTree
}
from
"
.
/
addToTree
"
;
import
{
collapseTree
}
from
"
.
/
collapseTree
"
;
import
{
createDirectoryNode
createParentMap
getPathParts
isInvalidUrl
}
from
"
.
/
utils
"
;
import
{
getDomain
createTreeNodeMatcher
findNodeInContents
}
from
"
.
/
treeOrder
"
;
import
{
getDisplayURL
}
from
"
.
/
getURL
"
;
import
type
{
SourcesMapByThread
}
from
"
.
.
/
.
.
/
reducers
/
types
"
;
import
type
{
Thread
DisplaySource
URL
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
TreeDirectory
TreeSource
TreeNode
}
from
"
.
/
types
"
;
function
getSourcesDiff
(
newSources
prevSources
)
:
{
toAdd
:
Array
<
DisplaySource
>
toUpdate
:
Array
<
[
DisplaySource
DisplaySource
]
>
}
{
const
toAdd
=
[
]
;
const
toUpdate
=
[
]
;
for
(
const
sourceId
in
newSources
)
{
const
newSource
=
newSources
[
sourceId
]
;
const
prevSource
=
prevSources
?
prevSources
[
sourceId
]
:
null
;
if
(
!
prevSource
)
{
toAdd
.
push
(
newSource
)
;
}
else
if
(
prevSource
.
displayURL
!
=
=
newSource
.
displayURL
)
{
toUpdate
.
push
(
[
prevSource
newSource
]
)
;
}
}
return
{
toAdd
toUpdate
}
;
}
type
UpdateTreeParams
=
{
newSources
:
SourcesMapByThread
prevSources
:
SourcesMapByThread
uncollapsedTree
:
TreeDirectory
debuggeeUrl
:
URL
threads
:
Thread
[
]
sourceTree
?
:
TreeNode
}
;
type
CreateTreeParams
=
{
sources
:
SourcesMapByThread
debuggeeUrl
:
URL
threads
:
Thread
[
]
}
;
export
function
createTree
(
{
debuggeeUrl
sources
threads
}
:
CreateTreeParams
)
{
const
uncollapsedTree
=
createDirectoryNode
(
"
root
"
"
"
[
]
)
;
const
result
=
updateTree
(
{
debuggeeUrl
newSources
:
sources
prevSources
:
{
}
threads
uncollapsedTree
}
)
;
if
(
!
result
)
{
throw
new
Error
(
"
Tree
must
exist
"
)
;
}
return
result
;
}
export
function
updateTree
(
{
newSources
prevSources
debuggeeUrl
uncollapsedTree
threads
create
sourceTree
}
:
UpdateTreeParams
)
{
const
debuggeeHost
=
getDomain
(
debuggeeUrl
)
;
const
contexts
=
(
Object
.
keys
(
newSources
)
:
any
)
;
let
shouldUpdate
=
!
sourceTree
;
for
(
const
context
of
contexts
)
{
const
thread
=
threads
.
find
(
t
=
>
t
.
actor
=
=
=
context
)
;
if
(
!
thread
)
{
continue
;
}
const
{
toAdd
toUpdate
}
=
getSourcesDiff
(
(
Object
.
values
(
newSources
[
context
]
)
:
any
)
prevSources
[
context
]
?
(
Object
.
values
(
prevSources
[
context
]
)
:
any
)
:
null
)
;
for
(
const
source
of
toAdd
)
{
shouldUpdate
=
true
;
addToTree
(
uncollapsedTree
source
debuggeeHost
thread
.
actor
)
;
}
for
(
const
[
prevSource
newSource
]
of
toUpdate
)
{
shouldUpdate
=
true
;
updateInTree
(
uncollapsedTree
prevSource
newSource
debuggeeHost
thread
.
actor
)
;
}
}
if
(
!
shouldUpdate
)
{
return
false
;
}
const
newSourceTree
=
collapseTree
(
uncollapsedTree
)
;
return
{
uncollapsedTree
sourceTree
:
newSourceTree
parentMap
:
createParentMap
(
newSourceTree
)
}
;
}
export
function
updateInTree
(
tree
:
TreeDirectory
prevSource
:
DisplaySource
newSource
:
DisplaySource
debuggeeHost
:
?
string
thread
:
string
)
:
void
{
const
newUrl
=
getDisplayURL
(
newSource
debuggeeHost
)
;
const
prevUrl
=
getDisplayURL
(
prevSource
debuggeeHost
)
;
const
prevEntries
=
findEntries
(
tree
prevUrl
prevSource
thread
debuggeeHost
)
;
if
(
!
prevEntries
)
{
return
;
}
if
(
!
isInvalidUrl
(
newUrl
newSource
)
)
{
const
parts
=
getPathParts
(
newUrl
thread
debuggeeHost
)
;
if
(
parts
.
length
=
=
=
prevEntries
.
length
)
{
let
match
=
true
;
for
(
let
i
=
0
;
i
<
parts
.
length
-
2
;
i
+
+
)
{
if
(
parts
[
i
]
.
path
!
=
=
prevEntries
[
i
+
1
]
.
node
.
path
)
{
match
=
false
;
break
;
}
}
if
(
match
)
{
const
{
node
index
}
=
prevEntries
.
pop
(
)
;
const
fileNode
:
TreeSource
=
(
node
.
contents
[
index
]
:
any
)
;
fileNode
.
name
=
parts
[
parts
.
length
-
1
]
.
part
;
fileNode
.
path
=
parts
[
parts
.
length
-
1
]
.
path
;
fileNode
.
contents
=
newSource
;
return
;
}
}
}
for
(
let
i
=
prevEntries
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
{
node
index
}
=
prevEntries
[
i
]
;
if
(
node
.
contents
.
length
>
1
|
|
(
i
=
=
=
0
&
&
thread
)
)
{
node
.
contents
.
splice
(
index
1
)
;
break
;
}
}
addToTree
(
tree
newSource
debuggeeHost
thread
)
;
}
type
Entry
=
{
node
:
TreeDirectory
index
:
number
}
;
function
findEntries
(
tree
url
source
thread
debuggeeHost
)
:
?
Array
<
Entry
>
{
const
parts
=
getPathParts
(
url
thread
debuggeeHost
)
;
parts
.
pop
(
)
;
const
entries
=
[
]
;
let
currentNode
=
tree
;
for
(
const
{
part
}
of
parts
)
{
const
{
found
:
childFound
index
:
childIndex
}
=
findNodeInContents
(
currentNode
createTreeNodeMatcher
(
part
true
debuggeeHost
)
)
;
if
(
!
childFound
|
|
currentNode
.
type
!
=
=
"
directory
"
)
{
return
null
;
}
entries
.
push
(
{
node
:
currentNode
index
:
childIndex
}
)
;
currentNode
=
currentNode
.
contents
[
childIndex
]
;
}
const
found
=
(
function
search
(
node
)
{
if
(
node
.
type
!
=
=
"
directory
"
)
{
if
(
node
.
contents
.
id
=
=
=
source
.
id
)
{
return
[
]
;
}
return
null
;
}
for
(
let
i
=
0
;
i
<
node
.
contents
.
length
;
i
+
+
)
{
const
child
=
node
.
contents
[
i
]
;
const
result
=
search
(
child
)
;
if
(
result
)
{
result
.
unshift
(
{
node
index
:
i
}
)
;
return
result
;
}
}
return
null
;
}
)
(
currentNode
)
;
return
found
?
[
.
.
.
entries
.
.
.
found
]
:
null
;
}
