import
{
parse
}
from
"
.
.
/
url
"
;
import
{
nodeHasChildren
}
from
"
.
/
utils
"
;
import
type
{
TreeNode
}
from
"
.
/
types
"
;
import
type
{
Source
}
from
"
.
.
/
.
.
/
types
"
;
export
function
getDomain
(
url
?
:
string
)
:
?
string
{
if
(
!
url
)
{
return
null
;
}
const
{
host
}
=
parse
(
url
)
;
if
(
!
host
)
{
return
null
;
}
return
host
.
startsWith
(
"
www
.
"
)
?
host
.
substr
(
"
www
.
"
.
length
)
:
host
;
}
function
isExactDomainMatch
(
part
:
string
debuggeeHost
:
string
)
:
boolean
{
return
part
.
startsWith
(
"
www
.
"
)
?
part
.
substr
(
"
www
.
"
.
length
)
=
=
=
debuggeeHost
:
part
=
=
=
debuggeeHost
;
}
function
isIndexName
(
part
:
string
.
.
.
rest
)
:
boolean
{
return
part
=
=
=
IndexName
;
}
export
type
FindNodeInContentsMatcher
=
(
node
:
TreeNode
)
=
>
number
;
export
function
findNodeInContents
(
tree
:
TreeNode
matcher
:
FindNodeInContentsMatcher
)
:
{
|
found
:
boolean
index
:
number
|
}
{
if
(
tree
.
type
=
=
=
"
source
"
|
|
tree
.
contents
.
length
=
=
=
0
)
{
return
{
found
:
false
index
:
0
}
;
}
let
left
=
0
;
let
right
=
tree
.
contents
.
length
-
1
;
while
(
left
<
right
)
{
const
middle
=
Math
.
floor
(
(
left
+
right
)
/
2
)
;
if
(
matcher
(
tree
.
contents
[
middle
]
)
<
0
)
{
left
=
middle
+
1
;
}
else
{
right
=
middle
;
}
}
const
result
=
matcher
(
tree
.
contents
[
left
]
)
;
if
(
result
=
=
=
0
)
{
return
{
found
:
true
index
:
left
}
;
}
return
{
found
:
false
index
:
result
>
0
?
left
:
left
+
1
}
;
}
const
IndexName
=
"
(
index
)
"
;
const
matcherFunctions
=
[
isIndexName
isExactDomainMatch
]
;
export
function
createTreeNodeMatcher
(
part
:
string
isDir
:
boolean
debuggeeHost
:
?
string
source
?
:
Source
sortByUrl
?
:
boolean
)
:
FindNodeInContentsMatcher
{
return
(
node
:
TreeNode
)
=
>
{
for
(
let
i
=
0
;
i
<
matcherFunctions
.
length
;
i
+
+
)
{
if
(
matcherFunctions
[
i
]
(
part
debuggeeHost
)
)
{
for
(
let
j
=
0
;
j
<
i
;
j
+
+
)
{
if
(
matcherFunctions
[
j
]
(
node
.
name
debuggeeHost
)
)
{
return
-
1
;
}
}
if
(
matcherFunctions
[
i
]
(
node
.
name
debuggeeHost
)
)
{
return
0
;
}
return
1
;
}
if
(
matcherFunctions
[
i
]
(
node
.
name
debuggeeHost
)
)
{
return
-
1
;
}
}
const
nodeIsDir
=
nodeHasChildren
(
node
)
;
if
(
nodeIsDir
&
&
!
isDir
)
{
return
-
1
;
}
else
if
(
!
nodeIsDir
&
&
isDir
)
{
return
1
;
}
if
(
sortByUrl
&
&
node
.
type
=
=
=
"
source
"
&
&
source
)
{
return
node
.
contents
.
url
.
localeCompare
(
source
.
url
)
;
}
if
(
isExactDomainMatch
(
part
node
.
name
)
)
{
return
0
;
}
return
node
.
name
.
localeCompare
(
part
)
;
}
;
}
