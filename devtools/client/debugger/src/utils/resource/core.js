type
PropertiesById
<
ID
T
>
=
Exact
<
ObjMap
<
T
<
V
>
(
v
:
V
)
=
>
{
[
ID
]
:
V
}
>
>
;
export
type
Resource
=
{
+
item
:
{
+
id
:
string
}
}
;
export
type
Value
<
R
:
Resource
K
:
Keys
<
R
>
>
=
ElementType
<
R
K
>
;
export
type
Item
<
R
:
Resource
>
=
Value
<
R
"
item
"
>
;
export
type
Id
<
R
:
Resource
>
=
ElementType
<
Item
<
R
>
"
id
"
>
;
export
type
Order
<
R
:
Resource
>
=
Array
<
Id
<
R
>
>
;
export
type
ReadOnlyOrder
<
R
:
Resource
>
=
ReadOnlyArray
<
Id
<
R
>
>
;
export
type
Fields
<
R
:
Resource
>
=
{
|
.
.
.
PropertiesById
<
Id
<
R
>
R
>
|
}
;
export
type
ReadOnlyFields
<
R
:
Resource
>
=
ReadOnly
<
Fields
<
R
>
>
;
export
type
MutableResource
<
R
:
Resource
>
=
Rest
<
R
{
item
:
ElementType
<
R
"
item
"
>
}
>
;
export
type
MutableFields
<
R
:
Resource
>
=
PropertiesById
<
Id
<
R
>
MutableResource
<
R
>
>
;
export
opaque
type
UnorderedState
<
R
:
Resource
>
=
{
fields
:
ReadOnlyFields
<
R
>
}
;
/
/
An
ordered
version
of
the
state
where
order
is
represented
/
/
as
an
array
alongside
the
item
lookup
so
that
reordering
items
/
/
does
not
need
to
affect
any
results
that
may
have
been
computed
/
/
over
the
items
as
a
whole
ignoring
sort
order
.
export
opaque
type
OrderedState
<
R
:
Resource
>
=
{
order
:
ReadOnlyOrder
<
R
>
fields
:
ReadOnlyFields
<
R
>
}
;
export
type
State
<
R
:
Resource
>
=
OrderedState
<
R
>
|
UnorderedState
<
R
>
;
/
*
*
*
Provide
the
default
Redux
state
for
an
unordered
store
.
*
/
export
function
createUnordered
<
R
:
Resource
>
(
fields
:
Fields
<
R
>
)
:
UnorderedState
<
R
>
{
if
(
Object
.
keys
(
fields
.
item
)
.
length
!
=
=
0
)
{
throw
new
Error
(
"
The
initial
'
fields
'
object
should
be
empty
.
"
)
;
}
return
{
fields
}
;
}
export
function
createOrdered
<
R
:
Resource
>
(
fields
:
Fields
<
R
>
)
:
OrderedState
<
R
>
{
if
(
Object
.
keys
(
fields
.
item
)
.
length
!
=
=
0
)
{
throw
new
Error
(
"
The
initial
'
fields
'
object
should
be
empty
.
"
)
;
}
return
{
order
:
[
]
fields
}
;
}
export
function
mutateState
<
R
:
Resource
S
:
State
<
R
>
T
>
(
state
:
S
arg
:
T
fieldsMutator
:
(
T
Fields
<
R
>
)
=
>
void
orderMutator
?
:
(
T
Order
<
R
>
)
=
>
Order
<
R
>
|
void
)
:
S
{
state
=
{
.
.
.
state
}
;
state
.
fields
=
{
.
.
.
state
.
fields
}
;
fieldsMutator
(
arg
state
.
fields
)
;
if
(
orderMutator
&
&
state
.
order
)
{
const
mutableOrder
=
state
.
order
.
slice
(
)
;
state
.
order
=
orderMutator
(
arg
mutableOrder
)
|
|
mutableOrder
;
}
return
state
;
}
export
function
getOrder
<
R
:
Resource
>
(
state
:
OrderedState
<
R
>
)
:
ReadOnlyOrder
<
R
>
{
return
state
.
order
;
}
export
function
getFields
<
R
:
Resource
>
(
state
:
State
<
R
>
)
:
ReadOnlyFields
<
R
>
{
return
state
.
fields
;
}
