import
{
getOrder
getFields
type
Resource
type
Id
type
Item
type
OrderedState
type
State
}
from
"
.
/
core
"
;
export
function
hasResource
<
R
:
Resource
>
(
state
:
State
<
R
>
id
:
Id
<
R
>
|
Item
<
R
>
)
:
boolean
{
if
(
typeof
id
!
=
=
"
string
"
)
{
id
=
id
.
id
;
}
return
Object
.
prototype
.
hasOwnProperty
.
call
(
getFields
(
state
)
.
item
id
)
;
}
export
function
getResource
<
R
:
Resource
>
(
state
:
State
<
R
>
id
:
Id
<
R
>
|
Item
<
R
>
)
:
R
{
if
(
typeof
id
!
=
=
"
string
"
)
{
id
=
id
.
id
;
}
if
(
!
hasResource
(
state
id
)
)
{
throw
new
Error
(
Resource
{
id
}
not
found
)
;
}
const
fields
=
getFields
(
state
)
;
/
/
We
have
to
do
some
typecasting
here
because
while
we
know
that
the
the
/
/
types
are
the
same
Flow
isn
'
t
quite
able
to
guarantee
that
the
returned
/
/
Resource
here
will
actually
match
the
type
.
const
resource
:
{
[
string
]
:
mixed
}
=
{
}
;
for
(
const
key
of
Object
.
keys
(
fields
)
)
{
resource
[
key
]
=
fields
[
key
]
[
id
]
;
}
return
(
resource
:
any
)
;
}
const
listCache
:
WeakMap
<
Array
<
mixed
>
Array
<
mixed
>
>
=
new
WeakMap
(
)
;
export
function
listItems
<
R
:
Resource
>
(
state
:
OrderedState
<
R
>
)
:
Array
<
Item
<
R
>
>
{
const
order
=
getOrder
(
state
)
;
let
items
:
Array
<
Item
<
R
>
>
|
void
=
(
listCache
.
get
(
(
order
:
any
)
)
:
any
)
;
if
(
!
items
)
{
items
=
order
.
map
(
id
=
>
getItem
(
state
id
)
)
;
listCache
.
set
(
(
order
:
any
)
(
items
:
any
)
)
;
}
return
items
;
}
export
function
getItem
<
R
:
Resource
>
(
state
:
State
<
R
>
id
:
Id
<
R
>
)
:
Item
<
R
>
{
if
(
!
hasResource
(
state
id
)
)
{
throw
new
Error
(
Resource
item
{
id
}
not
found
)
;
}
return
getFields
(
state
)
.
item
[
id
]
;
}
export
function
getFieldValue
<
R
:
Resource
K
:
Keys
<
R
>
>
(
state
:
State
<
R
>
field
:
K
id
:
Id
<
R
>
|
Item
<
R
>
)
:
ElementType
<
R
K
>
{
if
(
typeof
id
!
=
=
"
string
"
)
{
id
=
id
.
id
;
}
if
(
!
hasResource
(
state
id
)
)
{
throw
new
Error
(
Resource
item
{
id
}
not
found
)
;
}
const
fieldValues
=
getFields
(
state
)
[
field
]
;
if
(
!
fieldValues
)
{
throw
new
Error
(
Resource
corrupt
:
Field
"
{
field
}
"
not
found
)
;
}
return
fieldValues
[
id
]
;
}
