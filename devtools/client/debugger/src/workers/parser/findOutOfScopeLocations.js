import
{
containsLocation
containsPosition
}
from
"
.
/
utils
/
contains
"
;
import
{
getSymbols
}
from
"
.
/
getSymbols
"
;
function
findSymbols
(
source
)
{
const
{
functions
comments
}
=
getSymbols
(
source
)
;
return
{
functions
comments
}
;
}
function
getLocation
(
func
)
{
const
location
=
{
.
.
.
func
.
location
}
;
const
identifierEnd
=
func
?
.
identifier
?
.
loc
?
.
end
;
if
(
identifierEnd
)
{
location
.
start
=
identifierEnd
;
}
return
location
;
}
function
getInnerLocations
(
locations
position
)
{
let
parentIndex
;
for
(
let
i
=
locations
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
const
loc
=
locations
[
i
]
;
if
(
containsPosition
(
loc
position
)
)
{
parentIndex
=
i
;
break
;
}
}
if
(
parentIndex
=
=
undefined
)
{
return
[
]
;
}
const
parentLoc
=
locations
[
parentIndex
]
;
const
innerLocations
=
[
]
;
for
(
let
i
=
parentIndex
+
1
;
i
<
locations
.
length
;
i
+
+
)
{
const
loc
=
locations
[
i
]
;
if
(
!
containsLocation
(
parentLoc
loc
)
)
{
break
;
}
innerLocations
.
push
(
loc
)
;
}
return
innerLocations
;
}
function
removeOverlaps
(
locations
)
{
if
(
!
locations
.
length
)
{
return
[
]
;
}
const
firstParent
=
locations
[
0
]
;
return
locations
.
reduce
(
deduplicateNode
[
firstParent
]
)
;
}
function
deduplicateNode
(
nodes
location
)
{
const
parent
=
nodes
[
nodes
.
length
-
1
]
;
if
(
!
containsLocation
(
parent
location
)
)
{
nodes
.
push
(
location
)
;
}
return
nodes
;
}
function
sortByStart
(
a
b
)
{
if
(
a
.
start
.
line
<
b
.
start
.
line
)
{
return
-
1
;
}
else
if
(
a
.
start
.
line
=
=
=
b
.
start
.
line
)
{
return
a
.
start
.
column
-
b
.
start
.
column
;
}
return
1
;
}
function
findOutOfScopeLocations
(
sourceId
position
)
{
const
{
functions
comments
}
=
findSymbols
(
sourceId
)
;
const
commentLocations
=
comments
.
map
(
c
=
>
c
.
location
)
;
const
locations
=
functions
.
map
(
getLocation
)
.
concat
(
commentLocations
)
.
sort
(
sortByStart
)
;
const
innerLocations
=
getInnerLocations
(
locations
position
)
;
const
outerLocations
=
locations
.
filter
(
loc
=
>
{
if
(
innerLocations
.
includes
(
loc
)
)
{
return
false
;
}
return
!
containsPosition
(
loc
position
)
;
}
)
;
return
removeOverlaps
(
outerLocations
)
;
}
export
default
findOutOfScopeLocations
;
