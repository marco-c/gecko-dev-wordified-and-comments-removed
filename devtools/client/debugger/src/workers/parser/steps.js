import
*
as
t
from
"
babel
/
types
"
;
import
type
{
SimplePath
}
from
"
.
/
utils
/
simple
-
path
"
;
import
type
{
SourceLocation
SourceId
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
AstPosition
}
from
"
.
/
types
"
;
import
{
getClosestPath
}
from
"
.
/
utils
/
closest
"
;
import
{
isAwaitExpression
isYieldExpression
}
from
"
.
/
utils
/
helpers
"
;
export
function
getNextStep
(
sourceId
:
SourceId
pausedPosition
:
AstPosition
)
:
?
SourceLocation
{
const
currentExpression
=
getSteppableExpression
(
sourceId
pausedPosition
)
;
if
(
!
currentExpression
)
{
return
null
;
}
const
currentStatement
=
currentExpression
.
find
(
p
=
>
{
return
p
.
inList
&
&
t
.
isStatement
(
p
.
node
)
;
}
)
;
if
(
!
currentStatement
)
{
throw
new
Error
(
"
Assertion
failure
-
this
should
always
find
at
least
Program
"
)
;
}
return
_getNextStep
(
currentStatement
sourceId
pausedPosition
)
;
}
function
getSteppableExpression
(
sourceId
:
SourceId
pausedPosition
:
AstPosition
)
{
const
closestPath
=
getClosestPath
(
sourceId
pausedPosition
)
;
if
(
!
closestPath
)
{
return
null
;
}
if
(
isAwaitExpression
(
closestPath
)
|
|
isYieldExpression
(
closestPath
)
)
{
return
closestPath
;
}
return
closestPath
.
find
(
p
=
>
t
.
isAwaitExpression
(
p
.
node
)
|
|
t
.
isYieldExpression
(
p
.
node
)
)
;
}
function
_getNextStep
(
statement
:
SimplePath
sourceId
:
string
position
:
AstPosition
)
:
?
SourceLocation
{
const
nextStatement
=
statement
.
getSibling
(
1
)
;
if
(
nextStatement
)
{
return
{
.
.
.
nextStatement
.
node
.
loc
.
start
sourceId
:
sourceId
}
;
}
return
null
;
}
