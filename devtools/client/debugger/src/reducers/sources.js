import
{
createSelector
}
from
"
reselect
"
;
import
{
getPrettySourceURL
isDescendantOfRoot
getRelativeUrl
isGenerated
getPlainUrl
isPretty
isJavaScript
}
from
"
.
.
/
utils
/
source
"
;
import
{
createInitial
insertResources
updateResources
hasResource
getResource
getMappedResource
getResourceIds
memoizeResourceShallow
makeShallowQuery
makeReduceAllQuery
makeMapWithArgs
}
from
"
.
.
/
utils
/
resource
"
;
import
{
stripQuery
}
from
"
.
.
/
utils
/
url
"
;
import
{
findPosition
}
from
"
.
.
/
utils
/
breakpoint
/
breakpointPositions
"
;
import
{
pending
fulfilled
rejected
asSettled
isFulfilled
}
from
"
.
.
/
utils
/
async
-
value
"
;
import
{
originalToGeneratedId
}
from
"
devtools
-
source
-
map
"
;
import
{
prefs
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
hasSourceActor
getSourceActor
getSourceActors
getAllThreadsBySource
getBreakableLinesForSourceActors
}
from
"
.
/
source
-
actors
"
;
import
{
getAllThreads
}
from
"
.
.
/
selectors
/
threads
"
;
export
function
initialSourcesState
(
state
)
{
return
{
sources
:
createInitial
(
)
urls
:
{
}
plainUrls
:
{
}
sourcesWithUrls
:
[
]
actors
:
{
}
breakpointPositions
:
{
}
breakableLines
:
{
}
epoch
:
1
selectedLocation
:
undefined
pendingSelectedLocation
:
prefs
.
pendingSelectedLocation
projectDirectoryRoot
:
prefs
.
projectDirectoryRoot
projectDirectoryRootName
:
prefs
.
projectDirectoryRootName
chromeAndExtensionsEnabled
:
prefs
.
chromeAndExtensionsEnabled
blackboxedRanges
:
state
?
.
blackboxedRanges
?
?
{
}
}
;
}
function
update
(
state
=
initialSourcesState
(
)
action
)
{
let
location
=
null
;
switch
(
action
.
type
)
{
case
"
ADD_SOURCE
"
:
return
addSources
(
state
[
action
.
source
]
)
;
case
"
ADD_SOURCES
"
:
return
addSources
(
state
action
.
sources
)
;
case
"
INSERT_SOURCE_ACTORS
"
:
return
insertSourceActors
(
state
action
)
;
case
"
REMOVE_SOURCE_ACTORS
"
:
return
removeSourceActors
(
state
action
)
;
case
"
SET_SELECTED_LOCATION
"
:
location
=
{
.
.
.
action
.
location
url
:
action
.
source
.
url
}
;
if
(
action
.
source
.
url
)
{
prefs
.
pendingSelectedLocation
=
location
;
}
return
{
.
.
.
state
selectedLocation
:
{
sourceId
:
action
.
source
.
id
.
.
.
action
.
location
}
pendingSelectedLocation
:
location
}
;
case
"
CLEAR_SELECTED_LOCATION
"
:
location
=
{
url
:
"
"
}
;
prefs
.
pendingSelectedLocation
=
location
;
return
{
.
.
.
state
selectedLocation
:
null
pendingSelectedLocation
:
location
}
;
case
"
SET_PENDING_SELECTED_LOCATION
"
:
location
=
{
url
:
action
.
url
line
:
action
.
line
column
:
action
.
column
}
;
prefs
.
pendingSelectedLocation
=
location
;
return
{
.
.
.
state
pendingSelectedLocation
:
location
}
;
case
"
LOAD_SOURCE_TEXT
"
:
return
updateLoadedState
(
state
action
)
;
case
"
BLACKBOX
"
:
if
(
action
.
status
=
=
=
"
done
"
)
{
const
{
blackboxSources
}
=
action
.
value
;
state
=
updateBlackBoxState
(
state
blackboxSources
)
;
return
updateSourcesBlackboxState
(
state
blackboxSources
)
;
}
break
;
case
"
SET_PROJECT_DIRECTORY_ROOT
"
:
const
{
url
name
}
=
action
;
return
updateProjectDirectoryRoot
(
state
url
name
)
;
case
"
SET_ORIGINAL_BREAKABLE_LINES
"
:
{
const
{
breakableLines
sourceId
}
=
action
;
return
{
.
.
.
state
breakableLines
:
{
.
.
.
state
.
breakableLines
[
sourceId
]
:
breakableLines
}
}
;
}
case
"
ADD_BREAKPOINT_POSITIONS
"
:
{
const
{
source
positions
}
=
action
;
const
breakpointPositions
=
state
.
breakpointPositions
[
source
.
id
]
;
return
{
.
.
.
state
breakpointPositions
:
{
.
.
.
state
.
breakpointPositions
[
source
.
id
]
:
{
.
.
.
breakpointPositions
.
.
.
positions
}
}
}
;
}
case
"
NAVIGATE
"
:
return
{
.
.
.
initialSourcesState
(
state
)
epoch
:
state
.
epoch
+
1
}
;
}
return
state
;
}
export
const
resourceAsSourceBase
=
memoizeResourceShallow
(
(
{
content
.
.
.
source
}
)
=
>
source
)
;
const
resourceAsSourceWithContent
=
memoizeResourceShallow
(
(
{
content
.
.
.
source
}
)
=
>
(
{
.
.
.
source
content
:
asSettled
(
content
)
}
)
)
;
function
addSources
(
state
sources
)
{
const
originalState
=
state
;
state
=
{
.
.
.
state
urls
:
{
.
.
.
state
.
urls
}
plainUrls
:
{
.
.
.
state
.
plainUrls
}
}
;
state
.
sources
=
insertResources
(
state
.
sources
sources
.
map
(
source
=
>
(
{
.
.
.
source
content
:
null
}
)
)
)
;
for
(
const
source
of
sources
)
{
const
existing
=
state
.
urls
[
source
.
url
]
|
|
[
]
;
if
(
!
existing
.
includes
(
source
.
id
)
)
{
state
.
urls
[
source
.
url
]
=
[
.
.
.
existing
source
.
id
]
;
}
if
(
source
.
url
)
{
const
plainUrl
=
getPlainUrl
(
source
.
url
)
;
const
existingPlainUrls
=
state
.
plainUrls
[
plainUrl
]
|
|
[
]
;
if
(
!
existingPlainUrls
.
includes
(
source
.
url
)
)
{
state
.
plainUrls
[
plainUrl
]
=
[
.
.
.
existingPlainUrls
source
.
url
]
;
}
if
(
originalState
.
sourcesWithUrls
=
=
=
state
.
sourcesWithUrls
)
{
state
.
sourcesWithUrls
=
[
.
.
.
state
.
sourcesWithUrls
]
;
}
state
.
sourcesWithUrls
.
push
(
source
.
id
)
;
}
}
state
=
updateRootRelativeValues
(
state
sources
)
;
return
state
;
}
function
insertSourceActors
(
state
action
)
{
const
{
items
}
=
action
;
state
=
{
.
.
.
state
actors
:
{
.
.
.
state
.
actors
}
}
;
for
(
const
sourceActor
of
items
)
{
state
.
actors
[
sourceActor
.
source
]
=
[
.
.
.
(
state
.
actors
[
sourceActor
.
source
]
|
|
[
]
)
sourceActor
.
id
]
;
}
const
scriptActors
=
items
.
filter
(
item
=
>
item
.
introductionType
=
=
=
"
scriptElement
"
)
;
if
(
scriptActors
.
length
>
0
)
{
const
{
.
.
.
breakpointPositions
}
=
state
.
breakpointPositions
;
for
(
const
{
source
}
of
scriptActors
)
{
delete
breakpointPositions
[
source
]
;
}
state
=
{
.
.
.
state
breakpointPositions
}
;
}
return
state
;
}
function
removeSourceActors
(
state
action
)
{
const
{
items
}
=
action
;
const
actors
=
new
Set
(
items
.
map
(
item
=
>
item
.
id
)
)
;
const
sources
=
new
Set
(
items
.
map
(
item
=
>
item
.
source
)
)
;
state
=
{
.
.
.
state
actors
:
{
.
.
.
state
.
actors
}
}
;
for
(
const
source
of
sources
)
{
state
.
actors
[
source
]
=
state
.
actors
[
source
]
.
filter
(
id
=
>
!
actors
.
has
(
id
)
)
;
}
return
state
;
}
function
updateProjectDirectoryRoot
(
state
root
name
)
{
if
(
actorType
(
root
)
!
=
=
"
thread
"
)
{
prefs
.
projectDirectoryRoot
=
root
;
prefs
.
projectDirectoryRootName
=
name
;
}
return
updateRootRelativeValues
(
state
undefined
root
name
)
;
}
function
actorType
(
actor
)
{
const
match
=
actor
.
match
(
/
\
/
(
[
a
-
z
]
+
)
\
d
+
/
)
;
return
match
?
match
[
1
]
:
null
;
}
function
updateRootRelativeValues
(
state
sources
projectDirectoryRoot
=
state
.
projectDirectoryRoot
projectDirectoryRootName
=
state
.
projectDirectoryRootName
)
{
const
wrappedIdsOrIds
=
sources
?
sources
:
getResourceIds
(
state
.
sources
)
;
state
=
{
.
.
.
state
projectDirectoryRoot
projectDirectoryRootName
}
;
const
relativeURLUpdates
=
wrappedIdsOrIds
.
map
(
wrappedIdOrId
=
>
{
const
id
=
typeof
wrappedIdOrId
=
=
=
"
string
"
?
wrappedIdOrId
:
wrappedIdOrId
.
id
;
const
source
=
getResource
(
state
.
sources
id
)
;
return
{
id
relativeUrl
:
getRelativeUrl
(
source
state
.
projectDirectoryRoot
)
}
;
}
)
;
state
.
sources
=
updateResources
(
state
.
sources
relativeURLUpdates
)
;
return
state
;
}
function
updateLoadedState
(
state
action
)
{
const
{
sourceId
}
=
action
;
if
(
action
.
epoch
!
=
=
state
.
epoch
|
|
!
hasResource
(
state
.
sources
sourceId
)
)
{
return
state
;
}
let
content
;
if
(
action
.
status
=
=
=
"
start
"
)
{
content
=
pending
(
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
)
{
content
=
rejected
(
action
.
error
)
;
}
else
if
(
typeof
action
.
value
.
text
=
=
=
"
string
"
)
{
content
=
fulfilled
(
{
type
:
"
text
"
value
:
action
.
value
.
text
contentType
:
action
.
value
.
contentType
}
)
;
}
else
{
content
=
fulfilled
(
{
type
:
"
wasm
"
value
:
action
.
value
.
text
}
)
;
}
return
{
.
.
.
state
sources
:
updateResources
(
state
.
sources
[
{
id
:
sourceId
content
}
]
)
}
;
}
function
updateSourcesBlackboxState
(
state
blackboxSources
)
{
const
sourcesToUpdate
=
[
]
;
for
(
const
{
source
}
of
blackboxSources
)
{
if
(
!
hasResource
(
state
.
sources
source
.
id
)
)
{
continue
;
}
const
isBlackBoxed
=
!
!
state
.
blackboxedRanges
[
source
.
url
]
;
sourcesToUpdate
.
push
(
{
id
:
source
.
id
isBlackBoxed
}
)
;
}
state
.
sources
=
updateResources
(
state
.
sources
sourcesToUpdate
)
;
return
state
;
}
function
updateBlackboxRangesForSourceUrl
(
currentRanges
url
shouldBlackBox
newRanges
)
{
if
(
shouldBlackBox
)
{
if
(
!
newRanges
.
length
)
{
currentRanges
[
url
]
=
[
]
;
}
else
{
currentRanges
[
url
]
=
currentRanges
[
url
]
|
|
[
]
;
newRanges
.
forEach
(
newRange
=
>
{
const
duplicate
=
currentRanges
[
url
]
.
findIndex
(
r
=
>
r
.
start
.
line
=
=
newRange
.
start
.
line
&
&
r
.
end
.
line
=
=
newRange
.
end
.
line
)
;
if
(
duplicate
!
=
=
-
1
)
{
return
;
}
const
index
=
currentRanges
[
url
]
.
findIndex
(
range
=
>
range
.
end
.
line
<
=
newRange
.
start
.
line
&
&
range
.
end
.
column
<
=
newRange
.
start
.
column
)
;
currentRanges
[
url
]
.
splice
(
index
+
1
0
newRange
)
;
}
)
;
}
}
else
{
if
(
!
newRanges
.
length
)
{
delete
currentRanges
[
url
]
;
return
;
}
newRanges
.
forEach
(
newRange
=
>
{
const
index
=
currentRanges
[
url
]
.
findIndex
(
range
=
>
range
.
start
.
line
=
=
=
newRange
.
start
.
line
&
&
range
.
end
.
line
=
=
=
newRange
.
end
.
line
)
;
if
(
index
!
=
=
-
1
)
{
currentRanges
[
url
]
.
splice
(
index
1
)
;
}
}
)
;
if
(
currentRanges
[
url
]
.
length
=
=
0
)
{
delete
currentRanges
[
url
]
;
}
}
}
function
updateBlackBoxState
(
state
blackboxSources
)
{
const
currentRanges
=
{
.
.
.
state
.
blackboxedRanges
}
;
blackboxSources
.
map
(
(
{
source
shouldBlackBox
ranges
}
)
=
>
updateBlackboxRangesForSourceUrl
(
currentRanges
source
.
url
shouldBlackBox
ranges
)
)
;
return
{
.
.
.
state
blackboxedRanges
:
currentRanges
}
;
}
const
getSourcesState
=
state
=
>
state
.
sources
;
export
function
getSourceThreads
(
state
source
)
{
return
[
.
.
.
new
Set
(
getSourceActors
(
state
state
.
sources
.
actors
[
source
.
id
]
)
.
map
(
actor
=
>
actor
.
thread
)
)
]
;
}
export
function
getSourceInSources
(
sources
id
)
{
return
hasResource
(
sources
id
)
?
getMappedResource
(
sources
id
resourceAsSourceBase
)
:
null
;
}
export
function
getSource
(
state
id
)
{
return
getSourceInSources
(
getSources
(
state
)
id
)
;
}
export
function
getSourceFromId
(
state
id
)
{
const
source
=
getSource
(
state
id
)
;
if
(
!
source
)
{
console
.
warn
(
source
{
id
}
does
not
exist
)
;
}
return
source
;
}
export
function
getSourceByActorId
(
state
actorId
)
{
if
(
!
hasSourceActor
(
state
actorId
)
)
{
return
null
;
}
return
getSource
(
state
getSourceActor
(
state
actorId
)
.
source
)
;
}
export
function
getSourcesByURLInSources
(
sources
urls
url
)
{
if
(
!
url
|
|
!
urls
[
url
]
)
{
return
[
]
;
}
return
urls
[
url
]
.
map
(
id
=
>
getMappedResource
(
sources
id
resourceAsSourceBase
)
)
;
}
export
function
getSourcesByURL
(
state
url
)
{
return
getSourcesByURLInSources
(
getSources
(
state
)
getUrls
(
state
)
url
)
;
}
export
function
getSourceByURL
(
state
url
)
{
const
foundSources
=
getSourcesByURL
(
state
url
)
;
return
foundSources
?
foundSources
[
0
]
:
null
;
}
export
function
getSpecificSourceByURLInSources
(
sources
urls
url
isOriginal
)
{
const
foundSources
=
getSourcesByURLInSources
(
sources
urls
url
)
;
if
(
foundSources
)
{
return
foundSources
.
find
(
source
=
>
source
.
isOriginal
=
=
isOriginal
)
;
}
return
null
;
}
export
function
getSpecificSourceByURL
(
state
url
isOriginal
)
{
return
getSpecificSourceByURLInSources
(
getSources
(
state
)
getUrls
(
state
)
url
isOriginal
)
;
}
export
function
getOriginalSourceByURL
(
state
url
)
{
return
getSpecificSourceByURL
(
state
url
true
)
;
}
export
function
getGeneratedSourceByURL
(
state
url
)
{
return
getSpecificSourceByURL
(
state
url
false
)
;
}
export
function
getGeneratedSource
(
state
source
)
{
if
(
!
source
)
{
return
null
;
}
if
(
isGenerated
(
source
)
)
{
return
source
;
}
return
getSourceFromId
(
state
originalToGeneratedId
(
source
.
id
)
)
;
}
export
function
getGeneratedSourceById
(
state
sourceId
)
{
const
generatedSourceId
=
originalToGeneratedId
(
sourceId
)
;
return
getSourceFromId
(
state
generatedSourceId
)
;
}
export
function
getPendingSelectedLocation
(
state
)
{
return
state
.
sources
.
pendingSelectedLocation
;
}
export
function
getPrettySource
(
state
id
)
{
if
(
!
id
)
{
return
;
}
const
source
=
getSource
(
state
id
)
;
if
(
!
source
)
{
return
;
}
return
getOriginalSourceByURL
(
state
getPrettySourceURL
(
source
.
url
)
)
;
}
export
function
hasPrettySource
(
state
id
)
{
return
!
!
getPrettySource
(
state
id
)
;
}
export
function
getSourcesUrlsInSources
(
state
url
)
{
if
(
!
url
)
{
return
[
]
;
}
const
plainUrl
=
getPlainUrl
(
url
)
;
return
getPlainUrls
(
state
)
[
plainUrl
]
|
|
[
]
;
}
export
function
getHasSiblingOfSameName
(
state
source
)
{
if
(
!
source
)
{
return
false
;
}
return
getSourcesUrlsInSources
(
state
source
.
url
)
.
length
>
1
;
}
const
querySourceList
=
makeReduceAllQuery
(
resourceAsSourceBase
sources
=
>
sources
.
slice
(
)
)
;
export
function
getSources
(
state
)
{
return
state
.
sources
.
sources
;
}
export
function
getSourcesEpoch
(
state
)
{
return
state
.
sources
.
epoch
;
}
export
function
getUrls
(
state
)
{
return
state
.
sources
.
urls
;
}
export
function
getPlainUrls
(
state
)
{
return
state
.
sources
.
plainUrls
;
}
export
function
getSourceList
(
state
)
{
return
querySourceList
(
getSources
(
state
)
)
;
}
export
function
getDisplayedSourcesList
(
state
)
{
return
Object
.
values
(
getDisplayedSources
(
state
)
)
.
flatMap
(
Object
.
values
)
;
}
export
function
getExtensionNameBySourceUrl
(
state
url
)
{
const
match
=
getSourceList
(
state
)
.
find
(
source
=
>
source
.
url
&
&
source
.
url
.
startsWith
(
url
)
)
;
if
(
match
&
&
match
.
extensionName
)
{
return
match
.
extensionName
;
}
}
export
function
getSourceCount
(
state
)
{
return
getSourceList
(
state
)
.
length
;
}
export
const
getSelectedLocation
=
createSelector
(
getSourcesState
sources
=
>
sources
.
selectedLocation
)
;
export
const
getSelectedSource
=
createSelector
(
getSelectedLocation
getSources
(
selectedLocation
sources
)
=
>
{
if
(
!
selectedLocation
)
{
return
;
}
return
getSourceInSources
(
sources
selectedLocation
.
sourceId
)
;
}
)
;
export
const
getSelectedSourceWithContent
=
createSelector
(
getSelectedLocation
getSources
(
selectedLocation
sources
)
=
>
{
const
source
=
selectedLocation
&
&
getSourceInSources
(
sources
selectedLocation
.
sourceId
)
;
return
source
?
getMappedResource
(
sources
source
.
id
resourceAsSourceWithContent
)
:
null
;
}
)
;
export
function
getSourceWithContent
(
state
id
)
{
return
getMappedResource
(
state
.
sources
.
sources
id
resourceAsSourceWithContent
)
;
}
export
function
getSourceContent
(
state
id
)
{
const
{
content
}
=
getResource
(
state
.
sources
.
sources
id
)
;
return
asSettled
(
content
)
;
}
export
function
getSelectedSourceId
(
state
)
{
const
source
=
getSelectedSource
(
state
)
;
return
source
?
.
id
;
}
export
function
getProjectDirectoryRoot
(
state
)
{
return
state
.
sources
.
projectDirectoryRoot
;
}
export
function
getProjectDirectoryRootName
(
state
)
{
return
state
.
sources
.
projectDirectoryRootName
;
}
const
queryAllDisplayedSources
=
makeShallowQuery
(
{
filter
:
(
_
{
sourcesWithUrls
}
)
=
>
sourcesWithUrls
map
:
makeMapWithArgs
(
(
resource
ident
{
projectDirectoryRoot
chromeAndExtensionsEnabled
debuggeeIsWebExtension
threads
}
)
=
>
(
{
id
:
resource
.
id
displayed
:
isDescendantOfRoot
(
resource
projectDirectoryRoot
threads
)
&
&
(
!
resource
.
isExtension
|
|
chromeAndExtensionsEnabled
|
|
debuggeeIsWebExtension
)
}
)
)
reduce
:
items
=
>
items
.
reduce
(
(
acc
{
id
displayed
}
)
=
>
{
if
(
displayed
)
{
acc
.
push
(
id
)
;
}
return
acc
;
}
[
]
)
}
)
;
function
getAllDisplayedSources
(
state
)
{
return
queryAllDisplayedSources
(
state
.
sources
.
sources
{
sourcesWithUrls
:
state
.
sources
.
sourcesWithUrls
projectDirectoryRoot
:
state
.
sources
.
projectDirectoryRoot
chromeAndExtensionsEnabled
:
state
.
sources
.
chromeAndExtensionsEnabled
debuggeeIsWebExtension
:
state
.
threads
.
isWebExtension
threads
:
getAllThreads
(
state
)
}
)
;
}
const
getDisplayedSourceIDs
=
createSelector
(
getAllThreadsBySource
getAllDisplayedSources
(
threadsBySource
displayedSources
)
=
>
{
const
sourceIDsByThread
=
{
}
;
for
(
const
sourceId
of
displayedSources
)
{
const
threads
=
threadsBySource
[
sourceId
]
|
|
threadsBySource
[
originalToGeneratedId
(
sourceId
)
]
|
|
[
]
;
for
(
const
thread
of
threads
)
{
if
(
!
sourceIDsByThread
[
thread
]
)
{
sourceIDsByThread
[
thread
]
=
new
Set
(
)
;
}
sourceIDsByThread
[
thread
]
.
add
(
sourceId
)
;
}
}
return
sourceIDsByThread
;
}
)
;
export
const
getDisplayedSources
=
createSelector
(
state
=
>
state
.
sources
.
sources
getDisplayedSourceIDs
(
sources
idsByThread
)
=
>
{
const
result
=
{
}
;
for
(
const
thread
of
Object
.
keys
(
idsByThread
)
)
{
const
entriesByNoQueryURL
=
Object
.
create
(
null
)
;
for
(
const
id
of
idsByThread
[
thread
]
)
{
if
(
!
result
[
thread
]
)
{
result
[
thread
]
=
{
}
;
}
const
source
=
getResource
(
sources
id
)
;
const
entry
=
{
.
.
.
source
displayURL
:
source
.
url
}
;
result
[
thread
]
[
id
]
=
entry
;
const
noQueryURL
=
stripQuery
(
entry
.
displayURL
)
;
if
(
!
entriesByNoQueryURL
[
noQueryURL
]
)
{
entriesByNoQueryURL
[
noQueryURL
]
=
[
]
;
}
entriesByNoQueryURL
[
noQueryURL
]
.
push
(
entry
)
;
}
for
(
const
noQueryURL
in
entriesByNoQueryURL
)
{
const
entries
=
entriesByNoQueryURL
[
noQueryURL
]
;
if
(
entries
.
length
=
=
=
1
)
{
entries
[
0
]
.
displayURL
=
noQueryURL
;
}
}
}
return
result
;
}
)
;
export
function
getSourceActorsForSource
(
state
id
)
{
const
actors
=
state
.
sources
.
actors
[
id
]
;
if
(
!
actors
)
{
return
[
]
;
}
return
getSourceActors
(
state
actors
)
;
}
export
function
isSourceWithMap
(
state
id
)
{
return
getSourceActorsForSource
(
state
id
)
.
some
(
sourceActor
=
>
sourceActor
.
sourceMapURL
)
;
}
export
function
canPrettyPrintSource
(
state
id
)
{
const
source
=
getSourceWithContent
(
state
id
)
;
if
(
!
source
|
|
isPretty
(
source
)
|
|
source
.
isOriginal
|
|
(
prefs
.
clientSourceMapsEnabled
&
&
isSourceWithMap
(
state
id
)
)
)
{
return
false
;
}
const
sourceContent
=
source
.
content
&
&
isFulfilled
(
source
.
content
)
?
source
.
content
.
value
:
null
;
if
(
!
sourceContent
|
|
!
isJavaScript
(
source
sourceContent
)
)
{
return
false
;
}
return
true
;
}
export
function
getBreakpointPositions
(
state
)
{
return
state
.
sources
.
breakpointPositions
;
}
export
function
getBreakpointPositionsForSource
(
state
sourceId
)
{
const
positions
=
getBreakpointPositions
(
state
)
;
return
positions
?
.
[
sourceId
]
;
}
export
function
hasBreakpointPositions
(
state
sourceId
)
{
return
!
!
getBreakpointPositionsForSource
(
state
sourceId
)
;
}
export
function
getBreakpointPositionsForLine
(
state
sourceId
line
)
{
const
positions
=
getBreakpointPositionsForSource
(
state
sourceId
)
;
return
positions
?
.
[
line
]
;
}
export
function
hasBreakpointPositionsForLine
(
state
sourceId
line
)
{
return
!
!
getBreakpointPositionsForLine
(
state
sourceId
line
)
;
}
export
function
getBreakpointPositionsForLocation
(
state
location
)
{
const
{
sourceId
}
=
location
;
const
positions
=
getBreakpointPositionsForSource
(
state
sourceId
)
;
return
findPosition
(
positions
location
)
;
}
export
function
getBreakableLines
(
state
sourceId
)
{
if
(
!
sourceId
)
{
return
null
;
}
const
source
=
getSource
(
state
sourceId
)
;
if
(
!
source
)
{
return
null
;
}
if
(
source
.
isOriginal
)
{
return
state
.
sources
.
breakableLines
[
sourceId
]
;
}
return
getBreakableLinesForSourceActors
(
state
.
sourceActors
state
.
sources
.
actors
[
sourceId
]
)
;
}
export
const
getSelectedBreakableLines
=
createSelector
(
state
=
>
{
const
sourceId
=
getSelectedSourceId
(
state
)
;
return
sourceId
&
&
getBreakableLines
(
state
sourceId
)
;
}
breakableLines
=
>
new
Set
(
breakableLines
|
|
[
]
)
)
;
export
function
isSourceLoadingOrLoaded
(
state
sourceId
)
{
const
{
content
}
=
getResource
(
state
.
sources
.
sources
sourceId
)
;
return
content
!
=
=
null
;
}
export
function
getBlackBoxRanges
(
state
)
{
return
state
.
sources
.
blackboxedRanges
;
}
export
default
update
;
