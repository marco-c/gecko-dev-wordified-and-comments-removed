import
{
prefs
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
createPendingSelectedLocation
}
from
"
.
.
/
utils
/
location
"
;
export
const
UNDEFINED_LOCATION
=
Symbol
(
"
Undefined
location
"
)
;
export
const
NO_LOCATION
=
Symbol
(
"
No
location
"
)
;
export
function
initialSourcesState
(
)
{
return
{
mutableBreakpointPositions
:
new
Map
(
)
mutableOriginalBreakableLines
:
new
Map
(
)
mutableOriginalSources
:
new
Map
(
)
mutableSourceActors
:
new
Map
(
)
mutableSources
:
new
Map
(
)
mutableSourcesPerUrl
:
new
Map
(
)
pendingSelectedLocation
:
prefs
.
pendingSelectedLocation
selectedLocation
:
undefined
selectedOriginalLocation
:
UNDEFINED_LOCATION
shouldHighlightSelectedLocation
:
true
shouldSelectOriginalLocation
:
true
}
;
}
function
update
(
state
=
initialSourcesState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
ADD_SOURCES
"
:
return
addSources
(
state
action
.
sources
)
;
case
"
ADD_ORIGINAL_SOURCES
"
:
return
addSources
(
state
action
.
originalSources
)
;
case
"
INSERT_SOURCE_ACTORS
"
:
return
insertSourceActors
(
state
action
)
;
case
"
SET_SELECTED_LOCATION
"
:
{
let
pendingSelectedLocation
=
null
;
if
(
action
.
location
.
source
.
url
)
{
pendingSelectedLocation
=
createPendingSelectedLocation
(
action
.
location
)
;
prefs
.
pendingSelectedLocation
=
pendingSelectedLocation
;
}
return
{
.
.
.
state
selectedLocation
:
action
.
location
selectedOriginalLocation
:
UNDEFINED_LOCATION
pendingSelectedLocation
shouldSelectOriginalLocation
:
action
.
shouldSelectOriginalLocation
shouldHighlightSelectedLocation
:
action
.
shouldHighlightSelectedLocation
shouldScrollToSelectedLocation
:
action
.
shouldScrollToSelectedLocation
}
;
}
case
"
CLEAR_SELECTED_LOCATION
"
:
{
const
pendingSelectedLocation
=
{
url
:
"
"
}
;
prefs
.
pendingSelectedLocation
=
pendingSelectedLocation
;
return
{
.
.
.
state
selectedLocation
:
null
selectedOriginalLocation
:
UNDEFINED_LOCATION
pendingSelectedLocation
}
;
}
case
"
SET_ORIGINAL_SELECTED_LOCATION
"
:
{
if
(
action
.
location
!
=
state
.
selectedLocation
)
{
return
state
;
}
return
{
.
.
.
state
selectedOriginalLocation
:
action
.
originalLocation
}
;
}
case
"
SET_DEFAULT_SELECTED_LOCATION
"
:
{
if
(
state
.
shouldSelectOriginalLocation
=
=
action
.
shouldSelectOriginalLocation
)
{
return
state
;
}
return
{
.
.
.
state
shouldSelectOriginalLocation
:
action
.
shouldSelectOriginalLocation
}
;
}
case
"
SET_PENDING_SELECTED_LOCATION
"
:
{
const
pendingSelectedLocation
=
{
url
:
action
.
url
line
:
action
.
line
column
:
action
.
column
}
;
prefs
.
pendingSelectedLocation
=
pendingSelectedLocation
;
return
{
.
.
.
state
pendingSelectedLocation
}
;
}
case
"
SET_ORIGINAL_BREAKABLE_LINES
"
:
{
state
.
mutableOriginalBreakableLines
.
set
(
action
.
source
.
id
action
.
promise
|
|
action
.
breakableLines
)
;
return
{
.
.
.
state
}
;
}
case
"
ADD_BREAKPOINT_POSITIONS
"
:
{
let
positions
=
state
.
mutableBreakpointPositions
.
get
(
action
.
source
.
id
)
;
if
(
positions
)
{
positions
=
{
.
.
.
positions
.
.
.
action
.
positions
}
;
}
else
{
positions
=
action
.
positions
;
}
state
.
mutableBreakpointPositions
.
set
(
action
.
source
.
id
positions
)
;
return
{
.
.
.
state
}
;
}
case
"
CLEAR_BREAKPOINT_POSITIONS
"
:
{
if
(
!
state
.
mutableBreakpointPositions
.
has
(
action
.
source
.
id
)
)
{
return
state
;
}
state
.
mutableBreakpointPositions
.
delete
(
action
.
source
.
id
)
;
return
{
.
.
.
state
}
;
}
case
"
REMOVE_SOURCES
"
:
{
return
removeSourcesAndActors
(
state
action
)
;
}
}
return
state
;
}
function
addSources
(
state
sources
)
{
for
(
const
source
of
sources
)
{
state
.
mutableSources
.
set
(
source
.
id
source
)
;
const
existing
=
state
.
mutableSourcesPerUrl
.
get
(
source
.
url
)
;
if
(
existing
)
{
existing
.
push
(
source
)
;
}
else
{
state
.
mutableSourcesPerUrl
.
set
(
source
.
url
[
source
]
)
;
}
if
(
source
.
isOriginal
)
{
const
generatedSourceId
=
source
.
generatedSource
.
id
;
let
originalSourceIds
=
state
.
mutableOriginalSources
.
get
(
generatedSourceId
)
;
if
(
!
originalSourceIds
)
{
originalSourceIds
=
[
]
;
state
.
mutableOriginalSources
.
set
(
generatedSourceId
originalSourceIds
)
;
}
originalSourceIds
.
push
(
source
.
id
)
;
}
}
return
{
.
.
.
state
}
;
}
function
removeSourcesAndActors
(
state
action
)
{
const
{
mutableSourcesPerUrl
mutableSources
mutableOriginalSources
mutableSourceActors
mutableOriginalBreakableLines
mutableBreakpointPositions
}
=
state
;
const
newState
=
{
.
.
.
state
}
;
for
(
const
removedSource
of
action
.
sources
)
{
const
sourceId
=
removedSource
.
id
;
const
sourceUrl
=
removedSource
.
url
;
if
(
sourceUrl
)
{
const
sourcesForSameUrl
=
(
mutableSourcesPerUrl
.
get
(
sourceUrl
)
|
|
[
]
)
.
filter
(
s
=
>
s
!
=
removedSource
)
;
if
(
!
sourcesForSameUrl
.
length
)
{
mutableSourcesPerUrl
.
delete
(
sourceUrl
)
;
}
else
{
mutableSourcesPerUrl
.
set
(
sourceUrl
sourcesForSameUrl
)
;
}
}
mutableSources
.
delete
(
sourceId
)
;
mutableOriginalSources
.
delete
(
sourceId
)
;
mutableSourceActors
.
delete
(
sourceId
)
;
if
(
removedSource
.
isOriginal
)
{
mutableOriginalBreakableLines
.
delete
(
sourceId
)
;
const
generatedSourceId
=
removedSource
.
generatedSource
.
id
;
let
originalSourceIds
=
mutableOriginalSources
.
get
(
generatedSourceId
)
;
if
(
originalSourceIds
)
{
originalSourceIds
=
originalSourceIds
.
filter
(
id
=
>
id
!
=
sourceId
)
;
mutableOriginalSources
.
set
(
generatedSourceId
originalSourceIds
)
;
}
const
generatedBreakpointPositions
=
mutableBreakpointPositions
.
get
(
generatedSourceId
)
;
if
(
generatedBreakpointPositions
)
{
for
(
const
line
in
generatedBreakpointPositions
)
{
for
(
const
position
of
generatedBreakpointPositions
[
line
]
)
{
if
(
position
.
location
.
source
=
=
removedSource
)
{
position
.
location
=
position
.
generatedLocation
;
}
}
}
}
}
mutableBreakpointPositions
.
delete
(
sourceId
)
;
if
(
action
.
resetSelectedLocation
&
&
newState
.
selectedLocation
?
.
source
=
=
removedSource
)
{
newState
.
selectedLocation
=
null
;
newState
.
selectedOriginalLocation
=
UNDEFINED_LOCATION
;
}
}
for
(
const
removedActor
of
action
.
actors
)
{
const
sourceId
=
removedActor
.
source
;
const
actorsForSource
=
mutableSourceActors
.
get
(
sourceId
)
;
if
(
!
actorsForSource
)
{
continue
;
}
const
idx
=
actorsForSource
.
indexOf
(
removedActor
)
;
if
(
idx
!
=
-
1
)
{
actorsForSource
.
splice
(
idx
1
)
;
mutableSourceActors
.
set
(
sourceId
[
.
.
.
actorsForSource
]
)
;
}
if
(
!
actorsForSource
.
length
)
{
mutableSourceActors
.
delete
(
sourceId
)
;
}
if
(
action
.
resetSelectedLocation
&
&
newState
.
selectedLocation
?
.
sourceActor
=
=
removedActor
)
{
newState
.
selectedLocation
=
null
;
newState
.
selectedOriginalLocation
=
UNDEFINED_LOCATION
;
}
}
return
newState
;
}
function
insertSourceActors
(
state
action
)
{
const
{
sourceActors
}
=
action
;
const
{
mutableSourceActors
}
=
state
;
for
(
const
sourceActor
of
sourceActors
)
{
const
sourceId
=
sourceActor
.
source
;
const
existing
=
mutableSourceActors
.
get
(
sourceId
)
;
if
(
existing
)
{
mutableSourceActors
.
set
(
sourceId
[
.
.
.
existing
sourceActor
]
)
;
}
else
{
mutableSourceActors
.
set
(
sourceId
[
sourceActor
]
)
;
}
}
const
scriptActors
=
sourceActors
.
filter
(
item
=
>
item
.
introductionType
=
=
=
"
scriptElement
"
)
;
if
(
scriptActors
.
length
)
{
for
(
const
{
source
}
of
scriptActors
)
{
state
.
mutableBreakpointPositions
.
delete
(
source
)
;
}
}
return
{
.
.
.
state
}
;
}
export
default
update
;
