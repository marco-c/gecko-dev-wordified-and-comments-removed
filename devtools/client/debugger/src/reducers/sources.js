import
{
getRelativeUrl
getPlainUrl
}
from
"
.
.
/
utils
/
source
"
;
import
{
prefs
}
from
"
.
.
/
utils
/
prefs
"
;
export
function
initialSourcesState
(
state
)
{
return
{
sources
:
new
Map
(
)
urls
:
{
}
plainUrls
:
{
}
sourcesWithUrls
:
[
]
actors
:
{
}
breakpointPositions
:
{
}
breakableLines
:
{
}
selectedLocation
:
undefined
pendingSelectedLocation
:
prefs
.
pendingSelectedLocation
projectDirectoryRoot
:
prefs
.
projectDirectoryRoot
projectDirectoryRootName
:
prefs
.
projectDirectoryRootName
chromeAndExtensionsEnabled
:
prefs
.
chromeAndExtensionsEnabled
blackboxedRanges
:
state
?
.
blackboxedRanges
?
?
{
}
}
;
}
function
update
(
state
=
initialSourcesState
(
)
action
)
{
let
location
=
null
;
switch
(
action
.
type
)
{
case
"
ADD_SOURCES
"
:
return
addSources
(
state
action
.
sources
)
;
case
"
INSERT_SOURCE_ACTORS
"
:
return
insertSourceActors
(
state
action
)
;
case
"
SET_SELECTED_LOCATION
"
:
location
=
{
.
.
.
action
.
location
url
:
action
.
source
.
url
}
;
if
(
action
.
source
.
url
)
{
prefs
.
pendingSelectedLocation
=
location
;
}
return
{
.
.
.
state
selectedLocation
:
{
sourceId
:
action
.
source
.
id
.
.
.
action
.
location
}
pendingSelectedLocation
:
location
}
;
case
"
CLEAR_SELECTED_LOCATION
"
:
location
=
{
url
:
"
"
}
;
prefs
.
pendingSelectedLocation
=
location
;
return
{
.
.
.
state
selectedLocation
:
null
pendingSelectedLocation
:
location
}
;
case
"
SET_PENDING_SELECTED_LOCATION
"
:
location
=
{
url
:
action
.
url
line
:
action
.
line
column
:
action
.
column
}
;
prefs
.
pendingSelectedLocation
=
location
;
return
{
.
.
.
state
pendingSelectedLocation
:
location
}
;
case
"
BLACKBOX
"
:
if
(
action
.
status
=
=
=
"
done
"
)
{
const
{
blackboxSources
}
=
action
.
value
;
state
=
updateBlackBoxState
(
state
blackboxSources
)
;
return
updateSourcesBlackboxState
(
state
blackboxSources
)
;
}
break
;
case
"
SET_PROJECT_DIRECTORY_ROOT
"
:
const
{
url
name
}
=
action
;
return
updateProjectDirectoryRoot
(
state
url
name
)
;
case
"
SET_ORIGINAL_BREAKABLE_LINES
"
:
{
const
{
breakableLines
sourceId
}
=
action
;
return
{
.
.
.
state
breakableLines
:
{
.
.
.
state
.
breakableLines
[
sourceId
]
:
breakableLines
}
}
;
}
case
"
ADD_BREAKPOINT_POSITIONS
"
:
{
const
{
source
positions
}
=
action
;
const
breakpointPositions
=
state
.
breakpointPositions
[
source
.
id
]
;
return
{
.
.
.
state
breakpointPositions
:
{
.
.
.
state
.
breakpointPositions
[
source
.
id
]
:
{
.
.
.
breakpointPositions
.
.
.
positions
}
}
}
;
}
case
"
NAVIGATE
"
:
return
initialSourcesState
(
state
)
;
case
"
REMOVE_THREAD
"
:
{
const
threadSources
=
[
]
;
for
(
const
source
of
state
.
sources
.
values
(
)
)
{
if
(
source
.
thread
=
=
action
.
threadActorID
)
{
threadSources
.
push
(
source
)
;
}
}
return
removeSourcesAndActors
(
state
threadSources
)
;
}
}
return
state
;
}
function
addSources
(
state
sources
)
{
const
originalState
=
state
;
state
=
{
.
.
.
state
urls
:
{
.
.
.
state
.
urls
}
plainUrls
:
{
.
.
.
state
.
plainUrls
}
}
;
const
newSourceMap
=
new
Map
(
state
.
sources
)
;
for
(
const
source
of
sources
)
{
newSourceMap
.
set
(
source
.
id
source
)
;
const
existing
=
state
.
urls
[
source
.
url
]
|
|
[
]
;
if
(
!
existing
.
includes
(
source
.
id
)
)
{
state
.
urls
[
source
.
url
]
=
[
.
.
.
existing
source
.
id
]
;
}
if
(
source
.
url
)
{
const
plainUrl
=
getPlainUrl
(
source
.
url
)
;
const
existingPlainUrls
=
state
.
plainUrls
[
plainUrl
]
|
|
[
]
;
if
(
!
existingPlainUrls
.
includes
(
source
.
url
)
)
{
state
.
plainUrls
[
plainUrl
]
=
[
.
.
.
existingPlainUrls
source
.
url
]
;
}
if
(
originalState
.
sourcesWithUrls
=
=
=
state
.
sourcesWithUrls
)
{
state
.
sourcesWithUrls
=
[
.
.
.
state
.
sourcesWithUrls
]
;
}
state
.
sourcesWithUrls
.
push
(
source
.
id
)
;
}
}
state
.
sources
=
newSourceMap
;
state
=
updateRootRelativeValues
(
state
sources
)
;
return
state
;
}
function
removeSourcesAndActors
(
state
sources
)
{
state
=
{
.
.
.
state
urls
:
{
.
.
.
state
.
urls
}
plainUrls
:
{
.
.
.
state
.
plainUrls
}
sourcesWithUrls
:
[
.
.
.
state
.
sourcesWithUrls
]
}
;
const
newSourceMap
=
new
Map
(
state
.
sources
)
;
for
(
const
source
of
sources
)
{
newSourceMap
.
delete
(
source
.
id
)
;
if
(
source
.
url
)
{
if
(
state
.
urls
[
source
.
url
]
)
{
state
.
urls
[
source
.
url
]
=
state
.
urls
[
source
.
url
]
.
filter
(
id
=
>
id
!
=
=
source
.
id
)
;
}
if
(
state
.
urls
[
source
.
url
]
?
.
length
=
=
0
)
{
delete
state
.
urls
[
source
.
url
]
;
}
const
plainUrl
=
getPlainUrl
(
source
.
url
)
;
if
(
state
.
plainUrls
[
plainUrl
]
)
{
const
index
=
state
.
plainUrls
[
plainUrl
]
.
findIndex
(
url
=
>
url
=
=
=
source
.
url
)
;
state
.
plainUrls
[
plainUrl
]
.
splice
(
index
1
)
;
}
if
(
state
.
plainUrls
[
plainUrl
]
?
.
length
=
=
0
)
{
delete
state
.
plainUrls
[
plainUrl
]
;
}
state
.
sourcesWithUrls
=
state
.
sourcesWithUrls
.
filter
(
sourceId
=
>
sourceId
!
=
=
source
.
id
)
;
}
delete
state
.
actors
[
source
.
id
]
;
}
state
.
sources
=
newSourceMap
;
return
state
;
}
function
insertSourceActors
(
state
action
)
{
const
{
items
}
=
action
;
state
=
{
.
.
.
state
actors
:
{
.
.
.
state
.
actors
}
}
;
for
(
const
sourceActor
of
items
)
{
state
.
actors
[
sourceActor
.
source
]
=
[
.
.
.
(
state
.
actors
[
sourceActor
.
source
]
|
|
[
]
)
sourceActor
.
id
]
;
}
const
scriptActors
=
items
.
filter
(
item
=
>
item
.
introductionType
=
=
=
"
scriptElement
"
)
;
if
(
scriptActors
.
length
>
0
)
{
const
{
.
.
.
breakpointPositions
}
=
state
.
breakpointPositions
;
for
(
const
{
source
}
of
scriptActors
)
{
delete
breakpointPositions
[
source
]
;
}
state
=
{
.
.
.
state
breakpointPositions
}
;
}
return
state
;
}
function
updateProjectDirectoryRoot
(
state
root
name
)
{
if
(
actorType
(
root
)
!
=
=
"
thread
"
)
{
prefs
.
projectDirectoryRoot
=
root
;
prefs
.
projectDirectoryRootName
=
name
;
}
return
updateRootRelativeValues
(
state
[
.
.
.
state
.
sources
.
values
(
)
]
root
name
)
;
}
function
actorType
(
actor
)
{
const
match
=
actor
.
match
(
/
\
/
(
[
a
-
z
]
+
)
\
d
+
/
)
;
return
match
?
match
[
1
]
:
null
;
}
function
updateRootRelativeValues
(
state
sourcesToUpdate
projectDirectoryRoot
=
state
.
projectDirectoryRoot
projectDirectoryRootName
=
state
.
projectDirectoryRootName
)
{
state
=
{
.
.
.
state
projectDirectoryRoot
projectDirectoryRootName
}
;
const
newSourceMap
=
new
Map
(
state
.
sources
)
;
for
(
const
source
of
sourcesToUpdate
)
{
newSourceMap
.
set
(
source
.
id
{
.
.
.
state
.
sources
.
get
(
source
.
id
)
relativeUrl
:
getRelativeUrl
(
source
state
.
projectDirectoryRoot
)
}
)
;
}
state
.
sources
=
newSourceMap
;
return
state
;
}
function
updateSourcesBlackboxState
(
state
blackboxSources
)
{
const
newSourceMap
=
new
Map
(
state
.
sources
)
;
let
changed
=
false
;
for
(
const
{
source
}
of
blackboxSources
)
{
if
(
!
state
.
sources
.
has
(
source
.
id
)
)
{
continue
;
}
const
isBlackBoxed
=
!
!
state
.
blackboxedRanges
[
source
.
url
]
;
newSourceMap
.
set
(
source
.
id
{
.
.
.
state
.
sources
.
get
(
source
.
id
)
isBlackBoxed
}
)
;
changed
=
true
;
}
if
(
changed
)
{
state
.
sources
=
newSourceMap
;
}
return
state
;
}
function
updateBlackboxRangesForSourceUrl
(
currentRanges
url
shouldBlackBox
newRanges
)
{
if
(
shouldBlackBox
)
{
if
(
!
newRanges
.
length
)
{
currentRanges
[
url
]
=
[
]
;
}
else
{
currentRanges
[
url
]
=
currentRanges
[
url
]
|
|
[
]
;
newRanges
.
forEach
(
newRange
=
>
{
const
duplicate
=
currentRanges
[
url
]
.
findIndex
(
r
=
>
r
.
start
.
line
=
=
newRange
.
start
.
line
&
&
r
.
end
.
line
=
=
newRange
.
end
.
line
)
;
if
(
duplicate
!
=
=
-
1
)
{
return
;
}
const
index
=
currentRanges
[
url
]
.
findIndex
(
range
=
>
range
.
end
.
line
<
=
newRange
.
start
.
line
&
&
range
.
end
.
column
<
=
newRange
.
start
.
column
)
;
currentRanges
[
url
]
.
splice
(
index
+
1
0
newRange
)
;
}
)
;
}
}
else
{
if
(
!
newRanges
.
length
)
{
delete
currentRanges
[
url
]
;
return
;
}
newRanges
.
forEach
(
newRange
=
>
{
const
index
=
currentRanges
[
url
]
.
findIndex
(
range
=
>
range
.
start
.
line
=
=
=
newRange
.
start
.
line
&
&
range
.
end
.
line
=
=
=
newRange
.
end
.
line
)
;
if
(
index
!
=
=
-
1
)
{
currentRanges
[
url
]
.
splice
(
index
1
)
;
}
}
)
;
if
(
currentRanges
[
url
]
.
length
=
=
0
)
{
delete
currentRanges
[
url
]
;
}
}
}
function
updateBlackBoxState
(
state
blackboxSources
)
{
const
currentRanges
=
{
.
.
.
state
.
blackboxedRanges
}
;
blackboxSources
.
map
(
(
{
source
shouldBlackBox
ranges
}
)
=
>
updateBlackboxRangesForSourceUrl
(
currentRanges
source
.
url
shouldBlackBox
ranges
)
)
;
return
{
.
.
.
state
blackboxedRanges
:
currentRanges
}
;
}
export
default
update
;
