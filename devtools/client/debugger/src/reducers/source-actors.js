import
{
asyncActionAsValue
}
from
"
.
.
/
actions
/
utils
/
middleware
/
promise
"
;
function
initialSourceActorsState
(
)
{
return
{
mutableSourceActors
:
new
Map
(
)
mutableBreakableLines
:
new
Map
(
)
}
;
}
export
const
initial
=
initialSourceActorsState
(
)
;
export
default
function
update
(
state
=
initialSourceActorsState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
INSERT_SOURCE_ACTORS
"
:
{
for
(
const
sourceActor
of
action
.
sourceActors
)
{
state
.
mutableSourceActors
.
set
(
sourceActor
.
id
sourceActor
)
;
}
return
{
.
.
.
state
}
;
}
case
"
NAVIGATE
"
:
{
state
=
initialSourceActorsState
(
)
;
break
;
}
case
"
REMOVE_THREAD
"
:
{
for
(
const
sourceActor
of
state
.
mutableSourceActors
.
values
(
)
)
{
if
(
sourceActor
.
thread
=
=
action
.
threadActorID
)
{
state
.
mutableSourceActors
.
delete
(
sourceActor
.
id
)
;
}
}
return
{
.
.
.
state
}
;
}
case
"
SET_SOURCE_ACTOR_BREAKABLE_LINES
"
:
return
updateBreakableLines
(
state
action
)
;
case
"
CLEAR_SOURCE_ACTOR_MAP_URL
"
:
return
clearSourceActorMapURL
(
state
action
.
sourceActorId
)
;
}
return
state
;
}
function
clearSourceActorMapURL
(
state
sourceActorId
)
{
const
existingSourceActor
=
state
.
mutableSourceActors
.
get
(
sourceActorId
)
;
if
(
!
existingSourceActor
)
{
return
state
;
}
state
.
mutableSourceActors
.
set
(
sourceActorId
{
.
.
.
existingSourceActor
sourceMapURL
:
"
"
}
)
;
return
{
.
.
.
state
}
;
}
function
updateBreakableLines
(
state
action
)
{
const
value
=
asyncActionAsValue
(
action
)
;
const
{
sourceActorId
}
=
action
;
if
(
!
state
.
mutableSourceActors
.
has
(
sourceActorId
)
)
{
return
state
;
}
state
.
mutableBreakableLines
.
set
(
sourceActorId
value
)
;
return
{
.
.
.
state
}
;
}
