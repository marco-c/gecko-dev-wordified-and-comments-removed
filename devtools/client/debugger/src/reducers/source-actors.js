function
initialSourceActorsState
(
)
{
return
{
mutableSourceActors
:
new
Map
(
)
mutableBreakableLines
:
new
Map
(
)
mutableSourceActorsWithSourceMap
:
new
Set
(
)
}
;
}
export
const
initial
=
initialSourceActorsState
(
)
;
export
default
function
update
(
state
=
initialSourceActorsState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
INSERT_SOURCE_ACTORS
"
:
{
for
(
const
sourceActor
of
action
.
sourceActors
)
{
state
.
mutableSourceActors
.
set
(
sourceActor
.
id
sourceActor
)
;
if
(
sourceActor
.
sourceMapURL
)
{
state
.
mutableSourceActorsWithSourceMap
.
add
(
sourceActor
.
id
)
;
}
}
return
{
.
.
.
state
}
;
}
case
"
NAVIGATE
"
:
{
state
=
initialSourceActorsState
(
)
;
break
;
}
case
"
REMOVE_THREAD
"
:
{
for
(
const
sourceActor
of
state
.
mutableSourceActors
.
values
(
)
)
{
if
(
sourceActor
.
thread
=
=
action
.
threadActorID
)
{
state
.
mutableSourceActors
.
delete
(
sourceActor
.
id
)
;
state
.
mutableBreakableLines
.
delete
(
sourceActor
.
id
)
;
state
.
mutableSourceActorsWithSourceMap
.
delete
(
sourceActor
.
id
)
;
}
}
return
{
.
.
.
state
}
;
}
case
"
SET_SOURCE_ACTOR_BREAKABLE_LINES
"
:
return
updateBreakableLines
(
state
action
)
;
case
"
CLEAR_SOURCE_ACTOR_MAP_URL
"
:
if
(
state
.
mutableSourceActorsWithSourceMap
.
delete
(
action
.
sourceActorId
)
)
{
return
{
.
.
.
state
}
;
}
return
state
;
}
return
state
;
}
function
updateBreakableLines
(
state
action
)
{
const
{
sourceActorId
}
=
action
;
if
(
!
state
.
mutableSourceActors
.
has
(
sourceActorId
)
)
{
return
state
;
}
state
.
mutableBreakableLines
.
set
(
sourceActorId
action
.
breakableLines
)
;
return
{
.
.
.
state
}
;
}
