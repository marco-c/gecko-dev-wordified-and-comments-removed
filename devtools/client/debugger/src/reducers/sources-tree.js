const
IGNORED_URLS
=
[
"
debugger
eval
code
"
"
XStringBundle
"
]
;
const
IGNORED_EXTENSIONS
=
[
"
css
"
"
svg
"
"
png
"
]
;
import
{
isPretty
getRawSourceURL
}
from
"
.
.
/
utils
/
source
"
;
import
{
prefs
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
getDisplayURL
}
from
"
.
.
/
utils
/
sources
-
tree
/
getURL
"
;
import
TargetCommand
from
"
resource
:
/
/
devtools
/
shared
/
commands
/
target
/
target
-
command
.
js
"
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
BinarySearch
:
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
sys
.
mjs
"
}
)
;
export
function
initialSourcesTreeState
(
{
isWebExtension
mainThreadProjectDirectoryRoots
=
{
}
}
=
{
}
)
{
return
{
threadItems
:
[
]
expanded
:
new
Set
(
)
focusedItem
:
null
mainThreadProjectDirectoryRoots
projectDirectoryRoot
:
"
"
projectDirectoryRootName
:
"
"
projectDirectoryRootFullName
:
"
"
isWebExtension
showContentScripts
:
prefs
.
showContentScripts
mutableExtensionSources
:
[
]
}
;
}
export
default
function
update
(
state
=
initialSourcesTreeState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
SHOW_CONTENT_SCRIPTS
"
:
{
const
{
shouldShow
}
=
action
;
if
(
shouldShow
!
=
=
state
.
showExtensionSources
)
{
prefs
.
showContentScripts
=
shouldShow
;
return
{
.
.
.
state
showContentScripts
:
shouldShow
}
;
}
return
state
;
}
case
"
ADD_ORIGINAL_SOURCES
"
:
{
const
{
generatedSourceActor
}
=
action
;
const
validOriginalSources
=
action
.
originalSources
.
filter
(
source
=
>
{
if
(
source
.
isExtension
)
{
state
.
mutableExtensionSources
.
push
(
{
source
sourceActor
:
generatedSourceActor
}
)
;
}
return
isSourceVisibleInSourceTree
(
source
state
.
showContentScripts
state
.
isWebExtension
)
;
}
)
;
if
(
!
validOriginalSources
.
length
)
{
return
state
;
}
let
changed
=
false
;
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
for
(
const
source
of
validOriginalSources
)
{
changed
|
=
addSource
(
threadItems
source
generatedSourceActor
)
;
}
if
(
changed
)
{
return
{
.
.
.
state
threadItems
}
;
}
return
state
;
}
case
"
INSERT_SOURCE_ACTORS
"
:
{
const
newSourceActors
=
action
.
sourceActors
.
filter
(
sourceActor
=
>
{
if
(
sourceActor
.
sourceObject
.
isExtension
)
{
state
.
mutableExtensionSources
.
push
(
{
source
:
sourceActor
.
sourceObject
sourceActor
}
)
;
}
return
isSourceVisibleInSourceTree
(
sourceActor
.
sourceObject
state
.
showContentScripts
state
.
isWebExtension
)
;
}
)
;
if
(
!
newSourceActors
.
length
)
{
return
state
;
}
let
changed
=
false
;
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
for
(
const
sourceActor
of
newSourceActors
)
{
changed
|
=
addSource
(
threadItems
sourceActor
.
sourceObject
sourceActor
)
;
}
if
(
changed
)
{
return
{
.
.
.
state
threadItems
}
;
}
return
state
;
}
case
"
INSERT_THREAD
"
:
state
=
{
.
.
.
state
}
;
addThread
(
state
action
.
newThread
)
;
return
applyMainThreadProjectDirectoryRoot
(
state
action
.
newThread
)
;
case
"
REMOVE_THREAD
"
:
{
const
{
threadActorID
}
=
action
;
const
index
=
state
.
threadItems
.
findIndex
(
item
=
>
{
return
item
.
threadActorID
=
=
threadActorID
;
}
)
;
if
(
index
=
=
-
1
)
{
return
state
;
}
let
{
focusedItem
}
=
state
;
if
(
focusedItem
&
&
focusedItem
.
uniquePath
.
startsWith
(
threadActorID
)
)
{
focusedItem
=
null
;
}
const
expanded
=
new
Set
(
)
;
for
(
const
path
of
state
.
expanded
)
{
if
(
!
path
.
startsWith
(
threadActorID
)
)
{
expanded
.
add
(
path
)
;
}
}
let
{
projectDirectoryRoot
projectDirectoryRootName
projectDirectoryRootFullName
}
=
state
;
if
(
projectDirectoryRoot
.
startsWith
(
{
threadActorID
}
|
)
)
{
projectDirectoryRoot
=
"
"
;
projectDirectoryRootName
=
"
"
;
projectDirectoryRootFullName
=
"
"
;
}
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
threadItems
.
splice
(
index
1
)
;
return
{
.
.
.
state
threadItems
focusedItem
expanded
projectDirectoryRoot
projectDirectoryRootName
projectDirectoryRootFullName
}
;
}
case
"
SET_EXPANDED_STATE
"
:
return
updateExpanded
(
state
action
)
;
case
"
SET_FOCUSED_SOURCE_ITEM
"
:
return
{
.
.
.
state
focusedItem
:
action
.
item
}
;
case
"
SET_SELECTED_LOCATION
"
:
return
updateSelectedLocation
(
state
action
.
location
)
;
case
"
SET_PROJECT_DIRECTORY_ROOT
"
:
{
const
{
uniquePath
name
fullName
mainThread
}
=
action
;
return
updateProjectDirectoryRoot
(
state
uniquePath
name
fullName
mainThread
)
;
}
case
"
BLACKBOX_WHOLE_SOURCES
"
:
case
"
BLACKBOX_SOURCE_RANGES
"
:
{
const
sources
=
action
.
sources
|
|
[
action
.
source
]
;
return
updateBlackbox
(
state
sources
true
)
;
}
case
"
UNBLACKBOX_WHOLE_SOURCES
"
:
{
const
sources
=
action
.
sources
|
|
[
action
.
source
]
;
return
updateBlackbox
(
state
sources
false
)
;
}
}
return
state
;
}
function
addThread
(
state
thread
)
{
const
threadActorID
=
thread
.
actor
;
let
threadItem
=
state
.
threadItems
.
find
(
item
=
>
{
return
item
.
threadActorID
=
=
threadActorID
;
}
)
;
if
(
!
threadItem
)
{
threadItem
=
createThreadTreeItem
(
threadActorID
)
;
state
.
threadItems
=
[
.
.
.
state
.
threadItems
]
;
threadItem
.
thread
=
thread
;
addSortedItem
(
state
.
threadItems
threadItem
sortThreadItems
)
;
}
else
{
state
.
threadItems
=
[
.
.
.
state
.
threadItems
]
;
threadItem
.
thread
=
thread
;
state
.
threadItems
=
[
.
.
.
state
.
threadItems
]
;
state
.
threadItems
.
splice
(
state
.
threadItems
.
indexOf
(
threadItem
)
1
)
;
addSortedItem
(
state
.
threadItems
threadItem
sortThreadItems
)
;
}
}
function
updateBlackbox
(
state
sources
shouldBlackBox
)
{
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
for
(
const
source
of
sources
)
{
for
(
const
threadItem
of
threadItems
)
{
const
sourceTreeItem
=
findSourceInThreadItem
(
source
threadItem
)
;
if
(
sourceTreeItem
&
&
sourceTreeItem
.
isBlackBoxed
!
=
shouldBlackBox
)
{
const
{
children
}
=
sourceTreeItem
.
parent
;
children
.
splice
(
children
.
indexOf
(
sourceTreeItem
)
1
{
.
.
.
sourceTreeItem
isBlackBoxed
:
shouldBlackBox
}
)
;
threadItem
.
children
=
[
.
.
.
threadItem
.
children
]
;
}
}
}
return
{
.
.
.
state
threadItems
}
;
}
function
updateExpanded
(
state
action
)
{
return
{
.
.
.
state
expanded
:
action
.
expanded
}
;
}
function
updateProjectDirectoryRoot
(
state
uniquePath
name
fullName
mainThread
)
{
let
directoryRoots
=
state
.
mainThreadProjectDirectoryRoots
;
if
(
mainThread
)
{
const
{
origin
}
=
getDisplayURL
(
mainThread
.
url
)
;
if
(
origin
)
{
directoryRoots
=
{
.
.
.
directoryRoots
}
;
if
(
uniquePath
.
startsWith
(
{
mainThread
.
actor
}
|
)
)
{
directoryRoots
[
origin
]
=
{
uniquePath
:
uniquePath
.
substring
(
mainThread
.
actor
.
length
)
name
fullName
}
;
}
else
{
delete
directoryRoots
[
origin
]
;
}
}
}
return
{
.
.
.
state
mainThreadProjectDirectoryRoots
:
directoryRoots
projectDirectoryRoot
:
uniquePath
projectDirectoryRootName
:
name
projectDirectoryRootFullName
:
fullName
}
;
}
function
applyMainThreadProjectDirectoryRoot
(
state
thread
)
{
if
(
!
thread
.
isTopLevel
|
|
!
thread
.
url
)
{
return
state
;
}
const
{
origin
}
=
getDisplayURL
(
thread
.
url
)
;
if
(
!
origin
)
{
return
state
;
}
const
directoryRoot
=
state
.
mainThreadProjectDirectoryRoots
[
origin
]
;
const
uniquePath
=
directoryRoot
?
thread
.
actor
+
directoryRoot
.
uniquePath
:
"
"
;
const
name
=
directoryRoot
?
.
name
?
?
"
"
;
const
fullName
=
directoryRoot
?
.
fullName
?
?
"
"
;
return
{
.
.
.
state
projectDirectoryRoot
:
uniquePath
projectDirectoryRootName
:
name
projectDirectoryRootFullName
:
fullName
}
;
}
function
isSourceVisibleInSourceTree
(
source
showContentScripts
debuggeeIsWebExtension
)
{
return
(
!
!
source
.
url
&
&
!
IGNORED_EXTENSIONS
.
includes
(
source
.
displayURL
.
fileExtension
)
&
&
!
IGNORED_URLS
.
includes
(
source
.
url
)
&
&
!
isPretty
(
source
)
&
&
(
!
source
.
isExtension
|
|
showContentScripts
|
|
debuggeeIsWebExtension
)
)
;
}
function
addSortedItem
(
array
newValue
comparator
)
{
const
index
=
lazy
.
BinarySearch
.
insertionIndexOf
(
comparator
array
newValue
)
;
array
.
splice
(
index
0
newValue
)
;
}
function
addSource
(
threadItems
source
sourceActor
)
{
let
threadItem
=
threadItems
.
find
(
item
=
>
{
return
item
.
threadActorID
=
=
sourceActor
.
thread
;
}
)
;
if
(
!
threadItem
)
{
threadItem
=
createThreadTreeItem
(
sourceActor
.
thread
)
;
addSortedItem
(
threadItems
threadItem
sortThreadItems
)
;
}
const
{
displayURL
}
=
source
;
const
{
group
origin
}
=
displayURL
;
let
groupItem
=
threadItem
.
children
.
find
(
item
=
>
{
return
item
.
groupName
=
=
group
;
}
)
;
if
(
!
groupItem
)
{
groupItem
=
createGroupTreeItem
(
group
origin
threadItem
source
)
;
threadItem
.
children
=
[
.
.
.
threadItem
.
children
]
;
addSortedItem
(
threadItem
.
children
groupItem
sortItems
)
;
}
const
{
path
}
=
displayURL
;
const
parentPath
=
path
.
substring
(
0
path
.
lastIndexOf
(
"
/
"
)
)
;
const
parentUrl
=
source
.
url
.
substring
(
0
source
.
url
.
lastIndexOf
(
"
/
"
)
)
;
const
directoryItem
=
addOrGetParentDirectory
(
groupItem
parentPath
parentUrl
)
;
const
existing
=
directoryItem
.
children
.
find
(
item
=
>
{
return
item
.
type
=
=
"
source
"
&
&
item
.
source
=
=
source
;
}
)
;
if
(
existing
)
{
return
false
;
}
const
sourceItem
=
createSourceTreeItem
(
source
sourceActor
directoryItem
)
;
directoryItem
.
children
=
[
.
.
.
directoryItem
.
children
]
;
addSortedItem
(
directoryItem
.
children
sourceItem
sortItems
)
;
return
true
;
}
function
findSourceInThreadItem
(
source
threadItem
)
{
const
{
displayURL
}
=
source
;
const
{
group
path
}
=
displayURL
;
const
groupItem
=
threadItem
.
children
.
find
(
item
=
>
{
return
item
.
groupName
=
=
group
;
}
)
;
if
(
!
groupItem
)
{
return
null
;
}
const
parentPath
=
path
.
substring
(
0
path
.
lastIndexOf
(
"
/
"
)
)
;
if
(
!
parentPath
)
{
return
groupItem
.
children
.
find
(
item
=
>
{
return
item
.
type
=
=
"
source
"
&
&
item
.
source
=
=
source
;
}
)
;
}
const
directoryItem
=
groupItem
.
_allGroupDirectoryItems
.
find
(
item
=
>
{
return
item
.
type
=
=
"
directory
"
&
&
item
.
path
=
=
parentPath
;
}
)
;
if
(
!
directoryItem
)
{
return
null
;
}
return
directoryItem
.
children
.
find
(
item
=
>
{
return
item
.
type
=
=
"
source
"
&
&
item
.
source
=
=
source
;
}
)
;
}
function
sortItems
(
a
b
)
{
if
(
a
.
type
=
=
"
directory
"
&
&
b
.
type
=
=
"
source
"
)
{
return
-
1
;
}
else
if
(
b
.
type
=
=
"
directory
"
&
&
a
.
type
=
=
"
source
"
)
{
return
1
;
}
else
if
(
a
.
type
=
=
"
group
"
&
&
b
.
type
=
=
"
group
"
)
{
return
a
.
groupName
.
localeCompare
(
b
.
groupName
)
;
}
else
if
(
a
.
type
=
=
"
directory
"
&
&
b
.
type
=
=
"
directory
"
)
{
return
a
.
path
.
localeCompare
(
b
.
path
)
;
}
else
if
(
a
.
type
=
=
"
source
"
&
&
b
.
type
=
=
"
source
"
)
{
return
a
.
source
.
longName
.
localeCompare
(
b
.
source
.
longName
)
;
}
return
0
;
}
const
{
TYPES
}
=
TargetCommand
;
const
TARGET_TYPE_ORDER
=
[
TYPES
.
PROCESS
TYPES
.
FRAME
TYPES
.
CONTENT_SCRIPT
TYPES
.
SERVICE_WORKER
TYPES
.
SHARED_WORKER
TYPES
.
WORKER
]
;
function
sortThreadItems
(
threadItemA
threadItemB
)
{
if
(
!
threadItemA
.
thread
|
|
!
threadItemB
.
thread
)
{
return
0
;
}
return
sortThreads
(
threadItemA
.
thread
threadItemB
.
thread
)
;
}
export
function
sortThreads
(
a
b
)
{
if
(
a
.
isTopLevel
)
{
return
-
1
;
}
else
if
(
b
.
isTopLevel
)
{
return
1
;
}
if
(
a
.
innerWindowId
>
b
.
innerWindowId
)
{
return
1
;
}
else
if
(
a
.
innerWindowId
<
b
.
innerWindowId
)
{
return
-
1
;
}
if
(
a
.
targetType
!
=
=
b
.
targetType
)
{
const
idxA
=
TARGET_TYPE_ORDER
.
indexOf
(
a
.
targetType
)
;
const
idxB
=
TARGET_TYPE_ORDER
.
indexOf
(
b
.
targetType
)
;
return
idxA
<
idxB
?
-
1
:
1
;
}
if
(
a
.
processID
&
&
b
.
processID
)
{
if
(
a
.
processID
>
b
.
processID
)
{
return
1
;
}
else
if
(
a
.
processID
<
b
.
processID
)
{
return
-
1
;
}
}
if
(
(
a
.
targetType
=
=
"
frame
"
&
&
b
.
targetType
=
=
"
frame
"
)
|
|
(
a
.
targetType
.
endsWith
(
"
worker
"
)
&
&
b
.
targetType
.
endsWith
(
"
worker
"
)
)
|
|
(
a
.
targetType
=
=
"
content_script
"
&
&
b
.
targetType
=
=
"
content_script
"
)
)
{
return
a
.
name
.
localeCompare
(
b
.
name
)
;
}
return
0
;
}
function
addOrGetParentDirectory
(
groupItem
path
url
)
{
if
(
!
path
)
{
return
groupItem
;
}
const
existing
=
groupItem
.
_allGroupDirectoryItems
.
find
(
item
=
>
{
return
item
.
type
=
=
"
directory
"
&
&
item
.
path
=
=
path
;
}
)
;
if
(
existing
)
{
return
existing
;
}
const
parentPath
=
path
.
substring
(
0
path
.
lastIndexOf
(
"
/
"
)
)
;
const
parentUrl
=
url
.
substring
(
0
url
.
lastIndexOf
(
"
/
"
)
)
;
const
parentDirectory
=
addOrGetParentDirectory
(
groupItem
parentPath
parentUrl
)
;
const
directory
=
createDirectoryTreeItem
(
path
url
parentDirectory
)
;
parentDirectory
.
children
=
[
.
.
.
parentDirectory
.
children
]
;
addSortedItem
(
parentDirectory
.
children
directory
sortItems
)
;
groupItem
.
_allGroupDirectoryItems
.
push
(
directory
)
;
return
directory
;
}
function
createBaseTreeItem
(
{
type
parent
uniquePath
children
}
)
{
return
{
type
parent
uniquePath
children
}
;
}
function
createThreadTreeItem
(
thread
)
{
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
thread
"
parent
:
null
uniquePath
:
thread
children
:
[
]
}
)
threadActorID
:
thread
}
;
}
function
createGroupTreeItem
(
groupName
origin
parent
source
)
{
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
group
"
parent
uniquePath
:
{
parent
.
uniquePath
}
|
{
groupName
}
children
:
[
]
}
)
groupName
url
:
origin
isForExtensionSource
:
source
.
isExtension
_allGroupDirectoryItems
:
[
]
}
;
}
function
createDirectoryTreeItem
(
path
url
parent
)
{
const
pathSeparator
=
parent
.
type
=
=
"
directory
"
?
"
/
"
:
"
|
"
;
const
relativePath
=
parent
.
type
=
=
"
directory
"
?
path
.
replace
(
parent
.
path
"
"
)
.
replace
(
/
^
\
/
/
"
"
)
:
path
;
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
directory
"
parent
uniquePath
:
{
parent
.
uniquePath
}
{
pathSeparator
}
{
relativePath
}
children
:
[
]
}
)
path
url
}
;
}
function
createSourceTreeItem
(
source
sourceActor
parent
)
{
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
source
"
parent
uniquePath
:
{
parent
.
uniquePath
}
|
{
source
.
id
}
children
:
null
}
)
source
sourceActor
}
;
}
function
updateSelectedLocation
(
state
selectedLocation
)
{
const
sourceItem
=
getSourceItemForSelectedLocation
(
state
selectedLocation
)
;
if
(
sourceItem
)
{
const
expanded
=
new
Set
(
state
.
expanded
)
;
let
parentDirectory
=
sourceItem
;
while
(
parentDirectory
)
{
expanded
.
add
(
parentDirectory
.
uniquePath
)
;
parentDirectory
=
parentDirectory
.
parent
;
}
return
{
.
.
.
state
expanded
focusedItem
:
sourceItem
}
;
}
return
state
;
}
function
getSourceItemForSelectedLocation
(
state
selectedLocation
)
{
const
{
source
sourceActor
}
=
selectedLocation
;
if
(
!
source
.
url
)
{
return
null
;
}
const
sourceUrl
=
getRawSourceURL
(
source
.
url
)
;
const
{
displayURL
}
=
source
;
function
findSourceInItem
(
item
path
)
{
if
(
item
.
type
=
=
"
source
"
)
{
if
(
item
.
source
.
url
=
=
sourceUrl
)
{
return
item
;
}
return
null
;
}
if
(
item
.
type
=
=
"
thread
"
&
&
item
.
threadActorID
!
=
sourceActor
?
.
thread
)
{
return
null
;
}
if
(
item
.
type
=
=
"
group
"
&
&
displayURL
.
group
!
=
item
.
groupName
)
{
return
null
;
}
if
(
item
.
type
=
=
"
directory
"
&
&
!
path
.
startsWith
(
item
.
path
)
)
{
return
null
;
}
for
(
const
child
of
item
.
children
)
{
const
match
=
findSourceInItem
(
child
path
)
;
if
(
match
)
{
return
match
;
}
}
return
null
;
}
for
(
const
rootItem
of
state
.
threadItems
)
{
const
item
=
findSourceInItem
(
rootItem
displayURL
.
path
)
;
if
(
item
)
{
return
item
;
}
}
return
null
;
}
