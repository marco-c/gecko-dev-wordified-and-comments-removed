const
IGNORED_URLS
=
[
"
debugger
eval
code
"
"
XStringBundle
"
]
;
const
IGNORED_EXTENSIONS
=
[
"
css
"
"
svg
"
"
png
"
]
;
import
{
isPretty
}
from
"
.
.
/
utils
/
source
"
;
import
{
prefs
}
from
"
.
.
/
utils
/
prefs
"
;
export
function
initialSourcesTreeState
(
)
{
return
{
threadItems
:
[
]
expanded
:
new
Set
(
)
focusedItem
:
null
projectDirectoryRoot
:
prefs
.
projectDirectoryRoot
projectDirectoryRootName
:
prefs
.
projectDirectoryRootName
isWebExtension
:
false
chromeAndExtensionsEnabled
:
prefs
.
chromeAndExtensionsEnabled
}
;
}
export
default
function
update
(
state
=
initialSourcesTreeState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
ADD_ORIGINAL_SOURCES
"
:
{
const
{
generatedSourceActor
}
=
action
;
const
validOriginalSources
=
action
.
originalSources
.
filter
(
source
=
>
isSourceVisibleInSourceTree
(
source
state
.
chromeAndExtensionsEnabled
state
.
isWebExtension
)
)
;
if
(
!
validOriginalSources
.
length
)
{
return
state
;
}
let
changed
=
false
;
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
for
(
const
source
of
validOriginalSources
)
{
changed
|
=
addSource
(
threadItems
source
generatedSourceActor
)
;
}
if
(
changed
)
{
return
{
.
.
.
state
threadItems
}
;
}
return
state
;
}
case
"
INSERT_SOURCE_ACTORS
"
:
{
const
newSourceActors
=
action
.
sourceActors
.
filter
(
sourceActor
=
>
isSourceVisibleInSourceTree
(
sourceActor
.
sourceObject
state
.
chromeAndExtensionsEnabled
state
.
isWebExtension
)
)
;
if
(
!
newSourceActors
.
length
)
{
return
state
;
}
let
changed
=
false
;
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
for
(
const
sourceActor
of
newSourceActors
)
{
changed
|
=
addSource
(
threadItems
sourceActor
.
sourceObject
sourceActor
)
;
}
if
(
changed
)
{
return
{
.
.
.
state
threadItems
}
;
}
return
state
;
}
case
"
INSERT_THREAD
"
:
state
=
{
.
.
.
state
}
;
addThread
(
state
action
.
newThread
)
;
return
state
;
case
"
REMOVE_THREAD
"
:
{
const
{
threadActorID
}
=
action
;
const
index
=
state
.
threadItems
.
findIndex
(
item
=
>
{
return
item
.
threadActorID
=
=
threadActorID
;
}
)
;
if
(
index
=
=
-
1
)
{
return
state
;
}
let
{
focusedItem
}
=
state
;
if
(
focusedItem
&
&
focusedItem
.
uniquePath
.
startsWith
(
threadActorID
)
)
{
focusedItem
=
null
;
}
const
expanded
=
new
Set
(
)
;
for
(
const
path
of
state
.
expanded
)
{
if
(
!
path
.
startsWith
(
threadActorID
)
)
{
expanded
.
add
(
path
)
;
}
}
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
threadItems
.
splice
(
index
1
)
;
return
{
.
.
.
state
threadItems
focusedItem
expanded
}
;
}
case
"
SET_EXPANDED_STATE
"
:
return
updateExpanded
(
state
action
)
;
case
"
SET_FOCUSED_SOURCE_ITEM
"
:
return
{
.
.
.
state
focusedItem
:
action
.
item
}
;
case
"
SET_PROJECT_DIRECTORY_ROOT
"
:
const
{
uniquePath
name
}
=
action
;
return
updateProjectDirectoryRoot
(
state
uniquePath
name
)
;
case
"
BLACKBOX_WHOLE_SOURCES
"
:
case
"
BLACKBOX_SOURCE_RANGES
"
:
{
const
sources
=
action
.
sources
|
|
[
action
.
source
]
;
return
updateBlackbox
(
state
sources
true
)
;
}
case
"
UNBLACKBOX_WHOLE_SOURCES
"
:
{
const
sources
=
action
.
sources
|
|
[
action
.
source
]
;
return
updateBlackbox
(
state
sources
false
)
;
}
}
return
state
;
}
function
addThread
(
state
thread
)
{
const
threadActorID
=
thread
.
actor
;
if
(
thread
.
isTopLevel
)
{
state
.
isWebExtension
=
thread
.
isWebExtension
;
}
let
threadItem
=
state
.
threadItems
.
find
(
item
=
>
{
return
item
.
threadActorID
=
=
threadActorID
;
}
)
;
if
(
!
threadItem
)
{
threadItem
=
createThreadTreeItem
(
threadActorID
)
;
state
.
threadItems
=
[
.
.
.
state
.
threadItems
threadItem
]
;
}
else
{
state
.
threadItems
=
[
.
.
.
state
.
threadItems
]
;
}
threadItem
.
thread
=
thread
;
state
.
threadItems
.
sort
(
sortThreadItems
)
;
}
function
updateBlackbox
(
state
sources
shouldBlackBox
)
{
const
threadItems
=
[
.
.
.
state
.
threadItems
]
;
for
(
const
source
of
sources
)
{
for
(
const
threadItem
of
threadItems
)
{
const
sourceTreeItem
=
findSourceInThreadItem
(
source
threadItem
)
;
if
(
sourceTreeItem
)
{
sourceTreeItem
.
isBlackBoxed
=
shouldBlackBox
;
}
}
}
return
{
.
.
.
state
threadItems
}
;
}
function
updateExpanded
(
state
action
)
{
return
{
.
.
.
state
expanded
:
new
Set
(
action
.
expanded
)
}
;
}
function
updateProjectDirectoryRoot
(
state
uniquePath
name
)
{
if
(
!
uniquePath
|
|
uniquePath
.
startsWith
(
"
top
-
level
"
)
)
{
prefs
.
projectDirectoryRoot
=
uniquePath
;
prefs
.
projectDirectoryRootName
=
name
;
}
return
{
.
.
.
state
projectDirectoryRoot
:
uniquePath
projectDirectoryRootName
:
name
}
;
}
function
isSourceVisibleInSourceTree
(
source
chromeAndExtensionsEnabled
debuggeeIsWebExtension
)
{
return
(
!
!
source
.
url
&
&
!
IGNORED_EXTENSIONS
.
includes
(
source
.
displayURL
.
fileExtension
)
&
&
!
IGNORED_URLS
.
includes
(
source
.
url
)
&
&
!
isPretty
(
source
)
&
&
(
!
source
.
isExtension
|
|
chromeAndExtensionsEnabled
|
|
debuggeeIsWebExtension
)
)
;
}
function
addSource
(
threadItems
source
sourceActor
)
{
let
threadItem
=
threadItems
.
find
(
item
=
>
{
return
item
.
threadActorID
=
=
sourceActor
.
thread
;
}
)
;
if
(
!
threadItem
)
{
threadItem
=
createThreadTreeItem
(
sourceActor
.
thread
)
;
threadItems
.
push
(
threadItem
)
;
threadItems
.
sort
(
sortThreadItems
)
;
}
const
{
displayURL
}
=
source
;
const
{
group
}
=
displayURL
;
let
groupItem
=
threadItem
.
children
.
find
(
item
=
>
{
return
item
.
groupName
=
=
group
;
}
)
;
if
(
!
groupItem
)
{
groupItem
=
createGroupTreeItem
(
group
threadItem
source
)
;
threadItem
.
children
=
[
.
.
.
threadItem
.
children
groupItem
]
;
threadItem
.
children
.
sort
(
sortItems
)
;
}
const
{
path
}
=
displayURL
;
const
parentPath
=
path
.
substring
(
0
path
.
lastIndexOf
(
"
/
"
)
)
;
const
directoryItem
=
addOrGetParentDirectory
(
groupItem
parentPath
)
;
const
existing
=
directoryItem
.
children
.
find
(
item
=
>
{
return
item
.
type
=
=
"
source
"
&
&
item
.
source
=
=
source
;
}
)
;
if
(
existing
)
{
return
false
;
}
const
sourceItem
=
createSourceTreeItem
(
source
sourceActor
directoryItem
)
;
directoryItem
.
children
=
[
.
.
.
directoryItem
.
children
sourceItem
]
;
directoryItem
.
children
.
sort
(
sortItems
)
;
return
true
;
}
function
findSourceInThreadItem
(
source
threadItem
)
{
const
{
displayURL
}
=
source
;
const
{
group
path
}
=
displayURL
;
const
groupItem
=
threadItem
.
children
.
find
(
item
=
>
{
return
item
.
groupName
=
=
group
;
}
)
;
if
(
!
groupItem
)
return
null
;
const
parentPath
=
path
.
substring
(
0
path
.
lastIndexOf
(
"
/
"
)
)
;
const
directoryItem
=
groupItem
.
_allGroupDirectoryItems
.
find
(
item
=
>
{
return
item
.
type
=
=
"
directory
"
&
&
item
.
path
=
=
parentPath
;
}
)
;
if
(
!
directoryItem
)
return
null
;
return
directoryItem
.
children
.
find
(
item
=
>
{
return
item
.
type
=
=
"
source
"
&
&
item
.
source
=
=
source
;
}
)
;
}
function
sortItems
(
a
b
)
{
if
(
a
.
type
=
=
"
directory
"
&
&
b
.
type
=
=
"
source
"
)
{
return
-
1
;
}
else
if
(
b
.
type
=
=
"
directory
"
&
&
a
.
type
=
=
"
source
"
)
{
return
1
;
}
else
if
(
a
.
type
=
=
"
directory
"
&
&
b
.
type
=
=
"
directory
"
)
{
return
a
.
path
.
localeCompare
(
b
.
path
)
;
}
else
if
(
a
.
type
=
=
"
source
"
&
&
b
.
type
=
=
"
source
"
)
{
return
a
.
source
.
displayURL
.
filename
.
localeCompare
(
b
.
source
.
displayURL
.
filename
)
;
}
return
0
;
}
function
sortThreadItems
(
a
b
)
{
if
(
!
a
.
thread
|
|
!
b
.
thread
)
{
return
0
;
}
if
(
a
.
thread
.
isTopLevel
)
{
return
-
1
;
}
else
if
(
b
.
thread
.
isTopLevel
)
{
return
1
;
}
if
(
a
.
thread
.
targetType
=
=
"
process
"
&
&
b
.
thread
.
targetType
=
=
"
frame
"
)
{
return
-
1
;
}
else
if
(
a
.
thread
.
targetType
=
=
"
frame
"
&
&
b
.
thread
.
targetType
=
=
"
process
"
)
{
return
1
;
}
if
(
a
.
thread
.
targetType
.
endsWith
(
"
worker
"
)
&
&
!
b
.
thread
.
targetType
.
endsWith
(
"
worker
"
)
)
{
return
1
;
}
else
if
(
!
a
.
thread
.
targetType
.
endsWith
(
"
worker
"
)
&
&
b
.
thread
.
targetType
.
endsWith
(
"
worker
"
)
)
{
return
-
1
;
}
if
(
a
.
thread
.
processID
>
b
.
thread
.
processID
)
{
return
1
;
}
else
if
(
a
.
thread
.
processID
<
b
.
thread
.
processID
)
{
return
0
;
}
if
(
a
.
thread
.
targetType
=
=
"
frame
"
&
&
b
.
thread
.
targetType
=
=
"
frame
"
)
{
return
a
.
thread
.
name
.
localeCompare
(
b
.
thread
.
name
)
;
}
else
if
(
a
.
thread
.
targetType
.
endsWith
(
"
worker
"
)
&
&
b
.
thread
.
targetType
.
endsWith
(
"
worker
"
)
)
{
return
a
.
thread
.
name
.
localeCompare
(
b
.
thread
.
name
)
;
}
return
0
;
}
function
addOrGetParentDirectory
(
groupItem
path
)
{
if
(
!
path
)
{
return
groupItem
;
}
const
existing
=
groupItem
.
_allGroupDirectoryItems
.
find
(
item
=
>
{
return
item
.
type
=
=
"
directory
"
&
&
item
.
path
=
=
path
;
}
)
;
if
(
existing
)
{
return
existing
;
}
const
parentPath
=
path
.
substring
(
0
path
.
lastIndexOf
(
"
/
"
)
)
;
const
parentDirectory
=
addOrGetParentDirectory
(
groupItem
parentPath
)
;
const
directory
=
createDirectoryTreeItem
(
path
parentDirectory
)
;
parentDirectory
.
children
=
[
.
.
.
parentDirectory
.
children
directory
]
;
parentDirectory
.
children
.
sort
(
sortItems
)
;
groupItem
.
_allGroupDirectoryItems
.
push
(
directory
)
;
return
directory
;
}
function
createBaseTreeItem
(
{
type
parent
uniquePath
children
}
)
{
return
{
type
parent
uniquePath
children
}
;
}
function
createThreadTreeItem
(
thread
)
{
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
thread
"
parent
:
null
uniquePath
:
thread
children
:
[
]
}
)
threadActorID
:
thread
}
;
}
function
createGroupTreeItem
(
groupName
parent
source
)
{
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
group
"
parent
uniquePath
:
{
parent
.
uniquePath
}
|
{
groupName
}
children
:
[
]
}
)
groupName
isForExtensionSource
:
source
.
isExtension
_allGroupDirectoryItems
:
[
]
}
;
}
function
createDirectoryTreeItem
(
path
parent
)
{
const
pathSeparator
=
parent
.
type
=
=
"
directory
"
?
"
/
"
:
"
|
"
;
const
relativePath
=
parent
.
type
=
=
"
directory
"
?
path
.
replace
(
parent
.
path
"
"
)
.
replace
(
/
^
\
/
/
"
"
)
:
path
;
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
directory
"
parent
uniquePath
:
{
parent
.
uniquePath
}
{
pathSeparator
}
{
relativePath
}
children
:
[
]
}
)
path
}
;
}
function
createSourceTreeItem
(
source
sourceActor
parent
)
{
return
{
.
.
.
createBaseTreeItem
(
{
type
:
"
source
"
parent
uniquePath
:
{
parent
.
uniquePath
}
|
{
source
.
id
}
children
:
null
}
)
source
sourceActor
}
;
}
