export
function
initialSourceBlackBoxState
(
state
)
{
return
{
blackboxedRanges
:
state
?
.
blackboxedRanges
?
?
{
}
blackboxedSet
:
state
?
.
blackboxedRanges
?
new
Set
(
Object
.
keys
(
state
.
blackboxedRanges
)
)
:
new
Set
(
)
}
;
}
function
update
(
state
=
initialSourceBlackBoxState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
BLACKBOX_WHOLE_SOURCES
"
:
{
const
{
sources
}
=
action
;
const
currentBlackboxedRanges
=
{
.
.
.
state
.
blackboxedRanges
}
;
const
currentBlackboxedSet
=
new
Set
(
state
.
blackboxedSet
)
;
for
(
const
source
of
sources
)
{
currentBlackboxedRanges
[
source
.
url
]
=
[
]
;
currentBlackboxedSet
.
add
(
source
.
url
)
;
}
return
{
.
.
.
state
blackboxedRanges
:
currentBlackboxedRanges
blackboxedSet
:
currentBlackboxedSet
}
;
}
case
"
BLACKBOX_SOURCE_RANGES
"
:
{
const
{
source
ranges
}
=
action
;
const
currentBlackboxedRanges
=
{
.
.
.
state
.
blackboxedRanges
}
;
const
currentBlackboxedSet
=
new
Set
(
state
.
blackboxedSet
)
;
if
(
!
currentBlackboxedRanges
[
source
.
url
]
)
{
currentBlackboxedRanges
[
source
.
url
]
=
[
]
;
currentBlackboxedSet
.
add
(
source
.
url
)
;
}
else
{
currentBlackboxedRanges
[
source
.
url
]
=
[
.
.
.
state
.
blackboxedRanges
[
source
.
url
]
]
;
}
for
(
const
newRange
of
ranges
)
{
const
index
=
currentBlackboxedRanges
[
source
.
url
]
.
findIndex
(
range
=
>
range
.
end
.
line
<
=
newRange
.
start
.
line
&
&
range
.
end
.
column
<
=
newRange
.
start
.
column
)
;
currentBlackboxedRanges
[
source
.
url
]
.
splice
(
index
+
1
0
newRange
)
;
}
return
{
.
.
.
state
blackboxedRanges
:
currentBlackboxedRanges
blackboxedSet
:
currentBlackboxedSet
}
;
}
case
"
UNBLACKBOX_WHOLE_SOURCES
"
:
{
const
{
sources
}
=
action
;
const
currentBlackboxedRanges
=
{
.
.
.
state
.
blackboxedRanges
}
;
const
currentBlackboxedSet
=
new
Set
(
state
.
blackboxedSet
)
;
for
(
const
source
of
sources
)
{
delete
currentBlackboxedRanges
[
source
.
url
]
;
currentBlackboxedSet
.
delete
(
source
.
url
)
;
}
return
{
.
.
.
state
blackboxedRanges
:
currentBlackboxedRanges
blackboxedSet
:
currentBlackboxedSet
}
;
}
case
"
UNBLACKBOX_SOURCE_RANGES
"
:
{
const
{
source
ranges
}
=
action
;
const
currentBlackboxedRanges
=
{
.
.
.
state
.
blackboxedRanges
[
source
.
url
]
:
[
.
.
.
state
.
blackboxedRanges
[
source
.
url
]
]
}
;
for
(
const
newRange
of
ranges
)
{
const
index
=
currentBlackboxedRanges
[
source
.
url
]
.
findIndex
(
range
=
>
range
.
start
.
line
=
=
=
newRange
.
start
.
line
&
&
range
.
end
.
line
=
=
=
newRange
.
end
.
line
)
;
if
(
index
!
=
=
-
1
)
{
currentBlackboxedRanges
[
source
.
url
]
.
splice
(
index
1
)
;
}
}
return
{
.
.
.
state
blackboxedRanges
:
currentBlackboxedRanges
}
;
}
case
"
NAVIGATE
"
:
return
initialSourceBlackBoxState
(
state
)
;
}
return
state
;
}
export
default
update
;
