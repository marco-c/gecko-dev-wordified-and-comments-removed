import
{
pending
fulfilled
rejected
}
from
"
.
.
/
utils
/
async
-
value
"
;
export
function
initialSourcesContentState
(
)
{
return
{
mutableOriginalSourceTextContentMapBySourceId
:
new
Map
(
)
mutableGeneratedSourceTextContentMapBySourceActorId
:
new
Map
(
)
epoch
:
1
}
;
}
function
update
(
state
=
initialSourcesContentState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
LOAD_ORIGINAL_SOURCE_TEXT
"
:
if
(
!
action
.
sourceId
)
{
throw
new
Error
(
"
No
source
id
found
.
"
)
;
}
return
updateSourceTextContent
(
state
action
)
;
case
"
LOAD_GENERATED_SOURCE_TEXT
"
:
if
(
!
action
.
sourceActorId
)
{
throw
new
Error
(
"
No
source
actor
id
found
.
"
)
;
}
return
updateSourceTextContent
(
state
action
)
;
case
"
REMOVE_THREAD
"
:
return
removeThread
(
state
action
)
;
case
"
NAVIGATE
"
:
return
{
.
.
.
initialSourcesContentState
(
)
epoch
:
state
.
epoch
+
1
}
;
}
return
state
;
}
function
updateSourceTextContent
(
state
action
)
{
if
(
action
.
epoch
!
=
=
state
.
epoch
)
{
return
state
;
}
let
content
;
if
(
action
.
status
=
=
=
"
start
"
)
{
content
=
pending
(
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
)
{
content
=
rejected
(
action
.
error
)
;
}
else
if
(
typeof
action
.
value
.
text
=
=
=
"
string
"
)
{
content
=
fulfilled
(
{
type
:
"
text
"
value
:
action
.
value
.
text
contentType
:
action
.
value
.
contentType
}
)
;
}
else
{
content
=
fulfilled
(
{
type
:
"
wasm
"
value
:
action
.
value
.
text
}
)
;
}
if
(
action
.
sourceId
&
&
action
.
sourceActorId
)
{
throw
new
Error
(
"
Both
the
source
id
and
the
source
actor
should
not
exist
at
the
same
time
"
)
;
}
if
(
action
.
sourceId
)
{
state
.
mutableOriginalSourceTextContentMapBySourceId
.
set
(
action
.
sourceId
content
)
;
}
if
(
action
.
sourceActorId
)
{
state
.
mutableGeneratedSourceTextContentMapBySourceActorId
.
set
(
action
.
sourceActorId
content
)
;
}
return
{
.
.
.
state
}
;
}
function
removeThread
(
state
action
)
{
const
originalSizeBefore
=
state
.
mutableOriginalSourceTextContentMapBySourceId
.
size
;
for
(
const
source
of
action
.
sources
)
{
state
.
mutableOriginalSourceTextContentMapBySourceId
.
delete
(
source
.
id
)
;
}
const
generatedSizeBefore
=
state
.
mutableGeneratedSourceTextContentMapBySourceActorId
.
size
;
for
(
const
actor
of
action
.
actors
)
{
state
.
mutableGeneratedSourceTextContentMapBySourceActorId
.
delete
(
actor
.
id
)
;
}
if
(
originalSizeBefore
!
=
state
.
mutableOriginalSourceTextContentMapBySourceId
.
size
|
|
generatedSizeBefore
!
=
state
.
mutableGeneratedSourceTextContentMapBySourceActorId
.
size
)
{
return
{
.
.
.
state
}
;
}
return
state
;
}
export
default
update
;
