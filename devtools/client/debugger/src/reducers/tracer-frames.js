const
{
TRACER_FIELDS_INDEXES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
.
js
"
)
;
function
initialState
(
)
{
return
{
mutableTraces
:
[
]
mutableChildren
:
[
]
mutableParents
:
[
]
mutableFrames
:
[
]
mutableTopTraces
:
[
]
mutableMutationTraces
:
[
]
selectedTraceIndex
:
null
previews
:
null
localPlatformVersion
:
null
remotePlatformVersion
:
null
}
;
}
function
update
(
state
=
initialState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
TRACING_TOGGLED
"
:
{
if
(
action
.
enabled
)
{
return
initialState
(
)
;
}
return
state
;
}
case
"
TRACING_CLEAR
"
:
{
return
initialState
(
)
;
}
case
"
ADD_TRACES
"
:
{
addTraces
(
state
action
.
traces
)
;
return
{
.
.
.
state
}
;
}
case
"
SELECT_TRACE
"
:
{
const
{
traceIndex
}
=
action
;
if
(
traceIndex
<
0
|
|
traceIndex
>
=
state
.
mutableTraces
.
length
|
|
traceIndex
=
=
state
.
selectedTraceIndex
)
{
return
state
;
}
const
trace
=
state
.
mutableTraces
[
traceIndex
]
;
return
{
.
.
.
state
selectedTraceIndex
:
traceIndex
previews
:
generatePreviewsForTrace
(
state
trace
)
}
;
}
case
"
SELECT_FRAME
"
:
case
"
PAUSED
"
:
{
if
(
!
state
.
previews
&
&
state
.
selectedTraceIndex
=
=
null
)
{
return
state
;
}
return
{
.
.
.
state
selectedTraceIndex
:
null
previews
:
null
}
;
}
case
"
SET_SELECTED_LOCATION
"
:
{
if
(
action
.
location
.
source
.
isOriginal
)
return
state
;
if
(
state
.
selectedTrace
&
&
locationMatchTrace
(
action
.
location
state
.
selectedTrace
)
)
{
return
state
;
}
for
(
const
trace
of
state
.
mutableTraces
)
{
if
(
locationMatchTrace
(
action
.
location
trace
)
)
{
return
{
.
.
.
state
selectedTrace
:
trace
}
;
}
}
return
{
.
.
.
state
selectedTrace
:
null
}
;
}
case
"
SET_GENERATED_SELECTED_LOCATION
"
:
{
if
(
state
.
selectedTrace
&
&
locationMatchTrace
(
action
.
generatedLocation
state
.
selectedTrace
)
)
{
return
state
;
}
for
(
const
trace
of
state
.
mutableTraces
)
{
if
(
locationMatchTrace
(
action
.
generatedLocation
trace
)
)
{
return
{
.
.
.
state
selectedTrace
:
trace
}
;
}
}
return
{
.
.
.
state
selectedTrace
:
null
}
;
}
case
"
CLEAR_SELECTED_LOCATION
"
:
{
return
{
.
.
.
state
selectedTrace
:
null
}
;
}
case
"
SET_RUNTIME_VERSIONS
"
:
{
return
{
.
.
.
state
localPlatformVersion
:
action
.
localPlatformVersion
remotePlatformVersion
:
action
.
remotePlatformVersion
}
;
}
}
return
state
;
}
function
addTraces
(
state
traces
)
{
const
{
mutableTraces
mutableMutationTraces
mutableFrames
mutableTopTraces
mutableChildren
mutableParents
}
=
state
;
function
matchParent
(
traceIndex
depth
)
{
let
idx
=
mutableTraces
.
length
-
2
;
while
(
idx
!
=
null
)
{
const
trace
=
mutableTraces
[
idx
]
;
if
(
!
trace
)
{
break
;
}
const
currentDepth
=
trace
[
TRACER_FIELDS_INDEXES
.
DEPTH
]
;
if
(
currentDepth
<
depth
)
{
mutableChildren
[
idx
]
.
push
(
traceIndex
)
;
mutableParents
.
push
(
idx
)
;
return
;
}
idx
=
mutableParents
[
idx
]
;
}
mutableTopTraces
.
push
(
traceIndex
)
;
mutableParents
.
push
(
null
)
;
}
for
(
const
traceResource
of
traces
)
{
if
(
!
traceResource
.
targetFront
.
isTopLevel
)
{
continue
;
}
const
type
=
traceResource
[
TRACER_FIELDS_INDEXES
.
TYPE
]
;
switch
(
type
)
{
case
"
frame
"
:
{
mutableFrames
.
push
(
{
functionDisplayName
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_NAME
]
source
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_URL
]
sourceId
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_SOURCEID
]
line
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_LINE
]
column
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_COLUMN
]
}
)
;
break
;
}
case
"
enter
"
:
{
const
traceIndex
=
mutableTraces
.
length
;
mutableTraces
.
push
(
traceResource
)
;
mutableChildren
.
push
(
[
]
)
;
const
depth
=
traceResource
[
TRACER_FIELDS_INDEXES
.
DEPTH
]
;
matchParent
(
traceIndex
depth
)
;
break
;
}
case
"
exit
"
:
{
break
;
}
case
"
dom
-
mutation
"
:
{
const
traceIndex
=
mutableTraces
.
length
;
mutableTraces
.
push
(
traceResource
)
;
mutableChildren
.
push
(
[
]
)
;
mutableMutationTraces
.
push
(
traceIndex
)
;
const
depth
=
traceResource
[
TRACER_FIELDS_INDEXES
.
DEPTH
]
;
matchParent
(
traceIndex
depth
)
;
break
;
}
case
"
event
"
:
{
const
traceIndex
=
mutableTraces
.
length
;
mutableTraces
.
push
(
traceResource
)
;
mutableChildren
.
push
(
[
]
)
;
mutableParents
.
push
(
null
)
;
mutableTopTraces
.
push
(
traceIndex
)
;
break
;
}
}
}
}
function
locationMatchTrace
(
location
trace
)
{
return
(
trace
.
sourceId
=
=
location
.
sourceActor
.
id
&
&
trace
.
lineNumber
=
=
location
.
line
&
&
trace
.
columnNumber
=
=
location
.
column
)
;
}
function
generatePreviewsForTrace
(
state
trace
)
{
let
previews
=
state
.
previews
;
const
argumentValues
=
trace
[
TRACER_FIELDS_INDEXES
.
ENTER_ARGS
]
;
const
argumentNames
=
trace
[
TRACER_FIELDS_INDEXES
.
ENTER_ARG_NAMES
]
;
if
(
argumentNames
&
&
argumentValues
)
{
const
frameIndex
=
trace
[
TRACER_FIELDS_INDEXES
.
FRAME_INDEX
]
;
const
frame
=
state
.
mutableFrames
[
frameIndex
]
;
const
line
=
frame
.
line
-
1
;
const
column
=
frame
.
column
;
const
preview
=
[
]
;
for
(
let
i
=
0
;
i
<
argumentNames
.
length
;
i
+
+
)
{
const
name
=
argumentNames
[
i
]
;
const
objectGrip
=
argumentValues
[
i
]
?
.
getGrip
?
argumentValues
[
i
]
?
.
getGrip
(
)
:
argumentValues
[
i
]
;
preview
.
push
(
{
line
column
type
:
"
trace
"
name
value
:
objectGrip
}
)
;
}
previews
=
{
[
line
]
:
preview
}
;
}
return
previews
;
}
export
default
update
;
