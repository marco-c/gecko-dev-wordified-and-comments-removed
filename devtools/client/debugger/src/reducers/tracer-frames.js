const
{
TRACER_FIELDS_INDEXES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
.
js
"
)
;
const
lazy
=
{
}
;
ChromeUtils
.
defineESModuleGetters
(
lazy
{
BinarySearch
:
"
resource
:
/
/
gre
/
modules
/
BinarySearch
.
sys
.
mjs
"
}
)
;
export
const
NO_SEARCH_VALUE
=
Symbol
(
"
no
-
search
-
value
"
)
;
function
initialState
(
previousState
=
{
searchValueOrGrip
:
NO_SEARCH_VALUE
}
)
{
return
{
mutableTraces
:
[
]
mutableChildren
:
[
]
mutableParents
:
[
]
mutableFrames
:
[
]
mutableTopTraces
:
[
]
mutableFilteredTopTraces
:
[
]
mutableMutationTraces
:
[
]
mutableMatchingTraces
:
[
]
searchExceptionMessage
:
null
searchValueOrGrip
:
previousState
.
searchValueOrGrip
mutableEventNames
:
new
Set
(
)
domEventInfoByTracerName
:
previousState
.
domEventInfoByTracerName
|
|
new
Map
(
)
domEventCategories
:
[
]
activeDomEvents
:
[
]
highlightedDomEvents
:
[
]
selectedTraceIndex
:
null
previews
:
null
localPlatformVersion
:
null
remotePlatformVersion
:
null
traceValues
:
false
}
;
}
function
update
(
state
=
initialState
(
)
action
)
{
switch
(
action
.
type
)
{
case
"
SET_TRACE_SEARCH_EXCEPTION
"
:
{
return
{
.
.
.
state
searchExceptionMessage
:
action
.
errorMessage
searchValueOrGrip
:
NO_SEARCH_VALUE
mutableMatchingTraces
:
[
]
}
;
}
case
"
SET_TRACE_SEARCH_STRING
"
:
{
const
{
searchValueOrGrip
}
=
action
;
if
(
searchValueOrGrip
=
=
=
NO_SEARCH_VALUE
)
{
return
{
.
.
.
state
searchValueOrGrip
searchExceptionMessage
:
null
mutableMatchingTraces
:
[
]
}
;
}
const
mutableMatchingTraces
=
[
]
;
for
(
const
trace
of
state
.
mutableTraces
)
{
const
type
=
trace
[
TRACER_FIELDS_INDEXES
.
TYPE
]
;
if
(
type
!
=
"
enter
"
)
{
continue
;
}
if
(
isTraceMatchingSearch
(
trace
searchValueOrGrip
)
)
{
mutableMatchingTraces
.
push
(
trace
)
;
}
}
return
{
.
.
.
state
searchValueOrGrip
mutableMatchingTraces
searchExceptionMessage
:
null
}
;
}
case
"
TRACING_TOGGLED
"
:
{
if
(
action
.
enabled
)
{
state
=
initialState
(
state
)
;
if
(
action
.
traceValues
)
{
state
.
traceValues
=
true
;
}
else
{
state
.
searchValueOrGrip
=
NO_SEARCH_VALUE
;
}
return
state
;
}
return
state
;
}
case
"
TRACING_CLEAR
"
:
{
return
initialState
(
state
)
;
}
case
"
ADD_TRACES
"
:
{
addTraces
(
state
action
.
traces
)
;
return
{
.
.
.
state
}
;
}
case
"
SELECT_TRACE
"
:
{
const
{
traceIndex
}
=
action
;
if
(
traceIndex
<
0
|
|
traceIndex
>
=
state
.
mutableTraces
.
length
|
|
traceIndex
=
=
state
.
selectedTraceIndex
)
{
return
state
;
}
const
trace
=
state
.
mutableTraces
[
traceIndex
]
;
return
{
.
.
.
state
selectedTraceIndex
:
traceIndex
previews
:
generatePreviewsForTrace
(
state
trace
)
}
;
}
case
"
SELECT_FRAME
"
:
case
"
PAUSED
"
:
{
if
(
!
state
.
previews
&
&
state
.
selectedTraceIndex
=
=
null
)
{
return
state
;
}
return
{
.
.
.
state
selectedTraceIndex
:
null
previews
:
null
}
;
}
case
"
SET_SELECTED_LOCATION
"
:
{
if
(
action
.
location
.
source
.
isOriginal
)
return
state
;
if
(
state
.
selectedTrace
&
&
locationMatchTrace
(
action
.
location
state
.
selectedTrace
)
)
{
return
state
;
}
for
(
const
trace
of
state
.
mutableTraces
)
{
if
(
locationMatchTrace
(
action
.
location
trace
)
)
{
return
{
.
.
.
state
selectedTrace
:
trace
}
;
}
}
return
{
.
.
.
state
selectedTrace
:
null
}
;
}
case
"
SET_GENERATED_SELECTED_LOCATION
"
:
{
if
(
state
.
selectedTrace
&
&
locationMatchTrace
(
action
.
generatedLocation
state
.
selectedTrace
)
)
{
return
state
;
}
for
(
const
trace
of
state
.
mutableTraces
)
{
if
(
locationMatchTrace
(
action
.
generatedLocation
trace
)
)
{
return
{
.
.
.
state
selectedTrace
:
trace
}
;
}
}
return
{
.
.
.
state
selectedTrace
:
null
}
;
}
case
"
CLEAR_SELECTED_LOCATION
"
:
{
return
{
.
.
.
state
selectedTrace
:
null
}
;
}
case
"
SET_RUNTIME_VERSIONS
"
:
{
return
{
.
.
.
state
localPlatformVersion
:
action
.
localPlatformVersion
remotePlatformVersion
:
action
.
remotePlatformVersion
}
;
}
case
"
RECEIVE_EVENT_LISTENER_TYPES
"
:
{
const
domEventInfoByTracerName
=
new
Map
(
)
;
for
(
const
category
of
action
.
categories
)
{
for
(
const
event
of
category
.
events
)
{
const
value
=
{
id
:
event
.
id
category
name
:
event
.
name
}
;
if
(
event
.
type
=
=
"
event
"
)
{
for
(
const
targetType
of
event
.
targetTypes
)
{
domEventInfoByTracerName
.
set
(
{
targetType
}
.
{
event
.
eventType
}
value
)
;
}
}
else
{
domEventInfoByTracerName
.
set
(
event
.
notificationType
value
)
;
}
}
}
return
{
.
.
.
state
domEventInfoByTracerName
}
;
}
case
"
UPDATE_EVENT_LISTENERS
"
:
{
if
(
action
.
panelKey
!
=
"
tracer
"
)
{
return
state
;
}
const
{
mutableTraces
mutableTopTraces
}
=
state
;
if
(
action
.
active
.
length
=
=
state
.
mutableEventNames
.
size
)
{
return
{
.
.
.
state
mutableFilteredTopTraces
:
mutableTopTraces
activeDomEvents
:
action
.
active
}
;
}
const
mutableFilteredTopTraces
=
[
]
;
for
(
const
traceIndex
of
mutableTopTraces
)
{
const
trace
=
mutableTraces
[
traceIndex
]
;
const
type
=
trace
[
TRACER_FIELDS_INDEXES
.
TYPE
]
;
if
(
type
=
=
"
event
"
)
{
const
eventName
=
trace
[
TRACER_FIELDS_INDEXES
.
EVENT_NAME
]
;
const
id
=
state
.
domEventInfoByTracerName
.
get
(
eventName
)
?
.
id
|
|
event
.
unclassified
.
{
eventName
}
;
if
(
action
.
active
.
includes
(
id
)
)
{
mutableFilteredTopTraces
.
push
(
traceIndex
)
;
}
}
}
return
{
.
.
.
state
mutableFilteredTopTraces
activeDomEvents
:
action
.
active
}
;
}
case
"
HIGHLIGHT_EVENT_LISTENERS
"
:
{
if
(
action
.
panelKey
!
=
"
tracer
"
)
{
return
state
;
}
const
eventNames
=
[
]
;
for
(
const
[
eventName
{
id
}
]
of
state
.
domEventInfoByTracerName
.
entries
(
)
)
{
if
(
action
.
eventIds
.
includes
(
id
)
)
{
eventNames
.
push
(
eventName
)
;
}
}
return
{
.
.
.
state
highlightedDomEvents
:
eventNames
}
;
}
}
return
state
;
}
function
addTraces
(
state
traces
)
{
const
{
mutableTraces
mutableMutationTraces
mutableFrames
mutableTopTraces
mutableFilteredTopTraces
mutableChildren
mutableParents
mutableMatchingTraces
searchValueOrGrip
}
=
state
;
function
matchParent
(
traceIndex
depth
)
{
let
idx
=
mutableTraces
.
length
-
2
;
while
(
idx
!
=
null
)
{
const
trace
=
mutableTraces
[
idx
]
;
if
(
!
trace
)
{
break
;
}
const
currentDepth
=
trace
[
TRACER_FIELDS_INDEXES
.
DEPTH
]
;
if
(
currentDepth
<
depth
)
{
mutableChildren
[
idx
]
.
push
(
traceIndex
)
;
mutableParents
.
push
(
idx
)
;
return
;
}
idx
=
mutableParents
[
idx
]
;
}
mutableTopTraces
.
push
(
traceIndex
)
;
mutableFilteredTopTraces
.
push
(
traceIndex
)
;
mutableParents
.
push
(
null
)
;
}
for
(
const
traceResource
of
traces
)
{
if
(
!
traceResource
.
targetFront
.
isTopLevel
)
{
continue
;
}
const
type
=
traceResource
[
TRACER_FIELDS_INDEXES
.
TYPE
]
;
switch
(
type
)
{
case
"
frame
"
:
{
mutableFrames
.
push
(
{
functionDisplayName
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_NAME
]
source
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_URL
]
sourceId
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_SOURCEID
]
line
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_LINE
]
column
:
traceResource
[
TRACER_FIELDS_INDEXES
.
FRAME_COLUMN
]
}
)
;
break
;
}
case
"
enter
"
:
{
const
traceIndex
=
mutableTraces
.
length
;
mutableTraces
.
push
(
traceResource
)
;
mutableChildren
.
push
(
[
]
)
;
const
depth
=
traceResource
[
TRACER_FIELDS_INDEXES
.
DEPTH
]
;
matchParent
(
traceIndex
depth
)
;
if
(
searchValueOrGrip
!
=
NO_SEARCH_VALUE
&
&
isTraceMatchingSearch
(
traceResource
searchValueOrGrip
)
)
{
mutableMatchingTraces
.
push
(
traceResource
)
;
}
break
;
}
case
"
exit
"
:
{
break
;
}
case
"
dom
-
mutation
"
:
{
const
traceIndex
=
mutableTraces
.
length
;
mutableTraces
.
push
(
traceResource
)
;
mutableChildren
.
push
(
[
]
)
;
mutableMutationTraces
.
push
(
traceIndex
)
;
const
depth
=
traceResource
[
TRACER_FIELDS_INDEXES
.
DEPTH
]
;
matchParent
(
traceIndex
depth
)
;
break
;
}
case
"
event
"
:
{
const
traceIndex
=
mutableTraces
.
length
;
mutableTraces
.
push
(
traceResource
)
;
mutableChildren
.
push
(
[
]
)
;
mutableParents
.
push
(
null
)
;
mutableTopTraces
.
push
(
traceIndex
)
;
const
eventName
=
traceResource
[
TRACER_FIELDS_INDEXES
.
EVENT_NAME
]
;
registerDOMEvent
(
state
eventName
)
;
const
id
=
state
.
domEventInfoByTracerName
.
get
(
eventName
)
?
.
id
|
|
event
.
unclassified
.
{
eventName
}
;
if
(
state
.
activeDomEvents
.
includes
(
id
)
)
{
mutableFilteredTopTraces
.
push
(
traceIndex
)
;
}
break
;
}
}
}
}
const
UNCLASSIFIED_CATEGORY
=
{
id
:
"
unclassified
"
name
:
"
Unclassified
"
}
;
function
registerDOMEvent
(
state
eventName
)
{
if
(
state
.
mutableEventNames
.
has
(
eventName
)
)
{
return
;
}
state
.
mutableEventNames
.
add
(
eventName
)
;
const
{
category
id
name
}
=
state
.
domEventInfoByTracerName
.
get
(
eventName
)
|
|
{
category
:
UNCLASSIFIED_CATEGORY
id
:
event
.
unclassified
.
{
eventName
}
name
:
eventName
}
;
if
(
!
state
.
activeDomEvents
.
includes
(
id
)
)
{
state
.
activeDomEvents
.
push
(
id
)
;
}
let
newCategory
=
state
.
domEventCategories
.
find
(
cat
=
>
cat
.
name
=
=
category
.
name
)
;
if
(
!
newCategory
)
{
newCategory
=
{
id
:
category
.
id
name
:
category
.
name
events
:
[
]
}
;
state
.
domEventCategories
=
[
.
.
.
state
.
domEventCategories
]
;
addSortedCategoryOrEvent
(
state
.
domEventCategories
newCategory
)
;
}
if
(
!
newCategory
.
events
.
some
(
e
=
>
e
.
name
=
=
name
)
)
{
addSortedCategoryOrEvent
(
newCategory
.
events
{
id
name
}
)
;
state
.
domEventCategories
=
[
.
.
.
state
.
domEventCategories
]
;
}
}
function
addSortedCategoryOrEvent
(
array
newElement
)
{
const
index
=
lazy
.
BinarySearch
.
insertionIndexOf
(
function
(
a
b
)
{
return
a
.
name
.
localeCompare
(
b
.
name
)
;
}
array
newElement
)
;
array
.
splice
(
index
0
newElement
)
;
}
function
locationMatchTrace
(
location
trace
)
{
return
(
trace
.
sourceId
=
=
location
.
sourceActor
.
id
&
&
trace
.
lineNumber
=
=
location
.
line
&
&
trace
.
columnNumber
=
=
location
.
column
)
;
}
function
isTraceMatchingSearch
(
trace
searchValueOrGrip
)
{
const
argumentValues
=
trace
[
TRACER_FIELDS_INDEXES
.
ENTER_ARGS
]
;
if
(
!
argumentValues
)
{
return
false
;
}
if
(
searchValueOrGrip
)
{
const
{
actor
}
=
searchValueOrGrip
;
if
(
actor
)
{
return
argumentValues
.
some
(
v
=
>
v
.
actor
=
=
=
searchValueOrGrip
.
actor
)
;
}
}
if
(
searchValueOrGrip
=
=
=
null
)
{
return
argumentValues
.
some
(
v
=
>
v
?
.
type
=
=
"
null
"
)
;
}
else
if
(
searchValueOrGrip
=
=
=
undefined
)
{
return
argumentValues
.
some
(
v
=
>
v
?
.
type
=
=
"
undefined
"
)
;
}
return
argumentValues
.
some
(
v
=
>
v
=
=
=
searchValueOrGrip
)
;
}
function
generatePreviewsForTrace
(
state
trace
)
{
let
previews
=
state
.
previews
;
const
argumentValues
=
trace
[
TRACER_FIELDS_INDEXES
.
ENTER_ARGS
]
;
const
argumentNames
=
trace
[
TRACER_FIELDS_INDEXES
.
ENTER_ARG_NAMES
]
;
if
(
argumentNames
&
&
argumentValues
)
{
const
frameIndex
=
trace
[
TRACER_FIELDS_INDEXES
.
FRAME_INDEX
]
;
const
frame
=
state
.
mutableFrames
[
frameIndex
]
;
const
line
=
frame
.
line
-
1
;
const
column
=
frame
.
column
;
const
preview
=
[
]
;
for
(
let
i
=
0
;
i
<
argumentNames
.
length
;
i
+
+
)
{
const
name
=
argumentNames
[
i
]
;
const
objectGrip
=
argumentValues
[
i
]
?
.
getGrip
?
argumentValues
[
i
]
?
.
getGrip
(
)
:
argumentValues
[
i
]
;
preview
.
push
(
{
line
column
type
:
"
trace
"
name
value
:
objectGrip
}
)
;
}
previews
=
{
[
line
]
:
preview
}
;
}
return
previews
;
}
export
default
update
;
