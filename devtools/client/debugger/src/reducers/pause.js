import
{
prefs
}
from
"
.
.
/
utils
/
prefs
"
;
import
{
findClosestFunction
}
from
"
.
.
/
utils
/
ast
"
;
export
function
initialPauseState
(
thread
=
"
UnknownThread
"
)
{
return
{
cx
:
{
navigateCounter
:
0
}
threadcx
:
{
navigateCounter
:
0
thread
pauseCounter
:
0
}
threads
:
{
}
skipPausing
:
prefs
.
skipPausing
mapScopes
:
prefs
.
mapScopes
shouldPauseOnDebuggerStatement
:
prefs
.
pauseOnDebuggerStatement
shouldPauseOnExceptions
:
prefs
.
pauseOnExceptions
shouldPauseOnCaughtExceptions
:
prefs
.
pauseOnCaughtExceptions
}
;
}
const
resumedPauseState
=
{
isPaused
:
false
frames
:
null
framesLoading
:
false
frameScopes
:
{
generated
:
{
}
original
:
{
}
mappings
:
{
}
}
selectedFrameId
:
null
why
:
null
inlinePreview
:
{
}
}
;
const
createInitialPauseState
=
(
)
=
>
(
{
.
.
.
resumedPauseState
isWaitingOnBreak
:
false
command
:
null
previousLocation
:
null
expandedScopes
:
new
Set
(
)
lastExpandedScopes
:
[
]
}
)
;
export
function
getThreadPauseState
(
state
thread
)
{
return
state
.
threads
[
thread
]
|
|
createInitialPauseState
(
)
;
}
function
update
(
state
=
initialPauseState
(
)
action
)
{
const
getActionThread
=
(
)
=
>
{
const
thread
=
action
.
thread
|
|
action
.
selectedFrame
?
.
thread
|
|
action
.
frame
?
.
thread
;
if
(
!
thread
)
{
throw
new
Error
(
Missing
thread
in
action
{
action
.
type
}
)
;
}
return
thread
;
}
;
const
threadState
=
(
)
=
>
{
return
getThreadPauseState
(
state
getActionThread
(
)
)
;
}
;
const
updateThreadState
=
newThreadState
=
>
{
return
{
.
.
.
state
threads
:
{
.
.
.
state
.
threads
[
getActionThread
(
)
]
:
{
.
.
.
threadState
(
)
.
.
.
newThreadState
}
}
}
;
}
;
switch
(
action
.
type
)
{
case
"
SELECT_THREAD
"
:
{
if
(
!
state
.
threads
[
action
.
thread
]
)
{
console
.
warn
(
Trying
to
select
a
destroyed
or
non
-
existent
thread
'
{
action
.
thread
}
'
)
;
return
state
;
}
return
{
.
.
.
state
threadcx
:
{
.
.
.
state
.
threadcx
thread
:
action
.
thread
pauseCounter
:
state
.
threadcx
.
pauseCounter
+
1
}
}
;
}
case
"
INSERT_THREAD
"
:
{
if
(
action
.
newThread
.
isTopLevel
)
{
return
{
.
.
.
state
threadcx
:
{
.
.
.
state
.
threadcx
thread
:
action
.
newThread
.
actor
pauseCounter
:
state
.
threadcx
.
pauseCounter
+
1
}
threads
:
{
.
.
.
state
.
threads
[
action
.
newThread
.
actor
]
:
createInitialPauseState
(
)
}
}
;
}
return
{
.
.
.
state
threads
:
{
.
.
.
state
.
threads
[
action
.
newThread
.
actor
]
:
createInitialPauseState
(
)
}
}
;
}
case
"
REMOVE_THREAD
"
:
{
if
(
action
.
threadActorID
in
state
.
threads
|
|
action
.
threadActorID
=
=
state
.
threadcx
.
thread
)
{
const
threads
=
{
.
.
.
state
.
threads
}
;
delete
threads
[
action
.
threadActorID
]
;
let
threadcx
=
state
.
threadcx
;
if
(
state
.
threadcx
.
thread
=
=
action
.
threadActorID
)
{
threadcx
=
{
.
.
.
threadcx
thread
:
Object
.
keys
(
threads
)
[
0
]
pauseCounter
:
threadcx
.
pauseCounter
+
1
}
;
}
return
{
.
.
.
state
threadcx
threads
}
;
}
break
;
}
case
"
PAUSED
"
:
{
const
{
thread
topFrame
why
}
=
action
;
state
=
{
.
.
.
state
threadcx
:
{
.
.
.
state
.
threadcx
pauseCounter
:
state
.
threadcx
.
pauseCounter
+
1
thread
}
}
;
return
updateThreadState
(
{
isWaitingOnBreak
:
false
selectedFrameId
:
topFrame
.
id
isPaused
:
true
frames
:
[
topFrame
]
framesLoading
:
true
frameScopes
:
{
.
.
.
resumedPauseState
.
frameScopes
}
why
shouldBreakpointsPaneOpenOnPause
:
why
.
type
=
=
=
"
breakpoint
"
}
)
;
}
case
"
FETCHED_FRAMES
"
:
{
const
{
frames
}
=
action
;
if
(
threadState
(
)
.
frames
)
{
const
previousFirstFrame
=
threadState
(
)
.
frames
[
0
]
;
if
(
previousFirstFrame
.
id
=
=
frames
[
0
]
?
.
id
)
{
frames
.
splice
(
0
1
previousFirstFrame
)
;
}
}
return
updateThreadState
(
{
frames
framesLoading
:
false
}
)
;
}
case
"
MAP_FRAMES
"
:
{
const
{
selectedFrameId
frames
}
=
action
;
return
updateThreadState
(
{
frames
selectedFrameId
}
)
;
}
case
"
MAP_FRAME_DISPLAY_NAMES
"
:
{
const
{
frames
}
=
action
;
return
updateThreadState
(
{
frames
}
)
;
}
case
"
SET_SYMBOLS
"
:
{
if
(
action
.
status
=
=
=
"
start
"
)
{
return
state
;
}
return
updateFrameOriginalDisplayName
(
state
action
.
location
.
source
action
.
value
)
;
}
case
"
ADD_SCOPES
"
:
{
const
{
status
value
}
=
action
;
const
selectedFrameId
=
action
.
selectedFrame
.
id
;
const
generated
=
{
.
.
.
threadState
(
)
.
frameScopes
.
generated
[
selectedFrameId
]
:
{
pending
:
status
!
=
=
"
done
"
scope
:
value
}
}
;
return
updateThreadState
(
{
frameScopes
:
{
.
.
.
threadState
(
)
.
frameScopes
generated
}
}
)
;
}
case
"
MAP_SCOPES
"
:
{
const
{
status
value
}
=
action
;
const
selectedFrameId
=
action
.
selectedFrame
.
id
;
const
original
=
{
.
.
.
threadState
(
)
.
frameScopes
.
original
[
selectedFrameId
]
:
{
pending
:
status
!
=
=
"
done
"
scope
:
value
?
.
scope
}
}
;
const
mappings
=
{
.
.
.
threadState
(
)
.
frameScopes
.
mappings
[
selectedFrameId
]
:
value
?
.
mappings
}
;
return
updateThreadState
(
{
frameScopes
:
{
.
.
.
threadState
(
)
.
frameScopes
original
mappings
}
}
)
;
}
case
"
BREAK_ON_NEXT
"
:
return
updateThreadState
(
{
isWaitingOnBreak
:
true
}
)
;
case
"
SELECT_FRAME
"
:
return
updateThreadState
(
{
selectedFrameId
:
action
.
frame
.
id
}
)
;
case
"
PAUSE_ON_DEBUGGER_STATEMENT
"
:
{
const
{
shouldPauseOnDebuggerStatement
}
=
action
;
prefs
.
pauseOnDebuggerStatement
=
shouldPauseOnDebuggerStatement
;
return
{
.
.
.
state
shouldPauseOnDebuggerStatement
}
;
}
case
"
PAUSE_ON_EXCEPTIONS
"
:
{
const
{
shouldPauseOnExceptions
shouldPauseOnCaughtExceptions
}
=
action
;
prefs
.
pauseOnExceptions
=
shouldPauseOnExceptions
;
prefs
.
pauseOnCaughtExceptions
=
shouldPauseOnCaughtExceptions
;
prefs
.
ignoreCaughtExceptions
=
!
shouldPauseOnCaughtExceptions
;
return
{
.
.
.
state
shouldPauseOnExceptions
shouldPauseOnCaughtExceptions
}
;
}
case
"
COMMAND
"
:
if
(
action
.
status
=
=
=
"
start
"
)
{
return
updateThreadState
(
{
.
.
.
resumedPauseState
command
:
action
.
command
previousLocation
:
getPauseLocation
(
threadState
(
)
action
)
}
)
;
}
return
updateThreadState
(
{
command
:
null
}
)
;
case
"
RESUME
"
:
{
if
(
action
.
thread
=
=
state
.
threadcx
.
thread
)
{
state
=
{
.
.
.
state
threadcx
:
{
.
.
.
state
.
threadcx
pauseCounter
:
state
.
threadcx
.
pauseCounter
+
1
}
}
;
}
return
updateThreadState
(
{
.
.
.
resumedPauseState
expandedScopes
:
new
Set
(
)
lastExpandedScopes
:
[
.
.
.
threadState
(
)
.
expandedScopes
]
shouldBreakpointsPaneOpenOnPause
:
false
}
)
;
}
case
"
EVALUATE_EXPRESSION
"
:
return
updateThreadState
(
{
command
:
action
.
status
=
=
=
"
start
"
?
"
expression
"
:
null
}
)
;
case
"
NAVIGATE
"
:
{
const
navigateCounter
=
state
.
cx
.
navigateCounter
+
1
;
return
{
.
.
.
state
cx
:
{
navigateCounter
}
threadcx
:
{
navigateCounter
thread
:
action
.
mainThread
.
actor
pauseCounter
:
0
}
threads
:
{
.
.
.
state
.
threads
[
action
.
mainThread
.
actor
]
:
{
.
.
.
getThreadPauseState
(
state
action
.
mainThread
.
actor
)
.
.
.
resumedPauseState
}
}
}
;
}
case
"
TOGGLE_SKIP_PAUSING
"
:
{
const
{
skipPausing
}
=
action
;
prefs
.
skipPausing
=
skipPausing
;
return
{
.
.
.
state
skipPausing
}
;
}
case
"
TOGGLE_MAP_SCOPES
"
:
{
const
{
mapScopes
}
=
action
;
prefs
.
mapScopes
=
mapScopes
;
return
{
.
.
.
state
mapScopes
}
;
}
case
"
SET_EXPANDED_SCOPE
"
:
{
const
{
path
expanded
}
=
action
;
const
expandedScopes
=
new
Set
(
threadState
(
)
.
expandedScopes
)
;
if
(
expanded
)
{
expandedScopes
.
add
(
path
)
;
}
else
{
expandedScopes
.
delete
(
path
)
;
}
return
updateThreadState
(
{
expandedScopes
}
)
;
}
case
"
ADD_INLINE_PREVIEW
"
:
{
const
{
selectedFrame
previews
}
=
action
;
const
selectedFrameId
=
selectedFrame
.
id
;
return
updateThreadState
(
{
inlinePreview
:
{
.
.
.
threadState
(
)
.
inlinePreview
[
selectedFrameId
]
:
previews
}
}
)
;
}
case
"
RESET_BREAKPOINTS_PANE_STATE
"
:
{
return
updateThreadState
(
{
.
.
.
threadState
(
)
shouldBreakpointsPaneOpenOnPause
:
false
}
)
;
}
}
return
state
;
}
function
getPauseLocation
(
state
action
)
{
const
{
frames
previousLocation
}
=
state
;
if
(
action
.
command
!
=
=
"
stepOver
"
)
{
return
null
;
}
const
frame
=
frames
?
.
[
0
]
;
if
(
!
frame
)
{
return
previousLocation
;
}
return
{
location
:
frame
.
location
generatedLocation
:
frame
.
generatedLocation
}
;
}
function
mapDisplayName
(
frame
symbols
)
{
if
(
frame
.
isOriginal
)
{
return
frame
;
}
if
(
!
frame
.
location
.
source
.
isOriginal
)
{
return
frame
;
}
if
(
frame
.
originalDisplayName
)
{
return
frame
;
}
if
(
!
symbols
.
functions
)
{
return
frame
;
}
const
originalDisplayName
=
getOriginalDisplayNameForOriginalLocation
(
symbols
frame
.
location
)
;
if
(
!
originalDisplayName
)
{
return
frame
;
}
return
{
.
.
.
frame
originalDisplayName
}
;
}
function
updateFrameOriginalDisplayName
(
state
source
symbols
)
{
if
(
!
source
.
isOriginal
)
{
return
state
;
}
let
newState
=
null
;
for
(
const
threadActorId
in
state
.
threads
)
{
const
thread
=
state
.
threads
[
threadActorId
]
;
if
(
!
thread
.
frames
)
{
continue
;
}
const
shouldUpdateThreadFrames
=
thread
.
frames
.
some
(
frame
=
>
frame
.
location
.
source
=
=
source
)
;
if
(
!
shouldUpdateThreadFrames
)
{
continue
;
}
const
frames
=
thread
.
frames
.
map
(
frame
=
>
frame
.
location
.
source
=
=
source
?
mapDisplayName
(
frame
symbols
)
:
frame
)
;
if
(
!
newState
)
{
newState
=
{
.
.
.
state
}
;
}
newState
.
threads
[
threadActorId
]
=
{
.
.
.
thread
frames
}
;
}
return
newState
?
newState
:
state
;
}
export
function
getOriginalDisplayNameForOriginalLocation
(
symbols
location
)
{
if
(
!
symbols
.
functions
)
{
return
null
;
}
const
originalFunction
=
findClosestFunction
(
symbols
location
)
;
return
originalFunction
?
originalFunction
.
name
:
null
;
}
export
default
update
;
