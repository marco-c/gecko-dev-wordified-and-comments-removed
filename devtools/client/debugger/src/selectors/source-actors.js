export
function
hasSourceActor
(
state
sourceActorId
)
{
return
state
.
sourceActors
.
mutableSourceActors
.
has
(
sourceActorId
)
;
}
export
function
getSourceActor
(
state
sourceActorId
)
{
return
state
.
sourceActors
.
mutableSourceActors
.
get
(
sourceActorId
)
;
}
export
function
isSourceActorWithSourceMap
(
state
sourceActorId
)
{
return
state
.
sourceActors
.
mutableSourceActorsWithSourceMap
.
has
(
sourceActorId
)
;
}
export
function
getSourceMapErrorForSourceActor
(
state
sourceActorId
)
{
return
state
.
sourceActors
.
mutableSourceMapErrors
.
get
(
sourceActorId
)
;
}
export
function
getSourceMapResolvedURL
(
state
sourceActorId
)
{
return
state
.
sourceActors
.
mutableResolvedSourceMapURL
.
get
(
sourceActorId
)
;
}
export
function
getSourceActorsForThread
(
state
threadActorIDs
)
{
if
(
!
Array
.
isArray
(
threadActorIDs
)
)
{
threadActorIDs
=
[
threadActorIDs
]
;
}
const
actors
=
[
]
;
for
(
const
sourceActor
of
state
.
sourceActors
.
mutableSourceActors
.
values
(
)
)
{
if
(
threadActorIDs
.
includes
(
sourceActor
.
thread
)
)
{
actors
.
push
(
sourceActor
)
;
}
}
return
actors
;
}
export
function
getSourceActorBreakableLines
(
state
sourceActorId
)
{
return
state
.
sourceActors
.
mutableBreakableLines
.
get
(
sourceActorId
)
;
}
export
function
getBreakableLinesForSourceActors
(
state
sourceActors
isHTML
)
{
const
allBreakableLines
=
[
]
;
for
(
const
sourceActor
of
sourceActors
)
{
const
breakableLines
=
getSourceActorBreakableLines
(
state
sourceActor
.
id
)
;
if
(
!
breakableLines
|
|
breakableLines
instanceof
Promise
)
{
continue
;
}
if
(
isHTML
)
{
allBreakableLines
.
push
(
.
.
.
breakableLines
)
;
}
else
{
return
breakableLines
;
}
}
return
allBreakableLines
;
}
