import
{
PureComponent
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
"
;
import
{
div
textarea
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
;
import
ReactDOM
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
;
import
PropTypes
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
;
import
{
connect
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
;
import
{
toEditorLine
}
from
"
.
.
/
.
.
/
utils
/
editor
/
index
"
;
import
{
createEditor
}
from
"
.
.
/
.
.
/
utils
/
editor
/
create
-
editor
"
;
import
{
prefs
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
actions
from
"
.
.
/
.
.
/
actions
/
index
"
;
import
{
markerTypes
}
from
"
.
.
/
.
.
/
constants
"
;
import
{
getClosestBreakpoint
getConditionalPanelLocation
getLogPointStatus
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
const
classnames
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
classnames
.
js
"
)
;
export
class
ConditionalPanel
extends
PureComponent
{
cbPanel
;
input
;
codeMirror
;
panelNode
;
scrollParent
;
constructor
(
)
{
super
(
)
;
this
.
cbPanel
=
null
;
this
.
breakpointPanelEditor
=
null
;
}
static
get
propTypes
(
)
{
return
{
breakpoint
:
PropTypes
.
object
closeConditionalPanel
:
PropTypes
.
func
.
isRequired
editor
:
PropTypes
.
object
.
isRequired
location
:
PropTypes
.
any
.
isRequired
log
:
PropTypes
.
bool
.
isRequired
openConditionalPanel
:
PropTypes
.
func
.
isRequired
setBreakpointOptions
:
PropTypes
.
func
.
isRequired
selectedSource
:
PropTypes
.
object
.
isRequired
}
;
}
removeBreakpointPanelEditor
(
)
{
if
(
this
.
breakpointPanelEditor
)
{
this
.
breakpointPanelEditor
.
destroy
(
)
;
}
this
.
breakpointPanelEditor
=
null
;
}
keepFocusOnInput
(
)
{
if
(
this
.
input
)
{
this
.
input
.
focus
(
)
;
}
else
if
(
this
.
breakpointPanelEditor
)
{
this
.
breakpointPanelEditor
.
focus
(
)
;
}
}
saveAndClose
=
(
expression
=
null
)
=
>
{
if
(
expression
)
{
this
.
setBreakpoint
(
expression
.
trim
(
)
)
;
}
this
.
props
.
closeConditionalPanel
(
)
;
}
;
onKey
=
e
=
>
{
if
(
e
.
key
=
=
=
"
Enter
"
&
&
!
e
.
shiftKey
)
{
this
.
saveAndClose
(
this
.
input
?
.
value
)
;
}
else
if
(
e
.
key
=
=
=
"
Escape
"
)
{
this
.
props
.
closeConditionalPanel
(
)
;
}
}
;
onBlur
=
e
=
>
{
if
(
!
e
|
|
(
e
?
.
relatedTarget
&
&
e
.
relatedTarget
.
closest
(
"
.
conditional
-
breakpoint
-
panel
"
)
)
)
{
return
;
}
this
.
props
.
closeConditionalPanel
(
)
;
}
;
setBreakpoint
(
value
)
{
const
{
log
breakpoint
}
=
this
.
props
;
const
location
=
breakpoint
&
&
breakpoint
.
generatedLocation
?
breakpoint
.
generatedLocation
:
this
.
props
.
location
;
const
options
=
breakpoint
?
breakpoint
.
options
:
{
}
;
const
type
=
log
?
"
logValue
"
:
"
condition
"
;
return
this
.
props
.
setBreakpointOptions
(
location
{
.
.
.
options
[
type
]
:
value
}
)
;
}
clearConditionalPanel
(
)
{
if
(
this
.
cbPanel
)
{
this
.
cbPanel
.
clear
(
)
;
this
.
cbPanel
=
null
;
}
if
(
this
.
scrollParent
)
{
this
.
scrollParent
.
removeEventListener
(
"
scroll
"
this
.
repositionOnScroll
)
;
}
}
repositionOnScroll
=
(
)
=
>
{
if
(
this
.
panelNode
&
&
this
.
scrollParent
)
{
const
{
scrollLeft
}
=
this
.
scrollParent
;
this
.
panelNode
.
style
.
transform
=
translateX
(
{
scrollLeft
}
px
)
;
}
}
;
showConditionalPanel
(
prevProps
)
{
const
{
location
log
editor
breakpoint
selectedSource
}
=
this
.
props
;
if
(
!
selectedSource
|
|
!
location
)
{
this
.
removeBreakpointPanelEditor
(
)
;
return
;
}
if
(
prevProps
?
.
breakpoint
&
&
!
breakpoint
)
{
editor
.
removeLineContentMarker
(
markerTypes
.
CONDITIONAL_BP_MARKER
)
;
this
.
removeBreakpointPanelEditor
(
)
;
return
;
}
if
(
selectedSource
.
id
!
=
=
location
.
source
.
id
)
{
editor
.
removeLineContentMarker
(
markerTypes
.
CONDITIONAL_BP_MARKER
)
;
this
.
removeBreakpointPanelEditor
(
)
;
return
;
}
const
line
=
toEditorLine
(
location
.
source
.
id
location
.
line
|
|
0
)
;
editor
.
setLineContentMarker
(
{
id
:
markerTypes
.
CONDITIONAL_BP_MARKER
lines
:
[
{
line
}
]
renderAsBlock
:
true
createLineElementNode
:
(
)
=
>
{
const
onEnterKeyMapConfig
=
{
preventDefault
:
true
stopPropagation
:
true
run
:
(
)
=
>
this
.
saveAndClose
(
breakpointPanelEditor
.
getText
(
null
)
)
}
;
const
breakpointPanelEditor
=
createEditor
(
{
cm6
:
features
.
codemirrorNext
readOnly
:
false
lineNumbers
:
false
placeholder
:
L10N
.
getStr
(
log
?
"
editor
.
conditionalPanel
.
logPoint
.
placeholder2
"
:
"
editor
.
conditionalPanel
.
placeholder2
"
)
keyMap
:
[
{
key
:
"
Enter
"
.
.
.
onEnterKeyMapConfig
}
{
key
:
"
Mod
-
Enter
"
.
.
.
onEnterKeyMapConfig
}
{
key
:
"
Escape
"
preventDefault
:
true
stopPropagation
:
true
run
:
(
)
=
>
this
.
props
.
closeConditionalPanel
(
)
}
]
}
)
;
this
.
breakpointPanelEditor
=
breakpointPanelEditor
;
return
this
.
renderConditionalPanel
(
this
.
props
breakpointPanelEditor
)
;
}
}
)
;
}
UNSAFE_componentWillMount
(
)
{
if
(
features
.
codemirrorNext
)
{
this
.
showConditionalPanel
(
)
;
}
else
{
this
.
renderToWidget
(
this
.
props
)
;
}
}
UNSAFE_componentWillUpdate
(
)
{
if
(
!
features
.
codemirrorNext
)
{
this
.
clearConditionalPanel
(
)
;
}
}
componentDidUpdate
(
prevProps
)
{
if
(
features
.
codemirrorNext
)
{
this
.
showConditionalPanel
(
prevProps
)
;
}
this
.
keepFocusOnInput
(
)
;
}
componentWillUnmount
(
)
{
const
{
editor
}
=
this
.
props
;
if
(
features
.
codemirrorNext
)
{
editor
.
removeLineContentMarker
(
markerTypes
.
CONDITIONAL_BP_MARKER
)
;
this
.
removeBreakpointPanelEditor
(
)
;
}
else
{
this
.
clearConditionalPanel
(
)
;
}
}
renderToWidget
(
props
)
{
if
(
this
.
cbPanel
)
{
this
.
clearConditionalPanel
(
)
;
}
const
{
location
editor
}
=
props
;
if
(
!
location
)
{
return
;
}
const
editorLine
=
toEditorLine
(
location
.
source
.
id
location
.
line
|
|
0
)
;
this
.
cbPanel
=
editor
.
codeMirror
.
addLineWidget
(
editorLine
this
.
renderConditionalPanel
(
props
editor
)
{
coverGutter
:
true
noHScroll
:
true
}
)
;
if
(
this
.
input
)
{
let
parent
=
this
.
input
.
parentNode
;
while
(
parent
)
{
if
(
parent
instanceof
HTMLElement
&
&
parent
.
classList
.
contains
(
"
CodeMirror
-
scroll
"
)
)
{
this
.
scrollParent
=
parent
;
break
;
}
parent
=
parent
.
parentNode
;
}
if
(
this
.
scrollParent
)
{
this
.
scrollParent
.
addEventListener
(
"
scroll
"
this
.
repositionOnScroll
)
;
this
.
repositionOnScroll
(
)
;
}
}
}
setupAndAppendInlineEditor
=
(
el
editor
)
=
>
{
const
{
log
}
=
this
.
props
;
if
(
features
.
codemirrorNext
)
{
editor
.
appendToLocalElement
(
el
)
;
editor
.
on
(
"
blur
"
e
=
>
this
.
onBlur
(
e
)
)
;
editor
.
setText
(
this
.
getDefaultValue
(
)
)
;
editor
.
focus
(
)
;
editor
.
selectAll
(
)
;
}
else
{
const
codeMirror
=
editor
.
CodeMirror
.
fromTextArea
(
el
{
mode
:
"
javascript
"
theme
:
"
mozilla
"
placeholder
:
L10N
.
getStr
(
log
?
"
editor
.
conditionalPanel
.
logPoint
.
placeholder2
"
:
"
editor
.
conditionalPanel
.
placeholder2
"
)
cursorBlinkRate
:
prefs
.
cursorBlinkRate
}
)
;
codeMirror
.
on
(
"
keydown
"
(
cm
e
)
=
>
{
if
(
e
.
key
=
=
=
"
Enter
"
)
{
e
.
codemirrorIgnore
=
true
;
}
}
)
;
codeMirror
.
on
(
"
blur
"
(
cm
e
)
=
>
this
.
onBlur
(
e
)
)
;
const
codeMirrorWrapper
=
codeMirror
.
getWrapperElement
(
)
;
codeMirrorWrapper
.
addEventListener
(
"
keydown
"
e
=
>
{
codeMirror
.
save
(
)
;
this
.
onKey
(
e
)
;
}
)
;
this
.
input
=
el
;
this
.
codeMirror
=
codeMirror
;
codeMirror
.
focus
(
)
;
codeMirror
.
execCommand
(
"
selectAll
"
)
;
}
}
;
getDefaultValue
(
)
{
const
{
breakpoint
log
}
=
this
.
props
;
const
options
=
breakpoint
?
.
options
|
|
{
}
;
const
value
=
log
?
options
.
logValue
:
options
.
condition
;
return
value
|
|
"
"
;
}
renderConditionalPanel
(
props
editor
)
{
const
{
log
}
=
props
;
const
defaultValue
=
this
.
getDefaultValue
(
)
;
const
panel
=
document
.
createElement
(
"
div
"
)
;
const
reactElPanel
=
div
(
{
className
:
"
conditional
-
breakpoint
-
panel
-
container
"
}
div
(
{
className
:
classnames
(
"
conditional
-
breakpoint
-
panel
"
{
"
log
-
point
"
:
log
}
)
onClick
:
(
)
=
>
this
.
keepFocusOnInput
(
)
ref
:
node
=
>
(
this
.
panelNode
=
node
)
}
div
(
{
className
:
"
prompt
"
}
"
"
)
features
.
codemirrorNext
?
div
(
{
className
:
"
inline
-
codemirror
-
container
"
ref
:
el
=
>
this
.
setupAndAppendInlineEditor
(
el
editor
)
}
)
:
textarea
(
{
defaultValue
ref
:
input
=
>
this
.
setupAndAppendInlineEditor
(
input
editor
)
}
)
)
)
;
ReactDOM
.
render
(
reactElPanel
panel
)
;
return
panel
;
}
render
(
)
{
return
null
;
}
}
const
mapStateToProps
=
state
=
>
{
const
location
=
getConditionalPanelLocation
(
state
)
;
if
(
!
location
)
{
return
{
}
;
}
const
breakpoint
=
getClosestBreakpoint
(
state
location
)
;
return
{
breakpoint
location
log
:
getLogPointStatus
(
state
)
}
;
}
;
const
{
setBreakpointOptions
openConditionalPanel
closeConditionalPanel
}
=
actions
;
const
mapDispatchToProps
=
{
setBreakpointOptions
openConditionalPanel
closeConditionalPanel
}
;
export
default
connect
(
mapStateToProps
mapDispatchToProps
)
(
ConditionalPanel
)
;
