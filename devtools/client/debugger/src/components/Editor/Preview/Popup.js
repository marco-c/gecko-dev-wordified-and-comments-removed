import
React
{
Component
}
from
"
react
"
;
import
PropTypes
from
"
prop
-
types
"
;
import
{
connect
}
from
"
.
.
/
.
.
/
.
.
/
utils
/
connect
"
;
import
Reps
from
"
devtools
/
client
/
shared
/
components
/
reps
/
index
"
;
const
{
REPS
:
{
Rep
}
MODE
objectInspector
}
=
Reps
;
const
{
ObjectInspector
utils
}
=
objectInspector
;
const
{
node
:
{
nodeIsPrimitive
nodeIsFunction
nodeIsObject
}
}
=
utils
;
import
ExceptionPopup
from
"
.
/
ExceptionPopup
"
;
import
actions
from
"
.
.
/
.
.
/
.
.
/
actions
"
;
import
{
getThreadContext
}
from
"
.
.
/
.
.
/
.
.
/
selectors
"
;
import
Popover
from
"
.
.
/
.
.
/
shared
/
Popover
"
;
import
PreviewFunction
from
"
.
.
/
.
.
/
shared
/
PreviewFunction
"
;
import
"
.
/
Popup
.
css
"
;
export
class
Popup
extends
Component
{
constructor
(
props
)
{
super
(
props
)
;
}
static
get
propTypes
(
)
{
return
{
clearPreview
:
PropTypes
.
func
.
isRequired
cx
:
PropTypes
.
object
.
isRequired
editorRef
:
PropTypes
.
object
.
isRequired
highlightDomElement
:
PropTypes
.
func
.
isRequired
openElementInInspector
:
PropTypes
.
func
.
isRequired
openLink
:
PropTypes
.
func
.
isRequired
preview
:
PropTypes
.
object
.
isRequired
selectSourceURL
:
PropTypes
.
func
.
isRequired
unHighlightDomElement
:
PropTypes
.
func
.
isRequired
}
;
}
componentDidMount
(
)
{
this
.
addHighlightToToken
(
)
;
}
componentWillUnmount
(
)
{
this
.
removeHighlightFromToken
(
)
;
}
addHighlightToToken
(
)
{
const
{
target
}
=
this
.
props
.
preview
;
if
(
target
)
{
target
.
classList
.
add
(
"
preview
-
token
"
)
;
addHighlightToTargetSiblings
(
target
this
.
props
)
;
}
}
removeHighlightFromToken
(
)
{
const
{
target
}
=
this
.
props
.
preview
;
if
(
target
)
{
target
.
classList
.
remove
(
"
preview
-
token
"
)
;
removeHighlightForTargetSiblings
(
target
)
;
}
}
calculateMaxHeight
=
(
)
=
>
{
const
{
editorRef
}
=
this
.
props
;
if
(
!
editorRef
)
{
return
"
auto
"
;
}
const
{
height
top
}
=
editorRef
.
getBoundingClientRect
(
)
;
const
maxHeight
=
height
+
top
;
if
(
maxHeight
<
250
)
{
return
maxHeight
;
}
return
250
;
}
;
createElement
(
element
)
{
return
document
.
createElement
(
element
)
;
}
renderFunctionPreview
(
)
{
const
{
cx
selectSourceURL
preview
:
{
resultGrip
}
}
=
this
.
props
;
if
(
!
resultGrip
)
{
return
null
;
}
const
{
location
}
=
resultGrip
;
return
(
<
div
className
=
"
preview
-
popup
"
onClick
=
{
(
)
=
>
location
&
&
selectSourceURL
(
cx
location
.
url
{
line
:
location
.
line
}
)
}
>
<
PreviewFunction
func
=
{
resultGrip
}
/
>
<
/
div
>
)
;
}
renderObjectPreview
(
)
{
const
{
preview
:
{
properties
}
openLink
openElementInInspector
highlightDomElement
unHighlightDomElement
}
=
this
.
props
;
if
(
!
properties
.
length
)
{
return
(
<
div
className
=
"
preview
-
popup
"
>
<
span
className
=
"
label
"
>
{
L10N
.
getStr
(
"
preview
.
noProperties
"
)
}
<
/
span
>
<
/
div
>
)
;
}
return
(
<
div
className
=
"
preview
-
popup
"
style
=
{
{
maxHeight
:
this
.
calculateMaxHeight
(
)
}
}
>
<
ObjectInspector
roots
=
{
properties
}
autoExpandDepth
=
{
0
}
disableWrap
=
{
true
}
focusable
=
{
false
}
openLink
=
{
openLink
}
createElement
=
{
this
.
createElement
}
onDOMNodeClick
=
{
grip
=
>
openElementInInspector
(
grip
)
}
onInspectIconClick
=
{
grip
=
>
openElementInInspector
(
grip
)
}
onDOMNodeMouseOver
=
{
grip
=
>
highlightDomElement
(
grip
)
}
onDOMNodeMouseOut
=
{
grip
=
>
unHighlightDomElement
(
grip
)
}
mayUseCustomFormatter
=
{
true
}
/
>
<
/
div
>
)
;
}
renderSimplePreview
(
)
{
const
{
openLink
preview
:
{
resultGrip
}
}
=
this
.
props
;
return
(
<
div
className
=
"
preview
-
popup
"
>
{
Rep
(
{
object
:
resultGrip
mode
:
MODE
.
LONG
openLink
}
)
}
<
/
div
>
)
;
}
renderExceptionPreview
(
exception
)
{
return
(
<
ExceptionPopup
exception
=
{
exception
}
mouseout
=
{
this
.
onMouseOutException
}
/
>
)
;
}
renderPreview
(
)
{
const
{
preview
:
{
root
exception
}
}
=
this
.
props
;
if
(
nodeIsFunction
(
root
)
)
{
return
this
.
renderFunctionPreview
(
)
;
}
if
(
nodeIsObject
(
root
)
)
{
return
<
div
>
{
this
.
renderObjectPreview
(
)
}
<
/
div
>
;
}
if
(
exception
)
{
return
this
.
renderExceptionPreview
(
exception
)
;
}
return
this
.
renderSimplePreview
(
)
;
}
getPreviewType
(
)
{
const
{
preview
:
{
root
properties
exception
}
}
=
this
.
props
;
if
(
exception
|
|
nodeIsPrimitive
(
root
)
|
|
nodeIsFunction
(
root
)
|
|
!
Array
.
isArray
(
properties
)
|
|
properties
.
length
=
=
=
0
)
{
return
"
tooltip
"
;
}
return
"
popover
"
;
}
onMouseOut
=
(
)
=
>
{
const
{
clearPreview
cx
}
=
this
.
props
;
clearPreview
(
cx
)
;
}
;
onMouseOutException
=
(
shouldClearOnMouseout
isExceptionStactraceOpen
)
=
>
{
const
{
clearPreview
cx
}
=
this
.
props
;
if
(
shouldClearOnMouseout
)
{
this
.
isExceptionStactraceOpen
=
isExceptionStactraceOpen
;
}
if
(
!
this
.
isExceptionStactraceOpen
)
{
clearPreview
(
cx
)
;
}
}
;
render
(
)
{
const
{
preview
:
{
cursorPos
resultGrip
exception
}
editorRef
}
=
this
.
props
;
if
(
!
exception
&
&
(
typeof
resultGrip
=
=
"
undefined
"
|
|
resultGrip
?
.
optimizedOut
)
)
{
return
null
;
}
const
type
=
this
.
getPreviewType
(
)
;
return
(
<
Popover
targetPosition
=
{
cursorPos
}
type
=
{
type
}
editorRef
=
{
editorRef
}
target
=
{
this
.
props
.
preview
.
target
}
mouseout
=
{
exception
?
this
.
onMouseOutException
:
this
.
onMouseOut
}
>
{
this
.
renderPreview
(
)
}
<
/
Popover
>
)
;
}
}
export
function
addHighlightToTargetSiblings
(
target
props
)
{
const
tokenType
=
target
.
classList
.
item
(
0
)
;
const
previewExpression
=
props
.
preview
.
expression
;
if
(
tokenType
&
&
previewExpression
&
&
target
.
innerHTML
!
=
=
previewExpression
)
{
let
nextSibling
=
target
.
nextSibling
;
let
nextElementSibling
=
target
.
nextElementSibling
;
while
(
nextSibling
&
&
nextElementSibling
&
&
nextSibling
.
nodeType
=
=
=
1
&
&
nextElementSibling
.
className
.
includes
(
tokenType
)
&
&
previewExpression
.
includes
(
nextElementSibling
.
innerHTML
)
)
{
nextElementSibling
.
classList
.
add
(
"
preview
-
token
"
)
;
nextSibling
=
nextSibling
.
nextSibling
;
nextElementSibling
=
nextElementSibling
.
nextElementSibling
;
}
let
previousSibling
=
target
.
previousSibling
;
let
previousElementSibling
=
target
.
previousElementSibling
;
while
(
previousSibling
&
&
previousElementSibling
&
&
previousSibling
.
nodeType
=
=
=
1
&
&
previousElementSibling
.
className
.
includes
(
tokenType
)
&
&
previewExpression
.
includes
(
previousElementSibling
.
innerHTML
)
)
{
previousElementSibling
.
classList
.
add
(
"
preview
-
token
"
)
;
previousSibling
=
previousSibling
.
previousSibling
;
previousElementSibling
=
previousElementSibling
.
previousElementSibling
;
}
}
}
export
function
removeHighlightForTargetSiblings
(
target
)
{
let
nextSibling
=
target
.
nextElementSibling
;
while
(
nextSibling
&
&
nextSibling
.
className
.
includes
(
"
preview
-
token
"
)
)
{
nextSibling
.
classList
.
remove
(
"
preview
-
token
"
)
;
nextSibling
=
nextSibling
.
nextElementSibling
;
}
let
previousSibling
=
target
.
previousElementSibling
;
while
(
previousSibling
&
&
previousSibling
.
className
.
includes
(
"
preview
-
token
"
)
)
{
previousSibling
.
classList
.
remove
(
"
preview
-
token
"
)
;
previousSibling
=
previousSibling
.
previousElementSibling
;
}
}
const
mapStateToProps
=
state
=
>
(
{
cx
:
getThreadContext
(
state
)
}
)
;
const
{
addExpression
selectSourceURL
openLink
openElementInInspectorCommand
highlightDomElement
unHighlightDomElement
clearPreview
}
=
actions
;
const
mapDispatchToProps
=
{
addExpression
selectSourceURL
openLink
openElementInInspector
:
openElementInInspectorCommand
highlightDomElement
unHighlightDomElement
clearPreview
}
;
export
default
connect
(
mapStateToProps
mapDispatchToProps
)
(
Popup
)
;
