import
PropTypes
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
;
import
React
{
PureComponent
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
"
;
import
{
connect
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
;
import
Popup
from
"
.
/
Popup
"
;
import
{
getIsCurrentThreadPaused
}
from
"
.
.
/
.
.
/
.
.
/
selectors
/
index
"
;
import
actions
from
"
.
.
/
.
.
/
.
.
/
actions
/
index
"
;
import
{
features
}
from
"
.
.
/
.
.
/
.
.
/
utils
/
prefs
"
;
const
EXCEPTION_MARKER
=
"
mark
-
text
-
exception
"
;
class
Preview
extends
PureComponent
{
target
=
null
;
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
selecting
:
false
}
;
}
static
get
propTypes
(
)
{
return
{
editor
:
PropTypes
.
object
.
isRequired
editorRef
:
PropTypes
.
object
.
isRequired
isPaused
:
PropTypes
.
bool
.
isRequired
getExceptionPreview
:
PropTypes
.
func
.
isRequired
getPreview
:
PropTypes
.
func
}
;
}
componentDidMount
(
)
{
if
(
features
.
codemirrorNext
)
{
this
.
props
.
editor
.
on
(
"
tokenenter
"
this
.
onTokenEnter
)
;
this
.
props
.
editor
.
addEditorDOMEventListeners
(
{
mouseup
:
this
.
onMouseUp
mousedown
:
this
.
onMouseDown
scroll
:
this
.
onScroll
}
)
;
}
else
{
const
{
codeMirror
}
=
this
.
props
.
editor
;
const
codeMirrorWrapper
=
codeMirror
.
getWrapperElement
(
)
;
codeMirror
.
on
(
"
tokenenter
"
this
.
onTokenEnter
)
;
codeMirror
.
on
(
"
scroll
"
this
.
onScroll
)
;
codeMirrorWrapper
.
addEventListener
(
"
mouseup
"
this
.
onMouseUp
)
;
codeMirrorWrapper
.
addEventListener
(
"
mousedown
"
this
.
onMouseDown
)
;
}
}
componentWillUnmount
(
)
{
if
(
features
.
codemirrorNext
)
{
this
.
props
.
editor
.
off
(
"
tokenenter
"
this
.
onTokenEnter
)
;
this
.
props
.
editor
.
removeEditorDOMEventListeners
(
{
mouseup
:
this
.
onMouseUp
mousedown
:
this
.
onMouseDown
scroll
:
this
.
onScroll
}
)
;
}
else
{
const
{
codeMirror
}
=
this
.
props
.
editor
;
const
codeMirrorWrapper
=
codeMirror
.
getWrapperElement
(
)
;
codeMirror
.
off
(
"
tokenenter
"
this
.
onTokenEnter
)
;
codeMirror
.
off
(
"
scroll
"
this
.
onScroll
)
;
codeMirrorWrapper
.
removeEventListener
(
"
mouseup
"
this
.
onMouseUp
)
;
codeMirrorWrapper
.
removeEventListener
(
"
mousedown
"
this
.
onMouseDown
)
;
}
}
onTokenEnter
=
async
(
{
target
tokenPos
}
)
=
>
{
const
tokenId
=
{
}
;
this
.
currentTokenId
=
tokenId
;
const
{
editor
getPreview
getExceptionPreview
}
=
this
.
props
;
const
isTargetException
=
target
.
closest
(
.
{
EXCEPTION_MARKER
}
)
;
let
preview
;
if
(
isTargetException
)
{
preview
=
await
getExceptionPreview
(
target
tokenPos
editor
)
;
}
if
(
!
preview
&
&
this
.
props
.
isPaused
&
&
!
this
.
state
.
selecting
)
{
preview
=
await
getPreview
(
target
tokenPos
editor
)
;
}
if
(
!
preview
|
|
this
.
currentTokenId
!
=
=
tokenId
)
{
return
;
}
this
.
setState
(
{
preview
}
)
;
}
;
onMouseUp
=
(
)
=
>
{
if
(
this
.
props
.
isPaused
)
{
this
.
setState
(
{
selecting
:
false
}
)
;
}
}
;
onMouseDown
=
(
)
=
>
{
if
(
this
.
props
.
isPaused
)
{
this
.
setState
(
{
selecting
:
true
}
)
;
}
}
;
onScroll
=
(
)
=
>
{
if
(
this
.
props
.
isPaused
)
{
this
.
clearPreview
(
)
;
}
}
;
clearPreview
=
(
)
=
>
{
this
.
setState
(
{
preview
:
null
}
)
;
}
;
render
(
)
{
const
{
preview
}
=
this
.
state
;
if
(
!
preview
|
|
this
.
state
.
selecting
)
{
return
null
;
}
return
React
.
createElement
(
Popup
{
preview
editor
:
this
.
props
.
editor
editorRef
:
this
.
props
.
editorRef
clearPreview
:
this
.
clearPreview
}
)
;
}
}
const
mapStateToProps
=
state
=
>
{
return
{
isPaused
:
getIsCurrentThreadPaused
(
state
)
}
;
}
;
export
default
connect
(
mapStateToProps
{
addExpression
:
actions
.
addExpression
getPreview
:
actions
.
getPreview
getExceptionPreview
:
actions
.
getExceptionPreview
}
)
(
Preview
)
;
