import
{
PureComponent
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
"
;
import
PropTypes
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
;
import
{
toEditorPosition
}
from
"
.
.
/
.
.
/
utils
/
editor
/
index
"
;
import
{
isException
}
from
"
.
.
/
.
.
/
utils
/
pause
/
index
"
;
import
{
connect
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
;
import
{
markerTypes
}
from
"
.
.
/
.
.
/
constants
"
;
import
{
getVisibleSelectedFrame
getPauseReason
getSourceTextContent
getCurrentThread
getViewport
getSelectedTraceLocation
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
export
class
DebugLine
extends
PureComponent
{
debugExpression
;
static
get
propTypes
(
)
{
return
{
editor
:
PropTypes
.
object
selectedSource
:
PropTypes
.
object
location
:
PropTypes
.
object
why
:
PropTypes
.
object
sourceTextContent
:
PropTypes
.
object
}
;
}
componentDidMount
(
)
{
this
.
setDebugLine
(
)
;
}
componentWillUnmount
(
)
{
this
.
clearDebugLine
(
this
.
props
)
;
}
componentDidUpdate
(
prevProps
)
{
this
.
clearDebugLine
(
prevProps
)
;
this
.
setDebugLine
(
)
;
}
setDebugLine
(
)
{
const
{
why
location
editor
selectedSource
}
=
this
.
props
;
if
(
!
location
)
{
return
;
}
if
(
!
selectedSource
|
|
location
.
source
.
id
!
=
=
selectedSource
.
id
)
{
return
;
}
const
{
lineClass
markTextClass
}
=
this
.
getTextClasses
(
why
)
;
const
editorLocation
=
toEditorPosition
(
location
)
;
editor
.
setPositionContentMarker
(
{
id
:
markerTypes
.
PAUSED_LOCATION_MARKER
displayLast
:
true
positions
:
[
editorLocation
]
createPositionElementNode
(
_line
_column
isFirstNonSpaceColumn
)
{
const
pausedLocation
=
document
.
createElement
(
"
span
"
)
;
pausedLocation
.
className
=
paused
-
location
{
isFirstNonSpaceColumn
?
"
first
-
column
"
:
"
"
}
;
const
bar
=
document
.
createElement
(
"
span
"
)
;
bar
.
className
=
vertical
-
bar
;
pausedLocation
.
appendChild
(
bar
)
;
return
pausedLocation
;
}
}
)
;
editor
.
setLineContentMarker
(
{
id
:
markerTypes
.
DEBUG_LINE_MARKER
lineClassName
:
lineClass
lines
:
[
{
line
:
editorLocation
.
line
}
]
}
)
;
editor
.
setPositionContentMarker
(
{
id
:
markerTypes
.
DEBUG_POSITION_MARKER
positionClassName
:
markTextClass
positions
:
[
editorLocation
]
}
)
;
}
clearDebugLine
(
otherProps
=
{
}
)
{
const
{
location
editor
selectedSource
}
=
this
.
props
;
if
(
!
location
|
|
location
.
source
.
id
!
=
=
selectedSource
.
id
|
|
otherProps
?
.
location
!
=
=
location
|
|
otherProps
?
.
selectedSource
?
.
id
!
=
=
selectedSource
.
id
)
{
editor
.
removeLineContentMarker
(
markerTypes
.
DEBUG_LINE_MARKER
)
;
editor
.
removePositionContentMarker
(
markerTypes
.
DEBUG_POSITION_MARKER
)
;
editor
.
removePositionContentMarker
(
markerTypes
.
PAUSED_LOCATION_MARKER
)
;
}
}
getTextClasses
(
why
)
{
if
(
why
&
&
isException
(
why
)
)
{
return
{
markTextClass
:
"
debug
-
expression
-
error
"
lineClass
:
"
new
-
debug
-
line
-
error
"
}
;
}
return
{
markTextClass
:
null
lineClass
:
why
=
=
"
tracer
"
?
"
traced
-
line
"
:
"
paused
-
line
"
}
;
}
render
(
)
{
return
null
;
}
}
function
isDocumentReady
(
location
sourceTextContent
)
{
return
location
&
&
sourceTextContent
;
}
const
mapStateToProps
=
state
=
>
{
let
why
;
let
location
=
getSelectedTraceLocation
(
state
)
;
if
(
location
)
{
why
=
"
tracer
"
;
}
else
{
const
frame
=
getVisibleSelectedFrame
(
state
)
;
location
=
frame
?
.
location
;
if
(
!
location
)
{
return
{
}
;
}
why
=
getPauseReason
(
state
getCurrentThread
(
state
)
)
;
}
if
(
!
getViewport
(
state
)
)
{
return
{
}
;
}
const
sourceTextContent
=
getSourceTextContent
(
state
location
)
;
if
(
!
isDocumentReady
(
location
sourceTextContent
)
)
{
return
{
}
;
}
return
{
location
why
sourceTextContent
}
;
}
;
export
default
connect
(
mapStateToProps
)
(
DebugLine
)
;
