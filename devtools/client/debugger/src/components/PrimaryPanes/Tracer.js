import
{
AppConstants
}
from
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
sys
.
mjs
"
;
import
React
{
Component
createFactory
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
"
;
import
{
div
button
footer
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
;
import
EventListeners
from
"
.
.
/
shared
/
EventListeners
"
;
import
{
connect
}
from
"
devtools
/
client
/
shared
/
vendor
/
react
-
redux
"
;
import
{
getSelectedTraceIndex
getFilteredTopTraces
getAllTraces
getTraceChildren
getTraceParents
getTraceFrames
getAllMutationTraces
getAllTraceCount
getIsCurrentlyTracing
getRuntimeVersions
getTraceHighlightedDomEvents
}
from
"
.
.
/
.
.
/
selectors
/
index
"
;
const
VirtualizedTree
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
VirtualizedTree
.
js
"
)
;
const
FrameView
=
createFactory
(
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
Frame
.
js
"
)
)
;
const
{
TRACER_FIELDS_INDEXES
}
=
require
(
"
resource
:
/
/
devtools
/
server
/
actors
/
tracer
.
js
"
)
;
const
{
HTMLTooltip
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
tooltip
/
HTMLTooltip
.
js
"
)
;
const
{
TabPanel
Tabs
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
components
/
tabs
/
Tabs
.
js
"
)
;
import
actions
from
"
.
.
/
.
.
/
actions
/
index
"
;
const
isMacOS
=
AppConstants
.
platform
=
=
"
macosx
"
;
const
TREE_NODE_HEIGHT
=
20
;
const
DEBUG
=
false
;
export
class
Tracer
extends
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
expanded
:
new
Set
(
)
startIndex
:
0
endIndex
:
-
1
renderedTraceCount
:
0
selectedTabIndex
:
0
}
;
this
.
onSliderClick
=
this
.
onSliderClick
.
bind
(
this
)
;
this
.
onSliderWheel
=
this
.
onSliderWheel
.
bind
(
this
)
;
this
.
resetZoom
=
this
.
resetZoom
.
bind
(
this
)
;
}
UNSAFE_componentWillReceiveProps
(
nextProps
)
{
const
{
traceParents
}
=
this
.
props
;
if
(
nextProps
.
selectedTraceIndex
!
=
this
.
props
.
selectedTraceIndex
&
&
nextProps
.
selectedTraceIndex
!
=
null
)
{
const
{
expanded
}
=
this
.
state
;
let
index
=
traceParents
[
nextProps
.
selectedTraceIndex
]
;
while
(
index
)
{
expanded
.
add
(
index
)
;
index
=
traceParents
[
index
]
;
}
this
.
setState
(
{
expanded
}
)
;
}
if
(
nextProps
.
traceCount
!
=
this
.
props
.
traceCount
)
{
if
(
nextProps
.
traceCount
=
=
0
)
{
this
.
updateIndexes
(
{
startIndex
:
0
endIndex
:
-
1
}
nextProps
)
;
}
else
{
this
.
updateIndexes
(
{
startIndex
:
this
.
state
.
startIndex
endIndex
:
this
.
state
.
endIndex
}
nextProps
)
;
}
}
}
componentDidMount
(
)
{
this
.
refs
.
timeline
.
onwheel
=
e
=
>
e
.
preventDefault
(
)
;
if
(
!
this
.
tooltip
)
{
this
.
instantiateTooltip
(
)
;
}
}
instantiateTooltip
(
)
{
this
.
tooltip
=
new
HTMLTooltip
(
this
.
refs
.
timeline
.
ownerDocument
{
className
:
"
event
-
tooltip
"
type
:
"
arrow
"
consumeOutsideClicks
:
false
}
)
;
this
.
tooltip
.
setContentSize
(
{
height
:
"
auto
"
}
)
;
this
.
tooltip
.
startTogglingOnHover
(
this
.
refs
.
timeline
(
target
tooltip
)
=
>
{
if
(
target
.
classList
.
contains
(
"
tracer
-
slider
-
event
"
)
)
{
const
{
traceIndex
}
=
target
.
dataset
;
const
trace
=
this
.
props
.
allTraces
[
traceIndex
]
;
const
eventName
=
trace
[
TRACER_FIELDS_INDEXES
.
EVENT_NAME
]
;
const
eventType
=
getEventClassNameFromTraceEventName
(
eventName
)
;
tooltip
.
panel
.
innerHTML
=
"
"
;
const
el
=
document
.
createElement
(
"
div
"
)
;
el
.
classList
.
add
(
"
tracer
-
dom
-
event
"
eventType
)
;
el
.
textContent
=
DOM
|
{
eventName
}
;
tooltip
.
panel
.
append
(
el
document
.
createElement
(
"
hr
"
)
document
.
createTextNode
(
"
Double
click
to
focus
on
the
executions
related
to
this
event
.
"
)
)
;
return
true
;
}
else
if
(
target
.
classList
.
contains
(
"
tracer
-
slider
-
mutation
"
)
)
{
const
{
traceIndex
}
=
target
.
dataset
;
const
trace
=
this
.
props
.
allTraces
[
traceIndex
]
;
const
mutationType
=
trace
[
TRACER_FIELDS_INDEXES
.
DOM_MUTATION_TYPE
]
;
tooltip
.
panel
.
innerHTML
=
"
"
;
const
el
=
document
.
createElement
(
"
div
"
)
;
el
.
classList
.
add
(
"
tracer
-
dom
-
mutation
"
)
;
el
.
textContent
=
DOM
Mutation
|
{
mutationType
}
;
tooltip
.
panel
.
append
(
el
document
.
createElement
(
"
hr
"
)
document
.
createTextNode
(
"
Click
to
find
the
call
tree
leading
to
this
mutation
.
"
)
)
;
return
true
;
}
return
false
;
}
)
;
}
componentDidUpdate
(
)
{
if
(
DEBUG
)
{
dump
(
#
start
:
{
this
.
state
.
startIndex
}
end
:
{
this
.
state
.
endIndex
}
rendered
:
{
this
.
state
.
renderedTraceCount
}
traceCount
:
{
this
.
props
.
traceCount
}
\
n
)
;
}
}
renderTree
(
)
{
let
{
selectedTraceIndex
topTraces
allTraces
traceChildren
traceParents
}
=
this
.
props
;
if
(
!
allTraces
.
length
)
{
if
(
!
this
.
props
.
isTracing
)
{
return
div
(
{
className
:
"
tracer
-
message
"
}
"
Tracer
is
off
or
pending
for
next
interaction
/
load
.
"
)
;
}
return
div
(
{
className
:
"
tracer
-
message
"
}
"
Waiting
for
the
first
JavaScript
executions
"
)
;
}
if
(
!
topTraces
.
length
)
{
if
(
this
.
state
.
renderedTraceCount
!
=
this
.
props
.
traceCount
)
{
return
div
(
{
className
:
"
tracer
-
message
"
}
"
All
traces
have
been
filtered
out
in
the
slice
of
the
record
"
)
;
}
return
div
(
{
className
:
"
tracer
-
message
"
}
"
All
traces
have
been
filtered
out
"
)
;
}
let
{
startIndex
endIndex
}
=
this
.
state
;
startIndex
=
Math
.
floor
(
startIndex
)
;
endIndex
=
Math
.
floor
(
endIndex
)
;
if
(
startIndex
!
=
0
|
|
endIndex
!
=
-
1
)
{
let
topTracesStartIndex
=
0
;
if
(
startIndex
!
=
0
)
{
topTracesStartIndex
=
-
1
;
for
(
let
i
=
0
;
i
<
topTraces
.
length
;
i
+
+
)
{
const
traceIndex
=
topTraces
[
i
]
;
if
(
traceIndex
>
=
startIndex
)
{
topTracesStartIndex
=
i
;
break
;
}
}
}
let
topTracesEndIndex
=
topTraces
.
length
;
if
(
endIndex
!
=
-
1
)
{
for
(
let
i
=
topTraces
.
length
;
i
>
=
0
;
i
-
-
)
{
const
traceIndex
=
topTraces
[
i
]
;
if
(
traceIndex
<
=
endIndex
)
{
topTracesEndIndex
=
i
+
1
;
break
;
}
}
}
if
(
topTracesStartIndex
=
=
-
1
)
{
topTraces
=
[
startIndex
]
;
}
else
{
topTraces
=
topTraces
.
slice
(
topTracesStartIndex
topTracesEndIndex
)
;
}
if
(
startIndex
!
=
0
&
&
topTraces
[
0
]
!
=
startIndex
)
{
const
results
=
[
]
;
results
.
push
(
startIndex
)
;
collectAllSiblings
(
traceParents
traceChildren
startIndex
results
)
;
topTraces
.
unshift
(
.
.
.
results
)
;
}
}
return
React
.
createElement
(
VirtualizedTree
{
itemHeight
:
TREE_NODE_HEIGHT
autoExpandDepth
:
1
getRoots
(
)
{
return
topTraces
;
}
getKey
(
traceIndex
)
{
return
{
traceIndex
}
;
}
getParent
(
traceIndex
)
{
return
traceParents
[
traceIndex
]
;
}
getChildren
(
traceIndex
)
{
if
(
endIndex
!
=
-
1
)
{
return
traceChildren
[
traceIndex
]
.
filter
(
index
=
>
{
return
index
<
endIndex
;
}
)
;
}
return
traceChildren
[
traceIndex
]
;
}
isExpanded
:
traceIndex
=
>
{
return
this
.
state
.
expanded
.
has
(
traceIndex
)
;
}
onExpand
:
traceIndex
=
>
{
const
{
expanded
}
=
this
.
state
;
expanded
.
add
(
traceIndex
)
;
this
.
setState
(
{
expanded
}
)
;
}
onCollapse
:
traceIndex
=
>
{
const
{
expanded
}
=
this
.
state
;
expanded
.
delete
(
traceIndex
)
;
this
.
setState
(
{
expanded
}
)
;
}
focused
:
selectedTraceIndex
onFocus
:
traceIndex
=
>
{
this
.
props
.
selectTrace
(
traceIndex
)
;
}
shown
:
selectedTraceIndex
renderItem
:
(
traceIndex
_depth
isFocused
arrow
_isExpanded
)
=
>
{
const
trace
=
allTraces
[
traceIndex
]
;
const
type
=
trace
[
TRACER_FIELDS_INDEXES
.
TYPE
]
;
if
(
type
=
=
"
event
"
)
{
const
eventName
=
trace
[
TRACER_FIELDS_INDEXES
.
EVENT_NAME
]
;
const
eventType
=
getEventClassNameFromTraceEventName
(
eventName
)
;
return
div
(
{
className
:
"
trace
-
line
"
}
arrow
div
(
{
className
:
tracer
-
dom
-
event
{
eventType
}
{
selectedTraceIndex
=
=
traceIndex
?
"
selected
"
:
"
"
}
onDoubleClick
:
(
)
=
>
{
this
.
focusOnTrace
(
traceIndex
)
;
}
}
DOM
|
{
eventName
}
)
)
;
}
if
(
type
=
=
"
dom
-
mutation
"
)
{
const
mutationType
=
trace
[
TRACER_FIELDS_INDEXES
.
DOM_MUTATION_TYPE
]
;
return
div
(
{
className
:
tracer
-
dom
-
mutation
{
selectedTraceIndex
=
=
trace
?
"
selected
"
:
"
"
}
}
DOM
Mutation
|
{
mutationType
}
)
;
}
if
(
type
=
=
"
exit
"
)
{
return
null
;
}
let
className
=
"
"
;
if
(
selectedTraceIndex
)
{
let
idx
=
selectedTraceIndex
;
let
onStack
=
false
;
while
(
(
idx
=
traceParents
[
idx
]
)
)
{
if
(
idx
=
=
traceIndex
)
{
onStack
=
true
;
break
;
}
}
if
(
onStack
)
{
className
+
=
"
onstack
"
;
}
}
const
frameIndex
=
trace
[
TRACER_FIELDS_INDEXES
.
FRAME_INDEX
]
;
const
frame
=
this
.
props
.
frames
[
frameIndex
]
;
return
div
(
{
className
:
"
trace
-
line
"
onDoubleClick
:
(
)
=
>
{
this
.
focusOnTrace
(
traceIndex
)
;
}
}
arrow
FrameView
(
{
className
showFunctionName
:
true
showAnonymousFunctionName
:
true
frame
sourceMapURLService
:
window
.
sourceMapURLService
}
)
)
;
}
}
)
;
}
onSliderClick
(
event
)
{
const
{
top
height
}
=
this
.
refs
.
sliceSlider
.
getBoundingClientRect
(
)
;
const
yInSlider
=
event
.
clientY
-
top
;
const
mousePositionRatio
=
yInSlider
/
height
;
const
index
=
Math
.
round
(
this
.
state
.
startIndex
+
mousePositionRatio
*
this
.
state
.
renderedTraceCount
)
;
const
{
traceParents
}
=
this
.
props
;
const
parentIndex
=
getTraceParentIndex
(
traceParents
index
)
;
if
(
!
this
.
props
.
topTraces
.
includes
(
parentIndex
)
)
{
return
;
}
this
.
props
.
selectTrace
(
index
)
;
}
onSliderWheel
(
event
)
{
const
direction
=
event
.
deltaY
>
0
?
1
:
-
1
;
const
scrolledDelta
=
Math
.
abs
(
event
.
deltaY
)
*
0
.
01
;
let
{
startIndex
endIndex
}
=
this
.
state
;
if
(
isMacOS
?
event
.
metaKey
:
event
.
ctrlKey
)
{
const
{
top
height
}
=
this
.
refs
.
sliceSlider
.
getBoundingClientRect
(
)
;
const
yInSlider
=
event
.
clientY
-
top
;
const
zoomOriginRatio
=
yInSlider
/
height
;
const
shift
=
Math
.
floor
(
Math
.
max
(
this
.
state
.
renderedTraceCount
*
scrolledDelta
2
)
*
direction
)
;
startIndex
-
=
shift
*
zoomOriginRatio
;
if
(
endIndex
=
=
-
1
)
{
endIndex
=
this
.
props
.
traceCount
+
shift
*
(
1
-
zoomOriginRatio
)
;
}
else
{
endIndex
+
=
shift
*
(
1
-
zoomOriginRatio
)
;
}
}
else
{
if
(
(
direction
<
0
&
&
startIndex
=
=
0
)
|
|
(
direction
>
0
&
&
endIndex
=
=
-
1
)
)
{
return
;
}
const
shift
=
Math
.
max
(
1
this
.
state
.
renderedTraceCount
*
scrolledDelta
)
*
direction
;
startIndex
+
=
shift
;
if
(
endIndex
=
=
-
1
)
{
endIndex
=
this
.
props
.
traceCount
+
shift
;
}
else
{
endIndex
+
=
shift
;
}
}
startIndex
=
Math
.
max
(
0
startIndex
)
;
startIndex
=
Math
.
min
(
startIndex
this
.
props
.
traceCount
-
1
)
;
if
(
endIndex
!
=
-
1
)
{
endIndex
=
Math
.
max
(
startIndex
+
1
endIndex
)
;
if
(
endIndex
>
=
this
.
props
.
traceCount
)
{
endIndex
=
-
1
;
}
}
this
.
updateIndexes
(
{
startIndex
endIndex
}
)
;
}
updateIndexes
(
{
startIndex
endIndex
}
nextProps
=
this
.
props
)
{
const
renderedTraceCount
=
(
endIndex
=
=
-
1
?
nextProps
.
traceCount
:
endIndex
)
-
startIndex
;
this
.
setState
(
{
startIndex
endIndex
renderedTraceCount
}
)
;
if
(
this
.
tooltip
)
{
this
.
tooltip
.
hide
(
)
;
}
}
focusOnTrace
(
traceIndex
)
{
this
.
setState
(
{
selectedTabIndex
:
0
}
)
;
const
lastTraceIndex
=
findLastTraceIndex
(
this
.
props
.
traceChildren
traceIndex
)
;
this
.
updateIndexes
(
{
startIndex
:
traceIndex
endIndex
:
lastTraceIndex
}
)
;
}
resetZoom
(
)
{
this
.
updateIndexes
(
{
startIndex
:
0
endIndex
:
-
1
}
)
;
}
tracePositionInPercent
(
traceIndex
)
{
return
Math
.
round
(
(
(
traceIndex
-
this
.
state
.
startIndex
)
/
this
.
state
.
renderedTraceCount
)
*
100
)
;
}
renderMutationsInSlider
(
)
{
const
{
mutationTraces
allTraces
}
=
this
.
props
;
const
{
startIndex
endIndex
}
=
this
.
state
;
const
displayedMutationTraces
=
[
]
;
for
(
const
traceIndex
of
mutationTraces
)
{
if
(
traceIndex
>
=
startIndex
&
&
(
endIndex
=
=
-
1
|
|
traceIndex
<
=
endIndex
)
)
{
displayedMutationTraces
.
push
(
traceIndex
)
;
}
}
return
displayedMutationTraces
.
map
(
traceIndex
=
>
{
const
symbol
=
{
add
:
"
+
"
attributes
:
"
=
"
remove
:
"
-
"
}
;
const
trace
=
allTraces
[
traceIndex
]
;
const
mutationType
=
trace
[
TRACER_FIELDS_INDEXES
.
DOM_MUTATION_TYPE
]
;
return
div
(
{
className
:
tracer
-
slider
-
mutation
"
data
-
trace
-
index
"
:
traceIndex
style
:
{
top
:
{
this
.
tracePositionInPercent
(
traceIndex
)
}
%
}
onClick
:
event
=
>
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
this
.
props
.
selectTrace
(
traceIndex
)
;
}
}
symbol
[
mutationType
]
)
;
}
)
;
}
renderEventsInSlider
(
)
{
const
{
topTraces
allTraces
traceChildren
}
=
this
.
props
;
const
{
startIndex
endIndex
}
=
this
.
state
;
const
displayedTraceEvents
=
[
]
;
for
(
const
traceIndex
of
topTraces
)
{
const
lastTraceIndex
=
findLastTraceIndex
(
traceChildren
traceIndex
)
;
if
(
lastTraceIndex
>
=
startIndex
&
&
(
endIndex
=
=
-
1
|
|
traceIndex
<
=
endIndex
)
)
{
displayedTraceEvents
.
push
(
traceIndex
)
;
}
}
return
displayedTraceEvents
.
map
(
traceIndex
=
>
{
const
eventPositionInPercent
=
this
.
tracePositionInPercent
(
traceIndex
)
;
const
lastTraceIndex
=
findLastTraceIndex
(
traceChildren
traceIndex
)
;
const
eventHeightInPercent
=
Math
.
round
(
(
(
lastTraceIndex
-
traceIndex
)
/
this
.
state
.
renderedTraceCount
)
*
100
)
;
const
trace
=
allTraces
[
traceIndex
]
;
if
(
trace
[
TRACER_FIELDS_INDEXES
.
TYPE
]
!
=
"
event
"
)
{
return
null
;
}
const
eventName
=
trace
[
TRACER_FIELDS_INDEXES
.
EVENT_NAME
]
;
const
eventType
=
getEventClassNameFromTraceEventName
(
eventName
)
;
const
highlighted
=
this
.
props
.
highlightedDomEvents
.
includes
(
eventName
)
;
return
div
(
{
className
:
tracer
-
slider
-
event
{
eventType
}
{
highlighted
?
"
highlighted
"
:
"
"
}
"
data
-
trace
-
index
"
:
traceIndex
style
:
{
top
:
{
eventPositionInPercent
}
%
height
:
{
Math
.
max
(
Math
.
min
(
eventHeightInPercent
100
-
eventPositionInPercent
)
1
)
}
%
}
onClick
:
event
=
>
{
event
.
preventDefault
(
)
;
event
.
stopPropagation
(
)
;
this
.
props
.
selectTrace
(
traceIndex
)
;
}
onDoubleClick
:
(
)
=
>
{
this
.
focusOnTrace
(
traceIndex
)
;
}
}
)
;
}
)
;
}
renderVerticalSliders
(
)
{
if
(
!
this
.
props
.
traceCount
)
{
return
div
(
{
className
:
"
tracer
-
timeline
hidden
"
ref
:
"
timeline
"
onWheel
:
this
.
onSliderWheel
}
)
;
}
const
{
selectedTraceIndex
}
=
this
.
props
;
const
{
startIndex
endIndex
}
=
this
.
state
;
let
selectedHighlightHeight
;
if
(
selectedTraceIndex
>
startIndex
+
this
.
state
.
renderedTraceCount
)
{
selectedHighlightHeight
=
100
;
}
else
if
(
selectedTraceIndex
<
startIndex
)
{
selectedHighlightHeight
=
0
;
}
else
{
selectedHighlightHeight
=
this
.
tracePositionInPercent
(
selectedTraceIndex
)
;
}
const
classnames
=
[
]
;
if
(
startIndex
>
0
)
{
classnames
.
push
(
"
cut
-
start
"
)
;
}
if
(
endIndex
!
=
-
1
)
{
classnames
.
push
(
"
cut
-
end
"
)
;
}
if
(
selectedTraceIndex
)
{
if
(
selectedTraceIndex
<
startIndex
)
{
classnames
.
push
(
"
selected
-
before
"
)
;
}
else
if
(
endIndex
!
=
-
1
&
&
selectedTraceIndex
>
endIndex
)
{
classnames
.
push
(
"
selected
-
after
"
)
;
}
}
const
isZoomed
=
this
.
state
.
renderedTraceCount
!
=
this
.
props
.
traceCount
;
return
div
(
{
className
:
"
tracer
-
timeline
"
}
div
(
{
className
:
tracer
-
slider
-
box
{
classnames
.
join
(
"
"
)
}
ref
:
"
timeline
"
onWheel
:
this
.
onSliderWheel
}
div
(
{
className
:
"
tracer
-
slice
-
slider
"
ref
:
"
sliceSlider
"
onClick
:
this
.
onSliderClick
style
:
{
"
-
-
slider
-
bar
-
progress
"
:
{
selectedHighlightHeight
}
%
}
}
selectedTraceIndex
?
div
(
{
className
:
"
tracer
-
slider
-
bar
"
}
)
:
null
selectedTraceIndex
&
&
selectedTraceIndex
>
=
startIndex
&
&
selectedTraceIndex
<
=
startIndex
+
this
.
state
.
renderedTraceCount
?
div
(
{
className
:
"
tracer
-
slider
-
position
"
}
)
:
null
this
.
renderEventsInSlider
(
)
this
.
renderMutationsInSlider
(
)
)
)
isZoomed
?
button
(
{
className
:
"
tracer
-
reset
-
zoom
"
onClick
:
this
.
resetZoom
}
"
Reset
zoom
"
)
:
null
)
;
}
render
(
)
{
const
{
runtimeVersions
}
=
this
.
props
;
return
div
(
{
className
:
"
tracer
-
container
"
style
:
{
"
-
-
tree
-
node
-
height
"
:
{
TREE_NODE_HEIGHT
}
px
}
}
div
(
{
className
:
"
tracer
-
toolbar
"
}
this
.
props
.
traceCount
=
=
0
?
div
(
{
className
:
"
tracer
-
experimental
-
notice
"
}
"
This
panel
is
experimental
.
It
may
change
regress
be
dropped
or
replaced
.
"
)
:
null
runtimeVersions
&
&
runtimeVersions
.
localPlatformVersion
!
=
runtimeVersions
.
remotePlatformVersion
?
div
(
{
className
:
"
tracer
-
runtime
-
version
-
mismatch
"
}
Client
and
remote
runtime
have
different
versions
(
{
runtimeVersions
.
localPlatformVersion
}
vs
{
runtimeVersions
.
remotePlatformVersion
}
)
.
The
Tracer
may
be
broken
because
of
protocol
changes
between
these
two
versions
.
Please
upgrade
or
downgrade
one
of
the
two
to
use
the
same
major
version
.
)
:
null
)
this
.
renderVerticalSliders
(
)
React
.
createElement
(
Tabs
{
activeTab
:
this
.
state
.
selectedTabIndex
|
|
0
onAfterChange
:
index
=
>
{
this
.
setState
(
{
selectedTabIndex
:
index
}
)
;
}
}
React
.
createElement
(
TabPanel
{
id
:
"
tracer
-
traces
"
title
:
"
Call
Traces
"
}
this
.
renderTree
(
)
)
React
.
createElement
(
TabPanel
{
id
:
"
tracer
-
events
"
title
:
"
DOM
Events
"
}
div
(
{
className
:
"
event
-
listeners
-
container
"
}
React
.
createElement
(
EventListeners
{
panelKey
:
"
tracer
"
}
)
footer
(
null
{
isMacOS
?
"
Cmd
"
:
"
Ctrl
"
}
+
Click
to
select
only
one
category
or
event
)
)
)
)
)
;
}
}
function
findLastTraceIndex
(
traceChildren
traceIndex
)
{
const
children
=
traceChildren
[
traceIndex
]
;
if
(
!
children
.
length
)
{
return
traceIndex
;
}
return
findLastTraceIndex
(
traceChildren
children
.
at
(
-
1
)
)
;
}
function
collectAllSiblings
(
traceParents
traceChildren
traceIndex
results
)
{
const
parentIndex
=
traceParents
[
traceIndex
]
;
if
(
parentIndex
!
=
null
)
{
const
parentChildren
=
traceChildren
[
parentIndex
]
;
const
indexInItsParent
=
parentChildren
.
indexOf
(
traceIndex
)
;
const
siblingTraces
=
parentChildren
.
slice
(
indexInItsParent
+
1
)
;
if
(
siblingTraces
.
length
)
{
results
.
push
(
.
.
.
siblingTraces
)
;
}
collectAllSiblings
(
traceParents
traceChildren
parentIndex
results
)
;
}
}
function
getEventClassNameFromTraceEventName
(
eventName
)
{
let
eventType
=
"
other
"
;
if
(
eventName
.
startsWith
(
"
global
.
mouse
"
)
|
|
eventName
.
startsWith
(
"
global
.
click
"
)
|
|
eventName
.
startsWith
(
"
node
.
mouse
"
)
|
|
eventName
.
startsWith
(
"
node
.
click
"
)
)
{
eventType
=
"
mouse
"
;
}
else
if
(
eventName
.
startsWith
(
"
global
.
key
"
)
|
|
eventName
.
startsWith
(
"
node
.
key
"
)
)
{
eventType
=
"
key
"
;
}
return
eventType
;
}
function
getTraceParentIndex
(
traceParents
index
)
{
const
parentIndex
=
traceParents
[
index
]
;
if
(
parentIndex
=
=
undefined
)
{
return
index
;
}
return
getTraceParentIndex
(
traceParents
parentIndex
)
;
}
const
mapStateToProps
=
state
=
>
{
return
{
isTracing
:
getIsCurrentlyTracing
(
state
)
topTraces
:
getFilteredTopTraces
(
state
)
allTraces
:
getAllTraces
(
state
)
traceChildren
:
getTraceChildren
(
state
)
traceParents
:
getTraceParents
(
state
)
frames
:
getTraceFrames
(
state
)
mutationTraces
:
getAllMutationTraces
(
state
)
traceCount
:
getAllTraceCount
(
state
)
selectedTraceIndex
:
getSelectedTraceIndex
(
state
)
runtimeVersions
:
getRuntimeVersions
(
state
)
highlightedDomEvents
:
getTraceHighlightedDomEvents
(
state
)
}
;
}
;
export
default
connect
(
mapStateToProps
{
selectTrace
:
actions
.
selectTrace
}
)
(
Tracer
)
;
