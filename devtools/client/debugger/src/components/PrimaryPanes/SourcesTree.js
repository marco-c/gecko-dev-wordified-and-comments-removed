import
React
{
Component
}
from
"
react
"
;
import
PropTypes
from
"
prop
-
types
"
;
import
{
connect
}
from
"
.
.
/
.
.
/
utils
/
connect
"
;
import
{
getSelectedLocation
getMainThreadHost
getExpandedState
getProjectDirectoryRoot
getProjectDirectoryRootName
getSourcesTreeSources
getFocusedSourceItem
getContext
getGeneratedSourceByURL
getBlackBoxRanges
getHideIgnoredSources
}
from
"
.
.
/
.
.
/
selectors
"
;
import
actions
from
"
.
.
/
.
.
/
actions
"
;
import
SourcesTreeItem
from
"
.
/
SourcesTreeItem
"
;
import
AccessibleImage
from
"
.
.
/
shared
/
AccessibleImage
"
;
import
{
getRawSourceURL
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
createLocation
}
from
"
.
.
/
.
.
/
utils
/
location
"
;
const
classnames
=
require
(
"
devtools
/
client
/
shared
/
classnames
.
js
"
)
;
const
Tree
=
require
(
"
devtools
/
client
/
shared
/
components
/
Tree
"
)
;
function
shouldAutoExpand
(
item
mainThreadHost
)
{
return
item
.
type
=
=
"
group
"
&
&
item
.
groupName
=
=
=
mainThreadHost
;
}
function
getSourceItemForTreeLocation
(
treeLocation
rootItems
)
{
const
{
source
sourceActor
}
=
treeLocation
;
if
(
!
source
.
url
)
{
return
null
;
}
const
{
displayURL
}
=
source
;
function
findSourceInItem
(
item
path
)
{
if
(
item
.
type
=
=
"
source
"
)
{
if
(
item
.
source
.
url
=
=
source
.
url
)
{
return
item
;
}
return
null
;
}
if
(
item
.
type
=
=
"
thread
"
&
&
item
.
threadActorID
!
=
sourceActor
?
.
thread
)
{
return
null
;
}
if
(
item
.
type
=
=
"
group
"
&
&
displayURL
.
group
!
=
item
.
groupName
)
{
return
null
;
}
if
(
item
.
type
=
=
"
directory
"
&
&
!
path
.
startsWith
(
item
.
path
)
)
{
return
null
;
}
for
(
const
child
of
item
.
children
)
{
const
match
=
findSourceInItem
(
child
path
)
;
if
(
match
)
{
return
match
;
}
}
return
null
;
}
for
(
const
rootItem
of
rootItems
)
{
const
item
=
findSourceInItem
(
rootItem
displayURL
.
path
)
;
if
(
item
)
{
return
item
;
}
}
return
null
;
}
class
SourcesTree
extends
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
}
;
}
static
get
propTypes
(
)
{
return
{
cx
:
PropTypes
.
object
.
isRequired
mainThreadHost
:
PropTypes
.
string
.
isRequired
expanded
:
PropTypes
.
object
.
isRequired
focusItem
:
PropTypes
.
func
.
isRequired
focused
:
PropTypes
.
object
projectRoot
:
PropTypes
.
string
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
selectedTreeLocation
:
PropTypes
.
object
setExpandedState
:
PropTypes
.
func
.
isRequired
blackBoxRanges
:
PropTypes
.
object
.
isRequired
rootItems
:
PropTypes
.
object
.
isRequired
clearProjectDirectoryRoot
:
PropTypes
.
func
.
isRequired
projectRootName
:
PropTypes
.
string
.
isRequired
setHideOrShowIgnoredSources
:
PropTypes
.
func
.
isRequired
hideIgnoredSources
:
PropTypes
.
bool
.
isRequired
}
;
}
UNSAFE_componentWillReceiveProps
(
nextProps
)
{
const
{
selectedTreeLocation
}
=
this
.
props
;
if
(
nextProps
.
selectedTreeLocation
?
.
source
&
&
(
nextProps
.
selectedTreeLocation
.
source
!
=
selectedTreeLocation
?
.
source
|
|
(
nextProps
.
selectedTreeLocation
.
source
=
=
=
selectedTreeLocation
?
.
source
&
&
nextProps
.
selectedTreeLocation
.
sourceActor
!
=
selectedTreeLocation
?
.
sourceActor
)
|
|
!
this
.
props
.
focused
)
)
{
const
sourceItem
=
getSourceItemForTreeLocation
(
nextProps
.
selectedTreeLocation
this
.
props
.
rootItems
)
;
if
(
sourceItem
)
{
const
expanded
=
new
Set
(
this
.
props
.
expanded
)
;
let
parentDirectory
=
sourceItem
;
while
(
parentDirectory
)
{
expanded
.
add
(
this
.
getKey
(
parentDirectory
)
)
;
parentDirectory
=
this
.
getParent
(
parentDirectory
)
;
}
this
.
props
.
setExpandedState
(
expanded
)
;
this
.
onFocus
(
sourceItem
)
;
}
}
}
selectSourceItem
=
item
=
>
{
this
.
props
.
selectSource
(
this
.
props
.
cx
item
.
source
item
.
sourceActor
)
;
}
;
onFocus
=
item
=
>
{
this
.
props
.
focusItem
(
item
)
;
}
;
onActivate
=
item
=
>
{
if
(
item
.
type
=
=
"
source
"
)
{
this
.
selectSourceItem
(
item
)
;
}
}
;
onExpand
=
(
item
shouldIncludeChildren
)
=
>
{
this
.
setExpanded
(
item
true
shouldIncludeChildren
)
;
}
;
onCollapse
=
(
item
shouldIncludeChildren
)
=
>
{
this
.
setExpanded
(
item
false
shouldIncludeChildren
)
;
}
;
setExpanded
=
(
item
isExpanded
shouldIncludeChildren
)
=
>
{
const
{
expanded
}
=
this
.
props
;
let
changed
=
false
;
const
expandItem
=
i
=
>
{
const
key
=
this
.
getKey
(
i
)
;
if
(
isExpanded
)
{
changed
|
=
!
expanded
.
has
(
key
)
;
expanded
.
add
(
key
)
;
}
else
{
changed
|
=
expanded
.
has
(
key
)
;
expanded
.
delete
(
key
)
;
}
}
;
expandItem
(
item
)
;
if
(
shouldIncludeChildren
)
{
let
parents
=
[
item
]
;
while
(
parents
.
length
)
{
const
children
=
[
]
;
for
(
const
parent
of
parents
)
{
for
(
const
child
of
this
.
getChildren
(
parent
)
)
{
expandItem
(
child
)
;
children
.
push
(
child
)
;
}
}
parents
=
children
;
}
}
if
(
changed
)
{
this
.
props
.
setExpandedState
(
expanded
)
;
}
}
;
isEmpty
(
)
{
return
!
this
.
getRoots
(
)
.
length
;
}
renderEmptyElement
(
message
)
{
return
(
<
div
key
=
"
empty
"
className
=
"
no
-
sources
-
message
"
>
{
message
}
<
/
div
>
)
;
}
getRoots
=
(
)
=
>
{
return
this
.
props
.
rootItems
;
}
;
getKey
=
item
=
>
{
const
{
projectRoot
}
=
this
.
props
;
if
(
projectRoot
)
{
return
projectRoot
+
item
.
uniquePath
;
}
return
item
.
uniquePath
;
}
;
getChildren
=
item
=
>
{
function
skipEmptyDirectories
(
directory
)
{
if
(
directory
.
type
!
=
"
directory
"
)
{
return
directory
;
}
if
(
directory
.
children
.
length
=
=
1
&
&
directory
.
children
[
0
]
.
type
=
=
"
directory
"
)
{
return
skipEmptyDirectories
(
directory
.
children
[
0
]
)
;
}
return
directory
;
}
if
(
item
.
type
=
=
"
thread
"
)
{
return
item
.
children
;
}
else
if
(
item
.
type
=
=
"
group
"
|
|
item
.
type
=
=
"
directory
"
)
{
return
item
.
children
.
map
(
skipEmptyDirectories
)
;
}
return
[
]
;
}
;
getParent
=
item
=
>
{
if
(
item
.
type
=
=
"
thread
"
)
{
return
null
;
}
const
{
rootItems
}
=
this
.
props
;
function
skipEmptyDirectories
(
directory
)
{
if
(
directory
.
type
=
=
"
group
"
|
|
directory
.
type
=
=
"
thread
"
|
|
rootItems
.
includes
(
directory
)
)
{
return
directory
;
}
if
(
directory
.
children
.
length
=
=
1
&
&
directory
.
children
[
0
]
.
type
=
=
"
directory
"
)
{
return
skipEmptyDirectories
(
directory
.
parent
)
;
}
return
directory
;
}
return
skipEmptyDirectories
(
item
.
parent
)
;
}
;
getBlackBoxSourcesGroups
=
item
=
>
{
const
allSources
=
[
]
;
function
collectAllSources
(
list
_item
)
{
if
(
_item
.
children
)
{
_item
.
children
.
forEach
(
i
=
>
collectAllSources
(
list
i
)
)
;
}
if
(
_item
.
type
=
=
"
source
"
)
{
list
.
push
(
_item
.
source
)
;
}
}
for
(
const
rootItem
of
this
.
props
.
rootItems
)
{
collectAllSources
(
allSources
rootItem
)
;
}
const
sourcesInside
=
[
]
;
collectAllSources
(
sourcesInside
item
)
;
const
sourcesOutside
=
allSources
.
filter
(
source
=
>
!
sourcesInside
.
includes
(
source
)
)
;
const
allInsideBlackBoxed
=
sourcesInside
.
every
(
source
=
>
this
.
props
.
blackBoxRanges
[
source
.
url
]
)
;
const
allOutsideBlackBoxed
=
sourcesOutside
.
every
(
source
=
>
this
.
props
.
blackBoxRanges
[
source
.
url
]
)
;
return
{
sourcesInside
sourcesOutside
allInsideBlackBoxed
allOutsideBlackBoxed
}
;
}
;
renderProjectRootHeader
(
)
{
const
{
cx
projectRootName
}
=
this
.
props
;
if
(
!
projectRootName
)
{
return
null
;
}
return
(
<
div
key
=
"
root
"
className
=
"
sources
-
clear
-
root
-
container
"
>
<
button
className
=
"
sources
-
clear
-
root
"
onClick
=
{
(
)
=
>
this
.
props
.
clearProjectDirectoryRoot
(
cx
)
}
title
=
{
L10N
.
getStr
(
"
removeDirectoryRoot
.
label
"
)
}
>
<
AccessibleImage
className
=
"
home
"
/
>
<
AccessibleImage
className
=
"
breadcrumb
"
/
>
<
span
className
=
"
sources
-
clear
-
root
-
label
"
>
{
projectRootName
}
<
/
span
>
<
/
button
>
<
/
div
>
)
;
}
renderItem
=
(
item
depth
focused
_
expanded
)
=
>
{
const
{
mainThreadHost
projectRoot
}
=
this
.
props
;
return
(
<
SourcesTreeItem
item
=
{
item
}
depth
=
{
depth
}
focused
=
{
focused
}
autoExpand
=
{
shouldAutoExpand
(
item
mainThreadHost
)
}
expanded
=
{
expanded
}
focusItem
=
{
this
.
onFocus
}
selectSourceItem
=
{
this
.
selectSourceItem
}
projectRoot
=
{
projectRoot
}
setExpanded
=
{
this
.
setExpanded
}
getBlackBoxSourcesGroups
=
{
this
.
getBlackBoxSourcesGroups
}
getParent
=
{
this
.
getParent
}
/
>
)
;
}
;
renderTree
(
)
{
const
{
expanded
focused
}
=
this
.
props
;
const
treeProps
=
{
autoExpandAll
:
false
autoExpandDepth
:
1
expanded
focused
getChildren
:
this
.
getChildren
getParent
:
this
.
getParent
getKey
:
this
.
getKey
getRoots
:
this
.
getRoots
itemHeight
:
21
key
:
this
.
isEmpty
(
)
?
"
empty
"
:
"
full
"
onCollapse
:
this
.
onCollapse
onExpand
:
this
.
onExpand
onFocus
:
this
.
onFocus
isExpanded
:
item
=
>
{
return
this
.
props
.
expanded
.
has
(
this
.
getKey
(
item
)
)
;
}
onActivate
:
this
.
onActivate
renderItem
:
this
.
renderItem
preventBlur
:
true
}
;
return
<
Tree
{
.
.
.
treeProps
}
/
>
;
}
renderPane
(
child
)
{
const
{
projectRoot
}
=
this
.
props
;
return
(
<
div
key
=
"
pane
"
className
=
{
classnames
(
"
sources
-
pane
"
{
"
sources
-
list
-
custom
-
root
"
:
!
!
projectRoot
}
)
}
>
{
child
}
<
/
div
>
)
;
}
renderFooter
(
)
{
if
(
this
.
props
.
hideIgnoredSources
)
{
return
(
<
footer
className
=
"
source
-
list
-
footer
"
>
{
L10N
.
getStr
(
"
ignoredSourcesHidden
"
)
}
<
button
className
=
"
devtools
-
togglebutton
"
onClick
=
{
(
)
=
>
this
.
props
.
setHideOrShowIgnoredSources
(
false
)
}
title
=
{
L10N
.
getStr
(
"
showIgnoredSources
.
tooltip
.
label
"
)
}
>
{
L10N
.
getStr
(
"
showIgnoredSources
"
)
}
<
/
button
>
<
/
footer
>
)
;
}
return
null
;
}
render
(
)
{
const
{
projectRoot
}
=
this
.
props
;
return
(
<
div
key
=
"
pane
"
className
=
{
classnames
(
"
sources
-
list
"
{
"
sources
-
list
-
custom
-
root
"
:
!
!
projectRoot
}
)
}
>
{
this
.
isEmpty
(
)
?
(
this
.
renderEmptyElement
(
L10N
.
getStr
(
"
noSourcesText
"
)
)
)
:
(
<
>
{
this
.
renderProjectRootHeader
(
)
}
{
this
.
renderTree
(
)
}
{
this
.
renderFooter
(
)
}
<
/
>
)
}
<
/
div
>
)
;
}
}
function
getTreeLocation
(
state
location
)
{
if
(
location
?
.
source
.
isPrettyPrinted
)
{
const
source
=
getGeneratedSourceByURL
(
state
getRawSourceURL
(
location
.
source
.
url
)
)
;
if
(
source
)
{
return
createLocation
(
{
source
sourceActor
:
location
.
sourceActor
}
)
;
}
}
return
location
;
}
const
mapStateToProps
=
state
=
>
{
const
rootItems
=
getSourcesTreeSources
(
state
)
;
return
{
cx
:
getContext
(
state
)
selectedTreeLocation
:
getTreeLocation
(
state
getSelectedLocation
(
state
)
)
mainThreadHost
:
getMainThreadHost
(
state
)
expanded
:
getExpandedState
(
state
)
focused
:
getFocusedSourceItem
(
state
)
projectRoot
:
getProjectDirectoryRoot
(
state
)
rootItems
blackBoxRanges
:
getBlackBoxRanges
(
state
)
projectRootName
:
getProjectDirectoryRootName
(
state
)
hideIgnoredSources
:
getHideIgnoredSources
(
state
)
}
;
}
;
export
default
connect
(
mapStateToProps
{
selectSource
:
actions
.
selectSource
setExpandedState
:
actions
.
setExpandedState
focusItem
:
actions
.
focusItem
clearProjectDirectoryRoot
:
actions
.
clearProjectDirectoryRoot
setHideOrShowIgnoredSources
:
actions
.
setHideOrShowIgnoredSources
}
)
(
SourcesTree
)
;
