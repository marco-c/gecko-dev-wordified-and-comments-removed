import
React
{
Component
}
from
"
react
"
;
import
PropTypes
from
"
prop
-
types
"
;
import
classnames
from
"
classnames
"
;
import
{
connect
}
from
"
.
.
/
.
.
/
utils
/
connect
"
;
import
{
getSelectedSource
getMainThreadHost
getExpandedState
getProjectDirectoryRoot
getSourcesTreeSources
getFocusedSourceItem
getContext
getGeneratedSourceByURL
getBlackBoxRanges
}
from
"
.
.
/
.
.
/
selectors
"
;
import
actions
from
"
.
.
/
.
.
/
actions
"
;
import
SourcesTreeItem
from
"
.
/
SourcesTreeItem
"
;
import
ManagedTree
from
"
.
.
/
shared
/
ManagedTree
"
;
import
{
getRawSourceURL
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
function
shouldAutoExpand
(
item
mainThreadHost
)
{
return
item
.
type
=
=
"
group
"
&
&
item
.
groupName
=
=
=
mainThreadHost
;
}
function
getDirectoryForSource
(
source
rootItems
)
{
if
(
!
source
.
url
)
{
return
null
;
}
const
{
displayURL
}
=
source
;
function
findSourceInItem
(
item
path
)
{
if
(
item
.
type
=
=
"
source
"
)
{
if
(
item
.
source
.
url
=
=
source
.
url
)
{
return
item
;
}
return
null
;
}
if
(
item
.
type
=
=
"
thread
"
&
&
source
.
thread
!
=
item
.
thread
.
actor
)
{
return
null
;
}
if
(
item
.
type
=
=
"
group
"
&
&
displayURL
.
group
!
=
item
.
groupName
)
{
return
null
;
}
if
(
item
.
type
=
=
"
directory
"
&
&
!
path
.
startsWith
(
item
.
path
)
)
{
return
null
;
}
for
(
const
child
of
item
.
children
)
{
const
match
=
findSourceInItem
(
child
path
)
;
if
(
match
)
{
return
match
;
}
}
}
for
(
const
rootItem
of
rootItems
)
{
const
item
=
findSourceInItem
(
rootItem
displayURL
.
path
)
;
if
(
item
)
{
return
item
;
}
}
return
null
;
}
class
SourcesTree
extends
Component
{
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
}
;
}
static
get
propTypes
(
)
{
return
{
cx
:
PropTypes
.
object
.
isRequired
mainThreadHost
:
PropTypes
.
string
.
isRequired
expanded
:
PropTypes
.
object
.
isRequired
focusItem
:
PropTypes
.
func
.
isRequired
focused
:
PropTypes
.
object
projectRoot
:
PropTypes
.
string
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
selectedSource
:
PropTypes
.
object
setExpandedState
:
PropTypes
.
func
.
isRequired
blackBoxRanges
:
PropTypes
.
object
.
isRequired
rootItems
:
PropTypes
.
object
.
isRequired
}
;
}
UNSAFE_componentWillReceiveProps
(
nextProps
)
{
const
{
selectedSource
}
=
this
.
props
;
if
(
nextProps
.
selectedSource
&
&
(
nextProps
.
selectedSource
!
=
selectedSource
|
|
!
this
.
state
.
highlightItems
?
.
length
)
)
{
let
parentDirectory
=
getDirectoryForSource
(
nextProps
.
selectedSource
this
.
props
.
rootItems
)
;
const
highlightItems
=
[
]
;
while
(
parentDirectory
)
{
highlightItems
.
push
(
parentDirectory
)
;
parentDirectory
=
this
.
getParent
(
parentDirectory
)
;
}
this
.
setState
(
{
highlightItems
}
)
;
}
}
selectSourceItem
=
item
=
>
{
this
.
props
.
selectSource
(
this
.
props
.
cx
item
.
source
.
id
)
;
}
;
onFocus
=
item
=
>
{
this
.
props
.
focusItem
(
item
)
;
}
;
onActivate
=
item
=
>
{
if
(
item
.
type
=
=
"
source
"
)
{
this
.
selectSourceItem
(
item
)
;
}
}
;
onExpand
=
(
item
expandedState
)
=
>
{
this
.
props
.
setExpandedState
(
expandedState
)
;
}
;
onCollapse
=
(
item
expandedState
)
=
>
{
this
.
props
.
setExpandedState
(
expandedState
)
;
}
;
isEmpty
(
)
{
return
!
this
.
getRoots
(
)
.
length
;
}
renderEmptyElement
(
message
)
{
return
(
<
div
key
=
"
empty
"
className
=
"
no
-
sources
-
message
"
>
{
message
}
<
/
div
>
)
;
}
getRoots
=
(
)
=
>
{
return
this
.
props
.
rootItems
;
}
;
getPath
=
item
=
>
{
const
{
projectRoot
}
=
this
.
props
;
if
(
projectRoot
)
{
return
projectRoot
+
item
.
uniquePath
;
}
return
item
.
uniquePath
;
}
;
getChildren
=
item
=
>
{
function
skipEmptyDirectories
(
directory
)
{
if
(
directory
.
type
!
=
"
directory
"
)
{
return
directory
;
}
if
(
directory
.
children
.
length
=
=
1
&
&
directory
.
children
[
0
]
.
type
=
=
"
directory
"
)
{
return
skipEmptyDirectories
(
directory
.
children
[
0
]
)
;
}
return
directory
;
}
if
(
item
.
type
=
=
"
thread
"
)
{
return
item
.
children
;
}
else
if
(
item
.
type
=
=
"
group
"
|
|
item
.
type
=
=
"
directory
"
)
{
return
item
.
children
.
map
(
skipEmptyDirectories
)
;
}
return
[
]
;
}
;
getParent
=
item
=
>
{
if
(
item
.
type
=
=
"
thread
"
)
{
return
null
;
}
const
{
rootItems
}
=
this
.
props
;
function
skipEmptyDirectories
(
directory
)
{
if
(
directory
.
type
=
=
"
group
"
|
|
directory
.
type
=
=
"
thread
"
|
|
rootItems
.
includes
(
directory
)
)
{
return
directory
;
}
if
(
directory
.
children
.
length
=
=
1
&
&
directory
.
children
[
0
]
.
type
=
=
"
directory
"
)
{
return
skipEmptyDirectories
(
directory
.
parent
)
;
}
return
directory
;
}
return
skipEmptyDirectories
(
item
.
parent
)
;
}
;
getBlackBoxSourcesGroups
=
item
=
>
{
const
allSources
=
[
]
;
function
collectAllSources
(
list
_item
)
{
if
(
_item
.
children
)
{
_item
.
children
.
forEach
(
i
=
>
collectAllSources
(
list
i
)
)
;
}
if
(
_item
.
type
=
=
"
source
"
)
{
list
.
push
(
_item
.
source
)
;
}
}
for
(
const
rootItem
of
this
.
props
.
rootItems
)
{
collectAllSources
(
allSources
rootItem
)
;
}
const
sourcesInside
=
[
]
;
collectAllSources
(
sourcesInside
item
)
;
const
sourcesOutside
=
allSources
.
filter
(
source
=
>
!
sourcesInside
.
includes
(
source
)
)
;
const
allInsideBlackBoxed
=
sourcesInside
.
every
(
source
=
>
this
.
props
.
blackBoxRanges
[
source
.
url
]
)
;
const
allOutsideBlackBoxed
=
sourcesOutside
.
every
(
source
=
>
this
.
props
.
blackBoxRanges
[
source
.
url
]
)
;
return
{
sourcesInside
sourcesOutside
allInsideBlackBoxed
allOutsideBlackBoxed
}
;
}
;
renderItem
=
(
item
depth
focused
_
expanded
{
setExpanded
}
)
=
>
{
const
{
mainThreadHost
projectRoot
}
=
this
.
props
;
const
isSourceBlackBoxed
=
item
.
source
?
this
.
props
.
blackBoxRanges
[
item
.
source
.
url
]
:
null
;
return
(
<
SourcesTreeItem
item
=
{
item
}
depth
=
{
depth
}
focused
=
{
focused
}
autoExpand
=
{
shouldAutoExpand
(
item
mainThreadHost
)
}
expanded
=
{
expanded
}
focusItem
=
{
this
.
onFocus
}
selectSourceItem
=
{
this
.
selectSourceItem
}
isSourceBlackBoxed
=
{
isSourceBlackBoxed
}
projectRoot
=
{
projectRoot
}
setExpanded
=
{
setExpanded
}
getBlackBoxSourcesGroups
=
{
this
.
getBlackBoxSourcesGroups
}
getParent
=
{
this
.
getParent
}
/
>
)
;
}
;
renderTree
(
)
{
const
{
expanded
focused
}
=
this
.
props
;
const
{
highlightItems
}
=
this
.
state
;
const
treeProps
=
{
autoExpandAll
:
false
autoExpandDepth
:
1
expanded
focused
getChildren
:
this
.
getChildren
getParent
:
this
.
getParent
getPath
:
this
.
getPath
getRoots
:
this
.
getRoots
highlightItems
itemHeight
:
21
key
:
this
.
isEmpty
(
)
?
"
empty
"
:
"
full
"
onCollapse
:
this
.
onCollapse
onExpand
:
this
.
onExpand
onFocus
:
this
.
onFocus
onActivate
:
this
.
onActivate
renderItem
:
this
.
renderItem
preventBlur
:
true
}
;
return
<
ManagedTree
{
.
.
.
treeProps
}
/
>
;
}
renderPane
(
child
)
{
const
{
projectRoot
}
=
this
.
props
;
return
(
<
div
key
=
"
pane
"
className
=
{
classnames
(
"
sources
-
pane
"
{
"
sources
-
list
-
custom
-
root
"
:
!
!
projectRoot
}
)
}
>
{
child
}
<
/
div
>
)
;
}
render
(
)
{
return
this
.
renderPane
(
this
.
isEmpty
(
)
?
(
this
.
renderEmptyElement
(
L10N
.
getStr
(
"
noSourcesText
"
)
)
)
:
(
<
div
key
=
"
tree
"
className
=
"
sources
-
list
"
>
{
this
.
renderTree
(
)
}
<
/
div
>
)
)
;
}
}
function
getSourceForTree
(
state
source
)
{
if
(
!
source
)
{
return
null
;
}
if
(
!
source
.
isPrettyPrinted
)
{
return
source
;
}
return
getGeneratedSourceByURL
(
state
getRawSourceURL
(
source
.
url
)
)
;
}
const
mapStateToProps
=
state
=
>
{
const
selectedSource
=
getSelectedSource
(
state
)
;
const
rootItems
=
getSourcesTreeSources
(
state
)
;
return
{
cx
:
getContext
(
state
)
selectedSource
:
getSourceForTree
(
state
selectedSource
)
mainThreadHost
:
getMainThreadHost
(
state
)
expanded
:
getExpandedState
(
state
)
focused
:
getFocusedSourceItem
(
state
)
projectRoot
:
getProjectDirectoryRoot
(
state
)
rootItems
blackBoxRanges
:
getBlackBoxRanges
(
state
)
}
;
}
;
export
default
connect
(
mapStateToProps
{
selectSource
:
actions
.
selectSource
setExpandedState
:
actions
.
setExpandedState
focusItem
:
actions
.
focusItem
}
)
(
SourcesTree
)
;
