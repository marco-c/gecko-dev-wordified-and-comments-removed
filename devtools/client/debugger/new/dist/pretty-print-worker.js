(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
]
factory
)
;
else
{
var
a
=
factory
(
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
typeof
self
!
=
=
'
undefined
'
?
self
:
this
function
(
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
{
return
installedModules
[
moduleId
]
.
exports
;
}
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
1282
)
;
}
)
(
{
1282
:
(
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
1630
)
;
}
)
1630
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_prettyFast
=
__webpack_require__
(
802
)
;
var
_prettyFast2
=
_interopRequireDefault
(
_prettyFast
)
;
var
_devtoolsUtils
=
__webpack_require__
(
3651
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
{
workerHandler
}
=
_devtoolsUtils
.
workerUtils
;
function
prettyPrint
(
{
url
indent
sourceText
}
)
{
const
prettified
=
(
0
_prettyFast2
.
default
)
(
sourceText
{
url
:
url
indent
:
"
"
.
repeat
(
indent
)
}
)
;
return
{
code
:
prettified
.
code
mappings
:
invertMappings
(
prettified
.
map
.
_mappings
)
}
;
}
function
invertMappings
(
mappings
)
{
return
mappings
.
_array
.
map
(
m
=
>
{
const
mapping
=
{
generated
:
{
line
:
m
.
originalLine
column
:
m
.
originalColumn
}
}
;
if
(
m
.
source
)
{
mapping
.
source
=
m
.
source
;
mapping
.
original
=
{
line
:
m
.
generatedLine
column
:
m
.
generatedColumn
}
;
mapping
.
name
=
m
.
name
;
}
return
mapping
;
}
)
;
}
self
.
onmessage
=
workerHandler
(
{
prettyPrint
}
)
;
}
)
3651
:
(
function
(
module
exports
__webpack_require__
)
{
const
networkRequest
=
__webpack_require__
(
3653
)
;
const
workerUtils
=
__webpack_require__
(
3654
)
;
module
.
exports
=
{
networkRequest
workerUtils
}
;
}
)
3653
:
(
function
(
module
exports
)
{
function
networkRequest
(
url
opts
)
{
return
fetch
(
url
{
cache
:
opts
.
loadFromCache
?
"
default
"
:
"
no
-
cache
"
}
)
.
then
(
res
=
>
{
if
(
res
.
status
>
=
200
&
&
res
.
status
<
300
)
{
return
res
.
text
(
)
.
then
(
text
=
>
(
{
content
:
text
}
)
)
;
}
return
Promise
.
reject
(
request
failed
with
status
{
res
.
status
}
)
;
}
)
;
}
module
.
exports
=
networkRequest
;
}
)
3654
:
(
function
(
module
exports
)
{
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
function
WorkerDispatcher
(
)
{
this
.
msgId
=
1
;
this
.
worker
=
null
;
}
WorkerDispatcher
.
prototype
=
{
start
(
url
)
{
this
.
worker
=
new
Worker
(
url
)
;
this
.
worker
.
onerror
=
(
)
=
>
{
console
.
error
(
Error
in
worker
{
url
}
)
;
}
;
}
stop
(
)
{
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
terminate
(
)
;
this
.
worker
=
null
;
}
task
(
method
{
queue
=
false
}
=
{
}
)
{
const
calls
=
[
]
;
const
push
=
args
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
queue
&
&
calls
.
length
=
=
=
0
)
{
Promise
.
resolve
(
)
.
then
(
flush
)
;
}
calls
.
push
(
[
args
resolve
reject
]
)
;
if
(
!
queue
)
{
flush
(
)
;
}
}
)
;
}
;
const
flush
=
(
)
=
>
{
const
items
=
calls
.
slice
(
)
;
calls
.
length
=
0
;
if
(
!
this
.
worker
)
{
return
;
}
const
id
=
this
.
msgId
+
+
;
this
.
worker
.
postMessage
(
{
id
method
calls
:
items
.
map
(
item
=
>
item
[
0
]
)
}
)
;
const
listener
=
(
{
data
:
result
}
)
=
>
{
if
(
result
.
id
!
=
=
id
)
{
return
;
}
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
removeEventListener
(
"
message
"
listener
)
;
result
.
results
.
forEach
(
(
resultData
i
)
=
>
{
const
[
resolve
reject
]
=
items
[
i
]
;
if
(
resultData
.
error
)
{
reject
(
resultData
.
error
)
;
}
else
{
resolve
(
resultData
.
response
)
;
}
}
)
;
}
;
this
.
worker
.
addEventListener
(
"
message
"
listener
)
;
}
;
return
(
.
.
.
args
)
=
>
push
(
args
)
;
}
}
;
function
workerHandler
(
publicInterface
)
{
return
function
(
msg
)
{
const
{
id
method
calls
}
=
msg
.
data
;
Promise
.
all
(
calls
.
map
(
args
=
>
{
try
{
const
response
=
publicInterface
[
method
]
.
apply
(
undefined
args
)
;
if
(
response
instanceof
Promise
)
{
return
response
.
then
(
val
=
>
(
{
response
:
val
}
)
err
=
>
(
{
error
:
err
.
toString
(
)
}
)
)
;
}
return
{
response
}
;
}
catch
(
error
)
{
return
{
error
:
error
.
toString
(
)
}
;
}
}
)
)
.
then
(
results
=
>
{
self
.
postMessage
(
{
id
results
}
)
;
}
)
;
}
;
}
function
streamingWorkerHandler
(
publicInterface
{
timeout
=
100
}
=
{
}
worker
=
self
)
{
let
streamingWorker
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
id
tasks
)
{
let
isWorking
=
true
;
const
timeoutId
=
setTimeout
(
function
(
)
{
isWorking
=
false
;
}
timeout
)
;
const
results
=
[
]
;
while
(
tasks
.
length
!
=
=
0
&
&
isWorking
)
{
const
{
callback
context
args
}
=
tasks
.
shift
(
)
;
const
result
=
yield
callback
.
call
(
context
args
)
;
results
.
push
(
result
)
;
}
worker
.
postMessage
(
{
id
status
:
"
pending
"
data
:
results
}
)
;
clearTimeout
(
timeoutId
)
;
if
(
tasks
.
length
!
=
=
0
)
{
yield
streamingWorker
(
id
tasks
)
;
}
}
)
;
return
function
streamingWorker
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
return
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
msg
)
{
const
{
id
method
args
}
=
msg
.
data
;
const
workerMethod
=
publicInterface
[
method
]
;
if
(
!
workerMethod
)
{
console
.
error
(
Could
not
find
{
method
}
defined
in
worker
.
)
;
}
worker
.
postMessage
(
{
id
status
:
"
start
"
}
)
;
try
{
const
tasks
=
workerMethod
(
args
)
;
yield
streamingWorker
(
id
tasks
)
;
worker
.
postMessage
(
{
id
status
:
"
done
"
}
)
;
}
catch
(
error
)
{
worker
.
postMessage
(
{
id
status
:
"
error
"
error
}
)
;
}
}
)
;
return
function
(
_x3
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
module
.
exports
=
{
WorkerDispatcher
workerHandler
streamingWorkerHandler
}
;
}
)
381
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
factory
)
{
true
?
factory
(
exports
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
[
'
exports
'
]
factory
)
:
(
factory
(
(
global
.
acorn
=
global
.
acorn
|
|
{
}
)
)
)
;
}
(
this
(
function
(
exports
)
{
'
use
strict
'
;
var
reservedWords
=
{
3
:
"
abstract
boolean
byte
char
class
double
enum
export
extends
final
float
goto
implements
import
int
interface
long
native
package
private
protected
public
short
static
super
synchronized
throws
transient
volatile
"
5
:
"
class
enum
extends
super
const
export
import
"
6
:
"
enum
"
strict
:
"
implements
interface
let
package
private
protected
public
static
yield
"
strictBind
:
"
eval
arguments
"
}
;
var
ecma5AndLessKeywords
=
"
break
case
catch
continue
debugger
default
do
else
finally
for
function
if
return
switch
throw
try
var
while
with
null
true
false
instanceof
typeof
void
delete
new
in
this
"
;
var
keywords
=
{
5
:
ecma5AndLessKeywords
6
:
ecma5AndLessKeywords
+
"
const
class
extends
export
import
super
"
}
;
var
nonASCIIidentifierStartChars
=
"
\
xaa
\
xb5
\
xba
\
xc0
-
\
xd6
\
xd8
-
\
xf6
\
xf8
-
\
u02c1
\
u02c6
-
\
u02d1
\
u02e0
-
\
u02e4
\
u02ec
\
u02ee
\
u0370
-
\
u0374
\
u0376
\
u0377
\
u037a
-
\
u037d
\
u037f
\
u0386
\
u0388
-
\
u038a
\
u038c
\
u038e
-
\
u03a1
\
u03a3
-
\
u03f5
\
u03f7
-
\
u0481
\
u048a
-
\
u052f
\
u0531
-
\
u0556
\
u0559
\
u0561
-
\
u0587
\
u05d0
-
\
u05ea
\
u05f0
-
\
u05f2
\
u0620
-
\
u064a
\
u066e
\
u066f
\
u0671
-
\
u06d3
\
u06d5
\
u06e5
\
u06e6
\
u06ee
\
u06ef
\
u06fa
-
\
u06fc
\
u06ff
\
u0710
\
u0712
-
\
u072f
\
u074d
-
\
u07a5
\
u07b1
\
u07ca
-
\
u07ea
\
u07f4
\
u07f5
\
u07fa
\
u0800
-
\
u0815
\
u081a
\
u0824
\
u0828
\
u0840
-
\
u0858
\
u08a0
-
\
u08b4
\
u08b6
-
\
u08bd
\
u0904
-
\
u0939
\
u093d
\
u0950
\
u0958
-
\
u0961
\
u0971
-
\
u0980
\
u0985
-
\
u098c
\
u098f
\
u0990
\
u0993
-
\
u09a8
\
u09aa
-
\
u09b0
\
u09b2
\
u09b6
-
\
u09b9
\
u09bd
\
u09ce
\
u09dc
\
u09dd
\
u09df
-
\
u09e1
\
u09f0
\
u09f1
\
u0a05
-
\
u0a0a
\
u0a0f
\
u0a10
\
u0a13
-
\
u0a28
\
u0a2a
-
\
u0a30
\
u0a32
\
u0a33
\
u0a35
\
u0a36
\
u0a38
\
u0a39
\
u0a59
-
\
u0a5c
\
u0a5e
\
u0a72
-
\
u0a74
\
u0a85
-
\
u0a8d
\
u0a8f
-
\
u0a91
\
u0a93
-
\
u0aa8
\
u0aaa
-
\
u0ab0
\
u0ab2
\
u0ab3
\
u0ab5
-
\
u0ab9
\
u0abd
\
u0ad0
\
u0ae0
\
u0ae1
\
u0af9
\
u0b05
-
\
u0b0c
\
u0b0f
\
u0b10
\
u0b13
-
\
u0b28
\
u0b2a
-
\
u0b30
\
u0b32
\
u0b33
\
u0b35
-
\
u0b39
\
u0b3d
\
u0b5c
\
u0b5d
\
u0b5f
-
\
u0b61
\
u0b71
\
u0b83
\
u0b85
-
\
u0b8a
\
u0b8e
-
\
u0b90
\
u0b92
-
\
u0b95
\
u0b99
\
u0b9a
\
u0b9c
\
u0b9e
\
u0b9f
\
u0ba3
\
u0ba4
\
u0ba8
-
\
u0baa
\
u0bae
-
\
u0bb9
\
u0bd0
\
u0c05
-
\
u0c0c
\
u0c0e
-
\
u0c10
\
u0c12
-
\
u0c28
\
u0c2a
-
\
u0c39
\
u0c3d
\
u0c58
-
\
u0c5a
\
u0c60
\
u0c61
\
u0c80
\
u0c85
-
\
u0c8c
\
u0c8e
-
\
u0c90
\
u0c92
-
\
u0ca8
\
u0caa
-
\
u0cb3
\
u0cb5
-
\
u0cb9
\
u0cbd
\
u0cde
\
u0ce0
\
u0ce1
\
u0cf1
\
u0cf2
\
u0d05
-
\
u0d0c
\
u0d0e
-
\
u0d10
\
u0d12
-
\
u0d3a
\
u0d3d
\
u0d4e
\
u0d54
-
\
u0d56
\
u0d5f
-
\
u0d61
\
u0d7a
-
\
u0d7f
\
u0d85
-
\
u0d96
\
u0d9a
-
\
u0db1
\
u0db3
-
\
u0dbb
\
u0dbd
\
u0dc0
-
\
u0dc6
\
u0e01
-
\
u0e30
\
u0e32
\
u0e33
\
u0e40
-
\
u0e46
\
u0e81
\
u0e82
\
u0e84
\
u0e87
\
u0e88
\
u0e8a
\
u0e8d
\
u0e94
-
\
u0e97
\
u0e99
-
\
u0e9f
\
u0ea1
-
\
u0ea3
\
u0ea5
\
u0ea7
\
u0eaa
\
u0eab
\
u0ead
-
\
u0eb0
\
u0eb2
\
u0eb3
\
u0ebd
\
u0ec0
-
\
u0ec4
\
u0ec6
\
u0edc
-
\
u0edf
\
u0f00
\
u0f40
-
\
u0f47
\
u0f49
-
\
u0f6c
\
u0f88
-
\
u0f8c
\
u1000
-
\
u102a
\
u103f
\
u1050
-
\
u1055
\
u105a
-
\
u105d
\
u1061
\
u1065
\
u1066
\
u106e
-
\
u1070
\
u1075
-
\
u1081
\
u108e
\
u10a0
-
\
u10c5
\
u10c7
\
u10cd
\
u10d0
-
\
u10fa
\
u10fc
-
\
u1248
\
u124a
-
\
u124d
\
u1250
-
\
u1256
\
u1258
\
u125a
-
\
u125d
\
u1260
-
\
u1288
\
u128a
-
\
u128d
\
u1290
-
\
u12b0
\
u12b2
-
\
u12b5
\
u12b8
-
\
u12be
\
u12c0
\
u12c2
-
\
u12c5
\
u12c8
-
\
u12d6
\
u12d8
-
\
u1310
\
u1312
-
\
u1315
\
u1318
-
\
u135a
\
u1380
-
\
u138f
\
u13a0
-
\
u13f5
\
u13f8
-
\
u13fd
\
u1401
-
\
u166c
\
u166f
-
\
u167f
\
u1681
-
\
u169a
\
u16a0
-
\
u16ea
\
u16ee
-
\
u16f8
\
u1700
-
\
u170c
\
u170e
-
\
u1711
\
u1720
-
\
u1731
\
u1740
-
\
u1751
\
u1760
-
\
u176c
\
u176e
-
\
u1770
\
u1780
-
\
u17b3
\
u17d7
\
u17dc
\
u1820
-
\
u1877
\
u1880
-
\
u18a8
\
u18aa
\
u18b0
-
\
u18f5
\
u1900
-
\
u191e
\
u1950
-
\
u196d
\
u1970
-
\
u1974
\
u1980
-
\
u19ab
\
u19b0
-
\
u19c9
\
u1a00
-
\
u1a16
\
u1a20
-
\
u1a54
\
u1aa7
\
u1b05
-
\
u1b33
\
u1b45
-
\
u1b4b
\
u1b83
-
\
u1ba0
\
u1bae
\
u1baf
\
u1bba
-
\
u1be5
\
u1c00
-
\
u1c23
\
u1c4d
-
\
u1c4f
\
u1c5a
-
\
u1c7d
\
u1c80
-
\
u1c88
\
u1ce9
-
\
u1cec
\
u1cee
-
\
u1cf1
\
u1cf5
\
u1cf6
\
u1d00
-
\
u1dbf
\
u1e00
-
\
u1f15
\
u1f18
-
\
u1f1d
\
u1f20
-
\
u1f45
\
u1f48
-
\
u1f4d
\
u1f50
-
\
u1f57
\
u1f59
\
u1f5b
\
u1f5d
\
u1f5f
-
\
u1f7d
\
u1f80
-
\
u1fb4
\
u1fb6
-
\
u1fbc
\
u1fbe
\
u1fc2
-
\
u1fc4
\
u1fc6
-
\
u1fcc
\
u1fd0
-
\
u1fd3
\
u1fd6
-
\
u1fdb
\
u1fe0
-
\
u1fec
\
u1ff2
-
\
u1ff4
\
u1ff6
-
\
u1ffc
\
u2071
\
u207f
\
u2090
-
\
u209c
\
u2102
\
u2107
\
u210a
-
\
u2113
\
u2115
\
u2118
-
\
u211d
\
u2124
\
u2126
\
u2128
\
u212a
-
\
u2139
\
u213c
-
\
u213f
\
u2145
-
\
u2149
\
u214e
\
u2160
-
\
u2188
\
u2c00
-
\
u2c2e
\
u2c30
-
\
u2c5e
\
u2c60
-
\
u2ce4
\
u2ceb
-
\
u2cee
\
u2cf2
\
u2cf3
\
u2d00
-
\
u2d25
\
u2d27
\
u2d2d
\
u2d30
-
\
u2d67
\
u2d6f
\
u2d80
-
\
u2d96
\
u2da0
-
\
u2da6
\
u2da8
-
\
u2dae
\
u2db0
-
\
u2db6
\
u2db8
-
\
u2dbe
\
u2dc0
-
\
u2dc6
\
u2dc8
-
\
u2dce
\
u2dd0
-
\
u2dd6
\
u2dd8
-
\
u2dde
\
u3005
-
\
u3007
\
u3021
-
\
u3029
\
u3031
-
\
u3035
\
u3038
-
\
u303c
\
u3041
-
\
u3096
\
u309b
-
\
u309f
\
u30a1
-
\
u30fa
\
u30fc
-
\
u30ff
\
u3105
-
\
u312d
\
u3131
-
\
u318e
\
u31a0
-
\
u31ba
\
u31f0
-
\
u31ff
\
u3400
-
\
u4db5
\
u4e00
-
\
u9fd5
\
ua000
-
\
ua48c
\
ua4d0
-
\
ua4fd
\
ua500
-
\
ua60c
\
ua610
-
\
ua61f
\
ua62a
\
ua62b
\
ua640
-
\
ua66e
\
ua67f
-
\
ua69d
\
ua6a0
-
\
ua6ef
\
ua717
-
\
ua71f
\
ua722
-
\
ua788
\
ua78b
-
\
ua7ae
\
ua7b0
-
\
ua7b7
\
ua7f7
-
\
ua801
\
ua803
-
\
ua805
\
ua807
-
\
ua80a
\
ua80c
-
\
ua822
\
ua840
-
\
ua873
\
ua882
-
\
ua8b3
\
ua8f2
-
\
ua8f7
\
ua8fb
\
ua8fd
\
ua90a
-
\
ua925
\
ua930
-
\
ua946
\
ua960
-
\
ua97c
\
ua984
-
\
ua9b2
\
ua9cf
\
ua9e0
-
\
ua9e4
\
ua9e6
-
\
ua9ef
\
ua9fa
-
\
ua9fe
\
uaa00
-
\
uaa28
\
uaa40
-
\
uaa42
\
uaa44
-
\
uaa4b
\
uaa60
-
\
uaa76
\
uaa7a
\
uaa7e
-
\
uaaaf
\
uaab1
\
uaab5
\
uaab6
\
uaab9
-
\
uaabd
\
uaac0
\
uaac2
\
uaadb
-
\
uaadd
\
uaae0
-
\
uaaea
\
uaaf2
-
\
uaaf4
\
uab01
-
\
uab06
\
uab09
-
\
uab0e
\
uab11
-
\
uab16
\
uab20
-
\
uab26
\
uab28
-
\
uab2e
\
uab30
-
\
uab5a
\
uab5c
-
\
uab65
\
uab70
-
\
uabe2
\
uac00
-
\
ud7a3
\
ud7b0
-
\
ud7c6
\
ud7cb
-
\
ud7fb
\
uf900
-
\
ufa6d
\
ufa70
-
\
ufad9
\
ufb00
-
\
ufb06
\
ufb13
-
\
ufb17
\
ufb1d
\
ufb1f
-
\
ufb28
\
ufb2a
-
\
ufb36
\
ufb38
-
\
ufb3c
\
ufb3e
\
ufb40
\
ufb41
\
ufb43
\
ufb44
\
ufb46
-
\
ufbb1
\
ufbd3
-
\
ufd3d
\
ufd50
-
\
ufd8f
\
ufd92
-
\
ufdc7
\
ufdf0
-
\
ufdfb
\
ufe70
-
\
ufe74
\
ufe76
-
\
ufefc
\
uff21
-
\
uff3a
\
uff41
-
\
uff5a
\
uff66
-
\
uffbe
\
uffc2
-
\
uffc7
\
uffca
-
\
uffcf
\
uffd2
-
\
uffd7
\
uffda
-
\
uffdc
"
;
var
nonASCIIidentifierChars
=
"
\
u200c
\
u200d
\
xb7
\
u0300
-
\
u036f
\
u0387
\
u0483
-
\
u0487
\
u0591
-
\
u05bd
\
u05bf
\
u05c1
\
u05c2
\
u05c4
\
u05c5
\
u05c7
\
u0610
-
\
u061a
\
u064b
-
\
u0669
\
u0670
\
u06d6
-
\
u06dc
\
u06df
-
\
u06e4
\
u06e7
\
u06e8
\
u06ea
-
\
u06ed
\
u06f0
-
\
u06f9
\
u0711
\
u0730
-
\
u074a
\
u07a6
-
\
u07b0
\
u07c0
-
\
u07c9
\
u07eb
-
\
u07f3
\
u0816
-
\
u0819
\
u081b
-
\
u0823
\
u0825
-
\
u0827
\
u0829
-
\
u082d
\
u0859
-
\
u085b
\
u08d4
-
\
u08e1
\
u08e3
-
\
u0903
\
u093a
-
\
u093c
\
u093e
-
\
u094f
\
u0951
-
\
u0957
\
u0962
\
u0963
\
u0966
-
\
u096f
\
u0981
-
\
u0983
\
u09bc
\
u09be
-
\
u09c4
\
u09c7
\
u09c8
\
u09cb
-
\
u09cd
\
u09d7
\
u09e2
\
u09e3
\
u09e6
-
\
u09ef
\
u0a01
-
\
u0a03
\
u0a3c
\
u0a3e
-
\
u0a42
\
u0a47
\
u0a48
\
u0a4b
-
\
u0a4d
\
u0a51
\
u0a66
-
\
u0a71
\
u0a75
\
u0a81
-
\
u0a83
\
u0abc
\
u0abe
-
\
u0ac5
\
u0ac7
-
\
u0ac9
\
u0acb
-
\
u0acd
\
u0ae2
\
u0ae3
\
u0ae6
-
\
u0aef
\
u0b01
-
\
u0b03
\
u0b3c
\
u0b3e
-
\
u0b44
\
u0b47
\
u0b48
\
u0b4b
-
\
u0b4d
\
u0b56
\
u0b57
\
u0b62
\
u0b63
\
u0b66
-
\
u0b6f
\
u0b82
\
u0bbe
-
\
u0bc2
\
u0bc6
-
\
u0bc8
\
u0bca
-
\
u0bcd
\
u0bd7
\
u0be6
-
\
u0bef
\
u0c00
-
\
u0c03
\
u0c3e
-
\
u0c44
\
u0c46
-
\
u0c48
\
u0c4a
-
\
u0c4d
\
u0c55
\
u0c56
\
u0c62
\
u0c63
\
u0c66
-
\
u0c6f
\
u0c81
-
\
u0c83
\
u0cbc
\
u0cbe
-
\
u0cc4
\
u0cc6
-
\
u0cc8
\
u0cca
-
\
u0ccd
\
u0cd5
\
u0cd6
\
u0ce2
\
u0ce3
\
u0ce6
-
\
u0cef
\
u0d01
-
\
u0d03
\
u0d3e
-
\
u0d44
\
u0d46
-
\
u0d48
\
u0d4a
-
\
u0d4d
\
u0d57
\
u0d62
\
u0d63
\
u0d66
-
\
u0d6f
\
u0d82
\
u0d83
\
u0dca
\
u0dcf
-
\
u0dd4
\
u0dd6
\
u0dd8
-
\
u0ddf
\
u0de6
-
\
u0def
\
u0df2
\
u0df3
\
u0e31
\
u0e34
-
\
u0e3a
\
u0e47
-
\
u0e4e
\
u0e50
-
\
u0e59
\
u0eb1
\
u0eb4
-
\
u0eb9
\
u0ebb
\
u0ebc
\
u0ec8
-
\
u0ecd
\
u0ed0
-
\
u0ed9
\
u0f18
\
u0f19
\
u0f20
-
\
u0f29
\
u0f35
\
u0f37
\
u0f39
\
u0f3e
\
u0f3f
\
u0f71
-
\
u0f84
\
u0f86
\
u0f87
\
u0f8d
-
\
u0f97
\
u0f99
-
\
u0fbc
\
u0fc6
\
u102b
-
\
u103e
\
u1040
-
\
u1049
\
u1056
-
\
u1059
\
u105e
-
\
u1060
\
u1062
-
\
u1064
\
u1067
-
\
u106d
\
u1071
-
\
u1074
\
u1082
-
\
u108d
\
u108f
-
\
u109d
\
u135d
-
\
u135f
\
u1369
-
\
u1371
\
u1712
-
\
u1714
\
u1732
-
\
u1734
\
u1752
\
u1753
\
u1772
\
u1773
\
u17b4
-
\
u17d3
\
u17dd
\
u17e0
-
\
u17e9
\
u180b
-
\
u180d
\
u1810
-
\
u1819
\
u18a9
\
u1920
-
\
u192b
\
u1930
-
\
u193b
\
u1946
-
\
u194f
\
u19d0
-
\
u19da
\
u1a17
-
\
u1a1b
\
u1a55
-
\
u1a5e
\
u1a60
-
\
u1a7c
\
u1a7f
-
\
u1a89
\
u1a90
-
\
u1a99
\
u1ab0
-
\
u1abd
\
u1b00
-
\
u1b04
\
u1b34
-
\
u1b44
\
u1b50
-
\
u1b59
\
u1b6b
-
\
u1b73
\
u1b80
-
\
u1b82
\
u1ba1
-
\
u1bad
\
u1bb0
-
\
u1bb9
\
u1be6
-
\
u1bf3
\
u1c24
-
\
u1c37
\
u1c40
-
\
u1c49
\
u1c50
-
\
u1c59
\
u1cd0
-
\
u1cd2
\
u1cd4
-
\
u1ce8
\
u1ced
\
u1cf2
-
\
u1cf4
\
u1cf8
\
u1cf9
\
u1dc0
-
\
u1df5
\
u1dfb
-
\
u1dff
\
u203f
\
u2040
\
u2054
\
u20d0
-
\
u20dc
\
u20e1
\
u20e5
-
\
u20f0
\
u2cef
-
\
u2cf1
\
u2d7f
\
u2de0
-
\
u2dff
\
u302a
-
\
u302f
\
u3099
\
u309a
\
ua620
-
\
ua629
\
ua66f
\
ua674
-
\
ua67d
\
ua69e
\
ua69f
\
ua6f0
\
ua6f1
\
ua802
\
ua806
\
ua80b
\
ua823
-
\
ua827
\
ua880
\
ua881
\
ua8b4
-
\
ua8c5
\
ua8d0
-
\
ua8d9
\
ua8e0
-
\
ua8f1
\
ua900
-
\
ua909
\
ua926
-
\
ua92d
\
ua947
-
\
ua953
\
ua980
-
\
ua983
\
ua9b3
-
\
ua9c0
\
ua9d0
-
\
ua9d9
\
ua9e5
\
ua9f0
-
\
ua9f9
\
uaa29
-
\
uaa36
\
uaa43
\
uaa4c
\
uaa4d
\
uaa50
-
\
uaa59
\
uaa7b
-
\
uaa7d
\
uaab0
\
uaab2
-
\
uaab4
\
uaab7
\
uaab8
\
uaabe
\
uaabf
\
uaac1
\
uaaeb
-
\
uaaef
\
uaaf5
\
uaaf6
\
uabe3
-
\
uabea
\
uabec
\
uabed
\
uabf0
-
\
uabf9
\
ufb1e
\
ufe00
-
\
ufe0f
\
ufe20
-
\
ufe2f
\
ufe33
\
ufe34
\
ufe4d
-
\
ufe4f
\
uff10
-
\
uff19
\
uff3f
"
;
var
nonASCIIidentifierStart
=
new
RegExp
(
"
[
"
+
nonASCIIidentifierStartChars
+
"
]
"
)
;
var
nonASCIIidentifier
=
new
RegExp
(
"
[
"
+
nonASCIIidentifierStartChars
+
nonASCIIidentifierChars
+
"
]
"
)
;
nonASCIIidentifierStartChars
=
nonASCIIidentifierChars
=
null
;
var
astralIdentifierStartCodes
=
[
0
11
2
25
2
18
2
1
2
14
3
13
35
122
70
52
268
28
4
48
48
31
17
26
6
37
11
29
3
35
5
7
2
4
43
157
19
35
5
35
5
39
9
51
157
310
10
21
11
7
153
5
3
0
2
43
2
1
4
0
3
22
11
22
10
30
66
18
2
1
11
21
11
25
71
55
7
1
65
0
16
3
2
2
2
26
45
28
4
28
36
7
2
27
28
53
11
21
11
18
14
17
111
72
56
50
14
50
785
52
76
44
33
24
27
35
42
34
4
0
13
47
15
3
22
0
2
0
36
17
2
24
85
6
2
0
2
3
2
14
2
9
8
46
39
7
3
1
3
21
2
6
2
1
2
4
4
0
19
0
13
4
159
52
19
3
54
47
21
1
2
0
185
46
42
3
37
47
21
0
60
42
86
25
391
63
32
0
449
56
264
8
2
36
18
0
50
29
881
921
103
110
18
195
2749
1070
4050
582
8634
568
8
30
114
29
19
47
17
3
32
20
6
18
881
68
12
0
67
12
65
0
32
6124
20
754
9486
1
3071
106
6
12
4
8
8
9
5991
84
2
70
2
1
3
0
3
1
3
3
2
11
2
0
2
6
2
64
2
3
3
7
2
6
2
27
2
3
2
4
2
0
4
6
2
339
3
24
2
24
2
30
2
24
2
30
2
24
2
30
2
24
2
30
2
24
2
7
4149
196
60
67
1213
3
2
26
2
1
2
0
3
0
2
9
2
3
2
0
2
0
7
0
5
0
2
0
2
0
2
2
2
1
2
0
3
0
2
0
2
0
2
0
2
0
2
1
2
0
3
3
2
6
2
3
2
3
2
0
2
9
2
16
6
2
2
4
2
16
4421
42710
42
4148
12
221
3
5761
10591
541
]
;
var
astralIdentifierCodes
=
[
509
0
227
0
150
4
294
9
1368
2
2
1
6
3
41
2
5
0
166
1
1306
2
54
14
32
9
16
3
46
10
54
9
7
2
37
13
2
9
52
0
13
2
49
13
10
2
4
9
83
11
7
0
161
11
6
9
7
3
57
0
2
6
3
1
3
2
10
0
11
1
3
6
4
4
193
17
10
9
87
19
13
9
214
6
3
8
28
1
83
16
16
9
82
12
9
9
84
14
5
9
423
9
838
7
2
7
17
9
57
21
2
13
19882
9
135
4
60
6
26
9
1016
45
17
3
19723
1
5319
4
4
5
9
7
3
6
31
3
149
2
1418
49
513
54
5
49
9
0
15
0
23
4
2
14
1361
6
2
16
3
6
2
1
2
4
2214
6
110
6
6
9
792487
239
]
;
function
isInAstralSet
(
code
set
)
{
var
pos
=
0x10000
;
for
(
var
i
=
0
;
i
<
set
.
length
;
i
+
=
2
)
{
pos
+
=
set
[
i
]
;
if
(
pos
>
code
)
{
return
false
}
pos
+
=
set
[
i
+
1
]
;
if
(
pos
>
=
code
)
{
return
true
}
}
}
function
isIdentifierStart
(
code
astral
)
{
if
(
code
<
65
)
{
return
code
=
=
=
36
}
if
(
code
<
91
)
{
return
true
}
if
(
code
<
97
)
{
return
code
=
=
=
95
}
if
(
code
<
123
)
{
return
true
}
if
(
code
<
=
0xffff
)
{
return
code
>
=
0xaa
&
&
nonASCIIidentifierStart
.
test
(
String
.
fromCharCode
(
code
)
)
}
if
(
astral
=
=
=
false
)
{
return
false
}
return
isInAstralSet
(
code
astralIdentifierStartCodes
)
}
function
isIdentifierChar
(
code
astral
)
{
if
(
code
<
48
)
{
return
code
=
=
=
36
}
if
(
code
<
58
)
{
return
true
}
if
(
code
<
65
)
{
return
false
}
if
(
code
<
91
)
{
return
true
}
if
(
code
<
97
)
{
return
code
=
=
=
95
}
if
(
code
<
123
)
{
return
true
}
if
(
code
<
=
0xffff
)
{
return
code
>
=
0xaa
&
&
nonASCIIidentifier
.
test
(
String
.
fromCharCode
(
code
)
)
}
if
(
astral
=
=
=
false
)
{
return
false
}
return
isInAstralSet
(
code
astralIdentifierStartCodes
)
|
|
isInAstralSet
(
code
astralIdentifierCodes
)
}
var
TokenType
=
function
TokenType
(
label
conf
)
{
if
(
conf
=
=
=
void
0
)
conf
=
{
}
;
this
.
label
=
label
;
this
.
keyword
=
conf
.
keyword
;
this
.
beforeExpr
=
!
!
conf
.
beforeExpr
;
this
.
startsExpr
=
!
!
conf
.
startsExpr
;
this
.
isLoop
=
!
!
conf
.
isLoop
;
this
.
isAssign
=
!
!
conf
.
isAssign
;
this
.
prefix
=
!
!
conf
.
prefix
;
this
.
postfix
=
!
!
conf
.
postfix
;
this
.
binop
=
conf
.
binop
|
|
null
;
this
.
updateContext
=
null
;
}
;
function
binop
(
name
prec
)
{
return
new
TokenType
(
name
{
beforeExpr
:
true
binop
:
prec
}
)
}
var
beforeExpr
=
{
beforeExpr
:
true
}
;
var
startsExpr
=
{
startsExpr
:
true
}
;
var
keywords
1
=
{
}
;
function
kw
(
name
options
)
{
if
(
options
=
=
=
void
0
)
options
=
{
}
;
options
.
keyword
=
name
;
return
keywords
1
[
name
]
=
new
TokenType
(
name
options
)
}
var
types
=
{
num
:
new
TokenType
(
"
num
"
startsExpr
)
regexp
:
new
TokenType
(
"
regexp
"
startsExpr
)
string
:
new
TokenType
(
"
string
"
startsExpr
)
name
:
new
TokenType
(
"
name
"
startsExpr
)
eof
:
new
TokenType
(
"
eof
"
)
bracketL
:
new
TokenType
(
"
[
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
bracketR
:
new
TokenType
(
"
]
"
)
braceL
:
new
TokenType
(
"
{
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
braceR
:
new
TokenType
(
"
}
"
)
parenL
:
new
TokenType
(
"
(
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
parenR
:
new
TokenType
(
"
)
"
)
comma
:
new
TokenType
(
"
"
beforeExpr
)
semi
:
new
TokenType
(
"
;
"
beforeExpr
)
colon
:
new
TokenType
(
"
:
"
beforeExpr
)
dot
:
new
TokenType
(
"
.
"
)
question
:
new
TokenType
(
"
?
"
beforeExpr
)
arrow
:
new
TokenType
(
"
=
>
"
beforeExpr
)
template
:
new
TokenType
(
"
template
"
)
invalidTemplate
:
new
TokenType
(
"
invalidTemplate
"
)
ellipsis
:
new
TokenType
(
"
.
.
.
"
beforeExpr
)
backQuote
:
new
TokenType
(
"
"
startsExpr
)
dollarBraceL
:
new
TokenType
(
"
{
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
eq
:
new
TokenType
(
"
=
"
{
beforeExpr
:
true
isAssign
:
true
}
)
assign
:
new
TokenType
(
"
_
=
"
{
beforeExpr
:
true
isAssign
:
true
}
)
incDec
:
new
TokenType
(
"
+
+
/
-
-
"
{
prefix
:
true
postfix
:
true
startsExpr
:
true
}
)
prefix
:
new
TokenType
(
"
!
/
~
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
logicalOR
:
binop
(
"
|
|
"
1
)
logicalAND
:
binop
(
"
&
&
"
2
)
bitwiseOR
:
binop
(
"
|
"
3
)
bitwiseXOR
:
binop
(
"
^
"
4
)
bitwiseAND
:
binop
(
"
&
"
5
)
equality
:
binop
(
"
=
=
/
!
=
/
=
=
=
/
!
=
=
"
6
)
relational
:
binop
(
"
<
/
>
/
<
=
/
>
=
"
7
)
bitShift
:
binop
(
"
<
<
/
>
>
/
>
>
>
"
8
)
plusMin
:
new
TokenType
(
"
+
/
-
"
{
beforeExpr
:
true
binop
:
9
prefix
:
true
startsExpr
:
true
}
)
modulo
:
binop
(
"
%
"
10
)
star
:
binop
(
"
*
"
10
)
slash
:
binop
(
"
/
"
10
)
starstar
:
new
TokenType
(
"
*
*
"
{
beforeExpr
:
true
}
)
_break
:
kw
(
"
break
"
)
_case
:
kw
(
"
case
"
beforeExpr
)
_catch
:
kw
(
"
catch
"
)
_continue
:
kw
(
"
continue
"
)
_debugger
:
kw
(
"
debugger
"
)
_default
:
kw
(
"
default
"
beforeExpr
)
_do
:
kw
(
"
do
"
{
isLoop
:
true
beforeExpr
:
true
}
)
_else
:
kw
(
"
else
"
beforeExpr
)
_finally
:
kw
(
"
finally
"
)
_for
:
kw
(
"
for
"
{
isLoop
:
true
}
)
_function
:
kw
(
"
function
"
startsExpr
)
_if
:
kw
(
"
if
"
)
_return
:
kw
(
"
return
"
beforeExpr
)
_switch
:
kw
(
"
switch
"
)
_throw
:
kw
(
"
throw
"
beforeExpr
)
_try
:
kw
(
"
try
"
)
_var
:
kw
(
"
var
"
)
_const
:
kw
(
"
const
"
)
_while
:
kw
(
"
while
"
{
isLoop
:
true
}
)
_with
:
kw
(
"
with
"
)
_new
:
kw
(
"
new
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
_this
:
kw
(
"
this
"
startsExpr
)
_super
:
kw
(
"
super
"
startsExpr
)
_class
:
kw
(
"
class
"
startsExpr
)
_extends
:
kw
(
"
extends
"
beforeExpr
)
_export
:
kw
(
"
export
"
)
_import
:
kw
(
"
import
"
)
_null
:
kw
(
"
null
"
startsExpr
)
_true
:
kw
(
"
true
"
startsExpr
)
_false
:
kw
(
"
false
"
startsExpr
)
_in
:
kw
(
"
in
"
{
beforeExpr
:
true
binop
:
7
}
)
_instanceof
:
kw
(
"
instanceof
"
{
beforeExpr
:
true
binop
:
7
}
)
_typeof
:
kw
(
"
typeof
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
_void
:
kw
(
"
void
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
_delete
:
kw
(
"
delete
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
}
;
var
lineBreak
=
/
\
r
\
n
?
|
\
n
|
\
u2028
|
\
u2029
/
;
var
lineBreakG
=
new
RegExp
(
lineBreak
.
source
"
g
"
)
;
function
isNewLine
(
code
)
{
return
code
=
=
=
10
|
|
code
=
=
=
13
|
|
code
=
=
=
0x2028
|
|
code
=
=
=
0x2029
}
var
nonASCIIwhitespace
=
/
[
\
u1680
\
u180e
\
u2000
-
\
u200a
\
u202f
\
u205f
\
u3000
\
ufeff
]
/
;
var
skipWhiteSpace
=
/
(
?
:
\
s
|
\
/
\
/
.
*
|
\
/
\
*
[
^
]
*
?
\
*
\
/
)
*
/
g
;
var
ref
=
Object
.
prototype
;
var
hasOwnProperty
=
ref
.
hasOwnProperty
;
var
toString
=
ref
.
toString
;
function
has
(
obj
propName
)
{
return
hasOwnProperty
.
call
(
obj
propName
)
}
var
isArray
=
Array
.
isArray
|
|
(
function
(
obj
)
{
return
(
toString
.
call
(
obj
)
=
=
=
"
[
object
Array
]
"
)
;
}
)
;
var
Position
=
function
Position
(
line
col
)
{
this
.
line
=
line
;
this
.
column
=
col
;
}
;
Position
.
prototype
.
offset
=
function
offset
(
n
)
{
return
new
Position
(
this
.
line
this
.
column
+
n
)
}
;
var
SourceLocation
=
function
SourceLocation
(
p
start
end
)
{
this
.
start
=
start
;
this
.
end
=
end
;
if
(
p
.
sourceFile
!
=
=
null
)
{
this
.
source
=
p
.
sourceFile
;
}
}
;
function
getLineInfo
(
input
offset
)
{
for
(
var
line
=
1
cur
=
0
;
;
)
{
lineBreakG
.
lastIndex
=
cur
;
var
match
=
lineBreakG
.
exec
(
input
)
;
if
(
match
&
&
match
.
index
<
offset
)
{
+
+
line
;
cur
=
match
.
index
+
match
[
0
]
.
length
;
}
else
{
return
new
Position
(
line
offset
-
cur
)
}
}
}
var
defaultOptions
=
{
ecmaVersion
:
7
sourceType
:
"
script
"
onInsertedSemicolon
:
null
onTrailingComma
:
null
allowReserved
:
null
allowReturnOutsideFunction
:
false
allowImportExportEverywhere
:
false
allowHashBang
:
false
locations
:
false
onToken
:
null
onComment
:
null
ranges
:
false
program
:
null
sourceFile
:
null
directSourceFile
:
null
preserveParens
:
false
plugins
:
{
}
}
;
function
getOptions
(
opts
)
{
var
options
=
{
}
;
for
(
var
opt
in
defaultOptions
)
{
options
[
opt
]
=
opts
&
&
has
(
opts
opt
)
?
opts
[
opt
]
:
defaultOptions
[
opt
]
;
}
if
(
options
.
ecmaVersion
>
=
2015
)
{
options
.
ecmaVersion
-
=
2009
;
}
if
(
options
.
allowReserved
=
=
null
)
{
options
.
allowReserved
=
options
.
ecmaVersion
<
5
;
}
if
(
isArray
(
options
.
onToken
)
)
{
var
tokens
=
options
.
onToken
;
options
.
onToken
=
function
(
token
)
{
return
tokens
.
push
(
token
)
;
}
;
}
if
(
isArray
(
options
.
onComment
)
)
{
options
.
onComment
=
pushComment
(
options
options
.
onComment
)
;
}
return
options
}
function
pushComment
(
options
array
)
{
return
function
(
block
text
start
end
startLoc
endLoc
)
{
var
comment
=
{
type
:
block
?
"
Block
"
:
"
Line
"
value
:
text
start
:
start
end
:
end
}
;
if
(
options
.
locations
)
{
comment
.
loc
=
new
SourceLocation
(
this
startLoc
endLoc
)
;
}
if
(
options
.
ranges
)
{
comment
.
range
=
[
start
end
]
;
}
array
.
push
(
comment
)
;
}
}
var
plugins
=
{
}
;
function
keywordRegexp
(
words
)
{
return
new
RegExp
(
"
^
(
?
:
"
+
words
.
replace
(
/
/
g
"
|
"
)
+
"
)
"
)
}
var
Parser
=
function
Parser
(
options
input
startPos
)
{
this
.
options
=
options
=
getOptions
(
options
)
;
this
.
sourceFile
=
options
.
sourceFile
;
this
.
keywords
=
keywordRegexp
(
keywords
[
options
.
ecmaVersion
>
=
6
?
6
:
5
]
)
;
var
reserved
=
"
"
;
if
(
!
options
.
allowReserved
)
{
for
(
var
v
=
options
.
ecmaVersion
;
;
v
-
-
)
{
if
(
reserved
=
reservedWords
[
v
]
)
{
break
}
}
if
(
options
.
sourceType
=
=
"
module
"
)
{
reserved
+
=
"
await
"
;
}
}
this
.
reservedWords
=
keywordRegexp
(
reserved
)
;
var
reservedStrict
=
(
reserved
?
reserved
+
"
"
:
"
"
)
+
reservedWords
.
strict
;
this
.
reservedWordsStrict
=
keywordRegexp
(
reservedStrict
)
;
this
.
reservedWordsStrictBind
=
keywordRegexp
(
reservedStrict
+
"
"
+
reservedWords
.
strictBind
)
;
this
.
input
=
String
(
input
)
;
this
.
containsEsc
=
false
;
this
.
loadPlugins
(
options
.
plugins
)
;
if
(
startPos
)
{
this
.
pos
=
startPos
;
this
.
lineStart
=
this
.
input
.
lastIndexOf
(
"
\
n
"
startPos
-
1
)
+
1
;
this
.
curLine
=
this
.
input
.
slice
(
0
this
.
lineStart
)
.
split
(
lineBreak
)
.
length
;
}
else
{
this
.
pos
=
this
.
lineStart
=
0
;
this
.
curLine
=
1
;
}
this
.
type
=
types
.
eof
;
this
.
value
=
null
;
this
.
start
=
this
.
end
=
this
.
pos
;
this
.
startLoc
=
this
.
endLoc
=
this
.
curPosition
(
)
;
this
.
lastTokEndLoc
=
this
.
lastTokStartLoc
=
null
;
this
.
lastTokStart
=
this
.
lastTokEnd
=
this
.
pos
;
this
.
context
=
this
.
initialContext
(
)
;
this
.
exprAllowed
=
true
;
this
.
inModule
=
options
.
sourceType
=
=
=
"
module
"
;
this
.
strict
=
this
.
inModule
|
|
this
.
strictDirective
(
this
.
pos
)
;
this
.
potentialArrowAt
=
-
1
;
this
.
inFunction
=
this
.
inGenerator
=
this
.
inAsync
=
false
;
this
.
yieldPos
=
this
.
awaitPos
=
0
;
this
.
labels
=
[
]
;
if
(
this
.
pos
=
=
=
0
&
&
options
.
allowHashBang
&
&
this
.
input
.
slice
(
0
2
)
=
=
=
"
#
!
"
)
{
this
.
skipLineComment
(
2
)
;
}
this
.
scopeStack
=
[
]
;
this
.
enterFunctionScope
(
)
;
}
;
Parser
.
prototype
.
isKeyword
=
function
isKeyword
(
word
)
{
return
this
.
keywords
.
test
(
word
)
}
;
Parser
.
prototype
.
isReservedWord
=
function
isReservedWord
(
word
)
{
return
this
.
reservedWords
.
test
(
word
)
}
;
Parser
.
prototype
.
extend
=
function
extend
(
name
f
)
{
this
[
name
]
=
f
(
this
[
name
]
)
;
}
;
Parser
.
prototype
.
loadPlugins
=
function
loadPlugins
(
pluginConfigs
)
{
var
this
1
=
this
;
for
(
var
name
in
pluginConfigs
)
{
var
plugin
=
plugins
[
name
]
;
if
(
!
plugin
)
{
throw
new
Error
(
"
Plugin
'
"
+
name
+
"
'
not
found
"
)
}
plugin
(
this
1
pluginConfigs
[
name
]
)
;
}
}
;
Parser
.
prototype
.
parse
=
function
parse
(
)
{
var
node
=
this
.
options
.
program
|
|
this
.
startNode
(
)
;
this
.
nextToken
(
)
;
return
this
.
parseTopLevel
(
node
)
}
;
var
pp
=
Parser
.
prototype
;
var
literal
=
/
^
(
?
:
'
(
(
?
:
\
\
.
|
[
^
'
]
)
*
?
)
'
|
"
(
(
?
:
\
\
.
|
[
^
"
]
)
*
?
)
"
|
;
)
/
;
pp
.
strictDirective
=
function
(
start
)
{
var
this
1
=
this
;
for
(
;
;
)
{
skipWhiteSpace
.
lastIndex
=
start
;
start
+
=
skipWhiteSpace
.
exec
(
this
1
.
input
)
[
0
]
.
length
;
var
match
=
literal
.
exec
(
this
1
.
input
.
slice
(
start
)
)
;
if
(
!
match
)
{
return
false
}
if
(
(
match
[
1
]
|
|
match
[
2
]
)
=
=
"
use
strict
"
)
{
return
true
}
start
+
=
match
[
0
]
.
length
;
}
}
;
pp
.
eat
=
function
(
type
)
{
if
(
this
.
type
=
=
=
type
)
{
this
.
next
(
)
;
return
true
}
else
{
return
false
}
}
;
pp
.
isContextual
=
function
(
name
)
{
return
this
.
type
=
=
=
types
.
name
&
&
this
.
value
=
=
=
name
}
;
pp
.
eatContextual
=
function
(
name
)
{
return
this
.
value
=
=
=
name
&
&
this
.
eat
(
types
.
name
)
}
;
pp
.
expectContextual
=
function
(
name
)
{
if
(
!
this
.
eatContextual
(
name
)
)
{
this
.
unexpected
(
)
;
}
}
;
pp
.
canInsertSemicolon
=
function
(
)
{
return
this
.
type
=
=
=
types
.
eof
|
|
this
.
type
=
=
=
types
.
braceR
|
|
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
start
)
)
}
;
pp
.
insertSemicolon
=
function
(
)
{
if
(
this
.
canInsertSemicolon
(
)
)
{
if
(
this
.
options
.
onInsertedSemicolon
)
{
this
.
options
.
onInsertedSemicolon
(
this
.
lastTokEnd
this
.
lastTokEndLoc
)
;
}
return
true
}
}
;
pp
.
semicolon
=
function
(
)
{
if
(
!
this
.
eat
(
types
.
semi
)
&
&
!
this
.
insertSemicolon
(
)
)
{
this
.
unexpected
(
)
;
}
}
;
pp
.
afterTrailingComma
=
function
(
tokType
notNext
)
{
if
(
this
.
type
=
=
tokType
)
{
if
(
this
.
options
.
onTrailingComma
)
{
this
.
options
.
onTrailingComma
(
this
.
lastTokStart
this
.
lastTokStartLoc
)
;
}
if
(
!
notNext
)
{
this
.
next
(
)
;
}
return
true
}
}
;
pp
.
expect
=
function
(
type
)
{
this
.
eat
(
type
)
|
|
this
.
unexpected
(
)
;
}
;
pp
.
unexpected
=
function
(
pos
)
{
this
.
raise
(
pos
!
=
null
?
pos
:
this
.
start
"
Unexpected
token
"
)
;
}
;
function
DestructuringErrors
(
)
{
this
.
shorthandAssign
=
this
.
trailingComma
=
this
.
parenthesizedAssign
=
this
.
parenthesizedBind
=
-
1
;
}
pp
.
checkPatternErrors
=
function
(
refDestructuringErrors
isAssign
)
{
if
(
!
refDestructuringErrors
)
{
return
}
if
(
refDestructuringErrors
.
trailingComma
>
-
1
)
{
this
.
raiseRecoverable
(
refDestructuringErrors
.
trailingComma
"
Comma
is
not
permitted
after
the
rest
element
"
)
;
}
var
parens
=
isAssign
?
refDestructuringErrors
.
parenthesizedAssign
:
refDestructuringErrors
.
parenthesizedBind
;
if
(
parens
>
-
1
)
{
this
.
raiseRecoverable
(
parens
"
Parenthesized
pattern
"
)
;
}
}
;
pp
.
checkExpressionErrors
=
function
(
refDestructuringErrors
andThrow
)
{
var
pos
=
refDestructuringErrors
?
refDestructuringErrors
.
shorthandAssign
:
-
1
;
if
(
!
andThrow
)
{
return
pos
>
=
0
}
if
(
pos
>
-
1
)
{
this
.
raise
(
pos
"
Shorthand
property
assignments
are
valid
only
in
destructuring
patterns
"
)
;
}
}
;
pp
.
checkYieldAwaitInDefaultParams
=
function
(
)
{
if
(
this
.
yieldPos
&
&
(
!
this
.
awaitPos
|
|
this
.
yieldPos
<
this
.
awaitPos
)
)
{
this
.
raise
(
this
.
yieldPos
"
Yield
expression
cannot
be
a
default
value
"
)
;
}
if
(
this
.
awaitPos
)
{
this
.
raise
(
this
.
awaitPos
"
Await
expression
cannot
be
a
default
value
"
)
;
}
}
;
pp
.
isSimpleAssignTarget
=
function
(
expr
)
{
if
(
expr
.
type
=
=
=
"
ParenthesizedExpression
"
)
{
return
this
.
isSimpleAssignTarget
(
expr
.
expression
)
}
return
expr
.
type
=
=
=
"
Identifier
"
|
|
expr
.
type
=
=
=
"
MemberExpression
"
}
;
var
pp
1
=
Parser
.
prototype
;
pp
1
.
parseTopLevel
=
function
(
node
)
{
var
this
1
=
this
;
var
exports
=
{
}
;
if
(
!
node
.
body
)
{
node
.
body
=
[
]
;
}
while
(
this
.
type
!
=
=
types
.
eof
)
{
var
stmt
=
this
1
.
parseStatement
(
true
true
exports
)
;
node
.
body
.
push
(
stmt
)
;
}
this
.
adaptDirectivePrologue
(
node
.
body
)
;
this
.
next
(
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
node
.
sourceType
=
this
.
options
.
sourceType
;
}
return
this
.
finishNode
(
node
"
Program
"
)
}
;
var
loopLabel
=
{
kind
:
"
loop
"
}
;
var
switchLabel
=
{
kind
:
"
switch
"
}
;
pp
1
.
isLet
=
function
(
)
{
if
(
this
.
type
!
=
=
types
.
name
|
|
this
.
options
.
ecmaVersion
<
6
|
|
this
.
value
!
=
"
let
"
)
{
return
false
}
skipWhiteSpace
.
lastIndex
=
this
.
pos
;
var
skip
=
skipWhiteSpace
.
exec
(
this
.
input
)
;
var
next
=
this
.
pos
+
skip
[
0
]
.
length
nextCh
=
this
.
input
.
charCodeAt
(
next
)
;
if
(
nextCh
=
=
=
91
|
|
nextCh
=
=
123
)
{
return
true
}
if
(
isIdentifierStart
(
nextCh
true
)
)
{
var
pos
=
next
+
1
;
while
(
isIdentifierChar
(
this
.
input
.
charCodeAt
(
pos
)
true
)
)
{
+
+
pos
;
}
var
ident
=
this
.
input
.
slice
(
next
pos
)
;
if
(
!
this
.
isKeyword
(
ident
)
)
{
return
true
}
}
return
false
}
;
pp
1
.
isAsyncFunction
=
function
(
)
{
if
(
this
.
type
!
=
=
types
.
name
|
|
this
.
options
.
ecmaVersion
<
8
|
|
this
.
value
!
=
"
async
"
)
{
return
false
}
skipWhiteSpace
.
lastIndex
=
this
.
pos
;
var
skip
=
skipWhiteSpace
.
exec
(
this
.
input
)
;
var
next
=
this
.
pos
+
skip
[
0
]
.
length
;
return
!
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
pos
next
)
)
&
&
this
.
input
.
slice
(
next
next
+
8
)
=
=
=
"
function
"
&
&
(
next
+
8
=
=
this
.
input
.
length
|
|
!
isIdentifierChar
(
this
.
input
.
charAt
(
next
+
8
)
)
)
}
;
pp
1
.
parseStatement
=
function
(
declaration
topLevel
exports
)
{
var
starttype
=
this
.
type
node
=
this
.
startNode
(
)
kind
;
if
(
this
.
isLet
(
)
)
{
starttype
=
types
.
_var
;
kind
=
"
let
"
;
}
switch
(
starttype
)
{
case
types
.
_break
:
case
types
.
_continue
:
return
this
.
parseBreakContinueStatement
(
node
starttype
.
keyword
)
case
types
.
_debugger
:
return
this
.
parseDebuggerStatement
(
node
)
case
types
.
_do
:
return
this
.
parseDoStatement
(
node
)
case
types
.
_for
:
return
this
.
parseForStatement
(
node
)
case
types
.
_function
:
if
(
!
declaration
&
&
this
.
options
.
ecmaVersion
>
=
6
)
{
this
.
unexpected
(
)
;
}
return
this
.
parseFunctionStatement
(
node
false
)
case
types
.
_class
:
if
(
!
declaration
)
{
this
.
unexpected
(
)
;
}
return
this
.
parseClass
(
node
true
)
case
types
.
_if
:
return
this
.
parseIfStatement
(
node
)
case
types
.
_return
:
return
this
.
parseReturnStatement
(
node
)
case
types
.
_switch
:
return
this
.
parseSwitchStatement
(
node
)
case
types
.
_throw
:
return
this
.
parseThrowStatement
(
node
)
case
types
.
_try
:
return
this
.
parseTryStatement
(
node
)
case
types
.
_const
:
case
types
.
_var
:
kind
=
kind
|
|
this
.
value
;
if
(
!
declaration
&
&
kind
!
=
"
var
"
)
{
this
.
unexpected
(
)
;
}
return
this
.
parseVarStatement
(
node
kind
)
case
types
.
_while
:
return
this
.
parseWhileStatement
(
node
)
case
types
.
_with
:
return
this
.
parseWithStatement
(
node
)
case
types
.
braceL
:
return
this
.
parseBlock
(
)
case
types
.
semi
:
return
this
.
parseEmptyStatement
(
node
)
case
types
.
_export
:
case
types
.
_import
:
if
(
!
this
.
options
.
allowImportExportEverywhere
)
{
if
(
!
topLevel
)
{
this
.
raise
(
this
.
start
"
'
import
'
and
'
export
'
may
only
appear
at
the
top
level
"
)
;
}
if
(
!
this
.
inModule
)
{
this
.
raise
(
this
.
start
"
'
import
'
and
'
export
'
may
appear
only
with
'
sourceType
:
module
'
"
)
;
}
}
return
starttype
=
=
=
types
.
_import
?
this
.
parseImport
(
node
)
:
this
.
parseExport
(
node
exports
)
default
:
if
(
this
.
isAsyncFunction
(
)
&
&
declaration
)
{
this
.
next
(
)
;
return
this
.
parseFunctionStatement
(
node
true
)
}
var
maybeName
=
this
.
value
expr
=
this
.
parseExpression
(
)
;
if
(
starttype
=
=
=
types
.
name
&
&
expr
.
type
=
=
=
"
Identifier
"
&
&
this
.
eat
(
types
.
colon
)
)
{
return
this
.
parseLabeledStatement
(
node
maybeName
expr
)
}
else
{
return
this
.
parseExpressionStatement
(
node
expr
)
}
}
}
;
pp
1
.
parseBreakContinueStatement
=
function
(
node
keyword
)
{
var
this
1
=
this
;
var
isBreak
=
keyword
=
=
"
break
"
;
this
.
next
(
)
;
if
(
this
.
eat
(
types
.
semi
)
|
|
this
.
insertSemicolon
(
)
)
{
node
.
label
=
null
;
}
else
if
(
this
.
type
!
=
=
types
.
name
)
{
this
.
unexpected
(
)
;
}
else
{
node
.
label
=
this
.
parseIdent
(
)
;
this
.
semicolon
(
)
;
}
var
i
=
0
;
for
(
;
i
<
this
.
labels
.
length
;
+
+
i
)
{
var
lab
=
this
1
.
labels
[
i
]
;
if
(
node
.
label
=
=
null
|
|
lab
.
name
=
=
=
node
.
label
.
name
)
{
if
(
lab
.
kind
!
=
null
&
&
(
isBreak
|
|
lab
.
kind
=
=
=
"
loop
"
)
)
{
break
}
if
(
node
.
label
&
&
isBreak
)
{
break
}
}
}
if
(
i
=
=
=
this
.
labels
.
length
)
{
this
.
raise
(
node
.
start
"
Unsyntactic
"
+
keyword
)
;
}
return
this
.
finishNode
(
node
isBreak
?
"
BreakStatement
"
:
"
ContinueStatement
"
)
}
;
pp
1
.
parseDebuggerStatement
=
function
(
node
)
{
this
.
next
(
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
DebuggerStatement
"
)
}
;
pp
1
.
parseDoStatement
=
function
(
node
)
{
this
.
next
(
)
;
this
.
labels
.
push
(
loopLabel
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
this
.
expect
(
types
.
_while
)
;
node
.
test
=
this
.
parseParenExpression
(
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
this
.
eat
(
types
.
semi
)
;
}
else
{
this
.
semicolon
(
)
;
}
return
this
.
finishNode
(
node
"
DoWhileStatement
"
)
}
;
pp
1
.
parseForStatement
=
function
(
node
)
{
this
.
next
(
)
;
this
.
labels
.
push
(
loopLabel
)
;
this
.
enterLexicalScope
(
)
;
this
.
expect
(
types
.
parenL
)
;
if
(
this
.
type
=
=
=
types
.
semi
)
{
return
this
.
parseFor
(
node
null
)
}
var
isLet
=
this
.
isLet
(
)
;
if
(
this
.
type
=
=
=
types
.
_var
|
|
this
.
type
=
=
=
types
.
_const
|
|
isLet
)
{
var
init
1
=
this
.
startNode
(
)
kind
=
isLet
?
"
let
"
:
this
.
value
;
this
.
next
(
)
;
this
.
parseVar
(
init
1
true
kind
)
;
this
.
finishNode
(
init
1
"
VariableDeclaration
"
)
;
if
(
(
this
.
type
=
=
=
types
.
_in
|
|
(
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
isContextual
(
"
of
"
)
)
)
&
&
init
1
.
declarations
.
length
=
=
=
1
&
&
!
(
kind
!
=
=
"
var
"
&
&
init
1
.
declarations
[
0
]
.
init
)
)
{
return
this
.
parseForIn
(
node
init
1
)
}
return
this
.
parseFor
(
node
init
1
)
}
var
refDestructuringErrors
=
new
DestructuringErrors
;
var
init
=
this
.
parseExpression
(
true
refDestructuringErrors
)
;
if
(
this
.
type
=
=
=
types
.
_in
|
|
(
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
isContextual
(
"
of
"
)
)
)
{
this
.
toAssignable
(
init
)
;
this
.
checkLVal
(
init
)
;
this
.
checkPatternErrors
(
refDestructuringErrors
true
)
;
return
this
.
parseForIn
(
node
init
)
}
else
{
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
}
return
this
.
parseFor
(
node
init
)
}
;
pp
1
.
parseFunctionStatement
=
function
(
node
isAsync
)
{
this
.
next
(
)
;
return
this
.
parseFunction
(
node
true
false
isAsync
)
}
;
pp
1
.
isFunction
=
function
(
)
{
return
this
.
type
=
=
=
types
.
_function
|
|
this
.
isAsyncFunction
(
)
}
;
pp
1
.
parseIfStatement
=
function
(
node
)
{
this
.
next
(
)
;
node
.
test
=
this
.
parseParenExpression
(
)
;
node
.
consequent
=
this
.
parseStatement
(
!
this
.
strict
&
&
this
.
isFunction
(
)
)
;
node
.
alternate
=
this
.
eat
(
types
.
_else
)
?
this
.
parseStatement
(
!
this
.
strict
&
&
this
.
isFunction
(
)
)
:
null
;
return
this
.
finishNode
(
node
"
IfStatement
"
)
}
;
pp
1
.
parseReturnStatement
=
function
(
node
)
{
if
(
!
this
.
inFunction
&
&
!
this
.
options
.
allowReturnOutsideFunction
)
{
this
.
raise
(
this
.
start
"
'
return
'
outside
of
function
"
)
;
}
this
.
next
(
)
;
if
(
this
.
eat
(
types
.
semi
)
|
|
this
.
insertSemicolon
(
)
)
{
node
.
argument
=
null
;
}
else
{
node
.
argument
=
this
.
parseExpression
(
)
;
this
.
semicolon
(
)
;
}
return
this
.
finishNode
(
node
"
ReturnStatement
"
)
}
;
pp
1
.
parseSwitchStatement
=
function
(
node
)
{
var
this
1
=
this
;
this
.
next
(
)
;
node
.
discriminant
=
this
.
parseParenExpression
(
)
;
node
.
cases
=
[
]
;
this
.
expect
(
types
.
braceL
)
;
this
.
labels
.
push
(
switchLabel
)
;
this
.
enterLexicalScope
(
)
;
var
cur
;
for
(
var
sawDefault
=
false
;
this
.
type
!
=
types
.
braceR
;
)
{
if
(
this
1
.
type
=
=
=
types
.
_case
|
|
this
1
.
type
=
=
=
types
.
_default
)
{
var
isCase
=
this
1
.
type
=
=
=
types
.
_case
;
if
(
cur
)
{
this
1
.
finishNode
(
cur
"
SwitchCase
"
)
;
}
node
.
cases
.
push
(
cur
=
this
1
.
startNode
(
)
)
;
cur
.
consequent
=
[
]
;
this
1
.
next
(
)
;
if
(
isCase
)
{
cur
.
test
=
this
1
.
parseExpression
(
)
;
}
else
{
if
(
sawDefault
)
{
this
1
.
raiseRecoverable
(
this
1
.
lastTokStart
"
Multiple
default
clauses
"
)
;
}
sawDefault
=
true
;
cur
.
test
=
null
;
}
this
1
.
expect
(
types
.
colon
)
;
}
else
{
if
(
!
cur
)
{
this
1
.
unexpected
(
)
;
}
cur
.
consequent
.
push
(
this
1
.
parseStatement
(
true
)
)
;
}
}
this
.
exitLexicalScope
(
)
;
if
(
cur
)
{
this
.
finishNode
(
cur
"
SwitchCase
"
)
;
}
this
.
next
(
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
"
SwitchStatement
"
)
}
;
pp
1
.
parseThrowStatement
=
function
(
node
)
{
this
.
next
(
)
;
if
(
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
start
)
)
)
{
this
.
raise
(
this
.
lastTokEnd
"
Illegal
newline
after
throw
"
)
;
}
node
.
argument
=
this
.
parseExpression
(
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ThrowStatement
"
)
}
;
var
empty
=
[
]
;
pp
1
.
parseTryStatement
=
function
(
node
)
{
this
.
next
(
)
;
node
.
block
=
this
.
parseBlock
(
)
;
node
.
handler
=
null
;
if
(
this
.
type
=
=
=
types
.
_catch
)
{
var
clause
=
this
.
startNode
(
)
;
this
.
next
(
)
;
this
.
expect
(
types
.
parenL
)
;
clause
.
param
=
this
.
parseBindingAtom
(
)
;
this
.
enterLexicalScope
(
)
;
this
.
checkLVal
(
clause
.
param
"
let
"
)
;
this
.
expect
(
types
.
parenR
)
;
clause
.
body
=
this
.
parseBlock
(
false
)
;
this
.
exitLexicalScope
(
)
;
node
.
handler
=
this
.
finishNode
(
clause
"
CatchClause
"
)
;
}
node
.
finalizer
=
this
.
eat
(
types
.
_finally
)
?
this
.
parseBlock
(
)
:
null
;
if
(
!
node
.
handler
&
&
!
node
.
finalizer
)
{
this
.
raise
(
node
.
start
"
Missing
catch
or
finally
clause
"
)
;
}
return
this
.
finishNode
(
node
"
TryStatement
"
)
}
;
pp
1
.
parseVarStatement
=
function
(
node
kind
)
{
this
.
next
(
)
;
this
.
parseVar
(
node
false
kind
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
VariableDeclaration
"
)
}
;
pp
1
.
parseWhileStatement
=
function
(
node
)
{
this
.
next
(
)
;
node
.
test
=
this
.
parseParenExpression
(
)
;
this
.
labels
.
push
(
loopLabel
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
"
WhileStatement
"
)
}
;
pp
1
.
parseWithStatement
=
function
(
node
)
{
if
(
this
.
strict
)
{
this
.
raise
(
this
.
start
"
'
with
'
in
strict
mode
"
)
;
}
this
.
next
(
)
;
node
.
object
=
this
.
parseParenExpression
(
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
return
this
.
finishNode
(
node
"
WithStatement
"
)
}
;
pp
1
.
parseEmptyStatement
=
function
(
node
)
{
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
EmptyStatement
"
)
}
;
pp
1
.
parseLabeledStatement
=
function
(
node
maybeName
expr
)
{
var
this
1
=
this
;
for
(
var
i
1
=
0
list
=
this
1
.
labels
;
i
1
<
list
.
length
;
i
1
+
=
1
)
{
var
label
=
list
[
i
1
]
;
if
(
label
.
name
=
=
=
maybeName
)
{
this
1
.
raise
(
expr
.
start
"
Label
'
"
+
maybeName
+
"
'
is
already
declared
"
)
;
}
}
var
kind
=
this
.
type
.
isLoop
?
"
loop
"
:
this
.
type
=
=
=
types
.
_switch
?
"
switch
"
:
null
;
for
(
var
i
=
this
.
labels
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
label
1
=
this
1
.
labels
[
i
]
;
if
(
label
1
.
statementStart
=
=
node
.
start
)
{
label
1
.
statementStart
=
this
1
.
start
;
label
1
.
kind
=
kind
;
}
else
{
break
}
}
this
.
labels
.
push
(
{
name
:
maybeName
kind
:
kind
statementStart
:
this
.
start
}
)
;
node
.
body
=
this
.
parseStatement
(
true
)
;
if
(
node
.
body
.
type
=
=
"
ClassDeclaration
"
|
|
node
.
body
.
type
=
=
"
VariableDeclaration
"
&
&
node
.
body
.
kind
!
=
"
var
"
|
|
node
.
body
.
type
=
=
"
FunctionDeclaration
"
&
&
(
this
.
strict
|
|
node
.
body
.
generator
)
)
{
this
.
raiseRecoverable
(
node
.
body
.
start
"
Invalid
labeled
declaration
"
)
;
}
this
.
labels
.
pop
(
)
;
node
.
label
=
expr
;
return
this
.
finishNode
(
node
"
LabeledStatement
"
)
}
;
pp
1
.
parseExpressionStatement
=
function
(
node
expr
)
{
node
.
expression
=
expr
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ExpressionStatement
"
)
}
;
pp
1
.
parseBlock
=
function
(
createNewLexicalScope
)
{
var
this
1
=
this
;
if
(
createNewLexicalScope
=
=
=
void
0
)
createNewLexicalScope
=
true
;
var
node
=
this
.
startNode
(
)
;
node
.
body
=
[
]
;
this
.
expect
(
types
.
braceL
)
;
if
(
createNewLexicalScope
)
{
this
.
enterLexicalScope
(
)
;
}
while
(
!
this
.
eat
(
types
.
braceR
)
)
{
var
stmt
=
this
1
.
parseStatement
(
true
)
;
node
.
body
.
push
(
stmt
)
;
}
if
(
createNewLexicalScope
)
{
this
.
exitLexicalScope
(
)
;
}
return
this
.
finishNode
(
node
"
BlockStatement
"
)
}
;
pp
1
.
parseFor
=
function
(
node
init
)
{
node
.
init
=
init
;
this
.
expect
(
types
.
semi
)
;
node
.
test
=
this
.
type
=
=
=
types
.
semi
?
null
:
this
.
parseExpression
(
)
;
this
.
expect
(
types
.
semi
)
;
node
.
update
=
this
.
type
=
=
=
types
.
parenR
?
null
:
this
.
parseExpression
(
)
;
this
.
expect
(
types
.
parenR
)
;
this
.
exitLexicalScope
(
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
"
ForStatement
"
)
}
;
pp
1
.
parseForIn
=
function
(
node
init
)
{
var
type
=
this
.
type
=
=
=
types
.
_in
?
"
ForInStatement
"
:
"
ForOfStatement
"
;
this
.
next
(
)
;
node
.
left
=
init
;
node
.
right
=
this
.
parseExpression
(
)
;
this
.
expect
(
types
.
parenR
)
;
this
.
exitLexicalScope
(
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
type
)
}
;
pp
1
.
parseVar
=
function
(
node
isFor
kind
)
{
var
this
1
=
this
;
node
.
declarations
=
[
]
;
node
.
kind
=
kind
;
for
(
;
;
)
{
var
decl
=
this
1
.
startNode
(
)
;
this
1
.
parseVarId
(
decl
kind
)
;
if
(
this
1
.
eat
(
types
.
eq
)
)
{
decl
.
init
=
this
1
.
parseMaybeAssign
(
isFor
)
;
}
else
if
(
kind
=
=
=
"
const
"
&
&
!
(
this
1
.
type
=
=
=
types
.
_in
|
|
(
this
1
.
options
.
ecmaVersion
>
=
6
&
&
this
1
.
isContextual
(
"
of
"
)
)
)
)
{
this
1
.
unexpected
(
)
;
}
else
if
(
decl
.
id
.
type
!
=
"
Identifier
"
&
&
!
(
isFor
&
&
(
this
1
.
type
=
=
=
types
.
_in
|
|
this
1
.
isContextual
(
"
of
"
)
)
)
)
{
this
1
.
raise
(
this
1
.
lastTokEnd
"
Complex
binding
patterns
require
an
initialization
value
"
)
;
}
else
{
decl
.
init
=
null
;
}
node
.
declarations
.
push
(
this
1
.
finishNode
(
decl
"
VariableDeclarator
"
)
)
;
if
(
!
this
1
.
eat
(
types
.
comma
)
)
{
break
}
}
return
node
}
;
pp
1
.
parseVarId
=
function
(
decl
kind
)
{
decl
.
id
=
this
.
parseBindingAtom
(
kind
)
;
this
.
checkLVal
(
decl
.
id
kind
false
)
;
}
;
pp
1
.
parseFunction
=
function
(
node
isStatement
allowExpressionBody
isAsync
)
{
this
.
initFunction
(
node
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
!
isAsync
)
{
node
.
generator
=
this
.
eat
(
types
.
star
)
;
}
if
(
this
.
options
.
ecmaVersion
>
=
8
)
{
node
.
async
=
!
!
isAsync
;
}
if
(
isStatement
)
{
node
.
id
=
isStatement
=
=
=
"
nullableID
"
&
&
this
.
type
!
=
types
.
name
?
null
:
this
.
parseIdent
(
)
;
if
(
node
.
id
)
{
this
.
checkLVal
(
node
.
id
"
var
"
)
;
}
}
var
oldInGen
=
this
.
inGenerator
oldInAsync
=
this
.
inAsync
oldYieldPos
=
this
.
yieldPos
oldAwaitPos
=
this
.
awaitPos
oldInFunc
=
this
.
inFunction
;
this
.
inGenerator
=
node
.
generator
;
this
.
inAsync
=
node
.
async
;
this
.
yieldPos
=
0
;
this
.
awaitPos
=
0
;
this
.
inFunction
=
true
;
this
.
enterFunctionScope
(
)
;
if
(
!
isStatement
)
{
node
.
id
=
this
.
type
=
=
types
.
name
?
this
.
parseIdent
(
)
:
null
;
}
this
.
parseFunctionParams
(
node
)
;
this
.
parseFunctionBody
(
node
allowExpressionBody
)
;
this
.
inGenerator
=
oldInGen
;
this
.
inAsync
=
oldInAsync
;
this
.
yieldPos
=
oldYieldPos
;
this
.
awaitPos
=
oldAwaitPos
;
this
.
inFunction
=
oldInFunc
;
return
this
.
finishNode
(
node
isStatement
?
"
FunctionDeclaration
"
:
"
FunctionExpression
"
)
}
;
pp
1
.
parseFunctionParams
=
function
(
node
)
{
this
.
expect
(
types
.
parenL
)
;
node
.
params
=
this
.
parseBindingList
(
types
.
parenR
false
this
.
options
.
ecmaVersion
>
=
8
)
;
this
.
checkYieldAwaitInDefaultParams
(
)
;
}
;
pp
1
.
parseClass
=
function
(
node
isStatement
)
{
var
this
1
=
this
;
this
.
next
(
)
;
this
.
parseClassId
(
node
isStatement
)
;
this
.
parseClassSuper
(
node
)
;
var
classBody
=
this
.
startNode
(
)
;
var
hadConstructor
=
false
;
classBody
.
body
=
[
]
;
this
.
expect
(
types
.
braceL
)
;
while
(
!
this
.
eat
(
types
.
braceR
)
)
{
if
(
this
1
.
eat
(
types
.
semi
)
)
{
continue
}
var
method
=
this
1
.
startNode
(
)
;
var
isGenerator
=
this
1
.
eat
(
types
.
star
)
;
var
isAsync
=
false
;
var
isMaybeStatic
=
this
1
.
type
=
=
=
types
.
name
&
&
this
1
.
value
=
=
=
"
static
"
;
this
1
.
parsePropertyName
(
method
)
;
method
.
static
=
isMaybeStatic
&
&
this
1
.
type
!
=
=
types
.
parenL
;
if
(
method
.
static
)
{
if
(
isGenerator
)
{
this
1
.
unexpected
(
)
;
}
isGenerator
=
this
1
.
eat
(
types
.
star
)
;
this
1
.
parsePropertyName
(
method
)
;
}
if
(
this
1
.
options
.
ecmaVersion
>
=
8
&
&
!
isGenerator
&
&
!
method
.
computed
&
&
method
.
key
.
type
=
=
=
"
Identifier
"
&
&
method
.
key
.
name
=
=
=
"
async
"
&
&
this
1
.
type
!
=
=
types
.
parenL
&
&
!
this
1
.
canInsertSemicolon
(
)
)
{
isAsync
=
true
;
this
1
.
parsePropertyName
(
method
)
;
}
method
.
kind
=
"
method
"
;
var
isGetSet
=
false
;
if
(
!
method
.
computed
)
{
var
key
=
method
.
key
;
if
(
!
isGenerator
&
&
!
isAsync
&
&
key
.
type
=
=
=
"
Identifier
"
&
&
this
1
.
type
!
=
=
types
.
parenL
&
&
(
key
.
name
=
=
=
"
get
"
|
|
key
.
name
=
=
=
"
set
"
)
)
{
isGetSet
=
true
;
method
.
kind
=
key
.
name
;
key
=
this
1
.
parsePropertyName
(
method
)
;
}
if
(
!
method
.
static
&
&
(
key
.
type
=
=
=
"
Identifier
"
&
&
key
.
name
=
=
=
"
constructor
"
|
|
key
.
type
=
=
=
"
Literal
"
&
&
key
.
value
=
=
=
"
constructor
"
)
)
{
if
(
hadConstructor
)
{
this
1
.
raise
(
key
.
start
"
Duplicate
constructor
in
the
same
class
"
)
;
}
if
(
isGetSet
)
{
this
1
.
raise
(
key
.
start
"
Constructor
can
'
t
have
get
/
set
modifier
"
)
;
}
if
(
isGenerator
)
{
this
1
.
raise
(
key
.
start
"
Constructor
can
'
t
be
a
generator
"
)
;
}
if
(
isAsync
)
{
this
1
.
raise
(
key
.
start
"
Constructor
can
'
t
be
an
async
method
"
)
;
}
method
.
kind
=
"
constructor
"
;
hadConstructor
=
true
;
}
}
this
1
.
parseClassMethod
(
classBody
method
isGenerator
isAsync
)
;
if
(
isGetSet
)
{
var
paramCount
=
method
.
kind
=
=
=
"
get
"
?
0
:
1
;
if
(
method
.
value
.
params
.
length
!
=
=
paramCount
)
{
var
start
=
method
.
value
.
start
;
if
(
method
.
kind
=
=
=
"
get
"
)
{
this
1
.
raiseRecoverable
(
start
"
getter
should
have
no
params
"
)
;
}
else
{
this
1
.
raiseRecoverable
(
start
"
setter
should
have
exactly
one
param
"
)
;
}
}
else
{
if
(
method
.
kind
=
=
=
"
set
"
&
&
method
.
value
.
params
[
0
]
.
type
=
=
=
"
RestElement
"
)
{
this
1
.
raiseRecoverable
(
method
.
value
.
params
[
0
]
.
start
"
Setter
cannot
use
rest
params
"
)
;
}
}
}
}
node
.
body
=
this
.
finishNode
(
classBody
"
ClassBody
"
)
;
return
this
.
finishNode
(
node
isStatement
?
"
ClassDeclaration
"
:
"
ClassExpression
"
)
}
;
pp
1
.
parseClassMethod
=
function
(
classBody
method
isGenerator
isAsync
)
{
method
.
value
=
this
.
parseMethod
(
isGenerator
isAsync
)
;
classBody
.
body
.
push
(
this
.
finishNode
(
method
"
MethodDefinition
"
)
)
;
}
;
pp
1
.
parseClassId
=
function
(
node
isStatement
)
{
node
.
id
=
this
.
type
=
=
=
types
.
name
?
this
.
parseIdent
(
)
:
isStatement
=
=
=
true
?
this
.
unexpected
(
)
:
null
;
}
;
pp
1
.
parseClassSuper
=
function
(
node
)
{
node
.
superClass
=
this
.
eat
(
types
.
_extends
)
?
this
.
parseExprSubscripts
(
)
:
null
;
}
;
pp
1
.
parseExport
=
function
(
node
exports
)
{
var
this
1
=
this
;
this
.
next
(
)
;
if
(
this
.
eat
(
types
.
star
)
)
{
this
.
expectContextual
(
"
from
"
)
;
node
.
source
=
this
.
type
=
=
=
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
unexpected
(
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ExportAllDeclaration
"
)
}
if
(
this
.
eat
(
types
.
_default
)
)
{
this
.
checkExport
(
exports
"
default
"
this
.
lastTokStart
)
;
var
isAsync
;
if
(
this
.
type
=
=
=
types
.
_function
|
|
(
isAsync
=
this
.
isAsyncFunction
(
)
)
)
{
var
fNode
=
this
.
startNode
(
)
;
this
.
next
(
)
;
if
(
isAsync
)
{
this
.
next
(
)
;
}
node
.
declaration
=
this
.
parseFunction
(
fNode
"
nullableID
"
false
isAsync
)
;
}
else
if
(
this
.
type
=
=
=
types
.
_class
)
{
var
cNode
=
this
.
startNode
(
)
;
node
.
declaration
=
this
.
parseClass
(
cNode
"
nullableID
"
)
;
}
else
{
node
.
declaration
=
this
.
parseMaybeAssign
(
)
;
this
.
semicolon
(
)
;
}
return
this
.
finishNode
(
node
"
ExportDefaultDeclaration
"
)
}
if
(
this
.
shouldParseExportStatement
(
)
)
{
node
.
declaration
=
this
.
parseStatement
(
true
)
;
if
(
node
.
declaration
.
type
=
=
=
"
VariableDeclaration
"
)
{
this
.
checkVariableExport
(
exports
node
.
declaration
.
declarations
)
;
}
else
{
this
.
checkExport
(
exports
node
.
declaration
.
id
.
name
node
.
declaration
.
id
.
start
)
;
}
node
.
specifiers
=
[
]
;
node
.
source
=
null
;
}
else
{
node
.
declaration
=
null
;
node
.
specifiers
=
this
.
parseExportSpecifiers
(
exports
)
;
if
(
this
.
eatContextual
(
"
from
"
)
)
{
node
.
source
=
this
.
type
=
=
=
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
unexpected
(
)
;
}
else
{
for
(
var
i
=
0
list
=
node
.
specifiers
;
i
<
list
.
length
;
i
+
=
1
)
{
var
spec
=
list
[
i
]
;
this
1
.
checkUnreserved
(
spec
.
local
)
;
}
node
.
source
=
null
;
}
this
.
semicolon
(
)
;
}
return
this
.
finishNode
(
node
"
ExportNamedDeclaration
"
)
}
;
pp
1
.
checkExport
=
function
(
exports
name
pos
)
{
if
(
!
exports
)
{
return
}
if
(
has
(
exports
name
)
)
{
this
.
raiseRecoverable
(
pos
"
Duplicate
export
'
"
+
name
+
"
'
"
)
;
}
exports
[
name
]
=
true
;
}
;
pp
1
.
checkPatternExport
=
function
(
exports
pat
)
{
var
this
1
=
this
;
var
type
=
pat
.
type
;
if
(
type
=
=
"
Identifier
"
)
{
this
.
checkExport
(
exports
pat
.
name
pat
.
start
)
;
}
else
if
(
type
=
=
"
ObjectPattern
"
)
{
for
(
var
i
=
0
list
=
pat
.
properties
;
i
<
list
.
length
;
i
+
=
1
)
{
var
prop
=
list
[
i
]
;
this
1
.
checkPatternExport
(
exports
prop
.
value
)
;
}
}
else
if
(
type
=
=
"
ArrayPattern
"
)
{
for
(
var
i
1
=
0
list
1
=
pat
.
elements
;
i
1
<
list
1
.
length
;
i
1
+
=
1
)
{
var
elt
=
list
1
[
i
1
]
;
if
(
elt
)
{
this
1
.
checkPatternExport
(
exports
elt
)
;
}
}
}
else
if
(
type
=
=
"
AssignmentPattern
"
)
{
this
.
checkPatternExport
(
exports
pat
.
left
)
;
}
else
if
(
type
=
=
"
ParenthesizedExpression
"
)
{
this
.
checkPatternExport
(
exports
pat
.
expression
)
;
}
}
;
pp
1
.
checkVariableExport
=
function
(
exports
decls
)
{
var
this
1
=
this
;
if
(
!
exports
)
{
return
}
for
(
var
i
=
0
list
=
decls
;
i
<
list
.
length
;
i
+
=
1
)
{
var
decl
=
list
[
i
]
;
this
1
.
checkPatternExport
(
exports
decl
.
id
)
;
}
}
;
pp
1
.
shouldParseExportStatement
=
function
(
)
{
return
this
.
type
.
keyword
=
=
=
"
var
"
|
|
this
.
type
.
keyword
=
=
=
"
const
"
|
|
this
.
type
.
keyword
=
=
=
"
class
"
|
|
this
.
type
.
keyword
=
=
=
"
function
"
|
|
this
.
isLet
(
)
|
|
this
.
isAsyncFunction
(
)
}
;
pp
1
.
parseExportSpecifiers
=
function
(
exports
)
{
var
this
1
=
this
;
var
nodes
=
[
]
first
=
true
;
this
.
expect
(
types
.
braceL
)
;
while
(
!
this
.
eat
(
types
.
braceR
)
)
{
if
(
!
first
)
{
this
1
.
expect
(
types
.
comma
)
;
if
(
this
1
.
afterTrailingComma
(
types
.
braceR
)
)
{
break
}
}
else
{
first
=
false
;
}
var
node
=
this
1
.
startNode
(
)
;
node
.
local
=
this
1
.
parseIdent
(
true
)
;
node
.
exported
=
this
1
.
eatContextual
(
"
as
"
)
?
this
1
.
parseIdent
(
true
)
:
node
.
local
;
this
1
.
checkExport
(
exports
node
.
exported
.
name
node
.
exported
.
start
)
;
nodes
.
push
(
this
1
.
finishNode
(
node
"
ExportSpecifier
"
)
)
;
}
return
nodes
}
;
pp
1
.
parseImport
=
function
(
node
)
{
this
.
next
(
)
;
if
(
this
.
type
=
=
=
types
.
string
)
{
node
.
specifiers
=
empty
;
node
.
source
=
this
.
parseExprAtom
(
)
;
}
else
{
node
.
specifiers
=
this
.
parseImportSpecifiers
(
)
;
this
.
expectContextual
(
"
from
"
)
;
node
.
source
=
this
.
type
=
=
=
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
unexpected
(
)
;
}
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ImportDeclaration
"
)
}
;
pp
1
.
parseImportSpecifiers
=
function
(
)
{
var
this
1
=
this
;
var
nodes
=
[
]
first
=
true
;
if
(
this
.
type
=
=
=
types
.
name
)
{
var
node
=
this
.
startNode
(
)
;
node
.
local
=
this
.
parseIdent
(
)
;
this
.
checkLVal
(
node
.
local
"
let
"
)
;
nodes
.
push
(
this
.
finishNode
(
node
"
ImportDefaultSpecifier
"
)
)
;
if
(
!
this
.
eat
(
types
.
comma
)
)
{
return
nodes
}
}
if
(
this
.
type
=
=
=
types
.
star
)
{
var
node
1
=
this
.
startNode
(
)
;
this
.
next
(
)
;
this
.
expectContextual
(
"
as
"
)
;
node
1
.
local
=
this
.
parseIdent
(
)
;
this
.
checkLVal
(
node
1
.
local
"
let
"
)
;
nodes
.
push
(
this
.
finishNode
(
node
1
"
ImportNamespaceSpecifier
"
)
)
;
return
nodes
}
this
.
expect
(
types
.
braceL
)
;
while
(
!
this
.
eat
(
types
.
braceR
)
)
{
if
(
!
first
)
{
this
1
.
expect
(
types
.
comma
)
;
if
(
this
1
.
afterTrailingComma
(
types
.
braceR
)
)
{
break
}
}
else
{
first
=
false
;
}
var
node
2
=
this
1
.
startNode
(
)
;
node
2
.
imported
=
this
1
.
parseIdent
(
true
)
;
if
(
this
1
.
eatContextual
(
"
as
"
)
)
{
node
2
.
local
=
this
1
.
parseIdent
(
)
;
}
else
{
this
1
.
checkUnreserved
(
node
2
.
imported
)
;
node
2
.
local
=
node
2
.
imported
;
}
this
1
.
checkLVal
(
node
2
.
local
"
let
"
)
;
nodes
.
push
(
this
1
.
finishNode
(
node
2
"
ImportSpecifier
"
)
)
;
}
return
nodes
}
;
pp
1
.
adaptDirectivePrologue
=
function
(
statements
)
{
for
(
var
i
=
0
;
i
<
statements
.
length
&
&
this
.
isDirectiveCandidate
(
statements
[
i
]
)
;
+
+
i
)
{
statements
[
i
]
.
directive
=
statements
[
i
]
.
expression
.
raw
.
slice
(
1
-
1
)
;
}
}
;
pp
1
.
isDirectiveCandidate
=
function
(
statement
)
{
return
(
statement
.
type
=
=
=
"
ExpressionStatement
"
&
&
statement
.
expression
.
type
=
=
=
"
Literal
"
&
&
typeof
statement
.
expression
.
value
=
=
=
"
string
"
&
&
(
this
.
input
[
statement
.
start
]
=
=
=
"
\
"
"
|
|
this
.
input
[
statement
.
start
]
=
=
=
"
'
"
)
)
}
;
var
pp
2
=
Parser
.
prototype
;
pp
2
.
toAssignable
=
function
(
node
isBinding
)
{
var
this
1
=
this
;
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
node
)
{
switch
(
node
.
type
)
{
case
"
Identifier
"
:
if
(
this
.
inAsync
&
&
node
.
name
=
=
=
"
await
"
)
{
this
.
raise
(
node
.
start
"
Can
not
use
'
await
'
as
identifier
inside
an
async
function
"
)
;
}
break
case
"
ObjectPattern
"
:
case
"
ArrayPattern
"
:
break
case
"
ObjectExpression
"
:
node
.
type
=
"
ObjectPattern
"
;
for
(
var
i
=
0
list
=
node
.
properties
;
i
<
list
.
length
;
i
+
=
1
)
{
var
prop
=
list
[
i
]
;
if
(
prop
.
kind
!
=
=
"
init
"
)
{
this
1
.
raise
(
prop
.
key
.
start
"
Object
pattern
can
'
t
contain
getter
or
setter
"
)
;
}
this
1
.
toAssignable
(
prop
.
value
isBinding
)
;
}
break
case
"
ArrayExpression
"
:
node
.
type
=
"
ArrayPattern
"
;
this
.
toAssignableList
(
node
.
elements
isBinding
)
;
break
case
"
AssignmentExpression
"
:
if
(
node
.
operator
=
=
=
"
=
"
)
{
node
.
type
=
"
AssignmentPattern
"
;
delete
node
.
operator
;
this
.
toAssignable
(
node
.
left
isBinding
)
;
}
else
{
this
.
raise
(
node
.
left
.
end
"
Only
'
=
'
operator
can
be
used
for
specifying
default
value
.
"
)
;
break
}
case
"
AssignmentPattern
"
:
break
case
"
ParenthesizedExpression
"
:
this
.
toAssignable
(
node
.
expression
isBinding
)
;
break
case
"
MemberExpression
"
:
if
(
!
isBinding
)
{
break
}
default
:
this
.
raise
(
node
.
start
"
Assigning
to
rvalue
"
)
;
}
}
return
node
}
;
pp
2
.
toAssignableList
=
function
(
exprList
isBinding
)
{
var
this
1
=
this
;
var
end
=
exprList
.
length
;
if
(
end
)
{
var
last
=
exprList
[
end
-
1
]
;
if
(
last
&
&
last
.
type
=
=
"
RestElement
"
)
{
-
-
end
;
}
else
if
(
last
&
&
last
.
type
=
=
"
SpreadElement
"
)
{
last
.
type
=
"
RestElement
"
;
var
arg
=
last
.
argument
;
this
.
toAssignable
(
arg
isBinding
)
;
-
-
end
;
}
if
(
this
.
options
.
ecmaVersion
=
=
=
6
&
&
isBinding
&
&
last
&
&
last
.
type
=
=
=
"
RestElement
"
&
&
last
.
argument
.
type
!
=
=
"
Identifier
"
)
{
this
.
unexpected
(
last
.
argument
.
start
)
;
}
}
for
(
var
i
=
0
;
i
<
end
;
i
+
+
)
{
var
elt
=
exprList
[
i
]
;
if
(
elt
)
{
this
1
.
toAssignable
(
elt
isBinding
)
;
}
}
return
exprList
}
;
pp
2
.
parseSpread
=
function
(
refDestructuringErrors
)
{
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
argument
=
this
.
parseMaybeAssign
(
false
refDestructuringErrors
)
;
return
this
.
finishNode
(
node
"
SpreadElement
"
)
}
;
pp
2
.
parseRestBinding
=
function
(
)
{
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
if
(
this
.
options
.
ecmaVersion
=
=
=
6
&
&
this
.
type
!
=
=
types
.
name
)
{
this
.
unexpected
(
)
;
}
node
.
argument
=
this
.
parseBindingAtom
(
)
;
return
this
.
finishNode
(
node
"
RestElement
"
)
}
;
pp
2
.
parseBindingAtom
=
function
(
)
{
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
switch
(
this
.
type
)
{
case
types
.
bracketL
:
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
elements
=
this
.
parseBindingList
(
types
.
bracketR
true
true
)
;
return
this
.
finishNode
(
node
"
ArrayPattern
"
)
case
types
.
braceL
:
return
this
.
parseObj
(
true
)
}
}
return
this
.
parseIdent
(
)
}
;
pp
2
.
parseBindingList
=
function
(
close
allowEmpty
allowTrailingComma
)
{
var
this
1
=
this
;
var
elts
=
[
]
first
=
true
;
while
(
!
this
.
eat
(
close
)
)
{
if
(
first
)
{
first
=
false
;
}
else
{
this
1
.
expect
(
types
.
comma
)
;
}
if
(
allowEmpty
&
&
this
1
.
type
=
=
=
types
.
comma
)
{
elts
.
push
(
null
)
;
}
else
if
(
allowTrailingComma
&
&
this
1
.
afterTrailingComma
(
close
)
)
{
break
}
else
if
(
this
1
.
type
=
=
=
types
.
ellipsis
)
{
var
rest
=
this
1
.
parseRestBinding
(
)
;
this
1
.
parseBindingListItem
(
rest
)
;
elts
.
push
(
rest
)
;
if
(
this
1
.
type
=
=
=
types
.
comma
)
{
this
1
.
raise
(
this
1
.
start
"
Comma
is
not
permitted
after
the
rest
element
"
)
;
}
this
1
.
expect
(
close
)
;
break
}
else
{
var
elem
=
this
1
.
parseMaybeDefault
(
this
1
.
start
this
1
.
startLoc
)
;
this
1
.
parseBindingListItem
(
elem
)
;
elts
.
push
(
elem
)
;
}
}
return
elts
}
;
pp
2
.
parseBindingListItem
=
function
(
param
)
{
return
param
}
;
pp
2
.
parseMaybeDefault
=
function
(
startPos
startLoc
left
)
{
left
=
left
|
|
this
.
parseBindingAtom
(
)
;
if
(
this
.
options
.
ecmaVersion
<
6
|
|
!
this
.
eat
(
types
.
eq
)
)
{
return
left
}
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
left
=
left
;
node
.
right
=
this
.
parseMaybeAssign
(
)
;
return
this
.
finishNode
(
node
"
AssignmentPattern
"
)
}
;
pp
2
.
checkLVal
=
function
(
expr
bindingType
checkClashes
)
{
var
this
1
=
this
;
switch
(
expr
.
type
)
{
case
"
Identifier
"
:
if
(
this
.
strict
&
&
this
.
reservedWordsStrictBind
.
test
(
expr
.
name
)
)
{
this
.
raiseRecoverable
(
expr
.
start
(
bindingType
?
"
Binding
"
:
"
Assigning
to
"
)
+
expr
.
name
+
"
in
strict
mode
"
)
;
}
if
(
checkClashes
)
{
if
(
has
(
checkClashes
expr
.
name
)
)
{
this
.
raiseRecoverable
(
expr
.
start
"
Argument
name
clash
"
)
;
}
checkClashes
[
expr
.
name
]
=
true
;
}
if
(
bindingType
&
&
bindingType
!
=
=
"
none
"
)
{
if
(
bindingType
=
=
=
"
var
"
&
&
!
this
.
canDeclareVarName
(
expr
.
name
)
|
|
bindingType
!
=
=
"
var
"
&
&
!
this
.
canDeclareLexicalName
(
expr
.
name
)
)
{
this
.
raiseRecoverable
(
expr
.
start
(
"
Identifier
'
"
+
(
expr
.
name
)
+
"
'
has
already
been
declared
"
)
)
;
}
if
(
bindingType
=
=
=
"
var
"
)
{
this
.
declareVarName
(
expr
.
name
)
;
}
else
{
this
.
declareLexicalName
(
expr
.
name
)
;
}
}
break
case
"
MemberExpression
"
:
if
(
bindingType
)
{
this
.
raiseRecoverable
(
expr
.
start
(
bindingType
?
"
Binding
"
:
"
Assigning
to
"
)
+
"
member
expression
"
)
;
}
break
case
"
ObjectPattern
"
:
for
(
var
i
=
0
list
=
expr
.
properties
;
i
<
list
.
length
;
i
+
=
1
)
{
var
prop
=
list
[
i
]
;
this
1
.
checkLVal
(
prop
.
value
bindingType
checkClashes
)
;
}
break
case
"
ArrayPattern
"
:
for
(
var
i
1
=
0
list
1
=
expr
.
elements
;
i
1
<
list
1
.
length
;
i
1
+
=
1
)
{
var
elem
=
list
1
[
i
1
]
;
if
(
elem
)
{
this
1
.
checkLVal
(
elem
bindingType
checkClashes
)
;
}
}
break
case
"
AssignmentPattern
"
:
this
.
checkLVal
(
expr
.
left
bindingType
checkClashes
)
;
break
case
"
RestElement
"
:
this
.
checkLVal
(
expr
.
argument
bindingType
checkClashes
)
;
break
case
"
ParenthesizedExpression
"
:
this
.
checkLVal
(
expr
.
expression
bindingType
checkClashes
)
;
break
default
:
this
.
raise
(
expr
.
start
(
bindingType
?
"
Binding
"
:
"
Assigning
to
"
)
+
"
rvalue
"
)
;
}
}
;
var
pp
3
=
Parser
.
prototype
;
pp
3
.
checkPropClash
=
function
(
prop
propHash
)
{
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
(
prop
.
computed
|
|
prop
.
method
|
|
prop
.
shorthand
)
)
{
return
}
var
key
=
prop
.
key
;
var
name
;
switch
(
key
.
type
)
{
case
"
Identifier
"
:
name
=
key
.
name
;
break
case
"
Literal
"
:
name
=
String
(
key
.
value
)
;
break
default
:
return
}
var
kind
=
prop
.
kind
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
if
(
name
=
=
=
"
__proto__
"
&
&
kind
=
=
=
"
init
"
)
{
if
(
propHash
.
proto
)
{
this
.
raiseRecoverable
(
key
.
start
"
Redefinition
of
__proto__
property
"
)
;
}
propHash
.
proto
=
true
;
}
return
}
name
=
"
"
+
name
;
var
other
=
propHash
[
name
]
;
if
(
other
)
{
var
redefinition
;
if
(
kind
=
=
=
"
init
"
)
{
redefinition
=
this
.
strict
&
&
other
.
init
|
|
other
.
get
|
|
other
.
set
;
}
else
{
redefinition
=
other
.
init
|
|
other
[
kind
]
;
}
if
(
redefinition
)
{
this
.
raiseRecoverable
(
key
.
start
"
Redefinition
of
property
"
)
;
}
}
else
{
other
=
propHash
[
name
]
=
{
init
:
false
get
:
false
set
:
false
}
;
}
other
[
kind
]
=
true
;
}
;
pp
3
.
parseExpression
=
function
(
noIn
refDestructuringErrors
)
{
var
this
1
=
this
;
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseMaybeAssign
(
noIn
refDestructuringErrors
)
;
if
(
this
.
type
=
=
=
types
.
comma
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
expressions
=
[
expr
]
;
while
(
this
.
eat
(
types
.
comma
)
)
{
node
.
expressions
.
push
(
this
1
.
parseMaybeAssign
(
noIn
refDestructuringErrors
)
)
;
}
return
this
.
finishNode
(
node
"
SequenceExpression
"
)
}
return
expr
}
;
pp
3
.
parseMaybeAssign
=
function
(
noIn
refDestructuringErrors
afterLeftParse
)
{
if
(
this
.
inGenerator
&
&
this
.
isContextual
(
"
yield
"
)
)
{
return
this
.
parseYield
(
)
}
var
ownDestructuringErrors
=
false
oldParenAssign
=
-
1
oldTrailingComma
=
-
1
;
if
(
refDestructuringErrors
)
{
oldParenAssign
=
refDestructuringErrors
.
parenthesizedAssign
;
oldTrailingComma
=
refDestructuringErrors
.
trailingComma
;
refDestructuringErrors
.
parenthesizedAssign
=
refDestructuringErrors
.
trailingComma
=
-
1
;
}
else
{
refDestructuringErrors
=
new
DestructuringErrors
;
ownDestructuringErrors
=
true
;
}
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
if
(
this
.
type
=
=
types
.
parenL
|
|
this
.
type
=
=
types
.
name
)
{
this
.
potentialArrowAt
=
this
.
start
;
}
var
left
=
this
.
parseMaybeConditional
(
noIn
refDestructuringErrors
)
;
if
(
afterLeftParse
)
{
left
=
afterLeftParse
.
call
(
this
left
startPos
startLoc
)
;
}
if
(
this
.
type
.
isAssign
)
{
this
.
checkPatternErrors
(
refDestructuringErrors
true
)
;
if
(
!
ownDestructuringErrors
)
{
DestructuringErrors
.
call
(
refDestructuringErrors
)
;
}
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
operator
=
this
.
value
;
node
.
left
=
this
.
type
=
=
=
types
.
eq
?
this
.
toAssignable
(
left
)
:
left
;
refDestructuringErrors
.
shorthandAssign
=
-
1
;
this
.
checkLVal
(
left
)
;
this
.
next
(
)
;
node
.
right
=
this
.
parseMaybeAssign
(
noIn
)
;
return
this
.
finishNode
(
node
"
AssignmentExpression
"
)
}
else
{
if
(
ownDestructuringErrors
)
{
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
}
}
if
(
oldParenAssign
>
-
1
)
{
refDestructuringErrors
.
parenthesizedAssign
=
oldParenAssign
;
}
if
(
oldTrailingComma
>
-
1
)
{
refDestructuringErrors
.
trailingComma
=
oldTrailingComma
;
}
return
left
}
;
pp
3
.
parseMaybeConditional
=
function
(
noIn
refDestructuringErrors
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseExprOps
(
noIn
refDestructuringErrors
)
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
)
{
return
expr
}
if
(
this
.
eat
(
types
.
question
)
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
test
=
expr
;
node
.
consequent
=
this
.
parseMaybeAssign
(
)
;
this
.
expect
(
types
.
colon
)
;
node
.
alternate
=
this
.
parseMaybeAssign
(
noIn
)
;
return
this
.
finishNode
(
node
"
ConditionalExpression
"
)
}
return
expr
}
;
pp
3
.
parseExprOps
=
function
(
noIn
refDestructuringErrors
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseMaybeUnary
(
refDestructuringErrors
false
)
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
)
{
return
expr
}
return
expr
.
start
=
=
startPos
&
&
expr
.
type
=
=
=
"
ArrowFunctionExpression
"
?
expr
:
this
.
parseExprOp
(
expr
startPos
startLoc
-
1
noIn
)
}
;
pp
3
.
parseExprOp
=
function
(
left
leftStartPos
leftStartLoc
minPrec
noIn
)
{
var
prec
=
this
.
type
.
binop
;
if
(
prec
!
=
null
&
&
(
!
noIn
|
|
this
.
type
!
=
=
types
.
_in
)
)
{
if
(
prec
>
minPrec
)
{
var
logical
=
this
.
type
=
=
=
types
.
logicalOR
|
|
this
.
type
=
=
=
types
.
logicalAND
;
var
op
=
this
.
value
;
this
.
next
(
)
;
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
right
=
this
.
parseExprOp
(
this
.
parseMaybeUnary
(
null
false
)
startPos
startLoc
prec
noIn
)
;
var
node
=
this
.
buildBinary
(
leftStartPos
leftStartLoc
left
right
op
logical
)
;
return
this
.
parseExprOp
(
node
leftStartPos
leftStartLoc
minPrec
noIn
)
}
}
return
left
}
;
pp
3
.
buildBinary
=
function
(
startPos
startLoc
left
right
op
logical
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
left
=
left
;
node
.
operator
=
op
;
node
.
right
=
right
;
return
this
.
finishNode
(
node
logical
?
"
LogicalExpression
"
:
"
BinaryExpression
"
)
}
;
pp
3
.
parseMaybeUnary
=
function
(
refDestructuringErrors
sawUnary
)
{
var
this
1
=
this
;
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
expr
;
if
(
this
.
inAsync
&
&
this
.
isContextual
(
"
await
"
)
)
{
expr
=
this
.
parseAwait
(
)
;
sawUnary
=
true
;
}
else
if
(
this
.
type
.
prefix
)
{
var
node
=
this
.
startNode
(
)
update
=
this
.
type
=
=
=
types
.
incDec
;
node
.
operator
=
this
.
value
;
node
.
prefix
=
true
;
this
.
next
(
)
;
node
.
argument
=
this
.
parseMaybeUnary
(
null
true
)
;
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
if
(
update
)
{
this
.
checkLVal
(
node
.
argument
)
;
}
else
if
(
this
.
strict
&
&
node
.
operator
=
=
=
"
delete
"
&
&
node
.
argument
.
type
=
=
=
"
Identifier
"
)
{
this
.
raiseRecoverable
(
node
.
start
"
Deleting
local
variable
in
strict
mode
"
)
;
}
else
{
sawUnary
=
true
;
}
expr
=
this
.
finishNode
(
node
update
?
"
UpdateExpression
"
:
"
UnaryExpression
"
)
;
}
else
{
expr
=
this
.
parseExprSubscripts
(
refDestructuringErrors
)
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
)
{
return
expr
}
while
(
this
.
type
.
postfix
&
&
!
this
.
canInsertSemicolon
(
)
)
{
var
node
1
=
this
1
.
startNodeAt
(
startPos
startLoc
)
;
node
1
.
operator
=
this
1
.
value
;
node
1
.
prefix
=
false
;
node
1
.
argument
=
expr
;
this
1
.
checkLVal
(
expr
)
;
this
1
.
next
(
)
;
expr
=
this
1
.
finishNode
(
node
1
"
UpdateExpression
"
)
;
}
}
if
(
!
sawUnary
&
&
this
.
eat
(
types
.
starstar
)
)
{
return
this
.
buildBinary
(
startPos
startLoc
expr
this
.
parseMaybeUnary
(
null
false
)
"
*
*
"
false
)
}
else
{
return
expr
}
}
;
pp
3
.
parseExprSubscripts
=
function
(
refDestructuringErrors
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseExprAtom
(
refDestructuringErrors
)
;
var
skipArrowSubscripts
=
expr
.
type
=
=
=
"
ArrowFunctionExpression
"
&
&
this
.
input
.
slice
(
this
.
lastTokStart
this
.
lastTokEnd
)
!
=
=
"
)
"
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
|
|
skipArrowSubscripts
)
{
return
expr
}
var
result
=
this
.
parseSubscripts
(
expr
startPos
startLoc
)
;
if
(
refDestructuringErrors
&
&
result
.
type
=
=
=
"
MemberExpression
"
)
{
if
(
refDestructuringErrors
.
parenthesizedAssign
>
=
result
.
start
)
{
refDestructuringErrors
.
parenthesizedAssign
=
-
1
;
}
if
(
refDestructuringErrors
.
parenthesizedBind
>
=
result
.
start
)
{
refDestructuringErrors
.
parenthesizedBind
=
-
1
;
}
}
return
result
}
;
pp
3
.
parseSubscripts
=
function
(
base
startPos
startLoc
noCalls
)
{
var
this
1
=
this
;
var
maybeAsyncArrow
=
this
.
options
.
ecmaVersion
>
=
8
&
&
base
.
type
=
=
=
"
Identifier
"
&
&
base
.
name
=
=
=
"
async
"
&
&
this
.
lastTokEnd
=
=
base
.
end
&
&
!
this
.
canInsertSemicolon
(
)
;
for
(
var
computed
=
(
void
0
)
;
;
)
{
if
(
(
computed
=
this
1
.
eat
(
types
.
bracketL
)
)
|
|
this
1
.
eat
(
types
.
dot
)
)
{
var
node
=
this
1
.
startNodeAt
(
startPos
startLoc
)
;
node
.
object
=
base
;
node
.
property
=
computed
?
this
1
.
parseExpression
(
)
:
this
1
.
parseIdent
(
true
)
;
node
.
computed
=
!
!
computed
;
if
(
computed
)
{
this
1
.
expect
(
types
.
bracketR
)
;
}
base
=
this
1
.
finishNode
(
node
"
MemberExpression
"
)
;
}
else
if
(
!
noCalls
&
&
this
1
.
eat
(
types
.
parenL
)
)
{
var
refDestructuringErrors
=
new
DestructuringErrors
oldYieldPos
=
this
1
.
yieldPos
oldAwaitPos
=
this
1
.
awaitPos
;
this
1
.
yieldPos
=
0
;
this
1
.
awaitPos
=
0
;
var
exprList
=
this
1
.
parseExprList
(
types
.
parenR
this
1
.
options
.
ecmaVersion
>
=
8
false
refDestructuringErrors
)
;
if
(
maybeAsyncArrow
&
&
!
this
1
.
canInsertSemicolon
(
)
&
&
this
1
.
eat
(
types
.
arrow
)
)
{
this
1
.
checkPatternErrors
(
refDestructuringErrors
false
)
;
this
1
.
checkYieldAwaitInDefaultParams
(
)
;
this
1
.
yieldPos
=
oldYieldPos
;
this
1
.
awaitPos
=
oldAwaitPos
;
return
this
1
.
parseArrowExpression
(
this
1
.
startNodeAt
(
startPos
startLoc
)
exprList
true
)
}
this
1
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
this
1
.
yieldPos
=
oldYieldPos
|
|
this
1
.
yieldPos
;
this
1
.
awaitPos
=
oldAwaitPos
|
|
this
1
.
awaitPos
;
var
node
1
=
this
1
.
startNodeAt
(
startPos
startLoc
)
;
node
1
.
callee
=
base
;
node
1
.
arguments
=
exprList
;
base
=
this
1
.
finishNode
(
node
1
"
CallExpression
"
)
;
}
else
if
(
this
1
.
type
=
=
=
types
.
backQuote
)
{
var
node
2
=
this
1
.
startNodeAt
(
startPos
startLoc
)
;
node
2
.
tag
=
base
;
node
2
.
quasi
=
this
1
.
parseTemplate
(
{
isTagged
:
true
}
)
;
base
=
this
1
.
finishNode
(
node
2
"
TaggedTemplateExpression
"
)
;
}
else
{
return
base
}
}
}
;
pp
3
.
parseExprAtom
=
function
(
refDestructuringErrors
)
{
var
node
canBeArrow
=
this
.
potentialArrowAt
=
=
this
.
start
;
switch
(
this
.
type
)
{
case
types
.
_super
:
if
(
!
this
.
inFunction
)
{
this
.
raise
(
this
.
start
"
'
super
'
outside
of
function
or
class
"
)
;
}
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
if
(
this
.
type
!
=
=
types
.
dot
&
&
this
.
type
!
=
=
types
.
bracketL
&
&
this
.
type
!
=
=
types
.
parenL
)
{
this
.
unexpected
(
)
;
}
return
this
.
finishNode
(
node
"
Super
"
)
case
types
.
_this
:
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
ThisExpression
"
)
case
types
.
name
:
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
id
=
this
.
parseIdent
(
this
.
type
!
=
=
types
.
name
)
;
if
(
this
.
options
.
ecmaVersion
>
=
8
&
&
id
.
name
=
=
=
"
async
"
&
&
!
this
.
canInsertSemicolon
(
)
&
&
this
.
eat
(
types
.
_function
)
)
{
return
this
.
parseFunction
(
this
.
startNodeAt
(
startPos
startLoc
)
false
false
true
)
}
if
(
canBeArrow
&
&
!
this
.
canInsertSemicolon
(
)
)
{
if
(
this
.
eat
(
types
.
arrow
)
)
{
return
this
.
parseArrowExpression
(
this
.
startNodeAt
(
startPos
startLoc
)
[
id
]
false
)
}
if
(
this
.
options
.
ecmaVersion
>
=
8
&
&
id
.
name
=
=
=
"
async
"
&
&
this
.
type
=
=
=
types
.
name
)
{
id
=
this
.
parseIdent
(
)
;
if
(
this
.
canInsertSemicolon
(
)
|
|
!
this
.
eat
(
types
.
arrow
)
)
{
this
.
unexpected
(
)
;
}
return
this
.
parseArrowExpression
(
this
.
startNodeAt
(
startPos
startLoc
)
[
id
]
true
)
}
}
return
id
case
types
.
regexp
:
var
value
=
this
.
value
;
node
=
this
.
parseLiteral
(
value
.
value
)
;
node
.
regex
=
{
pattern
:
value
.
pattern
flags
:
value
.
flags
}
;
return
node
case
types
.
num
:
case
types
.
string
:
return
this
.
parseLiteral
(
this
.
value
)
case
types
.
_null
:
case
types
.
_true
:
case
types
.
_false
:
node
=
this
.
startNode
(
)
;
node
.
value
=
this
.
type
=
=
=
types
.
_null
?
null
:
this
.
type
=
=
=
types
.
_true
;
node
.
raw
=
this
.
type
.
keyword
;
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
Literal
"
)
case
types
.
parenL
:
var
start
=
this
.
start
expr
=
this
.
parseParenAndDistinguishExpression
(
canBeArrow
)
;
if
(
refDestructuringErrors
)
{
if
(
refDestructuringErrors
.
parenthesizedAssign
<
0
&
&
!
this
.
isSimpleAssignTarget
(
expr
)
)
{
refDestructuringErrors
.
parenthesizedAssign
=
start
;
}
if
(
refDestructuringErrors
.
parenthesizedBind
<
0
)
{
refDestructuringErrors
.
parenthesizedBind
=
start
;
}
}
return
expr
case
types
.
bracketL
:
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
elements
=
this
.
parseExprList
(
types
.
bracketR
true
true
refDestructuringErrors
)
;
return
this
.
finishNode
(
node
"
ArrayExpression
"
)
case
types
.
braceL
:
return
this
.
parseObj
(
false
refDestructuringErrors
)
case
types
.
_function
:
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
return
this
.
parseFunction
(
node
false
)
case
types
.
_class
:
return
this
.
parseClass
(
this
.
startNode
(
)
false
)
case
types
.
_new
:
return
this
.
parseNew
(
)
case
types
.
backQuote
:
return
this
.
parseTemplate
(
)
default
:
this
.
unexpected
(
)
;
}
}
;
pp
3
.
parseLiteral
=
function
(
value
)
{
var
node
=
this
.
startNode
(
)
;
node
.
value
=
value
;
node
.
raw
=
this
.
input
.
slice
(
this
.
start
this
.
end
)
;
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
Literal
"
)
}
;
pp
3
.
parseParenExpression
=
function
(
)
{
this
.
expect
(
types
.
parenL
)
;
var
val
=
this
.
parseExpression
(
)
;
this
.
expect
(
types
.
parenR
)
;
return
val
}
;
pp
3
.
parseParenAndDistinguishExpression
=
function
(
canBeArrow
)
{
var
this
1
=
this
;
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
val
allowTrailingComma
=
this
.
options
.
ecmaVersion
>
=
8
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
this
.
next
(
)
;
var
innerStartPos
=
this
.
start
innerStartLoc
=
this
.
startLoc
;
var
exprList
=
[
]
first
=
true
lastIsComma
=
false
;
var
refDestructuringErrors
=
new
DestructuringErrors
oldYieldPos
=
this
.
yieldPos
oldAwaitPos
=
this
.
awaitPos
spreadStart
innerParenStart
;
this
.
yieldPos
=
0
;
this
.
awaitPos
=
0
;
while
(
this
.
type
!
=
=
types
.
parenR
)
{
first
?
first
=
false
:
this
1
.
expect
(
types
.
comma
)
;
if
(
allowTrailingComma
&
&
this
1
.
afterTrailingComma
(
types
.
parenR
true
)
)
{
lastIsComma
=
true
;
break
}
else
if
(
this
1
.
type
=
=
=
types
.
ellipsis
)
{
spreadStart
=
this
1
.
start
;
exprList
.
push
(
this
1
.
parseParenItem
(
this
1
.
parseRestBinding
(
)
)
)
;
if
(
this
1
.
type
=
=
=
types
.
comma
)
{
this
1
.
raise
(
this
1
.
start
"
Comma
is
not
permitted
after
the
rest
element
"
)
;
}
break
}
else
{
if
(
this
1
.
type
=
=
=
types
.
parenL
&
&
!
innerParenStart
)
{
innerParenStart
=
this
1
.
start
;
}
exprList
.
push
(
this
1
.
parseMaybeAssign
(
false
refDestructuringErrors
this
1
.
parseParenItem
)
)
;
}
}
var
innerEndPos
=
this
.
start
innerEndLoc
=
this
.
startLoc
;
this
.
expect
(
types
.
parenR
)
;
if
(
canBeArrow
&
&
!
this
.
canInsertSemicolon
(
)
&
&
this
.
eat
(
types
.
arrow
)
)
{
this
.
checkPatternErrors
(
refDestructuringErrors
false
)
;
this
.
checkYieldAwaitInDefaultParams
(
)
;
if
(
innerParenStart
)
{
this
.
unexpected
(
innerParenStart
)
;
}
this
.
yieldPos
=
oldYieldPos
;
this
.
awaitPos
=
oldAwaitPos
;
return
this
.
parseParenArrowList
(
startPos
startLoc
exprList
)
}
if
(
!
exprList
.
length
|
|
lastIsComma
)
{
this
.
unexpected
(
this
.
lastTokStart
)
;
}
if
(
spreadStart
)
{
this
.
unexpected
(
spreadStart
)
;
}
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
this
.
yieldPos
=
oldYieldPos
|
|
this
.
yieldPos
;
this
.
awaitPos
=
oldAwaitPos
|
|
this
.
awaitPos
;
if
(
exprList
.
length
>
1
)
{
val
=
this
.
startNodeAt
(
innerStartPos
innerStartLoc
)
;
val
.
expressions
=
exprList
;
this
.
finishNodeAt
(
val
"
SequenceExpression
"
innerEndPos
innerEndLoc
)
;
}
else
{
val
=
exprList
[
0
]
;
}
}
else
{
val
=
this
.
parseParenExpression
(
)
;
}
if
(
this
.
options
.
preserveParens
)
{
var
par
=
this
.
startNodeAt
(
startPos
startLoc
)
;
par
.
expression
=
val
;
return
this
.
finishNode
(
par
"
ParenthesizedExpression
"
)
}
else
{
return
val
}
}
;
pp
3
.
parseParenItem
=
function
(
item
)
{
return
item
}
;
pp
3
.
parseParenArrowList
=
function
(
startPos
startLoc
exprList
)
{
return
this
.
parseArrowExpression
(
this
.
startNodeAt
(
startPos
startLoc
)
exprList
)
}
;
var
empty
1
=
[
]
;
pp
3
.
parseNew
=
function
(
)
{
var
node
=
this
.
startNode
(
)
;
var
meta
=
this
.
parseIdent
(
true
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
eat
(
types
.
dot
)
)
{
node
.
meta
=
meta
;
node
.
property
=
this
.
parseIdent
(
true
)
;
if
(
node
.
property
.
name
!
=
=
"
target
"
)
{
this
.
raiseRecoverable
(
node
.
property
.
start
"
The
only
valid
meta
property
for
new
is
new
.
target
"
)
;
}
if
(
!
this
.
inFunction
)
{
this
.
raiseRecoverable
(
node
.
start
"
new
.
target
can
only
be
used
in
functions
"
)
;
}
return
this
.
finishNode
(
node
"
MetaProperty
"
)
}
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
node
.
callee
=
this
.
parseSubscripts
(
this
.
parseExprAtom
(
)
startPos
startLoc
true
)
;
if
(
this
.
eat
(
types
.
parenL
)
)
{
node
.
arguments
=
this
.
parseExprList
(
types
.
parenR
this
.
options
.
ecmaVersion
>
=
8
false
)
;
}
else
{
node
.
arguments
=
empty
1
;
}
return
this
.
finishNode
(
node
"
NewExpression
"
)
}
;
pp
3
.
parseTemplateElement
=
function
(
ref
)
{
var
isTagged
=
ref
.
isTagged
;
var
elem
=
this
.
startNode
(
)
;
if
(
this
.
type
=
=
=
types
.
invalidTemplate
)
{
if
(
!
isTagged
)
{
this
.
raiseRecoverable
(
this
.
start
"
Bad
escape
sequence
in
untagged
template
literal
"
)
;
}
elem
.
value
=
{
raw
:
this
.
value
cooked
:
null
}
;
}
else
{
elem
.
value
=
{
raw
:
this
.
input
.
slice
(
this
.
start
this
.
end
)
.
replace
(
/
\
r
\
n
?
/
g
"
\
n
"
)
cooked
:
this
.
value
}
;
}
this
.
next
(
)
;
elem
.
tail
=
this
.
type
=
=
=
types
.
backQuote
;
return
this
.
finishNode
(
elem
"
TemplateElement
"
)
}
;
pp
3
.
parseTemplate
=
function
(
ref
)
{
var
this
1
=
this
;
if
(
ref
=
=
=
void
0
)
ref
=
{
}
;
var
isTagged
=
ref
.
isTagged
;
if
(
isTagged
=
=
=
void
0
)
isTagged
=
false
;
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
expressions
=
[
]
;
var
curElt
=
this
.
parseTemplateElement
(
{
isTagged
:
isTagged
}
)
;
node
.
quasis
=
[
curElt
]
;
while
(
!
curElt
.
tail
)
{
this
1
.
expect
(
types
.
dollarBraceL
)
;
node
.
expressions
.
push
(
this
1
.
parseExpression
(
)
)
;
this
1
.
expect
(
types
.
braceR
)
;
node
.
quasis
.
push
(
curElt
=
this
1
.
parseTemplateElement
(
{
isTagged
:
isTagged
}
)
)
;
}
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
TemplateLiteral
"
)
}
;
pp
3
.
isAsyncProp
=
function
(
prop
)
{
return
!
prop
.
computed
&
&
prop
.
key
.
type
=
=
=
"
Identifier
"
&
&
prop
.
key
.
name
=
=
=
"
async
"
&
&
(
this
.
type
=
=
=
types
.
name
|
|
this
.
type
=
=
=
types
.
num
|
|
this
.
type
=
=
=
types
.
string
|
|
this
.
type
=
=
=
types
.
bracketL
|
|
this
.
type
.
keyword
)
&
&
!
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
start
)
)
}
;
pp
3
.
parseObj
=
function
(
isPattern
refDestructuringErrors
)
{
var
this
1
=
this
;
var
node
=
this
.
startNode
(
)
first
=
true
propHash
=
{
}
;
node
.
properties
=
[
]
;
this
.
next
(
)
;
while
(
!
this
.
eat
(
types
.
braceR
)
)
{
if
(
!
first
)
{
this
1
.
expect
(
types
.
comma
)
;
if
(
this
1
.
afterTrailingComma
(
types
.
braceR
)
)
{
break
}
}
else
{
first
=
false
;
}
var
prop
=
this
1
.
parseProperty
(
isPattern
refDestructuringErrors
)
;
this
1
.
checkPropClash
(
prop
propHash
)
;
node
.
properties
.
push
(
prop
)
;
}
return
this
.
finishNode
(
node
isPattern
?
"
ObjectPattern
"
:
"
ObjectExpression
"
)
}
;
pp
3
.
parseProperty
=
function
(
isPattern
refDestructuringErrors
)
{
var
prop
=
this
.
startNode
(
)
isGenerator
isAsync
startPos
startLoc
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
prop
.
method
=
false
;
prop
.
shorthand
=
false
;
if
(
isPattern
|
|
refDestructuringErrors
)
{
startPos
=
this
.
start
;
startLoc
=
this
.
startLoc
;
}
if
(
!
isPattern
)
{
isGenerator
=
this
.
eat
(
types
.
star
)
;
}
}
this
.
parsePropertyName
(
prop
)
;
if
(
!
isPattern
&
&
this
.
options
.
ecmaVersion
>
=
8
&
&
!
isGenerator
&
&
this
.
isAsyncProp
(
prop
)
)
{
isAsync
=
true
;
this
.
parsePropertyName
(
prop
refDestructuringErrors
)
;
}
else
{
isAsync
=
false
;
}
this
.
parsePropertyValue
(
prop
isPattern
isGenerator
isAsync
startPos
startLoc
refDestructuringErrors
)
;
return
this
.
finishNode
(
prop
"
Property
"
)
}
;
pp
3
.
parsePropertyValue
=
function
(
prop
isPattern
isGenerator
isAsync
startPos
startLoc
refDestructuringErrors
)
{
if
(
(
isGenerator
|
|
isAsync
)
&
&
this
.
type
=
=
=
types
.
colon
)
{
this
.
unexpected
(
)
;
}
if
(
this
.
eat
(
types
.
colon
)
)
{
prop
.
value
=
isPattern
?
this
.
parseMaybeDefault
(
this
.
start
this
.
startLoc
)
:
this
.
parseMaybeAssign
(
false
refDestructuringErrors
)
;
prop
.
kind
=
"
init
"
;
}
else
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
type
=
=
=
types
.
parenL
)
{
if
(
isPattern
)
{
this
.
unexpected
(
)
;
}
prop
.
kind
=
"
init
"
;
prop
.
method
=
true
;
prop
.
value
=
this
.
parseMethod
(
isGenerator
isAsync
)
;
}
else
if
(
!
isPattern
&
&
this
.
options
.
ecmaVersion
>
=
5
&
&
!
prop
.
computed
&
&
prop
.
key
.
type
=
=
=
"
Identifier
"
&
&
(
prop
.
key
.
name
=
=
=
"
get
"
|
|
prop
.
key
.
name
=
=
=
"
set
"
)
&
&
(
this
.
type
!
=
types
.
comma
&
&
this
.
type
!
=
types
.
braceR
)
)
{
if
(
isGenerator
|
|
isAsync
)
{
this
.
unexpected
(
)
;
}
prop
.
kind
=
prop
.
key
.
name
;
this
.
parsePropertyName
(
prop
)
;
prop
.
value
=
this
.
parseMethod
(
false
)
;
var
paramCount
=
prop
.
kind
=
=
=
"
get
"
?
0
:
1
;
if
(
prop
.
value
.
params
.
length
!
=
=
paramCount
)
{
var
start
=
prop
.
value
.
start
;
if
(
prop
.
kind
=
=
=
"
get
"
)
{
this
.
raiseRecoverable
(
start
"
getter
should
have
no
params
"
)
;
}
else
{
this
.
raiseRecoverable
(
start
"
setter
should
have
exactly
one
param
"
)
;
}
}
else
{
if
(
prop
.
kind
=
=
=
"
set
"
&
&
prop
.
value
.
params
[
0
]
.
type
=
=
=
"
RestElement
"
)
{
this
.
raiseRecoverable
(
prop
.
value
.
params
[
0
]
.
start
"
Setter
cannot
use
rest
params
"
)
;
}
}
}
else
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
!
prop
.
computed
&
&
prop
.
key
.
type
=
=
=
"
Identifier
"
)
{
this
.
checkUnreserved
(
prop
.
key
)
;
prop
.
kind
=
"
init
"
;
if
(
isPattern
)
{
prop
.
value
=
this
.
parseMaybeDefault
(
startPos
startLoc
prop
.
key
)
;
}
else
if
(
this
.
type
=
=
=
types
.
eq
&
&
refDestructuringErrors
)
{
if
(
refDestructuringErrors
.
shorthandAssign
<
0
)
{
refDestructuringErrors
.
shorthandAssign
=
this
.
start
;
}
prop
.
value
=
this
.
parseMaybeDefault
(
startPos
startLoc
prop
.
key
)
;
}
else
{
prop
.
value
=
prop
.
key
;
}
prop
.
shorthand
=
true
;
}
else
{
this
.
unexpected
(
)
;
}
}
;
pp
3
.
parsePropertyName
=
function
(
prop
)
{
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
if
(
this
.
eat
(
types
.
bracketL
)
)
{
prop
.
computed
=
true
;
prop
.
key
=
this
.
parseMaybeAssign
(
)
;
this
.
expect
(
types
.
bracketR
)
;
return
prop
.
key
}
else
{
prop
.
computed
=
false
;
}
}
return
prop
.
key
=
this
.
type
=
=
=
types
.
num
|
|
this
.
type
=
=
=
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
parseIdent
(
true
)
}
;
pp
3
.
initFunction
=
function
(
node
)
{
node
.
id
=
null
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
node
.
generator
=
false
;
node
.
expression
=
false
;
}
if
(
this
.
options
.
ecmaVersion
>
=
8
)
{
node
.
async
=
false
;
}
}
;
pp
3
.
parseMethod
=
function
(
isGenerator
isAsync
)
{
var
node
=
this
.
startNode
(
)
oldInGen
=
this
.
inGenerator
oldInAsync
=
this
.
inAsync
oldYieldPos
=
this
.
yieldPos
oldAwaitPos
=
this
.
awaitPos
oldInFunc
=
this
.
inFunction
;
this
.
initFunction
(
node
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
node
.
generator
=
isGenerator
;
}
if
(
this
.
options
.
ecmaVersion
>
=
8
)
{
node
.
async
=
!
!
isAsync
;
}
this
.
inGenerator
=
node
.
generator
;
this
.
inAsync
=
node
.
async
;
this
.
yieldPos
=
0
;
this
.
awaitPos
=
0
;
this
.
inFunction
=
true
;
this
.
enterFunctionScope
(
)
;
this
.
expect
(
types
.
parenL
)
;
node
.
params
=
this
.
parseBindingList
(
types
.
parenR
false
this
.
options
.
ecmaVersion
>
=
8
)
;
this
.
checkYieldAwaitInDefaultParams
(
)
;
this
.
parseFunctionBody
(
node
false
)
;
this
.
inGenerator
=
oldInGen
;
this
.
inAsync
=
oldInAsync
;
this
.
yieldPos
=
oldYieldPos
;
this
.
awaitPos
=
oldAwaitPos
;
this
.
inFunction
=
oldInFunc
;
return
this
.
finishNode
(
node
"
FunctionExpression
"
)
}
;
pp
3
.
parseArrowExpression
=
function
(
node
params
isAsync
)
{
var
oldInGen
=
this
.
inGenerator
oldInAsync
=
this
.
inAsync
oldYieldPos
=
this
.
yieldPos
oldAwaitPos
=
this
.
awaitPos
oldInFunc
=
this
.
inFunction
;
this
.
enterFunctionScope
(
)
;
this
.
initFunction
(
node
)
;
if
(
this
.
options
.
ecmaVersion
>
=
8
)
{
node
.
async
=
!
!
isAsync
;
}
this
.
inGenerator
=
false
;
this
.
inAsync
=
node
.
async
;
this
.
yieldPos
=
0
;
this
.
awaitPos
=
0
;
this
.
inFunction
=
true
;
node
.
params
=
this
.
toAssignableList
(
params
true
)
;
this
.
parseFunctionBody
(
node
true
)
;
this
.
inGenerator
=
oldInGen
;
this
.
inAsync
=
oldInAsync
;
this
.
yieldPos
=
oldYieldPos
;
this
.
awaitPos
=
oldAwaitPos
;
this
.
inFunction
=
oldInFunc
;
return
this
.
finishNode
(
node
"
ArrowFunctionExpression
"
)
}
;
pp
3
.
parseFunctionBody
=
function
(
node
isArrowFunction
)
{
var
isExpression
=
isArrowFunction
&
&
this
.
type
!
=
=
types
.
braceL
;
var
oldStrict
=
this
.
strict
useStrict
=
false
;
if
(
isExpression
)
{
node
.
body
=
this
.
parseMaybeAssign
(
)
;
node
.
expression
=
true
;
this
.
checkParams
(
node
false
)
;
}
else
{
var
nonSimple
=
this
.
options
.
ecmaVersion
>
=
7
&
&
!
this
.
isSimpleParamList
(
node
.
params
)
;
if
(
!
oldStrict
|
|
nonSimple
)
{
useStrict
=
this
.
strictDirective
(
this
.
end
)
;
if
(
useStrict
&
&
nonSimple
)
{
this
.
raiseRecoverable
(
node
.
start
"
Illegal
'
use
strict
'
directive
in
function
with
non
-
simple
parameter
list
"
)
;
}
}
var
oldLabels
=
this
.
labels
;
this
.
labels
=
[
]
;
if
(
useStrict
)
{
this
.
strict
=
true
;
}
this
.
checkParams
(
node
!
oldStrict
&
&
!
useStrict
&
&
!
isArrowFunction
&
&
this
.
isSimpleParamList
(
node
.
params
)
)
;
node
.
body
=
this
.
parseBlock
(
false
)
;
node
.
expression
=
false
;
this
.
adaptDirectivePrologue
(
node
.
body
.
body
)
;
this
.
labels
=
oldLabels
;
}
this
.
exitFunctionScope
(
)
;
if
(
this
.
strict
&
&
node
.
id
)
{
this
.
checkLVal
(
node
.
id
"
none
"
)
;
}
this
.
strict
=
oldStrict
;
}
;
pp
3
.
isSimpleParamList
=
function
(
params
)
{
for
(
var
i
=
0
list
=
params
;
i
<
list
.
length
;
i
+
=
1
)
{
var
param
=
list
[
i
]
;
if
(
param
.
type
!
=
=
"
Identifier
"
)
{
return
false
}
}
return
true
}
;
pp
3
.
checkParams
=
function
(
node
allowDuplicates
)
{
var
this
1
=
this
;
var
nameHash
=
{
}
;
for
(
var
i
=
0
list
=
node
.
params
;
i
<
list
.
length
;
i
+
=
1
)
{
var
param
=
list
[
i
]
;
this
1
.
checkLVal
(
param
"
var
"
allowDuplicates
?
null
:
nameHash
)
;
}
}
;
pp
3
.
parseExprList
=
function
(
close
allowTrailingComma
allowEmpty
refDestructuringErrors
)
{
var
this
1
=
this
;
var
elts
=
[
]
first
=
true
;
while
(
!
this
.
eat
(
close
)
)
{
if
(
!
first
)
{
this
1
.
expect
(
types
.
comma
)
;
if
(
allowTrailingComma
&
&
this
1
.
afterTrailingComma
(
close
)
)
{
break
}
}
else
{
first
=
false
;
}
var
elt
=
(
void
0
)
;
if
(
allowEmpty
&
&
this
1
.
type
=
=
=
types
.
comma
)
{
elt
=
null
;
}
else
if
(
this
1
.
type
=
=
=
types
.
ellipsis
)
{
elt
=
this
1
.
parseSpread
(
refDestructuringErrors
)
;
if
(
refDestructuringErrors
&
&
this
1
.
type
=
=
=
types
.
comma
&
&
refDestructuringErrors
.
trailingComma
<
0
)
{
refDestructuringErrors
.
trailingComma
=
this
1
.
start
;
}
}
else
{
elt
=
this
1
.
parseMaybeAssign
(
false
refDestructuringErrors
)
;
}
elts
.
push
(
elt
)
;
}
return
elts
}
;
pp
3
.
checkUnreserved
=
function
(
ref
)
{
var
start
=
ref
.
start
;
var
end
=
ref
.
end
;
var
name
=
ref
.
name
;
if
(
this
.
inGenerator
&
&
name
=
=
=
"
yield
"
)
{
this
.
raiseRecoverable
(
start
"
Can
not
use
'
yield
'
as
identifier
inside
a
generator
"
)
;
}
if
(
this
.
inAsync
&
&
name
=
=
=
"
await
"
)
{
this
.
raiseRecoverable
(
start
"
Can
not
use
'
await
'
as
identifier
inside
an
async
function
"
)
;
}
if
(
this
.
isKeyword
(
name
)
)
{
this
.
raise
(
start
(
"
Unexpected
keyword
'
"
+
name
+
"
'
"
)
)
;
}
if
(
this
.
options
.
ecmaVersion
<
6
&
&
this
.
input
.
slice
(
start
end
)
.
indexOf
(
"
\
\
"
)
!
=
-
1
)
{
return
}
var
re
=
this
.
strict
?
this
.
reservedWordsStrict
:
this
.
reservedWords
;
if
(
re
.
test
(
name
)
)
{
this
.
raiseRecoverable
(
start
(
"
The
keyword
'
"
+
name
+
"
'
is
reserved
"
)
)
;
}
}
;
pp
3
.
parseIdent
=
function
(
liberal
isBinding
)
{
var
node
=
this
.
startNode
(
)
;
if
(
liberal
&
&
this
.
options
.
allowReserved
=
=
"
never
"
)
{
liberal
=
false
;
}
if
(
this
.
type
=
=
=
types
.
name
)
{
node
.
name
=
this
.
value
;
}
else
if
(
this
.
type
.
keyword
)
{
node
.
name
=
this
.
type
.
keyword
;
if
(
(
node
.
name
=
=
=
"
class
"
|
|
node
.
name
=
=
=
"
function
"
)
&
&
(
this
.
lastTokEnd
!
=
=
this
.
lastTokStart
+
1
|
|
this
.
input
.
charCodeAt
(
this
.
lastTokStart
)
!
=
=
46
)
)
{
this
.
context
.
pop
(
)
;
}
}
else
{
this
.
unexpected
(
)
;
}
this
.
next
(
)
;
this
.
finishNode
(
node
"
Identifier
"
)
;
if
(
!
liberal
)
{
this
.
checkUnreserved
(
node
)
;
}
return
node
}
;
pp
3
.
parseYield
=
function
(
)
{
if
(
!
this
.
yieldPos
)
{
this
.
yieldPos
=
this
.
start
;
}
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
if
(
this
.
type
=
=
types
.
semi
|
|
this
.
canInsertSemicolon
(
)
|
|
(
this
.
type
!
=
types
.
star
&
&
!
this
.
type
.
startsExpr
)
)
{
node
.
delegate
=
false
;
node
.
argument
=
null
;
}
else
{
node
.
delegate
=
this
.
eat
(
types
.
star
)
;
node
.
argument
=
this
.
parseMaybeAssign
(
)
;
}
return
this
.
finishNode
(
node
"
YieldExpression
"
)
}
;
pp
3
.
parseAwait
=
function
(
)
{
if
(
!
this
.
awaitPos
)
{
this
.
awaitPos
=
this
.
start
;
}
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
argument
=
this
.
parseMaybeUnary
(
null
true
)
;
return
this
.
finishNode
(
node
"
AwaitExpression
"
)
}
;
var
pp
4
=
Parser
.
prototype
;
pp
4
.
raise
=
function
(
pos
message
)
{
var
loc
=
getLineInfo
(
this
.
input
pos
)
;
message
+
=
"
(
"
+
loc
.
line
+
"
:
"
+
loc
.
column
+
"
)
"
;
var
err
=
new
SyntaxError
(
message
)
;
err
.
pos
=
pos
;
err
.
loc
=
loc
;
err
.
raisedAt
=
this
.
pos
;
throw
err
}
;
pp
4
.
raiseRecoverable
=
pp
4
.
raise
;
pp
4
.
curPosition
=
function
(
)
{
if
(
this
.
options
.
locations
)
{
return
new
Position
(
this
.
curLine
this
.
pos
-
this
.
lineStart
)
}
}
;
var
pp
5
=
Parser
.
prototype
;
var
assign
=
Object
.
assign
|
|
function
(
target
)
{
var
sources
=
[
]
len
=
arguments
.
length
-
1
;
while
(
len
-
-
>
0
)
sources
[
len
]
=
arguments
[
len
+
1
]
;
for
(
var
i
=
0
list
=
sources
;
i
<
list
.
length
;
i
+
=
1
)
{
var
source
=
list
[
i
]
;
for
(
var
key
in
source
)
{
if
(
has
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
}
;
pp
5
.
enterFunctionScope
=
function
(
)
{
this
.
scopeStack
.
push
(
{
var
:
{
}
lexical
:
{
}
childVar
:
{
}
parentLexical
:
{
}
}
)
;
}
;
pp
5
.
exitFunctionScope
=
function
(
)
{
this
.
scopeStack
.
pop
(
)
;
}
;
pp
5
.
enterLexicalScope
=
function
(
)
{
var
parentScope
=
this
.
scopeStack
[
this
.
scopeStack
.
length
-
1
]
;
var
childScope
=
{
var
:
{
}
lexical
:
{
}
childVar
:
{
}
parentLexical
:
{
}
}
;
this
.
scopeStack
.
push
(
childScope
)
;
assign
(
childScope
.
parentLexical
parentScope
.
lexical
parentScope
.
parentLexical
)
;
}
;
pp
5
.
exitLexicalScope
=
function
(
)
{
var
childScope
=
this
.
scopeStack
.
pop
(
)
;
var
parentScope
=
this
.
scopeStack
[
this
.
scopeStack
.
length
-
1
]
;
assign
(
parentScope
.
childVar
childScope
.
var
childScope
.
childVar
)
;
}
;
pp
5
.
canDeclareVarName
=
function
(
name
)
{
var
currentScope
=
this
.
scopeStack
[
this
.
scopeStack
.
length
-
1
]
;
return
!
has
(
currentScope
.
lexical
name
)
&
&
!
has
(
currentScope
.
parentLexical
name
)
}
;
pp
5
.
canDeclareLexicalName
=
function
(
name
)
{
var
currentScope
=
this
.
scopeStack
[
this
.
scopeStack
.
length
-
1
]
;
return
!
has
(
currentScope
.
lexical
name
)
&
&
!
has
(
currentScope
.
var
name
)
&
&
!
has
(
currentScope
.
childVar
name
)
}
;
pp
5
.
declareVarName
=
function
(
name
)
{
this
.
scopeStack
[
this
.
scopeStack
.
length
-
1
]
.
var
[
name
]
=
true
;
}
;
pp
5
.
declareLexicalName
=
function
(
name
)
{
this
.
scopeStack
[
this
.
scopeStack
.
length
-
1
]
.
lexical
[
name
]
=
true
;
}
;
var
Node
=
function
Node
(
parser
pos
loc
)
{
this
.
type
=
"
"
;
this
.
start
=
pos
;
this
.
end
=
0
;
if
(
parser
.
options
.
locations
)
{
this
.
loc
=
new
SourceLocation
(
parser
loc
)
;
}
if
(
parser
.
options
.
directSourceFile
)
{
this
.
sourceFile
=
parser
.
options
.
directSourceFile
;
}
if
(
parser
.
options
.
ranges
)
{
this
.
range
=
[
pos
0
]
;
}
}
;
var
pp
6
=
Parser
.
prototype
;
pp
6
.
startNode
=
function
(
)
{
return
new
Node
(
this
this
.
start
this
.
startLoc
)
}
;
pp
6
.
startNodeAt
=
function
(
pos
loc
)
{
return
new
Node
(
this
pos
loc
)
}
;
function
finishNodeAt
(
node
type
pos
loc
)
{
node
.
type
=
type
;
node
.
end
=
pos
;
if
(
this
.
options
.
locations
)
{
node
.
loc
.
end
=
loc
;
}
if
(
this
.
options
.
ranges
)
{
node
.
range
[
1
]
=
pos
;
}
return
node
}
pp
6
.
finishNode
=
function
(
node
type
)
{
return
finishNodeAt
.
call
(
this
node
type
this
.
lastTokEnd
this
.
lastTokEndLoc
)
}
;
pp
6
.
finishNodeAt
=
function
(
node
type
pos
loc
)
{
return
finishNodeAt
.
call
(
this
node
type
pos
loc
)
}
;
var
TokContext
=
function
TokContext
(
token
isExpr
preserveSpace
override
generator
)
{
this
.
token
=
token
;
this
.
isExpr
=
!
!
isExpr
;
this
.
preserveSpace
=
!
!
preserveSpace
;
this
.
override
=
override
;
this
.
generator
=
!
!
generator
;
}
;
var
types
1
=
{
b_stat
:
new
TokContext
(
"
{
"
false
)
b_expr
:
new
TokContext
(
"
{
"
true
)
b_tmpl
:
new
TokContext
(
"
{
"
false
)
p_stat
:
new
TokContext
(
"
(
"
false
)
p_expr
:
new
TokContext
(
"
(
"
true
)
q_tmpl
:
new
TokContext
(
"
"
true
true
function
(
p
)
{
return
p
.
tryReadTemplateToken
(
)
;
}
)
f_stat
:
new
TokContext
(
"
function
"
false
)
f_expr
:
new
TokContext
(
"
function
"
true
)
f_expr_gen
:
new
TokContext
(
"
function
"
true
false
null
true
)
f_gen
:
new
TokContext
(
"
function
"
false
false
null
true
)
}
;
var
pp
7
=
Parser
.
prototype
;
pp
7
.
initialContext
=
function
(
)
{
return
[
types
1
.
b_stat
]
}
;
pp
7
.
braceIsBlock
=
function
(
prevType
)
{
var
parent
=
this
.
curContext
(
)
;
if
(
parent
=
=
=
types
1
.
f_expr
|
|
parent
=
=
=
types
1
.
f_stat
)
{
return
true
}
if
(
prevType
=
=
=
types
.
colon
&
&
(
parent
=
=
=
types
1
.
b_stat
|
|
parent
=
=
=
types
1
.
b_expr
)
)
{
return
!
parent
.
isExpr
}
if
(
prevType
=
=
=
types
.
_return
|
|
prevType
=
=
types
.
name
&
&
this
.
exprAllowed
)
{
return
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
start
)
)
}
if
(
prevType
=
=
=
types
.
_else
|
|
prevType
=
=
=
types
.
semi
|
|
prevType
=
=
=
types
.
eof
|
|
prevType
=
=
=
types
.
parenR
|
|
prevType
=
=
types
.
arrow
)
{
return
true
}
if
(
prevType
=
=
types
.
braceL
)
{
return
parent
=
=
=
types
1
.
b_stat
}
if
(
prevType
=
=
types
.
_var
|
|
prevType
=
=
types
.
name
)
{
return
false
}
return
!
this
.
exprAllowed
}
;
pp
7
.
inGeneratorContext
=
function
(
)
{
var
this
1
=
this
;
for
(
var
i
=
this
.
context
.
length
-
1
;
i
>
=
1
;
i
-
-
)
{
var
context
=
this
1
.
context
[
i
]
;
if
(
context
.
token
=
=
=
"
function
"
)
{
return
context
.
generator
}
}
return
false
}
;
pp
7
.
updateContext
=
function
(
prevType
)
{
var
update
type
=
this
.
type
;
if
(
type
.
keyword
&
&
prevType
=
=
types
.
dot
)
{
this
.
exprAllowed
=
false
;
}
else
if
(
update
=
type
.
updateContext
)
{
update
.
call
(
this
prevType
)
;
}
else
{
this
.
exprAllowed
=
type
.
beforeExpr
;
}
}
;
types
.
parenR
.
updateContext
=
types
.
braceR
.
updateContext
=
function
(
)
{
if
(
this
.
context
.
length
=
=
1
)
{
this
.
exprAllowed
=
true
;
return
}
var
out
=
this
.
context
.
pop
(
)
;
if
(
out
=
=
=
types
1
.
b_stat
&
&
this
.
curContext
(
)
.
token
=
=
=
"
function
"
)
{
out
=
this
.
context
.
pop
(
)
;
}
this
.
exprAllowed
=
!
out
.
isExpr
;
}
;
types
.
braceL
.
updateContext
=
function
(
prevType
)
{
this
.
context
.
push
(
this
.
braceIsBlock
(
prevType
)
?
types
1
.
b_stat
:
types
1
.
b_expr
)
;
this
.
exprAllowed
=
true
;
}
;
types
.
dollarBraceL
.
updateContext
=
function
(
)
{
this
.
context
.
push
(
types
1
.
b_tmpl
)
;
this
.
exprAllowed
=
true
;
}
;
types
.
parenL
.
updateContext
=
function
(
prevType
)
{
var
statementParens
=
prevType
=
=
=
types
.
_if
|
|
prevType
=
=
=
types
.
_for
|
|
prevType
=
=
=
types
.
_with
|
|
prevType
=
=
=
types
.
_while
;
this
.
context
.
push
(
statementParens
?
types
1
.
p_stat
:
types
1
.
p_expr
)
;
this
.
exprAllowed
=
true
;
}
;
types
.
incDec
.
updateContext
=
function
(
)
{
}
;
types
.
_function
.
updateContext
=
types
.
_class
.
updateContext
=
function
(
prevType
)
{
if
(
prevType
.
beforeExpr
&
&
prevType
!
=
=
types
.
semi
&
&
prevType
!
=
=
types
.
_else
&
&
!
(
(
prevType
=
=
=
types
.
colon
|
|
prevType
=
=
=
types
.
braceL
)
&
&
this
.
curContext
(
)
=
=
=
types
1
.
b_stat
)
)
{
this
.
context
.
push
(
types
1
.
f_expr
)
;
}
else
{
this
.
context
.
push
(
types
1
.
f_stat
)
;
}
this
.
exprAllowed
=
false
;
}
;
types
.
backQuote
.
updateContext
=
function
(
)
{
if
(
this
.
curContext
(
)
=
=
=
types
1
.
q_tmpl
)
{
this
.
context
.
pop
(
)
;
}
else
{
this
.
context
.
push
(
types
1
.
q_tmpl
)
;
}
this
.
exprAllowed
=
false
;
}
;
types
.
star
.
updateContext
=
function
(
prevType
)
{
if
(
prevType
=
=
types
.
_function
)
{
var
index
=
this
.
context
.
length
-
1
;
if
(
this
.
context
[
index
]
=
=
=
types
1
.
f_expr
)
{
this
.
context
[
index
]
=
types
1
.
f_expr_gen
;
}
else
{
this
.
context
[
index
]
=
types
1
.
f_gen
;
}
}
this
.
exprAllowed
=
true
;
}
;
types
.
name
.
updateContext
=
function
(
prevType
)
{
var
allowed
=
false
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
if
(
this
.
value
=
=
"
of
"
&
&
!
this
.
exprAllowed
|
|
this
.
value
=
=
"
yield
"
&
&
this
.
inGeneratorContext
(
)
)
{
allowed
=
true
;
}
}
this
.
exprAllowed
=
allowed
;
}
;
var
Token
=
function
Token
(
p
)
{
this
.
type
=
p
.
type
;
this
.
value
=
p
.
value
;
this
.
start
=
p
.
start
;
this
.
end
=
p
.
end
;
if
(
p
.
options
.
locations
)
{
this
.
loc
=
new
SourceLocation
(
p
p
.
startLoc
p
.
endLoc
)
;
}
if
(
p
.
options
.
ranges
)
{
this
.
range
=
[
p
.
start
p
.
end
]
;
}
}
;
var
pp
8
=
Parser
.
prototype
;
var
isRhino
=
typeof
Packages
=
=
"
object
"
&
&
Object
.
prototype
.
toString
.
call
(
Packages
)
=
=
"
[
object
JavaPackage
]
"
;
pp
8
.
next
=
function
(
)
{
if
(
this
.
options
.
onToken
)
{
this
.
options
.
onToken
(
new
Token
(
this
)
)
;
}
this
.
lastTokEnd
=
this
.
end
;
this
.
lastTokStart
=
this
.
start
;
this
.
lastTokEndLoc
=
this
.
endLoc
;
this
.
lastTokStartLoc
=
this
.
startLoc
;
this
.
nextToken
(
)
;
}
;
pp
8
.
getToken
=
function
(
)
{
this
.
next
(
)
;
return
new
Token
(
this
)
}
;
if
(
typeof
Symbol
!
=
=
"
undefined
"
)
{
pp
8
[
Symbol
.
iterator
]
=
function
(
)
{
var
this
1
=
this
;
return
{
next
:
function
(
)
{
var
token
=
this
1
.
getToken
(
)
;
return
{
done
:
token
.
type
=
=
=
types
.
eof
value
:
token
}
}
}
}
;
}
pp
8
.
curContext
=
function
(
)
{
return
this
.
context
[
this
.
context
.
length
-
1
]
}
;
pp
8
.
nextToken
=
function
(
)
{
var
curContext
=
this
.
curContext
(
)
;
if
(
!
curContext
|
|
!
curContext
.
preserveSpace
)
{
this
.
skipSpace
(
)
;
}
this
.
start
=
this
.
pos
;
if
(
this
.
options
.
locations
)
{
this
.
startLoc
=
this
.
curPosition
(
)
;
}
if
(
this
.
pos
>
=
this
.
input
.
length
)
{
return
this
.
finishToken
(
types
.
eof
)
}
if
(
curContext
.
override
)
{
return
curContext
.
override
(
this
)
}
else
{
this
.
readToken
(
this
.
fullCharCodeAtPos
(
)
)
;
}
}
;
pp
8
.
readToken
=
function
(
code
)
{
if
(
isIdentifierStart
(
code
this
.
options
.
ecmaVersion
>
=
6
)
|
|
code
=
=
=
92
)
{
return
this
.
readWord
(
)
}
return
this
.
getTokenFromCode
(
code
)
}
;
pp
8
.
fullCharCodeAtPos
=
function
(
)
{
var
code
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
if
(
code
<
=
0xd7ff
|
|
code
>
=
0xe000
)
{
return
code
}
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
return
(
code
<
<
10
)
+
next
-
0x35fdc00
}
;
pp
8
.
skipBlockComment
=
function
(
)
{
var
this
1
=
this
;
var
startLoc
=
this
.
options
.
onComment
&
&
this
.
curPosition
(
)
;
var
start
=
this
.
pos
end
=
this
.
input
.
indexOf
(
"
*
/
"
this
.
pos
+
=
2
)
;
if
(
end
=
=
=
-
1
)
{
this
.
raise
(
this
.
pos
-
2
"
Unterminated
comment
"
)
;
}
this
.
pos
=
end
+
2
;
if
(
this
.
options
.
locations
)
{
lineBreakG
.
lastIndex
=
start
;
var
match
;
while
(
(
match
=
lineBreakG
.
exec
(
this
.
input
)
)
&
&
match
.
index
<
this
.
pos
)
{
+
+
this
1
.
curLine
;
this
1
.
lineStart
=
match
.
index
+
match
[
0
]
.
length
;
}
}
if
(
this
.
options
.
onComment
)
{
this
.
options
.
onComment
(
true
this
.
input
.
slice
(
start
+
2
end
)
start
this
.
pos
startLoc
this
.
curPosition
(
)
)
;
}
}
;
pp
8
.
skipLineComment
=
function
(
startSkip
)
{
var
this
1
=
this
;
var
start
=
this
.
pos
;
var
startLoc
=
this
.
options
.
onComment
&
&
this
.
curPosition
(
)
;
var
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
+
=
startSkip
)
;
while
(
this
.
pos
<
this
.
input
.
length
&
&
!
isNewLine
(
ch
)
)
{
ch
=
this
1
.
input
.
charCodeAt
(
+
+
this
1
.
pos
)
;
}
if
(
this
.
options
.
onComment
)
{
this
.
options
.
onComment
(
false
this
.
input
.
slice
(
start
+
startSkip
this
.
pos
)
start
this
.
pos
startLoc
this
.
curPosition
(
)
)
;
}
}
;
pp
8
.
skipSpace
=
function
(
)
{
var
this
1
=
this
;
loop
:
while
(
this
.
pos
<
this
.
input
.
length
)
{
var
ch
=
this
1
.
input
.
charCodeAt
(
this
1
.
pos
)
;
switch
(
ch
)
{
case
32
:
case
160
:
+
+
this
1
.
pos
;
break
case
13
:
if
(
this
1
.
input
.
charCodeAt
(
this
1
.
pos
+
1
)
=
=
=
10
)
{
+
+
this
1
.
pos
;
}
case
10
:
case
8232
:
case
8233
:
+
+
this
1
.
pos
;
if
(
this
1
.
options
.
locations
)
{
+
+
this
1
.
curLine
;
this
1
.
lineStart
=
this
1
.
pos
;
}
break
case
47
:
switch
(
this
1
.
input
.
charCodeAt
(
this
1
.
pos
+
1
)
)
{
case
42
:
this
1
.
skipBlockComment
(
)
;
break
case
47
:
this
1
.
skipLineComment
(
2
)
;
break
default
:
break
loop
}
break
default
:
if
(
ch
>
8
&
&
ch
<
14
|
|
ch
>
=
5760
&
&
nonASCIIwhitespace
.
test
(
String
.
fromCharCode
(
ch
)
)
)
{
+
+
this
1
.
pos
;
}
else
{
break
loop
}
}
}
}
;
pp
8
.
finishToken
=
function
(
type
val
)
{
this
.
end
=
this
.
pos
;
if
(
this
.
options
.
locations
)
{
this
.
endLoc
=
this
.
curPosition
(
)
;
}
var
prevType
=
this
.
type
;
this
.
type
=
type
;
this
.
value
=
val
;
this
.
updateContext
(
prevType
)
;
}
;
pp
8
.
readToken_dot
=
function
(
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
>
=
48
&
&
next
<
=
57
)
{
return
this
.
readNumber
(
true
)
}
var
next2
=
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
next
=
=
=
46
&
&
next2
=
=
=
46
)
{
this
.
pos
+
=
3
;
return
this
.
finishToken
(
types
.
ellipsis
)
}
else
{
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
dot
)
}
}
;
pp
8
.
readToken_slash
=
function
(
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
this
.
exprAllowed
)
{
+
+
this
.
pos
;
return
this
.
readRegexp
(
)
}
if
(
next
=
=
=
61
)
{
return
this
.
finishOp
(
types
.
assign
2
)
}
return
this
.
finishOp
(
types
.
slash
1
)
}
;
pp
8
.
readToken_mult_modulo_exp
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
var
size
=
1
;
var
tokentype
=
code
=
=
=
42
?
types
.
star
:
types
.
modulo
;
if
(
this
.
options
.
ecmaVersion
>
=
7
&
&
code
=
=
42
&
&
next
=
=
=
42
)
{
+
+
size
;
tokentype
=
types
.
starstar
;
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
;
}
if
(
next
=
=
=
61
)
{
return
this
.
finishOp
(
types
.
assign
size
+
1
)
}
return
this
.
finishOp
(
tokentype
size
)
}
;
pp
8
.
readToken_pipe_amp
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
code
)
{
return
this
.
finishOp
(
code
=
=
=
124
?
types
.
logicalOR
:
types
.
logicalAND
2
)
}
if
(
next
=
=
=
61
)
{
return
this
.
finishOp
(
types
.
assign
2
)
}
return
this
.
finishOp
(
code
=
=
=
124
?
types
.
bitwiseOR
:
types
.
bitwiseAND
1
)
}
;
pp
8
.
readToken_caret
=
function
(
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
61
)
{
return
this
.
finishOp
(
types
.
assign
2
)
}
return
this
.
finishOp
(
types
.
bitwiseXOR
1
)
}
;
pp
8
.
readToken_plus_min
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
code
)
{
if
(
next
=
=
45
&
&
!
this
.
inModule
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
62
&
&
(
this
.
lastTokEnd
=
=
=
0
|
|
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
pos
)
)
)
)
{
this
.
skipLineComment
(
3
)
;
this
.
skipSpace
(
)
;
return
this
.
nextToken
(
)
}
return
this
.
finishOp
(
types
.
incDec
2
)
}
if
(
next
=
=
=
61
)
{
return
this
.
finishOp
(
types
.
assign
2
)
}
return
this
.
finishOp
(
types
.
plusMin
1
)
}
;
pp
8
.
readToken_lt_gt
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
var
size
=
1
;
if
(
next
=
=
=
code
)
{
size
=
code
=
=
=
62
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
=
62
?
3
:
2
;
if
(
this
.
input
.
charCodeAt
(
this
.
pos
+
size
)
=
=
=
61
)
{
return
this
.
finishOp
(
types
.
assign
size
+
1
)
}
return
this
.
finishOp
(
types
.
bitShift
size
)
}
if
(
next
=
=
33
&
&
code
=
=
60
&
&
!
this
.
inModule
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
45
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
3
)
=
=
45
)
{
this
.
skipLineComment
(
4
)
;
this
.
skipSpace
(
)
;
return
this
.
nextToken
(
)
}
if
(
next
=
=
=
61
)
{
size
=
2
;
}
return
this
.
finishOp
(
types
.
relational
size
)
}
;
pp
8
.
readToken_eq_excl
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
61
)
{
return
this
.
finishOp
(
types
.
equality
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
=
61
?
3
:
2
)
}
if
(
code
=
=
=
61
&
&
next
=
=
=
62
&
&
this
.
options
.
ecmaVersion
>
=
6
)
{
this
.
pos
+
=
2
;
return
this
.
finishToken
(
types
.
arrow
)
}
return
this
.
finishOp
(
code
=
=
=
61
?
types
.
eq
:
types
.
prefix
1
)
}
;
pp
8
.
getTokenFromCode
=
function
(
code
)
{
switch
(
code
)
{
case
46
:
return
this
.
readToken_dot
(
)
case
40
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
parenL
)
case
41
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
parenR
)
case
59
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
semi
)
case
44
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
comma
)
case
91
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
bracketL
)
case
93
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
bracketR
)
case
123
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
braceL
)
case
125
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
braceR
)
case
58
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
colon
)
case
63
:
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
question
)
case
96
:
if
(
this
.
options
.
ecmaVersion
<
6
)
{
break
}
+
+
this
.
pos
;
return
this
.
finishToken
(
types
.
backQuote
)
case
48
:
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
120
|
|
next
=
=
=
88
)
{
return
this
.
readRadixNumber
(
16
)
}
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
if
(
next
=
=
=
111
|
|
next
=
=
=
79
)
{
return
this
.
readRadixNumber
(
8
)
}
if
(
next
=
=
=
98
|
|
next
=
=
=
66
)
{
return
this
.
readRadixNumber
(
2
)
}
}
case
49
:
case
50
:
case
51
:
case
52
:
case
53
:
case
54
:
case
55
:
case
56
:
case
57
:
return
this
.
readNumber
(
false
)
case
34
:
case
39
:
return
this
.
readString
(
code
)
case
47
:
return
this
.
readToken_slash
(
)
case
37
:
case
42
:
return
this
.
readToken_mult_modulo_exp
(
code
)
case
124
:
case
38
:
return
this
.
readToken_pipe_amp
(
code
)
case
94
:
return
this
.
readToken_caret
(
)
case
43
:
case
45
:
return
this
.
readToken_plus_min
(
code
)
case
60
:
case
62
:
return
this
.
readToken_lt_gt
(
code
)
case
61
:
case
33
:
return
this
.
readToken_eq_excl
(
code
)
case
126
:
return
this
.
finishOp
(
types
.
prefix
1
)
}
this
.
raise
(
this
.
pos
"
Unexpected
character
'
"
+
codePointToString
(
code
)
+
"
'
"
)
;
}
;
pp
8
.
finishOp
=
function
(
type
size
)
{
var
str
=
this
.
input
.
slice
(
this
.
pos
this
.
pos
+
size
)
;
this
.
pos
+
=
size
;
return
this
.
finishToken
(
type
str
)
}
;
function
tryCreateRegexp
(
src
flags
throwErrorAt
parser
)
{
try
{
return
new
RegExp
(
src
flags
)
}
catch
(
e
)
{
if
(
throwErrorAt
!
=
=
undefined
)
{
if
(
e
instanceof
SyntaxError
)
{
parser
.
raise
(
throwErrorAt
"
Error
parsing
regular
expression
:
"
+
e
.
message
)
;
}
throw
e
}
}
}
var
regexpUnicodeSupport
=
!
!
tryCreateRegexp
(
"
\
uffff
"
"
u
"
)
;
pp
8
.
readRegexp
=
function
(
)
{
var
this
1
=
this
;
var
escaped
inClass
start
=
this
.
pos
;
for
(
;
;
)
{
if
(
this
1
.
pos
>
=
this
1
.
input
.
length
)
{
this
1
.
raise
(
start
"
Unterminated
regular
expression
"
)
;
}
var
ch
=
this
1
.
input
.
charAt
(
this
1
.
pos
)
;
if
(
lineBreak
.
test
(
ch
)
)
{
this
1
.
raise
(
start
"
Unterminated
regular
expression
"
)
;
}
if
(
!
escaped
)
{
if
(
ch
=
=
=
"
[
"
)
{
inClass
=
true
;
}
else
if
(
ch
=
=
=
"
]
"
&
&
inClass
)
{
inClass
=
false
;
}
else
if
(
ch
=
=
=
"
/
"
&
&
!
inClass
)
{
break
}
escaped
=
ch
=
=
=
"
\
\
"
;
}
else
{
escaped
=
false
;
}
+
+
this
1
.
pos
;
}
var
content
=
this
.
input
.
slice
(
start
this
.
pos
)
;
+
+
this
.
pos
;
var
mods
=
this
.
readWord1
(
)
;
var
tmp
=
content
tmpFlags
=
"
"
;
if
(
mods
)
{
var
validFlags
=
/
^
[
gim
]
*
/
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
validFlags
=
/
^
[
gimuy
]
*
/
;
}
if
(
!
validFlags
.
test
(
mods
)
)
{
this
.
raise
(
start
"
Invalid
regular
expression
flag
"
)
;
}
if
(
mods
.
indexOf
(
"
u
"
)
>
=
0
)
{
if
(
regexpUnicodeSupport
)
{
tmpFlags
=
"
u
"
;
}
else
{
tmp
=
tmp
.
replace
(
/
\
\
u
\
{
(
[
0
-
9a
-
fA
-
F
]
+
)
\
}
/
g
function
(
_match
code
offset
)
{
code
=
Number
(
"
0x
"
+
code
)
;
if
(
code
>
0x10FFFF
)
{
this
1
.
raise
(
start
+
offset
+
3
"
Code
point
out
of
bounds
"
)
;
}
return
"
x
"
}
)
;
tmp
=
tmp
.
replace
(
/
\
\
u
(
[
a
-
fA
-
F0
-
9
]
{
4
}
)
|
[
\
uD800
-
\
uDBFF
]
[
\
uDC00
-
\
uDFFF
]
/
g
"
x
"
)
;
tmpFlags
=
tmpFlags
.
replace
(
"
u
"
"
"
)
;
}
}
}
var
value
=
null
;
if
(
!
isRhino
)
{
tryCreateRegexp
(
tmp
tmpFlags
start
this
)
;
value
=
tryCreateRegexp
(
content
mods
)
;
}
return
this
.
finishToken
(
types
.
regexp
{
pattern
:
content
flags
:
mods
value
:
value
}
)
}
;
pp
8
.
readInt
=
function
(
radix
len
)
{
var
this
1
=
this
;
var
start
=
this
.
pos
total
=
0
;
for
(
var
i
=
0
e
=
len
=
=
null
?
Infinity
:
len
;
i
<
e
;
+
+
i
)
{
var
code
=
this
1
.
input
.
charCodeAt
(
this
1
.
pos
)
val
=
(
void
0
)
;
if
(
code
>
=
97
)
{
val
=
code
-
97
+
10
;
}
else
if
(
code
>
=
65
)
{
val
=
code
-
65
+
10
;
}
else
if
(
code
>
=
48
&
&
code
<
=
57
)
{
val
=
code
-
48
;
}
else
{
val
=
Infinity
;
}
if
(
val
>
=
radix
)
{
break
}
+
+
this
1
.
pos
;
total
=
total
*
radix
+
val
;
}
if
(
this
.
pos
=
=
=
start
|
|
len
!
=
null
&
&
this
.
pos
-
start
!
=
=
len
)
{
return
null
}
return
total
}
;
pp
8
.
readRadixNumber
=
function
(
radix
)
{
this
.
pos
+
=
2
;
var
val
=
this
.
readInt
(
radix
)
;
if
(
val
=
=
null
)
{
this
.
raise
(
this
.
start
+
2
"
Expected
number
in
radix
"
+
radix
)
;
}
if
(
isIdentifierStart
(
this
.
fullCharCodeAtPos
(
)
)
)
{
this
.
raise
(
this
.
pos
"
Identifier
directly
after
number
"
)
;
}
return
this
.
finishToken
(
types
.
num
val
)
}
;
pp
8
.
readNumber
=
function
(
startsWithDot
)
{
var
start
=
this
.
pos
isFloat
=
false
octal
=
this
.
input
.
charCodeAt
(
this
.
pos
)
=
=
=
48
;
if
(
!
startsWithDot
&
&
this
.
readInt
(
10
)
=
=
=
null
)
{
this
.
raise
(
start
"
Invalid
number
"
)
;
}
if
(
octal
&
&
this
.
pos
=
=
start
+
1
)
{
octal
=
false
;
}
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
if
(
next
=
=
=
46
&
&
!
octal
)
{
+
+
this
.
pos
;
this
.
readInt
(
10
)
;
isFloat
=
true
;
next
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
}
if
(
(
next
=
=
=
69
|
|
next
=
=
=
101
)
&
&
!
octal
)
{
next
=
this
.
input
.
charCodeAt
(
+
+
this
.
pos
)
;
if
(
next
=
=
=
43
|
|
next
=
=
=
45
)
{
+
+
this
.
pos
;
}
if
(
this
.
readInt
(
10
)
=
=
=
null
)
{
this
.
raise
(
start
"
Invalid
number
"
)
;
}
isFloat
=
true
;
}
if
(
isIdentifierStart
(
this
.
fullCharCodeAtPos
(
)
)
)
{
this
.
raise
(
this
.
pos
"
Identifier
directly
after
number
"
)
;
}
var
str
=
this
.
input
.
slice
(
start
this
.
pos
)
val
;
if
(
isFloat
)
{
val
=
parseFloat
(
str
)
;
}
else
if
(
!
octal
|
|
str
.
length
=
=
=
1
)
{
val
=
parseInt
(
str
10
)
;
}
else
if
(
this
.
strict
)
{
this
.
raise
(
start
"
Invalid
number
"
)
;
}
else
if
(
/
[
89
]
/
.
test
(
str
)
)
{
val
=
parseInt
(
str
10
)
;
}
else
{
val
=
parseInt
(
str
8
)
;
}
return
this
.
finishToken
(
types
.
num
val
)
}
;
pp
8
.
readCodePoint
=
function
(
)
{
var
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
)
code
;
if
(
ch
=
=
=
123
)
{
if
(
this
.
options
.
ecmaVersion
<
6
)
{
this
.
unexpected
(
)
;
}
var
codePos
=
+
+
this
.
pos
;
code
=
this
.
readHexChar
(
this
.
input
.
indexOf
(
"
}
"
this
.
pos
)
-
this
.
pos
)
;
+
+
this
.
pos
;
if
(
code
>
0x10FFFF
)
{
this
.
invalidStringToken
(
codePos
"
Code
point
out
of
bounds
"
)
;
}
}
else
{
code
=
this
.
readHexChar
(
4
)
;
}
return
code
}
;
function
codePointToString
(
code
)
{
if
(
code
<
=
0xFFFF
)
{
return
String
.
fromCharCode
(
code
)
}
code
-
=
0x10000
;
return
String
.
fromCharCode
(
(
code
>
>
10
)
+
0xD800
(
code
&
1023
)
+
0xDC00
)
}
pp
8
.
readString
=
function
(
quote
)
{
var
this
1
=
this
;
var
out
=
"
"
chunkStart
=
+
+
this
.
pos
;
for
(
;
;
)
{
if
(
this
1
.
pos
>
=
this
1
.
input
.
length
)
{
this
1
.
raise
(
this
1
.
start
"
Unterminated
string
constant
"
)
;
}
var
ch
=
this
1
.
input
.
charCodeAt
(
this
1
.
pos
)
;
if
(
ch
=
=
=
quote
)
{
break
}
if
(
ch
=
=
=
92
)
{
out
+
=
this
1
.
input
.
slice
(
chunkStart
this
1
.
pos
)
;
out
+
=
this
1
.
readEscapedChar
(
false
)
;
chunkStart
=
this
1
.
pos
;
}
else
{
if
(
isNewLine
(
ch
)
)
{
this
1
.
raise
(
this
1
.
start
"
Unterminated
string
constant
"
)
;
}
+
+
this
1
.
pos
;
}
}
out
+
=
this
.
input
.
slice
(
chunkStart
this
.
pos
+
+
)
;
return
this
.
finishToken
(
types
.
string
out
)
}
;
var
INVALID_TEMPLATE_ESCAPE_ERROR
=
{
}
;
pp
8
.
tryReadTemplateToken
=
function
(
)
{
this
.
inTemplateElement
=
true
;
try
{
this
.
readTmplToken
(
)
;
}
catch
(
err
)
{
if
(
err
=
=
=
INVALID_TEMPLATE_ESCAPE_ERROR
)
{
this
.
readInvalidTemplateToken
(
)
;
}
else
{
throw
err
}
}
this
.
inTemplateElement
=
false
;
}
;
pp
8
.
invalidStringToken
=
function
(
position
message
)
{
if
(
this
.
inTemplateElement
&
&
this
.
options
.
ecmaVersion
>
=
9
)
{
throw
INVALID_TEMPLATE_ESCAPE_ERROR
}
else
{
this
.
raise
(
position
message
)
;
}
}
;
pp
8
.
readTmplToken
=
function
(
)
{
var
this
1
=
this
;
var
out
=
"
"
chunkStart
=
this
.
pos
;
for
(
;
;
)
{
if
(
this
1
.
pos
>
=
this
1
.
input
.
length
)
{
this
1
.
raise
(
this
1
.
start
"
Unterminated
template
"
)
;
}
var
ch
=
this
1
.
input
.
charCodeAt
(
this
1
.
pos
)
;
if
(
ch
=
=
=
96
|
|
ch
=
=
=
36
&
&
this
1
.
input
.
charCodeAt
(
this
1
.
pos
+
1
)
=
=
=
123
)
{
if
(
this
1
.
pos
=
=
=
this
1
.
start
&
&
(
this
1
.
type
=
=
=
types
.
template
|
|
this
1
.
type
=
=
=
types
.
invalidTemplate
)
)
{
if
(
ch
=
=
=
36
)
{
this
1
.
pos
+
=
2
;
return
this
1
.
finishToken
(
types
.
dollarBraceL
)
}
else
{
+
+
this
1
.
pos
;
return
this
1
.
finishToken
(
types
.
backQuote
)
}
}
out
+
=
this
1
.
input
.
slice
(
chunkStart
this
1
.
pos
)
;
return
this
1
.
finishToken
(
types
.
template
out
)
}
if
(
ch
=
=
=
92
)
{
out
+
=
this
1
.
input
.
slice
(
chunkStart
this
1
.
pos
)
;
out
+
=
this
1
.
readEscapedChar
(
true
)
;
chunkStart
=
this
1
.
pos
;
}
else
if
(
isNewLine
(
ch
)
)
{
out
+
=
this
1
.
input
.
slice
(
chunkStart
this
1
.
pos
)
;
+
+
this
1
.
pos
;
switch
(
ch
)
{
case
13
:
if
(
this
1
.
input
.
charCodeAt
(
this
1
.
pos
)
=
=
=
10
)
{
+
+
this
1
.
pos
;
}
case
10
:
out
+
=
"
\
n
"
;
break
default
:
out
+
=
String
.
fromCharCode
(
ch
)
;
break
}
if
(
this
1
.
options
.
locations
)
{
+
+
this
1
.
curLine
;
this
1
.
lineStart
=
this
1
.
pos
;
}
chunkStart
=
this
1
.
pos
;
}
else
{
+
+
this
1
.
pos
;
}
}
}
;
pp
8
.
readInvalidTemplateToken
=
function
(
)
{
var
this
1
=
this
;
for
(
;
this
.
pos
<
this
.
input
.
length
;
this
.
pos
+
+
)
{
switch
(
this
1
.
input
[
this
1
.
pos
]
)
{
case
"
\
\
"
:
+
+
this
1
.
pos
;
break
case
"
"
:
if
(
this
1
.
input
[
this
1
.
pos
+
1
]
!
=
=
"
{
"
)
{
break
}
case
"
"
:
return
this
1
.
finishToken
(
types
.
invalidTemplate
this
1
.
input
.
slice
(
this
1
.
start
this
1
.
pos
)
)
}
}
this
.
raise
(
this
.
start
"
Unterminated
template
"
)
;
}
;
pp
8
.
readEscapedChar
=
function
(
inTemplate
)
{
var
ch
=
this
.
input
.
charCodeAt
(
+
+
this
.
pos
)
;
+
+
this
.
pos
;
switch
(
ch
)
{
case
110
:
return
"
\
n
"
case
114
:
return
"
\
r
"
case
120
:
return
String
.
fromCharCode
(
this
.
readHexChar
(
2
)
)
case
117
:
return
codePointToString
(
this
.
readCodePoint
(
)
)
case
116
:
return
"
\
t
"
case
98
:
return
"
\
b
"
case
118
:
return
"
\
u000b
"
case
102
:
return
"
\
f
"
case
13
:
if
(
this
.
input
.
charCodeAt
(
this
.
pos
)
=
=
=
10
)
{
+
+
this
.
pos
;
}
case
10
:
if
(
this
.
options
.
locations
)
{
this
.
lineStart
=
this
.
pos
;
+
+
this
.
curLine
;
}
return
"
"
default
:
if
(
ch
>
=
48
&
&
ch
<
=
55
)
{
var
octalStr
=
this
.
input
.
substr
(
this
.
pos
-
1
3
)
.
match
(
/
^
[
0
-
7
]
+
/
)
[
0
]
;
var
octal
=
parseInt
(
octalStr
8
)
;
if
(
octal
>
255
)
{
octalStr
=
octalStr
.
slice
(
0
-
1
)
;
octal
=
parseInt
(
octalStr
8
)
;
}
if
(
octalStr
!
=
=
"
0
"
&
&
(
this
.
strict
|
|
inTemplate
)
)
{
this
.
invalidStringToken
(
this
.
pos
-
2
"
Octal
literal
in
strict
mode
"
)
;
}
this
.
pos
+
=
octalStr
.
length
-
1
;
return
String
.
fromCharCode
(
octal
)
}
return
String
.
fromCharCode
(
ch
)
}
}
;
pp
8
.
readHexChar
=
function
(
len
)
{
var
codePos
=
this
.
pos
;
var
n
=
this
.
readInt
(
16
len
)
;
if
(
n
=
=
=
null
)
{
this
.
invalidStringToken
(
codePos
"
Bad
character
escape
sequence
"
)
;
}
return
n
}
;
pp
8
.
readWord1
=
function
(
)
{
var
this
1
=
this
;
this
.
containsEsc
=
false
;
var
word
=
"
"
first
=
true
chunkStart
=
this
.
pos
;
var
astral
=
this
.
options
.
ecmaVersion
>
=
6
;
while
(
this
.
pos
<
this
.
input
.
length
)
{
var
ch
=
this
1
.
fullCharCodeAtPos
(
)
;
if
(
isIdentifierChar
(
ch
astral
)
)
{
this
1
.
pos
+
=
ch
<
=
0xffff
?
1
:
2
;
}
else
if
(
ch
=
=
=
92
)
{
this
1
.
containsEsc
=
true
;
word
+
=
this
1
.
input
.
slice
(
chunkStart
this
1
.
pos
)
;
var
escStart
=
this
1
.
pos
;
if
(
this
1
.
input
.
charCodeAt
(
+
+
this
1
.
pos
)
!
=
117
)
{
this
1
.
invalidStringToken
(
this
1
.
pos
"
Expecting
Unicode
escape
sequence
\
\
uXXXX
"
)
;
}
+
+
this
1
.
pos
;
var
esc
=
this
1
.
readCodePoint
(
)
;
if
(
!
(
first
?
isIdentifierStart
:
isIdentifierChar
)
(
esc
astral
)
)
{
this
1
.
invalidStringToken
(
escStart
"
Invalid
Unicode
escape
"
)
;
}
word
+
=
codePointToString
(
esc
)
;
chunkStart
=
this
1
.
pos
;
}
else
{
break
}
first
=
false
;
}
return
word
+
this
.
input
.
slice
(
chunkStart
this
.
pos
)
}
;
pp
8
.
readWord
=
function
(
)
{
var
word
=
this
.
readWord1
(
)
;
var
type
=
types
.
name
;
if
(
this
.
keywords
.
test
(
word
)
)
{
if
(
this
.
containsEsc
)
{
this
.
raiseRecoverable
(
this
.
start
"
Escape
sequence
in
keyword
"
+
word
)
;
}
type
=
keywords
1
[
word
]
;
}
return
this
.
finishToken
(
type
word
)
}
;
var
version
=
"
5
.
2
.
1
"
;
function
parse
(
input
options
)
{
return
new
Parser
(
options
input
)
.
parse
(
)
}
function
parseExpressionAt
(
input
pos
options
)
{
var
p
=
new
Parser
(
options
input
pos
)
;
p
.
nextToken
(
)
;
return
p
.
parseExpression
(
)
}
function
tokenizer
(
input
options
)
{
return
new
Parser
(
options
input
)
}
function
addLooseExports
(
parse
Parser
1
plugins
1
)
{
exports
.
parse_dammit
=
parse
;
exports
.
LooseParser
=
Parser
1
;
exports
.
pluginsLoose
=
plugins
1
;
}
exports
.
version
=
version
;
exports
.
parse
=
parse
;
exports
.
parseExpressionAt
=
parseExpressionAt
;
exports
.
tokenizer
=
tokenizer
;
exports
.
addLooseExports
=
addLooseExports
;
exports
.
Parser
=
Parser
;
exports
.
plugins
=
plugins
;
exports
.
defaultOptions
=
defaultOptions
;
exports
.
Position
=
Position
;
exports
.
SourceLocation
=
SourceLocation
;
exports
.
getLineInfo
=
getLineInfo
;
exports
.
Node
=
Node
;
exports
.
TokenType
=
TokenType
;
exports
.
tokTypes
=
types
;
exports
.
keywordTypes
=
keywords
1
;
exports
.
TokContext
=
TokContext
;
exports
.
tokContexts
=
types
1
;
exports
.
isIdentifierChar
=
isIdentifierChar
;
exports
.
isIdentifierStart
=
isIdentifierStart
;
exports
.
Token
=
Token
;
exports
.
isNewLine
=
isNewLine
;
exports
.
lineBreak
=
lineBreak
;
exports
.
lineBreakG
=
lineBreakG
;
exports
.
nonASCIIwhitespace
=
nonASCIIwhitespace
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
}
)
)
)
;
}
)
802
:
(
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_FACTORY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
root
factory
)
{
"
use
strict
"
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_FACTORY__
=
(
factory
)
__WEBPACK_AMD_DEFINE_RESULT__
=
(
typeof
__WEBPACK_AMD_DEFINE_FACTORY__
=
=
=
'
function
'
?
(
__WEBPACK_AMD_DEFINE_FACTORY__
.
call
(
exports
__webpack_require__
exports
module
)
)
:
__WEBPACK_AMD_DEFINE_FACTORY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
typeof
exports
=
=
=
"
object
"
)
{
module
.
exports
=
factory
(
)
;
}
else
{
root
.
prettyFast
=
factory
(
)
;
}
}
(
this
function
(
)
{
"
use
strict
"
;
var
acorn
=
this
.
acorn
|
|
__webpack_require__
(
381
)
;
var
sourceMap
=
this
.
sourceMap
|
|
__webpack_require__
(
815
)
;
var
SourceNode
=
sourceMap
.
SourceNode
;
var
PRE_ARRAY_LITERAL_TOKENS
=
{
"
typeof
"
:
true
"
void
"
:
true
"
delete
"
:
true
"
case
"
:
true
"
do
"
:
true
"
=
"
:
true
"
in
"
:
true
"
{
"
:
true
"
*
"
:
true
"
/
"
:
true
"
%
"
:
true
"
else
"
:
true
"
;
"
:
true
"
+
+
"
:
true
"
-
-
"
:
true
"
+
"
:
true
"
-
"
:
true
"
~
"
:
true
"
!
"
:
true
"
:
"
:
true
"
?
"
:
true
"
>
>
"
:
true
"
>
>
>
"
:
true
"
<
<
"
:
true
"
|
|
"
:
true
"
&
&
"
:
true
"
<
"
:
true
"
>
"
:
true
"
<
=
"
:
true
"
>
=
"
:
true
"
instanceof
"
:
true
"
&
"
:
true
"
^
"
:
true
"
|
"
:
true
"
=
=
"
:
true
"
!
=
"
:
true
"
=
=
=
"
:
true
"
!
=
=
"
:
true
"
"
:
true
"
}
"
:
true
}
;
function
isArrayLiteral
(
token
lastToken
)
{
if
(
token
.
type
.
label
!
=
"
[
"
)
{
return
false
;
}
if
(
!
lastToken
)
{
return
true
;
}
if
(
lastToken
.
type
.
isAssign
)
{
return
true
;
}
return
!
!
PRE_ARRAY_LITERAL_TOKENS
[
lastToken
.
type
.
keyword
|
|
lastToken
.
type
.
label
]
;
}
var
PREVENT_ASI_AFTER_TOKENS
=
{
"
*
"
:
true
"
/
"
:
true
"
%
"
:
true
"
+
"
:
true
"
-
"
:
true
"
<
<
"
:
true
"
>
>
"
:
true
"
>
>
>
"
:
true
"
<
"
:
true
"
>
"
:
true
"
<
=
"
:
true
"
>
=
"
:
true
"
instanceof
"
:
true
"
in
"
:
true
"
=
=
"
:
true
"
!
=
"
:
true
"
=
=
=
"
:
true
"
!
=
=
"
:
true
"
&
"
:
true
"
^
"
:
true
"
|
"
:
true
"
&
&
"
:
true
"
|
|
"
:
true
"
"
:
true
"
.
"
:
true
"
=
"
:
true
"
*
=
"
:
true
"
/
=
"
:
true
"
%
=
"
:
true
"
+
=
"
:
true
"
-
=
"
:
true
"
<
<
=
"
:
true
"
>
>
=
"
:
true
"
>
>
>
=
"
:
true
"
&
=
"
:
true
"
^
=
"
:
true
"
|
=
"
:
true
"
delete
"
:
true
"
void
"
:
true
"
typeof
"
:
true
"
~
"
:
true
"
!
"
:
true
"
new
"
:
true
"
(
"
:
true
}
;
var
PREVENT_ASI_BEFORE_TOKENS
=
{
"
*
"
:
true
"
/
"
:
true
"
%
"
:
true
"
<
<
"
:
true
"
>
>
"
:
true
"
>
>
>
"
:
true
"
<
"
:
true
"
>
"
:
true
"
<
=
"
:
true
"
>
=
"
:
true
"
instanceof
"
:
true
"
in
"
:
true
"
=
=
"
:
true
"
!
=
"
:
true
"
=
=
=
"
:
true
"
!
=
=
"
:
true
"
&
"
:
true
"
^
"
:
true
"
|
"
:
true
"
&
&
"
:
true
"
|
|
"
:
true
"
"
:
true
"
.
"
:
true
"
=
"
:
true
"
*
=
"
:
true
"
/
=
"
:
true
"
%
=
"
:
true
"
+
=
"
:
true
"
-
=
"
:
true
"
<
<
=
"
:
true
"
>
>
=
"
:
true
"
>
>
>
=
"
:
true
"
&
=
"
:
true
"
^
=
"
:
true
"
|
=
"
:
true
"
(
"
:
true
}
;
function
isASI
(
token
lastToken
)
{
if
(
!
lastToken
)
{
return
false
;
}
if
(
token
.
loc
.
start
.
line
=
=
=
lastToken
.
loc
.
start
.
line
)
{
return
false
;
}
if
(
PREVENT_ASI_AFTER_TOKENS
[
lastToken
.
type
.
label
|
|
lastToken
.
type
.
keyword
]
)
{
return
false
;
}
if
(
PREVENT_ASI_BEFORE_TOKENS
[
token
.
type
.
label
|
|
token
.
type
.
keyword
]
)
{
return
false
;
}
return
true
;
}
function
isGetterOrSetter
(
token
lastToken
stack
)
{
return
stack
[
stack
.
length
-
1
]
=
=
"
{
"
&
&
lastToken
&
&
lastToken
.
type
.
label
=
=
"
name
"
&
&
(
lastToken
.
value
=
=
"
get
"
|
|
lastToken
.
value
=
=
"
set
"
)
&
&
token
.
type
.
label
=
=
"
name
"
;
}
function
isLineDelimiter
(
token
stack
)
{
if
(
token
.
isArrayLiteral
)
{
return
true
;
}
var
ttl
=
token
.
type
.
label
;
var
top
=
stack
[
stack
.
length
-
1
]
;
return
ttl
=
=
"
;
"
&
&
top
!
=
"
(
"
|
|
ttl
=
=
"
{
"
|
|
ttl
=
=
"
"
&
&
top
!
=
"
(
"
|
|
ttl
=
=
"
:
"
&
&
(
top
=
=
"
case
"
|
|
top
=
=
"
default
"
)
;
}
function
appendNewline
(
token
write
stack
)
{
if
(
isLineDelimiter
(
token
stack
)
)
{
write
(
"
\
n
"
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
return
true
;
}
return
false
;
}
function
needsSpaceAfter
(
token
lastToken
)
{
if
(
lastToken
)
{
if
(
lastToken
.
type
.
isLoop
)
{
return
true
;
}
if
(
lastToken
.
type
.
isAssign
)
{
return
true
;
}
if
(
lastToken
.
type
.
binop
!
=
null
)
{
return
true
;
}
var
ltt
=
lastToken
.
type
.
label
;
if
(
ltt
=
=
"
?
"
)
{
return
true
;
}
if
(
ltt
=
=
"
:
"
)
{
return
true
;
}
if
(
ltt
=
=
"
"
)
{
return
true
;
}
if
(
ltt
=
=
"
;
"
)
{
return
true
;
}
var
ltk
=
lastToken
.
type
.
keyword
;
if
(
ltk
!
=
null
)
{
if
(
ltk
=
=
"
break
"
|
|
ltk
=
=
"
continue
"
|
|
ltk
=
=
"
return
"
)
{
return
token
.
type
.
label
!
=
"
;
"
;
}
if
(
ltk
!
=
"
debugger
"
&
&
ltk
!
=
"
null
"
&
&
ltk
!
=
"
true
"
&
&
ltk
!
=
"
false
"
&
&
ltk
!
=
"
this
"
&
&
ltk
!
=
"
default
"
)
{
return
true
;
}
}
if
(
ltt
=
=
"
)
"
&
&
(
token
.
type
.
label
!
=
"
)
"
&
&
token
.
type
.
label
!
=
"
]
"
&
&
token
.
type
.
label
!
=
"
;
"
&
&
token
.
type
.
label
!
=
"
"
&
&
token
.
type
.
label
!
=
"
.
"
)
)
{
return
true
;
}
if
(
lastToken
.
value
=
=
"
let
"
)
{
return
true
;
}
if
(
lastToken
.
value
=
=
"
const
"
)
{
return
true
;
}
}
if
(
token
.
type
.
isAssign
)
{
return
true
;
}
if
(
token
.
type
.
binop
!
=
null
)
{
return
true
;
}
if
(
token
.
type
.
label
=
=
"
?
"
)
{
return
true
;
}
return
false
;
}
function
prependWhiteSpace
(
token
lastToken
addedNewline
write
options
indentLevel
stack
)
{
var
ttk
=
token
.
type
.
keyword
;
var
ttl
=
token
.
type
.
label
;
var
newlineAdded
=
addedNewline
;
var
ltt
=
lastToken
?
lastToken
.
type
.
label
:
null
;
if
(
lastToken
&
&
ltt
=
=
"
}
"
)
{
if
(
ttk
=
=
"
while
"
&
&
stack
[
stack
.
length
-
1
]
=
=
"
do
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
else
if
(
ttk
=
=
"
else
"
|
|
ttk
=
=
"
catch
"
|
|
ttk
=
=
"
finally
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
else
if
(
ttl
!
=
"
(
"
&
&
ttl
!
=
"
;
"
&
&
ttl
!
=
"
"
&
&
ttl
!
=
"
)
"
&
&
ttl
!
=
"
.
"
)
{
write
(
"
\
n
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
newlineAdded
=
true
;
}
}
if
(
isGetterOrSetter
(
token
lastToken
stack
)
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
if
(
ttl
=
=
"
:
"
&
&
stack
[
stack
.
length
-
1
]
=
=
"
?
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
if
(
lastToken
&
&
ltt
!
=
"
}
"
&
&
ttk
=
=
"
else
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
function
ensureNewline
(
)
{
if
(
!
newlineAdded
)
{
write
(
"
\
n
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
newlineAdded
=
true
;
}
}
if
(
isASI
(
token
lastToken
)
)
{
ensureNewline
(
)
;
}
if
(
decrementsIndent
(
ttl
stack
)
)
{
ensureNewline
(
)
;
}
if
(
newlineAdded
)
{
if
(
ttk
=
=
"
case
"
|
|
ttk
=
=
"
default
"
)
{
write
(
repeat
(
options
.
indent
indentLevel
-
1
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
else
{
write
(
repeat
(
options
.
indent
indentLevel
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
}
else
if
(
needsSpaceAfter
(
token
lastToken
)
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
}
function
repeat
(
str
n
)
{
var
result
=
"
"
;
while
(
n
>
0
)
{
if
(
n
&
1
)
{
result
+
=
str
;
}
n
>
>
=
1
;
str
+
=
str
;
}
return
result
;
}
var
sanitize
=
(
function
(
)
{
var
escapeCharacters
=
{
"
\
\
"
:
"
\
\
\
\
"
"
\
n
"
:
"
\
\
n
"
"
\
r
"
:
"
\
\
r
"
"
\
t
"
:
"
\
\
t
"
"
\
v
"
:
"
\
\
v
"
"
\
f
"
:
"
\
\
f
"
"
\
0
"
:
"
\
\
0
"
"
'
"
:
"
\
\
'
"
}
;
var
regExpString
=
"
(
"
+
Object
.
keys
(
escapeCharacters
)
.
map
(
function
(
c
)
{
return
escapeCharacters
[
c
]
;
}
)
.
join
(
"
|
"
)
+
"
)
"
;
var
escapeCharactersRegExp
=
new
RegExp
(
regExpString
"
g
"
)
;
return
function
(
str
)
{
return
str
.
replace
(
escapeCharactersRegExp
function
(
_
c
)
{
return
escapeCharacters
[
c
]
;
}
)
;
}
;
}
(
)
)
;
function
addToken
(
token
write
)
{
if
(
token
.
type
.
label
=
=
"
string
"
)
{
write
(
"
'
"
+
sanitize
(
token
.
value
)
+
"
'
"
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
else
if
(
token
.
type
.
label
=
=
"
regexp
"
)
{
write
(
String
(
token
.
value
.
value
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
else
{
write
(
String
(
token
.
value
!
=
null
?
token
.
value
:
token
.
type
.
label
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
}
function
belongsOnStack
(
token
)
{
var
ttl
=
token
.
type
.
label
;
var
ttk
=
token
.
type
.
keyword
;
return
ttl
=
=
"
{
"
|
|
ttl
=
=
"
(
"
|
|
ttl
=
=
"
[
"
|
|
ttl
=
=
"
?
"
|
|
ttk
=
=
"
do
"
|
|
ttk
=
=
"
switch
"
|
|
ttk
=
=
"
case
"
|
|
ttk
=
=
"
default
"
;
}
function
shouldStackPop
(
token
stack
)
{
var
ttl
=
token
.
type
.
label
;
var
ttk
=
token
.
type
.
keyword
;
var
top
=
stack
[
stack
.
length
-
1
]
;
return
ttl
=
=
"
]
"
|
|
ttl
=
=
"
)
"
|
|
ttl
=
=
"
}
"
|
|
(
ttl
=
=
"
:
"
&
&
(
top
=
=
"
case
"
|
|
top
=
=
"
default
"
|
|
top
=
=
"
?
"
)
)
|
|
(
ttk
=
=
"
while
"
&
&
top
=
=
"
do
"
)
;
}
function
decrementsIndent
(
tokenType
stack
)
{
return
tokenType
=
=
"
}
"
|
|
(
tokenType
=
=
"
]
"
&
&
stack
[
stack
.
length
-
1
]
=
=
"
[
\
n
"
)
;
}
function
incrementsIndent
(
token
)
{
return
token
.
type
.
label
=
=
"
{
"
|
|
token
.
isArrayLiteral
|
|
token
.
type
.
keyword
=
=
"
switch
"
;
}
function
addComment
(
write
indentLevel
options
block
text
line
column
)
{
var
indentString
=
repeat
(
options
.
indent
indentLevel
)
;
write
(
indentString
line
column
)
;
if
(
block
)
{
write
(
"
/
*
"
)
;
write
(
text
.
split
(
new
RegExp
(
"
/
\
n
"
+
indentString
+
"
/
"
"
g
"
)
)
.
join
(
"
\
n
"
+
indentString
)
)
;
write
(
"
*
/
"
)
;
}
else
{
write
(
"
/
/
"
)
;
write
(
text
)
;
}
write
(
"
\
n
"
)
;
}
return
function
prettyFast
(
input
options
)
{
var
indentLevel
=
0
;
var
result
=
new
SourceNode
(
)
;
var
write
=
(
function
(
)
{
var
buffer
=
[
]
;
var
bufferLine
=
-
1
;
var
bufferColumn
=
-
1
;
return
function
write
(
str
line
column
)
{
if
(
line
!
=
null
&
&
bufferLine
=
=
=
-
1
)
{
bufferLine
=
line
;
}
if
(
column
!
=
null
&
&
bufferColumn
=
=
=
-
1
)
{
bufferColumn
=
column
;
}
buffer
.
push
(
str
)
;
if
(
str
=
=
"
\
n
"
)
{
var
lineStr
=
"
"
;
for
(
var
i
=
0
len
=
buffer
.
length
;
i
<
len
;
i
+
+
)
{
lineStr
+
=
buffer
[
i
]
;
}
result
.
add
(
new
SourceNode
(
bufferLine
bufferColumn
options
.
url
lineStr
)
)
;
buffer
.
splice
(
0
buffer
.
length
)
;
bufferLine
=
-
1
;
bufferColumn
=
-
1
;
}
}
;
}
(
)
)
;
var
addedNewline
=
false
;
var
token
;
var
ttl
;
var
ttk
;
var
lastToken
;
var
stack
=
[
]
;
var
tokenQueue
=
[
]
;
var
tokens
=
acorn
.
tokenizer
(
input
{
locations
:
true
sourceFile
:
options
.
url
onComment
:
function
(
block
text
start
end
startLoc
endLoc
)
{
tokenQueue
.
push
(
{
type
:
{
}
comment
:
true
block
:
block
text
:
text
loc
:
{
start
:
startLoc
end
:
endLoc
}
}
)
;
}
}
)
;
for
(
;
;
)
{
token
=
tokens
.
getToken
(
)
;
tokenQueue
.
push
(
token
)
;
if
(
token
.
type
.
label
=
=
"
eof
"
)
{
break
;
}
}
for
(
var
i
=
0
;
i
<
tokenQueue
.
length
;
i
+
+
)
{
token
=
tokenQueue
[
i
]
;
if
(
token
.
comment
)
{
var
commentIndentLevel
=
indentLevel
;
if
(
lastToken
&
&
(
lastToken
.
loc
.
end
.
line
=
=
token
.
loc
.
start
.
line
)
)
{
commentIndentLevel
=
0
;
write
(
"
"
)
;
}
addComment
(
write
commentIndentLevel
options
token
.
block
token
.
text
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
addedNewline
=
true
;
continue
;
}
ttk
=
token
.
type
.
keyword
;
ttl
=
token
.
type
.
label
;
if
(
ttl
=
=
"
eof
"
)
{
if
(
!
addedNewline
)
{
write
(
"
\
n
"
)
;
}
break
;
}
token
.
isArrayLiteral
=
isArrayLiteral
(
token
lastToken
)
;
if
(
belongsOnStack
(
token
)
)
{
if
(
token
.
isArrayLiteral
)
{
stack
.
push
(
"
[
\
n
"
)
;
}
else
{
stack
.
push
(
ttl
|
|
ttk
)
;
}
}
if
(
decrementsIndent
(
ttl
stack
)
)
{
indentLevel
-
-
;
if
(
ttl
=
=
"
}
"
&
&
stack
.
length
>
1
&
&
stack
[
stack
.
length
-
2
]
=
=
"
switch
"
)
{
indentLevel
-
-
;
}
}
prependWhiteSpace
(
token
lastToken
addedNewline
write
options
indentLevel
stack
)
;
addToken
(
token
write
)
;
var
nextToken
=
tokenQueue
[
i
+
1
]
;
if
(
!
nextToken
|
|
!
nextToken
.
comment
|
|
token
.
loc
.
end
.
line
!
=
nextToken
.
loc
.
start
.
line
)
{
addedNewline
=
appendNewline
(
token
write
stack
)
;
}
if
(
shouldStackPop
(
token
stack
)
)
{
stack
.
pop
(
)
;
if
(
token
=
=
"
}
"
&
&
stack
.
length
&
&
stack
[
stack
.
length
-
1
]
=
=
"
switch
"
)
{
stack
.
pop
(
)
;
}
}
if
(
incrementsIndent
(
token
)
)
{
indentLevel
+
+
;
}
if
(
!
lastToken
)
{
lastToken
=
{
loc
:
{
start
:
{
}
end
:
{
}
}
}
;
}
lastToken
.
start
=
token
.
start
;
lastToken
.
end
=
token
.
end
;
lastToken
.
loc
.
start
.
line
=
token
.
loc
.
start
.
line
;
lastToken
.
loc
.
start
.
column
=
token
.
loc
.
start
.
column
;
lastToken
.
loc
.
end
.
line
=
token
.
loc
.
end
.
line
;
lastToken
.
loc
.
end
.
column
=
token
.
loc
.
end
.
column
;
lastToken
.
type
=
token
.
type
;
lastToken
.
value
=
token
.
value
;
lastToken
.
isArrayLiteral
=
token
.
isArrayLiteral
;
}
return
result
.
toStringWithSourceMap
(
{
file
:
options
.
url
}
)
;
}
;
}
.
bind
(
this
)
)
)
;
}
)
815
:
(
function
(
module
exports
__webpack_require__
)
{
exports
.
SourceMapGenerator
=
__webpack_require__
(
816
)
.
SourceMapGenerator
;
exports
.
SourceMapConsumer
=
__webpack_require__
(
822
)
.
SourceMapConsumer
;
exports
.
SourceNode
=
__webpack_require__
(
825
)
.
SourceNode
;
}
)
816
:
(
function
(
module
exports
__webpack_require__
)
{
var
base64VLQ
=
__webpack_require__
(
817
)
;
var
util
=
__webpack_require__
(
819
)
;
var
ArraySet
=
__webpack_require__
(
820
)
.
ArraySet
;
var
MappingList
=
__webpack_require__
(
821
)
.
MappingList
;
function
SourceMapGenerator
(
aArgs
)
{
if
(
!
aArgs
)
{
aArgs
=
{
}
;
}
this
.
_file
=
util
.
getArg
(
aArgs
'
file
'
null
)
;
this
.
_sourceRoot
=
util
.
getArg
(
aArgs
'
sourceRoot
'
null
)
;
this
.
_skipValidation
=
util
.
getArg
(
aArgs
'
skipValidation
'
false
)
;
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
this
.
_mappings
=
new
MappingList
(
)
;
this
.
_sourcesContents
=
null
;
}
SourceMapGenerator
.
prototype
.
_version
=
3
;
SourceMapGenerator
.
fromSourceMap
=
function
SourceMapGenerator_fromSourceMap
(
aSourceMapConsumer
)
{
var
sourceRoot
=
aSourceMapConsumer
.
sourceRoot
;
var
generator
=
new
SourceMapGenerator
(
{
file
:
aSourceMapConsumer
.
file
sourceRoot
:
sourceRoot
}
)
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
var
newMapping
=
{
generated
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
generatedColumn
}
}
;
if
(
mapping
.
source
!
=
null
)
{
newMapping
.
source
=
mapping
.
source
;
if
(
sourceRoot
!
=
null
)
{
newMapping
.
source
=
util
.
relative
(
sourceRoot
newMapping
.
source
)
;
}
newMapping
.
original
=
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
;
if
(
mapping
.
name
!
=
null
)
{
newMapping
.
name
=
mapping
.
name
;
}
}
generator
.
addMapping
(
newMapping
)
;
}
)
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
generator
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
generator
;
}
;
SourceMapGenerator
.
prototype
.
addMapping
=
function
SourceMapGenerator_addMapping
(
aArgs
)
{
var
generated
=
util
.
getArg
(
aArgs
'
generated
'
)
;
var
original
=
util
.
getArg
(
aArgs
'
original
'
null
)
;
var
source
=
util
.
getArg
(
aArgs
'
source
'
null
)
;
var
name
=
util
.
getArg
(
aArgs
'
name
'
null
)
;
if
(
!
this
.
_skipValidation
)
{
this
.
_validateMapping
(
generated
original
source
name
)
;
}
if
(
source
!
=
null
)
{
source
=
String
(
source
)
;
if
(
!
this
.
_sources
.
has
(
source
)
)
{
this
.
_sources
.
add
(
source
)
;
}
}
if
(
name
!
=
null
)
{
name
=
String
(
name
)
;
if
(
!
this
.
_names
.
has
(
name
)
)
{
this
.
_names
.
add
(
name
)
;
}
}
this
.
_mappings
.
add
(
{
generatedLine
:
generated
.
line
generatedColumn
:
generated
.
column
originalLine
:
original
!
=
null
&
&
original
.
line
originalColumn
:
original
!
=
null
&
&
original
.
column
source
:
source
name
:
name
}
)
;
}
;
SourceMapGenerator
.
prototype
.
setSourceContent
=
function
SourceMapGenerator_setSourceContent
(
aSourceFile
aSourceContent
)
{
var
source
=
aSourceFile
;
if
(
this
.
_sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
_sourceRoot
source
)
;
}
if
(
aSourceContent
!
=
null
)
{
if
(
!
this
.
_sourcesContents
)
{
this
.
_sourcesContents
=
Object
.
create
(
null
)
;
}
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
=
aSourceContent
;
}
else
if
(
this
.
_sourcesContents
)
{
delete
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
;
if
(
Object
.
keys
(
this
.
_sourcesContents
)
.
length
=
=
=
0
)
{
this
.
_sourcesContents
=
null
;
}
}
}
;
SourceMapGenerator
.
prototype
.
applySourceMap
=
function
SourceMapGenerator_applySourceMap
(
aSourceMapConsumer
aSourceFile
aSourceMapPath
)
{
var
sourceFile
=
aSourceFile
;
if
(
aSourceFile
=
=
null
)
{
if
(
aSourceMapConsumer
.
file
=
=
null
)
{
throw
new
Error
(
'
SourceMapGenerator
.
prototype
.
applySourceMap
requires
either
an
explicit
source
file
'
+
'
or
the
source
map
\
'
s
"
file
"
property
.
Both
were
omitted
.
'
)
;
}
sourceFile
=
aSourceMapConsumer
.
file
;
}
var
sourceRoot
=
this
.
_sourceRoot
;
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
var
newSources
=
new
ArraySet
(
)
;
var
newNames
=
new
ArraySet
(
)
;
this
.
_mappings
.
unsortedForEach
(
function
(
mapping
)
{
if
(
mapping
.
source
=
=
=
sourceFile
&
&
mapping
.
originalLine
!
=
null
)
{
var
original
=
aSourceMapConsumer
.
originalPositionFor
(
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
)
;
if
(
original
.
source
!
=
null
)
{
mapping
.
source
=
original
.
source
;
if
(
aSourceMapPath
!
=
null
)
{
mapping
.
source
=
util
.
join
(
aSourceMapPath
mapping
.
source
)
}
if
(
sourceRoot
!
=
null
)
{
mapping
.
source
=
util
.
relative
(
sourceRoot
mapping
.
source
)
;
}
mapping
.
originalLine
=
original
.
line
;
mapping
.
originalColumn
=
original
.
column
;
if
(
original
.
name
!
=
null
)
{
mapping
.
name
=
original
.
name
;
}
}
}
var
source
=
mapping
.
source
;
if
(
source
!
=
null
&
&
!
newSources
.
has
(
source
)
)
{
newSources
.
add
(
source
)
;
}
var
name
=
mapping
.
name
;
if
(
name
!
=
null
&
&
!
newNames
.
has
(
name
)
)
{
newNames
.
add
(
name
)
;
}
}
this
)
;
this
.
_sources
=
newSources
;
this
.
_names
=
newNames
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aSourceMapPath
!
=
null
)
{
sourceFile
=
util
.
join
(
aSourceMapPath
sourceFile
)
;
}
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
this
.
setSourceContent
(
sourceFile
content
)
;
}
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
_validateMapping
=
function
SourceMapGenerator_validateMapping
(
aGenerated
aOriginal
aSource
aName
)
{
if
(
aOriginal
&
&
typeof
aOriginal
.
line
!
=
=
'
number
'
&
&
typeof
aOriginal
.
column
!
=
=
'
number
'
)
{
throw
new
Error
(
'
original
.
line
and
original
.
column
are
not
numbers
-
-
you
probably
meant
to
omit
'
+
'
the
original
mapping
entirely
and
only
map
the
generated
position
.
If
so
pass
'
+
'
null
for
the
original
mapping
instead
of
an
object
with
empty
or
null
values
.
'
)
;
}
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
!
aOriginal
&
&
!
aSource
&
&
!
aName
)
{
return
;
}
else
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aOriginal
&
&
'
line
'
in
aOriginal
&
&
'
column
'
in
aOriginal
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
aOriginal
.
line
>
0
&
&
aOriginal
.
column
>
=
0
&
&
aSource
)
{
return
;
}
else
{
throw
new
Error
(
'
Invalid
mapping
:
'
+
JSON
.
stringify
(
{
generated
:
aGenerated
source
:
aSource
original
:
aOriginal
name
:
aName
}
)
)
;
}
}
;
SourceMapGenerator
.
prototype
.
_serializeMappings
=
function
SourceMapGenerator_serializeMappings
(
)
{
var
previousGeneratedColumn
=
0
;
var
previousGeneratedLine
=
1
;
var
previousOriginalColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousName
=
0
;
var
previousSource
=
0
;
var
result
=
'
'
;
var
next
;
var
mapping
;
var
nameIdx
;
var
sourceIdx
;
var
mappings
=
this
.
_mappings
.
toArray
(
)
;
for
(
var
i
=
0
len
=
mappings
.
length
;
i
<
len
;
i
+
+
)
{
mapping
=
mappings
[
i
]
;
next
=
'
'
if
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
previousGeneratedColumn
=
0
;
while
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
next
+
=
'
;
'
;
previousGeneratedLine
+
+
;
}
}
else
{
if
(
i
>
0
)
{
if
(
!
util
.
compareByGeneratedPositionsInflated
(
mapping
mappings
[
i
-
1
]
)
)
{
continue
;
}
next
+
=
'
'
;
}
}
next
+
=
base64VLQ
.
encode
(
mapping
.
generatedColumn
-
previousGeneratedColumn
)
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
mapping
.
source
!
=
null
)
{
sourceIdx
=
this
.
_sources
.
indexOf
(
mapping
.
source
)
;
next
+
=
base64VLQ
.
encode
(
sourceIdx
-
previousSource
)
;
previousSource
=
sourceIdx
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalLine
-
1
-
previousOriginalLine
)
;
previousOriginalLine
=
mapping
.
originalLine
-
1
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalColumn
-
previousOriginalColumn
)
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
mapping
.
name
!
=
null
)
{
nameIdx
=
this
.
_names
.
indexOf
(
mapping
.
name
)
;
next
+
=
base64VLQ
.
encode
(
nameIdx
-
previousName
)
;
previousName
=
nameIdx
;
}
}
result
+
=
next
;
}
return
result
;
}
;
SourceMapGenerator
.
prototype
.
_generateSourcesContent
=
function
SourceMapGenerator_generateSourcesContent
(
aSources
aSourceRoot
)
{
return
aSources
.
map
(
function
(
source
)
{
if
(
!
this
.
_sourcesContents
)
{
return
null
;
}
if
(
aSourceRoot
!
=
null
)
{
source
=
util
.
relative
(
aSourceRoot
source
)
;
}
var
key
=
util
.
toSetString
(
source
)
;
return
Object
.
prototype
.
hasOwnProperty
.
call
(
this
.
_sourcesContents
key
)
?
this
.
_sourcesContents
[
key
]
:
null
;
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
toJSON
=
function
SourceMapGenerator_toJSON
(
)
{
var
map
=
{
version
:
this
.
_version
sources
:
this
.
_sources
.
toArray
(
)
names
:
this
.
_names
.
toArray
(
)
mappings
:
this
.
_serializeMappings
(
)
}
;
if
(
this
.
_file
!
=
null
)
{
map
.
file
=
this
.
_file
;
}
if
(
this
.
_sourceRoot
!
=
null
)
{
map
.
sourceRoot
=
this
.
_sourceRoot
;
}
if
(
this
.
_sourcesContents
)
{
map
.
sourcesContent
=
this
.
_generateSourcesContent
(
map
.
sources
map
.
sourceRoot
)
;
}
return
map
;
}
;
SourceMapGenerator
.
prototype
.
toString
=
function
SourceMapGenerator_toString
(
)
{
return
JSON
.
stringify
(
this
.
toJSON
(
)
)
;
}
;
exports
.
SourceMapGenerator
=
SourceMapGenerator
;
}
)
817
:
(
function
(
module
exports
__webpack_require__
)
{
var
base64
=
__webpack_require__
(
818
)
;
var
VLQ_BASE_SHIFT
=
5
;
var
VLQ_BASE
=
1
<
<
VLQ_BASE_SHIFT
;
var
VLQ_BASE_MASK
=
VLQ_BASE
-
1
;
var
VLQ_CONTINUATION_BIT
=
VLQ_BASE
;
function
toVLQSigned
(
aValue
)
{
return
aValue
<
0
?
(
(
-
aValue
)
<
<
1
)
+
1
:
(
aValue
<
<
1
)
+
0
;
}
function
fromVLQSigned
(
aValue
)
{
var
isNegative
=
(
aValue
&
1
)
=
=
=
1
;
var
shifted
=
aValue
>
>
1
;
return
isNegative
?
-
shifted
:
shifted
;
}
exports
.
encode
=
function
base64VLQ_encode
(
aValue
)
{
var
encoded
=
"
"
;
var
digit
;
var
vlq
=
toVLQSigned
(
aValue
)
;
do
{
digit
=
vlq
&
VLQ_BASE_MASK
;
vlq
>
>
>
=
VLQ_BASE_SHIFT
;
if
(
vlq
>
0
)
{
digit
|
=
VLQ_CONTINUATION_BIT
;
}
encoded
+
=
base64
.
encode
(
digit
)
;
}
while
(
vlq
>
0
)
;
return
encoded
;
}
;
exports
.
decode
=
function
base64VLQ_decode
(
aStr
aIndex
aOutParam
)
{
var
strLen
=
aStr
.
length
;
var
result
=
0
;
var
shift
=
0
;
var
continuation
digit
;
do
{
if
(
aIndex
>
=
strLen
)
{
throw
new
Error
(
"
Expected
more
digits
in
base
64
VLQ
value
.
"
)
;
}
digit
=
base64
.
decode
(
aStr
.
charCodeAt
(
aIndex
+
+
)
)
;
if
(
digit
=
=
=
-
1
)
{
throw
new
Error
(
"
Invalid
base64
digit
:
"
+
aStr
.
charAt
(
aIndex
-
1
)
)
;
}
continuation
=
!
!
(
digit
&
VLQ_CONTINUATION_BIT
)
;
digit
&
=
VLQ_BASE_MASK
;
result
=
result
+
(
digit
<
<
shift
)
;
shift
+
=
VLQ_BASE_SHIFT
;
}
while
(
continuation
)
;
aOutParam
.
value
=
fromVLQSigned
(
result
)
;
aOutParam
.
rest
=
aIndex
;
}
;
}
)
818
:
(
function
(
module
exports
)
{
var
intToCharMap
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
.
split
(
'
'
)
;
exports
.
encode
=
function
(
number
)
{
if
(
0
<
=
number
&
&
number
<
intToCharMap
.
length
)
{
return
intToCharMap
[
number
]
;
}
throw
new
TypeError
(
"
Must
be
between
0
and
63
:
"
+
number
)
;
}
;
exports
.
decode
=
function
(
charCode
)
{
var
bigA
=
65
;
var
bigZ
=
90
;
var
littleA
=
97
;
var
littleZ
=
122
;
var
zero
=
48
;
var
nine
=
57
;
var
plus
=
43
;
var
slash
=
47
;
var
littleOffset
=
26
;
var
numberOffset
=
52
;
if
(
bigA
<
=
charCode
&
&
charCode
<
=
bigZ
)
{
return
(
charCode
-
bigA
)
;
}
if
(
littleA
<
=
charCode
&
&
charCode
<
=
littleZ
)
{
return
(
charCode
-
littleA
+
littleOffset
)
;
}
if
(
zero
<
=
charCode
&
&
charCode
<
=
nine
)
{
return
(
charCode
-
zero
+
numberOffset
)
;
}
if
(
charCode
=
=
plus
)
{
return
62
;
}
if
(
charCode
=
=
slash
)
{
return
63
;
}
return
-
1
;
}
;
}
)
819
:
(
function
(
module
exports
)
{
function
getArg
(
aArgs
aName
aDefaultValue
)
{
if
(
aName
in
aArgs
)
{
return
aArgs
[
aName
]
;
}
else
if
(
arguments
.
length
=
=
=
3
)
{
return
aDefaultValue
;
}
else
{
throw
new
Error
(
'
"
'
+
aName
+
'
"
is
a
required
argument
.
'
)
;
}
}
exports
.
getArg
=
getArg
;
var
urlRegexp
=
/
^
(
?
:
(
[
\
w
+
\
-
.
]
+
)
:
)
?
\
/
\
/
(
?
:
(
\
w
+
:
\
w
+
)
)
?
(
[
\
w
.
]
*
)
(
?
:
:
(
\
d
+
)
)
?
(
\
S
*
)
/
;
var
dataUrlRegexp
=
/
^
data
:
.
+
\
.
+
/
;
function
urlParse
(
aUrl
)
{
var
match
=
aUrl
.
match
(
urlRegexp
)
;
if
(
!
match
)
{
return
null
;
}
return
{
scheme
:
match
[
1
]
auth
:
match
[
2
]
host
:
match
[
3
]
port
:
match
[
4
]
path
:
match
[
5
]
}
;
}
exports
.
urlParse
=
urlParse
;
function
urlGenerate
(
aParsedUrl
)
{
var
url
=
'
'
;
if
(
aParsedUrl
.
scheme
)
{
url
+
=
aParsedUrl
.
scheme
+
'
:
'
;
}
url
+
=
'
/
/
'
;
if
(
aParsedUrl
.
auth
)
{
url
+
=
aParsedUrl
.
auth
+
'
'
;
}
if
(
aParsedUrl
.
host
)
{
url
+
=
aParsedUrl
.
host
;
}
if
(
aParsedUrl
.
port
)
{
url
+
=
"
:
"
+
aParsedUrl
.
port
}
if
(
aParsedUrl
.
path
)
{
url
+
=
aParsedUrl
.
path
;
}
return
url
;
}
exports
.
urlGenerate
=
urlGenerate
;
function
normalize
(
aPath
)
{
var
path
=
aPath
;
var
url
=
urlParse
(
aPath
)
;
if
(
url
)
{
if
(
!
url
.
path
)
{
return
aPath
;
}
path
=
url
.
path
;
}
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
;
var
parts
=
path
.
split
(
/
\
/
+
/
)
;
for
(
var
part
up
=
0
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
part
=
parts
[
i
]
;
if
(
part
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
part
=
=
=
'
.
.
'
)
{
up
+
+
;
}
else
if
(
up
>
0
)
{
if
(
part
=
=
=
'
'
)
{
parts
.
splice
(
i
+
1
up
)
;
up
=
0
;
}
else
{
parts
.
splice
(
i
2
)
;
up
-
-
;
}
}
}
path
=
parts
.
join
(
'
/
'
)
;
if
(
path
=
=
=
'
'
)
{
path
=
isAbsolute
?
'
/
'
:
'
.
'
;
}
if
(
url
)
{
url
.
path
=
path
;
return
urlGenerate
(
url
)
;
}
return
path
;
}
exports
.
normalize
=
normalize
;
function
join
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
if
(
aPath
=
=
=
"
"
)
{
aPath
=
"
.
"
;
}
var
aPathUrl
=
urlParse
(
aPath
)
;
var
aRootUrl
=
urlParse
(
aRoot
)
;
if
(
aRootUrl
)
{
aRoot
=
aRootUrl
.
path
|
|
'
/
'
;
}
if
(
aPathUrl
&
&
!
aPathUrl
.
scheme
)
{
if
(
aRootUrl
)
{
aPathUrl
.
scheme
=
aRootUrl
.
scheme
;
}
return
urlGenerate
(
aPathUrl
)
;
}
if
(
aPathUrl
|
|
aPath
.
match
(
dataUrlRegexp
)
)
{
return
aPath
;
}
if
(
aRootUrl
&
&
!
aRootUrl
.
host
&
&
!
aRootUrl
.
path
)
{
aRootUrl
.
host
=
aPath
;
return
urlGenerate
(
aRootUrl
)
;
}
var
joined
=
aPath
.
charAt
(
0
)
=
=
=
'
/
'
?
aPath
:
normalize
(
aRoot
.
replace
(
/
\
/
+
/
'
'
)
+
'
/
'
+
aPath
)
;
if
(
aRootUrl
)
{
aRootUrl
.
path
=
joined
;
return
urlGenerate
(
aRootUrl
)
;
}
return
joined
;
}
exports
.
join
=
join
;
exports
.
isAbsolute
=
function
(
aPath
)
{
return
aPath
.
charAt
(
0
)
=
=
=
'
/
'
|
|
!
!
aPath
.
match
(
urlRegexp
)
;
}
;
function
relative
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
aRoot
=
aRoot
.
replace
(
/
\
/
/
'
'
)
;
var
level
=
0
;
while
(
aPath
.
indexOf
(
aRoot
+
'
/
'
)
!
=
=
0
)
{
var
index
=
aRoot
.
lastIndexOf
(
"
/
"
)
;
if
(
index
<
0
)
{
return
aPath
;
}
aRoot
=
aRoot
.
slice
(
0
index
)
;
if
(
aRoot
.
match
(
/
^
(
[
^
\
/
]
+
:
\
/
)
?
\
/
*
/
)
)
{
return
aPath
;
}
+
+
level
;
}
return
Array
(
level
+
1
)
.
join
(
"
.
.
/
"
)
+
aPath
.
substr
(
aRoot
.
length
+
1
)
;
}
exports
.
relative
=
relative
;
var
supportsNullProto
=
(
function
(
)
{
var
obj
=
Object
.
create
(
null
)
;
return
!
(
'
__proto__
'
in
obj
)
;
}
(
)
)
;
function
identity
(
s
)
{
return
s
;
}
function
toSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
'
'
+
aStr
;
}
return
aStr
;
}
exports
.
toSetString
=
supportsNullProto
?
identity
:
toSetString
;
function
fromSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
aStr
.
slice
(
1
)
;
}
return
aStr
;
}
exports
.
fromSetString
=
supportsNullProto
?
identity
:
fromSetString
;
function
isProtoString
(
s
)
{
if
(
!
s
)
{
return
false
;
}
var
length
=
s
.
length
;
if
(
length
<
9
)
{
return
false
;
}
if
(
s
.
charCodeAt
(
length
-
1
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
2
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
3
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
4
)
!
=
=
116
|
|
s
.
charCodeAt
(
length
-
5
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
6
)
!
=
=
114
|
|
s
.
charCodeAt
(
length
-
7
)
!
=
=
112
|
|
s
.
charCodeAt
(
length
-
8
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
9
)
!
=
=
95
)
{
return
false
;
}
for
(
var
i
=
length
-
10
;
i
>
=
0
;
i
-
-
)
{
if
(
s
.
charCodeAt
(
i
)
!
=
=
36
)
{
return
false
;
}
}
return
true
;
}
function
compareByOriginalPositions
(
mappingA
mappingB
onlyCompareOriginal
)
{
var
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareOriginal
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByOriginalPositions
=
compareByOriginalPositions
;
function
compareByGeneratedPositionsDeflated
(
mappingA
mappingB
onlyCompareGenerated
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareGenerated
)
{
return
cmp
;
}
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByGeneratedPositionsDeflated
=
compareByGeneratedPositionsDeflated
;
function
strcmp
(
aStr1
aStr2
)
{
if
(
aStr1
=
=
=
aStr2
)
{
return
0
;
}
if
(
aStr1
>
aStr2
)
{
return
1
;
}
return
-
1
;
}
function
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
strcmp
(
mappingA
.
source
mappingB
.
source
)
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
strcmp
(
mappingA
.
name
mappingB
.
name
)
;
}
exports
.
compareByGeneratedPositionsInflated
=
compareByGeneratedPositionsInflated
;
}
)
820
:
(
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
819
)
;
var
has
=
Object
.
prototype
.
hasOwnProperty
;
var
hasNativeMap
=
typeof
Map
!
=
=
"
undefined
"
;
function
ArraySet
(
)
{
this
.
_array
=
[
]
;
this
.
_set
=
hasNativeMap
?
new
Map
(
)
:
Object
.
create
(
null
)
;
}
ArraySet
.
fromArray
=
function
ArraySet_fromArray
(
aArray
aAllowDuplicates
)
{
var
set
=
new
ArraySet
(
)
;
for
(
var
i
=
0
len
=
aArray
.
length
;
i
<
len
;
i
+
+
)
{
set
.
add
(
aArray
[
i
]
aAllowDuplicates
)
;
}
return
set
;
}
;
ArraySet
.
prototype
.
size
=
function
ArraySet_size
(
)
{
return
hasNativeMap
?
this
.
_set
.
size
:
Object
.
getOwnPropertyNames
(
this
.
_set
)
.
length
;
}
;
ArraySet
.
prototype
.
add
=
function
ArraySet_add
(
aStr
aAllowDuplicates
)
{
var
sStr
=
hasNativeMap
?
aStr
:
util
.
toSetString
(
aStr
)
;
var
isDuplicate
=
hasNativeMap
?
this
.
has
(
aStr
)
:
has
.
call
(
this
.
_set
sStr
)
;
var
idx
=
this
.
_array
.
length
;
if
(
!
isDuplicate
|
|
aAllowDuplicates
)
{
this
.
_array
.
push
(
aStr
)
;
}
if
(
!
isDuplicate
)
{
if
(
hasNativeMap
)
{
this
.
_set
.
set
(
aStr
idx
)
;
}
else
{
this
.
_set
[
sStr
]
=
idx
;
}
}
}
;
ArraySet
.
prototype
.
has
=
function
ArraySet_has
(
aStr
)
{
if
(
hasNativeMap
)
{
return
this
.
_set
.
has
(
aStr
)
;
}
else
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
return
has
.
call
(
this
.
_set
sStr
)
;
}
}
;
ArraySet
.
prototype
.
indexOf
=
function
ArraySet_indexOf
(
aStr
)
{
if
(
hasNativeMap
)
{
var
idx
=
this
.
_set
.
get
(
aStr
)
;
if
(
idx
>
=
0
)
{
return
idx
;
}
}
else
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
if
(
has
.
call
(
this
.
_set
sStr
)
)
{
return
this
.
_set
[
sStr
]
;
}
}
throw
new
Error
(
'
"
'
+
aStr
+
'
"
is
not
in
the
set
.
'
)
;
}
;
ArraySet
.
prototype
.
at
=
function
ArraySet_at
(
aIdx
)
{
if
(
aIdx
>
=
0
&
&
aIdx
<
this
.
_array
.
length
)
{
return
this
.
_array
[
aIdx
]
;
}
throw
new
Error
(
'
No
element
indexed
by
'
+
aIdx
)
;
}
;
ArraySet
.
prototype
.
toArray
=
function
ArraySet_toArray
(
)
{
return
this
.
_array
.
slice
(
)
;
}
;
exports
.
ArraySet
=
ArraySet
;
}
)
821
:
(
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
819
)
;
function
generatedPositionAfter
(
mappingA
mappingB
)
{
var
lineA
=
mappingA
.
generatedLine
;
var
lineB
=
mappingB
.
generatedLine
;
var
columnA
=
mappingA
.
generatedColumn
;
var
columnB
=
mappingB
.
generatedColumn
;
return
lineB
>
lineA
|
|
lineB
=
=
lineA
&
&
columnB
>
=
columnA
|
|
util
.
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
<
=
0
;
}
function
MappingList
(
)
{
this
.
_array
=
[
]
;
this
.
_sorted
=
true
;
this
.
_last
=
{
generatedLine
:
-
1
generatedColumn
:
0
}
;
}
MappingList
.
prototype
.
unsortedForEach
=
function
MappingList_forEach
(
aCallback
aThisArg
)
{
this
.
_array
.
forEach
(
aCallback
aThisArg
)
;
}
;
MappingList
.
prototype
.
add
=
function
MappingList_add
(
aMapping
)
{
if
(
generatedPositionAfter
(
this
.
_last
aMapping
)
)
{
this
.
_last
=
aMapping
;
this
.
_array
.
push
(
aMapping
)
;
}
else
{
this
.
_sorted
=
false
;
this
.
_array
.
push
(
aMapping
)
;
}
}
;
MappingList
.
prototype
.
toArray
=
function
MappingList_toArray
(
)
{
if
(
!
this
.
_sorted
)
{
this
.
_array
.
sort
(
util
.
compareByGeneratedPositionsInflated
)
;
this
.
_sorted
=
true
;
}
return
this
.
_array
;
}
;
exports
.
MappingList
=
MappingList
;
}
)
822
:
(
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
819
)
;
var
binarySearch
=
__webpack_require__
(
823
)
;
var
ArraySet
=
__webpack_require__
(
820
)
.
ArraySet
;
var
base64VLQ
=
__webpack_require__
(
817
)
;
var
quickSort
=
__webpack_require__
(
824
)
.
quickSort
;
function
SourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
return
sourceMap
.
sections
!
=
null
?
new
IndexedSourceMapConsumer
(
sourceMap
)
:
new
BasicSourceMapConsumer
(
sourceMap
)
;
}
SourceMapConsumer
.
fromSourceMap
=
function
(
aSourceMap
)
{
return
BasicSourceMapConsumer
.
fromSourceMap
(
aSourceMap
)
;
}
SourceMapConsumer
.
prototype
.
_version
=
3
;
SourceMapConsumer
.
prototype
.
__generatedMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_generatedMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__generatedMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__generatedMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
__originalMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_originalMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__originalMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__originalMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
_charIsMappingSeparator
=
function
SourceMapConsumer_charIsMappingSeparator
(
aStr
index
)
{
var
c
=
aStr
.
charAt
(
index
)
;
return
c
=
=
=
"
;
"
|
|
c
=
=
=
"
"
;
}
;
SourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
throw
new
Error
(
"
Subclasses
must
implement
_parseMappings
"
)
;
}
;
SourceMapConsumer
.
GENERATED_ORDER
=
1
;
SourceMapConsumer
.
ORIGINAL_ORDER
=
2
;
SourceMapConsumer
.
GREATEST_LOWER_BOUND
=
1
;
SourceMapConsumer
.
LEAST_UPPER_BOUND
=
2
;
SourceMapConsumer
.
prototype
.
eachMapping
=
function
SourceMapConsumer_eachMapping
(
aCallback
aContext
aOrder
)
{
var
context
=
aContext
|
|
null
;
var
order
=
aOrder
|
|
SourceMapConsumer
.
GENERATED_ORDER
;
var
mappings
;
switch
(
order
)
{
case
SourceMapConsumer
.
GENERATED_ORDER
:
mappings
=
this
.
_generatedMappings
;
break
;
case
SourceMapConsumer
.
ORIGINAL_ORDER
:
mappings
=
this
.
_originalMappings
;
break
;
default
:
throw
new
Error
(
"
Unknown
order
of
iteration
.
"
)
;
}
var
sourceRoot
=
this
.
sourceRoot
;
mappings
.
map
(
function
(
mapping
)
{
var
source
=
mapping
.
source
=
=
=
null
?
null
:
this
.
_sources
.
at
(
mapping
.
source
)
;
if
(
source
!
=
null
&
&
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
sourceRoot
source
)
;
}
return
{
source
:
source
generatedLine
:
mapping
.
generatedLine
generatedColumn
:
mapping
.
generatedColumn
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
mapping
.
name
=
=
=
null
?
null
:
this
.
_names
.
at
(
mapping
.
name
)
}
;
}
this
)
.
forEach
(
aCallback
context
)
;
}
;
SourceMapConsumer
.
prototype
.
allGeneratedPositionsFor
=
function
SourceMapConsumer_allGeneratedPositionsFor
(
aArgs
)
{
var
line
=
util
.
getArg
(
aArgs
'
line
'
)
;
var
needle
=
{
source
:
util
.
getArg
(
aArgs
'
source
'
)
originalLine
:
line
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
0
)
}
;
if
(
this
.
sourceRoot
!
=
null
)
{
needle
.
source
=
util
.
relative
(
this
.
sourceRoot
needle
.
source
)
;
}
if
(
!
this
.
_sources
.
has
(
needle
.
source
)
)
{
return
[
]
;
}
needle
.
source
=
this
.
_sources
.
indexOf
(
needle
.
source
)
;
var
mappings
=
[
]
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
binarySearch
.
LEAST_UPPER_BOUND
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
aArgs
.
column
=
=
=
undefined
)
{
var
originalLine
=
mapping
.
originalLine
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
originalLine
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
else
{
var
originalColumn
=
mapping
.
originalColumn
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
line
&
&
mapping
.
originalColumn
=
=
originalColumn
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
}
return
mappings
;
}
;
exports
.
SourceMapConsumer
=
SourceMapConsumer
;
function
BasicSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sources
=
util
.
getArg
(
sourceMap
'
sources
'
)
;
var
names
=
util
.
getArg
(
sourceMap
'
names
'
[
]
)
;
var
sourceRoot
=
util
.
getArg
(
sourceMap
'
sourceRoot
'
null
)
;
var
sourcesContent
=
util
.
getArg
(
sourceMap
'
sourcesContent
'
null
)
;
var
mappings
=
util
.
getArg
(
sourceMap
'
mappings
'
)
;
var
file
=
util
.
getArg
(
sourceMap
'
file
'
null
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
sources
=
sources
.
map
(
String
)
.
map
(
util
.
normalize
)
.
map
(
function
(
source
)
{
return
sourceRoot
&
&
util
.
isAbsolute
(
sourceRoot
)
&
&
util
.
isAbsolute
(
source
)
?
util
.
relative
(
sourceRoot
source
)
:
source
;
}
)
;
this
.
_names
=
ArraySet
.
fromArray
(
names
.
map
(
String
)
true
)
;
this
.
_sources
=
ArraySet
.
fromArray
(
sources
true
)
;
this
.
sourceRoot
=
sourceRoot
;
this
.
sourcesContent
=
sourcesContent
;
this
.
_mappings
=
mappings
;
this
.
file
=
file
;
}
BasicSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
BasicSourceMapConsumer
.
prototype
.
consumer
=
SourceMapConsumer
;
BasicSourceMapConsumer
.
fromSourceMap
=
function
SourceMapConsumer_fromSourceMap
(
aSourceMap
)
{
var
smc
=
Object
.
create
(
BasicSourceMapConsumer
.
prototype
)
;
var
names
=
smc
.
_names
=
ArraySet
.
fromArray
(
aSourceMap
.
_names
.
toArray
(
)
true
)
;
var
sources
=
smc
.
_sources
=
ArraySet
.
fromArray
(
aSourceMap
.
_sources
.
toArray
(
)
true
)
;
smc
.
sourceRoot
=
aSourceMap
.
_sourceRoot
;
smc
.
sourcesContent
=
aSourceMap
.
_generateSourcesContent
(
smc
.
_sources
.
toArray
(
)
smc
.
sourceRoot
)
;
smc
.
file
=
aSourceMap
.
_file
;
var
generatedMappings
=
aSourceMap
.
_mappings
.
toArray
(
)
.
slice
(
)
;
var
destGeneratedMappings
=
smc
.
__generatedMappings
=
[
]
;
var
destOriginalMappings
=
smc
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
length
=
generatedMappings
.
length
;
i
<
length
;
i
+
+
)
{
var
srcMapping
=
generatedMappings
[
i
]
;
var
destMapping
=
new
Mapping
;
destMapping
.
generatedLine
=
srcMapping
.
generatedLine
;
destMapping
.
generatedColumn
=
srcMapping
.
generatedColumn
;
if
(
srcMapping
.
source
)
{
destMapping
.
source
=
sources
.
indexOf
(
srcMapping
.
source
)
;
destMapping
.
originalLine
=
srcMapping
.
originalLine
;
destMapping
.
originalColumn
=
srcMapping
.
originalColumn
;
if
(
srcMapping
.
name
)
{
destMapping
.
name
=
names
.
indexOf
(
srcMapping
.
name
)
;
}
destOriginalMappings
.
push
(
destMapping
)
;
}
destGeneratedMappings
.
push
(
destMapping
)
;
}
quickSort
(
smc
.
__originalMappings
util
.
compareByOriginalPositions
)
;
return
smc
;
}
;
BasicSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
BasicSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
return
this
.
_sources
.
toArray
(
)
.
map
(
function
(
s
)
{
return
this
.
sourceRoot
!
=
null
?
util
.
join
(
this
.
sourceRoot
s
)
:
s
;
}
this
)
;
}
}
)
;
function
Mapping
(
)
{
this
.
generatedLine
=
0
;
this
.
generatedColumn
=
0
;
this
.
source
=
null
;
this
.
originalLine
=
null
;
this
.
originalColumn
=
null
;
this
.
name
=
null
;
}
BasicSourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
var
generatedLine
=
1
;
var
previousGeneratedColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousOriginalColumn
=
0
;
var
previousSource
=
0
;
var
previousName
=
0
;
var
length
=
aStr
.
length
;
var
index
=
0
;
var
cachedSegments
=
{
}
;
var
temp
=
{
}
;
var
originalMappings
=
[
]
;
var
generatedMappings
=
[
]
;
var
mapping
str
segment
end
value
;
while
(
index
<
length
)
{
if
(
aStr
.
charAt
(
index
)
=
=
=
'
;
'
)
{
generatedLine
+
+
;
index
+
+
;
previousGeneratedColumn
=
0
;
}
else
if
(
aStr
.
charAt
(
index
)
=
=
=
'
'
)
{
index
+
+
;
}
else
{
mapping
=
new
Mapping
(
)
;
mapping
.
generatedLine
=
generatedLine
;
for
(
end
=
index
;
end
<
length
;
end
+
+
)
{
if
(
this
.
_charIsMappingSeparator
(
aStr
end
)
)
{
break
;
}
}
str
=
aStr
.
slice
(
index
end
)
;
segment
=
cachedSegments
[
str
]
;
if
(
segment
)
{
index
+
=
str
.
length
;
}
else
{
segment
=
[
]
;
while
(
index
<
end
)
{
base64VLQ
.
decode
(
aStr
index
temp
)
;
value
=
temp
.
value
;
index
=
temp
.
rest
;
segment
.
push
(
value
)
;
}
if
(
segment
.
length
=
=
=
2
)
{
throw
new
Error
(
'
Found
a
source
but
no
line
and
column
'
)
;
}
if
(
segment
.
length
=
=
=
3
)
{
throw
new
Error
(
'
Found
a
source
and
line
but
no
column
'
)
;
}
cachedSegments
[
str
]
=
segment
;
}
mapping
.
generatedColumn
=
previousGeneratedColumn
+
segment
[
0
]
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
segment
.
length
>
1
)
{
mapping
.
source
=
previousSource
+
segment
[
1
]
;
previousSource
+
=
segment
[
1
]
;
mapping
.
originalLine
=
previousOriginalLine
+
segment
[
2
]
;
previousOriginalLine
=
mapping
.
originalLine
;
mapping
.
originalLine
+
=
1
;
mapping
.
originalColumn
=
previousOriginalColumn
+
segment
[
3
]
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
segment
.
length
>
4
)
{
mapping
.
name
=
previousName
+
segment
[
4
]
;
previousName
+
=
segment
[
4
]
;
}
}
generatedMappings
.
push
(
mapping
)
;
if
(
typeof
mapping
.
originalLine
=
=
=
'
number
'
)
{
originalMappings
.
push
(
mapping
)
;
}
}
}
quickSort
(
generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
this
.
__generatedMappings
=
generatedMappings
;
quickSort
(
originalMappings
util
.
compareByOriginalPositions
)
;
this
.
__originalMappings
=
originalMappings
;
}
;
BasicSourceMapConsumer
.
prototype
.
_findMapping
=
function
SourceMapConsumer_findMapping
(
aNeedle
aMappings
aLineName
aColumnName
aComparator
aBias
)
{
if
(
aNeedle
[
aLineName
]
<
=
0
)
{
throw
new
TypeError
(
'
Line
must
be
greater
than
or
equal
to
1
got
'
+
aNeedle
[
aLineName
]
)
;
}
if
(
aNeedle
[
aColumnName
]
<
0
)
{
throw
new
TypeError
(
'
Column
must
be
greater
than
or
equal
to
0
got
'
+
aNeedle
[
aColumnName
]
)
;
}
return
binarySearch
.
search
(
aNeedle
aMappings
aComparator
aBias
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
computeColumnSpans
=
function
SourceMapConsumer_computeColumnSpans
(
)
{
for
(
var
index
=
0
;
index
<
this
.
_generatedMappings
.
length
;
+
+
index
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
index
+
1
<
this
.
_generatedMappings
.
length
)
{
var
nextMapping
=
this
.
_generatedMappings
[
index
+
1
]
;
if
(
mapping
.
generatedLine
=
=
=
nextMapping
.
generatedLine
)
{
mapping
.
lastGeneratedColumn
=
nextMapping
.
generatedColumn
-
1
;
continue
;
}
}
mapping
.
lastGeneratedColumn
=
Infinity
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
SourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_generatedMappings
"
generatedLine
"
"
generatedColumn
"
util
.
compareByGeneratedPositionsDeflated
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
mapping
.
generatedLine
=
=
=
needle
.
generatedLine
)
{
var
source
=
util
.
getArg
(
mapping
'
source
'
null
)
;
if
(
source
!
=
=
null
)
{
source
=
this
.
_sources
.
at
(
source
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
this
.
sourceRoot
source
)
;
}
}
var
name
=
util
.
getArg
(
mapping
'
name
'
null
)
;
if
(
name
!
=
=
null
)
{
name
=
this
.
_names
.
at
(
name
)
;
}
return
{
source
:
source
line
:
util
.
getArg
(
mapping
'
originalLine
'
null
)
column
:
util
.
getArg
(
mapping
'
originalColumn
'
null
)
name
:
name
}
;
}
}
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
;
BasicSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
BasicSourceMapConsumer_hasContentsOfAllSources
(
)
{
if
(
!
this
.
sourcesContent
)
{
return
false
;
}
return
this
.
sourcesContent
.
length
>
=
this
.
_sources
.
size
(
)
&
&
!
this
.
sourcesContent
.
some
(
function
(
sc
)
{
return
sc
=
=
null
;
}
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
SourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
if
(
!
this
.
sourcesContent
)
{
return
null
;
}
if
(
this
.
sourceRoot
!
=
null
)
{
aSource
=
util
.
relative
(
this
.
sourceRoot
aSource
)
;
}
if
(
this
.
_sources
.
has
(
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
aSource
)
]
;
}
var
url
;
if
(
this
.
sourceRoot
!
=
null
&
&
(
url
=
util
.
urlParse
(
this
.
sourceRoot
)
)
)
{
var
fileUriAbsPath
=
aSource
.
replace
(
/
^
file
:
\
/
\
/
/
"
"
)
;
if
(
url
.
scheme
=
=
"
file
"
&
&
this
.
_sources
.
has
(
fileUriAbsPath
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
fileUriAbsPath
)
]
}
if
(
(
!
url
.
path
|
|
url
.
path
=
=
"
/
"
)
&
&
this
.
_sources
.
has
(
"
/
"
+
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
"
/
"
+
aSource
)
]
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
SourceMapConsumer_generatedPositionFor
(
aArgs
)
{
var
source
=
util
.
getArg
(
aArgs
'
source
'
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
sourceRoot
source
)
;
}
if
(
!
this
.
_sources
.
has
(
source
)
)
{
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
needle
=
{
source
:
source
originalLine
:
util
.
getArg
(
aArgs
'
line
'
)
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
mapping
.
source
=
=
=
needle
.
source
)
{
return
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
;
}
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
;
exports
.
BasicSourceMapConsumer
=
BasicSourceMapConsumer
;
function
IndexedSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sections
=
util
.
getArg
(
sourceMap
'
sections
'
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
var
lastOffset
=
{
line
:
-
1
column
:
0
}
;
this
.
_sections
=
sections
.
map
(
function
(
s
)
{
if
(
s
.
url
)
{
throw
new
Error
(
'
Support
for
url
field
in
sections
not
implemented
.
'
)
;
}
var
offset
=
util
.
getArg
(
s
'
offset
'
)
;
var
offsetLine
=
util
.
getArg
(
offset
'
line
'
)
;
var
offsetColumn
=
util
.
getArg
(
offset
'
column
'
)
;
if
(
offsetLine
<
lastOffset
.
line
|
|
(
offsetLine
=
=
=
lastOffset
.
line
&
&
offsetColumn
<
lastOffset
.
column
)
)
{
throw
new
Error
(
'
Section
offsets
must
be
ordered
and
non
-
overlapping
.
'
)
;
}
lastOffset
=
offset
;
return
{
generatedOffset
:
{
generatedLine
:
offsetLine
+
1
generatedColumn
:
offsetColumn
+
1
}
consumer
:
new
SourceMapConsumer
(
util
.
getArg
(
s
'
map
'
)
)
}
}
)
;
}
IndexedSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
IndexedSourceMapConsumer
.
prototype
.
constructor
=
SourceMapConsumer
;
IndexedSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
IndexedSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
var
sources
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
this
.
_sections
[
i
]
.
consumer
.
sources
.
length
;
j
+
+
)
{
sources
.
push
(
this
.
_sections
[
i
]
.
consumer
.
sources
[
j
]
)
;
}
}
return
sources
;
}
}
)
;
IndexedSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
IndexedSourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
sectionIndex
=
binarySearch
.
search
(
needle
this
.
_sections
function
(
needle
section
)
{
var
cmp
=
needle
.
generatedLine
-
section
.
generatedOffset
.
generatedLine
;
if
(
cmp
)
{
return
cmp
;
}
return
(
needle
.
generatedColumn
-
section
.
generatedOffset
.
generatedColumn
)
;
}
)
;
var
section
=
this
.
_sections
[
sectionIndex
]
;
if
(
!
section
)
{
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
return
section
.
consumer
.
originalPositionFor
(
{
line
:
needle
.
generatedLine
-
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
needle
.
generatedColumn
-
(
section
.
generatedOffset
.
generatedLine
=
=
=
needle
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
bias
:
aArgs
.
bias
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
IndexedSourceMapConsumer_hasContentsOfAllSources
(
)
{
return
this
.
_sections
.
every
(
function
(
s
)
{
return
s
.
consumer
.
hasContentsOfAllSources
(
)
;
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
IndexedSourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
content
=
section
.
consumer
.
sourceContentFor
(
aSource
true
)
;
if
(
content
)
{
return
content
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
IndexedSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
IndexedSourceMapConsumer_generatedPositionFor
(
aArgs
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
if
(
section
.
consumer
.
sources
.
indexOf
(
util
.
getArg
(
aArgs
'
source
'
)
)
=
=
=
-
1
)
{
continue
;
}
var
generatedPosition
=
section
.
consumer
.
generatedPositionFor
(
aArgs
)
;
if
(
generatedPosition
)
{
var
ret
=
{
line
:
generatedPosition
.
line
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
generatedPosition
.
column
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
generatedPosition
.
line
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
}
;
return
ret
;
}
}
return
{
line
:
null
column
:
null
}
;
}
;
IndexedSourceMapConsumer
.
prototype
.
_parseMappings
=
function
IndexedSourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
this
.
__generatedMappings
=
[
]
;
this
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
sectionMappings
=
section
.
consumer
.
_generatedMappings
;
for
(
var
j
=
0
;
j
<
sectionMappings
.
length
;
j
+
+
)
{
var
mapping
=
sectionMappings
[
j
]
;
var
source
=
section
.
consumer
.
_sources
.
at
(
mapping
.
source
)
;
if
(
section
.
consumer
.
sourceRoot
!
=
=
null
)
{
source
=
util
.
join
(
section
.
consumer
.
sourceRoot
source
)
;
}
this
.
_sources
.
add
(
source
)
;
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
name
=
section
.
consumer
.
_names
.
at
(
mapping
.
name
)
;
this
.
_names
.
add
(
name
)
;
name
=
this
.
_names
.
indexOf
(
name
)
;
var
adjustedMapping
=
{
source
:
source
generatedLine
:
mapping
.
generatedLine
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
generatedColumn
:
mapping
.
generatedColumn
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
mapping
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
name
}
;
this
.
__generatedMappings
.
push
(
adjustedMapping
)
;
if
(
typeof
adjustedMapping
.
originalLine
=
=
=
'
number
'
)
{
this
.
__originalMappings
.
push
(
adjustedMapping
)
;
}
}
}
quickSort
(
this
.
__generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
quickSort
(
this
.
__originalMappings
util
.
compareByOriginalPositions
)
;
}
;
exports
.
IndexedSourceMapConsumer
=
IndexedSourceMapConsumer
;
}
)
823
:
(
function
(
module
exports
)
{
exports
.
GREATEST_LOWER_BOUND
=
1
;
exports
.
LEAST_UPPER_BOUND
=
2
;
function
recursiveSearch
(
aLow
aHigh
aNeedle
aHaystack
aCompare
aBias
)
{
var
mid
=
Math
.
floor
(
(
aHigh
-
aLow
)
/
2
)
+
aLow
;
var
cmp
=
aCompare
(
aNeedle
aHaystack
[
mid
]
true
)
;
if
(
cmp
=
=
=
0
)
{
return
mid
;
}
else
if
(
cmp
>
0
)
{
if
(
aHigh
-
mid
>
1
)
{
return
recursiveSearch
(
mid
aHigh
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
aHigh
<
aHaystack
.
length
?
aHigh
:
-
1
;
}
else
{
return
mid
;
}
}
else
{
if
(
mid
-
aLow
>
1
)
{
return
recursiveSearch
(
aLow
mid
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
mid
;
}
else
{
return
aLow
<
0
?
-
1
:
aLow
;
}
}
}
exports
.
search
=
function
search
(
aNeedle
aHaystack
aCompare
aBias
)
{
if
(
aHaystack
.
length
=
=
=
0
)
{
return
-
1
;
}
var
index
=
recursiveSearch
(
-
1
aHaystack
.
length
aNeedle
aHaystack
aCompare
aBias
|
|
exports
.
GREATEST_LOWER_BOUND
)
;
if
(
index
<
0
)
{
return
-
1
;
}
while
(
index
-
1
>
=
0
)
{
if
(
aCompare
(
aHaystack
[
index
]
aHaystack
[
index
-
1
]
true
)
!
=
=
0
)
{
break
;
}
-
-
index
;
}
return
index
;
}
;
}
)
824
:
(
function
(
module
exports
)
{
function
swap
(
ary
x
y
)
{
var
temp
=
ary
[
x
]
;
ary
[
x
]
=
ary
[
y
]
;
ary
[
y
]
=
temp
;
}
function
randomIntInRange
(
low
high
)
{
return
Math
.
round
(
low
+
(
Math
.
random
(
)
*
(
high
-
low
)
)
)
;
}
function
doQuickSort
(
ary
comparator
p
r
)
{
if
(
p
<
r
)
{
var
pivotIndex
=
randomIntInRange
(
p
r
)
;
var
i
=
p
-
1
;
swap
(
ary
pivotIndex
r
)
;
var
pivot
=
ary
[
r
]
;
for
(
var
j
=
p
;
j
<
r
;
j
+
+
)
{
if
(
comparator
(
ary
[
j
]
pivot
)
<
=
0
)
{
i
+
=
1
;
swap
(
ary
i
j
)
;
}
}
swap
(
ary
i
+
1
j
)
;
var
q
=
i
+
1
;
doQuickSort
(
ary
comparator
p
q
-
1
)
;
doQuickSort
(
ary
comparator
q
+
1
r
)
;
}
}
exports
.
quickSort
=
function
(
ary
comparator
)
{
doQuickSort
(
ary
comparator
0
ary
.
length
-
1
)
;
}
;
}
)
825
:
(
function
(
module
exports
__webpack_require__
)
{
var
SourceMapGenerator
=
__webpack_require__
(
816
)
.
SourceMapGenerator
;
var
util
=
__webpack_require__
(
819
)
;
var
REGEX_NEWLINE
=
/
(
\
r
?
\
n
)
/
;
var
NEWLINE_CODE
=
10
;
var
isSourceNode
=
"
isSourceNode
"
;
function
SourceNode
(
aLine
aColumn
aSource
aChunks
aName
)
{
this
.
children
=
[
]
;
this
.
sourceContents
=
{
}
;
this
.
line
=
aLine
=
=
null
?
null
:
aLine
;
this
.
column
=
aColumn
=
=
null
?
null
:
aColumn
;
this
.
source
=
aSource
=
=
null
?
null
:
aSource
;
this
.
name
=
aName
=
=
null
?
null
:
aName
;
this
[
isSourceNode
]
=
true
;
if
(
aChunks
!
=
null
)
this
.
add
(
aChunks
)
;
}
SourceNode
.
fromStringWithSourceMap
=
function
SourceNode_fromStringWithSourceMap
(
aGeneratedCode
aSourceMapConsumer
aRelativePath
)
{
var
node
=
new
SourceNode
(
)
;
var
remainingLines
=
aGeneratedCode
.
split
(
REGEX_NEWLINE
)
;
var
remainingLinesIndex
=
0
;
var
shiftNextLine
=
function
(
)
{
var
lineContents
=
getNextLine
(
)
;
var
newLine
=
getNextLine
(
)
|
|
"
"
;
return
lineContents
+
newLine
;
function
getNextLine
(
)
{
return
remainingLinesIndex
<
remainingLines
.
length
?
remainingLines
[
remainingLinesIndex
+
+
]
:
undefined
;
}
}
;
var
lastGeneratedLine
=
1
lastGeneratedColumn
=
0
;
var
lastMapping
=
null
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
if
(
lastMapping
!
=
=
null
)
{
if
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
lastGeneratedColumn
=
0
;
}
else
{
var
nextLine
=
remainingLines
[
remainingLinesIndex
]
;
var
code
=
nextLine
.
substr
(
0
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
remainingLines
[
remainingLinesIndex
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
addMappingWithCode
(
lastMapping
code
)
;
lastMapping
=
mapping
;
return
;
}
}
while
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
node
.
add
(
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
}
if
(
lastGeneratedColumn
<
mapping
.
generatedColumn
)
{
var
nextLine
=
remainingLines
[
remainingLinesIndex
]
;
node
.
add
(
nextLine
.
substr
(
0
mapping
.
generatedColumn
)
)
;
remainingLines
[
remainingLinesIndex
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
}
lastMapping
=
mapping
;
}
this
)
;
if
(
remainingLinesIndex
<
remainingLines
.
length
)
{
if
(
lastMapping
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
}
node
.
add
(
remainingLines
.
splice
(
remainingLinesIndex
)
.
join
(
"
"
)
)
;
}
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aRelativePath
!
=
null
)
{
sourceFile
=
util
.
join
(
aRelativePath
sourceFile
)
;
}
node
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
node
;
function
addMappingWithCode
(
mapping
code
)
{
if
(
mapping
=
=
=
null
|
|
mapping
.
source
=
=
=
undefined
)
{
node
.
add
(
code
)
;
}
else
{
var
source
=
aRelativePath
?
util
.
join
(
aRelativePath
mapping
.
source
)
:
mapping
.
source
;
node
.
add
(
new
SourceNode
(
mapping
.
originalLine
mapping
.
originalColumn
source
code
mapping
.
name
)
)
;
}
}
}
;
SourceNode
.
prototype
.
add
=
function
SourceNode_add
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
aChunk
.
forEach
(
function
(
chunk
)
{
this
.
add
(
chunk
)
;
}
this
)
;
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
if
(
aChunk
)
{
this
.
children
.
push
(
aChunk
)
;
}
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
prepend
=
function
SourceNode_prepend
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
for
(
var
i
=
aChunk
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
prepend
(
aChunk
[
i
]
)
;
}
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
this
.
children
.
unshift
(
aChunk
)
;
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
walk
=
function
SourceNode_walk
(
aFn
)
{
var
chunk
;
for
(
var
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
chunk
=
this
.
children
[
i
]
;
if
(
chunk
[
isSourceNode
]
)
{
chunk
.
walk
(
aFn
)
;
}
else
{
if
(
chunk
!
=
=
'
'
)
{
aFn
(
chunk
{
source
:
this
.
source
line
:
this
.
line
column
:
this
.
column
name
:
this
.
name
}
)
;
}
}
}
}
;
SourceNode
.
prototype
.
join
=
function
SourceNode_join
(
aSep
)
{
var
newChildren
;
var
i
;
var
len
=
this
.
children
.
length
;
if
(
len
>
0
)
{
newChildren
=
[
]
;
for
(
i
=
0
;
i
<
len
-
1
;
i
+
+
)
{
newChildren
.
push
(
this
.
children
[
i
]
)
;
newChildren
.
push
(
aSep
)
;
}
newChildren
.
push
(
this
.
children
[
i
]
)
;
this
.
children
=
newChildren
;
}
return
this
;
}
;
SourceNode
.
prototype
.
replaceRight
=
function
SourceNode_replaceRight
(
aPattern
aReplacement
)
{
var
lastChild
=
this
.
children
[
this
.
children
.
length
-
1
]
;
if
(
lastChild
[
isSourceNode
]
)
{
lastChild
.
replaceRight
(
aPattern
aReplacement
)
;
}
else
if
(
typeof
lastChild
=
=
=
'
string
'
)
{
this
.
children
[
this
.
children
.
length
-
1
]
=
lastChild
.
replace
(
aPattern
aReplacement
)
;
}
else
{
this
.
children
.
push
(
'
'
.
replace
(
aPattern
aReplacement
)
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
setSourceContent
=
function
SourceNode_setSourceContent
(
aSourceFile
aSourceContent
)
{
this
.
sourceContents
[
util
.
toSetString
(
aSourceFile
)
]
=
aSourceContent
;
}
;
SourceNode
.
prototype
.
walkSourceContents
=
function
SourceNode_walkSourceContents
(
aFn
)
{
for
(
var
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
if
(
this
.
children
[
i
]
[
isSourceNode
]
)
{
this
.
children
[
i
]
.
walkSourceContents
(
aFn
)
;
}
}
var
sources
=
Object
.
keys
(
this
.
sourceContents
)
;
for
(
var
i
=
0
len
=
sources
.
length
;
i
<
len
;
i
+
+
)
{
aFn
(
util
.
fromSetString
(
sources
[
i
]
)
this
.
sourceContents
[
sources
[
i
]
]
)
;
}
}
;
SourceNode
.
prototype
.
toString
=
function
SourceNode_toString
(
)
{
var
str
=
"
"
;
this
.
walk
(
function
(
chunk
)
{
str
+
=
chunk
;
}
)
;
return
str
;
}
;
SourceNode
.
prototype
.
toStringWithSourceMap
=
function
SourceNode_toStringWithSourceMap
(
aArgs
)
{
var
generated
=
{
code
:
"
"
line
:
1
column
:
0
}
;
var
map
=
new
SourceMapGenerator
(
aArgs
)
;
var
sourceMappingActive
=
false
;
var
lastOriginalSource
=
null
;
var
lastOriginalLine
=
null
;
var
lastOriginalColumn
=
null
;
var
lastOriginalName
=
null
;
this
.
walk
(
function
(
chunk
original
)
{
generated
.
code
+
=
chunk
;
if
(
original
.
source
!
=
=
null
&
&
original
.
line
!
=
=
null
&
&
original
.
column
!
=
=
null
)
{
if
(
lastOriginalSource
!
=
=
original
.
source
|
|
lastOriginalLine
!
=
=
original
.
line
|
|
lastOriginalColumn
!
=
=
original
.
column
|
|
lastOriginalName
!
=
=
original
.
name
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
lastOriginalSource
=
original
.
source
;
lastOriginalLine
=
original
.
line
;
lastOriginalColumn
=
original
.
column
;
lastOriginalName
=
original
.
name
;
sourceMappingActive
=
true
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
}
)
;
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
for
(
var
idx
=
0
length
=
chunk
.
length
;
idx
<
length
;
idx
+
+
)
{
if
(
chunk
.
charCodeAt
(
idx
)
=
=
=
NEWLINE_CODE
)
{
generated
.
line
+
+
;
generated
.
column
=
0
;
if
(
idx
+
1
=
=
=
length
)
{
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
}
else
{
generated
.
column
+
+
;
}
}
}
)
;
this
.
walkSourceContents
(
function
(
sourceFile
sourceContent
)
{
map
.
setSourceContent
(
sourceFile
sourceContent
)
;
}
)
;
return
{
code
:
generated
.
code
map
:
map
}
;
}
;
exports
.
SourceNode
=
SourceNode
;
}
)
}
)
;
}
)
;
