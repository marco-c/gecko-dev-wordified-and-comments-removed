type
JestMockFn
<
TArguments
:
ReadOnlyArray
<
*
>
TReturn
>
=
{
(
.
.
.
args
:
TArguments
)
:
TReturn
mock
:
{
calls
:
Array
<
TArguments
>
instances
:
Array
<
TReturn
>
}
mockClear
(
)
:
void
mockReset
(
)
:
void
mockRestore
(
)
:
void
mockImplementation
(
fn
:
(
.
.
.
args
:
TArguments
)
=
>
TReturn
)
:
JestMockFn
<
TArguments
TReturn
>
mockImplementationOnce
(
fn
:
(
.
.
.
args
:
TArguments
)
=
>
TReturn
)
:
JestMockFn
<
TArguments
TReturn
>
mockName
(
name
:
string
)
:
JestMockFn
<
TArguments
TReturn
>
mockReturnThis
(
)
:
void
mockReturnValue
(
value
:
TReturn
)
:
JestMockFn
<
TArguments
TReturn
>
mockReturnValueOnce
(
value
:
TReturn
)
:
JestMockFn
<
TArguments
TReturn
>
}
;
type
JestAsymmetricEqualityType
=
{
asymmetricMatch
(
value
:
mixed
)
:
boolean
}
;
type
JestCallsType
=
{
allArgs
(
)
:
mixed
all
(
)
:
mixed
any
(
)
:
boolean
count
(
)
:
number
first
(
)
:
mixed
mostRecent
(
)
:
mixed
reset
(
)
:
void
}
;
type
JestClockType
=
{
install
(
)
:
void
mockDate
(
date
:
Date
)
:
void
tick
(
milliseconds
?
:
number
)
:
void
uninstall
(
)
:
void
}
;
type
JestMatcherResult
=
{
message
?
:
string
|
(
(
)
=
>
string
)
pass
:
boolean
}
;
type
JestMatcher
=
(
actual
:
any
expected
:
any
)
=
>
JestMatcherResult
;
type
JestPromiseType
=
{
rejects
:
JestExpectType
resolves
:
JestExpectType
}
;
type
JestTestName
=
string
|
Function
;
type
EnzymeMatchersType
=
{
toBeChecked
(
)
:
void
toBeDisabled
(
)
:
void
toBeEmpty
(
)
:
void
toBeEmptyRender
(
)
:
void
toBePresent
(
)
:
void
toContainReact
(
element
:
React
Element
<
any
>
)
:
void
toExist
(
)
:
void
toHaveClassName
(
className
:
string
)
:
void
toHaveHTML
(
html
:
string
)
:
void
toHaveProp
:
(
(
propKey
:
string
propValue
?
:
any
)
=
>
void
)
&
(
(
props
:
Object
)
=
>
void
)
toHaveRef
(
refName
:
string
)
:
void
toHaveState
:
(
(
stateKey
:
string
stateValue
?
:
any
)
=
>
void
)
&
(
(
state
:
Object
)
=
>
void
)
toHaveStyle
:
(
(
styleKey
:
string
styleValue
?
:
any
)
=
>
void
)
&
(
(
style
:
Object
)
=
>
void
)
toHaveTagName
(
tagName
:
string
)
:
void
toHaveText
(
text
:
string
)
:
void
toIncludeText
(
text
:
string
)
:
void
toHaveValue
(
value
:
any
)
:
void
toMatchElement
(
element
:
React
Element
<
any
>
)
:
void
toMatchSelector
(
selector
:
string
)
:
void
}
;
type
DomTestingLibraryType
=
{
toBeInTheDOM
(
)
:
void
toHaveTextContent
(
content
:
string
)
:
void
toHaveAttribute
(
name
:
string
expectedValue
?
:
string
)
:
void
}
;
type
JestJQueryMatchersType
=
{
toExist
(
)
:
void
toHaveLength
(
len
:
number
)
:
void
toHaveId
(
id
:
string
)
:
void
toHaveClass
(
className
:
string
)
:
void
toHaveTag
(
tag
:
string
)
:
void
toHaveAttr
(
key
:
string
val
?
:
any
)
:
void
toHaveProp
(
key
:
string
val
?
:
any
)
:
void
toHaveText
(
text
:
string
|
RegExp
)
:
void
toHaveData
(
key
:
string
val
?
:
any
)
:
void
toHaveValue
(
val
:
any
)
:
void
toHaveCss
(
css
:
{
[
key
:
string
]
:
any
}
)
:
void
toBeChecked
(
)
:
void
toBeDisabled
(
)
:
void
toBeEmpty
(
)
:
void
toBeHidden
(
)
:
void
toBeSelected
(
)
:
void
toBeVisible
(
)
:
void
toBeFocused
(
)
:
void
toBeInDom
(
)
:
void
toBeMatchedBy
(
sel
:
string
)
:
void
toHaveDescendant
(
sel
:
string
)
:
void
toHaveDescendantWithText
(
sel
:
string
text
:
string
|
RegExp
)
:
void
}
;
type
JestExtendedMatchersType
=
{
toBeEmpty
(
)
:
void
;
toBeOneOf
(
members
:
any
[
]
)
:
void
;
toBeNil
(
)
:
void
;
toSatisfy
(
predicate
:
(
n
:
any
)
=
>
boolean
)
:
void
;
toBeArray
(
)
:
void
;
toBeArrayOfSize
(
x
:
number
)
:
void
;
toIncludeAllMembers
(
members
:
any
[
]
)
:
void
;
toIncludeAnyMembers
(
members
:
any
[
]
)
:
void
;
toSatisfyAll
(
predicate
:
(
n
:
any
)
=
>
boolean
)
:
void
;
toBeBoolean
(
)
:
void
;
toBeTrue
(
)
:
void
;
toBeFalse
(
)
:
void
;
toBeDate
(
)
:
void
;
toBeFunction
(
)
:
void
;
toHaveBeenCalledBefore
(
mock
:
JestMockFn
<
any
any
>
)
:
void
;
toBeNumber
(
)
:
void
;
toBeNaN
(
)
:
void
;
toBeFinite
(
)
:
void
;
toBePositive
(
)
:
void
;
toBeNegative
(
)
:
void
;
toBeEven
(
)
:
void
;
toBeOdd
(
)
:
void
;
toBeWithin
(
start
:
number
end
:
number
)
:
void
;
toBeObject
(
)
:
void
;
toContainKey
(
key
:
string
)
:
void
;
toContainKeys
(
keys
:
string
[
]
)
:
void
;
toContainAllKeys
(
keys
:
string
[
]
)
:
void
;
toContainAnyKeys
(
keys
:
string
[
]
)
:
void
;
toContainValue
(
value
:
any
)
:
void
;
toContainValues
(
values
:
any
[
]
)
:
void
;
toContainAllValues
(
values
:
any
[
]
)
:
void
;
toContainAnyValues
(
values
:
any
[
]
)
:
void
;
toContainEntry
(
entry
:
[
string
string
]
)
:
void
;
toContainEntries
(
entries
:
[
string
string
]
[
]
)
:
void
;
toContainAllEntries
(
entries
:
[
string
string
]
[
]
)
:
void
;
toContainAnyEntries
(
entries
:
[
string
string
]
[
]
)
:
void
;
toBeExtensible
(
)
:
void
;
toBeFrozen
(
)
:
void
;
toBeSealed
(
)
:
void
;
toBeString
(
)
:
void
;
toEqualCaseInsensitive
(
string
:
string
)
:
void
;
toStartWith
(
prefix
:
string
)
:
void
;
toEndWith
(
suffix
:
string
)
:
void
;
toInclude
(
substring
:
string
)
:
void
;
toIncludeRepeated
(
substring
:
string
times
:
number
)
:
void
;
toIncludeMultiple
(
substring
:
string
[
]
)
:
void
;
}
;
interface
JestExpectType
{
not
:
JestExpectType
&
EnzymeMatchersType
&
DomTestingLibraryType
&
JestJQueryMatchersType
&
JestExtendedMatchersType
lastCalledWith
(
.
.
.
args
:
Array
<
any
>
)
:
void
toBe
(
value
:
any
)
:
void
toBeCalledWith
(
.
.
.
args
:
Array
<
any
>
)
:
void
toBeCloseTo
(
num
:
number
delta
:
any
)
:
void
toBeDefined
(
)
:
void
toBeFalsy
(
)
:
void
toBeGreaterThan
(
number
:
number
)
:
void
toBeGreaterThanOrEqual
(
number
:
number
)
:
void
toBeLessThan
(
number
:
number
)
:
void
toBeLessThanOrEqual
(
number
:
number
)
:
void
toBeInstanceOf
(
cls
:
Class
<
*
>
)
:
void
toBeNull
(
)
:
void
toBeTruthy
(
)
:
void
toBeUndefined
(
)
:
void
toContain
(
item
:
any
)
:
void
toContainEqual
(
item
:
any
)
:
void
toEqual
(
value
:
any
)
:
void
toHaveBeenCalled
(
)
:
void
toBeCalled
(
)
:
void
;
toHaveBeenCalledTimes
(
number
:
number
)
:
void
toBeCalledTimes
(
number
:
number
)
:
void
;
toHaveBeenNthCalledWith
(
nthCall
:
number
.
.
.
args
:
Array
<
any
>
)
:
void
;
nthCalledWith
(
nthCall
:
number
.
.
.
args
:
Array
<
any
>
)
:
void
;
toHaveReturned
(
)
:
void
;
toReturn
(
)
:
void
;
toHaveReturnedTimes
(
number
:
number
)
:
void
;
toReturnTimes
(
number
:
number
)
:
void
;
toHaveReturnedWith
(
value
:
any
)
:
void
;
toReturnWith
(
value
:
any
)
:
void
;
toHaveLastReturnedWith
(
value
:
any
)
:
void
;
lastReturnedWith
(
value
:
any
)
:
void
;
toHaveNthReturnedWith
(
nthCall
:
number
value
:
any
)
:
void
;
nthReturnedWith
(
nthCall
:
number
value
:
any
)
:
void
;
toHaveBeenCalledWith
(
.
.
.
args
:
Array
<
any
>
)
:
void
toBeCalledWith
(
.
.
.
args
:
Array
<
any
>
)
:
void
toHaveBeenLastCalledWith
(
.
.
.
args
:
Array
<
any
>
)
:
void
lastCalledWith
(
.
.
.
args
:
Array
<
any
>
)
:
void
toHaveLength
(
number
:
number
)
:
void
toHaveProperty
(
propPath
:
string
value
?
:
any
)
:
void
toMatch
(
regexpOrString
:
RegExp
|
string
)
:
void
toMatchObject
(
object
:
Object
|
Array
<
Object
>
)
:
void
toMatchSnapshot
(
propertyMatchers
?
:
{
[
key
:
string
]
:
JestAsymmetricEqualityType
}
name
?
:
string
)
:
void
toMatchSnapshot
(
name
:
string
)
:
void
toThrow
(
message
?
:
string
|
Error
|
Class
<
Error
>
|
RegExp
)
:
void
toThrowError
(
message
?
:
string
|
Error
|
Class
<
Error
>
|
RegExp
)
:
void
toThrowErrorMatchingSnapshot
(
)
:
void
}
type
JestObjectType
=
{
disableAutomock
(
)
:
JestObjectType
autoMockOff
(
)
:
JestObjectType
enableAutomock
(
)
:
JestObjectType
autoMockOn
(
)
:
JestObjectType
clearAllMocks
(
)
:
JestObjectType
resetAllMocks
(
)
:
JestObjectType
restoreAllMocks
(
)
:
JestObjectType
clearAllTimers
(
)
:
void
doMock
(
moduleName
:
string
moduleFactory
?
:
any
)
:
JestObjectType
dontMock
(
moduleName
:
string
)
:
JestObjectType
fn
<
TArguments
:
ReadOnlyArray
<
*
>
TReturn
>
(
implementation
?
:
(
.
.
.
args
:
TArguments
)
=
>
TReturn
)
:
JestMockFn
<
TArguments
TReturn
>
isMockFunction
(
fn
:
Function
)
:
boolean
genMockFromModule
(
moduleName
:
string
)
:
any
mock
(
moduleName
:
string
moduleFactory
?
:
any
options
?
:
Object
)
:
JestObjectType
requireActual
(
moduleName
:
string
)
:
any
requireMock
(
moduleName
:
string
)
:
any
resetModules
(
)
:
JestObjectType
runAllTicks
(
)
:
void
runAllTimers
(
)
:
void
runAllImmediates
(
)
:
void
advanceTimersByTime
(
msToRun
:
number
)
:
void
runTimersToTime
(
msToRun
:
number
)
:
void
runOnlyPendingTimers
(
)
:
void
setMock
(
moduleName
:
string
moduleExports
:
any
)
:
JestObjectType
unmock
(
moduleName
:
string
)
:
JestObjectType
useFakeTimers
(
)
:
JestObjectType
useRealTimers
(
)
:
JestObjectType
spyOn
(
object
:
Object
methodName
:
string
accessType
?
:
"
get
"
|
"
set
"
)
:
JestMockFn
<
any
any
>
setTimeout
(
timeout
:
number
)
:
JestObjectType
}
;
type
JestSpyType
=
{
calls
:
JestCallsType
}
;
declare
function
afterEach
(
fn
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
;
declare
function
beforeEach
(
fn
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
;
declare
function
afterAll
(
fn
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
;
declare
function
beforeAll
(
fn
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
;
declare
var
describe
:
{
(
name
:
JestTestName
fn
:
(
)
=
>
void
)
:
void
only
(
name
:
JestTestName
fn
:
(
)
=
>
void
)
:
void
skip
(
name
:
JestTestName
fn
:
(
)
=
>
void
)
:
void
}
;
declare
var
it
:
{
(
name
:
JestTestName
fn
?
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
only
(
name
:
JestTestName
fn
?
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
skip
(
name
:
JestTestName
fn
?
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
concurrent
(
name
:
JestTestName
fn
?
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
}
;
declare
function
fit
(
name
:
JestTestName
fn
:
(
done
:
(
)
=
>
void
)
=
>
?
Promise
<
mixed
>
timeout
?
:
number
)
:
void
;
declare
var
test
:
typeof
it
;
declare
var
xdescribe
:
typeof
describe
;
declare
var
fdescribe
:
typeof
describe
;
declare
var
xit
:
typeof
it
;
declare
var
xtest
:
typeof
it
;
type
JestPrettyFormatColors
=
{
comment
:
{
close
:
string
open
:
string
}
content
:
{
close
:
string
open
:
string
}
prop
:
{
close
:
string
open
:
string
}
tag
:
{
close
:
string
open
:
string
}
value
:
{
close
:
string
open
:
string
}
}
;
type
JestPrettyFormatIndent
=
string
=
>
string
;
type
JestPrettyFormatRefs
=
Array
<
any
>
;
type
JestPrettyFormatPrint
=
any
=
>
string
;
type
JestPrettyFormatStringOrNull
=
string
|
null
;
type
JestPrettyFormatOptions
=
{
|
callToJSON
:
boolean
edgeSpacing
:
string
escapeRegex
:
boolean
highlight
:
boolean
indent
:
number
maxDepth
:
number
min
:
boolean
plugins
:
JestPrettyFormatPlugins
printFunctionName
:
boolean
spacing
:
string
theme
:
{
|
comment
:
string
content
:
string
prop
:
string
tag
:
string
value
:
string
|
}
|
}
;
type
JestPrettyFormatPlugin
=
{
print
:
(
val
:
any
serialize
:
JestPrettyFormatPrint
indent
:
JestPrettyFormatIndent
opts
:
JestPrettyFormatOptions
colors
:
JestPrettyFormatColors
)
=
>
string
test
:
any
=
>
boolean
}
;
type
JestPrettyFormatPlugins
=
Array
<
JestPrettyFormatPlugin
>
;
declare
var
expect
:
{
(
value
:
any
)
:
JestExpectType
&
JestPromiseType
&
EnzymeMatchersType
&
DomTestingLibraryType
&
JestJQueryMatchersType
&
JestExtendedMatchersType
extend
(
matchers
:
{
[
name
:
string
]
:
JestMatcher
}
)
:
void
addSnapshotSerializer
(
pluginModule
:
JestPrettyFormatPlugin
)
:
void
assertions
(
expectedAssertions
:
number
)
:
void
hasAssertions
(
)
:
void
any
(
value
:
mixed
)
:
JestAsymmetricEqualityType
anything
(
)
:
any
arrayContaining
(
value
:
Array
<
mixed
>
)
:
Array
<
mixed
>
objectContaining
(
value
:
Object
)
:
Object
stringContaining
(
value
:
string
)
:
string
stringMatching
(
value
:
string
|
RegExp
)
:
string
}
;
declare
function
spyOn
(
value
:
mixed
method
:
string
)
:
Object
;
declare
var
jest
:
JestObjectType
;
declare
var
jasmine
:
{
DEFAULT_TIMEOUT_INTERVAL
:
number
any
(
value
:
mixed
)
:
JestAsymmetricEqualityType
anything
(
)
:
any
arrayContaining
(
value
:
Array
<
mixed
>
)
:
Array
<
mixed
>
clock
(
)
:
JestClockType
createSpy
(
name
:
string
)
:
JestSpyType
createSpyObj
(
baseName
:
string
methodNames
:
Array
<
string
>
)
:
{
[
methodName
:
string
]
:
JestSpyType
}
objectContaining
(
value
:
Object
)
:
Object
stringMatching
(
value
:
string
)
:
string
}
;
