var
Debugger
=
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
exports
:
{
}
id
:
moduleId
loaded
:
false
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
p
=
"
/
public
/
build
"
;
return
__webpack_require__
(
0
)
;
}
)
(
[
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
1
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
combineReducers
=
_require
.
combineReducers
;
var
_require2
=
__webpack_require__
(
15
)
;
var
Provider
=
_require2
.
Provider
;
var
ReactDOM
=
__webpack_require__
(
176
)
;
var
React
=
__webpack_require__
(
17
)
;
var
DevToolsUtils
=
__webpack_require__
(
177
)
;
var
AppConstants
=
__webpack_require__
(
191
)
.
AppConstants
;
var
_require3
=
__webpack_require__
(
195
)
;
var
injectGlobals
=
_require3
.
injectGlobals
;
var
_require4
=
__webpack_require__
(
197
)
;
var
isEnabled
=
_require4
.
isEnabled
;
var
isFirefoxPanel
=
_require4
.
isFirefoxPanel
;
var
isDevelopment
=
_require4
.
isDevelopment
;
var
setConfig
=
_require4
.
setConfig
;
setConfig
(
(
{
"
environment
"
:
"
firefox
-
panel
"
"
baseWorkerURL
"
:
"
resource
:
/
/
devtools
/
client
/
debugger
/
new
/
"
"
logging
"
:
false
"
clientLogging
"
:
false
"
features
"
:
{
"
tabs
"
:
true
}
"
hotReloading
"
:
false
}
)
)
;
if
(
isEnabled
(
"
logging
.
client
"
)
)
{
DevToolsUtils
.
dumpn
.
wantLogging
=
true
;
}
var
_require5
=
__webpack_require__
(
245
)
;
var
getClient
=
_require5
.
getClient
;
var
connectClients
=
_require5
.
connectClients
;
var
startDebugging
=
_require5
.
startDebugging
;
var
firefox
=
__webpack_require__
(
247
)
;
var
configureStore
=
__webpack_require__
(
328
)
;
var
reducers
=
__webpack_require__
(
336
)
;
var
Tabs
=
__webpack_require__
(
347
)
;
var
App
=
__webpack_require__
(
359
)
;
var
createStore
=
configureStore
(
{
log
:
false
makeThunkArgs
:
(
args
state
)
=
>
{
return
Object
.
assign
(
{
}
args
{
client
:
getClient
(
state
)
}
)
;
}
}
)
;
var
store
=
createStore
(
combineReducers
(
reducers
)
)
;
var
actions
=
bindActionCreators
(
__webpack_require__
(
360
)
store
.
dispatch
)
;
if
(
isDevelopment
(
)
)
{
AppConstants
.
DEBUG_JS_MODULES
=
true
;
injectGlobals
(
{
store
}
)
;
}
window
.
actions
=
{
selectSource
:
actions
.
selectSource
selectSourceURL
:
actions
.
selectSourceURL
}
;
function
renderRoot
(
component
)
{
var
mount
=
document
.
querySelector
(
"
#
mount
"
)
;
if
(
!
mount
)
{
return
;
}
ReactDOM
.
render
(
React
.
createElement
(
Provider
{
store
}
React
.
createElement
(
component
)
)
mount
)
;
}
function
getTargetFromQuery
(
)
{
var
href
=
window
.
location
.
href
;
var
nodeMatch
=
href
.
match
(
/
ws
=
(
[
^
&
#
]
*
)
/
)
;
var
firefoxMatch
=
href
.
match
(
/
firefox
-
tab
=
(
[
^
&
#
]
*
)
/
)
;
var
chromeMatch
=
href
.
match
(
/
chrome
-
tab
=
(
[
^
&
#
]
*
)
/
)
;
if
(
nodeMatch
)
{
return
{
type
:
"
node
"
param
:
nodeMatch
[
1
]
}
;
}
else
if
(
firefoxMatch
)
{
return
{
type
:
"
firefox
"
param
:
firefoxMatch
[
1
]
}
;
}
else
if
(
chromeMatch
)
{
return
{
type
:
"
chrome
"
param
:
chromeMatch
[
1
]
}
;
}
return
null
;
}
var
connTarget
=
getTargetFromQuery
(
)
;
if
(
connTarget
)
{
startDebugging
(
connTarget
actions
)
.
then
(
tabs
=
>
{
actions
.
newTabs
(
tabs
)
;
actions
.
selectTab
(
{
id
:
connTarget
.
param
}
)
;
renderRoot
(
App
)
;
}
)
;
}
else
if
(
isFirefoxPanel
(
)
)
{
module
.
exports
=
{
setThreadClient
:
firefox
.
setThreadClient
setTabTarget
:
firefox
.
setTabTarget
initPage
:
firefox
.
initPage
getActions
:
(
)
=
>
actions
renderApp
:
(
)
=
>
renderRoot
(
App
)
}
;
}
else
{
connectClients
(
)
.
then
(
tabs
=
>
{
actions
.
newTabs
(
tabs
)
;
renderRoot
(
Tabs
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
compose
=
exports
.
applyMiddleware
=
exports
.
bindActionCreators
=
exports
.
combineReducers
=
exports
.
createStore
=
undefined
;
var
_createStore
=
__webpack_require__
(
3
)
;
var
_createStore2
=
_interopRequireDefault
(
_createStore
)
;
var
_combineReducers
=
__webpack_require__
(
10
)
;
var
_combineReducers2
=
_interopRequireDefault
(
_combineReducers
)
;
var
_bindActionCreators
=
__webpack_require__
(
12
)
;
var
_bindActionCreators2
=
_interopRequireDefault
(
_bindActionCreators
)
;
var
_applyMiddleware
=
__webpack_require__
(
13
)
;
var
_applyMiddleware2
=
_interopRequireDefault
(
_applyMiddleware
)
;
var
_compose
=
__webpack_require__
(
14
)
;
var
_compose2
=
_interopRequireDefault
(
_compose
)
;
var
_warning
=
__webpack_require__
(
11
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
isCrushed
(
)
{
}
if
(
false
)
{
(
0
_warning2
[
"
default
"
]
)
(
'
You
are
currently
using
minified
code
outside
of
NODE_ENV
=
=
=
\
'
production
\
'
.
'
+
'
This
means
that
you
are
running
a
slower
development
build
of
Redux
.
'
+
'
You
can
use
loose
-
envify
(
https
:
/
/
github
.
com
/
zertosh
/
loose
-
envify
)
for
browserify
'
+
'
or
DefinePlugin
for
webpack
(
http
:
/
/
stackoverflow
.
com
/
questions
/
30030031
)
'
+
'
to
ensure
you
have
the
correct
code
for
your
production
build
.
'
)
;
}
exports
.
createStore
=
_createStore2
[
"
default
"
]
;
exports
.
combineReducers
=
_combineReducers2
[
"
default
"
]
;
exports
.
bindActionCreators
=
_bindActionCreators2
[
"
default
"
]
;
exports
.
applyMiddleware
=
_applyMiddleware2
[
"
default
"
]
;
exports
.
compose
=
_compose2
[
"
default
"
]
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
ActionTypes
=
undefined
;
exports
[
"
default
"
]
=
createStore
;
var
_isPlainObject
=
__webpack_require__
(
4
)
;
var
_isPlainObject2
=
_interopRequireDefault
(
_isPlainObject
)
;
var
_symbolObservable
=
__webpack_require__
(
8
)
;
var
_symbolObservable2
=
_interopRequireDefault
(
_symbolObservable
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
var
ActionTypes
=
exports
.
ActionTypes
=
{
INIT
:
'
redux
/
INIT
'
}
;
function
createStore
(
reducer
initialState
enhancer
)
{
var
_ref2
;
if
(
typeof
initialState
=
=
=
'
function
'
&
&
typeof
enhancer
=
=
=
'
undefined
'
)
{
enhancer
=
initialState
;
initialState
=
undefined
;
}
if
(
typeof
enhancer
!
=
=
'
undefined
'
)
{
if
(
typeof
enhancer
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
the
enhancer
to
be
a
function
.
'
)
;
}
return
enhancer
(
createStore
)
(
reducer
initialState
)
;
}
if
(
typeof
reducer
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
the
reducer
to
be
a
function
.
'
)
;
}
var
currentReducer
=
reducer
;
var
currentState
=
initialState
;
var
currentListeners
=
[
]
;
var
nextListeners
=
currentListeners
;
var
isDispatching
=
false
;
function
ensureCanMutateNextListeners
(
)
{
if
(
nextListeners
=
=
=
currentListeners
)
{
nextListeners
=
currentListeners
.
slice
(
)
;
}
}
function
getState
(
)
{
return
currentState
;
}
function
subscribe
(
listener
)
{
if
(
typeof
listener
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
listener
to
be
a
function
.
'
)
;
}
var
isSubscribed
=
true
;
ensureCanMutateNextListeners
(
)
;
nextListeners
.
push
(
listener
)
;
return
function
unsubscribe
(
)
{
if
(
!
isSubscribed
)
{
return
;
}
isSubscribed
=
false
;
ensureCanMutateNextListeners
(
)
;
var
index
=
nextListeners
.
indexOf
(
listener
)
;
nextListeners
.
splice
(
index
1
)
;
}
;
}
function
dispatch
(
action
)
{
if
(
!
(
0
_isPlainObject2
[
"
default
"
]
)
(
action
)
)
{
throw
new
Error
(
'
Actions
must
be
plain
objects
.
'
+
'
Use
custom
middleware
for
async
actions
.
'
)
;
}
if
(
typeof
action
.
type
=
=
=
'
undefined
'
)
{
throw
new
Error
(
'
Actions
may
not
have
an
undefined
"
type
"
property
.
'
+
'
Have
you
misspelled
a
constant
?
'
)
;
}
if
(
isDispatching
)
{
throw
new
Error
(
'
Reducers
may
not
dispatch
actions
.
'
)
;
}
try
{
isDispatching
=
true
;
currentState
=
currentReducer
(
currentState
action
)
;
}
finally
{
isDispatching
=
false
;
}
var
listeners
=
currentListeners
=
nextListeners
;
for
(
var
i
=
0
;
i
<
listeners
.
length
;
i
+
+
)
{
listeners
[
i
]
(
)
;
}
return
action
;
}
function
replaceReducer
(
nextReducer
)
{
if
(
typeof
nextReducer
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
the
nextReducer
to
be
a
function
.
'
)
;
}
currentReducer
=
nextReducer
;
dispatch
(
{
type
:
ActionTypes
.
INIT
}
)
;
}
function
observable
(
)
{
var
_ref
;
var
outerSubscribe
=
subscribe
;
return
_ref
=
{
subscribe
:
function
subscribe
(
observer
)
{
if
(
typeof
observer
!
=
=
'
object
'
)
{
throw
new
TypeError
(
'
Expected
the
observer
to
be
an
object
.
'
)
;
}
function
observeState
(
)
{
if
(
observer
.
next
)
{
observer
.
next
(
getState
(
)
)
;
}
}
observeState
(
)
;
var
unsubscribe
=
outerSubscribe
(
observeState
)
;
return
{
unsubscribe
:
unsubscribe
}
;
}
}
_ref
[
_symbolObservable2
[
"
default
"
]
]
=
function
(
)
{
return
this
;
}
_ref
;
}
dispatch
(
{
type
:
ActionTypes
.
INIT
}
)
;
return
_ref2
=
{
dispatch
:
dispatch
subscribe
:
subscribe
getState
:
getState
replaceReducer
:
replaceReducer
}
_ref2
[
_symbolObservable2
[
"
default
"
]
]
=
observable
_ref2
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
getPrototype
=
__webpack_require__
(
5
)
isHostObject
=
__webpack_require__
(
6
)
isObjectLike
=
__webpack_require__
(
7
)
;
var
objectTag
=
'
[
object
Object
]
'
;
var
objectProto
=
Object
.
prototype
;
var
funcToString
=
Function
.
prototype
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
objectCtorString
=
funcToString
.
call
(
Object
)
;
var
objectToString
=
objectProto
.
toString
;
function
isPlainObject
(
value
)
{
if
(
!
isObjectLike
(
value
)
|
|
objectToString
.
call
(
value
)
!
=
objectTag
|
|
isHostObject
(
value
)
)
{
return
false
;
}
var
proto
=
getPrototype
(
value
)
;
if
(
proto
=
=
=
null
)
{
return
true
;
}
var
Ctor
=
hasOwnProperty
.
call
(
proto
'
constructor
'
)
&
&
proto
.
constructor
;
return
(
typeof
Ctor
=
=
'
function
'
&
&
Ctor
instanceof
Ctor
&
&
funcToString
.
call
(
Ctor
)
=
=
objectCtorString
)
;
}
module
.
exports
=
isPlainObject
;
}
function
(
module
exports
)
{
var
nativeGetPrototype
=
Object
.
getPrototypeOf
;
function
getPrototype
(
value
)
{
return
nativeGetPrototype
(
Object
(
value
)
)
;
}
module
.
exports
=
getPrototype
;
}
function
(
module
exports
)
{
function
isHostObject
(
value
)
{
var
result
=
false
;
if
(
value
!
=
null
&
&
typeof
value
.
toString
!
=
'
function
'
)
{
try
{
result
=
!
!
(
value
+
'
'
)
;
}
catch
(
e
)
{
}
}
return
result
;
}
module
.
exports
=
isHostObject
;
}
function
(
module
exports
)
{
function
isObjectLike
(
value
)
{
return
!
!
value
&
&
typeof
value
=
=
'
object
'
;
}
module
.
exports
=
isObjectLike
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
)
{
'
use
strict
'
;
module
.
exports
=
__webpack_require__
(
9
)
(
global
|
|
window
|
|
this
)
;
}
.
call
(
exports
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
function
symbolObservablePonyfill
(
root
)
{
var
result
;
var
Symbol
=
root
.
Symbol
;
if
(
typeof
Symbol
=
=
=
'
function
'
)
{
if
(
Symbol
.
observable
)
{
result
=
Symbol
.
observable
;
}
else
{
result
=
Symbol
(
'
observable
'
)
;
Symbol
.
observable
=
result
;
}
}
else
{
result
=
'
observable
'
;
}
return
result
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
combineReducers
;
var
_createStore
=
__webpack_require__
(
3
)
;
var
_isPlainObject
=
__webpack_require__
(
4
)
;
var
_isPlainObject2
=
_interopRequireDefault
(
_isPlainObject
)
;
var
_warning
=
__webpack_require__
(
11
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
getUndefinedStateErrorMessage
(
key
action
)
{
var
actionType
=
action
&
&
action
.
type
;
var
actionName
=
actionType
&
&
'
"
'
+
actionType
.
toString
(
)
+
'
"
'
|
|
'
an
action
'
;
return
'
Given
action
'
+
actionName
+
'
reducer
"
'
+
key
+
'
"
returned
undefined
.
'
+
'
To
ignore
an
action
you
must
explicitly
return
the
previous
state
.
'
;
}
function
getUnexpectedStateShapeWarningMessage
(
inputState
reducers
action
)
{
var
reducerKeys
=
Object
.
keys
(
reducers
)
;
var
argumentName
=
action
&
&
action
.
type
=
=
=
_createStore
.
ActionTypes
.
INIT
?
'
initialState
argument
passed
to
createStore
'
:
'
previous
state
received
by
the
reducer
'
;
if
(
reducerKeys
.
length
=
=
=
0
)
{
return
'
Store
does
not
have
a
valid
reducer
.
Make
sure
the
argument
passed
'
+
'
to
combineReducers
is
an
object
whose
values
are
reducers
.
'
;
}
if
(
!
(
0
_isPlainObject2
[
"
default
"
]
)
(
inputState
)
)
{
return
'
The
'
+
argumentName
+
'
has
unexpected
type
of
"
'
+
{
}
.
toString
.
call
(
inputState
)
.
match
(
/
\
s
(
[
a
-
z
|
A
-
Z
]
+
)
/
)
[
1
]
+
'
"
.
Expected
argument
to
be
an
object
with
the
following
'
+
(
'
keys
:
"
'
+
reducerKeys
.
join
(
'
"
"
'
)
+
'
"
'
)
;
}
var
unexpectedKeys
=
Object
.
keys
(
inputState
)
.
filter
(
function
(
key
)
{
return
!
reducers
.
hasOwnProperty
(
key
)
;
}
)
;
if
(
unexpectedKeys
.
length
>
0
)
{
return
'
Unexpected
'
+
(
unexpectedKeys
.
length
>
1
?
'
keys
'
:
'
key
'
)
+
'
'
+
(
'
"
'
+
unexpectedKeys
.
join
(
'
"
"
'
)
+
'
"
found
in
'
+
argumentName
+
'
.
'
)
+
'
Expected
to
find
one
of
the
known
reducer
keys
instead
:
'
+
(
'
"
'
+
reducerKeys
.
join
(
'
"
"
'
)
+
'
"
.
Unexpected
keys
will
be
ignored
.
'
)
;
}
}
function
assertReducerSanity
(
reducers
)
{
Object
.
keys
(
reducers
)
.
forEach
(
function
(
key
)
{
var
reducer
=
reducers
[
key
]
;
var
initialState
=
reducer
(
undefined
{
type
:
_createStore
.
ActionTypes
.
INIT
}
)
;
if
(
typeof
initialState
=
=
=
'
undefined
'
)
{
throw
new
Error
(
'
Reducer
"
'
+
key
+
'
"
returned
undefined
during
initialization
.
'
+
'
If
the
state
passed
to
the
reducer
is
undefined
you
must
'
+
'
explicitly
return
the
initial
state
.
The
initial
state
may
'
+
'
not
be
undefined
.
'
)
;
}
var
type
=
'
redux
/
PROBE_UNKNOWN_ACTION_
'
+
Math
.
random
(
)
.
toString
(
36
)
.
substring
(
7
)
.
split
(
'
'
)
.
join
(
'
.
'
)
;
if
(
typeof
reducer
(
undefined
{
type
:
type
}
)
=
=
=
'
undefined
'
)
{
throw
new
Error
(
'
Reducer
"
'
+
key
+
'
"
returned
undefined
when
probed
with
a
random
type
.
'
+
(
'
Don
\
'
t
try
to
handle
'
+
_createStore
.
ActionTypes
.
INIT
+
'
or
other
actions
in
"
redux
/
*
"
'
)
+
'
namespace
.
They
are
considered
private
.
Instead
you
must
return
the
'
+
'
current
state
for
any
unknown
actions
unless
it
is
undefined
'
+
'
in
which
case
you
must
return
the
initial
state
regardless
of
the
'
+
'
action
type
.
The
initial
state
may
not
be
undefined
.
'
)
;
}
}
)
;
}
function
combineReducers
(
reducers
)
{
var
reducerKeys
=
Object
.
keys
(
reducers
)
;
var
finalReducers
=
{
}
;
for
(
var
i
=
0
;
i
<
reducerKeys
.
length
;
i
+
+
)
{
var
key
=
reducerKeys
[
i
]
;
if
(
typeof
reducers
[
key
]
=
=
=
'
function
'
)
{
finalReducers
[
key
]
=
reducers
[
key
]
;
}
}
var
finalReducerKeys
=
Object
.
keys
(
finalReducers
)
;
var
sanityError
;
try
{
assertReducerSanity
(
finalReducers
)
;
}
catch
(
e
)
{
sanityError
=
e
;
}
return
function
combination
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
if
(
sanityError
)
{
throw
sanityError
;
}
if
(
false
)
{
var
warningMessage
=
getUnexpectedStateShapeWarningMessage
(
state
finalReducers
action
)
;
if
(
warningMessage
)
{
(
0
_warning2
[
"
default
"
]
)
(
warningMessage
)
;
}
}
var
hasChanged
=
false
;
var
nextState
=
{
}
;
for
(
var
i
=
0
;
i
<
finalReducerKeys
.
length
;
i
+
+
)
{
var
key
=
finalReducerKeys
[
i
]
;
var
reducer
=
finalReducers
[
key
]
;
var
previousStateForKey
=
state
[
key
]
;
var
nextStateForKey
=
reducer
(
previousStateForKey
action
)
;
if
(
typeof
nextStateForKey
=
=
=
'
undefined
'
)
{
var
errorMessage
=
getUndefinedStateErrorMessage
(
key
action
)
;
throw
new
Error
(
errorMessage
)
;
}
nextState
[
key
]
=
nextStateForKey
;
hasChanged
=
hasChanged
|
|
nextStateForKey
!
=
=
previousStateForKey
;
}
return
hasChanged
?
nextState
:
state
;
}
;
}
}
function
(
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
warning
;
function
warning
(
message
)
{
if
(
typeof
console
!
=
=
'
undefined
'
&
&
typeof
console
.
error
=
=
=
'
function
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
e
)
{
}
}
}
function
(
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
bindActionCreators
;
function
bindActionCreator
(
actionCreator
dispatch
)
{
return
function
(
)
{
return
dispatch
(
actionCreator
.
apply
(
undefined
arguments
)
)
;
}
;
}
function
bindActionCreators
(
actionCreators
dispatch
)
{
if
(
typeof
actionCreators
=
=
=
'
function
'
)
{
return
bindActionCreator
(
actionCreators
dispatch
)
;
}
if
(
typeof
actionCreators
!
=
=
'
object
'
|
|
actionCreators
=
=
=
null
)
{
throw
new
Error
(
'
bindActionCreators
expected
an
object
or
a
function
instead
received
'
+
(
actionCreators
=
=
=
null
?
'
null
'
:
typeof
actionCreators
)
+
'
.
'
+
'
Did
you
write
"
import
ActionCreators
from
"
instead
of
"
import
*
as
ActionCreators
from
"
?
'
)
;
}
var
keys
=
Object
.
keys
(
actionCreators
)
;
var
boundActionCreators
=
{
}
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
actionCreator
=
actionCreators
[
key
]
;
if
(
typeof
actionCreator
=
=
=
'
function
'
)
{
boundActionCreators
[
key
]
=
bindActionCreator
(
actionCreator
dispatch
)
;
}
}
return
boundActionCreators
;
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
exports
[
"
default
"
]
=
applyMiddleware
;
var
_compose
=
__webpack_require__
(
14
)
;
var
_compose2
=
_interopRequireDefault
(
_compose
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
applyMiddleware
(
)
{
for
(
var
_len
=
arguments
.
length
middlewares
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
middlewares
[
_key
]
=
arguments
[
_key
]
;
}
return
function
(
createStore
)
{
return
function
(
reducer
initialState
enhancer
)
{
var
store
=
createStore
(
reducer
initialState
enhancer
)
;
var
_dispatch
=
store
.
dispatch
;
var
chain
=
[
]
;
var
middlewareAPI
=
{
getState
:
store
.
getState
dispatch
:
function
dispatch
(
action
)
{
return
_dispatch
(
action
)
;
}
}
;
chain
=
middlewares
.
map
(
function
(
middleware
)
{
return
middleware
(
middlewareAPI
)
;
}
)
;
_dispatch
=
_compose2
[
"
default
"
]
.
apply
(
undefined
chain
)
(
store
.
dispatch
)
;
return
_extends
(
{
}
store
{
dispatch
:
_dispatch
}
)
;
}
;
}
;
}
}
function
(
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
compose
;
function
compose
(
)
{
for
(
var
_len
=
arguments
.
length
funcs
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
funcs
[
_key
]
=
arguments
[
_key
]
;
}
if
(
funcs
.
length
=
=
=
0
)
{
return
function
(
arg
)
{
return
arg
;
}
;
}
else
{
var
_ret
=
function
(
)
{
var
last
=
funcs
[
funcs
.
length
-
1
]
;
var
rest
=
funcs
.
slice
(
0
-
1
)
;
return
{
v
:
function
v
(
)
{
return
rest
.
reduceRight
(
function
(
composed
f
)
{
return
f
(
composed
)
;
}
last
.
apply
(
undefined
arguments
)
)
;
}
}
;
}
(
)
;
if
(
typeof
_ret
=
=
=
"
object
"
)
return
_ret
.
v
;
}
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
connect
=
exports
.
Provider
=
undefined
;
var
_Provider
=
__webpack_require__
(
16
)
;
var
_Provider2
=
_interopRequireDefault
(
_Provider
)
;
var
_connect
=
__webpack_require__
(
171
)
;
var
_connect2
=
_interopRequireDefault
(
_connect
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
exports
.
Provider
=
_Provider2
[
"
default
"
]
;
exports
.
connect
=
_connect2
[
"
default
"
]
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
undefined
;
var
_react
=
__webpack_require__
(
17
)
;
var
_storeShape
=
__webpack_require__
(
169
)
;
var
_storeShape2
=
_interopRequireDefault
(
_storeShape
)
;
var
_warning
=
__webpack_require__
(
170
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
didWarnAboutReceivingStore
=
false
;
function
warnAboutReceivingStore
(
)
{
if
(
didWarnAboutReceivingStore
)
{
return
;
}
didWarnAboutReceivingStore
=
true
;
(
0
_warning2
[
"
default
"
]
)
(
'
<
Provider
>
does
not
support
changing
store
on
the
fly
.
'
+
'
It
is
most
likely
that
you
see
this
error
because
you
updated
to
'
+
'
Redux
2
.
x
and
React
Redux
2
.
x
which
no
longer
hot
reload
reducers
'
+
'
automatically
.
See
https
:
/
/
github
.
com
/
reactjs
/
react
-
redux
/
releases
/
'
+
'
tag
/
v2
.
0
.
0
for
the
migration
instructions
.
'
)
;
}
var
Provider
=
function
(
_Component
)
{
_inherits
(
Provider
_Component
)
;
Provider
.
prototype
.
getChildContext
=
function
getChildContext
(
)
{
return
{
store
:
this
.
store
}
;
}
;
function
Provider
(
props
context
)
{
_classCallCheck
(
this
Provider
)
;
var
_this
=
_possibleConstructorReturn
(
this
_Component
.
call
(
this
props
context
)
)
;
_this
.
store
=
props
.
store
;
return
_this
;
}
Provider
.
prototype
.
render
=
function
render
(
)
{
var
children
=
this
.
props
.
children
;
return
_react
.
Children
.
only
(
children
)
;
}
;
return
Provider
;
}
(
_react
.
Component
)
;
exports
[
"
default
"
]
=
Provider
;
if
(
false
)
{
Provider
.
prototype
.
componentWillReceiveProps
=
function
(
nextProps
)
{
var
store
=
this
.
store
;
var
nextStore
=
nextProps
.
store
;
if
(
store
!
=
=
nextStore
)
{
warnAboutReceivingStore
(
)
;
}
}
;
}
Provider
.
propTypes
=
{
store
:
_storeShape2
[
"
default
"
]
.
isRequired
children
:
_react
.
PropTypes
.
element
.
isRequired
}
;
Provider
.
childContextTypes
=
{
store
:
_storeShape2
[
"
default
"
]
.
isRequired
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
module
.
exports
=
__webpack_require__
(
18
)
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactDOM
=
__webpack_require__
(
19
)
;
var
ReactDOMServer
=
__webpack_require__
(
159
)
;
var
ReactIsomorphic
=
__webpack_require__
(
163
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
deprecated
=
__webpack_require__
(
168
)
;
var
React
=
{
}
;
assign
(
React
ReactIsomorphic
)
;
assign
(
React
{
findDOMNode
:
deprecated
(
'
findDOMNode
'
'
ReactDOM
'
'
react
-
dom
'
ReactDOM
ReactDOM
.
findDOMNode
)
render
:
deprecated
(
'
render
'
'
ReactDOM
'
'
react
-
dom
'
ReactDOM
ReactDOM
.
render
)
unmountComponentAtNode
:
deprecated
(
'
unmountComponentAtNode
'
'
ReactDOM
'
'
react
-
dom
'
ReactDOM
ReactDOM
.
unmountComponentAtNode
)
renderToString
:
deprecated
(
'
renderToString
'
'
ReactDOMServer
'
'
react
-
dom
/
server
'
ReactDOMServer
ReactDOMServer
.
renderToString
)
renderToStaticMarkup
:
deprecated
(
'
renderToStaticMarkup
'
'
ReactDOMServer
'
'
react
-
dom
/
server
'
ReactDOMServer
ReactDOMServer
.
renderToStaticMarkup
)
}
)
;
React
.
__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
=
ReactDOM
;
React
.
__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
=
ReactDOMServer
;
module
.
exports
=
React
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
ReactDOMTextComponent
=
__webpack_require__
(
21
)
;
var
ReactDefaultInjection
=
__webpack_require__
(
86
)
;
var
ReactInstanceHandles
=
__webpack_require__
(
60
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
ReactReconciler
=
__webpack_require__
(
65
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
ReactVersion
=
__webpack_require__
(
157
)
;
var
findDOMNode
=
__webpack_require__
(
106
)
;
var
renderSubtreeIntoContainer
=
__webpack_require__
(
158
)
;
var
warning
=
__webpack_require__
(
40
)
;
ReactDefaultInjection
.
inject
(
)
;
var
render
=
ReactPerf
.
measure
(
'
React
'
'
render
'
ReactMount
.
render
)
;
var
React
=
{
findDOMNode
:
findDOMNode
render
:
render
unmountComponentAtNode
:
ReactMount
.
unmountComponentAtNode
version
:
ReactVersion
unstable_batchedUpdates
:
ReactUpdates
.
batchedUpdates
unstable_renderSubtreeIntoContainer
:
renderSubtreeIntoContainer
}
;
if
(
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
!
=
=
'
undefined
'
&
&
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
.
inject
=
=
=
'
function
'
)
{
__REACT_DEVTOOLS_GLOBAL_HOOK__
.
inject
(
{
CurrentOwner
:
ReactCurrentOwner
InstanceHandles
:
ReactInstanceHandles
Mount
:
ReactMount
Reconciler
:
ReactReconciler
TextComponent
:
ReactDOMTextComponent
}
)
;
}
if
(
false
)
{
var
ExecutionEnvironment
=
require
(
'
fbjs
/
lib
/
ExecutionEnvironment
'
)
;
if
(
ExecutionEnvironment
.
canUseDOM
&
&
window
.
top
=
=
=
window
.
self
)
{
if
(
typeof
__REACT_DEVTOOLS_GLOBAL_HOOK__
=
=
=
'
undefined
'
)
{
if
(
navigator
.
userAgent
.
indexOf
(
'
Chrome
'
)
>
-
1
&
&
navigator
.
userAgent
.
indexOf
(
'
Edge
'
)
=
=
=
-
1
|
|
navigator
.
userAgent
.
indexOf
(
'
Firefox
'
)
>
-
1
)
{
console
.
debug
(
'
Download
the
React
DevTools
for
a
better
development
experience
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
devtools
'
)
;
}
}
var
ieCompatibilityMode
=
document
.
documentMode
&
&
document
.
documentMode
<
8
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
ieCompatibilityMode
'
Internet
Explorer
is
running
in
compatibility
mode
;
please
add
the
'
+
'
following
tag
to
your
HTML
to
prevent
this
from
happening
:
'
+
'
<
meta
http
-
equiv
=
"
X
-
UA
-
Compatible
"
content
=
"
IE
=
edge
"
/
>
'
)
:
undefined
;
var
expectedFeatures
=
[
Array
.
isArray
Array
.
prototype
.
every
Array
.
prototype
.
forEach
Array
.
prototype
.
indexOf
Array
.
prototype
.
map
Date
.
now
Function
.
prototype
.
bind
Object
.
keys
String
.
prototype
.
split
String
.
prototype
.
trim
Object
.
create
Object
.
freeze
]
;
for
(
var
i
=
0
;
i
<
expectedFeatures
.
length
;
i
+
+
)
{
if
(
!
expectedFeatures
[
i
]
)
{
console
.
error
(
'
One
or
more
ES5
shim
/
shams
expected
by
React
are
not
available
:
'
+
'
https
:
/
/
fb
.
me
/
react
-
warning
-
polyfills
'
)
;
break
;
}
}
}
}
module
.
exports
=
React
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ReactCurrentOwner
=
{
current
:
null
}
;
module
.
exports
=
ReactCurrentOwner
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
DOMChildrenOperations
=
__webpack_require__
(
22
)
;
var
DOMPropertyOperations
=
__webpack_require__
(
37
)
;
var
ReactComponentBrowserEnvironment
=
__webpack_require__
(
41
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
escapeTextContentForBrowser
=
__webpack_require__
(
36
)
;
var
setTextContent
=
__webpack_require__
(
35
)
;
var
validateDOMNesting
=
__webpack_require__
(
85
)
;
var
ReactDOMTextComponent
=
function
(
props
)
{
}
;
assign
(
ReactDOMTextComponent
.
prototype
{
construct
:
function
(
text
)
{
this
.
_currentElement
=
text
;
this
.
_stringText
=
'
'
+
text
;
this
.
_rootNodeID
=
null
;
this
.
_mountIndex
=
0
;
}
mountComponent
:
function
(
rootID
transaction
context
)
{
if
(
false
)
{
if
(
context
[
validateDOMNesting
.
ancestorInfoContextKey
]
)
{
validateDOMNesting
(
'
span
'
null
context
[
validateDOMNesting
.
ancestorInfoContextKey
]
)
;
}
}
this
.
_rootNodeID
=
rootID
;
if
(
transaction
.
useCreateElement
)
{
var
ownerDocument
=
context
[
ReactMount
.
ownerDocumentContextKey
]
;
var
el
=
ownerDocument
.
createElement
(
'
span
'
)
;
DOMPropertyOperations
.
setAttributeForID
(
el
rootID
)
;
ReactMount
.
getID
(
el
)
;
setTextContent
(
el
this
.
_stringText
)
;
return
el
;
}
else
{
var
escapedText
=
escapeTextContentForBrowser
(
this
.
_stringText
)
;
if
(
transaction
.
renderToStaticMarkup
)
{
return
escapedText
;
}
return
'
<
span
'
+
DOMPropertyOperations
.
createMarkupForID
(
rootID
)
+
'
>
'
+
escapedText
+
'
<
/
span
>
'
;
}
}
receiveComponent
:
function
(
nextText
transaction
)
{
if
(
nextText
!
=
=
this
.
_currentElement
)
{
this
.
_currentElement
=
nextText
;
var
nextStringText
=
'
'
+
nextText
;
if
(
nextStringText
!
=
=
this
.
_stringText
)
{
this
.
_stringText
=
nextStringText
;
var
node
=
ReactMount
.
getNode
(
this
.
_rootNodeID
)
;
DOMChildrenOperations
.
updateTextContent
(
node
nextStringText
)
;
}
}
}
unmountComponent
:
function
(
)
{
ReactComponentBrowserEnvironment
.
unmountIDFromEnvironment
(
this
.
_rootNodeID
)
;
}
}
)
;
module
.
exports
=
ReactDOMTextComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
Danger
=
__webpack_require__
(
23
)
;
var
ReactMultiChildUpdateTypes
=
__webpack_require__
(
31
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
setInnerHTML
=
__webpack_require__
(
34
)
;
var
setTextContent
=
__webpack_require__
(
35
)
;
var
invariant
=
__webpack_require__
(
28
)
;
function
insertChildAt
(
parentNode
childNode
index
)
{
var
beforeChild
=
index
>
=
parentNode
.
childNodes
.
length
?
null
:
parentNode
.
childNodes
.
item
(
index
)
;
parentNode
.
insertBefore
(
childNode
beforeChild
)
;
}
var
DOMChildrenOperations
=
{
dangerouslyReplaceNodeWithMarkup
:
Danger
.
dangerouslyReplaceNodeWithMarkup
updateTextContent
:
setTextContent
processUpdates
:
function
(
updates
markupList
)
{
var
update
;
var
initialChildren
=
null
;
var
updatedChildren
=
null
;
for
(
var
i
=
0
;
i
<
updates
.
length
;
i
+
+
)
{
update
=
updates
[
i
]
;
if
(
update
.
type
=
=
=
ReactMultiChildUpdateTypes
.
MOVE_EXISTING
|
|
update
.
type
=
=
=
ReactMultiChildUpdateTypes
.
REMOVE_NODE
)
{
var
updatedIndex
=
update
.
fromIndex
;
var
updatedChild
=
update
.
parentNode
.
childNodes
[
updatedIndex
]
;
var
parentID
=
update
.
parentID
;
!
updatedChild
?
false
?
invariant
(
false
'
processUpdates
(
)
:
Unable
to
find
child
%
s
of
element
.
This
'
+
'
probably
means
the
DOM
was
unexpectedly
mutated
(
e
.
g
.
by
the
'
+
'
browser
)
usually
due
to
forgetting
a
<
tbody
>
when
using
tables
'
+
'
nesting
tags
like
<
form
>
<
p
>
or
<
a
>
or
using
non
-
SVG
elements
'
+
'
in
an
<
svg
>
parent
.
Try
inspecting
the
child
nodes
of
the
element
'
+
'
with
React
ID
%
s
.
'
updatedIndex
parentID
)
:
invariant
(
false
)
:
undefined
;
initialChildren
=
initialChildren
|
|
{
}
;
initialChildren
[
parentID
]
=
initialChildren
[
parentID
]
|
|
[
]
;
initialChildren
[
parentID
]
[
updatedIndex
]
=
updatedChild
;
updatedChildren
=
updatedChildren
|
|
[
]
;
updatedChildren
.
push
(
updatedChild
)
;
}
}
var
renderedMarkup
;
if
(
markupList
.
length
&
&
typeof
markupList
[
0
]
=
=
=
'
string
'
)
{
renderedMarkup
=
Danger
.
dangerouslyRenderMarkup
(
markupList
)
;
}
else
{
renderedMarkup
=
markupList
;
}
if
(
updatedChildren
)
{
for
(
var
j
=
0
;
j
<
updatedChildren
.
length
;
j
+
+
)
{
updatedChildren
[
j
]
.
parentNode
.
removeChild
(
updatedChildren
[
j
]
)
;
}
}
for
(
var
k
=
0
;
k
<
updates
.
length
;
k
+
+
)
{
update
=
updates
[
k
]
;
switch
(
update
.
type
)
{
case
ReactMultiChildUpdateTypes
.
INSERT_MARKUP
:
insertChildAt
(
update
.
parentNode
renderedMarkup
[
update
.
markupIndex
]
update
.
toIndex
)
;
break
;
case
ReactMultiChildUpdateTypes
.
MOVE_EXISTING
:
insertChildAt
(
update
.
parentNode
initialChildren
[
update
.
parentID
]
[
update
.
fromIndex
]
update
.
toIndex
)
;
break
;
case
ReactMultiChildUpdateTypes
.
SET_MARKUP
:
setInnerHTML
(
update
.
parentNode
update
.
content
)
;
break
;
case
ReactMultiChildUpdateTypes
.
TEXT_CONTENT
:
setTextContent
(
update
.
parentNode
update
.
content
)
;
break
;
case
ReactMultiChildUpdateTypes
.
REMOVE_NODE
:
break
;
}
}
}
}
;
ReactPerf
.
measureMethods
(
DOMChildrenOperations
'
DOMChildrenOperations
'
{
updateTextContent
:
'
updateTextContent
'
}
)
;
module
.
exports
=
DOMChildrenOperations
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
createNodesFromMarkup
=
__webpack_require__
(
25
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
getMarkupWrap
=
__webpack_require__
(
29
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
OPEN_TAG_NAME_EXP
=
/
^
(
<
[
^
\
/
>
]
+
)
/
;
var
RESULT_INDEX_ATTR
=
'
data
-
danger
-
index
'
;
function
getNodeName
(
markup
)
{
return
markup
.
substring
(
1
markup
.
indexOf
(
'
'
)
)
;
}
var
Danger
=
{
dangerouslyRenderMarkup
:
function
(
markupList
)
{
!
ExecutionEnvironment
.
canUseDOM
?
false
?
invariant
(
false
'
dangerouslyRenderMarkup
(
.
.
.
)
:
Cannot
render
markup
in
a
worker
'
+
'
thread
.
Make
sure
window
and
document
are
available
globally
'
+
'
before
requiring
React
when
unit
testing
or
use
'
+
'
ReactDOMServer
.
renderToString
for
server
rendering
.
'
)
:
invariant
(
false
)
:
undefined
;
var
nodeName
;
var
markupByNodeName
=
{
}
;
for
(
var
i
=
0
;
i
<
markupList
.
length
;
i
+
+
)
{
!
markupList
[
i
]
?
false
?
invariant
(
false
'
dangerouslyRenderMarkup
(
.
.
.
)
:
Missing
markup
.
'
)
:
invariant
(
false
)
:
undefined
;
nodeName
=
getNodeName
(
markupList
[
i
]
)
;
nodeName
=
getMarkupWrap
(
nodeName
)
?
nodeName
:
'
*
'
;
markupByNodeName
[
nodeName
]
=
markupByNodeName
[
nodeName
]
|
|
[
]
;
markupByNodeName
[
nodeName
]
[
i
]
=
markupList
[
i
]
;
}
var
resultList
=
[
]
;
var
resultListAssignmentCount
=
0
;
for
(
nodeName
in
markupByNodeName
)
{
if
(
!
markupByNodeName
.
hasOwnProperty
(
nodeName
)
)
{
continue
;
}
var
markupListByNodeName
=
markupByNodeName
[
nodeName
]
;
var
resultIndex
;
for
(
resultIndex
in
markupListByNodeName
)
{
if
(
markupListByNodeName
.
hasOwnProperty
(
resultIndex
)
)
{
var
markup
=
markupListByNodeName
[
resultIndex
]
;
markupListByNodeName
[
resultIndex
]
=
markup
.
replace
(
OPEN_TAG_NAME_EXP
'
1
'
+
RESULT_INDEX_ATTR
+
'
=
"
'
+
resultIndex
+
'
"
'
)
;
}
}
var
renderNodes
=
createNodesFromMarkup
(
markupListByNodeName
.
join
(
'
'
)
emptyFunction
)
;
for
(
var
j
=
0
;
j
<
renderNodes
.
length
;
+
+
j
)
{
var
renderNode
=
renderNodes
[
j
]
;
if
(
renderNode
.
hasAttribute
&
&
renderNode
.
hasAttribute
(
RESULT_INDEX_ATTR
)
)
{
resultIndex
=
+
renderNode
.
getAttribute
(
RESULT_INDEX_ATTR
)
;
renderNode
.
removeAttribute
(
RESULT_INDEX_ATTR
)
;
!
!
resultList
.
hasOwnProperty
(
resultIndex
)
?
false
?
invariant
(
false
'
Danger
:
Assigning
to
an
already
-
occupied
result
index
.
'
)
:
invariant
(
false
)
:
undefined
;
resultList
[
resultIndex
]
=
renderNode
;
resultListAssignmentCount
+
=
1
;
}
else
if
(
false
)
{
console
.
error
(
'
Danger
:
Discarding
unexpected
node
:
'
renderNode
)
;
}
}
}
!
(
resultListAssignmentCount
=
=
=
resultList
.
length
)
?
false
?
invariant
(
false
'
Danger
:
Did
not
assign
to
every
index
of
resultList
.
'
)
:
invariant
(
false
)
:
undefined
;
!
(
resultList
.
length
=
=
=
markupList
.
length
)
?
false
?
invariant
(
false
'
Danger
:
Expected
markup
to
render
%
s
nodes
but
rendered
%
s
.
'
markupList
.
length
resultList
.
length
)
:
invariant
(
false
)
:
undefined
;
return
resultList
;
}
dangerouslyReplaceNodeWithMarkup
:
function
(
oldChild
markup
)
{
!
ExecutionEnvironment
.
canUseDOM
?
false
?
invariant
(
false
'
dangerouslyReplaceNodeWithMarkup
(
.
.
.
)
:
Cannot
render
markup
in
a
'
+
'
worker
thread
.
Make
sure
window
and
document
are
available
'
+
'
globally
before
requiring
React
when
unit
testing
or
use
'
+
'
ReactDOMServer
.
renderToString
(
)
for
server
rendering
.
'
)
:
invariant
(
false
)
:
undefined
;
!
markup
?
false
?
invariant
(
false
'
dangerouslyReplaceNodeWithMarkup
(
.
.
.
)
:
Missing
markup
.
'
)
:
invariant
(
false
)
:
undefined
;
!
(
oldChild
.
tagName
.
toLowerCase
(
)
!
=
=
'
html
'
)
?
false
?
invariant
(
false
'
dangerouslyReplaceNodeWithMarkup
(
.
.
.
)
:
Cannot
replace
markup
of
the
'
+
'
<
html
>
node
.
This
is
because
browser
quirks
make
this
unreliable
'
+
'
and
/
or
slow
.
If
you
want
to
render
to
the
root
you
must
use
'
+
'
server
rendering
.
See
ReactDOMServer
.
renderToString
(
)
.
'
)
:
invariant
(
false
)
:
undefined
;
var
newChild
;
if
(
typeof
markup
=
=
=
'
string
'
)
{
newChild
=
createNodesFromMarkup
(
markup
emptyFunction
)
[
0
]
;
}
else
{
newChild
=
markup
;
}
oldChild
.
parentNode
.
replaceChild
(
newChild
oldChild
)
;
}
}
;
module
.
exports
=
Danger
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
canUseDOM
=
!
!
(
typeof
window
!
=
=
'
undefined
'
&
&
window
.
document
&
&
window
.
document
.
createElement
)
;
var
ExecutionEnvironment
=
{
canUseDOM
:
canUseDOM
canUseWorkers
:
typeof
Worker
!
=
=
'
undefined
'
canUseEventListeners
:
canUseDOM
&
&
!
!
(
window
.
addEventListener
|
|
window
.
attachEvent
)
canUseViewport
:
canUseDOM
&
&
!
!
window
.
screen
isInWorker
:
!
canUseDOM
}
;
module
.
exports
=
ExecutionEnvironment
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
createArrayFromMixed
=
__webpack_require__
(
26
)
;
var
getMarkupWrap
=
__webpack_require__
(
29
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
dummyNode
=
ExecutionEnvironment
.
canUseDOM
?
document
.
createElement
(
'
div
'
)
:
null
;
var
nodeNamePattern
=
/
^
\
s
*
<
(
\
w
+
)
/
;
function
getNodeName
(
markup
)
{
var
nodeNameMatch
=
markup
.
match
(
nodeNamePattern
)
;
return
nodeNameMatch
&
&
nodeNameMatch
[
1
]
.
toLowerCase
(
)
;
}
function
createNodesFromMarkup
(
markup
handleScript
)
{
var
node
=
dummyNode
;
!
!
!
dummyNode
?
false
?
invariant
(
false
'
createNodesFromMarkup
dummy
not
initialized
'
)
:
invariant
(
false
)
:
undefined
;
var
nodeName
=
getNodeName
(
markup
)
;
var
wrap
=
nodeName
&
&
getMarkupWrap
(
nodeName
)
;
if
(
wrap
)
{
node
.
innerHTML
=
wrap
[
1
]
+
markup
+
wrap
[
2
]
;
var
wrapDepth
=
wrap
[
0
]
;
while
(
wrapDepth
-
-
)
{
node
=
node
.
lastChild
;
}
}
else
{
node
.
innerHTML
=
markup
;
}
var
scripts
=
node
.
getElementsByTagName
(
'
script
'
)
;
if
(
scripts
.
length
)
{
!
handleScript
?
false
?
invariant
(
false
'
createNodesFromMarkup
(
.
.
.
)
:
Unexpected
<
script
>
element
rendered
.
'
)
:
invariant
(
false
)
:
undefined
;
createArrayFromMixed
(
scripts
)
.
forEach
(
handleScript
)
;
}
var
nodes
=
createArrayFromMixed
(
node
.
childNodes
)
;
while
(
node
.
lastChild
)
{
node
.
removeChild
(
node
.
lastChild
)
;
}
return
nodes
;
}
module
.
exports
=
createNodesFromMarkup
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
toArray
=
__webpack_require__
(
27
)
;
function
hasArrayNature
(
obj
)
{
return
(
!
!
obj
&
&
(
typeof
obj
=
=
'
object
'
|
|
typeof
obj
=
=
'
function
'
)
&
&
'
length
'
in
obj
&
&
!
(
'
setInterval
'
in
obj
)
&
&
typeof
obj
.
nodeType
!
=
'
number
'
&
&
(
Array
.
isArray
(
obj
)
|
|
'
callee
'
in
obj
|
|
'
item
'
in
obj
)
)
;
}
function
createArrayFromMixed
(
obj
)
{
if
(
!
hasArrayNature
(
obj
)
)
{
return
[
obj
]
;
}
else
if
(
Array
.
isArray
(
obj
)
)
{
return
obj
.
slice
(
)
;
}
else
{
return
toArray
(
obj
)
;
}
}
module
.
exports
=
createArrayFromMixed
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
function
toArray
(
obj
)
{
var
length
=
obj
.
length
;
!
(
!
Array
.
isArray
(
obj
)
&
&
(
typeof
obj
=
=
=
'
object
'
|
|
typeof
obj
=
=
=
'
function
'
)
)
?
false
?
invariant
(
false
'
toArray
:
Array
-
like
object
expected
'
)
:
invariant
(
false
)
:
undefined
;
!
(
typeof
length
=
=
=
'
number
'
)
?
false
?
invariant
(
false
'
toArray
:
Object
needs
a
length
property
'
)
:
invariant
(
false
)
:
undefined
;
!
(
length
=
=
=
0
|
|
length
-
1
in
obj
)
?
false
?
invariant
(
false
'
toArray
:
Object
should
have
keys
for
indices
'
)
:
invariant
(
false
)
:
undefined
;
if
(
obj
.
hasOwnProperty
)
{
try
{
return
Array
.
prototype
.
slice
.
call
(
obj
)
;
}
catch
(
e
)
{
}
}
var
ret
=
Array
(
length
)
;
for
(
var
ii
=
0
;
ii
<
length
;
ii
+
+
)
{
ret
[
ii
]
=
obj
[
ii
]
;
}
return
ret
;
}
module
.
exports
=
toArray
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
function
invariant
(
condition
format
a
b
c
d
e
f
)
{
if
(
false
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
invariant
requires
an
error
message
argument
'
)
;
}
}
if
(
!
condition
)
{
var
error
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
module
.
exports
=
invariant
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
dummyNode
=
ExecutionEnvironment
.
canUseDOM
?
document
.
createElement
(
'
div
'
)
:
null
;
var
shouldWrap
=
{
}
;
var
selectWrap
=
[
1
'
<
select
multiple
=
"
true
"
>
'
'
<
/
select
>
'
]
;
var
tableWrap
=
[
1
'
<
table
>
'
'
<
/
table
>
'
]
;
var
trWrap
=
[
3
'
<
table
>
<
tbody
>
<
tr
>
'
'
<
/
tr
>
<
/
tbody
>
<
/
table
>
'
]
;
var
svgWrap
=
[
1
'
<
svg
xmlns
=
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
>
'
'
<
/
svg
>
'
]
;
var
markupWrap
=
{
'
*
'
:
[
1
'
?
<
div
>
'
'
<
/
div
>
'
]
'
area
'
:
[
1
'
<
map
>
'
'
<
/
map
>
'
]
'
col
'
:
[
2
'
<
table
>
<
tbody
>
<
/
tbody
>
<
colgroup
>
'
'
<
/
colgroup
>
<
/
table
>
'
]
'
legend
'
:
[
1
'
<
fieldset
>
'
'
<
/
fieldset
>
'
]
'
param
'
:
[
1
'
<
object
>
'
'
<
/
object
>
'
]
'
tr
'
:
[
2
'
<
table
>
<
tbody
>
'
'
<
/
tbody
>
<
/
table
>
'
]
'
optgroup
'
:
selectWrap
'
option
'
:
selectWrap
'
caption
'
:
tableWrap
'
colgroup
'
:
tableWrap
'
tbody
'
:
tableWrap
'
tfoot
'
:
tableWrap
'
thead
'
:
tableWrap
'
td
'
:
trWrap
'
th
'
:
trWrap
}
;
var
svgElements
=
[
'
circle
'
'
clipPath
'
'
defs
'
'
ellipse
'
'
g
'
'
image
'
'
line
'
'
linearGradient
'
'
mask
'
'
path
'
'
pattern
'
'
polygon
'
'
polyline
'
'
radialGradient
'
'
rect
'
'
stop
'
'
text
'
'
tspan
'
]
;
svgElements
.
forEach
(
function
(
nodeName
)
{
markupWrap
[
nodeName
]
=
svgWrap
;
shouldWrap
[
nodeName
]
=
true
;
}
)
;
function
getMarkupWrap
(
nodeName
)
{
!
!
!
dummyNode
?
false
?
invariant
(
false
'
Markup
wrapping
node
not
initialized
'
)
:
invariant
(
false
)
:
undefined
;
if
(
!
markupWrap
.
hasOwnProperty
(
nodeName
)
)
{
nodeName
=
'
*
'
;
}
if
(
!
shouldWrap
.
hasOwnProperty
(
nodeName
)
)
{
if
(
nodeName
=
=
=
'
*
'
)
{
dummyNode
.
innerHTML
=
'
<
link
/
>
'
;
}
else
{
dummyNode
.
innerHTML
=
'
<
'
+
nodeName
+
'
>
<
/
'
+
nodeName
+
'
>
'
;
}
shouldWrap
[
nodeName
]
=
!
dummyNode
.
firstChild
;
}
return
shouldWrap
[
nodeName
]
?
markupWrap
[
nodeName
]
:
null
;
}
module
.
exports
=
getMarkupWrap
;
}
function
(
module
exports
)
{
"
use
strict
"
;
function
makeEmptyFunction
(
arg
)
{
return
function
(
)
{
return
arg
;
}
;
}
function
emptyFunction
(
)
{
}
emptyFunction
.
thatReturns
=
makeEmptyFunction
;
emptyFunction
.
thatReturnsFalse
=
makeEmptyFunction
(
false
)
;
emptyFunction
.
thatReturnsTrue
=
makeEmptyFunction
(
true
)
;
emptyFunction
.
thatReturnsNull
=
makeEmptyFunction
(
null
)
;
emptyFunction
.
thatReturnsThis
=
function
(
)
{
return
this
;
}
;
emptyFunction
.
thatReturnsArgument
=
function
(
arg
)
{
return
arg
;
}
;
module
.
exports
=
emptyFunction
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
keyMirror
=
__webpack_require__
(
32
)
;
var
ReactMultiChildUpdateTypes
=
keyMirror
(
{
INSERT_MARKUP
:
null
MOVE_EXISTING
:
null
REMOVE_NODE
:
null
SET_MARKUP
:
null
TEXT_CONTENT
:
null
}
)
;
module
.
exports
=
ReactMultiChildUpdateTypes
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
var
keyMirror
=
function
(
obj
)
{
var
ret
=
{
}
;
var
key
;
!
(
obj
instanceof
Object
&
&
!
Array
.
isArray
(
obj
)
)
?
false
?
invariant
(
false
'
keyMirror
(
.
.
.
)
:
Argument
must
be
an
object
.
'
)
:
invariant
(
false
)
:
undefined
;
for
(
key
in
obj
)
{
if
(
!
obj
.
hasOwnProperty
(
key
)
)
{
continue
;
}
ret
[
key
]
=
key
;
}
return
ret
;
}
;
module
.
exports
=
keyMirror
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactPerf
=
{
enableMeasure
:
false
storedMeasure
:
_noMeasure
measureMethods
:
function
(
object
objectName
methodNames
)
{
if
(
false
)
{
for
(
var
key
in
methodNames
)
{
if
(
!
methodNames
.
hasOwnProperty
(
key
)
)
{
continue
;
}
object
[
key
]
=
ReactPerf
.
measure
(
objectName
methodNames
[
key
]
object
[
key
]
)
;
}
}
}
measure
:
function
(
objName
fnName
func
)
{
if
(
false
)
{
var
measuredFunc
=
null
;
var
wrapper
=
function
(
)
{
if
(
ReactPerf
.
enableMeasure
)
{
if
(
!
measuredFunc
)
{
measuredFunc
=
ReactPerf
.
storedMeasure
(
objName
fnName
func
)
;
}
return
measuredFunc
.
apply
(
this
arguments
)
;
}
return
func
.
apply
(
this
arguments
)
;
}
;
wrapper
.
displayName
=
objName
+
'
_
'
+
fnName
;
return
wrapper
;
}
return
func
;
}
injection
:
{
injectMeasure
:
function
(
measure
)
{
ReactPerf
.
storedMeasure
=
measure
;
}
}
}
;
function
_noMeasure
(
objName
fnName
func
)
{
return
func
;
}
module
.
exports
=
ReactPerf
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
WHITESPACE_TEST
=
/
^
[
\
r
\
n
\
t
\
f
]
/
;
var
NONVISIBLE_TEST
=
/
<
(
!
-
-
|
link
|
noscript
|
meta
|
script
|
style
)
[
\
r
\
n
\
t
\
f
\
/
>
]
/
;
var
setInnerHTML
=
function
(
node
html
)
{
node
.
innerHTML
=
html
;
}
;
if
(
typeof
MSApp
!
=
=
'
undefined
'
&
&
MSApp
.
execUnsafeLocalFunction
)
{
setInnerHTML
=
function
(
node
html
)
{
MSApp
.
execUnsafeLocalFunction
(
function
(
)
{
node
.
innerHTML
=
html
;
}
)
;
}
;
}
if
(
ExecutionEnvironment
.
canUseDOM
)
{
var
testElement
=
document
.
createElement
(
'
div
'
)
;
testElement
.
innerHTML
=
'
'
;
if
(
testElement
.
innerHTML
=
=
=
'
'
)
{
setInnerHTML
=
function
(
node
html
)
{
if
(
node
.
parentNode
)
{
node
.
parentNode
.
replaceChild
(
node
node
)
;
}
if
(
WHITESPACE_TEST
.
test
(
html
)
|
|
html
[
0
]
=
=
=
'
<
'
&
&
NONVISIBLE_TEST
.
test
(
html
)
)
{
node
.
innerHTML
=
String
.
fromCharCode
(
0xFEFF
)
+
html
;
var
textNode
=
node
.
firstChild
;
if
(
textNode
.
data
.
length
=
=
=
1
)
{
node
.
removeChild
(
textNode
)
;
}
else
{
textNode
.
deleteData
(
0
1
)
;
}
}
else
{
node
.
innerHTML
=
html
;
}
}
;
}
}
module
.
exports
=
setInnerHTML
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
escapeTextContentForBrowser
=
__webpack_require__
(
36
)
;
var
setInnerHTML
=
__webpack_require__
(
34
)
;
var
setTextContent
=
function
(
node
text
)
{
node
.
textContent
=
text
;
}
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
if
(
!
(
'
textContent
'
in
document
.
documentElement
)
)
{
setTextContent
=
function
(
node
text
)
{
setInnerHTML
(
node
escapeTextContentForBrowser
(
text
)
)
;
}
;
}
}
module
.
exports
=
setTextContent
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ESCAPE_LOOKUP
=
{
'
&
'
:
'
&
amp
;
'
'
>
'
:
'
&
gt
;
'
'
<
'
:
'
&
lt
;
'
'
"
'
:
'
&
quot
;
'
'
\
'
'
:
'
&
#
x27
;
'
}
;
var
ESCAPE_REGEX
=
/
[
&
>
<
"
'
]
/
g
;
function
escaper
(
match
)
{
return
ESCAPE_LOOKUP
[
match
]
;
}
function
escapeTextContentForBrowser
(
text
)
{
return
(
'
'
+
text
)
.
replace
(
ESCAPE_REGEX
escaper
)
;
}
module
.
exports
=
escapeTextContentForBrowser
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
DOMProperty
=
__webpack_require__
(
38
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
quoteAttributeValueForBrowser
=
__webpack_require__
(
39
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
VALID_ATTRIBUTE_NAME_REGEX
=
/
^
[
a
-
zA
-
Z_
]
[
\
w
\
.
\
-
]
*
/
;
var
illegalAttributeNameCache
=
{
}
;
var
validatedAttributeNameCache
=
{
}
;
function
isAttributeNameSafe
(
attributeName
)
{
if
(
validatedAttributeNameCache
.
hasOwnProperty
(
attributeName
)
)
{
return
true
;
}
if
(
illegalAttributeNameCache
.
hasOwnProperty
(
attributeName
)
)
{
return
false
;
}
if
(
VALID_ATTRIBUTE_NAME_REGEX
.
test
(
attributeName
)
)
{
validatedAttributeNameCache
[
attributeName
]
=
true
;
return
true
;
}
illegalAttributeNameCache
[
attributeName
]
=
true
;
false
?
warning
(
false
'
Invalid
attribute
name
:
%
s
'
attributeName
)
:
undefined
;
return
false
;
}
function
shouldIgnoreValue
(
propertyInfo
value
)
{
return
value
=
=
null
|
|
propertyInfo
.
hasBooleanValue
&
&
!
value
|
|
propertyInfo
.
hasNumericValue
&
&
isNaN
(
value
)
|
|
propertyInfo
.
hasPositiveNumericValue
&
&
value
<
1
|
|
propertyInfo
.
hasOverloadedBooleanValue
&
&
value
=
=
=
false
;
}
if
(
false
)
{
var
reactProps
=
{
children
:
true
dangerouslySetInnerHTML
:
true
key
:
true
ref
:
true
}
;
var
warnedProperties
=
{
}
;
var
warnUnknownProperty
=
function
(
name
)
{
if
(
reactProps
.
hasOwnProperty
(
name
)
&
&
reactProps
[
name
]
|
|
warnedProperties
.
hasOwnProperty
(
name
)
&
&
warnedProperties
[
name
]
)
{
return
;
}
warnedProperties
[
name
]
=
true
;
var
lowerCasedName
=
name
.
toLowerCase
(
)
;
var
standardName
=
DOMProperty
.
isCustomAttribute
(
lowerCasedName
)
?
lowerCasedName
:
DOMProperty
.
getPossibleStandardName
.
hasOwnProperty
(
lowerCasedName
)
?
DOMProperty
.
getPossibleStandardName
[
lowerCasedName
]
:
null
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
standardName
=
=
null
'
Unknown
DOM
property
%
s
.
Did
you
mean
%
s
?
'
name
standardName
)
:
undefined
;
}
;
}
var
DOMPropertyOperations
=
{
createMarkupForID
:
function
(
id
)
{
return
DOMProperty
.
ID_ATTRIBUTE_NAME
+
'
=
'
+
quoteAttributeValueForBrowser
(
id
)
;
}
setAttributeForID
:
function
(
node
id
)
{
node
.
setAttribute
(
DOMProperty
.
ID_ATTRIBUTE_NAME
id
)
;
}
createMarkupForProperty
:
function
(
name
value
)
{
var
propertyInfo
=
DOMProperty
.
properties
.
hasOwnProperty
(
name
)
?
DOMProperty
.
properties
[
name
]
:
null
;
if
(
propertyInfo
)
{
if
(
shouldIgnoreValue
(
propertyInfo
value
)
)
{
return
'
'
;
}
var
attributeName
=
propertyInfo
.
attributeName
;
if
(
propertyInfo
.
hasBooleanValue
|
|
propertyInfo
.
hasOverloadedBooleanValue
&
&
value
=
=
=
true
)
{
return
attributeName
+
'
=
"
"
'
;
}
return
attributeName
+
'
=
'
+
quoteAttributeValueForBrowser
(
value
)
;
}
else
if
(
DOMProperty
.
isCustomAttribute
(
name
)
)
{
if
(
value
=
=
null
)
{
return
'
'
;
}
return
name
+
'
=
'
+
quoteAttributeValueForBrowser
(
value
)
;
}
else
if
(
false
)
{
warnUnknownProperty
(
name
)
;
}
return
null
;
}
createMarkupForCustomAttribute
:
function
(
name
value
)
{
if
(
!
isAttributeNameSafe
(
name
)
|
|
value
=
=
null
)
{
return
'
'
;
}
return
name
+
'
=
'
+
quoteAttributeValueForBrowser
(
value
)
;
}
setValueForProperty
:
function
(
node
name
value
)
{
var
propertyInfo
=
DOMProperty
.
properties
.
hasOwnProperty
(
name
)
?
DOMProperty
.
properties
[
name
]
:
null
;
if
(
propertyInfo
)
{
var
mutationMethod
=
propertyInfo
.
mutationMethod
;
if
(
mutationMethod
)
{
mutationMethod
(
node
value
)
;
}
else
if
(
shouldIgnoreValue
(
propertyInfo
value
)
)
{
this
.
deleteValueForProperty
(
node
name
)
;
}
else
if
(
propertyInfo
.
mustUseAttribute
)
{
var
attributeName
=
propertyInfo
.
attributeName
;
var
namespace
=
propertyInfo
.
attributeNamespace
;
if
(
namespace
)
{
node
.
setAttributeNS
(
namespace
attributeName
'
'
+
value
)
;
}
else
if
(
propertyInfo
.
hasBooleanValue
|
|
propertyInfo
.
hasOverloadedBooleanValue
&
&
value
=
=
=
true
)
{
node
.
setAttribute
(
attributeName
'
'
)
;
}
else
{
node
.
setAttribute
(
attributeName
'
'
+
value
)
;
}
}
else
{
var
propName
=
propertyInfo
.
propertyName
;
if
(
!
propertyInfo
.
hasSideEffects
|
|
'
'
+
node
[
propName
]
!
=
=
'
'
+
value
)
{
node
[
propName
]
=
value
;
}
}
}
else
if
(
DOMProperty
.
isCustomAttribute
(
name
)
)
{
DOMPropertyOperations
.
setValueForAttribute
(
node
name
value
)
;
}
else
if
(
false
)
{
warnUnknownProperty
(
name
)
;
}
}
setValueForAttribute
:
function
(
node
name
value
)
{
if
(
!
isAttributeNameSafe
(
name
)
)
{
return
;
}
if
(
value
=
=
null
)
{
node
.
removeAttribute
(
name
)
;
}
else
{
node
.
setAttribute
(
name
'
'
+
value
)
;
}
}
deleteValueForProperty
:
function
(
node
name
)
{
var
propertyInfo
=
DOMProperty
.
properties
.
hasOwnProperty
(
name
)
?
DOMProperty
.
properties
[
name
]
:
null
;
if
(
propertyInfo
)
{
var
mutationMethod
=
propertyInfo
.
mutationMethod
;
if
(
mutationMethod
)
{
mutationMethod
(
node
undefined
)
;
}
else
if
(
propertyInfo
.
mustUseAttribute
)
{
node
.
removeAttribute
(
propertyInfo
.
attributeName
)
;
}
else
{
var
propName
=
propertyInfo
.
propertyName
;
var
defaultValue
=
DOMProperty
.
getDefaultValueForProperty
(
node
.
nodeName
propName
)
;
if
(
!
propertyInfo
.
hasSideEffects
|
|
'
'
+
node
[
propName
]
!
=
=
defaultValue
)
{
node
[
propName
]
=
defaultValue
;
}
}
}
else
if
(
DOMProperty
.
isCustomAttribute
(
name
)
)
{
node
.
removeAttribute
(
name
)
;
}
else
if
(
false
)
{
warnUnknownProperty
(
name
)
;
}
}
}
;
ReactPerf
.
measureMethods
(
DOMPropertyOperations
'
DOMPropertyOperations
'
{
setValueForProperty
:
'
setValueForProperty
'
setValueForAttribute
:
'
setValueForAttribute
'
deleteValueForProperty
:
'
deleteValueForProperty
'
}
)
;
module
.
exports
=
DOMPropertyOperations
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
function
checkMask
(
value
bitmask
)
{
return
(
value
&
bitmask
)
=
=
=
bitmask
;
}
var
DOMPropertyInjection
=
{
MUST_USE_ATTRIBUTE
:
0x1
MUST_USE_PROPERTY
:
0x2
HAS_SIDE_EFFECTS
:
0x4
HAS_BOOLEAN_VALUE
:
0x8
HAS_NUMERIC_VALUE
:
0x10
HAS_POSITIVE_NUMERIC_VALUE
:
0x20
|
0x10
HAS_OVERLOADED_BOOLEAN_VALUE
:
0x40
injectDOMPropertyConfig
:
function
(
domPropertyConfig
)
{
var
Injection
=
DOMPropertyInjection
;
var
Properties
=
domPropertyConfig
.
Properties
|
|
{
}
;
var
DOMAttributeNamespaces
=
domPropertyConfig
.
DOMAttributeNamespaces
|
|
{
}
;
var
DOMAttributeNames
=
domPropertyConfig
.
DOMAttributeNames
|
|
{
}
;
var
DOMPropertyNames
=
domPropertyConfig
.
DOMPropertyNames
|
|
{
}
;
var
DOMMutationMethods
=
domPropertyConfig
.
DOMMutationMethods
|
|
{
}
;
if
(
domPropertyConfig
.
isCustomAttribute
)
{
DOMProperty
.
_isCustomAttributeFunctions
.
push
(
domPropertyConfig
.
isCustomAttribute
)
;
}
for
(
var
propName
in
Properties
)
{
!
!
DOMProperty
.
properties
.
hasOwnProperty
(
propName
)
?
false
?
invariant
(
false
'
injectDOMPropertyConfig
(
.
.
.
)
:
You
\
'
re
trying
to
inject
DOM
property
'
+
'
\
'
%
s
\
'
which
has
already
been
injected
.
You
may
be
accidentally
'
+
'
injecting
the
same
DOM
property
config
twice
or
you
may
be
'
+
'
injecting
two
configs
that
have
conflicting
property
names
.
'
propName
)
:
invariant
(
false
)
:
undefined
;
var
lowerCased
=
propName
.
toLowerCase
(
)
;
var
propConfig
=
Properties
[
propName
]
;
var
propertyInfo
=
{
attributeName
:
lowerCased
attributeNamespace
:
null
propertyName
:
propName
mutationMethod
:
null
mustUseAttribute
:
checkMask
(
propConfig
Injection
.
MUST_USE_ATTRIBUTE
)
mustUseProperty
:
checkMask
(
propConfig
Injection
.
MUST_USE_PROPERTY
)
hasSideEffects
:
checkMask
(
propConfig
Injection
.
HAS_SIDE_EFFECTS
)
hasBooleanValue
:
checkMask
(
propConfig
Injection
.
HAS_BOOLEAN_VALUE
)
hasNumericValue
:
checkMask
(
propConfig
Injection
.
HAS_NUMERIC_VALUE
)
hasPositiveNumericValue
:
checkMask
(
propConfig
Injection
.
HAS_POSITIVE_NUMERIC_VALUE
)
hasOverloadedBooleanValue
:
checkMask
(
propConfig
Injection
.
HAS_OVERLOADED_BOOLEAN_VALUE
)
}
;
!
(
!
propertyInfo
.
mustUseAttribute
|
|
!
propertyInfo
.
mustUseProperty
)
?
false
?
invariant
(
false
'
DOMProperty
:
Cannot
require
using
both
attribute
and
property
:
%
s
'
propName
)
:
invariant
(
false
)
:
undefined
;
!
(
propertyInfo
.
mustUseProperty
|
|
!
propertyInfo
.
hasSideEffects
)
?
false
?
invariant
(
false
'
DOMProperty
:
Properties
that
have
side
effects
must
use
property
:
%
s
'
propName
)
:
invariant
(
false
)
:
undefined
;
!
(
propertyInfo
.
hasBooleanValue
+
propertyInfo
.
hasNumericValue
+
propertyInfo
.
hasOverloadedBooleanValue
<
=
1
)
?
false
?
invariant
(
false
'
DOMProperty
:
Value
can
be
one
of
boolean
overloaded
boolean
or
'
+
'
numeric
value
but
not
a
combination
:
%
s
'
propName
)
:
invariant
(
false
)
:
undefined
;
if
(
false
)
{
DOMProperty
.
getPossibleStandardName
[
lowerCased
]
=
propName
;
}
if
(
DOMAttributeNames
.
hasOwnProperty
(
propName
)
)
{
var
attributeName
=
DOMAttributeNames
[
propName
]
;
propertyInfo
.
attributeName
=
attributeName
;
if
(
false
)
{
DOMProperty
.
getPossibleStandardName
[
attributeName
]
=
propName
;
}
}
if
(
DOMAttributeNamespaces
.
hasOwnProperty
(
propName
)
)
{
propertyInfo
.
attributeNamespace
=
DOMAttributeNamespaces
[
propName
]
;
}
if
(
DOMPropertyNames
.
hasOwnProperty
(
propName
)
)
{
propertyInfo
.
propertyName
=
DOMPropertyNames
[
propName
]
;
}
if
(
DOMMutationMethods
.
hasOwnProperty
(
propName
)
)
{
propertyInfo
.
mutationMethod
=
DOMMutationMethods
[
propName
]
;
}
DOMProperty
.
properties
[
propName
]
=
propertyInfo
;
}
}
}
;
var
defaultValueCache
=
{
}
;
var
DOMProperty
=
{
ID_ATTRIBUTE_NAME
:
'
data
-
reactid
'
properties
:
{
}
getPossibleStandardName
:
false
?
{
}
:
null
_isCustomAttributeFunctions
:
[
]
isCustomAttribute
:
function
(
attributeName
)
{
for
(
var
i
=
0
;
i
<
DOMProperty
.
_isCustomAttributeFunctions
.
length
;
i
+
+
)
{
var
isCustomAttributeFn
=
DOMProperty
.
_isCustomAttributeFunctions
[
i
]
;
if
(
isCustomAttributeFn
(
attributeName
)
)
{
return
true
;
}
}
return
false
;
}
getDefaultValueForProperty
:
function
(
nodeName
prop
)
{
var
nodeDefaults
=
defaultValueCache
[
nodeName
]
;
var
testElement
;
if
(
!
nodeDefaults
)
{
defaultValueCache
[
nodeName
]
=
nodeDefaults
=
{
}
;
}
if
(
!
(
prop
in
nodeDefaults
)
)
{
testElement
=
document
.
createElement
(
nodeName
)
;
nodeDefaults
[
prop
]
=
testElement
[
prop
]
;
}
return
nodeDefaults
[
prop
]
;
}
injection
:
DOMPropertyInjection
}
;
module
.
exports
=
DOMProperty
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
escapeTextContentForBrowser
=
__webpack_require__
(
36
)
;
function
quoteAttributeValueForBrowser
(
value
)
{
return
'
"
'
+
escapeTextContentForBrowser
(
value
)
+
'
"
'
;
}
module
.
exports
=
quoteAttributeValueForBrowser
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
warning
=
emptyFunction
;
if
(
false
)
{
warning
=
function
(
condition
format
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
warning
(
condition
format
.
.
.
args
)
requires
a
warning
'
+
'
message
argument
'
)
;
}
if
(
format
.
indexOf
(
'
Failed
Composite
propType
:
'
)
=
=
=
0
)
{
return
;
}
if
(
!
condition
)
{
var
argIndex
=
0
;
var
message
=
'
Warning
:
'
+
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
;
if
(
typeof
console
!
=
=
'
undefined
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
x
)
{
}
}
}
;
}
module
.
exports
=
warning
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactDOMIDOperations
=
__webpack_require__
(
42
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactComponentBrowserEnvironment
=
{
processChildrenUpdates
:
ReactDOMIDOperations
.
dangerouslyProcessChildrenUpdates
replaceNodeWithMarkupByID
:
ReactDOMIDOperations
.
dangerouslyReplaceNodeWithMarkupByID
unmountIDFromEnvironment
:
function
(
rootNodeID
)
{
ReactMount
.
purgeID
(
rootNodeID
)
;
}
}
;
module
.
exports
=
ReactComponentBrowserEnvironment
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
DOMChildrenOperations
=
__webpack_require__
(
22
)
;
var
DOMPropertyOperations
=
__webpack_require__
(
37
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
INVALID_PROPERTY_ERRORS
=
{
dangerouslySetInnerHTML
:
'
dangerouslySetInnerHTML
must
be
set
using
updateInnerHTMLByID
(
)
.
'
style
:
'
style
must
be
set
using
updateStylesByID
(
)
.
'
}
;
var
ReactDOMIDOperations
=
{
updatePropertyByID
:
function
(
id
name
value
)
{
var
node
=
ReactMount
.
getNode
(
id
)
;
!
!
INVALID_PROPERTY_ERRORS
.
hasOwnProperty
(
name
)
?
false
?
invariant
(
false
'
updatePropertyByID
(
.
.
.
)
:
%
s
'
INVALID_PROPERTY_ERRORS
[
name
]
)
:
invariant
(
false
)
:
undefined
;
if
(
value
!
=
null
)
{
DOMPropertyOperations
.
setValueForProperty
(
node
name
value
)
;
}
else
{
DOMPropertyOperations
.
deleteValueForProperty
(
node
name
)
;
}
}
dangerouslyReplaceNodeWithMarkupByID
:
function
(
id
markup
)
{
var
node
=
ReactMount
.
getNode
(
id
)
;
DOMChildrenOperations
.
dangerouslyReplaceNodeWithMarkup
(
node
markup
)
;
}
dangerouslyProcessChildrenUpdates
:
function
(
updates
markup
)
{
for
(
var
i
=
0
;
i
<
updates
.
length
;
i
+
+
)
{
updates
[
i
]
.
parentNode
=
ReactMount
.
getNode
(
updates
[
i
]
.
parentID
)
;
}
DOMChildrenOperations
.
processUpdates
(
updates
markup
)
;
}
}
;
ReactPerf
.
measureMethods
(
ReactDOMIDOperations
'
ReactDOMIDOperations
'
{
dangerouslyReplaceNodeWithMarkupByID
:
'
dangerouslyReplaceNodeWithMarkupByID
'
dangerouslyProcessChildrenUpdates
:
'
dangerouslyProcessChildrenUpdates
'
}
)
;
module
.
exports
=
ReactDOMIDOperations
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
DOMProperty
=
__webpack_require__
(
38
)
;
var
ReactBrowserEventEmitter
=
__webpack_require__
(
44
)
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
ReactDOMFeatureFlags
=
__webpack_require__
(
56
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactEmptyComponentRegistry
=
__webpack_require__
(
59
)
;
var
ReactInstanceHandles
=
__webpack_require__
(
60
)
;
var
ReactInstanceMap
=
__webpack_require__
(
62
)
;
var
ReactMarkupChecksum
=
__webpack_require__
(
63
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
ReactReconciler
=
__webpack_require__
(
65
)
;
var
ReactUpdateQueue
=
__webpack_require__
(
68
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
emptyObject
=
__webpack_require__
(
73
)
;
var
containsNode
=
__webpack_require__
(
74
)
;
var
instantiateReactComponent
=
__webpack_require__
(
77
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
setInnerHTML
=
__webpack_require__
(
34
)
;
var
shouldUpdateReactComponent
=
__webpack_require__
(
82
)
;
var
validateDOMNesting
=
__webpack_require__
(
85
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
ATTR_NAME
=
DOMProperty
.
ID_ATTRIBUTE_NAME
;
var
nodeCache
=
{
}
;
var
ELEMENT_NODE_TYPE
=
1
;
var
DOC_NODE_TYPE
=
9
;
var
DOCUMENT_FRAGMENT_NODE_TYPE
=
11
;
var
ownerDocumentContextKey
=
'
__ReactMount_ownerDocument
'
+
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
var
instancesByReactRootID
=
{
}
;
var
containersByReactRootID
=
{
}
;
if
(
false
)
{
var
rootElementsByReactRootID
=
{
}
;
}
var
findComponentRootReusableArray
=
[
]
;
function
firstDifferenceIndex
(
string1
string2
)
{
var
minLen
=
Math
.
min
(
string1
.
length
string2
.
length
)
;
for
(
var
i
=
0
;
i
<
minLen
;
i
+
+
)
{
if
(
string1
.
charAt
(
i
)
!
=
=
string2
.
charAt
(
i
)
)
{
return
i
;
}
}
return
string1
.
length
=
=
=
string2
.
length
?
-
1
:
minLen
;
}
function
getReactRootElementInContainer
(
container
)
{
if
(
!
container
)
{
return
null
;
}
if
(
container
.
nodeType
=
=
=
DOC_NODE_TYPE
)
{
return
container
.
documentElement
;
}
else
{
return
container
.
firstChild
;
}
}
function
getReactRootID
(
container
)
{
var
rootElement
=
getReactRootElementInContainer
(
container
)
;
return
rootElement
&
&
ReactMount
.
getID
(
rootElement
)
;
}
function
getID
(
node
)
{
var
id
=
internalGetID
(
node
)
;
if
(
id
)
{
if
(
nodeCache
.
hasOwnProperty
(
id
)
)
{
var
cached
=
nodeCache
[
id
]
;
if
(
cached
!
=
=
node
)
{
!
!
isValid
(
cached
id
)
?
false
?
invariant
(
false
'
ReactMount
:
Two
valid
but
unequal
nodes
with
the
same
%
s
:
%
s
'
ATTR_NAME
id
)
:
invariant
(
false
)
:
undefined
;
nodeCache
[
id
]
=
node
;
}
}
else
{
nodeCache
[
id
]
=
node
;
}
}
return
id
;
}
function
internalGetID
(
node
)
{
return
node
&
&
node
.
getAttribute
&
&
node
.
getAttribute
(
ATTR_NAME
)
|
|
'
'
;
}
function
setID
(
node
id
)
{
var
oldID
=
internalGetID
(
node
)
;
if
(
oldID
!
=
=
id
)
{
delete
nodeCache
[
oldID
]
;
}
node
.
setAttribute
(
ATTR_NAME
id
)
;
nodeCache
[
id
]
=
node
;
}
function
getNode
(
id
)
{
if
(
!
nodeCache
.
hasOwnProperty
(
id
)
|
|
!
isValid
(
nodeCache
[
id
]
id
)
)
{
nodeCache
[
id
]
=
ReactMount
.
findReactNodeByID
(
id
)
;
}
return
nodeCache
[
id
]
;
}
function
getNodeFromInstance
(
instance
)
{
var
id
=
ReactInstanceMap
.
get
(
instance
)
.
_rootNodeID
;
if
(
ReactEmptyComponentRegistry
.
isNullComponentID
(
id
)
)
{
return
null
;
}
if
(
!
nodeCache
.
hasOwnProperty
(
id
)
|
|
!
isValid
(
nodeCache
[
id
]
id
)
)
{
nodeCache
[
id
]
=
ReactMount
.
findReactNodeByID
(
id
)
;
}
return
nodeCache
[
id
]
;
}
function
isValid
(
node
id
)
{
if
(
node
)
{
!
(
internalGetID
(
node
)
=
=
=
id
)
?
false
?
invariant
(
false
'
ReactMount
:
Unexpected
modification
of
%
s
'
ATTR_NAME
)
:
invariant
(
false
)
:
undefined
;
var
container
=
ReactMount
.
findReactContainerForID
(
id
)
;
if
(
container
&
&
containsNode
(
container
node
)
)
{
return
true
;
}
}
return
false
;
}
function
purgeID
(
id
)
{
delete
nodeCache
[
id
]
;
}
var
deepestNodeSoFar
=
null
;
function
findDeepestCachedAncestorImpl
(
ancestorID
)
{
var
ancestor
=
nodeCache
[
ancestorID
]
;
if
(
ancestor
&
&
isValid
(
ancestor
ancestorID
)
)
{
deepestNodeSoFar
=
ancestor
;
}
else
{
return
false
;
}
}
function
findDeepestCachedAncestor
(
targetID
)
{
deepestNodeSoFar
=
null
;
ReactInstanceHandles
.
traverseAncestors
(
targetID
findDeepestCachedAncestorImpl
)
;
var
foundNode
=
deepestNodeSoFar
;
deepestNodeSoFar
=
null
;
return
foundNode
;
}
function
mountComponentIntoNode
(
componentInstance
rootID
container
transaction
shouldReuseMarkup
context
)
{
if
(
ReactDOMFeatureFlags
.
useCreateElement
)
{
context
=
assign
(
{
}
context
)
;
if
(
container
.
nodeType
=
=
=
DOC_NODE_TYPE
)
{
context
[
ownerDocumentContextKey
]
=
container
;
}
else
{
context
[
ownerDocumentContextKey
]
=
container
.
ownerDocument
;
}
}
if
(
false
)
{
if
(
context
=
=
=
emptyObject
)
{
context
=
{
}
;
}
var
tag
=
container
.
nodeName
.
toLowerCase
(
)
;
context
[
validateDOMNesting
.
ancestorInfoContextKey
]
=
validateDOMNesting
.
updatedAncestorInfo
(
null
tag
null
)
;
}
var
markup
=
ReactReconciler
.
mountComponent
(
componentInstance
rootID
transaction
context
)
;
componentInstance
.
_renderedComponent
.
_topLevelWrapper
=
componentInstance
;
ReactMount
.
_mountImageIntoNode
(
markup
container
shouldReuseMarkup
transaction
)
;
}
function
batchedMountComponentIntoNode
(
componentInstance
rootID
container
shouldReuseMarkup
context
)
{
var
transaction
=
ReactUpdates
.
ReactReconcileTransaction
.
getPooled
(
shouldReuseMarkup
)
;
transaction
.
perform
(
mountComponentIntoNode
null
componentInstance
rootID
container
transaction
shouldReuseMarkup
context
)
;
ReactUpdates
.
ReactReconcileTransaction
.
release
(
transaction
)
;
}
function
unmountComponentFromNode
(
instance
container
)
{
ReactReconciler
.
unmountComponent
(
instance
)
;
if
(
container
.
nodeType
=
=
=
DOC_NODE_TYPE
)
{
container
=
container
.
documentElement
;
}
while
(
container
.
lastChild
)
{
container
.
removeChild
(
container
.
lastChild
)
;
}
}
function
hasNonRootReactChild
(
node
)
{
var
reactRootID
=
getReactRootID
(
node
)
;
return
reactRootID
?
reactRootID
!
=
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
reactRootID
)
:
false
;
}
function
findFirstReactDOMImpl
(
node
)
{
for
(
;
node
&
&
node
.
parentNode
!
=
=
node
;
node
=
node
.
parentNode
)
{
if
(
node
.
nodeType
!
=
=
1
)
{
continue
;
}
var
nodeID
=
internalGetID
(
node
)
;
if
(
!
nodeID
)
{
continue
;
}
var
reactRootID
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
nodeID
)
;
var
current
=
node
;
var
lastID
;
do
{
lastID
=
internalGetID
(
current
)
;
current
=
current
.
parentNode
;
if
(
current
=
=
null
)
{
return
null
;
}
}
while
(
lastID
!
=
=
reactRootID
)
;
if
(
current
=
=
=
containersByReactRootID
[
reactRootID
]
)
{
return
node
;
}
}
return
null
;
}
var
TopLevelWrapper
=
function
(
)
{
}
;
TopLevelWrapper
.
prototype
.
isReactComponent
=
{
}
;
if
(
false
)
{
TopLevelWrapper
.
displayName
=
'
TopLevelWrapper
'
;
}
TopLevelWrapper
.
prototype
.
render
=
function
(
)
{
return
this
.
props
;
}
;
var
ReactMount
=
{
TopLevelWrapper
:
TopLevelWrapper
_instancesByReactRootID
:
instancesByReactRootID
scrollMonitor
:
function
(
container
renderCallback
)
{
renderCallback
(
)
;
}
_updateRootComponent
:
function
(
prevComponent
nextElement
container
callback
)
{
ReactMount
.
scrollMonitor
(
container
function
(
)
{
ReactUpdateQueue
.
enqueueElementInternal
(
prevComponent
nextElement
)
;
if
(
callback
)
{
ReactUpdateQueue
.
enqueueCallbackInternal
(
prevComponent
callback
)
;
}
}
)
;
if
(
false
)
{
rootElementsByReactRootID
[
getReactRootID
(
container
)
]
=
getReactRootElementInContainer
(
container
)
;
}
return
prevComponent
;
}
_registerComponent
:
function
(
nextComponent
container
)
{
!
(
container
&
&
(
container
.
nodeType
=
=
=
ELEMENT_NODE_TYPE
|
|
container
.
nodeType
=
=
=
DOC_NODE_TYPE
|
|
container
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE_TYPE
)
)
?
false
?
invariant
(
false
'
_registerComponent
(
.
.
.
)
:
Target
container
is
not
a
DOM
element
.
'
)
:
invariant
(
false
)
:
undefined
;
ReactBrowserEventEmitter
.
ensureScrollValueMonitoring
(
)
;
var
reactRootID
=
ReactMount
.
registerContainer
(
container
)
;
instancesByReactRootID
[
reactRootID
]
=
nextComponent
;
return
reactRootID
;
}
_renderNewRootComponent
:
function
(
nextElement
container
shouldReuseMarkup
context
)
{
false
?
warning
(
ReactCurrentOwner
.
current
=
=
null
'
_renderNewRootComponent
(
)
:
Render
methods
should
be
a
pure
function
'
+
'
of
props
and
state
;
triggering
nested
component
updates
from
'
+
'
render
is
not
allowed
.
If
necessary
trigger
nested
updates
in
'
+
'
componentDidUpdate
.
Check
the
render
method
of
%
s
.
'
ReactCurrentOwner
.
current
&
&
ReactCurrentOwner
.
current
.
getName
(
)
|
|
'
ReactCompositeComponent
'
)
:
undefined
;
var
componentInstance
=
instantiateReactComponent
(
nextElement
null
)
;
var
reactRootID
=
ReactMount
.
_registerComponent
(
componentInstance
container
)
;
ReactUpdates
.
batchedUpdates
(
batchedMountComponentIntoNode
componentInstance
reactRootID
container
shouldReuseMarkup
context
)
;
if
(
false
)
{
rootElementsByReactRootID
[
reactRootID
]
=
getReactRootElementInContainer
(
container
)
;
}
return
componentInstance
;
}
renderSubtreeIntoContainer
:
function
(
parentComponent
nextElement
container
callback
)
{
!
(
parentComponent
!
=
null
&
&
parentComponent
.
_reactInternalInstance
!
=
null
)
?
false
?
invariant
(
false
'
parentComponent
must
be
a
valid
React
Component
'
)
:
invariant
(
false
)
:
undefined
;
return
ReactMount
.
_renderSubtreeIntoContainer
(
parentComponent
nextElement
container
callback
)
;
}
_renderSubtreeIntoContainer
:
function
(
parentComponent
nextElement
container
callback
)
{
!
ReactElement
.
isValidElement
(
nextElement
)
?
false
?
invariant
(
false
'
ReactDOM
.
render
(
)
:
Invalid
component
element
.
%
s
'
typeof
nextElement
=
=
=
'
string
'
?
'
Instead
of
passing
an
element
string
make
sure
to
instantiate
'
+
'
it
by
passing
it
to
React
.
createElement
.
'
:
typeof
nextElement
=
=
=
'
function
'
?
'
Instead
of
passing
a
component
class
make
sure
to
instantiate
'
+
'
it
by
passing
it
to
React
.
createElement
.
'
:
nextElement
!
=
null
&
&
nextElement
.
props
!
=
=
undefined
?
'
This
may
be
caused
by
unintentionally
loading
two
independent
'
+
'
copies
of
React
.
'
:
'
'
)
:
invariant
(
false
)
:
undefined
;
false
?
warning
(
!
container
|
|
!
container
.
tagName
|
|
container
.
tagName
.
toUpperCase
(
)
!
=
=
'
BODY
'
'
render
(
)
:
Rendering
components
directly
into
document
.
body
is
'
+
'
discouraged
since
its
children
are
often
manipulated
by
third
-
party
'
+
'
scripts
and
browser
extensions
.
This
may
lead
to
subtle
'
+
'
reconciliation
issues
.
Try
rendering
into
a
container
element
created
'
+
'
for
your
app
.
'
)
:
undefined
;
var
nextWrappedElement
=
new
ReactElement
(
TopLevelWrapper
null
null
null
null
null
nextElement
)
;
var
prevComponent
=
instancesByReactRootID
[
getReactRootID
(
container
)
]
;
if
(
prevComponent
)
{
var
prevWrappedElement
=
prevComponent
.
_currentElement
;
var
prevElement
=
prevWrappedElement
.
props
;
if
(
shouldUpdateReactComponent
(
prevElement
nextElement
)
)
{
var
publicInst
=
prevComponent
.
_renderedComponent
.
getPublicInstance
(
)
;
var
updatedCallback
=
callback
&
&
function
(
)
{
callback
.
call
(
publicInst
)
;
}
;
ReactMount
.
_updateRootComponent
(
prevComponent
nextWrappedElement
container
updatedCallback
)
;
return
publicInst
;
}
else
{
ReactMount
.
unmountComponentAtNode
(
container
)
;
}
}
var
reactRootElement
=
getReactRootElementInContainer
(
container
)
;
var
containerHasReactMarkup
=
reactRootElement
&
&
!
!
internalGetID
(
reactRootElement
)
;
var
containerHasNonRootReactChild
=
hasNonRootReactChild
(
container
)
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
containerHasNonRootReactChild
'
render
(
.
.
.
)
:
Replacing
React
-
rendered
children
with
a
new
root
'
+
'
component
.
If
you
intended
to
update
the
children
of
this
node
'
+
'
you
should
instead
have
the
existing
children
update
their
state
'
+
'
and
render
the
new
components
instead
of
calling
ReactDOM
.
render
.
'
)
:
undefined
;
if
(
!
containerHasReactMarkup
|
|
reactRootElement
.
nextSibling
)
{
var
rootElementSibling
=
reactRootElement
;
while
(
rootElementSibling
)
{
if
(
internalGetID
(
rootElementSibling
)
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
render
(
)
:
Target
node
has
markup
rendered
by
React
but
there
'
+
'
are
unrelated
nodes
as
well
.
This
is
most
commonly
caused
by
'
+
'
white
-
space
inserted
around
server
-
rendered
markup
.
'
)
:
undefined
;
break
;
}
rootElementSibling
=
rootElementSibling
.
nextSibling
;
}
}
}
var
shouldReuseMarkup
=
containerHasReactMarkup
&
&
!
prevComponent
&
&
!
containerHasNonRootReactChild
;
var
component
=
ReactMount
.
_renderNewRootComponent
(
nextWrappedElement
container
shouldReuseMarkup
parentComponent
!
=
null
?
parentComponent
.
_reactInternalInstance
.
_processChildContext
(
parentComponent
.
_reactInternalInstance
.
_context
)
:
emptyObject
)
.
_renderedComponent
.
getPublicInstance
(
)
;
if
(
callback
)
{
callback
.
call
(
component
)
;
}
return
component
;
}
render
:
function
(
nextElement
container
callback
)
{
return
ReactMount
.
_renderSubtreeIntoContainer
(
null
nextElement
container
callback
)
;
}
registerContainer
:
function
(
container
)
{
var
reactRootID
=
getReactRootID
(
container
)
;
if
(
reactRootID
)
{
reactRootID
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
reactRootID
)
;
}
if
(
!
reactRootID
)
{
reactRootID
=
ReactInstanceHandles
.
createReactRootID
(
)
;
}
containersByReactRootID
[
reactRootID
]
=
container
;
return
reactRootID
;
}
unmountComponentAtNode
:
function
(
container
)
{
false
?
warning
(
ReactCurrentOwner
.
current
=
=
null
'
unmountComponentAtNode
(
)
:
Render
methods
should
be
a
pure
function
'
+
'
of
props
and
state
;
triggering
nested
component
updates
from
render
'
+
'
is
not
allowed
.
If
necessary
trigger
nested
updates
in
'
+
'
componentDidUpdate
.
Check
the
render
method
of
%
s
.
'
ReactCurrentOwner
.
current
&
&
ReactCurrentOwner
.
current
.
getName
(
)
|
|
'
ReactCompositeComponent
'
)
:
undefined
;
!
(
container
&
&
(
container
.
nodeType
=
=
=
ELEMENT_NODE_TYPE
|
|
container
.
nodeType
=
=
=
DOC_NODE_TYPE
|
|
container
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE_TYPE
)
)
?
false
?
invariant
(
false
'
unmountComponentAtNode
(
.
.
.
)
:
Target
container
is
not
a
DOM
element
.
'
)
:
invariant
(
false
)
:
undefined
;
var
reactRootID
=
getReactRootID
(
container
)
;
var
component
=
instancesByReactRootID
[
reactRootID
]
;
if
(
!
component
)
{
var
containerHasNonRootReactChild
=
hasNonRootReactChild
(
container
)
;
var
containerID
=
internalGetID
(
container
)
;
var
isContainerReactRoot
=
containerID
&
&
containerID
=
=
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
containerID
)
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
containerHasNonRootReactChild
'
unmountComponentAtNode
(
)
:
The
node
you
\
'
re
attempting
to
unmount
'
+
'
was
rendered
by
React
and
is
not
a
top
-
level
container
.
%
s
'
isContainerReactRoot
?
'
You
may
have
accidentally
passed
in
a
React
root
node
instead
'
+
'
of
its
container
.
'
:
'
Instead
have
the
parent
component
update
its
state
and
'
+
'
rerender
in
order
to
remove
this
component
.
'
)
:
undefined
;
}
return
false
;
}
ReactUpdates
.
batchedUpdates
(
unmountComponentFromNode
component
container
)
;
delete
instancesByReactRootID
[
reactRootID
]
;
delete
containersByReactRootID
[
reactRootID
]
;
if
(
false
)
{
delete
rootElementsByReactRootID
[
reactRootID
]
;
}
return
true
;
}
findReactContainerForID
:
function
(
id
)
{
var
reactRootID
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
id
)
;
var
container
=
containersByReactRootID
[
reactRootID
]
;
if
(
false
)
{
var
rootElement
=
rootElementsByReactRootID
[
reactRootID
]
;
if
(
rootElement
&
&
rootElement
.
parentNode
!
=
=
container
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
internalGetID
(
rootElement
)
=
=
=
reactRootID
'
ReactMount
:
Root
element
ID
differed
from
reactRootID
.
'
)
:
undefined
;
var
containerChild
=
container
.
firstChild
;
if
(
containerChild
&
&
reactRootID
=
=
=
internalGetID
(
containerChild
)
)
{
rootElementsByReactRootID
[
reactRootID
]
=
containerChild
;
}
else
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
ReactMount
:
Root
element
has
been
removed
from
its
original
'
+
'
container
.
New
container
:
%
s
'
rootElement
.
parentNode
)
:
undefined
;
}
}
}
return
container
;
}
findReactNodeByID
:
function
(
id
)
{
var
reactRoot
=
ReactMount
.
findReactContainerForID
(
id
)
;
return
ReactMount
.
findComponentRoot
(
reactRoot
id
)
;
}
getFirstReactDOM
:
function
(
node
)
{
return
findFirstReactDOMImpl
(
node
)
;
}
findComponentRoot
:
function
(
ancestorNode
targetID
)
{
var
firstChildren
=
findComponentRootReusableArray
;
var
childIndex
=
0
;
var
deepestAncestor
=
findDeepestCachedAncestor
(
targetID
)
|
|
ancestorNode
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
deepestAncestor
!
=
null
'
React
can
\
'
t
find
the
root
component
node
for
data
-
reactid
value
'
+
'
%
s
.
If
you
\
'
re
seeing
this
message
it
probably
means
that
'
+
'
you
\
'
ve
loaded
two
copies
of
React
on
the
page
.
At
this
time
only
'
+
'
a
single
copy
of
React
can
be
loaded
at
a
time
.
'
targetID
)
:
undefined
;
}
firstChildren
[
0
]
=
deepestAncestor
.
firstChild
;
firstChildren
.
length
=
1
;
while
(
childIndex
<
firstChildren
.
length
)
{
var
child
=
firstChildren
[
childIndex
+
+
]
;
var
targetChild
;
while
(
child
)
{
var
childID
=
ReactMount
.
getID
(
child
)
;
if
(
childID
)
{
if
(
targetID
=
=
=
childID
)
{
targetChild
=
child
;
}
else
if
(
ReactInstanceHandles
.
isAncestorIDOf
(
childID
targetID
)
)
{
firstChildren
.
length
=
childIndex
=
0
;
firstChildren
.
push
(
child
.
firstChild
)
;
}
}
else
{
firstChildren
.
push
(
child
.
firstChild
)
;
}
child
=
child
.
nextSibling
;
}
if
(
targetChild
)
{
firstChildren
.
length
=
0
;
return
targetChild
;
}
}
firstChildren
.
length
=
0
;
true
?
false
?
invariant
(
false
'
findComponentRoot
(
.
.
.
%
s
)
:
Unable
to
find
element
.
This
probably
'
+
'
means
the
DOM
was
unexpectedly
mutated
(
e
.
g
.
by
the
browser
)
'
+
'
usually
due
to
forgetting
a
<
tbody
>
when
using
tables
nesting
tags
'
+
'
like
<
form
>
<
p
>
or
<
a
>
or
using
non
-
SVG
elements
in
an
<
svg
>
'
+
'
parent
.
'
+
'
Try
inspecting
the
child
nodes
of
the
element
with
React
ID
%
s
.
'
targetID
ReactMount
.
getID
(
ancestorNode
)
)
:
invariant
(
false
)
:
undefined
;
}
_mountImageIntoNode
:
function
(
markup
container
shouldReuseMarkup
transaction
)
{
!
(
container
&
&
(
container
.
nodeType
=
=
=
ELEMENT_NODE_TYPE
|
|
container
.
nodeType
=
=
=
DOC_NODE_TYPE
|
|
container
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE_TYPE
)
)
?
false
?
invariant
(
false
'
mountComponentIntoNode
(
.
.
.
)
:
Target
container
is
not
valid
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
shouldReuseMarkup
)
{
var
rootElement
=
getReactRootElementInContainer
(
container
)
;
if
(
ReactMarkupChecksum
.
canReuseMarkup
(
markup
rootElement
)
)
{
return
;
}
else
{
var
checksum
=
rootElement
.
getAttribute
(
ReactMarkupChecksum
.
CHECKSUM_ATTR_NAME
)
;
rootElement
.
removeAttribute
(
ReactMarkupChecksum
.
CHECKSUM_ATTR_NAME
)
;
var
rootMarkup
=
rootElement
.
outerHTML
;
rootElement
.
setAttribute
(
ReactMarkupChecksum
.
CHECKSUM_ATTR_NAME
checksum
)
;
var
normalizedMarkup
=
markup
;
if
(
false
)
{
var
normalizer
;
if
(
container
.
nodeType
=
=
=
ELEMENT_NODE_TYPE
)
{
normalizer
=
document
.
createElement
(
'
div
'
)
;
normalizer
.
innerHTML
=
markup
;
normalizedMarkup
=
normalizer
.
innerHTML
;
}
else
{
normalizer
=
document
.
createElement
(
'
iframe
'
)
;
document
.
body
.
appendChild
(
normalizer
)
;
normalizer
.
contentDocument
.
write
(
markup
)
;
normalizedMarkup
=
normalizer
.
contentDocument
.
documentElement
.
outerHTML
;
document
.
body
.
removeChild
(
normalizer
)
;
}
}
var
diffIndex
=
firstDifferenceIndex
(
normalizedMarkup
rootMarkup
)
;
var
difference
=
'
(
client
)
'
+
normalizedMarkup
.
substring
(
diffIndex
-
20
diffIndex
+
20
)
+
'
\
n
(
server
)
'
+
rootMarkup
.
substring
(
diffIndex
-
20
diffIndex
+
20
)
;
!
(
container
.
nodeType
!
=
=
DOC_NODE_TYPE
)
?
false
?
invariant
(
false
'
You
\
'
re
trying
to
render
a
component
to
the
document
using
'
+
'
server
rendering
but
the
checksum
was
invalid
.
This
usually
'
+
'
means
you
rendered
a
different
component
type
or
props
on
'
+
'
the
client
from
the
one
on
the
server
or
your
render
(
)
'
+
'
methods
are
impure
.
React
cannot
handle
this
case
due
to
'
+
'
cross
-
browser
quirks
by
rendering
at
the
document
root
.
You
'
+
'
should
look
for
environment
dependent
code
in
your
components
'
+
'
and
ensure
the
props
are
the
same
client
and
server
side
:
\
n
%
s
'
difference
)
:
invariant
(
false
)
:
undefined
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
React
attempted
to
reuse
markup
in
a
container
but
the
'
+
'
checksum
was
invalid
.
This
generally
means
that
you
are
'
+
'
using
server
rendering
and
the
markup
generated
on
the
'
+
'
server
was
not
what
the
client
was
expecting
.
React
injected
'
+
'
new
markup
to
compensate
which
works
but
you
have
lost
many
'
+
'
of
the
benefits
of
server
rendering
.
Instead
figure
out
'
+
'
why
the
markup
being
generated
is
different
on
the
client
'
+
'
or
server
:
\
n
%
s
'
difference
)
:
undefined
;
}
}
}
!
(
container
.
nodeType
!
=
=
DOC_NODE_TYPE
)
?
false
?
invariant
(
false
'
You
\
'
re
trying
to
render
a
component
to
the
document
but
'
+
'
you
didn
\
'
t
use
server
rendering
.
We
can
\
'
t
do
this
'
+
'
without
using
server
rendering
due
to
cross
-
browser
quirks
.
'
+
'
See
ReactDOMServer
.
renderToString
(
)
for
server
rendering
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
transaction
.
useCreateElement
)
{
while
(
container
.
lastChild
)
{
container
.
removeChild
(
container
.
lastChild
)
;
}
container
.
appendChild
(
markup
)
;
}
else
{
setInnerHTML
(
container
markup
)
;
}
}
ownerDocumentContextKey
:
ownerDocumentContextKey
getReactRootID
:
getReactRootID
getID
:
getID
setID
:
setID
getNode
:
getNode
getNodeFromInstance
:
getNodeFromInstance
isValid
:
isValid
purgeID
:
purgeID
}
;
ReactPerf
.
measureMethods
(
ReactMount
'
ReactMount
'
{
_renderNewRootComponent
:
'
_renderNewRootComponent
'
_mountImageIntoNode
:
'
_mountImageIntoNode
'
}
)
;
module
.
exports
=
ReactMount
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
EventPluginHub
=
__webpack_require__
(
46
)
;
var
EventPluginRegistry
=
__webpack_require__
(
47
)
;
var
ReactEventEmitterMixin
=
__webpack_require__
(
52
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
ViewportMetrics
=
__webpack_require__
(
53
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
isEventSupported
=
__webpack_require__
(
55
)
;
var
alreadyListeningTo
=
{
}
;
var
isMonitoringScrollValue
=
false
;
var
reactTopListenersCounter
=
0
;
var
topEventMapping
=
{
topAbort
:
'
abort
'
topBlur
:
'
blur
'
topCanPlay
:
'
canplay
'
topCanPlayThrough
:
'
canplaythrough
'
topChange
:
'
change
'
topClick
:
'
click
'
topCompositionEnd
:
'
compositionend
'
topCompositionStart
:
'
compositionstart
'
topCompositionUpdate
:
'
compositionupdate
'
topContextMenu
:
'
contextmenu
'
topCopy
:
'
copy
'
topCut
:
'
cut
'
topDoubleClick
:
'
dblclick
'
topDrag
:
'
drag
'
topDragEnd
:
'
dragend
'
topDragEnter
:
'
dragenter
'
topDragExit
:
'
dragexit
'
topDragLeave
:
'
dragleave
'
topDragOver
:
'
dragover
'
topDragStart
:
'
dragstart
'
topDrop
:
'
drop
'
topDurationChange
:
'
durationchange
'
topEmptied
:
'
emptied
'
topEncrypted
:
'
encrypted
'
topEnded
:
'
ended
'
topError
:
'
error
'
topFocus
:
'
focus
'
topInput
:
'
input
'
topKeyDown
:
'
keydown
'
topKeyPress
:
'
keypress
'
topKeyUp
:
'
keyup
'
topLoadedData
:
'
loadeddata
'
topLoadedMetadata
:
'
loadedmetadata
'
topLoadStart
:
'
loadstart
'
topMouseDown
:
'
mousedown
'
topMouseMove
:
'
mousemove
'
topMouseOut
:
'
mouseout
'
topMouseOver
:
'
mouseover
'
topMouseUp
:
'
mouseup
'
topPaste
:
'
paste
'
topPause
:
'
pause
'
topPlay
:
'
play
'
topPlaying
:
'
playing
'
topProgress
:
'
progress
'
topRateChange
:
'
ratechange
'
topScroll
:
'
scroll
'
topSeeked
:
'
seeked
'
topSeeking
:
'
seeking
'
topSelectionChange
:
'
selectionchange
'
topStalled
:
'
stalled
'
topSuspend
:
'
suspend
'
topTextInput
:
'
textInput
'
topTimeUpdate
:
'
timeupdate
'
topTouchCancel
:
'
touchcancel
'
topTouchEnd
:
'
touchend
'
topTouchMove
:
'
touchmove
'
topTouchStart
:
'
touchstart
'
topVolumeChange
:
'
volumechange
'
topWaiting
:
'
waiting
'
topWheel
:
'
wheel
'
}
;
var
topListenersIDKey
=
'
_reactListenersID
'
+
String
(
Math
.
random
(
)
)
.
slice
(
2
)
;
function
getListeningForDocument
(
mountAt
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
mountAt
topListenersIDKey
)
)
{
mountAt
[
topListenersIDKey
]
=
reactTopListenersCounter
+
+
;
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
=
{
}
;
}
return
alreadyListeningTo
[
mountAt
[
topListenersIDKey
]
]
;
}
var
ReactBrowserEventEmitter
=
assign
(
{
}
ReactEventEmitterMixin
{
ReactEventListener
:
null
injection
:
{
injectReactEventListener
:
function
(
ReactEventListener
)
{
ReactEventListener
.
setHandleTopLevel
(
ReactBrowserEventEmitter
.
handleTopLevel
)
;
ReactBrowserEventEmitter
.
ReactEventListener
=
ReactEventListener
;
}
}
setEnabled
:
function
(
enabled
)
{
if
(
ReactBrowserEventEmitter
.
ReactEventListener
)
{
ReactBrowserEventEmitter
.
ReactEventListener
.
setEnabled
(
enabled
)
;
}
}
isEnabled
:
function
(
)
{
return
!
!
(
ReactBrowserEventEmitter
.
ReactEventListener
&
&
ReactBrowserEventEmitter
.
ReactEventListener
.
isEnabled
(
)
)
;
}
listenTo
:
function
(
registrationName
contentDocumentHandle
)
{
var
mountAt
=
contentDocumentHandle
;
var
isListening
=
getListeningForDocument
(
mountAt
)
;
var
dependencies
=
EventPluginRegistry
.
registrationNameDependencies
[
registrationName
]
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
for
(
var
i
=
0
;
i
<
dependencies
.
length
;
i
+
+
)
{
var
dependency
=
dependencies
[
i
]
;
if
(
!
(
isListening
.
hasOwnProperty
(
dependency
)
&
&
isListening
[
dependency
]
)
)
{
if
(
dependency
=
=
=
topLevelTypes
.
topWheel
)
{
if
(
isEventSupported
(
'
wheel
'
)
)
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
topLevelTypes
.
topWheel
'
wheel
'
mountAt
)
;
}
else
if
(
isEventSupported
(
'
mousewheel
'
)
)
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
topLevelTypes
.
topWheel
'
mousewheel
'
mountAt
)
;
}
else
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
topLevelTypes
.
topWheel
'
DOMMouseScroll
'
mountAt
)
;
}
}
else
if
(
dependency
=
=
=
topLevelTypes
.
topScroll
)
{
if
(
isEventSupported
(
'
scroll
'
true
)
)
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapCapturedEvent
(
topLevelTypes
.
topScroll
'
scroll
'
mountAt
)
;
}
else
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
topLevelTypes
.
topScroll
'
scroll
'
ReactBrowserEventEmitter
.
ReactEventListener
.
WINDOW_HANDLE
)
;
}
}
else
if
(
dependency
=
=
=
topLevelTypes
.
topFocus
|
|
dependency
=
=
=
topLevelTypes
.
topBlur
)
{
if
(
isEventSupported
(
'
focus
'
true
)
)
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapCapturedEvent
(
topLevelTypes
.
topFocus
'
focus
'
mountAt
)
;
ReactBrowserEventEmitter
.
ReactEventListener
.
trapCapturedEvent
(
topLevelTypes
.
topBlur
'
blur
'
mountAt
)
;
}
else
if
(
isEventSupported
(
'
focusin
'
)
)
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
topLevelTypes
.
topFocus
'
focusin
'
mountAt
)
;
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
topLevelTypes
.
topBlur
'
focusout
'
mountAt
)
;
}
isListening
[
topLevelTypes
.
topBlur
]
=
true
;
isListening
[
topLevelTypes
.
topFocus
]
=
true
;
}
else
if
(
topEventMapping
.
hasOwnProperty
(
dependency
)
)
{
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
dependency
topEventMapping
[
dependency
]
mountAt
)
;
}
isListening
[
dependency
]
=
true
;
}
}
}
trapBubbledEvent
:
function
(
topLevelType
handlerBaseName
handle
)
{
return
ReactBrowserEventEmitter
.
ReactEventListener
.
trapBubbledEvent
(
topLevelType
handlerBaseName
handle
)
;
}
trapCapturedEvent
:
function
(
topLevelType
handlerBaseName
handle
)
{
return
ReactBrowserEventEmitter
.
ReactEventListener
.
trapCapturedEvent
(
topLevelType
handlerBaseName
handle
)
;
}
ensureScrollValueMonitoring
:
function
(
)
{
if
(
!
isMonitoringScrollValue
)
{
var
refresh
=
ViewportMetrics
.
refreshScrollValues
;
ReactBrowserEventEmitter
.
ReactEventListener
.
monitorScrollValue
(
refresh
)
;
isMonitoringScrollValue
=
true
;
}
}
eventNameDispatchConfigs
:
EventPluginHub
.
eventNameDispatchConfigs
registrationNameModules
:
EventPluginHub
.
registrationNameModules
putListener
:
EventPluginHub
.
putListener
getListener
:
EventPluginHub
.
getListener
deleteListener
:
EventPluginHub
.
deleteListener
deleteAllListeners
:
EventPluginHub
.
deleteAllListeners
}
)
;
ReactPerf
.
measureMethods
(
ReactBrowserEventEmitter
'
ReactBrowserEventEmitter
'
{
putListener
:
'
putListener
'
deleteListener
:
'
deleteListener
'
}
)
;
module
.
exports
=
ReactBrowserEventEmitter
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
keyMirror
=
__webpack_require__
(
32
)
;
var
PropagationPhases
=
keyMirror
(
{
bubbled
:
null
captured
:
null
}
)
;
var
topLevelTypes
=
keyMirror
(
{
topAbort
:
null
topBlur
:
null
topCanPlay
:
null
topCanPlayThrough
:
null
topChange
:
null
topClick
:
null
topCompositionEnd
:
null
topCompositionStart
:
null
topCompositionUpdate
:
null
topContextMenu
:
null
topCopy
:
null
topCut
:
null
topDoubleClick
:
null
topDrag
:
null
topDragEnd
:
null
topDragEnter
:
null
topDragExit
:
null
topDragLeave
:
null
topDragOver
:
null
topDragStart
:
null
topDrop
:
null
topDurationChange
:
null
topEmptied
:
null
topEncrypted
:
null
topEnded
:
null
topError
:
null
topFocus
:
null
topInput
:
null
topKeyDown
:
null
topKeyPress
:
null
topKeyUp
:
null
topLoad
:
null
topLoadedData
:
null
topLoadedMetadata
:
null
topLoadStart
:
null
topMouseDown
:
null
topMouseMove
:
null
topMouseOut
:
null
topMouseOver
:
null
topMouseUp
:
null
topPaste
:
null
topPause
:
null
topPlay
:
null
topPlaying
:
null
topProgress
:
null
topRateChange
:
null
topReset
:
null
topScroll
:
null
topSeeked
:
null
topSeeking
:
null
topSelectionChange
:
null
topStalled
:
null
topSubmit
:
null
topSuspend
:
null
topTextInput
:
null
topTimeUpdate
:
null
topTouchCancel
:
null
topTouchEnd
:
null
topTouchMove
:
null
topTouchStart
:
null
topVolumeChange
:
null
topWaiting
:
null
topWheel
:
null
}
)
;
var
EventConstants
=
{
topLevelTypes
:
topLevelTypes
PropagationPhases
:
PropagationPhases
}
;
module
.
exports
=
EventConstants
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventPluginRegistry
=
__webpack_require__
(
47
)
;
var
EventPluginUtils
=
__webpack_require__
(
48
)
;
var
ReactErrorUtils
=
__webpack_require__
(
49
)
;
var
accumulateInto
=
__webpack_require__
(
50
)
;
var
forEachAccumulated
=
__webpack_require__
(
51
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
listenerBank
=
{
}
;
var
eventQueue
=
null
;
var
executeDispatchesAndRelease
=
function
(
event
simulated
)
{
if
(
event
)
{
EventPluginUtils
.
executeDispatchesInOrder
(
event
simulated
)
;
if
(
!
event
.
isPersistent
(
)
)
{
event
.
constructor
.
release
(
event
)
;
}
}
}
;
var
executeDispatchesAndReleaseSimulated
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
true
)
;
}
;
var
executeDispatchesAndReleaseTopLevel
=
function
(
e
)
{
return
executeDispatchesAndRelease
(
e
false
)
;
}
;
var
InstanceHandle
=
null
;
function
validateInstanceHandle
(
)
{
var
valid
=
InstanceHandle
&
&
InstanceHandle
.
traverseTwoPhase
&
&
InstanceHandle
.
traverseEnterLeave
;
false
?
warning
(
valid
'
InstanceHandle
not
injected
before
use
!
'
)
:
undefined
;
}
var
EventPluginHub
=
{
injection
:
{
injectMount
:
EventPluginUtils
.
injection
.
injectMount
injectInstanceHandle
:
function
(
InjectedInstanceHandle
)
{
InstanceHandle
=
InjectedInstanceHandle
;
if
(
false
)
{
validateInstanceHandle
(
)
;
}
}
getInstanceHandle
:
function
(
)
{
if
(
false
)
{
validateInstanceHandle
(
)
;
}
return
InstanceHandle
;
}
injectEventPluginOrder
:
EventPluginRegistry
.
injectEventPluginOrder
injectEventPluginsByName
:
EventPluginRegistry
.
injectEventPluginsByName
}
eventNameDispatchConfigs
:
EventPluginRegistry
.
eventNameDispatchConfigs
registrationNameModules
:
EventPluginRegistry
.
registrationNameModules
putListener
:
function
(
id
registrationName
listener
)
{
!
(
typeof
listener
=
=
=
'
function
'
)
?
false
?
invariant
(
false
'
Expected
%
s
listener
to
be
a
function
instead
got
type
%
s
'
registrationName
typeof
listener
)
:
invariant
(
false
)
:
undefined
;
var
bankForRegistrationName
=
listenerBank
[
registrationName
]
|
|
(
listenerBank
[
registrationName
]
=
{
}
)
;
bankForRegistrationName
[
id
]
=
listener
;
var
PluginModule
=
EventPluginRegistry
.
registrationNameModules
[
registrationName
]
;
if
(
PluginModule
&
&
PluginModule
.
didPutListener
)
{
PluginModule
.
didPutListener
(
id
registrationName
listener
)
;
}
}
getListener
:
function
(
id
registrationName
)
{
var
bankForRegistrationName
=
listenerBank
[
registrationName
]
;
return
bankForRegistrationName
&
&
bankForRegistrationName
[
id
]
;
}
deleteListener
:
function
(
id
registrationName
)
{
var
PluginModule
=
EventPluginRegistry
.
registrationNameModules
[
registrationName
]
;
if
(
PluginModule
&
&
PluginModule
.
willDeleteListener
)
{
PluginModule
.
willDeleteListener
(
id
registrationName
)
;
}
var
bankForRegistrationName
=
listenerBank
[
registrationName
]
;
if
(
bankForRegistrationName
)
{
delete
bankForRegistrationName
[
id
]
;
}
}
deleteAllListeners
:
function
(
id
)
{
for
(
var
registrationName
in
listenerBank
)
{
if
(
!
listenerBank
[
registrationName
]
[
id
]
)
{
continue
;
}
var
PluginModule
=
EventPluginRegistry
.
registrationNameModules
[
registrationName
]
;
if
(
PluginModule
&
&
PluginModule
.
willDeleteListener
)
{
PluginModule
.
willDeleteListener
(
id
registrationName
)
;
}
delete
listenerBank
[
registrationName
]
[
id
]
;
}
}
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
var
events
;
var
plugins
=
EventPluginRegistry
.
plugins
;
for
(
var
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
var
possiblePlugin
=
plugins
[
i
]
;
if
(
possiblePlugin
)
{
var
extractedEvents
=
possiblePlugin
.
extractEvents
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
;
if
(
extractedEvents
)
{
events
=
accumulateInto
(
events
extractedEvents
)
;
}
}
}
return
events
;
}
enqueueEvents
:
function
(
events
)
{
if
(
events
)
{
eventQueue
=
accumulateInto
(
eventQueue
events
)
;
}
}
processEventQueue
:
function
(
simulated
)
{
var
processingEventQueue
=
eventQueue
;
eventQueue
=
null
;
if
(
simulated
)
{
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseSimulated
)
;
}
else
{
forEachAccumulated
(
processingEventQueue
executeDispatchesAndReleaseTopLevel
)
;
}
!
!
eventQueue
?
false
?
invariant
(
false
'
processEventQueue
(
)
:
Additional
events
were
enqueued
while
processing
'
+
'
an
event
queue
.
Support
for
this
has
not
yet
been
implemented
.
'
)
:
invariant
(
false
)
:
undefined
;
ReactErrorUtils
.
rethrowCaughtError
(
)
;
}
__purge
:
function
(
)
{
listenerBank
=
{
}
;
}
__getListenerBank
:
function
(
)
{
return
listenerBank
;
}
}
;
module
.
exports
=
EventPluginHub
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
var
EventPluginOrder
=
null
;
var
namesToPlugins
=
{
}
;
function
recomputePluginOrdering
(
)
{
if
(
!
EventPluginOrder
)
{
return
;
}
for
(
var
pluginName
in
namesToPlugins
)
{
var
PluginModule
=
namesToPlugins
[
pluginName
]
;
var
pluginIndex
=
EventPluginOrder
.
indexOf
(
pluginName
)
;
!
(
pluginIndex
>
-
1
)
?
false
?
invariant
(
false
'
EventPluginRegistry
:
Cannot
inject
event
plugins
that
do
not
exist
in
'
+
'
the
plugin
ordering
%
s
.
'
pluginName
)
:
invariant
(
false
)
:
undefined
;
if
(
EventPluginRegistry
.
plugins
[
pluginIndex
]
)
{
continue
;
}
!
PluginModule
.
extractEvents
?
false
?
invariant
(
false
'
EventPluginRegistry
:
Event
plugins
must
implement
an
extractEvents
'
+
'
method
but
%
s
does
not
.
'
pluginName
)
:
invariant
(
false
)
:
undefined
;
EventPluginRegistry
.
plugins
[
pluginIndex
]
=
PluginModule
;
var
publishedEvents
=
PluginModule
.
eventTypes
;
for
(
var
eventName
in
publishedEvents
)
{
!
publishEventForPlugin
(
publishedEvents
[
eventName
]
PluginModule
eventName
)
?
false
?
invariant
(
false
'
EventPluginRegistry
:
Failed
to
publish
event
%
s
for
plugin
%
s
.
'
eventName
pluginName
)
:
invariant
(
false
)
:
undefined
;
}
}
}
function
publishEventForPlugin
(
dispatchConfig
PluginModule
eventName
)
{
!
!
EventPluginRegistry
.
eventNameDispatchConfigs
.
hasOwnProperty
(
eventName
)
?
false
?
invariant
(
false
'
EventPluginHub
:
More
than
one
plugin
attempted
to
publish
the
same
'
+
'
event
name
%
s
.
'
eventName
)
:
invariant
(
false
)
:
undefined
;
EventPluginRegistry
.
eventNameDispatchConfigs
[
eventName
]
=
dispatchConfig
;
var
phasedRegistrationNames
=
dispatchConfig
.
phasedRegistrationNames
;
if
(
phasedRegistrationNames
)
{
for
(
var
phaseName
in
phasedRegistrationNames
)
{
if
(
phasedRegistrationNames
.
hasOwnProperty
(
phaseName
)
)
{
var
phasedRegistrationName
=
phasedRegistrationNames
[
phaseName
]
;
publishRegistrationName
(
phasedRegistrationName
PluginModule
eventName
)
;
}
}
return
true
;
}
else
if
(
dispatchConfig
.
registrationName
)
{
publishRegistrationName
(
dispatchConfig
.
registrationName
PluginModule
eventName
)
;
return
true
;
}
return
false
;
}
function
publishRegistrationName
(
registrationName
PluginModule
eventName
)
{
!
!
EventPluginRegistry
.
registrationNameModules
[
registrationName
]
?
false
?
invariant
(
false
'
EventPluginHub
:
More
than
one
plugin
attempted
to
publish
the
same
'
+
'
registration
name
%
s
.
'
registrationName
)
:
invariant
(
false
)
:
undefined
;
EventPluginRegistry
.
registrationNameModules
[
registrationName
]
=
PluginModule
;
EventPluginRegistry
.
registrationNameDependencies
[
registrationName
]
=
PluginModule
.
eventTypes
[
eventName
]
.
dependencies
;
}
var
EventPluginRegistry
=
{
plugins
:
[
]
eventNameDispatchConfigs
:
{
}
registrationNameModules
:
{
}
registrationNameDependencies
:
{
}
injectEventPluginOrder
:
function
(
InjectedEventPluginOrder
)
{
!
!
EventPluginOrder
?
false
?
invariant
(
false
'
EventPluginRegistry
:
Cannot
inject
event
plugin
ordering
more
than
'
+
'
once
.
You
are
likely
trying
to
load
more
than
one
copy
of
React
.
'
)
:
invariant
(
false
)
:
undefined
;
EventPluginOrder
=
Array
.
prototype
.
slice
.
call
(
InjectedEventPluginOrder
)
;
recomputePluginOrdering
(
)
;
}
injectEventPluginsByName
:
function
(
injectedNamesToPlugins
)
{
var
isOrderingDirty
=
false
;
for
(
var
pluginName
in
injectedNamesToPlugins
)
{
if
(
!
injectedNamesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
continue
;
}
var
PluginModule
=
injectedNamesToPlugins
[
pluginName
]
;
if
(
!
namesToPlugins
.
hasOwnProperty
(
pluginName
)
|
|
namesToPlugins
[
pluginName
]
!
=
=
PluginModule
)
{
!
!
namesToPlugins
[
pluginName
]
?
false
?
invariant
(
false
'
EventPluginRegistry
:
Cannot
inject
two
different
event
plugins
'
+
'
using
the
same
name
%
s
.
'
pluginName
)
:
invariant
(
false
)
:
undefined
;
namesToPlugins
[
pluginName
]
=
PluginModule
;
isOrderingDirty
=
true
;
}
}
if
(
isOrderingDirty
)
{
recomputePluginOrdering
(
)
;
}
}
getPluginModuleForEvent
:
function
(
event
)
{
var
dispatchConfig
=
event
.
dispatchConfig
;
if
(
dispatchConfig
.
registrationName
)
{
return
EventPluginRegistry
.
registrationNameModules
[
dispatchConfig
.
registrationName
]
|
|
null
;
}
for
(
var
phase
in
dispatchConfig
.
phasedRegistrationNames
)
{
if
(
!
dispatchConfig
.
phasedRegistrationNames
.
hasOwnProperty
(
phase
)
)
{
continue
;
}
var
PluginModule
=
EventPluginRegistry
.
registrationNameModules
[
dispatchConfig
.
phasedRegistrationNames
[
phase
]
]
;
if
(
PluginModule
)
{
return
PluginModule
;
}
}
return
null
;
}
_resetEventPlugins
:
function
(
)
{
EventPluginOrder
=
null
;
for
(
var
pluginName
in
namesToPlugins
)
{
if
(
namesToPlugins
.
hasOwnProperty
(
pluginName
)
)
{
delete
namesToPlugins
[
pluginName
]
;
}
}
EventPluginRegistry
.
plugins
.
length
=
0
;
var
eventNameDispatchConfigs
=
EventPluginRegistry
.
eventNameDispatchConfigs
;
for
(
var
eventName
in
eventNameDispatchConfigs
)
{
if
(
eventNameDispatchConfigs
.
hasOwnProperty
(
eventName
)
)
{
delete
eventNameDispatchConfigs
[
eventName
]
;
}
}
var
registrationNameModules
=
EventPluginRegistry
.
registrationNameModules
;
for
(
var
registrationName
in
registrationNameModules
)
{
if
(
registrationNameModules
.
hasOwnProperty
(
registrationName
)
)
{
delete
registrationNameModules
[
registrationName
]
;
}
}
}
}
;
module
.
exports
=
EventPluginRegistry
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
ReactErrorUtils
=
__webpack_require__
(
49
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
injection
=
{
Mount
:
null
injectMount
:
function
(
InjectedMount
)
{
injection
.
Mount
=
InjectedMount
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
InjectedMount
&
&
InjectedMount
.
getNode
&
&
InjectedMount
.
getID
'
EventPluginUtils
.
injection
.
injectMount
(
.
.
.
)
:
Injected
Mount
'
+
'
module
is
missing
getNode
or
getID
.
'
)
:
undefined
;
}
}
}
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
function
isEndish
(
topLevelType
)
{
return
topLevelType
=
=
=
topLevelTypes
.
topMouseUp
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchEnd
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchCancel
;
}
function
isMoveish
(
topLevelType
)
{
return
topLevelType
=
=
=
topLevelTypes
.
topMouseMove
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchMove
;
}
function
isStartish
(
topLevelType
)
{
return
topLevelType
=
=
=
topLevelTypes
.
topMouseDown
|
|
topLevelType
=
=
=
topLevelTypes
.
topTouchStart
;
}
var
validateEventDispatches
;
if
(
false
)
{
validateEventDispatches
=
function
(
event
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchIDs
=
event
.
_dispatchIDs
;
var
listenersIsArr
=
Array
.
isArray
(
dispatchListeners
)
;
var
idsIsArr
=
Array
.
isArray
(
dispatchIDs
)
;
var
IDsLen
=
idsIsArr
?
dispatchIDs
.
length
:
dispatchIDs
?
1
:
0
;
var
listenersLen
=
listenersIsArr
?
dispatchListeners
.
length
:
dispatchListeners
?
1
:
0
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
idsIsArr
=
=
=
listenersIsArr
&
&
IDsLen
=
=
=
listenersLen
'
EventPluginUtils
:
Invalid
event
.
'
)
:
undefined
;
}
;
}
function
executeDispatch
(
event
simulated
listener
domID
)
{
var
type
=
event
.
type
|
|
'
unknown
-
event
'
;
event
.
currentTarget
=
injection
.
Mount
.
getNode
(
domID
)
;
if
(
simulated
)
{
ReactErrorUtils
.
invokeGuardedCallbackWithCatch
(
type
listener
event
domID
)
;
}
else
{
ReactErrorUtils
.
invokeGuardedCallback
(
type
listener
event
domID
)
;
}
event
.
currentTarget
=
null
;
}
function
executeDispatchesInOrder
(
event
simulated
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchIDs
=
event
.
_dispatchIDs
;
if
(
false
)
{
validateEventDispatches
(
event
)
;
}
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
executeDispatch
(
event
simulated
dispatchListeners
[
i
]
dispatchIDs
[
i
]
)
;
}
}
else
if
(
dispatchListeners
)
{
executeDispatch
(
event
simulated
dispatchListeners
dispatchIDs
)
;
}
event
.
_dispatchListeners
=
null
;
event
.
_dispatchIDs
=
null
;
}
function
executeDispatchesInOrderStopAtTrueImpl
(
event
)
{
var
dispatchListeners
=
event
.
_dispatchListeners
;
var
dispatchIDs
=
event
.
_dispatchIDs
;
if
(
false
)
{
validateEventDispatches
(
event
)
;
}
if
(
Array
.
isArray
(
dispatchListeners
)
)
{
for
(
var
i
=
0
;
i
<
dispatchListeners
.
length
;
i
+
+
)
{
if
(
event
.
isPropagationStopped
(
)
)
{
break
;
}
if
(
dispatchListeners
[
i
]
(
event
dispatchIDs
[
i
]
)
)
{
return
dispatchIDs
[
i
]
;
}
}
}
else
if
(
dispatchListeners
)
{
if
(
dispatchListeners
(
event
dispatchIDs
)
)
{
return
dispatchIDs
;
}
}
return
null
;
}
function
executeDispatchesInOrderStopAtTrue
(
event
)
{
var
ret
=
executeDispatchesInOrderStopAtTrueImpl
(
event
)
;
event
.
_dispatchIDs
=
null
;
event
.
_dispatchListeners
=
null
;
return
ret
;
}
function
executeDirectDispatch
(
event
)
{
if
(
false
)
{
validateEventDispatches
(
event
)
;
}
var
dispatchListener
=
event
.
_dispatchListeners
;
var
dispatchID
=
event
.
_dispatchIDs
;
!
!
Array
.
isArray
(
dispatchListener
)
?
false
?
invariant
(
false
'
executeDirectDispatch
(
.
.
.
)
:
Invalid
event
.
'
)
:
invariant
(
false
)
:
undefined
;
var
res
=
dispatchListener
?
dispatchListener
(
event
dispatchID
)
:
null
;
event
.
_dispatchListeners
=
null
;
event
.
_dispatchIDs
=
null
;
return
res
;
}
function
hasDispatches
(
event
)
{
return
!
!
event
.
_dispatchListeners
;
}
var
EventPluginUtils
=
{
isEndish
:
isEndish
isMoveish
:
isMoveish
isStartish
:
isStartish
executeDirectDispatch
:
executeDirectDispatch
executeDispatchesInOrder
:
executeDispatchesInOrder
executeDispatchesInOrderStopAtTrue
:
executeDispatchesInOrderStopAtTrue
hasDispatches
:
hasDispatches
getNode
:
function
(
id
)
{
return
injection
.
Mount
.
getNode
(
id
)
;
}
getID
:
function
(
node
)
{
return
injection
.
Mount
.
getID
(
node
)
;
}
injection
:
injection
}
;
module
.
exports
=
EventPluginUtils
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
caughtError
=
null
;
function
invokeGuardedCallback
(
name
func
a
b
)
{
try
{
return
func
(
a
b
)
;
}
catch
(
x
)
{
if
(
caughtError
=
=
=
null
)
{
caughtError
=
x
;
}
return
undefined
;
}
}
var
ReactErrorUtils
=
{
invokeGuardedCallback
:
invokeGuardedCallback
invokeGuardedCallbackWithCatch
:
invokeGuardedCallback
rethrowCaughtError
:
function
(
)
{
if
(
caughtError
)
{
var
error
=
caughtError
;
caughtError
=
null
;
throw
error
;
}
}
}
;
if
(
false
)
{
if
(
typeof
window
!
=
=
'
undefined
'
&
&
typeof
window
.
dispatchEvent
=
=
=
'
function
'
&
&
typeof
document
!
=
=
'
undefined
'
&
&
typeof
document
.
createEvent
=
=
=
'
function
'
)
{
var
fakeNode
=
document
.
createElement
(
'
react
'
)
;
ReactErrorUtils
.
invokeGuardedCallback
=
function
(
name
func
a
b
)
{
var
boundFunc
=
func
.
bind
(
null
a
b
)
;
var
evtType
=
'
react
-
'
+
name
;
fakeNode
.
addEventListener
(
evtType
boundFunc
false
)
;
var
evt
=
document
.
createEvent
(
'
Event
'
)
;
evt
.
initEvent
(
evtType
false
false
)
;
fakeNode
.
dispatchEvent
(
evt
)
;
fakeNode
.
removeEventListener
(
evtType
boundFunc
false
)
;
}
;
}
}
module
.
exports
=
ReactErrorUtils
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
function
accumulateInto
(
current
next
)
{
!
(
next
!
=
null
)
?
false
?
invariant
(
false
'
accumulateInto
(
.
.
.
)
:
Accumulated
items
must
not
be
null
or
undefined
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
current
=
=
null
)
{
return
next
;
}
var
currentIsArray
=
Array
.
isArray
(
current
)
;
var
nextIsArray
=
Array
.
isArray
(
next
)
;
if
(
currentIsArray
&
&
nextIsArray
)
{
current
.
push
.
apply
(
current
next
)
;
return
current
;
}
if
(
currentIsArray
)
{
current
.
push
(
next
)
;
return
current
;
}
if
(
nextIsArray
)
{
return
[
current
]
.
concat
(
next
)
;
}
return
[
current
next
]
;
}
module
.
exports
=
accumulateInto
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
forEachAccumulated
=
function
(
arr
cb
scope
)
{
if
(
Array
.
isArray
(
arr
)
)
{
arr
.
forEach
(
cb
scope
)
;
}
else
if
(
arr
)
{
cb
.
call
(
scope
arr
)
;
}
}
;
module
.
exports
=
forEachAccumulated
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventPluginHub
=
__webpack_require__
(
46
)
;
function
runEventQueueInBatch
(
events
)
{
EventPluginHub
.
enqueueEvents
(
events
)
;
EventPluginHub
.
processEventQueue
(
false
)
;
}
var
ReactEventEmitterMixin
=
{
handleTopLevel
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
var
events
=
EventPluginHub
.
extractEvents
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
;
runEventQueueInBatch
(
events
)
;
}
}
;
module
.
exports
=
ReactEventEmitterMixin
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ViewportMetrics
=
{
currentScrollLeft
:
0
currentScrollTop
:
0
refreshScrollValues
:
function
(
scrollPosition
)
{
ViewportMetrics
.
currentScrollLeft
=
scrollPosition
.
x
;
ViewportMetrics
.
currentScrollTop
=
scrollPosition
.
y
;
}
}
;
module
.
exports
=
ViewportMetrics
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
assign
(
target
sources
)
{
if
(
target
=
=
null
)
{
throw
new
TypeError
(
'
Object
.
assign
target
cannot
be
null
or
undefined
'
)
;
}
var
to
=
Object
(
target
)
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
for
(
var
nextIndex
=
1
;
nextIndex
<
arguments
.
length
;
nextIndex
+
+
)
{
var
nextSource
=
arguments
[
nextIndex
]
;
if
(
nextSource
=
=
null
)
{
continue
;
}
var
from
=
Object
(
nextSource
)
;
for
(
var
key
in
from
)
{
if
(
hasOwnProperty
.
call
(
from
key
)
)
{
to
[
key
]
=
from
[
key
]
;
}
}
}
return
to
;
}
module
.
exports
=
assign
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
useHasFeature
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
useHasFeature
=
document
.
implementation
&
&
document
.
implementation
.
hasFeature
&
&
document
.
implementation
.
hasFeature
(
'
'
'
'
)
!
=
=
true
;
}
function
isEventSupported
(
eventNameSuffix
capture
)
{
if
(
!
ExecutionEnvironment
.
canUseDOM
|
|
capture
&
&
!
(
'
addEventListener
'
in
document
)
)
{
return
false
;
}
var
eventName
=
'
on
'
+
eventNameSuffix
;
var
isSupported
=
(
eventName
in
document
)
;
if
(
!
isSupported
)
{
var
element
=
document
.
createElement
(
'
div
'
)
;
element
.
setAttribute
(
eventName
'
return
;
'
)
;
isSupported
=
typeof
element
[
eventName
]
=
=
=
'
function
'
;
}
if
(
!
isSupported
&
&
useHasFeature
&
&
eventNameSuffix
=
=
=
'
wheel
'
)
{
isSupported
=
document
.
implementation
.
hasFeature
(
'
Events
.
wheel
'
'
3
.
0
'
)
;
}
return
isSupported
;
}
module
.
exports
=
isEventSupported
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ReactDOMFeatureFlags
=
{
useCreateElement
:
false
}
;
module
.
exports
=
ReactDOMFeatureFlags
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
canDefineProperty
=
__webpack_require__
(
58
)
;
var
REACT_ELEMENT_TYPE
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
[
'
for
'
]
&
&
Symbol
[
'
for
'
]
(
'
react
.
element
'
)
|
|
0xeac7
;
var
RESERVED_PROPS
=
{
key
:
true
ref
:
true
__self
:
true
__source
:
true
}
;
var
ReactElement
=
function
(
type
key
ref
self
source
owner
props
)
{
var
element
=
{
typeof
:
REACT_ELEMENT_TYPE
type
:
type
key
:
key
ref
:
ref
props
:
props
_owner
:
owner
}
;
if
(
false
)
{
element
.
_store
=
{
}
;
if
(
canDefineProperty
)
{
Object
.
defineProperty
(
element
.
_store
'
validated
'
{
configurable
:
false
enumerable
:
false
writable
:
true
value
:
false
}
)
;
Object
.
defineProperty
(
element
'
_self
'
{
configurable
:
false
enumerable
:
false
writable
:
false
value
:
self
}
)
;
Object
.
defineProperty
(
element
'
_source
'
{
configurable
:
false
enumerable
:
false
writable
:
false
value
:
source
}
)
;
}
else
{
element
.
_store
.
validated
=
false
;
element
.
_self
=
self
;
element
.
_source
=
source
;
}
Object
.
freeze
(
element
.
props
)
;
Object
.
freeze
(
element
)
;
}
return
element
;
}
;
ReactElement
.
createElement
=
function
(
type
config
children
)
{
var
propName
;
var
props
=
{
}
;
var
key
=
null
;
var
ref
=
null
;
var
self
=
null
;
var
source
=
null
;
if
(
config
!
=
null
)
{
ref
=
config
.
ref
=
=
=
undefined
?
null
:
config
.
ref
;
key
=
config
.
key
=
=
=
undefined
?
null
:
'
'
+
config
.
key
;
self
=
config
.
__self
=
=
=
undefined
?
null
:
config
.
__self
;
source
=
config
.
__source
=
=
=
undefined
?
null
:
config
.
__source
;
for
(
propName
in
config
)
{
if
(
config
.
hasOwnProperty
(
propName
)
&
&
!
RESERVED_PROPS
.
hasOwnProperty
(
propName
)
)
{
props
[
propName
]
=
config
[
propName
]
;
}
}
}
var
childrenLength
=
arguments
.
length
-
2
;
if
(
childrenLength
=
=
=
1
)
{
props
.
children
=
children
;
}
else
if
(
childrenLength
>
1
)
{
var
childArray
=
Array
(
childrenLength
)
;
for
(
var
i
=
0
;
i
<
childrenLength
;
i
+
+
)
{
childArray
[
i
]
=
arguments
[
i
+
2
]
;
}
props
.
children
=
childArray
;
}
if
(
type
&
&
type
.
defaultProps
)
{
var
defaultProps
=
type
.
defaultProps
;
for
(
propName
in
defaultProps
)
{
if
(
typeof
props
[
propName
]
=
=
=
'
undefined
'
)
{
props
[
propName
]
=
defaultProps
[
propName
]
;
}
}
}
return
ReactElement
(
type
key
ref
self
source
ReactCurrentOwner
.
current
props
)
;
}
;
ReactElement
.
createFactory
=
function
(
type
)
{
var
factory
=
ReactElement
.
createElement
.
bind
(
null
type
)
;
factory
.
type
=
type
;
return
factory
;
}
;
ReactElement
.
cloneAndReplaceKey
=
function
(
oldElement
newKey
)
{
var
newElement
=
ReactElement
(
oldElement
.
type
newKey
oldElement
.
ref
oldElement
.
_self
oldElement
.
_source
oldElement
.
_owner
oldElement
.
props
)
;
return
newElement
;
}
;
ReactElement
.
cloneAndReplaceProps
=
function
(
oldElement
newProps
)
{
var
newElement
=
ReactElement
(
oldElement
.
type
oldElement
.
key
oldElement
.
ref
oldElement
.
_self
oldElement
.
_source
oldElement
.
_owner
newProps
)
;
if
(
false
)
{
newElement
.
_store
.
validated
=
oldElement
.
_store
.
validated
;
}
return
newElement
;
}
;
ReactElement
.
cloneElement
=
function
(
element
config
children
)
{
var
propName
;
var
props
=
assign
(
{
}
element
.
props
)
;
var
key
=
element
.
key
;
var
ref
=
element
.
ref
;
var
self
=
element
.
_self
;
var
source
=
element
.
_source
;
var
owner
=
element
.
_owner
;
if
(
config
!
=
null
)
{
if
(
config
.
ref
!
=
=
undefined
)
{
ref
=
config
.
ref
;
owner
=
ReactCurrentOwner
.
current
;
}
if
(
config
.
key
!
=
=
undefined
)
{
key
=
'
'
+
config
.
key
;
}
for
(
propName
in
config
)
{
if
(
config
.
hasOwnProperty
(
propName
)
&
&
!
RESERVED_PROPS
.
hasOwnProperty
(
propName
)
)
{
props
[
propName
]
=
config
[
propName
]
;
}
}
}
var
childrenLength
=
arguments
.
length
-
2
;
if
(
childrenLength
=
=
=
1
)
{
props
.
children
=
children
;
}
else
if
(
childrenLength
>
1
)
{
var
childArray
=
Array
(
childrenLength
)
;
for
(
var
i
=
0
;
i
<
childrenLength
;
i
+
+
)
{
childArray
[
i
]
=
arguments
[
i
+
2
]
;
}
props
.
children
=
childArray
;
}
return
ReactElement
(
element
.
type
key
ref
self
source
owner
props
)
;
}
;
ReactElement
.
isValidElement
=
function
(
object
)
{
return
typeof
object
=
=
=
'
object
'
&
&
object
!
=
=
null
&
&
object
.
typeof
=
=
=
REACT_ELEMENT_TYPE
;
}
;
module
.
exports
=
ReactElement
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
canDefineProperty
=
false
;
if
(
false
)
{
try
{
Object
.
defineProperty
(
{
}
'
x
'
{
get
:
function
(
)
{
}
}
)
;
canDefineProperty
=
true
;
}
catch
(
x
)
{
}
}
module
.
exports
=
canDefineProperty
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
nullComponentIDsRegistry
=
{
}
;
function
isNullComponentID
(
id
)
{
return
!
!
nullComponentIDsRegistry
[
id
]
;
}
function
registerNullComponentID
(
id
)
{
nullComponentIDsRegistry
[
id
]
=
true
;
}
function
deregisterNullComponentID
(
id
)
{
delete
nullComponentIDsRegistry
[
id
]
;
}
var
ReactEmptyComponentRegistry
=
{
isNullComponentID
:
isNullComponentID
registerNullComponentID
:
registerNullComponentID
deregisterNullComponentID
:
deregisterNullComponentID
}
;
module
.
exports
=
ReactEmptyComponentRegistry
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactRootIndex
=
__webpack_require__
(
61
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
SEPARATOR
=
'
.
'
;
var
SEPARATOR_LENGTH
=
SEPARATOR
.
length
;
var
MAX_TREE_DEPTH
=
10000
;
function
getReactRootIDString
(
index
)
{
return
SEPARATOR
+
index
.
toString
(
36
)
;
}
function
isBoundary
(
id
index
)
{
return
id
.
charAt
(
index
)
=
=
=
SEPARATOR
|
|
index
=
=
=
id
.
length
;
}
function
isValidID
(
id
)
{
return
id
=
=
=
'
'
|
|
id
.
charAt
(
0
)
=
=
=
SEPARATOR
&
&
id
.
charAt
(
id
.
length
-
1
)
!
=
=
SEPARATOR
;
}
function
isAncestorIDOf
(
ancestorID
descendantID
)
{
return
descendantID
.
indexOf
(
ancestorID
)
=
=
=
0
&
&
isBoundary
(
descendantID
ancestorID
.
length
)
;
}
function
getParentID
(
id
)
{
return
id
?
id
.
substr
(
0
id
.
lastIndexOf
(
SEPARATOR
)
)
:
'
'
;
}
function
getNextDescendantID
(
ancestorID
destinationID
)
{
!
(
isValidID
(
ancestorID
)
&
&
isValidID
(
destinationID
)
)
?
false
?
invariant
(
false
'
getNextDescendantID
(
%
s
%
s
)
:
Received
an
invalid
React
DOM
ID
.
'
ancestorID
destinationID
)
:
invariant
(
false
)
:
undefined
;
!
isAncestorIDOf
(
ancestorID
destinationID
)
?
false
?
invariant
(
false
'
getNextDescendantID
(
.
.
.
)
:
React
has
made
an
invalid
assumption
about
'
+
'
the
DOM
hierarchy
.
Expected
%
s
to
be
an
ancestor
of
%
s
.
'
ancestorID
destinationID
)
:
invariant
(
false
)
:
undefined
;
if
(
ancestorID
=
=
=
destinationID
)
{
return
ancestorID
;
}
var
start
=
ancestorID
.
length
+
SEPARATOR_LENGTH
;
var
i
;
for
(
i
=
start
;
i
<
destinationID
.
length
;
i
+
+
)
{
if
(
isBoundary
(
destinationID
i
)
)
{
break
;
}
}
return
destinationID
.
substr
(
0
i
)
;
}
function
getFirstCommonAncestorID
(
oneID
twoID
)
{
var
minLength
=
Math
.
min
(
oneID
.
length
twoID
.
length
)
;
if
(
minLength
=
=
=
0
)
{
return
'
'
;
}
var
lastCommonMarkerIndex
=
0
;
for
(
var
i
=
0
;
i
<
=
minLength
;
i
+
+
)
{
if
(
isBoundary
(
oneID
i
)
&
&
isBoundary
(
twoID
i
)
)
{
lastCommonMarkerIndex
=
i
;
}
else
if
(
oneID
.
charAt
(
i
)
!
=
=
twoID
.
charAt
(
i
)
)
{
break
;
}
}
var
longestCommonID
=
oneID
.
substr
(
0
lastCommonMarkerIndex
)
;
!
isValidID
(
longestCommonID
)
?
false
?
invariant
(
false
'
getFirstCommonAncestorID
(
%
s
%
s
)
:
Expected
a
valid
React
DOM
ID
:
%
s
'
oneID
twoID
longestCommonID
)
:
invariant
(
false
)
:
undefined
;
return
longestCommonID
;
}
function
traverseParentPath
(
start
stop
cb
arg
skipFirst
skipLast
)
{
start
=
start
|
|
'
'
;
stop
=
stop
|
|
'
'
;
!
(
start
!
=
=
stop
)
?
false
?
invariant
(
false
'
traverseParentPath
(
.
.
.
)
:
Cannot
traverse
from
and
to
the
same
ID
%
s
.
'
start
)
:
invariant
(
false
)
:
undefined
;
var
traverseUp
=
isAncestorIDOf
(
stop
start
)
;
!
(
traverseUp
|
|
isAncestorIDOf
(
start
stop
)
)
?
false
?
invariant
(
false
'
traverseParentPath
(
%
s
%
s
.
.
.
)
:
Cannot
traverse
from
two
IDs
that
do
'
+
'
not
have
a
parent
path
.
'
start
stop
)
:
invariant
(
false
)
:
undefined
;
var
depth
=
0
;
var
traverse
=
traverseUp
?
getParentID
:
getNextDescendantID
;
for
(
var
id
=
start
;
;
id
=
traverse
(
id
stop
)
)
{
var
ret
;
if
(
(
!
skipFirst
|
|
id
!
=
=
start
)
&
&
(
!
skipLast
|
|
id
!
=
=
stop
)
)
{
ret
=
cb
(
id
traverseUp
arg
)
;
}
if
(
ret
=
=
=
false
|
|
id
=
=
=
stop
)
{
break
;
}
!
(
depth
+
+
<
MAX_TREE_DEPTH
)
?
false
?
invariant
(
false
'
traverseParentPath
(
%
s
%
s
.
.
.
)
:
Detected
an
infinite
loop
while
'
+
'
traversing
the
React
DOM
ID
tree
.
This
may
be
due
to
malformed
IDs
:
%
s
'
start
stop
id
)
:
invariant
(
false
)
:
undefined
;
}
}
var
ReactInstanceHandles
=
{
createReactRootID
:
function
(
)
{
return
getReactRootIDString
(
ReactRootIndex
.
createReactRootIndex
(
)
)
;
}
createReactID
:
function
(
rootID
name
)
{
return
rootID
+
name
;
}
getReactRootIDFromNodeID
:
function
(
id
)
{
if
(
id
&
&
id
.
charAt
(
0
)
=
=
=
SEPARATOR
&
&
id
.
length
>
1
)
{
var
index
=
id
.
indexOf
(
SEPARATOR
1
)
;
return
index
>
-
1
?
id
.
substr
(
0
index
)
:
id
;
}
return
null
;
}
traverseEnterLeave
:
function
(
leaveID
enterID
cb
upArg
downArg
)
{
var
ancestorID
=
getFirstCommonAncestorID
(
leaveID
enterID
)
;
if
(
ancestorID
!
=
=
leaveID
)
{
traverseParentPath
(
leaveID
ancestorID
cb
upArg
false
true
)
;
}
if
(
ancestorID
!
=
=
enterID
)
{
traverseParentPath
(
ancestorID
enterID
cb
downArg
true
false
)
;
}
}
traverseTwoPhase
:
function
(
targetID
cb
arg
)
{
if
(
targetID
)
{
traverseParentPath
(
'
'
targetID
cb
arg
true
false
)
;
traverseParentPath
(
targetID
'
'
cb
arg
false
true
)
;
}
}
traverseTwoPhaseSkipTarget
:
function
(
targetID
cb
arg
)
{
if
(
targetID
)
{
traverseParentPath
(
'
'
targetID
cb
arg
true
true
)
;
traverseParentPath
(
targetID
'
'
cb
arg
true
true
)
;
}
}
traverseAncestors
:
function
(
targetID
cb
arg
)
{
traverseParentPath
(
'
'
targetID
cb
arg
true
false
)
;
}
getFirstCommonAncestorID
:
getFirstCommonAncestorID
_getNextDescendantID
:
getNextDescendantID
isAncestorIDOf
:
isAncestorIDOf
SEPARATOR
:
SEPARATOR
}
;
module
.
exports
=
ReactInstanceHandles
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ReactRootIndexInjection
=
{
injectCreateReactRootIndex
:
function
(
_createReactRootIndex
)
{
ReactRootIndex
.
createReactRootIndex
=
_createReactRootIndex
;
}
}
;
var
ReactRootIndex
=
{
createReactRootIndex
:
null
injection
:
ReactRootIndexInjection
}
;
module
.
exports
=
ReactRootIndex
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ReactInstanceMap
=
{
remove
:
function
(
key
)
{
key
.
_reactInternalInstance
=
undefined
;
}
get
:
function
(
key
)
{
return
key
.
_reactInternalInstance
;
}
has
:
function
(
key
)
{
return
key
.
_reactInternalInstance
!
=
=
undefined
;
}
set
:
function
(
key
value
)
{
key
.
_reactInternalInstance
=
value
;
}
}
;
module
.
exports
=
ReactInstanceMap
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
adler32
=
__webpack_require__
(
64
)
;
var
TAG_END
=
/
\
/
?
>
/
;
var
ReactMarkupChecksum
=
{
CHECKSUM_ATTR_NAME
:
'
data
-
react
-
checksum
'
addChecksumToMarkup
:
function
(
markup
)
{
var
checksum
=
adler32
(
markup
)
;
return
markup
.
replace
(
TAG_END
'
'
+
ReactMarkupChecksum
.
CHECKSUM_ATTR_NAME
+
'
=
"
'
+
checksum
+
'
"
&
'
)
;
}
canReuseMarkup
:
function
(
markup
element
)
{
var
existingChecksum
=
element
.
getAttribute
(
ReactMarkupChecksum
.
CHECKSUM_ATTR_NAME
)
;
existingChecksum
=
existingChecksum
&
&
parseInt
(
existingChecksum
10
)
;
var
markupChecksum
=
adler32
(
markup
)
;
return
markupChecksum
=
=
=
existingChecksum
;
}
}
;
module
.
exports
=
ReactMarkupChecksum
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
MOD
=
65521
;
function
adler32
(
data
)
{
var
a
=
1
;
var
b
=
0
;
var
i
=
0
;
var
l
=
data
.
length
;
var
m
=
l
&
~
0x3
;
while
(
i
<
m
)
{
for
(
;
i
<
Math
.
min
(
i
+
4096
m
)
;
i
+
=
4
)
{
b
+
=
(
a
+
=
data
.
charCodeAt
(
i
)
)
+
(
a
+
=
data
.
charCodeAt
(
i
+
1
)
)
+
(
a
+
=
data
.
charCodeAt
(
i
+
2
)
)
+
(
a
+
=
data
.
charCodeAt
(
i
+
3
)
)
;
}
a
%
=
MOD
;
b
%
=
MOD
;
}
for
(
;
i
<
l
;
i
+
+
)
{
b
+
=
a
+
=
data
.
charCodeAt
(
i
)
;
}
a
%
=
MOD
;
b
%
=
MOD
;
return
a
|
b
<
<
16
;
}
module
.
exports
=
adler32
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactRef
=
__webpack_require__
(
66
)
;
function
attachRefs
(
)
{
ReactRef
.
attachRefs
(
this
this
.
_currentElement
)
;
}
var
ReactReconciler
=
{
mountComponent
:
function
(
internalInstance
rootID
transaction
context
)
{
var
markup
=
internalInstance
.
mountComponent
(
rootID
transaction
context
)
;
if
(
internalInstance
.
_currentElement
&
&
internalInstance
.
_currentElement
.
ref
!
=
null
)
{
transaction
.
getReactMountReady
(
)
.
enqueue
(
attachRefs
internalInstance
)
;
}
return
markup
;
}
unmountComponent
:
function
(
internalInstance
)
{
ReactRef
.
detachRefs
(
internalInstance
internalInstance
.
_currentElement
)
;
internalInstance
.
unmountComponent
(
)
;
}
receiveComponent
:
function
(
internalInstance
nextElement
transaction
context
)
{
var
prevElement
=
internalInstance
.
_currentElement
;
if
(
nextElement
=
=
=
prevElement
&
&
context
=
=
=
internalInstance
.
_context
)
{
return
;
}
var
refsChanged
=
ReactRef
.
shouldUpdateRefs
(
prevElement
nextElement
)
;
if
(
refsChanged
)
{
ReactRef
.
detachRefs
(
internalInstance
prevElement
)
;
}
internalInstance
.
receiveComponent
(
nextElement
transaction
context
)
;
if
(
refsChanged
&
&
internalInstance
.
_currentElement
&
&
internalInstance
.
_currentElement
.
ref
!
=
null
)
{
transaction
.
getReactMountReady
(
)
.
enqueue
(
attachRefs
internalInstance
)
;
}
}
performUpdateIfNecessary
:
function
(
internalInstance
transaction
)
{
internalInstance
.
performUpdateIfNecessary
(
transaction
)
;
}
}
;
module
.
exports
=
ReactReconciler
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactOwner
=
__webpack_require__
(
67
)
;
var
ReactRef
=
{
}
;
function
attachRef
(
ref
component
owner
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
ref
(
component
.
getPublicInstance
(
)
)
;
}
else
{
ReactOwner
.
addComponentAsRefTo
(
component
ref
owner
)
;
}
}
function
detachRef
(
ref
component
owner
)
{
if
(
typeof
ref
=
=
=
'
function
'
)
{
ref
(
null
)
;
}
else
{
ReactOwner
.
removeComponentAsRefFrom
(
component
ref
owner
)
;
}
}
ReactRef
.
attachRefs
=
function
(
instance
element
)
{
if
(
element
=
=
=
null
|
|
element
=
=
=
false
)
{
return
;
}
var
ref
=
element
.
ref
;
if
(
ref
!
=
null
)
{
attachRef
(
ref
instance
element
.
_owner
)
;
}
}
;
ReactRef
.
shouldUpdateRefs
=
function
(
prevElement
nextElement
)
{
var
prevEmpty
=
prevElement
=
=
=
null
|
|
prevElement
=
=
=
false
;
var
nextEmpty
=
nextElement
=
=
=
null
|
|
nextElement
=
=
=
false
;
return
(
prevEmpty
|
|
nextEmpty
|
|
nextElement
.
_owner
!
=
=
prevElement
.
_owner
|
|
nextElement
.
ref
!
=
=
prevElement
.
ref
)
;
}
;
ReactRef
.
detachRefs
=
function
(
instance
element
)
{
if
(
element
=
=
=
null
|
|
element
=
=
=
false
)
{
return
;
}
var
ref
=
element
.
ref
;
if
(
ref
!
=
null
)
{
detachRef
(
ref
instance
element
.
_owner
)
;
}
}
;
module
.
exports
=
ReactRef
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
var
ReactOwner
=
{
isValidOwner
:
function
(
object
)
{
return
!
!
(
object
&
&
typeof
object
.
attachRef
=
=
=
'
function
'
&
&
typeof
object
.
detachRef
=
=
=
'
function
'
)
;
}
addComponentAsRefTo
:
function
(
component
ref
owner
)
{
!
ReactOwner
.
isValidOwner
(
owner
)
?
false
?
invariant
(
false
'
addComponentAsRefTo
(
.
.
.
)
:
Only
a
ReactOwner
can
have
refs
.
You
might
'
+
'
be
adding
a
ref
to
a
component
that
was
not
created
inside
a
component
\
'
s
'
+
'
render
method
or
you
have
multiple
copies
of
React
loaded
'
+
'
(
details
:
https
:
/
/
fb
.
me
/
react
-
refs
-
must
-
have
-
owner
)
.
'
)
:
invariant
(
false
)
:
undefined
;
owner
.
attachRef
(
ref
component
)
;
}
removeComponentAsRefFrom
:
function
(
component
ref
owner
)
{
!
ReactOwner
.
isValidOwner
(
owner
)
?
false
?
invariant
(
false
'
removeComponentAsRefFrom
(
.
.
.
)
:
Only
a
ReactOwner
can
have
refs
.
You
might
'
+
'
be
removing
a
ref
to
a
component
that
was
not
created
inside
a
component
\
'
s
'
+
'
render
method
or
you
have
multiple
copies
of
React
loaded
'
+
'
(
details
:
https
:
/
/
fb
.
me
/
react
-
refs
-
must
-
have
-
owner
)
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
owner
.
getPublicInstance
(
)
.
refs
[
ref
]
=
=
=
component
.
getPublicInstance
(
)
)
{
owner
.
detachRef
(
ref
)
;
}
}
}
;
module
.
exports
=
ReactOwner
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactInstanceMap
=
__webpack_require__
(
62
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
enqueueUpdate
(
internalInstance
)
{
ReactUpdates
.
enqueueUpdate
(
internalInstance
)
;
}
function
getInternalInstanceReadyForUpdate
(
publicInstance
callerName
)
{
var
internalInstance
=
ReactInstanceMap
.
get
(
publicInstance
)
;
if
(
!
internalInstance
)
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
callerName
'
%
s
(
.
.
.
)
:
Can
only
update
a
mounted
or
mounting
component
.
'
+
'
This
usually
means
you
called
%
s
(
)
on
an
unmounted
component
.
'
+
'
This
is
a
no
-
op
.
Please
check
the
code
for
the
%
s
component
.
'
callerName
callerName
publicInstance
.
constructor
.
displayName
)
:
undefined
;
}
return
null
;
}
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
ReactCurrentOwner
.
current
=
=
null
'
%
s
(
.
.
.
)
:
Cannot
update
during
an
existing
state
transition
'
+
'
(
such
as
within
render
)
.
Render
methods
should
be
a
pure
function
'
+
'
of
props
and
state
.
'
callerName
)
:
undefined
;
}
return
internalInstance
;
}
var
ReactUpdateQueue
=
{
isMounted
:
function
(
publicInstance
)
{
if
(
false
)
{
var
owner
=
ReactCurrentOwner
.
current
;
if
(
owner
!
=
=
null
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
owner
.
_warnedAboutRefsInRender
'
%
s
is
accessing
isMounted
inside
its
render
(
)
function
.
'
+
'
render
(
)
should
be
a
pure
function
of
props
and
state
.
It
should
'
+
'
never
access
something
that
requires
stale
data
from
the
previous
'
+
'
render
such
as
refs
.
Move
this
logic
to
componentDidMount
and
'
+
'
componentDidUpdate
instead
.
'
owner
.
getName
(
)
|
|
'
A
component
'
)
:
undefined
;
owner
.
_warnedAboutRefsInRender
=
true
;
}
}
var
internalInstance
=
ReactInstanceMap
.
get
(
publicInstance
)
;
if
(
internalInstance
)
{
return
!
!
internalInstance
.
_renderedComponent
;
}
else
{
return
false
;
}
}
enqueueCallback
:
function
(
publicInstance
callback
)
{
!
(
typeof
callback
=
=
=
'
function
'
)
?
false
?
invariant
(
false
'
enqueueCallback
(
.
.
.
)
:
You
called
setProps
replaceProps
'
+
'
setState
replaceState
or
forceUpdate
with
a
callback
that
'
+
'
isn
\
'
t
callable
.
'
)
:
invariant
(
false
)
:
undefined
;
var
internalInstance
=
getInternalInstanceReadyForUpdate
(
publicInstance
)
;
if
(
!
internalInstance
)
{
return
null
;
}
if
(
internalInstance
.
_pendingCallbacks
)
{
internalInstance
.
_pendingCallbacks
.
push
(
callback
)
;
}
else
{
internalInstance
.
_pendingCallbacks
=
[
callback
]
;
}
enqueueUpdate
(
internalInstance
)
;
}
enqueueCallbackInternal
:
function
(
internalInstance
callback
)
{
!
(
typeof
callback
=
=
=
'
function
'
)
?
false
?
invariant
(
false
'
enqueueCallback
(
.
.
.
)
:
You
called
setProps
replaceProps
'
+
'
setState
replaceState
or
forceUpdate
with
a
callback
that
'
+
'
isn
\
'
t
callable
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
internalInstance
.
_pendingCallbacks
)
{
internalInstance
.
_pendingCallbacks
.
push
(
callback
)
;
}
else
{
internalInstance
.
_pendingCallbacks
=
[
callback
]
;
}
enqueueUpdate
(
internalInstance
)
;
}
enqueueForceUpdate
:
function
(
publicInstance
)
{
var
internalInstance
=
getInternalInstanceReadyForUpdate
(
publicInstance
'
forceUpdate
'
)
;
if
(
!
internalInstance
)
{
return
;
}
internalInstance
.
_pendingForceUpdate
=
true
;
enqueueUpdate
(
internalInstance
)
;
}
enqueueReplaceState
:
function
(
publicInstance
completeState
)
{
var
internalInstance
=
getInternalInstanceReadyForUpdate
(
publicInstance
'
replaceState
'
)
;
if
(
!
internalInstance
)
{
return
;
}
internalInstance
.
_pendingStateQueue
=
[
completeState
]
;
internalInstance
.
_pendingReplaceState
=
true
;
enqueueUpdate
(
internalInstance
)
;
}
enqueueSetState
:
function
(
publicInstance
partialState
)
{
var
internalInstance
=
getInternalInstanceReadyForUpdate
(
publicInstance
'
setState
'
)
;
if
(
!
internalInstance
)
{
return
;
}
var
queue
=
internalInstance
.
_pendingStateQueue
|
|
(
internalInstance
.
_pendingStateQueue
=
[
]
)
;
queue
.
push
(
partialState
)
;
enqueueUpdate
(
internalInstance
)
;
}
enqueueSetProps
:
function
(
publicInstance
partialProps
)
{
var
internalInstance
=
getInternalInstanceReadyForUpdate
(
publicInstance
'
setProps
'
)
;
if
(
!
internalInstance
)
{
return
;
}
ReactUpdateQueue
.
enqueueSetPropsInternal
(
internalInstance
partialProps
)
;
}
enqueueSetPropsInternal
:
function
(
internalInstance
partialProps
)
{
var
topLevelWrapper
=
internalInstance
.
_topLevelWrapper
;
!
topLevelWrapper
?
false
?
invariant
(
false
'
setProps
(
.
.
.
)
:
You
called
setProps
on
a
'
+
'
component
with
a
parent
.
This
is
an
anti
-
pattern
since
props
will
'
+
'
get
reactively
updated
when
rendered
.
Instead
change
the
owner
\
'
s
'
+
'
render
method
to
pass
the
correct
value
as
props
to
the
component
'
+
'
where
it
is
created
.
'
)
:
invariant
(
false
)
:
undefined
;
var
wrapElement
=
topLevelWrapper
.
_pendingElement
|
|
topLevelWrapper
.
_currentElement
;
var
element
=
wrapElement
.
props
;
var
props
=
assign
(
{
}
element
.
props
partialProps
)
;
topLevelWrapper
.
_pendingElement
=
ReactElement
.
cloneAndReplaceProps
(
wrapElement
ReactElement
.
cloneAndReplaceProps
(
element
props
)
)
;
enqueueUpdate
(
topLevelWrapper
)
;
}
enqueueReplaceProps
:
function
(
publicInstance
props
)
{
var
internalInstance
=
getInternalInstanceReadyForUpdate
(
publicInstance
'
replaceProps
'
)
;
if
(
!
internalInstance
)
{
return
;
}
ReactUpdateQueue
.
enqueueReplacePropsInternal
(
internalInstance
props
)
;
}
enqueueReplacePropsInternal
:
function
(
internalInstance
props
)
{
var
topLevelWrapper
=
internalInstance
.
_topLevelWrapper
;
!
topLevelWrapper
?
false
?
invariant
(
false
'
replaceProps
(
.
.
.
)
:
You
called
replaceProps
on
a
'
+
'
component
with
a
parent
.
This
is
an
anti
-
pattern
since
props
will
'
+
'
get
reactively
updated
when
rendered
.
Instead
change
the
owner
\
'
s
'
+
'
render
method
to
pass
the
correct
value
as
props
to
the
component
'
+
'
where
it
is
created
.
'
)
:
invariant
(
false
)
:
undefined
;
var
wrapElement
=
topLevelWrapper
.
_pendingElement
|
|
topLevelWrapper
.
_currentElement
;
var
element
=
wrapElement
.
props
;
topLevelWrapper
.
_pendingElement
=
ReactElement
.
cloneAndReplaceProps
(
wrapElement
ReactElement
.
cloneAndReplaceProps
(
element
props
)
)
;
enqueueUpdate
(
topLevelWrapper
)
;
}
enqueueElementInternal
:
function
(
internalInstance
newElement
)
{
internalInstance
.
_pendingElement
=
newElement
;
enqueueUpdate
(
internalInstance
)
;
}
}
;
module
.
exports
=
ReactUpdateQueue
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
CallbackQueue
=
__webpack_require__
(
70
)
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
ReactReconciler
=
__webpack_require__
(
65
)
;
var
Transaction
=
__webpack_require__
(
72
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
dirtyComponents
=
[
]
;
var
asapCallbackQueue
=
CallbackQueue
.
getPooled
(
)
;
var
asapEnqueued
=
false
;
var
batchingStrategy
=
null
;
function
ensureInjected
(
)
{
!
(
ReactUpdates
.
ReactReconcileTransaction
&
&
batchingStrategy
)
?
false
?
invariant
(
false
'
ReactUpdates
:
must
inject
a
reconcile
transaction
class
and
batching
'
+
'
strategy
'
)
:
invariant
(
false
)
:
undefined
;
}
var
NESTED_UPDATES
=
{
initialize
:
function
(
)
{
this
.
dirtyComponentsLength
=
dirtyComponents
.
length
;
}
close
:
function
(
)
{
if
(
this
.
dirtyComponentsLength
!
=
=
dirtyComponents
.
length
)
{
dirtyComponents
.
splice
(
0
this
.
dirtyComponentsLength
)
;
flushBatchedUpdates
(
)
;
}
else
{
dirtyComponents
.
length
=
0
;
}
}
}
;
var
UPDATE_QUEUEING
=
{
initialize
:
function
(
)
{
this
.
callbackQueue
.
reset
(
)
;
}
close
:
function
(
)
{
this
.
callbackQueue
.
notifyAll
(
)
;
}
}
;
var
TRANSACTION_WRAPPERS
=
[
NESTED_UPDATES
UPDATE_QUEUEING
]
;
function
ReactUpdatesFlushTransaction
(
)
{
this
.
reinitializeTransaction
(
)
;
this
.
dirtyComponentsLength
=
null
;
this
.
callbackQueue
=
CallbackQueue
.
getPooled
(
)
;
this
.
reconcileTransaction
=
ReactUpdates
.
ReactReconcileTransaction
.
getPooled
(
false
)
;
}
assign
(
ReactUpdatesFlushTransaction
.
prototype
Transaction
.
Mixin
{
getTransactionWrappers
:
function
(
)
{
return
TRANSACTION_WRAPPERS
;
}
destructor
:
function
(
)
{
this
.
dirtyComponentsLength
=
null
;
CallbackQueue
.
release
(
this
.
callbackQueue
)
;
this
.
callbackQueue
=
null
;
ReactUpdates
.
ReactReconcileTransaction
.
release
(
this
.
reconcileTransaction
)
;
this
.
reconcileTransaction
=
null
;
}
perform
:
function
(
method
scope
a
)
{
return
Transaction
.
Mixin
.
perform
.
call
(
this
this
.
reconcileTransaction
.
perform
this
.
reconcileTransaction
method
scope
a
)
;
}
}
)
;
PooledClass
.
addPoolingTo
(
ReactUpdatesFlushTransaction
)
;
function
batchedUpdates
(
callback
a
b
c
d
e
)
{
ensureInjected
(
)
;
batchingStrategy
.
batchedUpdates
(
callback
a
b
c
d
e
)
;
}
function
mountOrderComparator
(
c1
c2
)
{
return
c1
.
_mountOrder
-
c2
.
_mountOrder
;
}
function
runBatchedUpdates
(
transaction
)
{
var
len
=
transaction
.
dirtyComponentsLength
;
!
(
len
=
=
=
dirtyComponents
.
length
)
?
false
?
invariant
(
false
'
Expected
flush
transaction
\
'
s
stored
dirty
-
components
length
(
%
s
)
to
'
+
'
match
dirty
-
components
array
length
(
%
s
)
.
'
len
dirtyComponents
.
length
)
:
invariant
(
false
)
:
undefined
;
dirtyComponents
.
sort
(
mountOrderComparator
)
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
component
=
dirtyComponents
[
i
]
;
var
callbacks
=
component
.
_pendingCallbacks
;
component
.
_pendingCallbacks
=
null
;
ReactReconciler
.
performUpdateIfNecessary
(
component
transaction
.
reconcileTransaction
)
;
if
(
callbacks
)
{
for
(
var
j
=
0
;
j
<
callbacks
.
length
;
j
+
+
)
{
transaction
.
callbackQueue
.
enqueue
(
callbacks
[
j
]
component
.
getPublicInstance
(
)
)
;
}
}
}
}
var
flushBatchedUpdates
=
function
(
)
{
while
(
dirtyComponents
.
length
|
|
asapEnqueued
)
{
if
(
dirtyComponents
.
length
)
{
var
transaction
=
ReactUpdatesFlushTransaction
.
getPooled
(
)
;
transaction
.
perform
(
runBatchedUpdates
null
transaction
)
;
ReactUpdatesFlushTransaction
.
release
(
transaction
)
;
}
if
(
asapEnqueued
)
{
asapEnqueued
=
false
;
var
queue
=
asapCallbackQueue
;
asapCallbackQueue
=
CallbackQueue
.
getPooled
(
)
;
queue
.
notifyAll
(
)
;
CallbackQueue
.
release
(
queue
)
;
}
}
}
;
flushBatchedUpdates
=
ReactPerf
.
measure
(
'
ReactUpdates
'
'
flushBatchedUpdates
'
flushBatchedUpdates
)
;
function
enqueueUpdate
(
component
)
{
ensureInjected
(
)
;
if
(
!
batchingStrategy
.
isBatchingUpdates
)
{
batchingStrategy
.
batchedUpdates
(
enqueueUpdate
component
)
;
return
;
}
dirtyComponents
.
push
(
component
)
;
}
function
asap
(
callback
context
)
{
!
batchingStrategy
.
isBatchingUpdates
?
false
?
invariant
(
false
'
ReactUpdates
.
asap
:
Can
\
'
t
enqueue
an
asap
callback
in
a
context
where
'
+
'
updates
are
not
being
batched
.
'
)
:
invariant
(
false
)
:
undefined
;
asapCallbackQueue
.
enqueue
(
callback
context
)
;
asapEnqueued
=
true
;
}
var
ReactUpdatesInjection
=
{
injectReconcileTransaction
:
function
(
ReconcileTransaction
)
{
!
ReconcileTransaction
?
false
?
invariant
(
false
'
ReactUpdates
:
must
provide
a
reconcile
transaction
class
'
)
:
invariant
(
false
)
:
undefined
;
ReactUpdates
.
ReactReconcileTransaction
=
ReconcileTransaction
;
}
injectBatchingStrategy
:
function
(
_batchingStrategy
)
{
!
_batchingStrategy
?
false
?
invariant
(
false
'
ReactUpdates
:
must
provide
a
batching
strategy
'
)
:
invariant
(
false
)
:
undefined
;
!
(
typeof
_batchingStrategy
.
batchedUpdates
=
=
=
'
function
'
)
?
false
?
invariant
(
false
'
ReactUpdates
:
must
provide
a
batchedUpdates
(
)
function
'
)
:
invariant
(
false
)
:
undefined
;
!
(
typeof
_batchingStrategy
.
isBatchingUpdates
=
=
=
'
boolean
'
)
?
false
?
invariant
(
false
'
ReactUpdates
:
must
provide
an
isBatchingUpdates
boolean
attribute
'
)
:
invariant
(
false
)
:
undefined
;
batchingStrategy
=
_batchingStrategy
;
}
}
;
var
ReactUpdates
=
{
ReactReconcileTransaction
:
null
batchedUpdates
:
batchedUpdates
enqueueUpdate
:
enqueueUpdate
flushBatchedUpdates
:
flushBatchedUpdates
injection
:
ReactUpdatesInjection
asap
:
asap
}
;
module
.
exports
=
ReactUpdates
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
invariant
=
__webpack_require__
(
28
)
;
function
CallbackQueue
(
)
{
this
.
_callbacks
=
null
;
this
.
_contexts
=
null
;
}
assign
(
CallbackQueue
.
prototype
{
enqueue
:
function
(
callback
context
)
{
this
.
_callbacks
=
this
.
_callbacks
|
|
[
]
;
this
.
_contexts
=
this
.
_contexts
|
|
[
]
;
this
.
_callbacks
.
push
(
callback
)
;
this
.
_contexts
.
push
(
context
)
;
}
notifyAll
:
function
(
)
{
var
callbacks
=
this
.
_callbacks
;
var
contexts
=
this
.
_contexts
;
if
(
callbacks
)
{
!
(
callbacks
.
length
=
=
=
contexts
.
length
)
?
false
?
invariant
(
false
'
Mismatched
list
of
contexts
in
callback
queue
'
)
:
invariant
(
false
)
:
undefined
;
this
.
_callbacks
=
null
;
this
.
_contexts
=
null
;
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callbacks
[
i
]
.
call
(
contexts
[
i
]
)
;
}
callbacks
.
length
=
0
;
contexts
.
length
=
0
;
}
}
reset
:
function
(
)
{
this
.
_callbacks
=
null
;
this
.
_contexts
=
null
;
}
destructor
:
function
(
)
{
this
.
reset
(
)
;
}
}
)
;
PooledClass
.
addPoolingTo
(
CallbackQueue
)
;
module
.
exports
=
CallbackQueue
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
var
oneArgumentPooler
=
function
(
copyFieldsFrom
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
copyFieldsFrom
)
;
return
instance
;
}
else
{
return
new
Klass
(
copyFieldsFrom
)
;
}
}
;
var
twoArgumentPooler
=
function
(
a1
a2
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
a1
a2
)
;
return
instance
;
}
else
{
return
new
Klass
(
a1
a2
)
;
}
}
;
var
threeArgumentPooler
=
function
(
a1
a2
a3
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
a1
a2
a3
)
;
return
instance
;
}
else
{
return
new
Klass
(
a1
a2
a3
)
;
}
}
;
var
fourArgumentPooler
=
function
(
a1
a2
a3
a4
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
a1
a2
a3
a4
)
;
return
instance
;
}
else
{
return
new
Klass
(
a1
a2
a3
a4
)
;
}
}
;
var
fiveArgumentPooler
=
function
(
a1
a2
a3
a4
a5
)
{
var
Klass
=
this
;
if
(
Klass
.
instancePool
.
length
)
{
var
instance
=
Klass
.
instancePool
.
pop
(
)
;
Klass
.
call
(
instance
a1
a2
a3
a4
a5
)
;
return
instance
;
}
else
{
return
new
Klass
(
a1
a2
a3
a4
a5
)
;
}
}
;
var
standardReleaser
=
function
(
instance
)
{
var
Klass
=
this
;
!
(
instance
instanceof
Klass
)
?
false
?
invariant
(
false
'
Trying
to
release
an
instance
into
a
pool
of
a
different
type
.
'
)
:
invariant
(
false
)
:
undefined
;
instance
.
destructor
(
)
;
if
(
Klass
.
instancePool
.
length
<
Klass
.
poolSize
)
{
Klass
.
instancePool
.
push
(
instance
)
;
}
}
;
var
DEFAULT_POOL_SIZE
=
10
;
var
DEFAULT_POOLER
=
oneArgumentPooler
;
var
addPoolingTo
=
function
(
CopyConstructor
pooler
)
{
var
NewKlass
=
CopyConstructor
;
NewKlass
.
instancePool
=
[
]
;
NewKlass
.
getPooled
=
pooler
|
|
DEFAULT_POOLER
;
if
(
!
NewKlass
.
poolSize
)
{
NewKlass
.
poolSize
=
DEFAULT_POOL_SIZE
;
}
NewKlass
.
release
=
standardReleaser
;
return
NewKlass
;
}
;
var
PooledClass
=
{
addPoolingTo
:
addPoolingTo
oneArgumentPooler
:
oneArgumentPooler
twoArgumentPooler
:
twoArgumentPooler
threeArgumentPooler
:
threeArgumentPooler
fourArgumentPooler
:
fourArgumentPooler
fiveArgumentPooler
:
fiveArgumentPooler
}
;
module
.
exports
=
PooledClass
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
var
Mixin
=
{
reinitializeTransaction
:
function
(
)
{
this
.
transactionWrappers
=
this
.
getTransactionWrappers
(
)
;
if
(
this
.
wrapperInitData
)
{
this
.
wrapperInitData
.
length
=
0
;
}
else
{
this
.
wrapperInitData
=
[
]
;
}
this
.
_isInTransaction
=
false
;
}
_isInTransaction
:
false
getTransactionWrappers
:
null
isInTransaction
:
function
(
)
{
return
!
!
this
.
_isInTransaction
;
}
perform
:
function
(
method
scope
a
b
c
d
e
f
)
{
!
!
this
.
isInTransaction
(
)
?
false
?
invariant
(
false
'
Transaction
.
perform
(
.
.
.
)
:
Cannot
initialize
a
transaction
when
there
'
+
'
is
already
an
outstanding
transaction
.
'
)
:
invariant
(
false
)
:
undefined
;
var
errorThrown
;
var
ret
;
try
{
this
.
_isInTransaction
=
true
;
errorThrown
=
true
;
this
.
initializeAll
(
0
)
;
ret
=
method
.
call
(
scope
a
b
c
d
e
f
)
;
errorThrown
=
false
;
}
finally
{
try
{
if
(
errorThrown
)
{
try
{
this
.
closeAll
(
0
)
;
}
catch
(
err
)
{
}
}
else
{
this
.
closeAll
(
0
)
;
}
}
finally
{
this
.
_isInTransaction
=
false
;
}
}
return
ret
;
}
initializeAll
:
function
(
startIndex
)
{
var
transactionWrappers
=
this
.
transactionWrappers
;
for
(
var
i
=
startIndex
;
i
<
transactionWrappers
.
length
;
i
+
+
)
{
var
wrapper
=
transactionWrappers
[
i
]
;
try
{
this
.
wrapperInitData
[
i
]
=
Transaction
.
OBSERVED_ERROR
;
this
.
wrapperInitData
[
i
]
=
wrapper
.
initialize
?
wrapper
.
initialize
.
call
(
this
)
:
null
;
}
finally
{
if
(
this
.
wrapperInitData
[
i
]
=
=
=
Transaction
.
OBSERVED_ERROR
)
{
try
{
this
.
initializeAll
(
i
+
1
)
;
}
catch
(
err
)
{
}
}
}
}
}
closeAll
:
function
(
startIndex
)
{
!
this
.
isInTransaction
(
)
?
false
?
invariant
(
false
'
Transaction
.
closeAll
(
)
:
Cannot
close
transaction
when
none
are
open
.
'
)
:
invariant
(
false
)
:
undefined
;
var
transactionWrappers
=
this
.
transactionWrappers
;
for
(
var
i
=
startIndex
;
i
<
transactionWrappers
.
length
;
i
+
+
)
{
var
wrapper
=
transactionWrappers
[
i
]
;
var
initData
=
this
.
wrapperInitData
[
i
]
;
var
errorThrown
;
try
{
errorThrown
=
true
;
if
(
initData
!
=
=
Transaction
.
OBSERVED_ERROR
&
&
wrapper
.
close
)
{
wrapper
.
close
.
call
(
this
initData
)
;
}
errorThrown
=
false
;
}
finally
{
if
(
errorThrown
)
{
try
{
this
.
closeAll
(
i
+
1
)
;
}
catch
(
e
)
{
}
}
}
}
this
.
wrapperInitData
.
length
=
0
;
}
}
;
var
Transaction
=
{
Mixin
:
Mixin
OBSERVED_ERROR
:
{
}
}
;
module
.
exports
=
Transaction
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
emptyObject
=
{
}
;
if
(
false
)
{
Object
.
freeze
(
emptyObject
)
;
}
module
.
exports
=
emptyObject
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
isTextNode
=
__webpack_require__
(
75
)
;
function
containsNode
(
_x
_x2
)
{
var
_again
=
true
;
_function
:
while
(
_again
)
{
var
outerNode
=
_x
innerNode
=
_x2
;
_again
=
false
;
if
(
!
outerNode
|
|
!
innerNode
)
{
return
false
;
}
else
if
(
outerNode
=
=
=
innerNode
)
{
return
true
;
}
else
if
(
isTextNode
(
outerNode
)
)
{
return
false
;
}
else
if
(
isTextNode
(
innerNode
)
)
{
_x
=
outerNode
;
_x2
=
innerNode
.
parentNode
;
_again
=
true
;
continue
_function
;
}
else
if
(
outerNode
.
contains
)
{
return
outerNode
.
contains
(
innerNode
)
;
}
else
if
(
outerNode
.
compareDocumentPosition
)
{
return
!
!
(
outerNode
.
compareDocumentPosition
(
innerNode
)
&
16
)
;
}
else
{
return
false
;
}
}
}
module
.
exports
=
containsNode
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
isNode
=
__webpack_require__
(
76
)
;
function
isTextNode
(
object
)
{
return
isNode
(
object
)
&
&
object
.
nodeType
=
=
3
;
}
module
.
exports
=
isTextNode
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
isNode
(
object
)
{
return
!
!
(
object
&
&
(
typeof
Node
=
=
=
'
function
'
?
object
instanceof
Node
:
typeof
object
=
=
=
'
object
'
&
&
typeof
object
.
nodeType
=
=
=
'
number
'
&
&
typeof
object
.
nodeName
=
=
=
'
string
'
)
)
;
}
module
.
exports
=
isNode
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactCompositeComponent
=
__webpack_require__
(
78
)
;
var
ReactEmptyComponent
=
__webpack_require__
(
83
)
;
var
ReactNativeComponent
=
__webpack_require__
(
84
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
ReactCompositeComponentWrapper
=
function
(
)
{
}
;
assign
(
ReactCompositeComponentWrapper
.
prototype
ReactCompositeComponent
.
Mixin
{
_instantiateReactComponent
:
instantiateReactComponent
}
)
;
function
getDeclarationErrorAddendum
(
owner
)
{
if
(
owner
)
{
var
name
=
owner
.
getName
(
)
;
if
(
name
)
{
return
'
Check
the
render
method
of
'
+
name
+
'
.
'
;
}
}
return
'
'
;
}
function
isInternalComponentType
(
type
)
{
return
typeof
type
=
=
=
'
function
'
&
&
typeof
type
.
prototype
!
=
=
'
undefined
'
&
&
typeof
type
.
prototype
.
mountComponent
=
=
=
'
function
'
&
&
typeof
type
.
prototype
.
receiveComponent
=
=
=
'
function
'
;
}
function
instantiateReactComponent
(
node
)
{
var
instance
;
if
(
node
=
=
=
null
|
|
node
=
=
=
false
)
{
instance
=
new
ReactEmptyComponent
(
instantiateReactComponent
)
;
}
else
if
(
typeof
node
=
=
=
'
object
'
)
{
var
element
=
node
;
!
(
element
&
&
(
typeof
element
.
type
=
=
=
'
function
'
|
|
typeof
element
.
type
=
=
=
'
string
'
)
)
?
false
?
invariant
(
false
'
Element
type
is
invalid
:
expected
a
string
(
for
built
-
in
components
)
'
+
'
or
a
class
/
function
(
for
composite
components
)
but
got
:
%
s
.
%
s
'
element
.
type
=
=
null
?
element
.
type
:
typeof
element
.
type
getDeclarationErrorAddendum
(
element
.
_owner
)
)
:
invariant
(
false
)
:
undefined
;
if
(
typeof
element
.
type
=
=
=
'
string
'
)
{
instance
=
ReactNativeComponent
.
createInternalComponent
(
element
)
;
}
else
if
(
isInternalComponentType
(
element
.
type
)
)
{
instance
=
new
element
.
type
(
element
)
;
}
else
{
instance
=
new
ReactCompositeComponentWrapper
(
)
;
}
}
else
if
(
typeof
node
=
=
=
'
string
'
|
|
typeof
node
=
=
=
'
number
'
)
{
instance
=
ReactNativeComponent
.
createInstanceForText
(
node
)
;
}
else
{
true
?
false
?
invariant
(
false
'
Encountered
invalid
React
node
of
type
%
s
'
typeof
node
)
:
invariant
(
false
)
:
undefined
;
}
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
typeof
instance
.
construct
=
=
=
'
function
'
&
&
typeof
instance
.
mountComponent
=
=
=
'
function
'
&
&
typeof
instance
.
receiveComponent
=
=
=
'
function
'
&
&
typeof
instance
.
unmountComponent
=
=
=
'
function
'
'
Only
React
Components
can
be
mounted
.
'
)
:
undefined
;
}
instance
.
construct
(
node
)
;
instance
.
_mountIndex
=
0
;
instance
.
_mountImage
=
null
;
if
(
false
)
{
instance
.
_isOwnerNecessary
=
false
;
instance
.
_warnedAboutRefsInRender
=
false
;
}
if
(
false
)
{
if
(
Object
.
preventExtensions
)
{
Object
.
preventExtensions
(
instance
)
;
}
}
return
instance
;
}
module
.
exports
=
instantiateReactComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactComponentEnvironment
=
__webpack_require__
(
79
)
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactInstanceMap
=
__webpack_require__
(
62
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
ReactPropTypeLocations
=
__webpack_require__
(
80
)
;
var
ReactPropTypeLocationNames
=
__webpack_require__
(
81
)
;
var
ReactReconciler
=
__webpack_require__
(
65
)
;
var
ReactUpdateQueue
=
__webpack_require__
(
68
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
emptyObject
=
__webpack_require__
(
73
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
shouldUpdateReactComponent
=
__webpack_require__
(
82
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
getDeclarationErrorAddendum
(
component
)
{
var
owner
=
component
.
_currentElement
.
_owner
|
|
null
;
if
(
owner
)
{
var
name
=
owner
.
getName
(
)
;
if
(
name
)
{
return
'
Check
the
render
method
of
'
+
name
+
'
.
'
;
}
}
return
'
'
;
}
function
StatelessComponent
(
Component
)
{
}
StatelessComponent
.
prototype
.
render
=
function
(
)
{
var
Component
=
ReactInstanceMap
.
get
(
this
)
.
_currentElement
.
type
;
return
Component
(
this
.
props
this
.
context
this
.
updater
)
;
}
;
var
nextMountID
=
1
;
var
ReactCompositeComponentMixin
=
{
construct
:
function
(
element
)
{
this
.
_currentElement
=
element
;
this
.
_rootNodeID
=
null
;
this
.
_instance
=
null
;
this
.
_pendingElement
=
null
;
this
.
_pendingStateQueue
=
null
;
this
.
_pendingReplaceState
=
false
;
this
.
_pendingForceUpdate
=
false
;
this
.
_renderedComponent
=
null
;
this
.
_context
=
null
;
this
.
_mountOrder
=
0
;
this
.
_topLevelWrapper
=
null
;
this
.
_pendingCallbacks
=
null
;
}
mountComponent
:
function
(
rootID
transaction
context
)
{
this
.
_context
=
context
;
this
.
_mountOrder
=
nextMountID
+
+
;
this
.
_rootNodeID
=
rootID
;
var
publicProps
=
this
.
_processProps
(
this
.
_currentElement
.
props
)
;
var
publicContext
=
this
.
_processContext
(
context
)
;
var
Component
=
this
.
_currentElement
.
type
;
var
inst
;
var
renderedElement
;
var
canInstantiate
=
(
'
prototype
'
in
Component
)
;
if
(
canInstantiate
)
{
if
(
false
)
{
ReactCurrentOwner
.
current
=
this
;
try
{
inst
=
new
Component
(
publicProps
publicContext
ReactUpdateQueue
)
;
}
finally
{
ReactCurrentOwner
.
current
=
null
;
}
}
else
{
inst
=
new
Component
(
publicProps
publicContext
ReactUpdateQueue
)
;
}
}
if
(
!
canInstantiate
|
|
inst
=
=
=
null
|
|
inst
=
=
=
false
|
|
ReactElement
.
isValidElement
(
inst
)
)
{
renderedElement
=
inst
;
inst
=
new
StatelessComponent
(
Component
)
;
}
if
(
false
)
{
if
(
inst
.
render
=
=
null
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
%
s
(
.
.
.
)
:
No
render
method
found
on
the
returned
component
'
+
'
instance
:
you
may
have
forgotten
to
define
render
returned
'
+
'
null
/
false
from
a
stateless
component
or
tried
to
render
an
'
+
'
element
whose
type
is
a
function
that
isn
\
'
t
a
React
component
.
'
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
:
undefined
;
}
else
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
Component
.
prototype
&
&
Component
.
prototype
.
isReactComponent
|
|
!
canInstantiate
|
|
!
(
inst
instanceof
Component
)
'
%
s
(
.
.
.
)
:
React
component
classes
must
extend
React
.
Component
.
'
Component
.
displayName
|
|
Component
.
name
|
|
'
Component
'
)
:
undefined
;
}
}
inst
.
props
=
publicProps
;
inst
.
context
=
publicContext
;
inst
.
refs
=
emptyObject
;
inst
.
updater
=
ReactUpdateQueue
;
this
.
_instance
=
inst
;
ReactInstanceMap
.
set
(
inst
this
)
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
inst
.
getInitialState
|
|
inst
.
getInitialState
.
isReactClassApproved
'
getInitialState
was
defined
on
%
s
a
plain
JavaScript
class
.
'
+
'
This
is
only
supported
for
classes
created
using
React
.
createClass
.
'
+
'
Did
you
mean
to
define
a
state
property
instead
?
'
this
.
getName
(
)
|
|
'
a
component
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
inst
.
getDefaultProps
|
|
inst
.
getDefaultProps
.
isReactClassApproved
'
getDefaultProps
was
defined
on
%
s
a
plain
JavaScript
class
.
'
+
'
This
is
only
supported
for
classes
created
using
React
.
createClass
.
'
+
'
Use
a
static
property
to
define
defaultProps
instead
.
'
this
.
getName
(
)
|
|
'
a
component
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
inst
.
propTypes
'
propTypes
was
defined
as
an
instance
property
on
%
s
.
Use
a
static
'
+
'
property
to
define
propTypes
instead
.
'
this
.
getName
(
)
|
|
'
a
component
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
inst
.
contextTypes
'
contextTypes
was
defined
as
an
instance
property
on
%
s
.
Use
a
'
+
'
static
property
to
define
contextTypes
instead
.
'
this
.
getName
(
)
|
|
'
a
component
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
typeof
inst
.
componentShouldUpdate
!
=
=
'
function
'
'
%
s
has
a
method
called
'
+
'
componentShouldUpdate
(
)
.
Did
you
mean
shouldComponentUpdate
(
)
?
'
+
'
The
name
is
phrased
as
a
question
because
the
function
is
'
+
'
expected
to
return
a
value
.
'
this
.
getName
(
)
|
|
'
A
component
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
typeof
inst
.
componentDidUnmount
!
=
=
'
function
'
'
%
s
has
a
method
called
'
+
'
componentDidUnmount
(
)
.
But
there
is
no
such
lifecycle
method
.
'
+
'
Did
you
mean
componentWillUnmount
(
)
?
'
this
.
getName
(
)
|
|
'
A
component
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
typeof
inst
.
componentWillRecieveProps
!
=
=
'
function
'
'
%
s
has
a
method
called
'
+
'
componentWillRecieveProps
(
)
.
Did
you
mean
componentWillReceiveProps
(
)
?
'
this
.
getName
(
)
|
|
'
A
component
'
)
:
undefined
;
}
var
initialState
=
inst
.
state
;
if
(
initialState
=
=
=
undefined
)
{
inst
.
state
=
initialState
=
null
;
}
!
(
typeof
initialState
=
=
=
'
object
'
&
&
!
Array
.
isArray
(
initialState
)
)
?
false
?
invariant
(
false
'
%
s
.
state
:
must
be
set
to
an
object
or
null
'
this
.
getName
(
)
|
|
'
ReactCompositeComponent
'
)
:
invariant
(
false
)
:
undefined
;
this
.
_pendingStateQueue
=
null
;
this
.
_pendingReplaceState
=
false
;
this
.
_pendingForceUpdate
=
false
;
if
(
inst
.
componentWillMount
)
{
inst
.
componentWillMount
(
)
;
if
(
this
.
_pendingStateQueue
)
{
inst
.
state
=
this
.
_processPendingState
(
inst
.
props
inst
.
context
)
;
}
}
if
(
renderedElement
=
=
=
undefined
)
{
renderedElement
=
this
.
_renderValidatedComponent
(
)
;
}
this
.
_renderedComponent
=
this
.
_instantiateReactComponent
(
renderedElement
)
;
var
markup
=
ReactReconciler
.
mountComponent
(
this
.
_renderedComponent
rootID
transaction
this
.
_processChildContext
(
context
)
)
;
if
(
inst
.
componentDidMount
)
{
transaction
.
getReactMountReady
(
)
.
enqueue
(
inst
.
componentDidMount
inst
)
;
}
return
markup
;
}
unmountComponent
:
function
(
)
{
var
inst
=
this
.
_instance
;
if
(
inst
.
componentWillUnmount
)
{
inst
.
componentWillUnmount
(
)
;
}
ReactReconciler
.
unmountComponent
(
this
.
_renderedComponent
)
;
this
.
_renderedComponent
=
null
;
this
.
_instance
=
null
;
this
.
_pendingStateQueue
=
null
;
this
.
_pendingReplaceState
=
false
;
this
.
_pendingForceUpdate
=
false
;
this
.
_pendingCallbacks
=
null
;
this
.
_pendingElement
=
null
;
this
.
_context
=
null
;
this
.
_rootNodeID
=
null
;
this
.
_topLevelWrapper
=
null
;
ReactInstanceMap
.
remove
(
inst
)
;
}
_maskContext
:
function
(
context
)
{
var
maskedContext
=
null
;
var
Component
=
this
.
_currentElement
.
type
;
var
contextTypes
=
Component
.
contextTypes
;
if
(
!
contextTypes
)
{
return
emptyObject
;
}
maskedContext
=
{
}
;
for
(
var
contextName
in
contextTypes
)
{
maskedContext
[
contextName
]
=
context
[
contextName
]
;
}
return
maskedContext
;
}
_processContext
:
function
(
context
)
{
var
maskedContext
=
this
.
_maskContext
(
context
)
;
if
(
false
)
{
var
Component
=
this
.
_currentElement
.
type
;
if
(
Component
.
contextTypes
)
{
this
.
_checkPropTypes
(
Component
.
contextTypes
maskedContext
ReactPropTypeLocations
.
context
)
;
}
}
return
maskedContext
;
}
_processChildContext
:
function
(
currentContext
)
{
var
Component
=
this
.
_currentElement
.
type
;
var
inst
=
this
.
_instance
;
var
childContext
=
inst
.
getChildContext
&
&
inst
.
getChildContext
(
)
;
if
(
childContext
)
{
!
(
typeof
Component
.
childContextTypes
=
=
=
'
object
'
)
?
false
?
invariant
(
false
'
%
s
.
getChildContext
(
)
:
childContextTypes
must
be
defined
in
order
to
'
+
'
use
getChildContext
(
)
.
'
this
.
getName
(
)
|
|
'
ReactCompositeComponent
'
)
:
invariant
(
false
)
:
undefined
;
if
(
false
)
{
this
.
_checkPropTypes
(
Component
.
childContextTypes
childContext
ReactPropTypeLocations
.
childContext
)
;
}
for
(
var
name
in
childContext
)
{
!
(
name
in
Component
.
childContextTypes
)
?
false
?
invariant
(
false
'
%
s
.
getChildContext
(
)
:
key
"
%
s
"
is
not
defined
in
childContextTypes
.
'
this
.
getName
(
)
|
|
'
ReactCompositeComponent
'
name
)
:
invariant
(
false
)
:
undefined
;
}
return
assign
(
{
}
currentContext
childContext
)
;
}
return
currentContext
;
}
_processProps
:
function
(
newProps
)
{
if
(
false
)
{
var
Component
=
this
.
_currentElement
.
type
;
if
(
Component
.
propTypes
)
{
this
.
_checkPropTypes
(
Component
.
propTypes
newProps
ReactPropTypeLocations
.
prop
)
;
}
}
return
newProps
;
}
_checkPropTypes
:
function
(
propTypes
props
location
)
{
var
componentName
=
this
.
getName
(
)
;
for
(
var
propName
in
propTypes
)
{
if
(
propTypes
.
hasOwnProperty
(
propName
)
)
{
var
error
;
try
{
!
(
typeof
propTypes
[
propName
]
=
=
=
'
function
'
)
?
false
?
invariant
(
false
'
%
s
:
%
s
type
%
s
is
invalid
;
it
must
be
a
function
usually
'
+
'
from
React
.
PropTypes
.
'
componentName
|
|
'
React
class
'
ReactPropTypeLocationNames
[
location
]
propName
)
:
invariant
(
false
)
:
undefined
;
error
=
propTypes
[
propName
]
(
props
propName
componentName
location
)
;
}
catch
(
ex
)
{
error
=
ex
;
}
if
(
error
instanceof
Error
)
{
var
addendum
=
getDeclarationErrorAddendum
(
this
)
;
if
(
location
=
=
=
ReactPropTypeLocations
.
prop
)
{
false
?
warning
(
false
'
Failed
Composite
propType
:
%
s
%
s
'
error
.
message
addendum
)
:
undefined
;
}
else
{
false
?
warning
(
false
'
Failed
Context
Types
:
%
s
%
s
'
error
.
message
addendum
)
:
undefined
;
}
}
}
}
}
receiveComponent
:
function
(
nextElement
transaction
nextContext
)
{
var
prevElement
=
this
.
_currentElement
;
var
prevContext
=
this
.
_context
;
this
.
_pendingElement
=
null
;
this
.
updateComponent
(
transaction
prevElement
nextElement
prevContext
nextContext
)
;
}
performUpdateIfNecessary
:
function
(
transaction
)
{
if
(
this
.
_pendingElement
!
=
null
)
{
ReactReconciler
.
receiveComponent
(
this
this
.
_pendingElement
|
|
this
.
_currentElement
transaction
this
.
_context
)
;
}
if
(
this
.
_pendingStateQueue
!
=
=
null
|
|
this
.
_pendingForceUpdate
)
{
this
.
updateComponent
(
transaction
this
.
_currentElement
this
.
_currentElement
this
.
_context
this
.
_context
)
;
}
}
updateComponent
:
function
(
transaction
prevParentElement
nextParentElement
prevUnmaskedContext
nextUnmaskedContext
)
{
var
inst
=
this
.
_instance
;
var
nextContext
=
this
.
_context
=
=
=
nextUnmaskedContext
?
inst
.
context
:
this
.
_processContext
(
nextUnmaskedContext
)
;
var
nextProps
;
if
(
prevParentElement
=
=
=
nextParentElement
)
{
nextProps
=
nextParentElement
.
props
;
}
else
{
nextProps
=
this
.
_processProps
(
nextParentElement
.
props
)
;
if
(
inst
.
componentWillReceiveProps
)
{
inst
.
componentWillReceiveProps
(
nextProps
nextContext
)
;
}
}
var
nextState
=
this
.
_processPendingState
(
nextProps
nextContext
)
;
var
shouldUpdate
=
this
.
_pendingForceUpdate
|
|
!
inst
.
shouldComponentUpdate
|
|
inst
.
shouldComponentUpdate
(
nextProps
nextState
nextContext
)
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
typeof
shouldUpdate
!
=
=
'
undefined
'
'
%
s
.
shouldComponentUpdate
(
)
:
Returned
undefined
instead
of
a
'
+
'
boolean
value
.
Make
sure
to
return
true
or
false
.
'
this
.
getName
(
)
|
|
'
ReactCompositeComponent
'
)
:
undefined
;
}
if
(
shouldUpdate
)
{
this
.
_pendingForceUpdate
=
false
;
this
.
_performComponentUpdate
(
nextParentElement
nextProps
nextState
nextContext
transaction
nextUnmaskedContext
)
;
}
else
{
this
.
_currentElement
=
nextParentElement
;
this
.
_context
=
nextUnmaskedContext
;
inst
.
props
=
nextProps
;
inst
.
state
=
nextState
;
inst
.
context
=
nextContext
;
}
}
_processPendingState
:
function
(
props
context
)
{
var
inst
=
this
.
_instance
;
var
queue
=
this
.
_pendingStateQueue
;
var
replace
=
this
.
_pendingReplaceState
;
this
.
_pendingReplaceState
=
false
;
this
.
_pendingStateQueue
=
null
;
if
(
!
queue
)
{
return
inst
.
state
;
}
if
(
replace
&
&
queue
.
length
=
=
=
1
)
{
return
queue
[
0
]
;
}
var
nextState
=
assign
(
{
}
replace
?
queue
[
0
]
:
inst
.
state
)
;
for
(
var
i
=
replace
?
1
:
0
;
i
<
queue
.
length
;
i
+
+
)
{
var
partial
=
queue
[
i
]
;
assign
(
nextState
typeof
partial
=
=
=
'
function
'
?
partial
.
call
(
inst
nextState
props
context
)
:
partial
)
;
}
return
nextState
;
}
_performComponentUpdate
:
function
(
nextElement
nextProps
nextState
nextContext
transaction
unmaskedContext
)
{
var
inst
=
this
.
_instance
;
var
hasComponentDidUpdate
=
Boolean
(
inst
.
componentDidUpdate
)
;
var
prevProps
;
var
prevState
;
var
prevContext
;
if
(
hasComponentDidUpdate
)
{
prevProps
=
inst
.
props
;
prevState
=
inst
.
state
;
prevContext
=
inst
.
context
;
}
if
(
inst
.
componentWillUpdate
)
{
inst
.
componentWillUpdate
(
nextProps
nextState
nextContext
)
;
}
this
.
_currentElement
=
nextElement
;
this
.
_context
=
unmaskedContext
;
inst
.
props
=
nextProps
;
inst
.
state
=
nextState
;
inst
.
context
=
nextContext
;
this
.
_updateRenderedComponent
(
transaction
unmaskedContext
)
;
if
(
hasComponentDidUpdate
)
{
transaction
.
getReactMountReady
(
)
.
enqueue
(
inst
.
componentDidUpdate
.
bind
(
inst
prevProps
prevState
prevContext
)
inst
)
;
}
}
_updateRenderedComponent
:
function
(
transaction
context
)
{
var
prevComponentInstance
=
this
.
_renderedComponent
;
var
prevRenderedElement
=
prevComponentInstance
.
_currentElement
;
var
nextRenderedElement
=
this
.
_renderValidatedComponent
(
)
;
if
(
shouldUpdateReactComponent
(
prevRenderedElement
nextRenderedElement
)
)
{
ReactReconciler
.
receiveComponent
(
prevComponentInstance
nextRenderedElement
transaction
this
.
_processChildContext
(
context
)
)
;
}
else
{
var
thisID
=
this
.
_rootNodeID
;
var
prevComponentID
=
prevComponentInstance
.
_rootNodeID
;
ReactReconciler
.
unmountComponent
(
prevComponentInstance
)
;
this
.
_renderedComponent
=
this
.
_instantiateReactComponent
(
nextRenderedElement
)
;
var
nextMarkup
=
ReactReconciler
.
mountComponent
(
this
.
_renderedComponent
thisID
transaction
this
.
_processChildContext
(
context
)
)
;
this
.
_replaceNodeWithMarkupByID
(
prevComponentID
nextMarkup
)
;
}
}
_replaceNodeWithMarkupByID
:
function
(
prevComponentID
nextMarkup
)
{
ReactComponentEnvironment
.
replaceNodeWithMarkupByID
(
prevComponentID
nextMarkup
)
;
}
_renderValidatedComponentWithoutOwnerOrContext
:
function
(
)
{
var
inst
=
this
.
_instance
;
var
renderedComponent
=
inst
.
render
(
)
;
if
(
false
)
{
if
(
typeof
renderedComponent
=
=
=
'
undefined
'
&
&
inst
.
render
.
_isMockFunction
)
{
renderedComponent
=
null
;
}
}
return
renderedComponent
;
}
_renderValidatedComponent
:
function
(
)
{
var
renderedComponent
;
ReactCurrentOwner
.
current
=
this
;
try
{
renderedComponent
=
this
.
_renderValidatedComponentWithoutOwnerOrContext
(
)
;
}
finally
{
ReactCurrentOwner
.
current
=
null
;
}
!
(
renderedComponent
=
=
=
null
|
|
renderedComponent
=
=
=
false
|
|
ReactElement
.
isValidElement
(
renderedComponent
)
)
?
false
?
invariant
(
false
'
%
s
.
render
(
)
:
A
valid
ReactComponent
must
be
returned
.
You
may
have
'
+
'
returned
undefined
an
array
or
some
other
invalid
object
.
'
this
.
getName
(
)
|
|
'
ReactCompositeComponent
'
)
:
invariant
(
false
)
:
undefined
;
return
renderedComponent
;
}
attachRef
:
function
(
ref
component
)
{
var
inst
=
this
.
getPublicInstance
(
)
;
!
(
inst
!
=
null
)
?
false
?
invariant
(
false
'
Stateless
function
components
cannot
have
refs
.
'
)
:
invariant
(
false
)
:
undefined
;
var
publicComponentInstance
=
component
.
getPublicInstance
(
)
;
if
(
false
)
{
var
componentName
=
component
&
&
component
.
getName
?
component
.
getName
(
)
:
'
a
component
'
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
publicComponentInstance
!
=
null
'
Stateless
function
components
cannot
be
given
refs
'
+
'
(
See
ref
"
%
s
"
in
%
s
created
by
%
s
)
.
'
+
'
Attempts
to
access
this
ref
will
fail
.
'
ref
componentName
this
.
getName
(
)
)
:
undefined
;
}
var
refs
=
inst
.
refs
=
=
=
emptyObject
?
inst
.
refs
=
{
}
:
inst
.
refs
;
refs
[
ref
]
=
publicComponentInstance
;
}
detachRef
:
function
(
ref
)
{
var
refs
=
this
.
getPublicInstance
(
)
.
refs
;
delete
refs
[
ref
]
;
}
getName
:
function
(
)
{
var
type
=
this
.
_currentElement
.
type
;
var
constructor
=
this
.
_instance
&
&
this
.
_instance
.
constructor
;
return
type
.
displayName
|
|
constructor
&
&
constructor
.
displayName
|
|
type
.
name
|
|
constructor
&
&
constructor
.
name
|
|
null
;
}
getPublicInstance
:
function
(
)
{
var
inst
=
this
.
_instance
;
if
(
inst
instanceof
StatelessComponent
)
{
return
null
;
}
return
inst
;
}
_instantiateReactComponent
:
null
}
;
ReactPerf
.
measureMethods
(
ReactCompositeComponentMixin
'
ReactCompositeComponent
'
{
mountComponent
:
'
mountComponent
'
updateComponent
:
'
updateComponent
'
_renderValidatedComponent
:
'
_renderValidatedComponent
'
}
)
;
var
ReactCompositeComponent
=
{
Mixin
:
ReactCompositeComponentMixin
}
;
module
.
exports
=
ReactCompositeComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
__webpack_require__
(
28
)
;
var
injected
=
false
;
var
ReactComponentEnvironment
=
{
unmountIDFromEnvironment
:
null
replaceNodeWithMarkupByID
:
null
processChildrenUpdates
:
null
injection
:
{
injectEnvironment
:
function
(
environment
)
{
!
!
injected
?
false
?
invariant
(
false
'
ReactCompositeComponent
:
injectEnvironment
(
)
can
only
be
called
once
.
'
)
:
invariant
(
false
)
:
undefined
;
ReactComponentEnvironment
.
unmountIDFromEnvironment
=
environment
.
unmountIDFromEnvironment
;
ReactComponentEnvironment
.
replaceNodeWithMarkupByID
=
environment
.
replaceNodeWithMarkupByID
;
ReactComponentEnvironment
.
processChildrenUpdates
=
environment
.
processChildrenUpdates
;
injected
=
true
;
}
}
}
;
module
.
exports
=
ReactComponentEnvironment
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
keyMirror
=
__webpack_require__
(
32
)
;
var
ReactPropTypeLocations
=
keyMirror
(
{
prop
:
null
context
:
null
childContext
:
null
}
)
;
module
.
exports
=
ReactPropTypeLocations
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactPropTypeLocationNames
=
{
}
;
if
(
false
)
{
ReactPropTypeLocationNames
=
{
prop
:
'
prop
'
context
:
'
context
'
childContext
:
'
child
context
'
}
;
}
module
.
exports
=
ReactPropTypeLocationNames
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
shouldUpdateReactComponent
(
prevElement
nextElement
)
{
var
prevEmpty
=
prevElement
=
=
=
null
|
|
prevElement
=
=
=
false
;
var
nextEmpty
=
nextElement
=
=
=
null
|
|
nextElement
=
=
=
false
;
if
(
prevEmpty
|
|
nextEmpty
)
{
return
prevEmpty
=
=
=
nextEmpty
;
}
var
prevType
=
typeof
prevElement
;
var
nextType
=
typeof
nextElement
;
if
(
prevType
=
=
=
'
string
'
|
|
prevType
=
=
=
'
number
'
)
{
return
nextType
=
=
=
'
string
'
|
|
nextType
=
=
=
'
number
'
;
}
else
{
return
nextType
=
=
=
'
object
'
&
&
prevElement
.
type
=
=
=
nextElement
.
type
&
&
prevElement
.
key
=
=
=
nextElement
.
key
;
}
return
false
;
}
module
.
exports
=
shouldUpdateReactComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactEmptyComponentRegistry
=
__webpack_require__
(
59
)
;
var
ReactReconciler
=
__webpack_require__
(
65
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
placeholderElement
;
var
ReactEmptyComponentInjection
=
{
injectEmptyComponent
:
function
(
component
)
{
placeholderElement
=
ReactElement
.
createElement
(
component
)
;
}
}
;
var
ReactEmptyComponent
=
function
(
instantiate
)
{
this
.
_currentElement
=
null
;
this
.
_rootNodeID
=
null
;
this
.
_renderedComponent
=
instantiate
(
placeholderElement
)
;
}
;
assign
(
ReactEmptyComponent
.
prototype
{
construct
:
function
(
element
)
{
}
mountComponent
:
function
(
rootID
transaction
context
)
{
ReactEmptyComponentRegistry
.
registerNullComponentID
(
rootID
)
;
this
.
_rootNodeID
=
rootID
;
return
ReactReconciler
.
mountComponent
(
this
.
_renderedComponent
rootID
transaction
context
)
;
}
receiveComponent
:
function
(
)
{
}
unmountComponent
:
function
(
rootID
transaction
context
)
{
ReactReconciler
.
unmountComponent
(
this
.
_renderedComponent
)
;
ReactEmptyComponentRegistry
.
deregisterNullComponentID
(
this
.
_rootNodeID
)
;
this
.
_rootNodeID
=
null
;
this
.
_renderedComponent
=
null
;
}
}
)
;
ReactEmptyComponent
.
injection
=
ReactEmptyComponentInjection
;
module
.
exports
=
ReactEmptyComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
assign
=
__webpack_require__
(
54
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
autoGenerateWrapperClass
=
null
;
var
genericComponentClass
=
null
;
var
tagToComponentClass
=
{
}
;
var
textComponentClass
=
null
;
var
ReactNativeComponentInjection
=
{
injectGenericComponentClass
:
function
(
componentClass
)
{
genericComponentClass
=
componentClass
;
}
injectTextComponentClass
:
function
(
componentClass
)
{
textComponentClass
=
componentClass
;
}
injectComponentClasses
:
function
(
componentClasses
)
{
assign
(
tagToComponentClass
componentClasses
)
;
}
}
;
function
getComponentClassForElement
(
element
)
{
if
(
typeof
element
.
type
=
=
=
'
function
'
)
{
return
element
.
type
;
}
var
tag
=
element
.
type
;
var
componentClass
=
tagToComponentClass
[
tag
]
;
if
(
componentClass
=
=
null
)
{
tagToComponentClass
[
tag
]
=
componentClass
=
autoGenerateWrapperClass
(
tag
)
;
}
return
componentClass
;
}
function
createInternalComponent
(
element
)
{
!
genericComponentClass
?
false
?
invariant
(
false
'
There
is
no
registered
component
for
the
tag
%
s
'
element
.
type
)
:
invariant
(
false
)
:
undefined
;
return
new
genericComponentClass
(
element
.
type
element
.
props
)
;
}
function
createInstanceForText
(
text
)
{
return
new
textComponentClass
(
text
)
;
}
function
isTextComponent
(
component
)
{
return
component
instanceof
textComponentClass
;
}
var
ReactNativeComponent
=
{
getComponentClassForElement
:
getComponentClassForElement
createInternalComponent
:
createInternalComponent
createInstanceForText
:
createInstanceForText
isTextComponent
:
isTextComponent
injection
:
ReactNativeComponentInjection
}
;
module
.
exports
=
ReactNativeComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
assign
=
__webpack_require__
(
54
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
validateDOMNesting
=
emptyFunction
;
if
(
false
)
{
var
specialTags
=
[
'
address
'
'
applet
'
'
area
'
'
article
'
'
aside
'
'
base
'
'
basefont
'
'
bgsound
'
'
blockquote
'
'
body
'
'
br
'
'
button
'
'
caption
'
'
center
'
'
col
'
'
colgroup
'
'
dd
'
'
details
'
'
dir
'
'
div
'
'
dl
'
'
dt
'
'
embed
'
'
fieldset
'
'
figcaption
'
'
figure
'
'
footer
'
'
form
'
'
frame
'
'
frameset
'
'
h1
'
'
h2
'
'
h3
'
'
h4
'
'
h5
'
'
h6
'
'
head
'
'
header
'
'
hgroup
'
'
hr
'
'
html
'
'
iframe
'
'
img
'
'
input
'
'
isindex
'
'
li
'
'
link
'
'
listing
'
'
main
'
'
marquee
'
'
menu
'
'
menuitem
'
'
meta
'
'
nav
'
'
noembed
'
'
noframes
'
'
noscript
'
'
object
'
'
ol
'
'
p
'
'
param
'
'
plaintext
'
'
pre
'
'
script
'
'
section
'
'
select
'
'
source
'
'
style
'
'
summary
'
'
table
'
'
tbody
'
'
td
'
'
template
'
'
textarea
'
'
tfoot
'
'
th
'
'
thead
'
'
title
'
'
tr
'
'
track
'
'
ul
'
'
wbr
'
'
xmp
'
]
;
var
inScopeTags
=
[
'
applet
'
'
caption
'
'
html
'
'
table
'
'
td
'
'
th
'
'
marquee
'
'
object
'
'
template
'
'
foreignObject
'
'
desc
'
'
title
'
]
;
var
buttonScopeTags
=
inScopeTags
.
concat
(
[
'
button
'
]
)
;
var
impliedEndTags
=
[
'
dd
'
'
dt
'
'
li
'
'
option
'
'
optgroup
'
'
p
'
'
rp
'
'
rt
'
]
;
var
emptyAncestorInfo
=
{
parentTag
:
null
formTag
:
null
aTagInScope
:
null
buttonTagInScope
:
null
nobrTagInScope
:
null
pTagInButtonScope
:
null
listItemTagAutoclosing
:
null
dlItemTagAutoclosing
:
null
}
;
var
updatedAncestorInfo
=
function
(
oldInfo
tag
instance
)
{
var
ancestorInfo
=
assign
(
{
}
oldInfo
|
|
emptyAncestorInfo
)
;
var
info
=
{
tag
:
tag
instance
:
instance
}
;
if
(
inScopeTags
.
indexOf
(
tag
)
!
=
=
-
1
)
{
ancestorInfo
.
aTagInScope
=
null
;
ancestorInfo
.
buttonTagInScope
=
null
;
ancestorInfo
.
nobrTagInScope
=
null
;
}
if
(
buttonScopeTags
.
indexOf
(
tag
)
!
=
=
-
1
)
{
ancestorInfo
.
pTagInButtonScope
=
null
;
}
if
(
specialTags
.
indexOf
(
tag
)
!
=
=
-
1
&
&
tag
!
=
=
'
address
'
&
&
tag
!
=
=
'
div
'
&
&
tag
!
=
=
'
p
'
)
{
ancestorInfo
.
listItemTagAutoclosing
=
null
;
ancestorInfo
.
dlItemTagAutoclosing
=
null
;
}
ancestorInfo
.
parentTag
=
info
;
if
(
tag
=
=
=
'
form
'
)
{
ancestorInfo
.
formTag
=
info
;
}
if
(
tag
=
=
=
'
a
'
)
{
ancestorInfo
.
aTagInScope
=
info
;
}
if
(
tag
=
=
=
'
button
'
)
{
ancestorInfo
.
buttonTagInScope
=
info
;
}
if
(
tag
=
=
=
'
nobr
'
)
{
ancestorInfo
.
nobrTagInScope
=
info
;
}
if
(
tag
=
=
=
'
p
'
)
{
ancestorInfo
.
pTagInButtonScope
=
info
;
}
if
(
tag
=
=
=
'
li
'
)
{
ancestorInfo
.
listItemTagAutoclosing
=
info
;
}
if
(
tag
=
=
=
'
dd
'
|
|
tag
=
=
=
'
dt
'
)
{
ancestorInfo
.
dlItemTagAutoclosing
=
info
;
}
return
ancestorInfo
;
}
;
var
isTagValidWithParent
=
function
(
tag
parentTag
)
{
switch
(
parentTag
)
{
case
'
select
'
:
return
tag
=
=
=
'
option
'
|
|
tag
=
=
=
'
optgroup
'
|
|
tag
=
=
=
'
#
text
'
;
case
'
optgroup
'
:
return
tag
=
=
=
'
option
'
|
|
tag
=
=
=
'
#
text
'
;
case
'
option
'
:
return
tag
=
=
=
'
#
text
'
;
case
'
tr
'
:
return
tag
=
=
=
'
th
'
|
|
tag
=
=
=
'
td
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
tbody
'
:
case
'
thead
'
:
case
'
tfoot
'
:
return
tag
=
=
=
'
tr
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
colgroup
'
:
return
tag
=
=
=
'
col
'
|
|
tag
=
=
=
'
template
'
;
case
'
table
'
:
return
tag
=
=
=
'
caption
'
|
|
tag
=
=
=
'
colgroup
'
|
|
tag
=
=
=
'
tbody
'
|
|
tag
=
=
=
'
tfoot
'
|
|
tag
=
=
=
'
thead
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
head
'
:
return
tag
=
=
=
'
base
'
|
|
tag
=
=
=
'
basefont
'
|
|
tag
=
=
=
'
bgsound
'
|
|
tag
=
=
=
'
link
'
|
|
tag
=
=
=
'
meta
'
|
|
tag
=
=
=
'
title
'
|
|
tag
=
=
=
'
noscript
'
|
|
tag
=
=
=
'
noframes
'
|
|
tag
=
=
=
'
style
'
|
|
tag
=
=
=
'
script
'
|
|
tag
=
=
=
'
template
'
;
case
'
html
'
:
return
tag
=
=
=
'
head
'
|
|
tag
=
=
=
'
body
'
;
}
switch
(
tag
)
{
case
'
h1
'
:
case
'
h2
'
:
case
'
h3
'
:
case
'
h4
'
:
case
'
h5
'
:
case
'
h6
'
:
return
parentTag
!
=
=
'
h1
'
&
&
parentTag
!
=
=
'
h2
'
&
&
parentTag
!
=
=
'
h3
'
&
&
parentTag
!
=
=
'
h4
'
&
&
parentTag
!
=
=
'
h5
'
&
&
parentTag
!
=
=
'
h6
'
;
case
'
rp
'
:
case
'
rt
'
:
return
impliedEndTags
.
indexOf
(
parentTag
)
=
=
=
-
1
;
case
'
caption
'
:
case
'
col
'
:
case
'
colgroup
'
:
case
'
frame
'
:
case
'
head
'
:
case
'
tbody
'
:
case
'
td
'
:
case
'
tfoot
'
:
case
'
th
'
:
case
'
thead
'
:
case
'
tr
'
:
return
parentTag
=
=
null
;
}
return
true
;
}
;
var
findInvalidAncestorForTag
=
function
(
tag
ancestorInfo
)
{
switch
(
tag
)
{
case
'
address
'
:
case
'
article
'
:
case
'
aside
'
:
case
'
blockquote
'
:
case
'
center
'
:
case
'
details
'
:
case
'
dialog
'
:
case
'
dir
'
:
case
'
div
'
:
case
'
dl
'
:
case
'
fieldset
'
:
case
'
figcaption
'
:
case
'
figure
'
:
case
'
footer
'
:
case
'
header
'
:
case
'
hgroup
'
:
case
'
main
'
:
case
'
menu
'
:
case
'
nav
'
:
case
'
ol
'
:
case
'
p
'
:
case
'
section
'
:
case
'
summary
'
:
case
'
ul
'
:
case
'
pre
'
:
case
'
listing
'
:
case
'
table
'
:
case
'
hr
'
:
case
'
xmp
'
:
case
'
h1
'
:
case
'
h2
'
:
case
'
h3
'
:
case
'
h4
'
:
case
'
h5
'
:
case
'
h6
'
:
return
ancestorInfo
.
pTagInButtonScope
;
case
'
form
'
:
return
ancestorInfo
.
formTag
|
|
ancestorInfo
.
pTagInButtonScope
;
case
'
li
'
:
return
ancestorInfo
.
listItemTagAutoclosing
;
case
'
dd
'
:
case
'
dt
'
:
return
ancestorInfo
.
dlItemTagAutoclosing
;
case
'
button
'
:
return
ancestorInfo
.
buttonTagInScope
;
case
'
a
'
:
return
ancestorInfo
.
aTagInScope
;
case
'
nobr
'
:
return
ancestorInfo
.
nobrTagInScope
;
}
return
null
;
}
;
var
findOwnerStack
=
function
(
instance
)
{
if
(
!
instance
)
{
return
[
]
;
}
var
stack
=
[
]
;
do
{
stack
.
push
(
instance
)
;
}
while
(
instance
=
instance
.
_currentElement
.
_owner
)
;
stack
.
reverse
(
)
;
return
stack
;
}
;
var
didWarn
=
{
}
;
validateDOMNesting
=
function
(
childTag
childInstance
ancestorInfo
)
{
ancestorInfo
=
ancestorInfo
|
|
emptyAncestorInfo
;
var
parentInfo
=
ancestorInfo
.
parentTag
;
var
parentTag
=
parentInfo
&
&
parentInfo
.
tag
;
var
invalidParent
=
isTagValidWithParent
(
childTag
parentTag
)
?
null
:
parentInfo
;
var
invalidAncestor
=
invalidParent
?
null
:
findInvalidAncestorForTag
(
childTag
ancestorInfo
)
;
var
problematic
=
invalidParent
|
|
invalidAncestor
;
if
(
problematic
)
{
var
ancestorTag
=
problematic
.
tag
;
var
ancestorInstance
=
problematic
.
instance
;
var
childOwner
=
childInstance
&
&
childInstance
.
_currentElement
.
_owner
;
var
ancestorOwner
=
ancestorInstance
&
&
ancestorInstance
.
_currentElement
.
_owner
;
var
childOwners
=
findOwnerStack
(
childOwner
)
;
var
ancestorOwners
=
findOwnerStack
(
ancestorOwner
)
;
var
minStackLen
=
Math
.
min
(
childOwners
.
length
ancestorOwners
.
length
)
;
var
i
;
var
deepestCommon
=
-
1
;
for
(
i
=
0
;
i
<
minStackLen
;
i
+
+
)
{
if
(
childOwners
[
i
]
=
=
=
ancestorOwners
[
i
]
)
{
deepestCommon
=
i
;
}
else
{
break
;
}
}
var
UNKNOWN
=
'
(
unknown
)
'
;
var
childOwnerNames
=
childOwners
.
slice
(
deepestCommon
+
1
)
.
map
(
function
(
inst
)
{
return
inst
.
getName
(
)
|
|
UNKNOWN
;
}
)
;
var
ancestorOwnerNames
=
ancestorOwners
.
slice
(
deepestCommon
+
1
)
.
map
(
function
(
inst
)
{
return
inst
.
getName
(
)
|
|
UNKNOWN
;
}
)
;
var
ownerInfo
=
[
]
.
concat
(
deepestCommon
!
=
=
-
1
?
childOwners
[
deepestCommon
]
.
getName
(
)
|
|
UNKNOWN
:
[
]
ancestorOwnerNames
ancestorTag
invalidAncestor
?
[
'
.
.
.
'
]
:
[
]
childOwnerNames
childTag
)
.
join
(
'
>
'
)
;
var
warnKey
=
!
!
invalidParent
+
'
|
'
+
childTag
+
'
|
'
+
ancestorTag
+
'
|
'
+
ownerInfo
;
if
(
didWarn
[
warnKey
]
)
{
return
;
}
didWarn
[
warnKey
]
=
true
;
if
(
invalidParent
)
{
var
info
=
'
'
;
if
(
ancestorTag
=
=
=
'
table
'
&
&
childTag
=
=
=
'
tr
'
)
{
info
+
=
'
Add
a
<
tbody
>
to
your
code
to
match
the
DOM
tree
generated
by
'
+
'
the
browser
.
'
;
}
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
validateDOMNesting
(
.
.
.
)
:
<
%
s
>
cannot
appear
as
a
child
of
<
%
s
>
.
'
+
'
See
%
s
.
%
s
'
childTag
ancestorTag
ownerInfo
info
)
:
undefined
;
}
else
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
validateDOMNesting
(
.
.
.
)
:
<
%
s
>
cannot
appear
as
a
descendant
of
'
+
'
<
%
s
>
.
See
%
s
.
'
childTag
ancestorTag
ownerInfo
)
:
undefined
;
}
}
}
;
validateDOMNesting
.
ancestorInfoContextKey
=
'
__validateDOMNesting_ancestorInfo
'
+
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
validateDOMNesting
.
updatedAncestorInfo
=
updatedAncestorInfo
;
validateDOMNesting
.
isTagValidInContext
=
function
(
tag
ancestorInfo
)
{
ancestorInfo
=
ancestorInfo
|
|
emptyAncestorInfo
;
var
parentInfo
=
ancestorInfo
.
parentTag
;
var
parentTag
=
parentInfo
&
&
parentInfo
.
tag
;
return
isTagValidWithParent
(
tag
parentTag
)
&
&
!
findInvalidAncestorForTag
(
tag
ancestorInfo
)
;
}
;
}
module
.
exports
=
validateDOMNesting
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
BeforeInputEventPlugin
=
__webpack_require__
(
87
)
;
var
ChangeEventPlugin
=
__webpack_require__
(
95
)
;
var
ClientReactRootIndex
=
__webpack_require__
(
98
)
;
var
DefaultEventPluginOrder
=
__webpack_require__
(
99
)
;
var
EnterLeaveEventPlugin
=
__webpack_require__
(
100
)
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
HTMLDOMPropertyConfig
=
__webpack_require__
(
104
)
;
var
ReactBrowserComponentMixin
=
__webpack_require__
(
105
)
;
var
ReactComponentBrowserEnvironment
=
__webpack_require__
(
41
)
;
var
ReactDefaultBatchingStrategy
=
__webpack_require__
(
107
)
;
var
ReactDOMComponent
=
__webpack_require__
(
108
)
;
var
ReactDOMTextComponent
=
__webpack_require__
(
21
)
;
var
ReactEventListener
=
__webpack_require__
(
133
)
;
var
ReactInjection
=
__webpack_require__
(
136
)
;
var
ReactInstanceHandles
=
__webpack_require__
(
60
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactReconcileTransaction
=
__webpack_require__
(
140
)
;
var
SelectEventPlugin
=
__webpack_require__
(
145
)
;
var
ServerReactRootIndex
=
__webpack_require__
(
146
)
;
var
SimpleEventPlugin
=
__webpack_require__
(
147
)
;
var
SVGDOMPropertyConfig
=
__webpack_require__
(
156
)
;
var
alreadyInjected
=
false
;
function
inject
(
)
{
if
(
alreadyInjected
)
{
return
;
}
alreadyInjected
=
true
;
ReactInjection
.
EventEmitter
.
injectReactEventListener
(
ReactEventListener
)
;
ReactInjection
.
EventPluginHub
.
injectEventPluginOrder
(
DefaultEventPluginOrder
)
;
ReactInjection
.
EventPluginHub
.
injectInstanceHandle
(
ReactInstanceHandles
)
;
ReactInjection
.
EventPluginHub
.
injectMount
(
ReactMount
)
;
ReactInjection
.
EventPluginHub
.
injectEventPluginsByName
(
{
SimpleEventPlugin
:
SimpleEventPlugin
EnterLeaveEventPlugin
:
EnterLeaveEventPlugin
ChangeEventPlugin
:
ChangeEventPlugin
SelectEventPlugin
:
SelectEventPlugin
BeforeInputEventPlugin
:
BeforeInputEventPlugin
}
)
;
ReactInjection
.
NativeComponent
.
injectGenericComponentClass
(
ReactDOMComponent
)
;
ReactInjection
.
NativeComponent
.
injectTextComponentClass
(
ReactDOMTextComponent
)
;
ReactInjection
.
Class
.
injectMixin
(
ReactBrowserComponentMixin
)
;
ReactInjection
.
DOMProperty
.
injectDOMPropertyConfig
(
HTMLDOMPropertyConfig
)
;
ReactInjection
.
DOMProperty
.
injectDOMPropertyConfig
(
SVGDOMPropertyConfig
)
;
ReactInjection
.
EmptyComponent
.
injectEmptyComponent
(
'
noscript
'
)
;
ReactInjection
.
Updates
.
injectReconcileTransaction
(
ReactReconcileTransaction
)
;
ReactInjection
.
Updates
.
injectBatchingStrategy
(
ReactDefaultBatchingStrategy
)
;
ReactInjection
.
RootIndex
.
injectCreateReactRootIndex
(
ExecutionEnvironment
.
canUseDOM
?
ClientReactRootIndex
.
createReactRootIndex
:
ServerReactRootIndex
.
createReactRootIndex
)
;
ReactInjection
.
Component
.
injectEnvironment
(
ReactComponentBrowserEnvironment
)
;
if
(
false
)
{
var
url
=
ExecutionEnvironment
.
canUseDOM
&
&
window
.
location
.
href
|
|
'
'
;
if
(
/
[
?
&
]
react_perf
\
b
/
.
test
(
url
)
)
{
var
ReactDefaultPerf
=
require
(
'
.
/
ReactDefaultPerf
'
)
;
ReactDefaultPerf
.
start
(
)
;
}
}
}
module
.
exports
=
{
inject
:
inject
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
EventPropagators
=
__webpack_require__
(
88
)
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
FallbackCompositionState
=
__webpack_require__
(
89
)
;
var
SyntheticCompositionEvent
=
__webpack_require__
(
91
)
;
var
SyntheticInputEvent
=
__webpack_require__
(
93
)
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
END_KEYCODES
=
[
9
13
27
32
]
;
var
START_KEYCODE
=
229
;
var
canUseCompositionEvent
=
ExecutionEnvironment
.
canUseDOM
&
&
'
CompositionEvent
'
in
window
;
var
documentMode
=
null
;
if
(
ExecutionEnvironment
.
canUseDOM
&
&
'
documentMode
'
in
document
)
{
documentMode
=
document
.
documentMode
;
}
var
canUseTextInputEvent
=
ExecutionEnvironment
.
canUseDOM
&
&
'
TextEvent
'
in
window
&
&
!
documentMode
&
&
!
isPresto
(
)
;
var
useFallbackCompositionData
=
ExecutionEnvironment
.
canUseDOM
&
&
(
!
canUseCompositionEvent
|
|
documentMode
&
&
documentMode
>
8
&
&
documentMode
<
=
11
)
;
function
isPresto
(
)
{
var
opera
=
window
.
opera
;
return
typeof
opera
=
=
=
'
object
'
&
&
typeof
opera
.
version
=
=
=
'
function
'
&
&
parseInt
(
opera
.
version
(
)
10
)
<
=
12
;
}
var
SPACEBAR_CODE
=
32
;
var
SPACEBAR_CHAR
=
String
.
fromCharCode
(
SPACEBAR_CODE
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
eventTypes
=
{
beforeInput
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onBeforeInput
:
null
}
)
captured
:
keyOf
(
{
onBeforeInputCapture
:
null
}
)
}
dependencies
:
[
topLevelTypes
.
topCompositionEnd
topLevelTypes
.
topKeyPress
topLevelTypes
.
topTextInput
topLevelTypes
.
topPaste
]
}
compositionEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onCompositionEnd
:
null
}
)
captured
:
keyOf
(
{
onCompositionEndCapture
:
null
}
)
}
dependencies
:
[
topLevelTypes
.
topBlur
topLevelTypes
.
topCompositionEnd
topLevelTypes
.
topKeyDown
topLevelTypes
.
topKeyPress
topLevelTypes
.
topKeyUp
topLevelTypes
.
topMouseDown
]
}
compositionStart
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onCompositionStart
:
null
}
)
captured
:
keyOf
(
{
onCompositionStartCapture
:
null
}
)
}
dependencies
:
[
topLevelTypes
.
topBlur
topLevelTypes
.
topCompositionStart
topLevelTypes
.
topKeyDown
topLevelTypes
.
topKeyPress
topLevelTypes
.
topKeyUp
topLevelTypes
.
topMouseDown
]
}
compositionUpdate
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onCompositionUpdate
:
null
}
)
captured
:
keyOf
(
{
onCompositionUpdateCapture
:
null
}
)
}
dependencies
:
[
topLevelTypes
.
topBlur
topLevelTypes
.
topCompositionUpdate
topLevelTypes
.
topKeyDown
topLevelTypes
.
topKeyPress
topLevelTypes
.
topKeyUp
topLevelTypes
.
topMouseDown
]
}
}
;
var
hasSpaceKeypress
=
false
;
function
isKeypressCommand
(
nativeEvent
)
{
return
(
nativeEvent
.
ctrlKey
|
|
nativeEvent
.
altKey
|
|
nativeEvent
.
metaKey
)
&
&
!
(
nativeEvent
.
ctrlKey
&
&
nativeEvent
.
altKey
)
;
}
function
getCompositionEventType
(
topLevelType
)
{
switch
(
topLevelType
)
{
case
topLevelTypes
.
topCompositionStart
:
return
eventTypes
.
compositionStart
;
case
topLevelTypes
.
topCompositionEnd
:
return
eventTypes
.
compositionEnd
;
case
topLevelTypes
.
topCompositionUpdate
:
return
eventTypes
.
compositionUpdate
;
}
}
function
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
{
return
topLevelType
=
=
=
topLevelTypes
.
topKeyDown
&
&
nativeEvent
.
keyCode
=
=
=
START_KEYCODE
;
}
function
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
topLevelTypes
.
topKeyUp
:
return
END_KEYCODES
.
indexOf
(
nativeEvent
.
keyCode
)
!
=
=
-
1
;
case
topLevelTypes
.
topKeyDown
:
return
nativeEvent
.
keyCode
!
=
=
START_KEYCODE
;
case
topLevelTypes
.
topKeyPress
:
case
topLevelTypes
.
topMouseDown
:
case
topLevelTypes
.
topBlur
:
return
true
;
default
:
return
false
;
}
}
function
getDataFromCustomEvent
(
nativeEvent
)
{
var
detail
=
nativeEvent
.
detail
;
if
(
typeof
detail
=
=
=
'
object
'
&
&
'
data
'
in
detail
)
{
return
detail
.
data
;
}
return
null
;
}
var
currentComposition
=
null
;
function
extractCompositionEvent
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
var
eventType
;
var
fallbackData
;
if
(
canUseCompositionEvent
)
{
eventType
=
getCompositionEventType
(
topLevelType
)
;
}
else
if
(
!
currentComposition
)
{
if
(
isFallbackCompositionStart
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionStart
;
}
}
else
if
(
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
eventType
=
eventTypes
.
compositionEnd
;
}
if
(
!
eventType
)
{
return
null
;
}
if
(
useFallbackCompositionData
)
{
if
(
!
currentComposition
&
&
eventType
=
=
=
eventTypes
.
compositionStart
)
{
currentComposition
=
FallbackCompositionState
.
getPooled
(
topLevelTarget
)
;
}
else
if
(
eventType
=
=
=
eventTypes
.
compositionEnd
)
{
if
(
currentComposition
)
{
fallbackData
=
currentComposition
.
getData
(
)
;
}
}
}
var
event
=
SyntheticCompositionEvent
.
getPooled
(
eventType
topLevelTargetID
nativeEvent
nativeEventTarget
)
;
if
(
fallbackData
)
{
event
.
data
=
fallbackData
;
}
else
{
var
customData
=
getDataFromCustomEvent
(
nativeEvent
)
;
if
(
customData
!
=
=
null
)
{
event
.
data
=
customData
;
}
}
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
function
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
{
switch
(
topLevelType
)
{
case
topLevelTypes
.
topCompositionEnd
:
return
getDataFromCustomEvent
(
nativeEvent
)
;
case
topLevelTypes
.
topKeyPress
:
var
which
=
nativeEvent
.
which
;
if
(
which
!
=
=
SPACEBAR_CODE
)
{
return
null
;
}
hasSpaceKeypress
=
true
;
return
SPACEBAR_CHAR
;
case
topLevelTypes
.
topTextInput
:
var
chars
=
nativeEvent
.
data
;
if
(
chars
=
=
=
SPACEBAR_CHAR
&
&
hasSpaceKeypress
)
{
return
null
;
}
return
chars
;
default
:
return
null
;
}
}
function
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
{
if
(
currentComposition
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topCompositionEnd
|
|
isFallbackCompositionEnd
(
topLevelType
nativeEvent
)
)
{
var
chars
=
currentComposition
.
getData
(
)
;
FallbackCompositionState
.
release
(
currentComposition
)
;
currentComposition
=
null
;
return
chars
;
}
return
null
;
}
switch
(
topLevelType
)
{
case
topLevelTypes
.
topPaste
:
return
null
;
case
topLevelTypes
.
topKeyPress
:
if
(
nativeEvent
.
which
&
&
!
isKeypressCommand
(
nativeEvent
)
)
{
return
String
.
fromCharCode
(
nativeEvent
.
which
)
;
}
return
null
;
case
topLevelTypes
.
topCompositionEnd
:
return
useFallbackCompositionData
?
null
:
nativeEvent
.
data
;
default
:
return
null
;
}
}
function
extractBeforeInputEvent
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
var
chars
;
if
(
canUseTextInputEvent
)
{
chars
=
getNativeBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
else
{
chars
=
getFallbackBeforeInputChars
(
topLevelType
nativeEvent
)
;
}
if
(
!
chars
)
{
return
null
;
}
var
event
=
SyntheticInputEvent
.
getPooled
(
eventTypes
.
beforeInput
topLevelTargetID
nativeEvent
nativeEventTarget
)
;
event
.
data
=
chars
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
var
BeforeInputEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
return
[
extractCompositionEvent
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
extractBeforeInputEvent
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
]
;
}
}
;
module
.
exports
=
BeforeInputEventPlugin
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
EventPluginHub
=
__webpack_require__
(
46
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
accumulateInto
=
__webpack_require__
(
50
)
;
var
forEachAccumulated
=
__webpack_require__
(
51
)
;
var
PropagationPhases
=
EventConstants
.
PropagationPhases
;
var
getListener
=
EventPluginHub
.
getListener
;
function
listenerAtPhase
(
id
event
propagationPhase
)
{
var
registrationName
=
event
.
dispatchConfig
.
phasedRegistrationNames
[
propagationPhase
]
;
return
getListener
(
id
registrationName
)
;
}
function
accumulateDirectionalDispatches
(
domID
upwards
event
)
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
domID
'
Dispatching
id
must
not
be
null
'
)
:
undefined
;
}
var
phase
=
upwards
?
PropagationPhases
.
bubbled
:
PropagationPhases
.
captured
;
var
listener
=
listenerAtPhase
(
domID
event
phase
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchIDs
=
accumulateInto
(
event
.
_dispatchIDs
domID
)
;
}
}
function
accumulateTwoPhaseDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
EventPluginHub
.
injection
.
getInstanceHandle
(
)
.
traverseTwoPhase
(
event
.
dispatchMarker
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateTwoPhaseDispatchesSingleSkipTarget
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
phasedRegistrationNames
)
{
EventPluginHub
.
injection
.
getInstanceHandle
(
)
.
traverseTwoPhaseSkipTarget
(
event
.
dispatchMarker
accumulateDirectionalDispatches
event
)
;
}
}
function
accumulateDispatches
(
id
ignoredDirection
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
var
registrationName
=
event
.
dispatchConfig
.
registrationName
;
var
listener
=
getListener
(
id
registrationName
)
;
if
(
listener
)
{
event
.
_dispatchListeners
=
accumulateInto
(
event
.
_dispatchListeners
listener
)
;
event
.
_dispatchIDs
=
accumulateInto
(
event
.
_dispatchIDs
id
)
;
}
}
}
function
accumulateDirectDispatchesSingle
(
event
)
{
if
(
event
&
&
event
.
dispatchConfig
.
registrationName
)
{
accumulateDispatches
(
event
.
dispatchMarker
null
event
)
;
}
}
function
accumulateTwoPhaseDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingle
)
;
}
function
accumulateTwoPhaseDispatchesSkipTarget
(
events
)
{
forEachAccumulated
(
events
accumulateTwoPhaseDispatchesSingleSkipTarget
)
;
}
function
accumulateEnterLeaveDispatches
(
leave
enter
fromID
toID
)
{
EventPluginHub
.
injection
.
getInstanceHandle
(
)
.
traverseEnterLeave
(
fromID
toID
accumulateDispatches
leave
enter
)
;
}
function
accumulateDirectDispatches
(
events
)
{
forEachAccumulated
(
events
accumulateDirectDispatchesSingle
)
;
}
var
EventPropagators
=
{
accumulateTwoPhaseDispatches
:
accumulateTwoPhaseDispatches
accumulateTwoPhaseDispatchesSkipTarget
:
accumulateTwoPhaseDispatchesSkipTarget
accumulateDirectDispatches
:
accumulateDirectDispatches
accumulateEnterLeaveDispatches
:
accumulateEnterLeaveDispatches
}
;
module
.
exports
=
EventPropagators
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
getTextContentAccessor
=
__webpack_require__
(
90
)
;
function
FallbackCompositionState
(
root
)
{
this
.
_root
=
root
;
this
.
_startText
=
this
.
getText
(
)
;
this
.
_fallbackText
=
null
;
}
assign
(
FallbackCompositionState
.
prototype
{
destructor
:
function
(
)
{
this
.
_root
=
null
;
this
.
_startText
=
null
;
this
.
_fallbackText
=
null
;
}
getText
:
function
(
)
{
if
(
'
value
'
in
this
.
_root
)
{
return
this
.
_root
.
value
;
}
return
this
.
_root
[
getTextContentAccessor
(
)
]
;
}
getData
:
function
(
)
{
if
(
this
.
_fallbackText
)
{
return
this
.
_fallbackText
;
}
var
start
;
var
startValue
=
this
.
_startText
;
var
startLength
=
startValue
.
length
;
var
end
;
var
endValue
=
this
.
getText
(
)
;
var
endLength
=
endValue
.
length
;
for
(
start
=
0
;
start
<
startLength
;
start
+
+
)
{
if
(
startValue
[
start
]
!
=
=
endValue
[
start
]
)
{
break
;
}
}
var
minEnd
=
startLength
-
start
;
for
(
end
=
1
;
end
<
=
minEnd
;
end
+
+
)
{
if
(
startValue
[
startLength
-
end
]
!
=
=
endValue
[
endLength
-
end
]
)
{
break
;
}
}
var
sliceTail
=
end
>
1
?
1
-
end
:
undefined
;
this
.
_fallbackText
=
endValue
.
slice
(
start
sliceTail
)
;
return
this
.
_fallbackText
;
}
}
)
;
PooledClass
.
addPoolingTo
(
FallbackCompositionState
)
;
module
.
exports
=
FallbackCompositionState
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
contentKey
=
null
;
function
getTextContentAccessor
(
)
{
if
(
!
contentKey
&
&
ExecutionEnvironment
.
canUseDOM
)
{
contentKey
=
'
textContent
'
in
document
.
documentElement
?
'
textContent
'
:
'
innerText
'
;
}
return
contentKey
;
}
module
.
exports
=
getTextContentAccessor
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticEvent
=
__webpack_require__
(
92
)
;
var
CompositionEventInterface
=
{
data
:
null
}
;
function
SyntheticCompositionEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticCompositionEvent
CompositionEventInterface
)
;
module
.
exports
=
SyntheticCompositionEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
EventInterface
=
{
type
:
null
target
:
null
currentTarget
:
emptyFunction
.
thatReturnsNull
eventPhase
:
null
bubbles
:
null
cancelable
:
null
timeStamp
:
function
(
event
)
{
return
event
.
timeStamp
|
|
Date
.
now
(
)
;
}
defaultPrevented
:
null
isTrusted
:
null
}
;
function
SyntheticEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
this
.
dispatchConfig
=
dispatchConfig
;
this
.
dispatchMarker
=
dispatchMarker
;
this
.
nativeEvent
=
nativeEvent
;
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
if
(
!
Interface
.
hasOwnProperty
(
propName
)
)
{
continue
;
}
var
normalize
=
Interface
[
propName
]
;
if
(
normalize
)
{
this
[
propName
]
=
normalize
(
nativeEvent
)
;
}
else
{
if
(
propName
=
=
=
'
target
'
)
{
this
.
target
=
nativeEventTarget
;
}
else
{
this
[
propName
]
=
nativeEvent
[
propName
]
;
}
}
}
var
defaultPrevented
=
nativeEvent
.
defaultPrevented
!
=
null
?
nativeEvent
.
defaultPrevented
:
nativeEvent
.
returnValue
=
=
=
false
;
if
(
defaultPrevented
)
{
this
.
isDefaultPrevented
=
emptyFunction
.
thatReturnsTrue
;
}
else
{
this
.
isDefaultPrevented
=
emptyFunction
.
thatReturnsFalse
;
}
this
.
isPropagationStopped
=
emptyFunction
.
thatReturnsFalse
;
}
assign
(
SyntheticEvent
.
prototype
{
preventDefault
:
function
(
)
{
this
.
defaultPrevented
=
true
;
var
event
=
this
.
nativeEvent
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
event
'
This
synthetic
event
is
reused
for
performance
reasons
.
If
you
\
'
re
'
+
'
seeing
this
you
\
'
re
calling
preventDefault
on
a
'
+
'
released
/
nullified
synthetic
event
.
This
is
a
no
-
op
.
See
'
+
'
https
:
/
/
fb
.
me
/
react
-
event
-
pooling
for
more
information
.
'
)
:
undefined
;
}
if
(
!
event
)
{
return
;
}
if
(
event
.
preventDefault
)
{
event
.
preventDefault
(
)
;
}
else
{
event
.
returnValue
=
false
;
}
this
.
isDefaultPrevented
=
emptyFunction
.
thatReturnsTrue
;
}
stopPropagation
:
function
(
)
{
var
event
=
this
.
nativeEvent
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
event
'
This
synthetic
event
is
reused
for
performance
reasons
.
If
you
\
'
re
'
+
'
seeing
this
you
\
'
re
calling
stopPropagation
on
a
'
+
'
released
/
nullified
synthetic
event
.
This
is
a
no
-
op
.
See
'
+
'
https
:
/
/
fb
.
me
/
react
-
event
-
pooling
for
more
information
.
'
)
:
undefined
;
}
if
(
!
event
)
{
return
;
}
if
(
event
.
stopPropagation
)
{
event
.
stopPropagation
(
)
;
}
else
{
event
.
cancelBubble
=
true
;
}
this
.
isPropagationStopped
=
emptyFunction
.
thatReturnsTrue
;
}
persist
:
function
(
)
{
this
.
isPersistent
=
emptyFunction
.
thatReturnsTrue
;
}
isPersistent
:
emptyFunction
.
thatReturnsFalse
destructor
:
function
(
)
{
var
Interface
=
this
.
constructor
.
Interface
;
for
(
var
propName
in
Interface
)
{
this
[
propName
]
=
null
;
}
this
.
dispatchConfig
=
null
;
this
.
dispatchMarker
=
null
;
this
.
nativeEvent
=
null
;
}
}
)
;
SyntheticEvent
.
Interface
=
EventInterface
;
SyntheticEvent
.
augmentClass
=
function
(
Class
Interface
)
{
var
Super
=
this
;
var
prototype
=
Object
.
create
(
Super
.
prototype
)
;
assign
(
prototype
Class
.
prototype
)
;
Class
.
prototype
=
prototype
;
Class
.
prototype
.
constructor
=
Class
;
Class
.
Interface
=
assign
(
{
}
Super
.
Interface
Interface
)
;
Class
.
augmentClass
=
Super
.
augmentClass
;
PooledClass
.
addPoolingTo
(
Class
PooledClass
.
fourArgumentPooler
)
;
}
;
PooledClass
.
addPoolingTo
(
SyntheticEvent
PooledClass
.
fourArgumentPooler
)
;
module
.
exports
=
SyntheticEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticEvent
=
__webpack_require__
(
92
)
;
var
InputEventInterface
=
{
data
:
null
}
;
function
SyntheticInputEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticInputEvent
InputEventInterface
)
;
module
.
exports
=
SyntheticInputEvent
;
}
function
(
module
exports
)
{
"
use
strict
"
;
var
keyOf
=
function
(
oneKeyObj
)
{
var
key
;
for
(
key
in
oneKeyObj
)
{
if
(
!
oneKeyObj
.
hasOwnProperty
(
key
)
)
{
continue
;
}
return
key
;
}
return
null
;
}
;
module
.
exports
=
keyOf
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
EventPluginHub
=
__webpack_require__
(
46
)
;
var
EventPropagators
=
__webpack_require__
(
88
)
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
SyntheticEvent
=
__webpack_require__
(
92
)
;
var
getEventTarget
=
__webpack_require__
(
96
)
;
var
isEventSupported
=
__webpack_require__
(
55
)
;
var
isTextInputElement
=
__webpack_require__
(
97
)
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
eventTypes
=
{
change
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onChange
:
null
}
)
captured
:
keyOf
(
{
onChangeCapture
:
null
}
)
}
dependencies
:
[
topLevelTypes
.
topBlur
topLevelTypes
.
topChange
topLevelTypes
.
topClick
topLevelTypes
.
topFocus
topLevelTypes
.
topInput
topLevelTypes
.
topKeyDown
topLevelTypes
.
topKeyUp
topLevelTypes
.
topSelectionChange
]
}
}
;
var
activeElement
=
null
;
var
activeElementID
=
null
;
var
activeElementValue
=
null
;
var
activeElementValueProp
=
null
;
function
shouldUseChangeEvent
(
elem
)
{
var
nodeName
=
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
=
=
=
'
select
'
|
|
nodeName
=
=
=
'
input
'
&
&
elem
.
type
=
=
=
'
file
'
;
}
var
doesChangeEventBubble
=
false
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
doesChangeEventBubble
=
isEventSupported
(
'
change
'
)
&
&
(
!
(
'
documentMode
'
in
document
)
|
|
document
.
documentMode
>
8
)
;
}
function
manualDispatchChangeEvent
(
nativeEvent
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
.
change
activeElementID
nativeEvent
getEventTarget
(
nativeEvent
)
)
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
ReactUpdates
.
batchedUpdates
(
runEventInBatch
event
)
;
}
function
runEventInBatch
(
event
)
{
EventPluginHub
.
enqueueEvents
(
event
)
;
EventPluginHub
.
processEventQueue
(
false
)
;
}
function
startWatchingForChangeEventIE8
(
target
targetID
)
{
activeElement
=
target
;
activeElementID
=
targetID
;
activeElement
.
attachEvent
(
'
onchange
'
manualDispatchChangeEvent
)
;
}
function
stopWatchingForChangeEventIE8
(
)
{
if
(
!
activeElement
)
{
return
;
}
activeElement
.
detachEvent
(
'
onchange
'
manualDispatchChangeEvent
)
;
activeElement
=
null
;
activeElementID
=
null
;
}
function
getTargetIDForChangeEvent
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topChange
)
{
return
topLevelTargetID
;
}
}
function
handleEventsForChangeEventIE8
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topFocus
)
{
stopWatchingForChangeEventIE8
(
)
;
startWatchingForChangeEventIE8
(
topLevelTarget
topLevelTargetID
)
;
}
else
if
(
topLevelType
=
=
=
topLevelTypes
.
topBlur
)
{
stopWatchingForChangeEventIE8
(
)
;
}
}
var
isInputEventSupported
=
false
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
isInputEventSupported
=
isEventSupported
(
'
input
'
)
&
&
(
!
(
'
documentMode
'
in
document
)
|
|
document
.
documentMode
>
9
)
;
}
var
newValueProp
=
{
get
:
function
(
)
{
return
activeElementValueProp
.
get
.
call
(
this
)
;
}
set
:
function
(
val
)
{
activeElementValue
=
'
'
+
val
;
activeElementValueProp
.
set
.
call
(
this
val
)
;
}
}
;
function
startWatchingForValueChange
(
target
targetID
)
{
activeElement
=
target
;
activeElementID
=
targetID
;
activeElementValue
=
target
.
value
;
activeElementValueProp
=
Object
.
getOwnPropertyDescriptor
(
target
.
constructor
.
prototype
'
value
'
)
;
Object
.
defineProperty
(
activeElement
'
value
'
newValueProp
)
;
activeElement
.
attachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
}
function
stopWatchingForValueChange
(
)
{
if
(
!
activeElement
)
{
return
;
}
delete
activeElement
.
value
;
activeElement
.
detachEvent
(
'
onpropertychange
'
handlePropertyChange
)
;
activeElement
=
null
;
activeElementID
=
null
;
activeElementValue
=
null
;
activeElementValueProp
=
null
;
}
function
handlePropertyChange
(
nativeEvent
)
{
if
(
nativeEvent
.
propertyName
!
=
=
'
value
'
)
{
return
;
}
var
value
=
nativeEvent
.
srcElement
.
value
;
if
(
value
=
=
=
activeElementValue
)
{
return
;
}
activeElementValue
=
value
;
manualDispatchChangeEvent
(
nativeEvent
)
;
}
function
getTargetIDForInputEvent
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topInput
)
{
return
topLevelTargetID
;
}
}
function
handleEventsForInputEventIE
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topFocus
)
{
stopWatchingForValueChange
(
)
;
startWatchingForValueChange
(
topLevelTarget
topLevelTargetID
)
;
}
else
if
(
topLevelType
=
=
=
topLevelTypes
.
topBlur
)
{
stopWatchingForValueChange
(
)
;
}
}
function
getTargetIDForInputEventIE
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topSelectionChange
|
|
topLevelType
=
=
=
topLevelTypes
.
topKeyUp
|
|
topLevelType
=
=
=
topLevelTypes
.
topKeyDown
)
{
if
(
activeElement
&
&
activeElement
.
value
!
=
=
activeElementValue
)
{
activeElementValue
=
activeElement
.
value
;
return
activeElementID
;
}
}
}
function
shouldUseClickEvent
(
elem
)
{
return
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
&
&
(
elem
.
type
=
=
=
'
checkbox
'
|
|
elem
.
type
=
=
=
'
radio
'
)
;
}
function
getTargetIDForClickEvent
(
topLevelType
topLevelTarget
topLevelTargetID
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topClick
)
{
return
topLevelTargetID
;
}
}
var
ChangeEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
var
getTargetIDFunc
handleEventFunc
;
if
(
shouldUseChangeEvent
(
topLevelTarget
)
)
{
if
(
doesChangeEventBubble
)
{
getTargetIDFunc
=
getTargetIDForChangeEvent
;
}
else
{
handleEventFunc
=
handleEventsForChangeEventIE8
;
}
}
else
if
(
isTextInputElement
(
topLevelTarget
)
)
{
if
(
isInputEventSupported
)
{
getTargetIDFunc
=
getTargetIDForInputEvent
;
}
else
{
getTargetIDFunc
=
getTargetIDForInputEventIE
;
handleEventFunc
=
handleEventsForInputEventIE
;
}
}
else
if
(
shouldUseClickEvent
(
topLevelTarget
)
)
{
getTargetIDFunc
=
getTargetIDForClickEvent
;
}
if
(
getTargetIDFunc
)
{
var
targetID
=
getTargetIDFunc
(
topLevelType
topLevelTarget
topLevelTargetID
)
;
if
(
targetID
)
{
var
event
=
SyntheticEvent
.
getPooled
(
eventTypes
.
change
targetID
nativeEvent
nativeEventTarget
)
;
event
.
type
=
'
change
'
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
}
if
(
handleEventFunc
)
{
handleEventFunc
(
topLevelType
topLevelTarget
topLevelTargetID
)
;
}
}
}
;
module
.
exports
=
ChangeEventPlugin
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
getEventTarget
(
nativeEvent
)
{
var
target
=
nativeEvent
.
target
|
|
nativeEvent
.
srcElement
|
|
window
;
return
target
.
nodeType
=
=
=
3
?
target
.
parentNode
:
target
;
}
module
.
exports
=
getEventTarget
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
supportedInputTypes
=
{
'
color
'
:
true
'
date
'
:
true
'
datetime
'
:
true
'
datetime
-
local
'
:
true
'
email
'
:
true
'
month
'
:
true
'
number
'
:
true
'
password
'
:
true
'
range
'
:
true
'
search
'
:
true
'
tel
'
:
true
'
text
'
:
true
'
time
'
:
true
'
url
'
:
true
'
week
'
:
true
}
;
function
isTextInputElement
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
&
&
(
nodeName
=
=
=
'
input
'
&
&
supportedInputTypes
[
elem
.
type
]
|
|
nodeName
=
=
=
'
textarea
'
)
;
}
module
.
exports
=
isTextInputElement
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
nextReactRootIndex
=
0
;
var
ClientReactRootIndex
=
{
createReactRootIndex
:
function
(
)
{
return
nextReactRootIndex
+
+
;
}
}
;
module
.
exports
=
ClientReactRootIndex
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
DefaultEventPluginOrder
=
[
keyOf
(
{
ResponderEventPlugin
:
null
}
)
keyOf
(
{
SimpleEventPlugin
:
null
}
)
keyOf
(
{
TapEventPlugin
:
null
}
)
keyOf
(
{
EnterLeaveEventPlugin
:
null
}
)
keyOf
(
{
ChangeEventPlugin
:
null
}
)
keyOf
(
{
SelectEventPlugin
:
null
}
)
keyOf
(
{
BeforeInputEventPlugin
:
null
}
)
]
;
module
.
exports
=
DefaultEventPluginOrder
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
EventPropagators
=
__webpack_require__
(
88
)
;
var
SyntheticMouseEvent
=
__webpack_require__
(
101
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
getFirstReactDOM
=
ReactMount
.
getFirstReactDOM
;
var
eventTypes
=
{
mouseEnter
:
{
registrationName
:
keyOf
(
{
onMouseEnter
:
null
}
)
dependencies
:
[
topLevelTypes
.
topMouseOut
topLevelTypes
.
topMouseOver
]
}
mouseLeave
:
{
registrationName
:
keyOf
(
{
onMouseLeave
:
null
}
)
dependencies
:
[
topLevelTypes
.
topMouseOut
topLevelTypes
.
topMouseOver
]
}
}
;
var
extractedEvents
=
[
null
null
]
;
var
EnterLeaveEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
if
(
topLevelType
=
=
=
topLevelTypes
.
topMouseOver
&
&
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
fromElement
)
)
{
return
null
;
}
if
(
topLevelType
!
=
=
topLevelTypes
.
topMouseOut
&
&
topLevelType
!
=
=
topLevelTypes
.
topMouseOver
)
{
return
null
;
}
var
win
;
if
(
topLevelTarget
.
window
=
=
=
topLevelTarget
)
{
win
=
topLevelTarget
;
}
else
{
var
doc
=
topLevelTarget
.
ownerDocument
;
if
(
doc
)
{
win
=
doc
.
defaultView
|
|
doc
.
parentWindow
;
}
else
{
win
=
window
;
}
}
var
from
;
var
to
;
var
fromID
=
'
'
;
var
toID
=
'
'
;
if
(
topLevelType
=
=
=
topLevelTypes
.
topMouseOut
)
{
from
=
topLevelTarget
;
fromID
=
topLevelTargetID
;
to
=
getFirstReactDOM
(
nativeEvent
.
relatedTarget
|
|
nativeEvent
.
toElement
)
;
if
(
to
)
{
toID
=
ReactMount
.
getID
(
to
)
;
}
else
{
to
=
win
;
}
to
=
to
|
|
win
;
}
else
{
from
=
win
;
to
=
topLevelTarget
;
toID
=
topLevelTargetID
;
}
if
(
from
=
=
=
to
)
{
return
null
;
}
var
leave
=
SyntheticMouseEvent
.
getPooled
(
eventTypes
.
mouseLeave
fromID
nativeEvent
nativeEventTarget
)
;
leave
.
type
=
'
mouseleave
'
;
leave
.
target
=
from
;
leave
.
relatedTarget
=
to
;
var
enter
=
SyntheticMouseEvent
.
getPooled
(
eventTypes
.
mouseEnter
toID
nativeEvent
nativeEventTarget
)
;
enter
.
type
=
'
mouseenter
'
;
enter
.
target
=
to
;
enter
.
relatedTarget
=
from
;
EventPropagators
.
accumulateEnterLeaveDispatches
(
leave
enter
fromID
toID
)
;
extractedEvents
[
0
]
=
leave
;
extractedEvents
[
1
]
=
enter
;
return
extractedEvents
;
}
}
;
module
.
exports
=
EnterLeaveEventPlugin
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticUIEvent
=
__webpack_require__
(
102
)
;
var
ViewportMetrics
=
__webpack_require__
(
53
)
;
var
getEventModifierState
=
__webpack_require__
(
103
)
;
var
MouseEventInterface
=
{
screenX
:
null
screenY
:
null
clientX
:
null
clientY
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
getModifierState
:
getEventModifierState
button
:
function
(
event
)
{
var
button
=
event
.
button
;
if
(
'
which
'
in
event
)
{
return
button
;
}
return
button
=
=
=
2
?
2
:
button
=
=
=
4
?
1
:
0
;
}
buttons
:
null
relatedTarget
:
function
(
event
)
{
return
event
.
relatedTarget
|
|
(
event
.
fromElement
=
=
=
event
.
srcElement
?
event
.
toElement
:
event
.
fromElement
)
;
}
pageX
:
function
(
event
)
{
return
'
pageX
'
in
event
?
event
.
pageX
:
event
.
clientX
+
ViewportMetrics
.
currentScrollLeft
;
}
pageY
:
function
(
event
)
{
return
'
pageY
'
in
event
?
event
.
pageY
:
event
.
clientY
+
ViewportMetrics
.
currentScrollTop
;
}
}
;
function
SyntheticMouseEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticMouseEvent
MouseEventInterface
)
;
module
.
exports
=
SyntheticMouseEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticEvent
=
__webpack_require__
(
92
)
;
var
getEventTarget
=
__webpack_require__
(
96
)
;
var
UIEventInterface
=
{
view
:
function
(
event
)
{
if
(
event
.
view
)
{
return
event
.
view
;
}
var
target
=
getEventTarget
(
event
)
;
if
(
target
!
=
null
&
&
target
.
window
=
=
=
target
)
{
return
target
;
}
var
doc
=
target
.
ownerDocument
;
if
(
doc
)
{
return
doc
.
defaultView
|
|
doc
.
parentWindow
;
}
else
{
return
window
;
}
}
detail
:
function
(
event
)
{
return
event
.
detail
|
|
0
;
}
}
;
function
SyntheticUIEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticUIEvent
UIEventInterface
)
;
module
.
exports
=
SyntheticUIEvent
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
modifierKeyToProp
=
{
'
Alt
'
:
'
altKey
'
'
Control
'
:
'
ctrlKey
'
'
Meta
'
:
'
metaKey
'
'
Shift
'
:
'
shiftKey
'
}
;
function
modifierStateGetter
(
keyArg
)
{
var
syntheticEvent
=
this
;
var
nativeEvent
=
syntheticEvent
.
nativeEvent
;
if
(
nativeEvent
.
getModifierState
)
{
return
nativeEvent
.
getModifierState
(
keyArg
)
;
}
var
keyProp
=
modifierKeyToProp
[
keyArg
]
;
return
keyProp
?
!
!
nativeEvent
[
keyProp
]
:
false
;
}
function
getEventModifierState
(
nativeEvent
)
{
return
modifierStateGetter
;
}
module
.
exports
=
getEventModifierState
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
DOMProperty
=
__webpack_require__
(
38
)
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
MUST_USE_ATTRIBUTE
=
DOMProperty
.
injection
.
MUST_USE_ATTRIBUTE
;
var
MUST_USE_PROPERTY
=
DOMProperty
.
injection
.
MUST_USE_PROPERTY
;
var
HAS_BOOLEAN_VALUE
=
DOMProperty
.
injection
.
HAS_BOOLEAN_VALUE
;
var
HAS_SIDE_EFFECTS
=
DOMProperty
.
injection
.
HAS_SIDE_EFFECTS
;
var
HAS_NUMERIC_VALUE
=
DOMProperty
.
injection
.
HAS_NUMERIC_VALUE
;
var
HAS_POSITIVE_NUMERIC_VALUE
=
DOMProperty
.
injection
.
HAS_POSITIVE_NUMERIC_VALUE
;
var
HAS_OVERLOADED_BOOLEAN_VALUE
=
DOMProperty
.
injection
.
HAS_OVERLOADED_BOOLEAN_VALUE
;
var
hasSVG
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
var
implementation
=
document
.
implementation
;
hasSVG
=
implementation
&
&
implementation
.
hasFeature
&
&
implementation
.
hasFeature
(
'
http
:
/
/
www
.
w3
.
org
/
TR
/
SVG11
/
feature
#
BasicStructure
'
'
1
.
1
'
)
;
}
var
HTMLDOMPropertyConfig
=
{
isCustomAttribute
:
RegExp
.
prototype
.
test
.
bind
(
/
^
(
data
|
aria
)
-
[
a
-
z_
]
[
a
-
z
\
d_
.
\
-
]
*
/
)
Properties
:
{
accept
:
null
acceptCharset
:
null
accessKey
:
null
action
:
null
allowFullScreen
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
allowTransparency
:
MUST_USE_ATTRIBUTE
alt
:
null
async
:
HAS_BOOLEAN_VALUE
autoComplete
:
null
autoPlay
:
HAS_BOOLEAN_VALUE
capture
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
cellPadding
:
null
cellSpacing
:
null
charSet
:
MUST_USE_ATTRIBUTE
challenge
:
MUST_USE_ATTRIBUTE
checked
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
classID
:
MUST_USE_ATTRIBUTE
className
:
hasSVG
?
MUST_USE_ATTRIBUTE
:
MUST_USE_PROPERTY
cols
:
MUST_USE_ATTRIBUTE
|
HAS_POSITIVE_NUMERIC_VALUE
colSpan
:
null
content
:
null
contentEditable
:
null
contextMenu
:
MUST_USE_ATTRIBUTE
controls
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
coords
:
null
crossOrigin
:
null
data
:
null
dateTime
:
MUST_USE_ATTRIBUTE
'
default
'
:
HAS_BOOLEAN_VALUE
defer
:
HAS_BOOLEAN_VALUE
dir
:
null
disabled
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
download
:
HAS_OVERLOADED_BOOLEAN_VALUE
draggable
:
null
encType
:
null
form
:
MUST_USE_ATTRIBUTE
formAction
:
MUST_USE_ATTRIBUTE
formEncType
:
MUST_USE_ATTRIBUTE
formMethod
:
MUST_USE_ATTRIBUTE
formNoValidate
:
HAS_BOOLEAN_VALUE
formTarget
:
MUST_USE_ATTRIBUTE
frameBorder
:
MUST_USE_ATTRIBUTE
headers
:
null
height
:
MUST_USE_ATTRIBUTE
hidden
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
high
:
null
href
:
null
hrefLang
:
null
htmlFor
:
null
httpEquiv
:
null
icon
:
null
id
:
MUST_USE_PROPERTY
inputMode
:
MUST_USE_ATTRIBUTE
integrity
:
null
is
:
MUST_USE_ATTRIBUTE
keyParams
:
MUST_USE_ATTRIBUTE
keyType
:
MUST_USE_ATTRIBUTE
kind
:
null
label
:
null
lang
:
null
list
:
MUST_USE_ATTRIBUTE
loop
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
low
:
null
manifest
:
MUST_USE_ATTRIBUTE
marginHeight
:
null
marginWidth
:
null
max
:
null
maxLength
:
MUST_USE_ATTRIBUTE
media
:
MUST_USE_ATTRIBUTE
mediaGroup
:
null
method
:
null
min
:
null
minLength
:
MUST_USE_ATTRIBUTE
multiple
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
muted
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
name
:
null
nonce
:
MUST_USE_ATTRIBUTE
noValidate
:
HAS_BOOLEAN_VALUE
open
:
HAS_BOOLEAN_VALUE
optimum
:
null
pattern
:
null
placeholder
:
null
poster
:
null
preload
:
null
radioGroup
:
null
readOnly
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
rel
:
null
required
:
HAS_BOOLEAN_VALUE
reversed
:
HAS_BOOLEAN_VALUE
role
:
MUST_USE_ATTRIBUTE
rows
:
MUST_USE_ATTRIBUTE
|
HAS_POSITIVE_NUMERIC_VALUE
rowSpan
:
null
sandbox
:
null
scope
:
null
scoped
:
HAS_BOOLEAN_VALUE
scrolling
:
null
seamless
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
selected
:
MUST_USE_PROPERTY
|
HAS_BOOLEAN_VALUE
shape
:
null
size
:
MUST_USE_ATTRIBUTE
|
HAS_POSITIVE_NUMERIC_VALUE
sizes
:
MUST_USE_ATTRIBUTE
span
:
HAS_POSITIVE_NUMERIC_VALUE
spellCheck
:
null
src
:
null
srcDoc
:
MUST_USE_PROPERTY
srcLang
:
null
srcSet
:
MUST_USE_ATTRIBUTE
start
:
HAS_NUMERIC_VALUE
step
:
null
style
:
null
summary
:
null
tabIndex
:
null
target
:
null
title
:
null
type
:
null
useMap
:
null
value
:
MUST_USE_PROPERTY
|
HAS_SIDE_EFFECTS
width
:
MUST_USE_ATTRIBUTE
wmode
:
MUST_USE_ATTRIBUTE
wrap
:
null
about
:
MUST_USE_ATTRIBUTE
datatype
:
MUST_USE_ATTRIBUTE
inlist
:
MUST_USE_ATTRIBUTE
prefix
:
MUST_USE_ATTRIBUTE
property
:
MUST_USE_ATTRIBUTE
resource
:
MUST_USE_ATTRIBUTE
'
typeof
'
:
MUST_USE_ATTRIBUTE
vocab
:
MUST_USE_ATTRIBUTE
autoCapitalize
:
MUST_USE_ATTRIBUTE
autoCorrect
:
MUST_USE_ATTRIBUTE
autoSave
:
null
color
:
null
itemProp
:
MUST_USE_ATTRIBUTE
itemScope
:
MUST_USE_ATTRIBUTE
|
HAS_BOOLEAN_VALUE
itemType
:
MUST_USE_ATTRIBUTE
itemID
:
MUST_USE_ATTRIBUTE
itemRef
:
MUST_USE_ATTRIBUTE
results
:
null
security
:
MUST_USE_ATTRIBUTE
unselectable
:
MUST_USE_ATTRIBUTE
}
DOMAttributeNames
:
{
acceptCharset
:
'
accept
-
charset
'
className
:
'
class
'
htmlFor
:
'
for
'
httpEquiv
:
'
http
-
equiv
'
}
DOMPropertyNames
:
{
autoComplete
:
'
autocomplete
'
autoFocus
:
'
autofocus
'
autoPlay
:
'
autoplay
'
autoSave
:
'
autosave
'
encType
:
'
encoding
'
hrefLang
:
'
hreflang
'
radioGroup
:
'
radiogroup
'
spellCheck
:
'
spellcheck
'
srcDoc
:
'
srcdoc
'
srcSet
:
'
srcset
'
}
}
;
module
.
exports
=
HTMLDOMPropertyConfig
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactInstanceMap
=
__webpack_require__
(
62
)
;
var
findDOMNode
=
__webpack_require__
(
106
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
didWarnKey
=
'
_getDOMNodeDidWarn
'
;
var
ReactBrowserComponentMixin
=
{
getDOMNode
:
function
(
)
{
false
?
warning
(
this
.
constructor
[
didWarnKey
]
'
%
s
.
getDOMNode
(
.
.
.
)
is
deprecated
.
Please
use
'
+
'
ReactDOM
.
findDOMNode
(
instance
)
instead
.
'
ReactInstanceMap
.
get
(
this
)
.
getName
(
)
|
|
this
.
tagName
|
|
'
Unknown
'
)
:
undefined
;
this
.
constructor
[
didWarnKey
]
=
true
;
return
findDOMNode
(
this
)
;
}
}
;
module
.
exports
=
ReactBrowserComponentMixin
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
ReactInstanceMap
=
__webpack_require__
(
62
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
findDOMNode
(
componentOrElement
)
{
if
(
false
)
{
var
owner
=
ReactCurrentOwner
.
current
;
if
(
owner
!
=
=
null
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
owner
.
_warnedAboutRefsInRender
'
%
s
is
accessing
getDOMNode
or
findDOMNode
inside
its
render
(
)
.
'
+
'
render
(
)
should
be
a
pure
function
of
props
and
state
.
It
should
'
+
'
never
access
something
that
requires
stale
data
from
the
previous
'
+
'
render
such
as
refs
.
Move
this
logic
to
componentDidMount
and
'
+
'
componentDidUpdate
instead
.
'
owner
.
getName
(
)
|
|
'
A
component
'
)
:
undefined
;
owner
.
_warnedAboutRefsInRender
=
true
;
}
}
if
(
componentOrElement
=
=
null
)
{
return
null
;
}
if
(
componentOrElement
.
nodeType
=
=
=
1
)
{
return
componentOrElement
;
}
if
(
ReactInstanceMap
.
has
(
componentOrElement
)
)
{
return
ReactMount
.
getNodeFromInstance
(
componentOrElement
)
;
}
!
(
componentOrElement
.
render
=
=
null
|
|
typeof
componentOrElement
.
render
!
=
=
'
function
'
)
?
false
?
invariant
(
false
'
findDOMNode
was
called
on
an
unmounted
component
.
'
)
:
invariant
(
false
)
:
undefined
;
true
?
false
?
invariant
(
false
'
Element
appears
to
be
neither
ReactComponent
nor
DOMNode
(
keys
:
%
s
)
'
Object
.
keys
(
componentOrElement
)
)
:
invariant
(
false
)
:
undefined
;
}
module
.
exports
=
findDOMNode
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
Transaction
=
__webpack_require__
(
72
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
RESET_BATCHED_UPDATES
=
{
initialize
:
emptyFunction
close
:
function
(
)
{
ReactDefaultBatchingStrategy
.
isBatchingUpdates
=
false
;
}
}
;
var
FLUSH_BATCHED_UPDATES
=
{
initialize
:
emptyFunction
close
:
ReactUpdates
.
flushBatchedUpdates
.
bind
(
ReactUpdates
)
}
;
var
TRANSACTION_WRAPPERS
=
[
FLUSH_BATCHED_UPDATES
RESET_BATCHED_UPDATES
]
;
function
ReactDefaultBatchingStrategyTransaction
(
)
{
this
.
reinitializeTransaction
(
)
;
}
assign
(
ReactDefaultBatchingStrategyTransaction
.
prototype
Transaction
.
Mixin
{
getTransactionWrappers
:
function
(
)
{
return
TRANSACTION_WRAPPERS
;
}
}
)
;
var
transaction
=
new
ReactDefaultBatchingStrategyTransaction
(
)
;
var
ReactDefaultBatchingStrategy
=
{
isBatchingUpdates
:
false
batchedUpdates
:
function
(
callback
a
b
c
d
e
)
{
var
alreadyBatchingUpdates
=
ReactDefaultBatchingStrategy
.
isBatchingUpdates
;
ReactDefaultBatchingStrategy
.
isBatchingUpdates
=
true
;
if
(
alreadyBatchingUpdates
)
{
callback
(
a
b
c
d
e
)
;
}
else
{
transaction
.
perform
(
callback
null
a
b
c
d
e
)
;
}
}
}
;
module
.
exports
=
ReactDefaultBatchingStrategy
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
AutoFocusUtils
=
__webpack_require__
(
109
)
;
var
CSSPropertyOperations
=
__webpack_require__
(
111
)
;
var
DOMProperty
=
__webpack_require__
(
38
)
;
var
DOMPropertyOperations
=
__webpack_require__
(
37
)
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
ReactBrowserEventEmitter
=
__webpack_require__
(
44
)
;
var
ReactComponentBrowserEnvironment
=
__webpack_require__
(
41
)
;
var
ReactDOMButton
=
__webpack_require__
(
119
)
;
var
ReactDOMInput
=
__webpack_require__
(
120
)
;
var
ReactDOMOption
=
__webpack_require__
(
124
)
;
var
ReactDOMSelect
=
__webpack_require__
(
127
)
;
var
ReactDOMTextarea
=
__webpack_require__
(
128
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactMultiChild
=
__webpack_require__
(
129
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
ReactUpdateQueue
=
__webpack_require__
(
68
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
canDefineProperty
=
__webpack_require__
(
58
)
;
var
escapeTextContentForBrowser
=
__webpack_require__
(
36
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
isEventSupported
=
__webpack_require__
(
55
)
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
setInnerHTML
=
__webpack_require__
(
34
)
;
var
setTextContent
=
__webpack_require__
(
35
)
;
var
shallowEqual
=
__webpack_require__
(
132
)
;
var
validateDOMNesting
=
__webpack_require__
(
85
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
deleteListener
=
ReactBrowserEventEmitter
.
deleteListener
;
var
listenTo
=
ReactBrowserEventEmitter
.
listenTo
;
var
registrationNameModules
=
ReactBrowserEventEmitter
.
registrationNameModules
;
var
CONTENT_TYPES
=
{
'
string
'
:
true
'
number
'
:
true
}
;
var
CHILDREN
=
keyOf
(
{
children
:
null
}
)
;
var
STYLE
=
keyOf
(
{
style
:
null
}
)
;
var
HTML
=
keyOf
(
{
__html
:
null
}
)
;
var
ELEMENT_NODE_TYPE
=
1
;
function
getDeclarationErrorAddendum
(
internalInstance
)
{
if
(
internalInstance
)
{
var
owner
=
internalInstance
.
_currentElement
.
_owner
|
|
null
;
if
(
owner
)
{
var
name
=
owner
.
getName
(
)
;
if
(
name
)
{
return
'
This
DOM
node
was
rendered
by
'
+
name
+
'
.
'
;
}
}
}
return
'
'
;
}
var
legacyPropsDescriptor
;
if
(
false
)
{
legacyPropsDescriptor
=
{
props
:
{
enumerable
:
false
get
:
function
(
)
{
var
component
=
this
.
_reactInternalComponent
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
ReactDOMComponent
:
Do
not
access
.
props
of
a
DOM
node
;
instead
'
+
'
recreate
the
props
as
render
did
originally
or
read
the
DOM
'
+
'
properties
/
attributes
directly
from
this
node
(
e
.
g
.
'
+
'
this
.
refs
.
box
.
className
)
.
%
s
'
getDeclarationErrorAddendum
(
component
)
)
:
undefined
;
return
component
.
_currentElement
.
props
;
}
}
}
;
}
function
legacyGetDOMNode
(
)
{
if
(
false
)
{
var
component
=
this
.
_reactInternalComponent
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
ReactDOMComponent
:
Do
not
access
.
getDOMNode
(
)
of
a
DOM
node
;
'
+
'
instead
use
the
node
directly
.
%
s
'
getDeclarationErrorAddendum
(
component
)
)
:
undefined
;
}
return
this
;
}
function
legacyIsMounted
(
)
{
var
component
=
this
.
_reactInternalComponent
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
ReactDOMComponent
:
Do
not
access
.
isMounted
(
)
of
a
DOM
node
.
%
s
'
getDeclarationErrorAddendum
(
component
)
)
:
undefined
;
}
return
!
!
component
;
}
function
legacySetStateEtc
(
)
{
if
(
false
)
{
var
component
=
this
.
_reactInternalComponent
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
ReactDOMComponent
:
Do
not
access
.
setState
(
)
.
replaceState
(
)
or
'
+
'
.
forceUpdate
(
)
of
a
DOM
node
.
This
is
a
no
-
op
.
%
s
'
getDeclarationErrorAddendum
(
component
)
)
:
undefined
;
}
}
function
legacySetProps
(
partialProps
callback
)
{
var
component
=
this
.
_reactInternalComponent
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
ReactDOMComponent
:
Do
not
access
.
setProps
(
)
of
a
DOM
node
.
'
+
'
Instead
call
ReactDOM
.
render
again
at
the
top
level
.
%
s
'
getDeclarationErrorAddendum
(
component
)
)
:
undefined
;
}
if
(
!
component
)
{
return
;
}
ReactUpdateQueue
.
enqueueSetPropsInternal
(
component
partialProps
)
;
if
(
callback
)
{
ReactUpdateQueue
.
enqueueCallbackInternal
(
component
callback
)
;
}
}
function
legacyReplaceProps
(
partialProps
callback
)
{
var
component
=
this
.
_reactInternalComponent
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
ReactDOMComponent
:
Do
not
access
.
replaceProps
(
)
of
a
DOM
node
.
'
+
'
Instead
call
ReactDOM
.
render
again
at
the
top
level
.
%
s
'
getDeclarationErrorAddendum
(
component
)
)
:
undefined
;
}
if
(
!
component
)
{
return
;
}
ReactUpdateQueue
.
enqueueReplacePropsInternal
(
component
partialProps
)
;
if
(
callback
)
{
ReactUpdateQueue
.
enqueueCallbackInternal
(
component
callback
)
;
}
}
function
friendlyStringify
(
obj
)
{
if
(
typeof
obj
=
=
=
'
object
'
)
{
if
(
Array
.
isArray
(
obj
)
)
{
return
'
[
'
+
obj
.
map
(
friendlyStringify
)
.
join
(
'
'
)
+
'
]
'
;
}
else
{
var
pairs
=
[
]
;
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
{
var
keyEscaped
=
/
^
[
a
-
z
_
]
[
\
w
_
]
*
/
i
.
test
(
key
)
?
key
:
JSON
.
stringify
(
key
)
;
pairs
.
push
(
keyEscaped
+
'
:
'
+
friendlyStringify
(
obj
[
key
]
)
)
;
}
}
return
'
{
'
+
pairs
.
join
(
'
'
)
+
'
}
'
;
}
}
else
if
(
typeof
obj
=
=
=
'
string
'
)
{
return
JSON
.
stringify
(
obj
)
;
}
else
if
(
typeof
obj
=
=
=
'
function
'
)
{
return
'
[
function
object
]
'
;
}
return
String
(
obj
)
;
}
var
styleMutationWarning
=
{
}
;
function
checkAndWarnForMutatedStyle
(
style1
style2
component
)
{
if
(
style1
=
=
null
|
|
style2
=
=
null
)
{
return
;
}
if
(
shallowEqual
(
style1
style2
)
)
{
return
;
}
var
componentName
=
component
.
_tag
;
var
owner
=
component
.
_currentElement
.
_owner
;
var
ownerName
;
if
(
owner
)
{
ownerName
=
owner
.
getName
(
)
;
}
var
hash
=
ownerName
+
'
|
'
+
componentName
;
if
(
styleMutationWarning
.
hasOwnProperty
(
hash
)
)
{
return
;
}
styleMutationWarning
[
hash
]
=
true
;
false
?
warning
(
false
'
%
s
was
passed
a
style
object
that
has
previously
been
mutated
.
'
+
'
Mutating
style
is
deprecated
.
Consider
cloning
it
beforehand
.
Check
'
+
'
the
render
%
s
.
Previous
style
:
%
s
.
Mutated
style
:
%
s
.
'
componentName
owner
?
'
of
'
+
ownerName
+
'
'
:
'
using
<
'
+
componentName
+
'
>
'
friendlyStringify
(
style1
)
friendlyStringify
(
style2
)
)
:
undefined
;
}
function
assertValidProps
(
component
props
)
{
if
(
!
props
)
{
return
;
}
if
(
false
)
{
if
(
voidElementTags
[
component
.
_tag
]
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
props
.
children
=
=
null
&
&
props
.
dangerouslySetInnerHTML
=
=
null
'
%
s
is
a
void
element
tag
and
must
not
have
children
or
'
+
'
use
props
.
dangerouslySetInnerHTML
.
%
s
'
component
.
_tag
component
.
_currentElement
.
_owner
?
'
Check
the
render
method
of
'
+
component
.
_currentElement
.
_owner
.
getName
(
)
+
'
.
'
:
'
'
)
:
undefined
;
}
}
if
(
props
.
dangerouslySetInnerHTML
!
=
null
)
{
!
(
props
.
children
=
=
null
)
?
false
?
invariant
(
false
'
Can
only
set
one
of
children
or
props
.
dangerouslySetInnerHTML
.
'
)
:
invariant
(
false
)
:
undefined
;
!
(
typeof
props
.
dangerouslySetInnerHTML
=
=
=
'
object
'
&
&
HTML
in
props
.
dangerouslySetInnerHTML
)
?
false
?
invariant
(
false
'
props
.
dangerouslySetInnerHTML
must
be
in
the
form
{
__html
:
.
.
.
}
.
'
+
'
Please
visit
https
:
/
/
fb
.
me
/
react
-
invariant
-
dangerously
-
set
-
inner
-
html
'
+
'
for
more
information
.
'
)
:
invariant
(
false
)
:
undefined
;
}
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
props
.
innerHTML
=
=
null
'
Directly
setting
property
innerHTML
is
not
permitted
.
'
+
'
For
more
information
lookup
documentation
on
dangerouslySetInnerHTML
.
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
props
.
contentEditable
|
|
props
.
children
=
=
null
'
A
component
is
contentEditable
and
contains
children
managed
by
'
+
'
React
.
It
is
now
your
responsibility
to
guarantee
that
none
of
'
+
'
those
nodes
are
unexpectedly
modified
or
duplicated
.
This
is
'
+
'
probably
not
intentional
.
'
)
:
undefined
;
}
!
(
props
.
style
=
=
null
|
|
typeof
props
.
style
=
=
=
'
object
'
)
?
false
?
invariant
(
false
'
The
style
prop
expects
a
mapping
from
style
properties
to
values
'
+
'
not
a
string
.
For
example
style
=
{
{
marginRight
:
spacing
+
\
'
em
\
'
}
}
when
'
+
'
using
JSX
.
%
s
'
getDeclarationErrorAddendum
(
component
)
)
:
invariant
(
false
)
:
undefined
;
}
function
enqueuePutListener
(
id
registrationName
listener
transaction
)
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
registrationName
!
=
=
'
onScroll
'
|
|
isEventSupported
(
'
scroll
'
true
)
'
This
browser
doesn
\
'
t
support
the
onScroll
event
'
)
:
undefined
;
}
var
container
=
ReactMount
.
findReactContainerForID
(
id
)
;
if
(
container
)
{
var
doc
=
container
.
nodeType
=
=
=
ELEMENT_NODE_TYPE
?
container
.
ownerDocument
:
container
;
listenTo
(
registrationName
doc
)
;
}
transaction
.
getReactMountReady
(
)
.
enqueue
(
putListener
{
id
:
id
registrationName
:
registrationName
listener
:
listener
}
)
;
}
function
putListener
(
)
{
var
listenerToPut
=
this
;
ReactBrowserEventEmitter
.
putListener
(
listenerToPut
.
id
listenerToPut
.
registrationName
listenerToPut
.
listener
)
;
}
var
mediaEvents
=
{
topAbort
:
'
abort
'
topCanPlay
:
'
canplay
'
topCanPlayThrough
:
'
canplaythrough
'
topDurationChange
:
'
durationchange
'
topEmptied
:
'
emptied
'
topEncrypted
:
'
encrypted
'
topEnded
:
'
ended
'
topError
:
'
error
'
topLoadedData
:
'
loadeddata
'
topLoadedMetadata
:
'
loadedmetadata
'
topLoadStart
:
'
loadstart
'
topPause
:
'
pause
'
topPlay
:
'
play
'
topPlaying
:
'
playing
'
topProgress
:
'
progress
'
topRateChange
:
'
ratechange
'
topSeeked
:
'
seeked
'
topSeeking
:
'
seeking
'
topStalled
:
'
stalled
'
topSuspend
:
'
suspend
'
topTimeUpdate
:
'
timeupdate
'
topVolumeChange
:
'
volumechange
'
topWaiting
:
'
waiting
'
}
;
function
trapBubbledEventsLocal
(
)
{
var
inst
=
this
;
!
inst
.
_rootNodeID
?
false
?
invariant
(
false
'
Must
be
mounted
to
trap
events
'
)
:
invariant
(
false
)
:
undefined
;
var
node
=
ReactMount
.
getNode
(
inst
.
_rootNodeID
)
;
!
node
?
false
?
invariant
(
false
'
trapBubbledEvent
(
.
.
.
)
:
Requires
node
to
be
rendered
.
'
)
:
invariant
(
false
)
:
undefined
;
switch
(
inst
.
_tag
)
{
case
'
iframe
'
:
inst
.
_wrapperState
.
listeners
=
[
ReactBrowserEventEmitter
.
trapBubbledEvent
(
EventConstants
.
topLevelTypes
.
topLoad
'
load
'
node
)
]
;
break
;
case
'
video
'
:
case
'
audio
'
:
inst
.
_wrapperState
.
listeners
=
[
]
;
for
(
var
event
in
mediaEvents
)
{
if
(
mediaEvents
.
hasOwnProperty
(
event
)
)
{
inst
.
_wrapperState
.
listeners
.
push
(
ReactBrowserEventEmitter
.
trapBubbledEvent
(
EventConstants
.
topLevelTypes
[
event
]
mediaEvents
[
event
]
node
)
)
;
}
}
break
;
case
'
img
'
:
inst
.
_wrapperState
.
listeners
=
[
ReactBrowserEventEmitter
.
trapBubbledEvent
(
EventConstants
.
topLevelTypes
.
topError
'
error
'
node
)
ReactBrowserEventEmitter
.
trapBubbledEvent
(
EventConstants
.
topLevelTypes
.
topLoad
'
load
'
node
)
]
;
break
;
case
'
form
'
:
inst
.
_wrapperState
.
listeners
=
[
ReactBrowserEventEmitter
.
trapBubbledEvent
(
EventConstants
.
topLevelTypes
.
topReset
'
reset
'
node
)
ReactBrowserEventEmitter
.
trapBubbledEvent
(
EventConstants
.
topLevelTypes
.
topSubmit
'
submit
'
node
)
]
;
break
;
}
}
function
mountReadyInputWrapper
(
)
{
ReactDOMInput
.
mountReadyWrapper
(
this
)
;
}
function
postUpdateSelectWrapper
(
)
{
ReactDOMSelect
.
postUpdateWrapper
(
this
)
;
}
var
omittedCloseTags
=
{
'
area
'
:
true
'
base
'
:
true
'
br
'
:
true
'
col
'
:
true
'
embed
'
:
true
'
hr
'
:
true
'
img
'
:
true
'
input
'
:
true
'
keygen
'
:
true
'
link
'
:
true
'
meta
'
:
true
'
param
'
:
true
'
source
'
:
true
'
track
'
:
true
'
wbr
'
:
true
}
;
var
newlineEatingTags
=
{
'
listing
'
:
true
'
pre
'
:
true
'
textarea
'
:
true
}
;
var
voidElementTags
=
assign
(
{
'
menuitem
'
:
true
}
omittedCloseTags
)
;
var
VALID_TAG_REGEX
=
/
^
[
a
-
zA
-
Z
]
[
a
-
zA
-
Z
:
_
\
.
\
-
\
d
]
*
/
;
var
validatedTagCache
=
{
}
;
var
hasOwnProperty
=
(
{
}
)
.
hasOwnProperty
;
function
validateDangerousTag
(
tag
)
{
if
(
!
hasOwnProperty
.
call
(
validatedTagCache
tag
)
)
{
!
VALID_TAG_REGEX
.
test
(
tag
)
?
false
?
invariant
(
false
'
Invalid
tag
:
%
s
'
tag
)
:
invariant
(
false
)
:
undefined
;
validatedTagCache
[
tag
]
=
true
;
}
}
function
processChildContextDev
(
context
inst
)
{
context
=
assign
(
{
}
context
)
;
var
info
=
context
[
validateDOMNesting
.
ancestorInfoContextKey
]
;
context
[
validateDOMNesting
.
ancestorInfoContextKey
]
=
validateDOMNesting
.
updatedAncestorInfo
(
info
inst
.
_tag
inst
)
;
return
context
;
}
function
isCustomComponent
(
tagName
props
)
{
return
tagName
.
indexOf
(
'
-
'
)
>
=
0
|
|
props
.
is
!
=
null
;
}
function
ReactDOMComponent
(
tag
)
{
validateDangerousTag
(
tag
)
;
this
.
_tag
=
tag
.
toLowerCase
(
)
;
this
.
_renderedChildren
=
null
;
this
.
_previousStyle
=
null
;
this
.
_previousStyleCopy
=
null
;
this
.
_rootNodeID
=
null
;
this
.
_wrapperState
=
null
;
this
.
_topLevelWrapper
=
null
;
this
.
_nodeWithLegacyProperties
=
null
;
if
(
false
)
{
this
.
_unprocessedContextDev
=
null
;
this
.
_processedContextDev
=
null
;
}
}
ReactDOMComponent
.
displayName
=
'
ReactDOMComponent
'
;
ReactDOMComponent
.
Mixin
=
{
construct
:
function
(
element
)
{
this
.
_currentElement
=
element
;
}
mountComponent
:
function
(
rootID
transaction
context
)
{
this
.
_rootNodeID
=
rootID
;
var
props
=
this
.
_currentElement
.
props
;
switch
(
this
.
_tag
)
{
case
'
iframe
'
:
case
'
img
'
:
case
'
form
'
:
case
'
video
'
:
case
'
audio
'
:
this
.
_wrapperState
=
{
listeners
:
null
}
;
transaction
.
getReactMountReady
(
)
.
enqueue
(
trapBubbledEventsLocal
this
)
;
break
;
case
'
button
'
:
props
=
ReactDOMButton
.
getNativeProps
(
this
props
context
)
;
break
;
case
'
input
'
:
ReactDOMInput
.
mountWrapper
(
this
props
context
)
;
props
=
ReactDOMInput
.
getNativeProps
(
this
props
context
)
;
break
;
case
'
option
'
:
ReactDOMOption
.
mountWrapper
(
this
props
context
)
;
props
=
ReactDOMOption
.
getNativeProps
(
this
props
context
)
;
break
;
case
'
select
'
:
ReactDOMSelect
.
mountWrapper
(
this
props
context
)
;
props
=
ReactDOMSelect
.
getNativeProps
(
this
props
context
)
;
context
=
ReactDOMSelect
.
processChildContext
(
this
props
context
)
;
break
;
case
'
textarea
'
:
ReactDOMTextarea
.
mountWrapper
(
this
props
context
)
;
props
=
ReactDOMTextarea
.
getNativeProps
(
this
props
context
)
;
break
;
}
assertValidProps
(
this
props
)
;
if
(
false
)
{
if
(
context
[
validateDOMNesting
.
ancestorInfoContextKey
]
)
{
validateDOMNesting
(
this
.
_tag
this
context
[
validateDOMNesting
.
ancestorInfoContextKey
]
)
;
}
}
if
(
false
)
{
this
.
_unprocessedContextDev
=
context
;
this
.
_processedContextDev
=
processChildContextDev
(
context
this
)
;
context
=
this
.
_processedContextDev
;
}
var
mountImage
;
if
(
transaction
.
useCreateElement
)
{
var
ownerDocument
=
context
[
ReactMount
.
ownerDocumentContextKey
]
;
var
el
=
ownerDocument
.
createElement
(
this
.
_currentElement
.
type
)
;
DOMPropertyOperations
.
setAttributeForID
(
el
this
.
_rootNodeID
)
;
ReactMount
.
getID
(
el
)
;
this
.
_updateDOMProperties
(
{
}
props
transaction
el
)
;
this
.
_createInitialChildren
(
transaction
props
context
el
)
;
mountImage
=
el
;
}
else
{
var
tagOpen
=
this
.
_createOpenTagMarkupAndPutListeners
(
transaction
props
)
;
var
tagContent
=
this
.
_createContentMarkup
(
transaction
props
context
)
;
if
(
!
tagContent
&
&
omittedCloseTags
[
this
.
_tag
]
)
{
mountImage
=
tagOpen
+
'
/
>
'
;
}
else
{
mountImage
=
tagOpen
+
'
>
'
+
tagContent
+
'
<
/
'
+
this
.
_currentElement
.
type
+
'
>
'
;
}
}
switch
(
this
.
_tag
)
{
case
'
input
'
:
transaction
.
getReactMountReady
(
)
.
enqueue
(
mountReadyInputWrapper
this
)
;
case
'
button
'
:
case
'
select
'
:
case
'
textarea
'
:
if
(
props
.
autoFocus
)
{
transaction
.
getReactMountReady
(
)
.
enqueue
(
AutoFocusUtils
.
focusDOMComponent
this
)
;
}
break
;
}
return
mountImage
;
}
_createOpenTagMarkupAndPutListeners
:
function
(
transaction
props
)
{
var
ret
=
'
<
'
+
this
.
_currentElement
.
type
;
for
(
var
propKey
in
props
)
{
if
(
!
props
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
var
propValue
=
props
[
propKey
]
;
if
(
propValue
=
=
null
)
{
continue
;
}
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
propValue
)
{
enqueuePutListener
(
this
.
_rootNodeID
propKey
propValue
transaction
)
;
}
}
else
{
if
(
propKey
=
=
=
STYLE
)
{
if
(
propValue
)
{
if
(
false
)
{
this
.
_previousStyle
=
propValue
;
}
propValue
=
this
.
_previousStyleCopy
=
assign
(
{
}
props
.
style
)
;
}
propValue
=
CSSPropertyOperations
.
createMarkupForStyles
(
propValue
)
;
}
var
markup
=
null
;
if
(
this
.
_tag
!
=
null
&
&
isCustomComponent
(
this
.
_tag
props
)
)
{
if
(
propKey
!
=
=
CHILDREN
)
{
markup
=
DOMPropertyOperations
.
createMarkupForCustomAttribute
(
propKey
propValue
)
;
}
}
else
{
markup
=
DOMPropertyOperations
.
createMarkupForProperty
(
propKey
propValue
)
;
}
if
(
markup
)
{
ret
+
=
'
'
+
markup
;
}
}
}
if
(
transaction
.
renderToStaticMarkup
)
{
return
ret
;
}
var
markupForID
=
DOMPropertyOperations
.
createMarkupForID
(
this
.
_rootNodeID
)
;
return
ret
+
'
'
+
markupForID
;
}
_createContentMarkup
:
function
(
transaction
props
context
)
{
var
ret
=
'
'
;
var
innerHTML
=
props
.
dangerouslySetInnerHTML
;
if
(
innerHTML
!
=
null
)
{
if
(
innerHTML
.
__html
!
=
null
)
{
ret
=
innerHTML
.
__html
;
}
}
else
{
var
contentToUse
=
CONTENT_TYPES
[
typeof
props
.
children
]
?
props
.
children
:
null
;
var
childrenToUse
=
contentToUse
!
=
null
?
null
:
props
.
children
;
if
(
contentToUse
!
=
null
)
{
ret
=
escapeTextContentForBrowser
(
contentToUse
)
;
}
else
if
(
childrenToUse
!
=
null
)
{
var
mountImages
=
this
.
mountChildren
(
childrenToUse
transaction
context
)
;
ret
=
mountImages
.
join
(
'
'
)
;
}
}
if
(
newlineEatingTags
[
this
.
_tag
]
&
&
ret
.
charAt
(
0
)
=
=
=
'
\
n
'
)
{
return
'
\
n
'
+
ret
;
}
else
{
return
ret
;
}
}
_createInitialChildren
:
function
(
transaction
props
context
el
)
{
var
innerHTML
=
props
.
dangerouslySetInnerHTML
;
if
(
innerHTML
!
=
null
)
{
if
(
innerHTML
.
__html
!
=
null
)
{
setInnerHTML
(
el
innerHTML
.
__html
)
;
}
}
else
{
var
contentToUse
=
CONTENT_TYPES
[
typeof
props
.
children
]
?
props
.
children
:
null
;
var
childrenToUse
=
contentToUse
!
=
null
?
null
:
props
.
children
;
if
(
contentToUse
!
=
null
)
{
setTextContent
(
el
contentToUse
)
;
}
else
if
(
childrenToUse
!
=
null
)
{
var
mountImages
=
this
.
mountChildren
(
childrenToUse
transaction
context
)
;
for
(
var
i
=
0
;
i
<
mountImages
.
length
;
i
+
+
)
{
el
.
appendChild
(
mountImages
[
i
]
)
;
}
}
}
}
receiveComponent
:
function
(
nextElement
transaction
context
)
{
var
prevElement
=
this
.
_currentElement
;
this
.
_currentElement
=
nextElement
;
this
.
updateComponent
(
transaction
prevElement
nextElement
context
)
;
}
updateComponent
:
function
(
transaction
prevElement
nextElement
context
)
{
var
lastProps
=
prevElement
.
props
;
var
nextProps
=
this
.
_currentElement
.
props
;
switch
(
this
.
_tag
)
{
case
'
button
'
:
lastProps
=
ReactDOMButton
.
getNativeProps
(
this
lastProps
)
;
nextProps
=
ReactDOMButton
.
getNativeProps
(
this
nextProps
)
;
break
;
case
'
input
'
:
ReactDOMInput
.
updateWrapper
(
this
)
;
lastProps
=
ReactDOMInput
.
getNativeProps
(
this
lastProps
)
;
nextProps
=
ReactDOMInput
.
getNativeProps
(
this
nextProps
)
;
break
;
case
'
option
'
:
lastProps
=
ReactDOMOption
.
getNativeProps
(
this
lastProps
)
;
nextProps
=
ReactDOMOption
.
getNativeProps
(
this
nextProps
)
;
break
;
case
'
select
'
:
lastProps
=
ReactDOMSelect
.
getNativeProps
(
this
lastProps
)
;
nextProps
=
ReactDOMSelect
.
getNativeProps
(
this
nextProps
)
;
break
;
case
'
textarea
'
:
ReactDOMTextarea
.
updateWrapper
(
this
)
;
lastProps
=
ReactDOMTextarea
.
getNativeProps
(
this
lastProps
)
;
nextProps
=
ReactDOMTextarea
.
getNativeProps
(
this
nextProps
)
;
break
;
}
if
(
false
)
{
if
(
this
.
_unprocessedContextDev
!
=
=
context
)
{
this
.
_unprocessedContextDev
=
context
;
this
.
_processedContextDev
=
processChildContextDev
(
context
this
)
;
}
context
=
this
.
_processedContextDev
;
}
assertValidProps
(
this
nextProps
)
;
this
.
_updateDOMProperties
(
lastProps
nextProps
transaction
null
)
;
this
.
_updateDOMChildren
(
lastProps
nextProps
transaction
context
)
;
if
(
!
canDefineProperty
&
&
this
.
_nodeWithLegacyProperties
)
{
this
.
_nodeWithLegacyProperties
.
props
=
nextProps
;
}
if
(
this
.
_tag
=
=
=
'
select
'
)
{
transaction
.
getReactMountReady
(
)
.
enqueue
(
postUpdateSelectWrapper
this
)
;
}
}
_updateDOMProperties
:
function
(
lastProps
nextProps
transaction
node
)
{
var
propKey
;
var
styleName
;
var
styleUpdates
;
for
(
propKey
in
lastProps
)
{
if
(
nextProps
.
hasOwnProperty
(
propKey
)
|
|
!
lastProps
.
hasOwnProperty
(
propKey
)
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
var
lastStyle
=
this
.
_previousStyleCopy
;
for
(
styleName
in
lastStyle
)
{
if
(
lastStyle
.
hasOwnProperty
(
styleName
)
)
{
styleUpdates
=
styleUpdates
|
|
{
}
;
styleUpdates
[
styleName
]
=
'
'
;
}
}
this
.
_previousStyleCopy
=
null
;
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
lastProps
[
propKey
]
)
{
deleteListener
(
this
.
_rootNodeID
propKey
)
;
}
}
else
if
(
DOMProperty
.
properties
[
propKey
]
|
|
DOMProperty
.
isCustomAttribute
(
propKey
)
)
{
if
(
!
node
)
{
node
=
ReactMount
.
getNode
(
this
.
_rootNodeID
)
;
}
DOMPropertyOperations
.
deleteValueForProperty
(
node
propKey
)
;
}
}
for
(
propKey
in
nextProps
)
{
var
nextProp
=
nextProps
[
propKey
]
;
var
lastProp
=
propKey
=
=
=
STYLE
?
this
.
_previousStyleCopy
:
lastProps
[
propKey
]
;
if
(
!
nextProps
.
hasOwnProperty
(
propKey
)
|
|
nextProp
=
=
=
lastProp
)
{
continue
;
}
if
(
propKey
=
=
=
STYLE
)
{
if
(
nextProp
)
{
if
(
false
)
{
checkAndWarnForMutatedStyle
(
this
.
_previousStyleCopy
this
.
_previousStyle
this
)
;
this
.
_previousStyle
=
nextProp
;
}
nextProp
=
this
.
_previousStyleCopy
=
assign
(
{
}
nextProp
)
;
}
else
{
this
.
_previousStyleCopy
=
null
;
}
if
(
lastProp
)
{
for
(
styleName
in
lastProp
)
{
if
(
lastProp
.
hasOwnProperty
(
styleName
)
&
&
(
!
nextProp
|
|
!
nextProp
.
hasOwnProperty
(
styleName
)
)
)
{
styleUpdates
=
styleUpdates
|
|
{
}
;
styleUpdates
[
styleName
]
=
'
'
;
}
}
for
(
styleName
in
nextProp
)
{
if
(
nextProp
.
hasOwnProperty
(
styleName
)
&
&
lastProp
[
styleName
]
!
=
=
nextProp
[
styleName
]
)
{
styleUpdates
=
styleUpdates
|
|
{
}
;
styleUpdates
[
styleName
]
=
nextProp
[
styleName
]
;
}
}
}
else
{
styleUpdates
=
nextProp
;
}
}
else
if
(
registrationNameModules
.
hasOwnProperty
(
propKey
)
)
{
if
(
nextProp
)
{
enqueuePutListener
(
this
.
_rootNodeID
propKey
nextProp
transaction
)
;
}
else
if
(
lastProp
)
{
deleteListener
(
this
.
_rootNodeID
propKey
)
;
}
}
else
if
(
isCustomComponent
(
this
.
_tag
nextProps
)
)
{
if
(
!
node
)
{
node
=
ReactMount
.
getNode
(
this
.
_rootNodeID
)
;
}
if
(
propKey
=
=
=
CHILDREN
)
{
nextProp
=
null
;
}
DOMPropertyOperations
.
setValueForAttribute
(
node
propKey
nextProp
)
;
}
else
if
(
DOMProperty
.
properties
[
propKey
]
|
|
DOMProperty
.
isCustomAttribute
(
propKey
)
)
{
if
(
!
node
)
{
node
=
ReactMount
.
getNode
(
this
.
_rootNodeID
)
;
}
if
(
nextProp
!
=
null
)
{
DOMPropertyOperations
.
setValueForProperty
(
node
propKey
nextProp
)
;
}
else
{
DOMPropertyOperations
.
deleteValueForProperty
(
node
propKey
)
;
}
}
}
if
(
styleUpdates
)
{
if
(
!
node
)
{
node
=
ReactMount
.
getNode
(
this
.
_rootNodeID
)
;
}
CSSPropertyOperations
.
setValueForStyles
(
node
styleUpdates
)
;
}
}
_updateDOMChildren
:
function
(
lastProps
nextProps
transaction
context
)
{
var
lastContent
=
CONTENT_TYPES
[
typeof
lastProps
.
children
]
?
lastProps
.
children
:
null
;
var
nextContent
=
CONTENT_TYPES
[
typeof
nextProps
.
children
]
?
nextProps
.
children
:
null
;
var
lastHtml
=
lastProps
.
dangerouslySetInnerHTML
&
&
lastProps
.
dangerouslySetInnerHTML
.
__html
;
var
nextHtml
=
nextProps
.
dangerouslySetInnerHTML
&
&
nextProps
.
dangerouslySetInnerHTML
.
__html
;
var
lastChildren
=
lastContent
!
=
null
?
null
:
lastProps
.
children
;
var
nextChildren
=
nextContent
!
=
null
?
null
:
nextProps
.
children
;
var
lastHasContentOrHtml
=
lastContent
!
=
null
|
|
lastHtml
!
=
null
;
var
nextHasContentOrHtml
=
nextContent
!
=
null
|
|
nextHtml
!
=
null
;
if
(
lastChildren
!
=
null
&
&
nextChildren
=
=
null
)
{
this
.
updateChildren
(
null
transaction
context
)
;
}
else
if
(
lastHasContentOrHtml
&
&
!
nextHasContentOrHtml
)
{
this
.
updateTextContent
(
'
'
)
;
}
if
(
nextContent
!
=
null
)
{
if
(
lastContent
!
=
=
nextContent
)
{
this
.
updateTextContent
(
'
'
+
nextContent
)
;
}
}
else
if
(
nextHtml
!
=
null
)
{
if
(
lastHtml
!
=
=
nextHtml
)
{
this
.
updateMarkup
(
'
'
+
nextHtml
)
;
}
}
else
if
(
nextChildren
!
=
null
)
{
this
.
updateChildren
(
nextChildren
transaction
context
)
;
}
}
unmountComponent
:
function
(
)
{
switch
(
this
.
_tag
)
{
case
'
iframe
'
:
case
'
img
'
:
case
'
form
'
:
case
'
video
'
:
case
'
audio
'
:
var
listeners
=
this
.
_wrapperState
.
listeners
;
if
(
listeners
)
{
for
(
var
i
=
0
;
i
<
listeners
.
length
;
i
+
+
)
{
listeners
[
i
]
.
remove
(
)
;
}
}
break
;
case
'
input
'
:
ReactDOMInput
.
unmountWrapper
(
this
)
;
break
;
case
'
html
'
:
case
'
head
'
:
case
'
body
'
:
true
?
false
?
invariant
(
false
'
<
%
s
>
tried
to
unmount
.
Because
of
cross
-
browser
quirks
it
is
'
+
'
impossible
to
unmount
some
top
-
level
components
(
eg
<
html
>
'
+
'
<
head
>
and
<
body
>
)
reliably
and
efficiently
.
To
fix
this
have
a
'
+
'
single
top
-
level
component
that
never
unmounts
render
these
'
+
'
elements
.
'
this
.
_tag
)
:
invariant
(
false
)
:
undefined
;
break
;
}
this
.
unmountChildren
(
)
;
ReactBrowserEventEmitter
.
deleteAllListeners
(
this
.
_rootNodeID
)
;
ReactComponentBrowserEnvironment
.
unmountIDFromEnvironment
(
this
.
_rootNodeID
)
;
this
.
_rootNodeID
=
null
;
this
.
_wrapperState
=
null
;
if
(
this
.
_nodeWithLegacyProperties
)
{
var
node
=
this
.
_nodeWithLegacyProperties
;
node
.
_reactInternalComponent
=
null
;
this
.
_nodeWithLegacyProperties
=
null
;
}
}
getPublicInstance
:
function
(
)
{
if
(
!
this
.
_nodeWithLegacyProperties
)
{
var
node
=
ReactMount
.
getNode
(
this
.
_rootNodeID
)
;
node
.
_reactInternalComponent
=
this
;
node
.
getDOMNode
=
legacyGetDOMNode
;
node
.
isMounted
=
legacyIsMounted
;
node
.
setState
=
legacySetStateEtc
;
node
.
replaceState
=
legacySetStateEtc
;
node
.
forceUpdate
=
legacySetStateEtc
;
node
.
setProps
=
legacySetProps
;
node
.
replaceProps
=
legacyReplaceProps
;
if
(
false
)
{
if
(
canDefineProperty
)
{
Object
.
defineProperties
(
node
legacyPropsDescriptor
)
;
}
else
{
node
.
props
=
this
.
_currentElement
.
props
;
}
}
else
{
node
.
props
=
this
.
_currentElement
.
props
;
}
this
.
_nodeWithLegacyProperties
=
node
;
}
return
this
.
_nodeWithLegacyProperties
;
}
}
;
ReactPerf
.
measureMethods
(
ReactDOMComponent
'
ReactDOMComponent
'
{
mountComponent
:
'
mountComponent
'
updateComponent
:
'
updateComponent
'
}
)
;
assign
(
ReactDOMComponent
.
prototype
ReactDOMComponent
.
Mixin
ReactMultiChild
.
Mixin
)
;
module
.
exports
=
ReactDOMComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
findDOMNode
=
__webpack_require__
(
106
)
;
var
focusNode
=
__webpack_require__
(
110
)
;
var
Mixin
=
{
componentDidMount
:
function
(
)
{
if
(
this
.
props
.
autoFocus
)
{
focusNode
(
findDOMNode
(
this
)
)
;
}
}
}
;
var
AutoFocusUtils
=
{
Mixin
:
Mixin
focusDOMComponent
:
function
(
)
{
focusNode
(
ReactMount
.
getNode
(
this
.
_rootNodeID
)
)
;
}
}
;
module
.
exports
=
AutoFocusUtils
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
focusNode
(
node
)
{
try
{
node
.
focus
(
)
;
}
catch
(
e
)
{
}
}
module
.
exports
=
focusNode
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
CSSProperty
=
__webpack_require__
(
112
)
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
camelizeStyleName
=
__webpack_require__
(
113
)
;
var
dangerousStyleValue
=
__webpack_require__
(
115
)
;
var
hyphenateStyleName
=
__webpack_require__
(
116
)
;
var
memoizeStringOnly
=
__webpack_require__
(
118
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
processStyleName
=
memoizeStringOnly
(
function
(
styleName
)
{
return
hyphenateStyleName
(
styleName
)
;
}
)
;
var
hasShorthandPropertyBug
=
false
;
var
styleFloatAccessor
=
'
cssFloat
'
;
if
(
ExecutionEnvironment
.
canUseDOM
)
{
var
tempStyle
=
document
.
createElement
(
'
div
'
)
.
style
;
try
{
tempStyle
.
font
=
'
'
;
}
catch
(
e
)
{
hasShorthandPropertyBug
=
true
;
}
if
(
document
.
documentElement
.
style
.
cssFloat
=
=
=
undefined
)
{
styleFloatAccessor
=
'
styleFloat
'
;
}
}
if
(
false
)
{
var
badVendoredStyleNamePattern
=
/
^
(
?
:
webkit
|
moz
|
o
)
[
A
-
Z
]
/
;
var
badStyleValueWithSemicolonPattern
=
/
;
\
s
*
/
;
var
warnedStyleNames
=
{
}
;
var
warnedStyleValues
=
{
}
;
var
warnHyphenatedStyleName
=
function
(
name
)
{
if
(
warnedStyleNames
.
hasOwnProperty
(
name
)
&
&
warnedStyleNames
[
name
]
)
{
return
;
}
warnedStyleNames
[
name
]
=
true
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
Unsupported
style
property
%
s
.
Did
you
mean
%
s
?
'
name
camelizeStyleName
(
name
)
)
:
undefined
;
}
;
var
warnBadVendoredStyleName
=
function
(
name
)
{
if
(
warnedStyleNames
.
hasOwnProperty
(
name
)
&
&
warnedStyleNames
[
name
]
)
{
return
;
}
warnedStyleNames
[
name
]
=
true
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
Unsupported
vendor
-
prefixed
style
property
%
s
.
Did
you
mean
%
s
?
'
name
name
.
charAt
(
0
)
.
toUpperCase
(
)
+
name
.
slice
(
1
)
)
:
undefined
;
}
;
var
warnStyleValueWithSemicolon
=
function
(
name
value
)
{
if
(
warnedStyleValues
.
hasOwnProperty
(
value
)
&
&
warnedStyleValues
[
value
]
)
{
return
;
}
warnedStyleValues
[
value
]
=
true
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
Style
property
values
shouldn
\
'
t
contain
a
semicolon
.
'
+
'
Try
"
%
s
:
%
s
"
instead
.
'
name
value
.
replace
(
badStyleValueWithSemicolonPattern
'
'
)
)
:
undefined
;
}
;
var
warnValidStyle
=
function
(
name
value
)
{
if
(
name
.
indexOf
(
'
-
'
)
>
-
1
)
{
warnHyphenatedStyleName
(
name
)
;
}
else
if
(
badVendoredStyleNamePattern
.
test
(
name
)
)
{
warnBadVendoredStyleName
(
name
)
;
}
else
if
(
badStyleValueWithSemicolonPattern
.
test
(
value
)
)
{
warnStyleValueWithSemicolon
(
name
value
)
;
}
}
;
}
var
CSSPropertyOperations
=
{
createMarkupForStyles
:
function
(
styles
)
{
var
serialized
=
'
'
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
var
styleValue
=
styles
[
styleName
]
;
if
(
false
)
{
warnValidStyle
(
styleName
styleValue
)
;
}
if
(
styleValue
!
=
null
)
{
serialized
+
=
processStyleName
(
styleName
)
+
'
:
'
;
serialized
+
=
dangerousStyleValue
(
styleName
styleValue
)
+
'
;
'
;
}
}
return
serialized
|
|
null
;
}
setValueForStyles
:
function
(
node
styles
)
{
var
style
=
node
.
style
;
for
(
var
styleName
in
styles
)
{
if
(
!
styles
.
hasOwnProperty
(
styleName
)
)
{
continue
;
}
if
(
false
)
{
warnValidStyle
(
styleName
styles
[
styleName
]
)
;
}
var
styleValue
=
dangerousStyleValue
(
styleName
styles
[
styleName
]
)
;
if
(
styleName
=
=
=
'
float
'
)
{
styleName
=
styleFloatAccessor
;
}
if
(
styleValue
)
{
style
[
styleName
]
=
styleValue
;
}
else
{
var
expansion
=
hasShorthandPropertyBug
&
&
CSSProperty
.
shorthandPropertyExpansions
[
styleName
]
;
if
(
expansion
)
{
for
(
var
individualStyleName
in
expansion
)
{
style
[
individualStyleName
]
=
'
'
;
}
}
else
{
style
[
styleName
]
=
'
'
;
}
}
}
}
}
;
ReactPerf
.
measureMethods
(
CSSPropertyOperations
'
CSSPropertyOperations
'
{
setValueForStyles
:
'
setValueForStyles
'
}
)
;
module
.
exports
=
CSSPropertyOperations
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
isUnitlessNumber
=
{
animationIterationCount
:
true
boxFlex
:
true
boxFlexGroup
:
true
boxOrdinalGroup
:
true
columnCount
:
true
flex
:
true
flexGrow
:
true
flexPositive
:
true
flexShrink
:
true
flexNegative
:
true
flexOrder
:
true
fontWeight
:
true
lineClamp
:
true
lineHeight
:
true
opacity
:
true
order
:
true
orphans
:
true
tabSize
:
true
widows
:
true
zIndex
:
true
zoom
:
true
fillOpacity
:
true
stopOpacity
:
true
strokeDashoffset
:
true
strokeOpacity
:
true
strokeWidth
:
true
}
;
function
prefixKey
(
prefix
key
)
{
return
prefix
+
key
.
charAt
(
0
)
.
toUpperCase
(
)
+
key
.
substring
(
1
)
;
}
var
prefixes
=
[
'
Webkit
'
'
ms
'
'
Moz
'
'
O
'
]
;
Object
.
keys
(
isUnitlessNumber
)
.
forEach
(
function
(
prop
)
{
prefixes
.
forEach
(
function
(
prefix
)
{
isUnitlessNumber
[
prefixKey
(
prefix
prop
)
]
=
isUnitlessNumber
[
prop
]
;
}
)
;
}
)
;
var
shorthandPropertyExpansions
=
{
background
:
{
backgroundAttachment
:
true
backgroundColor
:
true
backgroundImage
:
true
backgroundPositionX
:
true
backgroundPositionY
:
true
backgroundRepeat
:
true
}
backgroundPosition
:
{
backgroundPositionX
:
true
backgroundPositionY
:
true
}
border
:
{
borderWidth
:
true
borderStyle
:
true
borderColor
:
true
}
borderBottom
:
{
borderBottomWidth
:
true
borderBottomStyle
:
true
borderBottomColor
:
true
}
borderLeft
:
{
borderLeftWidth
:
true
borderLeftStyle
:
true
borderLeftColor
:
true
}
borderRight
:
{
borderRightWidth
:
true
borderRightStyle
:
true
borderRightColor
:
true
}
borderTop
:
{
borderTopWidth
:
true
borderTopStyle
:
true
borderTopColor
:
true
}
font
:
{
fontStyle
:
true
fontVariant
:
true
fontWeight
:
true
fontSize
:
true
lineHeight
:
true
fontFamily
:
true
}
outline
:
{
outlineWidth
:
true
outlineStyle
:
true
outlineColor
:
true
}
}
;
var
CSSProperty
=
{
isUnitlessNumber
:
isUnitlessNumber
shorthandPropertyExpansions
:
shorthandPropertyExpansions
}
;
module
.
exports
=
CSSProperty
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
camelize
=
__webpack_require__
(
114
)
;
var
msPattern
=
/
^
-
ms
-
/
;
function
camelizeStyleName
(
string
)
{
return
camelize
(
string
.
replace
(
msPattern
'
ms
-
'
)
)
;
}
module
.
exports
=
camelizeStyleName
;
}
function
(
module
exports
)
{
"
use
strict
"
;
var
_hyphenPattern
=
/
-
(
.
)
/
g
;
function
camelize
(
string
)
{
return
string
.
replace
(
_hyphenPattern
function
(
_
character
)
{
return
character
.
toUpperCase
(
)
;
}
)
;
}
module
.
exports
=
camelize
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
CSSProperty
=
__webpack_require__
(
112
)
;
var
isUnitlessNumber
=
CSSProperty
.
isUnitlessNumber
;
function
dangerousStyleValue
(
name
value
)
{
var
isEmpty
=
value
=
=
null
|
|
typeof
value
=
=
=
'
boolean
'
|
|
value
=
=
=
'
'
;
if
(
isEmpty
)
{
return
'
'
;
}
var
isNonNumeric
=
isNaN
(
value
)
;
if
(
isNonNumeric
|
|
value
=
=
=
0
|
|
isUnitlessNumber
.
hasOwnProperty
(
name
)
&
&
isUnitlessNumber
[
name
]
)
{
return
'
'
+
value
;
}
if
(
typeof
value
=
=
=
'
string
'
)
{
value
=
value
.
trim
(
)
;
}
return
value
+
'
px
'
;
}
module
.
exports
=
dangerousStyleValue
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
hyphenate
=
__webpack_require__
(
117
)
;
var
msPattern
=
/
^
ms
-
/
;
function
hyphenateStyleName
(
string
)
{
return
hyphenate
(
string
)
.
replace
(
msPattern
'
-
ms
-
'
)
;
}
module
.
exports
=
hyphenateStyleName
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
_uppercasePattern
=
/
(
[
A
-
Z
]
)
/
g
;
function
hyphenate
(
string
)
{
return
string
.
replace
(
_uppercasePattern
'
-
1
'
)
.
toLowerCase
(
)
;
}
module
.
exports
=
hyphenate
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
memoizeStringOnly
(
callback
)
{
var
cache
=
{
}
;
return
function
(
string
)
{
if
(
!
cache
.
hasOwnProperty
(
string
)
)
{
cache
[
string
]
=
callback
.
call
(
this
string
)
;
}
return
cache
[
string
]
;
}
;
}
module
.
exports
=
memoizeStringOnly
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
mouseListenerNames
=
{
onClick
:
true
onDoubleClick
:
true
onMouseDown
:
true
onMouseMove
:
true
onMouseUp
:
true
onClickCapture
:
true
onDoubleClickCapture
:
true
onMouseDownCapture
:
true
onMouseMoveCapture
:
true
onMouseUpCapture
:
true
}
;
var
ReactDOMButton
=
{
getNativeProps
:
function
(
inst
props
context
)
{
if
(
!
props
.
disabled
)
{
return
props
;
}
var
nativeProps
=
{
}
;
for
(
var
key
in
props
)
{
if
(
props
.
hasOwnProperty
(
key
)
&
&
!
mouseListenerNames
[
key
]
)
{
nativeProps
[
key
]
=
props
[
key
]
;
}
}
return
nativeProps
;
}
}
;
module
.
exports
=
ReactDOMButton
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactDOMIDOperations
=
__webpack_require__
(
42
)
;
var
LinkedValueUtils
=
__webpack_require__
(
121
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
instancesByReactID
=
{
}
;
function
forceUpdateIfMounted
(
)
{
if
(
this
.
_rootNodeID
)
{
ReactDOMInput
.
updateWrapper
(
this
)
;
}
}
var
ReactDOMInput
=
{
getNativeProps
:
function
(
inst
props
context
)
{
var
value
=
LinkedValueUtils
.
getValue
(
props
)
;
var
checked
=
LinkedValueUtils
.
getChecked
(
props
)
;
var
nativeProps
=
assign
(
{
}
props
{
defaultChecked
:
undefined
defaultValue
:
undefined
value
:
value
!
=
null
?
value
:
inst
.
_wrapperState
.
initialValue
checked
:
checked
!
=
null
?
checked
:
inst
.
_wrapperState
.
initialChecked
onChange
:
inst
.
_wrapperState
.
onChange
}
)
;
return
nativeProps
;
}
mountWrapper
:
function
(
inst
props
)
{
if
(
false
)
{
LinkedValueUtils
.
checkPropTypes
(
'
input
'
props
inst
.
_currentElement
.
_owner
)
;
}
var
defaultValue
=
props
.
defaultValue
;
inst
.
_wrapperState
=
{
initialChecked
:
props
.
defaultChecked
|
|
false
initialValue
:
defaultValue
!
=
null
?
defaultValue
:
null
onChange
:
_handleChange
.
bind
(
inst
)
}
;
}
mountReadyWrapper
:
function
(
inst
)
{
instancesByReactID
[
inst
.
_rootNodeID
]
=
inst
;
}
unmountWrapper
:
function
(
inst
)
{
delete
instancesByReactID
[
inst
.
_rootNodeID
]
;
}
updateWrapper
:
function
(
inst
)
{
var
props
=
inst
.
_currentElement
.
props
;
var
checked
=
props
.
checked
;
if
(
checked
!
=
null
)
{
ReactDOMIDOperations
.
updatePropertyByID
(
inst
.
_rootNodeID
'
checked
'
checked
|
|
false
)
;
}
var
value
=
LinkedValueUtils
.
getValue
(
props
)
;
if
(
value
!
=
null
)
{
ReactDOMIDOperations
.
updatePropertyByID
(
inst
.
_rootNodeID
'
value
'
'
'
+
value
)
;
}
}
}
;
function
_handleChange
(
event
)
{
var
props
=
this
.
_currentElement
.
props
;
var
returnValue
=
LinkedValueUtils
.
executeOnChange
(
props
event
)
;
ReactUpdates
.
asap
(
forceUpdateIfMounted
this
)
;
var
name
=
props
.
name
;
if
(
props
.
type
=
=
=
'
radio
'
&
&
name
!
=
null
)
{
var
rootNode
=
ReactMount
.
getNode
(
this
.
_rootNodeID
)
;
var
queryRoot
=
rootNode
;
while
(
queryRoot
.
parentNode
)
{
queryRoot
=
queryRoot
.
parentNode
;
}
var
group
=
queryRoot
.
querySelectorAll
(
'
input
[
name
=
'
+
JSON
.
stringify
(
'
'
+
name
)
+
'
]
[
type
=
"
radio
"
]
'
)
;
for
(
var
i
=
0
;
i
<
group
.
length
;
i
+
+
)
{
var
otherNode
=
group
[
i
]
;
if
(
otherNode
=
=
=
rootNode
|
|
otherNode
.
form
!
=
=
rootNode
.
form
)
{
continue
;
}
var
otherID
=
ReactMount
.
getID
(
otherNode
)
;
!
otherID
?
false
?
invariant
(
false
'
ReactDOMInput
:
Mixing
React
and
non
-
React
radio
inputs
with
the
'
+
'
same
name
is
not
supported
.
'
)
:
invariant
(
false
)
:
undefined
;
var
otherInstance
=
instancesByReactID
[
otherID
]
;
!
otherInstance
?
false
?
invariant
(
false
'
ReactDOMInput
:
Unknown
radio
button
ID
%
s
.
'
otherID
)
:
invariant
(
false
)
:
undefined
;
ReactUpdates
.
asap
(
forceUpdateIfMounted
otherInstance
)
;
}
}
return
returnValue
;
}
module
.
exports
=
ReactDOMInput
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactPropTypes
=
__webpack_require__
(
122
)
;
var
ReactPropTypeLocations
=
__webpack_require__
(
80
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
hasReadOnlyValue
=
{
'
button
'
:
true
'
checkbox
'
:
true
'
image
'
:
true
'
hidden
'
:
true
'
radio
'
:
true
'
reset
'
:
true
'
submit
'
:
true
}
;
function
_assertSingleLink
(
inputProps
)
{
!
(
inputProps
.
checkedLink
=
=
null
|
|
inputProps
.
valueLink
=
=
null
)
?
false
?
invariant
(
false
'
Cannot
provide
a
checkedLink
and
a
valueLink
.
If
you
want
to
use
'
+
'
checkedLink
you
probably
don
\
'
t
want
to
use
valueLink
and
vice
versa
.
'
)
:
invariant
(
false
)
:
undefined
;
}
function
_assertValueLink
(
inputProps
)
{
_assertSingleLink
(
inputProps
)
;
!
(
inputProps
.
value
=
=
null
&
&
inputProps
.
onChange
=
=
null
)
?
false
?
invariant
(
false
'
Cannot
provide
a
valueLink
and
a
value
or
onChange
event
.
If
you
want
'
+
'
to
use
value
or
onChange
you
probably
don
\
'
t
want
to
use
valueLink
.
'
)
:
invariant
(
false
)
:
undefined
;
}
function
_assertCheckedLink
(
inputProps
)
{
_assertSingleLink
(
inputProps
)
;
!
(
inputProps
.
checked
=
=
null
&
&
inputProps
.
onChange
=
=
null
)
?
false
?
invariant
(
false
'
Cannot
provide
a
checkedLink
and
a
checked
property
or
onChange
event
.
'
+
'
If
you
want
to
use
checked
or
onChange
you
probably
don
\
'
t
want
to
'
+
'
use
checkedLink
'
)
:
invariant
(
false
)
:
undefined
;
}
var
propTypes
=
{
value
:
function
(
props
propName
componentName
)
{
if
(
!
props
[
propName
]
|
|
hasReadOnlyValue
[
props
.
type
]
|
|
props
.
onChange
|
|
props
.
readOnly
|
|
props
.
disabled
)
{
return
null
;
}
return
new
Error
(
'
You
provided
a
value
prop
to
a
form
field
without
an
'
+
'
onChange
handler
.
This
will
render
a
read
-
only
field
.
If
'
+
'
the
field
should
be
mutable
use
defaultValue
.
Otherwise
'
+
'
set
either
onChange
or
readOnly
.
'
)
;
}
checked
:
function
(
props
propName
componentName
)
{
if
(
!
props
[
propName
]
|
|
props
.
onChange
|
|
props
.
readOnly
|
|
props
.
disabled
)
{
return
null
;
}
return
new
Error
(
'
You
provided
a
checked
prop
to
a
form
field
without
an
'
+
'
onChange
handler
.
This
will
render
a
read
-
only
field
.
If
'
+
'
the
field
should
be
mutable
use
defaultChecked
.
Otherwise
'
+
'
set
either
onChange
or
readOnly
.
'
)
;
}
onChange
:
ReactPropTypes
.
func
}
;
var
loggedTypeFailures
=
{
}
;
function
getDeclarationErrorAddendum
(
owner
)
{
if
(
owner
)
{
var
name
=
owner
.
getName
(
)
;
if
(
name
)
{
return
'
Check
the
render
method
of
'
+
name
+
'
.
'
;
}
}
return
'
'
;
}
var
LinkedValueUtils
=
{
checkPropTypes
:
function
(
tagName
props
owner
)
{
for
(
var
propName
in
propTypes
)
{
if
(
propTypes
.
hasOwnProperty
(
propName
)
)
{
var
error
=
propTypes
[
propName
]
(
props
propName
tagName
ReactPropTypeLocations
.
prop
)
;
}
if
(
error
instanceof
Error
&
&
!
(
error
.
message
in
loggedTypeFailures
)
)
{
loggedTypeFailures
[
error
.
message
]
=
true
;
var
addendum
=
getDeclarationErrorAddendum
(
owner
)
;
false
?
warning
(
false
'
Failed
form
propType
:
%
s
%
s
'
error
.
message
addendum
)
:
undefined
;
}
}
}
getValue
:
function
(
inputProps
)
{
if
(
inputProps
.
valueLink
)
{
_assertValueLink
(
inputProps
)
;
return
inputProps
.
valueLink
.
value
;
}
return
inputProps
.
value
;
}
getChecked
:
function
(
inputProps
)
{
if
(
inputProps
.
checkedLink
)
{
_assertCheckedLink
(
inputProps
)
;
return
inputProps
.
checkedLink
.
value
;
}
return
inputProps
.
checked
;
}
executeOnChange
:
function
(
inputProps
event
)
{
if
(
inputProps
.
valueLink
)
{
_assertValueLink
(
inputProps
)
;
return
inputProps
.
valueLink
.
requestChange
(
event
.
target
.
value
)
;
}
else
if
(
inputProps
.
checkedLink
)
{
_assertCheckedLink
(
inputProps
)
;
return
inputProps
.
checkedLink
.
requestChange
(
event
.
target
.
checked
)
;
}
else
if
(
inputProps
.
onChange
)
{
return
inputProps
.
onChange
.
call
(
undefined
event
)
;
}
}
}
;
module
.
exports
=
LinkedValueUtils
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactPropTypeLocationNames
=
__webpack_require__
(
81
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
getIteratorFn
=
__webpack_require__
(
123
)
;
var
ANONYMOUS
=
'
<
<
anonymous
>
>
'
;
var
ReactPropTypes
=
{
array
:
createPrimitiveTypeChecker
(
'
array
'
)
bool
:
createPrimitiveTypeChecker
(
'
boolean
'
)
func
:
createPrimitiveTypeChecker
(
'
function
'
)
number
:
createPrimitiveTypeChecker
(
'
number
'
)
object
:
createPrimitiveTypeChecker
(
'
object
'
)
string
:
createPrimitiveTypeChecker
(
'
string
'
)
any
:
createAnyTypeChecker
(
)
arrayOf
:
createArrayOfTypeChecker
element
:
createElementTypeChecker
(
)
instanceOf
:
createInstanceTypeChecker
node
:
createNodeChecker
(
)
objectOf
:
createObjectOfTypeChecker
oneOf
:
createEnumTypeChecker
oneOfType
:
createUnionTypeChecker
shape
:
createShapeTypeChecker
}
;
function
createChainableTypeChecker
(
validate
)
{
function
checkType
(
isRequired
props
propName
componentName
location
propFullName
)
{
componentName
=
componentName
|
|
ANONYMOUS
;
propFullName
=
propFullName
|
|
propName
;
if
(
props
[
propName
]
=
=
null
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
if
(
isRequired
)
{
return
new
Error
(
'
Required
'
+
locationName
+
'
'
+
propFullName
+
'
was
not
specified
in
'
+
(
'
'
+
componentName
+
'
.
'
)
)
;
}
return
null
;
}
else
{
return
validate
(
props
propName
componentName
location
propFullName
)
;
}
}
var
chainedCheckType
=
checkType
.
bind
(
null
false
)
;
chainedCheckType
.
isRequired
=
checkType
.
bind
(
null
true
)
;
return
chainedCheckType
;
}
function
createPrimitiveTypeChecker
(
expectedType
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
!
=
=
expectedType
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
var
preciseType
=
getPreciseType
(
propValue
)
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
preciseType
+
'
supplied
to
'
+
componentName
+
'
expected
'
)
+
(
'
'
+
expectedType
+
'
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createAnyTypeChecker
(
)
{
return
createChainableTypeChecker
(
emptyFunction
.
thatReturns
(
null
)
)
;
}
function
createArrayOfTypeChecker
(
typeChecker
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
if
(
!
Array
.
isArray
(
propValue
)
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
var
propType
=
getPropType
(
propValue
)
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
propType
+
'
supplied
to
'
+
componentName
+
'
expected
an
array
.
'
)
)
;
}
for
(
var
i
=
0
;
i
<
propValue
.
length
;
i
+
+
)
{
var
error
=
typeChecker
(
propValue
i
componentName
location
propFullName
+
'
[
'
+
i
+
'
]
'
)
;
if
(
error
instanceof
Error
)
{
return
error
;
}
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createElementTypeChecker
(
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
if
(
!
ReactElement
.
isValidElement
(
props
[
propName
]
)
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
supplied
to
'
+
(
'
'
+
componentName
+
'
expected
a
single
ReactElement
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createInstanceTypeChecker
(
expectedClass
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
if
(
!
(
props
[
propName
]
instanceof
expectedClass
)
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
var
expectedClassName
=
expectedClass
.
name
|
|
ANONYMOUS
;
var
actualClassName
=
getClassName
(
props
[
propName
]
)
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
actualClassName
+
'
supplied
to
'
+
componentName
+
'
expected
'
)
+
(
'
instance
of
'
+
expectedClassName
+
'
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createEnumTypeChecker
(
expectedValues
)
{
if
(
!
Array
.
isArray
(
expectedValues
)
)
{
return
createChainableTypeChecker
(
function
(
)
{
return
new
Error
(
'
Invalid
argument
supplied
to
oneOf
expected
an
instance
of
array
.
'
)
;
}
)
;
}
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
for
(
var
i
=
0
;
i
<
expectedValues
.
length
;
i
+
+
)
{
if
(
propValue
=
=
=
expectedValues
[
i
]
)
{
return
null
;
}
}
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
var
valuesString
=
JSON
.
stringify
(
expectedValues
)
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
of
value
'
+
propValue
+
'
'
+
(
'
supplied
to
'
+
componentName
+
'
expected
one
of
'
+
valuesString
+
'
.
'
)
)
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createObjectOfTypeChecker
(
typeChecker
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
!
=
=
'
object
'
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
of
type
'
+
(
'
'
+
propType
+
'
supplied
to
'
+
componentName
+
'
expected
an
object
.
'
)
)
;
}
for
(
var
key
in
propValue
)
{
if
(
propValue
.
hasOwnProperty
(
key
)
)
{
var
error
=
typeChecker
(
propValue
key
componentName
location
propFullName
+
'
.
'
+
key
)
;
if
(
error
instanceof
Error
)
{
return
error
;
}
}
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createUnionTypeChecker
(
arrayOfTypeCheckers
)
{
if
(
!
Array
.
isArray
(
arrayOfTypeCheckers
)
)
{
return
createChainableTypeChecker
(
function
(
)
{
return
new
Error
(
'
Invalid
argument
supplied
to
oneOfType
expected
an
instance
of
array
.
'
)
;
}
)
;
}
function
validate
(
props
propName
componentName
location
propFullName
)
{
for
(
var
i
=
0
;
i
<
arrayOfTypeCheckers
.
length
;
i
+
+
)
{
var
checker
=
arrayOfTypeCheckers
[
i
]
;
if
(
checker
(
props
propName
componentName
location
propFullName
)
=
=
null
)
{
return
null
;
}
}
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
supplied
to
'
+
(
'
'
+
componentName
+
'
.
'
)
)
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createNodeChecker
(
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
if
(
!
isNode
(
props
[
propName
]
)
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
supplied
to
'
+
(
'
'
+
componentName
+
'
expected
a
ReactNode
.
'
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createShapeTypeChecker
(
shapeTypes
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
!
=
=
'
object
'
)
{
var
locationName
=
ReactPropTypeLocationNames
[
location
]
;
return
new
Error
(
'
Invalid
'
+
locationName
+
'
'
+
propFullName
+
'
of
type
'
+
propType
+
'
'
+
(
'
supplied
to
'
+
componentName
+
'
expected
object
.
'
)
)
;
}
for
(
var
key
in
shapeTypes
)
{
var
checker
=
shapeTypes
[
key
]
;
if
(
!
checker
)
{
continue
;
}
var
error
=
checker
(
propValue
key
componentName
location
propFullName
+
'
.
'
+
key
)
;
if
(
error
)
{
return
error
;
}
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
isNode
(
propValue
)
{
switch
(
typeof
propValue
)
{
case
'
number
'
:
case
'
string
'
:
case
'
undefined
'
:
return
true
;
case
'
boolean
'
:
return
!
propValue
;
case
'
object
'
:
if
(
Array
.
isArray
(
propValue
)
)
{
return
propValue
.
every
(
isNode
)
;
}
if
(
propValue
=
=
=
null
|
|
ReactElement
.
isValidElement
(
propValue
)
)
{
return
true
;
}
var
iteratorFn
=
getIteratorFn
(
propValue
)
;
if
(
iteratorFn
)
{
var
iterator
=
iteratorFn
.
call
(
propValue
)
;
var
step
;
if
(
iteratorFn
!
=
=
propValue
.
entries
)
{
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
if
(
!
isNode
(
step
.
value
)
)
{
return
false
;
}
}
}
else
{
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
var
entry
=
step
.
value
;
if
(
entry
)
{
if
(
!
isNode
(
entry
[
1
]
)
)
{
return
false
;
}
}
}
}
}
else
{
return
false
;
}
return
true
;
default
:
return
false
;
}
}
function
getPropType
(
propValue
)
{
var
propType
=
typeof
propValue
;
if
(
Array
.
isArray
(
propValue
)
)
{
return
'
array
'
;
}
if
(
propValue
instanceof
RegExp
)
{
return
'
object
'
;
}
return
propType
;
}
function
getPreciseType
(
propValue
)
{
var
propType
=
getPropType
(
propValue
)
;
if
(
propType
=
=
=
'
object
'
)
{
if
(
propValue
instanceof
Date
)
{
return
'
date
'
;
}
else
if
(
propValue
instanceof
RegExp
)
{
return
'
regexp
'
;
}
}
return
propType
;
}
function
getClassName
(
propValue
)
{
if
(
!
propValue
.
constructor
|
|
!
propValue
.
constructor
.
name
)
{
return
'
<
<
anonymous
>
>
'
;
}
return
propValue
.
constructor
.
name
;
}
module
.
exports
=
ReactPropTypes
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
function
getIteratorFn
(
maybeIterable
)
{
var
iteratorFn
=
maybeIterable
&
&
(
ITERATOR_SYMBOL
&
&
maybeIterable
[
ITERATOR_SYMBOL
]
|
|
maybeIterable
[
FAUX_ITERATOR_SYMBOL
]
)
;
if
(
typeof
iteratorFn
=
=
=
'
function
'
)
{
return
iteratorFn
;
}
}
module
.
exports
=
getIteratorFn
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactChildren
=
__webpack_require__
(
125
)
;
var
ReactDOMSelect
=
__webpack_require__
(
127
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
valueContextKey
=
ReactDOMSelect
.
valueContextKey
;
var
ReactDOMOption
=
{
mountWrapper
:
function
(
inst
props
context
)
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
props
.
selected
=
=
null
'
Use
the
defaultValue
or
value
props
on
<
select
>
instead
of
'
+
'
setting
selected
on
<
option
>
.
'
)
:
undefined
;
}
var
selectValue
=
context
[
valueContextKey
]
;
var
selected
=
null
;
if
(
selectValue
!
=
null
)
{
selected
=
false
;
if
(
Array
.
isArray
(
selectValue
)
)
{
for
(
var
i
=
0
;
i
<
selectValue
.
length
;
i
+
+
)
{
if
(
'
'
+
selectValue
[
i
]
=
=
=
'
'
+
props
.
value
)
{
selected
=
true
;
break
;
}
}
}
else
{
selected
=
'
'
+
selectValue
=
=
=
'
'
+
props
.
value
;
}
}
inst
.
_wrapperState
=
{
selected
:
selected
}
;
}
getNativeProps
:
function
(
inst
props
context
)
{
var
nativeProps
=
assign
(
{
selected
:
undefined
children
:
undefined
}
props
)
;
if
(
inst
.
_wrapperState
.
selected
!
=
null
)
{
nativeProps
.
selected
=
inst
.
_wrapperState
.
selected
;
}
var
content
=
'
'
;
ReactChildren
.
forEach
(
props
.
children
function
(
child
)
{
if
(
child
=
=
null
)
{
return
;
}
if
(
typeof
child
=
=
=
'
string
'
|
|
typeof
child
=
=
=
'
number
'
)
{
content
+
=
child
;
}
else
{
false
?
warning
(
false
'
Only
strings
and
numbers
are
supported
as
<
option
>
children
.
'
)
:
undefined
;
}
}
)
;
if
(
content
)
{
nativeProps
.
children
=
content
;
}
return
nativeProps
;
}
}
;
module
.
exports
=
ReactDOMOption
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
traverseAllChildren
=
__webpack_require__
(
126
)
;
var
twoArgumentPooler
=
PooledClass
.
twoArgumentPooler
;
var
fourArgumentPooler
=
PooledClass
.
fourArgumentPooler
;
var
userProvidedKeyEscapeRegex
=
/
\
/
(
?
!
\
/
)
/
g
;
function
escapeUserProvidedKey
(
text
)
{
return
(
'
'
+
text
)
.
replace
(
userProvidedKeyEscapeRegex
'
/
/
'
)
;
}
function
ForEachBookKeeping
(
forEachFunction
forEachContext
)
{
this
.
func
=
forEachFunction
;
this
.
context
=
forEachContext
;
this
.
count
=
0
;
}
ForEachBookKeeping
.
prototype
.
destructor
=
function
(
)
{
this
.
func
=
null
;
this
.
context
=
null
;
this
.
count
=
0
;
}
;
PooledClass
.
addPoolingTo
(
ForEachBookKeeping
twoArgumentPooler
)
;
function
forEachSingleChild
(
bookKeeping
child
name
)
{
var
func
=
bookKeeping
.
func
;
var
context
=
bookKeeping
.
context
;
func
.
call
(
context
child
bookKeeping
.
count
+
+
)
;
}
function
forEachChildren
(
children
forEachFunc
forEachContext
)
{
if
(
children
=
=
null
)
{
return
children
;
}
var
traverseContext
=
ForEachBookKeeping
.
getPooled
(
forEachFunc
forEachContext
)
;
traverseAllChildren
(
children
forEachSingleChild
traverseContext
)
;
ForEachBookKeeping
.
release
(
traverseContext
)
;
}
function
MapBookKeeping
(
mapResult
keyPrefix
mapFunction
mapContext
)
{
this
.
result
=
mapResult
;
this
.
keyPrefix
=
keyPrefix
;
this
.
func
=
mapFunction
;
this
.
context
=
mapContext
;
this
.
count
=
0
;
}
MapBookKeeping
.
prototype
.
destructor
=
function
(
)
{
this
.
result
=
null
;
this
.
keyPrefix
=
null
;
this
.
func
=
null
;
this
.
context
=
null
;
this
.
count
=
0
;
}
;
PooledClass
.
addPoolingTo
(
MapBookKeeping
fourArgumentPooler
)
;
function
mapSingleChildIntoContext
(
bookKeeping
child
childKey
)
{
var
result
=
bookKeeping
.
result
;
var
keyPrefix
=
bookKeeping
.
keyPrefix
;
var
func
=
bookKeeping
.
func
;
var
context
=
bookKeeping
.
context
;
var
mappedChild
=
func
.
call
(
context
child
bookKeeping
.
count
+
+
)
;
if
(
Array
.
isArray
(
mappedChild
)
)
{
mapIntoWithKeyPrefixInternal
(
mappedChild
result
childKey
emptyFunction
.
thatReturnsArgument
)
;
}
else
if
(
mappedChild
!
=
null
)
{
if
(
ReactElement
.
isValidElement
(
mappedChild
)
)
{
mappedChild
=
ReactElement
.
cloneAndReplaceKey
(
mappedChild
keyPrefix
+
(
mappedChild
!
=
=
child
?
escapeUserProvidedKey
(
mappedChild
.
key
|
|
'
'
)
+
'
/
'
:
'
'
)
+
childKey
)
;
}
result
.
push
(
mappedChild
)
;
}
}
function
mapIntoWithKeyPrefixInternal
(
children
array
prefix
func
context
)
{
var
escapedPrefix
=
'
'
;
if
(
prefix
!
=
null
)
{
escapedPrefix
=
escapeUserProvidedKey
(
prefix
)
+
'
/
'
;
}
var
traverseContext
=
MapBookKeeping
.
getPooled
(
array
escapedPrefix
func
context
)
;
traverseAllChildren
(
children
mapSingleChildIntoContext
traverseContext
)
;
MapBookKeeping
.
release
(
traverseContext
)
;
}
function
mapChildren
(
children
func
context
)
{
if
(
children
=
=
null
)
{
return
children
;
}
var
result
=
[
]
;
mapIntoWithKeyPrefixInternal
(
children
result
null
func
context
)
;
return
result
;
}
function
forEachSingleChildDummy
(
traverseContext
child
name
)
{
return
null
;
}
function
countChildren
(
children
context
)
{
return
traverseAllChildren
(
children
forEachSingleChildDummy
null
)
;
}
function
toArray
(
children
)
{
var
result
=
[
]
;
mapIntoWithKeyPrefixInternal
(
children
result
null
emptyFunction
.
thatReturnsArgument
)
;
return
result
;
}
var
ReactChildren
=
{
forEach
:
forEachChildren
map
:
mapChildren
mapIntoWithKeyPrefixInternal
:
mapIntoWithKeyPrefixInternal
count
:
countChildren
toArray
:
toArray
}
;
module
.
exports
=
ReactChildren
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactInstanceHandles
=
__webpack_require__
(
60
)
;
var
getIteratorFn
=
__webpack_require__
(
123
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
SEPARATOR
=
ReactInstanceHandles
.
SEPARATOR
;
var
SUBSEPARATOR
=
'
:
'
;
var
userProvidedKeyEscaperLookup
=
{
'
=
'
:
'
=
0
'
'
.
'
:
'
=
1
'
'
:
'
:
'
=
2
'
}
;
var
userProvidedKeyEscapeRegex
=
/
[
=
.
:
]
/
g
;
var
didWarnAboutMaps
=
false
;
function
userProvidedKeyEscaper
(
match
)
{
return
userProvidedKeyEscaperLookup
[
match
]
;
}
function
getComponentKey
(
component
index
)
{
if
(
component
&
&
component
.
key
!
=
null
)
{
return
wrapUserProvidedKey
(
component
.
key
)
;
}
return
index
.
toString
(
36
)
;
}
function
escapeUserProvidedKey
(
text
)
{
return
(
'
'
+
text
)
.
replace
(
userProvidedKeyEscapeRegex
userProvidedKeyEscaper
)
;
}
function
wrapUserProvidedKey
(
key
)
{
return
'
'
+
escapeUserProvidedKey
(
key
)
;
}
function
traverseAllChildrenImpl
(
children
nameSoFar
callback
traverseContext
)
{
var
type
=
typeof
children
;
if
(
type
=
=
=
'
undefined
'
|
|
type
=
=
=
'
boolean
'
)
{
children
=
null
;
}
if
(
children
=
=
=
null
|
|
type
=
=
=
'
string
'
|
|
type
=
=
=
'
number
'
|
|
ReactElement
.
isValidElement
(
children
)
)
{
callback
(
traverseContext
children
nameSoFar
=
=
=
'
'
?
SEPARATOR
+
getComponentKey
(
children
0
)
:
nameSoFar
)
;
return
1
;
}
var
child
;
var
nextName
;
var
subtreeCount
=
0
;
var
nextNamePrefix
=
nameSoFar
=
=
=
'
'
?
SEPARATOR
:
nameSoFar
+
SUBSEPARATOR
;
if
(
Array
.
isArray
(
children
)
)
{
for
(
var
i
=
0
;
i
<
children
.
length
;
i
+
+
)
{
child
=
children
[
i
]
;
nextName
=
nextNamePrefix
+
getComponentKey
(
child
i
)
;
subtreeCount
+
=
traverseAllChildrenImpl
(
child
nextName
callback
traverseContext
)
;
}
}
else
{
var
iteratorFn
=
getIteratorFn
(
children
)
;
if
(
iteratorFn
)
{
var
iterator
=
iteratorFn
.
call
(
children
)
;
var
step
;
if
(
iteratorFn
!
=
=
children
.
entries
)
{
var
ii
=
0
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
child
=
step
.
value
;
nextName
=
nextNamePrefix
+
getComponentKey
(
child
ii
+
+
)
;
subtreeCount
+
=
traverseAllChildrenImpl
(
child
nextName
callback
traverseContext
)
;
}
}
else
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
didWarnAboutMaps
'
Using
Maps
as
children
is
not
yet
fully
supported
.
It
is
an
'
+
'
experimental
feature
that
might
be
removed
.
Convert
it
to
a
'
+
'
sequence
/
iterable
of
keyed
ReactElements
instead
.
'
)
:
undefined
;
didWarnAboutMaps
=
true
;
}
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
var
entry
=
step
.
value
;
if
(
entry
)
{
child
=
entry
[
1
]
;
nextName
=
nextNamePrefix
+
wrapUserProvidedKey
(
entry
[
0
]
)
+
SUBSEPARATOR
+
getComponentKey
(
child
0
)
;
subtreeCount
+
=
traverseAllChildrenImpl
(
child
nextName
callback
traverseContext
)
;
}
}
}
}
else
if
(
type
=
=
=
'
object
'
)
{
var
addendum
=
'
'
;
if
(
false
)
{
addendum
=
'
If
you
meant
to
render
a
collection
of
children
use
an
array
'
+
'
instead
or
wrap
the
object
using
createFragment
(
object
)
from
the
'
+
'
React
add
-
ons
.
'
;
if
(
children
.
_isReactElement
)
{
addendum
=
'
It
looks
like
you
\
'
re
using
an
element
created
by
a
different
'
+
'
version
of
React
.
Make
sure
to
use
only
one
copy
of
React
.
'
;
}
if
(
ReactCurrentOwner
.
current
)
{
var
name
=
ReactCurrentOwner
.
current
.
getName
(
)
;
if
(
name
)
{
addendum
+
=
'
Check
the
render
method
of
'
+
name
+
'
.
'
;
}
}
}
var
childrenString
=
String
(
children
)
;
true
?
false
?
invariant
(
false
'
Objects
are
not
valid
as
a
React
child
(
found
:
%
s
)
.
%
s
'
childrenString
=
=
=
'
[
object
Object
]
'
?
'
object
with
keys
{
'
+
Object
.
keys
(
children
)
.
join
(
'
'
)
+
'
}
'
:
childrenString
addendum
)
:
invariant
(
false
)
:
undefined
;
}
}
return
subtreeCount
;
}
function
traverseAllChildren
(
children
callback
traverseContext
)
{
if
(
children
=
=
null
)
{
return
0
;
}
return
traverseAllChildrenImpl
(
children
'
'
callback
traverseContext
)
;
}
module
.
exports
=
traverseAllChildren
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
LinkedValueUtils
=
__webpack_require__
(
121
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
valueContextKey
=
'
__ReactDOMSelect_value
'
+
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
function
updateOptionsIfPendingUpdateAndMounted
(
)
{
if
(
this
.
_rootNodeID
&
&
this
.
_wrapperState
.
pendingUpdate
)
{
this
.
_wrapperState
.
pendingUpdate
=
false
;
var
props
=
this
.
_currentElement
.
props
;
var
value
=
LinkedValueUtils
.
getValue
(
props
)
;
if
(
value
!
=
null
)
{
updateOptions
(
this
Boolean
(
props
.
multiple
)
value
)
;
}
}
}
function
getDeclarationErrorAddendum
(
owner
)
{
if
(
owner
)
{
var
name
=
owner
.
getName
(
)
;
if
(
name
)
{
return
'
Check
the
render
method
of
'
+
name
+
'
.
'
;
}
}
return
'
'
;
}
var
valuePropNames
=
[
'
value
'
'
defaultValue
'
]
;
function
checkSelectPropTypes
(
inst
props
)
{
var
owner
=
inst
.
_currentElement
.
_owner
;
LinkedValueUtils
.
checkPropTypes
(
'
select
'
props
owner
)
;
for
(
var
i
=
0
;
i
<
valuePropNames
.
length
;
i
+
+
)
{
var
propName
=
valuePropNames
[
i
]
;
if
(
props
[
propName
]
=
=
null
)
{
continue
;
}
if
(
props
.
multiple
)
{
false
?
warning
(
Array
.
isArray
(
props
[
propName
]
)
'
The
%
s
prop
supplied
to
<
select
>
must
be
an
array
if
'
+
'
multiple
is
true
.
%
s
'
propName
getDeclarationErrorAddendum
(
owner
)
)
:
undefined
;
}
else
{
false
?
warning
(
!
Array
.
isArray
(
props
[
propName
]
)
'
The
%
s
prop
supplied
to
<
select
>
must
be
a
scalar
'
+
'
value
if
multiple
is
false
.
%
s
'
propName
getDeclarationErrorAddendum
(
owner
)
)
:
undefined
;
}
}
}
function
updateOptions
(
inst
multiple
propValue
)
{
var
selectedValue
i
;
var
options
=
ReactMount
.
getNode
(
inst
.
_rootNodeID
)
.
options
;
if
(
multiple
)
{
selectedValue
=
{
}
;
for
(
i
=
0
;
i
<
propValue
.
length
;
i
+
+
)
{
selectedValue
[
'
'
+
propValue
[
i
]
]
=
true
;
}
for
(
i
=
0
;
i
<
options
.
length
;
i
+
+
)
{
var
selected
=
selectedValue
.
hasOwnProperty
(
options
[
i
]
.
value
)
;
if
(
options
[
i
]
.
selected
!
=
=
selected
)
{
options
[
i
]
.
selected
=
selected
;
}
}
}
else
{
selectedValue
=
'
'
+
propValue
;
for
(
i
=
0
;
i
<
options
.
length
;
i
+
+
)
{
if
(
options
[
i
]
.
value
=
=
=
selectedValue
)
{
options
[
i
]
.
selected
=
true
;
return
;
}
}
if
(
options
.
length
)
{
options
[
0
]
.
selected
=
true
;
}
}
}
var
ReactDOMSelect
=
{
valueContextKey
:
valueContextKey
getNativeProps
:
function
(
inst
props
context
)
{
return
assign
(
{
}
props
{
onChange
:
inst
.
_wrapperState
.
onChange
value
:
undefined
}
)
;
}
mountWrapper
:
function
(
inst
props
)
{
if
(
false
)
{
checkSelectPropTypes
(
inst
props
)
;
}
var
value
=
LinkedValueUtils
.
getValue
(
props
)
;
inst
.
_wrapperState
=
{
pendingUpdate
:
false
initialValue
:
value
!
=
null
?
value
:
props
.
defaultValue
onChange
:
_handleChange
.
bind
(
inst
)
wasMultiple
:
Boolean
(
props
.
multiple
)
}
;
}
processChildContext
:
function
(
inst
props
context
)
{
var
childContext
=
assign
(
{
}
context
)
;
childContext
[
valueContextKey
]
=
inst
.
_wrapperState
.
initialValue
;
return
childContext
;
}
postUpdateWrapper
:
function
(
inst
)
{
var
props
=
inst
.
_currentElement
.
props
;
inst
.
_wrapperState
.
initialValue
=
undefined
;
var
wasMultiple
=
inst
.
_wrapperState
.
wasMultiple
;
inst
.
_wrapperState
.
wasMultiple
=
Boolean
(
props
.
multiple
)
;
var
value
=
LinkedValueUtils
.
getValue
(
props
)
;
if
(
value
!
=
null
)
{
inst
.
_wrapperState
.
pendingUpdate
=
false
;
updateOptions
(
inst
Boolean
(
props
.
multiple
)
value
)
;
}
else
if
(
wasMultiple
!
=
=
Boolean
(
props
.
multiple
)
)
{
if
(
props
.
defaultValue
!
=
null
)
{
updateOptions
(
inst
Boolean
(
props
.
multiple
)
props
.
defaultValue
)
;
}
else
{
updateOptions
(
inst
Boolean
(
props
.
multiple
)
props
.
multiple
?
[
]
:
'
'
)
;
}
}
}
}
;
function
_handleChange
(
event
)
{
var
props
=
this
.
_currentElement
.
props
;
var
returnValue
=
LinkedValueUtils
.
executeOnChange
(
props
event
)
;
this
.
_wrapperState
.
pendingUpdate
=
true
;
ReactUpdates
.
asap
(
updateOptionsIfPendingUpdateAndMounted
this
)
;
return
returnValue
;
}
module
.
exports
=
ReactDOMSelect
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
LinkedValueUtils
=
__webpack_require__
(
121
)
;
var
ReactDOMIDOperations
=
__webpack_require__
(
42
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
forceUpdateIfMounted
(
)
{
if
(
this
.
_rootNodeID
)
{
ReactDOMTextarea
.
updateWrapper
(
this
)
;
}
}
var
ReactDOMTextarea
=
{
getNativeProps
:
function
(
inst
props
context
)
{
!
(
props
.
dangerouslySetInnerHTML
=
=
null
)
?
false
?
invariant
(
false
'
dangerouslySetInnerHTML
does
not
make
sense
on
<
textarea
>
.
'
)
:
invariant
(
false
)
:
undefined
;
var
nativeProps
=
assign
(
{
}
props
{
defaultValue
:
undefined
value
:
undefined
children
:
inst
.
_wrapperState
.
initialValue
onChange
:
inst
.
_wrapperState
.
onChange
}
)
;
return
nativeProps
;
}
mountWrapper
:
function
(
inst
props
)
{
if
(
false
)
{
LinkedValueUtils
.
checkPropTypes
(
'
textarea
'
props
inst
.
_currentElement
.
_owner
)
;
}
var
defaultValue
=
props
.
defaultValue
;
var
children
=
props
.
children
;
if
(
children
!
=
null
)
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
Use
the
defaultValue
or
value
props
instead
of
setting
'
+
'
children
on
<
textarea
>
.
'
)
:
undefined
;
}
!
(
defaultValue
=
=
null
)
?
false
?
invariant
(
false
'
If
you
supply
defaultValue
on
a
<
textarea
>
do
not
pass
children
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
Array
.
isArray
(
children
)
)
{
!
(
children
.
length
<
=
1
)
?
false
?
invariant
(
false
'
<
textarea
>
can
only
have
at
most
one
child
.
'
)
:
invariant
(
false
)
:
undefined
;
children
=
children
[
0
]
;
}
defaultValue
=
'
'
+
children
;
}
if
(
defaultValue
=
=
null
)
{
defaultValue
=
'
'
;
}
var
value
=
LinkedValueUtils
.
getValue
(
props
)
;
inst
.
_wrapperState
=
{
initialValue
:
'
'
+
(
value
!
=
null
?
value
:
defaultValue
)
onChange
:
_handleChange
.
bind
(
inst
)
}
;
}
updateWrapper
:
function
(
inst
)
{
var
props
=
inst
.
_currentElement
.
props
;
var
value
=
LinkedValueUtils
.
getValue
(
props
)
;
if
(
value
!
=
null
)
{
ReactDOMIDOperations
.
updatePropertyByID
(
inst
.
_rootNodeID
'
value
'
'
'
+
value
)
;
}
}
}
;
function
_handleChange
(
event
)
{
var
props
=
this
.
_currentElement
.
props
;
var
returnValue
=
LinkedValueUtils
.
executeOnChange
(
props
event
)
;
ReactUpdates
.
asap
(
forceUpdateIfMounted
this
)
;
return
returnValue
;
}
module
.
exports
=
ReactDOMTextarea
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactComponentEnvironment
=
__webpack_require__
(
79
)
;
var
ReactMultiChildUpdateTypes
=
__webpack_require__
(
31
)
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
ReactReconciler
=
__webpack_require__
(
65
)
;
var
ReactChildReconciler
=
__webpack_require__
(
130
)
;
var
flattenChildren
=
__webpack_require__
(
131
)
;
var
updateDepth
=
0
;
var
updateQueue
=
[
]
;
var
markupQueue
=
[
]
;
function
enqueueInsertMarkup
(
parentID
markup
toIndex
)
{
updateQueue
.
push
(
{
parentID
:
parentID
parentNode
:
null
type
:
ReactMultiChildUpdateTypes
.
INSERT_MARKUP
markupIndex
:
markupQueue
.
push
(
markup
)
-
1
content
:
null
fromIndex
:
null
toIndex
:
toIndex
}
)
;
}
function
enqueueMove
(
parentID
fromIndex
toIndex
)
{
updateQueue
.
push
(
{
parentID
:
parentID
parentNode
:
null
type
:
ReactMultiChildUpdateTypes
.
MOVE_EXISTING
markupIndex
:
null
content
:
null
fromIndex
:
fromIndex
toIndex
:
toIndex
}
)
;
}
function
enqueueRemove
(
parentID
fromIndex
)
{
updateQueue
.
push
(
{
parentID
:
parentID
parentNode
:
null
type
:
ReactMultiChildUpdateTypes
.
REMOVE_NODE
markupIndex
:
null
content
:
null
fromIndex
:
fromIndex
toIndex
:
null
}
)
;
}
function
enqueueSetMarkup
(
parentID
markup
)
{
updateQueue
.
push
(
{
parentID
:
parentID
parentNode
:
null
type
:
ReactMultiChildUpdateTypes
.
SET_MARKUP
markupIndex
:
null
content
:
markup
fromIndex
:
null
toIndex
:
null
}
)
;
}
function
enqueueTextContent
(
parentID
textContent
)
{
updateQueue
.
push
(
{
parentID
:
parentID
parentNode
:
null
type
:
ReactMultiChildUpdateTypes
.
TEXT_CONTENT
markupIndex
:
null
content
:
textContent
fromIndex
:
null
toIndex
:
null
}
)
;
}
function
processQueue
(
)
{
if
(
updateQueue
.
length
)
{
ReactComponentEnvironment
.
processChildrenUpdates
(
updateQueue
markupQueue
)
;
clearQueue
(
)
;
}
}
function
clearQueue
(
)
{
updateQueue
.
length
=
0
;
markupQueue
.
length
=
0
;
}
var
ReactMultiChild
=
{
Mixin
:
{
_reconcilerInstantiateChildren
:
function
(
nestedChildren
transaction
context
)
{
if
(
false
)
{
if
(
this
.
_currentElement
)
{
try
{
ReactCurrentOwner
.
current
=
this
.
_currentElement
.
_owner
;
return
ReactChildReconciler
.
instantiateChildren
(
nestedChildren
transaction
context
)
;
}
finally
{
ReactCurrentOwner
.
current
=
null
;
}
}
}
return
ReactChildReconciler
.
instantiateChildren
(
nestedChildren
transaction
context
)
;
}
_reconcilerUpdateChildren
:
function
(
prevChildren
nextNestedChildrenElements
transaction
context
)
{
var
nextChildren
;
if
(
false
)
{
if
(
this
.
_currentElement
)
{
try
{
ReactCurrentOwner
.
current
=
this
.
_currentElement
.
_owner
;
nextChildren
=
flattenChildren
(
nextNestedChildrenElements
)
;
}
finally
{
ReactCurrentOwner
.
current
=
null
;
}
return
ReactChildReconciler
.
updateChildren
(
prevChildren
nextChildren
transaction
context
)
;
}
}
nextChildren
=
flattenChildren
(
nextNestedChildrenElements
)
;
return
ReactChildReconciler
.
updateChildren
(
prevChildren
nextChildren
transaction
context
)
;
}
mountChildren
:
function
(
nestedChildren
transaction
context
)
{
var
children
=
this
.
_reconcilerInstantiateChildren
(
nestedChildren
transaction
context
)
;
this
.
_renderedChildren
=
children
;
var
mountImages
=
[
]
;
var
index
=
0
;
for
(
var
name
in
children
)
{
if
(
children
.
hasOwnProperty
(
name
)
)
{
var
child
=
children
[
name
]
;
var
rootID
=
this
.
_rootNodeID
+
name
;
var
mountImage
=
ReactReconciler
.
mountComponent
(
child
rootID
transaction
context
)
;
child
.
_mountIndex
=
index
+
+
;
mountImages
.
push
(
mountImage
)
;
}
}
return
mountImages
;
}
updateTextContent
:
function
(
nextContent
)
{
updateDepth
+
+
;
var
errorThrown
=
true
;
try
{
var
prevChildren
=
this
.
_renderedChildren
;
ReactChildReconciler
.
unmountChildren
(
prevChildren
)
;
for
(
var
name
in
prevChildren
)
{
if
(
prevChildren
.
hasOwnProperty
(
name
)
)
{
this
.
_unmountChild
(
prevChildren
[
name
]
)
;
}
}
this
.
setTextContent
(
nextContent
)
;
errorThrown
=
false
;
}
finally
{
updateDepth
-
-
;
if
(
!
updateDepth
)
{
if
(
errorThrown
)
{
clearQueue
(
)
;
}
else
{
processQueue
(
)
;
}
}
}
}
updateMarkup
:
function
(
nextMarkup
)
{
updateDepth
+
+
;
var
errorThrown
=
true
;
try
{
var
prevChildren
=
this
.
_renderedChildren
;
ReactChildReconciler
.
unmountChildren
(
prevChildren
)
;
for
(
var
name
in
prevChildren
)
{
if
(
prevChildren
.
hasOwnProperty
(
name
)
)
{
this
.
_unmountChildByName
(
prevChildren
[
name
]
name
)
;
}
}
this
.
setMarkup
(
nextMarkup
)
;
errorThrown
=
false
;
}
finally
{
updateDepth
-
-
;
if
(
!
updateDepth
)
{
if
(
errorThrown
)
{
clearQueue
(
)
;
}
else
{
processQueue
(
)
;
}
}
}
}
updateChildren
:
function
(
nextNestedChildrenElements
transaction
context
)
{
updateDepth
+
+
;
var
errorThrown
=
true
;
try
{
this
.
_updateChildren
(
nextNestedChildrenElements
transaction
context
)
;
errorThrown
=
false
;
}
finally
{
updateDepth
-
-
;
if
(
!
updateDepth
)
{
if
(
errorThrown
)
{
clearQueue
(
)
;
}
else
{
processQueue
(
)
;
}
}
}
}
_updateChildren
:
function
(
nextNestedChildrenElements
transaction
context
)
{
var
prevChildren
=
this
.
_renderedChildren
;
var
nextChildren
=
this
.
_reconcilerUpdateChildren
(
prevChildren
nextNestedChildrenElements
transaction
context
)
;
this
.
_renderedChildren
=
nextChildren
;
if
(
!
nextChildren
&
&
!
prevChildren
)
{
return
;
}
var
name
;
var
lastIndex
=
0
;
var
nextIndex
=
0
;
for
(
name
in
nextChildren
)
{
if
(
!
nextChildren
.
hasOwnProperty
(
name
)
)
{
continue
;
}
var
prevChild
=
prevChildren
&
&
prevChildren
[
name
]
;
var
nextChild
=
nextChildren
[
name
]
;
if
(
prevChild
=
=
=
nextChild
)
{
this
.
moveChild
(
prevChild
nextIndex
lastIndex
)
;
lastIndex
=
Math
.
max
(
prevChild
.
_mountIndex
lastIndex
)
;
prevChild
.
_mountIndex
=
nextIndex
;
}
else
{
if
(
prevChild
)
{
lastIndex
=
Math
.
max
(
prevChild
.
_mountIndex
lastIndex
)
;
this
.
_unmountChild
(
prevChild
)
;
}
this
.
_mountChildByNameAtIndex
(
nextChild
name
nextIndex
transaction
context
)
;
}
nextIndex
+
+
;
}
for
(
name
in
prevChildren
)
{
if
(
prevChildren
.
hasOwnProperty
(
name
)
&
&
!
(
nextChildren
&
&
nextChildren
.
hasOwnProperty
(
name
)
)
)
{
this
.
_unmountChild
(
prevChildren
[
name
]
)
;
}
}
}
unmountChildren
:
function
(
)
{
var
renderedChildren
=
this
.
_renderedChildren
;
ReactChildReconciler
.
unmountChildren
(
renderedChildren
)
;
this
.
_renderedChildren
=
null
;
}
moveChild
:
function
(
child
toIndex
lastIndex
)
{
if
(
child
.
_mountIndex
<
lastIndex
)
{
enqueueMove
(
this
.
_rootNodeID
child
.
_mountIndex
toIndex
)
;
}
}
createChild
:
function
(
child
mountImage
)
{
enqueueInsertMarkup
(
this
.
_rootNodeID
mountImage
child
.
_mountIndex
)
;
}
removeChild
:
function
(
child
)
{
enqueueRemove
(
this
.
_rootNodeID
child
.
_mountIndex
)
;
}
setTextContent
:
function
(
textContent
)
{
enqueueTextContent
(
this
.
_rootNodeID
textContent
)
;
}
setMarkup
:
function
(
markup
)
{
enqueueSetMarkup
(
this
.
_rootNodeID
markup
)
;
}
_mountChildByNameAtIndex
:
function
(
child
name
index
transaction
context
)
{
var
rootID
=
this
.
_rootNodeID
+
name
;
var
mountImage
=
ReactReconciler
.
mountComponent
(
child
rootID
transaction
context
)
;
child
.
_mountIndex
=
index
;
this
.
createChild
(
child
mountImage
)
;
}
_unmountChild
:
function
(
child
)
{
this
.
removeChild
(
child
)
;
child
.
_mountIndex
=
null
;
}
}
}
;
module
.
exports
=
ReactMultiChild
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactReconciler
=
__webpack_require__
(
65
)
;
var
instantiateReactComponent
=
__webpack_require__
(
77
)
;
var
shouldUpdateReactComponent
=
__webpack_require__
(
82
)
;
var
traverseAllChildren
=
__webpack_require__
(
126
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
instantiateChild
(
childInstances
child
name
)
{
var
keyUnique
=
childInstances
[
name
]
=
=
=
undefined
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
keyUnique
'
flattenChildren
(
.
.
.
)
:
Encountered
two
children
with
the
same
key
'
+
'
%
s
.
Child
keys
must
be
unique
;
when
two
children
share
a
key
only
'
+
'
the
first
child
will
be
used
.
'
name
)
:
undefined
;
}
if
(
child
!
=
null
&
&
keyUnique
)
{
childInstances
[
name
]
=
instantiateReactComponent
(
child
null
)
;
}
}
var
ReactChildReconciler
=
{
instantiateChildren
:
function
(
nestedChildNodes
transaction
context
)
{
if
(
nestedChildNodes
=
=
null
)
{
return
null
;
}
var
childInstances
=
{
}
;
traverseAllChildren
(
nestedChildNodes
instantiateChild
childInstances
)
;
return
childInstances
;
}
updateChildren
:
function
(
prevChildren
nextChildren
transaction
context
)
{
if
(
!
nextChildren
&
&
!
prevChildren
)
{
return
null
;
}
var
name
;
for
(
name
in
nextChildren
)
{
if
(
!
nextChildren
.
hasOwnProperty
(
name
)
)
{
continue
;
}
var
prevChild
=
prevChildren
&
&
prevChildren
[
name
]
;
var
prevElement
=
prevChild
&
&
prevChild
.
_currentElement
;
var
nextElement
=
nextChildren
[
name
]
;
if
(
prevChild
!
=
null
&
&
shouldUpdateReactComponent
(
prevElement
nextElement
)
)
{
ReactReconciler
.
receiveComponent
(
prevChild
nextElement
transaction
context
)
;
nextChildren
[
name
]
=
prevChild
;
}
else
{
if
(
prevChild
)
{
ReactReconciler
.
unmountComponent
(
prevChild
name
)
;
}
var
nextChildInstance
=
instantiateReactComponent
(
nextElement
null
)
;
nextChildren
[
name
]
=
nextChildInstance
;
}
}
for
(
name
in
prevChildren
)
{
if
(
prevChildren
.
hasOwnProperty
(
name
)
&
&
!
(
nextChildren
&
&
nextChildren
.
hasOwnProperty
(
name
)
)
)
{
ReactReconciler
.
unmountComponent
(
prevChildren
[
name
]
)
;
}
}
return
nextChildren
;
}
unmountChildren
:
function
(
renderedChildren
)
{
for
(
var
name
in
renderedChildren
)
{
if
(
renderedChildren
.
hasOwnProperty
(
name
)
)
{
var
renderedChild
=
renderedChildren
[
name
]
;
ReactReconciler
.
unmountComponent
(
renderedChild
)
;
}
}
}
}
;
module
.
exports
=
ReactChildReconciler
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
traverseAllChildren
=
__webpack_require__
(
126
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
flattenSingleChildIntoContext
(
traverseContext
child
name
)
{
var
result
=
traverseContext
;
var
keyUnique
=
result
[
name
]
=
=
=
undefined
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
keyUnique
'
flattenChildren
(
.
.
.
)
:
Encountered
two
children
with
the
same
key
'
+
'
%
s
.
Child
keys
must
be
unique
;
when
two
children
share
a
key
only
'
+
'
the
first
child
will
be
used
.
'
name
)
:
undefined
;
}
if
(
keyUnique
&
&
child
!
=
null
)
{
result
[
name
]
=
child
;
}
}
function
flattenChildren
(
children
)
{
if
(
children
=
=
null
)
{
return
children
;
}
var
result
=
{
}
;
traverseAllChildren
(
children
flattenSingleChildIntoContext
result
)
;
return
result
;
}
module
.
exports
=
flattenChildren
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
shallowEqual
(
objA
objB
)
{
if
(
objA
=
=
=
objB
)
{
return
true
;
}
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
var
bHasOwnProperty
=
hasOwnProperty
.
bind
(
objB
)
;
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
bHasOwnProperty
(
keysA
[
i
]
)
|
|
objA
[
keysA
[
i
]
]
!
=
=
objB
[
keysA
[
i
]
]
)
{
return
false
;
}
}
return
true
;
}
module
.
exports
=
shallowEqual
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventListener
=
__webpack_require__
(
134
)
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
ReactInstanceHandles
=
__webpack_require__
(
60
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
getEventTarget
=
__webpack_require__
(
96
)
;
var
getUnboundedScrollPosition
=
__webpack_require__
(
135
)
;
var
DOCUMENT_FRAGMENT_NODE_TYPE
=
11
;
function
findParent
(
node
)
{
var
nodeID
=
ReactMount
.
getID
(
node
)
;
var
rootID
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
nodeID
)
;
var
container
=
ReactMount
.
findReactContainerForID
(
rootID
)
;
var
parent
=
ReactMount
.
getFirstReactDOM
(
container
)
;
return
parent
;
}
function
TopLevelCallbackBookKeeping
(
topLevelType
nativeEvent
)
{
this
.
topLevelType
=
topLevelType
;
this
.
nativeEvent
=
nativeEvent
;
this
.
ancestors
=
[
]
;
}
assign
(
TopLevelCallbackBookKeeping
.
prototype
{
destructor
:
function
(
)
{
this
.
topLevelType
=
null
;
this
.
nativeEvent
=
null
;
this
.
ancestors
.
length
=
0
;
}
}
)
;
PooledClass
.
addPoolingTo
(
TopLevelCallbackBookKeeping
PooledClass
.
twoArgumentPooler
)
;
function
handleTopLevelImpl
(
bookKeeping
)
{
void
handleTopLevelWithPath
;
handleTopLevelWithoutPath
(
bookKeeping
)
;
}
function
handleTopLevelWithoutPath
(
bookKeeping
)
{
var
topLevelTarget
=
ReactMount
.
getFirstReactDOM
(
getEventTarget
(
bookKeeping
.
nativeEvent
)
)
|
|
window
;
var
ancestor
=
topLevelTarget
;
while
(
ancestor
)
{
bookKeeping
.
ancestors
.
push
(
ancestor
)
;
ancestor
=
findParent
(
ancestor
)
;
}
for
(
var
i
=
0
;
i
<
bookKeeping
.
ancestors
.
length
;
i
+
+
)
{
topLevelTarget
=
bookKeeping
.
ancestors
[
i
]
;
var
topLevelTargetID
=
ReactMount
.
getID
(
topLevelTarget
)
|
|
'
'
;
ReactEventListener
.
_handleTopLevel
(
bookKeeping
.
topLevelType
topLevelTarget
topLevelTargetID
bookKeeping
.
nativeEvent
getEventTarget
(
bookKeeping
.
nativeEvent
)
)
;
}
}
function
handleTopLevelWithPath
(
bookKeeping
)
{
var
path
=
bookKeeping
.
nativeEvent
.
path
;
var
currentNativeTarget
=
path
[
0
]
;
var
eventsFired
=
0
;
for
(
var
i
=
0
;
i
<
path
.
length
;
i
+
+
)
{
var
currentPathElement
=
path
[
i
]
;
if
(
currentPathElement
.
nodeType
=
=
=
DOCUMENT_FRAGMENT_NODE_TYPE
)
{
currentNativeTarget
=
path
[
i
+
1
]
;
}
var
reactParent
=
ReactMount
.
getFirstReactDOM
(
currentPathElement
)
;
if
(
reactParent
=
=
=
currentPathElement
)
{
var
currentPathElementID
=
ReactMount
.
getID
(
currentPathElement
)
;
var
newRootID
=
ReactInstanceHandles
.
getReactRootIDFromNodeID
(
currentPathElementID
)
;
bookKeeping
.
ancestors
.
push
(
currentPathElement
)
;
var
topLevelTargetID
=
ReactMount
.
getID
(
currentPathElement
)
|
|
'
'
;
eventsFired
+
+
;
ReactEventListener
.
_handleTopLevel
(
bookKeeping
.
topLevelType
currentPathElement
topLevelTargetID
bookKeeping
.
nativeEvent
currentNativeTarget
)
;
while
(
currentPathElementID
!
=
=
newRootID
)
{
i
+
+
;
currentPathElement
=
path
[
i
]
;
currentPathElementID
=
ReactMount
.
getID
(
currentPathElement
)
;
}
}
}
if
(
eventsFired
=
=
=
0
)
{
ReactEventListener
.
_handleTopLevel
(
bookKeeping
.
topLevelType
window
'
'
bookKeeping
.
nativeEvent
getEventTarget
(
bookKeeping
.
nativeEvent
)
)
;
}
}
function
scrollValueMonitor
(
cb
)
{
var
scrollPosition
=
getUnboundedScrollPosition
(
window
)
;
cb
(
scrollPosition
)
;
}
var
ReactEventListener
=
{
_enabled
:
true
_handleTopLevel
:
null
WINDOW_HANDLE
:
ExecutionEnvironment
.
canUseDOM
?
window
:
null
setHandleTopLevel
:
function
(
handleTopLevel
)
{
ReactEventListener
.
_handleTopLevel
=
handleTopLevel
;
}
setEnabled
:
function
(
enabled
)
{
ReactEventListener
.
_enabled
=
!
!
enabled
;
}
isEnabled
:
function
(
)
{
return
ReactEventListener
.
_enabled
;
}
trapBubbledEvent
:
function
(
topLevelType
handlerBaseName
handle
)
{
var
element
=
handle
;
if
(
!
element
)
{
return
null
;
}
return
EventListener
.
listen
(
element
handlerBaseName
ReactEventListener
.
dispatchEvent
.
bind
(
null
topLevelType
)
)
;
}
trapCapturedEvent
:
function
(
topLevelType
handlerBaseName
handle
)
{
var
element
=
handle
;
if
(
!
element
)
{
return
null
;
}
return
EventListener
.
capture
(
element
handlerBaseName
ReactEventListener
.
dispatchEvent
.
bind
(
null
topLevelType
)
)
;
}
monitorScrollValue
:
function
(
refresh
)
{
var
callback
=
scrollValueMonitor
.
bind
(
null
refresh
)
;
EventListener
.
listen
(
window
'
scroll
'
callback
)
;
}
dispatchEvent
:
function
(
topLevelType
nativeEvent
)
{
if
(
!
ReactEventListener
.
_enabled
)
{
return
;
}
var
bookKeeping
=
TopLevelCallbackBookKeeping
.
getPooled
(
topLevelType
nativeEvent
)
;
try
{
ReactUpdates
.
batchedUpdates
(
handleTopLevelImpl
bookKeeping
)
;
}
finally
{
TopLevelCallbackBookKeeping
.
release
(
bookKeeping
)
;
}
}
}
;
module
.
exports
=
ReactEventListener
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
EventListener
=
{
listen
:
function
(
target
eventType
callback
)
{
if
(
target
.
addEventListener
)
{
target
.
addEventListener
(
eventType
callback
false
)
;
return
{
remove
:
function
(
)
{
target
.
removeEventListener
(
eventType
callback
false
)
;
}
}
;
}
else
if
(
target
.
attachEvent
)
{
target
.
attachEvent
(
'
on
'
+
eventType
callback
)
;
return
{
remove
:
function
(
)
{
target
.
detachEvent
(
'
on
'
+
eventType
callback
)
;
}
}
;
}
}
capture
:
function
(
target
eventType
callback
)
{
if
(
target
.
addEventListener
)
{
target
.
addEventListener
(
eventType
callback
true
)
;
return
{
remove
:
function
(
)
{
target
.
removeEventListener
(
eventType
callback
true
)
;
}
}
;
}
else
{
if
(
false
)
{
console
.
error
(
'
Attempted
to
listen
to
events
during
the
capture
phase
on
a
'
+
'
browser
that
does
not
support
the
capture
phase
.
Your
application
'
+
'
will
not
receive
some
events
.
'
)
;
}
return
{
remove
:
emptyFunction
}
;
}
}
registerDefault
:
function
(
)
{
}
}
;
module
.
exports
=
EventListener
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
getUnboundedScrollPosition
(
scrollable
)
{
if
(
scrollable
=
=
=
window
)
{
return
{
x
:
window
.
pageXOffset
|
|
document
.
documentElement
.
scrollLeft
y
:
window
.
pageYOffset
|
|
document
.
documentElement
.
scrollTop
}
;
}
return
{
x
:
scrollable
.
scrollLeft
y
:
scrollable
.
scrollTop
}
;
}
module
.
exports
=
getUnboundedScrollPosition
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
DOMProperty
=
__webpack_require__
(
38
)
;
var
EventPluginHub
=
__webpack_require__
(
46
)
;
var
ReactComponentEnvironment
=
__webpack_require__
(
79
)
;
var
ReactClass
=
__webpack_require__
(
137
)
;
var
ReactEmptyComponent
=
__webpack_require__
(
83
)
;
var
ReactBrowserEventEmitter
=
__webpack_require__
(
44
)
;
var
ReactNativeComponent
=
__webpack_require__
(
84
)
;
var
ReactPerf
=
__webpack_require__
(
33
)
;
var
ReactRootIndex
=
__webpack_require__
(
61
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
ReactInjection
=
{
Component
:
ReactComponentEnvironment
.
injection
Class
:
ReactClass
.
injection
DOMProperty
:
DOMProperty
.
injection
EmptyComponent
:
ReactEmptyComponent
.
injection
EventPluginHub
:
EventPluginHub
.
injection
EventEmitter
:
ReactBrowserEventEmitter
.
injection
NativeComponent
:
ReactNativeComponent
.
injection
Perf
:
ReactPerf
.
injection
RootIndex
:
ReactRootIndex
.
injection
Updates
:
ReactUpdates
.
injection
}
;
module
.
exports
=
ReactInjection
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactComponent
=
__webpack_require__
(
138
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactPropTypeLocations
=
__webpack_require__
(
80
)
;
var
ReactPropTypeLocationNames
=
__webpack_require__
(
81
)
;
var
ReactNoopUpdateQueue
=
__webpack_require__
(
139
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
emptyObject
=
__webpack_require__
(
73
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
keyMirror
=
__webpack_require__
(
32
)
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
warning
=
__webpack_require__
(
40
)
;
var
MIXINS_KEY
=
keyOf
(
{
mixins
:
null
}
)
;
var
SpecPolicy
=
keyMirror
(
{
DEFINE_ONCE
:
null
DEFINE_MANY
:
null
OVERRIDE_BASE
:
null
DEFINE_MANY_MERGED
:
null
}
)
;
var
injectedMixins
=
[
]
;
var
warnedSetProps
=
false
;
function
warnSetProps
(
)
{
if
(
!
warnedSetProps
)
{
warnedSetProps
=
true
;
false
?
warning
(
false
'
setProps
(
.
.
.
)
and
replaceProps
(
.
.
.
)
are
deprecated
.
'
+
'
Instead
call
render
again
at
the
top
level
.
'
)
:
undefined
;
}
}
var
ReactClassInterface
=
{
mixins
:
SpecPolicy
.
DEFINE_MANY
statics
:
SpecPolicy
.
DEFINE_MANY
propTypes
:
SpecPolicy
.
DEFINE_MANY
contextTypes
:
SpecPolicy
.
DEFINE_MANY
childContextTypes
:
SpecPolicy
.
DEFINE_MANY
getDefaultProps
:
SpecPolicy
.
DEFINE_MANY_MERGED
getInitialState
:
SpecPolicy
.
DEFINE_MANY_MERGED
getChildContext
:
SpecPolicy
.
DEFINE_MANY_MERGED
render
:
SpecPolicy
.
DEFINE_ONCE
componentWillMount
:
SpecPolicy
.
DEFINE_MANY
componentDidMount
:
SpecPolicy
.
DEFINE_MANY
componentWillReceiveProps
:
SpecPolicy
.
DEFINE_MANY
shouldComponentUpdate
:
SpecPolicy
.
DEFINE_ONCE
componentWillUpdate
:
SpecPolicy
.
DEFINE_MANY
componentDidUpdate
:
SpecPolicy
.
DEFINE_MANY
componentWillUnmount
:
SpecPolicy
.
DEFINE_MANY
updateComponent
:
SpecPolicy
.
OVERRIDE_BASE
}
;
var
RESERVED_SPEC_KEYS
=
{
displayName
:
function
(
Constructor
displayName
)
{
Constructor
.
displayName
=
displayName
;
}
mixins
:
function
(
Constructor
mixins
)
{
if
(
mixins
)
{
for
(
var
i
=
0
;
i
<
mixins
.
length
;
i
+
+
)
{
mixSpecIntoComponent
(
Constructor
mixins
[
i
]
)
;
}
}
}
childContextTypes
:
function
(
Constructor
childContextTypes
)
{
if
(
false
)
{
validateTypeDef
(
Constructor
childContextTypes
ReactPropTypeLocations
.
childContext
)
;
}
Constructor
.
childContextTypes
=
assign
(
{
}
Constructor
.
childContextTypes
childContextTypes
)
;
}
contextTypes
:
function
(
Constructor
contextTypes
)
{
if
(
false
)
{
validateTypeDef
(
Constructor
contextTypes
ReactPropTypeLocations
.
context
)
;
}
Constructor
.
contextTypes
=
assign
(
{
}
Constructor
.
contextTypes
contextTypes
)
;
}
getDefaultProps
:
function
(
Constructor
getDefaultProps
)
{
if
(
Constructor
.
getDefaultProps
)
{
Constructor
.
getDefaultProps
=
createMergedResultFunction
(
Constructor
.
getDefaultProps
getDefaultProps
)
;
}
else
{
Constructor
.
getDefaultProps
=
getDefaultProps
;
}
}
propTypes
:
function
(
Constructor
propTypes
)
{
if
(
false
)
{
validateTypeDef
(
Constructor
propTypes
ReactPropTypeLocations
.
prop
)
;
}
Constructor
.
propTypes
=
assign
(
{
}
Constructor
.
propTypes
propTypes
)
;
}
statics
:
function
(
Constructor
statics
)
{
mixStaticSpecIntoComponent
(
Constructor
statics
)
;
}
autobind
:
function
(
)
{
}
}
;
function
validateTypeDef
(
Constructor
typeDef
location
)
{
for
(
var
propName
in
typeDef
)
{
if
(
typeDef
.
hasOwnProperty
(
propName
)
)
{
false
?
warning
(
typeof
typeDef
[
propName
]
=
=
=
'
function
'
'
%
s
:
%
s
type
%
s
is
invalid
;
it
must
be
a
function
usually
from
'
+
'
React
.
PropTypes
.
'
Constructor
.
displayName
|
|
'
ReactClass
'
ReactPropTypeLocationNames
[
location
]
propName
)
:
undefined
;
}
}
}
function
validateMethodOverride
(
proto
name
)
{
var
specPolicy
=
ReactClassInterface
.
hasOwnProperty
(
name
)
?
ReactClassInterface
[
name
]
:
null
;
if
(
ReactClassMixin
.
hasOwnProperty
(
name
)
)
{
!
(
specPolicy
=
=
=
SpecPolicy
.
OVERRIDE_BASE
)
?
false
?
invariant
(
false
'
ReactClassInterface
:
You
are
attempting
to
override
'
+
'
%
s
from
your
class
specification
.
Ensure
that
your
method
names
'
+
'
do
not
overlap
with
React
methods
.
'
name
)
:
invariant
(
false
)
:
undefined
;
}
if
(
proto
.
hasOwnProperty
(
name
)
)
{
!
(
specPolicy
=
=
=
SpecPolicy
.
DEFINE_MANY
|
|
specPolicy
=
=
=
SpecPolicy
.
DEFINE_MANY_MERGED
)
?
false
?
invariant
(
false
'
ReactClassInterface
:
You
are
attempting
to
define
'
+
'
%
s
on
your
component
more
than
once
.
This
conflict
may
be
due
'
+
'
to
a
mixin
.
'
name
)
:
invariant
(
false
)
:
undefined
;
}
}
function
mixSpecIntoComponent
(
Constructor
spec
)
{
if
(
!
spec
)
{
return
;
}
!
(
typeof
spec
!
=
=
'
function
'
)
?
false
?
invariant
(
false
'
ReactClass
:
You
\
'
re
attempting
to
'
+
'
use
a
component
class
as
a
mixin
.
Instead
just
use
a
regular
object
.
'
)
:
invariant
(
false
)
:
undefined
;
!
!
ReactElement
.
isValidElement
(
spec
)
?
false
?
invariant
(
false
'
ReactClass
:
You
\
'
re
attempting
to
'
+
'
use
a
component
as
a
mixin
.
Instead
just
use
a
regular
object
.
'
)
:
invariant
(
false
)
:
undefined
;
var
proto
=
Constructor
.
prototype
;
if
(
spec
.
hasOwnProperty
(
MIXINS_KEY
)
)
{
RESERVED_SPEC_KEYS
.
mixins
(
Constructor
spec
.
mixins
)
;
}
for
(
var
name
in
spec
)
{
if
(
!
spec
.
hasOwnProperty
(
name
)
)
{
continue
;
}
if
(
name
=
=
=
MIXINS_KEY
)
{
continue
;
}
var
property
=
spec
[
name
]
;
validateMethodOverride
(
proto
name
)
;
if
(
RESERVED_SPEC_KEYS
.
hasOwnProperty
(
name
)
)
{
RESERVED_SPEC_KEYS
[
name
]
(
Constructor
property
)
;
}
else
{
var
isReactClassMethod
=
ReactClassInterface
.
hasOwnProperty
(
name
)
;
var
isAlreadyDefined
=
proto
.
hasOwnProperty
(
name
)
;
var
isFunction
=
typeof
property
=
=
=
'
function
'
;
var
shouldAutoBind
=
isFunction
&
&
!
isReactClassMethod
&
&
!
isAlreadyDefined
&
&
spec
.
autobind
!
=
=
false
;
if
(
shouldAutoBind
)
{
if
(
!
proto
.
__reactAutoBindMap
)
{
proto
.
__reactAutoBindMap
=
{
}
;
}
proto
.
__reactAutoBindMap
[
name
]
=
property
;
proto
[
name
]
=
property
;
}
else
{
if
(
isAlreadyDefined
)
{
var
specPolicy
=
ReactClassInterface
[
name
]
;
!
(
isReactClassMethod
&
&
(
specPolicy
=
=
=
SpecPolicy
.
DEFINE_MANY_MERGED
|
|
specPolicy
=
=
=
SpecPolicy
.
DEFINE_MANY
)
)
?
false
?
invariant
(
false
'
ReactClass
:
Unexpected
spec
policy
%
s
for
key
%
s
'
+
'
when
mixing
in
component
specs
.
'
specPolicy
name
)
:
invariant
(
false
)
:
undefined
;
if
(
specPolicy
=
=
=
SpecPolicy
.
DEFINE_MANY_MERGED
)
{
proto
[
name
]
=
createMergedResultFunction
(
proto
[
name
]
property
)
;
}
else
if
(
specPolicy
=
=
=
SpecPolicy
.
DEFINE_MANY
)
{
proto
[
name
]
=
createChainedFunction
(
proto
[
name
]
property
)
;
}
}
else
{
proto
[
name
]
=
property
;
if
(
false
)
{
if
(
typeof
property
=
=
=
'
function
'
&
&
spec
.
displayName
)
{
proto
[
name
]
.
displayName
=
spec
.
displayName
+
'
_
'
+
name
;
}
}
}
}
}
}
}
function
mixStaticSpecIntoComponent
(
Constructor
statics
)
{
if
(
!
statics
)
{
return
;
}
for
(
var
name
in
statics
)
{
var
property
=
statics
[
name
]
;
if
(
!
statics
.
hasOwnProperty
(
name
)
)
{
continue
;
}
var
isReserved
=
(
name
in
RESERVED_SPEC_KEYS
)
;
!
!
isReserved
?
false
?
invariant
(
false
'
ReactClass
:
You
are
attempting
to
define
a
reserved
'
+
'
property
%
s
that
shouldn
\
'
t
be
on
the
"
statics
"
key
.
Define
it
'
+
'
as
an
instance
property
instead
;
it
will
still
be
accessible
on
the
'
+
'
constructor
.
'
name
)
:
invariant
(
false
)
:
undefined
;
var
isInherited
=
(
name
in
Constructor
)
;
!
!
isInherited
?
false
?
invariant
(
false
'
ReactClass
:
You
are
attempting
to
define
'
+
'
%
s
on
your
component
more
than
once
.
This
conflict
may
be
'
+
'
due
to
a
mixin
.
'
name
)
:
invariant
(
false
)
:
undefined
;
Constructor
[
name
]
=
property
;
}
}
function
mergeIntoWithNoDuplicateKeys
(
one
two
)
{
!
(
one
&
&
two
&
&
typeof
one
=
=
=
'
object
'
&
&
typeof
two
=
=
=
'
object
'
)
?
false
?
invariant
(
false
'
mergeIntoWithNoDuplicateKeys
(
)
:
Cannot
merge
non
-
objects
.
'
)
:
invariant
(
false
)
:
undefined
;
for
(
var
key
in
two
)
{
if
(
two
.
hasOwnProperty
(
key
)
)
{
!
(
one
[
key
]
=
=
=
undefined
)
?
false
?
invariant
(
false
'
mergeIntoWithNoDuplicateKeys
(
)
:
'
+
'
Tried
to
merge
two
objects
with
the
same
key
:
%
s
.
This
conflict
'
+
'
may
be
due
to
a
mixin
;
in
particular
this
may
be
caused
by
two
'
+
'
getInitialState
(
)
or
getDefaultProps
(
)
methods
returning
objects
'
+
'
with
clashing
keys
.
'
key
)
:
invariant
(
false
)
:
undefined
;
one
[
key
]
=
two
[
key
]
;
}
}
return
one
;
}
function
createMergedResultFunction
(
one
two
)
{
return
function
mergedResult
(
)
{
var
a
=
one
.
apply
(
this
arguments
)
;
var
b
=
two
.
apply
(
this
arguments
)
;
if
(
a
=
=
null
)
{
return
b
;
}
else
if
(
b
=
=
null
)
{
return
a
;
}
var
c
=
{
}
;
mergeIntoWithNoDuplicateKeys
(
c
a
)
;
mergeIntoWithNoDuplicateKeys
(
c
b
)
;
return
c
;
}
;
}
function
createChainedFunction
(
one
two
)
{
return
function
chainedFunction
(
)
{
one
.
apply
(
this
arguments
)
;
two
.
apply
(
this
arguments
)
;
}
;
}
function
bindAutoBindMethod
(
component
method
)
{
var
boundMethod
=
method
.
bind
(
component
)
;
if
(
false
)
{
boundMethod
.
__reactBoundContext
=
component
;
boundMethod
.
__reactBoundMethod
=
method
;
boundMethod
.
__reactBoundArguments
=
null
;
var
componentName
=
component
.
constructor
.
displayName
;
var
_bind
=
boundMethod
.
bind
;
boundMethod
.
bind
=
function
(
newThis
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
if
(
newThis
!
=
=
component
&
&
newThis
!
=
=
null
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
bind
(
)
:
React
component
methods
may
only
be
bound
to
the
'
+
'
component
instance
.
See
%
s
'
componentName
)
:
undefined
;
}
else
if
(
!
args
.
length
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
bind
(
)
:
You
are
binding
a
component
method
to
the
component
.
'
+
'
React
does
this
for
you
automatically
in
a
high
-
performance
'
+
'
way
so
you
can
safely
remove
this
call
.
See
%
s
'
componentName
)
:
undefined
;
return
boundMethod
;
}
var
reboundMethod
=
_bind
.
apply
(
boundMethod
arguments
)
;
reboundMethod
.
__reactBoundContext
=
component
;
reboundMethod
.
__reactBoundMethod
=
method
;
reboundMethod
.
__reactBoundArguments
=
args
;
return
reboundMethod
;
}
;
}
return
boundMethod
;
}
function
bindAutoBindMethods
(
component
)
{
for
(
var
autoBindKey
in
component
.
__reactAutoBindMap
)
{
if
(
component
.
__reactAutoBindMap
.
hasOwnProperty
(
autoBindKey
)
)
{
var
method
=
component
.
__reactAutoBindMap
[
autoBindKey
]
;
component
[
autoBindKey
]
=
bindAutoBindMethod
(
component
method
)
;
}
}
}
var
ReactClassMixin
=
{
replaceState
:
function
(
newState
callback
)
{
this
.
updater
.
enqueueReplaceState
(
this
newState
)
;
if
(
callback
)
{
this
.
updater
.
enqueueCallback
(
this
callback
)
;
}
}
isMounted
:
function
(
)
{
return
this
.
updater
.
isMounted
(
this
)
;
}
setProps
:
function
(
partialProps
callback
)
{
if
(
false
)
{
warnSetProps
(
)
;
}
this
.
updater
.
enqueueSetProps
(
this
partialProps
)
;
if
(
callback
)
{
this
.
updater
.
enqueueCallback
(
this
callback
)
;
}
}
replaceProps
:
function
(
newProps
callback
)
{
if
(
false
)
{
warnSetProps
(
)
;
}
this
.
updater
.
enqueueReplaceProps
(
this
newProps
)
;
if
(
callback
)
{
this
.
updater
.
enqueueCallback
(
this
callback
)
;
}
}
}
;
var
ReactClassComponent
=
function
(
)
{
}
;
assign
(
ReactClassComponent
.
prototype
ReactComponent
.
prototype
ReactClassMixin
)
;
var
ReactClass
=
{
createClass
:
function
(
spec
)
{
var
Constructor
=
function
(
props
context
updater
)
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
this
instanceof
Constructor
'
Something
is
calling
a
React
component
directly
.
Use
a
factory
or
'
+
'
JSX
instead
.
See
:
https
:
/
/
fb
.
me
/
react
-
legacyfactory
'
)
:
undefined
;
}
if
(
this
.
__reactAutoBindMap
)
{
bindAutoBindMethods
(
this
)
;
}
this
.
props
=
props
;
this
.
context
=
context
;
this
.
refs
=
emptyObject
;
this
.
updater
=
updater
|
|
ReactNoopUpdateQueue
;
this
.
state
=
null
;
var
initialState
=
this
.
getInitialState
?
this
.
getInitialState
(
)
:
null
;
if
(
false
)
{
if
(
typeof
initialState
=
=
=
'
undefined
'
&
&
this
.
getInitialState
.
_isMockFunction
)
{
initialState
=
null
;
}
}
!
(
typeof
initialState
=
=
=
'
object
'
&
&
!
Array
.
isArray
(
initialState
)
)
?
false
?
invariant
(
false
'
%
s
.
getInitialState
(
)
:
must
return
an
object
or
null
'
Constructor
.
displayName
|
|
'
ReactCompositeComponent
'
)
:
invariant
(
false
)
:
undefined
;
this
.
state
=
initialState
;
}
;
Constructor
.
prototype
=
new
ReactClassComponent
(
)
;
Constructor
.
prototype
.
constructor
=
Constructor
;
injectedMixins
.
forEach
(
mixSpecIntoComponent
.
bind
(
null
Constructor
)
)
;
mixSpecIntoComponent
(
Constructor
spec
)
;
if
(
Constructor
.
getDefaultProps
)
{
Constructor
.
defaultProps
=
Constructor
.
getDefaultProps
(
)
;
}
if
(
false
)
{
if
(
Constructor
.
getDefaultProps
)
{
Constructor
.
getDefaultProps
.
isReactClassApproved
=
{
}
;
}
if
(
Constructor
.
prototype
.
getInitialState
)
{
Constructor
.
prototype
.
getInitialState
.
isReactClassApproved
=
{
}
;
}
}
!
Constructor
.
prototype
.
render
?
false
?
invariant
(
false
'
createClass
(
.
.
.
)
:
Class
specification
must
implement
a
render
method
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
Constructor
.
prototype
.
componentShouldUpdate
'
%
s
has
a
method
called
'
+
'
componentShouldUpdate
(
)
.
Did
you
mean
shouldComponentUpdate
(
)
?
'
+
'
The
name
is
phrased
as
a
question
because
the
function
is
'
+
'
expected
to
return
a
value
.
'
spec
.
displayName
|
|
'
A
component
'
)
:
undefined
;
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
!
Constructor
.
prototype
.
componentWillRecieveProps
'
%
s
has
a
method
called
'
+
'
componentWillRecieveProps
(
)
.
Did
you
mean
componentWillReceiveProps
(
)
?
'
spec
.
displayName
|
|
'
A
component
'
)
:
undefined
;
}
for
(
var
methodName
in
ReactClassInterface
)
{
if
(
!
Constructor
.
prototype
[
methodName
]
)
{
Constructor
.
prototype
[
methodName
]
=
null
;
}
}
return
Constructor
;
}
injection
:
{
injectMixin
:
function
(
mixin
)
{
injectedMixins
.
push
(
mixin
)
;
}
}
}
;
module
.
exports
=
ReactClass
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactNoopUpdateQueue
=
__webpack_require__
(
139
)
;
var
canDefineProperty
=
__webpack_require__
(
58
)
;
var
emptyObject
=
__webpack_require__
(
73
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
ReactComponent
(
props
context
updater
)
{
this
.
props
=
props
;
this
.
context
=
context
;
this
.
refs
=
emptyObject
;
this
.
updater
=
updater
|
|
ReactNoopUpdateQueue
;
}
ReactComponent
.
prototype
.
isReactComponent
=
{
}
;
ReactComponent
.
prototype
.
setState
=
function
(
partialState
callback
)
{
!
(
typeof
partialState
=
=
=
'
object
'
|
|
typeof
partialState
=
=
=
'
function
'
|
|
partialState
=
=
null
)
?
false
?
invariant
(
false
'
setState
(
.
.
.
)
:
takes
an
object
of
state
variables
to
update
or
a
'
+
'
function
which
returns
an
object
of
state
variables
.
'
)
:
invariant
(
false
)
:
undefined
;
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
partialState
!
=
null
'
setState
(
.
.
.
)
:
You
passed
an
undefined
or
null
state
object
;
'
+
'
instead
use
forceUpdate
(
)
.
'
)
:
undefined
;
}
this
.
updater
.
enqueueSetState
(
this
partialState
)
;
if
(
callback
)
{
this
.
updater
.
enqueueCallback
(
this
callback
)
;
}
}
;
ReactComponent
.
prototype
.
forceUpdate
=
function
(
callback
)
{
this
.
updater
.
enqueueForceUpdate
(
this
)
;
if
(
callback
)
{
this
.
updater
.
enqueueCallback
(
this
callback
)
;
}
}
;
if
(
false
)
{
var
deprecatedAPIs
=
{
getDOMNode
:
[
'
getDOMNode
'
'
Use
ReactDOM
.
findDOMNode
(
component
)
instead
.
'
]
isMounted
:
[
'
isMounted
'
'
Instead
make
sure
to
clean
up
subscriptions
and
pending
requests
in
'
+
'
componentWillUnmount
to
prevent
memory
leaks
.
'
]
replaceProps
:
[
'
replaceProps
'
'
Instead
call
render
again
at
the
top
level
.
'
]
replaceState
:
[
'
replaceState
'
'
Refactor
your
code
to
use
setState
instead
(
see
'
+
'
https
:
/
/
github
.
com
/
facebook
/
react
/
issues
/
3236
)
.
'
]
setProps
:
[
'
setProps
'
'
Instead
call
render
again
at
the
top
level
.
'
]
}
;
var
defineDeprecationWarning
=
function
(
methodName
info
)
{
if
(
canDefineProperty
)
{
Object
.
defineProperty
(
ReactComponent
.
prototype
methodName
{
get
:
function
(
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
%
s
(
.
.
.
)
is
deprecated
in
plain
JavaScript
React
classes
.
%
s
'
info
[
0
]
info
[
1
]
)
:
undefined
;
return
undefined
;
}
}
)
;
}
}
;
for
(
var
fnName
in
deprecatedAPIs
)
{
if
(
deprecatedAPIs
.
hasOwnProperty
(
fnName
)
)
{
defineDeprecationWarning
(
fnName
deprecatedAPIs
[
fnName
]
)
;
}
}
}
module
.
exports
=
ReactComponent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
warning
=
__webpack_require__
(
40
)
;
function
warnTDZ
(
publicInstance
callerName
)
{
if
(
false
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
%
s
(
.
.
.
)
:
Can
only
update
a
mounted
or
mounting
component
.
'
+
'
This
usually
means
you
called
%
s
(
)
on
an
unmounted
component
.
'
+
'
This
is
a
no
-
op
.
Please
check
the
code
for
the
%
s
component
.
'
callerName
callerName
publicInstance
.
constructor
&
&
publicInstance
.
constructor
.
displayName
|
|
'
'
)
:
undefined
;
}
}
var
ReactNoopUpdateQueue
=
{
isMounted
:
function
(
publicInstance
)
{
return
false
;
}
enqueueCallback
:
function
(
publicInstance
callback
)
{
}
enqueueForceUpdate
:
function
(
publicInstance
)
{
warnTDZ
(
publicInstance
'
forceUpdate
'
)
;
}
enqueueReplaceState
:
function
(
publicInstance
completeState
)
{
warnTDZ
(
publicInstance
'
replaceState
'
)
;
}
enqueueSetState
:
function
(
publicInstance
partialState
)
{
warnTDZ
(
publicInstance
'
setState
'
)
;
}
enqueueSetProps
:
function
(
publicInstance
partialProps
)
{
warnTDZ
(
publicInstance
'
setProps
'
)
;
}
enqueueReplaceProps
:
function
(
publicInstance
props
)
{
warnTDZ
(
publicInstance
'
replaceProps
'
)
;
}
}
;
module
.
exports
=
ReactNoopUpdateQueue
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
CallbackQueue
=
__webpack_require__
(
70
)
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
ReactBrowserEventEmitter
=
__webpack_require__
(
44
)
;
var
ReactDOMFeatureFlags
=
__webpack_require__
(
56
)
;
var
ReactInputSelection
=
__webpack_require__
(
141
)
;
var
Transaction
=
__webpack_require__
(
72
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
SELECTION_RESTORATION
=
{
initialize
:
ReactInputSelection
.
getSelectionInformation
close
:
ReactInputSelection
.
restoreSelection
}
;
var
EVENT_SUPPRESSION
=
{
initialize
:
function
(
)
{
var
currentlyEnabled
=
ReactBrowserEventEmitter
.
isEnabled
(
)
;
ReactBrowserEventEmitter
.
setEnabled
(
false
)
;
return
currentlyEnabled
;
}
close
:
function
(
previouslyEnabled
)
{
ReactBrowserEventEmitter
.
setEnabled
(
previouslyEnabled
)
;
}
}
;
var
ON_DOM_READY_QUEUEING
=
{
initialize
:
function
(
)
{
this
.
reactMountReady
.
reset
(
)
;
}
close
:
function
(
)
{
this
.
reactMountReady
.
notifyAll
(
)
;
}
}
;
var
TRANSACTION_WRAPPERS
=
[
SELECTION_RESTORATION
EVENT_SUPPRESSION
ON_DOM_READY_QUEUEING
]
;
function
ReactReconcileTransaction
(
forceHTML
)
{
this
.
reinitializeTransaction
(
)
;
this
.
renderToStaticMarkup
=
false
;
this
.
reactMountReady
=
CallbackQueue
.
getPooled
(
null
)
;
this
.
useCreateElement
=
!
forceHTML
&
&
ReactDOMFeatureFlags
.
useCreateElement
;
}
var
Mixin
=
{
getTransactionWrappers
:
function
(
)
{
return
TRANSACTION_WRAPPERS
;
}
getReactMountReady
:
function
(
)
{
return
this
.
reactMountReady
;
}
destructor
:
function
(
)
{
CallbackQueue
.
release
(
this
.
reactMountReady
)
;
this
.
reactMountReady
=
null
;
}
}
;
assign
(
ReactReconcileTransaction
.
prototype
Transaction
.
Mixin
Mixin
)
;
PooledClass
.
addPoolingTo
(
ReactReconcileTransaction
)
;
module
.
exports
=
ReactReconcileTransaction
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactDOMSelection
=
__webpack_require__
(
142
)
;
var
containsNode
=
__webpack_require__
(
74
)
;
var
focusNode
=
__webpack_require__
(
110
)
;
var
getActiveElement
=
__webpack_require__
(
144
)
;
function
isInDocument
(
node
)
{
return
containsNode
(
document
.
documentElement
node
)
;
}
var
ReactInputSelection
=
{
hasSelectionCapabilities
:
function
(
elem
)
{
var
nodeName
=
elem
&
&
elem
.
nodeName
&
&
elem
.
nodeName
.
toLowerCase
(
)
;
return
nodeName
&
&
(
nodeName
=
=
=
'
input
'
&
&
elem
.
type
=
=
=
'
text
'
|
|
nodeName
=
=
=
'
textarea
'
|
|
elem
.
contentEditable
=
=
=
'
true
'
)
;
}
getSelectionInformation
:
function
(
)
{
var
focusedElem
=
getActiveElement
(
)
;
return
{
focusedElem
:
focusedElem
selectionRange
:
ReactInputSelection
.
hasSelectionCapabilities
(
focusedElem
)
?
ReactInputSelection
.
getSelection
(
focusedElem
)
:
null
}
;
}
restoreSelection
:
function
(
priorSelectionInformation
)
{
var
curFocusedElem
=
getActiveElement
(
)
;
var
priorFocusedElem
=
priorSelectionInformation
.
focusedElem
;
var
priorSelectionRange
=
priorSelectionInformation
.
selectionRange
;
if
(
curFocusedElem
!
=
=
priorFocusedElem
&
&
isInDocument
(
priorFocusedElem
)
)
{
if
(
ReactInputSelection
.
hasSelectionCapabilities
(
priorFocusedElem
)
)
{
ReactInputSelection
.
setSelection
(
priorFocusedElem
priorSelectionRange
)
;
}
focusNode
(
priorFocusedElem
)
;
}
}
getSelection
:
function
(
input
)
{
var
selection
;
if
(
'
selectionStart
'
in
input
)
{
selection
=
{
start
:
input
.
selectionStart
end
:
input
.
selectionEnd
}
;
}
else
if
(
document
.
selection
&
&
(
input
.
nodeName
&
&
input
.
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
)
)
{
var
range
=
document
.
selection
.
createRange
(
)
;
if
(
range
.
parentElement
(
)
=
=
=
input
)
{
selection
=
{
start
:
-
range
.
moveStart
(
'
character
'
-
input
.
value
.
length
)
end
:
-
range
.
moveEnd
(
'
character
'
-
input
.
value
.
length
)
}
;
}
}
else
{
selection
=
ReactDOMSelection
.
getOffsets
(
input
)
;
}
return
selection
|
|
{
start
:
0
end
:
0
}
;
}
setSelection
:
function
(
input
offsets
)
{
var
start
=
offsets
.
start
;
var
end
=
offsets
.
end
;
if
(
typeof
end
=
=
=
'
undefined
'
)
{
end
=
start
;
}
if
(
'
selectionStart
'
in
input
)
{
input
.
selectionStart
=
start
;
input
.
selectionEnd
=
Math
.
min
(
end
input
.
value
.
length
)
;
}
else
if
(
document
.
selection
&
&
(
input
.
nodeName
&
&
input
.
nodeName
.
toLowerCase
(
)
=
=
=
'
input
'
)
)
{
var
range
=
input
.
createTextRange
(
)
;
range
.
collapse
(
true
)
;
range
.
moveStart
(
'
character
'
start
)
;
range
.
moveEnd
(
'
character
'
end
-
start
)
;
range
.
select
(
)
;
}
else
{
ReactDOMSelection
.
setOffsets
(
input
offsets
)
;
}
}
}
;
module
.
exports
=
ReactInputSelection
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
getNodeForCharacterOffset
=
__webpack_require__
(
143
)
;
var
getTextContentAccessor
=
__webpack_require__
(
90
)
;
function
isCollapsed
(
anchorNode
anchorOffset
focusNode
focusOffset
)
{
return
anchorNode
=
=
=
focusNode
&
&
anchorOffset
=
=
=
focusOffset
;
}
function
getIEOffsets
(
node
)
{
var
selection
=
document
.
selection
;
var
selectedRange
=
selection
.
createRange
(
)
;
var
selectedLength
=
selectedRange
.
text
.
length
;
var
fromStart
=
selectedRange
.
duplicate
(
)
;
fromStart
.
moveToElementText
(
node
)
;
fromStart
.
setEndPoint
(
'
EndToStart
'
selectedRange
)
;
var
startOffset
=
fromStart
.
text
.
length
;
var
endOffset
=
startOffset
+
selectedLength
;
return
{
start
:
startOffset
end
:
endOffset
}
;
}
function
getModernOffsets
(
node
)
{
var
selection
=
window
.
getSelection
&
&
window
.
getSelection
(
)
;
if
(
!
selection
|
|
selection
.
rangeCount
=
=
=
0
)
{
return
null
;
}
var
anchorNode
=
selection
.
anchorNode
;
var
anchorOffset
=
selection
.
anchorOffset
;
var
focusNode
=
selection
.
focusNode
;
var
focusOffset
=
selection
.
focusOffset
;
var
currentRange
=
selection
.
getRangeAt
(
0
)
;
try
{
currentRange
.
startContainer
.
nodeType
;
currentRange
.
endContainer
.
nodeType
;
}
catch
(
e
)
{
return
null
;
}
var
isSelectionCollapsed
=
isCollapsed
(
selection
.
anchorNode
selection
.
anchorOffset
selection
.
focusNode
selection
.
focusOffset
)
;
var
rangeLength
=
isSelectionCollapsed
?
0
:
currentRange
.
toString
(
)
.
length
;
var
tempRange
=
currentRange
.
cloneRange
(
)
;
tempRange
.
selectNodeContents
(
node
)
;
tempRange
.
setEnd
(
currentRange
.
startContainer
currentRange
.
startOffset
)
;
var
isTempRangeCollapsed
=
isCollapsed
(
tempRange
.
startContainer
tempRange
.
startOffset
tempRange
.
endContainer
tempRange
.
endOffset
)
;
var
start
=
isTempRangeCollapsed
?
0
:
tempRange
.
toString
(
)
.
length
;
var
end
=
start
+
rangeLength
;
var
detectionRange
=
document
.
createRange
(
)
;
detectionRange
.
setStart
(
anchorNode
anchorOffset
)
;
detectionRange
.
setEnd
(
focusNode
focusOffset
)
;
var
isBackward
=
detectionRange
.
collapsed
;
return
{
start
:
isBackward
?
end
:
start
end
:
isBackward
?
start
:
end
}
;
}
function
setIEOffsets
(
node
offsets
)
{
var
range
=
document
.
selection
.
createRange
(
)
.
duplicate
(
)
;
var
start
end
;
if
(
typeof
offsets
.
end
=
=
=
'
undefined
'
)
{
start
=
offsets
.
start
;
end
=
start
;
}
else
if
(
offsets
.
start
>
offsets
.
end
)
{
start
=
offsets
.
end
;
end
=
offsets
.
start
;
}
else
{
start
=
offsets
.
start
;
end
=
offsets
.
end
;
}
range
.
moveToElementText
(
node
)
;
range
.
moveStart
(
'
character
'
start
)
;
range
.
setEndPoint
(
'
EndToStart
'
range
)
;
range
.
moveEnd
(
'
character
'
end
-
start
)
;
range
.
select
(
)
;
}
function
setModernOffsets
(
node
offsets
)
{
if
(
!
window
.
getSelection
)
{
return
;
}
var
selection
=
window
.
getSelection
(
)
;
var
length
=
node
[
getTextContentAccessor
(
)
]
.
length
;
var
start
=
Math
.
min
(
offsets
.
start
length
)
;
var
end
=
typeof
offsets
.
end
=
=
=
'
undefined
'
?
start
:
Math
.
min
(
offsets
.
end
length
)
;
if
(
!
selection
.
extend
&
&
start
>
end
)
{
var
temp
=
end
;
end
=
start
;
start
=
temp
;
}
var
startMarker
=
getNodeForCharacterOffset
(
node
start
)
;
var
endMarker
=
getNodeForCharacterOffset
(
node
end
)
;
if
(
startMarker
&
&
endMarker
)
{
var
range
=
document
.
createRange
(
)
;
range
.
setStart
(
startMarker
.
node
startMarker
.
offset
)
;
selection
.
removeAllRanges
(
)
;
if
(
start
>
end
)
{
selection
.
addRange
(
range
)
;
selection
.
extend
(
endMarker
.
node
endMarker
.
offset
)
;
}
else
{
range
.
setEnd
(
endMarker
.
node
endMarker
.
offset
)
;
selection
.
addRange
(
range
)
;
}
}
}
var
useIEOffsets
=
ExecutionEnvironment
.
canUseDOM
&
&
'
selection
'
in
document
&
&
!
(
'
getSelection
'
in
window
)
;
var
ReactDOMSelection
=
{
getOffsets
:
useIEOffsets
?
getIEOffsets
:
getModernOffsets
setOffsets
:
useIEOffsets
?
setIEOffsets
:
setModernOffsets
}
;
module
.
exports
=
ReactDOMSelection
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
getLeafNode
(
node
)
{
while
(
node
&
&
node
.
firstChild
)
{
node
=
node
.
firstChild
;
}
return
node
;
}
function
getSiblingNode
(
node
)
{
while
(
node
)
{
if
(
node
.
nextSibling
)
{
return
node
.
nextSibling
;
}
node
=
node
.
parentNode
;
}
}
function
getNodeForCharacterOffset
(
root
offset
)
{
var
node
=
getLeafNode
(
root
)
;
var
nodeStart
=
0
;
var
nodeEnd
=
0
;
while
(
node
)
{
if
(
node
.
nodeType
=
=
=
3
)
{
nodeEnd
=
nodeStart
+
node
.
textContent
.
length
;
if
(
nodeStart
<
=
offset
&
&
nodeEnd
>
=
offset
)
{
return
{
node
:
node
offset
:
offset
-
nodeStart
}
;
}
nodeStart
=
nodeEnd
;
}
node
=
getLeafNode
(
getSiblingNode
(
node
)
)
;
}
}
module
.
exports
=
getNodeForCharacterOffset
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
getActiveElement
(
)
{
if
(
typeof
document
=
=
=
'
undefined
'
)
{
return
null
;
}
try
{
return
document
.
activeElement
|
|
document
.
body
;
}
catch
(
e
)
{
return
document
.
body
;
}
}
module
.
exports
=
getActiveElement
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
EventPropagators
=
__webpack_require__
(
88
)
;
var
ExecutionEnvironment
=
__webpack_require__
(
24
)
;
var
ReactInputSelection
=
__webpack_require__
(
141
)
;
var
SyntheticEvent
=
__webpack_require__
(
92
)
;
var
getActiveElement
=
__webpack_require__
(
144
)
;
var
isTextInputElement
=
__webpack_require__
(
97
)
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
shallowEqual
=
__webpack_require__
(
132
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
skipSelectionChangeEvent
=
ExecutionEnvironment
.
canUseDOM
&
&
'
documentMode
'
in
document
&
&
document
.
documentMode
<
=
11
;
var
eventTypes
=
{
select
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onSelect
:
null
}
)
captured
:
keyOf
(
{
onSelectCapture
:
null
}
)
}
dependencies
:
[
topLevelTypes
.
topBlur
topLevelTypes
.
topContextMenu
topLevelTypes
.
topFocus
topLevelTypes
.
topKeyDown
topLevelTypes
.
topMouseDown
topLevelTypes
.
topMouseUp
topLevelTypes
.
topSelectionChange
]
}
}
;
var
activeElement
=
null
;
var
activeElementID
=
null
;
var
lastSelection
=
null
;
var
mouseDown
=
false
;
var
hasListener
=
false
;
var
ON_SELECT_KEY
=
keyOf
(
{
onSelect
:
null
}
)
;
function
getSelection
(
node
)
{
if
(
'
selectionStart
'
in
node
&
&
ReactInputSelection
.
hasSelectionCapabilities
(
node
)
)
{
return
{
start
:
node
.
selectionStart
end
:
node
.
selectionEnd
}
;
}
else
if
(
window
.
getSelection
)
{
var
selection
=
window
.
getSelection
(
)
;
return
{
anchorNode
:
selection
.
anchorNode
anchorOffset
:
selection
.
anchorOffset
focusNode
:
selection
.
focusNode
focusOffset
:
selection
.
focusOffset
}
;
}
else
if
(
document
.
selection
)
{
var
range
=
document
.
selection
.
createRange
(
)
;
return
{
parentElement
:
range
.
parentElement
(
)
text
:
range
.
text
top
:
range
.
boundingTop
left
:
range
.
boundingLeft
}
;
}
}
function
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
{
if
(
mouseDown
|
|
activeElement
=
=
null
|
|
activeElement
!
=
=
getActiveElement
(
)
)
{
return
null
;
}
var
currentSelection
=
getSelection
(
activeElement
)
;
if
(
!
lastSelection
|
|
!
shallowEqual
(
lastSelection
currentSelection
)
)
{
lastSelection
=
currentSelection
;
var
syntheticEvent
=
SyntheticEvent
.
getPooled
(
eventTypes
.
select
activeElementID
nativeEvent
nativeEventTarget
)
;
syntheticEvent
.
type
=
'
select
'
;
syntheticEvent
.
target
=
activeElement
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
syntheticEvent
)
;
return
syntheticEvent
;
}
return
null
;
}
var
SelectEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
if
(
!
hasListener
)
{
return
null
;
}
switch
(
topLevelType
)
{
case
topLevelTypes
.
topFocus
:
if
(
isTextInputElement
(
topLevelTarget
)
|
|
topLevelTarget
.
contentEditable
=
=
=
'
true
'
)
{
activeElement
=
topLevelTarget
;
activeElementID
=
topLevelTargetID
;
lastSelection
=
null
;
}
break
;
case
topLevelTypes
.
topBlur
:
activeElement
=
null
;
activeElementID
=
null
;
lastSelection
=
null
;
break
;
case
topLevelTypes
.
topMouseDown
:
mouseDown
=
true
;
break
;
case
topLevelTypes
.
topContextMenu
:
case
topLevelTypes
.
topMouseUp
:
mouseDown
=
false
;
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
case
topLevelTypes
.
topSelectionChange
:
if
(
skipSelectionChangeEvent
)
{
break
;
}
case
topLevelTypes
.
topKeyDown
:
case
topLevelTypes
.
topKeyUp
:
return
constructSelectEvent
(
nativeEvent
nativeEventTarget
)
;
}
return
null
;
}
didPutListener
:
function
(
id
registrationName
listener
)
{
if
(
registrationName
=
=
=
ON_SELECT_KEY
)
{
hasListener
=
true
;
}
}
}
;
module
.
exports
=
SelectEventPlugin
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
GLOBAL_MOUNT_POINT_MAX
=
Math
.
pow
(
2
53
)
;
var
ServerReactRootIndex
=
{
createReactRootIndex
:
function
(
)
{
return
Math
.
ceil
(
Math
.
random
(
)
*
GLOBAL_MOUNT_POINT_MAX
)
;
}
}
;
module
.
exports
=
ServerReactRootIndex
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
EventConstants
=
__webpack_require__
(
45
)
;
var
EventListener
=
__webpack_require__
(
134
)
;
var
EventPropagators
=
__webpack_require__
(
88
)
;
var
ReactMount
=
__webpack_require__
(
43
)
;
var
SyntheticClipboardEvent
=
__webpack_require__
(
148
)
;
var
SyntheticEvent
=
__webpack_require__
(
92
)
;
var
SyntheticFocusEvent
=
__webpack_require__
(
149
)
;
var
SyntheticKeyboardEvent
=
__webpack_require__
(
150
)
;
var
SyntheticMouseEvent
=
__webpack_require__
(
101
)
;
var
SyntheticDragEvent
=
__webpack_require__
(
153
)
;
var
SyntheticTouchEvent
=
__webpack_require__
(
154
)
;
var
SyntheticUIEvent
=
__webpack_require__
(
102
)
;
var
SyntheticWheelEvent
=
__webpack_require__
(
155
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
getEventCharCode
=
__webpack_require__
(
151
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
keyOf
=
__webpack_require__
(
94
)
;
var
topLevelTypes
=
EventConstants
.
topLevelTypes
;
var
eventTypes
=
{
abort
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onAbort
:
true
}
)
captured
:
keyOf
(
{
onAbortCapture
:
true
}
)
}
}
blur
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onBlur
:
true
}
)
captured
:
keyOf
(
{
onBlurCapture
:
true
}
)
}
}
canPlay
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onCanPlay
:
true
}
)
captured
:
keyOf
(
{
onCanPlayCapture
:
true
}
)
}
}
canPlayThrough
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onCanPlayThrough
:
true
}
)
captured
:
keyOf
(
{
onCanPlayThroughCapture
:
true
}
)
}
}
click
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onClick
:
true
}
)
captured
:
keyOf
(
{
onClickCapture
:
true
}
)
}
}
contextMenu
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onContextMenu
:
true
}
)
captured
:
keyOf
(
{
onContextMenuCapture
:
true
}
)
}
}
copy
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onCopy
:
true
}
)
captured
:
keyOf
(
{
onCopyCapture
:
true
}
)
}
}
cut
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onCut
:
true
}
)
captured
:
keyOf
(
{
onCutCapture
:
true
}
)
}
}
doubleClick
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDoubleClick
:
true
}
)
captured
:
keyOf
(
{
onDoubleClickCapture
:
true
}
)
}
}
drag
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDrag
:
true
}
)
captured
:
keyOf
(
{
onDragCapture
:
true
}
)
}
}
dragEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragEnd
:
true
}
)
captured
:
keyOf
(
{
onDragEndCapture
:
true
}
)
}
}
dragEnter
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragEnter
:
true
}
)
captured
:
keyOf
(
{
onDragEnterCapture
:
true
}
)
}
}
dragExit
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragExit
:
true
}
)
captured
:
keyOf
(
{
onDragExitCapture
:
true
}
)
}
}
dragLeave
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragLeave
:
true
}
)
captured
:
keyOf
(
{
onDragLeaveCapture
:
true
}
)
}
}
dragOver
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragOver
:
true
}
)
captured
:
keyOf
(
{
onDragOverCapture
:
true
}
)
}
}
dragStart
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDragStart
:
true
}
)
captured
:
keyOf
(
{
onDragStartCapture
:
true
}
)
}
}
drop
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDrop
:
true
}
)
captured
:
keyOf
(
{
onDropCapture
:
true
}
)
}
}
durationChange
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onDurationChange
:
true
}
)
captured
:
keyOf
(
{
onDurationChangeCapture
:
true
}
)
}
}
emptied
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onEmptied
:
true
}
)
captured
:
keyOf
(
{
onEmptiedCapture
:
true
}
)
}
}
encrypted
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onEncrypted
:
true
}
)
captured
:
keyOf
(
{
onEncryptedCapture
:
true
}
)
}
}
ended
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onEnded
:
true
}
)
captured
:
keyOf
(
{
onEndedCapture
:
true
}
)
}
}
error
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onError
:
true
}
)
captured
:
keyOf
(
{
onErrorCapture
:
true
}
)
}
}
focus
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onFocus
:
true
}
)
captured
:
keyOf
(
{
onFocusCapture
:
true
}
)
}
}
input
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onInput
:
true
}
)
captured
:
keyOf
(
{
onInputCapture
:
true
}
)
}
}
keyDown
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onKeyDown
:
true
}
)
captured
:
keyOf
(
{
onKeyDownCapture
:
true
}
)
}
}
keyPress
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onKeyPress
:
true
}
)
captured
:
keyOf
(
{
onKeyPressCapture
:
true
}
)
}
}
keyUp
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onKeyUp
:
true
}
)
captured
:
keyOf
(
{
onKeyUpCapture
:
true
}
)
}
}
load
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onLoad
:
true
}
)
captured
:
keyOf
(
{
onLoadCapture
:
true
}
)
}
}
loadedData
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onLoadedData
:
true
}
)
captured
:
keyOf
(
{
onLoadedDataCapture
:
true
}
)
}
}
loadedMetadata
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onLoadedMetadata
:
true
}
)
captured
:
keyOf
(
{
onLoadedMetadataCapture
:
true
}
)
}
}
loadStart
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onLoadStart
:
true
}
)
captured
:
keyOf
(
{
onLoadStartCapture
:
true
}
)
}
}
mouseDown
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseDown
:
true
}
)
captured
:
keyOf
(
{
onMouseDownCapture
:
true
}
)
}
}
mouseMove
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseMove
:
true
}
)
captured
:
keyOf
(
{
onMouseMoveCapture
:
true
}
)
}
}
mouseOut
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseOut
:
true
}
)
captured
:
keyOf
(
{
onMouseOutCapture
:
true
}
)
}
}
mouseOver
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseOver
:
true
}
)
captured
:
keyOf
(
{
onMouseOverCapture
:
true
}
)
}
}
mouseUp
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onMouseUp
:
true
}
)
captured
:
keyOf
(
{
onMouseUpCapture
:
true
}
)
}
}
paste
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onPaste
:
true
}
)
captured
:
keyOf
(
{
onPasteCapture
:
true
}
)
}
}
pause
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onPause
:
true
}
)
captured
:
keyOf
(
{
onPauseCapture
:
true
}
)
}
}
play
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onPlay
:
true
}
)
captured
:
keyOf
(
{
onPlayCapture
:
true
}
)
}
}
playing
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onPlaying
:
true
}
)
captured
:
keyOf
(
{
onPlayingCapture
:
true
}
)
}
}
progress
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onProgress
:
true
}
)
captured
:
keyOf
(
{
onProgressCapture
:
true
}
)
}
}
rateChange
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onRateChange
:
true
}
)
captured
:
keyOf
(
{
onRateChangeCapture
:
true
}
)
}
}
reset
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onReset
:
true
}
)
captured
:
keyOf
(
{
onResetCapture
:
true
}
)
}
}
scroll
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onScroll
:
true
}
)
captured
:
keyOf
(
{
onScrollCapture
:
true
}
)
}
}
seeked
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onSeeked
:
true
}
)
captured
:
keyOf
(
{
onSeekedCapture
:
true
}
)
}
}
seeking
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onSeeking
:
true
}
)
captured
:
keyOf
(
{
onSeekingCapture
:
true
}
)
}
}
stalled
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onStalled
:
true
}
)
captured
:
keyOf
(
{
onStalledCapture
:
true
}
)
}
}
submit
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onSubmit
:
true
}
)
captured
:
keyOf
(
{
onSubmitCapture
:
true
}
)
}
}
suspend
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onSuspend
:
true
}
)
captured
:
keyOf
(
{
onSuspendCapture
:
true
}
)
}
}
timeUpdate
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTimeUpdate
:
true
}
)
captured
:
keyOf
(
{
onTimeUpdateCapture
:
true
}
)
}
}
touchCancel
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchCancel
:
true
}
)
captured
:
keyOf
(
{
onTouchCancelCapture
:
true
}
)
}
}
touchEnd
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchEnd
:
true
}
)
captured
:
keyOf
(
{
onTouchEndCapture
:
true
}
)
}
}
touchMove
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchMove
:
true
}
)
captured
:
keyOf
(
{
onTouchMoveCapture
:
true
}
)
}
}
touchStart
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onTouchStart
:
true
}
)
captured
:
keyOf
(
{
onTouchStartCapture
:
true
}
)
}
}
volumeChange
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onVolumeChange
:
true
}
)
captured
:
keyOf
(
{
onVolumeChangeCapture
:
true
}
)
}
}
waiting
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onWaiting
:
true
}
)
captured
:
keyOf
(
{
onWaitingCapture
:
true
}
)
}
}
wheel
:
{
phasedRegistrationNames
:
{
bubbled
:
keyOf
(
{
onWheel
:
true
}
)
captured
:
keyOf
(
{
onWheelCapture
:
true
}
)
}
}
}
;
var
topLevelEventsToDispatchConfig
=
{
topAbort
:
eventTypes
.
abort
topBlur
:
eventTypes
.
blur
topCanPlay
:
eventTypes
.
canPlay
topCanPlayThrough
:
eventTypes
.
canPlayThrough
topClick
:
eventTypes
.
click
topContextMenu
:
eventTypes
.
contextMenu
topCopy
:
eventTypes
.
copy
topCut
:
eventTypes
.
cut
topDoubleClick
:
eventTypes
.
doubleClick
topDrag
:
eventTypes
.
drag
topDragEnd
:
eventTypes
.
dragEnd
topDragEnter
:
eventTypes
.
dragEnter
topDragExit
:
eventTypes
.
dragExit
topDragLeave
:
eventTypes
.
dragLeave
topDragOver
:
eventTypes
.
dragOver
topDragStart
:
eventTypes
.
dragStart
topDrop
:
eventTypes
.
drop
topDurationChange
:
eventTypes
.
durationChange
topEmptied
:
eventTypes
.
emptied
topEncrypted
:
eventTypes
.
encrypted
topEnded
:
eventTypes
.
ended
topError
:
eventTypes
.
error
topFocus
:
eventTypes
.
focus
topInput
:
eventTypes
.
input
topKeyDown
:
eventTypes
.
keyDown
topKeyPress
:
eventTypes
.
keyPress
topKeyUp
:
eventTypes
.
keyUp
topLoad
:
eventTypes
.
load
topLoadedData
:
eventTypes
.
loadedData
topLoadedMetadata
:
eventTypes
.
loadedMetadata
topLoadStart
:
eventTypes
.
loadStart
topMouseDown
:
eventTypes
.
mouseDown
topMouseMove
:
eventTypes
.
mouseMove
topMouseOut
:
eventTypes
.
mouseOut
topMouseOver
:
eventTypes
.
mouseOver
topMouseUp
:
eventTypes
.
mouseUp
topPaste
:
eventTypes
.
paste
topPause
:
eventTypes
.
pause
topPlay
:
eventTypes
.
play
topPlaying
:
eventTypes
.
playing
topProgress
:
eventTypes
.
progress
topRateChange
:
eventTypes
.
rateChange
topReset
:
eventTypes
.
reset
topScroll
:
eventTypes
.
scroll
topSeeked
:
eventTypes
.
seeked
topSeeking
:
eventTypes
.
seeking
topStalled
:
eventTypes
.
stalled
topSubmit
:
eventTypes
.
submit
topSuspend
:
eventTypes
.
suspend
topTimeUpdate
:
eventTypes
.
timeUpdate
topTouchCancel
:
eventTypes
.
touchCancel
topTouchEnd
:
eventTypes
.
touchEnd
topTouchMove
:
eventTypes
.
touchMove
topTouchStart
:
eventTypes
.
touchStart
topVolumeChange
:
eventTypes
.
volumeChange
topWaiting
:
eventTypes
.
waiting
topWheel
:
eventTypes
.
wheel
}
;
for
(
var
type
in
topLevelEventsToDispatchConfig
)
{
topLevelEventsToDispatchConfig
[
type
]
.
dependencies
=
[
type
]
;
}
var
ON_CLICK_KEY
=
keyOf
(
{
onClick
:
null
}
)
;
var
onClickListeners
=
{
}
;
var
SimpleEventPlugin
=
{
eventTypes
:
eventTypes
extractEvents
:
function
(
topLevelType
topLevelTarget
topLevelTargetID
nativeEvent
nativeEventTarget
)
{
var
dispatchConfig
=
topLevelEventsToDispatchConfig
[
topLevelType
]
;
if
(
!
dispatchConfig
)
{
return
null
;
}
var
EventConstructor
;
switch
(
topLevelType
)
{
case
topLevelTypes
.
topAbort
:
case
topLevelTypes
.
topCanPlay
:
case
topLevelTypes
.
topCanPlayThrough
:
case
topLevelTypes
.
topDurationChange
:
case
topLevelTypes
.
topEmptied
:
case
topLevelTypes
.
topEncrypted
:
case
topLevelTypes
.
topEnded
:
case
topLevelTypes
.
topError
:
case
topLevelTypes
.
topInput
:
case
topLevelTypes
.
topLoad
:
case
topLevelTypes
.
topLoadedData
:
case
topLevelTypes
.
topLoadedMetadata
:
case
topLevelTypes
.
topLoadStart
:
case
topLevelTypes
.
topPause
:
case
topLevelTypes
.
topPlay
:
case
topLevelTypes
.
topPlaying
:
case
topLevelTypes
.
topProgress
:
case
topLevelTypes
.
topRateChange
:
case
topLevelTypes
.
topReset
:
case
topLevelTypes
.
topSeeked
:
case
topLevelTypes
.
topSeeking
:
case
topLevelTypes
.
topStalled
:
case
topLevelTypes
.
topSubmit
:
case
topLevelTypes
.
topSuspend
:
case
topLevelTypes
.
topTimeUpdate
:
case
topLevelTypes
.
topVolumeChange
:
case
topLevelTypes
.
topWaiting
:
EventConstructor
=
SyntheticEvent
;
break
;
case
topLevelTypes
.
topKeyPress
:
if
(
getEventCharCode
(
nativeEvent
)
=
=
=
0
)
{
return
null
;
}
case
topLevelTypes
.
topKeyDown
:
case
topLevelTypes
.
topKeyUp
:
EventConstructor
=
SyntheticKeyboardEvent
;
break
;
case
topLevelTypes
.
topBlur
:
case
topLevelTypes
.
topFocus
:
EventConstructor
=
SyntheticFocusEvent
;
break
;
case
topLevelTypes
.
topClick
:
if
(
nativeEvent
.
button
=
=
=
2
)
{
return
null
;
}
case
topLevelTypes
.
topContextMenu
:
case
topLevelTypes
.
topDoubleClick
:
case
topLevelTypes
.
topMouseDown
:
case
topLevelTypes
.
topMouseMove
:
case
topLevelTypes
.
topMouseOut
:
case
topLevelTypes
.
topMouseOver
:
case
topLevelTypes
.
topMouseUp
:
EventConstructor
=
SyntheticMouseEvent
;
break
;
case
topLevelTypes
.
topDrag
:
case
topLevelTypes
.
topDragEnd
:
case
topLevelTypes
.
topDragEnter
:
case
topLevelTypes
.
topDragExit
:
case
topLevelTypes
.
topDragLeave
:
case
topLevelTypes
.
topDragOver
:
case
topLevelTypes
.
topDragStart
:
case
topLevelTypes
.
topDrop
:
EventConstructor
=
SyntheticDragEvent
;
break
;
case
topLevelTypes
.
topTouchCancel
:
case
topLevelTypes
.
topTouchEnd
:
case
topLevelTypes
.
topTouchMove
:
case
topLevelTypes
.
topTouchStart
:
EventConstructor
=
SyntheticTouchEvent
;
break
;
case
topLevelTypes
.
topScroll
:
EventConstructor
=
SyntheticUIEvent
;
break
;
case
topLevelTypes
.
topWheel
:
EventConstructor
=
SyntheticWheelEvent
;
break
;
case
topLevelTypes
.
topCopy
:
case
topLevelTypes
.
topCut
:
case
topLevelTypes
.
topPaste
:
EventConstructor
=
SyntheticClipboardEvent
;
break
;
}
!
EventConstructor
?
false
?
invariant
(
false
'
SimpleEventPlugin
:
Unhandled
event
type
%
s
.
'
topLevelType
)
:
invariant
(
false
)
:
undefined
;
var
event
=
EventConstructor
.
getPooled
(
dispatchConfig
topLevelTargetID
nativeEvent
nativeEventTarget
)
;
EventPropagators
.
accumulateTwoPhaseDispatches
(
event
)
;
return
event
;
}
didPutListener
:
function
(
id
registrationName
listener
)
{
if
(
registrationName
=
=
=
ON_CLICK_KEY
)
{
var
node
=
ReactMount
.
getNode
(
id
)
;
if
(
!
onClickListeners
[
id
]
)
{
onClickListeners
[
id
]
=
EventListener
.
listen
(
node
'
click
'
emptyFunction
)
;
}
}
}
willDeleteListener
:
function
(
id
registrationName
)
{
if
(
registrationName
=
=
=
ON_CLICK_KEY
)
{
onClickListeners
[
id
]
.
remove
(
)
;
delete
onClickListeners
[
id
]
;
}
}
}
;
module
.
exports
=
SimpleEventPlugin
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticEvent
=
__webpack_require__
(
92
)
;
var
ClipboardEventInterface
=
{
clipboardData
:
function
(
event
)
{
return
'
clipboardData
'
in
event
?
event
.
clipboardData
:
window
.
clipboardData
;
}
}
;
function
SyntheticClipboardEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticEvent
.
augmentClass
(
SyntheticClipboardEvent
ClipboardEventInterface
)
;
module
.
exports
=
SyntheticClipboardEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticUIEvent
=
__webpack_require__
(
102
)
;
var
FocusEventInterface
=
{
relatedTarget
:
null
}
;
function
SyntheticFocusEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticFocusEvent
FocusEventInterface
)
;
module
.
exports
=
SyntheticFocusEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticUIEvent
=
__webpack_require__
(
102
)
;
var
getEventCharCode
=
__webpack_require__
(
151
)
;
var
getEventKey
=
__webpack_require__
(
152
)
;
var
getEventModifierState
=
__webpack_require__
(
103
)
;
var
KeyboardEventInterface
=
{
key
:
getEventKey
location
:
null
ctrlKey
:
null
shiftKey
:
null
altKey
:
null
metaKey
:
null
repeat
:
null
locale
:
null
getModifierState
:
getEventModifierState
charCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
return
0
;
}
keyCode
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
which
:
function
(
event
)
{
if
(
event
.
type
=
=
=
'
keypress
'
)
{
return
getEventCharCode
(
event
)
;
}
if
(
event
.
type
=
=
=
'
keydown
'
|
|
event
.
type
=
=
=
'
keyup
'
)
{
return
event
.
keyCode
;
}
return
0
;
}
}
;
function
SyntheticKeyboardEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticKeyboardEvent
KeyboardEventInterface
)
;
module
.
exports
=
SyntheticKeyboardEvent
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
getEventCharCode
(
nativeEvent
)
{
var
charCode
;
var
keyCode
=
nativeEvent
.
keyCode
;
if
(
'
charCode
'
in
nativeEvent
)
{
charCode
=
nativeEvent
.
charCode
;
if
(
charCode
=
=
=
0
&
&
keyCode
=
=
=
13
)
{
charCode
=
13
;
}
}
else
{
charCode
=
keyCode
;
}
if
(
charCode
>
=
32
|
|
charCode
=
=
=
13
)
{
return
charCode
;
}
return
0
;
}
module
.
exports
=
getEventCharCode
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
getEventCharCode
=
__webpack_require__
(
151
)
;
var
normalizeKey
=
{
'
Esc
'
:
'
Escape
'
'
Spacebar
'
:
'
'
'
Left
'
:
'
ArrowLeft
'
'
Up
'
:
'
ArrowUp
'
'
Right
'
:
'
ArrowRight
'
'
Down
'
:
'
ArrowDown
'
'
Del
'
:
'
Delete
'
'
Win
'
:
'
OS
'
'
Menu
'
:
'
ContextMenu
'
'
Apps
'
:
'
ContextMenu
'
'
Scroll
'
:
'
ScrollLock
'
'
MozPrintableKey
'
:
'
Unidentified
'
}
;
var
translateToKey
=
{
8
:
'
Backspace
'
9
:
'
Tab
'
12
:
'
Clear
'
13
:
'
Enter
'
16
:
'
Shift
'
17
:
'
Control
'
18
:
'
Alt
'
19
:
'
Pause
'
20
:
'
CapsLock
'
27
:
'
Escape
'
32
:
'
'
33
:
'
PageUp
'
34
:
'
PageDown
'
35
:
'
End
'
36
:
'
Home
'
37
:
'
ArrowLeft
'
38
:
'
ArrowUp
'
39
:
'
ArrowRight
'
40
:
'
ArrowDown
'
45
:
'
Insert
'
46
:
'
Delete
'
112
:
'
F1
'
113
:
'
F2
'
114
:
'
F3
'
115
:
'
F4
'
116
:
'
F5
'
117
:
'
F6
'
118
:
'
F7
'
119
:
'
F8
'
120
:
'
F9
'
121
:
'
F10
'
122
:
'
F11
'
123
:
'
F12
'
144
:
'
NumLock
'
145
:
'
ScrollLock
'
224
:
'
Meta
'
}
;
function
getEventKey
(
nativeEvent
)
{
if
(
nativeEvent
.
key
)
{
var
key
=
normalizeKey
[
nativeEvent
.
key
]
|
|
nativeEvent
.
key
;
if
(
key
!
=
=
'
Unidentified
'
)
{
return
key
;
}
}
if
(
nativeEvent
.
type
=
=
=
'
keypress
'
)
{
var
charCode
=
getEventCharCode
(
nativeEvent
)
;
return
charCode
=
=
=
13
?
'
Enter
'
:
String
.
fromCharCode
(
charCode
)
;
}
if
(
nativeEvent
.
type
=
=
=
'
keydown
'
|
|
nativeEvent
.
type
=
=
=
'
keyup
'
)
{
return
translateToKey
[
nativeEvent
.
keyCode
]
|
|
'
Unidentified
'
;
}
return
'
'
;
}
module
.
exports
=
getEventKey
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticMouseEvent
=
__webpack_require__
(
101
)
;
var
DragEventInterface
=
{
dataTransfer
:
null
}
;
function
SyntheticDragEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticMouseEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticMouseEvent
.
augmentClass
(
SyntheticDragEvent
DragEventInterface
)
;
module
.
exports
=
SyntheticDragEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticUIEvent
=
__webpack_require__
(
102
)
;
var
getEventModifierState
=
__webpack_require__
(
103
)
;
var
TouchEventInterface
=
{
touches
:
null
targetTouches
:
null
changedTouches
:
null
altKey
:
null
metaKey
:
null
ctrlKey
:
null
shiftKey
:
null
getModifierState
:
getEventModifierState
}
;
function
SyntheticTouchEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticUIEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticUIEvent
.
augmentClass
(
SyntheticTouchEvent
TouchEventInterface
)
;
module
.
exports
=
SyntheticTouchEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
SyntheticMouseEvent
=
__webpack_require__
(
101
)
;
var
WheelEventInterface
=
{
deltaX
:
function
(
event
)
{
return
'
deltaX
'
in
event
?
event
.
deltaX
:
'
wheelDeltaX
'
in
event
?
-
event
.
wheelDeltaX
:
0
;
}
deltaY
:
function
(
event
)
{
return
'
deltaY
'
in
event
?
event
.
deltaY
:
'
wheelDeltaY
'
in
event
?
-
event
.
wheelDeltaY
:
'
wheelDelta
'
in
event
?
-
event
.
wheelDelta
:
0
;
}
deltaZ
:
null
deltaMode
:
null
}
;
function
SyntheticWheelEvent
(
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
{
SyntheticMouseEvent
.
call
(
this
dispatchConfig
dispatchMarker
nativeEvent
nativeEventTarget
)
;
}
SyntheticMouseEvent
.
augmentClass
(
SyntheticWheelEvent
WheelEventInterface
)
;
module
.
exports
=
SyntheticWheelEvent
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
DOMProperty
=
__webpack_require__
(
38
)
;
var
MUST_USE_ATTRIBUTE
=
DOMProperty
.
injection
.
MUST_USE_ATTRIBUTE
;
var
NS
=
{
xlink
:
'
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
'
xml
:
'
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
'
}
;
var
SVGDOMPropertyConfig
=
{
Properties
:
{
clipPath
:
MUST_USE_ATTRIBUTE
cx
:
MUST_USE_ATTRIBUTE
cy
:
MUST_USE_ATTRIBUTE
d
:
MUST_USE_ATTRIBUTE
dx
:
MUST_USE_ATTRIBUTE
dy
:
MUST_USE_ATTRIBUTE
fill
:
MUST_USE_ATTRIBUTE
fillOpacity
:
MUST_USE_ATTRIBUTE
fontFamily
:
MUST_USE_ATTRIBUTE
fontSize
:
MUST_USE_ATTRIBUTE
fx
:
MUST_USE_ATTRIBUTE
fy
:
MUST_USE_ATTRIBUTE
gradientTransform
:
MUST_USE_ATTRIBUTE
gradientUnits
:
MUST_USE_ATTRIBUTE
markerEnd
:
MUST_USE_ATTRIBUTE
markerMid
:
MUST_USE_ATTRIBUTE
markerStart
:
MUST_USE_ATTRIBUTE
offset
:
MUST_USE_ATTRIBUTE
opacity
:
MUST_USE_ATTRIBUTE
patternContentUnits
:
MUST_USE_ATTRIBUTE
patternUnits
:
MUST_USE_ATTRIBUTE
points
:
MUST_USE_ATTRIBUTE
preserveAspectRatio
:
MUST_USE_ATTRIBUTE
r
:
MUST_USE_ATTRIBUTE
rx
:
MUST_USE_ATTRIBUTE
ry
:
MUST_USE_ATTRIBUTE
spreadMethod
:
MUST_USE_ATTRIBUTE
stopColor
:
MUST_USE_ATTRIBUTE
stopOpacity
:
MUST_USE_ATTRIBUTE
stroke
:
MUST_USE_ATTRIBUTE
strokeDasharray
:
MUST_USE_ATTRIBUTE
strokeLinecap
:
MUST_USE_ATTRIBUTE
strokeOpacity
:
MUST_USE_ATTRIBUTE
strokeWidth
:
MUST_USE_ATTRIBUTE
textAnchor
:
MUST_USE_ATTRIBUTE
transform
:
MUST_USE_ATTRIBUTE
version
:
MUST_USE_ATTRIBUTE
viewBox
:
MUST_USE_ATTRIBUTE
x1
:
MUST_USE_ATTRIBUTE
x2
:
MUST_USE_ATTRIBUTE
x
:
MUST_USE_ATTRIBUTE
xlinkActuate
:
MUST_USE_ATTRIBUTE
xlinkArcrole
:
MUST_USE_ATTRIBUTE
xlinkHref
:
MUST_USE_ATTRIBUTE
xlinkRole
:
MUST_USE_ATTRIBUTE
xlinkShow
:
MUST_USE_ATTRIBUTE
xlinkTitle
:
MUST_USE_ATTRIBUTE
xlinkType
:
MUST_USE_ATTRIBUTE
xmlBase
:
MUST_USE_ATTRIBUTE
xmlLang
:
MUST_USE_ATTRIBUTE
xmlSpace
:
MUST_USE_ATTRIBUTE
y1
:
MUST_USE_ATTRIBUTE
y2
:
MUST_USE_ATTRIBUTE
y
:
MUST_USE_ATTRIBUTE
}
DOMAttributeNamespaces
:
{
xlinkActuate
:
NS
.
xlink
xlinkArcrole
:
NS
.
xlink
xlinkHref
:
NS
.
xlink
xlinkRole
:
NS
.
xlink
xlinkShow
:
NS
.
xlink
xlinkTitle
:
NS
.
xlink
xlinkType
:
NS
.
xlink
xmlBase
:
NS
.
xml
xmlLang
:
NS
.
xml
xmlSpace
:
NS
.
xml
}
DOMAttributeNames
:
{
clipPath
:
'
clip
-
path
'
fillOpacity
:
'
fill
-
opacity
'
fontFamily
:
'
font
-
family
'
fontSize
:
'
font
-
size
'
gradientTransform
:
'
gradientTransform
'
gradientUnits
:
'
gradientUnits
'
markerEnd
:
'
marker
-
end
'
markerMid
:
'
marker
-
mid
'
markerStart
:
'
marker
-
start
'
patternContentUnits
:
'
patternContentUnits
'
patternUnits
:
'
patternUnits
'
preserveAspectRatio
:
'
preserveAspectRatio
'
spreadMethod
:
'
spreadMethod
'
stopColor
:
'
stop
-
color
'
stopOpacity
:
'
stop
-
opacity
'
strokeDasharray
:
'
stroke
-
dasharray
'
strokeLinecap
:
'
stroke
-
linecap
'
strokeOpacity
:
'
stroke
-
opacity
'
strokeWidth
:
'
stroke
-
width
'
textAnchor
:
'
text
-
anchor
'
viewBox
:
'
viewBox
'
xlinkActuate
:
'
xlink
:
actuate
'
xlinkArcrole
:
'
xlink
:
arcrole
'
xlinkHref
:
'
xlink
:
href
'
xlinkRole
:
'
xlink
:
role
'
xlinkShow
:
'
xlink
:
show
'
xlinkTitle
:
'
xlink
:
title
'
xlinkType
:
'
xlink
:
type
'
xmlBase
:
'
xml
:
base
'
xmlLang
:
'
xml
:
lang
'
xmlSpace
:
'
xml
:
space
'
}
}
;
module
.
exports
=
SVGDOMPropertyConfig
;
}
function
(
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
'
0
.
14
.
7
'
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactMount
=
__webpack_require__
(
43
)
;
module
.
exports
=
ReactMount
.
renderSubtreeIntoContainer
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactDefaultInjection
=
__webpack_require__
(
86
)
;
var
ReactServerRendering
=
__webpack_require__
(
160
)
;
var
ReactVersion
=
__webpack_require__
(
157
)
;
ReactDefaultInjection
.
inject
(
)
;
var
ReactDOMServer
=
{
renderToString
:
ReactServerRendering
.
renderToString
renderToStaticMarkup
:
ReactServerRendering
.
renderToStaticMarkup
version
:
ReactVersion
}
;
module
.
exports
=
ReactDOMServer
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactDefaultBatchingStrategy
=
__webpack_require__
(
107
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactInstanceHandles
=
__webpack_require__
(
60
)
;
var
ReactMarkupChecksum
=
__webpack_require__
(
63
)
;
var
ReactServerBatchingStrategy
=
__webpack_require__
(
161
)
;
var
ReactServerRenderingTransaction
=
__webpack_require__
(
162
)
;
var
ReactUpdates
=
__webpack_require__
(
69
)
;
var
emptyObject
=
__webpack_require__
(
73
)
;
var
instantiateReactComponent
=
__webpack_require__
(
77
)
;
var
invariant
=
__webpack_require__
(
28
)
;
function
renderToString
(
element
)
{
!
ReactElement
.
isValidElement
(
element
)
?
false
?
invariant
(
false
'
renderToString
(
)
:
You
must
pass
a
valid
ReactElement
.
'
)
:
invariant
(
false
)
:
undefined
;
var
transaction
;
try
{
ReactUpdates
.
injection
.
injectBatchingStrategy
(
ReactServerBatchingStrategy
)
;
var
id
=
ReactInstanceHandles
.
createReactRootID
(
)
;
transaction
=
ReactServerRenderingTransaction
.
getPooled
(
false
)
;
return
transaction
.
perform
(
function
(
)
{
var
componentInstance
=
instantiateReactComponent
(
element
null
)
;
var
markup
=
componentInstance
.
mountComponent
(
id
transaction
emptyObject
)
;
return
ReactMarkupChecksum
.
addChecksumToMarkup
(
markup
)
;
}
null
)
;
}
finally
{
ReactServerRenderingTransaction
.
release
(
transaction
)
;
ReactUpdates
.
injection
.
injectBatchingStrategy
(
ReactDefaultBatchingStrategy
)
;
}
}
function
renderToStaticMarkup
(
element
)
{
!
ReactElement
.
isValidElement
(
element
)
?
false
?
invariant
(
false
'
renderToStaticMarkup
(
)
:
You
must
pass
a
valid
ReactElement
.
'
)
:
invariant
(
false
)
:
undefined
;
var
transaction
;
try
{
ReactUpdates
.
injection
.
injectBatchingStrategy
(
ReactServerBatchingStrategy
)
;
var
id
=
ReactInstanceHandles
.
createReactRootID
(
)
;
transaction
=
ReactServerRenderingTransaction
.
getPooled
(
true
)
;
return
transaction
.
perform
(
function
(
)
{
var
componentInstance
=
instantiateReactComponent
(
element
null
)
;
return
componentInstance
.
mountComponent
(
id
transaction
emptyObject
)
;
}
null
)
;
}
finally
{
ReactServerRenderingTransaction
.
release
(
transaction
)
;
ReactUpdates
.
injection
.
injectBatchingStrategy
(
ReactDefaultBatchingStrategy
)
;
}
}
module
.
exports
=
{
renderToString
:
renderToString
renderToStaticMarkup
:
renderToStaticMarkup
}
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
ReactServerBatchingStrategy
=
{
isBatchingUpdates
:
false
batchedUpdates
:
function
(
callback
)
{
}
}
;
module
.
exports
=
ReactServerBatchingStrategy
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
PooledClass
=
__webpack_require__
(
71
)
;
var
CallbackQueue
=
__webpack_require__
(
70
)
;
var
Transaction
=
__webpack_require__
(
72
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
emptyFunction
=
__webpack_require__
(
30
)
;
var
ON_DOM_READY_QUEUEING
=
{
initialize
:
function
(
)
{
this
.
reactMountReady
.
reset
(
)
;
}
close
:
emptyFunction
}
;
var
TRANSACTION_WRAPPERS
=
[
ON_DOM_READY_QUEUEING
]
;
function
ReactServerRenderingTransaction
(
renderToStaticMarkup
)
{
this
.
reinitializeTransaction
(
)
;
this
.
renderToStaticMarkup
=
renderToStaticMarkup
;
this
.
reactMountReady
=
CallbackQueue
.
getPooled
(
null
)
;
this
.
useCreateElement
=
false
;
}
var
Mixin
=
{
getTransactionWrappers
:
function
(
)
{
return
TRANSACTION_WRAPPERS
;
}
getReactMountReady
:
function
(
)
{
return
this
.
reactMountReady
;
}
destructor
:
function
(
)
{
CallbackQueue
.
release
(
this
.
reactMountReady
)
;
this
.
reactMountReady
=
null
;
}
}
;
assign
(
ReactServerRenderingTransaction
.
prototype
Transaction
.
Mixin
Mixin
)
;
PooledClass
.
addPoolingTo
(
ReactServerRenderingTransaction
)
;
module
.
exports
=
ReactServerRenderingTransaction
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactChildren
=
__webpack_require__
(
125
)
;
var
ReactComponent
=
__webpack_require__
(
138
)
;
var
ReactClass
=
__webpack_require__
(
137
)
;
var
ReactDOMFactories
=
__webpack_require__
(
164
)
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactElementValidator
=
__webpack_require__
(
165
)
;
var
ReactPropTypes
=
__webpack_require__
(
122
)
;
var
ReactVersion
=
__webpack_require__
(
157
)
;
var
assign
=
__webpack_require__
(
54
)
;
var
onlyChild
=
__webpack_require__
(
167
)
;
var
createElement
=
ReactElement
.
createElement
;
var
createFactory
=
ReactElement
.
createFactory
;
var
cloneElement
=
ReactElement
.
cloneElement
;
if
(
false
)
{
createElement
=
ReactElementValidator
.
createElement
;
createFactory
=
ReactElementValidator
.
createFactory
;
cloneElement
=
ReactElementValidator
.
cloneElement
;
}
var
React
=
{
Children
:
{
map
:
ReactChildren
.
map
forEach
:
ReactChildren
.
forEach
count
:
ReactChildren
.
count
toArray
:
ReactChildren
.
toArray
only
:
onlyChild
}
Component
:
ReactComponent
createElement
:
createElement
cloneElement
:
cloneElement
isValidElement
:
ReactElement
.
isValidElement
PropTypes
:
ReactPropTypes
createClass
:
ReactClass
.
createClass
createFactory
:
createFactory
createMixin
:
function
(
mixin
)
{
return
mixin
;
}
DOM
:
ReactDOMFactories
version
:
ReactVersion
__spread
:
assign
}
;
module
.
exports
=
React
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactElementValidator
=
__webpack_require__
(
165
)
;
var
mapObject
=
__webpack_require__
(
166
)
;
function
createDOMFactory
(
tag
)
{
if
(
false
)
{
return
ReactElementValidator
.
createFactory
(
tag
)
;
}
return
ReactElement
.
createFactory
(
tag
)
;
}
var
ReactDOMFactories
=
mapObject
(
{
a
:
'
a
'
abbr
:
'
abbr
'
address
:
'
address
'
area
:
'
area
'
article
:
'
article
'
aside
:
'
aside
'
audio
:
'
audio
'
b
:
'
b
'
base
:
'
base
'
bdi
:
'
bdi
'
bdo
:
'
bdo
'
big
:
'
big
'
blockquote
:
'
blockquote
'
body
:
'
body
'
br
:
'
br
'
button
:
'
button
'
canvas
:
'
canvas
'
caption
:
'
caption
'
cite
:
'
cite
'
code
:
'
code
'
col
:
'
col
'
colgroup
:
'
colgroup
'
data
:
'
data
'
datalist
:
'
datalist
'
dd
:
'
dd
'
del
:
'
del
'
details
:
'
details
'
dfn
:
'
dfn
'
dialog
:
'
dialog
'
div
:
'
div
'
dl
:
'
dl
'
dt
:
'
dt
'
em
:
'
em
'
embed
:
'
embed
'
fieldset
:
'
fieldset
'
figcaption
:
'
figcaption
'
figure
:
'
figure
'
footer
:
'
footer
'
form
:
'
form
'
h1
:
'
h1
'
h2
:
'
h2
'
h3
:
'
h3
'
h4
:
'
h4
'
h5
:
'
h5
'
h6
:
'
h6
'
head
:
'
head
'
header
:
'
header
'
hgroup
:
'
hgroup
'
hr
:
'
hr
'
html
:
'
html
'
i
:
'
i
'
iframe
:
'
iframe
'
img
:
'
img
'
input
:
'
input
'
ins
:
'
ins
'
kbd
:
'
kbd
'
keygen
:
'
keygen
'
label
:
'
label
'
legend
:
'
legend
'
li
:
'
li
'
link
:
'
link
'
main
:
'
main
'
map
:
'
map
'
mark
:
'
mark
'
menu
:
'
menu
'
menuitem
:
'
menuitem
'
meta
:
'
meta
'
meter
:
'
meter
'
nav
:
'
nav
'
noscript
:
'
noscript
'
object
:
'
object
'
ol
:
'
ol
'
optgroup
:
'
optgroup
'
option
:
'
option
'
output
:
'
output
'
p
:
'
p
'
param
:
'
param
'
picture
:
'
picture
'
pre
:
'
pre
'
progress
:
'
progress
'
q
:
'
q
'
rp
:
'
rp
'
rt
:
'
rt
'
ruby
:
'
ruby
'
s
:
'
s
'
samp
:
'
samp
'
script
:
'
script
'
section
:
'
section
'
select
:
'
select
'
small
:
'
small
'
source
:
'
source
'
span
:
'
span
'
strong
:
'
strong
'
style
:
'
style
'
sub
:
'
sub
'
summary
:
'
summary
'
sup
:
'
sup
'
table
:
'
table
'
tbody
:
'
tbody
'
td
:
'
td
'
textarea
:
'
textarea
'
tfoot
:
'
tfoot
'
th
:
'
th
'
thead
:
'
thead
'
time
:
'
time
'
title
:
'
title
'
tr
:
'
tr
'
track
:
'
track
'
u
:
'
u
'
ul
:
'
ul
'
'
var
'
:
'
var
'
video
:
'
video
'
wbr
:
'
wbr
'
circle
:
'
circle
'
clipPath
:
'
clipPath
'
defs
:
'
defs
'
ellipse
:
'
ellipse
'
g
:
'
g
'
image
:
'
image
'
line
:
'
line
'
linearGradient
:
'
linearGradient
'
mask
:
'
mask
'
path
:
'
path
'
pattern
:
'
pattern
'
polygon
:
'
polygon
'
polyline
:
'
polyline
'
radialGradient
:
'
radialGradient
'
rect
:
'
rect
'
stop
:
'
stop
'
svg
:
'
svg
'
text
:
'
text
'
tspan
:
'
tspan
'
}
createDOMFactory
)
;
module
.
exports
=
ReactDOMFactories
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
ReactPropTypeLocations
=
__webpack_require__
(
80
)
;
var
ReactPropTypeLocationNames
=
__webpack_require__
(
81
)
;
var
ReactCurrentOwner
=
__webpack_require__
(
20
)
;
var
canDefineProperty
=
__webpack_require__
(
58
)
;
var
getIteratorFn
=
__webpack_require__
(
123
)
;
var
invariant
=
__webpack_require__
(
28
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
getDeclarationErrorAddendum
(
)
{
if
(
ReactCurrentOwner
.
current
)
{
var
name
=
ReactCurrentOwner
.
current
.
getName
(
)
;
if
(
name
)
{
return
'
Check
the
render
method
of
'
+
name
+
'
.
'
;
}
}
return
'
'
;
}
var
ownerHasKeyUseWarning
=
{
}
;
var
loggedTypeFailures
=
{
}
;
function
validateExplicitKey
(
element
parentType
)
{
if
(
!
element
.
_store
|
|
element
.
_store
.
validated
|
|
element
.
key
!
=
null
)
{
return
;
}
element
.
_store
.
validated
=
true
;
var
addenda
=
getAddendaForKeyUse
(
'
uniqueKey
'
element
parentType
)
;
if
(
addenda
=
=
=
null
)
{
return
;
}
false
?
warning
(
false
'
Each
child
in
an
array
or
iterator
should
have
a
unique
"
key
"
prop
.
'
+
'
%
s
%
s
%
s
'
addenda
.
parentOrOwner
|
|
'
'
addenda
.
childOwner
|
|
'
'
addenda
.
url
|
|
'
'
)
:
undefined
;
}
function
getAddendaForKeyUse
(
messageType
element
parentType
)
{
var
addendum
=
getDeclarationErrorAddendum
(
)
;
if
(
!
addendum
)
{
var
parentName
=
typeof
parentType
=
=
=
'
string
'
?
parentType
:
parentType
.
displayName
|
|
parentType
.
name
;
if
(
parentName
)
{
addendum
=
'
Check
the
top
-
level
render
call
using
<
'
+
parentName
+
'
>
.
'
;
}
}
var
memoizer
=
ownerHasKeyUseWarning
[
messageType
]
|
|
(
ownerHasKeyUseWarning
[
messageType
]
=
{
}
)
;
if
(
memoizer
[
addendum
]
)
{
return
null
;
}
memoizer
[
addendum
]
=
true
;
var
addenda
=
{
parentOrOwner
:
addendum
url
:
'
See
https
:
/
/
fb
.
me
/
react
-
warning
-
keys
for
more
information
.
'
childOwner
:
null
}
;
if
(
element
&
&
element
.
_owner
&
&
element
.
_owner
!
=
=
ReactCurrentOwner
.
current
)
{
addenda
.
childOwner
=
'
It
was
passed
a
child
from
'
+
element
.
_owner
.
getName
(
)
+
'
.
'
;
}
return
addenda
;
}
function
validateChildKeys
(
node
parentType
)
{
if
(
typeof
node
!
=
=
'
object
'
)
{
return
;
}
if
(
Array
.
isArray
(
node
)
)
{
for
(
var
i
=
0
;
i
<
node
.
length
;
i
+
+
)
{
var
child
=
node
[
i
]
;
if
(
ReactElement
.
isValidElement
(
child
)
)
{
validateExplicitKey
(
child
parentType
)
;
}
}
}
else
if
(
ReactElement
.
isValidElement
(
node
)
)
{
if
(
node
.
_store
)
{
node
.
_store
.
validated
=
true
;
}
}
else
if
(
node
)
{
var
iteratorFn
=
getIteratorFn
(
node
)
;
if
(
iteratorFn
)
{
if
(
iteratorFn
!
=
=
node
.
entries
)
{
var
iterator
=
iteratorFn
.
call
(
node
)
;
var
step
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
if
(
ReactElement
.
isValidElement
(
step
.
value
)
)
{
validateExplicitKey
(
step
.
value
parentType
)
;
}
}
}
}
}
}
function
checkPropTypes
(
componentName
propTypes
props
location
)
{
for
(
var
propName
in
propTypes
)
{
if
(
propTypes
.
hasOwnProperty
(
propName
)
)
{
var
error
;
try
{
!
(
typeof
propTypes
[
propName
]
=
=
=
'
function
'
)
?
false
?
invariant
(
false
'
%
s
:
%
s
type
%
s
is
invalid
;
it
must
be
a
function
usually
from
'
+
'
React
.
PropTypes
.
'
componentName
|
|
'
React
class
'
ReactPropTypeLocationNames
[
location
]
propName
)
:
invariant
(
false
)
:
undefined
;
error
=
propTypes
[
propName
]
(
props
propName
componentName
location
)
;
}
catch
(
ex
)
{
error
=
ex
;
}
false
?
warning
(
!
error
|
|
error
instanceof
Error
'
%
s
:
type
specification
of
%
s
%
s
is
invalid
;
the
type
checker
'
+
'
function
must
return
null
or
an
Error
but
returned
a
%
s
.
'
+
'
You
may
have
forgotten
to
pass
an
argument
to
the
type
checker
'
+
'
creator
(
arrayOf
instanceOf
objectOf
oneOf
oneOfType
and
'
+
'
shape
all
require
an
argument
)
.
'
componentName
|
|
'
React
class
'
ReactPropTypeLocationNames
[
location
]
propName
typeof
error
)
:
undefined
;
if
(
error
instanceof
Error
&
&
!
(
error
.
message
in
loggedTypeFailures
)
)
{
loggedTypeFailures
[
error
.
message
]
=
true
;
var
addendum
=
getDeclarationErrorAddendum
(
)
;
false
?
warning
(
false
'
Failed
propType
:
%
s
%
s
'
error
.
message
addendum
)
:
undefined
;
}
}
}
}
function
validatePropTypes
(
element
)
{
var
componentClass
=
element
.
type
;
if
(
typeof
componentClass
!
=
=
'
function
'
)
{
return
;
}
var
name
=
componentClass
.
displayName
|
|
componentClass
.
name
;
if
(
componentClass
.
propTypes
)
{
checkPropTypes
(
name
componentClass
.
propTypes
element
.
props
ReactPropTypeLocations
.
prop
)
;
}
if
(
typeof
componentClass
.
getDefaultProps
=
=
=
'
function
'
)
{
false
?
warning
(
componentClass
.
getDefaultProps
.
isReactClassApproved
'
getDefaultProps
is
only
used
on
classic
React
.
createClass
'
+
'
definitions
.
Use
a
static
property
named
defaultProps
instead
.
'
)
:
undefined
;
}
}
var
ReactElementValidator
=
{
createElement
:
function
(
type
props
children
)
{
var
validType
=
typeof
type
=
=
=
'
string
'
|
|
typeof
type
=
=
=
'
function
'
;
false
?
warning
(
validType
'
React
.
createElement
:
type
should
not
be
null
undefined
boolean
or
'
+
'
number
.
It
should
be
a
string
(
for
DOM
elements
)
or
a
ReactClass
'
+
'
(
for
composite
components
)
.
%
s
'
getDeclarationErrorAddendum
(
)
)
:
undefined
;
var
element
=
ReactElement
.
createElement
.
apply
(
this
arguments
)
;
if
(
element
=
=
null
)
{
return
element
;
}
if
(
validType
)
{
for
(
var
i
=
2
;
i
<
arguments
.
length
;
i
+
+
)
{
validateChildKeys
(
arguments
[
i
]
type
)
;
}
}
validatePropTypes
(
element
)
;
return
element
;
}
createFactory
:
function
(
type
)
{
var
validatedFactory
=
ReactElementValidator
.
createElement
.
bind
(
null
type
)
;
validatedFactory
.
type
=
type
;
if
(
false
)
{
if
(
canDefineProperty
)
{
Object
.
defineProperty
(
validatedFactory
'
type
'
{
enumerable
:
false
get
:
function
(
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
false
'
Factory
.
type
is
deprecated
.
Access
the
class
directly
'
+
'
before
passing
it
to
createFactory
.
'
)
:
undefined
;
Object
.
defineProperty
(
this
'
type
'
{
value
:
type
}
)
;
return
type
;
}
}
)
;
}
}
return
validatedFactory
;
}
cloneElement
:
function
(
element
props
children
)
{
var
newElement
=
ReactElement
.
cloneElement
.
apply
(
this
arguments
)
;
for
(
var
i
=
2
;
i
<
arguments
.
length
;
i
+
+
)
{
validateChildKeys
(
arguments
[
i
]
newElement
.
type
)
;
}
validatePropTypes
(
newElement
)
;
return
newElement
;
}
}
;
module
.
exports
=
ReactElementValidator
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
mapObject
(
object
callback
context
)
{
if
(
!
object
)
{
return
null
;
}
var
result
=
{
}
;
for
(
var
name
in
object
)
{
if
(
hasOwnProperty
.
call
(
object
name
)
)
{
result
[
name
]
=
callback
.
call
(
context
object
[
name
]
name
object
)
;
}
}
return
result
;
}
module
.
exports
=
mapObject
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
ReactElement
=
__webpack_require__
(
57
)
;
var
invariant
=
__webpack_require__
(
28
)
;
function
onlyChild
(
children
)
{
!
ReactElement
.
isValidElement
(
children
)
?
false
?
invariant
(
false
'
onlyChild
must
be
passed
a
children
with
exactly
one
child
.
'
)
:
invariant
(
false
)
:
undefined
;
return
children
;
}
module
.
exports
=
onlyChild
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
assign
=
__webpack_require__
(
54
)
;
var
warning
=
__webpack_require__
(
40
)
;
function
deprecated
(
fnName
newModule
newPackage
ctx
fn
)
{
var
warned
=
false
;
if
(
false
)
{
var
newFn
=
function
(
)
{
process
.
env
.
NODE_ENV
!
=
=
'
production
'
?
warning
(
warned
'
React
.
%
s
is
deprecated
.
Please
use
%
s
.
%
s
from
require
'
+
'
(
\
'
%
s
\
'
)
'
+
'
instead
.
'
fnName
newModule
fnName
newPackage
)
:
undefined
;
warned
=
true
;
return
fn
.
apply
(
ctx
arguments
)
;
}
;
return
assign
(
newFn
fn
)
;
}
return
fn
;
}
module
.
exports
=
deprecated
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
var
_react
=
__webpack_require__
(
17
)
;
exports
[
"
default
"
]
=
_react
.
PropTypes
.
shape
(
{
subscribe
:
_react
.
PropTypes
.
func
.
isRequired
dispatch
:
_react
.
PropTypes
.
func
.
isRequired
getState
:
_react
.
PropTypes
.
func
.
isRequired
}
)
;
}
function
(
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
warning
;
function
warning
(
message
)
{
if
(
typeof
console
!
=
=
'
undefined
'
&
&
typeof
console
.
error
=
=
=
'
function
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
e
)
{
}
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
connect
;
var
_react
=
__webpack_require__
(
17
)
;
var
_storeShape
=
__webpack_require__
(
169
)
;
var
_storeShape2
=
_interopRequireDefault
(
_storeShape
)
;
var
_shallowEqual
=
__webpack_require__
(
172
)
;
var
_shallowEqual2
=
_interopRequireDefault
(
_shallowEqual
)
;
var
_wrapActionCreators
=
__webpack_require__
(
173
)
;
var
_wrapActionCreators2
=
_interopRequireDefault
(
_wrapActionCreators
)
;
var
_warning
=
__webpack_require__
(
170
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
var
_isPlainObject
=
__webpack_require__
(
4
)
;
var
_isPlainObject2
=
_interopRequireDefault
(
_isPlainObject
)
;
var
_hoistNonReactStatics
=
__webpack_require__
(
174
)
;
var
_hoistNonReactStatics2
=
_interopRequireDefault
(
_hoistNonReactStatics
)
;
var
_invariant
=
__webpack_require__
(
175
)
;
var
_invariant2
=
_interopRequireDefault
(
_invariant
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
defaultMapStateToProps
=
function
defaultMapStateToProps
(
state
)
{
return
{
}
;
}
;
var
defaultMapDispatchToProps
=
function
defaultMapDispatchToProps
(
dispatch
)
{
return
{
dispatch
:
dispatch
}
;
}
;
var
defaultMergeProps
=
function
defaultMergeProps
(
stateProps
dispatchProps
parentProps
)
{
return
_extends
(
{
}
parentProps
stateProps
dispatchProps
)
;
}
;
function
getDisplayName
(
WrappedComponent
)
{
return
WrappedComponent
.
displayName
|
|
WrappedComponent
.
name
|
|
'
Component
'
;
}
var
errorObject
=
{
value
:
null
}
;
function
tryCatch
(
fn
ctx
)
{
try
{
return
fn
.
apply
(
ctx
)
;
}
catch
(
e
)
{
errorObject
.
value
=
e
;
return
errorObject
;
}
}
var
nextVersion
=
0
;
function
connect
(
mapStateToProps
mapDispatchToProps
mergeProps
)
{
var
options
=
arguments
.
length
<
=
3
|
|
arguments
[
3
]
=
=
=
undefined
?
{
}
:
arguments
[
3
]
;
var
shouldSubscribe
=
Boolean
(
mapStateToProps
)
;
var
mapState
=
mapStateToProps
|
|
defaultMapStateToProps
;
var
mapDispatch
=
undefined
;
if
(
typeof
mapDispatchToProps
=
=
=
'
function
'
)
{
mapDispatch
=
mapDispatchToProps
;
}
else
if
(
!
mapDispatchToProps
)
{
mapDispatch
=
defaultMapDispatchToProps
;
}
else
{
mapDispatch
=
(
0
_wrapActionCreators2
[
"
default
"
]
)
(
mapDispatchToProps
)
;
}
var
finalMergeProps
=
mergeProps
|
|
defaultMergeProps
;
var
_options
pure
=
options
.
pure
;
var
pure
=
_options
pure
=
=
=
undefined
?
true
:
_options
pure
;
var
_options
withRef
=
options
.
withRef
;
var
withRef
=
_options
withRef
=
=
=
undefined
?
false
:
_options
withRef
;
var
checkMergedEquals
=
pure
&
&
finalMergeProps
!
=
=
defaultMergeProps
;
var
version
=
nextVersion
+
+
;
return
function
wrapWithConnect
(
WrappedComponent
)
{
var
connectDisplayName
=
'
Connect
(
'
+
getDisplayName
(
WrappedComponent
)
+
'
)
'
;
function
checkStateShape
(
props
methodName
)
{
if
(
!
(
0
_isPlainObject2
[
"
default
"
]
)
(
props
)
)
{
(
0
_warning2
[
"
default
"
]
)
(
methodName
+
'
(
)
in
'
+
connectDisplayName
+
'
must
return
a
plain
object
.
'
+
(
'
Instead
received
'
+
props
+
'
.
'
)
)
;
}
}
function
computeMergedProps
(
stateProps
dispatchProps
parentProps
)
{
var
mergedProps
=
finalMergeProps
(
stateProps
dispatchProps
parentProps
)
;
if
(
false
)
{
checkStateShape
(
mergedProps
'
mergeProps
'
)
;
}
return
mergedProps
;
}
var
Connect
=
function
(
_Component
)
{
_inherits
(
Connect
_Component
)
;
Connect
.
prototype
.
shouldComponentUpdate
=
function
shouldComponentUpdate
(
)
{
return
!
pure
|
|
this
.
haveOwnPropsChanged
|
|
this
.
hasStoreStateChanged
;
}
;
function
Connect
(
props
context
)
{
_classCallCheck
(
this
Connect
)
;
var
_this
=
_possibleConstructorReturn
(
this
_Component
.
call
(
this
props
context
)
)
;
_this
.
version
=
version
;
_this
.
store
=
props
.
store
|
|
context
.
store
;
(
0
_invariant2
[
"
default
"
]
)
(
_this
.
store
'
Could
not
find
"
store
"
in
either
the
context
or
'
+
(
'
props
of
"
'
+
connectDisplayName
+
'
"
.
'
)
+
'
Either
wrap
the
root
component
in
a
<
Provider
>
'
+
(
'
or
explicitly
pass
"
store
"
as
a
prop
to
"
'
+
connectDisplayName
+
'
"
.
'
)
)
;
var
storeState
=
_this
.
store
.
getState
(
)
;
_this
.
state
=
{
storeState
:
storeState
}
;
_this
.
clearCache
(
)
;
return
_this
;
}
Connect
.
prototype
.
computeStateProps
=
function
computeStateProps
(
store
props
)
{
if
(
!
this
.
finalMapStateToProps
)
{
return
this
.
configureFinalMapState
(
store
props
)
;
}
var
state
=
store
.
getState
(
)
;
var
stateProps
=
this
.
doStatePropsDependOnOwnProps
?
this
.
finalMapStateToProps
(
state
props
)
:
this
.
finalMapStateToProps
(
state
)
;
if
(
false
)
{
checkStateShape
(
stateProps
'
mapStateToProps
'
)
;
}
return
stateProps
;
}
;
Connect
.
prototype
.
configureFinalMapState
=
function
configureFinalMapState
(
store
props
)
{
var
mappedState
=
mapState
(
store
.
getState
(
)
props
)
;
var
isFactory
=
typeof
mappedState
=
=
=
'
function
'
;
this
.
finalMapStateToProps
=
isFactory
?
mappedState
:
mapState
;
this
.
doStatePropsDependOnOwnProps
=
this
.
finalMapStateToProps
.
length
!
=
=
1
;
if
(
isFactory
)
{
return
this
.
computeStateProps
(
store
props
)
;
}
if
(
false
)
{
checkStateShape
(
mappedState
'
mapStateToProps
'
)
;
}
return
mappedState
;
}
;
Connect
.
prototype
.
computeDispatchProps
=
function
computeDispatchProps
(
store
props
)
{
if
(
!
this
.
finalMapDispatchToProps
)
{
return
this
.
configureFinalMapDispatch
(
store
props
)
;
}
var
dispatch
=
store
.
dispatch
;
var
dispatchProps
=
this
.
doDispatchPropsDependOnOwnProps
?
this
.
finalMapDispatchToProps
(
dispatch
props
)
:
this
.
finalMapDispatchToProps
(
dispatch
)
;
if
(
false
)
{
checkStateShape
(
dispatchProps
'
mapDispatchToProps
'
)
;
}
return
dispatchProps
;
}
;
Connect
.
prototype
.
configureFinalMapDispatch
=
function
configureFinalMapDispatch
(
store
props
)
{
var
mappedDispatch
=
mapDispatch
(
store
.
dispatch
props
)
;
var
isFactory
=
typeof
mappedDispatch
=
=
=
'
function
'
;
this
.
finalMapDispatchToProps
=
isFactory
?
mappedDispatch
:
mapDispatch
;
this
.
doDispatchPropsDependOnOwnProps
=
this
.
finalMapDispatchToProps
.
length
!
=
=
1
;
if
(
isFactory
)
{
return
this
.
computeDispatchProps
(
store
props
)
;
}
if
(
false
)
{
checkStateShape
(
mappedDispatch
'
mapDispatchToProps
'
)
;
}
return
mappedDispatch
;
}
;
Connect
.
prototype
.
updateStatePropsIfNeeded
=
function
updateStatePropsIfNeeded
(
)
{
var
nextStateProps
=
this
.
computeStateProps
(
this
.
store
this
.
props
)
;
if
(
this
.
stateProps
&
&
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextStateProps
this
.
stateProps
)
)
{
return
false
;
}
this
.
stateProps
=
nextStateProps
;
return
true
;
}
;
Connect
.
prototype
.
updateDispatchPropsIfNeeded
=
function
updateDispatchPropsIfNeeded
(
)
{
var
nextDispatchProps
=
this
.
computeDispatchProps
(
this
.
store
this
.
props
)
;
if
(
this
.
dispatchProps
&
&
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextDispatchProps
this
.
dispatchProps
)
)
{
return
false
;
}
this
.
dispatchProps
=
nextDispatchProps
;
return
true
;
}
;
Connect
.
prototype
.
updateMergedPropsIfNeeded
=
function
updateMergedPropsIfNeeded
(
)
{
var
nextMergedProps
=
computeMergedProps
(
this
.
stateProps
this
.
dispatchProps
this
.
props
)
;
if
(
this
.
mergedProps
&
&
checkMergedEquals
&
&
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextMergedProps
this
.
mergedProps
)
)
{
return
false
;
}
this
.
mergedProps
=
nextMergedProps
;
return
true
;
}
;
Connect
.
prototype
.
isSubscribed
=
function
isSubscribed
(
)
{
return
typeof
this
.
unsubscribe
=
=
=
'
function
'
;
}
;
Connect
.
prototype
.
trySubscribe
=
function
trySubscribe
(
)
{
if
(
shouldSubscribe
&
&
!
this
.
unsubscribe
)
{
this
.
unsubscribe
=
this
.
store
.
subscribe
(
this
.
handleChange
.
bind
(
this
)
)
;
this
.
handleChange
(
)
;
}
}
;
Connect
.
prototype
.
tryUnsubscribe
=
function
tryUnsubscribe
(
)
{
if
(
this
.
unsubscribe
)
{
this
.
unsubscribe
(
)
;
this
.
unsubscribe
=
null
;
}
}
;
Connect
.
prototype
.
componentDidMount
=
function
componentDidMount
(
)
{
this
.
trySubscribe
(
)
;
}
;
Connect
.
prototype
.
componentWillReceiveProps
=
function
componentWillReceiveProps
(
nextProps
)
{
if
(
!
pure
|
|
!
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextProps
this
.
props
)
)
{
this
.
haveOwnPropsChanged
=
true
;
}
}
;
Connect
.
prototype
.
componentWillUnmount
=
function
componentWillUnmount
(
)
{
this
.
tryUnsubscribe
(
)
;
this
.
clearCache
(
)
;
}
;
Connect
.
prototype
.
clearCache
=
function
clearCache
(
)
{
this
.
dispatchProps
=
null
;
this
.
stateProps
=
null
;
this
.
mergedProps
=
null
;
this
.
haveOwnPropsChanged
=
true
;
this
.
hasStoreStateChanged
=
true
;
this
.
haveStatePropsBeenPrecalculated
=
false
;
this
.
statePropsPrecalculationError
=
null
;
this
.
renderedElement
=
null
;
this
.
finalMapDispatchToProps
=
null
;
this
.
finalMapStateToProps
=
null
;
}
;
Connect
.
prototype
.
handleChange
=
function
handleChange
(
)
{
if
(
!
this
.
unsubscribe
)
{
return
;
}
var
storeState
=
this
.
store
.
getState
(
)
;
var
prevStoreState
=
this
.
state
.
storeState
;
if
(
pure
&
&
prevStoreState
=
=
=
storeState
)
{
return
;
}
if
(
pure
&
&
!
this
.
doStatePropsDependOnOwnProps
)
{
var
haveStatePropsChanged
=
tryCatch
(
this
.
updateStatePropsIfNeeded
this
)
;
if
(
!
haveStatePropsChanged
)
{
return
;
}
if
(
haveStatePropsChanged
=
=
=
errorObject
)
{
this
.
statePropsPrecalculationError
=
errorObject
.
value
;
}
this
.
haveStatePropsBeenPrecalculated
=
true
;
}
this
.
hasStoreStateChanged
=
true
;
this
.
setState
(
{
storeState
:
storeState
}
)
;
}
;
Connect
.
prototype
.
getWrappedInstance
=
function
getWrappedInstance
(
)
{
(
0
_invariant2
[
"
default
"
]
)
(
withRef
'
To
access
the
wrapped
instance
you
need
to
specify
'
+
'
{
withRef
:
true
}
as
the
fourth
argument
of
the
connect
(
)
call
.
'
)
;
return
this
.
refs
.
wrappedInstance
;
}
;
Connect
.
prototype
.
render
=
function
render
(
)
{
var
haveOwnPropsChanged
=
this
.
haveOwnPropsChanged
;
var
hasStoreStateChanged
=
this
.
hasStoreStateChanged
;
var
haveStatePropsBeenPrecalculated
=
this
.
haveStatePropsBeenPrecalculated
;
var
statePropsPrecalculationError
=
this
.
statePropsPrecalculationError
;
var
renderedElement
=
this
.
renderedElement
;
this
.
haveOwnPropsChanged
=
false
;
this
.
hasStoreStateChanged
=
false
;
this
.
haveStatePropsBeenPrecalculated
=
false
;
this
.
statePropsPrecalculationError
=
null
;
if
(
statePropsPrecalculationError
)
{
throw
statePropsPrecalculationError
;
}
var
shouldUpdateStateProps
=
true
;
var
shouldUpdateDispatchProps
=
true
;
if
(
pure
&
&
renderedElement
)
{
shouldUpdateStateProps
=
hasStoreStateChanged
|
|
haveOwnPropsChanged
&
&
this
.
doStatePropsDependOnOwnProps
;
shouldUpdateDispatchProps
=
haveOwnPropsChanged
&
&
this
.
doDispatchPropsDependOnOwnProps
;
}
var
haveStatePropsChanged
=
false
;
var
haveDispatchPropsChanged
=
false
;
if
(
haveStatePropsBeenPrecalculated
)
{
haveStatePropsChanged
=
true
;
}
else
if
(
shouldUpdateStateProps
)
{
haveStatePropsChanged
=
this
.
updateStatePropsIfNeeded
(
)
;
}
if
(
shouldUpdateDispatchProps
)
{
haveDispatchPropsChanged
=
this
.
updateDispatchPropsIfNeeded
(
)
;
}
var
haveMergedPropsChanged
=
true
;
if
(
haveStatePropsChanged
|
|
haveDispatchPropsChanged
|
|
haveOwnPropsChanged
)
{
haveMergedPropsChanged
=
this
.
updateMergedPropsIfNeeded
(
)
;
}
else
{
haveMergedPropsChanged
=
false
;
}
if
(
!
haveMergedPropsChanged
&
&
renderedElement
)
{
return
renderedElement
;
}
if
(
withRef
)
{
this
.
renderedElement
=
(
0
_react
.
createElement
)
(
WrappedComponent
_extends
(
{
}
this
.
mergedProps
{
ref
:
'
wrappedInstance
'
}
)
)
;
}
else
{
this
.
renderedElement
=
(
0
_react
.
createElement
)
(
WrappedComponent
this
.
mergedProps
)
;
}
return
this
.
renderedElement
;
}
;
return
Connect
;
}
(
_react
.
Component
)
;
Connect
.
displayName
=
connectDisplayName
;
Connect
.
WrappedComponent
=
WrappedComponent
;
Connect
.
contextTypes
=
{
store
:
_storeShape2
[
"
default
"
]
}
;
Connect
.
propTypes
=
{
store
:
_storeShape2
[
"
default
"
]
}
;
if
(
false
)
{
Connect
.
prototype
.
componentWillUpdate
=
function
componentWillUpdate
(
)
{
if
(
this
.
version
=
=
=
version
)
{
return
;
}
this
.
version
=
version
;
this
.
trySubscribe
(
)
;
}
;
}
return
(
0
_hoistNonReactStatics2
[
"
default
"
]
)
(
Connect
WrappedComponent
)
;
}
;
}
}
function
(
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
shallowEqual
;
function
shallowEqual
(
objA
objB
)
{
if
(
objA
=
=
=
objB
)
{
return
true
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
var
hasOwn
=
Object
.
prototype
.
hasOwnProperty
;
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwn
.
call
(
objB
keysA
[
i
]
)
|
|
objA
[
keysA
[
i
]
]
!
=
=
objB
[
keysA
[
i
]
]
)
{
return
false
;
}
}
return
true
;
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
wrapActionCreators
;
var
_redux
=
__webpack_require__
(
2
)
;
function
wrapActionCreators
(
actionCreators
)
{
return
function
(
dispatch
)
{
return
(
0
_redux
.
bindActionCreators
)
(
actionCreators
dispatch
)
;
}
;
}
}
function
(
module
exports
)
{
'
use
strict
'
;
var
REACT_STATICS
=
{
childContextTypes
:
true
contextTypes
:
true
defaultProps
:
true
displayName
:
true
getDefaultProps
:
true
mixins
:
true
propTypes
:
true
type
:
true
}
;
var
KNOWN_STATICS
=
{
name
:
true
length
:
true
prototype
:
true
caller
:
true
arguments
:
true
arity
:
true
}
;
var
isGetOwnPropertySymbolsAvailable
=
typeof
Object
.
getOwnPropertySymbols
=
=
=
'
function
'
;
module
.
exports
=
function
hoistNonReactStatics
(
targetComponent
sourceComponent
customStatics
)
{
if
(
typeof
sourceComponent
!
=
=
'
string
'
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
sourceComponent
)
;
if
(
isGetOwnPropertySymbolsAvailable
)
{
keys
=
keys
.
concat
(
Object
.
getOwnPropertySymbols
(
sourceComponent
)
)
;
}
for
(
var
i
=
0
;
i
<
keys
.
length
;
+
+
i
)
{
if
(
!
REACT_STATICS
[
keys
[
i
]
]
&
&
!
KNOWN_STATICS
[
keys
[
i
]
]
&
&
(
!
customStatics
|
|
!
customStatics
[
keys
[
i
]
]
)
)
{
try
{
targetComponent
[
keys
[
i
]
]
=
sourceComponent
[
keys
[
i
]
]
;
}
catch
(
error
)
{
}
}
}
}
return
targetComponent
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
function
(
condition
format
a
b
c
d
e
f
)
{
if
(
false
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
invariant
requires
an
error
message
argument
'
)
;
}
}
if
(
!
condition
)
{
var
error
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
;
module
.
exports
=
invariant
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
module
.
exports
=
__webpack_require__
(
19
)
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
{
Ci
Cu
Cc
components
}
=
__webpack_require__
(
178
)
;
var
Services
=
__webpack_require__
(
183
)
;
var
promise
=
__webpack_require__
(
189
)
;
const
{
FileUtils
}
=
__webpack_require__
(
190
)
;
exports
.
safeErrorString
=
function
safeErrorString
(
aError
)
{
try
{
let
errorString
=
aError
.
toString
(
)
;
if
(
typeof
errorString
=
=
"
string
"
)
{
try
{
if
(
aError
.
stack
)
{
let
stack
=
aError
.
stack
.
toString
(
)
;
if
(
typeof
stack
=
=
"
string
"
)
{
errorString
+
=
"
\
nStack
:
"
+
stack
;
}
}
}
catch
(
ee
)
{
}
if
(
typeof
aError
.
lineNumber
=
=
"
number
"
&
&
typeof
aError
.
columnNumber
=
=
"
number
"
)
{
errorString
+
=
"
Line
:
"
+
aError
.
lineNumber
+
"
column
:
"
+
aError
.
columnNumber
;
}
return
errorString
;
}
}
catch
(
ee
)
{
}
return
Object
.
prototype
.
toString
.
call
(
aError
)
;
}
exports
.
reportException
=
function
reportException
(
aWho
aException
)
{
let
msg
=
aWho
+
"
threw
an
exception
:
"
+
exports
.
safeErrorString
(
aException
)
;
console
.
log
(
msg
)
;
}
exports
.
makeInfallible
=
function
makeInfallible
(
aHandler
aName
)
{
if
(
!
aName
)
aName
=
aHandler
.
name
;
return
function
(
)
{
return
aHandler
.
apply
(
this
arguments
)
;
}
}
exports
.
executeSoon
=
function
executeSoon
(
aFn
)
{
setTimeout
(
aFn
0
)
;
}
;
exports
.
waitForTick
=
function
waitForTick
(
)
{
let
deferred
=
promise
.
defer
(
)
;
exports
.
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
;
exports
.
waitForTime
=
function
waitForTime
(
aDelay
)
{
let
deferred
=
promise
.
defer
(
)
;
setTimeout
(
deferred
.
resolve
aDelay
)
;
return
deferred
.
promise
;
}
;
exports
.
yieldingEach
=
function
yieldingEach
(
aArray
aFn
)
{
const
deferred
=
promise
.
defer
(
)
;
let
i
=
0
;
let
len
=
aArray
.
length
;
let
outstanding
=
[
deferred
.
promise
]
;
(
function
loop
(
)
{
const
start
=
Date
.
now
(
)
;
while
(
i
<
len
)
{
if
(
Date
.
now
(
)
-
start
>
16
)
{
exports
.
executeSoon
(
loop
)
;
return
;
}
try
{
outstanding
.
push
(
aFn
(
aArray
[
i
]
i
+
+
)
)
;
}
catch
(
e
)
{
deferred
.
reject
(
e
)
;
return
;
}
}
deferred
.
resolve
(
)
;
}
(
)
)
;
return
promise
.
all
(
outstanding
)
;
}
exports
.
defineLazyPrototypeGetter
=
function
defineLazyPrototypeGetter
(
aObject
aKey
aCallback
)
{
Object
.
defineProperty
(
aObject
aKey
{
configurable
:
true
get
:
function
(
)
{
const
value
=
aCallback
.
call
(
this
)
;
Object
.
defineProperty
(
this
aKey
{
configurable
:
true
writable
:
true
value
:
value
}
)
;
return
value
;
}
}
)
;
}
exports
.
getProperty
=
function
getProperty
(
aObj
aKey
)
{
let
root
=
aObj
;
try
{
do
{
const
desc
=
aObj
.
getOwnPropertyDescriptor
(
aKey
)
;
if
(
desc
)
{
if
(
"
value
"
in
desc
)
{
return
desc
.
value
;
}
return
exports
.
hasSafeGetter
(
desc
)
?
desc
.
get
.
call
(
root
)
.
return
:
undefined
;
}
aObj
=
aObj
.
proto
;
}
while
(
aObj
)
;
}
catch
(
e
)
{
exports
.
reportException
(
"
getProperty
"
e
)
;
}
return
undefined
;
}
;
exports
.
hasSafeGetter
=
function
hasSafeGetter
(
aDesc
)
{
try
{
let
fn
=
aDesc
.
get
.
unwrap
(
)
;
return
fn
&
&
fn
.
callable
&
&
fn
.
class
=
=
"
Function
"
&
&
fn
.
script
=
=
=
undefined
;
}
catch
(
e
)
{
return
false
;
}
}
;
exports
.
isSafeJSObject
=
function
isSafeJSObject
(
aObj
)
{
if
(
isWorker
)
{
return
false
;
}
if
(
Cu
.
getGlobalForObject
(
aObj
)
=
=
Cu
.
getGlobalForObject
(
exports
.
isSafeJSObject
)
)
{
return
true
;
}
let
principal
=
Cu
.
getObjectPrincipal
(
aObj
)
;
if
(
Services
.
scriptSecurityManager
.
isSystemPrincipal
(
principal
)
)
{
return
true
;
}
return
Cu
.
isXrayWrapper
(
aObj
)
;
}
;
exports
.
dumpn
=
function
dumpn
(
str
)
{
if
(
exports
.
dumpn
.
wantLogging
)
{
console
.
log
(
"
DBG
-
SERVER
:
"
+
str
+
"
\
n
"
)
;
}
}
exports
.
dumpn
.
wantLogging
=
false
;
exports
.
dumpv
=
function
(
msg
)
{
if
(
exports
.
dumpv
.
wantVerbose
)
{
exports
.
dumpn
(
msg
)
;
}
}
;
exports
.
dumpv
.
wantVerbose
=
false
;
exports
.
update
=
function
update
(
aTarget
.
.
.
aArgs
)
{
for
(
let
attrs
of
aArgs
)
{
for
(
let
key
in
attrs
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
attrs
key
)
;
if
(
desc
)
{
Object
.
defineProperty
(
aTarget
key
desc
)
;
}
}
}
return
aTarget
;
}
exports
.
values
=
function
values
(
aObject
)
{
return
Object
.
keys
(
aObject
)
.
map
(
k
=
>
aObject
[
k
]
)
;
}
exports
.
defineLazyGetter
=
function
defineLazyGetter
(
aObject
aName
aLambda
)
{
Object
.
defineProperty
(
aObject
aName
{
get
:
function
(
)
{
delete
aObject
[
aName
]
;
return
aObject
[
aName
]
=
aLambda
.
apply
(
aObject
)
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
;
let
haveLoggedDeprecationMessage
=
false
;
exports
.
dbg_assert
=
function
dbg_assert
(
cond
e
)
{
if
(
!
haveLoggedDeprecationMessage
)
{
haveLoggedDeprecationMessage
=
true
;
const
deprecationMessage
=
"
DevToolsUtils
.
dbg_assert
is
deprecated
!
Use
DevToolsUtils
.
assert
instead
!
"
+
Error
(
)
.
stack
;
console
.
log
(
deprecationMessage
)
;
if
(
typeof
console
=
=
=
"
object
"
&
&
console
&
&
console
.
warn
)
{
console
.
warn
(
deprecationMessage
)
;
}
}
if
(
!
cond
)
{
return
e
;
}
}
;
const
{
AppConstants
}
=
__webpack_require__
(
191
)
;
exports
.
noop
=
function
(
)
{
}
;
function
reallyAssert
(
condition
message
)
{
if
(
!
condition
)
{
const
err
=
new
Error
(
"
Assertion
failure
:
"
+
message
)
;
exports
.
reportException
(
"
DevToolsUtils
.
assert
"
err
)
;
throw
err
;
}
}
Object
.
defineProperty
(
exports
"
assert
"
{
get
:
(
)
=
>
(
AppConstants
.
DEBUG
|
|
AppConstants
.
DEBUG_JS_MODULES
|
|
this
.
testing
)
?
reallyAssert
:
exports
.
noop
}
)
exports
.
defineLazyModuleGetter
=
function
defineLazyModuleGetter
(
aObject
aName
aResource
aSymbol
)
{
this
.
defineLazyGetter
(
aObject
aName
function
XPCU_moduleLambda
(
)
{
var
temp
=
{
}
;
Cu
.
import
(
aResource
temp
)
;
return
temp
[
aSymbol
|
|
aName
]
;
}
)
;
}
;
const
{
NetUtil
}
=
__webpack_require__
(
192
)
;
const
{
TextDecoder
OS
}
=
__webpack_require__
(
193
)
;
const
NetworkHelper
=
__webpack_require__
(
194
)
;
function
mainThreadFetch
(
aURL
aOptions
=
{
loadFromCache
:
true
policy
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
window
:
null
charset
:
null
}
)
{
let
url
=
aURL
.
split
(
"
-
>
"
)
.
pop
(
)
;
let
channel
;
try
{
channel
=
newChannelForURL
(
url
aOptions
)
;
}
catch
(
ex
)
{
return
promise
.
reject
(
ex
)
;
}
channel
.
loadFlags
=
aOptions
.
loadFromCache
?
channel
.
LOAD_FROM_CACHE
:
channel
.
LOAD_BYPASS_CACHE
;
if
(
aOptions
.
window
)
{
channel
.
loadGroup
=
aOptions
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocumentLoader
)
.
loadGroup
;
}
let
deferred
=
promise
.
defer
(
)
;
let
onResponse
=
(
stream
status
request
)
=
>
{
if
(
!
components
.
isSuccessCode
(
status
)
)
{
deferred
.
reject
(
new
Error
(
Failed
to
fetch
{
url
}
.
Code
{
status
}
.
)
)
;
return
;
}
try
{
let
available
=
stream
.
available
(
)
;
let
source
=
NetUtil
.
readInputStreamToString
(
stream
available
)
;
stream
.
close
(
)
;
let
charset
=
channel
.
contentCharset
|
|
aOptions
.
charset
|
|
"
UTF
-
8
"
;
let
unicodeSource
=
NetworkHelper
.
convertToUnicode
(
source
charset
)
;
deferred
.
resolve
(
{
content
:
unicodeSource
contentType
:
request
.
contentType
}
)
;
}
catch
(
ex
)
{
let
uri
=
request
.
originalURI
;
if
(
ex
.
name
=
=
=
"
NS_BASE_STREAM_CLOSED
"
&
&
uri
instanceof
Ci
.
nsIFileURL
)
{
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
let
result
=
OS
.
File
.
read
(
uri
.
file
.
path
)
.
then
(
bytes
=
>
{
let
decoder
=
new
TextDecoder
(
)
;
let
content
=
decoder
.
decode
(
bytes
)
;
return
{
content
contentType
:
"
text
/
plain
"
}
;
}
)
;
deferred
.
resolve
(
result
)
;
}
else
{
deferred
.
reject
(
ex
)
;
}
}
}
;
try
{
NetUtil
.
asyncFetch
(
channel
onResponse
)
;
}
catch
(
ex
)
{
return
promise
.
reject
(
ex
)
;
}
return
deferred
.
promise
;
}
function
newChannelForURL
(
url
{
policy
}
)
{
let
channelOptions
=
{
contentPolicyType
:
policy
loadUsingSystemPrincipal
:
true
uri
:
url
}
;
try
{
return
NetUtil
.
newChannel
(
channelOptions
)
;
}
catch
(
e
)
{
channelOptions
.
uri
=
"
file
:
/
/
"
+
url
;
return
NetUtil
.
newChannel
(
channelOptions
)
;
}
}
if
(
typeof
WorkerGlobalScope
=
=
=
'
undefined
'
)
{
exports
.
fetch
=
mainThreadFetch
;
}
else
{
exports
.
fetch
=
function
(
url
options
)
{
return
rpc
(
"
fetch
"
url
options
)
;
}
}
exports
.
settleAll
=
values
=
>
{
if
(
values
=
=
=
null
|
|
typeof
(
values
[
Symbol
.
iterator
]
)
!
=
"
function
"
)
{
throw
new
Error
(
"
settleAll
(
)
expects
an
iterable
.
"
)
;
}
let
deferred
=
promise
.
defer
(
)
;
values
=
Array
.
isArray
(
values
)
?
values
:
[
.
.
.
values
]
;
let
countdown
=
values
.
length
;
let
resolutionValues
=
new
Array
(
countdown
)
;
let
rejectionValue
;
let
rejectionOccurred
=
false
;
if
(
!
countdown
)
{
deferred
.
resolve
(
resolutionValues
)
;
return
deferred
.
promise
;
}
function
checkForCompletion
(
)
{
if
(
-
-
countdown
>
0
)
{
return
;
}
if
(
!
rejectionOccurred
)
{
deferred
.
resolve
(
resolutionValues
)
;
}
else
{
deferred
.
reject
(
rejectionValue
)
;
}
}
for
(
let
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
let
index
=
i
;
let
value
=
values
[
i
]
;
let
resolver
=
result
=
>
{
resolutionValues
[
index
]
=
result
;
checkForCompletion
(
)
;
}
;
let
rejecter
=
error
=
>
{
if
(
!
rejectionOccurred
)
{
rejectionValue
=
error
;
rejectionOccurred
=
true
;
}
checkForCompletion
(
)
;
}
;
if
(
value
&
&
typeof
(
value
.
then
)
=
=
"
function
"
)
{
value
.
then
(
resolver
rejecter
)
;
}
else
{
resolver
(
value
)
;
}
}
return
deferred
.
promise
;
}
;
var
testing
=
false
;
Object
.
defineProperty
(
exports
"
testing
"
{
get
:
function
(
)
{
return
testing
;
}
set
:
function
(
state
)
{
testing
=
state
;
}
}
)
;
exports
.
openFileStream
=
function
(
filePath
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
uri
=
NetUtil
.
newURI
(
new
FileUtils
.
File
(
filePath
)
)
;
NetUtil
.
asyncFetch
(
{
uri
loadUsingSystemPrincipal
:
true
}
(
stream
result
)
=
>
{
if
(
!
components
.
isSuccessCode
(
result
)
)
{
reject
(
new
Error
(
Could
not
open
"
{
filePath
}
"
:
result
=
{
result
}
)
)
;
return
;
}
resolve
(
stream
)
;
}
)
;
}
)
;
}
exports
.
isGenerator
=
function
(
fn
)
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
return
false
;
}
let
proto
=
Object
.
getPrototypeOf
(
fn
)
;
if
(
!
proto
)
{
return
false
;
}
let
ctor
=
proto
.
constructor
;
if
(
!
ctor
)
{
return
false
;
}
return
ctor
.
name
=
=
"
GeneratorFunction
"
;
}
;
exports
.
isPromise
=
function
(
p
)
{
return
p
&
&
typeof
p
.
then
=
=
=
"
function
"
;
}
;
exports
.
isSavedFrame
=
function
(
thing
)
{
return
Object
.
prototype
.
toString
.
call
(
thing
)
=
=
=
"
[
object
SavedFrame
]
"
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
{
inDOMUtils
}
=
__webpack_require__
(
179
)
;
var
ourServices
=
{
inIDOMUtils
:
inDOMUtils
nsIClipboardHelper
:
{
copyString
:
(
)
=
>
{
}
}
nsIXULChromeRegistry
:
{
isLocaleRTL
:
(
)
=
>
{
return
false
;
}
}
nsIDOMParser
:
{
}
}
;
module
.
exports
=
{
Cc
:
name
=
>
{
if
(
typeof
console
!
=
=
"
undefined
"
)
{
console
.
log
(
'
Cc
sham
for
'
name
)
;
}
return
{
getService
:
(
name
)
=
>
ourServices
[
name
]
createInstance
:
(
iface
)
=
>
ourServices
[
iface
]
}
;
}
CC
:
(
name
iface
method
)
=
>
{
if
(
typeof
console
!
=
=
"
undefined
"
)
{
console
.
log
(
'
CC
sham
for
'
name
iface
method
)
;
}
return
{
}
;
}
Ci
:
{
nsIThread
:
{
"
DISPATCH_NORMAL
"
:
0
"
DISPATCH_SYNC
"
:
1
}
nsIDOMNode
:
typeof
HTMLElement
!
=
=
"
undefined
"
?
HTMLElement
:
null
nsIFocusManager
:
{
MOVEFOCUS_BACKWARD
:
2
MOVEFOCUS_FORWARD
:
1
}
nsIDOMKeyEvent
:
{
}
nsIDOMCSSRule
:
{
"
UNKNOWN_RULE
"
:
0
"
STYLE_RULE
"
:
1
"
CHARSET_RULE
"
:
2
"
IMPORT_RULE
"
:
3
"
MEDIA_RULE
"
:
4
"
FONT_FACE_RULE
"
:
5
"
PAGE_RULE
"
:
6
"
KEYFRAMES_RULE
"
:
7
"
KEYFRAME_RULE
"
:
8
"
MOZ_KEYFRAMES_RULE
"
:
7
"
MOZ_KEYFRAME_RULE
"
:
8
"
NAMESPACE_RULE
"
:
10
"
COUNTER_STYLE_RULE
"
:
11
"
SUPPORTS_RULE
"
:
12
"
FONT_FEATURE_VALUES_RULE
"
:
14
}
inIDOMUtils
:
"
inIDOMUtils
"
nsIClipboardHelper
:
"
nsIClipboardHelper
"
nsIXULChromeRegistry
:
"
nsIXULChromeRegistry
"
}
Cu
:
{
reportError
:
msg
=
>
{
(
typeof
console
!
=
=
"
undefined
"
)
?
console
.
error
(
msg
)
:
dump
(
msg
)
}
callFunctionWithAsyncStack
:
fn
=
>
fn
(
)
}
Cr
:
{
}
components
:
{
isSuccessCode
:
(
)
=
>
(
returnCode
&
0x80000000
)
=
=
=
0
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
{
CSSLexer
}
=
__webpack_require__
(
180
)
;
var
{
cssColors
}
=
__webpack_require__
(
181
)
;
var
{
cssProperties
}
=
__webpack_require__
(
182
)
;
var
cssRGBMap
;
var
EXCLUDE_SHORTHANDS
=
(
1
<
<
0
)
;
var
INCLUDE_ALIASES
=
(
1
<
<
1
)
;
var
TYPE_LENGTH
=
0
;
var
TYPE_PERCENTAGE
=
1
;
var
TYPE_COLOR
=
2
;
var
TYPE_URL
=
3
;
var
TYPE_ANGLE
=
4
;
var
TYPE_FREQUENCY
=
5
;
var
TYPE_TIME
=
6
;
var
TYPE_GRADIENT
=
7
;
var
TYPE_TIMING_FUNCTION
=
8
;
var
TYPE_IMAGE_RECT
=
9
;
var
TYPE_NUMBER
=
10
;
function
getCSSLexer
(
text
)
{
return
new
CSSLexer
(
text
)
;
}
function
rgbToColorName
(
r
g
b
)
{
if
(
!
cssRGBMap
)
{
cssRGBMap
=
new
Map
(
)
;
for
(
let
name
in
cssColors
)
{
cssRGBMap
.
set
(
JSON
.
stringify
(
cssColors
[
name
]
)
name
)
;
}
}
let
value
=
cssRGBMap
.
get
(
JSON
.
stringify
(
[
r
g
b
]
)
)
;
if
(
!
value
)
{
throw
new
Error
(
"
no
such
color
"
)
;
}
return
value
;
}
function
_hslValue
(
n1
n2
hue
)
{
if
(
hue
>
6
.
0
)
{
hue
-
=
6
.
0
;
}
else
if
(
hue
<
0
.
0
)
{
hue
+
=
6
.
0
;
}
var
val
;
if
(
hue
<
1
.
0
)
{
val
=
n1
+
(
n2
-
n1
)
*
hue
;
}
else
if
(
hue
<
3
.
0
)
{
val
=
n2
;
}
else
if
(
hue
<
4
.
0
)
{
val
=
n1
+
(
n2
-
n1
)
*
(
4
.
0
-
hue
)
;
}
else
{
val
=
n1
;
}
return
val
;
}
function
hslToRGB
(
[
hue
saturation
lightness
]
)
{
var
red
;
var
green
;
var
blue
;
if
(
saturation
=
=
=
0
)
{
red
=
lightness
;
green
=
lightness
;
blue
=
lightness
;
}
else
{
var
m2
;
if
(
lightness
<
=
0
.
5
)
{
m2
=
lightness
*
(
1
.
0
+
saturation
)
;
}
else
{
m2
=
lightness
+
saturation
-
(
lightness
*
saturation
)
;
}
var
m1
=
(
2
.
0
*
lightness
)
-
m2
;
var
f
=
_hslValue
;
var
h6
=
hue
*
6
.
0
;
red
=
f
(
m1
m2
h6
+
2
)
;
green
=
f
(
m1
m2
h6
)
;
blue
=
f
(
m1
m2
h6
-
2
)
;
}
return
[
red
green
blue
]
;
}
function
colorToRGBA
(
name
)
{
name
=
name
.
trim
(
)
.
toLowerCase
(
)
;
if
(
name
in
cssColors
)
{
return
cssColors
[
name
]
;
}
if
(
name
=
=
=
"
transparent
"
)
{
return
[
0
0
0
0
]
;
}
let
lexer
=
getCSSLexer
(
name
)
;
let
getToken
=
function
(
)
{
while
(
true
)
{
let
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
|
|
token
.
tokenType
!
=
=
"
comment
"
|
|
token
.
tokenType
!
=
=
"
whitespace
"
)
{
return
token
;
}
}
}
;
let
requireComma
=
function
(
token
)
{
if
(
token
.
tokenType
!
=
=
"
symbol
"
|
|
token
.
text
!
=
=
"
"
)
{
return
null
;
}
return
getToken
(
)
;
}
;
let
func
=
getToken
(
)
;
if
(
!
func
|
|
func
.
tokenType
!
=
=
"
function
"
)
{
return
null
;
}
let
alpha
=
false
;
if
(
func
.
text
=
=
=
"
rgb
"
|
|
func
.
text
=
=
=
"
hsl
"
)
{
}
else
if
(
func
.
text
=
=
=
"
rgba
"
|
|
func
.
text
=
=
=
"
hsla
"
)
{
alpha
=
true
;
}
else
{
return
null
;
}
let
vals
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
+
+
i
)
{
let
token
=
getToken
(
)
;
if
(
i
>
0
)
{
token
=
requireComma
(
token
)
;
}
if
(
token
.
tokenType
!
=
=
"
number
"
|
|
!
token
.
isInteger
)
{
return
null
;
}
let
num
=
token
.
number
;
if
(
num
<
0
)
{
num
=
0
;
}
else
if
(
num
>
255
)
{
num
=
255
;
}
vals
.
push
(
num
)
;
}
if
(
func
.
text
=
=
=
"
hsl
"
|
|
func
.
text
=
=
=
"
hsla
"
)
{
vals
=
hslToRGB
(
vals
)
;
}
if
(
alpha
)
{
let
token
=
requireComma
(
getToken
(
)
)
;
if
(
token
.
tokenType
!
=
=
"
number
"
)
{
return
null
;
}
let
num
=
token
.
number
;
if
(
num
<
0
)
{
num
=
0
;
}
else
if
(
num
>
1
)
{
num
=
1
;
}
vals
.
push
(
num
)
;
}
else
{
vals
.
push
(
1
)
;
}
let
parenToken
=
getToken
(
)
;
if
(
!
parenToken
|
|
parenToken
.
tokenType
!
=
=
"
symbol
"
|
|
parenToken
.
text
!
=
=
"
)
"
)
{
return
null
;
}
if
(
getToken
(
)
!
=
=
null
)
{
return
null
;
}
return
vals
;
}
function
isValidCSSColor
(
name
)
{
return
colorToRGBA
(
name
)
!
=
=
null
;
}
function
isVariable
(
name
)
{
return
name
.
startsWith
(
"
-
-
"
)
;
}
function
cssPropertyIsShorthand
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
false
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
return
!
!
cssProperties
[
name
]
.
subproperties
;
}
function
getSubpropertiesForCSSProperty
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
[
name
]
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
if
(
"
subproperties
"
in
cssProperties
[
name
]
)
{
return
cssProperties
[
name
]
.
subproperties
.
slice
(
)
;
}
return
[
name
]
;
}
function
getCSSValuesForProperty
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
[
"
initial
"
"
inherit
"
"
unset
"
]
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
return
cssProperties
[
name
]
.
values
.
slice
(
)
;
}
function
getCSSPropertyNames
(
flags
)
{
let
names
=
Object
.
keys
(
cssProperties
)
;
if
(
(
flags
&
EXCLUDE_SHORTHANDS
)
!
=
=
0
)
{
names
=
names
.
filter
(
(
name
)
=
>
cssProperties
[
name
]
.
subproperties
)
;
}
if
(
(
flags
&
INCLUDE_ALIASES
)
=
=
=
0
)
{
names
=
names
.
filter
(
(
name
)
=
>
!
cssProperties
[
name
]
.
alias
)
;
}
return
names
;
}
function
cssPropertySupportsType
(
name
type
)
{
if
(
isVariable
(
name
)
)
{
return
false
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
return
(
cssProperties
[
name
]
.
supports
&
(
1
<
<
type
)
)
!
=
=
0
;
}
function
isInheritedProperty
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
true
;
}
if
(
!
(
name
in
cssProperties
)
)
{
return
false
;
}
return
cssProperties
[
name
]
.
inherited
;
}
function
cssPropertyIsValid
(
name
value
)
{
if
(
isVariable
(
name
)
)
{
return
true
;
}
if
(
!
(
name
in
cssProperties
)
)
{
return
false
;
}
let
elt
=
document
.
createElement
(
"
div
"
)
;
elt
.
style
=
name
+
"
:
"
+
value
;
return
elt
.
style
.
length
>
0
;
}
exports
.
inDOMUtils
=
{
getCSSLexer
rgbToColorName
colorToRGBA
isValidCSSColor
cssPropertyIsShorthand
getSubpropertiesForCSSProperty
getCSSValuesForProperty
getCSSPropertyNames
cssPropertySupportsType
isInheritedProperty
cssPropertyIsValid
EXCLUDE_SHORTHANDS
INCLUDE_ALIASES
TYPE_LENGTH
TYPE_PERCENTAGE
TYPE_COLOR
TYPE_URL
TYPE_ANGLE
TYPE_FREQUENCY
TYPE_TIME
TYPE_GRADIENT
TYPE_TIMING_FUNCTION
TYPE_IMAGE_RECT
TYPE_NUMBER
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_FACTORY__
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
(
function
(
root
factory
)
{
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
exports
]
__WEBPACK_AMD_DEFINE_FACTORY__
=
(
factory
)
__WEBPACK_AMD_DEFINE_RESULT__
=
(
typeof
__WEBPACK_AMD_DEFINE_FACTORY__
=
=
=
'
function
'
?
(
__WEBPACK_AMD_DEFINE_FACTORY__
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
)
:
__WEBPACK_AMD_DEFINE_FACTORY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
typeof
exports
!
=
=
'
undefined
'
)
{
factory
(
exports
)
;
}
else
{
factory
(
root
)
;
}
}
(
this
function
(
exports
)
{
function
between
(
num
first
last
)
{
return
num
>
=
first
&
&
num
<
=
last
;
}
function
digit
(
code
)
{
return
between
(
code
0x30
0x39
)
;
}
function
hexdigit
(
code
)
{
return
digit
(
code
)
|
|
between
(
code
0x41
0x46
)
|
|
between
(
code
0x61
0x66
)
;
}
function
uppercaseletter
(
code
)
{
return
between
(
code
0x41
0x5a
)
;
}
function
lowercaseletter
(
code
)
{
return
between
(
code
0x61
0x7a
)
;
}
function
letter
(
code
)
{
return
uppercaseletter
(
code
)
|
|
lowercaseletter
(
code
)
;
}
function
nonascii
(
code
)
{
return
code
>
=
0x80
;
}
function
namestartchar
(
code
)
{
return
letter
(
code
)
|
|
nonascii
(
code
)
|
|
code
=
=
0x5f
;
}
function
namechar
(
code
)
{
return
namestartchar
(
code
)
|
|
digit
(
code
)
|
|
code
=
=
0x2d
;
}
function
nonprintable
(
code
)
{
return
between
(
code
0
8
)
|
|
code
=
=
0xb
|
|
between
(
code
0xe
0x1f
)
|
|
code
=
=
0x7f
;
}
function
newline
(
code
)
{
return
code
=
=
0xa
;
}
function
whitespace
(
code
)
{
return
newline
(
code
)
|
|
code
=
=
9
|
|
code
=
=
0x20
;
}
var
maximumallowedcodepoint
=
0x10ffff
;
var
InvalidCharacterError
=
function
(
message
)
{
this
.
message
=
message
;
}
;
InvalidCharacterError
.
prototype
=
new
Error
;
InvalidCharacterError
.
prototype
.
name
=
'
InvalidCharacterError
'
;
function
stringFromCode
(
code
)
{
if
(
code
<
=
0xffff
)
return
String
.
fromCharCode
(
code
)
;
code
-
=
Math
.
pow
(
2
20
)
;
var
lead
=
Math
.
floor
(
code
/
Math
.
pow
(
2
10
)
)
+
0xd800
;
var
trail
=
code
%
Math
.
pow
(
2
10
)
+
0xdc00
;
return
String
.
fromCharCode
(
lead
)
+
String
.
fromCharCode
(
trail
)
;
}
function
*
tokenize
(
str
options
)
{
if
(
options
=
=
=
undefined
)
{
options
=
{
}
;
}
if
(
options
.
loc
=
=
=
undefined
)
{
options
.
loc
=
false
;
}
if
(
options
.
offsets
=
=
=
undefined
)
{
options
.
offsets
=
false
;
}
if
(
options
.
keepComments
=
=
=
undefined
)
{
options
.
keepComments
=
false
;
}
if
(
options
.
startOffset
=
=
=
undefined
)
{
options
.
startOffset
=
0
;
}
var
i
=
options
.
startOffset
-
1
;
var
code
;
var
line
=
0
;
var
column
=
0
;
var
lastLineLength
=
0
;
var
incrLineno
=
function
(
)
{
line
+
=
1
;
lastLineLength
=
column
;
column
=
0
;
}
;
var
locStart
=
{
line
:
line
column
:
column
}
;
var
offsetStart
=
i
;
var
codepoint
=
function
(
i
)
{
if
(
i
>
=
str
.
length
)
{
return
-
1
;
}
return
str
.
charCodeAt
(
i
)
;
}
;
var
next
=
function
(
num
)
{
if
(
num
=
=
=
undefined
)
num
=
1
;
if
(
num
>
3
)
throw
"
Spec
Error
:
no
more
than
three
codepoints
of
lookahead
.
"
;
var
rcode
;
for
(
var
offset
=
i
+
1
;
num
-
-
>
0
;
+
+
offset
)
{
rcode
=
codepoint
(
offset
)
;
if
(
rcode
=
=
=
0xd
&
&
codepoint
(
offset
+
1
)
=
=
=
0xa
)
{
+
+
offset
;
rcode
=
0xa
;
}
else
if
(
rcode
=
=
=
0xd
|
|
rcode
=
=
=
0xc
)
{
rcode
=
0xa
;
}
else
if
(
rcode
=
=
=
0x0
)
{
rcode
=
0xfffd
;
}
}
return
rcode
;
}
;
var
consume
=
function
(
num
)
{
if
(
num
=
=
=
undefined
)
num
=
1
;
while
(
num
-
-
>
0
)
{
+
+
i
;
code
=
codepoint
(
i
)
;
if
(
code
=
=
=
0xd
&
&
codepoint
(
i
+
1
)
=
=
=
0xa
)
{
+
+
i
;
code
=
0xa
;
}
else
if
(
code
=
=
=
0xd
|
|
code
=
=
=
0xc
)
{
code
=
0xa
;
}
else
if
(
code
=
=
=
0x0
)
{
code
=
0xfffd
;
}
if
(
newline
(
code
)
)
incrLineno
(
)
;
else
column
+
+
;
}
return
true
;
}
;
var
reconsume
=
function
(
)
{
i
-
=
1
;
if
(
newline
(
code
)
)
{
line
-
=
1
;
column
=
lastLineLength
;
}
else
{
column
-
=
1
;
}
return
true
;
}
;
var
eof
=
function
(
codepoint
)
{
if
(
codepoint
=
=
=
undefined
)
codepoint
=
code
;
return
codepoint
=
=
-
1
;
}
;
var
donothing
=
function
(
)
{
}
;
var
parseerror
=
function
(
)
{
console
.
log
(
"
Parse
error
at
index
"
+
i
+
"
processing
codepoint
0x
"
+
code
.
toString
(
16
)
+
"
.
"
)
;
return
true
;
}
;
var
consumeAToken
=
function
(
)
{
consume
(
)
;
if
(
!
options
.
keepComments
)
{
while
(
code
=
=
0x2f
&
&
next
(
)
=
=
0x2a
)
{
consumeAComment
(
)
;
consume
(
)
;
}
}
locStart
.
line
=
line
;
locStart
.
column
=
column
;
offsetStart
=
i
;
if
(
whitespace
(
code
)
)
{
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
return
new
WhitespaceToken
;
}
else
if
(
code
=
=
0x2f
&
&
next
(
)
=
=
0x2a
)
return
consumeAComment
(
)
;
else
if
(
code
=
=
0x22
)
return
consumeAStringToken
(
)
;
else
if
(
code
=
=
0x23
)
{
if
(
namechar
(
next
(
)
)
|
|
areAValidEscape
(
next
(
1
)
next
(
2
)
)
)
{
var
token
=
new
HashToken
(
)
;
if
(
wouldStartAnIdentifier
(
next
(
1
)
next
(
2
)
next
(
3
)
)
)
{
token
.
type
=
"
id
"
;
token
.
tokenType
=
"
id
"
;
}
token
.
value
=
consumeAName
(
)
;
token
.
text
=
token
.
value
;
return
token
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x24
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
SuffixMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x27
)
return
consumeAStringToken
(
)
;
else
if
(
code
=
=
0x28
)
return
new
OpenParenToken
(
)
;
else
if
(
code
=
=
0x29
)
return
new
CloseParenToken
(
)
;
else
if
(
code
=
=
0x2a
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
SubstringMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x2b
)
{
if
(
startsWithANumber
(
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x2c
)
return
new
CommaToken
(
)
;
else
if
(
code
=
=
0x2d
)
{
if
(
startsWithANumber
(
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
if
(
next
(
1
)
=
=
0x2d
&
&
next
(
2
)
=
=
0x3e
)
{
consume
(
2
)
;
return
new
CDCToken
(
)
;
}
else
if
(
startsWithAnIdentifier
(
)
)
{
reconsume
(
)
;
return
consumeAnIdentlikeToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x2e
)
{
if
(
startsWithANumber
(
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x3a
)
return
new
ColonToken
;
else
if
(
code
=
=
0x3b
)
return
new
SemicolonToken
;
else
if
(
code
=
=
0x3c
)
{
if
(
next
(
1
)
=
=
0x21
&
&
next
(
2
)
=
=
0x2d
&
&
next
(
3
)
=
=
0x2d
)
{
consume
(
3
)
;
return
new
CDOToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x40
)
{
if
(
wouldStartAnIdentifier
(
next
(
1
)
next
(
2
)
next
(
3
)
)
)
{
return
new
AtKeywordToken
(
consumeAName
(
)
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x5b
)
return
new
OpenSquareToken
(
)
;
else
if
(
code
=
=
0x5c
)
{
if
(
startsWithAValidEscape
(
)
)
{
reconsume
(
)
;
return
consumeAnIdentlikeToken
(
)
;
}
else
{
parseerror
(
)
;
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x5d
)
return
new
CloseSquareToken
(
)
;
else
if
(
code
=
=
0x5e
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
PrefixMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x7b
)
return
new
OpenCurlyToken
(
)
;
else
if
(
code
=
=
0x7c
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
DashMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x7d
)
return
new
CloseCurlyToken
(
)
;
else
if
(
code
=
=
0x7e
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
IncludeMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
digit
(
code
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
if
(
namestartchar
(
code
)
)
{
reconsume
(
)
;
return
consumeAnIdentlikeToken
(
)
;
}
else
if
(
eof
(
)
)
return
new
EOFToken
(
)
;
else
return
new
DelimToken
(
code
)
;
}
;
var
consumeAComment
=
function
(
)
{
consume
(
)
;
var
comment
=
"
"
;
while
(
true
)
{
consume
(
)
;
if
(
code
=
=
0x2a
&
&
next
(
)
=
=
0x2f
)
{
consume
(
)
;
break
;
}
else
if
(
eof
(
)
)
{
break
;
}
comment
+
=
stringFromCode
(
code
)
;
}
return
new
CommentToken
(
comment
)
;
}
;
var
consumeANumericToken
=
function
(
)
{
var
num
=
consumeANumber
(
)
;
var
token
;
if
(
wouldStartAnIdentifier
(
next
(
1
)
next
(
2
)
next
(
3
)
)
)
{
token
=
new
DimensionToken
(
)
;
token
.
value
=
num
.
value
;
token
.
repr
=
num
.
repr
;
token
.
type
=
num
.
type
;
token
.
unit
=
consumeAName
(
)
;
token
.
text
=
token
.
unit
;
}
else
if
(
next
(
)
=
=
0x25
)
{
consume
(
)
;
token
=
new
PercentageToken
(
)
;
token
.
value
=
num
.
value
;
token
.
repr
=
num
.
repr
;
}
else
{
var
token
=
new
NumberToken
(
)
;
token
.
value
=
num
.
value
;
token
.
repr
=
num
.
repr
;
token
.
type
=
num
.
type
;
}
token
.
number
=
token
.
value
;
token
.
isInteger
=
token
.
type
=
=
=
"
integer
"
;
return
token
;
}
;
var
consumeAnIdentlikeToken
=
function
(
)
{
var
str
=
consumeAName
(
)
;
if
(
str
.
toLowerCase
(
)
=
=
"
url
"
&
&
next
(
)
=
=
0x28
)
{
consume
(
)
;
while
(
whitespace
(
next
(
1
)
)
&
&
whitespace
(
next
(
2
)
)
)
consume
(
)
;
if
(
(
next
(
)
=
=
0x22
|
|
next
(
)
=
=
0x27
)
|
|
(
whitespace
(
next
(
)
)
&
&
(
next
(
2
)
=
=
0x22
|
|
next
(
2
)
=
=
0x27
)
)
)
{
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
consume
(
)
;
let
str
=
consumeAStringToken
(
)
;
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
consume
(
)
;
return
new
URLToken
(
str
.
text
)
;
}
else
{
return
consumeAURLToken
(
)
;
}
}
else
if
(
next
(
)
=
=
0x28
)
{
consume
(
)
;
return
new
FunctionToken
(
str
)
;
}
else
{
return
new
IdentToken
(
str
)
;
}
}
;
var
consumeAStringToken
=
function
(
endingCodePoint
)
{
if
(
endingCodePoint
=
=
=
undefined
)
endingCodePoint
=
code
;
var
string
=
"
"
;
while
(
consume
(
)
)
{
if
(
code
=
=
endingCodePoint
|
|
eof
(
)
)
{
return
new
StringToken
(
string
)
;
}
else
if
(
newline
(
code
)
)
{
reconsume
(
)
;
return
new
BadStringToken
(
string
)
;
}
else
if
(
code
=
=
0x5c
)
{
if
(
eof
(
next
(
)
)
)
{
donothing
(
)
;
}
else
if
(
newline
(
next
(
)
)
)
{
consume
(
)
;
}
else
{
string
+
=
stringFromCode
(
consumeEscape
(
)
)
;
}
}
else
{
string
+
=
stringFromCode
(
code
)
;
}
}
}
;
var
consumeAURLToken
=
function
(
)
{
var
token
=
new
URLToken
(
"
"
)
;
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
if
(
eof
(
next
(
)
)
)
return
token
;
while
(
consume
(
)
)
{
if
(
code
=
=
0x29
|
|
eof
(
)
)
{
break
;
}
else
if
(
whitespace
(
code
)
)
{
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
if
(
next
(
)
=
=
0x29
|
|
eof
(
next
(
)
)
)
{
consume
(
)
;
break
;
}
else
{
consumeTheRemnantsOfABadURL
(
)
;
return
new
BadURLToken
(
)
;
}
}
else
if
(
code
=
=
0x22
|
|
code
=
=
0x27
|
|
code
=
=
0x28
|
|
nonprintable
(
code
)
)
{
parseerror
(
)
;
consumeTheRemnantsOfABadURL
(
)
;
return
new
BadURLToken
(
)
;
}
else
if
(
code
=
=
0x5c
)
{
if
(
startsWithAValidEscape
(
)
)
{
token
.
value
+
=
stringFromCode
(
consumeEscape
(
)
)
;
}
else
{
parseerror
(
)
;
consumeTheRemnantsOfABadURL
(
)
;
return
new
BadURLToken
(
)
;
}
}
else
{
token
.
value
+
=
stringFromCode
(
code
)
;
}
}
token
.
text
=
token
.
value
;
return
token
;
}
;
var
consumeEscape
=
function
(
)
{
consume
(
)
;
if
(
hexdigit
(
code
)
)
{
var
digits
=
[
code
]
;
for
(
var
total
=
0
;
total
<
5
;
total
+
+
)
{
if
(
hexdigit
(
next
(
)
)
)
{
consume
(
)
;
digits
.
push
(
code
)
;
}
else
{
break
;
}
}
if
(
whitespace
(
next
(
)
)
)
consume
(
)
;
var
value
=
parseInt
(
digits
.
map
(
function
(
x
)
{
return
String
.
fromCharCode
(
x
)
;
}
)
.
join
(
'
'
)
16
)
;
if
(
value
>
maximumallowedcodepoint
)
value
=
0xfffd
;
return
value
;
}
else
if
(
eof
(
)
)
{
return
0xfffd
;
}
else
{
return
code
;
}
}
;
var
areAValidEscape
=
function
(
c1
c2
)
{
if
(
c1
!
=
0x5c
)
return
false
;
if
(
newline
(
c2
)
)
return
false
;
return
true
;
}
;
var
startsWithAValidEscape
=
function
(
)
{
return
areAValidEscape
(
code
next
(
)
)
;
}
;
var
wouldStartAnIdentifier
=
function
(
c1
c2
c3
)
{
if
(
c1
=
=
0x2d
)
{
return
namestartchar
(
c2
)
|
|
c2
=
=
0x2d
|
|
areAValidEscape
(
c2
c3
)
;
}
else
if
(
namestartchar
(
c1
)
)
{
return
true
;
}
else
if
(
c1
=
=
0x5c
)
{
return
areAValidEscape
(
c1
c2
)
;
}
else
{
return
false
;
}
}
;
var
startsWithAnIdentifier
=
function
(
)
{
return
wouldStartAnIdentifier
(
code
next
(
1
)
next
(
2
)
)
;
}
;
var
wouldStartANumber
=
function
(
c1
c2
c3
)
{
if
(
c1
=
=
0x2b
|
|
c1
=
=
0x2d
)
{
if
(
digit
(
c2
)
)
return
true
;
if
(
c2
=
=
0x2e
&
&
digit
(
c3
)
)
return
true
;
return
false
;
}
else
if
(
c1
=
=
0x2e
)
{
if
(
digit
(
c2
)
)
return
true
;
return
false
;
}
else
if
(
digit
(
c1
)
)
{
return
true
;
}
else
{
return
false
;
}
}
;
var
startsWithANumber
=
function
(
)
{
return
wouldStartANumber
(
code
next
(
1
)
next
(
2
)
)
;
}
;
var
consumeAName
=
function
(
)
{
var
result
=
"
"
;
while
(
consume
(
)
)
{
if
(
namechar
(
code
)
)
{
result
+
=
stringFromCode
(
code
)
;
}
else
if
(
startsWithAValidEscape
(
)
)
{
result
+
=
stringFromCode
(
consumeEscape
(
)
)
;
}
else
{
reconsume
(
)
;
return
result
;
}
}
}
;
var
consumeANumber
=
function
(
)
{
var
repr
=
[
]
;
var
type
=
"
integer
"
;
if
(
next
(
)
=
=
0x2b
|
|
next
(
)
=
=
0x2d
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
if
(
next
(
1
)
=
=
0x2e
&
&
digit
(
next
(
2
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
type
=
"
number
"
;
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
}
var
c1
=
next
(
1
)
c2
=
next
(
2
)
c3
=
next
(
3
)
;
if
(
(
c1
=
=
0x45
|
|
c1
=
=
0x65
)
&
&
digit
(
c2
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
type
=
"
number
"
;
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
}
else
if
(
(
c1
=
=
0x45
|
|
c1
=
=
0x65
)
&
&
(
c2
=
=
0x2b
|
|
c2
=
=
0x2d
)
&
&
digit
(
c3
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
type
=
"
number
"
;
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
}
var
value
=
convertAStringToANumber
(
repr
)
;
return
{
type
:
type
value
:
value
repr
:
repr
}
;
}
;
var
convertAStringToANumber
=
function
(
string
)
{
return
+
string
;
}
;
var
consumeTheRemnantsOfABadURL
=
function
(
)
{
while
(
consume
(
)
)
{
if
(
code
=
=
0x2d
|
|
eof
(
)
)
{
return
;
}
else
if
(
startsWithAValidEscape
(
)
)
{
consumeEscape
(
)
;
donothing
(
)
;
}
else
{
donothing
(
)
;
}
}
}
;
var
iterationCount
=
0
;
while
(
!
eof
(
next
(
)
)
)
{
var
token
=
consumeAToken
(
)
;
if
(
options
.
loc
)
{
token
.
loc
=
{
}
;
token
.
loc
.
start
=
{
line
:
locStart
.
line
column
:
locStart
.
column
}
;
token
.
loc
.
end
=
{
line
:
line
column
:
column
}
;
}
if
(
options
.
offsets
)
{
token
.
startOffset
=
offsetStart
;
token
.
endOffset
=
i
+
1
;
}
yield
token
;
iterationCount
+
+
;
if
(
iterationCount
>
str
.
length
*
2
)
return
"
I
'
m
infinite
-
looping
!
"
;
}
}
function
CSSParserToken
(
)
{
throw
"
Abstract
Base
Class
"
;
}
CSSParserToken
.
prototype
.
toJSON
=
function
(
)
{
return
{
token
:
this
.
tokenType
}
;
}
;
CSSParserToken
.
prototype
.
toString
=
function
(
)
{
return
this
.
tokenType
;
}
;
CSSParserToken
.
prototype
.
toSource
=
function
(
)
{
return
'
'
+
this
;
}
;
function
BadStringToken
(
text
)
{
this
.
text
=
text
;
return
this
;
}
BadStringToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
BadStringToken
.
prototype
.
tokenType
=
"
bad_string
"
;
function
BadURLToken
(
)
{
return
this
;
}
BadURLToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
BadURLToken
.
prototype
.
tokenType
=
"
bad_url
"
;
function
WhitespaceToken
(
)
{
return
this
;
}
WhitespaceToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
WhitespaceToken
.
prototype
.
tokenType
=
"
whitespace
"
;
WhitespaceToken
.
prototype
.
toString
=
function
(
)
{
return
"
WS
"
;
}
;
WhitespaceToken
.
prototype
.
toSource
=
function
(
)
{
return
"
"
;
}
;
function
CDOToken
(
)
{
return
this
;
}
CDOToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
CDOToken
.
prototype
.
tokenType
=
"
htmlcomment
"
;
CDOToken
.
prototype
.
toSource
=
function
(
)
{
return
"
<
!
-
-
"
;
}
;
function
CDCToken
(
)
{
return
this
;
}
CDCToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
CDCToken
.
prototype
.
tokenType
=
"
htmlcomment
"
;
CDCToken
.
prototype
.
toSource
=
function
(
)
{
return
"
-
-
>
"
;
}
;
function
ColonToken
(
)
{
return
this
;
}
ColonToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
ColonToken
.
prototype
.
tokenType
=
"
symbol
"
;
ColonToken
.
prototype
.
text
=
"
:
"
;
function
SemicolonToken
(
)
{
return
this
;
}
SemicolonToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
SemicolonToken
.
prototype
.
tokenType
=
"
symbol
"
;
SemicolonToken
.
prototype
.
text
=
"
;
"
;
function
CommaToken
(
)
{
return
this
;
}
CommaToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
CommaToken
.
prototype
.
tokenType
=
"
symbol
"
;
CommaToken
.
prototype
.
text
=
"
"
;
function
GroupingToken
(
)
{
throw
"
Abstract
Base
Class
"
;
}
GroupingToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
function
OpenCurlyToken
(
)
{
this
.
value
=
"
{
"
;
this
.
mirror
=
"
}
"
;
return
this
;
}
OpenCurlyToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
OpenCurlyToken
.
prototype
.
tokenType
=
"
symbol
"
;
OpenCurlyToken
.
prototype
.
text
=
"
{
"
;
function
CloseCurlyToken
(
)
{
this
.
value
=
"
}
"
;
this
.
mirror
=
"
{
"
;
return
this
;
}
CloseCurlyToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
CloseCurlyToken
.
prototype
.
tokenType
=
"
symbol
"
;
CloseCurlyToken
.
prototype
.
text
=
"
}
"
;
function
OpenSquareToken
(
)
{
this
.
value
=
"
[
"
;
this
.
mirror
=
"
]
"
;
return
this
;
}
OpenSquareToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
OpenSquareToken
.
prototype
.
tokenType
=
"
symbol
"
;
OpenSquareToken
.
prototype
.
text
=
"
[
"
;
function
CloseSquareToken
(
)
{
this
.
value
=
"
]
"
;
this
.
mirror
=
"
[
"
;
return
this
;
}
CloseSquareToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
CloseSquareToken
.
prototype
.
tokenType
=
"
symbol
"
;
CloseSquareToken
.
prototype
.
text
=
"
]
"
;
function
OpenParenToken
(
)
{
this
.
value
=
"
(
"
;
this
.
mirror
=
"
)
"
;
return
this
;
}
OpenParenToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
OpenParenToken
.
prototype
.
tokenType
=
"
symbol
"
;
OpenParenToken
.
prototype
.
text
=
"
(
"
;
function
CloseParenToken
(
)
{
this
.
value
=
"
)
"
;
this
.
mirror
=
"
(
"
;
return
this
;
}
CloseParenToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
CloseParenToken
.
prototype
.
tokenType
=
"
symbol
"
;
CloseParenToken
.
prototype
.
text
=
"
)
"
;
function
IncludeMatchToken
(
)
{
return
this
;
}
IncludeMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
IncludeMatchToken
.
prototype
.
tokenType
=
"
includes
"
;
function
DashMatchToken
(
)
{
return
this
;
}
DashMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
DashMatchToken
.
prototype
.
tokenType
=
"
dashmatch
"
;
function
PrefixMatchToken
(
)
{
return
this
;
}
PrefixMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
PrefixMatchToken
.
prototype
.
tokenType
=
"
beginsmatch
"
;
function
SuffixMatchToken
(
)
{
return
this
;
}
SuffixMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
SuffixMatchToken
.
prototype
.
tokenType
=
"
endsmatch
"
;
function
SubstringMatchToken
(
)
{
return
this
;
}
SubstringMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
SubstringMatchToken
.
prototype
.
tokenType
=
"
containsmatch
"
;
function
ColumnToken
(
)
{
return
this
;
}
ColumnToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
ColumnToken
.
prototype
.
tokenType
=
"
|
|
"
;
function
EOFToken
(
)
{
return
this
;
}
EOFToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
EOFToken
.
prototype
.
tokenType
=
"
EOF
"
;
EOFToken
.
prototype
.
toSource
=
function
(
)
{
return
"
"
;
}
;
function
DelimToken
(
code
)
{
this
.
value
=
stringFromCode
(
code
)
;
this
.
text
=
this
.
value
;
return
this
;
}
DelimToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
DelimToken
.
prototype
.
tokenType
=
"
symbol
"
;
DelimToken
.
prototype
.
toString
=
function
(
)
{
return
"
DELIM
(
"
+
this
.
value
+
"
)
"
;
}
;
DelimToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
return
json
;
}
;
DelimToken
.
prototype
.
toSource
=
function
(
)
{
if
(
this
.
value
=
=
"
\
\
"
)
return
"
\
\
\
n
"
;
else
return
this
.
value
;
}
;
function
StringValuedToken
(
)
{
throw
"
Abstract
Base
Class
"
;
}
StringValuedToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
StringValuedToken
.
prototype
.
ASCIIMatch
=
function
(
str
)
{
return
this
.
value
.
toLowerCase
(
)
=
=
str
.
toLowerCase
(
)
;
}
;
StringValuedToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
return
json
;
}
;
function
IdentToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
IdentToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
IdentToken
.
prototype
.
tokenType
=
"
ident
"
;
IdentToken
.
prototype
.
toString
=
function
(
)
{
return
"
IDENT
(
"
+
this
.
value
+
"
)
"
;
}
;
IdentToken
.
prototype
.
toSource
=
function
(
)
{
return
escapeIdent
(
this
.
value
)
;
}
;
function
FunctionToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
this
.
mirror
=
"
)
"
;
}
FunctionToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
FunctionToken
.
prototype
.
tokenType
=
"
function
"
;
FunctionToken
.
prototype
.
toString
=
function
(
)
{
return
"
FUNCTION
(
"
+
this
.
value
+
"
)
"
;
}
;
FunctionToken
.
prototype
.
toSource
=
function
(
)
{
return
escapeIdent
(
this
.
value
)
+
"
(
"
;
}
;
function
AtKeywordToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
AtKeywordToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
AtKeywordToken
.
prototype
.
tokenType
=
"
at
"
;
AtKeywordToken
.
prototype
.
toString
=
function
(
)
{
return
"
AT
(
"
+
this
.
value
+
"
)
"
;
}
;
AtKeywordToken
.
prototype
.
toSource
=
function
(
)
{
return
"
"
+
escapeIdent
(
this
.
value
)
;
}
;
function
HashToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
this
.
type
=
"
unrestricted
"
;
}
HashToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
HashToken
.
prototype
.
tokenType
=
"
hash
"
;
HashToken
.
prototype
.
toString
=
function
(
)
{
return
"
HASH
(
"
+
this
.
value
+
"
)
"
;
}
;
HashToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
type
=
this
.
type
;
return
json
;
}
;
HashToken
.
prototype
.
toSource
=
function
(
)
{
if
(
this
.
type
=
=
"
id
"
)
{
return
"
#
"
+
escapeIdent
(
this
.
value
)
;
}
else
{
return
"
#
"
+
escapeHash
(
this
.
value
)
;
}
}
;
function
StringToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
StringToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
StringToken
.
prototype
.
tokenType
=
"
string
"
;
StringToken
.
prototype
.
toString
=
function
(
)
{
return
'
"
'
+
escapeString
(
this
.
value
)
+
'
"
'
;
}
;
function
CommentToken
(
val
)
{
this
.
value
=
val
;
}
CommentToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
CommentToken
.
prototype
.
tokenType
=
"
comment
"
;
CommentToken
.
prototype
.
toString
=
function
(
)
{
return
'
/
*
'
+
this
.
value
+
'
*
/
'
;
}
CommentToken
.
prototype
.
toSource
=
CommentToken
.
prototype
.
toString
;
function
URLToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
URLToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
URLToken
.
prototype
.
tokenType
=
"
url
"
;
URLToken
.
prototype
.
toString
=
function
(
)
{
return
"
URL
(
"
+
this
.
value
+
"
)
"
;
}
;
URLToken
.
prototype
.
toSource
=
function
(
)
{
return
'
url
(
"
'
+
escapeString
(
this
.
value
)
+
'
"
)
'
;
}
;
function
NumberToken
(
)
{
this
.
value
=
null
;
this
.
type
=
"
integer
"
;
this
.
repr
=
"
"
;
}
NumberToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
NumberToken
.
prototype
.
tokenType
=
"
number
"
;
NumberToken
.
prototype
.
toString
=
function
(
)
{
if
(
this
.
type
=
=
"
integer
"
)
return
"
INT
(
"
+
this
.
value
+
"
)
"
;
return
"
NUMBER
(
"
+
this
.
value
+
"
)
"
;
}
;
NumberToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
type
=
this
.
type
;
json
.
repr
=
this
.
repr
;
return
json
;
}
;
NumberToken
.
prototype
.
toSource
=
function
(
)
{
return
this
.
repr
;
}
;
function
PercentageToken
(
)
{
this
.
value
=
null
;
this
.
repr
=
"
"
;
}
PercentageToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
PercentageToken
.
prototype
.
tokenType
=
"
percentage
"
;
PercentageToken
.
prototype
.
toString
=
function
(
)
{
return
"
PERCENTAGE
(
"
+
this
.
value
+
"
)
"
;
}
;
PercentageToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
repr
=
this
.
repr
;
return
json
;
}
;
PercentageToken
.
prototype
.
toSource
=
function
(
)
{
return
this
.
repr
+
"
%
"
;
}
;
function
DimensionToken
(
)
{
this
.
value
=
null
;
this
.
type
=
"
integer
"
;
this
.
repr
=
"
"
;
this
.
unit
=
"
"
;
}
DimensionToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
DimensionToken
.
prototype
.
tokenType
=
"
dimension
"
;
DimensionToken
.
prototype
.
toString
=
function
(
)
{
return
"
DIM
(
"
+
this
.
value
+
"
"
+
this
.
unit
+
"
)
"
;
}
;
DimensionToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
type
=
this
.
type
;
json
.
repr
=
this
.
repr
;
json
.
unit
=
this
.
unit
;
return
json
;
}
;
DimensionToken
.
prototype
.
toSource
=
function
(
)
{
var
source
=
this
.
repr
;
var
unit
=
escapeIdent
(
this
.
unit
)
;
if
(
unit
[
0
]
.
toLowerCase
(
)
=
=
"
e
"
&
&
(
unit
[
1
]
=
=
"
-
"
|
|
between
(
unit
.
charCodeAt
(
1
)
0x30
0x39
)
)
)
{
unit
=
"
\
\
65
"
+
unit
.
slice
(
1
unit
.
length
)
;
}
return
source
+
unit
;
}
;
function
escapeIdent
(
string
)
{
string
=
'
'
+
string
;
var
result
=
'
'
;
var
firstcode
=
string
.
charCodeAt
(
0
)
;
for
(
var
i
=
0
;
i
<
string
.
length
;
i
+
+
)
{
var
code
=
string
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
0x0
)
{
throw
new
InvalidCharacterError
(
'
Invalid
character
:
the
input
contains
U
+
0000
.
'
)
;
}
if
(
between
(
code
0x1
0x1f
)
|
|
code
=
=
0x7f
|
|
(
i
=
=
=
0
&
&
between
(
code
0x30
0x39
)
)
|
|
(
i
=
=
1
&
&
between
(
code
0x30
0x39
)
&
&
firstcode
=
=
0x2d
)
)
{
result
+
=
'
\
\
'
+
code
.
toString
(
16
)
+
'
'
;
}
else
if
(
code
>
=
0x80
|
|
code
=
=
0x2d
|
|
code
=
=
0x5f
|
|
between
(
code
0x30
0x39
)
|
|
between
(
code
0x41
0x5a
)
|
|
between
(
code
0x61
0x7a
)
)
{
result
+
=
string
[
i
]
;
}
else
{
result
+
=
'
\
\
'
+
string
[
i
]
;
}
}
return
result
;
}
function
escapeHash
(
string
)
{
string
=
'
'
+
string
;
var
result
=
'
'
;
for
(
var
i
=
0
;
i
<
string
.
length
;
i
+
+
)
{
var
code
=
string
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
0x0
)
{
throw
new
InvalidCharacterError
(
'
Invalid
character
:
the
input
contains
U
+
0000
.
'
)
;
}
if
(
code
>
=
0x80
|
|
code
=
=
0x2d
|
|
code
=
=
0x5f
|
|
between
(
code
0x30
0x39
)
|
|
between
(
code
0x41
0x5a
)
|
|
between
(
code
0x61
0x7a
)
)
{
result
+
=
string
[
i
]
;
}
else
{
result
+
=
'
\
\
'
+
code
.
toString
(
16
)
+
'
'
;
}
}
return
result
;
}
function
escapeString
(
string
)
{
string
=
'
'
+
string
;
var
result
=
'
'
;
for
(
var
i
=
0
;
i
<
string
.
length
;
i
+
+
)
{
var
code
=
string
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
0x0
)
{
throw
new
InvalidCharacterError
(
'
Invalid
character
:
the
input
contains
U
+
0000
.
'
)
;
}
if
(
between
(
code
0x1
0x1f
)
|
|
code
=
=
0x7f
)
{
result
+
=
'
\
\
'
+
code
.
toString
(
16
)
+
'
'
;
}
else
if
(
code
=
=
0x22
|
|
code
=
=
0x5c
)
{
result
+
=
'
\
\
'
+
string
[
i
]
;
}
else
{
result
+
=
string
[
i
]
;
}
}
return
result
;
}
exports
.
tokenize
=
tokenize
;
exports
.
IdentToken
=
IdentToken
;
exports
.
FunctionToken
=
FunctionToken
;
exports
.
AtKeywordToken
=
AtKeywordToken
;
exports
.
HashToken
=
HashToken
;
exports
.
StringToken
=
StringToken
;
exports
.
BadStringToken
=
BadStringToken
;
exports
.
URLToken
=
URLToken
;
exports
.
BadURLToken
=
BadURLToken
;
exports
.
DelimToken
=
DelimToken
;
exports
.
NumberToken
=
NumberToken
;
exports
.
PercentageToken
=
PercentageToken
;
exports
.
DimensionToken
=
DimensionToken
;
exports
.
IncludeMatchToken
=
IncludeMatchToken
;
exports
.
DashMatchToken
=
DashMatchToken
;
exports
.
PrefixMatchToken
=
PrefixMatchToken
;
exports
.
SuffixMatchToken
=
SuffixMatchToken
;
exports
.
SubstringMatchToken
=
SubstringMatchToken
;
exports
.
ColumnToken
=
ColumnToken
;
exports
.
WhitespaceToken
=
WhitespaceToken
;
exports
.
CDOToken
=
CDOToken
;
exports
.
CDCToken
=
CDCToken
;
exports
.
ColonToken
=
ColonToken
;
exports
.
SemicolonToken
=
SemicolonToken
;
exports
.
CommaToken
=
CommaToken
;
exports
.
OpenParenToken
=
OpenParenToken
;
exports
.
CloseParenToken
=
CloseParenToken
;
exports
.
OpenSquareToken
=
OpenSquareToken
;
exports
.
CloseSquareToken
=
CloseSquareToken
;
exports
.
OpenCurlyToken
=
OpenCurlyToken
;
exports
.
CloseCurlyToken
=
CloseCurlyToken
;
exports
.
EOFToken
=
EOFToken
;
exports
.
CSSParserToken
=
CSSParserToken
;
exports
.
GroupingToken
=
GroupingToken
;
function
TokenStream
(
tokens
)
{
this
.
tokens
=
tokens
;
this
.
token
=
undefined
;
this
.
stored
=
[
]
;
}
TokenStream
.
prototype
.
consume
=
function
(
num
)
{
if
(
num
=
=
=
undefined
)
num
=
1
;
while
(
num
-
-
>
0
)
{
if
(
this
.
stored
.
length
>
0
)
{
this
.
token
=
this
.
stored
.
shift
(
)
;
}
else
{
var
n
=
this
.
tokens
.
next
(
)
;
while
(
!
n
.
done
&
&
n
.
value
instanceof
CommentToken
)
{
n
=
this
.
tokens
.
next
(
)
;
}
if
(
n
.
done
)
{
this
.
token
=
new
EOFToken
(
)
;
break
;
}
this
.
token
=
n
.
value
;
}
}
return
true
;
}
;
TokenStream
.
prototype
.
next
=
function
(
)
{
if
(
this
.
stored
.
length
=
=
=
0
)
{
var
n
=
this
.
tokens
.
next
(
)
;
while
(
!
n
.
done
&
&
n
.
value
instanceof
CommentToken
)
{
n
=
this
.
tokens
.
next
(
)
;
}
if
(
n
.
done
)
return
new
EOFToken
(
)
;
this
.
stored
.
push
(
n
.
value
)
;
}
return
this
.
stored
[
0
]
;
}
;
TokenStream
.
prototype
.
reconsume
=
function
(
)
{
this
.
stored
.
unshift
(
this
.
token
)
;
}
;
function
parseerror
(
s
msg
)
{
console
.
log
(
"
Parse
error
at
token
"
+
s
.
i
+
"
:
"
+
s
.
token
+
"
.
\
n
"
+
msg
)
;
return
true
;
}
function
donothing
(
)
{
return
true
;
}
function
consumeAListOfRules
(
s
topLevel
)
{
var
rules
=
[
]
;
var
rule
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
WhitespaceToken
)
{
continue
;
}
else
if
(
s
.
token
instanceof
EOFToken
)
{
return
rules
;
}
else
if
(
s
.
token
instanceof
CDOToken
|
|
s
.
token
instanceof
CDCToken
)
{
if
(
topLevel
=
=
"
top
-
level
"
)
continue
;
s
.
reconsume
(
)
;
if
(
rule
=
consumeAQualifiedRule
(
s
)
)
rules
.
push
(
rule
)
;
}
else
if
(
s
.
token
instanceof
AtKeywordToken
)
{
s
.
reconsume
(
)
;
if
(
rule
=
consumeAnAtRule
(
s
)
)
rules
.
push
(
rule
)
;
}
else
{
s
.
reconsume
(
)
;
if
(
rule
=
consumeAQualifiedRule
(
s
)
)
rules
.
push
(
rule
)
;
}
}
}
function
consumeAnAtRule
(
s
)
{
s
.
consume
(
)
;
var
rule
=
new
AtRule
(
s
.
token
.
value
)
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
SemicolonToken
|
|
s
.
token
instanceof
EOFToken
)
{
return
rule
;
}
else
if
(
s
.
token
instanceof
OpenCurlyToken
)
{
rule
.
value
=
consumeASimpleBlock
(
s
)
;
return
rule
;
}
else
{
s
.
reconsume
(
)
;
rule
.
prelude
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
consumeAQualifiedRule
(
s
)
{
var
rule
=
new
QualifiedRule
(
)
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
EOFToken
)
{
parseerror
(
s
"
Hit
EOF
when
trying
to
parse
the
prelude
of
a
qualified
rule
.
"
)
;
return
;
}
else
if
(
s
.
token
instanceof
OpenCurlyToken
)
{
rule
.
value
=
consumeASimpleBlock
(
s
)
;
return
rule
;
}
else
{
s
.
reconsume
(
)
;
rule
.
prelude
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
consumeAListOfDeclarations
(
s
)
{
var
decls
=
[
]
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
WhitespaceToken
|
|
s
.
token
instanceof
SemicolonToken
)
{
donothing
(
)
;
}
else
if
(
s
.
token
instanceof
EOFToken
)
{
return
decls
;
}
else
if
(
s
.
token
instanceof
AtKeywordToken
)
{
s
.
reconsume
(
)
;
decls
.
push
(
consumeAnAtRule
(
s
)
)
;
}
else
if
(
s
.
token
instanceof
IdentToken
)
{
var
temp
=
[
s
.
token
]
;
while
(
!
(
s
.
next
(
)
instanceof
SemicolonToken
|
|
s
.
next
(
)
instanceof
EOFToken
)
)
temp
.
push
(
consumeAComponentValue
(
s
)
)
;
var
decl
;
if
(
decl
=
consumeADeclaration
(
new
TokenStream
(
temp
)
)
)
decls
.
push
(
decl
)
;
}
else
{
parseerror
(
s
)
;
s
.
reconsume
(
)
;
while
(
!
(
s
.
next
(
)
instanceof
SemicolonToken
|
|
s
.
next
(
)
instanceof
EOFToken
)
)
consumeAComponentValue
(
s
)
;
}
}
}
function
consumeADeclaration
(
s
)
{
s
.
consume
(
)
;
var
decl
=
new
Declaration
(
s
.
token
.
value
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
!
(
s
.
next
(
)
instanceof
ColonToken
)
)
{
parseerror
(
s
)
;
return
;
}
else
{
s
.
consume
(
)
;
}
while
(
!
(
s
.
next
(
)
instanceof
EOFToken
)
)
{
decl
.
value
.
push
(
consumeAComponentValue
(
s
)
)
;
}
var
foundImportant
=
false
;
for
(
var
i
=
decl
.
value
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
decl
.
value
[
i
]
instanceof
WhitespaceToken
)
{
continue
;
}
else
if
(
decl
.
value
[
i
]
instanceof
IdentToken
&
&
decl
.
value
[
i
]
.
ASCIIMatch
(
"
important
"
)
)
{
foundImportant
=
true
;
}
else
if
(
foundImportant
&
&
decl
.
value
[
i
]
instanceof
DelimToken
&
&
decl
.
value
[
i
]
.
value
=
=
"
!
"
)
{
decl
.
value
.
splice
(
i
decl
.
value
.
length
)
;
decl
.
important
=
true
;
break
;
}
else
{
break
;
}
}
return
decl
;
}
function
consumeAComponentValue
(
s
)
{
s
.
consume
(
)
;
if
(
s
.
token
instanceof
OpenCurlyToken
|
|
s
.
token
instanceof
OpenSquareToken
|
|
s
.
token
instanceof
OpenParenToken
)
return
consumeASimpleBlock
(
s
)
;
if
(
s
.
token
instanceof
FunctionToken
)
return
consumeAFunction
(
s
)
;
return
s
.
token
;
}
function
consumeASimpleBlock
(
s
)
{
var
mirror
=
s
.
token
.
mirror
;
var
block
=
new
SimpleBlock
(
s
.
token
.
value
)
;
block
.
startToken
=
s
.
token
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
EOFToken
|
|
(
s
.
token
instanceof
GroupingToken
&
&
s
.
token
.
value
=
=
mirror
)
)
return
block
;
else
{
s
.
reconsume
(
)
;
block
.
value
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
consumeAFunction
(
s
)
{
var
func
=
new
Func
(
s
.
token
.
value
)
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
EOFToken
|
|
s
.
token
instanceof
CloseParenToken
)
return
func
;
else
{
s
.
reconsume
(
)
;
func
.
value
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
normalizeInput
(
input
)
{
if
(
typeof
input
=
=
"
string
"
)
return
new
TokenStream
(
tokenize
(
input
)
)
;
if
(
input
instanceof
TokenStream
)
return
input
;
if
(
typeof
(
input
.
next
)
=
=
"
function
"
)
return
new
TokenStream
(
input
)
;
if
(
input
.
length
!
=
=
undefined
)
return
new
TokenStream
(
input
[
Symbol
.
iterator
]
(
)
)
;
else
throw
SyntaxError
(
input
)
;
}
function
parseAStylesheet
(
s
)
{
s
=
normalizeInput
(
s
)
;
var
sheet
=
new
Stylesheet
(
)
;
sheet
.
value
=
consumeAListOfRules
(
s
"
top
-
level
"
)
;
return
sheet
;
}
function
parseAListOfRules
(
s
)
{
s
=
normalizeInput
(
s
)
;
return
consumeAListOfRules
(
s
)
;
}
function
parseARule
(
s
)
{
s
=
normalizeInput
(
s
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
s
.
next
(
)
instanceof
EOFToken
)
throw
SyntaxError
(
)
;
var
rule
;
var
startToken
=
s
.
next
(
)
;
if
(
startToken
instanceof
AtKeywordToken
)
{
rule
=
consumeAnAtRule
(
s
)
;
}
else
{
rule
=
consumeAQualifiedRule
(
s
)
;
if
(
!
rule
)
throw
SyntaxError
(
)
;
}
rule
.
startToken
=
startToken
;
rule
.
endToken
=
s
.
token
;
return
rule
;
}
function
parseADeclaration
(
s
)
{
s
=
normalizeInput
(
s
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
!
(
s
.
next
(
)
instanceof
IdentToken
)
)
throw
SyntaxError
(
)
;
var
decl
=
consumeADeclaration
(
s
)
;
if
(
decl
)
return
decl
;
else
throw
SyntaxError
(
)
;
}
function
parseAListOfDeclarations
(
s
)
{
s
=
normalizeInput
(
s
)
;
return
consumeAListOfDeclarations
(
s
)
;
}
function
parseAComponentValue
(
s
)
{
s
=
normalizeInput
(
s
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
s
.
next
(
)
instanceof
EOFToken
)
throw
SyntaxError
(
)
;
var
val
=
consumeAComponentValue
(
s
)
;
if
(
!
val
)
throw
SyntaxError
(
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
s
.
next
(
)
instanceof
EOFToken
)
return
val
;
throw
SyntaxError
(
)
;
}
function
parseAListOfComponentValues
(
s
)
{
s
=
normalizeInput
(
s
)
;
var
vals
=
[
]
;
while
(
true
)
{
var
val
=
consumeAComponentValue
(
s
)
;
if
(
val
instanceof
EOFToken
)
return
vals
;
else
vals
.
push
(
val
)
;
}
}
function
parseACommaSeparatedListOfComponentValues
(
s
)
{
s
=
normalizeInput
(
s
)
;
var
listOfCVLs
=
[
]
;
while
(
true
)
{
var
vals
=
[
]
;
while
(
true
)
{
var
val
=
consumeAComponentValue
(
s
)
;
if
(
val
instanceof
EOFToken
)
{
listOfCVLs
.
push
(
vals
)
;
return
listOfCVLs
;
}
else
if
(
val
instanceof
CommaToken
)
{
listOfCVLs
.
push
(
vals
)
;
break
;
}
else
{
vals
.
push
(
val
)
;
}
}
}
}
function
CSSParserRule
(
)
{
throw
"
Abstract
Base
Class
"
;
}
CSSParserRule
.
prototype
.
toString
=
function
(
indent
)
{
return
JSON
.
stringify
(
this
null
indent
)
;
}
;
CSSParserRule
.
prototype
.
toJSON
=
function
(
)
{
return
{
type
:
this
.
type
value
:
this
.
value
}
;
}
;
function
Stylesheet
(
)
{
this
.
value
=
[
]
;
return
this
;
}
Stylesheet
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
Stylesheet
.
prototype
.
type
=
"
STYLESHEET
"
;
function
AtRule
(
name
)
{
this
.
name
=
name
;
this
.
prelude
=
[
]
;
this
.
value
=
null
;
return
this
;
}
AtRule
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
AtRule
.
prototype
.
type
=
"
AT
-
RULE
"
;
AtRule
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
json
.
prelude
=
this
.
prelude
;
return
json
;
}
;
function
QualifiedRule
(
)
{
this
.
prelude
=
[
]
;
this
.
value
=
[
]
;
return
this
;
}
QualifiedRule
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
QualifiedRule
.
prototype
.
type
=
"
QUALIFIED
-
RULE
"
;
QualifiedRule
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
prelude
=
this
.
prelude
;
return
json
;
}
;
function
Declaration
(
name
)
{
this
.
name
=
name
;
this
.
value
=
[
]
;
this
.
important
=
false
;
return
this
;
}
Declaration
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
Declaration
.
prototype
.
type
=
"
DECLARATION
"
;
Declaration
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
json
.
important
=
this
.
important
;
return
json
;
}
;
function
SimpleBlock
(
type
)
{
this
.
name
=
type
;
this
.
value
=
[
]
;
return
this
;
}
SimpleBlock
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
SimpleBlock
.
prototype
.
type
=
"
BLOCK
"
;
SimpleBlock
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
return
json
;
}
;
function
Func
(
name
)
{
this
.
name
=
name
;
this
.
value
=
[
]
;
return
this
;
}
Func
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
Func
.
prototype
.
type
=
"
FUNCTION
"
;
Func
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
return
json
;
}
;
function
CSSLexer
(
text
)
{
this
.
stream
=
tokenize
(
text
{
loc
:
true
offsets
:
true
keepComments
:
true
}
)
;
this
.
lineNumber
=
0
;
this
.
columnNumber
=
0
;
return
this
;
}
CSSLexer
.
prototype
.
performEOFFixup
=
function
(
input
preserveBackslash
)
{
return
"
"
;
}
;
CSSLexer
.
prototype
.
nextToken
=
function
(
)
{
if
(
!
this
.
stream
)
{
return
null
;
}
let
v
=
this
.
stream
.
next
(
)
;
if
(
v
.
done
|
|
v
.
value
.
tokenType
=
=
=
"
EOF
"
)
{
this
.
stream
=
null
;
return
null
;
}
this
.
lineNumber
=
v
.
value
.
loc
.
start
.
line
;
this
.
columnNumber
=
v
.
value
.
loc
.
start
.
column
;
return
v
.
value
;
}
;
exports
.
CSSParserRule
=
CSSParserRule
;
exports
.
Stylesheet
=
Stylesheet
;
exports
.
AtRule
=
AtRule
;
exports
.
QualifiedRule
=
QualifiedRule
;
exports
.
Declaration
=
Declaration
;
exports
.
SimpleBlock
=
SimpleBlock
;
exports
.
Func
=
Func
;
exports
.
parseAStylesheet
=
parseAStylesheet
;
exports
.
parseAListOfRules
=
parseAListOfRules
;
exports
.
parseARule
=
parseARule
;
exports
.
parseADeclaration
=
parseADeclaration
;
exports
.
parseAListOfDeclarations
=
parseAListOfDeclarations
;
exports
.
parseAComponentValue
=
parseAComponentValue
;
exports
.
parseAListOfComponentValues
=
parseAListOfComponentValues
;
exports
.
parseACommaSeparatedListOfComponentValues
=
parseACommaSeparatedListOfComponentValues
;
exports
.
CSSLexer
=
CSSLexer
;
}
)
)
;
}
function
(
module
exports
)
{
var
cssColors
=
{
aliceblue
:
[
240
248
255
]
antiquewhite
:
[
250
235
215
]
aqua
:
[
0
255
255
]
aquamarine
:
[
127
255
212
]
azure
:
[
240
255
255
]
beige
:
[
245
245
220
]
bisque
:
[
255
228
196
]
black
:
[
0
0
0
]
blanchedalmond
:
[
255
235
205
]
blue
:
[
0
0
255
]
blueviolet
:
[
138
43
226
]
brown
:
[
165
42
42
]
burlywood
:
[
222
184
135
]
cadetblue
:
[
95
158
160
]
chartreuse
:
[
127
255
0
]
chocolate
:
[
210
105
30
]
coral
:
[
255
127
80
]
cornflowerblue
:
[
100
149
237
]
cornsilk
:
[
255
248
220
]
crimson
:
[
220
20
60
]
cyan
:
[
0
255
255
]
darkblue
:
[
0
0
139
]
darkcyan
:
[
0
139
139
]
darkgoldenrod
:
[
184
134
11
]
darkgray
:
[
169
169
169
]
darkgreen
:
[
0
100
0
]
darkgrey
:
[
169
169
169
]
darkkhaki
:
[
189
183
107
]
darkmagenta
:
[
139
0
139
]
darkolivegreen
:
[
85
107
47
]
darkorange
:
[
255
140
0
]
darkorchid
:
[
153
50
204
]
darkred
:
[
139
0
0
]
darksalmon
:
[
233
150
122
]
darkseagreen
:
[
143
188
143
]
darkslateblue
:
[
72
61
139
]
darkslategray
:
[
47
79
79
]
darkslategrey
:
[
47
79
79
]
darkturquoise
:
[
0
206
209
]
darkviolet
:
[
148
0
211
]
deeppink
:
[
255
20
147
]
deepskyblue
:
[
0
191
255
]
dimgray
:
[
105
105
105
]
dimgrey
:
[
105
105
105
]
dodgerblue
:
[
30
144
255
]
firebrick
:
[
178
34
34
]
floralwhite
:
[
255
250
240
]
forestgreen
:
[
34
139
34
]
fuchsia
:
[
255
0
255
]
gainsboro
:
[
220
220
220
]
ghostwhite
:
[
248
248
255
]
gold
:
[
255
215
0
]
goldenrod
:
[
218
165
32
]
gray
:
[
128
128
128
]
grey
:
[
128
128
128
]
green
:
[
0
128
0
]
greenyellow
:
[
173
255
47
]
honeydew
:
[
240
255
240
]
hotpink
:
[
255
105
180
]
indianred
:
[
205
92
92
]
indigo
:
[
75
0
130
]
ivory
:
[
255
255
240
]
khaki
:
[
240
230
140
]
lavender
:
[
230
230
250
]
lavenderblush
:
[
255
240
245
]
lawngreen
:
[
124
252
0
]
lemonchiffon
:
[
255
250
205
]
lightblue
:
[
173
216
230
]
lightcoral
:
[
240
128
128
]
lightcyan
:
[
224
255
255
]
lightgoldenrodyellow
:
[
250
250
210
]
lightgray
:
[
211
211
211
]
lightgreen
:
[
144
238
144
]
lightgrey
:
[
211
211
211
]
lightpink
:
[
255
182
193
]
lightsalmon
:
[
255
160
122
]
lightseagreen
:
[
32
178
170
]
lightskyblue
:
[
135
206
250
]
lightslategray
:
[
119
136
153
]
lightslategrey
:
[
119
136
153
]
lightsteelblue
:
[
176
196
222
]
lightyellow
:
[
255
255
224
]
lime
:
[
0
255
0
]
limegreen
:
[
50
205
50
]
linen
:
[
250
240
230
]
magenta
:
[
255
0
255
]
maroon
:
[
128
0
0
]
mediumaquamarine
:
[
102
205
170
]
mediumblue
:
[
0
0
205
]
mediumorchid
:
[
186
85
211
]
mediumpurple
:
[
147
112
219
]
mediumseagreen
:
[
60
179
113
]
mediumslateblue
:
[
123
104
238
]
mediumspringgreen
:
[
0
250
154
]
mediumturquoise
:
[
72
209
204
]
mediumvioletred
:
[
199
21
133
]
midnightblue
:
[
25
25
112
]
mintcream
:
[
245
255
250
]
mistyrose
:
[
255
228
225
]
moccasin
:
[
255
228
181
]
navajowhite
:
[
255
222
173
]
navy
:
[
0
0
128
]
oldlace
:
[
253
245
230
]
olive
:
[
128
128
0
]
olivedrab
:
[
107
142
35
]
orange
:
[
255
165
0
]
orangered
:
[
255
69
0
]
orchid
:
[
218
112
214
]
palegoldenrod
:
[
238
232
170
]
palegreen
:
[
152
251
152
]
paleturquoise
:
[
175
238
238
]
palevioletred
:
[
219
112
147
]
papayawhip
:
[
255
239
213
]
peachpuff
:
[
255
218
185
]
peru
:
[
205
133
63
]
pink
:
[
255
192
203
]
plum
:
[
221
160
221
]
powderblue
:
[
176
224
230
]
purple
:
[
128
0
128
]
rebeccapurple
:
[
102
51
153
]
red
:
[
255
0
0
]
rosybrown
:
[
188
143
143
]
royalblue
:
[
65
105
225
]
saddlebrown
:
[
139
69
19
]
salmon
:
[
250
128
114
]
sandybrown
:
[
244
164
96
]
seagreen
:
[
46
139
87
]
seashell
:
[
255
245
238
]
sienna
:
[
160
82
45
]
silver
:
[
192
192
192
]
skyblue
:
[
135
206
235
]
slateblue
:
[
106
90
205
]
slategray
:
[
112
128
144
]
slategrey
:
[
112
128
144
]
snow
:
[
255
250
250
]
springgreen
:
[
0
255
127
]
steelblue
:
[
70
130
180
]
tan
:
[
210
180
140
]
teal
:
[
0
128
128
]
thistle
:
[
216
191
216
]
tomato
:
[
255
99
71
]
turquoise
:
[
64
224
208
]
violet
:
[
238
130
238
]
wheat
:
[
245
222
179
]
white
:
[
255
255
255
]
whitesmoke
:
[
245
245
245
]
yellow
:
[
255
255
0
]
yellowgreen
:
[
154
205
50
]
}
;
module
.
exports
=
{
cssColors
}
;
}
function
(
module
exports
)
{
var
cssProperties
=
{
"
-
moz
-
appearance
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
gtk
-
info
-
bar
"
"
-
moz
-
mac
-
disclosure
-
button
-
closed
"
"
-
moz
-
mac
-
disclosure
-
button
-
open
"
"
-
moz
-
mac
-
fullscreen
-
button
"
"
-
moz
-
mac
-
help
-
button
"
"
-
moz
-
mac
-
vibrancy
-
dark
"
"
-
moz
-
mac
-
vibrancy
-
light
"
"
-
moz
-
win
-
borderless
-
glass
"
"
-
moz
-
win
-
browsertabbar
-
toolbox
"
"
-
moz
-
win
-
communications
-
toolbox
"
"
-
moz
-
win
-
exclude
-
glass
"
"
-
moz
-
win
-
glass
"
"
-
moz
-
win
-
media
-
toolbox
"
"
-
moz
-
window
-
button
-
box
"
"
-
moz
-
window
-
button
-
box
-
maximized
"
"
-
moz
-
window
-
button
-
close
"
"
-
moz
-
window
-
button
-
maximize
"
"
-
moz
-
window
-
button
-
minimize
"
"
-
moz
-
window
-
button
-
restore
"
"
-
moz
-
window
-
frame
-
bottom
"
"
-
moz
-
window
-
frame
-
left
"
"
-
moz
-
window
-
frame
-
right
"
"
-
moz
-
window
-
titlebar
"
"
-
moz
-
window
-
titlebar
-
maximized
"
"
button
"
"
button
-
arrow
-
down
"
"
button
-
arrow
-
next
"
"
button
-
arrow
-
previous
"
"
button
-
arrow
-
up
"
"
button
-
bevel
"
"
button
-
focus
"
"
caret
"
"
checkbox
"
"
checkbox
-
container
"
"
checkbox
-
label
"
"
checkmenuitem
"
"
dialog
"
"
dualbutton
"
"
groupbox
"
"
inherit
"
"
initial
"
"
listbox
"
"
listitem
"
"
menuarrow
"
"
menubar
"
"
menucheckbox
"
"
menuimage
"
"
menuitem
"
"
menuitemtext
"
"
menulist
"
"
menulist
-
button
"
"
menulist
-
text
"
"
menulist
-
textfield
"
"
menupopup
"
"
menuradio
"
"
menuseparator
"
"
meterbar
"
"
meterchunk
"
"
none
"
"
number
-
input
"
"
progressbar
"
"
progressbar
-
vertical
"
"
progresschunk
"
"
progresschunk
-
vertical
"
"
radio
"
"
radio
-
container
"
"
radio
-
label
"
"
radiomenuitem
"
"
range
"
"
range
-
thumb
"
"
resizer
"
"
resizerpanel
"
"
scale
-
horizontal
"
"
scale
-
vertical
"
"
scalethumb
-
horizontal
"
"
scalethumb
-
vertical
"
"
scalethumbend
"
"
scalethumbstart
"
"
scalethumbtick
"
"
scrollbar
"
"
scrollbar
-
small
"
"
scrollbarbutton
-
down
"
"
scrollbarbutton
-
left
"
"
scrollbarbutton
-
right
"
"
scrollbarbutton
-
up
"
"
scrollbarthumb
-
horizontal
"
"
scrollbarthumb
-
vertical
"
"
scrollbartrack
-
horizontal
"
"
scrollbartrack
-
vertical
"
"
searchfield
"
"
separator
"
"
spinner
"
"
spinner
-
downbutton
"
"
spinner
-
textfield
"
"
spinner
-
upbutton
"
"
splitter
"
"
statusbar
"
"
statusbarpanel
"
"
tab
"
"
tab
-
scroll
-
arrow
-
back
"
"
tab
-
scroll
-
arrow
-
forward
"
"
tabpanel
"
"
tabpanels
"
"
textfield
"
"
textfield
-
multiline
"
"
toolbar
"
"
toolbarbutton
"
"
toolbarbutton
-
dropdown
"
"
toolbargripper
"
"
toolbox
"
"
tooltip
"
"
treeheader
"
"
treeheadercell
"
"
treeheadersortarrow
"
"
treeitem
"
"
treeline
"
"
treetwisty
"
"
treetwistyopen
"
"
treeview
"
"
unset
"
"
window
"
]
}
"
-
moz
-
outline
-
radius
-
topleft
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
-
topright
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
-
bottomright
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
-
bottomleft
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
tab
-
size
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
delay
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
direction
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
animation
-
duration
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
fill
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
backwards
"
"
both
"
"
forwards
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
animation
-
iteration
-
count
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
infinite
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
name
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
animation
-
play
-
state
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
paused
"
"
running
"
"
unset
"
]
}
"
animation
-
timing
-
function
"
:
{
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
background
-
attachment
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
fixed
"
"
inherit
"
"
initial
"
"
local
"
"
scroll
"
"
unset
"
]
}
"
background
-
clip
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
background
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
background
-
image
"
:
{
inherited
:
false
supports
:
648
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
background
-
blend
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
color
"
"
color
-
burn
"
"
color
-
dodge
"
"
darken
"
"
difference
"
"
exclusion
"
"
hard
-
light
"
"
hue
"
"
inherit
"
"
initial
"
"
lighten
"
"
luminosity
"
"
multiply
"
"
normal
"
"
overlay
"
"
saturation
"
"
screen
"
"
soft
-
light
"
"
unset
"
]
}
"
background
-
origin
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
background
-
position
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
background
-
repeat
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
no
-
repeat
"
"
repeat
"
"
repeat
-
x
"
"
repeat
-
y
"
"
unset
"
]
}
"
background
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
binding
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
block
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
block
-
end
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
end
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
block
-
end
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
block
-
start
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
start
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
block
-
start
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
bottom
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
bottom
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
bottom
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
bottom
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
collapse
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
collapse
"
"
inherit
"
"
initial
"
"
separate
"
"
unset
"
]
}
"
border
-
image
-
source
"
:
{
inherited
:
false
supports
:
648
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
border
-
image
-
slice
"
:
{
inherited
:
false
supports
:
1026
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
image
-
width
"
:
{
inherited
:
false
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
image
-
outset
"
:
{
inherited
:
false
supports
:
1025
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
image
-
repeat
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
inline
-
end
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
inline
-
end
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
inline
-
end
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
inline
-
start
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
inline
-
start
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
inline
-
start
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
left
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
left
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
left
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
left
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
right
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
right
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
right
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
right
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
spacing
"
:
{
inherited
:
true
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
top
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
top
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
top
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
top
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
top
-
left
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
top
-
right
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
bottom
-
right
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
bottom
-
left
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
bottom
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
box
-
decoration
-
break
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
clone
"
"
inherit
"
"
initial
"
"
slice
"
"
unset
"
]
}
"
box
-
shadow
"
:
{
inherited
:
false
supports
:
5
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
box
-
sizing
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
caption
-
side
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
bottom
"
"
bottom
-
outside
"
"
inherit
"
"
initial
"
"
left
"
"
right
"
"
top
"
"
top
-
outside
"
"
unset
"
]
}
"
clear
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
both
"
"
inherit
"
"
initial
"
"
inline
-
end
"
"
inline
-
start
"
"
left
"
"
none
"
"
right
"
"
unset
"
]
}
"
clip
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
color
"
:
{
inherited
:
true
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
column
-
count
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
fill
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
balance
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
gap
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
-
moz
-
column
-
rule
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
column
-
rule
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
-
moz
-
column
-
rule
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
contain
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
layout
"
"
none
"
"
paint
"
"
strict
"
"
style
"
"
unset
"
]
}
"
content
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
control
-
character
-
visibility
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
counter
-
increment
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
counter
-
reset
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
cursor
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
direction
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
ltr
"
"
rtl
"
"
unset
"
]
}
"
display
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
box
"
"
-
moz
-
deck
"
"
-
moz
-
grid
"
"
-
moz
-
grid
-
group
"
"
-
moz
-
grid
-
line
"
"
-
moz
-
groupbox
"
"
-
moz
-
inline
-
box
"
"
-
moz
-
inline
-
grid
"
"
-
moz
-
inline
-
stack
"
"
-
moz
-
popup
"
"
-
moz
-
stack
"
"
block
"
"
contents
"
"
flex
"
"
grid
"
"
inherit
"
"
initial
"
"
inline
"
"
inline
-
block
"
"
inline
-
flex
"
"
inline
-
grid
"
"
inline
-
table
"
"
list
-
item
"
"
none
"
"
ruby
"
"
ruby
-
base
"
"
ruby
-
base
-
container
"
"
ruby
-
text
"
"
ruby
-
text
-
container
"
"
table
"
"
table
-
caption
"
"
table
-
cell
"
"
table
-
column
"
"
table
-
column
-
group
"
"
table
-
footer
-
group
"
"
table
-
header
-
group
"
"
table
-
row
"
"
table
-
row
-
group
"
"
unset
"
]
}
"
empty
-
cells
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
hide
"
"
inherit
"
"
initial
"
"
show
"
"
unset
"
]
}
"
align
-
content
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
align
-
items
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
align
-
self
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
basis
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
direction
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
column
"
"
column
-
reverse
"
"
inherit
"
"
initial
"
"
row
"
"
row
-
reverse
"
"
unset
"
]
}
"
flex
-
grow
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
shrink
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
wrap
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
nowrap
"
"
unset
"
"
wrap
"
"
wrap
-
reverse
"
]
}
"
order
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
justify
-
content
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
justify
-
items
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
justify
-
self
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
float
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
inline
-
end
"
"
inline
-
start
"
"
left
"
"
none
"
"
right
"
"
unset
"
]
}
"
-
moz
-
float
-
edge
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
content
-
box
"
"
inherit
"
"
initial
"
"
margin
-
box
"
"
unset
"
]
}
"
font
-
family
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
feature
-
settings
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
kerning
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
none
"
"
normal
"
"
unset
"
]
}
"
font
-
language
-
override
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
font
-
size
"
:
{
inherited
:
true
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
large
"
"
larger
"
"
medium
"
"
small
"
"
smaller
"
"
unset
"
"
x
-
large
"
"
x
-
small
"
"
xx
-
large
"
"
xx
-
small
"
]
}
"
font
-
size
-
adjust
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
font
-
stretch
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
condensed
"
"
expanded
"
"
extra
-
condensed
"
"
extra
-
expanded
"
"
inherit
"
"
initial
"
"
normal
"
"
semi
-
condensed
"
"
semi
-
expanded
"
"
ultra
-
condensed
"
"
ultra
-
expanded
"
"
unset
"
]
}
"
font
-
style
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
italic
"
"
normal
"
"
oblique
"
"
unset
"
]
}
"
font
-
synthesis
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
alternates
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
caps
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
inherit
"
"
initial
"
"
normal
"
"
petite
-
caps
"
"
small
-
caps
"
"
titling
-
caps
"
"
unicase
"
"
unset
"
]
}
"
font
-
variant
-
east
-
asian
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
ligatures
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
numeric
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
position
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
sub
"
"
super
"
"
unset
"
]
}
"
font
-
weight
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
force
-
broken
-
image
-
icon
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
auto
-
flow
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
auto
-
columns
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
auto
-
rows
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
template
-
areas
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
template
-
columns
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
template
-
rows
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
-
start
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
-
end
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
-
start
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
-
end
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
-
gap
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
-
gap
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
height
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
image
-
orientation
"
:
{
inherited
:
true
supports
:
16
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
image
-
region
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
ime
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
active
"
"
auto
"
"
disabled
"
"
inactive
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
inline
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
left
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
letter
-
spacing
"
:
{
inherited
:
true
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
line
-
height
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
-
moz
-
block
-
height
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
list
-
style
-
image
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
list
-
style
-
position
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
inside
"
"
outside
"
"
unset
"
]
}
"
list
-
style
-
type
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
block
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
block
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
bottom
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
inline
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
inline
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
left
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
right
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
top
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
marker
-
offset
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
max
-
block
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
max
-
height
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
max
-
inline
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
max
-
width
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
min
-
height
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
min
-
block
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
min
-
inline
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
min
-
width
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
mix
-
blend
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
color
"
"
color
-
burn
"
"
color
-
dodge
"
"
darken
"
"
difference
"
"
exclusion
"
"
hard
-
light
"
"
hue
"
"
inherit
"
"
initial
"
"
lighten
"
"
luminosity
"
"
multiply
"
"
normal
"
"
overlay
"
"
saturation
"
"
screen
"
"
soft
-
light
"
"
unset
"
]
}
"
isolation
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
isolate
"
"
unset
"
]
}
"
object
-
fit
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
contain
"
"
cover
"
"
fill
"
"
inherit
"
"
initial
"
"
none
"
"
scale
-
down
"
"
unset
"
]
}
"
object
-
position
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
block
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
block
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
inline
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
inline
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
opacity
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
orient
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
block
"
"
horizontal
"
"
inherit
"
"
initial
"
"
inline
"
"
unset
"
"
vertical
"
]
}
"
outline
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
outline
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
outline
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
outline
-
offset
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
overflow
-
x
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
hidden
-
unscrollable
"
"
auto
"
"
hidden
"
"
inherit
"
"
initial
"
"
scroll
"
"
unset
"
"
visible
"
]
}
"
overflow
-
y
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
hidden
-
unscrollable
"
"
auto
"
"
hidden
"
"
inherit
"
"
initial
"
"
scroll
"
"
unset
"
"
visible
"
]
}
"
padding
-
block
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
block
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
bottom
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
inline
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
inline
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
left
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
right
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
top
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
page
-
break
-
after
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
always
"
"
auto
"
"
avoid
"
"
inherit
"
"
initial
"
"
left
"
"
right
"
"
unset
"
]
}
"
page
-
break
-
before
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
always
"
"
auto
"
"
avoid
"
"
inherit
"
"
initial
"
"
left
"
"
right
"
"
unset
"
]
}
"
page
-
break
-
inside
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
avoid
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
paint
-
order
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
pointer
-
events
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
all
"
"
auto
"
"
fill
"
"
inherit
"
"
initial
"
"
none
"
"
painted
"
"
stroke
"
"
unset
"
"
visible
"
"
visiblefill
"
"
visiblepainted
"
"
visiblestroke
"
]
}
"
position
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
absolute
"
"
fixed
"
"
inherit
"
"
initial
"
"
relative
"
"
static
"
"
sticky
"
"
unset
"
]
}
"
quotes
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
resize
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
both
"
"
horizontal
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
vertical
"
]
}
"
right
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
ruby
-
align
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
center
"
"
inherit
"
"
initial
"
"
space
-
around
"
"
space
-
between
"
"
start
"
"
unset
"
]
}
"
ruby
-
position
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
over
"
"
under
"
"
unset
"
]
}
"
scroll
-
behavior
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
smooth
"
"
unset
"
]
}
"
scroll
-
snap
-
coordinate
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
destination
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
points
-
x
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
points
-
y
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
type
-
x
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mandatory
"
"
none
"
"
proximity
"
"
unset
"
]
}
"
scroll
-
snap
-
type
-
y
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mandatory
"
"
none
"
"
proximity
"
"
unset
"
]
}
"
table
-
layout
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
fixed
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
align
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
-
moz
-
center
"
"
-
moz
-
left
"
"
-
moz
-
right
"
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
justify
"
"
left
"
"
right
"
"
start
"
"
unset
"
]
}
"
-
moz
-
text
-
align
-
last
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
justify
"
"
left
"
"
right
"
"
start
"
"
unset
"
]
}
"
text
-
decoration
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
text
-
decoration
-
line
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
decoration
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
none
"
"
dashed
"
"
dotted
"
"
double
"
"
inherit
"
"
initial
"
"
solid
"
"
unset
"
"
wavy
"
]
}
"
text
-
indent
"
:
{
inherited
:
true
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
orientation
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mixed
"
"
sideways
"
"
sideways
-
right
"
"
unset
"
"
upright
"
]
}
"
text
-
overflow
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
shadow
"
:
{
inherited
:
true
supports
:
5
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
text
-
size
-
adjust
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
text
-
transform
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
capitalize
"
"
full
-
width
"
"
inherit
"
"
initial
"
"
lowercase
"
"
none
"
"
unset
"
"
uppercase
"
]
}
"
transform
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transform
-
box
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
fill
-
box
"
"
inherit
"
"
initial
"
"
unset
"
"
view
-
box
"
]
}
"
transform
-
origin
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
perspective
-
origin
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
perspective
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
transform
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
flat
"
"
inherit
"
"
initial
"
"
preserve
-
3d
"
"
unset
"
]
}
"
backface
-
visibility
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
top
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transition
-
delay
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transition
-
duration
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transition
-
property
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
all
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
transition
-
timing
-
function
"
:
{
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
unicode
-
bidi
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
isolate
"
"
-
moz
-
isolate
-
override
"
"
-
moz
-
plaintext
"
"
bidi
-
override
"
"
embed
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
-
moz
-
user
-
focus
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
ignore
"
"
inherit
"
"
initial
"
"
none
"
"
normal
"
"
select
-
after
"
"
select
-
all
"
"
select
-
before
"
"
select
-
menu
"
"
select
-
same
"
"
unset
"
]
}
"
-
moz
-
user
-
input
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
disabled
"
"
enabled
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
user
-
modify
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
read
-
only
"
"
read
-
write
"
"
unset
"
"
write
-
only
"
]
}
"
-
moz
-
user
-
select
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
all
"
"
-
moz
-
none
"
"
-
moz
-
text
"
"
all
"
"
auto
"
"
element
"
"
elements
"
"
inherit
"
"
initial
"
"
none
"
"
text
"
"
toggle
"
"
tri
-
state
"
"
unset
"
]
}
"
vertical
-
align
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
middle
-
with
-
baseline
"
"
baseline
"
"
bottom
"
"
calc
"
"
inherit
"
"
initial
"
"
middle
"
"
sub
"
"
super
"
"
text
-
bottom
"
"
text
-
top
"
"
top
"
"
unset
"
]
}
"
visibility
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
collapse
"
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
white
-
space
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
-
moz
-
pre
-
space
"
"
inherit
"
"
initial
"
"
normal
"
"
nowrap
"
"
pre
"
"
pre
-
line
"
"
pre
-
wrap
"
"
unset
"
]
}
"
width
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
window
-
dragging
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
drag
"
"
inherit
"
"
initial
"
"
no
-
drag
"
"
unset
"
]
}
"
word
-
break
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
break
-
all
"
"
inherit
"
"
initial
"
"
keep
-
all
"
"
normal
"
"
unset
"
]
}
"
word
-
spacing
"
:
{
inherited
:
true
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
word
-
wrap
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
break
-
word
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
hyphens
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
manual
"
"
none
"
"
unset
"
]
}
"
writing
-
mode
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
horizontal
-
tb
"
"
inherit
"
"
initial
"
"
lr
"
"
lr
-
tb
"
"
rl
"
"
rl
-
tb
"
"
sideways
-
lr
"
"
sideways
-
rl
"
"
tb
"
"
tb
-
rl
"
"
unset
"
"
vertical
-
lr
"
"
vertical
-
rl
"
]
}
"
z
-
index
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
box
-
align
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
baseline
"
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
start
"
"
stretch
"
"
unset
"
]
}
"
-
moz
-
box
-
direction
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
-
moz
-
box
-
flex
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
box
-
orient
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
block
-
axis
"
"
horizontal
"
"
inherit
"
"
initial
"
"
inline
-
axis
"
"
unset
"
"
vertical
"
]
}
"
-
moz
-
box
-
pack
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
justify
"
"
start
"
"
unset
"
]
}
"
-
moz
-
box
-
ordinal
-
group
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
stack
-
sizing
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
ignore
"
"
inherit
"
"
initial
"
"
stretch
-
to
-
fit
"
"
unset
"
]
}
"
clip
-
path
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
clip
-
rule
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
evenodd
"
"
inherit
"
"
initial
"
"
nonzero
"
"
unset
"
]
}
"
color
-
interpolation
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
linearrgb
"
"
srgb
"
"
unset
"
]
}
"
color
-
interpolation
-
filters
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
linearrgb
"
"
srgb
"
"
unset
"
]
}
"
dominant
-
baseline
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
alphabetic
"
"
auto
"
"
central
"
"
hanging
"
"
ideographic
"
"
inherit
"
"
initial
"
"
mathematical
"
"
middle
"
"
no
-
change
"
"
reset
-
size
"
"
text
-
after
-
edge
"
"
text
-
before
-
edge
"
"
unset
"
"
use
-
script
"
]
}
"
fill
"
:
{
inherited
:
true
supports
:
12
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
fill
-
opacity
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
fill
-
rule
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
evenodd
"
"
inherit
"
"
initial
"
"
nonzero
"
"
unset
"
]
}
"
filter
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flood
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
flood
-
opacity
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
image
-
rendering
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
-
moz
-
crisp
-
edges
"
"
auto
"
"
inherit
"
"
initial
"
"
optimizequality
"
"
optimizespeed
"
"
unset
"
]
}
"
lighting
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
marker
-
end
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
marker
-
mid
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
marker
-
start
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
mask
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
mask
-
type
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
alpha
"
"
inherit
"
"
initial
"
"
luminance
"
"
unset
"
]
}
"
shape
-
rendering
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
crispedges
"
"
geometricprecision
"
"
inherit
"
"
initial
"
"
optimizespeed
"
"
unset
"
]
}
"
stop
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
stop
-
opacity
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
"
:
{
inherited
:
true
supports
:
12
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
dasharray
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
dashoffset
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
linecap
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
butt
"
"
inherit
"
"
initial
"
"
round
"
"
square
"
"
unset
"
]
}
"
stroke
-
linejoin
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
bevel
"
"
inherit
"
"
initial
"
"
miter
"
"
round
"
"
unset
"
]
}
"
stroke
-
miterlimit
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
opacity
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
width
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
anchor
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
end
"
"
inherit
"
"
initial
"
"
middle
"
"
start
"
"
unset
"
]
}
"
text
-
rendering
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
geometricprecision
"
"
inherit
"
"
initial
"
"
optimizelegibility
"
"
optimizespeed
"
"
unset
"
]
}
"
vector
-
effect
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
non
-
scaling
-
stroke
"
"
none
"
"
unset
"
]
}
"
will
-
change
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
"
:
{
subproperties
:
[
"
-
moz
-
outline
-
radius
-
topleft
"
"
-
moz
-
outline
-
radius
-
topright
"
"
-
moz
-
outline
-
radius
-
bottomright
"
"
-
moz
-
outline
-
radius
-
bottomleft
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
all
"
:
{
subproperties
:
[
"
-
moz
-
appearance
"
"
-
moz
-
outline
-
radius
-
topleft
"
"
-
moz
-
outline
-
radius
-
topright
"
"
-
moz
-
outline
-
radius
-
bottomright
"
"
-
moz
-
outline
-
radius
-
bottomleft
"
"
-
moz
-
tab
-
size
"
"
-
x
-
system
-
font
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
duration
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
name
"
"
animation
-
play
-
state
"
"
animation
-
timing
-
function
"
"
background
-
attachment
"
"
background
-
clip
"
"
background
-
color
"
"
background
-
image
"
"
background
-
blend
-
mode
"
"
background
-
origin
"
"
background
-
position
"
"
background
-
repeat
"
"
background
-
size
"
"
-
moz
-
binding
"
"
block
-
size
"
"
border
-
block
-
end
-
color
"
"
border
-
block
-
end
-
style
"
"
border
-
block
-
end
-
width
"
"
border
-
block
-
start
-
color
"
"
border
-
block
-
start
-
style
"
"
border
-
block
-
start
-
width
"
"
border
-
bottom
-
color
"
"
-
moz
-
border
-
bottom
-
colors
"
"
border
-
bottom
-
style
"
"
border
-
bottom
-
width
"
"
border
-
collapse
"
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
"
border
-
inline
-
end
-
color
"
"
border
-
inline
-
end
-
style
"
"
border
-
inline
-
end
-
width
"
"
border
-
inline
-
start
-
color
"
"
border
-
inline
-
start
-
style
"
"
border
-
inline
-
start
-
width
"
"
border
-
left
-
color
"
"
-
moz
-
border
-
left
-
colors
"
"
border
-
left
-
style
"
"
border
-
left
-
width
"
"
border
-
right
-
color
"
"
-
moz
-
border
-
right
-
colors
"
"
border
-
right
-
style
"
"
border
-
right
-
width
"
"
border
-
spacing
"
"
border
-
top
-
color
"
"
-
moz
-
border
-
top
-
colors
"
"
border
-
top
-
style
"
"
border
-
top
-
width
"
"
border
-
top
-
left
-
radius
"
"
border
-
top
-
right
-
radius
"
"
border
-
bottom
-
right
-
radius
"
"
border
-
bottom
-
left
-
radius
"
"
bottom
"
"
box
-
decoration
-
break
"
"
box
-
shadow
"
"
box
-
sizing
"
"
caption
-
side
"
"
clear
"
"
clip
"
"
color
"
"
-
moz
-
column
-
count
"
"
-
moz
-
column
-
fill
"
"
-
moz
-
column
-
width
"
"
-
moz
-
column
-
gap
"
"
-
moz
-
column
-
rule
-
color
"
"
-
moz
-
column
-
rule
-
style
"
"
-
moz
-
column
-
rule
-
width
"
"
contain
"
"
content
"
"
-
moz
-
control
-
character
-
visibility
"
"
counter
-
increment
"
"
counter
-
reset
"
"
cursor
"
"
display
"
"
empty
-
cells
"
"
align
-
content
"
"
align
-
items
"
"
align
-
self
"
"
flex
-
basis
"
"
flex
-
direction
"
"
flex
-
grow
"
"
flex
-
shrink
"
"
flex
-
wrap
"
"
order
"
"
justify
-
content
"
"
justify
-
items
"
"
justify
-
self
"
"
float
"
"
-
moz
-
float
-
edge
"
"
font
-
family
"
"
font
-
feature
-
settings
"
"
font
-
kerning
"
"
font
-
language
-
override
"
"
font
-
size
"
"
font
-
size
-
adjust
"
"
-
moz
-
osx
-
font
-
smoothing
"
"
font
-
stretch
"
"
font
-
style
"
"
font
-
synthesis
"
"
font
-
variant
-
alternates
"
"
font
-
variant
-
caps
"
"
font
-
variant
-
east
-
asian
"
"
font
-
variant
-
ligatures
"
"
font
-
variant
-
numeric
"
"
font
-
variant
-
position
"
"
font
-
weight
"
"
-
moz
-
force
-
broken
-
image
-
icon
"
"
grid
-
auto
-
flow
"
"
grid
-
auto
-
columns
"
"
grid
-
auto
-
rows
"
"
grid
-
template
-
areas
"
"
grid
-
template
-
columns
"
"
grid
-
template
-
rows
"
"
grid
-
column
-
start
"
"
grid
-
column
-
end
"
"
grid
-
row
-
start
"
"
grid
-
row
-
end
"
"
grid
-
column
-
gap
"
"
grid
-
row
-
gap
"
"
height
"
"
image
-
orientation
"
"
-
moz
-
image
-
region
"
"
ime
-
mode
"
"
inline
-
size
"
"
left
"
"
letter
-
spacing
"
"
line
-
height
"
"
list
-
style
-
image
"
"
list
-
style
-
position
"
"
list
-
style
-
type
"
"
margin
-
block
-
end
"
"
margin
-
block
-
start
"
"
margin
-
bottom
"
"
margin
-
inline
-
end
"
"
margin
-
inline
-
start
"
"
margin
-
left
"
"
margin
-
right
"
"
margin
-
top
"
"
marker
-
offset
"
"
max
-
block
-
size
"
"
max
-
height
"
"
max
-
inline
-
size
"
"
max
-
width
"
"
-
moz
-
min
-
font
-
size
-
ratio
"
"
min
-
height
"
"
min
-
block
-
size
"
"
min
-
inline
-
size
"
"
min
-
width
"
"
mix
-
blend
-
mode
"
"
isolation
"
"
object
-
fit
"
"
object
-
position
"
"
offset
-
block
-
end
"
"
offset
-
block
-
start
"
"
offset
-
inline
-
end
"
"
offset
-
inline
-
start
"
"
opacity
"
"
-
moz
-
orient
"
"
outline
-
color
"
"
outline
-
style
"
"
outline
-
width
"
"
outline
-
offset
"
"
overflow
-
clip
-
box
"
"
overflow
-
x
"
"
overflow
-
y
"
"
padding
-
block
-
end
"
"
padding
-
block
-
start
"
"
padding
-
bottom
"
"
padding
-
inline
-
end
"
"
padding
-
inline
-
start
"
"
padding
-
left
"
"
padding
-
right
"
"
padding
-
top
"
"
page
-
break
-
after
"
"
page
-
break
-
before
"
"
page
-
break
-
inside
"
"
paint
-
order
"
"
pointer
-
events
"
"
position
"
"
quotes
"
"
resize
"
"
right
"
"
ruby
-
align
"
"
ruby
-
position
"
"
scroll
-
behavior
"
"
scroll
-
snap
-
coordinate
"
"
scroll
-
snap
-
destination
"
"
scroll
-
snap
-
points
-
x
"
"
scroll
-
snap
-
points
-
y
"
"
scroll
-
snap
-
type
-
x
"
"
scroll
-
snap
-
type
-
y
"
"
table
-
layout
"
"
text
-
align
"
"
-
moz
-
text
-
align
-
last
"
"
text
-
combine
-
upright
"
"
text
-
decoration
-
color
"
"
text
-
decoration
-
line
"
"
text
-
decoration
-
style
"
"
text
-
indent
"
"
text
-
orientation
"
"
text
-
overflow
"
"
text
-
shadow
"
"
-
moz
-
text
-
size
-
adjust
"
"
text
-
transform
"
"
transform
"
"
transform
-
box
"
"
transform
-
origin
"
"
perspective
-
origin
"
"
perspective
"
"
transform
-
style
"
"
backface
-
visibility
"
"
top
"
"
-
moz
-
top
-
layer
"
"
touch
-
action
"
"
transition
-
delay
"
"
transition
-
duration
"
"
transition
-
property
"
"
transition
-
timing
-
function
"
"
-
moz
-
user
-
focus
"
"
-
moz
-
user
-
input
"
"
-
moz
-
user
-
modify
"
"
-
moz
-
user
-
select
"
"
vertical
-
align
"
"
visibility
"
"
white
-
space
"
"
width
"
"
-
moz
-
window
-
dragging
"
"
-
moz
-
window
-
shadow
"
"
word
-
break
"
"
word
-
spacing
"
"
word
-
wrap
"
"
hyphens
"
"
writing
-
mode
"
"
z
-
index
"
"
-
moz
-
box
-
align
"
"
-
moz
-
box
-
direction
"
"
-
moz
-
box
-
flex
"
"
-
moz
-
box
-
orient
"
"
-
moz
-
box
-
pack
"
"
-
moz
-
box
-
ordinal
-
group
"
"
-
moz
-
stack
-
sizing
"
"
clip
-
path
"
"
clip
-
rule
"
"
color
-
interpolation
"
"
color
-
interpolation
-
filters
"
"
dominant
-
baseline
"
"
fill
"
"
fill
-
opacity
"
"
fill
-
rule
"
"
filter
"
"
flood
-
color
"
"
flood
-
opacity
"
"
image
-
rendering
"
"
lighting
-
color
"
"
marker
-
end
"
"
marker
-
mid
"
"
marker
-
start
"
"
mask
"
"
mask
-
type
"
"
shape
-
rendering
"
"
stop
-
color
"
"
stop
-
opacity
"
"
stroke
"
"
stroke
-
dasharray
"
"
stroke
-
dashoffset
"
"
stroke
-
linecap
"
"
stroke
-
linejoin
"
"
stroke
-
miterlimit
"
"
stroke
-
opacity
"
"
stroke
-
width
"
"
text
-
anchor
"
"
text
-
rendering
"
"
vector
-
effect
"
"
will
-
change
"
]
inherited
:
false
supports
:
2015
values
:
[
"
-
moz
-
all
"
"
-
moz
-
available
"
"
-
moz
-
block
-
height
"
"
-
moz
-
box
"
"
-
moz
-
calc
"
"
-
moz
-
center
"
"
-
moz
-
crisp
-
edges
"
"
-
moz
-
deck
"
"
-
moz
-
element
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
grid
"
"
-
moz
-
grid
-
group
"
"
-
moz
-
grid
-
line
"
"
-
moz
-
groupbox
"
"
-
moz
-
gtk
-
info
-
bar
"
"
-
moz
-
hidden
-
unscrollable
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
inline
-
box
"
"
-
moz
-
inline
-
grid
"
"
-
moz
-
inline
-
stack
"
"
-
moz
-
left
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
mac
-
disclosure
-
button
-
closed
"
"
-
moz
-
mac
-
disclosure
-
button
-
open
"
"
-
moz
-
mac
-
fullscreen
-
button
"
"
-
moz
-
mac
-
help
-
button
"
"
-
moz
-
mac
-
vibrancy
-
dark
"
"
-
moz
-
mac
-
vibrancy
-
light
"
"
-
moz
-
max
-
content
"
"
-
moz
-
middle
-
with
-
baseline
"
"
-
moz
-
min
-
content
"
"
-
moz
-
none
"
"
-
moz
-
popup
"
"
-
moz
-
pre
-
space
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
-
moz
-
right
"
"
-
moz
-
stack
"
"
-
moz
-
text
"
"
-
moz
-
use
-
text
-
color
"
"
-
moz
-
win
-
borderless
-
glass
"
"
-
moz
-
win
-
browsertabbar
-
toolbox
"
"
-
moz
-
win
-
communications
-
toolbox
"
"
-
moz
-
win
-
exclude
-
glass
"
"
-
moz
-
win
-
glass
"
"
-
moz
-
win
-
media
-
toolbox
"
"
-
moz
-
window
-
button
-
box
"
"
-
moz
-
window
-
button
-
box
-
maximized
"
"
-
moz
-
window
-
button
-
close
"
"
-
moz
-
window
-
button
-
maximize
"
"
-
moz
-
window
-
button
-
minimize
"
"
-
moz
-
window
-
button
-
restore
"
"
-
moz
-
window
-
frame
-
bottom
"
"
-
moz
-
window
-
frame
-
left
"
"
-
moz
-
window
-
frame
-
right
"
"
-
moz
-
window
-
titlebar
"
"
-
moz
-
window
-
titlebar
-
maximized
"
"
absolute
"
"
active
"
"
aliceblue
"
"
all
"
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
alpha
"
"
alphabetic
"
"
alternate
"
"
alternate
-
reverse
"
"
always
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
auto
"
"
avoid
"
"
azure
"
"
backwards
"
"
balance
"
"
baseline
"
"
beige
"
"
bevel
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
block
"
"
block
-
axis
"
"
blue
"
"
blueviolet
"
"
border
-
box
"
"
both
"
"
bottom
"
"
bottom
-
outside
"
"
break
-
all
"
"
break
-
word
"
"
brown
"
"
burlywood
"
"
butt
"
"
button
"
"
button
-
arrow
-
down
"
"
button
-
arrow
-
next
"
"
button
-
arrow
-
previous
"
"
button
-
arrow
-
up
"
"
button
-
bevel
"
"
button
-
focus
"
"
cadetblue
"
"
calc
"
"
capitalize
"
"
caret
"
"
center
"
"
central
"
"
chartreuse
"
"
checkbox
"
"
checkbox
-
container
"
"
checkbox
-
label
"
"
checkmenuitem
"
"
chocolate
"
"
clone
"
"
collapse
"
"
color
"
"
color
-
burn
"
"
color
-
dodge
"
"
column
"
"
column
-
reverse
"
"
condensed
"
"
contain
"
"
content
-
box
"
"
contents
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
cover
"
"
crimson
"
"
crispedges
"
"
cubic
-
bezier
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darken
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dialog
"
"
difference
"
"
dimgray
"
"
dimgrey
"
"
disabled
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
drag
"
"
dualbutton
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
element
"
"
elements
"
"
enabled
"
"
end
"
"
evenodd
"
"
exclusion
"
"
expanded
"
"
extra
-
condensed
"
"
extra
-
expanded
"
"
fill
"
"
fill
-
box
"
"
firebrick
"
"
fixed
"
"
flat
"
"
flex
"
"
floralwhite
"
"
forestgreen
"
"
forwards
"
"
fuchsia
"
"
full
-
width
"
"
gainsboro
"
"
geometricprecision
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
grid
"
"
groove
"
"
groupbox
"
"
hanging
"
"
hard
-
light
"
"
hidden
"
"
hide
"
"
honeydew
"
"
horizontal
"
"
horizontal
-
tb
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
hue
"
"
ideographic
"
"
ignore
"
"
inactive
"
"
indianred
"
"
indigo
"
"
infinite
"
"
inherit
"
"
initial
"
"
inline
"
"
inline
-
axis
"
"
inline
-
block
"
"
inline
-
end
"
"
inline
-
flex
"
"
inline
-
grid
"
"
inline
-
start
"
"
inline
-
table
"
"
inset
"
"
inside
"
"
isolate
"
"
italic
"
"
ivory
"
"
justify
"
"
keep
-
all
"
"
khaki
"
"
large
"
"
larger
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
layout
"
"
left
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lighten
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linear
"
"
linear
-
gradient
"
"
linearrgb
"
"
linen
"
"
list
-
item
"
"
listbox
"
"
listitem
"
"
local
"
"
lowercase
"
"
lr
"
"
lr
-
tb
"
"
luminance
"
"
luminosity
"
"
magenta
"
"
mandatory
"
"
manual
"
"
margin
-
box
"
"
maroon
"
"
mathematical
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
menuarrow
"
"
menubar
"
"
menucheckbox
"
"
menuimage
"
"
menuitem
"
"
menuitemtext
"
"
menulist
"
"
menulist
-
button
"
"
menulist
-
text
"
"
menulist
-
textfield
"
"
menupopup
"
"
menuradio
"
"
menuseparator
"
"
meterbar
"
"
meterchunk
"
"
middle
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
miter
"
"
mixed
"
"
moccasin
"
"
multiply
"
"
navajowhite
"
"
navy
"
"
no
-
change
"
"
no
-
drag
"
"
no
-
repeat
"
"
non
-
scaling
-
stroke
"
"
none
"
"
nonzero
"
"
normal
"
"
nowrap
"
"
number
-
input
"
"
oblique
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
optimizelegibility
"
"
optimizequality
"
"
optimizespeed
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
outside
"
"
over
"
"
overlay
"
"
padding
-
box
"
"
paint
"
"
painted
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
paused
"
"
peachpuff
"
"
peru
"
"
petite
-
caps
"
"
pink
"
"
plum
"
"
powderblue
"
"
pre
"
"
pre
-
line
"
"
pre
-
wrap
"
"
preserve
-
3d
"
"
progressbar
"
"
progressbar
-
vertical
"
"
progresschunk
"
"
progresschunk
-
vertical
"
"
proximity
"
"
purple
"
"
radial
-
gradient
"
"
radio
"
"
radio
-
container
"
"
radio
-
label
"
"
radiomenuitem
"
"
range
"
"
range
-
thumb
"
"
read
-
only
"
"
read
-
write
"
"
rebeccapurple
"
"
red
"
"
relative
"
"
repeat
"
"
repeat
-
x
"
"
repeat
-
y
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
reset
-
size
"
"
resizer
"
"
resizerpanel
"
"
reverse
"
"
rgb
"
"
rgba
"
"
ridge
"
"
right
"
"
rl
"
"
rl
-
tb
"
"
rosybrown
"
"
round
"
"
row
"
"
row
-
reverse
"
"
royalblue
"
"
ruby
"
"
ruby
-
base
"
"
ruby
-
base
-
container
"
"
ruby
-
text
"
"
ruby
-
text
-
container
"
"
running
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
saturation
"
"
scale
-
down
"
"
scale
-
horizontal
"
"
scale
-
vertical
"
"
scalethumb
-
horizontal
"
"
scalethumb
-
vertical
"
"
scalethumbend
"
"
scalethumbstart
"
"
scalethumbtick
"
"
screen
"
"
scroll
"
"
scrollbar
"
"
scrollbar
-
small
"
"
scrollbarbutton
-
down
"
"
scrollbarbutton
-
left
"
"
scrollbarbutton
-
right
"
"
scrollbarbutton
-
up
"
"
scrollbarthumb
-
horizontal
"
"
scrollbarthumb
-
vertical
"
"
scrollbartrack
-
horizontal
"
"
scrollbartrack
-
vertical
"
"
seagreen
"
"
searchfield
"
"
seashell
"
"
select
-
after
"
"
select
-
all
"
"
select
-
before
"
"
select
-
menu
"
"
select
-
same
"
"
semi
-
condensed
"
"
semi
-
expanded
"
"
separate
"
"
separator
"
"
show
"
"
sideways
"
"
sideways
-
lr
"
"
sideways
-
right
"
"
sideways
-
rl
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
slice
"
"
small
"
"
small
-
caps
"
"
smaller
"
"
smooth
"
"
snow
"
"
soft
-
light
"
"
solid
"
"
space
-
around
"
"
space
-
between
"
"
spinner
"
"
spinner
-
downbutton
"
"
spinner
-
textfield
"
"
spinner
-
upbutton
"
"
splitter
"
"
springgreen
"
"
square
"
"
srgb
"
"
start
"
"
static
"
"
statusbar
"
"
statusbarpanel
"
"
steelblue
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
sticky
"
"
stretch
"
"
stretch
-
to
-
fit
"
"
strict
"
"
stroke
"
"
style
"
"
sub
"
"
super
"
"
tab
"
"
tab
-
scroll
-
arrow
-
back
"
"
tab
-
scroll
-
arrow
-
forward
"
"
table
"
"
table
-
caption
"
"
table
-
cell
"
"
table
-
column
"
"
table
-
column
-
group
"
"
table
-
footer
-
group
"
"
table
-
header
-
group
"
"
table
-
row
"
"
table
-
row
-
group
"
"
tabpanel
"
"
tabpanels
"
"
tan
"
"
tb
"
"
tb
-
rl
"
"
teal
"
"
text
"
"
text
-
after
-
edge
"
"
text
-
before
-
edge
"
"
text
-
bottom
"
"
text
-
top
"
"
textfield
"
"
textfield
-
multiline
"
"
thick
"
"
thin
"
"
thistle
"
"
titling
-
caps
"
"
toggle
"
"
tomato
"
"
toolbar
"
"
toolbarbutton
"
"
toolbarbutton
-
dropdown
"
"
toolbargripper
"
"
toolbox
"
"
tooltip
"
"
top
"
"
top
-
outside
"
"
transparent
"
"
treeheader
"
"
treeheadercell
"
"
treeheadersortarrow
"
"
treeitem
"
"
treeline
"
"
treetwisty
"
"
treetwistyopen
"
"
treeview
"
"
tri
-
state
"
"
turquoise
"
"
ultra
-
condensed
"
"
ultra
-
expanded
"
"
under
"
"
unicase
"
"
unset
"
"
uppercase
"
"
upright
"
"
url
"
"
use
-
script
"
"
vertical
"
"
vertical
-
lr
"
"
vertical
-
rl
"
"
view
-
box
"
"
violet
"
"
visible
"
"
visiblefill
"
"
visiblepainted
"
"
visiblestroke
"
"
wavy
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
window
"
"
wrap
"
"
wrap
-
reverse
"
"
write
-
only
"
"
x
-
large
"
"
x
-
small
"
"
xx
-
large
"
"
xx
-
small
"
"
yellow
"
"
yellowgreen
"
]
}
"
animation
"
:
{
subproperties
:
[
"
animation
-
duration
"
"
animation
-
timing
-
function
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
play
-
state
"
"
animation
-
name
"
]
inherited
:
false
supports
:
1344
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
backwards
"
"
both
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
forwards
"
"
infinite
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
normal
"
"
paused
"
"
reverse
"
"
running
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
background
"
:
{
subproperties
:
[
"
background
-
color
"
"
background
-
image
"
"
background
-
repeat
"
"
background
-
attachment
"
"
background
-
position
"
"
background
-
clip
"
"
background
-
origin
"
"
background
-
size
"
]
inherited
:
false
supports
:
655
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
border
-
box
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
content
-
box
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
fixed
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linear
-
gradient
"
"
linen
"
"
local
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
no
-
repeat
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
padding
-
box
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
radial
-
gradient
"
"
rebeccapurple
"
"
red
"
"
repeat
"
"
repeat
-
x
"
"
repeat
-
y
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
scroll
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
url
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
"
:
{
subproperties
:
[
"
border
-
top
-
width
"
"
border
-
right
-
width
"
"
border
-
bottom
-
width
"
"
border
-
left
-
width
"
"
border
-
top
-
style
"
"
border
-
right
-
style
"
"
border
-
bottom
-
style
"
"
border
-
left
-
style
"
"
border
-
top
-
color
"
"
border
-
right
-
color
"
"
border
-
bottom
-
color
"
"
border
-
left
-
color
"
"
-
moz
-
border
-
top
-
colors
"
"
-
moz
-
border
-
right
-
colors
"
"
-
moz
-
border
-
bottom
-
colors
"
"
-
moz
-
border
-
left
-
colors
"
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linear
-
gradient
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
radial
-
gradient
"
"
rebeccapurple
"
"
red
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
url
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
end
"
:
{
subproperties
:
[
"
border
-
block
-
end
-
width
"
"
border
-
block
-
end
-
style
"
"
border
-
block
-
end
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
start
"
:
{
subproperties
:
[
"
border
-
block
-
start
-
width
"
"
border
-
block
-
start
-
style
"
"
border
-
block
-
start
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
bottom
"
:
{
subproperties
:
[
"
border
-
bottom
-
width
"
"
border
-
bottom
-
style
"
"
border
-
bottom
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
color
"
:
{
subproperties
:
[
"
border
-
top
-
color
"
"
border
-
right
-
color
"
"
border
-
bottom
-
color
"
"
border
-
left
-
color
"
]
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
image
"
:
{
subproperties
:
[
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
1675
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
border
-
inline
-
end
"
:
{
subproperties
:
[
"
border
-
inline
-
end
-
width
"
"
border
-
inline
-
end
-
style
"
"
border
-
inline
-
end
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
inline
-
start
"
:
{
subproperties
:
[
"
border
-
inline
-
start
-
width
"
"
border
-
inline
-
start
-
style
"
"
border
-
inline
-
start
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
left
"
:
{
subproperties
:
[
"
border
-
left
-
width
"
"
border
-
left
-
style
"
"
border
-
left
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
right
"
:
{
subproperties
:
[
"
border
-
right
-
width
"
"
border
-
right
-
style
"
"
border
-
right
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
style
"
:
{
subproperties
:
[
"
border
-
top
-
style
"
"
border
-
right
-
style
"
"
border
-
bottom
-
style
"
"
border
-
left
-
style
"
]
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
top
"
:
{
subproperties
:
[
"
border
-
top
-
width
"
"
border
-
top
-
style
"
"
border
-
top
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
width
"
:
{
subproperties
:
[
"
border
-
top
-
width
"
"
border
-
right
-
width
"
"
border
-
bottom
-
width
"
"
border
-
left
-
width
"
]
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
radius
"
:
{
subproperties
:
[
"
border
-
top
-
left
-
radius
"
"
border
-
top
-
right
-
radius
"
"
border
-
bottom
-
right
-
radius
"
"
border
-
bottom
-
left
-
radius
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
columns
"
:
{
subproperties
:
[
"
-
moz
-
column
-
count
"
"
-
moz
-
column
-
width
"
]
inherited
:
false
supports
:
1025
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
rule
"
:
{
subproperties
:
[
"
-
moz
-
column
-
rule
-
width
"
"
-
moz
-
column
-
rule
-
style
"
"
-
moz
-
column
-
rule
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
flex
"
:
{
subproperties
:
[
"
flex
-
grow
"
"
flex
-
shrink
"
"
flex
-
basis
"
]
inherited
:
false
supports
:
1027
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
flow
"
:
{
subproperties
:
[
"
flex
-
direction
"
"
flex
-
wrap
"
]
inherited
:
false
supports
:
0
values
:
[
"
column
"
"
column
-
reverse
"
"
inherit
"
"
initial
"
"
nowrap
"
"
row
"
"
row
-
reverse
"
"
unset
"
"
wrap
"
"
wrap
-
reverse
"
]
}
"
font
"
:
{
subproperties
:
[
"
font
-
family
"
"
font
-
style
"
"
font
-
weight
"
"
font
-
size
"
"
line
-
height
"
"
font
-
size
-
adjust
"
"
font
-
stretch
"
"
-
x
-
system
-
font
"
"
font
-
feature
-
settings
"
"
font
-
language
-
override
"
"
font
-
kerning
"
"
font
-
synthesis
"
"
font
-
variant
-
alternates
"
"
font
-
variant
-
caps
"
"
font
-
variant
-
east
-
asian
"
"
font
-
variant
-
ligatures
"
"
font
-
variant
-
numeric
"
"
font
-
variant
-
position
"
]
inherited
:
true
supports
:
1027
values
:
[
"
-
moz
-
block
-
height
"
"
-
moz
-
calc
"
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
auto
"
"
calc
"
"
condensed
"
"
expanded
"
"
extra
-
condensed
"
"
extra
-
expanded
"
"
inherit
"
"
initial
"
"
italic
"
"
large
"
"
larger
"
"
medium
"
"
none
"
"
normal
"
"
oblique
"
"
petite
-
caps
"
"
semi
-
condensed
"
"
semi
-
expanded
"
"
small
"
"
small
-
caps
"
"
smaller
"
"
sub
"
"
super
"
"
titling
-
caps
"
"
ultra
-
condensed
"
"
ultra
-
expanded
"
"
unicase
"
"
unset
"
"
x
-
large
"
"
x
-
small
"
"
xx
-
large
"
"
xx
-
small
"
]
}
"
font
-
variant
"
:
{
subproperties
:
[
"
font
-
variant
-
alternates
"
"
font
-
variant
-
caps
"
"
font
-
variant
-
east
-
asian
"
"
font
-
variant
-
ligatures
"
"
font
-
variant
-
numeric
"
"
font
-
variant
-
position
"
]
inherited
:
true
supports
:
0
values
:
[
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
inherit
"
"
initial
"
"
normal
"
"
petite
-
caps
"
"
small
-
caps
"
"
sub
"
"
super
"
"
titling
-
caps
"
"
unicase
"
"
unset
"
]
}
"
grid
-
template
"
:
{
subproperties
:
[
"
grid
-
template
-
areas
"
"
grid
-
template
-
columns
"
"
grid
-
template
-
rows
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
"
:
{
subproperties
:
[
"
grid
-
template
-
areas
"
"
grid
-
template
-
columns
"
"
grid
-
template
-
rows
"
"
grid
-
auto
-
flow
"
"
grid
-
auto
-
columns
"
"
grid
-
auto
-
rows
"
"
grid
-
column
-
gap
"
"
grid
-
row
-
gap
"
]
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
"
:
{
subproperties
:
[
"
grid
-
column
-
start
"
"
grid
-
column
-
end
"
]
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
"
:
{
subproperties
:
[
"
grid
-
row
-
start
"
"
grid
-
row
-
end
"
]
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
area
"
:
{
subproperties
:
[
"
grid
-
row
-
start
"
"
grid
-
column
-
start
"
"
grid
-
row
-
end
"
"
grid
-
column
-
end
"
]
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
gap
"
:
{
subproperties
:
[
"
grid
-
column
-
gap
"
"
grid
-
row
-
gap
"
]
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
list
-
style
"
:
{
subproperties
:
[
"
list
-
style
-
type
"
"
list
-
style
-
image
"
"
list
-
style
-
position
"
]
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
inside
"
"
none
"
"
outside
"
"
unset
"
"
url
"
]
}
"
margin
"
:
{
subproperties
:
[
"
margin
-
top
"
"
margin
-
right
"
"
margin
-
bottom
"
"
margin
-
left
"
]
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
outline
"
:
{
subproperties
:
[
"
outline
-
width
"
"
outline
-
style
"
"
outline
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
auto
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
overflow
"
:
{
subproperties
:
[
"
overflow
-
x
"
"
overflow
-
y
"
]
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
hidden
-
unscrollable
"
"
auto
"
"
hidden
"
"
inherit
"
"
initial
"
"
scroll
"
"
unset
"
"
visible
"
]
}
"
padding
"
:
{
subproperties
:
[
"
padding
-
top
"
"
padding
-
right
"
"
padding
-
bottom
"
"
padding
-
left
"
]
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
type
"
:
{
subproperties
:
[
"
scroll
-
snap
-
type
-
x
"
"
scroll
-
snap
-
type
-
y
"
]
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mandatory
"
"
none
"
"
proximity
"
"
unset
"
]
}
"
text
-
decoration
"
:
{
subproperties
:
[
"
text
-
decoration
-
color
"
"
text
-
decoration
-
line
"
"
text
-
decoration
-
style
"
]
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
none
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wavy
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
transition
"
:
{
subproperties
:
[
"
transition
-
property
"
"
transition
-
duration
"
"
transition
-
timing
-
function
"
"
transition
-
delay
"
]
inherited
:
false
supports
:
320
values
:
[
"
all
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
marker
"
:
{
subproperties
:
[
"
marker
-
start
"
"
marker
-
mid
"
"
marker
-
end
"
]
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
-
moz
-
transform
"
:
{
alias
:
true
subproperties
:
[
"
transform
"
]
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
transform
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
perspective
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
perspective
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
transform
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
flat
"
"
inherit
"
"
initial
"
"
preserve
-
3d
"
"
unset
"
]
}
"
-
moz
-
backface
-
visibility
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
-
moz
-
border
-
image
"
:
{
alias
:
true
subproperties
:
[
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
1675
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
-
moz
-
transition
"
:
{
alias
:
true
subproperties
:
[
"
transition
-
property
"
"
transition
-
duration
"
"
transition
-
timing
-
function
"
"
transition
-
delay
"
]
inherited
:
false
supports
:
320
values
:
[
"
all
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
transition
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
transition
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
transition
-
property
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
all
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
transition
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
animation
"
:
{
alias
:
true
subproperties
:
[
"
animation
-
duration
"
"
animation
-
timing
-
function
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
play
-
state
"
"
animation
-
name
"
]
inherited
:
false
supports
:
1344
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
backwards
"
"
both
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
forwards
"
"
infinite
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
normal
"
"
paused
"
"
reverse
"
"
running
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
animation
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
animation
-
direction
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
-
moz
-
animation
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
animation
-
fill
-
mode
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
backwards
"
"
both
"
"
forwards
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
animation
-
iteration
-
count
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
infinite
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
animation
-
name
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
animation
-
play
-
state
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
paused
"
"
running
"
"
unset
"
]
}
"
-
moz
-
animation
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
box
-
sizing
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
moz
-
font
-
feature
-
settings
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
font
-
language
-
override
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
-
moz
-
padding
-
end
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
padding
-
start
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
margin
-
end
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
margin
-
start
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
border
-
end
"
:
{
alias
:
true
subproperties
:
[
"
border
-
inline
-
end
-
width
"
"
border
-
inline
-
end
-
style
"
"
border
-
inline
-
end
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
end
-
color
"
:
{
alias
:
true
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
end
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
-
moz
-
border
-
end
-
width
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
-
moz
-
border
-
start
"
:
{
alias
:
true
subproperties
:
[
"
border
-
inline
-
start
-
width
"
"
border
-
inline
-
start
-
style
"
"
border
-
inline
-
start
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
start
-
color
"
:
{
alias
:
true
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
start
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
-
moz
-
border
-
start
-
width
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
-
moz
-
hyphens
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
manual
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
animation
"
:
{
alias
:
true
subproperties
:
[
"
animation
-
duration
"
"
animation
-
timing
-
function
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
play
-
state
"
"
animation
-
name
"
]
inherited
:
false
supports
:
1344
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
backwards
"
"
both
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
forwards
"
"
infinite
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
normal
"
"
paused
"
"
reverse
"
"
running
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
animation
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
animation
-
direction
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
-
webkit
-
animation
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
animation
-
fill
-
mode
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
backwards
"
"
both
"
"
forwards
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
animation
-
iteration
-
count
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
infinite
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
animation
-
name
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
animation
-
play
-
state
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
paused
"
"
running
"
"
unset
"
]
}
"
-
webkit
-
animation
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
text
-
size
-
adjust
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
transform
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transform
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transform
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
flat
"
"
inherit
"
"
initial
"
"
preserve
-
3d
"
"
unset
"
]
}
"
-
webkit
-
backface
-
visibility
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
-
webkit
-
perspective
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
perspective
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transition
"
:
{
alias
:
true
subproperties
:
[
"
transition
-
property
"
"
transition
-
duration
"
"
transition
-
timing
-
function
"
"
transition
-
delay
"
]
inherited
:
false
supports
:
320
values
:
[
"
all
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
transition
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transition
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transition
-
property
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
all
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
transition
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
border
-
radius
"
:
{
alias
:
true
subproperties
:
[
"
border
-
top
-
left
-
radius
"
"
border
-
top
-
right
-
radius
"
"
border
-
bottom
-
right
-
radius
"
"
border
-
bottom
-
left
-
radius
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
top
-
left
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
top
-
right
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
bottom
-
left
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
bottom
-
right
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
appearance
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
gtk
-
info
-
bar
"
"
-
moz
-
mac
-
disclosure
-
button
-
closed
"
"
-
moz
-
mac
-
disclosure
-
button
-
open
"
"
-
moz
-
mac
-
fullscreen
-
button
"
"
-
moz
-
mac
-
help
-
button
"
"
-
moz
-
mac
-
vibrancy
-
dark
"
"
-
moz
-
mac
-
vibrancy
-
light
"
"
-
moz
-
win
-
borderless
-
glass
"
"
-
moz
-
win
-
browsertabbar
-
toolbox
"
"
-
moz
-
win
-
communications
-
toolbox
"
"
-
moz
-
win
-
exclude
-
glass
"
"
-
moz
-
win
-
glass
"
"
-
moz
-
win
-
media
-
toolbox
"
"
-
moz
-
window
-
button
-
box
"
"
-
moz
-
window
-
button
-
box
-
maximized
"
"
-
moz
-
window
-
button
-
close
"
"
-
moz
-
window
-
button
-
maximize
"
"
-
moz
-
window
-
button
-
minimize
"
"
-
moz
-
window
-
button
-
restore
"
"
-
moz
-
window
-
frame
-
bottom
"
"
-
moz
-
window
-
frame
-
left
"
"
-
moz
-
window
-
frame
-
right
"
"
-
moz
-
window
-
titlebar
"
"
-
moz
-
window
-
titlebar
-
maximized
"
"
button
"
"
button
-
arrow
-
down
"
"
button
-
arrow
-
next
"
"
button
-
arrow
-
previous
"
"
button
-
arrow
-
up
"
"
button
-
bevel
"
"
button
-
focus
"
"
caret
"
"
checkbox
"
"
checkbox
-
container
"
"
checkbox
-
label
"
"
checkmenuitem
"
"
dialog
"
"
dualbutton
"
"
groupbox
"
"
inherit
"
"
initial
"
"
listbox
"
"
listitem
"
"
menuarrow
"
"
menubar
"
"
menucheckbox
"
"
menuimage
"
"
menuitem
"
"
menuitemtext
"
"
menulist
"
"
menulist
-
button
"
"
menulist
-
text
"
"
menulist
-
textfield
"
"
menupopup
"
"
menuradio
"
"
menuseparator
"
"
meterbar
"
"
meterchunk
"
"
none
"
"
number
-
input
"
"
progressbar
"
"
progressbar
-
vertical
"
"
progresschunk
"
"
progresschunk
-
vertical
"
"
radio
"
"
radio
-
container
"
"
radio
-
label
"
"
radiomenuitem
"
"
range
"
"
range
-
thumb
"
"
resizer
"
"
resizerpanel
"
"
scale
-
horizontal
"
"
scale
-
vertical
"
"
scalethumb
-
horizontal
"
"
scalethumb
-
vertical
"
"
scalethumbend
"
"
scalethumbstart
"
"
scalethumbtick
"
"
scrollbar
"
"
scrollbar
-
small
"
"
scrollbarbutton
-
down
"
"
scrollbarbutton
-
left
"
"
scrollbarbutton
-
right
"
"
scrollbarbutton
-
up
"
"
scrollbarthumb
-
horizontal
"
"
scrollbarthumb
-
vertical
"
"
scrollbartrack
-
horizontal
"
"
scrollbartrack
-
vertical
"
"
searchfield
"
"
separator
"
"
spinner
"
"
spinner
-
downbutton
"
"
spinner
-
textfield
"
"
spinner
-
upbutton
"
"
splitter
"
"
statusbar
"
"
statusbarpanel
"
"
tab
"
"
tab
-
scroll
-
arrow
-
back
"
"
tab
-
scroll
-
arrow
-
forward
"
"
tabpanel
"
"
tabpanels
"
"
textfield
"
"
textfield
-
multiline
"
"
toolbar
"
"
toolbarbutton
"
"
toolbarbutton
-
dropdown
"
"
toolbargripper
"
"
toolbox
"
"
tooltip
"
"
treeheader
"
"
treeheadercell
"
"
treeheadersortarrow
"
"
treeitem
"
"
treeline
"
"
treetwisty
"
"
treetwistyopen
"
"
treeview
"
"
unset
"
"
window
"
]
}
"
-
webkit
-
background
-
clip
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
webkit
-
background
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
webkit
-
background
-
size
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
"
:
{
alias
:
true
subproperties
:
[
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
1675
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
-
webkit
-
border
-
image
-
outset
"
:
{
alias
:
true
inherited
:
false
supports
:
1025
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
-
repeat
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
-
slice
"
:
{
alias
:
true
inherited
:
false
supports
:
1026
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
-
source
"
:
{
alias
:
true
inherited
:
false
supports
:
648
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
-
webkit
-
border
-
image
-
width
"
:
{
alias
:
true
inherited
:
false
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
shadow
"
:
{
alias
:
true
inherited
:
false
supports
:
5
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
sizing
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
webkit
-
box
-
flex
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
ordinal
-
group
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
align
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
pack
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
user
-
select
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
all
"
"
-
moz
-
none
"
"
-
moz
-
text
"
"
all
"
"
auto
"
"
element
"
"
elements
"
"
inherit
"
"
initial
"
"
none
"
"
text
"
"
toggle
"
"
tri
-
state
"
"
unset
"
]
}
}
;
module
.
exports
=
{
cssProperties
}
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
setImmediate
)
{
const
L10N
=
__webpack_require__
(
186
)
;
const
Services
=
{
}
;
Services
.
strings
=
{
createBundle
:
name
=
>
{
if
(
typeof
name
!
=
=
"
object
"
)
{
throw
new
Error
(
Cannot
implement
'
Services
.
strings
.
createBundle
'
.
Use
'
new
L10N
(
require
(
{
name
}
)
)
'
instead
or
call
this
with
the
return
value
of
a
require
like
'
Services
.
strings
.
createBundle
(
require
(
{
name
}
)
)
'
.
)
;
}
return
new
L10N
(
name
)
;
}
}
;
Services
.
appinfo
=
{
OS
:
'
Darwin
'
}
;
Services
.
telemetry
=
{
getHistogramById
(
)
{
return
{
add
(
)
{
}
}
;
}
}
;
Services
.
obs
=
{
addObserver
:
(
)
=
>
{
}
removeObserver
:
(
)
=
>
{
}
}
Services
.
prefs
=
__webpack_require__
(
187
)
;
Services
.
tm
=
{
currentThread
:
{
dispatch
:
(
cb
)
=
>
{
setImmediate
(
cb
)
;
}
}
mainThread
:
{
dispatch
:
(
cb
)
=
>
{
setImmediate
(
cb
)
;
}
}
}
;
Services
.
scriptloader
=
{
loadSubScript
:
(
url
target
charset
=
"
utf8
"
)
=
>
{
if
(
!
target
|
|
!
target
.
document
)
{
throw
new
Error
(
target
in
loadSubScript
does
not
have
a
document
.
)
;
}
return
new
Promise
(
resolve
=
>
{
let
script
=
target
.
document
.
createElement
(
"
script
"
)
;
script
.
src
=
url
;
script
.
onload
=
resolve
target
.
document
.
body
.
appendChild
(
script
)
;
}
)
;
}
}
;
module
.
exports
.
Services
=
Services
;
}
.
call
(
exports
__webpack_require__
(
184
)
.
setImmediate
)
)
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
setImmediate
clearImmediate
)
{
var
nextTick
=
__webpack_require__
(
185
)
.
nextTick
;
var
apply
=
Function
.
prototype
.
apply
;
var
slice
=
Array
.
prototype
.
slice
;
var
immediateIds
=
{
}
;
var
nextImmediateId
=
0
;
exports
.
setTimeout
=
function
(
)
{
return
new
Timeout
(
apply
.
call
(
setTimeout
window
arguments
)
clearTimeout
)
;
}
;
exports
.
setInterval
=
function
(
)
{
return
new
Timeout
(
apply
.
call
(
setInterval
window
arguments
)
clearInterval
)
;
}
;
exports
.
clearTimeout
=
exports
.
clearInterval
=
function
(
timeout
)
{
timeout
.
close
(
)
;
}
;
function
Timeout
(
id
clearFn
)
{
this
.
_id
=
id
;
this
.
_clearFn
=
clearFn
;
}
Timeout
.
prototype
.
unref
=
Timeout
.
prototype
.
ref
=
function
(
)
{
}
;
Timeout
.
prototype
.
close
=
function
(
)
{
this
.
_clearFn
.
call
(
window
this
.
_id
)
;
}
;
exports
.
enroll
=
function
(
item
msecs
)
{
clearTimeout
(
item
.
_idleTimeoutId
)
;
item
.
_idleTimeout
=
msecs
;
}
;
exports
.
unenroll
=
function
(
item
)
{
clearTimeout
(
item
.
_idleTimeoutId
)
;
item
.
_idleTimeout
=
-
1
;
}
;
exports
.
_unrefActive
=
exports
.
active
=
function
(
item
)
{
clearTimeout
(
item
.
_idleTimeoutId
)
;
var
msecs
=
item
.
_idleTimeout
;
if
(
msecs
>
=
0
)
{
item
.
_idleTimeoutId
=
setTimeout
(
function
onTimeout
(
)
{
if
(
item
.
_onTimeout
)
item
.
_onTimeout
(
)
;
}
msecs
)
;
}
}
;
exports
.
setImmediate
=
typeof
setImmediate
=
=
=
"
function
"
?
setImmediate
:
function
(
fn
)
{
var
id
=
nextImmediateId
+
+
;
var
args
=
arguments
.
length
<
2
?
false
:
slice
.
call
(
arguments
1
)
;
immediateIds
[
id
]
=
true
;
nextTick
(
function
onNextTick
(
)
{
if
(
immediateIds
[
id
]
)
{
if
(
args
)
{
fn
.
apply
(
null
args
)
;
}
else
{
fn
.
call
(
null
)
;
}
exports
.
clearImmediate
(
id
)
;
}
}
)
;
return
id
;
}
;
exports
.
clearImmediate
=
typeof
clearImmediate
=
=
=
"
function
"
?
clearImmediate
:
function
(
id
)
{
delete
immediateIds
[
id
]
;
}
;
}
.
call
(
exports
__webpack_require__
(
184
)
.
setImmediate
__webpack_require__
(
184
)
.
clearImmediate
)
)
}
function
(
module
exports
)
{
var
process
=
module
.
exports
=
{
}
;
var
cachedSetTimeout
;
var
cachedClearTimeout
;
(
function
(
)
{
try
{
cachedSetTimeout
=
setTimeout
;
}
catch
(
e
)
{
cachedSetTimeout
=
function
(
)
{
throw
new
Error
(
'
setTimeout
is
not
defined
'
)
;
}
}
try
{
cachedClearTimeout
=
clearTimeout
;
}
catch
(
e
)
{
cachedClearTimeout
=
function
(
)
{
throw
new
Error
(
'
clearTimeout
is
not
defined
'
)
;
}
}
}
(
)
)
var
queue
=
[
]
;
var
draining
=
false
;
var
currentQueue
;
var
queueIndex
=
-
1
;
function
cleanUpNextTick
(
)
{
if
(
!
draining
|
|
!
currentQueue
)
{
return
;
}
draining
=
false
;
if
(
currentQueue
.
length
)
{
queue
=
currentQueue
.
concat
(
queue
)
;
}
else
{
queueIndex
=
-
1
;
}
if
(
queue
.
length
)
{
drainQueue
(
)
;
}
}
function
drainQueue
(
)
{
if
(
draining
)
{
return
;
}
var
timeout
=
cachedSetTimeout
(
cleanUpNextTick
)
;
draining
=
true
;
var
len
=
queue
.
length
;
while
(
len
)
{
currentQueue
=
queue
;
queue
=
[
]
;
while
(
+
+
queueIndex
<
len
)
{
if
(
currentQueue
)
{
currentQueue
[
queueIndex
]
.
run
(
)
;
}
}
queueIndex
=
-
1
;
len
=
queue
.
length
;
}
currentQueue
=
null
;
draining
=
false
;
cachedClearTimeout
(
timeout
)
;
}
process
.
nextTick
=
function
(
fun
)
{
var
args
=
new
Array
(
arguments
.
length
-
1
)
;
if
(
arguments
.
length
>
1
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
}
queue
.
push
(
new
Item
(
fun
args
)
)
;
if
(
queue
.
length
=
=
=
1
&
&
!
draining
)
{
cachedSetTimeout
(
drainQueue
0
)
;
}
}
;
function
Item
(
fun
array
)
{
this
.
fun
=
fun
;
this
.
array
=
array
;
}
Item
.
prototype
.
run
=
function
(
)
{
this
.
fun
.
apply
(
null
this
.
array
)
;
}
;
process
.
title
=
'
browser
'
;
process
.
browser
=
true
;
process
.
env
=
{
}
;
process
.
argv
=
[
]
;
process
.
version
=
'
'
;
process
.
versions
=
{
}
;
function
noop
(
)
{
}
process
.
on
=
noop
;
process
.
addListener
=
noop
;
process
.
once
=
noop
;
process
.
off
=
noop
;
process
.
removeListener
=
noop
;
process
.
removeAllListeners
=
noop
;
process
.
emit
=
noop
;
process
.
binding
=
function
(
name
)
{
throw
new
Error
(
'
process
.
binding
is
not
supported
'
)
;
}
;
process
.
cwd
=
function
(
)
{
return
'
/
'
}
;
process
.
chdir
=
function
(
dir
)
{
throw
new
Error
(
'
process
.
chdir
is
not
supported
'
)
;
}
;
process
.
umask
=
function
(
)
{
return
0
;
}
;
}
function
(
module
exports
)
{
function
L10N
(
props
)
{
this
.
props
=
props
;
}
L10N
.
prototype
.
GetStringFromName
=
function
(
name
)
{
return
this
.
props
[
name
]
;
}
;
L10N
.
prototype
.
formatStringFromName
=
function
(
name
values
)
{
var
result
=
this
.
GetStringFromName
(
name
)
;
for
(
var
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
result
=
result
.
replace
(
/
%
S
/
values
[
i
]
)
;
}
return
result
;
}
;
module
.
exports
=
L10N
;
}
function
(
module
exports
__webpack_require__
)
{
let
DEFAULTS
=
__webpack_require__
(
188
)
;
let
storage
=
JSON
.
parse
(
JSON
.
stringify
(
DEFAULTS
)
)
;
const
PREF_INVALID
=
exports
.
PREF_INVALID
=
0
;
const
PREF_STRING
=
exports
.
PREF_STRING
=
32
;
const
PREF_INT
=
exports
.
PREF_INT
=
64
;
const
PREF_BOOL
=
exports
.
PREF_BOOL
=
128
;
function
findPref
(
pref
)
{
let
branchNames
=
pref
.
split
(
"
.
"
)
;
let
branch
=
storage
;
for
(
let
branchName
of
branchNames
)
{
branch
=
branch
[
branchName
]
;
if
(
!
branch
)
{
branch
=
{
}
;
}
}
return
branch
;
}
function
setPrefValue
(
pref
value
)
{
let
obj
=
findPref
(
pref
)
;
obj
.
value
=
value
;
}
function
getPrefValue
(
pref
)
{
return
findPref
(
pref
)
.
value
;
}
const
addObserver
=
exports
.
addObserver
=
function
(
domain
observer
holdWeak
)
{
console
.
log
(
"
TODO
implement
addObserver
"
)
;
}
;
const
removeObserver
=
exports
.
removeObserver
=
function
(
domain
observer
holdWeak
)
{
console
.
log
(
"
TODO
implement
removeObserver
"
)
;
}
;
const
resetPrefs
=
exports
.
resetPrefs
=
function
(
)
{
storage
=
JSON
.
parse
(
JSON
.
stringify
(
DEFAULTS
)
)
;
}
;
const
getPrefType
=
exports
.
getPrefType
=
function
(
pref
)
{
return
findPref
(
pref
)
.
type
;
}
;
const
setBoolPref
=
exports
.
setBoolPref
=
function
(
pref
value
)
{
if
(
typeof
value
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
Cannot
setBoolPref
without
a
boolean
.
"
)
;
}
if
(
getPrefType
(
pref
)
&
&
getPrefType
(
pref
)
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
"
Can
only
call
setBoolPref
on
boolean
type
prefs
.
"
)
;
}
setPrefValue
(
pref
value
)
;
}
;
exports
.
setCharPref
=
function
(
pref
value
)
{
if
(
typeof
value
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Cannot
setCharPref
without
a
string
.
"
)
;
}
if
(
getPrefType
(
pref
)
&
&
getPrefType
(
pref
)
!
=
=
PREF_STRING
)
{
throw
new
Error
(
"
Can
only
call
setCharPref
on
string
type
prefs
.
"
)
;
}
setPrefValue
(
pref
value
)
;
}
;
exports
.
setIntPref
=
function
(
pref
value
)
{
if
(
typeof
value
!
=
=
"
number
"
&
&
(
parseInt
(
value
)
!
=
=
value
)
)
{
throw
new
Error
(
"
Cannot
setCharPref
without
an
integer
.
"
)
;
}
if
(
getPrefType
(
pref
)
&
&
getPrefType
(
pref
)
!
=
=
PREF_INT
)
{
throw
new
Error
(
"
Can
only
call
setIntPref
on
number
type
prefs
.
"
)
;
}
setPrefValue
(
pref
value
)
;
}
;
exports
.
getBoolPref
=
function
(
pref
)
{
if
(
getPrefType
(
pref
)
!
=
=
PREF_BOOL
)
{
console
.
log
(
No
cached
boolean
pref
for
{
pref
}
)
;
return
undefined
;
}
return
getPrefValue
(
pref
)
;
}
;
exports
.
getCharPref
=
function
(
pref
)
{
if
(
getPrefType
(
pref
)
!
=
=
PREF_STRING
)
{
console
.
log
(
No
cached
char
pref
for
{
pref
}
)
;
return
undefined
;
}
return
getPrefValue
(
pref
)
;
}
;
exports
.
getIntPref
=
function
(
pref
)
{
if
(
getPrefType
(
pref
)
!
=
=
PREF_INT
)
{
console
.
log
(
No
cached
int
pref
for
{
pref
}
)
;
return
undefined
;
}
return
getPrefValue
(
pref
)
;
}
;
exports
.
getComplexValue
=
function
(
pref
)
{
return
{
data
:
'
'
}
}
;
exports
.
getBranch
=
function
(
pref
)
{
return
{
addObserver
:
(
)
=
>
{
}
removeObserver
:
(
)
=
>
{
}
}
}
;
exports
.
prefHasUserValue
=
function
(
pref
)
{
return
false
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
{
"
devtools
"
:
{
"
devedition
"
:
{
"
promo
"
:
{
"
shown
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
url
"
:
{
"
value
"
:
"
https
:
/
/
www
.
mozilla
.
org
/
firefox
/
developer
/
?
utm_source
=
firefox
-
dev
-
tools
&
utm_medium
=
firefox
-
browser
&
utm_content
=
betadoorhanger
"
"
type
"
:
32
}
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
errorconsole
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
toolbar
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
visible
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
webide
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
toolbox
"
:
{
"
footer
"
:
{
"
height
"
:
{
"
value
"
:
250
"
type
"
:
64
}
}
"
sidebar
"
:
{
"
width
"
:
{
"
value
"
:
500
"
type
"
:
64
}
}
"
host
"
:
{
"
value
"
:
"
bottom
"
"
type
"
:
32
}
"
previousHost
"
:
{
"
value
"
:
"
side
"
"
type
"
:
32
}
"
selectedTool
"
:
{
"
value
"
:
"
webconsole
"
"
type
"
:
32
}
"
toolbarSpec
"
:
{
"
value
"
:
"
[
\
"
splitconsole
\
"
\
"
paintflashing
toggle
\
"
\
"
tilt
toggle
\
"
\
"
scratchpad
\
"
\
"
resize
toggle
\
"
\
"
eyedropper
\
"
\
"
screenshot
-
-
fullpage
\
"
\
"
rulers
\
"
\
"
measure
\
"
]
"
"
type
"
:
32
}
"
sideEnabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
zoomValue
"
:
{
"
value
"
:
"
1
"
"
type
"
:
32
}
"
splitconsoleEnabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
splitconsoleHeight
"
:
{
"
value
"
:
100
"
type
"
:
64
}
}
"
inspector
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
activeSidebar
"
:
{
"
value
"
:
"
ruleview
"
"
type
"
:
32
}
"
remote
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
show_pseudo_elements
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
imagePreviewTooltipSize
"
:
{
"
value
"
:
300
"
type
"
:
64
}
"
showUserAgentStyles
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
showAllAnonymousContent
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
mdnDocsTooltip
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
}
"
defaultColorUnit
"
:
{
"
value
"
:
"
authored
"
"
type
"
:
32
}
"
debugger
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
workers
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
promise
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
memory
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
performance
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
ui
"
:
{
"
experimental
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
cache
"
:
{
"
disabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
serviceWorkers
"
:
{
"
testing
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
netmonitor
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
statistics
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
filters
"
:
{
"
value
"
:
"
[
\
"
all
\
"
]
"
"
type
"
:
32
}
"
har
"
:
{
"
defaultLogDir
"
:
{
"
value
"
:
"
"
"
type
"
:
32
}
"
defaultFileName
"
:
{
"
value
"
:
"
Archive
%
y
-
%
m
-
%
d
%
H
-
%
M
-
%
S
"
"
type
"
:
32
}
"
jsonp
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
jsonpCallback
"
:
{
"
value
"
:
"
"
"
type
"
:
32
}
"
includeResponseBodies
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
compress
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
forceExport
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
pageLoadedTimeout
"
:
{
"
value
"
:
1500
"
type
"
:
64
}
"
enableAutoExportToFile
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
tilt
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
intro_transition
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
outro_transition
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
scratchpad
"
:
{
"
recentFilesMax
"
:
{
"
value
"
:
10
"
type
"
:
64
}
"
lineNumbers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
wrapText
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
showTrailingSpace
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
editorFontSize
"
:
{
"
value
"
:
12
"
type
"
:
64
}
"
enableAutocompletion
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
storage
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
styleeditor
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
showMediaSidebar
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
mediaSidebarWidth
"
:
{
"
value
"
:
238
"
type
"
:
64
}
"
navSidebarWidth
"
:
{
"
value
"
:
245
"
type
"
:
64
}
"
transitions
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
shadereditor
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
canvasdebugger
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
webaudioeditor
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
inspectorWidth
"
:
{
"
value
"
:
300
"
type
"
:
64
}
}
"
webconsole
"
:
{
"
filter
"
:
{
"
network
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
networkinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
netwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
netxhr
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csserror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
cssparser
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csslog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
exception
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jswarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jslog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
error
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
warn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
info
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
log
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secerror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
serviceworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
sharedworkers
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
windowlessworkers
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
servererror
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverwarn
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverlog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
fontSize
"
:
{
"
value
"
:
0
"
type
"
:
64
}
"
inputHistoryCount
"
:
{
"
value
"
:
50
"
type
"
:
64
}
"
persistlog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
timestampMessages
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
browserconsole
"
:
{
"
filter
"
:
{
"
network
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
networkinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
netwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
netxhr
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csserror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
cssparser
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csslog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
exception
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jswarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jslog
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
error
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
warn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
info
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
log
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secerror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
serviceworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
sharedworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
windowlessworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
servererror
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverwarn
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverlog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
hud
"
:
{
"
loglimit
"
:
{
"
network
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
"
cssparser
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
"
exception
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
"
console
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
}
}
"
eyedropper
"
:
{
"
zoom
"
:
{
"
value
"
:
6
"
type
"
:
64
}
}
"
editor
"
:
{
"
tabsize
"
:
{
"
value
"
:
2
"
type
"
:
64
}
"
expandtab
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
keymap
"
:
{
"
value
"
:
"
default
"
"
type
"
:
32
}
"
autoclosebrackets
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
detectindentation
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
enableCodeFolding
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
autocomplete
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
fontinspector
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
telemetry
"
:
{
"
tools
"
:
{
"
opened
"
:
{
"
version
"
:
{
"
value
"
:
"
{
}
"
"
type
"
:
32
}
}
}
}
"
jsonview
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
}
}
function
(
module
exports
)
{
let
p
=
typeof
window
!
=
"
undefined
"
?
window
.
Promise
:
Promise
;
p
.
defer
=
function
defer
(
)
{
var
resolve
reject
;
var
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
module
.
exports
=
p
;
}
function
(
module
exports
)
{
}
function
(
module
exports
)
{
module
.
exports
=
{
AppConstants
:
{
}
}
;
}
function
(
module
exports
)
{
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
components
Cc
Ci
Cu
}
=
__webpack_require__
(
178
)
;
const
{
NetUtil
}
=
__webpack_require__
(
192
)
;
const
DevToolsUtils
=
__webpack_require__
(
177
)
;
const
gNSURLStore
=
new
Map
(
)
;
var
NetworkHelper
=
{
convertToUnicode
:
function
NH_convertToUnicode
(
aText
aCharset
)
{
let
conv
=
Cc
(
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
)
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
try
{
conv
.
charset
=
aCharset
|
|
"
UTF
-
8
"
;
return
conv
.
ConvertToUnicode
(
aText
)
;
}
catch
(
ex
)
{
return
aText
;
}
}
readAndConvertFromStream
:
function
NH_readAndConvertFromStream
(
aStream
aCharset
)
{
let
text
=
null
;
try
{
text
=
NetUtil
.
readInputStreamToString
(
aStream
aStream
.
available
(
)
)
return
this
.
convertToUnicode
(
text
aCharset
)
;
}
catch
(
err
)
{
return
text
;
}
}
readPostTextFromRequest
:
function
NH_readPostTextFromRequest
(
aRequest
aCharset
)
{
if
(
aRequest
instanceof
Ci
.
nsIUploadChannel
)
{
let
iStream
=
aRequest
.
uploadStream
;
let
isSeekableStream
=
false
;
if
(
iStream
instanceof
Ci
.
nsISeekableStream
)
{
isSeekableStream
=
true
;
}
let
prevOffset
;
if
(
isSeekableStream
)
{
prevOffset
=
iStream
.
tell
(
)
;
iStream
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
0
)
;
}
let
text
=
this
.
readAndConvertFromStream
(
iStream
aCharset
)
;
if
(
isSeekableStream
&
&
prevOffset
=
=
0
)
{
iStream
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
0
)
;
}
return
text
;
}
return
null
;
}
readPostTextFromPage
:
function
NH_readPostTextFromPage
(
aDocShell
aCharset
)
{
let
webNav
=
aDocShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
return
this
.
readPostTextFromPageViaWebNav
(
webNav
aCharset
)
;
}
readPostTextFromPageViaWebNav
:
function
NH_readPostTextFromPageViaWebNav
(
aWebNav
aCharset
)
{
if
(
aWebNav
instanceof
Ci
.
nsIWebPageDescriptor
)
{
let
descriptor
=
aWebNav
.
currentDescriptor
;
if
(
descriptor
instanceof
Ci
.
nsISHEntry
&
&
descriptor
.
postData
&
&
descriptor
instanceof
Ci
.
nsISeekableStream
)
{
descriptor
.
seek
(
NS_SEEK_SET
0
)
;
return
this
.
readAndConvertFromStream
(
descriptor
aCharset
)
;
}
}
return
null
;
}
getAppIdForRequest
:
function
NH_getAppIdForRequest
(
aRequest
)
{
try
{
return
this
.
getRequestLoadContext
(
aRequest
)
.
appId
;
}
catch
(
ex
)
{
}
return
null
;
}
getTopFrameForRequest
:
function
NH_getTopFrameForRequest
(
aRequest
)
{
try
{
return
this
.
getRequestLoadContext
(
aRequest
)
.
topFrameElement
;
}
catch
(
ex
)
{
}
return
null
;
}
getWindowForRequest
:
function
NH_getWindowForRequest
(
aRequest
)
{
try
{
return
this
.
getRequestLoadContext
(
aRequest
)
.
associatedWindow
;
}
catch
(
ex
)
{
}
return
null
;
}
getRequestLoadContext
:
function
NH_getRequestLoadContext
(
aRequest
)
{
try
{
return
aRequest
.
notificationCallbacks
.
getInterface
(
Ci
.
nsILoadContext
)
;
}
catch
(
ex
)
{
}
try
{
return
aRequest
.
loadGroup
.
notificationCallbacks
.
getInterface
(
Ci
.
nsILoadContext
)
;
}
catch
(
ex
)
{
}
return
null
;
}
isTopLevelLoad
:
function
(
aRequest
)
{
if
(
aRequest
instanceof
Ci
.
nsIChannel
)
{
let
loadInfo
=
aRequest
.
loadInfo
;
if
(
loadInfo
&
&
loadInfo
.
isTopLevelLoad
)
{
return
(
aRequest
.
loadFlags
&
Ci
.
nsIChannel
.
LOAD_DOCUMENT_URI
)
;
}
}
return
false
;
}
loadFromCache
:
function
NH_loadFromCache
(
aUrl
aCharset
aCallback
)
{
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
aUrl
loadUsingSystemPrincipal
:
true
}
)
;
channel
.
loadFlags
=
Ci
.
nsIRequest
.
LOAD_FROM_CACHE
|
Ci
.
nsICachingChannel
.
LOAD_ONLY_FROM_CACHE
|
Ci
.
nsICachingChannel
.
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
;
NetUtil
.
asyncFetch
(
channel
(
aInputStream
aStatusCode
aRequest
)
=
>
{
if
(
!
components
.
isSuccessCode
(
aStatusCode
)
)
{
aCallback
(
null
)
;
return
;
}
let
aChannel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
contentCharset
=
aChannel
.
contentCharset
|
|
aCharset
;
aCallback
(
this
.
readAndConvertFromStream
(
aInputStream
contentCharset
)
)
;
}
)
;
}
parseCookieHeader
:
function
NH_parseCookieHeader
(
aHeader
)
{
let
cookies
=
aHeader
.
split
(
"
;
"
)
;
let
result
=
[
]
;
cookies
.
forEach
(
function
(
aCookie
)
{
let
equal
=
aCookie
.
indexOf
(
"
=
"
)
;
let
name
=
aCookie
.
substr
(
0
equal
)
;
let
value
=
aCookie
.
substr
(
equal
+
1
)
;
result
.
push
(
{
name
:
unescape
(
name
.
trim
(
)
)
value
:
unescape
(
value
.
trim
(
)
)
}
)
;
}
)
;
return
result
;
}
parseSetCookieHeader
:
function
NH_parseSetCookieHeader
(
aHeader
)
{
let
rawCookies
=
aHeader
.
split
(
/
\
r
\
n
|
\
n
|
\
r
/
)
;
let
cookies
=
[
]
;
rawCookies
.
forEach
(
function
(
aCookie
)
{
let
equal
=
aCookie
.
indexOf
(
"
=
"
)
;
let
name
=
unescape
(
aCookie
.
substr
(
0
equal
)
.
trim
(
)
)
;
let
parts
=
aCookie
.
substr
(
equal
+
1
)
.
split
(
"
;
"
)
;
let
value
=
unescape
(
parts
.
shift
(
)
.
trim
(
)
)
;
let
cookie
=
{
name
:
name
value
:
value
}
;
parts
.
forEach
(
function
(
aPart
)
{
let
part
=
aPart
.
trim
(
)
;
if
(
part
.
toLowerCase
(
)
=
=
"
secure
"
)
{
cookie
.
secure
=
true
;
}
else
if
(
part
.
toLowerCase
(
)
=
=
"
httponly
"
)
{
cookie
.
httpOnly
=
true
;
}
else
if
(
part
.
indexOf
(
"
=
"
)
>
-
1
)
{
let
pair
=
part
.
split
(
"
=
"
)
;
pair
[
0
]
=
pair
[
0
]
.
toLowerCase
(
)
;
if
(
pair
[
0
]
=
=
"
path
"
|
|
pair
[
0
]
=
=
"
domain
"
)
{
cookie
[
pair
[
0
]
]
=
pair
[
1
]
;
}
else
if
(
pair
[
0
]
=
=
"
expires
"
)
{
try
{
pair
[
1
]
=
pair
[
1
]
.
replace
(
/
-
/
g
'
'
)
;
cookie
.
expires
=
new
Date
(
pair
[
1
]
)
.
toISOString
(
)
;
}
catch
(
ex
)
{
}
}
}
}
)
;
cookies
.
push
(
cookie
)
;
}
)
;
return
cookies
;
}
mimeCategoryMap
:
{
"
text
/
plain
"
:
"
txt
"
"
text
/
html
"
:
"
html
"
"
text
/
xml
"
:
"
xml
"
"
text
/
xsl
"
:
"
txt
"
"
text
/
xul
"
:
"
txt
"
"
text
/
css
"
:
"
css
"
"
text
/
sgml
"
:
"
txt
"
"
text
/
rtf
"
:
"
txt
"
"
text
/
x
-
setext
"
:
"
txt
"
"
text
/
richtext
"
:
"
txt
"
"
text
/
javascript
"
:
"
js
"
"
text
/
jscript
"
:
"
txt
"
"
text
/
tab
-
separated
-
values
"
:
"
txt
"
"
text
/
rdf
"
:
"
txt
"
"
text
/
xif
"
:
"
txt
"
"
text
/
ecmascript
"
:
"
js
"
"
text
/
vnd
.
curl
"
:
"
txt
"
"
text
/
x
-
json
"
:
"
json
"
"
text
/
x
-
js
"
:
"
txt
"
"
text
/
js
"
:
"
txt
"
"
text
/
vbscript
"
:
"
txt
"
"
view
-
source
"
:
"
txt
"
"
view
-
fragment
"
:
"
txt
"
"
application
/
xml
"
:
"
xml
"
"
application
/
xhtml
+
xml
"
:
"
xml
"
"
application
/
atom
+
xml
"
:
"
xml
"
"
application
/
rss
+
xml
"
:
"
xml
"
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
:
"
xml
"
"
application
/
vnd
.
mozilla
.
xul
+
xml
"
:
"
xml
"
"
application
/
javascript
"
:
"
js
"
"
application
/
x
-
javascript
"
:
"
js
"
"
application
/
x
-
httpd
-
php
"
:
"
txt
"
"
application
/
rdf
+
xml
"
:
"
xml
"
"
application
/
ecmascript
"
:
"
js
"
"
application
/
http
-
index
-
format
"
:
"
txt
"
"
application
/
json
"
:
"
json
"
"
application
/
x
-
js
"
:
"
txt
"
"
multipart
/
mixed
"
:
"
txt
"
"
multipart
/
x
-
mixed
-
replace
"
:
"
txt
"
"
image
/
svg
+
xml
"
:
"
svg
"
"
application
/
octet
-
stream
"
:
"
bin
"
"
image
/
jpeg
"
:
"
image
"
"
image
/
jpg
"
:
"
image
"
"
image
/
gif
"
:
"
image
"
"
image
/
png
"
:
"
image
"
"
image
/
bmp
"
:
"
image
"
"
application
/
x
-
shockwave
-
flash
"
:
"
flash
"
"
video
/
x
-
flv
"
:
"
flash
"
"
audio
/
mpeg3
"
:
"
media
"
"
audio
/
x
-
mpeg
-
3
"
:
"
media
"
"
video
/
mpeg
"
:
"
media
"
"
video
/
x
-
mpeg
"
:
"
media
"
"
audio
/
ogg
"
:
"
media
"
"
application
/
ogg
"
:
"
media
"
"
application
/
x
-
ogg
"
:
"
media
"
"
application
/
x
-
midi
"
:
"
media
"
"
audio
/
midi
"
:
"
media
"
"
audio
/
x
-
mid
"
:
"
media
"
"
audio
/
x
-
midi
"
:
"
media
"
"
music
/
crescendo
"
:
"
media
"
"
audio
/
wav
"
:
"
media
"
"
audio
/
x
-
wav
"
:
"
media
"
"
text
/
json
"
:
"
json
"
"
application
/
x
-
json
"
:
"
json
"
"
application
/
json
-
rpc
"
:
"
json
"
"
application
/
x
-
web
-
app
-
manifest
+
json
"
:
"
json
"
"
application
/
manifest
+
json
"
:
"
json
"
}
isTextMimeType
:
function
NH_isTextMimeType
(
aMimeType
)
{
if
(
aMimeType
.
indexOf
(
"
text
/
"
)
=
=
0
)
{
return
true
;
}
if
(
/
^
application
\
/
\
w
+
(
?
:
[
\
.
-
]
\
w
+
)
*
(
?
:
\
+
xml
|
[
-
+
]
json
)
/
.
test
(
aMimeType
)
)
{
return
true
;
}
let
category
=
this
.
mimeCategoryMap
[
aMimeType
]
|
|
null
;
switch
(
category
)
{
case
"
txt
"
:
case
"
js
"
:
case
"
json
"
:
case
"
css
"
:
case
"
html
"
:
case
"
svg
"
:
case
"
xml
"
:
return
true
;
default
:
return
false
;
}
}
parseSecurityInfo
:
function
NH_parseSecurityInfo
(
securityInfo
httpActivity
)
{
const
info
=
{
state
:
"
insecure
"
}
;
if
(
!
securityInfo
)
{
return
info
;
}
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
securityInfo
.
QueryInterface
(
Ci
.
nsISSLStatusProvider
)
;
const
wpl
=
Ci
.
nsIWebProgressListener
;
const
NSSErrorsService
=
Cc
[
'
mozilla
.
org
/
nss_errors_service
;
1
'
]
.
getService
(
Ci
.
nsINSSErrorsService
)
;
const
SSLStatus
=
securityInfo
.
SSLStatus
;
if
(
!
NSSErrorsService
.
isNSSErrorCode
(
securityInfo
.
errorCode
)
)
{
const
state
=
securityInfo
.
securityState
;
let
uri
=
null
;
if
(
httpActivity
.
channel
&
&
httpActivity
.
channel
.
URI
)
{
uri
=
httpActivity
.
channel
.
URI
;
}
if
(
uri
&
&
!
uri
.
schemeIs
(
"
https
"
)
&
&
!
uri
.
schemeIs
(
"
wss
"
)
)
{
info
.
state
=
"
insecure
"
;
}
else
if
(
state
&
wpl
.
STATE_IS_SECURE
)
{
info
.
state
=
"
secure
"
;
}
else
if
(
state
&
wpl
.
STATE_IS_BROKEN
)
{
info
.
state
=
"
weak
"
;
info
.
weaknessReasons
=
this
.
getReasonsForWeakness
(
state
)
;
}
else
if
(
state
&
wpl
.
STATE_IS_INSECURE
)
{
return
info
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseSecurityInfo
"
"
Security
state
"
+
state
+
"
has
no
known
STATE_IS_
*
flags
.
"
)
;
return
info
;
}
info
.
cipherSuite
=
SSLStatus
.
cipherName
;
info
.
protocolVersion
=
this
.
formatSecurityProtocol
(
SSLStatus
.
protocolVersion
)
;
info
.
cert
=
this
.
parseCertificateInfo
(
SSLStatus
.
serverCert
)
;
if
(
httpActivity
.
hostname
)
{
const
sss
=
Cc
(
"
mozilla
.
org
/
ssservice
;
1
"
)
.
getService
(
Ci
.
nsISiteSecurityService
)
;
let
flags
=
(
httpActivity
.
private
)
?
Ci
.
nsISocketProvider
.
NO_PERMANENT_STORAGE
:
0
;
let
host
=
httpActivity
.
hostname
;
info
.
hsts
=
sss
.
isSecureHost
(
sss
.
HEADER_HSTS
host
flags
)
;
info
.
hpkp
=
sss
.
isSecureHost
(
sss
.
HEADER_HPKP
host
flags
)
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseSecurityInfo
"
"
Could
not
get
HSTS
/
HPKP
status
as
hostname
is
not
available
.
"
)
;
info
.
hsts
=
false
;
info
.
hpkp
=
false
;
}
}
else
{
info
.
state
=
"
broken
"
;
info
.
errorMessage
=
securityInfo
.
errorMessage
;
}
return
info
;
}
parseCertificateInfo
:
function
NH_parseCertifificateInfo
(
cert
)
{
let
info
=
{
}
;
if
(
cert
)
{
info
.
subject
=
{
commonName
:
cert
.
commonName
organization
:
cert
.
organization
organizationalUnit
:
cert
.
organizationalUnit
}
;
info
.
issuer
=
{
commonName
:
cert
.
issuerCommonName
organization
:
cert
.
issuerOrganization
organizationUnit
:
cert
.
issuerOrganizationUnit
}
;
info
.
validity
=
{
start
:
cert
.
validity
.
notBeforeLocalDay
end
:
cert
.
validity
.
notAfterLocalDay
}
;
info
.
fingerprint
=
{
sha1
:
cert
.
sha1Fingerprint
sha256
:
cert
.
sha256Fingerprint
}
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseCertificateInfo
"
"
Secure
connection
established
without
certificate
.
"
)
;
}
return
info
;
}
formatSecurityProtocol
:
function
NH_formatSecurityProtocol
(
version
)
{
switch
(
version
)
{
case
Ci
.
nsISSLStatus
.
TLS_VERSION_1
:
return
"
TLSv1
"
;
case
Ci
.
nsISSLStatus
.
TLS_VERSION_1_1
:
return
"
TLSv1
.
1
"
;
case
Ci
.
nsISSLStatus
.
TLS_VERSION_1_2
:
return
"
TLSv1
.
2
"
;
default
:
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
formatSecurityProtocol
"
"
protocolVersion
"
+
version
+
"
is
unknown
.
"
)
;
return
"
Unknown
"
;
}
}
getReasonsForWeakness
:
function
NH_getReasonsForWeakness
(
state
)
{
const
wpl
=
Ci
.
nsIWebProgressListener
;
let
reasons
=
[
]
;
if
(
state
&
wpl
.
STATE_IS_BROKEN
)
{
let
isCipher
=
state
&
wpl
.
STATE_USES_WEAK_CRYPTO
;
if
(
isCipher
)
{
reasons
.
push
(
"
cipher
"
)
;
}
if
(
!
isCipher
)
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
getReasonsForWeakness
"
"
STATE_IS_BROKEN
without
a
known
reason
.
Full
state
was
:
"
+
state
)
;
}
}
return
reasons
;
}
parseQueryString
:
function
(
aQueryString
)
{
if
(
!
aQueryString
)
{
return
;
}
let
paramsArray
=
aQueryString
.
replace
(
/
^
[
?
&
]
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
let
param
=
e
.
split
(
"
=
"
)
;
return
{
name
:
param
[
0
]
?
NetworkHelper
.
convertToUnicode
(
unescape
(
param
[
0
]
)
)
:
"
"
value
:
param
[
1
]
?
NetworkHelper
.
convertToUnicode
(
unescape
(
param
[
1
]
)
)
:
"
"
}
}
)
;
return
paramsArray
;
}
nsIURL
:
function
(
aUrl
aStore
=
gNSURLStore
)
{
if
(
aStore
.
has
(
aUrl
)
)
{
return
aStore
.
get
(
aUrl
)
;
}
let
uri
=
Services
.
io
.
newURI
(
aUrl
null
null
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
aStore
.
set
(
aUrl
uri
)
;
return
uri
;
}
}
;
for
(
let
prop
of
Object
.
getOwnPropertyNames
(
NetworkHelper
)
)
{
exports
[
prop
]
=
NetworkHelper
[
prop
]
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
196
)
;
var
isDevelopment
=
_require
.
isDevelopment
;
function
debugGlobal
(
field
value
)
{
if
(
!
isDevelopment
(
)
)
{
return
;
}
window
[
field
]
=
value
;
}
function
injectGlobals
(
_ref
)
{
var
store
=
_ref
.
store
;
debugGlobal
(
"
store
"
store
)
;
debugGlobal
(
"
injectDebuggee
"
__webpack_require__
(
244
)
)
;
debugGlobal
(
"
serializeStore
"
(
)
=
>
{
return
JSON
.
parse
(
JSON
.
stringify
(
store
.
getState
(
)
)
)
;
}
)
;
}
module
.
exports
=
{
debugGlobal
injectGlobals
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
feature
=
__webpack_require__
(
197
)
;
module
.
exports
=
feature
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
pick
=
__webpack_require__
(
198
)
;
var
config
=
void
0
;
function
getValue
(
key
)
{
return
pick
(
config
key
)
;
}
var
isEnabled
=
getValue
;
function
isDevelopment
(
)
{
return
(
"
production
"
)
!
=
=
"
production
"
;
}
function
isFirefoxPanel
(
)
{
return
(
"
firefox
-
panel
"
)
=
=
"
firefox
-
panel
"
;
}
function
isFirefox
(
)
{
return
(
/
firefox
/
i
.
test
(
navigator
.
userAgent
)
)
;
}
function
setConfig
(
value
)
{
config
=
value
;
}
function
getConfig
(
)
{
return
config
;
}
module
.
exports
=
{
isEnabled
getValue
isDevelopment
isFirefoxPanel
isFirefox
getConfig
setConfig
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseGet
=
__webpack_require__
(
199
)
;
function
get
(
object
path
defaultValue
)
{
var
result
=
object
=
=
null
?
undefined
:
baseGet
(
object
path
)
;
return
result
=
=
=
undefined
?
defaultValue
:
result
;
}
module
.
exports
=
get
;
}
function
(
module
exports
__webpack_require__
)
{
var
castPath
=
__webpack_require__
(
200
)
isKey
=
__webpack_require__
(
242
)
toKey
=
__webpack_require__
(
243
)
;
function
baseGet
(
object
path
)
{
path
=
isKey
(
path
object
)
?
[
path
]
:
castPath
(
path
)
;
var
index
=
0
length
=
path
.
length
;
while
(
object
!
=
null
&
&
index
<
length
)
{
object
=
object
[
toKey
(
path
[
index
+
+
]
)
]
;
}
return
(
index
&
&
index
=
=
length
)
?
object
:
undefined
;
}
module
.
exports
=
baseGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
201
)
stringToPath
=
__webpack_require__
(
202
)
;
function
castPath
(
value
)
{
return
isArray
(
value
)
?
value
:
stringToPath
(
value
)
;
}
module
.
exports
=
castPath
;
}
function
(
module
exports
)
{
var
isArray
=
Array
.
isArray
;
module
.
exports
=
isArray
;
}
function
(
module
exports
__webpack_require__
)
{
var
memoize
=
__webpack_require__
(
203
)
toString
=
__webpack_require__
(
238
)
;
var
rePropName
=
/
[
^
.
[
\
]
]
+
|
\
[
(
?
:
(
-
?
\
d
+
(
?
:
\
.
\
d
+
)
?
)
|
(
[
"
'
]
)
(
(
?
:
(
?
!
\
2
)
[
^
\
\
]
|
\
\
.
)
*
?
)
\
2
)
\
]
|
(
?
=
(
\
.
|
\
[
\
]
)
(
?
:
\
4
|
)
)
/
g
;
var
reEscapeChar
=
/
\
\
(
\
\
)
?
/
g
;
var
stringToPath
=
memoize
(
function
(
string
)
{
var
result
=
[
]
;
toString
(
string
)
.
replace
(
rePropName
function
(
match
number
quote
string
)
{
result
.
push
(
quote
?
string
.
replace
(
reEscapeChar
'
1
'
)
:
(
number
|
|
match
)
)
;
}
)
;
return
result
;
}
)
;
module
.
exports
=
stringToPath
;
}
function
(
module
exports
__webpack_require__
)
{
var
MapCache
=
__webpack_require__
(
204
)
;
var
FUNC_ERROR_TEXT
=
'
Expected
a
function
'
;
function
memoize
(
func
resolver
)
{
if
(
typeof
func
!
=
'
function
'
|
|
(
resolver
&
&
typeof
resolver
!
=
'
function
'
)
)
{
throw
new
TypeError
(
FUNC_ERROR_TEXT
)
;
}
var
memoized
=
function
(
)
{
var
args
=
arguments
key
=
resolver
?
resolver
.
apply
(
this
args
)
:
args
[
0
]
cache
=
memoized
.
cache
;
if
(
cache
.
has
(
key
)
)
{
return
cache
.
get
(
key
)
;
}
var
result
=
func
.
apply
(
this
args
)
;
memoized
.
cache
=
cache
.
set
(
key
result
)
;
return
result
;
}
;
memoized
.
cache
=
new
(
memoize
.
Cache
|
|
MapCache
)
;
return
memoized
;
}
memoize
.
Cache
=
MapCache
;
module
.
exports
=
memoize
;
}
function
(
module
exports
__webpack_require__
)
{
var
mapCacheClear
=
__webpack_require__
(
205
)
mapCacheDelete
=
__webpack_require__
(
232
)
mapCacheGet
=
__webpack_require__
(
235
)
mapCacheHas
=
__webpack_require__
(
236
)
mapCacheSet
=
__webpack_require__
(
237
)
;
function
MapCache
(
entries
)
{
var
index
=
-
1
length
=
entries
?
entries
.
length
:
0
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
MapCache
.
prototype
.
clear
=
mapCacheClear
;
MapCache
.
prototype
[
'
delete
'
]
=
mapCacheDelete
;
MapCache
.
prototype
.
get
=
mapCacheGet
;
MapCache
.
prototype
.
has
=
mapCacheHas
;
MapCache
.
prototype
.
set
=
mapCacheSet
;
module
.
exports
=
MapCache
;
}
function
(
module
exports
__webpack_require__
)
{
var
Hash
=
__webpack_require__
(
206
)
ListCache
=
__webpack_require__
(
223
)
Map
=
__webpack_require__
(
231
)
;
function
mapCacheClear
(
)
{
this
.
__data__
=
{
'
hash
'
:
new
Hash
'
map
'
:
new
(
Map
|
|
ListCache
)
'
string
'
:
new
Hash
}
;
}
module
.
exports
=
mapCacheClear
;
}
function
(
module
exports
__webpack_require__
)
{
var
hashClear
=
__webpack_require__
(
207
)
hashDelete
=
__webpack_require__
(
219
)
hashGet
=
__webpack_require__
(
220
)
hashHas
=
__webpack_require__
(
221
)
hashSet
=
__webpack_require__
(
222
)
;
function
Hash
(
entries
)
{
var
index
=
-
1
length
=
entries
?
entries
.
length
:
0
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
Hash
.
prototype
.
clear
=
hashClear
;
Hash
.
prototype
[
'
delete
'
]
=
hashDelete
;
Hash
.
prototype
.
get
=
hashGet
;
Hash
.
prototype
.
has
=
hashHas
;
Hash
.
prototype
.
set
=
hashSet
;
module
.
exports
=
Hash
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
208
)
;
function
hashClear
(
)
{
this
.
__data__
=
nativeCreate
?
nativeCreate
(
null
)
:
{
}
;
}
module
.
exports
=
hashClear
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
209
)
;
var
nativeCreate
=
getNative
(
Object
'
create
'
)
;
module
.
exports
=
nativeCreate
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseIsNative
=
__webpack_require__
(
210
)
getValue
=
__webpack_require__
(
218
)
;
function
getNative
(
object
key
)
{
var
value
=
getValue
(
object
key
)
;
return
baseIsNative
(
value
)
?
value
:
undefined
;
}
module
.
exports
=
getNative
;
}
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
211
)
isHostObject
=
__webpack_require__
(
6
)
isMasked
=
__webpack_require__
(
213
)
isObject
=
__webpack_require__
(
212
)
toSource
=
__webpack_require__
(
217
)
;
var
reRegExpChar
=
/
[
\
\
^
.
*
+
?
(
)
[
\
]
{
}
|
]
/
g
;
var
reIsHostCtor
=
/
^
\
[
object
.
+
?
Constructor
\
]
/
;
var
objectProto
=
Object
.
prototype
;
var
funcToString
=
Function
.
prototype
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
reIsNative
=
RegExp
(
'
^
'
+
funcToString
.
call
(
hasOwnProperty
)
.
replace
(
reRegExpChar
'
\
\
&
'
)
.
replace
(
/
hasOwnProperty
|
(
function
)
.
*
?
(
?
=
\
\
\
(
)
|
for
.
+
?
(
?
=
\
\
\
]
)
/
g
'
1
.
*
?
'
)
+
'
'
)
;
function
baseIsNative
(
value
)
{
if
(
!
isObject
(
value
)
|
|
isMasked
(
value
)
)
{
return
false
;
}
var
pattern
=
(
isFunction
(
value
)
|
|
isHostObject
(
value
)
)
?
reIsNative
:
reIsHostCtor
;
return
pattern
.
test
(
toSource
(
value
)
)
;
}
module
.
exports
=
baseIsNative
;
}
function
(
module
exports
__webpack_require__
)
{
var
isObject
=
__webpack_require__
(
212
)
;
var
funcTag
=
'
[
object
Function
]
'
genTag
=
'
[
object
GeneratorFunction
]
'
;
var
objectProto
=
Object
.
prototype
;
var
objectToString
=
objectProto
.
toString
;
function
isFunction
(
value
)
{
var
tag
=
isObject
(
value
)
?
objectToString
.
call
(
value
)
:
'
'
;
return
tag
=
=
funcTag
|
|
tag
=
=
genTag
;
}
module
.
exports
=
isFunction
;
}
function
(
module
exports
)
{
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
module
.
exports
=
isObject
;
}
function
(
module
exports
__webpack_require__
)
{
var
coreJsData
=
__webpack_require__
(
214
)
;
var
maskSrcKey
=
(
function
(
)
{
var
uid
=
/
[
^
.
]
+
/
.
exec
(
coreJsData
&
&
coreJsData
.
keys
&
&
coreJsData
.
keys
.
IE_PROTO
|
|
'
'
)
;
return
uid
?
(
'
Symbol
(
src
)
_1
.
'
+
uid
)
:
'
'
;
}
(
)
)
;
function
isMasked
(
func
)
{
return
!
!
maskSrcKey
&
&
(
maskSrcKey
in
func
)
;
}
module
.
exports
=
isMasked
;
}
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
215
)
;
var
coreJsData
=
root
[
'
__core
-
js_shared__
'
]
;
module
.
exports
=
coreJsData
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
)
{
var
checkGlobal
=
__webpack_require__
(
216
)
;
var
freeGlobal
=
checkGlobal
(
typeof
global
=
=
'
object
'
&
&
global
)
;
var
freeSelf
=
checkGlobal
(
typeof
self
=
=
'
object
'
&
&
self
)
;
var
thisGlobal
=
checkGlobal
(
typeof
this
=
=
'
object
'
&
&
this
)
;
var
root
=
freeGlobal
|
|
freeSelf
|
|
thisGlobal
|
|
Function
(
'
return
this
'
)
(
)
;
module
.
exports
=
root
;
}
.
call
(
exports
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
)
{
function
checkGlobal
(
value
)
{
return
(
value
&
&
value
.
Object
=
=
=
Object
)
?
value
:
null
;
}
module
.
exports
=
checkGlobal
;
}
function
(
module
exports
)
{
var
funcToString
=
Function
.
prototype
.
toString
;
function
toSource
(
func
)
{
if
(
func
!
=
null
)
{
try
{
return
funcToString
.
call
(
func
)
;
}
catch
(
e
)
{
}
try
{
return
(
func
+
'
'
)
;
}
catch
(
e
)
{
}
}
return
'
'
;
}
module
.
exports
=
toSource
;
}
function
(
module
exports
)
{
function
getValue
(
object
key
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
module
.
exports
=
getValue
;
}
function
(
module
exports
)
{
function
hashDelete
(
key
)
{
return
this
.
has
(
key
)
&
&
delete
this
.
__data__
[
key
]
;
}
module
.
exports
=
hashDelete
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
208
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashGet
(
key
)
{
var
data
=
this
.
__data__
;
if
(
nativeCreate
)
{
var
result
=
data
[
key
]
;
return
result
=
=
=
HASH_UNDEFINED
?
undefined
:
result
;
}
return
hasOwnProperty
.
call
(
data
key
)
?
data
[
key
]
:
undefined
;
}
module
.
exports
=
hashGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
208
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashHas
(
key
)
{
var
data
=
this
.
__data__
;
return
nativeCreate
?
data
[
key
]
!
=
=
undefined
:
hasOwnProperty
.
call
(
data
key
)
;
}
module
.
exports
=
hashHas
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
208
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
function
hashSet
(
key
value
)
{
var
data
=
this
.
__data__
;
data
[
key
]
=
(
nativeCreate
&
&
value
=
=
=
undefined
)
?
HASH_UNDEFINED
:
value
;
return
this
;
}
module
.
exports
=
hashSet
;
}
function
(
module
exports
__webpack_require__
)
{
var
listCacheClear
=
__webpack_require__
(
224
)
listCacheDelete
=
__webpack_require__
(
225
)
listCacheGet
=
__webpack_require__
(
228
)
listCacheHas
=
__webpack_require__
(
229
)
listCacheSet
=
__webpack_require__
(
230
)
;
function
ListCache
(
entries
)
{
var
index
=
-
1
length
=
entries
?
entries
.
length
:
0
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
ListCache
.
prototype
.
clear
=
listCacheClear
;
ListCache
.
prototype
[
'
delete
'
]
=
listCacheDelete
;
ListCache
.
prototype
.
get
=
listCacheGet
;
ListCache
.
prototype
.
has
=
listCacheHas
;
ListCache
.
prototype
.
set
=
listCacheSet
;
module
.
exports
=
ListCache
;
}
function
(
module
exports
)
{
function
listCacheClear
(
)
{
this
.
__data__
=
[
]
;
}
module
.
exports
=
listCacheClear
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
226
)
;
var
arrayProto
=
Array
.
prototype
;
var
splice
=
arrayProto
.
splice
;
function
listCacheDelete
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
return
false
;
}
var
lastIndex
=
data
.
length
-
1
;
if
(
index
=
=
lastIndex
)
{
data
.
pop
(
)
;
}
else
{
splice
.
call
(
data
index
1
)
;
}
return
true
;
}
module
.
exports
=
listCacheDelete
;
}
function
(
module
exports
__webpack_require__
)
{
var
eq
=
__webpack_require__
(
227
)
;
function
assocIndexOf
(
array
key
)
{
var
length
=
array
.
length
;
while
(
length
-
-
)
{
if
(
eq
(
array
[
length
]
[
0
]
key
)
)
{
return
length
;
}
}
return
-
1
;
}
module
.
exports
=
assocIndexOf
;
}
function
(
module
exports
)
{
function
eq
(
value
other
)
{
return
value
=
=
=
other
|
|
(
value
!
=
=
value
&
&
other
!
=
=
other
)
;
}
module
.
exports
=
eq
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
226
)
;
function
listCacheGet
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
return
index
<
0
?
undefined
:
data
[
index
]
[
1
]
;
}
module
.
exports
=
listCacheGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
226
)
;
function
listCacheHas
(
key
)
{
return
assocIndexOf
(
this
.
__data__
key
)
>
-
1
;
}
module
.
exports
=
listCacheHas
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
226
)
;
function
listCacheSet
(
key
value
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
data
.
push
(
[
key
value
]
)
;
}
else
{
data
[
index
]
[
1
]
=
value
;
}
return
this
;
}
module
.
exports
=
listCacheSet
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
209
)
root
=
__webpack_require__
(
215
)
;
var
Map
=
getNative
(
root
'
Map
'
)
;
module
.
exports
=
Map
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
233
)
;
function
mapCacheDelete
(
key
)
{
return
getMapData
(
this
key
)
[
'
delete
'
]
(
key
)
;
}
module
.
exports
=
mapCacheDelete
;
}
function
(
module
exports
__webpack_require__
)
{
var
isKeyable
=
__webpack_require__
(
234
)
;
function
getMapData
(
map
key
)
{
var
data
=
map
.
__data__
;
return
isKeyable
(
key
)
?
data
[
typeof
key
=
=
'
string
'
?
'
string
'
:
'
hash
'
]
:
data
.
map
;
}
module
.
exports
=
getMapData
;
}
function
(
module
exports
)
{
function
isKeyable
(
value
)
{
var
type
=
typeof
value
;
return
(
type
=
=
'
string
'
|
|
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
)
?
(
value
!
=
=
'
__proto__
'
)
:
(
value
=
=
=
null
)
;
}
module
.
exports
=
isKeyable
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
233
)
;
function
mapCacheGet
(
key
)
{
return
getMapData
(
this
key
)
.
get
(
key
)
;
}
module
.
exports
=
mapCacheGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
233
)
;
function
mapCacheHas
(
key
)
{
return
getMapData
(
this
key
)
.
has
(
key
)
;
}
module
.
exports
=
mapCacheHas
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
233
)
;
function
mapCacheSet
(
key
value
)
{
getMapData
(
this
key
)
.
set
(
key
value
)
;
return
this
;
}
module
.
exports
=
mapCacheSet
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseToString
=
__webpack_require__
(
239
)
;
function
toString
(
value
)
{
return
value
=
=
null
?
'
'
:
baseToString
(
value
)
;
}
module
.
exports
=
toString
;
}
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
240
)
isSymbol
=
__webpack_require__
(
241
)
;
var
INFINITY
=
1
/
0
;
var
symbolProto
=
Symbol
?
Symbol
.
prototype
:
undefined
symbolToString
=
symbolProto
?
symbolProto
.
toString
:
undefined
;
function
baseToString
(
value
)
{
if
(
typeof
value
=
=
'
string
'
)
{
return
value
;
}
if
(
isSymbol
(
value
)
)
{
return
symbolToString
?
symbolToString
.
call
(
value
)
:
'
'
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
baseToString
;
}
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
215
)
;
var
Symbol
=
root
.
Symbol
;
module
.
exports
=
Symbol
;
}
function
(
module
exports
__webpack_require__
)
{
var
isObjectLike
=
__webpack_require__
(
7
)
;
var
symbolTag
=
'
[
object
Symbol
]
'
;
var
objectProto
=
Object
.
prototype
;
var
objectToString
=
objectProto
.
toString
;
function
isSymbol
(
value
)
{
return
typeof
value
=
=
'
symbol
'
|
|
(
isObjectLike
(
value
)
&
&
objectToString
.
call
(
value
)
=
=
symbolTag
)
;
}
module
.
exports
=
isSymbol
;
}
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
201
)
isSymbol
=
__webpack_require__
(
241
)
;
var
reIsDeepProp
=
/
\
.
|
\
[
(
?
:
[
^
[
\
]
]
*
|
(
[
"
'
]
)
(
?
:
(
?
!
\
1
)
[
^
\
\
]
|
\
\
.
)
*
?
\
1
)
\
]
/
reIsPlainProp
=
/
^
\
w
*
/
;
function
isKey
(
value
object
)
{
if
(
isArray
(
value
)
)
{
return
false
;
}
var
type
=
typeof
value
;
if
(
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
|
|
value
=
=
null
|
|
isSymbol
(
value
)
)
{
return
true
;
}
return
reIsPlainProp
.
test
(
value
)
|
|
!
reIsDeepProp
.
test
(
value
)
|
|
(
object
!
=
null
&
&
value
in
Object
(
object
)
)
;
}
module
.
exports
=
isKey
;
}
function
(
module
exports
__webpack_require__
)
{
var
isSymbol
=
__webpack_require__
(
241
)
;
var
INFINITY
=
1
/
0
;
function
toKey
(
value
)
{
if
(
typeof
value
=
=
'
string
'
|
|
isSymbol
(
value
)
)
{
return
value
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
toKey
;
}
function
(
module
exports
)
{
function
Debuggee
(
)
{
function
(
selector
)
{
var
element
=
document
.
querySelector
(
selector
)
;
console
.
log
(
"
"
selector
element
)
;
if
(
!
element
)
{
throw
new
Error
(
"
Element
not
found
try
changing
the
selector
"
)
;
}
return
element
;
}
function
mouseEvent
(
eventType
)
{
return
new
MouseEvent
(
eventType
{
"
view
"
:
window
"
bubbles
"
:
true
"
cancelable
"
:
true
}
)
;
}
var
specialKeysMap
=
{
"
{
enter
}
"
:
13
}
;
function
isSpecialCharacter
(
text
)
{
return
text
.
match
(
/
^
\
{
.
*
\
}
/
)
;
}
function
keyInfo
(
key
eventType
)
{
var
charCodeAt
=
void
0
;
if
(
key
.
length
>
1
)
{
charCodeAt
=
specialKeysMap
[
key
]
;
}
else
{
charCodeAt
=
key
.
toUpperCase
(
)
.
charCodeAt
(
0
)
;
}
return
{
charCode
:
eventType
=
=
"
keypress
"
?
0
:
charCodeAt
keyCode
:
charCodeAt
which
:
charCodeAt
}
;
}
function
keyEvent
(
eventType
key
)
{
var
event
=
new
Event
(
eventType
{
bubbles
:
true
cancelable
:
false
view
:
window
}
)
;
var
_keyInfo
=
keyInfo
(
key
eventType
)
;
var
charCode
=
_keyInfo
.
charCode
;
var
keyCode
=
_keyInfo
.
keyCode
;
var
which
=
_keyInfo
.
which
;
return
Object
.
assign
(
event
{
charCode
:
charCode
keyCode
:
keyCode
which
:
which
detail
:
0
layerX
:
0
layerY
:
0
pageX
:
0
pageY
:
0
}
)
;
}
function
sendKey
(
element
key
)
{
element
.
dispatchEvent
(
keyEvent
(
"
keydown
"
key
)
)
;
element
.
dispatchEvent
(
keyEvent
(
"
keypress
"
key
)
)
;
if
(
key
.
length
=
=
1
)
{
element
.
value
+
=
key
;
}
element
.
dispatchEvent
(
keyEvent
(
"
keyup
"
key
)
)
;
}
function
click
(
selector
)
{
var
element
=
(
selector
)
;
console
.
log
(
"
click
"
selector
)
;
element
.
dispatchEvent
(
mouseEvent
(
"
click
"
)
)
;
}
function
dblclick
(
selector
)
{
var
element
=
(
selector
)
;
console
.
log
(
"
dblclick
"
selector
)
;
element
.
dispatchEvent
(
mouseEvent
(
"
dblclick
"
)
)
;
}
function
type
(
selector
text
)
{
var
element
=
(
selector
)
;
console
.
log
(
"
type
"
selector
text
)
;
element
.
select
(
)
;
if
(
isSpecialCharacter
(
text
)
)
{
sendKey
(
element
text
)
;
}
else
{
var
chars
=
text
.
split
(
"
"
)
;
chars
.
forEach
(
char
=
>
sendKey
(
element
char
)
)
;
}
}
return
{
click
dblclick
type
}
;
}
var
debuggeeStatement
=
window
.
dbg
=
(
{
Debuggee
}
)
(
)
;
var
injectedDebuggee
=
void
0
;
function
injectDebuggee
(
)
{
if
(
injectedDebuggee
)
{
return
Promise
.
resolve
(
injectedDebuggee
)
;
}
return
window
.
client
.
evaluate
(
debuggeeStatement
)
.
then
(
result
=
>
{
injectedDebuggee
=
result
;
}
)
;
}
module
.
exports
=
injectDebuggee
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
_require
=
__webpack_require__
(
246
)
;
var
Task
=
_require
.
Task
;
var
firefox
=
__webpack_require__
(
247
)
;
var
chrome
=
__webpack_require__
(
321
)
;
var
_require2
=
__webpack_require__
(
195
)
;
var
debugGlobal
=
_require2
.
debugGlobal
;
var
clientType
=
void
0
;
function
getClient
(
)
{
if
(
clientType
=
=
=
"
chrome
"
)
{
return
chrome
.
clientCommands
;
}
return
firefox
.
clientCommands
;
}
function
startDebugging
(
connTarget
actions
)
{
if
(
connTarget
.
type
=
=
=
"
node
"
)
{
return
startDebuggingNode
(
connTarget
.
param
actions
)
;
}
var
target
=
connTarget
.
type
=
=
=
"
chrome
"
?
chrome
:
firefox
;
return
startDebuggingTab
(
target
connTarget
.
param
actions
)
;
}
function
startDebuggingNode
(
url
actions
)
{
clientType
=
"
chrome
"
;
return
chrome
.
connectNode
(
ws
:
/
/
{
url
}
)
.
then
(
(
)
=
>
{
chrome
.
initPage
(
actions
)
;
}
)
;
}
function
startDebuggingTab
(
targetEnv
tabId
actions
)
{
return
Task
.
spawn
(
function
*
(
)
{
var
tabs
=
yield
targetEnv
.
connectClient
(
)
;
var
tab
=
tabs
.
find
(
t
=
>
t
.
id
.
indexOf
(
tabId
)
!
=
=
-
1
)
;
yield
targetEnv
.
connectTab
(
tab
.
tab
)
;
targetEnv
.
initPage
(
actions
)
;
clientType
=
targetEnv
=
=
=
firefox
?
"
firefox
"
:
"
chrome
"
;
debugGlobal
(
"
client
"
targetEnv
.
clientCommands
)
;
return
tabs
;
}
)
;
}
function
connectClients
(
)
{
return
Promise
.
all
(
[
firefox
.
connectClient
(
)
chrome
.
connectClient
(
)
]
)
.
then
(
results
=
>
{
var
_results
=
_slicedToArray
(
results
2
)
;
var
firefoxTabs
=
_results
[
0
]
;
var
chromeTabs
=
_results
[
1
]
;
return
firefoxTabs
.
concat
(
chromeTabs
)
.
filter
(
i
=
>
i
)
;
}
)
;
}
module
.
exports
=
{
getClient
connectClients
startDebugging
}
;
}
function
(
module
exports
)
{
var
Task
=
{
async
:
function
(
task
)
{
return
function
(
)
{
return
Task
.
spawn
(
task
this
arguments
)
;
}
;
}
spawn
:
function
(
task
scope
args
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
iterator
=
task
.
apply
(
scope
args
)
;
var
callNext
=
lastValue
=
>
{
var
iteration
=
iterator
.
next
(
lastValue
)
;
Promise
.
resolve
(
iteration
.
value
)
.
then
(
value
=
>
{
if
(
iteration
.
done
)
{
resolve
(
value
)
;
}
else
{
callNext
(
value
)
;
}
}
)
.
catch
(
error
=
>
{
reject
(
error
)
;
iterator
.
throw
(
error
)
;
}
)
;
}
;
callNext
(
undefined
)
;
}
)
;
}
}
;
module
.
exports
=
{
Task
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
248
)
;
var
DebuggerClient
=
_require
.
DebuggerClient
;
var
_require2
=
__webpack_require__
(
254
)
;
var
DebuggerTransport
=
_require2
.
DebuggerTransport
;
var
WebSocketDebuggerTransport
=
__webpack_require__
(
259
)
;
var
_require3
=
__webpack_require__
(
262
)
;
var
TargetFactory
=
_require3
.
TargetFactory
;
var
defer
=
__webpack_require__
(
261
)
;
var
_require4
=
__webpack_require__
(
196
)
;
var
getValue
=
_require4
.
getValue
;
var
_require5
=
__webpack_require__
(
263
)
;
var
Tab
=
_require5
.
Tab
;
var
_require6
=
__webpack_require__
(
319
)
;
var
setupCommands
=
_require6
.
setupCommands
;
var
clientCommands
=
_require6
.
clientCommands
;
var
_require7
=
__webpack_require__
(
320
)
;
var
setupEvents
=
_require7
.
setupEvents
;
var
clientEvents
=
_require7
.
clientEvents
;
var
debuggerClient
=
null
;
var
threadClient
=
null
;
var
tabTarget
=
null
;
function
getThreadClient
(
)
{
return
threadClient
;
}
function
setThreadClient
(
client
)
{
threadClient
=
client
;
}
function
getTabTarget
(
)
{
return
tabTarget
;
}
function
setTabTarget
(
target
)
{
tabTarget
=
target
;
}
function
lookupTabTarget
(
tab
)
{
var
options
=
{
client
:
debuggerClient
form
:
tab
chrome
:
false
}
;
return
TargetFactory
.
forRemoteTab
(
options
)
;
}
function
createTabs
(
tabs
)
{
return
tabs
.
map
(
tab
=
>
{
return
Tab
(
{
title
:
tab
.
title
url
:
tab
.
url
id
:
tab
.
actor
tab
browser
:
"
firefox
"
}
)
;
}
)
;
}
function
connectClient
(
)
{
var
deferred
=
defer
(
)
;
var
isConnected
=
false
;
var
useProxy
=
!
getValue
(
"
firefox
.
webSocketConnection
"
)
;
var
portPref
=
useProxy
?
"
firefox
.
proxyPort
"
:
"
firefox
.
webSocketPort
"
;
var
webSocketPort
=
getValue
(
portPref
)
;
var
socket
=
new
WebSocket
(
ws
:
/
/
{
document
.
location
.
hostname
}
:
{
webSocketPort
}
)
;
var
transport
=
useProxy
?
new
DebuggerTransport
(
socket
)
:
new
WebSocketDebuggerTransport
(
socket
)
;
debuggerClient
=
new
DebuggerClient
(
transport
)
;
setTimeout
(
(
)
=
>
{
if
(
isConnected
)
{
return
;
}
deferred
.
resolve
(
[
]
)
;
}
6000
)
;
debuggerClient
.
connect
(
)
.
then
(
(
)
=
>
{
isConnected
=
true
;
return
debuggerClient
.
listTabs
(
)
.
then
(
response
=
>
{
deferred
.
resolve
(
createTabs
(
response
.
tabs
)
)
;
}
)
;
}
)
.
catch
(
err
=
>
{
console
.
log
(
err
)
;
deferred
.
reject
(
)
;
}
)
;
return
deferred
.
promise
;
}
function
connectTab
(
tab
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
window
.
addEventListener
(
"
beforeunload
"
(
)
=
>
{
getTabTarget
(
)
&
&
getTabTarget
(
)
.
destroy
(
)
;
}
)
;
lookupTabTarget
(
tab
)
.
then
(
target
=
>
{
tabTarget
=
target
;
target
.
activeTab
.
attachThread
(
{
}
(
res
_threadClient
)
=
>
{
threadClient
=
_threadClient
;
threadClient
.
resume
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
}
function
initPage
(
actions
)
{
tabTarget
=
getTabTarget
(
)
;
threadClient
=
getThreadClient
(
)
;
setupCommands
(
{
threadClient
tabTarget
}
)
;
tabTarget
.
on
(
"
will
-
navigate
"
actions
.
willNavigate
)
;
tabTarget
.
on
(
"
navigate
"
actions
.
navigate
)
;
tabTarget
.
on
(
"
frame
-
update
"
function
(
_
packet
)
{
if
(
packet
.
destroyAll
)
{
actions
.
willNavigate
(
)
;
}
}
)
;
setupEvents
(
{
threadClient
actions
}
)
;
Object
.
keys
(
clientEvents
)
.
forEach
(
eventName
=
>
{
threadClient
.
addListener
(
eventName
clientEvents
[
eventName
]
)
;
}
)
;
threadClient
.
reconfigure
(
{
"
useSourceMaps
"
:
false
"
autoBlackBox
"
:
false
}
)
;
threadClient
.
getSources
(
)
;
}
module
.
exports
=
{
connectClient
connectTab
clientCommands
getThreadClient
setThreadClient
getTabTarget
setTabTarget
initPage
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Ci
Cu
components
}
=
__webpack_require__
(
178
)
;
const
{
Services
}
=
__webpack_require__
(
183
)
;
const
DevToolsUtils
=
__webpack_require__
(
177
)
;
const
promise
=
__webpack_require__
(
189
)
;
const
events
=
__webpack_require__
(
249
)
;
const
{
WebConsoleClient
}
=
__webpack_require__
(
252
)
;
const
noop
=
(
)
=
>
{
}
;
function
eventSource
(
aProto
)
{
aProto
.
addListener
=
function
(
aName
aListener
)
{
if
(
typeof
aListener
!
=
"
function
"
)
{
throw
TypeError
(
"
Listeners
must
be
functions
.
"
)
;
}
if
(
!
this
.
_listeners
)
{
this
.
_listeners
=
{
}
;
}
this
.
_getListeners
(
aName
)
.
push
(
aListener
)
;
}
;
aProto
.
addOneTimeListener
=
function
(
aName
aListener
)
{
let
l
=
(
.
.
.
args
)
=
>
{
this
.
removeListener
(
aName
l
)
;
aListener
.
apply
(
null
args
)
;
}
;
this
.
addListener
(
aName
l
)
;
}
;
aProto
.
removeListener
=
function
(
aName
aListener
)
{
if
(
!
this
.
_listeners
|
|
(
aListener
&
&
!
this
.
_listeners
[
aName
]
)
)
{
return
;
}
if
(
!
aListener
)
{
this
.
_listeners
[
aName
]
=
[
]
;
}
else
{
this
.
_listeners
[
aName
]
=
this
.
_listeners
[
aName
]
.
filter
(
function
(
l
)
{
return
l
!
=
aListener
}
)
;
}
}
;
aProto
.
_getListeners
=
function
(
aName
)
{
if
(
aName
in
this
.
_listeners
)
{
return
this
.
_listeners
[
aName
]
;
}
this
.
_listeners
[
aName
]
=
[
]
;
return
this
.
_listeners
[
aName
]
;
}
;
aProto
.
emit
=
function
(
)
{
if
(
!
this
.
_listeners
)
{
return
;
}
let
name
=
arguments
[
0
]
;
let
listeners
=
this
.
_getListeners
(
name
)
.
slice
(
0
)
;
for
(
let
listener
of
listeners
)
{
try
{
listener
.
apply
(
null
arguments
)
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
notify
event
'
"
+
name
+
"
'
"
e
)
;
}
}
}
}
const
ThreadStateTypes
=
{
"
paused
"
:
"
paused
"
"
resumed
"
:
"
attached
"
"
detached
"
:
"
detached
"
}
;
const
UnsolicitedNotifications
=
{
"
consoleAPICall
"
:
"
consoleAPICall
"
"
eventNotification
"
:
"
eventNotification
"
"
fileActivity
"
:
"
fileActivity
"
"
lastPrivateContextExited
"
:
"
lastPrivateContextExited
"
"
logMessage
"
:
"
logMessage
"
"
networkEvent
"
:
"
networkEvent
"
"
networkEventUpdate
"
:
"
networkEventUpdate
"
"
newGlobal
"
:
"
newGlobal
"
"
newScript
"
:
"
newScript
"
"
tabDetached
"
:
"
tabDetached
"
"
tabListChanged
"
:
"
tabListChanged
"
"
reflowActivity
"
:
"
reflowActivity
"
"
addonListChanged
"
:
"
addonListChanged
"
"
workerListChanged
"
:
"
workerListChanged
"
"
serviceWorkerRegistrationListChanged
"
:
"
serviceWorkerRegistrationList
"
"
tabNavigated
"
:
"
tabNavigated
"
"
frameUpdate
"
:
"
frameUpdate
"
"
pageError
"
:
"
pageError
"
"
documentLoad
"
:
"
documentLoad
"
"
enteredFrame
"
:
"
enteredFrame
"
"
exitedFrame
"
:
"
exitedFrame
"
"
appOpen
"
:
"
appOpen
"
"
appClose
"
:
"
appClose
"
"
appInstall
"
:
"
appInstall
"
"
appUninstall
"
:
"
appUninstall
"
"
evaluationResult
"
:
"
evaluationResult
"
"
newSource
"
:
"
newSource
"
"
updatedSource
"
:
"
updatedSource
"
}
;
const
UnsolicitedPauses
=
{
"
resumeLimit
"
:
"
resumeLimit
"
"
debuggerStatement
"
:
"
debuggerStatement
"
"
breakpoint
"
:
"
breakpoint
"
"
DOMEvent
"
:
"
DOMEvent
"
"
watchpoint
"
:
"
watchpoint
"
"
exception
"
:
"
exception
"
}
;
const
DebuggerClient
=
exports
.
DebuggerClient
=
function
(
aTransport
)
{
this
.
_transport
=
aTransport
;
this
.
_transport
.
hooks
=
this
;
this
.
_clients
=
new
Map
(
)
;
this
.
_pendingRequests
=
new
Map
(
)
;
this
.
_activeRequests
=
new
Map
(
)
;
this
.
_eventsEnabled
=
true
;
this
.
traits
=
{
}
;
this
.
request
=
this
.
request
.
bind
(
this
)
;
this
.
localTransport
=
this
.
_transport
.
onOutputStreamReady
=
=
=
undefined
;
this
.
mainRoot
=
null
;
this
.
expectReply
(
"
root
"
(
aPacket
)
=
>
{
this
.
mainRoot
=
new
RootClient
(
this
aPacket
)
;
this
.
emit
(
"
connected
"
aPacket
.
applicationType
aPacket
.
traits
)
;
}
)
;
}
DebuggerClient
.
requester
=
function
(
aPacketSkeleton
config
=
{
}
)
{
let
{
telemetry
before
after
}
=
config
;
return
DevToolsUtils
.
makeInfallible
(
function
(
.
.
.
args
)
{
let
histogram
startTime
;
if
(
telemetry
)
{
let
transportType
=
this
.
_transport
.
onOutputStreamReady
=
=
=
undefined
?
"
LOCAL_
"
:
"
REMOTE_
"
;
let
histogramId
=
"
DEVTOOLS_DEBUGGER_RDP_
"
+
transportType
+
telemetry
+
"
_MS
"
;
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramId
)
;
startTime
=
+
new
Date
;
}
let
outgoingPacket
=
{
to
:
aPacketSkeleton
.
to
|
|
this
.
actor
}
;
let
maxPosition
=
-
1
;
for
(
let
k
of
Object
.
keys
(
aPacketSkeleton
)
)
{
if
(
aPacketSkeleton
[
k
]
instanceof
DebuggerClient
.
Argument
)
{
let
{
position
}
=
aPacketSkeleton
[
k
]
;
outgoingPacket
[
k
]
=
aPacketSkeleton
[
k
]
.
getArgument
(
args
)
;
maxPosition
=
Math
.
max
(
position
maxPosition
)
;
}
else
{
outgoingPacket
[
k
]
=
aPacketSkeleton
[
k
]
;
}
}
if
(
before
)
{
outgoingPacket
=
before
.
call
(
this
outgoingPacket
)
;
}
return
this
.
request
(
outgoingPacket
DevToolsUtils
.
makeInfallible
(
(
aResponse
)
=
>
{
if
(
after
)
{
let
{
from
}
=
aResponse
;
aResponse
=
after
.
call
(
this
aResponse
)
;
if
(
!
aResponse
.
from
)
{
aResponse
.
from
=
from
;
}
}
let
thisCallback
=
args
[
maxPosition
+
1
]
;
if
(
thisCallback
)
{
thisCallback
(
aResponse
)
;
}
if
(
histogram
)
{
histogram
.
add
(
+
new
Date
-
startTime
)
;
}
}
"
DebuggerClient
.
requester
request
callback
"
)
)
;
}
"
DebuggerClient
.
requester
"
)
;
}
;
function
args
(
aPos
)
{
return
new
DebuggerClient
.
Argument
(
aPos
)
;
}
DebuggerClient
.
Argument
=
function
(
aPosition
)
{
this
.
position
=
aPosition
;
}
;
DebuggerClient
.
Argument
.
prototype
.
getArgument
=
function
(
aParams
)
{
if
(
!
(
this
.
position
in
aParams
)
)
{
throw
new
Error
(
"
Bad
index
into
params
:
"
+
this
.
position
)
;
}
return
aParams
[
this
.
position
]
;
}
;
DebuggerClient
.
socketConnect
=
function
(
options
)
{
return
DebuggerSocket
.
connect
(
options
)
;
}
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
Authenticators
"
(
)
=
>
{
return
Authentication
.
Authenticators
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
AuthenticationResult
"
(
)
=
>
{
return
Authentication
.
AuthenticationResult
;
}
)
;
DebuggerClient
.
prototype
=
{
connect
:
function
(
aOnConnected
)
{
let
deferred
=
promise
.
defer
(
)
;
this
.
emit
(
"
connect
"
)
;
events
.
emit
(
DebuggerClient
"
connect
"
this
)
;
this
.
addOneTimeListener
(
"
connected
"
(
aName
aApplicationType
aTraits
)
=
>
{
this
.
traits
=
aTraits
;
if
(
aOnConnected
)
{
aOnConnected
(
aApplicationType
aTraits
)
;
}
deferred
.
resolve
(
[
aApplicationType
aTraits
]
)
;
}
)
;
this
.
_transport
.
ready
(
)
;
return
deferred
.
promise
;
}
close
:
function
(
aOnClosed
)
{
this
.
_eventsEnabled
=
false
;
let
cleanup
=
(
)
=
>
{
this
.
_transport
.
close
(
)
;
this
.
_transport
=
null
;
}
;
if
(
this
.
_closed
)
{
cleanup
(
)
;
if
(
aOnClosed
)
{
aOnClosed
(
)
;
}
return
;
}
if
(
aOnClosed
)
{
this
.
addOneTimeListener
(
'
closed
'
function
(
aEvent
)
{
aOnClosed
(
)
;
}
)
;
}
let
clients
=
[
.
.
.
this
.
_clients
.
values
(
)
]
;
this
.
_clients
.
clear
(
)
;
const
detachClients
=
(
)
=
>
{
let
client
=
clients
.
pop
(
)
;
if
(
!
client
)
{
cleanup
(
)
;
return
;
}
if
(
client
.
detach
)
{
client
.
detach
(
detachClients
)
;
return
;
}
detachClients
(
)
;
}
;
detachClients
(
)
;
}
listTabs
:
function
(
aOnResponse
)
{
return
this
.
mainRoot
.
listTabs
(
aOnResponse
)
;
}
listAddons
:
function
(
aOnResponse
)
{
return
this
.
mainRoot
.
listAddons
(
aOnResponse
)
;
}
getTab
:
function
(
aFilter
)
{
return
this
.
mainRoot
.
getTab
(
aFilter
)
;
}
attachTab
:
function
(
aTabActor
aOnResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
aTabActor
)
)
{
let
cachedTab
=
this
.
_clients
.
get
(
aTabActor
)
;
let
cachedResponse
=
{
cacheDisabled
:
cachedTab
.
cacheDisabled
javascriptEnabled
:
cachedTab
.
javascriptEnabled
traits
:
cachedTab
.
traits
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
cachedResponse
cachedTab
)
)
;
return
promise
.
resolve
(
[
cachedResponse
cachedTab
]
)
;
}
let
packet
=
{
to
:
aTabActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
tabClient
;
if
(
!
aResponse
.
error
)
{
tabClient
=
new
TabClient
(
this
aResponse
)
;
this
.
registerClient
(
tabClient
)
;
}
aOnResponse
(
aResponse
tabClient
)
;
return
[
aResponse
tabClient
]
;
}
)
;
}
attachWorker
:
function
DC_attachWorker
(
aWorkerActor
aOnResponse
=
noop
)
{
let
workerClient
=
this
.
_clients
.
get
(
aWorkerActor
)
;
if
(
workerClient
!
=
=
undefined
)
{
let
response
=
{
from
:
workerClient
.
actor
type
:
"
attached
"
url
:
workerClient
.
url
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
response
workerClient
)
)
;
return
promise
.
resolve
(
[
response
workerClient
]
)
;
}
return
this
.
request
(
{
to
:
aWorkerActor
type
:
"
attach
"
}
)
.
then
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
aOnResponse
(
aResponse
null
)
;
return
[
aResponse
null
]
;
}
let
workerClient
=
new
WorkerClient
(
this
aResponse
)
;
this
.
registerClient
(
workerClient
)
;
aOnResponse
(
aResponse
workerClient
)
;
return
[
aResponse
workerClient
]
;
}
)
;
}
attachAddon
:
function
DC_attachAddon
(
aAddonActor
aOnResponse
=
noop
)
{
let
packet
=
{
to
:
aAddonActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
addonClient
;
if
(
!
aResponse
.
error
)
{
addonClient
=
new
AddonClient
(
this
aAddonActor
)
;
this
.
registerClient
(
addonClient
)
;
this
.
activeAddon
=
addonClient
;
}
aOnResponse
(
aResponse
addonClient
)
;
return
[
aResponse
addonClient
]
;
}
)
;
}
attachConsole
:
function
(
aConsoleActor
aListeners
aOnResponse
=
noop
)
{
let
packet
=
{
to
:
aConsoleActor
type
:
"
startListeners
"
listeners
:
aListeners
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
consoleClient
;
if
(
!
aResponse
.
error
)
{
if
(
this
.
_clients
.
has
(
aConsoleActor
)
)
{
consoleClient
=
this
.
_clients
.
get
(
aConsoleActor
)
;
}
else
{
consoleClient
=
new
WebConsoleClient
(
this
aResponse
)
;
this
.
registerClient
(
consoleClient
)
;
}
}
aOnResponse
(
aResponse
consoleClient
)
;
return
[
aResponse
consoleClient
]
;
}
)
;
}
attachThread
:
function
(
aThreadActor
aOnResponse
=
noop
aOptions
=
{
}
)
{
if
(
this
.
_clients
.
has
(
aThreadActor
)
)
{
let
client
=
this
.
_clients
.
get
(
aThreadActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
let
packet
=
{
to
:
aThreadActor
type
:
"
attach
"
options
:
aOptions
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
var
threadClient
=
new
ThreadClient
(
this
aThreadActor
)
;
this
.
registerClient
(
threadClient
)
;
}
aOnResponse
(
aResponse
threadClient
)
;
return
[
aResponse
threadClient
]
;
}
)
;
}
attachTracer
:
function
(
aTraceActor
aOnResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
aTraceActor
)
)
{
let
client
=
this
.
_clients
.
get
(
aTraceActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
let
packet
=
{
to
:
aTraceActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
var
traceClient
=
new
TraceClient
(
this
aTraceActor
)
;
this
.
registerClient
(
traceClient
)
;
}
aOnResponse
(
aResponse
traceClient
)
;
return
[
aResponse
traceClient
]
;
}
)
;
}
getProcess
:
function
(
aId
)
{
let
packet
=
{
to
:
"
root
"
type
:
"
getProcess
"
}
if
(
typeof
(
aId
)
=
=
"
number
"
)
{
packet
.
id
=
aId
;
}
return
this
.
request
(
packet
)
;
}
release
:
DebuggerClient
.
requester
(
{
to
:
args
(
0
)
type
:
"
release
"
}
{
telemetry
:
"
RELEASE
"
}
)
request
:
function
(
aRequest
aOnResponse
)
{
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
let
type
=
aRequest
.
type
|
|
"
"
;
if
(
!
aRequest
.
to
)
{
throw
Error
(
"
'
"
+
type
+
"
'
request
packet
has
no
destination
.
"
)
;
}
if
(
this
.
_closed
)
{
let
msg
=
"
'
"
+
type
+
"
'
request
packet
to
"
+
"
'
"
+
aRequest
.
to
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
is
closed
.
"
;
let
resp
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
if
(
aOnResponse
)
{
aOnResponse
(
resp
)
;
}
return
promise
.
reject
(
resp
)
;
}
let
request
=
new
Request
(
aRequest
)
;
request
.
format
=
"
json
"
;
request
.
stack
=
components
.
stack
;
if
(
aOnResponse
)
{
request
.
on
(
"
json
-
reply
"
aOnResponse
)
;
}
this
.
_sendOrQueueRequest
(
request
)
;
let
deferred
=
promise
.
defer
(
)
;
function
listenerJson
(
resp
)
{
request
.
off
(
"
json
-
reply
"
listenerJson
)
;
request
.
off
(
"
bulk
-
reply
"
listenerBulk
)
;
if
(
resp
.
error
)
{
deferred
.
reject
(
resp
)
;
}
else
{
deferred
.
resolve
(
resp
)
;
}
}
function
listenerBulk
(
resp
)
{
request
.
off
(
"
json
-
reply
"
listenerJson
)
;
request
.
off
(
"
bulk
-
reply
"
listenerBulk
)
;
deferred
.
resolve
(
resp
)
;
}
request
.
on
(
"
json
-
reply
"
listenerJson
)
;
request
.
on
(
"
bulk
-
reply
"
listenerBulk
)
;
request
.
then
=
deferred
.
promise
.
then
.
bind
(
deferred
.
promise
)
;
return
request
;
}
startBulkRequest
:
function
(
request
)
{
if
(
!
this
.
traits
.
bulk
)
{
throw
Error
(
"
Server
doesn
'
t
support
bulk
transfers
"
)
;
}
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
if
(
!
request
.
type
)
{
throw
Error
(
"
Bulk
packet
is
missing
the
required
'
type
'
field
.
"
)
;
}
if
(
!
request
.
actor
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
destination
.
"
)
;
}
if
(
!
request
.
length
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
length
.
"
)
;
}
request
=
new
Request
(
request
)
;
request
.
format
=
"
bulk
"
;
this
.
_sendOrQueueRequest
(
request
)
;
return
request
;
}
_sendOrQueueRequest
(
request
)
{
let
actor
=
request
.
actor
;
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
this
.
_sendRequest
(
request
)
;
}
else
{
this
.
_queueRequest
(
request
)
;
}
}
_sendRequest
(
request
)
{
let
actor
=
request
.
actor
;
this
.
expectReply
(
actor
request
)
;
if
(
request
.
format
=
=
=
"
json
"
)
{
this
.
_transport
.
send
(
request
.
request
)
;
return
false
;
}
this
.
_transport
.
startBulkSend
(
request
.
request
)
.
then
(
(
.
.
.
args
)
=
>
{
request
.
emit
(
"
bulk
-
send
-
ready
"
.
.
.
args
)
;
}
)
;
}
_queueRequest
(
request
)
{
let
actor
=
request
.
actor
;
let
queue
=
this
.
_pendingRequests
.
get
(
actor
)
|
|
[
]
;
queue
.
push
(
request
)
;
this
.
_pendingRequests
.
set
(
actor
queue
)
;
}
_attemptNextRequest
(
actor
)
{
if
(
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
let
queue
=
this
.
_pendingRequests
.
get
(
actor
)
;
if
(
!
queue
)
{
return
;
}
let
request
=
queue
.
shift
(
)
;
if
(
queue
.
length
=
=
=
0
)
{
this
.
_pendingRequests
.
delete
(
actor
)
;
}
this
.
_sendRequest
(
request
)
;
}
expectReply
:
function
(
aActor
aRequest
)
{
if
(
this
.
_activeRequests
.
has
(
aActor
)
)
{
throw
Error
(
"
clashing
handlers
for
next
reply
from
"
+
uneval
(
aActor
)
)
;
}
if
(
typeof
aRequest
=
=
=
"
function
"
)
{
let
handler
=
aRequest
;
aRequest
=
new
Request
(
)
;
aRequest
.
on
(
"
json
-
reply
"
handler
)
;
}
this
.
_activeRequests
.
set
(
aActor
aRequest
)
;
}
onPacket
:
function
(
aPacket
)
{
if
(
!
aPacket
.
from
)
{
DevToolsUtils
.
reportException
(
"
onPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
packet
:
"
+
JSON
.
stringify
(
aPacket
)
)
)
;
return
;
}
let
front
=
this
.
getActor
(
aPacket
.
from
)
;
if
(
front
)
{
front
.
onPacket
(
aPacket
)
;
return
;
}
if
(
this
.
_clients
.
has
(
aPacket
.
from
)
&
&
aPacket
.
type
)
{
let
client
=
this
.
_clients
.
get
(
aPacket
.
from
)
;
let
type
=
aPacket
.
type
;
if
(
client
.
events
.
indexOf
(
type
)
!
=
-
1
)
{
client
.
emit
(
type
aPacket
)
;
return
;
}
}
let
activeRequest
;
if
(
this
.
_activeRequests
.
has
(
aPacket
.
from
)
&
&
!
(
aPacket
.
type
in
UnsolicitedNotifications
)
&
&
!
(
aPacket
.
type
=
=
ThreadStateTypes
.
paused
&
&
aPacket
.
why
.
type
in
UnsolicitedPauses
)
)
{
activeRequest
=
this
.
_activeRequests
.
get
(
aPacket
.
from
)
;
this
.
_activeRequests
.
delete
(
aPacket
.
from
)
;
}
this
.
_attemptNextRequest
(
aPacket
.
from
)
;
if
(
aPacket
.
type
in
ThreadStateTypes
&
&
this
.
_clients
.
has
(
aPacket
.
from
)
&
&
typeof
this
.
_clients
.
get
(
aPacket
.
from
)
.
_onThreadState
=
=
"
function
"
)
{
this
.
_clients
.
get
(
aPacket
.
from
)
.
_onThreadState
(
aPacket
)
;
}
if
(
!
this
.
traits
.
noNeedToFakeResumptionOnNavigation
)
{
if
(
aPacket
.
type
=
=
UnsolicitedNotifications
.
tabNavigated
&
&
this
.
_clients
.
has
(
aPacket
.
from
)
&
&
this
.
_clients
.
get
(
aPacket
.
from
)
.
thread
)
{
let
thread
=
this
.
_clients
.
get
(
aPacket
.
from
)
.
thread
;
let
resumption
=
{
from
:
thread
.
_actor
type
:
"
resumed
"
}
;
thread
.
_onThreadState
(
resumption
)
;
}
}
if
(
aPacket
.
type
)
{
this
.
emit
(
aPacket
.
type
aPacket
)
;
}
if
(
activeRequest
)
{
let
emitReply
=
(
)
=
>
activeRequest
.
emit
(
"
json
-
reply
"
aPacket
)
;
if
(
activeRequest
.
stack
)
{
Cu
.
callFunctionWithAsyncStack
(
emitReply
activeRequest
.
stack
"
DevTools
RDP
"
)
;
}
else
{
emitReply
(
)
;
}
}
}
onBulkPacket
:
function
(
packet
)
{
let
{
actor
type
length
}
=
packet
;
if
(
!
actor
)
{
DevToolsUtils
.
reportException
(
"
onBulkPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
bulk
packet
:
"
+
JSON
.
stringify
(
packet
)
)
)
;
return
;
}
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
let
activeRequest
=
this
.
_activeRequests
.
get
(
actor
)
;
this
.
_activeRequests
.
delete
(
actor
)
;
this
.
_attemptNextRequest
(
actor
)
;
activeRequest
.
emit
(
"
bulk
-
reply
"
packet
)
;
}
onClosed
:
function
(
aStatus
)
{
this
.
_closed
=
true
;
this
.
emit
(
"
closed
"
)
;
let
reject
=
function
(
type
request
actor
)
{
let
msg
;
if
(
request
.
request
)
{
msg
=
"
'
"
+
request
.
request
.
type
+
"
'
"
+
type
+
"
request
packet
"
+
"
to
'
"
+
actor
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
just
closed
.
"
;
}
else
{
msg
=
"
server
side
packet
from
'
"
+
actor
+
"
'
can
'
t
be
received
"
+
"
as
the
connection
just
closed
.
"
;
}
let
packet
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
request
.
emit
(
"
json
-
reply
"
packet
)
;
}
;
let
pendingRequests
=
new
Map
(
this
.
_pendingRequests
)
;
this
.
_pendingRequests
.
clear
(
)
;
pendingRequests
.
forEach
(
(
list
actor
)
=
>
{
list
.
forEach
(
request
=
>
reject
(
"
pending
"
request
actor
)
)
;
}
)
;
let
activeRequests
=
new
Map
(
this
.
_activeRequests
)
;
this
.
_activeRequests
.
clear
(
)
;
activeRequests
.
forEach
(
reject
.
bind
(
null
"
active
"
)
)
;
for
(
let
pool
of
this
.
_pools
)
{
pool
.
cleanup
(
)
;
}
}
registerClient
:
function
(
client
)
{
let
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
actor
attribute
.
"
)
;
}
if
(
!
Array
.
isArray
(
client
.
events
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
events
attribute
"
+
"
that
is
an
array
.
"
)
;
}
if
(
client
.
events
.
length
>
0
&
&
typeof
(
client
.
emit
)
!
=
"
function
"
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
non
-
empty
events
array
to
"
+
"
have
an
emit
function
.
"
)
;
}
if
(
this
.
_clients
.
has
(
actorID
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
already
registered
"
+
"
a
client
for
this
actor
.
"
)
;
}
this
.
_clients
.
set
(
actorID
client
)
;
}
unregisterClient
:
function
(
client
)
{
let
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
unregisterClient
expects
"
+
"
a
Client
instance
with
a
actor
attribute
.
"
)
;
}
this
.
_clients
.
delete
(
actorID
)
;
}
__pools
:
null
get
_pools
(
)
{
if
(
this
.
__pools
)
{
return
this
.
__pools
;
}
this
.
__pools
=
new
Set
(
)
;
return
this
.
__pools
;
}
addActorPool
:
function
(
pool
)
{
this
.
_pools
.
add
(
pool
)
;
}
removeActorPool
:
function
(
pool
)
{
this
.
_pools
.
delete
(
pool
)
;
}
getActor
:
function
(
actorID
)
{
let
pool
=
this
.
poolFor
(
actorID
)
;
return
pool
?
pool
.
get
(
actorID
)
:
null
;
}
poolFor
:
function
(
actorID
)
{
for
(
let
pool
of
this
.
_pools
)
{
if
(
pool
.
has
(
actorID
)
)
return
pool
;
}
return
null
;
}
activeAddon
:
null
}
eventSource
(
DebuggerClient
.
prototype
)
;
function
Request
(
request
)
{
this
.
request
=
request
;
}
Request
.
prototype
=
{
on
:
function
(
type
listener
)
{
events
.
on
(
this
type
listener
)
;
}
off
:
function
(
type
listener
)
{
events
.
off
(
this
type
listener
)
;
}
once
:
function
(
type
listener
)
{
events
.
once
(
this
type
listener
)
;
}
emit
:
function
(
type
.
.
.
args
)
{
events
.
emit
(
this
type
.
.
.
args
)
;
}
get
actor
(
)
{
return
this
.
request
.
to
|
|
this
.
request
.
actor
;
}
}
;
function
TabClient
(
aClient
aForm
)
{
this
.
client
=
aClient
;
this
.
_actor
=
aForm
.
from
;
this
.
_threadActor
=
aForm
.
threadActor
;
this
.
javascriptEnabled
=
aForm
.
javascriptEnabled
;
this
.
cacheDisabled
=
aForm
.
cacheDisabled
;
this
.
thread
=
null
;
this
.
request
=
this
.
client
.
request
;
this
.
traits
=
aForm
.
traits
|
|
{
}
;
this
.
events
=
[
"
workerListChanged
"
]
;
}
TabClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
attachThread
:
function
(
aOptions
=
{
}
aOnResponse
=
noop
)
{
if
(
this
.
thread
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
{
}
this
.
thread
)
)
;
return
promise
.
resolve
(
[
{
}
this
.
thread
]
)
;
}
let
packet
=
{
to
:
this
.
_threadActor
type
:
"
attach
"
options
:
aOptions
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
this
.
thread
=
new
ThreadClient
(
this
this
.
_threadActor
)
;
this
.
client
.
registerClient
(
this
.
thread
)
;
}
aOnResponse
(
aResponse
this
.
thread
)
;
return
[
aResponse
this
.
thread
]
;
}
)
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
thread
)
{
this
.
thread
.
detach
(
)
;
}
return
aPacket
;
}
after
:
function
(
aResponse
)
{
this
.
client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
TABDETACH
"
}
)
focus
:
DebuggerClient
.
requester
(
{
type
:
"
focus
"
}
{
}
)
reload
:
function
(
options
=
{
force
:
false
}
)
{
return
this
.
_reload
(
options
)
;
}
_reload
:
DebuggerClient
.
requester
(
{
type
:
"
reload
"
options
:
args
(
0
)
}
{
telemetry
:
"
RELOAD
"
}
)
navigateTo
:
DebuggerClient
.
requester
(
{
type
:
"
navigateTo
"
url
:
args
(
0
)
}
{
telemetry
:
"
NAVIGATETO
"
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
args
(
0
)
}
{
telemetry
:
"
RECONFIGURETAB
"
}
)
listWorkers
:
DebuggerClient
.
requester
(
{
type
:
"
listWorkers
"
}
{
telemetry
:
"
LISTWORKERS
"
}
)
attachWorker
:
function
(
aWorkerActor
aOnResponse
)
{
this
.
client
.
attachWorker
(
aWorkerActor
aOnResponse
)
;
}
resolveLocation
:
DebuggerClient
.
requester
(
{
type
:
"
resolveLocation
"
location
:
args
(
0
)
}
)
}
;
eventSource
(
TabClient
.
prototype
)
;
function
WorkerClient
(
aClient
aForm
)
{
this
.
client
=
aClient
;
this
.
_actor
=
aForm
.
from
;
this
.
_isClosed
=
false
;
this
.
_url
=
aForm
.
url
;
this
.
_onClose
=
this
.
_onClose
.
bind
(
this
)
;
this
.
addListener
(
"
close
"
this
.
_onClose
)
;
this
.
traits
=
{
}
;
}
WorkerClient
.
prototype
=
{
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
get
request
(
)
{
return
this
.
client
.
request
;
}
get
actor
(
)
{
return
this
.
_actor
;
}
get
url
(
)
{
return
this
.
_url
;
}
get
isClosed
(
)
{
return
this
.
_isClosed
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
if
(
this
.
thread
)
{
this
.
client
.
unregisterClient
(
this
.
thread
)
;
}
this
.
client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
WORKERDETACH
"
}
)
attachThread
:
function
(
aOptions
=
{
}
aOnResponse
=
noop
)
{
if
(
this
.
thread
)
{
let
response
=
[
{
type
:
"
connected
"
threadActor
:
this
.
thread
.
_actor
consoleActor
:
this
.
consoleActor
}
this
.
thread
]
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
response
)
)
;
return
response
;
}
return
this
.
request
(
{
to
:
this
.
_actor
type
:
"
connect
"
options
:
aOptions
}
)
.
then
(
connectReponse
=
>
{
if
(
connectReponse
.
error
)
{
aOnResponse
(
connectReponse
null
)
;
return
[
connectResponse
null
]
;
}
return
this
.
request
(
{
to
:
connectReponse
.
threadActor
type
:
"
attach
"
options
:
aOptions
}
)
.
then
(
attachResponse
=
>
{
if
(
attachResponse
.
error
)
{
aOnResponse
(
attachResponse
null
)
;
}
this
.
thread
=
new
ThreadClient
(
this
connectReponse
.
threadActor
)
;
this
.
consoleActor
=
connectReponse
.
consoleActor
;
this
.
client
.
registerClient
(
this
.
thread
)
;
aOnResponse
(
connectReponse
this
.
thread
)
;
return
[
connectResponse
this
.
thread
]
;
}
)
;
}
)
;
}
_onClose
:
function
(
)
{
this
.
removeListener
(
"
close
"
this
.
_onClose
)
;
if
(
this
.
thread
)
{
this
.
client
.
unregisterClient
(
this
.
thread
)
;
}
this
.
client
.
unregisterClient
(
this
)
;
this
.
_isClosed
=
true
;
}
reconfigure
:
function
(
)
{
return
Promise
.
resolve
(
)
;
}
events
:
[
"
close
"
]
}
;
eventSource
(
WorkerClient
.
prototype
)
;
function
AddonClient
(
aClient
aActor
)
{
this
.
_client
=
aClient
;
this
.
_actor
=
aActor
;
this
.
request
=
this
.
_client
.
request
;
this
.
events
=
[
]
;
}
AddonClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
if
(
this
.
_client
.
activeAddon
=
=
=
this
)
{
this
.
_client
.
activeAddon
=
null
}
this
.
_client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
ADDONDETACH
"
}
)
}
;
function
RootClient
(
aClient
aGreeting
)
{
this
.
_client
=
aClient
;
this
.
actor
=
aGreeting
.
from
;
this
.
applicationType
=
aGreeting
.
applicationType
;
this
.
traits
=
aGreeting
.
traits
;
}
exports
.
RootClient
=
RootClient
;
RootClient
.
prototype
=
{
constructor
:
RootClient
listTabs
:
DebuggerClient
.
requester
(
{
type
:
"
listTabs
"
}
{
telemetry
:
"
LISTTABS
"
}
)
listAddons
:
DebuggerClient
.
requester
(
{
type
:
"
listAddons
"
}
{
telemetry
:
"
LISTADDONS
"
}
)
listWorkers
:
DebuggerClient
.
requester
(
{
type
:
"
listWorkers
"
}
{
telemetry
:
"
LISTWORKERS
"
}
)
listServiceWorkerRegistrations
:
DebuggerClient
.
requester
(
{
type
:
"
listServiceWorkerRegistrations
"
}
{
telemetry
:
"
LISTSERVICEWORKERREGISTRATIONS
"
}
)
listProcesses
:
DebuggerClient
.
requester
(
{
type
:
"
listProcesses
"
}
{
telemetry
:
"
LISTPROCESSES
"
}
)
getTab
:
function
(
aFilter
)
{
let
packet
=
{
to
:
this
.
actor
type
:
"
getTab
"
}
;
if
(
aFilter
)
{
if
(
typeof
(
aFilter
.
outerWindowID
)
=
=
"
number
"
)
{
packet
.
outerWindowID
=
aFilter
.
outerWindowID
;
}
else
if
(
typeof
(
aFilter
.
tabId
)
=
=
"
number
"
)
{
packet
.
tabId
=
aFilter
.
tabId
;
}
else
if
(
"
tab
"
in
aFilter
)
{
let
browser
=
aFilter
.
tab
.
linkedBrowser
;
if
(
browser
.
frameLoader
.
tabParent
)
{
packet
.
tabId
=
browser
.
frameLoader
.
tabParent
.
tabId
;
}
else
{
let
windowUtils
=
browser
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
packet
.
outerWindowID
=
windowUtils
.
outerWindowID
;
}
}
else
{
throw
new
Error
(
"
Unsupported
argument
given
to
getTab
request
"
)
;
}
}
return
this
.
request
(
packet
)
;
}
protocolDescription
:
DebuggerClient
.
requester
(
{
type
:
"
protocolDescription
"
}
{
telemetry
:
"
PROTOCOLDESCRIPTION
"
}
)
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
}
;
function
ThreadClient
(
aClient
aActor
)
{
this
.
_parent
=
aClient
;
this
.
client
=
aClient
instanceof
DebuggerClient
?
aClient
:
aClient
.
client
;
this
.
_actor
=
aActor
;
this
.
_frameCache
=
[
]
;
this
.
_scriptCache
=
{
}
;
this
.
_pauseGrips
=
{
}
;
this
.
_threadGrips
=
{
}
;
this
.
request
=
this
.
client
.
request
;
}
ThreadClient
.
prototype
=
{
_state
:
"
paused
"
get
state
(
)
{
return
this
.
_state
;
}
get
paused
(
)
{
return
this
.
_state
=
=
=
"
paused
"
;
}
_pauseOnExceptions
:
false
_ignoreCaughtExceptions
:
false
_pauseOnDOMEvents
:
null
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
_assertPaused
:
function
(
aCommand
)
{
if
(
!
this
.
paused
)
{
throw
Error
(
aCommand
+
"
command
sent
while
not
paused
.
Currently
"
+
this
.
_state
)
;
}
}
_doResume
:
DebuggerClient
.
requester
(
{
type
:
"
resume
"
resumeLimit
:
args
(
0
)
}
{
before
:
function
(
aPacket
)
{
this
.
_assertPaused
(
"
resume
"
)
;
this
.
_state
=
"
resuming
"
;
if
(
this
.
_pauseOnExceptions
)
{
aPacket
.
pauseOnExceptions
=
this
.
_pauseOnExceptions
;
}
if
(
this
.
_ignoreCaughtExceptions
)
{
aPacket
.
ignoreCaughtExceptions
=
this
.
_ignoreCaughtExceptions
;
}
if
(
this
.
_pauseOnDOMEvents
)
{
aPacket
.
pauseOnDOMEvents
=
this
.
_pauseOnDOMEvents
;
}
return
aPacket
;
}
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
this
.
_state
=
"
paused
"
;
}
return
aResponse
;
}
telemetry
:
"
RESUME
"
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
args
(
0
)
}
{
telemetry
:
"
RECONFIGURETHREAD
"
}
)
resume
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
null
aOnResponse
)
;
}
resumeThenPause
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
break
"
}
aOnResponse
)
;
}
stepOver
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
aOnResponse
)
;
}
stepIn
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
step
"
}
aOnResponse
)
;
}
stepOut
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
finish
"
}
aOnResponse
)
;
}
interrupt
:
function
(
aOnResponse
)
{
return
this
.
_doInterrupt
(
null
aOnResponse
)
;
}
breakOnNext
:
function
(
aOnResponse
)
{
return
this
.
_doInterrupt
(
"
onNext
"
aOnResponse
)
;
}
_doInterrupt
:
DebuggerClient
.
requester
(
{
type
:
"
interrupt
"
when
:
args
(
0
)
}
{
telemetry
:
"
INTERRUPT
"
}
)
pauseOnExceptions
:
function
(
aPauseOnExceptions
aIgnoreCaughtExceptions
aOnResponse
=
noop
)
{
this
.
_pauseOnExceptions
=
aPauseOnExceptions
;
this
.
_ignoreCaughtExceptions
=
aIgnoreCaughtExceptions
;
if
(
!
this
.
paused
)
{
return
this
.
interrupt
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
aOnResponse
(
aResponse
)
;
return
aResponse
;
}
return
this
.
resume
(
aOnResponse
)
;
}
)
;
}
aOnResponse
(
)
;
return
promise
.
resolve
(
)
;
}
pauseOnDOMEvents
:
function
(
events
onResponse
=
noop
)
{
this
.
_pauseOnDOMEvents
=
events
;
if
(
this
.
paused
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
)
)
;
return
{
}
;
}
return
this
.
interrupt
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
)
;
return
response
;
}
return
this
.
resume
(
onResponse
)
;
}
)
;
}
eval
:
DebuggerClient
.
requester
(
{
type
:
"
clientEvaluate
"
frame
:
args
(
0
)
expression
:
args
(
1
)
}
{
before
:
function
(
aPacket
)
{
this
.
_assertPaused
(
"
eval
"
)
;
this
.
_state
=
"
resuming
"
;
return
aPacket
;
}
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
this
.
_state
=
"
paused
"
;
}
return
aResponse
;
}
telemetry
:
"
CLIENTEVALUATE
"
}
)
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
this
.
client
.
unregisterClient
(
this
)
;
this
.
_parent
.
thread
=
null
;
return
aResponse
;
}
telemetry
:
"
THREADDETACH
"
}
)
releaseMany
:
DebuggerClient
.
requester
(
{
type
:
"
releaseMany
"
actors
:
args
(
0
)
}
{
telemetry
:
"
RELEASEMANY
"
}
)
threadGrips
:
DebuggerClient
.
requester
(
{
type
:
"
threadGrips
"
actors
:
args
(
0
)
}
{
telemetry
:
"
THREADGRIPS
"
}
)
eventListeners
:
DebuggerClient
.
requester
(
{
type
:
"
eventListeners
"
}
{
telemetry
:
"
EVENTLISTENERS
"
}
)
getSources
:
DebuggerClient
.
requester
(
{
type
:
"
sources
"
}
{
telemetry
:
"
SOURCES
"
}
)
_clearScripts
:
function
(
)
{
if
(
Object
.
keys
(
this
.
_scriptCache
)
.
length
>
0
)
{
this
.
_scriptCache
=
{
}
this
.
emit
(
"
scriptscleared
"
)
;
}
}
getFrames
:
DebuggerClient
.
requester
(
{
type
:
"
frames
"
start
:
args
(
0
)
count
:
args
(
1
)
}
{
telemetry
:
"
FRAMES
"
}
)
get
cachedFrames
(
)
{
return
this
.
_frameCache
;
}
get
moreFrames
(
)
{
return
this
.
paused
&
&
(
!
this
.
_frameCache
|
|
this
.
_frameCache
.
length
=
=
0
|
|
!
this
.
_frameCache
[
this
.
_frameCache
.
length
-
1
]
.
oldest
)
;
}
fillFrames
:
function
(
aTotal
aCallback
=
noop
)
{
this
.
_assertPaused
(
"
fillFrames
"
)
;
if
(
this
.
_frameCache
.
length
>
=
aTotal
)
{
return
false
;
}
let
numFrames
=
this
.
_frameCache
.
length
;
this
.
getFrames
(
numFrames
aTotal
-
numFrames
(
aResponse
)
=
>
{
if
(
aResponse
.
error
)
{
aCallback
(
aResponse
)
;
return
;
}
let
threadGrips
=
DevToolsUtils
.
values
(
this
.
_threadGrips
)
;
for
(
let
i
in
aResponse
.
frames
)
{
let
frame
=
aResponse
.
frames
[
i
]
;
if
(
!
frame
.
where
.
source
)
{
for
(
let
grip
of
threadGrips
)
{
if
(
grip
instanceof
SourceClient
&
&
grip
.
url
=
=
=
frame
.
url
)
{
frame
.
where
.
source
=
grip
.
_form
;
}
}
}
this
.
_frameCache
[
frame
.
depth
]
=
frame
;
}
this
.
emit
(
"
framesadded
"
)
;
aCallback
(
aResponse
)
;
}
)
;
return
true
;
}
_clearFrames
:
function
(
)
{
if
(
this
.
_frameCache
.
length
>
0
)
{
this
.
_frameCache
=
[
]
;
this
.
emit
(
"
framescleared
"
)
;
}
}
pauseGrip
:
function
(
aGrip
)
{
if
(
aGrip
.
actor
in
this
.
_pauseGrips
)
{
return
this
.
_pauseGrips
[
aGrip
.
actor
]
;
}
let
client
=
new
ObjectClient
(
this
.
client
aGrip
)
;
this
.
_pauseGrips
[
aGrip
.
actor
]
=
client
;
return
client
;
}
_longString
:
function
(
aGrip
aGripCacheName
)
{
if
(
aGrip
.
actor
in
this
[
aGripCacheName
]
)
{
return
this
[
aGripCacheName
]
[
aGrip
.
actor
]
;
}
let
client
=
new
LongStringClient
(
this
.
client
aGrip
)
;
this
[
aGripCacheName
]
[
aGrip
.
actor
]
=
client
;
return
client
;
}
pauseLongString
:
function
(
aGrip
)
{
return
this
.
_longString
(
aGrip
"
_pauseGrips
"
)
;
}
threadLongString
:
function
(
aGrip
)
{
return
this
.
_longString
(
aGrip
"
_threadGrips
"
)
;
}
_clearObjectClients
:
function
(
aGripCacheName
)
{
for
(
let
id
in
this
[
aGripCacheName
]
)
{
this
[
aGripCacheName
]
[
id
]
.
valid
=
false
;
}
this
[
aGripCacheName
]
=
{
}
;
}
_clearPauseGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_pauseGrips
"
)
;
}
_clearThreadGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_threadGrips
"
)
;
}
_onThreadState
:
function
(
aPacket
)
{
this
.
_state
=
ThreadStateTypes
[
aPacket
.
type
]
;
this
.
_lastPausePacket
=
aPacket
.
type
=
=
=
'
resumed
'
?
null
:
aPacket
;
this
.
_clearFrames
(
)
;
this
.
_clearPauseGrips
(
)
;
aPacket
.
type
=
=
=
ThreadStateTypes
.
detached
&
&
this
.
_clearThreadGrips
(
)
;
this
.
client
.
_eventsEnabled
&
&
this
.
emit
(
aPacket
.
type
aPacket
)
;
}
getLastPausePacket
:
function
(
)
{
return
this
.
_lastPausePacket
;
}
environment
:
function
(
aForm
)
{
return
new
EnvironmentClient
(
this
.
client
aForm
)
;
}
source
:
function
(
aForm
)
{
if
(
aForm
.
actor
in
this
.
_threadGrips
)
{
return
this
.
_threadGrips
[
aForm
.
actor
]
;
}
return
this
.
_threadGrips
[
aForm
.
actor
]
=
new
SourceClient
(
this
aForm
)
;
}
getPrototypesAndProperties
:
DebuggerClient
.
requester
(
{
type
:
"
prototypesAndProperties
"
actors
:
args
(
0
)
}
{
telemetry
:
"
PROTOTYPESANDPROPERTIES
"
}
)
events
:
[
"
newSource
"
]
}
;
eventSource
(
ThreadClient
.
prototype
)
;
function
TraceClient
(
aClient
aActor
)
{
this
.
_client
=
aClient
;
this
.
_actor
=
aActor
;
this
.
_activeTraces
=
new
Set
(
)
;
this
.
_waitingPackets
=
new
Map
(
)
;
this
.
_expectedPacket
=
0
;
this
.
request
=
this
.
_client
.
request
;
this
.
events
=
[
]
;
}
TraceClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
;
}
get
tracing
(
)
{
return
this
.
_activeTraces
.
size
>
0
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
this
.
_client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
TRACERDETACH
"
}
)
startTrace
:
DebuggerClient
.
requester
(
{
type
:
"
startTrace
"
name
:
args
(
1
)
trace
:
args
(
0
)
}
{
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
return
aResponse
;
}
if
(
!
this
.
tracing
)
{
this
.
_waitingPackets
.
clear
(
)
;
this
.
_expectedPacket
=
0
;
}
this
.
_activeTraces
.
add
(
aResponse
.
name
)
;
return
aResponse
;
}
telemetry
:
"
STARTTRACE
"
}
)
stopTrace
:
DebuggerClient
.
requester
(
{
type
:
"
stopTrace
"
name
:
args
(
0
)
}
{
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
return
aResponse
;
}
this
.
_activeTraces
.
delete
(
aResponse
.
name
)
;
return
aResponse
;
}
telemetry
:
"
STOPTRACE
"
}
)
}
;
function
ObjectClient
(
aClient
aGrip
)
{
this
.
_grip
=
aGrip
;
this
.
_client
=
aClient
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
ObjectClient
=
ObjectClient
;
ObjectClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
valid
:
true
get
isFrozen
(
)
{
return
this
.
_grip
.
frozen
;
}
get
isSealed
(
)
{
return
this
.
_grip
.
sealed
;
}
get
isExtensible
(
)
{
return
this
.
_grip
.
extensible
;
}
getDefinitionSite
:
DebuggerClient
.
requester
(
{
type
:
"
definitionSite
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
"
Function
"
)
{
throw
new
Error
(
"
getDefinitionSite
is
only
valid
for
function
grips
.
"
)
;
}
return
aPacket
;
}
}
)
getParameterNames
:
DebuggerClient
.
requester
(
{
type
:
"
parameterNames
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
[
"
class
"
]
!
=
=
"
Function
"
)
{
throw
new
Error
(
"
getParameterNames
is
only
valid
for
function
grips
.
"
)
;
}
return
aPacket
;
}
telemetry
:
"
PARAMETERNAMES
"
}
)
getOwnPropertyNames
:
DebuggerClient
.
requester
(
{
type
:
"
ownPropertyNames
"
}
{
telemetry
:
"
OWNPROPERTYNAMES
"
}
)
getPrototypeAndProperties
:
DebuggerClient
.
requester
(
{
type
:
"
prototypeAndProperties
"
}
{
telemetry
:
"
PROTOTYPEANDPROPERTIES
"
}
)
enumProperties
:
DebuggerClient
.
requester
(
{
type
:
"
enumProperties
"
options
:
args
(
0
)
}
{
after
:
function
(
aResponse
)
{
if
(
aResponse
.
iterator
)
{
return
{
iterator
:
new
PropertyIteratorClient
(
this
.
_client
aResponse
.
iterator
)
}
;
}
return
aResponse
;
}
telemetry
:
"
ENUMPROPERTIES
"
}
)
enumEntries
:
DebuggerClient
.
requester
(
{
type
:
"
enumEntries
"
}
{
before
:
function
(
packet
)
{
if
(
!
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
this
.
_grip
.
class
)
)
{
throw
new
Error
(
"
enumEntries
is
only
valid
for
Map
/
Set
-
like
grips
.
"
)
;
}
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
iterator
)
{
return
{
iterator
:
new
PropertyIteratorClient
(
this
.
_client
response
.
iterator
)
}
;
}
return
response
;
}
}
)
getProperty
:
DebuggerClient
.
requester
(
{
type
:
"
property
"
name
:
args
(
0
)
}
{
telemetry
:
"
PROPERTY
"
}
)
getPrototype
:
DebuggerClient
.
requester
(
{
type
:
"
prototype
"
}
{
telemetry
:
"
PROTOTYPE
"
}
)
getDisplayString
:
DebuggerClient
.
requester
(
{
type
:
"
displayString
"
}
{
telemetry
:
"
DISPLAYSTRING
"
}
)
getScope
:
DebuggerClient
.
requester
(
{
type
:
"
scope
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Function
"
)
{
throw
new
Error
(
"
scope
is
only
valid
for
function
grips
.
"
)
;
}
return
aPacket
;
}
telemetry
:
"
SCOPE
"
}
)
getDependentPromises
:
DebuggerClient
.
requester
(
{
type
:
"
dependentPromises
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getDependentPromises
is
only
valid
for
promise
"
+
"
grips
.
"
)
;
}
return
aPacket
;
}
}
)
getPromiseAllocationStack
:
DebuggerClient
.
requester
(
{
type
:
"
allocationStack
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getAllocationStack
is
only
valid
for
promise
grips
.
"
)
;
}
return
aPacket
;
}
}
)
getPromiseFulfillmentStack
:
DebuggerClient
.
requester
(
{
type
:
"
fulfillmentStack
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getPromiseFulfillmentStack
is
only
valid
for
"
+
"
promise
grips
.
"
)
;
}
return
packet
;
}
}
)
getPromiseRejectionStack
:
DebuggerClient
.
requester
(
{
type
:
"
rejectionStack
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getPromiseRejectionStack
is
only
valid
for
"
+
"
promise
grips
.
"
)
;
}
return
packet
;
}
}
)
}
;
function
PropertyIteratorClient
(
aClient
aGrip
)
{
this
.
_grip
=
aGrip
;
this
.
_client
=
aClient
;
this
.
request
=
this
.
_client
.
request
;
}
PropertyIteratorClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
;
}
get
count
(
)
{
return
this
.
_grip
.
count
;
}
names
:
DebuggerClient
.
requester
(
{
type
:
"
names
"
indexes
:
args
(
0
)
}
{
}
)
slice
:
DebuggerClient
.
requester
(
{
type
:
"
slice
"
start
:
args
(
0
)
count
:
args
(
1
)
}
{
}
)
all
:
DebuggerClient
.
requester
(
{
type
:
"
all
"
}
{
}
)
}
;
function
LongStringClient
(
aClient
aGrip
)
{
this
.
_grip
=
aGrip
;
this
.
_client
=
aClient
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
LongStringClient
=
LongStringClient
;
LongStringClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
;
}
get
length
(
)
{
return
this
.
_grip
.
length
;
}
get
initial
(
)
{
return
this
.
_grip
.
initial
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
valid
:
true
substring
:
DebuggerClient
.
requester
(
{
type
:
"
substring
"
start
:
args
(
0
)
end
:
args
(
1
)
}
{
telemetry
:
"
SUBSTRING
"
}
)
}
;
function
SourceClient
(
aClient
aForm
)
{
this
.
_form
=
aForm
;
this
.
_isBlackBoxed
=
aForm
.
isBlackBoxed
;
this
.
_isPrettyPrinted
=
aForm
.
isPrettyPrinted
;
this
.
_activeThread
=
aClient
;
this
.
_client
=
aClient
.
client
;
}
SourceClient
.
prototype
=
{
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
isBlackBoxed
(
)
{
return
this
.
_isBlackBoxed
;
}
get
isPrettyPrinted
(
)
{
return
this
.
_isPrettyPrinted
;
}
get
actor
(
)
{
return
this
.
_form
.
actor
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
get
url
(
)
{
return
this
.
_form
.
url
;
}
blackBox
:
DebuggerClient
.
requester
(
{
type
:
"
blackbox
"
}
{
telemetry
:
"
BLACKBOX
"
after
:
function
(
aResponse
)
{
if
(
!
aResponse
.
error
)
{
this
.
_isBlackBoxed
=
true
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
aResponse
;
}
}
)
unblackBox
:
DebuggerClient
.
requester
(
{
type
:
"
unblackbox
"
}
{
telemetry
:
"
UNBLACKBOX
"
after
:
function
(
aResponse
)
{
if
(
!
aResponse
.
error
)
{
this
.
_isBlackBoxed
=
false
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
aResponse
;
}
}
)
getExecutableLines
:
function
(
cb
=
noop
)
{
let
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
getExecutableLines
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
res
=
>
{
cb
(
res
.
lines
)
;
return
res
.
lines
;
}
)
;
}
source
:
function
(
aCallback
=
noop
)
{
let
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
source
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
return
this
.
_onSourceResponse
(
aResponse
aCallback
)
}
)
;
}
prettyPrint
:
function
(
aIndent
aCallback
=
noop
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
prettyPrint
"
indent
:
aIndent
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
this
.
_isPrettyPrinted
=
true
;
this
.
_activeThread
.
_clearFrames
(
)
;
this
.
_activeThread
.
emit
(
"
prettyprintchange
"
this
)
;
}
return
this
.
_onSourceResponse
(
aResponse
aCallback
)
;
}
)
;
}
disablePrettyPrint
:
function
(
aCallback
=
noop
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
disablePrettyPrint
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
this
.
_isPrettyPrinted
=
false
;
this
.
_activeThread
.
_clearFrames
(
)
;
this
.
_activeThread
.
emit
(
"
prettyprintchange
"
this
)
;
}
return
this
.
_onSourceResponse
(
aResponse
aCallback
)
;
}
)
;
}
_onSourceResponse
:
function
(
aResponse
aCallback
)
{
if
(
aResponse
.
error
)
{
aCallback
(
aResponse
)
;
return
aResponse
;
}
if
(
typeof
aResponse
.
source
=
=
=
"
string
"
)
{
aCallback
(
aResponse
)
;
return
aResponse
;
}
let
{
contentType
source
}
=
aResponse
;
let
longString
=
this
.
_activeThread
.
threadLongString
(
source
)
;
return
longString
.
substring
(
0
longString
.
length
)
.
then
(
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
aCallback
(
aResponse
)
;
return
aReponse
;
}
let
response
=
{
source
:
aResponse
.
substring
contentType
:
contentType
}
;
aCallback
(
response
)
;
return
response
;
}
)
;
}
setBreakpoint
:
function
(
{
line
column
condition
}
aOnResponse
=
noop
)
{
let
doSetBreakpoint
=
aCallback
=
>
{
let
root
=
this
.
_client
.
mainRoot
;
let
location
=
{
line
:
line
column
:
column
}
;
let
packet
=
{
to
:
this
.
actor
type
:
"
setBreakpoint
"
location
:
location
condition
:
condition
}
;
if
(
!
root
.
traits
.
debuggerSourceActors
)
{
packet
.
to
=
this
.
_activeThread
.
actor
;
packet
.
location
.
url
=
this
.
url
;
}
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
bpClient
;
if
(
aResponse
.
actor
)
{
bpClient
=
new
BreakpointClient
(
this
.
_client
this
aResponse
.
actor
location
root
.
traits
.
conditionalBreakpoints
?
condition
:
undefined
)
;
}
aOnResponse
(
aResponse
bpClient
)
;
if
(
aCallback
)
{
aCallback
(
)
;
}
return
[
aResponse
bpClient
]
;
}
)
;
}
;
if
(
this
.
_activeThread
.
paused
)
{
return
doSetBreakpoint
(
)
;
}
return
this
.
_activeThread
.
interrupt
(
)
.
then
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
aOnResponse
(
aResponse
)
;
return
aResponse
;
}
const
{
type
why
}
=
aResponse
;
const
cleanUp
=
type
=
=
"
paused
"
&
&
why
.
type
=
=
"
interrupted
"
?
(
)
=
>
this
.
_activeThread
.
resume
(
)
:
noop
;
return
doSetBreakpoint
(
cleanUp
)
;
}
)
;
}
}
;
function
BreakpointClient
(
aClient
aSourceClient
aActor
aLocation
aCondition
)
{
this
.
_client
=
aClient
;
this
.
_actor
=
aActor
;
this
.
location
=
aLocation
;
this
.
location
.
actor
=
aSourceClient
.
actor
;
this
.
location
.
url
=
aSourceClient
.
url
;
this
.
source
=
aSourceClient
;
this
.
request
=
this
.
_client
.
request
;
if
(
aCondition
)
{
this
.
condition
=
aCondition
;
}
}
BreakpointClient
.
prototype
=
{
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
remove
:
DebuggerClient
.
requester
(
{
type
:
"
delete
"
}
{
telemetry
:
"
DELETE
"
}
)
hasCondition
:
function
(
)
{
let
root
=
this
.
_client
.
mainRoot
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
return
"
condition
"
in
this
;
}
else
{
return
"
conditionalExpression
"
in
this
;
}
}
getCondition
:
function
(
)
{
let
root
=
this
.
_client
.
mainRoot
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
return
this
.
condition
;
}
else
{
return
this
.
conditionalExpression
;
}
}
setCondition
:
function
(
gThreadClient
aCondition
)
{
let
root
=
this
.
_client
.
mainRoot
;
let
deferred
=
promise
.
defer
(
)
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
let
info
=
{
line
:
this
.
location
.
line
column
:
this
.
location
.
column
condition
:
aCondition
}
;
this
.
remove
(
aResponse
=
>
{
if
(
aResponse
&
&
aResponse
.
error
)
{
deferred
.
reject
(
aResponse
)
;
return
;
}
this
.
source
.
setBreakpoint
(
info
(
aResponse
aNewBreakpoint
)
=
>
{
if
(
aResponse
&
&
aResponse
.
error
)
{
deferred
.
reject
(
aResponse
)
;
}
else
{
deferred
.
resolve
(
aNewBreakpoint
)
;
}
}
)
;
}
)
;
}
else
{
if
(
aCondition
=
=
=
"
"
)
{
delete
this
.
conditionalExpression
;
}
else
{
this
.
conditionalExpression
=
aCondition
;
}
deferred
.
resolve
(
this
)
;
}
return
deferred
.
promise
;
}
}
;
eventSource
(
BreakpointClient
.
prototype
)
;
function
EnvironmentClient
(
aClient
aForm
)
{
this
.
_client
=
aClient
;
this
.
_form
=
aForm
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
EnvironmentClient
=
EnvironmentClient
;
EnvironmentClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_form
.
actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
getBindings
:
DebuggerClient
.
requester
(
{
type
:
"
bindings
"
}
{
telemetry
:
"
BINDINGS
"
}
)
assign
:
DebuggerClient
.
requester
(
{
type
:
"
assign
"
name
:
args
(
0
)
value
:
args
(
1
)
}
{
telemetry
:
"
ASSIGN
"
}
)
}
;
eventSource
(
EnvironmentClient
.
prototype
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
)
{
"
use
strict
"
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
UNCAUGHT_ERROR
=
'
An
error
event
was
emitted
for
which
there
was
no
listener
.
'
;
const
BAD_LISTENER
=
'
The
event
listener
must
be
a
function
.
'
;
const
{
ns
}
=
__webpack_require__
(
251
)
;
const
event
=
ns
(
)
;
const
EVENT_TYPE_PATTERN
=
/
^
on
(
[
A
-
Z
]
\
w
+
)
/
;
exports
.
EVENT_TYPE_PATTERN
=
EVENT_TYPE_PATTERN
;
const
observers
=
function
observers
(
target
type
)
{
if
(
!
target
)
throw
TypeError
(
"
Event
target
must
be
an
object
"
)
;
let
listeners
=
event
(
target
)
;
return
type
in
listeners
?
listeners
[
type
]
:
listeners
[
type
]
=
[
]
;
}
;
function
on
(
target
type
listener
)
{
if
(
typeof
(
listener
)
!
=
=
'
function
'
)
throw
new
Error
(
BAD_LISTENER
)
;
let
listeners
=
observers
(
target
type
)
;
if
(
!
~
listeners
.
indexOf
(
listener
)
)
listeners
.
push
(
listener
)
;
}
exports
.
on
=
on
;
var
onceWeakMap
=
new
WeakMap
(
)
;
function
once
(
target
type
listener
)
{
let
replacement
=
function
observer
(
.
.
.
args
)
{
off
(
target
type
observer
)
;
onceWeakMap
.
delete
(
listener
)
;
listener
.
apply
(
target
args
)
;
}
;
onceWeakMap
.
set
(
listener
replacement
)
;
on
(
target
type
replacement
)
;
}
exports
.
once
=
once
;
function
emit
(
target
type
.
.
.
args
)
{
emitOnObject
(
target
type
target
.
.
.
args
)
;
}
exports
.
emit
=
emit
;
function
emitOnObject
(
target
type
thisArg
.
.
.
args
)
{
let
all
=
observers
(
target
'
*
'
)
.
length
;
let
state
=
observers
(
target
type
)
;
let
listeners
=
state
.
slice
(
)
;
let
count
=
listeners
.
length
;
let
index
=
0
;
if
(
count
=
=
=
0
&
&
type
=
=
=
'
error
'
&
&
all
=
=
=
0
)
console
.
exception
(
args
[
0
]
)
;
while
(
index
<
count
)
{
try
{
let
listener
=
listeners
[
index
]
;
if
(
~
state
.
indexOf
(
listener
)
)
listener
.
apply
(
thisArg
args
)
;
}
catch
(
error
)
{
if
(
type
!
=
=
'
error
'
)
emit
(
target
'
error
'
error
)
;
else
console
.
exception
(
error
)
;
}
index
+
+
;
}
if
(
type
!
=
=
'
*
'
)
emit
(
target
'
*
'
type
.
.
.
args
)
;
}
exports
.
emitOnObject
=
emitOnObject
;
function
off
(
target
type
listener
)
{
let
length
=
arguments
.
length
;
if
(
length
=
=
=
3
)
{
if
(
onceWeakMap
.
has
(
listener
)
)
{
listener
=
onceWeakMap
.
get
(
listener
)
;
onceWeakMap
.
delete
(
listener
)
;
}
let
listeners
=
observers
(
target
type
)
;
let
index
=
listeners
.
indexOf
(
listener
)
;
if
(
~
index
)
listeners
.
splice
(
index
1
)
;
}
else
if
(
length
=
=
=
2
)
{
observers
(
target
type
)
.
splice
(
0
)
;
}
else
if
(
length
=
=
=
1
)
{
let
listeners
=
event
(
target
)
;
Object
.
keys
(
listeners
)
.
forEach
(
type
=
>
delete
listeners
[
type
]
)
;
}
}
exports
.
off
=
off
;
function
count
(
target
type
)
{
return
observers
(
target
type
)
.
length
;
}
exports
.
count
=
count
;
function
setListeners
(
target
listeners
)
{
Object
.
keys
(
listeners
|
|
{
}
)
.
forEach
(
key
=
>
{
let
match
=
EVENT_TYPE_PATTERN
.
exec
(
key
)
;
let
type
=
match
&
&
match
[
1
]
.
toLowerCase
(
)
;
if
(
!
type
)
return
;
let
listener
=
listeners
[
key
]
;
if
(
typeof
(
listener
)
=
=
=
'
function
'
)
on
(
target
type
listener
)
;
}
)
;
}
exports
.
setListeners
=
setListeners
;
}
.
call
(
exports
__webpack_require__
(
250
)
(
module
)
)
)
}
function
(
module
exports
)
{
module
.
exports
=
function
(
module
)
{
if
(
!
module
.
webpackPolyfill
)
{
module
.
deprecate
=
function
(
)
{
}
;
module
.
paths
=
[
]
;
module
.
children
=
[
]
;
module
.
webpackPolyfill
=
1
;
}
return
module
;
}
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
)
{
"
use
strict
"
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
create
=
Object
.
create
;
const
prototypeOf
=
Object
.
getPrototypeOf
;
function
ns
(
)
{
const
map
=
new
WeakMap
(
)
;
return
function
namespace
(
target
)
{
if
(
!
target
)
return
target
;
if
(
!
map
.
has
(
target
)
)
map
.
set
(
target
create
(
namespace
(
prototypeOf
(
target
)
|
|
null
)
)
)
;
return
map
.
get
(
target
)
;
}
;
}
;
exports
.
ns
=
ns
;
exports
.
Namespace
=
ns
;
}
.
call
(
exports
__webpack_require__
(
250
)
(
module
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
__webpack_require__
(
178
)
;
const
DevToolsUtils
=
__webpack_require__
(
177
)
;
const
EventEmitter
=
__webpack_require__
(
253
)
;
const
promise
=
__webpack_require__
(
189
)
;
const
{
LongStringClient
}
=
__webpack_require__
(
248
)
;
function
WebConsoleClient
(
aDebuggerClient
aResponse
)
{
this
.
_actor
=
aResponse
.
from
;
this
.
_client
=
aDebuggerClient
;
this
.
_longStrings
=
{
}
;
this
.
traits
=
aResponse
.
traits
|
|
{
}
;
this
.
events
=
[
]
;
this
.
_networkRequests
=
new
Map
(
)
;
this
.
pendingEvaluationResults
=
new
Map
(
)
;
this
.
onEvaluationResult
=
this
.
onEvaluationResult
.
bind
(
this
)
;
this
.
onNetworkEvent
=
this
.
_onNetworkEvent
.
bind
(
this
)
;
this
.
onNetworkEventUpdate
=
this
.
_onNetworkEventUpdate
.
bind
(
this
)
;
this
.
_client
.
addListener
(
"
evaluationResult
"
this
.
onEvaluationResult
)
;
this
.
_client
.
addListener
(
"
networkEvent
"
this
.
onNetworkEvent
)
;
this
.
_client
.
addListener
(
"
networkEventUpdate
"
this
.
onNetworkEventUpdate
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
WebConsoleClient
=
WebConsoleClient
;
WebConsoleClient
.
prototype
=
{
_longStrings
:
null
traits
:
null
_networkRequests
:
null
getNetworkRequest
(
actorId
)
{
return
this
.
_networkRequests
.
get
(
actorId
)
;
}
hasNetworkRequest
(
actorId
)
{
return
this
.
_networkRequests
.
has
(
actorId
)
;
}
removeNetworkRequest
(
actorId
)
{
this
.
_networkRequests
.
delete
(
actorId
)
;
}
getNetworkEvents
(
)
{
return
this
.
_networkRequests
.
values
(
)
;
}
get
actor
(
)
{
return
this
.
_actor
;
}
_onNetworkEvent
:
function
(
type
packet
)
{
if
(
packet
.
from
=
=
this
.
_actor
)
{
let
actor
=
packet
.
eventActor
;
let
networkInfo
=
{
_type
:
"
NetworkEvent
"
timeStamp
:
actor
.
timeStamp
node
:
null
actor
:
actor
.
actor
discardRequestBody
:
true
discardResponseBody
:
true
startedDateTime
:
actor
.
startedDateTime
request
:
{
url
:
actor
.
url
method
:
actor
.
method
}
isXHR
:
actor
.
isXHR
response
:
{
}
timings
:
{
}
updates
:
[
]
private
:
actor
.
private
fromCache
:
actor
.
fromCache
}
;
this
.
_networkRequests
.
set
(
actor
.
actor
networkInfo
)
;
this
.
emit
(
"
networkEvent
"
networkInfo
)
;
}
}
_onNetworkEventUpdate
:
function
(
type
packet
)
{
let
networkInfo
=
this
.
getNetworkRequest
(
packet
.
from
)
;
if
(
!
networkInfo
)
{
return
;
}
networkInfo
.
updates
.
push
(
packet
.
updateType
)
;
switch
(
packet
.
updateType
)
{
case
"
requestHeaders
"
:
networkInfo
.
request
.
headersSize
=
packet
.
headersSize
;
break
;
case
"
requestPostData
"
:
networkInfo
.
discardRequestBody
=
packet
.
discardRequestBody
;
networkInfo
.
request
.
bodySize
=
packet
.
dataSize
;
break
;
case
"
responseStart
"
:
networkInfo
.
response
.
httpVersion
=
packet
.
response
.
httpVersion
;
networkInfo
.
response
.
status
=
packet
.
response
.
status
;
networkInfo
.
response
.
statusText
=
packet
.
response
.
statusText
;
networkInfo
.
response
.
headersSize
=
packet
.
response
.
headersSize
;
networkInfo
.
response
.
remoteAddress
=
packet
.
response
.
remoteAddress
;
networkInfo
.
response
.
remotePort
=
packet
.
response
.
remotePort
;
networkInfo
.
discardResponseBody
=
packet
.
response
.
discardResponseBody
;
break
;
case
"
responseContent
"
:
networkInfo
.
response
.
content
=
{
mimeType
:
packet
.
mimeType
}
;
networkInfo
.
response
.
bodySize
=
packet
.
contentSize
;
networkInfo
.
response
.
transferredSize
=
packet
.
transferredSize
;
networkInfo
.
discardResponseBody
=
packet
.
discardResponseBody
;
break
;
case
"
eventTimings
"
:
networkInfo
.
totalTime
=
packet
.
totalTime
;
break
;
case
"
securityInfo
"
:
networkInfo
.
securityInfo
=
packet
.
state
;
break
;
}
this
.
emit
(
"
networkEventUpdate
"
{
packet
:
packet
networkInfo
}
)
;
}
getCachedMessages
:
function
WCC_getCachedMessages
(
types
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
getCachedMessages
"
messageTypes
:
types
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
inspectObjectProperties
:
function
WCC_inspectObjectProperties
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
inspectProperties
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
evaluateJS
:
function
WCC_evaluateJS
(
aString
aOnResponse
aOptions
=
{
}
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
evaluateJS
"
text
:
aString
bindObjectActor
:
aOptions
.
bindObjectActor
frameActor
:
aOptions
.
frameActor
url
:
aOptions
.
url
selectedNodeActor
:
aOptions
.
selectedNodeActor
selectedObjectActor
:
aOptions
.
selectedObjectActor
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
evaluateJSAsync
:
function
(
aString
aOnResponse
aOptions
=
{
}
)
{
if
(
!
this
.
traits
.
evaluateJSAsync
)
{
this
.
evaluateJS
(
aString
aOnResponse
aOptions
)
;
return
;
}
let
packet
=
{
to
:
this
.
_actor
type
:
"
evaluateJSAsync
"
text
:
aString
bindObjectActor
:
aOptions
.
bindObjectActor
frameActor
:
aOptions
.
frameActor
url
:
aOptions
.
url
selectedNodeActor
:
aOptions
.
selectedNodeActor
selectedObjectActor
:
aOptions
.
selectedObjectActor
}
;
this
.
_client
.
request
(
packet
response
=
>
{
if
(
this
.
pendingEvaluationResults
)
{
this
.
pendingEvaluationResults
.
set
(
response
.
resultID
aOnResponse
)
;
}
}
)
;
}
onEvaluationResult
:
function
(
aNotification
aPacket
)
{
if
(
aPacket
.
from
!
=
=
this
.
_actor
)
{
return
;
}
let
onResponse
=
this
.
pendingEvaluationResults
.
get
(
aPacket
.
resultID
)
;
if
(
onResponse
)
{
onResponse
(
aPacket
)
;
this
.
pendingEvaluationResults
.
delete
(
aPacket
.
resultID
)
;
}
else
{
DevToolsUtils
.
reportException
(
"
onEvaluationResult
"
"
No
response
handler
for
an
evaluateJSAsync
result
(
resultID
:
"
+
aPacket
.
resultID
+
"
)
"
)
;
}
}
autocomplete
:
function
WCC_autocomplete
(
aString
aCursor
aOnResponse
aFrameActor
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
autocomplete
"
text
:
aString
cursor
:
aCursor
frameActor
:
aFrameActor
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
clearMessagesCache
:
function
WCC_clearMessagesCache
(
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
clearMessagesCache
"
}
;
this
.
_client
.
request
(
packet
)
;
}
getPreferences
:
function
WCC_getPreferences
(
aPreferences
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
getPreferences
"
preferences
:
aPreferences
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
setPreferences
:
function
WCC_setPreferences
(
aPreferences
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
setPreferences
"
preferences
:
aPreferences
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getRequestHeaders
:
function
WCC_getRequestHeaders
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getRequestHeaders
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getRequestCookies
:
function
WCC_getRequestCookies
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getRequestCookies
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getRequestPostData
:
function
WCC_getRequestPostData
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getRequestPostData
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getResponseHeaders
:
function
WCC_getResponseHeaders
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getResponseHeaders
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getResponseCookies
:
function
WCC_getResponseCookies
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getResponseCookies
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getResponseContent
:
function
WCC_getResponseContent
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getResponseContent
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getEventTimings
:
function
WCC_getEventTimings
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getEventTimings
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getSecurityInfo
:
function
WCC_getSecurityInfo
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getSecurityInfo
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
sendHTTPRequest
:
function
WCC_sendHTTPRequest
(
aData
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
sendHTTPRequest
"
request
:
aData
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
startListeners
:
function
WCC_startListeners
(
aListeners
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
startListeners
"
listeners
:
aListeners
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
stopListeners
:
function
WCC_stopListeners
(
aListeners
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
stopListeners
"
listeners
:
aListeners
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
longString
:
function
WCC_longString
(
aGrip
)
{
if
(
aGrip
.
actor
in
this
.
_longStrings
)
{
return
this
.
_longStrings
[
aGrip
.
actor
]
;
}
let
client
=
new
LongStringClient
(
this
.
_client
aGrip
)
;
this
.
_longStrings
[
aGrip
.
actor
]
=
client
;
return
client
;
}
detach
:
function
WCC_detach
(
aOnResponse
)
{
this
.
_client
.
removeListener
(
"
evaluationResult
"
this
.
onEvaluationResult
)
;
this
.
_client
.
removeListener
(
"
networkEvent
"
this
.
onNetworkEvent
)
;
this
.
_client
.
removeListener
(
"
networkEventUpdate
"
this
.
onNetworkEventUpdate
)
;
this
.
stopListeners
(
null
aOnResponse
)
;
this
.
_longStrings
=
null
;
this
.
_client
=
null
;
this
.
pendingEvaluationResults
.
clear
(
)
;
this
.
pendingEvaluationResults
=
null
;
this
.
clearNetworkRequests
(
)
;
this
.
_networkRequests
=
null
;
}
clearNetworkRequests
:
function
(
)
{
this
.
_networkRequests
.
clear
(
)
;
}
getString
:
function
(
stringGrip
)
{
if
(
typeof
stringGrip
!
=
"
object
"
|
|
stringGrip
.
type
!
=
"
longString
"
)
{
return
promise
.
resolve
(
stringGrip
)
;
}
if
(
stringGrip
.
_fullText
)
{
return
stringGrip
.
_fullText
.
promise
;
}
let
deferred
=
stringGrip
.
_fullText
=
promise
.
defer
(
)
;
let
{
actor
initial
length
}
=
stringGrip
;
let
longStringClient
=
this
.
longString
(
stringGrip
)
;
longStringClient
.
substring
(
initial
.
length
length
aResponse
=
>
{
if
(
aResponse
.
error
)
{
DevToolsUtils
.
reportException
(
"
getString
"
aResponse
.
error
+
"
:
"
+
aResponse
.
message
)
;
deferred
.
reject
(
aResponse
)
;
return
;
}
deferred
.
resolve
(
initial
+
aResponse
.
substring
)
;
}
)
;
return
deferred
.
promise
;
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
EventEmitter
=
function
EventEmitter
(
)
{
}
;
module
.
exports
=
EventEmitter
;
const
{
Cu
}
=
__webpack_require__
(
178
)
;
const
promise
=
__webpack_require__
(
189
)
;
EventEmitter
.
decorate
=
function
EventEmitter_decorate
(
aObjectToDecorate
)
{
let
emitter
=
new
EventEmitter
(
)
;
aObjectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
aObjectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
aObjectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
aObjectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
:
function
EventEmitter_on
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
this
.
_eventEmitterListeners
=
new
Map
(
)
;
if
(
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
aEvent
)
.
push
(
aListener
)
;
}
once
:
function
EventEmitter_once
(
aEvent
aListener
)
{
let
deferred
=
promise
.
defer
(
)
;
let
handler
=
(
aEvent
aFirstArg
.
.
.
aRest
)
=
>
{
this
.
off
(
aEvent
handler
)
;
if
(
aListener
)
{
aListener
.
apply
(
null
[
aEvent
aFirstArg
.
.
.
aRest
]
)
;
}
deferred
.
resolve
(
aFirstArg
)
;
}
;
handler
.
_originalListener
=
aListener
;
this
.
on
(
aEvent
handler
)
;
return
deferred
.
promise
;
}
off
:
function
EventEmitter_off
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
return
;
let
listeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
listeners
.
filter
(
l
=
>
{
return
l
!
=
=
aListener
&
&
l
.
_originalListener
!
=
=
aListener
;
}
)
)
;
}
}
emit
:
function
EventEmitter_emit
(
aEvent
)
{
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
return
;
}
let
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
for
(
let
listener
of
this
.
_eventEmitterListeners
.
get
(
aEvent
)
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
break
;
}
if
(
originalListeners
=
=
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
|
|
this
.
_eventEmitterListeners
.
get
(
aEvent
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
.
apply
(
null
arguments
)
;
}
catch
(
ex
)
{
let
msg
=
ex
+
"
:
"
+
ex
.
stack
;
console
.
log
(
msg
)
;
}
}
}
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
DevToolsUtils
=
__webpack_require__
(
177
)
;
const
{
dumpn
dumpv
}
=
DevToolsUtils
;
const
StreamUtils
=
__webpack_require__
(
255
)
;
const
{
Packet
JSONPacket
BulkPacket
}
=
__webpack_require__
(
256
)
;
const
promise
=
__webpack_require__
(
189
)
;
const
EventEmitter
=
__webpack_require__
(
253
)
;
const
utf8
=
__webpack_require__
(
258
)
;
const
PACKET_HEADER_MAX
=
200
;
function
DebuggerTransport
(
socket
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_socket
=
socket
;
this
.
_incomingHeader
=
"
"
;
this
.
_incoming
=
null
;
this
.
_outgoing
=
[
]
;
this
.
hooks
=
null
;
this
.
active
=
false
;
this
.
_incomingEnabled
=
true
;
this
.
_outgoingEnabled
=
true
;
this
.
close
=
this
.
close
.
bind
(
this
)
;
}
DebuggerTransport
.
prototype
=
{
send
:
function
(
object
)
{
this
.
emit
(
"
send
"
object
)
;
let
packet
=
new
JSONPacket
(
this
)
;
packet
.
object
=
object
;
this
.
_outgoing
.
push
(
packet
)
;
this
.
_flushOutgoing
(
)
;
}
startBulkSend
:
function
(
header
)
{
this
.
emit
(
"
startBulkSend
"
header
)
;
let
packet
=
new
BulkPacket
(
this
)
;
packet
.
header
=
header
;
this
.
_outgoing
.
push
(
packet
)
;
this
.
_flushOutgoing
(
)
;
return
packet
.
streamReadyForWriting
;
}
close
:
function
(
reason
)
{
this
.
emit
(
"
onClosed
"
reason
)
;
this
.
active
=
false
;
this
.
_socket
.
close
(
)
;
this
.
_destroyIncoming
(
)
;
this
.
_destroyAllOutgoing
(
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
reason
)
;
this
.
hooks
=
null
;
}
if
(
reason
)
{
dumpn
(
"
Transport
closed
:
"
+
DevToolsUtils
.
safeErrorString
(
reason
)
)
;
}
else
{
dumpn
(
"
Transport
closed
.
"
)
;
}
}
get
_currentOutgoing
(
)
{
return
this
.
_outgoing
[
0
]
;
}
_flushOutgoing
:
function
(
)
{
if
(
!
this
.
_outgoingEnabled
|
|
this
.
_outgoing
.
length
=
=
=
0
)
{
return
;
}
if
(
this
.
_currentOutgoing
.
done
)
{
this
.
_finishCurrentOutgoing
(
)
;
}
if
(
this
.
_outgoing
.
length
>
0
)
{
setTimeout
(
this
.
onOutputStreamReady
.
bind
(
this
)
0
)
;
}
}
pauseOutgoing
:
function
(
)
{
this
.
_outgoingEnabled
=
false
;
}
resumeOutgoing
:
function
(
)
{
this
.
_outgoingEnabled
=
true
;
this
.
_flushOutgoing
(
)
;
}
onOutputStreamReady
:
DevToolsUtils
.
makeInfallible
(
function
(
)
{
if
(
!
this
.
_outgoingEnabled
|
|
this
.
_outgoing
.
length
=
=
=
0
)
{
return
;
}
try
{
this
.
_currentOutgoing
.
write
(
{
write
:
data
=
>
{
let
count
=
data
.
length
;
this
.
_socket
.
send
(
data
)
;
return
count
;
}
}
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
this
.
close
(
e
.
result
)
;
return
;
}
else
{
throw
e
;
}
}
this
.
_flushOutgoing
(
)
;
}
"
DebuggerTransport
.
prototype
.
onOutputStreamReady
"
)
_finishCurrentOutgoing
:
function
(
)
{
if
(
this
.
_currentOutgoing
)
{
this
.
_currentOutgoing
.
destroy
(
)
;
this
.
_outgoing
.
shift
(
)
;
}
}
_destroyAllOutgoing
:
function
(
)
{
for
(
let
packet
of
this
.
_outgoing
)
{
packet
.
destroy
(
)
;
}
this
.
_outgoing
=
[
]
;
}
ready
:
function
(
)
{
this
.
active
=
true
;
this
.
_waitForIncoming
(
)
;
}
_waitForIncoming
:
function
(
)
{
if
(
this
.
_incomingEnabled
&
&
!
this
.
_socket
.
onmessage
)
{
this
.
_socket
.
onmessage
=
this
.
onInputStreamReady
.
bind
(
this
)
;
}
}
pauseIncoming
:
function
(
)
{
this
.
_incomingEnabled
=
false
;
}
resumeIncoming
:
function
(
)
{
this
.
_incomingEnabled
=
true
;
this
.
_flushIncoming
(
)
;
this
.
_waitForIncoming
(
)
;
}
onInputStreamReady
:
DevToolsUtils
.
makeInfallible
(
function
(
event
)
{
let
data
=
event
.
data
;
data
=
utf8
.
encode
(
data
)
;
let
stream
=
{
available
(
)
{
return
data
.
length
;
}
readBytes
(
count
)
{
let
result
=
data
.
slice
(
0
count
)
;
data
=
data
.
slice
(
count
)
;
return
result
;
}
}
;
try
{
while
(
data
&
&
this
.
_incomingEnabled
&
&
this
.
_processIncoming
(
stream
stream
.
available
(
)
)
)
{
}
this
.
_waitForIncoming
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
this
.
close
(
e
.
result
)
;
}
else
{
throw
e
;
}
}
}
"
DebuggerTransport
.
prototype
.
onInputStreamReady
"
)
_processIncoming
:
function
(
stream
count
)
{
dumpv
(
"
Data
available
:
"
+
count
)
;
if
(
!
count
)
{
dumpv
(
"
Nothing
to
read
skipping
"
)
;
return
false
;
}
try
{
if
(
!
this
.
_incoming
)
{
dumpv
(
"
Creating
a
new
packet
from
incoming
"
)
;
if
(
!
this
.
_readHeader
(
stream
)
)
{
return
false
;
}
this
.
_incoming
=
Packet
.
fromHeader
(
this
.
_incomingHeader
this
)
;
if
(
!
this
.
_incoming
)
{
throw
new
Error
(
"
No
packet
types
for
header
:
"
+
this
.
_incomingHeader
)
;
}
}
if
(
!
this
.
_incoming
.
done
)
{
dumpv
(
"
Existing
packet
incomplete
keep
reading
"
)
;
this
.
_incoming
.
read
(
stream
)
;
}
}
catch
(
e
)
{
let
msg
=
"
Error
reading
incoming
packet
:
(
"
+
e
+
"
-
"
+
e
.
stack
+
"
)
"
;
dumpn
(
msg
)
;
this
.
close
(
)
;
return
false
;
}
if
(
!
this
.
_incoming
.
done
)
{
dumpv
(
"
Packet
not
done
wait
for
more
"
)
;
return
true
;
}
this
.
_flushIncoming
(
)
;
return
true
;
}
_readHeader
:
function
(
stream
)
{
let
amountToRead
=
PACKET_HEADER_MAX
-
this
.
_incomingHeader
.
length
;
this
.
_incomingHeader
+
=
StreamUtils
.
delimitedRead
(
stream
"
:
"
amountToRead
)
;
if
(
dumpv
.
wantVerbose
)
{
dumpv
(
"
Header
read
:
"
+
this
.
_incomingHeader
)
;
}
if
(
this
.
_incomingHeader
.
endsWith
(
"
:
"
)
)
{
if
(
dumpv
.
wantVerbose
)
{
dumpv
(
"
Found
packet
header
successfully
:
"
+
this
.
_incomingHeader
)
;
}
return
true
;
}
if
(
this
.
_incomingHeader
.
length
>
=
PACKET_HEADER_MAX
)
{
throw
new
Error
(
"
Failed
to
parse
packet
header
!
"
)
;
}
return
false
;
}
_flushIncoming
:
function
(
)
{
if
(
!
this
.
_incoming
.
done
)
{
return
;
}
if
(
dumpn
.
wantLogging
)
{
dumpn
(
"
Got
:
"
+
this
.
_incoming
)
;
}
this
.
_destroyIncoming
(
)
;
}
_onJSONObjectReady
:
function
(
object
)
{
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
this
.
active
)
{
this
.
emit
(
"
onPacket
"
object
)
;
this
.
hooks
.
onPacket
(
object
)
;
}
}
"
DebuggerTransport
instance
'
s
this
.
hooks
.
onPacket
"
)
)
;
}
_onBulkReadReady
:
function
(
.
.
.
args
)
{
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
this
.
active
)
{
this
.
emit
(
"
onBulkPacket
"
.
.
.
args
)
;
this
.
hooks
.
onBulkPacket
(
.
.
.
args
)
;
}
}
"
DebuggerTransport
instance
'
s
this
.
hooks
.
onBulkPacket
"
)
)
;
}
_destroyIncoming
:
function
(
)
{
if
(
this
.
_incoming
)
{
this
.
_incoming
.
destroy
(
)
;
}
this
.
_incomingHeader
=
"
"
;
this
.
_incoming
=
null
;
}
}
;
exports
.
DebuggerTransport
=
DebuggerTransport
;
function
LocalDebuggerTransport
(
other
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
other
=
other
;
this
.
hooks
=
null
;
this
.
_serial
=
this
.
other
?
this
.
other
.
_serial
:
{
count
:
0
}
;
this
.
close
=
this
.
close
.
bind
(
this
)
;
}
LocalDebuggerTransport
.
prototype
=
{
send
:
function
(
packet
)
{
this
.
emit
(
"
send
"
packet
)
;
let
serial
=
this
.
_serial
.
count
+
+
;
if
(
dumpn
.
wantLogging
)
{
if
(
packet
.
from
)
{
dumpn
(
"
Packet
"
+
serial
+
"
sent
from
"
+
uneval
(
packet
.
from
)
)
;
}
else
if
(
packet
.
to
)
{
dumpn
(
"
Packet
"
+
serial
+
"
sent
to
"
+
uneval
(
packet
.
to
)
)
;
}
}
this
.
_deepFreeze
(
packet
)
;
let
other
=
this
.
other
;
if
(
other
)
{
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
dumpn
.
wantLogging
)
{
dumpn
(
"
Received
packet
"
+
serial
+
"
:
"
+
JSON
.
stringify
(
packet
null
2
)
)
;
}
if
(
other
.
hooks
)
{
other
.
emit
(
"
onPacket
"
packet
)
;
other
.
hooks
.
onPacket
(
packet
)
;
}
}
"
LocalDebuggerTransport
instance
'
s
this
.
other
.
hooks
.
onPacket
"
)
)
;
}
}
startBulkSend
:
function
(
{
actor
type
length
}
)
{
this
.
emit
(
"
startBulkSend
"
{
actor
type
length
}
)
;
let
serial
=
this
.
_serial
.
count
+
+
;
dumpn
(
"
Sent
bulk
packet
"
+
serial
+
"
for
actor
"
+
actor
)
;
if
(
!
this
.
other
)
{
return
;
}
let
pipe
=
new
Pipe
(
true
true
0
0
null
)
;
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
dumpn
(
"
Received
bulk
packet
"
+
serial
)
;
if
(
!
this
.
other
.
hooks
)
{
return
;
}
let
deferred
=
promise
.
defer
(
)
;
let
packet
=
{
actor
:
actor
type
:
type
length
:
length
copyTo
:
(
output
)
=
>
{
let
copying
=
StreamUtils
.
copyStream
(
pipe
.
inputStream
output
length
)
;
deferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
pipe
.
inputStream
done
:
deferred
}
;
this
.
other
.
emit
(
"
onBulkPacket
"
packet
)
;
this
.
other
.
hooks
.
onBulkPacket
(
packet
)
;
deferred
.
promise
.
then
(
(
)
=
>
pipe
.
inputStream
.
close
(
)
this
.
close
)
;
}
"
LocalDebuggerTransport
instance
'
s
this
.
other
.
hooks
.
onBulkPacket
"
)
)
;
let
sendDeferred
=
promise
.
defer
(
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
let
copyDeferred
=
promise
.
defer
(
)
;
sendDeferred
.
resolve
(
{
copyFrom
:
(
input
)
=
>
{
let
copying
=
StreamUtils
.
copyStream
(
input
pipe
.
outputStream
length
)
;
copyDeferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
pipe
.
outputStream
done
:
copyDeferred
}
)
;
copyDeferred
.
promise
.
then
(
(
)
=
>
pipe
.
outputStream
.
close
(
)
this
.
close
)
;
}
)
;
return
sendDeferred
.
promise
;
}
close
:
function
(
)
{
this
.
emit
(
"
close
"
)
;
if
(
this
.
other
)
{
let
other
=
this
.
other
;
this
.
other
=
null
;
other
.
close
(
)
;
}
if
(
this
.
hooks
)
{
try
{
this
.
hooks
.
onClosed
(
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
this
.
hooks
=
null
;
}
}
ready
:
function
(
)
{
}
_deepFreeze
:
function
(
object
)
{
Object
.
freeze
(
object
)
;
for
(
let
prop
in
object
)
{
if
(
object
.
hasOwnProperty
(
prop
)
&
&
typeof
object
=
=
=
"
object
"
&
&
!
Object
.
isFrozen
(
object
)
)
{
this
.
_deepFreeze
(
o
[
prop
]
)
;
}
}
}
}
;
exports
.
LocalDebuggerTransport
=
LocalDebuggerTransport
;
function
ChildDebuggerTransport
(
sender
prefix
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_sender
=
sender
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
this
.
_messageName
=
"
debug
:
"
+
prefix
+
"
:
packet
"
;
}
ChildDebuggerTransport
.
prototype
=
{
constructor
:
ChildDebuggerTransport
hooks
:
null
ready
:
function
(
)
{
this
.
_sender
.
addMessageListener
(
this
.
_messageName
this
)
;
}
close
:
function
(
)
{
this
.
_sender
.
removeMessageListener
(
this
.
_messageName
this
)
;
this
.
emit
(
"
onClosed
"
)
;
this
.
hooks
.
onClosed
(
)
;
}
receiveMessage
:
function
(
{
data
}
)
{
this
.
emit
(
"
onPacket
"
data
)
;
this
.
hooks
.
onPacket
(
data
)
;
}
send
:
function
(
packet
)
{
this
.
emit
(
"
send
"
packet
)
;
this
.
_sender
.
sendAsyncMessage
(
this
.
_messageName
packet
)
;
}
startBulkSend
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
send
bulk
data
to
child
processes
.
"
)
;
}
}
;
exports
.
ChildDebuggerTransport
=
ChildDebuggerTransport
;
if
(
typeof
WorkerGlobalScope
=
=
=
'
undefined
'
)
{
(
function
(
)
{
function
WorkerDebuggerTransport
(
dbg
id
)
{
this
.
_dbg
=
dbg
;
this
.
_id
=
id
;
this
.
onMessage
=
this
.
_onMessage
.
bind
(
this
)
;
}
WorkerDebuggerTransport
.
prototype
=
{
constructor
:
WorkerDebuggerTransport
ready
:
function
(
)
{
this
.
_dbg
.
addListener
(
this
)
;
}
close
:
function
(
)
{
this
.
_dbg
.
removeListener
(
this
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
)
;
}
}
send
:
function
(
packet
)
{
this
.
_dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
message
"
id
:
this
.
_id
message
:
packet
}
)
)
;
}
startBulkSend
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
send
bulk
data
from
worker
threads
!
"
)
;
}
_onMessage
:
function
(
message
)
{
let
packet
=
JSON
.
parse
(
message
)
;
if
(
packet
.
type
!
=
=
"
message
"
|
|
packet
.
id
!
=
=
this
.
_id
)
{
return
;
}
if
(
this
.
hooks
)
{
this
.
hooks
.
onPacket
(
packet
.
message
)
;
}
}
}
;
exports
.
WorkerDebuggerTransport
=
WorkerDebuggerTransport
;
}
)
.
call
(
this
)
;
}
else
{
(
function
(
)
{
function
WorkerDebuggerTransport
(
scope
id
)
{
this
.
_scope
=
scope
;
this
.
_id
=
id
;
this
.
_onMessage
=
this
.
_onMessage
.
bind
(
this
)
;
}
WorkerDebuggerTransport
.
prototype
=
{
constructor
:
WorkerDebuggerTransport
ready
:
function
(
)
{
this
.
_scope
.
addEventListener
(
"
message
"
this
.
_onMessage
)
;
}
close
:
function
(
)
{
this
.
_scope
.
removeEventListener
(
"
message
"
this
.
_onMessage
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
)
;
}
}
send
:
function
(
packet
)
{
this
.
_scope
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
message
"
id
:
this
.
_id
message
:
packet
}
)
)
;
}
startBulkSend
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
send
bulk
data
from
worker
threads
!
"
)
;
}
_onMessage
:
function
(
event
)
{
let
packet
=
JSON
.
parse
(
event
.
data
)
;
if
(
packet
.
type
!
=
=
"
message
"
|
|
packet
.
id
!
=
=
this
.
_id
)
{
return
;
}
if
(
this
.
hooks
)
{
this
.
hooks
.
onPacket
(
packet
.
message
)
;
}
}
}
;
exports
.
WorkerDebuggerTransport
=
WorkerDebuggerTransport
;
}
)
.
call
(
this
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Ci
Cc
Cu
Cr
CC
}
=
__webpack_require__
(
178
)
;
const
Services
=
__webpack_require__
(
183
)
;
const
DevToolsUtils
=
__webpack_require__
(
177
)
;
const
{
dumpv
}
=
DevToolsUtils
;
const
EventEmitter
=
__webpack_require__
(
253
)
;
const
promise
=
__webpack_require__
(
189
)
;
const
IOUtil
=
Cc
(
"
mozilla
.
org
/
io
-
util
;
1
"
)
.
getService
(
Ci
.
nsIIOUtil
)
;
const
ScriptableInputStream
=
CC
(
"
mozilla
.
org
/
scriptableinputstream
;
1
"
"
nsIScriptableInputStream
"
"
init
"
)
;
const
BUFFER_SIZE
=
0x8000
;
function
copyStream
(
input
output
length
)
{
let
copier
=
new
StreamCopier
(
input
output
length
)
;
return
copier
.
copy
(
)
;
}
function
StreamCopier
(
input
output
length
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_id
=
StreamCopier
.
_nextId
+
+
;
this
.
input
=
input
;
this
.
baseAsyncOutput
=
output
;
if
(
IOUtil
.
outputStreamIsBuffered
(
output
)
)
{
this
.
output
=
output
;
}
else
{
this
.
output
=
Cc
(
"
mozilla
.
org
/
network
/
buffered
-
output
-
stream
;
1
"
)
.
createInstance
(
Ci
.
nsIBufferedOutputStream
)
;
this
.
output
.
init
(
output
BUFFER_SIZE
)
;
}
this
.
_length
=
length
;
this
.
_amountLeft
=
length
;
this
.
_deferred
=
promise
.
defer
(
)
;
this
.
_copy
=
this
.
_copy
.
bind
(
this
)
;
this
.
_flush
=
this
.
_flush
.
bind
(
this
)
;
this
.
_destroy
=
this
.
_destroy
.
bind
(
this
)
;
this
.
then
=
this
.
_deferred
.
promise
.
then
.
bind
(
this
.
_deferred
.
promise
)
;
this
.
then
(
this
.
_destroy
this
.
_destroy
)
;
this
.
_streamReadyCallback
=
this
.
_copy
;
}
StreamCopier
.
_nextId
=
0
;
StreamCopier
.
prototype
=
{
copy
:
function
(
)
{
Services
.
tm
.
currentThread
.
dispatch
(
(
)
=
>
{
try
{
this
.
_copy
(
)
;
}
catch
(
e
)
{
this
.
_deferred
.
reject
(
e
)
;
}
}
0
)
;
return
this
;
}
_copy
:
function
(
)
{
let
bytesAvailable
=
this
.
input
.
available
(
)
;
let
amountToCopy
=
Math
.
min
(
bytesAvailable
this
.
_amountLeft
)
;
this
.
_debug
(
"
Trying
to
copy
:
"
+
amountToCopy
)
;
let
bytesCopied
;
try
{
bytesCopied
=
this
.
output
.
writeFrom
(
this
.
input
amountToCopy
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
this
.
_debug
(
"
Base
stream
would
block
will
retry
"
)
;
this
.
_debug
(
"
Waiting
for
output
stream
"
)
;
this
.
baseAsyncOutput
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
return
;
}
else
{
throw
e
;
}
}
this
.
_amountLeft
-
=
bytesCopied
;
this
.
_debug
(
"
Copied
:
"
+
bytesCopied
+
"
Left
:
"
+
this
.
_amountLeft
)
;
this
.
_emitProgress
(
)
;
if
(
this
.
_amountLeft
=
=
=
0
)
{
this
.
_debug
(
"
Copy
done
!
"
)
;
this
.
_flush
(
)
;
return
;
}
this
.
_debug
(
"
Waiting
for
input
stream
"
)
;
this
.
input
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
}
_emitProgress
:
function
(
)
{
this
.
emit
(
"
progress
"
{
bytesSent
:
this
.
_length
-
this
.
_amountLeft
totalBytes
:
this
.
_length
}
)
;
}
_flush
:
function
(
)
{
try
{
this
.
output
.
flush
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
|
|
e
.
result
=
=
Cr
.
NS_ERROR_FAILURE
)
{
this
.
_debug
(
"
Flush
would
block
will
retry
"
)
;
this
.
_streamReadyCallback
=
this
.
_flush
;
this
.
_debug
(
"
Waiting
for
output
stream
"
)
;
this
.
baseAsyncOutput
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
return
;
}
else
{
throw
e
;
}
}
this
.
_deferred
.
resolve
(
)
;
}
_destroy
:
function
(
)
{
this
.
_destroy
=
null
;
this
.
_copy
=
null
;
this
.
_flush
=
null
;
this
.
input
=
null
;
this
.
output
=
null
;
}
onInputStreamReady
:
function
(
)
{
this
.
_streamReadyCallback
(
)
;
}
onOutputStreamReady
:
function
(
)
{
this
.
_streamReadyCallback
(
)
;
}
_debug
:
function
(
msg
)
{
dumpv
(
"
Copier
:
"
+
this
.
_id
+
"
"
+
msg
)
;
}
}
;
function
delimitedRead
(
stream
delimiter
count
)
{
dumpv
(
"
Starting
delimited
read
for
"
+
delimiter
+
"
up
to
"
+
count
+
"
bytes
"
)
;
let
scriptableStream
;
if
(
stream
.
readBytes
)
{
scriptableStream
=
stream
;
}
else
{
scriptableStream
=
new
ScriptableInputStream
(
stream
)
;
}
let
data
=
"
"
;
count
=
Math
.
min
(
count
stream
.
available
(
)
)
;
if
(
count
<
=
0
)
{
return
data
;
}
let
char
;
while
(
char
!
=
=
delimiter
&
&
count
>
0
)
{
char
=
scriptableStream
.
readBytes
(
1
)
;
count
-
-
;
data
+
=
char
;
}
return
data
;
}
module
.
exports
=
{
copyStream
:
copyStream
delimitedRead
:
delimitedRead
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
__webpack_require__
(
178
)
;
const
DevToolsUtils
=
__webpack_require__
(
177
)
;
const
{
dumpn
dumpv
}
=
DevToolsUtils
;
const
StreamUtils
=
__webpack_require__
(
255
)
;
const
promise
=
__webpack_require__
(
189
)
;
const
utf8
=
__webpack_require__
(
257
)
;
const
PACKET_LENGTH_MAX
=
Math
.
pow
(
2
40
)
;
function
Packet
(
transport
)
{
this
.
_transport
=
transport
;
this
.
_length
=
0
;
}
Packet
.
fromHeader
=
function
(
header
transport
)
{
return
JSONPacket
.
fromHeader
(
header
transport
)
|
|
BulkPacket
.
fromHeader
(
header
transport
)
;
}
;
Packet
.
prototype
=
{
get
length
(
)
{
return
this
.
_length
;
}
set
length
(
length
)
{
if
(
length
>
PACKET_LENGTH_MAX
)
{
throw
Error
(
"
Packet
length
"
+
length
+
"
exceeds
the
max
length
of
"
+
PACKET_LENGTH_MAX
)
;
}
this
.
_length
=
length
;
}
destroy
:
function
(
)
{
this
.
_transport
=
null
;
}
}
;
exports
.
Packet
=
Packet
;
function
JSONPacket
(
transport
)
{
Packet
.
call
(
this
transport
)
;
this
.
_data
=
"
"
;
this
.
_done
=
false
;
}
JSONPacket
.
fromHeader
=
function
(
header
transport
)
{
let
match
=
this
.
HEADER_PATTERN
.
exec
(
header
)
;
if
(
!
match
)
{
return
null
;
}
dumpv
(
"
Header
matches
JSON
packet
"
)
;
let
packet
=
new
JSONPacket
(
transport
)
;
packet
.
length
=
+
match
[
1
]
;
return
packet
;
}
;
JSONPacket
.
HEADER_PATTERN
=
/
^
(
\
d
+
)
:
/
;
JSONPacket
.
prototype
=
Object
.
create
(
Packet
.
prototype
)
;
Object
.
defineProperty
(
JSONPacket
.
prototype
"
object
"
{
get
:
function
(
)
{
return
this
.
_object
;
}
set
:
function
(
object
)
{
this
.
_object
=
object
;
let
data
=
JSON
.
stringify
(
object
)
;
this
.
_data
=
data
;
this
.
length
=
this
.
_data
.
length
;
}
}
)
;
JSONPacket
.
prototype
.
read
=
function
(
stream
scriptableStream
)
{
dumpv
(
"
Reading
JSON
packet
"
)
;
this
.
_readData
(
stream
scriptableStream
)
;
if
(
!
this
.
done
)
{
return
;
}
let
json
=
this
.
_data
;
try
{
json
=
utf8
.
decode
(
json
)
;
this
.
_object
=
JSON
.
parse
(
json
)
;
}
catch
(
e
)
{
let
msg
=
"
Error
parsing
incoming
packet
:
"
+
json
+
"
(
"
+
e
+
"
-
"
+
e
.
stack
+
"
)
"
;
if
(
console
.
error
)
{
console
.
error
(
msg
)
;
}
dumpn
(
msg
)
;
return
;
}
this
.
_transport
.
_onJSONObjectReady
(
this
.
_object
)
;
}
JSONPacket
.
prototype
.
_readData
=
function
(
stream
scriptableStream
)
{
if
(
!
scriptableStream
)
{
scriptableStream
=
stream
;
}
if
(
dumpv
.
wantVerbose
)
{
dumpv
(
"
Reading
JSON
data
:
_l
:
"
+
this
.
length
+
"
dL
:
"
+
this
.
_data
.
length
+
"
sA
:
"
+
stream
.
available
(
)
)
;
}
let
bytesToRead
=
Math
.
min
(
this
.
length
-
this
.
_data
.
length
stream
.
available
(
)
)
;
this
.
_data
+
=
scriptableStream
.
readBytes
(
bytesToRead
)
;
this
.
_done
=
this
.
_data
.
length
=
=
=
this
.
length
;
}
JSONPacket
.
prototype
.
write
=
function
(
stream
)
{
dumpv
(
"
Writing
JSON
packet
"
)
;
if
(
this
.
_outgoing
=
=
=
undefined
)
{
this
.
_outgoing
=
this
.
length
+
"
:
"
+
this
.
_data
;
}
let
written
=
stream
.
write
(
this
.
_outgoing
this
.
_outgoing
.
length
)
;
this
.
_outgoing
=
this
.
_outgoing
.
slice
(
written
)
;
this
.
_done
=
!
this
.
_outgoing
.
length
;
}
Object
.
defineProperty
(
JSONPacket
.
prototype
"
done
"
{
get
:
function
(
)
{
return
this
.
_done
;
}
}
)
;
JSONPacket
.
prototype
.
toString
=
function
(
)
{
return
JSON
.
stringify
(
this
.
_object
null
2
)
;
}
exports
.
JSONPacket
=
JSONPacket
;
function
BulkPacket
(
transport
)
{
Packet
.
call
(
this
transport
)
;
this
.
_done
=
false
;
this
.
_readyForWriting
=
promise
.
defer
(
)
;
}
BulkPacket
.
fromHeader
=
function
(
header
transport
)
{
let
match
=
this
.
HEADER_PATTERN
.
exec
(
header
)
;
if
(
!
match
)
{
return
null
;
}
dumpv
(
"
Header
matches
bulk
packet
"
)
;
let
packet
=
new
BulkPacket
(
transport
)
;
packet
.
header
=
{
actor
:
match
[
1
]
type
:
match
[
2
]
length
:
+
match
[
3
]
}
;
return
packet
;
}
;
BulkPacket
.
HEADER_PATTERN
=
/
^
bulk
(
[
^
:
]
+
)
(
[
^
:
]
+
)
(
\
d
+
)
:
/
;
BulkPacket
.
prototype
=
Object
.
create
(
Packet
.
prototype
)
;
BulkPacket
.
prototype
.
read
=
function
(
stream
)
{
dumpv
(
"
Reading
bulk
packet
handing
off
input
stream
"
)
;
this
.
_transport
.
pauseIncoming
(
)
;
let
deferred
=
promise
.
defer
(
)
;
this
.
_transport
.
_onBulkReadReady
(
{
actor
:
this
.
actor
type
:
this
.
type
length
:
this
.
length
copyTo
:
(
output
)
=
>
{
dumpv
(
"
CT
length
:
"
+
this
.
length
)
;
let
copying
=
StreamUtils
.
copyStream
(
stream
output
this
.
length
)
;
deferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
stream
done
:
deferred
}
)
;
deferred
.
promise
.
then
(
(
)
=
>
{
dumpv
(
"
onReadDone
called
ending
bulk
mode
"
)
;
this
.
_done
=
true
;
this
.
_transport
.
resumeIncoming
(
)
;
}
this
.
_transport
.
close
)
;
this
.
read
=
(
)
=
>
{
throw
new
Error
(
"
Tried
to
read
(
)
a
BulkPacket
'
s
stream
multiple
times
.
"
)
;
}
;
}
BulkPacket
.
prototype
.
write
=
function
(
stream
)
{
dumpv
(
"
Writing
bulk
packet
"
)
;
if
(
this
.
_outgoingHeader
=
=
=
undefined
)
{
dumpv
(
"
Serializing
bulk
packet
header
"
)
;
this
.
_outgoingHeader
=
"
bulk
"
+
this
.
actor
+
"
"
+
this
.
type
+
"
"
+
this
.
length
+
"
:
"
;
}
if
(
this
.
_outgoingHeader
.
length
)
{
dumpv
(
"
Writing
bulk
packet
header
"
)
;
let
written
=
stream
.
write
(
this
.
_outgoingHeader
this
.
_outgoingHeader
.
length
)
;
this
.
_outgoingHeader
=
this
.
_outgoingHeader
.
slice
(
written
)
;
return
;
}
dumpv
(
"
Handing
off
output
stream
"
)
;
this
.
_transport
.
pauseOutgoing
(
)
;
let
deferred
=
promise
.
defer
(
)
;
this
.
_readyForWriting
.
resolve
(
{
copyFrom
:
(
input
)
=
>
{
dumpv
(
"
CF
length
:
"
+
this
.
length
)
;
let
copying
=
StreamUtils
.
copyStream
(
input
stream
this
.
length
)
;
deferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
stream
done
:
deferred
}
)
;
deferred
.
promise
.
then
(
(
)
=
>
{
dumpv
(
"
onWriteDone
called
ending
bulk
mode
"
)
;
this
.
_done
=
true
;
this
.
_transport
.
resumeOutgoing
(
)
;
}
this
.
_transport
.
close
)
;
this
.
write
=
(
)
=
>
{
throw
new
Error
(
"
Tried
to
write
(
)
a
BulkPacket
'
s
stream
multiple
times
.
"
)
;
}
;
}
Object
.
defineProperty
(
BulkPacket
.
prototype
"
streamReadyForWriting
"
{
get
:
function
(
)
{
return
this
.
_readyForWriting
.
promise
;
}
}
)
;
Object
.
defineProperty
(
BulkPacket
.
prototype
"
header
"
{
get
:
function
(
)
{
return
{
actor
:
this
.
actor
type
:
this
.
type
length
:
this
.
length
}
;
}
set
:
function
(
header
)
{
this
.
actor
=
header
.
actor
;
this
.
type
=
header
.
type
;
this
.
length
=
header
.
length
;
}
}
)
;
Object
.
defineProperty
(
BulkPacket
.
prototype
"
done
"
{
get
:
function
(
)
{
return
this
.
_done
;
}
}
)
;
BulkPacket
.
prototype
.
toString
=
function
(
)
{
return
"
Bulk
:
"
+
JSON
.
stringify
(
this
.
header
null
2
)
;
}
exports
.
BulkPacket
=
BulkPacket
;
function
RawPacket
(
transport
data
)
{
Packet
.
call
(
this
transport
)
;
this
.
_data
=
data
;
this
.
length
=
data
.
length
;
this
.
_done
=
false
;
}
RawPacket
.
prototype
=
Object
.
create
(
Packet
.
prototype
)
;
RawPacket
.
prototype
.
read
=
function
(
stream
)
{
throw
Error
(
"
Not
implmented
.
"
)
;
}
RawPacket
.
prototype
.
write
=
function
(
stream
)
{
let
written
=
stream
.
write
(
this
.
_data
this
.
_data
.
length
)
;
this
.
_data
=
this
.
_data
.
slice
(
written
)
;
this
.
_done
=
!
this
.
_data
.
length
;
}
Object
.
defineProperty
(
RawPacket
.
prototype
"
done
"
{
get
:
function
(
)
{
return
this
.
_done
;
}
}
)
;
exports
.
RawPacket
=
RawPacket
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
module
global
)
{
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
module
.
exports
=
=
freeExports
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
stringFromCharCode
=
String
.
fromCharCode
;
function
ucs2decode
(
string
)
{
var
output
=
[
]
;
var
counter
=
0
;
var
length
=
string
.
length
;
var
value
;
var
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
var
length
=
array
.
length
;
var
index
=
-
1
;
var
value
;
var
output
=
'
'
;
while
(
+
+
index
<
length
)
{
value
=
array
[
index
]
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
}
return
output
;
}
function
checkScalarValue
(
codePoint
)
{
if
(
codePoint
>
=
0xD800
&
&
codePoint
<
=
0xDFFF
)
{
throw
Error
(
'
Lone
surrogate
U
+
'
+
codePoint
.
toString
(
16
)
.
toUpperCase
(
)
+
'
is
not
a
scalar
value
'
)
;
}
}
function
createByte
(
codePoint
shift
)
{
return
stringFromCharCode
(
(
(
codePoint
>
>
shift
)
&
0x3F
)
|
0x80
)
;
}
function
encodeCodePoint
(
codePoint
)
{
if
(
(
codePoint
&
0xFFFFFF80
)
=
=
0
)
{
return
stringFromCharCode
(
codePoint
)
;
}
var
symbol
=
'
'
;
if
(
(
codePoint
&
0xFFFFF800
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
6
)
&
0x1F
)
|
0xC0
)
;
}
else
if
(
(
codePoint
&
0xFFFF0000
)
=
=
0
)
{
checkScalarValue
(
codePoint
)
;
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
12
)
&
0x0F
)
|
0xE0
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
else
if
(
(
codePoint
&
0xFFE00000
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
18
)
&
0x07
)
|
0xF0
)
;
symbol
+
=
createByte
(
codePoint
12
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
symbol
+
=
stringFromCharCode
(
(
codePoint
&
0x3F
)
|
0x80
)
;
return
symbol
;
}
function
utf8encode
(
string
)
{
var
codePoints
=
ucs2decode
(
string
)
;
var
length
=
codePoints
.
length
;
var
index
=
-
1
;
var
codePoint
;
var
byteString
=
'
'
;
while
(
+
+
index
<
length
)
{
codePoint
=
codePoints
[
index
]
;
byteString
+
=
encodeCodePoint
(
codePoint
)
;
}
return
byteString
;
}
function
readContinuationByte
(
)
{
if
(
byteIndex
>
=
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
var
continuationByte
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
continuationByte
&
0xC0
)
=
=
0x80
)
{
return
continuationByte
&
0x3F
;
}
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
function
decodeSymbol
(
)
{
var
byte1
;
var
byte2
;
var
byte3
;
var
byte4
;
var
codePoint
;
if
(
byteIndex
>
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
if
(
byteIndex
=
=
byteCount
)
{
return
false
;
}
byte1
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
byte1
&
0x80
)
=
=
0
)
{
return
byte1
;
}
if
(
(
byte1
&
0xE0
)
=
=
0xC0
)
{
var
byte2
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x1F
)
<
<
6
)
|
byte2
;
if
(
codePoint
>
=
0x80
)
{
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF0
)
=
=
0xE0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
12
)
|
(
byte2
<
<
6
)
|
byte3
;
if
(
codePoint
>
=
0x0800
)
{
checkScalarValue
(
codePoint
)
;
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF8
)
=
=
0xF0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
byte4
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
0x12
)
|
(
byte2
<
<
0x0C
)
|
(
byte3
<
<
0x06
)
|
byte4
;
if
(
codePoint
>
=
0x010000
&
&
codePoint
<
=
0x10FFFF
)
{
return
codePoint
;
}
}
throw
Error
(
'
Invalid
UTF
-
8
detected
'
)
;
}
var
byteArray
;
var
byteCount
;
var
byteIndex
;
function
utf8decode
(
byteString
)
{
byteArray
=
ucs2decode
(
byteString
)
;
byteCount
=
byteArray
.
length
;
byteIndex
=
0
;
var
codePoints
=
[
]
;
var
tmp
;
while
(
(
tmp
=
decodeSymbol
(
)
)
!
=
=
false
)
{
codePoints
.
push
(
tmp
)
;
}
return
ucs2encode
(
codePoints
)
;
}
var
utf8
=
{
'
version
'
:
'
2
.
0
.
0
'
'
encode
'
:
utf8encode
'
decode
'
:
utf8decode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
utf8
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
!
freeExports
.
nodeType
)
{
if
(
freeModule
)
{
freeModule
.
exports
=
utf8
;
}
else
{
var
object
=
{
}
;
var
hasOwnProperty
=
object
.
hasOwnProperty
;
for
(
var
key
in
utf8
)
{
hasOwnProperty
.
call
(
utf8
key
)
&
&
(
freeExports
[
key
]
=
utf8
[
key
]
)
;
}
}
}
else
{
root
.
utf8
=
utf8
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
250
)
(
module
)
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
module
global
)
{
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
module
.
exports
=
=
freeExports
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
stringFromCharCode
=
String
.
fromCharCode
;
function
ucs2decode
(
string
)
{
var
output
=
[
]
;
var
counter
=
0
;
var
length
=
string
.
length
;
var
value
;
var
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
var
length
=
array
.
length
;
var
index
=
-
1
;
var
value
;
var
output
=
'
'
;
while
(
+
+
index
<
length
)
{
value
=
array
[
index
]
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
}
return
output
;
}
function
checkScalarValue
(
codePoint
)
{
if
(
codePoint
>
=
0xD800
&
&
codePoint
<
=
0xDFFF
)
{
throw
Error
(
'
Lone
surrogate
U
+
'
+
codePoint
.
toString
(
16
)
.
toUpperCase
(
)
+
'
is
not
a
scalar
value
'
)
;
}
}
function
createByte
(
codePoint
shift
)
{
return
stringFromCharCode
(
(
(
codePoint
>
>
shift
)
&
0x3F
)
|
0x80
)
;
}
function
encodeCodePoint
(
codePoint
)
{
if
(
(
codePoint
&
0xFFFFFF80
)
=
=
0
)
{
return
stringFromCharCode
(
codePoint
)
;
}
var
symbol
=
'
'
;
if
(
(
codePoint
&
0xFFFFF800
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
6
)
&
0x1F
)
|
0xC0
)
;
}
else
if
(
(
codePoint
&
0xFFFF0000
)
=
=
0
)
{
checkScalarValue
(
codePoint
)
;
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
12
)
&
0x0F
)
|
0xE0
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
else
if
(
(
codePoint
&
0xFFE00000
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
18
)
&
0x07
)
|
0xF0
)
;
symbol
+
=
createByte
(
codePoint
12
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
symbol
+
=
stringFromCharCode
(
(
codePoint
&
0x3F
)
|
0x80
)
;
return
symbol
;
}
function
utf8encode
(
string
)
{
var
codePoints
=
ucs2decode
(
string
)
;
var
length
=
codePoints
.
length
;
var
index
=
-
1
;
var
codePoint
;
var
byteString
=
'
'
;
while
(
+
+
index
<
length
)
{
codePoint
=
codePoints
[
index
]
;
byteString
+
=
encodeCodePoint
(
codePoint
)
;
}
return
byteString
;
}
function
readContinuationByte
(
)
{
if
(
byteIndex
>
=
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
var
continuationByte
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
continuationByte
&
0xC0
)
=
=
0x80
)
{
return
continuationByte
&
0x3F
;
}
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
function
decodeSymbol
(
)
{
var
byte1
;
var
byte2
;
var
byte3
;
var
byte4
;
var
codePoint
;
if
(
byteIndex
>
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
if
(
byteIndex
=
=
byteCount
)
{
return
false
;
}
byte1
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
byte1
&
0x80
)
=
=
0
)
{
return
byte1
;
}
if
(
(
byte1
&
0xE0
)
=
=
0xC0
)
{
var
byte2
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x1F
)
<
<
6
)
|
byte2
;
if
(
codePoint
>
=
0x80
)
{
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF0
)
=
=
0xE0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
12
)
|
(
byte2
<
<
6
)
|
byte3
;
if
(
codePoint
>
=
0x0800
)
{
checkScalarValue
(
codePoint
)
;
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF8
)
=
=
0xF0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
byte4
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
0x12
)
|
(
byte2
<
<
0x0C
)
|
(
byte3
<
<
0x06
)
|
byte4
;
if
(
codePoint
>
=
0x010000
&
&
codePoint
<
=
0x10FFFF
)
{
return
codePoint
;
}
}
throw
Error
(
'
Invalid
UTF
-
8
detected
'
)
;
}
var
byteArray
;
var
byteCount
;
var
byteIndex
;
function
utf8decode
(
byteString
)
{
byteArray
=
ucs2decode
(
byteString
)
;
byteCount
=
byteArray
.
length
;
byteIndex
=
0
;
var
codePoints
=
[
]
;
var
tmp
;
while
(
(
tmp
=
decodeSymbol
(
)
)
!
=
=
false
)
{
codePoints
.
push
(
tmp
)
;
}
return
ucs2encode
(
codePoints
)
;
}
var
utf8
=
{
'
version
'
:
'
2
.
0
.
0
'
'
encode
'
:
utf8encode
'
decode
'
:
utf8decode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
utf8
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
!
freeExports
.
nodeType
)
{
if
(
freeModule
)
{
freeModule
.
exports
=
utf8
;
}
else
{
var
object
=
{
}
;
var
hasOwnProperty
=
object
.
hasOwnProperty
;
for
(
var
key
in
utf8
)
{
hasOwnProperty
.
call
(
utf8
key
)
&
&
(
freeExports
[
key
]
=
utf8
[
key
]
)
;
}
}
}
else
{
root
.
utf8
=
utf8
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
250
)
(
module
)
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
EventEmitter
=
__webpack_require__
(
260
)
;
function
WebSocketDebuggerTransport
(
socket
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
active
=
false
;
this
.
hooks
=
null
;
this
.
socket
=
socket
;
}
WebSocketDebuggerTransport
.
prototype
=
{
ready
(
)
{
if
(
this
.
active
)
{
return
;
}
this
.
socket
.
addEventListener
(
"
message
"
this
)
;
this
.
socket
.
addEventListener
(
"
close
"
this
)
;
this
.
active
=
true
;
}
send
(
object
)
{
this
.
emit
(
"
send
"
object
)
;
if
(
this
.
socket
)
{
this
.
socket
.
send
(
JSON
.
stringify
(
object
)
)
;
}
}
startBulkSend
(
)
{
throw
new
Error
(
"
Bulk
send
is
not
supported
by
WebSocket
transport
"
)
;
}
close
(
)
{
this
.
emit
(
"
onClosed
"
)
;
this
.
active
=
false
;
this
.
socket
.
removeEventListener
(
"
message
"
this
)
;
this
.
socket
.
removeEventListener
(
"
close
"
this
)
;
this
.
socket
.
close
(
)
;
this
.
socket
=
null
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
)
;
this
.
hooks
=
null
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
message
"
:
this
.
onMessage
(
event
)
;
break
;
case
"
close
"
:
this
.
close
(
)
;
break
;
}
}
onMessage
(
{
data
}
)
{
if
(
typeof
data
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Binary
messages
are
not
supported
by
WebSocket
transport
"
)
;
}
let
object
=
JSON
.
parse
(
data
)
;
this
.
emit
(
"
onPacket
"
object
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onPacket
(
object
)
;
}
}
}
;
module
.
exports
=
WebSocketDebuggerTransport
;
}
function
(
module
exports
__webpack_require__
)
{
var
EventEmitter
=
function
(
)
{
}
;
var
defer
=
__webpack_require__
(
261
)
;
EventEmitter
.
decorate
=
function
(
objectToDecorate
)
{
var
emitter
=
new
EventEmitter
(
)
;
objectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
objectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
objectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
objectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
this
.
_eventEmitterListeners
=
new
Map
(
)
;
}
if
(
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
this
.
_eventEmitterListeners
.
set
(
event
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
event
)
.
push
(
listener
)
;
}
once
(
event
listener
)
{
var
_this
=
this
;
var
deferred
=
defer
(
)
;
var
handler
=
function
(
_
first
)
{
for
(
var
_len
=
arguments
.
length
rest
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
rest
[
_key
-
2
]
=
arguments
[
_key
]
;
}
_this
.
off
(
event
handler
)
;
if
(
listener
)
{
listener
.
apply
(
null
[
event
first
]
.
concat
(
rest
)
)
;
}
deferred
.
resolve
(
first
)
;
}
;
handler
.
_originalListener
=
listener
;
this
.
on
(
event
handler
)
;
return
deferred
.
promise
;
}
off
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
return
;
}
var
listeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
event
listeners
.
filter
(
l
=
>
{
return
l
!
=
=
listener
&
&
l
.
_originalListener
!
=
=
listener
;
}
)
)
;
}
}
emit
(
event
)
{
var
_this2
=
this
_arguments
=
arguments
;
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
return
;
}
var
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
var
_loop
=
function
(
listener
)
{
if
(
!
_this2
.
_eventEmitterListeners
)
{
return
"
break
"
;
}
if
(
originalListeners
=
=
=
_this2
.
_eventEmitterListeners
.
get
(
event
)
|
|
_this2
.
_eventEmitterListeners
.
get
(
event
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
.
apply
(
null
_arguments
)
;
}
catch
(
ex
)
{
var
msg
=
ex
+
"
:
"
+
ex
.
stack
;
console
.
error
(
msg
)
;
dump
(
msg
+
"
\
n
"
)
;
}
}
}
;
for
(
var
listener
of
this
.
_eventEmitterListeners
.
get
(
event
)
)
{
var
_ret
=
_loop
(
listener
)
;
if
(
_ret
=
=
=
"
break
"
)
break
;
}
}
}
;
module
.
exports
=
EventEmitter
;
}
function
(
module
exports
)
{
module
.
exports
=
function
defer
(
)
{
var
resolve
=
void
0
reject
=
void
0
;
var
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Ci
Cu
}
=
__webpack_require__
(
178
)
;
const
promise
=
__webpack_require__
(
189
)
;
const
EventEmitter
=
__webpack_require__
(
253
)
;
const
{
Services
}
=
__webpack_require__
(
183
)
;
const
{
DebuggerClient
}
=
__webpack_require__
(
248
)
;
const
targets
=
new
WeakMap
(
)
;
const
promiseTargets
=
new
WeakMap
(
)
;
exports
.
TargetFactory
=
{
forTab
:
function
(
tab
)
{
let
target
=
targets
.
get
(
tab
)
;
if
(
target
=
=
null
)
{
target
=
new
TabTarget
(
tab
)
;
targets
.
set
(
tab
target
)
;
}
return
target
;
}
forRemoteTab
:
function
(
options
)
{
let
targetPromise
=
promiseTargets
.
get
(
options
)
;
if
(
targetPromise
=
=
null
)
{
let
target
=
new
TabTarget
(
options
)
;
targetPromise
=
target
.
makeRemote
(
)
.
then
(
(
)
=
>
target
)
;
promiseTargets
.
set
(
options
targetPromise
)
;
}
return
targetPromise
;
}
forWorker
:
function
(
workerClient
)
{
let
target
=
targets
.
get
(
workerClient
)
;
if
(
target
=
=
null
)
{
target
=
new
WorkerTarget
(
workerClient
)
;
targets
.
set
(
workerClient
target
)
;
}
return
target
;
}
isKnownTab
:
function
(
tab
)
{
return
targets
.
has
(
tab
)
;
}
}
;
function
TabTarget
(
tab
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_handleThreadState
=
this
.
_handleThreadState
.
bind
(
this
)
;
this
.
on
(
"
thread
-
resumed
"
this
.
_handleThreadState
)
;
this
.
on
(
"
thread
-
paused
"
this
.
_handleThreadState
)
;
this
.
activeTab
=
this
.
activeConsole
=
null
;
if
(
tab
&
&
!
[
"
client
"
"
form
"
"
chrome
"
]
.
every
(
tab
.
hasOwnProperty
tab
)
)
{
this
.
_tab
=
tab
;
this
.
_setupListeners
(
)
;
}
else
{
this
.
_form
=
tab
.
form
;
this
.
_client
=
tab
.
client
;
this
.
_chrome
=
tab
.
chrome
;
}
if
(
typeof
tab
.
isTabActor
=
=
"
boolean
"
)
{
this
.
_isTabActor
=
tab
.
isTabActor
;
}
else
{
this
.
_isTabActor
=
true
;
}
}
TabTarget
.
prototype
=
{
_webProgressListener
:
null
getActorDescription
:
function
(
actorName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
getActorDescription
(
)
can
only
be
called
on
"
+
"
remote
tabs
.
"
)
;
}
let
deferred
=
promise
.
defer
(
)
;
if
(
this
.
_protocolDescription
&
&
this
.
_protocolDescription
.
types
[
actorName
]
)
{
deferred
.
resolve
(
this
.
_protocolDescription
.
types
[
actorName
]
)
;
}
else
{
this
.
client
.
mainRoot
.
protocolDescription
(
description
=
>
{
this
.
_protocolDescription
=
description
;
deferred
.
resolve
(
description
.
types
[
actorName
]
)
;
}
)
;
}
return
deferred
.
promise
;
}
hasActor
:
function
(
actorName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
hasActor
(
)
can
only
be
called
on
remote
"
+
"
tabs
.
"
)
;
}
if
(
this
.
form
)
{
return
!
!
this
.
form
[
actorName
+
"
Actor
"
]
;
}
return
false
;
}
actorHasMethod
:
function
(
actorName
methodName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
actorHasMethod
(
)
can
only
be
called
on
"
+
"
remote
tabs
.
"
)
;
}
return
this
.
getActorDescription
(
actorName
)
.
then
(
desc
=
>
{
if
(
desc
&
&
desc
.
methods
)
{
return
!
!
desc
.
methods
.
find
(
method
=
>
method
.
name
=
=
=
methodName
)
;
}
return
false
;
}
)
;
}
getTrait
:
function
(
traitName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
getTrait
(
)
can
only
be
called
on
remote
"
+
"
tabs
.
"
)
;
}
if
(
this
.
form
.
traits
&
&
traitName
in
this
.
form
.
traits
)
{
return
this
.
form
.
traits
[
traitName
]
;
}
return
this
.
client
.
traits
[
traitName
]
;
}
get
tab
(
)
{
return
this
.
_tab
;
}
get
form
(
)
{
return
this
.
_form
;
}
get
root
(
)
{
if
(
!
this
.
_root
)
{
this
.
_root
=
this
.
_getRoot
(
)
;
}
return
this
.
_root
;
}
_getRoot
:
function
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
client
.
listTabs
(
response
=
>
{
if
(
response
.
error
)
{
reject
(
new
Error
(
response
.
error
+
"
:
"
+
response
.
message
)
)
;
return
;
}
resolve
(
response
)
;
}
)
;
}
)
;
}
get
client
(
)
{
return
this
.
_client
;
}
get
chrome
(
)
{
return
this
.
_chrome
;
}
get
isTabActor
(
)
{
return
this
.
_isTabActor
;
}
get
window
(
)
{
if
(
this
.
_tab
&
&
this
.
_tab
.
linkedBrowser
)
{
return
this
.
_tab
.
linkedBrowser
.
contentWindow
;
}
return
null
;
}
get
name
(
)
{
if
(
this
.
_tab
&
&
this
.
_tab
.
linkedBrowser
.
contentDocument
)
{
return
this
.
_tab
.
linkedBrowser
.
contentDocument
.
title
;
}
if
(
this
.
isAddon
)
{
return
this
.
_form
.
name
;
}
return
this
.
_form
.
title
;
}
get
url
(
)
{
return
this
.
_tab
?
this
.
_tab
.
linkedBrowser
.
currentURI
.
spec
:
this
.
_form
.
url
;
}
get
isRemote
(
)
{
return
!
this
.
isLocalTab
;
}
get
isAddon
(
)
{
return
!
!
(
this
.
_form
&
&
this
.
_form
.
actor
&
&
this
.
_form
.
actor
.
match
(
/
conn
\
d
+
\
.
addon
\
d
+
/
)
)
;
}
get
isLocalTab
(
)
{
return
!
!
this
.
_tab
;
}
get
isMultiProcess
(
)
{
return
!
this
.
window
;
}
get
isThreadPaused
(
)
{
return
!
!
this
.
_isThreadPaused
;
}
makeRemote
:
function
(
)
{
if
(
this
.
_remote
)
{
return
this
.
_remote
.
promise
;
}
this
.
_remote
=
promise
.
defer
(
)
;
if
(
this
.
isLocalTab
)
{
if
(
!
DebuggerServer
.
initialized
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
addBrowserActors
(
)
;
}
this
.
_client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
this
.
_chrome
=
false
;
}
this
.
_setupRemoteListeners
(
)
;
let
attachTab
=
(
)
=
>
{
this
.
_client
.
attachTab
(
this
.
_form
.
actor
(
response
tabClient
)
=
>
{
if
(
!
tabClient
)
{
this
.
_remote
.
reject
(
"
Unable
to
attach
to
the
tab
"
)
;
return
;
}
this
.
activeTab
=
tabClient
;
this
.
threadActor
=
response
.
threadActor
;
attachConsole
(
)
;
}
)
;
}
;
let
onConsoleAttached
=
(
response
consoleClient
)
=
>
{
if
(
!
consoleClient
)
{
this
.
_remote
.
reject
(
"
Unable
to
attach
to
the
console
"
)
;
return
;
}
this
.
activeConsole
=
consoleClient
;
this
.
_remote
.
resolve
(
null
)
;
}
;
let
attachConsole
=
(
)
=
>
{
this
.
_client
.
attachConsole
(
this
.
_form
.
consoleActor
[
"
NetworkActivity
"
]
onConsoleAttached
)
;
}
;
if
(
this
.
isLocalTab
)
{
this
.
_client
.
connect
(
(
)
=
>
{
this
.
_client
.
getTab
(
{
tab
:
this
.
tab
}
)
.
then
(
response
=
>
{
this
.
_form
=
response
.
tab
;
attachTab
(
)
;
}
)
;
}
)
;
}
else
if
(
this
.
isTabActor
)
{
attachTab
(
)
;
}
else
{
attachConsole
(
)
;
}
return
this
.
_remote
.
promise
;
}
_setupListeners
:
function
(
)
{
this
.
_webProgressListener
=
new
TabWebProgressListener
(
this
)
;
this
.
tab
.
linkedBrowser
.
addProgressListener
(
this
.
_webProgressListener
)
;
this
.
tab
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
tab
.
parentNode
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
tab
.
ownerDocument
.
defaultView
.
addEventListener
(
"
unload
"
this
)
;
}
_teardownListeners
:
function
(
)
{
if
(
this
.
_webProgressListener
)
{
this
.
_webProgressListener
.
destroy
(
)
;
}
this
.
_tab
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
unload
"
this
)
;
this
.
_tab
.
removeEventListener
(
"
TabClose
"
this
)
;
this
.
_tab
.
parentNode
.
removeEventListener
(
"
TabSelect
"
this
)
;
}
_setupRemoteListeners
:
function
(
)
{
this
.
client
.
addListener
(
"
closed
"
this
.
destroy
)
;
this
.
_onTabDetached
=
(
aType
aPacket
)
=
>
{
if
(
aPacket
.
from
=
=
this
.
_form
.
actor
)
{
this
.
destroy
(
)
;
}
}
;
this
.
client
.
addListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
_onTabNavigated
=
(
aType
aPacket
)
=
>
{
let
event
=
Object
.
create
(
null
)
;
event
.
url
=
aPacket
.
url
;
event
.
title
=
aPacket
.
title
;
event
.
nativeConsoleAPI
=
aPacket
.
nativeConsoleAPI
;
event
.
isFrameSwitching
=
aPacket
.
isFrameSwitching
;
if
(
aPacket
.
state
=
=
"
start
"
)
{
event
.
_navPayload
=
this
.
_navRequest
;
this
.
emit
(
"
will
-
navigate
"
event
)
;
this
.
_navRequest
=
null
;
}
else
{
event
.
_navPayload
=
this
.
_navWindow
;
this
.
emit
(
"
navigate
"
event
)
;
this
.
_navWindow
=
null
;
}
}
;
this
.
client
.
addListener
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
_onFrameUpdate
=
(
aType
aPacket
)
=
>
{
this
.
emit
(
"
frame
-
update
"
aPacket
)
;
}
;
this
.
client
.
addListener
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
}
_teardownRemoteListeners
:
function
(
)
{
this
.
client
.
removeListener
(
"
closed
"
this
.
destroy
)
;
this
.
client
.
removeListener
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
client
.
removeListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
client
.
removeListener
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
}
handleEvent
:
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabClose
"
:
case
"
unload
"
:
this
.
destroy
(
)
;
break
;
case
"
TabSelect
"
:
if
(
this
.
tab
.
selected
)
{
this
.
emit
(
"
visible
"
event
)
;
}
else
{
this
.
emit
(
"
hidden
"
event
)
;
}
break
;
}
}
_handleThreadState
:
function
(
event
)
{
switch
(
event
)
{
case
"
thread
-
resumed
"
:
this
.
_isThreadPaused
=
false
;
break
;
case
"
thread
-
paused
"
:
this
.
_isThreadPaused
=
true
;
break
;
}
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
.
promise
;
}
this
.
_destroyer
=
promise
.
defer
(
)
;
this
.
emit
(
"
close
"
)
;
this
.
off
(
"
thread
-
resumed
"
this
.
_handleThreadState
)
;
this
.
off
(
"
thread
-
paused
"
this
.
_handleThreadState
)
;
if
(
this
.
_tab
)
{
this
.
_teardownListeners
(
)
;
}
let
cleanupAndResolve
=
(
)
=
>
{
this
.
_cleanup
(
)
;
this
.
_destroyer
.
resolve
(
null
)
;
}
;
if
(
this
.
_tab
&
&
!
this
.
_client
)
{
cleanupAndResolve
(
)
;
}
else
if
(
this
.
_client
)
{
this
.
_teardownRemoteListeners
(
)
;
if
(
this
.
isLocalTab
)
{
this
.
_client
.
close
(
cleanupAndResolve
)
;
}
else
if
(
this
.
activeTab
)
{
this
.
activeTab
.
detach
(
)
;
cleanupAndResolve
(
)
;
}
else
{
cleanupAndResolve
(
)
;
}
}
return
this
.
_destroyer
.
promise
;
}
_cleanup
:
function
(
)
{
if
(
this
.
_tab
)
{
targets
.
delete
(
this
.
_tab
)
;
}
else
{
promiseTargets
.
delete
(
this
.
_form
)
;
}
this
.
activeTab
=
null
;
this
.
activeConsole
=
null
;
this
.
_client
=
null
;
this
.
_tab
=
null
;
this
.
_form
=
null
;
this
.
_remote
=
null
;
}
toString
:
function
(
)
{
let
id
=
this
.
_tab
?
this
.
_tab
:
(
this
.
_form
&
&
this
.
_form
.
actor
)
;
return
TabTarget
:
{
id
}
;
}
}
;
function
WorkerTarget
(
workerClient
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_workerClient
=
workerClient
;
}
WorkerTarget
.
prototype
=
{
destroy
:
function
(
)
{
}
get
isRemote
(
)
{
return
true
;
}
get
isTabActor
(
)
{
return
true
;
}
get
url
(
)
{
return
this
.
_workerClient
.
url
;
}
get
isWorkerTarget
(
)
{
return
true
;
}
get
form
(
)
{
return
{
consoleActor
:
this
.
_workerClient
.
consoleActor
}
;
}
get
activeTab
(
)
{
return
this
.
_workerClient
;
}
get
client
(
)
{
return
this
.
_workerClient
.
client
;
}
destroy
:
function
(
)
{
}
hasActor
:
function
(
name
)
{
return
false
;
}
getTrait
:
function
(
)
{
return
undefined
;
}
makeRemote
:
function
(
)
{
return
Promise
.
resolve
(
)
;
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
t
=
__webpack_require__
(
264
)
;
var
Tab
=
t
.
struct
(
{
title
:
t
.
String
url
:
t
.
String
id
:
t
.
String
tab
:
t
.
Object
browser
:
t
.
enums
.
of
(
[
"
chrome
"
"
firefox
"
]
)
}
"
Tab
"
)
;
var
SourceText
=
t
.
struct
(
{
text
:
t
.
String
contentType
:
t
.
String
}
)
;
var
Source
=
t
.
struct
(
{
id
:
t
.
String
url
:
t
.
union
(
[
t
.
String
t
.
Nil
]
)
isPrettyPrinted
:
t
.
Boolean
sourceMapURL
:
t
.
union
(
[
t
.
String
t
.
Nil
]
)
}
"
Source
"
)
;
var
Location
=
t
.
struct
(
{
sourceId
:
t
.
String
line
:
t
.
Number
column
:
t
.
union
(
[
t
.
Number
t
.
Nil
]
)
}
"
Location
"
)
;
var
Breakpoint
=
t
.
struct
(
{
id
:
t
.
String
loading
:
t
.
Boolean
disabled
:
t
.
Boolean
text
:
t
.
String
condition
:
t
.
union
(
[
t
.
String
t
.
Nil
]
)
}
)
;
var
BreakpointResult
=
t
.
struct
(
{
id
:
t
.
String
actualLocation
:
Location
}
)
;
var
Frame
=
t
.
struct
(
{
id
:
t
.
String
displayName
:
t
.
String
location
:
Location
scope
:
t
.
union
(
[
t
.
Object
t
.
Nil
]
)
}
"
Frame
"
)
;
module
.
exports
=
{
Tab
Source
SourceText
Location
Breakpoint
BreakpointResult
Frame
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
t
=
__webpack_require__
(
265
)
;
t
.
Any
=
__webpack_require__
(
271
)
;
t
.
Array
=
__webpack_require__
(
279
)
;
t
.
Boolean
=
__webpack_require__
(
280
)
;
t
.
Date
=
__webpack_require__
(
282
)
;
t
.
Error
=
__webpack_require__
(
283
)
;
t
.
Function
=
__webpack_require__
(
284
)
;
t
.
Nil
=
__webpack_require__
(
285
)
;
t
.
Number
=
__webpack_require__
(
286
)
;
t
.
Integer
=
__webpack_require__
(
288
)
;
t
.
IntegerT
=
t
.
Integer
;
t
.
Object
=
__webpack_require__
(
294
)
;
t
.
RegExp
=
__webpack_require__
(
295
)
;
t
.
String
=
__webpack_require__
(
296
)
;
t
.
Type
=
__webpack_require__
(
297
)
;
t
.
TypeT
=
t
.
Type
;
t
.
Arr
=
t
.
Array
;
t
.
Bool
=
t
.
Boolean
;
t
.
Dat
=
t
.
Date
;
t
.
Err
=
t
.
Error
;
t
.
Func
=
t
.
Function
;
t
.
Num
=
t
.
Number
;
t
.
Obj
=
t
.
Object
;
t
.
Re
=
t
.
RegExp
;
t
.
Str
=
t
.
String
;
t
.
dict
=
__webpack_require__
(
298
)
;
t
.
declare
=
__webpack_require__
(
299
)
;
t
.
enums
=
__webpack_require__
(
301
)
;
t
.
irreducible
=
__webpack_require__
(
272
)
;
t
.
list
=
__webpack_require__
(
302
)
;
t
.
maybe
=
__webpack_require__
(
303
)
;
t
.
refinement
=
__webpack_require__
(
289
)
;
t
.
struct
=
__webpack_require__
(
305
)
;
t
.
tuple
=
__webpack_require__
(
311
)
;
t
.
union
=
__webpack_require__
(
312
)
;
t
.
func
=
__webpack_require__
(
314
)
;
t
.
intersection
=
__webpack_require__
(
315
)
;
t
.
subtype
=
t
.
refinement
;
t
.
inter
=
__webpack_require__
(
316
)
;
t
[
'
interface
'
]
=
t
.
inter
;
t
.
assert
=
t
;
t
.
update
=
__webpack_require__
(
317
)
;
t
.
mixin
=
__webpack_require__
(
300
)
;
t
.
isType
=
__webpack_require__
(
276
)
;
t
.
is
=
__webpack_require__
(
293
)
;
t
.
getTypeName
=
__webpack_require__
(
275
)
;
t
.
match
=
__webpack_require__
(
318
)
;
module
.
exports
=
t
;
}
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
266
)
;
var
isNil
=
__webpack_require__
(
267
)
;
var
fail
=
__webpack_require__
(
268
)
;
var
stringify
=
__webpack_require__
(
269
)
;
function
assert
(
guard
message
)
{
if
(
guard
!
=
=
true
)
{
if
(
isFunction
(
message
)
)
{
message
=
message
(
)
;
}
else
if
(
isNil
(
message
)
)
{
message
=
'
Assert
failed
(
turn
on
"
Pause
on
exceptions
"
in
your
Source
panel
)
'
;
}
assert
.
fail
(
message
)
;
}
}
assert
.
fail
=
fail
;
assert
.
stringify
=
stringify
;
module
.
exports
=
assert
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isFunction
(
x
)
{
return
typeof
x
=
=
=
'
function
'
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isNil
(
x
)
{
return
x
=
=
=
null
|
|
x
=
=
=
void
0
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
fail
(
message
)
{
throw
new
TypeError
(
'
[
tcomb
]
'
+
message
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
getFunctionName
=
__webpack_require__
(
270
)
;
function
replacer
(
key
value
)
{
if
(
typeof
value
=
=
=
'
function
'
)
{
return
getFunctionName
(
value
)
;
}
return
value
;
}
module
.
exports
=
function
stringify
(
x
)
{
try
{
return
JSON
.
stringify
(
x
replacer
2
)
;
}
catch
(
e
)
{
return
String
(
x
)
;
}
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
getFunctionName
(
f
)
{
return
f
.
displayName
|
|
f
.
name
|
|
'
<
function
'
+
f
.
length
+
'
>
'
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
module
.
exports
=
irreducible
(
'
Any
'
function
(
)
{
return
true
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isString
=
__webpack_require__
(
273
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
forbidNewOperator
=
__webpack_require__
(
274
)
;
module
.
exports
=
function
irreducible
(
name
predicate
)
{
if
(
false
)
{
assert
(
isString
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
irreducible
(
name
predicate
)
(
expected
a
string
)
'
;
}
)
;
assert
(
isFunction
(
predicate
)
'
Invalid
argument
predicate
'
+
assert
.
stringify
(
predicate
)
+
'
supplied
to
irreducible
(
name
predicate
)
(
expected
a
function
)
'
)
;
}
function
Irreducible
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Irreducible
)
;
path
=
path
|
|
[
name
]
;
assert
(
predicate
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
Irreducible
.
meta
=
{
kind
:
'
irreducible
'
name
:
name
predicate
:
predicate
identity
:
true
}
;
Irreducible
.
displayName
=
name
;
Irreducible
.
is
=
predicate
;
return
Irreducible
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isString
(
x
)
{
return
typeof
x
=
=
=
'
string
'
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
module
.
exports
=
function
forbidNewOperator
(
x
type
)
{
assert
(
!
(
x
instanceof
type
)
function
(
)
{
return
'
Cannot
use
the
new
operator
to
instantiate
the
type
'
+
getTypeName
(
type
)
;
}
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
var
getFunctionName
=
__webpack_require__
(
270
)
;
module
.
exports
=
function
getTypeName
(
constructor
)
{
if
(
isType
(
constructor
)
)
{
return
constructor
.
displayName
;
}
return
getFunctionName
(
constructor
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
266
)
;
var
isObject
=
__webpack_require__
(
277
)
;
module
.
exports
=
function
isType
(
x
)
{
return
isFunction
(
x
)
&
&
isObject
(
x
.
meta
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isNil
=
__webpack_require__
(
267
)
;
var
isArray
=
__webpack_require__
(
278
)
;
module
.
exports
=
function
isObject
(
x
)
{
return
!
isNil
(
x
)
&
&
typeof
x
=
=
=
'
object
'
&
&
!
isArray
(
x
)
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isArray
(
x
)
{
return
x
instanceof
Array
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isArray
=
__webpack_require__
(
278
)
;
module
.
exports
=
irreducible
(
'
Array
'
isArray
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isBoolean
=
__webpack_require__
(
281
)
;
module
.
exports
=
irreducible
(
'
Boolean
'
isBoolean
)
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isBoolean
(
x
)
{
return
x
=
=
=
true
|
|
x
=
=
=
false
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
module
.
exports
=
irreducible
(
'
Date
'
function
(
x
)
{
return
x
instanceof
Date
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
module
.
exports
=
irreducible
(
'
Error
'
function
(
x
)
{
return
x
instanceof
Error
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
module
.
exports
=
irreducible
(
'
Function
'
isFunction
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isNil
=
__webpack_require__
(
267
)
;
module
.
exports
=
irreducible
(
'
Nil
'
isNil
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isNumber
=
__webpack_require__
(
287
)
;
module
.
exports
=
irreducible
(
'
Number
'
isNumber
)
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isNumber
(
x
)
{
return
typeof
x
=
=
=
'
number
'
&
&
isFinite
(
x
)
&
&
!
isNaN
(
x
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
refinement
=
__webpack_require__
(
289
)
;
var
Number
=
__webpack_require__
(
286
)
;
module
.
exports
=
refinement
(
Number
function
(
x
)
{
return
x
%
1
=
=
=
0
;
}
'
Integer
'
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
forbidNewOperator
=
__webpack_require__
(
274
)
;
var
isIdentity
=
__webpack_require__
(
291
)
;
var
create
=
__webpack_require__
(
292
)
;
var
is
=
__webpack_require__
(
293
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
getFunctionName
=
__webpack_require__
(
270
)
;
function
getDefaultName
(
type
predicate
)
{
return
'
{
'
+
getTypeName
(
type
)
+
'
|
'
+
getFunctionName
(
predicate
)
+
'
}
'
;
}
function
refinement
(
type
predicate
name
)
{
if
(
false
)
{
assert
(
isFunction
(
type
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
type
)
+
'
supplied
to
refinement
(
type
predicate
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isFunction
(
predicate
)
function
(
)
{
return
'
Invalid
argument
predicate
supplied
to
refinement
(
type
predicate
[
name
]
)
combinator
(
expected
a
function
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
refinement
(
type
predicate
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
type
predicate
)
;
var
identity
=
isIdentity
(
type
)
;
function
Refinement
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Refinement
)
;
path
=
path
|
|
[
displayName
]
;
}
var
x
=
create
(
type
value
path
)
;
if
(
false
)
{
assert
(
predicate
(
x
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
x
;
}
Refinement
.
meta
=
{
kind
:
'
subtype
'
type
:
type
predicate
:
predicate
name
:
name
identity
:
identity
}
;
Refinement
.
displayName
=
displayName
;
Refinement
.
is
=
function
(
x
)
{
return
is
(
x
type
)
&
&
predicate
(
x
)
;
}
;
Refinement
.
update
=
function
(
instance
patch
)
{
return
Refinement
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Refinement
;
}
refinement
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
refinement
;
}
function
(
module
exports
__webpack_require__
)
{
var
isNil
=
__webpack_require__
(
267
)
;
var
isString
=
__webpack_require__
(
273
)
;
module
.
exports
=
function
isTypeName
(
name
)
{
return
isNil
(
name
)
|
|
isString
(
name
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
Boolean
=
__webpack_require__
(
280
)
;
var
isType
=
__webpack_require__
(
276
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
module
.
exports
=
function
isIdentity
(
type
)
{
if
(
isType
(
type
)
)
{
if
(
false
)
{
assert
(
Boolean
.
is
(
type
.
meta
.
identity
)
function
(
)
{
return
'
Invalid
meta
identity
'
+
assert
.
stringify
(
type
.
meta
.
identity
)
+
'
supplied
to
type
'
+
getTypeName
(
type
)
;
}
)
;
}
return
type
.
meta
.
identity
;
}
return
true
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
var
getFunctionName
=
__webpack_require__
(
270
)
;
var
assert
=
__webpack_require__
(
265
)
;
var
stringify
=
__webpack_require__
(
269
)
;
module
.
exports
=
function
create
(
type
value
path
)
{
if
(
isType
(
type
)
)
{
return
type
.
meta
.
kind
=
=
=
'
struct
'
?
new
type
(
value
path
)
:
type
(
value
path
)
;
}
if
(
false
)
{
path
=
path
|
|
[
getFunctionName
(
type
)
]
;
assert
(
value
instanceof
type
function
(
)
{
return
'
Invalid
value
'
+
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
module
.
exports
=
function
is
(
x
type
)
{
if
(
isType
(
type
)
)
{
return
type
.
is
(
x
)
;
}
return
x
instanceof
type
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isObject
=
__webpack_require__
(
277
)
;
module
.
exports
=
irreducible
(
'
Object
'
isObject
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
module
.
exports
=
irreducible
(
'
RegExp
'
function
(
x
)
{
return
x
instanceof
RegExp
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isString
=
__webpack_require__
(
273
)
;
module
.
exports
=
irreducible
(
'
String
'
isString
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
272
)
;
var
isType
=
__webpack_require__
(
276
)
;
module
.
exports
=
irreducible
(
'
Type
'
isType
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
isIdentity
=
__webpack_require__
(
291
)
;
var
isObject
=
__webpack_require__
(
277
)
;
var
create
=
__webpack_require__
(
292
)
;
var
is
=
__webpack_require__
(
293
)
;
function
getDefaultName
(
domain
codomain
)
{
return
'
{
[
key
:
'
+
getTypeName
(
domain
)
+
'
]
:
'
+
getTypeName
(
codomain
)
+
'
}
'
;
}
function
dict
(
domain
codomain
name
)
{
if
(
false
)
{
assert
(
isFunction
(
domain
)
function
(
)
{
return
'
Invalid
argument
domain
'
+
assert
.
stringify
(
domain
)
+
'
supplied
to
dict
(
domain
codomain
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isFunction
(
codomain
)
function
(
)
{
return
'
Invalid
argument
codomain
'
+
assert
.
stringify
(
codomain
)
+
'
supplied
to
dict
(
domain
codomain
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
dict
(
domain
codomain
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
domain
codomain
)
;
var
domainNameCache
=
getTypeName
(
domain
)
;
var
codomainNameCache
=
getTypeName
(
codomain
)
;
var
identity
=
isIdentity
(
domain
)
&
&
isIdentity
(
codomain
)
;
function
Dict
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isObject
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
var
idempotent
=
true
;
var
ret
=
{
}
;
for
(
var
k
in
value
)
{
if
(
value
.
hasOwnProperty
(
k
)
)
{
k
=
create
(
domain
k
(
false
?
path
.
concat
(
domainNameCache
)
:
null
)
)
;
var
actual
=
value
[
k
]
;
var
instance
=
create
(
codomain
actual
(
false
?
path
.
concat
(
k
+
'
:
'
+
codomainNameCache
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
[
k
]
=
instance
;
}
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
Dict
.
meta
=
{
kind
:
'
dict
'
domain
:
domain
codomain
:
codomain
name
:
name
identity
:
identity
}
;
Dict
.
displayName
=
displayName
;
Dict
.
is
=
function
(
x
)
{
if
(
!
isObject
(
x
)
)
{
return
false
;
}
for
(
var
k
in
x
)
{
if
(
x
.
hasOwnProperty
(
k
)
)
{
if
(
!
is
(
k
domain
)
|
|
!
is
(
x
[
k
]
codomain
)
)
{
return
false
;
}
}
}
return
true
;
}
;
Dict
.
update
=
function
(
instance
patch
)
{
return
Dict
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Dict
;
}
dict
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
dict
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isType
=
__webpack_require__
(
276
)
;
var
isNil
=
__webpack_require__
(
267
)
;
var
mixin
=
__webpack_require__
(
300
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
nextDeclareUniqueId
=
1
;
module
.
exports
=
function
declare
(
name
)
{
if
(
false
)
{
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
name
+
'
supplied
to
declare
(
[
name
]
)
(
expected
a
string
)
'
;
}
)
;
}
var
type
;
function
Declare
(
value
path
)
{
if
(
false
)
{
assert
(
!
isNil
(
type
)
function
(
)
{
return
'
Type
declared
but
not
defined
don
\
'
t
forget
to
call
.
define
on
every
declared
type
'
;
}
)
;
}
return
type
(
value
path
)
;
}
Declare
.
define
=
function
(
spec
)
{
if
(
false
)
{
assert
(
isType
(
spec
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
spec
)
+
'
supplied
to
define
(
type
)
(
expected
a
type
)
'
;
}
)
;
assert
(
isNil
(
type
)
function
(
)
{
return
'
Declare
.
define
(
type
)
can
only
be
invoked
once
'
;
}
)
;
assert
(
isNil
(
spec
.
meta
.
name
)
&
&
Object
.
keys
(
spec
.
prototype
)
.
length
=
=
=
0
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
spec
)
+
'
supplied
to
define
(
type
)
(
expected
a
fresh
unnamed
type
)
'
;
}
)
;
}
type
=
spec
;
mixin
(
Declare
type
true
)
;
if
(
name
)
{
type
.
displayName
=
Declare
.
displayName
=
name
;
Declare
.
meta
.
name
=
name
;
}
Declare
.
meta
.
identity
=
false
;
Declare
.
prototype
=
type
.
prototype
;
return
Declare
;
}
;
Declare
.
displayName
=
name
|
|
(
getTypeName
(
Declare
)
+
"
"
+
nextDeclareUniqueId
+
+
)
;
Declare
.
meta
=
{
identity
:
false
}
;
Declare
.
prototype
=
null
;
return
Declare
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isNil
=
__webpack_require__
(
267
)
;
var
assert
=
__webpack_require__
(
265
)
;
module
.
exports
=
function
mixin
(
target
source
overwrite
)
{
if
(
isNil
(
source
)
)
{
return
target
;
}
for
(
var
k
in
source
)
{
if
(
source
.
hasOwnProperty
(
k
)
)
{
if
(
overwrite
!
=
=
true
)
{
if
(
false
)
{
assert
(
!
target
.
hasOwnProperty
(
k
)
|
|
target
[
k
]
=
=
=
source
[
k
]
function
(
)
{
return
'
Invalid
call
to
mixin
(
target
source
[
overwrite
]
)
:
cannot
overwrite
property
"
'
+
k
+
'
"
of
target
object
'
;
}
)
;
}
}
target
[
k
]
=
source
[
k
]
;
}
}
return
target
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
forbidNewOperator
=
__webpack_require__
(
274
)
;
var
isString
=
__webpack_require__
(
273
)
;
var
isObject
=
__webpack_require__
(
277
)
;
function
getDefaultName
(
map
)
{
return
Object
.
keys
(
map
)
.
map
(
function
(
k
)
{
return
assert
.
stringify
(
k
)
;
}
)
.
join
(
'
|
'
)
;
}
function
enums
(
map
name
)
{
if
(
false
)
{
assert
(
isObject
(
map
)
function
(
)
{
return
'
Invalid
argument
map
'
+
assert
.
stringify
(
map
)
+
'
supplied
to
enums
(
map
[
name
]
)
combinator
(
expected
a
dictionary
of
String
-
>
String
|
Number
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
enums
(
map
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
map
)
;
function
Enums
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Enums
)
;
path
=
path
|
|
[
displayName
]
;
assert
(
Enums
.
is
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
one
of
'
+
assert
.
stringify
(
Object
.
keys
(
map
)
)
+
'
)
'
;
}
)
;
}
return
value
;
}
Enums
.
meta
=
{
kind
:
'
enums
'
map
:
map
name
:
name
identity
:
true
}
;
Enums
.
displayName
=
displayName
;
Enums
.
is
=
function
(
x
)
{
return
map
.
hasOwnProperty
(
x
)
;
}
;
return
Enums
;
}
enums
.
of
=
function
(
keys
name
)
{
keys
=
isString
(
keys
)
?
keys
.
split
(
'
'
)
:
keys
;
var
value
=
{
}
;
keys
.
forEach
(
function
(
k
)
{
value
[
k
]
=
k
;
}
)
;
return
enums
(
value
name
)
;
}
;
enums
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
enums
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
isIdentity
=
__webpack_require__
(
291
)
;
var
create
=
__webpack_require__
(
292
)
;
var
is
=
__webpack_require__
(
293
)
;
var
isArray
=
__webpack_require__
(
278
)
;
function
getDefaultName
(
type
)
{
return
'
Array
<
'
+
getTypeName
(
type
)
+
'
>
'
;
}
function
list
(
type
name
)
{
if
(
false
)
{
assert
(
isFunction
(
type
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
type
)
+
'
supplied
to
list
(
type
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
list
(
type
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
type
)
;
var
typeNameCache
=
getTypeName
(
type
)
;
var
identity
=
isIdentity
(
type
)
;
function
List
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isArray
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
an
array
of
'
+
typeNameCache
+
'
)
'
;
}
)
;
}
var
idempotent
=
true
;
var
ret
=
[
]
;
for
(
var
i
=
0
len
=
value
.
length
;
i
<
len
;
i
+
+
)
{
var
actual
=
value
[
i
]
;
var
instance
=
create
(
type
actual
(
false
?
path
.
concat
(
i
+
'
:
'
+
typeNameCache
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
.
push
(
instance
)
;
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
List
.
meta
=
{
kind
:
'
list
'
type
:
type
name
:
name
identity
:
identity
}
;
List
.
displayName
=
displayName
;
List
.
is
=
function
(
x
)
{
return
isArray
(
x
)
&
&
x
.
every
(
function
(
e
)
{
return
is
(
e
type
)
;
}
)
;
}
;
List
.
update
=
function
(
instance
patch
)
{
return
List
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
List
;
}
list
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
list
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
isMaybe
=
__webpack_require__
(
304
)
;
var
isIdentity
=
__webpack_require__
(
291
)
;
var
Any
=
__webpack_require__
(
271
)
;
var
create
=
__webpack_require__
(
292
)
;
var
Nil
=
__webpack_require__
(
285
)
;
var
forbidNewOperator
=
__webpack_require__
(
274
)
;
var
is
=
__webpack_require__
(
293
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
function
getDefaultName
(
type
)
{
return
'
?
'
+
getTypeName
(
type
)
;
}
function
maybe
(
type
name
)
{
if
(
isMaybe
(
type
)
|
|
type
=
=
=
Any
|
|
type
=
=
=
Nil
)
{
return
type
;
}
if
(
false
)
{
assert
(
isFunction
(
type
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
type
)
+
'
supplied
to
maybe
(
type
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
maybe
(
type
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
type
)
;
function
Maybe
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Maybe
)
;
}
return
Nil
.
is
(
value
)
?
value
:
create
(
type
value
path
)
;
}
Maybe
.
meta
=
{
kind
:
'
maybe
'
type
:
type
name
:
name
identity
:
isIdentity
(
type
)
}
;
Maybe
.
displayName
=
displayName
;
Maybe
.
is
=
function
(
x
)
{
return
Nil
.
is
(
x
)
|
|
is
(
x
type
)
;
}
;
return
Maybe
;
}
maybe
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
maybe
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
module
.
exports
=
function
isMaybe
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
maybe
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
String
=
__webpack_require__
(
296
)
;
var
Function
=
__webpack_require__
(
284
)
;
var
isBoolean
=
__webpack_require__
(
281
)
;
var
isObject
=
__webpack_require__
(
277
)
;
var
isNil
=
__webpack_require__
(
267
)
;
var
create
=
__webpack_require__
(
292
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
dict
=
__webpack_require__
(
298
)
;
var
getDefaultInterfaceName
=
__webpack_require__
(
306
)
;
var
extend
=
__webpack_require__
(
307
)
;
function
getDefaultName
(
props
)
{
return
'
Struct
'
+
getDefaultInterfaceName
(
props
)
;
}
function
extendStruct
(
mixins
name
)
{
return
extend
(
struct
mixins
name
)
;
}
function
getOptions
(
options
)
{
if
(
!
isObject
(
options
)
)
{
options
=
isNil
(
options
)
?
{
}
:
{
name
:
options
}
;
}
if
(
!
options
.
hasOwnProperty
(
'
strict
'
)
)
{
options
.
strict
=
struct
.
strict
;
}
if
(
!
options
.
hasOwnProperty
(
'
defaultProps
'
)
)
{
options
.
defaultProps
=
{
}
;
}
return
options
;
}
function
struct
(
props
options
)
{
options
=
getOptions
(
options
)
;
var
name
=
options
.
name
;
var
strict
=
options
.
strict
;
var
defaultProps
=
options
.
defaultProps
;
if
(
false
)
{
assert
(
dict
(
String
Function
)
.
is
(
props
)
function
(
)
{
return
'
Invalid
argument
props
'
+
assert
.
stringify
(
props
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
dictionary
String
-
>
Type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
assert
(
isBoolean
(
strict
)
function
(
)
{
return
'
Invalid
argument
strict
'
+
assert
.
stringify
(
strict
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
boolean
)
'
;
}
)
;
assert
(
isObject
(
defaultProps
)
function
(
)
{
return
'
Invalid
argument
defaultProps
'
+
assert
.
stringify
(
defaultProps
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
an
object
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
props
)
;
function
Struct
(
value
path
)
{
if
(
Struct
.
is
(
value
)
)
{
return
value
;
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isObject
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
an
object
)
'
;
}
)
;
if
(
strict
)
{
for
(
k
in
value
)
{
if
(
value
.
hasOwnProperty
(
k
)
)
{
assert
(
props
.
hasOwnProperty
(
k
)
function
(
)
{
return
'
Invalid
additional
prop
"
'
+
k
+
'
"
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
}
}
}
if
(
!
(
this
instanceof
Struct
)
)
{
return
new
Struct
(
value
path
)
;
}
for
(
var
k
in
props
)
{
if
(
props
.
hasOwnProperty
(
k
)
)
{
var
expected
=
props
[
k
]
;
var
actual
=
value
[
k
]
;
if
(
actual
=
=
=
undefined
)
{
actual
=
defaultProps
[
k
]
;
}
this
[
k
]
=
create
(
expected
actual
(
false
?
path
.
concat
(
k
+
'
:
'
+
getTypeName
(
expected
)
)
:
null
)
)
;
}
}
if
(
false
)
{
Object
.
freeze
(
this
)
;
}
}
Struct
.
meta
=
{
kind
:
'
struct
'
props
:
props
name
:
name
identity
:
false
strict
:
strict
defaultProps
:
defaultProps
}
;
Struct
.
displayName
=
displayName
;
Struct
.
is
=
function
(
x
)
{
return
x
instanceof
Struct
;
}
;
Struct
.
update
=
function
(
instance
patch
)
{
return
new
Struct
(
assert
.
update
(
instance
patch
)
)
;
}
;
Struct
.
extend
=
function
(
xs
name
)
{
return
extendStruct
(
[
Struct
]
.
concat
(
xs
)
name
)
;
}
;
return
Struct
;
}
struct
.
strict
=
false
;
struct
.
getOptions
=
getOptions
;
struct
.
getDefaultName
=
getDefaultName
;
struct
.
extend
=
extendStruct
;
module
.
exports
=
struct
;
}
function
(
module
exports
__webpack_require__
)
{
var
getTypeName
=
__webpack_require__
(
275
)
;
function
getDefaultInterfaceName
(
props
)
{
return
'
{
'
+
Object
.
keys
(
props
)
.
map
(
function
(
prop
)
{
return
prop
+
'
:
'
+
getTypeName
(
props
[
prop
]
)
;
}
)
.
join
(
'
'
)
+
'
}
'
;
}
module
.
exports
=
getDefaultInterfaceName
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
isArray
=
__webpack_require__
(
278
)
;
var
mixin
=
__webpack_require__
(
300
)
;
var
isStruct
=
__webpack_require__
(
308
)
;
var
isInterface
=
__webpack_require__
(
309
)
;
var
isObject
=
__webpack_require__
(
277
)
;
var
refinement
=
__webpack_require__
(
289
)
;
var
decompose
=
__webpack_require__
(
310
)
;
function
compose
(
predicates
unrefinedType
)
{
return
predicates
.
reduce
(
function
(
type
predicate
)
{
return
refinement
(
type
predicate
)
;
}
unrefinedType
)
;
}
function
getProps
(
type
)
{
return
isObject
(
type
)
?
type
:
type
.
meta
.
props
;
}
function
getDefaultProps
(
type
)
{
return
isObject
(
type
)
?
null
:
type
.
meta
.
defaultProps
;
}
function
pushAll
(
arr
elements
)
{
Array
.
prototype
.
push
.
apply
(
arr
elements
)
;
}
function
extend
(
combinator
mixins
options
)
{
if
(
false
)
{
assert
(
isFunction
(
combinator
)
function
(
)
{
return
'
Invalid
argument
combinator
supplied
to
extend
(
combinator
mixins
options
)
expected
a
function
'
;
}
)
;
assert
(
isArray
(
mixins
)
function
(
)
{
return
'
Invalid
argument
mixins
supplied
to
extend
(
combinator
mixins
options
)
expected
an
array
'
;
}
)
;
}
var
props
=
{
}
;
var
prototype
=
{
}
;
var
predicates
=
[
]
;
var
defaultProps
=
{
}
;
mixins
.
forEach
(
function
(
x
i
)
{
var
decomposition
=
decompose
(
x
)
;
var
unrefinedType
=
decomposition
.
unrefinedType
;
if
(
false
)
{
assert
(
isObject
(
unrefinedType
)
|
|
isStruct
(
unrefinedType
)
|
|
isInterface
(
unrefinedType
)
function
(
)
{
return
'
Invalid
argument
mixins
[
'
+
i
+
'
]
supplied
to
extend
(
combinator
mixins
options
)
expected
an
object
struct
interface
or
a
refinement
(
of
struct
or
interface
)
'
;
}
)
;
}
pushAll
(
predicates
decomposition
.
predicates
)
;
mixin
(
props
getProps
(
unrefinedType
)
)
;
mixin
(
prototype
unrefinedType
.
prototype
)
;
mixin
(
defaultProps
getDefaultProps
(
unrefinedType
)
)
;
}
)
;
options
=
combinator
.
getOptions
(
options
)
;
mixin
(
options
.
defaultProps
defaultProps
)
;
var
result
=
compose
(
predicates
combinator
(
props
options
)
)
;
mixin
(
result
.
prototype
prototype
)
;
return
result
;
}
module
.
exports
=
extend
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
module
.
exports
=
function
isStruct
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
struct
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
module
.
exports
=
function
isInterface
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
interface
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
function
isRefinement
(
type
)
{
return
isType
(
type
)
&
&
type
.
meta
.
kind
=
=
=
'
subtype
'
;
}
function
getPredicates
(
type
)
{
return
isRefinement
(
type
)
?
[
type
.
meta
.
predicate
]
.
concat
(
getPredicates
(
type
.
meta
.
type
)
)
:
[
]
;
}
function
getUnrefinedType
(
type
)
{
return
isRefinement
(
type
)
?
getUnrefinedType
(
type
.
meta
.
type
)
:
type
;
}
function
decompose
(
type
)
{
return
{
predicates
:
getPredicates
(
type
)
unrefinedType
:
getUnrefinedType
(
type
)
}
;
}
module
.
exports
=
decompose
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
isIdentity
=
__webpack_require__
(
291
)
;
var
isArray
=
__webpack_require__
(
278
)
;
var
create
=
__webpack_require__
(
292
)
;
var
is
=
__webpack_require__
(
293
)
;
function
getDefaultName
(
types
)
{
return
'
[
'
+
types
.
map
(
getTypeName
)
.
join
(
'
'
)
+
'
]
'
;
}
function
tuple
(
types
name
)
{
if
(
false
)
{
assert
(
isArray
(
types
)
&
&
types
.
every
(
isFunction
)
function
(
)
{
return
'
Invalid
argument
types
'
+
assert
.
stringify
(
types
)
+
'
supplied
to
tuple
(
types
[
name
]
)
combinator
(
expected
an
array
of
types
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
tuple
(
types
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
types
)
;
var
identity
=
types
.
every
(
isIdentity
)
;
function
Tuple
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isArray
(
value
)
&
&
value
.
length
=
=
=
types
.
length
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
an
array
of
length
'
+
types
.
length
+
'
)
'
;
}
)
;
}
var
idempotent
=
true
;
var
ret
=
[
]
;
for
(
var
i
=
0
len
=
types
.
length
;
i
<
len
;
i
+
+
)
{
var
expected
=
types
[
i
]
;
var
actual
=
value
[
i
]
;
var
instance
=
create
(
expected
actual
(
false
?
path
.
concat
(
i
+
'
:
'
+
getTypeName
(
expected
)
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
.
push
(
instance
)
;
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
Tuple
.
meta
=
{
kind
:
'
tuple
'
types
:
types
name
:
name
identity
:
identity
}
;
Tuple
.
displayName
=
displayName
;
Tuple
.
is
=
function
(
x
)
{
return
isArray
(
x
)
&
&
x
.
length
=
=
=
types
.
length
&
&
types
.
every
(
function
(
type
i
)
{
return
is
(
x
[
i
]
type
)
;
}
)
;
}
;
Tuple
.
update
=
function
(
instance
patch
)
{
return
Tuple
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Tuple
;
}
tuple
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
tuple
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
isIdentity
=
__webpack_require__
(
291
)
;
var
isArray
=
__webpack_require__
(
278
)
;
var
create
=
__webpack_require__
(
292
)
;
var
is
=
__webpack_require__
(
293
)
;
var
forbidNewOperator
=
__webpack_require__
(
274
)
;
var
isType
=
__webpack_require__
(
276
)
;
var
isUnion
=
__webpack_require__
(
313
)
;
var
isNil
=
__webpack_require__
(
267
)
;
function
getDefaultName
(
types
)
{
return
types
.
map
(
getTypeName
)
.
join
(
'
|
'
)
;
}
function
union
(
types
name
)
{
if
(
false
)
{
assert
(
isArray
(
types
)
&
&
types
.
every
(
isFunction
)
&
&
types
.
length
>
=
2
function
(
)
{
return
'
Invalid
argument
types
'
+
assert
.
stringify
(
types
)
+
'
supplied
to
union
(
types
[
name
]
)
combinator
(
expected
an
array
of
at
least
2
types
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
union
(
types
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
types
)
;
var
identity
=
types
.
every
(
isIdentity
)
;
function
Union
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
var
type
=
Union
.
dispatch
(
value
)
;
if
(
!
type
&
&
Union
.
is
(
value
)
)
{
return
value
;
}
if
(
false
)
{
forbidNewOperator
(
this
Union
)
;
path
=
path
|
|
[
displayName
]
;
assert
(
isType
(
type
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
no
constructor
returned
by
dispatch
)
'
;
}
)
;
path
[
path
.
length
-
1
]
+
=
'
(
'
+
getTypeName
(
type
)
+
'
)
'
;
}
return
create
(
type
value
path
)
;
}
Union
.
meta
=
{
kind
:
'
union
'
types
:
types
name
:
name
identity
:
identity
}
;
Union
.
displayName
=
displayName
;
Union
.
is
=
function
(
x
)
{
return
types
.
some
(
function
(
type
)
{
return
is
(
x
type
)
;
}
)
;
}
;
Union
.
dispatch
=
function
(
x
)
{
for
(
var
i
=
0
len
=
types
.
length
;
i
<
len
;
i
+
+
)
{
var
type
=
types
[
i
]
;
if
(
isUnion
(
type
)
)
{
var
t
=
type
.
dispatch
(
x
)
;
if
(
!
isNil
(
t
)
)
{
return
t
;
}
}
else
if
(
is
(
x
type
)
)
{
return
type
;
}
}
}
;
Union
.
update
=
function
(
instance
patch
)
{
return
Union
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Union
;
}
union
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
union
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
276
)
;
module
.
exports
=
function
isUnion
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
union
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
FunctionType
=
__webpack_require__
(
284
)
;
var
isArray
=
__webpack_require__
(
278
)
;
var
list
=
__webpack_require__
(
302
)
;
var
isObject
=
__webpack_require__
(
277
)
;
var
create
=
__webpack_require__
(
292
)
;
var
isNil
=
__webpack_require__
(
267
)
;
var
isBoolean
=
__webpack_require__
(
281
)
;
var
tuple
=
__webpack_require__
(
311
)
;
var
getFunctionName
=
__webpack_require__
(
270
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
isType
=
__webpack_require__
(
276
)
;
function
getDefaultName
(
domain
codomain
)
{
return
'
(
'
+
domain
.
map
(
getTypeName
)
.
join
(
'
'
)
+
'
)
=
>
'
+
getTypeName
(
codomain
)
;
}
function
isInstrumented
(
f
)
{
return
FunctionType
.
is
(
f
)
&
&
isObject
(
f
.
instrumentation
)
;
}
function
getOptionalArgumentsIndex
(
types
)
{
var
end
=
types
.
length
;
var
areAllMaybes
=
false
;
for
(
var
i
=
end
-
1
;
i
>
=
0
;
i
-
-
)
{
var
type
=
types
[
i
]
;
if
(
!
isType
(
type
)
|
|
type
.
meta
.
kind
!
=
=
'
maybe
'
)
{
return
(
i
+
1
)
;
}
else
{
areAllMaybes
=
true
;
}
}
return
areAllMaybes
?
0
:
end
;
}
function
func
(
domain
codomain
name
)
{
domain
=
isArray
(
domain
)
?
domain
:
[
domain
]
;
if
(
false
)
{
assert
(
list
(
FunctionType
)
.
is
(
domain
)
function
(
)
{
return
'
Invalid
argument
domain
'
+
assert
.
stringify
(
domain
)
+
'
supplied
to
func
(
domain
codomain
[
name
]
)
combinator
(
expected
an
array
of
types
)
'
;
}
)
;
assert
(
FunctionType
.
is
(
codomain
)
function
(
)
{
return
'
Invalid
argument
codomain
'
+
assert
.
stringify
(
codomain
)
+
'
supplied
to
func
(
domain
codomain
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
func
(
domain
codomain
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
domain
codomain
)
;
var
domainLength
=
domain
.
length
;
var
optionalArgumentsIndex
=
getOptionalArgumentsIndex
(
domain
)
;
function
FuncType
(
value
path
)
{
if
(
!
isInstrumented
(
value
)
)
{
return
FuncType
.
of
(
value
)
;
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
FuncType
.
is
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
FuncType
.
meta
=
{
kind
:
'
func
'
domain
:
domain
codomain
:
codomain
name
:
name
identity
:
true
}
;
FuncType
.
displayName
=
displayName
;
FuncType
.
is
=
function
(
x
)
{
return
isInstrumented
(
x
)
&
&
x
.
instrumentation
.
domain
.
length
=
=
=
domainLength
&
&
x
.
instrumentation
.
domain
.
every
(
function
(
type
i
)
{
return
type
=
=
=
domain
[
i
]
;
}
)
&
&
x
.
instrumentation
.
codomain
=
=
=
codomain
;
}
;
FuncType
.
of
=
function
(
f
curried
)
{
if
(
false
)
{
assert
(
FunctionType
.
is
(
f
)
function
(
)
{
return
'
Invalid
argument
f
supplied
to
func
.
of
'
+
displayName
+
'
(
expected
a
function
)
'
;
}
)
;
assert
(
isNil
(
curried
)
|
|
isBoolean
(
curried
)
function
(
)
{
return
'
Invalid
argument
curried
'
+
assert
.
stringify
(
curried
)
+
'
supplied
to
func
.
of
'
+
displayName
+
'
(
expected
a
boolean
)
'
;
}
)
;
}
if
(
FuncType
.
is
(
f
)
)
{
return
f
;
}
function
fn
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
var
argsLength
=
args
.
length
;
if
(
false
)
{
var
tupleLength
=
curried
?
argsLength
:
Math
.
max
(
argsLength
optionalArgumentsIndex
)
;
tuple
(
domain
.
slice
(
0
tupleLength
)
'
arguments
of
function
'
+
displayName
)
(
args
)
;
}
if
(
curried
&
&
argsLength
<
domainLength
)
{
if
(
false
)
{
assert
(
argsLength
>
0
'
Invalid
arguments
.
length
=
0
for
curried
function
'
+
displayName
)
;
}
var
g
=
Function
.
prototype
.
bind
.
apply
(
f
[
this
]
.
concat
(
args
)
)
;
var
newDomain
=
func
(
domain
.
slice
(
argsLength
)
codomain
)
;
return
newDomain
.
of
(
g
true
)
;
}
else
{
return
create
(
codomain
f
.
apply
(
this
args
)
)
;
}
}
fn
.
instrumentation
=
{
domain
:
domain
codomain
:
codomain
f
:
f
}
;
fn
.
displayName
=
getFunctionName
(
f
)
;
return
fn
;
}
;
return
FuncType
;
}
func
.
getDefaultName
=
getDefaultName
;
func
.
getOptionalArgumentsIndex
=
getOptionalArgumentsIndex
;
module
.
exports
=
func
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
isArray
=
__webpack_require__
(
278
)
;
var
forbidNewOperator
=
__webpack_require__
(
291
)
;
var
is
=
__webpack_require__
(
293
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
function
getDefaultName
(
types
)
{
return
types
.
map
(
getTypeName
)
.
join
(
'
&
'
)
;
}
function
intersection
(
types
name
)
{
if
(
false
)
{
assert
(
isArray
(
types
)
&
&
types
.
every
(
isFunction
)
&
&
types
.
length
>
=
2
function
(
)
{
return
'
Invalid
argument
types
'
+
assert
.
stringify
(
types
)
+
'
supplied
to
intersection
(
types
[
name
]
)
combinator
(
expected
an
array
of
at
least
2
types
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
intersection
(
types
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
types
)
;
function
Intersection
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Intersection
)
;
path
=
path
|
|
[
displayName
]
;
assert
(
Intersection
.
is
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
Intersection
.
meta
=
{
kind
:
'
intersection
'
types
:
types
name
:
name
identity
:
true
}
;
Intersection
.
displayName
=
displayName
;
Intersection
.
is
=
function
(
x
)
{
return
types
.
every
(
function
(
type
)
{
return
is
(
x
type
)
;
}
)
;
}
;
Intersection
.
update
=
function
(
instance
patch
)
{
return
Intersection
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Intersection
;
}
intersection
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
intersection
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isTypeName
=
__webpack_require__
(
290
)
;
var
String
=
__webpack_require__
(
296
)
;
var
Function
=
__webpack_require__
(
284
)
;
var
isBoolean
=
__webpack_require__
(
281
)
;
var
isObject
=
__webpack_require__
(
277
)
;
var
isNil
=
__webpack_require__
(
267
)
;
var
create
=
__webpack_require__
(
292
)
;
var
getTypeName
=
__webpack_require__
(
275
)
;
var
dict
=
__webpack_require__
(
298
)
;
var
getDefaultInterfaceName
=
__webpack_require__
(
306
)
;
var
isIdentity
=
__webpack_require__
(
291
)
;
var
is
=
__webpack_require__
(
293
)
;
var
extend
=
__webpack_require__
(
307
)
;
function
extendInterface
(
mixins
name
)
{
return
extend
(
inter
mixins
name
)
;
}
function
getOptions
(
options
)
{
if
(
!
isObject
(
options
)
)
{
options
=
isNil
(
options
)
?
{
}
:
{
name
:
options
}
;
}
if
(
!
options
.
hasOwnProperty
(
'
strict
'
)
)
{
options
.
strict
=
inter
.
strict
;
}
return
options
;
}
function
inter
(
props
options
)
{
options
=
getOptions
(
options
)
;
var
name
=
options
.
name
;
var
strict
=
options
.
strict
;
if
(
false
)
{
assert
(
dict
(
String
Function
)
.
is
(
props
)
function
(
)
{
return
'
Invalid
argument
props
'
+
assert
.
stringify
(
props
)
+
'
supplied
to
interface
(
props
[
options
]
)
combinator
(
expected
a
dictionary
String
-
>
Type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
interface
(
props
[
options
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
assert
(
isBoolean
(
strict
)
function
(
)
{
return
'
Invalid
argument
strict
'
+
assert
.
stringify
(
strict
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
boolean
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultInterfaceName
(
props
)
;
var
identity
=
Object
.
keys
(
props
)
.
map
(
function
(
prop
)
{
return
props
[
prop
]
;
}
)
.
every
(
isIdentity
)
;
function
Interface
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
!
isNil
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
value
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
if
(
strict
)
{
for
(
var
k
in
value
)
{
assert
(
props
.
hasOwnProperty
(
k
)
function
(
)
{
return
'
Invalid
additional
prop
"
'
+
k
+
'
"
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
}
}
var
idempotent
=
true
;
var
ret
=
{
}
;
for
(
var
prop
in
props
)
{
var
expected
=
props
[
prop
]
;
var
actual
=
value
[
prop
]
;
var
instance
=
create
(
expected
actual
(
false
?
path
.
concat
(
prop
+
'
:
'
+
getTypeName
(
expected
)
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
[
prop
]
=
instance
;
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
Interface
.
meta
=
{
kind
:
'
interface
'
props
:
props
name
:
name
identity
:
identity
strict
:
strict
}
;
Interface
.
displayName
=
displayName
;
Interface
.
is
=
function
(
x
)
{
if
(
strict
)
{
for
(
var
k
in
x
)
{
if
(
!
props
.
hasOwnProperty
(
k
)
)
{
return
false
;
}
}
}
for
(
var
prop
in
props
)
{
if
(
!
is
(
x
[
prop
]
props
[
prop
]
)
)
{
return
false
;
}
}
return
true
;
}
;
Interface
.
update
=
function
(
instance
patch
)
{
return
Interface
(
assert
.
update
(
instance
patch
)
)
;
}
;
Interface
.
extend
=
function
(
xs
name
)
{
return
extendInterface
(
[
Interface
]
.
concat
(
xs
)
name
)
;
}
;
return
Interface
;
}
inter
.
strict
=
false
;
inter
.
getOptions
=
getOptions
;
inter
.
getDefaultName
=
getDefaultInterfaceName
;
inter
.
extend
=
extendInterface
;
module
.
exports
=
inter
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isObject
=
__webpack_require__
(
277
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
isArray
=
__webpack_require__
(
278
)
;
var
isNumber
=
__webpack_require__
(
287
)
;
var
mixin
=
__webpack_require__
(
300
)
;
function
getShallowCopy
(
x
)
{
if
(
isArray
(
x
)
)
{
return
x
.
concat
(
)
;
}
if
(
x
instanceof
Date
|
|
x
instanceof
RegExp
)
{
return
x
;
}
if
(
isObject
(
x
)
)
{
return
mixin
(
{
}
x
)
;
}
return
x
;
}
function
isCommand
(
k
)
{
return
update
.
commands
.
hasOwnProperty
(
k
)
;
}
function
getCommand
(
k
)
{
return
update
.
commands
[
k
]
;
}
function
update
(
instance
patch
)
{
if
(
false
)
{
assert
(
isObject
(
patch
)
function
(
)
{
return
'
Invalid
argument
patch
'
+
assert
.
stringify
(
patch
)
+
'
supplied
to
function
update
(
instance
patch
)
:
expected
an
object
containing
commands
'
;
}
)
;
}
var
value
=
instance
;
var
isChanged
=
false
;
var
newValue
;
for
(
var
k
in
patch
)
{
if
(
patch
.
hasOwnProperty
(
k
)
)
{
if
(
isCommand
(
k
)
)
{
newValue
=
getCommand
(
k
)
(
patch
[
k
]
value
)
;
if
(
newValue
!
=
=
instance
)
{
isChanged
=
true
;
value
=
newValue
;
}
else
{
value
=
instance
;
}
}
else
{
if
(
value
=
=
=
instance
)
{
value
=
getShallowCopy
(
instance
)
;
}
newValue
=
update
(
value
[
k
]
patch
[
k
]
)
;
isChanged
=
isChanged
|
|
(
newValue
!
=
=
value
[
k
]
)
;
value
[
k
]
=
newValue
;
}
}
}
return
isChanged
?
value
:
instance
;
}
function
apply
(
f
value
)
{
if
(
false
)
{
assert
(
isFunction
(
f
)
'
Invalid
argument
f
supplied
to
immutability
helper
{
apply
:
f
}
(
expected
a
function
)
'
)
;
}
return
f
(
value
)
;
}
function
push
(
elements
arr
)
{
if
(
false
)
{
assert
(
isArray
(
elements
)
'
Invalid
argument
elements
supplied
to
immutability
helper
{
push
:
elements
}
(
expected
an
array
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
push
(
expected
an
array
)
'
)
;
}
if
(
elements
.
length
>
0
)
{
return
arr
.
concat
(
elements
)
;
}
return
arr
;
}
function
remove
(
keys
obj
)
{
if
(
false
)
{
assert
(
isArray
(
keys
)
'
Invalid
argument
keys
supplied
to
immutability
helper
{
remove
:
keys
}
(
expected
an
array
)
'
)
;
assert
(
isObject
(
obj
)
'
Invalid
value
supplied
to
immutability
helper
remove
(
expected
an
object
)
'
)
;
}
if
(
keys
.
length
>
0
)
{
obj
=
getShallowCopy
(
obj
)
;
for
(
var
i
=
0
len
=
keys
.
length
;
i
<
len
;
i
+
+
)
{
delete
obj
[
keys
[
i
]
]
;
}
}
return
obj
;
}
function
set
(
value
)
{
return
value
;
}
function
splice
(
splices
arr
)
{
if
(
false
)
{
assert
(
isArray
(
splices
)
&
&
splices
.
every
(
isArray
)
'
Invalid
argument
splices
supplied
to
immutability
helper
{
splice
:
splices
}
(
expected
an
array
of
arrays
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
splice
(
expected
an
array
)
'
)
;
}
if
(
splices
.
length
>
0
)
{
arr
=
getShallowCopy
(
arr
)
;
return
splices
.
reduce
(
function
(
acc
splice
)
{
acc
.
splice
.
apply
(
acc
splice
)
;
return
acc
;
}
arr
)
;
}
return
arr
;
}
function
swap
(
config
arr
)
{
if
(
false
)
{
assert
(
isObject
(
config
)
'
Invalid
argument
config
supplied
to
immutability
helper
{
swap
:
config
}
(
expected
an
object
)
'
)
;
assert
(
isNumber
(
config
.
from
)
'
Invalid
argument
config
.
from
supplied
to
immutability
helper
{
swap
:
config
}
(
expected
a
number
)
'
)
;
assert
(
isNumber
(
config
.
to
)
'
Invalid
argument
config
.
to
supplied
to
immutability
helper
{
swap
:
config
}
(
expected
a
number
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
swap
(
expected
an
array
)
'
)
;
}
if
(
config
.
from
!
=
=
config
.
to
)
{
arr
=
getShallowCopy
(
arr
)
;
var
element
=
arr
[
config
.
to
]
;
arr
[
config
.
to
]
=
arr
[
config
.
from
]
;
arr
[
config
.
from
]
=
element
;
}
return
arr
;
}
function
unshift
(
elements
arr
)
{
if
(
false
)
{
assert
(
isArray
(
elements
)
'
Invalid
argument
elements
supplied
to
immutability
helper
{
unshift
:
elements
}
(
expected
an
array
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
unshift
(
expected
an
array
)
'
)
;
}
if
(
elements
.
length
>
0
)
{
return
elements
.
concat
(
arr
)
;
}
return
arr
;
}
function
merge
(
whatToMerge
value
)
{
var
isChanged
=
false
;
var
result
=
getShallowCopy
(
value
)
;
for
(
var
k
in
whatToMerge
)
{
if
(
whatToMerge
.
hasOwnProperty
(
k
)
)
{
result
[
k
]
=
whatToMerge
[
k
]
;
isChanged
=
isChanged
|
|
(
result
[
k
]
!
=
=
value
[
k
]
)
;
}
}
return
isChanged
?
result
:
value
;
}
update
.
commands
=
{
apply
:
apply
push
:
push
remove
:
remove
set
:
set
splice
:
splice
swap
:
swap
unshift
:
unshift
merge
:
merge
}
;
module
.
exports
=
update
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
265
)
;
var
isFunction
=
__webpack_require__
(
266
)
;
var
isType
=
__webpack_require__
(
276
)
;
var
Any
=
__webpack_require__
(
271
)
;
module
.
exports
=
function
match
(
x
)
{
var
type
guard
f
count
;
for
(
var
i
=
1
len
=
arguments
.
length
;
i
<
len
;
)
{
type
=
arguments
[
i
]
;
guard
=
arguments
[
i
+
1
]
;
f
=
arguments
[
i
+
2
]
;
if
(
isFunction
(
f
)
&
&
!
isType
(
f
)
)
{
i
=
i
+
3
;
}
else
{
f
=
guard
;
guard
=
Any
.
is
;
i
=
i
+
2
;
}
if
(
false
)
{
count
=
(
count
|
|
0
)
+
1
;
assert
(
isType
(
type
)
function
(
)
{
return
'
Invalid
type
in
clause
#
'
+
count
;
}
)
;
assert
(
isFunction
(
guard
)
function
(
)
{
return
'
Invalid
guard
in
clause
#
'
+
count
;
}
)
;
assert
(
isFunction
(
f
)
function
(
)
{
return
'
Invalid
block
in
clause
#
'
+
count
;
}
)
;
}
if
(
type
.
is
(
x
)
&
&
guard
(
x
)
)
{
return
f
(
x
)
;
}
}
assert
.
fail
(
'
Match
error
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
_require
=
__webpack_require__
(
263
)
;
var
BreakpointResult
=
_require
.
BreakpointResult
;
var
Location
=
_require
.
Location
;
var
defer
=
__webpack_require__
(
261
)
;
var
bpClients
=
void
0
;
var
threadClient
=
void
0
;
var
tabTarget
=
void
0
;
function
setupCommands
(
dependencies
)
{
threadClient
=
dependencies
.
threadClient
;
tabTarget
=
dependencies
.
tabTarget
;
bpClients
=
{
}
;
}
function
resume
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
resume
(
resolve
)
;
}
)
;
}
function
stepIn
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
stepIn
(
resolve
)
;
}
)
;
}
function
stepOver
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
stepOver
(
resolve
)
;
}
)
;
}
function
stepOut
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
stepOut
(
resolve
)
;
}
)
;
}
function
breakOnNext
(
)
{
return
threadClient
.
breakOnNext
(
)
;
}
function
sourceContents
(
sourceId
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
sourceId
}
)
;
return
sourceClient
.
source
(
)
;
}
function
setBreakpoint
(
location
condition
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
location
.
sourceId
}
)
;
return
sourceClient
.
setBreakpoint
(
{
line
:
location
.
line
column
:
location
.
column
condition
:
condition
}
)
.
then
(
_ref
=
>
{
var
_ref2
=
_slicedToArray
(
_ref
2
)
;
var
res
=
_ref2
[
0
]
;
var
bpClient
=
_ref2
[
1
]
;
bpClients
[
bpClient
.
actor
]
=
bpClient
;
var
actualLocation
=
res
.
actualLocation
?
{
sourceId
:
res
.
actualLocation
.
source
.
actor
line
:
res
.
actualLocation
.
line
column
:
res
.
actualLocation
.
column
}
:
location
;
return
BreakpointResult
(
{
id
:
bpClient
.
actor
actualLocation
:
Location
(
actualLocation
)
}
)
;
}
)
;
}
function
removeBreakpoint
(
breakpointId
)
{
var
bpClient
=
bpClients
[
breakpointId
]
;
bpClients
[
breakpointId
]
=
null
;
return
bpClient
.
remove
(
)
;
}
function
evaluate
(
script
)
{
var
deferred
=
defer
(
)
;
tabTarget
.
activeConsole
.
evaluateJS
(
script
result
=
>
{
deferred
.
resolve
(
result
)
;
}
)
;
return
deferred
.
promise
;
}
function
navigate
(
url
)
{
return
tabTarget
.
activeTab
.
navigateTo
(
url
)
;
}
function
getProperties
(
grip
)
{
var
objClient
=
threadClient
.
pauseGrip
(
grip
)
;
return
objClient
.
getPrototypeAndProperties
(
)
;
}
function
pauseOnExceptions
(
toggle
)
{
return
threadClient
.
pauseOnExceptions
(
toggle
)
;
}
function
prettyPrint
(
sourceId
indentSize
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
sourceId
}
)
;
return
sourceClient
.
prettyPrint
(
indentSize
)
;
}
function
disablePrettyPrint
(
sourceId
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
sourceId
}
)
;
return
sourceClient
.
disablePrettyPrint
(
)
;
}
var
clientCommands
=
{
resume
stepIn
stepOut
stepOver
breakOnNext
sourceContents
setBreakpoint
removeBreakpoint
evaluate
navigate
getProperties
pauseOnExceptions
prettyPrint
disablePrettyPrint
}
;
module
.
exports
=
{
setupCommands
clientCommands
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
paused
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
_
packet
)
{
if
(
packet
.
why
.
type
=
=
=
"
interrupted
"
&
&
!
packet
.
why
.
onNext
)
{
return
;
}
var
response
=
yield
threadClient
.
getFrames
(
0
CALL_STACK_PAGE_SIZE
)
;
var
frames
=
response
.
frames
.
map
(
createFrame
)
;
var
pause
=
Object
.
assign
(
{
}
packet
{
frame
:
createFrame
(
packet
.
frame
)
frames
:
frames
}
)
;
actions
.
paused
(
pause
)
;
}
)
;
return
function
paused
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
263
)
;
var
Source
=
_require
.
Source
;
var
Frame
=
_require
.
Frame
;
var
Location
=
_require
.
Location
;
var
CALL_STACK_PAGE_SIZE
=
1000
;
var
NEW_SOURCE_IGNORED_URLS
=
[
"
debugger
eval
code
"
"
XStringBundle
"
]
;
var
threadClient
=
void
0
;
var
actions
=
void
0
;
function
setupEvents
(
dependencies
)
{
threadClient
=
dependencies
.
threadClient
;
actions
=
dependencies
.
actions
;
}
function
createFrame
(
frame
)
{
var
title
=
void
0
;
if
(
frame
.
type
=
=
"
call
"
)
{
var
c
=
frame
.
callee
;
title
=
c
.
name
|
|
c
.
userDisplayName
|
|
c
.
displayName
|
|
"
(
anonymous
)
"
;
}
else
{
title
=
"
(
"
+
frame
.
type
+
"
)
"
;
}
return
Frame
(
{
id
:
frame
.
actor
displayName
:
title
location
:
Location
(
{
sourceId
:
frame
.
where
.
source
.
actor
line
:
frame
.
where
.
line
column
:
frame
.
where
.
column
}
)
scope
:
frame
.
environment
}
)
;
}
function
resumed
(
_
packet
)
{
actions
.
resumed
(
packet
)
;
}
function
newSource
(
_
packet
)
{
var
source
=
packet
.
source
;
if
(
NEW_SOURCE_IGNORED_URLS
.
indexOf
(
source
.
url
)
>
-
1
)
{
return
;
}
if
(
source
.
introductionType
=
=
"
debugger
eval
"
)
{
return
;
}
actions
.
newSource
(
Source
(
{
id
:
source
.
actor
url
:
source
.
url
isPrettyPrinted
:
false
sourceMapURL
:
source
.
sourceMapURL
}
)
)
;
}
var
clientEvents
=
{
paused
resumed
newSource
}
;
module
.
exports
=
{
setupEvents
clientEvents
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
322
)
;
var
connect
=
_require
.
connect
;
var
defer
=
__webpack_require__
(
261
)
;
var
_require2
=
__webpack_require__
(
263
)
;
var
Tab
=
_require2
.
Tab
;
var
_require3
=
__webpack_require__
(
196
)
;
var
isEnabled
=
_require3
.
isEnabled
;
var
getValue
=
_require3
.
getValue
;
var
_require4
=
__webpack_require__
(
323
)
;
var
networkRequest
=
_require4
.
networkRequest
;
var
_require5
=
__webpack_require__
(
326
)
;
var
setupCommands
=
_require5
.
setupCommands
;
var
clientCommands
=
_require5
.
clientCommands
;
var
_require6
=
__webpack_require__
(
327
)
;
var
setupEvents
=
_require6
.
setupEvents
;
var
clientEvents
=
_require6
.
clientEvents
;
var
pageEvents
=
_require6
.
pageEvents
;
Array
.
prototype
.
peekLast
=
function
(
)
{
return
this
[
this
.
length
-
1
]
;
}
;
var
connection
=
void
0
;
function
createTabs
(
tabs
)
{
return
tabs
.
filter
(
tab
=
>
{
var
isPage
=
tab
.
type
=
=
"
page
"
;
return
isPage
;
}
)
.
map
(
tab
=
>
{
return
Tab
(
{
title
:
tab
.
title
url
:
tab
.
url
id
:
tab
.
id
tab
browser
:
"
chrome
"
}
)
;
}
)
;
}
function
connectClient
(
)
{
var
deferred
=
defer
(
)
;
if
(
!
isEnabled
(
"
chrome
.
debug
"
)
)
{
return
deferred
.
resolve
(
createTabs
(
[
]
)
)
;
}
var
webSocketPort
=
getValue
(
"
chrome
.
webSocketPort
"
)
;
var
url
=
http
:
/
/
localhost
:
{
webSocketPort
}
/
json
/
list
;
networkRequest
(
url
)
.
then
(
body
=
>
{
deferred
.
resolve
(
createTabs
(
body
)
)
;
}
)
;
return
deferred
.
promise
;
}
function
connectTab
(
tab
)
{
return
connect
(
tab
.
webSocketDebuggerUrl
)
.
then
(
conn
=
>
{
connection
=
conn
;
}
)
;
}
function
connectNode
(
url
)
{
return
connect
(
url
)
.
then
(
conn
=
>
{
connection
=
conn
;
}
)
;
}
function
initPage
(
actions
)
{
var
agents
=
connection
.
_agents
;
setupCommands
(
{
agents
:
agents
}
)
;
setupEvents
(
{
actions
}
)
;
agents
.
Debugger
.
enable
(
)
;
agents
.
Debugger
.
setPauseOnExceptions
(
"
none
"
)
;
agents
.
Debugger
.
setAsyncCallStackDepth
(
0
)
;
agents
.
Runtime
.
enable
(
)
;
agents
.
Runtime
.
run
(
)
;
agents
.
Page
.
enable
(
)
;
connection
.
registerDispatcher
(
"
Debugger
"
clientEvents
)
;
connection
.
registerDispatcher
(
"
Page
"
pageEvents
)
;
}
module
.
exports
=
{
connectClient
clientCommands
connectNode
connectTab
initPage
}
;
}
function
(
module
exports
)
{
module
.
exports
=
{
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
324
)
;
var
log
=
_require
.
log
;
function
networkRequest
(
url
)
{
return
fetch
(
/
get
?
url
=
{
url
}
)
.
then
(
res
=
>
res
.
json
(
)
)
.
catch
(
res
=
>
{
log
(
failed
to
request
{
url
}
)
;
}
)
;
}
module
.
exports
=
{
networkRequest
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
asyncMap
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
items
callback
)
{
var
newItems
=
[
]
;
for
(
var
item
of
items
)
{
item
=
yield
callback
(
item
)
;
newItems
.
push
(
item
)
;
}
return
newItems
;
}
)
;
return
function
asyncMap
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
co
=
__webpack_require__
(
325
)
;
var
_require
=
__webpack_require__
(
196
)
;
var
isDevelopment
=
_require
.
isDevelopment
;
var
defer
=
__webpack_require__
(
261
)
;
function
asPaused
(
client
func
)
{
if
(
client
.
state
!
=
"
paused
"
)
{
return
co
(
function
*
(
)
{
yield
client
.
interrupt
(
)
;
var
result
=
void
0
;
try
{
result
=
yield
func
(
)
;
}
catch
(
e
)
{
yield
client
.
resume
(
)
;
throw
e
;
}
yield
client
.
resume
(
)
;
return
result
;
}
)
;
}
return
func
(
)
;
}
function
handleError
(
err
)
{
console
.
log
(
"
ERROR
:
"
err
)
;
}
function
promisify
(
context
method
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
args
.
push
(
response
=
>
{
if
(
response
.
error
)
{
reject
(
response
)
;
}
else
{
resolve
(
response
)
;
}
}
)
;
method
.
apply
(
context
args
)
;
}
)
;
}
function
truncateStr
(
str
size
)
{
if
(
str
.
length
>
size
)
{
return
str
.
slice
(
0
size
)
+
"
.
.
.
"
;
}
return
str
;
}
function
endTruncateStr
(
str
size
)
{
if
(
str
.
length
>
size
)
{
return
"
.
.
.
"
+
str
.
slice
(
str
.
length
-
size
)
;
}
return
str
;
}
function
workerTask
(
worker
message
)
{
var
deferred
=
defer
(
)
;
worker
.
postMessage
(
message
)
;
worker
.
onmessage
=
function
(
result
)
{
if
(
result
.
error
)
{
deferred
.
reject
(
result
.
error
)
;
}
deferred
.
resolve
(
result
.
data
)
;
}
;
return
deferred
.
promise
;
}
function
zip
(
a
b
)
{
if
(
!
b
)
{
return
a
;
}
if
(
!
a
)
{
return
b
;
}
var
pairs
=
[
]
;
for
(
var
i
=
0
aLength
=
a
.
length
bLength
=
b
.
length
;
i
<
aLength
|
|
i
<
bLength
;
i
+
+
)
{
pairs
.
push
(
[
a
[
i
]
b
[
i
]
]
)
;
}
return
pairs
;
}
function
entries
(
obj
)
{
return
Object
.
keys
(
obj
)
.
map
(
k
=
>
[
k
obj
[
k
]
]
)
;
}
function
mapObject
(
obj
iteratee
)
{
return
toObject
(
entries
(
obj
)
.
map
(
_ref2
=
>
{
var
_ref3
=
_slicedToArray
(
_ref2
2
)
;
var
key
=
_ref3
[
0
]
;
var
value
=
_ref3
[
1
]
;
return
[
key
iteratee
(
key
value
)
]
;
}
)
)
;
}
function
toObject
(
arr
)
{
var
obj
=
{
}
;
for
(
var
pair
of
arr
)
{
obj
[
pair
[
0
]
]
=
pair
[
1
]
;
}
return
obj
;
}
function
compose
(
)
{
for
(
var
_len2
=
arguments
.
length
funcs
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
funcs
[
_key2
]
=
arguments
[
_key2
]
;
}
return
function
(
)
{
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
var
initialValue
=
funcs
[
funcs
.
length
-
1
]
.
apply
(
null
args
)
;
var
leftFuncs
=
funcs
.
slice
(
0
-
1
)
;
return
leftFuncs
.
reduceRight
(
(
composed
f
)
=
>
f
(
composed
)
initialValue
)
;
}
;
}
function
log
(
)
{
if
(
!
isDevelopment
(
)
)
{
return
;
}
console
.
log
.
apply
(
console
[
"
[
log
]
"
]
.
concat
(
Array
.
prototype
.
slice
.
call
(
arguments
)
)
)
;
}
function
updateObj
(
obj
fields
)
{
return
Object
.
assign
(
{
}
obj
fields
)
;
}
module
.
exports
=
{
asPaused
handleError
promisify
truncateStr
endTruncateStr
workerTask
asyncMap
zip
entries
toObject
mapObject
compose
log
updateObj
}
;
}
function
(
module
exports
)
{
var
slice
=
Array
.
prototype
.
slice
;
module
.
exports
=
co
[
'
default
'
]
=
co
.
co
=
co
;
co
.
wrap
=
function
(
fn
)
{
createPromise
.
__generatorFunction__
=
fn
;
return
createPromise
;
function
createPromise
(
)
{
return
co
.
call
(
this
fn
.
apply
(
this
arguments
)
)
;
}
}
;
function
co
(
gen
)
{
var
ctx
=
this
;
var
args
=
slice
.
call
(
arguments
1
)
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
typeof
gen
=
=
=
'
function
'
)
gen
=
gen
.
apply
(
ctx
args
)
;
if
(
!
gen
|
|
typeof
gen
.
next
!
=
=
'
function
'
)
return
resolve
(
gen
)
;
onFulfilled
(
)
;
function
onFulfilled
(
res
)
{
var
ret
;
try
{
ret
=
gen
.
next
(
res
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
onRejected
(
err
)
{
var
ret
;
try
{
ret
=
gen
.
throw
(
err
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
next
(
ret
)
{
if
(
ret
.
done
)
return
resolve
(
ret
.
value
)
;
var
value
=
toPromise
.
call
(
ctx
ret
.
value
)
;
if
(
value
&
&
isPromise
(
value
)
)
return
value
.
then
(
onFulfilled
onRejected
)
;
return
onRejected
(
new
TypeError
(
'
You
may
only
yield
a
function
promise
generator
array
or
object
'
+
'
but
the
following
object
was
passed
:
"
'
+
String
(
ret
.
value
)
+
'
"
'
)
)
;
}
}
)
;
}
function
toPromise
(
obj
)
{
if
(
!
obj
)
return
obj
;
if
(
isPromise
(
obj
)
)
return
obj
;
if
(
isGeneratorFunction
(
obj
)
|
|
isGenerator
(
obj
)
)
return
co
.
call
(
this
obj
)
;
if
(
'
function
'
=
=
typeof
obj
)
return
thunkToPromise
.
call
(
this
obj
)
;
if
(
Array
.
isArray
(
obj
)
)
return
arrayToPromise
.
call
(
this
obj
)
;
if
(
isObject
(
obj
)
)
return
objectToPromise
.
call
(
this
obj
)
;
return
obj
;
}
function
thunkToPromise
(
fn
)
{
var
ctx
=
this
;
return
new
Promise
(
function
(
resolve
reject
)
{
fn
.
call
(
ctx
function
(
err
res
)
{
if
(
err
)
return
reject
(
err
)
;
if
(
arguments
.
length
>
2
)
res
=
slice
.
call
(
arguments
1
)
;
resolve
(
res
)
;
}
)
;
}
)
;
}
function
arrayToPromise
(
obj
)
{
return
Promise
.
all
(
obj
.
map
(
toPromise
this
)
)
;
}
function
objectToPromise
(
obj
)
{
var
results
=
new
obj
.
constructor
(
)
;
var
keys
=
Object
.
keys
(
obj
)
;
var
promises
=
[
]
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
promise
=
toPromise
.
call
(
this
obj
[
key
]
)
;
if
(
promise
&
&
isPromise
(
promise
)
)
defer
(
promise
key
)
;
else
results
[
key
]
=
obj
[
key
]
;
}
return
Promise
.
all
(
promises
)
.
then
(
function
(
)
{
return
results
;
}
)
;
function
defer
(
promise
key
)
{
results
[
key
]
=
undefined
;
promises
.
push
(
promise
.
then
(
function
(
res
)
{
results
[
key
]
=
res
;
}
)
)
;
}
}
function
isPromise
(
obj
)
{
return
'
function
'
=
=
typeof
obj
.
then
;
}
function
isGenerator
(
obj
)
{
return
'
function
'
=
=
typeof
obj
.
next
&
&
'
function
'
=
=
typeof
obj
.
throw
;
}
function
isGeneratorFunction
(
obj
)
{
var
constructor
=
obj
.
constructor
;
if
(
!
constructor
)
return
false
;
if
(
'
GeneratorFunction
'
=
=
=
constructor
.
name
|
|
'
GeneratorFunction
'
=
=
=
constructor
.
displayName
)
return
true
;
return
isGenerator
(
constructor
.
prototype
)
;
}
function
isObject
(
val
)
{
return
Object
=
=
val
.
constructor
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
263
)
;
var
BreakpointResult
=
_require
.
BreakpointResult
;
var
Location
=
_require
.
Location
;
var
debuggerAgent
=
void
0
;
var
runtimeAgent
=
void
0
;
var
pageAgent
=
void
0
;
function
setupCommands
(
_ref
)
{
var
agents
=
_ref
.
agents
;
debuggerAgent
=
agents
.
Debugger
;
runtimeAgent
=
agents
.
Runtime
;
pageAgent
=
agents
.
Page
;
}
function
resume
(
)
{
return
debuggerAgent
.
resume
(
)
;
}
function
stepIn
(
)
{
return
debuggerAgent
.
stepInto
(
)
;
}
function
stepOver
(
)
{
return
debuggerAgent
.
stepOver
(
)
;
}
function
stepOut
(
)
{
return
debuggerAgent
.
stepOut
(
)
;
}
function
pauseOnExceptions
(
toggle
)
{
var
state
=
toggle
?
"
uncaught
"
:
"
none
"
;
return
debuggerAgent
.
setPauseOnExceptions
(
state
)
;
}
function
breakOnNext
(
)
{
return
debuggerAgent
.
pause
(
)
;
}
function
sourceContents
(
sourceId
)
{
return
debuggerAgent
.
getScriptSource
(
sourceId
(
err
contents
)
=
>
(
{
source
:
contents
contentType
:
null
}
)
)
;
}
function
setBreakpoint
(
location
condition
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
return
debuggerAgent
.
setBreakpoint
(
{
scriptId
:
location
.
sourceId
lineNumber
:
location
.
line
-
1
columnNumber
:
location
.
column
}
(
err
breakpointId
actualLocation
)
=
>
{
if
(
err
)
{
reject
(
err
)
;
return
;
}
actualLocation
=
actualLocation
?
{
sourceId
:
actualLocation
.
scriptId
line
:
actualLocation
.
lineNumber
+
1
column
:
actualLocation
.
columnNumber
}
:
location
;
resolve
(
BreakpointResult
(
{
id
:
breakpointId
actualLocation
:
Location
(
actualLocation
)
}
)
)
;
}
)
;
}
)
;
}
function
removeBreakpoint
(
breakpointId
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
resolve
(
debuggerAgent
.
removeBreakpoint
(
breakpointId
)
)
;
}
)
;
}
function
evaluate
(
script
)
{
return
runtimeAgent
.
evaluate
(
script
(
_
result
)
=
>
{
return
result
;
}
)
;
}
function
navigate
(
url
)
{
return
pageAgent
.
navigate
(
url
(
_
result
)
=
>
{
return
result
;
}
)
;
}
var
clientCommands
=
{
resume
stepIn
stepOut
stepOver
pauseOnExceptions
breakOnNext
sourceContents
setBreakpoint
removeBreakpoint
evaluate
navigate
}
;
module
.
exports
=
{
setupCommands
clientCommands
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
paused
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
callFrames
reason
data
hitBreakpoints
asyncStackTrace
)
{
var
frames
=
callFrames
.
map
(
function
(
frame
)
{
return
Frame
(
{
id
:
frame
.
callFrameId
displayName
:
frame
.
functionName
location
:
Location
(
{
sourceId
:
frame
.
location
.
scriptId
line
:
frame
.
location
.
lineNumber
+
1
column
:
frame
.
location
.
columnNumber
}
)
}
)
;
}
)
;
var
frame
=
frames
[
0
]
;
var
why
=
Object
.
assign
(
{
}
{
type
:
reason
}
data
)
;
yield
actions
.
paused
(
{
frame
why
frames
}
)
;
}
)
;
return
function
paused
(
_x
_x2
_x3
_x4
_x5
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
263
)
;
var
Source
=
_require
.
Source
;
var
Location
=
_require
.
Location
;
var
Frame
=
_require
.
Frame
;
var
actions
=
void
0
;
function
setupEvents
(
dependencies
)
{
actions
=
dependencies
.
actions
;
}
function
scriptParsed
(
scriptId
url
startLine
startColumn
endLine
endColumn
executionContextId
hash
isContentScript
isInternalScript
isLiveEdit
sourceMapURL
hasSourceURL
deprecatedCommentWasUsed
)
{
if
(
isContentScript
)
{
return
;
}
actions
.
newSource
(
Source
(
{
id
:
scriptId
url
sourceMapURL
isPrettyPrinted
:
false
}
)
)
;
}
function
scriptFailedToParse
(
)
{
}
function
resumed
(
)
{
actions
.
resumed
(
)
;
}
function
globalObjectCleared
(
)
{
}
function
frameNavigated
(
frame
)
{
actions
.
navigate
(
)
;
}
function
frameStartedLoading
(
)
{
actions
.
willNavigate
(
)
;
}
function
domContentEventFired
(
)
{
}
function
loadEventFired
(
)
{
}
function
frameStoppedLoading
(
)
{
}
var
clientEvents
=
{
scriptParsed
scriptFailedToParse
paused
resumed
globalObjectCleared
}
;
var
pageEvents
=
{
frameNavigated
frameStartedLoading
domContentEventFired
loadEventFired
frameStoppedLoading
}
;
module
.
exports
=
{
setupEvents
pageEvents
clientEvents
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
2
)
;
var
createStore
=
_require
.
createStore
;
var
applyMiddleware
=
_require
.
applyMiddleware
;
var
_require2
=
__webpack_require__
(
329
)
;
var
waitUntilService
=
_require2
.
waitUntilService
;
var
_require3
=
__webpack_require__
(
330
)
;
var
log
=
_require3
.
log
;
var
_require4
=
__webpack_require__
(
331
)
;
var
history
=
_require4
.
history
;
var
_require5
=
__webpack_require__
(
332
)
;
var
promise
=
_require5
.
promise
;
var
_require6
=
__webpack_require__
(
335
)
;
var
thunk
=
_require6
.
thunk
;
var
configureStore
=
function
(
)
{
var
opts
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
var
middleware
=
[
thunk
(
opts
.
makeThunkArgs
)
promise
waitUntilService
]
;
if
(
opts
.
history
)
{
middleware
.
push
(
history
(
opts
.
history
)
)
;
}
if
(
opts
.
middleware
)
{
opts
.
middleware
.
forEach
(
fn
=
>
middleware
.
push
(
fn
)
)
;
}
if
(
opts
.
log
)
{
middleware
.
push
(
log
)
;
}
var
devtoolsExt
=
typeof
window
=
=
=
"
object
"
&
&
window
.
devToolsExtension
?
window
.
devToolsExtension
(
)
:
f
=
>
f
;
return
applyMiddleware
.
apply
(
undefined
middleware
)
(
devtoolsExt
(
createStore
)
)
;
}
;
module
.
exports
=
configureStore
;
}
function
(
module
exports
)
{
"
use
strict
"
;
const
NAME
=
exports
.
NAME
=
"
service
/
waitUntil
"
;
function
waitUntilService
(
{
dispatch
getState
}
)
{
let
pending
=
[
]
;
function
checkPending
(
action
)
{
let
readyRequests
=
[
]
;
let
stillPending
=
[
]
;
for
(
let
request
of
pending
)
{
if
(
request
.
predicate
(
action
)
)
{
readyRequests
.
push
(
request
)
;
}
else
{
stillPending
.
push
(
request
)
;
}
}
pending
=
stillPending
;
for
(
let
request
of
readyRequests
)
{
request
.
run
(
dispatch
getState
action
)
;
}
}
return
next
=
>
action
=
>
{
if
(
action
.
type
=
=
=
NAME
)
{
pending
.
push
(
action
)
;
return
null
;
}
let
result
=
next
(
action
)
;
checkPending
(
action
)
;
return
result
;
}
;
}
exports
.
waitUntilService
=
waitUntilService
;
}
function
(
module
exports
)
{
"
use
strict
"
;
function
log
(
{
dispatch
getState
}
)
{
return
next
=
>
action
=
>
{
console
.
log
(
"
[
DISPATCH
]
"
JSON
.
stringify
(
action
null
2
)
)
;
next
(
action
)
;
}
;
}
exports
.
log
=
log
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
196
)
;
var
isDevelopment
=
_require
.
isDevelopment
;
exports
.
history
=
function
(
)
{
var
log
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
[
]
:
arguments
[
0
]
;
return
_ref
=
>
{
var
dispatch
=
_ref
.
dispatch
;
var
getState
=
_ref
.
getState
;
if
(
isDevelopment
(
)
)
{
console
.
warn
(
"
Using
history
middleware
stores
all
actions
in
state
for
"
+
"
testing
and
devtools
is
not
currently
running
in
test
"
+
"
mode
.
Be
sure
this
is
intentional
.
"
)
;
}
return
next
=
>
action
=
>
{
log
.
push
(
action
)
;
next
(
action
)
;
}
;
}
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
uuidgen
=
__webpack_require__
(
333
)
.
uuid
;
var
defer
=
__webpack_require__
(
261
)
;
var
_require
=
__webpack_require__
(
324
)
;
var
entries
=
_require
.
entries
;
var
toObject
=
_require
.
toObject
;
var
_require2
=
__webpack_require__
(
334
)
;
var
executeSoon
=
_require2
.
executeSoon
;
var
PROMISE
=
exports
.
PROMISE
=
"
dispatch
/
promise
"
;
function
promiseMiddleware
(
_ref
)
{
var
dispatch
=
_ref
.
dispatch
;
var
getState
=
_ref
.
getState
;
return
next
=
>
action
=
>
{
if
(
!
(
PROMISE
in
action
)
)
{
return
next
(
action
)
;
}
var
promiseInst
=
action
[
PROMISE
]
;
var
seqId
=
uuidgen
(
)
.
toString
(
)
;
action
=
Object
.
assign
(
toObject
(
entries
(
action
)
.
filter
(
pair
=
>
pair
[
0
]
!
=
=
PROMISE
)
)
{
seqId
}
)
;
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
start
"
}
)
)
;
var
deferred
=
defer
(
)
;
promiseInst
.
then
(
value
=
>
{
executeSoon
(
(
)
=
>
{
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
done
"
value
:
value
}
)
)
;
deferred
.
resolve
(
value
)
;
}
)
;
}
error
=
>
{
executeSoon
(
(
)
=
>
{
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
error
"
error
:
error
.
message
|
|
error
}
)
)
;
deferred
.
reject
(
error
)
;
}
)
;
}
)
;
return
deferred
.
promise
;
}
;
}
exports
.
promise
=
promiseMiddleware
;
}
function
(
module
exports
)
{
let
i
=
1
;
function
uuid
(
)
{
return
'
not
-
really
-
uuid
'
+
(
i
+
+
)
;
}
module
.
exports
=
{
uuid
}
;
}
function
(
module
exports
)
{
function
reportException
(
who
exception
)
{
var
msg
=
who
+
"
threw
an
exception
:
"
;
console
.
error
(
msg
exception
)
;
}
function
assert
(
condition
message
)
{
if
(
!
condition
)
{
var
err
=
new
Error
(
"
Assertion
failure
:
"
+
message
)
;
reportException
(
"
DevToolsUtils
.
assert
"
err
)
;
throw
err
;
}
}
function
executeSoon
(
fn
)
{
setTimeout
(
fn
0
)
;
}
module
.
exports
=
{
reportException
executeSoon
assert
}
;
}
function
(
module
exports
)
{
function
thunk
(
makeArgs
)
{
return
_ref
=
>
{
var
dispatch
=
_ref
.
dispatch
;
var
getState
=
_ref
.
getState
;
var
args
=
{
dispatch
getState
}
;
return
next
=
>
action
=
>
{
return
typeof
action
=
=
=
"
function
"
?
action
(
makeArgs
?
makeArgs
(
args
getState
(
)
)
:
args
)
:
next
(
action
)
;
}
;
}
;
}
exports
.
thunk
=
thunk
;
}
function
(
module
exports
__webpack_require__
)
{
var
eventListeners
=
__webpack_require__
(
337
)
;
var
sources
=
__webpack_require__
(
339
)
;
var
breakpoints
=
__webpack_require__
(
343
)
;
var
asyncRequests
=
__webpack_require__
(
344
)
;
var
tabs
=
__webpack_require__
(
345
)
;
var
pause
=
__webpack_require__
(
346
)
;
module
.
exports
=
{
eventListeners
sources
:
sources
.
update
breakpoints
:
breakpoints
.
update
asyncRequests
tabs
pause
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
338
)
;
var
initialState
=
{
activeEventNames
:
[
]
listeners
:
[
]
fetchingListeners
:
false
}
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
var
emit
=
arguments
[
2
]
;
switch
(
action
.
type
)
{
case
constants
.
UPDATE_EVENT_BREAKPOINTS
:
state
.
activeEventNames
=
action
.
eventNames
;
emit
(
"
activeEventNames
"
state
.
activeEventNames
)
;
break
;
case
constants
.
FETCH_EVENT_LISTENERS
:
if
(
action
.
status
=
=
=
"
begin
"
)
{
state
.
fetchingListeners
=
true
;
}
else
if
(
action
.
status
=
=
=
"
done
"
)
{
state
.
fetchingListeners
=
false
;
state
.
listeners
=
action
.
listeners
;
emit
(
"
event
-
listeners
"
state
.
listeners
)
;
}
break
;
case
constants
.
NAVIGATE
:
return
initialState
;
}
return
state
;
}
module
.
exports
=
update
;
}
function
(
module
exports
)
{
exports
.
UPDATE_EVENT_BREAKPOINTS
=
"
UPDATE_EVENT_BREAKPOINTS
"
;
exports
.
FETCH_EVENT_LISTENERS
=
"
FETCH_EVENT_LISTENERS
"
;
exports
.
TOGGLE_PRETTY_PRINT
=
"
TOGGLE_PRETTY_PRINT
"
;
exports
.
BLACKBOX
=
"
BLACKBOX
"
;
exports
.
ADD_BREAKPOINT
=
"
ADD_BREAKPOINT
"
;
exports
.
REMOVE_BREAKPOINT
=
"
REMOVE_BREAKPOINT
"
;
exports
.
ENABLE_BREAKPOINT
=
"
ENABLE_BREAKPOINT
"
;
exports
.
DISABLE_BREAKPOINT
=
"
DISABLE_BREAKPOINT
"
;
exports
.
SET_BREAKPOINT_CONDITION
=
"
SET_BREAKPOINT_CONDITION
"
;
exports
.
ADD_SOURCE
=
"
ADD_SOURCE
"
;
exports
.
LOAD_SOURCE_MAP
=
"
LOAD_SOURCE_MAP
"
;
exports
.
CLOSE_TAB
=
"
CLOSE_TAB
"
;
exports
.
ADD_SOURCES
=
"
ADD_SOURCES
"
;
exports
.
LOAD_SOURCE_TEXT
=
"
LOAD_SOURCE_TEXT
"
;
exports
.
SELECT_SOURCE
=
"
SELECT_SOURCE
"
;
exports
.
SELECT_SOURCE_URL
=
"
SELECT_SOURCE_URL
"
;
exports
.
NAVIGATE
=
"
NAVIGATE
"
;
exports
.
RELOAD
=
"
RELOAD
"
;
exports
.
ADD_TABS
=
"
ADD_TABS
"
;
exports
.
SELECT_TAB
=
"
SELECT_TAB
"
;
exports
.
BREAK_ON_NEXT
=
"
BREAK_ON_NEXT
"
;
exports
.
RESUME
=
"
RESUME
"
;
exports
.
PAUSED
=
"
PAUSED
"
;
exports
.
PAUSE_ON_EXCEPTIONS
=
"
PAUSE_ON_EXCEPTIONS
"
;
exports
.
COMMAND
=
"
COMMAND
"
;
exports
.
SELECT_FRAME
=
"
SELECT_FRAME
"
;
exports
.
LOAD_OBJECT_PROPERTIES
=
"
LOAD_OBJECT_PROPERTIES
"
;
exports
.
ADD_EXPRESSION
=
"
ADD_EXPRESSION
"
;
exports
.
EVALUATE_EXPRESSION
=
"
EVALUATE_EXPRESSION
"
;
exports
.
UPDATE_EXPRESSION
=
"
UPDATE_EXPRESSION
"
;
exports
.
DELETE_EXPRESSION
=
"
DELETE_EXPRESSION
"
;
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
fromJS
=
__webpack_require__
(
340
)
;
var
I
=
__webpack_require__
(
341
)
;
var
makeRecord
=
__webpack_require__
(
342
)
;
var
State
=
makeRecord
(
{
sources
:
I
.
Map
(
)
selectedSource
:
undefined
pendingSelectedSourceURL
:
undefined
sourcesText
:
I
.
Map
(
)
sourceMaps
:
I
.
Map
(
)
tabs
:
I
.
List
(
[
]
)
}
)
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
State
(
)
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
"
ADD_SOURCE
"
:
{
var
source
=
action
.
source
;
return
state
.
mergeIn
(
[
"
sources
"
action
.
source
.
id
]
source
)
;
}
case
"
ADD_SOURCES
"
:
return
state
.
mergeIn
(
[
"
sources
"
]
I
.
Map
(
action
.
sources
.
map
(
source
=
>
{
return
[
source
.
id
fromJS
(
source
)
]
;
}
)
)
)
;
case
"
LOAD_SOURCE_MAP
"
:
if
(
action
.
status
=
=
"
done
"
)
{
return
state
.
mergeIn
(
[
"
sourceMaps
"
action
.
source
.
id
]
action
.
value
.
sourceMap
)
;
}
break
;
case
"
SELECT_SOURCE
"
:
return
state
.
merge
(
{
selectedSource
:
action
.
source
pendingSelectedSourceURL
:
null
tabs
:
updateTabList
(
state
fromJS
(
action
.
source
)
action
.
options
)
}
)
;
case
"
SELECT_SOURCE_URL
"
:
return
state
.
merge
(
{
pendingSelectedSourceURL
:
action
.
url
}
)
;
case
"
CLOSE_TAB
"
:
return
state
.
merge
(
{
selectedSource
:
getNewSelectedSource
(
state
action
.
id
)
tabs
:
removeSourceFromTabList
(
state
action
.
id
)
}
)
;
case
"
LOAD_SOURCE_TEXT
"
:
{
var
values
=
void
0
;
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_action
value
=
action
.
value
;
var
generatedSourceText
=
_action
value
.
generatedSourceText
;
var
originalSourceTexts
=
_action
value
.
originalSourceTexts
;
values
=
[
generatedSourceText
]
.
concat
(
_toConsumableArray
(
originalSourceTexts
)
)
;
}
else
{
var
_source
=
action
.
source
;
values
=
[
_source
]
;
}
return
_updateText
(
state
action
values
)
;
}
case
"
BLACKBOX
"
:
if
(
action
.
status
=
=
=
"
done
"
)
{
return
state
.
setIn
(
[
"
sources
"
action
.
source
.
id
"
isBlackBoxed
"
]
action
.
value
.
isBlackBoxed
)
;
}
break
;
case
"
TOGGLE_PRETTY_PRINT
"
:
if
(
action
.
status
=
=
=
"
done
"
)
{
return
_updateText
(
state
action
[
action
.
value
.
sourceText
]
)
.
setIn
(
[
"
sources
"
action
.
source
.
id
"
isPrettyPrinted
"
]
action
.
value
.
isPrettyPrinted
)
;
}
return
_updateText
(
state
action
[
action
.
originalSource
]
)
;
case
"
NAVIGATE
"
:
return
State
(
)
;
}
return
state
;
}
function
_updateText
(
state
action
values
)
{
if
(
action
.
status
=
=
=
"
start
"
)
{
return
values
.
reduce
(
(
_state
source
)
=
>
{
return
_state
.
mergeIn
(
[
"
sourcesText
"
source
.
id
]
{
loading
:
true
}
)
;
}
state
)
;
}
if
(
action
.
status
=
=
=
"
error
"
)
{
return
values
.
reduce
(
(
_state
source
)
=
>
{
return
_state
.
setIn
(
[
"
sourcesText
"
source
.
id
]
I
.
Map
(
{
error
:
action
.
error
}
)
)
;
}
state
)
;
}
return
values
.
reduce
(
(
_state
sourceText
)
=
>
{
return
_state
.
setIn
(
[
"
sourcesText
"
sourceText
.
id
]
I
.
Map
(
{
text
:
sourceText
.
text
contentType
:
sourceText
.
contentType
}
)
)
;
}
state
)
;
}
function
removeSourceFromTabList
(
state
id
)
{
return
state
.
tabs
.
filter
(
tab
=
>
tab
.
get
(
"
id
"
)
!
=
id
)
;
}
function
updateTabList
(
state
source
options
)
{
var
tabs
=
state
.
get
(
"
tabs
"
)
;
var
selectedSource
=
state
.
get
(
"
selectedSource
"
)
;
var
selectedSourceIndex
=
tabs
.
indexOf
(
selectedSource
)
;
var
sourceIndex
=
tabs
.
indexOf
(
source
)
;
var
includesSource
=
!
!
tabs
.
find
(
t
=
>
t
.
get
(
"
id
"
)
=
=
source
.
get
(
"
id
"
)
)
;
if
(
includesSource
)
{
if
(
options
.
position
!
=
undefined
)
{
return
tabs
.
delete
(
sourceIndex
)
.
insert
(
options
.
position
source
)
;
}
return
tabs
;
}
return
tabs
.
insert
(
selectedSourceIndex
+
1
source
)
;
}
function
getNewSelectedSource
(
state
id
)
{
var
tabs
=
state
.
get
(
"
tabs
"
)
;
var
selectedSource
=
state
.
get
(
"
selectedSource
"
)
;
if
(
selectedSource
.
get
(
"
id
"
)
!
=
id
)
{
return
selectedSource
;
}
var
tabIndex
=
tabs
.
findIndex
(
tab
=
>
tab
.
get
(
"
id
"
)
=
=
id
)
;
var
numTabs
=
tabs
.
count
(
)
;
if
(
numTabs
=
=
1
)
{
return
undefined
;
}
if
(
tabIndex
+
1
=
=
numTabs
)
{
return
tabs
.
get
(
tabIndex
-
1
)
;
}
return
tabs
.
get
(
tabIndex
+
1
)
;
}
function
getSource
(
state
id
)
{
return
state
.
sources
.
sources
.
get
(
id
)
;
}
function
getSourceByURL
(
state
url
)
{
return
state
.
sources
.
sources
.
find
(
source
=
>
source
.
get
(
"
url
"
)
=
=
url
)
;
}
function
getSourceById
(
state
id
)
{
return
state
.
sources
.
sources
.
find
(
source
=
>
source
.
get
(
"
id
"
)
=
=
id
)
;
}
function
getSources
(
state
)
{
return
state
.
sources
.
sources
;
}
function
getSourceText
(
state
id
)
{
return
state
.
sources
.
sourcesText
.
get
(
id
)
;
}
function
getSourceTabs
(
state
)
{
return
state
.
sources
.
tabs
;
}
function
getSelectedSource
(
state
)
{
return
state
.
sources
.
selectedSource
;
}
function
getPendingSelectedSourceURL
(
state
)
{
return
state
.
sources
.
pendingSelectedSourceURL
;
}
function
getSourceMap
(
state
sourceId
)
{
return
state
.
sources
.
sourceMaps
.
get
(
sourceId
)
;
}
module
.
exports
=
{
State
update
getSource
getSourceByURL
getSourceById
getSources
getSourceText
getSourceTabs
getSelectedSource
getPendingSelectedSourceURL
getSourceMap
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
Immutable
=
__webpack_require__
(
341
)
;
function
fromJS
(
value
)
{
if
(
Array
.
isArray
(
value
)
)
{
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toList
(
)
;
}
if
(
value
&
&
value
.
constructor
.
meta
)
{
var
kind
=
value
.
constructor
.
meta
.
kind
;
if
(
kind
=
=
=
"
struct
"
)
{
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toMap
(
)
;
}
else
if
(
kind
=
=
=
"
list
"
)
{
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toList
(
)
;
}
}
if
(
value
=
=
null
|
|
typeof
value
!
=
=
"
object
"
)
{
return
value
;
}
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toMap
(
)
;
}
module
.
exports
=
fromJS
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
factory
)
{
true
?
module
.
exports
=
factory
(
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
factory
)
:
(
global
.
Immutable
=
factory
(
)
)
;
}
(
this
function
(
)
{
'
use
strict
'
;
var
SLICE
0
=
Array
.
prototype
.
slice
;
function
createClass
(
ctor
superClass
)
{
if
(
superClass
)
{
ctor
.
prototype
=
Object
.
create
(
superClass
.
prototype
)
;
}
ctor
.
prototype
.
constructor
=
ctor
;
}
function
Iterable
(
value
)
{
return
isIterable
(
value
)
?
value
:
Seq
(
value
)
;
}
createClass
(
KeyedIterable
Iterable
)
;
function
KeyedIterable
(
value
)
{
return
isKeyed
(
value
)
?
value
:
KeyedSeq
(
value
)
;
}
createClass
(
IndexedIterable
Iterable
)
;
function
IndexedIterable
(
value
)
{
return
isIndexed
(
value
)
?
value
:
IndexedSeq
(
value
)
;
}
createClass
(
SetIterable
Iterable
)
;
function
SetIterable
(
value
)
{
return
isIterable
(
value
)
&
&
!
isAssociative
(
value
)
?
value
:
SetSeq
(
value
)
;
}
function
isIterable
(
maybeIterable
)
{
return
!
!
(
maybeIterable
&
&
maybeIterable
[
IS_ITERABLE_SENTINEL
]
)
;
}
function
isKeyed
(
maybeKeyed
)
{
return
!
!
(
maybeKeyed
&
&
maybeKeyed
[
IS_KEYED_SENTINEL
]
)
;
}
function
isIndexed
(
maybeIndexed
)
{
return
!
!
(
maybeIndexed
&
&
maybeIndexed
[
IS_INDEXED_SENTINEL
]
)
;
}
function
isAssociative
(
maybeAssociative
)
{
return
isKeyed
(
maybeAssociative
)
|
|
isIndexed
(
maybeAssociative
)
;
}
function
isOrdered
(
maybeOrdered
)
{
return
!
!
(
maybeOrdered
&
&
maybeOrdered
[
IS_ORDERED_SENTINEL
]
)
;
}
Iterable
.
isIterable
=
isIterable
;
Iterable
.
isKeyed
=
isKeyed
;
Iterable
.
isIndexed
=
isIndexed
;
Iterable
.
isAssociative
=
isAssociative
;
Iterable
.
isOrdered
=
isOrdered
;
Iterable
.
Keyed
=
KeyedIterable
;
Iterable
.
Indexed
=
IndexedIterable
;
Iterable
.
Set
=
SetIterable
;
var
IS_ITERABLE_SENTINEL
=
'
__IMMUTABLE_ITERABLE__
'
;
var
IS_KEYED_SENTINEL
=
'
__IMMUTABLE_KEYED__
'
;
var
IS_INDEXED_SENTINEL
=
'
__IMMUTABLE_INDEXED__
'
;
var
IS_ORDERED_SENTINEL
=
'
__IMMUTABLE_ORDERED__
'
;
var
DELETE
=
'
delete
'
;
var
SHIFT
=
5
;
var
SIZE
=
1
<
<
SHIFT
;
var
MASK
=
SIZE
-
1
;
var
NOT_SET
=
{
}
;
var
CHANGE_LENGTH
=
{
value
:
false
}
;
var
DID_ALTER
=
{
value
:
false
}
;
function
MakeRef
(
ref
)
{
ref
.
value
=
false
;
return
ref
;
}
function
SetRef
(
ref
)
{
ref
&
&
(
ref
.
value
=
true
)
;
}
function
OwnerID
(
)
{
}
function
arrCopy
(
arr
offset
)
{
offset
=
offset
|
|
0
;
var
len
=
Math
.
max
(
0
arr
.
length
-
offset
)
;
var
newArr
=
new
Array
(
len
)
;
for
(
var
ii
=
0
;
ii
<
len
;
ii
+
+
)
{
newArr
[
ii
]
=
arr
[
ii
+
offset
]
;
}
return
newArr
;
}
function
ensureSize
(
iter
)
{
if
(
iter
.
size
=
=
=
undefined
)
{
iter
.
size
=
iter
.
__iterate
(
returnTrue
)
;
}
return
iter
.
size
;
}
function
wrapIndex
(
iter
index
)
{
if
(
typeof
index
!
=
=
'
number
'
)
{
var
uint32Index
=
index
>
>
>
0
;
if
(
'
'
+
uint32Index
!
=
=
index
|
|
uint32Index
=
=
=
4294967295
)
{
return
NaN
;
}
index
=
uint32Index
;
}
return
index
<
0
?
ensureSize
(
iter
)
+
index
:
index
;
}
function
returnTrue
(
)
{
return
true
;
}
function
wholeSlice
(
begin
end
size
)
{
return
(
begin
=
=
=
0
|
|
(
size
!
=
=
undefined
&
&
begin
<
=
-
size
)
)
&
&
(
end
=
=
=
undefined
|
|
(
size
!
=
=
undefined
&
&
end
>
=
size
)
)
;
}
function
resolveBegin
(
begin
size
)
{
return
resolveIndex
(
begin
size
0
)
;
}
function
resolveEnd
(
end
size
)
{
return
resolveIndex
(
end
size
size
)
;
}
function
resolveIndex
(
index
size
defaultIndex
)
{
return
index
=
=
=
undefined
?
defaultIndex
:
index
<
0
?
Math
.
max
(
0
size
+
index
)
:
size
=
=
=
undefined
?
index
:
Math
.
min
(
size
index
)
;
}
var
ITERATE_KEYS
=
0
;
var
ITERATE_VALUES
=
1
;
var
ITERATE_ENTRIES
=
2
;
var
REAL_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
var
ITERATOR_SYMBOL
=
REAL_ITERATOR_SYMBOL
|
|
FAUX_ITERATOR_SYMBOL
;
function
Iterator
(
next
)
{
this
.
next
=
next
;
}
Iterator
.
prototype
.
toString
=
function
(
)
{
return
'
[
Iterator
]
'
;
}
;
Iterator
.
KEYS
=
ITERATE_KEYS
;
Iterator
.
VALUES
=
ITERATE_VALUES
;
Iterator
.
ENTRIES
=
ITERATE_ENTRIES
;
Iterator
.
prototype
.
inspect
=
Iterator
.
prototype
.
toSource
=
function
(
)
{
return
this
.
toString
(
)
;
}
Iterator
.
prototype
[
ITERATOR_SYMBOL
]
=
function
(
)
{
return
this
;
}
;
function
iteratorValue
(
type
k
v
iteratorResult
)
{
var
value
=
type
=
=
=
0
?
k
:
type
=
=
=
1
?
v
:
[
k
v
]
;
iteratorResult
?
(
iteratorResult
.
value
=
value
)
:
(
iteratorResult
=
{
value
:
value
done
:
false
}
)
;
return
iteratorResult
;
}
function
iteratorDone
(
)
{
return
{
value
:
undefined
done
:
true
}
;
}
function
hasIterator
(
maybeIterable
)
{
return
!
!
getIteratorFn
(
maybeIterable
)
;
}
function
isIterator
(
maybeIterator
)
{
return
maybeIterator
&
&
typeof
maybeIterator
.
next
=
=
=
'
function
'
;
}
function
getIterator
(
iterable
)
{
var
iteratorFn
=
getIteratorFn
(
iterable
)
;
return
iteratorFn
&
&
iteratorFn
.
call
(
iterable
)
;
}
function
getIteratorFn
(
iterable
)
{
var
iteratorFn
=
iterable
&
&
(
(
REAL_ITERATOR_SYMBOL
&
&
iterable
[
REAL_ITERATOR_SYMBOL
]
)
|
|
iterable
[
FAUX_ITERATOR_SYMBOL
]
)
;
if
(
typeof
iteratorFn
=
=
=
'
function
'
)
{
return
iteratorFn
;
}
}
function
isArrayLike
(
value
)
{
return
value
&
&
typeof
value
.
length
=
=
=
'
number
'
;
}
createClass
(
Seq
Iterable
)
;
function
Seq
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
:
isIterable
(
value
)
?
value
.
toSeq
(
)
:
seqFromValue
(
value
)
;
}
Seq
.
of
=
function
(
)
{
return
Seq
(
arguments
)
;
}
;
Seq
.
prototype
.
toSeq
=
function
(
)
{
return
this
;
}
;
Seq
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Seq
{
'
'
}
'
)
;
}
;
Seq
.
prototype
.
cacheResult
=
function
(
)
{
if
(
!
this
.
_cache
&
&
this
.
__iterateUncached
)
{
this
.
_cache
=
this
.
entrySeq
(
)
.
toArray
(
)
;
this
.
size
=
this
.
_cache
.
length
;
}
return
this
;
}
;
Seq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
return
seqIterate
(
this
fn
reverse
true
)
;
}
;
Seq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
seqIterator
(
this
type
reverse
true
)
;
}
;
createClass
(
KeyedSeq
Seq
)
;
function
KeyedSeq
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
.
toKeyedSeq
(
)
:
isIterable
(
value
)
?
(
isKeyed
(
value
)
?
value
.
toSeq
(
)
:
value
.
fromEntrySeq
(
)
)
:
keyedSeqFromValue
(
value
)
;
}
KeyedSeq
.
prototype
.
toKeyedSeq
=
function
(
)
{
return
this
;
}
;
createClass
(
IndexedSeq
Seq
)
;
function
IndexedSeq
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
:
!
isIterable
(
value
)
?
indexedSeqFromValue
(
value
)
:
isKeyed
(
value
)
?
value
.
entrySeq
(
)
:
value
.
toIndexedSeq
(
)
;
}
IndexedSeq
.
of
=
function
(
)
{
return
IndexedSeq
(
arguments
)
;
}
;
IndexedSeq
.
prototype
.
toIndexedSeq
=
function
(
)
{
return
this
;
}
;
IndexedSeq
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Seq
[
'
'
]
'
)
;
}
;
IndexedSeq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
return
seqIterate
(
this
fn
reverse
false
)
;
}
;
IndexedSeq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
seqIterator
(
this
type
reverse
false
)
;
}
;
createClass
(
SetSeq
Seq
)
;
function
SetSeq
(
value
)
{
return
(
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
:
!
isIterable
(
value
)
?
indexedSeqFromValue
(
value
)
:
isKeyed
(
value
)
?
value
.
entrySeq
(
)
:
value
)
.
toSetSeq
(
)
;
}
SetSeq
.
of
=
function
(
)
{
return
SetSeq
(
arguments
)
;
}
;
SetSeq
.
prototype
.
toSetSeq
=
function
(
)
{
return
this
;
}
;
Seq
.
isSeq
=
isSeq
;
Seq
.
Keyed
=
KeyedSeq
;
Seq
.
Set
=
SetSeq
;
Seq
.
Indexed
=
IndexedSeq
;
var
IS_SEQ_SENTINEL
=
'
__IMMUTABLE_SEQ__
'
;
Seq
.
prototype
[
IS_SEQ_SENTINEL
]
=
true
;
createClass
(
ArraySeq
IndexedSeq
)
;
function
ArraySeq
(
array
)
{
this
.
_array
=
array
;
this
.
size
=
array
.
length
;
}
ArraySeq
.
prototype
.
get
=
function
(
index
notSetValue
)
{
return
this
.
has
(
index
)
?
this
.
_array
[
wrapIndex
(
this
index
)
]
:
notSetValue
;
}
;
ArraySeq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
array
=
this
.
_array
;
var
maxIndex
=
array
.
length
-
1
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
if
(
fn
(
array
[
reverse
?
maxIndex
-
ii
:
ii
]
ii
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
;
ArraySeq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
array
=
this
.
_array
;
var
maxIndex
=
array
.
length
-
1
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
return
ii
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
ii
array
[
reverse
?
maxIndex
-
ii
+
+
:
ii
+
+
]
)
}
)
;
}
;
createClass
(
ObjectSeq
KeyedSeq
)
;
function
ObjectSeq
(
object
)
{
var
keys
=
Object
.
keys
(
object
)
;
this
.
_object
=
object
;
this
.
_keys
=
keys
;
this
.
size
=
keys
.
length
;
}
ObjectSeq
.
prototype
.
get
=
function
(
key
notSetValue
)
{
if
(
notSetValue
!
=
=
undefined
&
&
!
this
.
has
(
key
)
)
{
return
notSetValue
;
}
return
this
.
_object
[
key
]
;
}
;
ObjectSeq
.
prototype
.
has
=
function
(
key
)
{
return
this
.
_object
.
hasOwnProperty
(
key
)
;
}
;
ObjectSeq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
object
=
this
.
_object
;
var
keys
=
this
.
_keys
;
var
maxIndex
=
keys
.
length
-
1
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
var
key
=
keys
[
reverse
?
maxIndex
-
ii
:
ii
]
;
if
(
fn
(
object
[
key
]
key
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
;
ObjectSeq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
object
=
this
.
_object
;
var
keys
=
this
.
_keys
;
var
maxIndex
=
keys
.
length
-
1
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
var
key
=
keys
[
reverse
?
maxIndex
-
ii
:
ii
]
;
return
ii
+
+
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
key
object
[
key
]
)
;
}
)
;
}
;
ObjectSeq
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
createClass
(
IterableSeq
IndexedSeq
)
;
function
IterableSeq
(
iterable
)
{
this
.
_iterable
=
iterable
;
this
.
size
=
iterable
.
length
|
|
iterable
.
size
;
}
IterableSeq
.
prototype
.
__iterateUncached
=
function
(
fn
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
iterable
=
this
.
_iterable
;
var
iterator
=
getIterator
(
iterable
)
;
var
iterations
=
0
;
if
(
isIterator
(
iterator
)
)
{
var
step
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
if
(
fn
(
step
.
value
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
}
}
return
iterations
;
}
;
IterableSeq
.
prototype
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterable
=
this
.
_iterable
;
var
iterator
=
getIterator
(
iterable
)
;
if
(
!
isIterator
(
iterator
)
)
{
return
new
Iterator
(
iteratorDone
)
;
}
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
iterations
+
+
step
.
value
)
;
}
)
;
}
;
createClass
(
IteratorSeq
IndexedSeq
)
;
function
IteratorSeq
(
iterator
)
{
this
.
_iterator
=
iterator
;
this
.
_iteratorCache
=
[
]
;
}
IteratorSeq
.
prototype
.
__iterateUncached
=
function
(
fn
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
iterator
=
this
.
_iterator
;
var
cache
=
this
.
_iteratorCache
;
var
iterations
=
0
;
while
(
iterations
<
cache
.
length
)
{
if
(
fn
(
cache
[
iterations
]
iterations
+
+
this
)
=
=
=
false
)
{
return
iterations
;
}
}
var
step
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
var
val
=
step
.
value
;
cache
[
iterations
]
=
val
;
if
(
fn
(
val
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
}
return
iterations
;
}
;
IteratorSeq
.
prototype
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
this
.
_iterator
;
var
cache
=
this
.
_iteratorCache
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
if
(
iterations
>
=
cache
.
length
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
cache
[
iterations
]
=
step
.
value
;
}
return
iteratorValue
(
type
iterations
cache
[
iterations
+
+
]
)
;
}
)
;
}
;
function
isSeq
(
maybeSeq
)
{
return
!
!
(
maybeSeq
&
&
maybeSeq
[
IS_SEQ_SENTINEL
]
)
;
}
var
EMPTY_SEQ
;
function
emptySequence
(
)
{
return
EMPTY_SEQ
|
|
(
EMPTY_SEQ
=
new
ArraySeq
(
[
]
)
)
;
}
function
keyedSeqFromValue
(
value
)
{
var
seq
=
Array
.
isArray
(
value
)
?
new
ArraySeq
(
value
)
.
fromEntrySeq
(
)
:
isIterator
(
value
)
?
new
IteratorSeq
(
value
)
.
fromEntrySeq
(
)
:
hasIterator
(
value
)
?
new
IterableSeq
(
value
)
.
fromEntrySeq
(
)
:
typeof
value
=
=
=
'
object
'
?
new
ObjectSeq
(
value
)
:
undefined
;
if
(
!
seq
)
{
throw
new
TypeError
(
'
Expected
Array
or
iterable
object
of
[
k
v
]
entries
'
+
'
or
keyed
object
:
'
+
value
)
;
}
return
seq
;
}
function
indexedSeqFromValue
(
value
)
{
var
seq
=
maybeIndexedSeqFromValue
(
value
)
;
if
(
!
seq
)
{
throw
new
TypeError
(
'
Expected
Array
or
iterable
object
of
values
:
'
+
value
)
;
}
return
seq
;
}
function
seqFromValue
(
value
)
{
var
seq
=
maybeIndexedSeqFromValue
(
value
)
|
|
(
typeof
value
=
=
=
'
object
'
&
&
new
ObjectSeq
(
value
)
)
;
if
(
!
seq
)
{
throw
new
TypeError
(
'
Expected
Array
or
iterable
object
of
values
or
keyed
object
:
'
+
value
)
;
}
return
seq
;
}
function
maybeIndexedSeqFromValue
(
value
)
{
return
(
isArrayLike
(
value
)
?
new
ArraySeq
(
value
)
:
isIterator
(
value
)
?
new
IteratorSeq
(
value
)
:
hasIterator
(
value
)
?
new
IterableSeq
(
value
)
:
undefined
)
;
}
function
seqIterate
(
seq
fn
reverse
useKeys
)
{
var
cache
=
seq
.
_cache
;
if
(
cache
)
{
var
maxIndex
=
cache
.
length
-
1
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
var
entry
=
cache
[
reverse
?
maxIndex
-
ii
:
ii
]
;
if
(
fn
(
entry
[
1
]
useKeys
?
entry
[
0
]
:
ii
seq
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
return
seq
.
__iterateUncached
(
fn
reverse
)
;
}
function
seqIterator
(
seq
type
reverse
useKeys
)
{
var
cache
=
seq
.
_cache
;
if
(
cache
)
{
var
maxIndex
=
cache
.
length
-
1
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
var
entry
=
cache
[
reverse
?
maxIndex
-
ii
:
ii
]
;
return
ii
+
+
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
useKeys
?
entry
[
0
]
:
ii
-
1
entry
[
1
]
)
;
}
)
;
}
return
seq
.
__iteratorUncached
(
type
reverse
)
;
}
function
fromJS
(
json
converter
)
{
return
converter
?
fromJSWith
(
converter
json
'
'
{
'
'
:
json
}
)
:
fromJSDefault
(
json
)
;
}
function
fromJSWith
(
converter
json
key
parentJSON
)
{
if
(
Array
.
isArray
(
json
)
)
{
return
converter
.
call
(
parentJSON
key
IndexedSeq
(
json
)
.
map
(
function
(
v
k
)
{
return
fromJSWith
(
converter
v
k
json
)
}
)
)
;
}
if
(
isPlainObj
(
json
)
)
{
return
converter
.
call
(
parentJSON
key
KeyedSeq
(
json
)
.
map
(
function
(
v
k
)
{
return
fromJSWith
(
converter
v
k
json
)
}
)
)
;
}
return
json
;
}
function
fromJSDefault
(
json
)
{
if
(
Array
.
isArray
(
json
)
)
{
return
IndexedSeq
(
json
)
.
map
(
fromJSDefault
)
.
toList
(
)
;
}
if
(
isPlainObj
(
json
)
)
{
return
KeyedSeq
(
json
)
.
map
(
fromJSDefault
)
.
toMap
(
)
;
}
return
json
;
}
function
isPlainObj
(
value
)
{
return
value
&
&
(
value
.
constructor
=
=
=
Object
|
|
value
.
constructor
=
=
=
undefined
)
;
}
function
is
(
valueA
valueB
)
{
if
(
valueA
=
=
=
valueB
|
|
(
valueA
!
=
=
valueA
&
&
valueB
!
=
=
valueB
)
)
{
return
true
;
}
if
(
!
valueA
|
|
!
valueB
)
{
return
false
;
}
if
(
typeof
valueA
.
valueOf
=
=
=
'
function
'
&
&
typeof
valueB
.
valueOf
=
=
=
'
function
'
)
{
valueA
=
valueA
.
valueOf
(
)
;
valueB
=
valueB
.
valueOf
(
)
;
if
(
valueA
=
=
=
valueB
|
|
(
valueA
!
=
=
valueA
&
&
valueB
!
=
=
valueB
)
)
{
return
true
;
}
if
(
!
valueA
|
|
!
valueB
)
{
return
false
;
}
}
if
(
typeof
valueA
.
equals
=
=
=
'
function
'
&
&
typeof
valueB
.
equals
=
=
=
'
function
'
&
&
valueA
.
equals
(
valueB
)
)
{
return
true
;
}
return
false
;
}
function
deepEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
!
isIterable
(
b
)
|
|
a
.
size
!
=
=
undefined
&
&
b
.
size
!
=
=
undefined
&
&
a
.
size
!
=
=
b
.
size
|
|
a
.
__hash
!
=
=
undefined
&
&
b
.
__hash
!
=
=
undefined
&
&
a
.
__hash
!
=
=
b
.
__hash
|
|
isKeyed
(
a
)
!
=
=
isKeyed
(
b
)
|
|
isIndexed
(
a
)
!
=
=
isIndexed
(
b
)
|
|
isOrdered
(
a
)
!
=
=
isOrdered
(
b
)
)
{
return
false
;
}
if
(
a
.
size
=
=
=
0
&
&
b
.
size
=
=
=
0
)
{
return
true
;
}
var
notAssociative
=
!
isAssociative
(
a
)
;
if
(
isOrdered
(
a
)
)
{
var
entries
=
a
.
entries
(
)
;
return
b
.
every
(
function
(
v
k
)
{
var
entry
=
entries
.
next
(
)
.
value
;
return
entry
&
&
is
(
entry
[
1
]
v
)
&
&
(
notAssociative
|
|
is
(
entry
[
0
]
k
)
)
;
}
)
&
&
entries
.
next
(
)
.
done
;
}
var
flipped
=
false
;
if
(
a
.
size
=
=
=
undefined
)
{
if
(
b
.
size
=
=
=
undefined
)
{
if
(
typeof
a
.
cacheResult
=
=
=
'
function
'
)
{
a
.
cacheResult
(
)
;
}
}
else
{
flipped
=
true
;
var
_
=
a
;
a
=
b
;
b
=
_
;
}
}
var
allEqual
=
true
;
var
bSize
=
b
.
__iterate
(
function
(
v
k
)
{
if
(
notAssociative
?
!
a
.
has
(
v
)
:
flipped
?
!
is
(
v
a
.
get
(
k
NOT_SET
)
)
:
!
is
(
a
.
get
(
k
NOT_SET
)
v
)
)
{
allEqual
=
false
;
return
false
;
}
}
)
;
return
allEqual
&
&
a
.
size
=
=
=
bSize
;
}
createClass
(
Repeat
IndexedSeq
)
;
function
Repeat
(
value
times
)
{
if
(
!
(
this
instanceof
Repeat
)
)
{
return
new
Repeat
(
value
times
)
;
}
this
.
_value
=
value
;
this
.
size
=
times
=
=
=
undefined
?
Infinity
:
Math
.
max
(
0
times
)
;
if
(
this
.
size
=
=
=
0
)
{
if
(
EMPTY_REPEAT
)
{
return
EMPTY_REPEAT
;
}
EMPTY_REPEAT
=
this
;
}
}
Repeat
.
prototype
.
toString
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
'
Repeat
[
]
'
;
}
return
'
Repeat
[
'
+
this
.
_value
+
'
'
+
this
.
size
+
'
times
]
'
;
}
;
Repeat
.
prototype
.
get
=
function
(
index
notSetValue
)
{
return
this
.
has
(
index
)
?
this
.
_value
:
notSetValue
;
}
;
Repeat
.
prototype
.
includes
=
function
(
searchValue
)
{
return
is
(
this
.
_value
searchValue
)
;
}
;
Repeat
.
prototype
.
slice
=
function
(
begin
end
)
{
var
size
=
this
.
size
;
return
wholeSlice
(
begin
end
size
)
?
this
:
new
Repeat
(
this
.
_value
resolveEnd
(
end
size
)
-
resolveBegin
(
begin
size
)
)
;
}
;
Repeat
.
prototype
.
reverse
=
function
(
)
{
return
this
;
}
;
Repeat
.
prototype
.
indexOf
=
function
(
searchValue
)
{
if
(
is
(
this
.
_value
searchValue
)
)
{
return
0
;
}
return
-
1
;
}
;
Repeat
.
prototype
.
lastIndexOf
=
function
(
searchValue
)
{
if
(
is
(
this
.
_value
searchValue
)
)
{
return
this
.
size
;
}
return
-
1
;
}
;
Repeat
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
for
(
var
ii
=
0
;
ii
<
this
.
size
;
ii
+
+
)
{
if
(
fn
(
this
.
_value
ii
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
;
Repeat
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
this
0
=
this
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
return
ii
<
this
0
.
size
?
iteratorValue
(
type
ii
+
+
this
0
.
_value
)
:
iteratorDone
(
)
}
)
;
}
;
Repeat
.
prototype
.
equals
=
function
(
other
)
{
return
other
instanceof
Repeat
?
is
(
this
.
_value
other
.
_value
)
:
deepEqual
(
other
)
;
}
;
var
EMPTY_REPEAT
;
function
invariant
(
condition
error
)
{
if
(
!
condition
)
throw
new
Error
(
error
)
;
}
createClass
(
Range
IndexedSeq
)
;
function
Range
(
start
end
step
)
{
if
(
!
(
this
instanceof
Range
)
)
{
return
new
Range
(
start
end
step
)
;
}
invariant
(
step
!
=
=
0
'
Cannot
step
a
Range
by
0
'
)
;
start
=
start
|
|
0
;
if
(
end
=
=
=
undefined
)
{
end
=
Infinity
;
}
step
=
step
=
=
=
undefined
?
1
:
Math
.
abs
(
step
)
;
if
(
end
<
start
)
{
step
=
-
step
;
}
this
.
_start
=
start
;
this
.
_end
=
end
;
this
.
_step
=
step
;
this
.
size
=
Math
.
max
(
0
Math
.
ceil
(
(
end
-
start
)
/
step
-
1
)
+
1
)
;
if
(
this
.
size
=
=
=
0
)
{
if
(
EMPTY_RANGE
)
{
return
EMPTY_RANGE
;
}
EMPTY_RANGE
=
this
;
}
}
Range
.
prototype
.
toString
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
'
Range
[
]
'
;
}
return
'
Range
[
'
+
this
.
_start
+
'
.
.
.
'
+
this
.
_end
+
(
this
.
_step
!
=
=
1
?
'
by
'
+
this
.
_step
:
'
'
)
+
'
]
'
;
}
;
Range
.
prototype
.
get
=
function
(
index
notSetValue
)
{
return
this
.
has
(
index
)
?
this
.
_start
+
wrapIndex
(
this
index
)
*
this
.
_step
:
notSetValue
;
}
;
Range
.
prototype
.
includes
=
function
(
searchValue
)
{
var
possibleIndex
=
(
searchValue
-
this
.
_start
)
/
this
.
_step
;
return
possibleIndex
>
=
0
&
&
possibleIndex
<
this
.
size
&
&
possibleIndex
=
=
=
Math
.
floor
(
possibleIndex
)
;
}
;
Range
.
prototype
.
slice
=
function
(
begin
end
)
{
if
(
wholeSlice
(
begin
end
this
.
size
)
)
{
return
this
;
}
begin
=
resolveBegin
(
begin
this
.
size
)
;
end
=
resolveEnd
(
end
this
.
size
)
;
if
(
end
<
=
begin
)
{
return
new
Range
(
0
0
)
;
}
return
new
Range
(
this
.
get
(
begin
this
.
_end
)
this
.
get
(
end
this
.
_end
)
this
.
_step
)
;
}
;
Range
.
prototype
.
indexOf
=
function
(
searchValue
)
{
var
offsetValue
=
searchValue
-
this
.
_start
;
if
(
offsetValue
%
this
.
_step
=
=
=
0
)
{
var
index
=
offsetValue
/
this
.
_step
;
if
(
index
>
=
0
&
&
index
<
this
.
size
)
{
return
index
}
}
return
-
1
;
}
;
Range
.
prototype
.
lastIndexOf
=
function
(
searchValue
)
{
return
this
.
indexOf
(
searchValue
)
;
}
;
Range
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
maxIndex
=
this
.
size
-
1
;
var
step
=
this
.
_step
;
var
value
=
reverse
?
this
.
_start
+
maxIndex
*
step
:
this
.
_start
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
if
(
fn
(
value
ii
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
value
+
=
reverse
?
-
step
:
step
;
}
return
ii
;
}
;
Range
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
maxIndex
=
this
.
size
-
1
;
var
step
=
this
.
_step
;
var
value
=
reverse
?
this
.
_start
+
maxIndex
*
step
:
this
.
_start
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
var
v
=
value
;
value
+
=
reverse
?
-
step
:
step
;
return
ii
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
ii
+
+
v
)
;
}
)
;
}
;
Range
.
prototype
.
equals
=
function
(
other
)
{
return
other
instanceof
Range
?
this
.
_start
=
=
=
other
.
_start
&
&
this
.
_end
=
=
=
other
.
_end
&
&
this
.
_step
=
=
=
other
.
_step
:
deepEqual
(
this
other
)
;
}
;
var
EMPTY_RANGE
;
createClass
(
Collection
Iterable
)
;
function
Collection
(
)
{
throw
TypeError
(
'
Abstract
'
)
;
}
createClass
(
KeyedCollection
Collection
)
;
function
KeyedCollection
(
)
{
}
createClass
(
IndexedCollection
Collection
)
;
function
IndexedCollection
(
)
{
}
createClass
(
SetCollection
Collection
)
;
function
SetCollection
(
)
{
}
Collection
.
Keyed
=
KeyedCollection
;
Collection
.
Indexed
=
IndexedCollection
;
Collection
.
Set
=
SetCollection
;
var
imul
=
typeof
Math
.
imul
=
=
=
'
function
'
&
&
Math
.
imul
(
0xffffffff
2
)
=
=
=
-
2
?
Math
.
imul
:
function
imul
(
a
b
)
{
a
=
a
|
0
;
b
=
b
|
0
;
var
c
=
a
&
0xffff
;
var
d
=
b
&
0xffff
;
return
(
c
*
d
)
+
(
(
(
(
a
>
>
>
16
)
*
d
+
c
*
(
b
>
>
>
16
)
)
<
<
16
)
>
>
>
0
)
|
0
;
}
;
function
smi
(
i32
)
{
return
(
(
i32
>
>
>
1
)
&
0x40000000
)
|
(
i32
&
0xBFFFFFFF
)
;
}
function
hash
(
o
)
{
if
(
o
=
=
=
false
|
|
o
=
=
=
null
|
|
o
=
=
=
undefined
)
{
return
0
;
}
if
(
typeof
o
.
valueOf
=
=
=
'
function
'
)
{
o
=
o
.
valueOf
(
)
;
if
(
o
=
=
=
false
|
|
o
=
=
=
null
|
|
o
=
=
=
undefined
)
{
return
0
;
}
}
if
(
o
=
=
=
true
)
{
return
1
;
}
var
type
=
typeof
o
;
if
(
type
=
=
=
'
number
'
)
{
if
(
o
!
=
=
o
|
|
o
=
=
=
Infinity
)
{
return
0
;
}
var
h
=
o
|
0
;
if
(
h
!
=
=
o
)
{
h
^
=
o
*
0xFFFFFFFF
;
}
while
(
o
>
0xFFFFFFFF
)
{
o
/
=
0xFFFFFFFF
;
h
^
=
o
;
}
return
smi
(
h
)
;
}
if
(
type
=
=
=
'
string
'
)
{
return
o
.
length
>
STRING_HASH_CACHE_MIN_STRLEN
?
cachedHashString
(
o
)
:
hashString
(
o
)
;
}
if
(
typeof
o
.
hashCode
=
=
=
'
function
'
)
{
return
o
.
hashCode
(
)
;
}
if
(
type
=
=
=
'
object
'
)
{
return
hashJSObj
(
o
)
;
}
if
(
typeof
o
.
toString
=
=
=
'
function
'
)
{
return
hashString
(
o
.
toString
(
)
)
;
}
throw
new
Error
(
'
Value
type
'
+
type
+
'
cannot
be
hashed
.
'
)
;
}
function
cachedHashString
(
string
)
{
var
hash
=
stringHashCache
[
string
]
;
if
(
hash
=
=
=
undefined
)
{
hash
=
hashString
(
string
)
;
if
(
STRING_HASH_CACHE_SIZE
=
=
=
STRING_HASH_CACHE_MAX_SIZE
)
{
STRING_HASH_CACHE_SIZE
=
0
;
stringHashCache
=
{
}
;
}
STRING_HASH_CACHE_SIZE
+
+
;
stringHashCache
[
string
]
=
hash
;
}
return
hash
;
}
function
hashString
(
string
)
{
var
hash
=
0
;
for
(
var
ii
=
0
;
ii
<
string
.
length
;
ii
+
+
)
{
hash
=
31
*
hash
+
string
.
charCodeAt
(
ii
)
|
0
;
}
return
smi
(
hash
)
;
}
function
hashJSObj
(
obj
)
{
var
hash
;
if
(
usingWeakMap
)
{
hash
=
weakMap
.
get
(
obj
)
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
}
hash
=
obj
[
UID_HASH_KEY
]
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
if
(
!
canDefineProperty
)
{
hash
=
obj
.
propertyIsEnumerable
&
&
obj
.
propertyIsEnumerable
[
UID_HASH_KEY
]
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
hash
=
getIENodeHash
(
obj
)
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
}
hash
=
+
+
objHashUID
;
if
(
objHashUID
&
0x40000000
)
{
objHashUID
=
0
;
}
if
(
usingWeakMap
)
{
weakMap
.
set
(
obj
hash
)
;
}
else
if
(
isExtensible
!
=
=
undefined
&
&
isExtensible
(
obj
)
=
=
=
false
)
{
throw
new
Error
(
'
Non
-
extensible
objects
are
not
allowed
as
keys
.
'
)
;
}
else
if
(
canDefineProperty
)
{
Object
.
defineProperty
(
obj
UID_HASH_KEY
{
'
enumerable
'
:
false
'
configurable
'
:
false
'
writable
'
:
false
'
value
'
:
hash
}
)
;
}
else
if
(
obj
.
propertyIsEnumerable
!
=
=
undefined
&
&
obj
.
propertyIsEnumerable
=
=
=
obj
.
constructor
.
prototype
.
propertyIsEnumerable
)
{
obj
.
propertyIsEnumerable
=
function
(
)
{
return
this
.
constructor
.
prototype
.
propertyIsEnumerable
.
apply
(
this
arguments
)
;
}
;
obj
.
propertyIsEnumerable
[
UID_HASH_KEY
]
=
hash
;
}
else
if
(
obj
.
nodeType
!
=
=
undefined
)
{
obj
[
UID_HASH_KEY
]
=
hash
;
}
else
{
throw
new
Error
(
'
Unable
to
set
a
non
-
enumerable
property
on
object
.
'
)
;
}
return
hash
;
}
var
isExtensible
=
Object
.
isExtensible
;
var
canDefineProperty
=
(
function
(
)
{
try
{
Object
.
defineProperty
(
{
}
'
'
{
}
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
(
)
)
;
function
getIENodeHash
(
node
)
{
if
(
node
&
&
node
.
nodeType
>
0
)
{
switch
(
node
.
nodeType
)
{
case
1
:
return
node
.
uniqueID
;
case
9
:
return
node
.
documentElement
&
&
node
.
documentElement
.
uniqueID
;
}
}
}
var
usingWeakMap
=
typeof
WeakMap
=
=
=
'
function
'
;
var
weakMap
;
if
(
usingWeakMap
)
{
weakMap
=
new
WeakMap
(
)
;
}
var
objHashUID
=
0
;
var
UID_HASH_KEY
=
'
__immutablehash__
'
;
if
(
typeof
Symbol
=
=
=
'
function
'
)
{
UID_HASH_KEY
=
Symbol
(
UID_HASH_KEY
)
;
}
var
STRING_HASH_CACHE_MIN_STRLEN
=
16
;
var
STRING_HASH_CACHE_MAX_SIZE
=
255
;
var
STRING_HASH_CACHE_SIZE
=
0
;
var
stringHashCache
=
{
}
;
function
assertNotInfinite
(
size
)
{
invariant
(
size
!
=
=
Infinity
'
Cannot
perform
this
action
with
an
infinite
size
.
'
)
;
}
createClass
(
Map
KeyedCollection
)
;
function
Map
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyMap
(
)
:
isMap
(
value
)
&
&
!
isOrdered
(
value
)
?
value
:
emptyMap
(
)
.
withMutations
(
function
(
map
)
{
var
iter
=
KeyedIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
k
)
{
return
map
.
set
(
k
v
)
}
)
;
}
)
;
}
Map
.
of
=
function
(
)
{
var
keyValues
=
SLICE
0
.
call
(
arguments
0
)
;
return
emptyMap
(
)
.
withMutations
(
function
(
map
)
{
for
(
var
i
=
0
;
i
<
keyValues
.
length
;
i
+
=
2
)
{
if
(
i
+
1
>
=
keyValues
.
length
)
{
throw
new
Error
(
'
Missing
value
for
key
:
'
+
keyValues
[
i
]
)
;
}
map
.
set
(
keyValues
[
i
]
keyValues
[
i
+
1
]
)
;
}
}
)
;
}
;
Map
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Map
{
'
'
}
'
)
;
}
;
Map
.
prototype
.
get
=
function
(
k
notSetValue
)
{
return
this
.
_root
?
this
.
_root
.
get
(
0
undefined
k
notSetValue
)
:
notSetValue
;
}
;
Map
.
prototype
.
set
=
function
(
k
v
)
{
return
updateMap
(
this
k
v
)
;
}
;
Map
.
prototype
.
setIn
=
function
(
keyPath
v
)
{
return
this
.
updateIn
(
keyPath
NOT_SET
function
(
)
{
return
v
}
)
;
}
;
Map
.
prototype
.
remove
=
function
(
k
)
{
return
updateMap
(
this
k
NOT_SET
)
;
}
;
Map
.
prototype
.
deleteIn
=
function
(
keyPath
)
{
return
this
.
updateIn
(
keyPath
function
(
)
{
return
NOT_SET
}
)
;
}
;
Map
.
prototype
.
update
=
function
(
k
notSetValue
updater
)
{
return
arguments
.
length
=
=
=
1
?
k
(
this
)
:
this
.
updateIn
(
[
k
]
notSetValue
updater
)
;
}
;
Map
.
prototype
.
updateIn
=
function
(
keyPath
notSetValue
updater
)
{
if
(
!
updater
)
{
updater
=
notSetValue
;
notSetValue
=
undefined
;
}
var
updatedValue
=
updateInDeepMap
(
this
forceIterator
(
keyPath
)
notSetValue
updater
)
;
return
updatedValue
=
=
=
NOT_SET
?
undefined
:
updatedValue
;
}
;
Map
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
0
;
this
.
_root
=
null
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
emptyMap
(
)
;
}
;
Map
.
prototype
.
merge
=
function
(
)
{
return
mergeIntoMapWith
(
this
undefined
arguments
)
;
}
;
Map
.
prototype
.
mergeWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoMapWith
(
this
merger
iters
)
;
}
;
Map
.
prototype
.
mergeIn
=
function
(
keyPath
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
this
.
updateIn
(
keyPath
emptyMap
(
)
function
(
m
)
{
return
typeof
m
.
merge
=
=
=
'
function
'
?
m
.
merge
.
apply
(
m
iters
)
:
iters
[
iters
.
length
-
1
]
}
)
;
}
;
Map
.
prototype
.
mergeDeep
=
function
(
)
{
return
mergeIntoMapWith
(
this
deepMerger
arguments
)
;
}
;
Map
.
prototype
.
mergeDeepWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoMapWith
(
this
deepMergerWith
(
merger
)
iters
)
;
}
;
Map
.
prototype
.
mergeDeepIn
=
function
(
keyPath
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
this
.
updateIn
(
keyPath
emptyMap
(
)
function
(
m
)
{
return
typeof
m
.
mergeDeep
=
=
=
'
function
'
?
m
.
mergeDeep
.
apply
(
m
iters
)
:
iters
[
iters
.
length
-
1
]
}
)
;
}
;
Map
.
prototype
.
sort
=
function
(
comparator
)
{
return
OrderedMap
(
sortFactory
(
this
comparator
)
)
;
}
;
Map
.
prototype
.
sortBy
=
function
(
mapper
comparator
)
{
return
OrderedMap
(
sortFactory
(
this
comparator
mapper
)
)
;
}
;
Map
.
prototype
.
withMutations
=
function
(
fn
)
{
var
mutable
=
this
.
asMutable
(
)
;
fn
(
mutable
)
;
return
mutable
.
wasAltered
(
)
?
mutable
.
__ensureOwner
(
this
.
__ownerID
)
:
this
;
}
;
Map
.
prototype
.
asMutable
=
function
(
)
{
return
this
.
__ownerID
?
this
:
this
.
__ensureOwner
(
new
OwnerID
(
)
)
;
}
;
Map
.
prototype
.
asImmutable
=
function
(
)
{
return
this
.
__ensureOwner
(
)
;
}
;
Map
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
__altered
;
}
;
Map
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
new
MapIterator
(
this
type
reverse
)
;
}
;
Map
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
this
.
_root
&
&
this
.
_root
.
iterate
(
function
(
entry
)
{
iterations
+
+
;
return
fn
(
entry
[
1
]
entry
[
0
]
this
0
)
;
}
reverse
)
;
return
iterations
;
}
;
Map
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
__altered
=
false
;
return
this
;
}
return
makeMap
(
this
.
size
this
.
_root
ownerID
this
.
__hash
)
;
}
;
function
isMap
(
maybeMap
)
{
return
!
!
(
maybeMap
&
&
maybeMap
[
IS_MAP_SENTINEL
]
)
;
}
Map
.
isMap
=
isMap
;
var
IS_MAP_SENTINEL
=
'
__IMMUTABLE_MAP__
'
;
var
MapPrototype
=
Map
.
prototype
;
MapPrototype
[
IS_MAP_SENTINEL
]
=
true
;
MapPrototype
[
DELETE
]
=
MapPrototype
.
remove
;
MapPrototype
.
removeIn
=
MapPrototype
.
deleteIn
;
function
ArrayMapNode
(
ownerID
entries
)
{
this
.
ownerID
=
ownerID
;
this
.
entries
=
entries
;
}
ArrayMapNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
var
entries
=
this
.
entries
;
for
(
var
ii
=
0
len
=
entries
.
length
;
ii
<
len
;
ii
+
+
)
{
if
(
is
(
key
entries
[
ii
]
[
0
]
)
)
{
return
entries
[
ii
]
[
1
]
;
}
}
return
notSetValue
;
}
;
ArrayMapNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
var
removed
=
value
=
=
=
NOT_SET
;
var
entries
=
this
.
entries
;
var
idx
=
0
;
for
(
var
len
=
entries
.
length
;
idx
<
len
;
idx
+
+
)
{
if
(
is
(
key
entries
[
idx
]
[
0
]
)
)
{
break
;
}
}
var
exists
=
idx
<
len
;
if
(
exists
?
entries
[
idx
]
[
1
]
=
=
=
value
:
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
(
removed
|
|
!
exists
)
&
&
SetRef
(
didChangeSize
)
;
if
(
removed
&
&
entries
.
length
=
=
=
1
)
{
return
;
}
if
(
!
exists
&
&
!
removed
&
&
entries
.
length
>
=
MAX_ARRAY_MAP_SIZE
)
{
return
createNodes
(
ownerID
entries
key
value
)
;
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newEntries
=
isEditable
?
entries
:
arrCopy
(
entries
)
;
if
(
exists
)
{
if
(
removed
)
{
idx
=
=
=
len
-
1
?
newEntries
.
pop
(
)
:
(
newEntries
[
idx
]
=
newEntries
.
pop
(
)
)
;
}
else
{
newEntries
[
idx
]
=
[
key
value
]
;
}
}
else
{
newEntries
.
push
(
[
key
value
]
)
;
}
if
(
isEditable
)
{
this
.
entries
=
newEntries
;
return
this
;
}
return
new
ArrayMapNode
(
ownerID
newEntries
)
;
}
;
function
BitmapIndexedNode
(
ownerID
bitmap
nodes
)
{
this
.
ownerID
=
ownerID
;
this
.
bitmap
=
bitmap
;
this
.
nodes
=
nodes
;
}
BitmapIndexedNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
bit
=
(
1
<
<
(
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
)
)
;
var
bitmap
=
this
.
bitmap
;
return
(
bitmap
&
bit
)
=
=
=
0
?
notSetValue
:
this
.
nodes
[
popCount
(
bitmap
&
(
bit
-
1
)
)
]
.
get
(
shift
+
SHIFT
keyHash
key
notSetValue
)
;
}
;
BitmapIndexedNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
keyHashFrag
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
bit
=
1
<
<
keyHashFrag
;
var
bitmap
=
this
.
bitmap
;
var
exists
=
(
bitmap
&
bit
)
!
=
=
0
;
if
(
!
exists
&
&
value
=
=
=
NOT_SET
)
{
return
this
;
}
var
idx
=
popCount
(
bitmap
&
(
bit
-
1
)
)
;
var
nodes
=
this
.
nodes
;
var
node
=
exists
?
nodes
[
idx
]
:
undefined
;
var
newNode
=
updateNode
(
node
ownerID
shift
+
SHIFT
keyHash
key
value
didChangeSize
didAlter
)
;
if
(
newNode
=
=
=
node
)
{
return
this
;
}
if
(
!
exists
&
&
newNode
&
&
nodes
.
length
>
=
MAX_BITMAP_INDEXED_SIZE
)
{
return
expandNodes
(
ownerID
nodes
bitmap
keyHashFrag
newNode
)
;
}
if
(
exists
&
&
!
newNode
&
&
nodes
.
length
=
=
=
2
&
&
isLeafNode
(
nodes
[
idx
^
1
]
)
)
{
return
nodes
[
idx
^
1
]
;
}
if
(
exists
&
&
newNode
&
&
nodes
.
length
=
=
=
1
&
&
isLeafNode
(
newNode
)
)
{
return
newNode
;
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newBitmap
=
exists
?
newNode
?
bitmap
:
bitmap
^
bit
:
bitmap
|
bit
;
var
newNodes
=
exists
?
newNode
?
setIn
(
nodes
idx
newNode
isEditable
)
:
spliceOut
(
nodes
idx
isEditable
)
:
spliceIn
(
nodes
idx
newNode
isEditable
)
;
if
(
isEditable
)
{
this
.
bitmap
=
newBitmap
;
this
.
nodes
=
newNodes
;
return
this
;
}
return
new
BitmapIndexedNode
(
ownerID
newBitmap
newNodes
)
;
}
;
function
HashArrayMapNode
(
ownerID
count
nodes
)
{
this
.
ownerID
=
ownerID
;
this
.
count
=
count
;
this
.
nodes
=
nodes
;
}
HashArrayMapNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
idx
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
node
=
this
.
nodes
[
idx
]
;
return
node
?
node
.
get
(
shift
+
SHIFT
keyHash
key
notSetValue
)
:
notSetValue
;
}
;
HashArrayMapNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
idx
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
removed
=
value
=
=
=
NOT_SET
;
var
nodes
=
this
.
nodes
;
var
node
=
nodes
[
idx
]
;
if
(
removed
&
&
!
node
)
{
return
this
;
}
var
newNode
=
updateNode
(
node
ownerID
shift
+
SHIFT
keyHash
key
value
didChangeSize
didAlter
)
;
if
(
newNode
=
=
=
node
)
{
return
this
;
}
var
newCount
=
this
.
count
;
if
(
!
node
)
{
newCount
+
+
;
}
else
if
(
!
newNode
)
{
newCount
-
-
;
if
(
newCount
<
MIN_HASH_ARRAY_MAP_SIZE
)
{
return
packNodes
(
ownerID
nodes
newCount
idx
)
;
}
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newNodes
=
setIn
(
nodes
idx
newNode
isEditable
)
;
if
(
isEditable
)
{
this
.
count
=
newCount
;
this
.
nodes
=
newNodes
;
return
this
;
}
return
new
HashArrayMapNode
(
ownerID
newCount
newNodes
)
;
}
;
function
HashCollisionNode
(
ownerID
keyHash
entries
)
{
this
.
ownerID
=
ownerID
;
this
.
keyHash
=
keyHash
;
this
.
entries
=
entries
;
}
HashCollisionNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
var
entries
=
this
.
entries
;
for
(
var
ii
=
0
len
=
entries
.
length
;
ii
<
len
;
ii
+
+
)
{
if
(
is
(
key
entries
[
ii
]
[
0
]
)
)
{
return
entries
[
ii
]
[
1
]
;
}
}
return
notSetValue
;
}
;
HashCollisionNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
removed
=
value
=
=
=
NOT_SET
;
if
(
keyHash
!
=
=
this
.
keyHash
)
{
if
(
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
SetRef
(
didChangeSize
)
;
return
mergeIntoNode
(
this
ownerID
shift
keyHash
[
key
value
]
)
;
}
var
entries
=
this
.
entries
;
var
idx
=
0
;
for
(
var
len
=
entries
.
length
;
idx
<
len
;
idx
+
+
)
{
if
(
is
(
key
entries
[
idx
]
[
0
]
)
)
{
break
;
}
}
var
exists
=
idx
<
len
;
if
(
exists
?
entries
[
idx
]
[
1
]
=
=
=
value
:
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
(
removed
|
|
!
exists
)
&
&
SetRef
(
didChangeSize
)
;
if
(
removed
&
&
len
=
=
=
2
)
{
return
new
ValueNode
(
ownerID
this
.
keyHash
entries
[
idx
^
1
]
)
;
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newEntries
=
isEditable
?
entries
:
arrCopy
(
entries
)
;
if
(
exists
)
{
if
(
removed
)
{
idx
=
=
=
len
-
1
?
newEntries
.
pop
(
)
:
(
newEntries
[
idx
]
=
newEntries
.
pop
(
)
)
;
}
else
{
newEntries
[
idx
]
=
[
key
value
]
;
}
}
else
{
newEntries
.
push
(
[
key
value
]
)
;
}
if
(
isEditable
)
{
this
.
entries
=
newEntries
;
return
this
;
}
return
new
HashCollisionNode
(
ownerID
this
.
keyHash
newEntries
)
;
}
;
function
ValueNode
(
ownerID
keyHash
entry
)
{
this
.
ownerID
=
ownerID
;
this
.
keyHash
=
keyHash
;
this
.
entry
=
entry
;
}
ValueNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
return
is
(
key
this
.
entry
[
0
]
)
?
this
.
entry
[
1
]
:
notSetValue
;
}
;
ValueNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
var
removed
=
value
=
=
=
NOT_SET
;
var
keyMatch
=
is
(
key
this
.
entry
[
0
]
)
;
if
(
keyMatch
?
value
=
=
=
this
.
entry
[
1
]
:
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
if
(
removed
)
{
SetRef
(
didChangeSize
)
;
return
;
}
if
(
keyMatch
)
{
if
(
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
)
{
this
.
entry
[
1
]
=
value
;
return
this
;
}
return
new
ValueNode
(
ownerID
this
.
keyHash
[
key
value
]
)
;
}
SetRef
(
didChangeSize
)
;
return
mergeIntoNode
(
this
ownerID
shift
hash
(
key
)
[
key
value
]
)
;
}
;
ArrayMapNode
.
prototype
.
iterate
=
HashCollisionNode
.
prototype
.
iterate
=
function
(
fn
reverse
)
{
var
entries
=
this
.
entries
;
for
(
var
ii
=
0
maxIndex
=
entries
.
length
-
1
;
ii
<
=
maxIndex
;
ii
+
+
)
{
if
(
fn
(
entries
[
reverse
?
maxIndex
-
ii
:
ii
]
)
=
=
=
false
)
{
return
false
;
}
}
}
BitmapIndexedNode
.
prototype
.
iterate
=
HashArrayMapNode
.
prototype
.
iterate
=
function
(
fn
reverse
)
{
var
nodes
=
this
.
nodes
;
for
(
var
ii
=
0
maxIndex
=
nodes
.
length
-
1
;
ii
<
=
maxIndex
;
ii
+
+
)
{
var
node
=
nodes
[
reverse
?
maxIndex
-
ii
:
ii
]
;
if
(
node
&
&
node
.
iterate
(
fn
reverse
)
=
=
=
false
)
{
return
false
;
}
}
}
ValueNode
.
prototype
.
iterate
=
function
(
fn
reverse
)
{
return
fn
(
this
.
entry
)
;
}
createClass
(
MapIterator
Iterator
)
;
function
MapIterator
(
map
type
reverse
)
{
this
.
_type
=
type
;
this
.
_reverse
=
reverse
;
this
.
_stack
=
map
.
_root
&
&
mapIteratorFrame
(
map
.
_root
)
;
}
MapIterator
.
prototype
.
next
=
function
(
)
{
var
type
=
this
.
_type
;
var
stack
=
this
.
_stack
;
while
(
stack
)
{
var
node
=
stack
.
node
;
var
index
=
stack
.
index
+
+
;
var
maxIndex
;
if
(
node
.
entry
)
{
if
(
index
=
=
=
0
)
{
return
mapIteratorValue
(
type
node
.
entry
)
;
}
}
else
if
(
node
.
entries
)
{
maxIndex
=
node
.
entries
.
length
-
1
;
if
(
index
<
=
maxIndex
)
{
return
mapIteratorValue
(
type
node
.
entries
[
this
.
_reverse
?
maxIndex
-
index
:
index
]
)
;
}
}
else
{
maxIndex
=
node
.
nodes
.
length
-
1
;
if
(
index
<
=
maxIndex
)
{
var
subNode
=
node
.
nodes
[
this
.
_reverse
?
maxIndex
-
index
:
index
]
;
if
(
subNode
)
{
if
(
subNode
.
entry
)
{
return
mapIteratorValue
(
type
subNode
.
entry
)
;
}
stack
=
this
.
_stack
=
mapIteratorFrame
(
subNode
stack
)
;
}
continue
;
}
}
stack
=
this
.
_stack
=
this
.
_stack
.
__prev
;
}
return
iteratorDone
(
)
;
}
;
function
mapIteratorValue
(
type
entry
)
{
return
iteratorValue
(
type
entry
[
0
]
entry
[
1
]
)
;
}
function
mapIteratorFrame
(
node
prev
)
{
return
{
node
:
node
index
:
0
__prev
:
prev
}
;
}
function
makeMap
(
size
root
ownerID
hash
)
{
var
map
=
Object
.
create
(
MapPrototype
)
;
map
.
size
=
size
;
map
.
_root
=
root
;
map
.
__ownerID
=
ownerID
;
map
.
__hash
=
hash
;
map
.
__altered
=
false
;
return
map
;
}
var
EMPTY_MAP
;
function
emptyMap
(
)
{
return
EMPTY_MAP
|
|
(
EMPTY_MAP
=
makeMap
(
0
)
)
;
}
function
updateMap
(
map
k
v
)
{
var
newRoot
;
var
newSize
;
if
(
!
map
.
_root
)
{
if
(
v
=
=
=
NOT_SET
)
{
return
map
;
}
newSize
=
1
;
newRoot
=
new
ArrayMapNode
(
map
.
__ownerID
[
[
k
v
]
]
)
;
}
else
{
var
didChangeSize
=
MakeRef
(
CHANGE_LENGTH
)
;
var
didAlter
=
MakeRef
(
DID_ALTER
)
;
newRoot
=
updateNode
(
map
.
_root
map
.
__ownerID
0
undefined
k
v
didChangeSize
didAlter
)
;
if
(
!
didAlter
.
value
)
{
return
map
;
}
newSize
=
map
.
size
+
(
didChangeSize
.
value
?
v
=
=
=
NOT_SET
?
-
1
:
1
:
0
)
;
}
if
(
map
.
__ownerID
)
{
map
.
size
=
newSize
;
map
.
_root
=
newRoot
;
map
.
__hash
=
undefined
;
map
.
__altered
=
true
;
return
map
;
}
return
newRoot
?
makeMap
(
newSize
newRoot
)
:
emptyMap
(
)
;
}
function
updateNode
(
node
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
!
node
)
{
if
(
value
=
=
=
NOT_SET
)
{
return
node
;
}
SetRef
(
didAlter
)
;
SetRef
(
didChangeSize
)
;
return
new
ValueNode
(
ownerID
keyHash
[
key
value
]
)
;
}
return
node
.
update
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
;
}
function
isLeafNode
(
node
)
{
return
node
.
constructor
=
=
=
ValueNode
|
|
node
.
constructor
=
=
=
HashCollisionNode
;
}
function
mergeIntoNode
(
node
ownerID
shift
keyHash
entry
)
{
if
(
node
.
keyHash
=
=
=
keyHash
)
{
return
new
HashCollisionNode
(
ownerID
keyHash
[
node
.
entry
entry
]
)
;
}
var
idx1
=
(
shift
=
=
=
0
?
node
.
keyHash
:
node
.
keyHash
>
>
>
shift
)
&
MASK
;
var
idx2
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
newNode
;
var
nodes
=
idx1
=
=
=
idx2
?
[
mergeIntoNode
(
node
ownerID
shift
+
SHIFT
keyHash
entry
)
]
:
(
(
newNode
=
new
ValueNode
(
ownerID
keyHash
entry
)
)
idx1
<
idx2
?
[
node
newNode
]
:
[
newNode
node
]
)
;
return
new
BitmapIndexedNode
(
ownerID
(
1
<
<
idx1
)
|
(
1
<
<
idx2
)
nodes
)
;
}
function
createNodes
(
ownerID
entries
key
value
)
{
if
(
!
ownerID
)
{
ownerID
=
new
OwnerID
(
)
;
}
var
node
=
new
ValueNode
(
ownerID
hash
(
key
)
[
key
value
]
)
;
for
(
var
ii
=
0
;
ii
<
entries
.
length
;
ii
+
+
)
{
var
entry
=
entries
[
ii
]
;
node
=
node
.
update
(
ownerID
0
undefined
entry
[
0
]
entry
[
1
]
)
;
}
return
node
;
}
function
packNodes
(
ownerID
nodes
count
excluding
)
{
var
bitmap
=
0
;
var
packedII
=
0
;
var
packedNodes
=
new
Array
(
count
)
;
for
(
var
ii
=
0
bit
=
1
len
=
nodes
.
length
;
ii
<
len
;
ii
+
+
bit
<
<
=
1
)
{
var
node
=
nodes
[
ii
]
;
if
(
node
!
=
=
undefined
&
&
ii
!
=
=
excluding
)
{
bitmap
|
=
bit
;
packedNodes
[
packedII
+
+
]
=
node
;
}
}
return
new
BitmapIndexedNode
(
ownerID
bitmap
packedNodes
)
;
}
function
expandNodes
(
ownerID
nodes
bitmap
including
node
)
{
var
count
=
0
;
var
expandedNodes
=
new
Array
(
SIZE
)
;
for
(
var
ii
=
0
;
bitmap
!
=
=
0
;
ii
+
+
bitmap
>
>
>
=
1
)
{
expandedNodes
[
ii
]
=
bitmap
&
1
?
nodes
[
count
+
+
]
:
undefined
;
}
expandedNodes
[
including
]
=
node
;
return
new
HashArrayMapNode
(
ownerID
count
+
1
expandedNodes
)
;
}
function
mergeIntoMapWith
(
map
merger
iterables
)
{
var
iters
=
[
]
;
for
(
var
ii
=
0
;
ii
<
iterables
.
length
;
ii
+
+
)
{
var
value
=
iterables
[
ii
]
;
var
iter
=
KeyedIterable
(
value
)
;
if
(
!
isIterable
(
value
)
)
{
iter
=
iter
.
map
(
function
(
v
)
{
return
fromJS
(
v
)
}
)
;
}
iters
.
push
(
iter
)
;
}
return
mergeIntoCollectionWith
(
map
merger
iters
)
;
}
function
deepMerger
(
existing
value
key
)
{
return
existing
&
&
existing
.
mergeDeep
&
&
isIterable
(
value
)
?
existing
.
mergeDeep
(
value
)
:
is
(
existing
value
)
?
existing
:
value
;
}
function
deepMergerWith
(
merger
)
{
return
function
(
existing
value
key
)
{
if
(
existing
&
&
existing
.
mergeDeepWith
&
&
isIterable
(
value
)
)
{
return
existing
.
mergeDeepWith
(
merger
value
)
;
}
var
nextValue
=
merger
(
existing
value
key
)
;
return
is
(
existing
nextValue
)
?
existing
:
nextValue
;
}
;
}
function
mergeIntoCollectionWith
(
collection
merger
iters
)
{
iters
=
iters
.
filter
(
function
(
x
)
{
return
x
.
size
!
=
=
0
}
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
collection
;
}
if
(
collection
.
size
=
=
=
0
&
&
!
collection
.
__ownerID
&
&
iters
.
length
=
=
=
1
)
{
return
collection
.
constructor
(
iters
[
0
]
)
;
}
return
collection
.
withMutations
(
function
(
collection
)
{
var
mergeIntoMap
=
merger
?
function
(
value
key
)
{
collection
.
update
(
key
NOT_SET
function
(
existing
)
{
return
existing
=
=
=
NOT_SET
?
value
:
merger
(
existing
value
key
)
}
)
;
}
:
function
(
value
key
)
{
collection
.
set
(
key
value
)
;
}
for
(
var
ii
=
0
;
ii
<
iters
.
length
;
ii
+
+
)
{
iters
[
ii
]
.
forEach
(
mergeIntoMap
)
;
}
}
)
;
}
function
updateInDeepMap
(
existing
keyPathIter
notSetValue
updater
)
{
var
isNotSet
=
existing
=
=
=
NOT_SET
;
var
step
=
keyPathIter
.
next
(
)
;
if
(
step
.
done
)
{
var
existingValue
=
isNotSet
?
notSetValue
:
existing
;
var
newValue
=
updater
(
existingValue
)
;
return
newValue
=
=
=
existingValue
?
existing
:
newValue
;
}
invariant
(
isNotSet
|
|
(
existing
&
&
existing
.
set
)
'
invalid
keyPath
'
)
;
var
key
=
step
.
value
;
var
nextExisting
=
isNotSet
?
NOT_SET
:
existing
.
get
(
key
NOT_SET
)
;
var
nextUpdated
=
updateInDeepMap
(
nextExisting
keyPathIter
notSetValue
updater
)
;
return
nextUpdated
=
=
=
nextExisting
?
existing
:
nextUpdated
=
=
=
NOT_SET
?
existing
.
remove
(
key
)
:
(
isNotSet
?
emptyMap
(
)
:
existing
)
.
set
(
key
nextUpdated
)
;
}
function
popCount
(
x
)
{
x
=
x
-
(
(
x
>
>
1
)
&
0x55555555
)
;
x
=
(
x
&
0x33333333
)
+
(
(
x
>
>
2
)
&
0x33333333
)
;
x
=
(
x
+
(
x
>
>
4
)
)
&
0x0f0f0f0f
;
x
=
x
+
(
x
>
>
8
)
;
x
=
x
+
(
x
>
>
16
)
;
return
x
&
0x7f
;
}
function
setIn
(
array
idx
val
canEdit
)
{
var
newArray
=
canEdit
?
array
:
arrCopy
(
array
)
;
newArray
[
idx
]
=
val
;
return
newArray
;
}
function
spliceIn
(
array
idx
val
canEdit
)
{
var
newLen
=
array
.
length
+
1
;
if
(
canEdit
&
&
idx
+
1
=
=
=
newLen
)
{
array
[
idx
]
=
val
;
return
array
;
}
var
newArray
=
new
Array
(
newLen
)
;
var
after
=
0
;
for
(
var
ii
=
0
;
ii
<
newLen
;
ii
+
+
)
{
if
(
ii
=
=
=
idx
)
{
newArray
[
ii
]
=
val
;
after
=
-
1
;
}
else
{
newArray
[
ii
]
=
array
[
ii
+
after
]
;
}
}
return
newArray
;
}
function
spliceOut
(
array
idx
canEdit
)
{
var
newLen
=
array
.
length
-
1
;
if
(
canEdit
&
&
idx
=
=
=
newLen
)
{
array
.
pop
(
)
;
return
array
;
}
var
newArray
=
new
Array
(
newLen
)
;
var
after
=
0
;
for
(
var
ii
=
0
;
ii
<
newLen
;
ii
+
+
)
{
if
(
ii
=
=
=
idx
)
{
after
=
1
;
}
newArray
[
ii
]
=
array
[
ii
+
after
]
;
}
return
newArray
;
}
var
MAX_ARRAY_MAP_SIZE
=
SIZE
/
4
;
var
MAX_BITMAP_INDEXED_SIZE
=
SIZE
/
2
;
var
MIN_HASH_ARRAY_MAP_SIZE
=
SIZE
/
4
;
createClass
(
List
IndexedCollection
)
;
function
List
(
value
)
{
var
empty
=
emptyList
(
)
;
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
empty
;
}
if
(
isList
(
value
)
)
{
return
value
;
}
var
iter
=
IndexedIterable
(
value
)
;
var
size
=
iter
.
size
;
if
(
size
=
=
=
0
)
{
return
empty
;
}
assertNotInfinite
(
size
)
;
if
(
size
>
0
&
&
size
<
SIZE
)
{
return
makeList
(
0
size
SHIFT
null
new
VNode
(
iter
.
toArray
(
)
)
)
;
}
return
empty
.
withMutations
(
function
(
list
)
{
list
.
setSize
(
size
)
;
iter
.
forEach
(
function
(
v
i
)
{
return
list
.
set
(
i
v
)
}
)
;
}
)
;
}
List
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
List
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
List
[
'
'
]
'
)
;
}
;
List
.
prototype
.
get
=
function
(
index
notSetValue
)
{
index
=
wrapIndex
(
this
index
)
;
if
(
index
>
=
0
&
&
index
<
this
.
size
)
{
index
+
=
this
.
_origin
;
var
node
=
listNodeFor
(
this
index
)
;
return
node
&
&
node
.
array
[
index
&
MASK
]
;
}
return
notSetValue
;
}
;
List
.
prototype
.
set
=
function
(
index
value
)
{
return
updateList
(
this
index
value
)
;
}
;
List
.
prototype
.
remove
=
function
(
index
)
{
return
!
this
.
has
(
index
)
?
this
:
index
=
=
=
0
?
this
.
shift
(
)
:
index
=
=
=
this
.
size
-
1
?
this
.
pop
(
)
:
this
.
splice
(
index
1
)
;
}
;
List
.
prototype
.
insert
=
function
(
index
value
)
{
return
this
.
splice
(
index
0
value
)
;
}
;
List
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
this
.
_origin
=
this
.
_capacity
=
0
;
this
.
_level
=
SHIFT
;
this
.
_root
=
this
.
_tail
=
null
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
emptyList
(
)
;
}
;
List
.
prototype
.
push
=
function
(
)
{
var
values
=
arguments
;
var
oldSize
=
this
.
size
;
return
this
.
withMutations
(
function
(
list
)
{
setListBounds
(
list
0
oldSize
+
values
.
length
)
;
for
(
var
ii
=
0
;
ii
<
values
.
length
;
ii
+
+
)
{
list
.
set
(
oldSize
+
ii
values
[
ii
]
)
;
}
}
)
;
}
;
List
.
prototype
.
pop
=
function
(
)
{
return
setListBounds
(
this
0
-
1
)
;
}
;
List
.
prototype
.
unshift
=
function
(
)
{
var
values
=
arguments
;
return
this
.
withMutations
(
function
(
list
)
{
setListBounds
(
list
-
values
.
length
)
;
for
(
var
ii
=
0
;
ii
<
values
.
length
;
ii
+
+
)
{
list
.
set
(
ii
values
[
ii
]
)
;
}
}
)
;
}
;
List
.
prototype
.
shift
=
function
(
)
{
return
setListBounds
(
this
1
)
;
}
;
List
.
prototype
.
merge
=
function
(
)
{
return
mergeIntoListWith
(
this
undefined
arguments
)
;
}
;
List
.
prototype
.
mergeWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoListWith
(
this
merger
iters
)
;
}
;
List
.
prototype
.
mergeDeep
=
function
(
)
{
return
mergeIntoListWith
(
this
deepMerger
arguments
)
;
}
;
List
.
prototype
.
mergeDeepWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoListWith
(
this
deepMergerWith
(
merger
)
iters
)
;
}
;
List
.
prototype
.
setSize
=
function
(
size
)
{
return
setListBounds
(
this
0
size
)
;
}
;
List
.
prototype
.
slice
=
function
(
begin
end
)
{
var
size
=
this
.
size
;
if
(
wholeSlice
(
begin
end
size
)
)
{
return
this
;
}
return
setListBounds
(
this
resolveBegin
(
begin
size
)
resolveEnd
(
end
size
)
)
;
}
;
List
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
index
=
0
;
var
values
=
iterateList
(
this
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
value
=
values
(
)
;
return
value
=
=
=
DONE
?
iteratorDone
(
)
:
iteratorValue
(
type
index
+
+
value
)
;
}
)
;
}
;
List
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
index
=
0
;
var
values
=
iterateList
(
this
reverse
)
;
var
value
;
while
(
(
value
=
values
(
)
)
!
=
=
DONE
)
{
if
(
fn
(
value
index
+
+
this
)
=
=
=
false
)
{
break
;
}
}
return
index
;
}
;
List
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
return
this
;
}
return
makeList
(
this
.
_origin
this
.
_capacity
this
.
_level
this
.
_root
this
.
_tail
ownerID
this
.
__hash
)
;
}
;
function
isList
(
maybeList
)
{
return
!
!
(
maybeList
&
&
maybeList
[
IS_LIST_SENTINEL
]
)
;
}
List
.
isList
=
isList
;
var
IS_LIST_SENTINEL
=
'
__IMMUTABLE_LIST__
'
;
var
ListPrototype
=
List
.
prototype
;
ListPrototype
[
IS_LIST_SENTINEL
]
=
true
;
ListPrototype
[
DELETE
]
=
ListPrototype
.
remove
;
ListPrototype
.
setIn
=
MapPrototype
.
setIn
;
ListPrototype
.
deleteIn
=
ListPrototype
.
removeIn
=
MapPrototype
.
removeIn
;
ListPrototype
.
update
=
MapPrototype
.
update
;
ListPrototype
.
updateIn
=
MapPrototype
.
updateIn
;
ListPrototype
.
mergeIn
=
MapPrototype
.
mergeIn
;
ListPrototype
.
mergeDeepIn
=
MapPrototype
.
mergeDeepIn
;
ListPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
ListPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
ListPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
ListPrototype
.
wasAltered
=
MapPrototype
.
wasAltered
;
function
VNode
(
array
ownerID
)
{
this
.
array
=
array
;
this
.
ownerID
=
ownerID
;
}
VNode
.
prototype
.
removeBefore
=
function
(
ownerID
level
index
)
{
if
(
index
=
=
=
level
?
1
<
<
level
:
0
|
|
this
.
array
.
length
=
=
=
0
)
{
return
this
;
}
var
originIndex
=
(
index
>
>
>
level
)
&
MASK
;
if
(
originIndex
>
=
this
.
array
.
length
)
{
return
new
VNode
(
[
]
ownerID
)
;
}
var
removingFirst
=
originIndex
=
=
=
0
;
var
newChild
;
if
(
level
>
0
)
{
var
oldChild
=
this
.
array
[
originIndex
]
;
newChild
=
oldChild
&
&
oldChild
.
removeBefore
(
ownerID
level
-
SHIFT
index
)
;
if
(
newChild
=
=
=
oldChild
&
&
removingFirst
)
{
return
this
;
}
}
if
(
removingFirst
&
&
!
newChild
)
{
return
this
;
}
var
editable
=
editableVNode
(
this
ownerID
)
;
if
(
!
removingFirst
)
{
for
(
var
ii
=
0
;
ii
<
originIndex
;
ii
+
+
)
{
editable
.
array
[
ii
]
=
undefined
;
}
}
if
(
newChild
)
{
editable
.
array
[
originIndex
]
=
newChild
;
}
return
editable
;
}
;
VNode
.
prototype
.
removeAfter
=
function
(
ownerID
level
index
)
{
if
(
index
=
=
=
(
level
?
1
<
<
level
:
0
)
|
|
this
.
array
.
length
=
=
=
0
)
{
return
this
;
}
var
sizeIndex
=
(
(
index
-
1
)
>
>
>
level
)
&
MASK
;
if
(
sizeIndex
>
=
this
.
array
.
length
)
{
return
this
;
}
var
newChild
;
if
(
level
>
0
)
{
var
oldChild
=
this
.
array
[
sizeIndex
]
;
newChild
=
oldChild
&
&
oldChild
.
removeAfter
(
ownerID
level
-
SHIFT
index
)
;
if
(
newChild
=
=
=
oldChild
&
&
sizeIndex
=
=
=
this
.
array
.
length
-
1
)
{
return
this
;
}
}
var
editable
=
editableVNode
(
this
ownerID
)
;
editable
.
array
.
splice
(
sizeIndex
+
1
)
;
if
(
newChild
)
{
editable
.
array
[
sizeIndex
]
=
newChild
;
}
return
editable
;
}
;
var
DONE
=
{
}
;
function
iterateList
(
list
reverse
)
{
var
left
=
list
.
_origin
;
var
right
=
list
.
_capacity
;
var
tailPos
=
getTailOffset
(
right
)
;
var
tail
=
list
.
_tail
;
return
iterateNodeOrLeaf
(
list
.
_root
list
.
_level
0
)
;
function
iterateNodeOrLeaf
(
node
level
offset
)
{
return
level
=
=
=
0
?
iterateLeaf
(
node
offset
)
:
iterateNode
(
node
level
offset
)
;
}
function
iterateLeaf
(
node
offset
)
{
var
array
=
offset
=
=
=
tailPos
?
tail
&
&
tail
.
array
:
node
&
&
node
.
array
;
var
from
=
offset
>
left
?
0
:
left
-
offset
;
var
to
=
right
-
offset
;
if
(
to
>
SIZE
)
{
to
=
SIZE
;
}
return
function
(
)
{
if
(
from
=
=
=
to
)
{
return
DONE
;
}
var
idx
=
reverse
?
-
-
to
:
from
+
+
;
return
array
&
&
array
[
idx
]
;
}
;
}
function
iterateNode
(
node
level
offset
)
{
var
values
;
var
array
=
node
&
&
node
.
array
;
var
from
=
offset
>
left
?
0
:
(
left
-
offset
)
>
>
level
;
var
to
=
(
(
right
-
offset
)
>
>
level
)
+
1
;
if
(
to
>
SIZE
)
{
to
=
SIZE
;
}
return
function
(
)
{
do
{
if
(
values
)
{
var
value
=
values
(
)
;
if
(
value
!
=
=
DONE
)
{
return
value
;
}
values
=
null
;
}
if
(
from
=
=
=
to
)
{
return
DONE
;
}
var
idx
=
reverse
?
-
-
to
:
from
+
+
;
values
=
iterateNodeOrLeaf
(
array
&
&
array
[
idx
]
level
-
SHIFT
offset
+
(
idx
<
<
level
)
)
;
}
while
(
true
)
;
}
;
}
}
function
makeList
(
origin
capacity
level
root
tail
ownerID
hash
)
{
var
list
=
Object
.
create
(
ListPrototype
)
;
list
.
size
=
capacity
-
origin
;
list
.
_origin
=
origin
;
list
.
_capacity
=
capacity
;
list
.
_level
=
level
;
list
.
_root
=
root
;
list
.
_tail
=
tail
;
list
.
__ownerID
=
ownerID
;
list
.
__hash
=
hash
;
list
.
__altered
=
false
;
return
list
;
}
var
EMPTY_LIST
;
function
emptyList
(
)
{
return
EMPTY_LIST
|
|
(
EMPTY_LIST
=
makeList
(
0
0
SHIFT
)
)
;
}
function
updateList
(
list
index
value
)
{
index
=
wrapIndex
(
list
index
)
;
if
(
index
!
=
=
index
)
{
return
list
;
}
if
(
index
>
=
list
.
size
|
|
index
<
0
)
{
return
list
.
withMutations
(
function
(
list
)
{
index
<
0
?
setListBounds
(
list
index
)
.
set
(
0
value
)
:
setListBounds
(
list
0
index
+
1
)
.
set
(
index
value
)
}
)
;
}
index
+
=
list
.
_origin
;
var
newTail
=
list
.
_tail
;
var
newRoot
=
list
.
_root
;
var
didAlter
=
MakeRef
(
DID_ALTER
)
;
if
(
index
>
=
getTailOffset
(
list
.
_capacity
)
)
{
newTail
=
updateVNode
(
newTail
list
.
__ownerID
0
index
value
didAlter
)
;
}
else
{
newRoot
=
updateVNode
(
newRoot
list
.
__ownerID
list
.
_level
index
value
didAlter
)
;
}
if
(
!
didAlter
.
value
)
{
return
list
;
}
if
(
list
.
__ownerID
)
{
list
.
_root
=
newRoot
;
list
.
_tail
=
newTail
;
list
.
__hash
=
undefined
;
list
.
__altered
=
true
;
return
list
;
}
return
makeList
(
list
.
_origin
list
.
_capacity
list
.
_level
newRoot
newTail
)
;
}
function
updateVNode
(
node
ownerID
level
index
value
didAlter
)
{
var
idx
=
(
index
>
>
>
level
)
&
MASK
;
var
nodeHas
=
node
&
&
idx
<
node
.
array
.
length
;
if
(
!
nodeHas
&
&
value
=
=
=
undefined
)
{
return
node
;
}
var
newNode
;
if
(
level
>
0
)
{
var
lowerNode
=
node
&
&
node
.
array
[
idx
]
;
var
newLowerNode
=
updateVNode
(
lowerNode
ownerID
level
-
SHIFT
index
value
didAlter
)
;
if
(
newLowerNode
=
=
=
lowerNode
)
{
return
node
;
}
newNode
=
editableVNode
(
node
ownerID
)
;
newNode
.
array
[
idx
]
=
newLowerNode
;
return
newNode
;
}
if
(
nodeHas
&
&
node
.
array
[
idx
]
=
=
=
value
)
{
return
node
;
}
SetRef
(
didAlter
)
;
newNode
=
editableVNode
(
node
ownerID
)
;
if
(
value
=
=
=
undefined
&
&
idx
=
=
=
newNode
.
array
.
length
-
1
)
{
newNode
.
array
.
pop
(
)
;
}
else
{
newNode
.
array
[
idx
]
=
value
;
}
return
newNode
;
}
function
editableVNode
(
node
ownerID
)
{
if
(
ownerID
&
&
node
&
&
ownerID
=
=
=
node
.
ownerID
)
{
return
node
;
}
return
new
VNode
(
node
?
node
.
array
.
slice
(
)
:
[
]
ownerID
)
;
}
function
listNodeFor
(
list
rawIndex
)
{
if
(
rawIndex
>
=
getTailOffset
(
list
.
_capacity
)
)
{
return
list
.
_tail
;
}
if
(
rawIndex
<
1
<
<
(
list
.
_level
+
SHIFT
)
)
{
var
node
=
list
.
_root
;
var
level
=
list
.
_level
;
while
(
node
&
&
level
>
0
)
{
node
=
node
.
array
[
(
rawIndex
>
>
>
level
)
&
MASK
]
;
level
-
=
SHIFT
;
}
return
node
;
}
}
function
setListBounds
(
list
begin
end
)
{
if
(
begin
!
=
=
undefined
)
{
begin
=
begin
|
0
;
}
if
(
end
!
=
=
undefined
)
{
end
=
end
|
0
;
}
var
owner
=
list
.
__ownerID
|
|
new
OwnerID
(
)
;
var
oldOrigin
=
list
.
_origin
;
var
oldCapacity
=
list
.
_capacity
;
var
newOrigin
=
oldOrigin
+
begin
;
var
newCapacity
=
end
=
=
=
undefined
?
oldCapacity
:
end
<
0
?
oldCapacity
+
end
:
oldOrigin
+
end
;
if
(
newOrigin
=
=
=
oldOrigin
&
&
newCapacity
=
=
=
oldCapacity
)
{
return
list
;
}
if
(
newOrigin
>
=
newCapacity
)
{
return
list
.
clear
(
)
;
}
var
newLevel
=
list
.
_level
;
var
newRoot
=
list
.
_root
;
var
offsetShift
=
0
;
while
(
newOrigin
+
offsetShift
<
0
)
{
newRoot
=
new
VNode
(
newRoot
&
&
newRoot
.
array
.
length
?
[
undefined
newRoot
]
:
[
]
owner
)
;
newLevel
+
=
SHIFT
;
offsetShift
+
=
1
<
<
newLevel
;
}
if
(
offsetShift
)
{
newOrigin
+
=
offsetShift
;
oldOrigin
+
=
offsetShift
;
newCapacity
+
=
offsetShift
;
oldCapacity
+
=
offsetShift
;
}
var
oldTailOffset
=
getTailOffset
(
oldCapacity
)
;
var
newTailOffset
=
getTailOffset
(
newCapacity
)
;
while
(
newTailOffset
>
=
1
<
<
(
newLevel
+
SHIFT
)
)
{
newRoot
=
new
VNode
(
newRoot
&
&
newRoot
.
array
.
length
?
[
newRoot
]
:
[
]
owner
)
;
newLevel
+
=
SHIFT
;
}
var
oldTail
=
list
.
_tail
;
var
newTail
=
newTailOffset
<
oldTailOffset
?
listNodeFor
(
list
newCapacity
-
1
)
:
newTailOffset
>
oldTailOffset
?
new
VNode
(
[
]
owner
)
:
oldTail
;
if
(
oldTail
&
&
newTailOffset
>
oldTailOffset
&
&
newOrigin
<
oldCapacity
&
&
oldTail
.
array
.
length
)
{
newRoot
=
editableVNode
(
newRoot
owner
)
;
var
node
=
newRoot
;
for
(
var
level
=
newLevel
;
level
>
SHIFT
;
level
-
=
SHIFT
)
{
var
idx
=
(
oldTailOffset
>
>
>
level
)
&
MASK
;
node
=
node
.
array
[
idx
]
=
editableVNode
(
node
.
array
[
idx
]
owner
)
;
}
node
.
array
[
(
oldTailOffset
>
>
>
SHIFT
)
&
MASK
]
=
oldTail
;
}
if
(
newCapacity
<
oldCapacity
)
{
newTail
=
newTail
&
&
newTail
.
removeAfter
(
owner
0
newCapacity
)
;
}
if
(
newOrigin
>
=
newTailOffset
)
{
newOrigin
-
=
newTailOffset
;
newCapacity
-
=
newTailOffset
;
newLevel
=
SHIFT
;
newRoot
=
null
;
newTail
=
newTail
&
&
newTail
.
removeBefore
(
owner
0
newOrigin
)
;
}
else
if
(
newOrigin
>
oldOrigin
|
|
newTailOffset
<
oldTailOffset
)
{
offsetShift
=
0
;
while
(
newRoot
)
{
var
beginIndex
=
(
newOrigin
>
>
>
newLevel
)
&
MASK
;
if
(
beginIndex
!
=
=
(
newTailOffset
>
>
>
newLevel
)
&
MASK
)
{
break
;
}
if
(
beginIndex
)
{
offsetShift
+
=
(
1
<
<
newLevel
)
*
beginIndex
;
}
newLevel
-
=
SHIFT
;
newRoot
=
newRoot
.
array
[
beginIndex
]
;
}
if
(
newRoot
&
&
newOrigin
>
oldOrigin
)
{
newRoot
=
newRoot
.
removeBefore
(
owner
newLevel
newOrigin
-
offsetShift
)
;
}
if
(
newRoot
&
&
newTailOffset
<
oldTailOffset
)
{
newRoot
=
newRoot
.
removeAfter
(
owner
newLevel
newTailOffset
-
offsetShift
)
;
}
if
(
offsetShift
)
{
newOrigin
-
=
offsetShift
;
newCapacity
-
=
offsetShift
;
}
}
if
(
list
.
__ownerID
)
{
list
.
size
=
newCapacity
-
newOrigin
;
list
.
_origin
=
newOrigin
;
list
.
_capacity
=
newCapacity
;
list
.
_level
=
newLevel
;
list
.
_root
=
newRoot
;
list
.
_tail
=
newTail
;
list
.
__hash
=
undefined
;
list
.
__altered
=
true
;
return
list
;
}
return
makeList
(
newOrigin
newCapacity
newLevel
newRoot
newTail
)
;
}
function
mergeIntoListWith
(
list
merger
iterables
)
{
var
iters
=
[
]
;
var
maxSize
=
0
;
for
(
var
ii
=
0
;
ii
<
iterables
.
length
;
ii
+
+
)
{
var
value
=
iterables
[
ii
]
;
var
iter
=
IndexedIterable
(
value
)
;
if
(
iter
.
size
>
maxSize
)
{
maxSize
=
iter
.
size
;
}
if
(
!
isIterable
(
value
)
)
{
iter
=
iter
.
map
(
function
(
v
)
{
return
fromJS
(
v
)
}
)
;
}
iters
.
push
(
iter
)
;
}
if
(
maxSize
>
list
.
size
)
{
list
=
list
.
setSize
(
maxSize
)
;
}
return
mergeIntoCollectionWith
(
list
merger
iters
)
;
}
function
getTailOffset
(
size
)
{
return
size
<
SIZE
?
0
:
(
(
(
size
-
1
)
>
>
>
SHIFT
)
<
<
SHIFT
)
;
}
createClass
(
OrderedMap
Map
)
;
function
OrderedMap
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyOrderedMap
(
)
:
isOrderedMap
(
value
)
?
value
:
emptyOrderedMap
(
)
.
withMutations
(
function
(
map
)
{
var
iter
=
KeyedIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
k
)
{
return
map
.
set
(
k
v
)
}
)
;
}
)
;
}
OrderedMap
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
OrderedMap
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
OrderedMap
{
'
'
}
'
)
;
}
;
OrderedMap
.
prototype
.
get
=
function
(
k
notSetValue
)
{
var
index
=
this
.
_map
.
get
(
k
)
;
return
index
!
=
=
undefined
?
this
.
_list
.
get
(
index
)
[
1
]
:
notSetValue
;
}
;
OrderedMap
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
0
;
this
.
_map
.
clear
(
)
;
this
.
_list
.
clear
(
)
;
return
this
;
}
return
emptyOrderedMap
(
)
;
}
;
OrderedMap
.
prototype
.
set
=
function
(
k
v
)
{
return
updateOrderedMap
(
this
k
v
)
;
}
;
OrderedMap
.
prototype
.
remove
=
function
(
k
)
{
return
updateOrderedMap
(
this
k
NOT_SET
)
;
}
;
OrderedMap
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
_map
.
wasAltered
(
)
|
|
this
.
_list
.
wasAltered
(
)
;
}
;
OrderedMap
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_list
.
__iterate
(
function
(
entry
)
{
return
entry
&
&
fn
(
entry
[
1
]
entry
[
0
]
this
0
)
}
reverse
)
;
}
;
OrderedMap
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
this
.
_list
.
fromEntrySeq
(
)
.
__iterator
(
type
reverse
)
;
}
;
OrderedMap
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
var
newMap
=
this
.
_map
.
__ensureOwner
(
ownerID
)
;
var
newList
=
this
.
_list
.
__ensureOwner
(
ownerID
)
;
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
_map
=
newMap
;
this
.
_list
=
newList
;
return
this
;
}
return
makeOrderedMap
(
newMap
newList
ownerID
this
.
__hash
)
;
}
;
function
isOrderedMap
(
maybeOrderedMap
)
{
return
isMap
(
maybeOrderedMap
)
&
&
isOrdered
(
maybeOrderedMap
)
;
}
OrderedMap
.
isOrderedMap
=
isOrderedMap
;
OrderedMap
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
OrderedMap
.
prototype
[
DELETE
]
=
OrderedMap
.
prototype
.
remove
;
function
makeOrderedMap
(
map
list
ownerID
hash
)
{
var
omap
=
Object
.
create
(
OrderedMap
.
prototype
)
;
omap
.
size
=
map
?
map
.
size
:
0
;
omap
.
_map
=
map
;
omap
.
_list
=
list
;
omap
.
__ownerID
=
ownerID
;
omap
.
__hash
=
hash
;
return
omap
;
}
var
EMPTY_ORDERED_MAP
;
function
emptyOrderedMap
(
)
{
return
EMPTY_ORDERED_MAP
|
|
(
EMPTY_ORDERED_MAP
=
makeOrderedMap
(
emptyMap
(
)
emptyList
(
)
)
)
;
}
function
updateOrderedMap
(
omap
k
v
)
{
var
map
=
omap
.
_map
;
var
list
=
omap
.
_list
;
var
i
=
map
.
get
(
k
)
;
var
has
=
i
!
=
=
undefined
;
var
newMap
;
var
newList
;
if
(
v
=
=
=
NOT_SET
)
{
if
(
!
has
)
{
return
omap
;
}
if
(
list
.
size
>
=
SIZE
&
&
list
.
size
>
=
map
.
size
*
2
)
{
newList
=
list
.
filter
(
function
(
entry
idx
)
{
return
entry
!
=
=
undefined
&
&
i
!
=
=
idx
}
)
;
newMap
=
newList
.
toKeyedSeq
(
)
.
map
(
function
(
entry
)
{
return
entry
[
0
]
}
)
.
flip
(
)
.
toMap
(
)
;
if
(
omap
.
__ownerID
)
{
newMap
.
__ownerID
=
newList
.
__ownerID
=
omap
.
__ownerID
;
}
}
else
{
newMap
=
map
.
remove
(
k
)
;
newList
=
i
=
=
=
list
.
size
-
1
?
list
.
pop
(
)
:
list
.
set
(
i
undefined
)
;
}
}
else
{
if
(
has
)
{
if
(
v
=
=
=
list
.
get
(
i
)
[
1
]
)
{
return
omap
;
}
newMap
=
map
;
newList
=
list
.
set
(
i
[
k
v
]
)
;
}
else
{
newMap
=
map
.
set
(
k
list
.
size
)
;
newList
=
list
.
set
(
list
.
size
[
k
v
]
)
;
}
}
if
(
omap
.
__ownerID
)
{
omap
.
size
=
newMap
.
size
;
omap
.
_map
=
newMap
;
omap
.
_list
=
newList
;
omap
.
__hash
=
undefined
;
return
omap
;
}
return
makeOrderedMap
(
newMap
newList
)
;
}
createClass
(
ToKeyedSequence
KeyedSeq
)
;
function
ToKeyedSequence
(
indexed
useKeys
)
{
this
.
_iter
=
indexed
;
this
.
_useKeys
=
useKeys
;
this
.
size
=
indexed
.
size
;
}
ToKeyedSequence
.
prototype
.
get
=
function
(
key
notSetValue
)
{
return
this
.
_iter
.
get
(
key
notSetValue
)
;
}
;
ToKeyedSequence
.
prototype
.
has
=
function
(
key
)
{
return
this
.
_iter
.
has
(
key
)
;
}
;
ToKeyedSequence
.
prototype
.
valueSeq
=
function
(
)
{
return
this
.
_iter
.
valueSeq
(
)
;
}
;
ToKeyedSequence
.
prototype
.
reverse
=
function
(
)
{
var
this
0
=
this
;
var
reversedSequence
=
reverseFactory
(
this
true
)
;
if
(
!
this
.
_useKeys
)
{
reversedSequence
.
valueSeq
=
function
(
)
{
return
this
0
.
_iter
.
toSeq
(
)
.
reverse
(
)
}
;
}
return
reversedSequence
;
}
;
ToKeyedSequence
.
prototype
.
map
=
function
(
mapper
context
)
{
var
this
0
=
this
;
var
mappedSequence
=
mapFactory
(
this
mapper
context
)
;
if
(
!
this
.
_useKeys
)
{
mappedSequence
.
valueSeq
=
function
(
)
{
return
this
0
.
_iter
.
toSeq
(
)
.
map
(
mapper
context
)
}
;
}
return
mappedSequence
;
}
;
ToKeyedSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
ii
;
return
this
.
_iter
.
__iterate
(
this
.
_useKeys
?
function
(
v
k
)
{
return
fn
(
v
k
this
0
)
}
:
(
(
ii
=
reverse
?
resolveSize
(
this
)
:
0
)
function
(
v
)
{
return
fn
(
v
reverse
?
-
-
ii
:
ii
+
+
this
0
)
}
)
reverse
)
;
}
;
ToKeyedSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
if
(
this
.
_useKeys
)
{
return
this
.
_iter
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
ii
=
reverse
?
resolveSize
(
this
)
:
0
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
reverse
?
-
-
ii
:
ii
+
+
step
.
value
step
)
;
}
)
;
}
;
ToKeyedSequence
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
createClass
(
ToIndexedSequence
IndexedSeq
)
;
function
ToIndexedSequence
(
iter
)
{
this
.
_iter
=
iter
;
this
.
size
=
iter
.
size
;
}
ToIndexedSequence
.
prototype
.
includes
=
function
(
value
)
{
return
this
.
_iter
.
includes
(
value
)
;
}
;
ToIndexedSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
return
this
.
_iter
.
__iterate
(
function
(
v
)
{
return
fn
(
v
iterations
+
+
this
0
)
}
reverse
)
;
}
;
ToIndexedSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
iterations
+
+
step
.
value
step
)
}
)
;
}
;
createClass
(
ToSetSequence
SetSeq
)
;
function
ToSetSequence
(
iter
)
{
this
.
_iter
=
iter
;
this
.
size
=
iter
.
size
;
}
ToSetSequence
.
prototype
.
has
=
function
(
key
)
{
return
this
.
_iter
.
includes
(
key
)
;
}
;
ToSetSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_iter
.
__iterate
(
function
(
v
)
{
return
fn
(
v
v
this
0
)
}
reverse
)
;
}
;
ToSetSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
step
.
value
step
.
value
step
)
;
}
)
;
}
;
createClass
(
FromEntriesSequence
KeyedSeq
)
;
function
FromEntriesSequence
(
entries
)
{
this
.
_iter
=
entries
;
this
.
size
=
entries
.
size
;
}
FromEntriesSequence
.
prototype
.
entrySeq
=
function
(
)
{
return
this
.
_iter
.
toSeq
(
)
;
}
;
FromEntriesSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_iter
.
__iterate
(
function
(
entry
)
{
if
(
entry
)
{
validateEntry
(
entry
)
;
var
indexedIterable
=
isIterable
(
entry
)
;
return
fn
(
indexedIterable
?
entry
.
get
(
1
)
:
entry
[
1
]
indexedIterable
?
entry
.
get
(
0
)
:
entry
[
0
]
this
0
)
;
}
}
reverse
)
;
}
;
FromEntriesSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
return
new
Iterator
(
function
(
)
{
while
(
true
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
if
(
entry
)
{
validateEntry
(
entry
)
;
var
indexedIterable
=
isIterable
(
entry
)
;
return
iteratorValue
(
type
indexedIterable
?
entry
.
get
(
0
)
:
entry
[
0
]
indexedIterable
?
entry
.
get
(
1
)
:
entry
[
1
]
step
)
;
}
}
}
)
;
}
;
ToIndexedSequence
.
prototype
.
cacheResult
=
ToKeyedSequence
.
prototype
.
cacheResult
=
ToSetSequence
.
prototype
.
cacheResult
=
FromEntriesSequence
.
prototype
.
cacheResult
=
cacheResultThrough
;
function
flipFactory
(
iterable
)
{
var
flipSequence
=
makeSequence
(
iterable
)
;
flipSequence
.
_iter
=
iterable
;
flipSequence
.
size
=
iterable
.
size
;
flipSequence
.
flip
=
function
(
)
{
return
iterable
}
;
flipSequence
.
reverse
=
function
(
)
{
var
reversedSequence
=
iterable
.
reverse
.
apply
(
this
)
;
reversedSequence
.
flip
=
function
(
)
{
return
iterable
.
reverse
(
)
}
;
return
reversedSequence
;
}
;
flipSequence
.
has
=
function
(
key
)
{
return
iterable
.
includes
(
key
)
}
;
flipSequence
.
includes
=
function
(
key
)
{
return
iterable
.
has
(
key
)
}
;
flipSequence
.
cacheResult
=
cacheResultThrough
;
flipSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
iterable
.
__iterate
(
function
(
v
k
)
{
return
fn
(
k
v
this
0
)
!
=
=
false
}
reverse
)
;
}
flipSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
type
=
=
=
ITERATE_ENTRIES
)
{
var
iterator
=
iterable
.
__iterator
(
type
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
if
(
!
step
.
done
)
{
var
k
=
step
.
value
[
0
]
;
step
.
value
[
0
]
=
step
.
value
[
1
]
;
step
.
value
[
1
]
=
k
;
}
return
step
;
}
)
;
}
return
iterable
.
__iterator
(
type
=
=
=
ITERATE_VALUES
?
ITERATE_KEYS
:
ITERATE_VALUES
reverse
)
;
}
return
flipSequence
;
}
function
mapFactory
(
iterable
mapper
context
)
{
var
mappedSequence
=
makeSequence
(
iterable
)
;
mappedSequence
.
size
=
iterable
.
size
;
mappedSequence
.
has
=
function
(
key
)
{
return
iterable
.
has
(
key
)
}
;
mappedSequence
.
get
=
function
(
key
notSetValue
)
{
var
v
=
iterable
.
get
(
key
NOT_SET
)
;
return
v
=
=
=
NOT_SET
?
notSetValue
:
mapper
.
call
(
context
v
key
iterable
)
;
}
;
mappedSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
iterable
.
__iterate
(
function
(
v
k
c
)
{
return
fn
(
mapper
.
call
(
context
v
k
c
)
k
this
0
)
!
=
=
false
}
reverse
)
;
}
mappedSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
var
key
=
entry
[
0
]
;
return
iteratorValue
(
type
key
mapper
.
call
(
context
entry
[
1
]
key
iterable
)
step
)
;
}
)
;
}
return
mappedSequence
;
}
function
reverseFactory
(
iterable
useKeys
)
{
var
reversedSequence
=
makeSequence
(
iterable
)
;
reversedSequence
.
_iter
=
iterable
;
reversedSequence
.
size
=
iterable
.
size
;
reversedSequence
.
reverse
=
function
(
)
{
return
iterable
}
;
if
(
iterable
.
flip
)
{
reversedSequence
.
flip
=
function
(
)
{
var
flipSequence
=
flipFactory
(
iterable
)
;
flipSequence
.
reverse
=
function
(
)
{
return
iterable
.
flip
(
)
}
;
return
flipSequence
;
}
;
}
reversedSequence
.
get
=
function
(
key
notSetValue
)
{
return
iterable
.
get
(
useKeys
?
key
:
-
1
-
key
notSetValue
)
}
;
reversedSequence
.
has
=
function
(
key
)
{
return
iterable
.
has
(
useKeys
?
key
:
-
1
-
key
)
}
;
reversedSequence
.
includes
=
function
(
value
)
{
return
iterable
.
includes
(
value
)
}
;
reversedSequence
.
cacheResult
=
cacheResultThrough
;
reversedSequence
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
iterable
.
__iterate
(
function
(
v
k
)
{
return
fn
(
v
k
this
0
)
}
!
reverse
)
;
}
;
reversedSequence
.
__iterator
=
function
(
type
reverse
)
{
return
iterable
.
__iterator
(
type
!
reverse
)
}
;
return
reversedSequence
;
}
function
filterFactory
(
iterable
predicate
context
useKeys
)
{
var
filterSequence
=
makeSequence
(
iterable
)
;
if
(
useKeys
)
{
filterSequence
.
has
=
function
(
key
)
{
var
v
=
iterable
.
get
(
key
NOT_SET
)
;
return
v
!
=
=
NOT_SET
&
&
!
!
predicate
.
call
(
context
v
key
iterable
)
;
}
;
filterSequence
.
get
=
function
(
key
notSetValue
)
{
var
v
=
iterable
.
get
(
key
NOT_SET
)
;
return
v
!
=
=
NOT_SET
&
&
predicate
.
call
(
context
v
key
iterable
)
?
v
:
notSetValue
;
}
;
}
filterSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
c
)
{
if
(
predicate
.
call
(
context
v
k
c
)
)
{
iterations
+
+
;
return
fn
(
v
useKeys
?
k
:
iterations
-
1
this
0
)
;
}
}
reverse
)
;
return
iterations
;
}
;
filterSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
while
(
true
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
var
key
=
entry
[
0
]
;
var
value
=
entry
[
1
]
;
if
(
predicate
.
call
(
context
value
key
iterable
)
)
{
return
iteratorValue
(
type
useKeys
?
key
:
iterations
+
+
value
step
)
;
}
}
}
)
;
}
return
filterSequence
;
}
function
countByFactory
(
iterable
grouper
context
)
{
var
groups
=
Map
(
)
.
asMutable
(
)
;
iterable
.
__iterate
(
function
(
v
k
)
{
groups
.
update
(
grouper
.
call
(
context
v
k
iterable
)
0
function
(
a
)
{
return
a
+
1
}
)
;
}
)
;
return
groups
.
asImmutable
(
)
;
}
function
groupByFactory
(
iterable
grouper
context
)
{
var
isKeyedIter
=
isKeyed
(
iterable
)
;
var
groups
=
(
isOrdered
(
iterable
)
?
OrderedMap
(
)
:
Map
(
)
)
.
asMutable
(
)
;
iterable
.
__iterate
(
function
(
v
k
)
{
groups
.
update
(
grouper
.
call
(
context
v
k
iterable
)
function
(
a
)
{
return
(
a
=
a
|
|
[
]
a
.
push
(
isKeyedIter
?
[
k
v
]
:
v
)
a
)
}
)
;
}
)
;
var
coerce
=
iterableClass
(
iterable
)
;
return
groups
.
map
(
function
(
arr
)
{
return
reify
(
iterable
coerce
(
arr
)
)
}
)
;
}
function
sliceFactory
(
iterable
begin
end
useKeys
)
{
var
originalSize
=
iterable
.
size
;
if
(
begin
!
=
=
undefined
)
{
begin
=
begin
|
0
;
}
if
(
end
!
=
=
undefined
)
{
if
(
end
=
=
=
Infinity
)
{
end
=
originalSize
;
}
else
{
end
=
end
|
0
;
}
}
if
(
wholeSlice
(
begin
end
originalSize
)
)
{
return
iterable
;
}
var
resolvedBegin
=
resolveBegin
(
begin
originalSize
)
;
var
resolvedEnd
=
resolveEnd
(
end
originalSize
)
;
if
(
resolvedBegin
!
=
=
resolvedBegin
|
|
resolvedEnd
!
=
=
resolvedEnd
)
{
return
sliceFactory
(
iterable
.
toSeq
(
)
.
cacheResult
(
)
begin
end
useKeys
)
;
}
var
resolvedSize
=
resolvedEnd
-
resolvedBegin
;
var
sliceSize
;
if
(
resolvedSize
=
=
=
resolvedSize
)
{
sliceSize
=
resolvedSize
<
0
?
0
:
resolvedSize
;
}
var
sliceSeq
=
makeSequence
(
iterable
)
;
sliceSeq
.
size
=
sliceSize
=
=
=
0
?
sliceSize
:
iterable
.
size
&
&
sliceSize
|
|
undefined
;
if
(
!
useKeys
&
&
isSeq
(
iterable
)
&
&
sliceSize
>
=
0
)
{
sliceSeq
.
get
=
function
(
index
notSetValue
)
{
index
=
wrapIndex
(
this
index
)
;
return
index
>
=
0
&
&
index
<
sliceSize
?
iterable
.
get
(
index
+
resolvedBegin
notSetValue
)
:
notSetValue
;
}
}
sliceSeq
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
if
(
sliceSize
=
=
=
0
)
{
return
0
;
}
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
skipped
=
0
;
var
isSkipping
=
true
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
)
{
if
(
!
(
isSkipping
&
&
(
isSkipping
=
skipped
+
+
<
resolvedBegin
)
)
)
{
iterations
+
+
;
return
fn
(
v
useKeys
?
k
:
iterations
-
1
this
0
)
!
=
=
false
&
&
iterations
!
=
=
sliceSize
;
}
}
)
;
return
iterations
;
}
;
sliceSeq
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
sliceSize
!
=
=
0
&
&
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
sliceSize
!
=
=
0
&
&
iterable
.
__iterator
(
type
reverse
)
;
var
skipped
=
0
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
while
(
skipped
+
+
<
resolvedBegin
)
{
iterator
.
next
(
)
;
}
if
(
+
+
iterations
>
sliceSize
)
{
return
iteratorDone
(
)
;
}
var
step
=
iterator
.
next
(
)
;
if
(
useKeys
|
|
type
=
=
=
ITERATE_VALUES
)
{
return
step
;
}
else
if
(
type
=
=
=
ITERATE_KEYS
)
{
return
iteratorValue
(
type
iterations
-
1
undefined
step
)
;
}
else
{
return
iteratorValue
(
type
iterations
-
1
step
.
value
[
1
]
step
)
;
}
}
)
;
}
return
sliceSeq
;
}
function
takeWhileFactory
(
iterable
predicate
context
)
{
var
takeSequence
=
makeSequence
(
iterable
)
;
takeSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
c
)
{
return
predicate
.
call
(
context
v
k
c
)
&
&
+
+
iterations
&
&
fn
(
v
k
this
0
)
}
)
;
return
iterations
;
}
;
takeSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
var
iterating
=
true
;
return
new
Iterator
(
function
(
)
{
if
(
!
iterating
)
{
return
iteratorDone
(
)
;
}
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
var
k
=
entry
[
0
]
;
var
v
=
entry
[
1
]
;
if
(
!
predicate
.
call
(
context
v
k
this
0
)
)
{
iterating
=
false
;
return
iteratorDone
(
)
;
}
return
type
=
=
=
ITERATE_ENTRIES
?
step
:
iteratorValue
(
type
k
v
step
)
;
}
)
;
}
;
return
takeSequence
;
}
function
skipWhileFactory
(
iterable
predicate
context
useKeys
)
{
var
skipSequence
=
makeSequence
(
iterable
)
;
skipSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
isSkipping
=
true
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
c
)
{
if
(
!
(
isSkipping
&
&
(
isSkipping
=
predicate
.
call
(
context
v
k
c
)
)
)
)
{
iterations
+
+
;
return
fn
(
v
useKeys
?
k
:
iterations
-
1
this
0
)
;
}
}
)
;
return
iterations
;
}
;
skipSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
var
skipping
=
true
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
var
step
k
v
;
do
{
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
if
(
useKeys
|
|
type
=
=
=
ITERATE_VALUES
)
{
return
step
;
}
else
if
(
type
=
=
=
ITERATE_KEYS
)
{
return
iteratorValue
(
type
iterations
+
+
undefined
step
)
;
}
else
{
return
iteratorValue
(
type
iterations
+
+
step
.
value
[
1
]
step
)
;
}
}
var
entry
=
step
.
value
;
k
=
entry
[
0
]
;
v
=
entry
[
1
]
;
skipping
&
&
(
skipping
=
predicate
.
call
(
context
v
k
this
0
)
)
;
}
while
(
skipping
)
;
return
type
=
=
=
ITERATE_ENTRIES
?
step
:
iteratorValue
(
type
k
v
step
)
;
}
)
;
}
;
return
skipSequence
;
}
function
concatFactory
(
iterable
values
)
{
var
isKeyedIterable
=
isKeyed
(
iterable
)
;
var
iters
=
[
iterable
]
.
concat
(
values
)
.
map
(
function
(
v
)
{
if
(
!
isIterable
(
v
)
)
{
v
=
isKeyedIterable
?
keyedSeqFromValue
(
v
)
:
indexedSeqFromValue
(
Array
.
isArray
(
v
)
?
v
:
[
v
]
)
;
}
else
if
(
isKeyedIterable
)
{
v
=
KeyedIterable
(
v
)
;
}
return
v
;
}
)
.
filter
(
function
(
v
)
{
return
v
.
size
!
=
=
0
}
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
iterable
;
}
if
(
iters
.
length
=
=
=
1
)
{
var
singleton
=
iters
[
0
]
;
if
(
singleton
=
=
=
iterable
|
|
isKeyedIterable
&
&
isKeyed
(
singleton
)
|
|
isIndexed
(
iterable
)
&
&
isIndexed
(
singleton
)
)
{
return
singleton
;
}
}
var
concatSeq
=
new
ArraySeq
(
iters
)
;
if
(
isKeyedIterable
)
{
concatSeq
=
concatSeq
.
toKeyedSeq
(
)
;
}
else
if
(
!
isIndexed
(
iterable
)
)
{
concatSeq
=
concatSeq
.
toSetSeq
(
)
;
}
concatSeq
=
concatSeq
.
flatten
(
true
)
;
concatSeq
.
size
=
iters
.
reduce
(
function
(
sum
seq
)
{
if
(
sum
!
=
=
undefined
)
{
var
size
=
seq
.
size
;
if
(
size
!
=
=
undefined
)
{
return
sum
+
size
;
}
}
}
0
)
;
return
concatSeq
;
}
function
flattenFactory
(
iterable
depth
useKeys
)
{
var
flatSequence
=
makeSequence
(
iterable
)
;
flatSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
iterations
=
0
;
var
stopped
=
false
;
function
flatDeep
(
iter
currentDepth
)
{
var
this
0
=
this
;
iter
.
__iterate
(
function
(
v
k
)
{
if
(
(
!
depth
|
|
currentDepth
<
depth
)
&
&
isIterable
(
v
)
)
{
flatDeep
(
v
currentDepth
+
1
)
;
}
else
if
(
fn
(
v
useKeys
?
k
:
iterations
+
+
this
0
)
=
=
=
false
)
{
stopped
=
true
;
}
return
!
stopped
;
}
reverse
)
;
}
flatDeep
(
iterable
0
)
;
return
iterations
;
}
flatSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
type
reverse
)
;
var
stack
=
[
]
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
while
(
iterator
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
!
=
=
false
)
{
iterator
=
stack
.
pop
(
)
;
continue
;
}
var
v
=
step
.
value
;
if
(
type
=
=
=
ITERATE_ENTRIES
)
{
v
=
v
[
1
]
;
}
if
(
(
!
depth
|
|
stack
.
length
<
depth
)
&
&
isIterable
(
v
)
)
{
stack
.
push
(
iterator
)
;
iterator
=
v
.
__iterator
(
type
reverse
)
;
}
else
{
return
useKeys
?
step
:
iteratorValue
(
type
iterations
+
+
v
step
)
;
}
}
return
iteratorDone
(
)
;
}
)
;
}
return
flatSequence
;
}
function
flatMapFactory
(
iterable
mapper
context
)
{
var
coerce
=
iterableClass
(
iterable
)
;
return
iterable
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
coerce
(
mapper
.
call
(
context
v
k
iterable
)
)
}
)
.
flatten
(
true
)
;
}
function
interposeFactory
(
iterable
separator
)
{
var
interposedSequence
=
makeSequence
(
iterable
)
;
interposedSequence
.
size
=
iterable
.
size
&
&
iterable
.
size
*
2
-
1
;
interposedSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
)
{
return
(
!
iterations
|
|
fn
(
separator
iterations
+
+
this
0
)
!
=
=
false
)
&
&
fn
(
v
iterations
+
+
this
0
)
!
=
=
false
}
reverse
)
;
return
iterations
;
}
;
interposedSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
iterations
=
0
;
var
step
;
return
new
Iterator
(
function
(
)
{
if
(
!
step
|
|
iterations
%
2
)
{
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
}
return
iterations
%
2
?
iteratorValue
(
type
iterations
+
+
separator
)
:
iteratorValue
(
type
iterations
+
+
step
.
value
step
)
;
}
)
;
}
;
return
interposedSequence
;
}
function
sortFactory
(
iterable
comparator
mapper
)
{
if
(
!
comparator
)
{
comparator
=
defaultComparator
;
}
var
isKeyedIterable
=
isKeyed
(
iterable
)
;
var
index
=
0
;
var
entries
=
iterable
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
[
k
v
index
+
+
mapper
?
mapper
(
v
k
iterable
)
:
v
]
}
)
.
toArray
(
)
;
entries
.
sort
(
function
(
a
b
)
{
return
comparator
(
a
[
3
]
b
[
3
]
)
|
|
a
[
2
]
-
b
[
2
]
}
)
.
forEach
(
isKeyedIterable
?
function
(
v
i
)
{
entries
[
i
]
.
length
=
2
;
}
:
function
(
v
i
)
{
entries
[
i
]
=
v
[
1
]
;
}
)
;
return
isKeyedIterable
?
KeyedSeq
(
entries
)
:
isIndexed
(
iterable
)
?
IndexedSeq
(
entries
)
:
SetSeq
(
entries
)
;
}
function
maxFactory
(
iterable
comparator
mapper
)
{
if
(
!
comparator
)
{
comparator
=
defaultComparator
;
}
if
(
mapper
)
{
var
entry
=
iterable
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
[
v
mapper
(
v
k
iterable
)
]
}
)
.
reduce
(
function
(
a
b
)
{
return
maxCompare
(
comparator
a
[
1
]
b
[
1
]
)
?
b
:
a
}
)
;
return
entry
&
&
entry
[
0
]
;
}
else
{
return
iterable
.
reduce
(
function
(
a
b
)
{
return
maxCompare
(
comparator
a
b
)
?
b
:
a
}
)
;
}
}
function
maxCompare
(
comparator
a
b
)
{
var
comp
=
comparator
(
b
a
)
;
return
(
comp
=
=
=
0
&
&
b
!
=
=
a
&
&
(
b
=
=
=
undefined
|
|
b
=
=
=
null
|
|
b
!
=
=
b
)
)
|
|
comp
>
0
;
}
function
zipWithFactory
(
keyIter
zipper
iters
)
{
var
zipSequence
=
makeSequence
(
keyIter
)
;
zipSequence
.
size
=
new
ArraySeq
(
iters
)
.
map
(
function
(
i
)
{
return
i
.
size
}
)
.
min
(
)
;
zipSequence
.
__iterate
=
function
(
fn
reverse
)
{
var
iterator
=
this
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
step
;
var
iterations
=
0
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
if
(
fn
(
step
.
value
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
}
return
iterations
;
}
;
zipSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterators
=
iters
.
map
(
function
(
i
)
{
return
(
i
=
Iterable
(
i
)
getIterator
(
reverse
?
i
.
reverse
(
)
:
i
)
)
}
)
;
var
iterations
=
0
;
var
isDone
=
false
;
return
new
Iterator
(
function
(
)
{
var
steps
;
if
(
!
isDone
)
{
steps
=
iterators
.
map
(
function
(
i
)
{
return
i
.
next
(
)
}
)
;
isDone
=
steps
.
some
(
function
(
s
)
{
return
s
.
done
}
)
;
}
if
(
isDone
)
{
return
iteratorDone
(
)
;
}
return
iteratorValue
(
type
iterations
+
+
zipper
.
apply
(
null
steps
.
map
(
function
(
s
)
{
return
s
.
value
}
)
)
)
;
}
)
;
}
;
return
zipSequence
}
function
reify
(
iter
seq
)
{
return
isSeq
(
iter
)
?
seq
:
iter
.
constructor
(
seq
)
;
}
function
validateEntry
(
entry
)
{
if
(
entry
!
=
=
Object
(
entry
)
)
{
throw
new
TypeError
(
'
Expected
[
K
V
]
tuple
:
'
+
entry
)
;
}
}
function
resolveSize
(
iter
)
{
assertNotInfinite
(
iter
.
size
)
;
return
ensureSize
(
iter
)
;
}
function
iterableClass
(
iterable
)
{
return
isKeyed
(
iterable
)
?
KeyedIterable
:
isIndexed
(
iterable
)
?
IndexedIterable
:
SetIterable
;
}
function
makeSequence
(
iterable
)
{
return
Object
.
create
(
(
isKeyed
(
iterable
)
?
KeyedSeq
:
isIndexed
(
iterable
)
?
IndexedSeq
:
SetSeq
)
.
prototype
)
;
}
function
cacheResultThrough
(
)
{
if
(
this
.
_iter
.
cacheResult
)
{
this
.
_iter
.
cacheResult
(
)
;
this
.
size
=
this
.
_iter
.
size
;
return
this
;
}
else
{
return
Seq
.
prototype
.
cacheResult
.
call
(
this
)
;
}
}
function
defaultComparator
(
a
b
)
{
return
a
>
b
?
1
:
a
<
b
?
-
1
:
0
;
}
function
forceIterator
(
keyPath
)
{
var
iter
=
getIterator
(
keyPath
)
;
if
(
!
iter
)
{
if
(
!
isArrayLike
(
keyPath
)
)
{
throw
new
TypeError
(
'
Expected
iterable
or
array
-
like
:
'
+
keyPath
)
;
}
iter
=
getIterator
(
Iterable
(
keyPath
)
)
;
}
return
iter
;
}
createClass
(
Record
KeyedCollection
)
;
function
Record
(
defaultValues
name
)
{
var
hasInitialized
;
var
RecordType
=
function
Record
(
values
)
{
if
(
values
instanceof
RecordType
)
{
return
values
;
}
if
(
!
(
this
instanceof
RecordType
)
)
{
return
new
RecordType
(
values
)
;
}
if
(
!
hasInitialized
)
{
hasInitialized
=
true
;
var
keys
=
Object
.
keys
(
defaultValues
)
;
setProps
(
RecordTypePrototype
keys
)
;
RecordTypePrototype
.
size
=
keys
.
length
;
RecordTypePrototype
.
_name
=
name
;
RecordTypePrototype
.
_keys
=
keys
;
RecordTypePrototype
.
_defaultValues
=
defaultValues
;
}
this
.
_map
=
Map
(
values
)
;
}
;
var
RecordTypePrototype
=
RecordType
.
prototype
=
Object
.
create
(
RecordPrototype
)
;
RecordTypePrototype
.
constructor
=
RecordType
;
return
RecordType
;
}
Record
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
recordName
(
this
)
+
'
{
'
'
}
'
)
;
}
;
Record
.
prototype
.
has
=
function
(
k
)
{
return
this
.
_defaultValues
.
hasOwnProperty
(
k
)
;
}
;
Record
.
prototype
.
get
=
function
(
k
notSetValue
)
{
if
(
!
this
.
has
(
k
)
)
{
return
notSetValue
;
}
var
defaultVal
=
this
.
_defaultValues
[
k
]
;
return
this
.
_map
?
this
.
_map
.
get
(
k
defaultVal
)
:
defaultVal
;
}
;
Record
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
__ownerID
)
{
this
.
_map
&
&
this
.
_map
.
clear
(
)
;
return
this
;
}
var
RecordType
=
this
.
constructor
;
return
RecordType
.
_empty
|
|
(
RecordType
.
_empty
=
makeRecord
(
this
emptyMap
(
)
)
)
;
}
;
Record
.
prototype
.
set
=
function
(
k
v
)
{
if
(
!
this
.
has
(
k
)
)
{
throw
new
Error
(
'
Cannot
set
unknown
key
"
'
+
k
+
'
"
on
'
+
recordName
(
this
)
)
;
}
if
(
this
.
_map
&
&
!
this
.
_map
.
has
(
k
)
)
{
var
defaultVal
=
this
.
_defaultValues
[
k
]
;
if
(
v
=
=
=
defaultVal
)
{
return
this
;
}
}
var
newMap
=
this
.
_map
&
&
this
.
_map
.
set
(
k
v
)
;
if
(
this
.
__ownerID
|
|
newMap
=
=
=
this
.
_map
)
{
return
this
;
}
return
makeRecord
(
this
newMap
)
;
}
;
Record
.
prototype
.
remove
=
function
(
k
)
{
if
(
!
this
.
has
(
k
)
)
{
return
this
;
}
var
newMap
=
this
.
_map
&
&
this
.
_map
.
remove
(
k
)
;
if
(
this
.
__ownerID
|
|
newMap
=
=
=
this
.
_map
)
{
return
this
;
}
return
makeRecord
(
this
newMap
)
;
}
;
Record
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
_map
.
wasAltered
(
)
;
}
;
Record
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
this
0
=
this
;
return
KeyedIterable
(
this
.
_defaultValues
)
.
map
(
function
(
_
k
)
{
return
this
0
.
get
(
k
)
}
)
.
__iterator
(
type
reverse
)
;
}
;
Record
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
KeyedIterable
(
this
.
_defaultValues
)
.
map
(
function
(
_
k
)
{
return
this
0
.
get
(
k
)
}
)
.
__iterate
(
fn
reverse
)
;
}
;
Record
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
var
newMap
=
this
.
_map
&
&
this
.
_map
.
__ensureOwner
(
ownerID
)
;
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
_map
=
newMap
;
return
this
;
}
return
makeRecord
(
this
newMap
ownerID
)
;
}
;
var
RecordPrototype
=
Record
.
prototype
;
RecordPrototype
[
DELETE
]
=
RecordPrototype
.
remove
;
RecordPrototype
.
deleteIn
=
RecordPrototype
.
removeIn
=
MapPrototype
.
removeIn
;
RecordPrototype
.
merge
=
MapPrototype
.
merge
;
RecordPrototype
.
mergeWith
=
MapPrototype
.
mergeWith
;
RecordPrototype
.
mergeIn
=
MapPrototype
.
mergeIn
;
RecordPrototype
.
mergeDeep
=
MapPrototype
.
mergeDeep
;
RecordPrototype
.
mergeDeepWith
=
MapPrototype
.
mergeDeepWith
;
RecordPrototype
.
mergeDeepIn
=
MapPrototype
.
mergeDeepIn
;
RecordPrototype
.
setIn
=
MapPrototype
.
setIn
;
RecordPrototype
.
update
=
MapPrototype
.
update
;
RecordPrototype
.
updateIn
=
MapPrototype
.
updateIn
;
RecordPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
RecordPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
RecordPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
function
makeRecord
(
likeRecord
map
ownerID
)
{
var
record
=
Object
.
create
(
Object
.
getPrototypeOf
(
likeRecord
)
)
;
record
.
_map
=
map
;
record
.
__ownerID
=
ownerID
;
return
record
;
}
function
recordName
(
record
)
{
return
record
.
_name
|
|
record
.
constructor
.
name
|
|
'
Record
'
;
}
function
setProps
(
prototype
names
)
{
try
{
names
.
forEach
(
setProp
.
bind
(
undefined
prototype
)
)
;
}
catch
(
error
)
{
}
}
function
setProp
(
prototype
name
)
{
Object
.
defineProperty
(
prototype
name
{
get
:
function
(
)
{
return
this
.
get
(
name
)
;
}
set
:
function
(
value
)
{
invariant
(
this
.
__ownerID
'
Cannot
set
on
an
immutable
record
.
'
)
;
this
.
set
(
name
value
)
;
}
}
)
;
}
createClass
(
Set
SetCollection
)
;
function
Set
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySet
(
)
:
isSet
(
value
)
&
&
!
isOrdered
(
value
)
?
value
:
emptySet
(
)
.
withMutations
(
function
(
set
)
{
var
iter
=
SetIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
)
{
return
set
.
add
(
v
)
}
)
;
}
)
;
}
Set
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
Set
.
fromKeys
=
function
(
value
)
{
return
this
(
KeyedIterable
(
value
)
.
keySeq
(
)
)
;
}
;
Set
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Set
{
'
'
}
'
)
;
}
;
Set
.
prototype
.
has
=
function
(
value
)
{
return
this
.
_map
.
has
(
value
)
;
}
;
Set
.
prototype
.
add
=
function
(
value
)
{
return
updateSet
(
this
this
.
_map
.
set
(
value
true
)
)
;
}
;
Set
.
prototype
.
remove
=
function
(
value
)
{
return
updateSet
(
this
this
.
_map
.
remove
(
value
)
)
;
}
;
Set
.
prototype
.
clear
=
function
(
)
{
return
updateSet
(
this
this
.
_map
.
clear
(
)
)
;
}
;
Set
.
prototype
.
union
=
function
(
)
{
var
iters
=
SLICE
0
.
call
(
arguments
0
)
;
iters
=
iters
.
filter
(
function
(
x
)
{
return
x
.
size
!
=
=
0
}
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
this
;
}
if
(
this
.
size
=
=
=
0
&
&
!
this
.
__ownerID
&
&
iters
.
length
=
=
=
1
)
{
return
this
.
constructor
(
iters
[
0
]
)
;
}
return
this
.
withMutations
(
function
(
set
)
{
for
(
var
ii
=
0
;
ii
<
iters
.
length
;
ii
+
+
)
{
SetIterable
(
iters
[
ii
]
)
.
forEach
(
function
(
value
)
{
return
set
.
add
(
value
)
}
)
;
}
}
)
;
}
;
Set
.
prototype
.
intersect
=
function
(
)
{
var
iters
=
SLICE
0
.
call
(
arguments
0
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
this
;
}
iters
=
iters
.
map
(
function
(
iter
)
{
return
SetIterable
(
iter
)
}
)
;
var
originalSet
=
this
;
return
this
.
withMutations
(
function
(
set
)
{
originalSet
.
forEach
(
function
(
value
)
{
if
(
!
iters
.
every
(
function
(
iter
)
{
return
iter
.
includes
(
value
)
}
)
)
{
set
.
remove
(
value
)
;
}
}
)
;
}
)
;
}
;
Set
.
prototype
.
subtract
=
function
(
)
{
var
iters
=
SLICE
0
.
call
(
arguments
0
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
this
;
}
iters
=
iters
.
map
(
function
(
iter
)
{
return
SetIterable
(
iter
)
}
)
;
var
originalSet
=
this
;
return
this
.
withMutations
(
function
(
set
)
{
originalSet
.
forEach
(
function
(
value
)
{
if
(
iters
.
some
(
function
(
iter
)
{
return
iter
.
includes
(
value
)
}
)
)
{
set
.
remove
(
value
)
;
}
}
)
;
}
)
;
}
;
Set
.
prototype
.
merge
=
function
(
)
{
return
this
.
union
.
apply
(
this
arguments
)
;
}
;
Set
.
prototype
.
mergeWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
this
.
union
.
apply
(
this
iters
)
;
}
;
Set
.
prototype
.
sort
=
function
(
comparator
)
{
return
OrderedSet
(
sortFactory
(
this
comparator
)
)
;
}
;
Set
.
prototype
.
sortBy
=
function
(
mapper
comparator
)
{
return
OrderedSet
(
sortFactory
(
this
comparator
mapper
)
)
;
}
;
Set
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
_map
.
wasAltered
(
)
;
}
;
Set
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_map
.
__iterate
(
function
(
_
k
)
{
return
fn
(
k
k
this
0
)
}
reverse
)
;
}
;
Set
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
this
.
_map
.
map
(
function
(
_
k
)
{
return
k
}
)
.
__iterator
(
type
reverse
)
;
}
;
Set
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
var
newMap
=
this
.
_map
.
__ensureOwner
(
ownerID
)
;
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
_map
=
newMap
;
return
this
;
}
return
this
.
__make
(
newMap
ownerID
)
;
}
;
function
isSet
(
maybeSet
)
{
return
!
!
(
maybeSet
&
&
maybeSet
[
IS_SET_SENTINEL
]
)
;
}
Set
.
isSet
=
isSet
;
var
IS_SET_SENTINEL
=
'
__IMMUTABLE_SET__
'
;
var
SetPrototype
=
Set
.
prototype
;
SetPrototype
[
IS_SET_SENTINEL
]
=
true
;
SetPrototype
[
DELETE
]
=
SetPrototype
.
remove
;
SetPrototype
.
mergeDeep
=
SetPrototype
.
merge
;
SetPrototype
.
mergeDeepWith
=
SetPrototype
.
mergeWith
;
SetPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
SetPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
SetPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
SetPrototype
.
__empty
=
emptySet
;
SetPrototype
.
__make
=
makeSet
;
function
updateSet
(
set
newMap
)
{
if
(
set
.
__ownerID
)
{
set
.
size
=
newMap
.
size
;
set
.
_map
=
newMap
;
return
set
;
}
return
newMap
=
=
=
set
.
_map
?
set
:
newMap
.
size
=
=
=
0
?
set
.
__empty
(
)
:
set
.
__make
(
newMap
)
;
}
function
makeSet
(
map
ownerID
)
{
var
set
=
Object
.
create
(
SetPrototype
)
;
set
.
size
=
map
?
map
.
size
:
0
;
set
.
_map
=
map
;
set
.
__ownerID
=
ownerID
;
return
set
;
}
var
EMPTY_SET
;
function
emptySet
(
)
{
return
EMPTY_SET
|
|
(
EMPTY_SET
=
makeSet
(
emptyMap
(
)
)
)
;
}
createClass
(
OrderedSet
Set
)
;
function
OrderedSet
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyOrderedSet
(
)
:
isOrderedSet
(
value
)
?
value
:
emptyOrderedSet
(
)
.
withMutations
(
function
(
set
)
{
var
iter
=
SetIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
)
{
return
set
.
add
(
v
)
}
)
;
}
)
;
}
OrderedSet
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
OrderedSet
.
fromKeys
=
function
(
value
)
{
return
this
(
KeyedIterable
(
value
)
.
keySeq
(
)
)
;
}
;
OrderedSet
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
OrderedSet
{
'
'
}
'
)
;
}
;
function
isOrderedSet
(
maybeOrderedSet
)
{
return
isSet
(
maybeOrderedSet
)
&
&
isOrdered
(
maybeOrderedSet
)
;
}
OrderedSet
.
isOrderedSet
=
isOrderedSet
;
var
OrderedSetPrototype
=
OrderedSet
.
prototype
;
OrderedSetPrototype
[
IS_ORDERED_SENTINEL
]
=
true
;
OrderedSetPrototype
.
__empty
=
emptyOrderedSet
;
OrderedSetPrototype
.
__make
=
makeOrderedSet
;
function
makeOrderedSet
(
map
ownerID
)
{
var
set
=
Object
.
create
(
OrderedSetPrototype
)
;
set
.
size
=
map
?
map
.
size
:
0
;
set
.
_map
=
map
;
set
.
__ownerID
=
ownerID
;
return
set
;
}
var
EMPTY_ORDERED_SET
;
function
emptyOrderedSet
(
)
{
return
EMPTY_ORDERED_SET
|
|
(
EMPTY_ORDERED_SET
=
makeOrderedSet
(
emptyOrderedMap
(
)
)
)
;
}
createClass
(
Stack
IndexedCollection
)
;
function
Stack
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyStack
(
)
:
isStack
(
value
)
?
value
:
emptyStack
(
)
.
unshiftAll
(
value
)
;
}
Stack
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
Stack
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Stack
[
'
'
]
'
)
;
}
;
Stack
.
prototype
.
get
=
function
(
index
notSetValue
)
{
var
head
=
this
.
_head
;
index
=
wrapIndex
(
this
index
)
;
while
(
head
&
&
index
-
-
)
{
head
=
head
.
next
;
}
return
head
?
head
.
value
:
notSetValue
;
}
;
Stack
.
prototype
.
peek
=
function
(
)
{
return
this
.
_head
&
&
this
.
_head
.
value
;
}
;
Stack
.
prototype
.
push
=
function
(
)
{
if
(
arguments
.
length
=
=
=
0
)
{
return
this
;
}
var
newSize
=
this
.
size
+
arguments
.
length
;
var
head
=
this
.
_head
;
for
(
var
ii
=
arguments
.
length
-
1
;
ii
>
=
0
;
ii
-
-
)
{
head
=
{
value
:
arguments
[
ii
]
next
:
head
}
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
newSize
;
this
.
_head
=
head
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
makeStack
(
newSize
head
)
;
}
;
Stack
.
prototype
.
pushAll
=
function
(
iter
)
{
iter
=
IndexedIterable
(
iter
)
;
if
(
iter
.
size
=
=
=
0
)
{
return
this
;
}
assertNotInfinite
(
iter
.
size
)
;
var
newSize
=
this
.
size
;
var
head
=
this
.
_head
;
iter
.
reverse
(
)
.
forEach
(
function
(
value
)
{
newSize
+
+
;
head
=
{
value
:
value
next
:
head
}
;
}
)
;
if
(
this
.
__ownerID
)
{
this
.
size
=
newSize
;
this
.
_head
=
head
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
makeStack
(
newSize
head
)
;
}
;
Stack
.
prototype
.
pop
=
function
(
)
{
return
this
.
slice
(
1
)
;
}
;
Stack
.
prototype
.
unshift
=
function
(
)
{
return
this
.
push
.
apply
(
this
arguments
)
;
}
;
Stack
.
prototype
.
unshiftAll
=
function
(
iter
)
{
return
this
.
pushAll
(
iter
)
;
}
;
Stack
.
prototype
.
shift
=
function
(
)
{
return
this
.
pop
.
apply
(
this
arguments
)
;
}
;
Stack
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
0
;
this
.
_head
=
undefined
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
emptyStack
(
)
;
}
;
Stack
.
prototype
.
slice
=
function
(
begin
end
)
{
if
(
wholeSlice
(
begin
end
this
.
size
)
)
{
return
this
;
}
var
resolvedBegin
=
resolveBegin
(
begin
this
.
size
)
;
var
resolvedEnd
=
resolveEnd
(
end
this
.
size
)
;
if
(
resolvedEnd
!
=
=
this
.
size
)
{
return
IndexedCollection
.
prototype
.
slice
.
call
(
this
begin
end
)
;
}
var
newSize
=
this
.
size
-
resolvedBegin
;
var
head
=
this
.
_head
;
while
(
resolvedBegin
-
-
)
{
head
=
head
.
next
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
newSize
;
this
.
_head
=
head
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
makeStack
(
newSize
head
)
;
}
;
Stack
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
__altered
=
false
;
return
this
;
}
return
makeStack
(
this
.
size
this
.
_head
ownerID
this
.
__hash
)
;
}
;
Stack
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
if
(
reverse
)
{
return
this
.
reverse
(
)
.
__iterate
(
fn
)
;
}
var
iterations
=
0
;
var
node
=
this
.
_head
;
while
(
node
)
{
if
(
fn
(
node
.
value
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
node
=
node
.
next
;
}
return
iterations
;
}
;
Stack
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
if
(
reverse
)
{
return
this
.
reverse
(
)
.
__iterator
(
type
)
;
}
var
iterations
=
0
;
var
node
=
this
.
_head
;
return
new
Iterator
(
function
(
)
{
if
(
node
)
{
var
value
=
node
.
value
;
node
=
node
.
next
;
return
iteratorValue
(
type
iterations
+
+
value
)
;
}
return
iteratorDone
(
)
;
}
)
;
}
;
function
isStack
(
maybeStack
)
{
return
!
!
(
maybeStack
&
&
maybeStack
[
IS_STACK_SENTINEL
]
)
;
}
Stack
.
isStack
=
isStack
;
var
IS_STACK_SENTINEL
=
'
__IMMUTABLE_STACK__
'
;
var
StackPrototype
=
Stack
.
prototype
;
StackPrototype
[
IS_STACK_SENTINEL
]
=
true
;
StackPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
StackPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
StackPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
StackPrototype
.
wasAltered
=
MapPrototype
.
wasAltered
;
function
makeStack
(
size
head
ownerID
hash
)
{
var
map
=
Object
.
create
(
StackPrototype
)
;
map
.
size
=
size
;
map
.
_head
=
head
;
map
.
__ownerID
=
ownerID
;
map
.
__hash
=
hash
;
map
.
__altered
=
false
;
return
map
;
}
var
EMPTY_STACK
;
function
emptyStack
(
)
{
return
EMPTY_STACK
|
|
(
EMPTY_STACK
=
makeStack
(
0
)
)
;
}
function
mixin
(
ctor
methods
)
{
var
keyCopier
=
function
(
key
)
{
ctor
.
prototype
[
key
]
=
methods
[
key
]
;
}
;
Object
.
keys
(
methods
)
.
forEach
(
keyCopier
)
;
Object
.
getOwnPropertySymbols
&
&
Object
.
getOwnPropertySymbols
(
methods
)
.
forEach
(
keyCopier
)
;
return
ctor
;
}
Iterable
.
Iterator
=
Iterator
;
mixin
(
Iterable
{
toArray
:
function
(
)
{
assertNotInfinite
(
this
.
size
)
;
var
array
=
new
Array
(
this
.
size
|
|
0
)
;
this
.
valueSeq
(
)
.
__iterate
(
function
(
v
i
)
{
array
[
i
]
=
v
;
}
)
;
return
array
;
}
toIndexedSeq
:
function
(
)
{
return
new
ToIndexedSequence
(
this
)
;
}
toJS
:
function
(
)
{
return
this
.
toSeq
(
)
.
map
(
function
(
value
)
{
return
value
&
&
typeof
value
.
toJS
=
=
=
'
function
'
?
value
.
toJS
(
)
:
value
}
)
.
__toJS
(
)
;
}
toJSON
:
function
(
)
{
return
this
.
toSeq
(
)
.
map
(
function
(
value
)
{
return
value
&
&
typeof
value
.
toJSON
=
=
=
'
function
'
?
value
.
toJSON
(
)
:
value
}
)
.
__toJS
(
)
;
}
toKeyedSeq
:
function
(
)
{
return
new
ToKeyedSequence
(
this
true
)
;
}
toMap
:
function
(
)
{
return
Map
(
this
.
toKeyedSeq
(
)
)
;
}
toObject
:
function
(
)
{
assertNotInfinite
(
this
.
size
)
;
var
object
=
{
}
;
this
.
__iterate
(
function
(
v
k
)
{
object
[
k
]
=
v
;
}
)
;
return
object
;
}
toOrderedMap
:
function
(
)
{
return
OrderedMap
(
this
.
toKeyedSeq
(
)
)
;
}
toOrderedSet
:
function
(
)
{
return
OrderedSet
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toSet
:
function
(
)
{
return
Set
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toSetSeq
:
function
(
)
{
return
new
ToSetSequence
(
this
)
;
}
toSeq
:
function
(
)
{
return
isIndexed
(
this
)
?
this
.
toIndexedSeq
(
)
:
isKeyed
(
this
)
?
this
.
toKeyedSeq
(
)
:
this
.
toSetSeq
(
)
;
}
toStack
:
function
(
)
{
return
Stack
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toList
:
function
(
)
{
return
List
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toString
:
function
(
)
{
return
'
[
Iterable
]
'
;
}
__toString
:
function
(
head
tail
)
{
if
(
this
.
size
=
=
=
0
)
{
return
head
+
tail
;
}
return
head
+
'
'
+
this
.
toSeq
(
)
.
map
(
this
.
__toStringMapper
)
.
join
(
'
'
)
+
'
'
+
tail
;
}
concat
:
function
(
)
{
var
values
=
SLICE
0
.
call
(
arguments
0
)
;
return
reify
(
this
concatFactory
(
this
values
)
)
;
}
includes
:
function
(
searchValue
)
{
return
this
.
some
(
function
(
value
)
{
return
is
(
value
searchValue
)
}
)
;
}
entries
:
function
(
)
{
return
this
.
__iterator
(
ITERATE_ENTRIES
)
;
}
every
:
function
(
predicate
context
)
{
assertNotInfinite
(
this
.
size
)
;
var
returnValue
=
true
;
this
.
__iterate
(
function
(
v
k
c
)
{
if
(
!
predicate
.
call
(
context
v
k
c
)
)
{
returnValue
=
false
;
return
false
;
}
}
)
;
return
returnValue
;
}
filter
:
function
(
predicate
context
)
{
return
reify
(
this
filterFactory
(
this
predicate
context
true
)
)
;
}
find
:
function
(
predicate
context
notSetValue
)
{
var
entry
=
this
.
findEntry
(
predicate
context
)
;
return
entry
?
entry
[
1
]
:
notSetValue
;
}
forEach
:
function
(
sideEffect
context
)
{
assertNotInfinite
(
this
.
size
)
;
return
this
.
__iterate
(
context
?
sideEffect
.
bind
(
context
)
:
sideEffect
)
;
}
join
:
function
(
separator
)
{
assertNotInfinite
(
this
.
size
)
;
separator
=
separator
!
=
=
undefined
?
'
'
+
separator
:
'
'
;
var
joined
=
'
'
;
var
isFirst
=
true
;
this
.
__iterate
(
function
(
v
)
{
isFirst
?
(
isFirst
=
false
)
:
(
joined
+
=
separator
)
;
joined
+
=
v
!
=
=
null
&
&
v
!
=
=
undefined
?
v
.
toString
(
)
:
'
'
;
}
)
;
return
joined
;
}
keys
:
function
(
)
{
return
this
.
__iterator
(
ITERATE_KEYS
)
;
}
map
:
function
(
mapper
context
)
{
return
reify
(
this
mapFactory
(
this
mapper
context
)
)
;
}
reduce
:
function
(
reducer
initialReduction
context
)
{
assertNotInfinite
(
this
.
size
)
;
var
reduction
;
var
useFirst
;
if
(
arguments
.
length
<
2
)
{
useFirst
=
true
;
}
else
{
reduction
=
initialReduction
;
}
this
.
__iterate
(
function
(
v
k
c
)
{
if
(
useFirst
)
{
useFirst
=
false
;
reduction
=
v
;
}
else
{
reduction
=
reducer
.
call
(
context
reduction
v
k
c
)
;
}
}
)
;
return
reduction
;
}
reduceRight
:
function
(
reducer
initialReduction
context
)
{
var
reversed
=
this
.
toKeyedSeq
(
)
.
reverse
(
)
;
return
reversed
.
reduce
.
apply
(
reversed
arguments
)
;
}
reverse
:
function
(
)
{
return
reify
(
this
reverseFactory
(
this
true
)
)
;
}
slice
:
function
(
begin
end
)
{
return
reify
(
this
sliceFactory
(
this
begin
end
true
)
)
;
}
some
:
function
(
predicate
context
)
{
return
!
this
.
every
(
not
(
predicate
)
context
)
;
}
sort
:
function
(
comparator
)
{
return
reify
(
this
sortFactory
(
this
comparator
)
)
;
}
values
:
function
(
)
{
return
this
.
__iterator
(
ITERATE_VALUES
)
;
}
butLast
:
function
(
)
{
return
this
.
slice
(
0
-
1
)
;
}
isEmpty
:
function
(
)
{
return
this
.
size
!
=
=
undefined
?
this
.
size
=
=
=
0
:
!
this
.
some
(
function
(
)
{
return
true
}
)
;
}
count
:
function
(
predicate
context
)
{
return
ensureSize
(
predicate
?
this
.
toSeq
(
)
.
filter
(
predicate
context
)
:
this
)
;
}
countBy
:
function
(
grouper
context
)
{
return
countByFactory
(
this
grouper
context
)
;
}
equals
:
function
(
other
)
{
return
deepEqual
(
this
other
)
;
}
entrySeq
:
function
(
)
{
var
iterable
=
this
;
if
(
iterable
.
_cache
)
{
return
new
ArraySeq
(
iterable
.
_cache
)
;
}
var
entriesSequence
=
iterable
.
toSeq
(
)
.
map
(
entryMapper
)
.
toIndexedSeq
(
)
;
entriesSequence
.
fromEntrySeq
=
function
(
)
{
return
iterable
.
toSeq
(
)
}
;
return
entriesSequence
;
}
filterNot
:
function
(
predicate
context
)
{
return
this
.
filter
(
not
(
predicate
)
context
)
;
}
findEntry
:
function
(
predicate
context
notSetValue
)
{
var
found
=
notSetValue
;
this
.
__iterate
(
function
(
v
k
c
)
{
if
(
predicate
.
call
(
context
v
k
c
)
)
{
found
=
[
k
v
]
;
return
false
;
}
}
)
;
return
found
;
}
findKey
:
function
(
predicate
context
)
{
var
entry
=
this
.
findEntry
(
predicate
context
)
;
return
entry
&
&
entry
[
0
]
;
}
findLast
:
function
(
predicate
context
notSetValue
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
find
(
predicate
context
notSetValue
)
;
}
findLastEntry
:
function
(
predicate
context
notSetValue
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
findEntry
(
predicate
context
notSetValue
)
;
}
findLastKey
:
function
(
predicate
context
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
findKey
(
predicate
context
)
;
}
first
:
function
(
)
{
return
this
.
find
(
returnTrue
)
;
}
flatMap
:
function
(
mapper
context
)
{
return
reify
(
this
flatMapFactory
(
this
mapper
context
)
)
;
}
flatten
:
function
(
depth
)
{
return
reify
(
this
flattenFactory
(
this
depth
true
)
)
;
}
fromEntrySeq
:
function
(
)
{
return
new
FromEntriesSequence
(
this
)
;
}
get
:
function
(
searchKey
notSetValue
)
{
return
this
.
find
(
function
(
_
key
)
{
return
is
(
key
searchKey
)
}
undefined
notSetValue
)
;
}
getIn
:
function
(
searchKeyPath
notSetValue
)
{
var
nested
=
this
;
var
iter
=
forceIterator
(
searchKeyPath
)
;
var
step
;
while
(
!
(
step
=
iter
.
next
(
)
)
.
done
)
{
var
key
=
step
.
value
;
nested
=
nested
&
&
nested
.
get
?
nested
.
get
(
key
NOT_SET
)
:
NOT_SET
;
if
(
nested
=
=
=
NOT_SET
)
{
return
notSetValue
;
}
}
return
nested
;
}
groupBy
:
function
(
grouper
context
)
{
return
groupByFactory
(
this
grouper
context
)
;
}
has
:
function
(
searchKey
)
{
return
this
.
get
(
searchKey
NOT_SET
)
!
=
=
NOT_SET
;
}
hasIn
:
function
(
searchKeyPath
)
{
return
this
.
getIn
(
searchKeyPath
NOT_SET
)
!
=
=
NOT_SET
;
}
isSubset
:
function
(
iter
)
{
iter
=
typeof
iter
.
includes
=
=
=
'
function
'
?
iter
:
Iterable
(
iter
)
;
return
this
.
every
(
function
(
value
)
{
return
iter
.
includes
(
value
)
}
)
;
}
isSuperset
:
function
(
iter
)
{
iter
=
typeof
iter
.
isSubset
=
=
=
'
function
'
?
iter
:
Iterable
(
iter
)
;
return
iter
.
isSubset
(
this
)
;
}
keyOf
:
function
(
searchValue
)
{
return
this
.
findKey
(
function
(
value
)
{
return
is
(
value
searchValue
)
}
)
;
}
keySeq
:
function
(
)
{
return
this
.
toSeq
(
)
.
map
(
keyMapper
)
.
toIndexedSeq
(
)
;
}
last
:
function
(
)
{
return
this
.
toSeq
(
)
.
reverse
(
)
.
first
(
)
;
}
lastKeyOf
:
function
(
searchValue
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
keyOf
(
searchValue
)
;
}
max
:
function
(
comparator
)
{
return
maxFactory
(
this
comparator
)
;
}
maxBy
:
function
(
mapper
comparator
)
{
return
maxFactory
(
this
comparator
mapper
)
;
}
min
:
function
(
comparator
)
{
return
maxFactory
(
this
comparator
?
neg
(
comparator
)
:
defaultNegComparator
)
;
}
minBy
:
function
(
mapper
comparator
)
{
return
maxFactory
(
this
comparator
?
neg
(
comparator
)
:
defaultNegComparator
mapper
)
;
}
rest
:
function
(
)
{
return
this
.
slice
(
1
)
;
}
skip
:
function
(
amount
)
{
return
this
.
slice
(
Math
.
max
(
0
amount
)
)
;
}
skipLast
:
function
(
amount
)
{
return
reify
(
this
this
.
toSeq
(
)
.
reverse
(
)
.
skip
(
amount
)
.
reverse
(
)
)
;
}
skipWhile
:
function
(
predicate
context
)
{
return
reify
(
this
skipWhileFactory
(
this
predicate
context
true
)
)
;
}
skipUntil
:
function
(
predicate
context
)
{
return
this
.
skipWhile
(
not
(
predicate
)
context
)
;
}
sortBy
:
function
(
mapper
comparator
)
{
return
reify
(
this
sortFactory
(
this
comparator
mapper
)
)
;
}
take
:
function
(
amount
)
{
return
this
.
slice
(
0
Math
.
max
(
0
amount
)
)
;
}
takeLast
:
function
(
amount
)
{
return
reify
(
this
this
.
toSeq
(
)
.
reverse
(
)
.
take
(
amount
)
.
reverse
(
)
)
;
}
takeWhile
:
function
(
predicate
context
)
{
return
reify
(
this
takeWhileFactory
(
this
predicate
context
)
)
;
}
takeUntil
:
function
(
predicate
context
)
{
return
this
.
takeWhile
(
not
(
predicate
)
context
)
;
}
valueSeq
:
function
(
)
{
return
this
.
toIndexedSeq
(
)
;
}
hashCode
:
function
(
)
{
return
this
.
__hash
|
|
(
this
.
__hash
=
hashIterable
(
this
)
)
;
}
}
)
;
var
IterablePrototype
=
Iterable
.
prototype
;
IterablePrototype
[
IS_ITERABLE_SENTINEL
]
=
true
;
IterablePrototype
[
ITERATOR_SYMBOL
]
=
IterablePrototype
.
values
;
IterablePrototype
.
__toJS
=
IterablePrototype
.
toArray
;
IterablePrototype
.
__toStringMapper
=
quoteString
;
IterablePrototype
.
inspect
=
IterablePrototype
.
toSource
=
function
(
)
{
return
this
.
toString
(
)
;
}
;
IterablePrototype
.
chain
=
IterablePrototype
.
flatMap
;
IterablePrototype
.
contains
=
IterablePrototype
.
includes
;
mixin
(
KeyedIterable
{
flip
:
function
(
)
{
return
reify
(
this
flipFactory
(
this
)
)
;
}
mapEntries
:
function
(
mapper
context
)
{
var
this
0
=
this
;
var
iterations
=
0
;
return
reify
(
this
this
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
mapper
.
call
(
context
[
k
v
]
iterations
+
+
this
0
)
}
)
.
fromEntrySeq
(
)
)
;
}
mapKeys
:
function
(
mapper
context
)
{
var
this
0
=
this
;
return
reify
(
this
this
.
toSeq
(
)
.
flip
(
)
.
map
(
function
(
k
v
)
{
return
mapper
.
call
(
context
k
v
this
0
)
}
)
.
flip
(
)
)
;
}
}
)
;
var
KeyedIterablePrototype
=
KeyedIterable
.
prototype
;
KeyedIterablePrototype
[
IS_KEYED_SENTINEL
]
=
true
;
KeyedIterablePrototype
[
ITERATOR_SYMBOL
]
=
IterablePrototype
.
entries
;
KeyedIterablePrototype
.
__toJS
=
IterablePrototype
.
toObject
;
KeyedIterablePrototype
.
__toStringMapper
=
function
(
v
k
)
{
return
JSON
.
stringify
(
k
)
+
'
:
'
+
quoteString
(
v
)
}
;
mixin
(
IndexedIterable
{
toKeyedSeq
:
function
(
)
{
return
new
ToKeyedSequence
(
this
false
)
;
}
filter
:
function
(
predicate
context
)
{
return
reify
(
this
filterFactory
(
this
predicate
context
false
)
)
;
}
findIndex
:
function
(
predicate
context
)
{
var
entry
=
this
.
findEntry
(
predicate
context
)
;
return
entry
?
entry
[
0
]
:
-
1
;
}
indexOf
:
function
(
searchValue
)
{
var
key
=
this
.
keyOf
(
searchValue
)
;
return
key
=
=
=
undefined
?
-
1
:
key
;
}
lastIndexOf
:
function
(
searchValue
)
{
var
key
=
this
.
lastKeyOf
(
searchValue
)
;
return
key
=
=
=
undefined
?
-
1
:
key
;
}
reverse
:
function
(
)
{
return
reify
(
this
reverseFactory
(
this
false
)
)
;
}
slice
:
function
(
begin
end
)
{
return
reify
(
this
sliceFactory
(
this
begin
end
false
)
)
;
}
splice
:
function
(
index
removeNum
)
{
var
numArgs
=
arguments
.
length
;
removeNum
=
Math
.
max
(
removeNum
|
0
0
)
;
if
(
numArgs
=
=
=
0
|
|
(
numArgs
=
=
=
2
&
&
!
removeNum
)
)
{
return
this
;
}
index
=
resolveBegin
(
index
index
<
0
?
this
.
count
(
)
:
this
.
size
)
;
var
spliced
=
this
.
slice
(
0
index
)
;
return
reify
(
this
numArgs
=
=
=
1
?
spliced
:
spliced
.
concat
(
arrCopy
(
arguments
2
)
this
.
slice
(
index
+
removeNum
)
)
)
;
}
findLastIndex
:
function
(
predicate
context
)
{
var
entry
=
this
.
findLastEntry
(
predicate
context
)
;
return
entry
?
entry
[
0
]
:
-
1
;
}
first
:
function
(
)
{
return
this
.
get
(
0
)
;
}
flatten
:
function
(
depth
)
{
return
reify
(
this
flattenFactory
(
this
depth
false
)
)
;
}
get
:
function
(
index
notSetValue
)
{
index
=
wrapIndex
(
this
index
)
;
return
(
index
<
0
|
|
(
this
.
size
=
=
=
Infinity
|
|
(
this
.
size
!
=
=
undefined
&
&
index
>
this
.
size
)
)
)
?
notSetValue
:
this
.
find
(
function
(
_
key
)
{
return
key
=
=
=
index
}
undefined
notSetValue
)
;
}
has
:
function
(
index
)
{
index
=
wrapIndex
(
this
index
)
;
return
index
>
=
0
&
&
(
this
.
size
!
=
=
undefined
?
this
.
size
=
=
=
Infinity
|
|
index
<
this
.
size
:
this
.
indexOf
(
index
)
!
=
=
-
1
)
;
}
interpose
:
function
(
separator
)
{
return
reify
(
this
interposeFactory
(
this
separator
)
)
;
}
interleave
:
function
(
)
{
var
iterables
=
[
this
]
.
concat
(
arrCopy
(
arguments
)
)
;
var
zipped
=
zipWithFactory
(
this
.
toSeq
(
)
IndexedSeq
.
of
iterables
)
;
var
interleaved
=
zipped
.
flatten
(
true
)
;
if
(
zipped
.
size
)
{
interleaved
.
size
=
zipped
.
size
*
iterables
.
length
;
}
return
reify
(
this
interleaved
)
;
}
keySeq
:
function
(
)
{
return
Range
(
0
this
.
size
)
;
}
last
:
function
(
)
{
return
this
.
get
(
-
1
)
;
}
skipWhile
:
function
(
predicate
context
)
{
return
reify
(
this
skipWhileFactory
(
this
predicate
context
false
)
)
;
}
zip
:
function
(
)
{
var
iterables
=
[
this
]
.
concat
(
arrCopy
(
arguments
)
)
;
return
reify
(
this
zipWithFactory
(
this
defaultZipper
iterables
)
)
;
}
zipWith
:
function
(
zipper
)
{
var
iterables
=
arrCopy
(
arguments
)
;
iterables
[
0
]
=
this
;
return
reify
(
this
zipWithFactory
(
this
zipper
iterables
)
)
;
}
}
)
;
IndexedIterable
.
prototype
[
IS_INDEXED_SENTINEL
]
=
true
;
IndexedIterable
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
mixin
(
SetIterable
{
get
:
function
(
value
notSetValue
)
{
return
this
.
has
(
value
)
?
value
:
notSetValue
;
}
includes
:
function
(
value
)
{
return
this
.
has
(
value
)
;
}
keySeq
:
function
(
)
{
return
this
.
valueSeq
(
)
;
}
}
)
;
SetIterable
.
prototype
.
has
=
IterablePrototype
.
includes
;
SetIterable
.
prototype
.
contains
=
SetIterable
.
prototype
.
includes
;
mixin
(
KeyedSeq
KeyedIterable
.
prototype
)
;
mixin
(
IndexedSeq
IndexedIterable
.
prototype
)
;
mixin
(
SetSeq
SetIterable
.
prototype
)
;
mixin
(
KeyedCollection
KeyedIterable
.
prototype
)
;
mixin
(
IndexedCollection
IndexedIterable
.
prototype
)
;
mixin
(
SetCollection
SetIterable
.
prototype
)
;
function
keyMapper
(
v
k
)
{
return
k
;
}
function
entryMapper
(
v
k
)
{
return
[
k
v
]
;
}
function
not
(
predicate
)
{
return
function
(
)
{
return
!
predicate
.
apply
(
this
arguments
)
;
}
}
function
neg
(
predicate
)
{
return
function
(
)
{
return
-
predicate
.
apply
(
this
arguments
)
;
}
}
function
quoteString
(
value
)
{
return
typeof
value
=
=
=
'
string
'
?
JSON
.
stringify
(
value
)
:
String
(
value
)
;
}
function
defaultZipper
(
)
{
return
arrCopy
(
arguments
)
;
}
function
defaultNegComparator
(
a
b
)
{
return
a
<
b
?
1
:
a
>
b
?
-
1
:
0
;
}
function
hashIterable
(
iterable
)
{
if
(
iterable
.
size
=
=
=
Infinity
)
{
return
0
;
}
var
ordered
=
isOrdered
(
iterable
)
;
var
keyed
=
isKeyed
(
iterable
)
;
var
h
=
ordered
?
1
:
0
;
var
size
=
iterable
.
__iterate
(
keyed
?
ordered
?
function
(
v
k
)
{
h
=
31
*
h
+
hashMerge
(
hash
(
v
)
hash
(
k
)
)
|
0
;
}
:
function
(
v
k
)
{
h
=
h
+
hashMerge
(
hash
(
v
)
hash
(
k
)
)
|
0
;
}
:
ordered
?
function
(
v
)
{
h
=
31
*
h
+
hash
(
v
)
|
0
;
}
:
function
(
v
)
{
h
=
h
+
hash
(
v
)
|
0
;
}
)
;
return
murmurHashOfSize
(
size
h
)
;
}
function
murmurHashOfSize
(
size
h
)
{
h
=
imul
(
h
0xCC9E2D51
)
;
h
=
imul
(
h
<
<
15
|
h
>
>
>
-
15
0x1B873593
)
;
h
=
imul
(
h
<
<
13
|
h
>
>
>
-
13
5
)
;
h
=
(
h
+
0xE6546B64
|
0
)
^
size
;
h
=
imul
(
h
^
h
>
>
>
16
0x85EBCA6B
)
;
h
=
imul
(
h
^
h
>
>
>
13
0xC2B2AE35
)
;
h
=
smi
(
h
^
h
>
>
>
16
)
;
return
h
;
}
function
hashMerge
(
a
b
)
{
return
a
^
b
+
0x9E3779B9
+
(
a
<
<
6
)
+
(
a
>
>
2
)
|
0
;
}
var
Immutable
=
{
Iterable
:
Iterable
Seq
:
Seq
Collection
:
Collection
Map
:
Map
OrderedMap
:
OrderedMap
List
:
List
Stack
:
Stack
Set
:
Set
OrderedSet
:
OrderedSet
Record
:
Record
Range
:
Range
Repeat
:
Repeat
is
:
is
fromJS
:
fromJS
}
;
return
Immutable
;
}
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
I
=
__webpack_require__
(
341
)
;
function
makeRecord
(
spec
)
{
return
I
.
Record
(
spec
)
;
}
module
.
exports
=
makeRecord
;
}
function
(
module
exports
__webpack_require__
)
{
var
fromJS
=
__webpack_require__
(
340
)
;
var
_require
=
__webpack_require__
(
324
)
;
var
updateObj
=
_require
.
updateObj
;
var
I
=
__webpack_require__
(
341
)
;
var
makeRecord
=
__webpack_require__
(
342
)
;
var
State
=
makeRecord
(
{
breakpoints
:
I
.
Map
(
)
}
)
;
function
firstString
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
for
(
var
arg
of
args
)
{
if
(
typeof
arg
=
=
=
"
string
"
)
{
return
arg
;
}
}
return
null
;
}
function
locationMoved
(
location
newLocation
)
{
return
location
.
line
!
=
=
newLocation
.
line
|
|
location
.
column
!
=
null
&
&
location
.
column
!
=
=
newLocation
.
column
;
}
function
makeLocationId
(
location
)
{
return
location
.
sourceId
+
"
:
"
+
location
.
line
.
toString
(
)
;
}
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
State
(
)
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
"
ADD_BREAKPOINT
"
:
{
var
id
=
makeLocationId
(
action
.
breakpoint
.
location
)
;
if
(
action
.
status
=
=
=
"
start
"
)
{
var
bp
=
state
.
breakpoints
.
get
(
id
)
|
|
action
.
breakpoint
;
return
state
.
setIn
(
[
"
breakpoints
"
id
]
updateObj
(
bp
{
disabled
:
false
loading
:
true
condition
:
firstString
(
action
.
condition
bp
.
condition
)
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_action
value
=
action
.
value
;
var
breakpointId
=
_action
value
.
id
;
var
text
=
_action
value
.
text
;
var
location
=
action
.
breakpoint
.
location
;
var
actualLocation
=
action
.
value
.
actualLocation
;
if
(
locationMoved
(
location
actualLocation
)
)
{
state
=
state
.
deleteIn
(
[
"
breakpoints
"
id
]
)
;
var
movedId
=
makeLocationId
(
actualLocation
)
;
var
currentBp
=
state
.
breakpoints
.
get
(
movedId
)
|
|
fromJS
(
action
.
breakpoint
)
;
var
newBp
=
updateObj
(
currentBp
{
location
:
actualLocation
}
)
;
state
=
state
.
setIn
(
[
"
breakpoints
"
movedId
]
newBp
)
;
location
=
actualLocation
;
}
var
locationId
=
makeLocationId
(
location
)
;
var
_bp
=
state
.
breakpoints
.
get
(
locationId
)
;
return
state
.
setIn
(
[
"
breakpoints
"
locationId
]
updateObj
(
_bp
{
id
:
breakpointId
disabled
:
false
loading
:
false
text
:
text
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
)
{
return
state
.
deleteIn
(
[
"
breakpoints
"
id
]
)
;
}
break
;
}
case
"
REMOVE_BREAKPOINT
"
:
{
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_id
=
makeLocationId
(
action
.
breakpoint
.
location
)
;
if
(
action
.
disabled
)
{
var
_bp2
=
state
.
breakpoints
.
get
(
_id
)
;
return
state
.
setIn
(
[
"
breakpoints
"
_id
]
updateObj
(
_bp2
{
loading
:
false
disabled
:
true
}
)
)
;
}
return
state
.
deleteIn
(
[
"
breakpoints
"
_id
]
)
;
}
break
;
}
case
"
SET_BREAKPOINT_CONDITION
"
:
{
var
_id2
=
makeLocationId
(
action
.
breakpoint
.
location
)
;
if
(
action
.
status
=
=
=
"
start
"
)
{
var
_bp3
=
state
.
breakpoints
.
get
(
_id2
)
;
return
state
.
setIn
(
[
"
breakpoints
"
_id2
]
updateObj
(
_bp3
{
loading
:
true
condition
:
action
.
condition
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_bp4
=
state
.
breakpoints
.
get
(
_id2
)
;
return
state
.
setIn
(
[
"
breakpoints
"
_id2
]
updateObj
(
_bp4
{
loading
:
false
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
)
{
return
state
.
deleteIn
(
[
"
breakpoints
"
_id2
]
)
;
}
break
;
}
}
return
state
;
}
function
getBreakpoint
(
state
location
)
{
return
state
.
breakpoints
.
breakpoints
.
get
(
makeLocationId
(
location
)
)
;
}
function
getBreakpoints
(
state
)
{
return
state
.
breakpoints
.
breakpoints
;
}
function
getBreakpointsForSource
(
state
sourceId
)
{
return
state
.
breakpoints
.
breakpoints
.
filter
(
bp
=
>
{
return
bp
.
location
.
sourceId
=
=
=
sourceId
;
}
)
;
}
module
.
exports
=
{
State
update
makeLocationId
getBreakpoint
getBreakpoints
getBreakpointsForSource
}
;
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
constants
=
__webpack_require__
(
338
)
;
var
initialState
=
[
]
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
var
seqId
=
action
.
seqId
;
if
(
action
.
type
=
=
=
constants
.
NAVIGATE
)
{
return
initialState
;
}
else
if
(
seqId
)
{
var
newState
=
void
0
;
if
(
action
.
status
=
=
=
"
start
"
)
{
newState
=
[
]
.
concat
(
_toConsumableArray
(
state
)
[
seqId
]
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
|
|
action
.
status
=
=
=
"
done
"
)
{
newState
=
state
.
filter
(
id
=
>
id
!
=
=
seqId
)
;
}
return
newState
;
}
return
state
;
}
module
.
exports
=
update
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
338
)
;
var
Immutable
=
__webpack_require__
(
341
)
;
var
fromJS
=
__webpack_require__
(
340
)
;
var
initialState
=
fromJS
(
{
tabs
:
{
}
selectedTab
:
null
}
)
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
constants
.
ADD_TABS
:
var
tabs
=
action
.
value
;
if
(
!
tabs
)
{
return
state
;
}
return
state
.
mergeIn
(
[
"
tabs
"
]
Immutable
.
Map
(
tabs
.
map
(
tab
=
>
{
tab
=
Object
.
assign
(
{
}
tab
{
id
:
getTabId
(
tab
)
}
)
;
return
[
tab
.
id
Immutable
.
Map
(
tab
)
]
;
}
)
)
)
;
case
constants
.
SELECT_TAB
:
var
tab
=
state
.
getIn
(
[
"
tabs
"
action
.
id
]
)
;
return
state
.
setIn
(
[
"
selectedTab
"
]
tab
)
;
}
return
state
;
}
function
getTabId
(
tab
)
{
var
id
=
tab
.
id
;
var
isFirefox
=
tab
.
browser
=
=
"
firefox
"
;
if
(
isFirefox
)
{
id
=
tab
.
id
.
split
(
"
.
"
)
.
pop
(
)
;
}
return
id
;
}
module
.
exports
=
update
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
338
)
;
var
fromJS
=
__webpack_require__
(
340
)
;
var
initialState
=
fromJS
(
{
pause
:
null
isWaitingOnBreak
:
false
frames
:
null
selectedFrame
:
null
loadedObjects
:
{
}
shouldPauseOnExceptions
:
false
expressions
:
[
]
}
)
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
var
emit
=
arguments
[
2
]
;
switch
(
action
.
type
)
{
case
constants
.
PAUSED
:
if
(
action
.
status
=
=
"
done
"
)
{
var
pause
=
action
.
value
.
pauseInfo
;
pause
.
isInterrupted
=
pause
.
why
.
type
=
=
=
"
interrupted
"
;
return
state
.
merge
(
{
isWaitingOnBreak
:
false
pause
:
fromJS
(
pause
)
selectedFrame
:
action
.
value
.
pauseInfo
.
frame
frames
:
action
.
value
.
frames
}
)
;
}
break
;
case
constants
.
RESUME
:
return
state
.
merge
(
{
pause
:
null
frames
:
null
selectedFrame
:
null
loadedObjects
:
{
}
}
)
;
case
constants
.
BREAK_ON_NEXT
:
return
state
.
set
(
"
isWaitingOnBreak
"
true
)
;
case
constants
.
LOADED_FRAMES
:
if
(
action
.
status
=
=
"
done
"
)
{
return
state
.
set
(
"
frames
"
action
.
value
.
frames
)
;
}
break
;
case
constants
.
SELECT_FRAME
:
return
state
.
set
(
"
selectedFrame
"
action
.
frame
)
;
case
constants
.
LOAD_OBJECT_PROPERTIES
:
if
(
action
.
status
=
=
=
"
done
"
)
{
var
ownProperties
=
action
.
value
.
ownProperties
;
var
prototype
=
action
.
value
.
prototype
;
return
state
.
setIn
(
[
"
loadedObjects
"
action
.
objectId
]
{
ownProperties
prototype
}
)
;
}
break
;
case
constants
.
NAVIGATE
:
return
initialState
;
case
constants
.
PAUSE_ON_EXCEPTIONS
:
var
toggle
=
action
.
toggle
;
return
state
.
set
(
"
shouldPauseOnExceptions
"
toggle
)
;
case
constants
.
ADD_EXPRESSION
:
return
state
.
setIn
(
[
"
expressions
"
action
.
id
]
{
id
:
action
.
id
input
:
action
.
input
value
:
action
.
value
updating
:
false
}
)
;
case
constants
.
EVALUATE_EXPRESSION
:
if
(
action
.
status
=
=
=
"
done
"
)
{
return
state
.
mergeIn
(
[
"
expressions
"
action
.
id
]
{
id
:
action
.
id
input
:
action
.
input
value
:
action
.
value
updating
:
false
}
)
;
}
break
;
case
constants
.
UPDATE_EXPRESSION
:
return
state
.
mergeIn
(
[
"
expressions
"
action
.
id
]
{
id
:
action
.
id
input
:
action
.
input
updating
:
true
}
)
;
case
constants
.
DELETE_EXPRESSION
:
return
state
.
deleteIn
(
[
"
expressions
"
action
.
id
]
)
;
}
return
state
;
}
module
.
exports
=
update
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
348
)
;
var
getTabs
=
_require2
.
getTabs
;
__webpack_require__
(
355
)
;
var
dom
=
React
.
DOM
;
function
getTabsByBrowser
(
tabs
browser
)
{
return
tabs
.
valueSeq
(
)
.
filter
(
tab
=
>
tab
.
get
(
"
browser
"
)
=
=
browser
)
;
}
function
renderTabs
(
tabTitle
tabs
paramName
)
{
if
(
tabs
.
count
(
)
=
=
0
)
{
return
null
;
}
return
dom
.
div
(
{
className
:
tab
-
group
{
tabTitle
}
}
dom
.
div
(
{
className
:
"
tab
-
group
-
title
"
}
tabTitle
)
dom
.
ul
(
{
className
:
"
tab
-
list
"
}
tabs
.
valueSeq
(
)
.
map
(
tab
=
>
dom
.
li
(
{
"
className
"
:
"
tab
"
"
key
"
:
tab
.
get
(
"
id
"
)
"
onClick
"
:
(
)
=
>
{
window
.
location
=
"
/
?
"
+
paramName
+
"
=
"
+
tab
.
get
(
"
id
"
)
;
}
}
dom
.
div
(
{
className
:
"
tab
-
title
"
}
tab
.
get
(
"
title
"
)
)
dom
.
div
(
{
className
:
"
tab
-
url
"
}
tab
.
get
(
"
url
"
)
)
)
)
)
)
;
}
function
renderMessage
(
tabsIsEmpty
)
{
return
dom
.
div
(
{
className
:
"
not
-
connected
-
message
"
}
!
tabsIsEmpty
|
|
"
No
remote
tabs
found
.
"
"
You
may
be
looking
to
"
dom
.
a
(
{
href
:
/
?
ws
=
{
document
.
location
.
hostname
}
:
9229
/
node
}
"
connect
to
Node
"
)
"
.
"
dom
.
br
(
)
"
Make
sure
you
run
"
dom
.
a
(
{
href
:
"
https
:
/
/
github
.
com
/
devtools
-
html
/
debugger
.
html
/
blob
/
master
/
CONTRIBUTING
.
md
#
firefox
"
}
"
Firefox
"
)
"
"
dom
.
a
(
{
href
:
"
https
:
/
/
github
.
com
/
devtools
-
html
/
debugger
.
html
/
blob
/
master
/
CONTRIBUTING
.
md
#
chrome
"
}
"
Chrome
"
)
"
or
"
dom
.
a
(
{
href
:
"
https
:
/
/
github
.
com
/
devtools
-
html
/
debugger
.
html
/
blob
/
master
/
CONTRIBUTING
.
md
#
nodejs
"
}
"
Node
"
)
"
with
the
right
flags
.
"
)
;
}
function
Tabs
(
_ref
)
{
var
tabs
=
_ref
.
tabs
;
var
firefoxTabs
=
getTabsByBrowser
(
tabs
"
firefox
"
)
;
var
chromeTabs
=
getTabsByBrowser
(
tabs
"
chrome
"
)
;
return
dom
.
div
(
{
className
:
"
tabs
theme
-
light
"
}
renderTabs
(
"
Firefox
Tabs
"
firefoxTabs
"
firefox
-
tab
"
)
renderTabs
(
"
Chrome
Tabs
"
chromeTabs
"
chrome
-
tab
"
)
renderMessage
(
tabs
.
isEmpty
(
)
)
)
;
}
module
.
exports
=
connect
(
state
=
>
(
{
tabs
:
getTabs
(
state
)
}
)
)
(
Tabs
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
URL
=
__webpack_require__
(
349
)
;
var
path
=
__webpack_require__
(
354
)
;
var
sources
=
__webpack_require__
(
339
)
;
var
breakpoints
=
__webpack_require__
(
343
)
;
function
getTabs
(
state
)
{
return
state
.
tabs
.
get
(
"
tabs
"
)
;
}
function
getSelectedTab
(
state
)
{
return
state
.
tabs
.
get
(
"
selectedTab
"
)
;
}
function
getPause
(
state
)
{
return
state
.
pause
.
get
(
"
pause
"
)
;
}
function
getLoadedObjects
(
state
)
{
return
state
.
pause
.
get
(
"
loadedObjects
"
)
;
}
function
getExpressions
(
state
)
{
return
state
.
pause
.
get
(
"
expressions
"
)
;
}
function
getIsWaitingOnBreak
(
state
)
{
return
state
.
pause
.
get
(
"
isWaitingOnBreak
"
)
;
}
function
getShouldPauseOnExceptions
(
state
)
{
return
state
.
pause
.
get
(
"
shouldPauseOnExceptions
"
)
;
}
function
getFrames
(
state
)
{
return
state
.
pause
.
get
(
"
frames
"
)
|
|
[
]
;
}
function
getSelectedFrame
(
state
)
{
return
state
.
pause
.
get
(
"
selectedFrame
"
)
;
}
function
getSourceMapURL
(
state
source
)
{
if
(
path
.
isURL
(
source
.
sourceMapURL
)
)
{
return
source
.
sourceMapURL
;
}
else
if
(
path
.
isAbsolute
(
source
.
sourceMapURL
)
)
{
var
urlObj
=
URL
.
parse
(
source
.
url
)
;
var
base
=
urlObj
.
protocol
+
"
/
/
"
+
urlObj
.
host
;
return
base
+
source
.
sourceMapURL
;
}
return
path
.
dirname
(
source
.
url
)
+
"
/
"
+
source
.
sourceMapURL
;
}
module
.
exports
=
{
getSource
:
sources
.
getSource
getSourceByURL
:
sources
.
getSourceByURL
getSourceById
:
sources
.
getSourceById
getSources
:
sources
.
getSources
getSourceText
:
sources
.
getSourceText
getSourceTabs
:
sources
.
getSourceTabs
getSelectedSource
:
sources
.
getSelectedSource
getPendingSelectedSourceURL
:
sources
.
getPendingSelectedSourceURL
getSourceMap
:
sources
.
getSourceMap
getSourceMapURL
getBreakpoint
:
breakpoints
.
getBreakpoint
getBreakpoints
:
breakpoints
.
getBreakpoints
getBreakpointsForSource
:
breakpoints
.
getBreakpointsForSource
getTabs
getSelectedTab
getPause
getLoadedObjects
getExpressions
getIsWaitingOnBreak
getShouldPauseOnExceptions
getFrames
getSelectedFrame
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
punycode
=
__webpack_require__
(
350
)
;
exports
.
parse
=
urlParse
;
exports
.
resolve
=
urlResolve
;
exports
.
resolveObject
=
urlResolveObject
;
exports
.
format
=
urlFormat
;
exports
.
Url
=
Url
;
function
Url
(
)
{
this
.
protocol
=
null
;
this
.
slashes
=
null
;
this
.
auth
=
null
;
this
.
host
=
null
;
this
.
port
=
null
;
this
.
hostname
=
null
;
this
.
hash
=
null
;
this
.
search
=
null
;
this
.
query
=
null
;
this
.
pathname
=
null
;
this
.
path
=
null
;
this
.
href
=
null
;
}
var
protocolPattern
=
/
^
(
[
a
-
z0
-
9
.
+
-
]
+
:
)
/
i
portPattern
=
/
:
[
0
-
9
]
*
/
delims
=
[
'
<
'
'
>
'
'
"
'
'
'
'
'
'
\
r
'
'
\
n
'
'
\
t
'
]
unwise
=
[
'
{
'
'
}
'
'
|
'
'
\
\
'
'
^
'
'
'
]
.
concat
(
delims
)
autoEscape
=
[
'
\
'
'
]
.
concat
(
unwise
)
nonHostChars
=
[
'
%
'
'
/
'
'
?
'
'
;
'
'
#
'
]
.
concat
(
autoEscape
)
hostEndingChars
=
[
'
/
'
'
?
'
'
#
'
]
hostnameMaxLen
=
255
hostnamePartPattern
=
/
^
[
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
/
hostnamePartStart
=
/
^
(
[
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
)
(
.
*
)
/
unsafeProtocol
=
{
'
javascript
'
:
true
'
javascript
:
'
:
true
}
hostlessProtocol
=
{
'
javascript
'
:
true
'
javascript
:
'
:
true
}
slashedProtocol
=
{
'
http
'
:
true
'
https
'
:
true
'
ftp
'
:
true
'
gopher
'
:
true
'
file
'
:
true
'
http
:
'
:
true
'
https
:
'
:
true
'
ftp
:
'
:
true
'
gopher
:
'
:
true
'
file
:
'
:
true
}
querystring
=
__webpack_require__
(
351
)
;
function
urlParse
(
url
parseQueryString
slashesDenoteHost
)
{
if
(
url
&
&
isObject
(
url
)
&
&
url
instanceof
Url
)
return
url
;
var
u
=
new
Url
;
u
.
parse
(
url
parseQueryString
slashesDenoteHost
)
;
return
u
;
}
Url
.
prototype
.
parse
=
function
(
url
parseQueryString
slashesDenoteHost
)
{
if
(
!
isString
(
url
)
)
{
throw
new
TypeError
(
"
Parameter
'
url
'
must
be
a
string
not
"
+
typeof
url
)
;
}
var
rest
=
url
;
rest
=
rest
.
trim
(
)
;
var
proto
=
protocolPattern
.
exec
(
rest
)
;
if
(
proto
)
{
proto
=
proto
[
0
]
;
var
lowerProto
=
proto
.
toLowerCase
(
)
;
this
.
protocol
=
lowerProto
;
rest
=
rest
.
substr
(
proto
.
length
)
;
}
if
(
slashesDenoteHost
|
|
proto
|
|
rest
.
match
(
/
^
\
/
\
/
[
^
\
/
]
+
[
^
\
/
]
+
/
)
)
{
var
slashes
=
rest
.
substr
(
0
2
)
=
=
=
'
/
/
'
;
if
(
slashes
&
&
!
(
proto
&
&
hostlessProtocol
[
proto
]
)
)
{
rest
=
rest
.
substr
(
2
)
;
this
.
slashes
=
true
;
}
}
if
(
!
hostlessProtocol
[
proto
]
&
&
(
slashes
|
|
(
proto
&
&
!
slashedProtocol
[
proto
]
)
)
)
{
var
hostEnd
=
-
1
;
for
(
var
i
=
0
;
i
<
hostEndingChars
.
length
;
i
+
+
)
{
var
hec
=
rest
.
indexOf
(
hostEndingChars
[
i
]
)
;
if
(
hec
!
=
=
-
1
&
&
(
hostEnd
=
=
=
-
1
|
|
hec
<
hostEnd
)
)
hostEnd
=
hec
;
}
var
auth
atSign
;
if
(
hostEnd
=
=
=
-
1
)
{
atSign
=
rest
.
lastIndexOf
(
'
'
)
;
}
else
{
atSign
=
rest
.
lastIndexOf
(
'
'
hostEnd
)
;
}
if
(
atSign
!
=
=
-
1
)
{
auth
=
rest
.
slice
(
0
atSign
)
;
rest
=
rest
.
slice
(
atSign
+
1
)
;
this
.
auth
=
decodeURIComponent
(
auth
)
;
}
hostEnd
=
-
1
;
for
(
var
i
=
0
;
i
<
nonHostChars
.
length
;
i
+
+
)
{
var
hec
=
rest
.
indexOf
(
nonHostChars
[
i
]
)
;
if
(
hec
!
=
=
-
1
&
&
(
hostEnd
=
=
=
-
1
|
|
hec
<
hostEnd
)
)
hostEnd
=
hec
;
}
if
(
hostEnd
=
=
=
-
1
)
hostEnd
=
rest
.
length
;
this
.
host
=
rest
.
slice
(
0
hostEnd
)
;
rest
=
rest
.
slice
(
hostEnd
)
;
this
.
parseHost
(
)
;
this
.
hostname
=
this
.
hostname
|
|
'
'
;
var
ipv6Hostname
=
this
.
hostname
[
0
]
=
=
=
'
[
'
&
&
this
.
hostname
[
this
.
hostname
.
length
-
1
]
=
=
=
'
]
'
;
if
(
!
ipv6Hostname
)
{
var
hostparts
=
this
.
hostname
.
split
(
/
\
.
/
)
;
for
(
var
i
=
0
l
=
hostparts
.
length
;
i
<
l
;
i
+
+
)
{
var
part
=
hostparts
[
i
]
;
if
(
!
part
)
continue
;
if
(
!
part
.
match
(
hostnamePartPattern
)
)
{
var
newpart
=
'
'
;
for
(
var
j
=
0
k
=
part
.
length
;
j
<
k
;
j
+
+
)
{
if
(
part
.
charCodeAt
(
j
)
>
127
)
{
newpart
+
=
'
x
'
;
}
else
{
newpart
+
=
part
[
j
]
;
}
}
if
(
!
newpart
.
match
(
hostnamePartPattern
)
)
{
var
validParts
=
hostparts
.
slice
(
0
i
)
;
var
notHost
=
hostparts
.
slice
(
i
+
1
)
;
var
bit
=
part
.
match
(
hostnamePartStart
)
;
if
(
bit
)
{
validParts
.
push
(
bit
[
1
]
)
;
notHost
.
unshift
(
bit
[
2
]
)
;
}
if
(
notHost
.
length
)
{
rest
=
'
/
'
+
notHost
.
join
(
'
.
'
)
+
rest
;
}
this
.
hostname
=
validParts
.
join
(
'
.
'
)
;
break
;
}
}
}
}
if
(
this
.
hostname
.
length
>
hostnameMaxLen
)
{
this
.
hostname
=
'
'
;
}
else
{
this
.
hostname
=
this
.
hostname
.
toLowerCase
(
)
;
}
if
(
!
ipv6Hostname
)
{
var
domainArray
=
this
.
hostname
.
split
(
'
.
'
)
;
var
newOut
=
[
]
;
for
(
var
i
=
0
;
i
<
domainArray
.
length
;
+
+
i
)
{
var
s
=
domainArray
[
i
]
;
newOut
.
push
(
s
.
match
(
/
[
^
A
-
Za
-
z0
-
9_
-
]
/
)
?
'
xn
-
-
'
+
punycode
.
encode
(
s
)
:
s
)
;
}
this
.
hostname
=
newOut
.
join
(
'
.
'
)
;
}
var
p
=
this
.
port
?
'
:
'
+
this
.
port
:
'
'
;
var
h
=
this
.
hostname
|
|
'
'
;
this
.
host
=
h
+
p
;
this
.
href
+
=
this
.
host
;
if
(
ipv6Hostname
)
{
this
.
hostname
=
this
.
hostname
.
substr
(
1
this
.
hostname
.
length
-
2
)
;
if
(
rest
[
0
]
!
=
=
'
/
'
)
{
rest
=
'
/
'
+
rest
;
}
}
}
if
(
!
unsafeProtocol
[
lowerProto
]
)
{
for
(
var
i
=
0
l
=
autoEscape
.
length
;
i
<
l
;
i
+
+
)
{
var
ae
=
autoEscape
[
i
]
;
var
esc
=
encodeURIComponent
(
ae
)
;
if
(
esc
=
=
=
ae
)
{
esc
=
escape
(
ae
)
;
}
rest
=
rest
.
split
(
ae
)
.
join
(
esc
)
;
}
}
var
hash
=
rest
.
indexOf
(
'
#
'
)
;
if
(
hash
!
=
=
-
1
)
{
this
.
hash
=
rest
.
substr
(
hash
)
;
rest
=
rest
.
slice
(
0
hash
)
;
}
var
qm
=
rest
.
indexOf
(
'
?
'
)
;
if
(
qm
!
=
=
-
1
)
{
this
.
search
=
rest
.
substr
(
qm
)
;
this
.
query
=
rest
.
substr
(
qm
+
1
)
;
if
(
parseQueryString
)
{
this
.
query
=
querystring
.
parse
(
this
.
query
)
;
}
rest
=
rest
.
slice
(
0
qm
)
;
}
else
if
(
parseQueryString
)
{
this
.
search
=
'
'
;
this
.
query
=
{
}
;
}
if
(
rest
)
this
.
pathname
=
rest
;
if
(
slashedProtocol
[
lowerProto
]
&
&
this
.
hostname
&
&
!
this
.
pathname
)
{
this
.
pathname
=
'
/
'
;
}
if
(
this
.
pathname
|
|
this
.
search
)
{
var
p
=
this
.
pathname
|
|
'
'
;
var
s
=
this
.
search
|
|
'
'
;
this
.
path
=
p
+
s
;
}
this
.
href
=
this
.
format
(
)
;
return
this
;
}
;
function
urlFormat
(
obj
)
{
if
(
isString
(
obj
)
)
obj
=
urlParse
(
obj
)
;
if
(
!
(
obj
instanceof
Url
)
)
return
Url
.
prototype
.
format
.
call
(
obj
)
;
return
obj
.
format
(
)
;
}
Url
.
prototype
.
format
=
function
(
)
{
var
auth
=
this
.
auth
|
|
'
'
;
if
(
auth
)
{
auth
=
encodeURIComponent
(
auth
)
;
auth
=
auth
.
replace
(
/
%
3A
/
i
'
:
'
)
;
auth
+
=
'
'
;
}
var
protocol
=
this
.
protocol
|
|
'
'
pathname
=
this
.
pathname
|
|
'
'
hash
=
this
.
hash
|
|
'
'
host
=
false
query
=
'
'
;
if
(
this
.
host
)
{
host
=
auth
+
this
.
host
;
}
else
if
(
this
.
hostname
)
{
host
=
auth
+
(
this
.
hostname
.
indexOf
(
'
:
'
)
=
=
=
-
1
?
this
.
hostname
:
'
[
'
+
this
.
hostname
+
'
]
'
)
;
if
(
this
.
port
)
{
host
+
=
'
:
'
+
this
.
port
;
}
}
if
(
this
.
query
&
&
isObject
(
this
.
query
)
&
&
Object
.
keys
(
this
.
query
)
.
length
)
{
query
=
querystring
.
stringify
(
this
.
query
)
;
}
var
search
=
this
.
search
|
|
(
query
&
&
(
'
?
'
+
query
)
)
|
|
'
'
;
if
(
protocol
&
&
protocol
.
substr
(
-
1
)
!
=
=
'
:
'
)
protocol
+
=
'
:
'
;
if
(
this
.
slashes
|
|
(
!
protocol
|
|
slashedProtocol
[
protocol
]
)
&
&
host
!
=
=
false
)
{
host
=
'
/
/
'
+
(
host
|
|
'
'
)
;
if
(
pathname
&
&
pathname
.
charAt
(
0
)
!
=
=
'
/
'
)
pathname
=
'
/
'
+
pathname
;
}
else
if
(
!
host
)
{
host
=
'
'
;
}
if
(
hash
&
&
hash
.
charAt
(
0
)
!
=
=
'
#
'
)
hash
=
'
#
'
+
hash
;
if
(
search
&
&
search
.
charAt
(
0
)
!
=
=
'
?
'
)
search
=
'
?
'
+
search
;
pathname
=
pathname
.
replace
(
/
[
?
#
]
/
g
function
(
match
)
{
return
encodeURIComponent
(
match
)
;
}
)
;
search
=
search
.
replace
(
'
#
'
'
%
23
'
)
;
return
protocol
+
host
+
pathname
+
search
+
hash
;
}
;
function
urlResolve
(
source
relative
)
{
return
urlParse
(
source
false
true
)
.
resolve
(
relative
)
;
}
Url
.
prototype
.
resolve
=
function
(
relative
)
{
return
this
.
resolveObject
(
urlParse
(
relative
false
true
)
)
.
format
(
)
;
}
;
function
urlResolveObject
(
source
relative
)
{
if
(
!
source
)
return
relative
;
return
urlParse
(
source
false
true
)
.
resolveObject
(
relative
)
;
}
Url
.
prototype
.
resolveObject
=
function
(
relative
)
{
if
(
isString
(
relative
)
)
{
var
rel
=
new
Url
(
)
;
rel
.
parse
(
relative
false
true
)
;
relative
=
rel
;
}
var
result
=
new
Url
(
)
;
Object
.
keys
(
this
)
.
forEach
(
function
(
k
)
{
result
[
k
]
=
this
[
k
]
;
}
this
)
;
result
.
hash
=
relative
.
hash
;
if
(
relative
.
href
=
=
=
'
'
)
{
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
relative
.
slashes
&
&
!
relative
.
protocol
)
{
Object
.
keys
(
relative
)
.
forEach
(
function
(
k
)
{
if
(
k
!
=
=
'
protocol
'
)
result
[
k
]
=
relative
[
k
]
;
}
)
;
if
(
slashedProtocol
[
result
.
protocol
]
&
&
result
.
hostname
&
&
!
result
.
pathname
)
{
result
.
path
=
result
.
pathname
=
'
/
'
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
relative
.
protocol
&
&
relative
.
protocol
!
=
=
result
.
protocol
)
{
if
(
!
slashedProtocol
[
relative
.
protocol
]
)
{
Object
.
keys
(
relative
)
.
forEach
(
function
(
k
)
{
result
[
k
]
=
relative
[
k
]
;
}
)
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
result
.
protocol
=
relative
.
protocol
;
if
(
!
relative
.
host
&
&
!
hostlessProtocol
[
relative
.
protocol
]
)
{
var
relPath
=
(
relative
.
pathname
|
|
'
'
)
.
split
(
'
/
'
)
;
while
(
relPath
.
length
&
&
!
(
relative
.
host
=
relPath
.
shift
(
)
)
)
;
if
(
!
relative
.
host
)
relative
.
host
=
'
'
;
if
(
!
relative
.
hostname
)
relative
.
hostname
=
'
'
;
if
(
relPath
[
0
]
!
=
=
'
'
)
relPath
.
unshift
(
'
'
)
;
if
(
relPath
.
length
<
2
)
relPath
.
unshift
(
'
'
)
;
result
.
pathname
=
relPath
.
join
(
'
/
'
)
;
}
else
{
result
.
pathname
=
relative
.
pathname
;
}
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
result
.
host
=
relative
.
host
|
|
'
'
;
result
.
auth
=
relative
.
auth
;
result
.
hostname
=
relative
.
hostname
|
|
relative
.
host
;
result
.
port
=
relative
.
port
;
if
(
result
.
pathname
|
|
result
.
search
)
{
var
p
=
result
.
pathname
|
|
'
'
;
var
s
=
result
.
search
|
|
'
'
;
result
.
path
=
p
+
s
;
}
result
.
slashes
=
result
.
slashes
|
|
relative
.
slashes
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
var
isSourceAbs
=
(
result
.
pathname
&
&
result
.
pathname
.
charAt
(
0
)
=
=
=
'
/
'
)
isRelAbs
=
(
relative
.
host
|
|
relative
.
pathname
&
&
relative
.
pathname
.
charAt
(
0
)
=
=
=
'
/
'
)
mustEndAbs
=
(
isRelAbs
|
|
isSourceAbs
|
|
(
result
.
host
&
&
relative
.
pathname
)
)
removeAllDots
=
mustEndAbs
srcPath
=
result
.
pathname
&
&
result
.
pathname
.
split
(
'
/
'
)
|
|
[
]
relPath
=
relative
.
pathname
&
&
relative
.
pathname
.
split
(
'
/
'
)
|
|
[
]
psychotic
=
result
.
protocol
&
&
!
slashedProtocol
[
result
.
protocol
]
;
if
(
psychotic
)
{
result
.
hostname
=
'
'
;
result
.
port
=
null
;
if
(
result
.
host
)
{
if
(
srcPath
[
0
]
=
=
=
'
'
)
srcPath
[
0
]
=
result
.
host
;
else
srcPath
.
unshift
(
result
.
host
)
;
}
result
.
host
=
'
'
;
if
(
relative
.
protocol
)
{
relative
.
hostname
=
null
;
relative
.
port
=
null
;
if
(
relative
.
host
)
{
if
(
relPath
[
0
]
=
=
=
'
'
)
relPath
[
0
]
=
relative
.
host
;
else
relPath
.
unshift
(
relative
.
host
)
;
}
relative
.
host
=
null
;
}
mustEndAbs
=
mustEndAbs
&
&
(
relPath
[
0
]
=
=
=
'
'
|
|
srcPath
[
0
]
=
=
=
'
'
)
;
}
if
(
isRelAbs
)
{
result
.
host
=
(
relative
.
host
|
|
relative
.
host
=
=
=
'
'
)
?
relative
.
host
:
result
.
host
;
result
.
hostname
=
(
relative
.
hostname
|
|
relative
.
hostname
=
=
=
'
'
)
?
relative
.
hostname
:
result
.
hostname
;
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
srcPath
=
relPath
;
}
else
if
(
relPath
.
length
)
{
if
(
!
srcPath
)
srcPath
=
[
]
;
srcPath
.
pop
(
)
;
srcPath
=
srcPath
.
concat
(
relPath
)
;
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
}
else
if
(
!
isNullOrUndefined
(
relative
.
search
)
)
{
if
(
psychotic
)
{
result
.
hostname
=
result
.
host
=
srcPath
.
shift
(
)
;
var
authInHost
=
result
.
host
&
&
result
.
host
.
indexOf
(
'
'
)
>
0
?
result
.
host
.
split
(
'
'
)
:
false
;
if
(
authInHost
)
{
result
.
auth
=
authInHost
.
shift
(
)
;
result
.
host
=
result
.
hostname
=
authInHost
.
shift
(
)
;
}
}
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
if
(
!
isNull
(
result
.
pathname
)
|
|
!
isNull
(
result
.
search
)
)
{
result
.
path
=
(
result
.
pathname
?
result
.
pathname
:
'
'
)
+
(
result
.
search
?
result
.
search
:
'
'
)
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
!
srcPath
.
length
)
{
result
.
pathname
=
null
;
if
(
result
.
search
)
{
result
.
path
=
'
/
'
+
result
.
search
;
}
else
{
result
.
path
=
null
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
var
last
=
srcPath
.
slice
(
-
1
)
[
0
]
;
var
hasTrailingSlash
=
(
(
result
.
host
|
|
relative
.
host
)
&
&
(
last
=
=
=
'
.
'
|
|
last
=
=
=
'
.
.
'
)
|
|
last
=
=
=
'
'
)
;
var
up
=
0
;
for
(
var
i
=
srcPath
.
length
;
i
>
=
0
;
i
-
-
)
{
last
=
srcPath
[
i
]
;
if
(
last
=
=
'
.
'
)
{
srcPath
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
srcPath
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
srcPath
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
!
mustEndAbs
&
&
!
removeAllDots
)
{
for
(
;
up
-
-
;
up
)
{
srcPath
.
unshift
(
'
.
.
'
)
;
}
}
if
(
mustEndAbs
&
&
srcPath
[
0
]
!
=
=
'
'
&
&
(
!
srcPath
[
0
]
|
|
srcPath
[
0
]
.
charAt
(
0
)
!
=
=
'
/
'
)
)
{
srcPath
.
unshift
(
'
'
)
;
}
if
(
hasTrailingSlash
&
&
(
srcPath
.
join
(
'
/
'
)
.
substr
(
-
1
)
!
=
=
'
/
'
)
)
{
srcPath
.
push
(
'
'
)
;
}
var
isAbsolute
=
srcPath
[
0
]
=
=
=
'
'
|
|
(
srcPath
[
0
]
&
&
srcPath
[
0
]
.
charAt
(
0
)
=
=
=
'
/
'
)
;
if
(
psychotic
)
{
result
.
hostname
=
result
.
host
=
isAbsolute
?
'
'
:
srcPath
.
length
?
srcPath
.
shift
(
)
:
'
'
;
var
authInHost
=
result
.
host
&
&
result
.
host
.
indexOf
(
'
'
)
>
0
?
result
.
host
.
split
(
'
'
)
:
false
;
if
(
authInHost
)
{
result
.
auth
=
authInHost
.
shift
(
)
;
result
.
host
=
result
.
hostname
=
authInHost
.
shift
(
)
;
}
}
mustEndAbs
=
mustEndAbs
|
|
(
result
.
host
&
&
srcPath
.
length
)
;
if
(
mustEndAbs
&
&
!
isAbsolute
)
{
srcPath
.
unshift
(
'
'
)
;
}
if
(
!
srcPath
.
length
)
{
result
.
pathname
=
null
;
result
.
path
=
null
;
}
else
{
result
.
pathname
=
srcPath
.
join
(
'
/
'
)
;
}
if
(
!
isNull
(
result
.
pathname
)
|
|
!
isNull
(
result
.
search
)
)
{
result
.
path
=
(
result
.
pathname
?
result
.
pathname
:
'
'
)
+
(
result
.
search
?
result
.
search
:
'
'
)
;
}
result
.
auth
=
relative
.
auth
|
|
result
.
auth
;
result
.
slashes
=
result
.
slashes
|
|
relative
.
slashes
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
;
Url
.
prototype
.
parseHost
=
function
(
)
{
var
host
=
this
.
host
;
var
port
=
portPattern
.
exec
(
host
)
;
if
(
port
)
{
port
=
port
[
0
]
;
if
(
port
!
=
=
'
:
'
)
{
this
.
port
=
port
.
substr
(
1
)
;
}
host
=
host
.
substr
(
0
host
.
length
-
port
.
length
)
;
}
if
(
host
)
this
.
hostname
=
host
;
}
;
function
isString
(
arg
)
{
return
typeof
arg
=
=
=
"
string
"
;
}
function
isObject
(
arg
)
{
return
typeof
arg
=
=
=
'
object
'
&
&
arg
!
=
=
null
;
}
function
isNull
(
arg
)
{
return
arg
=
=
=
null
;
}
function
isNullOrUndefined
(
arg
)
{
return
arg
=
=
null
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
module
global
)
{
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
&
&
!
exports
.
nodeType
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
!
module
.
nodeType
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
|
|
freeGlobal
.
self
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
punycode
maxInt
=
2147483647
base
=
36
tMin
=
1
tMax
=
26
skew
=
38
damp
=
700
initialBias
=
72
initialN
=
128
delimiter
=
'
-
'
regexPunycode
=
/
^
xn
-
-
/
regexNonASCII
=
/
[
^
\
x20
-
\
x7E
]
/
regexSeparators
=
/
[
\
x2E
\
u3002
\
uFF0E
\
uFF61
]
/
g
errors
=
{
'
overflow
'
:
'
Overflow
:
input
needs
wider
integers
to
process
'
'
not
-
basic
'
:
'
Illegal
input
>
=
0x80
(
not
a
basic
code
point
)
'
'
invalid
-
input
'
:
'
Invalid
input
'
}
baseMinusTMin
=
base
-
tMin
floor
=
Math
.
floor
stringFromCharCode
=
String
.
fromCharCode
key
;
function
error
(
type
)
{
throw
RangeError
(
errors
[
type
]
)
;
}
function
map
(
array
fn
)
{
var
length
=
array
.
length
;
var
result
=
[
]
;
while
(
length
-
-
)
{
result
[
length
]
=
fn
(
array
[
length
]
)
;
}
return
result
;
}
function
mapDomain
(
string
fn
)
{
var
parts
=
string
.
split
(
'
'
)
;
var
result
=
'
'
;
if
(
parts
.
length
>
1
)
{
result
=
parts
[
0
]
+
'
'
;
string
=
parts
[
1
]
;
}
string
=
string
.
replace
(
regexSeparators
'
\
x2E
'
)
;
var
labels
=
string
.
split
(
'
.
'
)
;
var
encoded
=
map
(
labels
fn
)
.
join
(
'
.
'
)
;
return
result
+
encoded
;
}
function
ucs2decode
(
string
)
{
var
output
=
[
]
counter
=
0
length
=
string
.
length
value
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
return
map
(
array
function
(
value
)
{
var
output
=
'
'
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
return
output
;
}
)
.
join
(
'
'
)
;
}
function
basicToDigit
(
codePoint
)
{
if
(
codePoint
-
48
<
10
)
{
return
codePoint
-
22
;
}
if
(
codePoint
-
65
<
26
)
{
return
codePoint
-
65
;
}
if
(
codePoint
-
97
<
26
)
{
return
codePoint
-
97
;
}
return
base
;
}
function
digitToBasic
(
digit
flag
)
{
return
digit
+
22
+
75
*
(
digit
<
26
)
-
(
(
flag
!
=
0
)
<
<
5
)
;
}
function
adapt
(
delta
numPoints
firstTime
)
{
var
k
=
0
;
delta
=
firstTime
?
floor
(
delta
/
damp
)
:
delta
>
>
1
;
delta
+
=
floor
(
delta
/
numPoints
)
;
for
(
;
delta
>
baseMinusTMin
*
tMax
>
>
1
;
k
+
=
base
)
{
delta
=
floor
(
delta
/
baseMinusTMin
)
;
}
return
floor
(
k
+
(
baseMinusTMin
+
1
)
*
delta
/
(
delta
+
skew
)
)
;
}
function
decode
(
input
)
{
var
output
=
[
]
inputLength
=
input
.
length
out
i
=
0
n
=
initialN
bias
=
initialBias
basic
j
index
oldi
w
k
digit
t
baseMinusT
;
basic
=
input
.
lastIndexOf
(
delimiter
)
;
if
(
basic
<
0
)
{
basic
=
0
;
}
for
(
j
=
0
;
j
<
basic
;
+
+
j
)
{
if
(
input
.
charCodeAt
(
j
)
>
=
0x80
)
{
error
(
'
not
-
basic
'
)
;
}
output
.
push
(
input
.
charCodeAt
(
j
)
)
;
}
for
(
index
=
basic
>
0
?
basic
+
1
:
0
;
index
<
inputLength
;
)
{
for
(
oldi
=
i
w
=
1
k
=
base
;
;
k
+
=
base
)
{
if
(
index
>
=
inputLength
)
{
error
(
'
invalid
-
input
'
)
;
}
digit
=
basicToDigit
(
input
.
charCodeAt
(
index
+
+
)
)
;
if
(
digit
>
=
base
|
|
digit
>
floor
(
(
maxInt
-
i
)
/
w
)
)
{
error
(
'
overflow
'
)
;
}
i
+
=
digit
*
w
;
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
digit
<
t
)
{
break
;
}
baseMinusT
=
base
-
t
;
if
(
w
>
floor
(
maxInt
/
baseMinusT
)
)
{
error
(
'
overflow
'
)
;
}
w
*
=
baseMinusT
;
}
out
=
output
.
length
+
1
;
bias
=
adapt
(
i
-
oldi
out
oldi
=
=
0
)
;
if
(
floor
(
i
/
out
)
>
maxInt
-
n
)
{
error
(
'
overflow
'
)
;
}
n
+
=
floor
(
i
/
out
)
;
i
%
=
out
;
output
.
splice
(
i
+
+
0
n
)
;
}
return
ucs2encode
(
output
)
;
}
function
encode
(
input
)
{
var
n
delta
handledCPCount
basicLength
bias
j
m
q
k
t
currentValue
output
=
[
]
inputLength
handledCPCountPlusOne
baseMinusT
qMinusT
;
input
=
ucs2decode
(
input
)
;
inputLength
=
input
.
length
;
n
=
initialN
;
delta
=
0
;
bias
=
initialBias
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
0x80
)
{
output
.
push
(
stringFromCharCode
(
currentValue
)
)
;
}
}
handledCPCount
=
basicLength
=
output
.
length
;
if
(
basicLength
)
{
output
.
push
(
delimiter
)
;
}
while
(
handledCPCount
<
inputLength
)
{
for
(
m
=
maxInt
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
>
=
n
&
&
currentValue
<
m
)
{
m
=
currentValue
;
}
}
handledCPCountPlusOne
=
handledCPCount
+
1
;
if
(
m
-
n
>
floor
(
(
maxInt
-
delta
)
/
handledCPCountPlusOne
)
)
{
error
(
'
overflow
'
)
;
}
delta
+
=
(
m
-
n
)
*
handledCPCountPlusOne
;
n
=
m
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
n
&
&
+
+
delta
>
maxInt
)
{
error
(
'
overflow
'
)
;
}
if
(
currentValue
=
=
n
)
{
for
(
q
=
delta
k
=
base
;
;
k
+
=
base
)
{
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
q
<
t
)
{
break
;
}
qMinusT
=
q
-
t
;
baseMinusT
=
base
-
t
;
output
.
push
(
stringFromCharCode
(
digitToBasic
(
t
+
qMinusT
%
baseMinusT
0
)
)
)
;
q
=
floor
(
qMinusT
/
baseMinusT
)
;
}
output
.
push
(
stringFromCharCode
(
digitToBasic
(
q
0
)
)
)
;
bias
=
adapt
(
delta
handledCPCountPlusOne
handledCPCount
=
=
basicLength
)
;
delta
=
0
;
+
+
handledCPCount
;
}
}
+
+
delta
;
+
+
n
;
}
return
output
.
join
(
'
'
)
;
}
function
toUnicode
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexPunycode
.
test
(
string
)
?
decode
(
string
.
slice
(
4
)
.
toLowerCase
(
)
)
:
string
;
}
)
;
}
function
toASCII
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexNonASCII
.
test
(
string
)
?
'
xn
-
-
'
+
encode
(
string
)
:
string
;
}
)
;
}
punycode
=
{
'
version
'
:
'
1
.
3
.
2
'
'
ucs2
'
:
{
'
decode
'
:
ucs2decode
'
encode
'
:
ucs2encode
}
'
decode
'
:
decode
'
encode
'
:
encode
'
toASCII
'
:
toASCII
'
toUnicode
'
:
toUnicode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
punycode
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
freeModule
)
{
if
(
module
.
exports
=
=
freeExports
)
{
freeModule
.
exports
=
punycode
;
}
else
{
for
(
key
in
punycode
)
{
punycode
.
hasOwnProperty
(
key
)
&
&
(
freeExports
[
key
]
=
punycode
[
key
]
)
;
}
}
}
else
{
root
.
punycode
=
punycode
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
250
)
(
module
)
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
decode
=
exports
.
parse
=
__webpack_require__
(
352
)
;
exports
.
encode
=
exports
.
stringify
=
__webpack_require__
(
353
)
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
hasOwnProperty
(
obj
prop
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
prop
)
;
}
module
.
exports
=
function
(
qs
sep
eq
options
)
{
sep
=
sep
|
|
'
&
'
;
eq
=
eq
|
|
'
=
'
;
var
obj
=
{
}
;
if
(
typeof
qs
!
=
=
'
string
'
|
|
qs
.
length
=
=
=
0
)
{
return
obj
;
}
var
regexp
=
/
\
+
/
g
;
qs
=
qs
.
split
(
sep
)
;
var
maxKeys
=
1000
;
if
(
options
&
&
typeof
options
.
maxKeys
=
=
=
'
number
'
)
{
maxKeys
=
options
.
maxKeys
;
}
var
len
=
qs
.
length
;
if
(
maxKeys
>
0
&
&
len
>
maxKeys
)
{
len
=
maxKeys
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
var
x
=
qs
[
i
]
.
replace
(
regexp
'
%
20
'
)
idx
=
x
.
indexOf
(
eq
)
kstr
vstr
k
v
;
if
(
idx
>
=
0
)
{
kstr
=
x
.
substr
(
0
idx
)
;
vstr
=
x
.
substr
(
idx
+
1
)
;
}
else
{
kstr
=
x
;
vstr
=
'
'
;
}
k
=
decodeURIComponent
(
kstr
)
;
v
=
decodeURIComponent
(
vstr
)
;
if
(
!
hasOwnProperty
(
obj
k
)
)
{
obj
[
k
]
=
v
;
}
else
if
(
Array
.
isArray
(
obj
[
k
]
)
)
{
obj
[
k
]
.
push
(
v
)
;
}
else
{
obj
[
k
]
=
[
obj
[
k
]
v
]
;
}
}
return
obj
;
}
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
stringifyPrimitive
=
function
(
v
)
{
switch
(
typeof
v
)
{
case
'
string
'
:
return
v
;
case
'
boolean
'
:
return
v
?
'
true
'
:
'
false
'
;
case
'
number
'
:
return
isFinite
(
v
)
?
v
:
'
'
;
default
:
return
'
'
;
}
}
;
module
.
exports
=
function
(
obj
sep
eq
name
)
{
sep
=
sep
|
|
'
&
'
;
eq
=
eq
|
|
'
=
'
;
if
(
obj
=
=
=
null
)
{
obj
=
undefined
;
}
if
(
typeof
obj
=
=
=
'
object
'
)
{
return
Object
.
keys
(
obj
)
.
map
(
function
(
k
)
{
var
ks
=
encodeURIComponent
(
stringifyPrimitive
(
k
)
)
+
eq
;
if
(
Array
.
isArray
(
obj
[
k
]
)
)
{
return
obj
[
k
]
.
map
(
function
(
v
)
{
return
ks
+
encodeURIComponent
(
stringifyPrimitive
(
v
)
)
;
}
)
.
join
(
sep
)
;
}
else
{
return
ks
+
encodeURIComponent
(
stringifyPrimitive
(
obj
[
k
]
)
)
;
}
}
)
.
join
(
sep
)
;
}
if
(
!
name
)
return
'
'
;
return
encodeURIComponent
(
stringifyPrimitive
(
name
)
)
+
eq
+
encodeURIComponent
(
stringifyPrimitive
(
obj
)
)
;
}
;
}
function
(
module
exports
)
{
function
basename
(
path
)
{
return
path
.
split
(
"
/
"
)
.
pop
(
)
;
}
function
dirname
(
path
)
{
var
idx
=
path
.
lastIndexOf
(
"
/
"
)
;
return
path
.
slice
(
0
idx
)
;
}
function
isURL
(
str
)
{
return
str
.
indexOf
(
"
:
/
/
"
)
!
=
=
-
1
;
}
function
isAbsolute
(
str
)
{
return
str
[
0
]
=
=
=
"
/
"
;
}
module
.
exports
=
{
basename
dirname
isURL
isAbsolute
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
356
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Tabs
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Tabs
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
tabs
{
\
n
margin
:
100px
auto
;
\
n
margin
-
bottom
:
0
;
\
n
width
:
calc
(
100
%
-
200px
)
;
\
n
}
\
n
\
n
.
tabs
.
tab
-
group
{
\
n
margin
-
top
:
20px
;
\
n
}
\
n
\
n
.
tabs
.
tab
-
group
-
title
{
\
n
margin
:
0
0
1em
10px
;
\
n
color
:
var
(
-
-
theme
-
highlight
-
lightorange
)
;
\
n
}
\
n
\
n
.
tabs
.
tab
-
list
{
\
n
list
-
style
:
none
;
\
n
padding
:
0px
;
\
n
margin
:
0px
;
\
n
}
\
n
\
n
.
tabs
.
tab
:
first
-
child
{
\
n
border
-
top
:
1px
solid
#
dddddd
;
\
n
}
\
n
\
n
.
tabs
.
tab
{
\
n
border
-
bottom
:
1px
solid
#
dddddd
;
\
n
padding
:
10px
;
\
n
font
-
family
:
sans
-
serif
;
\
n
font
-
size
:
0
.
9em
;
\
n
}
\
n
\
n
.
tabs
.
tab
:
hover
{
\
n
background
-
color
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
tabs
.
tab
-
title
{
\
n
line
-
height
:
25px
;
\
n
color
:
var
(
-
-
theme
-
content
-
color1
)
;
\
n
}
\
n
\
n
.
tabs
.
tab
-
url
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
bluegrey
)
;
\
n
}
\
n
\
n
.
not
-
connected
-
message
{
\
n
margin
:
20px
;
\
n
padding
:
50px
100px
;
\
n
border
:
1px
solid
#
dddddd
;
\
n
background
-
color
:
#
fbfbfb
;
\
n
color
:
#
9a9a9a
;
\
n
text
-
align
:
center
;
\
n
}
\
n
\
n
.
node
-
message
{
\
n
margin
:
3em
0
;
\
n
text
-
align
:
center
;
\
n
font
-
size
:
0
.
9em
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
)
{
module
.
exports
=
function
(
)
{
var
list
=
[
]
;
list
.
toString
=
function
toString
(
)
{
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
length
;
i
+
+
)
{
var
item
=
this
[
i
]
;
if
(
item
[
2
]
)
{
result
.
push
(
"
media
"
+
item
[
2
]
+
"
{
"
+
item
[
1
]
+
"
}
"
)
;
}
else
{
result
.
push
(
item
[
1
]
)
;
}
}
return
result
.
join
(
"
"
)
;
}
;
list
.
i
=
function
(
modules
mediaQuery
)
{
if
(
typeof
modules
=
=
=
"
string
"
)
modules
=
[
[
null
modules
"
"
]
]
;
var
alreadyImportedModules
=
{
}
;
for
(
var
i
=
0
;
i
<
this
.
length
;
i
+
+
)
{
var
id
=
this
[
i
]
[
0
]
;
if
(
typeof
id
=
=
=
"
number
"
)
alreadyImportedModules
[
id
]
=
true
;
}
for
(
i
=
0
;
i
<
modules
.
length
;
i
+
+
)
{
var
item
=
modules
[
i
]
;
if
(
typeof
item
[
0
]
!
=
=
"
number
"
|
|
!
alreadyImportedModules
[
item
[
0
]
]
)
{
if
(
mediaQuery
&
&
!
item
[
2
]
)
{
item
[
2
]
=
mediaQuery
;
}
else
if
(
mediaQuery
)
{
item
[
2
]
=
"
(
"
+
item
[
2
]
+
"
)
and
(
"
+
mediaQuery
+
"
)
"
;
}
list
.
push
(
item
)
;
}
}
}
;
return
list
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
stylesInDom
=
{
}
memoize
=
function
(
fn
)
{
var
memo
;
return
function
(
)
{
if
(
typeof
memo
=
=
=
"
undefined
"
)
memo
=
fn
.
apply
(
this
arguments
)
;
return
memo
;
}
;
}
isOldIE
=
memoize
(
function
(
)
{
return
/
msie
[
6
-
9
]
\
b
/
.
test
(
window
.
navigator
.
userAgent
.
toLowerCase
(
)
)
;
}
)
getHeadElement
=
memoize
(
function
(
)
{
return
document
.
head
|
|
document
.
getElementsByTagName
(
"
head
"
)
[
0
]
;
}
)
singletonElement
=
null
singletonCounter
=
0
styleElementsInsertedAtTop
=
[
]
;
module
.
exports
=
function
(
list
options
)
{
if
(
false
)
{
if
(
typeof
document
!
=
=
"
object
"
)
throw
new
Error
(
"
The
style
-
loader
cannot
be
used
in
a
non
-
browser
environment
"
)
;
}
options
=
options
|
|
{
}
;
if
(
typeof
options
.
singleton
=
=
=
"
undefined
"
)
options
.
singleton
=
isOldIE
(
)
;
if
(
typeof
options
.
insertAt
=
=
=
"
undefined
"
)
options
.
insertAt
=
"
bottom
"
;
var
styles
=
listToStyles
(
list
)
;
addStylesToDom
(
styles
options
)
;
return
function
update
(
newList
)
{
var
mayRemove
=
[
]
;
for
(
var
i
=
0
;
i
<
styles
.
length
;
i
+
+
)
{
var
item
=
styles
[
i
]
;
var
domStyle
=
stylesInDom
[
item
.
id
]
;
domStyle
.
refs
-
-
;
mayRemove
.
push
(
domStyle
)
;
}
if
(
newList
)
{
var
newStyles
=
listToStyles
(
newList
)
;
addStylesToDom
(
newStyles
options
)
;
}
for
(
var
i
=
0
;
i
<
mayRemove
.
length
;
i
+
+
)
{
var
domStyle
=
mayRemove
[
i
]
;
if
(
domStyle
.
refs
=
=
=
0
)
{
for
(
var
j
=
0
;
j
<
domStyle
.
parts
.
length
;
j
+
+
)
domStyle
.
parts
[
j
]
(
)
;
delete
stylesInDom
[
domStyle
.
id
]
;
}
}
}
;
}
function
addStylesToDom
(
styles
options
)
{
for
(
var
i
=
0
;
i
<
styles
.
length
;
i
+
+
)
{
var
item
=
styles
[
i
]
;
var
domStyle
=
stylesInDom
[
item
.
id
]
;
if
(
domStyle
)
{
domStyle
.
refs
+
+
;
for
(
var
j
=
0
;
j
<
domStyle
.
parts
.
length
;
j
+
+
)
{
domStyle
.
parts
[
j
]
(
item
.
parts
[
j
]
)
;
}
for
(
;
j
<
item
.
parts
.
length
;
j
+
+
)
{
domStyle
.
parts
.
push
(
addStyle
(
item
.
parts
[
j
]
options
)
)
;
}
}
else
{
var
parts
=
[
]
;
for
(
var
j
=
0
;
j
<
item
.
parts
.
length
;
j
+
+
)
{
parts
.
push
(
addStyle
(
item
.
parts
[
j
]
options
)
)
;
}
stylesInDom
[
item
.
id
]
=
{
id
:
item
.
id
refs
:
1
parts
:
parts
}
;
}
}
}
function
listToStyles
(
list
)
{
var
styles
=
[
]
;
var
newStyles
=
{
}
;
for
(
var
i
=
0
;
i
<
list
.
length
;
i
+
+
)
{
var
item
=
list
[
i
]
;
var
id
=
item
[
0
]
;
var
css
=
item
[
1
]
;
var
media
=
item
[
2
]
;
var
sourceMap
=
item
[
3
]
;
var
part
=
{
css
:
css
media
:
media
sourceMap
:
sourceMap
}
;
if
(
!
newStyles
[
id
]
)
styles
.
push
(
newStyles
[
id
]
=
{
id
:
id
parts
:
[
part
]
}
)
;
else
newStyles
[
id
]
.
parts
.
push
(
part
)
;
}
return
styles
;
}
function
insertStyleElement
(
options
styleElement
)
{
var
head
=
getHeadElement
(
)
;
var
lastStyleElementInsertedAtTop
=
styleElementsInsertedAtTop
[
styleElementsInsertedAtTop
.
length
-
1
]
;
if
(
options
.
insertAt
=
=
=
"
top
"
)
{
if
(
!
lastStyleElementInsertedAtTop
)
{
head
.
insertBefore
(
styleElement
head
.
firstChild
)
;
}
else
if
(
lastStyleElementInsertedAtTop
.
nextSibling
)
{
head
.
insertBefore
(
styleElement
lastStyleElementInsertedAtTop
.
nextSibling
)
;
}
else
{
head
.
appendChild
(
styleElement
)
;
}
styleElementsInsertedAtTop
.
push
(
styleElement
)
;
}
else
if
(
options
.
insertAt
=
=
=
"
bottom
"
)
{
head
.
appendChild
(
styleElement
)
;
}
else
{
throw
new
Error
(
"
Invalid
value
for
parameter
'
insertAt
'
.
Must
be
'
top
'
or
'
bottom
'
.
"
)
;
}
}
function
removeStyleElement
(
styleElement
)
{
styleElement
.
parentNode
.
removeChild
(
styleElement
)
;
var
idx
=
styleElementsInsertedAtTop
.
indexOf
(
styleElement
)
;
if
(
idx
>
=
0
)
{
styleElementsInsertedAtTop
.
splice
(
idx
1
)
;
}
}
function
createStyleElement
(
options
)
{
var
styleElement
=
document
.
createElement
(
"
style
"
)
;
styleElement
.
type
=
"
text
/
css
"
;
insertStyleElement
(
options
styleElement
)
;
return
styleElement
;
}
function
createLinkElement
(
options
)
{
var
linkElement
=
document
.
createElement
(
"
link
"
)
;
linkElement
.
rel
=
"
stylesheet
"
;
insertStyleElement
(
options
linkElement
)
;
return
linkElement
;
}
function
addStyle
(
obj
options
)
{
var
styleElement
update
remove
;
if
(
options
.
singleton
)
{
var
styleIndex
=
singletonCounter
+
+
;
styleElement
=
singletonElement
|
|
(
singletonElement
=
createStyleElement
(
options
)
)
;
update
=
applyToSingletonTag
.
bind
(
null
styleElement
styleIndex
false
)
;
remove
=
applyToSingletonTag
.
bind
(
null
styleElement
styleIndex
true
)
;
}
else
if
(
obj
.
sourceMap
&
&
typeof
URL
=
=
=
"
function
"
&
&
typeof
URL
.
createObjectURL
=
=
=
"
function
"
&
&
typeof
URL
.
revokeObjectURL
=
=
=
"
function
"
&
&
typeof
Blob
=
=
=
"
function
"
&
&
typeof
btoa
=
=
=
"
function
"
)
{
styleElement
=
createLinkElement
(
options
)
;
update
=
updateLink
.
bind
(
null
styleElement
)
;
remove
=
function
(
)
{
removeStyleElement
(
styleElement
)
;
if
(
styleElement
.
href
)
URL
.
revokeObjectURL
(
styleElement
.
href
)
;
}
;
}
else
{
styleElement
=
createStyleElement
(
options
)
;
update
=
applyToTag
.
bind
(
null
styleElement
)
;
remove
=
function
(
)
{
removeStyleElement
(
styleElement
)
;
}
;
}
update
(
obj
)
;
return
function
updateStyle
(
newObj
)
{
if
(
newObj
)
{
if
(
newObj
.
css
=
=
=
obj
.
css
&
&
newObj
.
media
=
=
=
obj
.
media
&
&
newObj
.
sourceMap
=
=
=
obj
.
sourceMap
)
return
;
update
(
obj
=
newObj
)
;
}
else
{
remove
(
)
;
}
}
;
}
var
replaceText
=
(
function
(
)
{
var
textStore
=
[
]
;
return
function
(
index
replacement
)
{
textStore
[
index
]
=
replacement
;
return
textStore
.
filter
(
Boolean
)
.
join
(
'
\
n
'
)
;
}
;
}
)
(
)
;
function
applyToSingletonTag
(
styleElement
index
remove
obj
)
{
var
css
=
remove
?
"
"
:
obj
.
css
;
if
(
styleElement
.
styleSheet
)
{
styleElement
.
styleSheet
.
cssText
=
replaceText
(
index
css
)
;
}
else
{
var
cssNode
=
document
.
createTextNode
(
css
)
;
var
childNodes
=
styleElement
.
childNodes
;
if
(
childNodes
[
index
]
)
styleElement
.
removeChild
(
childNodes
[
index
]
)
;
if
(
childNodes
.
length
)
{
styleElement
.
insertBefore
(
cssNode
childNodes
[
index
]
)
;
}
else
{
styleElement
.
appendChild
(
cssNode
)
;
}
}
}
function
applyToTag
(
styleElement
obj
)
{
var
css
=
obj
.
css
;
var
media
=
obj
.
media
;
if
(
media
)
{
styleElement
.
setAttribute
(
"
media
"
media
)
}
if
(
styleElement
.
styleSheet
)
{
styleElement
.
styleSheet
.
cssText
=
css
;
}
else
{
while
(
styleElement
.
firstChild
)
{
styleElement
.
removeChild
(
styleElement
.
firstChild
)
;
}
styleElement
.
appendChild
(
document
.
createTextNode
(
css
)
)
;
}
}
function
updateLink
(
linkElement
obj
)
{
var
css
=
obj
.
css
;
var
sourceMap
=
obj
.
sourceMap
;
if
(
sourceMap
)
{
css
+
=
"
\
n
/
*
#
sourceMappingURL
=
data
:
application
/
json
;
base64
"
+
btoa
(
unescape
(
encodeURIComponent
(
JSON
.
stringify
(
sourceMap
)
)
)
)
+
"
*
/
"
;
}
var
blob
=
new
Blob
(
[
css
]
{
type
:
"
text
/
css
"
}
)
;
var
oldSrc
=
linkElement
.
href
;
linkElement
.
href
=
URL
.
createObjectURL
(
blob
)
;
if
(
oldSrc
)
URL
.
revokeObjectURL
(
oldSrc
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
createFactory
=
React
.
createFactory
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
actions
=
__webpack_require__
(
360
)
;
__webpack_require__
(
369
)
;
__webpack_require__
(
371
)
;
__webpack_require__
(
373
)
;
var
Sources
=
createFactory
(
__webpack_require__
(
375
)
)
;
var
Editor
=
createFactory
(
__webpack_require__
(
414
)
)
;
var
SplitBox
=
createFactory
(
__webpack_require__
(
425
)
)
;
var
RightSidebar
=
createFactory
(
__webpack_require__
(
429
)
)
;
var
SourceTabs
=
createFactory
(
__webpack_require__
(
498
)
)
;
var
SourceFooter
=
createFactory
(
__webpack_require__
(
503
)
)
;
var
Autocomplete
=
createFactory
(
__webpack_require__
(
504
)
)
;
var
_require3
=
__webpack_require__
(
348
)
;
var
getSelectedSource
=
_require3
.
getSelectedSource
;
var
getSources
=
_require3
.
getSources
;
var
_require4
=
__webpack_require__
(
324
)
;
var
endTruncateStr
=
_require4
.
endTruncateStr
;
var
_require5
=
__webpack_require__
(
513
)
;
var
KeyShortcuts
=
_require5
.
KeyShortcuts
;
var
App
=
React
.
createClass
(
{
propTypes
:
{
sources
:
PropTypes
.
object
selectedSource
:
PropTypes
.
object
selectSource
:
PropTypes
.
func
}
displayName
:
"
App
"
getInitialState
(
)
{
return
{
searchOn
:
false
}
;
}
componentDidMount
(
)
{
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
}
)
;
this
.
shortcuts
.
on
(
"
Cmd
+
P
"
this
.
toggleSourcesSearch
)
;
window
.
addEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
}
componentWillUnmount
(
)
{
this
.
shortcuts
.
off
(
"
Cmd
+
P
"
this
.
toggleSourcesSearch
)
;
window
.
removeEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
}
toggleSourcesSearch
(
key
e
)
{
e
.
preventDefault
(
)
;
this
.
setState
(
{
searchOn
:
!
this
.
state
.
searchOn
}
)
;
}
onKeyDown
(
e
)
{
if
(
e
.
key
=
=
=
"
Escape
"
)
{
this
.
setState
(
{
searchOn
:
false
}
)
;
e
.
preventDefault
(
)
;
}
}
renderSourcesSearch
(
)
{
function
getSourcePath
(
source
)
{
var
url
=
source
.
get
(
"
url
"
)
|
|
"
"
;
var
path
=
new
URL
(
url
)
.
pathname
;
return
endTruncateStr
(
path
50
)
;
}
function
searchResults
(
sources
)
{
return
sources
.
valueSeq
(
)
.
filter
(
source
=
>
!
!
source
.
get
(
"
url
"
)
)
.
map
(
source
=
>
(
{
value
:
getSourcePath
(
source
)
title
:
getSourcePath
(
source
)
.
split
(
"
/
"
)
.
pop
(
)
subtitle
:
getSourcePath
(
source
)
id
:
source
.
get
(
"
id
"
)
}
)
)
.
toJS
(
)
;
}
return
Autocomplete
(
{
selectItem
:
result
=
>
{
this
.
props
.
selectSource
(
result
.
id
)
;
this
.
setState
(
{
searchOn
:
false
}
)
;
}
items
:
searchResults
(
this
.
props
.
sources
)
}
)
;
}
renderEditor
(
)
{
return
dom
.
div
(
{
className
:
"
editor
-
container
"
}
SourceTabs
(
)
Editor
(
)
SourceFooter
(
)
)
;
}
renderWelcomeBox
(
)
{
return
dom
.
div
(
{
className
:
"
welcomebox
"
}
"
Want
to
find
a
file
?
(
Cmd
+
P
)
"
)
;
}
renderCenterPane
(
)
{
var
centerPane
=
void
0
;
if
(
this
.
state
.
searchOn
)
{
centerPane
=
this
.
renderSourcesSearch
(
)
;
}
else
if
(
this
.
props
.
selectedSource
)
{
centerPane
=
this
.
renderEditor
(
)
;
}
else
{
centerPane
=
this
.
renderWelcomeBox
(
)
;
}
return
dom
.
div
(
{
className
:
"
center
-
pane
"
}
centerPane
)
;
}
render
:
function
(
)
{
return
dom
.
div
(
{
className
:
"
theme
-
light
debugger
"
}
SplitBox
(
{
initialWidth
:
300
left
:
Sources
(
{
sources
:
this
.
props
.
sources
}
)
right
:
SplitBox
(
{
initialWidth
:
300
rightFlex
:
true
left
:
this
.
renderCenterPane
(
this
.
props
)
right
:
RightSidebar
(
)
}
)
}
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
sources
:
getSources
(
state
)
selectedSource
:
getSelectedSource
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
App
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
breakpoints
=
__webpack_require__
(
361
)
;
var
eventListeners
=
__webpack_require__
(
363
)
;
var
sources
=
__webpack_require__
(
364
)
;
var
tabs
=
__webpack_require__
(
366
)
;
var
pause
=
__webpack_require__
(
367
)
;
var
navigation
=
__webpack_require__
(
368
)
;
module
.
exports
=
Object
.
assign
(
navigation
breakpoints
eventListeners
sources
tabs
pause
)
;
}
function
(
module
exports
__webpack_require__
)
{
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
constants
=
__webpack_require__
(
338
)
;
var
_require
=
__webpack_require__
(
332
)
;
var
PROMISE
=
_require
.
PROMISE
;
var
_require2
=
__webpack_require__
(
348
)
;
var
getBreakpoint
=
_require2
.
getBreakpoint
;
var
getBreakpoints
=
_require2
.
getBreakpoints
;
var
_require3
=
__webpack_require__
(
362
)
;
var
getOriginalLocation
=
_require3
.
getOriginalLocation
;
var
getGeneratedLocation
=
_require3
.
getGeneratedLocation
;
function
_breakpointExists
(
state
location
)
{
var
currentBp
=
getBreakpoint
(
state
location
)
;
return
currentBp
&
&
!
currentBp
.
disabled
;
}
function
_getOrCreateBreakpoint
(
state
location
condition
)
{
return
getBreakpoint
(
state
location
)
|
|
{
location
condition
}
;
}
function
enableBreakpoint
(
location
)
{
return
addBreakpoint
(
location
)
;
}
function
addBreakpoint
(
location
)
{
var
_ref
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
condition
=
_ref
.
condition
;
var
getTextForLine
=
_ref
.
getTextForLine
;
return
_ref2
=
>
{
var
dispatch
=
_ref2
.
dispatch
;
var
getState
=
_ref2
.
getState
;
var
client
=
_ref2
.
client
;
if
(
_breakpointExists
(
getState
(
)
location
)
)
{
return
Promise
.
resolve
(
)
;
}
var
bp
=
_getOrCreateBreakpoint
(
getState
(
)
location
condition
)
;
return
dispatch
(
{
type
:
constants
.
ADD_BREAKPOINT
breakpoint
:
bp
condition
:
condition
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
location
=
yield
getGeneratedLocation
(
getState
(
)
bp
.
location
)
;
var
_ref4
=
yield
client
.
setBreakpoint
(
location
bp
.
condition
)
;
var
id
=
_ref4
.
id
;
var
actualLocation
=
_ref4
.
actualLocation
;
actualLocation
=
yield
getOriginalLocation
(
getState
(
)
actualLocation
)
;
var
text
=
bp
.
text
;
if
(
!
text
)
{
text
=
getTextForLine
?
getTextForLine
(
actualLocation
.
line
)
:
"
"
;
}
return
{
id
actualLocation
text
}
;
}
)
(
)
}
)
;
}
;
}
function
disableBreakpoint
(
location
)
{
return
_removeOrDisableBreakpoint
(
location
true
)
;
}
function
removeBreakpoint
(
location
)
{
return
_removeOrDisableBreakpoint
(
location
)
;
}
function
_removeOrDisableBreakpoint
(
location
isDisabled
)
{
return
_ref5
=
>
{
var
dispatch
=
_ref5
.
dispatch
;
var
getState
=
_ref5
.
getState
;
var
client
=
_ref5
.
client
;
var
bp
=
getBreakpoint
(
getState
(
)
location
)
;
if
(
!
bp
)
{
throw
new
Error
(
"
attempt
to
remove
breakpoint
that
does
not
exist
"
)
;
}
if
(
bp
.
loading
)
{
throw
new
Error
(
"
attempt
to
remove
unsaved
breakpoint
"
)
;
}
var
action
=
{
type
:
constants
.
REMOVE_BREAKPOINT
breakpoint
:
bp
disabled
:
isDisabled
}
;
if
(
!
bp
.
disabled
)
{
return
dispatch
(
Object
.
assign
(
{
}
action
{
[
PROMISE
]
:
client
.
removeBreakpoint
(
bp
.
id
)
}
)
)
;
}
return
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
done
"
}
)
)
;
}
;
}
function
removeAllBreakpoints
(
)
{
return
_ref6
=
>
{
var
dispatch
=
_ref6
.
dispatch
;
var
getState
=
_ref6
.
getState
;
var
breakpoints
=
getBreakpoints
(
getState
(
)
)
;
var
activeBreakpoints
=
breakpoints
.
filter
(
bp
=
>
!
bp
.
disabled
)
;
activeBreakpoints
.
forEach
(
bp
=
>
removeBreakpoint
(
bp
.
location
)
)
;
}
;
}
function
setBreakpointCondition
(
location
condition
)
{
throw
new
Error
(
"
not
implemented
"
)
;
}
module
.
exports
=
{
enableBreakpoint
addBreakpoint
disableBreakpoint
removeBreakpoint
removeAllBreakpoints
setBreakpointCondition
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
getOriginalSources
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
state
source
)
{
var
originalSourceUrls
=
yield
getOriginalSourceUrls
(
source
)
;
return
originalSourceUrls
.
map
(
function
(
url
)
{
return
getSourceByURL
(
state
url
)
;
}
)
;
}
)
;
return
function
getOriginalSources
(
_x
_x2
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
getGeneratedSource
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
state
source
)
{
if
(
yield
isGenerated
(
source
)
)
{
return
source
;
}
var
generatedSourceId
=
yield
getGeneratedSourceId
(
source
)
;
var
originalSource
=
getSource
(
state
generatedSourceId
)
;
if
(
originalSource
)
{
return
originalSource
.
toJS
(
)
;
}
return
source
;
}
)
;
return
function
getGeneratedSource
(
_x3
_x4
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
getGeneratedLocation
=
(
(
)
=
>
{
var
_ref4
=
_asyncToGenerator
(
function
*
(
state
location
)
{
var
source
=
getSource
(
state
location
.
sourceId
)
;
if
(
!
source
)
{
return
location
;
}
if
(
yield
isOriginal
(
source
.
toJS
(
)
)
)
{
return
yield
getGeneratedSourceLocation
(
source
.
toJS
(
)
location
)
;
}
return
location
;
}
)
;
return
function
getGeneratedLocation
(
_x5
_x6
)
{
return
_ref4
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
getOriginalLocation
=
(
(
)
=
>
{
var
_ref5
=
_asyncToGenerator
(
function
*
(
state
location
)
{
var
source
=
getSource
(
state
location
.
sourceId
)
;
if
(
!
source
)
{
return
location
;
}
var
_isGenerated
=
yield
isGenerated
(
source
.
toJS
(
)
)
;
if
(
_isGenerated
)
{
var
originalPosition
=
yield
getOriginalSourcePosition
(
source
.
toJS
(
)
location
)
;
var
url
=
originalPosition
.
url
;
var
line
=
originalPosition
.
line
;
var
originalSource
=
getSourceByURL
(
state
url
)
;
return
{
sourceId
:
originalSource
.
get
(
"
id
"
)
line
}
;
}
return
location
;
}
)
;
return
function
getOriginalLocation
(
_x7
_x8
)
{
return
_ref5
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
getOriginalSourceTexts
=
(
(
)
=
>
{
var
_ref6
=
_asyncToGenerator
(
function
*
(
state
generatedSource
generatedText
)
{
if
(
!
_shouldSourceMap
(
generatedSource
)
)
{
return
[
]
;
}
var
originalTexts
=
yield
getOriginalTexts
(
generatedSource
generatedText
)
;
return
originalTexts
.
map
(
function
(
_ref7
)
{
var
text
=
_ref7
.
text
;
var
url
=
_ref7
.
url
;
var
id
=
getSourceByURL
(
state
url
)
.
get
(
"
id
"
)
;
var
contentType
=
"
text
/
javascript
"
;
return
{
text
id
contentType
}
;
}
)
;
}
)
;
return
function
getOriginalSourceTexts
(
_x9
_x10
_x11
)
{
return
_ref6
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
324
)
;
var
workerTask
=
_require
.
workerTask
;
var
_require2
=
__webpack_require__
(
348
)
;
var
getSource
=
_require2
.
getSource
;
var
getSourceByURL
=
_require2
.
getSourceByURL
;
var
_require3
=
__webpack_require__
(
196
)
;
var
isEnabled
=
_require3
.
isEnabled
;
var
getValue
=
_require3
.
getValue
;
var
sourceMapWorker
=
new
Worker
(
getValue
(
"
baseWorkerURL
"
)
+
"
source
-
map
-
worker
.
js
"
)
;
var
sourceMapTask
=
function
(
method
)
{
return
function
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
return
workerTask
(
sourceMapWorker
{
method
args
}
)
;
}
;
}
;
function
makeOriginalSource
(
_ref
)
{
var
url
=
_ref
.
url
;
var
source
=
_ref
.
source
;
var
_ref
id
=
_ref
.
id
;
var
id
=
_ref
id
=
=
=
undefined
?
1
:
_ref
id
;
var
generatedSourceId
=
source
.
id
;
return
{
url
id
:
JSON
.
stringify
(
{
generatedSourceId
id
}
)
isPrettyPrinted
:
false
}
;
}
var
getOriginalSourcePosition
=
sourceMapTask
(
"
getOriginalSourcePosition
"
)
;
var
getGeneratedSourceLocation
=
sourceMapTask
(
"
getGeneratedSourceLocation
"
)
;
var
createOriginalSources
=
sourceMapTask
(
"
createOriginalSources
"
)
;
var
getOriginalSourceUrls
=
sourceMapTask
(
"
getOriginalSourceUrls
"
)
;
var
getOriginalTexts
=
sourceMapTask
(
"
getOriginalTexts
"
)
;
var
isOriginal
=
sourceMapTask
(
"
isOriginal
"
)
;
var
isGenerated
=
sourceMapTask
(
"
isGenerated
"
)
;
var
getGeneratedSourceId
=
sourceMapTask
(
"
getGeneratedSourceId
"
)
;
var
createSourceMap
=
sourceMapTask
(
"
createSourceMap
"
)
;
var
clearData
=
sourceMapTask
(
"
clearData
"
)
;
function
_shouldSourceMap
(
generatedSource
)
{
return
isEnabled
(
"
features
.
sourceMaps
"
)
&
&
generatedSource
.
sourceMapURL
;
}
module
.
exports
=
{
getGeneratedLocation
getOriginalLocation
makeOriginalSource
getOriginalSources
getGeneratedSource
getOriginalSourceTexts
getOriginalSourcePosition
getGeneratedSourceLocation
createOriginalSources
getOriginalSourceUrls
getOriginalTexts
isOriginal
isGenerated
getGeneratedSourceId
createSourceMap
clearData
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
338
)
;
var
_require
=
__webpack_require__
(
324
)
;
var
asPaused
=
_require
.
asPaused
;
var
_require2
=
__webpack_require__
(
334
)
;
var
reportException
=
_require2
.
reportException
;
var
_require3
=
__webpack_require__
(
246
)
;
var
Task
=
_require3
.
Task
;
var
FETCH_EVENT_LISTENERS_DELAY
=
200
;
function
fetchEventListeners
(
)
{
return
(
dispatch
getState
)
=
>
{
setNamedTimeout
(
"
event
-
listeners
-
fetch
"
FETCH_EVENT_LISTENERS_DELAY
(
)
=
>
{
if
(
getState
(
)
.
eventListeners
.
fetchingListeners
)
{
dispatch
(
{
type
:
services
.
WAIT_UNTIL
predicate
:
action
=
>
action
.
type
=
=
=
constants
.
FETCH_EVENT_LISTENERS
&
&
action
.
status
=
=
=
"
done
"
run
:
dispatch
=
>
dispatch
(
fetchEventListeners
(
)
)
}
)
;
return
;
}
dispatch
(
{
type
:
constants
.
FETCH_EVENT_LISTENERS
status
:
"
begin
"
}
)
;
asPaused
(
gThreadClient
_getListeners
)
.
then
(
listeners
=
>
{
window
.
emit
(
EVENTS
.
EVENT_LISTENERS_FETCHED
)
;
dispatch
(
{
type
:
constants
.
FETCH_EVENT_LISTENERS
status
:
"
done
"
listeners
:
listeners
}
)
;
}
)
;
}
)
;
}
;
}
var
_getListeners
=
Task
.
async
(
function
*
(
)
{
var
response
=
yield
gThreadClient
.
eventListeners
(
)
;
response
.
listeners
.
sort
(
(
a
b
)
=
>
a
.
type
>
b
.
type
?
1
:
-
1
)
;
var
fetchedDefinitions
=
new
Map
(
)
;
var
listeners
=
[
]
;
for
(
var
listener
of
response
.
listeners
)
{
var
definitionSite
=
void
0
;
if
(
fetchedDefinitions
.
has
(
listener
.
function
.
actor
)
)
{
definitionSite
=
fetchedDefinitions
.
get
(
listener
.
function
.
actor
)
;
}
else
if
(
listener
.
function
.
class
=
=
"
Function
"
)
{
definitionSite
=
yield
_getDefinitionSite
(
listener
.
function
)
;
if
(
!
definitionSite
)
{
continue
;
}
fetchedDefinitions
.
set
(
listener
.
function
.
actor
definitionSite
)
;
}
listener
.
function
.
url
=
definitionSite
;
listeners
.
push
(
listener
)
;
}
fetchedDefinitions
.
clear
(
)
;
return
listeners
;
}
)
;
var
_getDefinitionSite
=
Task
.
async
(
function
*
(
func
)
{
var
grip
=
gThreadClient
.
pauseGrip
(
func
)
;
var
response
=
void
0
;
try
{
response
=
yield
grip
.
getDefinitionSite
(
)
;
}
catch
(
e
)
{
reportException
(
"
_getDefinitionSite
"
e
)
;
return
null
;
}
return
response
.
source
.
url
;
}
)
;
function
updateEventBreakpoints
(
eventNames
)
{
return
dispatch
=
>
{
setNamedTimeout
(
"
event
-
breakpoints
-
update
"
0
(
)
=
>
{
gThreadClient
.
pauseOnDOMEvents
(
eventNames
function
(
)
{
window
.
emit
(
EVENTS
.
EVENT_BREAKPOINTS_UPDATED
)
;
dispatch
(
{
type
:
constants
.
UPDATE_EVENT_BREAKPOINTS
eventNames
:
eventNames
}
)
;
}
)
;
}
)
;
}
;
}
module
.
exports
=
{
updateEventBreakpoints
fetchEventListeners
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
_prettyPrintSource
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
_ref2
)
{
var
source
=
_ref2
.
source
;
var
sourceText
=
_ref2
.
sourceText
;
var
url
=
_ref2
.
url
;
var
contentType
=
sourceText
?
sourceText
.
contentType
:
null
;
var
indent
=
2
;
invariant
(
isJavaScript
(
source
.
url
contentType
)
"
Can
'
t
prettify
non
-
javascript
files
.
"
)
;
var
_ref3
=
yield
workerTask
(
new
Worker
(
"
public
/
build
/
pretty
-
print
-
worker
.
js
"
)
{
url
indent
source
:
sourceText
.
text
}
)
;
var
code
=
_ref3
.
code
;
var
mappings
=
_ref3
.
mappings
;
yield
createSourceMap
(
{
source
mappings
code
}
)
;
return
code
;
}
)
;
return
function
_prettyPrintSource
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
defer
=
__webpack_require__
(
261
)
;
var
_require
=
__webpack_require__
(
332
)
;
var
PROMISE
=
_require
.
PROMISE
;
var
_require2
=
__webpack_require__
(
246
)
;
var
Task
=
_require2
.
Task
;
var
_require3
=
__webpack_require__
(
365
)
;
var
isJavaScript
=
_require3
.
isJavaScript
;
var
_require4
=
__webpack_require__
(
323
)
;
var
networkRequest
=
_require4
.
networkRequest
;
var
_require5
=
__webpack_require__
(
324
)
;
var
workerTask
=
_require5
.
workerTask
;
var
constants
=
__webpack_require__
(
338
)
;
var
invariant
=
__webpack_require__
(
175
)
;
var
_require6
=
__webpack_require__
(
196
)
;
var
isEnabled
=
_require6
.
isEnabled
;
var
_require7
=
__webpack_require__
(
362
)
;
var
createOriginalSources
=
_require7
.
createOriginalSources
;
var
getOriginalSourceTexts
=
_require7
.
getOriginalSourceTexts
;
var
createSourceMap
=
_require7
.
createSourceMap
;
var
makeOriginalSource
=
_require7
.
makeOriginalSource
;
var
getGeneratedSource
=
_require7
.
getGeneratedSource
;
var
_require8
=
__webpack_require__
(
348
)
;
var
getSource
=
_require8
.
getSource
;
var
getSourceByURL
=
_require8
.
getSourceByURL
;
var
getSourceText
=
_require8
.
getSourceText
;
var
getPendingSelectedSourceURL
=
_require8
.
getPendingSelectedSourceURL
;
var
getSourceMap
=
_require8
.
getSourceMap
;
var
getSourceMapURL
=
_require8
.
getSourceMapURL
;
function
_shouldSourceMap
(
generatedSource
)
{
return
isEnabled
(
"
features
.
sourceMaps
"
)
&
&
generatedSource
.
sourceMapURL
;
}
function
_addSource
(
source
)
{
return
{
type
:
constants
.
ADD_SOURCE
source
}
;
}
function
newSource
(
source
)
{
return
_ref4
=
>
{
var
dispatch
=
_ref4
.
dispatch
;
var
getState
=
_ref4
.
getState
;
if
(
_shouldSourceMap
(
source
)
)
{
dispatch
(
loadSourceMap
(
source
)
)
;
}
dispatch
(
_addSource
(
source
)
)
;
var
pendingURL
=
getPendingSelectedSourceURL
(
getState
(
)
)
;
if
(
pendingURL
=
=
=
source
.
url
)
{
dispatch
(
selectSource
(
source
.
id
)
)
;
}
}
;
}
function
loadSourceMap
(
generatedSource
)
{
return
_ref5
=
>
{
var
dispatch
=
_ref5
.
dispatch
;
var
getState
=
_ref5
.
getState
;
var
sourceMap
=
getSourceMap
(
getState
(
)
generatedSource
.
id
)
;
if
(
sourceMap
)
{
return
;
}
dispatch
(
{
type
:
constants
.
LOAD_SOURCE_MAP
source
:
generatedSource
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
var
sourceMapURL
=
getSourceMapURL
(
getState
(
)
generatedSource
)
;
sourceMap
=
yield
networkRequest
(
sourceMapURL
)
;
var
originalSources
=
yield
createOriginalSources
(
generatedSource
sourceMap
)
;
originalSources
.
forEach
(
function
(
s
)
{
return
dispatch
(
newSource
(
s
)
)
;
}
)
;
return
{
sourceMap
}
;
}
)
(
)
}
)
;
}
;
}
function
selectSourceURL
(
url
)
{
return
_ref7
=
>
{
var
dispatch
=
_ref7
.
dispatch
;
var
getState
=
_ref7
.
getState
;
var
source
=
getSourceByURL
(
getState
(
)
url
)
;
if
(
source
)
{
dispatch
(
selectSource
(
source
.
get
(
"
id
"
)
)
)
;
}
else
{
dispatch
(
{
type
:
constants
.
SELECT_SOURCE_URL
url
:
url
}
)
;
}
}
;
}
function
selectSource
(
id
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
return
_ref8
=
>
{
var
dispatch
=
_ref8
.
dispatch
;
var
getState
=
_ref8
.
getState
;
var
client
=
_ref8
.
client
;
if
(
!
client
)
{
return
;
}
var
source
=
getSource
(
getState
(
)
id
)
.
toJS
(
)
;
dispatch
(
loadSourceText
(
source
)
)
;
dispatch
(
{
type
:
constants
.
SELECT_SOURCE
source
:
source
options
}
)
;
}
;
}
function
closeTab
(
id
)
{
return
{
type
:
constants
.
CLOSE_TAB
id
:
id
}
;
}
function
blackbox
(
source
shouldBlackBox
)
{
return
_ref9
=
>
{
var
dispatch
=
_ref9
.
dispatch
;
var
client
=
_ref9
.
client
;
dispatch
(
{
type
:
constants
.
BLACKBOX
source
:
source
[
PROMISE
]
:
Task
.
spawn
(
function
*
(
)
{
yield
shouldBlackBox
?
client
.
blackBox
(
source
.
id
)
:
client
.
unblackBox
(
source
.
id
)
;
return
{
isBlackBoxed
:
shouldBlackBox
}
;
}
)
}
)
;
}
;
}
function
togglePrettyPrint
(
id
)
{
return
_ref10
=
>
{
var
dispatch
=
_ref10
.
dispatch
;
var
getState
=
_ref10
.
getState
;
var
client
=
_ref10
.
client
;
var
source
=
getSource
(
getState
(
)
id
)
.
toJS
(
)
;
if
(
!
isEnabled
(
"
features
.
prettyPrint
"
)
|
|
source
.
isPrettyPrinted
)
{
return
{
}
;
}
var
url
=
source
.
url
+
"
:
formatted
"
;
var
originalSource
=
makeOriginalSource
(
{
url
source
}
)
;
dispatch
(
_addSource
(
originalSource
)
)
;
return
dispatch
(
{
type
:
constants
.
TOGGLE_PRETTY_PRINT
source
originalSource
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
var
sourceText
=
getSourceText
(
getState
(
)
source
.
id
)
.
toJS
(
)
;
var
text
=
yield
_prettyPrintSource
(
{
source
sourceText
url
}
)
;
dispatch
(
selectSource
(
originalSource
.
id
)
)
;
var
originalSourceText
=
{
id
:
originalSource
.
id
contentType
:
"
text
/
javascript
"
text
}
;
return
{
isPrettyPrinted
:
true
sourceText
:
originalSourceText
}
;
}
)
(
)
}
)
;
}
;
}
function
loadSourceText
(
source
)
{
return
_ref12
=
>
{
var
dispatch
=
_ref12
.
dispatch
;
var
getState
=
_ref12
.
getState
;
var
client
=
_ref12
.
client
;
var
textInfo
=
getSourceText
(
getState
(
)
source
.
id
)
;
if
(
textInfo
)
{
return
Promise
.
resolve
(
textInfo
)
;
}
return
dispatch
(
{
type
:
constants
.
LOAD_SOURCE_TEXT
source
:
source
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
var
generatedSource
=
yield
getGeneratedSource
(
getState
(
)
source
)
;
var
response
=
yield
client
.
sourceContents
(
generatedSource
.
id
)
;
var
generatedSourceText
=
{
text
:
response
.
source
contentType
:
response
.
contentType
|
|
"
text
/
javascript
"
id
:
generatedSource
.
id
}
;
var
originalSourceTexts
=
yield
getOriginalSourceTexts
(
getState
(
)
generatedSource
generatedSourceText
.
text
)
;
return
{
generatedSourceText
originalSourceTexts
}
;
}
)
(
)
}
)
;
}
;
}
var
FETCH_SOURCE_RESPONSE_DELAY
=
200
;
function
getTextForSources
(
actors
)
{
return
_ref14
=
>
{
var
dispatch
=
_ref14
.
dispatch
;
var
getState
=
_ref14
.
getState
;
var
deferred
=
defer
(
)
;
var
pending
=
new
Set
(
actors
)
;
var
fetched
=
[
]
;
var
_loop
=
function
(
actor
)
{
var
source
=
getSource
(
getState
(
)
actor
)
;
dispatch
(
loadSourceText
(
source
)
)
.
then
(
_ref23
=
>
{
var
text
=
_ref23
.
text
;
var
contentType
=
_ref23
.
contentType
;
onFetch
(
[
source
text
contentType
]
)
;
}
err
=
>
{
onError
(
source
err
)
;
}
)
;
}
;
for
(
var
actor
of
actors
)
{
_loop
(
actor
)
;
}
setTimeout
(
onTimeout
FETCH_SOURCE_RESPONSE_DELAY
)
;
function
onTimeout
(
)
{
pending
=
new
Set
(
)
;
maybeFinish
(
)
;
}
function
onFetch
(
_ref15
)
{
var
_ref16
=
_slicedToArray
(
_ref15
3
)
;
var
aSource
=
_ref16
[
0
]
;
var
aText
=
_ref16
[
1
]
;
var
aContentType
=
_ref16
[
2
]
;
if
(
!
pending
.
has
(
aSource
.
actor
)
)
{
return
;
}
pending
.
delete
(
aSource
.
actor
)
;
fetched
.
push
(
[
aSource
.
actor
aText
aContentType
]
)
;
maybeFinish
(
)
;
}
function
onError
(
_ref17
)
{
var
_ref18
=
_slicedToArray
(
_ref17
2
)
;
var
aSource
=
_ref18
[
0
]
;
var
aError
=
_ref18
[
1
]
;
pending
.
delete
(
aSource
.
actor
)
;
maybeFinish
(
)
;
}
function
maybeFinish
(
)
{
if
(
pending
.
size
=
=
0
)
{
deferred
.
resolve
(
fetched
.
sort
(
(
_ref19
_ref20
)
=
>
{
var
_ref22
=
_slicedToArray
(
_ref19
1
)
;
var
aFirst
=
_ref22
[
0
]
;
var
_ref21
=
_slicedToArray
(
_ref20
1
)
;
var
aSecond
=
_ref21
[
0
]
;
return
aFirst
>
aSecond
;
}
)
)
;
}
}
return
deferred
.
promise
;
}
;
}
module
.
exports
=
{
newSource
selectSource
selectSourceURL
closeTab
blackbox
togglePrettyPrint
loadSourceText
getTextForSources
}
;
}
function
(
module
exports
)
{
function
trimUrlQuery
(
url
)
{
var
length
=
url
.
length
;
var
q1
=
url
.
indexOf
(
"
?
"
)
;
var
q2
=
url
.
indexOf
(
"
&
"
)
;
var
q3
=
url
.
indexOf
(
"
#
"
)
;
var
q
=
Math
.
min
(
q1
!
=
-
1
?
q1
:
length
q2
!
=
-
1
?
q2
:
length
q3
!
=
-
1
?
q3
:
length
)
;
return
url
.
slice
(
0
q
)
;
}
function
isJavaScript
(
url
)
{
var
contentType
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
"
"
:
arguments
[
1
]
;
return
url
&
&
/
\
.
jsm
?
/
.
test
(
trimUrlQuery
(
url
)
)
|
|
contentType
.
includes
(
"
javascript
"
)
;
}
module
.
exports
=
{
isJavaScript
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
338
)
;
function
newTabs
(
tabs
)
{
return
{
type
:
constants
.
ADD_TABS
value
:
tabs
}
;
}
function
selectTab
(
_ref
)
{
var
id
=
_ref
.
id
;
return
{
type
:
constants
.
SELECT_TAB
id
:
id
}
;
}
module
.
exports
=
{
newTabs
selectTab
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
updateFrame
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
state
frame
)
{
var
originalLocation
=
yield
getOriginalLocation
(
state
frame
.
location
)
;
return
Frame
.
update
(
frame
{
merge
:
{
location
:
Location
(
originalLocation
)
}
}
)
;
}
)
;
return
function
updateFrame
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
constants
=
__webpack_require__
(
338
)
;
var
_require
=
__webpack_require__
(
364
)
;
var
selectSource
=
_require
.
selectSource
;
var
_require2
=
__webpack_require__
(
332
)
;
var
PROMISE
=
_require2
.
PROMISE
;
var
_require3
=
__webpack_require__
(
263
)
;
var
Location
=
_require3
.
Location
;
var
Frame
=
_require3
.
Frame
;
var
_require4
=
__webpack_require__
(
348
)
;
var
getExpressions
=
_require4
.
getExpressions
;
var
_require5
=
__webpack_require__
(
362
)
;
var
getOriginalLocation
=
_require5
.
getOriginalLocation
;
var
_require6
=
__webpack_require__
(
324
)
;
var
asyncMap
=
_require6
.
asyncMap
;
function
resumed
(
)
{
return
_ref2
=
>
{
var
dispatch
=
_ref2
.
dispatch
;
var
client
=
_ref2
.
client
;
return
dispatch
(
{
type
:
constants
.
RESUME
value
:
undefined
}
)
;
}
;
}
function
paused
(
pauseInfo
)
{
return
_ref3
=
>
{
var
dispatch
=
_ref3
.
dispatch
;
var
getState
=
_ref3
.
getState
;
var
client
=
_ref3
.
client
;
var
frame
=
pauseInfo
.
frame
;
var
frames
=
pauseInfo
.
frames
;
var
why
=
pauseInfo
.
why
;
dispatch
(
evaluateExpressions
(
)
)
;
return
dispatch
(
{
type
:
constants
.
PAUSED
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
frame
=
yield
updateFrame
(
getState
(
)
frame
)
;
frames
=
yield
asyncMap
(
frames
function
(
item
)
{
return
updateFrame
(
getState
(
)
item
)
;
}
)
;
dispatch
(
selectSource
(
frame
.
location
.
sourceId
)
)
;
return
{
pauseInfo
:
{
why
frame
}
frames
:
frames
}
;
}
)
(
)
}
)
;
}
;
}
function
pauseOnExceptions
(
toggle
)
{
return
_ref5
=
>
{
var
dispatch
=
_ref5
.
dispatch
;
var
getState
=
_ref5
.
getState
;
var
client
=
_ref5
.
client
;
client
.
pauseOnExceptions
(
toggle
)
;
return
dispatch
(
{
type
:
constants
.
PAUSE_ON_EXCEPTIONS
toggle
}
)
;
}
;
}
function
command
(
_ref6
)
{
var
type
=
_ref6
.
type
;
return
_ref7
=
>
{
var
dispatch
=
_ref7
.
dispatch
;
var
client
=
_ref7
.
client
;
client
[
type
]
(
)
;
return
dispatch
(
{
type
:
constants
.
COMMAND
value
:
undefined
}
)
;
}
;
}
function
breakOnNext
(
)
{
return
_ref8
=
>
{
var
dispatch
=
_ref8
.
dispatch
;
var
client
=
_ref8
.
client
;
client
.
breakOnNext
(
)
;
return
dispatch
(
{
type
:
constants
.
BREAK_ON_NEXT
value
:
true
}
)
;
}
;
}
function
selectFrame
(
frame
)
{
return
_ref9
=
>
{
var
dispatch
=
_ref9
.
dispatch
;
dispatch
(
selectSource
(
frame
.
location
.
sourceId
{
line
:
frame
.
location
.
line
}
)
)
;
dispatch
(
{
type
:
constants
.
SELECT_FRAME
frame
:
frame
}
)
;
}
;
}
function
loadObjectProperties
(
grip
)
{
return
_ref10
=
>
{
var
dispatch
=
_ref10
.
dispatch
;
var
client
=
_ref10
.
client
;
dispatch
(
{
type
:
constants
.
LOAD_OBJECT_PROPERTIES
objectId
:
grip
.
actor
[
PROMISE
]
:
client
.
getProperties
(
grip
)
}
)
;
}
;
}
function
addExpression
(
expression
)
{
return
_ref11
=
>
{
var
dispatch
=
_ref11
.
dispatch
;
var
getState
=
_ref11
.
getState
;
var
id
=
expression
.
id
!
=
=
undefined
?
parseInt
(
expression
.
id
10
)
:
getExpressions
(
getState
(
)
)
.
toSeq
(
)
.
size
+
+
;
dispatch
(
{
type
:
constants
.
ADD_EXPRESSION
id
:
id
input
:
expression
.
input
}
)
;
dispatch
(
evaluateExpressions
(
)
)
;
}
;
}
function
updateExpression
(
expression
)
{
return
_ref12
=
>
{
var
dispatch
=
_ref12
.
dispatch
;
dispatch
(
{
type
:
constants
.
UPDATE_EXPRESSION
id
:
expression
.
id
input
:
expression
.
input
}
)
;
}
;
}
function
deleteExpression
(
expression
)
{
return
_ref13
=
>
{
var
dispatch
=
_ref13
.
dispatch
;
dispatch
(
{
type
:
constants
.
DELETE_EXPRESSION
id
:
expression
.
id
}
)
;
}
;
}
function
evaluateExpressions
(
)
{
return
_ref14
=
>
{
var
dispatch
=
_ref14
.
dispatch
;
var
getState
=
_ref14
.
getState
;
var
client
=
_ref14
.
client
;
for
(
var
expression
of
getExpressions
(
getState
(
)
)
)
{
dispatch
(
{
type
:
constants
.
EVALUATE_EXPRESSION
id
:
expression
.
id
input
:
expression
.
input
[
PROMISE
]
:
client
.
evaluate
(
expression
.
input
)
}
)
;
}
}
;
}
module
.
exports
=
{
addExpression
updateExpression
deleteExpression
resumed
paused
pauseOnExceptions
command
breakOnNext
selectFrame
loadObjectProperties
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
338
)
;
var
_require
=
__webpack_require__
(
362
)
;
var
clearData
=
_require
.
clearData
;
function
willNavigate
(
)
{
clearData
(
)
;
return
{
type
:
constants
.
NAVIGATE
}
;
}
function
navigate
(
)
{
return
_ref
=
>
{
var
dispatch
=
_ref
.
dispatch
;
}
;
}
module
.
exports
=
{
willNavigate
navigate
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
370
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
App
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
App
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
/
*
vim
:
set
ts
=
2
sw
=
2
sts
=
2
et
:
*
/
\
n
\
n
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
\
n
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
file
\
n
*
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
\
n
\
n
*
{
\
n
box
-
sizing
:
border
-
box
;
\
n
}
\
n
\
nhtml
\
nbody
{
\
n
font
-
family
:
\
"
SF
UI
Text
\
"
sans
-
serif
;
\
n
height
:
100
%
;
\
n
margin
:
0
;
\
n
padding
:
0
;
\
n
width
:
100
%
;
\
n
}
\
n
\
n
#
mount
{
\
n
display
:
flex
;
\
n
height
:
100
%
;
\
n
}
\
n
\
n
.
debugger
{
\
n
display
:
flex
;
\
n
flex
:
1
;
\
n
}
\
n
\
n
.
center
-
pane
{
\
n
display
:
flex
;
\
n
position
:
relative
;
\
n
flex
:
1
;
\
n
background
-
color
:
#
fcfcfc
;
\
n
}
\
n
\
n
.
editor
-
container
{
\
n
display
:
flex
;
\
n
flex
:
1
;
\
n
}
\
n
\
n
.
subsettings
:
hover
{
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
source
-
footer
{
\
n
background
:
white
;
\
n
position
:
absolute
;
\
n
bottom
:
0
;
\
n
right
:
0
;
\
n
z
-
index
:
100
;
\
n
width
:
100px
;
\
n
opacity
:
0
.
9
;
\
n
}
\
n
\
n
.
source
-
footer
.
command
-
bar
{
\
n
float
:
right
;
\
n
}
\
n
\
n
.
command
-
bar
>
span
{
\
n
cursor
:
pointer
;
\
n
margin
-
right
:
0
.
7em
;
\
n
width
:
1em
;
\
n
height
:
1
.
1em
;
\
n
display
:
inline
-
block
;
\
n
text
-
align
:
center
;
\
n
transition
:
opacity
200ms
;
\
n
}
\
n
\
n
.
welcomebox
{
\
n
margin
:
50px
auto
;
\
n
padding
:
20px
;
\
n
font
-
size
:
1em
;
\
n
color
:
var
(
-
-
theme
-
gray
-
darker
)
;
\
n
font
-
weight
:
lighter
;
\
n
text
-
align
:
center
;
\
n
width
:
100
%
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
372
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
variables
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
variables
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
/
*
vim
:
set
ts
=
2
sw
=
2
sts
=
2
et
:
*
/
\
n
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
\
n
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
\
n
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
\
n
\
n
/
*
Variable
declarations
for
light
and
dark
devtools
themes
.
\
n
*
Colors
are
taken
from
:
\
n
*
https
:
/
/
developer
.
mozilla
.
org
/
en
-
US
/
docs
/
Tools
/
DevToolsColors
.
\
n
*
Changes
should
be
kept
in
sync
with
commandline
.
css
and
commandline
.
inc
.
css
.
\
n
*
/
\
n
\
n
/
*
IMPORTANT
NOTE
:
\
n
*
This
file
is
parsed
in
js
(
see
client
/
shared
/
theme
.
js
)
\
n
*
so
the
formatting
should
be
consistent
(
i
.
e
.
no
'
}
'
inside
a
rule
)
.
\
n
*
/
\
n
\
n
:
root
.
theme
-
light
{
\
n
-
-
theme
-
body
-
background
:
white
;
\
n
-
-
theme
-
sidebar
-
background
:
white
;
\
n
-
-
theme
-
contrast
-
background
:
#
e6b064
;
\
n
\
n
-
-
theme
-
tab
-
toolbar
-
background
:
#
fcfcfc
;
\
n
-
-
theme
-
toolbar
-
background
:
#
fcfcfc
;
\
n
-
-
theme
-
selection
-
background
:
#
4c9ed9
;
\
n
-
-
theme
-
selection
-
background
-
semitransparent
:
rgba
(
76
158
217
0
.
15
)
;
\
n
-
-
theme
-
selection
-
color
:
#
f5f7fa
;
\
n
-
-
theme
-
splitter
-
color
:
#
dde1e4
;
\
n
-
-
theme
-
breakpoint
-
background
:
#
fafafa
;
\
n
-
-
theme
-
comment
:
#
696969
;
\
n
\
n
-
-
theme
-
body
-
color
:
#
393f4c
;
\
n
-
-
theme
-
body
-
color
-
alt
:
#
585959
;
\
n
-
-
theme
-
body
-
color
-
inactive
:
#
999797
;
\
n
-
-
theme
-
content
-
color1
:
#
292e33
;
\
n
-
-
theme
-
content
-
color2
:
#
8fa1b2
;
\
n
-
-
theme
-
content
-
color3
:
#
667380
;
\
n
\
n
-
-
theme
-
gray
:
#
dde1e4
;
\
n
-
-
theme
-
gray
-
darker
:
#
ccd1d5
;
\
n
\
n
-
-
theme
-
highlight
-
green
:
#
2cbb0f
;
\
n
-
-
theme
-
highlight
-
blue
:
#
0088cc
;
\
n
-
-
theme
-
highlight
-
bluegrey
:
#
0072ab
;
\
n
-
-
theme
-
highlight
-
purple
:
#
5b5fff
;
\
n
-
-
theme
-
highlight
-
lightorange
:
#
d97e00
;
\
n
-
-
theme
-
highlight
-
orange
:
#
f13c00
;
\
n
-
-
theme
-
highlight
-
red
:
#
ed2655
;
\
n
-
-
theme
-
highlight
-
pink
:
#
b82ee5
;
\
n
\
n
/
*
Colors
used
in
Graphs
like
performance
tools
.
Similar
colors
to
Chrome
'
s
timeline
.
*
/
\
n
-
-
theme
-
graphs
-
green
:
#
85d175
;
\
n
-
-
theme
-
graphs
-
blue
:
#
83b7f6
;
\
n
-
-
theme
-
graphs
-
bluegrey
:
#
0072ab
;
\
n
-
-
theme
-
graphs
-
purple
:
#
b693eb
;
\
n
-
-
theme
-
graphs
-
yellow
:
#
efc052
;
\
n
-
-
theme
-
graphs
-
orange
:
#
d97e00
;
\
n
-
-
theme
-
graphs
-
red
:
#
e57180
;
\
n
-
-
theme
-
graphs
-
grey
:
#
cccccc
;
\
n
-
-
theme
-
graphs
-
full
-
red
:
#
f00
;
\
n
-
-
theme
-
graphs
-
full
-
blue
:
#
00f
;
\
n
\
n
-
-
breakpoint
-
active
-
color
:
rgba
(
44
187
15
.
1
)
;
\
n
}
\
n
\
n
:
root
.
theme
-
dark
{
\
n
-
-
theme
-
body
-
background
:
#
393f4c
;
\
n
-
-
theme
-
sidebar
-
background
:
#
393f4c
;
\
n
-
-
theme
-
contrast
-
background
:
#
ffb35b
;
\
n
\
n
-
-
theme
-
tab
-
toolbar
-
background
:
#
272b35
;
\
n
-
-
theme
-
toolbar
-
background
:
#
272b35
;
\
n
-
-
theme
-
selection
-
background
:
#
5675B9
;
\
n
-
-
theme
-
selection
-
background
-
semitransparent
:
rgba
(
86
117
185
0
.
5
)
;
\
n
-
-
theme
-
selection
-
color
:
#
f5f7fa
;
\
n
-
-
theme
-
splitter
-
color
:
#
454d5d
;
\
n
-
-
theme
-
breakpoint
-
background
:
#
fafafa
;
/
*
Match
not
found
*
/
\
n
-
-
theme
-
comment
:
#
757873
;
\
n
\
n
-
-
theme
-
body
-
color
:
#
8fa1b2
;
\
n
-
-
theme
-
body
-
color
-
alt
:
#
b6babf
;
\
n
-
-
theme
-
body
-
color
-
inactive
:
#
8fa1b2
;
\
n
-
-
theme
-
content
-
color1
:
#
a9bacb
;
\
n
-
-
theme
-
content
-
color2
:
#
8fa1b2
;
\
n
-
-
theme
-
content
-
color3
:
#
5f7387
;
\
n
\
n
-
-
theme
-
gray
:
#
dde1e4
;
/
*
Match
not
found
*
/
\
n
-
-
theme
-
gray
-
darker
:
#
ccd1d5
;
/
*
Match
not
found
*
/
\
n
\
n
-
-
theme
-
highlight
-
green
:
#
00ff7f
;
\
n
-
-
theme
-
highlight
-
blue
:
#
46afe3
;
\
n
-
-
theme
-
highlight
-
bluegrey
:
#
5e88b0
;
\
n
-
-
theme
-
highlight
-
purple
:
#
bcb8db
;
\
n
-
-
theme
-
highlight
-
lightorange
:
#
d99b28
;
\
n
-
-
theme
-
highlight
-
orange
:
#
d96629
;
\
n
-
-
theme
-
highlight
-
red
:
#
eb5368
;
\
n
-
-
theme
-
highlight
-
pink
:
#
df80ff
;
\
n
-
-
theme
-
highlight
-
gray
:
#
e9f4fe
;
\
n
\
n
/
*
Colors
used
in
Graphs
like
performance
tools
.
Similar
colors
to
Chrome
'
s
timeline
.
*
/
\
n
-
-
theme
-
graphs
-
green
:
#
70bf53
;
\
n
-
-
theme
-
graphs
-
blue
:
#
46afe3
;
\
n
-
-
theme
-
graphs
-
bluegrey
:
#
5e88b0
;
\
n
-
-
theme
-
graphs
-
purple
:
#
df80ff
;
\
n
-
-
theme
-
graphs
-
yellow
:
#
d99b28
;
\
n
-
-
theme
-
graphs
-
orange
:
#
d96629
;
\
n
-
-
theme
-
graphs
-
red
:
#
eb5368
;
\
n
-
-
theme
-
graphs
-
grey
:
#
757873
;
\
n
-
-
theme
-
graphs
-
full
-
red
:
#
f00
;
\
n
-
-
theme
-
graphs
-
full
-
blue
:
#
00f
;
\
n
\
n
-
-
breakpoint
-
active
-
color
:
rgba
(
44
187
15
.
1
)
;
/
*
Match
not
found
*
/
\
n
}
\
n
\
n
:
root
.
theme
-
firebug
{
\
n
-
-
theme
-
body
-
background
:
#
fcfcfc
;
\
n
-
-
theme
-
sidebar
-
background
:
#
fcfcfc
;
\
n
-
-
theme
-
contrast
-
background
:
#
e6b064
;
\
n
\
n
-
-
theme
-
tab
-
toolbar
-
background
:
#
ebeced
;
\
n
-
-
theme
-
toolbar
-
background
:
#
f0f1f2
;
\
n
-
-
theme
-
selection
-
background
:
#
3399ff
;
\
n
-
-
theme
-
selection
-
background
-
semitransparent
:
rgba
(
128
128
128
0
.
2
)
;
\
n
-
-
theme
-
selection
-
color
:
white
;
\
n
-
-
theme
-
splitter
-
color
:
#
aabccf
;
\
n
-
-
theme
-
comment
:
green
;
\
n
\
n
-
-
theme
-
body
-
color
:
#
18191a
;
\
n
-
-
theme
-
body
-
color
-
alt
:
#
585959
;
\
n
-
-
theme
-
content
-
color1
:
#
292e33
;
\
n
-
-
theme
-
content
-
color2
:
#
8fa1b2
;
\
n
-
-
theme
-
content
-
color3
:
#
667380
;
\
n
\
n
-
-
theme
-
gray
:
#
dde1e4
;
/
*
Match
not
found
*
/
\
n
-
-
theme
-
gray
-
darker
:
#
ccd1d5
;
/
*
Match
not
found
*
/
\
n
\
n
-
-
theme
-
highlight
-
green
:
#
2cbb0f
;
\
n
-
-
theme
-
highlight
-
blue
:
#
3455db
;
\
n
-
-
theme
-
highlight
-
bluegrey
:
#
0072ab
;
\
n
-
-
theme
-
highlight
-
purple
:
#
887ce6
;
\
n
-
-
theme
-
highlight
-
lightorange
:
#
d97e00
;
\
n
-
-
theme
-
highlight
-
orange
:
#
f13c00
;
\
n
-
-
theme
-
highlight
-
red
:
#
e22f6f
;
\
n
-
-
theme
-
highlight
-
pink
:
#
b82ee5
;
\
n
-
-
theme
-
highlight
-
gray
:
#
dde1e4
;
\
n
\
n
/
*
Colors
used
in
Graphs
like
performance
tools
.
Mostly
similar
to
some
\
"
highlight
-
*
\
"
colors
.
*
/
\
n
-
-
theme
-
graphs
-
green
:
#
70bf53
;
\
n
-
-
theme
-
graphs
-
blue
:
#
46afe3
;
\
n
-
-
theme
-
graphs
-
bluegrey
:
#
5e88b0
;
\
n
-
-
theme
-
graphs
-
purple
:
#
df80ff
;
\
n
-
-
theme
-
graphs
-
yellow
:
#
d99b28
;
\
n
-
-
theme
-
graphs
-
orange
:
#
d96629
;
\
n
-
-
theme
-
graphs
-
red
:
#
eb5368
;
\
n
-
-
theme
-
graphs
-
grey
:
#
757873
;
\
n
-
-
theme
-
graphs
-
full
-
red
:
#
f00
;
\
n
-
-
theme
-
graphs
-
full
-
blue
:
#
00f
;
\
n
\
n
-
-
breakpoint
-
active
-
color
:
rgba
(
44
187
15
.
1
)
;
/
*
Match
not
found
*
/
\
n
}
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
374
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
light
-
theme
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
light
-
theme
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
/
*
vim
:
set
ts
=
2
sw
=
2
sts
=
2
et
:
*
/
\
n
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
\
n
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
\
n
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
\
n
\
nbody
{
\
n
margin
:
0
;
\
n
}
\
n
\
n
.
theme
-
body
{
\
n
background
:
var
(
-
-
theme
-
body
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
sidebar
{
\
n
background
:
var
(
-
-
theme
-
sidebar
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
:
:
-
moz
-
selection
{
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
selection
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
bg
-
darker
{
\
n
background
:
var
(
-
-
theme
-
selection
-
background
-
semitransparent
)
;
\
n
}
\
n
\
n
.
theme
-
selected
\
n
.
CodeMirror
-
hint
-
active
{
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
selection
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
bg
-
contrast
\
n
.
variable
-
or
-
property
:
not
(
[
overridden
]
)
[
changed
]
{
\
n
background
:
var
(
-
-
theme
-
contrast
-
background
)
;
\
n
}
\
n
\
n
.
theme
-
link
\
n
.
cm
-
s
-
mozilla
.
cm
-
link
\
n
.
CodeMirror
-
Tern
-
type
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
}
\
n
\
n
/
*
\
n
*
FIXME
:
http
:
/
/
bugzil
.
la
/
575675
CSS
links
without
:
visited
set
cause
assertion
\
n
*
failures
in
debug
builds
.
\
n
*
/
\
n
.
theme
-
link
:
visited
\
n
.
cm
-
s
-
mozilla
.
cm
-
link
:
visited
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
}
\
n
\
n
.
theme
-
comment
\
n
.
cm
-
s
-
mozilla
.
cm
-
meta
\
n
.
cm
-
s
-
mozilla
.
cm
-
hr
\
n
.
cm
-
s
-
mozilla
.
cm
-
comment
\
n
.
variable
-
or
-
property
.
token
-
undefined
\
n
.
variable
-
or
-
property
.
token
-
null
\
n
.
CodeMirror
-
Tern
-
completion
-
unknown
:
before
{
\
n
color
:
var
(
-
-
theme
-
comment
)
;
\
n
}
\
n
\
n
.
theme
-
gutter
{
\
n
background
-
color
:
var
(
-
-
theme
-
tab
-
toolbar
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
content
-
color3
)
;
\
n
border
-
color
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
separator
{
/
*
grey
*
/
\
n
border
-
color
:
#
cddae5
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
cm
-
unused
-
line
{
\
n
text
-
decoration
:
line
-
through
;
\
n
text
-
decoration
-
color
:
var
(
-
-
theme
-
highlight
-
bluegrey
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
cm
-
executed
-
line
{
\
n
background
-
color
:
#
fcfffc
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color1
\
n
.
cm
-
s
-
mozilla
.
cm
-
number
\
n
.
variable
-
or
-
property
.
token
-
number
\
n
.
variable
-
or
-
property
[
return
]
>
.
title
>
.
name
\
n
.
variable
-
or
-
property
[
scope
]
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
purple
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
number
:
before
{
\
n
background
-
color
:
hsl
(
72
100
%
27
%
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color2
\
n
.
cm
-
s
-
mozilla
.
cm
-
attribute
\
n
.
cm
-
s
-
mozilla
.
cm
-
builtin
\
n
.
cm
-
s
-
mozilla
.
cm
-
property
\
n
.
variables
-
view
-
variable
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
red
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
cm
-
def
{
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
object
:
before
{
\
n
background
-
color
:
hsl
(
208
56
%
40
%
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color3
\
n
.
cm
-
s
-
mozilla
.
cm
-
variable
\
n
.
cm
-
s
-
mozilla
.
cm
-
tag
\
n
.
cm
-
s
-
mozilla
.
cm
-
header
\
n
.
cm
-
s
-
mozilla
.
cm
-
bracket
\
n
.
cm
-
s
-
mozilla
.
cm
-
qualifier
\
n
.
variables
-
view
-
property
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
array
:
before
{
\
n
background
-
color
:
var
(
-
-
theme
-
highlight
-
bluegrey
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color4
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
orange
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color5
\
n
.
cm
-
s
-
mozilla
.
cm
-
keyword
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
red
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color6
\
n
.
cm
-
s
-
mozilla
.
cm
-
string
\
n
.
cm
-
s
-
mozilla
.
cm
-
string
-
2
\
n
.
variable
-
or
-
property
.
token
-
string
\
n
.
CodeMirror
-
Tern
-
farg
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
purple
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
string
:
before
\
n
.
CodeMirror
-
Tern
-
completion
-
fn
:
before
{
\
n
background
-
color
:
hsl
(
24
85
%
39
%
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color7
\
n
.
cm
-
s
-
mozilla
.
cm
-
atom
\
n
.
cm
-
s
-
mozilla
.
cm
-
quote
\
n
.
cm
-
s
-
mozilla
.
cm
-
error
\
n
.
variable
-
or
-
property
.
token
-
boolean
\
n
.
variable
-
or
-
property
.
token
-
domnode
\
n
.
variable
-
or
-
property
[
exception
]
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
red
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
bool
:
before
{
\
n
background
-
color
:
#
bf5656
;
\
n
}
\
n
\
n
.
variable
-
or
-
property
.
token
-
domnode
{
\
n
font
-
weight
:
bold
;
\
n
}
\
n
\
n
.
theme
-
fg
-
contrast
{
/
*
To
be
used
for
text
on
theme
-
bg
-
contrast
*
/
\
n
color
:
black
;
\
n
}
\
n
\
n
.
theme
-
toolbar
\
n
.
devtools
-
toolbar
\
n
.
devtools
-
sidebar
-
tabs
tabs
\
n
.
devtools
-
sidebar
-
alltabs
\
n
.
cm
-
s
-
mozilla
.
CodeMirror
-
dialog
{
/
*
General
toolbar
styling
*
/
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
background
-
color
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
border
-
color
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
}
\
n
\
n
.
ruleview
-
swatch
\
n
.
computedview
-
colorswatch
{
\
n
box
-
shadow
:
0
0
0
1px
#
c4c4c4
;
\
n
}
\
n
\
n
/
*
CodeMirror
specific
styles
.
\
n
*
Best
effort
to
match
the
existing
theme
some
of
the
colors
\
n
*
are
duplicated
here
to
prevent
weirdness
in
the
main
theme
.
*
/
\
n
\
n
.
CodeMirror
.
cm
-
s
-
mozilla
{
/
*
Inherit
platform
specific
font
sizing
and
styles
*
/
\
n
font
-
family
:
inherit
;
\
n
font
-
size
:
inherit
;
\
n
background
:
transparent
;
\
n
}
\
n
\
n
.
CodeMirror
.
cm
-
s
-
mozilla
pre
\
n
.
cm
-
s
-
mozilla
.
cm
-
variable
-
2
\
n
.
cm
-
s
-
mozilla
.
cm
-
variable
-
3
\
n
.
cm
-
s
-
mozilla
.
cm
-
operator
\
n
.
cm
-
s
-
mozilla
.
cm
-
special
{
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
CodeMirror
-
lines
.
CodeMirror
-
cursor
{
\
n
border
-
left
:
solid
1px
black
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
CodeMirror
-
focused
.
CodeMirror
-
selected
{
/
*
selected
text
(
focused
)
*
/
\
n
background
:
rgb
(
185
215
253
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
CodeMirror
-
selected
{
/
*
selected
text
(
unfocused
)
*
/
\
n
background
:
rgb
(
176
176
176
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
CodeMirror
-
activeline
-
background
{
/
*
selected
color
with
alpha
*
/
\
n
background
:
rgba
(
185
215
253
.
35
)
;
\
n
}
\
n
\
ndiv
.
cm
-
s
-
mozilla
span
.
CodeMirror
-
matchingbracket
{
/
*
highlight
brackets
*
/
\
n
outline
:
solid
1px
rgba
(
0
0
0
.
25
)
;
\
n
color
:
black
;
\
n
}
\
n
\
n
/
*
Highlight
for
a
line
that
contains
an
error
.
*
/
\
ndiv
.
CodeMirror
div
.
error
-
line
{
\
n
background
:
rgba
(
255
0
0
0
.
2
)
;
\
n
}
\
n
\
n
/
*
Generic
highlighted
text
*
/
\
ndiv
.
CodeMirror
span
.
marked
-
text
{
\
n
background
:
rgba
(
255
255
0
0
.
2
)
;
\
n
border
:
1px
dashed
rgba
(
192
192
0
0
.
6
)
;
\
n
margin
-
inline
-
start
:
-
1px
;
\
n
margin
-
inline
-
end
:
-
1px
;
\
n
}
\
n
\
n
/
*
Highlight
for
evaluating
current
statement
.
*
/
\
ndiv
.
CodeMirror
span
.
eval
-
text
{
\
n
background
-
color
:
#
ccd
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
CodeMirror
-
linenumber
{
/
*
line
number
text
*
/
\
n
color
:
var
(
-
-
theme
-
content
-
color3
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
mozilla
.
CodeMirror
-
gutters
{
/
*
vertical
line
next
to
line
numbers
*
/
\
n
border
-
right
-
color
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
background
-
color
:
var
(
-
-
theme
-
sidebar
-
background
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
markup
-
view
pre
{
\
n
line
-
height
:
1
.
4em
;
\
n
min
-
height
:
1
.
4em
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
ImPropTypes
=
__webpack_require__
(
376
)
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
SourcesTree
=
React
.
createFactory
(
__webpack_require__
(
377
)
)
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require3
=
__webpack_require__
(
348
)
;
var
getSelectedSource
=
_require3
.
getSelectedSource
;
var
getSources
=
_require3
.
getSources
;
__webpack_require__
(
412
)
;
var
Sources
=
React
.
createClass
(
{
propTypes
:
{
sources
:
ImPropTypes
.
map
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
Sources
"
render
(
)
{
var
_props
=
this
.
props
;
var
sources
=
_props
.
sources
;
var
selectSource
=
_props
.
selectSource
;
return
dom
.
div
(
{
className
:
"
sources
-
panel
"
}
SourcesTree
(
{
sources
selectSource
}
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
selectedSource
:
getSelectedSource
(
state
)
sources
:
getSources
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Sources
)
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
Immutable
=
__webpack_require__
(
341
)
;
var
ANONYMOUS
=
"
<
<
anonymous
>
>
"
;
var
ImmutablePropTypes
=
{
listOf
:
createListOfTypeChecker
mapOf
:
createMapOfTypeChecker
orderedMapOf
:
createOrderedMapOfTypeChecker
setOf
:
createSetOfTypeChecker
orderedSetOf
:
createOrderedSetOfTypeChecker
stackOf
:
createStackOfTypeChecker
iterableOf
:
createIterableOfTypeChecker
recordOf
:
createRecordOfTypeChecker
shape
:
createShapeChecker
contains
:
createShapeChecker
mapContains
:
createMapContainsChecker
list
:
createImmutableTypeChecker
(
"
List
"
Immutable
.
List
.
isList
)
map
:
createImmutableTypeChecker
(
"
Map
"
Immutable
.
Map
.
isMap
)
orderedMap
:
createImmutableTypeChecker
(
"
OrderedMap
"
Immutable
.
OrderedMap
.
isOrderedMap
)
set
:
createImmutableTypeChecker
(
"
Set
"
Immutable
.
Set
.
isSet
)
orderedSet
:
createImmutableTypeChecker
(
"
OrderedSet
"
Immutable
.
OrderedSet
.
isOrderedSet
)
stack
:
createImmutableTypeChecker
(
"
Stack
"
Immutable
.
Stack
.
isStack
)
seq
:
createImmutableTypeChecker
(
"
Seq
"
Immutable
.
Seq
.
isSeq
)
record
:
createImmutableTypeChecker
(
"
Record
"
function
(
isRecord
)
{
return
isRecord
instanceof
Immutable
.
Record
;
}
)
iterable
:
createImmutableTypeChecker
(
"
Iterable
"
Immutable
.
Iterable
.
isIterable
)
}
;
function
getPropType
(
propValue
)
{
var
propType
=
typeof
propValue
;
if
(
Array
.
isArray
(
propValue
)
)
{
return
"
array
"
;
}
if
(
propValue
instanceof
RegExp
)
{
return
"
object
"
;
}
if
(
propValue
instanceof
Immutable
.
Iterable
)
{
return
"
Immutable
.
"
+
propValue
.
toSource
(
)
.
split
(
"
"
)
[
0
]
;
}
return
propType
;
}
function
createChainableTypeChecker
(
validate
)
{
function
checkType
(
isRequired
props
propName
componentName
location
propFullName
)
{
propFullName
=
propFullName
|
|
propName
;
componentName
=
componentName
|
|
ANONYMOUS
;
if
(
props
[
propName
]
=
=
null
)
{
var
locationName
=
location
;
if
(
isRequired
)
{
return
new
Error
(
"
Required
"
+
locationName
+
"
"
+
propFullName
+
"
was
not
specified
in
"
+
(
"
"
+
componentName
+
"
.
"
)
)
;
}
}
else
{
return
validate
(
props
propName
componentName
location
propFullName
)
;
}
}
var
chainedCheckType
=
checkType
.
bind
(
null
false
)
;
chainedCheckType
.
isRequired
=
checkType
.
bind
(
null
true
)
;
return
chainedCheckType
;
}
function
createImmutableTypeChecker
(
immutableClassName
immutableClassTypeValidator
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
if
(
!
immutableClassTypeValidator
(
propValue
)
)
{
var
propType
=
getPropType
(
propValue
)
;
return
new
Error
(
"
Invalid
"
+
location
+
"
"
+
propFullName
+
"
of
type
"
+
propType
+
"
"
+
(
"
supplied
to
"
+
componentName
+
"
expected
"
+
immutableClassName
+
"
.
"
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createIterableTypeChecker
(
typeChecker
immutableClassName
immutableClassTypeValidator
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
if
(
!
immutableClassTypeValidator
(
propValue
)
)
{
var
locationName
=
location
;
var
propType
=
getPropType
(
propValue
)
;
return
new
Error
(
"
Invalid
"
+
locationName
+
"
"
+
propFullName
+
"
of
type
"
+
(
"
"
+
propType
+
"
supplied
to
"
+
componentName
+
"
expected
an
Immutable
.
js
"
+
immutableClassName
+
"
.
"
)
)
;
}
if
(
typeof
typeChecker
!
=
=
"
function
"
)
{
return
new
Error
(
"
Invalid
typeChecker
supplied
to
"
+
componentName
+
"
"
+
(
"
for
propType
"
+
propFullName
+
"
expected
a
function
.
"
)
)
;
}
var
propValues
=
propValue
.
toArray
(
)
;
for
(
var
i
=
0
len
=
propValues
.
length
;
i
<
len
;
i
+
+
)
{
var
error
=
typeChecker
(
propValues
i
componentName
location
"
"
+
propFullName
+
"
[
"
+
i
+
"
]
"
)
;
if
(
error
instanceof
Error
)
{
return
error
;
}
}
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createListOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
List
"
Immutable
.
List
.
isList
)
;
}
function
createMapOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Map
"
Immutable
.
Map
.
isMap
)
;
}
function
createOrderedMapOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
OrderedMap
"
Immutable
.
OrderedMap
.
isOrderedMap
)
;
}
function
createSetOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Set
"
Immutable
.
Set
.
isSet
)
;
}
function
createOrderedSetOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
OrderedSet
"
Immutable
.
OrderedSet
.
isOrderedSet
)
;
}
function
createStackOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Stack
"
Immutable
.
Stack
.
isStack
)
;
}
function
createIterableOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Iterable
"
Immutable
.
Iterable
.
isIterable
)
;
}
function
createRecordOfTypeChecker
(
recordKeys
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
!
(
propValue
instanceof
Immutable
.
Record
)
)
{
var
locationName
=
location
;
return
new
Error
(
"
Invalid
"
+
locationName
+
"
"
+
propFullName
+
"
of
type
"
+
propType
+
"
"
+
(
"
supplied
to
"
+
componentName
+
"
expected
an
Immutable
.
js
Record
.
"
)
)
;
}
for
(
var
key
in
recordKeys
)
{
var
checker
=
recordKeys
[
key
]
;
if
(
!
checker
)
{
continue
;
}
var
mutablePropValue
=
propValue
.
toObject
(
)
;
var
error
=
checker
(
mutablePropValue
key
componentName
location
"
"
+
propFullName
+
"
.
"
+
key
)
;
if
(
error
)
{
return
error
;
}
}
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createShapeTypeChecker
(
shapeTypes
)
{
var
immutableClassName
=
arguments
[
1
]
=
=
=
undefined
?
"
Iterable
"
:
arguments
[
1
]
;
var
immutableClassTypeValidator
=
arguments
[
2
]
=
=
=
undefined
?
Immutable
.
Iterable
.
isIterable
:
arguments
[
2
]
;
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
!
immutableClassTypeValidator
(
propValue
)
)
{
var
locationName
=
location
;
return
new
Error
(
"
Invalid
"
+
locationName
+
"
"
+
propFullName
+
"
of
type
"
+
propType
+
"
"
+
(
"
supplied
to
"
+
componentName
+
"
expected
an
Immutable
.
js
"
+
immutableClassName
+
"
.
"
)
)
;
}
var
mutablePropValue
=
propValue
.
toObject
(
)
;
for
(
var
key
in
shapeTypes
)
{
var
checker
=
shapeTypes
[
key
]
;
if
(
!
checker
)
{
continue
;
}
var
error
=
checker
(
mutablePropValue
key
componentName
location
"
"
+
propFullName
+
"
.
"
+
key
)
;
if
(
error
)
{
return
error
;
}
}
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createShapeChecker
(
shapeTypes
)
{
return
createShapeTypeChecker
(
shapeTypes
)
;
}
function
createMapContainsChecker
(
shapeTypes
)
{
return
createShapeTypeChecker
(
shapeTypes
"
Map
"
Immutable
.
Map
.
isMap
)
;
}
module
.
exports
=
ImmutablePropTypes
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
_require
=
__webpack_require__
(
378
)
;
var
nodeHasChildren
=
_require
.
nodeHasChildren
;
var
createParentMap
=
_require
.
createParentMap
;
var
addToTree
=
_require
.
addToTree
;
var
collapseTree
=
_require
.
collapseTree
;
var
createTree
=
_require
.
createTree
;
var
classnames
=
__webpack_require__
(
379
)
;
var
ImPropTypes
=
__webpack_require__
(
376
)
;
var
_require2
=
__webpack_require__
(
341
)
;
var
Set
=
_require2
.
Set
;
var
debounce
=
__webpack_require__
(
380
)
;
var
ManagedTree
=
React
.
createFactory
(
__webpack_require__
(
383
)
)
;
var
Svg
=
__webpack_require__
(
387
)
;
var
SourcesTree
=
React
.
createClass
(
{
propTypes
:
{
sources
:
ImPropTypes
.
map
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
SourcesTree
"
getInitialState
(
)
{
return
createTree
(
this
.
props
.
sources
)
;
}
componentWillMount
(
)
{
this
.
debouncedUpdate
=
debounce
(
this
.
debouncedUpdate
50
)
;
}
shouldComponentUpdate
(
)
{
this
.
debouncedUpdate
(
)
;
return
false
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
nextProps
.
sources
=
=
=
this
.
props
.
sources
)
{
return
;
}
if
(
nextProps
.
sources
.
size
=
=
=
0
)
{
this
.
setState
(
createTree
(
nextProps
.
sources
)
)
;
return
;
}
var
next
=
Set
(
nextProps
.
sources
.
valueSeq
(
)
)
;
var
prev
=
Set
(
this
.
props
.
sources
.
valueSeq
(
)
)
;
var
newSet
=
next
.
subtract
(
prev
)
;
var
uncollapsedTree
=
this
.
state
.
uncollapsedTree
;
for
(
var
source
of
newSet
)
{
addToTree
(
uncollapsedTree
source
)
;
}
var
sourceTree
=
newSet
.
size
>
0
?
collapseTree
(
uncollapsedTree
)
:
this
.
state
.
sourceTree
;
this
.
setState
(
{
uncollapsedTree
sourceTree
parentMap
:
createParentMap
(
sourceTree
)
}
)
;
}
debouncedUpdate
(
)
{
if
(
!
this
.
isMounted
(
)
)
{
return
;
}
this
.
forceUpdate
(
)
;
}
focusItem
(
item
)
{
this
.
setState
(
{
focusedItem
:
item
}
)
;
}
selectItem
(
item
)
{
if
(
!
nodeHasChildren
(
item
)
)
{
this
.
props
.
selectSource
(
item
.
contents
.
get
(
"
id
"
)
)
;
}
}
getIcon
(
item
depth
)
{
if
(
depth
=
=
=
0
)
{
return
new
Svg
(
"
domain
"
)
;
}
if
(
!
nodeHasChildren
(
item
)
)
{
return
new
Svg
(
"
file
"
)
;
}
return
new
Svg
(
"
folder
"
)
;
}
renderItem
(
item
depth
focused
_
expanded
_ref
)
{
var
setExpanded
=
_ref
.
setExpanded
;
var
arrow
=
new
Svg
(
"
arrow
"
{
className
:
classnames
(
{
expanded
:
expanded
hidden
:
!
nodeHasChildren
(
item
)
}
)
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
setExpanded
(
item
!
expanded
)
;
}
}
)
;
var
icon
=
this
.
getIcon
(
item
depth
)
;
return
dom
.
div
(
{
className
:
classnames
(
"
node
"
{
focused
}
)
style
:
{
paddingLeft
:
depth
*
15
+
"
px
"
}
key
:
item
.
path
onClick
:
(
)
=
>
this
.
selectItem
(
item
)
onDoubleClick
:
e
=
>
setExpanded
(
item
!
expanded
)
}
dom
.
div
(
null
arrow
icon
item
.
name
)
)
;
}
render
:
function
(
)
{
var
_state
=
this
.
state
;
var
focusedItem
=
_state
.
focusedItem
;
var
sourceTree
=
_state
.
sourceTree
;
var
parentMap
=
_state
.
parentMap
;
var
tree
=
ManagedTree
(
{
getParent
:
item
=
>
{
return
parentMap
.
get
(
item
)
;
}
getChildren
:
item
=
>
{
if
(
nodeHasChildren
(
item
)
)
{
return
item
.
contents
;
}
return
[
]
;
}
getRoots
:
(
)
=
>
sourceTree
.
contents
getKey
:
(
item
i
)
=
>
item
.
path
itemHeight
:
30
autoExpandDepth
:
2
onFocus
:
this
.
focusItem
renderItem
:
this
.
renderItem
}
)
;
return
dom
.
div
(
{
className
:
"
sources
-
list
"
onKeyDown
:
e
=
>
{
if
(
e
.
keyCode
=
=
=
13
&
&
focusedItem
)
{
this
.
selectItem
(
focusedItem
)
;
}
}
}
tree
)
;
}
}
)
;
module
.
exports
=
SourcesTree
;
}
function
(
module
exports
__webpack_require__
)
{
var
URL
=
__webpack_require__
(
349
)
;
var
_require
=
__webpack_require__
(
334
)
;
var
assert
=
_require
.
assert
;
function
nodeHasChildren
(
item
)
{
return
Array
.
isArray
(
item
.
contents
)
;
}
function
createNode
(
name
path
contents
)
{
return
{
name
path
contents
:
contents
|
|
null
}
;
}
function
createParentMap
(
tree
)
{
var
map
=
new
WeakMap
(
)
;
function
_traverse
(
subtree
)
{
if
(
nodeHasChildren
(
subtree
)
)
{
for
(
var
child
of
subtree
.
contents
)
{
map
.
set
(
child
subtree
)
;
_traverse
(
child
)
;
}
}
}
tree
.
contents
.
forEach
(
_traverse
)
;
return
map
;
}
function
getURL
(
source
)
{
var
url
=
source
.
get
(
"
url
"
)
;
if
(
!
url
)
{
return
null
;
}
var
urlObj
=
URL
.
parse
(
url
)
;
if
(
!
urlObj
.
protocol
&
&
urlObj
.
pathname
[
0
]
=
=
=
"
/
"
)
{
urlObj
.
protocol
=
"
file
:
"
;
}
else
if
(
!
urlObj
.
host
&
&
!
urlObj
.
protocol
)
{
return
{
path
:
url
group
:
"
(
no
domain
)
"
}
;
}
else
if
(
urlObj
.
protocol
=
=
=
"
javascript
:
"
)
{
return
null
;
}
else
if
(
urlObj
.
protocol
=
=
=
"
about
:
"
)
{
return
{
path
:
"
/
"
group
:
url
}
;
}
else
if
(
urlObj
.
protocol
=
=
=
"
http
:
"
|
|
urlObj
.
protocol
=
=
=
"
https
:
"
)
{
return
{
path
:
urlObj
.
pathname
group
:
urlObj
.
host
}
;
}
return
{
path
:
urlObj
.
path
group
:
urlObj
.
protocol
+
"
/
/
"
}
;
}
function
addToTree
(
tree
source
)
{
var
url
=
getURL
(
source
)
;
if
(
!
url
)
{
return
;
}
url
.
path
=
decodeURIComponent
(
url
.
path
)
;
var
parts
=
url
.
path
.
split
(
"
/
"
)
.
filter
(
p
=
>
p
!
=
=
"
"
)
;
var
isDir
=
parts
.
length
=
=
=
0
|
|
parts
[
parts
.
length
-
1
]
.
indexOf
(
"
.
"
)
=
=
=
-
1
;
parts
.
unshift
(
url
.
group
)
;
var
path
=
"
"
;
var
subtree
=
tree
;
var
_loop
=
function
(
part
)
{
assert
(
nodeHasChildren
(
subtree
)
{
subtree
.
name
}
should
have
children
)
;
var
subpaths
=
subtree
.
contents
;
var
idx
=
subpaths
.
findIndex
(
subpath
=
>
{
return
subpath
.
name
.
localeCompare
(
part
)
>
=
0
;
}
)
;
if
(
idx
>
=
0
&
&
subpaths
[
idx
]
.
name
=
=
=
part
)
{
subtree
=
subpaths
[
idx
]
;
}
else
{
var
node
=
createNode
(
part
path
+
"
/
"
+
part
[
]
)
;
var
where
=
idx
=
=
=
-
1
?
subpaths
.
length
:
idx
;
subpaths
.
splice
(
where
0
node
)
;
subtree
=
subpaths
[
where
]
;
}
path
=
path
+
"
/
"
+
part
;
}
;
for
(
var
part
of
parts
)
{
_loop
(
part
)
;
}
if
(
isDir
)
{
subtree
.
contents
.
unshift
(
createNode
(
"
(
index
)
"
source
.
get
(
"
url
"
)
source
)
)
;
}
else
{
subtree
.
contents
=
source
;
}
}
function
collapseTree
(
node
)
{
var
depth
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
0
:
arguments
[
1
]
;
if
(
nodeHasChildren
(
node
)
)
{
if
(
depth
>
1
&
&
node
.
contents
.
length
=
=
=
1
)
{
var
next
=
node
.
contents
[
0
]
;
if
(
nodeHasChildren
(
next
)
)
{
return
collapseTree
(
createNode
(
{
node
.
name
}
/
{
next
.
name
}
next
.
path
next
.
contents
)
depth
+
1
)
;
}
}
return
createNode
(
node
.
name
node
.
path
node
.
contents
.
map
(
next
=
>
collapseTree
(
next
depth
+
1
)
)
)
;
}
return
node
;
}
function
createTree
(
sources
)
{
var
uncollapsedTree
=
createNode
(
"
root
"
"
"
[
]
)
;
for
(
var
source
of
sources
.
valueSeq
(
)
)
{
addToTree
(
uncollapsedTree
source
)
;
}
var
sourceTree
=
collapseTree
(
uncollapsedTree
)
;
return
{
uncollapsedTree
sourceTree
parentMap
:
createParentMap
(
sourceTree
)
focusedItem
:
null
}
;
}
module
.
exports
=
{
createNode
nodeHasChildren
createParentMap
addToTree
collapseTree
createTree
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
)
{
'
use
strict
'
;
var
hasOwn
=
{
}
.
hasOwnProperty
;
function
classNames
(
)
{
var
classes
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
continue
;
var
argType
=
typeof
arg
;
if
(
argType
=
=
=
'
string
'
|
|
argType
=
=
=
'
number
'
)
{
classes
.
push
(
arg
)
;
}
else
if
(
Array
.
isArray
(
arg
)
)
{
classes
.
push
(
classNames
.
apply
(
null
arg
)
)
;
}
else
if
(
argType
=
=
=
'
object
'
)
{
for
(
var
key
in
arg
)
{
if
(
hasOwn
.
call
(
arg
key
)
&
&
arg
[
key
]
)
{
classes
.
push
(
key
)
;
}
}
}
}
return
classes
.
join
(
'
'
)
;
}
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
module
.
exports
=
classNames
;
}
else
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
]
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
classNames
;
}
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
window
.
classNames
=
classNames
;
}
}
(
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
isObject
=
__webpack_require__
(
212
)
now
=
__webpack_require__
(
381
)
toNumber
=
__webpack_require__
(
382
)
;
var
FUNC_ERROR_TEXT
=
'
Expected
a
function
'
;
var
nativeMax
=
Math
.
max
nativeMin
=
Math
.
min
;
function
debounce
(
func
wait
options
)
{
var
lastArgs
lastThis
maxWait
result
timerId
lastCallTime
lastInvokeTime
=
0
leading
=
false
maxing
=
false
trailing
=
true
;
if
(
typeof
func
!
=
'
function
'
)
{
throw
new
TypeError
(
FUNC_ERROR_TEXT
)
;
}
wait
=
toNumber
(
wait
)
|
|
0
;
if
(
isObject
(
options
)
)
{
leading
=
!
!
options
.
leading
;
maxing
=
'
maxWait
'
in
options
;
maxWait
=
maxing
?
nativeMax
(
toNumber
(
options
.
maxWait
)
|
|
0
wait
)
:
maxWait
;
trailing
=
'
trailing
'
in
options
?
!
!
options
.
trailing
:
trailing
;
}
function
invokeFunc
(
time
)
{
var
args
=
lastArgs
thisArg
=
lastThis
;
lastArgs
=
lastThis
=
undefined
;
lastInvokeTime
=
time
;
result
=
func
.
apply
(
thisArg
args
)
;
return
result
;
}
function
leadingEdge
(
time
)
{
lastInvokeTime
=
time
;
timerId
=
setTimeout
(
timerExpired
wait
)
;
return
leading
?
invokeFunc
(
time
)
:
result
;
}
function
remainingWait
(
time
)
{
var
timeSinceLastCall
=
time
-
lastCallTime
timeSinceLastInvoke
=
time
-
lastInvokeTime
result
=
wait
-
timeSinceLastCall
;
return
maxing
?
nativeMin
(
result
maxWait
-
timeSinceLastInvoke
)
:
result
;
}
function
shouldInvoke
(
time
)
{
var
timeSinceLastCall
=
time
-
lastCallTime
timeSinceLastInvoke
=
time
-
lastInvokeTime
;
return
(
lastCallTime
=
=
=
undefined
|
|
(
timeSinceLastCall
>
=
wait
)
|
|
(
timeSinceLastCall
<
0
)
|
|
(
maxing
&
&
timeSinceLastInvoke
>
=
maxWait
)
)
;
}
function
timerExpired
(
)
{
var
time
=
now
(
)
;
if
(
shouldInvoke
(
time
)
)
{
return
trailingEdge
(
time
)
;
}
timerId
=
setTimeout
(
timerExpired
remainingWait
(
time
)
)
;
}
function
trailingEdge
(
time
)
{
timerId
=
undefined
;
if
(
trailing
&
&
lastArgs
)
{
return
invokeFunc
(
time
)
;
}
lastArgs
=
lastThis
=
undefined
;
return
result
;
}
function
cancel
(
)
{
lastInvokeTime
=
0
;
lastArgs
=
lastCallTime
=
lastThis
=
timerId
=
undefined
;
}
function
flush
(
)
{
return
timerId
=
=
=
undefined
?
result
:
trailingEdge
(
now
(
)
)
;
}
function
debounced
(
)
{
var
time
=
now
(
)
isInvoking
=
shouldInvoke
(
time
)
;
lastArgs
=
arguments
;
lastThis
=
this
;
lastCallTime
=
time
;
if
(
isInvoking
)
{
if
(
timerId
=
=
=
undefined
)
{
return
leadingEdge
(
lastCallTime
)
;
}
if
(
maxing
)
{
timerId
=
setTimeout
(
timerExpired
wait
)
;
return
invokeFunc
(
lastCallTime
)
;
}
}
if
(
timerId
=
=
=
undefined
)
{
timerId
=
setTimeout
(
timerExpired
wait
)
;
}
return
result
;
}
debounced
.
cancel
=
cancel
;
debounced
.
flush
=
flush
;
return
debounced
;
}
module
.
exports
=
debounce
;
}
function
(
module
exports
)
{
function
now
(
)
{
return
Date
.
now
(
)
;
}
module
.
exports
=
now
;
}
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
211
)
isObject
=
__webpack_require__
(
212
)
isSymbol
=
__webpack_require__
(
241
)
;
var
NAN
=
0
/
0
;
var
reTrim
=
/
^
\
s
+
|
\
s
+
/
g
;
var
reIsBadHex
=
/
^
[
-
+
]
0x
[
0
-
9a
-
f
]
+
/
i
;
var
reIsBinary
=
/
^
0b
[
01
]
+
/
i
;
var
reIsOctal
=
/
^
0o
[
0
-
7
]
+
/
i
;
var
freeParseInt
=
parseInt
;
function
toNumber
(
value
)
{
if
(
typeof
value
=
=
'
number
'
)
{
return
value
;
}
if
(
isSymbol
(
value
)
)
{
return
NAN
;
}
if
(
isObject
(
value
)
)
{
var
other
=
isFunction
(
value
.
valueOf
)
?
value
.
valueOf
(
)
:
value
;
value
=
isObject
(
other
)
?
(
other
+
'
'
)
:
other
;
}
if
(
typeof
value
!
=
'
string
'
)
{
return
value
=
=
=
0
?
value
:
+
value
;
}
value
=
value
.
replace
(
reTrim
'
'
)
;
var
isBinary
=
reIsBinary
.
test
(
value
)
;
return
(
isBinary
|
|
reIsOctal
.
test
(
value
)
)
?
freeParseInt
(
value
.
slice
(
2
)
isBinary
?
2
:
8
)
:
(
reIsBadHex
.
test
(
value
)
?
NAN
:
+
value
)
;
}
module
.
exports
=
toNumber
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
Tree
=
React
.
createFactory
(
__webpack_require__
(
384
)
)
;
__webpack_require__
(
385
)
;
var
ManagedTree
=
React
.
createClass
(
{
propTypes
:
Tree
.
propTypes
displayName
:
"
ManagedTree
"
getInitialState
(
)
{
return
{
expanded
:
new
Set
(
)
focusedItem
:
null
}
;
}
setExpanded
(
item
isExpanded
)
{
var
expanded
=
this
.
state
.
expanded
;
var
key
=
this
.
props
.
getKey
(
item
)
;
if
(
isExpanded
)
{
expanded
.
add
(
key
)
;
}
else
{
expanded
.
delete
(
key
)
;
}
this
.
setState
(
{
expanded
}
)
;
if
(
isExpanded
&
&
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
}
else
if
(
!
expanded
&
&
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
focusItem
(
item
)
{
if
(
!
this
.
props
.
disabledFocus
&
&
this
.
state
.
focusedItem
!
=
=
item
)
{
this
.
setState
(
{
focusedItem
:
item
}
)
;
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
}
render
(
)
{
var
_this
=
this
;
var
_state
=
this
.
state
;
var
expanded
=
_state
.
expanded
;
var
focusedItem
=
_state
.
focusedItem
;
var
props
=
Object
.
assign
(
{
}
this
.
props
{
isExpanded
:
item
=
>
expanded
.
has
(
this
.
props
.
getKey
(
item
)
)
focused
:
focusedItem
onExpand
:
item
=
>
this
.
setExpanded
(
item
true
)
onCollapse
:
item
=
>
this
.
setExpanded
(
item
false
)
onFocus
:
this
.
focusItem
renderItem
:
function
(
)
{
var
_props
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
(
_props
=
_this
.
props
)
.
renderItem
.
apply
(
_props
args
.
concat
(
[
{
setExpanded
:
_this
.
setExpanded
}
]
)
)
;
}
}
)
;
return
Tree
(
props
)
;
}
}
)
;
module
.
exports
=
ManagedTree
;
}
function
(
module
exports
__webpack_require__
)
{
const
{
DOM
:
dom
createClass
createFactory
PropTypes
}
=
__webpack_require__
(
17
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
ArrowExpander
=
createFactory
(
createClass
(
{
displayName
:
"
ArrowExpander
"
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
visible
!
=
=
nextProps
.
visible
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
attrs
=
{
className
:
"
arrow
theme
-
twisty
"
onClick
:
this
.
props
.
expanded
?
(
)
=
>
this
.
props
.
onCollapse
(
this
.
props
.
item
)
:
e
=
>
this
.
props
.
onExpand
(
this
.
props
.
item
e
.
altKey
)
}
;
if
(
this
.
props
.
expanded
)
{
attrs
.
className
+
=
"
open
"
;
}
if
(
!
this
.
props
.
visible
)
{
attrs
.
style
=
{
visibility
:
"
hidden
"
}
;
}
return
dom
.
div
(
attrs
this
.
props
.
children
)
;
}
}
)
)
;
const
TreeNode
=
createFactory
(
createClass
(
{
displayName
:
"
TreeNode
"
componentDidMount
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
componentDidUpdate
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
focused
!
=
=
nextProps
.
focused
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
arrow
=
ArrowExpander
(
{
item
:
this
.
props
.
item
expanded
:
this
.
props
.
expanded
visible
:
this
.
props
.
hasChildren
onExpand
:
this
.
props
.
onExpand
onCollapse
:
this
.
props
.
onCollapse
}
)
;
let
isOddRow
=
this
.
props
.
index
%
2
;
return
dom
.
div
(
{
className
:
tree
-
node
div
{
isOddRow
?
"
tree
-
node
-
odd
"
:
"
"
}
onFocus
:
this
.
props
.
onFocus
onClick
:
this
.
props
.
onFocus
onBlur
:
this
.
props
.
onBlur
style
:
{
padding
:
0
margin
:
0
}
}
this
.
props
.
renderItem
(
this
.
props
.
item
this
.
props
.
depth
this
.
props
.
focused
arrow
this
.
props
.
expanded
)
dom
.
button
(
this
.
_buttonAttrs
)
)
;
}
_buttonAttrs
:
{
ref
:
"
button
"
style
:
{
opacity
:
0
width
:
"
0
!
important
"
height
:
"
0
!
important
"
padding
:
"
0
!
important
"
outline
:
"
none
"
MozAppearance
:
"
none
"
MozMarginStart
:
"
-
1000px
!
important
"
}
}
}
)
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
const
NUMBER_OF_OFFSCREEN_ITEMS
=
1
;
const
Tree
=
module
.
exports
=
createClass
(
{
displayName
:
"
Tree
"
propTypes
:
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
isExpanded
:
PropTypes
.
func
.
isRequired
itemHeight
:
PropTypes
.
number
.
isRequired
focused
:
PropTypes
.
any
onFocus
:
PropTypes
.
func
autoExpandDepth
:
PropTypes
.
number
onExpand
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
}
getDefaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
}
;
}
getInitialState
(
)
{
return
{
scroll
:
0
height
:
window
.
innerHeight
seen
:
new
Set
(
)
}
;
}
componentDidMount
(
)
{
window
.
addEventListener
(
"
resize
"
this
.
_updateHeight
)
;
this
.
_autoExpand
(
this
.
props
)
;
this
.
_updateHeight
(
)
;
}
componentWillUnmount
(
)
{
window
.
removeEventListener
(
"
resize
"
this
.
_updateHeight
)
;
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
nextProps
)
;
this
.
_updateHeight
(
)
;
}
_autoExpand
(
props
)
{
if
(
!
props
.
autoExpandDepth
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
if
(
currentDepth
>
=
props
.
autoExpandDepth
|
|
this
.
state
.
seen
.
has
(
item
)
)
{
return
;
}
props
.
onExpand
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
const
children
=
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
renderItem
=
i
=
>
{
let
{
item
depth
}
=
traversal
[
i
]
;
return
TreeNode
(
{
key
:
this
.
props
.
getKey
(
item
i
)
index
:
i
item
:
item
depth
:
depth
renderItem
:
this
.
props
.
renderItem
focused
:
this
.
props
.
focused
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
hasChildren
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onFocus
:
(
)
=
>
this
.
_focus
(
i
item
)
}
)
;
}
return
dom
.
div
(
{
className
:
"
tree
"
ref
:
"
tree
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
style
:
{
padding
:
0
margin
:
0
}
}
traversal
.
map
(
(
v
i
)
=
>
renderItem
(
i
)
)
)
;
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
}
_updateHeight
(
)
{
this
.
setState
(
{
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
:
oncePerAnimationFrame
(
function
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
)
_onCollapse
:
oncePerAnimationFrame
(
function
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
)
_focus
(
index
item
)
{
if
(
item
!
=
=
undefined
)
{
const
itemStartPosition
=
index
*
this
.
props
.
itemHeight
;
const
itemEndPosition
=
(
index
+
1
)
*
this
.
props
.
itemHeight
;
if
(
this
.
state
.
scroll
>
itemStartPosition
)
{
this
.
refs
.
tree
.
scrollTop
=
itemStartPosition
;
}
else
if
(
(
this
.
state
.
scroll
+
this
.
state
.
height
)
<
itemEndPosition
)
{
this
.
refs
.
tree
.
scrollTop
=
itemEndPosition
-
this
.
state
.
height
;
}
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_onBlur
(
)
{
this
.
_focus
(
0
undefined
)
;
}
_onScroll
:
oncePerAnimationFrame
(
function
(
e
)
{
this
.
setState
(
{
scroll
:
Math
.
max
(
this
.
refs
.
tree
.
scrollTop
0
)
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
)
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
props
.
getChildren
(
this
.
props
.
focused
)
.
length
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
;
}
}
_focusPrevNode
:
oncePerAnimationFrame
(
function
(
)
{
let
prev
;
let
prevIndex
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
prevIndex
=
i
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prevIndex
prev
)
;
}
)
_focusNextNode
:
oncePerAnimationFrame
(
function
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
i
+
1
traversal
[
i
+
1
]
.
item
)
;
}
}
)
_focusParentNode
:
oncePerAnimationFrame
(
function
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
return
;
}
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
parentIndex
=
0
;
for
(
;
parentIndex
<
length
;
parentIndex
+
+
)
{
if
(
traversal
[
parentIndex
]
.
item
=
=
=
parent
)
{
break
;
}
}
this
.
_focus
(
parentIndex
parent
)
;
}
)
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
386
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
ManagedTree
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
ManagedTree
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
tree
{
\
n
-
webkit
-
user
-
select
:
none
;
\
n
-
moz
-
user
-
select
:
none
;
\
n
-
ms
-
user
-
select
:
none
;
\
n
-
o
-
user
-
select
:
none
;
\
n
user
-
select
:
none
;
\
n
\
n
flex
:
1
;
\
n
white
-
space
:
nowrap
;
\
n
overflow
:
auto
;
\
n
}
\
n
\
n
.
tree
button
{
\
n
display
:
block
;
\
n
}
\
n
\
n
.
tree
.
node
{
\
n
padding
:
2px
5px
;
\
n
position
:
relative
;
\
n
}
\
n
\
n
.
tree
.
node
.
focused
{
\
n
color
:
white
;
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
}
\
n
\
n
.
tree
.
node
>
div
{
\
n
margin
-
left
:
10px
;
\
n
}
\
n
\
n
.
tree
.
node
.
focused
svg
{
\
n
fill
:
white
;
\
n
}
\
n
\
n
.
tree
-
node
button
{
\
n
position
:
fixed
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
Svg
=
__webpack_require__
(
388
)
;
module
.
exports
=
Svg
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
InlineSVG
=
__webpack_require__
(
389
)
;
var
svg
=
{
"
angle
-
brackets
"
:
__webpack_require__
(
390
)
"
arrow
"
:
__webpack_require__
(
391
)
"
blackBox
"
:
__webpack_require__
(
392
)
"
breakpoint
"
:
__webpack_require__
(
393
)
"
close
"
:
__webpack_require__
(
394
)
"
disableBreakpoints
"
:
__webpack_require__
(
395
)
"
domain
"
:
__webpack_require__
(
396
)
"
file
"
:
__webpack_require__
(
397
)
"
folder
"
:
__webpack_require__
(
398
)
"
globe
"
:
__webpack_require__
(
399
)
"
magnifying
-
glass
"
:
__webpack_require__
(
400
)
"
pause
"
:
__webpack_require__
(
401
)
"
pause
-
circle
"
:
__webpack_require__
(
402
)
"
pause
-
exceptions
"
:
__webpack_require__
(
403
)
"
prettyPrint
"
:
__webpack_require__
(
404
)
"
resume
"
:
__webpack_require__
(
405
)
"
settings
"
:
__webpack_require__
(
406
)
"
stepIn
"
:
__webpack_require__
(
407
)
"
stepOut
"
:
__webpack_require__
(
408
)
"
stepOver
"
:
__webpack_require__
(
409
)
"
subSettings
"
:
__webpack_require__
(
410
)
"
worker
"
:
__webpack_require__
(
411
)
}
;
module
.
exports
=
function
(
name
props
)
{
if
(
!
svg
[
name
]
)
{
throw
new
Error
(
"
Unknown
SVG
:
"
+
name
)
;
}
var
className
=
props
?
{
name
}
{
props
.
className
}
:
name
;
if
(
name
=
=
=
"
subSettings
"
)
{
className
=
"
"
;
}
props
=
Object
.
assign
(
{
}
props
{
className
src
:
svg
[
name
]
}
)
;
return
React
.
createElement
(
InlineSVG
props
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_createClass
=
(
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
'
value
'
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
)
(
)
;
var
_get
=
function
get
(
_x
_x2
_x3
)
{
var
_again
=
true
;
_function
:
while
(
_again
)
{
var
object
=
_x
property
=
_x2
receiver
=
_x3
;
_again
=
false
;
if
(
object
=
=
=
null
)
object
=
Function
.
prototype
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
object
property
)
;
if
(
desc
=
=
=
undefined
)
{
var
parent
=
Object
.
getPrototypeOf
(
object
)
;
if
(
parent
=
=
=
null
)
{
return
undefined
;
}
else
{
_x
=
parent
;
_x2
=
property
;
_x3
=
receiver
;
_again
=
true
;
desc
=
parent
=
undefined
;
continue
_function
;
}
}
else
if
(
'
value
'
in
desc
)
{
return
desc
.
value
;
}
else
{
var
getter
=
desc
.
get
;
if
(
getter
=
=
=
undefined
)
{
return
undefined
;
}
return
getter
.
call
(
receiver
)
;
}
}
}
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
function
_objectWithoutProperties
(
obj
keys
)
{
var
target
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
keys
.
indexOf
(
i
)
>
=
0
)
continue
;
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
continue
;
target
[
i
]
=
obj
[
i
]
;
}
return
target
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
'
Cannot
call
a
class
as
a
function
'
)
;
}
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
'
function
'
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
'
Super
expression
must
either
be
null
or
a
function
not
'
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
_react
=
__webpack_require__
(
17
)
;
var
_react2
=
_interopRequireDefault
(
_react
)
;
var
DOMParser
=
typeof
window
!
=
=
'
undefined
'
&
&
window
.
DOMParser
;
var
process
=
process
|
|
{
}
;
process
.
env
=
process
.
env
|
|
{
}
;
var
parserAvailable
=
typeof
DOMParser
!
=
=
'
undefined
'
&
&
DOMParser
.
prototype
!
=
null
&
&
DOMParser
.
prototype
.
parseFromString
!
=
null
;
if
(
"
production
"
!
=
=
process
.
env
.
NODE_ENV
&
&
!
parserAvailable
)
{
console
.
info
(
'
<
InlineSVG
/
>
:
raw
prop
works
only
when
window
.
DOMParser
exists
.
'
)
;
}
function
isParsable
(
src
)
{
return
parserAvailable
&
&
typeof
src
=
=
=
'
string
'
&
&
src
.
trim
(
)
.
substr
(
0
4
)
=
=
=
'
<
svg
'
;
}
function
parseFromSVGString
(
src
)
{
var
parser
=
new
DOMParser
(
)
;
return
parser
.
parseFromString
(
src
"
image
/
svg
+
xml
"
)
;
}
function
switchSVGAttrToReactProp
(
propName
)
{
switch
(
propName
)
{
case
'
class
'
:
return
'
className
'
;
default
:
return
propName
;
}
}
var
InlineSVG
=
(
function
(
_React
Component
)
{
_inherits
(
InlineSVG
_React
Component
)
;
_createClass
(
InlineSVG
null
[
{
key
:
'
defaultProps
'
value
:
{
element
:
'
i
'
raw
:
false
src
:
'
'
}
enumerable
:
true
}
{
key
:
'
propTypes
'
value
:
{
src
:
_react2
[
'
default
'
]
.
PropTypes
.
string
.
isRequired
element
:
_react2
[
'
default
'
]
.
PropTypes
.
string
raw
:
_react2
[
'
default
'
]
.
PropTypes
.
bool
}
enumerable
:
true
}
]
)
;
function
InlineSVG
(
props
)
{
_classCallCheck
(
this
InlineSVG
)
;
_get
(
Object
.
getPrototypeOf
(
InlineSVG
.
prototype
)
'
constructor
'
this
)
.
call
(
this
props
)
;
this
.
_extractSVGProps
=
this
.
_extractSVGProps
.
bind
(
this
)
;
}
_createClass
(
InlineSVG
[
{
key
:
'
_serializeAttrs
'
value
:
function
_serializeAttrs
(
map
)
{
var
ret
=
{
}
;
var
prop
=
undefined
;
for
(
var
i
=
0
;
i
<
map
.
length
;
i
+
+
)
{
prop
=
switchSVGAttrToReactProp
(
map
[
i
]
.
name
)
;
ret
[
prop
]
=
map
[
i
]
.
value
;
}
return
ret
;
}
}
{
key
:
'
_extractSVGProps
'
value
:
function
_extractSVGProps
(
src
)
{
var
map
=
parseFromSVGString
(
src
)
.
documentElement
.
attributes
;
return
map
.
length
>
0
?
this
.
_serializeAttrs
(
map
)
:
null
;
}
}
{
key
:
'
_stripSVG
'
value
:
function
_stripSVG
(
src
)
{
return
parseFromSVGString
(
src
)
.
documentElement
.
innerHTML
;
}
}
{
key
:
'
componentWillReceiveProps
'
value
:
function
componentWillReceiveProps
(
_ref
)
{
var
children
=
_ref
.
children
;
if
(
"
production
"
!
=
=
process
.
env
.
NODE_ENV
&
&
children
!
=
null
)
{
console
.
info
(
'
<
InlineSVG
/
>
:
children
prop
will
be
ignored
.
'
)
;
}
}
}
{
key
:
'
render
'
value
:
function
render
(
)
{
var
Element
=
undefined
__html
=
undefined
svgProps
=
undefined
;
var
_props
=
this
.
props
;
var
element
=
_props
.
element
;
var
raw
=
_props
.
raw
;
var
src
=
_props
.
src
;
var
otherProps
=
_objectWithoutProperties
(
_props
[
'
element
'
'
raw
'
'
src
'
]
)
;
if
(
raw
=
=
=
true
&
&
isParsable
(
src
)
)
{
Element
=
'
svg
'
;
svgProps
=
this
.
_extractSVGProps
(
src
)
;
__html
=
this
.
_stripSVG
(
src
)
;
}
__html
=
__html
|
|
src
;
Element
=
Element
|
|
element
;
svgProps
=
svgProps
|
|
{
}
;
return
_react2
[
'
default
'
]
.
createElement
(
Element
_extends
(
{
}
svgProps
otherProps
{
src
:
null
children
:
null
dangerouslySetInnerHTML
:
{
__html
:
__html
}
}
)
)
;
}
}
]
)
;
return
InlineSVG
;
}
)
(
_react2
[
'
default
'
]
.
Component
)
;
exports
[
'
default
'
]
=
InlineSVG
;
module
.
exports
=
exports
[
'
default
'
]
;
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
-
1
73
16
11
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
g
id
=
\
"
Shape
-
Copy
-
3
-
+
-
Shape
-
Copy
-
4
\
"
stroke
=
\
"
none
\
"
stroke
-
width
=
\
"
1
\
"
fill
=
\
"
none
\
"
fill
-
rule
=
\
"
evenodd
\
"
transform
=
\
"
translate
(
0
.
000000
74
.
000000
)
\
"
>
<
path
d
=
\
"
M0
.
749321284
4
.
16081709
L4
.
43130681
0
.
242526751
C4
.
66815444
-
0
.
00952143591
5
.
06030999
-
0
.
0211407611
5
.
30721074
0
.
216574262
C5
.
55411149
0
.
454289284
5
.
56226116
0
.
851320812
5
.
32541353
1
.
103369
L1
.
95384971
4
.
69131519
L5
.
48809879
8
.
09407556
C5
.
73499955
8
.
33179058
5
.
74314922
8
.
72882211
5
.
50630159
8
.
9808703
C5
.
26945396
9
.
23291849
4
.
87729841
9
.
24453781
4
.
63039766
9
.
00682279
L0
.
827097345
5
.
34502101
C0
.
749816996
5
.
31670099
0
.
677016974
5
.
27216098
0
.
613753508
5
.
21125118
C0
.
427367989
5
.
03179997
0
.
377040713
4
.
7615583
0
.
465458792
4
.
53143559
C0
.
492371834
4
.
43667624
0
.
541703274
4
.
34676528
0
.
613628034
4
.
27022448
C0
.
654709457
4
.
22650651
0
.
70046335
4
.
19002189
0
.
749321284
4
.
16081709
Z
\
"
id
=
\
"
Shape
-
Copy
-
3
\
"
stroke
=
\
"
#
FFFFFF
\
"
stroke
-
width
=
\
"
0
.
05
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
/
path
>
<
path
d
=
\
"
M13
.
7119065
5
.
44453032
L9
.
77062746
9
.
09174784
C9
.
51677479
9
.
3266604
9
.
12476399
9
.
31089603
8
.
89504684
9
.
05653714
C8
.
66532968
8
.
80217826
8
.
68489539
8
.
40554539
8
.
93874806
8
.
17063283
L12
.
5546008
4
.
82456128
L9
.
26827469
1
.
18571135
C9
.
03855754
0
.
931352463
9
.
05812324
0
.
534719593
9
.
31197591
0
.
299807038
C9
.
56582858
0
.
0648944831
9
.
95783938
0
.
0806588502
10
.
1875565
0
.
335017737
L13
.
72891
4
.
25625178
C13
.
8013755
4
.
28980469
13
.
8684335
4
.
3382578
13
.
9254821
4
.
40142604
C14
.
0883019
4
.
58171146
14
.
1258883
4
.
83347168
14
.
0435812
5
.
04846202
C14
.
0126705
5
.
15680232
13
.
9526426
5
.
2583679
13
.
8641331
5
.
34027361
C13
.
8174417
5
.
38348136
13
.
7660763
5
.
41820853
13
.
7119065
5
.
44453032
Z
\
"
id
=
\
"
Shape
-
Copy
-
4
\
"
stroke
=
\
"
#
FFFFFF
\
"
stroke
-
width
=
\
"
0
.
05
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
viewBox
=
\
"
0
0
16
16
\
"
>
<
path
d
=
\
"
M8
13
.
4c
-
.
5
0
-
.
9
-
.
2
-
1
.
2
-
.
6L
.
4
5
.
2C0
4
.
7
-
.
1
4
.
3
.
2
3
.
7S1
3
1
.
6
3h12
.
8c
.
6
0
1
.
2
.
1
1
.
4
.
7
.
3
.
6
.
2
1
.
1
-
.
2
1
.
6l
-
6
.
4
7
.
6c
-
.
3
.
4
-
.
7
.
5
-
1
.
2
.
5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
circle
cx
=
\
"
8
\
"
cy
=
\
"
8
.
5
\
"
r
=
\
"
1
.
5
\
"
>
<
/
circle
>
<
path
d
=
\
"
M15
.
498
8
.
28l
-
.
001
-
.
03v
-
.
002
-
.
004l
-
.
002
-
.
018
-
.
004
-
.
031c0
-
.
002
0
-
.
002
0
0l
-
.
004
-
.
035
.
006
.
082c
-
.
037
-
.
296
-
.
133
-
.
501
-
.
28
-
.
661
-
.
4
-
.
522
-
.
915
-
1
.
042
-
1
.
562
-
1
.
604
-
1
.
36
-
1
.
182
-
2
.
74
-
1
.
975
-
4
.
178
-
2
.
309a6
.
544
6
.
544
0
0
0
-
2
.
755
-
.
042c
-
.
78
.
153
-
1
.
565
.
462
-
2
.
369
.
91C3
.
252
5
.
147
2
.
207
6
1
.
252
7
.
035c
-
.
216
.
233
-
.
36
.
398
-
.
499
.
577
-
.
338
.
437
-
.
338
1
0
1
.
437
.
428
.
552
.
941
1
.
072
1
.
59
1
.
635
1
.
359
1
.
181
2
.
739
1
.
975
4
.
177
2
.
308
.
907
.
21
1
.
829
.
223
2
.
756
.
043
.
78
-
.
153
1
.
564
-
.
462
2
.
369
-
.
91
1
.
097
-
.
612
2
.
141
-
1
.
464
3
.
097
-
2
.
499
.
217
-
.
235
.
36
-
.
398
.
498
-
.
578
.
12
-
.
128
.
216
-
.
334
.
248
-
.
554
0
.
01
0
.
01
-
.
008
.
04l
.
013
-
.
079
-
.
001
.
011
.
003
-
.
031
.
001
-
.
017v
.
005l
.
001
-
.
02v
.
008l
.
002
-
.
03
.
001
-
.
05
-
.
001
-
.
044v
-
.
004
-
.
004zm
-
.
954
.
045v
.
007l
.
001
.
004V8
.
33v
.
012l
-
.
001
.
01v
-
.
005
-
.
005l
.
002
-
.
015
-
.
001
.
008c
-
.
002
.
014
-
.
002
.
014
0
0l
-
.
007
.
084c
.
003
-
.
057
-
.
004
-
.
041
-
.
014
-
.
031
-
.
143
.
182
-
.
27
.
327
-
.
468
.
543
-
.
89
.
963
-
1
.
856
1
.
752
-
2
.
86
2
.
311
-
.
724
.
404
-
1
.
419
.
677
-
2
.
095
.
81a5
.
63
5
.
63
0
0
1
-
2
.
374
-
.
036c
-
1
.
273
-
.
295
-
2
.
523
-
1
.
014
-
3
.
774
-
2
.
101
-
.
604
-
.
525
-
1
.
075
-
1
.
001
-
1
.
457
-
1
.
496
-
.
054
-
.
07
-
.
054
-
.
107
0
-
.
177
.
117
-
.
152
.
244
-
.
298
.
442
-
.
512
.
89
-
.
963
1
.
856
-
1
.
752
2
.
86
-
2
.
311
.
724
-
.
404
1
.
419
-
.
678
2
.
095
-
.
81a5
.
631
5
.
631
0
0
1
2
.
374
.
036c1
.
272
.
295
2
.
523
1
.
014
3
.
774
2
.
101
.
603
.
524
1
.
074
1
1
.
457
1
.
496
.
035
.
041
.
043
.
057
.
046
.
076
0
.
01
0
.
01
.
008
.
043l
-
.
009
-
.
047
.
003
.
02
-
.
002
-
.
013v
-
.
008
.
016c0
-
.
004
0
-
.
004
0
0v
-
.
004z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
viewBox
=
\
"
0
0
33
12
\
"
>
<
path
id
=
\
"
base
-
path
\
"
d
=
\
"
M27
.
1
0H1C0
.
4
0
0
0
.
4
0
1v10c0
0
.
6
0
.
4
1
1
1h26
.
1
c0
.
6
0
1
.
2
-
0
.
3
1
.
5
-
0
.
7L33
6l
-
4
.
4
-
5
.
3C28
.
2
0
.
3
27
.
7
0
27
.
1
0z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
6
6
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
path
d
=
\
"
M1
.
35191454
5
.
27895256
L5
.
31214367
1
.
35518468
C5
.
50830675
1
.
16082764
5
.
50977084
0
.
844248536
5
.
3154138
0
.
648085456
C5
.
12105677
0
.
451922377
4
.
80447766
0
.
450458288
4
.
60831458
0
.
644815324
L0
.
648085456
4
.
56858321
C0
.
451922377
4
.
76294025
0
.
450458288
5
.
07951935
0
.
644815324
5
.
27568243
C0
.
83917236
5
.
47184551
1
.
15575146
5
.
4733096
1
.
35191454
5
.
27895256
L1
.
35191454
5
.
27895256
Z
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
none
\
"
fill
=
\
"
#
696969
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
path
d
=
\
"
M5
.
31214367
4
.
56858321
L1
.
35191454
0
.
644815324
C1
.
15575146
0
.
450458288
0
.
83917236
0
.
451922377
0
.
644815324
0
.
648085456
C0
.
450458288
0
.
844248536
0
.
451922377
1
.
16082764
0
.
648085456
1
.
35518468
L4
.
60831458
5
.
27895256
C4
.
80447766
5
.
4733096
5
.
12105677
5
.
47184551
5
.
3154138
5
.
27568243
C5
.
50977084
5
.
07951935
5
.
50830675
4
.
76294025
5
.
31214367
4
.
56858321
L5
.
31214367
4
.
56858321
Z
\
"
id
=
\
"
Line
-
Copy
-
2
\
"
stroke
=
\
"
none
\
"
fill
=
\
"
#
696969
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M3
.
233
11
.
25l
-
.
417
1H1
.
712C
.
763
12
.
25
0
11
.
574
0
10
.
747V6
.
503C0
5
.
675
.
755
5
1
.
712
5h4
.
127l
-
.
417
1H1
.
597C1
.
257
6
1
6
.
225
1
6
.
503v4
.
244c0
.
277
.
267
.
503
.
597
.
503h1
.
636zM7
.
405
11
.
27L7
12
.
306c
.
865
.
01
2
.
212
-
.
024
2
.
315
-
.
04
.
112
-
.
016
.
112
-
.
016
.
185
-
.
035
.
075
-
.
02
.
156
-
.
046
.
251
-
.
082
.
152
-
.
056
.
349
-
.
138
.
592
-
.
244
.
415
-
.
182
.
962
-
.
435
1
.
612
-
.
744l
.
138
-
.
066a179
.
35
179
.
35
0
0
0
2
.
255
-
1
.
094c1
.
191
-
.
546
1
.
191
-
2
.
074
-
.
025
-
2
.
632l
-
.
737
-
.
34a3547
.
554
3547
.
554
0
0
0
-
3
.
854
-
1
.
78c
-
.
029
.
11
-
.
065
.
222
-
.
11
.
336l
-
.
232
.
596c
.
894
.
408
4
.
56
2
.
107
4
.
56
2
.
107
.
458
.
21
.
458
.
596
0
.
806L9
.
197
11
.
27H7
.
405zM4
.
462
14
.
692l5
-
12a
.
5
.
5
0
1
0
-
.
924
-
.
384l
-
5
12a
.
5
.
5
0
1
0
.
924
.
384z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
path
d
=
\
"
M9
.
05
4
.
634l
-
2
.
144
.
003
-
.
116
.
116v1
.
445l
.
92
.
965
.
492
.
034
.
116
-
.
116v
-
.
617L9
.
13
5
.
7l
.
035
-
.
95M12
.
482
10
.
38l
-
1
.
505
-
1
.
462H9
.
362l
-
.
564
.
516
-
.
034
1
.
108
.
72
.
768
1
.
323
.
034
-
.
117
-
.
116v1
.
2l
.
972
1
.
02
.
315
.
034
.
116
-
.
116v
-
1
.
154l
.
422
-
.
374
.
034
-
.
927
-
.
117
.
117h
.
26l
.
408
-
.
36V10
.
5l
-
.
125
-
.
124
-
.
575
-
.
033
\
"
>
<
/
path
>
<
path
d
=
\
"
M8
.
47
15
.
073c
-
3
.
088
0
-
5
.
6
-
2
.
513
-
5
.
6
-
5
.
602V9
.
4v
-
.
003c0
-
.
018
0
-
.
018
.
002
-
.
034l
.
182
-
.
088
.
724
.
587
.
49
.
033
.
497
.
543
-
.
034
.
9
.
317
.
383h
.
47l
.
114
.
096
-
.
032
1
.
9
.
524
.
553h
.
105l
.
025
-
.
338
1
.
004
-
.
95
.
054
-
.
474
.
53
-
.
462v
-
.
888l
-
.
588
-
.
038
-
1
.
118
-
1
.
155H4
.
48l
-
.
154
-
.
09V9
.
01l
.
155
-
.
1h1
.
164v
-
.
273l
.
12
-
.
115
.
7
.
033
.
494
-
.
443
.
034
-
.
746
-
.
624
-
.
655h
-
.
724v
.
28l
-
.
11
.
07H4
.
64l
-
.
114
-
.
09
.
025
-
.
64
.
48
-
.
43v
-
.
244h
-
.
382c
-
.
102
0
-
.
152
-
.
128
-
.
08
-
.
2
1
.
04
-
1
.
01
2
.
428
-
1
.
59
3
.
903
-
1
.
59
1
.
374
0
2
.
672
.
5
3
.
688
1
.
39
.
08
.
068
.
03
.
198
-
.
075
.
198l
-
1
.
144
-
.
034
-
.
81
.
803
.
52
.
523v
.
16l
-
.
382
.
388h
-
.
158l
-
.
176
-
.
177v
-
.
16l
.
076
-
.
074
-
.
252
-
.
252
-
.
37
.
362
.
53
.
53c
.
072
.
072
.
005
.
194
-
.
096
.
194l
-
.
752
-
.
005v
.
844h
.
783L9
.
885
8l
.
16
-
.
143h
.
16l
.
62
.
61v
.
267l
.
58
.
027
.
003
.
002V8
.
76l
.
18
-
.
03
1
.
234
1
.
24
.
753
-
.
708h
.
382l
.
116
.
108c0
.
02
.
003
.
016
.
003
.
036v
.
065c0
3
.
09
-
2
.
515
5
.
603
-
5
.
605
5
.
603M8
.
47
3C4
.
904
3
2
5
.
903
2
9
.
47c0
3
.
57
2
.
903
6
.
472
6
.
47
6
.
472
3
.
57
0
6
.
472
-
2
.
903
6
.
472
-
6
.
47C14
.
942
5
.
9
12
.
04
3
8
.
472
3
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
path
d
=
\
"
M4
2v12h9V4
.
775L9
.
888
2H4zm0
-
1h5
.
888c
.
246
0
.
483
.
09
.
666
.
254l3
.
112
2
.
774c
.
212
.
19
.
334
.
462
.
334
.
747V14c0
.
552
-
.
448
1
-
1
1H4c
-
.
552
0
-
1
-
.
448
-
1
-
1V2c0
-
.
552
.
448
-
1
1
-
1z
\
"
>
<
/
path
>
<
path
d
=
\
"
M9
1
.
5v4c0
.
325
.
306
.
564
.
62
.
485l4
-
1c
.
27
-
.
067
.
432
-
.
338
.
365
-
.
606
-
.
067
-
.
27
-
.
338
-
.
432
-
.
606
-
.
365l
-
4
1L10
5
.
5v
-
4c0
-
.
276
-
.
224
-
.
5
-
.
5
-
.
5s
-
.
5
.
224
-
.
5
.
5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E5
\
"
>
<
path
d
=
\
"
M2
5
.
193v7
.
652c0
.
003
-
.
002
0
.
007
0H14v
-
7
.
69c0
-
.
003
.
002
0
-
.
007
0h
-
7
.
53v
-
2
.
15c0
-
.
002
-
.
004
-
.
005
-
.
01
-
.
005H2
.
01C2
3
2
3
2
3
.
005V5
.
193zm
-
1
0V3
.
005C1
2
.
45
1
.
444
2
2
.
01
2h4
.
442c
.
558
0
1
.
01
.
45
1
.
01
1
.
005v1
.
15h6
.
53c
.
557
0
1
.
008
.
44
1
.
008
1v7
.
69c0
.
553
-
.
45
1
-
1
.
007
1H2
.
007c
-
.
556
0
-
1
.
007
-
.
44
-
1
.
007
-
1V5
.
193zM6
.
08
4
.
15H2v1h4
.
46v
-
1h
-
.
38z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
14
6
13
12
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
g
id
=
\
"
world
\
"
stroke
=
\
"
none
\
"
stroke
-
width
=
\
"
1
\
"
fill
=
\
"
none
\
"
fill
-
rule
=
\
"
evenodd
\
"
transform
=
\
"
translate
(
14
.
000000
6
.
000000
)
\
"
stroke
-
linecap
=
\
"
round
\
"
stroke
-
linejoin
=
\
"
round
\
"
>
<
path
d
=
\
"
M6
.
35076107
0
.
354
C3
.
25095418
0
.
354
0
.
729
2
.
87582735
0
.
729
5
.
9758879
C0
.
729
9
.
07544113
3
.
25082735
11
.
5972685
6
.
35076107
11
.
5972685
C9
.
45044113
11
.
5972685
11
.
9723953
9
.
07544113
11
.
9723953
5
.
97576107
C11
.
9723953
2
.
87582735
9
.
45044113
0
.
354
6
.
35076107
0
.
354
L6
.
35076107
0
.
354
Z
M6
.
35076107
10
.
8289121
C3
.
67445071
10
.
8289121
1
.
49722956
8
.
65181776
1
.
49722956
5
.
97576107
C1
.
49722956
5
.
9443064
1
.
49900522
5
.
91335907
1
.
49976622
5
.
88215806
L2
.
20090094
6
.
4213266
L2
.
56313696
6
.
4213266
L2
.
97268183
6
.
8306178
L2
.
97268183
7
.
68217686
L3
.
32324919
8
.
03287105
L3
.
73926255
8
.
03287105
L3
.
73926255
9
.
79940584
L4
.
27386509
10
.
3361645
L4
.
4591686
10
.
3361645
L4
.
4591686
10
.
000183
L5
.
37655417
9
.
08343163
L5
.
37655417
8
.
73400577
L5
.
85585737
8
.
25203907
L5
.
85585737
7
.
37206934
L5
.
32518666
7
.
37206934
L4
.
28439226
6
.
33140176
L2
.
82225748
6
.
33140176
L2
.
82225748
5
.
56938704
L3
.
96286973
5
.
56938704
L3
.
96286973
5
.
23949352
L4
.
65068695
5
.
23949352
L5
.
11477015
4
.
77667865
L5
.
11477015
4
.
03001076
L4
.
49087694
3
.
40662489
L3
.
75359472
3
.
40662489
L3
.
75359472
3
.
78725175
L2
.
96228149
3
.
78725175
L2
.
96228149
3
.
28385021
L3
.
42217919
2
.
82319151
L3
.
42217919
2
.
49786399
L2
.
97001833
2
.
49786399
C3
.
84466106
1
.
64744643
5
.
03714814
1
.
12222956
6
.
35063424
1
.
12222956
C7
.
57292716
1
.
12222956
8
.
69020207
1
.
57730759
9
.
54442463
2
.
32587797
L8
.
46164839
2
.
32587797
L7
.
680355
3
.
10666403
L8
.
21508437
3
.
64088607
L7
.
87238068
3
.
98257509
L7
.
7165025
3
.
82669692
L7
.
85297518
3
.
68946324
L7
.
78930484
3
.
62566607
L7
.
78943167
3
.
62566607
L7
.
56011699
3
.
39559038
L7
.
55986332
3
.
39571722
L7
.
49758815
3
.
33318838
L7
.
01904595
3
.
78585658
L7
.
55910232
4
.
32654712
L6
.
8069806
4
.
32198112
L6
.
8069806
5
.
25864535
L7
.
66716433
5
.
25864535
L7
.
6723645
4
.
72112565
L7
.
81289584
4
.
57996014
L8
.
31819988
5
.
08653251
L8
.
31819988
5
.
41921636
L9
.
00703176
5
.
41921636
L9
.
03366676
5
.
39321553
L9
.
03430093
5
.
39194719
L10
.
195587
6
.
55259911
L10
.
8637451
5
.
88520206
L11
.
2018828
5
.
88520206
C11
.
2023901
5
.
9153884
11
.
2041658
5
.
94532107
11
.
2041658
5
.
97563424
C11
.
2040389
8
.
65181776
9
.
0269446
10
.
8289121
6
.
35076107
10
.
8289121
L6
.
35076107
10
.
8289121
Z
\
"
id
=
\
"
Shape
\
"
stroke
=
\
"
#
DDE1E5
\
"
stroke
-
width
=
\
"
0
.
25
\
"
fill
=
\
"
#
DDE1E5
\
"
>
<
/
path
>
<
polygon
id
=
\
"
Shape
\
"
stroke
=
\
"
#
DDE1E5
\
"
stroke
-
width
=
\
"
0
.
25
\
"
fill
=
\
"
#
DDE1E5
\
"
points
=
\
"
6
.
50676608
1
.
61523076
4
.
52892694
1
.
61789426
4
.
52892694
2
.
95192735
5
.
34560683
3
.
76733891
5
.
72496536
3
.
76733891
5
.
72496536
3
.
1967157
6
.
50676608
2
.
41592965
\
"
>
<
/
polygon
>
<
polygon
id
=
\
"
Shape
\
"
stroke
=
\
"
#
DDE1E5
\
"
stroke
-
width
=
\
"
0
.
25
\
"
fill
=
\
"
#
DDE1E5
\
"
points
=
\
"
9
.
59959714
6
.
88718547
8
.
28623788
5
.
57268471
8
.
28623788
5
.
57002121
6
.
79607294
5
.
57002121
6
.
35101474
6
.
01469891
6
.
35101474
6
.
96201714
6
.
98429362
7
.
59466185
8
.
12909136
7
.
59466185
8
.
12909136
8
.
70343893
8
.
99434843
9
.
56882283
9
.
20971144
9
.
56882283
9
.
20971144
8
.
50329592
9
.
63029081
8
.
08271655
9
.
63029081
7
.
3026915
9
.
87025949
7
.
3026915
10
.
1711082
7
.
00082814
10
.
0558167
6
.
88718547
\
"
>
<
/
polygon
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
488
384
14
14
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
path
d
=
\
"
M495
.
5
391
.
5
L500
.
200877
396
.
200877
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
#
4A90E2
\
"
stroke
-
width
=
\
"
1
.
25
\
"
stroke
-
linecap
=
\
"
round
\
"
stroke
-
linejoin
=
\
"
round
\
"
fill
=
\
"
none
\
"
>
<
/
path
>
<
ellipse
id
=
\
"
Oval
-
6
\
"
stroke
=
\
"
#
4A90E2
\
"
stroke
-
width
=
\
"
1
.
25
\
"
fill
=
\
"
#
FFFFFF
\
"
fill
-
rule
=
\
"
evenodd
\
"
cx
=
\
"
493
.
5
\
"
cy
=
\
"
389
.
5
\
"
rx
=
\
"
4
.
5
\
"
ry
=
\
"
4
.
5
\
"
>
<
/
ellipse
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M6
.
5
12
.
003l
.
052
-
9a
.
5
.
5
0
1
0
-
1
-
.
006l
-
.
052
9a
.
5
.
5
0
1
0
1
.
006zM13
11
.
997l
-
.
05
-
9a
.
488
.
488
0
0
0
-
.
477
-
.
497
.
488
.
488
0
0
0
-
.
473
.
503l
.
05
9a
.
488
.
488
0
0
0
.
477
.
497
.
488
.
488
0
0
0
.
473
-
.
503z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
975
569
11
11
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
g
id
=
\
"
Pause
-
circle
\
"
stroke
=
\
"
none
\
"
stroke
-
width
=
\
"
1
\
"
fill
=
\
"
none
\
"
fill
-
rule
=
\
"
evenodd
\
"
transform
=
\
"
translate
(
976
.
000000
570
.
000000
)
\
"
>
<
path
d
=
\
"
M4
.
5
0
.
538639227
C2
.
3152037
0
.
538639227
0
.
538639227
2
.
31614868
0
.
538639227
4
.
5
C0
.
538639227
6
.
6847963
2
.
3152037
8
.
46136077
4
.
5
8
.
46136077
C6
.
6847963
8
.
46136077
8
.
46136077
6
.
6847963
8
.
46136077
4
.
5
C8
.
46136077
2
.
31614868
6
.
6847963
0
.
538639227
4
.
5
0
.
538639227
M4
.
5
9
C2
.
01847963
9
0
6
.
98152037
0
4
.
5
C0
2
.
01847963
2
.
01847963
0
4
.
5
0
C6
.
98152037
0
9
2
.
01847963
9
4
.
5
C9
6
.
98152037
6
.
98152037
9
4
.
5
9
\
"
id
=
\
"
Fill
-
1
-
Copy
\
"
stroke
=
\
"
#
4990E2
\
"
stroke
-
width
=
\
"
0
.
5
\
"
fill
=
\
"
#
4990E2
\
"
>
<
/
path
>
<
path
d
=
\
"
M3
3
L3
6
.
5
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
#
4990E2
\
"
stroke
-
width
=
\
"
1
.
15
\
"
stroke
-
linecap
=
\
"
round
\
"
>
<
/
path
>
<
path
d
=
\
"
M6
3
L6
6
.
5
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
#
4990E2
\
"
stroke
-
width
=
\
"
1
.
15
\
"
stroke
-
linecap
=
\
"
round
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
>
<
path
d
=
\
"
M10
.
483
13
.
995H5
.
517l
-
3
.
512
-
3
.
512V5
.
516l3
.
512
-
3
.
512h4
.
966l3
.
512
3
.
512v4
.
967l
-
3
.
512
3
.
512zm4
.
37
-
9
.
042l
-
3
.
807
-
3
.
805A
.
503
.
503
0
0
0
10
.
691
1H5
.
309a
.
503
.
503
0
0
0
-
.
356
.
148L1
.
147
4
.
953A
.
502
.
502
0
0
0
1
5
.
308v5
.
383c0
.
134
.
053
.
262
.
147
.
356l3
.
806
3
.
806a
.
503
.
503
0
0
0
.
356
.
147h5
.
382a
.
503
.
503
0
0
0
.
355
-
.
147l3
.
806
-
3
.
806A
.
502
.
502
0
0
0
15
10
.
69V5
.
308a
.
502
.
502
0
0
0
-
.
147
-
.
355z
\
"
>
<
/
path
>
<
path
d
=
\
"
M10
10
.
5a
.
5
.
5
0
1
0
1
0v
-
5a
.
5
.
5
0
1
0
-
1
0v5zM5
10
.
5a
.
5
.
5
0
1
0
1
0v
-
5a
.
5
.
5
0
0
0
-
1
0v5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
path
d
=
\
"
M4
.
525
13
.
21h
-
.
472c
-
.
574
0
-
.
987
-
.
154
-
1
.
24
-
.
463
-
.
253
-
.
31
-
.
38
-
.
882
-
.
38
-
1
.
719v
-
.
573c0
-
.
746
-
.
097
-
1
.
265
-
.
292
-
1
.
557
-
.
196
-
.
293
-
.
51
-
.
44
-
.
945
-
.
44v
-
.
974c
.
435
0
.
75
-
.
146
.
945
-
.
44
.
195
-
.
292
.
293
-
.
811
.
293
-
1
.
556v
-
.
58c0
-
.
833
.
126
-
1
.
404
.
379
-
1
.
712
.
253
-
.
31
.
666
-
.
464
1
.
24
-
.
464h
.
472v
.
783h
-
.
179c
-
.
37
0
-
.
628
.
08
-
.
774
.
24
-
.
145
.
159
-
.
218
.
54
-
.
218
1
.
141v
.
383c0
.
824
-
.
096
1
.
432
-
.
287
1
.
823
-
.
191
.
39
-
.
516
.
679
-
.
974
.
866
.
458
.
191
.
783
.
482
.
974
.
873
.
191
.
39
.
287
.
998
.
287
1
.
823v
.
382c0
.
602
.
073
.
982
.
218
1
.
142
.
146
.
16
.
404
.
239
.
774
.
239h
.
18v
.
783zm9
.
502
-
4
.
752c
-
.
43
0
-
.
744
.
147
-
.
942
.
44
-
.
197
.
292
-
.
296
.
811
-
.
296
1
.
557v
.
573c0
.
837
-
.
125
1
.
41
-
.
376
1
.
719
-
.
251
.
309
-
.
664
.
463
-
1
.
237
.
463h
-
.
478v
-
.
783h
.
185c
.
37
0
.
628
-
.
08
.
774
-
.
24
.
145
-
.
159
.
218
-
.
539
.
218
-
1
.
14v
-
.
383c0
-
.
825
.
096
-
1
.
433
.
287
-
1
.
823
.
191
-
.
39
.
516
-
.
682
.
974
-
.
873
-
.
458
-
.
187
-
.
783
-
.
476
-
.
974
-
.
866
-
.
191
-
.
391
-
.
287
-
.
999
-
.
287
-
1
.
823v
-
.
383c0
-
.
602
-
.
073
-
.
982
-
.
218
-
1
.
142
-
.
146
-
.
159
-
.
404
-
.
239
-
.
774
-
.
239h
-
.
185v
-
.
783h
.
478c
.
573
0
.
986
.
155
1
.
237
.
464
.
25
.
308
.
376
.
88
.
376
1
.
712v
.
58c0
.
673
.
088
1
.
174
.
263
1
.
503
.
176
.
329
.
5
.
493
.
975
.
493v
.
974z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
696969
\
"
>
<
path
d
=
\
"
M6
.
925
12
.
5l7
.
4
-
5
-
7
.
4
-
5v10zM6
12
.
5v
-
10c0
-
.
785
.
8
-
1
.
264
1
.
415
-
.
848l7
.
4
5c
.
58
.
392
.
58
1
.
304
0
1
.
696l
-
7
.
4
5C6
.
8
13
.
764
6
13
.
285
6
12
.
5z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
viewBox
=
\
"
0
0
33
12
\
"
>
<
path
id
=
\
"
base
-
path
\
"
d
=
\
"
M27
.
1
0H1C0
.
4
0
0
0
.
4
0
1v10c0
0
.
6
0
.
4
1
1
1h26
.
1
c0
.
6
0
1
.
2
-
0
.
3
1
.
5
-
0
.
7L33
6l
-
4
.
4
-
5
.
3C28
.
2
0
.
3
27
.
7
0
27
.
1
0z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M1
.
5
14
.
042h4
.
095a
.
5
.
5
0
0
0
0
-
1H1
.
5a
.
5
.
5
0
1
0
0
1zM7
.
983
2a
.
5
.
5
0
0
1
.
517
.
5v7
.
483l3
.
136
-
3
.
326a
.
5
.
5
0
1
1
.
728
.
686l
-
4
4
.
243a
.
499
.
499
0
0
1
-
.
73
-
.
004L3
.
635
7
.
343a
.
5
.
5
0
0
1
.
728
-
.
686L7
.
5
9
.
983V3H1
.
536C1
.
24
3
1
2
.
776
1
2
.
5s
.
24
-
.
5
.
536
-
.
5h6
.
447zM10
.
5
14
.
042h4
.
095a
.
5
.
5
0
0
0
0
-
1H10
.
5a
.
5
.
5
0
1
0
0
1z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M5
13
.
5H1a
.
5
.
5
0
1
0
0
1h4a
.
5
.
5
0
1
0
0
-
1zM12
13
.
5H8a
.
5
.
5
0
1
0
0
1h4a
.
5
.
5
0
1
0
0
-
1zM6
.
11
5
.
012A
.
427
.
427
0
0
1
6
.
21
5h7
.
083L9
.
646
1
.
354a
.
5
.
5
0
1
1
.
708
-
.
708l4
.
5
4
.
5a
.
498
.
498
0
0
1
0
.
708l
-
4
.
5
4
.
5a
.
5
.
5
0
0
1
-
.
708
-
.
708L13
.
293
6H6
.
5v5
.
5a
.
5
.
5
0
1
1
-
1
0v
-
6a
.
5
.
5
0
0
1
.
61
-
.
488z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M13
.
297
6
.
912C12
.
595
4
.
39
10
.
167
2
.
5
7
.
398
2
.
5A5
.
898
5
.
898
0
0
0
1
.
5
8
.
398a
.
5
.
5
0
0
0
1
0A4
.
898
4
.
898
0
0
1
7
.
398
3
.
5c2
.
75
0
5
.
102
2
.
236
5
.
102
4
.
898v
.
004L8
.
669
7
.
029a
.
5
.
5
0
0
0
-
.
338
.
942l4
.
462
1
.
598a
.
5
.
5
0
0
0
.
651
-
.
34
.
506
.
506
0
0
0
.
02
-
.
043l2
-
5a
.
5
.
5
0
1
0
-
.
928
-
.
372l
-
1
.
24
3
.
098z
\
"
>
<
/
path
>
<
circle
cx
=
\
"
7
\
"
cy
=
\
"
12
\
"
r
=
\
"
1
\
"
>
<
/
circle
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
696969
\
"
>
<
path
d
=
\
"
M12
.
219
7c
.
345
0
.
635
.
117
.
869
.
352
.
234
.
234
.
351
.
524
.
351
.
869
0
.
351
-
.
118
.
652
-
.
356
.
903
-
.
238
.
25
-
.
526
.
376
-
.
864
.
376
-
.
332
0
-
.
615
-
.
125
-
.
85
-
.
376a1
.
276
1
.
276
0
0
1
-
.
351
-
.
903A1
.
185
1
.
185
0
0
1
12
.
218
7zM8
.
234
7c
.
345
0
.
635
.
117
.
87
.
352
.
234
.
234
.
351
.
524
.
351
.
869
0
.
351
-
.
119
.
652
-
.
356
.
903
-
.
238
.
25
-
.
526
.
376
-
.
865
.
376
-
.
332
0
-
.
613
-
.
125
-
.
844
-
.
376a1
.
286
1
.
286
0
0
1
-
.
347
-
.
903c0
-
.
352
.
114
-
.
643
.
342
-
.
874
.
228
-
.
231
.
51
-
.
347
.
85
-
.
347zM4
.
201
7c
.
339
0
.
627
.
117
.
864
.
352
.
238
.
234
.
357
.
524
.
357
.
869
0
.
351
-
.
119
.
652
-
.
357
.
903
-
.
237
.
25
-
.
525
.
376
-
.
864
.
376
-
.
338
0
-
.
623
-
.
125
-
.
854
-
.
376A1
.
286
1
.
286
0
0
1
3
8
.
221
1
.
185
1
.
185
0
0
1
4
.
201
7z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
path
fill
-
rule
=
\
"
evenodd
\
"
d
=
\
"
M8
.
5
8
.
793L5
.
854
6
.
146l
-
.
04
-
.
035L7
.
5
4
.
426c
.
2
-
.
2
.
3
-
.
4
.
3
-
.
6
0
-
.
2
-
.
1
-
.
4
-
.
2
-
.
6l
-
1
-
1c
-
.
4
-
.
3
-
.
9
-
.
3
-
1
.
2
0l
-
4
.
1
4
.
1c
-
.
2
.
2
-
.
3
.
4
-
.
3
.
6
0
.
2
.
1
.
4
.
2
.
6l1
1c
.
3
.
3
.
9
.
3
1
.
2
0l1
.
71
-
1
.
71
.
036
.
04L7
.
793
9
.
5l
-
3
.
647
3
.
646c
-
.
195
.
196
-
.
195
.
512
0
.
708
.
196
.
195
.
512
.
195
.
708
0L8
.
5
10
.
207l3
.
646
3
.
647c
.
196
.
195
.
512
.
195
.
708
0
.
195
-
.
196
.
195
-
.
512
0
-
.
708L9
.
207
9
.
5l2
.
565
-
2
.
565L13
.
3
8
.
5c
.
1
.
1
2
.
3
1
.
1
2
.
7
.
7
.
4
-
.
4
-
.
3
-
2
.
7
-
.
5
-
2
.
9l
-
1
.
1
-
1
.
1c
.
1
-
.
1
.
2
-
.
4
.
2
-
.
6
0
-
.
2
-
.
1
-
.
4
-
.
2
-
.
6l
-
.
4
-
.
4c
-
.
3
-
.
3
-
.
8
-
.
3
-
1
.
1
0l
-
1
.
5
-
1
.
4c
-
.
2
-
.
2
-
.
3
-
.
2
-
.
5
-
.
2s
-
.
3
.
1
-
.
5
.
2L9
.
2
3
.
4c
-
.
2
.
1
-
.
2
.
2
-
.
2
.
4s
.
1
.
4
.
2
.
5l1
.
874
1
.
92L8
.
5
8
.
792z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
413
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Sources
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Sources
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
sources
-
panel
{
\
n
flex
:
1
;
\
n
display
:
flex
;
\
n
flex
-
direction
:
column
;
\
n
overflow
:
hidden
;
\
n
}
\
n
\
n
.
sources
-
list
{
\
n
flex
:
1
;
\
n
display
:
flex
;
\
n
overflow
:
hidden
;
\
n
font
-
size
:
0
.
75em
;
\
n
}
\
n
\
nul
.
sources
-
list
{
\
n
list
-
style
:
none
;
\
n
margin
:
20px
0
;
\
n
padding
:
0
;
\
n
padding
-
left
:
10px
;
\
n
flex
:
1
;
\
n
white
-
space
:
nowrap
;
\
n
}
\
n
\
n
.
sources
-
list
ul
{
\
n
list
-
style
:
none
;
\
n
margin
:
0
.
5em
0
;
\
n
padding
:
0
;
\
n
}
\
n
\
n
.
sources
-
list
.
source
-
item
{
\
n
list
-
style
:
none
;
\
n
white
-
space
:
nowrap
;
\
n
}
\
n
\
n
.
sources
-
list
.
label
{
\
n
font
-
size
:
1em
;
\
n
padding
-
left
:
10px
;
\
n
color
:
var
(
-
-
theme
-
comment
)
;
\
n
}
\
n
\
n
.
sources
-
list
.
source
-
item
.
selected
{
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
}
\
n
\
n
.
sources
-
list
.
source
-
item
.
selected
.
label
{
\
n
color
:
var
(
-
-
theme
-
selection
-
color
)
;
\
n
}
\
n
\
n
.
arrow
\
n
.
folder
\
n
.
domain
\
n
.
file
\
n
.
worker
{
\
n
fill
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
}
\
n
\
n
.
domain
\
n
.
file
\
n
.
worker
{
\
n
position
:
relative
;
\
n
top
:
1px
;
\
n
}
\
n
\
n
.
worker
\
n
.
folder
{
\
n
position
:
relative
;
\
n
top
:
2px
;
\
n
}
\
n
\
n
.
domain
svg
\
n
.
folder
svg
\
n
.
worker
svg
{
\
n
width
:
15px
;
\
n
margin
-
right
:
5px
;
\
n
}
\
n
\
n
.
file
svg
{
\
n
width
:
13px
;
\
n
margin
-
right
:
5px
;
\
n
}
\
n
\
n
.
tree
{
\
n
-
webkit
-
user
-
select
:
none
;
\
n
-
moz
-
user
-
select
:
none
;
\
n
-
ms
-
user
-
select
:
none
;
\
n
-
o
-
user
-
select
:
none
;
\
n
user
-
select
:
none
;
\
n
\
n
flex
:
1
;
\
n
white
-
space
:
nowrap
;
\
n
overflow
:
auto
;
\
n
}
\
n
\
n
.
tree
button
{
\
n
display
:
block
;
\
n
}
\
n
\
n
.
tree
.
node
{
\
n
padding
:
2px
5px
;
\
n
position
:
relative
;
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
tree
.
node
:
hover
{
\
n
background
:
var
(
-
-
theme
-
tab
-
toolbar
-
background
)
;
\
n
}
\
n
\
n
.
tree
.
node
.
focused
{
\
n
color
:
white
;
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
}
\
n
\
n
.
tree
.
node
>
div
{
\
n
margin
-
left
:
10px
;
\
n
}
\
n
\
n
.
tree
.
node
.
focused
svg
{
\
n
fill
:
white
;
\
n
}
\
n
\
n
.
sources
-
list
.
tree
-
node
button
{
\
n
position
:
fixed
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
ImPropTypes
=
__webpack_require__
(
376
)
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
CodeMirror
=
__webpack_require__
(
415
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
_require3
=
__webpack_require__
(
195
)
;
var
debugGlobal
=
_require3
.
debugGlobal
;
var
_require4
=
__webpack_require__
(
196
)
;
var
isFirefox
=
_require4
.
isFirefox
;
var
_require5
=
__webpack_require__
(
348
)
;
var
getSourceText
=
_require5
.
getSourceText
;
var
getBreakpointsForSource
=
_require5
.
getBreakpointsForSource
;
var
getSelectedSource
=
_require5
.
getSelectedSource
;
var
getSelectedFrame
=
_require5
.
getSelectedFrame
;
var
_require6
=
__webpack_require__
(
343
)
;
var
makeLocationId
=
_require6
.
makeLocationId
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require7
=
__webpack_require__
(
416
)
;
var
alignLine
=
_require7
.
alignLine
;
var
onWheel
=
_require7
.
onWheel
;
var
resizeBreakpointGutter
=
_require7
.
resizeBreakpointGutter
;
var
Breakpoint
=
React
.
createFactory
(
__webpack_require__
(
417
)
)
;
__webpack_require__
(
418
)
;
__webpack_require__
(
420
)
;
__webpack_require__
(
422
)
;
__webpack_require__
(
423
)
;
function
isSourceForFrame
(
source
frame
)
{
return
frame
&
&
frame
.
location
.
sourceId
=
=
=
source
.
get
(
"
id
"
)
;
}
var
Editor
=
React
.
createClass
(
{
propTypes
:
{
breakpoints
:
ImPropTypes
.
map
.
isRequired
selectedSource
:
ImPropTypes
.
map
sourceText
:
PropTypes
.
object
addBreakpoint
:
PropTypes
.
func
removeBreakpoint
:
PropTypes
.
func
selectedFrame
:
PropTypes
.
object
}
displayName
:
"
Editor
"
componentDidMount
(
)
{
this
.
editor
=
CodeMirror
.
fromTextArea
(
this
.
refs
.
editor
{
mode
:
"
javascript
"
lineNumbers
:
true
theme
:
"
mozilla
"
lineWrapping
:
false
smartIndent
:
false
matchBrackets
:
true
styleActiveLine
:
true
readOnly
:
true
gutters
:
[
"
breakpoints
"
]
}
)
;
debugGlobal
(
"
cm
"
this
.
editor
)
;
this
.
editor
.
on
(
"
gutterClick
"
this
.
onGutterClick
)
;
if
(
isFirefox
(
)
)
{
this
.
editor
.
getScrollerElement
(
)
.
addEventListener
(
"
wheel
"
ev
=
>
onWheel
(
this
.
editor
ev
)
)
;
}
this
.
setText
(
this
.
props
.
sourceText
.
get
(
"
text
"
)
)
;
resizeBreakpointGutter
(
this
.
editor
)
;
}
onGutterClick
(
cm
line
gutter
ev
)
{
var
bp
=
this
.
props
.
breakpoints
.
find
(
b
=
>
{
return
b
.
location
.
line
=
=
=
line
+
1
;
}
)
;
if
(
bp
)
{
this
.
props
.
removeBreakpoint
(
{
sourceId
:
this
.
props
.
selectedSource
.
get
(
"
id
"
)
line
:
line
+
1
}
)
;
}
else
{
this
.
props
.
addBreakpoint
(
{
sourceId
:
this
.
props
.
selectedSource
.
get
(
"
id
"
)
line
:
line
+
1
}
{
getTextForLine
:
l
=
>
cm
.
getLine
(
l
-
1
)
.
trim
(
)
}
)
;
}
}
clearDebugLine
(
line
)
{
this
.
editor
.
removeLineClass
(
line
-
1
"
line
"
"
debug
-
line
"
)
;
}
setDebugLine
(
line
)
{
this
.
editor
.
addLineClass
(
line
-
1
"
line
"
"
debug
-
line
"
)
;
alignLine
(
this
.
editor
line
)
;
}
setSourceText
(
newSourceText
oldSourceText
)
{
if
(
newSourceText
.
get
(
"
loading
"
)
)
{
this
.
editor
.
setValue
(
"
Loading
.
.
.
"
)
;
return
;
}
if
(
newSourceText
.
get
(
"
error
"
)
)
{
this
.
editor
.
setValue
(
"
Error
"
)
;
console
.
error
(
newSourceText
.
get
(
"
error
"
)
)
;
return
;
}
this
.
setText
(
newSourceText
.
get
(
"
text
"
)
)
;
resizeBreakpointGutter
(
this
.
editor
)
;
}
setText
(
text
)
{
if
(
!
text
|
|
!
this
.
editor
)
{
return
;
}
if
(
text
=
=
this
.
editor
.
getValue
(
)
)
{
return
;
}
this
.
editor
.
setValue
(
text
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
isSourceForFrame
(
this
.
props
.
selectedSource
this
.
props
.
selectedFrame
)
)
{
this
.
clearDebugLine
(
this
.
props
.
selectedFrame
.
location
.
line
)
;
}
if
(
nextProps
.
sourceText
)
{
this
.
setSourceText
(
nextProps
.
sourceText
this
.
props
.
sourceText
)
;
}
if
(
this
.
props
.
selectedSource
&
&
!
nextProps
.
selectedSource
)
{
this
.
editor
.
setValue
(
"
"
)
;
}
if
(
isSourceForFrame
(
nextProps
.
selectedSource
nextProps
.
selectedFrame
)
)
{
this
.
setDebugLine
(
nextProps
.
selectedFrame
.
location
.
line
)
;
}
}
render
(
)
{
var
breakpoints
=
this
.
props
.
breakpoints
.
valueSeq
(
)
.
filter
(
bp
=
>
!
bp
.
disabled
)
;
return
dom
.
div
(
{
className
:
"
editor
-
wrapper
"
}
dom
.
textarea
(
{
ref
:
"
editor
"
defaultValue
:
"
.
.
.
"
}
)
breakpoints
.
map
(
bp
=
>
{
return
Breakpoint
(
{
key
:
makeLocationId
(
bp
.
location
)
breakpoint
:
bp
editor
:
this
.
editor
}
)
;
}
)
)
;
}
}
)
;
module
.
exports
=
connect
(
(
state
props
)
=
>
{
var
selectedSource
=
getSelectedSource
(
state
)
;
var
selectedId
=
selectedSource
&
&
selectedSource
.
get
(
"
id
"
)
;
return
{
selectedSource
:
selectedSource
sourceText
:
getSourceText
(
state
selectedId
)
breakpoints
:
getBreakpointsForSource
(
state
selectedId
)
selectedFrame
:
getSelectedFrame
(
state
)
}
;
}
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Editor
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
mod
)
{
if
(
true
)
module
.
exports
=
mod
(
)
;
else
if
(
typeof
define
=
=
"
function
"
&
&
define
.
amd
)
return
define
(
[
]
mod
)
;
else
(
this
|
|
window
)
.
CodeMirror
=
mod
(
)
;
}
)
(
function
(
)
{
"
use
strict
"
;
var
userAgent
=
navigator
.
userAgent
;
var
platform
=
navigator
.
platform
;
var
gecko
=
/
gecko
\
/
\
d
/
i
.
test
(
userAgent
)
;
var
ie_upto10
=
/
MSIE
\
d
/
.
test
(
userAgent
)
;
var
ie_11up
=
/
Trident
\
/
(
?
:
[
7
-
9
]
|
\
d
{
2
}
)
\
.
.
*
rv
:
(
\
d
+
)
/
.
exec
(
userAgent
)
;
var
ie
=
ie_upto10
|
|
ie_11up
;
var
ie_version
=
ie
&
&
(
ie_upto10
?
document
.
documentMode
|
|
6
:
ie_11up
[
1
]
)
;
var
webkit
=
/
WebKit
\
/
/
.
test
(
userAgent
)
;
var
qtwebkit
=
webkit
&
&
/
Qt
\
/
\
d
+
\
.
\
d
+
/
.
test
(
userAgent
)
;
var
chrome
=
/
Chrome
\
/
/
.
test
(
userAgent
)
;
var
presto
=
/
Opera
\
/
/
.
test
(
userAgent
)
;
var
safari
=
/
Apple
Computer
/
.
test
(
navigator
.
vendor
)
;
var
mac_geMountainLion
=
/
Mac
OS
X
1
\
d
\
D
(
[
8
-
9
]
|
\
d
\
d
)
\
D
/
.
test
(
userAgent
)
;
var
phantom
=
/
PhantomJS
/
.
test
(
userAgent
)
;
var
ios
=
/
AppleWebKit
/
.
test
(
userAgent
)
&
&
/
Mobile
\
/
\
w
+
/
.
test
(
userAgent
)
;
var
mobile
=
ios
|
|
/
Android
|
webOS
|
BlackBerry
|
Opera
Mini
|
Opera
Mobi
|
IEMobile
/
i
.
test
(
userAgent
)
;
var
mac
=
ios
|
|
/
Mac
/
.
test
(
platform
)
;
var
chromeOS
=
/
\
bCrOS
\
b
/
.
test
(
userAgent
)
;
var
windows
=
/
win
/
i
.
test
(
platform
)
;
var
presto_version
=
presto
&
&
userAgent
.
match
(
/
Version
\
/
(
\
d
*
\
.
\
d
*
)
/
)
;
if
(
presto_version
)
presto_version
=
Number
(
presto_version
[
1
]
)
;
if
(
presto_version
&
&
presto_version
>
=
15
)
{
presto
=
false
;
webkit
=
true
;
}
var
flipCtrlCmd
=
mac
&
&
(
qtwebkit
|
|
presto
&
&
(
presto_version
=
=
null
|
|
presto_version
<
12
.
11
)
)
;
var
captureRightClick
=
gecko
|
|
(
ie
&
&
ie_version
>
=
9
)
;
var
sawReadOnlySpans
=
false
sawCollapsedSpans
=
false
;
function
CodeMirror
(
place
options
)
{
if
(
!
(
this
instanceof
CodeMirror
)
)
return
new
CodeMirror
(
place
options
)
;
this
.
options
=
options
=
options
?
copyObj
(
options
)
:
{
}
;
copyObj
(
defaults
options
false
)
;
setGuttersForLineNumbers
(
options
)
;
var
doc
=
options
.
value
;
if
(
typeof
doc
=
=
"
string
"
)
doc
=
new
Doc
(
doc
options
.
mode
null
options
.
lineSeparator
)
;
this
.
doc
=
doc
;
var
input
=
new
CodeMirror
.
inputStyles
[
options
.
inputStyle
]
(
this
)
;
var
display
=
this
.
display
=
new
Display
(
place
doc
input
)
;
display
.
wrapper
.
CodeMirror
=
this
;
updateGutters
(
this
)
;
themeChanged
(
this
)
;
if
(
options
.
lineWrapping
)
this
.
display
.
wrapper
.
className
+
=
"
CodeMirror
-
wrap
"
;
if
(
options
.
autofocus
&
&
!
mobile
)
display
.
input
.
focus
(
)
;
initScrollbars
(
this
)
;
this
.
state
=
{
keyMaps
:
[
]
overlays
:
[
]
modeGen
:
0
overwrite
:
false
delayingBlurEvent
:
false
focused
:
false
suppressEdits
:
false
pasteIncoming
:
false
cutIncoming
:
false
selectingText
:
false
draggingText
:
false
highlight
:
new
Delayed
(
)
keySeq
:
null
specialChars
:
null
}
;
var
cm
=
this
;
if
(
ie
&
&
ie_version
<
11
)
setTimeout
(
function
(
)
{
cm
.
display
.
input
.
reset
(
true
)
;
}
20
)
;
registerEventHandlers
(
this
)
;
ensureGlobalHandlers
(
)
;
startOperation
(
this
)
;
this
.
curOp
.
forceUpdate
=
true
;
attachDoc
(
this
doc
)
;
if
(
(
options
.
autofocus
&
&
!
mobile
)
|
|
cm
.
hasFocus
(
)
)
setTimeout
(
bind
(
onFocus
this
)
20
)
;
else
onBlur
(
this
)
;
for
(
var
opt
in
optionHandlers
)
if
(
optionHandlers
.
hasOwnProperty
(
opt
)
)
optionHandlers
[
opt
]
(
this
options
[
opt
]
Init
)
;
maybeUpdateLineNumberWidth
(
this
)
;
if
(
options
.
finishInit
)
options
.
finishInit
(
this
)
;
for
(
var
i
=
0
;
i
<
initHooks
.
length
;
+
+
i
)
initHooks
[
i
]
(
this
)
;
endOperation
(
this
)
;
if
(
webkit
&
&
options
.
lineWrapping
&
&
getComputedStyle
(
display
.
lineDiv
)
.
textRendering
=
=
"
optimizelegibility
"
)
display
.
lineDiv
.
style
.
textRendering
=
"
auto
"
;
}
function
Display
(
place
doc
input
)
{
var
d
=
this
;
this
.
input
=
input
;
d
.
scrollbarFiller
=
elt
(
"
div
"
null
"
CodeMirror
-
scrollbar
-
filler
"
)
;
d
.
scrollbarFiller
.
setAttribute
(
"
cm
-
not
-
content
"
"
true
"
)
;
d
.
gutterFiller
=
elt
(
"
div
"
null
"
CodeMirror
-
gutter
-
filler
"
)
;
d
.
gutterFiller
.
setAttribute
(
"
cm
-
not
-
content
"
"
true
"
)
;
d
.
lineDiv
=
elt
(
"
div
"
null
"
CodeMirror
-
code
"
)
;
d
.
selectionDiv
=
elt
(
"
div
"
null
null
"
position
:
relative
;
z
-
index
:
1
"
)
;
d
.
cursorDiv
=
elt
(
"
div
"
null
"
CodeMirror
-
cursors
"
)
;
d
.
measure
=
elt
(
"
div
"
null
"
CodeMirror
-
measure
"
)
;
d
.
lineMeasure
=
elt
(
"
div
"
null
"
CodeMirror
-
measure
"
)
;
d
.
lineSpace
=
elt
(
"
div
"
[
d
.
measure
d
.
lineMeasure
d
.
selectionDiv
d
.
cursorDiv
d
.
lineDiv
]
null
"
position
:
relative
;
outline
:
none
"
)
;
d
.
mover
=
elt
(
"
div
"
[
elt
(
"
div
"
[
d
.
lineSpace
]
"
CodeMirror
-
lines
"
)
]
null
"
position
:
relative
"
)
;
d
.
sizer
=
elt
(
"
div
"
[
d
.
mover
]
"
CodeMirror
-
sizer
"
)
;
d
.
sizerWidth
=
null
;
d
.
heightForcer
=
elt
(
"
div
"
null
null
"
position
:
absolute
;
height
:
"
+
scrollerGap
+
"
px
;
width
:
1px
;
"
)
;
d
.
gutters
=
elt
(
"
div
"
null
"
CodeMirror
-
gutters
"
)
;
d
.
lineGutter
=
null
;
d
.
scroller
=
elt
(
"
div
"
[
d
.
sizer
d
.
heightForcer
d
.
gutters
]
"
CodeMirror
-
scroll
"
)
;
d
.
scroller
.
setAttribute
(
"
tabIndex
"
"
-
1
"
)
;
d
.
wrapper
=
elt
(
"
div
"
[
d
.
scrollbarFiller
d
.
gutterFiller
d
.
scroller
]
"
CodeMirror
"
)
;
if
(
ie
&
&
ie_version
<
8
)
{
d
.
gutters
.
style
.
zIndex
=
-
1
;
d
.
scroller
.
style
.
paddingRight
=
0
;
}
if
(
!
webkit
&
&
!
(
gecko
&
&
mobile
)
)
d
.
scroller
.
draggable
=
true
;
if
(
place
)
{
if
(
place
.
appendChild
)
place
.
appendChild
(
d
.
wrapper
)
;
else
place
(
d
.
wrapper
)
;
}
d
.
viewFrom
=
d
.
viewTo
=
doc
.
first
;
d
.
reportedViewFrom
=
d
.
reportedViewTo
=
doc
.
first
;
d
.
view
=
[
]
;
d
.
renderedView
=
null
;
d
.
externalMeasured
=
null
;
d
.
viewOffset
=
0
;
d
.
lastWrapHeight
=
d
.
lastWrapWidth
=
0
;
d
.
updateLineNumbers
=
null
;
d
.
nativeBarWidth
=
d
.
barHeight
=
d
.
barWidth
=
0
;
d
.
scrollbarsClipped
=
false
;
d
.
lineNumWidth
=
d
.
lineNumInnerWidth
=
d
.
lineNumChars
=
null
;
d
.
alignWidgets
=
false
;
d
.
cachedCharWidth
=
d
.
cachedTextHeight
=
d
.
cachedPaddingH
=
null
;
d
.
maxLine
=
null
;
d
.
maxLineLength
=
0
;
d
.
maxLineChanged
=
false
;
d
.
wheelDX
=
d
.
wheelDY
=
d
.
wheelStartX
=
d
.
wheelStartY
=
null
;
d
.
shift
=
false
;
d
.
selForContextMenu
=
null
;
d
.
activeTouch
=
null
;
input
.
init
(
d
)
;
}
function
loadMode
(
cm
)
{
cm
.
doc
.
mode
=
CodeMirror
.
getMode
(
cm
.
options
cm
.
doc
.
modeOption
)
;
resetModeState
(
cm
)
;
}
function
resetModeState
(
cm
)
{
cm
.
doc
.
iter
(
function
(
line
)
{
if
(
line
.
stateAfter
)
line
.
stateAfter
=
null
;
if
(
line
.
styles
)
line
.
styles
=
null
;
}
)
;
cm
.
doc
.
frontier
=
cm
.
doc
.
first
;
startWorker
(
cm
100
)
;
cm
.
state
.
modeGen
+
+
;
if
(
cm
.
curOp
)
regChange
(
cm
)
;
}
function
wrappingChanged
(
cm
)
{
if
(
cm
.
options
.
lineWrapping
)
{
addClass
(
cm
.
display
.
wrapper
"
CodeMirror
-
wrap
"
)
;
cm
.
display
.
sizer
.
style
.
minWidth
=
"
"
;
cm
.
display
.
sizerWidth
=
null
;
}
else
{
rmClass
(
cm
.
display
.
wrapper
"
CodeMirror
-
wrap
"
)
;
findMaxLine
(
cm
)
;
}
estimateLineHeights
(
cm
)
;
regChange
(
cm
)
;
clearCaches
(
cm
)
;
setTimeout
(
function
(
)
{
updateScrollbars
(
cm
)
;
}
100
)
;
}
function
estimateHeight
(
cm
)
{
var
th
=
textHeight
(
cm
.
display
)
wrapping
=
cm
.
options
.
lineWrapping
;
var
perLine
=
wrapping
&
&
Math
.
max
(
5
cm
.
display
.
scroller
.
clientWidth
/
charWidth
(
cm
.
display
)
-
3
)
;
return
function
(
line
)
{
if
(
lineIsHidden
(
cm
.
doc
line
)
)
return
0
;
var
widgetsHeight
=
0
;
if
(
line
.
widgets
)
for
(
var
i
=
0
;
i
<
line
.
widgets
.
length
;
i
+
+
)
{
if
(
line
.
widgets
[
i
]
.
height
)
widgetsHeight
+
=
line
.
widgets
[
i
]
.
height
;
}
if
(
wrapping
)
return
widgetsHeight
+
(
Math
.
ceil
(
line
.
text
.
length
/
perLine
)
|
|
1
)
*
th
;
else
return
widgetsHeight
+
th
;
}
;
}
function
estimateLineHeights
(
cm
)
{
var
doc
=
cm
.
doc
est
=
estimateHeight
(
cm
)
;
doc
.
iter
(
function
(
line
)
{
var
estHeight
=
est
(
line
)
;
if
(
estHeight
!
=
line
.
height
)
updateLineHeight
(
line
estHeight
)
;
}
)
;
}
function
themeChanged
(
cm
)
{
cm
.
display
.
wrapper
.
className
=
cm
.
display
.
wrapper
.
className
.
replace
(
/
\
s
*
cm
-
s
-
\
S
+
/
g
"
"
)
+
cm
.
options
.
theme
.
replace
(
/
(
^
|
\
s
)
\
s
*
/
g
"
cm
-
s
-
"
)
;
clearCaches
(
cm
)
;
}
function
guttersChanged
(
cm
)
{
updateGutters
(
cm
)
;
regChange
(
cm
)
;
setTimeout
(
function
(
)
{
alignHorizontally
(
cm
)
;
}
20
)
;
}
function
updateGutters
(
cm
)
{
var
gutters
=
cm
.
display
.
gutters
specs
=
cm
.
options
.
gutters
;
removeChildren
(
gutters
)
;
for
(
var
i
=
0
;
i
<
specs
.
length
;
+
+
i
)
{
var
gutterClass
=
specs
[
i
]
;
var
gElt
=
gutters
.
appendChild
(
elt
(
"
div
"
null
"
CodeMirror
-
gutter
"
+
gutterClass
)
)
;
if
(
gutterClass
=
=
"
CodeMirror
-
linenumbers
"
)
{
cm
.
display
.
lineGutter
=
gElt
;
gElt
.
style
.
width
=
(
cm
.
display
.
lineNumWidth
|
|
1
)
+
"
px
"
;
}
}
gutters
.
style
.
display
=
i
?
"
"
:
"
none
"
;
updateGutterSpace
(
cm
)
;
}
function
updateGutterSpace
(
cm
)
{
var
width
=
cm
.
display
.
gutters
.
offsetWidth
;
cm
.
display
.
sizer
.
style
.
marginLeft
=
width
+
"
px
"
;
}
function
lineLength
(
line
)
{
if
(
line
.
height
=
=
0
)
return
0
;
var
len
=
line
.
text
.
length
merged
cur
=
line
;
while
(
merged
=
collapsedSpanAtStart
(
cur
)
)
{
var
found
=
merged
.
find
(
0
true
)
;
cur
=
found
.
from
.
line
;
len
+
=
found
.
from
.
ch
-
found
.
to
.
ch
;
}
cur
=
line
;
while
(
merged
=
collapsedSpanAtEnd
(
cur
)
)
{
var
found
=
merged
.
find
(
0
true
)
;
len
-
=
cur
.
text
.
length
-
found
.
from
.
ch
;
cur
=
found
.
to
.
line
;
len
+
=
cur
.
text
.
length
-
found
.
to
.
ch
;
}
return
len
;
}
function
findMaxLine
(
cm
)
{
var
d
=
cm
.
display
doc
=
cm
.
doc
;
d
.
maxLine
=
getLine
(
doc
doc
.
first
)
;
d
.
maxLineLength
=
lineLength
(
d
.
maxLine
)
;
d
.
maxLineChanged
=
true
;
doc
.
iter
(
function
(
line
)
{
var
len
=
lineLength
(
line
)
;
if
(
len
>
d
.
maxLineLength
)
{
d
.
maxLineLength
=
len
;
d
.
maxLine
=
line
;
}
}
)
;
}
function
setGuttersForLineNumbers
(
options
)
{
var
found
=
indexOf
(
options
.
gutters
"
CodeMirror
-
linenumbers
"
)
;
if
(
found
=
=
-
1
&
&
options
.
lineNumbers
)
{
options
.
gutters
=
options
.
gutters
.
concat
(
[
"
CodeMirror
-
linenumbers
"
]
)
;
}
else
if
(
found
>
-
1
&
&
!
options
.
lineNumbers
)
{
options
.
gutters
=
options
.
gutters
.
slice
(
0
)
;
options
.
gutters
.
splice
(
found
1
)
;
}
}
function
measureForScrollbars
(
cm
)
{
var
d
=
cm
.
display
gutterW
=
d
.
gutters
.
offsetWidth
;
var
docH
=
Math
.
round
(
cm
.
doc
.
height
+
paddingVert
(
cm
.
display
)
)
;
return
{
clientHeight
:
d
.
scroller
.
clientHeight
viewHeight
:
d
.
wrapper
.
clientHeight
scrollWidth
:
d
.
scroller
.
scrollWidth
clientWidth
:
d
.
scroller
.
clientWidth
viewWidth
:
d
.
wrapper
.
clientWidth
barLeft
:
cm
.
options
.
fixedGutter
?
gutterW
:
0
docHeight
:
docH
scrollHeight
:
docH
+
scrollGap
(
cm
)
+
d
.
barHeight
nativeBarWidth
:
d
.
nativeBarWidth
gutterWidth
:
gutterW
}
;
}
function
NativeScrollbars
(
place
scroll
cm
)
{
this
.
cm
=
cm
;
var
vert
=
this
.
vert
=
elt
(
"
div
"
[
elt
(
"
div
"
null
null
"
min
-
width
:
1px
"
)
]
"
CodeMirror
-
vscrollbar
"
)
;
var
horiz
=
this
.
horiz
=
elt
(
"
div
"
[
elt
(
"
div
"
null
null
"
height
:
100
%
;
min
-
height
:
1px
"
)
]
"
CodeMirror
-
hscrollbar
"
)
;
place
(
vert
)
;
place
(
horiz
)
;
on
(
vert
"
scroll
"
function
(
)
{
if
(
vert
.
clientHeight
)
scroll
(
vert
.
scrollTop
"
vertical
"
)
;
}
)
;
on
(
horiz
"
scroll
"
function
(
)
{
if
(
horiz
.
clientWidth
)
scroll
(
horiz
.
scrollLeft
"
horizontal
"
)
;
}
)
;
this
.
checkedZeroWidth
=
false
;
if
(
ie
&
&
ie_version
<
8
)
this
.
horiz
.
style
.
minHeight
=
this
.
vert
.
style
.
minWidth
=
"
18px
"
;
}
NativeScrollbars
.
prototype
=
copyObj
(
{
update
:
function
(
measure
)
{
var
needsH
=
measure
.
scrollWidth
>
measure
.
clientWidth
+
1
;
var
needsV
=
measure
.
scrollHeight
>
measure
.
clientHeight
+
1
;
var
sWidth
=
measure
.
nativeBarWidth
;
if
(
needsV
)
{
this
.
vert
.
style
.
display
=
"
block
"
;
this
.
vert
.
style
.
bottom
=
needsH
?
sWidth
+
"
px
"
:
"
0
"
;
var
totalHeight
=
measure
.
viewHeight
-
(
needsH
?
sWidth
:
0
)
;
this
.
vert
.
firstChild
.
style
.
height
=
Math
.
max
(
0
measure
.
scrollHeight
-
measure
.
clientHeight
+
totalHeight
)
+
"
px
"
;
}
else
{
this
.
vert
.
style
.
display
=
"
"
;
this
.
vert
.
firstChild
.
style
.
height
=
"
0
"
;
}
if
(
needsH
)
{
this
.
horiz
.
style
.
display
=
"
block
"
;
this
.
horiz
.
style
.
right
=
needsV
?
sWidth
+
"
px
"
:
"
0
"
;
this
.
horiz
.
style
.
left
=
measure
.
barLeft
+
"
px
"
;
var
totalWidth
=
measure
.
viewWidth
-
measure
.
barLeft
-
(
needsV
?
sWidth
:
0
)
;
this
.
horiz
.
firstChild
.
style
.
width
=
(
measure
.
scrollWidth
-
measure
.
clientWidth
+
totalWidth
)
+
"
px
"
;
}
else
{
this
.
horiz
.
style
.
display
=
"
"
;
this
.
horiz
.
firstChild
.
style
.
width
=
"
0
"
;
}
if
(
!
this
.
checkedZeroWidth
&
&
measure
.
clientHeight
>
0
)
{
if
(
sWidth
=
=
0
)
this
.
zeroWidthHack
(
)
;
this
.
checkedZeroWidth
=
true
;
}
return
{
right
:
needsV
?
sWidth
:
0
bottom
:
needsH
?
sWidth
:
0
}
;
}
setScrollLeft
:
function
(
pos
)
{
if
(
this
.
horiz
.
scrollLeft
!
=
pos
)
this
.
horiz
.
scrollLeft
=
pos
;
if
(
this
.
disableHoriz
)
this
.
enableZeroWidthBar
(
this
.
horiz
this
.
disableHoriz
)
;
}
setScrollTop
:
function
(
pos
)
{
if
(
this
.
vert
.
scrollTop
!
=
pos
)
this
.
vert
.
scrollTop
=
pos
;
if
(
this
.
disableVert
)
this
.
enableZeroWidthBar
(
this
.
vert
this
.
disableVert
)
;
}
zeroWidthHack
:
function
(
)
{
var
w
=
mac
&
&
!
mac_geMountainLion
?
"
12px
"
:
"
18px
"
;
this
.
horiz
.
style
.
height
=
this
.
vert
.
style
.
width
=
w
;
this
.
horiz
.
style
.
pointerEvents
=
this
.
vert
.
style
.
pointerEvents
=
"
none
"
;
this
.
disableHoriz
=
new
Delayed
;
this
.
disableVert
=
new
Delayed
;
}
enableZeroWidthBar
:
function
(
bar
delay
)
{
bar
.
style
.
pointerEvents
=
"
auto
"
;
function
maybeDisable
(
)
{
var
box
=
bar
.
getBoundingClientRect
(
)
;
var
elt
=
document
.
elementFromPoint
(
box
.
left
+
1
box
.
bottom
-
1
)
;
if
(
elt
!
=
bar
)
bar
.
style
.
pointerEvents
=
"
none
"
;
else
delay
.
set
(
1000
maybeDisable
)
;
}
delay
.
set
(
1000
maybeDisable
)
;
}
clear
:
function
(
)
{
var
parent
=
this
.
horiz
.
parentNode
;
parent
.
removeChild
(
this
.
horiz
)
;
parent
.
removeChild
(
this
.
vert
)
;
}
}
NativeScrollbars
.
prototype
)
;
function
NullScrollbars
(
)
{
}
NullScrollbars
.
prototype
=
copyObj
(
{
update
:
function
(
)
{
return
{
bottom
:
0
right
:
0
}
;
}
setScrollLeft
:
function
(
)
{
}
setScrollTop
:
function
(
)
{
}
clear
:
function
(
)
{
}
}
NullScrollbars
.
prototype
)
;
CodeMirror
.
scrollbarModel
=
{
"
native
"
:
NativeScrollbars
"
null
"
:
NullScrollbars
}
;
function
initScrollbars
(
cm
)
{
if
(
cm
.
display
.
scrollbars
)
{
cm
.
display
.
scrollbars
.
clear
(
)
;
if
(
cm
.
display
.
scrollbars
.
addClass
)
rmClass
(
cm
.
display
.
wrapper
cm
.
display
.
scrollbars
.
addClass
)
;
}
cm
.
display
.
scrollbars
=
new
CodeMirror
.
scrollbarModel
[
cm
.
options
.
scrollbarStyle
]
(
function
(
node
)
{
cm
.
display
.
wrapper
.
insertBefore
(
node
cm
.
display
.
scrollbarFiller
)
;
on
(
node
"
mousedown
"
function
(
)
{
if
(
cm
.
state
.
focused
)
setTimeout
(
function
(
)
{
cm
.
display
.
input
.
focus
(
)
;
}
0
)
;
}
)
;
node
.
setAttribute
(
"
cm
-
not
-
content
"
"
true
"
)
;
}
function
(
pos
axis
)
{
if
(
axis
=
=
"
horizontal
"
)
setScrollLeft
(
cm
pos
)
;
else
setScrollTop
(
cm
pos
)
;
}
cm
)
;
if
(
cm
.
display
.
scrollbars
.
addClass
)
addClass
(
cm
.
display
.
wrapper
cm
.
display
.
scrollbars
.
addClass
)
;
}
function
updateScrollbars
(
cm
measure
)
{
if
(
!
measure
)
measure
=
measureForScrollbars
(
cm
)
;
var
startWidth
=
cm
.
display
.
barWidth
startHeight
=
cm
.
display
.
barHeight
;
updateScrollbarsInner
(
cm
measure
)
;
for
(
var
i
=
0
;
i
<
4
&
&
startWidth
!
=
cm
.
display
.
barWidth
|
|
startHeight
!
=
cm
.
display
.
barHeight
;
i
+
+
)
{
if
(
startWidth
!
=
cm
.
display
.
barWidth
&
&
cm
.
options
.
lineWrapping
)
updateHeightsInViewport
(
cm
)
;
updateScrollbarsInner
(
cm
measureForScrollbars
(
cm
)
)
;
startWidth
=
cm
.
display
.
barWidth
;
startHeight
=
cm
.
display
.
barHeight
;
}
}
function
updateScrollbarsInner
(
cm
measure
)
{
var
d
=
cm
.
display
;
var
sizes
=
d
.
scrollbars
.
update
(
measure
)
;
d
.
sizer
.
style
.
paddingRight
=
(
d
.
barWidth
=
sizes
.
right
)
+
"
px
"
;
d
.
sizer
.
style
.
paddingBottom
=
(
d
.
barHeight
=
sizes
.
bottom
)
+
"
px
"
;
d
.
heightForcer
.
style
.
borderBottom
=
sizes
.
bottom
+
"
px
solid
transparent
"
if
(
sizes
.
right
&
&
sizes
.
bottom
)
{
d
.
scrollbarFiller
.
style
.
display
=
"
block
"
;
d
.
scrollbarFiller
.
style
.
height
=
sizes
.
bottom
+
"
px
"
;
d
.
scrollbarFiller
.
style
.
width
=
sizes
.
right
+
"
px
"
;
}
else
d
.
scrollbarFiller
.
style
.
display
=
"
"
;
if
(
sizes
.
bottom
&
&
cm
.
options
.
coverGutterNextToScrollbar
&
&
cm
.
options
.
fixedGutter
)
{
d
.
gutterFiller
.
style
.
display
=
"
block
"
;
d
.
gutterFiller
.
style
.
height
=
sizes
.
bottom
+
"
px
"
;
d
.
gutterFiller
.
style
.
width
=
measure
.
gutterWidth
+
"
px
"
;
}
else
d
.
gutterFiller
.
style
.
display
=
"
"
;
}
function
visibleLines
(
display
doc
viewport
)
{
var
top
=
viewport
&
&
viewport
.
top
!
=
null
?
Math
.
max
(
0
viewport
.
top
)
:
display
.
scroller
.
scrollTop
;
top
=
Math
.
floor
(
top
-
paddingTop
(
display
)
)
;
var
bottom
=
viewport
&
&
viewport
.
bottom
!
=
null
?
viewport
.
bottom
:
top
+
display
.
wrapper
.
clientHeight
;
var
from
=
lineAtHeight
(
doc
top
)
to
=
lineAtHeight
(
doc
bottom
)
;
if
(
viewport
&
&
viewport
.
ensure
)
{
var
ensureFrom
=
viewport
.
ensure
.
from
.
line
ensureTo
=
viewport
.
ensure
.
to
.
line
;
if
(
ensureFrom
<
from
)
{
from
=
ensureFrom
;
to
=
lineAtHeight
(
doc
heightAtLine
(
getLine
(
doc
ensureFrom
)
)
+
display
.
wrapper
.
clientHeight
)
;
}
else
if
(
Math
.
min
(
ensureTo
doc
.
lastLine
(
)
)
>
=
to
)
{
from
=
lineAtHeight
(
doc
heightAtLine
(
getLine
(
doc
ensureTo
)
)
-
display
.
wrapper
.
clientHeight
)
;
to
=
ensureTo
;
}
}
return
{
from
:
from
to
:
Math
.
max
(
to
from
+
1
)
}
;
}
function
alignHorizontally
(
cm
)
{
var
display
=
cm
.
display
view
=
display
.
view
;
if
(
!
display
.
alignWidgets
&
&
(
!
display
.
gutters
.
firstChild
|
|
!
cm
.
options
.
fixedGutter
)
)
return
;
var
comp
=
compensateForHScroll
(
display
)
-
display
.
scroller
.
scrollLeft
+
cm
.
doc
.
scrollLeft
;
var
gutterW
=
display
.
gutters
.
offsetWidth
left
=
comp
+
"
px
"
;
for
(
var
i
=
0
;
i
<
view
.
length
;
i
+
+
)
if
(
!
view
[
i
]
.
hidden
)
{
if
(
cm
.
options
.
fixedGutter
&
&
view
[
i
]
.
gutter
)
view
[
i
]
.
gutter
.
style
.
left
=
left
;
var
align
=
view
[
i
]
.
alignable
;
if
(
align
)
for
(
var
j
=
0
;
j
<
align
.
length
;
j
+
+
)
align
[
j
]
.
style
.
left
=
left
;
}
if
(
cm
.
options
.
fixedGutter
)
display
.
gutters
.
style
.
left
=
(
comp
+
gutterW
)
+
"
px
"
;
}
function
maybeUpdateLineNumberWidth
(
cm
)
{
if
(
!
cm
.
options
.
lineNumbers
)
return
false
;
var
doc
=
cm
.
doc
last
=
lineNumberFor
(
cm
.
options
doc
.
first
+
doc
.
size
-
1
)
display
=
cm
.
display
;
if
(
last
.
length
!
=
display
.
lineNumChars
)
{
var
test
=
display
.
measure
.
appendChild
(
elt
(
"
div
"
[
elt
(
"
div
"
last
)
]
"
CodeMirror
-
linenumber
CodeMirror
-
gutter
-
elt
"
)
)
;
var
innerW
=
test
.
firstChild
.
offsetWidth
padding
=
test
.
offsetWidth
-
innerW
;
display
.
lineGutter
.
style
.
width
=
"
"
;
display
.
lineNumInnerWidth
=
Math
.
max
(
innerW
display
.
lineGutter
.
offsetWidth
-
padding
)
+
1
;
display
.
lineNumWidth
=
display
.
lineNumInnerWidth
+
padding
;
display
.
lineNumChars
=
display
.
lineNumInnerWidth
?
last
.
length
:
-
1
;
display
.
lineGutter
.
style
.
width
=
display
.
lineNumWidth
+
"
px
"
;
updateGutterSpace
(
cm
)
;
return
true
;
}
return
false
;
}
function
lineNumberFor
(
options
i
)
{
return
String
(
options
.
lineNumberFormatter
(
i
+
options
.
firstLineNumber
)
)
;
}
function
compensateForHScroll
(
display
)
{
return
display
.
scroller
.
getBoundingClientRect
(
)
.
left
-
display
.
sizer
.
getBoundingClientRect
(
)
.
left
;
}
function
DisplayUpdate
(
cm
viewport
force
)
{
var
display
=
cm
.
display
;
this
.
viewport
=
viewport
;
this
.
visible
=
visibleLines
(
display
cm
.
doc
viewport
)
;
this
.
editorIsHidden
=
!
display
.
wrapper
.
offsetWidth
;
this
.
wrapperHeight
=
display
.
wrapper
.
clientHeight
;
this
.
wrapperWidth
=
display
.
wrapper
.
clientWidth
;
this
.
oldDisplayWidth
=
displayWidth
(
cm
)
;
this
.
force
=
force
;
this
.
dims
=
getDimensions
(
cm
)
;
this
.
events
=
[
]
;
}
DisplayUpdate
.
prototype
.
signal
=
function
(
emitter
type
)
{
if
(
hasHandler
(
emitter
type
)
)
this
.
events
.
push
(
arguments
)
;
}
;
DisplayUpdate
.
prototype
.
finish
=
function
(
)
{
for
(
var
i
=
0
;
i
<
this
.
events
.
length
;
i
+
+
)
signal
.
apply
(
null
this
.
events
[
i
]
)
;
}
;
function
maybeClipScrollbars
(
cm
)
{
var
display
=
cm
.
display
;
if
(
!
display
.
scrollbarsClipped
&
&
display
.
scroller
.
offsetWidth
)
{
display
.
nativeBarWidth
=
display
.
scroller
.
offsetWidth
-
display
.
scroller
.
clientWidth
;
display
.
heightForcer
.
style
.
height
=
scrollGap
(
cm
)
+
"
px
"
;
display
.
sizer
.
style
.
marginBottom
=
-
display
.
nativeBarWidth
+
"
px
"
;
display
.
sizer
.
style
.
borderRightWidth
=
scrollGap
(
cm
)
+
"
px
"
;
display
.
scrollbarsClipped
=
true
;
}
}
function
updateDisplayIfNeeded
(
cm
update
)
{
var
display
=
cm
.
display
doc
=
cm
.
doc
;
if
(
update
.
editorIsHidden
)
{
resetView
(
cm
)
;
return
false
;
}
if
(
!
update
.
force
&
&
update
.
visible
.
from
>
=
display
.
viewFrom
&
&
update
.
visible
.
to
<
=
display
.
viewTo
&
&
(
display
.
updateLineNumbers
=
=
null
|
|
display
.
updateLineNumbers
>
=
display
.
viewTo
)
&
&
display
.
renderedView
=
=
display
.
view
&
&
countDirtyView
(
cm
)
=
=
0
)
return
false
;
if
(
maybeUpdateLineNumberWidth
(
cm
)
)
{
resetView
(
cm
)
;
update
.
dims
=
getDimensions
(
cm
)
;
}
var
end
=
doc
.
first
+
doc
.
size
;
var
from
=
Math
.
max
(
update
.
visible
.
from
-
cm
.
options
.
viewportMargin
doc
.
first
)
;
var
to
=
Math
.
min
(
end
update
.
visible
.
to
+
cm
.
options
.
viewportMargin
)
;
if
(
display
.
viewFrom
<
from
&
&
from
-
display
.
viewFrom
<
20
)
from
=
Math
.
max
(
doc
.
first
display
.
viewFrom
)
;
if
(
display
.
viewTo
>
to
&
&
display
.
viewTo
-
to
<
20
)
to
=
Math
.
min
(
end
display
.
viewTo
)
;
if
(
sawCollapsedSpans
)
{
from
=
visualLineNo
(
cm
.
doc
from
)
;
to
=
visualLineEndNo
(
cm
.
doc
to
)
;
}
var
different
=
from
!
=
display
.
viewFrom
|
|
to
!
=
display
.
viewTo
|
|
display
.
lastWrapHeight
!
=
update
.
wrapperHeight
|
|
display
.
lastWrapWidth
!
=
update
.
wrapperWidth
;
adjustView
(
cm
from
to
)
;
display
.
viewOffset
=
heightAtLine
(
getLine
(
cm
.
doc
display
.
viewFrom
)
)
;
cm
.
display
.
mover
.
style
.
top
=
display
.
viewOffset
+
"
px
"
;
var
toUpdate
=
countDirtyView
(
cm
)
;
if
(
!
different
&
&
toUpdate
=
=
0
&
&
!
update
.
force
&
&
display
.
renderedView
=
=
display
.
view
&
&
(
display
.
updateLineNumbers
=
=
null
|
|
display
.
updateLineNumbers
>
=
display
.
viewTo
)
)
return
false
;
var
focused
=
activeElt
(
)
;
if
(
toUpdate
>
4
)
display
.
lineDiv
.
style
.
display
=
"
none
"
;
patchDisplay
(
cm
display
.
updateLineNumbers
update
.
dims
)
;
if
(
toUpdate
>
4
)
display
.
lineDiv
.
style
.
display
=
"
"
;
display
.
renderedView
=
display
.
view
;
if
(
focused
&
&
activeElt
(
)
!
=
focused
&
&
focused
.
offsetHeight
)
focused
.
focus
(
)
;
removeChildren
(
display
.
cursorDiv
)
;
removeChildren
(
display
.
selectionDiv
)
;
display
.
gutters
.
style
.
height
=
display
.
sizer
.
style
.
minHeight
=
0
;
if
(
different
)
{
display
.
lastWrapHeight
=
update
.
wrapperHeight
;
display
.
lastWrapWidth
=
update
.
wrapperWidth
;
startWorker
(
cm
400
)
;
}
display
.
updateLineNumbers
=
null
;
return
true
;
}
function
postUpdateDisplay
(
cm
update
)
{
var
viewport
=
update
.
viewport
;
for
(
var
first
=
true
;
;
first
=
false
)
{
if
(
!
first
|
|
!
cm
.
options
.
lineWrapping
|
|
update
.
oldDisplayWidth
=
=
displayWidth
(
cm
)
)
{
if
(
viewport
&
&
viewport
.
top
!
=
null
)
viewport
=
{
top
:
Math
.
min
(
cm
.
doc
.
height
+
paddingVert
(
cm
.
display
)
-
displayHeight
(
cm
)
viewport
.
top
)
}
;
update
.
visible
=
visibleLines
(
cm
.
display
cm
.
doc
viewport
)
;
if
(
update
.
visible
.
from
>
=
cm
.
display
.
viewFrom
&
&
update
.
visible
.
to
<
=
cm
.
display
.
viewTo
)
break
;
}
if
(
!
updateDisplayIfNeeded
(
cm
update
)
)
break
;
updateHeightsInViewport
(
cm
)
;
var
barMeasure
=
measureForScrollbars
(
cm
)
;
updateSelection
(
cm
)
;
updateScrollbars
(
cm
barMeasure
)
;
setDocumentHeight
(
cm
barMeasure
)
;
}
update
.
signal
(
cm
"
update
"
cm
)
;
if
(
cm
.
display
.
viewFrom
!
=
cm
.
display
.
reportedViewFrom
|
|
cm
.
display
.
viewTo
!
=
cm
.
display
.
reportedViewTo
)
{
update
.
signal
(
cm
"
viewportChange
"
cm
cm
.
display
.
viewFrom
cm
.
display
.
viewTo
)
;
cm
.
display
.
reportedViewFrom
=
cm
.
display
.
viewFrom
;
cm
.
display
.
reportedViewTo
=
cm
.
display
.
viewTo
;
}
}
function
updateDisplaySimple
(
cm
viewport
)
{
var
update
=
new
DisplayUpdate
(
cm
viewport
)
;
if
(
updateDisplayIfNeeded
(
cm
update
)
)
{
updateHeightsInViewport
(
cm
)
;
postUpdateDisplay
(
cm
update
)
;
var
barMeasure
=
measureForScrollbars
(
cm
)
;
updateSelection
(
cm
)
;
updateScrollbars
(
cm
barMeasure
)
;
setDocumentHeight
(
cm
barMeasure
)
;
update
.
finish
(
)
;
}
}
function
setDocumentHeight
(
cm
measure
)
{
cm
.
display
.
sizer
.
style
.
minHeight
=
measure
.
docHeight
+
"
px
"
;
cm
.
display
.
heightForcer
.
style
.
top
=
measure
.
docHeight
+
"
px
"
;
cm
.
display
.
gutters
.
style
.
height
=
(
measure
.
docHeight
+
cm
.
display
.
barHeight
+
scrollGap
(
cm
)
)
+
"
px
"
;
}
function
updateHeightsInViewport
(
cm
)
{
var
display
=
cm
.
display
;
var
prevBottom
=
display
.
lineDiv
.
offsetTop
;
for
(
var
i
=
0
;
i
<
display
.
view
.
length
;
i
+
+
)
{
var
cur
=
display
.
view
[
i
]
height
;
if
(
cur
.
hidden
)
continue
;
if
(
ie
&
&
ie_version
<
8
)
{
var
bot
=
cur
.
node
.
offsetTop
+
cur
.
node
.
offsetHeight
;
height
=
bot
-
prevBottom
;
prevBottom
=
bot
;
}
else
{
var
box
=
cur
.
node
.
getBoundingClientRect
(
)
;
height
=
box
.
bottom
-
box
.
top
;
}
var
diff
=
cur
.
line
.
height
-
height
;
if
(
height
<
2
)
height
=
textHeight
(
display
)
;
if
(
diff
>
.
001
|
|
diff
<
-
.
001
)
{
updateLineHeight
(
cur
.
line
height
)
;
updateWidgetHeight
(
cur
.
line
)
;
if
(
cur
.
rest
)
for
(
var
j
=
0
;
j
<
cur
.
rest
.
length
;
j
+
+
)
updateWidgetHeight
(
cur
.
rest
[
j
]
)
;
}
}
}
function
updateWidgetHeight
(
line
)
{
if
(
line
.
widgets
)
for
(
var
i
=
0
;
i
<
line
.
widgets
.
length
;
+
+
i
)
line
.
widgets
[
i
]
.
height
=
line
.
widgets
[
i
]
.
node
.
parentNode
.
offsetHeight
;
}
function
getDimensions
(
cm
)
{
var
d
=
cm
.
display
left
=
{
}
width
=
{
}
;
var
gutterLeft
=
d
.
gutters
.
clientLeft
;
for
(
var
n
=
d
.
gutters
.
firstChild
i
=
0
;
n
;
n
=
n
.
nextSibling
+
+
i
)
{
left
[
cm
.
options
.
gutters
[
i
]
]
=
n
.
offsetLeft
+
n
.
clientLeft
+
gutterLeft
;
width
[
cm
.
options
.
gutters
[
i
]
]
=
n
.
clientWidth
;
}
return
{
fixedPos
:
compensateForHScroll
(
d
)
gutterTotalWidth
:
d
.
gutters
.
offsetWidth
gutterLeft
:
left
gutterWidth
:
width
wrapperWidth
:
d
.
wrapper
.
clientWidth
}
;
}
function
patchDisplay
(
cm
updateNumbersFrom
dims
)
{
var
display
=
cm
.
display
lineNumbers
=
cm
.
options
.
lineNumbers
;
var
container
=
display
.
lineDiv
cur
=
container
.
firstChild
;
function
rm
(
node
)
{
var
next
=
node
.
nextSibling
;
if
(
webkit
&
&
mac
&
&
cm
.
display
.
currentWheelTarget
=
=
node
)
node
.
style
.
display
=
"
none
"
;
else
node
.
parentNode
.
removeChild
(
node
)
;
return
next
;
}
var
view
=
display
.
view
lineN
=
display
.
viewFrom
;
for
(
var
i
=
0
;
i
<
view
.
length
;
i
+
+
)
{
var
lineView
=
view
[
i
]
;
if
(
lineView
.
hidden
)
{
}
else
if
(
!
lineView
.
node
|
|
lineView
.
node
.
parentNode
!
=
container
)
{
var
node
=
buildLineElement
(
cm
lineView
lineN
dims
)
;
container
.
insertBefore
(
node
cur
)
;
}
else
{
while
(
cur
!
=
lineView
.
node
)
cur
=
rm
(
cur
)
;
var
updateNumber
=
lineNumbers
&
&
updateNumbersFrom
!
=
null
&
&
updateNumbersFrom
<
=
lineN
&
&
lineView
.
lineNumber
;
if
(
lineView
.
changes
)
{
if
(
indexOf
(
lineView
.
changes
"
gutter
"
)
>
-
1
)
updateNumber
=
false
;
updateLineForChanges
(
cm
lineView
lineN
dims
)
;
}
if
(
updateNumber
)
{
removeChildren
(
lineView
.
lineNumber
)
;
lineView
.
lineNumber
.
appendChild
(
document
.
createTextNode
(
lineNumberFor
(
cm
.
options
lineN
)
)
)
;
}
cur
=
lineView
.
node
.
nextSibling
;
}
lineN
+
=
lineView
.
size
;
}
while
(
cur
)
cur
=
rm
(
cur
)
;
}
function
updateLineForChanges
(
cm
lineView
lineN
dims
)
{
for
(
var
j
=
0
;
j
<
lineView
.
changes
.
length
;
j
+
+
)
{
var
type
=
lineView
.
changes
[
j
]
;
if
(
type
=
=
"
text
"
)
updateLineText
(
cm
lineView
)
;
else
if
(
type
=
=
"
gutter
"
)
updateLineGutter
(
cm
lineView
lineN
dims
)
;
else
if
(
type
=
=
"
class
"
)
updateLineClasses
(
lineView
)
;
else
if
(
type
=
=
"
widget
"
)
updateLineWidgets
(
cm
lineView
dims
)
;
}
lineView
.
changes
=
null
;
}
function
ensureLineWrapped
(
lineView
)
{
if
(
lineView
.
node
=
=
lineView
.
text
)
{
lineView
.
node
=
elt
(
"
div
"
null
null
"
position
:
relative
"
)
;
if
(
lineView
.
text
.
parentNode
)
lineView
.
text
.
parentNode
.
replaceChild
(
lineView
.
node
lineView
.
text
)
;
lineView
.
node
.
appendChild
(
lineView
.
text
)
;
if
(
ie
&
&
ie_version
<
8
)
lineView
.
node
.
style
.
zIndex
=
2
;
}
return
lineView
.
node
;
}
function
updateLineBackground
(
lineView
)
{
var
cls
=
lineView
.
bgClass
?
lineView
.
bgClass
+
"
"
+
(
lineView
.
line
.
bgClass
|
|
"
"
)
:
lineView
.
line
.
bgClass
;
if
(
cls
)
cls
+
=
"
CodeMirror
-
linebackground
"
;
if
(
lineView
.
background
)
{
if
(
cls
)
lineView
.
background
.
className
=
cls
;
else
{
lineView
.
background
.
parentNode
.
removeChild
(
lineView
.
background
)
;
lineView
.
background
=
null
;
}
}
else
if
(
cls
)
{
var
wrap
=
ensureLineWrapped
(
lineView
)
;
lineView
.
background
=
wrap
.
insertBefore
(
elt
(
"
div
"
null
cls
)
wrap
.
firstChild
)
;
}
}
function
getLineContent
(
cm
lineView
)
{
var
ext
=
cm
.
display
.
externalMeasured
;
if
(
ext
&
&
ext
.
line
=
=
lineView
.
line
)
{
cm
.
display
.
externalMeasured
=
null
;
lineView
.
measure
=
ext
.
measure
;
return
ext
.
built
;
}
return
buildLineContent
(
cm
lineView
)
;
}
function
updateLineText
(
cm
lineView
)
{
var
cls
=
lineView
.
text
.
className
;
var
built
=
getLineContent
(
cm
lineView
)
;
if
(
lineView
.
text
=
=
lineView
.
node
)
lineView
.
node
=
built
.
pre
;
lineView
.
text
.
parentNode
.
replaceChild
(
built
.
pre
lineView
.
text
)
;
lineView
.
text
=
built
.
pre
;
if
(
built
.
bgClass
!
=
lineView
.
bgClass
|
|
built
.
textClass
!
=
lineView
.
textClass
)
{
lineView
.
bgClass
=
built
.
bgClass
;
lineView
.
textClass
=
built
.
textClass
;
updateLineClasses
(
lineView
)
;
}
else
if
(
cls
)
{
lineView
.
text
.
className
=
cls
;
}
}
function
updateLineClasses
(
lineView
)
{
updateLineBackground
(
lineView
)
;
if
(
lineView
.
line
.
wrapClass
)
ensureLineWrapped
(
lineView
)
.
className
=
lineView
.
line
.
wrapClass
;
else
if
(
lineView
.
node
!
=
lineView
.
text
)
lineView
.
node
.
className
=
"
"
;
var
textClass
=
lineView
.
textClass
?
lineView
.
textClass
+
"
"
+
(
lineView
.
line
.
textClass
|
|
"
"
)
:
lineView
.
line
.
textClass
;
lineView
.
text
.
className
=
textClass
|
|
"
"
;
}
function
updateLineGutter
(
cm
lineView
lineN
dims
)
{
if
(
lineView
.
gutter
)
{
lineView
.
node
.
removeChild
(
lineView
.
gutter
)
;
lineView
.
gutter
=
null
;
}
if
(
lineView
.
gutterBackground
)
{
lineView
.
node
.
removeChild
(
lineView
.
gutterBackground
)
;
lineView
.
gutterBackground
=
null
;
}
if
(
lineView
.
line
.
gutterClass
)
{
var
wrap
=
ensureLineWrapped
(
lineView
)
;
lineView
.
gutterBackground
=
elt
(
"
div
"
null
"
CodeMirror
-
gutter
-
background
"
+
lineView
.
line
.
gutterClass
"
left
:
"
+
(
cm
.
options
.
fixedGutter
?
dims
.
fixedPos
:
-
dims
.
gutterTotalWidth
)
+
"
px
;
width
:
"
+
dims
.
gutterTotalWidth
+
"
px
"
)
;
wrap
.
insertBefore
(
lineView
.
gutterBackground
lineView
.
text
)
;
}
var
markers
=
lineView
.
line
.
gutterMarkers
;
if
(
cm
.
options
.
lineNumbers
|
|
markers
)
{
var
wrap
=
ensureLineWrapped
(
lineView
)
;
var
gutterWrap
=
lineView
.
gutter
=
elt
(
"
div
"
null
"
CodeMirror
-
gutter
-
wrapper
"
"
left
:
"
+
(
cm
.
options
.
fixedGutter
?
dims
.
fixedPos
:
-
dims
.
gutterTotalWidth
)
+
"
px
"
)
;
cm
.
display
.
input
.
setUneditable
(
gutterWrap
)
;
wrap
.
insertBefore
(
gutterWrap
lineView
.
text
)
;
if
(
lineView
.
line
.
gutterClass
)
gutterWrap
.
className
+
=
"
"
+
lineView
.
line
.
gutterClass
;
if
(
cm
.
options
.
lineNumbers
&
&
(
!
markers
|
|
!
markers
[
"
CodeMirror
-
linenumbers
"
]
)
)
lineView
.
lineNumber
=
gutterWrap
.
appendChild
(
elt
(
"
div
"
lineNumberFor
(
cm
.
options
lineN
)
"
CodeMirror
-
linenumber
CodeMirror
-
gutter
-
elt
"
"
left
:
"
+
dims
.
gutterLeft
[
"
CodeMirror
-
linenumbers
"
]
+
"
px
;
width
:
"
+
cm
.
display
.
lineNumInnerWidth
+
"
px
"
)
)
;
if
(
markers
)
for
(
var
k
=
0
;
k
<
cm
.
options
.
gutters
.
length
;
+
+
k
)
{
var
id
=
cm
.
options
.
gutters
[
k
]
found
=
markers
.
hasOwnProperty
(
id
)
&
&
markers
[
id
]
;
if
(
found
)
gutterWrap
.
appendChild
(
elt
(
"
div
"
[
found
]
"
CodeMirror
-
gutter
-
elt
"
"
left
:
"
+
dims
.
gutterLeft
[
id
]
+
"
px
;
width
:
"
+
dims
.
gutterWidth
[
id
]
+
"
px
"
)
)
;
}
}
}
function
updateLineWidgets
(
cm
lineView
dims
)
{
if
(
lineView
.
alignable
)
lineView
.
alignable
=
null
;
for
(
var
node
=
lineView
.
node
.
firstChild
next
;
node
;
node
=
next
)
{
var
next
=
node
.
nextSibling
;
if
(
node
.
className
=
=
"
CodeMirror
-
linewidget
"
)
lineView
.
node
.
removeChild
(
node
)
;
}
insertLineWidgets
(
cm
lineView
dims
)
;
}
function
buildLineElement
(
cm
lineView
lineN
dims
)
{
var
built
=
getLineContent
(
cm
lineView
)
;
lineView
.
text
=
lineView
.
node
=
built
.
pre
;
if
(
built
.
bgClass
)
lineView
.
bgClass
=
built
.
bgClass
;
if
(
built
.
textClass
)
lineView
.
textClass
=
built
.
textClass
;
updateLineClasses
(
lineView
)
;
updateLineGutter
(
cm
lineView
lineN
dims
)
;
insertLineWidgets
(
cm
lineView
dims
)
;
return
lineView
.
node
;
}
function
insertLineWidgets
(
cm
lineView
dims
)
{
insertLineWidgetsFor
(
cm
lineView
.
line
lineView
dims
true
)
;
if
(
lineView
.
rest
)
for
(
var
i
=
0
;
i
<
lineView
.
rest
.
length
;
i
+
+
)
insertLineWidgetsFor
(
cm
lineView
.
rest
[
i
]
lineView
dims
false
)
;
}
function
insertLineWidgetsFor
(
cm
line
lineView
dims
allowAbove
)
{
if
(
!
line
.
widgets
)
return
;
var
wrap
=
ensureLineWrapped
(
lineView
)
;
for
(
var
i
=
0
ws
=
line
.
widgets
;
i
<
ws
.
length
;
+
+
i
)
{
var
widget
=
ws
[
i
]
node
=
elt
(
"
div
"
[
widget
.
node
]
"
CodeMirror
-
linewidget
"
)
;
if
(
!
widget
.
handleMouseEvents
)
node
.
setAttribute
(
"
cm
-
ignore
-
events
"
"
true
"
)
;
positionLineWidget
(
widget
node
lineView
dims
)
;
cm
.
display
.
input
.
setUneditable
(
node
)
;
if
(
allowAbove
&
&
widget
.
above
)
wrap
.
insertBefore
(
node
lineView
.
gutter
|
|
lineView
.
text
)
;
else
wrap
.
appendChild
(
node
)
;
signalLater
(
widget
"
redraw
"
)
;
}
}
function
positionLineWidget
(
widget
node
lineView
dims
)
{
if
(
widget
.
noHScroll
)
{
(
lineView
.
alignable
|
|
(
lineView
.
alignable
=
[
]
)
)
.
push
(
node
)
;
var
width
=
dims
.
wrapperWidth
;
node
.
style
.
left
=
dims
.
fixedPos
+
"
px
"
;
if
(
!
widget
.
coverGutter
)
{
width
-
=
dims
.
gutterTotalWidth
;
node
.
style
.
paddingLeft
=
dims
.
gutterTotalWidth
+
"
px
"
;
}
node
.
style
.
width
=
width
+
"
px
"
;
}
if
(
widget
.
coverGutter
)
{
node
.
style
.
zIndex
=
5
;
node
.
style
.
position
=
"
relative
"
;
if
(
!
widget
.
noHScroll
)
node
.
style
.
marginLeft
=
-
dims
.
gutterTotalWidth
+
"
px
"
;
}
}
var
Pos
=
CodeMirror
.
Pos
=
function
(
line
ch
)
{
if
(
!
(
this
instanceof
Pos
)
)
return
new
Pos
(
line
ch
)
;
this
.
line
=
line
;
this
.
ch
=
ch
;
}
;
var
cmp
=
CodeMirror
.
cmpPos
=
function
(
a
b
)
{
return
a
.
line
-
b
.
line
|
|
a
.
ch
-
b
.
ch
;
}
;
function
copyPos
(
x
)
{
return
Pos
(
x
.
line
x
.
ch
)
;
}
function
maxPos
(
a
b
)
{
return
cmp
(
a
b
)
<
0
?
b
:
a
;
}
function
minPos
(
a
b
)
{
return
cmp
(
a
b
)
<
0
?
a
:
b
;
}
function
ensureFocus
(
cm
)
{
if
(
!
cm
.
state
.
focused
)
{
cm
.
display
.
input
.
focus
(
)
;
onFocus
(
cm
)
;
}
}
var
lastCopied
=
null
;
function
applyTextInput
(
cm
inserted
deleted
sel
origin
)
{
var
doc
=
cm
.
doc
;
cm
.
display
.
shift
=
false
;
if
(
!
sel
)
sel
=
doc
.
sel
;
var
paste
=
cm
.
state
.
pasteIncoming
|
|
origin
=
=
"
paste
"
;
var
textLines
=
doc
.
splitLines
(
inserted
)
multiPaste
=
null
if
(
paste
&
&
sel
.
ranges
.
length
>
1
)
{
if
(
lastCopied
&
&
lastCopied
.
text
.
join
(
"
\
n
"
)
=
=
inserted
)
{
if
(
sel
.
ranges
.
length
%
lastCopied
.
text
.
length
=
=
0
)
{
multiPaste
=
[
]
;
for
(
var
i
=
0
;
i
<
lastCopied
.
text
.
length
;
i
+
+
)
multiPaste
.
push
(
doc
.
splitLines
(
lastCopied
.
text
[
i
]
)
)
;
}
}
else
if
(
textLines
.
length
=
=
sel
.
ranges
.
length
)
{
multiPaste
=
map
(
textLines
function
(
l
)
{
return
[
l
]
;
}
)
;
}
}
for
(
var
i
=
sel
.
ranges
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
range
=
sel
.
ranges
[
i
]
;
var
from
=
range
.
from
(
)
to
=
range
.
to
(
)
;
if
(
range
.
empty
(
)
)
{
if
(
deleted
&
&
deleted
>
0
)
from
=
Pos
(
from
.
line
from
.
ch
-
deleted
)
;
else
if
(
cm
.
state
.
overwrite
&
&
!
paste
)
to
=
Pos
(
to
.
line
Math
.
min
(
getLine
(
doc
to
.
line
)
.
text
.
length
to
.
ch
+
lst
(
textLines
)
.
length
)
)
;
else
if
(
lastCopied
&
&
lastCopied
.
lineWise
&
&
lastCopied
.
text
.
join
(
"
\
n
"
)
=
=
inserted
)
from
=
to
=
Pos
(
from
.
line
0
)
}
var
updateInput
=
cm
.
curOp
.
updateInput
;
var
changeEvent
=
{
from
:
from
to
:
to
text
:
multiPaste
?
multiPaste
[
i
%
multiPaste
.
length
]
:
textLines
origin
:
origin
|
|
(
paste
?
"
paste
"
:
cm
.
state
.
cutIncoming
?
"
cut
"
:
"
+
input
"
)
}
;
makeChange
(
cm
.
doc
changeEvent
)
;
signalLater
(
cm
"
inputRead
"
cm
changeEvent
)
;
}
if
(
inserted
&
&
!
paste
)
triggerElectric
(
cm
inserted
)
;
ensureCursorVisible
(
cm
)
;
cm
.
curOp
.
updateInput
=
updateInput
;
cm
.
curOp
.
typing
=
true
;
cm
.
state
.
pasteIncoming
=
cm
.
state
.
cutIncoming
=
false
;
}
function
handlePaste
(
e
cm
)
{
var
pasted
=
e
.
clipboardData
&
&
e
.
clipboardData
.
getData
(
"
text
/
plain
"
)
;
if
(
pasted
)
{
e
.
preventDefault
(
)
;
if
(
!
cm
.
isReadOnly
(
)
&
&
!
cm
.
options
.
disableInput
)
runInOp
(
cm
function
(
)
{
applyTextInput
(
cm
pasted
0
null
"
paste
"
)
;
}
)
;
return
true
;
}
}
function
triggerElectric
(
cm
inserted
)
{
if
(
!
cm
.
options
.
electricChars
|
|
!
cm
.
options
.
smartIndent
)
return
;
var
sel
=
cm
.
doc
.
sel
;
for
(
var
i
=
sel
.
ranges
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
range
=
sel
.
ranges
[
i
]
;
if
(
range
.
head
.
ch
>
100
|
|
(
i
&
&
sel
.
ranges
[
i
-
1
]
.
head
.
line
=
=
range
.
head
.
line
)
)
continue
;
var
mode
=
cm
.
getModeAt
(
range
.
head
)
;
var
indented
=
false
;
if
(
mode
.
electricChars
)
{
for
(
var
j
=
0
;
j
<
mode
.
electricChars
.
length
;
j
+
+
)
if
(
inserted
.
indexOf
(
mode
.
electricChars
.
charAt
(
j
)
)
>
-
1
)
{
indented
=
indentLine
(
cm
range
.
head
.
line
"
smart
"
)
;
break
;
}
}
else
if
(
mode
.
electricInput
)
{
if
(
mode
.
electricInput
.
test
(
getLine
(
cm
.
doc
range
.
head
.
line
)
.
text
.
slice
(
0
range
.
head
.
ch
)
)
)
indented
=
indentLine
(
cm
range
.
head
.
line
"
smart
"
)
;
}
if
(
indented
)
signalLater
(
cm
"
electricInput
"
cm
range
.
head
.
line
)
;
}
}
function
copyableRanges
(
cm
)
{
var
text
=
[
]
ranges
=
[
]
;
for
(
var
i
=
0
;
i
<
cm
.
doc
.
sel
.
ranges
.
length
;
i
+
+
)
{
var
line
=
cm
.
doc
.
sel
.
ranges
[
i
]
.
head
.
line
;
var
lineRange
=
{
anchor
:
Pos
(
line
0
)
head
:
Pos
(
line
+
1
0
)
}
;
ranges
.
push
(
lineRange
)
;
text
.
push
(
cm
.
getRange
(
lineRange
.
anchor
lineRange
.
head
)
)
;
}
return
{
text
:
text
ranges
:
ranges
}
;
}
function
disableBrowserMagic
(
field
)
{
field
.
setAttribute
(
"
autocorrect
"
"
off
"
)
;
field
.
setAttribute
(
"
autocapitalize
"
"
off
"
)
;
field
.
setAttribute
(
"
spellcheck
"
"
false
"
)
;
}
function
TextareaInput
(
cm
)
{
this
.
cm
=
cm
;
this
.
prevInput
=
"
"
;
this
.
pollingFast
=
false
;
this
.
polling
=
new
Delayed
(
)
;
this
.
inaccurateSelection
=
false
;
this
.
hasSelection
=
false
;
this
.
composing
=
null
;
}
;
function
hiddenTextarea
(
)
{
var
te
=
elt
(
"
textarea
"
null
null
"
position
:
absolute
;
padding
:
0
;
width
:
1px
;
height
:
1em
;
outline
:
none
"
)
;
var
div
=
elt
(
"
div
"
[
te
]
null
"
overflow
:
hidden
;
position
:
relative
;
width
:
3px
;
height
:
0px
;
"
)
;
if
(
webkit
)
te
.
style
.
width
=
"
1000px
"
;
else
te
.
setAttribute
(
"
wrap
"
"
off
"
)
;
if
(
ios
)
te
.
style
.
border
=
"
1px
solid
black
"
;
disableBrowserMagic
(
te
)
;
return
div
;
}
TextareaInput
.
prototype
=
copyObj
(
{
init
:
function
(
display
)
{
var
input
=
this
cm
=
this
.
cm
;
var
div
=
this
.
wrapper
=
hiddenTextarea
(
)
;
var
te
=
this
.
textarea
=
div
.
firstChild
;
display
.
wrapper
.
insertBefore
(
div
display
.
wrapper
.
firstChild
)
;
if
(
ios
)
te
.
style
.
width
=
"
0px
"
;
on
(
te
"
input
"
function
(
)
{
if
(
ie
&
&
ie_version
>
=
9
&
&
input
.
hasSelection
)
input
.
hasSelection
=
null
;
input
.
poll
(
)
;
}
)
;
on
(
te
"
paste
"
function
(
e
)
{
if
(
signalDOMEvent
(
cm
e
)
|
|
handlePaste
(
e
cm
)
)
return
cm
.
state
.
pasteIncoming
=
true
;
input
.
fastPoll
(
)
;
}
)
;
function
prepareCopyCut
(
e
)
{
if
(
signalDOMEvent
(
cm
e
)
)
return
if
(
cm
.
somethingSelected
(
)
)
{
lastCopied
=
{
lineWise
:
false
text
:
cm
.
getSelections
(
)
}
;
if
(
input
.
inaccurateSelection
)
{
input
.
prevInput
=
"
"
;
input
.
inaccurateSelection
=
false
;
te
.
value
=
lastCopied
.
text
.
join
(
"
\
n
"
)
;
selectInput
(
te
)
;
}
}
else
if
(
!
cm
.
options
.
lineWiseCopyCut
)
{
return
;
}
else
{
var
ranges
=
copyableRanges
(
cm
)
;
lastCopied
=
{
lineWise
:
true
text
:
ranges
.
text
}
;
if
(
e
.
type
=
=
"
cut
"
)
{
cm
.
setSelections
(
ranges
.
ranges
null
sel_dontScroll
)
;
}
else
{
input
.
prevInput
=
"
"
;
te
.
value
=
ranges
.
text
.
join
(
"
\
n
"
)
;
selectInput
(
te
)
;
}
}
if
(
e
.
type
=
=
"
cut
"
)
cm
.
state
.
cutIncoming
=
true
;
}
on
(
te
"
cut
"
prepareCopyCut
)
;
on
(
te
"
copy
"
prepareCopyCut
)
;
on
(
display
.
scroller
"
paste
"
function
(
e
)
{
if
(
eventInWidget
(
display
e
)
|
|
signalDOMEvent
(
cm
e
)
)
return
;
cm
.
state
.
pasteIncoming
=
true
;
input
.
focus
(
)
;
}
)
;
on
(
display
.
lineSpace
"
selectstart
"
function
(
e
)
{
if
(
!
eventInWidget
(
display
e
)
)
e_preventDefault
(
e
)
;
}
)
;
on
(
te
"
compositionstart
"
function
(
)
{
var
start
=
cm
.
getCursor
(
"
from
"
)
;
if
(
input
.
composing
)
input
.
composing
.
range
.
clear
(
)
input
.
composing
=
{
start
:
start
range
:
cm
.
markText
(
start
cm
.
getCursor
(
"
to
"
)
{
className
:
"
CodeMirror
-
composing
"
}
)
}
;
}
)
;
on
(
te
"
compositionend
"
function
(
)
{
if
(
input
.
composing
)
{
input
.
poll
(
)
;
input
.
composing
.
range
.
clear
(
)
;
input
.
composing
=
null
;
}
}
)
;
}
prepareSelection
:
function
(
)
{
var
cm
=
this
.
cm
display
=
cm
.
display
doc
=
cm
.
doc
;
var
result
=
prepareSelection
(
cm
)
;
if
(
cm
.
options
.
moveInputWithCursor
)
{
var
headPos
=
cursorCoords
(
cm
doc
.
sel
.
primary
(
)
.
head
"
div
"
)
;
var
wrapOff
=
display
.
wrapper
.
getBoundingClientRect
(
)
lineOff
=
display
.
lineDiv
.
getBoundingClientRect
(
)
;
result
.
teTop
=
Math
.
max
(
0
Math
.
min
(
display
.
wrapper
.
clientHeight
-
10
headPos
.
top
+
lineOff
.
top
-
wrapOff
.
top
)
)
;
result
.
teLeft
=
Math
.
max
(
0
Math
.
min
(
display
.
wrapper
.
clientWidth
-
10
headPos
.
left
+
lineOff
.
left
-
wrapOff
.
left
)
)
;
}
return
result
;
}
showSelection
:
function
(
drawn
)
{
var
cm
=
this
.
cm
display
=
cm
.
display
;
removeChildrenAndAdd
(
display
.
cursorDiv
drawn
.
cursors
)
;
removeChildrenAndAdd
(
display
.
selectionDiv
drawn
.
selection
)
;
if
(
drawn
.
teTop
!
=
null
)
{
this
.
wrapper
.
style
.
top
=
drawn
.
teTop
+
"
px
"
;
this
.
wrapper
.
style
.
left
=
drawn
.
teLeft
+
"
px
"
;
}
}
reset
:
function
(
typing
)
{
if
(
this
.
contextMenuPending
)
return
;
var
minimal
selected
cm
=
this
.
cm
doc
=
cm
.
doc
;
if
(
cm
.
somethingSelected
(
)
)
{
this
.
prevInput
=
"
"
;
var
range
=
doc
.
sel
.
primary
(
)
;
minimal
=
hasCopyEvent
&
&
(
range
.
to
(
)
.
line
-
range
.
from
(
)
.
line
>
100
|
|
(
selected
=
cm
.
getSelection
(
)
)
.
length
>
1000
)
;
var
content
=
minimal
?
"
-
"
:
selected
|
|
cm
.
getSelection
(
)
;
this
.
textarea
.
value
=
content
;
if
(
cm
.
state
.
focused
)
selectInput
(
this
.
textarea
)
;
if
(
ie
&
&
ie_version
>
=
9
)
this
.
hasSelection
=
content
;
}
else
if
(
!
typing
)
{
this
.
prevInput
=
this
.
textarea
.
value
=
"
"
;
if
(
ie
&
&
ie_version
>
=
9
)
this
.
hasSelection
=
null
;
}
this
.
inaccurateSelection
=
minimal
;
}
getField
:
function
(
)
{
return
this
.
textarea
;
}
supportsTouch
:
function
(
)
{
return
false
;
}
focus
:
function
(
)
{
if
(
this
.
cm
.
options
.
readOnly
!
=
"
nocursor
"
&
&
(
!
mobile
|
|
activeElt
(
)
!
=
this
.
textarea
)
)
{
try
{
this
.
textarea
.
focus
(
)
;
}
catch
(
e
)
{
}
}
}
blur
:
function
(
)
{
this
.
textarea
.
blur
(
)
;
}
resetPosition
:
function
(
)
{
this
.
wrapper
.
style
.
top
=
this
.
wrapper
.
style
.
left
=
0
;
}
receivedFocus
:
function
(
)
{
this
.
slowPoll
(
)
;
}
slowPoll
:
function
(
)
{
var
input
=
this
;
if
(
input
.
pollingFast
)
return
;
input
.
polling
.
set
(
this
.
cm
.
options
.
pollInterval
function
(
)
{
input
.
poll
(
)
;
if
(
input
.
cm
.
state
.
focused
)
input
.
slowPoll
(
)
;
}
)
;
}
fastPoll
:
function
(
)
{
var
missed
=
false
input
=
this
;
input
.
pollingFast
=
true
;
function
p
(
)
{
var
changed
=
input
.
poll
(
)
;
if
(
!
changed
&
&
!
missed
)
{
missed
=
true
;
input
.
polling
.
set
(
60
p
)
;
}
else
{
input
.
pollingFast
=
false
;
input
.
slowPoll
(
)
;
}
}
input
.
polling
.
set
(
20
p
)
;
}
poll
:
function
(
)
{
var
cm
=
this
.
cm
input
=
this
.
textarea
prevInput
=
this
.
prevInput
;
if
(
this
.
contextMenuPending
|
|
!
cm
.
state
.
focused
|
|
(
hasSelection
(
input
)
&
&
!
prevInput
&
&
!
this
.
composing
)
|
|
cm
.
isReadOnly
(
)
|
|
cm
.
options
.
disableInput
|
|
cm
.
state
.
keySeq
)
return
false
;
var
text
=
input
.
value
;
if
(
text
=
=
prevInput
&
&
!
cm
.
somethingSelected
(
)
)
return
false
;
if
(
ie
&
&
ie_version
>
=
9
&
&
this
.
hasSelection
=
=
=
text
|
|
mac
&
&
/
[
\
uf700
-
\
uf7ff
]
/
.
test
(
text
)
)
{
cm
.
display
.
input
.
reset
(
)
;
return
false
;
}
if
(
cm
.
doc
.
sel
=
=
cm
.
display
.
selForContextMenu
)
{
var
first
=
text
.
charCodeAt
(
0
)
;
if
(
first
=
=
0x200b
&
&
!
prevInput
)
prevInput
=
"
\
u200b
"
;
if
(
first
=
=
0x21da
)
{
this
.
reset
(
)
;
return
this
.
cm
.
execCommand
(
"
undo
"
)
;
}
}
var
same
=
0
l
=
Math
.
min
(
prevInput
.
length
text
.
length
)
;
while
(
same
<
l
&
&
prevInput
.
charCodeAt
(
same
)
=
=
text
.
charCodeAt
(
same
)
)
+
+
same
;
var
self
=
this
;
runInOp
(
cm
function
(
)
{
applyTextInput
(
cm
text
.
slice
(
same
)
prevInput
.
length
-
same
null
self
.
composing
?
"
*
compose
"
:
null
)
;
if
(
text
.
length
>
1000
|
|
text
.
indexOf
(
"
\
n
"
)
>
-
1
)
input
.
value
=
self
.
prevInput
=
"
"
;
else
self
.
prevInput
=
text
;
if
(
self
.
composing
)
{
self
.
composing
.
range
.
clear
(
)
;
self
.
composing
.
range
=
cm
.
markText
(
self
.
composing
.
start
cm
.
getCursor
(
"
to
"
)
{
className
:
"
CodeMirror
-
composing
"
}
)
;
}
}
)
;
return
true
;
}
ensurePolled
:
function
(
)
{
if
(
this
.
pollingFast
&
&
this
.
poll
(
)
)
this
.
pollingFast
=
false
;
}
onKeyPress
:
function
(
)
{
if
(
ie
&
&
ie_version
>
=
9
)
this
.
hasSelection
=
null
;
this
.
fastPoll
(
)
;
}
onContextMenu
:
function
(
e
)
{
var
input
=
this
cm
=
input
.
cm
display
=
cm
.
display
te
=
input
.
textarea
;
var
pos
=
posFromMouse
(
cm
e
)
scrollPos
=
display
.
scroller
.
scrollTop
;
if
(
!
pos
|
|
presto
)
return
;
var
reset
=
cm
.
options
.
resetSelectionOnContextMenu
;
if
(
reset
&
&
cm
.
doc
.
sel
.
contains
(
pos
)
=
=
-
1
)
operation
(
cm
setSelection
)
(
cm
.
doc
simpleSelection
(
pos
)
sel_dontScroll
)
;
var
oldCSS
=
te
.
style
.
cssText
oldWrapperCSS
=
input
.
wrapper
.
style
.
cssText
;
input
.
wrapper
.
style
.
cssText
=
"
position
:
absolute
"
var
wrapperBox
=
input
.
wrapper
.
getBoundingClientRect
(
)
te
.
style
.
cssText
=
"
position
:
absolute
;
width
:
30px
;
height
:
30px
;
top
:
"
+
(
e
.
clientY
-
wrapperBox
.
top
-
5
)
+
"
px
;
left
:
"
+
(
e
.
clientX
-
wrapperBox
.
left
-
5
)
+
"
px
;
z
-
index
:
1000
;
background
:
"
+
(
ie
?
"
rgba
(
255
255
255
.
05
)
"
:
"
transparent
"
)
+
"
;
outline
:
none
;
border
-
width
:
0
;
outline
:
none
;
overflow
:
hidden
;
opacity
:
.
05
;
filter
:
alpha
(
opacity
=
5
)
;
"
;
if
(
webkit
)
var
oldScrollY
=
window
.
scrollY
;
display
.
input
.
focus
(
)
;
if
(
webkit
)
window
.
scrollTo
(
null
oldScrollY
)
;
display
.
input
.
reset
(
)
;
if
(
!
cm
.
somethingSelected
(
)
)
te
.
value
=
input
.
prevInput
=
"
"
;
input
.
contextMenuPending
=
true
;
display
.
selForContextMenu
=
cm
.
doc
.
sel
;
clearTimeout
(
display
.
detectingSelectAll
)
;
function
prepareSelectAllHack
(
)
{
if
(
te
.
selectionStart
!
=
null
)
{
var
selected
=
cm
.
somethingSelected
(
)
;
var
extval
=
"
\
u200b
"
+
(
selected
?
te
.
value
:
"
"
)
;
te
.
value
=
"
\
u21da
"
;
te
.
value
=
extval
;
input
.
prevInput
=
selected
?
"
"
:
"
\
u200b
"
;
te
.
selectionStart
=
1
;
te
.
selectionEnd
=
extval
.
length
;
display
.
selForContextMenu
=
cm
.
doc
.
sel
;
}
}
function
rehide
(
)
{
input
.
contextMenuPending
=
false
;
input
.
wrapper
.
style
.
cssText
=
oldWrapperCSS
te
.
style
.
cssText
=
oldCSS
;
if
(
ie
&
&
ie_version
<
9
)
display
.
scrollbars
.
setScrollTop
(
display
.
scroller
.
scrollTop
=
scrollPos
)
;
if
(
te
.
selectionStart
!
=
null
)
{
if
(
!
ie
|
|
(
ie
&
&
ie_version
<
9
)
)
prepareSelectAllHack
(
)
;
var
i
=
0
poll
=
function
(
)
{
if
(
display
.
selForContextMenu
=
=
cm
.
doc
.
sel
&
&
te
.
selectionStart
=
=
0
&
&
te
.
selectionEnd
>
0
&
&
input
.
prevInput
=
=
"
\
u200b
"
)
operation
(
cm
commands
.
selectAll
)
(
cm
)
;
else
if
(
i
+
+
<
10
)
display
.
detectingSelectAll
=
setTimeout
(
poll
500
)
;
else
display
.
input
.
reset
(
)
;
}
;
display
.
detectingSelectAll
=
setTimeout
(
poll
200
)
;
}
}
if
(
ie
&
&
ie_version
>
=
9
)
prepareSelectAllHack
(
)
;
if
(
captureRightClick
)
{
e_stop
(
e
)
;
var
mouseup
=
function
(
)
{
off
(
window
"
mouseup
"
mouseup
)
;
setTimeout
(
rehide
20
)
;
}
;
on
(
window
"
mouseup
"
mouseup
)
;
}
else
{
setTimeout
(
rehide
50
)
;
}
}
readOnlyChanged
:
function
(
val
)
{
if
(
!
val
)
this
.
reset
(
)
;
}
setUneditable
:
nothing
needsContentAttribute
:
false
}
TextareaInput
.
prototype
)
;
function
ContentEditableInput
(
cm
)
{
this
.
cm
=
cm
;
this
.
lastAnchorNode
=
this
.
lastAnchorOffset
=
this
.
lastFocusNode
=
this
.
lastFocusOffset
=
null
;
this
.
polling
=
new
Delayed
(
)
;
this
.
gracePeriod
=
false
;
}
ContentEditableInput
.
prototype
=
copyObj
(
{
init
:
function
(
display
)
{
var
input
=
this
cm
=
input
.
cm
;
var
div
=
input
.
div
=
display
.
lineDiv
;
disableBrowserMagic
(
div
)
;
on
(
div
"
paste
"
function
(
e
)
{
if
(
!
signalDOMEvent
(
cm
e
)
)
handlePaste
(
e
cm
)
;
}
)
on
(
div
"
compositionstart
"
function
(
e
)
{
var
data
=
e
.
data
;
input
.
composing
=
{
sel
:
cm
.
doc
.
sel
data
:
data
startData
:
data
}
;
if
(
!
data
)
return
;
var
prim
=
cm
.
doc
.
sel
.
primary
(
)
;
var
line
=
cm
.
getLine
(
prim
.
head
.
line
)
;
var
found
=
line
.
indexOf
(
data
Math
.
max
(
0
prim
.
head
.
ch
-
data
.
length
)
)
;
if
(
found
>
-
1
&
&
found
<
=
prim
.
head
.
ch
)
input
.
composing
.
sel
=
simpleSelection
(
Pos
(
prim
.
head
.
line
found
)
Pos
(
prim
.
head
.
line
found
+
data
.
length
)
)
;
}
)
;
on
(
div
"
compositionupdate
"
function
(
e
)
{
input
.
composing
.
data
=
e
.
data
;
}
)
;
on
(
div
"
compositionend
"
function
(
e
)
{
var
ours
=
input
.
composing
;
if
(
!
ours
)
return
;
if
(
e
.
data
!
=
ours
.
startData
&
&
!
/
\
u200b
/
.
test
(
e
.
data
)
)
ours
.
data
=
e
.
data
;
setTimeout
(
function
(
)
{
if
(
!
ours
.
handled
)
input
.
applyComposition
(
ours
)
;
if
(
input
.
composing
=
=
ours
)
input
.
composing
=
null
;
}
50
)
;
}
)
;
on
(
div
"
touchstart
"
function
(
)
{
input
.
forceCompositionEnd
(
)
;
}
)
;
on
(
div
"
input
"
function
(
)
{
if
(
input
.
composing
)
return
;
if
(
cm
.
isReadOnly
(
)
|
|
!
input
.
pollContent
(
)
)
runInOp
(
input
.
cm
function
(
)
{
regChange
(
cm
)
;
}
)
;
}
)
;
function
onCopyCut
(
e
)
{
if
(
signalDOMEvent
(
cm
e
)
)
return
if
(
cm
.
somethingSelected
(
)
)
{
lastCopied
=
{
lineWise
:
false
text
:
cm
.
getSelections
(
)
}
;
if
(
e
.
type
=
=
"
cut
"
)
cm
.
replaceSelection
(
"
"
null
"
cut
"
)
;
}
else
if
(
!
cm
.
options
.
lineWiseCopyCut
)
{
return
;
}
else
{
var
ranges
=
copyableRanges
(
cm
)
;
lastCopied
=
{
lineWise
:
true
text
:
ranges
.
text
}
;
if
(
e
.
type
=
=
"
cut
"
)
{
cm
.
operation
(
function
(
)
{
cm
.
setSelections
(
ranges
.
ranges
0
sel_dontScroll
)
;
cm
.
replaceSelection
(
"
"
null
"
cut
"
)
;
}
)
;
}
}
if
(
e
.
clipboardData
&
&
!
ios
)
{
e
.
preventDefault
(
)
;
e
.
clipboardData
.
clearData
(
)
;
e
.
clipboardData
.
setData
(
"
text
/
plain
"
lastCopied
.
text
.
join
(
"
\
n
"
)
)
;
}
else
{
var
kludge
=
hiddenTextarea
(
)
te
=
kludge
.
firstChild
;
cm
.
display
.
lineSpace
.
insertBefore
(
kludge
cm
.
display
.
lineSpace
.
firstChild
)
;
te
.
value
=
lastCopied
.
text
.
join
(
"
\
n
"
)
;
var
hadFocus
=
document
.
activeElement
;
selectInput
(
te
)
;
setTimeout
(
function
(
)
{
cm
.
display
.
lineSpace
.
removeChild
(
kludge
)
;
hadFocus
.
focus
(
)
;
}
50
)
;
}
}
on
(
div
"
copy
"
onCopyCut
)
;
on
(
div
"
cut
"
onCopyCut
)
;
}
prepareSelection
:
function
(
)
{
var
result
=
prepareSelection
(
this
.
cm
false
)
;
result
.
focus
=
this
.
cm
.
state
.
focused
;
return
result
;
}
showSelection
:
function
(
info
takeFocus
)
{
if
(
!
info
|
|
!
this
.
cm
.
display
.
view
.
length
)
return
;
if
(
info
.
focus
|
|
takeFocus
)
this
.
showPrimarySelection
(
)
;
this
.
showMultipleSelections
(
info
)
;
}
showPrimarySelection
:
function
(
)
{
var
sel
=
window
.
getSelection
(
)
prim
=
this
.
cm
.
doc
.
sel
.
primary
(
)
;
var
curAnchor
=
domToPos
(
this
.
cm
sel
.
anchorNode
sel
.
anchorOffset
)
;
var
curFocus
=
domToPos
(
this
.
cm
sel
.
focusNode
sel
.
focusOffset
)
;
if
(
curAnchor
&
&
!
curAnchor
.
bad
&
&
curFocus
&
&
!
curFocus
.
bad
&
&
cmp
(
minPos
(
curAnchor
curFocus
)
prim
.
from
(
)
)
=
=
0
&
&
cmp
(
maxPos
(
curAnchor
curFocus
)
prim
.
to
(
)
)
=
=
0
)
return
;
var
start
=
posToDOM
(
this
.
cm
prim
.
from
(
)
)
;
var
end
=
posToDOM
(
this
.
cm
prim
.
to
(
)
)
;
if
(
!
start
&
&
!
end
)
return
;
var
view
=
this
.
cm
.
display
.
view
;
var
old
=
sel
.
rangeCount
&
&
sel
.
getRangeAt
(
0
)
;
if
(
!
start
)
{
start
=
{
node
:
view
[
0
]
.
measure
.
map
[
2
]
offset
:
0
}
;
}
else
if
(
!
end
)
{
var
measure
=
view
[
view
.
length
-
1
]
.
measure
;
var
map
=
measure
.
maps
?
measure
.
maps
[
measure
.
maps
.
length
-
1
]
:
measure
.
map
;
end
=
{
node
:
map
[
map
.
length
-
1
]
offset
:
map
[
map
.
length
-
2
]
-
map
[
map
.
length
-
3
]
}
;
}
try
{
var
rng
=
range
(
start
.
node
start
.
offset
end
.
offset
end
.
node
)
;
}
catch
(
e
)
{
}
if
(
rng
)
{
if
(
!
gecko
&
&
this
.
cm
.
state
.
focused
)
{
sel
.
collapse
(
start
.
node
start
.
offset
)
;
if
(
!
rng
.
collapsed
)
sel
.
addRange
(
rng
)
;
}
else
{
sel
.
removeAllRanges
(
)
;
sel
.
addRange
(
rng
)
;
}
if
(
old
&
&
sel
.
anchorNode
=
=
null
)
sel
.
addRange
(
old
)
;
else
if
(
gecko
)
this
.
startGracePeriod
(
)
;
}
this
.
rememberSelection
(
)
;
}
startGracePeriod
:
function
(
)
{
var
input
=
this
;
clearTimeout
(
this
.
gracePeriod
)
;
this
.
gracePeriod
=
setTimeout
(
function
(
)
{
input
.
gracePeriod
=
false
;
if
(
input
.
selectionChanged
(
)
)
input
.
cm
.
operation
(
function
(
)
{
input
.
cm
.
curOp
.
selectionChanged
=
true
;
}
)
;
}
20
)
;
}
showMultipleSelections
:
function
(
info
)
{
removeChildrenAndAdd
(
this
.
cm
.
display
.
cursorDiv
info
.
cursors
)
;
removeChildrenAndAdd
(
this
.
cm
.
display
.
selectionDiv
info
.
selection
)
;
}
rememberSelection
:
function
(
)
{
var
sel
=
window
.
getSelection
(
)
;
this
.
lastAnchorNode
=
sel
.
anchorNode
;
this
.
lastAnchorOffset
=
sel
.
anchorOffset
;
this
.
lastFocusNode
=
sel
.
focusNode
;
this
.
lastFocusOffset
=
sel
.
focusOffset
;
}
selectionInEditor
:
function
(
)
{
var
sel
=
window
.
getSelection
(
)
;
if
(
!
sel
.
rangeCount
)
return
false
;
var
node
=
sel
.
getRangeAt
(
0
)
.
commonAncestorContainer
;
return
contains
(
this
.
div
node
)
;
}
focus
:
function
(
)
{
if
(
this
.
cm
.
options
.
readOnly
!
=
"
nocursor
"
)
this
.
div
.
focus
(
)
;
}
blur
:
function
(
)
{
this
.
div
.
blur
(
)
;
}
getField
:
function
(
)
{
return
this
.
div
;
}
supportsTouch
:
function
(
)
{
return
true
;
}
receivedFocus
:
function
(
)
{
var
input
=
this
;
if
(
this
.
selectionInEditor
(
)
)
this
.
pollSelection
(
)
;
else
runInOp
(
this
.
cm
function
(
)
{
input
.
cm
.
curOp
.
selectionChanged
=
true
;
}
)
;
function
poll
(
)
{
if
(
input
.
cm
.
state
.
focused
)
{
input
.
pollSelection
(
)
;
input
.
polling
.
set
(
input
.
cm
.
options
.
pollInterval
poll
)
;
}
}
this
.
polling
.
set
(
this
.
cm
.
options
.
pollInterval
poll
)
;
}
selectionChanged
:
function
(
)
{
var
sel
=
window
.
getSelection
(
)
;
return
sel
.
anchorNode
!
=
this
.
lastAnchorNode
|
|
sel
.
anchorOffset
!
=
this
.
lastAnchorOffset
|
|
sel
.
focusNode
!
=
this
.
lastFocusNode
|
|
sel
.
focusOffset
!
=
this
.
lastFocusOffset
;
}
pollSelection
:
function
(
)
{
if
(
!
this
.
composing
&
&
!
this
.
gracePeriod
&
&
this
.
selectionChanged
(
)
)
{
var
sel
=
window
.
getSelection
(
)
cm
=
this
.
cm
;
this
.
rememberSelection
(
)
;
var
anchor
=
domToPos
(
cm
sel
.
anchorNode
sel
.
anchorOffset
)
;
var
head
=
domToPos
(
cm
sel
.
focusNode
sel
.
focusOffset
)
;
if
(
anchor
&
&
head
)
runInOp
(
cm
function
(
)
{
setSelection
(
cm
.
doc
simpleSelection
(
anchor
head
)
sel_dontScroll
)
;
if
(
anchor
.
bad
|
|
head
.
bad
)
cm
.
curOp
.
selectionChanged
=
true
;
}
)
;
}
}
pollContent
:
function
(
)
{
var
cm
=
this
.
cm
display
=
cm
.
display
sel
=
cm
.
doc
.
sel
.
primary
(
)
;
var
from
=
sel
.
from
(
)
to
=
sel
.
to
(
)
;
if
(
from
.
line
<
display
.
viewFrom
|
|
to
.
line
>
display
.
viewTo
-
1
)
return
false
;
var
fromIndex
;
if
(
from
.
line
=
=
display
.
viewFrom
|
|
(
fromIndex
=
findViewIndex
(
cm
from
.
line
)
)
=
=
0
)
{
var
fromLine
=
lineNo
(
display
.
view
[
0
]
.
line
)
;
var
fromNode
=
display
.
view
[
0
]
.
node
;
}
else
{
var
fromLine
=
lineNo
(
display
.
view
[
fromIndex
]
.
line
)
;
var
fromNode
=
display
.
view
[
fromIndex
-
1
]
.
node
.
nextSibling
;
}
var
toIndex
=
findViewIndex
(
cm
to
.
line
)
;
if
(
toIndex
=
=
display
.
view
.
length
-
1
)
{
var
toLine
=
display
.
viewTo
-
1
;
var
toNode
=
display
.
lineDiv
.
lastChild
;
}
else
{
var
toLine
=
lineNo
(
display
.
view
[
toIndex
+
1
]
.
line
)
-
1
;
var
toNode
=
display
.
view
[
toIndex
+
1
]
.
node
.
previousSibling
;
}
var
newText
=
cm
.
doc
.
splitLines
(
domTextBetween
(
cm
fromNode
toNode
fromLine
toLine
)
)
;
var
oldText
=
getBetween
(
cm
.
doc
Pos
(
fromLine
0
)
Pos
(
toLine
getLine
(
cm
.
doc
toLine
)
.
text
.
length
)
)
;
while
(
newText
.
length
>
1
&
&
oldText
.
length
>
1
)
{
if
(
lst
(
newText
)
=
=
lst
(
oldText
)
)
{
newText
.
pop
(
)
;
oldText
.
pop
(
)
;
toLine
-
-
;
}
else
if
(
newText
[
0
]
=
=
oldText
[
0
]
)
{
newText
.
shift
(
)
;
oldText
.
shift
(
)
;
fromLine
+
+
;
}
else
break
;
}
var
cutFront
=
0
cutEnd
=
0
;
var
newTop
=
newText
[
0
]
oldTop
=
oldText
[
0
]
maxCutFront
=
Math
.
min
(
newTop
.
length
oldTop
.
length
)
;
while
(
cutFront
<
maxCutFront
&
&
newTop
.
charCodeAt
(
cutFront
)
=
=
oldTop
.
charCodeAt
(
cutFront
)
)
+
+
cutFront
;
var
newBot
=
lst
(
newText
)
oldBot
=
lst
(
oldText
)
;
var
maxCutEnd
=
Math
.
min
(
newBot
.
length
-
(
newText
.
length
=
=
1
?
cutFront
:
0
)
oldBot
.
length
-
(
oldText
.
length
=
=
1
?
cutFront
:
0
)
)
;
while
(
cutEnd
<
maxCutEnd
&
&
newBot
.
charCodeAt
(
newBot
.
length
-
cutEnd
-
1
)
=
=
oldBot
.
charCodeAt
(
oldBot
.
length
-
cutEnd
-
1
)
)
+
+
cutEnd
;
newText
[
newText
.
length
-
1
]
=
newBot
.
slice
(
0
newBot
.
length
-
cutEnd
)
;
newText
[
0
]
=
newText
[
0
]
.
slice
(
cutFront
)
;
var
chFrom
=
Pos
(
fromLine
cutFront
)
;
var
chTo
=
Pos
(
toLine
oldText
.
length
?
lst
(
oldText
)
.
length
-
cutEnd
:
0
)
;
if
(
newText
.
length
>
1
|
|
newText
[
0
]
|
|
cmp
(
chFrom
chTo
)
)
{
replaceRange
(
cm
.
doc
newText
chFrom
chTo
"
+
input
"
)
;
return
true
;
}
}
ensurePolled
:
function
(
)
{
this
.
forceCompositionEnd
(
)
;
}
reset
:
function
(
)
{
this
.
forceCompositionEnd
(
)
;
}
forceCompositionEnd
:
function
(
)
{
if
(
!
this
.
composing
|
|
this
.
composing
.
handled
)
return
;
this
.
applyComposition
(
this
.
composing
)
;
this
.
composing
.
handled
=
true
;
this
.
div
.
blur
(
)
;
this
.
div
.
focus
(
)
;
}
applyComposition
:
function
(
composing
)
{
if
(
this
.
cm
.
isReadOnly
(
)
)
operation
(
this
.
cm
regChange
)
(
this
.
cm
)
else
if
(
composing
.
data
&
&
composing
.
data
!
=
composing
.
startData
)
operation
(
this
.
cm
applyTextInput
)
(
this
.
cm
composing
.
data
0
composing
.
sel
)
;
}
setUneditable
:
function
(
node
)
{
node
.
contentEditable
=
"
false
"
}
onKeyPress
:
function
(
e
)
{
e
.
preventDefault
(
)
;
if
(
!
this
.
cm
.
isReadOnly
(
)
)
operation
(
this
.
cm
applyTextInput
)
(
this
.
cm
String
.
fromCharCode
(
e
.
charCode
=
=
null
?
e
.
keyCode
:
e
.
charCode
)
0
)
;
}
readOnlyChanged
:
function
(
val
)
{
this
.
div
.
contentEditable
=
String
(
val
!
=
"
nocursor
"
)
}
onContextMenu
:
nothing
resetPosition
:
nothing
needsContentAttribute
:
true
}
ContentEditableInput
.
prototype
)
;
function
posToDOM
(
cm
pos
)
{
var
view
=
findViewForLine
(
cm
pos
.
line
)
;
if
(
!
view
|
|
view
.
hidden
)
return
null
;
var
line
=
getLine
(
cm
.
doc
pos
.
line
)
;
var
info
=
mapFromLineView
(
view
line
pos
.
line
)
;
var
order
=
getOrder
(
line
)
side
=
"
left
"
;
if
(
order
)
{
var
partPos
=
getBidiPartAt
(
order
pos
.
ch
)
;
side
=
partPos
%
2
?
"
right
"
:
"
left
"
;
}
var
result
=
nodeAndOffsetInLineMap
(
info
.
map
pos
.
ch
side
)
;
result
.
offset
=
result
.
collapse
=
=
"
right
"
?
result
.
end
:
result
.
start
;
return
result
;
}
function
badPos
(
pos
bad
)
{
if
(
bad
)
pos
.
bad
=
true
;
return
pos
;
}
function
domToPos
(
cm
node
offset
)
{
var
lineNode
;
if
(
node
=
=
cm
.
display
.
lineDiv
)
{
lineNode
=
cm
.
display
.
lineDiv
.
childNodes
[
offset
]
;
if
(
!
lineNode
)
return
badPos
(
cm
.
clipPos
(
Pos
(
cm
.
display
.
viewTo
-
1
)
)
true
)
;
node
=
null
;
offset
=
0
;
}
else
{
for
(
lineNode
=
node
;
;
lineNode
=
lineNode
.
parentNode
)
{
if
(
!
lineNode
|
|
lineNode
=
=
cm
.
display
.
lineDiv
)
return
null
;
if
(
lineNode
.
parentNode
&
&
lineNode
.
parentNode
=
=
cm
.
display
.
lineDiv
)
break
;
}
}
for
(
var
i
=
0
;
i
<
cm
.
display
.
view
.
length
;
i
+
+
)
{
var
lineView
=
cm
.
display
.
view
[
i
]
;
if
(
lineView
.
node
=
=
lineNode
)
return
locateNodeInLineView
(
lineView
node
offset
)
;
}
}
function
locateNodeInLineView
(
lineView
node
offset
)
{
var
wrapper
=
lineView
.
text
.
firstChild
bad
=
false
;
if
(
!
node
|
|
!
contains
(
wrapper
node
)
)
return
badPos
(
Pos
(
lineNo
(
lineView
.
line
)
0
)
true
)
;
if
(
node
=
=
wrapper
)
{
bad
=
true
;
node
=
wrapper
.
childNodes
[
offset
]
;
offset
=
0
;
if
(
!
node
)
{
var
line
=
lineView
.
rest
?
lst
(
lineView
.
rest
)
:
lineView
.
line
;
return
badPos
(
Pos
(
lineNo
(
line
)
line
.
text
.
length
)
bad
)
;
}
}
var
textNode
=
node
.
nodeType
=
=
3
?
node
:
null
topNode
=
node
;
if
(
!
textNode
&
&
node
.
childNodes
.
length
=
=
1
&
&
node
.
firstChild
.
nodeType
=
=
3
)
{
textNode
=
node
.
firstChild
;
if
(
offset
)
offset
=
textNode
.
nodeValue
.
length
;
}
while
(
topNode
.
parentNode
!
=
wrapper
)
topNode
=
topNode
.
parentNode
;
var
measure
=
lineView
.
measure
maps
=
measure
.
maps
;
function
find
(
textNode
topNode
offset
)
{
for
(
var
i
=
-
1
;
i
<
(
maps
?
maps
.
length
:
0
)
;
i
+
+
)
{
var
map
=
i
<
0
?
measure
.
map
:
maps
[
i
]
;
for
(
var
j
=
0
;
j
<
map
.
length
;
j
+
=
3
)
{
var
curNode
=
map
[
j
+
2
]
;
if
(
curNode
=
=
textNode
|
|
curNode
=
=
topNode
)
{
var
line
=
lineNo
(
i
<
0
?
lineView
.
line
:
lineView
.
rest
[
i
]
)
;
var
ch
=
map
[
j
]
+
offset
;
if
(
offset
<
0
|
|
curNode
!
=
textNode
)
ch
=
map
[
j
+
(
offset
?
1
:
0
)
]
;
return
Pos
(
line
ch
)
;
}
}
}
}
var
found
=
find
(
textNode
topNode
offset
)
;
if
(
found
)
return
badPos
(
found
bad
)
;
for
(
var
after
=
topNode
.
nextSibling
dist
=
textNode
?
textNode
.
nodeValue
.
length
-
offset
:
0
;
after
;
after
=
after
.
nextSibling
)
{
found
=
find
(
after
after
.
firstChild
0
)
;
if
(
found
)
return
badPos
(
Pos
(
found
.
line
found
.
ch
-
dist
)
bad
)
;
else
dist
+
=
after
.
textContent
.
length
;
}
for
(
var
before
=
topNode
.
previousSibling
dist
=
offset
;
before
;
before
=
before
.
previousSibling
)
{
found
=
find
(
before
before
.
firstChild
-
1
)
;
if
(
found
)
return
badPos
(
Pos
(
found
.
line
found
.
ch
+
dist
)
bad
)
;
else
dist
+
=
after
.
textContent
.
length
;
}
}
function
domTextBetween
(
cm
from
to
fromLine
toLine
)
{
var
text
=
"
"
closing
=
false
lineSep
=
cm
.
doc
.
lineSeparator
(
)
;
function
recognizeMarker
(
id
)
{
return
function
(
marker
)
{
return
marker
.
id
=
=
id
;
}
;
}
function
walk
(
node
)
{
if
(
node
.
nodeType
=
=
1
)
{
var
cmText
=
node
.
getAttribute
(
"
cm
-
text
"
)
;
if
(
cmText
!
=
null
)
{
if
(
cmText
=
=
"
"
)
cmText
=
node
.
textContent
.
replace
(
/
\
u200b
/
g
"
"
)
;
text
+
=
cmText
;
return
;
}
var
markerID
=
node
.
getAttribute
(
"
cm
-
marker
"
)
range
;
if
(
markerID
)
{
var
found
=
cm
.
findMarks
(
Pos
(
fromLine
0
)
Pos
(
toLine
+
1
0
)
recognizeMarker
(
+
markerID
)
)
;
if
(
found
.
length
&
&
(
range
=
found
[
0
]
.
find
(
)
)
)
text
+
=
getBetween
(
cm
.
doc
range
.
from
range
.
to
)
.
join
(
lineSep
)
;
return
;
}
if
(
node
.
getAttribute
(
"
contenteditable
"
)
=
=
"
false
"
)
return
;
for
(
var
i
=
0
;
i
<
node
.
childNodes
.
length
;
i
+
+
)
walk
(
node
.
childNodes
[
i
]
)
;
if
(
/
^
(
pre
|
div
|
p
)
/
i
.
test
(
node
.
nodeName
)
)
closing
=
true
;
}
else
if
(
node
.
nodeType
=
=
3
)
{
var
val
=
node
.
nodeValue
;
if
(
!
val
)
return
;
if
(
closing
)
{
text
+
=
lineSep
;
closing
=
false
;
}
text
+
=
val
;
}
}
for
(
;
;
)
{
walk
(
from
)
;
if
(
from
=
=
to
)
break
;
from
=
from
.
nextSibling
;
}
return
text
;
}
CodeMirror
.
inputStyles
=
{
"
textarea
"
:
TextareaInput
"
contenteditable
"
:
ContentEditableInput
}
;
function
Selection
(
ranges
primIndex
)
{
this
.
ranges
=
ranges
;
this
.
primIndex
=
primIndex
;
}
Selection
.
prototype
=
{
primary
:
function
(
)
{
return
this
.
ranges
[
this
.
primIndex
]
;
}
equals
:
function
(
other
)
{
if
(
other
=
=
this
)
return
true
;
if
(
other
.
primIndex
!
=
this
.
primIndex
|
|
other
.
ranges
.
length
!
=
this
.
ranges
.
length
)
return
false
;
for
(
var
i
=
0
;
i
<
this
.
ranges
.
length
;
i
+
+
)
{
var
here
=
this
.
ranges
[
i
]
there
=
other
.
ranges
[
i
]
;
if
(
cmp
(
here
.
anchor
there
.
anchor
)
!
=
0
|
|
cmp
(
here
.
head
there
.
head
)
!
=
0
)
return
false
;
}
return
true
;
}
deepCopy
:
function
(
)
{
for
(
var
out
=
[
]
i
=
0
;
i
<
this
.
ranges
.
length
;
i
+
+
)
out
[
i
]
=
new
Range
(
copyPos
(
this
.
ranges
[
i
]
.
anchor
)
copyPos
(
this
.
ranges
[
i
]
.
head
)
)
;
return
new
Selection
(
out
this
.
primIndex
)
;
}
somethingSelected
:
function
(
)
{
for
(
var
i
=
0
;
i
<
this
.
ranges
.
length
;
i
+
+
)
if
(
!
this
.
ranges
[
i
]
.
empty
(
)
)
return
true
;
return
false
;
}
contains
:
function
(
pos
end
)
{
if
(
!
end
)
end
=
pos
;
for
(
var
i
=
0
;
i
<
this
.
ranges
.
length
;
i
+
+
)
{
var
range
=
this
.
ranges
[
i
]
;
if
(
cmp
(
end
range
.
from
(
)
)
>
=
0
&
&
cmp
(
pos
range
.
to
(
)
)
<
=
0
)
return
i
;
}
return
-
1
;
}
}
;
function
Range
(
anchor
head
)
{
this
.
anchor
=
anchor
;
this
.
head
=
head
;
}
Range
.
prototype
=
{
from
:
function
(
)
{
return
minPos
(
this
.
anchor
this
.
head
)
;
}
to
:
function
(
)
{
return
maxPos
(
this
.
anchor
this
.
head
)
;
}
empty
:
function
(
)
{
return
this
.
head
.
line
=
=
this
.
anchor
.
line
&
&
this
.
head
.
ch
=
=
this
.
anchor
.
ch
;
}
}
;
function
normalizeSelection
(
ranges
primIndex
)
{
var
prim
=
ranges
[
primIndex
]
;
ranges
.
sort
(
function
(
a
b
)
{
return
cmp
(
a
.
from
(
)
b
.
from
(
)
)
;
}
)
;
primIndex
=
indexOf
(
ranges
prim
)
;
for
(
var
i
=
1
;
i
<
ranges
.
length
;
i
+
+
)
{
var
cur
=
ranges
[
i
]
prev
=
ranges
[
i
-
1
]
;
if
(
cmp
(
prev
.
to
(
)
cur
.
from
(
)
)
>
=
0
)
{
var
from
=
minPos
(
prev
.
from
(
)
cur
.
from
(
)
)
to
=
maxPos
(
prev
.
to
(
)
cur
.
to
(
)
)
;
var
inv
=
prev
.
empty
(
)
?
cur
.
from
(
)
=
=
cur
.
head
:
prev
.
from
(
)
=
=
prev
.
head
;
if
(
i
<
=
primIndex
)
-
-
primIndex
;
ranges
.
splice
(
-
-
i
2
new
Range
(
inv
?
to
:
from
inv
?
from
:
to
)
)
;
}
}
return
new
Selection
(
ranges
primIndex
)
;
}
function
simpleSelection
(
anchor
head
)
{
return
new
Selection
(
[
new
Range
(
anchor
head
|
|
anchor
)
]
0
)
;
}
function
clipLine
(
doc
n
)
{
return
Math
.
max
(
doc
.
first
Math
.
min
(
n
doc
.
first
+
doc
.
size
-
1
)
)
;
}
function
clipPos
(
doc
pos
)
{
if
(
pos
.
line
<
doc
.
first
)
return
Pos
(
doc
.
first
0
)
;
var
last
=
doc
.
first
+
doc
.
size
-
1
;
if
(
pos
.
line
>
last
)
return
Pos
(
last
getLine
(
doc
last
)
.
text
.
length
)
;
return
clipToLen
(
pos
getLine
(
doc
pos
.
line
)
.
text
.
length
)
;
}
function
clipToLen
(
pos
linelen
)
{
var
ch
=
pos
.
ch
;
if
(
ch
=
=
null
|
|
ch
>
linelen
)
return
Pos
(
pos
.
line
linelen
)
;
else
if
(
ch
<
0
)
return
Pos
(
pos
.
line
0
)
;
else
return
pos
;
}
function
isLine
(
doc
l
)
{
return
l
>
=
doc
.
first
&
&
l
<
doc
.
first
+
doc
.
size
;
}
function
clipPosArray
(
doc
array
)
{
for
(
var
out
=
[
]
i
=
0
;
i
<
array
.
length
;
i
+
+
)
out
[
i
]
=
clipPos
(
doc
array
[
i
]
)
;
return
out
;
}
function
extendRange
(
doc
range
head
other
)
{
if
(
doc
.
cm
&
&
doc
.
cm
.
display
.
shift
|
|
doc
.
extend
)
{
var
anchor
=
range
.
anchor
;
if
(
other
)
{
var
posBefore
=
cmp
(
head
anchor
)
<
0
;
if
(
posBefore
!
=
(
cmp
(
other
anchor
)
<
0
)
)
{
anchor
=
head
;
head
=
other
;
}
else
if
(
posBefore
!
=
(
cmp
(
head
other
)
<
0
)
)
{
head
=
other
;
}
}
return
new
Range
(
anchor
head
)
;
}
else
{
return
new
Range
(
other
|
|
head
head
)
;
}
}
function
extendSelection
(
doc
head
other
options
)
{
setSelection
(
doc
new
Selection
(
[
extendRange
(
doc
doc
.
sel
.
primary
(
)
head
other
)
]
0
)
options
)
;
}
function
extendSelections
(
doc
heads
options
)
{
for
(
var
out
=
[
]
i
=
0
;
i
<
doc
.
sel
.
ranges
.
length
;
i
+
+
)
out
[
i
]
=
extendRange
(
doc
doc
.
sel
.
ranges
[
i
]
heads
[
i
]
null
)
;
var
newSel
=
normalizeSelection
(
out
doc
.
sel
.
primIndex
)
;
setSelection
(
doc
newSel
options
)
;
}
function
replaceOneSelection
(
doc
i
range
options
)
{
var
ranges
=
doc
.
sel
.
ranges
.
slice
(
0
)
;
ranges
[
i
]
=
range
;
setSelection
(
doc
normalizeSelection
(
ranges
doc
.
sel
.
primIndex
)
options
)
;
}
function
setSimpleSelection
(
doc
anchor
head
options
)
{
setSelection
(
doc
simpleSelection
(
anchor
head
)
options
)
;
}
function
filterSelectionChange
(
doc
sel
options
)
{
var
obj
=
{
ranges
:
sel
.
ranges
update
:
function
(
ranges
)
{
this
.
ranges
=
[
]
;
for
(
var
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
this
.
ranges
[
i
]
=
new
Range
(
clipPos
(
doc
ranges
[
i
]
.
anchor
)
clipPos
(
doc
ranges
[
i
]
.
head
)
)
;
}
origin
:
options
&
&
options
.
origin
}
;
signal
(
doc
"
beforeSelectionChange
"
doc
obj
)
;
if
(
doc
.
cm
)
signal
(
doc
.
cm
"
beforeSelectionChange
"
doc
.
cm
obj
)
;
if
(
obj
.
ranges
!
=
sel
.
ranges
)
return
normalizeSelection
(
obj
.
ranges
obj
.
ranges
.
length
-
1
)
;
else
return
sel
;
}
function
setSelectionReplaceHistory
(
doc
sel
options
)
{
var
done
=
doc
.
history
.
done
last
=
lst
(
done
)
;
if
(
last
&
&
last
.
ranges
)
{
done
[
done
.
length
-
1
]
=
sel
;
setSelectionNoUndo
(
doc
sel
options
)
;
}
else
{
setSelection
(
doc
sel
options
)
;
}
}
function
setSelection
(
doc
sel
options
)
{
setSelectionNoUndo
(
doc
sel
options
)
;
addSelectionToHistory
(
doc
doc
.
sel
doc
.
cm
?
doc
.
cm
.
curOp
.
id
:
NaN
options
)
;
}
function
setSelectionNoUndo
(
doc
sel
options
)
{
if
(
hasHandler
(
doc
"
beforeSelectionChange
"
)
|
|
doc
.
cm
&
&
hasHandler
(
doc
.
cm
"
beforeSelectionChange
"
)
)
sel
=
filterSelectionChange
(
doc
sel
options
)
;
var
bias
=
options
&
&
options
.
bias
|
|
(
cmp
(
sel
.
primary
(
)
.
head
doc
.
sel
.
primary
(
)
.
head
)
<
0
?
-
1
:
1
)
;
setSelectionInner
(
doc
skipAtomicInSelection
(
doc
sel
bias
true
)
)
;
if
(
!
(
options
&
&
options
.
scroll
=
=
=
false
)
&
&
doc
.
cm
)
ensureCursorVisible
(
doc
.
cm
)
;
}
function
setSelectionInner
(
doc
sel
)
{
if
(
sel
.
equals
(
doc
.
sel
)
)
return
;
doc
.
sel
=
sel
;
if
(
doc
.
cm
)
{
doc
.
cm
.
curOp
.
updateInput
=
doc
.
cm
.
curOp
.
selectionChanged
=
true
;
signalCursorActivity
(
doc
.
cm
)
;
}
signalLater
(
doc
"
cursorActivity
"
doc
)
;
}
function
reCheckSelection
(
doc
)
{
setSelectionInner
(
doc
skipAtomicInSelection
(
doc
doc
.
sel
null
false
)
sel_dontScroll
)
;
}
function
skipAtomicInSelection
(
doc
sel
bias
mayClear
)
{
var
out
;
for
(
var
i
=
0
;
i
<
sel
.
ranges
.
length
;
i
+
+
)
{
var
range
=
sel
.
ranges
[
i
]
;
var
old
=
sel
.
ranges
.
length
=
=
doc
.
sel
.
ranges
.
length
&
&
doc
.
sel
.
ranges
[
i
]
;
var
newAnchor
=
skipAtomic
(
doc
range
.
anchor
old
&
&
old
.
anchor
bias
mayClear
)
;
var
newHead
=
skipAtomic
(
doc
range
.
head
old
&
&
old
.
head
bias
mayClear
)
;
if
(
out
|
|
newAnchor
!
=
range
.
anchor
|
|
newHead
!
=
range
.
head
)
{
if
(
!
out
)
out
=
sel
.
ranges
.
slice
(
0
i
)
;
out
[
i
]
=
new
Range
(
newAnchor
newHead
)
;
}
}
return
out
?
normalizeSelection
(
out
sel
.
primIndex
)
:
sel
;
}
function
skipAtomicInner
(
doc
pos
oldPos
dir
mayClear
)
{
var
line
=
getLine
(
doc
pos
.
line
)
;
if
(
line
.
markedSpans
)
for
(
var
i
=
0
;
i
<
line
.
markedSpans
.
length
;
+
+
i
)
{
var
sp
=
line
.
markedSpans
[
i
]
m
=
sp
.
marker
;
if
(
(
sp
.
from
=
=
null
|
|
(
m
.
inclusiveLeft
?
sp
.
from
<
=
pos
.
ch
:
sp
.
from
<
pos
.
ch
)
)
&
&
(
sp
.
to
=
=
null
|
|
(
m
.
inclusiveRight
?
sp
.
to
>
=
pos
.
ch
:
sp
.
to
>
pos
.
ch
)
)
)
{
if
(
mayClear
)
{
signal
(
m
"
beforeCursorEnter
"
)
;
if
(
m
.
explicitlyCleared
)
{
if
(
!
line
.
markedSpans
)
break
;
else
{
-
-
i
;
continue
;
}
}
}
if
(
!
m
.
atomic
)
continue
;
if
(
oldPos
)
{
var
near
=
m
.
find
(
dir
<
0
?
1
:
-
1
)
diff
;
if
(
dir
<
0
?
m
.
inclusiveRight
:
m
.
inclusiveLeft
)
near
=
movePos
(
doc
near
-
dir
near
&
&
near
.
line
=
=
pos
.
line
?
line
:
null
)
;
if
(
near
&
&
near
.
line
=
=
pos
.
line
&
&
(
diff
=
cmp
(
near
oldPos
)
)
&
&
(
dir
<
0
?
diff
<
0
:
diff
>
0
)
)
return
skipAtomicInner
(
doc
near
pos
dir
mayClear
)
;
}
var
far
=
m
.
find
(
dir
<
0
?
-
1
:
1
)
;
if
(
dir
<
0
?
m
.
inclusiveLeft
:
m
.
inclusiveRight
)
far
=
movePos
(
doc
far
dir
far
.
line
=
=
pos
.
line
?
line
:
null
)
;
return
far
?
skipAtomicInner
(
doc
far
pos
dir
mayClear
)
:
null
;
}
}
return
pos
;
}
function
skipAtomic
(
doc
pos
oldPos
bias
mayClear
)
{
var
dir
=
bias
|
|
1
;
var
found
=
skipAtomicInner
(
doc
pos
oldPos
dir
mayClear
)
|
|
(
!
mayClear
&
&
skipAtomicInner
(
doc
pos
oldPos
dir
true
)
)
|
|
skipAtomicInner
(
doc
pos
oldPos
-
dir
mayClear
)
|
|
(
!
mayClear
&
&
skipAtomicInner
(
doc
pos
oldPos
-
dir
true
)
)
;
if
(
!
found
)
{
doc
.
cantEdit
=
true
;
return
Pos
(
doc
.
first
0
)
;
}
return
found
;
}
function
movePos
(
doc
pos
dir
line
)
{
if
(
dir
<
0
&
&
pos
.
ch
=
=
0
)
{
if
(
pos
.
line
>
doc
.
first
)
return
clipPos
(
doc
Pos
(
pos
.
line
-
1
)
)
;
else
return
null
;
}
else
if
(
dir
>
0
&
&
pos
.
ch
=
=
(
line
|
|
getLine
(
doc
pos
.
line
)
)
.
text
.
length
)
{
if
(
pos
.
line
<
doc
.
first
+
doc
.
size
-
1
)
return
Pos
(
pos
.
line
+
1
0
)
;
else
return
null
;
}
else
{
return
new
Pos
(
pos
.
line
pos
.
ch
+
dir
)
;
}
}
function
updateSelection
(
cm
)
{
cm
.
display
.
input
.
showSelection
(
cm
.
display
.
input
.
prepareSelection
(
)
)
;
}
function
prepareSelection
(
cm
primary
)
{
var
doc
=
cm
.
doc
result
=
{
}
;
var
curFragment
=
result
.
cursors
=
document
.
createDocumentFragment
(
)
;
var
selFragment
=
result
.
selection
=
document
.
createDocumentFragment
(
)
;
for
(
var
i
=
0
;
i
<
doc
.
sel
.
ranges
.
length
;
i
+
+
)
{
if
(
primary
=
=
=
false
&
&
i
=
=
doc
.
sel
.
primIndex
)
continue
;
var
range
=
doc
.
sel
.
ranges
[
i
]
;
if
(
range
.
from
(
)
.
line
>
=
cm
.
display
.
viewTo
|
|
range
.
to
(
)
.
line
<
cm
.
display
.
viewFrom
)
continue
;
var
collapsed
=
range
.
empty
(
)
;
if
(
collapsed
|
|
cm
.
options
.
showCursorWhenSelecting
)
drawSelectionCursor
(
cm
range
.
head
curFragment
)
;
if
(
!
collapsed
)
drawSelectionRange
(
cm
range
selFragment
)
;
}
return
result
;
}
function
drawSelectionCursor
(
cm
head
output
)
{
var
pos
=
cursorCoords
(
cm
head
"
div
"
null
null
!
cm
.
options
.
singleCursorHeightPerLine
)
;
var
cursor
=
output
.
appendChild
(
elt
(
"
div
"
"
\
u00a0
"
"
CodeMirror
-
cursor
"
)
)
;
cursor
.
style
.
left
=
pos
.
left
+
"
px
"
;
cursor
.
style
.
top
=
pos
.
top
+
"
px
"
;
cursor
.
style
.
height
=
Math
.
max
(
0
pos
.
bottom
-
pos
.
top
)
*
cm
.
options
.
cursorHeight
+
"
px
"
;
if
(
pos
.
other
)
{
var
otherCursor
=
output
.
appendChild
(
elt
(
"
div
"
"
\
u00a0
"
"
CodeMirror
-
cursor
CodeMirror
-
secondarycursor
"
)
)
;
otherCursor
.
style
.
display
=
"
"
;
otherCursor
.
style
.
left
=
pos
.
other
.
left
+
"
px
"
;
otherCursor
.
style
.
top
=
pos
.
other
.
top
+
"
px
"
;
otherCursor
.
style
.
height
=
(
pos
.
other
.
bottom
-
pos
.
other
.
top
)
*
.
85
+
"
px
"
;
}
}
function
drawSelectionRange
(
cm
range
output
)
{
var
display
=
cm
.
display
doc
=
cm
.
doc
;
var
fragment
=
document
.
createDocumentFragment
(
)
;
var
padding
=
paddingH
(
cm
.
display
)
leftSide
=
padding
.
left
;
var
rightSide
=
Math
.
max
(
display
.
sizerWidth
displayWidth
(
cm
)
-
display
.
sizer
.
offsetLeft
)
-
padding
.
right
;
function
add
(
left
top
width
bottom
)
{
if
(
top
<
0
)
top
=
0
;
top
=
Math
.
round
(
top
)
;
bottom
=
Math
.
round
(
bottom
)
;
fragment
.
appendChild
(
elt
(
"
div
"
null
"
CodeMirror
-
selected
"
"
position
:
absolute
;
left
:
"
+
left
+
"
px
;
top
:
"
+
top
+
"
px
;
width
:
"
+
(
width
=
=
null
?
rightSide
-
left
:
width
)
+
"
px
;
height
:
"
+
(
bottom
-
top
)
+
"
px
"
)
)
;
}
function
drawForLine
(
line
fromArg
toArg
)
{
var
lineObj
=
getLine
(
doc
line
)
;
var
lineLen
=
lineObj
.
text
.
length
;
var
start
end
;
function
coords
(
ch
bias
)
{
return
charCoords
(
cm
Pos
(
line
ch
)
"
div
"
lineObj
bias
)
;
}
iterateBidiSections
(
getOrder
(
lineObj
)
fromArg
|
|
0
toArg
=
=
null
?
lineLen
:
toArg
function
(
from
to
dir
)
{
var
leftPos
=
coords
(
from
"
left
"
)
rightPos
left
right
;
if
(
from
=
=
to
)
{
rightPos
=
leftPos
;
left
=
right
=
leftPos
.
left
;
}
else
{
rightPos
=
coords
(
to
-
1
"
right
"
)
;
if
(
dir
=
=
"
rtl
"
)
{
var
tmp
=
leftPos
;
leftPos
=
rightPos
;
rightPos
=
tmp
;
}
left
=
leftPos
.
left
;
right
=
rightPos
.
right
;
}
if
(
fromArg
=
=
null
&
&
from
=
=
0
)
left
=
leftSide
;
if
(
rightPos
.
top
-
leftPos
.
top
>
3
)
{
add
(
left
leftPos
.
top
null
leftPos
.
bottom
)
;
left
=
leftSide
;
if
(
leftPos
.
bottom
<
rightPos
.
top
)
add
(
left
leftPos
.
bottom
null
rightPos
.
top
)
;
}
if
(
toArg
=
=
null
&
&
to
=
=
lineLen
)
right
=
rightSide
;
if
(
!
start
|
|
leftPos
.
top
<
start
.
top
|
|
leftPos
.
top
=
=
start
.
top
&
&
leftPos
.
left
<
start
.
left
)
start
=
leftPos
;
if
(
!
end
|
|
rightPos
.
bottom
>
end
.
bottom
|
|
rightPos
.
bottom
=
=
end
.
bottom
&
&
rightPos
.
right
>
end
.
right
)
end
=
rightPos
;
if
(
left
<
leftSide
+
1
)
left
=
leftSide
;
add
(
left
rightPos
.
top
right
-
left
rightPos
.
bottom
)
;
}
)
;
return
{
start
:
start
end
:
end
}
;
}
var
sFrom
=
range
.
from
(
)
sTo
=
range
.
to
(
)
;
if
(
sFrom
.
line
=
=
sTo
.
line
)
{
drawForLine
(
sFrom
.
line
sFrom
.
ch
sTo
.
ch
)
;
}
else
{
var
fromLine
=
getLine
(
doc
sFrom
.
line
)
toLine
=
getLine
(
doc
sTo
.
line
)
;
var
singleVLine
=
visualLine
(
fromLine
)
=
=
visualLine
(
toLine
)
;
var
leftEnd
=
drawForLine
(
sFrom
.
line
sFrom
.
ch
singleVLine
?
fromLine
.
text
.
length
+
1
:
null
)
.
end
;
var
rightStart
=
drawForLine
(
sTo
.
line
singleVLine
?
0
:
null
sTo
.
ch
)
.
start
;
if
(
singleVLine
)
{
if
(
leftEnd
.
top
<
rightStart
.
top
-
2
)
{
add
(
leftEnd
.
right
leftEnd
.
top
null
leftEnd
.
bottom
)
;
add
(
leftSide
rightStart
.
top
rightStart
.
left
rightStart
.
bottom
)
;
}
else
{
add
(
leftEnd
.
right
leftEnd
.
top
rightStart
.
left
-
leftEnd
.
right
leftEnd
.
bottom
)
;
}
}
if
(
leftEnd
.
bottom
<
rightStart
.
top
)
add
(
leftSide
leftEnd
.
bottom
null
rightStart
.
top
)
;
}
output
.
appendChild
(
fragment
)
;
}
function
restartBlink
(
cm
)
{
if
(
!
cm
.
state
.
focused
)
return
;
var
display
=
cm
.
display
;
clearInterval
(
display
.
blinker
)
;
var
on
=
true
;
display
.
cursorDiv
.
style
.
visibility
=
"
"
;
if
(
cm
.
options
.
cursorBlinkRate
>
0
)
display
.
blinker
=
setInterval
(
function
(
)
{
display
.
cursorDiv
.
style
.
visibility
=
(
on
=
!
on
)
?
"
"
:
"
hidden
"
;
}
cm
.
options
.
cursorBlinkRate
)
;
else
if
(
cm
.
options
.
cursorBlinkRate
<
0
)
display
.
cursorDiv
.
style
.
visibility
=
"
hidden
"
;
}
function
startWorker
(
cm
time
)
{
if
(
cm
.
doc
.
mode
.
startState
&
&
cm
.
doc
.
frontier
<
cm
.
display
.
viewTo
)
cm
.
state
.
highlight
.
set
(
time
bind
(
highlightWorker
cm
)
)
;
}
function
highlightWorker
(
cm
)
{
var
doc
=
cm
.
doc
;
if
(
doc
.
frontier
<
doc
.
first
)
doc
.
frontier
=
doc
.
first
;
if
(
doc
.
frontier
>
=
cm
.
display
.
viewTo
)
return
;
var
end
=
+
new
Date
+
cm
.
options
.
workTime
;
var
state
=
copyState
(
doc
.
mode
getStateBefore
(
cm
doc
.
frontier
)
)
;
var
changedLines
=
[
]
;
doc
.
iter
(
doc
.
frontier
Math
.
min
(
doc
.
first
+
doc
.
size
cm
.
display
.
viewTo
+
500
)
function
(
line
)
{
if
(
doc
.
frontier
>
=
cm
.
display
.
viewFrom
)
{
var
oldStyles
=
line
.
styles
tooLong
=
line
.
text
.
length
>
cm
.
options
.
maxHighlightLength
;
var
highlighted
=
highlightLine
(
cm
line
tooLong
?
copyState
(
doc
.
mode
state
)
:
state
true
)
;
line
.
styles
=
highlighted
.
styles
;
var
oldCls
=
line
.
styleClasses
newCls
=
highlighted
.
classes
;
if
(
newCls
)
line
.
styleClasses
=
newCls
;
else
if
(
oldCls
)
line
.
styleClasses
=
null
;
var
ischange
=
!
oldStyles
|
|
oldStyles
.
length
!
=
line
.
styles
.
length
|
|
oldCls
!
=
newCls
&
&
(
!
oldCls
|
|
!
newCls
|
|
oldCls
.
bgClass
!
=
newCls
.
bgClass
|
|
oldCls
.
textClass
!
=
newCls
.
textClass
)
;
for
(
var
i
=
0
;
!
ischange
&
&
i
<
oldStyles
.
length
;
+
+
i
)
ischange
=
oldStyles
[
i
]
!
=
line
.
styles
[
i
]
;
if
(
ischange
)
changedLines
.
push
(
doc
.
frontier
)
;
line
.
stateAfter
=
tooLong
?
state
:
copyState
(
doc
.
mode
state
)
;
}
else
{
if
(
line
.
text
.
length
<
=
cm
.
options
.
maxHighlightLength
)
processLine
(
cm
line
.
text
state
)
;
line
.
stateAfter
=
doc
.
frontier
%
5
=
=
0
?
copyState
(
doc
.
mode
state
)
:
null
;
}
+
+
doc
.
frontier
;
if
(
+
new
Date
>
end
)
{
startWorker
(
cm
cm
.
options
.
workDelay
)
;
return
true
;
}
}
)
;
if
(
changedLines
.
length
)
runInOp
(
cm
function
(
)
{
for
(
var
i
=
0
;
i
<
changedLines
.
length
;
i
+
+
)
regLineChange
(
cm
changedLines
[
i
]
"
text
"
)
;
}
)
;
}
function
findStartLine
(
cm
n
precise
)
{
var
minindent
minline
doc
=
cm
.
doc
;
var
lim
=
precise
?
-
1
:
n
-
(
cm
.
doc
.
mode
.
innerMode
?
1000
:
100
)
;
for
(
var
search
=
n
;
search
>
lim
;
-
-
search
)
{
if
(
search
<
=
doc
.
first
)
return
doc
.
first
;
var
line
=
getLine
(
doc
search
-
1
)
;
if
(
line
.
stateAfter
&
&
(
!
precise
|
|
search
<
=
doc
.
frontier
)
)
return
search
;
var
indented
=
countColumn
(
line
.
text
null
cm
.
options
.
tabSize
)
;
if
(
minline
=
=
null
|
|
minindent
>
indented
)
{
minline
=
search
-
1
;
minindent
=
indented
;
}
}
return
minline
;
}
function
getStateBefore
(
cm
n
precise
)
{
var
doc
=
cm
.
doc
display
=
cm
.
display
;
if
(
!
doc
.
mode
.
startState
)
return
true
;
var
pos
=
findStartLine
(
cm
n
precise
)
state
=
pos
>
doc
.
first
&
&
getLine
(
doc
pos
-
1
)
.
stateAfter
;
if
(
!
state
)
state
=
startState
(
doc
.
mode
)
;
else
state
=
copyState
(
doc
.
mode
state
)
;
doc
.
iter
(
pos
n
function
(
line
)
{
processLine
(
cm
line
.
text
state
)
;
var
save
=
pos
=
=
n
-
1
|
|
pos
%
5
=
=
0
|
|
pos
>
=
display
.
viewFrom
&
&
pos
<
display
.
viewTo
;
line
.
stateAfter
=
save
?
copyState
(
doc
.
mode
state
)
:
null
;
+
+
pos
;
}
)
;
if
(
precise
)
doc
.
frontier
=
pos
;
return
state
;
}
function
paddingTop
(
display
)
{
return
display
.
lineSpace
.
offsetTop
;
}
function
paddingVert
(
display
)
{
return
display
.
mover
.
offsetHeight
-
display
.
lineSpace
.
offsetHeight
;
}
function
paddingH
(
display
)
{
if
(
display
.
cachedPaddingH
)
return
display
.
cachedPaddingH
;
var
e
=
removeChildrenAndAdd
(
display
.
measure
elt
(
"
pre
"
"
x
"
)
)
;
var
style
=
window
.
getComputedStyle
?
window
.
getComputedStyle
(
e
)
:
e
.
currentStyle
;
var
data
=
{
left
:
parseInt
(
style
.
paddingLeft
)
right
:
parseInt
(
style
.
paddingRight
)
}
;
if
(
!
isNaN
(
data
.
left
)
&
&
!
isNaN
(
data
.
right
)
)
display
.
cachedPaddingH
=
data
;
return
data
;
}
function
scrollGap
(
cm
)
{
return
scrollerGap
-
cm
.
display
.
nativeBarWidth
;
}
function
displayWidth
(
cm
)
{
return
cm
.
display
.
scroller
.
clientWidth
-
scrollGap
(
cm
)
-
cm
.
display
.
barWidth
;
}
function
displayHeight
(
cm
)
{
return
cm
.
display
.
scroller
.
clientHeight
-
scrollGap
(
cm
)
-
cm
.
display
.
barHeight
;
}
function
ensureLineHeights
(
cm
lineView
rect
)
{
var
wrapping
=
cm
.
options
.
lineWrapping
;
var
curWidth
=
wrapping
&
&
displayWidth
(
cm
)
;
if
(
!
lineView
.
measure
.
heights
|
|
wrapping
&
&
lineView
.
measure
.
width
!
=
curWidth
)
{
var
heights
=
lineView
.
measure
.
heights
=
[
]
;
if
(
wrapping
)
{
lineView
.
measure
.
width
=
curWidth
;
var
rects
=
lineView
.
text
.
firstChild
.
getClientRects
(
)
;
for
(
var
i
=
0
;
i
<
rects
.
length
-
1
;
i
+
+
)
{
var
cur
=
rects
[
i
]
next
=
rects
[
i
+
1
]
;
if
(
Math
.
abs
(
cur
.
bottom
-
next
.
bottom
)
>
2
)
heights
.
push
(
(
cur
.
bottom
+
next
.
top
)
/
2
-
rect
.
top
)
;
}
}
heights
.
push
(
rect
.
bottom
-
rect
.
top
)
;
}
}
function
mapFromLineView
(
lineView
line
lineN
)
{
if
(
lineView
.
line
=
=
line
)
return
{
map
:
lineView
.
measure
.
map
cache
:
lineView
.
measure
.
cache
}
;
for
(
var
i
=
0
;
i
<
lineView
.
rest
.
length
;
i
+
+
)
if
(
lineView
.
rest
[
i
]
=
=
line
)
return
{
map
:
lineView
.
measure
.
maps
[
i
]
cache
:
lineView
.
measure
.
caches
[
i
]
}
;
for
(
var
i
=
0
;
i
<
lineView
.
rest
.
length
;
i
+
+
)
if
(
lineNo
(
lineView
.
rest
[
i
]
)
>
lineN
)
return
{
map
:
lineView
.
measure
.
maps
[
i
]
cache
:
lineView
.
measure
.
caches
[
i
]
before
:
true
}
;
}
function
updateExternalMeasurement
(
cm
line
)
{
line
=
visualLine
(
line
)
;
var
lineN
=
lineNo
(
line
)
;
var
view
=
cm
.
display
.
externalMeasured
=
new
LineView
(
cm
.
doc
line
lineN
)
;
view
.
lineN
=
lineN
;
var
built
=
view
.
built
=
buildLineContent
(
cm
view
)
;
view
.
text
=
built
.
pre
;
removeChildrenAndAdd
(
cm
.
display
.
lineMeasure
built
.
pre
)
;
return
view
;
}
function
measureChar
(
cm
line
ch
bias
)
{
return
measureCharPrepared
(
cm
prepareMeasureForLine
(
cm
line
)
ch
bias
)
;
}
function
findViewForLine
(
cm
lineN
)
{
if
(
lineN
>
=
cm
.
display
.
viewFrom
&
&
lineN
<
cm
.
display
.
viewTo
)
return
cm
.
display
.
view
[
findViewIndex
(
cm
lineN
)
]
;
var
ext
=
cm
.
display
.
externalMeasured
;
if
(
ext
&
&
lineN
>
=
ext
.
lineN
&
&
lineN
<
ext
.
lineN
+
ext
.
size
)
return
ext
;
}
function
prepareMeasureForLine
(
cm
line
)
{
var
lineN
=
lineNo
(
line
)
;
var
view
=
findViewForLine
(
cm
lineN
)
;
if
(
view
&
&
!
view
.
text
)
{
view
=
null
;
}
else
if
(
view
&
&
view
.
changes
)
{
updateLineForChanges
(
cm
view
lineN
getDimensions
(
cm
)
)
;
cm
.
curOp
.
forceUpdate
=
true
;
}
if
(
!
view
)
view
=
updateExternalMeasurement
(
cm
line
)
;
var
info
=
mapFromLineView
(
view
line
lineN
)
;
return
{
line
:
line
view
:
view
rect
:
null
map
:
info
.
map
cache
:
info
.
cache
before
:
info
.
before
hasHeights
:
false
}
;
}
function
measureCharPrepared
(
cm
prepared
ch
bias
varHeight
)
{
if
(
prepared
.
before
)
ch
=
-
1
;
var
key
=
ch
+
(
bias
|
|
"
"
)
found
;
if
(
prepared
.
cache
.
hasOwnProperty
(
key
)
)
{
found
=
prepared
.
cache
[
key
]
;
}
else
{
if
(
!
prepared
.
rect
)
prepared
.
rect
=
prepared
.
view
.
text
.
getBoundingClientRect
(
)
;
if
(
!
prepared
.
hasHeights
)
{
ensureLineHeights
(
cm
prepared
.
view
prepared
.
rect
)
;
prepared
.
hasHeights
=
true
;
}
found
=
measureCharInner
(
cm
prepared
ch
bias
)
;
if
(
!
found
.
bogus
)
prepared
.
cache
[
key
]
=
found
;
}
return
{
left
:
found
.
left
right
:
found
.
right
top
:
varHeight
?
found
.
rtop
:
found
.
top
bottom
:
varHeight
?
found
.
rbottom
:
found
.
bottom
}
;
}
var
nullRect
=
{
left
:
0
right
:
0
top
:
0
bottom
:
0
}
;
function
nodeAndOffsetInLineMap
(
map
ch
bias
)
{
var
node
start
end
collapse
;
for
(
var
i
=
0
;
i
<
map
.
length
;
i
+
=
3
)
{
var
mStart
=
map
[
i
]
mEnd
=
map
[
i
+
1
]
;
if
(
ch
<
mStart
)
{
start
=
0
;
end
=
1
;
collapse
=
"
left
"
;
}
else
if
(
ch
<
mEnd
)
{
start
=
ch
-
mStart
;
end
=
start
+
1
;
}
else
if
(
i
=
=
map
.
length
-
3
|
|
ch
=
=
mEnd
&
&
map
[
i
+
3
]
>
ch
)
{
end
=
mEnd
-
mStart
;
start
=
end
-
1
;
if
(
ch
>
=
mEnd
)
collapse
=
"
right
"
;
}
if
(
start
!
=
null
)
{
node
=
map
[
i
+
2
]
;
if
(
mStart
=
=
mEnd
&
&
bias
=
=
(
node
.
insertLeft
?
"
left
"
:
"
right
"
)
)
collapse
=
bias
;
if
(
bias
=
=
"
left
"
&
&
start
=
=
0
)
while
(
i
&
&
map
[
i
-
2
]
=
=
map
[
i
-
3
]
&
&
map
[
i
-
1
]
.
insertLeft
)
{
node
=
map
[
(
i
-
=
3
)
+
2
]
;
collapse
=
"
left
"
;
}
if
(
bias
=
=
"
right
"
&
&
start
=
=
mEnd
-
mStart
)
while
(
i
<
map
.
length
-
3
&
&
map
[
i
+
3
]
=
=
map
[
i
+
4
]
&
&
!
map
[
i
+
5
]
.
insertLeft
)
{
node
=
map
[
(
i
+
=
3
)
+
2
]
;
collapse
=
"
right
"
;
}
break
;
}
}
return
{
node
:
node
start
:
start
end
:
end
collapse
:
collapse
coverStart
:
mStart
coverEnd
:
mEnd
}
;
}
function
measureCharInner
(
cm
prepared
ch
bias
)
{
var
place
=
nodeAndOffsetInLineMap
(
prepared
.
map
ch
bias
)
;
var
node
=
place
.
node
start
=
place
.
start
end
=
place
.
end
collapse
=
place
.
collapse
;
var
rect
;
if
(
node
.
nodeType
=
=
3
)
{
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
while
(
start
&
&
isExtendingChar
(
prepared
.
line
.
text
.
charAt
(
place
.
coverStart
+
start
)
)
)
-
-
start
;
while
(
place
.
coverStart
+
end
<
place
.
coverEnd
&
&
isExtendingChar
(
prepared
.
line
.
text
.
charAt
(
place
.
coverStart
+
end
)
)
)
+
+
end
;
if
(
ie
&
&
ie_version
<
9
&
&
start
=
=
0
&
&
end
=
=
place
.
coverEnd
-
place
.
coverStart
)
{
rect
=
node
.
parentNode
.
getBoundingClientRect
(
)
;
}
else
if
(
ie
&
&
cm
.
options
.
lineWrapping
)
{
var
rects
=
range
(
node
start
end
)
.
getClientRects
(
)
;
if
(
rects
.
length
)
rect
=
rects
[
bias
=
=
"
right
"
?
rects
.
length
-
1
:
0
]
;
else
rect
=
nullRect
;
}
else
{
rect
=
range
(
node
start
end
)
.
getBoundingClientRect
(
)
|
|
nullRect
;
}
if
(
rect
.
left
|
|
rect
.
right
|
|
start
=
=
0
)
break
;
end
=
start
;
start
=
start
-
1
;
collapse
=
"
right
"
;
}
if
(
ie
&
&
ie_version
<
11
)
rect
=
maybeUpdateRectForZooming
(
cm
.
display
.
measure
rect
)
;
}
else
{
if
(
start
>
0
)
collapse
=
bias
=
"
right
"
;
var
rects
;
if
(
cm
.
options
.
lineWrapping
&
&
(
rects
=
node
.
getClientRects
(
)
)
.
length
>
1
)
rect
=
rects
[
bias
=
=
"
right
"
?
rects
.
length
-
1
:
0
]
;
else
rect
=
node
.
getBoundingClientRect
(
)
;
}
if
(
ie
&
&
ie_version
<
9
&
&
!
start
&
&
(
!
rect
|
|
!
rect
.
left
&
&
!
rect
.
right
)
)
{
var
rSpan
=
node
.
parentNode
.
getClientRects
(
)
[
0
]
;
if
(
rSpan
)
rect
=
{
left
:
rSpan
.
left
right
:
rSpan
.
left
+
charWidth
(
cm
.
display
)
top
:
rSpan
.
top
bottom
:
rSpan
.
bottom
}
;
else
rect
=
nullRect
;
}
var
rtop
=
rect
.
top
-
prepared
.
rect
.
top
rbot
=
rect
.
bottom
-
prepared
.
rect
.
top
;
var
mid
=
(
rtop
+
rbot
)
/
2
;
var
heights
=
prepared
.
view
.
measure
.
heights
;
for
(
var
i
=
0
;
i
<
heights
.
length
-
1
;
i
+
+
)
if
(
mid
<
heights
[
i
]
)
break
;
var
top
=
i
?
heights
[
i
-
1
]
:
0
bot
=
heights
[
i
]
;
var
result
=
{
left
:
(
collapse
=
=
"
right
"
?
rect
.
right
:
rect
.
left
)
-
prepared
.
rect
.
left
right
:
(
collapse
=
=
"
left
"
?
rect
.
left
:
rect
.
right
)
-
prepared
.
rect
.
left
top
:
top
bottom
:
bot
}
;
if
(
!
rect
.
left
&
&
!
rect
.
right
)
result
.
bogus
=
true
;
if
(
!
cm
.
options
.
singleCursorHeightPerLine
)
{
result
.
rtop
=
rtop
;
result
.
rbottom
=
rbot
;
}
return
result
;
}
function
maybeUpdateRectForZooming
(
measure
rect
)
{
if
(
!
window
.
screen
|
|
screen
.
logicalXDPI
=
=
null
|
|
screen
.
logicalXDPI
=
=
screen
.
deviceXDPI
|
|
!
hasBadZoomedRects
(
measure
)
)
return
rect
;
var
scaleX
=
screen
.
logicalXDPI
/
screen
.
deviceXDPI
;
var
scaleY
=
screen
.
logicalYDPI
/
screen
.
deviceYDPI
;
return
{
left
:
rect
.
left
*
scaleX
right
:
rect
.
right
*
scaleX
top
:
rect
.
top
*
scaleY
bottom
:
rect
.
bottom
*
scaleY
}
;
}
function
clearLineMeasurementCacheFor
(
lineView
)
{
if
(
lineView
.
measure
)
{
lineView
.
measure
.
cache
=
{
}
;
lineView
.
measure
.
heights
=
null
;
if
(
lineView
.
rest
)
for
(
var
i
=
0
;
i
<
lineView
.
rest
.
length
;
i
+
+
)
lineView
.
measure
.
caches
[
i
]
=
{
}
;
}
}
function
clearLineMeasurementCache
(
cm
)
{
cm
.
display
.
externalMeasure
=
null
;
removeChildren
(
cm
.
display
.
lineMeasure
)
;
for
(
var
i
=
0
;
i
<
cm
.
display
.
view
.
length
;
i
+
+
)
clearLineMeasurementCacheFor
(
cm
.
display
.
view
[
i
]
)
;
}
function
clearCaches
(
cm
)
{
clearLineMeasurementCache
(
cm
)
;
cm
.
display
.
cachedCharWidth
=
cm
.
display
.
cachedTextHeight
=
cm
.
display
.
cachedPaddingH
=
null
;
if
(
!
cm
.
options
.
lineWrapping
)
cm
.
display
.
maxLineChanged
=
true
;
cm
.
display
.
lineNumChars
=
null
;
}
function
pageScrollX
(
)
{
return
window
.
pageXOffset
|
|
(
document
.
documentElement
|
|
document
.
body
)
.
scrollLeft
;
}
function
pageScrollY
(
)
{
return
window
.
pageYOffset
|
|
(
document
.
documentElement
|
|
document
.
body
)
.
scrollTop
;
}
function
intoCoordSystem
(
cm
lineObj
rect
context
)
{
if
(
lineObj
.
widgets
)
for
(
var
i
=
0
;
i
<
lineObj
.
widgets
.
length
;
+
+
i
)
if
(
lineObj
.
widgets
[
i
]
.
above
)
{
var
size
=
widgetHeight
(
lineObj
.
widgets
[
i
]
)
;
rect
.
top
+
=
size
;
rect
.
bottom
+
=
size
;
}
if
(
context
=
=
"
line
"
)
return
rect
;
if
(
!
context
)
context
=
"
local
"
;
var
yOff
=
heightAtLine
(
lineObj
)
;
if
(
context
=
=
"
local
"
)
yOff
+
=
paddingTop
(
cm
.
display
)
;
else
yOff
-
=
cm
.
display
.
viewOffset
;
if
(
context
=
=
"
page
"
|
|
context
=
=
"
window
"
)
{
var
lOff
=
cm
.
display
.
lineSpace
.
getBoundingClientRect
(
)
;
yOff
+
=
lOff
.
top
+
(
context
=
=
"
window
"
?
0
:
pageScrollY
(
)
)
;
var
xOff
=
lOff
.
left
+
(
context
=
=
"
window
"
?
0
:
pageScrollX
(
)
)
;
rect
.
left
+
=
xOff
;
rect
.
right
+
=
xOff
;
}
rect
.
top
+
=
yOff
;
rect
.
bottom
+
=
yOff
;
return
rect
;
}
function
fromCoordSystem
(
cm
coords
context
)
{
if
(
context
=
=
"
div
"
)
return
coords
;
var
left
=
coords
.
left
top
=
coords
.
top
;
if
(
context
=
=
"
page
"
)
{
left
-
=
pageScrollX
(
)
;
top
-
=
pageScrollY
(
)
;
}
else
if
(
context
=
=
"
local
"
|
|
!
context
)
{
var
localBox
=
cm
.
display
.
sizer
.
getBoundingClientRect
(
)
;
left
+
=
localBox
.
left
;
top
+
=
localBox
.
top
;
}
var
lineSpaceBox
=
cm
.
display
.
lineSpace
.
getBoundingClientRect
(
)
;
return
{
left
:
left
-
lineSpaceBox
.
left
top
:
top
-
lineSpaceBox
.
top
}
;
}
function
charCoords
(
cm
pos
context
lineObj
bias
)
{
if
(
!
lineObj
)
lineObj
=
getLine
(
cm
.
doc
pos
.
line
)
;
return
intoCoordSystem
(
cm
lineObj
measureChar
(
cm
lineObj
pos
.
ch
bias
)
context
)
;
}
function
cursorCoords
(
cm
pos
context
lineObj
preparedMeasure
varHeight
)
{
lineObj
=
lineObj
|
|
getLine
(
cm
.
doc
pos
.
line
)
;
if
(
!
preparedMeasure
)
preparedMeasure
=
prepareMeasureForLine
(
cm
lineObj
)
;
function
get
(
ch
right
)
{
var
m
=
measureCharPrepared
(
cm
preparedMeasure
ch
right
?
"
right
"
:
"
left
"
varHeight
)
;
if
(
right
)
m
.
left
=
m
.
right
;
else
m
.
right
=
m
.
left
;
return
intoCoordSystem
(
cm
lineObj
m
context
)
;
}
function
getBidi
(
ch
partPos
)
{
var
part
=
order
[
partPos
]
right
=
part
.
level
%
2
;
if
(
ch
=
=
bidiLeft
(
part
)
&
&
partPos
&
&
part
.
level
<
order
[
partPos
-
1
]
.
level
)
{
part
=
order
[
-
-
partPos
]
;
ch
=
bidiRight
(
part
)
-
(
part
.
level
%
2
?
0
:
1
)
;
right
=
true
;
}
else
if
(
ch
=
=
bidiRight
(
part
)
&
&
partPos
<
order
.
length
-
1
&
&
part
.
level
<
order
[
partPos
+
1
]
.
level
)
{
part
=
order
[
+
+
partPos
]
;
ch
=
bidiLeft
(
part
)
-
part
.
level
%
2
;
right
=
false
;
}
if
(
right
&
&
ch
=
=
part
.
to
&
&
ch
>
part
.
from
)
return
get
(
ch
-
1
)
;
return
get
(
ch
right
)
;
}
var
order
=
getOrder
(
lineObj
)
ch
=
pos
.
ch
;
if
(
!
order
)
return
get
(
ch
)
;
var
partPos
=
getBidiPartAt
(
order
ch
)
;
var
val
=
getBidi
(
ch
partPos
)
;
if
(
bidiOther
!
=
null
)
val
.
other
=
getBidi
(
ch
bidiOther
)
;
return
val
;
}
function
estimateCoords
(
cm
pos
)
{
var
left
=
0
pos
=
clipPos
(
cm
.
doc
pos
)
;
if
(
!
cm
.
options
.
lineWrapping
)
left
=
charWidth
(
cm
.
display
)
*
pos
.
ch
;
var
lineObj
=
getLine
(
cm
.
doc
pos
.
line
)
;
var
top
=
heightAtLine
(
lineObj
)
+
paddingTop
(
cm
.
display
)
;
return
{
left
:
left
right
:
left
top
:
top
bottom
:
top
+
lineObj
.
height
}
;
}
function
PosWithInfo
(
line
ch
outside
xRel
)
{
var
pos
=
Pos
(
line
ch
)
;
pos
.
xRel
=
xRel
;
if
(
outside
)
pos
.
outside
=
true
;
return
pos
;
}
function
coordsChar
(
cm
x
y
)
{
var
doc
=
cm
.
doc
;
y
+
=
cm
.
display
.
viewOffset
;
if
(
y
<
0
)
return
PosWithInfo
(
doc
.
first
0
true
-
1
)
;
var
lineN
=
lineAtHeight
(
doc
y
)
last
=
doc
.
first
+
doc
.
size
-
1
;
if
(
lineN
>
last
)
return
PosWithInfo
(
doc
.
first
+
doc
.
size
-
1
getLine
(
doc
last
)
.
text
.
length
true
1
)
;
if
(
x
<
0
)
x
=
0
;
var
lineObj
=
getLine
(
doc
lineN
)
;
for
(
;
;
)
{
var
found
=
coordsCharInner
(
cm
lineObj
lineN
x
y
)
;
var
merged
=
collapsedSpanAtEnd
(
lineObj
)
;
var
mergedPos
=
merged
&
&
merged
.
find
(
0
true
)
;
if
(
merged
&
&
(
found
.
ch
>
mergedPos
.
from
.
ch
|
|
found
.
ch
=
=
mergedPos
.
from
.
ch
&
&
found
.
xRel
>
0
)
)
lineN
=
lineNo
(
lineObj
=
mergedPos
.
to
.
line
)
;
else
return
found
;
}
}
function
coordsCharInner
(
cm
lineObj
lineNo
x
y
)
{
var
innerOff
=
y
-
heightAtLine
(
lineObj
)
;
var
wrongLine
=
false
adjust
=
2
*
cm
.
display
.
wrapper
.
clientWidth
;
var
preparedMeasure
=
prepareMeasureForLine
(
cm
lineObj
)
;
function
getX
(
ch
)
{
var
sp
=
cursorCoords
(
cm
Pos
(
lineNo
ch
)
"
line
"
lineObj
preparedMeasure
)
;
wrongLine
=
true
;
if
(
innerOff
>
sp
.
bottom
)
return
sp
.
left
-
adjust
;
else
if
(
innerOff
<
sp
.
top
)
return
sp
.
left
+
adjust
;
else
wrongLine
=
false
;
return
sp
.
left
;
}
var
bidi
=
getOrder
(
lineObj
)
dist
=
lineObj
.
text
.
length
;
var
from
=
lineLeft
(
lineObj
)
to
=
lineRight
(
lineObj
)
;
var
fromX
=
getX
(
from
)
fromOutside
=
wrongLine
toX
=
getX
(
to
)
toOutside
=
wrongLine
;
if
(
x
>
toX
)
return
PosWithInfo
(
lineNo
to
toOutside
1
)
;
for
(
;
;
)
{
if
(
bidi
?
to
=
=
from
|
|
to
=
=
moveVisually
(
lineObj
from
1
)
:
to
-
from
<
=
1
)
{
var
ch
=
x
<
fromX
|
|
x
-
fromX
<
=
toX
-
x
?
from
:
to
;
var
outside
=
ch
=
=
from
?
fromOutside
:
toOutside
var
xDiff
=
x
-
(
ch
=
=
from
?
fromX
:
toX
)
;
if
(
toOutside
&
&
!
bidi
&
&
!
/
\
s
/
.
test
(
lineObj
.
text
.
charAt
(
ch
)
)
&
&
xDiff
>
0
&
&
ch
<
lineObj
.
text
.
length
&
&
preparedMeasure
.
view
.
measure
.
heights
.
length
>
1
)
{
var
charSize
=
measureCharPrepared
(
cm
preparedMeasure
ch
"
right
"
)
;
if
(
innerOff
<
=
charSize
.
bottom
&
&
innerOff
>
=
charSize
.
top
&
&
Math
.
abs
(
x
-
charSize
.
right
)
<
xDiff
)
{
outside
=
false
ch
+
+
xDiff
=
x
-
charSize
.
right
}
}
while
(
isExtendingChar
(
lineObj
.
text
.
charAt
(
ch
)
)
)
+
+
ch
;
var
pos
=
PosWithInfo
(
lineNo
ch
outside
xDiff
<
-
1
?
-
1
:
xDiff
>
1
?
1
:
0
)
;
return
pos
;
}
var
step
=
Math
.
ceil
(
dist
/
2
)
middle
=
from
+
step
;
if
(
bidi
)
{
middle
=
from
;
for
(
var
i
=
0
;
i
<
step
;
+
+
i
)
middle
=
moveVisually
(
lineObj
middle
1
)
;
}
var
middleX
=
getX
(
middle
)
;
if
(
middleX
>
x
)
{
to
=
middle
;
toX
=
middleX
;
if
(
toOutside
=
wrongLine
)
toX
+
=
1000
;
dist
=
step
;
}
else
{
from
=
middle
;
fromX
=
middleX
;
fromOutside
=
wrongLine
;
dist
-
=
step
;
}
}
}
var
measureText
;
function
textHeight
(
display
)
{
if
(
display
.
cachedTextHeight
!
=
null
)
return
display
.
cachedTextHeight
;
if
(
measureText
=
=
null
)
{
measureText
=
elt
(
"
pre
"
)
;
for
(
var
i
=
0
;
i
<
49
;
+
+
i
)
{
measureText
.
appendChild
(
document
.
createTextNode
(
"
x
"
)
)
;
measureText
.
appendChild
(
elt
(
"
br
"
)
)
;
}
measureText
.
appendChild
(
document
.
createTextNode
(
"
x
"
)
)
;
}
removeChildrenAndAdd
(
display
.
measure
measureText
)
;
var
height
=
measureText
.
offsetHeight
/
50
;
if
(
height
>
3
)
display
.
cachedTextHeight
=
height
;
removeChildren
(
display
.
measure
)
;
return
height
|
|
1
;
}
function
charWidth
(
display
)
{
if
(
display
.
cachedCharWidth
!
=
null
)
return
display
.
cachedCharWidth
;
var
anchor
=
elt
(
"
span
"
"
xxxxxxxxxx
"
)
;
var
pre
=
elt
(
"
pre
"
[
anchor
]
)
;
removeChildrenAndAdd
(
display
.
measure
pre
)
;
var
rect
=
anchor
.
getBoundingClientRect
(
)
width
=
(
rect
.
right
-
rect
.
left
)
/
10
;
if
(
width
>
2
)
display
.
cachedCharWidth
=
width
;
return
width
|
|
10
;
}
var
operationGroup
=
null
;
var
nextOpId
=
0
;
function
startOperation
(
cm
)
{
cm
.
curOp
=
{
cm
:
cm
viewChanged
:
false
startHeight
:
cm
.
doc
.
height
forceUpdate
:
false
updateInput
:
null
typing
:
false
changeObjs
:
null
cursorActivityHandlers
:
null
cursorActivityCalled
:
0
selectionChanged
:
false
updateMaxLine
:
false
scrollLeft
:
null
scrollTop
:
null
scrollToPos
:
null
focus
:
false
id
:
+
+
nextOpId
}
;
if
(
operationGroup
)
{
operationGroup
.
ops
.
push
(
cm
.
curOp
)
;
}
else
{
cm
.
curOp
.
ownsGroup
=
operationGroup
=
{
ops
:
[
cm
.
curOp
]
delayedCallbacks
:
[
]
}
;
}
}
function
fireCallbacksForOps
(
group
)
{
var
callbacks
=
group
.
delayedCallbacks
i
=
0
;
do
{
for
(
;
i
<
callbacks
.
length
;
i
+
+
)
callbacks
[
i
]
.
call
(
null
)
;
for
(
var
j
=
0
;
j
<
group
.
ops
.
length
;
j
+
+
)
{
var
op
=
group
.
ops
[
j
]
;
if
(
op
.
cursorActivityHandlers
)
while
(
op
.
cursorActivityCalled
<
op
.
cursorActivityHandlers
.
length
)
op
.
cursorActivityHandlers
[
op
.
cursorActivityCalled
+
+
]
.
call
(
null
op
.
cm
)
;
}
}
while
(
i
<
callbacks
.
length
)
;
}
function
endOperation
(
cm
)
{
var
op
=
cm
.
curOp
group
=
op
.
ownsGroup
;
if
(
!
group
)
return
;
try
{
fireCallbacksForOps
(
group
)
;
}
finally
{
operationGroup
=
null
;
for
(
var
i
=
0
;
i
<
group
.
ops
.
length
;
i
+
+
)
group
.
ops
[
i
]
.
cm
.
curOp
=
null
;
endOperations
(
group
)
;
}
}
function
endOperations
(
group
)
{
var
ops
=
group
.
ops
;
for
(
var
i
=
0
;
i
<
ops
.
length
;
i
+
+
)
endOperation_R1
(
ops
[
i
]
)
;
for
(
var
i
=
0
;
i
<
ops
.
length
;
i
+
+
)
endOperation_W1
(
ops
[
i
]
)
;
for
(
var
i
=
0
;
i
<
ops
.
length
;
i
+
+
)
endOperation_R2
(
ops
[
i
]
)
;
for
(
var
i
=
0
;
i
<
ops
.
length
;
i
+
+
)
endOperation_W2
(
ops
[
i
]
)
;
for
(
var
i
=
0
;
i
<
ops
.
length
;
i
+
+
)
endOperation_finish
(
ops
[
i
]
)
;
}
function
endOperation_R1
(
op
)
{
var
cm
=
op
.
cm
display
=
cm
.
display
;
maybeClipScrollbars
(
cm
)
;
if
(
op
.
updateMaxLine
)
findMaxLine
(
cm
)
;
op
.
mustUpdate
=
op
.
viewChanged
|
|
op
.
forceUpdate
|
|
op
.
scrollTop
!
=
null
|
|
op
.
scrollToPos
&
&
(
op
.
scrollToPos
.
from
.
line
<
display
.
viewFrom
|
|
op
.
scrollToPos
.
to
.
line
>
=
display
.
viewTo
)
|
|
display
.
maxLineChanged
&
&
cm
.
options
.
lineWrapping
;
op
.
update
=
op
.
mustUpdate
&
&
new
DisplayUpdate
(
cm
op
.
mustUpdate
&
&
{
top
:
op
.
scrollTop
ensure
:
op
.
scrollToPos
}
op
.
forceUpdate
)
;
}
function
endOperation_W1
(
op
)
{
op
.
updatedDisplay
=
op
.
mustUpdate
&
&
updateDisplayIfNeeded
(
op
.
cm
op
.
update
)
;
}
function
endOperation_R2
(
op
)
{
var
cm
=
op
.
cm
display
=
cm
.
display
;
if
(
op
.
updatedDisplay
)
updateHeightsInViewport
(
cm
)
;
op
.
barMeasure
=
measureForScrollbars
(
cm
)
;
if
(
display
.
maxLineChanged
&
&
!
cm
.
options
.
lineWrapping
)
{
op
.
adjustWidthTo
=
measureChar
(
cm
display
.
maxLine
display
.
maxLine
.
text
.
length
)
.
left
+
3
;
cm
.
display
.
sizerWidth
=
op
.
adjustWidthTo
;
op
.
barMeasure
.
scrollWidth
=
Math
.
max
(
display
.
scroller
.
clientWidth
display
.
sizer
.
offsetLeft
+
op
.
adjustWidthTo
+
scrollGap
(
cm
)
+
cm
.
display
.
barWidth
)
;
op
.
maxScrollLeft
=
Math
.
max
(
0
display
.
sizer
.
offsetLeft
+
op
.
adjustWidthTo
-
displayWidth
(
cm
)
)
;
}
if
(
op
.
updatedDisplay
|
|
op
.
selectionChanged
)
op
.
preparedSelection
=
display
.
input
.
prepareSelection
(
op
.
focus
)
;
}
function
endOperation_W2
(
op
)
{
var
cm
=
op
.
cm
;
if
(
op
.
adjustWidthTo
!
=
null
)
{
cm
.
display
.
sizer
.
style
.
minWidth
=
op
.
adjustWidthTo
+
"
px
"
;
if
(
op
.
maxScrollLeft
<
cm
.
doc
.
scrollLeft
)
setScrollLeft
(
cm
Math
.
min
(
cm
.
display
.
scroller
.
scrollLeft
op
.
maxScrollLeft
)
true
)
;
cm
.
display
.
maxLineChanged
=
false
;
}
var
takeFocus
=
op
.
focus
&
&
op
.
focus
=
=
activeElt
(
)
&
&
(
!
document
.
hasFocus
|
|
document
.
hasFocus
(
)
)
if
(
op
.
preparedSelection
)
cm
.
display
.
input
.
showSelection
(
op
.
preparedSelection
takeFocus
)
;
if
(
op
.
updatedDisplay
|
|
op
.
startHeight
!
=
cm
.
doc
.
height
)
updateScrollbars
(
cm
op
.
barMeasure
)
;
if
(
op
.
updatedDisplay
)
setDocumentHeight
(
cm
op
.
barMeasure
)
;
if
(
op
.
selectionChanged
)
restartBlink
(
cm
)
;
if
(
cm
.
state
.
focused
&
&
op
.
updateInput
)
cm
.
display
.
input
.
reset
(
op
.
typing
)
;
if
(
takeFocus
)
ensureFocus
(
op
.
cm
)
;
}
function
endOperation_finish
(
op
)
{
var
cm
=
op
.
cm
display
=
cm
.
display
doc
=
cm
.
doc
;
if
(
op
.
updatedDisplay
)
postUpdateDisplay
(
cm
op
.
update
)
;
if
(
display
.
wheelStartX
!
=
null
&
&
(
op
.
scrollTop
!
=
null
|
|
op
.
scrollLeft
!
=
null
|
|
op
.
scrollToPos
)
)
display
.
wheelStartX
=
display
.
wheelStartY
=
null
;
if
(
op
.
scrollTop
!
=
null
&
&
(
display
.
scroller
.
scrollTop
!
=
op
.
scrollTop
|
|
op
.
forceScroll
)
)
{
doc
.
scrollTop
=
Math
.
max
(
0
Math
.
min
(
display
.
scroller
.
scrollHeight
-
display
.
scroller
.
clientHeight
op
.
scrollTop
)
)
;
display
.
scrollbars
.
setScrollTop
(
doc
.
scrollTop
)
;
display
.
scroller
.
scrollTop
=
doc
.
scrollTop
;
}
if
(
op
.
scrollLeft
!
=
null
&
&
(
display
.
scroller
.
scrollLeft
!
=
op
.
scrollLeft
|
|
op
.
forceScroll
)
)
{
doc
.
scrollLeft
=
Math
.
max
(
0
Math
.
min
(
display
.
scroller
.
scrollWidth
-
display
.
scroller
.
clientWidth
op
.
scrollLeft
)
)
;
display
.
scrollbars
.
setScrollLeft
(
doc
.
scrollLeft
)
;
display
.
scroller
.
scrollLeft
=
doc
.
scrollLeft
;
alignHorizontally
(
cm
)
;
}
if
(
op
.
scrollToPos
)
{
var
coords
=
scrollPosIntoView
(
cm
clipPos
(
doc
op
.
scrollToPos
.
from
)
clipPos
(
doc
op
.
scrollToPos
.
to
)
op
.
scrollToPos
.
margin
)
;
if
(
op
.
scrollToPos
.
isCursor
&
&
cm
.
state
.
focused
)
maybeScrollWindow
(
cm
coords
)
;
}
var
hidden
=
op
.
maybeHiddenMarkers
unhidden
=
op
.
maybeUnhiddenMarkers
;
if
(
hidden
)
for
(
var
i
=
0
;
i
<
hidden
.
length
;
+
+
i
)
if
(
!
hidden
[
i
]
.
lines
.
length
)
signal
(
hidden
[
i
]
"
hide
"
)
;
if
(
unhidden
)
for
(
var
i
=
0
;
i
<
unhidden
.
length
;
+
+
i
)
if
(
unhidden
[
i
]
.
lines
.
length
)
signal
(
unhidden
[
i
]
"
unhide
"
)
;
if
(
display
.
wrapper
.
offsetHeight
)
doc
.
scrollTop
=
cm
.
display
.
scroller
.
scrollTop
;
if
(
op
.
changeObjs
)
signal
(
cm
"
changes
"
cm
op
.
changeObjs
)
;
if
(
op
.
update
)
op
.
update
.
finish
(
)
;
}
function
runInOp
(
cm
f
)
{
if
(
cm
.
curOp
)
return
f
(
)
;
startOperation
(
cm
)
;
try
{
return
f
(
)
;
}
finally
{
endOperation
(
cm
)
;
}
}
function
operation
(
cm
f
)
{
return
function
(
)
{
if
(
cm
.
curOp
)
return
f
.
apply
(
cm
arguments
)
;
startOperation
(
cm
)
;
try
{
return
f
.
apply
(
cm
arguments
)
;
}
finally
{
endOperation
(
cm
)
;
}
}
;
}
function
methodOp
(
f
)
{
return
function
(
)
{
if
(
this
.
curOp
)
return
f
.
apply
(
this
arguments
)
;
startOperation
(
this
)
;
try
{
return
f
.
apply
(
this
arguments
)
;
}
finally
{
endOperation
(
this
)
;
}
}
;
}
function
docMethodOp
(
f
)
{
return
function
(
)
{
var
cm
=
this
.
cm
;
if
(
!
cm
|
|
cm
.
curOp
)
return
f
.
apply
(
this
arguments
)
;
startOperation
(
cm
)
;
try
{
return
f
.
apply
(
this
arguments
)
;
}
finally
{
endOperation
(
cm
)
;
}
}
;
}
function
LineView
(
doc
line
lineN
)
{
this
.
line
=
line
;
this
.
rest
=
visualLineContinued
(
line
)
;
this
.
size
=
this
.
rest
?
lineNo
(
lst
(
this
.
rest
)
)
-
lineN
+
1
:
1
;
this
.
node
=
this
.
text
=
null
;
this
.
hidden
=
lineIsHidden
(
doc
line
)
;
}
function
buildViewArray
(
cm
from
to
)
{
var
array
=
[
]
nextPos
;
for
(
var
pos
=
from
;
pos
<
to
;
pos
=
nextPos
)
{
var
view
=
new
LineView
(
cm
.
doc
getLine
(
cm
.
doc
pos
)
pos
)
;
nextPos
=
pos
+
view
.
size
;
array
.
push
(
view
)
;
}
return
array
;
}
function
regChange
(
cm
from
to
lendiff
)
{
if
(
from
=
=
null
)
from
=
cm
.
doc
.
first
;
if
(
to
=
=
null
)
to
=
cm
.
doc
.
first
+
cm
.
doc
.
size
;
if
(
!
lendiff
)
lendiff
=
0
;
var
display
=
cm
.
display
;
if
(
lendiff
&
&
to
<
display
.
viewTo
&
&
(
display
.
updateLineNumbers
=
=
null
|
|
display
.
updateLineNumbers
>
from
)
)
display
.
updateLineNumbers
=
from
;
cm
.
curOp
.
viewChanged
=
true
;
if
(
from
>
=
display
.
viewTo
)
{
if
(
sawCollapsedSpans
&
&
visualLineNo
(
cm
.
doc
from
)
<
display
.
viewTo
)
resetView
(
cm
)
;
}
else
if
(
to
<
=
display
.
viewFrom
)
{
if
(
sawCollapsedSpans
&
&
visualLineEndNo
(
cm
.
doc
to
+
lendiff
)
>
display
.
viewFrom
)
{
resetView
(
cm
)
;
}
else
{
display
.
viewFrom
+
=
lendiff
;
display
.
viewTo
+
=
lendiff
;
}
}
else
if
(
from
<
=
display
.
viewFrom
&
&
to
>
=
display
.
viewTo
)
{
resetView
(
cm
)
;
}
else
if
(
from
<
=
display
.
viewFrom
)
{
var
cut
=
viewCuttingPoint
(
cm
to
to
+
lendiff
1
)
;
if
(
cut
)
{
display
.
view
=
display
.
view
.
slice
(
cut
.
index
)
;
display
.
viewFrom
=
cut
.
lineN
;
display
.
viewTo
+
=
lendiff
;
}
else
{
resetView
(
cm
)
;
}
}
else
if
(
to
>
=
display
.
viewTo
)
{
var
cut
=
viewCuttingPoint
(
cm
from
from
-
1
)
;
if
(
cut
)
{
display
.
view
=
display
.
view
.
slice
(
0
cut
.
index
)
;
display
.
viewTo
=
cut
.
lineN
;
}
else
{
resetView
(
cm
)
;
}
}
else
{
var
cutTop
=
viewCuttingPoint
(
cm
from
from
-
1
)
;
var
cutBot
=
viewCuttingPoint
(
cm
to
to
+
lendiff
1
)
;
if
(
cutTop
&
&
cutBot
)
{
display
.
view
=
display
.
view
.
slice
(
0
cutTop
.
index
)
.
concat
(
buildViewArray
(
cm
cutTop
.
lineN
cutBot
.
lineN
)
)
.
concat
(
display
.
view
.
slice
(
cutBot
.
index
)
)
;
display
.
viewTo
+
=
lendiff
;
}
else
{
resetView
(
cm
)
;
}
}
var
ext
=
display
.
externalMeasured
;
if
(
ext
)
{
if
(
to
<
ext
.
lineN
)
ext
.
lineN
+
=
lendiff
;
else
if
(
from
<
ext
.
lineN
+
ext
.
size
)
display
.
externalMeasured
=
null
;
}
}
function
regLineChange
(
cm
line
type
)
{
cm
.
curOp
.
viewChanged
=
true
;
var
display
=
cm
.
display
ext
=
cm
.
display
.
externalMeasured
;
if
(
ext
&
&
line
>
=
ext
.
lineN
&
&
line
<
ext
.
lineN
+
ext
.
size
)
display
.
externalMeasured
=
null
;
if
(
line
<
display
.
viewFrom
|
|
line
>
=
display
.
viewTo
)
return
;
var
lineView
=
display
.
view
[
findViewIndex
(
cm
line
)
]
;
if
(
lineView
.
node
=
=
null
)
return
;
var
arr
=
lineView
.
changes
|
|
(
lineView
.
changes
=
[
]
)
;
if
(
indexOf
(
arr
type
)
=
=
-
1
)
arr
.
push
(
type
)
;
}
function
resetView
(
cm
)
{
cm
.
display
.
viewFrom
=
cm
.
display
.
viewTo
=
cm
.
doc
.
first
;
cm
.
display
.
view
=
[
]
;
cm
.
display
.
viewOffset
=
0
;
}
function
findViewIndex
(
cm
n
)
{
if
(
n
>
=
cm
.
display
.
viewTo
)
return
null
;
n
-
=
cm
.
display
.
viewFrom
;
if
(
n
<
0
)
return
null
;
var
view
=
cm
.
display
.
view
;
for
(
var
i
=
0
;
i
<
view
.
length
;
i
+
+
)
{
n
-
=
view
[
i
]
.
size
;
if
(
n
<
0
)
return
i
;
}
}
function
viewCuttingPoint
(
cm
oldN
newN
dir
)
{
var
index
=
findViewIndex
(
cm
oldN
)
diff
view
=
cm
.
display
.
view
;
if
(
!
sawCollapsedSpans
|
|
newN
=
=
cm
.
doc
.
first
+
cm
.
doc
.
size
)
return
{
index
:
index
lineN
:
newN
}
;
for
(
var
i
=
0
n
=
cm
.
display
.
viewFrom
;
i
<
index
;
i
+
+
)
n
+
=
view
[
i
]
.
size
;
if
(
n
!
=
oldN
)
{
if
(
dir
>
0
)
{
if
(
index
=
=
view
.
length
-
1
)
return
null
;
diff
=
(
n
+
view
[
index
]
.
size
)
-
oldN
;
index
+
+
;
}
else
{
diff
=
n
-
oldN
;
}
oldN
+
=
diff
;
newN
+
=
diff
;
}
while
(
visualLineNo
(
cm
.
doc
newN
)
!
=
newN
)
{
if
(
index
=
=
(
dir
<
0
?
0
:
view
.
length
-
1
)
)
return
null
;
newN
+
=
dir
*
view
[
index
-
(
dir
<
0
?
1
:
0
)
]
.
size
;
index
+
=
dir
;
}
return
{
index
:
index
lineN
:
newN
}
;
}
function
adjustView
(
cm
from
to
)
{
var
display
=
cm
.
display
view
=
display
.
view
;
if
(
view
.
length
=
=
0
|
|
from
>
=
display
.
viewTo
|
|
to
<
=
display
.
viewFrom
)
{
display
.
view
=
buildViewArray
(
cm
from
to
)
;
display
.
viewFrom
=
from
;
}
else
{
if
(
display
.
viewFrom
>
from
)
display
.
view
=
buildViewArray
(
cm
from
display
.
viewFrom
)
.
concat
(
display
.
view
)
;
else
if
(
display
.
viewFrom
<
from
)
display
.
view
=
display
.
view
.
slice
(
findViewIndex
(
cm
from
)
)
;
display
.
viewFrom
=
from
;
if
(
display
.
viewTo
<
to
)
display
.
view
=
display
.
view
.
concat
(
buildViewArray
(
cm
display
.
viewTo
to
)
)
;
else
if
(
display
.
viewTo
>
to
)
display
.
view
=
display
.
view
.
slice
(
0
findViewIndex
(
cm
to
)
)
;
}
display
.
viewTo
=
to
;
}
function
countDirtyView
(
cm
)
{
var
view
=
cm
.
display
.
view
dirty
=
0
;
for
(
var
i
=
0
;
i
<
view
.
length
;
i
+
+
)
{
var
lineView
=
view
[
i
]
;
if
(
!
lineView
.
hidden
&
&
(
!
lineView
.
node
|
|
lineView
.
changes
)
)
+
+
dirty
;
}
return
dirty
;
}
function
registerEventHandlers
(
cm
)
{
var
d
=
cm
.
display
;
on
(
d
.
scroller
"
mousedown
"
operation
(
cm
onMouseDown
)
)
;
if
(
ie
&
&
ie_version
<
11
)
on
(
d
.
scroller
"
dblclick
"
operation
(
cm
function
(
e
)
{
if
(
signalDOMEvent
(
cm
e
)
)
return
;
var
pos
=
posFromMouse
(
cm
e
)
;
if
(
!
pos
|
|
clickInGutter
(
cm
e
)
|
|
eventInWidget
(
cm
.
display
e
)
)
return
;
e_preventDefault
(
e
)
;
var
word
=
cm
.
findWordAt
(
pos
)
;
extendSelection
(
cm
.
doc
word
.
anchor
word
.
head
)
;
}
)
)
;
else
on
(
d
.
scroller
"
dblclick
"
function
(
e
)
{
signalDOMEvent
(
cm
e
)
|
|
e_preventDefault
(
e
)
;
}
)
;
if
(
!
captureRightClick
)
on
(
d
.
scroller
"
contextmenu
"
function
(
e
)
{
onContextMenu
(
cm
e
)
;
}
)
;
var
touchFinished
prevTouch
=
{
end
:
0
}
;
function
finishTouch
(
)
{
if
(
d
.
activeTouch
)
{
touchFinished
=
setTimeout
(
function
(
)
{
d
.
activeTouch
=
null
;
}
1000
)
;
prevTouch
=
d
.
activeTouch
;
prevTouch
.
end
=
+
new
Date
;
}
}
;
function
isMouseLikeTouchEvent
(
e
)
{
if
(
e
.
touches
.
length
!
=
1
)
return
false
;
var
touch
=
e
.
touches
[
0
]
;
return
touch
.
radiusX
<
=
1
&
&
touch
.
radiusY
<
=
1
;
}
function
farAway
(
touch
other
)
{
if
(
other
.
left
=
=
null
)
return
true
;
var
dx
=
other
.
left
-
touch
.
left
dy
=
other
.
top
-
touch
.
top
;
return
dx
*
dx
+
dy
*
dy
>
20
*
20
;
}
on
(
d
.
scroller
"
touchstart
"
function
(
e
)
{
if
(
!
signalDOMEvent
(
cm
e
)
&
&
!
isMouseLikeTouchEvent
(
e
)
)
{
clearTimeout
(
touchFinished
)
;
var
now
=
+
new
Date
;
d
.
activeTouch
=
{
start
:
now
moved
:
false
prev
:
now
-
prevTouch
.
end
<
=
300
?
prevTouch
:
null
}
;
if
(
e
.
touches
.
length
=
=
1
)
{
d
.
activeTouch
.
left
=
e
.
touches
[
0
]
.
pageX
;
d
.
activeTouch
.
top
=
e
.
touches
[
0
]
.
pageY
;
}
}
}
)
;
on
(
d
.
scroller
"
touchmove
"
function
(
)
{
if
(
d
.
activeTouch
)
d
.
activeTouch
.
moved
=
true
;
}
)
;
on
(
d
.
scroller
"
touchend
"
function
(
e
)
{
var
touch
=
d
.
activeTouch
;
if
(
touch
&
&
!
eventInWidget
(
d
e
)
&
&
touch
.
left
!
=
null
&
&
!
touch
.
moved
&
&
new
Date
-
touch
.
start
<
300
)
{
var
pos
=
cm
.
coordsChar
(
d
.
activeTouch
"
page
"
)
range
;
if
(
!
touch
.
prev
|
|
farAway
(
touch
touch
.
prev
)
)
range
=
new
Range
(
pos
pos
)
;
else
if
(
!
touch
.
prev
.
prev
|
|
farAway
(
touch
touch
.
prev
.
prev
)
)
range
=
cm
.
findWordAt
(
pos
)
;
else
range
=
new
Range
(
Pos
(
pos
.
line
0
)
clipPos
(
cm
.
doc
Pos
(
pos
.
line
+
1
0
)
)
)
;
cm
.
setSelection
(
range
.
anchor
range
.
head
)
;
cm
.
focus
(
)
;
e_preventDefault
(
e
)
;
}
finishTouch
(
)
;
}
)
;
on
(
d
.
scroller
"
touchcancel
"
finishTouch
)
;
on
(
d
.
scroller
"
scroll
"
function
(
)
{
if
(
d
.
scroller
.
clientHeight
)
{
setScrollTop
(
cm
d
.
scroller
.
scrollTop
)
;
setScrollLeft
(
cm
d
.
scroller
.
scrollLeft
true
)
;
signal
(
cm
"
scroll
"
cm
)
;
}
}
)
;
on
(
d
.
scroller
"
mousewheel
"
function
(
e
)
{
onScrollWheel
(
cm
e
)
;
}
)
;
on
(
d
.
scroller
"
DOMMouseScroll
"
function
(
e
)
{
onScrollWheel
(
cm
e
)
;
}
)
;
on
(
d
.
wrapper
"
scroll
"
function
(
)
{
d
.
wrapper
.
scrollTop
=
d
.
wrapper
.
scrollLeft
=
0
;
}
)
;
d
.
dragFunctions
=
{
enter
:
function
(
e
)
{
if
(
!
signalDOMEvent
(
cm
e
)
)
e_stop
(
e
)
;
}
over
:
function
(
e
)
{
if
(
!
signalDOMEvent
(
cm
e
)
)
{
onDragOver
(
cm
e
)
;
e_stop
(
e
)
;
}
}
start
:
function
(
e
)
{
onDragStart
(
cm
e
)
;
}
drop
:
operation
(
cm
onDrop
)
leave
:
function
(
e
)
{
if
(
!
signalDOMEvent
(
cm
e
)
)
{
clearDragCursor
(
cm
)
;
}
}
}
;
var
inp
=
d
.
input
.
getField
(
)
;
on
(
inp
"
keyup
"
function
(
e
)
{
onKeyUp
.
call
(
cm
e
)
;
}
)
;
on
(
inp
"
keydown
"
operation
(
cm
onKeyDown
)
)
;
on
(
inp
"
keypress
"
operation
(
cm
onKeyPress
)
)
;
on
(
inp
"
focus
"
bind
(
onFocus
cm
)
)
;
on
(
inp
"
blur
"
bind
(
onBlur
cm
)
)
;
}
function
dragDropChanged
(
cm
value
old
)
{
var
wasOn
=
old
&
&
old
!
=
CodeMirror
.
Init
;
if
(
!
value
!
=
!
wasOn
)
{
var
funcs
=
cm
.
display
.
dragFunctions
;
var
toggle
=
value
?
on
:
off
;
toggle
(
cm
.
display
.
scroller
"
dragstart
"
funcs
.
start
)
;
toggle
(
cm
.
display
.
scroller
"
dragenter
"
funcs
.
enter
)
;
toggle
(
cm
.
display
.
scroller
"
dragover
"
funcs
.
over
)
;
toggle
(
cm
.
display
.
scroller
"
dragleave
"
funcs
.
leave
)
;
toggle
(
cm
.
display
.
scroller
"
drop
"
funcs
.
drop
)
;
}
}
function
onResize
(
cm
)
{
var
d
=
cm
.
display
;
if
(
d
.
lastWrapHeight
=
=
d
.
wrapper
.
clientHeight
&
&
d
.
lastWrapWidth
=
=
d
.
wrapper
.
clientWidth
)
return
;
d
.
cachedCharWidth
=
d
.
cachedTextHeight
=
d
.
cachedPaddingH
=
null
;
d
.
scrollbarsClipped
=
false
;
cm
.
setSize
(
)
;
}
function
eventInWidget
(
display
e
)
{
for
(
var
n
=
e_target
(
e
)
;
n
!
=
display
.
wrapper
;
n
=
n
.
parentNode
)
{
if
(
!
n
|
|
(
n
.
nodeType
=
=
1
&
&
n
.
getAttribute
(
"
cm
-
ignore
-
events
"
)
=
=
"
true
"
)
|
|
(
n
.
parentNode
=
=
display
.
sizer
&
&
n
!
=
display
.
mover
)
)
return
true
;
}
}
function
posFromMouse
(
cm
e
liberal
forRect
)
{
var
display
=
cm
.
display
;
if
(
!
liberal
&
&
e_target
(
e
)
.
getAttribute
(
"
cm
-
not
-
content
"
)
=
=
"
true
"
)
return
null
;
var
x
y
space
=
display
.
lineSpace
.
getBoundingClientRect
(
)
;
try
{
x
=
e
.
clientX
-
space
.
left
;
y
=
e
.
clientY
-
space
.
top
;
}
catch
(
e
)
{
return
null
;
}
var
coords
=
coordsChar
(
cm
x
y
)
line
;
if
(
forRect
&
&
coords
.
xRel
=
=
1
&
&
(
line
=
getLine
(
cm
.
doc
coords
.
line
)
.
text
)
.
length
=
=
coords
.
ch
)
{
var
colDiff
=
countColumn
(
line
line
.
length
cm
.
options
.
tabSize
)
-
line
.
length
;
coords
=
Pos
(
coords
.
line
Math
.
max
(
0
Math
.
round
(
(
x
-
paddingH
(
cm
.
display
)
.
left
)
/
charWidth
(
cm
.
display
)
)
-
colDiff
)
)
;
}
return
coords
;
}
function
onMouseDown
(
e
)
{
var
cm
=
this
display
=
cm
.
display
;
if
(
signalDOMEvent
(
cm
e
)
|
|
display
.
activeTouch
&
&
display
.
input
.
supportsTouch
(
)
)
return
;
display
.
shift
=
e
.
shiftKey
;
if
(
eventInWidget
(
display
e
)
)
{
if
(
!
webkit
)
{
display
.
scroller
.
draggable
=
false
;
setTimeout
(
function
(
)
{
display
.
scroller
.
draggable
=
true
;
}
100
)
;
}
return
;
}
if
(
clickInGutter
(
cm
e
)
)
return
;
var
start
=
posFromMouse
(
cm
e
)
;
window
.
focus
(
)
;
switch
(
e_button
(
e
)
)
{
case
1
:
if
(
cm
.
state
.
selectingText
)
cm
.
state
.
selectingText
(
e
)
;
else
if
(
start
)
leftButtonDown
(
cm
e
start
)
;
else
if
(
e_target
(
e
)
=
=
display
.
scroller
)
e_preventDefault
(
e
)
;
break
;
case
2
:
if
(
webkit
)
cm
.
state
.
lastMiddleDown
=
+
new
Date
;
if
(
start
)
extendSelection
(
cm
.
doc
start
)
;
setTimeout
(
function
(
)
{
display
.
input
.
focus
(
)
;
}
20
)
;
e_preventDefault
(
e
)
;
break
;
case
3
:
if
(
captureRightClick
)
onContextMenu
(
cm
e
)
;
else
delayBlurEvent
(
cm
)
;
break
;
}
}
var
lastClick
lastDoubleClick
;
function
leftButtonDown
(
cm
e
start
)
{
if
(
ie
)
setTimeout
(
bind
(
ensureFocus
cm
)
0
)
;
else
cm
.
curOp
.
focus
=
activeElt
(
)
;
var
now
=
+
new
Date
type
;
if
(
lastDoubleClick
&
&
lastDoubleClick
.
time
>
now
-
400
&
&
cmp
(
lastDoubleClick
.
pos
start
)
=
=
0
)
{
type
=
"
triple
"
;
}
else
if
(
lastClick
&
&
lastClick
.
time
>
now
-
400
&
&
cmp
(
lastClick
.
pos
start
)
=
=
0
)
{
type
=
"
double
"
;
lastDoubleClick
=
{
time
:
now
pos
:
start
}
;
}
else
{
type
=
"
single
"
;
lastClick
=
{
time
:
now
pos
:
start
}
;
}
var
sel
=
cm
.
doc
.
sel
modifier
=
mac
?
e
.
metaKey
:
e
.
ctrlKey
contained
;
if
(
cm
.
options
.
dragDrop
&
&
dragAndDrop
&
&
!
cm
.
isReadOnly
(
)
&
&
type
=
=
"
single
"
&
&
(
contained
=
sel
.
contains
(
start
)
)
>
-
1
&
&
(
cmp
(
(
contained
=
sel
.
ranges
[
contained
]
)
.
from
(
)
start
)
<
0
|
|
start
.
xRel
>
0
)
&
&
(
cmp
(
contained
.
to
(
)
start
)
>
0
|
|
start
.
xRel
<
0
)
)
leftButtonStartDrag
(
cm
e
start
modifier
)
;
else
leftButtonSelect
(
cm
e
start
type
modifier
)
;
}
function
leftButtonStartDrag
(
cm
e
start
modifier
)
{
var
display
=
cm
.
display
startTime
=
+
new
Date
;
var
dragEnd
=
operation
(
cm
function
(
e2
)
{
if
(
webkit
)
display
.
scroller
.
draggable
=
false
;
cm
.
state
.
draggingText
=
false
;
off
(
document
"
mouseup
"
dragEnd
)
;
off
(
display
.
scroller
"
drop
"
dragEnd
)
;
if
(
Math
.
abs
(
e
.
clientX
-
e2
.
clientX
)
+
Math
.
abs
(
e
.
clientY
-
e2
.
clientY
)
<
10
)
{
e_preventDefault
(
e2
)
;
if
(
!
modifier
&
&
+
new
Date
-
200
<
startTime
)
extendSelection
(
cm
.
doc
start
)
;
if
(
webkit
|
|
ie
&
&
ie_version
=
=
9
)
setTimeout
(
function
(
)
{
document
.
body
.
focus
(
)
;
display
.
input
.
focus
(
)
;
}
20
)
;
else
display
.
input
.
focus
(
)
;
}
}
)
;
if
(
webkit
)
display
.
scroller
.
draggable
=
true
;
cm
.
state
.
draggingText
=
dragEnd
;
dragEnd
.
copy
=
mac
?
e
.
altKey
:
e
.
ctrlKey
if
(
display
.
scroller
.
dragDrop
)
display
.
scroller
.
dragDrop
(
)
;
on
(
document
"
mouseup
"
dragEnd
)
;
on
(
display
.
scroller
"
drop
"
dragEnd
)
;
}
function
leftButtonSelect
(
cm
e
start
type
addNew
)
{
var
display
=
cm
.
display
doc
=
cm
.
doc
;
e_preventDefault
(
e
)
;
var
ourRange
ourIndex
startSel
=
doc
.
sel
ranges
=
startSel
.
ranges
;
if
(
addNew
&
&
!
e
.
shiftKey
)
{
ourIndex
=
doc
.
sel
.
contains
(
start
)
;
if
(
ourIndex
>
-
1
)
ourRange
=
ranges
[
ourIndex
]
;
else
ourRange
=
new
Range
(
start
start
)
;
}
else
{
ourRange
=
doc
.
sel
.
primary
(
)
;
ourIndex
=
doc
.
sel
.
primIndex
;
}
if
(
chromeOS
?
e
.
shiftKey
&
&
e
.
metaKey
:
e
.
altKey
)
{
type
=
"
rect
"
;
if
(
!
addNew
)
ourRange
=
new
Range
(
start
start
)
;
start
=
posFromMouse
(
cm
e
true
true
)
;
ourIndex
=
-
1
;
}
else
if
(
type
=
=
"
double
"
)
{
var
word
=
cm
.
findWordAt
(
start
)
;
if
(
cm
.
display
.
shift
|
|
doc
.
extend
)
ourRange
=
extendRange
(
doc
ourRange
word
.
anchor
word
.
head
)
;
else
ourRange
=
word
;
}
else
if
(
type
=
=
"
triple
"
)
{
var
line
=
new
Range
(
Pos
(
start
.
line
0
)
clipPos
(
doc
Pos
(
start
.
line
+
1
0
)
)
)
;
if
(
cm
.
display
.
shift
|
|
doc
.
extend
)
ourRange
=
extendRange
(
doc
ourRange
line
.
anchor
line
.
head
)
;
else
ourRange
=
line
;
}
else
{
ourRange
=
extendRange
(
doc
ourRange
start
)
;
}
if
(
!
addNew
)
{
ourIndex
=
0
;
setSelection
(
doc
new
Selection
(
[
ourRange
]
0
)
sel_mouse
)
;
startSel
=
doc
.
sel
;
}
else
if
(
ourIndex
=
=
-
1
)
{
ourIndex
=
ranges
.
length
;
setSelection
(
doc
normalizeSelection
(
ranges
.
concat
(
[
ourRange
]
)
ourIndex
)
{
scroll
:
false
origin
:
"
*
mouse
"
}
)
;
}
else
if
(
ranges
.
length
>
1
&
&
ranges
[
ourIndex
]
.
empty
(
)
&
&
type
=
=
"
single
"
&
&
!
e
.
shiftKey
)
{
setSelection
(
doc
normalizeSelection
(
ranges
.
slice
(
0
ourIndex
)
.
concat
(
ranges
.
slice
(
ourIndex
+
1
)
)
0
)
{
scroll
:
false
origin
:
"
*
mouse
"
}
)
;
startSel
=
doc
.
sel
;
}
else
{
replaceOneSelection
(
doc
ourIndex
ourRange
sel_mouse
)
;
}
var
lastPos
=
start
;
function
extendTo
(
pos
)
{
if
(
cmp
(
lastPos
pos
)
=
=
0
)
return
;
lastPos
=
pos
;
if
(
type
=
=
"
rect
"
)
{
var
ranges
=
[
]
tabSize
=
cm
.
options
.
tabSize
;
var
startCol
=
countColumn
(
getLine
(
doc
start
.
line
)
.
text
start
.
ch
tabSize
)
;
var
posCol
=
countColumn
(
getLine
(
doc
pos
.
line
)
.
text
pos
.
ch
tabSize
)
;
var
left
=
Math
.
min
(
startCol
posCol
)
right
=
Math
.
max
(
startCol
posCol
)
;
for
(
var
line
=
Math
.
min
(
start
.
line
pos
.
line
)
end
=
Math
.
min
(
cm
.
lastLine
(
)
Math
.
max
(
start
.
line
pos
.
line
)
)
;
line
<
=
end
;
line
+
+
)
{
var
text
=
getLine
(
doc
line
)
.
text
leftPos
=
findColumn
(
text
left
tabSize
)
;
if
(
left
=
=
right
)
ranges
.
push
(
new
Range
(
Pos
(
line
leftPos
)
Pos
(
line
leftPos
)
)
)
;
else
if
(
text
.
length
>
leftPos
)
ranges
.
push
(
new
Range
(
Pos
(
line
leftPos
)
Pos
(
line
findColumn
(
text
right
tabSize
)
)
)
)
;
}
if
(
!
ranges
.
length
)
ranges
.
push
(
new
Range
(
start
start
)
)
;
setSelection
(
doc
normalizeSelection
(
startSel
.
ranges
.
slice
(
0
ourIndex
)
.
concat
(
ranges
)
ourIndex
)
{
origin
:
"
*
mouse
"
scroll
:
false
}
)
;
cm
.
scrollIntoView
(
pos
)
;
}
else
{
var
oldRange
=
ourRange
;
var
anchor
=
oldRange
.
anchor
head
=
pos
;
if
(
type
!
=
"
single
"
)
{
if
(
type
=
=
"
double
"
)
var
range
=
cm
.
findWordAt
(
pos
)
;
else
var
range
=
new
Range
(
Pos
(
pos
.
line
0
)
clipPos
(
doc
Pos
(
pos
.
line
+
1
0
)
)
)
;
if
(
cmp
(
range
.
anchor
anchor
)
>
0
)
{
head
=
range
.
head
;
anchor
=
minPos
(
oldRange
.
from
(
)
range
.
anchor
)
;
}
else
{
head
=
range
.
anchor
;
anchor
=
maxPos
(
oldRange
.
to
(
)
range
.
head
)
;
}
}
var
ranges
=
startSel
.
ranges
.
slice
(
0
)
;
ranges
[
ourIndex
]
=
new
Range
(
clipPos
(
doc
anchor
)
head
)
;
setSelection
(
doc
normalizeSelection
(
ranges
ourIndex
)
sel_mouse
)
;
}
}
var
editorSize
=
display
.
wrapper
.
getBoundingClientRect
(
)
;
var
counter
=
0
;
function
extend
(
e
)
{
var
curCount
=
+
+
counter
;
var
cur
=
posFromMouse
(
cm
e
true
type
=
=
"
rect
"
)
;
if
(
!
cur
)
return
;
if
(
cmp
(
cur
lastPos
)
!
=
0
)
{
cm
.
curOp
.
focus
=
activeElt
(
)
;
extendTo
(
cur
)
;
var
visible
=
visibleLines
(
display
doc
)
;
if
(
cur
.
line
>
=
visible
.
to
|
|
cur
.
line
<
visible
.
from
)
setTimeout
(
operation
(
cm
function
(
)
{
if
(
counter
=
=
curCount
)
extend
(
e
)
;
}
)
150
)
;
}
else
{
var
outside
=
e
.
clientY
<
editorSize
.
top
?
-
20
:
e
.
clientY
>
editorSize
.
bottom
?
20
:
0
;
if
(
outside
)
setTimeout
(
operation
(
cm
function
(
)
{
if
(
counter
!
=
curCount
)
return
;
display
.
scroller
.
scrollTop
+
=
outside
;
extend
(
e
)
;
}
)
50
)
;
}
}
function
done
(
e
)
{
cm
.
state
.
selectingText
=
false
;
counter
=
Infinity
;
e_preventDefault
(
e
)
;
display
.
input
.
focus
(
)
;
off
(
document
"
mousemove
"
move
)
;
off
(
document
"
mouseup
"
up
)
;
doc
.
history
.
lastSelOrigin
=
null
;
}
var
move
=
operation
(
cm
function
(
e
)
{
if
(
!
e_button
(
e
)
)
done
(
e
)
;
else
extend
(
e
)
;
}
)
;
var
up
=
operation
(
cm
done
)
;
cm
.
state
.
selectingText
=
up
;
on
(
document
"
mousemove
"
move
)
;
on
(
document
"
mouseup
"
up
)
;
}
function
gutterEvent
(
cm
e
type
prevent
)
{
try
{
var
mX
=
e
.
clientX
mY
=
e
.
clientY
;
}
catch
(
e
)
{
return
false
;
}
if
(
mX
>
=
Math
.
floor
(
cm
.
display
.
gutters
.
getBoundingClientRect
(
)
.
right
)
)
return
false
;
if
(
prevent
)
e_preventDefault
(
e
)
;
var
display
=
cm
.
display
;
var
lineBox
=
display
.
lineDiv
.
getBoundingClientRect
(
)
;
if
(
mY
>
lineBox
.
bottom
|
|
!
hasHandler
(
cm
type
)
)
return
e_defaultPrevented
(
e
)
;
mY
-
=
lineBox
.
top
-
display
.
viewOffset
;
for
(
var
i
=
0
;
i
<
cm
.
options
.
gutters
.
length
;
+
+
i
)
{
var
g
=
display
.
gutters
.
childNodes
[
i
]
;
if
(
g
&
&
g
.
getBoundingClientRect
(
)
.
right
>
=
mX
)
{
var
line
=
lineAtHeight
(
cm
.
doc
mY
)
;
var
gutter
=
cm
.
options
.
gutters
[
i
]
;
signal
(
cm
type
cm
line
gutter
e
)
;
return
e_defaultPrevented
(
e
)
;
}
}
}
function
clickInGutter
(
cm
e
)
{
return
gutterEvent
(
cm
e
"
gutterClick
"
true
)
;
}
var
lastDrop
=
0
;
function
onDrop
(
e
)
{
var
cm
=
this
;
clearDragCursor
(
cm
)
;
if
(
signalDOMEvent
(
cm
e
)
|
|
eventInWidget
(
cm
.
display
e
)
)
return
;
e_preventDefault
(
e
)
;
if
(
ie
)
lastDrop
=
+
new
Date
;
var
pos
=
posFromMouse
(
cm
e
true
)
files
=
e
.
dataTransfer
.
files
;
if
(
!
pos
|
|
cm
.
isReadOnly
(
)
)
return
;
if
(
files
&
&
files
.
length
&
&
window
.
FileReader
&
&
window
.
File
)
{
var
n
=
files
.
length
text
=
Array
(
n
)
read
=
0
;
var
loadFile
=
function
(
file
i
)
{
if
(
cm
.
options
.
allowDropFileTypes
&
&
indexOf
(
cm
.
options
.
allowDropFileTypes
file
.
type
)
=
=
-
1
)
return
;
var
reader
=
new
FileReader
;
reader
.
onload
=
operation
(
cm
function
(
)
{
var
content
=
reader
.
result
;
if
(
/
[
\
x00
-
\
x08
\
x0e
-
\
x1f
]
{
2
}
/
.
test
(
content
)
)
content
=
"
"
;
text
[
i
]
=
content
;
if
(
+
+
read
=
=
n
)
{
pos
=
clipPos
(
cm
.
doc
pos
)
;
var
change
=
{
from
:
pos
to
:
pos
text
:
cm
.
doc
.
splitLines
(
text
.
join
(
cm
.
doc
.
lineSeparator
(
)
)
)
origin
:
"
paste
"
}
;
makeChange
(
cm
.
doc
change
)
;
setSelectionReplaceHistory
(
cm
.
doc
simpleSelection
(
pos
changeEnd
(
change
)
)
)
;
}
}
)
;
reader
.
readAsText
(
file
)
;
}
;
for
(
var
i
=
0
;
i
<
n
;
+
+
i
)
loadFile
(
files
[
i
]
i
)
;
}
else
{
if
(
cm
.
state
.
draggingText
&
&
cm
.
doc
.
sel
.
contains
(
pos
)
>
-
1
)
{
cm
.
state
.
draggingText
(
e
)
;
setTimeout
(
function
(
)
{
cm
.
display
.
input
.
focus
(
)
;
}
20
)
;
return
;
}
try
{
var
text
=
e
.
dataTransfer
.
getData
(
"
Text
"
)
;
if
(
text
)
{
if
(
cm
.
state
.
draggingText
&
&
!
cm
.
state
.
draggingText
.
copy
)
var
selected
=
cm
.
listSelections
(
)
;
setSelectionNoUndo
(
cm
.
doc
simpleSelection
(
pos
pos
)
)
;
if
(
selected
)
for
(
var
i
=
0
;
i
<
selected
.
length
;
+
+
i
)
replaceRange
(
cm
.
doc
"
"
selected
[
i
]
.
anchor
selected
[
i
]
.
head
"
drag
"
)
;
cm
.
replaceSelection
(
text
"
around
"
"
paste
"
)
;
cm
.
display
.
input
.
focus
(
)
;
}
}
catch
(
e
)
{
}
}
}
function
onDragStart
(
cm
e
)
{
if
(
ie
&
&
(
!
cm
.
state
.
draggingText
|
|
+
new
Date
-
lastDrop
<
100
)
)
{
e_stop
(
e
)
;
return
;
}
if
(
signalDOMEvent
(
cm
e
)
|
|
eventInWidget
(
cm
.
display
e
)
)
return
;
e
.
dataTransfer
.
setData
(
"
Text
"
cm
.
getSelection
(
)
)
;
e
.
dataTransfer
.
effectAllowed
=
"
copyMove
"
if
(
e
.
dataTransfer
.
setDragImage
&
&
!
safari
)
{
var
img
=
elt
(
"
img
"
null
null
"
position
:
fixed
;
left
:
0
;
top
:
0
;
"
)
;
img
.
src
=
"
data
:
image
/
gif
;
base64
R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw
=
=
"
;
if
(
presto
)
{
img
.
width
=
img
.
height
=
1
;
cm
.
display
.
wrapper
.
appendChild
(
img
)
;
img
.
_top
=
img
.
offsetTop
;
}
e
.
dataTransfer
.
setDragImage
(
img
0
0
)
;
if
(
presto
)
img
.
parentNode
.
removeChild
(
img
)
;
}
}
function
onDragOver
(
cm
e
)
{
var
pos
=
posFromMouse
(
cm
e
)
;
if
(
!
pos
)
return
;
var
frag
=
document
.
createDocumentFragment
(
)
;
drawSelectionCursor
(
cm
pos
frag
)
;
if
(
!
cm
.
display
.
dragCursor
)
{
cm
.
display
.
dragCursor
=
elt
(
"
div
"
null
"
CodeMirror
-
cursors
CodeMirror
-
dragcursors
"
)
;
cm
.
display
.
lineSpace
.
insertBefore
(
cm
.
display
.
dragCursor
cm
.
display
.
cursorDiv
)
;
}
removeChildrenAndAdd
(
cm
.
display
.
dragCursor
frag
)
;
}
function
clearDragCursor
(
cm
)
{
if
(
cm
.
display
.
dragCursor
)
{
cm
.
display
.
lineSpace
.
removeChild
(
cm
.
display
.
dragCursor
)
;
cm
.
display
.
dragCursor
=
null
;
}
}
function
setScrollTop
(
cm
val
)
{
if
(
Math
.
abs
(
cm
.
doc
.
scrollTop
-
val
)
<
2
)
return
;
cm
.
doc
.
scrollTop
=
val
;
if
(
!
gecko
)
updateDisplaySimple
(
cm
{
top
:
val
}
)
;
if
(
cm
.
display
.
scroller
.
scrollTop
!
=
val
)
cm
.
display
.
scroller
.
scrollTop
=
val
;
cm
.
display
.
scrollbars
.
setScrollTop
(
val
)
;
if
(
gecko
)
updateDisplaySimple
(
cm
)
;
startWorker
(
cm
100
)
;
}
function
setScrollLeft
(
cm
val
isScroller
)
{
if
(
isScroller
?
val
=
=
cm
.
doc
.
scrollLeft
:
Math
.
abs
(
cm
.
doc
.
scrollLeft
-
val
)
<
2
)
return
;
val
=
Math
.
min
(
val
cm
.
display
.
scroller
.
scrollWidth
-
cm
.
display
.
scroller
.
clientWidth
)
;
cm
.
doc
.
scrollLeft
=
val
;
alignHorizontally
(
cm
)
;
if
(
cm
.
display
.
scroller
.
scrollLeft
!
=
val
)
cm
.
display
.
scroller
.
scrollLeft
=
val
;
cm
.
display
.
scrollbars
.
setScrollLeft
(
val
)
;
}
var
wheelSamples
=
0
wheelPixelsPerUnit
=
null
;
if
(
ie
)
wheelPixelsPerUnit
=
-
.
53
;
else
if
(
gecko
)
wheelPixelsPerUnit
=
15
;
else
if
(
chrome
)
wheelPixelsPerUnit
=
-
.
7
;
else
if
(
safari
)
wheelPixelsPerUnit
=
-
1
/
3
;
var
wheelEventDelta
=
function
(
e
)
{
var
dx
=
e
.
wheelDeltaX
dy
=
e
.
wheelDeltaY
;
if
(
dx
=
=
null
&
&
e
.
detail
&
&
e
.
axis
=
=
e
.
HORIZONTAL_AXIS
)
dx
=
e
.
detail
;
if
(
dy
=
=
null
&
&
e
.
detail
&
&
e
.
axis
=
=
e
.
VERTICAL_AXIS
)
dy
=
e
.
detail
;
else
if
(
dy
=
=
null
)
dy
=
e
.
wheelDelta
;
return
{
x
:
dx
y
:
dy
}
;
}
;
CodeMirror
.
wheelEventPixels
=
function
(
e
)
{
var
delta
=
wheelEventDelta
(
e
)
;
delta
.
x
*
=
wheelPixelsPerUnit
;
delta
.
y
*
=
wheelPixelsPerUnit
;
return
delta
;
}
;
function
onScrollWheel
(
cm
e
)
{
var
delta
=
wheelEventDelta
(
e
)
dx
=
delta
.
x
dy
=
delta
.
y
;
var
display
=
cm
.
display
scroll
=
display
.
scroller
;
var
canScrollX
=
scroll
.
scrollWidth
>
scroll
.
clientWidth
;
var
canScrollY
=
scroll
.
scrollHeight
>
scroll
.
clientHeight
;
if
(
!
(
dx
&
&
canScrollX
|
|
dy
&
&
canScrollY
)
)
return
;
if
(
dy
&
&
mac
&
&
webkit
)
{
outer
:
for
(
var
cur
=
e
.
target
view
=
display
.
view
;
cur
!
=
scroll
;
cur
=
cur
.
parentNode
)
{
for
(
var
i
=
0
;
i
<
view
.
length
;
i
+
+
)
{
if
(
view
[
i
]
.
node
=
=
cur
)
{
cm
.
display
.
currentWheelTarget
=
cur
;
break
outer
;
}
}
}
}
if
(
dx
&
&
!
gecko
&
&
!
presto
&
&
wheelPixelsPerUnit
!
=
null
)
{
if
(
dy
&
&
canScrollY
)
setScrollTop
(
cm
Math
.
max
(
0
Math
.
min
(
scroll
.
scrollTop
+
dy
*
wheelPixelsPerUnit
scroll
.
scrollHeight
-
scroll
.
clientHeight
)
)
)
;
setScrollLeft
(
cm
Math
.
max
(
0
Math
.
min
(
scroll
.
scrollLeft
+
dx
*
wheelPixelsPerUnit
scroll
.
scrollWidth
-
scroll
.
clientWidth
)
)
)
;
if
(
!
dy
|
|
(
dy
&
&
canScrollY
)
)
e_preventDefault
(
e
)
;
display
.
wheelStartX
=
null
;
return
;
}
if
(
dy
&
&
wheelPixelsPerUnit
!
=
null
)
{
var
pixels
=
dy
*
wheelPixelsPerUnit
;
var
top
=
cm
.
doc
.
scrollTop
bot
=
top
+
display
.
wrapper
.
clientHeight
;
if
(
pixels
<
0
)
top
=
Math
.
max
(
0
top
+
pixels
-
50
)
;
else
bot
=
Math
.
min
(
cm
.
doc
.
height
bot
+
pixels
+
50
)
;
updateDisplaySimple
(
cm
{
top
:
top
bottom
:
bot
}
)
;
}
if
(
wheelSamples
<
20
)
{
if
(
display
.
wheelStartX
=
=
null
)
{
display
.
wheelStartX
=
scroll
.
scrollLeft
;
display
.
wheelStartY
=
scroll
.
scrollTop
;
display
.
wheelDX
=
dx
;
display
.
wheelDY
=
dy
;
setTimeout
(
function
(
)
{
if
(
display
.
wheelStartX
=
=
null
)
return
;
var
movedX
=
scroll
.
scrollLeft
-
display
.
wheelStartX
;
var
movedY
=
scroll
.
scrollTop
-
display
.
wheelStartY
;
var
sample
=
(
movedY
&
&
display
.
wheelDY
&
&
movedY
/
display
.
wheelDY
)
|
|
(
movedX
&
&
display
.
wheelDX
&
&
movedX
/
display
.
wheelDX
)
;
display
.
wheelStartX
=
display
.
wheelStartY
=
null
;
if
(
!
sample
)
return
;
wheelPixelsPerUnit
=
(
wheelPixelsPerUnit
*
wheelSamples
+
sample
)
/
(
wheelSamples
+
1
)
;
+
+
wheelSamples
;
}
200
)
;
}
else
{
display
.
wheelDX
+
=
dx
;
display
.
wheelDY
+
=
dy
;
}
}
}
function
doHandleBinding
(
cm
bound
dropShift
)
{
if
(
typeof
bound
=
=
"
string
"
)
{
bound
=
commands
[
bound
]
;
if
(
!
bound
)
return
false
;
}
cm
.
display
.
input
.
ensurePolled
(
)
;
var
prevShift
=
cm
.
display
.
shift
done
=
false
;
try
{
if
(
cm
.
isReadOnly
(
)
)
cm
.
state
.
suppressEdits
=
true
;
if
(
dropShift
)
cm
.
display
.
shift
=
false
;
done
=
bound
(
cm
)
!
=
Pass
;
}
finally
{
cm
.
display
.
shift
=
prevShift
;
cm
.
state
.
suppressEdits
=
false
;
}
return
done
;
}
function
lookupKeyForEditor
(
cm
name
handle
)
{
for
(
var
i
=
0
;
i
<
cm
.
state
.
keyMaps
.
length
;
i
+
+
)
{
var
result
=
lookupKey
(
name
cm
.
state
.
keyMaps
[
i
]
handle
cm
)
;
if
(
result
)
return
result
;
}
return
(
cm
.
options
.
extraKeys
&
&
lookupKey
(
name
cm
.
options
.
extraKeys
handle
cm
)
)
|
|
lookupKey
(
name
cm
.
options
.
keyMap
handle
cm
)
;
}
var
stopSeq
=
new
Delayed
;
function
dispatchKey
(
cm
name
e
handle
)
{
var
seq
=
cm
.
state
.
keySeq
;
if
(
seq
)
{
if
(
isModifierKey
(
name
)
)
return
"
handled
"
;
stopSeq
.
set
(
50
function
(
)
{
if
(
cm
.
state
.
keySeq
=
=
seq
)
{
cm
.
state
.
keySeq
=
null
;
cm
.
display
.
input
.
reset
(
)
;
}
}
)
;
name
=
seq
+
"
"
+
name
;
}
var
result
=
lookupKeyForEditor
(
cm
name
handle
)
;
if
(
result
=
=
"
multi
"
)
cm
.
state
.
keySeq
=
name
;
if
(
result
=
=
"
handled
"
)
signalLater
(
cm
"
keyHandled
"
cm
name
e
)
;
if
(
result
=
=
"
handled
"
|
|
result
=
=
"
multi
"
)
{
e_preventDefault
(
e
)
;
restartBlink
(
cm
)
;
}
if
(
seq
&
&
!
result
&
&
/
\
'
/
.
test
(
name
)
)
{
e_preventDefault
(
e
)
;
return
true
;
}
return
!
!
result
;
}
function
handleKeyBinding
(
cm
e
)
{
var
name
=
keyName
(
e
true
)
;
if
(
!
name
)
return
false
;
if
(
e
.
shiftKey
&
&
!
cm
.
state
.
keySeq
)
{
return
dispatchKey
(
cm
"
Shift
-
"
+
name
e
function
(
b
)
{
return
doHandleBinding
(
cm
b
true
)
;
}
)
|
|
dispatchKey
(
cm
name
e
function
(
b
)
{
if
(
typeof
b
=
=
"
string
"
?
/
^
go
[
A
-
Z
]
/
.
test
(
b
)
:
b
.
motion
)
return
doHandleBinding
(
cm
b
)
;
}
)
;
}
else
{
return
dispatchKey
(
cm
name
e
function
(
b
)
{
return
doHandleBinding
(
cm
b
)
;
}
)
;
}
}
function
handleCharBinding
(
cm
e
ch
)
{
return
dispatchKey
(
cm
"
'
"
+
ch
+
"
'
"
e
function
(
b
)
{
return
doHandleBinding
(
cm
b
true
)
;
}
)
;
}
var
lastStoppedKey
=
null
;
function
onKeyDown
(
e
)
{
var
cm
=
this
;
cm
.
curOp
.
focus
=
activeElt
(
)
;
if
(
signalDOMEvent
(
cm
e
)
)
return
;
if
(
ie
&
&
ie_version
<
11
&
&
e
.
keyCode
=
=
27
)
e
.
returnValue
=
false
;
var
code
=
e
.
keyCode
;
cm
.
display
.
shift
=
code
=
=
16
|
|
e
.
shiftKey
;
var
handled
=
handleKeyBinding
(
cm
e
)
;
if
(
presto
)
{
lastStoppedKey
=
handled
?
code
:
null
;
if
(
!
handled
&
&
code
=
=
88
&
&
!
hasCopyEvent
&
&
(
mac
?
e
.
metaKey
:
e
.
ctrlKey
)
)
cm
.
replaceSelection
(
"
"
null
"
cut
"
)
;
}
if
(
code
=
=
18
&
&
!
/
\
bCodeMirror
-
crosshair
\
b
/
.
test
(
cm
.
display
.
lineDiv
.
className
)
)
showCrossHair
(
cm
)
;
}
function
showCrossHair
(
cm
)
{
var
lineDiv
=
cm
.
display
.
lineDiv
;
addClass
(
lineDiv
"
CodeMirror
-
crosshair
"
)
;
function
up
(
e
)
{
if
(
e
.
keyCode
=
=
18
|
|
!
e
.
altKey
)
{
rmClass
(
lineDiv
"
CodeMirror
-
crosshair
"
)
;
off
(
document
"
keyup
"
up
)
;
off
(
document
"
mouseover
"
up
)
;
}
}
on
(
document
"
keyup
"
up
)
;
on
(
document
"
mouseover
"
up
)
;
}
function
onKeyUp
(
e
)
{
if
(
e
.
keyCode
=
=
16
)
this
.
doc
.
sel
.
shift
=
false
;
signalDOMEvent
(
this
e
)
;
}
function
onKeyPress
(
e
)
{
var
cm
=
this
;
if
(
eventInWidget
(
cm
.
display
e
)
|
|
signalDOMEvent
(
cm
e
)
|
|
e
.
ctrlKey
&
&
!
e
.
altKey
|
|
mac
&
&
e
.
metaKey
)
return
;
var
keyCode
=
e
.
keyCode
charCode
=
e
.
charCode
;
if
(
presto
&
&
keyCode
=
=
lastStoppedKey
)
{
lastStoppedKey
=
null
;
e_preventDefault
(
e
)
;
return
;
}
if
(
(
presto
&
&
(
!
e
.
which
|
|
e
.
which
<
10
)
)
&
&
handleKeyBinding
(
cm
e
)
)
return
;
var
ch
=
String
.
fromCharCode
(
charCode
=
=
null
?
keyCode
:
charCode
)
;
if
(
handleCharBinding
(
cm
e
ch
)
)
return
;
cm
.
display
.
input
.
onKeyPress
(
e
)
;
}
function
delayBlurEvent
(
cm
)
{
cm
.
state
.
delayingBlurEvent
=
true
;
setTimeout
(
function
(
)
{
if
(
cm
.
state
.
delayingBlurEvent
)
{
cm
.
state
.
delayingBlurEvent
=
false
;
onBlur
(
cm
)
;
}
}
100
)
;
}
function
onFocus
(
cm
)
{
if
(
cm
.
state
.
delayingBlurEvent
)
cm
.
state
.
delayingBlurEvent
=
false
;
if
(
cm
.
options
.
readOnly
=
=
"
nocursor
"
)
return
;
if
(
!
cm
.
state
.
focused
)
{
signal
(
cm
"
focus
"
cm
)
;
cm
.
state
.
focused
=
true
;
addClass
(
cm
.
display
.
wrapper
"
CodeMirror
-
focused
"
)
;
if
(
!
cm
.
curOp
&
&
cm
.
display
.
selForContextMenu
!
=
cm
.
doc
.
sel
)
{
cm
.
display
.
input
.
reset
(
)
;
if
(
webkit
)
setTimeout
(
function
(
)
{
cm
.
display
.
input
.
reset
(
true
)
;
}
20
)
;
}
cm
.
display
.
input
.
receivedFocus
(
)
;
}
restartBlink
(
cm
)
;
}
function
onBlur
(
cm
)
{
if
(
cm
.
state
.
delayingBlurEvent
)
return
;
if
(
cm
.
state
.
focused
)
{
signal
(
cm
"
blur
"
cm
)
;
cm
.
state
.
focused
=
false
;
rmClass
(
cm
.
display
.
wrapper
"
CodeMirror
-
focused
"
)
;
}
clearInterval
(
cm
.
display
.
blinker
)
;
setTimeout
(
function
(
)
{
if
(
!
cm
.
state
.
focused
)
cm
.
display
.
shift
=
false
;
}
150
)
;
}
function
onContextMenu
(
cm
e
)
{
if
(
eventInWidget
(
cm
.
display
e
)
|
|
contextMenuInGutter
(
cm
e
)
)
return
;
if
(
signalDOMEvent
(
cm
e
"
contextmenu
"
)
)
return
;
cm
.
display
.
input
.
onContextMenu
(
e
)
;
}
function
contextMenuInGutter
(
cm
e
)
{
if
(
!
hasHandler
(
cm
"
gutterContextMenu
"
)
)
return
false
;
return
gutterEvent
(
cm
e
"
gutterContextMenu
"
false
)
;
}
var
changeEnd
=
CodeMirror
.
changeEnd
=
function
(
change
)
{
if
(
!
change
.
text
)
return
change
.
to
;
return
Pos
(
change
.
from
.
line
+
change
.
text
.
length
-
1
lst
(
change
.
text
)
.
length
+
(
change
.
text
.
length
=
=
1
?
change
.
from
.
ch
:
0
)
)
;
}
;
function
adjustForChange
(
pos
change
)
{
if
(
cmp
(
pos
change
.
from
)
<
0
)
return
pos
;
if
(
cmp
(
pos
change
.
to
)
<
=
0
)
return
changeEnd
(
change
)
;
var
line
=
pos
.
line
+
change
.
text
.
length
-
(
change
.
to
.
line
-
change
.
from
.
line
)
-
1
ch
=
pos
.
ch
;
if
(
pos
.
line
=
=
change
.
to
.
line
)
ch
+
=
changeEnd
(
change
)
.
ch
-
change
.
to
.
ch
;
return
Pos
(
line
ch
)
;
}
function
computeSelAfterChange
(
doc
change
)
{
var
out
=
[
]
;
for
(
var
i
=
0
;
i
<
doc
.
sel
.
ranges
.
length
;
i
+
+
)
{
var
range
=
doc
.
sel
.
ranges
[
i
]
;
out
.
push
(
new
Range
(
adjustForChange
(
range
.
anchor
change
)
adjustForChange
(
range
.
head
change
)
)
)
;
}
return
normalizeSelection
(
out
doc
.
sel
.
primIndex
)
;
}
function
offsetPos
(
pos
old
nw
)
{
if
(
pos
.
line
=
=
old
.
line
)
return
Pos
(
nw
.
line
pos
.
ch
-
old
.
ch
+
nw
.
ch
)
;
else
return
Pos
(
nw
.
line
+
(
pos
.
line
-
old
.
line
)
pos
.
ch
)
;
}
function
computeReplacedSel
(
doc
changes
hint
)
{
var
out
=
[
]
;
var
oldPrev
=
Pos
(
doc
.
first
0
)
newPrev
=
oldPrev
;
for
(
var
i
=
0
;
i
<
changes
.
length
;
i
+
+
)
{
var
change
=
changes
[
i
]
;
var
from
=
offsetPos
(
change
.
from
oldPrev
newPrev
)
;
var
to
=
offsetPos
(
changeEnd
(
change
)
oldPrev
newPrev
)
;
oldPrev
=
change
.
to
;
newPrev
=
to
;
if
(
hint
=
=
"
around
"
)
{
var
range
=
doc
.
sel
.
ranges
[
i
]
inv
=
cmp
(
range
.
head
range
.
anchor
)
<
0
;
out
[
i
]
=
new
Range
(
inv
?
to
:
from
inv
?
from
:
to
)
;
}
else
{
out
[
i
]
=
new
Range
(
from
from
)
;
}
}
return
new
Selection
(
out
doc
.
sel
.
primIndex
)
;
}
function
filterChange
(
doc
change
update
)
{
var
obj
=
{
canceled
:
false
from
:
change
.
from
to
:
change
.
to
text
:
change
.
text
origin
:
change
.
origin
cancel
:
function
(
)
{
this
.
canceled
=
true
;
}
}
;
if
(
update
)
obj
.
update
=
function
(
from
to
text
origin
)
{
if
(
from
)
this
.
from
=
clipPos
(
doc
from
)
;
if
(
to
)
this
.
to
=
clipPos
(
doc
to
)
;
if
(
text
)
this
.
text
=
text
;
if
(
origin
!
=
=
undefined
)
this
.
origin
=
origin
;
}
;
signal
(
doc
"
beforeChange
"
doc
obj
)
;
if
(
doc
.
cm
)
signal
(
doc
.
cm
"
beforeChange
"
doc
.
cm
obj
)
;
if
(
obj
.
canceled
)
return
null
;
return
{
from
:
obj
.
from
to
:
obj
.
to
text
:
obj
.
text
origin
:
obj
.
origin
}
;
}
function
makeChange
(
doc
change
ignoreReadOnly
)
{
if
(
doc
.
cm
)
{
if
(
!
doc
.
cm
.
curOp
)
return
operation
(
doc
.
cm
makeChange
)
(
doc
change
ignoreReadOnly
)
;
if
(
doc
.
cm
.
state
.
suppressEdits
)
return
;
}
if
(
hasHandler
(
doc
"
beforeChange
"
)
|
|
doc
.
cm
&
&
hasHandler
(
doc
.
cm
"
beforeChange
"
)
)
{
change
=
filterChange
(
doc
change
true
)
;
if
(
!
change
)
return
;
}
var
split
=
sawReadOnlySpans
&
&
!
ignoreReadOnly
&
&
removeReadOnlyRanges
(
doc
change
.
from
change
.
to
)
;
if
(
split
)
{
for
(
var
i
=
split
.
length
-
1
;
i
>
=
0
;
-
-
i
)
makeChangeInner
(
doc
{
from
:
split
[
i
]
.
from
to
:
split
[
i
]
.
to
text
:
i
?
[
"
"
]
:
change
.
text
}
)
;
}
else
{
makeChangeInner
(
doc
change
)
;
}
}
function
makeChangeInner
(
doc
change
)
{
if
(
change
.
text
.
length
=
=
1
&
&
change
.
text
[
0
]
=
=
"
"
&
&
cmp
(
change
.
from
change
.
to
)
=
=
0
)
return
;
var
selAfter
=
computeSelAfterChange
(
doc
change
)
;
addChangeToHistory
(
doc
change
selAfter
doc
.
cm
?
doc
.
cm
.
curOp
.
id
:
NaN
)
;
makeChangeSingleDoc
(
doc
change
selAfter
stretchSpansOverChange
(
doc
change
)
)
;
var
rebased
=
[
]
;
linkedDocs
(
doc
function
(
doc
sharedHist
)
{
if
(
!
sharedHist
&
&
indexOf
(
rebased
doc
.
history
)
=
=
-
1
)
{
rebaseHist
(
doc
.
history
change
)
;
rebased
.
push
(
doc
.
history
)
;
}
makeChangeSingleDoc
(
doc
change
null
stretchSpansOverChange
(
doc
change
)
)
;
}
)
;
}
function
makeChangeFromHistory
(
doc
type
allowSelectionOnly
)
{
if
(
doc
.
cm
&
&
doc
.
cm
.
state
.
suppressEdits
)
return
;
var
hist
=
doc
.
history
event
selAfter
=
doc
.
sel
;
var
source
=
type
=
=
"
undo
"
?
hist
.
done
:
hist
.
undone
dest
=
type
=
=
"
undo
"
?
hist
.
undone
:
hist
.
done
;
for
(
var
i
=
0
;
i
<
source
.
length
;
i
+
+
)
{
event
=
source
[
i
]
;
if
(
allowSelectionOnly
?
event
.
ranges
&
&
!
event
.
equals
(
doc
.
sel
)
:
!
event
.
ranges
)
break
;
}
if
(
i
=
=
source
.
length
)
return
;
hist
.
lastOrigin
=
hist
.
lastSelOrigin
=
null
;
for
(
;
;
)
{
event
=
source
.
pop
(
)
;
if
(
event
.
ranges
)
{
pushSelectionToHistory
(
event
dest
)
;
if
(
allowSelectionOnly
&
&
!
event
.
equals
(
doc
.
sel
)
)
{
setSelection
(
doc
event
{
clearRedo
:
false
}
)
;
return
;
}
selAfter
=
event
;
}
else
break
;
}
var
antiChanges
=
[
]
;
pushSelectionToHistory
(
selAfter
dest
)
;
dest
.
push
(
{
changes
:
antiChanges
generation
:
hist
.
generation
}
)
;
hist
.
generation
=
event
.
generation
|
|
+
+
hist
.
maxGeneration
;
var
filter
=
hasHandler
(
doc
"
beforeChange
"
)
|
|
doc
.
cm
&
&
hasHandler
(
doc
.
cm
"
beforeChange
"
)
;
for
(
var
i
=
event
.
changes
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
change
=
event
.
changes
[
i
]
;
change
.
origin
=
type
;
if
(
filter
&
&
!
filterChange
(
doc
change
false
)
)
{
source
.
length
=
0
;
return
;
}
antiChanges
.
push
(
historyChangeFromChange
(
doc
change
)
)
;
var
after
=
i
?
computeSelAfterChange
(
doc
change
)
:
lst
(
source
)
;
makeChangeSingleDoc
(
doc
change
after
mergeOldSpans
(
doc
change
)
)
;
if
(
!
i
&
&
doc
.
cm
)
doc
.
cm
.
scrollIntoView
(
{
from
:
change
.
from
to
:
changeEnd
(
change
)
}
)
;
var
rebased
=
[
]
;
linkedDocs
(
doc
function
(
doc
sharedHist
)
{
if
(
!
sharedHist
&
&
indexOf
(
rebased
doc
.
history
)
=
=
-
1
)
{
rebaseHist
(
doc
.
history
change
)
;
rebased
.
push
(
doc
.
history
)
;
}
makeChangeSingleDoc
(
doc
change
null
mergeOldSpans
(
doc
change
)
)
;
}
)
;
}
}
function
shiftDoc
(
doc
distance
)
{
if
(
distance
=
=
0
)
return
;
doc
.
first
+
=
distance
;
doc
.
sel
=
new
Selection
(
map
(
doc
.
sel
.
ranges
function
(
range
)
{
return
new
Range
(
Pos
(
range
.
anchor
.
line
+
distance
range
.
anchor
.
ch
)
Pos
(
range
.
head
.
line
+
distance
range
.
head
.
ch
)
)
;
}
)
doc
.
sel
.
primIndex
)
;
if
(
doc
.
cm
)
{
regChange
(
doc
.
cm
doc
.
first
doc
.
first
-
distance
distance
)
;
for
(
var
d
=
doc
.
cm
.
display
l
=
d
.
viewFrom
;
l
<
d
.
viewTo
;
l
+
+
)
regLineChange
(
doc
.
cm
l
"
gutter
"
)
;
}
}
function
makeChangeSingleDoc
(
doc
change
selAfter
spans
)
{
if
(
doc
.
cm
&
&
!
doc
.
cm
.
curOp
)
return
operation
(
doc
.
cm
makeChangeSingleDoc
)
(
doc
change
selAfter
spans
)
;
if
(
change
.
to
.
line
<
doc
.
first
)
{
shiftDoc
(
doc
change
.
text
.
length
-
1
-
(
change
.
to
.
line
-
change
.
from
.
line
)
)
;
return
;
}
if
(
change
.
from
.
line
>
doc
.
lastLine
(
)
)
return
;
if
(
change
.
from
.
line
<
doc
.
first
)
{
var
shift
=
change
.
text
.
length
-
1
-
(
doc
.
first
-
change
.
from
.
line
)
;
shiftDoc
(
doc
shift
)
;
change
=
{
from
:
Pos
(
doc
.
first
0
)
to
:
Pos
(
change
.
to
.
line
+
shift
change
.
to
.
ch
)
text
:
[
lst
(
change
.
text
)
]
origin
:
change
.
origin
}
;
}
var
last
=
doc
.
lastLine
(
)
;
if
(
change
.
to
.
line
>
last
)
{
change
=
{
from
:
change
.
from
to
:
Pos
(
last
getLine
(
doc
last
)
.
text
.
length
)
text
:
[
change
.
text
[
0
]
]
origin
:
change
.
origin
}
;
}
change
.
removed
=
getBetween
(
doc
change
.
from
change
.
to
)
;
if
(
!
selAfter
)
selAfter
=
computeSelAfterChange
(
doc
change
)
;
if
(
doc
.
cm
)
makeChangeSingleDocInEditor
(
doc
.
cm
change
spans
)
;
else
updateDoc
(
doc
change
spans
)
;
setSelectionNoUndo
(
doc
selAfter
sel_dontScroll
)
;
}
function
makeChangeSingleDocInEditor
(
cm
change
spans
)
{
var
doc
=
cm
.
doc
display
=
cm
.
display
from
=
change
.
from
to
=
change
.
to
;
var
recomputeMaxLength
=
false
checkWidthStart
=
from
.
line
;
if
(
!
cm
.
options
.
lineWrapping
)
{
checkWidthStart
=
lineNo
(
visualLine
(
getLine
(
doc
from
.
line
)
)
)
;
doc
.
iter
(
checkWidthStart
to
.
line
+
1
function
(
line
)
{
if
(
line
=
=
display
.
maxLine
)
{
recomputeMaxLength
=
true
;
return
true
;
}
}
)
;
}
if
(
doc
.
sel
.
contains
(
change
.
from
change
.
to
)
>
-
1
)
signalCursorActivity
(
cm
)
;
updateDoc
(
doc
change
spans
estimateHeight
(
cm
)
)
;
if
(
!
cm
.
options
.
lineWrapping
)
{
doc
.
iter
(
checkWidthStart
from
.
line
+
change
.
text
.
length
function
(
line
)
{
var
len
=
lineLength
(
line
)
;
if
(
len
>
display
.
maxLineLength
)
{
display
.
maxLine
=
line
;
display
.
maxLineLength
=
len
;
display
.
maxLineChanged
=
true
;
recomputeMaxLength
=
false
;
}
}
)
;
if
(
recomputeMaxLength
)
cm
.
curOp
.
updateMaxLine
=
true
;
}
doc
.
frontier
=
Math
.
min
(
doc
.
frontier
from
.
line
)
;
startWorker
(
cm
400
)
;
var
lendiff
=
change
.
text
.
length
-
(
to
.
line
-
from
.
line
)
-
1
;
if
(
change
.
full
)
regChange
(
cm
)
;
else
if
(
from
.
line
=
=
to
.
line
&
&
change
.
text
.
length
=
=
1
&
&
!
isWholeLineUpdate
(
cm
.
doc
change
)
)
regLineChange
(
cm
from
.
line
"
text
"
)
;
else
regChange
(
cm
from
.
line
to
.
line
+
1
lendiff
)
;
var
changesHandler
=
hasHandler
(
cm
"
changes
"
)
changeHandler
=
hasHandler
(
cm
"
change
"
)
;
if
(
changeHandler
|
|
changesHandler
)
{
var
obj
=
{
from
:
from
to
:
to
text
:
change
.
text
removed
:
change
.
removed
origin
:
change
.
origin
}
;
if
(
changeHandler
)
signalLater
(
cm
"
change
"
cm
obj
)
;
if
(
changesHandler
)
(
cm
.
curOp
.
changeObjs
|
|
(
cm
.
curOp
.
changeObjs
=
[
]
)
)
.
push
(
obj
)
;
}
cm
.
display
.
selForContextMenu
=
null
;
}
function
replaceRange
(
doc
code
from
to
origin
)
{
if
(
!
to
)
to
=
from
;
if
(
cmp
(
to
from
)
<
0
)
{
var
tmp
=
to
;
to
=
from
;
from
=
tmp
;
}
if
(
typeof
code
=
=
"
string
"
)
code
=
doc
.
splitLines
(
code
)
;
makeChange
(
doc
{
from
:
from
to
:
to
text
:
code
origin
:
origin
}
)
;
}
function
maybeScrollWindow
(
cm
coords
)
{
if
(
signalDOMEvent
(
cm
"
scrollCursorIntoView
"
)
)
return
;
var
display
=
cm
.
display
box
=
display
.
sizer
.
getBoundingClientRect
(
)
doScroll
=
null
;
if
(
coords
.
top
+
box
.
top
<
0
)
doScroll
=
true
;
else
if
(
coords
.
bottom
+
box
.
top
>
(
window
.
innerHeight
|
|
document
.
documentElement
.
clientHeight
)
)
doScroll
=
false
;
if
(
doScroll
!
=
null
&
&
!
phantom
)
{
var
scrollNode
=
elt
(
"
div
"
"
\
u200b
"
null
"
position
:
absolute
;
top
:
"
+
(
coords
.
top
-
display
.
viewOffset
-
paddingTop
(
cm
.
display
)
)
+
"
px
;
height
:
"
+
(
coords
.
bottom
-
coords
.
top
+
scrollGap
(
cm
)
+
display
.
barHeight
)
+
"
px
;
left
:
"
+
coords
.
left
+
"
px
;
width
:
2px
;
"
)
;
cm
.
display
.
lineSpace
.
appendChild
(
scrollNode
)
;
scrollNode
.
scrollIntoView
(
doScroll
)
;
cm
.
display
.
lineSpace
.
removeChild
(
scrollNode
)
;
}
}
function
scrollPosIntoView
(
cm
pos
end
margin
)
{
if
(
margin
=
=
null
)
margin
=
0
;
for
(
var
limit
=
0
;
limit
<
5
;
limit
+
+
)
{
var
changed
=
false
coords
=
cursorCoords
(
cm
pos
)
;
var
endCoords
=
!
end
|
|
end
=
=
pos
?
coords
:
cursorCoords
(
cm
end
)
;
var
scrollPos
=
calculateScrollPos
(
cm
Math
.
min
(
coords
.
left
endCoords
.
left
)
Math
.
min
(
coords
.
top
endCoords
.
top
)
-
margin
Math
.
max
(
coords
.
left
endCoords
.
left
)
Math
.
max
(
coords
.
bottom
endCoords
.
bottom
)
+
margin
)
;
var
startTop
=
cm
.
doc
.
scrollTop
startLeft
=
cm
.
doc
.
scrollLeft
;
if
(
scrollPos
.
scrollTop
!
=
null
)
{
setScrollTop
(
cm
scrollPos
.
scrollTop
)
;
if
(
Math
.
abs
(
cm
.
doc
.
scrollTop
-
startTop
)
>
1
)
changed
=
true
;
}
if
(
scrollPos
.
scrollLeft
!
=
null
)
{
setScrollLeft
(
cm
scrollPos
.
scrollLeft
)
;
if
(
Math
.
abs
(
cm
.
doc
.
scrollLeft
-
startLeft
)
>
1
)
changed
=
true
;
}
if
(
!
changed
)
break
;
}
return
coords
;
}
function
scrollIntoView
(
cm
x1
y1
x2
y2
)
{
var
scrollPos
=
calculateScrollPos
(
cm
x1
y1
x2
y2
)
;
if
(
scrollPos
.
scrollTop
!
=
null
)
setScrollTop
(
cm
scrollPos
.
scrollTop
)
;
if
(
scrollPos
.
scrollLeft
!
=
null
)
setScrollLeft
(
cm
scrollPos
.
scrollLeft
)
;
}
function
calculateScrollPos
(
cm
x1
y1
x2
y2
)
{
var
display
=
cm
.
display
snapMargin
=
textHeight
(
cm
.
display
)
;
if
(
y1
<
0
)
y1
=
0
;
var
screentop
=
cm
.
curOp
&
&
cm
.
curOp
.
scrollTop
!
=
null
?
cm
.
curOp
.
scrollTop
:
display
.
scroller
.
scrollTop
;
var
screen
=
displayHeight
(
cm
)
result
=
{
}
;
if
(
y2
-
y1
>
screen
)
y2
=
y1
+
screen
;
var
docBottom
=
cm
.
doc
.
height
+
paddingVert
(
display
)
;
var
atTop
=
y1
<
snapMargin
atBottom
=
y2
>
docBottom
-
snapMargin
;
if
(
y1
<
screentop
)
{
result
.
scrollTop
=
atTop
?
0
:
y1
;
}
else
if
(
y2
>
screentop
+
screen
)
{
var
newTop
=
Math
.
min
(
y1
(
atBottom
?
docBottom
:
y2
)
-
screen
)
;
if
(
newTop
!
=
screentop
)
result
.
scrollTop
=
newTop
;
}
var
screenleft
=
cm
.
curOp
&
&
cm
.
curOp
.
scrollLeft
!
=
null
?
cm
.
curOp
.
scrollLeft
:
display
.
scroller
.
scrollLeft
;
var
screenw
=
displayWidth
(
cm
)
-
(
cm
.
options
.
fixedGutter
?
display
.
gutters
.
offsetWidth
:
0
)
;
var
tooWide
=
x2
-
x1
>
screenw
;
if
(
tooWide
)
x2
=
x1
+
screenw
;
if
(
x1
<
10
)
result
.
scrollLeft
=
0
;
else
if
(
x1
<
screenleft
)
result
.
scrollLeft
=
Math
.
max
(
0
x1
-
(
tooWide
?
0
:
10
)
)
;
else
if
(
x2
>
screenw
+
screenleft
-
3
)
result
.
scrollLeft
=
x2
+
(
tooWide
?
0
:
10
)
-
screenw
;
return
result
;
}
function
addToScrollPos
(
cm
left
top
)
{
if
(
left
!
=
null
|
|
top
!
=
null
)
resolveScrollToPos
(
cm
)
;
if
(
left
!
=
null
)
cm
.
curOp
.
scrollLeft
=
(
cm
.
curOp
.
scrollLeft
=
=
null
?
cm
.
doc
.
scrollLeft
:
cm
.
curOp
.
scrollLeft
)
+
left
;
if
(
top
!
=
null
)
cm
.
curOp
.
scrollTop
=
(
cm
.
curOp
.
scrollTop
=
=
null
?
cm
.
doc
.
scrollTop
:
cm
.
curOp
.
scrollTop
)
+
top
;
}
function
ensureCursorVisible
(
cm
)
{
resolveScrollToPos
(
cm
)
;
var
cur
=
cm
.
getCursor
(
)
from
=
cur
to
=
cur
;
if
(
!
cm
.
options
.
lineWrapping
)
{
from
=
cur
.
ch
?
Pos
(
cur
.
line
cur
.
ch
-
1
)
:
cur
;
to
=
Pos
(
cur
.
line
cur
.
ch
+
1
)
;
}
cm
.
curOp
.
scrollToPos
=
{
from
:
from
to
:
to
margin
:
cm
.
options
.
cursorScrollMargin
isCursor
:
true
}
;
}
function
resolveScrollToPos
(
cm
)
{
var
range
=
cm
.
curOp
.
scrollToPos
;
if
(
range
)
{
cm
.
curOp
.
scrollToPos
=
null
;
var
from
=
estimateCoords
(
cm
range
.
from
)
to
=
estimateCoords
(
cm
range
.
to
)
;
var
sPos
=
calculateScrollPos
(
cm
Math
.
min
(
from
.
left
to
.
left
)
Math
.
min
(
from
.
top
to
.
top
)
-
range
.
margin
Math
.
max
(
from
.
right
to
.
right
)
Math
.
max
(
from
.
bottom
to
.
bottom
)
+
range
.
margin
)
;
cm
.
scrollTo
(
sPos
.
scrollLeft
sPos
.
scrollTop
)
;
}
}
function
indentLine
(
cm
n
how
aggressive
)
{
var
doc
=
cm
.
doc
state
;
if
(
how
=
=
null
)
how
=
"
add
"
;
if
(
how
=
=
"
smart
"
)
{
if
(
!
doc
.
mode
.
indent
)
how
=
"
prev
"
;
else
state
=
getStateBefore
(
cm
n
)
;
}
var
tabSize
=
cm
.
options
.
tabSize
;
var
line
=
getLine
(
doc
n
)
curSpace
=
countColumn
(
line
.
text
null
tabSize
)
;
if
(
line
.
stateAfter
)
line
.
stateAfter
=
null
;
var
curSpaceString
=
line
.
text
.
match
(
/
^
\
s
*
/
)
[
0
]
indentation
;
if
(
!
aggressive
&
&
!
/
\
S
/
.
test
(
line
.
text
)
)
{
indentation
=
0
;
how
=
"
not
"
;
}
else
if
(
how
=
=
"
smart
"
)
{
indentation
=
doc
.
mode
.
indent
(
state
line
.
text
.
slice
(
curSpaceString
.
length
)
line
.
text
)
;
if
(
indentation
=
=
Pass
|
|
indentation
>
150
)
{
if
(
!
aggressive
)
return
;
how
=
"
prev
"
;
}
}
if
(
how
=
=
"
prev
"
)
{
if
(
n
>
doc
.
first
)
indentation
=
countColumn
(
getLine
(
doc
n
-
1
)
.
text
null
tabSize
)
;
else
indentation
=
0
;
}
else
if
(
how
=
=
"
add
"
)
{
indentation
=
curSpace
+
cm
.
options
.
indentUnit
;
}
else
if
(
how
=
=
"
subtract
"
)
{
indentation
=
curSpace
-
cm
.
options
.
indentUnit
;
}
else
if
(
typeof
how
=
=
"
number
"
)
{
indentation
=
curSpace
+
how
;
}
indentation
=
Math
.
max
(
0
indentation
)
;
var
indentString
=
"
"
pos
=
0
;
if
(
cm
.
options
.
indentWithTabs
)
for
(
var
i
=
Math
.
floor
(
indentation
/
tabSize
)
;
i
;
-
-
i
)
{
pos
+
=
tabSize
;
indentString
+
=
"
\
t
"
;
}
if
(
pos
<
indentation
)
indentString
+
=
spaceStr
(
indentation
-
pos
)
;
if
(
indentString
!
=
curSpaceString
)
{
replaceRange
(
doc
indentString
Pos
(
n
0
)
Pos
(
n
curSpaceString
.
length
)
"
+
input
"
)
;
line
.
stateAfter
=
null
;
return
true
;
}
else
{
for
(
var
i
=
0
;
i
<
doc
.
sel
.
ranges
.
length
;
i
+
+
)
{
var
range
=
doc
.
sel
.
ranges
[
i
]
;
if
(
range
.
head
.
line
=
=
n
&
&
range
.
head
.
ch
<
curSpaceString
.
length
)
{
var
pos
=
Pos
(
n
curSpaceString
.
length
)
;
replaceOneSelection
(
doc
i
new
Range
(
pos
pos
)
)
;
break
;
}
}
}
}
function
changeLine
(
doc
handle
changeType
op
)
{
var
no
=
handle
line
=
handle
;
if
(
typeof
handle
=
=
"
number
"
)
line
=
getLine
(
doc
clipLine
(
doc
handle
)
)
;
else
no
=
lineNo
(
handle
)
;
if
(
no
=
=
null
)
return
null
;
if
(
op
(
line
no
)
&
&
doc
.
cm
)
regLineChange
(
doc
.
cm
no
changeType
)
;
return
line
;
}
function
deleteNearSelection
(
cm
compute
)
{
var
ranges
=
cm
.
doc
.
sel
.
ranges
kill
=
[
]
;
for
(
var
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
var
toKill
=
compute
(
ranges
[
i
]
)
;
while
(
kill
.
length
&
&
cmp
(
toKill
.
from
lst
(
kill
)
.
to
)
<
=
0
)
{
var
replaced
=
kill
.
pop
(
)
;
if
(
cmp
(
replaced
.
from
toKill
.
from
)
<
0
)
{
toKill
.
from
=
replaced
.
from
;
break
;
}
}
kill
.
push
(
toKill
)
;
}
runInOp
(
cm
function
(
)
{
for
(
var
i
=
kill
.
length
-
1
;
i
>
=
0
;
i
-
-
)
replaceRange
(
cm
.
doc
"
"
kill
[
i
]
.
from
kill
[
i
]
.
to
"
+
delete
"
)
;
ensureCursorVisible
(
cm
)
;
}
)
;
}
function
findPosH
(
doc
pos
dir
unit
visually
)
{
var
line
=
pos
.
line
ch
=
pos
.
ch
origDir
=
dir
;
var
lineObj
=
getLine
(
doc
line
)
;
function
findNextLine
(
)
{
var
l
=
line
+
dir
;
if
(
l
<
doc
.
first
|
|
l
>
=
doc
.
first
+
doc
.
size
)
return
false
line
=
l
;
return
lineObj
=
getLine
(
doc
l
)
;
}
function
moveOnce
(
boundToLine
)
{
var
next
=
(
visually
?
moveVisually
:
moveLogically
)
(
lineObj
ch
dir
true
)
;
if
(
next
=
=
null
)
{
if
(
!
boundToLine
&
&
findNextLine
(
)
)
{
if
(
visually
)
ch
=
(
dir
<
0
?
lineRight
:
lineLeft
)
(
lineObj
)
;
else
ch
=
dir
<
0
?
lineObj
.
text
.
length
:
0
;
}
else
return
false
}
else
ch
=
next
;
return
true
;
}
if
(
unit
=
=
"
char
"
)
{
moveOnce
(
)
}
else
if
(
unit
=
=
"
column
"
)
{
moveOnce
(
true
)
}
else
if
(
unit
=
=
"
word
"
|
|
unit
=
=
"
group
"
)
{
var
sawType
=
null
group
=
unit
=
=
"
group
"
;
var
helper
=
doc
.
cm
&
&
doc
.
cm
.
getHelper
(
pos
"
wordChars
"
)
;
for
(
var
first
=
true
;
;
first
=
false
)
{
if
(
dir
<
0
&
&
!
moveOnce
(
!
first
)
)
break
;
var
cur
=
lineObj
.
text
.
charAt
(
ch
)
|
|
"
\
n
"
;
var
type
=
isWordChar
(
cur
helper
)
?
"
w
"
:
group
&
&
cur
=
=
"
\
n
"
?
"
n
"
:
!
group
|
|
/
\
s
/
.
test
(
cur
)
?
null
:
"
p
"
;
if
(
group
&
&
!
first
&
&
!
type
)
type
=
"
s
"
;
if
(
sawType
&
&
sawType
!
=
type
)
{
if
(
dir
<
0
)
{
dir
=
1
;
moveOnce
(
)
;
}
break
;
}
if
(
type
)
sawType
=
type
;
if
(
dir
>
0
&
&
!
moveOnce
(
!
first
)
)
break
;
}
}
var
result
=
skipAtomic
(
doc
Pos
(
line
ch
)
pos
origDir
true
)
;
if
(
!
cmp
(
pos
result
)
)
result
.
hitSide
=
true
;
return
result
;
}
function
findPosV
(
cm
pos
dir
unit
)
{
var
doc
=
cm
.
doc
x
=
pos
.
left
y
;
if
(
unit
=
=
"
page
"
)
{
var
pageSize
=
Math
.
min
(
cm
.
display
.
wrapper
.
clientHeight
window
.
innerHeight
|
|
document
.
documentElement
.
clientHeight
)
;
y
=
pos
.
top
+
dir
*
(
pageSize
-
(
dir
<
0
?
1
.
5
:
.
5
)
*
textHeight
(
cm
.
display
)
)
;
}
else
if
(
unit
=
=
"
line
"
)
{
y
=
dir
>
0
?
pos
.
bottom
+
3
:
pos
.
top
-
3
;
}
for
(
;
;
)
{
var
target
=
coordsChar
(
cm
x
y
)
;
if
(
!
target
.
outside
)
break
;
if
(
dir
<
0
?
y
<
=
0
:
y
>
=
doc
.
height
)
{
target
.
hitSide
=
true
;
break
;
}
y
+
=
dir
*
5
;
}
return
target
;
}
CodeMirror
.
prototype
=
{
constructor
:
CodeMirror
focus
:
function
(
)
{
window
.
focus
(
)
;
this
.
display
.
input
.
focus
(
)
;
}
setOption
:
function
(
option
value
)
{
var
options
=
this
.
options
old
=
options
[
option
]
;
if
(
options
[
option
]
=
=
value
&
&
option
!
=
"
mode
"
)
return
;
options
[
option
]
=
value
;
if
(
optionHandlers
.
hasOwnProperty
(
option
)
)
operation
(
this
optionHandlers
[
option
]
)
(
this
value
old
)
;
}
getOption
:
function
(
option
)
{
return
this
.
options
[
option
]
;
}
getDoc
:
function
(
)
{
return
this
.
doc
;
}
addKeyMap
:
function
(
map
bottom
)
{
this
.
state
.
keyMaps
[
bottom
?
"
push
"
:
"
unshift
"
]
(
getKeyMap
(
map
)
)
;
}
removeKeyMap
:
function
(
map
)
{
var
maps
=
this
.
state
.
keyMaps
;
for
(
var
i
=
0
;
i
<
maps
.
length
;
+
+
i
)
if
(
maps
[
i
]
=
=
map
|
|
maps
[
i
]
.
name
=
=
map
)
{
maps
.
splice
(
i
1
)
;
return
true
;
}
}
addOverlay
:
methodOp
(
function
(
spec
options
)
{
var
mode
=
spec
.
token
?
spec
:
CodeMirror
.
getMode
(
this
.
options
spec
)
;
if
(
mode
.
startState
)
throw
new
Error
(
"
Overlays
may
not
be
stateful
.
"
)
;
this
.
state
.
overlays
.
push
(
{
mode
:
mode
modeSpec
:
spec
opaque
:
options
&
&
options
.
opaque
}
)
;
this
.
state
.
modeGen
+
+
;
regChange
(
this
)
;
}
)
removeOverlay
:
methodOp
(
function
(
spec
)
{
var
overlays
=
this
.
state
.
overlays
;
for
(
var
i
=
0
;
i
<
overlays
.
length
;
+
+
i
)
{
var
cur
=
overlays
[
i
]
.
modeSpec
;
if
(
cur
=
=
spec
|
|
typeof
spec
=
=
"
string
"
&
&
cur
.
name
=
=
spec
)
{
overlays
.
splice
(
i
1
)
;
this
.
state
.
modeGen
+
+
;
regChange
(
this
)
;
return
;
}
}
}
)
indentLine
:
methodOp
(
function
(
n
dir
aggressive
)
{
if
(
typeof
dir
!
=
"
string
"
&
&
typeof
dir
!
=
"
number
"
)
{
if
(
dir
=
=
null
)
dir
=
this
.
options
.
smartIndent
?
"
smart
"
:
"
prev
"
;
else
dir
=
dir
?
"
add
"
:
"
subtract
"
;
}
if
(
isLine
(
this
.
doc
n
)
)
indentLine
(
this
n
dir
aggressive
)
;
}
)
indentSelection
:
methodOp
(
function
(
how
)
{
var
ranges
=
this
.
doc
.
sel
.
ranges
end
=
-
1
;
for
(
var
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
var
range
=
ranges
[
i
]
;
if
(
!
range
.
empty
(
)
)
{
var
from
=
range
.
from
(
)
to
=
range
.
to
(
)
;
var
start
=
Math
.
max
(
end
from
.
line
)
;
end
=
Math
.
min
(
this
.
lastLine
(
)
to
.
line
-
(
to
.
ch
?
0
:
1
)
)
+
1
;
for
(
var
j
=
start
;
j
<
end
;
+
+
j
)
indentLine
(
this
j
how
)
;
var
newRanges
=
this
.
doc
.
sel
.
ranges
;
if
(
from
.
ch
=
=
0
&
&
ranges
.
length
=
=
newRanges
.
length
&
&
newRanges
[
i
]
.
from
(
)
.
ch
>
0
)
replaceOneSelection
(
this
.
doc
i
new
Range
(
from
newRanges
[
i
]
.
to
(
)
)
sel_dontScroll
)
;
}
else
if
(
range
.
head
.
line
>
end
)
{
indentLine
(
this
range
.
head
.
line
how
true
)
;
end
=
range
.
head
.
line
;
if
(
i
=
=
this
.
doc
.
sel
.
primIndex
)
ensureCursorVisible
(
this
)
;
}
}
}
)
getTokenAt
:
function
(
pos
precise
)
{
return
takeToken
(
this
pos
precise
)
;
}
getLineTokens
:
function
(
line
precise
)
{
return
takeToken
(
this
Pos
(
line
)
precise
true
)
;
}
getTokenTypeAt
:
function
(
pos
)
{
pos
=
clipPos
(
this
.
doc
pos
)
;
var
styles
=
getLineStyles
(
this
getLine
(
this
.
doc
pos
.
line
)
)
;
var
before
=
0
after
=
(
styles
.
length
-
1
)
/
2
ch
=
pos
.
ch
;
var
type
;
if
(
ch
=
=
0
)
type
=
styles
[
2
]
;
else
for
(
;
;
)
{
var
mid
=
(
before
+
after
)
>
>
1
;
if
(
(
mid
?
styles
[
mid
*
2
-
1
]
:
0
)
>
=
ch
)
after
=
mid
;
else
if
(
styles
[
mid
*
2
+
1
]
<
ch
)
before
=
mid
+
1
;
else
{
type
=
styles
[
mid
*
2
+
2
]
;
break
;
}
}
var
cut
=
type
?
type
.
indexOf
(
"
cm
-
overlay
"
)
:
-
1
;
return
cut
<
0
?
type
:
cut
=
=
0
?
null
:
type
.
slice
(
0
cut
-
1
)
;
}
getModeAt
:
function
(
pos
)
{
var
mode
=
this
.
doc
.
mode
;
if
(
!
mode
.
innerMode
)
return
mode
;
return
CodeMirror
.
innerMode
(
mode
this
.
getTokenAt
(
pos
)
.
state
)
.
mode
;
}
getHelper
:
function
(
pos
type
)
{
return
this
.
getHelpers
(
pos
type
)
[
0
]
;
}
getHelpers
:
function
(
pos
type
)
{
var
found
=
[
]
;
if
(
!
helpers
.
hasOwnProperty
(
type
)
)
return
found
;
var
help
=
helpers
[
type
]
mode
=
this
.
getModeAt
(
pos
)
;
if
(
typeof
mode
[
type
]
=
=
"
string
"
)
{
if
(
help
[
mode
[
type
]
]
)
found
.
push
(
help
[
mode
[
type
]
]
)
;
}
else
if
(
mode
[
type
]
)
{
for
(
var
i
=
0
;
i
<
mode
[
type
]
.
length
;
i
+
+
)
{
var
val
=
help
[
mode
[
type
]
[
i
]
]
;
if
(
val
)
found
.
push
(
val
)
;
}
}
else
if
(
mode
.
helperType
&
&
help
[
mode
.
helperType
]
)
{
found
.
push
(
help
[
mode
.
helperType
]
)
;
}
else
if
(
help
[
mode
.
name
]
)
{
found
.
push
(
help
[
mode
.
name
]
)
;
}
for
(
var
i
=
0
;
i
<
help
.
_global
.
length
;
i
+
+
)
{
var
cur
=
help
.
_global
[
i
]
;
if
(
cur
.
pred
(
mode
this
)
&
&
indexOf
(
found
cur
.
val
)
=
=
-
1
)
found
.
push
(
cur
.
val
)
;
}
return
found
;
}
getStateAfter
:
function
(
line
precise
)
{
var
doc
=
this
.
doc
;
line
=
clipLine
(
doc
line
=
=
null
?
doc
.
first
+
doc
.
size
-
1
:
line
)
;
return
getStateBefore
(
this
line
+
1
precise
)
;
}
cursorCoords
:
function
(
start
mode
)
{
var
pos
range
=
this
.
doc
.
sel
.
primary
(
)
;
if
(
start
=
=
null
)
pos
=
range
.
head
;
else
if
(
typeof
start
=
=
"
object
"
)
pos
=
clipPos
(
this
.
doc
start
)
;
else
pos
=
start
?
range
.
from
(
)
:
range
.
to
(
)
;
return
cursorCoords
(
this
pos
mode
|
|
"
page
"
)
;
}
charCoords
:
function
(
pos
mode
)
{
return
charCoords
(
this
clipPos
(
this
.
doc
pos
)
mode
|
|
"
page
"
)
;
}
coordsChar
:
function
(
coords
mode
)
{
coords
=
fromCoordSystem
(
this
coords
mode
|
|
"
page
"
)
;
return
coordsChar
(
this
coords
.
left
coords
.
top
)
;
}
lineAtHeight
:
function
(
height
mode
)
{
height
=
fromCoordSystem
(
this
{
top
:
height
left
:
0
}
mode
|
|
"
page
"
)
.
top
;
return
lineAtHeight
(
this
.
doc
height
+
this
.
display
.
viewOffset
)
;
}
heightAtLine
:
function
(
line
mode
)
{
var
end
=
false
lineObj
;
if
(
typeof
line
=
=
"
number
"
)
{
var
last
=
this
.
doc
.
first
+
this
.
doc
.
size
-
1
;
if
(
line
<
this
.
doc
.
first
)
line
=
this
.
doc
.
first
;
else
if
(
line
>
last
)
{
line
=
last
;
end
=
true
;
}
lineObj
=
getLine
(
this
.
doc
line
)
;
}
else
{
lineObj
=
line
;
}
return
intoCoordSystem
(
this
lineObj
{
top
:
0
left
:
0
}
mode
|
|
"
page
"
)
.
top
+
(
end
?
this
.
doc
.
height
-
heightAtLine
(
lineObj
)
:
0
)
;
}
defaultTextHeight
:
function
(
)
{
return
textHeight
(
this
.
display
)
;
}
defaultCharWidth
:
function
(
)
{
return
charWidth
(
this
.
display
)
;
}
setGutterMarker
:
methodOp
(
function
(
line
gutterID
value
)
{
return
changeLine
(
this
.
doc
line
"
gutter
"
function
(
line
)
{
var
markers
=
line
.
gutterMarkers
|
|
(
line
.
gutterMarkers
=
{
}
)
;
markers
[
gutterID
]
=
value
;
if
(
!
value
&
&
isEmpty
(
markers
)
)
line
.
gutterMarkers
=
null
;
return
true
;
}
)
;
}
)
clearGutter
:
methodOp
(
function
(
gutterID
)
{
var
cm
=
this
doc
=
cm
.
doc
i
=
doc
.
first
;
doc
.
iter
(
function
(
line
)
{
if
(
line
.
gutterMarkers
&
&
line
.
gutterMarkers
[
gutterID
]
)
{
line
.
gutterMarkers
[
gutterID
]
=
null
;
regLineChange
(
cm
i
"
gutter
"
)
;
if
(
isEmpty
(
line
.
gutterMarkers
)
)
line
.
gutterMarkers
=
null
;
}
+
+
i
;
}
)
;
}
)
lineInfo
:
function
(
line
)
{
if
(
typeof
line
=
=
"
number
"
)
{
if
(
!
isLine
(
this
.
doc
line
)
)
return
null
;
var
n
=
line
;
line
=
getLine
(
this
.
doc
line
)
;
if
(
!
line
)
return
null
;
}
else
{
var
n
=
lineNo
(
line
)
;
if
(
n
=
=
null
)
return
null
;
}
return
{
line
:
n
handle
:
line
text
:
line
.
text
gutterMarkers
:
line
.
gutterMarkers
textClass
:
line
.
textClass
bgClass
:
line
.
bgClass
wrapClass
:
line
.
wrapClass
widgets
:
line
.
widgets
}
;
}
getViewport
:
function
(
)
{
return
{
from
:
this
.
display
.
viewFrom
to
:
this
.
display
.
viewTo
}
;
}
addWidget
:
function
(
pos
node
scroll
vert
horiz
)
{
var
display
=
this
.
display
;
pos
=
cursorCoords
(
this
clipPos
(
this
.
doc
pos
)
)
;
var
top
=
pos
.
bottom
left
=
pos
.
left
;
node
.
style
.
position
=
"
absolute
"
;
node
.
setAttribute
(
"
cm
-
ignore
-
events
"
"
true
"
)
;
this
.
display
.
input
.
setUneditable
(
node
)
;
display
.
sizer
.
appendChild
(
node
)
;
if
(
vert
=
=
"
over
"
)
{
top
=
pos
.
top
;
}
else
if
(
vert
=
=
"
above
"
|
|
vert
=
=
"
near
"
)
{
var
vspace
=
Math
.
max
(
display
.
wrapper
.
clientHeight
this
.
doc
.
height
)
hspace
=
Math
.
max
(
display
.
sizer
.
clientWidth
display
.
lineSpace
.
clientWidth
)
;
if
(
(
vert
=
=
'
above
'
|
|
pos
.
bottom
+
node
.
offsetHeight
>
vspace
)
&
&
pos
.
top
>
node
.
offsetHeight
)
top
=
pos
.
top
-
node
.
offsetHeight
;
else
if
(
pos
.
bottom
+
node
.
offsetHeight
<
=
vspace
)
top
=
pos
.
bottom
;
if
(
left
+
node
.
offsetWidth
>
hspace
)
left
=
hspace
-
node
.
offsetWidth
;
}
node
.
style
.
top
=
top
+
"
px
"
;
node
.
style
.
left
=
node
.
style
.
right
=
"
"
;
if
(
horiz
=
=
"
right
"
)
{
left
=
display
.
sizer
.
clientWidth
-
node
.
offsetWidth
;
node
.
style
.
right
=
"
0px
"
;
}
else
{
if
(
horiz
=
=
"
left
"
)
left
=
0
;
else
if
(
horiz
=
=
"
middle
"
)
left
=
(
display
.
sizer
.
clientWidth
-
node
.
offsetWidth
)
/
2
;
node
.
style
.
left
=
left
+
"
px
"
;
}
if
(
scroll
)
scrollIntoView
(
this
left
top
left
+
node
.
offsetWidth
top
+
node
.
offsetHeight
)
;
}
triggerOnKeyDown
:
methodOp
(
onKeyDown
)
triggerOnKeyPress
:
methodOp
(
onKeyPress
)
triggerOnKeyUp
:
onKeyUp
execCommand
:
function
(
cmd
)
{
if
(
commands
.
hasOwnProperty
(
cmd
)
)
return
commands
[
cmd
]
.
call
(
null
this
)
;
}
triggerElectric
:
methodOp
(
function
(
text
)
{
triggerElectric
(
this
text
)
;
}
)
findPosH
:
function
(
from
amount
unit
visually
)
{
var
dir
=
1
;
if
(
amount
<
0
)
{
dir
=
-
1
;
amount
=
-
amount
;
}
for
(
var
i
=
0
cur
=
clipPos
(
this
.
doc
from
)
;
i
<
amount
;
+
+
i
)
{
cur
=
findPosH
(
this
.
doc
cur
dir
unit
visually
)
;
if
(
cur
.
hitSide
)
break
;
}
return
cur
;
}
moveH
:
methodOp
(
function
(
dir
unit
)
{
var
cm
=
this
;
cm
.
extendSelectionsBy
(
function
(
range
)
{
if
(
cm
.
display
.
shift
|
|
cm
.
doc
.
extend
|
|
range
.
empty
(
)
)
return
findPosH
(
cm
.
doc
range
.
head
dir
unit
cm
.
options
.
rtlMoveVisually
)
;
else
return
dir
<
0
?
range
.
from
(
)
:
range
.
to
(
)
;
}
sel_move
)
;
}
)
deleteH
:
methodOp
(
function
(
dir
unit
)
{
var
sel
=
this
.
doc
.
sel
doc
=
this
.
doc
;
if
(
sel
.
somethingSelected
(
)
)
doc
.
replaceSelection
(
"
"
null
"
+
delete
"
)
;
else
deleteNearSelection
(
this
function
(
range
)
{
var
other
=
findPosH
(
doc
range
.
head
dir
unit
false
)
;
return
dir
<
0
?
{
from
:
other
to
:
range
.
head
}
:
{
from
:
range
.
head
to
:
other
}
;
}
)
;
}
)
findPosV
:
function
(
from
amount
unit
goalColumn
)
{
var
dir
=
1
x
=
goalColumn
;
if
(
amount
<
0
)
{
dir
=
-
1
;
amount
=
-
amount
;
}
for
(
var
i
=
0
cur
=
clipPos
(
this
.
doc
from
)
;
i
<
amount
;
+
+
i
)
{
var
coords
=
cursorCoords
(
this
cur
"
div
"
)
;
if
(
x
=
=
null
)
x
=
coords
.
left
;
else
coords
.
left
=
x
;
cur
=
findPosV
(
this
coords
dir
unit
)
;
if
(
cur
.
hitSide
)
break
;
}
return
cur
;
}
moveV
:
methodOp
(
function
(
dir
unit
)
{
var
cm
=
this
doc
=
this
.
doc
goals
=
[
]
;
var
collapse
=
!
cm
.
display
.
shift
&
&
!
doc
.
extend
&
&
doc
.
sel
.
somethingSelected
(
)
;
doc
.
extendSelectionsBy
(
function
(
range
)
{
if
(
collapse
)
return
dir
<
0
?
range
.
from
(
)
:
range
.
to
(
)
;
var
headPos
=
cursorCoords
(
cm
range
.
head
"
div
"
)
;
if
(
range
.
goalColumn
!
=
null
)
headPos
.
left
=
range
.
goalColumn
;
goals
.
push
(
headPos
.
left
)
;
var
pos
=
findPosV
(
cm
headPos
dir
unit
)
;
if
(
unit
=
=
"
page
"
&
&
range
=
=
doc
.
sel
.
primary
(
)
)
addToScrollPos
(
cm
null
charCoords
(
cm
pos
"
div
"
)
.
top
-
headPos
.
top
)
;
return
pos
;
}
sel_move
)
;
if
(
goals
.
length
)
for
(
var
i
=
0
;
i
<
doc
.
sel
.
ranges
.
length
;
i
+
+
)
doc
.
sel
.
ranges
[
i
]
.
goalColumn
=
goals
[
i
]
;
}
)
findWordAt
:
function
(
pos
)
{
var
doc
=
this
.
doc
line
=
getLine
(
doc
pos
.
line
)
.
text
;
var
start
=
pos
.
ch
end
=
pos
.
ch
;
if
(
line
)
{
var
helper
=
this
.
getHelper
(
pos
"
wordChars
"
)
;
if
(
(
pos
.
xRel
<
0
|
|
end
=
=
line
.
length
)
&
&
start
)
-
-
start
;
else
+
+
end
;
var
startChar
=
line
.
charAt
(
start
)
;
var
check
=
isWordChar
(
startChar
helper
)
?
function
(
ch
)
{
return
isWordChar
(
ch
helper
)
;
}
:
/
\
s
/
.
test
(
startChar
)
?
function
(
ch
)
{
return
/
\
s
/
.
test
(
ch
)
;
}
:
function
(
ch
)
{
return
!
/
\
s
/
.
test
(
ch
)
&
&
!
isWordChar
(
ch
)
;
}
;
while
(
start
>
0
&
&
check
(
line
.
charAt
(
start
-
1
)
)
)
-
-
start
;
while
(
end
<
line
.
length
&
&
check
(
line
.
charAt
(
end
)
)
)
+
+
end
;
}
return
new
Range
(
Pos
(
pos
.
line
start
)
Pos
(
pos
.
line
end
)
)
;
}
toggleOverwrite
:
function
(
value
)
{
if
(
value
!
=
null
&
&
value
=
=
this
.
state
.
overwrite
)
return
;
if
(
this
.
state
.
overwrite
=
!
this
.
state
.
overwrite
)
addClass
(
this
.
display
.
cursorDiv
"
CodeMirror
-
overwrite
"
)
;
else
rmClass
(
this
.
display
.
cursorDiv
"
CodeMirror
-
overwrite
"
)
;
signal
(
this
"
overwriteToggle
"
this
this
.
state
.
overwrite
)
;
}
hasFocus
:
function
(
)
{
return
this
.
display
.
input
.
getField
(
)
=
=
activeElt
(
)
;
}
isReadOnly
:
function
(
)
{
return
!
!
(
this
.
options
.
readOnly
|
|
this
.
doc
.
cantEdit
)
;
}
scrollTo
:
methodOp
(
function
(
x
y
)
{
if
(
x
!
=
null
|
|
y
!
=
null
)
resolveScrollToPos
(
this
)
;
if
(
x
!
=
null
)
this
.
curOp
.
scrollLeft
=
x
;
if
(
y
!
=
null
)
this
.
curOp
.
scrollTop
=
y
;
}
)
getScrollInfo
:
function
(
)
{
var
scroller
=
this
.
display
.
scroller
;
return
{
left
:
scroller
.
scrollLeft
top
:
scroller
.
scrollTop
height
:
scroller
.
scrollHeight
-
scrollGap
(
this
)
-
this
.
display
.
barHeight
width
:
scroller
.
scrollWidth
-
scrollGap
(
this
)
-
this
.
display
.
barWidth
clientHeight
:
displayHeight
(
this
)
clientWidth
:
displayWidth
(
this
)
}
;
}
scrollIntoView
:
methodOp
(
function
(
range
margin
)
{
if
(
range
=
=
null
)
{
range
=
{
from
:
this
.
doc
.
sel
.
primary
(
)
.
head
to
:
null
}
;
if
(
margin
=
=
null
)
margin
=
this
.
options
.
cursorScrollMargin
;
}
else
if
(
typeof
range
=
=
"
number
"
)
{
range
=
{
from
:
Pos
(
range
0
)
to
:
null
}
;
}
else
if
(
range
.
from
=
=
null
)
{
range
=
{
from
:
range
to
:
null
}
;
}
if
(
!
range
.
to
)
range
.
to
=
range
.
from
;
range
.
margin
=
margin
|
|
0
;
if
(
range
.
from
.
line
!
=
null
)
{
resolveScrollToPos
(
this
)
;
this
.
curOp
.
scrollToPos
=
range
;
}
else
{
var
sPos
=
calculateScrollPos
(
this
Math
.
min
(
range
.
from
.
left
range
.
to
.
left
)
Math
.
min
(
range
.
from
.
top
range
.
to
.
top
)
-
range
.
margin
Math
.
max
(
range
.
from
.
right
range
.
to
.
right
)
Math
.
max
(
range
.
from
.
bottom
range
.
to
.
bottom
)
+
range
.
margin
)
;
this
.
scrollTo
(
sPos
.
scrollLeft
sPos
.
scrollTop
)
;
}
}
)
setSize
:
methodOp
(
function
(
width
height
)
{
var
cm
=
this
;
function
interpret
(
val
)
{
return
typeof
val
=
=
"
number
"
|
|
/
^
\
d
+
/
.
test
(
String
(
val
)
)
?
val
+
"
px
"
:
val
;
}
if
(
width
!
=
null
)
cm
.
display
.
wrapper
.
style
.
width
=
interpret
(
width
)
;
if
(
height
!
=
null
)
cm
.
display
.
wrapper
.
style
.
height
=
interpret
(
height
)
;
if
(
cm
.
options
.
lineWrapping
)
clearLineMeasurementCache
(
this
)
;
var
lineNo
=
cm
.
display
.
viewFrom
;
cm
.
doc
.
iter
(
lineNo
cm
.
display
.
viewTo
function
(
line
)
{
if
(
line
.
widgets
)
for
(
var
i
=
0
;
i
<
line
.
widgets
.
length
;
i
+
+
)
if
(
line
.
widgets
[
i
]
.
noHScroll
)
{
regLineChange
(
cm
lineNo
"
widget
"
)
;
break
;
}
+
+
lineNo
;
}
)
;
cm
.
curOp
.
forceUpdate
=
true
;
signal
(
cm
"
refresh
"
this
)
;
}
)
operation
:
function
(
f
)
{
return
runInOp
(
this
f
)
;
}
refresh
:
methodOp
(
function
(
)
{
var
oldHeight
=
this
.
display
.
cachedTextHeight
;
regChange
(
this
)
;
this
.
curOp
.
forceUpdate
=
true
;
clearCaches
(
this
)
;
this
.
scrollTo
(
this
.
doc
.
scrollLeft
this
.
doc
.
scrollTop
)
;
updateGutterSpace
(
this
)
;
if
(
oldHeight
=
=
null
|
|
Math
.
abs
(
oldHeight
-
textHeight
(
this
.
display
)
)
>
.
5
)
estimateLineHeights
(
this
)
;
signal
(
this
"
refresh
"
this
)
;
}
)
swapDoc
:
methodOp
(
function
(
doc
)
{
var
old
=
this
.
doc
;
old
.
cm
=
null
;
attachDoc
(
this
doc
)
;
clearCaches
(
this
)
;
this
.
display
.
input
.
reset
(
)
;
this
.
scrollTo
(
doc
.
scrollLeft
doc
.
scrollTop
)
;
this
.
curOp
.
forceScroll
=
true
;
signalLater
(
this
"
swapDoc
"
this
old
)
;
return
old
;
}
)
getInputField
:
function
(
)
{
return
this
.
display
.
input
.
getField
(
)
;
}
getWrapperElement
:
function
(
)
{
return
this
.
display
.
wrapper
;
}
getScrollerElement
:
function
(
)
{
return
this
.
display
.
scroller
;
}
getGutterElement
:
function
(
)
{
return
this
.
display
.
gutters
;
}
}
;
eventMixin
(
CodeMirror
)
;
var
defaults
=
CodeMirror
.
defaults
=
{
}
;
var
optionHandlers
=
CodeMirror
.
optionHandlers
=
{
}
;
function
option
(
name
deflt
handle
notOnInit
)
{
CodeMirror
.
defaults
[
name
]
=
deflt
;
if
(
handle
)
optionHandlers
[
name
]
=
notOnInit
?
function
(
cm
val
old
)
{
if
(
old
!
=
Init
)
handle
(
cm
val
old
)
;
}
:
handle
;
}
var
Init
=
CodeMirror
.
Init
=
{
toString
:
function
(
)
{
return
"
CodeMirror
.
Init
"
;
}
}
;
option
(
"
value
"
"
"
function
(
cm
val
)
{
cm
.
setValue
(
val
)
;
}
true
)
;
option
(
"
mode
"
null
function
(
cm
val
)
{
cm
.
doc
.
modeOption
=
val
;
loadMode
(
cm
)
;
}
true
)
;
option
(
"
indentUnit
"
2
loadMode
true
)
;
option
(
"
indentWithTabs
"
false
)
;
option
(
"
smartIndent
"
true
)
;
option
(
"
tabSize
"
4
function
(
cm
)
{
resetModeState
(
cm
)
;
clearCaches
(
cm
)
;
regChange
(
cm
)
;
}
true
)
;
option
(
"
lineSeparator
"
null
function
(
cm
val
)
{
cm
.
doc
.
lineSep
=
val
;
if
(
!
val
)
return
;
var
newBreaks
=
[
]
lineNo
=
cm
.
doc
.
first
;
cm
.
doc
.
iter
(
function
(
line
)
{
for
(
var
pos
=
0
;
;
)
{
var
found
=
line
.
text
.
indexOf
(
val
pos
)
;
if
(
found
=
=
-
1
)
break
;
pos
=
found
+
val
.
length
;
newBreaks
.
push
(
Pos
(
lineNo
found
)
)
;
}
lineNo
+
+
;
}
)
;
for
(
var
i
=
newBreaks
.
length
-
1
;
i
>
=
0
;
i
-
-
)
replaceRange
(
cm
.
doc
val
newBreaks
[
i
]
Pos
(
newBreaks
[
i
]
.
line
newBreaks
[
i
]
.
ch
+
val
.
length
)
)
}
)
;
option
(
"
specialChars
"
/
[
\
u0000
-
\
u001f
\
u007f
\
u00ad
\
u200b
-
\
u200f
\
u2028
\
u2029
\
ufeff
]
/
g
function
(
cm
val
old
)
{
cm
.
state
.
specialChars
=
new
RegExp
(
val
.
source
+
(
val
.
test
(
"
\
t
"
)
?
"
"
:
"
|
\
t
"
)
"
g
"
)
;
if
(
old
!
=
CodeMirror
.
Init
)
cm
.
refresh
(
)
;
}
)
;
option
(
"
specialCharPlaceholder
"
defaultSpecialCharPlaceholder
function
(
cm
)
{
cm
.
refresh
(
)
;
}
true
)
;
option
(
"
electricChars
"
true
)
;
option
(
"
inputStyle
"
mobile
?
"
contenteditable
"
:
"
textarea
"
function
(
)
{
throw
new
Error
(
"
inputStyle
can
not
(
yet
)
be
changed
in
a
running
editor
"
)
;
}
true
)
;
option
(
"
rtlMoveVisually
"
!
windows
)
;
option
(
"
wholeLineUpdateBefore
"
true
)
;
option
(
"
theme
"
"
default
"
function
(
cm
)
{
themeChanged
(
cm
)
;
guttersChanged
(
cm
)
;
}
true
)
;
option
(
"
keyMap
"
"
default
"
function
(
cm
val
old
)
{
var
next
=
getKeyMap
(
val
)
;
var
prev
=
old
!
=
CodeMirror
.
Init
&
&
getKeyMap
(
old
)
;
if
(
prev
&
&
prev
.
detach
)
prev
.
detach
(
cm
next
)
;
if
(
next
.
attach
)
next
.
attach
(
cm
prev
|
|
null
)
;
}
)
;
option
(
"
extraKeys
"
null
)
;
option
(
"
lineWrapping
"
false
wrappingChanged
true
)
;
option
(
"
gutters
"
[
]
function
(
cm
)
{
setGuttersForLineNumbers
(
cm
.
options
)
;
guttersChanged
(
cm
)
;
}
true
)
;
option
(
"
fixedGutter
"
true
function
(
cm
val
)
{
cm
.
display
.
gutters
.
style
.
left
=
val
?
compensateForHScroll
(
cm
.
display
)
+
"
px
"
:
"
0
"
;
cm
.
refresh
(
)
;
}
true
)
;
option
(
"
coverGutterNextToScrollbar
"
false
function
(
cm
)
{
updateScrollbars
(
cm
)
;
}
true
)
;
option
(
"
scrollbarStyle
"
"
native
"
function
(
cm
)
{
initScrollbars
(
cm
)
;
updateScrollbars
(
cm
)
;
cm
.
display
.
scrollbars
.
setScrollTop
(
cm
.
doc
.
scrollTop
)
;
cm
.
display
.
scrollbars
.
setScrollLeft
(
cm
.
doc
.
scrollLeft
)
;
}
true
)
;
option
(
"
lineNumbers
"
false
function
(
cm
)
{
setGuttersForLineNumbers
(
cm
.
options
)
;
guttersChanged
(
cm
)
;
}
true
)
;
option
(
"
firstLineNumber
"
1
guttersChanged
true
)
;
option
(
"
lineNumberFormatter
"
function
(
integer
)
{
return
integer
;
}
guttersChanged
true
)
;
option
(
"
showCursorWhenSelecting
"
false
updateSelection
true
)
;
option
(
"
resetSelectionOnContextMenu
"
true
)
;
option
(
"
lineWiseCopyCut
"
true
)
;
option
(
"
readOnly
"
false
function
(
cm
val
)
{
if
(
val
=
=
"
nocursor
"
)
{
onBlur
(
cm
)
;
cm
.
display
.
input
.
blur
(
)
;
cm
.
display
.
disabled
=
true
;
}
else
{
cm
.
display
.
disabled
=
false
;
}
cm
.
display
.
input
.
readOnlyChanged
(
val
)
}
)
;
option
(
"
disableInput
"
false
function
(
cm
val
)
{
if
(
!
val
)
cm
.
display
.
input
.
reset
(
)
;
}
true
)
;
option
(
"
dragDrop
"
true
dragDropChanged
)
;
option
(
"
allowDropFileTypes
"
null
)
;
option
(
"
cursorBlinkRate
"
530
)
;
option
(
"
cursorScrollMargin
"
0
)
;
option
(
"
cursorHeight
"
1
updateSelection
true
)
;
option
(
"
singleCursorHeightPerLine
"
true
updateSelection
true
)
;
option
(
"
workTime
"
100
)
;
option
(
"
workDelay
"
100
)
;
option
(
"
flattenSpans
"
true
resetModeState
true
)
;
option
(
"
addModeClass
"
false
resetModeState
true
)
;
option
(
"
pollInterval
"
100
)
;
option
(
"
undoDepth
"
200
function
(
cm
val
)
{
cm
.
doc
.
history
.
undoDepth
=
val
;
}
)
;
option
(
"
historyEventDelay
"
1250
)
;
option
(
"
viewportMargin
"
10
function
(
cm
)
{
cm
.
refresh
(
)
;
}
true
)
;
option
(
"
maxHighlightLength
"
10000
resetModeState
true
)
;
option
(
"
moveInputWithCursor
"
true
function
(
cm
val
)
{
if
(
!
val
)
cm
.
display
.
input
.
resetPosition
(
)
;
}
)
;
option
(
"
tabindex
"
null
function
(
cm
val
)
{
cm
.
display
.
input
.
getField
(
)
.
tabIndex
=
val
|
|
"
"
;
}
)
;
option
(
"
autofocus
"
null
)
;
var
modes
=
CodeMirror
.
modes
=
{
}
mimeModes
=
CodeMirror
.
mimeModes
=
{
}
;
CodeMirror
.
defineMode
=
function
(
name
mode
)
{
if
(
!
CodeMirror
.
defaults
.
mode
&
&
name
!
=
"
null
"
)
CodeMirror
.
defaults
.
mode
=
name
;
if
(
arguments
.
length
>
2
)
mode
.
dependencies
=
Array
.
prototype
.
slice
.
call
(
arguments
2
)
;
modes
[
name
]
=
mode
;
}
;
CodeMirror
.
defineMIME
=
function
(
mime
spec
)
{
mimeModes
[
mime
]
=
spec
;
}
;
CodeMirror
.
resolveMode
=
function
(
spec
)
{
if
(
typeof
spec
=
=
"
string
"
&
&
mimeModes
.
hasOwnProperty
(
spec
)
)
{
spec
=
mimeModes
[
spec
]
;
}
else
if
(
spec
&
&
typeof
spec
.
name
=
=
"
string
"
&
&
mimeModes
.
hasOwnProperty
(
spec
.
name
)
)
{
var
found
=
mimeModes
[
spec
.
name
]
;
if
(
typeof
found
=
=
"
string
"
)
found
=
{
name
:
found
}
;
spec
=
createObj
(
found
spec
)
;
spec
.
name
=
found
.
name
;
}
else
if
(
typeof
spec
=
=
"
string
"
&
&
/
^
[
\
w
\
-
]
+
\
/
[
\
w
\
-
]
+
\
+
xml
/
.
test
(
spec
)
)
{
return
CodeMirror
.
resolveMode
(
"
application
/
xml
"
)
;
}
if
(
typeof
spec
=
=
"
string
"
)
return
{
name
:
spec
}
;
else
return
spec
|
|
{
name
:
"
null
"
}
;
}
;
CodeMirror
.
getMode
=
function
(
options
spec
)
{
var
spec
=
CodeMirror
.
resolveMode
(
spec
)
;
var
mfactory
=
modes
[
spec
.
name
]
;
if
(
!
mfactory
)
return
CodeMirror
.
getMode
(
options
"
text
/
plain
"
)
;
var
modeObj
=
mfactory
(
options
spec
)
;
if
(
modeExtensions
.
hasOwnProperty
(
spec
.
name
)
)
{
var
exts
=
modeExtensions
[
spec
.
name
]
;
for
(
var
prop
in
exts
)
{
if
(
!
exts
.
hasOwnProperty
(
prop
)
)
continue
;
if
(
modeObj
.
hasOwnProperty
(
prop
)
)
modeObj
[
"
_
"
+
prop
]
=
modeObj
[
prop
]
;
modeObj
[
prop
]
=
exts
[
prop
]
;
}
}
modeObj
.
name
=
spec
.
name
;
if
(
spec
.
helperType
)
modeObj
.
helperType
=
spec
.
helperType
;
if
(
spec
.
modeProps
)
for
(
var
prop
in
spec
.
modeProps
)
modeObj
[
prop
]
=
spec
.
modeProps
[
prop
]
;
return
modeObj
;
}
;
CodeMirror
.
defineMode
(
"
null
"
function
(
)
{
return
{
token
:
function
(
stream
)
{
stream
.
skipToEnd
(
)
;
}
}
;
}
)
;
CodeMirror
.
defineMIME
(
"
text
/
plain
"
"
null
"
)
;
var
modeExtensions
=
CodeMirror
.
modeExtensions
=
{
}
;
CodeMirror
.
extendMode
=
function
(
mode
properties
)
{
var
exts
=
modeExtensions
.
hasOwnProperty
(
mode
)
?
modeExtensions
[
mode
]
:
(
modeExtensions
[
mode
]
=
{
}
)
;
copyObj
(
properties
exts
)
;
}
;
CodeMirror
.
defineExtension
=
function
(
name
func
)
{
CodeMirror
.
prototype
[
name
]
=
func
;
}
;
CodeMirror
.
defineDocExtension
=
function
(
name
func
)
{
Doc
.
prototype
[
name
]
=
func
;
}
;
CodeMirror
.
defineOption
=
option
;
var
initHooks
=
[
]
;
CodeMirror
.
defineInitHook
=
function
(
f
)
{
initHooks
.
push
(
f
)
;
}
;
var
helpers
=
CodeMirror
.
helpers
=
{
}
;
CodeMirror
.
registerHelper
=
function
(
type
name
value
)
{
if
(
!
helpers
.
hasOwnProperty
(
type
)
)
helpers
[
type
]
=
CodeMirror
[
type
]
=
{
_global
:
[
]
}
;
helpers
[
type
]
[
name
]
=
value
;
}
;
CodeMirror
.
registerGlobalHelper
=
function
(
type
name
predicate
value
)
{
CodeMirror
.
registerHelper
(
type
name
value
)
;
helpers
[
type
]
.
_global
.
push
(
{
pred
:
predicate
val
:
value
}
)
;
}
;
var
copyState
=
CodeMirror
.
copyState
=
function
(
mode
state
)
{
if
(
state
=
=
=
true
)
return
state
;
if
(
mode
.
copyState
)
return
mode
.
copyState
(
state
)
;
var
nstate
=
{
}
;
for
(
var
n
in
state
)
{
var
val
=
state
[
n
]
;
if
(
val
instanceof
Array
)
val
=
val
.
concat
(
[
]
)
;
nstate
[
n
]
=
val
;
}
return
nstate
;
}
;
var
startState
=
CodeMirror
.
startState
=
function
(
mode
a1
a2
)
{
return
mode
.
startState
?
mode
.
startState
(
a1
a2
)
:
true
;
}
;
CodeMirror
.
innerMode
=
function
(
mode
state
)
{
while
(
mode
.
innerMode
)
{
var
info
=
mode
.
innerMode
(
state
)
;
if
(
!
info
|
|
info
.
mode
=
=
mode
)
break
;
state
=
info
.
state
;
mode
=
info
.
mode
;
}
return
info
|
|
{
mode
:
mode
state
:
state
}
;
}
;
var
commands
=
CodeMirror
.
commands
=
{
selectAll
:
function
(
cm
)
{
cm
.
setSelection
(
Pos
(
cm
.
firstLine
(
)
0
)
Pos
(
cm
.
lastLine
(
)
)
sel_dontScroll
)
;
}
singleSelection
:
function
(
cm
)
{
cm
.
setSelection
(
cm
.
getCursor
(
"
anchor
"
)
cm
.
getCursor
(
"
head
"
)
sel_dontScroll
)
;
}
killLine
:
function
(
cm
)
{
deleteNearSelection
(
cm
function
(
range
)
{
if
(
range
.
empty
(
)
)
{
var
len
=
getLine
(
cm
.
doc
range
.
head
.
line
)
.
text
.
length
;
if
(
range
.
head
.
ch
=
=
len
&
&
range
.
head
.
line
<
cm
.
lastLine
(
)
)
return
{
from
:
range
.
head
to
:
Pos
(
range
.
head
.
line
+
1
0
)
}
;
else
return
{
from
:
range
.
head
to
:
Pos
(
range
.
head
.
line
len
)
}
;
}
else
{
return
{
from
:
range
.
from
(
)
to
:
range
.
to
(
)
}
;
}
}
)
;
}
deleteLine
:
function
(
cm
)
{
deleteNearSelection
(
cm
function
(
range
)
{
return
{
from
:
Pos
(
range
.
from
(
)
.
line
0
)
to
:
clipPos
(
cm
.
doc
Pos
(
range
.
to
(
)
.
line
+
1
0
)
)
}
;
}
)
;
}
delLineLeft
:
function
(
cm
)
{
deleteNearSelection
(
cm
function
(
range
)
{
return
{
from
:
Pos
(
range
.
from
(
)
.
line
0
)
to
:
range
.
from
(
)
}
;
}
)
;
}
delWrappedLineLeft
:
function
(
cm
)
{
deleteNearSelection
(
cm
function
(
range
)
{
var
top
=
cm
.
charCoords
(
range
.
head
"
div
"
)
.
top
+
5
;
var
leftPos
=
cm
.
coordsChar
(
{
left
:
0
top
:
top
}
"
div
"
)
;
return
{
from
:
leftPos
to
:
range
.
from
(
)
}
;
}
)
;
}
delWrappedLineRight
:
function
(
cm
)
{
deleteNearSelection
(
cm
function
(
range
)
{
var
top
=
cm
.
charCoords
(
range
.
head
"
div
"
)
.
top
+
5
;
var
rightPos
=
cm
.
coordsChar
(
{
left
:
cm
.
display
.
lineDiv
.
offsetWidth
+
100
top
:
top
}
"
div
"
)
;
return
{
from
:
range
.
from
(
)
to
:
rightPos
}
;
}
)
;
}
undo
:
function
(
cm
)
{
cm
.
undo
(
)
;
}
redo
:
function
(
cm
)
{
cm
.
redo
(
)
;
}
undoSelection
:
function
(
cm
)
{
cm
.
undoSelection
(
)
;
}
redoSelection
:
function
(
cm
)
{
cm
.
redoSelection
(
)
;
}
goDocStart
:
function
(
cm
)
{
cm
.
extendSelection
(
Pos
(
cm
.
firstLine
(
)
0
)
)
;
}
goDocEnd
:
function
(
cm
)
{
cm
.
extendSelection
(
Pos
(
cm
.
lastLine
(
)
)
)
;
}
goLineStart
:
function
(
cm
)
{
cm
.
extendSelectionsBy
(
function
(
range
)
{
return
lineStart
(
cm
range
.
head
.
line
)
;
}
{
origin
:
"
+
move
"
bias
:
1
}
)
;
}
goLineStartSmart
:
function
(
cm
)
{
cm
.
extendSelectionsBy
(
function
(
range
)
{
return
lineStartSmart
(
cm
range
.
head
)
;
}
{
origin
:
"
+
move
"
bias
:
1
}
)
;
}
goLineEnd
:
function
(
cm
)
{
cm
.
extendSelectionsBy
(
function
(
range
)
{
return
lineEnd
(
cm
range
.
head
.
line
)
;
}
{
origin
:
"
+
move
"
bias
:
-
1
}
)
;
}
goLineRight
:
function
(
cm
)
{
cm
.
extendSelectionsBy
(
function
(
range
)
{
var
top
=
cm
.
charCoords
(
range
.
head
"
div
"
)
.
top
+
5
;
return
cm
.
coordsChar
(
{
left
:
cm
.
display
.
lineDiv
.
offsetWidth
+
100
top
:
top
}
"
div
"
)
;
}
sel_move
)
;
}
goLineLeft
:
function
(
cm
)
{
cm
.
extendSelectionsBy
(
function
(
range
)
{
var
top
=
cm
.
charCoords
(
range
.
head
"
div
"
)
.
top
+
5
;
return
cm
.
coordsChar
(
{
left
:
0
top
:
top
}
"
div
"
)
;
}
sel_move
)
;
}
goLineLeftSmart
:
function
(
cm
)
{
cm
.
extendSelectionsBy
(
function
(
range
)
{
var
top
=
cm
.
charCoords
(
range
.
head
"
div
"
)
.
top
+
5
;
var
pos
=
cm
.
coordsChar
(
{
left
:
0
top
:
top
}
"
div
"
)
;
if
(
pos
.
ch
<
cm
.
getLine
(
pos
.
line
)
.
search
(
/
\
S
/
)
)
return
lineStartSmart
(
cm
range
.
head
)
;
return
pos
;
}
sel_move
)
;
}
goLineUp
:
function
(
cm
)
{
cm
.
moveV
(
-
1
"
line
"
)
;
}
goLineDown
:
function
(
cm
)
{
cm
.
moveV
(
1
"
line
"
)
;
}
goPageUp
:
function
(
cm
)
{
cm
.
moveV
(
-
1
"
page
"
)
;
}
goPageDown
:
function
(
cm
)
{
cm
.
moveV
(
1
"
page
"
)
;
}
goCharLeft
:
function
(
cm
)
{
cm
.
moveH
(
-
1
"
char
"
)
;
}
goCharRight
:
function
(
cm
)
{
cm
.
moveH
(
1
"
char
"
)
;
}
goColumnLeft
:
function
(
cm
)
{
cm
.
moveH
(
-
1
"
column
"
)
;
}
goColumnRight
:
function
(
cm
)
{
cm
.
moveH
(
1
"
column
"
)
;
}
goWordLeft
:
function
(
cm
)
{
cm
.
moveH
(
-
1
"
word
"
)
;
}
goGroupRight
:
function
(
cm
)
{
cm
.
moveH
(
1
"
group
"
)
;
}
goGroupLeft
:
function
(
cm
)
{
cm
.
moveH
(
-
1
"
group
"
)
;
}
goWordRight
:
function
(
cm
)
{
cm
.
moveH
(
1
"
word
"
)
;
}
delCharBefore
:
function
(
cm
)
{
cm
.
deleteH
(
-
1
"
char
"
)
;
}
delCharAfter
:
function
(
cm
)
{
cm
.
deleteH
(
1
"
char
"
)
;
}
delWordBefore
:
function
(
cm
)
{
cm
.
deleteH
(
-
1
"
word
"
)
;
}
delWordAfter
:
function
(
cm
)
{
cm
.
deleteH
(
1
"
word
"
)
;
}
delGroupBefore
:
function
(
cm
)
{
cm
.
deleteH
(
-
1
"
group
"
)
;
}
delGroupAfter
:
function
(
cm
)
{
cm
.
deleteH
(
1
"
group
"
)
;
}
indentAuto
:
function
(
cm
)
{
cm
.
indentSelection
(
"
smart
"
)
;
}
indentMore
:
function
(
cm
)
{
cm
.
indentSelection
(
"
add
"
)
;
}
indentLess
:
function
(
cm
)
{
cm
.
indentSelection
(
"
subtract
"
)
;
}
insertTab
:
function
(
cm
)
{
cm
.
replaceSelection
(
"
\
t
"
)
;
}
insertSoftTab
:
function
(
cm
)
{
var
spaces
=
[
]
ranges
=
cm
.
listSelections
(
)
tabSize
=
cm
.
options
.
tabSize
;
for
(
var
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
var
pos
=
ranges
[
i
]
.
from
(
)
;
var
col
=
countColumn
(
cm
.
getLine
(
pos
.
line
)
pos
.
ch
tabSize
)
;
spaces
.
push
(
spaceStr
(
tabSize
-
col
%
tabSize
)
)
;
}
cm
.
replaceSelections
(
spaces
)
;
}
defaultTab
:
function
(
cm
)
{
if
(
cm
.
somethingSelected
(
)
)
cm
.
indentSelection
(
"
add
"
)
;
else
cm
.
execCommand
(
"
insertTab
"
)
;
}
transposeChars
:
function
(
cm
)
{
runInOp
(
cm
function
(
)
{
var
ranges
=
cm
.
listSelections
(
)
newSel
=
[
]
;
for
(
var
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
var
cur
=
ranges
[
i
]
.
head
line
=
getLine
(
cm
.
doc
cur
.
line
)
.
text
;
if
(
line
)
{
if
(
cur
.
ch
=
=
line
.
length
)
cur
=
new
Pos
(
cur
.
line
cur
.
ch
-
1
)
;
if
(
cur
.
ch
>
0
)
{
cur
=
new
Pos
(
cur
.
line
cur
.
ch
+
1
)
;
cm
.
replaceRange
(
line
.
charAt
(
cur
.
ch
-
1
)
+
line
.
charAt
(
cur
.
ch
-
2
)
Pos
(
cur
.
line
cur
.
ch
-
2
)
cur
"
+
transpose
"
)
;
}
else
if
(
cur
.
line
>
cm
.
doc
.
first
)
{
var
prev
=
getLine
(
cm
.
doc
cur
.
line
-
1
)
.
text
;
if
(
prev
)
cm
.
replaceRange
(
line
.
charAt
(
0
)
+
cm
.
doc
.
lineSeparator
(
)
+
prev
.
charAt
(
prev
.
length
-
1
)
Pos
(
cur
.
line
-
1
prev
.
length
-
1
)
Pos
(
cur
.
line
1
)
"
+
transpose
"
)
;
}
}
newSel
.
push
(
new
Range
(
cur
cur
)
)
;
}
cm
.
setSelections
(
newSel
)
;
}
)
;
}
newlineAndIndent
:
function
(
cm
)
{
runInOp
(
cm
function
(
)
{
var
len
=
cm
.
listSelections
(
)
.
length
;
for
(
var
i
=
0
;
i
<
len
;
i
+
+
)
{
var
range
=
cm
.
listSelections
(
)
[
i
]
;
cm
.
replaceRange
(
cm
.
doc
.
lineSeparator
(
)
range
.
anchor
range
.
head
"
+
input
"
)
;
cm
.
indentLine
(
range
.
from
(
)
.
line
+
1
null
true
)
;
}
ensureCursorVisible
(
cm
)
;
}
)
;
}
openLine
:
function
(
cm
)
{
cm
.
replaceSelection
(
"
\
n
"
"
start
"
)
}
toggleOverwrite
:
function
(
cm
)
{
cm
.
toggleOverwrite
(
)
;
}
}
;
var
keyMap
=
CodeMirror
.
keyMap
=
{
}
;
keyMap
.
basic
=
{
"
Left
"
:
"
goCharLeft
"
"
Right
"
:
"
goCharRight
"
"
Up
"
:
"
goLineUp
"
"
Down
"
:
"
goLineDown
"
"
End
"
:
"
goLineEnd
"
"
Home
"
:
"
goLineStartSmart
"
"
PageUp
"
:
"
goPageUp
"
"
PageDown
"
:
"
goPageDown
"
"
Delete
"
:
"
delCharAfter
"
"
Backspace
"
:
"
delCharBefore
"
"
Shift
-
Backspace
"
:
"
delCharBefore
"
"
Tab
"
:
"
defaultTab
"
"
Shift
-
Tab
"
:
"
indentAuto
"
"
Enter
"
:
"
newlineAndIndent
"
"
Insert
"
:
"
toggleOverwrite
"
"
Esc
"
:
"
singleSelection
"
}
;
keyMap
.
pcDefault
=
{
"
Ctrl
-
A
"
:
"
selectAll
"
"
Ctrl
-
D
"
:
"
deleteLine
"
"
Ctrl
-
Z
"
:
"
undo
"
"
Shift
-
Ctrl
-
Z
"
:
"
redo
"
"
Ctrl
-
Y
"
:
"
redo
"
"
Ctrl
-
Home
"
:
"
goDocStart
"
"
Ctrl
-
End
"
:
"
goDocEnd
"
"
Ctrl
-
Up
"
:
"
goLineUp
"
"
Ctrl
-
Down
"
:
"
goLineDown
"
"
Ctrl
-
Left
"
:
"
goGroupLeft
"
"
Ctrl
-
Right
"
:
"
goGroupRight
"
"
Alt
-
Left
"
:
"
goLineStart
"
"
Alt
-
Right
"
:
"
goLineEnd
"
"
Ctrl
-
Backspace
"
:
"
delGroupBefore
"
"
Ctrl
-
Delete
"
:
"
delGroupAfter
"
"
Ctrl
-
S
"
:
"
save
"
"
Ctrl
-
F
"
:
"
find
"
"
Ctrl
-
G
"
:
"
findNext
"
"
Shift
-
Ctrl
-
G
"
:
"
findPrev
"
"
Shift
-
Ctrl
-
F
"
:
"
replace
"
"
Shift
-
Ctrl
-
R
"
:
"
replaceAll
"
"
Ctrl
-
[
"
:
"
indentLess
"
"
Ctrl
-
]
"
:
"
indentMore
"
"
Ctrl
-
U
"
:
"
undoSelection
"
"
Shift
-
Ctrl
-
U
"
:
"
redoSelection
"
"
Alt
-
U
"
:
"
redoSelection
"
fallthrough
:
"
basic
"
}
;
keyMap
.
emacsy
=
{
"
Ctrl
-
F
"
:
"
goCharRight
"
"
Ctrl
-
B
"
:
"
goCharLeft
"
"
Ctrl
-
P
"
:
"
goLineUp
"
"
Ctrl
-
N
"
:
"
goLineDown
"
"
Alt
-
F
"
:
"
goWordRight
"
"
Alt
-
B
"
:
"
goWordLeft
"
"
Ctrl
-
A
"
:
"
goLineStart
"
"
Ctrl
-
E
"
:
"
goLineEnd
"
"
Ctrl
-
V
"
:
"
goPageDown
"
"
Shift
-
Ctrl
-
V
"
:
"
goPageUp
"
"
Ctrl
-
D
"
:
"
delCharAfter
"
"
Ctrl
-
H
"
:
"
delCharBefore
"
"
Alt
-
D
"
:
"
delWordAfter
"
"
Alt
-
Backspace
"
:
"
delWordBefore
"
"
Ctrl
-
K
"
:
"
killLine
"
"
Ctrl
-
T
"
:
"
transposeChars
"
"
Ctrl
-
O
"
:
"
openLine
"
}
;
keyMap
.
macDefault
=
{
"
Cmd
-
A
"
:
"
selectAll
"
"
Cmd
-
D
"
:
"
deleteLine
"
"
Cmd
-
Z
"
:
"
undo
"
"
Shift
-
Cmd
-
Z
"
:
"
redo
"
"
Cmd
-
Y
"
:
"
redo
"
"
Cmd
-
Home
"
:
"
goDocStart
"
"
Cmd
-
Up
"
:
"
goDocStart
"
"
Cmd
-
End
"
:
"
goDocEnd
"
"
Cmd
-
Down
"
:
"
goDocEnd
"
"
Alt
-
Left
"
:
"
goGroupLeft
"
"
Alt
-
Right
"
:
"
goGroupRight
"
"
Cmd
-
Left
"
:
"
goLineLeft
"
"
Cmd
-
Right
"
:
"
goLineRight
"
"
Alt
-
Backspace
"
:
"
delGroupBefore
"
"
Ctrl
-
Alt
-
Backspace
"
:
"
delGroupAfter
"
"
Alt
-
Delete
"
:
"
delGroupAfter
"
"
Cmd
-
S
"
:
"
save
"
"
Cmd
-
F
"
:
"
find
"
"
Cmd
-
G
"
:
"
findNext
"
"
Shift
-
Cmd
-
G
"
:
"
findPrev
"
"
Cmd
-
Alt
-
F
"
:
"
replace
"
"
Shift
-
Cmd
-
Alt
-
F
"
:
"
replaceAll
"
"
Cmd
-
[
"
:
"
indentLess
"
"
Cmd
-
]
"
:
"
indentMore
"
"
Cmd
-
Backspace
"
:
"
delWrappedLineLeft
"
"
Cmd
-
Delete
"
:
"
delWrappedLineRight
"
"
Cmd
-
U
"
:
"
undoSelection
"
"
Shift
-
Cmd
-
U
"
:
"
redoSelection
"
"
Ctrl
-
Up
"
:
"
goDocStart
"
"
Ctrl
-
Down
"
:
"
goDocEnd
"
fallthrough
:
[
"
basic
"
"
emacsy
"
]
}
;
keyMap
[
"
default
"
]
=
mac
?
keyMap
.
macDefault
:
keyMap
.
pcDefault
;
function
normalizeKeyName
(
name
)
{
var
parts
=
name
.
split
(
/
-
(
?
!
)
/
)
name
=
parts
[
parts
.
length
-
1
]
;
var
alt
ctrl
shift
cmd
;
for
(
var
i
=
0
;
i
<
parts
.
length
-
1
;
i
+
+
)
{
var
mod
=
parts
[
i
]
;
if
(
/
^
(
cmd
|
meta
|
m
)
/
i
.
test
(
mod
)
)
cmd
=
true
;
else
if
(
/
^
a
(
lt
)
?
/
i
.
test
(
mod
)
)
alt
=
true
;
else
if
(
/
^
(
c
|
ctrl
|
control
)
/
i
.
test
(
mod
)
)
ctrl
=
true
;
else
if
(
/
^
s
(
hift
)
/
i
.
test
(
mod
)
)
shift
=
true
;
else
throw
new
Error
(
"
Unrecognized
modifier
name
:
"
+
mod
)
;
}
if
(
alt
)
name
=
"
Alt
-
"
+
name
;
if
(
ctrl
)
name
=
"
Ctrl
-
"
+
name
;
if
(
cmd
)
name
=
"
Cmd
-
"
+
name
;
if
(
shift
)
name
=
"
Shift
-
"
+
name
;
return
name
;
}
CodeMirror
.
normalizeKeyMap
=
function
(
keymap
)
{
var
copy
=
{
}
;
for
(
var
keyname
in
keymap
)
if
(
keymap
.
hasOwnProperty
(
keyname
)
)
{
var
value
=
keymap
[
keyname
]
;
if
(
/
^
(
name
|
fallthrough
|
(
de
|
at
)
tach
)
/
.
test
(
keyname
)
)
continue
;
if
(
value
=
=
"
.
.
.
"
)
{
delete
keymap
[
keyname
]
;
continue
;
}
var
keys
=
map
(
keyname
.
split
(
"
"
)
normalizeKeyName
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
val
name
;
if
(
i
=
=
keys
.
length
-
1
)
{
name
=
keys
.
join
(
"
"
)
;
val
=
value
;
}
else
{
name
=
keys
.
slice
(
0
i
+
1
)
.
join
(
"
"
)
;
val
=
"
.
.
.
"
;
}
var
prev
=
copy
[
name
]
;
if
(
!
prev
)
copy
[
name
]
=
val
;
else
if
(
prev
!
=
val
)
throw
new
Error
(
"
Inconsistent
bindings
for
"
+
name
)
;
}
delete
keymap
[
keyname
]
;
}
for
(
var
prop
in
copy
)
keymap
[
prop
]
=
copy
[
prop
]
;
return
keymap
;
}
;
var
lookupKey
=
CodeMirror
.
lookupKey
=
function
(
key
map
handle
context
)
{
map
=
getKeyMap
(
map
)
;
var
found
=
map
.
call
?
map
.
call
(
key
context
)
:
map
[
key
]
;
if
(
found
=
=
=
false
)
return
"
nothing
"
;
if
(
found
=
=
=
"
.
.
.
"
)
return
"
multi
"
;
if
(
found
!
=
null
&
&
handle
(
found
)
)
return
"
handled
"
;
if
(
map
.
fallthrough
)
{
if
(
Object
.
prototype
.
toString
.
call
(
map
.
fallthrough
)
!
=
"
[
object
Array
]
"
)
return
lookupKey
(
key
map
.
fallthrough
handle
context
)
;
for
(
var
i
=
0
;
i
<
map
.
fallthrough
.
length
;
i
+
+
)
{
var
result
=
lookupKey
(
key
map
.
fallthrough
[
i
]
handle
context
)
;
if
(
result
)
return
result
;
}
}
}
;
var
isModifierKey
=
CodeMirror
.
isModifierKey
=
function
(
value
)
{
var
name
=
typeof
value
=
=
"
string
"
?
value
:
keyNames
[
value
.
keyCode
]
;
return
name
=
=
"
Ctrl
"
|
|
name
=
=
"
Alt
"
|
|
name
=
=
"
Shift
"
|
|
name
=
=
"
Mod
"
;
}
;
var
keyName
=
CodeMirror
.
keyName
=
function
(
event
noShift
)
{
if
(
presto
&
&
event
.
keyCode
=
=
34
&
&
event
[
"
char
"
]
)
return
false
;
var
base
=
keyNames
[
event
.
keyCode
]
name
=
base
;
if
(
name
=
=
null
|
|
event
.
altGraphKey
)
return
false
;
if
(
event
.
altKey
&
&
base
!
=
"
Alt
"
)
name
=
"
Alt
-
"
+
name
;
if
(
(
flipCtrlCmd
?
event
.
metaKey
:
event
.
ctrlKey
)
&
&
base
!
=
"
Ctrl
"
)
name
=
"
Ctrl
-
"
+
name
;
if
(
(
flipCtrlCmd
?
event
.
ctrlKey
:
event
.
metaKey
)
&
&
base
!
=
"
Cmd
"
)
name
=
"
Cmd
-
"
+
name
;
if
(
!
noShift
&
&
event
.
shiftKey
&
&
base
!
=
"
Shift
"
)
name
=
"
Shift
-
"
+
name
;
return
name
;
}
;
function
getKeyMap
(
val
)
{
return
typeof
val
=
=
"
string
"
?
keyMap
[
val
]
:
val
;
}
CodeMirror
.
fromTextArea
=
function
(
textarea
options
)
{
options
=
options
?
copyObj
(
options
)
:
{
}
;
options
.
value
=
textarea
.
value
;
if
(
!
options
.
tabindex
&
&
textarea
.
tabIndex
)
options
.
tabindex
=
textarea
.
tabIndex
;
if
(
!
options
.
placeholder
&
&
textarea
.
placeholder
)
options
.
placeholder
=
textarea
.
placeholder
;
if
(
options
.
autofocus
=
=
null
)
{
var
hasFocus
=
activeElt
(
)
;
options
.
autofocus
=
hasFocus
=
=
textarea
|
|
textarea
.
getAttribute
(
"
autofocus
"
)
!
=
null
&
&
hasFocus
=
=
document
.
body
;
}
function
save
(
)
{
textarea
.
value
=
cm
.
getValue
(
)
;
}
if
(
textarea
.
form
)
{
on
(
textarea
.
form
"
submit
"
save
)
;
if
(
!
options
.
leaveSubmitMethodAlone
)
{
var
form
=
textarea
.
form
realSubmit
=
form
.
submit
;
try
{
var
wrappedSubmit
=
form
.
submit
=
function
(
)
{
save
(
)
;
form
.
submit
=
realSubmit
;
form
.
submit
(
)
;
form
.
submit
=
wrappedSubmit
;
}
;
}
catch
(
e
)
{
}
}
}
options
.
finishInit
=
function
(
cm
)
{
cm
.
save
=
save
;
cm
.
getTextArea
=
function
(
)
{
return
textarea
;
}
;
cm
.
toTextArea
=
function
(
)
{
cm
.
toTextArea
=
isNaN
;
save
(
)
;
textarea
.
parentNode
.
removeChild
(
cm
.
getWrapperElement
(
)
)
;
textarea
.
style
.
display
=
"
"
;
if
(
textarea
.
form
)
{
off
(
textarea
.
form
"
submit
"
save
)
;
if
(
typeof
textarea
.
form
.
submit
=
=
"
function
"
)
textarea
.
form
.
submit
=
realSubmit
;
}
}
;
}
;
textarea
.
style
.
display
=
"
none
"
;
var
cm
=
CodeMirror
(
function
(
node
)
{
textarea
.
parentNode
.
insertBefore
(
node
textarea
.
nextSibling
)
;
}
options
)
;
return
cm
;
}
;
var
StringStream
=
CodeMirror
.
StringStream
=
function
(
string
tabSize
)
{
this
.
pos
=
this
.
start
=
0
;
this
.
string
=
string
;
this
.
tabSize
=
tabSize
|
|
8
;
this
.
lastColumnPos
=
this
.
lastColumnValue
=
0
;
this
.
lineStart
=
0
;
}
;
StringStream
.
prototype
=
{
eol
:
function
(
)
{
return
this
.
pos
>
=
this
.
string
.
length
;
}
sol
:
function
(
)
{
return
this
.
pos
=
=
this
.
lineStart
;
}
peek
:
function
(
)
{
return
this
.
string
.
charAt
(
this
.
pos
)
|
|
undefined
;
}
next
:
function
(
)
{
if
(
this
.
pos
<
this
.
string
.
length
)
return
this
.
string
.
charAt
(
this
.
pos
+
+
)
;
}
eat
:
function
(
match
)
{
var
ch
=
this
.
string
.
charAt
(
this
.
pos
)
;
if
(
typeof
match
=
=
"
string
"
)
var
ok
=
ch
=
=
match
;
else
var
ok
=
ch
&
&
(
match
.
test
?
match
.
test
(
ch
)
:
match
(
ch
)
)
;
if
(
ok
)
{
+
+
this
.
pos
;
return
ch
;
}
}
eatWhile
:
function
(
match
)
{
var
start
=
this
.
pos
;
while
(
this
.
eat
(
match
)
)
{
}
return
this
.
pos
>
start
;
}
eatSpace
:
function
(
)
{
var
start
=
this
.
pos
;
while
(
/
[
\
s
\
u00a0
]
/
.
test
(
this
.
string
.
charAt
(
this
.
pos
)
)
)
+
+
this
.
pos
;
return
this
.
pos
>
start
;
}
skipToEnd
:
function
(
)
{
this
.
pos
=
this
.
string
.
length
;
}
skipTo
:
function
(
ch
)
{
var
found
=
this
.
string
.
indexOf
(
ch
this
.
pos
)
;
if
(
found
>
-
1
)
{
this
.
pos
=
found
;
return
true
;
}
}
backUp
:
function
(
n
)
{
this
.
pos
-
=
n
;
}
column
:
function
(
)
{
if
(
this
.
lastColumnPos
<
this
.
start
)
{
this
.
lastColumnValue
=
countColumn
(
this
.
string
this
.
start
this
.
tabSize
this
.
lastColumnPos
this
.
lastColumnValue
)
;
this
.
lastColumnPos
=
this
.
start
;
}
return
this
.
lastColumnValue
-
(
this
.
lineStart
?
countColumn
(
this
.
string
this
.
lineStart
this
.
tabSize
)
:
0
)
;
}
indentation
:
function
(
)
{
return
countColumn
(
this
.
string
null
this
.
tabSize
)
-
(
this
.
lineStart
?
countColumn
(
this
.
string
this
.
lineStart
this
.
tabSize
)
:
0
)
;
}
match
:
function
(
pattern
consume
caseInsensitive
)
{
if
(
typeof
pattern
=
=
"
string
"
)
{
var
cased
=
function
(
str
)
{
return
caseInsensitive
?
str
.
toLowerCase
(
)
:
str
;
}
;
var
substr
=
this
.
string
.
substr
(
this
.
pos
pattern
.
length
)
;
if
(
cased
(
substr
)
=
=
cased
(
pattern
)
)
{
if
(
consume
!
=
=
false
)
this
.
pos
+
=
pattern
.
length
;
return
true
;
}
}
else
{
var
match
=
this
.
string
.
slice
(
this
.
pos
)
.
match
(
pattern
)
;
if
(
match
&
&
match
.
index
>
0
)
return
null
;
if
(
match
&
&
consume
!
=
=
false
)
this
.
pos
+
=
match
[
0
]
.
length
;
return
match
;
}
}
current
:
function
(
)
{
return
this
.
string
.
slice
(
this
.
start
this
.
pos
)
;
}
hideFirstChars
:
function
(
n
inner
)
{
this
.
lineStart
+
=
n
;
try
{
return
inner
(
)
;
}
finally
{
this
.
lineStart
-
=
n
;
}
}
}
;
var
nextMarkerId
=
0
;
var
TextMarker
=
CodeMirror
.
TextMarker
=
function
(
doc
type
)
{
this
.
lines
=
[
]
;
this
.
type
=
type
;
this
.
doc
=
doc
;
this
.
id
=
+
+
nextMarkerId
;
}
;
eventMixin
(
TextMarker
)
;
TextMarker
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
explicitlyCleared
)
return
;
var
cm
=
this
.
doc
.
cm
withOp
=
cm
&
&
!
cm
.
curOp
;
if
(
withOp
)
startOperation
(
cm
)
;
if
(
hasHandler
(
this
"
clear
"
)
)
{
var
found
=
this
.
find
(
)
;
if
(
found
)
signalLater
(
this
"
clear
"
found
.
from
found
.
to
)
;
}
var
min
=
null
max
=
null
;
for
(
var
i
=
0
;
i
<
this
.
lines
.
length
;
+
+
i
)
{
var
line
=
this
.
lines
[
i
]
;
var
span
=
getMarkedSpanFor
(
line
.
markedSpans
this
)
;
if
(
cm
&
&
!
this
.
collapsed
)
regLineChange
(
cm
lineNo
(
line
)
"
text
"
)
;
else
if
(
cm
)
{
if
(
span
.
to
!
=
null
)
max
=
lineNo
(
line
)
;
if
(
span
.
from
!
=
null
)
min
=
lineNo
(
line
)
;
}
line
.
markedSpans
=
removeMarkedSpan
(
line
.
markedSpans
span
)
;
if
(
span
.
from
=
=
null
&
&
this
.
collapsed
&
&
!
lineIsHidden
(
this
.
doc
line
)
&
&
cm
)
updateLineHeight
(
line
textHeight
(
cm
.
display
)
)
;
}
if
(
cm
&
&
this
.
collapsed
&
&
!
cm
.
options
.
lineWrapping
)
for
(
var
i
=
0
;
i
<
this
.
lines
.
length
;
+
+
i
)
{
var
visual
=
visualLine
(
this
.
lines
[
i
]
)
len
=
lineLength
(
visual
)
;
if
(
len
>
cm
.
display
.
maxLineLength
)
{
cm
.
display
.
maxLine
=
visual
;
cm
.
display
.
maxLineLength
=
len
;
cm
.
display
.
maxLineChanged
=
true
;
}
}
if
(
min
!
=
null
&
&
cm
&
&
this
.
collapsed
)
regChange
(
cm
min
max
+
1
)
;
this
.
lines
.
length
=
0
;
this
.
explicitlyCleared
=
true
;
if
(
this
.
atomic
&
&
this
.
doc
.
cantEdit
)
{
this
.
doc
.
cantEdit
=
false
;
if
(
cm
)
reCheckSelection
(
cm
.
doc
)
;
}
if
(
cm
)
signalLater
(
cm
"
markerCleared
"
cm
this
)
;
if
(
withOp
)
endOperation
(
cm
)
;
if
(
this
.
parent
)
this
.
parent
.
clear
(
)
;
}
;
TextMarker
.
prototype
.
find
=
function
(
side
lineObj
)
{
if
(
side
=
=
null
&
&
this
.
type
=
=
"
bookmark
"
)
side
=
1
;
var
from
to
;
for
(
var
i
=
0
;
i
<
this
.
lines
.
length
;
+
+
i
)
{
var
line
=
this
.
lines
[
i
]
;
var
span
=
getMarkedSpanFor
(
line
.
markedSpans
this
)
;
if
(
span
.
from
!
=
null
)
{
from
=
Pos
(
lineObj
?
line
:
lineNo
(
line
)
span
.
from
)
;
if
(
side
=
=
-
1
)
return
from
;
}
if
(
span
.
to
!
=
null
)
{
to
=
Pos
(
lineObj
?
line
:
lineNo
(
line
)
span
.
to
)
;
if
(
side
=
=
1
)
return
to
;
}
}
return
from
&
&
{
from
:
from
to
:
to
}
;
}
;
TextMarker
.
prototype
.
changed
=
function
(
)
{
var
pos
=
this
.
find
(
-
1
true
)
widget
=
this
cm
=
this
.
doc
.
cm
;
if
(
!
pos
|
|
!
cm
)
return
;
runInOp
(
cm
function
(
)
{
var
line
=
pos
.
line
lineN
=
lineNo
(
pos
.
line
)
;
var
view
=
findViewForLine
(
cm
lineN
)
;
if
(
view
)
{
clearLineMeasurementCacheFor
(
view
)
;
cm
.
curOp
.
selectionChanged
=
cm
.
curOp
.
forceUpdate
=
true
;
}
cm
.
curOp
.
updateMaxLine
=
true
;
if
(
!
lineIsHidden
(
widget
.
doc
line
)
&
&
widget
.
height
!
=
null
)
{
var
oldHeight
=
widget
.
height
;
widget
.
height
=
null
;
var
dHeight
=
widgetHeight
(
widget
)
-
oldHeight
;
if
(
dHeight
)
updateLineHeight
(
line
line
.
height
+
dHeight
)
;
}
}
)
;
}
;
TextMarker
.
prototype
.
attachLine
=
function
(
line
)
{
if
(
!
this
.
lines
.
length
&
&
this
.
doc
.
cm
)
{
var
op
=
this
.
doc
.
cm
.
curOp
;
if
(
!
op
.
maybeHiddenMarkers
|
|
indexOf
(
op
.
maybeHiddenMarkers
this
)
=
=
-
1
)
(
op
.
maybeUnhiddenMarkers
|
|
(
op
.
maybeUnhiddenMarkers
=
[
]
)
)
.
push
(
this
)
;
}
this
.
lines
.
push
(
line
)
;
}
;
TextMarker
.
prototype
.
detachLine
=
function
(
line
)
{
this
.
lines
.
splice
(
indexOf
(
this
.
lines
line
)
1
)
;
if
(
!
this
.
lines
.
length
&
&
this
.
doc
.
cm
)
{
var
op
=
this
.
doc
.
cm
.
curOp
;
(
op
.
maybeHiddenMarkers
|
|
(
op
.
maybeHiddenMarkers
=
[
]
)
)
.
push
(
this
)
;
}
}
;
var
nextMarkerId
=
0
;
function
markText
(
doc
from
to
options
type
)
{
if
(
options
&
&
options
.
shared
)
return
markTextShared
(
doc
from
to
options
type
)
;
if
(
doc
.
cm
&
&
!
doc
.
cm
.
curOp
)
return
operation
(
doc
.
cm
markText
)
(
doc
from
to
options
type
)
;
var
marker
=
new
TextMarker
(
doc
type
)
diff
=
cmp
(
from
to
)
;
if
(
options
)
copyObj
(
options
marker
false
)
;
if
(
diff
>
0
|
|
diff
=
=
0
&
&
marker
.
clearWhenEmpty
!
=
=
false
)
return
marker
;
if
(
marker
.
replacedWith
)
{
marker
.
collapsed
=
true
;
marker
.
widgetNode
=
elt
(
"
span
"
[
marker
.
replacedWith
]
"
CodeMirror
-
widget
"
)
;
if
(
!
options
.
handleMouseEvents
)
marker
.
widgetNode
.
setAttribute
(
"
cm
-
ignore
-
events
"
"
true
"
)
;
if
(
options
.
insertLeft
)
marker
.
widgetNode
.
insertLeft
=
true
;
}
if
(
marker
.
collapsed
)
{
if
(
conflictingCollapsedRange
(
doc
from
.
line
from
to
marker
)
|
|
from
.
line
!
=
to
.
line
&
&
conflictingCollapsedRange
(
doc
to
.
line
from
to
marker
)
)
throw
new
Error
(
"
Inserting
collapsed
marker
partially
overlapping
an
existing
one
"
)
;
sawCollapsedSpans
=
true
;
}
if
(
marker
.
addToHistory
)
addChangeToHistory
(
doc
{
from
:
from
to
:
to
origin
:
"
markText
"
}
doc
.
sel
NaN
)
;
var
curLine
=
from
.
line
cm
=
doc
.
cm
updateMaxLine
;
doc
.
iter
(
curLine
to
.
line
+
1
function
(
line
)
{
if
(
cm
&
&
marker
.
collapsed
&
&
!
cm
.
options
.
lineWrapping
&
&
visualLine
(
line
)
=
=
cm
.
display
.
maxLine
)
updateMaxLine
=
true
;
if
(
marker
.
collapsed
&
&
curLine
!
=
from
.
line
)
updateLineHeight
(
line
0
)
;
addMarkedSpan
(
line
new
MarkedSpan
(
marker
curLine
=
=
from
.
line
?
from
.
ch
:
null
curLine
=
=
to
.
line
?
to
.
ch
:
null
)
)
;
+
+
curLine
;
}
)
;
if
(
marker
.
collapsed
)
doc
.
iter
(
from
.
line
to
.
line
+
1
function
(
line
)
{
if
(
lineIsHidden
(
doc
line
)
)
updateLineHeight
(
line
0
)
;
}
)
;
if
(
marker
.
clearOnEnter
)
on
(
marker
"
beforeCursorEnter
"
function
(
)
{
marker
.
clear
(
)
;
}
)
;
if
(
marker
.
readOnly
)
{
sawReadOnlySpans
=
true
;
if
(
doc
.
history
.
done
.
length
|
|
doc
.
history
.
undone
.
length
)
doc
.
clearHistory
(
)
;
}
if
(
marker
.
collapsed
)
{
marker
.
id
=
+
+
nextMarkerId
;
marker
.
atomic
=
true
;
}
if
(
cm
)
{
if
(
updateMaxLine
)
cm
.
curOp
.
updateMaxLine
=
true
;
if
(
marker
.
collapsed
)
regChange
(
cm
from
.
line
to
.
line
+
1
)
;
else
if
(
marker
.
className
|
|
marker
.
title
|
|
marker
.
startStyle
|
|
marker
.
endStyle
|
|
marker
.
css
)
for
(
var
i
=
from
.
line
;
i
<
=
to
.
line
;
i
+
+
)
regLineChange
(
cm
i
"
text
"
)
;
if
(
marker
.
atomic
)
reCheckSelection
(
cm
.
doc
)
;
signalLater
(
cm
"
markerAdded
"
cm
marker
)
;
}
return
marker
;
}
var
SharedTextMarker
=
CodeMirror
.
SharedTextMarker
=
function
(
markers
primary
)
{
this
.
markers
=
markers
;
this
.
primary
=
primary
;
for
(
var
i
=
0
;
i
<
markers
.
length
;
+
+
i
)
markers
[
i
]
.
parent
=
this
;
}
;
eventMixin
(
SharedTextMarker
)
;
SharedTextMarker
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
explicitlyCleared
)
return
;
this
.
explicitlyCleared
=
true
;
for
(
var
i
=
0
;
i
<
this
.
markers
.
length
;
+
+
i
)
this
.
markers
[
i
]
.
clear
(
)
;
signalLater
(
this
"
clear
"
)
;
}
;
SharedTextMarker
.
prototype
.
find
=
function
(
side
lineObj
)
{
return
this
.
primary
.
find
(
side
lineObj
)
;
}
;
function
markTextShared
(
doc
from
to
options
type
)
{
options
=
copyObj
(
options
)
;
options
.
shared
=
false
;
var
markers
=
[
markText
(
doc
from
to
options
type
)
]
primary
=
markers
[
0
]
;
var
widget
=
options
.
widgetNode
;
linkedDocs
(
doc
function
(
doc
)
{
if
(
widget
)
options
.
widgetNode
=
widget
.
cloneNode
(
true
)
;
markers
.
push
(
markText
(
doc
clipPos
(
doc
from
)
clipPos
(
doc
to
)
options
type
)
)
;
for
(
var
i
=
0
;
i
<
doc
.
linked
.
length
;
+
+
i
)
if
(
doc
.
linked
[
i
]
.
isParent
)
return
;
primary
=
lst
(
markers
)
;
}
)
;
return
new
SharedTextMarker
(
markers
primary
)
;
}
function
findSharedMarkers
(
doc
)
{
return
doc
.
findMarks
(
Pos
(
doc
.
first
0
)
doc
.
clipPos
(
Pos
(
doc
.
lastLine
(
)
)
)
function
(
m
)
{
return
m
.
parent
;
}
)
;
}
function
copySharedMarkers
(
doc
markers
)
{
for
(
var
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
var
marker
=
markers
[
i
]
pos
=
marker
.
find
(
)
;
var
mFrom
=
doc
.
clipPos
(
pos
.
from
)
mTo
=
doc
.
clipPos
(
pos
.
to
)
;
if
(
cmp
(
mFrom
mTo
)
)
{
var
subMark
=
markText
(
doc
mFrom
mTo
marker
.
primary
marker
.
primary
.
type
)
;
marker
.
markers
.
push
(
subMark
)
;
subMark
.
parent
=
marker
;
}
}
}
function
detachSharedMarkers
(
markers
)
{
for
(
var
i
=
0
;
i
<
markers
.
length
;
i
+
+
)
{
var
marker
=
markers
[
i
]
linked
=
[
marker
.
primary
.
doc
]
;
;
linkedDocs
(
marker
.
primary
.
doc
function
(
d
)
{
linked
.
push
(
d
)
;
}
)
;
for
(
var
j
=
0
;
j
<
marker
.
markers
.
length
;
j
+
+
)
{
var
subMarker
=
marker
.
markers
[
j
]
;
if
(
indexOf
(
linked
subMarker
.
doc
)
=
=
-
1
)
{
subMarker
.
parent
=
null
;
marker
.
markers
.
splice
(
j
-
-
1
)
;
}
}
}
}
function
MarkedSpan
(
marker
from
to
)
{
this
.
marker
=
marker
;
this
.
from
=
from
;
this
.
to
=
to
;
}
function
getMarkedSpanFor
(
spans
marker
)
{
if
(
spans
)
for
(
var
i
=
0
;
i
<
spans
.
length
;
+
+
i
)
{
var
span
=
spans
[
i
]
;
if
(
span
.
marker
=
=
marker
)
return
span
;
}
}
function
removeMarkedSpan
(
spans
span
)
{
for
(
var
r
i
=
0
;
i
<
spans
.
length
;
+
+
i
)
if
(
spans
[
i
]
!
=
span
)
(
r
|
|
(
r
=
[
]
)
)
.
push
(
spans
[
i
]
)
;
return
r
;
}
function
addMarkedSpan
(
line
span
)
{
line
.
markedSpans
=
line
.
markedSpans
?
line
.
markedSpans
.
concat
(
[
span
]
)
:
[
span
]
;
span
.
marker
.
attachLine
(
line
)
;
}
function
markedSpansBefore
(
old
startCh
isInsert
)
{
if
(
old
)
for
(
var
i
=
0
nw
;
i
<
old
.
length
;
+
+
i
)
{
var
span
=
old
[
i
]
marker
=
span
.
marker
;
var
startsBefore
=
span
.
from
=
=
null
|
|
(
marker
.
inclusiveLeft
?
span
.
from
<
=
startCh
:
span
.
from
<
startCh
)
;
if
(
startsBefore
|
|
span
.
from
=
=
startCh
&
&
marker
.
type
=
=
"
bookmark
"
&
&
(
!
isInsert
|
|
!
span
.
marker
.
insertLeft
)
)
{
var
endsAfter
=
span
.
to
=
=
null
|
|
(
marker
.
inclusiveRight
?
span
.
to
>
=
startCh
:
span
.
to
>
startCh
)
;
(
nw
|
|
(
nw
=
[
]
)
)
.
push
(
new
MarkedSpan
(
marker
span
.
from
endsAfter
?
null
:
span
.
to
)
)
;
}
}
return
nw
;
}
function
markedSpansAfter
(
old
endCh
isInsert
)
{
if
(
old
)
for
(
var
i
=
0
nw
;
i
<
old
.
length
;
+
+
i
)
{
var
span
=
old
[
i
]
marker
=
span
.
marker
;
var
endsAfter
=
span
.
to
=
=
null
|
|
(
marker
.
inclusiveRight
?
span
.
to
>
=
endCh
:
span
.
to
>
endCh
)
;
if
(
endsAfter
|
|
span
.
from
=
=
endCh
&
&
marker
.
type
=
=
"
bookmark
"
&
&
(
!
isInsert
|
|
span
.
marker
.
insertLeft
)
)
{
var
startsBefore
=
span
.
from
=
=
null
|
|
(
marker
.
inclusiveLeft
?
span
.
from
<
=
endCh
:
span
.
from
<
endCh
)
;
(
nw
|
|
(
nw
=
[
]
)
)
.
push
(
new
MarkedSpan
(
marker
startsBefore
?
null
:
span
.
from
-
endCh
span
.
to
=
=
null
?
null
:
span
.
to
-
endCh
)
)
;
}
}
return
nw
;
}
function
stretchSpansOverChange
(
doc
change
)
{
if
(
change
.
full
)
return
null
;
var
oldFirst
=
isLine
(
doc
change
.
from
.
line
)
&
&
getLine
(
doc
change
.
from
.
line
)
.
markedSpans
;
var
oldLast
=
isLine
(
doc
change
.
to
.
line
)
&
&
getLine
(
doc
change
.
to
.
line
)
.
markedSpans
;
if
(
!
oldFirst
&
&
!
oldLast
)
return
null
;
var
startCh
=
change
.
from
.
ch
endCh
=
change
.
to
.
ch
isInsert
=
cmp
(
change
.
from
change
.
to
)
=
=
0
;
var
first
=
markedSpansBefore
(
oldFirst
startCh
isInsert
)
;
var
last
=
markedSpansAfter
(
oldLast
endCh
isInsert
)
;
var
sameLine
=
change
.
text
.
length
=
=
1
offset
=
lst
(
change
.
text
)
.
length
+
(
sameLine
?
startCh
:
0
)
;
if
(
first
)
{
for
(
var
i
=
0
;
i
<
first
.
length
;
+
+
i
)
{
var
span
=
first
[
i
]
;
if
(
span
.
to
=
=
null
)
{
var
found
=
getMarkedSpanFor
(
last
span
.
marker
)
;
if
(
!
found
)
span
.
to
=
startCh
;
else
if
(
sameLine
)
span
.
to
=
found
.
to
=
=
null
?
null
:
found
.
to
+
offset
;
}
}
}
if
(
last
)
{
for
(
var
i
=
0
;
i
<
last
.
length
;
+
+
i
)
{
var
span
=
last
[
i
]
;
if
(
span
.
to
!
=
null
)
span
.
to
+
=
offset
;
if
(
span
.
from
=
=
null
)
{
var
found
=
getMarkedSpanFor
(
first
span
.
marker
)
;
if
(
!
found
)
{
span
.
from
=
offset
;
if
(
sameLine
)
(
first
|
|
(
first
=
[
]
)
)
.
push
(
span
)
;
}
}
else
{
span
.
from
+
=
offset
;
if
(
sameLine
)
(
first
|
|
(
first
=
[
]
)
)
.
push
(
span
)
;
}
}
}
if
(
first
)
first
=
clearEmptySpans
(
first
)
;
if
(
last
&
&
last
!
=
first
)
last
=
clearEmptySpans
(
last
)
;
var
newMarkers
=
[
first
]
;
if
(
!
sameLine
)
{
var
gap
=
change
.
text
.
length
-
2
gapMarkers
;
if
(
gap
>
0
&
&
first
)
for
(
var
i
=
0
;
i
<
first
.
length
;
+
+
i
)
if
(
first
[
i
]
.
to
=
=
null
)
(
gapMarkers
|
|
(
gapMarkers
=
[
]
)
)
.
push
(
new
MarkedSpan
(
first
[
i
]
.
marker
null
null
)
)
;
for
(
var
i
=
0
;
i
<
gap
;
+
+
i
)
newMarkers
.
push
(
gapMarkers
)
;
newMarkers
.
push
(
last
)
;
}
return
newMarkers
;
}
function
clearEmptySpans
(
spans
)
{
for
(
var
i
=
0
;
i
<
spans
.
length
;
+
+
i
)
{
var
span
=
spans
[
i
]
;
if
(
span
.
from
!
=
null
&
&
span
.
from
=
=
span
.
to
&
&
span
.
marker
.
clearWhenEmpty
!
=
=
false
)
spans
.
splice
(
i
-
-
1
)
;
}
if
(
!
spans
.
length
)
return
null
;
return
spans
;
}
function
mergeOldSpans
(
doc
change
)
{
var
old
=
getOldSpans
(
doc
change
)
;
var
stretched
=
stretchSpansOverChange
(
doc
change
)
;
if
(
!
old
)
return
stretched
;
if
(
!
stretched
)
return
old
;
for
(
var
i
=
0
;
i
<
old
.
length
;
+
+
i
)
{
var
oldCur
=
old
[
i
]
stretchCur
=
stretched
[
i
]
;
if
(
oldCur
&
&
stretchCur
)
{
spans
:
for
(
var
j
=
0
;
j
<
stretchCur
.
length
;
+
+
j
)
{
var
span
=
stretchCur
[
j
]
;
for
(
var
k
=
0
;
k
<
oldCur
.
length
;
+
+
k
)
if
(
oldCur
[
k
]
.
marker
=
=
span
.
marker
)
continue
spans
;
oldCur
.
push
(
span
)
;
}
}
else
if
(
stretchCur
)
{
old
[
i
]
=
stretchCur
;
}
}
return
old
;
}
function
removeReadOnlyRanges
(
doc
from
to
)
{
var
markers
=
null
;
doc
.
iter
(
from
.
line
to
.
line
+
1
function
(
line
)
{
if
(
line
.
markedSpans
)
for
(
var
i
=
0
;
i
<
line
.
markedSpans
.
length
;
+
+
i
)
{
var
mark
=
line
.
markedSpans
[
i
]
.
marker
;
if
(
mark
.
readOnly
&
&
(
!
markers
|
|
indexOf
(
markers
mark
)
=
=
-
1
)
)
(
markers
|
|
(
markers
=
[
]
)
)
.
push
(
mark
)
;
}
}
)
;
if
(
!
markers
)
return
null
;
var
parts
=
[
{
from
:
from
to
:
to
}
]
;
for
(
var
i
=
0
;
i
<
markers
.
length
;
+
+
i
)
{
var
mk
=
markers
[
i
]
m
=
mk
.
find
(
0
)
;
for
(
var
j
=
0
;
j
<
parts
.
length
;
+
+
j
)
{
var
p
=
parts
[
j
]
;
if
(
cmp
(
p
.
to
m
.
from
)
<
0
|
|
cmp
(
p
.
from
m
.
to
)
>
0
)
continue
;
var
newParts
=
[
j
1
]
dfrom
=
cmp
(
p
.
from
m
.
from
)
dto
=
cmp
(
p
.
to
m
.
to
)
;
if
(
dfrom
<
0
|
|
!
mk
.
inclusiveLeft
&
&
!
dfrom
)
newParts
.
push
(
{
from
:
p
.
from
to
:
m
.
from
}
)
;
if
(
dto
>
0
|
|
!
mk
.
inclusiveRight
&
&
!
dto
)
newParts
.
push
(
{
from
:
m
.
to
to
:
p
.
to
}
)
;
parts
.
splice
.
apply
(
parts
newParts
)
;
j
+
=
newParts
.
length
-
1
;
}
}
return
parts
;
}
function
detachMarkedSpans
(
line
)
{
var
spans
=
line
.
markedSpans
;
if
(
!
spans
)
return
;
for
(
var
i
=
0
;
i
<
spans
.
length
;
+
+
i
)
spans
[
i
]
.
marker
.
detachLine
(
line
)
;
line
.
markedSpans
=
null
;
}
function
attachMarkedSpans
(
line
spans
)
{
if
(
!
spans
)
return
;
for
(
var
i
=
0
;
i
<
spans
.
length
;
+
+
i
)
spans
[
i
]
.
marker
.
attachLine
(
line
)
;
line
.
markedSpans
=
spans
;
}
function
extraLeft
(
marker
)
{
return
marker
.
inclusiveLeft
?
-
1
:
0
;
}
function
extraRight
(
marker
)
{
return
marker
.
inclusiveRight
?
1
:
0
;
}
function
compareCollapsedMarkers
(
a
b
)
{
var
lenDiff
=
a
.
lines
.
length
-
b
.
lines
.
length
;
if
(
lenDiff
!
=
0
)
return
lenDiff
;
var
aPos
=
a
.
find
(
)
bPos
=
b
.
find
(
)
;
var
fromCmp
=
cmp
(
aPos
.
from
bPos
.
from
)
|
|
extraLeft
(
a
)
-
extraLeft
(
b
)
;
if
(
fromCmp
)
return
-
fromCmp
;
var
toCmp
=
cmp
(
aPos
.
to
bPos
.
to
)
|
|
extraRight
(
a
)
-
extraRight
(
b
)
;
if
(
toCmp
)
return
toCmp
;
return
b
.
id
-
a
.
id
;
}
function
collapsedSpanAtSide
(
line
start
)
{
var
sps
=
sawCollapsedSpans
&
&
line
.
markedSpans
found
;
if
(
sps
)
for
(
var
sp
i
=
0
;
i
<
sps
.
length
;
+
+
i
)
{
sp
=
sps
[
i
]
;
if
(
sp
.
marker
.
collapsed
&
&
(
start
?
sp
.
from
:
sp
.
to
)
=
=
null
&
&
(
!
found
|
|
compareCollapsedMarkers
(
found
sp
.
marker
)
<
0
)
)
found
=
sp
.
marker
;
}
return
found
;
}
function
collapsedSpanAtStart
(
line
)
{
return
collapsedSpanAtSide
(
line
true
)
;
}
function
collapsedSpanAtEnd
(
line
)
{
return
collapsedSpanAtSide
(
line
false
)
;
}
function
conflictingCollapsedRange
(
doc
lineNo
from
to
marker
)
{
var
line
=
getLine
(
doc
lineNo
)
;
var
sps
=
sawCollapsedSpans
&
&
line
.
markedSpans
;
if
(
sps
)
for
(
var
i
=
0
;
i
<
sps
.
length
;
+
+
i
)
{
var
sp
=
sps
[
i
]
;
if
(
!
sp
.
marker
.
collapsed
)
continue
;
var
found
=
sp
.
marker
.
find
(
0
)
;
var
fromCmp
=
cmp
(
found
.
from
from
)
|
|
extraLeft
(
sp
.
marker
)
-
extraLeft
(
marker
)
;
var
toCmp
=
cmp
(
found
.
to
to
)
|
|
extraRight
(
sp
.
marker
)
-
extraRight
(
marker
)
;
if
(
fromCmp
>
=
0
&
&
toCmp
<
=
0
|
|
fromCmp
<
=
0
&
&
toCmp
>
=
0
)
continue
;
if
(
fromCmp
<
=
0
&
&
(
sp
.
marker
.
inclusiveRight
&
&
marker
.
inclusiveLeft
?
cmp
(
found
.
to
from
)
>
=
0
:
cmp
(
found
.
to
from
)
>
0
)
|
|
fromCmp
>
=
0
&
&
(
sp
.
marker
.
inclusiveRight
&
&
marker
.
inclusiveLeft
?
cmp
(
found
.
from
to
)
<
=
0
:
cmp
(
found
.
from
to
)
<
0
)
)
return
true
;
}
}
function
visualLine
(
line
)
{
var
merged
;
while
(
merged
=
collapsedSpanAtStart
(
line
)
)
line
=
merged
.
find
(
-
1
true
)
.
line
;
return
line
;
}
function
visualLineContinued
(
line
)
{
var
merged
lines
;
while
(
merged
=
collapsedSpanAtEnd
(
line
)
)
{
line
=
merged
.
find
(
1
true
)
.
line
;
(
lines
|
|
(
lines
=
[
]
)
)
.
push
(
line
)
;
}
return
lines
;
}
function
visualLineNo
(
doc
lineN
)
{
var
line
=
getLine
(
doc
lineN
)
vis
=
visualLine
(
line
)
;
if
(
line
=
=
vis
)
return
lineN
;
return
lineNo
(
vis
)
;
}
function
visualLineEndNo
(
doc
lineN
)
{
if
(
lineN
>
doc
.
lastLine
(
)
)
return
lineN
;
var
line
=
getLine
(
doc
lineN
)
merged
;
if
(
!
lineIsHidden
(
doc
line
)
)
return
lineN
;
while
(
merged
=
collapsedSpanAtEnd
(
line
)
)
line
=
merged
.
find
(
1
true
)
.
line
;
return
lineNo
(
line
)
+
1
;
}
function
lineIsHidden
(
doc
line
)
{
var
sps
=
sawCollapsedSpans
&
&
line
.
markedSpans
;
if
(
sps
)
for
(
var
sp
i
=
0
;
i
<
sps
.
length
;
+
+
i
)
{
sp
=
sps
[
i
]
;
if
(
!
sp
.
marker
.
collapsed
)
continue
;
if
(
sp
.
from
=
=
null
)
return
true
;
if
(
sp
.
marker
.
widgetNode
)
continue
;
if
(
sp
.
from
=
=
0
&
&
sp
.
marker
.
inclusiveLeft
&
&
lineIsHiddenInner
(
doc
line
sp
)
)
return
true
;
}
}
function
lineIsHiddenInner
(
doc
line
span
)
{
if
(
span
.
to
=
=
null
)
{
var
end
=
span
.
marker
.
find
(
1
true
)
;
return
lineIsHiddenInner
(
doc
end
.
line
getMarkedSpanFor
(
end
.
line
.
markedSpans
span
.
marker
)
)
;
}
if
(
span
.
marker
.
inclusiveRight
&
&
span
.
to
=
=
line
.
text
.
length
)
return
true
;
for
(
var
sp
i
=
0
;
i
<
line
.
markedSpans
.
length
;
+
+
i
)
{
sp
=
line
.
markedSpans
[
i
]
;
if
(
sp
.
marker
.
collapsed
&
&
!
sp
.
marker
.
widgetNode
&
&
sp
.
from
=
=
span
.
to
&
&
(
sp
.
to
=
=
null
|
|
sp
.
to
!
=
span
.
from
)
&
&
(
sp
.
marker
.
inclusiveLeft
|
|
span
.
marker
.
inclusiveRight
)
&
&
lineIsHiddenInner
(
doc
line
sp
)
)
return
true
;
}
}
var
LineWidget
=
CodeMirror
.
LineWidget
=
function
(
doc
node
options
)
{
if
(
options
)
for
(
var
opt
in
options
)
if
(
options
.
hasOwnProperty
(
opt
)
)
this
[
opt
]
=
options
[
opt
]
;
this
.
doc
=
doc
;
this
.
node
=
node
;
}
;
eventMixin
(
LineWidget
)
;
function
adjustScrollWhenAboveVisible
(
cm
line
diff
)
{
if
(
heightAtLine
(
line
)
<
(
(
cm
.
curOp
&
&
cm
.
curOp
.
scrollTop
)
|
|
cm
.
doc
.
scrollTop
)
)
addToScrollPos
(
cm
null
diff
)
;
}
LineWidget
.
prototype
.
clear
=
function
(
)
{
var
cm
=
this
.
doc
.
cm
ws
=
this
.
line
.
widgets
line
=
this
.
line
no
=
lineNo
(
line
)
;
if
(
no
=
=
null
|
|
!
ws
)
return
;
for
(
var
i
=
0
;
i
<
ws
.
length
;
+
+
i
)
if
(
ws
[
i
]
=
=
this
)
ws
.
splice
(
i
-
-
1
)
;
if
(
!
ws
.
length
)
line
.
widgets
=
null
;
var
height
=
widgetHeight
(
this
)
;
updateLineHeight
(
line
Math
.
max
(
0
line
.
height
-
height
)
)
;
if
(
cm
)
runInOp
(
cm
function
(
)
{
adjustScrollWhenAboveVisible
(
cm
line
-
height
)
;
regLineChange
(
cm
no
"
widget
"
)
;
}
)
;
}
;
LineWidget
.
prototype
.
changed
=
function
(
)
{
var
oldH
=
this
.
height
cm
=
this
.
doc
.
cm
line
=
this
.
line
;
this
.
height
=
null
;
var
diff
=
widgetHeight
(
this
)
-
oldH
;
if
(
!
diff
)
return
;
updateLineHeight
(
line
line
.
height
+
diff
)
;
if
(
cm
)
runInOp
(
cm
function
(
)
{
cm
.
curOp
.
forceUpdate
=
true
;
adjustScrollWhenAboveVisible
(
cm
line
diff
)
;
}
)
;
}
;
function
widgetHeight
(
widget
)
{
if
(
widget
.
height
!
=
null
)
return
widget
.
height
;
var
cm
=
widget
.
doc
.
cm
;
if
(
!
cm
)
return
0
;
if
(
!
contains
(
document
.
body
widget
.
node
)
)
{
var
parentStyle
=
"
position
:
relative
;
"
;
if
(
widget
.
coverGutter
)
parentStyle
+
=
"
margin
-
left
:
-
"
+
cm
.
display
.
gutters
.
offsetWidth
+
"
px
;
"
;
if
(
widget
.
noHScroll
)
parentStyle
+
=
"
width
:
"
+
cm
.
display
.
wrapper
.
clientWidth
+
"
px
;
"
;
removeChildrenAndAdd
(
cm
.
display
.
measure
elt
(
"
div
"
[
widget
.
node
]
null
parentStyle
)
)
;
}
return
widget
.
height
=
widget
.
node
.
parentNode
.
offsetHeight
;
}
function
addLineWidget
(
doc
handle
node
options
)
{
var
widget
=
new
LineWidget
(
doc
node
options
)
;
var
cm
=
doc
.
cm
;
if
(
cm
&
&
widget
.
noHScroll
)
cm
.
display
.
alignWidgets
=
true
;
changeLine
(
doc
handle
"
widget
"
function
(
line
)
{
var
widgets
=
line
.
widgets
|
|
(
line
.
widgets
=
[
]
)
;
if
(
widget
.
insertAt
=
=
null
)
widgets
.
push
(
widget
)
;
else
widgets
.
splice
(
Math
.
min
(
widgets
.
length
-
1
Math
.
max
(
0
widget
.
insertAt
)
)
0
widget
)
;
widget
.
line
=
line
;
if
(
cm
&
&
!
lineIsHidden
(
doc
line
)
)
{
var
aboveVisible
=
heightAtLine
(
line
)
<
doc
.
scrollTop
;
updateLineHeight
(
line
line
.
height
+
widgetHeight
(
widget
)
)
;
if
(
aboveVisible
)
addToScrollPos
(
cm
null
widget
.
height
)
;
cm
.
curOp
.
forceUpdate
=
true
;
}
return
true
;
}
)
;
return
widget
;
}
var
Line
=
CodeMirror
.
Line
=
function
(
text
markedSpans
estimateHeight
)
{
this
.
text
=
text
;
attachMarkedSpans
(
this
markedSpans
)
;
this
.
height
=
estimateHeight
?
estimateHeight
(
this
)
:
1
;
}
;
eventMixin
(
Line
)
;
Line
.
prototype
.
lineNo
=
function
(
)
{
return
lineNo
(
this
)
;
}
;
function
updateLine
(
line
text
markedSpans
estimateHeight
)
{
line
.
text
=
text
;
if
(
line
.
stateAfter
)
line
.
stateAfter
=
null
;
if
(
line
.
styles
)
line
.
styles
=
null
;
if
(
line
.
order
!
=
null
)
line
.
order
=
null
;
detachMarkedSpans
(
line
)
;
attachMarkedSpans
(
line
markedSpans
)
;
var
estHeight
=
estimateHeight
?
estimateHeight
(
line
)
:
1
;
if
(
estHeight
!
=
line
.
height
)
updateLineHeight
(
line
estHeight
)
;
}
function
cleanUpLine
(
line
)
{
line
.
parent
=
null
;
detachMarkedSpans
(
line
)
;
}
function
extractLineClasses
(
type
output
)
{
if
(
type
)
for
(
;
;
)
{
var
lineClass
=
type
.
match
(
/
(
?
:
^
|
\
s
+
)
line
-
(
background
-
)
?
(
\
S
+
)
/
)
;
if
(
!
lineClass
)
break
;
type
=
type
.
slice
(
0
lineClass
.
index
)
+
type
.
slice
(
lineClass
.
index
+
lineClass
[
0
]
.
length
)
;
var
prop
=
lineClass
[
1
]
?
"
bgClass
"
:
"
textClass
"
;
if
(
output
[
prop
]
=
=
null
)
output
[
prop
]
=
lineClass
[
2
]
;
else
if
(
!
(
new
RegExp
(
"
(
?
:
^
|
\
s
)
"
+
lineClass
[
2
]
+
"
(
?
:
|
\
s
)
"
)
)
.
test
(
output
[
prop
]
)
)
output
[
prop
]
+
=
"
"
+
lineClass
[
2
]
;
}
return
type
;
}
function
callBlankLine
(
mode
state
)
{
if
(
mode
.
blankLine
)
return
mode
.
blankLine
(
state
)
;
if
(
!
mode
.
innerMode
)
return
;
var
inner
=
CodeMirror
.
innerMode
(
mode
state
)
;
if
(
inner
.
mode
.
blankLine
)
return
inner
.
mode
.
blankLine
(
inner
.
state
)
;
}
function
readToken
(
mode
stream
state
inner
)
{
for
(
var
i
=
0
;
i
<
10
;
i
+
+
)
{
if
(
inner
)
inner
[
0
]
=
CodeMirror
.
innerMode
(
mode
state
)
.
mode
;
var
style
=
mode
.
token
(
stream
state
)
;
if
(
stream
.
pos
>
stream
.
start
)
return
style
;
}
throw
new
Error
(
"
Mode
"
+
mode
.
name
+
"
failed
to
advance
stream
.
"
)
;
}
function
takeToken
(
cm
pos
precise
asArray
)
{
function
getObj
(
copy
)
{
return
{
start
:
stream
.
start
end
:
stream
.
pos
string
:
stream
.
current
(
)
type
:
style
|
|
null
state
:
copy
?
copyState
(
doc
.
mode
state
)
:
state
}
;
}
var
doc
=
cm
.
doc
mode
=
doc
.
mode
style
;
pos
=
clipPos
(
doc
pos
)
;
var
line
=
getLine
(
doc
pos
.
line
)
state
=
getStateBefore
(
cm
pos
.
line
precise
)
;
var
stream
=
new
StringStream
(
line
.
text
cm
.
options
.
tabSize
)
tokens
;
if
(
asArray
)
tokens
=
[
]
;
while
(
(
asArray
|
|
stream
.
pos
<
pos
.
ch
)
&
&
!
stream
.
eol
(
)
)
{
stream
.
start
=
stream
.
pos
;
style
=
readToken
(
mode
stream
state
)
;
if
(
asArray
)
tokens
.
push
(
getObj
(
true
)
)
;
}
return
asArray
?
tokens
:
getObj
(
)
;
}
function
runMode
(
cm
text
mode
state
f
lineClasses
forceToEnd
)
{
var
flattenSpans
=
mode
.
flattenSpans
;
if
(
flattenSpans
=
=
null
)
flattenSpans
=
cm
.
options
.
flattenSpans
;
var
curStart
=
0
curStyle
=
null
;
var
stream
=
new
StringStream
(
text
cm
.
options
.
tabSize
)
style
;
var
inner
=
cm
.
options
.
addModeClass
&
&
[
null
]
;
if
(
text
=
=
"
"
)
extractLineClasses
(
callBlankLine
(
mode
state
)
lineClasses
)
;
while
(
!
stream
.
eol
(
)
)
{
if
(
stream
.
pos
>
cm
.
options
.
maxHighlightLength
)
{
flattenSpans
=
false
;
if
(
forceToEnd
)
processLine
(
cm
text
state
stream
.
pos
)
;
stream
.
pos
=
text
.
length
;
style
=
null
;
}
else
{
style
=
extractLineClasses
(
readToken
(
mode
stream
state
inner
)
lineClasses
)
;
}
if
(
inner
)
{
var
mName
=
inner
[
0
]
.
name
;
if
(
mName
)
style
=
"
m
-
"
+
(
style
?
mName
+
"
"
+
style
:
mName
)
;
}
if
(
!
flattenSpans
|
|
curStyle
!
=
style
)
{
while
(
curStart
<
stream
.
start
)
{
curStart
=
Math
.
min
(
stream
.
start
curStart
+
50000
)
;
f
(
curStart
curStyle
)
;
}
curStyle
=
style
;
}
stream
.
start
=
stream
.
pos
;
}
while
(
curStart
<
stream
.
pos
)
{
var
pos
=
Math
.
min
(
stream
.
pos
curStart
+
50000
)
;
f
(
pos
curStyle
)
;
curStart
=
pos
;
}
}
function
highlightLine
(
cm
line
state
forceToEnd
)
{
var
st
=
[
cm
.
state
.
modeGen
]
lineClasses
=
{
}
;
runMode
(
cm
line
.
text
cm
.
doc
.
mode
state
function
(
end
style
)
{
st
.
push
(
end
style
)
;
}
lineClasses
forceToEnd
)
;
for
(
var
o
=
0
;
o
<
cm
.
state
.
overlays
.
length
;
+
+
o
)
{
var
overlay
=
cm
.
state
.
overlays
[
o
]
i
=
1
at
=
0
;
runMode
(
cm
line
.
text
overlay
.
mode
true
function
(
end
style
)
{
var
start
=
i
;
while
(
at
<
end
)
{
var
i_end
=
st
[
i
]
;
if
(
i_end
>
end
)
st
.
splice
(
i
1
end
st
[
i
+
1
]
i_end
)
;
i
+
=
2
;
at
=
Math
.
min
(
end
i_end
)
;
}
if
(
!
style
)
return
;
if
(
overlay
.
opaque
)
{
st
.
splice
(
start
i
-
start
end
"
cm
-
overlay
"
+
style
)
;
i
=
start
+
2
;
}
else
{
for
(
;
start
<
i
;
start
+
=
2
)
{
var
cur
=
st
[
start
+
1
]
;
st
[
start
+
1
]
=
(
cur
?
cur
+
"
"
:
"
"
)
+
"
cm
-
overlay
"
+
style
;
}
}
}
lineClasses
)
;
}
return
{
styles
:
st
classes
:
lineClasses
.
bgClass
|
|
lineClasses
.
textClass
?
lineClasses
:
null
}
;
}
function
getLineStyles
(
cm
line
updateFrontier
)
{
if
(
!
line
.
styles
|
|
line
.
styles
[
0
]
!
=
cm
.
state
.
modeGen
)
{
var
state
=
getStateBefore
(
cm
lineNo
(
line
)
)
;
var
result
=
highlightLine
(
cm
line
line
.
text
.
length
>
cm
.
options
.
maxHighlightLength
?
copyState
(
cm
.
doc
.
mode
state
)
:
state
)
;
line
.
stateAfter
=
state
;
line
.
styles
=
result
.
styles
;
if
(
result
.
classes
)
line
.
styleClasses
=
result
.
classes
;
else
if
(
line
.
styleClasses
)
line
.
styleClasses
=
null
;
if
(
updateFrontier
=
=
=
cm
.
doc
.
frontier
)
cm
.
doc
.
frontier
+
+
;
}
return
line
.
styles
;
}
function
processLine
(
cm
text
state
startAt
)
{
var
mode
=
cm
.
doc
.
mode
;
var
stream
=
new
StringStream
(
text
cm
.
options
.
tabSize
)
;
stream
.
start
=
stream
.
pos
=
startAt
|
|
0
;
if
(
text
=
=
"
"
)
callBlankLine
(
mode
state
)
;
while
(
!
stream
.
eol
(
)
)
{
readToken
(
mode
stream
state
)
;
stream
.
start
=
stream
.
pos
;
}
}
var
styleToClassCache
=
{
}
styleToClassCacheWithMode
=
{
}
;
function
interpretTokenStyle
(
style
options
)
{
if
(
!
style
|
|
/
^
\
s
*
/
.
test
(
style
)
)
return
null
;
var
cache
=
options
.
addModeClass
?
styleToClassCacheWithMode
:
styleToClassCache
;
return
cache
[
style
]
|
|
(
cache
[
style
]
=
style
.
replace
(
/
\
S
+
/
g
"
cm
-
&
"
)
)
;
}
function
buildLineContent
(
cm
lineView
)
{
var
content
=
elt
(
"
span
"
null
null
webkit
?
"
padding
-
right
:
.
1px
"
:
null
)
;
var
builder
=
{
pre
:
elt
(
"
pre
"
[
content
]
"
CodeMirror
-
line
"
)
content
:
content
col
:
0
pos
:
0
cm
:
cm
splitSpaces
:
(
ie
|
|
webkit
)
&
&
cm
.
getOption
(
"
lineWrapping
"
)
}
;
lineView
.
measure
=
{
}
;
for
(
var
i
=
0
;
i
<
=
(
lineView
.
rest
?
lineView
.
rest
.
length
:
0
)
;
i
+
+
)
{
var
line
=
i
?
lineView
.
rest
[
i
-
1
]
:
lineView
.
line
order
;
builder
.
pos
=
0
;
builder
.
addToken
=
buildToken
;
if
(
hasBadBidiRects
(
cm
.
display
.
measure
)
&
&
(
order
=
getOrder
(
line
)
)
)
builder
.
addToken
=
buildTokenBadBidi
(
builder
.
addToken
order
)
;
builder
.
map
=
[
]
;
var
allowFrontierUpdate
=
lineView
!
=
cm
.
display
.
externalMeasured
&
&
lineNo
(
line
)
;
insertLineContent
(
line
builder
getLineStyles
(
cm
line
allowFrontierUpdate
)
)
;
if
(
line
.
styleClasses
)
{
if
(
line
.
styleClasses
.
bgClass
)
builder
.
bgClass
=
joinClasses
(
line
.
styleClasses
.
bgClass
builder
.
bgClass
|
|
"
"
)
;
if
(
line
.
styleClasses
.
textClass
)
builder
.
textClass
=
joinClasses
(
line
.
styleClasses
.
textClass
builder
.
textClass
|
|
"
"
)
;
}
if
(
builder
.
map
.
length
=
=
0
)
builder
.
map
.
push
(
0
0
builder
.
content
.
appendChild
(
zeroWidthElement
(
cm
.
display
.
measure
)
)
)
;
if
(
i
=
=
0
)
{
lineView
.
measure
.
map
=
builder
.
map
;
lineView
.
measure
.
cache
=
{
}
;
}
else
{
(
lineView
.
measure
.
maps
|
|
(
lineView
.
measure
.
maps
=
[
]
)
)
.
push
(
builder
.
map
)
;
(
lineView
.
measure
.
caches
|
|
(
lineView
.
measure
.
caches
=
[
]
)
)
.
push
(
{
}
)
;
}
}
if
(
webkit
)
{
var
last
=
builder
.
content
.
lastChild
if
(
/
\
bcm
-
tab
\
b
/
.
test
(
last
.
className
)
|
|
(
last
.
querySelector
&
&
last
.
querySelector
(
"
.
cm
-
tab
"
)
)
)
builder
.
content
.
className
=
"
cm
-
tab
-
wrap
-
hack
"
;
}
signal
(
cm
"
renderLine
"
cm
lineView
.
line
builder
.
pre
)
;
if
(
builder
.
pre
.
className
)
builder
.
textClass
=
joinClasses
(
builder
.
pre
.
className
builder
.
textClass
|
|
"
"
)
;
return
builder
;
}
function
defaultSpecialCharPlaceholder
(
ch
)
{
var
token
=
elt
(
"
span
"
"
\
u2022
"
"
cm
-
invalidchar
"
)
;
token
.
title
=
"
\
\
u
"
+
ch
.
charCodeAt
(
0
)
.
toString
(
16
)
;
token
.
setAttribute
(
"
aria
-
label
"
token
.
title
)
;
return
token
;
}
function
buildToken
(
builder
text
style
startStyle
endStyle
title
css
)
{
if
(
!
text
)
return
;
var
displayText
=
builder
.
splitSpaces
?
text
.
replace
(
/
{
3
}
/
g
splitSpaces
)
:
text
;
var
special
=
builder
.
cm
.
state
.
specialChars
mustWrap
=
false
;
if
(
!
special
.
test
(
text
)
)
{
builder
.
col
+
=
text
.
length
;
var
content
=
document
.
createTextNode
(
displayText
)
;
builder
.
map
.
push
(
builder
.
pos
builder
.
pos
+
text
.
length
content
)
;
if
(
ie
&
&
ie_version
<
9
)
mustWrap
=
true
;
builder
.
pos
+
=
text
.
length
;
}
else
{
var
content
=
document
.
createDocumentFragment
(
)
pos
=
0
;
while
(
true
)
{
special
.
lastIndex
=
pos
;
var
m
=
special
.
exec
(
text
)
;
var
skipped
=
m
?
m
.
index
-
pos
:
text
.
length
-
pos
;
if
(
skipped
)
{
var
txt
=
document
.
createTextNode
(
displayText
.
slice
(
pos
pos
+
skipped
)
)
;
if
(
ie
&
&
ie_version
<
9
)
content
.
appendChild
(
elt
(
"
span
"
[
txt
]
)
)
;
else
content
.
appendChild
(
txt
)
;
builder
.
map
.
push
(
builder
.
pos
builder
.
pos
+
skipped
txt
)
;
builder
.
col
+
=
skipped
;
builder
.
pos
+
=
skipped
;
}
if
(
!
m
)
break
;
pos
+
=
skipped
+
1
;
if
(
m
[
0
]
=
=
"
\
t
"
)
{
var
tabSize
=
builder
.
cm
.
options
.
tabSize
tabWidth
=
tabSize
-
builder
.
col
%
tabSize
;
var
txt
=
content
.
appendChild
(
elt
(
"
span
"
spaceStr
(
tabWidth
)
"
cm
-
tab
"
)
)
;
txt
.
setAttribute
(
"
role
"
"
presentation
"
)
;
txt
.
setAttribute
(
"
cm
-
text
"
"
\
t
"
)
;
builder
.
col
+
=
tabWidth
;
}
else
if
(
m
[
0
]
=
=
"
\
r
"
|
|
m
[
0
]
=
=
"
\
n
"
)
{
var
txt
=
content
.
appendChild
(
elt
(
"
span
"
m
[
0
]
=
=
"
\
r
"
?
"
\
u240d
"
:
"
\
u2424
"
"
cm
-
invalidchar
"
)
)
;
txt
.
setAttribute
(
"
cm
-
text
"
m
[
0
]
)
;
builder
.
col
+
=
1
;
}
else
{
var
txt
=
builder
.
cm
.
options
.
specialCharPlaceholder
(
m
[
0
]
)
;
txt
.
setAttribute
(
"
cm
-
text
"
m
[
0
]
)
;
if
(
ie
&
&
ie_version
<
9
)
content
.
appendChild
(
elt
(
"
span
"
[
txt
]
)
)
;
else
content
.
appendChild
(
txt
)
;
builder
.
col
+
=
1
;
}
builder
.
map
.
push
(
builder
.
pos
builder
.
pos
+
1
txt
)
;
builder
.
pos
+
+
;
}
}
if
(
style
|
|
startStyle
|
|
endStyle
|
|
mustWrap
|
|
css
)
{
var
fullStyle
=
style
|
|
"
"
;
if
(
startStyle
)
fullStyle
+
=
startStyle
;
if
(
endStyle
)
fullStyle
+
=
endStyle
;
var
token
=
elt
(
"
span
"
[
content
]
fullStyle
css
)
;
if
(
title
)
token
.
title
=
title
;
return
builder
.
content
.
appendChild
(
token
)
;
}
builder
.
content
.
appendChild
(
content
)
;
}
function
splitSpaces
(
old
)
{
var
out
=
"
"
;
for
(
var
i
=
0
;
i
<
old
.
length
-
2
;
+
+
i
)
out
+
=
i
%
2
?
"
"
:
"
\
u00a0
"
;
out
+
=
"
"
;
return
out
;
}
function
buildTokenBadBidi
(
inner
order
)
{
return
function
(
builder
text
style
startStyle
endStyle
title
css
)
{
style
=
style
?
style
+
"
cm
-
force
-
border
"
:
"
cm
-
force
-
border
"
;
var
start
=
builder
.
pos
end
=
start
+
text
.
length
;
for
(
;
;
)
{
for
(
var
i
=
0
;
i
<
order
.
length
;
i
+
+
)
{
var
part
=
order
[
i
]
;
if
(
part
.
to
>
start
&
&
part
.
from
<
=
start
)
break
;
}
if
(
part
.
to
>
=
end
)
return
inner
(
builder
text
style
startStyle
endStyle
title
css
)
;
inner
(
builder
text
.
slice
(
0
part
.
to
-
start
)
style
startStyle
null
title
css
)
;
startStyle
=
null
;
text
=
text
.
slice
(
part
.
to
-
start
)
;
start
=
part
.
to
;
}
}
;
}
function
buildCollapsedSpan
(
builder
size
marker
ignoreWidget
)
{
var
widget
=
!
ignoreWidget
&
&
marker
.
widgetNode
;
if
(
widget
)
builder
.
map
.
push
(
builder
.
pos
builder
.
pos
+
size
widget
)
;
if
(
!
ignoreWidget
&
&
builder
.
cm
.
display
.
input
.
needsContentAttribute
)
{
if
(
!
widget
)
widget
=
builder
.
content
.
appendChild
(
document
.
createElement
(
"
span
"
)
)
;
widget
.
setAttribute
(
"
cm
-
marker
"
marker
.
id
)
;
}
if
(
widget
)
{
builder
.
cm
.
display
.
input
.
setUneditable
(
widget
)
;
builder
.
content
.
appendChild
(
widget
)
;
}
builder
.
pos
+
=
size
;
}
function
insertLineContent
(
line
builder
styles
)
{
var
spans
=
line
.
markedSpans
allText
=
line
.
text
at
=
0
;
if
(
!
spans
)
{
for
(
var
i
=
1
;
i
<
styles
.
length
;
i
+
=
2
)
builder
.
addToken
(
builder
allText
.
slice
(
at
at
=
styles
[
i
]
)
interpretTokenStyle
(
styles
[
i
+
1
]
builder
.
cm
.
options
)
)
;
return
;
}
var
len
=
allText
.
length
pos
=
0
i
=
1
text
=
"
"
style
css
;
var
nextChange
=
0
spanStyle
spanEndStyle
spanStartStyle
title
collapsed
;
for
(
;
;
)
{
if
(
nextChange
=
=
pos
)
{
spanStyle
=
spanEndStyle
=
spanStartStyle
=
title
=
css
=
"
"
;
collapsed
=
null
;
nextChange
=
Infinity
;
var
foundBookmarks
=
[
]
endStyles
for
(
var
j
=
0
;
j
<
spans
.
length
;
+
+
j
)
{
var
sp
=
spans
[
j
]
m
=
sp
.
marker
;
if
(
m
.
type
=
=
"
bookmark
"
&
&
sp
.
from
=
=
pos
&
&
m
.
widgetNode
)
{
foundBookmarks
.
push
(
m
)
;
}
else
if
(
sp
.
from
<
=
pos
&
&
(
sp
.
to
=
=
null
|
|
sp
.
to
>
pos
|
|
m
.
collapsed
&
&
sp
.
to
=
=
pos
&
&
sp
.
from
=
=
pos
)
)
{
if
(
sp
.
to
!
=
null
&
&
sp
.
to
!
=
pos
&
&
nextChange
>
sp
.
to
)
{
nextChange
=
sp
.
to
;
spanEndStyle
=
"
"
;
}
if
(
m
.
className
)
spanStyle
+
=
"
"
+
m
.
className
;
if
(
m
.
css
)
css
=
(
css
?
css
+
"
;
"
:
"
"
)
+
m
.
css
;
if
(
m
.
startStyle
&
&
sp
.
from
=
=
pos
)
spanStartStyle
+
=
"
"
+
m
.
startStyle
;
if
(
m
.
endStyle
&
&
sp
.
to
=
=
nextChange
)
(
endStyles
|
|
(
endStyles
=
[
]
)
)
.
push
(
m
.
endStyle
sp
.
to
)
if
(
m
.
title
&
&
!
title
)
title
=
m
.
title
;
if
(
m
.
collapsed
&
&
(
!
collapsed
|
|
compareCollapsedMarkers
(
collapsed
.
marker
m
)
<
0
)
)
collapsed
=
sp
;
}
else
if
(
sp
.
from
>
pos
&
&
nextChange
>
sp
.
from
)
{
nextChange
=
sp
.
from
;
}
}
if
(
endStyles
)
for
(
var
j
=
0
;
j
<
endStyles
.
length
;
j
+
=
2
)
if
(
endStyles
[
j
+
1
]
=
=
nextChange
)
spanEndStyle
+
=
"
"
+
endStyles
[
j
]
if
(
!
collapsed
|
|
collapsed
.
from
=
=
pos
)
for
(
var
j
=
0
;
j
<
foundBookmarks
.
length
;
+
+
j
)
buildCollapsedSpan
(
builder
0
foundBookmarks
[
j
]
)
;
if
(
collapsed
&
&
(
collapsed
.
from
|
|
0
)
=
=
pos
)
{
buildCollapsedSpan
(
builder
(
collapsed
.
to
=
=
null
?
len
+
1
:
collapsed
.
to
)
-
pos
collapsed
.
marker
collapsed
.
from
=
=
null
)
;
if
(
collapsed
.
to
=
=
null
)
return
;
if
(
collapsed
.
to
=
=
pos
)
collapsed
=
false
;
}
}
if
(
pos
>
=
len
)
break
;
var
upto
=
Math
.
min
(
len
nextChange
)
;
while
(
true
)
{
if
(
text
)
{
var
end
=
pos
+
text
.
length
;
if
(
!
collapsed
)
{
var
tokenText
=
end
>
upto
?
text
.
slice
(
0
upto
-
pos
)
:
text
;
builder
.
addToken
(
builder
tokenText
style
?
style
+
spanStyle
:
spanStyle
spanStartStyle
pos
+
tokenText
.
length
=
=
nextChange
?
spanEndStyle
:
"
"
title
css
)
;
}
if
(
end
>
=
upto
)
{
text
=
text
.
slice
(
upto
-
pos
)
;
pos
=
upto
;
break
;
}
pos
=
end
;
spanStartStyle
=
"
"
;
}
text
=
allText
.
slice
(
at
at
=
styles
[
i
+
+
]
)
;
style
=
interpretTokenStyle
(
styles
[
i
+
+
]
builder
.
cm
.
options
)
;
}
}
}
function
isWholeLineUpdate
(
doc
change
)
{
return
change
.
from
.
ch
=
=
0
&
&
change
.
to
.
ch
=
=
0
&
&
lst
(
change
.
text
)
=
=
"
"
&
&
(
!
doc
.
cm
|
|
doc
.
cm
.
options
.
wholeLineUpdateBefore
)
;
}
function
updateDoc
(
doc
change
markedSpans
estimateHeight
)
{
function
spansFor
(
n
)
{
return
markedSpans
?
markedSpans
[
n
]
:
null
;
}
function
update
(
line
text
spans
)
{
updateLine
(
line
text
spans
estimateHeight
)
;
signalLater
(
line
"
change
"
line
change
)
;
}
function
linesFor
(
start
end
)
{
for
(
var
i
=
start
result
=
[
]
;
i
<
end
;
+
+
i
)
result
.
push
(
new
Line
(
text
[
i
]
spansFor
(
i
)
estimateHeight
)
)
;
return
result
;
}
var
from
=
change
.
from
to
=
change
.
to
text
=
change
.
text
;
var
firstLine
=
getLine
(
doc
from
.
line
)
lastLine
=
getLine
(
doc
to
.
line
)
;
var
lastText
=
lst
(
text
)
lastSpans
=
spansFor
(
text
.
length
-
1
)
nlines
=
to
.
line
-
from
.
line
;
if
(
change
.
full
)
{
doc
.
insert
(
0
linesFor
(
0
text
.
length
)
)
;
doc
.
remove
(
text
.
length
doc
.
size
-
text
.
length
)
;
}
else
if
(
isWholeLineUpdate
(
doc
change
)
)
{
var
added
=
linesFor
(
0
text
.
length
-
1
)
;
update
(
lastLine
lastLine
.
text
lastSpans
)
;
if
(
nlines
)
doc
.
remove
(
from
.
line
nlines
)
;
if
(
added
.
length
)
doc
.
insert
(
from
.
line
added
)
;
}
else
if
(
firstLine
=
=
lastLine
)
{
if
(
text
.
length
=
=
1
)
{
update
(
firstLine
firstLine
.
text
.
slice
(
0
from
.
ch
)
+
lastText
+
firstLine
.
text
.
slice
(
to
.
ch
)
lastSpans
)
;
}
else
{
var
added
=
linesFor
(
1
text
.
length
-
1
)
;
added
.
push
(
new
Line
(
lastText
+
firstLine
.
text
.
slice
(
to
.
ch
)
lastSpans
estimateHeight
)
)
;
update
(
firstLine
firstLine
.
text
.
slice
(
0
from
.
ch
)
+
text
[
0
]
spansFor
(
0
)
)
;
doc
.
insert
(
from
.
line
+
1
added
)
;
}
}
else
if
(
text
.
length
=
=
1
)
{
update
(
firstLine
firstLine
.
text
.
slice
(
0
from
.
ch
)
+
text
[
0
]
+
lastLine
.
text
.
slice
(
to
.
ch
)
spansFor
(
0
)
)
;
doc
.
remove
(
from
.
line
+
1
nlines
)
;
}
else
{
update
(
firstLine
firstLine
.
text
.
slice
(
0
from
.
ch
)
+
text
[
0
]
spansFor
(
0
)
)
;
update
(
lastLine
lastText
+
lastLine
.
text
.
slice
(
to
.
ch
)
lastSpans
)
;
var
added
=
linesFor
(
1
text
.
length
-
1
)
;
if
(
nlines
>
1
)
doc
.
remove
(
from
.
line
+
1
nlines
-
1
)
;
doc
.
insert
(
from
.
line
+
1
added
)
;
}
signalLater
(
doc
"
change
"
doc
change
)
;
}
function
LeafChunk
(
lines
)
{
this
.
lines
=
lines
;
this
.
parent
=
null
;
for
(
var
i
=
0
height
=
0
;
i
<
lines
.
length
;
+
+
i
)
{
lines
[
i
]
.
parent
=
this
;
height
+
=
lines
[
i
]
.
height
;
}
this
.
height
=
height
;
}
LeafChunk
.
prototype
=
{
chunkSize
:
function
(
)
{
return
this
.
lines
.
length
;
}
removeInner
:
function
(
at
n
)
{
for
(
var
i
=
at
e
=
at
+
n
;
i
<
e
;
+
+
i
)
{
var
line
=
this
.
lines
[
i
]
;
this
.
height
-
=
line
.
height
;
cleanUpLine
(
line
)
;
signalLater
(
line
"
delete
"
)
;
}
this
.
lines
.
splice
(
at
n
)
;
}
collapse
:
function
(
lines
)
{
lines
.
push
.
apply
(
lines
this
.
lines
)
;
}
insertInner
:
function
(
at
lines
height
)
{
this
.
height
+
=
height
;
this
.
lines
=
this
.
lines
.
slice
(
0
at
)
.
concat
(
lines
)
.
concat
(
this
.
lines
.
slice
(
at
)
)
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
+
+
i
)
lines
[
i
]
.
parent
=
this
;
}
iterN
:
function
(
at
n
op
)
{
for
(
var
e
=
at
+
n
;
at
<
e
;
+
+
at
)
if
(
op
(
this
.
lines
[
at
]
)
)
return
true
;
}
}
;
function
BranchChunk
(
children
)
{
this
.
children
=
children
;
var
size
=
0
height
=
0
;
for
(
var
i
=
0
;
i
<
children
.
length
;
+
+
i
)
{
var
ch
=
children
[
i
]
;
size
+
=
ch
.
chunkSize
(
)
;
height
+
=
ch
.
height
;
ch
.
parent
=
this
;
}
this
.
size
=
size
;
this
.
height
=
height
;
this
.
parent
=
null
;
}
BranchChunk
.
prototype
=
{
chunkSize
:
function
(
)
{
return
this
.
size
;
}
removeInner
:
function
(
at
n
)
{
this
.
size
-
=
n
;
for
(
var
i
=
0
;
i
<
this
.
children
.
length
;
+
+
i
)
{
var
child
=
this
.
children
[
i
]
sz
=
child
.
chunkSize
(
)
;
if
(
at
<
sz
)
{
var
rm
=
Math
.
min
(
n
sz
-
at
)
oldHeight
=
child
.
height
;
child
.
removeInner
(
at
rm
)
;
this
.
height
-
=
oldHeight
-
child
.
height
;
if
(
sz
=
=
rm
)
{
this
.
children
.
splice
(
i
-
-
1
)
;
child
.
parent
=
null
;
}
if
(
(
n
-
=
rm
)
=
=
0
)
break
;
at
=
0
;
}
else
at
-
=
sz
;
}
if
(
this
.
size
-
n
<
25
&
&
(
this
.
children
.
length
>
1
|
|
!
(
this
.
children
[
0
]
instanceof
LeafChunk
)
)
)
{
var
lines
=
[
]
;
this
.
collapse
(
lines
)
;
this
.
children
=
[
new
LeafChunk
(
lines
)
]
;
this
.
children
[
0
]
.
parent
=
this
;
}
}
collapse
:
function
(
lines
)
{
for
(
var
i
=
0
;
i
<
this
.
children
.
length
;
+
+
i
)
this
.
children
[
i
]
.
collapse
(
lines
)
;
}
insertInner
:
function
(
at
lines
height
)
{
this
.
size
+
=
lines
.
length
;
this
.
height
+
=
height
;
for
(
var
i
=
0
;
i
<
this
.
children
.
length
;
+
+
i
)
{
var
child
=
this
.
children
[
i
]
sz
=
child
.
chunkSize
(
)
;
if
(
at
<
=
sz
)
{
child
.
insertInner
(
at
lines
height
)
;
if
(
child
.
lines
&
&
child
.
lines
.
length
>
50
)
{
var
remaining
=
child
.
lines
.
length
%
25
+
25
for
(
var
pos
=
remaining
;
pos
<
child
.
lines
.
length
;
)
{
var
leaf
=
new
LeafChunk
(
child
.
lines
.
slice
(
pos
pos
+
=
25
)
)
;
child
.
height
-
=
leaf
.
height
;
this
.
children
.
splice
(
+
+
i
0
leaf
)
;
leaf
.
parent
=
this
;
}
child
.
lines
=
child
.
lines
.
slice
(
0
remaining
)
;
this
.
maybeSpill
(
)
;
}
break
;
}
at
-
=
sz
;
}
}
maybeSpill
:
function
(
)
{
if
(
this
.
children
.
length
<
=
10
)
return
;
var
me
=
this
;
do
{
var
spilled
=
me
.
children
.
splice
(
me
.
children
.
length
-
5
5
)
;
var
sibling
=
new
BranchChunk
(
spilled
)
;
if
(
!
me
.
parent
)
{
var
copy
=
new
BranchChunk
(
me
.
children
)
;
copy
.
parent
=
me
;
me
.
children
=
[
copy
sibling
]
;
me
=
copy
;
}
else
{
me
.
size
-
=
sibling
.
size
;
me
.
height
-
=
sibling
.
height
;
var
myIndex
=
indexOf
(
me
.
parent
.
children
me
)
;
me
.
parent
.
children
.
splice
(
myIndex
+
1
0
sibling
)
;
}
sibling
.
parent
=
me
.
parent
;
}
while
(
me
.
children
.
length
>
10
)
;
me
.
parent
.
maybeSpill
(
)
;
}
iterN
:
function
(
at
n
op
)
{
for
(
var
i
=
0
;
i
<
this
.
children
.
length
;
+
+
i
)
{
var
child
=
this
.
children
[
i
]
sz
=
child
.
chunkSize
(
)
;
if
(
at
<
sz
)
{
var
used
=
Math
.
min
(
n
sz
-
at
)
;
if
(
child
.
iterN
(
at
used
op
)
)
return
true
;
if
(
(
n
-
=
used
)
=
=
0
)
break
;
at
=
0
;
}
else
at
-
=
sz
;
}
}
}
;
var
nextDocId
=
0
;
var
Doc
=
CodeMirror
.
Doc
=
function
(
text
mode
firstLine
lineSep
)
{
if
(
!
(
this
instanceof
Doc
)
)
return
new
Doc
(
text
mode
firstLine
lineSep
)
;
if
(
firstLine
=
=
null
)
firstLine
=
0
;
BranchChunk
.
call
(
this
[
new
LeafChunk
(
[
new
Line
(
"
"
null
)
]
)
]
)
;
this
.
first
=
firstLine
;
this
.
scrollTop
=
this
.
scrollLeft
=
0
;
this
.
cantEdit
=
false
;
this
.
cleanGeneration
=
1
;
this
.
frontier
=
firstLine
;
var
start
=
Pos
(
firstLine
0
)
;
this
.
sel
=
simpleSelection
(
start
)
;
this
.
history
=
new
History
(
null
)
;
this
.
id
=
+
+
nextDocId
;
this
.
modeOption
=
mode
;
this
.
lineSep
=
lineSep
;
this
.
extend
=
false
;
if
(
typeof
text
=
=
"
string
"
)
text
=
this
.
splitLines
(
text
)
;
updateDoc
(
this
{
from
:
start
to
:
start
text
:
text
}
)
;
setSelection
(
this
simpleSelection
(
start
)
sel_dontScroll
)
;
}
;
Doc
.
prototype
=
createObj
(
BranchChunk
.
prototype
{
constructor
:
Doc
iter
:
function
(
from
to
op
)
{
if
(
op
)
this
.
iterN
(
from
-
this
.
first
to
-
from
op
)
;
else
this
.
iterN
(
this
.
first
this
.
first
+
this
.
size
from
)
;
}
insert
:
function
(
at
lines
)
{
var
height
=
0
;
for
(
var
i
=
0
;
i
<
lines
.
length
;
+
+
i
)
height
+
=
lines
[
i
]
.
height
;
this
.
insertInner
(
at
-
this
.
first
lines
height
)
;
}
remove
:
function
(
at
n
)
{
this
.
removeInner
(
at
-
this
.
first
n
)
;
}
getValue
:
function
(
lineSep
)
{
var
lines
=
getLines
(
this
this
.
first
this
.
first
+
this
.
size
)
;
if
(
lineSep
=
=
=
false
)
return
lines
;
return
lines
.
join
(
lineSep
|
|
this
.
lineSeparator
(
)
)
;
}
setValue
:
docMethodOp
(
function
(
code
)
{
var
top
=
Pos
(
this
.
first
0
)
last
=
this
.
first
+
this
.
size
-
1
;
makeChange
(
this
{
from
:
top
to
:
Pos
(
last
getLine
(
this
last
)
.
text
.
length
)
text
:
this
.
splitLines
(
code
)
origin
:
"
setValue
"
full
:
true
}
true
)
;
setSelection
(
this
simpleSelection
(
top
)
)
;
}
)
replaceRange
:
function
(
code
from
to
origin
)
{
from
=
clipPos
(
this
from
)
;
to
=
to
?
clipPos
(
this
to
)
:
from
;
replaceRange
(
this
code
from
to
origin
)
;
}
getRange
:
function
(
from
to
lineSep
)
{
var
lines
=
getBetween
(
this
clipPos
(
this
from
)
clipPos
(
this
to
)
)
;
if
(
lineSep
=
=
=
false
)
return
lines
;
return
lines
.
join
(
lineSep
|
|
this
.
lineSeparator
(
)
)
;
}
getLine
:
function
(
line
)
{
var
l
=
this
.
getLineHandle
(
line
)
;
return
l
&
&
l
.
text
;
}
getLineHandle
:
function
(
line
)
{
if
(
isLine
(
this
line
)
)
return
getLine
(
this
line
)
;
}
getLineNumber
:
function
(
line
)
{
return
lineNo
(
line
)
;
}
getLineHandleVisualStart
:
function
(
line
)
{
if
(
typeof
line
=
=
"
number
"
)
line
=
getLine
(
this
line
)
;
return
visualLine
(
line
)
;
}
lineCount
:
function
(
)
{
return
this
.
size
;
}
firstLine
:
function
(
)
{
return
this
.
first
;
}
lastLine
:
function
(
)
{
return
this
.
first
+
this
.
size
-
1
;
}
clipPos
:
function
(
pos
)
{
return
clipPos
(
this
pos
)
;
}
getCursor
:
function
(
start
)
{
var
range
=
this
.
sel
.
primary
(
)
pos
;
if
(
start
=
=
null
|
|
start
=
=
"
head
"
)
pos
=
range
.
head
;
else
if
(
start
=
=
"
anchor
"
)
pos
=
range
.
anchor
;
else
if
(
start
=
=
"
end
"
|
|
start
=
=
"
to
"
|
|
start
=
=
=
false
)
pos
=
range
.
to
(
)
;
else
pos
=
range
.
from
(
)
;
return
pos
;
}
listSelections
:
function
(
)
{
return
this
.
sel
.
ranges
;
}
somethingSelected
:
function
(
)
{
return
this
.
sel
.
somethingSelected
(
)
;
}
setCursor
:
docMethodOp
(
function
(
line
ch
options
)
{
setSimpleSelection
(
this
clipPos
(
this
typeof
line
=
=
"
number
"
?
Pos
(
line
ch
|
|
0
)
:
line
)
null
options
)
;
}
)
setSelection
:
docMethodOp
(
function
(
anchor
head
options
)
{
setSimpleSelection
(
this
clipPos
(
this
anchor
)
clipPos
(
this
head
|
|
anchor
)
options
)
;
}
)
extendSelection
:
docMethodOp
(
function
(
head
other
options
)
{
extendSelection
(
this
clipPos
(
this
head
)
other
&
&
clipPos
(
this
other
)
options
)
;
}
)
extendSelections
:
docMethodOp
(
function
(
heads
options
)
{
extendSelections
(
this
clipPosArray
(
this
heads
)
options
)
;
}
)
extendSelectionsBy
:
docMethodOp
(
function
(
f
options
)
{
var
heads
=
map
(
this
.
sel
.
ranges
f
)
;
extendSelections
(
this
clipPosArray
(
this
heads
)
options
)
;
}
)
setSelections
:
docMethodOp
(
function
(
ranges
primary
options
)
{
if
(
!
ranges
.
length
)
return
;
for
(
var
i
=
0
out
=
[
]
;
i
<
ranges
.
length
;
i
+
+
)
out
[
i
]
=
new
Range
(
clipPos
(
this
ranges
[
i
]
.
anchor
)
clipPos
(
this
ranges
[
i
]
.
head
)
)
;
if
(
primary
=
=
null
)
primary
=
Math
.
min
(
ranges
.
length
-
1
this
.
sel
.
primIndex
)
;
setSelection
(
this
normalizeSelection
(
out
primary
)
options
)
;
}
)
addSelection
:
docMethodOp
(
function
(
anchor
head
options
)
{
var
ranges
=
this
.
sel
.
ranges
.
slice
(
0
)
;
ranges
.
push
(
new
Range
(
clipPos
(
this
anchor
)
clipPos
(
this
head
|
|
anchor
)
)
)
;
setSelection
(
this
normalizeSelection
(
ranges
ranges
.
length
-
1
)
options
)
;
}
)
getSelection
:
function
(
lineSep
)
{
var
ranges
=
this
.
sel
.
ranges
lines
;
for
(
var
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
var
sel
=
getBetween
(
this
ranges
[
i
]
.
from
(
)
ranges
[
i
]
.
to
(
)
)
;
lines
=
lines
?
lines
.
concat
(
sel
)
:
sel
;
}
if
(
lineSep
=
=
=
false
)
return
lines
;
else
return
lines
.
join
(
lineSep
|
|
this
.
lineSeparator
(
)
)
;
}
getSelections
:
function
(
lineSep
)
{
var
parts
=
[
]
ranges
=
this
.
sel
.
ranges
;
for
(
var
i
=
0
;
i
<
ranges
.
length
;
i
+
+
)
{
var
sel
=
getBetween
(
this
ranges
[
i
]
.
from
(
)
ranges
[
i
]
.
to
(
)
)
;
if
(
lineSep
!
=
=
false
)
sel
=
sel
.
join
(
lineSep
|
|
this
.
lineSeparator
(
)
)
;
parts
[
i
]
=
sel
;
}
return
parts
;
}
replaceSelection
:
function
(
code
collapse
origin
)
{
var
dup
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
sel
.
ranges
.
length
;
i
+
+
)
dup
[
i
]
=
code
;
this
.
replaceSelections
(
dup
collapse
origin
|
|
"
+
input
"
)
;
}
replaceSelections
:
docMethodOp
(
function
(
code
collapse
origin
)
{
var
changes
=
[
]
sel
=
this
.
sel
;
for
(
var
i
=
0
;
i
<
sel
.
ranges
.
length
;
i
+
+
)
{
var
range
=
sel
.
ranges
[
i
]
;
changes
[
i
]
=
{
from
:
range
.
from
(
)
to
:
range
.
to
(
)
text
:
this
.
splitLines
(
code
[
i
]
)
origin
:
origin
}
;
}
var
newSel
=
collapse
&
&
collapse
!
=
"
end
"
&
&
computeReplacedSel
(
this
changes
collapse
)
;
for
(
var
i
=
changes
.
length
-
1
;
i
>
=
0
;
i
-
-
)
makeChange
(
this
changes
[
i
]
)
;
if
(
newSel
)
setSelectionReplaceHistory
(
this
newSel
)
;
else
if
(
this
.
cm
)
ensureCursorVisible
(
this
.
cm
)
;
}
)
undo
:
docMethodOp
(
function
(
)
{
makeChangeFromHistory
(
this
"
undo
"
)
;
}
)
redo
:
docMethodOp
(
function
(
)
{
makeChangeFromHistory
(
this
"
redo
"
)
;
}
)
undoSelection
:
docMethodOp
(
function
(
)
{
makeChangeFromHistory
(
this
"
undo
"
true
)
;
}
)
redoSelection
:
docMethodOp
(
function
(
)
{
makeChangeFromHistory
(
this
"
redo
"
true
)
;
}
)
setExtending
:
function
(
val
)
{
this
.
extend
=
val
;
}
getExtending
:
function
(
)
{
return
this
.
extend
;
}
historySize
:
function
(
)
{
var
hist
=
this
.
history
done
=
0
undone
=
0
;
for
(
var
i
=
0
;
i
<
hist
.
done
.
length
;
i
+
+
)
if
(
!
hist
.
done
[
i
]
.
ranges
)
+
+
done
;
for
(
var
i
=
0
;
i
<
hist
.
undone
.
length
;
i
+
+
)
if
(
!
hist
.
undone
[
i
]
.
ranges
)
+
+
undone
;
return
{
undo
:
done
redo
:
undone
}
;
}
clearHistory
:
function
(
)
{
this
.
history
=
new
History
(
this
.
history
.
maxGeneration
)
;
}
markClean
:
function
(
)
{
this
.
cleanGeneration
=
this
.
changeGeneration
(
true
)
;
}
changeGeneration
:
function
(
forceSplit
)
{
if
(
forceSplit
)
this
.
history
.
lastOp
=
this
.
history
.
lastSelOp
=
this
.
history
.
lastOrigin
=
null
;
return
this
.
history
.
generation
;
}
isClean
:
function
(
gen
)
{
return
this
.
history
.
generation
=
=
(
gen
|
|
this
.
cleanGeneration
)
;
}
getHistory
:
function
(
)
{
return
{
done
:
copyHistoryArray
(
this
.
history
.
done
)
undone
:
copyHistoryArray
(
this
.
history
.
undone
)
}
;
}
setHistory
:
function
(
histData
)
{
var
hist
=
this
.
history
=
new
History
(
this
.
history
.
maxGeneration
)
;
hist
.
done
=
copyHistoryArray
(
histData
.
done
.
slice
(
0
)
null
true
)
;
hist
.
undone
=
copyHistoryArray
(
histData
.
undone
.
slice
(
0
)
null
true
)
;
}
addLineClass
:
docMethodOp
(
function
(
handle
where
cls
)
{
return
changeLine
(
this
handle
where
=
=
"
gutter
"
?
"
gutter
"
:
"
class
"
function
(
line
)
{
var
prop
=
where
=
=
"
text
"
?
"
textClass
"
:
where
=
=
"
background
"
?
"
bgClass
"
:
where
=
=
"
gutter
"
?
"
gutterClass
"
:
"
wrapClass
"
;
if
(
!
line
[
prop
]
)
line
[
prop
]
=
cls
;
else
if
(
classTest
(
cls
)
.
test
(
line
[
prop
]
)
)
return
false
;
else
line
[
prop
]
+
=
"
"
+
cls
;
return
true
;
}
)
;
}
)
removeLineClass
:
docMethodOp
(
function
(
handle
where
cls
)
{
return
changeLine
(
this
handle
where
=
=
"
gutter
"
?
"
gutter
"
:
"
class
"
function
(
line
)
{
var
prop
=
where
=
=
"
text
"
?
"
textClass
"
:
where
=
=
"
background
"
?
"
bgClass
"
:
where
=
=
"
gutter
"
?
"
gutterClass
"
:
"
wrapClass
"
;
var
cur
=
line
[
prop
]
;
if
(
!
cur
)
return
false
;
else
if
(
cls
=
=
null
)
line
[
prop
]
=
null
;
else
{
var
found
=
cur
.
match
(
classTest
(
cls
)
)
;
if
(
!
found
)
return
false
;
var
end
=
found
.
index
+
found
[
0
]
.
length
;
line
[
prop
]
=
cur
.
slice
(
0
found
.
index
)
+
(
!
found
.
index
|
|
end
=
=
cur
.
length
?
"
"
:
"
"
)
+
cur
.
slice
(
end
)
|
|
null
;
}
return
true
;
}
)
;
}
)
addLineWidget
:
docMethodOp
(
function
(
handle
node
options
)
{
return
addLineWidget
(
this
handle
node
options
)
;
}
)
removeLineWidget
:
function
(
widget
)
{
widget
.
clear
(
)
;
}
markText
:
function
(
from
to
options
)
{
return
markText
(
this
clipPos
(
this
from
)
clipPos
(
this
to
)
options
options
&
&
options
.
type
|
|
"
range
"
)
;
}
setBookmark
:
function
(
pos
options
)
{
var
realOpts
=
{
replacedWith
:
options
&
&
(
options
.
nodeType
=
=
null
?
options
.
widget
:
options
)
insertLeft
:
options
&
&
options
.
insertLeft
clearWhenEmpty
:
false
shared
:
options
&
&
options
.
shared
handleMouseEvents
:
options
&
&
options
.
handleMouseEvents
}
;
pos
=
clipPos
(
this
pos
)
;
return
markText
(
this
pos
pos
realOpts
"
bookmark
"
)
;
}
findMarksAt
:
function
(
pos
)
{
pos
=
clipPos
(
this
pos
)
;
var
markers
=
[
]
spans
=
getLine
(
this
pos
.
line
)
.
markedSpans
;
if
(
spans
)
for
(
var
i
=
0
;
i
<
spans
.
length
;
+
+
i
)
{
var
span
=
spans
[
i
]
;
if
(
(
span
.
from
=
=
null
|
|
span
.
from
<
=
pos
.
ch
)
&
&
(
span
.
to
=
=
null
|
|
span
.
to
>
=
pos
.
ch
)
)
markers
.
push
(
span
.
marker
.
parent
|
|
span
.
marker
)
;
}
return
markers
;
}
findMarks
:
function
(
from
to
filter
)
{
from
=
clipPos
(
this
from
)
;
to
=
clipPos
(
this
to
)
;
var
found
=
[
]
lineNo
=
from
.
line
;
this
.
iter
(
from
.
line
to
.
line
+
1
function
(
line
)
{
var
spans
=
line
.
markedSpans
;
if
(
spans
)
for
(
var
i
=
0
;
i
<
spans
.
length
;
i
+
+
)
{
var
span
=
spans
[
i
]
;
if
(
!
(
span
.
to
!
=
null
&
&
lineNo
=
=
from
.
line
&
&
from
.
ch
>
=
span
.
to
|
|
span
.
from
=
=
null
&
&
lineNo
!
=
from
.
line
|
|
span
.
from
!
=
null
&
&
lineNo
=
=
to
.
line
&
&
span
.
from
>
=
to
.
ch
)
&
&
(
!
filter
|
|
filter
(
span
.
marker
)
)
)
found
.
push
(
span
.
marker
.
parent
|
|
span
.
marker
)
;
}
+
+
lineNo
;
}
)
;
return
found
;
}
getAllMarks
:
function
(
)
{
var
markers
=
[
]
;
this
.
iter
(
function
(
line
)
{
var
sps
=
line
.
markedSpans
;
if
(
sps
)
for
(
var
i
=
0
;
i
<
sps
.
length
;
+
+
i
)
if
(
sps
[
i
]
.
from
!
=
null
)
markers
.
push
(
sps
[
i
]
.
marker
)
;
}
)
;
return
markers
;
}
posFromIndex
:
function
(
off
)
{
var
ch
lineNo
=
this
.
first
sepSize
=
this
.
lineSeparator
(
)
.
length
;
this
.
iter
(
function
(
line
)
{
var
sz
=
line
.
text
.
length
+
sepSize
;
if
(
sz
>
off
)
{
ch
=
off
;
return
true
;
}
off
-
=
sz
;
+
+
lineNo
;
}
)
;
return
clipPos
(
this
Pos
(
lineNo
ch
)
)
;
}
indexFromPos
:
function
(
coords
)
{
coords
=
clipPos
(
this
coords
)
;
var
index
=
coords
.
ch
;
if
(
coords
.
line
<
this
.
first
|
|
coords
.
ch
<
0
)
return
0
;
var
sepSize
=
this
.
lineSeparator
(
)
.
length
;
this
.
iter
(
this
.
first
coords
.
line
function
(
line
)
{
index
+
=
line
.
text
.
length
+
sepSize
;
}
)
;
return
index
;
}
copy
:
function
(
copyHistory
)
{
var
doc
=
new
Doc
(
getLines
(
this
this
.
first
this
.
first
+
this
.
size
)
this
.
modeOption
this
.
first
this
.
lineSep
)
;
doc
.
scrollTop
=
this
.
scrollTop
;
doc
.
scrollLeft
=
this
.
scrollLeft
;
doc
.
sel
=
this
.
sel
;
doc
.
extend
=
false
;
if
(
copyHistory
)
{
doc
.
history
.
undoDepth
=
this
.
history
.
undoDepth
;
doc
.
setHistory
(
this
.
getHistory
(
)
)
;
}
return
doc
;
}
linkedDoc
:
function
(
options
)
{
if
(
!
options
)
options
=
{
}
;
var
from
=
this
.
first
to
=
this
.
first
+
this
.
size
;
if
(
options
.
from
!
=
null
&
&
options
.
from
>
from
)
from
=
options
.
from
;
if
(
options
.
to
!
=
null
&
&
options
.
to
<
to
)
to
=
options
.
to
;
var
copy
=
new
Doc
(
getLines
(
this
from
to
)
options
.
mode
|
|
this
.
modeOption
from
this
.
lineSep
)
;
if
(
options
.
sharedHist
)
copy
.
history
=
this
.
history
;
(
this
.
linked
|
|
(
this
.
linked
=
[
]
)
)
.
push
(
{
doc
:
copy
sharedHist
:
options
.
sharedHist
}
)
;
copy
.
linked
=
[
{
doc
:
this
isParent
:
true
sharedHist
:
options
.
sharedHist
}
]
;
copySharedMarkers
(
copy
findSharedMarkers
(
this
)
)
;
return
copy
;
}
unlinkDoc
:
function
(
other
)
{
if
(
other
instanceof
CodeMirror
)
other
=
other
.
doc
;
if
(
this
.
linked
)
for
(
var
i
=
0
;
i
<
this
.
linked
.
length
;
+
+
i
)
{
var
link
=
this
.
linked
[
i
]
;
if
(
link
.
doc
!
=
other
)
continue
;
this
.
linked
.
splice
(
i
1
)
;
other
.
unlinkDoc
(
this
)
;
detachSharedMarkers
(
findSharedMarkers
(
this
)
)
;
break
;
}
if
(
other
.
history
=
=
this
.
history
)
{
var
splitIds
=
[
other
.
id
]
;
linkedDocs
(
other
function
(
doc
)
{
splitIds
.
push
(
doc
.
id
)
;
}
true
)
;
other
.
history
=
new
History
(
null
)
;
other
.
history
.
done
=
copyHistoryArray
(
this
.
history
.
done
splitIds
)
;
other
.
history
.
undone
=
copyHistoryArray
(
this
.
history
.
undone
splitIds
)
;
}
}
iterLinkedDocs
:
function
(
f
)
{
linkedDocs
(
this
f
)
;
}
getMode
:
function
(
)
{
return
this
.
mode
;
}
getEditor
:
function
(
)
{
return
this
.
cm
;
}
splitLines
:
function
(
str
)
{
if
(
this
.
lineSep
)
return
str
.
split
(
this
.
lineSep
)
;
return
splitLinesAuto
(
str
)
;
}
lineSeparator
:
function
(
)
{
return
this
.
lineSep
|
|
"
\
n
"
;
}
}
)
;
Doc
.
prototype
.
eachLine
=
Doc
.
prototype
.
iter
;
var
dontDelegate
=
"
iter
insert
remove
copy
getEditor
constructor
"
.
split
(
"
"
)
;
for
(
var
prop
in
Doc
.
prototype
)
if
(
Doc
.
prototype
.
hasOwnProperty
(
prop
)
&
&
indexOf
(
dontDelegate
prop
)
<
0
)
CodeMirror
.
prototype
[
prop
]
=
(
function
(
method
)
{
return
function
(
)
{
return
method
.
apply
(
this
.
doc
arguments
)
;
}
;
}
)
(
Doc
.
prototype
[
prop
]
)
;
eventMixin
(
Doc
)
;
function
linkedDocs
(
doc
f
sharedHistOnly
)
{
function
propagate
(
doc
skip
sharedHist
)
{
if
(
doc
.
linked
)
for
(
var
i
=
0
;
i
<
doc
.
linked
.
length
;
+
+
i
)
{
var
rel
=
doc
.
linked
[
i
]
;
if
(
rel
.
doc
=
=
skip
)
continue
;
var
shared
=
sharedHist
&
&
rel
.
sharedHist
;
if
(
sharedHistOnly
&
&
!
shared
)
continue
;
f
(
rel
.
doc
shared
)
;
propagate
(
rel
.
doc
doc
shared
)
;
}
}
propagate
(
doc
null
true
)
;
}
function
attachDoc
(
cm
doc
)
{
if
(
doc
.
cm
)
throw
new
Error
(
"
This
document
is
already
in
use
.
"
)
;
cm
.
doc
=
doc
;
doc
.
cm
=
cm
;
estimateLineHeights
(
cm
)
;
loadMode
(
cm
)
;
if
(
!
cm
.
options
.
lineWrapping
)
findMaxLine
(
cm
)
;
cm
.
options
.
mode
=
doc
.
modeOption
;
regChange
(
cm
)
;
}
function
getLine
(
doc
n
)
{
n
-
=
doc
.
first
;
if
(
n
<
0
|
|
n
>
=
doc
.
size
)
throw
new
Error
(
"
There
is
no
line
"
+
(
n
+
doc
.
first
)
+
"
in
the
document
.
"
)
;
for
(
var
chunk
=
doc
;
!
chunk
.
lines
;
)
{
for
(
var
i
=
0
;
;
+
+
i
)
{
var
child
=
chunk
.
children
[
i
]
sz
=
child
.
chunkSize
(
)
;
if
(
n
<
sz
)
{
chunk
=
child
;
break
;
}
n
-
=
sz
;
}
}
return
chunk
.
lines
[
n
]
;
}
function
getBetween
(
doc
start
end
)
{
var
out
=
[
]
n
=
start
.
line
;
doc
.
iter
(
start
.
line
end
.
line
+
1
function
(
line
)
{
var
text
=
line
.
text
;
if
(
n
=
=
end
.
line
)
text
=
text
.
slice
(
0
end
.
ch
)
;
if
(
n
=
=
start
.
line
)
text
=
text
.
slice
(
start
.
ch
)
;
out
.
push
(
text
)
;
+
+
n
;
}
)
;
return
out
;
}
function
getLines
(
doc
from
to
)
{
var
out
=
[
]
;
doc
.
iter
(
from
to
function
(
line
)
{
out
.
push
(
line
.
text
)
;
}
)
;
return
out
;
}
function
updateLineHeight
(
line
height
)
{
var
diff
=
height
-
line
.
height
;
if
(
diff
)
for
(
var
n
=
line
;
n
;
n
=
n
.
parent
)
n
.
height
+
=
diff
;
}
function
lineNo
(
line
)
{
if
(
line
.
parent
=
=
null
)
return
null
;
var
cur
=
line
.
parent
no
=
indexOf
(
cur
.
lines
line
)
;
for
(
var
chunk
=
cur
.
parent
;
chunk
;
cur
=
chunk
chunk
=
chunk
.
parent
)
{
for
(
var
i
=
0
;
;
+
+
i
)
{
if
(
chunk
.
children
[
i
]
=
=
cur
)
break
;
no
+
=
chunk
.
children
[
i
]
.
chunkSize
(
)
;
}
}
return
no
+
cur
.
first
;
}
function
lineAtHeight
(
chunk
h
)
{
var
n
=
chunk
.
first
;
outer
:
do
{
for
(
var
i
=
0
;
i
<
chunk
.
children
.
length
;
+
+
i
)
{
var
child
=
chunk
.
children
[
i
]
ch
=
child
.
height
;
if
(
h
<
ch
)
{
chunk
=
child
;
continue
outer
;
}
h
-
=
ch
;
n
+
=
child
.
chunkSize
(
)
;
}
return
n
;
}
while
(
!
chunk
.
lines
)
;
for
(
var
i
=
0
;
i
<
chunk
.
lines
.
length
;
+
+
i
)
{
var
line
=
chunk
.
lines
[
i
]
lh
=
line
.
height
;
if
(
h
<
lh
)
break
;
h
-
=
lh
;
}
return
n
+
i
;
}
function
heightAtLine
(
lineObj
)
{
lineObj
=
visualLine
(
lineObj
)
;
var
h
=
0
chunk
=
lineObj
.
parent
;
for
(
var
i
=
0
;
i
<
chunk
.
lines
.
length
;
+
+
i
)
{
var
line
=
chunk
.
lines
[
i
]
;
if
(
line
=
=
lineObj
)
break
;
else
h
+
=
line
.
height
;
}
for
(
var
p
=
chunk
.
parent
;
p
;
chunk
=
p
p
=
chunk
.
parent
)
{
for
(
var
i
=
0
;
i
<
p
.
children
.
length
;
+
+
i
)
{
var
cur
=
p
.
children
[
i
]
;
if
(
cur
=
=
chunk
)
break
;
else
h
+
=
cur
.
height
;
}
}
return
h
;
}
function
getOrder
(
line
)
{
var
order
=
line
.
order
;
if
(
order
=
=
null
)
order
=
line
.
order
=
bidiOrdering
(
line
.
text
)
;
return
order
;
}
function
History
(
startGen
)
{
this
.
done
=
[
]
;
this
.
undone
=
[
]
;
this
.
undoDepth
=
Infinity
;
this
.
lastModTime
=
this
.
lastSelTime
=
0
;
this
.
lastOp
=
this
.
lastSelOp
=
null
;
this
.
lastOrigin
=
this
.
lastSelOrigin
=
null
;
this
.
generation
=
this
.
maxGeneration
=
startGen
|
|
1
;
}
function
historyChangeFromChange
(
doc
change
)
{
var
histChange
=
{
from
:
copyPos
(
change
.
from
)
to
:
changeEnd
(
change
)
text
:
getBetween
(
doc
change
.
from
change
.
to
)
}
;
attachLocalSpans
(
doc
histChange
change
.
from
.
line
change
.
to
.
line
+
1
)
;
linkedDocs
(
doc
function
(
doc
)
{
attachLocalSpans
(
doc
histChange
change
.
from
.
line
change
.
to
.
line
+
1
)
;
}
true
)
;
return
histChange
;
}
function
clearSelectionEvents
(
array
)
{
while
(
array
.
length
)
{
var
last
=
lst
(
array
)
;
if
(
last
.
ranges
)
array
.
pop
(
)
;
else
break
;
}
}
function
lastChangeEvent
(
hist
force
)
{
if
(
force
)
{
clearSelectionEvents
(
hist
.
done
)
;
return
lst
(
hist
.
done
)
;
}
else
if
(
hist
.
done
.
length
&
&
!
lst
(
hist
.
done
)
.
ranges
)
{
return
lst
(
hist
.
done
)
;
}
else
if
(
hist
.
done
.
length
>
1
&
&
!
hist
.
done
[
hist
.
done
.
length
-
2
]
.
ranges
)
{
hist
.
done
.
pop
(
)
;
return
lst
(
hist
.
done
)
;
}
}
function
addChangeToHistory
(
doc
change
selAfter
opId
)
{
var
hist
=
doc
.
history
;
hist
.
undone
.
length
=
0
;
var
time
=
+
new
Date
cur
;
if
(
(
hist
.
lastOp
=
=
opId
|
|
hist
.
lastOrigin
=
=
change
.
origin
&
&
change
.
origin
&
&
(
(
change
.
origin
.
charAt
(
0
)
=
=
"
+
"
&
&
doc
.
cm
&
&
hist
.
lastModTime
>
time
-
doc
.
cm
.
options
.
historyEventDelay
)
|
|
change
.
origin
.
charAt
(
0
)
=
=
"
*
"
)
)
&
&
(
cur
=
lastChangeEvent
(
hist
hist
.
lastOp
=
=
opId
)
)
)
{
var
last
=
lst
(
cur
.
changes
)
;
if
(
cmp
(
change
.
from
change
.
to
)
=
=
0
&
&
cmp
(
change
.
from
last
.
to
)
=
=
0
)
{
last
.
to
=
changeEnd
(
change
)
;
}
else
{
cur
.
changes
.
push
(
historyChangeFromChange
(
doc
change
)
)
;
}
}
else
{
var
before
=
lst
(
hist
.
done
)
;
if
(
!
before
|
|
!
before
.
ranges
)
pushSelectionToHistory
(
doc
.
sel
hist
.
done
)
;
cur
=
{
changes
:
[
historyChangeFromChange
(
doc
change
)
]
generation
:
hist
.
generation
}
;
hist
.
done
.
push
(
cur
)
;
while
(
hist
.
done
.
length
>
hist
.
undoDepth
)
{
hist
.
done
.
shift
(
)
;
if
(
!
hist
.
done
[
0
]
.
ranges
)
hist
.
done
.
shift
(
)
;
}
}
hist
.
done
.
push
(
selAfter
)
;
hist
.
generation
=
+
+
hist
.
maxGeneration
;
hist
.
lastModTime
=
hist
.
lastSelTime
=
time
;
hist
.
lastOp
=
hist
.
lastSelOp
=
opId
;
hist
.
lastOrigin
=
hist
.
lastSelOrigin
=
change
.
origin
;
if
(
!
last
)
signal
(
doc
"
historyAdded
"
)
;
}
function
selectionEventCanBeMerged
(
doc
origin
prev
sel
)
{
var
ch
=
origin
.
charAt
(
0
)
;
return
ch
=
=
"
*
"
|
|
ch
=
=
"
+
"
&
&
prev
.
ranges
.
length
=
=
sel
.
ranges
.
length
&
&
prev
.
somethingSelected
(
)
=
=
sel
.
somethingSelected
(
)
&
&
new
Date
-
doc
.
history
.
lastSelTime
<
=
(
doc
.
cm
?
doc
.
cm
.
options
.
historyEventDelay
:
500
)
;
}
function
addSelectionToHistory
(
doc
sel
opId
options
)
{
var
hist
=
doc
.
history
origin
=
options
&
&
options
.
origin
;
if
(
opId
=
=
hist
.
lastSelOp
|
|
(
origin
&
&
hist
.
lastSelOrigin
=
=
origin
&
&
(
hist
.
lastModTime
=
=
hist
.
lastSelTime
&
&
hist
.
lastOrigin
=
=
origin
|
|
selectionEventCanBeMerged
(
doc
origin
lst
(
hist
.
done
)
sel
)
)
)
)
hist
.
done
[
hist
.
done
.
length
-
1
]
=
sel
;
else
pushSelectionToHistory
(
sel
hist
.
done
)
;
hist
.
lastSelTime
=
+
new
Date
;
hist
.
lastSelOrigin
=
origin
;
hist
.
lastSelOp
=
opId
;
if
(
options
&
&
options
.
clearRedo
!
=
=
false
)
clearSelectionEvents
(
hist
.
undone
)
;
}
function
pushSelectionToHistory
(
sel
dest
)
{
var
top
=
lst
(
dest
)
;
if
(
!
(
top
&
&
top
.
ranges
&
&
top
.
equals
(
sel
)
)
)
dest
.
push
(
sel
)
;
}
function
attachLocalSpans
(
doc
change
from
to
)
{
var
existing
=
change
[
"
spans_
"
+
doc
.
id
]
n
=
0
;
doc
.
iter
(
Math
.
max
(
doc
.
first
from
)
Math
.
min
(
doc
.
first
+
doc
.
size
to
)
function
(
line
)
{
if
(
line
.
markedSpans
)
(
existing
|
|
(
existing
=
change
[
"
spans_
"
+
doc
.
id
]
=
{
}
)
)
[
n
]
=
line
.
markedSpans
;
+
+
n
;
}
)
;
}
function
removeClearedSpans
(
spans
)
{
if
(
!
spans
)
return
null
;
for
(
var
i
=
0
out
;
i
<
spans
.
length
;
+
+
i
)
{
if
(
spans
[
i
]
.
marker
.
explicitlyCleared
)
{
if
(
!
out
)
out
=
spans
.
slice
(
0
i
)
;
}
else
if
(
out
)
out
.
push
(
spans
[
i
]
)
;
}
return
!
out
?
spans
:
out
.
length
?
out
:
null
;
}
function
getOldSpans
(
doc
change
)
{
var
found
=
change
[
"
spans_
"
+
doc
.
id
]
;
if
(
!
found
)
return
null
;
for
(
var
i
=
0
nw
=
[
]
;
i
<
change
.
text
.
length
;
+
+
i
)
nw
.
push
(
removeClearedSpans
(
found
[
i
]
)
)
;
return
nw
;
}
function
copyHistoryArray
(
events
newGroup
instantiateSel
)
{
for
(
var
i
=
0
copy
=
[
]
;
i
<
events
.
length
;
+
+
i
)
{
var
event
=
events
[
i
]
;
if
(
event
.
ranges
)
{
copy
.
push
(
instantiateSel
?
Selection
.
prototype
.
deepCopy
.
call
(
event
)
:
event
)
;
continue
;
}
var
changes
=
event
.
changes
newChanges
=
[
]
;
copy
.
push
(
{
changes
:
newChanges
}
)
;
for
(
var
j
=
0
;
j
<
changes
.
length
;
+
+
j
)
{
var
change
=
changes
[
j
]
m
;
newChanges
.
push
(
{
from
:
change
.
from
to
:
change
.
to
text
:
change
.
text
}
)
;
if
(
newGroup
)
for
(
var
prop
in
change
)
if
(
m
=
prop
.
match
(
/
^
spans_
(
\
d
+
)
/
)
)
{
if
(
indexOf
(
newGroup
Number
(
m
[
1
]
)
)
>
-
1
)
{
lst
(
newChanges
)
[
prop
]
=
change
[
prop
]
;
delete
change
[
prop
]
;
}
}
}
}
return
copy
;
}
function
rebaseHistSelSingle
(
pos
from
to
diff
)
{
if
(
to
<
pos
.
line
)
{
pos
.
line
+
=
diff
;
}
else
if
(
from
<
pos
.
line
)
{
pos
.
line
=
from
;
pos
.
ch
=
0
;
}
}
function
rebaseHistArray
(
array
from
to
diff
)
{
for
(
var
i
=
0
;
i
<
array
.
length
;
+
+
i
)
{
var
sub
=
array
[
i
]
ok
=
true
;
if
(
sub
.
ranges
)
{
if
(
!
sub
.
copied
)
{
sub
=
array
[
i
]
=
sub
.
deepCopy
(
)
;
sub
.
copied
=
true
;
}
for
(
var
j
=
0
;
j
<
sub
.
ranges
.
length
;
j
+
+
)
{
rebaseHistSelSingle
(
sub
.
ranges
[
j
]
.
anchor
from
to
diff
)
;
rebaseHistSelSingle
(
sub
.
ranges
[
j
]
.
head
from
to
diff
)
;
}
continue
;
}
for
(
var
j
=
0
;
j
<
sub
.
changes
.
length
;
+
+
j
)
{
var
cur
=
sub
.
changes
[
j
]
;
if
(
to
<
cur
.
from
.
line
)
{
cur
.
from
=
Pos
(
cur
.
from
.
line
+
diff
cur
.
from
.
ch
)
;
cur
.
to
=
Pos
(
cur
.
to
.
line
+
diff
cur
.
to
.
ch
)
;
}
else
if
(
from
<
=
cur
.
to
.
line
)
{
ok
=
false
;
break
;
}
}
if
(
!
ok
)
{
array
.
splice
(
0
i
+
1
)
;
i
=
0
;
}
}
}
function
rebaseHist
(
hist
change
)
{
var
from
=
change
.
from
.
line
to
=
change
.
to
.
line
diff
=
change
.
text
.
length
-
(
to
-
from
)
-
1
;
rebaseHistArray
(
hist
.
done
from
to
diff
)
;
rebaseHistArray
(
hist
.
undone
from
to
diff
)
;
}
var
e_preventDefault
=
CodeMirror
.
e_preventDefault
=
function
(
e
)
{
if
(
e
.
preventDefault
)
e
.
preventDefault
(
)
;
else
e
.
returnValue
=
false
;
}
;
var
e_stopPropagation
=
CodeMirror
.
e_stopPropagation
=
function
(
e
)
{
if
(
e
.
stopPropagation
)
e
.
stopPropagation
(
)
;
else
e
.
cancelBubble
=
true
;
}
;
function
e_defaultPrevented
(
e
)
{
return
e
.
defaultPrevented
!
=
null
?
e
.
defaultPrevented
:
e
.
returnValue
=
=
false
;
}
var
e_stop
=
CodeMirror
.
e_stop
=
function
(
e
)
{
e_preventDefault
(
e
)
;
e_stopPropagation
(
e
)
;
}
;
function
e_target
(
e
)
{
return
e
.
target
|
|
e
.
srcElement
;
}
function
e_button
(
e
)
{
var
b
=
e
.
which
;
if
(
b
=
=
null
)
{
if
(
e
.
button
&
1
)
b
=
1
;
else
if
(
e
.
button
&
2
)
b
=
3
;
else
if
(
e
.
button
&
4
)
b
=
2
;
}
if
(
mac
&
&
e
.
ctrlKey
&
&
b
=
=
1
)
b
=
3
;
return
b
;
}
var
on
=
CodeMirror
.
on
=
function
(
emitter
type
f
)
{
if
(
emitter
.
addEventListener
)
emitter
.
addEventListener
(
type
f
false
)
;
else
if
(
emitter
.
attachEvent
)
emitter
.
attachEvent
(
"
on
"
+
type
f
)
;
else
{
var
map
=
emitter
.
_handlers
|
|
(
emitter
.
_handlers
=
{
}
)
;
var
arr
=
map
[
type
]
|
|
(
map
[
type
]
=
[
]
)
;
arr
.
push
(
f
)
;
}
}
;
var
noHandlers
=
[
]
function
getHandlers
(
emitter
type
copy
)
{
var
arr
=
emitter
.
_handlers
&
&
emitter
.
_handlers
[
type
]
if
(
copy
)
return
arr
&
&
arr
.
length
>
0
?
arr
.
slice
(
)
:
noHandlers
else
return
arr
|
|
noHandlers
}
var
off
=
CodeMirror
.
off
=
function
(
emitter
type
f
)
{
if
(
emitter
.
removeEventListener
)
emitter
.
removeEventListener
(
type
f
false
)
;
else
if
(
emitter
.
detachEvent
)
emitter
.
detachEvent
(
"
on
"
+
type
f
)
;
else
{
var
handlers
=
getHandlers
(
emitter
type
false
)
for
(
var
i
=
0
;
i
<
handlers
.
length
;
+
+
i
)
if
(
handlers
[
i
]
=
=
f
)
{
handlers
.
splice
(
i
1
)
;
break
;
}
}
}
;
var
signal
=
CodeMirror
.
signal
=
function
(
emitter
type
)
{
var
handlers
=
getHandlers
(
emitter
type
true
)
if
(
!
handlers
.
length
)
return
;
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
2
)
;
for
(
var
i
=
0
;
i
<
handlers
.
length
;
+
+
i
)
handlers
[
i
]
.
apply
(
null
args
)
;
}
;
var
orphanDelayedCallbacks
=
null
;
function
signalLater
(
emitter
type
)
{
var
arr
=
getHandlers
(
emitter
type
false
)
if
(
!
arr
.
length
)
return
;
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
2
)
list
;
if
(
operationGroup
)
{
list
=
operationGroup
.
delayedCallbacks
;
}
else
if
(
orphanDelayedCallbacks
)
{
list
=
orphanDelayedCallbacks
;
}
else
{
list
=
orphanDelayedCallbacks
=
[
]
;
setTimeout
(
fireOrphanDelayed
0
)
;
}
function
bnd
(
f
)
{
return
function
(
)
{
f
.
apply
(
null
args
)
;
}
;
}
;
for
(
var
i
=
0
;
i
<
arr
.
length
;
+
+
i
)
list
.
push
(
bnd
(
arr
[
i
]
)
)
;
}
function
fireOrphanDelayed
(
)
{
var
delayed
=
orphanDelayedCallbacks
;
orphanDelayedCallbacks
=
null
;
for
(
var
i
=
0
;
i
<
delayed
.
length
;
+
+
i
)
delayed
[
i
]
(
)
;
}
function
signalDOMEvent
(
cm
e
override
)
{
if
(
typeof
e
=
=
"
string
"
)
e
=
{
type
:
e
preventDefault
:
function
(
)
{
this
.
defaultPrevented
=
true
;
}
}
;
signal
(
cm
override
|
|
e
.
type
cm
e
)
;
return
e_defaultPrevented
(
e
)
|
|
e
.
codemirrorIgnore
;
}
function
signalCursorActivity
(
cm
)
{
var
arr
=
cm
.
_handlers
&
&
cm
.
_handlers
.
cursorActivity
;
if
(
!
arr
)
return
;
var
set
=
cm
.
curOp
.
cursorActivityHandlers
|
|
(
cm
.
curOp
.
cursorActivityHandlers
=
[
]
)
;
for
(
var
i
=
0
;
i
<
arr
.
length
;
+
+
i
)
if
(
indexOf
(
set
arr
[
i
]
)
=
=
-
1
)
set
.
push
(
arr
[
i
]
)
;
}
function
hasHandler
(
emitter
type
)
{
return
getHandlers
(
emitter
type
)
.
length
>
0
}
function
eventMixin
(
ctor
)
{
ctor
.
prototype
.
on
=
function
(
type
f
)
{
on
(
this
type
f
)
;
}
;
ctor
.
prototype
.
off
=
function
(
type
f
)
{
off
(
this
type
f
)
;
}
;
}
var
scrollerGap
=
30
;
var
Pass
=
CodeMirror
.
Pass
=
{
toString
:
function
(
)
{
return
"
CodeMirror
.
Pass
"
;
}
}
;
var
sel_dontScroll
=
{
scroll
:
false
}
sel_mouse
=
{
origin
:
"
*
mouse
"
}
sel_move
=
{
origin
:
"
+
move
"
}
;
function
Delayed
(
)
{
this
.
id
=
null
;
}
Delayed
.
prototype
.
set
=
function
(
ms
f
)
{
clearTimeout
(
this
.
id
)
;
this
.
id
=
setTimeout
(
f
ms
)
;
}
;
var
countColumn
=
CodeMirror
.
countColumn
=
function
(
string
end
tabSize
startIndex
startValue
)
{
if
(
end
=
=
null
)
{
end
=
string
.
search
(
/
[
^
\
s
\
u00a0
]
/
)
;
if
(
end
=
=
-
1
)
end
=
string
.
length
;
}
for
(
var
i
=
startIndex
|
|
0
n
=
startValue
|
|
0
;
;
)
{
var
nextTab
=
string
.
indexOf
(
"
\
t
"
i
)
;
if
(
nextTab
<
0
|
|
nextTab
>
=
end
)
return
n
+
(
end
-
i
)
;
n
+
=
nextTab
-
i
;
n
+
=
tabSize
-
(
n
%
tabSize
)
;
i
=
nextTab
+
1
;
}
}
;
var
findColumn
=
CodeMirror
.
findColumn
=
function
(
string
goal
tabSize
)
{
for
(
var
pos
=
0
col
=
0
;
;
)
{
var
nextTab
=
string
.
indexOf
(
"
\
t
"
pos
)
;
if
(
nextTab
=
=
-
1
)
nextTab
=
string
.
length
;
var
skipped
=
nextTab
-
pos
;
if
(
nextTab
=
=
string
.
length
|
|
col
+
skipped
>
=
goal
)
return
pos
+
Math
.
min
(
skipped
goal
-
col
)
;
col
+
=
nextTab
-
pos
;
col
+
=
tabSize
-
(
col
%
tabSize
)
;
pos
=
nextTab
+
1
;
if
(
col
>
=
goal
)
return
pos
;
}
}
var
spaceStrs
=
[
"
"
]
;
function
spaceStr
(
n
)
{
while
(
spaceStrs
.
length
<
=
n
)
spaceStrs
.
push
(
lst
(
spaceStrs
)
+
"
"
)
;
return
spaceStrs
[
n
]
;
}
function
lst
(
arr
)
{
return
arr
[
arr
.
length
-
1
]
;
}
var
selectInput
=
function
(
node
)
{
node
.
select
(
)
;
}
;
if
(
ios
)
selectInput
=
function
(
node
)
{
node
.
selectionStart
=
0
;
node
.
selectionEnd
=
node
.
value
.
length
;
}
;
else
if
(
ie
)
selectInput
=
function
(
node
)
{
try
{
node
.
select
(
)
;
}
catch
(
_e
)
{
}
}
;
function
indexOf
(
array
elt
)
{
for
(
var
i
=
0
;
i
<
array
.
length
;
+
+
i
)
if
(
array
[
i
]
=
=
elt
)
return
i
;
return
-
1
;
}
function
map
(
array
f
)
{
var
out
=
[
]
;
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
out
[
i
]
=
f
(
array
[
i
]
i
)
;
return
out
;
}
function
nothing
(
)
{
}
function
createObj
(
base
props
)
{
var
inst
;
if
(
Object
.
create
)
{
inst
=
Object
.
create
(
base
)
;
}
else
{
nothing
.
prototype
=
base
;
inst
=
new
nothing
(
)
;
}
if
(
props
)
copyObj
(
props
inst
)
;
return
inst
;
}
;
function
copyObj
(
obj
target
overwrite
)
{
if
(
!
target
)
target
=
{
}
;
for
(
var
prop
in
obj
)
if
(
obj
.
hasOwnProperty
(
prop
)
&
&
(
overwrite
!
=
=
false
|
|
!
target
.
hasOwnProperty
(
prop
)
)
)
target
[
prop
]
=
obj
[
prop
]
;
return
target
;
}
function
bind
(
f
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
return
function
(
)
{
return
f
.
apply
(
null
args
)
;
}
;
}
var
nonASCIISingleCaseWordChar
=
/
[
\
u00df
\
u0587
\
u0590
-
\
u05f4
\
u0600
-
\
u06ff
\
u3040
-
\
u309f
\
u30a0
-
\
u30ff
\
u3400
-
\
u4db5
\
u4e00
-
\
u9fcc
\
uac00
-
\
ud7af
]
/
;
var
isWordCharBasic
=
CodeMirror
.
isWordChar
=
function
(
ch
)
{
return
/
\
w
/
.
test
(
ch
)
|
|
ch
>
"
\
x80
"
&
&
(
ch
.
toUpperCase
(
)
!
=
ch
.
toLowerCase
(
)
|
|
nonASCIISingleCaseWordChar
.
test
(
ch
)
)
;
}
;
function
isWordChar
(
ch
helper
)
{
if
(
!
helper
)
return
isWordCharBasic
(
ch
)
;
if
(
helper
.
source
.
indexOf
(
"
\
\
w
"
)
>
-
1
&
&
isWordCharBasic
(
ch
)
)
return
true
;
return
helper
.
test
(
ch
)
;
}
function
isEmpty
(
obj
)
{
for
(
var
n
in
obj
)
if
(
obj
.
hasOwnProperty
(
n
)
&
&
obj
[
n
]
)
return
false
;
return
true
;
}
var
extendingChars
=
/
[
\
u0300
-
\
u036f
\
u0483
-
\
u0489
\
u0591
-
\
u05bd
\
u05bf
\
u05c1
\
u05c2
\
u05c4
\
u05c5
\
u05c7
\
u0610
-
\
u061a
\
u064b
-
\
u065e
\
u0670
\
u06d6
-
\
u06dc
\
u06de
-
\
u06e4
\
u06e7
\
u06e8
\
u06ea
-
\
u06ed
\
u0711
\
u0730
-
\
u074a
\
u07a6
-
\
u07b0
\
u07eb
-
\
u07f3
\
u0816
-
\
u0819
\
u081b
-
\
u0823
\
u0825
-
\
u0827
\
u0829
-
\
u082d
\
u0900
-
\
u0902
\
u093c
\
u0941
-
\
u0948
\
u094d
\
u0951
-
\
u0955
\
u0962
\
u0963
\
u0981
\
u09bc
\
u09be
\
u09c1
-
\
u09c4
\
u09cd
\
u09d7
\
u09e2
\
u09e3
\
u0a01
\
u0a02
\
u0a3c
\
u0a41
\
u0a42
\
u0a47
\
u0a48
\
u0a4b
-
\
u0a4d
\
u0a51
\
u0a70
\
u0a71
\
u0a75
\
u0a81
\
u0a82
\
u0abc
\
u0ac1
-
\
u0ac5
\
u0ac7
\
u0ac8
\
u0acd
\
u0ae2
\
u0ae3
\
u0b01
\
u0b3c
\
u0b3e
\
u0b3f
\
u0b41
-
\
u0b44
\
u0b4d
\
u0b56
\
u0b57
\
u0b62
\
u0b63
\
u0b82
\
u0bbe
\
u0bc0
\
u0bcd
\
u0bd7
\
u0c3e
-
\
u0c40
\
u0c46
-
\
u0c48
\
u0c4a
-
\
u0c4d
\
u0c55
\
u0c56
\
u0c62
\
u0c63
\
u0cbc
\
u0cbf
\
u0cc2
\
u0cc6
\
u0ccc
\
u0ccd
\
u0cd5
\
u0cd6
\
u0ce2
\
u0ce3
\
u0d3e
\
u0d41
-
\
u0d44
\
u0d4d
\
u0d57
\
u0d62
\
u0d63
\
u0dca
\
u0dcf
\
u0dd2
-
\
u0dd4
\
u0dd6
\
u0ddf
\
u0e31
\
u0e34
-
\
u0e3a
\
u0e47
-
\
u0e4e
\
u0eb1
\
u0eb4
-
\
u0eb9
\
u0ebb
\
u0ebc
\
u0ec8
-
\
u0ecd
\
u0f18
\
u0f19
\
u0f35
\
u0f37
\
u0f39
\
u0f71
-
\
u0f7e
\
u0f80
-
\
u0f84
\
u0f86
\
u0f87
\
u0f90
-
\
u0f97
\
u0f99
-
\
u0fbc
\
u0fc6
\
u102d
-
\
u1030
\
u1032
-
\
u1037
\
u1039
\
u103a
\
u103d
\
u103e
\
u1058
\
u1059
\
u105e
-
\
u1060
\
u1071
-
\
u1074
\
u1082
\
u1085
\
u1086
\
u108d
\
u109d
\
u135f
\
u1712
-
\
u1714
\
u1732
-
\
u1734
\
u1752
\
u1753
\
u1772
\
u1773
\
u17b7
-
\
u17bd
\
u17c6
\
u17c9
-
\
u17d3
\
u17dd
\
u180b
-
\
u180d
\
u18a9
\
u1920
-
\
u1922
\
u1927
\
u1928
\
u1932
\
u1939
-
\
u193b
\
u1a17
\
u1a18
\
u1a56
\
u1a58
-
\
u1a5e
\
u1a60
\
u1a62
\
u1a65
-
\
u1a6c
\
u1a73
-
\
u1a7c
\
u1a7f
\
u1b00
-
\
u1b03
\
u1b34
\
u1b36
-
\
u1b3a
\
u1b3c
\
u1b42
\
u1b6b
-
\
u1b73
\
u1b80
\
u1b81
\
u1ba2
-
\
u1ba5
\
u1ba8
\
u1ba9
\
u1c2c
-
\
u1c33
\
u1c36
\
u1c37
\
u1cd0
-
\
u1cd2
\
u1cd4
-
\
u1ce0
\
u1ce2
-
\
u1ce8
\
u1ced
\
u1dc0
-
\
u1de6
\
u1dfd
-
\
u1dff
\
u200c
\
u200d
\
u20d0
-
\
u20f0
\
u2cef
-
\
u2cf1
\
u2de0
-
\
u2dff
\
u302a
-
\
u302f
\
u3099
\
u309a
\
ua66f
-
\
ua672
\
ua67c
\
ua67d
\
ua6f0
\
ua6f1
\
ua802
\
ua806
\
ua80b
\
ua825
\
ua826
\
ua8c4
\
ua8e0
-
\
ua8f1
\
ua926
-
\
ua92d
\
ua947
-
\
ua951
\
ua980
-
\
ua982
\
ua9b3
\
ua9b6
-
\
ua9b9
\
ua9bc
\
uaa29
-
\
uaa2e
\
uaa31
\
uaa32
\
uaa35
\
uaa36
\
uaa43
\
uaa4c
\
uaab0
\
uaab2
-
\
uaab4
\
uaab7
\
uaab8
\
uaabe
\
uaabf
\
uaac1
\
uabe5
\
uabe8
\
uabed
\
udc00
-
\
udfff
\
ufb1e
\
ufe00
-
\
ufe0f
\
ufe20
-
\
ufe26
\
uff9e
\
uff9f
]
/
;
function
isExtendingChar
(
ch
)
{
return
ch
.
charCodeAt
(
0
)
>
=
768
&
&
extendingChars
.
test
(
ch
)
;
}
function
elt
(
tag
content
className
style
)
{
var
e
=
document
.
createElement
(
tag
)
;
if
(
className
)
e
.
className
=
className
;
if
(
style
)
e
.
style
.
cssText
=
style
;
if
(
typeof
content
=
=
"
string
"
)
e
.
appendChild
(
document
.
createTextNode
(
content
)
)
;
else
if
(
content
)
for
(
var
i
=
0
;
i
<
content
.
length
;
+
+
i
)
e
.
appendChild
(
content
[
i
]
)
;
return
e
;
}
var
range
;
if
(
document
.
createRange
)
range
=
function
(
node
start
end
endNode
)
{
var
r
=
document
.
createRange
(
)
;
r
.
setEnd
(
endNode
|
|
node
end
)
;
r
.
setStart
(
node
start
)
;
return
r
;
}
;
else
range
=
function
(
node
start
end
)
{
var
r
=
document
.
body
.
createTextRange
(
)
;
try
{
r
.
moveToElementText
(
node
.
parentNode
)
;
}
catch
(
e
)
{
return
r
;
}
r
.
collapse
(
true
)
;
r
.
moveEnd
(
"
character
"
end
)
;
r
.
moveStart
(
"
character
"
start
)
;
return
r
;
}
;
function
removeChildren
(
e
)
{
for
(
var
count
=
e
.
childNodes
.
length
;
count
>
0
;
-
-
count
)
e
.
removeChild
(
e
.
firstChild
)
;
return
e
;
}
function
removeChildrenAndAdd
(
parent
e
)
{
return
removeChildren
(
parent
)
.
appendChild
(
e
)
;
}
var
contains
=
CodeMirror
.
contains
=
function
(
parent
child
)
{
if
(
child
.
nodeType
=
=
3
)
child
=
child
.
parentNode
;
if
(
parent
.
contains
)
return
parent
.
contains
(
child
)
;
do
{
if
(
child
.
nodeType
=
=
11
)
child
=
child
.
host
;
if
(
child
=
=
parent
)
return
true
;
}
while
(
child
=
child
.
parentNode
)
;
}
;
function
activeElt
(
)
{
var
activeElement
=
document
.
activeElement
;
while
(
activeElement
&
&
activeElement
.
root
&
&
activeElement
.
root
.
activeElement
)
activeElement
=
activeElement
.
root
.
activeElement
;
return
activeElement
;
}
if
(
ie
&
&
ie_version
<
11
)
activeElt
=
function
(
)
{
try
{
return
document
.
activeElement
;
}
catch
(
e
)
{
return
document
.
body
;
}
}
;
function
classTest
(
cls
)
{
return
new
RegExp
(
"
(
^
|
\
\
s
)
"
+
cls
+
"
(
?
:
|
\
\
s
)
\
\
s
*
"
)
;
}
var
rmClass
=
CodeMirror
.
rmClass
=
function
(
node
cls
)
{
var
current
=
node
.
className
;
var
match
=
classTest
(
cls
)
.
exec
(
current
)
;
if
(
match
)
{
var
after
=
current
.
slice
(
match
.
index
+
match
[
0
]
.
length
)
;
node
.
className
=
current
.
slice
(
0
match
.
index
)
+
(
after
?
match
[
1
]
+
after
:
"
"
)
;
}
}
;
var
addClass
=
CodeMirror
.
addClass
=
function
(
node
cls
)
{
var
current
=
node
.
className
;
if
(
!
classTest
(
cls
)
.
test
(
current
)
)
node
.
className
+
=
(
current
?
"
"
:
"
"
)
+
cls
;
}
;
function
joinClasses
(
a
b
)
{
var
as
=
a
.
split
(
"
"
)
;
for
(
var
i
=
0
;
i
<
as
.
length
;
i
+
+
)
if
(
as
[
i
]
&
&
!
classTest
(
as
[
i
]
)
.
test
(
b
)
)
b
+
=
"
"
+
as
[
i
]
;
return
b
;
}
function
forEachCodeMirror
(
f
)
{
if
(
!
document
.
body
.
getElementsByClassName
)
return
;
var
byClass
=
document
.
body
.
getElementsByClassName
(
"
CodeMirror
"
)
;
for
(
var
i
=
0
;
i
<
byClass
.
length
;
i
+
+
)
{
var
cm
=
byClass
[
i
]
.
CodeMirror
;
if
(
cm
)
f
(
cm
)
;
}
}
var
globalsRegistered
=
false
;
function
ensureGlobalHandlers
(
)
{
if
(
globalsRegistered
)
return
;
registerGlobalHandlers
(
)
;
globalsRegistered
=
true
;
}
function
registerGlobalHandlers
(
)
{
var
resizeTimer
;
on
(
window
"
resize
"
function
(
)
{
if
(
resizeTimer
=
=
null
)
resizeTimer
=
setTimeout
(
function
(
)
{
resizeTimer
=
null
;
forEachCodeMirror
(
onResize
)
;
}
100
)
;
}
)
;
on
(
window
"
blur
"
function
(
)
{
forEachCodeMirror
(
onBlur
)
;
}
)
;
}
var
dragAndDrop
=
function
(
)
{
if
(
ie
&
&
ie_version
<
9
)
return
false
;
var
div
=
elt
(
'
div
'
)
;
return
"
draggable
"
in
div
|
|
"
dragDrop
"
in
div
;
}
(
)
;
var
zwspSupported
;
function
zeroWidthElement
(
measure
)
{
if
(
zwspSupported
=
=
null
)
{
var
test
=
elt
(
"
span
"
"
\
u200b
"
)
;
removeChildrenAndAdd
(
measure
elt
(
"
span
"
[
test
document
.
createTextNode
(
"
x
"
)
]
)
)
;
if
(
measure
.
firstChild
.
offsetHeight
!
=
0
)
zwspSupported
=
test
.
offsetWidth
<
=
1
&
&
test
.
offsetHeight
>
2
&
&
!
(
ie
&
&
ie_version
<
8
)
;
}
var
node
=
zwspSupported
?
elt
(
"
span
"
"
\
u200b
"
)
:
elt
(
"
span
"
"
\
u00a0
"
null
"
display
:
inline
-
block
;
width
:
1px
;
margin
-
right
:
-
1px
"
)
;
node
.
setAttribute
(
"
cm
-
text
"
"
"
)
;
return
node
;
}
var
badBidiRects
;
function
hasBadBidiRects
(
measure
)
{
if
(
badBidiRects
!
=
null
)
return
badBidiRects
;
var
txt
=
removeChildrenAndAdd
(
measure
document
.
createTextNode
(
"
A
\
u062eA
"
)
)
;
var
r0
=
range
(
txt
0
1
)
.
getBoundingClientRect
(
)
;
if
(
!
r0
|
|
r0
.
left
=
=
r0
.
right
)
return
false
;
var
r1
=
range
(
txt
1
2
)
.
getBoundingClientRect
(
)
;
return
badBidiRects
=
(
r1
.
right
-
r0
.
right
<
3
)
;
}
var
splitLinesAuto
=
CodeMirror
.
splitLines
=
"
\
n
\
nb
"
.
split
(
/
\
n
/
)
.
length
!
=
3
?
function
(
string
)
{
var
pos
=
0
result
=
[
]
l
=
string
.
length
;
while
(
pos
<
=
l
)
{
var
nl
=
string
.
indexOf
(
"
\
n
"
pos
)
;
if
(
nl
=
=
-
1
)
nl
=
string
.
length
;
var
line
=
string
.
slice
(
pos
string
.
charAt
(
nl
-
1
)
=
=
"
\
r
"
?
nl
-
1
:
nl
)
;
var
rt
=
line
.
indexOf
(
"
\
r
"
)
;
if
(
rt
!
=
-
1
)
{
result
.
push
(
line
.
slice
(
0
rt
)
)
;
pos
+
=
rt
+
1
;
}
else
{
result
.
push
(
line
)
;
pos
=
nl
+
1
;
}
}
return
result
;
}
:
function
(
string
)
{
return
string
.
split
(
/
\
r
\
n
?
|
\
n
/
)
;
}
;
var
hasSelection
=
window
.
getSelection
?
function
(
te
)
{
try
{
return
te
.
selectionStart
!
=
te
.
selectionEnd
;
}
catch
(
e
)
{
return
false
;
}
}
:
function
(
te
)
{
try
{
var
range
=
te
.
ownerDocument
.
selection
.
createRange
(
)
;
}
catch
(
e
)
{
}
if
(
!
range
|
|
range
.
parentElement
(
)
!
=
te
)
return
false
;
return
range
.
compareEndPoints
(
"
StartToEnd
"
range
)
!
=
0
;
}
;
var
hasCopyEvent
=
(
function
(
)
{
var
e
=
elt
(
"
div
"
)
;
if
(
"
oncopy
"
in
e
)
return
true
;
e
.
setAttribute
(
"
oncopy
"
"
return
;
"
)
;
return
typeof
e
.
oncopy
=
=
"
function
"
;
}
)
(
)
;
var
badZoomedRects
=
null
;
function
hasBadZoomedRects
(
measure
)
{
if
(
badZoomedRects
!
=
null
)
return
badZoomedRects
;
var
node
=
removeChildrenAndAdd
(
measure
elt
(
"
span
"
"
x
"
)
)
;
var
normal
=
node
.
getBoundingClientRect
(
)
;
var
fromRange
=
range
(
node
0
1
)
.
getBoundingClientRect
(
)
;
return
badZoomedRects
=
Math
.
abs
(
normal
.
left
-
fromRange
.
left
)
>
1
;
}
var
keyNames
=
CodeMirror
.
keyNames
=
{
3
:
"
Enter
"
8
:
"
Backspace
"
9
:
"
Tab
"
13
:
"
Enter
"
16
:
"
Shift
"
17
:
"
Ctrl
"
18
:
"
Alt
"
19
:
"
Pause
"
20
:
"
CapsLock
"
27
:
"
Esc
"
32
:
"
Space
"
33
:
"
PageUp
"
34
:
"
PageDown
"
35
:
"
End
"
36
:
"
Home
"
37
:
"
Left
"
38
:
"
Up
"
39
:
"
Right
"
40
:
"
Down
"
44
:
"
PrintScrn
"
45
:
"
Insert
"
46
:
"
Delete
"
59
:
"
;
"
61
:
"
=
"
91
:
"
Mod
"
92
:
"
Mod
"
93
:
"
Mod
"
106
:
"
*
"
107
:
"
=
"
109
:
"
-
"
110
:
"
.
"
111
:
"
/
"
127
:
"
Delete
"
173
:
"
-
"
186
:
"
;
"
187
:
"
=
"
188
:
"
"
189
:
"
-
"
190
:
"
.
"
191
:
"
/
"
192
:
"
"
219
:
"
[
"
220
:
"
\
\
"
221
:
"
]
"
222
:
"
'
"
63232
:
"
Up
"
63233
:
"
Down
"
63234
:
"
Left
"
63235
:
"
Right
"
63272
:
"
Delete
"
63273
:
"
Home
"
63275
:
"
End
"
63276
:
"
PageUp
"
63277
:
"
PageDown
"
63302
:
"
Insert
"
}
;
(
function
(
)
{
for
(
var
i
=
0
;
i
<
10
;
i
+
+
)
keyNames
[
i
+
48
]
=
keyNames
[
i
+
96
]
=
String
(
i
)
;
for
(
var
i
=
65
;
i
<
=
90
;
i
+
+
)
keyNames
[
i
]
=
String
.
fromCharCode
(
i
)
;
for
(
var
i
=
1
;
i
<
=
12
;
i
+
+
)
keyNames
[
i
+
111
]
=
keyNames
[
i
+
63235
]
=
"
F
"
+
i
;
}
)
(
)
;
function
iterateBidiSections
(
order
from
to
f
)
{
if
(
!
order
)
return
f
(
from
to
"
ltr
"
)
;
var
found
=
false
;
for
(
var
i
=
0
;
i
<
order
.
length
;
+
+
i
)
{
var
part
=
order
[
i
]
;
if
(
part
.
from
<
to
&
&
part
.
to
>
from
|
|
from
=
=
to
&
&
part
.
to
=
=
from
)
{
f
(
Math
.
max
(
part
.
from
from
)
Math
.
min
(
part
.
to
to
)
part
.
level
=
=
1
?
"
rtl
"
:
"
ltr
"
)
;
found
=
true
;
}
}
if
(
!
found
)
f
(
from
to
"
ltr
"
)
;
}
function
bidiLeft
(
part
)
{
return
part
.
level
%
2
?
part
.
to
:
part
.
from
;
}
function
bidiRight
(
part
)
{
return
part
.
level
%
2
?
part
.
from
:
part
.
to
;
}
function
lineLeft
(
line
)
{
var
order
=
getOrder
(
line
)
;
return
order
?
bidiLeft
(
order
[
0
]
)
:
0
;
}
function
lineRight
(
line
)
{
var
order
=
getOrder
(
line
)
;
if
(
!
order
)
return
line
.
text
.
length
;
return
bidiRight
(
lst
(
order
)
)
;
}
function
lineStart
(
cm
lineN
)
{
var
line
=
getLine
(
cm
.
doc
lineN
)
;
var
visual
=
visualLine
(
line
)
;
if
(
visual
!
=
line
)
lineN
=
lineNo
(
visual
)
;
var
order
=
getOrder
(
visual
)
;
var
ch
=
!
order
?
0
:
order
[
0
]
.
level
%
2
?
lineRight
(
visual
)
:
lineLeft
(
visual
)
;
return
Pos
(
lineN
ch
)
;
}
function
lineEnd
(
cm
lineN
)
{
var
merged
line
=
getLine
(
cm
.
doc
lineN
)
;
while
(
merged
=
collapsedSpanAtEnd
(
line
)
)
{
line
=
merged
.
find
(
1
true
)
.
line
;
lineN
=
null
;
}
var
order
=
getOrder
(
line
)
;
var
ch
=
!
order
?
line
.
text
.
length
:
order
[
0
]
.
level
%
2
?
lineLeft
(
line
)
:
lineRight
(
line
)
;
return
Pos
(
lineN
=
=
null
?
lineNo
(
line
)
:
lineN
ch
)
;
}
function
lineStartSmart
(
cm
pos
)
{
var
start
=
lineStart
(
cm
pos
.
line
)
;
var
line
=
getLine
(
cm
.
doc
start
.
line
)
;
var
order
=
getOrder
(
line
)
;
if
(
!
order
|
|
order
[
0
]
.
level
=
=
0
)
{
var
firstNonWS
=
Math
.
max
(
0
line
.
text
.
search
(
/
\
S
/
)
)
;
var
inWS
=
pos
.
line
=
=
start
.
line
&
&
pos
.
ch
<
=
firstNonWS
&
&
pos
.
ch
;
return
Pos
(
start
.
line
inWS
?
0
:
firstNonWS
)
;
}
return
start
;
}
function
compareBidiLevel
(
order
a
b
)
{
var
linedir
=
order
[
0
]
.
level
;
if
(
a
=
=
linedir
)
return
true
;
if
(
b
=
=
linedir
)
return
false
;
return
a
<
b
;
}
var
bidiOther
;
function
getBidiPartAt
(
order
pos
)
{
bidiOther
=
null
;
for
(
var
i
=
0
found
;
i
<
order
.
length
;
+
+
i
)
{
var
cur
=
order
[
i
]
;
if
(
cur
.
from
<
pos
&
&
cur
.
to
>
pos
)
return
i
;
if
(
(
cur
.
from
=
=
pos
|
|
cur
.
to
=
=
pos
)
)
{
if
(
found
=
=
null
)
{
found
=
i
;
}
else
if
(
compareBidiLevel
(
order
cur
.
level
order
[
found
]
.
level
)
)
{
if
(
cur
.
from
!
=
cur
.
to
)
bidiOther
=
found
;
return
i
;
}
else
{
if
(
cur
.
from
!
=
cur
.
to
)
bidiOther
=
i
;
return
found
;
}
}
}
return
found
;
}
function
moveInLine
(
line
pos
dir
byUnit
)
{
if
(
!
byUnit
)
return
pos
+
dir
;
do
pos
+
=
dir
;
while
(
pos
>
0
&
&
isExtendingChar
(
line
.
text
.
charAt
(
pos
)
)
)
;
return
pos
;
}
function
moveVisually
(
line
start
dir
byUnit
)
{
var
bidi
=
getOrder
(
line
)
;
if
(
!
bidi
)
return
moveLogically
(
line
start
dir
byUnit
)
;
var
pos
=
getBidiPartAt
(
bidi
start
)
part
=
bidi
[
pos
]
;
var
target
=
moveInLine
(
line
start
part
.
level
%
2
?
-
dir
:
dir
byUnit
)
;
for
(
;
;
)
{
if
(
target
>
part
.
from
&
&
target
<
part
.
to
)
return
target
;
if
(
target
=
=
part
.
from
|
|
target
=
=
part
.
to
)
{
if
(
getBidiPartAt
(
bidi
target
)
=
=
pos
)
return
target
;
part
=
bidi
[
pos
+
=
dir
]
;
return
(
dir
>
0
)
=
=
part
.
level
%
2
?
part
.
to
:
part
.
from
;
}
else
{
part
=
bidi
[
pos
+
=
dir
]
;
if
(
!
part
)
return
null
;
if
(
(
dir
>
0
)
=
=
part
.
level
%
2
)
target
=
moveInLine
(
line
part
.
to
-
1
byUnit
)
;
else
target
=
moveInLine
(
line
part
.
from
1
byUnit
)
;
}
}
}
function
moveLogically
(
line
start
dir
byUnit
)
{
var
target
=
start
+
dir
;
if
(
byUnit
)
while
(
target
>
0
&
&
isExtendingChar
(
line
.
text
.
charAt
(
target
)
)
)
target
+
=
dir
;
return
target
<
0
|
|
target
>
line
.
text
.
length
?
null
:
target
;
}
var
bidiOrdering
=
(
function
(
)
{
var
lowTypes
=
"
bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN
%
%
%
NNNNNN
N
N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb
N
%
%
%
%
NNNNLNNNNN
%
%
11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN
"
;
var
arabicTypes
=
"
rrrrrrrrrrrr
rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn
%
nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm
"
;
function
charType
(
code
)
{
if
(
code
<
=
0xf7
)
return
lowTypes
.
charAt
(
code
)
;
else
if
(
0x590
<
=
code
&
&
code
<
=
0x5f4
)
return
"
R
"
;
else
if
(
0x600
<
=
code
&
&
code
<
=
0x6ed
)
return
arabicTypes
.
charAt
(
code
-
0x600
)
;
else
if
(
0x6ee
<
=
code
&
&
code
<
=
0x8ac
)
return
"
r
"
;
else
if
(
0x2000
<
=
code
&
&
code
<
=
0x200b
)
return
"
w
"
;
else
if
(
code
=
=
0x200c
)
return
"
b
"
;
else
return
"
L
"
;
}
var
bidiRE
=
/
[
\
u0590
-
\
u05f4
\
u0600
-
\
u06ff
\
u0700
-
\
u08ac
]
/
;
var
isNeutral
=
/
[
stwN
]
/
isStrong
=
/
[
LRr
]
/
countsAsLeft
=
/
[
Lb1n
]
/
countsAsNum
=
/
[
1n
]
/
;
var
outerType
=
"
L
"
;
function
BidiSpan
(
level
from
to
)
{
this
.
level
=
level
;
this
.
from
=
from
;
this
.
to
=
to
;
}
return
function
(
str
)
{
if
(
!
bidiRE
.
test
(
str
)
)
return
false
;
var
len
=
str
.
length
types
=
[
]
;
for
(
var
i
=
0
type
;
i
<
len
;
+
+
i
)
types
.
push
(
type
=
charType
(
str
.
charCodeAt
(
i
)
)
)
;
for
(
var
i
=
0
prev
=
outerType
;
i
<
len
;
+
+
i
)
{
var
type
=
types
[
i
]
;
if
(
type
=
=
"
m
"
)
types
[
i
]
=
prev
;
else
prev
=
type
;
}
for
(
var
i
=
0
cur
=
outerType
;
i
<
len
;
+
+
i
)
{
var
type
=
types
[
i
]
;
if
(
type
=
=
"
1
"
&
&
cur
=
=
"
r
"
)
types
[
i
]
=
"
n
"
;
else
if
(
isStrong
.
test
(
type
)
)
{
cur
=
type
;
if
(
type
=
=
"
r
"
)
types
[
i
]
=
"
R
"
;
}
}
for
(
var
i
=
1
prev
=
types
[
0
]
;
i
<
len
-
1
;
+
+
i
)
{
var
type
=
types
[
i
]
;
if
(
type
=
=
"
+
"
&
&
prev
=
=
"
1
"
&
&
types
[
i
+
1
]
=
=
"
1
"
)
types
[
i
]
=
"
1
"
;
else
if
(
type
=
=
"
"
&
&
prev
=
=
types
[
i
+
1
]
&
&
(
prev
=
=
"
1
"
|
|
prev
=
=
"
n
"
)
)
types
[
i
]
=
prev
;
prev
=
type
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
var
type
=
types
[
i
]
;
if
(
type
=
=
"
"
)
types
[
i
]
=
"
N
"
;
else
if
(
type
=
=
"
%
"
)
{
for
(
var
end
=
i
+
1
;
end
<
len
&
&
types
[
end
]
=
=
"
%
"
;
+
+
end
)
{
}
var
replace
=
(
i
&
&
types
[
i
-
1
]
=
=
"
!
"
)
|
|
(
end
<
len
&
&
types
[
end
]
=
=
"
1
"
)
?
"
1
"
:
"
N
"
;
for
(
var
j
=
i
;
j
<
end
;
+
+
j
)
types
[
j
]
=
replace
;
i
=
end
-
1
;
}
}
for
(
var
i
=
0
cur
=
outerType
;
i
<
len
;
+
+
i
)
{
var
type
=
types
[
i
]
;
if
(
cur
=
=
"
L
"
&
&
type
=
=
"
1
"
)
types
[
i
]
=
"
L
"
;
else
if
(
isStrong
.
test
(
type
)
)
cur
=
type
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
isNeutral
.
test
(
types
[
i
]
)
)
{
for
(
var
end
=
i
+
1
;
end
<
len
&
&
isNeutral
.
test
(
types
[
end
]
)
;
+
+
end
)
{
}
var
before
=
(
i
?
types
[
i
-
1
]
:
outerType
)
=
=
"
L
"
;
var
after
=
(
end
<
len
?
types
[
end
]
:
outerType
)
=
=
"
L
"
;
var
replace
=
before
|
|
after
?
"
L
"
:
"
R
"
;
for
(
var
j
=
i
;
j
<
end
;
+
+
j
)
types
[
j
]
=
replace
;
i
=
end
-
1
;
}
}
var
order
=
[
]
m
;
for
(
var
i
=
0
;
i
<
len
;
)
{
if
(
countsAsLeft
.
test
(
types
[
i
]
)
)
{
var
start
=
i
;
for
(
+
+
i
;
i
<
len
&
&
countsAsLeft
.
test
(
types
[
i
]
)
;
+
+
i
)
{
}
order
.
push
(
new
BidiSpan
(
0
start
i
)
)
;
}
else
{
var
pos
=
i
at
=
order
.
length
;
for
(
+
+
i
;
i
<
len
&
&
types
[
i
]
!
=
"
L
"
;
+
+
i
)
{
}
for
(
var
j
=
pos
;
j
<
i
;
)
{
if
(
countsAsNum
.
test
(
types
[
j
]
)
)
{
if
(
pos
<
j
)
order
.
splice
(
at
0
new
BidiSpan
(
1
pos
j
)
)
;
var
nstart
=
j
;
for
(
+
+
j
;
j
<
i
&
&
countsAsNum
.
test
(
types
[
j
]
)
;
+
+
j
)
{
}
order
.
splice
(
at
0
new
BidiSpan
(
2
nstart
j
)
)
;
pos
=
j
;
}
else
+
+
j
;
}
if
(
pos
<
i
)
order
.
splice
(
at
0
new
BidiSpan
(
1
pos
i
)
)
;
}
}
if
(
order
[
0
]
.
level
=
=
1
&
&
(
m
=
str
.
match
(
/
^
\
s
+
/
)
)
)
{
order
[
0
]
.
from
=
m
[
0
]
.
length
;
order
.
unshift
(
new
BidiSpan
(
0
0
m
[
0
]
.
length
)
)
;
}
if
(
lst
(
order
)
.
level
=
=
1
&
&
(
m
=
str
.
match
(
/
\
s
+
/
)
)
)
{
lst
(
order
)
.
to
-
=
m
[
0
]
.
length
;
order
.
push
(
new
BidiSpan
(
0
len
-
m
[
0
]
.
length
len
)
)
;
}
if
(
order
[
0
]
.
level
=
=
2
)
order
.
unshift
(
new
BidiSpan
(
1
order
[
0
]
.
to
order
[
0
]
.
to
)
)
;
if
(
order
[
0
]
.
level
!
=
lst
(
order
)
.
level
)
order
.
push
(
new
BidiSpan
(
order
[
0
]
.
level
len
len
)
)
;
return
order
;
}
;
}
)
(
)
;
CodeMirror
.
version
=
"
5
.
16
.
0
"
;
return
CodeMirror
;
}
)
;
}
function
(
module
exports
)
{
var
MAX_VERTICAL_OFFSET
=
3
;
function
alignLine
(
cm
line
)
{
var
align
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
"
top
"
:
arguments
[
2
]
;
var
from
=
cm
.
lineAtHeight
(
0
"
page
"
)
;
var
to
=
cm
.
lineAtHeight
(
cm
.
getWrapperElement
(
)
.
clientHeight
"
page
"
)
;
var
linesVisible
=
to
-
from
;
var
halfVisible
=
Math
.
round
(
linesVisible
/
2
)
;
if
(
line
<
=
to
&
&
line
>
=
from
)
{
return
;
}
var
offset
=
Math
.
min
(
halfVisible
MAX_VERTICAL_OFFSET
)
;
var
topLine
=
{
"
center
"
:
Math
.
max
(
line
-
halfVisible
0
)
"
bottom
"
:
Math
.
max
(
line
-
linesVisible
+
offset
0
)
"
top
"
:
Math
.
max
(
line
-
offset
0
)
}
[
align
|
|
"
top
"
]
|
|
offset
;
topLine
=
Math
.
min
(
topLine
cm
.
lineCount
(
)
)
;
setFirstVisibleLine
(
cm
topLine
)
;
}
function
setFirstVisibleLine
(
cm
line
)
{
var
_cm
charCoords
=
cm
.
charCoords
(
{
line
:
line
ch
:
0
}
"
local
"
)
;
var
top
=
_cm
charCoords
.
top
;
cm
.
scrollTo
(
0
top
)
;
}
function
onWheel
(
cm
ev
)
{
if
(
!
cm
.
getScrollerElement
(
)
.
scrollBy
)
{
return
;
}
ev
.
preventDefault
(
)
;
var
deltaX
=
ev
.
deltaX
;
var
deltaY
=
ev
.
deltaY
;
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_LINE
)
{
deltaX
*
=
cm
.
defaultCharWidth
(
)
;
deltaY
*
=
cm
.
defaultTextHeight
(
)
;
}
else
if
(
ev
.
deltaMode
=
=
ev
.
DOM_DELTA_PAGE
)
{
deltaX
*
=
cm
.
getWrapperElement
(
)
.
clientWidth
;
deltaY
*
=
cm
.
getWrapperElement
(
)
.
clientHeight
;
}
if
(
cm
.
getScrollerElement
(
)
.
scrollBy
)
{
cm
.
getScrollerElement
(
)
.
scrollBy
(
deltaX
deltaY
)
;
}
}
function
resizeBreakpointGutter
(
editor
)
{
var
gutters
=
editor
.
display
.
gutters
;
var
lineNumbers
=
gutters
.
querySelector
(
"
.
CodeMirror
-
linenumbers
"
)
;
var
breakpoints
=
gutters
.
querySelector
(
"
.
breakpoints
"
)
;
breakpoints
.
style
.
width
=
lineNumbers
.
clientWidth
+
"
px
"
;
}
module
.
exports
=
{
alignLine
onWheel
resizeBreakpointGutter
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
PropTypes
=
React
.
PropTypes
;
function
makeMarker
(
)
{
var
marker
=
document
.
createElement
(
"
div
"
)
;
marker
.
className
=
"
editor
breakpoint
"
;
var
svg
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
"
svg
"
)
;
svg
.
setAttribute
(
"
viewBox
"
"
0
0
60
12
"
)
;
svg
.
setAttribute
(
"
preserveAspectRatio
"
"
none
"
)
;
var
path
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
"
path
"
)
;
path
.
setAttribute
(
"
d
"
"
M53
.
9
0H1C0
.
4
0
0
0
.
4
0
1v10c0
0
.
6
0
.
4
1
1
1h52
.
9c0
.
6
0
1
.
2
-
0
.
3
1
.
5
-
0
.
7L60
6l
-
4
.
4
-
5
.
3C55
0
.
3
54
.
5
0
53
.
9
0z
"
)
;
svg
.
appendChild
(
path
)
;
marker
.
appendChild
(
svg
)
;
return
marker
;
}
var
Breakpoint
=
React
.
createClass
(
{
propTypes
:
{
breakpoint
:
PropTypes
.
object
editor
:
PropTypes
.
object
}
displayName
:
"
Breakpoint
"
addBreakpoint
(
)
{
var
bp
=
this
.
props
.
breakpoint
;
var
line
=
bp
.
location
.
line
-
1
;
this
.
props
.
editor
.
setGutterMarker
(
line
"
breakpoints
"
makeMarker
(
)
)
;
this
.
props
.
editor
.
addLineClass
(
line
"
line
"
"
breakpoint
"
)
;
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
editor
!
=
=
nextProps
.
editor
;
}
componentDidMount
(
)
{
if
(
!
this
.
props
.
editor
)
{
return
;
}
this
.
addBreakpoint
(
)
;
}
componentDidUpdate
(
)
{
this
.
addBreakpoint
(
)
;
}
componentWillUnmount
(
)
{
if
(
!
this
.
props
.
editor
)
{
return
;
}
var
bp
=
this
.
props
.
breakpoint
;
var
line
=
bp
.
location
.
line
-
1
;
this
.
props
.
editor
.
setGutterMarker
(
line
"
breakpoints
"
null
)
;
this
.
props
.
editor
.
removeLineClass
(
line
"
line
"
"
breakpoint
"
)
;
}
render
(
)
{
return
null
;
}
}
)
;
module
.
exports
=
Breakpoint
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
419
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
css
-
loader
/
index
.
js
!
.
/
codemirror
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
css
-
loader
/
index
.
js
!
.
/
codemirror
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
/
*
BASICS
*
/
\
n
\
n
.
CodeMirror
{
\
n
/
*
Set
height
width
borders
and
global
font
properties
here
*
/
\
n
font
-
family
:
monospace
;
\
n
height
:
300px
;
\
n
color
:
black
;
\
n
}
\
n
\
n
/
*
PADDING
*
/
\
n
\
n
.
CodeMirror
-
lines
{
\
n
padding
:
4px
0
;
/
*
Vertical
padding
around
content
*
/
\
n
}
\
n
.
CodeMirror
pre
{
\
n
padding
:
0
4px
;
/
*
Horizontal
padding
of
content
*
/
\
n
}
\
n
\
n
.
CodeMirror
-
scrollbar
-
filler
.
CodeMirror
-
gutter
-
filler
{
\
n
background
-
color
:
white
;
/
*
The
little
square
between
H
and
V
scrollbars
*
/
\
n
}
\
n
\
n
/
*
GUTTER
*
/
\
n
\
n
.
CodeMirror
-
gutters
{
\
n
border
-
right
:
1px
solid
#
ddd
;
\
n
background
-
color
:
#
f7f7f7
;
\
n
white
-
space
:
nowrap
;
\
n
}
\
n
.
CodeMirror
-
linenumbers
{
}
\
n
.
CodeMirror
-
linenumber
{
\
n
padding
:
0
3px
0
5px
;
\
n
min
-
width
:
20px
;
\
n
text
-
align
:
right
;
\
n
color
:
#
999
;
\
n
white
-
space
:
nowrap
;
\
n
}
\
n
\
n
.
CodeMirror
-
guttermarker
{
color
:
black
;
}
\
n
.
CodeMirror
-
guttermarker
-
subtle
{
color
:
#
999
;
}
\
n
\
n
/
*
CURSOR
*
/
\
n
\
n
.
CodeMirror
-
cursor
{
\
n
border
-
left
:
1px
solid
black
;
\
n
border
-
right
:
none
;
\
n
width
:
0
;
\
n
}
\
n
/
*
Shown
when
moving
in
bi
-
directional
text
*
/
\
n
.
CodeMirror
div
.
CodeMirror
-
secondarycursor
{
\
n
border
-
left
:
1px
solid
silver
;
\
n
}
\
n
.
cm
-
fat
-
cursor
.
CodeMirror
-
cursor
{
\
n
width
:
auto
;
\
n
border
:
0
!
important
;
\
n
background
:
#
7e7
;
\
n
}
\
n
.
cm
-
fat
-
cursor
div
.
CodeMirror
-
cursors
{
\
n
z
-
index
:
1
;
\
n
}
\
n
\
n
.
cm
-
animate
-
fat
-
cursor
{
\
n
width
:
auto
;
\
n
border
:
0
;
\
n
-
webkit
-
animation
:
blink
1
.
06s
steps
(
1
)
infinite
;
\
n
-
moz
-
animation
:
blink
1
.
06s
steps
(
1
)
infinite
;
\
n
animation
:
blink
1
.
06s
steps
(
1
)
infinite
;
\
n
background
-
color
:
#
7e7
;
\
n
}
\
n
-
moz
-
keyframes
blink
{
\
n
0
%
{
}
\
n
50
%
{
background
-
color
:
transparent
;
}
\
n
100
%
{
}
\
n
}
\
n
-
webkit
-
keyframes
blink
{
\
n
0
%
{
}
\
n
50
%
{
background
-
color
:
transparent
;
}
\
n
100
%
{
}
\
n
}
\
n
keyframes
blink
{
\
n
0
%
{
}
\
n
50
%
{
background
-
color
:
transparent
;
}
\
n
100
%
{
}
\
n
}
\
n
\
n
/
*
Can
style
cursor
different
in
overwrite
(
non
-
insert
)
mode
*
/
\
n
.
CodeMirror
-
overwrite
.
CodeMirror
-
cursor
{
}
\
n
\
n
.
cm
-
tab
{
display
:
inline
-
block
;
text
-
decoration
:
inherit
;
}
\
n
\
n
.
CodeMirror
-
rulers
{
\
n
position
:
absolute
;
\
n
left
:
0
;
right
:
0
;
top
:
-
50px
;
bottom
:
-
20px
;
\
n
overflow
:
hidden
;
\
n
}
\
n
.
CodeMirror
-
ruler
{
\
n
border
-
left
:
1px
solid
#
ccc
;
\
n
top
:
0
;
bottom
:
0
;
\
n
position
:
absolute
;
\
n
}
\
n
\
n
/
*
DEFAULT
THEME
*
/
\
n
\
n
.
cm
-
s
-
default
.
cm
-
header
{
color
:
blue
;
}
\
n
.
cm
-
s
-
default
.
cm
-
quote
{
color
:
#
090
;
}
\
n
.
cm
-
negative
{
color
:
#
d44
;
}
\
n
.
cm
-
positive
{
color
:
#
292
;
}
\
n
.
cm
-
header
.
cm
-
strong
{
font
-
weight
:
bold
;
}
\
n
.
cm
-
em
{
font
-
style
:
italic
;
}
\
n
.
cm
-
link
{
text
-
decoration
:
underline
;
}
\
n
.
cm
-
strikethrough
{
text
-
decoration
:
line
-
through
;
}
\
n
\
n
.
cm
-
s
-
default
.
cm
-
keyword
{
color
:
#
708
;
}
\
n
.
cm
-
s
-
default
.
cm
-
atom
{
color
:
#
219
;
}
\
n
.
cm
-
s
-
default
.
cm
-
number
{
color
:
#
164
;
}
\
n
.
cm
-
s
-
default
.
cm
-
def
{
color
:
#
00f
;
}
\
n
.
cm
-
s
-
default
.
cm
-
variable
\
n
.
cm
-
s
-
default
.
cm
-
punctuation
\
n
.
cm
-
s
-
default
.
cm
-
property
\
n
.
cm
-
s
-
default
.
cm
-
operator
{
}
\
n
.
cm
-
s
-
default
.
cm
-
variable
-
2
{
color
:
#
05a
;
}
\
n
.
cm
-
s
-
default
.
cm
-
variable
-
3
{
color
:
#
085
;
}
\
n
.
cm
-
s
-
default
.
cm
-
comment
{
color
:
#
a50
;
}
\
n
.
cm
-
s
-
default
.
cm
-
string
{
color
:
#
a11
;
}
\
n
.
cm
-
s
-
default
.
cm
-
string
-
2
{
color
:
#
f50
;
}
\
n
.
cm
-
s
-
default
.
cm
-
meta
{
color
:
#
555
;
}
\
n
.
cm
-
s
-
default
.
cm
-
qualifier
{
color
:
#
555
;
}
\
n
.
cm
-
s
-
default
.
cm
-
builtin
{
color
:
#
30a
;
}
\
n
.
cm
-
s
-
default
.
cm
-
bracket
{
color
:
#
997
;
}
\
n
.
cm
-
s
-
default
.
cm
-
tag
{
color
:
#
170
;
}
\
n
.
cm
-
s
-
default
.
cm
-
attribute
{
color
:
#
00c
;
}
\
n
.
cm
-
s
-
default
.
cm
-
hr
{
color
:
#
999
;
}
\
n
.
cm
-
s
-
default
.
cm
-
link
{
color
:
#
00c
;
}
\
n
\
n
.
cm
-
s
-
default
.
cm
-
error
{
color
:
#
f00
;
}
\
n
.
cm
-
invalidchar
{
color
:
#
f00
;
}
\
n
\
n
.
CodeMirror
-
composing
{
border
-
bottom
:
2px
solid
;
}
\
n
\
n
/
*
Default
styles
for
common
addons
*
/
\
n
\
ndiv
.
CodeMirror
span
.
CodeMirror
-
matchingbracket
{
color
:
#
0f0
;
}
\
ndiv
.
CodeMirror
span
.
CodeMirror
-
nonmatchingbracket
{
color
:
#
f22
;
}
\
n
.
CodeMirror
-
matchingtag
{
background
:
rgba
(
255
150
0
.
3
)
;
}
\
n
.
CodeMirror
-
activeline
-
background
{
background
:
#
e8f2ff
;
}
\
n
\
n
/
*
STOP
*
/
\
n
\
n
/
*
The
rest
of
this
file
contains
styles
related
to
the
mechanics
of
\
n
the
editor
.
You
probably
shouldn
'
t
touch
them
.
*
/
\
n
\
n
.
CodeMirror
{
\
n
position
:
relative
;
\
n
overflow
:
hidden
;
\
n
background
:
white
;
\
n
}
\
n
\
n
.
CodeMirror
-
scroll
{
\
n
overflow
:
scroll
!
important
;
/
*
Things
will
break
if
this
is
overridden
*
/
\
n
/
*
30px
is
the
magic
margin
used
to
hide
the
element
'
s
real
scrollbars
*
/
\
n
/
*
See
overflow
:
hidden
in
.
CodeMirror
*
/
\
n
margin
-
bottom
:
-
30px
;
margin
-
right
:
-
30px
;
\
n
padding
-
bottom
:
30px
;
\
n
height
:
100
%
;
\
n
outline
:
none
;
/
*
Prevent
dragging
from
highlighting
the
element
*
/
\
n
position
:
relative
;
\
n
}
\
n
.
CodeMirror
-
sizer
{
\
n
position
:
relative
;
\
n
border
-
right
:
30px
solid
transparent
;
\
n
}
\
n
\
n
/
*
The
fake
visible
scrollbars
.
Used
to
force
redraw
during
scrolling
\
n
before
actual
scrolling
happens
thus
preventing
shaking
and
\
n
flickering
artifacts
.
*
/
\
n
.
CodeMirror
-
vscrollbar
.
CodeMirror
-
hscrollbar
.
CodeMirror
-
scrollbar
-
filler
.
CodeMirror
-
gutter
-
filler
{
\
n
position
:
absolute
;
\
n
z
-
index
:
6
;
\
n
display
:
none
;
\
n
}
\
n
.
CodeMirror
-
vscrollbar
{
\
n
right
:
0
;
top
:
0
;
\
n
overflow
-
x
:
hidden
;
\
n
overflow
-
y
:
scroll
;
\
n
}
\
n
.
CodeMirror
-
hscrollbar
{
\
n
bottom
:
0
;
left
:
0
;
\
n
overflow
-
y
:
hidden
;
\
n
overflow
-
x
:
scroll
;
\
n
}
\
n
.
CodeMirror
-
scrollbar
-
filler
{
\
n
right
:
0
;
bottom
:
0
;
\
n
}
\
n
.
CodeMirror
-
gutter
-
filler
{
\
n
left
:
0
;
bottom
:
0
;
\
n
}
\
n
\
n
.
CodeMirror
-
gutters
{
\
n
position
:
absolute
;
left
:
0
;
top
:
0
;
\
n
min
-
height
:
100
%
;
\
n
z
-
index
:
3
;
\
n
}
\
n
.
CodeMirror
-
gutter
{
\
n
white
-
space
:
normal
;
\
n
height
:
100
%
;
\
n
display
:
inline
-
block
;
\
n
vertical
-
align
:
top
;
\
n
margin
-
bottom
:
-
30px
;
\
n
/
*
Hack
to
make
IE7
behave
*
/
\
n
*
zoom
:
1
;
\
n
*
display
:
inline
;
\
n
}
\
n
.
CodeMirror
-
gutter
-
wrapper
{
\
n
position
:
absolute
;
\
n
z
-
index
:
4
;
\
n
background
:
none
!
important
;
\
n
border
:
none
!
important
;
\
n
}
\
n
.
CodeMirror
-
gutter
-
background
{
\
n
position
:
absolute
;
\
n
top
:
0
;
bottom
:
0
;
\
n
z
-
index
:
4
;
\
n
}
\
n
.
CodeMirror
-
gutter
-
elt
{
\
n
position
:
absolute
;
\
n
cursor
:
default
;
\
n
z
-
index
:
4
;
\
n
}
\
n
.
CodeMirror
-
gutter
-
wrapper
{
\
n
-
webkit
-
user
-
select
:
none
;
\
n
-
moz
-
user
-
select
:
none
;
\
n
user
-
select
:
none
;
\
n
}
\
n
\
n
.
CodeMirror
-
lines
{
\
n
cursor
:
text
;
\
n
min
-
height
:
1px
;
/
*
prevents
collapsing
before
first
draw
*
/
\
n
}
\
n
.
CodeMirror
pre
{
\
n
/
*
Reset
some
styles
that
the
rest
of
the
page
might
have
set
*
/
\
n
-
moz
-
border
-
radius
:
0
;
-
webkit
-
border
-
radius
:
0
;
border
-
radius
:
0
;
\
n
border
-
width
:
0
;
\
n
background
:
transparent
;
\
n
font
-
family
:
inherit
;
\
n
font
-
size
:
inherit
;
\
n
margin
:
0
;
\
n
white
-
space
:
pre
;
\
n
word
-
wrap
:
normal
;
\
n
line
-
height
:
inherit
;
\
n
color
:
inherit
;
\
n
z
-
index
:
2
;
\
n
position
:
relative
;
\
n
overflow
:
visible
;
\
n
-
webkit
-
tap
-
highlight
-
color
:
transparent
;
\
n
-
webkit
-
font
-
variant
-
ligatures
:
none
;
\
n
font
-
variant
-
ligatures
:
none
;
\
n
}
\
n
.
CodeMirror
-
wrap
pre
{
\
n
word
-
wrap
:
break
-
word
;
\
n
white
-
space
:
pre
-
wrap
;
\
n
word
-
break
:
normal
;
\
n
}
\
n
\
n
.
CodeMirror
-
linebackground
{
\
n
position
:
absolute
;
\
n
left
:
0
;
right
:
0
;
top
:
0
;
bottom
:
0
;
\
n
z
-
index
:
0
;
\
n
}
\
n
\
n
.
CodeMirror
-
linewidget
{
\
n
position
:
relative
;
\
n
z
-
index
:
2
;
\
n
overflow
:
auto
;
\
n
}
\
n
\
n
.
CodeMirror
-
widget
{
}
\
n
\
n
.
CodeMirror
-
code
{
\
n
outline
:
none
;
\
n
}
\
n
\
n
/
*
Force
content
-
box
sizing
for
the
elements
where
we
expect
it
*
/
\
n
.
CodeMirror
-
scroll
\
n
.
CodeMirror
-
sizer
\
n
.
CodeMirror
-
gutter
\
n
.
CodeMirror
-
gutters
\
n
.
CodeMirror
-
linenumber
{
\
n
-
moz
-
box
-
sizing
:
content
-
box
;
\
n
box
-
sizing
:
content
-
box
;
\
n
}
\
n
\
n
.
CodeMirror
-
measure
{
\
n
position
:
absolute
;
\
n
width
:
100
%
;
\
n
height
:
0
;
\
n
overflow
:
hidden
;
\
n
visibility
:
hidden
;
\
n
}
\
n
\
n
.
CodeMirror
-
cursor
{
\
n
position
:
absolute
;
\
n
pointer
-
events
:
none
;
\
n
}
\
n
.
CodeMirror
-
measure
pre
{
position
:
static
;
}
\
n
\
ndiv
.
CodeMirror
-
cursors
{
\
n
visibility
:
hidden
;
\
n
position
:
relative
;
\
n
z
-
index
:
3
;
\
n
}
\
ndiv
.
CodeMirror
-
dragcursors
{
\
n
visibility
:
visible
;
\
n
}
\
n
\
n
.
CodeMirror
-
focused
div
.
CodeMirror
-
cursors
{
\
n
visibility
:
visible
;
\
n
}
\
n
\
n
.
CodeMirror
-
selected
{
background
:
#
d9d9d9
;
}
\
n
.
CodeMirror
-
focused
.
CodeMirror
-
selected
{
background
:
#
d7d4f0
;
}
\
n
.
CodeMirror
-
crosshair
{
cursor
:
crosshair
;
}
\
n
.
CodeMirror
-
line
:
:
selection
.
CodeMirror
-
line
>
span
:
:
selection
.
CodeMirror
-
line
>
span
>
span
:
:
selection
{
background
:
#
d7d4f0
;
}
\
n
.
CodeMirror
-
line
:
:
-
moz
-
selection
.
CodeMirror
-
line
>
span
:
:
-
moz
-
selection
.
CodeMirror
-
line
>
span
>
span
:
:
-
moz
-
selection
{
background
:
#
d7d4f0
;
}
\
n
\
n
.
cm
-
searching
{
\
n
background
:
#
ffa
;
\
n
background
:
rgba
(
255
255
0
.
4
)
;
\
n
}
\
n
\
n
/
*
IE7
hack
to
prevent
it
from
returning
funny
offsetTops
on
the
spans
*
/
\
n
.
CodeMirror
span
{
*
vertical
-
align
:
text
-
bottom
;
}
\
n
\
n
/
*
Used
to
force
a
border
model
for
a
node
*
/
\
n
.
cm
-
force
-
border
{
padding
-
right
:
.
1px
;
}
\
n
\
n
media
print
{
\
n
/
*
Hide
the
cursor
when
printing
*
/
\
n
.
CodeMirror
div
.
CodeMirror
-
cursors
{
\
n
visibility
:
hidden
;
\
n
}
\
n
}
\
n
\
n
/
*
See
issue
#
2901
*
/
\
n
.
cm
-
tab
-
wrap
-
hack
:
after
{
content
:
'
'
;
}
\
n
\
n
/
*
Help
users
use
markselection
to
safely
style
text
background
*
/
\
nspan
.
CodeMirror
-
selectedtext
{
background
:
none
;
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
421
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Editor
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Editor
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
/
*
vim
:
set
ts
=
2
sw
=
2
sts
=
2
et
:
*
/
\
n
\
n
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
\
n
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
\
n
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
\
n
\
n
/
*
*
\
n
*
There
'
s
a
known
codemirror
flex
issue
with
chrome
that
this
addresses
.
\
n
*
BUG
https
:
/
/
github
.
com
/
devtools
-
html
/
debugger
.
html
/
issues
/
63
\
n
*
/
\
n
.
editor
-
wrapper
{
\
n
position
:
absolute
;
\
n
height
:
calc
(
100
%
-
30px
)
;
\
n
width
:
100
%
;
\
n
top
:
30px
;
\
n
left
:
0px
;
\
n
}
\
n
\
n
.
editor
-
wrapper
.
breakpoints
{
\
n
position
:
absolute
;
\
n
top
:
0
;
\
n
left
:
0
;
\
n
}
\
n
\
n
.
editor
.
breakpoint
svg
{
\
n
fill
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
width
:
60px
;
\
n
height
:
12px
;
\
n
position
:
absolute
;
\
n
top
:
0
;
\
n
right
:
-
4px
;
\
n
}
\
n
\
n
.
editor
.
breakpoint
:
hover
{
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
CodeMirror
{
\
n
font
-
family
:
Menlo
monospace
!
important
;
\
n
}
\
n
\
n
/
*
set
the
linenumber
white
when
there
is
a
breakpoint
*
/
\
n
.
breakpoint
.
CodeMirror
-
linenumber
{
\
n
color
:
white
;
\
n
}
\
n
\
n
/
*
move
the
breakpoint
below
the
linenumber
*
/
\
n
.
breakpoint
.
CodeMirror
-
gutter
-
elt
:
last
-
child
{
\
n
z
-
index
:
0
;
\
n
}
\
n
\
n
.
debug
-
line
.
CodeMirror
-
line
{
\
n
background
-
color
:
var
(
-
-
breakpoint
-
active
-
color
)
!
important
;
\
n
}
\
n
\
n
/
*
Don
'
t
display
the
highlight
color
since
the
debug
line
\
n
is
already
highlighted
*
/
\
n
.
debug
-
line
.
CodeMirror
-
activeline
-
background
{
\
n
display
:
none
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
mod
)
{
if
(
true
)
mod
(
__webpack_require__
(
415
)
)
;
else
if
(
typeof
define
=
=
"
function
"
&
&
define
.
amd
)
define
(
[
"
.
.
/
.
.
/
lib
/
codemirror
"
]
mod
)
;
else
mod
(
CodeMirror
)
;
}
)
(
function
(
CodeMirror
)
{
"
use
strict
"
;
function
expressionAllowed
(
stream
state
backUp
)
{
return
/
^
(
?
:
operator
|
sof
|
keyword
c
|
case
|
new
|
[
\
[
{
}
\
(
;
:
]
|
=
>
)
/
.
test
(
state
.
lastType
)
|
|
(
state
.
lastType
=
=
"
quasi
"
&
&
/
\
{
\
s
*
/
.
test
(
stream
.
string
.
slice
(
0
stream
.
pos
-
(
backUp
|
|
0
)
)
)
)
}
CodeMirror
.
defineMode
(
"
javascript
"
function
(
config
parserConfig
)
{
var
indentUnit
=
config
.
indentUnit
;
var
statementIndent
=
parserConfig
.
statementIndent
;
var
jsonldMode
=
parserConfig
.
jsonld
;
var
jsonMode
=
parserConfig
.
json
|
|
jsonldMode
;
var
isTS
=
parserConfig
.
typescript
;
var
wordRE
=
parserConfig
.
wordCharacters
|
|
/
[
\
w
\
xa1
-
\
uffff
]
/
;
var
keywords
=
function
(
)
{
function
kw
(
type
)
{
return
{
type
:
type
style
:
"
keyword
"
}
;
}
var
A
=
kw
(
"
keyword
a
"
)
B
=
kw
(
"
keyword
b
"
)
C
=
kw
(
"
keyword
c
"
)
;
var
operator
=
kw
(
"
operator
"
)
atom
=
{
type
:
"
atom
"
style
:
"
atom
"
}
;
var
jsKeywords
=
{
"
if
"
:
kw
(
"
if
"
)
"
while
"
:
A
"
with
"
:
A
"
else
"
:
B
"
do
"
:
B
"
try
"
:
B
"
finally
"
:
B
"
return
"
:
C
"
break
"
:
C
"
continue
"
:
C
"
new
"
:
kw
(
"
new
"
)
"
delete
"
:
C
"
throw
"
:
C
"
debugger
"
:
C
"
var
"
:
kw
(
"
var
"
)
"
const
"
:
kw
(
"
var
"
)
"
let
"
:
kw
(
"
var
"
)
"
function
"
:
kw
(
"
function
"
)
"
catch
"
:
kw
(
"
catch
"
)
"
for
"
:
kw
(
"
for
"
)
"
switch
"
:
kw
(
"
switch
"
)
"
case
"
:
kw
(
"
case
"
)
"
default
"
:
kw
(
"
default
"
)
"
in
"
:
operator
"
typeof
"
:
operator
"
instanceof
"
:
operator
"
true
"
:
atom
"
false
"
:
atom
"
null
"
:
atom
"
undefined
"
:
atom
"
NaN
"
:
atom
"
Infinity
"
:
atom
"
this
"
:
kw
(
"
this
"
)
"
class
"
:
kw
(
"
class
"
)
"
super
"
:
kw
(
"
atom
"
)
"
yield
"
:
C
"
export
"
:
kw
(
"
export
"
)
"
import
"
:
kw
(
"
import
"
)
"
extends
"
:
C
"
await
"
:
C
"
async
"
:
kw
(
"
async
"
)
}
;
if
(
isTS
)
{
var
type
=
{
type
:
"
variable
"
style
:
"
variable
-
3
"
}
;
var
tsKeywords
=
{
"
interface
"
:
kw
(
"
class
"
)
"
implements
"
:
C
"
namespace
"
:
C
"
module
"
:
kw
(
"
module
"
)
"
enum
"
:
kw
(
"
module
"
)
"
public
"
:
kw
(
"
modifier
"
)
"
private
"
:
kw
(
"
modifier
"
)
"
protected
"
:
kw
(
"
modifier
"
)
"
abstract
"
:
kw
(
"
modifier
"
)
"
as
"
:
operator
"
string
"
:
type
"
number
"
:
type
"
boolean
"
:
type
"
any
"
:
type
}
;
for
(
var
attr
in
tsKeywords
)
{
jsKeywords
[
attr
]
=
tsKeywords
[
attr
]
;
}
}
return
jsKeywords
;
}
(
)
;
var
isOperatorChar
=
/
[
+
\
-
*
&
%
=
<
>
!
?
|
~
^
]
/
;
var
isJsonldKeyword
=
/
^
(
context
|
id
|
value
|
language
|
type
|
container
|
list
|
set
|
reverse
|
index
|
base
|
vocab
|
graph
)
"
/
;
function
readRegexp
(
stream
)
{
var
escaped
=
false
next
inSet
=
false
;
while
(
(
next
=
stream
.
next
(
)
)
!
=
null
)
{
if
(
!
escaped
)
{
if
(
next
=
=
"
/
"
&
&
!
inSet
)
return
;
if
(
next
=
=
"
[
"
)
inSet
=
true
;
else
if
(
inSet
&
&
next
=
=
"
]
"
)
inSet
=
false
;
}
escaped
=
!
escaped
&
&
next
=
=
"
\
\
"
;
}
}
var
type
content
;
function
ret
(
tp
style
cont
)
{
type
=
tp
;
content
=
cont
;
return
style
;
}
function
tokenBase
(
stream
state
)
{
var
ch
=
stream
.
next
(
)
;
if
(
ch
=
=
'
"
'
|
|
ch
=
=
"
'
"
)
{
state
.
tokenize
=
tokenString
(
ch
)
;
return
state
.
tokenize
(
stream
state
)
;
}
else
if
(
ch
=
=
"
.
"
&
&
stream
.
match
(
/
^
\
d
+
(
?
:
[
eE
]
[
+
\
-
]
?
\
d
+
)
?
/
)
)
{
return
ret
(
"
number
"
"
number
"
)
;
}
else
if
(
ch
=
=
"
.
"
&
&
stream
.
match
(
"
.
.
"
)
)
{
return
ret
(
"
spread
"
"
meta
"
)
;
}
else
if
(
/
[
\
[
\
]
{
}
\
(
\
)
;
\
:
\
.
]
/
.
test
(
ch
)
)
{
return
ret
(
ch
)
;
}
else
if
(
ch
=
=
"
=
"
&
&
stream
.
eat
(
"
>
"
)
)
{
return
ret
(
"
=
>
"
"
operator
"
)
;
}
else
if
(
ch
=
=
"
0
"
&
&
stream
.
eat
(
/
x
/
i
)
)
{
stream
.
eatWhile
(
/
[
\
da
-
f
]
/
i
)
;
return
ret
(
"
number
"
"
number
"
)
;
}
else
if
(
ch
=
=
"
0
"
&
&
stream
.
eat
(
/
o
/
i
)
)
{
stream
.
eatWhile
(
/
[
0
-
7
]
/
i
)
;
return
ret
(
"
number
"
"
number
"
)
;
}
else
if
(
ch
=
=
"
0
"
&
&
stream
.
eat
(
/
b
/
i
)
)
{
stream
.
eatWhile
(
/
[
01
]
/
i
)
;
return
ret
(
"
number
"
"
number
"
)
;
}
else
if
(
/
\
d
/
.
test
(
ch
)
)
{
stream
.
match
(
/
^
\
d
*
(
?
:
\
.
\
d
*
)
?
(
?
:
[
eE
]
[
+
\
-
]
?
\
d
+
)
?
/
)
;
return
ret
(
"
number
"
"
number
"
)
;
}
else
if
(
ch
=
=
"
/
"
)
{
if
(
stream
.
eat
(
"
*
"
)
)
{
state
.
tokenize
=
tokenComment
;
return
tokenComment
(
stream
state
)
;
}
else
if
(
stream
.
eat
(
"
/
"
)
)
{
stream
.
skipToEnd
(
)
;
return
ret
(
"
comment
"
"
comment
"
)
;
}
else
if
(
expressionAllowed
(
stream
state
1
)
)
{
readRegexp
(
stream
)
;
stream
.
match
(
/
^
\
b
(
(
[
gimyu
]
)
(
?
!
[
gimyu
]
*
\
2
)
)
+
\
b
/
)
;
return
ret
(
"
regexp
"
"
string
-
2
"
)
;
}
else
{
stream
.
eatWhile
(
isOperatorChar
)
;
return
ret
(
"
operator
"
"
operator
"
stream
.
current
(
)
)
;
}
}
else
if
(
ch
=
=
"
"
)
{
state
.
tokenize
=
tokenQuasi
;
return
tokenQuasi
(
stream
state
)
;
}
else
if
(
ch
=
=
"
#
"
)
{
stream
.
skipToEnd
(
)
;
return
ret
(
"
error
"
"
error
"
)
;
}
else
if
(
isOperatorChar
.
test
(
ch
)
)
{
stream
.
eatWhile
(
isOperatorChar
)
;
return
ret
(
"
operator
"
"
operator
"
stream
.
current
(
)
)
;
}
else
if
(
wordRE
.
test
(
ch
)
)
{
stream
.
eatWhile
(
wordRE
)
;
var
word
=
stream
.
current
(
)
known
=
keywords
.
propertyIsEnumerable
(
word
)
&
&
keywords
[
word
]
;
return
(
known
&
&
state
.
lastType
!
=
"
.
"
)
?
ret
(
known
.
type
known
.
style
word
)
:
ret
(
"
variable
"
"
variable
"
word
)
;
}
}
function
tokenString
(
quote
)
{
return
function
(
stream
state
)
{
var
escaped
=
false
next
;
if
(
jsonldMode
&
&
stream
.
peek
(
)
=
=
"
"
&
&
stream
.
match
(
isJsonldKeyword
)
)
{
state
.
tokenize
=
tokenBase
;
return
ret
(
"
jsonld
-
keyword
"
"
meta
"
)
;
}
while
(
(
next
=
stream
.
next
(
)
)
!
=
null
)
{
if
(
next
=
=
quote
&
&
!
escaped
)
break
;
escaped
=
!
escaped
&
&
next
=
=
"
\
\
"
;
}
if
(
!
escaped
)
state
.
tokenize
=
tokenBase
;
return
ret
(
"
string
"
"
string
"
)
;
}
;
}
function
tokenComment
(
stream
state
)
{
var
maybeEnd
=
false
ch
;
while
(
ch
=
stream
.
next
(
)
)
{
if
(
ch
=
=
"
/
"
&
&
maybeEnd
)
{
state
.
tokenize
=
tokenBase
;
break
;
}
maybeEnd
=
(
ch
=
=
"
*
"
)
;
}
return
ret
(
"
comment
"
"
comment
"
)
;
}
function
tokenQuasi
(
stream
state
)
{
var
escaped
=
false
next
;
while
(
(
next
=
stream
.
next
(
)
)
!
=
null
)
{
if
(
!
escaped
&
&
(
next
=
=
"
"
|
|
next
=
=
"
"
&
&
stream
.
eat
(
"
{
"
)
)
)
{
state
.
tokenize
=
tokenBase
;
break
;
}
escaped
=
!
escaped
&
&
next
=
=
"
\
\
"
;
}
return
ret
(
"
quasi
"
"
string
-
2
"
stream
.
current
(
)
)
;
}
var
brackets
=
"
(
[
{
}
]
)
"
;
function
findFatArrow
(
stream
state
)
{
if
(
state
.
fatArrowAt
)
state
.
fatArrowAt
=
null
;
var
arrow
=
stream
.
string
.
indexOf
(
"
=
>
"
stream
.
start
)
;
if
(
arrow
<
0
)
return
;
var
depth
=
0
sawSomething
=
false
;
for
(
var
pos
=
arrow
-
1
;
pos
>
=
0
;
-
-
pos
)
{
var
ch
=
stream
.
string
.
charAt
(
pos
)
;
var
bracket
=
brackets
.
indexOf
(
ch
)
;
if
(
bracket
>
=
0
&
&
bracket
<
3
)
{
if
(
!
depth
)
{
+
+
pos
;
break
;
}
if
(
-
-
depth
=
=
0
)
break
;
}
else
if
(
bracket
>
=
3
&
&
bracket
<
6
)
{
+
+
depth
;
}
else
if
(
wordRE
.
test
(
ch
)
)
{
sawSomething
=
true
;
}
else
if
(
/
[
"
'
\
/
]
/
.
test
(
ch
)
)
{
return
;
}
else
if
(
sawSomething
&
&
!
depth
)
{
+
+
pos
;
break
;
}
}
if
(
sawSomething
&
&
!
depth
)
state
.
fatArrowAt
=
pos
;
}
var
atomicTypes
=
{
"
atom
"
:
true
"
number
"
:
true
"
variable
"
:
true
"
string
"
:
true
"
regexp
"
:
true
"
this
"
:
true
"
jsonld
-
keyword
"
:
true
}
;
function
JSLexical
(
indented
column
type
align
prev
info
)
{
this
.
indented
=
indented
;
this
.
column
=
column
;
this
.
type
=
type
;
this
.
prev
=
prev
;
this
.
info
=
info
;
if
(
align
!
=
null
)
this
.
align
=
align
;
}
function
inScope
(
state
varname
)
{
for
(
var
v
=
state
.
localVars
;
v
;
v
=
v
.
next
)
if
(
v
.
name
=
=
varname
)
return
true
;
for
(
var
cx
=
state
.
context
;
cx
;
cx
=
cx
.
prev
)
{
for
(
var
v
=
cx
.
vars
;
v
;
v
=
v
.
next
)
if
(
v
.
name
=
=
varname
)
return
true
;
}
}
function
parseJS
(
state
style
type
content
stream
)
{
var
cc
=
state
.
cc
;
cx
.
state
=
state
;
cx
.
stream
=
stream
;
cx
.
marked
=
null
cx
.
cc
=
cc
;
cx
.
style
=
style
;
if
(
!
state
.
lexical
.
hasOwnProperty
(
"
align
"
)
)
state
.
lexical
.
align
=
true
;
while
(
true
)
{
var
combinator
=
cc
.
length
?
cc
.
pop
(
)
:
jsonMode
?
expression
:
statement
;
if
(
combinator
(
type
content
)
)
{
while
(
cc
.
length
&
&
cc
[
cc
.
length
-
1
]
.
lex
)
cc
.
pop
(
)
(
)
;
if
(
cx
.
marked
)
return
cx
.
marked
;
if
(
type
=
=
"
variable
"
&
&
inScope
(
state
content
)
)
return
"
variable
-
2
"
;
return
style
;
}
}
}
var
cx
=
{
state
:
null
column
:
null
marked
:
null
cc
:
null
}
;
function
pass
(
)
{
for
(
var
i
=
arguments
.
length
-
1
;
i
>
=
0
;
i
-
-
)
cx
.
cc
.
push
(
arguments
[
i
]
)
;
}
function
cont
(
)
{
pass
.
apply
(
null
arguments
)
;
return
true
;
}
function
register
(
varname
)
{
function
inList
(
list
)
{
for
(
var
v
=
list
;
v
;
v
=
v
.
next
)
if
(
v
.
name
=
=
varname
)
return
true
;
return
false
;
}
var
state
=
cx
.
state
;
cx
.
marked
=
"
def
"
;
if
(
state
.
context
)
{
if
(
inList
(
state
.
localVars
)
)
return
;
state
.
localVars
=
{
name
:
varname
next
:
state
.
localVars
}
;
}
else
{
if
(
inList
(
state
.
globalVars
)
)
return
;
if
(
parserConfig
.
globalVars
)
state
.
globalVars
=
{
name
:
varname
next
:
state
.
globalVars
}
;
}
}
var
defaultVars
=
{
name
:
"
this
"
next
:
{
name
:
"
arguments
"
}
}
;
function
pushcontext
(
)
{
cx
.
state
.
context
=
{
prev
:
cx
.
state
.
context
vars
:
cx
.
state
.
localVars
}
;
cx
.
state
.
localVars
=
defaultVars
;
}
function
popcontext
(
)
{
cx
.
state
.
localVars
=
cx
.
state
.
context
.
vars
;
cx
.
state
.
context
=
cx
.
state
.
context
.
prev
;
}
function
pushlex
(
type
info
)
{
var
result
=
function
(
)
{
var
state
=
cx
.
state
indent
=
state
.
indented
;
if
(
state
.
lexical
.
type
=
=
"
stat
"
)
indent
=
state
.
lexical
.
indented
;
else
for
(
var
outer
=
state
.
lexical
;
outer
&
&
outer
.
type
=
=
"
)
"
&
&
outer
.
align
;
outer
=
outer
.
prev
)
indent
=
outer
.
indented
;
state
.
lexical
=
new
JSLexical
(
indent
cx
.
stream
.
column
(
)
type
null
state
.
lexical
info
)
;
}
;
result
.
lex
=
true
;
return
result
;
}
function
poplex
(
)
{
var
state
=
cx
.
state
;
if
(
state
.
lexical
.
prev
)
{
if
(
state
.
lexical
.
type
=
=
"
)
"
)
state
.
indented
=
state
.
lexical
.
indented
;
state
.
lexical
=
state
.
lexical
.
prev
;
}
}
poplex
.
lex
=
true
;
function
expect
(
wanted
)
{
function
exp
(
type
)
{
if
(
type
=
=
wanted
)
return
cont
(
)
;
else
if
(
wanted
=
=
"
;
"
)
return
pass
(
)
;
else
return
cont
(
exp
)
;
}
;
return
exp
;
}
function
statement
(
type
value
)
{
if
(
type
=
=
"
var
"
)
return
cont
(
pushlex
(
"
vardef
"
value
.
length
)
vardef
expect
(
"
;
"
)
poplex
)
;
if
(
type
=
=
"
keyword
a
"
)
return
cont
(
pushlex
(
"
form
"
)
expression
statement
poplex
)
;
if
(
type
=
=
"
keyword
b
"
)
return
cont
(
pushlex
(
"
form
"
)
statement
poplex
)
;
if
(
type
=
=
"
{
"
)
return
cont
(
pushlex
(
"
}
"
)
block
poplex
)
;
if
(
type
=
=
"
;
"
)
return
cont
(
)
;
if
(
type
=
=
"
if
"
)
{
if
(
cx
.
state
.
lexical
.
info
=
=
"
else
"
&
&
cx
.
state
.
cc
[
cx
.
state
.
cc
.
length
-
1
]
=
=
poplex
)
cx
.
state
.
cc
.
pop
(
)
(
)
;
return
cont
(
pushlex
(
"
form
"
)
expression
statement
poplex
maybeelse
)
;
}
if
(
type
=
=
"
function
"
)
return
cont
(
functiondef
)
;
if
(
type
=
=
"
for
"
)
return
cont
(
pushlex
(
"
form
"
)
forspec
statement
poplex
)
;
if
(
type
=
=
"
variable
"
)
return
cont
(
pushlex
(
"
stat
"
)
maybelabel
)
;
if
(
type
=
=
"
switch
"
)
return
cont
(
pushlex
(
"
form
"
)
expression
pushlex
(
"
}
"
"
switch
"
)
expect
(
"
{
"
)
block
poplex
poplex
)
;
if
(
type
=
=
"
case
"
)
return
cont
(
expression
expect
(
"
:
"
)
)
;
if
(
type
=
=
"
default
"
)
return
cont
(
expect
(
"
:
"
)
)
;
if
(
type
=
=
"
catch
"
)
return
cont
(
pushlex
(
"
form
"
)
pushcontext
expect
(
"
(
"
)
funarg
expect
(
"
)
"
)
statement
poplex
popcontext
)
;
if
(
type
=
=
"
class
"
)
return
cont
(
pushlex
(
"
form
"
)
className
poplex
)
;
if
(
type
=
=
"
export
"
)
return
cont
(
pushlex
(
"
stat
"
)
afterExport
poplex
)
;
if
(
type
=
=
"
import
"
)
return
cont
(
pushlex
(
"
stat
"
)
afterImport
poplex
)
;
if
(
type
=
=
"
module
"
)
return
cont
(
pushlex
(
"
form
"
)
pattern
pushlex
(
"
}
"
)
expect
(
"
{
"
)
block
poplex
poplex
)
if
(
type
=
=
"
async
"
)
return
cont
(
statement
)
return
pass
(
pushlex
(
"
stat
"
)
expression
expect
(
"
;
"
)
poplex
)
;
}
function
expression
(
type
)
{
return
expressionInner
(
type
false
)
;
}
function
expressionNoComma
(
type
)
{
return
expressionInner
(
type
true
)
;
}
function
expressionInner
(
type
noComma
)
{
if
(
cx
.
state
.
fatArrowAt
=
=
cx
.
stream
.
start
)
{
var
body
=
noComma
?
arrowBodyNoComma
:
arrowBody
;
if
(
type
=
=
"
(
"
)
return
cont
(
pushcontext
pushlex
(
"
)
"
)
commasep
(
pattern
"
)
"
)
poplex
expect
(
"
=
>
"
)
body
popcontext
)
;
else
if
(
type
=
=
"
variable
"
)
return
pass
(
pushcontext
pattern
expect
(
"
=
>
"
)
body
popcontext
)
;
}
var
maybeop
=
noComma
?
maybeoperatorNoComma
:
maybeoperatorComma
;
if
(
atomicTypes
.
hasOwnProperty
(
type
)
)
return
cont
(
maybeop
)
;
if
(
type
=
=
"
function
"
)
return
cont
(
functiondef
maybeop
)
;
if
(
type
=
=
"
keyword
c
"
)
return
cont
(
noComma
?
maybeexpressionNoComma
:
maybeexpression
)
;
if
(
type
=
=
"
(
"
)
return
cont
(
pushlex
(
"
)
"
)
maybeexpression
comprehension
expect
(
"
)
"
)
poplex
maybeop
)
;
if
(
type
=
=
"
operator
"
|
|
type
=
=
"
spread
"
)
return
cont
(
noComma
?
expressionNoComma
:
expression
)
;
if
(
type
=
=
"
[
"
)
return
cont
(
pushlex
(
"
]
"
)
arrayLiteral
poplex
maybeop
)
;
if
(
type
=
=
"
{
"
)
return
contCommasep
(
objprop
"
}
"
null
maybeop
)
;
if
(
type
=
=
"
quasi
"
)
return
pass
(
quasi
maybeop
)
;
if
(
type
=
=
"
new
"
)
return
cont
(
maybeTarget
(
noComma
)
)
;
return
cont
(
)
;
}
function
maybeexpression
(
type
)
{
if
(
type
.
match
(
/
[
;
\
}
\
)
\
]
]
/
)
)
return
pass
(
)
;
return
pass
(
expression
)
;
}
function
maybeexpressionNoComma
(
type
)
{
if
(
type
.
match
(
/
[
;
\
}
\
)
\
]
]
/
)
)
return
pass
(
)
;
return
pass
(
expressionNoComma
)
;
}
function
maybeoperatorComma
(
type
value
)
{
if
(
type
=
=
"
"
)
return
cont
(
expression
)
;
return
maybeoperatorNoComma
(
type
value
false
)
;
}
function
maybeoperatorNoComma
(
type
value
noComma
)
{
var
me
=
noComma
=
=
false
?
maybeoperatorComma
:
maybeoperatorNoComma
;
var
expr
=
noComma
=
=
false
?
expression
:
expressionNoComma
;
if
(
type
=
=
"
=
>
"
)
return
cont
(
pushcontext
noComma
?
arrowBodyNoComma
:
arrowBody
popcontext
)
;
if
(
type
=
=
"
operator
"
)
{
if
(
/
\
+
\
+
|
-
-
/
.
test
(
value
)
)
return
cont
(
me
)
;
if
(
value
=
=
"
?
"
)
return
cont
(
expression
expect
(
"
:
"
)
expr
)
;
return
cont
(
expr
)
;
}
if
(
type
=
=
"
quasi
"
)
{
return
pass
(
quasi
me
)
;
}
if
(
type
=
=
"
;
"
)
return
;
if
(
type
=
=
"
(
"
)
return
contCommasep
(
expressionNoComma
"
)
"
"
call
"
me
)
;
if
(
type
=
=
"
.
"
)
return
cont
(
property
me
)
;
if
(
type
=
=
"
[
"
)
return
cont
(
pushlex
(
"
]
"
)
maybeexpression
expect
(
"
]
"
)
poplex
me
)
;
}
function
quasi
(
type
value
)
{
if
(
type
!
=
"
quasi
"
)
return
pass
(
)
;
if
(
value
.
slice
(
value
.
length
-
2
)
!
=
"
{
"
)
return
cont
(
quasi
)
;
return
cont
(
expression
continueQuasi
)
;
}
function
continueQuasi
(
type
)
{
if
(
type
=
=
"
}
"
)
{
cx
.
marked
=
"
string
-
2
"
;
cx
.
state
.
tokenize
=
tokenQuasi
;
return
cont
(
quasi
)
;
}
}
function
arrowBody
(
type
)
{
findFatArrow
(
cx
.
stream
cx
.
state
)
;
return
pass
(
type
=
=
"
{
"
?
statement
:
expression
)
;
}
function
arrowBodyNoComma
(
type
)
{
findFatArrow
(
cx
.
stream
cx
.
state
)
;
return
pass
(
type
=
=
"
{
"
?
statement
:
expressionNoComma
)
;
}
function
maybeTarget
(
noComma
)
{
return
function
(
type
)
{
if
(
type
=
=
"
.
"
)
return
cont
(
noComma
?
targetNoComma
:
target
)
;
else
return
pass
(
noComma
?
expressionNoComma
:
expression
)
;
}
;
}
function
target
(
_
value
)
{
if
(
value
=
=
"
target
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
maybeoperatorComma
)
;
}
}
function
targetNoComma
(
_
value
)
{
if
(
value
=
=
"
target
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
maybeoperatorNoComma
)
;
}
}
function
maybelabel
(
type
)
{
if
(
type
=
=
"
:
"
)
return
cont
(
poplex
statement
)
;
return
pass
(
maybeoperatorComma
expect
(
"
;
"
)
poplex
)
;
}
function
property
(
type
)
{
if
(
type
=
=
"
variable
"
)
{
cx
.
marked
=
"
property
"
;
return
cont
(
)
;
}
}
function
objprop
(
type
value
)
{
if
(
type
=
=
"
variable
"
|
|
cx
.
style
=
=
"
keyword
"
)
{
cx
.
marked
=
"
property
"
;
if
(
value
=
=
"
get
"
|
|
value
=
=
"
set
"
)
return
cont
(
getterSetter
)
;
return
cont
(
afterprop
)
;
}
else
if
(
type
=
=
"
number
"
|
|
type
=
=
"
string
"
)
{
cx
.
marked
=
jsonldMode
?
"
property
"
:
(
cx
.
style
+
"
property
"
)
;
return
cont
(
afterprop
)
;
}
else
if
(
type
=
=
"
jsonld
-
keyword
"
)
{
return
cont
(
afterprop
)
;
}
else
if
(
type
=
=
"
modifier
"
)
{
return
cont
(
objprop
)
}
else
if
(
type
=
=
"
[
"
)
{
return
cont
(
expression
expect
(
"
]
"
)
afterprop
)
;
}
else
if
(
type
=
=
"
spread
"
)
{
return
cont
(
expression
)
;
}
}
function
getterSetter
(
type
)
{
if
(
type
!
=
"
variable
"
)
return
pass
(
afterprop
)
;
cx
.
marked
=
"
property
"
;
return
cont
(
functiondef
)
;
}
function
afterprop
(
type
)
{
if
(
type
=
=
"
:
"
)
return
cont
(
expressionNoComma
)
;
if
(
type
=
=
"
(
"
)
return
pass
(
functiondef
)
;
}
function
commasep
(
what
end
)
{
function
proceed
(
type
value
)
{
if
(
type
=
=
"
"
)
{
var
lex
=
cx
.
state
.
lexical
;
if
(
lex
.
info
=
=
"
call
"
)
lex
.
pos
=
(
lex
.
pos
|
|
0
)
+
1
;
return
cont
(
what
proceed
)
;
}
if
(
type
=
=
end
|
|
value
=
=
end
)
return
cont
(
)
;
return
cont
(
expect
(
end
)
)
;
}
return
function
(
type
value
)
{
if
(
type
=
=
end
|
|
value
=
=
end
)
return
cont
(
)
;
return
pass
(
what
proceed
)
;
}
;
}
function
contCommasep
(
what
end
info
)
{
for
(
var
i
=
3
;
i
<
arguments
.
length
;
i
+
+
)
cx
.
cc
.
push
(
arguments
[
i
]
)
;
return
cont
(
pushlex
(
end
info
)
commasep
(
what
end
)
poplex
)
;
}
function
block
(
type
)
{
if
(
type
=
=
"
}
"
)
return
cont
(
)
;
return
pass
(
statement
block
)
;
}
function
maybetype
(
type
)
{
if
(
isTS
&
&
type
=
=
"
:
"
)
return
cont
(
typeexpr
)
;
}
function
maybedefault
(
_
value
)
{
if
(
value
=
=
"
=
"
)
return
cont
(
expressionNoComma
)
;
}
function
typeexpr
(
type
)
{
if
(
type
=
=
"
variable
"
)
{
cx
.
marked
=
"
variable
-
3
"
;
return
cont
(
afterType
)
;
}
}
function
afterType
(
type
value
)
{
if
(
value
=
=
"
<
"
)
return
cont
(
commasep
(
typeexpr
"
>
"
)
afterType
)
if
(
type
=
=
"
[
"
)
return
cont
(
expect
(
"
]
"
)
afterType
)
}
function
vardef
(
)
{
return
pass
(
pattern
maybetype
maybeAssign
vardefCont
)
;
}
function
pattern
(
type
value
)
{
if
(
type
=
=
"
modifier
"
)
return
cont
(
pattern
)
if
(
type
=
=
"
variable
"
)
{
register
(
value
)
;
return
cont
(
)
;
}
if
(
type
=
=
"
spread
"
)
return
cont
(
pattern
)
;
if
(
type
=
=
"
[
"
)
return
contCommasep
(
pattern
"
]
"
)
;
if
(
type
=
=
"
{
"
)
return
contCommasep
(
proppattern
"
}
"
)
;
}
function
proppattern
(
type
value
)
{
if
(
type
=
=
"
variable
"
&
&
!
cx
.
stream
.
match
(
/
^
\
s
*
:
/
false
)
)
{
register
(
value
)
;
return
cont
(
maybeAssign
)
;
}
if
(
type
=
=
"
variable
"
)
cx
.
marked
=
"
property
"
;
if
(
type
=
=
"
spread
"
)
return
cont
(
pattern
)
;
if
(
type
=
=
"
}
"
)
return
pass
(
)
;
return
cont
(
expect
(
"
:
"
)
pattern
maybeAssign
)
;
}
function
maybeAssign
(
_type
value
)
{
if
(
value
=
=
"
=
"
)
return
cont
(
expressionNoComma
)
;
}
function
vardefCont
(
type
)
{
if
(
type
=
=
"
"
)
return
cont
(
vardef
)
;
}
function
maybeelse
(
type
value
)
{
if
(
type
=
=
"
keyword
b
"
&
&
value
=
=
"
else
"
)
return
cont
(
pushlex
(
"
form
"
"
else
"
)
statement
poplex
)
;
}
function
forspec
(
type
)
{
if
(
type
=
=
"
(
"
)
return
cont
(
pushlex
(
"
)
"
)
forspec1
expect
(
"
)
"
)
poplex
)
;
}
function
forspec1
(
type
)
{
if
(
type
=
=
"
var
"
)
return
cont
(
vardef
expect
(
"
;
"
)
forspec2
)
;
if
(
type
=
=
"
;
"
)
return
cont
(
forspec2
)
;
if
(
type
=
=
"
variable
"
)
return
cont
(
formaybeinof
)
;
return
pass
(
expression
expect
(
"
;
"
)
forspec2
)
;
}
function
formaybeinof
(
_type
value
)
{
if
(
value
=
=
"
in
"
|
|
value
=
=
"
of
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
expression
)
;
}
return
cont
(
maybeoperatorComma
forspec2
)
;
}
function
forspec2
(
type
value
)
{
if
(
type
=
=
"
;
"
)
return
cont
(
forspec3
)
;
if
(
value
=
=
"
in
"
|
|
value
=
=
"
of
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
expression
)
;
}
return
pass
(
expression
expect
(
"
;
"
)
forspec3
)
;
}
function
forspec3
(
type
)
{
if
(
type
!
=
"
)
"
)
cont
(
expression
)
;
}
function
functiondef
(
type
value
)
{
if
(
value
=
=
"
*
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
functiondef
)
;
}
if
(
type
=
=
"
variable
"
)
{
register
(
value
)
;
return
cont
(
functiondef
)
;
}
if
(
type
=
=
"
(
"
)
return
cont
(
pushcontext
pushlex
(
"
)
"
)
commasep
(
funarg
"
)
"
)
poplex
maybetype
statement
popcontext
)
;
}
function
funarg
(
type
)
{
if
(
type
=
=
"
spread
"
)
return
cont
(
funarg
)
;
return
pass
(
pattern
maybetype
maybedefault
)
;
}
function
className
(
type
value
)
{
if
(
type
=
=
"
variable
"
)
{
register
(
value
)
;
return
cont
(
classNameAfter
)
;
}
}
function
classNameAfter
(
type
value
)
{
if
(
value
=
=
"
extends
"
)
return
cont
(
expression
classNameAfter
)
;
if
(
type
=
=
"
{
"
)
return
cont
(
pushlex
(
"
}
"
)
classBody
poplex
)
;
}
function
classBody
(
type
value
)
{
if
(
type
=
=
"
variable
"
|
|
cx
.
style
=
=
"
keyword
"
)
{
if
(
value
=
=
"
static
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
classBody
)
;
}
cx
.
marked
=
"
property
"
;
if
(
value
=
=
"
get
"
|
|
value
=
=
"
set
"
)
return
cont
(
classGetterSetter
functiondef
classBody
)
;
return
cont
(
functiondef
classBody
)
;
}
if
(
value
=
=
"
*
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
classBody
)
;
}
if
(
type
=
=
"
;
"
)
return
cont
(
classBody
)
;
if
(
type
=
=
"
}
"
)
return
cont
(
)
;
}
function
classGetterSetter
(
type
)
{
if
(
type
!
=
"
variable
"
)
return
pass
(
)
;
cx
.
marked
=
"
property
"
;
return
cont
(
)
;
}
function
afterExport
(
_type
value
)
{
if
(
value
=
=
"
*
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
maybeFrom
expect
(
"
;
"
)
)
;
}
if
(
value
=
=
"
default
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
expression
expect
(
"
;
"
)
)
;
}
return
pass
(
statement
)
;
}
function
afterImport
(
type
)
{
if
(
type
=
=
"
string
"
)
return
cont
(
)
;
return
pass
(
importSpec
maybeFrom
)
;
}
function
importSpec
(
type
value
)
{
if
(
type
=
=
"
{
"
)
return
contCommasep
(
importSpec
"
}
"
)
;
if
(
type
=
=
"
variable
"
)
register
(
value
)
;
if
(
value
=
=
"
*
"
)
cx
.
marked
=
"
keyword
"
;
return
cont
(
maybeAs
)
;
}
function
maybeAs
(
_type
value
)
{
if
(
value
=
=
"
as
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
importSpec
)
;
}
}
function
maybeFrom
(
_type
value
)
{
if
(
value
=
=
"
from
"
)
{
cx
.
marked
=
"
keyword
"
;
return
cont
(
expression
)
;
}
}
function
arrayLiteral
(
type
)
{
if
(
type
=
=
"
]
"
)
return
cont
(
)
;
return
pass
(
expressionNoComma
maybeArrayComprehension
)
;
}
function
maybeArrayComprehension
(
type
)
{
if
(
type
=
=
"
for
"
)
return
pass
(
comprehension
expect
(
"
]
"
)
)
;
if
(
type
=
=
"
"
)
return
cont
(
commasep
(
maybeexpressionNoComma
"
]
"
)
)
;
return
pass
(
commasep
(
expressionNoComma
"
]
"
)
)
;
}
function
comprehension
(
type
)
{
if
(
type
=
=
"
for
"
)
return
cont
(
forspec
comprehension
)
;
if
(
type
=
=
"
if
"
)
return
cont
(
expression
comprehension
)
;
}
function
isContinuedStatement
(
state
textAfter
)
{
return
state
.
lastType
=
=
"
operator
"
|
|
state
.
lastType
=
=
"
"
|
|
isOperatorChar
.
test
(
textAfter
.
charAt
(
0
)
)
|
|
/
[
.
]
/
.
test
(
textAfter
.
charAt
(
0
)
)
;
}
return
{
startState
:
function
(
basecolumn
)
{
var
state
=
{
tokenize
:
tokenBase
lastType
:
"
sof
"
cc
:
[
]
lexical
:
new
JSLexical
(
(
basecolumn
|
|
0
)
-
indentUnit
0
"
block
"
false
)
localVars
:
parserConfig
.
localVars
context
:
parserConfig
.
localVars
&
&
{
vars
:
parserConfig
.
localVars
}
indented
:
basecolumn
|
|
0
}
;
if
(
parserConfig
.
globalVars
&
&
typeof
parserConfig
.
globalVars
=
=
"
object
"
)
state
.
globalVars
=
parserConfig
.
globalVars
;
return
state
;
}
token
:
function
(
stream
state
)
{
if
(
stream
.
sol
(
)
)
{
if
(
!
state
.
lexical
.
hasOwnProperty
(
"
align
"
)
)
state
.
lexical
.
align
=
false
;
state
.
indented
=
stream
.
indentation
(
)
;
findFatArrow
(
stream
state
)
;
}
if
(
state
.
tokenize
!
=
tokenComment
&
&
stream
.
eatSpace
(
)
)
return
null
;
var
style
=
state
.
tokenize
(
stream
state
)
;
if
(
type
=
=
"
comment
"
)
return
style
;
state
.
lastType
=
type
=
=
"
operator
"
&
&
(
content
=
=
"
+
+
"
|
|
content
=
=
"
-
-
"
)
?
"
incdec
"
:
type
;
return
parseJS
(
state
style
type
content
stream
)
;
}
indent
:
function
(
state
textAfter
)
{
if
(
state
.
tokenize
=
=
tokenComment
)
return
CodeMirror
.
Pass
;
if
(
state
.
tokenize
!
=
tokenBase
)
return
0
;
var
firstChar
=
textAfter
&
&
textAfter
.
charAt
(
0
)
lexical
=
state
.
lexical
;
if
(
!
/
^
\
s
*
else
\
b
/
.
test
(
textAfter
)
)
for
(
var
i
=
state
.
cc
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
c
=
state
.
cc
[
i
]
;
if
(
c
=
=
poplex
)
lexical
=
lexical
.
prev
;
else
if
(
c
!
=
maybeelse
)
break
;
}
if
(
lexical
.
type
=
=
"
stat
"
&
&
firstChar
=
=
"
}
"
)
lexical
=
lexical
.
prev
;
if
(
statementIndent
&
&
lexical
.
type
=
=
"
)
"
&
&
lexical
.
prev
.
type
=
=
"
stat
"
)
lexical
=
lexical
.
prev
;
var
type
=
lexical
.
type
closing
=
firstChar
=
=
type
;
if
(
type
=
=
"
vardef
"
)
return
lexical
.
indented
+
(
state
.
lastType
=
=
"
operator
"
|
|
state
.
lastType
=
=
"
"
?
lexical
.
info
+
1
:
0
)
;
else
if
(
type
=
=
"
form
"
&
&
firstChar
=
=
"
{
"
)
return
lexical
.
indented
;
else
if
(
type
=
=
"
form
"
)
return
lexical
.
indented
+
indentUnit
;
else
if
(
type
=
=
"
stat
"
)
return
lexical
.
indented
+
(
isContinuedStatement
(
state
textAfter
)
?
statementIndent
|
|
indentUnit
:
0
)
;
else
if
(
lexical
.
info
=
=
"
switch
"
&
&
!
closing
&
&
parserConfig
.
doubleIndentSwitch
!
=
false
)
return
lexical
.
indented
+
(
/
^
(
?
:
case
|
default
)
\
b
/
.
test
(
textAfter
)
?
indentUnit
:
2
*
indentUnit
)
;
else
if
(
lexical
.
align
)
return
lexical
.
column
+
(
closing
?
0
:
1
)
;
else
return
lexical
.
indented
+
(
closing
?
0
:
indentUnit
)
;
}
electricInput
:
/
^
\
s
*
(
?
:
case
.
*
?
:
|
default
:
|
\
{
|
\
}
)
/
blockCommentStart
:
jsonMode
?
null
:
"
/
*
"
blockCommentEnd
:
jsonMode
?
null
:
"
*
/
"
lineComment
:
jsonMode
?
null
:
"
/
/
"
fold
:
"
brace
"
closeBrackets
:
"
(
)
[
]
{
}
'
'
\
"
\
"
"
helperType
:
jsonMode
?
"
json
"
:
"
javascript
"
jsonldMode
:
jsonldMode
jsonMode
:
jsonMode
expressionAllowed
:
expressionAllowed
skipExpression
:
function
(
state
)
{
var
top
=
state
.
cc
[
state
.
cc
.
length
-
1
]
if
(
top
=
=
expression
|
|
top
=
=
expressionNoComma
)
state
.
cc
.
pop
(
)
}
}
;
}
)
;
CodeMirror
.
registerHelper
(
"
wordChars
"
"
javascript
"
/
[
\
w
]
/
)
;
CodeMirror
.
defineMIME
(
"
text
/
javascript
"
"
javascript
"
)
;
CodeMirror
.
defineMIME
(
"
text
/
ecmascript
"
"
javascript
"
)
;
CodeMirror
.
defineMIME
(
"
application
/
javascript
"
"
javascript
"
)
;
CodeMirror
.
defineMIME
(
"
application
/
x
-
javascript
"
"
javascript
"
)
;
CodeMirror
.
defineMIME
(
"
application
/
ecmascript
"
"
javascript
"
)
;
CodeMirror
.
defineMIME
(
"
application
/
json
"
{
name
:
"
javascript
"
json
:
true
}
)
;
CodeMirror
.
defineMIME
(
"
application
/
x
-
json
"
{
name
:
"
javascript
"
json
:
true
}
)
;
CodeMirror
.
defineMIME
(
"
application
/
ld
+
json
"
{
name
:
"
javascript
"
jsonld
:
true
}
)
;
CodeMirror
.
defineMIME
(
"
text
/
typescript
"
{
name
:
"
javascript
"
typescript
:
true
}
)
;
CodeMirror
.
defineMIME
(
"
application
/
typescript
"
{
name
:
"
javascript
"
typescript
:
true
}
)
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
424
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
codemirror
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
codemirror
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
\
n
.
theme
-
body
{
\
n
background
:
var
(
-
-
theme
-
body
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
sidebar
{
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
theme
-
sidebar
{
\
n
background
:
var
(
-
-
theme
-
sidebar
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
content
-
color1
)
;
\
n
}
\
n
\
n
:
:
-
moz
-
selection
{
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
selection
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
bg
-
darker
{
\
n
background
:
var
(
-
-
theme
-
selection
-
background
-
semitransparent
)
;
\
n
}
\
n
\
n
.
theme
-
selected
\
n
.
CodeMirror
-
hint
-
active
{
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
selection
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
bg
-
contrast
\
n
.
variable
-
or
-
property
:
not
(
[
overridden
]
)
[
changed
]
{
\
n
background
:
var
(
-
-
theme
-
contrast
-
background
)
;
\
n
}
\
n
\
n
.
theme
-
link
\
n
.
cm
-
link
\
n
.
CodeMirror
-
Tern
-
type
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
}
\
n
\
n
.
theme
-
link
:
visited
\
n
.
cm
-
link
:
visited
\
n
.
CodeMirror
-
Tern
-
type
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
}
\
n
\
n
.
theme
-
comment
\
n
.
cm
-
meta
\
n
.
cm
-
hr
\
n
.
cm
-
comment
\
n
.
variable
-
or
-
property
.
token
-
undefined
\
n
.
variable
-
or
-
property
.
token
-
null
\
n
.
CodeMirror
-
Tern
-
completion
-
unknown
:
:
before
{
\
n
color
:
var
(
-
-
theme
-
comment
)
;
\
n
}
\
n
\
n
.
theme
-
gutter
{
\
n
background
-
color
:
var
(
-
-
theme
-
tab
-
toolbar
-
background
)
;
\
n
color
:
var
(
-
-
theme
-
content
-
color3
)
;
\
n
border
-
color
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
separator
{
\
n
border
-
color
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color1
\
n
.
cm
-
number
\
n
.
variable
-
or
-
property
.
token
-
number
\
n
.
variable
-
or
-
property
[
return
]
>
.
title
>
.
name
\
n
.
variable
-
or
-
property
[
scope
]
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
green
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
number
:
before
{
\
n
background
-
color
:
hsl
(
72
100
%
27
%
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
Tern
-
completion
-
number
:
:
before
{
\
n
background
-
color
:
#
5c9966
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color2
\
n
.
cm
-
attribute
\
n
.
cm
-
variable
\
n
.
cm
-
def
\
n
.
cm
-
property
\
n
.
cm
-
qualifier
\
n
.
variables
-
view
-
variable
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
object
:
:
before
{
\
n
background
-
color
:
hsl
(
208
56
%
40
%
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
Tern
-
completion
-
object
:
:
before
{
\
n
background
-
color
:
#
3689b2
;
\
n
}
\
n
\
n
.
cm
-
unused
-
line
{
\
n
text
-
decoration
:
line
-
through
;
\
n
text
-
decoration
-
color
:
#
0072ab
;
\
n
}
\
n
\
n
.
cm
-
executed
-
line
{
\
n
background
-
color
:
#
133c26
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color3
\
n
.
cm
-
builtin
\
n
.
cm
-
tag
\
n
.
cm
-
header
\
n
.
cm
-
bracket
\
n
.
variables
-
view
-
property
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
bluegrey
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
theme
-
fg
-
color3
\
n
.
devtools
-
dark
-
theme
.
cm
-
builtin
\
n
.
devtools
-
dark
-
theme
.
cm
-
tag
\
n
.
devtools
-
dark
-
theme
.
cm
-
header
\
n
.
devtools
-
dark
-
theme
.
cm
-
bracket
\
n
.
devtools
-
dark
-
theme
.
variables
-
view
-
property
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
pink
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
array
:
:
before
{
\
n
background
-
color
:
var
(
-
-
theme
-
highlight
-
bluegrey
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color4
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
orange
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
theme
-
fg
-
color4
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
purple
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color5
\
n
.
cm
-
keyword
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
lightorange
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color6
\
n
.
cm
-
string
\
n
.
cm
-
string
-
2
\
n
.
variable
-
or
-
property
.
token
-
string
\
n
.
CodeMirror
-
Tern
-
farg
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
orange
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
string
:
:
before
\
n
.
CodeMirror
-
Tern
-
completion
-
fn
:
:
before
{
\
n
background
-
color
:
hsl
(
24
85
%
39
%
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
Tern
-
completion
-
string
:
:
before
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
Tern
-
completion
-
fn
:
:
before
{
\
n
background
-
color
:
#
b26b47
;
\
n
}
\
n
\
n
.
theme
-
fg
-
color7
\
n
.
cm
-
atom
\
n
.
cm
-
quote
\
n
.
cm
-
error
\
n
.
variable
-
or
-
property
.
token
-
boolean
\
n
.
variable
-
or
-
property
.
token
-
domnode
\
n
.
variable
-
or
-
property
[
exception
]
>
.
title
>
.
name
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
red
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
completion
-
bool
:
:
before
{
\
n
background
-
color
:
#
bf5656
;
\
n
}
\
n
\
n
.
variable
-
or
-
property
.
token
-
domnode
{
\
n
font
-
weight
:
bold
;
\
n
}
\
n
\
n
.
theme
-
toolbar
\
n
.
devtools
-
toolbar
\
n
.
devtools
-
sidebar
-
tabs
tabs
\
n
.
devtools
-
sidebar
-
alltabs
\
n
.
CodeMirror
-
dialog
{
\
n
/
*
General
toolbar
styling
*
/
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
background
-
color
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
border
-
color
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
theme
-
toolbar
\
n
.
devtools
-
dark
-
theme
.
devtools
-
toolbar
\
n
.
devtools
-
dark
-
theme
.
devtools
-
sidebar
-
tabs
tabs
\
n
.
devtools
-
dark
-
theme
.
devtools
-
sidebar
-
alltabs
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
dialog
{
\
n
/
*
General
toolbar
styling
*
/
\
n
color
:
var
(
-
-
theme
-
body
-
color
-
alt
)
;
\
n
background
-
color
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
border
-
color
:
hsla
(
210
8
%
5
%
0
.
6
)
;
\
n
}
\
n
\
n
.
theme
-
fg
-
contrast
{
\
n
/
*
To
be
used
for
text
on
theme
-
bg
-
contrast
*
/
\
n
color
:
black
;
\
n
}
\
n
\
n
.
ruleview
-
swatch
\
n
.
computedview
-
colorswatch
{
\
n
box
-
shadow
:
0
0
0
1px
#
c4c4c4
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
ruleview
-
swatch
\
n
.
devtools
-
dark
-
theme
.
computedview
-
colorswatch
{
\
n
box
-
shadow
:
0
0
0
1px
#
818181
;
\
n
}
\
n
\
n
.
CodeMirror
.
cm
-
s
-
mozilla
{
\
n
/
*
Inherit
platform
specific
font
sizing
and
styles
*
/
\
n
font
-
family
:
inherit
;
\
n
font
-
size
:
11px
;
\
n
height
:
100
%
;
\
n
background
:
var
(
-
-
theme
-
body
-
background
)
;
\
n
}
\
n
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
{
\
n
background
:
var
(
-
-
theme
-
body
-
background
)
;
\
n
}
\
n
\
n
.
CodeMirror
pre
\
n
.
cm
-
variable
-
2
\
n
.
cm
-
variable
-
3
\
n
.
cm
-
operator
\
n
.
cm
-
special
{
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
pre
\
n
.
devtools
-
dark
-
theme
.
cm
-
variable
-
2
\
n
.
devtools
-
dark
-
theme
.
cm
-
variable
-
3
\
n
.
devtools
-
dark
-
theme
.
cm
-
operator
\
n
.
devtools
-
dark
-
theme
.
cm
-
special
{
\
n
color
:
var
(
-
-
theme
-
content
-
color1
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
lines
.
CodeMirror
-
cursor
{
\
n
border
-
left
:
solid
1px
black
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
lines
.
CodeMirror
-
cursor
{
\
n
border
-
left
:
solid
1px
#
ffffff
;
\
n
}
\
n
\
n
.
CodeMirror
-
focused
.
CodeMirror
-
selected
{
\
n
/
*
selected
text
(
focused
)
*
/
\
n
background
:
rgb
(
185
215
253
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
selected
{
\
n
/
*
selected
text
(
unfocused
)
*
/
\
n
background
:
rgb
(
176
176
176
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
activeline
-
background
{
\
n
/
*
selected
color
with
alpha
*
/
\
n
background
:
rgba
(
185
215
253
0
.
35
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
activeline
-
background
{
\
n
background
:
rgba
(
185
215
253
0
.
15
)
;
\
n
}
\
n
\
ndiv
.
cm
-
s
-
mozilla
span
.
CodeMirror
-
matchingbracket
{
\
n
/
*
highlight
brackets
*
/
\
n
outline
:
solid
1px
rgba
(
0
0
0
0
.
25
)
;
\
n
color
:
black
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
div
span
.
CodeMirror
-
matchingbracket
{
\
n
outline
:
solid
1px
rgba
(
255
255
255
.
25
)
;
\
n
color
:
white
;
\
n
}
\
n
\
n
/
*
Highlight
for
a
line
that
contains
an
error
.
*
/
\
ndiv
.
CodeMirror
div
.
error
-
line
{
\
n
background
:
rgba
(
255
0
0
0
.
2
)
;
\
n
}
\
n
\
n
/
*
Generic
highlighted
text
*
/
\
ndiv
.
CodeMirror
span
.
marked
-
text
{
\
n
background
:
rgba
(
255
255
0
0
.
2
)
;
\
n
border
:
1px
dashed
rgba
(
192
192
0
0
.
6
)
;
\
n
-
moz
-
margin
-
start
:
-
1px
;
\
n
-
moz
-
margin
-
end
:
-
1px
;
\
n
}
\
n
\
n
/
*
Highlight
for
evaluating
current
statement
.
*
/
\
ndiv
.
CodeMirror
span
.
eval
-
text
{
\
n
background
-
color
:
#
ccccdd
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
div
.
CodeMirror
span
.
eval
-
text
{
\
n
background
-
color
:
#
555566
;
\
n
}
\
n
\
n
.
CodeMirror
-
linenumber
{
\
n
/
*
line
number
text
*
/
\
n
color
:
var
(
-
-
theme
-
content
-
color3
)
;
\
n
}
\
n
\
n
.
CodeMirror
-
gutters
{
\
n
/
*
vertical
line
next
to
line
numbers
*
/
\
n
border
-
right
-
color
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
background
-
color
:
var
(
-
-
theme
-
breakpoint
-
background
)
;
\
n
}
\
n
\
n
.
cm
-
s
-
markup
-
view
pre
{
\
n
line
-
height
:
1
.
4em
;
\
n
min
-
height
:
1
.
4em
;
\
n
}
\
n
\
n
.
CodeMirror
-
Tern
-
fname
{
\
n
color
:
#
f7f7f7
;
\
n
}
\
n
\
n
.
CodeMirror
-
hints
\
n
.
CodeMirror
-
Tern
-
tooltip
{
\
n
box
-
shadow
:
0
0
4px
rgba
(
128
128
128
0
.
5
)
;
\
n
background
-
color
:
var
(
-
-
theme
-
sidebar
-
background
)
;
\
n
}
\
n
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
hints
\
n
.
devtools
-
dark
-
theme
.
CodeMirror
-
Tern
-
tooltip
{
\
n
box
-
shadow
:
0
0
4px
rgba
(
255
255
255
0
.
3
)
;
\
n
background
-
color
:
#
0f171f
;
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
ReactDOM
=
__webpack_require__
(
176
)
;
var
Draggable
=
React
.
createFactory
(
__webpack_require__
(
426
)
)
;
__webpack_require__
(
427
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
SplitBox
=
React
.
createClass
(
{
propTypes
:
{
left
:
PropTypes
.
any
.
isRequired
right
:
PropTypes
.
any
.
isRequired
initialWidth
:
PropTypes
.
any
rightFlex
:
PropTypes
.
bool
style
:
PropTypes
.
string
}
displayName
:
"
SplitBox
"
getInitialState
(
)
{
return
{
width
:
this
.
props
.
initialWidth
}
;
}
onMove
(
x
)
{
var
node
=
ReactDOM
.
findDOMNode
(
this
)
;
this
.
setState
(
{
width
:
this
.
props
.
rightFlex
?
node
.
offsetLeft
+
node
.
offsetWidth
-
x
:
x
-
node
.
offsetLeft
}
)
;
}
render
(
)
{
var
_props
=
this
.
props
;
var
left
=
_props
.
left
;
var
right
=
_props
.
right
;
var
rightFlex
=
_props
.
rightFlex
;
var
width
=
this
.
state
.
width
;
return
dom
.
div
(
{
className
:
"
split
-
box
"
style
:
this
.
props
.
style
}
dom
.
div
(
{
className
:
rightFlex
?
"
uncontrolled
"
:
"
controlled
"
style
:
{
width
:
rightFlex
?
null
:
width
}
}
left
)
Draggable
(
{
className
:
"
splitter
"
onMove
:
x
=
>
this
.
onMove
(
x
)
}
)
dom
.
div
(
{
className
:
rightFlex
?
"
controlled
"
:
"
uncontrolled
"
style
:
{
width
:
rightFlex
?
width
:
null
}
}
right
)
)
;
}
}
)
;
module
.
exports
=
SplitBox
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
ReactDOM
=
__webpack_require__
(
176
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
Draggable
=
React
.
createClass
(
{
propTypes
:
{
onMove
:
PropTypes
.
func
.
isRequired
onStart
:
PropTypes
.
func
onStop
:
PropTypes
.
func
style
:
PropTypes
.
object
className
:
PropTypes
.
string
}
displayName
:
"
Draggable
"
startDragging
(
ev
)
{
ev
.
preventDefault
(
)
;
var
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
addEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
addEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStart
&
&
this
.
props
.
onStart
(
)
;
}
onMove
(
ev
)
{
ev
.
preventDefault
(
)
;
this
.
props
.
onMove
(
ev
.
pageX
ev
.
pageY
)
;
}
onUp
(
ev
)
{
ev
.
preventDefault
(
)
;
var
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
removeEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
removeEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStop
&
&
this
.
props
.
onStop
(
)
;
}
render
(
)
{
return
dom
.
div
(
{
style
:
this
.
props
.
style
className
:
this
.
props
.
className
onMouseDown
:
this
.
startDragging
}
)
;
}
}
)
;
module
.
exports
=
Draggable
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
428
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
SplitBox
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
SplitBox
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
split
-
box
{
\
n
display
:
flex
;
\
n
flex
:
1
;
\
n
min
-
width
:
0
;
\
n
}
\
n
\
n
.
split
-
box
.
uncontrolled
{
\
n
display
:
flex
;
\
n
flex
:
1
;
\
n
min
-
width
:
0
;
\
n
overflow
:
auto
;
\
n
}
\
n
\
n
.
split
-
box
.
controlled
{
\
n
display
:
flex
;
\
n
overflow
:
auto
;
\
n
}
\
n
\
n
.
split
-
box
.
splitter
{
\
n
background
-
color
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
border
-
bottom
-
width
:
0
;
\
n
border
-
color
:
white
;
\
n
border
-
left
-
width
:
0
;
\
n
border
-
right
-
width
:
0
;
\
n
border
-
style
:
solid
;
\
n
border
-
top
-
width
:
0
;
\
n
box
-
sizing
:
content
-
box
;
\
n
cursor
:
ew
-
resize
;
\
n
flex
:
0
0
1px
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
_require3
=
__webpack_require__
(
348
)
;
var
getPause
=
_require3
.
getPause
;
var
getIsWaitingOnBreak
=
_require3
.
getIsWaitingOnBreak
;
var
getShouldPauseOnExceptions
=
_require3
.
getShouldPauseOnExceptions
;
var
_require4
=
__webpack_require__
(
196
)
;
var
isEnabled
=
_require4
.
isEnabled
;
var
Svg
=
__webpack_require__
(
387
)
;
var
actions
=
__webpack_require__
(
360
)
;
var
Breakpoints
=
React
.
createFactory
(
__webpack_require__
(
430
)
)
;
var
Expressions
=
React
.
createFactory
(
__webpack_require__
(
450
)
)
;
var
Scopes
=
React
.
createFactory
(
__webpack_require__
(
483
)
)
;
var
Frames
=
React
.
createFactory
(
__webpack_require__
(
490
)
)
;
var
Accordion
=
React
.
createFactory
(
__webpack_require__
(
493
)
)
;
__webpack_require__
(
496
)
;
function
debugBtn
(
onClick
type
className
tooltip
)
{
className
=
{
type
}
{
className
}
;
return
dom
.
span
(
{
onClick
className
key
:
type
}
Svg
(
type
{
title
:
tooltip
}
)
)
;
}
function
getItems
(
)
{
var
items
=
[
{
header
:
"
Breakpoints
"
component
:
Breakpoints
opened
:
true
}
{
header
:
"
Call
Stack
"
component
:
Frames
}
{
header
:
"
Scopes
"
component
:
Scopes
}
]
;
if
(
isEnabled
(
"
features
.
watchExpressions
"
)
)
{
items
.
unshift
(
{
header
:
"
Watch
Expressions
"
component
:
Expressions
opened
:
true
}
)
;
}
return
items
;
}
function
RightSidebar
(
_ref
)
{
var
resume
=
_ref
.
resume
;
var
command
=
_ref
.
command
;
var
breakOnNext
=
_ref
.
breakOnNext
;
var
pause
=
_ref
.
pause
;
var
isWaitingOnBreak
=
_ref
.
isWaitingOnBreak
;
var
pauseOnExceptions
=
_ref
.
pauseOnExceptions
;
var
shouldPauseOnExceptions
=
_ref
.
shouldPauseOnExceptions
;
return
dom
.
div
(
{
className
:
"
right
-
sidebar
"
style
:
{
overflowX
:
"
hidden
"
}
}
dom
.
div
(
{
className
:
"
command
-
bar
"
}
pause
?
[
debugBtn
(
(
)
=
>
command
(
{
type
:
"
resume
"
}
)
"
resume
"
"
active
"
"
Click
to
resume
(
F8
)
"
)
debugBtn
(
(
)
=
>
command
(
{
type
:
"
stepOver
"
}
)
"
stepOver
"
"
active
"
"
Step
Over
(
F10
)
"
)
debugBtn
(
(
)
=
>
command
(
{
type
:
"
stepIn
"
}
)
"
stepIn
"
"
active
"
"
Step
In
(
F11
)
"
)
debugBtn
(
(
)
=
>
command
(
{
type
:
"
stepOut
"
}
)
"
stepOut
"
"
active
"
"
Step
Out
\
u21E7
(
F12
)
"
)
]
:
[
isWaitingOnBreak
?
debugBtn
(
null
"
pause
"
"
disabled
"
"
Click
to
resume
(
F8
)
"
)
:
debugBtn
(
breakOnNext
"
pause
"
"
Click
to
resume
(
F8
)
"
)
debugBtn
(
null
"
stepOver
"
"
disabled
"
"
Step
Over
(
F10
)
"
)
debugBtn
(
null
"
stepIn
"
"
disabled
"
"
Step
In
(
F11
)
"
)
debugBtn
(
null
"
stepOut
"
"
disabled
"
"
Step
Out
\
u21E7
(
F12
)
"
)
]
debugBtn
(
(
)
=
>
command
(
{
type
:
"
disableBreakpoints
"
}
)
"
disableBreakpoints
"
"
disabled
"
"
Disable
Breakpoints
"
)
debugBtn
(
(
)
=
>
pauseOnExceptions
(
!
shouldPauseOnExceptions
)
"
pause
-
exceptions
"
shouldPauseOnExceptions
?
"
enabled
"
:
"
disabled
"
"
Toggle
Pause
on
Exceptions
"
)
debugBtn
(
(
)
=
>
command
(
{
type
:
"
subSettings
"
}
)
"
subSettings
"
"
"
"
Settings
"
)
)
Accordion
(
{
items
:
getItems
(
)
}
)
)
;
}
module
.
exports
=
connect
(
state
=
>
(
{
pause
:
getPause
(
state
)
isWaitingOnBreak
:
getIsWaitingOnBreak
(
state
)
shouldPauseOnExceptions
:
getShouldPauseOnExceptions
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
RightSidebar
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
ImPropTypes
=
__webpack_require__
(
376
)
;
var
Isvg
=
React
.
createFactory
(
__webpack_require__
(
431
)
)
;
var
classnames
=
__webpack_require__
(
379
)
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require3
=
__webpack_require__
(
348
)
;
var
getSource
=
_require3
.
getSource
;
var
getPause
=
_require3
.
getPause
;
var
getBreakpoints
=
_require3
.
getBreakpoints
;
var
_require4
=
__webpack_require__
(
343
)
;
var
makeLocationId
=
_require4
.
makeLocationId
;
var
_require5
=
__webpack_require__
(
324
)
;
var
truncateStr
=
_require5
.
truncateStr
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
__webpack_require__
(
448
)
;
function
isCurrentlyPausedAtBreakpoint
(
state
breakpoint
)
{
var
pause
=
getPause
(
state
)
;
if
(
!
pause
|
|
pause
.
get
(
"
isInterrupted
"
)
)
{
return
false
;
}
var
bpId
=
makeLocationId
(
breakpoint
.
location
)
;
var
pausedId
=
makeLocationId
(
pause
.
getIn
(
[
"
frame
"
"
location
"
]
)
.
toJS
(
)
)
;
return
bpId
=
=
=
pausedId
;
}
var
Breakpoints
=
React
.
createClass
(
{
propTypes
:
{
breakpoints
:
ImPropTypes
.
map
.
isRequired
enableBreakpoint
:
PropTypes
.
func
.
isRequired
disableBreakpoint
:
PropTypes
.
func
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
Breakpoints
"
handleCheckbox
(
breakpoint
)
{
if
(
breakpoint
.
disabled
)
{
this
.
props
.
enableBreakpoint
(
breakpoint
.
location
)
;
}
else
{
this
.
props
.
disableBreakpoint
(
breakpoint
.
location
)
;
}
}
selectBreakpoint
(
breakpoint
)
{
var
sourceId
=
breakpoint
.
location
.
sourceId
;
var
line
=
breakpoint
.
location
.
line
;
this
.
props
.
selectSource
(
sourceId
{
line
}
)
;
}
renderBreakpoint
(
breakpoint
)
{
var
snippet
=
truncateStr
(
breakpoint
.
text
|
|
"
"
30
)
;
var
locationId
=
breakpoint
.
locationId
;
var
line
=
breakpoint
.
location
.
line
;
var
isCurrentlyPaused
=
breakpoint
.
isCurrentlyPaused
;
var
isDisabled
=
breakpoint
.
disabled
;
var
isPausedIcon
=
isCurrentlyPaused
&
&
Isvg
(
{
className
:
"
pause
-
indicator
"
src
:
"
images
/
pause
-
circle
.
svg
"
}
)
;
return
dom
.
div
(
{
className
:
classnames
(
{
breakpoint
paused
:
isCurrentlyPaused
disabled
:
isDisabled
}
)
key
:
locationId
onClick
:
(
)
=
>
this
.
selectBreakpoint
(
breakpoint
)
}
dom
.
input
(
{
type
:
"
checkbox
"
checked
:
!
isDisabled
onChange
:
(
)
=
>
this
.
handleCheckbox
(
breakpoint
)
}
)
dom
.
div
(
{
className
:
"
breakpoint
-
label
"
title
:
breakpoint
.
text
}
{
line
}
{
snippet
}
)
isPausedIcon
)
;
}
render
(
)
{
var
breakpoints
=
this
.
props
.
breakpoints
;
return
dom
.
div
(
{
className
:
"
pane
breakpoints
-
list
"
}
breakpoints
.
size
=
=
=
0
?
dom
.
div
(
{
className
:
"
pane
-
info
"
}
"
No
Breakpoints
"
)
:
breakpoints
.
valueSeq
(
)
.
map
(
bp
=
>
{
return
this
.
renderBreakpoint
(
bp
)
;
}
)
)
;
}
}
)
;
function
_getBreakpoints
(
state
)
{
return
getBreakpoints
(
state
)
.
map
(
bp
=
>
{
var
source
=
getSource
(
state
bp
.
location
.
sourceId
)
;
var
isCurrentlyPaused
=
isCurrentlyPausedAtBreakpoint
(
state
bp
)
;
var
locationId
=
makeLocationId
(
bp
.
location
)
;
bp
=
Object
.
assign
(
{
}
bp
)
;
bp
.
location
.
source
=
source
;
bp
.
locationId
=
locationId
;
bp
.
isCurrentlyPaused
=
isCurrentlyPaused
;
return
bp
;
}
)
;
}
module
.
exports
=
connect
(
(
state
props
)
=
>
(
{
breakpoints
:
_getBreakpoints
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Breakpoints
)
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_createClass
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
var
_react
=
__webpack_require__
(
17
)
;
var
_react2
=
_interopRequireDefault
(
_react
)
;
var
_once
=
__webpack_require__
(
432
)
;
var
_once2
=
_interopRequireDefault
(
_once
)
;
var
_httpplease
=
__webpack_require__
(
434
)
;
var
_httpplease2
=
_interopRequireDefault
(
_httpplease
)
;
var
_oldiexdomain
=
__webpack_require__
(
444
)
;
var
_oldiexdomain2
=
_interopRequireDefault
(
_oldiexdomain
)
;
var
_shouldComponentUpdate
=
__webpack_require__
(
446
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
http
=
_httpplease2
.
default
.
use
(
_oldiexdomain2
.
default
)
;
var
Status
=
{
PENDING
:
'
pending
'
LOADING
:
'
loading
'
LOADED
:
'
loaded
'
FAILED
:
'
failed
'
UNSUPPORTED
:
'
unsupported
'
}
;
var
getRequestsByUrl
=
{
}
;
var
loadedIcons
=
{
}
;
var
createGetOrUseCacheForUrl
=
function
createGetOrUseCacheForUrl
(
url
callback
)
{
if
(
loadedIcons
[
url
]
)
{
(
function
(
)
{
var
params
=
loadedIcons
[
url
]
;
setTimeout
(
function
(
)
{
return
callback
(
params
[
0
]
params
[
1
]
)
;
}
0
)
;
}
)
(
)
;
}
if
(
!
getRequestsByUrl
[
url
]
)
{
getRequestsByUrl
[
url
]
=
[
]
;
http
.
get
(
url
function
(
err
res
)
{
getRequestsByUrl
[
url
]
.
forEach
(
function
(
cb
)
{
loadedIcons
[
url
]
=
[
err
res
]
;
cb
(
err
res
)
;
}
)
;
}
)
;
}
getRequestsByUrl
[
url
]
.
push
(
callback
)
;
}
;
var
supportsInlineSVG
=
(
0
_once2
.
default
)
(
function
(
)
{
if
(
!
document
)
{
return
false
;
}
var
div
=
document
.
createElement
(
'
div
'
)
;
div
.
innerHTML
=
'
<
svg
/
>
'
;
return
div
.
firstChild
&
&
div
.
firstChild
.
namespaceURI
=
=
=
'
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
'
;
}
)
;
var
isSupportedEnvironment
=
(
0
_once2
.
default
)
(
function
(
)
{
return
(
(
typeof
window
!
=
=
'
undefined
'
&
&
window
!
=
=
null
?
window
.
XMLHttpRequest
:
void
0
)
|
|
(
typeof
window
!
=
=
'
undefined
'
&
&
window
!
=
=
null
?
window
.
XDomainRequest
:
void
0
)
)
&
&
supportsInlineSVG
(
)
;
}
)
;
var
uniquifyIDs
=
function
(
)
{
var
mkAttributePattern
=
function
mkAttributePattern
(
attr
)
{
return
'
(
?
:
(
?
:
\
\
s
|
\
\
:
)
'
+
attr
+
'
)
'
;
}
;
var
idPattern
=
new
RegExp
(
'
(
?
:
(
'
+
mkAttributePattern
(
'
id
'
)
+
'
)
=
"
(
[
^
"
]
+
)
"
)
|
(
?
:
(
'
+
mkAttributePattern
(
'
href
'
)
+
'
|
'
+
mkAttributePattern
(
'
role
'
)
+
'
|
'
+
mkAttributePattern
(
'
arcrole
'
)
+
'
)
=
"
\
\
#
(
[
^
"
]
+
)
"
)
|
(
?
:
=
"
url
\
\
(
\
\
#
(
[
^
\
\
)
]
+
)
\
\
)
"
)
'
'
g
'
)
;
return
function
(
svgText
svgID
)
{
var
uniquifyID
=
function
uniquifyID
(
id
)
{
return
id
+
'
___
'
+
svgID
;
}
;
return
svgText
.
replace
(
idPattern
function
(
m
p1
p2
p3
p4
p5
)
{
if
(
p2
)
{
return
p1
+
'
=
"
'
+
uniquifyID
(
p2
)
+
'
"
'
;
}
else
if
(
p4
)
{
return
p3
+
'
=
"
#
'
+
uniquifyID
(
p4
)
+
'
"
'
;
}
else
if
(
p5
)
{
return
'
=
"
url
(
#
'
+
uniquifyID
(
p5
)
+
'
)
"
'
;
}
}
)
;
}
;
}
(
)
;
var
getHash
=
function
getHash
(
str
)
{
var
chr
=
void
0
;
var
hash
=
0
;
var
i
=
void
0
;
var
j
=
void
0
;
var
len
=
void
0
;
if
(
!
str
)
{
return
hash
;
}
for
(
i
=
0
j
=
0
len
=
str
.
length
;
len
<
=
0
?
j
<
len
:
j
>
len
;
i
=
len
<
=
0
?
+
+
j
:
-
-
j
)
{
chr
=
str
.
charCodeAt
(
i
)
;
hash
=
(
hash
<
<
5
)
-
hash
+
chr
;
hash
=
hash
&
hash
;
}
return
hash
;
}
;
var
InlineSVGError
=
function
(
_Error
)
{
_inherits
(
InlineSVGError
_Error
)
;
function
InlineSVGError
(
message
)
{
var
_ret2
;
_classCallCheck
(
this
InlineSVGError
)
;
var
_this
=
_possibleConstructorReturn
(
this
Object
.
getPrototypeOf
(
InlineSVGError
)
.
call
(
this
)
)
;
_this
.
name
=
'
InlineSVGError
'
;
_this
.
isSupportedBrowser
=
true
;
_this
.
isConfigurationError
=
false
;
_this
.
isUnsupportedBrowserError
=
false
;
_this
.
message
=
message
;
return
_ret2
=
_this
_possibleConstructorReturn
(
_this
_ret2
)
;
}
return
InlineSVGError
;
}
(
Error
)
;
var
createError
=
function
createError
(
message
attrs
)
{
var
err
=
new
InlineSVGError
(
message
)
;
Object
.
keys
(
attrs
)
.
forEach
(
function
(
k
)
{
err
[
k
]
=
attrs
[
k
]
;
}
)
;
return
err
;
}
;
var
unsupportedBrowserError
=
function
unsupportedBrowserError
(
message
)
{
var
newMessage
=
message
;
if
(
newMessage
=
=
=
null
)
{
newMessage
=
'
Unsupported
Browser
'
;
}
return
createError
(
newMessage
{
isSupportedBrowser
:
false
isUnsupportedBrowserError
:
true
}
)
;
}
;
var
configurationError
=
function
configurationError
(
message
)
{
return
createError
(
message
{
isConfigurationError
:
true
}
)
;
}
;
var
InlineSVG
=
function
(
_React
Component
)
{
_inherits
(
InlineSVG
_React
Component
)
;
function
InlineSVG
(
props
)
{
_classCallCheck
(
this
InlineSVG
)
;
var
_this2
=
_possibleConstructorReturn
(
this
Object
.
getPrototypeOf
(
InlineSVG
)
.
call
(
this
props
)
)
;
_this2
.
shouldComponentUpdate
=
_shouldComponentUpdate
.
shouldComponentUpdate
;
_this2
.
state
=
{
status
:
Status
.
PENDING
}
;
_this2
.
handleLoad
=
_this2
.
handleLoad
.
bind
(
_this2
)
;
return
_this2
;
}
_createClass
(
InlineSVG
[
{
key
:
'
componentWillMount
'
value
:
function
componentWillMount
(
)
{
if
(
this
.
state
.
status
=
=
=
Status
.
PENDING
)
{
if
(
this
.
props
.
supportTest
(
)
)
{
if
(
this
.
props
.
src
)
{
this
.
setState
(
{
status
:
Status
.
LOADING
}
this
.
load
)
;
}
else
{
this
.
fail
(
configurationError
(
'
Missing
source
'
)
)
;
}
}
else
{
this
.
fail
(
unsupportedBrowserError
(
)
)
;
}
}
}
}
{
key
:
'
fail
'
value
:
function
fail
(
error
)
{
var
_this3
=
this
;
var
status
=
error
.
isUnsupportedBrowserError
?
Status
.
UNSUPPORTED
:
Status
.
FAILED
;
this
.
setState
(
{
status
:
status
}
function
(
)
{
if
(
typeof
_this3
.
props
.
onError
=
=
=
'
function
'
)
{
_this3
.
props
.
onError
(
error
)
;
}
}
)
;
}
}
{
key
:
'
handleLoad
'
value
:
function
handleLoad
(
err
res
)
{
var
_this4
=
this
;
if
(
err
)
{
this
.
fail
(
err
)
;
return
;
}
this
.
setState
(
{
loadedText
:
res
.
text
status
:
Status
.
LOADED
}
function
(
)
{
return
typeof
_this4
.
props
.
onLoad
=
=
=
'
function
'
?
_this4
.
props
.
onLoad
(
)
:
null
;
}
)
;
}
}
{
key
:
'
load
'
value
:
function
load
(
)
{
var
match
=
this
.
props
.
src
.
match
(
/
data
:
image
\
/
svg
[
^
]
*
?
(
;
base64
)
?
(
.
*
)
/
)
;
if
(
match
)
{
return
this
.
handleLoad
(
null
{
text
:
match
[
1
]
?
atob
(
match
[
2
]
)
:
decodeURIComponent
(
match
[
2
]
)
}
)
;
}
if
(
this
.
props
.
cacheGetRequests
)
{
return
createGetOrUseCacheForUrl
(
this
.
props
.
src
this
.
handleLoad
)
;
}
return
http
.
get
(
this
.
props
.
src
this
.
handleLoad
)
;
}
}
{
key
:
'
getClassName
'
value
:
function
getClassName
(
)
{
var
className
=
'
isvg
'
+
this
.
state
.
status
;
if
(
this
.
props
.
className
)
{
className
+
=
'
'
+
this
.
props
.
className
;
}
return
className
;
}
}
{
key
:
'
processSVG
'
value
:
function
processSVG
(
svgText
)
{
if
(
this
.
props
.
uniquifyIDs
)
{
return
uniquifyIDs
(
svgText
getHash
(
this
.
props
.
src
)
)
;
}
return
svgText
;
}
}
{
key
:
'
renderContents
'
value
:
function
renderContents
(
)
{
switch
(
this
.
state
.
status
)
{
case
Status
.
UNSUPPORTED
:
return
this
.
props
.
children
;
default
:
return
this
.
props
.
preloader
;
}
}
}
{
key
:
'
render
'
value
:
function
render
(
)
{
return
this
.
props
.
wrapper
(
{
className
:
this
.
getClassName
(
)
dangerouslySetInnerHTML
:
this
.
state
.
loadedText
?
{
__html
:
this
.
processSVG
(
this
.
state
.
loadedText
)
}
:
undefined
}
this
.
renderContents
(
)
)
;
}
}
]
)
;
return
InlineSVG
;
}
(
_react2
.
default
.
Component
)
;
InlineSVG
.
propTypes
=
{
cacheGetRequests
:
_react2
.
default
.
PropTypes
.
bool
children
:
_react2
.
default
.
PropTypes
.
node
className
:
_react2
.
default
.
PropTypes
.
string
onError
:
_react2
.
default
.
PropTypes
.
func
onLoad
:
_react2
.
default
.
PropTypes
.
func
preloader
:
_react2
.
default
.
PropTypes
.
func
src
:
_react2
.
default
.
PropTypes
.
string
.
isRequired
supportTest
:
_react2
.
default
.
PropTypes
.
func
uniquifyIDs
:
_react2
.
default
.
PropTypes
.
bool
wrapper
:
_react2
.
default
.
PropTypes
.
func
}
;
InlineSVG
.
defaultProps
=
{
wrapper
:
_react2
.
default
.
DOM
.
span
supportTest
:
isSupportedEnvironment
uniquifyIDs
:
true
cacheGetRequests
:
false
}
;
exports
.
default
=
InlineSVG
;
module
.
exports
=
exports
[
'
default
'
]
;
}
function
(
module
exports
__webpack_require__
)
{
var
wrappy
=
__webpack_require__
(
433
)
module
.
exports
=
wrappy
(
once
)
once
.
proto
=
once
(
function
(
)
{
Object
.
defineProperty
(
Function
.
prototype
'
once
'
{
value
:
function
(
)
{
return
once
(
this
)
}
configurable
:
true
}
)
}
)
function
once
(
fn
)
{
var
f
=
function
(
)
{
if
(
f
.
called
)
return
f
.
value
f
.
called
=
true
return
f
.
value
=
fn
.
apply
(
this
arguments
)
}
f
.
called
=
false
return
f
}
}
function
(
module
exports
)
{
module
.
exports
=
wrappy
function
wrappy
(
fn
cb
)
{
if
(
fn
&
&
cb
)
return
wrappy
(
fn
)
(
cb
)
if
(
typeof
fn
!
=
=
'
function
'
)
throw
new
TypeError
(
'
need
wrapper
function
'
)
Object
.
keys
(
fn
)
.
forEach
(
function
(
k
)
{
wrapper
[
k
]
=
fn
[
k
]
}
)
return
wrapper
function
wrapper
(
)
{
var
args
=
new
Array
(
arguments
.
length
)
for
(
var
i
=
0
;
i
<
args
.
length
;
i
+
+
)
{
args
[
i
]
=
arguments
[
i
]
}
var
ret
=
fn
.
apply
(
this
args
)
var
cb
=
args
[
args
.
length
-
1
]
if
(
typeof
ret
=
=
=
'
function
'
&
&
ret
!
=
=
cb
)
{
Object
.
keys
(
cb
)
.
forEach
(
function
(
k
)
{
ret
[
k
]
=
cb
[
k
]
}
)
}
return
ret
}
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
cleanURL
=
__webpack_require__
(
435
)
XHR
=
__webpack_require__
(
436
)
delay
=
__webpack_require__
(
437
)
RequestError
=
__webpack_require__
(
438
)
Response
=
__webpack_require__
(
439
)
Request
=
__webpack_require__
(
440
)
extend
=
__webpack_require__
(
442
)
once
=
__webpack_require__
(
443
)
;
var
i
createError
=
RequestError
.
create
;
function
factory
(
defaults
plugins
)
{
defaults
=
defaults
|
|
{
}
;
plugins
=
plugins
|
|
[
]
;
function
http
(
req
cb
)
{
var
xhr
plugin
done
k
timeoutId
supportsLoadAndErrorEvents
;
req
=
new
Request
(
extend
(
defaults
req
)
)
;
for
(
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
plugin
=
plugins
[
i
]
;
if
(
plugin
.
processRequest
)
{
plugin
.
processRequest
(
req
)
;
}
}
for
(
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
plugin
=
plugins
[
i
]
;
if
(
plugin
.
createXHR
)
{
xhr
=
plugin
.
createXHR
(
req
)
;
break
;
}
}
xhr
=
xhr
|
|
new
XHR
(
)
;
req
.
xhr
=
xhr
;
done
=
once
(
delay
(
function
(
rawError
)
{
clearTimeout
(
timeoutId
)
;
xhr
.
onload
=
xhr
.
onerror
=
xhr
.
onabort
=
xhr
.
onreadystatechange
=
xhr
.
ontimeout
=
xhr
.
onprogress
=
null
;
var
err
=
getError
(
req
rawError
)
;
var
res
=
err
|
|
Response
.
fromRequest
(
req
)
;
for
(
i
=
0
;
i
<
plugins
.
length
;
i
+
+
)
{
plugin
=
plugins
[
i
]
;
if
(
plugin
.
processResponse
)
{
plugin
.
processResponse
(
res
)
;
}
}
if
(
err
&
&
req
.
onerror
)
req
.
onerror
(
err
)
;
if
(
!
err
&
&
req
.
onload
)
req
.
onload
(
res
)
;
if
(
cb
)
cb
(
err
err
?
undefined
:
res
)
;
}
)
)
;
supportsLoadAndErrorEvents
=
(
'
onload
'
in
xhr
)
&
&
(
'
onerror
'
in
xhr
)
;
xhr
.
onload
=
function
(
)
{
done
(
)
;
}
;
xhr
.
onerror
=
done
;
xhr
.
onabort
=
function
(
)
{
done
(
)
;
}
;
xhr
.
onreadystatechange
=
function
(
)
{
if
(
xhr
.
readyState
!
=
=
4
)
return
;
if
(
req
.
aborted
)
return
done
(
)
;
if
(
!
supportsLoadAndErrorEvents
)
{
var
status
;
try
{
status
=
xhr
.
status
;
}
catch
(
err
)
{
}
var
err
=
status
=
=
=
0
?
new
Error
(
'
Internal
XHR
Error
'
)
:
null
;
return
done
(
err
)
;
}
}
;
xhr
.
ontimeout
=
function
(
)
{
}
;
xhr
.
onprogress
=
function
(
)
{
}
;
xhr
.
open
(
req
.
method
req
.
url
)
;
if
(
req
.
timeout
)
{
timeoutId
=
setTimeout
(
function
(
)
{
req
.
timedOut
=
true
;
done
(
)
;
try
{
xhr
.
abort
(
)
;
}
catch
(
err
)
{
}
}
req
.
timeout
)
;
}
for
(
k
in
req
.
headers
)
{
if
(
req
.
headers
.
hasOwnProperty
(
k
)
)
{
xhr
.
setRequestHeader
(
k
req
.
headers
[
k
]
)
;
}
}
xhr
.
send
(
req
.
body
)
;
return
req
;
}
var
method
methods
=
[
'
get
'
'
post
'
'
put
'
'
head
'
'
patch
'
'
delete
'
]
verb
=
function
(
method
)
{
return
function
(
req
cb
)
{
req
=
new
Request
(
req
)
;
req
.
method
=
method
;
return
http
(
req
cb
)
;
}
;
}
;
for
(
i
=
0
;
i
<
methods
.
length
;
i
+
+
)
{
method
=
methods
[
i
]
;
http
[
method
]
=
verb
(
method
)
;
}
http
.
plugins
=
function
(
)
{
return
plugins
;
}
;
http
.
defaults
=
function
(
newValues
)
{
if
(
newValues
)
{
return
factory
(
extend
(
defaults
newValues
)
plugins
)
;
}
return
defaults
;
}
;
http
.
use
=
function
(
)
{
var
newPlugins
=
Array
.
prototype
.
slice
.
call
(
arguments
0
)
;
return
factory
(
defaults
plugins
.
concat
(
newPlugins
)
)
;
}
;
http
.
bare
=
function
(
)
{
return
factory
(
)
;
}
;
http
.
Request
=
Request
;
http
.
Response
=
Response
;
http
.
RequestError
=
RequestError
;
return
http
;
}
module
.
exports
=
factory
(
{
}
[
cleanURL
]
)
;
function
getError
(
req
err
)
{
if
(
req
.
aborted
)
return
createError
(
'
Request
aborted
'
req
{
name
:
'
Abort
'
}
)
;
if
(
req
.
timedOut
)
return
createError
(
'
Request
timeout
'
req
{
name
:
'
Timeout
'
}
)
;
var
xhr
=
req
.
xhr
;
var
type
=
Math
.
floor
(
xhr
.
status
/
100
)
;
var
kind
;
switch
(
type
)
{
case
0
:
case
2
:
if
(
!
err
)
return
;
return
createError
(
err
.
message
req
)
;
case
4
:
if
(
xhr
.
status
=
=
=
404
&
&
!
req
.
errorOn404
)
return
;
kind
=
'
Client
'
;
break
;
case
5
:
kind
=
'
Server
'
;
break
;
default
:
kind
=
'
HTTP
'
;
}
var
msg
=
kind
+
'
Error
:
'
+
'
The
server
returned
a
status
of
'
+
xhr
.
status
+
'
for
the
request
"
'
+
req
.
method
.
toUpperCase
(
)
+
'
'
+
req
.
url
+
'
"
'
;
return
createError
(
msg
req
)
;
}
}
function
(
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
{
processRequest
:
function
(
req
)
{
req
.
url
=
req
.
url
.
replace
(
/
[
^
%
]
+
/
g
function
(
s
)
{
return
encodeURI
(
s
)
;
}
)
;
}
}
;
}
function
(
module
exports
)
{
module
.
exports
=
window
.
XMLHttpRequest
;
}
function
(
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
function
(
fn
)
{
return
function
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
0
)
newFunc
=
function
(
)
{
return
fn
.
apply
(
null
args
)
;
}
;
setTimeout
(
newFunc
0
)
;
}
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
Response
=
__webpack_require__
(
439
)
;
var
extractResponseProps
=
__webpack_require__
(
441
)
;
var
extend
=
__webpack_require__
(
442
)
;
function
RequestError
(
message
props
)
{
var
err
=
new
Error
(
message
)
;
err
.
name
=
'
RequestError
'
;
this
.
name
=
err
.
name
;
this
.
message
=
err
.
message
;
if
(
err
.
stack
)
{
this
.
stack
=
err
.
stack
;
}
this
.
toString
=
function
(
)
{
return
this
.
message
;
}
;
for
(
var
k
in
props
)
{
if
(
props
.
hasOwnProperty
(
k
)
)
{
this
[
k
]
=
props
[
k
]
;
}
}
}
RequestError
.
prototype
=
extend
(
Error
.
prototype
)
;
RequestError
.
prototype
.
constructor
=
RequestError
;
RequestError
.
create
=
function
(
message
req
props
)
{
var
err
=
new
RequestError
(
message
props
)
;
Response
.
call
(
err
extractResponseProps
(
req
)
)
;
return
err
;
}
;
module
.
exports
=
RequestError
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
Request
=
__webpack_require__
(
440
)
;
var
extractResponseProps
=
__webpack_require__
(
441
)
;
function
Response
(
props
)
{
this
.
request
=
props
.
request
;
this
.
xhr
=
props
.
xhr
;
this
.
headers
=
props
.
headers
|
|
{
}
;
this
.
status
=
props
.
status
|
|
0
;
this
.
text
=
props
.
text
;
this
.
body
=
props
.
body
;
this
.
contentType
=
props
.
contentType
;
this
.
isHttpError
=
props
.
status
>
=
400
;
}
Response
.
prototype
.
header
=
Request
.
prototype
.
header
;
Response
.
fromRequest
=
function
(
req
)
{
return
new
Response
(
extractResponseProps
(
req
)
)
;
}
;
module
.
exports
=
Response
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
Request
(
optsOrUrl
)
{
var
opts
=
typeof
optsOrUrl
=
=
=
'
string
'
?
{
url
:
optsOrUrl
}
:
optsOrUrl
|
|
{
}
;
this
.
method
=
opts
.
method
?
opts
.
method
.
toUpperCase
(
)
:
'
GET
'
;
this
.
url
=
opts
.
url
;
this
.
headers
=
opts
.
headers
|
|
{
}
;
this
.
body
=
opts
.
body
;
this
.
timeout
=
opts
.
timeout
|
|
0
;
this
.
errorOn404
=
opts
.
errorOn404
!
=
null
?
opts
.
errorOn404
:
true
;
this
.
onload
=
opts
.
onload
;
this
.
onerror
=
opts
.
onerror
;
}
Request
.
prototype
.
abort
=
function
(
)
{
if
(
this
.
aborted
)
return
;
this
.
aborted
=
true
;
this
.
xhr
.
abort
(
)
;
return
this
;
}
;
Request
.
prototype
.
header
=
function
(
name
value
)
{
var
k
;
for
(
k
in
this
.
headers
)
{
if
(
this
.
headers
.
hasOwnProperty
(
k
)
)
{
if
(
name
.
toLowerCase
(
)
=
=
=
k
.
toLowerCase
(
)
)
{
if
(
arguments
.
length
=
=
=
1
)
{
return
this
.
headers
[
k
]
;
}
delete
this
.
headers
[
k
]
;
break
;
}
}
}
if
(
value
!
=
null
)
{
this
.
headers
[
name
]
=
value
;
return
value
;
}
}
;
module
.
exports
=
Request
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
extend
=
__webpack_require__
(
442
)
;
module
.
exports
=
function
(
req
)
{
var
xhr
=
req
.
xhr
;
var
props
=
{
request
:
req
xhr
:
xhr
}
;
try
{
var
lines
i
m
headers
=
{
}
;
if
(
xhr
.
getAllResponseHeaders
)
{
lines
=
xhr
.
getAllResponseHeaders
(
)
.
split
(
'
\
n
'
)
;
for
(
i
=
0
;
i
<
lines
.
length
;
i
+
+
)
{
if
(
(
m
=
lines
[
i
]
.
match
(
/
\
s
*
(
[
^
\
s
]
+
)
:
\
s
+
(
[
^
\
s
]
+
)
/
)
)
)
{
headers
[
m
[
1
]
]
=
m
[
2
]
;
}
}
}
props
=
extend
(
props
{
status
:
xhr
.
status
contentType
:
xhr
.
contentType
|
|
(
xhr
.
getResponseHeader
&
&
xhr
.
getResponseHeader
(
'
Content
-
Type
'
)
)
headers
:
headers
text
:
xhr
.
responseText
body
:
xhr
.
response
|
|
xhr
.
responseText
}
)
;
}
catch
(
err
)
{
}
return
props
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
extend
function
extend
(
)
{
var
target
=
{
}
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
for
(
var
key
in
source
)
{
if
(
source
.
hasOwnProperty
(
key
)
)
{
target
[
key
]
=
source
[
key
]
}
}
}
return
target
}
}
function
(
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
function
(
fn
)
{
var
result
called
=
false
;
return
function
(
)
{
if
(
!
called
)
{
called
=
true
;
result
=
fn
.
apply
(
this
arguments
)
;
}
return
result
;
}
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
urllite
=
__webpack_require__
(
445
)
once
=
__webpack_require__
(
443
)
;
var
warningShown
=
false
;
var
supportsXHR
=
once
(
function
(
)
{
return
(
typeof
window
!
=
=
'
undefined
'
&
&
window
!
=
=
null
&
&
window
.
XMLHttpRequest
&
&
'
withCredentials
'
in
new
window
.
XMLHttpRequest
(
)
)
;
}
)
;
module
.
exports
=
{
createXHR
:
function
(
req
)
{
var
a
b
k
;
if
(
typeof
window
=
=
=
'
undefined
'
|
|
window
=
=
=
null
)
{
return
;
}
a
=
urllite
(
req
.
url
)
;
b
=
urllite
(
window
.
location
.
href
)
;
if
(
!
a
.
host
)
{
return
;
}
if
(
a
.
protocol
=
=
=
b
.
protocol
&
&
a
.
host
=
=
=
b
.
host
&
&
a
.
port
=
=
=
b
.
port
)
{
return
;
}
if
(
!
warningShown
&
&
req
.
headers
)
{
for
(
k
in
req
.
headers
)
{
if
(
req
.
headers
.
hasOwnProperty
(
k
)
)
{
warningShown
=
true
;
if
(
window
&
&
window
.
console
&
&
window
.
console
.
warn
)
{
window
.
console
.
warn
(
'
Request
headers
are
ignored
in
old
IE
when
using
the
oldiexdomain
plugin
.
'
)
;
}
break
;
}
}
}
if
(
window
.
XDomainRequest
&
&
!
supportsXHR
(
)
)
{
var
xdr
=
new
window
.
XDomainRequest
(
)
;
xdr
.
setRequestHeader
=
function
(
)
{
}
;
return
xdr
;
}
}
}
;
}
function
(
module
exports
)
{
(
function
(
)
{
var
URL
URL_PATTERN
defaults
urllite
__hasProp
=
{
}
.
hasOwnProperty
;
URL_PATTERN
=
/
^
(
?
:
(
?
:
(
[
^
:
\
/
?
\
#
]
+
:
)
\
/
+
|
(
\
/
\
/
)
)
(
?
:
(
[
a
-
z0
-
9
-
\
.
_
~
%
]
+
)
(
?
:
:
(
[
a
-
z0
-
9
-
\
.
_
~
%
]
+
)
)
?
)
?
(
(
[
a
-
z0
-
9
-
\
.
_
~
%
!
&
'
(
)
*
+
;
=
]
+
)
(
?
:
:
(
[
0
-
9
]
+
)
)
?
)
?
)
?
(
[
^
?
\
#
]
*
?
)
(
\
?
[
^
\
#
]
*
)
?
(
\
#
.
*
)
?
/
;
urllite
=
function
(
raw
opts
)
{
return
urllite
.
URL
.
parse
(
raw
opts
)
;
}
;
urllite
.
URL
=
URL
=
(
function
(
)
{
function
URL
(
props
)
{
var
k
v
_ref
;
for
(
k
in
defaults
)
{
if
(
!
__hasProp
.
call
(
defaults
k
)
)
continue
;
v
=
defaults
[
k
]
;
this
[
k
]
=
(
_ref
=
props
[
k
]
)
!
=
null
?
_ref
:
v
;
}
this
.
host
|
|
(
this
.
host
=
this
.
hostname
&
&
this
.
port
?
"
"
+
this
.
hostname
+
"
:
"
+
this
.
port
:
this
.
hostname
?
this
.
hostname
:
'
'
)
;
this
.
origin
|
|
(
this
.
origin
=
this
.
protocol
?
"
"
+
this
.
protocol
+
"
/
/
"
+
this
.
host
:
'
'
)
;
this
.
isAbsolutePathRelative
=
!
this
.
host
&
&
this
.
pathname
.
charAt
(
0
)
=
=
=
'
/
'
;
this
.
isPathRelative
=
!
this
.
host
&
&
this
.
pathname
.
charAt
(
0
)
!
=
=
'
/
'
;
this
.
isRelative
=
this
.
isSchemeRelative
|
|
this
.
isAbsolutePathRelative
|
|
this
.
isPathRelative
;
this
.
isAbsolute
=
!
this
.
isRelative
;
}
URL
.
parse
=
function
(
raw
)
{
var
m
pathname
protocol
;
m
=
raw
.
toString
(
)
.
match
(
URL_PATTERN
)
;
pathname
=
m
[
8
]
|
|
'
'
;
protocol
=
m
[
1
]
;
return
new
urllite
.
URL
(
{
protocol
:
protocol
username
:
m
[
3
]
password
:
m
[
4
]
hostname
:
m
[
6
]
port
:
m
[
7
]
pathname
:
protocol
&
&
pathname
.
charAt
(
0
)
!
=
=
'
/
'
?
"
/
"
+
pathname
:
pathname
search
:
m
[
9
]
hash
:
m
[
10
]
isSchemeRelative
:
m
[
2
]
!
=
null
}
)
;
}
;
return
URL
;
}
)
(
)
;
defaults
=
{
protocol
:
'
'
username
:
'
'
password
:
'
'
host
:
'
'
hostname
:
'
'
port
:
'
'
pathname
:
'
'
search
:
'
'
hash
:
'
'
origin
:
'
'
isSchemeRelative
:
false
}
;
module
.
exports
=
urllite
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
shouldComponentUpdate
=
shouldComponentUpdate
;
exports
.
shouldComponentUpdateContext
=
shouldComponentUpdateContext
;
var
_shallowEqual
=
__webpack_require__
(
447
)
;
var
_shallowEqual2
=
_interopRequireDefault
(
_shallowEqual
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
shouldComponentUpdate
(
nextProps
nextState
)
{
return
!
(
0
_shallowEqual2
.
default
)
(
this
.
props
nextProps
)
|
|
!
(
0
_shallowEqual2
.
default
)
(
this
.
state
nextState
)
;
}
function
shouldComponentUpdateContext
(
nextProps
nextState
nextContext
)
{
return
!
(
0
_shallowEqual2
.
default
)
(
this
.
props
nextProps
)
|
|
!
(
0
_shallowEqual2
.
default
)
(
this
.
state
nextState
)
|
|
!
(
0
_shallowEqual2
.
default
)
(
this
.
context
nextContext
)
;
}
exports
.
default
=
{
shouldComponentUpdate
:
shouldComponentUpdate
shouldComponentUpdateContext
:
shouldComponentUpdateContext
}
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
hasOwnProperty
=
Object
.
prototype
.
hasOwnProperty
;
function
is
(
x
y
)
{
if
(
x
=
=
=
y
)
{
return
x
!
=
=
0
|
|
1
/
x
=
=
=
1
/
y
;
}
else
{
return
x
!
=
=
x
&
&
y
!
=
=
y
;
}
}
function
shallowEqual
(
objA
objB
)
{
if
(
is
(
objA
objB
)
)
{
return
true
;
}
if
(
typeof
objA
!
=
=
'
object
'
|
|
objA
=
=
=
null
|
|
typeof
objB
!
=
=
'
object
'
|
|
objB
=
=
=
null
)
{
return
false
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwnProperty
.
call
(
objB
keysA
[
i
]
)
|
|
!
is
(
objA
[
keysA
[
i
]
]
objB
[
keysA
[
i
]
]
)
)
{
return
false
;
}
}
return
true
;
}
module
.
exports
=
shallowEqual
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
449
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Breakpoints
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Breakpoints
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
breakpoints
-
list
.
breakpoint
{
\
n
font
-
size
:
12px
;
\
n
color
:
var
(
-
-
theme
-
content
-
color1
)
;
\
n
margin
:
0
.
5em
0
;
\
n
line
-
height
:
1em
;
\
n
display
:
flex
;
\
n
flex
-
flow
:
row
;
\
n
align
-
items
:
center
;
\
n
}
\
n
\
n
.
breakpoints
-
list
.
breakpoint
input
{
\
n
flex
:
0
1
content
;
\
n
order
:
1
;
\
n
}
\
n
\
n
/
*
\
n
.
breakpoints
-
list
.
breakpoint
.
paused
{
\
n
}
\
n
*
/
\
n
\
n
.
breakpoints
-
list
.
breakpoint
.
disabled
.
breakpoint
-
label
{
\
n
color
:
var
(
-
-
theme
-
content
-
color3
)
;
\
n
transition
:
color
0
.
5s
linear
;
\
n
}
\
n
\
n
.
breakpoints
-
list
.
breakpoint
:
hover
{
\
n
cursor
:
pointer
;
\
n
background
-
color
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
}
\
n
\
n
.
breakpoints
-
list
.
breakpoint
-
label
{
\
n
flex
:
1
0
auto
;
\
n
order
:
2
;
\
n
}
\
n
\
n
.
breakpoints
-
list
.
pause
-
indicator
{
\
n
flex
:
0
1
content
;
\
n
order
:
3
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
ImPropTypes
=
__webpack_require__
(
376
)
;
var
Svg
=
__webpack_require__
(
387
)
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require3
=
__webpack_require__
(
348
)
;
var
getExpressions
=
_require3
.
getExpressions
;
var
getPause
=
_require3
.
getPause
;
var
Rep
=
React
.
createFactory
(
__webpack_require__
(
451
)
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
__webpack_require__
(
481
)
;
var
Expressions
=
React
.
createClass
(
{
propTypes
:
{
expressions
:
ImPropTypes
.
list
addExpression
:
PropTypes
.
func
updateExpression
:
PropTypes
.
func
deleteExpression
:
PropTypes
.
func
}
displayName
:
"
Expressions
"
inputKeyPress
(
e
_ref
)
{
var
id
=
_ref
.
id
;
if
(
e
.
key
!
=
=
"
Enter
"
)
{
return
;
}
var
addExpression
=
this
.
props
.
addExpression
;
var
expression
=
{
input
:
e
.
target
.
value
}
;
if
(
id
!
=
=
undefined
)
{
expression
.
id
=
id
;
}
e
.
target
.
value
=
"
"
;
addExpression
(
expression
)
;
}
updateExpression
(
e
_ref2
)
{
var
id
=
_ref2
.
id
;
e
.
stopPropagation
(
)
;
var
updateExpression
=
this
.
props
.
updateExpression
;
var
expression
=
{
id
input
:
e
.
target
.
textContent
}
;
updateExpression
(
expression
)
;
}
renderExpressionValue
(
value
)
{
if
(
!
value
)
{
return
;
}
if
(
value
.
exception
)
{
return
Rep
(
{
object
:
value
.
exception
}
)
;
}
return
Rep
(
{
object
:
value
.
result
}
)
;
}
deleteExpression
(
e
expression
)
{
e
.
stopPropagation
(
)
;
var
deleteExpression
=
this
.
props
.
deleteExpression
;
deleteExpression
(
expression
)
;
}
renderExpressionUpdating
(
expression
)
{
return
dom
.
span
(
{
className
:
"
expression
-
input
-
container
"
}
dom
.
input
(
{
type
:
"
text
"
className
:
"
input
-
expression
"
onKeyPress
:
e
=
>
this
.
inputKeyPress
(
e
expression
)
defaultValue
:
expression
.
input
ref
:
c
=
>
{
this
.
_input
=
c
;
}
}
)
)
;
}
renderExpression
(
expression
)
{
return
dom
.
span
(
{
className
:
"
expression
-
output
-
container
"
key
:
expression
.
id
}
dom
.
span
(
{
className
:
"
expression
-
input
"
onClick
:
e
=
>
this
.
updateExpression
(
e
expression
)
}
expression
.
input
)
dom
.
span
(
{
className
:
"
expression
-
seperator
"
}
"
:
"
)
dom
.
span
(
{
className
:
"
expression
-
value
"
}
this
.
renderExpressionValue
(
expression
.
value
)
)
dom
.
span
(
{
className
:
"
close
-
btn
"
onClick
:
e
=
>
this
.
deleteExpression
(
e
expression
)
}
Svg
(
"
close
"
)
)
)
;
}
renderExpressionContainer
(
expression
)
{
return
dom
.
div
(
{
className
:
"
expression
-
container
"
key
:
expression
.
id
+
expression
.
input
}
expression
.
updating
?
this
.
renderExpressionUpdating
(
expression
)
:
this
.
renderExpression
(
expression
)
)
;
}
componentDidUpdate
(
)
{
if
(
this
.
_input
)
{
this
.
_input
.
focus
(
)
;
}
}
render
(
)
{
var
expressions
=
this
.
props
.
expressions
;
return
dom
.
span
(
{
className
:
"
pane
expressions
-
list
"
}
dom
.
input
(
{
type
:
"
text
"
className
:
"
input
-
expression
"
placeholder
:
"
Add
watch
Expression
"
onKeyPress
:
e
=
>
this
.
inputKeyPress
(
e
{
}
)
}
)
expressions
.
toSeq
(
)
.
map
(
expression
=
>
this
.
renderExpressionContainer
(
expression
)
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
pauseInfo
:
getPause
(
state
)
expressions
:
getExpressions
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Expressions
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
Rep
=
React
.
createFactory
(
__webpack_require__
(
452
)
.
Rep
)
;
var
Grip
=
__webpack_require__
(
478
)
.
Grip
;
__webpack_require__
(
479
)
;
function
renderRep
(
_ref
)
{
var
object
=
_ref
.
object
;
return
Rep
(
{
object
defaultRep
:
Grip
}
)
;
}
module
.
exports
=
renderRep
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
Undefined
}
=
__webpack_require__
(
454
)
;
const
{
Null
}
=
__webpack_require__
(
456
)
;
const
{
StringRep
}
=
__webpack_require__
(
457
)
;
const
{
Number
}
=
__webpack_require__
(
458
)
;
const
{
ArrayRep
}
=
__webpack_require__
(
459
)
;
const
{
Obj
}
=
__webpack_require__
(
461
)
;
const
{
Attribute
}
=
__webpack_require__
(
463
)
;
const
{
DateTime
}
=
__webpack_require__
(
465
)
;
const
{
Document
}
=
__webpack_require__
(
466
)
;
const
{
Event
}
=
__webpack_require__
(
468
)
;
const
{
Func
}
=
__webpack_require__
(
469
)
;
const
{
NamedNodeMap
}
=
__webpack_require__
(
470
)
;
const
{
RegExp
}
=
__webpack_require__
(
471
)
;
const
{
StyleSheet
}
=
__webpack_require__
(
472
)
;
const
{
TextNode
}
=
__webpack_require__
(
473
)
;
const
{
Window
}
=
__webpack_require__
(
474
)
;
const
{
ObjectWithText
}
=
__webpack_require__
(
475
)
;
const
{
ObjectWithURL
}
=
__webpack_require__
(
476
)
;
const
{
GripArray
}
=
__webpack_require__
(
477
)
;
const
{
Grip
}
=
__webpack_require__
(
478
)
;
let
reps
=
[
RegExp
StyleSheet
Event
DateTime
TextNode
NamedNodeMap
Attribute
Func
ArrayRep
Document
Window
ObjectWithText
ObjectWithURL
GripArray
Grip
Undefined
Null
StringRep
Number
]
;
const
Rep
=
React
.
createClass
(
{
displayName
:
"
Rep
"
propTypes
:
{
object
:
React
.
PropTypes
.
any
defaultRep
:
React
.
PropTypes
.
object
}
render
:
function
(
)
{
let
rep
=
getRep
(
this
.
props
.
object
this
.
props
.
defaultRep
)
;
return
rep
(
this
.
props
)
;
}
}
)
;
function
getRep
(
object
defaultRep
=
Obj
)
{
let
type
=
typeof
object
;
if
(
type
=
=
"
object
"
&
&
object
instanceof
String
)
{
type
=
"
string
"
;
}
if
(
isGrip
(
object
)
)
{
type
=
object
.
class
;
}
for
(
let
i
=
0
;
i
<
reps
.
length
;
i
+
+
)
{
let
rep
=
reps
[
i
]
;
try
{
if
(
rep
.
supportsObject
(
object
type
)
)
{
return
React
.
createFactory
(
rep
.
rep
)
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
}
return
React
.
createFactory
(
defaultRep
.
rep
)
;
}
exports
.
Rep
=
Rep
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
function
createFactories
(
args
)
{
let
result
=
{
}
;
for
(
let
p
in
args
)
{
result
[
p
]
=
React
.
createFactory
(
args
[
p
]
)
;
}
return
result
;
}
function
isGrip
(
object
)
{
return
object
&
&
object
.
actor
;
}
function
escapeNewLines
(
value
)
{
return
value
.
replace
(
/
\
r
/
gm
"
\
\
r
"
)
.
replace
(
/
\
n
/
gm
"
\
\
n
"
)
;
}
function
cropMultipleLines
(
text
limit
)
{
return
escapeNewLines
(
cropString
(
text
limit
)
)
;
}
function
cropString
(
text
limit
alternativeText
)
{
if
(
!
alternativeText
)
{
alternativeText
=
"
\
u2026
"
;
}
text
=
text
+
"
"
;
if
(
!
limit
)
{
limit
=
50
;
}
if
(
limit
<
=
0
)
{
return
text
;
}
if
(
limit
<
=
alternativeText
.
length
)
{
limit
=
alternativeText
.
length
+
1
;
}
let
halfLimit
=
(
limit
-
alternativeText
.
length
)
/
2
;
if
(
text
.
length
>
limit
)
{
return
text
.
substr
(
0
Math
.
ceil
(
halfLimit
)
)
+
alternativeText
+
text
.
substr
(
text
.
length
-
Math
.
floor
(
halfLimit
)
)
;
}
return
text
;
}
exports
.
createFactories
=
createFactories
;
exports
.
isGrip
=
isGrip
;
exports
.
cropString
=
cropString
;
exports
.
cropMultipleLines
=
cropMultipleLines
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
Undefined
=
React
.
createClass
(
{
displayName
:
"
UndefinedRep
"
render
:
function
(
)
{
return
(
ObjectBox
(
{
className
:
"
undefined
"
}
"
undefined
"
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
undefined
"
)
{
return
true
;
}
return
(
type
=
=
"
undefined
"
)
;
}
exports
.
Undefined
=
{
rep
:
Undefined
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
DOM
=
React
.
DOM
;
const
ObjectBox
=
React
.
createClass
(
{
displayName
:
"
ObjectBox
"
render
:
function
(
)
{
let
className
=
this
.
props
.
className
;
let
boxClassName
=
className
?
"
objectBox
-
"
+
className
:
"
"
;
return
(
DOM
.
span
(
{
className
:
"
objectBox
"
+
boxClassName
role
:
"
presentation
"
}
this
.
props
.
children
)
)
;
}
}
)
;
exports
.
ObjectBox
=
ObjectBox
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
Null
=
React
.
createClass
(
{
displayName
:
"
NullRep
"
render
:
function
(
)
{
return
(
ObjectBox
(
{
className
:
"
null
"
}
"
null
"
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
null
"
)
{
return
true
;
}
return
(
object
=
=
null
)
;
}
exports
.
Null
=
{
rep
:
Null
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
cropMultipleLines
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
StringRep
=
React
.
createClass
(
{
displayName
:
"
StringRep
"
render
:
function
(
)
{
let
text
=
this
.
props
.
object
;
let
member
=
this
.
props
.
member
;
if
(
member
&
&
member
.
open
)
{
return
(
ObjectBox
(
{
className
:
"
string
"
}
"
\
"
"
+
text
+
"
\
"
"
)
)
;
}
return
(
ObjectBox
(
{
className
:
"
string
"
}
"
\
"
"
+
cropMultipleLines
(
text
)
+
"
\
"
"
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
return
(
type
=
=
"
string
"
)
;
}
exports
.
StringRep
=
{
rep
:
StringRep
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
Number
=
React
.
createClass
(
{
displayName
:
"
Number
"
stringify
:
function
(
object
)
{
return
(
Object
.
is
(
object
-
0
)
?
"
-
0
"
:
String
(
object
)
)
;
}
render
:
function
(
)
{
let
value
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
number
"
}
this
.
stringify
(
value
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
;
}
exports
.
Number
=
{
rep
:
Number
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
460
)
)
;
const
DOM
=
React
.
DOM
;
let
ArrayRep
=
React
.
createClass
(
{
displayName
:
"
ArrayRep
"
getTitle
:
function
(
object
context
)
{
return
"
[
"
+
object
.
length
+
"
]
"
;
}
arrayIterator
:
function
(
array
max
)
{
let
items
=
[
]
;
let
delim
;
for
(
let
i
=
0
;
i
<
array
.
length
&
&
i
<
=
max
;
i
+
+
)
{
try
{
let
value
=
array
[
i
]
;
delim
=
(
i
=
=
array
.
length
-
1
?
"
"
:
"
"
)
;
if
(
value
=
=
=
array
)
{
items
.
push
(
Reference
(
{
key
:
i
object
:
value
delim
:
delim
}
)
)
;
}
else
{
items
.
push
(
ItemRep
(
{
key
:
i
object
:
value
delim
:
delim
}
)
)
;
}
}
catch
(
exc
)
{
items
.
push
(
ItemRep
(
{
object
:
exc
delim
:
delim
key
:
i
}
)
)
;
}
}
if
(
array
.
length
>
max
+
1
)
{
items
.
pop
(
)
;
items
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
return
items
;
}
hasSpecialProperties
:
function
(
array
)
{
function
isInteger
(
x
)
{
let
y
=
parseInt
(
x
10
)
;
if
(
isNaN
(
y
)
)
{
return
false
;
}
return
x
=
=
=
y
.
toString
(
)
;
}
let
props
=
Object
.
getOwnPropertyNames
(
array
)
;
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
let
p
=
props
[
i
]
;
if
(
isInteger
(
p
)
)
{
continue
;
}
if
(
p
!
=
"
length
"
)
{
return
true
;
}
}
return
false
;
}
onToggleProperties
:
function
(
event
)
{
}
onClickBracket
:
function
(
event
)
{
}
render
:
function
(
)
{
let
mode
=
this
.
props
.
mode
|
|
"
short
"
;
let
object
=
this
.
props
.
object
;
let
items
;
if
(
mode
=
=
"
tiny
"
)
{
items
=
DOM
.
span
(
{
className
:
"
length
"
}
object
.
length
)
;
}
else
{
let
max
=
(
mode
=
=
"
short
"
)
?
3
:
300
;
items
=
this
.
arrayIterator
(
object
max
)
;
}
return
(
ObjectBox
(
{
className
:
"
array
"
onClick
:
this
.
onToggleProperties
}
DOM
.
a
(
{
className
:
"
objectLink
"
onclick
:
this
.
onClickBracket
}
DOM
.
span
(
{
className
:
"
arrayLeftBracket
"
role
:
"
presentation
"
}
"
[
"
)
)
items
DOM
.
a
(
{
className
:
"
objectLink
"
onclick
:
this
.
onClickBracket
}
DOM
.
span
(
{
className
:
"
arrayRightBracket
"
role
:
"
presentation
"
}
"
]
"
)
)
DOM
.
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
)
;
}
}
)
;
let
ItemRep
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
ItemRep
"
render
:
function
(
)
{
const
{
Rep
}
=
createFactories
(
__webpack_require__
(
452
)
)
;
let
object
=
this
.
props
.
object
;
let
delim
=
this
.
props
.
delim
;
return
(
DOM
.
span
(
{
}
Rep
(
{
object
:
object
}
)
delim
)
)
;
}
}
)
)
;
let
Reference
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
Reference
"
render
:
function
(
)
{
let
tooltip
=
"
Circular
reference
"
;
return
(
DOM
.
span
(
{
title
:
tooltip
}
"
[
.
.
.
]
"
)
)
;
}
}
)
)
;
function
supportsObject
(
object
type
)
{
return
Array
.
isArray
(
object
)
|
|
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Arguments
]
"
;
}
exports
.
ArrayRep
=
{
rep
:
ArrayRep
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
DOM
=
React
.
DOM
;
const
Caption
=
React
.
createClass
(
{
displayName
:
"
Caption
"
render
:
function
(
)
{
return
(
DOM
.
span
(
{
"
className
"
:
"
caption
"
}
this
.
props
.
object
)
)
;
}
}
)
;
exports
.
Caption
=
Caption
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
460
)
)
;
const
{
PropRep
}
=
createFactories
(
__webpack_require__
(
462
)
)
;
const
{
span
}
=
React
.
DOM
;
const
Obj
=
React
.
createClass
(
{
displayName
:
"
Obj
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
string
}
getTitle
:
function
(
)
{
return
"
Object
"
;
}
longPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
100
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
shortPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
3
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
propIterator
:
function
(
object
max
)
{
let
isInterestingProp
=
(
t
value
)
=
>
{
return
(
t
=
=
"
boolean
"
|
|
t
=
=
"
number
"
|
|
(
t
=
=
"
string
"
&
&
value
)
)
;
}
;
if
(
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Generator
]
"
)
{
object
=
Object
.
getPrototypeOf
(
object
)
;
}
let
props
=
this
.
getProps
(
object
max
isInterestingProp
)
;
if
(
props
.
length
<
=
max
)
{
props
=
props
.
concat
(
this
.
getProps
(
object
max
(
t
value
)
=
>
{
return
!
isInterestingProp
(
t
value
)
;
}
)
)
;
}
if
(
props
.
length
>
max
)
{
props
.
pop
(
)
;
props
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
else
if
(
props
.
length
>
0
)
{
props
[
props
.
length
-
1
]
=
React
.
cloneElement
(
props
[
props
.
length
-
1
]
{
delim
:
"
"
}
)
;
}
return
props
;
}
getProps
:
function
(
object
max
filter
)
{
let
props
=
[
]
;
max
=
max
|
|
3
;
if
(
!
object
)
{
return
props
;
}
let
mode
=
this
.
props
.
mode
;
try
{
for
(
let
name
in
object
)
{
if
(
props
.
length
>
max
)
{
return
props
;
}
let
value
;
try
{
value
=
object
[
name
]
;
}
catch
(
exc
)
{
continue
;
}
let
t
=
typeof
value
;
if
(
filter
(
t
value
)
)
{
props
.
push
(
PropRep
(
{
key
:
name
mode
:
mode
name
:
name
object
:
value
equal
:
"
:
"
delim
:
"
"
}
)
)
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
props
;
}
render
:
function
(
)
{
let
object
=
this
.
props
.
object
;
let
props
=
this
.
shortPropIterator
(
object
)
;
if
(
this
.
props
.
mode
=
=
"
tiny
"
|
|
!
props
.
length
)
{
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
)
)
)
)
;
}
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
)
)
span
(
{
className
:
"
objectLeftBrace
"
role
:
"
presentation
"
}
"
{
"
)
props
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
return
true
;
}
exports
.
Obj
=
{
rep
:
Obj
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
453
)
;
const
{
span
}
=
React
.
DOM
;
let
PropRep
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
PropRep
"
propTypes
:
{
name
:
React
.
PropTypes
.
string
equal
:
React
.
PropTypes
.
string
delim
:
React
.
PropTypes
.
string
}
render
:
function
(
)
{
let
{
Rep
}
=
createFactories
(
__webpack_require__
(
452
)
)
;
return
(
span
(
{
}
span
(
{
"
className
"
:
"
nodeName
"
}
this
.
props
.
name
)
span
(
{
"
className
"
:
"
objectEqual
"
role
:
"
presentation
"
}
this
.
props
.
equal
)
Rep
(
this
.
props
)
span
(
{
"
className
"
:
"
objectComma
"
role
:
"
presentation
"
}
this
.
props
.
delim
)
)
)
;
}
}
)
)
;
exports
.
PropRep
=
PropRep
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
const
{
StringRep
}
=
__webpack_require__
(
457
)
;
const
{
span
}
=
React
.
DOM
;
const
{
rep
:
StringRepFactory
}
=
createFactories
(
StringRep
)
;
let
Attribute
=
React
.
createClass
(
{
displayName
:
"
Attr
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getTitle
:
function
(
grip
)
{
return
grip
.
preview
.
nodeName
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
value
=
grip
.
preview
.
value
;
return
(
ObjectLink
(
{
className
:
"
Attr
"
}
span
(
{
}
span
(
{
className
:
"
attrTitle
"
}
this
.
getTitle
(
grip
)
)
span
(
{
className
:
"
attrEqual
"
}
"
=
"
)
StringRepFactory
(
{
object
:
value
}
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
type
=
=
"
Attr
"
&
&
grip
.
preview
)
;
}
exports
.
Attribute
=
{
rep
:
Attribute
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
DOM
=
React
.
DOM
;
const
ObjectLink
=
React
.
createClass
(
{
displayName
:
"
ObjectLink
"
render
:
function
(
)
{
let
className
=
this
.
props
.
className
;
let
objectClassName
=
className
?
"
objectLink
-
"
+
className
:
"
"
;
let
linkClassName
=
"
objectLink
"
+
objectClassName
+
"
a11yFocus
"
;
return
(
DOM
.
a
(
{
className
:
linkClassName
_repObject
:
this
.
props
.
object
}
this
.
props
.
children
)
)
;
}
}
)
;
exports
.
ObjectLink
=
ObjectLink
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
const
{
span
}
=
React
.
DOM
;
let
DateTime
=
React
.
createClass
(
{
displayName
:
"
Date
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getTitle
:
function
(
grip
)
{
return
new
Date
(
grip
.
preview
.
timestamp
)
.
toISOString
(
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
Date
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
type
=
=
"
Date
"
&
&
grip
.
preview
)
;
}
exports
.
DateTime
=
{
rep
:
DateTime
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
{
getFileName
}
=
__webpack_require__
(
467
)
;
const
{
span
}
=
React
.
DOM
;
let
Document
=
React
.
createClass
(
{
displayName
:
"
Document
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getLocation
:
function
(
grip
)
{
let
location
=
grip
.
preview
.
location
;
return
location
?
getFileName
(
location
)
:
"
"
;
}
getTitle
:
function
(
win
context
)
{
return
"
document
"
;
}
getTooltip
:
function
(
doc
)
{
return
doc
.
location
.
href
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
object
.
preview
&
&
type
=
=
"
HTMLDocument
"
)
;
}
exports
.
Document
=
{
rep
:
Document
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
function
parseURLParams
(
url
)
{
url
=
new
URL
(
url
)
;
return
parseURLEncodedText
(
url
.
searchParams
)
;
}
function
parseURLEncodedText
(
text
)
{
let
params
=
[
]
;
if
(
text
=
=
"
"
)
{
return
params
;
}
let
searchParams
=
new
URLSearchParams
(
text
)
;
let
entries
=
[
.
.
.
searchParams
.
entries
(
)
]
;
return
entries
.
map
(
entry
=
>
{
return
{
name
:
entry
[
0
]
value
:
entry
[
1
]
}
;
}
)
;
}
function
getFileName
(
url
)
{
let
split
=
splitURLBase
(
url
)
;
return
split
.
name
;
}
function
splitURLBase
(
url
)
{
if
(
!
isDataURL
(
url
)
)
{
return
splitURLTrue
(
url
)
;
}
return
{
}
;
}
function
isDataURL
(
url
)
{
return
(
url
&
&
url
.
substr
(
0
5
)
=
=
"
data
:
"
)
;
}
function
splitURLTrue
(
url
)
{
const
reSplitFile
=
/
(
.
*
?
)
:
\
/
{
2
3
}
(
[
^
\
/
]
*
)
(
.
*
?
)
(
[
^
\
/
]
*
?
)
(
|
\
?
.
*
)
/
;
let
m
=
reSplitFile
.
exec
(
url
)
;
if
(
!
m
)
{
return
{
name
:
url
path
:
url
}
;
}
else
if
(
m
[
4
]
=
=
"
"
&
&
m
[
5
]
=
=
"
"
)
{
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
3
]
name
:
m
[
3
]
!
=
"
/
"
?
m
[
3
]
:
m
[
2
]
}
;
}
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
2
]
+
m
[
3
]
name
:
m
[
4
]
+
m
[
5
]
}
;
}
exports
.
parseURLParams
=
parseURLParams
;
exports
.
parseURLEncodedText
=
parseURLEncodedText
;
exports
.
getFileName
=
getFileName
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
let
Event
=
React
.
createClass
(
{
displayName
:
"
event
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
summarizeEvent
:
function
(
grip
)
{
let
info
=
[
grip
.
preview
.
type
"
"
]
;
let
eventFamily
=
grip
.
class
;
let
props
=
grip
.
preview
.
properties
;
if
(
eventFamily
=
=
"
MouseEvent
"
)
{
info
.
push
(
"
clientX
=
"
props
.
clientX
"
clientY
=
"
props
.
clientY
)
;
}
else
if
(
eventFamily
=
=
"
KeyboardEvent
"
)
{
info
.
push
(
"
charCode
=
"
props
.
charCode
"
keyCode
=
"
props
.
keyCode
)
;
}
else
if
(
eventFamily
=
=
"
MessageEvent
"
)
{
info
.
push
(
"
origin
=
"
props
.
origin
"
data
=
"
props
.
data
)
;
}
return
info
.
join
(
"
"
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
event
"
}
this
.
summarizeEvent
(
grip
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
DOMEvent
"
)
;
}
exports
.
Event
=
{
rep
:
Event
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
cropString
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
let
Func
=
React
.
createClass
(
{
displayName
:
"
Func
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
summarizeFunction
:
function
(
grip
)
{
let
name
=
grip
.
displayName
|
|
grip
.
name
|
|
"
function
"
;
return
cropString
(
name
+
"
(
)
"
100
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
function
"
}
this
.
summarizeFunction
(
grip
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
(
type
=
=
"
function
"
)
;
}
return
(
type
=
=
"
Function
"
)
;
}
exports
.
Func
=
{
rep
:
Func
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
460
)
)
;
const
{
span
}
=
React
.
DOM
;
let
NamedNodeMap
=
React
.
createClass
(
{
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
provider
:
React
.
PropTypes
.
object
}
className
:
"
NamedNodeMap
"
getLength
:
function
(
object
)
{
return
object
.
preview
.
length
;
}
getTitle
:
function
(
object
)
{
return
object
.
class
?
object
.
class
:
"
"
;
}
getItems
:
function
(
array
max
)
{
let
items
=
this
.
propIterator
(
array
max
)
;
items
=
items
.
map
(
item
=
>
PropRep
(
item
)
)
;
if
(
items
.
length
>
max
+
1
)
{
items
.
pop
(
)
;
items
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
return
items
;
}
propIterator
:
function
(
grip
max
)
{
max
=
max
|
|
3
;
let
props
=
[
]
;
let
provider
=
this
.
props
.
provider
;
if
(
!
provider
)
{
return
props
;
}
let
ownProperties
=
grip
.
preview
?
grip
.
preview
.
ownProperties
:
[
]
;
for
(
let
name
in
ownProperties
)
{
if
(
props
.
length
>
max
)
{
break
;
}
let
item
=
ownProperties
[
name
]
;
let
label
=
provider
.
getLabel
(
item
)
;
let
value
=
provider
.
getValue
(
item
)
;
props
.
push
(
Object
.
assign
(
{
}
this
.
props
{
name
:
label
object
:
value
equal
:
"
:
"
delim
:
"
"
}
)
)
;
}
return
props
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
mode
=
this
.
props
.
mode
;
let
items
;
if
(
mode
=
=
"
tiny
"
)
{
items
=
this
.
getLength
(
grip
)
;
}
else
{
let
max
=
(
mode
=
=
"
short
"
)
?
3
:
100
;
items
=
this
.
getItems
(
grip
max
)
;
}
return
(
ObjectLink
(
{
className
:
"
NamedNodeMap
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
grip
)
)
span
(
{
className
:
"
arrayLeftBracket
"
role
:
"
presentation
"
}
"
[
"
)
items
span
(
{
className
:
"
arrayRightBracket
"
role
:
"
presentation
"
}
"
]
"
)
)
)
;
}
}
)
;
let
PropRep
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
PropRep
"
propTypes
:
{
equal
:
React
.
PropTypes
.
string
delim
:
React
.
PropTypes
.
string
}
render
:
function
(
)
{
const
{
Rep
}
=
createFactories
(
__webpack_require__
(
452
)
)
;
return
(
span
(
{
}
span
(
{
className
:
"
nodeName
"
}
"
prop
.
name
"
)
span
(
{
className
:
"
objectEqual
"
role
:
"
presentation
"
}
this
.
props
.
equal
)
Rep
(
this
.
props
)
span
(
{
className
:
"
objectComma
"
role
:
"
presentation
"
}
this
.
props
.
delim
)
)
)
;
}
}
)
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
type
=
=
"
NamedNodeMap
"
&
&
grip
.
preview
)
;
}
exports
.
NamedNodeMap
=
{
rep
:
NamedNodeMap
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
const
{
span
}
=
React
.
DOM
;
let
RegExp
=
React
.
createClass
(
{
displayName
:
"
regexp
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getTitle
:
function
(
grip
)
{
return
grip
.
class
;
}
getSource
:
function
(
grip
)
{
return
grip
.
displayString
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
regexp
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
grip
)
)
span
(
"
"
)
span
(
{
className
:
"
regexpSource
"
}
this
.
getSource
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
type
=
=
"
RegExp
"
)
;
}
exports
.
RegExp
=
{
rep
:
RegExp
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
{
getFileName
}
=
__webpack_require__
(
467
)
;
const
DOM
=
React
.
DOM
;
let
StyleSheet
=
React
.
createClass
(
{
displayName
:
"
object
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getLocation
:
function
(
grip
)
{
let
url
=
grip
.
preview
?
grip
.
preview
.
url
:
"
"
;
return
url
?
getFileName
(
url
)
:
"
"
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
object
"
}
"
StyleSheet
"
DOM
.
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
type
=
=
"
CSSStyleSheet
"
)
;
}
exports
.
StyleSheet
=
{
rep
:
StyleSheet
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
cropMultipleLines
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
const
DOM
=
React
.
DOM
;
let
TextNode
=
React
.
createClass
(
{
displayName
:
"
TextNode
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
}
getTextContent
:
function
(
grip
)
{
return
cropMultipleLines
(
grip
.
preview
.
textContent
)
;
}
getTitle
:
function
(
win
context
)
{
return
"
textNode
"
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
mode
=
this
.
props
.
mode
|
|
"
short
"
;
if
(
mode
=
=
"
short
"
|
|
mode
=
=
"
tiny
"
)
{
return
(
ObjectLink
(
{
className
:
"
textNode
"
}
"
\
"
"
+
this
.
getTextContent
(
grip
)
+
"
\
"
"
)
)
;
}
return
(
ObjectLink
(
{
className
:
"
textNode
"
}
"
<
"
DOM
.
span
(
{
className
:
"
nodeTag
"
}
"
TextNode
"
)
"
textContent
=
\
"
"
DOM
.
span
(
{
className
:
"
nodeValue
"
}
this
.
getTextContent
(
grip
)
)
"
\
"
"
"
>
;
"
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
class
=
=
"
Text
"
)
;
}
exports
.
TextNode
=
{
rep
:
TextNode
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
cropString
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
DOM
=
React
.
DOM
;
let
Window
=
React
.
createClass
(
{
displayName
:
"
Window
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getLocation
:
function
(
grip
)
{
return
cropString
(
grip
.
preview
.
url
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
Window
"
}
DOM
.
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
object
.
preview
&
&
type
=
=
"
Window
"
)
;
}
exports
.
Window
=
{
rep
:
Window
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
const
{
span
}
=
React
.
DOM
;
let
ObjectWithText
=
React
.
createClass
(
{
displayName
:
"
ObjectWithText
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getType
:
function
(
grip
)
{
return
grip
.
class
;
}
getDescription
:
function
(
grip
)
{
return
(
grip
.
preview
.
kind
=
=
"
ObjectWithText
"
)
?
grip
.
preview
.
text
:
"
"
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
this
.
getType
(
grip
)
}
span
(
{
className
:
"
objectPropValue
"
}
this
.
getDescription
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithText
"
)
;
}
exports
.
ObjectWithText
=
{
rep
:
ObjectWithText
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
464
)
)
;
const
{
span
}
=
React
.
DOM
;
let
ObjectWithURL
=
React
.
createClass
(
{
displayName
:
"
ObjectWithURL
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getType
:
function
(
grip
)
{
return
grip
.
class
;
}
getDescription
:
function
(
grip
)
{
return
grip
.
preview
.
url
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
this
.
getType
(
grip
)
}
span
(
{
className
:
"
objectPropValue
"
}
this
.
getDescription
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithURL
"
)
;
}
exports
.
ObjectWithURL
=
{
rep
:
ObjectWithURL
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
460
)
)
;
const
{
a
span
}
=
React
.
DOM
;
let
GripArray
=
React
.
createClass
(
{
displayName
:
"
GripArray
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
provider
:
React
.
PropTypes
.
object
}
getLength
:
function
(
grip
)
{
return
grip
.
preview
?
grip
.
preview
.
length
:
0
;
}
getTitle
:
function
(
object
context
)
{
return
"
[
"
+
object
.
length
+
"
]
"
;
}
arrayIterator
:
function
(
grip
max
)
{
let
items
=
[
]
;
if
(
!
grip
.
preview
|
|
!
grip
.
preview
.
length
)
{
return
items
;
}
let
array
=
grip
.
preview
.
items
;
if
(
!
array
)
{
return
items
;
}
let
delim
;
let
provider
=
this
.
props
.
provider
;
for
(
let
i
=
0
;
i
<
array
.
length
&
&
i
<
=
max
;
i
+
+
)
{
try
{
let
itemGrip
=
array
[
i
]
;
let
value
=
provider
?
provider
.
getValue
(
itemGrip
)
:
itemGrip
;
delim
=
(
i
=
=
array
.
length
-
1
?
"
"
:
"
"
)
;
if
(
value
=
=
=
array
)
{
items
.
push
(
Reference
(
{
key
:
i
object
:
value
delim
:
delim
}
)
)
;
}
else
{
items
.
push
(
GripArrayItem
(
Object
.
assign
(
{
}
this
.
props
{
key
:
i
object
:
value
delim
:
delim
}
)
)
)
;
}
}
catch
(
exc
)
{
items
.
push
(
GripArrayItem
(
Object
.
assign
(
{
}
this
.
props
{
object
:
exc
delim
:
delim
key
:
i
}
)
)
)
;
}
}
if
(
array
.
length
>
max
+
1
)
{
items
.
pop
(
)
;
items
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
return
items
;
}
render
:
function
(
)
{
let
mode
=
this
.
props
.
mode
|
|
"
short
"
;
let
object
=
this
.
props
.
object
;
let
items
;
if
(
mode
=
=
"
tiny
"
)
{
items
=
span
(
{
className
:
"
length
"
}
this
.
getLength
(
object
)
)
;
}
else
{
let
max
=
(
mode
=
=
"
short
"
)
?
3
:
300
;
items
=
this
.
arrayIterator
(
object
max
)
;
}
return
(
ObjectBox
(
{
className
:
"
array
"
}
a
(
{
className
:
"
objectLink
"
}
span
(
{
className
:
"
arrayLeftBracket
"
role
:
"
presentation
"
}
"
[
"
)
)
items
a
(
{
className
:
"
objectLink
"
}
span
(
{
className
:
"
arrayRightBracket
"
role
:
"
presentation
"
}
"
]
"
)
)
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
)
;
}
}
)
;
let
GripArrayItem
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
GripArrayItem
"
propTypes
:
{
delim
:
React
.
PropTypes
.
string
}
render
:
function
(
)
{
let
{
Rep
}
=
createFactories
(
__webpack_require__
(
452
)
)
;
return
(
span
(
{
}
Rep
(
Object
.
assign
(
{
}
this
.
props
{
mode
:
"
tiny
"
}
)
)
this
.
props
.
delim
)
)
;
}
}
)
)
;
let
Reference
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
Reference
"
render
:
function
(
)
{
return
(
span
(
{
title
:
"
Circular
reference
"
}
"
[
.
.
.
]
"
)
)
;
}
}
)
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ArrayLike
"
)
;
}
exports
.
GripArray
=
{
rep
:
GripArray
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
453
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
455
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
460
)
)
;
const
{
PropRep
}
=
createFactories
(
__webpack_require__
(
462
)
)
;
const
{
span
}
=
React
.
DOM
;
const
Grip
=
React
.
createClass
(
{
displayName
:
"
Grip
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
}
getTitle
:
function
(
)
{
return
this
.
props
.
object
.
class
|
|
"
Object
"
;
}
longPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
100
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
shortPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
3
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
propIterator
:
function
(
object
max
)
{
let
isInterestingProp
=
(
type
value
)
=
>
{
return
(
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
|
|
type
=
=
"
object
"
)
;
}
;
let
props
=
this
.
getProps
(
object
max
isInterestingProp
)
;
if
(
props
.
length
<
=
max
)
{
props
=
props
.
concat
(
this
.
getProps
(
object
max
(
t
value
)
=
>
{
return
!
isInterestingProp
(
t
value
)
;
}
)
)
;
}
if
(
props
.
length
>
max
)
{
props
.
pop
(
)
;
props
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
else
if
(
props
.
length
>
0
)
{
let
last
=
props
.
length
-
1
;
props
[
last
]
=
React
.
cloneElement
(
props
[
last
]
{
delim
:
"
"
}
)
;
}
return
props
;
}
getProps
:
function
(
object
max
filter
)
{
let
props
=
[
]
;
max
=
max
|
|
3
;
if
(
!
object
)
{
return
props
;
}
try
{
let
ownProperties
=
object
.
preview
?
object
.
preview
.
ownProperties
:
[
]
;
for
(
let
name
in
ownProperties
)
{
if
(
props
.
length
>
max
)
{
return
props
;
}
let
prop
=
ownProperties
[
name
]
;
let
value
=
prop
.
value
|
|
{
}
;
let
type
=
(
value
.
class
|
|
typeof
value
)
;
type
=
type
.
toLowerCase
(
)
;
if
(
filter
(
type
value
)
)
{
props
.
push
(
PropRep
(
Object
.
assign
(
{
}
this
.
props
{
key
:
name
mode
:
"
tiny
"
name
:
name
object
:
value
equal
:
"
:
"
delim
:
"
"
}
)
)
)
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
props
;
}
render
:
function
(
)
{
let
object
=
this
.
props
.
object
;
let
props
=
(
this
.
props
.
mode
=
=
"
long
"
)
?
this
.
longPropIterator
(
object
)
:
this
.
shortPropIterator
(
object
)
;
if
(
this
.
props
.
mode
=
=
"
tiny
"
|
|
!
props
.
length
)
{
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
object
)
)
)
)
;
}
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
object
)
)
span
(
{
className
:
"
objectLeftBrace
"
role
:
"
presentation
"
}
"
{
"
)
props
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
object
.
preview
&
&
object
.
preview
.
ownProperties
)
;
}
exports
.
Grip
=
{
rep
:
Grip
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
480
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
reps
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
reps
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
/
*
vim
:
set
ts
=
2
sw
=
2
sts
=
2
et
:
*
/
\
n
/
*
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
\
n
*
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
\
n
*
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
*
/
\
n
\
n
.
theme
-
dark
\
n
.
theme
-
light
{
\
n
-
-
number
-
color
:
var
(
-
-
theme
-
highlight
-
green
)
;
\
n
-
-
string
-
color
:
var
(
-
-
theme
-
highlight
-
orange
)
;
\
n
-
-
null
-
color
:
var
(
-
-
theme
-
comment
)
;
\
n
-
-
object
-
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
-
-
caption
-
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
-
-
location
-
color
:
var
(
-
-
theme
-
content
-
color1
)
;
\
n
-
-
source
-
link
-
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
-
-
node
-
color
:
var
(
-
-
theme
-
highlight
-
bluegrey
)
;
\
n
-
-
reference
-
color
:
var
(
-
-
theme
-
highlight
-
purple
)
;
\
n
}
\
n
\
n
.
theme
-
firebug
{
\
n
-
-
number
-
color
:
#
000088
;
\
n
-
-
string
-
color
:
#
FF0000
;
\
n
-
-
null
-
color
:
#
787878
;
\
n
-
-
object
-
color
:
DarkGreen
;
\
n
-
-
caption
-
color
:
#
444444
;
\
n
-
-
location
-
color
:
#
555555
;
\
n
-
-
source
-
link
-
color
:
blue
;
\
n
-
-
node
-
color
:
rgb
(
0
0
136
)
;
\
n
-
-
reference
-
color
:
rgb
(
102
102
255
)
;
\
n
}
\
n
\
n
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
\
n
.
objectLink
:
hover
{
\
n
cursor
:
pointer
;
\
n
text
-
decoration
:
underline
;
\
n
}
\
n
\
n
.
inline
{
\
n
display
:
inline
;
\
n
white
-
space
:
normal
;
\
n
}
\
n
\
n
.
objectBox
-
object
{
\
n
font
-
weight
:
bold
;
\
n
color
:
var
(
-
-
object
-
color
)
;
\
n
white
-
space
:
pre
-
wrap
;
\
n
}
\
n
\
n
.
objectBox
-
string
\
n
.
objectBox
-
text
\
n
.
objectLink
-
textNode
\
n
.
objectBox
-
table
{
\
n
white
-
space
:
pre
-
wrap
;
\
n
}
\
n
\
n
.
objectBox
-
number
\
n
.
objectLink
-
styleRule
\
n
.
objectLink
-
element
\
n
.
objectLink
-
textNode
\
n
.
objectBox
-
array
>
.
length
{
\
n
color
:
var
(
-
-
number
-
color
)
;
\
n
}
\
n
\
n
.
objectBox
-
string
{
\
n
color
:
var
(
-
-
string
-
color
)
;
\
n
}
\
n
\
n
.
objectLink
-
function
\
n
.
objectBox
-
stackTrace
\
n
.
objectLink
-
profile
{
\
n
color
:
var
(
-
-
object
-
color
)
;
\
n
}
\
n
\
n
.
objectLink
-
Location
{
\
n
font
-
style
:
italic
;
\
n
color
:
var
(
-
-
location
-
color
)
;
\
n
}
\
n
\
n
.
objectBox
-
null
\
n
.
objectBox
-
undefined
\
n
.
objectBox
-
hint
\
n
.
logRowHint
{
\
n
font
-
style
:
italic
;
\
n
color
:
var
(
-
-
null
-
color
)
;
\
n
}
\
n
\
n
.
objectLink
-
sourceLink
{
\
n
position
:
absolute
;
\
n
right
:
4px
;
\
n
top
:
2px
;
\
n
padding
-
left
:
8px
;
\
n
font
-
weight
:
bold
;
\
n
color
:
var
(
-
-
source
-
link
-
color
)
;
\
n
}
\
n
\
n
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
\
n
.
objectLink
-
event
\
n
.
objectLink
-
eventLog
\
n
.
objectLink
-
regexp
\
n
.
objectLink
-
object
\
n
.
objectLink
-
Date
{
\
n
font
-
weight
:
bold
;
\
n
color
:
var
(
-
-
object
-
color
)
;
\
n
white
-
space
:
pre
-
wrap
;
\
n
}
\
n
\
n
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
\
n
.
objectLink
-
object
.
nodeName
\
n
.
objectLink
-
NamedNodeMap
.
nodeName
\
n
.
objectLink
-
NamedNodeMap
.
objectEqual
\
n
.
objectLink
-
NamedNodeMap
.
arrayLeftBracket
\
n
.
objectLink
-
NamedNodeMap
.
arrayRightBracket
\
n
.
objectLink
-
Attr
.
attrEqual
\
n
.
objectLink
-
Attr
.
attrTitle
{
\
n
color
:
var
(
-
-
node
-
color
)
;
\
n
}
\
n
\
n
.
objectLink
-
object
.
nodeName
{
\
n
font
-
weight
:
normal
;
\
n
}
\
n
\
n
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
\
n
.
objectLeftBrace
\
n
.
objectRightBrace
\
n
.
arrayLeftBracket
\
n
.
arrayRightBracket
{
\
n
cursor
:
pointer
;
\
n
font
-
weight
:
bold
;
\
n
}
\
n
\
n
.
objectLeftBrace
\
n
.
arrayLeftBracket
{
\
n
margin
-
right
:
4px
;
\
n
}
\
n
\
n
.
objectRightBrace
\
n
.
arrayRightBracket
{
\
n
margin
-
left
:
4px
;
\
n
}
\
n
\
n
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
/
*
Cycle
reference
*
/
\
n
\
n
.
objectLink
-
Reference
{
\
n
font
-
weight
:
bold
;
\
n
color
:
var
(
-
-
reference
-
color
)
;
\
n
}
\
n
\
n
.
objectBox
-
array
>
.
objectTitle
{
\
n
font
-
weight
:
bold
;
\
n
color
:
var
(
-
-
object
-
color
)
;
\
n
}
\
n
\
n
.
caption
{
\
n
font
-
weight
:
bold
;
\
n
color
:
var
(
-
-
caption
-
color
)
;
\
n
}
\
n
\
n
/
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
/
\
n
/
*
Themes
*
/
\
n
\
n
.
theme
-
dark
.
objectBox
-
null
\
n
.
theme
-
dark
.
objectBox
-
undefined
\
n
.
theme
-
light
.
objectBox
-
null
\
n
.
theme
-
light
.
objectBox
-
undefined
{
\
n
font
-
style
:
normal
;
\
n
}
\
n
\
n
.
theme
-
dark
.
objectBox
-
object
\
n
.
theme
-
light
.
objectBox
-
object
{
\
n
font
-
weight
:
normal
;
\
n
white
-
space
:
pre
-
wrap
;
\
n
}
\
n
\
n
.
theme
-
dark
.
caption
\
n
.
theme
-
light
.
caption
{
\
n
font
-
weight
:
normal
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
482
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Expressions
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Expressions
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
input
-
expression
{
\
n
width
:
100
%
;
\
n
padding
:
5px
;
\
n
margin
:
0px
;
\
n
border
:
none
;
\
n
cursor
:
hand
;
\
n
}
\
n
\
n
.
expression
-
container
{
\
n
border
:
1px
;
\
n
padding
:
2px
;
\
n
margin
:
1px
;
\
n
width
:
100
%
;
\
n
}
\
n
\
n
.
expression
-
output
-
container
.
close
-
btn
{
\
n
width
:
6px
;
\
n
height
:
6px
;
\
n
float
:
right
;
\
n
margin
-
right
:
6px
;
\
n
display
:
block
;
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
expression
-
input
{
\
n
color
:
var
(
-
-
theme
-
content
-
color1
)
;
\
n
cursor
:
pointer
;
\
n
max
-
width
:
50
%
;
\
n
}
\
n
\
n
.
expression
-
value
{
\
n
overflow
-
x
:
scroll
;
\
n
color
:
var
(
-
-
theme
-
content
-
color2
)
;
\
n
max
-
width
:
50
%
!
important
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
ImPropTypes
=
__webpack_require__
(
376
)
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require3
=
__webpack_require__
(
348
)
;
var
getPause
=
_require3
.
getPause
;
var
getLoadedObjects
=
_require3
.
getLoadedObjects
;
var
ObjectInspector
=
React
.
createFactory
(
__webpack_require__
(
484
)
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
__webpack_require__
(
488
)
;
function
info
(
text
)
{
return
dom
.
div
(
{
className
:
"
pane
-
info
"
}
text
)
;
}
function
getBindingVariables
(
bindings
parentName
)
{
return
bindings
.
get
(
"
arguments
"
)
.
map
(
arg
=
>
arg
.
entrySeq
(
)
.
get
(
0
)
)
.
concat
(
bindings
.
get
(
"
variables
"
)
.
entrySeq
(
)
)
.
filter
(
binding
=
>
!
binding
[
1
]
.
hasIn
(
[
"
value
"
"
missingArguments
"
]
)
&
&
!
binding
[
1
]
.
hasIn
(
[
"
value
"
"
optimizedOut
"
]
)
)
.
map
(
binding
=
>
(
{
name
:
binding
[
0
]
path
:
parentName
+
"
/
"
+
binding
[
0
]
contents
:
binding
[
1
]
.
toJS
(
)
}
)
)
.
toArray
(
)
;
}
function
getSpecialVariables
(
pauseInfo
parentName
)
{
var
thrown
=
pauseInfo
.
getIn
(
[
"
why
"
"
frameFinished
"
"
throw
"
]
)
;
var
returned
=
pauseInfo
.
getIn
(
[
"
why
"
"
frameFinished
"
"
return
"
]
)
;
var
this_
=
pauseInfo
.
getIn
(
[
"
frame
"
"
this
"
]
)
;
var
vars
=
[
]
;
if
(
thrown
)
{
vars
.
push
(
{
name
:
"
<
exception
>
"
path
:
parentName
+
"
/
<
exception
>
"
contents
:
{
value
:
thrown
.
toJS
(
)
}
}
)
;
}
if
(
returned
)
{
vars
.
push
(
{
name
:
"
<
return
>
"
path
:
parentName
+
"
/
<
return
>
"
contents
:
{
value
:
returned
.
toJS
(
)
}
}
)
;
}
if
(
this_
)
{
vars
.
push
(
{
name
:
"
<
this
>
"
path
:
parentName
+
"
/
<
this
>
"
contents
:
{
value
:
this_
.
toJS
(
)
}
}
)
;
}
return
vars
;
}
function
getScopes
(
pauseInfo
)
{
if
(
!
pauseInfo
)
{
return
null
;
}
var
scope
=
pauseInfo
.
getIn
(
[
"
frame
"
"
scope
"
]
)
;
if
(
!
scope
)
{
return
null
;
}
var
scopes
=
[
]
;
do
{
var
type
=
scope
.
get
(
"
type
"
)
;
if
(
type
=
=
=
"
function
"
|
|
type
=
=
=
"
block
"
)
{
var
bindings
=
scope
.
get
(
"
bindings
"
)
;
var
title
=
void
0
;
if
(
type
=
=
=
"
function
"
)
{
title
=
scope
.
getIn
(
[
"
function
"
"
displayName
"
]
)
|
|
"
(
anonymous
)
"
;
}
else
{
title
=
"
Block
"
;
}
var
vars
=
getBindingVariables
(
bindings
title
)
;
if
(
scope
=
=
=
pauseInfo
.
getIn
(
[
"
frame
"
"
scope
"
]
)
)
{
vars
=
vars
.
concat
(
getSpecialVariables
(
pauseInfo
title
)
)
;
}
if
(
vars
.
length
)
{
vars
.
sort
(
(
a
b
)
=
>
a
.
name
.
localeCompare
(
b
.
name
)
)
;
scopes
.
push
(
{
name
:
title
path
:
title
contents
:
vars
}
)
;
}
}
else
if
(
type
=
=
=
"
object
"
)
{
scopes
.
push
(
{
name
:
scope
.
getIn
(
[
"
object
"
"
class
"
]
)
path
:
scope
.
getIn
(
[
"
object
"
"
class
"
]
)
contents
:
{
value
:
scope
.
get
(
"
object
"
)
.
toJS
(
)
}
}
)
;
}
}
while
(
scope
=
scope
.
get
(
"
parent
"
)
)
;
return
scopes
;
}
var
Scopes
=
React
.
createClass
(
{
propTypes
:
{
pauseInfo
:
ImPropTypes
.
map
loadedObjects
:
ImPropTypes
.
map
loadObjectProperties
:
PropTypes
.
func
}
displayName
:
"
Scopes
"
getInitialState
(
)
{
return
{
scopes
:
getScopes
(
this
.
props
.
pauseInfo
)
}
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
this
.
props
.
pauseInfo
!
=
=
nextProps
.
pauseInfo
)
{
this
.
setState
(
{
scopes
:
getScopes
(
nextProps
.
pauseInfo
)
}
)
;
}
}
render
(
)
{
var
_props
=
this
.
props
;
var
pauseInfo
=
_props
.
pauseInfo
;
var
loadObjectProperties
=
_props
.
loadObjectProperties
;
var
loadedObjects
=
_props
.
loadedObjects
;
var
scopes
=
this
.
state
.
scopes
;
var
scopeInspector
=
info
(
"
Scopes
Unavailable
"
)
;
if
(
scopes
)
{
scopeInspector
=
ObjectInspector
(
{
roots
:
scopes
getObjectProperties
:
id
=
>
loadedObjects
.
get
(
id
)
loadObjectProperties
:
loadObjectProperties
}
)
;
}
return
dom
.
div
(
{
className
:
"
pane
scopes
-
list
"
}
pauseInfo
?
scopeInspector
:
info
(
"
Not
Paused
"
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
pauseInfo
:
getPause
(
state
)
loadedObjects
:
getLoadedObjects
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Scopes
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
classnames
=
__webpack_require__
(
379
)
;
var
ManagedTree
=
React
.
createFactory
(
__webpack_require__
(
383
)
)
;
var
Arrow
=
React
.
createFactory
(
__webpack_require__
(
485
)
)
;
var
Rep
=
__webpack_require__
(
451
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
function
nodeHasChildren
(
item
)
{
return
Array
.
isArray
(
item
.
contents
)
;
}
function
nodeHasProperties
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
item
.
contents
.
value
.
type
=
=
=
"
object
"
;
}
function
nodeIsPrimitive
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
!
nodeHasProperties
(
item
)
;
}
function
createNode
(
name
path
contents
)
{
return
{
name
path
contents
}
;
}
var
ObjectInspector
=
React
.
createClass
(
{
propTypes
:
{
name
:
PropTypes
.
string
desc
:
PropTypes
.
object
roots
:
PropTypes
.
array
getObjectProperties
:
PropTypes
.
func
.
isRequired
loadObjectProperties
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
ObjectInspector
"
getInitialState
(
)
{
this
.
actorCache
=
{
}
;
return
{
}
;
}
makeNodesForProperties
(
objProps
parentPath
)
{
var
ownProperties
=
objProps
.
ownProperties
;
var
prototype
=
objProps
.
prototype
;
var
nodes
=
Object
.
keys
(
ownProperties
)
.
filter
(
name
=
>
{
return
"
value
"
in
ownProperties
[
name
]
;
}
)
.
map
(
name
=
>
{
return
createNode
(
name
parentPath
+
"
/
"
+
name
ownProperties
[
name
]
)
;
}
)
;
if
(
prototype
&
&
prototype
.
type
!
=
=
"
null
"
)
{
nodes
.
push
(
createNode
(
"
__proto__
"
parentPath
+
"
/
__proto__
"
{
value
:
prototype
}
)
)
;
}
return
nodes
;
}
getChildren
(
item
)
{
var
getObjectProperties
=
this
.
props
.
getObjectProperties
;
var
obj
=
item
.
contents
;
if
(
nodeHasChildren
(
item
)
)
{
return
item
.
contents
;
}
else
if
(
nodeHasProperties
(
item
)
)
{
var
actor
=
obj
.
value
.
actor
;
if
(
this
.
actorCache
[
actor
]
)
{
return
this
.
actorCache
[
actor
]
;
}
var
loadedProps
=
getObjectProperties
(
actor
)
;
if
(
loadedProps
)
{
var
children
=
this
.
makeNodesForProperties
(
loadedProps
item
.
path
)
;
this
.
actorCache
[
actor
]
=
children
;
return
children
;
}
return
[
]
;
}
return
[
]
;
}
renderItem
(
item
depth
focused
_
expanded
_ref
)
{
var
setExpanded
=
_ref
.
setExpanded
;
var
objectValue
=
void
0
;
if
(
nodeHasProperties
(
item
)
|
|
nodeIsPrimitive
(
item
)
)
{
var
object
=
item
.
contents
.
value
;
objectValue
=
Rep
(
{
object
}
)
;
}
return
dom
.
div
(
{
className
:
classnames
(
"
node
"
{
focused
}
)
style
:
{
marginLeft
:
depth
*
15
}
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
setExpanded
(
item
!
expanded
)
;
}
}
Arrow
(
{
className
:
classnames
(
{
expanded
:
expanded
hidden
:
nodeIsPrimitive
(
item
)
}
)
}
)
dom
.
span
(
{
className
:
"
object
-
label
"
}
item
.
name
)
dom
.
span
(
{
className
:
"
object
-
delimiter
"
}
objectValue
?
"
:
"
:
"
"
)
dom
.
span
(
{
className
:
"
object
-
value
"
}
objectValue
|
|
"
"
)
)
;
}
render
(
)
{
var
_props
=
this
.
props
;
var
name
=
_props
.
name
;
var
desc
=
_props
.
desc
;
var
loadObjectProperties
=
_props
.
loadObjectProperties
;
var
roots
=
this
.
props
.
roots
;
if
(
!
roots
)
{
roots
=
[
createNode
(
name
name
desc
)
]
;
}
return
ManagedTree
(
{
itemHeight
:
20
getParent
:
item
=
>
null
getChildren
:
this
.
getChildren
getRoots
:
(
)
=
>
roots
getKey
:
item
=
>
item
.
path
autoExpand
:
0
disabledFocus
:
true
onExpand
:
item
=
>
{
if
(
nodeHasProperties
(
item
)
)
{
loadObjectProperties
(
item
.
contents
.
value
)
;
}
}
renderItem
:
this
.
renderItem
}
)
;
}
}
)
;
module
.
exports
=
ObjectInspector
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
InlineSVG
=
__webpack_require__
(
389
)
;
var
dom
=
React
.
DOM
;
__webpack_require__
(
486
)
;
var
Arrow
=
props
=
>
{
var
className
=
"
arrow
"
+
(
props
.
className
|
|
"
"
)
;
return
dom
.
span
(
Object
.
assign
(
{
}
props
{
className
}
)
React
.
createElement
(
InlineSVG
{
src
:
__webpack_require__
(
391
)
}
)
)
;
}
;
module
.
exports
=
Arrow
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
487
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Arrow
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Arrow
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
arrow
svg
{
\
n
fill
:
var
(
-
-
theme
-
splitter
-
color
)
;
\
n
margin
-
right
:
5px
;
\
n
margin
-
top
:
3px
;
\
n
transform
:
rotate
(
-
90deg
)
;
\
n
transition
:
transform
0
.
25s
ease
;
\
n
width
:
10px
;
\
n
}
\
n
\
n
.
arrow
.
expanded
svg
{
\
n
transform
:
rotate
(
0deg
)
;
\
n
}
\
n
\
n
.
arrow
.
hidden
{
\
n
visibility
:
hidden
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
489
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Scopes
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Scopes
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
\
n
.
object
-
label
{
\
n
color
:
var
(
-
-
theme
-
highlight
-
blue
)
;
\
n
}
\
n
\
n
.
objectBox
-
object
\
n
.
objectBox
-
string
\
n
.
objectBox
-
text
\
n
.
objectBox
-
table
\
n
.
objectLink
-
textNode
\
n
.
objectLink
-
event
\
n
.
objectLink
-
eventLog
\
n
.
objectLink
-
regexp
\
n
.
objectLink
-
object
\
n
.
objectLink
-
Date
\
n
.
theme
-
dark
.
objectBox
-
object
\
n
.
theme
-
light
.
objectBox
-
object
{
\
n
white
-
space
:
nowrap
;
\
n
}
\
n
\
n
.
scopes
-
list
.
tree
-
node
{
\
n
overflow
:
hidden
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
div
=
dom
.
div
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require3
=
__webpack_require__
(
324
)
;
var
endTruncateStr
=
_require3
.
endTruncateStr
;
var
_require4
=
__webpack_require__
(
354
)
;
var
basename
=
_require4
.
basename
;
var
_require5
=
__webpack_require__
(
348
)
;
var
getFrames
=
_require5
.
getFrames
;
var
getSelectedFrame
=
_require5
.
getSelectedFrame
;
var
getSource
=
_require5
.
getSource
;
if
(
typeof
window
=
=
"
object
"
)
{
__webpack_require__
(
491
)
;
}
function
renderFrameTitle
(
frame
)
{
return
div
(
{
className
:
"
title
"
}
endTruncateStr
(
frame
.
displayName
40
)
)
;
}
function
renderFrameLocation
(
frame
)
{
var
url
=
frame
.
source
.
url
?
basename
(
frame
.
source
.
url
)
:
"
"
;
var
line
=
url
!
=
=
"
"
?
:
{
frame
.
location
.
line
}
:
"
"
;
return
url
!
=
=
"
"
?
div
(
{
className
:
"
location
"
}
{
endTruncateStr
(
url
30
)
}
{
line
}
)
:
null
;
}
function
renderFrame
(
frame
selectedFrame
selectFrame
)
{
var
selectedClass
=
selectedFrame
&
&
(
selectedFrame
.
id
=
=
=
frame
.
id
?
"
selected
"
:
"
"
)
;
return
dom
.
li
(
{
key
:
frame
.
id
className
:
frame
{
selectedClass
}
onClick
:
(
)
=
>
selectFrame
(
frame
)
}
renderFrameTitle
(
frame
)
renderFrameLocation
(
frame
)
)
;
}
function
Frames
(
_ref
)
{
var
frames
=
_ref
.
frames
;
var
selectedFrame
=
_ref
.
selectedFrame
;
var
selectFrame
=
_ref
.
selectFrame
;
return
div
(
{
className
:
"
pane
frames
"
}
frames
.
length
=
=
=
0
?
div
(
{
className
:
"
pane
-
info
empty
"
}
"
Not
Paused
"
)
:
dom
.
ul
(
null
frames
.
map
(
frame
=
>
{
return
renderFrame
(
frame
selectedFrame
selectFrame
)
;
}
)
)
)
;
}
module
.
exports
=
connect
(
state
=
>
(
{
frames
:
getFrames
(
state
)
.
map
(
frame
=
>
{
return
Object
.
assign
(
{
}
frame
{
source
:
getSource
(
state
frame
.
location
.
sourceId
)
.
toJS
(
)
}
)
;
}
)
selectedFrame
:
getSelectedFrame
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Frames
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
492
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Frames
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Frames
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
\
n
.
frames
ul
{
\
n
list
-
style
:
none
;
\
n
margin
:
0
;
\
n
padding
:
0
;
\
n
}
\
n
\
n
.
frames
ul
li
{
\
n
cursor
:
pointer
;
\
n
padding
:
10px
;
\
n
clear
:
both
;
\
n
overflow
:
hidden
;
\
n
}
\
n
\
n
.
frames
ul
li
:
nth
-
of
-
type
(
2n
)
{
\
n
background
-
color
:
#
f9f9f9
;
\
n
}
\
n
\
n
.
frames
.
location
{
\
n
float
:
right
;
\
n
color
:
#
666666
;
\
n
font
-
weight
:
lighter
;
\
n
}
\
n
\
n
.
frames
.
title
{
\
n
float
:
left
;
\
n
text
-
overflow
:
ellipsis
;
\
n
overflow
:
hidden
;
\
n
margin
-
right
:
1em
;
\
n
}
\
n
\
n
.
frames
ul
li
.
selected
\
n
.
frames
ul
li
.
selected
.
location
{
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
color
:
white
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
div
=
dom
.
div
;
var
Svg
=
__webpack_require__
(
387
)
;
__webpack_require__
(
494
)
;
var
Accordion
=
React
.
createClass
(
{
propTypes
:
{
items
:
PropTypes
.
array
}
displayName
:
"
Accordion
"
getInitialState
:
function
(
)
{
return
{
opened
:
this
.
props
.
items
.
map
(
item
=
>
item
.
opened
)
created
:
[
]
}
;
}
handleHeaderClick
:
function
(
i
)
{
var
opened
=
[
]
.
concat
(
_toConsumableArray
(
this
.
state
.
opened
)
)
;
var
created
=
[
]
.
concat
(
_toConsumableArray
(
this
.
state
.
created
)
)
;
var
item
=
this
.
props
.
items
[
i
]
;
opened
[
i
]
=
!
opened
[
i
]
;
created
[
i
]
=
true
;
if
(
opened
[
i
]
&
&
item
.
onOpened
)
{
item
.
onOpened
(
)
;
}
this
.
setState
(
{
opened
created
}
)
;
}
renderContainer
:
function
(
item
i
)
{
var
_state
=
this
.
state
;
var
opened
=
_state
.
opened
;
var
created
=
_state
.
created
;
var
containerClassName
=
item
.
header
.
toLowerCase
(
)
.
replace
(
/
\
s
/
g
"
-
"
)
+
"
-
pane
"
;
return
div
(
{
className
:
containerClassName
key
:
i
}
div
(
{
className
:
"
_header
"
onClick
:
(
)
=
>
this
.
handleHeaderClick
(
i
)
}
Svg
(
"
arrow
"
{
className
:
opened
[
i
]
?
"
expanded
"
:
"
"
}
)
item
.
header
)
created
[
i
]
|
|
opened
[
i
]
?
div
(
{
className
:
"
_content
"
style
:
{
display
:
opened
[
i
]
?
"
block
"
:
"
none
"
}
}
React
.
createElement
(
item
.
component
item
.
componentProps
|
|
{
}
)
)
:
null
)
;
}
render
:
function
(
)
{
return
div
(
{
className
:
"
accordion
"
}
this
.
props
.
items
.
map
(
this
.
renderContainer
)
)
;
}
}
)
;
module
.
exports
=
Accordion
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
495
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Accordion
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Accordion
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
accordion
{
\
n
background
-
color
:
var
(
-
-
theme
-
body
-
background
)
;
\
n
width
:
100
%
;
\
n
}
\
n
\
n
.
accordion
.
_header
{
\
n
background
-
color
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
border
-
bottom
:
1px
solid
#
d0d0d0
;
\
n
cursor
:
pointer
;
\
n
font
-
size
:
12px
;
\
n
padding
:
5px
;
\
n
transition
:
all
0
.
25s
ease
;
\
n
width
:
100
%
;
\
n
\
n
-
webkit
-
user
-
select
:
none
;
\
n
-
moz
-
user
-
select
:
none
;
\
n
-
ms
-
user
-
select
:
none
;
\
n
-
o
-
user
-
select
:
none
;
\
n
user
-
select
:
none
;
\
n
}
\
n
\
n
.
accordion
.
_header
:
hover
{
\
n
background
-
color
:
var
(
-
-
theme
-
selection
-
color
)
;
\
n
}
\
n
\
n
.
accordion
.
_header
:
hover
svg
{
\
n
fill
:
var
(
-
-
theme
-
gray
-
darker
)
;
\
n
}
\
n
\
n
.
accordion
.
_content
{
\
n
border
-
bottom
:
1px
solid
#
d0d0d0
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
497
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
RightSidebar
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
RightSidebar
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
right
-
sidebar
{
\
n
flex
:
1
;
\
n
white
-
space
:
nowrap
;
\
n
}
\
n
\
n
.
command
-
bar
{
\
n
border
-
bottom
:
1px
solid
#
cccccc
;
\
n
height
:
30px
;
\
n
padding
:
8px
5px
10px
10px
;
\
n
overflow
:
hidden
;
\
n
}
\
n
\
n
.
command
-
bar
>
span
{
\
n
cursor
:
pointer
;
\
n
margin
-
right
:
0
.
7em
;
\
n
width
:
1em
;
\
n
height
:
1
.
1em
;
\
n
display
:
inline
-
block
;
\
n
text
-
align
:
center
;
\
n
transition
:
opacity
200ms
;
\
n
}
\
n
\
n
.
command
-
bar
>
span
.
disabled
{
\
n
opacity
:
0
.
3
;
\
n
cursor
:
default
;
\
n
}
\
n
\
n
.
command
-
bar
.
stepOut
{
\
n
margin
-
right
:
2em
;
\
n
}
\
n
\
n
.
command
-
bar
.
subSettings
{
\
n
float
:
right
;
\
n
}
\
n
\
n
.
pane
{
\
n
font
-
size
:
0
.
75em
;
\
n
color
:
var
(
-
-
theme
-
body
-
color
)
;
\
n
}
\
n
\
n
.
pane
.
pane
-
info
{
\
n
font
-
style
:
italic
;
\
n
text
-
align
:
center
;
\
n
padding
:
0
.
5em
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
ImPropTypes
=
__webpack_require__
(
376
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
Svg
=
__webpack_require__
(
387
)
;
var
_require3
=
__webpack_require__
(
348
)
;
var
getSelectedSource
=
_require3
.
getSelectedSource
;
var
getSourceTabs
=
_require3
.
getSourceTabs
;
var
_require4
=
__webpack_require__
(
324
)
;
var
endTruncateStr
=
_require4
.
endTruncateStr
;
var
classnames
=
__webpack_require__
(
379
)
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require5
=
__webpack_require__
(
196
)
;
var
isEnabled
=
_require5
.
isEnabled
;
__webpack_require__
(
499
)
;
__webpack_require__
(
501
)
;
function
getFilename
(
url
)
{
if
(
!
url
)
{
return
"
"
;
}
var
name
=
url
;
var
m
=
url
.
toString
(
)
.
match
(
/
.
*
\
/
(
.
+
?
\
.
.
*
)
/
)
;
if
(
m
&
&
m
.
length
>
1
)
{
name
=
m
[
1
]
;
}
return
endTruncateStr
(
name
50
)
;
}
function
getHiddenTabs
(
sourceTabs
sourceTabEls
)
{
sourceTabEls
=
[
]
.
slice
.
call
(
sourceTabEls
)
;
function
getTopOffset
(
)
{
var
topOffsets
=
sourceTabEls
.
map
(
t
=
>
t
.
getBoundingClientRect
(
)
.
top
)
;
return
Math
.
min
.
apply
(
Math
_toConsumableArray
(
topOffsets
)
)
;
}
var
tabTopOffset
=
getTopOffset
(
)
;
return
sourceTabs
.
filter
(
(
tab
index
)
=
>
{
return
sourceTabEls
[
index
]
.
getBoundingClientRect
(
)
.
top
>
tabTopOffset
;
}
)
;
}
function
getLastVisibleTabIndex
(
sourceTabs
sourceTabEls
)
{
var
hiddenTabs
=
getHiddenTabs
(
sourceTabs
sourceTabEls
)
;
var
firstHiddenTab
=
hiddenTabs
.
first
(
)
;
var
firstHiddenTabIndex
=
sourceTabs
.
indexOf
(
firstHiddenTab
)
;
return
firstHiddenTabIndex
-
1
;
}
var
SourceTabs
=
React
.
createClass
(
{
propTypes
:
{
sourceTabs
:
ImPropTypes
.
list
selectedSource
:
ImPropTypes
.
map
selectSource
:
PropTypes
.
func
.
isRequired
closeTab
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
SourceTabs
"
getInitialState
(
)
{
return
{
dropdownShown
:
false
hiddenSourceTabs
:
null
}
;
}
componentDidUpdate
(
)
{
this
.
updateHiddenSourceTabs
(
this
.
props
.
sourceTabs
)
;
}
updateHiddenSourceTabs
(
sourceTabs
)
{
if
(
!
this
.
refs
.
sourceTabs
)
{
return
;
}
var
sourceTabEls
=
this
.
refs
.
sourceTabs
.
children
;
var
hiddenSourceTabs
=
getHiddenTabs
(
sourceTabs
sourceTabEls
)
;
if
(
!
hiddenSourceTabs
.
equals
(
this
.
state
.
hiddenSourceTabs
)
)
{
this
.
setState
(
{
hiddenSourceTabs
}
)
;
}
}
toggleSourcesDropdown
(
e
)
{
this
.
setState
(
{
dropdownShown
:
!
this
.
state
.
dropdownShown
}
)
;
}
renderSourcesDropdown
(
)
{
if
(
!
this
.
state
.
hiddenSourceTabs
)
{
return
dom
.
div
(
{
}
)
;
}
return
dom
.
div
(
{
className
:
"
sources
-
dropdown
dropdown
"
ref
:
"
sourcesDropdown
"
style
:
{
display
:
this
.
state
.
dropdownShown
?
"
block
"
:
"
none
"
}
}
dom
.
ul
(
{
}
this
.
state
.
hiddenSourceTabs
.
map
(
this
.
renderDropdownSource
)
)
)
;
}
renderDropdownSource
(
source
)
{
var
_props
=
this
.
props
;
var
selectSource
=
_props
.
selectSource
;
var
sourceTabs
=
_props
.
sourceTabs
;
var
url
=
source
&
&
source
.
get
(
"
url
"
)
;
var
filename
=
getFilename
(
url
)
;
var
sourceTabEls
=
this
.
refs
.
sourceTabs
.
children
;
return
dom
.
li
(
{
key
:
source
.
get
(
"
id
"
)
onClick
:
(
)
=
>
{
var
tabIndex
=
getLastVisibleTabIndex
(
sourceTabs
sourceTabEls
)
;
selectSource
(
source
.
get
(
"
id
"
)
{
position
:
tabIndex
}
)
;
this
.
toggleSourcesDropdown
(
)
;
}
}
filename
)
;
}
renderSourcesDropdownButon
(
)
{
var
hiddenSourceTabs
=
this
.
state
.
hiddenSourceTabs
;
if
(
!
hiddenSourceTabs
|
|
hiddenSourceTabs
.
size
=
=
0
)
{
return
dom
.
div
(
{
}
)
;
}
return
dom
.
span
(
{
className
:
"
subsettings
"
onClick
:
this
.
toggleSourcesDropdown
}
dom
.
img
(
{
src
:
"
images
/
subSettings
.
svg
"
}
)
)
;
}
renderTabs
(
)
{
var
sourceTabs
=
this
.
props
.
sourceTabs
;
return
dom
.
div
(
{
className
:
"
source
-
tabs
"
ref
:
"
sourceTabs
"
}
sourceTabs
.
map
(
this
.
renderTab
)
)
;
}
renderTab
(
source
)
{
var
_props2
=
this
.
props
;
var
selectedSource
=
_props2
.
selectedSource
;
var
selectSource
=
_props2
.
selectSource
;
var
closeTab
=
_props2
.
closeTab
;
var
url
=
source
&
&
source
.
get
(
"
url
"
)
;
var
filename
=
getFilename
(
url
)
;
var
active
=
source
.
get
(
"
id
"
)
=
=
selectedSource
.
get
(
"
id
"
)
;
function
onClickClose
(
ev
)
{
ev
.
stopPropagation
(
)
;
closeTab
(
source
.
get
(
"
id
"
)
)
;
}
return
dom
.
div
(
{
className
:
classnames
(
"
source
-
tab
"
{
active
}
)
key
:
source
.
get
(
"
id
"
)
onClick
:
(
)
=
>
selectSource
(
source
.
get
(
"
id
"
)
)
title
:
url
}
dom
.
div
(
{
className
:
"
filename
"
}
filename
)
dom
.
div
(
{
onClick
:
onClickClose
}
dom
.
span
(
{
className
:
"
close
-
btn
"
}
Svg
(
"
close
"
)
)
)
)
;
}
render
(
)
{
if
(
!
isEnabled
(
"
features
.
tabs
"
)
)
{
return
dom
.
div
(
{
className
:
"
source
-
header
"
}
)
;
}
return
dom
.
div
(
{
className
:
"
source
-
header
"
}
this
.
renderSourcesDropdown
(
)
this
.
renderTabs
(
)
this
.
renderSourcesDropdownButon
(
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
selectedSource
:
getSelectedSource
(
state
)
sourceTabs
:
getSourceTabs
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
SourceTabs
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
500
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
SourceTabs
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
SourceTabs
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
source
-
header
{
\
n
border
-
bottom
:
1px
solid
var
(
-
-
theme
-
gray
)
;
\
n
height
:
30px
;
\
n
flex
:
1
;
\
n
}
\
n
\
n
.
source
-
tabs
{
\
n
width
:
calc
(
100
%
-
30px
)
;
\
n
overflow
:
hidden
;
\
n
}
\
n
\
n
.
source
-
tab
{
\
n
border
:
1px
solid
var
(
-
-
theme
-
gray
)
;
\
n
border
-
top
-
left
-
radius
:
2px
;
\
n
border
-
top
-
right
-
radius
:
2px
;
\
n
padding
:
2px
20px
2px
10px
;
\
n
height
:
23px
;
\
n
line
-
height
:
20px
;
\
n
color
:
var
(
-
-
theme
-
comment
)
;
\
n
font
-
size
:
0
.
7em
;
\
n
margin
:
6px
0
0
10px
;
\
n
display
:
inline
-
block
;
\
n
border
-
bottom
:
none
;
\
n
position
:
relative
;
\
n
}
\
n
\
n
.
source
-
tab
:
hover
{
\
n
background
:
var
(
-
-
theme
-
toolbar
-
background
)
;
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
source
-
tab
.
active
{
\
n
background
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
border
-
color
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
color
:
white
;
\
n
}
\
n
\
n
.
source
-
tab
.
active
path
{
\
n
fill
:
white
;
\
n
}
\
n
\
n
.
source
-
tab
.
close
-
btn
{
\
n
position
:
absolute
;
\
n
right
:
7px
;
\
n
top
:
1px
;
\
n
width
:
6px
;
\
n
height
:
6px
;
\
n
}
\
n
\
n
.
source
-
header
.
subsettings
{
\
n
position
:
absolute
;
\
n
right
:
3px
;
\
n
top
:
9px
;
\
n
}
\
n
\
n
.
sources
-
dropdown
{
\
n
position
:
absolute
;
\
n
top
:
35px
;
\
n
right
:
0px
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
502
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Dropdown
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Dropdown
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
.
dropdown
{
\
n
background
:
white
;
\
n
border
:
1px
solid
var
(
-
-
theme
-
gray
)
;
\
n
width
:
150px
;
\
n
max
-
height
:
300px
;
\
n
z
-
index
:
1000
;
\
n
}
\
n
\
n
.
dropdown
li
{
\
n
padding
-
left
:
10px
;
\
n
}
\
n
\
n
.
dropdown
li
:
hover
{
\
n
background
:
var
(
-
-
theme
-
tab
-
toolbar
-
background
)
;
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
dropdown
ul
{
\
n
list
-
style
:
none
;
\
n
line
-
height
:
2em
;
\
n
font
-
size
:
0
.
8em
;
\
n
margin
:
0
;
\
n
padding
:
0
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
actions
=
__webpack_require__
(
360
)
;
var
_require3
=
__webpack_require__
(
196
)
;
var
isEnabled
=
_require3
.
isEnabled
;
var
_require4
=
__webpack_require__
(
348
)
;
var
getSelectedSource
=
_require4
.
getSelectedSource
;
var
Svg
=
__webpack_require__
(
387
)
;
function
debugBtn
(
onClick
type
)
{
var
className
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
"
active
"
:
arguments
[
2
]
;
var
tooltip
=
arguments
[
3
]
;
className
=
{
type
}
{
className
}
;
return
dom
.
span
(
{
onClick
className
key
:
type
}
Svg
(
type
{
title
:
tooltip
}
)
)
;
}
function
SourceFooter
(
_ref
)
{
var
togglePrettyPrint
=
_ref
.
togglePrettyPrint
;
var
selectedSource
=
_ref
.
selectedSource
;
var
commandsEnabled
=
selectedSource
?
"
"
:
"
disabled
"
;
return
dom
.
div
(
{
className
:
"
source
-
footer
"
}
dom
.
div
(
{
className
:
"
command
-
bar
"
}
isEnabled
(
"
features
.
blackbox
"
)
?
debugBtn
(
(
)
=
>
{
}
"
blackBox
"
commandsEnabled
"
Toggle
Black
Boxing
"
)
:
null
debugBtn
(
(
)
=
>
togglePrettyPrint
(
selectedSource
.
get
(
"
id
"
)
)
"
prettyPrint
"
commandsEnabled
"
Prettify
Source
"
)
)
)
;
}
module
.
exports
=
connect
(
state
=
>
(
{
selectedSource
:
getSelectedSource
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
SourceFooter
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
_require
=
__webpack_require__
(
505
)
;
var
filter
=
_require
.
filter
;
var
classnames
=
__webpack_require__
(
379
)
;
__webpack_require__
(
511
)
;
var
Autocomplete
=
React
.
createClass
(
{
propTypes
:
{
selectItem
:
PropTypes
.
func
items
:
PropTypes
.
array
}
displayName
:
"
Autocomplete
"
getInitialState
(
)
{
return
{
inputValue
:
"
"
selectedIndex
:
-
1
}
;
}
componentDidMount
(
)
{
this
.
refs
.
searchInput
.
focus
(
)
;
}
componentDidUpdate
(
)
{
this
.
scrollList
(
)
;
}
scrollList
(
)
{
var
resultsEl
=
this
.
refs
.
results
;
if
(
resultsEl
.
children
.
length
=
=
=
0
)
{
return
;
}
var
resultsHeight
=
resultsEl
.
clientHeight
;
var
itemHeight
=
resultsEl
.
children
[
0
]
.
clientHeight
;
var
numVisible
=
resultsHeight
/
itemHeight
;
var
positionsToScroll
=
this
.
state
.
selectedIndex
-
numVisible
+
1
;
var
itemOffset
=
resultsHeight
%
itemHeight
;
var
scroll
=
positionsToScroll
*
(
itemHeight
+
2
)
+
itemOffset
;
resultsEl
.
scrollTop
=
Math
.
max
(
0
scroll
)
;
}
renderSearchItem
(
result
index
)
{
return
dom
.
li
(
{
onClick
:
(
)
=
>
this
.
props
.
selectItem
(
result
)
key
:
result
.
value
className
:
classnames
(
{
selected
:
index
=
=
=
this
.
state
.
selectedIndex
}
)
}
dom
.
div
(
{
className
:
"
title
"
}
result
.
title
)
dom
.
div
(
{
className
:
"
subtitle
"
}
result
.
subtitle
)
)
;
}
getSearchResults
(
)
{
var
inputValue
=
this
.
state
.
inputValue
;
if
(
inputValue
=
=
"
"
)
{
return
[
]
;
}
return
filter
(
this
.
props
.
items
this
.
state
.
inputValue
{
key
:
"
value
"
}
)
;
}
onKeyDown
(
e
)
{
var
searchResults
=
this
.
getSearchResults
(
)
resultCount
=
searchResults
.
length
;
if
(
e
.
key
=
=
=
"
ArrowUp
"
)
{
this
.
setState
(
{
selectedIndex
:
Math
.
max
(
0
this
.
state
.
selectedIndex
-
1
)
}
)
;
e
.
preventDefault
(
)
;
}
else
if
(
e
.
key
=
=
=
"
ArrowDown
"
)
{
this
.
setState
(
{
selectedIndex
:
Math
.
min
(
resultCount
-
1
this
.
state
.
selectedIndex
+
1
)
}
)
;
e
.
preventDefault
(
)
;
}
else
if
(
e
.
key
=
=
=
"
Enter
"
)
{
this
.
props
.
selectItem
(
searchResults
[
this
.
state
.
selectedIndex
]
)
;
e
.
preventDefault
(
)
;
}
}
render
(
)
{
var
searchResults
=
this
.
getSearchResults
(
)
;
return
dom
.
div
(
{
className
:
"
autocomplete
"
}
dom
.
input
(
{
ref
:
"
searchInput
"
onChange
:
e
=
>
this
.
setState
(
{
inputValue
:
e
.
target
.
value
selectedIndex
:
-
1
}
)
onKeyDown
:
this
.
onKeyDown
}
)
dom
.
ul
(
{
className
:
"
results
"
ref
:
"
results
"
}
searchResults
.
map
(
this
.
renderSearchItem
)
)
)
;
}
}
)
;
module
.
exports
=
Autocomplete
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
filter
legacy_scorer
matcher
prepQueryCache
scorer
;
scorer
=
__webpack_require__
(
506
)
;
legacy_scorer
=
__webpack_require__
(
508
)
;
filter
=
__webpack_require__
(
509
)
;
matcher
=
__webpack_require__
(
510
)
;
PathSeparator
=
__webpack_require__
(
507
)
.
sep
;
prepQueryCache
=
null
;
module
.
exports
=
{
filter
:
function
(
candidates
query
options
)
{
if
(
!
(
(
query
!
=
null
?
query
.
length
:
void
0
)
&
&
(
candidates
!
=
null
?
candidates
.
length
:
void
0
)
)
)
{
return
[
]
;
}
return
filter
(
candidates
query
options
)
;
}
prepQuery
:
function
(
query
)
{
return
scorer
.
prepQuery
(
query
)
;
}
score
:
function
(
string
query
prepQuery
_arg
)
{
var
allowErrors
coreQuery
legacy
queryHasSlashes
score
_ref
;
_ref
=
_arg
!
=
null
?
_arg
:
{
}
allowErrors
=
_ref
.
allowErrors
legacy
=
_ref
.
legacy
;
if
(
!
(
(
string
!
=
null
?
string
.
length
:
void
0
)
&
&
(
query
!
=
null
?
query
.
length
:
void
0
)
)
)
{
return
0
;
}
if
(
prepQuery
=
=
null
)
{
prepQuery
=
prepQueryCache
&
&
prepQueryCache
.
query
=
=
=
query
?
prepQueryCache
:
(
prepQueryCache
=
scorer
.
prepQuery
(
query
)
)
;
}
if
(
!
legacy
)
{
score
=
scorer
.
score
(
string
query
prepQuery
!
!
allowErrors
)
;
}
else
{
queryHasSlashes
=
prepQuery
.
depth
>
0
;
coreQuery
=
prepQuery
.
core
;
score
=
legacy_scorer
.
score
(
string
coreQuery
queryHasSlashes
)
;
if
(
!
queryHasSlashes
)
{
score
=
legacy_scorer
.
basenameScore
(
string
coreQuery
score
)
;
}
}
return
score
;
}
match
:
function
(
string
query
prepQuery
_arg
)
{
var
allowErrors
baseMatches
matches
query_lw
string_lw
_i
_ref
_results
;
allowErrors
=
(
_arg
!
=
null
?
_arg
:
{
}
)
.
allowErrors
;
if
(
!
string
)
{
return
[
]
;
}
if
(
!
query
)
{
return
[
]
;
}
if
(
string
=
=
=
query
)
{
return
(
function
(
)
{
_results
=
[
]
;
for
(
var
_i
=
0
_ref
=
string
.
length
;
0
<
=
_ref
?
_i
<
_ref
:
_i
>
_ref
;
0
<
=
_ref
?
_i
+
+
:
_i
-
-
)
{
_results
.
push
(
_i
)
;
}
return
_results
;
}
)
.
apply
(
this
)
;
}
if
(
prepQuery
=
=
null
)
{
prepQuery
=
prepQueryCache
&
&
prepQueryCache
.
query
=
=
=
query
?
prepQueryCache
:
(
prepQueryCache
=
scorer
.
prepQuery
(
query
)
)
;
}
if
(
!
(
allowErrors
|
|
scorer
.
isMatch
(
string
prepQuery
.
core_lw
prepQuery
.
core_up
)
)
)
{
return
[
]
;
}
string_lw
=
string
.
toLowerCase
(
)
;
query_lw
=
prepQuery
.
query_lw
;
matches
=
matcher
.
match
(
string
string_lw
prepQuery
)
;
if
(
matches
.
length
=
=
=
0
)
{
return
matches
;
}
if
(
string
.
indexOf
(
PathSeparator
)
>
-
1
)
{
baseMatches
=
matcher
.
basenameMatch
(
string
string_lw
prepQuery
)
;
matches
=
matcher
.
mergeMatches
(
matches
baseMatches
)
;
}
return
matches
;
}
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
AcronymResult
PathSeparator
Query
basenameScore
coreChars
countDir
doScore
emptyAcronymResult
file_coeff
isMatch
isSeparator
isWordEnd
isWordStart
miss_coeff
opt_char_re
pos_bonus
scoreAcronyms
scoreCharacter
scoreConsecutives
scoreExact
scoreExactMatch
scorePattern
scorePosition
scoreSize
tau_depth
tau_size
truncatedUpperCase
wm
;
PathSeparator
=
__webpack_require__
(
507
)
.
sep
;
wm
=
150
;
pos_bonus
=
20
;
tau_depth
=
13
;
tau_size
=
85
;
file_coeff
=
1
.
2
;
miss_coeff
=
0
.
75
;
opt_char_re
=
/
[
_
\
-
:
\
/
\
\
]
/
g
;
exports
.
coreChars
=
coreChars
=
function
(
query
)
{
return
query
.
replace
(
opt_char_re
'
'
)
;
}
;
exports
.
score
=
function
(
string
query
prepQuery
allowErrors
)
{
var
score
string_lw
;
if
(
prepQuery
=
=
null
)
{
prepQuery
=
new
Query
(
query
)
;
}
if
(
allowErrors
=
=
null
)
{
allowErrors
=
false
;
}
if
(
!
(
allowErrors
|
|
isMatch
(
string
prepQuery
.
core_lw
prepQuery
.
core_up
)
)
)
{
return
0
;
}
string_lw
=
string
.
toLowerCase
(
)
;
score
=
doScore
(
string
string_lw
prepQuery
)
;
return
Math
.
ceil
(
basenameScore
(
string
string_lw
prepQuery
score
)
)
;
}
;
Query
=
(
function
(
)
{
function
Query
(
query
)
{
if
(
!
(
query
!
=
null
?
query
.
length
:
void
0
)
)
{
return
null
;
}
this
.
query
=
query
;
this
.
query_lw
=
query
.
toLowerCase
(
)
;
this
.
core
=
coreChars
(
query
)
;
this
.
core_lw
=
this
.
core
.
toLowerCase
(
)
;
this
.
core_up
=
truncatedUpperCase
(
this
.
core
)
;
this
.
depth
=
countDir
(
query
query
.
length
)
;
}
return
Query
;
}
)
(
)
;
exports
.
prepQuery
=
function
(
query
)
{
return
new
Query
(
query
)
;
}
;
exports
.
isMatch
=
isMatch
=
function
(
subject
query_lw
query_up
)
{
var
i
j
m
n
qj_lw
qj_up
si
;
m
=
subject
.
length
;
n
=
query_lw
.
length
;
if
(
!
m
|
|
n
>
m
)
{
return
false
;
}
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
[
j
]
;
qj_up
=
query_up
[
j
]
;
while
(
+
+
i
<
m
)
{
si
=
subject
[
i
]
;
if
(
si
=
=
=
qj_lw
|
|
si
=
=
=
qj_up
)
{
break
;
}
}
if
(
i
=
=
=
m
)
{
return
false
;
}
}
return
true
;
}
;
doScore
=
function
(
subject
subject_lw
prepQuery
)
{
var
acro
acro_score
align
csc_diag
csc_row
csc_score
i
j
m
miss_budget
miss_left
mm
n
pos
query
query_lw
record_miss
score
score_diag
score_row
score_up
si_lw
start
sz
;
query
=
prepQuery
.
query
;
query_lw
=
prepQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro
=
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
;
acro_score
=
acro
.
score
;
if
(
acro
.
count
=
=
=
n
)
{
return
scoreExact
(
n
m
acro_score
acro
.
pos
)
;
}
pos
=
subject_lw
.
indexOf
(
query_lw
)
;
if
(
pos
>
-
1
)
{
return
scoreExactMatch
(
subject
subject_lw
query
query_lw
pos
n
m
)
;
}
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
sz
=
scoreSize
(
n
m
)
;
miss_budget
=
Math
.
ceil
(
miss_coeff
*
n
)
+
5
;
miss_left
=
miss_budget
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
subject_lw
.
indexOf
(
query_lw
[
0
]
)
;
if
(
i
>
-
1
)
{
i
-
-
;
}
mm
=
subject_lw
.
lastIndexOf
(
query_lw
[
n
-
1
]
m
)
;
if
(
mm
>
i
)
{
m
=
mm
+
1
;
}
while
(
+
+
i
<
m
)
{
score
=
0
;
score_diag
=
0
;
csc_diag
=
0
;
si_lw
=
subject_lw
[
i
]
;
record_miss
=
true
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_up
=
score_row
[
j
]
;
if
(
score_up
>
score
)
{
score
=
score_up
;
}
csc_score
=
0
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
if
(
align
>
score
)
{
score
=
align
;
miss_left
=
miss_budget
;
}
else
{
if
(
record_miss
&
&
-
-
miss_left
<
=
0
)
{
return
score_row
[
n
-
1
]
*
sz
;
}
record_miss
=
false
;
}
}
score_diag
=
score_up
;
csc_diag
=
csc_row
[
j
]
;
csc_row
[
j
]
=
csc_score
;
score_row
[
j
]
=
score
;
}
}
return
score
*
sz
;
}
;
exports
.
isWordStart
=
isWordStart
=
function
(
pos
subject
subject_lw
)
{
var
curr_s
prev_s
;
if
(
pos
=
=
=
0
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
prev_s
=
subject
[
pos
-
1
]
;
return
isSeparator
(
curr_s
)
|
|
isSeparator
(
prev_s
)
|
|
(
curr_s
!
=
=
subject_lw
[
pos
]
&
&
prev_s
=
=
=
subject_lw
[
pos
-
1
]
)
;
}
;
exports
.
isWordEnd
=
isWordEnd
=
function
(
pos
subject
subject_lw
len
)
{
var
curr_s
next_s
;
if
(
pos
=
=
=
len
-
1
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
next_s
=
subject
[
pos
+
1
]
;
return
isSeparator
(
curr_s
)
|
|
isSeparator
(
next_s
)
|
|
(
curr_s
=
=
=
subject_lw
[
pos
]
&
&
next_s
!
=
=
subject_lw
[
pos
+
1
]
)
;
}
;
isSeparator
=
function
(
c
)
{
return
c
=
=
=
'
'
|
|
c
=
=
=
'
.
'
|
|
c
=
=
=
'
-
'
|
|
c
=
=
=
'
_
'
|
|
c
=
=
=
'
/
'
|
|
c
=
=
=
'
\
\
'
;
}
;
scorePosition
=
function
(
pos
)
{
var
sc
;
if
(
pos
<
pos_bonus
)
{
sc
=
pos_bonus
-
pos
;
return
100
+
sc
*
sc
;
}
else
{
return
Math
.
max
(
100
+
pos_bonus
-
pos
0
)
;
}
}
;
scoreSize
=
function
(
n
m
)
{
return
tau_size
/
(
tau_size
+
Math
.
abs
(
m
-
n
)
)
;
}
;
scoreExact
=
function
(
n
m
quality
pos
)
{
return
2
*
n
*
(
wm
*
quality
+
scorePosition
(
pos
)
)
*
scoreSize
(
n
m
)
;
}
;
exports
.
scorePattern
=
scorePattern
=
function
(
count
len
sameCase
start
end
)
{
var
bonus
sz
;
sz
=
count
;
bonus
=
6
;
if
(
sameCase
=
=
=
count
)
{
bonus
+
=
2
;
}
if
(
start
)
{
bonus
+
=
3
;
}
if
(
end
)
{
bonus
+
=
1
;
}
if
(
count
=
=
=
len
)
{
if
(
start
)
{
if
(
sameCase
=
=
=
len
)
{
sz
+
=
2
;
}
else
{
sz
+
=
1
;
}
}
if
(
end
)
{
bonus
+
=
1
;
}
}
return
sameCase
+
sz
*
(
sz
+
bonus
)
;
}
;
exports
.
scoreCharacter
=
scoreCharacter
=
function
(
i
j
start
acro_score
csc_score
)
{
var
posBonus
;
posBonus
=
scorePosition
(
i
)
;
if
(
start
)
{
return
posBonus
+
wm
*
(
(
acro_score
>
csc_score
?
acro_score
:
csc_score
)
+
10
)
;
}
return
posBonus
+
wm
*
csc_score
;
}
;
exports
.
scoreConsecutives
=
scoreConsecutives
=
function
(
subject
subject_lw
query
query_lw
i
j
start
)
{
var
k
m
mi
n
nj
sameCase
startPos
sz
;
m
=
subject
.
length
;
n
=
query
.
length
;
mi
=
m
-
i
;
nj
=
n
-
j
;
k
=
mi
<
nj
?
mi
:
nj
;
startPos
=
i
;
sameCase
=
0
;
sz
=
0
;
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
while
(
+
+
sz
<
k
&
&
query_lw
[
+
+
j
]
=
=
=
subject_lw
[
+
+
i
]
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
if
(
sz
=
=
=
1
)
{
return
1
+
2
*
sameCase
;
}
return
scorePattern
(
sz
n
sameCase
start
isWordEnd
(
i
subject
subject_lw
m
)
)
;
}
;
exports
.
scoreExactMatch
=
scoreExactMatch
=
function
(
subject
subject_lw
query
query_lw
pos
n
m
)
{
var
end
i
pos2
sameCase
start
;
start
=
isWordStart
(
pos
subject
subject_lw
)
;
if
(
!
start
)
{
pos2
=
subject_lw
.
indexOf
(
query_lw
pos
+
1
)
;
if
(
pos2
>
-
1
)
{
start
=
isWordStart
(
pos2
subject
subject_lw
)
;
if
(
start
)
{
pos
=
pos2
;
}
}
}
i
=
-
1
;
sameCase
=
0
;
while
(
+
+
i
<
n
)
{
if
(
query
[
pos
+
i
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
end
=
isWordEnd
(
pos
+
n
-
1
subject
subject_lw
m
)
;
return
scoreExact
(
n
m
scorePattern
(
n
n
sameCase
start
end
)
pos
)
;
}
;
AcronymResult
=
(
function
(
)
{
function
AcronymResult
(
score
pos
count
)
{
this
.
score
=
score
;
this
.
pos
=
pos
;
this
.
count
=
count
;
}
return
AcronymResult
;
}
)
(
)
;
emptyAcronymResult
=
new
AcronymResult
(
0
0
.
1
0
)
;
exports
.
scoreAcronyms
=
scoreAcronyms
=
function
(
subject
subject_lw
query
query_lw
)
{
var
count
i
j
m
n
pos
qj_lw
sameCase
score
;
m
=
subject
.
length
;
n
=
query
.
length
;
if
(
!
(
m
>
1
&
&
n
>
1
)
)
{
return
emptyAcronymResult
;
}
count
=
0
;
pos
=
0
;
sameCase
=
0
;
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
[
j
]
;
while
(
+
+
i
<
m
)
{
if
(
qj_lw
=
=
=
subject_lw
[
i
]
&
&
isWordStart
(
i
subject
subject_lw
)
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
pos
+
=
i
;
count
+
+
;
break
;
}
}
if
(
i
=
=
=
m
)
{
break
;
}
}
if
(
count
<
2
)
{
return
emptyAcronymResult
;
}
score
=
scorePattern
(
count
n
sameCase
true
false
)
;
return
new
AcronymResult
(
score
pos
/
count
count
)
;
}
;
basenameScore
=
function
(
subject
subject_lw
prepQuery
fullPathScore
)
{
var
alpha
basePathScore
basePos
depth
end
;
if
(
fullPathScore
=
=
=
0
)
{
return
0
;
}
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
PathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
PathSeparator
end
)
;
if
(
basePos
=
=
=
-
1
)
{
return
fullPathScore
;
}
depth
=
prepQuery
.
depth
;
while
(
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
PathSeparator
basePos
-
1
)
;
if
(
basePos
=
=
=
-
1
)
{
return
fullPathScore
;
}
}
basePos
+
+
;
end
+
+
;
basePathScore
=
doScore
(
subject
.
slice
(
basePos
end
)
subject_lw
.
slice
(
basePos
end
)
prepQuery
)
;
alpha
=
0
.
5
*
tau_depth
/
(
tau_depth
+
countDir
(
subject
end
+
1
)
)
;
return
alpha
*
basePathScore
+
(
1
-
alpha
)
*
fullPathScore
*
scoreSize
(
0
file_coeff
*
(
end
-
basePos
)
)
;
}
;
exports
.
countDir
=
countDir
=
function
(
path
end
)
{
var
count
i
;
if
(
end
<
1
)
{
return
0
;
}
count
=
0
;
i
=
-
1
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
PathSeparator
)
{
continue
;
}
while
(
+
+
i
<
end
)
{
if
(
path
[
i
]
=
=
=
PathSeparator
)
{
count
+
+
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
PathSeparator
)
{
continue
;
}
}
}
return
count
;
}
;
truncatedUpperCase
=
function
(
str
)
{
var
char
upper
_i
_len
;
upper
=
"
"
;
for
(
_i
=
0
_len
=
str
.
length
;
_i
<
_len
;
_i
+
+
)
{
char
=
str
[
_i
]
;
upper
+
=
char
.
toUpperCase
(
)
[
0
]
;
}
return
upper
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
function
normalizeArray
(
parts
allowAboveRoot
)
{
var
up
=
0
;
for
(
var
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
last
=
parts
[
i
]
;
if
(
last
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
parts
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
parts
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
allowAboveRoot
)
{
for
(
;
up
-
-
;
up
)
{
parts
.
unshift
(
'
.
.
'
)
;
}
}
return
parts
;
}
var
splitPathRe
=
/
^
(
\
/
?
|
)
(
[
\
s
\
S
]
*
?
)
(
(
?
:
\
.
{
1
2
}
|
[
^
\
/
]
+
?
|
)
(
\
.
[
^
.
\
/
]
*
|
)
)
(
?
:
[
\
/
]
*
)
/
;
var
splitPath
=
function
(
filename
)
{
return
splitPathRe
.
exec
(
filename
)
.
slice
(
1
)
;
}
;
exports
.
resolve
=
function
(
)
{
var
resolvedPath
=
'
'
resolvedAbsolute
=
false
;
for
(
var
i
=
arguments
.
length
-
1
;
i
>
=
-
1
&
&
!
resolvedAbsolute
;
i
-
-
)
{
var
path
=
(
i
>
=
0
)
?
arguments
[
i
]
:
process
.
cwd
(
)
;
if
(
typeof
path
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
resolve
must
be
strings
'
)
;
}
else
if
(
!
path
)
{
continue
;
}
resolvedPath
=
path
+
'
/
'
+
resolvedPath
;
resolvedAbsolute
=
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
resolvedPath
=
normalizeArray
(
filter
(
resolvedPath
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
resolvedAbsolute
)
.
join
(
'
/
'
)
;
return
(
(
resolvedAbsolute
?
'
/
'
:
'
'
)
+
resolvedPath
)
|
|
'
.
'
;
}
;
exports
.
normalize
=
function
(
path
)
{
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
trailingSlash
=
substr
(
path
-
1
)
=
=
=
'
/
'
;
path
=
normalizeArray
(
filter
(
path
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
isAbsolute
)
.
join
(
'
/
'
)
;
if
(
!
path
&
&
!
isAbsolute
)
{
path
=
'
.
'
;
}
if
(
path
&
&
trailingSlash
)
{
path
+
=
'
/
'
;
}
return
(
isAbsolute
?
'
/
'
:
'
'
)
+
path
;
}
;
exports
.
isAbsolute
=
function
(
path
)
{
return
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
;
exports
.
join
=
function
(
)
{
var
paths
=
Array
.
prototype
.
slice
.
call
(
arguments
0
)
;
return
exports
.
normalize
(
filter
(
paths
function
(
p
index
)
{
if
(
typeof
p
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
join
must
be
strings
'
)
;
}
return
p
;
}
)
.
join
(
'
/
'
)
)
;
}
;
exports
.
relative
=
function
(
from
to
)
{
from
=
exports
.
resolve
(
from
)
.
substr
(
1
)
;
to
=
exports
.
resolve
(
to
)
.
substr
(
1
)
;
function
trim
(
arr
)
{
var
start
=
0
;
for
(
;
start
<
arr
.
length
;
start
+
+
)
{
if
(
arr
[
start
]
!
=
=
'
'
)
break
;
}
var
end
=
arr
.
length
-
1
;
for
(
;
end
>
=
0
;
end
-
-
)
{
if
(
arr
[
end
]
!
=
=
'
'
)
break
;
}
if
(
start
>
end
)
return
[
]
;
return
arr
.
slice
(
start
end
-
start
+
1
)
;
}
var
fromParts
=
trim
(
from
.
split
(
'
/
'
)
)
;
var
toParts
=
trim
(
to
.
split
(
'
/
'
)
)
;
var
length
=
Math
.
min
(
fromParts
.
length
toParts
.
length
)
;
var
samePartsLength
=
length
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
fromParts
[
i
]
!
=
=
toParts
[
i
]
)
{
samePartsLength
=
i
;
break
;
}
}
var
outputParts
=
[
]
;
for
(
var
i
=
samePartsLength
;
i
<
fromParts
.
length
;
i
+
+
)
{
outputParts
.
push
(
'
.
.
'
)
;
}
outputParts
=
outputParts
.
concat
(
toParts
.
slice
(
samePartsLength
)
)
;
return
outputParts
.
join
(
'
/
'
)
;
}
;
exports
.
sep
=
'
/
'
;
exports
.
delimiter
=
'
:
'
;
exports
.
dirname
=
function
(
path
)
{
var
result
=
splitPath
(
path
)
root
=
result
[
0
]
dir
=
result
[
1
]
;
if
(
!
root
&
&
!
dir
)
{
return
'
.
'
;
}
if
(
dir
)
{
dir
=
dir
.
substr
(
0
dir
.
length
-
1
)
;
}
return
root
+
dir
;
}
;
exports
.
basename
=
function
(
path
ext
)
{
var
f
=
splitPath
(
path
)
[
2
]
;
if
(
ext
&
&
f
.
substr
(
-
1
*
ext
.
length
)
=
=
=
ext
)
{
f
=
f
.
substr
(
0
f
.
length
-
ext
.
length
)
;
}
return
f
;
}
;
exports
.
extname
=
function
(
path
)
{
return
splitPath
(
path
)
[
3
]
;
}
;
function
filter
(
xs
f
)
{
if
(
xs
.
filter
)
return
xs
.
filter
(
f
)
;
var
res
=
[
]
;
for
(
var
i
=
0
;
i
<
xs
.
length
;
i
+
+
)
{
if
(
f
(
xs
[
i
]
i
xs
)
)
res
.
push
(
xs
[
i
]
)
;
}
return
res
;
}
var
substr
=
'
ab
'
.
substr
(
-
1
)
=
=
=
'
b
'
?
function
(
str
start
len
)
{
return
str
.
substr
(
start
len
)
}
:
function
(
str
start
len
)
{
if
(
start
<
0
)
start
=
str
.
length
+
start
;
return
str
.
substr
(
start
len
)
;
}
;
}
.
call
(
exports
__webpack_require__
(
185
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
queryIsLastPathSegment
;
PathSeparator
=
__webpack_require__
(
507
)
.
sep
;
exports
.
basenameScore
=
function
(
string
query
score
)
{
var
base
depth
index
lastCharacter
segmentCount
slashCount
;
index
=
string
.
length
-
1
;
while
(
string
[
index
]
=
=
=
PathSeparator
)
{
index
-
-
;
}
slashCount
=
0
;
lastCharacter
=
index
;
base
=
null
;
while
(
index
>
=
0
)
{
if
(
string
[
index
]
=
=
=
PathSeparator
)
{
slashCount
+
+
;
if
(
base
=
=
null
)
{
base
=
string
.
substring
(
index
+
1
lastCharacter
+
1
)
;
}
}
else
if
(
index
=
=
=
0
)
{
if
(
lastCharacter
<
string
.
length
-
1
)
{
if
(
base
=
=
null
)
{
base
=
string
.
substring
(
0
lastCharacter
+
1
)
;
}
}
else
{
if
(
base
=
=
null
)
{
base
=
string
;
}
}
}
index
-
-
;
}
if
(
base
=
=
=
string
)
{
score
*
=
2
;
}
else
if
(
base
)
{
score
+
=
exports
.
score
(
base
query
)
;
}
segmentCount
=
slashCount
+
1
;
depth
=
Math
.
max
(
1
10
-
segmentCount
)
;
score
*
=
depth
*
0
.
01
;
return
score
;
}
;
exports
.
score
=
function
(
string
query
)
{
var
character
characterScore
indexInQuery
indexInString
lowerCaseIndex
minIndex
queryLength
queryScore
stringLength
totalCharacterScore
upperCaseIndex
_ref
;
if
(
string
=
=
=
query
)
{
return
1
;
}
if
(
queryIsLastPathSegment
(
string
query
)
)
{
return
1
;
}
totalCharacterScore
=
0
;
queryLength
=
query
.
length
;
stringLength
=
string
.
length
;
indexInQuery
=
0
;
indexInString
=
0
;
while
(
indexInQuery
<
queryLength
)
{
character
=
query
[
indexInQuery
+
+
]
;
lowerCaseIndex
=
string
.
indexOf
(
character
.
toLowerCase
(
)
)
;
upperCaseIndex
=
string
.
indexOf
(
character
.
toUpperCase
(
)
)
;
minIndex
=
Math
.
min
(
lowerCaseIndex
upperCaseIndex
)
;
if
(
minIndex
=
=
=
-
1
)
{
minIndex
=
Math
.
max
(
lowerCaseIndex
upperCaseIndex
)
;
}
indexInString
=
minIndex
;
if
(
indexInString
=
=
=
-
1
)
{
return
0
;
}
characterScore
=
0
.
1
;
if
(
string
[
indexInString
]
=
=
=
character
)
{
characterScore
+
=
0
.
1
;
}
if
(
indexInString
=
=
=
0
|
|
string
[
indexInString
-
1
]
=
=
=
PathSeparator
)
{
characterScore
+
=
0
.
8
;
}
else
if
(
(
_ref
=
string
[
indexInString
-
1
]
)
=
=
=
'
-
'
|
|
_ref
=
=
=
'
_
'
|
|
_ref
=
=
=
'
'
)
{
characterScore
+
=
0
.
7
;
}
string
=
string
.
substring
(
indexInString
+
1
stringLength
)
;
totalCharacterScore
+
=
characterScore
;
}
queryScore
=
totalCharacterScore
/
queryLength
;
return
(
(
queryScore
*
(
queryLength
/
stringLength
)
)
+
queryScore
)
/
2
;
}
;
queryIsLastPathSegment
=
function
(
string
query
)
{
if
(
string
[
string
.
length
-
query
.
length
-
1
]
=
=
=
PathSeparator
)
{
return
string
.
lastIndexOf
(
query
)
=
=
=
string
.
length
-
query
.
length
;
}
}
;
exports
.
match
=
function
(
string
query
stringOffset
)
{
var
character
indexInQuery
indexInString
lowerCaseIndex
matches
minIndex
queryLength
stringLength
upperCaseIndex
_i
_ref
_results
;
if
(
stringOffset
=
=
null
)
{
stringOffset
=
0
;
}
if
(
string
=
=
=
query
)
{
return
(
function
(
)
{
_results
=
[
]
;
for
(
var
_i
=
stringOffset
_ref
=
stringOffset
+
string
.
length
;
stringOffset
<
=
_ref
?
_i
<
_ref
:
_i
>
_ref
;
stringOffset
<
=
_ref
?
_i
+
+
:
_i
-
-
)
{
_results
.
push
(
_i
)
;
}
return
_results
;
}
)
.
apply
(
this
)
;
}
queryLength
=
query
.
length
;
stringLength
=
string
.
length
;
indexInQuery
=
0
;
indexInString
=
0
;
matches
=
[
]
;
while
(
indexInQuery
<
queryLength
)
{
character
=
query
[
indexInQuery
+
+
]
;
lowerCaseIndex
=
string
.
indexOf
(
character
.
toLowerCase
(
)
)
;
upperCaseIndex
=
string
.
indexOf
(
character
.
toUpperCase
(
)
)
;
minIndex
=
Math
.
min
(
lowerCaseIndex
upperCaseIndex
)
;
if
(
minIndex
=
=
=
-
1
)
{
minIndex
=
Math
.
max
(
lowerCaseIndex
upperCaseIndex
)
;
}
indexInString
=
minIndex
;
if
(
indexInString
=
=
=
-
1
)
{
return
[
]
;
}
matches
.
push
(
stringOffset
+
indexInString
)
;
stringOffset
+
=
indexInString
+
1
;
string
=
string
.
substring
(
indexInString
+
1
stringLength
)
;
}
return
matches
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
legacy_scorer
pluckCandidates
scorer
sortCandidates
;
scorer
=
__webpack_require__
(
506
)
;
legacy_scorer
=
__webpack_require__
(
508
)
;
pluckCandidates
=
function
(
a
)
{
return
a
.
candidate
;
}
;
sortCandidates
=
function
(
a
b
)
{
return
b
.
score
-
a
.
score
;
}
;
PathSeparator
=
__webpack_require__
(
507
)
.
sep
;
module
.
exports
=
function
(
candidates
query
_arg
)
{
var
allowErrors
bAllowErrors
bKey
candidate
coreQuery
key
legacy
maxInners
maxResults
prepQuery
queryHasSlashes
score
scoredCandidates
spotLeft
string
_i
_j
_len
_len1
_ref
;
_ref
=
_arg
!
=
null
?
_arg
:
{
}
key
=
_ref
.
key
maxResults
=
_ref
.
maxResults
maxInners
=
_ref
.
maxInners
allowErrors
=
_ref
.
allowErrors
legacy
=
_ref
.
legacy
;
scoredCandidates
=
[
]
;
spotLeft
=
(
maxInners
!
=
null
)
&
&
maxInners
>
0
?
maxInners
:
candidates
.
length
;
bAllowErrors
=
!
!
allowErrors
;
bKey
=
key
!
=
null
;
prepQuery
=
scorer
.
prepQuery
(
query
)
;
if
(
!
legacy
)
{
for
(
_i
=
0
_len
=
candidates
.
length
;
_i
<
_len
;
_i
+
+
)
{
candidate
=
candidates
[
_i
]
;
string
=
bKey
?
candidate
[
key
]
:
candidate
;
if
(
!
string
)
{
continue
;
}
score
=
scorer
.
score
(
string
query
prepQuery
bAllowErrors
)
;
if
(
score
>
0
)
{
scoredCandidates
.
push
(
{
candidate
:
candidate
score
:
score
}
)
;
if
(
!
-
-
spotLeft
)
{
break
;
}
}
}
}
else
{
queryHasSlashes
=
prepQuery
.
depth
>
0
;
coreQuery
=
prepQuery
.
core
;
for
(
_j
=
0
_len1
=
candidates
.
length
;
_j
<
_len1
;
_j
+
+
)
{
candidate
=
candidates
[
_j
]
;
string
=
key
!
=
null
?
candidate
[
key
]
:
candidate
;
if
(
!
string
)
{
continue
;
}
score
=
legacy_scorer
.
score
(
string
coreQuery
queryHasSlashes
)
;
if
(
!
queryHasSlashes
)
{
score
=
legacy_scorer
.
basenameScore
(
string
coreQuery
score
)
;
}
if
(
score
>
0
)
{
scoredCandidates
.
push
(
{
candidate
:
candidate
score
:
score
}
)
;
}
}
}
scoredCandidates
.
sort
(
sortCandidates
)
;
candidates
=
scoredCandidates
.
map
(
pluckCandidates
)
;
if
(
maxResults
!
=
null
)
{
candidates
=
candidates
.
slice
(
0
maxResults
)
;
}
return
candidates
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
scorer
;
PathSeparator
=
__webpack_require__
(
507
)
.
sep
;
scorer
=
__webpack_require__
(
506
)
;
exports
.
basenameMatch
=
function
(
subject
subject_lw
prepQuery
)
{
var
basePos
depth
end
;
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
PathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
PathSeparator
end
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
depth
=
prepQuery
.
depth
;
while
(
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
PathSeparator
basePos
-
1
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
}
basePos
+
+
;
end
+
+
;
return
exports
.
match
(
subject
.
slice
(
basePos
end
)
subject_lw
.
slice
(
basePos
end
)
prepQuery
basePos
)
;
}
;
exports
.
mergeMatches
=
function
(
a
b
)
{
var
ai
bj
i
j
m
n
out
;
m
=
a
.
length
;
n
=
b
.
length
;
if
(
n
=
=
=
0
)
{
return
a
.
slice
(
)
;
}
if
(
m
=
=
=
0
)
{
return
b
.
slice
(
)
;
}
i
=
-
1
;
j
=
0
;
bj
=
b
[
j
]
;
out
=
[
]
;
while
(
+
+
i
<
m
)
{
ai
=
a
[
i
]
;
while
(
bj
<
=
ai
&
&
+
+
j
<
n
)
{
if
(
bj
<
ai
)
{
out
.
push
(
bj
)
;
}
bj
=
b
[
j
]
;
}
out
.
push
(
ai
)
;
}
while
(
j
<
n
)
{
out
.
push
(
b
[
j
+
+
]
)
;
}
return
out
;
}
;
exports
.
match
=
function
(
subject
subject_lw
prepQuery
offset
)
{
var
DIAGONAL
LEFT
STOP
UP
acro_score
align
backtrack
csc_diag
csc_row
csc_score
i
j
m
matches
move
n
pos
query
query_lw
score
score_diag
score_row
score_up
si_lw
start
trace
;
if
(
offset
=
=
null
)
{
offset
=
0
;
}
query
=
prepQuery
.
query
;
query_lw
=
prepQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro_score
=
scorer
.
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
.
score
;
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
STOP
=
0
;
UP
=
1
;
LEFT
=
2
;
DIAGONAL
=
3
;
trace
=
new
Array
(
m
*
n
)
;
pos
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
score
=
0
;
score_up
=
0
;
csc_diag
=
0
;
si_lw
=
subject_lw
[
i
]
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
csc_score
=
0
;
align
=
0
;
score_diag
=
score_up
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
scorer
.
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scorer
.
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scorer
.
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
}
score_up
=
score_row
[
j
]
;
csc_diag
=
csc_row
[
j
]
;
if
(
score
>
score_up
)
{
move
=
LEFT
;
}
else
{
score
=
score_up
;
move
=
UP
;
}
if
(
align
>
score
)
{
score
=
align
;
move
=
DIAGONAL
;
}
else
{
csc_score
=
0
;
}
score_row
[
j
]
=
score
;
csc_row
[
j
]
=
csc_score
;
trace
[
+
+
pos
]
=
score
>
0
?
move
:
STOP
;
}
}
i
=
m
-
1
;
j
=
n
-
1
;
pos
=
i
*
n
+
j
;
backtrack
=
true
;
matches
=
[
]
;
while
(
backtrack
&
&
i
>
=
0
&
&
j
>
=
0
)
{
switch
(
trace
[
pos
]
)
{
case
UP
:
i
-
-
;
pos
-
=
n
;
break
;
case
LEFT
:
j
-
-
;
pos
-
-
;
break
;
case
DIAGONAL
:
matches
.
push
(
i
+
offset
)
;
j
-
-
;
i
-
-
;
pos
-
=
n
+
1
;
break
;
default
:
backtrack
=
false
;
}
}
matches
.
reverse
(
)
;
return
matches
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
content
=
__webpack_require__
(
512
)
;
if
(
typeof
content
=
=
=
'
string
'
)
content
=
[
[
module
.
id
content
'
'
]
]
;
var
update
=
__webpack_require__
(
358
)
(
content
{
}
)
;
if
(
content
.
locals
)
module
.
exports
=
content
.
locals
;
if
(
false
)
{
if
(
!
content
.
locals
)
{
module
.
hot
.
accept
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Autocomplete
.
css
"
function
(
)
{
var
newContent
=
require
(
"
!
!
.
/
.
.
/
.
.
/
.
.
/
node_modules
/
css
-
loader
/
index
.
js
!
.
/
Autocomplete
.
css
"
)
;
if
(
typeof
newContent
=
=
=
'
string
'
)
newContent
=
[
[
module
.
id
newContent
'
'
]
]
;
update
(
newContent
)
;
}
)
;
}
module
.
hot
.
dispose
(
function
(
)
{
update
(
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
exports
=
module
.
exports
=
__webpack_require__
(
357
)
(
)
;
exports
.
push
(
[
module
.
id
"
\
n
.
autocomplete
{
\
n
width
:
100
%
;
\
n
padding
:
20px
;
\
n
}
\
n
\
n
.
autocomplete
ul
{
\
n
list
-
style
:
none
;
\
n
width
:
100
%
;
\
n
max
-
height
:
calc
(
100
%
-
32px
)
;
\
n
margin
:
0px
;
\
n
padding
:
0px
;
\
n
overflow
:
auto
;
\
n
border
-
left
:
2px
solid
#
dde1e4
;
\
n
border
-
right
:
2px
solid
#
dde1e4
;
\
n
}
\
n
\
n
.
autocomplete
ul
:
not
(
:
empty
)
{
\
n
border
-
bottom
:
2px
solid
#
dde1e4
;
\
n
}
\
n
\
n
.
autocomplete
li
:
nth
-
child
(
1
)
{
\
n
border
-
top
:
none
;
\
n
}
\
n
\
n
.
autocomplete
li
{
\
n
border
-
top
:
2px
solid
#
dde1e4
;
\
n
padding
:
10px
;
\
n
}
\
n
\
n
.
autocomplete
li
:
hover
{
\
n
background
:
#
efefef
;
\
n
cursor
:
pointer
;
\
n
}
\
n
\
n
.
autocomplete
li
.
selected
{
\
n
background
:
var
(
-
-
theme
-
selection
-
background
)
;
\
n
color
:
white
;
\
n
}
\
n
\
n
.
autocomplete
li
.
selected
.
subtitle
{
\
n
color
:
white
;
\
n
}
\
n
\
n
.
autocomplete
li
.
title
{
\
n
font
-
size
:
0
.
8em
;
\
n
line
-
height
:
1
.
5em
;
\
n
}
\
n
\
n
.
autocomplete
li
.
subtitle
{
\
n
font
-
size
:
0
.
7em
;
\
n
line
-
height
:
1
.
5em
;
\
n
color
:
grey
;
\
n
}
\
n
\
n
.
autocomplete
input
{
\
n
width
:
100
%
;
\
n
border
:
2px
solid
#
dde1e4
;
\
n
outline
:
none
;
\
n
line
-
height
:
2
.
5em
;
\
n
height
:
2
.
5em
;
\
n
padding
-
left
:
25px
;
\
n
font
-
size
:
0
.
8em
;
\
n
background
-
image
:
url
(
\
"
/
images
/
magnifying
-
glass
.
svg
\
"
)
;
\
n
background
-
repeat
:
no
-
repeat
;
\
n
background
-
position
:
5px
50
%
;
\
n
}
\
n
\
n
.
autocomplete
input
:
focus
{
\
n
border
-
color
:
#
4a90e0
;
\
n
}
\
n
"
"
"
]
)
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Services
}
=
__webpack_require__
(
514
)
;
const
EventEmitter
=
__webpack_require__
(
260
)
;
const
isOSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
ElectronKeysMapping
=
{
"
F1
"
:
"
DOM_VK_F1
"
"
F2
"
:
"
DOM_VK_F2
"
"
F3
"
:
"
DOM_VK_F3
"
"
F4
"
:
"
DOM_VK_F4
"
"
F5
"
:
"
DOM_VK_F5
"
"
F6
"
:
"
DOM_VK_F6
"
"
F7
"
:
"
DOM_VK_F7
"
"
F8
"
:
"
DOM_VK_F8
"
"
F9
"
:
"
DOM_VK_F9
"
"
F10
"
:
"
DOM_VK_F10
"
"
F11
"
:
"
DOM_VK_F11
"
"
F12
"
:
"
DOM_VK_F12
"
"
F13
"
:
"
DOM_VK_F13
"
"
F14
"
:
"
DOM_VK_F14
"
"
F15
"
:
"
DOM_VK_F15
"
"
F16
"
:
"
DOM_VK_F16
"
"
F17
"
:
"
DOM_VK_F17
"
"
F18
"
:
"
DOM_VK_F18
"
"
F19
"
:
"
DOM_VK_F19
"
"
F20
"
:
"
DOM_VK_F20
"
"
F21
"
:
"
DOM_VK_F21
"
"
F22
"
:
"
DOM_VK_F22
"
"
F23
"
:
"
DOM_VK_F23
"
"
F24
"
:
"
DOM_VK_F24
"
"
Space
"
:
"
DOM_VK_SPACE
"
"
Backspace
"
:
"
DOM_VK_BACK_SPACE
"
"
Delete
"
:
"
DOM_VK_DELETE
"
"
Insert
"
:
"
DOM_VK_INSERT
"
"
Return
"
:
"
DOM_VK_RETURN
"
"
Enter
"
:
"
DOM_VK_RETURN
"
"
Up
"
:
"
DOM_VK_UP
"
"
Down
"
:
"
DOM_VK_DOWN
"
"
Left
"
:
"
DOM_VK_LEFT
"
"
Right
"
:
"
DOM_VK_RIGHT
"
"
Home
"
:
"
DOM_VK_HOME
"
"
End
"
:
"
DOM_VK_END
"
"
PageUp
"
:
"
DOM_VK_PAGE_UP
"
"
PageDown
"
:
"
DOM_VK_PAGE_DOWN
"
"
Escape
"
:
"
DOM_VK_ESCAPE
"
"
Esc
"
:
"
DOM_VK_ESCAPE
"
"
Tab
"
:
"
DOM_VK_TAB
"
"
VolumeUp
"
:
"
DOM_VK_VOLUME_UP
"
"
VolumeDown
"
:
"
DOM_VK_VOLUME_DOWN
"
"
VolumeMute
"
:
"
DOM_VK_VOLUME_MUTE
"
"
PrintScreen
"
:
"
DOM_VK_PRINTSCREEN
"
}
;
function
KeyShortcuts
(
{
window
target
}
)
{
this
.
window
=
window
;
this
.
target
=
target
|
|
window
;
this
.
keys
=
new
Map
(
)
;
this
.
eventEmitter
=
new
EventEmitter
(
)
;
this
.
target
.
addEventListener
(
"
keydown
"
this
)
;
}
KeyShortcuts
.
parseElectronKey
=
function
(
window
str
)
{
let
modifiers
=
str
.
split
(
"
+
"
)
;
let
key
=
modifiers
.
pop
(
)
;
let
shortcut
=
{
ctrl
:
false
meta
:
false
alt
:
false
shift
:
false
key
:
undefined
keyCode
:
undefined
}
;
for
(
let
mod
of
modifiers
)
{
if
(
mod
=
=
=
"
Alt
"
)
{
shortcut
.
alt
=
true
;
}
else
if
(
[
"
Command
"
"
Cmd
"
]
.
includes
(
mod
)
)
{
shortcut
.
meta
=
true
;
}
else
if
(
[
"
CommandOrControl
"
"
CmdOrCtrl
"
]
.
includes
(
mod
)
)
{
if
(
isOSX
)
{
shortcut
.
meta
=
true
;
}
else
{
shortcut
.
ctrl
=
true
;
}
}
else
if
(
[
"
Control
"
"
Ctrl
"
]
.
includes
(
mod
)
)
{
shortcut
.
ctrl
=
true
;
}
else
if
(
mod
=
=
=
"
Shift
"
)
{
shortcut
.
shift
=
true
;
}
else
{
console
.
error
(
"
Unsupported
modifier
:
"
mod
"
from
key
:
"
str
)
;
return
null
;
}
}
if
(
key
=
=
=
"
Plus
"
)
{
key
=
"
+
"
;
}
if
(
typeof
key
=
=
=
"
string
"
&
&
key
.
length
=
=
=
1
)
{
shortcut
.
key
=
key
.
toLowerCase
(
)
;
}
else
if
(
key
in
ElectronKeysMapping
)
{
key
=
ElectronKeysMapping
[
key
]
;
shortcut
.
keyCode
=
window
.
KeyboardEvent
[
key
]
;
shortcut
.
keyCodeString
=
key
;
}
else
{
console
.
error
(
"
Unsupported
key
:
"
key
)
;
return
null
;
}
return
shortcut
;
}
;
KeyShortcuts
.
stringify
=
function
(
shortcut
)
{
let
list
=
[
]
;
if
(
shortcut
.
alt
)
{
list
.
push
(
"
Alt
"
)
;
}
if
(
shortcut
.
ctrl
)
{
list
.
push
(
"
Ctrl
"
)
;
}
if
(
shortcut
.
meta
)
{
list
.
push
(
"
Cmd
"
)
;
}
if
(
shortcut
.
shift
)
{
list
.
push
(
"
Shift
"
)
;
}
let
key
;
if
(
shortcut
.
key
)
{
key
=
shortcut
.
key
.
toUpperCase
(
)
;
}
else
{
key
=
shortcut
.
keyCodeString
;
}
list
.
push
(
key
)
;
return
list
.
join
(
"
+
"
)
;
}
;
KeyShortcuts
.
prototype
=
{
destroy
(
)
{
this
.
target
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
keys
.
clear
(
)
;
}
doesEventMatchShortcut
(
event
shortcut
)
{
if
(
shortcut
.
meta
!
=
event
.
metaKey
)
{
return
false
;
}
if
(
shortcut
.
ctrl
!
=
event
.
ctrlKey
)
{
return
false
;
}
if
(
shortcut
.
alt
!
=
event
.
altKey
)
{
return
false
;
}
if
(
shortcut
.
shift
!
=
event
.
shiftKey
&
&
event
.
key
&
&
event
.
key
.
match
(
/
[
a
-
zA
-
Z
]
/
)
)
{
return
false
;
}
if
(
shortcut
.
keyCode
)
{
return
event
.
keyCode
=
=
shortcut
.
keyCode
;
}
return
event
.
key
.
toLowerCase
(
)
=
=
shortcut
.
key
|
|
(
shortcut
.
key
.
match
(
/
[
0
-
9
]
/
)
&
&
event
.
keyCode
=
=
shortcut
.
key
.
charCodeAt
(
0
)
)
;
}
handleEvent
(
event
)
{
for
(
let
[
key
shortcut
]
of
this
.
keys
)
{
if
(
this
.
doesEventMatchShortcut
(
event
shortcut
)
)
{
this
.
eventEmitter
.
emit
(
key
event
)
;
}
}
}
on
(
key
listener
)
{
if
(
typeof
listener
!
=
=
"
function
"
)
{
throw
new
Error
(
"
KeyShortcuts
.
on
(
)
expects
a
function
as
"
+
"
second
argument
"
)
;
}
if
(
!
this
.
keys
.
has
(
key
)
)
{
let
shortcut
=
KeyShortcuts
.
parseElectronKey
(
this
.
window
key
)
;
if
(
!
shortcut
)
{
return
;
}
this
.
keys
.
set
(
key
shortcut
)
;
}
this
.
eventEmitter
.
on
(
key
listener
)
;
}
off
(
key
listener
)
{
this
.
eventEmitter
.
off
(
key
listener
)
;
}
}
;
exports
.
KeyShortcuts
=
KeyShortcuts
;
}
function
(
module
exports
)
{
"
use
strict
"
;
const
PREF_INVALID
=
0
;
const
PREF_STRING
=
32
;
const
PREF_INT
=
64
;
const
PREF_BOOL
=
128
;
const
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
=
"
nsPref
:
changed
"
;
function
Preference
(
branch
name
fullName
)
{
this
.
branch
=
branch
;
this
.
name
=
name
;
this
.
fullName
=
fullName
;
this
.
defaultValue
=
null
;
this
.
hasUserValue
=
false
;
this
.
userValue
=
null
;
this
.
type
=
null
;
}
Preference
.
prototype
=
{
get
:
function
(
)
{
if
(
this
.
hasUserValue
)
{
return
this
.
userValue
;
}
return
this
.
defaultValue
;
}
set
:
function
(
value
)
{
if
(
!
this
.
hasUserValue
|
|
value
!
=
=
this
.
userValue
)
{
this
.
userValue
=
value
;
this
.
hasUserValue
=
true
;
this
.
saveAndNotify
(
)
;
}
}
setDefault
:
function
(
value
)
{
if
(
this
.
defaultValue
!
=
=
value
)
{
this
.
defaultValue
=
value
;
if
(
!
this
.
hasUserValue
)
{
this
.
saveAndNotify
(
)
;
}
}
}
clearUserValue
:
function
(
)
{
if
(
this
.
hasUserValue
)
{
this
.
userValue
=
null
;
this
.
hasUserValue
=
false
;
this
.
saveAndNotify
(
)
;
}
}
saveAndNotify
:
function
(
)
{
let
store
=
{
type
:
this
.
type
defaultValue
:
this
.
defaultValue
hasUserValue
:
this
.
hasUserValue
userValue
:
this
.
userValue
}
;
localStorage
.
setItem
(
this
.
fullName
JSON
.
stringify
(
store
)
)
;
this
.
branch
.
_notify
(
this
.
name
)
;
}
storageUpdated
:
function
(
type
userValue
hasUserValue
defaultValue
)
{
this
.
type
=
type
;
this
.
defaultValue
=
defaultValue
;
this
.
hasUserValue
=
hasUserValue
;
this
.
userValue
=
userValue
;
this
.
branch
.
_notify
(
this
.
name
)
;
}
}
;
function
PrefBranch
(
parent
name
fullName
)
{
this
.
_parent
=
parent
;
this
.
_name
=
name
;
this
.
_fullName
=
fullName
;
this
.
_observers
=
{
}
;
this
.
_children
=
{
}
;
if
(
!
parent
)
{
this
.
_initializeRoot
(
)
;
}
}
PrefBranch
.
prototype
=
{
PREF_INVALID
:
PREF_INVALID
PREF_STRING
:
PREF_STRING
PREF_INT
:
PREF_INT
PREF_BOOL
:
PREF_BOOL
get
root
(
)
{
return
this
.
_fullName
;
}
getPrefType
:
function
(
prefName
)
{
return
this
.
_findPref
(
prefName
)
.
type
;
}
getBoolPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
type
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
{
prefName
}
does
not
have
bool
type
)
;
}
return
thePref
.
get
(
)
;
}
setBoolPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
non
-
bool
passed
to
setBoolPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
type
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
{
prefName
}
does
not
have
bool
type
)
;
}
thePref
.
set
(
value
)
;
}
getCharPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
type
!
=
=
PREF_STRING
)
{
throw
new
Error
(
{
prefName
}
does
not
have
string
type
)
;
}
return
thePref
.
get
(
)
;
}
setCharPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
string
"
)
{
throw
new
Error
(
"
non
-
string
passed
to
setCharPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
type
!
=
=
PREF_STRING
)
{
throw
new
Error
(
{
prefName
}
does
not
have
string
type
)
;
}
thePref
.
set
(
value
)
;
}
getIntPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
type
!
=
=
PREF_INT
)
{
throw
new
Error
(
{
prefName
}
does
not
have
int
type
)
;
}
return
thePref
.
get
(
)
;
}
setIntPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
number
"
)
{
throw
new
Error
(
"
non
-
number
passed
to
setIntPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
type
!
=
=
PREF_INT
)
{
throw
new
Error
(
{
prefName
}
does
not
have
int
type
)
;
}
thePref
.
set
(
value
)
;
}
clearUserPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
thePref
.
clearUserValue
(
)
;
}
prefHasUserValue
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
return
thePref
.
hasUserValue
;
}
addObserver
:
function
(
domain
observer
holdWeak
)
{
if
(
domain
!
=
=
"
"
&
&
!
domain
.
endsWith
(
"
.
"
)
)
{
throw
new
Error
(
"
invalid
domain
to
addObserver
:
"
+
domain
)
;
}
if
(
holdWeak
)
{
throw
new
Error
(
"
shim
prefs
only
supports
strong
observers
"
)
;
}
if
(
!
(
domain
in
this
.
_observers
)
)
{
this
.
_observers
[
domain
]
=
[
]
;
}
this
.
_observers
[
domain
]
.
push
(
observer
)
;
}
removeObserver
:
function
(
domain
observer
)
{
if
(
!
(
domain
in
this
.
_observers
)
)
{
return
;
}
let
index
=
this
.
_observers
[
domain
]
.
indexOf
(
observer
)
;
if
(
index
>
=
0
)
{
this
.
_observers
[
domain
]
.
splice
(
index
1
)
;
}
}
savePrefFile
:
function
(
file
)
{
if
(
file
)
{
throw
new
Error
(
"
shim
prefs
only
supports
null
file
in
savePrefFile
"
)
;
}
}
getBranch
:
function
(
prefRoot
)
{
if
(
!
prefRoot
)
{
return
this
;
}
if
(
prefRoot
.
endsWith
(
"
.
"
)
)
{
prefRoot
=
prefRoot
.
slice
(
0
-
1
)
;
}
return
this
.
_findPref
(
prefRoot
)
;
}
_findPref
:
function
(
prefName
)
{
let
branchNames
=
prefName
.
split
(
"
.
"
)
;
let
branch
=
this
;
for
(
let
branchName
of
branchNames
)
{
branch
=
branch
.
_children
[
branchName
]
;
if
(
!
branch
)
{
throw
new
Error
(
"
could
not
find
pref
branch
"
+
prefName
)
;
}
}
return
branch
;
}
_notify
:
function
(
relativeName
)
{
for
(
let
domain
in
this
.
_observers
)
{
if
(
relativeName
.
startsWith
(
domain
)
)
{
let
localList
=
this
.
_observers
[
domain
]
.
slice
(
)
;
for
(
let
observer
of
localList
)
{
try
{
observer
.
observe
(
this
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
relativeName
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
}
}
if
(
this
.
_parent
)
{
this
.
_parent
.
_notify
(
this
.
_name
+
"
.
"
+
relativeName
)
;
}
}
_createBranch
:
function
(
branchList
)
{
let
parent
=
this
;
for
(
let
branch
of
branchList
)
{
if
(
!
parent
.
_children
[
branch
]
)
{
parent
.
_children
[
branch
]
=
new
PrefBranch
(
parent
branch
parent
.
root
+
"
.
"
+
branch
)
;
}
parent
=
parent
.
_children
[
branch
]
;
}
return
parent
;
}
_findOrCreatePref
:
function
(
keyName
userValue
hasUserValue
defaultValue
)
{
let
branchName
=
keyName
.
split
(
"
.
"
)
;
let
prefName
=
branchName
.
pop
(
)
;
let
branch
=
this
.
_createBranch
(
branchName
)
;
if
(
!
(
prefName
in
branch
.
_children
)
)
{
if
(
hasUserValue
&
&
typeof
(
userValue
)
!
=
=
typeof
(
defaultValue
)
)
{
throw
new
Error
(
"
inconsistent
values
when
creating
"
+
keyName
)
;
}
let
type
;
switch
(
typeof
(
defaultValue
)
)
{
case
"
boolean
"
:
type
=
PREF_BOOL
;
break
;
case
"
number
"
:
type
=
PREF_INT
;
break
;
case
"
string
"
:
type
=
PREF_STRING
;
break
;
default
:
throw
new
Error
(
"
unhandled
argument
type
:
"
+
typeof
(
defaultValue
)
)
;
}
let
thePref
=
new
Preference
(
branch
prefName
keyName
)
;
thePref
.
storageUpdated
(
type
userValue
hasUserValue
defaultValue
)
;
branch
.
_children
[
prefName
]
=
thePref
;
}
return
branch
.
_children
[
prefName
]
;
}
_onStorageChange
:
function
(
event
)
{
if
(
event
.
storageArea
!
=
=
localStorage
)
{
return
;
}
if
(
event
.
key
=
=
=
null
|
|
event
.
newValue
=
=
=
null
)
{
return
;
}
let
{
type
userValue
hasUserValue
defaultValue
}
=
JSON
.
parse
(
event
.
newValue
)
;
if
(
event
.
oldValue
=
=
=
null
)
{
this
.
_findOrCreatePref
(
event
.
key
userValue
hasUserValue
defaultValue
)
;
}
else
{
let
thePref
=
this
.
_findPref
(
event
.
key
)
;
thePref
.
storageUpdated
(
type
userValue
hasUserValue
defaultValue
)
;
}
}
_initializeRoot
:
function
(
)
{
try
{
if
(
localStorage
.
length
=
=
=
0
)
{
}
}
catch
(
e
)
{
return
;
}
for
(
let
i
=
0
;
i
<
localStorage
.
length
;
+
+
i
)
{
let
keyName
=
localStorage
.
key
(
i
)
;
try
{
let
{
userValue
hasUserValue
defaultValue
}
=
JSON
.
parse
(
localStorage
.
getItem
(
keyName
)
)
;
this
.
_findOrCreatePref
(
keyName
userValue
hasUserValue
defaultValue
)
;
}
catch
(
e
)
{
}
}
this
.
_onStorageChange
=
this
.
_onStorageChange
.
bind
(
this
)
;
window
.
addEventListener
(
"
storage
"
this
.
_onStorageChange
)
;
}
}
;
const
Services
=
{
prefs
:
new
PrefBranch
(
null
"
"
"
"
)
appinfo
:
{
get
OS
(
)
{
const
os
=
window
.
navigator
.
userAgent
;
if
(
os
)
{
if
(
os
.
includes
(
"
Linux
"
)
)
{
return
"
Linux
"
;
}
else
if
(
os
.
includes
(
"
Windows
"
)
)
{
return
"
WINNT
"
;
}
else
if
(
os
.
includes
(
"
Mac
"
)
)
{
return
"
Darwin
"
;
}
}
return
"
Unknown
"
;
}
get
name
(
)
{
return
window
.
navigator
.
userAgent
;
}
get
version
(
)
{
return
window
.
navigator
.
appVersion
;
}
get
is64Bit
(
)
{
return
true
;
}
}
telemetry
:
{
getHistogramById
:
function
(
name
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
getKeyedHistogramById
:
function
(
name
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
}
focus
:
{
MOVEFOCUS_FORWARD
:
1
MOVEFOCUS_BACKWARD
:
2
get
focusedElement
(
)
{
if
(
!
document
.
hasFocus
(
)
)
{
return
null
;
}
return
document
.
activeElement
;
}
moveFocus
:
function
(
window
startElement
type
flags
)
{
if
(
flags
!
=
=
0
)
{
throw
new
Error
(
"
shim
Services
.
focus
.
moveFocus
only
accepts
flags
=
=
=
0
"
)
;
}
if
(
type
!
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
&
&
type
!
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
throw
new
Error
(
"
shim
Services
.
focus
.
moveFocus
only
supports
"
+
"
MOVEFOCUS_FORWARD
and
MOVEFOCUS_BACKWARD
"
)
;
}
if
(
!
startElement
)
{
startElement
=
document
.
activeElement
|
|
document
;
}
let
iter
=
document
.
createTreeWalker
(
document
NodeFilter
.
SHOW_ELEMENT
{
acceptNode
:
function
(
node
)
{
let
tabIndex
=
node
.
getAttribute
(
"
tabindex
"
)
;
if
(
tabIndex
=
=
=
"
-
1
"
)
{
return
NodeFilter
.
FILTER_SKIP
;
}
node
.
focus
(
)
;
if
(
document
.
activeElement
=
=
node
)
{
return
NodeFilter
.
FILTER_ACCEPT
;
}
return
NodeFilter
.
FILTER_SKIP
;
}
}
)
;
iter
.
currentNode
=
startElement
;
if
(
type
=
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
iter
.
nextNode
(
)
;
}
else
{
iter
.
previousNode
(
)
;
}
}
}
}
;
function
pref
(
name
value
)
{
let
thePref
=
Services
.
prefs
.
_findOrCreatePref
(
name
value
true
value
)
;
thePref
.
setDefault
(
value
)
;
}
exports
.
Services
=
Services
;
exports
.
pref
=
pref
;
}
]
)
;
