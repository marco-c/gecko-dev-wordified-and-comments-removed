var
Debugger
=
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
exports
:
{
}
id
:
moduleId
loaded
:
false
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
p
=
"
/
public
/
build
"
;
return
__webpack_require__
(
0
)
;
}
)
(
[
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
1
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
combineReducers
=
_require
.
combineReducers
;
var
_require2
=
__webpack_require__
(
15
)
;
var
Provider
=
_require2
.
Provider
;
var
ReactDOM
=
__webpack_require__
(
25
)
;
var
React
=
__webpack_require__
(
17
)
;
var
DevToolsUtils
=
__webpack_require__
(
27
)
;
var
AppConstants
=
__webpack_require__
(
41
)
.
AppConstants
;
var
_require3
=
__webpack_require__
(
45
)
;
var
injectGlobals
=
_require3
.
injectGlobals
;
var
_require4
=
__webpack_require__
(
47
)
;
var
isEnabled
=
_require4
.
isEnabled
;
var
isFirefoxPanel
=
_require4
.
isFirefoxPanel
;
var
getValue
=
_require4
.
getValue
;
var
isDevelopment
=
_require4
.
isDevelopment
;
var
setConfig
=
_require4
.
setConfig
;
setConfig
(
(
{
"
environment
"
:
"
firefox
-
panel
"
"
baseWorkerURL
"
:
"
resource
:
/
/
devtools
/
client
/
debugger
/
new
/
"
"
logging
"
:
false
"
clientLogging
"
:
false
"
features
"
:
{
"
tabs
"
:
true
}
}
)
)
;
if
(
isEnabled
(
"
logging
.
client
"
)
)
{
DevToolsUtils
.
dumpn
.
wantLogging
=
true
;
}
var
_require5
=
__webpack_require__
(
96
)
;
var
getClient
=
_require5
.
getClient
;
var
connectClients
=
_require5
.
connectClients
;
var
startDebugging
=
_require5
.
startDebugging
;
var
firefox
=
__webpack_require__
(
98
)
;
var
configureStore
=
__webpack_require__
(
180
)
;
var
reducers
=
__webpack_require__
(
188
)
;
var
selectors
=
__webpack_require__
(
199
)
;
var
Tabs
=
__webpack_require__
(
206
)
;
var
App
=
__webpack_require__
(
212
)
;
var
createStore
=
configureStore
(
{
log
:
getValue
(
"
logging
.
actions
"
)
makeThunkArgs
:
(
args
state
)
=
>
{
return
Object
.
assign
(
{
}
args
{
client
:
getClient
(
state
)
}
)
;
}
}
)
;
var
store
=
createStore
(
combineReducers
(
reducers
)
)
;
var
actions
=
bindActionCreators
(
__webpack_require__
(
214
)
store
.
dispatch
)
;
if
(
isDevelopment
(
)
)
{
AppConstants
.
DEBUG_JS_MODULES
=
true
;
injectGlobals
(
{
store
}
)
;
}
window
.
actions
=
{
selectSource
:
actions
.
selectSource
selectSourceURL
:
actions
.
selectSourceURL
}
;
function
renderRoot
(
component
)
{
var
mount
=
document
.
querySelector
(
"
#
mount
"
)
;
if
(
!
mount
)
{
return
;
}
ReactDOM
.
render
(
React
.
createElement
(
Provider
{
store
}
React
.
createElement
(
component
)
)
mount
)
;
}
function
unmountRoot
(
)
{
var
mount
=
document
.
querySelector
(
"
#
mount
"
)
;
ReactDOM
.
unmountComponentAtNode
(
mount
)
;
}
function
getTargetFromQuery
(
)
{
var
href
=
window
.
location
.
href
;
var
nodeMatch
=
href
.
match
(
/
ws
=
(
[
^
&
#
]
*
)
/
)
;
var
firefoxMatch
=
href
.
match
(
/
firefox
-
tab
=
(
[
^
&
#
]
*
)
/
)
;
var
chromeMatch
=
href
.
match
(
/
chrome
-
tab
=
(
[
^
&
#
]
*
)
/
)
;
if
(
nodeMatch
)
{
return
{
type
:
"
node
"
param
:
nodeMatch
[
1
]
}
;
}
else
if
(
firefoxMatch
)
{
return
{
type
:
"
firefox
"
param
:
firefoxMatch
[
1
]
}
;
}
else
if
(
chromeMatch
)
{
return
{
type
:
"
chrome
"
param
:
chromeMatch
[
1
]
}
;
}
return
null
;
}
var
connTarget
=
getTargetFromQuery
(
)
;
if
(
connTarget
)
{
startDebugging
(
connTarget
actions
)
.
then
(
tabs
=
>
{
actions
.
newTabs
(
tabs
)
;
actions
.
selectTab
(
{
id
:
connTarget
.
param
}
)
;
renderRoot
(
App
)
;
}
)
;
}
else
if
(
isFirefoxPanel
(
)
)
{
(
function
(
)
{
var
sourceMap
=
__webpack_require__
(
216
)
;
module
.
exports
=
{
bootstrap
:
_ref
=
>
{
var
threadClient
=
_ref
.
threadClient
;
var
tabTarget
=
_ref
.
tabTarget
;
firefox
.
setThreadClient
(
threadClient
)
;
firefox
.
setTabTarget
(
tabTarget
)
;
renderRoot
(
App
)
;
return
firefox
.
initPage
(
actions
)
;
}
destroy
:
(
)
=
>
{
unmountRoot
(
)
;
sourceMap
.
destroy
(
)
;
}
store
:
store
actions
:
actions
selectors
:
selectors
client
:
firefox
.
clientCommands
}
;
}
)
(
)
;
}
else
{
renderRoot
(
Tabs
)
;
connectClients
(
)
.
then
(
tabs
=
>
{
actions
.
newTabs
(
tabs
)
;
}
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
compose
=
exports
.
applyMiddleware
=
exports
.
bindActionCreators
=
exports
.
combineReducers
=
exports
.
createStore
=
undefined
;
var
_createStore
=
__webpack_require__
(
3
)
;
var
_createStore2
=
_interopRequireDefault
(
_createStore
)
;
var
_combineReducers
=
__webpack_require__
(
10
)
;
var
_combineReducers2
=
_interopRequireDefault
(
_combineReducers
)
;
var
_bindActionCreators
=
__webpack_require__
(
12
)
;
var
_bindActionCreators2
=
_interopRequireDefault
(
_bindActionCreators
)
;
var
_applyMiddleware
=
__webpack_require__
(
13
)
;
var
_applyMiddleware2
=
_interopRequireDefault
(
_applyMiddleware
)
;
var
_compose
=
__webpack_require__
(
14
)
;
var
_compose2
=
_interopRequireDefault
(
_compose
)
;
var
_warning
=
__webpack_require__
(
11
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
isCrushed
(
)
{
}
if
(
false
)
{
(
0
_warning2
[
"
default
"
]
)
(
'
You
are
currently
using
minified
code
outside
of
NODE_ENV
=
=
=
\
'
production
\
'
.
'
+
'
This
means
that
you
are
running
a
slower
development
build
of
Redux
.
'
+
'
You
can
use
loose
-
envify
(
https
:
/
/
github
.
com
/
zertosh
/
loose
-
envify
)
for
browserify
'
+
'
or
DefinePlugin
for
webpack
(
http
:
/
/
stackoverflow
.
com
/
questions
/
30030031
)
'
+
'
to
ensure
you
have
the
correct
code
for
your
production
build
.
'
)
;
}
exports
.
createStore
=
_createStore2
[
"
default
"
]
;
exports
.
combineReducers
=
_combineReducers2
[
"
default
"
]
;
exports
.
bindActionCreators
=
_bindActionCreators2
[
"
default
"
]
;
exports
.
applyMiddleware
=
_applyMiddleware2
[
"
default
"
]
;
exports
.
compose
=
_compose2
[
"
default
"
]
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
ActionTypes
=
undefined
;
exports
[
"
default
"
]
=
createStore
;
var
_isPlainObject
=
__webpack_require__
(
4
)
;
var
_isPlainObject2
=
_interopRequireDefault
(
_isPlainObject
)
;
var
_symbolObservable
=
__webpack_require__
(
8
)
;
var
_symbolObservable2
=
_interopRequireDefault
(
_symbolObservable
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
var
ActionTypes
=
exports
.
ActionTypes
=
{
INIT
:
'
redux
/
INIT
'
}
;
function
createStore
(
reducer
initialState
enhancer
)
{
var
_ref2
;
if
(
typeof
initialState
=
=
=
'
function
'
&
&
typeof
enhancer
=
=
=
'
undefined
'
)
{
enhancer
=
initialState
;
initialState
=
undefined
;
}
if
(
typeof
enhancer
!
=
=
'
undefined
'
)
{
if
(
typeof
enhancer
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
the
enhancer
to
be
a
function
.
'
)
;
}
return
enhancer
(
createStore
)
(
reducer
initialState
)
;
}
if
(
typeof
reducer
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
the
reducer
to
be
a
function
.
'
)
;
}
var
currentReducer
=
reducer
;
var
currentState
=
initialState
;
var
currentListeners
=
[
]
;
var
nextListeners
=
currentListeners
;
var
isDispatching
=
false
;
function
ensureCanMutateNextListeners
(
)
{
if
(
nextListeners
=
=
=
currentListeners
)
{
nextListeners
=
currentListeners
.
slice
(
)
;
}
}
function
getState
(
)
{
return
currentState
;
}
function
subscribe
(
listener
)
{
if
(
typeof
listener
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
listener
to
be
a
function
.
'
)
;
}
var
isSubscribed
=
true
;
ensureCanMutateNextListeners
(
)
;
nextListeners
.
push
(
listener
)
;
return
function
unsubscribe
(
)
{
if
(
!
isSubscribed
)
{
return
;
}
isSubscribed
=
false
;
ensureCanMutateNextListeners
(
)
;
var
index
=
nextListeners
.
indexOf
(
listener
)
;
nextListeners
.
splice
(
index
1
)
;
}
;
}
function
dispatch
(
action
)
{
if
(
!
(
0
_isPlainObject2
[
"
default
"
]
)
(
action
)
)
{
throw
new
Error
(
'
Actions
must
be
plain
objects
.
'
+
'
Use
custom
middleware
for
async
actions
.
'
)
;
}
if
(
typeof
action
.
type
=
=
=
'
undefined
'
)
{
throw
new
Error
(
'
Actions
may
not
have
an
undefined
"
type
"
property
.
'
+
'
Have
you
misspelled
a
constant
?
'
)
;
}
if
(
isDispatching
)
{
throw
new
Error
(
'
Reducers
may
not
dispatch
actions
.
'
)
;
}
try
{
isDispatching
=
true
;
currentState
=
currentReducer
(
currentState
action
)
;
}
finally
{
isDispatching
=
false
;
}
var
listeners
=
currentListeners
=
nextListeners
;
for
(
var
i
=
0
;
i
<
listeners
.
length
;
i
+
+
)
{
listeners
[
i
]
(
)
;
}
return
action
;
}
function
replaceReducer
(
nextReducer
)
{
if
(
typeof
nextReducer
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Expected
the
nextReducer
to
be
a
function
.
'
)
;
}
currentReducer
=
nextReducer
;
dispatch
(
{
type
:
ActionTypes
.
INIT
}
)
;
}
function
observable
(
)
{
var
_ref
;
var
outerSubscribe
=
subscribe
;
return
_ref
=
{
subscribe
:
function
subscribe
(
observer
)
{
if
(
typeof
observer
!
=
=
'
object
'
)
{
throw
new
TypeError
(
'
Expected
the
observer
to
be
an
object
.
'
)
;
}
function
observeState
(
)
{
if
(
observer
.
next
)
{
observer
.
next
(
getState
(
)
)
;
}
}
observeState
(
)
;
var
unsubscribe
=
outerSubscribe
(
observeState
)
;
return
{
unsubscribe
:
unsubscribe
}
;
}
}
_ref
[
_symbolObservable2
[
"
default
"
]
]
=
function
(
)
{
return
this
;
}
_ref
;
}
dispatch
(
{
type
:
ActionTypes
.
INIT
}
)
;
return
_ref2
=
{
dispatch
:
dispatch
subscribe
:
subscribe
getState
:
getState
replaceReducer
:
replaceReducer
}
_ref2
[
_symbolObservable2
[
"
default
"
]
]
=
observable
_ref2
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
getPrototype
=
__webpack_require__
(
5
)
isHostObject
=
__webpack_require__
(
6
)
isObjectLike
=
__webpack_require__
(
7
)
;
var
objectTag
=
'
[
object
Object
]
'
;
var
objectProto
=
Object
.
prototype
;
var
funcToString
=
Function
.
prototype
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
objectCtorString
=
funcToString
.
call
(
Object
)
;
var
objectToString
=
objectProto
.
toString
;
function
isPlainObject
(
value
)
{
if
(
!
isObjectLike
(
value
)
|
|
objectToString
.
call
(
value
)
!
=
objectTag
|
|
isHostObject
(
value
)
)
{
return
false
;
}
var
proto
=
getPrototype
(
value
)
;
if
(
proto
=
=
=
null
)
{
return
true
;
}
var
Ctor
=
hasOwnProperty
.
call
(
proto
'
constructor
'
)
&
&
proto
.
constructor
;
return
(
typeof
Ctor
=
=
'
function
'
&
&
Ctor
instanceof
Ctor
&
&
funcToString
.
call
(
Ctor
)
=
=
objectCtorString
)
;
}
module
.
exports
=
isPlainObject
;
}
function
(
module
exports
)
{
var
nativeGetPrototype
=
Object
.
getPrototypeOf
;
function
getPrototype
(
value
)
{
return
nativeGetPrototype
(
Object
(
value
)
)
;
}
module
.
exports
=
getPrototype
;
}
function
(
module
exports
)
{
function
isHostObject
(
value
)
{
var
result
=
false
;
if
(
value
!
=
null
&
&
typeof
value
.
toString
!
=
'
function
'
)
{
try
{
result
=
!
!
(
value
+
'
'
)
;
}
catch
(
e
)
{
}
}
return
result
;
}
module
.
exports
=
isHostObject
;
}
function
(
module
exports
)
{
function
isObjectLike
(
value
)
{
return
!
!
value
&
&
typeof
value
=
=
'
object
'
;
}
module
.
exports
=
isObjectLike
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
)
{
'
use
strict
'
;
module
.
exports
=
__webpack_require__
(
9
)
(
global
|
|
window
|
|
this
)
;
}
.
call
(
exports
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
function
symbolObservablePonyfill
(
root
)
{
var
result
;
var
Symbol
=
root
.
Symbol
;
if
(
typeof
Symbol
=
=
=
'
function
'
)
{
if
(
Symbol
.
observable
)
{
result
=
Symbol
.
observable
;
}
else
{
result
=
Symbol
(
'
observable
'
)
;
Symbol
.
observable
=
result
;
}
}
else
{
result
=
'
observable
'
;
}
return
result
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
combineReducers
;
var
_createStore
=
__webpack_require__
(
3
)
;
var
_isPlainObject
=
__webpack_require__
(
4
)
;
var
_isPlainObject2
=
_interopRequireDefault
(
_isPlainObject
)
;
var
_warning
=
__webpack_require__
(
11
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
getUndefinedStateErrorMessage
(
key
action
)
{
var
actionType
=
action
&
&
action
.
type
;
var
actionName
=
actionType
&
&
'
"
'
+
actionType
.
toString
(
)
+
'
"
'
|
|
'
an
action
'
;
return
'
Given
action
'
+
actionName
+
'
reducer
"
'
+
key
+
'
"
returned
undefined
.
'
+
'
To
ignore
an
action
you
must
explicitly
return
the
previous
state
.
'
;
}
function
getUnexpectedStateShapeWarningMessage
(
inputState
reducers
action
)
{
var
reducerKeys
=
Object
.
keys
(
reducers
)
;
var
argumentName
=
action
&
&
action
.
type
=
=
=
_createStore
.
ActionTypes
.
INIT
?
'
initialState
argument
passed
to
createStore
'
:
'
previous
state
received
by
the
reducer
'
;
if
(
reducerKeys
.
length
=
=
=
0
)
{
return
'
Store
does
not
have
a
valid
reducer
.
Make
sure
the
argument
passed
'
+
'
to
combineReducers
is
an
object
whose
values
are
reducers
.
'
;
}
if
(
!
(
0
_isPlainObject2
[
"
default
"
]
)
(
inputState
)
)
{
return
'
The
'
+
argumentName
+
'
has
unexpected
type
of
"
'
+
{
}
.
toString
.
call
(
inputState
)
.
match
(
/
\
s
(
[
a
-
z
|
A
-
Z
]
+
)
/
)
[
1
]
+
'
"
.
Expected
argument
to
be
an
object
with
the
following
'
+
(
'
keys
:
"
'
+
reducerKeys
.
join
(
'
"
"
'
)
+
'
"
'
)
;
}
var
unexpectedKeys
=
Object
.
keys
(
inputState
)
.
filter
(
function
(
key
)
{
return
!
reducers
.
hasOwnProperty
(
key
)
;
}
)
;
if
(
unexpectedKeys
.
length
>
0
)
{
return
'
Unexpected
'
+
(
unexpectedKeys
.
length
>
1
?
'
keys
'
:
'
key
'
)
+
'
'
+
(
'
"
'
+
unexpectedKeys
.
join
(
'
"
"
'
)
+
'
"
found
in
'
+
argumentName
+
'
.
'
)
+
'
Expected
to
find
one
of
the
known
reducer
keys
instead
:
'
+
(
'
"
'
+
reducerKeys
.
join
(
'
"
"
'
)
+
'
"
.
Unexpected
keys
will
be
ignored
.
'
)
;
}
}
function
assertReducerSanity
(
reducers
)
{
Object
.
keys
(
reducers
)
.
forEach
(
function
(
key
)
{
var
reducer
=
reducers
[
key
]
;
var
initialState
=
reducer
(
undefined
{
type
:
_createStore
.
ActionTypes
.
INIT
}
)
;
if
(
typeof
initialState
=
=
=
'
undefined
'
)
{
throw
new
Error
(
'
Reducer
"
'
+
key
+
'
"
returned
undefined
during
initialization
.
'
+
'
If
the
state
passed
to
the
reducer
is
undefined
you
must
'
+
'
explicitly
return
the
initial
state
.
The
initial
state
may
'
+
'
not
be
undefined
.
'
)
;
}
var
type
=
'
redux
/
PROBE_UNKNOWN_ACTION_
'
+
Math
.
random
(
)
.
toString
(
36
)
.
substring
(
7
)
.
split
(
'
'
)
.
join
(
'
.
'
)
;
if
(
typeof
reducer
(
undefined
{
type
:
type
}
)
=
=
=
'
undefined
'
)
{
throw
new
Error
(
'
Reducer
"
'
+
key
+
'
"
returned
undefined
when
probed
with
a
random
type
.
'
+
(
'
Don
\
'
t
try
to
handle
'
+
_createStore
.
ActionTypes
.
INIT
+
'
or
other
actions
in
"
redux
/
*
"
'
)
+
'
namespace
.
They
are
considered
private
.
Instead
you
must
return
the
'
+
'
current
state
for
any
unknown
actions
unless
it
is
undefined
'
+
'
in
which
case
you
must
return
the
initial
state
regardless
of
the
'
+
'
action
type
.
The
initial
state
may
not
be
undefined
.
'
)
;
}
}
)
;
}
function
combineReducers
(
reducers
)
{
var
reducerKeys
=
Object
.
keys
(
reducers
)
;
var
finalReducers
=
{
}
;
for
(
var
i
=
0
;
i
<
reducerKeys
.
length
;
i
+
+
)
{
var
key
=
reducerKeys
[
i
]
;
if
(
typeof
reducers
[
key
]
=
=
=
'
function
'
)
{
finalReducers
[
key
]
=
reducers
[
key
]
;
}
}
var
finalReducerKeys
=
Object
.
keys
(
finalReducers
)
;
var
sanityError
;
try
{
assertReducerSanity
(
finalReducers
)
;
}
catch
(
e
)
{
sanityError
=
e
;
}
return
function
combination
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
if
(
sanityError
)
{
throw
sanityError
;
}
if
(
false
)
{
var
warningMessage
=
getUnexpectedStateShapeWarningMessage
(
state
finalReducers
action
)
;
if
(
warningMessage
)
{
(
0
_warning2
[
"
default
"
]
)
(
warningMessage
)
;
}
}
var
hasChanged
=
false
;
var
nextState
=
{
}
;
for
(
var
i
=
0
;
i
<
finalReducerKeys
.
length
;
i
+
+
)
{
var
key
=
finalReducerKeys
[
i
]
;
var
reducer
=
finalReducers
[
key
]
;
var
previousStateForKey
=
state
[
key
]
;
var
nextStateForKey
=
reducer
(
previousStateForKey
action
)
;
if
(
typeof
nextStateForKey
=
=
=
'
undefined
'
)
{
var
errorMessage
=
getUndefinedStateErrorMessage
(
key
action
)
;
throw
new
Error
(
errorMessage
)
;
}
nextState
[
key
]
=
nextStateForKey
;
hasChanged
=
hasChanged
|
|
nextStateForKey
!
=
=
previousStateForKey
;
}
return
hasChanged
?
nextState
:
state
;
}
;
}
}
function
(
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
warning
;
function
warning
(
message
)
{
if
(
typeof
console
!
=
=
'
undefined
'
&
&
typeof
console
.
error
=
=
=
'
function
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
e
)
{
}
}
}
function
(
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
bindActionCreators
;
function
bindActionCreator
(
actionCreator
dispatch
)
{
return
function
(
)
{
return
dispatch
(
actionCreator
.
apply
(
undefined
arguments
)
)
;
}
;
}
function
bindActionCreators
(
actionCreators
dispatch
)
{
if
(
typeof
actionCreators
=
=
=
'
function
'
)
{
return
bindActionCreator
(
actionCreators
dispatch
)
;
}
if
(
typeof
actionCreators
!
=
=
'
object
'
|
|
actionCreators
=
=
=
null
)
{
throw
new
Error
(
'
bindActionCreators
expected
an
object
or
a
function
instead
received
'
+
(
actionCreators
=
=
=
null
?
'
null
'
:
typeof
actionCreators
)
+
'
.
'
+
'
Did
you
write
"
import
ActionCreators
from
"
instead
of
"
import
*
as
ActionCreators
from
"
?
'
)
;
}
var
keys
=
Object
.
keys
(
actionCreators
)
;
var
boundActionCreators
=
{
}
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
actionCreator
=
actionCreators
[
key
]
;
if
(
typeof
actionCreator
=
=
=
'
function
'
)
{
boundActionCreators
[
key
]
=
bindActionCreator
(
actionCreator
dispatch
)
;
}
}
return
boundActionCreators
;
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
exports
[
"
default
"
]
=
applyMiddleware
;
var
_compose
=
__webpack_require__
(
14
)
;
var
_compose2
=
_interopRequireDefault
(
_compose
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
applyMiddleware
(
)
{
for
(
var
_len
=
arguments
.
length
middlewares
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
middlewares
[
_key
]
=
arguments
[
_key
]
;
}
return
function
(
createStore
)
{
return
function
(
reducer
initialState
enhancer
)
{
var
store
=
createStore
(
reducer
initialState
enhancer
)
;
var
_dispatch
=
store
.
dispatch
;
var
chain
=
[
]
;
var
middlewareAPI
=
{
getState
:
store
.
getState
dispatch
:
function
dispatch
(
action
)
{
return
_dispatch
(
action
)
;
}
}
;
chain
=
middlewares
.
map
(
function
(
middleware
)
{
return
middleware
(
middlewareAPI
)
;
}
)
;
_dispatch
=
_compose2
[
"
default
"
]
.
apply
(
undefined
chain
)
(
store
.
dispatch
)
;
return
_extends
(
{
}
store
{
dispatch
:
_dispatch
}
)
;
}
;
}
;
}
}
function
(
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
compose
;
function
compose
(
)
{
for
(
var
_len
=
arguments
.
length
funcs
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
funcs
[
_key
]
=
arguments
[
_key
]
;
}
if
(
funcs
.
length
=
=
=
0
)
{
return
function
(
arg
)
{
return
arg
;
}
;
}
else
{
var
_ret
=
function
(
)
{
var
last
=
funcs
[
funcs
.
length
-
1
]
;
var
rest
=
funcs
.
slice
(
0
-
1
)
;
return
{
v
:
function
v
(
)
{
return
rest
.
reduceRight
(
function
(
composed
f
)
{
return
f
(
composed
)
;
}
last
.
apply
(
undefined
arguments
)
)
;
}
}
;
}
(
)
;
if
(
typeof
_ret
=
=
=
"
object
"
)
return
_ret
.
v
;
}
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
connect
=
exports
.
Provider
=
undefined
;
var
_Provider
=
__webpack_require__
(
16
)
;
var
_Provider2
=
_interopRequireDefault
(
_Provider
)
;
var
_connect
=
__webpack_require__
(
20
)
;
var
_connect2
=
_interopRequireDefault
(
_connect
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
exports
.
Provider
=
_Provider2
[
"
default
"
]
;
exports
.
connect
=
_connect2
[
"
default
"
]
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
undefined
;
var
_react
=
__webpack_require__
(
17
)
;
var
_storeShape
=
__webpack_require__
(
18
)
;
var
_storeShape2
=
_interopRequireDefault
(
_storeShape
)
;
var
_warning
=
__webpack_require__
(
19
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
didWarnAboutReceivingStore
=
false
;
function
warnAboutReceivingStore
(
)
{
if
(
didWarnAboutReceivingStore
)
{
return
;
}
didWarnAboutReceivingStore
=
true
;
(
0
_warning2
[
"
default
"
]
)
(
'
<
Provider
>
does
not
support
changing
store
on
the
fly
.
'
+
'
It
is
most
likely
that
you
see
this
error
because
you
updated
to
'
+
'
Redux
2
.
x
and
React
Redux
2
.
x
which
no
longer
hot
reload
reducers
'
+
'
automatically
.
See
https
:
/
/
github
.
com
/
reactjs
/
react
-
redux
/
releases
/
'
+
'
tag
/
v2
.
0
.
0
for
the
migration
instructions
.
'
)
;
}
var
Provider
=
function
(
_Component
)
{
_inherits
(
Provider
_Component
)
;
Provider
.
prototype
.
getChildContext
=
function
getChildContext
(
)
{
return
{
store
:
this
.
store
}
;
}
;
function
Provider
(
props
context
)
{
_classCallCheck
(
this
Provider
)
;
var
_this
=
_possibleConstructorReturn
(
this
_Component
.
call
(
this
props
context
)
)
;
_this
.
store
=
props
.
store
;
return
_this
;
}
Provider
.
prototype
.
render
=
function
render
(
)
{
var
children
=
this
.
props
.
children
;
return
_react
.
Children
.
only
(
children
)
;
}
;
return
Provider
;
}
(
_react
.
Component
)
;
exports
[
"
default
"
]
=
Provider
;
if
(
false
)
{
Provider
.
prototype
.
componentWillReceiveProps
=
function
(
nextProps
)
{
var
store
=
this
.
store
;
var
nextStore
=
nextProps
.
store
;
if
(
store
!
=
=
nextStore
)
{
warnAboutReceivingStore
(
)
;
}
}
;
}
Provider
.
propTypes
=
{
store
:
_storeShape2
[
"
default
"
]
.
isRequired
children
:
_react
.
PropTypes
.
element
.
isRequired
}
;
Provider
.
childContextTypes
=
{
store
:
_storeShape2
[
"
default
"
]
.
isRequired
}
;
}
function
(
module
exports
)
{
module
.
exports
=
devtoolsRequire
(
'
devtools
/
client
/
shared
/
vendor
/
react
'
)
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
var
_react
=
__webpack_require__
(
17
)
;
exports
[
"
default
"
]
=
_react
.
PropTypes
.
shape
(
{
subscribe
:
_react
.
PropTypes
.
func
.
isRequired
dispatch
:
_react
.
PropTypes
.
func
.
isRequired
getState
:
_react
.
PropTypes
.
func
.
isRequired
}
)
;
}
function
(
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
warning
;
function
warning
(
message
)
{
if
(
typeof
console
!
=
=
'
undefined
'
&
&
typeof
console
.
error
=
=
=
'
function
'
)
{
console
.
error
(
message
)
;
}
try
{
throw
new
Error
(
message
)
;
}
catch
(
e
)
{
}
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
connect
;
var
_react
=
__webpack_require__
(
17
)
;
var
_storeShape
=
__webpack_require__
(
18
)
;
var
_storeShape2
=
_interopRequireDefault
(
_storeShape
)
;
var
_shallowEqual
=
__webpack_require__
(
21
)
;
var
_shallowEqual2
=
_interopRequireDefault
(
_shallowEqual
)
;
var
_wrapActionCreators
=
__webpack_require__
(
22
)
;
var
_wrapActionCreators2
=
_interopRequireDefault
(
_wrapActionCreators
)
;
var
_warning
=
__webpack_require__
(
19
)
;
var
_warning2
=
_interopRequireDefault
(
_warning
)
;
var
_isPlainObject
=
__webpack_require__
(
4
)
;
var
_isPlainObject2
=
_interopRequireDefault
(
_isPlainObject
)
;
var
_hoistNonReactStatics
=
__webpack_require__
(
23
)
;
var
_hoistNonReactStatics2
=
_interopRequireDefault
(
_hoistNonReactStatics
)
;
var
_invariant
=
__webpack_require__
(
24
)
;
var
_invariant2
=
_interopRequireDefault
(
_invariant
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
"
default
"
:
obj
}
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
function
_possibleConstructorReturn
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
"
this
hasn
'
t
been
initialised
-
super
(
)
hasn
'
t
been
called
"
)
;
}
return
call
&
&
(
typeof
call
=
=
=
"
object
"
|
|
typeof
call
=
=
=
"
function
"
)
?
call
:
self
;
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
"
function
"
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
"
Super
expression
must
either
be
null
or
a
function
not
"
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
defaultMapStateToProps
=
function
defaultMapStateToProps
(
state
)
{
return
{
}
;
}
;
var
defaultMapDispatchToProps
=
function
defaultMapDispatchToProps
(
dispatch
)
{
return
{
dispatch
:
dispatch
}
;
}
;
var
defaultMergeProps
=
function
defaultMergeProps
(
stateProps
dispatchProps
parentProps
)
{
return
_extends
(
{
}
parentProps
stateProps
dispatchProps
)
;
}
;
function
getDisplayName
(
WrappedComponent
)
{
return
WrappedComponent
.
displayName
|
|
WrappedComponent
.
name
|
|
'
Component
'
;
}
var
errorObject
=
{
value
:
null
}
;
function
tryCatch
(
fn
ctx
)
{
try
{
return
fn
.
apply
(
ctx
)
;
}
catch
(
e
)
{
errorObject
.
value
=
e
;
return
errorObject
;
}
}
var
nextVersion
=
0
;
function
connect
(
mapStateToProps
mapDispatchToProps
mergeProps
)
{
var
options
=
arguments
.
length
<
=
3
|
|
arguments
[
3
]
=
=
=
undefined
?
{
}
:
arguments
[
3
]
;
var
shouldSubscribe
=
Boolean
(
mapStateToProps
)
;
var
mapState
=
mapStateToProps
|
|
defaultMapStateToProps
;
var
mapDispatch
=
undefined
;
if
(
typeof
mapDispatchToProps
=
=
=
'
function
'
)
{
mapDispatch
=
mapDispatchToProps
;
}
else
if
(
!
mapDispatchToProps
)
{
mapDispatch
=
defaultMapDispatchToProps
;
}
else
{
mapDispatch
=
(
0
_wrapActionCreators2
[
"
default
"
]
)
(
mapDispatchToProps
)
;
}
var
finalMergeProps
=
mergeProps
|
|
defaultMergeProps
;
var
_options
pure
=
options
.
pure
;
var
pure
=
_options
pure
=
=
=
undefined
?
true
:
_options
pure
;
var
_options
withRef
=
options
.
withRef
;
var
withRef
=
_options
withRef
=
=
=
undefined
?
false
:
_options
withRef
;
var
checkMergedEquals
=
pure
&
&
finalMergeProps
!
=
=
defaultMergeProps
;
var
version
=
nextVersion
+
+
;
return
function
wrapWithConnect
(
WrappedComponent
)
{
var
connectDisplayName
=
'
Connect
(
'
+
getDisplayName
(
WrappedComponent
)
+
'
)
'
;
function
checkStateShape
(
props
methodName
)
{
if
(
!
(
0
_isPlainObject2
[
"
default
"
]
)
(
props
)
)
{
(
0
_warning2
[
"
default
"
]
)
(
methodName
+
'
(
)
in
'
+
connectDisplayName
+
'
must
return
a
plain
object
.
'
+
(
'
Instead
received
'
+
props
+
'
.
'
)
)
;
}
}
function
computeMergedProps
(
stateProps
dispatchProps
parentProps
)
{
var
mergedProps
=
finalMergeProps
(
stateProps
dispatchProps
parentProps
)
;
if
(
false
)
{
checkStateShape
(
mergedProps
'
mergeProps
'
)
;
}
return
mergedProps
;
}
var
Connect
=
function
(
_Component
)
{
_inherits
(
Connect
_Component
)
;
Connect
.
prototype
.
shouldComponentUpdate
=
function
shouldComponentUpdate
(
)
{
return
!
pure
|
|
this
.
haveOwnPropsChanged
|
|
this
.
hasStoreStateChanged
;
}
;
function
Connect
(
props
context
)
{
_classCallCheck
(
this
Connect
)
;
var
_this
=
_possibleConstructorReturn
(
this
_Component
.
call
(
this
props
context
)
)
;
_this
.
version
=
version
;
_this
.
store
=
props
.
store
|
|
context
.
store
;
(
0
_invariant2
[
"
default
"
]
)
(
_this
.
store
'
Could
not
find
"
store
"
in
either
the
context
or
'
+
(
'
props
of
"
'
+
connectDisplayName
+
'
"
.
'
)
+
'
Either
wrap
the
root
component
in
a
<
Provider
>
'
+
(
'
or
explicitly
pass
"
store
"
as
a
prop
to
"
'
+
connectDisplayName
+
'
"
.
'
)
)
;
var
storeState
=
_this
.
store
.
getState
(
)
;
_this
.
state
=
{
storeState
:
storeState
}
;
_this
.
clearCache
(
)
;
return
_this
;
}
Connect
.
prototype
.
computeStateProps
=
function
computeStateProps
(
store
props
)
{
if
(
!
this
.
finalMapStateToProps
)
{
return
this
.
configureFinalMapState
(
store
props
)
;
}
var
state
=
store
.
getState
(
)
;
var
stateProps
=
this
.
doStatePropsDependOnOwnProps
?
this
.
finalMapStateToProps
(
state
props
)
:
this
.
finalMapStateToProps
(
state
)
;
if
(
false
)
{
checkStateShape
(
stateProps
'
mapStateToProps
'
)
;
}
return
stateProps
;
}
;
Connect
.
prototype
.
configureFinalMapState
=
function
configureFinalMapState
(
store
props
)
{
var
mappedState
=
mapState
(
store
.
getState
(
)
props
)
;
var
isFactory
=
typeof
mappedState
=
=
=
'
function
'
;
this
.
finalMapStateToProps
=
isFactory
?
mappedState
:
mapState
;
this
.
doStatePropsDependOnOwnProps
=
this
.
finalMapStateToProps
.
length
!
=
=
1
;
if
(
isFactory
)
{
return
this
.
computeStateProps
(
store
props
)
;
}
if
(
false
)
{
checkStateShape
(
mappedState
'
mapStateToProps
'
)
;
}
return
mappedState
;
}
;
Connect
.
prototype
.
computeDispatchProps
=
function
computeDispatchProps
(
store
props
)
{
if
(
!
this
.
finalMapDispatchToProps
)
{
return
this
.
configureFinalMapDispatch
(
store
props
)
;
}
var
dispatch
=
store
.
dispatch
;
var
dispatchProps
=
this
.
doDispatchPropsDependOnOwnProps
?
this
.
finalMapDispatchToProps
(
dispatch
props
)
:
this
.
finalMapDispatchToProps
(
dispatch
)
;
if
(
false
)
{
checkStateShape
(
dispatchProps
'
mapDispatchToProps
'
)
;
}
return
dispatchProps
;
}
;
Connect
.
prototype
.
configureFinalMapDispatch
=
function
configureFinalMapDispatch
(
store
props
)
{
var
mappedDispatch
=
mapDispatch
(
store
.
dispatch
props
)
;
var
isFactory
=
typeof
mappedDispatch
=
=
=
'
function
'
;
this
.
finalMapDispatchToProps
=
isFactory
?
mappedDispatch
:
mapDispatch
;
this
.
doDispatchPropsDependOnOwnProps
=
this
.
finalMapDispatchToProps
.
length
!
=
=
1
;
if
(
isFactory
)
{
return
this
.
computeDispatchProps
(
store
props
)
;
}
if
(
false
)
{
checkStateShape
(
mappedDispatch
'
mapDispatchToProps
'
)
;
}
return
mappedDispatch
;
}
;
Connect
.
prototype
.
updateStatePropsIfNeeded
=
function
updateStatePropsIfNeeded
(
)
{
var
nextStateProps
=
this
.
computeStateProps
(
this
.
store
this
.
props
)
;
if
(
this
.
stateProps
&
&
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextStateProps
this
.
stateProps
)
)
{
return
false
;
}
this
.
stateProps
=
nextStateProps
;
return
true
;
}
;
Connect
.
prototype
.
updateDispatchPropsIfNeeded
=
function
updateDispatchPropsIfNeeded
(
)
{
var
nextDispatchProps
=
this
.
computeDispatchProps
(
this
.
store
this
.
props
)
;
if
(
this
.
dispatchProps
&
&
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextDispatchProps
this
.
dispatchProps
)
)
{
return
false
;
}
this
.
dispatchProps
=
nextDispatchProps
;
return
true
;
}
;
Connect
.
prototype
.
updateMergedPropsIfNeeded
=
function
updateMergedPropsIfNeeded
(
)
{
var
nextMergedProps
=
computeMergedProps
(
this
.
stateProps
this
.
dispatchProps
this
.
props
)
;
if
(
this
.
mergedProps
&
&
checkMergedEquals
&
&
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextMergedProps
this
.
mergedProps
)
)
{
return
false
;
}
this
.
mergedProps
=
nextMergedProps
;
return
true
;
}
;
Connect
.
prototype
.
isSubscribed
=
function
isSubscribed
(
)
{
return
typeof
this
.
unsubscribe
=
=
=
'
function
'
;
}
;
Connect
.
prototype
.
trySubscribe
=
function
trySubscribe
(
)
{
if
(
shouldSubscribe
&
&
!
this
.
unsubscribe
)
{
this
.
unsubscribe
=
this
.
store
.
subscribe
(
this
.
handleChange
.
bind
(
this
)
)
;
this
.
handleChange
(
)
;
}
}
;
Connect
.
prototype
.
tryUnsubscribe
=
function
tryUnsubscribe
(
)
{
if
(
this
.
unsubscribe
)
{
this
.
unsubscribe
(
)
;
this
.
unsubscribe
=
null
;
}
}
;
Connect
.
prototype
.
componentDidMount
=
function
componentDidMount
(
)
{
this
.
trySubscribe
(
)
;
}
;
Connect
.
prototype
.
componentWillReceiveProps
=
function
componentWillReceiveProps
(
nextProps
)
{
if
(
!
pure
|
|
!
(
0
_shallowEqual2
[
"
default
"
]
)
(
nextProps
this
.
props
)
)
{
this
.
haveOwnPropsChanged
=
true
;
}
}
;
Connect
.
prototype
.
componentWillUnmount
=
function
componentWillUnmount
(
)
{
this
.
tryUnsubscribe
(
)
;
this
.
clearCache
(
)
;
}
;
Connect
.
prototype
.
clearCache
=
function
clearCache
(
)
{
this
.
dispatchProps
=
null
;
this
.
stateProps
=
null
;
this
.
mergedProps
=
null
;
this
.
haveOwnPropsChanged
=
true
;
this
.
hasStoreStateChanged
=
true
;
this
.
haveStatePropsBeenPrecalculated
=
false
;
this
.
statePropsPrecalculationError
=
null
;
this
.
renderedElement
=
null
;
this
.
finalMapDispatchToProps
=
null
;
this
.
finalMapStateToProps
=
null
;
}
;
Connect
.
prototype
.
handleChange
=
function
handleChange
(
)
{
if
(
!
this
.
unsubscribe
)
{
return
;
}
var
storeState
=
this
.
store
.
getState
(
)
;
var
prevStoreState
=
this
.
state
.
storeState
;
if
(
pure
&
&
prevStoreState
=
=
=
storeState
)
{
return
;
}
if
(
pure
&
&
!
this
.
doStatePropsDependOnOwnProps
)
{
var
haveStatePropsChanged
=
tryCatch
(
this
.
updateStatePropsIfNeeded
this
)
;
if
(
!
haveStatePropsChanged
)
{
return
;
}
if
(
haveStatePropsChanged
=
=
=
errorObject
)
{
this
.
statePropsPrecalculationError
=
errorObject
.
value
;
}
this
.
haveStatePropsBeenPrecalculated
=
true
;
}
this
.
hasStoreStateChanged
=
true
;
this
.
setState
(
{
storeState
:
storeState
}
)
;
}
;
Connect
.
prototype
.
getWrappedInstance
=
function
getWrappedInstance
(
)
{
(
0
_invariant2
[
"
default
"
]
)
(
withRef
'
To
access
the
wrapped
instance
you
need
to
specify
'
+
'
{
withRef
:
true
}
as
the
fourth
argument
of
the
connect
(
)
call
.
'
)
;
return
this
.
refs
.
wrappedInstance
;
}
;
Connect
.
prototype
.
render
=
function
render
(
)
{
var
haveOwnPropsChanged
=
this
.
haveOwnPropsChanged
;
var
hasStoreStateChanged
=
this
.
hasStoreStateChanged
;
var
haveStatePropsBeenPrecalculated
=
this
.
haveStatePropsBeenPrecalculated
;
var
statePropsPrecalculationError
=
this
.
statePropsPrecalculationError
;
var
renderedElement
=
this
.
renderedElement
;
this
.
haveOwnPropsChanged
=
false
;
this
.
hasStoreStateChanged
=
false
;
this
.
haveStatePropsBeenPrecalculated
=
false
;
this
.
statePropsPrecalculationError
=
null
;
if
(
statePropsPrecalculationError
)
{
throw
statePropsPrecalculationError
;
}
var
shouldUpdateStateProps
=
true
;
var
shouldUpdateDispatchProps
=
true
;
if
(
pure
&
&
renderedElement
)
{
shouldUpdateStateProps
=
hasStoreStateChanged
|
|
haveOwnPropsChanged
&
&
this
.
doStatePropsDependOnOwnProps
;
shouldUpdateDispatchProps
=
haveOwnPropsChanged
&
&
this
.
doDispatchPropsDependOnOwnProps
;
}
var
haveStatePropsChanged
=
false
;
var
haveDispatchPropsChanged
=
false
;
if
(
haveStatePropsBeenPrecalculated
)
{
haveStatePropsChanged
=
true
;
}
else
if
(
shouldUpdateStateProps
)
{
haveStatePropsChanged
=
this
.
updateStatePropsIfNeeded
(
)
;
}
if
(
shouldUpdateDispatchProps
)
{
haveDispatchPropsChanged
=
this
.
updateDispatchPropsIfNeeded
(
)
;
}
var
haveMergedPropsChanged
=
true
;
if
(
haveStatePropsChanged
|
|
haveDispatchPropsChanged
|
|
haveOwnPropsChanged
)
{
haveMergedPropsChanged
=
this
.
updateMergedPropsIfNeeded
(
)
;
}
else
{
haveMergedPropsChanged
=
false
;
}
if
(
!
haveMergedPropsChanged
&
&
renderedElement
)
{
return
renderedElement
;
}
if
(
withRef
)
{
this
.
renderedElement
=
(
0
_react
.
createElement
)
(
WrappedComponent
_extends
(
{
}
this
.
mergedProps
{
ref
:
'
wrappedInstance
'
}
)
)
;
}
else
{
this
.
renderedElement
=
(
0
_react
.
createElement
)
(
WrappedComponent
this
.
mergedProps
)
;
}
return
this
.
renderedElement
;
}
;
return
Connect
;
}
(
_react
.
Component
)
;
Connect
.
displayName
=
connectDisplayName
;
Connect
.
WrappedComponent
=
WrappedComponent
;
Connect
.
contextTypes
=
{
store
:
_storeShape2
[
"
default
"
]
}
;
Connect
.
propTypes
=
{
store
:
_storeShape2
[
"
default
"
]
}
;
if
(
false
)
{
Connect
.
prototype
.
componentWillUpdate
=
function
componentWillUpdate
(
)
{
if
(
this
.
version
=
=
=
version
)
{
return
;
}
this
.
version
=
version
;
this
.
trySubscribe
(
)
;
}
;
}
return
(
0
_hoistNonReactStatics2
[
"
default
"
]
)
(
Connect
WrappedComponent
)
;
}
;
}
}
function
(
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
shallowEqual
;
function
shallowEqual
(
objA
objB
)
{
if
(
objA
=
=
=
objB
)
{
return
true
;
}
var
keysA
=
Object
.
keys
(
objA
)
;
var
keysB
=
Object
.
keys
(
objB
)
;
if
(
keysA
.
length
!
=
=
keysB
.
length
)
{
return
false
;
}
var
hasOwn
=
Object
.
prototype
.
hasOwnProperty
;
for
(
var
i
=
0
;
i
<
keysA
.
length
;
i
+
+
)
{
if
(
!
hasOwn
.
call
(
objB
keysA
[
i
]
)
|
|
objA
[
keysA
[
i
]
]
!
=
=
objB
[
keysA
[
i
]
]
)
{
return
false
;
}
}
return
true
;
}
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
wrapActionCreators
;
var
_redux
=
__webpack_require__
(
2
)
;
function
wrapActionCreators
(
actionCreators
)
{
return
function
(
dispatch
)
{
return
(
0
_redux
.
bindActionCreators
)
(
actionCreators
dispatch
)
;
}
;
}
}
function
(
module
exports
)
{
'
use
strict
'
;
var
REACT_STATICS
=
{
childContextTypes
:
true
contextTypes
:
true
defaultProps
:
true
displayName
:
true
getDefaultProps
:
true
mixins
:
true
propTypes
:
true
type
:
true
}
;
var
KNOWN_STATICS
=
{
name
:
true
length
:
true
prototype
:
true
caller
:
true
arguments
:
true
arity
:
true
}
;
var
isGetOwnPropertySymbolsAvailable
=
typeof
Object
.
getOwnPropertySymbols
=
=
=
'
function
'
;
module
.
exports
=
function
hoistNonReactStatics
(
targetComponent
sourceComponent
customStatics
)
{
if
(
typeof
sourceComponent
!
=
=
'
string
'
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
sourceComponent
)
;
if
(
isGetOwnPropertySymbolsAvailable
)
{
keys
=
keys
.
concat
(
Object
.
getOwnPropertySymbols
(
sourceComponent
)
)
;
}
for
(
var
i
=
0
;
i
<
keys
.
length
;
+
+
i
)
{
if
(
!
REACT_STATICS
[
keys
[
i
]
]
&
&
!
KNOWN_STATICS
[
keys
[
i
]
]
&
&
(
!
customStatics
|
|
!
customStatics
[
keys
[
i
]
]
)
)
{
try
{
targetComponent
[
keys
[
i
]
]
=
sourceComponent
[
keys
[
i
]
]
;
}
catch
(
error
)
{
}
}
}
}
return
targetComponent
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
var
invariant
=
function
(
condition
format
a
b
c
d
e
f
)
{
if
(
false
)
{
if
(
format
=
=
=
undefined
)
{
throw
new
Error
(
'
invariant
requires
an
error
message
argument
'
)
;
}
}
if
(
!
condition
)
{
var
error
;
if
(
format
=
=
=
undefined
)
{
error
=
new
Error
(
'
Minified
exception
occurred
;
use
the
non
-
minified
dev
environment
'
+
'
for
the
full
error
message
and
additional
helpful
warnings
.
'
)
;
}
else
{
var
args
=
[
a
b
c
d
e
f
]
;
var
argIndex
=
0
;
error
=
new
Error
(
format
.
replace
(
/
%
s
/
g
function
(
)
{
return
args
[
argIndex
+
+
]
;
}
)
)
;
error
.
name
=
'
Invariant
Violation
'
;
}
error
.
framesToPop
=
1
;
throw
error
;
}
}
;
module
.
exports
=
invariant
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
module
.
exports
=
__webpack_require__
(
26
)
;
}
function
(
module
exports
)
{
module
.
exports
=
devtoolsRequire
(
'
devtools
/
client
/
shared
/
vendor
/
react
-
dom
'
)
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
{
Ci
Cu
Cc
components
}
=
__webpack_require__
(
28
)
;
var
Services
=
__webpack_require__
(
33
)
;
var
promise
=
__webpack_require__
(
39
)
;
const
{
FileUtils
}
=
__webpack_require__
(
40
)
;
exports
.
safeErrorString
=
function
safeErrorString
(
aError
)
{
try
{
let
errorString
=
aError
.
toString
(
)
;
if
(
typeof
errorString
=
=
"
string
"
)
{
try
{
if
(
aError
.
stack
)
{
let
stack
=
aError
.
stack
.
toString
(
)
;
if
(
typeof
stack
=
=
"
string
"
)
{
errorString
+
=
"
\
nStack
:
"
+
stack
;
}
}
}
catch
(
ee
)
{
}
if
(
typeof
aError
.
lineNumber
=
=
"
number
"
&
&
typeof
aError
.
columnNumber
=
=
"
number
"
)
{
errorString
+
=
"
Line
:
"
+
aError
.
lineNumber
+
"
column
:
"
+
aError
.
columnNumber
;
}
return
errorString
;
}
}
catch
(
ee
)
{
}
return
Object
.
prototype
.
toString
.
call
(
aError
)
;
}
exports
.
reportException
=
function
reportException
(
aWho
aException
)
{
let
msg
=
aWho
+
"
threw
an
exception
:
"
+
exports
.
safeErrorString
(
aException
)
;
console
.
log
(
msg
)
;
}
exports
.
makeInfallible
=
function
makeInfallible
(
aHandler
aName
)
{
if
(
!
aName
)
aName
=
aHandler
.
name
;
return
function
(
)
{
return
aHandler
.
apply
(
this
arguments
)
;
}
}
exports
.
executeSoon
=
function
executeSoon
(
aFn
)
{
setTimeout
(
aFn
0
)
;
}
;
exports
.
waitForTick
=
function
waitForTick
(
)
{
let
deferred
=
promise
.
defer
(
)
;
exports
.
executeSoon
(
deferred
.
resolve
)
;
return
deferred
.
promise
;
}
;
exports
.
waitForTime
=
function
waitForTime
(
aDelay
)
{
let
deferred
=
promise
.
defer
(
)
;
setTimeout
(
deferred
.
resolve
aDelay
)
;
return
deferred
.
promise
;
}
;
exports
.
yieldingEach
=
function
yieldingEach
(
aArray
aFn
)
{
const
deferred
=
promise
.
defer
(
)
;
let
i
=
0
;
let
len
=
aArray
.
length
;
let
outstanding
=
[
deferred
.
promise
]
;
(
function
loop
(
)
{
const
start
=
Date
.
now
(
)
;
while
(
i
<
len
)
{
if
(
Date
.
now
(
)
-
start
>
16
)
{
exports
.
executeSoon
(
loop
)
;
return
;
}
try
{
outstanding
.
push
(
aFn
(
aArray
[
i
]
i
+
+
)
)
;
}
catch
(
e
)
{
deferred
.
reject
(
e
)
;
return
;
}
}
deferred
.
resolve
(
)
;
}
(
)
)
;
return
promise
.
all
(
outstanding
)
;
}
exports
.
defineLazyPrototypeGetter
=
function
defineLazyPrototypeGetter
(
aObject
aKey
aCallback
)
{
Object
.
defineProperty
(
aObject
aKey
{
configurable
:
true
get
:
function
(
)
{
const
value
=
aCallback
.
call
(
this
)
;
Object
.
defineProperty
(
this
aKey
{
configurable
:
true
writable
:
true
value
:
value
}
)
;
return
value
;
}
}
)
;
}
exports
.
getProperty
=
function
getProperty
(
aObj
aKey
)
{
let
root
=
aObj
;
try
{
do
{
const
desc
=
aObj
.
getOwnPropertyDescriptor
(
aKey
)
;
if
(
desc
)
{
if
(
"
value
"
in
desc
)
{
return
desc
.
value
;
}
return
exports
.
hasSafeGetter
(
desc
)
?
desc
.
get
.
call
(
root
)
.
return
:
undefined
;
}
aObj
=
aObj
.
proto
;
}
while
(
aObj
)
;
}
catch
(
e
)
{
exports
.
reportException
(
"
getProperty
"
e
)
;
}
return
undefined
;
}
;
exports
.
hasSafeGetter
=
function
hasSafeGetter
(
aDesc
)
{
try
{
let
fn
=
aDesc
.
get
.
unwrap
(
)
;
return
fn
&
&
fn
.
callable
&
&
fn
.
class
=
=
"
Function
"
&
&
fn
.
script
=
=
=
undefined
;
}
catch
(
e
)
{
return
false
;
}
}
;
exports
.
isSafeJSObject
=
function
isSafeJSObject
(
aObj
)
{
if
(
isWorker
)
{
return
false
;
}
if
(
Cu
.
getGlobalForObject
(
aObj
)
=
=
Cu
.
getGlobalForObject
(
exports
.
isSafeJSObject
)
)
{
return
true
;
}
let
principal
=
Cu
.
getObjectPrincipal
(
aObj
)
;
if
(
Services
.
scriptSecurityManager
.
isSystemPrincipal
(
principal
)
)
{
return
true
;
}
return
Cu
.
isXrayWrapper
(
aObj
)
;
}
;
exports
.
dumpn
=
function
dumpn
(
str
)
{
if
(
exports
.
dumpn
.
wantLogging
)
{
console
.
log
(
"
DBG
-
SERVER
:
"
+
str
+
"
\
n
"
)
;
}
}
exports
.
dumpn
.
wantLogging
=
false
;
exports
.
dumpv
=
function
(
msg
)
{
if
(
exports
.
dumpv
.
wantVerbose
)
{
exports
.
dumpn
(
msg
)
;
}
}
;
exports
.
dumpv
.
wantVerbose
=
false
;
exports
.
update
=
function
update
(
aTarget
.
.
.
aArgs
)
{
for
(
let
attrs
of
aArgs
)
{
for
(
let
key
in
attrs
)
{
let
desc
=
Object
.
getOwnPropertyDescriptor
(
attrs
key
)
;
if
(
desc
)
{
Object
.
defineProperty
(
aTarget
key
desc
)
;
}
}
}
return
aTarget
;
}
exports
.
values
=
function
values
(
aObject
)
{
return
Object
.
keys
(
aObject
)
.
map
(
k
=
>
aObject
[
k
]
)
;
}
exports
.
defineLazyGetter
=
function
defineLazyGetter
(
aObject
aName
aLambda
)
{
Object
.
defineProperty
(
aObject
aName
{
get
:
function
(
)
{
delete
aObject
[
aName
]
;
return
aObject
[
aName
]
=
aLambda
.
apply
(
aObject
)
;
}
configurable
:
true
enumerable
:
true
}
)
;
}
;
let
haveLoggedDeprecationMessage
=
false
;
exports
.
dbg_assert
=
function
dbg_assert
(
cond
e
)
{
if
(
!
haveLoggedDeprecationMessage
)
{
haveLoggedDeprecationMessage
=
true
;
const
deprecationMessage
=
"
DevToolsUtils
.
dbg_assert
is
deprecated
!
Use
DevToolsUtils
.
assert
instead
!
"
+
Error
(
)
.
stack
;
console
.
log
(
deprecationMessage
)
;
if
(
typeof
console
=
=
=
"
object
"
&
&
console
&
&
console
.
warn
)
{
console
.
warn
(
deprecationMessage
)
;
}
}
if
(
!
cond
)
{
return
e
;
}
}
;
const
{
AppConstants
}
=
__webpack_require__
(
41
)
;
exports
.
noop
=
function
(
)
{
}
;
function
reallyAssert
(
condition
message
)
{
if
(
!
condition
)
{
const
err
=
new
Error
(
"
Assertion
failure
:
"
+
message
)
;
exports
.
reportException
(
"
DevToolsUtils
.
assert
"
err
)
;
throw
err
;
}
}
Object
.
defineProperty
(
exports
"
assert
"
{
get
:
(
)
=
>
(
AppConstants
.
DEBUG
|
|
AppConstants
.
DEBUG_JS_MODULES
|
|
this
.
testing
)
?
reallyAssert
:
exports
.
noop
}
)
exports
.
defineLazyModuleGetter
=
function
defineLazyModuleGetter
(
aObject
aName
aResource
aSymbol
)
{
this
.
defineLazyGetter
(
aObject
aName
function
XPCU_moduleLambda
(
)
{
var
temp
=
{
}
;
Cu
.
import
(
aResource
temp
)
;
return
temp
[
aSymbol
|
|
aName
]
;
}
)
;
}
;
const
{
NetUtil
}
=
__webpack_require__
(
42
)
;
const
{
TextDecoder
OS
}
=
__webpack_require__
(
43
)
;
const
NetworkHelper
=
__webpack_require__
(
44
)
;
function
mainThreadFetch
(
aURL
aOptions
=
{
loadFromCache
:
true
policy
:
Ci
.
nsIContentPolicy
.
TYPE_OTHER
window
:
null
charset
:
null
}
)
{
let
url
=
aURL
.
split
(
"
-
>
"
)
.
pop
(
)
;
let
channel
;
try
{
channel
=
newChannelForURL
(
url
aOptions
)
;
}
catch
(
ex
)
{
return
promise
.
reject
(
ex
)
;
}
channel
.
loadFlags
=
aOptions
.
loadFromCache
?
channel
.
LOAD_FROM_CACHE
:
channel
.
LOAD_BYPASS_CACHE
;
if
(
aOptions
.
window
)
{
channel
.
loadGroup
=
aOptions
.
window
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebNavigation
)
.
QueryInterface
(
Ci
.
nsIDocumentLoader
)
.
loadGroup
;
}
let
deferred
=
promise
.
defer
(
)
;
let
onResponse
=
(
stream
status
request
)
=
>
{
if
(
!
components
.
isSuccessCode
(
status
)
)
{
deferred
.
reject
(
new
Error
(
Failed
to
fetch
{
url
}
.
Code
{
status
}
.
)
)
;
return
;
}
try
{
let
available
=
stream
.
available
(
)
;
let
source
=
NetUtil
.
readInputStreamToString
(
stream
available
)
;
stream
.
close
(
)
;
let
charset
=
channel
.
contentCharset
|
|
aOptions
.
charset
|
|
"
UTF
-
8
"
;
let
unicodeSource
=
NetworkHelper
.
convertToUnicode
(
source
charset
)
;
deferred
.
resolve
(
{
content
:
unicodeSource
contentType
:
request
.
contentType
}
)
;
}
catch
(
ex
)
{
let
uri
=
request
.
originalURI
;
if
(
ex
.
name
=
=
=
"
NS_BASE_STREAM_CLOSED
"
&
&
uri
instanceof
Ci
.
nsIFileURL
)
{
uri
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
let
result
=
OS
.
File
.
read
(
uri
.
file
.
path
)
.
then
(
bytes
=
>
{
let
decoder
=
new
TextDecoder
(
)
;
let
content
=
decoder
.
decode
(
bytes
)
;
return
{
content
contentType
:
"
text
/
plain
"
}
;
}
)
;
deferred
.
resolve
(
result
)
;
}
else
{
deferred
.
reject
(
ex
)
;
}
}
}
;
try
{
NetUtil
.
asyncFetch
(
channel
onResponse
)
;
}
catch
(
ex
)
{
return
promise
.
reject
(
ex
)
;
}
return
deferred
.
promise
;
}
function
newChannelForURL
(
url
{
policy
}
)
{
let
channelOptions
=
{
contentPolicyType
:
policy
loadUsingSystemPrincipal
:
true
uri
:
url
}
;
try
{
return
NetUtil
.
newChannel
(
channelOptions
)
;
}
catch
(
e
)
{
channelOptions
.
uri
=
"
file
:
/
/
"
+
url
;
return
NetUtil
.
newChannel
(
channelOptions
)
;
}
}
if
(
typeof
WorkerGlobalScope
=
=
=
'
undefined
'
)
{
exports
.
fetch
=
mainThreadFetch
;
}
else
{
exports
.
fetch
=
function
(
url
options
)
{
return
rpc
(
"
fetch
"
url
options
)
;
}
}
exports
.
settleAll
=
values
=
>
{
if
(
values
=
=
=
null
|
|
typeof
(
values
[
Symbol
.
iterator
]
)
!
=
"
function
"
)
{
throw
new
Error
(
"
settleAll
(
)
expects
an
iterable
.
"
)
;
}
let
deferred
=
promise
.
defer
(
)
;
values
=
Array
.
isArray
(
values
)
?
values
:
[
.
.
.
values
]
;
let
countdown
=
values
.
length
;
let
resolutionValues
=
new
Array
(
countdown
)
;
let
rejectionValue
;
let
rejectionOccurred
=
false
;
if
(
!
countdown
)
{
deferred
.
resolve
(
resolutionValues
)
;
return
deferred
.
promise
;
}
function
checkForCompletion
(
)
{
if
(
-
-
countdown
>
0
)
{
return
;
}
if
(
!
rejectionOccurred
)
{
deferred
.
resolve
(
resolutionValues
)
;
}
else
{
deferred
.
reject
(
rejectionValue
)
;
}
}
for
(
let
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
let
index
=
i
;
let
value
=
values
[
i
]
;
let
resolver
=
result
=
>
{
resolutionValues
[
index
]
=
result
;
checkForCompletion
(
)
;
}
;
let
rejecter
=
error
=
>
{
if
(
!
rejectionOccurred
)
{
rejectionValue
=
error
;
rejectionOccurred
=
true
;
}
checkForCompletion
(
)
;
}
;
if
(
value
&
&
typeof
(
value
.
then
)
=
=
"
function
"
)
{
value
.
then
(
resolver
rejecter
)
;
}
else
{
resolver
(
value
)
;
}
}
return
deferred
.
promise
;
}
;
var
testing
=
false
;
Object
.
defineProperty
(
exports
"
testing
"
{
get
:
function
(
)
{
return
testing
;
}
set
:
function
(
state
)
{
testing
=
state
;
}
}
)
;
exports
.
openFileStream
=
function
(
filePath
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
uri
=
NetUtil
.
newURI
(
new
FileUtils
.
File
(
filePath
)
)
;
NetUtil
.
asyncFetch
(
{
uri
loadUsingSystemPrincipal
:
true
}
(
stream
result
)
=
>
{
if
(
!
components
.
isSuccessCode
(
result
)
)
{
reject
(
new
Error
(
Could
not
open
"
{
filePath
}
"
:
result
=
{
result
}
)
)
;
return
;
}
resolve
(
stream
)
;
}
)
;
}
)
;
}
exports
.
isGenerator
=
function
(
fn
)
{
if
(
typeof
fn
!
=
=
"
function
"
)
{
return
false
;
}
let
proto
=
Object
.
getPrototypeOf
(
fn
)
;
if
(
!
proto
)
{
return
false
;
}
let
ctor
=
proto
.
constructor
;
if
(
!
ctor
)
{
return
false
;
}
return
ctor
.
name
=
=
"
GeneratorFunction
"
;
}
;
exports
.
isPromise
=
function
(
p
)
{
return
p
&
&
typeof
p
.
then
=
=
=
"
function
"
;
}
;
exports
.
isSavedFrame
=
function
(
thing
)
{
return
Object
.
prototype
.
toString
.
call
(
thing
)
=
=
=
"
[
object
SavedFrame
]
"
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
{
inDOMUtils
}
=
__webpack_require__
(
29
)
;
var
ourServices
=
{
inIDOMUtils
:
inDOMUtils
nsIClipboardHelper
:
{
copyString
:
(
)
=
>
{
}
}
nsIXULChromeRegistry
:
{
isLocaleRTL
:
(
)
=
>
{
return
false
;
}
}
nsIDOMParser
:
{
}
}
;
module
.
exports
=
{
Cc
:
name
=
>
{
if
(
typeof
console
!
=
=
"
undefined
"
)
{
console
.
log
(
'
Cc
sham
for
'
name
)
;
}
return
{
getService
:
(
name
)
=
>
ourServices
[
name
]
createInstance
:
(
iface
)
=
>
ourServices
[
iface
]
}
;
}
CC
:
(
name
iface
method
)
=
>
{
if
(
typeof
console
!
=
=
"
undefined
"
)
{
console
.
log
(
'
CC
sham
for
'
name
iface
method
)
;
}
return
{
}
;
}
Ci
:
{
nsIThread
:
{
"
DISPATCH_NORMAL
"
:
0
"
DISPATCH_SYNC
"
:
1
}
nsIDOMNode
:
typeof
HTMLElement
!
=
=
"
undefined
"
?
HTMLElement
:
null
nsIFocusManager
:
{
MOVEFOCUS_BACKWARD
:
2
MOVEFOCUS_FORWARD
:
1
}
nsIDOMKeyEvent
:
{
}
nsIDOMCSSRule
:
{
"
UNKNOWN_RULE
"
:
0
"
STYLE_RULE
"
:
1
"
CHARSET_RULE
"
:
2
"
IMPORT_RULE
"
:
3
"
MEDIA_RULE
"
:
4
"
FONT_FACE_RULE
"
:
5
"
PAGE_RULE
"
:
6
"
KEYFRAMES_RULE
"
:
7
"
KEYFRAME_RULE
"
:
8
"
MOZ_KEYFRAMES_RULE
"
:
7
"
MOZ_KEYFRAME_RULE
"
:
8
"
NAMESPACE_RULE
"
:
10
"
COUNTER_STYLE_RULE
"
:
11
"
SUPPORTS_RULE
"
:
12
"
FONT_FEATURE_VALUES_RULE
"
:
14
}
inIDOMUtils
:
"
inIDOMUtils
"
nsIClipboardHelper
:
"
nsIClipboardHelper
"
nsIXULChromeRegistry
:
"
nsIXULChromeRegistry
"
}
Cu
:
{
reportError
:
msg
=
>
{
(
typeof
console
!
=
=
"
undefined
"
)
?
console
.
error
(
msg
)
:
dump
(
msg
)
}
callFunctionWithAsyncStack
:
fn
=
>
fn
(
)
}
Cr
:
{
}
components
:
{
isSuccessCode
:
(
)
=
>
(
returnCode
&
0x80000000
)
=
=
=
0
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
{
CSSLexer
}
=
__webpack_require__
(
30
)
;
var
{
cssColors
}
=
__webpack_require__
(
31
)
;
var
{
cssProperties
}
=
__webpack_require__
(
32
)
;
var
cssRGBMap
;
var
EXCLUDE_SHORTHANDS
=
(
1
<
<
0
)
;
var
INCLUDE_ALIASES
=
(
1
<
<
1
)
;
var
TYPE_LENGTH
=
0
;
var
TYPE_PERCENTAGE
=
1
;
var
TYPE_COLOR
=
2
;
var
TYPE_URL
=
3
;
var
TYPE_ANGLE
=
4
;
var
TYPE_FREQUENCY
=
5
;
var
TYPE_TIME
=
6
;
var
TYPE_GRADIENT
=
7
;
var
TYPE_TIMING_FUNCTION
=
8
;
var
TYPE_IMAGE_RECT
=
9
;
var
TYPE_NUMBER
=
10
;
function
getCSSLexer
(
text
)
{
return
new
CSSLexer
(
text
)
;
}
function
rgbToColorName
(
r
g
b
)
{
if
(
!
cssRGBMap
)
{
cssRGBMap
=
new
Map
(
)
;
for
(
let
name
in
cssColors
)
{
cssRGBMap
.
set
(
JSON
.
stringify
(
cssColors
[
name
]
)
name
)
;
}
}
let
value
=
cssRGBMap
.
get
(
JSON
.
stringify
(
[
r
g
b
]
)
)
;
if
(
!
value
)
{
throw
new
Error
(
"
no
such
color
"
)
;
}
return
value
;
}
function
_hslValue
(
n1
n2
hue
)
{
if
(
hue
>
6
.
0
)
{
hue
-
=
6
.
0
;
}
else
if
(
hue
<
0
.
0
)
{
hue
+
=
6
.
0
;
}
var
val
;
if
(
hue
<
1
.
0
)
{
val
=
n1
+
(
n2
-
n1
)
*
hue
;
}
else
if
(
hue
<
3
.
0
)
{
val
=
n2
;
}
else
if
(
hue
<
4
.
0
)
{
val
=
n1
+
(
n2
-
n1
)
*
(
4
.
0
-
hue
)
;
}
else
{
val
=
n1
;
}
return
val
;
}
function
hslToRGB
(
[
hue
saturation
lightness
]
)
{
var
red
;
var
green
;
var
blue
;
if
(
saturation
=
=
=
0
)
{
red
=
lightness
;
green
=
lightness
;
blue
=
lightness
;
}
else
{
var
m2
;
if
(
lightness
<
=
0
.
5
)
{
m2
=
lightness
*
(
1
.
0
+
saturation
)
;
}
else
{
m2
=
lightness
+
saturation
-
(
lightness
*
saturation
)
;
}
var
m1
=
(
2
.
0
*
lightness
)
-
m2
;
var
f
=
_hslValue
;
var
h6
=
hue
*
6
.
0
;
red
=
f
(
m1
m2
h6
+
2
)
;
green
=
f
(
m1
m2
h6
)
;
blue
=
f
(
m1
m2
h6
-
2
)
;
}
return
[
red
green
blue
]
;
}
function
colorToRGBA
(
name
)
{
name
=
name
.
trim
(
)
.
toLowerCase
(
)
;
if
(
name
in
cssColors
)
{
return
cssColors
[
name
]
;
}
if
(
name
=
=
=
"
transparent
"
)
{
return
[
0
0
0
0
]
;
}
let
lexer
=
getCSSLexer
(
name
)
;
let
getToken
=
function
(
)
{
while
(
true
)
{
let
token
=
lexer
.
nextToken
(
)
;
if
(
!
token
|
|
token
.
tokenType
!
=
=
"
comment
"
|
|
token
.
tokenType
!
=
=
"
whitespace
"
)
{
return
token
;
}
}
}
;
let
requireComma
=
function
(
token
)
{
if
(
token
.
tokenType
!
=
=
"
symbol
"
|
|
token
.
text
!
=
=
"
"
)
{
return
null
;
}
return
getToken
(
)
;
}
;
let
func
=
getToken
(
)
;
if
(
!
func
|
|
func
.
tokenType
!
=
=
"
function
"
)
{
return
null
;
}
let
alpha
=
false
;
if
(
func
.
text
=
=
=
"
rgb
"
|
|
func
.
text
=
=
=
"
hsl
"
)
{
}
else
if
(
func
.
text
=
=
=
"
rgba
"
|
|
func
.
text
=
=
=
"
hsla
"
)
{
alpha
=
true
;
}
else
{
return
null
;
}
let
vals
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
+
+
i
)
{
let
token
=
getToken
(
)
;
if
(
i
>
0
)
{
token
=
requireComma
(
token
)
;
}
if
(
token
.
tokenType
!
=
=
"
number
"
|
|
!
token
.
isInteger
)
{
return
null
;
}
let
num
=
token
.
number
;
if
(
num
<
0
)
{
num
=
0
;
}
else
if
(
num
>
255
)
{
num
=
255
;
}
vals
.
push
(
num
)
;
}
if
(
func
.
text
=
=
=
"
hsl
"
|
|
func
.
text
=
=
=
"
hsla
"
)
{
vals
=
hslToRGB
(
vals
)
;
}
if
(
alpha
)
{
let
token
=
requireComma
(
getToken
(
)
)
;
if
(
token
.
tokenType
!
=
=
"
number
"
)
{
return
null
;
}
let
num
=
token
.
number
;
if
(
num
<
0
)
{
num
=
0
;
}
else
if
(
num
>
1
)
{
num
=
1
;
}
vals
.
push
(
num
)
;
}
else
{
vals
.
push
(
1
)
;
}
let
parenToken
=
getToken
(
)
;
if
(
!
parenToken
|
|
parenToken
.
tokenType
!
=
=
"
symbol
"
|
|
parenToken
.
text
!
=
=
"
)
"
)
{
return
null
;
}
if
(
getToken
(
)
!
=
=
null
)
{
return
null
;
}
return
vals
;
}
function
isValidCSSColor
(
name
)
{
return
colorToRGBA
(
name
)
!
=
=
null
;
}
function
isVariable
(
name
)
{
return
name
.
startsWith
(
"
-
-
"
)
;
}
function
cssPropertyIsShorthand
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
false
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
return
!
!
cssProperties
[
name
]
.
subproperties
;
}
function
getSubpropertiesForCSSProperty
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
[
name
]
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
if
(
"
subproperties
"
in
cssProperties
[
name
]
)
{
return
cssProperties
[
name
]
.
subproperties
.
slice
(
)
;
}
return
[
name
]
;
}
function
getCSSValuesForProperty
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
[
"
initial
"
"
inherit
"
"
unset
"
]
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
return
cssProperties
[
name
]
.
values
.
slice
(
)
;
}
function
getCSSPropertyNames
(
flags
)
{
let
names
=
Object
.
keys
(
cssProperties
)
;
if
(
(
flags
&
EXCLUDE_SHORTHANDS
)
!
=
=
0
)
{
names
=
names
.
filter
(
(
name
)
=
>
cssProperties
[
name
]
.
subproperties
)
;
}
if
(
(
flags
&
INCLUDE_ALIASES
)
=
=
=
0
)
{
names
=
names
.
filter
(
(
name
)
=
>
!
cssProperties
[
name
]
.
alias
)
;
}
return
names
;
}
function
cssPropertySupportsType
(
name
type
)
{
if
(
isVariable
(
name
)
)
{
return
false
;
}
if
(
!
(
name
in
cssProperties
)
)
{
throw
Error
(
"
unknown
property
"
+
name
)
;
}
return
(
cssProperties
[
name
]
.
supports
&
(
1
<
<
type
)
)
!
=
=
0
;
}
function
isInheritedProperty
(
name
)
{
if
(
isVariable
(
name
)
)
{
return
true
;
}
if
(
!
(
name
in
cssProperties
)
)
{
return
false
;
}
return
cssProperties
[
name
]
.
inherited
;
}
function
cssPropertyIsValid
(
name
value
)
{
if
(
isVariable
(
name
)
)
{
return
true
;
}
if
(
!
(
name
in
cssProperties
)
)
{
return
false
;
}
let
elt
=
document
.
createElement
(
"
div
"
)
;
elt
.
style
=
name
+
"
:
"
+
value
;
return
elt
.
style
.
length
>
0
;
}
exports
.
inDOMUtils
=
{
getCSSLexer
rgbToColorName
colorToRGBA
isValidCSSColor
cssPropertyIsShorthand
getSubpropertiesForCSSProperty
getCSSValuesForProperty
getCSSPropertyNames
cssPropertySupportsType
isInheritedProperty
cssPropertyIsValid
EXCLUDE_SHORTHANDS
INCLUDE_ALIASES
TYPE_LENGTH
TYPE_PERCENTAGE
TYPE_COLOR
TYPE_URL
TYPE_ANGLE
TYPE_FREQUENCY
TYPE_TIME
TYPE_GRADIENT
TYPE_TIMING_FUNCTION
TYPE_IMAGE_RECT
TYPE_NUMBER
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_FACTORY__
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
(
function
(
root
factory
)
{
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
exports
]
__WEBPACK_AMD_DEFINE_FACTORY__
=
(
factory
)
__WEBPACK_AMD_DEFINE_RESULT__
=
(
typeof
__WEBPACK_AMD_DEFINE_FACTORY__
=
=
=
'
function
'
?
(
__WEBPACK_AMD_DEFINE_FACTORY__
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
)
:
__WEBPACK_AMD_DEFINE_FACTORY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
typeof
exports
!
=
=
'
undefined
'
)
{
factory
(
exports
)
;
}
else
{
factory
(
root
)
;
}
}
(
this
function
(
exports
)
{
function
between
(
num
first
last
)
{
return
num
>
=
first
&
&
num
<
=
last
;
}
function
digit
(
code
)
{
return
between
(
code
0x30
0x39
)
;
}
function
hexdigit
(
code
)
{
return
digit
(
code
)
|
|
between
(
code
0x41
0x46
)
|
|
between
(
code
0x61
0x66
)
;
}
function
uppercaseletter
(
code
)
{
return
between
(
code
0x41
0x5a
)
;
}
function
lowercaseletter
(
code
)
{
return
between
(
code
0x61
0x7a
)
;
}
function
letter
(
code
)
{
return
uppercaseletter
(
code
)
|
|
lowercaseletter
(
code
)
;
}
function
nonascii
(
code
)
{
return
code
>
=
0x80
;
}
function
namestartchar
(
code
)
{
return
letter
(
code
)
|
|
nonascii
(
code
)
|
|
code
=
=
0x5f
;
}
function
namechar
(
code
)
{
return
namestartchar
(
code
)
|
|
digit
(
code
)
|
|
code
=
=
0x2d
;
}
function
nonprintable
(
code
)
{
return
between
(
code
0
8
)
|
|
code
=
=
0xb
|
|
between
(
code
0xe
0x1f
)
|
|
code
=
=
0x7f
;
}
function
newline
(
code
)
{
return
code
=
=
0xa
;
}
function
whitespace
(
code
)
{
return
newline
(
code
)
|
|
code
=
=
9
|
|
code
=
=
0x20
;
}
var
maximumallowedcodepoint
=
0x10ffff
;
var
InvalidCharacterError
=
function
(
message
)
{
this
.
message
=
message
;
}
;
InvalidCharacterError
.
prototype
=
new
Error
;
InvalidCharacterError
.
prototype
.
name
=
'
InvalidCharacterError
'
;
function
stringFromCode
(
code
)
{
if
(
code
<
=
0xffff
)
return
String
.
fromCharCode
(
code
)
;
code
-
=
Math
.
pow
(
2
20
)
;
var
lead
=
Math
.
floor
(
code
/
Math
.
pow
(
2
10
)
)
+
0xd800
;
var
trail
=
code
%
Math
.
pow
(
2
10
)
+
0xdc00
;
return
String
.
fromCharCode
(
lead
)
+
String
.
fromCharCode
(
trail
)
;
}
function
*
tokenize
(
str
options
)
{
if
(
options
=
=
=
undefined
)
{
options
=
{
}
;
}
if
(
options
.
loc
=
=
=
undefined
)
{
options
.
loc
=
false
;
}
if
(
options
.
offsets
=
=
=
undefined
)
{
options
.
offsets
=
false
;
}
if
(
options
.
keepComments
=
=
=
undefined
)
{
options
.
keepComments
=
false
;
}
if
(
options
.
startOffset
=
=
=
undefined
)
{
options
.
startOffset
=
0
;
}
var
i
=
options
.
startOffset
-
1
;
var
code
;
var
line
=
0
;
var
column
=
0
;
var
lastLineLength
=
0
;
var
incrLineno
=
function
(
)
{
line
+
=
1
;
lastLineLength
=
column
;
column
=
0
;
}
;
var
locStart
=
{
line
:
line
column
:
column
}
;
var
offsetStart
=
i
;
var
codepoint
=
function
(
i
)
{
if
(
i
>
=
str
.
length
)
{
return
-
1
;
}
return
str
.
charCodeAt
(
i
)
;
}
;
var
next
=
function
(
num
)
{
if
(
num
=
=
=
undefined
)
num
=
1
;
if
(
num
>
3
)
throw
"
Spec
Error
:
no
more
than
three
codepoints
of
lookahead
.
"
;
var
rcode
;
for
(
var
offset
=
i
+
1
;
num
-
-
>
0
;
+
+
offset
)
{
rcode
=
codepoint
(
offset
)
;
if
(
rcode
=
=
=
0xd
&
&
codepoint
(
offset
+
1
)
=
=
=
0xa
)
{
+
+
offset
;
rcode
=
0xa
;
}
else
if
(
rcode
=
=
=
0xd
|
|
rcode
=
=
=
0xc
)
{
rcode
=
0xa
;
}
else
if
(
rcode
=
=
=
0x0
)
{
rcode
=
0xfffd
;
}
}
return
rcode
;
}
;
var
consume
=
function
(
num
)
{
if
(
num
=
=
=
undefined
)
num
=
1
;
while
(
num
-
-
>
0
)
{
+
+
i
;
code
=
codepoint
(
i
)
;
if
(
code
=
=
=
0xd
&
&
codepoint
(
i
+
1
)
=
=
=
0xa
)
{
+
+
i
;
code
=
0xa
;
}
else
if
(
code
=
=
=
0xd
|
|
code
=
=
=
0xc
)
{
code
=
0xa
;
}
else
if
(
code
=
=
=
0x0
)
{
code
=
0xfffd
;
}
if
(
newline
(
code
)
)
incrLineno
(
)
;
else
column
+
+
;
}
return
true
;
}
;
var
reconsume
=
function
(
)
{
i
-
=
1
;
if
(
newline
(
code
)
)
{
line
-
=
1
;
column
=
lastLineLength
;
}
else
{
column
-
=
1
;
}
return
true
;
}
;
var
eof
=
function
(
codepoint
)
{
if
(
codepoint
=
=
=
undefined
)
codepoint
=
code
;
return
codepoint
=
=
-
1
;
}
;
var
donothing
=
function
(
)
{
}
;
var
parseerror
=
function
(
)
{
console
.
log
(
"
Parse
error
at
index
"
+
i
+
"
processing
codepoint
0x
"
+
code
.
toString
(
16
)
+
"
.
"
)
;
return
true
;
}
;
var
consumeAToken
=
function
(
)
{
consume
(
)
;
if
(
!
options
.
keepComments
)
{
while
(
code
=
=
0x2f
&
&
next
(
)
=
=
0x2a
)
{
consumeAComment
(
)
;
consume
(
)
;
}
}
locStart
.
line
=
line
;
locStart
.
column
=
column
;
offsetStart
=
i
;
if
(
whitespace
(
code
)
)
{
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
return
new
WhitespaceToken
;
}
else
if
(
code
=
=
0x2f
&
&
next
(
)
=
=
0x2a
)
return
consumeAComment
(
)
;
else
if
(
code
=
=
0x22
)
return
consumeAStringToken
(
)
;
else
if
(
code
=
=
0x23
)
{
if
(
namechar
(
next
(
)
)
|
|
areAValidEscape
(
next
(
1
)
next
(
2
)
)
)
{
var
token
=
new
HashToken
(
)
;
if
(
wouldStartAnIdentifier
(
next
(
1
)
next
(
2
)
next
(
3
)
)
)
{
token
.
type
=
"
id
"
;
token
.
tokenType
=
"
id
"
;
}
token
.
value
=
consumeAName
(
)
;
token
.
text
=
token
.
value
;
return
token
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x24
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
SuffixMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x27
)
return
consumeAStringToken
(
)
;
else
if
(
code
=
=
0x28
)
return
new
OpenParenToken
(
)
;
else
if
(
code
=
=
0x29
)
return
new
CloseParenToken
(
)
;
else
if
(
code
=
=
0x2a
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
SubstringMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x2b
)
{
if
(
startsWithANumber
(
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x2c
)
return
new
CommaToken
(
)
;
else
if
(
code
=
=
0x2d
)
{
if
(
startsWithANumber
(
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
if
(
next
(
1
)
=
=
0x2d
&
&
next
(
2
)
=
=
0x3e
)
{
consume
(
2
)
;
return
new
CDCToken
(
)
;
}
else
if
(
startsWithAnIdentifier
(
)
)
{
reconsume
(
)
;
return
consumeAnIdentlikeToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x2e
)
{
if
(
startsWithANumber
(
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x3a
)
return
new
ColonToken
;
else
if
(
code
=
=
0x3b
)
return
new
SemicolonToken
;
else
if
(
code
=
=
0x3c
)
{
if
(
next
(
1
)
=
=
0x21
&
&
next
(
2
)
=
=
0x2d
&
&
next
(
3
)
=
=
0x2d
)
{
consume
(
3
)
;
return
new
CDOToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x40
)
{
if
(
wouldStartAnIdentifier
(
next
(
1
)
next
(
2
)
next
(
3
)
)
)
{
return
new
AtKeywordToken
(
consumeAName
(
)
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x5b
)
return
new
OpenSquareToken
(
)
;
else
if
(
code
=
=
0x5c
)
{
if
(
startsWithAValidEscape
(
)
)
{
reconsume
(
)
;
return
consumeAnIdentlikeToken
(
)
;
}
else
{
parseerror
(
)
;
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x5d
)
return
new
CloseSquareToken
(
)
;
else
if
(
code
=
=
0x5e
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
PrefixMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x7b
)
return
new
OpenCurlyToken
(
)
;
else
if
(
code
=
=
0x7c
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
DashMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
code
=
=
0x7d
)
return
new
CloseCurlyToken
(
)
;
else
if
(
code
=
=
0x7e
)
{
if
(
next
(
)
=
=
0x3d
)
{
consume
(
)
;
return
new
IncludeMatchToken
(
)
;
}
else
{
return
new
DelimToken
(
code
)
;
}
}
else
if
(
digit
(
code
)
)
{
reconsume
(
)
;
return
consumeANumericToken
(
)
;
}
else
if
(
namestartchar
(
code
)
)
{
reconsume
(
)
;
return
consumeAnIdentlikeToken
(
)
;
}
else
if
(
eof
(
)
)
return
new
EOFToken
(
)
;
else
return
new
DelimToken
(
code
)
;
}
;
var
consumeAComment
=
function
(
)
{
consume
(
)
;
var
comment
=
"
"
;
while
(
true
)
{
consume
(
)
;
if
(
code
=
=
0x2a
&
&
next
(
)
=
=
0x2f
)
{
consume
(
)
;
break
;
}
else
if
(
eof
(
)
)
{
break
;
}
comment
+
=
stringFromCode
(
code
)
;
}
return
new
CommentToken
(
comment
)
;
}
;
var
consumeANumericToken
=
function
(
)
{
var
num
=
consumeANumber
(
)
;
var
token
;
if
(
wouldStartAnIdentifier
(
next
(
1
)
next
(
2
)
next
(
3
)
)
)
{
token
=
new
DimensionToken
(
)
;
token
.
value
=
num
.
value
;
token
.
repr
=
num
.
repr
;
token
.
type
=
num
.
type
;
token
.
unit
=
consumeAName
(
)
;
token
.
text
=
token
.
unit
;
}
else
if
(
next
(
)
=
=
0x25
)
{
consume
(
)
;
token
=
new
PercentageToken
(
)
;
token
.
value
=
num
.
value
;
token
.
repr
=
num
.
repr
;
}
else
{
var
token
=
new
NumberToken
(
)
;
token
.
value
=
num
.
value
;
token
.
repr
=
num
.
repr
;
token
.
type
=
num
.
type
;
}
token
.
number
=
token
.
value
;
token
.
isInteger
=
token
.
type
=
=
=
"
integer
"
;
return
token
;
}
;
var
consumeAnIdentlikeToken
=
function
(
)
{
var
str
=
consumeAName
(
)
;
if
(
str
.
toLowerCase
(
)
=
=
"
url
"
&
&
next
(
)
=
=
0x28
)
{
consume
(
)
;
while
(
whitespace
(
next
(
1
)
)
&
&
whitespace
(
next
(
2
)
)
)
consume
(
)
;
if
(
(
next
(
)
=
=
0x22
|
|
next
(
)
=
=
0x27
)
|
|
(
whitespace
(
next
(
)
)
&
&
(
next
(
2
)
=
=
0x22
|
|
next
(
2
)
=
=
0x27
)
)
)
{
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
consume
(
)
;
let
str
=
consumeAStringToken
(
)
;
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
consume
(
)
;
return
new
URLToken
(
str
.
text
)
;
}
else
{
return
consumeAURLToken
(
)
;
}
}
else
if
(
next
(
)
=
=
0x28
)
{
consume
(
)
;
return
new
FunctionToken
(
str
)
;
}
else
{
return
new
IdentToken
(
str
)
;
}
}
;
var
consumeAStringToken
=
function
(
endingCodePoint
)
{
if
(
endingCodePoint
=
=
=
undefined
)
endingCodePoint
=
code
;
var
string
=
"
"
;
while
(
consume
(
)
)
{
if
(
code
=
=
endingCodePoint
|
|
eof
(
)
)
{
return
new
StringToken
(
string
)
;
}
else
if
(
newline
(
code
)
)
{
reconsume
(
)
;
return
new
BadStringToken
(
string
)
;
}
else
if
(
code
=
=
0x5c
)
{
if
(
eof
(
next
(
)
)
)
{
donothing
(
)
;
}
else
if
(
newline
(
next
(
)
)
)
{
consume
(
)
;
}
else
{
string
+
=
stringFromCode
(
consumeEscape
(
)
)
;
}
}
else
{
string
+
=
stringFromCode
(
code
)
;
}
}
}
;
var
consumeAURLToken
=
function
(
)
{
var
token
=
new
URLToken
(
"
"
)
;
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
if
(
eof
(
next
(
)
)
)
return
token
;
while
(
consume
(
)
)
{
if
(
code
=
=
0x29
|
|
eof
(
)
)
{
break
;
}
else
if
(
whitespace
(
code
)
)
{
while
(
whitespace
(
next
(
)
)
)
consume
(
)
;
if
(
next
(
)
=
=
0x29
|
|
eof
(
next
(
)
)
)
{
consume
(
)
;
break
;
}
else
{
consumeTheRemnantsOfABadURL
(
)
;
return
new
BadURLToken
(
)
;
}
}
else
if
(
code
=
=
0x22
|
|
code
=
=
0x27
|
|
code
=
=
0x28
|
|
nonprintable
(
code
)
)
{
parseerror
(
)
;
consumeTheRemnantsOfABadURL
(
)
;
return
new
BadURLToken
(
)
;
}
else
if
(
code
=
=
0x5c
)
{
if
(
startsWithAValidEscape
(
)
)
{
token
.
value
+
=
stringFromCode
(
consumeEscape
(
)
)
;
}
else
{
parseerror
(
)
;
consumeTheRemnantsOfABadURL
(
)
;
return
new
BadURLToken
(
)
;
}
}
else
{
token
.
value
+
=
stringFromCode
(
code
)
;
}
}
token
.
text
=
token
.
value
;
return
token
;
}
;
var
consumeEscape
=
function
(
)
{
consume
(
)
;
if
(
hexdigit
(
code
)
)
{
var
digits
=
[
code
]
;
for
(
var
total
=
0
;
total
<
5
;
total
+
+
)
{
if
(
hexdigit
(
next
(
)
)
)
{
consume
(
)
;
digits
.
push
(
code
)
;
}
else
{
break
;
}
}
if
(
whitespace
(
next
(
)
)
)
consume
(
)
;
var
value
=
parseInt
(
digits
.
map
(
function
(
x
)
{
return
String
.
fromCharCode
(
x
)
;
}
)
.
join
(
'
'
)
16
)
;
if
(
value
>
maximumallowedcodepoint
)
value
=
0xfffd
;
return
value
;
}
else
if
(
eof
(
)
)
{
return
0xfffd
;
}
else
{
return
code
;
}
}
;
var
areAValidEscape
=
function
(
c1
c2
)
{
if
(
c1
!
=
0x5c
)
return
false
;
if
(
newline
(
c2
)
)
return
false
;
return
true
;
}
;
var
startsWithAValidEscape
=
function
(
)
{
return
areAValidEscape
(
code
next
(
)
)
;
}
;
var
wouldStartAnIdentifier
=
function
(
c1
c2
c3
)
{
if
(
c1
=
=
0x2d
)
{
return
namestartchar
(
c2
)
|
|
c2
=
=
0x2d
|
|
areAValidEscape
(
c2
c3
)
;
}
else
if
(
namestartchar
(
c1
)
)
{
return
true
;
}
else
if
(
c1
=
=
0x5c
)
{
return
areAValidEscape
(
c1
c2
)
;
}
else
{
return
false
;
}
}
;
var
startsWithAnIdentifier
=
function
(
)
{
return
wouldStartAnIdentifier
(
code
next
(
1
)
next
(
2
)
)
;
}
;
var
wouldStartANumber
=
function
(
c1
c2
c3
)
{
if
(
c1
=
=
0x2b
|
|
c1
=
=
0x2d
)
{
if
(
digit
(
c2
)
)
return
true
;
if
(
c2
=
=
0x2e
&
&
digit
(
c3
)
)
return
true
;
return
false
;
}
else
if
(
c1
=
=
0x2e
)
{
if
(
digit
(
c2
)
)
return
true
;
return
false
;
}
else
if
(
digit
(
c1
)
)
{
return
true
;
}
else
{
return
false
;
}
}
;
var
startsWithANumber
=
function
(
)
{
return
wouldStartANumber
(
code
next
(
1
)
next
(
2
)
)
;
}
;
var
consumeAName
=
function
(
)
{
var
result
=
"
"
;
while
(
consume
(
)
)
{
if
(
namechar
(
code
)
)
{
result
+
=
stringFromCode
(
code
)
;
}
else
if
(
startsWithAValidEscape
(
)
)
{
result
+
=
stringFromCode
(
consumeEscape
(
)
)
;
}
else
{
reconsume
(
)
;
return
result
;
}
}
}
;
var
consumeANumber
=
function
(
)
{
var
repr
=
[
]
;
var
type
=
"
integer
"
;
if
(
next
(
)
=
=
0x2b
|
|
next
(
)
=
=
0x2d
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
if
(
next
(
1
)
=
=
0x2e
&
&
digit
(
next
(
2
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
type
=
"
number
"
;
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
}
var
c1
=
next
(
1
)
c2
=
next
(
2
)
c3
=
next
(
3
)
;
if
(
(
c1
=
=
0x45
|
|
c1
=
=
0x65
)
&
&
digit
(
c2
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
type
=
"
number
"
;
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
}
else
if
(
(
c1
=
=
0x45
|
|
c1
=
=
0x65
)
&
&
(
c2
=
=
0x2b
|
|
c2
=
=
0x2d
)
&
&
digit
(
c3
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
type
=
"
number
"
;
while
(
digit
(
next
(
)
)
)
{
consume
(
)
;
repr
+
=
stringFromCode
(
code
)
;
}
}
var
value
=
convertAStringToANumber
(
repr
)
;
return
{
type
:
type
value
:
value
repr
:
repr
}
;
}
;
var
convertAStringToANumber
=
function
(
string
)
{
return
+
string
;
}
;
var
consumeTheRemnantsOfABadURL
=
function
(
)
{
while
(
consume
(
)
)
{
if
(
code
=
=
0x2d
|
|
eof
(
)
)
{
return
;
}
else
if
(
startsWithAValidEscape
(
)
)
{
consumeEscape
(
)
;
donothing
(
)
;
}
else
{
donothing
(
)
;
}
}
}
;
var
iterationCount
=
0
;
while
(
!
eof
(
next
(
)
)
)
{
var
token
=
consumeAToken
(
)
;
if
(
options
.
loc
)
{
token
.
loc
=
{
}
;
token
.
loc
.
start
=
{
line
:
locStart
.
line
column
:
locStart
.
column
}
;
token
.
loc
.
end
=
{
line
:
line
column
:
column
}
;
}
if
(
options
.
offsets
)
{
token
.
startOffset
=
offsetStart
;
token
.
endOffset
=
i
+
1
;
}
yield
token
;
iterationCount
+
+
;
if
(
iterationCount
>
str
.
length
*
2
)
return
"
I
'
m
infinite
-
looping
!
"
;
}
}
function
CSSParserToken
(
)
{
throw
"
Abstract
Base
Class
"
;
}
CSSParserToken
.
prototype
.
toJSON
=
function
(
)
{
return
{
token
:
this
.
tokenType
}
;
}
;
CSSParserToken
.
prototype
.
toString
=
function
(
)
{
return
this
.
tokenType
;
}
;
CSSParserToken
.
prototype
.
toSource
=
function
(
)
{
return
'
'
+
this
;
}
;
function
BadStringToken
(
text
)
{
this
.
text
=
text
;
return
this
;
}
BadStringToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
BadStringToken
.
prototype
.
tokenType
=
"
bad_string
"
;
function
BadURLToken
(
)
{
return
this
;
}
BadURLToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
BadURLToken
.
prototype
.
tokenType
=
"
bad_url
"
;
function
WhitespaceToken
(
)
{
return
this
;
}
WhitespaceToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
WhitespaceToken
.
prototype
.
tokenType
=
"
whitespace
"
;
WhitespaceToken
.
prototype
.
toString
=
function
(
)
{
return
"
WS
"
;
}
;
WhitespaceToken
.
prototype
.
toSource
=
function
(
)
{
return
"
"
;
}
;
function
CDOToken
(
)
{
return
this
;
}
CDOToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
CDOToken
.
prototype
.
tokenType
=
"
htmlcomment
"
;
CDOToken
.
prototype
.
toSource
=
function
(
)
{
return
"
<
!
-
-
"
;
}
;
function
CDCToken
(
)
{
return
this
;
}
CDCToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
CDCToken
.
prototype
.
tokenType
=
"
htmlcomment
"
;
CDCToken
.
prototype
.
toSource
=
function
(
)
{
return
"
-
-
>
"
;
}
;
function
ColonToken
(
)
{
return
this
;
}
ColonToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
ColonToken
.
prototype
.
tokenType
=
"
symbol
"
;
ColonToken
.
prototype
.
text
=
"
:
"
;
function
SemicolonToken
(
)
{
return
this
;
}
SemicolonToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
SemicolonToken
.
prototype
.
tokenType
=
"
symbol
"
;
SemicolonToken
.
prototype
.
text
=
"
;
"
;
function
CommaToken
(
)
{
return
this
;
}
CommaToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
CommaToken
.
prototype
.
tokenType
=
"
symbol
"
;
CommaToken
.
prototype
.
text
=
"
"
;
function
GroupingToken
(
)
{
throw
"
Abstract
Base
Class
"
;
}
GroupingToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
function
OpenCurlyToken
(
)
{
this
.
value
=
"
{
"
;
this
.
mirror
=
"
}
"
;
return
this
;
}
OpenCurlyToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
OpenCurlyToken
.
prototype
.
tokenType
=
"
symbol
"
;
OpenCurlyToken
.
prototype
.
text
=
"
{
"
;
function
CloseCurlyToken
(
)
{
this
.
value
=
"
}
"
;
this
.
mirror
=
"
{
"
;
return
this
;
}
CloseCurlyToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
CloseCurlyToken
.
prototype
.
tokenType
=
"
symbol
"
;
CloseCurlyToken
.
prototype
.
text
=
"
}
"
;
function
OpenSquareToken
(
)
{
this
.
value
=
"
[
"
;
this
.
mirror
=
"
]
"
;
return
this
;
}
OpenSquareToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
OpenSquareToken
.
prototype
.
tokenType
=
"
symbol
"
;
OpenSquareToken
.
prototype
.
text
=
"
[
"
;
function
CloseSquareToken
(
)
{
this
.
value
=
"
]
"
;
this
.
mirror
=
"
[
"
;
return
this
;
}
CloseSquareToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
CloseSquareToken
.
prototype
.
tokenType
=
"
symbol
"
;
CloseSquareToken
.
prototype
.
text
=
"
]
"
;
function
OpenParenToken
(
)
{
this
.
value
=
"
(
"
;
this
.
mirror
=
"
)
"
;
return
this
;
}
OpenParenToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
OpenParenToken
.
prototype
.
tokenType
=
"
symbol
"
;
OpenParenToken
.
prototype
.
text
=
"
(
"
;
function
CloseParenToken
(
)
{
this
.
value
=
"
)
"
;
this
.
mirror
=
"
(
"
;
return
this
;
}
CloseParenToken
.
prototype
=
Object
.
create
(
GroupingToken
.
prototype
)
;
CloseParenToken
.
prototype
.
tokenType
=
"
symbol
"
;
CloseParenToken
.
prototype
.
text
=
"
)
"
;
function
IncludeMatchToken
(
)
{
return
this
;
}
IncludeMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
IncludeMatchToken
.
prototype
.
tokenType
=
"
includes
"
;
function
DashMatchToken
(
)
{
return
this
;
}
DashMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
DashMatchToken
.
prototype
.
tokenType
=
"
dashmatch
"
;
function
PrefixMatchToken
(
)
{
return
this
;
}
PrefixMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
PrefixMatchToken
.
prototype
.
tokenType
=
"
beginsmatch
"
;
function
SuffixMatchToken
(
)
{
return
this
;
}
SuffixMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
SuffixMatchToken
.
prototype
.
tokenType
=
"
endsmatch
"
;
function
SubstringMatchToken
(
)
{
return
this
;
}
SubstringMatchToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
SubstringMatchToken
.
prototype
.
tokenType
=
"
containsmatch
"
;
function
ColumnToken
(
)
{
return
this
;
}
ColumnToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
ColumnToken
.
prototype
.
tokenType
=
"
|
|
"
;
function
EOFToken
(
)
{
return
this
;
}
EOFToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
EOFToken
.
prototype
.
tokenType
=
"
EOF
"
;
EOFToken
.
prototype
.
toSource
=
function
(
)
{
return
"
"
;
}
;
function
DelimToken
(
code
)
{
this
.
value
=
stringFromCode
(
code
)
;
this
.
text
=
this
.
value
;
return
this
;
}
DelimToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
DelimToken
.
prototype
.
tokenType
=
"
symbol
"
;
DelimToken
.
prototype
.
toString
=
function
(
)
{
return
"
DELIM
(
"
+
this
.
value
+
"
)
"
;
}
;
DelimToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
return
json
;
}
;
DelimToken
.
prototype
.
toSource
=
function
(
)
{
if
(
this
.
value
=
=
"
\
\
"
)
return
"
\
\
\
n
"
;
else
return
this
.
value
;
}
;
function
StringValuedToken
(
)
{
throw
"
Abstract
Base
Class
"
;
}
StringValuedToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
StringValuedToken
.
prototype
.
ASCIIMatch
=
function
(
str
)
{
return
this
.
value
.
toLowerCase
(
)
=
=
str
.
toLowerCase
(
)
;
}
;
StringValuedToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
return
json
;
}
;
function
IdentToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
IdentToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
IdentToken
.
prototype
.
tokenType
=
"
ident
"
;
IdentToken
.
prototype
.
toString
=
function
(
)
{
return
"
IDENT
(
"
+
this
.
value
+
"
)
"
;
}
;
IdentToken
.
prototype
.
toSource
=
function
(
)
{
return
escapeIdent
(
this
.
value
)
;
}
;
function
FunctionToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
this
.
mirror
=
"
)
"
;
}
FunctionToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
FunctionToken
.
prototype
.
tokenType
=
"
function
"
;
FunctionToken
.
prototype
.
toString
=
function
(
)
{
return
"
FUNCTION
(
"
+
this
.
value
+
"
)
"
;
}
;
FunctionToken
.
prototype
.
toSource
=
function
(
)
{
return
escapeIdent
(
this
.
value
)
+
"
(
"
;
}
;
function
AtKeywordToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
AtKeywordToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
AtKeywordToken
.
prototype
.
tokenType
=
"
at
"
;
AtKeywordToken
.
prototype
.
toString
=
function
(
)
{
return
"
AT
(
"
+
this
.
value
+
"
)
"
;
}
;
AtKeywordToken
.
prototype
.
toSource
=
function
(
)
{
return
"
"
+
escapeIdent
(
this
.
value
)
;
}
;
function
HashToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
this
.
type
=
"
unrestricted
"
;
}
HashToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
HashToken
.
prototype
.
tokenType
=
"
hash
"
;
HashToken
.
prototype
.
toString
=
function
(
)
{
return
"
HASH
(
"
+
this
.
value
+
"
)
"
;
}
;
HashToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
type
=
this
.
type
;
return
json
;
}
;
HashToken
.
prototype
.
toSource
=
function
(
)
{
if
(
this
.
type
=
=
"
id
"
)
{
return
"
#
"
+
escapeIdent
(
this
.
value
)
;
}
else
{
return
"
#
"
+
escapeHash
(
this
.
value
)
;
}
}
;
function
StringToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
StringToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
StringToken
.
prototype
.
tokenType
=
"
string
"
;
StringToken
.
prototype
.
toString
=
function
(
)
{
return
'
"
'
+
escapeString
(
this
.
value
)
+
'
"
'
;
}
;
function
CommentToken
(
val
)
{
this
.
value
=
val
;
}
CommentToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
CommentToken
.
prototype
.
tokenType
=
"
comment
"
;
CommentToken
.
prototype
.
toString
=
function
(
)
{
return
'
/
*
'
+
this
.
value
+
'
*
/
'
;
}
CommentToken
.
prototype
.
toSource
=
CommentToken
.
prototype
.
toString
;
function
URLToken
(
val
)
{
this
.
value
=
val
;
this
.
text
=
val
;
}
URLToken
.
prototype
=
Object
.
create
(
StringValuedToken
.
prototype
)
;
URLToken
.
prototype
.
tokenType
=
"
url
"
;
URLToken
.
prototype
.
toString
=
function
(
)
{
return
"
URL
(
"
+
this
.
value
+
"
)
"
;
}
;
URLToken
.
prototype
.
toSource
=
function
(
)
{
return
'
url
(
"
'
+
escapeString
(
this
.
value
)
+
'
"
)
'
;
}
;
function
NumberToken
(
)
{
this
.
value
=
null
;
this
.
type
=
"
integer
"
;
this
.
repr
=
"
"
;
}
NumberToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
NumberToken
.
prototype
.
tokenType
=
"
number
"
;
NumberToken
.
prototype
.
toString
=
function
(
)
{
if
(
this
.
type
=
=
"
integer
"
)
return
"
INT
(
"
+
this
.
value
+
"
)
"
;
return
"
NUMBER
(
"
+
this
.
value
+
"
)
"
;
}
;
NumberToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
type
=
this
.
type
;
json
.
repr
=
this
.
repr
;
return
json
;
}
;
NumberToken
.
prototype
.
toSource
=
function
(
)
{
return
this
.
repr
;
}
;
function
PercentageToken
(
)
{
this
.
value
=
null
;
this
.
repr
=
"
"
;
}
PercentageToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
PercentageToken
.
prototype
.
tokenType
=
"
percentage
"
;
PercentageToken
.
prototype
.
toString
=
function
(
)
{
return
"
PERCENTAGE
(
"
+
this
.
value
+
"
)
"
;
}
;
PercentageToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
repr
=
this
.
repr
;
return
json
;
}
;
PercentageToken
.
prototype
.
toSource
=
function
(
)
{
return
this
.
repr
+
"
%
"
;
}
;
function
DimensionToken
(
)
{
this
.
value
=
null
;
this
.
type
=
"
integer
"
;
this
.
repr
=
"
"
;
this
.
unit
=
"
"
;
}
DimensionToken
.
prototype
=
Object
.
create
(
CSSParserToken
.
prototype
)
;
DimensionToken
.
prototype
.
tokenType
=
"
dimension
"
;
DimensionToken
.
prototype
.
toString
=
function
(
)
{
return
"
DIM
(
"
+
this
.
value
+
"
"
+
this
.
unit
+
"
)
"
;
}
;
DimensionToken
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
value
=
this
.
value
;
json
.
type
=
this
.
type
;
json
.
repr
=
this
.
repr
;
json
.
unit
=
this
.
unit
;
return
json
;
}
;
DimensionToken
.
prototype
.
toSource
=
function
(
)
{
var
source
=
this
.
repr
;
var
unit
=
escapeIdent
(
this
.
unit
)
;
if
(
unit
[
0
]
.
toLowerCase
(
)
=
=
"
e
"
&
&
(
unit
[
1
]
=
=
"
-
"
|
|
between
(
unit
.
charCodeAt
(
1
)
0x30
0x39
)
)
)
{
unit
=
"
\
\
65
"
+
unit
.
slice
(
1
unit
.
length
)
;
}
return
source
+
unit
;
}
;
function
escapeIdent
(
string
)
{
string
=
'
'
+
string
;
var
result
=
'
'
;
var
firstcode
=
string
.
charCodeAt
(
0
)
;
for
(
var
i
=
0
;
i
<
string
.
length
;
i
+
+
)
{
var
code
=
string
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
0x0
)
{
throw
new
InvalidCharacterError
(
'
Invalid
character
:
the
input
contains
U
+
0000
.
'
)
;
}
if
(
between
(
code
0x1
0x1f
)
|
|
code
=
=
0x7f
|
|
(
i
=
=
=
0
&
&
between
(
code
0x30
0x39
)
)
|
|
(
i
=
=
1
&
&
between
(
code
0x30
0x39
)
&
&
firstcode
=
=
0x2d
)
)
{
result
+
=
'
\
\
'
+
code
.
toString
(
16
)
+
'
'
;
}
else
if
(
code
>
=
0x80
|
|
code
=
=
0x2d
|
|
code
=
=
0x5f
|
|
between
(
code
0x30
0x39
)
|
|
between
(
code
0x41
0x5a
)
|
|
between
(
code
0x61
0x7a
)
)
{
result
+
=
string
[
i
]
;
}
else
{
result
+
=
'
\
\
'
+
string
[
i
]
;
}
}
return
result
;
}
function
escapeHash
(
string
)
{
string
=
'
'
+
string
;
var
result
=
'
'
;
for
(
var
i
=
0
;
i
<
string
.
length
;
i
+
+
)
{
var
code
=
string
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
0x0
)
{
throw
new
InvalidCharacterError
(
'
Invalid
character
:
the
input
contains
U
+
0000
.
'
)
;
}
if
(
code
>
=
0x80
|
|
code
=
=
0x2d
|
|
code
=
=
0x5f
|
|
between
(
code
0x30
0x39
)
|
|
between
(
code
0x41
0x5a
)
|
|
between
(
code
0x61
0x7a
)
)
{
result
+
=
string
[
i
]
;
}
else
{
result
+
=
'
\
\
'
+
code
.
toString
(
16
)
+
'
'
;
}
}
return
result
;
}
function
escapeString
(
string
)
{
string
=
'
'
+
string
;
var
result
=
'
'
;
for
(
var
i
=
0
;
i
<
string
.
length
;
i
+
+
)
{
var
code
=
string
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
0x0
)
{
throw
new
InvalidCharacterError
(
'
Invalid
character
:
the
input
contains
U
+
0000
.
'
)
;
}
if
(
between
(
code
0x1
0x1f
)
|
|
code
=
=
0x7f
)
{
result
+
=
'
\
\
'
+
code
.
toString
(
16
)
+
'
'
;
}
else
if
(
code
=
=
0x22
|
|
code
=
=
0x5c
)
{
result
+
=
'
\
\
'
+
string
[
i
]
;
}
else
{
result
+
=
string
[
i
]
;
}
}
return
result
;
}
exports
.
tokenize
=
tokenize
;
exports
.
IdentToken
=
IdentToken
;
exports
.
FunctionToken
=
FunctionToken
;
exports
.
AtKeywordToken
=
AtKeywordToken
;
exports
.
HashToken
=
HashToken
;
exports
.
StringToken
=
StringToken
;
exports
.
BadStringToken
=
BadStringToken
;
exports
.
URLToken
=
URLToken
;
exports
.
BadURLToken
=
BadURLToken
;
exports
.
DelimToken
=
DelimToken
;
exports
.
NumberToken
=
NumberToken
;
exports
.
PercentageToken
=
PercentageToken
;
exports
.
DimensionToken
=
DimensionToken
;
exports
.
IncludeMatchToken
=
IncludeMatchToken
;
exports
.
DashMatchToken
=
DashMatchToken
;
exports
.
PrefixMatchToken
=
PrefixMatchToken
;
exports
.
SuffixMatchToken
=
SuffixMatchToken
;
exports
.
SubstringMatchToken
=
SubstringMatchToken
;
exports
.
ColumnToken
=
ColumnToken
;
exports
.
WhitespaceToken
=
WhitespaceToken
;
exports
.
CDOToken
=
CDOToken
;
exports
.
CDCToken
=
CDCToken
;
exports
.
ColonToken
=
ColonToken
;
exports
.
SemicolonToken
=
SemicolonToken
;
exports
.
CommaToken
=
CommaToken
;
exports
.
OpenParenToken
=
OpenParenToken
;
exports
.
CloseParenToken
=
CloseParenToken
;
exports
.
OpenSquareToken
=
OpenSquareToken
;
exports
.
CloseSquareToken
=
CloseSquareToken
;
exports
.
OpenCurlyToken
=
OpenCurlyToken
;
exports
.
CloseCurlyToken
=
CloseCurlyToken
;
exports
.
EOFToken
=
EOFToken
;
exports
.
CSSParserToken
=
CSSParserToken
;
exports
.
GroupingToken
=
GroupingToken
;
function
TokenStream
(
tokens
)
{
this
.
tokens
=
tokens
;
this
.
token
=
undefined
;
this
.
stored
=
[
]
;
}
TokenStream
.
prototype
.
consume
=
function
(
num
)
{
if
(
num
=
=
=
undefined
)
num
=
1
;
while
(
num
-
-
>
0
)
{
if
(
this
.
stored
.
length
>
0
)
{
this
.
token
=
this
.
stored
.
shift
(
)
;
}
else
{
var
n
=
this
.
tokens
.
next
(
)
;
while
(
!
n
.
done
&
&
n
.
value
instanceof
CommentToken
)
{
n
=
this
.
tokens
.
next
(
)
;
}
if
(
n
.
done
)
{
this
.
token
=
new
EOFToken
(
)
;
break
;
}
this
.
token
=
n
.
value
;
}
}
return
true
;
}
;
TokenStream
.
prototype
.
next
=
function
(
)
{
if
(
this
.
stored
.
length
=
=
=
0
)
{
var
n
=
this
.
tokens
.
next
(
)
;
while
(
!
n
.
done
&
&
n
.
value
instanceof
CommentToken
)
{
n
=
this
.
tokens
.
next
(
)
;
}
if
(
n
.
done
)
return
new
EOFToken
(
)
;
this
.
stored
.
push
(
n
.
value
)
;
}
return
this
.
stored
[
0
]
;
}
;
TokenStream
.
prototype
.
reconsume
=
function
(
)
{
this
.
stored
.
unshift
(
this
.
token
)
;
}
;
function
parseerror
(
s
msg
)
{
console
.
log
(
"
Parse
error
at
token
"
+
s
.
i
+
"
:
"
+
s
.
token
+
"
.
\
n
"
+
msg
)
;
return
true
;
}
function
donothing
(
)
{
return
true
;
}
function
consumeAListOfRules
(
s
topLevel
)
{
var
rules
=
[
]
;
var
rule
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
WhitespaceToken
)
{
continue
;
}
else
if
(
s
.
token
instanceof
EOFToken
)
{
return
rules
;
}
else
if
(
s
.
token
instanceof
CDOToken
|
|
s
.
token
instanceof
CDCToken
)
{
if
(
topLevel
=
=
"
top
-
level
"
)
continue
;
s
.
reconsume
(
)
;
if
(
rule
=
consumeAQualifiedRule
(
s
)
)
rules
.
push
(
rule
)
;
}
else
if
(
s
.
token
instanceof
AtKeywordToken
)
{
s
.
reconsume
(
)
;
if
(
rule
=
consumeAnAtRule
(
s
)
)
rules
.
push
(
rule
)
;
}
else
{
s
.
reconsume
(
)
;
if
(
rule
=
consumeAQualifiedRule
(
s
)
)
rules
.
push
(
rule
)
;
}
}
}
function
consumeAnAtRule
(
s
)
{
s
.
consume
(
)
;
var
rule
=
new
AtRule
(
s
.
token
.
value
)
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
SemicolonToken
|
|
s
.
token
instanceof
EOFToken
)
{
return
rule
;
}
else
if
(
s
.
token
instanceof
OpenCurlyToken
)
{
rule
.
value
=
consumeASimpleBlock
(
s
)
;
return
rule
;
}
else
{
s
.
reconsume
(
)
;
rule
.
prelude
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
consumeAQualifiedRule
(
s
)
{
var
rule
=
new
QualifiedRule
(
)
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
EOFToken
)
{
parseerror
(
s
"
Hit
EOF
when
trying
to
parse
the
prelude
of
a
qualified
rule
.
"
)
;
return
;
}
else
if
(
s
.
token
instanceof
OpenCurlyToken
)
{
rule
.
value
=
consumeASimpleBlock
(
s
)
;
return
rule
;
}
else
{
s
.
reconsume
(
)
;
rule
.
prelude
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
consumeAListOfDeclarations
(
s
)
{
var
decls
=
[
]
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
WhitespaceToken
|
|
s
.
token
instanceof
SemicolonToken
)
{
donothing
(
)
;
}
else
if
(
s
.
token
instanceof
EOFToken
)
{
return
decls
;
}
else
if
(
s
.
token
instanceof
AtKeywordToken
)
{
s
.
reconsume
(
)
;
decls
.
push
(
consumeAnAtRule
(
s
)
)
;
}
else
if
(
s
.
token
instanceof
IdentToken
)
{
var
temp
=
[
s
.
token
]
;
while
(
!
(
s
.
next
(
)
instanceof
SemicolonToken
|
|
s
.
next
(
)
instanceof
EOFToken
)
)
temp
.
push
(
consumeAComponentValue
(
s
)
)
;
var
decl
;
if
(
decl
=
consumeADeclaration
(
new
TokenStream
(
temp
)
)
)
decls
.
push
(
decl
)
;
}
else
{
parseerror
(
s
)
;
s
.
reconsume
(
)
;
while
(
!
(
s
.
next
(
)
instanceof
SemicolonToken
|
|
s
.
next
(
)
instanceof
EOFToken
)
)
consumeAComponentValue
(
s
)
;
}
}
}
function
consumeADeclaration
(
s
)
{
s
.
consume
(
)
;
var
decl
=
new
Declaration
(
s
.
token
.
value
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
!
(
s
.
next
(
)
instanceof
ColonToken
)
)
{
parseerror
(
s
)
;
return
;
}
else
{
s
.
consume
(
)
;
}
while
(
!
(
s
.
next
(
)
instanceof
EOFToken
)
)
{
decl
.
value
.
push
(
consumeAComponentValue
(
s
)
)
;
}
var
foundImportant
=
false
;
for
(
var
i
=
decl
.
value
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
decl
.
value
[
i
]
instanceof
WhitespaceToken
)
{
continue
;
}
else
if
(
decl
.
value
[
i
]
instanceof
IdentToken
&
&
decl
.
value
[
i
]
.
ASCIIMatch
(
"
important
"
)
)
{
foundImportant
=
true
;
}
else
if
(
foundImportant
&
&
decl
.
value
[
i
]
instanceof
DelimToken
&
&
decl
.
value
[
i
]
.
value
=
=
"
!
"
)
{
decl
.
value
.
splice
(
i
decl
.
value
.
length
)
;
decl
.
important
=
true
;
break
;
}
else
{
break
;
}
}
return
decl
;
}
function
consumeAComponentValue
(
s
)
{
s
.
consume
(
)
;
if
(
s
.
token
instanceof
OpenCurlyToken
|
|
s
.
token
instanceof
OpenSquareToken
|
|
s
.
token
instanceof
OpenParenToken
)
return
consumeASimpleBlock
(
s
)
;
if
(
s
.
token
instanceof
FunctionToken
)
return
consumeAFunction
(
s
)
;
return
s
.
token
;
}
function
consumeASimpleBlock
(
s
)
{
var
mirror
=
s
.
token
.
mirror
;
var
block
=
new
SimpleBlock
(
s
.
token
.
value
)
;
block
.
startToken
=
s
.
token
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
EOFToken
|
|
(
s
.
token
instanceof
GroupingToken
&
&
s
.
token
.
value
=
=
mirror
)
)
return
block
;
else
{
s
.
reconsume
(
)
;
block
.
value
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
consumeAFunction
(
s
)
{
var
func
=
new
Func
(
s
.
token
.
value
)
;
while
(
s
.
consume
(
)
)
{
if
(
s
.
token
instanceof
EOFToken
|
|
s
.
token
instanceof
CloseParenToken
)
return
func
;
else
{
s
.
reconsume
(
)
;
func
.
value
.
push
(
consumeAComponentValue
(
s
)
)
;
}
}
}
function
normalizeInput
(
input
)
{
if
(
typeof
input
=
=
"
string
"
)
return
new
TokenStream
(
tokenize
(
input
)
)
;
if
(
input
instanceof
TokenStream
)
return
input
;
if
(
typeof
(
input
.
next
)
=
=
"
function
"
)
return
new
TokenStream
(
input
)
;
if
(
input
.
length
!
=
=
undefined
)
return
new
TokenStream
(
input
[
Symbol
.
iterator
]
(
)
)
;
else
throw
SyntaxError
(
input
)
;
}
function
parseAStylesheet
(
s
)
{
s
=
normalizeInput
(
s
)
;
var
sheet
=
new
Stylesheet
(
)
;
sheet
.
value
=
consumeAListOfRules
(
s
"
top
-
level
"
)
;
return
sheet
;
}
function
parseAListOfRules
(
s
)
{
s
=
normalizeInput
(
s
)
;
return
consumeAListOfRules
(
s
)
;
}
function
parseARule
(
s
)
{
s
=
normalizeInput
(
s
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
s
.
next
(
)
instanceof
EOFToken
)
throw
SyntaxError
(
)
;
var
rule
;
var
startToken
=
s
.
next
(
)
;
if
(
startToken
instanceof
AtKeywordToken
)
{
rule
=
consumeAnAtRule
(
s
)
;
}
else
{
rule
=
consumeAQualifiedRule
(
s
)
;
if
(
!
rule
)
throw
SyntaxError
(
)
;
}
rule
.
startToken
=
startToken
;
rule
.
endToken
=
s
.
token
;
return
rule
;
}
function
parseADeclaration
(
s
)
{
s
=
normalizeInput
(
s
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
!
(
s
.
next
(
)
instanceof
IdentToken
)
)
throw
SyntaxError
(
)
;
var
decl
=
consumeADeclaration
(
s
)
;
if
(
decl
)
return
decl
;
else
throw
SyntaxError
(
)
;
}
function
parseAListOfDeclarations
(
s
)
{
s
=
normalizeInput
(
s
)
;
return
consumeAListOfDeclarations
(
s
)
;
}
function
parseAComponentValue
(
s
)
{
s
=
normalizeInput
(
s
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
s
.
next
(
)
instanceof
EOFToken
)
throw
SyntaxError
(
)
;
var
val
=
consumeAComponentValue
(
s
)
;
if
(
!
val
)
throw
SyntaxError
(
)
;
while
(
s
.
next
(
)
instanceof
WhitespaceToken
)
s
.
consume
(
)
;
if
(
s
.
next
(
)
instanceof
EOFToken
)
return
val
;
throw
SyntaxError
(
)
;
}
function
parseAListOfComponentValues
(
s
)
{
s
=
normalizeInput
(
s
)
;
var
vals
=
[
]
;
while
(
true
)
{
var
val
=
consumeAComponentValue
(
s
)
;
if
(
val
instanceof
EOFToken
)
return
vals
;
else
vals
.
push
(
val
)
;
}
}
function
parseACommaSeparatedListOfComponentValues
(
s
)
{
s
=
normalizeInput
(
s
)
;
var
listOfCVLs
=
[
]
;
while
(
true
)
{
var
vals
=
[
]
;
while
(
true
)
{
var
val
=
consumeAComponentValue
(
s
)
;
if
(
val
instanceof
EOFToken
)
{
listOfCVLs
.
push
(
vals
)
;
return
listOfCVLs
;
}
else
if
(
val
instanceof
CommaToken
)
{
listOfCVLs
.
push
(
vals
)
;
break
;
}
else
{
vals
.
push
(
val
)
;
}
}
}
}
function
CSSParserRule
(
)
{
throw
"
Abstract
Base
Class
"
;
}
CSSParserRule
.
prototype
.
toString
=
function
(
indent
)
{
return
JSON
.
stringify
(
this
null
indent
)
;
}
;
CSSParserRule
.
prototype
.
toJSON
=
function
(
)
{
return
{
type
:
this
.
type
value
:
this
.
value
}
;
}
;
function
Stylesheet
(
)
{
this
.
value
=
[
]
;
return
this
;
}
Stylesheet
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
Stylesheet
.
prototype
.
type
=
"
STYLESHEET
"
;
function
AtRule
(
name
)
{
this
.
name
=
name
;
this
.
prelude
=
[
]
;
this
.
value
=
null
;
return
this
;
}
AtRule
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
AtRule
.
prototype
.
type
=
"
AT
-
RULE
"
;
AtRule
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
json
.
prelude
=
this
.
prelude
;
return
json
;
}
;
function
QualifiedRule
(
)
{
this
.
prelude
=
[
]
;
this
.
value
=
[
]
;
return
this
;
}
QualifiedRule
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
QualifiedRule
.
prototype
.
type
=
"
QUALIFIED
-
RULE
"
;
QualifiedRule
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
prelude
=
this
.
prelude
;
return
json
;
}
;
function
Declaration
(
name
)
{
this
.
name
=
name
;
this
.
value
=
[
]
;
this
.
important
=
false
;
return
this
;
}
Declaration
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
Declaration
.
prototype
.
type
=
"
DECLARATION
"
;
Declaration
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
json
.
important
=
this
.
important
;
return
json
;
}
;
function
SimpleBlock
(
type
)
{
this
.
name
=
type
;
this
.
value
=
[
]
;
return
this
;
}
SimpleBlock
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
SimpleBlock
.
prototype
.
type
=
"
BLOCK
"
;
SimpleBlock
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
return
json
;
}
;
function
Func
(
name
)
{
this
.
name
=
name
;
this
.
value
=
[
]
;
return
this
;
}
Func
.
prototype
=
Object
.
create
(
CSSParserRule
.
prototype
)
;
Func
.
prototype
.
type
=
"
FUNCTION
"
;
Func
.
prototype
.
toJSON
=
function
(
)
{
var
json
=
this
.
constructor
.
prototype
.
constructor
.
prototype
.
toJSON
.
call
(
this
)
;
json
.
name
=
this
.
name
;
return
json
;
}
;
function
CSSLexer
(
text
)
{
this
.
stream
=
tokenize
(
text
{
loc
:
true
offsets
:
true
keepComments
:
true
}
)
;
this
.
lineNumber
=
0
;
this
.
columnNumber
=
0
;
return
this
;
}
CSSLexer
.
prototype
.
performEOFFixup
=
function
(
input
preserveBackslash
)
{
return
"
"
;
}
;
CSSLexer
.
prototype
.
nextToken
=
function
(
)
{
if
(
!
this
.
stream
)
{
return
null
;
}
let
v
=
this
.
stream
.
next
(
)
;
if
(
v
.
done
|
|
v
.
value
.
tokenType
=
=
=
"
EOF
"
)
{
this
.
stream
=
null
;
return
null
;
}
this
.
lineNumber
=
v
.
value
.
loc
.
start
.
line
;
this
.
columnNumber
=
v
.
value
.
loc
.
start
.
column
;
return
v
.
value
;
}
;
exports
.
CSSParserRule
=
CSSParserRule
;
exports
.
Stylesheet
=
Stylesheet
;
exports
.
AtRule
=
AtRule
;
exports
.
QualifiedRule
=
QualifiedRule
;
exports
.
Declaration
=
Declaration
;
exports
.
SimpleBlock
=
SimpleBlock
;
exports
.
Func
=
Func
;
exports
.
parseAStylesheet
=
parseAStylesheet
;
exports
.
parseAListOfRules
=
parseAListOfRules
;
exports
.
parseARule
=
parseARule
;
exports
.
parseADeclaration
=
parseADeclaration
;
exports
.
parseAListOfDeclarations
=
parseAListOfDeclarations
;
exports
.
parseAComponentValue
=
parseAComponentValue
;
exports
.
parseAListOfComponentValues
=
parseAListOfComponentValues
;
exports
.
parseACommaSeparatedListOfComponentValues
=
parseACommaSeparatedListOfComponentValues
;
exports
.
CSSLexer
=
CSSLexer
;
}
)
)
;
}
function
(
module
exports
)
{
var
cssColors
=
{
aliceblue
:
[
240
248
255
]
antiquewhite
:
[
250
235
215
]
aqua
:
[
0
255
255
]
aquamarine
:
[
127
255
212
]
azure
:
[
240
255
255
]
beige
:
[
245
245
220
]
bisque
:
[
255
228
196
]
black
:
[
0
0
0
]
blanchedalmond
:
[
255
235
205
]
blue
:
[
0
0
255
]
blueviolet
:
[
138
43
226
]
brown
:
[
165
42
42
]
burlywood
:
[
222
184
135
]
cadetblue
:
[
95
158
160
]
chartreuse
:
[
127
255
0
]
chocolate
:
[
210
105
30
]
coral
:
[
255
127
80
]
cornflowerblue
:
[
100
149
237
]
cornsilk
:
[
255
248
220
]
crimson
:
[
220
20
60
]
cyan
:
[
0
255
255
]
darkblue
:
[
0
0
139
]
darkcyan
:
[
0
139
139
]
darkgoldenrod
:
[
184
134
11
]
darkgray
:
[
169
169
169
]
darkgreen
:
[
0
100
0
]
darkgrey
:
[
169
169
169
]
darkkhaki
:
[
189
183
107
]
darkmagenta
:
[
139
0
139
]
darkolivegreen
:
[
85
107
47
]
darkorange
:
[
255
140
0
]
darkorchid
:
[
153
50
204
]
darkred
:
[
139
0
0
]
darksalmon
:
[
233
150
122
]
darkseagreen
:
[
143
188
143
]
darkslateblue
:
[
72
61
139
]
darkslategray
:
[
47
79
79
]
darkslategrey
:
[
47
79
79
]
darkturquoise
:
[
0
206
209
]
darkviolet
:
[
148
0
211
]
deeppink
:
[
255
20
147
]
deepskyblue
:
[
0
191
255
]
dimgray
:
[
105
105
105
]
dimgrey
:
[
105
105
105
]
dodgerblue
:
[
30
144
255
]
firebrick
:
[
178
34
34
]
floralwhite
:
[
255
250
240
]
forestgreen
:
[
34
139
34
]
fuchsia
:
[
255
0
255
]
gainsboro
:
[
220
220
220
]
ghostwhite
:
[
248
248
255
]
gold
:
[
255
215
0
]
goldenrod
:
[
218
165
32
]
gray
:
[
128
128
128
]
grey
:
[
128
128
128
]
green
:
[
0
128
0
]
greenyellow
:
[
173
255
47
]
honeydew
:
[
240
255
240
]
hotpink
:
[
255
105
180
]
indianred
:
[
205
92
92
]
indigo
:
[
75
0
130
]
ivory
:
[
255
255
240
]
khaki
:
[
240
230
140
]
lavender
:
[
230
230
250
]
lavenderblush
:
[
255
240
245
]
lawngreen
:
[
124
252
0
]
lemonchiffon
:
[
255
250
205
]
lightblue
:
[
173
216
230
]
lightcoral
:
[
240
128
128
]
lightcyan
:
[
224
255
255
]
lightgoldenrodyellow
:
[
250
250
210
]
lightgray
:
[
211
211
211
]
lightgreen
:
[
144
238
144
]
lightgrey
:
[
211
211
211
]
lightpink
:
[
255
182
193
]
lightsalmon
:
[
255
160
122
]
lightseagreen
:
[
32
178
170
]
lightskyblue
:
[
135
206
250
]
lightslategray
:
[
119
136
153
]
lightslategrey
:
[
119
136
153
]
lightsteelblue
:
[
176
196
222
]
lightyellow
:
[
255
255
224
]
lime
:
[
0
255
0
]
limegreen
:
[
50
205
50
]
linen
:
[
250
240
230
]
magenta
:
[
255
0
255
]
maroon
:
[
128
0
0
]
mediumaquamarine
:
[
102
205
170
]
mediumblue
:
[
0
0
205
]
mediumorchid
:
[
186
85
211
]
mediumpurple
:
[
147
112
219
]
mediumseagreen
:
[
60
179
113
]
mediumslateblue
:
[
123
104
238
]
mediumspringgreen
:
[
0
250
154
]
mediumturquoise
:
[
72
209
204
]
mediumvioletred
:
[
199
21
133
]
midnightblue
:
[
25
25
112
]
mintcream
:
[
245
255
250
]
mistyrose
:
[
255
228
225
]
moccasin
:
[
255
228
181
]
navajowhite
:
[
255
222
173
]
navy
:
[
0
0
128
]
oldlace
:
[
253
245
230
]
olive
:
[
128
128
0
]
olivedrab
:
[
107
142
35
]
orange
:
[
255
165
0
]
orangered
:
[
255
69
0
]
orchid
:
[
218
112
214
]
palegoldenrod
:
[
238
232
170
]
palegreen
:
[
152
251
152
]
paleturquoise
:
[
175
238
238
]
palevioletred
:
[
219
112
147
]
papayawhip
:
[
255
239
213
]
peachpuff
:
[
255
218
185
]
peru
:
[
205
133
63
]
pink
:
[
255
192
203
]
plum
:
[
221
160
221
]
powderblue
:
[
176
224
230
]
purple
:
[
128
0
128
]
rebeccapurple
:
[
102
51
153
]
red
:
[
255
0
0
]
rosybrown
:
[
188
143
143
]
royalblue
:
[
65
105
225
]
saddlebrown
:
[
139
69
19
]
salmon
:
[
250
128
114
]
sandybrown
:
[
244
164
96
]
seagreen
:
[
46
139
87
]
seashell
:
[
255
245
238
]
sienna
:
[
160
82
45
]
silver
:
[
192
192
192
]
skyblue
:
[
135
206
235
]
slateblue
:
[
106
90
205
]
slategray
:
[
112
128
144
]
slategrey
:
[
112
128
144
]
snow
:
[
255
250
250
]
springgreen
:
[
0
255
127
]
steelblue
:
[
70
130
180
]
tan
:
[
210
180
140
]
teal
:
[
0
128
128
]
thistle
:
[
216
191
216
]
tomato
:
[
255
99
71
]
turquoise
:
[
64
224
208
]
violet
:
[
238
130
238
]
wheat
:
[
245
222
179
]
white
:
[
255
255
255
]
whitesmoke
:
[
245
245
245
]
yellow
:
[
255
255
0
]
yellowgreen
:
[
154
205
50
]
}
;
module
.
exports
=
{
cssColors
}
;
}
function
(
module
exports
)
{
var
cssProperties
=
{
"
-
moz
-
appearance
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
gtk
-
info
-
bar
"
"
-
moz
-
mac
-
disclosure
-
button
-
closed
"
"
-
moz
-
mac
-
disclosure
-
button
-
open
"
"
-
moz
-
mac
-
fullscreen
-
button
"
"
-
moz
-
mac
-
help
-
button
"
"
-
moz
-
mac
-
vibrancy
-
dark
"
"
-
moz
-
mac
-
vibrancy
-
light
"
"
-
moz
-
win
-
borderless
-
glass
"
"
-
moz
-
win
-
browsertabbar
-
toolbox
"
"
-
moz
-
win
-
communications
-
toolbox
"
"
-
moz
-
win
-
exclude
-
glass
"
"
-
moz
-
win
-
glass
"
"
-
moz
-
win
-
media
-
toolbox
"
"
-
moz
-
window
-
button
-
box
"
"
-
moz
-
window
-
button
-
box
-
maximized
"
"
-
moz
-
window
-
button
-
close
"
"
-
moz
-
window
-
button
-
maximize
"
"
-
moz
-
window
-
button
-
minimize
"
"
-
moz
-
window
-
button
-
restore
"
"
-
moz
-
window
-
frame
-
bottom
"
"
-
moz
-
window
-
frame
-
left
"
"
-
moz
-
window
-
frame
-
right
"
"
-
moz
-
window
-
titlebar
"
"
-
moz
-
window
-
titlebar
-
maximized
"
"
button
"
"
button
-
arrow
-
down
"
"
button
-
arrow
-
next
"
"
button
-
arrow
-
previous
"
"
button
-
arrow
-
up
"
"
button
-
bevel
"
"
button
-
focus
"
"
caret
"
"
checkbox
"
"
checkbox
-
container
"
"
checkbox
-
label
"
"
checkmenuitem
"
"
dialog
"
"
dualbutton
"
"
groupbox
"
"
inherit
"
"
initial
"
"
listbox
"
"
listitem
"
"
menuarrow
"
"
menubar
"
"
menucheckbox
"
"
menuimage
"
"
menuitem
"
"
menuitemtext
"
"
menulist
"
"
menulist
-
button
"
"
menulist
-
text
"
"
menulist
-
textfield
"
"
menupopup
"
"
menuradio
"
"
menuseparator
"
"
meterbar
"
"
meterchunk
"
"
none
"
"
number
-
input
"
"
progressbar
"
"
progressbar
-
vertical
"
"
progresschunk
"
"
progresschunk
-
vertical
"
"
radio
"
"
radio
-
container
"
"
radio
-
label
"
"
radiomenuitem
"
"
range
"
"
range
-
thumb
"
"
resizer
"
"
resizerpanel
"
"
scale
-
horizontal
"
"
scale
-
vertical
"
"
scalethumb
-
horizontal
"
"
scalethumb
-
vertical
"
"
scalethumbend
"
"
scalethumbstart
"
"
scalethumbtick
"
"
scrollbar
"
"
scrollbar
-
small
"
"
scrollbarbutton
-
down
"
"
scrollbarbutton
-
left
"
"
scrollbarbutton
-
right
"
"
scrollbarbutton
-
up
"
"
scrollbarthumb
-
horizontal
"
"
scrollbarthumb
-
vertical
"
"
scrollbartrack
-
horizontal
"
"
scrollbartrack
-
vertical
"
"
searchfield
"
"
separator
"
"
spinner
"
"
spinner
-
downbutton
"
"
spinner
-
textfield
"
"
spinner
-
upbutton
"
"
splitter
"
"
statusbar
"
"
statusbarpanel
"
"
tab
"
"
tab
-
scroll
-
arrow
-
back
"
"
tab
-
scroll
-
arrow
-
forward
"
"
tabpanel
"
"
tabpanels
"
"
textfield
"
"
textfield
-
multiline
"
"
toolbar
"
"
toolbarbutton
"
"
toolbarbutton
-
dropdown
"
"
toolbargripper
"
"
toolbox
"
"
tooltip
"
"
treeheader
"
"
treeheadercell
"
"
treeheadersortarrow
"
"
treeitem
"
"
treeline
"
"
treetwisty
"
"
treetwistyopen
"
"
treeview
"
"
unset
"
"
window
"
]
}
"
-
moz
-
outline
-
radius
-
topleft
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
-
topright
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
-
bottomright
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
-
bottomleft
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
tab
-
size
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
delay
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
direction
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
animation
-
duration
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
fill
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
backwards
"
"
both
"
"
forwards
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
animation
-
iteration
-
count
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
infinite
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
animation
-
name
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
animation
-
play
-
state
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
paused
"
"
running
"
"
unset
"
]
}
"
animation
-
timing
-
function
"
:
{
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
background
-
attachment
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
fixed
"
"
inherit
"
"
initial
"
"
local
"
"
scroll
"
"
unset
"
]
}
"
background
-
clip
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
background
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
background
-
image
"
:
{
inherited
:
false
supports
:
648
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
background
-
blend
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
color
"
"
color
-
burn
"
"
color
-
dodge
"
"
darken
"
"
difference
"
"
exclusion
"
"
hard
-
light
"
"
hue
"
"
inherit
"
"
initial
"
"
lighten
"
"
luminosity
"
"
multiply
"
"
normal
"
"
overlay
"
"
saturation
"
"
screen
"
"
soft
-
light
"
"
unset
"
]
}
"
background
-
origin
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
background
-
position
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
background
-
repeat
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
no
-
repeat
"
"
repeat
"
"
repeat
-
x
"
"
repeat
-
y
"
"
unset
"
]
}
"
background
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
binding
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
block
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
block
-
end
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
end
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
block
-
end
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
block
-
start
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
start
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
block
-
start
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
bottom
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
bottom
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
bottom
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
bottom
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
collapse
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
collapse
"
"
inherit
"
"
initial
"
"
separate
"
"
unset
"
]
}
"
border
-
image
-
source
"
:
{
inherited
:
false
supports
:
648
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
border
-
image
-
slice
"
:
{
inherited
:
false
supports
:
1026
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
image
-
width
"
:
{
inherited
:
false
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
image
-
outset
"
:
{
inherited
:
false
supports
:
1025
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
image
-
repeat
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
inline
-
end
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
inline
-
end
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
inline
-
end
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
inline
-
start
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
inline
-
start
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
inline
-
start
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
left
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
left
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
left
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
left
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
right
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
right
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
right
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
right
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
spacing
"
:
{
inherited
:
true
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
top
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
top
-
colors
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
top
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
top
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
top
-
left
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
top
-
right
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
bottom
-
right
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
border
-
bottom
-
left
-
radius
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
bottom
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
box
-
decoration
-
break
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
clone
"
"
inherit
"
"
initial
"
"
slice
"
"
unset
"
]
}
"
box
-
shadow
"
:
{
inherited
:
false
supports
:
5
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
box
-
sizing
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
caption
-
side
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
bottom
"
"
bottom
-
outside
"
"
inherit
"
"
initial
"
"
left
"
"
right
"
"
top
"
"
top
-
outside
"
"
unset
"
]
}
"
clear
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
both
"
"
inherit
"
"
initial
"
"
inline
-
end
"
"
inline
-
start
"
"
left
"
"
none
"
"
right
"
"
unset
"
]
}
"
clip
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
color
"
:
{
inherited
:
true
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
column
-
count
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
fill
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
balance
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
gap
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
-
moz
-
column
-
rule
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
column
-
rule
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
-
moz
-
column
-
rule
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
contain
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
layout
"
"
none
"
"
paint
"
"
strict
"
"
style
"
"
unset
"
]
}
"
content
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
control
-
character
-
visibility
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
counter
-
increment
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
counter
-
reset
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
cursor
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
direction
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
ltr
"
"
rtl
"
"
unset
"
]
}
"
display
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
box
"
"
-
moz
-
deck
"
"
-
moz
-
grid
"
"
-
moz
-
grid
-
group
"
"
-
moz
-
grid
-
line
"
"
-
moz
-
groupbox
"
"
-
moz
-
inline
-
box
"
"
-
moz
-
inline
-
grid
"
"
-
moz
-
inline
-
stack
"
"
-
moz
-
popup
"
"
-
moz
-
stack
"
"
block
"
"
contents
"
"
flex
"
"
grid
"
"
inherit
"
"
initial
"
"
inline
"
"
inline
-
block
"
"
inline
-
flex
"
"
inline
-
grid
"
"
inline
-
table
"
"
list
-
item
"
"
none
"
"
ruby
"
"
ruby
-
base
"
"
ruby
-
base
-
container
"
"
ruby
-
text
"
"
ruby
-
text
-
container
"
"
table
"
"
table
-
caption
"
"
table
-
cell
"
"
table
-
column
"
"
table
-
column
-
group
"
"
table
-
footer
-
group
"
"
table
-
header
-
group
"
"
table
-
row
"
"
table
-
row
-
group
"
"
unset
"
]
}
"
empty
-
cells
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
hide
"
"
inherit
"
"
initial
"
"
show
"
"
unset
"
]
}
"
align
-
content
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
align
-
items
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
align
-
self
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
basis
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
direction
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
column
"
"
column
-
reverse
"
"
inherit
"
"
initial
"
"
row
"
"
row
-
reverse
"
"
unset
"
]
}
"
flex
-
grow
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
shrink
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
wrap
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
nowrap
"
"
unset
"
"
wrap
"
"
wrap
-
reverse
"
]
}
"
order
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
justify
-
content
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
justify
-
items
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
justify
-
self
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
float
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
inline
-
end
"
"
inline
-
start
"
"
left
"
"
none
"
"
right
"
"
unset
"
]
}
"
-
moz
-
float
-
edge
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
content
-
box
"
"
inherit
"
"
initial
"
"
margin
-
box
"
"
unset
"
]
}
"
font
-
family
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
feature
-
settings
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
kerning
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
none
"
"
normal
"
"
unset
"
]
}
"
font
-
language
-
override
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
font
-
size
"
:
{
inherited
:
true
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
large
"
"
larger
"
"
medium
"
"
small
"
"
smaller
"
"
unset
"
"
x
-
large
"
"
x
-
small
"
"
xx
-
large
"
"
xx
-
small
"
]
}
"
font
-
size
-
adjust
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
font
-
stretch
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
condensed
"
"
expanded
"
"
extra
-
condensed
"
"
extra
-
expanded
"
"
inherit
"
"
initial
"
"
normal
"
"
semi
-
condensed
"
"
semi
-
expanded
"
"
ultra
-
condensed
"
"
ultra
-
expanded
"
"
unset
"
]
}
"
font
-
style
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
italic
"
"
normal
"
"
oblique
"
"
unset
"
]
}
"
font
-
synthesis
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
alternates
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
caps
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
inherit
"
"
initial
"
"
normal
"
"
petite
-
caps
"
"
small
-
caps
"
"
titling
-
caps
"
"
unicase
"
"
unset
"
]
}
"
font
-
variant
-
east
-
asian
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
ligatures
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
numeric
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
font
-
variant
-
position
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
sub
"
"
super
"
"
unset
"
]
}
"
font
-
weight
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
force
-
broken
-
image
-
icon
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
auto
-
flow
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
auto
-
columns
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
auto
-
rows
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
template
-
areas
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
template
-
columns
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
template
-
rows
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
-
start
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
-
end
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
-
start
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
-
end
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
-
gap
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
-
gap
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
height
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
image
-
orientation
"
:
{
inherited
:
true
supports
:
16
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
image
-
region
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
ime
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
active
"
"
auto
"
"
disabled
"
"
inactive
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
inline
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
left
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
letter
-
spacing
"
:
{
inherited
:
true
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
line
-
height
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
-
moz
-
block
-
height
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
list
-
style
-
image
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
list
-
style
-
position
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
inside
"
"
outside
"
"
unset
"
]
}
"
list
-
style
-
type
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
block
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
block
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
bottom
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
inline
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
inline
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
left
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
right
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
margin
-
top
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
marker
-
offset
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
max
-
block
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
max
-
height
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
max
-
inline
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
max
-
width
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
calc
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
min
-
height
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
min
-
block
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
min
-
inline
-
size
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
min
-
width
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
mix
-
blend
-
mode
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
color
"
"
color
-
burn
"
"
color
-
dodge
"
"
darken
"
"
difference
"
"
exclusion
"
"
hard
-
light
"
"
hue
"
"
inherit
"
"
initial
"
"
lighten
"
"
luminosity
"
"
multiply
"
"
normal
"
"
overlay
"
"
saturation
"
"
screen
"
"
soft
-
light
"
"
unset
"
]
}
"
isolation
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
isolate
"
"
unset
"
]
}
"
object
-
fit
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
contain
"
"
cover
"
"
fill
"
"
inherit
"
"
initial
"
"
none
"
"
scale
-
down
"
"
unset
"
]
}
"
object
-
position
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
block
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
block
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
inline
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
offset
-
inline
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
opacity
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
orient
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
block
"
"
horizontal
"
"
inherit
"
"
initial
"
"
inline
"
"
unset
"
"
vertical
"
]
}
"
outline
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
outline
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
outline
-
width
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
outline
-
offset
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
overflow
-
x
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
hidden
-
unscrollable
"
"
auto
"
"
hidden
"
"
inherit
"
"
initial
"
"
scroll
"
"
unset
"
"
visible
"
]
}
"
overflow
-
y
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
hidden
-
unscrollable
"
"
auto
"
"
hidden
"
"
inherit
"
"
initial
"
"
scroll
"
"
unset
"
"
visible
"
]
}
"
padding
-
block
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
block
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
bottom
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
inline
-
end
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
inline
-
start
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
left
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
right
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
padding
-
top
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
page
-
break
-
after
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
always
"
"
auto
"
"
avoid
"
"
inherit
"
"
initial
"
"
left
"
"
right
"
"
unset
"
]
}
"
page
-
break
-
before
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
always
"
"
auto
"
"
avoid
"
"
inherit
"
"
initial
"
"
left
"
"
right
"
"
unset
"
]
}
"
page
-
break
-
inside
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
avoid
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
paint
-
order
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
pointer
-
events
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
all
"
"
auto
"
"
fill
"
"
inherit
"
"
initial
"
"
none
"
"
painted
"
"
stroke
"
"
unset
"
"
visible
"
"
visiblefill
"
"
visiblepainted
"
"
visiblestroke
"
]
}
"
position
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
absolute
"
"
fixed
"
"
inherit
"
"
initial
"
"
relative
"
"
static
"
"
sticky
"
"
unset
"
]
}
"
quotes
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
resize
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
both
"
"
horizontal
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
vertical
"
]
}
"
right
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
ruby
-
align
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
center
"
"
inherit
"
"
initial
"
"
space
-
around
"
"
space
-
between
"
"
start
"
"
unset
"
]
}
"
ruby
-
position
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
over
"
"
under
"
"
unset
"
]
}
"
scroll
-
behavior
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
smooth
"
"
unset
"
]
}
"
scroll
-
snap
-
coordinate
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
destination
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
points
-
x
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
points
-
y
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
type
-
x
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mandatory
"
"
none
"
"
proximity
"
"
unset
"
]
}
"
scroll
-
snap
-
type
-
y
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mandatory
"
"
none
"
"
proximity
"
"
unset
"
]
}
"
table
-
layout
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
auto
"
"
fixed
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
align
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
-
moz
-
center
"
"
-
moz
-
left
"
"
-
moz
-
right
"
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
justify
"
"
left
"
"
right
"
"
start
"
"
unset
"
]
}
"
-
moz
-
text
-
align
-
last
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
justify
"
"
left
"
"
right
"
"
start
"
"
unset
"
]
}
"
text
-
decoration
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
text
-
decoration
-
line
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
decoration
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
none
"
"
dashed
"
"
dotted
"
"
double
"
"
inherit
"
"
initial
"
"
solid
"
"
unset
"
"
wavy
"
]
}
"
text
-
indent
"
:
{
inherited
:
true
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
orientation
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mixed
"
"
sideways
"
"
sideways
-
right
"
"
unset
"
"
upright
"
]
}
"
text
-
overflow
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
shadow
"
:
{
inherited
:
true
supports
:
5
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
text
-
size
-
adjust
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
text
-
transform
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
capitalize
"
"
full
-
width
"
"
inherit
"
"
initial
"
"
lowercase
"
"
none
"
"
unset
"
"
uppercase
"
]
}
"
transform
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transform
-
box
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
fill
-
box
"
"
inherit
"
"
initial
"
"
unset
"
"
view
-
box
"
]
}
"
transform
-
origin
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
perspective
-
origin
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
perspective
"
:
{
inherited
:
false
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
transform
-
style
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
flat
"
"
inherit
"
"
initial
"
"
preserve
-
3d
"
"
unset
"
]
}
"
backface
-
visibility
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
top
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transition
-
delay
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transition
-
duration
"
:
{
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
transition
-
property
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
all
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
transition
-
timing
-
function
"
:
{
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
unicode
-
bidi
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
isolate
"
"
-
moz
-
isolate
-
override
"
"
-
moz
-
plaintext
"
"
bidi
-
override
"
"
embed
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
-
moz
-
user
-
focus
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
ignore
"
"
inherit
"
"
initial
"
"
none
"
"
normal
"
"
select
-
after
"
"
select
-
all
"
"
select
-
before
"
"
select
-
menu
"
"
select
-
same
"
"
unset
"
]
}
"
-
moz
-
user
-
input
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
disabled
"
"
enabled
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
user
-
modify
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
read
-
only
"
"
read
-
write
"
"
unset
"
"
write
-
only
"
]
}
"
-
moz
-
user
-
select
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
all
"
"
-
moz
-
none
"
"
-
moz
-
text
"
"
all
"
"
auto
"
"
element
"
"
elements
"
"
inherit
"
"
initial
"
"
none
"
"
text
"
"
toggle
"
"
tri
-
state
"
"
unset
"
]
}
"
vertical
-
align
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
middle
-
with
-
baseline
"
"
baseline
"
"
bottom
"
"
calc
"
"
inherit
"
"
initial
"
"
middle
"
"
sub
"
"
super
"
"
text
-
bottom
"
"
text
-
top
"
"
top
"
"
unset
"
]
}
"
visibility
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
collapse
"
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
white
-
space
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
-
moz
-
pre
-
space
"
"
inherit
"
"
initial
"
"
normal
"
"
nowrap
"
"
pre
"
"
pre
-
line
"
"
pre
-
wrap
"
"
unset
"
]
}
"
width
"
:
{
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
window
-
dragging
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
drag
"
"
inherit
"
"
initial
"
"
no
-
drag
"
"
unset
"
]
}
"
word
-
break
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
break
-
all
"
"
inherit
"
"
initial
"
"
keep
-
all
"
"
normal
"
"
unset
"
]
}
"
word
-
spacing
"
:
{
inherited
:
true
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
word
-
wrap
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
break
-
word
"
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
hyphens
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
manual
"
"
none
"
"
unset
"
]
}
"
writing
-
mode
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
horizontal
-
tb
"
"
inherit
"
"
initial
"
"
lr
"
"
lr
-
tb
"
"
rl
"
"
rl
-
tb
"
"
sideways
-
lr
"
"
sideways
-
rl
"
"
tb
"
"
tb
-
rl
"
"
unset
"
"
vertical
-
lr
"
"
vertical
-
rl
"
]
}
"
z
-
index
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
box
-
align
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
baseline
"
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
start
"
"
stretch
"
"
unset
"
]
}
"
-
moz
-
box
-
direction
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
-
moz
-
box
-
flex
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
box
-
orient
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
block
-
axis
"
"
horizontal
"
"
inherit
"
"
initial
"
"
inline
-
axis
"
"
unset
"
"
vertical
"
]
}
"
-
moz
-
box
-
pack
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
center
"
"
end
"
"
inherit
"
"
initial
"
"
justify
"
"
start
"
"
unset
"
]
}
"
-
moz
-
box
-
ordinal
-
group
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
stack
-
sizing
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
ignore
"
"
inherit
"
"
initial
"
"
stretch
-
to
-
fit
"
"
unset
"
]
}
"
clip
-
path
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
clip
-
rule
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
evenodd
"
"
inherit
"
"
initial
"
"
nonzero
"
"
unset
"
]
}
"
color
-
interpolation
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
linearrgb
"
"
srgb
"
"
unset
"
]
}
"
color
-
interpolation
-
filters
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
linearrgb
"
"
srgb
"
"
unset
"
]
}
"
dominant
-
baseline
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
alphabetic
"
"
auto
"
"
central
"
"
hanging
"
"
ideographic
"
"
inherit
"
"
initial
"
"
mathematical
"
"
middle
"
"
no
-
change
"
"
reset
-
size
"
"
text
-
after
-
edge
"
"
text
-
before
-
edge
"
"
unset
"
"
use
-
script
"
]
}
"
fill
"
:
{
inherited
:
true
supports
:
12
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
fill
-
opacity
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
fill
-
rule
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
evenodd
"
"
inherit
"
"
initial
"
"
nonzero
"
"
unset
"
]
}
"
filter
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flood
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
flood
-
opacity
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
image
-
rendering
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
-
moz
-
crisp
-
edges
"
"
auto
"
"
inherit
"
"
initial
"
"
optimizequality
"
"
optimizespeed
"
"
unset
"
]
}
"
lighting
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
marker
-
end
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
marker
-
mid
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
marker
-
start
"
:
{
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
mask
"
:
{
inherited
:
false
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
mask
-
type
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
alpha
"
"
inherit
"
"
initial
"
"
luminance
"
"
unset
"
]
}
"
shape
-
rendering
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
crispedges
"
"
geometricprecision
"
"
inherit
"
"
initial
"
"
optimizespeed
"
"
unset
"
]
}
"
stop
-
color
"
:
{
inherited
:
false
supports
:
4
values
:
[
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
stop
-
opacity
"
:
{
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
"
:
{
inherited
:
true
supports
:
12
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
dasharray
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
dashoffset
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
linecap
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
butt
"
"
inherit
"
"
initial
"
"
round
"
"
square
"
"
unset
"
]
}
"
stroke
-
linejoin
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
bevel
"
"
inherit
"
"
initial
"
"
miter
"
"
round
"
"
unset
"
]
}
"
stroke
-
miterlimit
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
opacity
"
:
{
inherited
:
true
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
stroke
-
width
"
:
{
inherited
:
true
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
text
-
anchor
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
end
"
"
inherit
"
"
initial
"
"
middle
"
"
start
"
"
unset
"
]
}
"
text
-
rendering
"
:
{
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
geometricprecision
"
"
inherit
"
"
initial
"
"
optimizelegibility
"
"
optimizespeed
"
"
unset
"
]
}
"
vector
-
effect
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
non
-
scaling
-
stroke
"
"
none
"
"
unset
"
]
}
"
will
-
change
"
:
{
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
outline
-
radius
"
:
{
subproperties
:
[
"
-
moz
-
outline
-
radius
-
topleft
"
"
-
moz
-
outline
-
radius
-
topright
"
"
-
moz
-
outline
-
radius
-
bottomright
"
"
-
moz
-
outline
-
radius
-
bottomleft
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
all
"
:
{
subproperties
:
[
"
-
moz
-
appearance
"
"
-
moz
-
outline
-
radius
-
topleft
"
"
-
moz
-
outline
-
radius
-
topright
"
"
-
moz
-
outline
-
radius
-
bottomright
"
"
-
moz
-
outline
-
radius
-
bottomleft
"
"
-
moz
-
tab
-
size
"
"
-
x
-
system
-
font
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
duration
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
name
"
"
animation
-
play
-
state
"
"
animation
-
timing
-
function
"
"
background
-
attachment
"
"
background
-
clip
"
"
background
-
color
"
"
background
-
image
"
"
background
-
blend
-
mode
"
"
background
-
origin
"
"
background
-
position
"
"
background
-
repeat
"
"
background
-
size
"
"
-
moz
-
binding
"
"
block
-
size
"
"
border
-
block
-
end
-
color
"
"
border
-
block
-
end
-
style
"
"
border
-
block
-
end
-
width
"
"
border
-
block
-
start
-
color
"
"
border
-
block
-
start
-
style
"
"
border
-
block
-
start
-
width
"
"
border
-
bottom
-
color
"
"
-
moz
-
border
-
bottom
-
colors
"
"
border
-
bottom
-
style
"
"
border
-
bottom
-
width
"
"
border
-
collapse
"
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
"
border
-
inline
-
end
-
color
"
"
border
-
inline
-
end
-
style
"
"
border
-
inline
-
end
-
width
"
"
border
-
inline
-
start
-
color
"
"
border
-
inline
-
start
-
style
"
"
border
-
inline
-
start
-
width
"
"
border
-
left
-
color
"
"
-
moz
-
border
-
left
-
colors
"
"
border
-
left
-
style
"
"
border
-
left
-
width
"
"
border
-
right
-
color
"
"
-
moz
-
border
-
right
-
colors
"
"
border
-
right
-
style
"
"
border
-
right
-
width
"
"
border
-
spacing
"
"
border
-
top
-
color
"
"
-
moz
-
border
-
top
-
colors
"
"
border
-
top
-
style
"
"
border
-
top
-
width
"
"
border
-
top
-
left
-
radius
"
"
border
-
top
-
right
-
radius
"
"
border
-
bottom
-
right
-
radius
"
"
border
-
bottom
-
left
-
radius
"
"
bottom
"
"
box
-
decoration
-
break
"
"
box
-
shadow
"
"
box
-
sizing
"
"
caption
-
side
"
"
clear
"
"
clip
"
"
color
"
"
-
moz
-
column
-
count
"
"
-
moz
-
column
-
fill
"
"
-
moz
-
column
-
width
"
"
-
moz
-
column
-
gap
"
"
-
moz
-
column
-
rule
-
color
"
"
-
moz
-
column
-
rule
-
style
"
"
-
moz
-
column
-
rule
-
width
"
"
contain
"
"
content
"
"
-
moz
-
control
-
character
-
visibility
"
"
counter
-
increment
"
"
counter
-
reset
"
"
cursor
"
"
display
"
"
empty
-
cells
"
"
align
-
content
"
"
align
-
items
"
"
align
-
self
"
"
flex
-
basis
"
"
flex
-
direction
"
"
flex
-
grow
"
"
flex
-
shrink
"
"
flex
-
wrap
"
"
order
"
"
justify
-
content
"
"
justify
-
items
"
"
justify
-
self
"
"
float
"
"
-
moz
-
float
-
edge
"
"
font
-
family
"
"
font
-
feature
-
settings
"
"
font
-
kerning
"
"
font
-
language
-
override
"
"
font
-
size
"
"
font
-
size
-
adjust
"
"
-
moz
-
osx
-
font
-
smoothing
"
"
font
-
stretch
"
"
font
-
style
"
"
font
-
synthesis
"
"
font
-
variant
-
alternates
"
"
font
-
variant
-
caps
"
"
font
-
variant
-
east
-
asian
"
"
font
-
variant
-
ligatures
"
"
font
-
variant
-
numeric
"
"
font
-
variant
-
position
"
"
font
-
weight
"
"
-
moz
-
force
-
broken
-
image
-
icon
"
"
grid
-
auto
-
flow
"
"
grid
-
auto
-
columns
"
"
grid
-
auto
-
rows
"
"
grid
-
template
-
areas
"
"
grid
-
template
-
columns
"
"
grid
-
template
-
rows
"
"
grid
-
column
-
start
"
"
grid
-
column
-
end
"
"
grid
-
row
-
start
"
"
grid
-
row
-
end
"
"
grid
-
column
-
gap
"
"
grid
-
row
-
gap
"
"
height
"
"
image
-
orientation
"
"
-
moz
-
image
-
region
"
"
ime
-
mode
"
"
inline
-
size
"
"
left
"
"
letter
-
spacing
"
"
line
-
height
"
"
list
-
style
-
image
"
"
list
-
style
-
position
"
"
list
-
style
-
type
"
"
margin
-
block
-
end
"
"
margin
-
block
-
start
"
"
margin
-
bottom
"
"
margin
-
inline
-
end
"
"
margin
-
inline
-
start
"
"
margin
-
left
"
"
margin
-
right
"
"
margin
-
top
"
"
marker
-
offset
"
"
max
-
block
-
size
"
"
max
-
height
"
"
max
-
inline
-
size
"
"
max
-
width
"
"
-
moz
-
min
-
font
-
size
-
ratio
"
"
min
-
height
"
"
min
-
block
-
size
"
"
min
-
inline
-
size
"
"
min
-
width
"
"
mix
-
blend
-
mode
"
"
isolation
"
"
object
-
fit
"
"
object
-
position
"
"
offset
-
block
-
end
"
"
offset
-
block
-
start
"
"
offset
-
inline
-
end
"
"
offset
-
inline
-
start
"
"
opacity
"
"
-
moz
-
orient
"
"
outline
-
color
"
"
outline
-
style
"
"
outline
-
width
"
"
outline
-
offset
"
"
overflow
-
clip
-
box
"
"
overflow
-
x
"
"
overflow
-
y
"
"
padding
-
block
-
end
"
"
padding
-
block
-
start
"
"
padding
-
bottom
"
"
padding
-
inline
-
end
"
"
padding
-
inline
-
start
"
"
padding
-
left
"
"
padding
-
right
"
"
padding
-
top
"
"
page
-
break
-
after
"
"
page
-
break
-
before
"
"
page
-
break
-
inside
"
"
paint
-
order
"
"
pointer
-
events
"
"
position
"
"
quotes
"
"
resize
"
"
right
"
"
ruby
-
align
"
"
ruby
-
position
"
"
scroll
-
behavior
"
"
scroll
-
snap
-
coordinate
"
"
scroll
-
snap
-
destination
"
"
scroll
-
snap
-
points
-
x
"
"
scroll
-
snap
-
points
-
y
"
"
scroll
-
snap
-
type
-
x
"
"
scroll
-
snap
-
type
-
y
"
"
table
-
layout
"
"
text
-
align
"
"
-
moz
-
text
-
align
-
last
"
"
text
-
combine
-
upright
"
"
text
-
decoration
-
color
"
"
text
-
decoration
-
line
"
"
text
-
decoration
-
style
"
"
text
-
indent
"
"
text
-
orientation
"
"
text
-
overflow
"
"
text
-
shadow
"
"
-
moz
-
text
-
size
-
adjust
"
"
text
-
transform
"
"
transform
"
"
transform
-
box
"
"
transform
-
origin
"
"
perspective
-
origin
"
"
perspective
"
"
transform
-
style
"
"
backface
-
visibility
"
"
top
"
"
-
moz
-
top
-
layer
"
"
touch
-
action
"
"
transition
-
delay
"
"
transition
-
duration
"
"
transition
-
property
"
"
transition
-
timing
-
function
"
"
-
moz
-
user
-
focus
"
"
-
moz
-
user
-
input
"
"
-
moz
-
user
-
modify
"
"
-
moz
-
user
-
select
"
"
vertical
-
align
"
"
visibility
"
"
white
-
space
"
"
width
"
"
-
moz
-
window
-
dragging
"
"
-
moz
-
window
-
shadow
"
"
word
-
break
"
"
word
-
spacing
"
"
word
-
wrap
"
"
hyphens
"
"
writing
-
mode
"
"
z
-
index
"
"
-
moz
-
box
-
align
"
"
-
moz
-
box
-
direction
"
"
-
moz
-
box
-
flex
"
"
-
moz
-
box
-
orient
"
"
-
moz
-
box
-
pack
"
"
-
moz
-
box
-
ordinal
-
group
"
"
-
moz
-
stack
-
sizing
"
"
clip
-
path
"
"
clip
-
rule
"
"
color
-
interpolation
"
"
color
-
interpolation
-
filters
"
"
dominant
-
baseline
"
"
fill
"
"
fill
-
opacity
"
"
fill
-
rule
"
"
filter
"
"
flood
-
color
"
"
flood
-
opacity
"
"
image
-
rendering
"
"
lighting
-
color
"
"
marker
-
end
"
"
marker
-
mid
"
"
marker
-
start
"
"
mask
"
"
mask
-
type
"
"
shape
-
rendering
"
"
stop
-
color
"
"
stop
-
opacity
"
"
stroke
"
"
stroke
-
dasharray
"
"
stroke
-
dashoffset
"
"
stroke
-
linecap
"
"
stroke
-
linejoin
"
"
stroke
-
miterlimit
"
"
stroke
-
opacity
"
"
stroke
-
width
"
"
text
-
anchor
"
"
text
-
rendering
"
"
vector
-
effect
"
"
will
-
change
"
]
inherited
:
false
supports
:
2015
values
:
[
"
-
moz
-
all
"
"
-
moz
-
available
"
"
-
moz
-
block
-
height
"
"
-
moz
-
box
"
"
-
moz
-
calc
"
"
-
moz
-
center
"
"
-
moz
-
crisp
-
edges
"
"
-
moz
-
deck
"
"
-
moz
-
element
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
grid
"
"
-
moz
-
grid
-
group
"
"
-
moz
-
grid
-
line
"
"
-
moz
-
groupbox
"
"
-
moz
-
gtk
-
info
-
bar
"
"
-
moz
-
hidden
-
unscrollable
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
inline
-
box
"
"
-
moz
-
inline
-
grid
"
"
-
moz
-
inline
-
stack
"
"
-
moz
-
left
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
mac
-
disclosure
-
button
-
closed
"
"
-
moz
-
mac
-
disclosure
-
button
-
open
"
"
-
moz
-
mac
-
fullscreen
-
button
"
"
-
moz
-
mac
-
help
-
button
"
"
-
moz
-
mac
-
vibrancy
-
dark
"
"
-
moz
-
mac
-
vibrancy
-
light
"
"
-
moz
-
max
-
content
"
"
-
moz
-
middle
-
with
-
baseline
"
"
-
moz
-
min
-
content
"
"
-
moz
-
none
"
"
-
moz
-
popup
"
"
-
moz
-
pre
-
space
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
-
moz
-
right
"
"
-
moz
-
stack
"
"
-
moz
-
text
"
"
-
moz
-
use
-
text
-
color
"
"
-
moz
-
win
-
borderless
-
glass
"
"
-
moz
-
win
-
browsertabbar
-
toolbox
"
"
-
moz
-
win
-
communications
-
toolbox
"
"
-
moz
-
win
-
exclude
-
glass
"
"
-
moz
-
win
-
glass
"
"
-
moz
-
win
-
media
-
toolbox
"
"
-
moz
-
window
-
button
-
box
"
"
-
moz
-
window
-
button
-
box
-
maximized
"
"
-
moz
-
window
-
button
-
close
"
"
-
moz
-
window
-
button
-
maximize
"
"
-
moz
-
window
-
button
-
minimize
"
"
-
moz
-
window
-
button
-
restore
"
"
-
moz
-
window
-
frame
-
bottom
"
"
-
moz
-
window
-
frame
-
left
"
"
-
moz
-
window
-
frame
-
right
"
"
-
moz
-
window
-
titlebar
"
"
-
moz
-
window
-
titlebar
-
maximized
"
"
absolute
"
"
active
"
"
aliceblue
"
"
all
"
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
alpha
"
"
alphabetic
"
"
alternate
"
"
alternate
-
reverse
"
"
always
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
auto
"
"
avoid
"
"
azure
"
"
backwards
"
"
balance
"
"
baseline
"
"
beige
"
"
bevel
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
block
"
"
block
-
axis
"
"
blue
"
"
blueviolet
"
"
border
-
box
"
"
both
"
"
bottom
"
"
bottom
-
outside
"
"
break
-
all
"
"
break
-
word
"
"
brown
"
"
burlywood
"
"
butt
"
"
button
"
"
button
-
arrow
-
down
"
"
button
-
arrow
-
next
"
"
button
-
arrow
-
previous
"
"
button
-
arrow
-
up
"
"
button
-
bevel
"
"
button
-
focus
"
"
cadetblue
"
"
calc
"
"
capitalize
"
"
caret
"
"
center
"
"
central
"
"
chartreuse
"
"
checkbox
"
"
checkbox
-
container
"
"
checkbox
-
label
"
"
checkmenuitem
"
"
chocolate
"
"
clone
"
"
collapse
"
"
color
"
"
color
-
burn
"
"
color
-
dodge
"
"
column
"
"
column
-
reverse
"
"
condensed
"
"
contain
"
"
content
-
box
"
"
contents
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
cover
"
"
crimson
"
"
crispedges
"
"
cubic
-
bezier
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darken
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dialog
"
"
difference
"
"
dimgray
"
"
dimgrey
"
"
disabled
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
drag
"
"
dualbutton
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
element
"
"
elements
"
"
enabled
"
"
end
"
"
evenodd
"
"
exclusion
"
"
expanded
"
"
extra
-
condensed
"
"
extra
-
expanded
"
"
fill
"
"
fill
-
box
"
"
firebrick
"
"
fixed
"
"
flat
"
"
flex
"
"
floralwhite
"
"
forestgreen
"
"
forwards
"
"
fuchsia
"
"
full
-
width
"
"
gainsboro
"
"
geometricprecision
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
grid
"
"
groove
"
"
groupbox
"
"
hanging
"
"
hard
-
light
"
"
hidden
"
"
hide
"
"
honeydew
"
"
horizontal
"
"
horizontal
-
tb
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
hue
"
"
ideographic
"
"
ignore
"
"
inactive
"
"
indianred
"
"
indigo
"
"
infinite
"
"
inherit
"
"
initial
"
"
inline
"
"
inline
-
axis
"
"
inline
-
block
"
"
inline
-
end
"
"
inline
-
flex
"
"
inline
-
grid
"
"
inline
-
start
"
"
inline
-
table
"
"
inset
"
"
inside
"
"
isolate
"
"
italic
"
"
ivory
"
"
justify
"
"
keep
-
all
"
"
khaki
"
"
large
"
"
larger
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
layout
"
"
left
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lighten
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linear
"
"
linear
-
gradient
"
"
linearrgb
"
"
linen
"
"
list
-
item
"
"
listbox
"
"
listitem
"
"
local
"
"
lowercase
"
"
lr
"
"
lr
-
tb
"
"
luminance
"
"
luminosity
"
"
magenta
"
"
mandatory
"
"
manual
"
"
margin
-
box
"
"
maroon
"
"
mathematical
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
menuarrow
"
"
menubar
"
"
menucheckbox
"
"
menuimage
"
"
menuitem
"
"
menuitemtext
"
"
menulist
"
"
menulist
-
button
"
"
menulist
-
text
"
"
menulist
-
textfield
"
"
menupopup
"
"
menuradio
"
"
menuseparator
"
"
meterbar
"
"
meterchunk
"
"
middle
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
miter
"
"
mixed
"
"
moccasin
"
"
multiply
"
"
navajowhite
"
"
navy
"
"
no
-
change
"
"
no
-
drag
"
"
no
-
repeat
"
"
non
-
scaling
-
stroke
"
"
none
"
"
nonzero
"
"
normal
"
"
nowrap
"
"
number
-
input
"
"
oblique
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
optimizelegibility
"
"
optimizequality
"
"
optimizespeed
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
outside
"
"
over
"
"
overlay
"
"
padding
-
box
"
"
paint
"
"
painted
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
paused
"
"
peachpuff
"
"
peru
"
"
petite
-
caps
"
"
pink
"
"
plum
"
"
powderblue
"
"
pre
"
"
pre
-
line
"
"
pre
-
wrap
"
"
preserve
-
3d
"
"
progressbar
"
"
progressbar
-
vertical
"
"
progresschunk
"
"
progresschunk
-
vertical
"
"
proximity
"
"
purple
"
"
radial
-
gradient
"
"
radio
"
"
radio
-
container
"
"
radio
-
label
"
"
radiomenuitem
"
"
range
"
"
range
-
thumb
"
"
read
-
only
"
"
read
-
write
"
"
rebeccapurple
"
"
red
"
"
relative
"
"
repeat
"
"
repeat
-
x
"
"
repeat
-
y
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
reset
-
size
"
"
resizer
"
"
resizerpanel
"
"
reverse
"
"
rgb
"
"
rgba
"
"
ridge
"
"
right
"
"
rl
"
"
rl
-
tb
"
"
rosybrown
"
"
round
"
"
row
"
"
row
-
reverse
"
"
royalblue
"
"
ruby
"
"
ruby
-
base
"
"
ruby
-
base
-
container
"
"
ruby
-
text
"
"
ruby
-
text
-
container
"
"
running
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
saturation
"
"
scale
-
down
"
"
scale
-
horizontal
"
"
scale
-
vertical
"
"
scalethumb
-
horizontal
"
"
scalethumb
-
vertical
"
"
scalethumbend
"
"
scalethumbstart
"
"
scalethumbtick
"
"
screen
"
"
scroll
"
"
scrollbar
"
"
scrollbar
-
small
"
"
scrollbarbutton
-
down
"
"
scrollbarbutton
-
left
"
"
scrollbarbutton
-
right
"
"
scrollbarbutton
-
up
"
"
scrollbarthumb
-
horizontal
"
"
scrollbarthumb
-
vertical
"
"
scrollbartrack
-
horizontal
"
"
scrollbartrack
-
vertical
"
"
seagreen
"
"
searchfield
"
"
seashell
"
"
select
-
after
"
"
select
-
all
"
"
select
-
before
"
"
select
-
menu
"
"
select
-
same
"
"
semi
-
condensed
"
"
semi
-
expanded
"
"
separate
"
"
separator
"
"
show
"
"
sideways
"
"
sideways
-
lr
"
"
sideways
-
right
"
"
sideways
-
rl
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
slice
"
"
small
"
"
small
-
caps
"
"
smaller
"
"
smooth
"
"
snow
"
"
soft
-
light
"
"
solid
"
"
space
-
around
"
"
space
-
between
"
"
spinner
"
"
spinner
-
downbutton
"
"
spinner
-
textfield
"
"
spinner
-
upbutton
"
"
splitter
"
"
springgreen
"
"
square
"
"
srgb
"
"
start
"
"
static
"
"
statusbar
"
"
statusbarpanel
"
"
steelblue
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
sticky
"
"
stretch
"
"
stretch
-
to
-
fit
"
"
strict
"
"
stroke
"
"
style
"
"
sub
"
"
super
"
"
tab
"
"
tab
-
scroll
-
arrow
-
back
"
"
tab
-
scroll
-
arrow
-
forward
"
"
table
"
"
table
-
caption
"
"
table
-
cell
"
"
table
-
column
"
"
table
-
column
-
group
"
"
table
-
footer
-
group
"
"
table
-
header
-
group
"
"
table
-
row
"
"
table
-
row
-
group
"
"
tabpanel
"
"
tabpanels
"
"
tan
"
"
tb
"
"
tb
-
rl
"
"
teal
"
"
text
"
"
text
-
after
-
edge
"
"
text
-
before
-
edge
"
"
text
-
bottom
"
"
text
-
top
"
"
textfield
"
"
textfield
-
multiline
"
"
thick
"
"
thin
"
"
thistle
"
"
titling
-
caps
"
"
toggle
"
"
tomato
"
"
toolbar
"
"
toolbarbutton
"
"
toolbarbutton
-
dropdown
"
"
toolbargripper
"
"
toolbox
"
"
tooltip
"
"
top
"
"
top
-
outside
"
"
transparent
"
"
treeheader
"
"
treeheadercell
"
"
treeheadersortarrow
"
"
treeitem
"
"
treeline
"
"
treetwisty
"
"
treetwistyopen
"
"
treeview
"
"
tri
-
state
"
"
turquoise
"
"
ultra
-
condensed
"
"
ultra
-
expanded
"
"
under
"
"
unicase
"
"
unset
"
"
uppercase
"
"
upright
"
"
url
"
"
use
-
script
"
"
vertical
"
"
vertical
-
lr
"
"
vertical
-
rl
"
"
view
-
box
"
"
violet
"
"
visible
"
"
visiblefill
"
"
visiblepainted
"
"
visiblestroke
"
"
wavy
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
window
"
"
wrap
"
"
wrap
-
reverse
"
"
write
-
only
"
"
x
-
large
"
"
x
-
small
"
"
xx
-
large
"
"
xx
-
small
"
"
yellow
"
"
yellowgreen
"
]
}
"
animation
"
:
{
subproperties
:
[
"
animation
-
duration
"
"
animation
-
timing
-
function
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
play
-
state
"
"
animation
-
name
"
]
inherited
:
false
supports
:
1344
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
backwards
"
"
both
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
forwards
"
"
infinite
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
normal
"
"
paused
"
"
reverse
"
"
running
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
background
"
:
{
subproperties
:
[
"
background
-
color
"
"
background
-
image
"
"
background
-
repeat
"
"
background
-
attachment
"
"
background
-
position
"
"
background
-
clip
"
"
background
-
origin
"
"
background
-
size
"
]
inherited
:
false
supports
:
655
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
border
-
box
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
content
-
box
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
fixed
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linear
-
gradient
"
"
linen
"
"
local
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
no
-
repeat
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
padding
-
box
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
radial
-
gradient
"
"
rebeccapurple
"
"
red
"
"
repeat
"
"
repeat
-
x
"
"
repeat
-
y
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
scroll
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
url
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
"
:
{
subproperties
:
[
"
border
-
top
-
width
"
"
border
-
right
-
width
"
"
border
-
bottom
-
width
"
"
border
-
left
-
width
"
"
border
-
top
-
style
"
"
border
-
right
-
style
"
"
border
-
bottom
-
style
"
"
border
-
left
-
style
"
"
border
-
top
-
color
"
"
border
-
right
-
color
"
"
border
-
bottom
-
color
"
"
border
-
left
-
color
"
"
-
moz
-
border
-
top
-
colors
"
"
-
moz
-
border
-
right
-
colors
"
"
-
moz
-
border
-
bottom
-
colors
"
"
-
moz
-
border
-
left
-
colors
"
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linear
-
gradient
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
radial
-
gradient
"
"
rebeccapurple
"
"
red
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
url
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
end
"
:
{
subproperties
:
[
"
border
-
block
-
end
-
width
"
"
border
-
block
-
end
-
style
"
"
border
-
block
-
end
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
block
-
start
"
:
{
subproperties
:
[
"
border
-
block
-
start
-
width
"
"
border
-
block
-
start
-
style
"
"
border
-
block
-
start
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
bottom
"
:
{
subproperties
:
[
"
border
-
bottom
-
width
"
"
border
-
bottom
-
style
"
"
border
-
bottom
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
color
"
:
{
subproperties
:
[
"
border
-
top
-
color
"
"
border
-
right
-
color
"
"
border
-
bottom
-
color
"
"
border
-
left
-
color
"
]
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
image
"
:
{
subproperties
:
[
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
1675
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
border
-
inline
-
end
"
:
{
subproperties
:
[
"
border
-
inline
-
end
-
width
"
"
border
-
inline
-
end
-
style
"
"
border
-
inline
-
end
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
inline
-
start
"
:
{
subproperties
:
[
"
border
-
inline
-
start
-
width
"
"
border
-
inline
-
start
-
style
"
"
border
-
inline
-
start
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
left
"
:
{
subproperties
:
[
"
border
-
left
-
width
"
"
border
-
left
-
style
"
"
border
-
left
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
right
"
:
{
subproperties
:
[
"
border
-
right
-
width
"
"
border
-
right
-
style
"
"
border
-
right
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
style
"
:
{
subproperties
:
[
"
border
-
top
-
style
"
"
border
-
right
-
style
"
"
border
-
bottom
-
style
"
"
border
-
left
-
style
"
]
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
border
-
top
"
:
{
subproperties
:
[
"
border
-
top
-
width
"
"
border
-
top
-
style
"
"
border
-
top
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
border
-
width
"
:
{
subproperties
:
[
"
border
-
top
-
width
"
"
border
-
right
-
width
"
"
border
-
bottom
-
width
"
"
border
-
left
-
width
"
]
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
border
-
radius
"
:
{
subproperties
:
[
"
border
-
top
-
left
-
radius
"
"
border
-
top
-
right
-
radius
"
"
border
-
bottom
-
right
-
radius
"
"
border
-
bottom
-
left
-
radius
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
columns
"
:
{
subproperties
:
[
"
-
moz
-
column
-
count
"
"
-
moz
-
column
-
width
"
]
inherited
:
false
supports
:
1025
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
column
-
rule
"
:
{
subproperties
:
[
"
-
moz
-
column
-
rule
-
width
"
"
-
moz
-
column
-
rule
-
style
"
"
-
moz
-
column
-
rule
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
flex
"
:
{
subproperties
:
[
"
flex
-
grow
"
"
flex
-
shrink
"
"
flex
-
basis
"
]
inherited
:
false
supports
:
1027
values
:
[
"
-
moz
-
available
"
"
-
moz
-
calc
"
"
-
moz
-
fit
-
content
"
"
-
moz
-
max
-
content
"
"
-
moz
-
min
-
content
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
flex
-
flow
"
:
{
subproperties
:
[
"
flex
-
direction
"
"
flex
-
wrap
"
]
inherited
:
false
supports
:
0
values
:
[
"
column
"
"
column
-
reverse
"
"
inherit
"
"
initial
"
"
nowrap
"
"
row
"
"
row
-
reverse
"
"
unset
"
"
wrap
"
"
wrap
-
reverse
"
]
}
"
font
"
:
{
subproperties
:
[
"
font
-
family
"
"
font
-
style
"
"
font
-
weight
"
"
font
-
size
"
"
line
-
height
"
"
font
-
size
-
adjust
"
"
font
-
stretch
"
"
-
x
-
system
-
font
"
"
font
-
feature
-
settings
"
"
font
-
language
-
override
"
"
font
-
kerning
"
"
font
-
synthesis
"
"
font
-
variant
-
alternates
"
"
font
-
variant
-
caps
"
"
font
-
variant
-
east
-
asian
"
"
font
-
variant
-
ligatures
"
"
font
-
variant
-
numeric
"
"
font
-
variant
-
position
"
]
inherited
:
true
supports
:
1027
values
:
[
"
-
moz
-
block
-
height
"
"
-
moz
-
calc
"
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
auto
"
"
calc
"
"
condensed
"
"
expanded
"
"
extra
-
condensed
"
"
extra
-
expanded
"
"
inherit
"
"
initial
"
"
italic
"
"
large
"
"
larger
"
"
medium
"
"
none
"
"
normal
"
"
oblique
"
"
petite
-
caps
"
"
semi
-
condensed
"
"
semi
-
expanded
"
"
small
"
"
small
-
caps
"
"
smaller
"
"
sub
"
"
super
"
"
titling
-
caps
"
"
ultra
-
condensed
"
"
ultra
-
expanded
"
"
unicase
"
"
unset
"
"
x
-
large
"
"
x
-
small
"
"
xx
-
large
"
"
xx
-
small
"
]
}
"
font
-
variant
"
:
{
subproperties
:
[
"
font
-
variant
-
alternates
"
"
font
-
variant
-
caps
"
"
font
-
variant
-
east
-
asian
"
"
font
-
variant
-
ligatures
"
"
font
-
variant
-
numeric
"
"
font
-
variant
-
position
"
]
inherited
:
true
supports
:
0
values
:
[
"
all
-
petite
-
caps
"
"
all
-
small
-
caps
"
"
inherit
"
"
initial
"
"
normal
"
"
petite
-
caps
"
"
small
-
caps
"
"
sub
"
"
super
"
"
titling
-
caps
"
"
unicase
"
"
unset
"
]
}
"
grid
-
template
"
:
{
subproperties
:
[
"
grid
-
template
-
areas
"
"
grid
-
template
-
columns
"
"
grid
-
template
-
rows
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
"
:
{
subproperties
:
[
"
grid
-
template
-
areas
"
"
grid
-
template
-
columns
"
"
grid
-
template
-
rows
"
"
grid
-
auto
-
flow
"
"
grid
-
auto
-
columns
"
"
grid
-
auto
-
rows
"
"
grid
-
column
-
gap
"
"
grid
-
row
-
gap
"
]
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
column
"
:
{
subproperties
:
[
"
grid
-
column
-
start
"
"
grid
-
column
-
end
"
]
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
row
"
:
{
subproperties
:
[
"
grid
-
row
-
start
"
"
grid
-
row
-
end
"
]
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
area
"
:
{
subproperties
:
[
"
grid
-
row
-
start
"
"
grid
-
column
-
start
"
"
grid
-
row
-
end
"
"
grid
-
column
-
end
"
]
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
grid
-
gap
"
:
{
subproperties
:
[
"
grid
-
column
-
gap
"
"
grid
-
row
-
gap
"
]
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
list
-
style
"
:
{
subproperties
:
[
"
list
-
style
-
type
"
"
list
-
style
-
image
"
"
list
-
style
-
position
"
]
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
inside
"
"
none
"
"
outside
"
"
unset
"
"
url
"
]
}
"
margin
"
:
{
subproperties
:
[
"
margin
-
top
"
"
margin
-
right
"
"
margin
-
bottom
"
"
margin
-
left
"
]
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
outline
"
:
{
subproperties
:
[
"
outline
-
width
"
"
outline
-
style
"
"
outline
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
auto
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
overflow
"
:
{
subproperties
:
[
"
overflow
-
x
"
"
overflow
-
y
"
]
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
hidden
-
unscrollable
"
"
auto
"
"
hidden
"
"
inherit
"
"
initial
"
"
scroll
"
"
unset
"
"
visible
"
]
}
"
padding
"
:
{
subproperties
:
[
"
padding
-
top
"
"
padding
-
right
"
"
padding
-
bottom
"
"
padding
-
left
"
]
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
scroll
-
snap
-
type
"
:
{
subproperties
:
[
"
scroll
-
snap
-
type
-
x
"
"
scroll
-
snap
-
type
-
y
"
]
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
mandatory
"
"
none
"
"
proximity
"
"
unset
"
]
}
"
text
-
decoration
"
:
{
subproperties
:
[
"
text
-
decoration
-
color
"
"
text
-
decoration
-
line
"
"
text
-
decoration
-
style
"
]
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
none
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wavy
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
transition
"
:
{
subproperties
:
[
"
transition
-
property
"
"
transition
-
duration
"
"
transition
-
timing
-
function
"
"
transition
-
delay
"
]
inherited
:
false
supports
:
320
values
:
[
"
all
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
marker
"
:
{
subproperties
:
[
"
marker
-
start
"
"
marker
-
mid
"
"
marker
-
end
"
]
inherited
:
true
supports
:
8
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
"
url
"
]
}
"
-
moz
-
transform
"
:
{
alias
:
true
subproperties
:
[
"
transform
"
]
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
transform
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
perspective
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
perspective
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
transform
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
flat
"
"
inherit
"
"
initial
"
"
preserve
-
3d
"
"
unset
"
]
}
"
-
moz
-
backface
-
visibility
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
-
moz
-
border
-
image
"
:
{
alias
:
true
subproperties
:
[
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
1675
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
-
moz
-
transition
"
:
{
alias
:
true
subproperties
:
[
"
transition
-
property
"
"
transition
-
duration
"
"
transition
-
timing
-
function
"
"
transition
-
delay
"
]
inherited
:
false
supports
:
320
values
:
[
"
all
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
transition
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
transition
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
transition
-
property
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
all
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
transition
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
animation
"
:
{
alias
:
true
subproperties
:
[
"
animation
-
duration
"
"
animation
-
timing
-
function
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
play
-
state
"
"
animation
-
name
"
]
inherited
:
false
supports
:
1344
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
backwards
"
"
both
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
forwards
"
"
infinite
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
normal
"
"
paused
"
"
reverse
"
"
running
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
animation
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
animation
-
direction
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
-
moz
-
animation
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
animation
-
fill
-
mode
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
backwards
"
"
both
"
"
forwards
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
animation
-
iteration
-
count
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
infinite
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
animation
-
name
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
moz
-
animation
-
play
-
state
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
paused
"
"
running
"
"
unset
"
]
}
"
-
moz
-
animation
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
moz
-
box
-
sizing
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
moz
-
font
-
feature
-
settings
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
font
-
language
-
override
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
normal
"
"
unset
"
]
}
"
-
moz
-
padding
-
end
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
padding
-
start
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
margin
-
end
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
margin
-
start
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
-
moz
-
calc
"
"
auto
"
"
calc
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
moz
-
border
-
end
"
:
{
alias
:
true
subproperties
:
[
"
border
-
inline
-
end
-
width
"
"
border
-
inline
-
end
-
style
"
"
border
-
inline
-
end
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
end
-
color
"
:
{
alias
:
true
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
end
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
-
moz
-
border
-
end
-
width
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
-
moz
-
border
-
start
"
:
{
alias
:
true
subproperties
:
[
"
border
-
inline
-
start
-
width
"
"
border
-
inline
-
start
-
style
"
"
border
-
inline
-
start
-
color
"
]
inherited
:
false
supports
:
5
values
:
[
"
-
moz
-
calc
"
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
calc
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
dashed
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
dotted
"
"
double
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
groove
"
"
hidden
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
inset
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
medium
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
none
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
outset
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
ridge
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
solid
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thick
"
"
thin
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
start
-
color
"
:
{
alias
:
true
inherited
:
false
supports
:
4
values
:
[
"
-
moz
-
use
-
text
-
color
"
"
aliceblue
"
"
antiquewhite
"
"
aqua
"
"
aquamarine
"
"
azure
"
"
beige
"
"
bisque
"
"
black
"
"
blanchedalmond
"
"
blue
"
"
blueviolet
"
"
brown
"
"
burlywood
"
"
cadetblue
"
"
chartreuse
"
"
chocolate
"
"
coral
"
"
cornflowerblue
"
"
cornsilk
"
"
crimson
"
"
currentColor
"
"
cyan
"
"
darkblue
"
"
darkcyan
"
"
darkgoldenrod
"
"
darkgray
"
"
darkgreen
"
"
darkgrey
"
"
darkkhaki
"
"
darkmagenta
"
"
darkolivegreen
"
"
darkorange
"
"
darkorchid
"
"
darkred
"
"
darksalmon
"
"
darkseagreen
"
"
darkslateblue
"
"
darkslategray
"
"
darkslategrey
"
"
darkturquoise
"
"
darkviolet
"
"
deeppink
"
"
deepskyblue
"
"
dimgray
"
"
dimgrey
"
"
dodgerblue
"
"
firebrick
"
"
floralwhite
"
"
forestgreen
"
"
fuchsia
"
"
gainsboro
"
"
ghostwhite
"
"
gold
"
"
goldenrod
"
"
gray
"
"
grey
"
"
green
"
"
greenyellow
"
"
honeydew
"
"
hotpink
"
"
hsl
"
"
hsla
"
"
indianred
"
"
indigo
"
"
inherit
"
"
initial
"
"
ivory
"
"
khaki
"
"
lavender
"
"
lavenderblush
"
"
lawngreen
"
"
lemonchiffon
"
"
lightblue
"
"
lightcoral
"
"
lightcyan
"
"
lightgoldenrodyellow
"
"
lightgray
"
"
lightgreen
"
"
lightgrey
"
"
lightpink
"
"
lightsalmon
"
"
lightseagreen
"
"
lightskyblue
"
"
lightslategray
"
"
lightslategrey
"
"
lightsteelblue
"
"
lightyellow
"
"
lime
"
"
limegreen
"
"
linen
"
"
magenta
"
"
maroon
"
"
mediumaquamarine
"
"
mediumblue
"
"
mediumorchid
"
"
mediumpurple
"
"
mediumseagreen
"
"
mediumslateblue
"
"
mediumspringgreen
"
"
mediumturquoise
"
"
mediumvioletred
"
"
midnightblue
"
"
mintcream
"
"
mistyrose
"
"
moccasin
"
"
navajowhite
"
"
navy
"
"
oldlace
"
"
olive
"
"
olivedrab
"
"
orange
"
"
orangered
"
"
orchid
"
"
palegoldenrod
"
"
palegreen
"
"
paleturquoise
"
"
palevioletred
"
"
papayawhip
"
"
peachpuff
"
"
peru
"
"
pink
"
"
plum
"
"
powderblue
"
"
purple
"
"
rebeccapurple
"
"
red
"
"
rgb
"
"
rgba
"
"
rosybrown
"
"
royalblue
"
"
saddlebrown
"
"
salmon
"
"
sandybrown
"
"
seagreen
"
"
seashell
"
"
sienna
"
"
silver
"
"
skyblue
"
"
slateblue
"
"
slategray
"
"
slategrey
"
"
snow
"
"
springgreen
"
"
steelblue
"
"
tan
"
"
teal
"
"
thistle
"
"
tomato
"
"
transparent
"
"
turquoise
"
"
unset
"
"
violet
"
"
wheat
"
"
white
"
"
whitesmoke
"
"
yellow
"
"
yellowgreen
"
]
}
"
-
moz
-
border
-
start
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
dashed
"
"
dotted
"
"
double
"
"
groove
"
"
hidden
"
"
inherit
"
"
initial
"
"
inset
"
"
none
"
"
outset
"
"
ridge
"
"
solid
"
"
unset
"
]
}
"
-
moz
-
border
-
start
-
width
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
-
moz
-
calc
"
"
calc
"
"
inherit
"
"
initial
"
"
medium
"
"
thick
"
"
thin
"
"
unset
"
]
}
"
-
moz
-
hyphens
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
manual
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
animation
"
:
{
alias
:
true
subproperties
:
[
"
animation
-
duration
"
"
animation
-
timing
-
function
"
"
animation
-
delay
"
"
animation
-
direction
"
"
animation
-
fill
-
mode
"
"
animation
-
iteration
-
count
"
"
animation
-
play
-
state
"
"
animation
-
name
"
]
inherited
:
false
supports
:
1344
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
backwards
"
"
both
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
forwards
"
"
infinite
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
normal
"
"
paused
"
"
reverse
"
"
running
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
animation
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
animation
-
direction
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
alternate
"
"
alternate
-
reverse
"
"
inherit
"
"
initial
"
"
normal
"
"
reverse
"
"
unset
"
]
}
"
-
webkit
-
animation
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
animation
-
fill
-
mode
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
backwards
"
"
both
"
"
forwards
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
animation
-
iteration
-
count
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
infinite
"
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
animation
-
name
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
animation
-
play
-
state
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
paused
"
"
running
"
"
unset
"
]
}
"
-
webkit
-
animation
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
text
-
size
-
adjust
"
:
{
alias
:
true
inherited
:
true
supports
:
0
values
:
[
"
auto
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
transform
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transform
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transform
-
style
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
flat
"
"
inherit
"
"
initial
"
"
preserve
-
3d
"
"
unset
"
]
}
"
-
webkit
-
backface
-
visibility
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
hidden
"
"
inherit
"
"
initial
"
"
unset
"
"
visible
"
]
}
"
-
webkit
-
perspective
"
:
{
alias
:
true
inherited
:
false
supports
:
1
values
:
[
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
perspective
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transition
"
:
{
alias
:
true
subproperties
:
[
"
transition
-
property
"
"
transition
-
duration
"
"
transition
-
timing
-
function
"
"
transition
-
delay
"
]
inherited
:
false
supports
:
320
values
:
[
"
all
"
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
none
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
transition
-
delay
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transition
-
duration
"
:
{
alias
:
true
inherited
:
false
supports
:
64
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
transition
-
property
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
all
"
"
inherit
"
"
initial
"
"
none
"
"
unset
"
]
}
"
-
webkit
-
transition
-
timing
-
function
"
:
{
alias
:
true
inherited
:
false
supports
:
256
values
:
[
"
cubic
-
bezier
"
"
ease
"
"
ease
-
in
"
"
ease
-
in
-
out
"
"
ease
-
out
"
"
inherit
"
"
initial
"
"
linear
"
"
step
-
end
"
"
step
-
start
"
"
steps
"
"
unset
"
]
}
"
-
webkit
-
border
-
radius
"
:
{
alias
:
true
subproperties
:
[
"
border
-
top
-
left
-
radius
"
"
border
-
top
-
right
-
radius
"
"
border
-
bottom
-
right
-
radius
"
"
border
-
bottom
-
left
-
radius
"
]
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
top
-
left
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
top
-
right
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
bottom
-
left
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
bottom
-
right
-
radius
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
appearance
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
gtk
-
info
-
bar
"
"
-
moz
-
mac
-
disclosure
-
button
-
closed
"
"
-
moz
-
mac
-
disclosure
-
button
-
open
"
"
-
moz
-
mac
-
fullscreen
-
button
"
"
-
moz
-
mac
-
help
-
button
"
"
-
moz
-
mac
-
vibrancy
-
dark
"
"
-
moz
-
mac
-
vibrancy
-
light
"
"
-
moz
-
win
-
borderless
-
glass
"
"
-
moz
-
win
-
browsertabbar
-
toolbox
"
"
-
moz
-
win
-
communications
-
toolbox
"
"
-
moz
-
win
-
exclude
-
glass
"
"
-
moz
-
win
-
glass
"
"
-
moz
-
win
-
media
-
toolbox
"
"
-
moz
-
window
-
button
-
box
"
"
-
moz
-
window
-
button
-
box
-
maximized
"
"
-
moz
-
window
-
button
-
close
"
"
-
moz
-
window
-
button
-
maximize
"
"
-
moz
-
window
-
button
-
minimize
"
"
-
moz
-
window
-
button
-
restore
"
"
-
moz
-
window
-
frame
-
bottom
"
"
-
moz
-
window
-
frame
-
left
"
"
-
moz
-
window
-
frame
-
right
"
"
-
moz
-
window
-
titlebar
"
"
-
moz
-
window
-
titlebar
-
maximized
"
"
button
"
"
button
-
arrow
-
down
"
"
button
-
arrow
-
next
"
"
button
-
arrow
-
previous
"
"
button
-
arrow
-
up
"
"
button
-
bevel
"
"
button
-
focus
"
"
caret
"
"
checkbox
"
"
checkbox
-
container
"
"
checkbox
-
label
"
"
checkmenuitem
"
"
dialog
"
"
dualbutton
"
"
groupbox
"
"
inherit
"
"
initial
"
"
listbox
"
"
listitem
"
"
menuarrow
"
"
menubar
"
"
menucheckbox
"
"
menuimage
"
"
menuitem
"
"
menuitemtext
"
"
menulist
"
"
menulist
-
button
"
"
menulist
-
text
"
"
menulist
-
textfield
"
"
menupopup
"
"
menuradio
"
"
menuseparator
"
"
meterbar
"
"
meterchunk
"
"
none
"
"
number
-
input
"
"
progressbar
"
"
progressbar
-
vertical
"
"
progresschunk
"
"
progresschunk
-
vertical
"
"
radio
"
"
radio
-
container
"
"
radio
-
label
"
"
radiomenuitem
"
"
range
"
"
range
-
thumb
"
"
resizer
"
"
resizerpanel
"
"
scale
-
horizontal
"
"
scale
-
vertical
"
"
scalethumb
-
horizontal
"
"
scalethumb
-
vertical
"
"
scalethumbend
"
"
scalethumbstart
"
"
scalethumbtick
"
"
scrollbar
"
"
scrollbar
-
small
"
"
scrollbarbutton
-
down
"
"
scrollbarbutton
-
left
"
"
scrollbarbutton
-
right
"
"
scrollbarbutton
-
up
"
"
scrollbarthumb
-
horizontal
"
"
scrollbarthumb
-
vertical
"
"
scrollbartrack
-
horizontal
"
"
scrollbartrack
-
vertical
"
"
searchfield
"
"
separator
"
"
spinner
"
"
spinner
-
downbutton
"
"
spinner
-
textfield
"
"
spinner
-
upbutton
"
"
splitter
"
"
statusbar
"
"
statusbarpanel
"
"
tab
"
"
tab
-
scroll
-
arrow
-
back
"
"
tab
-
scroll
-
arrow
-
forward
"
"
tabpanel
"
"
tabpanels
"
"
textfield
"
"
textfield
-
multiline
"
"
toolbar
"
"
toolbarbutton
"
"
toolbarbutton
-
dropdown
"
"
toolbargripper
"
"
toolbox
"
"
tooltip
"
"
treeheader
"
"
treeheadercell
"
"
treeheadersortarrow
"
"
treeitem
"
"
treeline
"
"
treetwisty
"
"
treetwistyopen
"
"
treeview
"
"
unset
"
"
window
"
]
}
"
-
webkit
-
background
-
clip
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
webkit
-
background
-
origin
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
webkit
-
background
-
size
"
:
{
alias
:
true
inherited
:
false
supports
:
3
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
"
:
{
alias
:
true
subproperties
:
[
"
border
-
image
-
source
"
"
border
-
image
-
slice
"
"
border
-
image
-
width
"
"
border
-
image
-
outset
"
"
border
-
image
-
repeat
"
]
inherited
:
false
supports
:
1675
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
-
webkit
-
border
-
image
-
outset
"
:
{
alias
:
true
inherited
:
false
supports
:
1025
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
-
repeat
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
-
slice
"
:
{
alias
:
true
inherited
:
false
supports
:
1026
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
border
-
image
-
source
"
:
{
alias
:
true
inherited
:
false
supports
:
648
values
:
[
"
-
moz
-
element
"
"
-
moz
-
image
-
rect
"
"
-
moz
-
linear
-
gradient
"
"
-
moz
-
radial
-
gradient
"
"
-
moz
-
repeating
-
linear
-
gradient
"
"
-
moz
-
repeating
-
radial
-
gradient
"
"
inherit
"
"
initial
"
"
linear
-
gradient
"
"
none
"
"
radial
-
gradient
"
"
repeating
-
linear
-
gradient
"
"
repeating
-
radial
-
gradient
"
"
unset
"
"
url
"
]
}
"
-
webkit
-
border
-
image
-
width
"
:
{
alias
:
true
inherited
:
false
supports
:
1027
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
shadow
"
:
{
alias
:
true
inherited
:
false
supports
:
5
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
sizing
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
border
-
box
"
"
content
-
box
"
"
inherit
"
"
initial
"
"
padding
-
box
"
"
unset
"
]
}
"
-
webkit
-
box
-
flex
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
ordinal
-
group
"
:
{
alias
:
true
inherited
:
false
supports
:
1024
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
align
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
box
-
pack
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
inherit
"
"
initial
"
"
unset
"
]
}
"
-
webkit
-
user
-
select
"
:
{
alias
:
true
inherited
:
false
supports
:
0
values
:
[
"
-
moz
-
all
"
"
-
moz
-
none
"
"
-
moz
-
text
"
"
all
"
"
auto
"
"
element
"
"
elements
"
"
inherit
"
"
initial
"
"
none
"
"
text
"
"
toggle
"
"
tri
-
state
"
"
unset
"
]
}
}
;
module
.
exports
=
{
cssProperties
}
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
setImmediate
)
{
const
L10N
=
__webpack_require__
(
36
)
;
const
Services
=
{
}
;
Services
.
strings
=
{
createBundle
:
name
=
>
{
if
(
typeof
name
!
=
=
"
object
"
)
{
throw
new
Error
(
Cannot
implement
'
Services
.
strings
.
createBundle
'
.
Use
'
new
L10N
(
require
(
{
name
}
)
)
'
instead
or
call
this
with
the
return
value
of
a
require
like
'
Services
.
strings
.
createBundle
(
require
(
{
name
}
)
)
'
.
)
;
}
return
new
L10N
(
name
)
;
}
}
;
Services
.
appinfo
=
{
OS
:
'
Darwin
'
}
;
Services
.
telemetry
=
{
getHistogramById
(
)
{
return
{
add
(
)
{
}
}
;
}
}
;
Services
.
obs
=
{
addObserver
:
(
)
=
>
{
}
removeObserver
:
(
)
=
>
{
}
}
Services
.
prefs
=
__webpack_require__
(
37
)
;
Services
.
tm
=
{
currentThread
:
{
dispatch
:
(
cb
)
=
>
{
setImmediate
(
cb
)
;
}
}
mainThread
:
{
dispatch
:
(
cb
)
=
>
{
setImmediate
(
cb
)
;
}
}
}
;
Services
.
scriptloader
=
{
loadSubScript
:
(
url
target
charset
=
"
utf8
"
)
=
>
{
if
(
!
target
|
|
!
target
.
document
)
{
throw
new
Error
(
target
in
loadSubScript
does
not
have
a
document
.
)
;
}
return
new
Promise
(
resolve
=
>
{
let
script
=
target
.
document
.
createElement
(
"
script
"
)
;
script
.
src
=
url
;
script
.
onload
=
resolve
target
.
document
.
body
.
appendChild
(
script
)
;
}
)
;
}
}
;
module
.
exports
.
Services
=
Services
;
}
.
call
(
exports
__webpack_require__
(
34
)
.
setImmediate
)
)
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
setImmediate
clearImmediate
)
{
var
nextTick
=
__webpack_require__
(
35
)
.
nextTick
;
var
apply
=
Function
.
prototype
.
apply
;
var
slice
=
Array
.
prototype
.
slice
;
var
immediateIds
=
{
}
;
var
nextImmediateId
=
0
;
exports
.
setTimeout
=
function
(
)
{
return
new
Timeout
(
apply
.
call
(
setTimeout
window
arguments
)
clearTimeout
)
;
}
;
exports
.
setInterval
=
function
(
)
{
return
new
Timeout
(
apply
.
call
(
setInterval
window
arguments
)
clearInterval
)
;
}
;
exports
.
clearTimeout
=
exports
.
clearInterval
=
function
(
timeout
)
{
timeout
.
close
(
)
;
}
;
function
Timeout
(
id
clearFn
)
{
this
.
_id
=
id
;
this
.
_clearFn
=
clearFn
;
}
Timeout
.
prototype
.
unref
=
Timeout
.
prototype
.
ref
=
function
(
)
{
}
;
Timeout
.
prototype
.
close
=
function
(
)
{
this
.
_clearFn
.
call
(
window
this
.
_id
)
;
}
;
exports
.
enroll
=
function
(
item
msecs
)
{
clearTimeout
(
item
.
_idleTimeoutId
)
;
item
.
_idleTimeout
=
msecs
;
}
;
exports
.
unenroll
=
function
(
item
)
{
clearTimeout
(
item
.
_idleTimeoutId
)
;
item
.
_idleTimeout
=
-
1
;
}
;
exports
.
_unrefActive
=
exports
.
active
=
function
(
item
)
{
clearTimeout
(
item
.
_idleTimeoutId
)
;
var
msecs
=
item
.
_idleTimeout
;
if
(
msecs
>
=
0
)
{
item
.
_idleTimeoutId
=
setTimeout
(
function
onTimeout
(
)
{
if
(
item
.
_onTimeout
)
item
.
_onTimeout
(
)
;
}
msecs
)
;
}
}
;
exports
.
setImmediate
=
typeof
setImmediate
=
=
=
"
function
"
?
setImmediate
:
function
(
fn
)
{
var
id
=
nextImmediateId
+
+
;
var
args
=
arguments
.
length
<
2
?
false
:
slice
.
call
(
arguments
1
)
;
immediateIds
[
id
]
=
true
;
nextTick
(
function
onNextTick
(
)
{
if
(
immediateIds
[
id
]
)
{
if
(
args
)
{
fn
.
apply
(
null
args
)
;
}
else
{
fn
.
call
(
null
)
;
}
exports
.
clearImmediate
(
id
)
;
}
}
)
;
return
id
;
}
;
exports
.
clearImmediate
=
typeof
clearImmediate
=
=
=
"
function
"
?
clearImmediate
:
function
(
id
)
{
delete
immediateIds
[
id
]
;
}
;
}
.
call
(
exports
__webpack_require__
(
34
)
.
setImmediate
__webpack_require__
(
34
)
.
clearImmediate
)
)
}
function
(
module
exports
)
{
var
process
=
module
.
exports
=
{
}
;
var
cachedSetTimeout
;
var
cachedClearTimeout
;
(
function
(
)
{
try
{
cachedSetTimeout
=
setTimeout
;
}
catch
(
e
)
{
cachedSetTimeout
=
function
(
)
{
throw
new
Error
(
'
setTimeout
is
not
defined
'
)
;
}
}
try
{
cachedClearTimeout
=
clearTimeout
;
}
catch
(
e
)
{
cachedClearTimeout
=
function
(
)
{
throw
new
Error
(
'
clearTimeout
is
not
defined
'
)
;
}
}
}
(
)
)
var
queue
=
[
]
;
var
draining
=
false
;
var
currentQueue
;
var
queueIndex
=
-
1
;
function
cleanUpNextTick
(
)
{
if
(
!
draining
|
|
!
currentQueue
)
{
return
;
}
draining
=
false
;
if
(
currentQueue
.
length
)
{
queue
=
currentQueue
.
concat
(
queue
)
;
}
else
{
queueIndex
=
-
1
;
}
if
(
queue
.
length
)
{
drainQueue
(
)
;
}
}
function
drainQueue
(
)
{
if
(
draining
)
{
return
;
}
var
timeout
=
cachedSetTimeout
(
cleanUpNextTick
)
;
draining
=
true
;
var
len
=
queue
.
length
;
while
(
len
)
{
currentQueue
=
queue
;
queue
=
[
]
;
while
(
+
+
queueIndex
<
len
)
{
if
(
currentQueue
)
{
currentQueue
[
queueIndex
]
.
run
(
)
;
}
}
queueIndex
=
-
1
;
len
=
queue
.
length
;
}
currentQueue
=
null
;
draining
=
false
;
cachedClearTimeout
(
timeout
)
;
}
process
.
nextTick
=
function
(
fun
)
{
var
args
=
new
Array
(
arguments
.
length
-
1
)
;
if
(
arguments
.
length
>
1
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
}
queue
.
push
(
new
Item
(
fun
args
)
)
;
if
(
queue
.
length
=
=
=
1
&
&
!
draining
)
{
cachedSetTimeout
(
drainQueue
0
)
;
}
}
;
function
Item
(
fun
array
)
{
this
.
fun
=
fun
;
this
.
array
=
array
;
}
Item
.
prototype
.
run
=
function
(
)
{
this
.
fun
.
apply
(
null
this
.
array
)
;
}
;
process
.
title
=
'
browser
'
;
process
.
browser
=
true
;
process
.
env
=
{
}
;
process
.
argv
=
[
]
;
process
.
version
=
'
'
;
process
.
versions
=
{
}
;
function
noop
(
)
{
}
process
.
on
=
noop
;
process
.
addListener
=
noop
;
process
.
once
=
noop
;
process
.
off
=
noop
;
process
.
removeListener
=
noop
;
process
.
removeAllListeners
=
noop
;
process
.
emit
=
noop
;
process
.
binding
=
function
(
name
)
{
throw
new
Error
(
'
process
.
binding
is
not
supported
'
)
;
}
;
process
.
cwd
=
function
(
)
{
return
'
/
'
}
;
process
.
chdir
=
function
(
dir
)
{
throw
new
Error
(
'
process
.
chdir
is
not
supported
'
)
;
}
;
process
.
umask
=
function
(
)
{
return
0
;
}
;
}
function
(
module
exports
)
{
function
L10N
(
props
)
{
this
.
props
=
props
;
}
L10N
.
prototype
.
GetStringFromName
=
function
(
name
)
{
return
this
.
props
[
name
]
;
}
;
L10N
.
prototype
.
formatStringFromName
=
function
(
name
values
)
{
var
result
=
this
.
GetStringFromName
(
name
)
;
for
(
var
i
=
0
;
i
<
values
.
length
;
i
+
+
)
{
result
=
result
.
replace
(
/
%
S
/
values
[
i
]
)
;
}
return
result
;
}
;
module
.
exports
=
L10N
;
}
function
(
module
exports
__webpack_require__
)
{
let
DEFAULTS
=
__webpack_require__
(
38
)
;
let
storage
=
JSON
.
parse
(
JSON
.
stringify
(
DEFAULTS
)
)
;
const
PREF_INVALID
=
exports
.
PREF_INVALID
=
0
;
const
PREF_STRING
=
exports
.
PREF_STRING
=
32
;
const
PREF_INT
=
exports
.
PREF_INT
=
64
;
const
PREF_BOOL
=
exports
.
PREF_BOOL
=
128
;
function
findPref
(
pref
)
{
let
branchNames
=
pref
.
split
(
"
.
"
)
;
let
branch
=
storage
;
for
(
let
branchName
of
branchNames
)
{
branch
=
branch
[
branchName
]
;
if
(
!
branch
)
{
branch
=
{
}
;
}
}
return
branch
;
}
function
setPrefValue
(
pref
value
)
{
let
obj
=
findPref
(
pref
)
;
obj
.
value
=
value
;
}
function
getPrefValue
(
pref
)
{
return
findPref
(
pref
)
.
value
;
}
const
addObserver
=
exports
.
addObserver
=
function
(
domain
observer
holdWeak
)
{
console
.
log
(
"
TODO
implement
addObserver
"
)
;
}
;
const
removeObserver
=
exports
.
removeObserver
=
function
(
domain
observer
holdWeak
)
{
console
.
log
(
"
TODO
implement
removeObserver
"
)
;
}
;
const
resetPrefs
=
exports
.
resetPrefs
=
function
(
)
{
storage
=
JSON
.
parse
(
JSON
.
stringify
(
DEFAULTS
)
)
;
}
;
const
getPrefType
=
exports
.
getPrefType
=
function
(
pref
)
{
return
findPref
(
pref
)
.
type
;
}
;
const
setBoolPref
=
exports
.
setBoolPref
=
function
(
pref
value
)
{
if
(
typeof
value
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
Cannot
setBoolPref
without
a
boolean
.
"
)
;
}
if
(
getPrefType
(
pref
)
&
&
getPrefType
(
pref
)
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
"
Can
only
call
setBoolPref
on
boolean
type
prefs
.
"
)
;
}
setPrefValue
(
pref
value
)
;
}
;
exports
.
setCharPref
=
function
(
pref
value
)
{
if
(
typeof
value
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Cannot
setCharPref
without
a
string
.
"
)
;
}
if
(
getPrefType
(
pref
)
&
&
getPrefType
(
pref
)
!
=
=
PREF_STRING
)
{
throw
new
Error
(
"
Can
only
call
setCharPref
on
string
type
prefs
.
"
)
;
}
setPrefValue
(
pref
value
)
;
}
;
exports
.
setIntPref
=
function
(
pref
value
)
{
if
(
typeof
value
!
=
=
"
number
"
&
&
(
parseInt
(
value
)
!
=
=
value
)
)
{
throw
new
Error
(
"
Cannot
setCharPref
without
an
integer
.
"
)
;
}
if
(
getPrefType
(
pref
)
&
&
getPrefType
(
pref
)
!
=
=
PREF_INT
)
{
throw
new
Error
(
"
Can
only
call
setIntPref
on
number
type
prefs
.
"
)
;
}
setPrefValue
(
pref
value
)
;
}
;
exports
.
getBoolPref
=
function
(
pref
)
{
if
(
getPrefType
(
pref
)
!
=
=
PREF_BOOL
)
{
console
.
log
(
No
cached
boolean
pref
for
{
pref
}
)
;
return
undefined
;
}
return
getPrefValue
(
pref
)
;
}
;
exports
.
getCharPref
=
function
(
pref
)
{
if
(
getPrefType
(
pref
)
!
=
=
PREF_STRING
)
{
console
.
log
(
No
cached
char
pref
for
{
pref
}
)
;
return
undefined
;
}
return
getPrefValue
(
pref
)
;
}
;
exports
.
getIntPref
=
function
(
pref
)
{
if
(
getPrefType
(
pref
)
!
=
=
PREF_INT
)
{
console
.
log
(
No
cached
int
pref
for
{
pref
}
)
;
return
undefined
;
}
return
getPrefValue
(
pref
)
;
}
;
exports
.
getComplexValue
=
function
(
pref
)
{
return
{
data
:
'
'
}
}
;
exports
.
getBranch
=
function
(
pref
)
{
return
{
addObserver
:
(
)
=
>
{
}
removeObserver
:
(
)
=
>
{
}
}
}
;
exports
.
prefHasUserValue
=
function
(
pref
)
{
return
false
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
{
"
devtools
"
:
{
"
devedition
"
:
{
"
promo
"
:
{
"
shown
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
url
"
:
{
"
value
"
:
"
https
:
/
/
www
.
mozilla
.
org
/
firefox
/
developer
/
?
utm_source
=
firefox
-
dev
-
tools
&
utm_medium
=
firefox
-
browser
&
utm_content
=
betadoorhanger
"
"
type
"
:
32
}
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
errorconsole
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
toolbar
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
visible
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
webide
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
toolbox
"
:
{
"
footer
"
:
{
"
height
"
:
{
"
value
"
:
250
"
type
"
:
64
}
}
"
sidebar
"
:
{
"
width
"
:
{
"
value
"
:
500
"
type
"
:
64
}
}
"
host
"
:
{
"
value
"
:
"
bottom
"
"
type
"
:
32
}
"
previousHost
"
:
{
"
value
"
:
"
side
"
"
type
"
:
32
}
"
selectedTool
"
:
{
"
value
"
:
"
webconsole
"
"
type
"
:
32
}
"
toolbarSpec
"
:
{
"
value
"
:
"
[
\
"
splitconsole
\
"
\
"
paintflashing
toggle
\
"
\
"
tilt
toggle
\
"
\
"
scratchpad
\
"
\
"
resize
toggle
\
"
\
"
eyedropper
\
"
\
"
screenshot
-
-
fullpage
\
"
\
"
rulers
\
"
\
"
measure
\
"
]
"
"
type
"
:
32
}
"
sideEnabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
zoomValue
"
:
{
"
value
"
:
"
1
"
"
type
"
:
32
}
"
splitconsoleEnabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
splitconsoleHeight
"
:
{
"
value
"
:
100
"
type
"
:
64
}
}
"
inspector
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
activeSidebar
"
:
{
"
value
"
:
"
ruleview
"
"
type
"
:
32
}
"
remote
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
show_pseudo_elements
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
imagePreviewTooltipSize
"
:
{
"
value
"
:
300
"
type
"
:
64
}
"
showUserAgentStyles
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
showAllAnonymousContent
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
mdnDocsTooltip
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
}
"
defaultColorUnit
"
:
{
"
value
"
:
"
authored
"
"
type
"
:
32
}
"
debugger
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
workers
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
promise
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
memory
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
performance
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
ui
"
:
{
"
experimental
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
cache
"
:
{
"
disabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
serviceWorkers
"
:
{
"
testing
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
netmonitor
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
statistics
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
filters
"
:
{
"
value
"
:
"
[
\
"
all
\
"
]
"
"
type
"
:
32
}
"
har
"
:
{
"
defaultLogDir
"
:
{
"
value
"
:
"
"
"
type
"
:
32
}
"
defaultFileName
"
:
{
"
value
"
:
"
Archive
%
y
-
%
m
-
%
d
%
H
-
%
M
-
%
S
"
"
type
"
:
32
}
"
jsonp
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
jsonpCallback
"
:
{
"
value
"
:
"
"
"
type
"
:
32
}
"
includeResponseBodies
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
compress
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
forceExport
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
pageLoadedTimeout
"
:
{
"
value
"
:
1500
"
type
"
:
64
}
"
enableAutoExportToFile
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
tilt
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
intro_transition
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
outro_transition
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
scratchpad
"
:
{
"
recentFilesMax
"
:
{
"
value
"
:
10
"
type
"
:
64
}
"
lineNumbers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
wrapText
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
showTrailingSpace
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
editorFontSize
"
:
{
"
value
"
:
12
"
type
"
:
64
}
"
enableAutocompletion
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
storage
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
styleeditor
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
showMediaSidebar
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
mediaSidebarWidth
"
:
{
"
value
"
:
238
"
type
"
:
64
}
"
navSidebarWidth
"
:
{
"
value
"
:
245
"
type
"
:
64
}
"
transitions
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
shadereditor
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
canvasdebugger
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
webaudioeditor
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
inspectorWidth
"
:
{
"
value
"
:
300
"
type
"
:
64
}
}
"
webconsole
"
:
{
"
filter
"
:
{
"
network
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
networkinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
netwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
netxhr
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csserror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
cssparser
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csslog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
exception
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jswarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jslog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
error
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
warn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
info
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
log
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secerror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
serviceworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
sharedworkers
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
windowlessworkers
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
servererror
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverwarn
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverlog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
fontSize
"
:
{
"
value
"
:
0
"
type
"
:
64
}
"
inputHistoryCount
"
:
{
"
value
"
:
50
"
type
"
:
64
}
"
persistlog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
timestampMessages
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
"
browserconsole
"
:
{
"
filter
"
:
{
"
network
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
networkinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
netwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
netxhr
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csserror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
cssparser
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
csslog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
exception
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jswarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
jslog
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
error
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
warn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
info
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
log
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secerror
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
secwarn
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
serviceworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
sharedworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
windowlessworkers
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
servererror
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverwarn
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverinfo
"
:
{
"
value
"
:
false
"
type
"
:
128
}
"
serverlog
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
"
hud
"
:
{
"
loglimit
"
:
{
"
network
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
"
cssparser
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
"
exception
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
"
console
"
:
{
"
value
"
:
1000
"
type
"
:
64
}
}
}
"
eyedropper
"
:
{
"
zoom
"
:
{
"
value
"
:
6
"
type
"
:
64
}
}
"
editor
"
:
{
"
tabsize
"
:
{
"
value
"
:
2
"
type
"
:
64
}
"
expandtab
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
keymap
"
:
{
"
value
"
:
"
default
"
"
type
"
:
32
}
"
autoclosebrackets
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
detectindentation
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
enableCodeFolding
"
:
{
"
value
"
:
true
"
type
"
:
128
}
"
autocomplete
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
fontinspector
"
:
{
"
enabled
"
:
{
"
value
"
:
true
"
type
"
:
128
}
}
"
telemetry
"
:
{
"
tools
"
:
{
"
opened
"
:
{
"
version
"
:
{
"
value
"
:
"
{
}
"
"
type
"
:
32
}
}
}
}
"
jsonview
"
:
{
"
enabled
"
:
{
"
value
"
:
false
"
type
"
:
128
}
}
}
}
}
function
(
module
exports
)
{
let
p
=
typeof
window
!
=
"
undefined
"
?
window
.
Promise
:
Promise
;
p
.
defer
=
function
defer
(
)
{
var
resolve
reject
;
var
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
module
.
exports
=
p
;
}
function
(
module
exports
)
{
}
function
(
module
exports
)
{
module
.
exports
=
{
AppConstants
:
{
}
}
;
}
function
(
module
exports
)
{
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
components
Cc
Ci
Cu
}
=
__webpack_require__
(
28
)
;
const
{
NetUtil
}
=
__webpack_require__
(
42
)
;
const
DevToolsUtils
=
__webpack_require__
(
27
)
;
const
gNSURLStore
=
new
Map
(
)
;
var
NetworkHelper
=
{
convertToUnicode
:
function
NH_convertToUnicode
(
aText
aCharset
)
{
let
conv
=
Cc
(
"
mozilla
.
org
/
intl
/
scriptableunicodeconverter
"
)
.
createInstance
(
Ci
.
nsIScriptableUnicodeConverter
)
;
try
{
conv
.
charset
=
aCharset
|
|
"
UTF
-
8
"
;
return
conv
.
ConvertToUnicode
(
aText
)
;
}
catch
(
ex
)
{
return
aText
;
}
}
readAndConvertFromStream
:
function
NH_readAndConvertFromStream
(
aStream
aCharset
)
{
let
text
=
null
;
try
{
text
=
NetUtil
.
readInputStreamToString
(
aStream
aStream
.
available
(
)
)
return
this
.
convertToUnicode
(
text
aCharset
)
;
}
catch
(
err
)
{
return
text
;
}
}
readPostTextFromRequest
:
function
NH_readPostTextFromRequest
(
aRequest
aCharset
)
{
if
(
aRequest
instanceof
Ci
.
nsIUploadChannel
)
{
let
iStream
=
aRequest
.
uploadStream
;
let
isSeekableStream
=
false
;
if
(
iStream
instanceof
Ci
.
nsISeekableStream
)
{
isSeekableStream
=
true
;
}
let
prevOffset
;
if
(
isSeekableStream
)
{
prevOffset
=
iStream
.
tell
(
)
;
iStream
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
0
)
;
}
let
text
=
this
.
readAndConvertFromStream
(
iStream
aCharset
)
;
if
(
isSeekableStream
&
&
prevOffset
=
=
0
)
{
iStream
.
seek
(
Ci
.
nsISeekableStream
.
NS_SEEK_SET
0
)
;
}
return
text
;
}
return
null
;
}
readPostTextFromPage
:
function
NH_readPostTextFromPage
(
aDocShell
aCharset
)
{
let
webNav
=
aDocShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
return
this
.
readPostTextFromPageViaWebNav
(
webNav
aCharset
)
;
}
readPostTextFromPageViaWebNav
:
function
NH_readPostTextFromPageViaWebNav
(
aWebNav
aCharset
)
{
if
(
aWebNav
instanceof
Ci
.
nsIWebPageDescriptor
)
{
let
descriptor
=
aWebNav
.
currentDescriptor
;
if
(
descriptor
instanceof
Ci
.
nsISHEntry
&
&
descriptor
.
postData
&
&
descriptor
instanceof
Ci
.
nsISeekableStream
)
{
descriptor
.
seek
(
NS_SEEK_SET
0
)
;
return
this
.
readAndConvertFromStream
(
descriptor
aCharset
)
;
}
}
return
null
;
}
getAppIdForRequest
:
function
NH_getAppIdForRequest
(
aRequest
)
{
try
{
return
this
.
getRequestLoadContext
(
aRequest
)
.
appId
;
}
catch
(
ex
)
{
}
return
null
;
}
getTopFrameForRequest
:
function
NH_getTopFrameForRequest
(
aRequest
)
{
try
{
return
this
.
getRequestLoadContext
(
aRequest
)
.
topFrameElement
;
}
catch
(
ex
)
{
}
return
null
;
}
getWindowForRequest
:
function
NH_getWindowForRequest
(
aRequest
)
{
try
{
return
this
.
getRequestLoadContext
(
aRequest
)
.
associatedWindow
;
}
catch
(
ex
)
{
}
return
null
;
}
getRequestLoadContext
:
function
NH_getRequestLoadContext
(
aRequest
)
{
try
{
return
aRequest
.
notificationCallbacks
.
getInterface
(
Ci
.
nsILoadContext
)
;
}
catch
(
ex
)
{
}
try
{
return
aRequest
.
loadGroup
.
notificationCallbacks
.
getInterface
(
Ci
.
nsILoadContext
)
;
}
catch
(
ex
)
{
}
return
null
;
}
isTopLevelLoad
:
function
(
aRequest
)
{
if
(
aRequest
instanceof
Ci
.
nsIChannel
)
{
let
loadInfo
=
aRequest
.
loadInfo
;
if
(
loadInfo
&
&
loadInfo
.
parentOuterWindowID
=
=
loadInfo
.
outerWindowID
)
{
return
(
aRequest
.
loadFlags
&
Ci
.
nsIChannel
.
LOAD_DOCUMENT_URI
)
;
}
}
return
false
;
}
loadFromCache
:
function
NH_loadFromCache
(
aUrl
aCharset
aCallback
)
{
let
channel
=
NetUtil
.
newChannel
(
{
uri
:
aUrl
loadUsingSystemPrincipal
:
true
}
)
;
channel
.
loadFlags
=
Ci
.
nsIRequest
.
LOAD_FROM_CACHE
|
Ci
.
nsICachingChannel
.
LOAD_ONLY_FROM_CACHE
|
Ci
.
nsICachingChannel
.
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
;
NetUtil
.
asyncFetch
(
channel
(
aInputStream
aStatusCode
aRequest
)
=
>
{
if
(
!
components
.
isSuccessCode
(
aStatusCode
)
)
{
aCallback
(
null
)
;
return
;
}
let
aChannel
=
aRequest
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
contentCharset
=
aChannel
.
contentCharset
|
|
aCharset
;
aCallback
(
this
.
readAndConvertFromStream
(
aInputStream
contentCharset
)
)
;
}
)
;
}
parseCookieHeader
:
function
NH_parseCookieHeader
(
aHeader
)
{
let
cookies
=
aHeader
.
split
(
"
;
"
)
;
let
result
=
[
]
;
cookies
.
forEach
(
function
(
aCookie
)
{
let
equal
=
aCookie
.
indexOf
(
"
=
"
)
;
let
name
=
aCookie
.
substr
(
0
equal
)
;
let
value
=
aCookie
.
substr
(
equal
+
1
)
;
result
.
push
(
{
name
:
unescape
(
name
.
trim
(
)
)
value
:
unescape
(
value
.
trim
(
)
)
}
)
;
}
)
;
return
result
;
}
parseSetCookieHeader
:
function
NH_parseSetCookieHeader
(
aHeader
)
{
let
rawCookies
=
aHeader
.
split
(
/
\
r
\
n
|
\
n
|
\
r
/
)
;
let
cookies
=
[
]
;
rawCookies
.
forEach
(
function
(
aCookie
)
{
let
equal
=
aCookie
.
indexOf
(
"
=
"
)
;
let
name
=
unescape
(
aCookie
.
substr
(
0
equal
)
.
trim
(
)
)
;
let
parts
=
aCookie
.
substr
(
equal
+
1
)
.
split
(
"
;
"
)
;
let
value
=
unescape
(
parts
.
shift
(
)
.
trim
(
)
)
;
let
cookie
=
{
name
:
name
value
:
value
}
;
parts
.
forEach
(
function
(
aPart
)
{
let
part
=
aPart
.
trim
(
)
;
if
(
part
.
toLowerCase
(
)
=
=
"
secure
"
)
{
cookie
.
secure
=
true
;
}
else
if
(
part
.
toLowerCase
(
)
=
=
"
httponly
"
)
{
cookie
.
httpOnly
=
true
;
}
else
if
(
part
.
indexOf
(
"
=
"
)
>
-
1
)
{
let
pair
=
part
.
split
(
"
=
"
)
;
pair
[
0
]
=
pair
[
0
]
.
toLowerCase
(
)
;
if
(
pair
[
0
]
=
=
"
path
"
|
|
pair
[
0
]
=
=
"
domain
"
)
{
cookie
[
pair
[
0
]
]
=
pair
[
1
]
;
}
else
if
(
pair
[
0
]
=
=
"
expires
"
)
{
try
{
pair
[
1
]
=
pair
[
1
]
.
replace
(
/
-
/
g
'
'
)
;
cookie
.
expires
=
new
Date
(
pair
[
1
]
)
.
toISOString
(
)
;
}
catch
(
ex
)
{
}
}
}
}
)
;
cookies
.
push
(
cookie
)
;
}
)
;
return
cookies
;
}
mimeCategoryMap
:
{
"
text
/
plain
"
:
"
txt
"
"
text
/
html
"
:
"
html
"
"
text
/
xml
"
:
"
xml
"
"
text
/
xsl
"
:
"
txt
"
"
text
/
xul
"
:
"
txt
"
"
text
/
css
"
:
"
css
"
"
text
/
sgml
"
:
"
txt
"
"
text
/
rtf
"
:
"
txt
"
"
text
/
x
-
setext
"
:
"
txt
"
"
text
/
richtext
"
:
"
txt
"
"
text
/
javascript
"
:
"
js
"
"
text
/
jscript
"
:
"
txt
"
"
text
/
tab
-
separated
-
values
"
:
"
txt
"
"
text
/
rdf
"
:
"
txt
"
"
text
/
xif
"
:
"
txt
"
"
text
/
ecmascript
"
:
"
js
"
"
text
/
vnd
.
curl
"
:
"
txt
"
"
text
/
x
-
json
"
:
"
json
"
"
text
/
x
-
js
"
:
"
txt
"
"
text
/
js
"
:
"
txt
"
"
text
/
vbscript
"
:
"
txt
"
"
view
-
source
"
:
"
txt
"
"
view
-
fragment
"
:
"
txt
"
"
application
/
xml
"
:
"
xml
"
"
application
/
xhtml
+
xml
"
:
"
xml
"
"
application
/
atom
+
xml
"
:
"
xml
"
"
application
/
rss
+
xml
"
:
"
xml
"
"
application
/
vnd
.
mozilla
.
maybe
.
feed
"
:
"
xml
"
"
application
/
vnd
.
mozilla
.
xul
+
xml
"
:
"
xml
"
"
application
/
javascript
"
:
"
js
"
"
application
/
x
-
javascript
"
:
"
js
"
"
application
/
x
-
httpd
-
php
"
:
"
txt
"
"
application
/
rdf
+
xml
"
:
"
xml
"
"
application
/
ecmascript
"
:
"
js
"
"
application
/
http
-
index
-
format
"
:
"
txt
"
"
application
/
json
"
:
"
json
"
"
application
/
x
-
js
"
:
"
txt
"
"
multipart
/
mixed
"
:
"
txt
"
"
multipart
/
x
-
mixed
-
replace
"
:
"
txt
"
"
image
/
svg
+
xml
"
:
"
svg
"
"
application
/
octet
-
stream
"
:
"
bin
"
"
image
/
jpeg
"
:
"
image
"
"
image
/
jpg
"
:
"
image
"
"
image
/
gif
"
:
"
image
"
"
image
/
png
"
:
"
image
"
"
image
/
bmp
"
:
"
image
"
"
application
/
x
-
shockwave
-
flash
"
:
"
flash
"
"
video
/
x
-
flv
"
:
"
flash
"
"
audio
/
mpeg3
"
:
"
media
"
"
audio
/
x
-
mpeg
-
3
"
:
"
media
"
"
video
/
mpeg
"
:
"
media
"
"
video
/
x
-
mpeg
"
:
"
media
"
"
audio
/
ogg
"
:
"
media
"
"
application
/
ogg
"
:
"
media
"
"
application
/
x
-
ogg
"
:
"
media
"
"
application
/
x
-
midi
"
:
"
media
"
"
audio
/
midi
"
:
"
media
"
"
audio
/
x
-
mid
"
:
"
media
"
"
audio
/
x
-
midi
"
:
"
media
"
"
music
/
crescendo
"
:
"
media
"
"
audio
/
wav
"
:
"
media
"
"
audio
/
x
-
wav
"
:
"
media
"
"
text
/
json
"
:
"
json
"
"
application
/
x
-
json
"
:
"
json
"
"
application
/
json
-
rpc
"
:
"
json
"
"
application
/
x
-
web
-
app
-
manifest
+
json
"
:
"
json
"
"
application
/
manifest
+
json
"
:
"
json
"
}
isTextMimeType
:
function
NH_isTextMimeType
(
aMimeType
)
{
if
(
aMimeType
.
indexOf
(
"
text
/
"
)
=
=
0
)
{
return
true
;
}
if
(
/
^
application
\
/
\
w
+
(
?
:
[
\
.
-
]
\
w
+
)
*
(
?
:
\
+
xml
|
[
-
+
]
json
)
/
.
test
(
aMimeType
)
)
{
return
true
;
}
let
category
=
this
.
mimeCategoryMap
[
aMimeType
]
|
|
null
;
switch
(
category
)
{
case
"
txt
"
:
case
"
js
"
:
case
"
json
"
:
case
"
css
"
:
case
"
html
"
:
case
"
svg
"
:
case
"
xml
"
:
return
true
;
default
:
return
false
;
}
}
parseSecurityInfo
:
function
NH_parseSecurityInfo
(
securityInfo
httpActivity
)
{
const
info
=
{
state
:
"
insecure
"
}
;
if
(
!
securityInfo
)
{
return
info
;
}
securityInfo
.
QueryInterface
(
Ci
.
nsITransportSecurityInfo
)
;
securityInfo
.
QueryInterface
(
Ci
.
nsISSLStatusProvider
)
;
const
wpl
=
Ci
.
nsIWebProgressListener
;
const
NSSErrorsService
=
Cc
[
'
mozilla
.
org
/
nss_errors_service
;
1
'
]
.
getService
(
Ci
.
nsINSSErrorsService
)
;
const
SSLStatus
=
securityInfo
.
SSLStatus
;
if
(
!
NSSErrorsService
.
isNSSErrorCode
(
securityInfo
.
errorCode
)
)
{
const
state
=
securityInfo
.
securityState
;
let
uri
=
null
;
if
(
httpActivity
.
channel
&
&
httpActivity
.
channel
.
URI
)
{
uri
=
httpActivity
.
channel
.
URI
;
}
if
(
uri
&
&
!
uri
.
schemeIs
(
"
https
"
)
&
&
!
uri
.
schemeIs
(
"
wss
"
)
)
{
info
.
state
=
"
insecure
"
;
}
else
if
(
state
&
wpl
.
STATE_IS_SECURE
)
{
info
.
state
=
"
secure
"
;
}
else
if
(
state
&
wpl
.
STATE_IS_BROKEN
)
{
info
.
state
=
"
weak
"
;
info
.
weaknessReasons
=
this
.
getReasonsForWeakness
(
state
)
;
}
else
if
(
state
&
wpl
.
STATE_IS_INSECURE
)
{
return
info
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseSecurityInfo
"
"
Security
state
"
+
state
+
"
has
no
known
STATE_IS_
*
flags
.
"
)
;
return
info
;
}
info
.
cipherSuite
=
SSLStatus
.
cipherName
;
info
.
protocolVersion
=
this
.
formatSecurityProtocol
(
SSLStatus
.
protocolVersion
)
;
info
.
cert
=
this
.
parseCertificateInfo
(
SSLStatus
.
serverCert
)
;
if
(
httpActivity
.
hostname
)
{
const
sss
=
Cc
(
"
mozilla
.
org
/
ssservice
;
1
"
)
.
getService
(
Ci
.
nsISiteSecurityService
)
;
let
flags
=
(
httpActivity
.
private
)
?
Ci
.
nsISocketProvider
.
NO_PERMANENT_STORAGE
:
0
;
let
host
=
httpActivity
.
hostname
;
info
.
hsts
=
sss
.
isSecureHost
(
sss
.
HEADER_HSTS
host
flags
)
;
info
.
hpkp
=
sss
.
isSecureHost
(
sss
.
HEADER_HPKP
host
flags
)
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseSecurityInfo
"
"
Could
not
get
HSTS
/
HPKP
status
as
hostname
is
not
available
.
"
)
;
info
.
hsts
=
false
;
info
.
hpkp
=
false
;
}
}
else
{
info
.
state
=
"
broken
"
;
info
.
errorMessage
=
securityInfo
.
errorMessage
;
}
return
info
;
}
parseCertificateInfo
:
function
NH_parseCertifificateInfo
(
cert
)
{
let
info
=
{
}
;
if
(
cert
)
{
info
.
subject
=
{
commonName
:
cert
.
commonName
organization
:
cert
.
organization
organizationalUnit
:
cert
.
organizationalUnit
}
;
info
.
issuer
=
{
commonName
:
cert
.
issuerCommonName
organization
:
cert
.
issuerOrganization
organizationUnit
:
cert
.
issuerOrganizationUnit
}
;
info
.
validity
=
{
start
:
cert
.
validity
.
notBeforeLocalDay
end
:
cert
.
validity
.
notAfterLocalDay
}
;
info
.
fingerprint
=
{
sha1
:
cert
.
sha1Fingerprint
sha256
:
cert
.
sha256Fingerprint
}
;
}
else
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
parseCertificateInfo
"
"
Secure
connection
established
without
certificate
.
"
)
;
}
return
info
;
}
formatSecurityProtocol
:
function
NH_formatSecurityProtocol
(
version
)
{
switch
(
version
)
{
case
Ci
.
nsISSLStatus
.
TLS_VERSION_1
:
return
"
TLSv1
"
;
case
Ci
.
nsISSLStatus
.
TLS_VERSION_1_1
:
return
"
TLSv1
.
1
"
;
case
Ci
.
nsISSLStatus
.
TLS_VERSION_1_2
:
return
"
TLSv1
.
2
"
;
default
:
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
formatSecurityProtocol
"
"
protocolVersion
"
+
version
+
"
is
unknown
.
"
)
;
return
"
Unknown
"
;
}
}
getReasonsForWeakness
:
function
NH_getReasonsForWeakness
(
state
)
{
const
wpl
=
Ci
.
nsIWebProgressListener
;
let
reasons
=
[
]
;
if
(
state
&
wpl
.
STATE_IS_BROKEN
)
{
let
isCipher
=
state
&
wpl
.
STATE_USES_WEAK_CRYPTO
;
if
(
isCipher
)
{
reasons
.
push
(
"
cipher
"
)
;
}
if
(
!
isCipher
)
{
DevToolsUtils
.
reportException
(
"
NetworkHelper
.
getReasonsForWeakness
"
"
STATE_IS_BROKEN
without
a
known
reason
.
Full
state
was
:
"
+
state
)
;
}
}
return
reasons
;
}
parseQueryString
:
function
(
aQueryString
)
{
if
(
!
aQueryString
)
{
return
;
}
let
paramsArray
=
aQueryString
.
replace
(
/
^
[
?
&
]
/
"
"
)
.
split
(
"
&
"
)
.
map
(
e
=
>
{
let
param
=
e
.
split
(
"
=
"
)
;
return
{
name
:
param
[
0
]
?
NetworkHelper
.
convertToUnicode
(
unescape
(
param
[
0
]
)
)
:
"
"
value
:
param
[
1
]
?
NetworkHelper
.
convertToUnicode
(
unescape
(
param
[
1
]
)
)
:
"
"
}
}
)
;
return
paramsArray
;
}
nsIURL
:
function
(
aUrl
aStore
=
gNSURLStore
)
{
if
(
aStore
.
has
(
aUrl
)
)
{
return
aStore
.
get
(
aUrl
)
;
}
let
uri
=
Services
.
io
.
newURI
(
aUrl
null
null
)
.
QueryInterface
(
Ci
.
nsIURL
)
;
aStore
.
set
(
aUrl
uri
)
;
return
uri
;
}
}
;
for
(
let
prop
of
Object
.
getOwnPropertyNames
(
NetworkHelper
)
)
{
exports
[
prop
]
=
NetworkHelper
[
prop
]
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
46
)
;
var
isDevelopment
=
_require
.
isDevelopment
;
var
isTesting
=
_require
.
isTesting
;
function
debugGlobal
(
field
value
)
{
if
(
isDevelopment
(
)
|
|
isTesting
(
)
)
{
window
[
field
]
=
value
;
}
}
function
injectGlobals
(
_ref
)
{
var
store
=
_ref
.
store
;
debugGlobal
(
"
store
"
store
)
;
debugGlobal
(
"
injectDebuggee
"
__webpack_require__
(
95
)
)
;
debugGlobal
(
"
serializeStore
"
(
)
=
>
{
return
JSON
.
parse
(
JSON
.
stringify
(
store
.
getState
(
)
)
)
;
}
)
;
}
module
.
exports
=
{
debugGlobal
injectGlobals
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
feature
=
__webpack_require__
(
47
)
;
module
.
exports
=
feature
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
flag
=
__webpack_require__
(
48
)
;
var
pick
=
__webpack_require__
(
49
)
;
var
config
=
void
0
;
function
getValue
(
key
)
{
return
pick
(
config
key
)
;
}
function
isEnabled
(
key
)
{
return
config
.
features
[
key
]
;
}
function
isDevelopment
(
)
{
if
(
isFirefoxPanel
(
)
)
{
return
(
"
production
"
)
=
=
=
"
development
"
;
}
return
(
"
production
"
)
!
=
=
"
production
"
;
}
function
isTesting
(
)
{
return
flag
.
testing
;
}
function
isFirefoxPanel
(
)
{
return
(
"
firefox
-
panel
"
)
=
=
"
firefox
-
panel
"
;
}
function
isFirefox
(
)
{
return
(
/
firefox
/
i
.
test
(
navigator
.
userAgent
)
)
;
}
function
setConfig
(
value
)
{
config
=
value
;
}
function
getConfig
(
)
{
return
config
;
}
module
.
exports
=
{
isEnabled
getValue
isDevelopment
isTesting
isFirefoxPanel
isFirefox
getConfig
setConfig
}
;
}
function
(
module
exports
)
{
module
.
exports
=
devtoolsRequire
(
'
devtools
/
shared
/
flags
'
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseGet
=
__webpack_require__
(
50
)
;
function
get
(
object
path
defaultValue
)
{
var
result
=
object
=
=
null
?
undefined
:
baseGet
(
object
path
)
;
return
result
=
=
=
undefined
?
defaultValue
:
result
;
}
module
.
exports
=
get
;
}
function
(
module
exports
__webpack_require__
)
{
var
castPath
=
__webpack_require__
(
51
)
isKey
=
__webpack_require__
(
93
)
toKey
=
__webpack_require__
(
94
)
;
function
baseGet
(
object
path
)
{
path
=
isKey
(
path
object
)
?
[
path
]
:
castPath
(
path
)
;
var
index
=
0
length
=
path
.
length
;
while
(
object
!
=
null
&
&
index
<
length
)
{
object
=
object
[
toKey
(
path
[
index
+
+
]
)
]
;
}
return
(
index
&
&
index
=
=
length
)
?
object
:
undefined
;
}
module
.
exports
=
baseGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
52
)
stringToPath
=
__webpack_require__
(
53
)
;
function
castPath
(
value
)
{
return
isArray
(
value
)
?
value
:
stringToPath
(
value
)
;
}
module
.
exports
=
castPath
;
}
function
(
module
exports
)
{
var
isArray
=
Array
.
isArray
;
module
.
exports
=
isArray
;
}
function
(
module
exports
__webpack_require__
)
{
var
memoize
=
__webpack_require__
(
54
)
toString
=
__webpack_require__
(
89
)
;
var
rePropName
=
/
[
^
.
[
\
]
]
+
|
\
[
(
?
:
(
-
?
\
d
+
(
?
:
\
.
\
d
+
)
?
)
|
(
[
"
'
]
)
(
(
?
:
(
?
!
\
2
)
[
^
\
\
]
|
\
\
.
)
*
?
)
\
2
)
\
]
|
(
?
=
(
\
.
|
\
[
\
]
)
(
?
:
\
4
|
)
)
/
g
;
var
reEscapeChar
=
/
\
\
(
\
\
)
?
/
g
;
var
stringToPath
=
memoize
(
function
(
string
)
{
var
result
=
[
]
;
toString
(
string
)
.
replace
(
rePropName
function
(
match
number
quote
string
)
{
result
.
push
(
quote
?
string
.
replace
(
reEscapeChar
'
1
'
)
:
(
number
|
|
match
)
)
;
}
)
;
return
result
;
}
)
;
module
.
exports
=
stringToPath
;
}
function
(
module
exports
__webpack_require__
)
{
var
MapCache
=
__webpack_require__
(
55
)
;
var
FUNC_ERROR_TEXT
=
'
Expected
a
function
'
;
function
memoize
(
func
resolver
)
{
if
(
typeof
func
!
=
'
function
'
|
|
(
resolver
&
&
typeof
resolver
!
=
'
function
'
)
)
{
throw
new
TypeError
(
FUNC_ERROR_TEXT
)
;
}
var
memoized
=
function
(
)
{
var
args
=
arguments
key
=
resolver
?
resolver
.
apply
(
this
args
)
:
args
[
0
]
cache
=
memoized
.
cache
;
if
(
cache
.
has
(
key
)
)
{
return
cache
.
get
(
key
)
;
}
var
result
=
func
.
apply
(
this
args
)
;
memoized
.
cache
=
cache
.
set
(
key
result
)
;
return
result
;
}
;
memoized
.
cache
=
new
(
memoize
.
Cache
|
|
MapCache
)
;
return
memoized
;
}
memoize
.
Cache
=
MapCache
;
module
.
exports
=
memoize
;
}
function
(
module
exports
__webpack_require__
)
{
var
mapCacheClear
=
__webpack_require__
(
56
)
mapCacheDelete
=
__webpack_require__
(
83
)
mapCacheGet
=
__webpack_require__
(
86
)
mapCacheHas
=
__webpack_require__
(
87
)
mapCacheSet
=
__webpack_require__
(
88
)
;
function
MapCache
(
entries
)
{
var
index
=
-
1
length
=
entries
?
entries
.
length
:
0
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
MapCache
.
prototype
.
clear
=
mapCacheClear
;
MapCache
.
prototype
[
'
delete
'
]
=
mapCacheDelete
;
MapCache
.
prototype
.
get
=
mapCacheGet
;
MapCache
.
prototype
.
has
=
mapCacheHas
;
MapCache
.
prototype
.
set
=
mapCacheSet
;
module
.
exports
=
MapCache
;
}
function
(
module
exports
__webpack_require__
)
{
var
Hash
=
__webpack_require__
(
57
)
ListCache
=
__webpack_require__
(
74
)
Map
=
__webpack_require__
(
82
)
;
function
mapCacheClear
(
)
{
this
.
__data__
=
{
'
hash
'
:
new
Hash
'
map
'
:
new
(
Map
|
|
ListCache
)
'
string
'
:
new
Hash
}
;
}
module
.
exports
=
mapCacheClear
;
}
function
(
module
exports
__webpack_require__
)
{
var
hashClear
=
__webpack_require__
(
58
)
hashDelete
=
__webpack_require__
(
70
)
hashGet
=
__webpack_require__
(
71
)
hashHas
=
__webpack_require__
(
72
)
hashSet
=
__webpack_require__
(
73
)
;
function
Hash
(
entries
)
{
var
index
=
-
1
length
=
entries
?
entries
.
length
:
0
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
Hash
.
prototype
.
clear
=
hashClear
;
Hash
.
prototype
[
'
delete
'
]
=
hashDelete
;
Hash
.
prototype
.
get
=
hashGet
;
Hash
.
prototype
.
has
=
hashHas
;
Hash
.
prototype
.
set
=
hashSet
;
module
.
exports
=
Hash
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
59
)
;
function
hashClear
(
)
{
this
.
__data__
=
nativeCreate
?
nativeCreate
(
null
)
:
{
}
;
}
module
.
exports
=
hashClear
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
60
)
;
var
nativeCreate
=
getNative
(
Object
'
create
'
)
;
module
.
exports
=
nativeCreate
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseIsNative
=
__webpack_require__
(
61
)
getValue
=
__webpack_require__
(
69
)
;
function
getNative
(
object
key
)
{
var
value
=
getValue
(
object
key
)
;
return
baseIsNative
(
value
)
?
value
:
undefined
;
}
module
.
exports
=
getNative
;
}
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
62
)
isHostObject
=
__webpack_require__
(
6
)
isMasked
=
__webpack_require__
(
64
)
isObject
=
__webpack_require__
(
63
)
toSource
=
__webpack_require__
(
68
)
;
var
reRegExpChar
=
/
[
\
\
^
.
*
+
?
(
)
[
\
]
{
}
|
]
/
g
;
var
reIsHostCtor
=
/
^
\
[
object
.
+
?
Constructor
\
]
/
;
var
objectProto
=
Object
.
prototype
;
var
funcToString
=
Function
.
prototype
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
reIsNative
=
RegExp
(
'
^
'
+
funcToString
.
call
(
hasOwnProperty
)
.
replace
(
reRegExpChar
'
\
\
&
'
)
.
replace
(
/
hasOwnProperty
|
(
function
)
.
*
?
(
?
=
\
\
\
(
)
|
for
.
+
?
(
?
=
\
\
\
]
)
/
g
'
1
.
*
?
'
)
+
'
'
)
;
function
baseIsNative
(
value
)
{
if
(
!
isObject
(
value
)
|
|
isMasked
(
value
)
)
{
return
false
;
}
var
pattern
=
(
isFunction
(
value
)
|
|
isHostObject
(
value
)
)
?
reIsNative
:
reIsHostCtor
;
return
pattern
.
test
(
toSource
(
value
)
)
;
}
module
.
exports
=
baseIsNative
;
}
function
(
module
exports
__webpack_require__
)
{
var
isObject
=
__webpack_require__
(
63
)
;
var
funcTag
=
'
[
object
Function
]
'
genTag
=
'
[
object
GeneratorFunction
]
'
;
var
objectProto
=
Object
.
prototype
;
var
objectToString
=
objectProto
.
toString
;
function
isFunction
(
value
)
{
var
tag
=
isObject
(
value
)
?
objectToString
.
call
(
value
)
:
'
'
;
return
tag
=
=
funcTag
|
|
tag
=
=
genTag
;
}
module
.
exports
=
isFunction
;
}
function
(
module
exports
)
{
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
module
.
exports
=
isObject
;
}
function
(
module
exports
__webpack_require__
)
{
var
coreJsData
=
__webpack_require__
(
65
)
;
var
maskSrcKey
=
(
function
(
)
{
var
uid
=
/
[
^
.
]
+
/
.
exec
(
coreJsData
&
&
coreJsData
.
keys
&
&
coreJsData
.
keys
.
IE_PROTO
|
|
'
'
)
;
return
uid
?
(
'
Symbol
(
src
)
_1
.
'
+
uid
)
:
'
'
;
}
(
)
)
;
function
isMasked
(
func
)
{
return
!
!
maskSrcKey
&
&
(
maskSrcKey
in
func
)
;
}
module
.
exports
=
isMasked
;
}
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
66
)
;
var
coreJsData
=
root
[
'
__core
-
js_shared__
'
]
;
module
.
exports
=
coreJsData
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
)
{
var
checkGlobal
=
__webpack_require__
(
67
)
;
var
freeGlobal
=
checkGlobal
(
typeof
global
=
=
'
object
'
&
&
global
)
;
var
freeSelf
=
checkGlobal
(
typeof
self
=
=
'
object
'
&
&
self
)
;
var
thisGlobal
=
checkGlobal
(
typeof
this
=
=
'
object
'
&
&
this
)
;
var
root
=
freeGlobal
|
|
freeSelf
|
|
thisGlobal
|
|
Function
(
'
return
this
'
)
(
)
;
module
.
exports
=
root
;
}
.
call
(
exports
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
)
{
function
checkGlobal
(
value
)
{
return
(
value
&
&
value
.
Object
=
=
=
Object
)
?
value
:
null
;
}
module
.
exports
=
checkGlobal
;
}
function
(
module
exports
)
{
var
funcToString
=
Function
.
prototype
.
toString
;
function
toSource
(
func
)
{
if
(
func
!
=
null
)
{
try
{
return
funcToString
.
call
(
func
)
;
}
catch
(
e
)
{
}
try
{
return
(
func
+
'
'
)
;
}
catch
(
e
)
{
}
}
return
'
'
;
}
module
.
exports
=
toSource
;
}
function
(
module
exports
)
{
function
getValue
(
object
key
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
module
.
exports
=
getValue
;
}
function
(
module
exports
)
{
function
hashDelete
(
key
)
{
return
this
.
has
(
key
)
&
&
delete
this
.
__data__
[
key
]
;
}
module
.
exports
=
hashDelete
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
59
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashGet
(
key
)
{
var
data
=
this
.
__data__
;
if
(
nativeCreate
)
{
var
result
=
data
[
key
]
;
return
result
=
=
=
HASH_UNDEFINED
?
undefined
:
result
;
}
return
hasOwnProperty
.
call
(
data
key
)
?
data
[
key
]
:
undefined
;
}
module
.
exports
=
hashGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
59
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashHas
(
key
)
{
var
data
=
this
.
__data__
;
return
nativeCreate
?
data
[
key
]
!
=
=
undefined
:
hasOwnProperty
.
call
(
data
key
)
;
}
module
.
exports
=
hashHas
;
}
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
59
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
function
hashSet
(
key
value
)
{
var
data
=
this
.
__data__
;
data
[
key
]
=
(
nativeCreate
&
&
value
=
=
=
undefined
)
?
HASH_UNDEFINED
:
value
;
return
this
;
}
module
.
exports
=
hashSet
;
}
function
(
module
exports
__webpack_require__
)
{
var
listCacheClear
=
__webpack_require__
(
75
)
listCacheDelete
=
__webpack_require__
(
76
)
listCacheGet
=
__webpack_require__
(
79
)
listCacheHas
=
__webpack_require__
(
80
)
listCacheSet
=
__webpack_require__
(
81
)
;
function
ListCache
(
entries
)
{
var
index
=
-
1
length
=
entries
?
entries
.
length
:
0
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
ListCache
.
prototype
.
clear
=
listCacheClear
;
ListCache
.
prototype
[
'
delete
'
]
=
listCacheDelete
;
ListCache
.
prototype
.
get
=
listCacheGet
;
ListCache
.
prototype
.
has
=
listCacheHas
;
ListCache
.
prototype
.
set
=
listCacheSet
;
module
.
exports
=
ListCache
;
}
function
(
module
exports
)
{
function
listCacheClear
(
)
{
this
.
__data__
=
[
]
;
}
module
.
exports
=
listCacheClear
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
77
)
;
var
arrayProto
=
Array
.
prototype
;
var
splice
=
arrayProto
.
splice
;
function
listCacheDelete
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
return
false
;
}
var
lastIndex
=
data
.
length
-
1
;
if
(
index
=
=
lastIndex
)
{
data
.
pop
(
)
;
}
else
{
splice
.
call
(
data
index
1
)
;
}
return
true
;
}
module
.
exports
=
listCacheDelete
;
}
function
(
module
exports
__webpack_require__
)
{
var
eq
=
__webpack_require__
(
78
)
;
function
assocIndexOf
(
array
key
)
{
var
length
=
array
.
length
;
while
(
length
-
-
)
{
if
(
eq
(
array
[
length
]
[
0
]
key
)
)
{
return
length
;
}
}
return
-
1
;
}
module
.
exports
=
assocIndexOf
;
}
function
(
module
exports
)
{
function
eq
(
value
other
)
{
return
value
=
=
=
other
|
|
(
value
!
=
=
value
&
&
other
!
=
=
other
)
;
}
module
.
exports
=
eq
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
77
)
;
function
listCacheGet
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
return
index
<
0
?
undefined
:
data
[
index
]
[
1
]
;
}
module
.
exports
=
listCacheGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
77
)
;
function
listCacheHas
(
key
)
{
return
assocIndexOf
(
this
.
__data__
key
)
>
-
1
;
}
module
.
exports
=
listCacheHas
;
}
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
77
)
;
function
listCacheSet
(
key
value
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
data
.
push
(
[
key
value
]
)
;
}
else
{
data
[
index
]
[
1
]
=
value
;
}
return
this
;
}
module
.
exports
=
listCacheSet
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
60
)
root
=
__webpack_require__
(
66
)
;
var
Map
=
getNative
(
root
'
Map
'
)
;
module
.
exports
=
Map
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
84
)
;
function
mapCacheDelete
(
key
)
{
return
getMapData
(
this
key
)
[
'
delete
'
]
(
key
)
;
}
module
.
exports
=
mapCacheDelete
;
}
function
(
module
exports
__webpack_require__
)
{
var
isKeyable
=
__webpack_require__
(
85
)
;
function
getMapData
(
map
key
)
{
var
data
=
map
.
__data__
;
return
isKeyable
(
key
)
?
data
[
typeof
key
=
=
'
string
'
?
'
string
'
:
'
hash
'
]
:
data
.
map
;
}
module
.
exports
=
getMapData
;
}
function
(
module
exports
)
{
function
isKeyable
(
value
)
{
var
type
=
typeof
value
;
return
(
type
=
=
'
string
'
|
|
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
)
?
(
value
!
=
=
'
__proto__
'
)
:
(
value
=
=
=
null
)
;
}
module
.
exports
=
isKeyable
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
84
)
;
function
mapCacheGet
(
key
)
{
return
getMapData
(
this
key
)
.
get
(
key
)
;
}
module
.
exports
=
mapCacheGet
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
84
)
;
function
mapCacheHas
(
key
)
{
return
getMapData
(
this
key
)
.
has
(
key
)
;
}
module
.
exports
=
mapCacheHas
;
}
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
84
)
;
function
mapCacheSet
(
key
value
)
{
getMapData
(
this
key
)
.
set
(
key
value
)
;
return
this
;
}
module
.
exports
=
mapCacheSet
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseToString
=
__webpack_require__
(
90
)
;
function
toString
(
value
)
{
return
value
=
=
null
?
'
'
:
baseToString
(
value
)
;
}
module
.
exports
=
toString
;
}
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
91
)
isSymbol
=
__webpack_require__
(
92
)
;
var
INFINITY
=
1
/
0
;
var
symbolProto
=
Symbol
?
Symbol
.
prototype
:
undefined
symbolToString
=
symbolProto
?
symbolProto
.
toString
:
undefined
;
function
baseToString
(
value
)
{
if
(
typeof
value
=
=
'
string
'
)
{
return
value
;
}
if
(
isSymbol
(
value
)
)
{
return
symbolToString
?
symbolToString
.
call
(
value
)
:
'
'
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
baseToString
;
}
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
66
)
;
var
Symbol
=
root
.
Symbol
;
module
.
exports
=
Symbol
;
}
function
(
module
exports
__webpack_require__
)
{
var
isObjectLike
=
__webpack_require__
(
7
)
;
var
symbolTag
=
'
[
object
Symbol
]
'
;
var
objectProto
=
Object
.
prototype
;
var
objectToString
=
objectProto
.
toString
;
function
isSymbol
(
value
)
{
return
typeof
value
=
=
'
symbol
'
|
|
(
isObjectLike
(
value
)
&
&
objectToString
.
call
(
value
)
=
=
symbolTag
)
;
}
module
.
exports
=
isSymbol
;
}
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
52
)
isSymbol
=
__webpack_require__
(
92
)
;
var
reIsDeepProp
=
/
\
.
|
\
[
(
?
:
[
^
[
\
]
]
*
|
(
[
"
'
]
)
(
?
:
(
?
!
\
1
)
[
^
\
\
]
|
\
\
.
)
*
?
\
1
)
\
]
/
reIsPlainProp
=
/
^
\
w
*
/
;
function
isKey
(
value
object
)
{
if
(
isArray
(
value
)
)
{
return
false
;
}
var
type
=
typeof
value
;
if
(
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
|
|
value
=
=
null
|
|
isSymbol
(
value
)
)
{
return
true
;
}
return
reIsPlainProp
.
test
(
value
)
|
|
!
reIsDeepProp
.
test
(
value
)
|
|
(
object
!
=
null
&
&
value
in
Object
(
object
)
)
;
}
module
.
exports
=
isKey
;
}
function
(
module
exports
__webpack_require__
)
{
var
isSymbol
=
__webpack_require__
(
92
)
;
var
INFINITY
=
1
/
0
;
function
toKey
(
value
)
{
if
(
typeof
value
=
=
'
string
'
|
|
isSymbol
(
value
)
)
{
return
value
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
toKey
;
}
function
(
module
exports
)
{
function
Debuggee
(
)
{
function
(
selector
)
{
var
element
=
document
.
querySelector
(
selector
)
;
console
.
log
(
"
"
selector
element
)
;
if
(
!
element
)
{
throw
new
Error
(
"
Element
not
found
try
changing
the
selector
"
)
;
}
return
element
;
}
function
mouseEvent
(
eventType
)
{
return
new
MouseEvent
(
eventType
{
"
view
"
:
window
"
bubbles
"
:
true
"
cancelable
"
:
true
}
)
;
}
var
specialKeysMap
=
{
"
{
enter
}
"
:
13
}
;
function
isSpecialCharacter
(
text
)
{
return
text
.
match
(
/
^
\
{
.
*
\
}
/
)
;
}
function
keyInfo
(
key
eventType
)
{
var
charCodeAt
=
void
0
;
if
(
key
.
length
>
1
)
{
charCodeAt
=
specialKeysMap
[
key
]
;
}
else
{
charCodeAt
=
key
.
toUpperCase
(
)
.
charCodeAt
(
0
)
;
}
return
{
charCode
:
eventType
=
=
"
keypress
"
?
0
:
charCodeAt
keyCode
:
charCodeAt
which
:
charCodeAt
}
;
}
function
keyEvent
(
eventType
key
)
{
var
event
=
new
Event
(
eventType
{
bubbles
:
true
cancelable
:
false
view
:
window
}
)
;
var
_keyInfo
=
keyInfo
(
key
eventType
)
;
var
charCode
=
_keyInfo
.
charCode
;
var
keyCode
=
_keyInfo
.
keyCode
;
var
which
=
_keyInfo
.
which
;
return
Object
.
assign
(
event
{
charCode
:
charCode
keyCode
:
keyCode
which
:
which
detail
:
0
layerX
:
0
layerY
:
0
pageX
:
0
pageY
:
0
}
)
;
}
function
sendKey
(
element
key
)
{
element
.
dispatchEvent
(
keyEvent
(
"
keydown
"
key
)
)
;
element
.
dispatchEvent
(
keyEvent
(
"
keypress
"
key
)
)
;
if
(
key
.
length
=
=
1
)
{
element
.
value
+
=
key
;
}
element
.
dispatchEvent
(
keyEvent
(
"
keyup
"
key
)
)
;
}
function
click
(
selector
)
{
var
element
=
(
selector
)
;
console
.
log
(
"
click
"
selector
)
;
element
.
dispatchEvent
(
mouseEvent
(
"
click
"
)
)
;
}
function
dblclick
(
selector
)
{
var
element
=
(
selector
)
;
console
.
log
(
"
dblclick
"
selector
)
;
element
.
dispatchEvent
(
mouseEvent
(
"
dblclick
"
)
)
;
}
function
type
(
selector
text
)
{
var
element
=
(
selector
)
;
console
.
log
(
"
type
"
selector
text
)
;
element
.
select
(
)
;
if
(
isSpecialCharacter
(
text
)
)
{
sendKey
(
element
text
)
;
}
else
{
var
chars
=
text
.
split
(
"
"
)
;
chars
.
forEach
(
char
=
>
sendKey
(
element
char
)
)
;
}
}
return
{
click
dblclick
type
}
;
}
var
debuggeeStatement
=
window
.
dbg
=
(
{
Debuggee
}
)
(
)
;
var
injectedDebuggee
=
void
0
;
function
injectDebuggee
(
)
{
if
(
injectedDebuggee
)
{
return
Promise
.
resolve
(
injectedDebuggee
)
;
}
return
window
.
client
.
debuggeeCommand
(
debuggeeStatement
)
.
then
(
result
=
>
{
injectedDebuggee
=
result
;
}
)
;
}
module
.
exports
=
injectDebuggee
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
_require
=
__webpack_require__
(
97
)
;
var
Task
=
_require
.
Task
;
var
firefox
=
__webpack_require__
(
98
)
;
var
chrome
=
__webpack_require__
(
173
)
;
var
_require2
=
__webpack_require__
(
45
)
;
var
debugGlobal
=
_require2
.
debugGlobal
;
var
clientType
=
void
0
;
function
getClient
(
)
{
if
(
clientType
=
=
=
"
chrome
"
)
{
return
chrome
.
clientCommands
;
}
return
firefox
.
clientCommands
;
}
function
startDebugging
(
connTarget
actions
)
{
if
(
connTarget
.
type
=
=
=
"
node
"
)
{
return
startDebuggingNode
(
connTarget
.
param
actions
)
;
}
var
target
=
connTarget
.
type
=
=
=
"
chrome
"
?
chrome
:
firefox
;
return
startDebuggingTab
(
target
connTarget
.
param
actions
)
;
}
function
startDebuggingNode
(
url
actions
)
{
clientType
=
"
chrome
"
;
return
chrome
.
connectNode
(
ws
:
/
/
{
url
}
)
.
then
(
(
)
=
>
{
chrome
.
initPage
(
actions
)
;
}
)
;
}
function
startDebuggingTab
(
targetEnv
tabId
actions
)
{
return
Task
.
spawn
(
function
*
(
)
{
var
tabs
=
yield
targetEnv
.
connectClient
(
)
;
var
tab
=
tabs
.
find
(
t
=
>
t
.
id
.
indexOf
(
tabId
)
!
=
=
-
1
)
;
yield
targetEnv
.
connectTab
(
tab
.
tab
)
;
targetEnv
.
initPage
(
actions
)
;
clientType
=
targetEnv
=
=
=
firefox
?
"
firefox
"
:
"
chrome
"
;
debugGlobal
(
"
client
"
targetEnv
.
clientCommands
)
;
return
tabs
;
}
)
;
}
function
connectClients
(
)
{
return
Promise
.
all
(
[
firefox
.
connectClient
(
)
chrome
.
connectClient
(
)
]
)
.
then
(
results
=
>
{
var
_results
=
_slicedToArray
(
results
2
)
;
var
firefoxTabs
=
_results
[
0
]
;
var
chromeTabs
=
_results
[
1
]
;
return
firefoxTabs
.
concat
(
chromeTabs
)
.
filter
(
i
=
>
i
)
;
}
)
;
}
module
.
exports
=
{
getClient
connectClients
startDebugging
}
;
}
function
(
module
exports
)
{
var
Task
=
{
async
:
function
(
task
)
{
return
function
(
)
{
return
Task
.
spawn
(
task
this
arguments
)
;
}
;
}
spawn
:
function
(
task
scope
args
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
var
iterator
=
task
.
apply
(
scope
args
)
;
var
callNext
=
lastValue
=
>
{
var
iteration
=
iterator
.
next
(
lastValue
)
;
Promise
.
resolve
(
iteration
.
value
)
.
then
(
value
=
>
{
if
(
iteration
.
done
)
{
resolve
(
value
)
;
}
else
{
callNext
(
value
)
;
}
}
)
.
catch
(
error
=
>
{
reject
(
error
)
;
iterator
.
throw
(
error
)
;
}
)
;
}
;
callNext
(
undefined
)
;
}
)
;
}
}
;
module
.
exports
=
{
Task
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
99
)
;
var
DebuggerClient
=
_require
.
DebuggerClient
;
var
_require2
=
__webpack_require__
(
105
)
;
var
DebuggerTransport
=
_require2
.
DebuggerTransport
;
var
WebSocketDebuggerTransport
=
__webpack_require__
(
110
)
;
var
_require3
=
__webpack_require__
(
113
)
;
var
TargetFactory
=
_require3
.
TargetFactory
;
var
defer
=
__webpack_require__
(
112
)
;
var
_require4
=
__webpack_require__
(
46
)
;
var
getValue
=
_require4
.
getValue
;
var
_require5
=
__webpack_require__
(
114
)
;
var
Tab
=
_require5
.
Tab
;
var
_require6
=
__webpack_require__
(
170
)
;
var
setupCommands
=
_require6
.
setupCommands
;
var
clientCommands
=
_require6
.
clientCommands
;
var
_require7
=
__webpack_require__
(
171
)
;
var
setupEvents
=
_require7
.
setupEvents
;
var
clientEvents
=
_require7
.
clientEvents
;
var
_require8
=
__webpack_require__
(
172
)
;
var
createSource
=
_require8
.
createSource
;
var
debuggerClient
=
null
;
var
threadClient
=
null
;
var
tabTarget
=
null
;
function
getThreadClient
(
)
{
return
threadClient
;
}
function
setThreadClient
(
client
)
{
threadClient
=
client
;
}
function
getTabTarget
(
)
{
return
tabTarget
;
}
function
setTabTarget
(
target
)
{
tabTarget
=
target
;
}
function
lookupTabTarget
(
tab
)
{
var
options
=
{
client
:
debuggerClient
form
:
tab
chrome
:
false
}
;
return
TargetFactory
.
forRemoteTab
(
options
)
;
}
function
createTabs
(
tabs
)
{
return
tabs
.
map
(
tab
=
>
{
return
Tab
(
{
title
:
tab
.
title
url
:
tab
.
url
id
:
tab
.
actor
tab
browser
:
"
firefox
"
}
)
;
}
)
;
}
function
connectClient
(
)
{
var
deferred
=
defer
(
)
;
var
useProxy
=
!
getValue
(
"
firefox
.
webSocketConnection
"
)
;
var
portPref
=
useProxy
?
"
firefox
.
proxyPort
"
:
"
firefox
.
webSocketPort
"
;
var
webSocketPort
=
getValue
(
portPref
)
;
var
socket
=
new
WebSocket
(
ws
:
/
/
{
document
.
location
.
hostname
}
:
{
webSocketPort
}
)
;
var
transport
=
useProxy
?
new
DebuggerTransport
(
socket
)
:
new
WebSocketDebuggerTransport
(
socket
)
;
debuggerClient
=
new
DebuggerClient
(
transport
)
;
debuggerClient
.
connect
(
)
.
then
(
(
)
=
>
{
return
debuggerClient
.
listTabs
(
)
.
then
(
response
=
>
{
deferred
.
resolve
(
createTabs
(
response
.
tabs
)
)
;
}
)
;
}
)
.
catch
(
err
=
>
{
console
.
log
(
err
)
;
deferred
.
reject
(
)
;
}
)
;
return
deferred
.
promise
;
}
function
connectTab
(
tab
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
window
.
addEventListener
(
"
beforeunload
"
(
)
=
>
{
getTabTarget
(
)
&
&
getTabTarget
(
)
.
destroy
(
)
;
}
)
;
lookupTabTarget
(
tab
)
.
then
(
target
=
>
{
tabTarget
=
target
;
target
.
activeTab
.
attachThread
(
{
}
(
res
_threadClient
)
=
>
{
threadClient
=
_threadClient
;
threadClient
.
resume
(
)
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
}
function
initPage
(
actions
)
{
tabTarget
=
getTabTarget
(
)
;
threadClient
=
getThreadClient
(
)
;
setupCommands
(
{
threadClient
tabTarget
debuggerClient
}
)
;
tabTarget
.
on
(
"
will
-
navigate
"
actions
.
willNavigate
)
;
tabTarget
.
on
(
"
navigate
"
actions
.
navigated
)
;
setupEvents
(
{
threadClient
actions
}
)
;
Object
.
keys
(
clientEvents
)
.
forEach
(
eventName
=
>
{
threadClient
.
addListener
(
eventName
clientEvents
[
eventName
]
)
;
}
)
;
return
threadClient
.
getSources
(
)
.
then
(
_ref
=
>
{
var
sources
=
_ref
.
sources
;
actions
.
newSources
(
sources
.
map
(
createSource
)
)
;
var
pausedPacket
=
threadClient
.
getLastPausePacket
(
)
;
if
(
pausedPacket
)
{
clientEvents
.
paused
(
null
pausedPacket
)
;
}
}
)
;
}
module
.
exports
=
{
connectClient
connectTab
clientCommands
getThreadClient
setThreadClient
getTabTarget
setTabTarget
initPage
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Ci
Cu
components
}
=
__webpack_require__
(
28
)
;
const
{
Services
}
=
__webpack_require__
(
33
)
;
const
DevToolsUtils
=
__webpack_require__
(
27
)
;
const
promise
=
__webpack_require__
(
39
)
;
const
events
=
__webpack_require__
(
100
)
;
const
{
WebConsoleClient
}
=
__webpack_require__
(
103
)
;
const
noop
=
(
)
=
>
{
}
;
function
eventSource
(
aProto
)
{
aProto
.
addListener
=
function
(
aName
aListener
)
{
if
(
typeof
aListener
!
=
"
function
"
)
{
throw
TypeError
(
"
Listeners
must
be
functions
.
"
)
;
}
if
(
!
this
.
_listeners
)
{
this
.
_listeners
=
{
}
;
}
this
.
_getListeners
(
aName
)
.
push
(
aListener
)
;
}
;
aProto
.
addOneTimeListener
=
function
(
aName
aListener
)
{
let
l
=
(
.
.
.
args
)
=
>
{
this
.
removeListener
(
aName
l
)
;
aListener
.
apply
(
null
args
)
;
}
;
this
.
addListener
(
aName
l
)
;
}
;
aProto
.
removeListener
=
function
(
aName
aListener
)
{
if
(
!
this
.
_listeners
|
|
(
aListener
&
&
!
this
.
_listeners
[
aName
]
)
)
{
return
;
}
if
(
!
aListener
)
{
this
.
_listeners
[
aName
]
=
[
]
;
}
else
{
this
.
_listeners
[
aName
]
=
this
.
_listeners
[
aName
]
.
filter
(
function
(
l
)
{
return
l
!
=
aListener
}
)
;
}
}
;
aProto
.
_getListeners
=
function
(
aName
)
{
if
(
aName
in
this
.
_listeners
)
{
return
this
.
_listeners
[
aName
]
;
}
this
.
_listeners
[
aName
]
=
[
]
;
return
this
.
_listeners
[
aName
]
;
}
;
aProto
.
emit
=
function
(
)
{
if
(
!
this
.
_listeners
)
{
return
;
}
let
name
=
arguments
[
0
]
;
let
listeners
=
this
.
_getListeners
(
name
)
.
slice
(
0
)
;
for
(
let
listener
of
listeners
)
{
try
{
listener
.
apply
(
null
arguments
)
;
}
catch
(
e
)
{
DevToolsUtils
.
reportException
(
"
notify
event
'
"
+
name
+
"
'
"
e
)
;
}
}
}
}
const
ThreadStateTypes
=
{
"
paused
"
:
"
paused
"
"
resumed
"
:
"
attached
"
"
detached
"
:
"
detached
"
}
;
const
UnsolicitedNotifications
=
{
"
consoleAPICall
"
:
"
consoleAPICall
"
"
eventNotification
"
:
"
eventNotification
"
"
fileActivity
"
:
"
fileActivity
"
"
lastPrivateContextExited
"
:
"
lastPrivateContextExited
"
"
logMessage
"
:
"
logMessage
"
"
networkEvent
"
:
"
networkEvent
"
"
networkEventUpdate
"
:
"
networkEventUpdate
"
"
newGlobal
"
:
"
newGlobal
"
"
newScript
"
:
"
newScript
"
"
tabDetached
"
:
"
tabDetached
"
"
tabListChanged
"
:
"
tabListChanged
"
"
reflowActivity
"
:
"
reflowActivity
"
"
addonListChanged
"
:
"
addonListChanged
"
"
workerListChanged
"
:
"
workerListChanged
"
"
serviceWorkerRegistrationListChanged
"
:
"
serviceWorkerRegistrationList
"
"
tabNavigated
"
:
"
tabNavigated
"
"
frameUpdate
"
:
"
frameUpdate
"
"
pageError
"
:
"
pageError
"
"
documentLoad
"
:
"
documentLoad
"
"
enteredFrame
"
:
"
enteredFrame
"
"
exitedFrame
"
:
"
exitedFrame
"
"
appOpen
"
:
"
appOpen
"
"
appClose
"
:
"
appClose
"
"
appInstall
"
:
"
appInstall
"
"
appUninstall
"
:
"
appUninstall
"
"
evaluationResult
"
:
"
evaluationResult
"
"
newSource
"
:
"
newSource
"
"
updatedSource
"
:
"
updatedSource
"
}
;
const
UnsolicitedPauses
=
{
"
resumeLimit
"
:
"
resumeLimit
"
"
debuggerStatement
"
:
"
debuggerStatement
"
"
breakpoint
"
:
"
breakpoint
"
"
DOMEvent
"
:
"
DOMEvent
"
"
watchpoint
"
:
"
watchpoint
"
"
exception
"
:
"
exception
"
}
;
const
DebuggerClient
=
exports
.
DebuggerClient
=
function
(
aTransport
)
{
this
.
_transport
=
aTransport
;
this
.
_transport
.
hooks
=
this
;
this
.
_clients
=
new
Map
(
)
;
this
.
_pendingRequests
=
new
Map
(
)
;
this
.
_activeRequests
=
new
Map
(
)
;
this
.
_eventsEnabled
=
true
;
this
.
traits
=
{
}
;
this
.
request
=
this
.
request
.
bind
(
this
)
;
this
.
localTransport
=
this
.
_transport
.
onOutputStreamReady
=
=
=
undefined
;
this
.
mainRoot
=
null
;
this
.
expectReply
(
"
root
"
(
aPacket
)
=
>
{
this
.
mainRoot
=
new
RootClient
(
this
aPacket
)
;
this
.
emit
(
"
connected
"
aPacket
.
applicationType
aPacket
.
traits
)
;
}
)
;
}
DebuggerClient
.
requester
=
function
(
aPacketSkeleton
config
=
{
}
)
{
let
{
telemetry
before
after
}
=
config
;
return
DevToolsUtils
.
makeInfallible
(
function
(
.
.
.
args
)
{
let
histogram
startTime
;
if
(
telemetry
)
{
let
transportType
=
this
.
_transport
.
onOutputStreamReady
=
=
=
undefined
?
"
LOCAL_
"
:
"
REMOTE_
"
;
let
histogramId
=
"
DEVTOOLS_DEBUGGER_RDP_
"
+
transportType
+
telemetry
+
"
_MS
"
;
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramId
)
;
startTime
=
+
new
Date
;
}
let
outgoingPacket
=
{
to
:
aPacketSkeleton
.
to
|
|
this
.
actor
}
;
let
maxPosition
=
-
1
;
for
(
let
k
of
Object
.
keys
(
aPacketSkeleton
)
)
{
if
(
aPacketSkeleton
[
k
]
instanceof
DebuggerClient
.
Argument
)
{
let
{
position
}
=
aPacketSkeleton
[
k
]
;
outgoingPacket
[
k
]
=
aPacketSkeleton
[
k
]
.
getArgument
(
args
)
;
maxPosition
=
Math
.
max
(
position
maxPosition
)
;
}
else
{
outgoingPacket
[
k
]
=
aPacketSkeleton
[
k
]
;
}
}
if
(
before
)
{
outgoingPacket
=
before
.
call
(
this
outgoingPacket
)
;
}
return
this
.
request
(
outgoingPacket
DevToolsUtils
.
makeInfallible
(
(
aResponse
)
=
>
{
if
(
after
)
{
let
{
from
}
=
aResponse
;
aResponse
=
after
.
call
(
this
aResponse
)
;
if
(
!
aResponse
.
from
)
{
aResponse
.
from
=
from
;
}
}
let
thisCallback
=
args
[
maxPosition
+
1
]
;
if
(
thisCallback
)
{
thisCallback
(
aResponse
)
;
}
if
(
histogram
)
{
histogram
.
add
(
+
new
Date
-
startTime
)
;
}
}
"
DebuggerClient
.
requester
request
callback
"
)
)
;
}
"
DebuggerClient
.
requester
"
)
;
}
;
function
args
(
aPos
)
{
return
new
DebuggerClient
.
Argument
(
aPos
)
;
}
DebuggerClient
.
Argument
=
function
(
aPosition
)
{
this
.
position
=
aPosition
;
}
;
DebuggerClient
.
Argument
.
prototype
.
getArgument
=
function
(
aParams
)
{
if
(
!
(
this
.
position
in
aParams
)
)
{
throw
new
Error
(
"
Bad
index
into
params
:
"
+
this
.
position
)
;
}
return
aParams
[
this
.
position
]
;
}
;
DebuggerClient
.
socketConnect
=
function
(
options
)
{
return
DebuggerSocket
.
connect
(
options
)
;
}
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
Authenticators
"
(
)
=
>
{
return
Authentication
.
Authenticators
;
}
)
;
DevToolsUtils
.
defineLazyGetter
(
DebuggerClient
"
AuthenticationResult
"
(
)
=
>
{
return
Authentication
.
AuthenticationResult
;
}
)
;
DebuggerClient
.
prototype
=
{
connect
:
function
(
aOnConnected
)
{
return
Promise
.
race
(
[
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
emit
(
"
connect
"
)
;
events
.
emit
(
DebuggerClient
"
connect
"
this
)
;
this
.
addOneTimeListener
(
"
connected
"
(
aName
aApplicationType
aTraits
)
=
>
{
this
.
traits
=
aTraits
;
if
(
aOnConnected
)
{
aOnConnected
(
aApplicationType
aTraits
)
;
}
resolve
(
[
aApplicationType
aTraits
]
)
;
}
)
;
this
.
_transport
.
ready
(
)
;
}
)
new
Promise
(
(
resolve
reject
)
=
>
{
setTimeout
(
(
)
=
>
reject
(
new
Error
(
"
Connect
timeout
error
"
)
)
6000
)
;
}
)
]
)
;
}
close
:
function
(
aOnClosed
)
{
this
.
_eventsEnabled
=
false
;
let
cleanup
=
(
)
=
>
{
this
.
_transport
.
close
(
)
;
this
.
_transport
=
null
;
}
;
if
(
this
.
_closed
)
{
cleanup
(
)
;
if
(
aOnClosed
)
{
aOnClosed
(
)
;
}
return
;
}
if
(
aOnClosed
)
{
this
.
addOneTimeListener
(
'
closed
'
function
(
aEvent
)
{
aOnClosed
(
)
;
}
)
;
}
let
clients
=
[
.
.
.
this
.
_clients
.
values
(
)
]
;
this
.
_clients
.
clear
(
)
;
const
detachClients
=
(
)
=
>
{
let
client
=
clients
.
pop
(
)
;
if
(
!
client
)
{
cleanup
(
)
;
return
;
}
if
(
client
.
detach
)
{
client
.
detach
(
detachClients
)
;
return
;
}
detachClients
(
)
;
}
;
detachClients
(
)
;
}
listTabs
:
function
(
aOnResponse
)
{
return
this
.
mainRoot
.
listTabs
(
aOnResponse
)
;
}
listAddons
:
function
(
aOnResponse
)
{
return
this
.
mainRoot
.
listAddons
(
aOnResponse
)
;
}
getTab
:
function
(
aFilter
)
{
return
this
.
mainRoot
.
getTab
(
aFilter
)
;
}
attachTab
:
function
(
aTabActor
aOnResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
aTabActor
)
)
{
let
cachedTab
=
this
.
_clients
.
get
(
aTabActor
)
;
let
cachedResponse
=
{
cacheDisabled
:
cachedTab
.
cacheDisabled
javascriptEnabled
:
cachedTab
.
javascriptEnabled
traits
:
cachedTab
.
traits
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
cachedResponse
cachedTab
)
)
;
return
promise
.
resolve
(
[
cachedResponse
cachedTab
]
)
;
}
let
packet
=
{
to
:
aTabActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
tabClient
;
if
(
!
aResponse
.
error
)
{
tabClient
=
new
TabClient
(
this
aResponse
)
;
this
.
registerClient
(
tabClient
)
;
}
aOnResponse
(
aResponse
tabClient
)
;
return
[
aResponse
tabClient
]
;
}
)
;
}
attachWorker
:
function
DC_attachWorker
(
aWorkerActor
aOnResponse
=
noop
)
{
let
workerClient
=
this
.
_clients
.
get
(
aWorkerActor
)
;
if
(
workerClient
!
=
=
undefined
)
{
let
response
=
{
from
:
workerClient
.
actor
type
:
"
attached
"
url
:
workerClient
.
url
}
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
response
workerClient
)
)
;
return
promise
.
resolve
(
[
response
workerClient
]
)
;
}
return
this
.
request
(
{
to
:
aWorkerActor
type
:
"
attach
"
}
)
.
then
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
aOnResponse
(
aResponse
null
)
;
return
[
aResponse
null
]
;
}
let
workerClient
=
new
WorkerClient
(
this
aResponse
)
;
this
.
registerClient
(
workerClient
)
;
aOnResponse
(
aResponse
workerClient
)
;
return
[
aResponse
workerClient
]
;
}
)
;
}
attachAddon
:
function
DC_attachAddon
(
aAddonActor
aOnResponse
=
noop
)
{
let
packet
=
{
to
:
aAddonActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
addonClient
;
if
(
!
aResponse
.
error
)
{
addonClient
=
new
AddonClient
(
this
aAddonActor
)
;
this
.
registerClient
(
addonClient
)
;
this
.
activeAddon
=
addonClient
;
}
aOnResponse
(
aResponse
addonClient
)
;
return
[
aResponse
addonClient
]
;
}
)
;
}
attachConsole
:
function
(
aConsoleActor
aListeners
aOnResponse
=
noop
)
{
let
packet
=
{
to
:
aConsoleActor
type
:
"
startListeners
"
listeners
:
aListeners
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
consoleClient
;
if
(
!
aResponse
.
error
)
{
if
(
this
.
_clients
.
has
(
aConsoleActor
)
)
{
consoleClient
=
this
.
_clients
.
get
(
aConsoleActor
)
;
}
else
{
consoleClient
=
new
WebConsoleClient
(
this
aResponse
)
;
this
.
registerClient
(
consoleClient
)
;
}
}
aOnResponse
(
aResponse
consoleClient
)
;
return
[
aResponse
consoleClient
]
;
}
)
;
}
attachThread
:
function
(
aThreadActor
aOnResponse
=
noop
aOptions
=
{
}
)
{
if
(
this
.
_clients
.
has
(
aThreadActor
)
)
{
let
client
=
this
.
_clients
.
get
(
aThreadActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
let
packet
=
{
to
:
aThreadActor
type
:
"
attach
"
options
:
aOptions
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
var
threadClient
=
new
ThreadClient
(
this
aThreadActor
)
;
this
.
registerClient
(
threadClient
)
;
}
aOnResponse
(
aResponse
threadClient
)
;
return
[
aResponse
threadClient
]
;
}
)
;
}
attachTracer
:
function
(
aTraceActor
aOnResponse
=
noop
)
{
if
(
this
.
_clients
.
has
(
aTraceActor
)
)
{
let
client
=
this
.
_clients
.
get
(
aTraceActor
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
{
}
client
)
)
;
return
promise
.
resolve
(
[
{
}
client
]
)
;
}
let
packet
=
{
to
:
aTraceActor
type
:
"
attach
"
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
var
traceClient
=
new
TraceClient
(
this
aTraceActor
)
;
this
.
registerClient
(
traceClient
)
;
}
aOnResponse
(
aResponse
traceClient
)
;
return
[
aResponse
traceClient
]
;
}
)
;
}
getProcess
:
function
(
aId
)
{
let
packet
=
{
to
:
"
root
"
type
:
"
getProcess
"
}
if
(
typeof
(
aId
)
=
=
"
number
"
)
{
packet
.
id
=
aId
;
}
return
this
.
request
(
packet
)
;
}
release
:
DebuggerClient
.
requester
(
{
to
:
args
(
0
)
type
:
"
release
"
}
{
telemetry
:
"
RELEASE
"
}
)
request
:
function
(
aRequest
aOnResponse
)
{
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
let
type
=
aRequest
.
type
|
|
"
"
;
if
(
!
aRequest
.
to
)
{
throw
Error
(
"
'
"
+
type
+
"
'
request
packet
has
no
destination
.
"
)
;
}
if
(
this
.
_closed
)
{
let
msg
=
"
'
"
+
type
+
"
'
request
packet
to
"
+
"
'
"
+
aRequest
.
to
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
is
closed
.
"
;
let
resp
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
if
(
aOnResponse
)
{
aOnResponse
(
resp
)
;
}
return
promise
.
reject
(
resp
)
;
}
let
request
=
new
Request
(
aRequest
)
;
request
.
format
=
"
json
"
;
request
.
stack
=
components
.
stack
;
if
(
aOnResponse
)
{
request
.
on
(
"
json
-
reply
"
aOnResponse
)
;
}
this
.
_sendOrQueueRequest
(
request
)
;
let
deferred
=
promise
.
defer
(
)
;
function
listenerJson
(
resp
)
{
request
.
off
(
"
json
-
reply
"
listenerJson
)
;
request
.
off
(
"
bulk
-
reply
"
listenerBulk
)
;
if
(
resp
.
error
)
{
deferred
.
reject
(
resp
)
;
}
else
{
deferred
.
resolve
(
resp
)
;
}
}
function
listenerBulk
(
resp
)
{
request
.
off
(
"
json
-
reply
"
listenerJson
)
;
request
.
off
(
"
bulk
-
reply
"
listenerBulk
)
;
deferred
.
resolve
(
resp
)
;
}
request
.
on
(
"
json
-
reply
"
listenerJson
)
;
request
.
on
(
"
bulk
-
reply
"
listenerBulk
)
;
request
.
then
=
deferred
.
promise
.
then
.
bind
(
deferred
.
promise
)
;
return
request
;
}
startBulkRequest
:
function
(
request
)
{
if
(
!
this
.
traits
.
bulk
)
{
throw
Error
(
"
Server
doesn
'
t
support
bulk
transfers
"
)
;
}
if
(
!
this
.
mainRoot
)
{
throw
Error
(
"
Have
not
yet
received
a
hello
packet
from
the
server
.
"
)
;
}
if
(
!
request
.
type
)
{
throw
Error
(
"
Bulk
packet
is
missing
the
required
'
type
'
field
.
"
)
;
}
if
(
!
request
.
actor
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
destination
.
"
)
;
}
if
(
!
request
.
length
)
{
throw
Error
(
"
'
"
+
request
.
type
+
"
'
bulk
packet
has
no
length
.
"
)
;
}
request
=
new
Request
(
request
)
;
request
.
format
=
"
bulk
"
;
this
.
_sendOrQueueRequest
(
request
)
;
return
request
;
}
_sendOrQueueRequest
(
request
)
{
let
actor
=
request
.
actor
;
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
this
.
_sendRequest
(
request
)
;
}
else
{
this
.
_queueRequest
(
request
)
;
}
}
_sendRequest
(
request
)
{
let
actor
=
request
.
actor
;
this
.
expectReply
(
actor
request
)
;
if
(
request
.
format
=
=
=
"
json
"
)
{
this
.
_transport
.
send
(
request
.
request
)
;
return
false
;
}
this
.
_transport
.
startBulkSend
(
request
.
request
)
.
then
(
(
.
.
.
args
)
=
>
{
request
.
emit
(
"
bulk
-
send
-
ready
"
.
.
.
args
)
;
}
)
;
}
_queueRequest
(
request
)
{
let
actor
=
request
.
actor
;
let
queue
=
this
.
_pendingRequests
.
get
(
actor
)
|
|
[
]
;
queue
.
push
(
request
)
;
this
.
_pendingRequests
.
set
(
actor
queue
)
;
}
_attemptNextRequest
(
actor
)
{
if
(
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
let
queue
=
this
.
_pendingRequests
.
get
(
actor
)
;
if
(
!
queue
)
{
return
;
}
let
request
=
queue
.
shift
(
)
;
if
(
queue
.
length
=
=
=
0
)
{
this
.
_pendingRequests
.
delete
(
actor
)
;
}
this
.
_sendRequest
(
request
)
;
}
expectReply
:
function
(
aActor
aRequest
)
{
if
(
this
.
_activeRequests
.
has
(
aActor
)
)
{
throw
Error
(
"
clashing
handlers
for
next
reply
from
"
+
uneval
(
aActor
)
)
;
}
if
(
typeof
aRequest
=
=
=
"
function
"
)
{
let
handler
=
aRequest
;
aRequest
=
new
Request
(
)
;
aRequest
.
on
(
"
json
-
reply
"
handler
)
;
}
this
.
_activeRequests
.
set
(
aActor
aRequest
)
;
}
onPacket
:
function
(
aPacket
)
{
if
(
!
aPacket
.
from
)
{
DevToolsUtils
.
reportException
(
"
onPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
packet
:
"
+
JSON
.
stringify
(
aPacket
)
)
)
;
return
;
}
let
front
=
this
.
getActor
(
aPacket
.
from
)
;
if
(
front
)
{
front
.
onPacket
(
aPacket
)
;
return
;
}
if
(
this
.
_clients
.
has
(
aPacket
.
from
)
&
&
aPacket
.
type
)
{
let
client
=
this
.
_clients
.
get
(
aPacket
.
from
)
;
let
type
=
aPacket
.
type
;
if
(
client
.
events
.
indexOf
(
type
)
!
=
-
1
)
{
client
.
emit
(
type
aPacket
)
;
return
;
}
}
let
activeRequest
;
if
(
this
.
_activeRequests
.
has
(
aPacket
.
from
)
&
&
!
(
aPacket
.
type
in
UnsolicitedNotifications
)
&
&
!
(
aPacket
.
type
=
=
ThreadStateTypes
.
paused
&
&
aPacket
.
why
.
type
in
UnsolicitedPauses
)
)
{
activeRequest
=
this
.
_activeRequests
.
get
(
aPacket
.
from
)
;
this
.
_activeRequests
.
delete
(
aPacket
.
from
)
;
}
this
.
_attemptNextRequest
(
aPacket
.
from
)
;
if
(
aPacket
.
type
in
ThreadStateTypes
&
&
this
.
_clients
.
has
(
aPacket
.
from
)
&
&
typeof
this
.
_clients
.
get
(
aPacket
.
from
)
.
_onThreadState
=
=
"
function
"
)
{
this
.
_clients
.
get
(
aPacket
.
from
)
.
_onThreadState
(
aPacket
)
;
}
if
(
!
this
.
traits
.
noNeedToFakeResumptionOnNavigation
)
{
if
(
aPacket
.
type
=
=
UnsolicitedNotifications
.
tabNavigated
&
&
this
.
_clients
.
has
(
aPacket
.
from
)
&
&
this
.
_clients
.
get
(
aPacket
.
from
)
.
thread
)
{
let
thread
=
this
.
_clients
.
get
(
aPacket
.
from
)
.
thread
;
let
resumption
=
{
from
:
thread
.
_actor
type
:
"
resumed
"
}
;
thread
.
_onThreadState
(
resumption
)
;
}
}
if
(
aPacket
.
type
)
{
this
.
emit
(
aPacket
.
type
aPacket
)
;
}
if
(
activeRequest
)
{
let
emitReply
=
(
)
=
>
activeRequest
.
emit
(
"
json
-
reply
"
aPacket
)
;
if
(
activeRequest
.
stack
)
{
Cu
.
callFunctionWithAsyncStack
(
emitReply
activeRequest
.
stack
"
DevTools
RDP
"
)
;
}
else
{
emitReply
(
)
;
}
}
}
onBulkPacket
:
function
(
packet
)
{
let
{
actor
type
length
}
=
packet
;
if
(
!
actor
)
{
DevToolsUtils
.
reportException
(
"
onBulkPacket
"
new
Error
(
"
Server
did
not
specify
an
actor
dropping
bulk
packet
:
"
+
JSON
.
stringify
(
packet
)
)
)
;
return
;
}
if
(
!
this
.
_activeRequests
.
has
(
actor
)
)
{
return
;
}
let
activeRequest
=
this
.
_activeRequests
.
get
(
actor
)
;
this
.
_activeRequests
.
delete
(
actor
)
;
this
.
_attemptNextRequest
(
actor
)
;
activeRequest
.
emit
(
"
bulk
-
reply
"
packet
)
;
}
onClosed
:
function
(
aStatus
)
{
this
.
_closed
=
true
;
this
.
emit
(
"
closed
"
)
;
let
reject
=
function
(
type
request
actor
)
{
let
msg
;
if
(
request
.
request
)
{
msg
=
"
'
"
+
request
.
request
.
type
+
"
'
"
+
type
+
"
request
packet
"
+
"
to
'
"
+
actor
+
"
'
"
+
"
can
'
t
be
sent
as
the
connection
just
closed
.
"
;
}
else
{
msg
=
"
server
side
packet
from
'
"
+
actor
+
"
'
can
'
t
be
received
"
+
"
as
the
connection
just
closed
.
"
;
}
let
packet
=
{
error
:
"
connectionClosed
"
message
:
msg
}
;
request
.
emit
(
"
json
-
reply
"
packet
)
;
}
;
let
pendingRequests
=
new
Map
(
this
.
_pendingRequests
)
;
this
.
_pendingRequests
.
clear
(
)
;
pendingRequests
.
forEach
(
(
list
actor
)
=
>
{
list
.
forEach
(
request
=
>
reject
(
"
pending
"
request
actor
)
)
;
}
)
;
let
activeRequests
=
new
Map
(
this
.
_activeRequests
)
;
this
.
_activeRequests
.
clear
(
)
;
activeRequests
.
forEach
(
reject
.
bind
(
null
"
active
"
)
)
;
for
(
let
pool
of
this
.
_pools
)
{
pool
.
cleanup
(
)
;
}
}
registerClient
:
function
(
client
)
{
let
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
actor
attribute
.
"
)
;
}
if
(
!
Array
.
isArray
(
client
.
events
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
an
events
attribute
"
+
"
that
is
an
array
.
"
)
;
}
if
(
client
.
events
.
length
>
0
&
&
typeof
(
client
.
emit
)
!
=
"
function
"
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
expects
"
+
"
a
client
instance
with
non
-
empty
events
array
to
"
+
"
have
an
emit
function
.
"
)
;
}
if
(
this
.
_clients
.
has
(
actorID
)
)
{
throw
new
Error
(
"
DebuggerServer
.
registerClient
already
registered
"
+
"
a
client
for
this
actor
.
"
)
;
}
this
.
_clients
.
set
(
actorID
client
)
;
}
unregisterClient
:
function
(
client
)
{
let
actorID
=
client
.
actor
;
if
(
!
actorID
)
{
throw
new
Error
(
"
DebuggerServer
.
unregisterClient
expects
"
+
"
a
Client
instance
with
a
actor
attribute
.
"
)
;
}
this
.
_clients
.
delete
(
actorID
)
;
}
__pools
:
null
get
_pools
(
)
{
if
(
this
.
__pools
)
{
return
this
.
__pools
;
}
this
.
__pools
=
new
Set
(
)
;
return
this
.
__pools
;
}
addActorPool
:
function
(
pool
)
{
this
.
_pools
.
add
(
pool
)
;
}
removeActorPool
:
function
(
pool
)
{
this
.
_pools
.
delete
(
pool
)
;
}
getActor
:
function
(
actorID
)
{
let
pool
=
this
.
poolFor
(
actorID
)
;
return
pool
?
pool
.
get
(
actorID
)
:
null
;
}
poolFor
:
function
(
actorID
)
{
for
(
let
pool
of
this
.
_pools
)
{
if
(
pool
.
has
(
actorID
)
)
return
pool
;
}
return
null
;
}
activeAddon
:
null
}
eventSource
(
DebuggerClient
.
prototype
)
;
function
Request
(
request
)
{
this
.
request
=
request
;
}
Request
.
prototype
=
{
on
:
function
(
type
listener
)
{
events
.
on
(
this
type
listener
)
;
}
off
:
function
(
type
listener
)
{
events
.
off
(
this
type
listener
)
;
}
once
:
function
(
type
listener
)
{
events
.
once
(
this
type
listener
)
;
}
emit
:
function
(
type
.
.
.
args
)
{
events
.
emit
(
this
type
.
.
.
args
)
;
}
get
actor
(
)
{
return
this
.
request
.
to
|
|
this
.
request
.
actor
;
}
}
;
function
TabClient
(
aClient
aForm
)
{
this
.
client
=
aClient
;
this
.
_actor
=
aForm
.
from
;
this
.
_threadActor
=
aForm
.
threadActor
;
this
.
javascriptEnabled
=
aForm
.
javascriptEnabled
;
this
.
cacheDisabled
=
aForm
.
cacheDisabled
;
this
.
thread
=
null
;
this
.
request
=
this
.
client
.
request
;
this
.
traits
=
aForm
.
traits
|
|
{
}
;
this
.
events
=
[
"
workerListChanged
"
]
;
}
TabClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
attachThread
:
function
(
aOptions
=
{
}
aOnResponse
=
noop
)
{
if
(
this
.
thread
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
{
}
this
.
thread
)
)
;
return
promise
.
resolve
(
[
{
}
this
.
thread
]
)
;
}
let
packet
=
{
to
:
this
.
_threadActor
type
:
"
attach
"
options
:
aOptions
}
;
return
this
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
this
.
thread
=
new
ThreadClient
(
this
this
.
_threadActor
)
;
this
.
client
.
registerClient
(
this
.
thread
)
;
}
aOnResponse
(
aResponse
this
.
thread
)
;
return
[
aResponse
this
.
thread
]
;
}
)
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
thread
)
{
this
.
thread
.
detach
(
)
;
}
return
aPacket
;
}
after
:
function
(
aResponse
)
{
this
.
client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
TABDETACH
"
}
)
focus
:
DebuggerClient
.
requester
(
{
type
:
"
focus
"
}
{
}
)
reload
:
function
(
options
=
{
force
:
false
}
)
{
return
this
.
_reload
(
options
)
;
}
_reload
:
DebuggerClient
.
requester
(
{
type
:
"
reload
"
options
:
args
(
0
)
}
{
telemetry
:
"
RELOAD
"
}
)
navigateTo
:
DebuggerClient
.
requester
(
{
type
:
"
navigateTo
"
url
:
args
(
0
)
}
{
telemetry
:
"
NAVIGATETO
"
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
args
(
0
)
}
{
telemetry
:
"
RECONFIGURETAB
"
}
)
listWorkers
:
DebuggerClient
.
requester
(
{
type
:
"
listWorkers
"
}
{
telemetry
:
"
LISTWORKERS
"
}
)
attachWorker
:
function
(
aWorkerActor
aOnResponse
)
{
this
.
client
.
attachWorker
(
aWorkerActor
aOnResponse
)
;
}
resolveLocation
:
DebuggerClient
.
requester
(
{
type
:
"
resolveLocation
"
location
:
args
(
0
)
}
)
}
;
eventSource
(
TabClient
.
prototype
)
;
function
WorkerClient
(
aClient
aForm
)
{
this
.
client
=
aClient
;
this
.
_actor
=
aForm
.
from
;
this
.
_isClosed
=
false
;
this
.
_url
=
aForm
.
url
;
this
.
_onClose
=
this
.
_onClose
.
bind
(
this
)
;
this
.
addListener
(
"
close
"
this
.
_onClose
)
;
this
.
traits
=
{
}
;
}
WorkerClient
.
prototype
=
{
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
get
request
(
)
{
return
this
.
client
.
request
;
}
get
actor
(
)
{
return
this
.
_actor
;
}
get
url
(
)
{
return
this
.
_url
;
}
get
isClosed
(
)
{
return
this
.
_isClosed
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
if
(
this
.
thread
)
{
this
.
client
.
unregisterClient
(
this
.
thread
)
;
}
this
.
client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
WORKERDETACH
"
}
)
attachThread
:
function
(
aOptions
=
{
}
aOnResponse
=
noop
)
{
if
(
this
.
thread
)
{
let
response
=
[
{
type
:
"
connected
"
threadActor
:
this
.
thread
.
_actor
consoleActor
:
this
.
consoleActor
}
this
.
thread
]
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
aOnResponse
(
response
)
)
;
return
response
;
}
return
this
.
request
(
{
to
:
this
.
_actor
type
:
"
connect
"
options
:
aOptions
}
)
.
then
(
connectReponse
=
>
{
if
(
connectReponse
.
error
)
{
aOnResponse
(
connectReponse
null
)
;
return
[
connectResponse
null
]
;
}
return
this
.
request
(
{
to
:
connectReponse
.
threadActor
type
:
"
attach
"
options
:
aOptions
}
)
.
then
(
attachResponse
=
>
{
if
(
attachResponse
.
error
)
{
aOnResponse
(
attachResponse
null
)
;
}
this
.
thread
=
new
ThreadClient
(
this
connectReponse
.
threadActor
)
;
this
.
consoleActor
=
connectReponse
.
consoleActor
;
this
.
client
.
registerClient
(
this
.
thread
)
;
aOnResponse
(
connectReponse
this
.
thread
)
;
return
[
connectResponse
this
.
thread
]
;
}
)
;
}
)
;
}
_onClose
:
function
(
)
{
this
.
removeListener
(
"
close
"
this
.
_onClose
)
;
if
(
this
.
thread
)
{
this
.
client
.
unregisterClient
(
this
.
thread
)
;
}
this
.
client
.
unregisterClient
(
this
)
;
this
.
_isClosed
=
true
;
}
reconfigure
:
function
(
)
{
return
Promise
.
resolve
(
)
;
}
events
:
[
"
close
"
]
}
;
eventSource
(
WorkerClient
.
prototype
)
;
function
AddonClient
(
aClient
aActor
)
{
this
.
_client
=
aClient
;
this
.
_actor
=
aActor
;
this
.
request
=
this
.
_client
.
request
;
this
.
events
=
[
]
;
}
AddonClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
if
(
this
.
_client
.
activeAddon
=
=
=
this
)
{
this
.
_client
.
activeAddon
=
null
}
this
.
_client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
ADDONDETACH
"
}
)
}
;
function
RootClient
(
aClient
aGreeting
)
{
this
.
_client
=
aClient
;
this
.
actor
=
aGreeting
.
from
;
this
.
applicationType
=
aGreeting
.
applicationType
;
this
.
traits
=
aGreeting
.
traits
;
}
exports
.
RootClient
=
RootClient
;
RootClient
.
prototype
=
{
constructor
:
RootClient
listTabs
:
DebuggerClient
.
requester
(
{
type
:
"
listTabs
"
}
{
telemetry
:
"
LISTTABS
"
}
)
listAddons
:
DebuggerClient
.
requester
(
{
type
:
"
listAddons
"
}
{
telemetry
:
"
LISTADDONS
"
}
)
listWorkers
:
DebuggerClient
.
requester
(
{
type
:
"
listWorkers
"
}
{
telemetry
:
"
LISTWORKERS
"
}
)
listServiceWorkerRegistrations
:
DebuggerClient
.
requester
(
{
type
:
"
listServiceWorkerRegistrations
"
}
{
telemetry
:
"
LISTSERVICEWORKERREGISTRATIONS
"
}
)
listProcesses
:
DebuggerClient
.
requester
(
{
type
:
"
listProcesses
"
}
{
telemetry
:
"
LISTPROCESSES
"
}
)
getTab
:
function
(
aFilter
)
{
let
packet
=
{
to
:
this
.
actor
type
:
"
getTab
"
}
;
if
(
aFilter
)
{
if
(
typeof
(
aFilter
.
outerWindowID
)
=
=
"
number
"
)
{
packet
.
outerWindowID
=
aFilter
.
outerWindowID
;
}
else
if
(
typeof
(
aFilter
.
tabId
)
=
=
"
number
"
)
{
packet
.
tabId
=
aFilter
.
tabId
;
}
else
if
(
"
tab
"
in
aFilter
)
{
let
browser
=
aFilter
.
tab
.
linkedBrowser
;
if
(
browser
.
frameLoader
.
tabParent
)
{
packet
.
tabId
=
browser
.
frameLoader
.
tabParent
.
tabId
;
}
else
{
let
windowUtils
=
browser
.
contentWindow
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIDOMWindowUtils
)
;
packet
.
outerWindowID
=
windowUtils
.
outerWindowID
;
}
}
else
{
throw
new
Error
(
"
Unsupported
argument
given
to
getTab
request
"
)
;
}
}
return
this
.
request
(
packet
)
;
}
protocolDescription
:
DebuggerClient
.
requester
(
{
type
:
"
protocolDescription
"
}
{
telemetry
:
"
PROTOCOLDESCRIPTION
"
}
)
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
}
;
function
ThreadClient
(
aClient
aActor
)
{
this
.
_parent
=
aClient
;
this
.
client
=
aClient
instanceof
DebuggerClient
?
aClient
:
aClient
.
client
;
this
.
_actor
=
aActor
;
this
.
_frameCache
=
[
]
;
this
.
_scriptCache
=
{
}
;
this
.
_pauseGrips
=
{
}
;
this
.
_threadGrips
=
{
}
;
this
.
request
=
this
.
client
.
request
;
}
ThreadClient
.
prototype
=
{
_state
:
"
paused
"
get
state
(
)
{
return
this
.
_state
;
}
get
paused
(
)
{
return
this
.
_state
=
=
=
"
paused
"
;
}
_pauseOnExceptions
:
false
_ignoreCaughtExceptions
:
false
_pauseOnDOMEvents
:
null
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
client
.
_transport
;
}
_assertPaused
:
function
(
aCommand
)
{
if
(
!
this
.
paused
)
{
throw
Error
(
aCommand
+
"
command
sent
while
not
paused
.
Currently
"
+
this
.
_state
)
;
}
}
_doResume
:
DebuggerClient
.
requester
(
{
type
:
"
resume
"
resumeLimit
:
args
(
0
)
}
{
before
:
function
(
aPacket
)
{
this
.
_assertPaused
(
"
resume
"
)
;
this
.
_state
=
"
resuming
"
;
if
(
this
.
_pauseOnExceptions
)
{
aPacket
.
pauseOnExceptions
=
this
.
_pauseOnExceptions
;
}
if
(
this
.
_ignoreCaughtExceptions
)
{
aPacket
.
ignoreCaughtExceptions
=
this
.
_ignoreCaughtExceptions
;
}
if
(
this
.
_pauseOnDOMEvents
)
{
aPacket
.
pauseOnDOMEvents
=
this
.
_pauseOnDOMEvents
;
}
return
aPacket
;
}
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
this
.
_state
=
"
paused
"
;
}
return
aResponse
;
}
telemetry
:
"
RESUME
"
}
)
reconfigure
:
DebuggerClient
.
requester
(
{
type
:
"
reconfigure
"
options
:
args
(
0
)
}
{
telemetry
:
"
RECONFIGURETHREAD
"
}
)
resume
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
null
aOnResponse
)
;
}
resumeThenPause
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
break
"
}
aOnResponse
)
;
}
stepOver
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
next
"
}
aOnResponse
)
;
}
stepIn
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
step
"
}
aOnResponse
)
;
}
stepOut
:
function
(
aOnResponse
)
{
return
this
.
_doResume
(
{
type
:
"
finish
"
}
aOnResponse
)
;
}
interrupt
:
function
(
aOnResponse
)
{
return
this
.
_doInterrupt
(
null
aOnResponse
)
;
}
breakOnNext
:
function
(
aOnResponse
)
{
return
this
.
_doInterrupt
(
"
onNext
"
aOnResponse
)
;
}
_doInterrupt
:
DebuggerClient
.
requester
(
{
type
:
"
interrupt
"
when
:
args
(
0
)
}
{
telemetry
:
"
INTERRUPT
"
}
)
pauseOnExceptions
:
function
(
aPauseOnExceptions
aIgnoreCaughtExceptions
aOnResponse
=
noop
)
{
this
.
_pauseOnExceptions
=
aPauseOnExceptions
;
this
.
_ignoreCaughtExceptions
=
aIgnoreCaughtExceptions
;
if
(
!
this
.
paused
)
{
return
this
.
interrupt
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
aOnResponse
(
aResponse
)
;
return
aResponse
;
}
return
this
.
resume
(
aOnResponse
)
;
}
)
;
}
aOnResponse
(
)
;
return
promise
.
resolve
(
)
;
}
pauseOnDOMEvents
:
function
(
events
onResponse
=
noop
)
{
this
.
_pauseOnDOMEvents
=
events
;
if
(
this
.
paused
)
{
DevToolsUtils
.
executeSoon
(
(
)
=
>
onResponse
(
{
}
)
)
;
return
{
}
;
}
return
this
.
interrupt
(
response
=
>
{
if
(
response
.
error
)
{
onResponse
(
response
)
;
return
response
;
}
return
this
.
resume
(
onResponse
)
;
}
)
;
}
eval
:
DebuggerClient
.
requester
(
{
type
:
"
clientEvaluate
"
frame
:
args
(
0
)
expression
:
args
(
1
)
}
{
before
:
function
(
aPacket
)
{
this
.
_assertPaused
(
"
eval
"
)
;
this
.
_state
=
"
resuming
"
;
return
aPacket
;
}
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
this
.
_state
=
"
paused
"
;
}
return
aResponse
;
}
telemetry
:
"
CLIENTEVALUATE
"
}
)
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
this
.
client
.
unregisterClient
(
this
)
;
this
.
_parent
.
thread
=
null
;
return
aResponse
;
}
telemetry
:
"
THREADDETACH
"
}
)
releaseMany
:
DebuggerClient
.
requester
(
{
type
:
"
releaseMany
"
actors
:
args
(
0
)
}
{
telemetry
:
"
RELEASEMANY
"
}
)
threadGrips
:
DebuggerClient
.
requester
(
{
type
:
"
threadGrips
"
actors
:
args
(
0
)
}
{
telemetry
:
"
THREADGRIPS
"
}
)
eventListeners
:
DebuggerClient
.
requester
(
{
type
:
"
eventListeners
"
}
{
telemetry
:
"
EVENTLISTENERS
"
}
)
getSources
:
DebuggerClient
.
requester
(
{
type
:
"
sources
"
}
{
telemetry
:
"
SOURCES
"
}
)
_clearScripts
:
function
(
)
{
if
(
Object
.
keys
(
this
.
_scriptCache
)
.
length
>
0
)
{
this
.
_scriptCache
=
{
}
this
.
emit
(
"
scriptscleared
"
)
;
}
}
getFrames
:
DebuggerClient
.
requester
(
{
type
:
"
frames
"
start
:
args
(
0
)
count
:
args
(
1
)
}
{
telemetry
:
"
FRAMES
"
}
)
get
cachedFrames
(
)
{
return
this
.
_frameCache
;
}
get
moreFrames
(
)
{
return
this
.
paused
&
&
(
!
this
.
_frameCache
|
|
this
.
_frameCache
.
length
=
=
0
|
|
!
this
.
_frameCache
[
this
.
_frameCache
.
length
-
1
]
.
oldest
)
;
}
fillFrames
:
function
(
aTotal
aCallback
=
noop
)
{
this
.
_assertPaused
(
"
fillFrames
"
)
;
if
(
this
.
_frameCache
.
length
>
=
aTotal
)
{
return
false
;
}
let
numFrames
=
this
.
_frameCache
.
length
;
this
.
getFrames
(
numFrames
aTotal
-
numFrames
(
aResponse
)
=
>
{
if
(
aResponse
.
error
)
{
aCallback
(
aResponse
)
;
return
;
}
let
threadGrips
=
DevToolsUtils
.
values
(
this
.
_threadGrips
)
;
for
(
let
i
in
aResponse
.
frames
)
{
let
frame
=
aResponse
.
frames
[
i
]
;
if
(
!
frame
.
where
.
source
)
{
for
(
let
grip
of
threadGrips
)
{
if
(
grip
instanceof
SourceClient
&
&
grip
.
url
=
=
=
frame
.
url
)
{
frame
.
where
.
source
=
grip
.
_form
;
}
}
}
this
.
_frameCache
[
frame
.
depth
]
=
frame
;
}
this
.
emit
(
"
framesadded
"
)
;
aCallback
(
aResponse
)
;
}
)
;
return
true
;
}
_clearFrames
:
function
(
)
{
if
(
this
.
_frameCache
.
length
>
0
)
{
this
.
_frameCache
=
[
]
;
this
.
emit
(
"
framescleared
"
)
;
}
}
pauseGrip
:
function
(
aGrip
)
{
if
(
aGrip
.
actor
in
this
.
_pauseGrips
)
{
return
this
.
_pauseGrips
[
aGrip
.
actor
]
;
}
let
client
=
new
ObjectClient
(
this
.
client
aGrip
)
;
this
.
_pauseGrips
[
aGrip
.
actor
]
=
client
;
return
client
;
}
_longString
:
function
(
aGrip
aGripCacheName
)
{
if
(
aGrip
.
actor
in
this
[
aGripCacheName
]
)
{
return
this
[
aGripCacheName
]
[
aGrip
.
actor
]
;
}
let
client
=
new
LongStringClient
(
this
.
client
aGrip
)
;
this
[
aGripCacheName
]
[
aGrip
.
actor
]
=
client
;
return
client
;
}
pauseLongString
:
function
(
aGrip
)
{
return
this
.
_longString
(
aGrip
"
_pauseGrips
"
)
;
}
threadLongString
:
function
(
aGrip
)
{
return
this
.
_longString
(
aGrip
"
_threadGrips
"
)
;
}
_clearObjectClients
:
function
(
aGripCacheName
)
{
for
(
let
id
in
this
[
aGripCacheName
]
)
{
this
[
aGripCacheName
]
[
id
]
.
valid
=
false
;
}
this
[
aGripCacheName
]
=
{
}
;
}
_clearPauseGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_pauseGrips
"
)
;
}
_clearThreadGrips
:
function
(
)
{
this
.
_clearObjectClients
(
"
_threadGrips
"
)
;
}
_onThreadState
:
function
(
aPacket
)
{
this
.
_state
=
ThreadStateTypes
[
aPacket
.
type
]
;
this
.
_lastPausePacket
=
aPacket
.
type
=
=
=
'
resumed
'
?
null
:
aPacket
;
this
.
_clearFrames
(
)
;
this
.
_clearPauseGrips
(
)
;
aPacket
.
type
=
=
=
ThreadStateTypes
.
detached
&
&
this
.
_clearThreadGrips
(
)
;
this
.
client
.
_eventsEnabled
&
&
this
.
emit
(
aPacket
.
type
aPacket
)
;
}
getLastPausePacket
:
function
(
)
{
return
this
.
_lastPausePacket
;
}
environment
:
function
(
aForm
)
{
return
new
EnvironmentClient
(
this
.
client
aForm
)
;
}
source
:
function
(
aForm
)
{
if
(
aForm
.
actor
in
this
.
_threadGrips
)
{
return
this
.
_threadGrips
[
aForm
.
actor
]
;
}
return
this
.
_threadGrips
[
aForm
.
actor
]
=
new
SourceClient
(
this
aForm
)
;
}
getPrototypesAndProperties
:
DebuggerClient
.
requester
(
{
type
:
"
prototypesAndProperties
"
actors
:
args
(
0
)
}
{
telemetry
:
"
PROTOTYPESANDPROPERTIES
"
}
)
events
:
[
"
newSource
"
]
}
;
eventSource
(
ThreadClient
.
prototype
)
;
function
TraceClient
(
aClient
aActor
)
{
this
.
_client
=
aClient
;
this
.
_actor
=
aActor
;
this
.
_activeTraces
=
new
Set
(
)
;
this
.
_waitingPackets
=
new
Map
(
)
;
this
.
_expectedPacket
=
0
;
this
.
request
=
this
.
_client
.
request
;
this
.
events
=
[
]
;
}
TraceClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_actor
;
}
get
tracing
(
)
{
return
this
.
_activeTraces
.
size
>
0
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
detach
:
DebuggerClient
.
requester
(
{
type
:
"
detach
"
}
{
after
:
function
(
aResponse
)
{
this
.
_client
.
unregisterClient
(
this
)
;
return
aResponse
;
}
telemetry
:
"
TRACERDETACH
"
}
)
startTrace
:
DebuggerClient
.
requester
(
{
type
:
"
startTrace
"
name
:
args
(
1
)
trace
:
args
(
0
)
}
{
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
return
aResponse
;
}
if
(
!
this
.
tracing
)
{
this
.
_waitingPackets
.
clear
(
)
;
this
.
_expectedPacket
=
0
;
}
this
.
_activeTraces
.
add
(
aResponse
.
name
)
;
return
aResponse
;
}
telemetry
:
"
STARTTRACE
"
}
)
stopTrace
:
DebuggerClient
.
requester
(
{
type
:
"
stopTrace
"
name
:
args
(
0
)
}
{
after
:
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
return
aResponse
;
}
this
.
_activeTraces
.
delete
(
aResponse
.
name
)
;
return
aResponse
;
}
telemetry
:
"
STOPTRACE
"
}
)
}
;
function
ObjectClient
(
aClient
aGrip
)
{
this
.
_grip
=
aGrip
;
this
.
_client
=
aClient
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
ObjectClient
=
ObjectClient
;
ObjectClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
valid
:
true
get
isFrozen
(
)
{
return
this
.
_grip
.
frozen
;
}
get
isSealed
(
)
{
return
this
.
_grip
.
sealed
;
}
get
isExtensible
(
)
{
return
this
.
_grip
.
extensible
;
}
getDefinitionSite
:
DebuggerClient
.
requester
(
{
type
:
"
definitionSite
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
"
Function
"
)
{
throw
new
Error
(
"
getDefinitionSite
is
only
valid
for
function
grips
.
"
)
;
}
return
aPacket
;
}
}
)
getParameterNames
:
DebuggerClient
.
requester
(
{
type
:
"
parameterNames
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
[
"
class
"
]
!
=
=
"
Function
"
)
{
throw
new
Error
(
"
getParameterNames
is
only
valid
for
function
grips
.
"
)
;
}
return
aPacket
;
}
telemetry
:
"
PARAMETERNAMES
"
}
)
getOwnPropertyNames
:
DebuggerClient
.
requester
(
{
type
:
"
ownPropertyNames
"
}
{
telemetry
:
"
OWNPROPERTYNAMES
"
}
)
getPrototypeAndProperties
:
DebuggerClient
.
requester
(
{
type
:
"
prototypeAndProperties
"
}
{
telemetry
:
"
PROTOTYPEANDPROPERTIES
"
}
)
enumProperties
:
DebuggerClient
.
requester
(
{
type
:
"
enumProperties
"
options
:
args
(
0
)
}
{
after
:
function
(
aResponse
)
{
if
(
aResponse
.
iterator
)
{
return
{
iterator
:
new
PropertyIteratorClient
(
this
.
_client
aResponse
.
iterator
)
}
;
}
return
aResponse
;
}
telemetry
:
"
ENUMPROPERTIES
"
}
)
enumEntries
:
DebuggerClient
.
requester
(
{
type
:
"
enumEntries
"
}
{
before
:
function
(
packet
)
{
if
(
!
[
"
Map
"
"
WeakMap
"
"
Set
"
"
WeakSet
"
]
.
includes
(
this
.
_grip
.
class
)
)
{
throw
new
Error
(
"
enumEntries
is
only
valid
for
Map
/
Set
-
like
grips
.
"
)
;
}
return
packet
;
}
after
:
function
(
response
)
{
if
(
response
.
iterator
)
{
return
{
iterator
:
new
PropertyIteratorClient
(
this
.
_client
response
.
iterator
)
}
;
}
return
response
;
}
}
)
getProperty
:
DebuggerClient
.
requester
(
{
type
:
"
property
"
name
:
args
(
0
)
}
{
telemetry
:
"
PROPERTY
"
}
)
getPrototype
:
DebuggerClient
.
requester
(
{
type
:
"
prototype
"
}
{
telemetry
:
"
PROTOTYPE
"
}
)
getDisplayString
:
DebuggerClient
.
requester
(
{
type
:
"
displayString
"
}
{
telemetry
:
"
DISPLAYSTRING
"
}
)
getScope
:
DebuggerClient
.
requester
(
{
type
:
"
scope
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Function
"
)
{
throw
new
Error
(
"
scope
is
only
valid
for
function
grips
.
"
)
;
}
return
aPacket
;
}
telemetry
:
"
SCOPE
"
}
)
getDependentPromises
:
DebuggerClient
.
requester
(
{
type
:
"
dependentPromises
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getDependentPromises
is
only
valid
for
promise
"
+
"
grips
.
"
)
;
}
return
aPacket
;
}
}
)
getPromiseAllocationStack
:
DebuggerClient
.
requester
(
{
type
:
"
allocationStack
"
}
{
before
:
function
(
aPacket
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getAllocationStack
is
only
valid
for
promise
grips
.
"
)
;
}
return
aPacket
;
}
}
)
getPromiseFulfillmentStack
:
DebuggerClient
.
requester
(
{
type
:
"
fulfillmentStack
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getPromiseFulfillmentStack
is
only
valid
for
"
+
"
promise
grips
.
"
)
;
}
return
packet
;
}
}
)
getPromiseRejectionStack
:
DebuggerClient
.
requester
(
{
type
:
"
rejectionStack
"
}
{
before
:
function
(
packet
)
{
if
(
this
.
_grip
.
class
!
=
=
"
Promise
"
)
{
throw
new
Error
(
"
getPromiseRejectionStack
is
only
valid
for
"
+
"
promise
grips
.
"
)
;
}
return
packet
;
}
}
)
}
;
function
PropertyIteratorClient
(
aClient
aGrip
)
{
this
.
_grip
=
aGrip
;
this
.
_client
=
aClient
;
this
.
request
=
this
.
_client
.
request
;
}
PropertyIteratorClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
;
}
get
count
(
)
{
return
this
.
_grip
.
count
;
}
names
:
DebuggerClient
.
requester
(
{
type
:
"
names
"
indexes
:
args
(
0
)
}
{
}
)
slice
:
DebuggerClient
.
requester
(
{
type
:
"
slice
"
start
:
args
(
0
)
count
:
args
(
1
)
}
{
}
)
all
:
DebuggerClient
.
requester
(
{
type
:
"
all
"
}
{
}
)
}
;
function
LongStringClient
(
aClient
aGrip
)
{
this
.
_grip
=
aGrip
;
this
.
_client
=
aClient
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
LongStringClient
=
LongStringClient
;
LongStringClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_grip
.
actor
;
}
get
length
(
)
{
return
this
.
_grip
.
length
;
}
get
initial
(
)
{
return
this
.
_grip
.
initial
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
valid
:
true
substring
:
DebuggerClient
.
requester
(
{
type
:
"
substring
"
start
:
args
(
0
)
end
:
args
(
1
)
}
{
telemetry
:
"
SUBSTRING
"
}
)
}
;
function
SourceClient
(
aClient
aForm
)
{
this
.
_form
=
aForm
;
this
.
_isBlackBoxed
=
aForm
.
isBlackBoxed
;
this
.
_isPrettyPrinted
=
aForm
.
isPrettyPrinted
;
this
.
_activeThread
=
aClient
;
this
.
_client
=
aClient
.
client
;
}
SourceClient
.
prototype
=
{
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
get
isBlackBoxed
(
)
{
return
this
.
_isBlackBoxed
;
}
get
isPrettyPrinted
(
)
{
return
this
.
_isPrettyPrinted
;
}
get
actor
(
)
{
return
this
.
_form
.
actor
;
}
get
request
(
)
{
return
this
.
_client
.
request
;
}
get
url
(
)
{
return
this
.
_form
.
url
;
}
blackBox
:
DebuggerClient
.
requester
(
{
type
:
"
blackbox
"
}
{
telemetry
:
"
BLACKBOX
"
after
:
function
(
aResponse
)
{
if
(
!
aResponse
.
error
)
{
this
.
_isBlackBoxed
=
true
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
aResponse
;
}
}
)
unblackBox
:
DebuggerClient
.
requester
(
{
type
:
"
unblackbox
"
}
{
telemetry
:
"
UNBLACKBOX
"
after
:
function
(
aResponse
)
{
if
(
!
aResponse
.
error
)
{
this
.
_isBlackBoxed
=
false
;
if
(
this
.
_activeThread
)
{
this
.
_activeThread
.
emit
(
"
blackboxchange
"
this
)
;
}
}
return
aResponse
;
}
}
)
getExecutableLines
:
function
(
cb
=
noop
)
{
let
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
getExecutableLines
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
res
=
>
{
cb
(
res
.
lines
)
;
return
res
.
lines
;
}
)
;
}
source
:
function
(
aCallback
=
noop
)
{
let
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
source
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
return
this
.
_onSourceResponse
(
aResponse
aCallback
)
}
)
;
}
prettyPrint
:
function
(
aIndent
aCallback
=
noop
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
prettyPrint
"
indent
:
aIndent
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
this
.
_isPrettyPrinted
=
true
;
this
.
_activeThread
.
_clearFrames
(
)
;
this
.
_activeThread
.
emit
(
"
prettyprintchange
"
this
)
;
}
return
this
.
_onSourceResponse
(
aResponse
aCallback
)
;
}
)
;
}
disablePrettyPrint
:
function
(
aCallback
=
noop
)
{
const
packet
=
{
to
:
this
.
_form
.
actor
type
:
"
disablePrettyPrint
"
}
;
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
if
(
!
aResponse
.
error
)
{
this
.
_isPrettyPrinted
=
false
;
this
.
_activeThread
.
_clearFrames
(
)
;
this
.
_activeThread
.
emit
(
"
prettyprintchange
"
this
)
;
}
return
this
.
_onSourceResponse
(
aResponse
aCallback
)
;
}
)
;
}
_onSourceResponse
:
function
(
aResponse
aCallback
)
{
if
(
aResponse
.
error
)
{
aCallback
(
aResponse
)
;
return
aResponse
;
}
if
(
typeof
aResponse
.
source
=
=
=
"
string
"
)
{
aCallback
(
aResponse
)
;
return
aResponse
;
}
let
{
contentType
source
}
=
aResponse
;
let
longString
=
this
.
_activeThread
.
threadLongString
(
source
)
;
return
longString
.
substring
(
0
longString
.
length
)
.
then
(
function
(
aResponse
)
{
if
(
aResponse
.
error
)
{
aCallback
(
aResponse
)
;
return
aReponse
;
}
let
response
=
{
source
:
aResponse
.
substring
contentType
:
contentType
}
;
aCallback
(
response
)
;
return
response
;
}
)
;
}
setBreakpoint
:
function
(
{
line
column
condition
}
aOnResponse
=
noop
)
{
let
doSetBreakpoint
=
aCallback
=
>
{
let
root
=
this
.
_client
.
mainRoot
;
let
location
=
{
line
:
line
column
:
column
}
;
let
packet
=
{
to
:
this
.
actor
type
:
"
setBreakpoint
"
location
:
location
condition
:
condition
}
;
if
(
!
root
.
traits
.
debuggerSourceActors
)
{
packet
.
to
=
this
.
_activeThread
.
actor
;
packet
.
location
.
url
=
this
.
url
;
}
return
this
.
_client
.
request
(
packet
)
.
then
(
aResponse
=
>
{
let
bpClient
;
if
(
aResponse
.
actor
)
{
bpClient
=
new
BreakpointClient
(
this
.
_client
this
aResponse
.
actor
location
root
.
traits
.
conditionalBreakpoints
?
condition
:
undefined
)
;
}
aOnResponse
(
aResponse
bpClient
)
;
if
(
aCallback
)
{
aCallback
(
)
;
}
return
[
aResponse
bpClient
]
;
}
)
;
}
;
if
(
this
.
_activeThread
.
paused
)
{
return
doSetBreakpoint
(
)
;
}
return
this
.
_activeThread
.
interrupt
(
)
.
then
(
aResponse
=
>
{
if
(
aResponse
.
error
)
{
aOnResponse
(
aResponse
)
;
return
aResponse
;
}
const
{
type
why
}
=
aResponse
;
const
cleanUp
=
type
=
=
"
paused
"
&
&
why
.
type
=
=
"
interrupted
"
?
(
)
=
>
this
.
_activeThread
.
resume
(
)
:
noop
;
return
doSetBreakpoint
(
cleanUp
)
;
}
)
;
}
}
;
function
BreakpointClient
(
aClient
aSourceClient
aActor
aLocation
aCondition
)
{
this
.
_client
=
aClient
;
this
.
_actor
=
aActor
;
this
.
location
=
aLocation
;
this
.
location
.
actor
=
aSourceClient
.
actor
;
this
.
location
.
url
=
aSourceClient
.
url
;
this
.
source
=
aSourceClient
;
this
.
request
=
this
.
_client
.
request
;
if
(
aCondition
)
{
this
.
condition
=
aCondition
;
}
}
BreakpointClient
.
prototype
=
{
_actor
:
null
get
actor
(
)
{
return
this
.
_actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
remove
:
DebuggerClient
.
requester
(
{
type
:
"
delete
"
}
{
telemetry
:
"
DELETE
"
}
)
hasCondition
:
function
(
)
{
let
root
=
this
.
_client
.
mainRoot
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
return
"
condition
"
in
this
;
}
else
{
return
"
conditionalExpression
"
in
this
;
}
}
getCondition
:
function
(
)
{
let
root
=
this
.
_client
.
mainRoot
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
return
this
.
condition
;
}
else
{
return
this
.
conditionalExpression
;
}
}
setCondition
:
function
(
gThreadClient
aCondition
)
{
let
root
=
this
.
_client
.
mainRoot
;
let
deferred
=
promise
.
defer
(
)
;
if
(
root
.
traits
.
conditionalBreakpoints
)
{
let
info
=
{
line
:
this
.
location
.
line
column
:
this
.
location
.
column
condition
:
aCondition
}
;
this
.
remove
(
aResponse
=
>
{
if
(
aResponse
&
&
aResponse
.
error
)
{
deferred
.
reject
(
aResponse
)
;
return
;
}
this
.
source
.
setBreakpoint
(
info
(
aResponse
aNewBreakpoint
)
=
>
{
if
(
aResponse
&
&
aResponse
.
error
)
{
deferred
.
reject
(
aResponse
)
;
}
else
{
deferred
.
resolve
(
aNewBreakpoint
)
;
}
}
)
;
}
)
;
}
else
{
if
(
aCondition
=
=
=
"
"
)
{
delete
this
.
conditionalExpression
;
}
else
{
this
.
conditionalExpression
=
aCondition
;
}
deferred
.
resolve
(
this
)
;
}
return
deferred
.
promise
;
}
}
;
eventSource
(
BreakpointClient
.
prototype
)
;
function
EnvironmentClient
(
aClient
aForm
)
{
this
.
_client
=
aClient
;
this
.
_form
=
aForm
;
this
.
request
=
this
.
_client
.
request
;
}
exports
.
EnvironmentClient
=
EnvironmentClient
;
EnvironmentClient
.
prototype
=
{
get
actor
(
)
{
return
this
.
_form
.
actor
;
}
get
_transport
(
)
{
return
this
.
_client
.
_transport
;
}
getBindings
:
DebuggerClient
.
requester
(
{
type
:
"
bindings
"
}
{
telemetry
:
"
BINDINGS
"
}
)
assign
:
DebuggerClient
.
requester
(
{
type
:
"
assign
"
name
:
args
(
0
)
value
:
args
(
1
)
}
{
telemetry
:
"
ASSIGN
"
}
)
}
;
eventSource
(
EnvironmentClient
.
prototype
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
)
{
"
use
strict
"
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
UNCAUGHT_ERROR
=
'
An
error
event
was
emitted
for
which
there
was
no
listener
.
'
;
const
BAD_LISTENER
=
'
The
event
listener
must
be
a
function
.
'
;
const
{
ns
}
=
__webpack_require__
(
102
)
;
const
event
=
ns
(
)
;
const
EVENT_TYPE_PATTERN
=
/
^
on
(
[
A
-
Z
]
\
w
+
)
/
;
exports
.
EVENT_TYPE_PATTERN
=
EVENT_TYPE_PATTERN
;
const
observers
=
function
observers
(
target
type
)
{
if
(
!
target
)
throw
TypeError
(
"
Event
target
must
be
an
object
"
)
;
let
listeners
=
event
(
target
)
;
return
type
in
listeners
?
listeners
[
type
]
:
listeners
[
type
]
=
[
]
;
}
;
function
on
(
target
type
listener
)
{
if
(
typeof
(
listener
)
!
=
=
'
function
'
)
throw
new
Error
(
BAD_LISTENER
)
;
let
listeners
=
observers
(
target
type
)
;
if
(
!
~
listeners
.
indexOf
(
listener
)
)
listeners
.
push
(
listener
)
;
}
exports
.
on
=
on
;
var
onceWeakMap
=
new
WeakMap
(
)
;
function
once
(
target
type
listener
)
{
let
replacement
=
function
observer
(
.
.
.
args
)
{
off
(
target
type
observer
)
;
onceWeakMap
.
delete
(
listener
)
;
listener
.
apply
(
target
args
)
;
}
;
onceWeakMap
.
set
(
listener
replacement
)
;
on
(
target
type
replacement
)
;
}
exports
.
once
=
once
;
function
emit
(
target
type
.
.
.
args
)
{
emitOnObject
(
target
type
target
.
.
.
args
)
;
}
exports
.
emit
=
emit
;
function
emitOnObject
(
target
type
thisArg
.
.
.
args
)
{
let
all
=
observers
(
target
'
*
'
)
.
length
;
let
state
=
observers
(
target
type
)
;
let
listeners
=
state
.
slice
(
)
;
let
count
=
listeners
.
length
;
let
index
=
0
;
if
(
count
=
=
=
0
&
&
type
=
=
=
'
error
'
&
&
all
=
=
=
0
)
console
.
exception
(
args
[
0
]
)
;
while
(
index
<
count
)
{
try
{
let
listener
=
listeners
[
index
]
;
if
(
~
state
.
indexOf
(
listener
)
)
listener
.
apply
(
thisArg
args
)
;
}
catch
(
error
)
{
if
(
type
!
=
=
'
error
'
)
emit
(
target
'
error
'
error
)
;
else
console
.
exception
(
error
)
;
}
index
+
+
;
}
if
(
type
!
=
=
'
*
'
)
emit
(
target
'
*
'
type
.
.
.
args
)
;
}
exports
.
emitOnObject
=
emitOnObject
;
function
off
(
target
type
listener
)
{
let
length
=
arguments
.
length
;
if
(
length
=
=
=
3
)
{
if
(
onceWeakMap
.
has
(
listener
)
)
{
listener
=
onceWeakMap
.
get
(
listener
)
;
onceWeakMap
.
delete
(
listener
)
;
}
let
listeners
=
observers
(
target
type
)
;
let
index
=
listeners
.
indexOf
(
listener
)
;
if
(
~
index
)
listeners
.
splice
(
index
1
)
;
}
else
if
(
length
=
=
=
2
)
{
observers
(
target
type
)
.
splice
(
0
)
;
}
else
if
(
length
=
=
=
1
)
{
let
listeners
=
event
(
target
)
;
Object
.
keys
(
listeners
)
.
forEach
(
type
=
>
delete
listeners
[
type
]
)
;
}
}
exports
.
off
=
off
;
function
count
(
target
type
)
{
return
observers
(
target
type
)
.
length
;
}
exports
.
count
=
count
;
function
setListeners
(
target
listeners
)
{
Object
.
keys
(
listeners
|
|
{
}
)
.
forEach
(
key
=
>
{
let
match
=
EVENT_TYPE_PATTERN
.
exec
(
key
)
;
let
type
=
match
&
&
match
[
1
]
.
toLowerCase
(
)
;
if
(
!
type
)
return
;
let
listener
=
listeners
[
key
]
;
if
(
typeof
(
listener
)
=
=
=
'
function
'
)
on
(
target
type
listener
)
;
}
)
;
}
exports
.
setListeners
=
setListeners
;
}
.
call
(
exports
__webpack_require__
(
101
)
(
module
)
)
)
}
function
(
module
exports
)
{
module
.
exports
=
function
(
module
)
{
if
(
!
module
.
webpackPolyfill
)
{
module
.
deprecate
=
function
(
)
{
}
;
module
.
paths
=
[
]
;
module
.
children
=
[
]
;
module
.
webpackPolyfill
=
1
;
}
return
module
;
}
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
)
{
"
use
strict
"
;
module
.
metadata
=
{
"
stability
"
:
"
unstable
"
}
;
const
create
=
Object
.
create
;
const
prototypeOf
=
Object
.
getPrototypeOf
;
function
ns
(
)
{
const
map
=
new
WeakMap
(
)
;
return
function
namespace
(
target
)
{
if
(
!
target
)
return
target
;
if
(
!
map
.
has
(
target
)
)
map
.
set
(
target
create
(
namespace
(
prototypeOf
(
target
)
|
|
null
)
)
)
;
return
map
.
get
(
target
)
;
}
;
}
;
exports
.
ns
=
ns
;
exports
.
Namespace
=
ns
;
}
.
call
(
exports
__webpack_require__
(
101
)
(
module
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
__webpack_require__
(
28
)
;
const
DevToolsUtils
=
__webpack_require__
(
27
)
;
const
EventEmitter
=
__webpack_require__
(
104
)
;
const
promise
=
__webpack_require__
(
39
)
;
const
{
LongStringClient
}
=
__webpack_require__
(
99
)
;
function
WebConsoleClient
(
aDebuggerClient
aResponse
)
{
this
.
_actor
=
aResponse
.
from
;
this
.
_client
=
aDebuggerClient
;
this
.
_longStrings
=
{
}
;
this
.
traits
=
aResponse
.
traits
|
|
{
}
;
this
.
events
=
[
]
;
this
.
_networkRequests
=
new
Map
(
)
;
this
.
pendingEvaluationResults
=
new
Map
(
)
;
this
.
onEvaluationResult
=
this
.
onEvaluationResult
.
bind
(
this
)
;
this
.
onNetworkEvent
=
this
.
_onNetworkEvent
.
bind
(
this
)
;
this
.
onNetworkEventUpdate
=
this
.
_onNetworkEventUpdate
.
bind
(
this
)
;
this
.
_client
.
addListener
(
"
evaluationResult
"
this
.
onEvaluationResult
)
;
this
.
_client
.
addListener
(
"
networkEvent
"
this
.
onNetworkEvent
)
;
this
.
_client
.
addListener
(
"
networkEventUpdate
"
this
.
onNetworkEventUpdate
)
;
EventEmitter
.
decorate
(
this
)
;
}
exports
.
WebConsoleClient
=
WebConsoleClient
;
WebConsoleClient
.
prototype
=
{
_longStrings
:
null
traits
:
null
_networkRequests
:
null
getNetworkRequest
(
actorId
)
{
return
this
.
_networkRequests
.
get
(
actorId
)
;
}
hasNetworkRequest
(
actorId
)
{
return
this
.
_networkRequests
.
has
(
actorId
)
;
}
removeNetworkRequest
(
actorId
)
{
this
.
_networkRequests
.
delete
(
actorId
)
;
}
getNetworkEvents
(
)
{
return
this
.
_networkRequests
.
values
(
)
;
}
get
actor
(
)
{
return
this
.
_actor
;
}
_onNetworkEvent
:
function
(
type
packet
)
{
if
(
packet
.
from
=
=
this
.
_actor
)
{
let
actor
=
packet
.
eventActor
;
let
networkInfo
=
{
_type
:
"
NetworkEvent
"
timeStamp
:
actor
.
timeStamp
node
:
null
actor
:
actor
.
actor
discardRequestBody
:
true
discardResponseBody
:
true
startedDateTime
:
actor
.
startedDateTime
request
:
{
url
:
actor
.
url
method
:
actor
.
method
}
isXHR
:
actor
.
isXHR
response
:
{
}
timings
:
{
}
updates
:
[
]
private
:
actor
.
private
fromCache
:
actor
.
fromCache
}
;
this
.
_networkRequests
.
set
(
actor
.
actor
networkInfo
)
;
this
.
emit
(
"
networkEvent
"
networkInfo
)
;
}
}
_onNetworkEventUpdate
:
function
(
type
packet
)
{
let
networkInfo
=
this
.
getNetworkRequest
(
packet
.
from
)
;
if
(
!
networkInfo
)
{
return
;
}
networkInfo
.
updates
.
push
(
packet
.
updateType
)
;
switch
(
packet
.
updateType
)
{
case
"
requestHeaders
"
:
networkInfo
.
request
.
headersSize
=
packet
.
headersSize
;
break
;
case
"
requestPostData
"
:
networkInfo
.
discardRequestBody
=
packet
.
discardRequestBody
;
networkInfo
.
request
.
bodySize
=
packet
.
dataSize
;
break
;
case
"
responseStart
"
:
networkInfo
.
response
.
httpVersion
=
packet
.
response
.
httpVersion
;
networkInfo
.
response
.
status
=
packet
.
response
.
status
;
networkInfo
.
response
.
statusText
=
packet
.
response
.
statusText
;
networkInfo
.
response
.
headersSize
=
packet
.
response
.
headersSize
;
networkInfo
.
response
.
remoteAddress
=
packet
.
response
.
remoteAddress
;
networkInfo
.
response
.
remotePort
=
packet
.
response
.
remotePort
;
networkInfo
.
discardResponseBody
=
packet
.
response
.
discardResponseBody
;
break
;
case
"
responseContent
"
:
networkInfo
.
response
.
content
=
{
mimeType
:
packet
.
mimeType
}
;
networkInfo
.
response
.
bodySize
=
packet
.
contentSize
;
networkInfo
.
response
.
transferredSize
=
packet
.
transferredSize
;
networkInfo
.
discardResponseBody
=
packet
.
discardResponseBody
;
break
;
case
"
eventTimings
"
:
networkInfo
.
totalTime
=
packet
.
totalTime
;
break
;
case
"
securityInfo
"
:
networkInfo
.
securityInfo
=
packet
.
state
;
break
;
}
this
.
emit
(
"
networkEventUpdate
"
{
packet
:
packet
networkInfo
}
)
;
}
getCachedMessages
:
function
WCC_getCachedMessages
(
types
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
getCachedMessages
"
messageTypes
:
types
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
inspectObjectProperties
:
function
WCC_inspectObjectProperties
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
inspectProperties
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
evaluateJS
:
function
WCC_evaluateJS
(
aString
aOnResponse
aOptions
=
{
}
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
evaluateJS
"
text
:
aString
bindObjectActor
:
aOptions
.
bindObjectActor
frameActor
:
aOptions
.
frameActor
url
:
aOptions
.
url
selectedNodeActor
:
aOptions
.
selectedNodeActor
selectedObjectActor
:
aOptions
.
selectedObjectActor
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
evaluateJSAsync
:
function
(
aString
aOnResponse
aOptions
=
{
}
)
{
if
(
!
this
.
traits
.
evaluateJSAsync
)
{
this
.
evaluateJS
(
aString
aOnResponse
aOptions
)
;
return
;
}
let
packet
=
{
to
:
this
.
_actor
type
:
"
evaluateJSAsync
"
text
:
aString
bindObjectActor
:
aOptions
.
bindObjectActor
frameActor
:
aOptions
.
frameActor
url
:
aOptions
.
url
selectedNodeActor
:
aOptions
.
selectedNodeActor
selectedObjectActor
:
aOptions
.
selectedObjectActor
}
;
this
.
_client
.
request
(
packet
response
=
>
{
if
(
this
.
pendingEvaluationResults
)
{
this
.
pendingEvaluationResults
.
set
(
response
.
resultID
aOnResponse
)
;
}
}
)
;
}
onEvaluationResult
:
function
(
aNotification
aPacket
)
{
if
(
aPacket
.
from
!
=
=
this
.
_actor
)
{
return
;
}
let
onResponse
=
this
.
pendingEvaluationResults
.
get
(
aPacket
.
resultID
)
;
if
(
onResponse
)
{
onResponse
(
aPacket
)
;
this
.
pendingEvaluationResults
.
delete
(
aPacket
.
resultID
)
;
}
else
{
DevToolsUtils
.
reportException
(
"
onEvaluationResult
"
"
No
response
handler
for
an
evaluateJSAsync
result
(
resultID
:
"
+
aPacket
.
resultID
+
"
)
"
)
;
}
}
autocomplete
:
function
WCC_autocomplete
(
aString
aCursor
aOnResponse
aFrameActor
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
autocomplete
"
text
:
aString
cursor
:
aCursor
frameActor
:
aFrameActor
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
clearMessagesCache
:
function
WCC_clearMessagesCache
(
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
clearMessagesCache
"
}
;
this
.
_client
.
request
(
packet
)
;
}
getPreferences
:
function
WCC_getPreferences
(
aPreferences
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
getPreferences
"
preferences
:
aPreferences
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
setPreferences
:
function
WCC_setPreferences
(
aPreferences
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
setPreferences
"
preferences
:
aPreferences
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getRequestHeaders
:
function
WCC_getRequestHeaders
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getRequestHeaders
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getRequestCookies
:
function
WCC_getRequestCookies
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getRequestCookies
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getRequestPostData
:
function
WCC_getRequestPostData
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getRequestPostData
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getResponseHeaders
:
function
WCC_getResponseHeaders
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getResponseHeaders
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getResponseCookies
:
function
WCC_getResponseCookies
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getResponseCookies
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getResponseContent
:
function
WCC_getResponseContent
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getResponseContent
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getEventTimings
:
function
WCC_getEventTimings
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getEventTimings
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
getSecurityInfo
:
function
WCC_getSecurityInfo
(
aActor
aOnResponse
)
{
let
packet
=
{
to
:
aActor
type
:
"
getSecurityInfo
"
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
sendHTTPRequest
:
function
WCC_sendHTTPRequest
(
aData
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
sendHTTPRequest
"
request
:
aData
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
startListeners
:
function
WCC_startListeners
(
aListeners
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
startListeners
"
listeners
:
aListeners
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
stopListeners
:
function
WCC_stopListeners
(
aListeners
aOnResponse
)
{
let
packet
=
{
to
:
this
.
_actor
type
:
"
stopListeners
"
listeners
:
aListeners
}
;
this
.
_client
.
request
(
packet
aOnResponse
)
;
}
longString
:
function
WCC_longString
(
aGrip
)
{
if
(
aGrip
.
actor
in
this
.
_longStrings
)
{
return
this
.
_longStrings
[
aGrip
.
actor
]
;
}
let
client
=
new
LongStringClient
(
this
.
_client
aGrip
)
;
this
.
_longStrings
[
aGrip
.
actor
]
=
client
;
return
client
;
}
detach
:
function
WCC_detach
(
aOnResponse
)
{
this
.
_client
.
removeListener
(
"
evaluationResult
"
this
.
onEvaluationResult
)
;
this
.
_client
.
removeListener
(
"
networkEvent
"
this
.
onNetworkEvent
)
;
this
.
_client
.
removeListener
(
"
networkEventUpdate
"
this
.
onNetworkEventUpdate
)
;
this
.
stopListeners
(
null
aOnResponse
)
;
this
.
_longStrings
=
null
;
this
.
_client
=
null
;
this
.
pendingEvaluationResults
.
clear
(
)
;
this
.
pendingEvaluationResults
=
null
;
this
.
clearNetworkRequests
(
)
;
this
.
_networkRequests
=
null
;
}
clearNetworkRequests
:
function
(
)
{
this
.
_networkRequests
.
clear
(
)
;
}
getString
:
function
(
stringGrip
)
{
if
(
typeof
stringGrip
!
=
"
object
"
|
|
stringGrip
.
type
!
=
"
longString
"
)
{
return
promise
.
resolve
(
stringGrip
)
;
}
if
(
stringGrip
.
_fullText
)
{
return
stringGrip
.
_fullText
.
promise
;
}
let
deferred
=
stringGrip
.
_fullText
=
promise
.
defer
(
)
;
let
{
actor
initial
length
}
=
stringGrip
;
let
longStringClient
=
this
.
longString
(
stringGrip
)
;
longStringClient
.
substring
(
initial
.
length
length
aResponse
=
>
{
if
(
aResponse
.
error
)
{
DevToolsUtils
.
reportException
(
"
getString
"
aResponse
.
error
+
"
:
"
+
aResponse
.
message
)
;
deferred
.
reject
(
aResponse
)
;
return
;
}
deferred
.
resolve
(
initial
+
aResponse
.
substring
)
;
}
)
;
return
deferred
.
promise
;
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
EventEmitter
=
function
EventEmitter
(
)
{
}
;
module
.
exports
=
EventEmitter
;
const
{
Cu
}
=
__webpack_require__
(
28
)
;
const
promise
=
__webpack_require__
(
39
)
;
EventEmitter
.
decorate
=
function
EventEmitter_decorate
(
aObjectToDecorate
)
{
let
emitter
=
new
EventEmitter
(
)
;
aObjectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
aObjectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
aObjectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
aObjectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
:
function
EventEmitter_on
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
this
.
_eventEmitterListeners
=
new
Map
(
)
;
if
(
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
aEvent
)
.
push
(
aListener
)
;
}
once
:
function
EventEmitter_once
(
aEvent
aListener
)
{
let
deferred
=
promise
.
defer
(
)
;
let
handler
=
(
aEvent
aFirstArg
.
.
.
aRest
)
=
>
{
this
.
off
(
aEvent
handler
)
;
if
(
aListener
)
{
aListener
.
apply
(
null
[
aEvent
aFirstArg
.
.
.
aRest
]
)
;
}
deferred
.
resolve
(
aFirstArg
)
;
}
;
handler
.
_originalListener
=
aListener
;
this
.
on
(
aEvent
handler
)
;
return
deferred
.
promise
;
}
off
:
function
EventEmitter_off
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
return
;
let
listeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
listeners
.
filter
(
l
=
>
{
return
l
!
=
=
aListener
&
&
l
.
_originalListener
!
=
=
aListener
;
}
)
)
;
}
}
emit
:
function
EventEmitter_emit
(
aEvent
)
{
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
return
;
}
let
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
for
(
let
listener
of
this
.
_eventEmitterListeners
.
get
(
aEvent
)
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
break
;
}
if
(
originalListeners
=
=
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
|
|
this
.
_eventEmitterListeners
.
get
(
aEvent
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
.
apply
(
null
arguments
)
;
}
catch
(
ex
)
{
let
msg
=
ex
+
"
:
"
+
ex
.
stack
;
console
.
log
(
msg
)
;
}
}
}
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
DevToolsUtils
=
__webpack_require__
(
27
)
;
const
{
dumpn
dumpv
}
=
DevToolsUtils
;
const
StreamUtils
=
__webpack_require__
(
106
)
;
const
{
Packet
JSONPacket
BulkPacket
}
=
__webpack_require__
(
107
)
;
const
promise
=
__webpack_require__
(
39
)
;
const
EventEmitter
=
__webpack_require__
(
104
)
;
const
utf8
=
__webpack_require__
(
109
)
;
const
PACKET_HEADER_MAX
=
200
;
function
DebuggerTransport
(
socket
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_socket
=
socket
;
this
.
_incomingHeader
=
"
"
;
this
.
_incoming
=
null
;
this
.
_outgoing
=
[
]
;
this
.
hooks
=
null
;
this
.
active
=
false
;
this
.
_incomingEnabled
=
true
;
this
.
_outgoingEnabled
=
true
;
this
.
close
=
this
.
close
.
bind
(
this
)
;
}
DebuggerTransport
.
prototype
=
{
send
:
function
(
object
)
{
this
.
emit
(
"
send
"
object
)
;
let
packet
=
new
JSONPacket
(
this
)
;
packet
.
object
=
object
;
this
.
_outgoing
.
push
(
packet
)
;
this
.
_flushOutgoing
(
)
;
}
startBulkSend
:
function
(
header
)
{
this
.
emit
(
"
startBulkSend
"
header
)
;
let
packet
=
new
BulkPacket
(
this
)
;
packet
.
header
=
header
;
this
.
_outgoing
.
push
(
packet
)
;
this
.
_flushOutgoing
(
)
;
return
packet
.
streamReadyForWriting
;
}
close
:
function
(
reason
)
{
this
.
emit
(
"
onClosed
"
reason
)
;
this
.
active
=
false
;
this
.
_socket
.
close
(
)
;
this
.
_destroyIncoming
(
)
;
this
.
_destroyAllOutgoing
(
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
reason
)
;
this
.
hooks
=
null
;
}
if
(
reason
)
{
dumpn
(
"
Transport
closed
:
"
+
DevToolsUtils
.
safeErrorString
(
reason
)
)
;
}
else
{
dumpn
(
"
Transport
closed
.
"
)
;
}
}
get
_currentOutgoing
(
)
{
return
this
.
_outgoing
[
0
]
;
}
_flushOutgoing
:
function
(
)
{
if
(
!
this
.
_outgoingEnabled
|
|
this
.
_outgoing
.
length
=
=
=
0
)
{
return
;
}
if
(
this
.
_currentOutgoing
.
done
)
{
this
.
_finishCurrentOutgoing
(
)
;
}
if
(
this
.
_outgoing
.
length
>
0
)
{
setTimeout
(
this
.
onOutputStreamReady
.
bind
(
this
)
0
)
;
}
}
pauseOutgoing
:
function
(
)
{
this
.
_outgoingEnabled
=
false
;
}
resumeOutgoing
:
function
(
)
{
this
.
_outgoingEnabled
=
true
;
this
.
_flushOutgoing
(
)
;
}
onOutputStreamReady
:
DevToolsUtils
.
makeInfallible
(
function
(
)
{
if
(
!
this
.
_outgoingEnabled
|
|
this
.
_outgoing
.
length
=
=
=
0
)
{
return
;
}
try
{
this
.
_currentOutgoing
.
write
(
{
write
:
data
=
>
{
let
count
=
data
.
length
;
this
.
_socket
.
send
(
data
)
;
return
count
;
}
}
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
this
.
close
(
e
.
result
)
;
return
;
}
else
{
throw
e
;
}
}
this
.
_flushOutgoing
(
)
;
}
"
DebuggerTransport
.
prototype
.
onOutputStreamReady
"
)
_finishCurrentOutgoing
:
function
(
)
{
if
(
this
.
_currentOutgoing
)
{
this
.
_currentOutgoing
.
destroy
(
)
;
this
.
_outgoing
.
shift
(
)
;
}
}
_destroyAllOutgoing
:
function
(
)
{
for
(
let
packet
of
this
.
_outgoing
)
{
packet
.
destroy
(
)
;
}
this
.
_outgoing
=
[
]
;
}
ready
:
function
(
)
{
this
.
active
=
true
;
this
.
_waitForIncoming
(
)
;
}
_waitForIncoming
:
function
(
)
{
if
(
this
.
_incomingEnabled
&
&
!
this
.
_socket
.
onmessage
)
{
this
.
_socket
.
onmessage
=
this
.
onInputStreamReady
.
bind
(
this
)
;
}
}
pauseIncoming
:
function
(
)
{
this
.
_incomingEnabled
=
false
;
}
resumeIncoming
:
function
(
)
{
this
.
_incomingEnabled
=
true
;
this
.
_flushIncoming
(
)
;
this
.
_waitForIncoming
(
)
;
}
onInputStreamReady
:
DevToolsUtils
.
makeInfallible
(
function
(
event
)
{
let
data
=
event
.
data
;
data
=
utf8
.
encode
(
data
)
;
let
stream
=
{
available
(
)
{
return
data
.
length
;
}
readBytes
(
count
)
{
let
result
=
data
.
slice
(
0
count
)
;
data
=
data
.
slice
(
count
)
;
return
result
;
}
}
;
try
{
while
(
data
&
&
this
.
_incomingEnabled
&
&
this
.
_processIncoming
(
stream
stream
.
available
(
)
)
)
{
}
this
.
_waitForIncoming
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
!
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
this
.
close
(
e
.
result
)
;
}
else
{
throw
e
;
}
}
}
"
DebuggerTransport
.
prototype
.
onInputStreamReady
"
)
_processIncoming
:
function
(
stream
count
)
{
dumpv
(
"
Data
available
:
"
+
count
)
;
if
(
!
count
)
{
dumpv
(
"
Nothing
to
read
skipping
"
)
;
return
false
;
}
try
{
if
(
!
this
.
_incoming
)
{
dumpv
(
"
Creating
a
new
packet
from
incoming
"
)
;
if
(
!
this
.
_readHeader
(
stream
)
)
{
return
false
;
}
this
.
_incoming
=
Packet
.
fromHeader
(
this
.
_incomingHeader
this
)
;
if
(
!
this
.
_incoming
)
{
throw
new
Error
(
"
No
packet
types
for
header
:
"
+
this
.
_incomingHeader
)
;
}
}
if
(
!
this
.
_incoming
.
done
)
{
dumpv
(
"
Existing
packet
incomplete
keep
reading
"
)
;
this
.
_incoming
.
read
(
stream
)
;
}
}
catch
(
e
)
{
let
msg
=
"
Error
reading
incoming
packet
:
(
"
+
e
+
"
-
"
+
e
.
stack
+
"
)
"
;
dumpn
(
msg
)
;
this
.
close
(
)
;
return
false
;
}
if
(
!
this
.
_incoming
.
done
)
{
dumpv
(
"
Packet
not
done
wait
for
more
"
)
;
return
true
;
}
this
.
_flushIncoming
(
)
;
return
true
;
}
_readHeader
:
function
(
stream
)
{
let
amountToRead
=
PACKET_HEADER_MAX
-
this
.
_incomingHeader
.
length
;
this
.
_incomingHeader
+
=
StreamUtils
.
delimitedRead
(
stream
"
:
"
amountToRead
)
;
if
(
dumpv
.
wantVerbose
)
{
dumpv
(
"
Header
read
:
"
+
this
.
_incomingHeader
)
;
}
if
(
this
.
_incomingHeader
.
endsWith
(
"
:
"
)
)
{
if
(
dumpv
.
wantVerbose
)
{
dumpv
(
"
Found
packet
header
successfully
:
"
+
this
.
_incomingHeader
)
;
}
return
true
;
}
if
(
this
.
_incomingHeader
.
length
>
=
PACKET_HEADER_MAX
)
{
throw
new
Error
(
"
Failed
to
parse
packet
header
!
"
)
;
}
return
false
;
}
_flushIncoming
:
function
(
)
{
if
(
!
this
.
_incoming
.
done
)
{
return
;
}
if
(
dumpn
.
wantLogging
)
{
dumpn
(
"
Got
:
"
+
this
.
_incoming
)
;
}
this
.
_destroyIncoming
(
)
;
}
_onJSONObjectReady
:
function
(
object
)
{
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
this
.
active
)
{
this
.
emit
(
"
onPacket
"
object
)
;
this
.
hooks
.
onPacket
(
object
)
;
}
}
"
DebuggerTransport
instance
'
s
this
.
hooks
.
onPacket
"
)
)
;
}
_onBulkReadReady
:
function
(
.
.
.
args
)
{
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
this
.
active
)
{
this
.
emit
(
"
onBulkPacket
"
.
.
.
args
)
;
this
.
hooks
.
onBulkPacket
(
.
.
.
args
)
;
}
}
"
DebuggerTransport
instance
'
s
this
.
hooks
.
onBulkPacket
"
)
)
;
}
_destroyIncoming
:
function
(
)
{
if
(
this
.
_incoming
)
{
this
.
_incoming
.
destroy
(
)
;
}
this
.
_incomingHeader
=
"
"
;
this
.
_incoming
=
null
;
}
}
;
exports
.
DebuggerTransport
=
DebuggerTransport
;
function
LocalDebuggerTransport
(
other
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
other
=
other
;
this
.
hooks
=
null
;
this
.
_serial
=
this
.
other
?
this
.
other
.
_serial
:
{
count
:
0
}
;
this
.
close
=
this
.
close
.
bind
(
this
)
;
}
LocalDebuggerTransport
.
prototype
=
{
send
:
function
(
packet
)
{
this
.
emit
(
"
send
"
packet
)
;
let
serial
=
this
.
_serial
.
count
+
+
;
if
(
dumpn
.
wantLogging
)
{
if
(
packet
.
from
)
{
dumpn
(
"
Packet
"
+
serial
+
"
sent
from
"
+
uneval
(
packet
.
from
)
)
;
}
else
if
(
packet
.
to
)
{
dumpn
(
"
Packet
"
+
serial
+
"
sent
to
"
+
uneval
(
packet
.
to
)
)
;
}
}
this
.
_deepFreeze
(
packet
)
;
let
other
=
this
.
other
;
if
(
other
)
{
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
if
(
dumpn
.
wantLogging
)
{
dumpn
(
"
Received
packet
"
+
serial
+
"
:
"
+
JSON
.
stringify
(
packet
null
2
)
)
;
}
if
(
other
.
hooks
)
{
other
.
emit
(
"
onPacket
"
packet
)
;
other
.
hooks
.
onPacket
(
packet
)
;
}
}
"
LocalDebuggerTransport
instance
'
s
this
.
other
.
hooks
.
onPacket
"
)
)
;
}
}
startBulkSend
:
function
(
{
actor
type
length
}
)
{
this
.
emit
(
"
startBulkSend
"
{
actor
type
length
}
)
;
let
serial
=
this
.
_serial
.
count
+
+
;
dumpn
(
"
Sent
bulk
packet
"
+
serial
+
"
for
actor
"
+
actor
)
;
if
(
!
this
.
other
)
{
return
;
}
let
pipe
=
new
Pipe
(
true
true
0
0
null
)
;
DevToolsUtils
.
executeSoon
(
DevToolsUtils
.
makeInfallible
(
(
)
=
>
{
dumpn
(
"
Received
bulk
packet
"
+
serial
)
;
if
(
!
this
.
other
.
hooks
)
{
return
;
}
let
deferred
=
promise
.
defer
(
)
;
let
packet
=
{
actor
:
actor
type
:
type
length
:
length
copyTo
:
(
output
)
=
>
{
let
copying
=
StreamUtils
.
copyStream
(
pipe
.
inputStream
output
length
)
;
deferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
pipe
.
inputStream
done
:
deferred
}
;
this
.
other
.
emit
(
"
onBulkPacket
"
packet
)
;
this
.
other
.
hooks
.
onBulkPacket
(
packet
)
;
deferred
.
promise
.
then
(
(
)
=
>
pipe
.
inputStream
.
close
(
)
this
.
close
)
;
}
"
LocalDebuggerTransport
instance
'
s
this
.
other
.
hooks
.
onBulkPacket
"
)
)
;
let
sendDeferred
=
promise
.
defer
(
)
;
DevToolsUtils
.
executeSoon
(
(
)
=
>
{
let
copyDeferred
=
promise
.
defer
(
)
;
sendDeferred
.
resolve
(
{
copyFrom
:
(
input
)
=
>
{
let
copying
=
StreamUtils
.
copyStream
(
input
pipe
.
outputStream
length
)
;
copyDeferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
pipe
.
outputStream
done
:
copyDeferred
}
)
;
copyDeferred
.
promise
.
then
(
(
)
=
>
pipe
.
outputStream
.
close
(
)
this
.
close
)
;
}
)
;
return
sendDeferred
.
promise
;
}
close
:
function
(
)
{
this
.
emit
(
"
close
"
)
;
if
(
this
.
other
)
{
let
other
=
this
.
other
;
this
.
other
=
null
;
other
.
close
(
)
;
}
if
(
this
.
hooks
)
{
try
{
this
.
hooks
.
onClosed
(
)
;
}
catch
(
ex
)
{
console
.
error
(
ex
)
;
}
this
.
hooks
=
null
;
}
}
ready
:
function
(
)
{
}
_deepFreeze
:
function
(
object
)
{
Object
.
freeze
(
object
)
;
for
(
let
prop
in
object
)
{
if
(
object
.
hasOwnProperty
(
prop
)
&
&
typeof
object
=
=
=
"
object
"
&
&
!
Object
.
isFrozen
(
object
)
)
{
this
.
_deepFreeze
(
o
[
prop
]
)
;
}
}
}
}
;
exports
.
LocalDebuggerTransport
=
LocalDebuggerTransport
;
function
ChildDebuggerTransport
(
sender
prefix
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_sender
=
sender
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
this
.
_messageName
=
"
debug
:
"
+
prefix
+
"
:
packet
"
;
}
ChildDebuggerTransport
.
prototype
=
{
constructor
:
ChildDebuggerTransport
hooks
:
null
ready
:
function
(
)
{
this
.
_sender
.
addMessageListener
(
this
.
_messageName
this
)
;
}
close
:
function
(
)
{
this
.
_sender
.
removeMessageListener
(
this
.
_messageName
this
)
;
this
.
emit
(
"
onClosed
"
)
;
this
.
hooks
.
onClosed
(
)
;
}
receiveMessage
:
function
(
{
data
}
)
{
this
.
emit
(
"
onPacket
"
data
)
;
this
.
hooks
.
onPacket
(
data
)
;
}
send
:
function
(
packet
)
{
this
.
emit
(
"
send
"
packet
)
;
this
.
_sender
.
sendAsyncMessage
(
this
.
_messageName
packet
)
;
}
startBulkSend
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
send
bulk
data
to
child
processes
.
"
)
;
}
}
;
exports
.
ChildDebuggerTransport
=
ChildDebuggerTransport
;
if
(
typeof
WorkerGlobalScope
=
=
=
'
undefined
'
)
{
(
function
(
)
{
function
WorkerDebuggerTransport
(
dbg
id
)
{
this
.
_dbg
=
dbg
;
this
.
_id
=
id
;
this
.
onMessage
=
this
.
_onMessage
.
bind
(
this
)
;
}
WorkerDebuggerTransport
.
prototype
=
{
constructor
:
WorkerDebuggerTransport
ready
:
function
(
)
{
this
.
_dbg
.
addListener
(
this
)
;
}
close
:
function
(
)
{
this
.
_dbg
.
removeListener
(
this
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
)
;
}
}
send
:
function
(
packet
)
{
this
.
_dbg
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
message
"
id
:
this
.
_id
message
:
packet
}
)
)
;
}
startBulkSend
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
send
bulk
data
from
worker
threads
!
"
)
;
}
_onMessage
:
function
(
message
)
{
let
packet
=
JSON
.
parse
(
message
)
;
if
(
packet
.
type
!
=
=
"
message
"
|
|
packet
.
id
!
=
=
this
.
_id
)
{
return
;
}
if
(
this
.
hooks
)
{
this
.
hooks
.
onPacket
(
packet
.
message
)
;
}
}
}
;
exports
.
WorkerDebuggerTransport
=
WorkerDebuggerTransport
;
}
)
.
call
(
this
)
;
}
else
{
(
function
(
)
{
function
WorkerDebuggerTransport
(
scope
id
)
{
this
.
_scope
=
scope
;
this
.
_id
=
id
;
this
.
_onMessage
=
this
.
_onMessage
.
bind
(
this
)
;
}
WorkerDebuggerTransport
.
prototype
=
{
constructor
:
WorkerDebuggerTransport
ready
:
function
(
)
{
this
.
_scope
.
addEventListener
(
"
message
"
this
.
_onMessage
)
;
}
close
:
function
(
)
{
this
.
_scope
.
removeEventListener
(
"
message
"
this
.
_onMessage
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
)
;
}
}
send
:
function
(
packet
)
{
this
.
_scope
.
postMessage
(
JSON
.
stringify
(
{
type
:
"
message
"
id
:
this
.
_id
message
:
packet
}
)
)
;
}
startBulkSend
:
function
(
)
{
throw
new
Error
(
"
Can
'
t
send
bulk
data
from
worker
threads
!
"
)
;
}
_onMessage
:
function
(
event
)
{
let
packet
=
JSON
.
parse
(
event
.
data
)
;
if
(
packet
.
type
!
=
=
"
message
"
|
|
packet
.
id
!
=
=
this
.
_id
)
{
return
;
}
if
(
this
.
hooks
)
{
this
.
hooks
.
onPacket
(
packet
.
message
)
;
}
}
}
;
exports
.
WorkerDebuggerTransport
=
WorkerDebuggerTransport
;
}
)
.
call
(
this
)
;
}
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Ci
Cc
Cu
Cr
CC
}
=
__webpack_require__
(
28
)
;
const
Services
=
__webpack_require__
(
33
)
;
const
DevToolsUtils
=
__webpack_require__
(
27
)
;
const
{
dumpv
}
=
DevToolsUtils
;
const
EventEmitter
=
__webpack_require__
(
104
)
;
const
promise
=
__webpack_require__
(
39
)
;
const
IOUtil
=
Cc
(
"
mozilla
.
org
/
io
-
util
;
1
"
)
.
getService
(
Ci
.
nsIIOUtil
)
;
const
ScriptableInputStream
=
CC
(
"
mozilla
.
org
/
scriptableinputstream
;
1
"
"
nsIScriptableInputStream
"
"
init
"
)
;
const
BUFFER_SIZE
=
0x8000
;
function
copyStream
(
input
output
length
)
{
let
copier
=
new
StreamCopier
(
input
output
length
)
;
return
copier
.
copy
(
)
;
}
function
StreamCopier
(
input
output
length
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_id
=
StreamCopier
.
_nextId
+
+
;
this
.
input
=
input
;
this
.
baseAsyncOutput
=
output
;
if
(
IOUtil
.
outputStreamIsBuffered
(
output
)
)
{
this
.
output
=
output
;
}
else
{
this
.
output
=
Cc
(
"
mozilla
.
org
/
network
/
buffered
-
output
-
stream
;
1
"
)
.
createInstance
(
Ci
.
nsIBufferedOutputStream
)
;
this
.
output
.
init
(
output
BUFFER_SIZE
)
;
}
this
.
_length
=
length
;
this
.
_amountLeft
=
length
;
this
.
_deferred
=
promise
.
defer
(
)
;
this
.
_copy
=
this
.
_copy
.
bind
(
this
)
;
this
.
_flush
=
this
.
_flush
.
bind
(
this
)
;
this
.
_destroy
=
this
.
_destroy
.
bind
(
this
)
;
this
.
then
=
this
.
_deferred
.
promise
.
then
.
bind
(
this
.
_deferred
.
promise
)
;
this
.
then
(
this
.
_destroy
this
.
_destroy
)
;
this
.
_streamReadyCallback
=
this
.
_copy
;
}
StreamCopier
.
_nextId
=
0
;
StreamCopier
.
prototype
=
{
copy
:
function
(
)
{
Services
.
tm
.
currentThread
.
dispatch
(
(
)
=
>
{
try
{
this
.
_copy
(
)
;
}
catch
(
e
)
{
this
.
_deferred
.
reject
(
e
)
;
}
}
0
)
;
return
this
;
}
_copy
:
function
(
)
{
let
bytesAvailable
=
this
.
input
.
available
(
)
;
let
amountToCopy
=
Math
.
min
(
bytesAvailable
this
.
_amountLeft
)
;
this
.
_debug
(
"
Trying
to
copy
:
"
+
amountToCopy
)
;
let
bytesCopied
;
try
{
bytesCopied
=
this
.
output
.
writeFrom
(
this
.
input
amountToCopy
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
)
{
this
.
_debug
(
"
Base
stream
would
block
will
retry
"
)
;
this
.
_debug
(
"
Waiting
for
output
stream
"
)
;
this
.
baseAsyncOutput
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
return
;
}
else
{
throw
e
;
}
}
this
.
_amountLeft
-
=
bytesCopied
;
this
.
_debug
(
"
Copied
:
"
+
bytesCopied
+
"
Left
:
"
+
this
.
_amountLeft
)
;
this
.
_emitProgress
(
)
;
if
(
this
.
_amountLeft
=
=
=
0
)
{
this
.
_debug
(
"
Copy
done
!
"
)
;
this
.
_flush
(
)
;
return
;
}
this
.
_debug
(
"
Waiting
for
input
stream
"
)
;
this
.
input
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
}
_emitProgress
:
function
(
)
{
this
.
emit
(
"
progress
"
{
bytesSent
:
this
.
_length
-
this
.
_amountLeft
totalBytes
:
this
.
_length
}
)
;
}
_flush
:
function
(
)
{
try
{
this
.
output
.
flush
(
)
;
}
catch
(
e
)
{
if
(
e
.
result
=
=
Cr
.
NS_BASE_STREAM_WOULD_BLOCK
|
|
e
.
result
=
=
Cr
.
NS_ERROR_FAILURE
)
{
this
.
_debug
(
"
Flush
would
block
will
retry
"
)
;
this
.
_streamReadyCallback
=
this
.
_flush
;
this
.
_debug
(
"
Waiting
for
output
stream
"
)
;
this
.
baseAsyncOutput
.
asyncWait
(
this
0
0
Services
.
tm
.
currentThread
)
;
return
;
}
else
{
throw
e
;
}
}
this
.
_deferred
.
resolve
(
)
;
}
_destroy
:
function
(
)
{
this
.
_destroy
=
null
;
this
.
_copy
=
null
;
this
.
_flush
=
null
;
this
.
input
=
null
;
this
.
output
=
null
;
}
onInputStreamReady
:
function
(
)
{
this
.
_streamReadyCallback
(
)
;
}
onOutputStreamReady
:
function
(
)
{
this
.
_streamReadyCallback
(
)
;
}
_debug
:
function
(
msg
)
{
dumpv
(
"
Copier
:
"
+
this
.
_id
+
"
"
+
msg
)
;
}
}
;
function
delimitedRead
(
stream
delimiter
count
)
{
dumpv
(
"
Starting
delimited
read
for
"
+
delimiter
+
"
up
to
"
+
count
+
"
bytes
"
)
;
let
scriptableStream
;
if
(
stream
.
readBytes
)
{
scriptableStream
=
stream
;
}
else
{
scriptableStream
=
new
ScriptableInputStream
(
stream
)
;
}
let
data
=
"
"
;
count
=
Math
.
min
(
count
stream
.
available
(
)
)
;
if
(
count
<
=
0
)
{
return
data
;
}
let
char
;
while
(
char
!
=
=
delimiter
&
&
count
>
0
)
{
char
=
scriptableStream
.
readBytes
(
1
)
;
count
-
-
;
data
+
=
char
;
}
return
data
;
}
module
.
exports
=
{
copyStream
:
copyStream
delimitedRead
:
delimitedRead
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Cc
Ci
Cu
}
=
__webpack_require__
(
28
)
;
const
DevToolsUtils
=
__webpack_require__
(
27
)
;
const
{
dumpn
dumpv
}
=
DevToolsUtils
;
const
StreamUtils
=
__webpack_require__
(
106
)
;
const
promise
=
__webpack_require__
(
39
)
;
const
utf8
=
__webpack_require__
(
108
)
;
const
PACKET_LENGTH_MAX
=
Math
.
pow
(
2
40
)
;
function
Packet
(
transport
)
{
this
.
_transport
=
transport
;
this
.
_length
=
0
;
}
Packet
.
fromHeader
=
function
(
header
transport
)
{
return
JSONPacket
.
fromHeader
(
header
transport
)
|
|
BulkPacket
.
fromHeader
(
header
transport
)
;
}
;
Packet
.
prototype
=
{
get
length
(
)
{
return
this
.
_length
;
}
set
length
(
length
)
{
if
(
length
>
PACKET_LENGTH_MAX
)
{
throw
Error
(
"
Packet
length
"
+
length
+
"
exceeds
the
max
length
of
"
+
PACKET_LENGTH_MAX
)
;
}
this
.
_length
=
length
;
}
destroy
:
function
(
)
{
this
.
_transport
=
null
;
}
}
;
exports
.
Packet
=
Packet
;
function
JSONPacket
(
transport
)
{
Packet
.
call
(
this
transport
)
;
this
.
_data
=
"
"
;
this
.
_done
=
false
;
}
JSONPacket
.
fromHeader
=
function
(
header
transport
)
{
let
match
=
this
.
HEADER_PATTERN
.
exec
(
header
)
;
if
(
!
match
)
{
return
null
;
}
dumpv
(
"
Header
matches
JSON
packet
"
)
;
let
packet
=
new
JSONPacket
(
transport
)
;
packet
.
length
=
+
match
[
1
]
;
return
packet
;
}
;
JSONPacket
.
HEADER_PATTERN
=
/
^
(
\
d
+
)
:
/
;
JSONPacket
.
prototype
=
Object
.
create
(
Packet
.
prototype
)
;
Object
.
defineProperty
(
JSONPacket
.
prototype
"
object
"
{
get
:
function
(
)
{
return
this
.
_object
;
}
set
:
function
(
object
)
{
this
.
_object
=
object
;
let
data
=
JSON
.
stringify
(
object
)
;
this
.
_data
=
data
;
this
.
length
=
this
.
_data
.
length
;
}
}
)
;
JSONPacket
.
prototype
.
read
=
function
(
stream
scriptableStream
)
{
dumpv
(
"
Reading
JSON
packet
"
)
;
this
.
_readData
(
stream
scriptableStream
)
;
if
(
!
this
.
done
)
{
return
;
}
let
json
=
this
.
_data
;
try
{
json
=
utf8
.
decode
(
json
)
;
this
.
_object
=
JSON
.
parse
(
json
)
;
}
catch
(
e
)
{
let
msg
=
"
Error
parsing
incoming
packet
:
"
+
json
+
"
(
"
+
e
+
"
-
"
+
e
.
stack
+
"
)
"
;
if
(
console
.
error
)
{
console
.
error
(
msg
)
;
}
dumpn
(
msg
)
;
return
;
}
this
.
_transport
.
_onJSONObjectReady
(
this
.
_object
)
;
}
JSONPacket
.
prototype
.
_readData
=
function
(
stream
scriptableStream
)
{
if
(
!
scriptableStream
)
{
scriptableStream
=
stream
;
}
if
(
dumpv
.
wantVerbose
)
{
dumpv
(
"
Reading
JSON
data
:
_l
:
"
+
this
.
length
+
"
dL
:
"
+
this
.
_data
.
length
+
"
sA
:
"
+
stream
.
available
(
)
)
;
}
let
bytesToRead
=
Math
.
min
(
this
.
length
-
this
.
_data
.
length
stream
.
available
(
)
)
;
this
.
_data
+
=
scriptableStream
.
readBytes
(
bytesToRead
)
;
this
.
_done
=
this
.
_data
.
length
=
=
=
this
.
length
;
}
JSONPacket
.
prototype
.
write
=
function
(
stream
)
{
dumpv
(
"
Writing
JSON
packet
"
)
;
if
(
this
.
_outgoing
=
=
=
undefined
)
{
this
.
_outgoing
=
this
.
length
+
"
:
"
+
this
.
_data
;
}
let
written
=
stream
.
write
(
this
.
_outgoing
this
.
_outgoing
.
length
)
;
this
.
_outgoing
=
this
.
_outgoing
.
slice
(
written
)
;
this
.
_done
=
!
this
.
_outgoing
.
length
;
}
Object
.
defineProperty
(
JSONPacket
.
prototype
"
done
"
{
get
:
function
(
)
{
return
this
.
_done
;
}
}
)
;
JSONPacket
.
prototype
.
toString
=
function
(
)
{
return
JSON
.
stringify
(
this
.
_object
null
2
)
;
}
exports
.
JSONPacket
=
JSONPacket
;
function
BulkPacket
(
transport
)
{
Packet
.
call
(
this
transport
)
;
this
.
_done
=
false
;
this
.
_readyForWriting
=
promise
.
defer
(
)
;
}
BulkPacket
.
fromHeader
=
function
(
header
transport
)
{
let
match
=
this
.
HEADER_PATTERN
.
exec
(
header
)
;
if
(
!
match
)
{
return
null
;
}
dumpv
(
"
Header
matches
bulk
packet
"
)
;
let
packet
=
new
BulkPacket
(
transport
)
;
packet
.
header
=
{
actor
:
match
[
1
]
type
:
match
[
2
]
length
:
+
match
[
3
]
}
;
return
packet
;
}
;
BulkPacket
.
HEADER_PATTERN
=
/
^
bulk
(
[
^
:
]
+
)
(
[
^
:
]
+
)
(
\
d
+
)
:
/
;
BulkPacket
.
prototype
=
Object
.
create
(
Packet
.
prototype
)
;
BulkPacket
.
prototype
.
read
=
function
(
stream
)
{
dumpv
(
"
Reading
bulk
packet
handing
off
input
stream
"
)
;
this
.
_transport
.
pauseIncoming
(
)
;
let
deferred
=
promise
.
defer
(
)
;
this
.
_transport
.
_onBulkReadReady
(
{
actor
:
this
.
actor
type
:
this
.
type
length
:
this
.
length
copyTo
:
(
output
)
=
>
{
dumpv
(
"
CT
length
:
"
+
this
.
length
)
;
let
copying
=
StreamUtils
.
copyStream
(
stream
output
this
.
length
)
;
deferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
stream
done
:
deferred
}
)
;
deferred
.
promise
.
then
(
(
)
=
>
{
dumpv
(
"
onReadDone
called
ending
bulk
mode
"
)
;
this
.
_done
=
true
;
this
.
_transport
.
resumeIncoming
(
)
;
}
this
.
_transport
.
close
)
;
this
.
read
=
(
)
=
>
{
throw
new
Error
(
"
Tried
to
read
(
)
a
BulkPacket
'
s
stream
multiple
times
.
"
)
;
}
;
}
BulkPacket
.
prototype
.
write
=
function
(
stream
)
{
dumpv
(
"
Writing
bulk
packet
"
)
;
if
(
this
.
_outgoingHeader
=
=
=
undefined
)
{
dumpv
(
"
Serializing
bulk
packet
header
"
)
;
this
.
_outgoingHeader
=
"
bulk
"
+
this
.
actor
+
"
"
+
this
.
type
+
"
"
+
this
.
length
+
"
:
"
;
}
if
(
this
.
_outgoingHeader
.
length
)
{
dumpv
(
"
Writing
bulk
packet
header
"
)
;
let
written
=
stream
.
write
(
this
.
_outgoingHeader
this
.
_outgoingHeader
.
length
)
;
this
.
_outgoingHeader
=
this
.
_outgoingHeader
.
slice
(
written
)
;
return
;
}
dumpv
(
"
Handing
off
output
stream
"
)
;
this
.
_transport
.
pauseOutgoing
(
)
;
let
deferred
=
promise
.
defer
(
)
;
this
.
_readyForWriting
.
resolve
(
{
copyFrom
:
(
input
)
=
>
{
dumpv
(
"
CF
length
:
"
+
this
.
length
)
;
let
copying
=
StreamUtils
.
copyStream
(
input
stream
this
.
length
)
;
deferred
.
resolve
(
copying
)
;
return
copying
;
}
stream
:
stream
done
:
deferred
}
)
;
deferred
.
promise
.
then
(
(
)
=
>
{
dumpv
(
"
onWriteDone
called
ending
bulk
mode
"
)
;
this
.
_done
=
true
;
this
.
_transport
.
resumeOutgoing
(
)
;
}
this
.
_transport
.
close
)
;
this
.
write
=
(
)
=
>
{
throw
new
Error
(
"
Tried
to
write
(
)
a
BulkPacket
'
s
stream
multiple
times
.
"
)
;
}
;
}
Object
.
defineProperty
(
BulkPacket
.
prototype
"
streamReadyForWriting
"
{
get
:
function
(
)
{
return
this
.
_readyForWriting
.
promise
;
}
}
)
;
Object
.
defineProperty
(
BulkPacket
.
prototype
"
header
"
{
get
:
function
(
)
{
return
{
actor
:
this
.
actor
type
:
this
.
type
length
:
this
.
length
}
;
}
set
:
function
(
header
)
{
this
.
actor
=
header
.
actor
;
this
.
type
=
header
.
type
;
this
.
length
=
header
.
length
;
}
}
)
;
Object
.
defineProperty
(
BulkPacket
.
prototype
"
done
"
{
get
:
function
(
)
{
return
this
.
_done
;
}
}
)
;
BulkPacket
.
prototype
.
toString
=
function
(
)
{
return
"
Bulk
:
"
+
JSON
.
stringify
(
this
.
header
null
2
)
;
}
exports
.
BulkPacket
=
BulkPacket
;
function
RawPacket
(
transport
data
)
{
Packet
.
call
(
this
transport
)
;
this
.
_data
=
data
;
this
.
length
=
data
.
length
;
this
.
_done
=
false
;
}
RawPacket
.
prototype
=
Object
.
create
(
Packet
.
prototype
)
;
RawPacket
.
prototype
.
read
=
function
(
stream
)
{
throw
Error
(
"
Not
implmented
.
"
)
;
}
RawPacket
.
prototype
.
write
=
function
(
stream
)
{
let
written
=
stream
.
write
(
this
.
_data
this
.
_data
.
length
)
;
this
.
_data
=
this
.
_data
.
slice
(
written
)
;
this
.
_done
=
!
this
.
_data
.
length
;
}
Object
.
defineProperty
(
RawPacket
.
prototype
"
done
"
{
get
:
function
(
)
{
return
this
.
_done
;
}
}
)
;
exports
.
RawPacket
=
RawPacket
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
module
global
)
{
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
module
.
exports
=
=
freeExports
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
stringFromCharCode
=
String
.
fromCharCode
;
function
ucs2decode
(
string
)
{
var
output
=
[
]
;
var
counter
=
0
;
var
length
=
string
.
length
;
var
value
;
var
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
var
length
=
array
.
length
;
var
index
=
-
1
;
var
value
;
var
output
=
'
'
;
while
(
+
+
index
<
length
)
{
value
=
array
[
index
]
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
}
return
output
;
}
function
checkScalarValue
(
codePoint
)
{
if
(
codePoint
>
=
0xD800
&
&
codePoint
<
=
0xDFFF
)
{
throw
Error
(
'
Lone
surrogate
U
+
'
+
codePoint
.
toString
(
16
)
.
toUpperCase
(
)
+
'
is
not
a
scalar
value
'
)
;
}
}
function
createByte
(
codePoint
shift
)
{
return
stringFromCharCode
(
(
(
codePoint
>
>
shift
)
&
0x3F
)
|
0x80
)
;
}
function
encodeCodePoint
(
codePoint
)
{
if
(
(
codePoint
&
0xFFFFFF80
)
=
=
0
)
{
return
stringFromCharCode
(
codePoint
)
;
}
var
symbol
=
'
'
;
if
(
(
codePoint
&
0xFFFFF800
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
6
)
&
0x1F
)
|
0xC0
)
;
}
else
if
(
(
codePoint
&
0xFFFF0000
)
=
=
0
)
{
checkScalarValue
(
codePoint
)
;
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
12
)
&
0x0F
)
|
0xE0
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
else
if
(
(
codePoint
&
0xFFE00000
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
18
)
&
0x07
)
|
0xF0
)
;
symbol
+
=
createByte
(
codePoint
12
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
symbol
+
=
stringFromCharCode
(
(
codePoint
&
0x3F
)
|
0x80
)
;
return
symbol
;
}
function
utf8encode
(
string
)
{
var
codePoints
=
ucs2decode
(
string
)
;
var
length
=
codePoints
.
length
;
var
index
=
-
1
;
var
codePoint
;
var
byteString
=
'
'
;
while
(
+
+
index
<
length
)
{
codePoint
=
codePoints
[
index
]
;
byteString
+
=
encodeCodePoint
(
codePoint
)
;
}
return
byteString
;
}
function
readContinuationByte
(
)
{
if
(
byteIndex
>
=
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
var
continuationByte
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
continuationByte
&
0xC0
)
=
=
0x80
)
{
return
continuationByte
&
0x3F
;
}
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
function
decodeSymbol
(
)
{
var
byte1
;
var
byte2
;
var
byte3
;
var
byte4
;
var
codePoint
;
if
(
byteIndex
>
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
if
(
byteIndex
=
=
byteCount
)
{
return
false
;
}
byte1
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
byte1
&
0x80
)
=
=
0
)
{
return
byte1
;
}
if
(
(
byte1
&
0xE0
)
=
=
0xC0
)
{
var
byte2
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x1F
)
<
<
6
)
|
byte2
;
if
(
codePoint
>
=
0x80
)
{
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF0
)
=
=
0xE0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
12
)
|
(
byte2
<
<
6
)
|
byte3
;
if
(
codePoint
>
=
0x0800
)
{
checkScalarValue
(
codePoint
)
;
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF8
)
=
=
0xF0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
byte4
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
0x12
)
|
(
byte2
<
<
0x0C
)
|
(
byte3
<
<
0x06
)
|
byte4
;
if
(
codePoint
>
=
0x010000
&
&
codePoint
<
=
0x10FFFF
)
{
return
codePoint
;
}
}
throw
Error
(
'
Invalid
UTF
-
8
detected
'
)
;
}
var
byteArray
;
var
byteCount
;
var
byteIndex
;
function
utf8decode
(
byteString
)
{
byteArray
=
ucs2decode
(
byteString
)
;
byteCount
=
byteArray
.
length
;
byteIndex
=
0
;
var
codePoints
=
[
]
;
var
tmp
;
while
(
(
tmp
=
decodeSymbol
(
)
)
!
=
=
false
)
{
codePoints
.
push
(
tmp
)
;
}
return
ucs2encode
(
codePoints
)
;
}
var
utf8
=
{
'
version
'
:
'
2
.
0
.
0
'
'
encode
'
:
utf8encode
'
decode
'
:
utf8decode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
utf8
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
!
freeExports
.
nodeType
)
{
if
(
freeModule
)
{
freeModule
.
exports
=
utf8
;
}
else
{
var
object
=
{
}
;
var
hasOwnProperty
=
object
.
hasOwnProperty
;
for
(
var
key
in
utf8
)
{
hasOwnProperty
.
call
(
utf8
key
)
&
&
(
freeExports
[
key
]
=
utf8
[
key
]
)
;
}
}
}
else
{
root
.
utf8
=
utf8
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
101
)
(
module
)
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
module
global
)
{
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
module
.
exports
=
=
freeExports
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
stringFromCharCode
=
String
.
fromCharCode
;
function
ucs2decode
(
string
)
{
var
output
=
[
]
;
var
counter
=
0
;
var
length
=
string
.
length
;
var
value
;
var
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
var
length
=
array
.
length
;
var
index
=
-
1
;
var
value
;
var
output
=
'
'
;
while
(
+
+
index
<
length
)
{
value
=
array
[
index
]
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
}
return
output
;
}
function
checkScalarValue
(
codePoint
)
{
if
(
codePoint
>
=
0xD800
&
&
codePoint
<
=
0xDFFF
)
{
throw
Error
(
'
Lone
surrogate
U
+
'
+
codePoint
.
toString
(
16
)
.
toUpperCase
(
)
+
'
is
not
a
scalar
value
'
)
;
}
}
function
createByte
(
codePoint
shift
)
{
return
stringFromCharCode
(
(
(
codePoint
>
>
shift
)
&
0x3F
)
|
0x80
)
;
}
function
encodeCodePoint
(
codePoint
)
{
if
(
(
codePoint
&
0xFFFFFF80
)
=
=
0
)
{
return
stringFromCharCode
(
codePoint
)
;
}
var
symbol
=
'
'
;
if
(
(
codePoint
&
0xFFFFF800
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
6
)
&
0x1F
)
|
0xC0
)
;
}
else
if
(
(
codePoint
&
0xFFFF0000
)
=
=
0
)
{
checkScalarValue
(
codePoint
)
;
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
12
)
&
0x0F
)
|
0xE0
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
else
if
(
(
codePoint
&
0xFFE00000
)
=
=
0
)
{
symbol
=
stringFromCharCode
(
(
(
codePoint
>
>
18
)
&
0x07
)
|
0xF0
)
;
symbol
+
=
createByte
(
codePoint
12
)
;
symbol
+
=
createByte
(
codePoint
6
)
;
}
symbol
+
=
stringFromCharCode
(
(
codePoint
&
0x3F
)
|
0x80
)
;
return
symbol
;
}
function
utf8encode
(
string
)
{
var
codePoints
=
ucs2decode
(
string
)
;
var
length
=
codePoints
.
length
;
var
index
=
-
1
;
var
codePoint
;
var
byteString
=
'
'
;
while
(
+
+
index
<
length
)
{
codePoint
=
codePoints
[
index
]
;
byteString
+
=
encodeCodePoint
(
codePoint
)
;
}
return
byteString
;
}
function
readContinuationByte
(
)
{
if
(
byteIndex
>
=
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
var
continuationByte
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
continuationByte
&
0xC0
)
=
=
0x80
)
{
return
continuationByte
&
0x3F
;
}
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
function
decodeSymbol
(
)
{
var
byte1
;
var
byte2
;
var
byte3
;
var
byte4
;
var
codePoint
;
if
(
byteIndex
>
byteCount
)
{
throw
Error
(
'
Invalid
byte
index
'
)
;
}
if
(
byteIndex
=
=
byteCount
)
{
return
false
;
}
byte1
=
byteArray
[
byteIndex
]
&
0xFF
;
byteIndex
+
+
;
if
(
(
byte1
&
0x80
)
=
=
0
)
{
return
byte1
;
}
if
(
(
byte1
&
0xE0
)
=
=
0xC0
)
{
var
byte2
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x1F
)
<
<
6
)
|
byte2
;
if
(
codePoint
>
=
0x80
)
{
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF0
)
=
=
0xE0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
12
)
|
(
byte2
<
<
6
)
|
byte3
;
if
(
codePoint
>
=
0x0800
)
{
checkScalarValue
(
codePoint
)
;
return
codePoint
;
}
else
{
throw
Error
(
'
Invalid
continuation
byte
'
)
;
}
}
if
(
(
byte1
&
0xF8
)
=
=
0xF0
)
{
byte2
=
readContinuationByte
(
)
;
byte3
=
readContinuationByte
(
)
;
byte4
=
readContinuationByte
(
)
;
codePoint
=
(
(
byte1
&
0x0F
)
<
<
0x12
)
|
(
byte2
<
<
0x0C
)
|
(
byte3
<
<
0x06
)
|
byte4
;
if
(
codePoint
>
=
0x010000
&
&
codePoint
<
=
0x10FFFF
)
{
return
codePoint
;
}
}
throw
Error
(
'
Invalid
UTF
-
8
detected
'
)
;
}
var
byteArray
;
var
byteCount
;
var
byteIndex
;
function
utf8decode
(
byteString
)
{
byteArray
=
ucs2decode
(
byteString
)
;
byteCount
=
byteArray
.
length
;
byteIndex
=
0
;
var
codePoints
=
[
]
;
var
tmp
;
while
(
(
tmp
=
decodeSymbol
(
)
)
!
=
=
false
)
{
codePoints
.
push
(
tmp
)
;
}
return
ucs2encode
(
codePoints
)
;
}
var
utf8
=
{
'
version
'
:
'
2
.
0
.
0
'
'
encode
'
:
utf8encode
'
decode
'
:
utf8decode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
utf8
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
!
freeExports
.
nodeType
)
{
if
(
freeModule
)
{
freeModule
.
exports
=
utf8
;
}
else
{
var
object
=
{
}
;
var
hasOwnProperty
=
object
.
hasOwnProperty
;
for
(
var
key
in
utf8
)
{
hasOwnProperty
.
call
(
utf8
key
)
&
&
(
freeExports
[
key
]
=
utf8
[
key
]
)
;
}
}
}
else
{
root
.
utf8
=
utf8
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
101
)
(
module
)
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
EventEmitter
=
__webpack_require__
(
111
)
;
function
WebSocketDebuggerTransport
(
socket
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
active
=
false
;
this
.
hooks
=
null
;
this
.
socket
=
socket
;
}
WebSocketDebuggerTransport
.
prototype
=
{
ready
(
)
{
if
(
this
.
active
)
{
return
;
}
this
.
socket
.
addEventListener
(
"
message
"
this
)
;
this
.
socket
.
addEventListener
(
"
close
"
this
)
;
this
.
active
=
true
;
}
send
(
object
)
{
this
.
emit
(
"
send
"
object
)
;
if
(
this
.
socket
)
{
this
.
socket
.
send
(
JSON
.
stringify
(
object
)
)
;
}
}
startBulkSend
(
)
{
throw
new
Error
(
"
Bulk
send
is
not
supported
by
WebSocket
transport
"
)
;
}
close
(
)
{
this
.
emit
(
"
onClosed
"
)
;
this
.
active
=
false
;
this
.
socket
.
removeEventListener
(
"
message
"
this
)
;
this
.
socket
.
removeEventListener
(
"
close
"
this
)
;
this
.
socket
.
close
(
)
;
this
.
socket
=
null
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onClosed
(
)
;
this
.
hooks
=
null
;
}
}
handleEvent
(
event
)
{
switch
(
event
.
type
)
{
case
"
message
"
:
this
.
onMessage
(
event
)
;
break
;
case
"
close
"
:
this
.
close
(
)
;
break
;
}
}
onMessage
(
{
data
}
)
{
if
(
typeof
data
!
=
=
"
string
"
)
{
throw
new
Error
(
"
Binary
messages
are
not
supported
by
WebSocket
transport
"
)
;
}
let
object
=
JSON
.
parse
(
data
)
;
this
.
emit
(
"
onPacket
"
object
)
;
if
(
this
.
hooks
)
{
this
.
hooks
.
onPacket
(
object
)
;
}
}
}
;
module
.
exports
=
WebSocketDebuggerTransport
;
}
function
(
module
exports
__webpack_require__
)
{
var
EventEmitter
=
function
(
)
{
}
;
var
defer
=
__webpack_require__
(
112
)
;
EventEmitter
.
decorate
=
function
(
objectToDecorate
)
{
var
emitter
=
new
EventEmitter
(
)
;
objectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
objectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
objectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
objectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
this
.
_eventEmitterListeners
=
new
Map
(
)
;
}
if
(
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
this
.
_eventEmitterListeners
.
set
(
event
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
event
)
.
push
(
listener
)
;
}
once
(
event
listener
)
{
var
_this
=
this
;
var
deferred
=
defer
(
)
;
var
handler
=
function
(
_
first
)
{
for
(
var
_len
=
arguments
.
length
rest
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
rest
[
_key
-
2
]
=
arguments
[
_key
]
;
}
_this
.
off
(
event
handler
)
;
if
(
listener
)
{
listener
.
apply
(
null
[
event
first
]
.
concat
(
rest
)
)
;
}
deferred
.
resolve
(
first
)
;
}
;
handler
.
_originalListener
=
listener
;
this
.
on
(
event
handler
)
;
return
deferred
.
promise
;
}
off
(
event
listener
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
return
;
}
var
listeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
event
listeners
.
filter
(
l
=
>
{
return
l
!
=
=
listener
&
&
l
.
_originalListener
!
=
=
listener
;
}
)
)
;
}
}
emit
(
event
)
{
var
_this2
=
this
_arguments
=
arguments
;
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
event
)
)
{
return
;
}
var
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
event
)
;
var
_loop
=
function
(
listener
)
{
if
(
!
_this2
.
_eventEmitterListeners
)
{
return
"
break
"
;
}
if
(
originalListeners
=
=
=
_this2
.
_eventEmitterListeners
.
get
(
event
)
|
|
_this2
.
_eventEmitterListeners
.
get
(
event
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
.
apply
(
null
_arguments
)
;
}
catch
(
ex
)
{
var
msg
=
ex
+
"
:
"
+
ex
.
stack
;
console
.
error
(
msg
)
;
}
}
}
;
for
(
var
listener
of
this
.
_eventEmitterListeners
.
get
(
event
)
)
{
var
_ret
=
_loop
(
listener
)
;
if
(
_ret
=
=
=
"
break
"
)
break
;
}
}
}
;
module
.
exports
=
EventEmitter
;
}
function
(
module
exports
)
{
module
.
exports
=
function
defer
(
)
{
var
resolve
=
void
0
reject
=
void
0
;
var
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Ci
Cu
}
=
__webpack_require__
(
28
)
;
const
promise
=
__webpack_require__
(
39
)
;
const
EventEmitter
=
__webpack_require__
(
104
)
;
const
{
Services
}
=
__webpack_require__
(
33
)
;
const
{
DebuggerClient
}
=
__webpack_require__
(
99
)
;
const
targets
=
new
WeakMap
(
)
;
const
promiseTargets
=
new
WeakMap
(
)
;
exports
.
TargetFactory
=
{
forTab
:
function
(
tab
)
{
let
target
=
targets
.
get
(
tab
)
;
if
(
target
=
=
null
)
{
target
=
new
TabTarget
(
tab
)
;
targets
.
set
(
tab
target
)
;
}
return
target
;
}
forRemoteTab
:
function
(
options
)
{
let
targetPromise
=
promiseTargets
.
get
(
options
)
;
if
(
targetPromise
=
=
null
)
{
let
target
=
new
TabTarget
(
options
)
;
targetPromise
=
target
.
makeRemote
(
)
.
then
(
(
)
=
>
target
)
;
promiseTargets
.
set
(
options
targetPromise
)
;
}
return
targetPromise
;
}
forWorker
:
function
(
workerClient
)
{
let
target
=
targets
.
get
(
workerClient
)
;
if
(
target
=
=
null
)
{
target
=
new
WorkerTarget
(
workerClient
)
;
targets
.
set
(
workerClient
target
)
;
}
return
target
;
}
isKnownTab
:
function
(
tab
)
{
return
targets
.
has
(
tab
)
;
}
}
;
function
TabTarget
(
tab
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
destroy
=
this
.
destroy
.
bind
(
this
)
;
this
.
_handleThreadState
=
this
.
_handleThreadState
.
bind
(
this
)
;
this
.
on
(
"
thread
-
resumed
"
this
.
_handleThreadState
)
;
this
.
on
(
"
thread
-
paused
"
this
.
_handleThreadState
)
;
this
.
activeTab
=
this
.
activeConsole
=
null
;
if
(
tab
&
&
!
[
"
client
"
"
form
"
"
chrome
"
]
.
every
(
tab
.
hasOwnProperty
tab
)
)
{
this
.
_tab
=
tab
;
this
.
_setupListeners
(
)
;
}
else
{
this
.
_form
=
tab
.
form
;
this
.
_client
=
tab
.
client
;
this
.
_chrome
=
tab
.
chrome
;
}
if
(
typeof
tab
.
isTabActor
=
=
"
boolean
"
)
{
this
.
_isTabActor
=
tab
.
isTabActor
;
}
else
{
this
.
_isTabActor
=
true
;
}
}
TabTarget
.
prototype
=
{
_webProgressListener
:
null
getActorDescription
:
function
(
actorName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
getActorDescription
(
)
can
only
be
called
on
"
+
"
remote
tabs
.
"
)
;
}
let
deferred
=
promise
.
defer
(
)
;
if
(
this
.
_protocolDescription
&
&
this
.
_protocolDescription
.
types
[
actorName
]
)
{
deferred
.
resolve
(
this
.
_protocolDescription
.
types
[
actorName
]
)
;
}
else
{
this
.
client
.
mainRoot
.
protocolDescription
(
description
=
>
{
this
.
_protocolDescription
=
description
;
deferred
.
resolve
(
description
.
types
[
actorName
]
)
;
}
)
;
}
return
deferred
.
promise
;
}
hasActor
:
function
(
actorName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
hasActor
(
)
can
only
be
called
on
remote
"
+
"
tabs
.
"
)
;
}
if
(
this
.
form
)
{
return
!
!
this
.
form
[
actorName
+
"
Actor
"
]
;
}
return
false
;
}
actorHasMethod
:
function
(
actorName
methodName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
actorHasMethod
(
)
can
only
be
called
on
"
+
"
remote
tabs
.
"
)
;
}
return
this
.
getActorDescription
(
actorName
)
.
then
(
desc
=
>
{
if
(
desc
&
&
desc
.
methods
)
{
return
!
!
desc
.
methods
.
find
(
method
=
>
method
.
name
=
=
=
methodName
)
;
}
return
false
;
}
)
;
}
getTrait
:
function
(
traitName
)
{
if
(
!
this
.
client
)
{
throw
new
Error
(
"
TabTarget
#
getTrait
(
)
can
only
be
called
on
remote
"
+
"
tabs
.
"
)
;
}
if
(
this
.
form
.
traits
&
&
traitName
in
this
.
form
.
traits
)
{
return
this
.
form
.
traits
[
traitName
]
;
}
return
this
.
client
.
traits
[
traitName
]
;
}
get
tab
(
)
{
return
this
.
_tab
;
}
get
form
(
)
{
return
this
.
_form
;
}
get
root
(
)
{
if
(
!
this
.
_root
)
{
this
.
_root
=
this
.
_getRoot
(
)
;
}
return
this
.
_root
;
}
_getRoot
:
function
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
client
.
listTabs
(
response
=
>
{
if
(
response
.
error
)
{
reject
(
new
Error
(
response
.
error
+
"
:
"
+
response
.
message
)
)
;
return
;
}
resolve
(
response
)
;
}
)
;
}
)
;
}
get
client
(
)
{
return
this
.
_client
;
}
get
chrome
(
)
{
return
this
.
_chrome
;
}
get
isTabActor
(
)
{
return
this
.
_isTabActor
;
}
get
window
(
)
{
if
(
this
.
_tab
&
&
this
.
_tab
.
linkedBrowser
)
{
return
this
.
_tab
.
linkedBrowser
.
contentWindow
;
}
return
null
;
}
get
name
(
)
{
if
(
this
.
_tab
&
&
this
.
_tab
.
linkedBrowser
.
contentDocument
)
{
return
this
.
_tab
.
linkedBrowser
.
contentDocument
.
title
;
}
if
(
this
.
isAddon
)
{
return
this
.
_form
.
name
;
}
return
this
.
_form
.
title
;
}
get
url
(
)
{
return
this
.
_tab
?
this
.
_tab
.
linkedBrowser
.
currentURI
.
spec
:
this
.
_form
.
url
;
}
get
isRemote
(
)
{
return
!
this
.
isLocalTab
;
}
get
isAddon
(
)
{
return
!
!
(
this
.
_form
&
&
this
.
_form
.
actor
&
&
this
.
_form
.
actor
.
match
(
/
conn
\
d
+
\
.
addon
\
d
+
/
)
)
;
}
get
isLocalTab
(
)
{
return
!
!
this
.
_tab
;
}
get
isMultiProcess
(
)
{
return
!
this
.
window
;
}
get
isThreadPaused
(
)
{
return
!
!
this
.
_isThreadPaused
;
}
makeRemote
:
function
(
)
{
if
(
this
.
_remote
)
{
return
this
.
_remote
.
promise
;
}
this
.
_remote
=
promise
.
defer
(
)
;
if
(
this
.
isLocalTab
)
{
if
(
!
DebuggerServer
.
initialized
)
{
DebuggerServer
.
init
(
)
;
DebuggerServer
.
addBrowserActors
(
)
;
}
this
.
_client
=
new
DebuggerClient
(
DebuggerServer
.
connectPipe
(
)
)
;
this
.
_chrome
=
false
;
}
this
.
_setupRemoteListeners
(
)
;
let
attachTab
=
(
)
=
>
{
this
.
_client
.
attachTab
(
this
.
_form
.
actor
(
response
tabClient
)
=
>
{
if
(
!
tabClient
)
{
this
.
_remote
.
reject
(
"
Unable
to
attach
to
the
tab
"
)
;
return
;
}
this
.
activeTab
=
tabClient
;
this
.
threadActor
=
response
.
threadActor
;
attachConsole
(
)
;
}
)
;
}
;
let
onConsoleAttached
=
(
response
consoleClient
)
=
>
{
if
(
!
consoleClient
)
{
this
.
_remote
.
reject
(
"
Unable
to
attach
to
the
console
"
)
;
return
;
}
this
.
activeConsole
=
consoleClient
;
this
.
_remote
.
resolve
(
null
)
;
}
;
let
attachConsole
=
(
)
=
>
{
this
.
_client
.
attachConsole
(
this
.
_form
.
consoleActor
[
"
NetworkActivity
"
]
onConsoleAttached
)
;
}
;
if
(
this
.
isLocalTab
)
{
this
.
_client
.
connect
(
(
)
=
>
{
this
.
_client
.
getTab
(
{
tab
:
this
.
tab
}
)
.
then
(
response
=
>
{
this
.
_form
=
response
.
tab
;
attachTab
(
)
;
}
)
;
}
)
;
}
else
if
(
this
.
isTabActor
)
{
attachTab
(
)
;
}
else
{
attachConsole
(
)
;
}
return
this
.
_remote
.
promise
;
}
_setupListeners
:
function
(
)
{
this
.
_webProgressListener
=
new
TabWebProgressListener
(
this
)
;
this
.
tab
.
linkedBrowser
.
addProgressListener
(
this
.
_webProgressListener
)
;
this
.
tab
.
addEventListener
(
"
TabClose
"
this
)
;
this
.
tab
.
parentNode
.
addEventListener
(
"
TabSelect
"
this
)
;
this
.
tab
.
ownerDocument
.
defaultView
.
addEventListener
(
"
unload
"
this
)
;
}
_teardownListeners
:
function
(
)
{
if
(
this
.
_webProgressListener
)
{
this
.
_webProgressListener
.
destroy
(
)
;
}
this
.
_tab
.
ownerDocument
.
defaultView
.
removeEventListener
(
"
unload
"
this
)
;
this
.
_tab
.
removeEventListener
(
"
TabClose
"
this
)
;
this
.
_tab
.
parentNode
.
removeEventListener
(
"
TabSelect
"
this
)
;
}
_setupRemoteListeners
:
function
(
)
{
this
.
client
.
addListener
(
"
closed
"
this
.
destroy
)
;
this
.
_onTabDetached
=
(
aType
aPacket
)
=
>
{
if
(
aPacket
.
from
=
=
this
.
_form
.
actor
)
{
this
.
destroy
(
)
;
}
}
;
this
.
client
.
addListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
_onTabNavigated
=
(
aType
aPacket
)
=
>
{
let
event
=
Object
.
create
(
null
)
;
event
.
url
=
aPacket
.
url
;
event
.
title
=
aPacket
.
title
;
event
.
nativeConsoleAPI
=
aPacket
.
nativeConsoleAPI
;
event
.
isFrameSwitching
=
aPacket
.
isFrameSwitching
;
if
(
aPacket
.
state
=
=
"
start
"
)
{
event
.
_navPayload
=
this
.
_navRequest
;
this
.
emit
(
"
will
-
navigate
"
event
)
;
this
.
_navRequest
=
null
;
}
else
{
event
.
_navPayload
=
this
.
_navWindow
;
this
.
emit
(
"
navigate
"
event
)
;
this
.
_navWindow
=
null
;
}
}
;
this
.
client
.
addListener
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
_onFrameUpdate
=
(
aType
aPacket
)
=
>
{
this
.
emit
(
"
frame
-
update
"
aPacket
)
;
}
;
this
.
client
.
addListener
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
}
_teardownRemoteListeners
:
function
(
)
{
this
.
client
.
removeListener
(
"
closed
"
this
.
destroy
)
;
this
.
client
.
removeListener
(
"
tabNavigated
"
this
.
_onTabNavigated
)
;
this
.
client
.
removeListener
(
"
tabDetached
"
this
.
_onTabDetached
)
;
this
.
client
.
removeListener
(
"
frameUpdate
"
this
.
_onFrameUpdate
)
;
}
handleEvent
:
function
(
event
)
{
switch
(
event
.
type
)
{
case
"
TabClose
"
:
case
"
unload
"
:
this
.
destroy
(
)
;
break
;
case
"
TabSelect
"
:
if
(
this
.
tab
.
selected
)
{
this
.
emit
(
"
visible
"
event
)
;
}
else
{
this
.
emit
(
"
hidden
"
event
)
;
}
break
;
}
}
_handleThreadState
:
function
(
event
)
{
switch
(
event
)
{
case
"
thread
-
resumed
"
:
this
.
_isThreadPaused
=
false
;
break
;
case
"
thread
-
paused
"
:
this
.
_isThreadPaused
=
true
;
break
;
}
}
destroy
:
function
(
)
{
if
(
this
.
_destroyer
)
{
return
this
.
_destroyer
.
promise
;
}
this
.
_destroyer
=
promise
.
defer
(
)
;
this
.
emit
(
"
close
"
)
;
this
.
off
(
"
thread
-
resumed
"
this
.
_handleThreadState
)
;
this
.
off
(
"
thread
-
paused
"
this
.
_handleThreadState
)
;
if
(
this
.
_tab
)
{
this
.
_teardownListeners
(
)
;
}
let
cleanupAndResolve
=
(
)
=
>
{
this
.
_cleanup
(
)
;
this
.
_destroyer
.
resolve
(
null
)
;
}
;
if
(
this
.
_tab
&
&
!
this
.
_client
)
{
cleanupAndResolve
(
)
;
}
else
if
(
this
.
_client
)
{
this
.
_teardownRemoteListeners
(
)
;
if
(
this
.
isLocalTab
)
{
this
.
_client
.
close
(
cleanupAndResolve
)
;
}
else
if
(
this
.
activeTab
)
{
this
.
activeTab
.
detach
(
)
;
cleanupAndResolve
(
)
;
}
else
{
cleanupAndResolve
(
)
;
}
}
return
this
.
_destroyer
.
promise
;
}
_cleanup
:
function
(
)
{
if
(
this
.
_tab
)
{
targets
.
delete
(
this
.
_tab
)
;
}
else
{
promiseTargets
.
delete
(
this
.
_form
)
;
}
this
.
activeTab
=
null
;
this
.
activeConsole
=
null
;
this
.
_client
=
null
;
this
.
_tab
=
null
;
this
.
_form
=
null
;
this
.
_remote
=
null
;
}
toString
:
function
(
)
{
let
id
=
this
.
_tab
?
this
.
_tab
:
(
this
.
_form
&
&
this
.
_form
.
actor
)
;
return
TabTarget
:
{
id
}
;
}
}
;
function
WorkerTarget
(
workerClient
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
_workerClient
=
workerClient
;
}
WorkerTarget
.
prototype
=
{
destroy
:
function
(
)
{
}
get
isRemote
(
)
{
return
true
;
}
get
isTabActor
(
)
{
return
true
;
}
get
url
(
)
{
return
this
.
_workerClient
.
url
;
}
get
isWorkerTarget
(
)
{
return
true
;
}
get
form
(
)
{
return
{
consoleActor
:
this
.
_workerClient
.
consoleActor
}
;
}
get
activeTab
(
)
{
return
this
.
_workerClient
;
}
get
client
(
)
{
return
this
.
_workerClient
.
client
;
}
destroy
:
function
(
)
{
}
hasActor
:
function
(
name
)
{
return
false
;
}
getTrait
:
function
(
)
{
return
undefined
;
}
makeRemote
:
function
(
)
{
return
Promise
.
resolve
(
)
;
}
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
t
=
__webpack_require__
(
115
)
;
var
Tab
=
t
.
struct
(
{
title
:
t
.
String
url
:
t
.
String
id
:
t
.
String
tab
:
t
.
Object
browser
:
t
.
enums
.
of
(
[
"
chrome
"
"
firefox
"
]
)
}
"
Tab
"
)
;
var
SourceText
=
t
.
struct
(
{
text
:
t
.
String
contentType
:
t
.
String
}
)
;
var
Source
=
t
.
struct
(
{
id
:
t
.
String
url
:
t
.
union
(
[
t
.
String
t
.
Nil
]
)
isPrettyPrinted
:
t
.
Boolean
sourceMapURL
:
t
.
union
(
[
t
.
String
t
.
Nil
]
)
}
"
Source
"
)
;
var
Location
=
t
.
struct
(
{
sourceId
:
t
.
String
line
:
t
.
Number
column
:
t
.
union
(
[
t
.
Number
t
.
Nil
]
)
}
"
Location
"
)
;
var
Breakpoint
=
t
.
struct
(
{
id
:
t
.
String
loading
:
t
.
Boolean
disabled
:
t
.
Boolean
text
:
t
.
String
condition
:
t
.
union
(
[
t
.
String
t
.
Nil
]
)
}
)
;
var
BreakpointResult
=
t
.
struct
(
{
id
:
t
.
String
actualLocation
:
Location
}
)
;
var
Frame
=
t
.
struct
(
{
id
:
t
.
String
displayName
:
t
.
String
location
:
Location
this
:
t
.
union
(
[
t
.
Object
t
.
Nil
]
)
scope
:
t
.
union
(
[
t
.
Object
t
.
Nil
]
)
}
"
Frame
"
)
;
module
.
exports
=
{
Tab
Source
SourceText
Location
Breakpoint
BreakpointResult
Frame
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
t
=
__webpack_require__
(
116
)
;
t
.
Any
=
__webpack_require__
(
122
)
;
t
.
Array
=
__webpack_require__
(
130
)
;
t
.
Boolean
=
__webpack_require__
(
131
)
;
t
.
Date
=
__webpack_require__
(
133
)
;
t
.
Error
=
__webpack_require__
(
134
)
;
t
.
Function
=
__webpack_require__
(
135
)
;
t
.
Nil
=
__webpack_require__
(
136
)
;
t
.
Number
=
__webpack_require__
(
137
)
;
t
.
Integer
=
__webpack_require__
(
139
)
;
t
.
IntegerT
=
t
.
Integer
;
t
.
Object
=
__webpack_require__
(
145
)
;
t
.
RegExp
=
__webpack_require__
(
146
)
;
t
.
String
=
__webpack_require__
(
147
)
;
t
.
Type
=
__webpack_require__
(
148
)
;
t
.
TypeT
=
t
.
Type
;
t
.
Arr
=
t
.
Array
;
t
.
Bool
=
t
.
Boolean
;
t
.
Dat
=
t
.
Date
;
t
.
Err
=
t
.
Error
;
t
.
Func
=
t
.
Function
;
t
.
Num
=
t
.
Number
;
t
.
Obj
=
t
.
Object
;
t
.
Re
=
t
.
RegExp
;
t
.
Str
=
t
.
String
;
t
.
dict
=
__webpack_require__
(
149
)
;
t
.
declare
=
__webpack_require__
(
150
)
;
t
.
enums
=
__webpack_require__
(
152
)
;
t
.
irreducible
=
__webpack_require__
(
123
)
;
t
.
list
=
__webpack_require__
(
153
)
;
t
.
maybe
=
__webpack_require__
(
154
)
;
t
.
refinement
=
__webpack_require__
(
140
)
;
t
.
struct
=
__webpack_require__
(
156
)
;
t
.
tuple
=
__webpack_require__
(
162
)
;
t
.
union
=
__webpack_require__
(
163
)
;
t
.
func
=
__webpack_require__
(
165
)
;
t
.
intersection
=
__webpack_require__
(
166
)
;
t
.
subtype
=
t
.
refinement
;
t
.
inter
=
__webpack_require__
(
167
)
;
t
[
'
interface
'
]
=
t
.
inter
;
t
.
assert
=
t
;
t
.
update
=
__webpack_require__
(
168
)
;
t
.
mixin
=
__webpack_require__
(
151
)
;
t
.
isType
=
__webpack_require__
(
127
)
;
t
.
is
=
__webpack_require__
(
144
)
;
t
.
getTypeName
=
__webpack_require__
(
126
)
;
t
.
match
=
__webpack_require__
(
169
)
;
module
.
exports
=
t
;
}
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
117
)
;
var
isNil
=
__webpack_require__
(
118
)
;
var
fail
=
__webpack_require__
(
119
)
;
var
stringify
=
__webpack_require__
(
120
)
;
function
assert
(
guard
message
)
{
if
(
guard
!
=
=
true
)
{
if
(
isFunction
(
message
)
)
{
message
=
message
(
)
;
}
else
if
(
isNil
(
message
)
)
{
message
=
'
Assert
failed
(
turn
on
"
Pause
on
exceptions
"
in
your
Source
panel
)
'
;
}
assert
.
fail
(
message
)
;
}
}
assert
.
fail
=
fail
;
assert
.
stringify
=
stringify
;
module
.
exports
=
assert
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isFunction
(
x
)
{
return
typeof
x
=
=
=
'
function
'
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isNil
(
x
)
{
return
x
=
=
=
null
|
|
x
=
=
=
void
0
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
fail
(
message
)
{
throw
new
TypeError
(
'
[
tcomb
]
'
+
message
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
getFunctionName
=
__webpack_require__
(
121
)
;
function
replacer
(
key
value
)
{
if
(
typeof
value
=
=
=
'
function
'
)
{
return
getFunctionName
(
value
)
;
}
return
value
;
}
module
.
exports
=
function
stringify
(
x
)
{
try
{
return
JSON
.
stringify
(
x
replacer
2
)
;
}
catch
(
e
)
{
return
String
(
x
)
;
}
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
getFunctionName
(
f
)
{
return
f
.
displayName
|
|
f
.
name
|
|
'
<
function
'
+
f
.
length
+
'
>
'
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
module
.
exports
=
irreducible
(
'
Any
'
function
(
)
{
return
true
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isString
=
__webpack_require__
(
124
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
forbidNewOperator
=
__webpack_require__
(
125
)
;
module
.
exports
=
function
irreducible
(
name
predicate
)
{
if
(
false
)
{
assert
(
isString
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
irreducible
(
name
predicate
)
(
expected
a
string
)
'
;
}
)
;
assert
(
isFunction
(
predicate
)
'
Invalid
argument
predicate
'
+
assert
.
stringify
(
predicate
)
+
'
supplied
to
irreducible
(
name
predicate
)
(
expected
a
function
)
'
)
;
}
function
Irreducible
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Irreducible
)
;
path
=
path
|
|
[
name
]
;
assert
(
predicate
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
Irreducible
.
meta
=
{
kind
:
'
irreducible
'
name
:
name
predicate
:
predicate
identity
:
true
}
;
Irreducible
.
displayName
=
name
;
Irreducible
.
is
=
predicate
;
return
Irreducible
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isString
(
x
)
{
return
typeof
x
=
=
=
'
string
'
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
module
.
exports
=
function
forbidNewOperator
(
x
type
)
{
assert
(
!
(
x
instanceof
type
)
function
(
)
{
return
'
Cannot
use
the
new
operator
to
instantiate
the
type
'
+
getTypeName
(
type
)
;
}
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
var
getFunctionName
=
__webpack_require__
(
121
)
;
module
.
exports
=
function
getTypeName
(
constructor
)
{
if
(
isType
(
constructor
)
)
{
return
constructor
.
displayName
;
}
return
getFunctionName
(
constructor
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
117
)
;
var
isObject
=
__webpack_require__
(
128
)
;
module
.
exports
=
function
isType
(
x
)
{
return
isFunction
(
x
)
&
&
isObject
(
x
.
meta
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isNil
=
__webpack_require__
(
118
)
;
var
isArray
=
__webpack_require__
(
129
)
;
module
.
exports
=
function
isObject
(
x
)
{
return
!
isNil
(
x
)
&
&
typeof
x
=
=
=
'
object
'
&
&
!
isArray
(
x
)
;
}
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isArray
(
x
)
{
return
x
instanceof
Array
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isArray
=
__webpack_require__
(
129
)
;
module
.
exports
=
irreducible
(
'
Array
'
isArray
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isBoolean
=
__webpack_require__
(
132
)
;
module
.
exports
=
irreducible
(
'
Boolean
'
isBoolean
)
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isBoolean
(
x
)
{
return
x
=
=
=
true
|
|
x
=
=
=
false
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
module
.
exports
=
irreducible
(
'
Date
'
function
(
x
)
{
return
x
instanceof
Date
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
module
.
exports
=
irreducible
(
'
Error
'
function
(
x
)
{
return
x
instanceof
Error
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
module
.
exports
=
irreducible
(
'
Function
'
isFunction
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isNil
=
__webpack_require__
(
118
)
;
module
.
exports
=
irreducible
(
'
Nil
'
isNil
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isNumber
=
__webpack_require__
(
138
)
;
module
.
exports
=
irreducible
(
'
Number
'
isNumber
)
;
}
function
(
module
exports
)
{
module
.
exports
=
function
isNumber
(
x
)
{
return
typeof
x
=
=
=
'
number
'
&
&
isFinite
(
x
)
&
&
!
isNaN
(
x
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
refinement
=
__webpack_require__
(
140
)
;
var
Number
=
__webpack_require__
(
137
)
;
module
.
exports
=
refinement
(
Number
function
(
x
)
{
return
x
%
1
=
=
=
0
;
}
'
Integer
'
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
forbidNewOperator
=
__webpack_require__
(
125
)
;
var
isIdentity
=
__webpack_require__
(
142
)
;
var
create
=
__webpack_require__
(
143
)
;
var
is
=
__webpack_require__
(
144
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
getFunctionName
=
__webpack_require__
(
121
)
;
function
getDefaultName
(
type
predicate
)
{
return
'
{
'
+
getTypeName
(
type
)
+
'
|
'
+
getFunctionName
(
predicate
)
+
'
}
'
;
}
function
refinement
(
type
predicate
name
)
{
if
(
false
)
{
assert
(
isFunction
(
type
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
type
)
+
'
supplied
to
refinement
(
type
predicate
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isFunction
(
predicate
)
function
(
)
{
return
'
Invalid
argument
predicate
supplied
to
refinement
(
type
predicate
[
name
]
)
combinator
(
expected
a
function
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
refinement
(
type
predicate
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
type
predicate
)
;
var
identity
=
isIdentity
(
type
)
;
function
Refinement
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Refinement
)
;
path
=
path
|
|
[
displayName
]
;
}
var
x
=
create
(
type
value
path
)
;
if
(
false
)
{
assert
(
predicate
(
x
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
x
;
}
Refinement
.
meta
=
{
kind
:
'
subtype
'
type
:
type
predicate
:
predicate
name
:
name
identity
:
identity
}
;
Refinement
.
displayName
=
displayName
;
Refinement
.
is
=
function
(
x
)
{
return
is
(
x
type
)
&
&
predicate
(
x
)
;
}
;
Refinement
.
update
=
function
(
instance
patch
)
{
return
Refinement
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Refinement
;
}
refinement
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
refinement
;
}
function
(
module
exports
__webpack_require__
)
{
var
isNil
=
__webpack_require__
(
118
)
;
var
isString
=
__webpack_require__
(
124
)
;
module
.
exports
=
function
isTypeName
(
name
)
{
return
isNil
(
name
)
|
|
isString
(
name
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
Boolean
=
__webpack_require__
(
131
)
;
var
isType
=
__webpack_require__
(
127
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
module
.
exports
=
function
isIdentity
(
type
)
{
if
(
isType
(
type
)
)
{
if
(
false
)
{
assert
(
Boolean
.
is
(
type
.
meta
.
identity
)
function
(
)
{
return
'
Invalid
meta
identity
'
+
assert
.
stringify
(
type
.
meta
.
identity
)
+
'
supplied
to
type
'
+
getTypeName
(
type
)
;
}
)
;
}
return
type
.
meta
.
identity
;
}
return
true
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
var
getFunctionName
=
__webpack_require__
(
121
)
;
var
assert
=
__webpack_require__
(
116
)
;
var
stringify
=
__webpack_require__
(
120
)
;
module
.
exports
=
function
create
(
type
value
path
)
{
if
(
isType
(
type
)
)
{
return
type
.
meta
.
kind
=
=
=
'
struct
'
?
new
type
(
value
path
)
:
type
(
value
path
)
;
}
if
(
false
)
{
path
=
path
|
|
[
getFunctionName
(
type
)
]
;
assert
(
value
instanceof
type
function
(
)
{
return
'
Invalid
value
'
+
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
module
.
exports
=
function
is
(
x
type
)
{
if
(
isType
(
type
)
)
{
return
type
.
is
(
x
)
;
}
return
x
instanceof
type
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isObject
=
__webpack_require__
(
128
)
;
module
.
exports
=
irreducible
(
'
Object
'
isObject
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
module
.
exports
=
irreducible
(
'
RegExp
'
function
(
x
)
{
return
x
instanceof
RegExp
;
}
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isString
=
__webpack_require__
(
124
)
;
module
.
exports
=
irreducible
(
'
String
'
isString
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
irreducible
=
__webpack_require__
(
123
)
;
var
isType
=
__webpack_require__
(
127
)
;
module
.
exports
=
irreducible
(
'
Type
'
isType
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
isIdentity
=
__webpack_require__
(
142
)
;
var
isObject
=
__webpack_require__
(
128
)
;
var
create
=
__webpack_require__
(
143
)
;
var
is
=
__webpack_require__
(
144
)
;
function
getDefaultName
(
domain
codomain
)
{
return
'
{
[
key
:
'
+
getTypeName
(
domain
)
+
'
]
:
'
+
getTypeName
(
codomain
)
+
'
}
'
;
}
function
dict
(
domain
codomain
name
)
{
if
(
false
)
{
assert
(
isFunction
(
domain
)
function
(
)
{
return
'
Invalid
argument
domain
'
+
assert
.
stringify
(
domain
)
+
'
supplied
to
dict
(
domain
codomain
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isFunction
(
codomain
)
function
(
)
{
return
'
Invalid
argument
codomain
'
+
assert
.
stringify
(
codomain
)
+
'
supplied
to
dict
(
domain
codomain
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
dict
(
domain
codomain
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
domain
codomain
)
;
var
domainNameCache
=
getTypeName
(
domain
)
;
var
codomainNameCache
=
getTypeName
(
codomain
)
;
var
identity
=
isIdentity
(
domain
)
&
&
isIdentity
(
codomain
)
;
function
Dict
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isObject
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
var
idempotent
=
true
;
var
ret
=
{
}
;
for
(
var
k
in
value
)
{
if
(
value
.
hasOwnProperty
(
k
)
)
{
k
=
create
(
domain
k
(
false
?
path
.
concat
(
domainNameCache
)
:
null
)
)
;
var
actual
=
value
[
k
]
;
var
instance
=
create
(
codomain
actual
(
false
?
path
.
concat
(
k
+
'
:
'
+
codomainNameCache
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
[
k
]
=
instance
;
}
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
Dict
.
meta
=
{
kind
:
'
dict
'
domain
:
domain
codomain
:
codomain
name
:
name
identity
:
identity
}
;
Dict
.
displayName
=
displayName
;
Dict
.
is
=
function
(
x
)
{
if
(
!
isObject
(
x
)
)
{
return
false
;
}
for
(
var
k
in
x
)
{
if
(
x
.
hasOwnProperty
(
k
)
)
{
if
(
!
is
(
k
domain
)
|
|
!
is
(
x
[
k
]
codomain
)
)
{
return
false
;
}
}
}
return
true
;
}
;
Dict
.
update
=
function
(
instance
patch
)
{
return
Dict
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Dict
;
}
dict
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
dict
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isType
=
__webpack_require__
(
127
)
;
var
isNil
=
__webpack_require__
(
118
)
;
var
mixin
=
__webpack_require__
(
151
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
nextDeclareUniqueId
=
1
;
module
.
exports
=
function
declare
(
name
)
{
if
(
false
)
{
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
name
+
'
supplied
to
declare
(
[
name
]
)
(
expected
a
string
)
'
;
}
)
;
}
var
type
;
function
Declare
(
value
path
)
{
if
(
false
)
{
assert
(
!
isNil
(
type
)
function
(
)
{
return
'
Type
declared
but
not
defined
don
\
'
t
forget
to
call
.
define
on
every
declared
type
'
;
}
)
;
}
return
type
(
value
path
)
;
}
Declare
.
define
=
function
(
spec
)
{
if
(
false
)
{
assert
(
isType
(
spec
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
spec
)
+
'
supplied
to
define
(
type
)
(
expected
a
type
)
'
;
}
)
;
assert
(
isNil
(
type
)
function
(
)
{
return
'
Declare
.
define
(
type
)
can
only
be
invoked
once
'
;
}
)
;
assert
(
isNil
(
spec
.
meta
.
name
)
&
&
Object
.
keys
(
spec
.
prototype
)
.
length
=
=
=
0
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
spec
)
+
'
supplied
to
define
(
type
)
(
expected
a
fresh
unnamed
type
)
'
;
}
)
;
}
type
=
spec
;
mixin
(
Declare
type
true
)
;
if
(
name
)
{
type
.
displayName
=
Declare
.
displayName
=
name
;
Declare
.
meta
.
name
=
name
;
}
Declare
.
meta
.
identity
=
false
;
Declare
.
prototype
=
type
.
prototype
;
return
Declare
;
}
;
Declare
.
displayName
=
name
|
|
(
getTypeName
(
Declare
)
+
"
"
+
nextDeclareUniqueId
+
+
)
;
Declare
.
meta
=
{
identity
:
false
}
;
Declare
.
prototype
=
null
;
return
Declare
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isNil
=
__webpack_require__
(
118
)
;
var
assert
=
__webpack_require__
(
116
)
;
module
.
exports
=
function
mixin
(
target
source
overwrite
)
{
if
(
isNil
(
source
)
)
{
return
target
;
}
for
(
var
k
in
source
)
{
if
(
source
.
hasOwnProperty
(
k
)
)
{
if
(
overwrite
!
=
=
true
)
{
if
(
false
)
{
assert
(
!
target
.
hasOwnProperty
(
k
)
|
|
target
[
k
]
=
=
=
source
[
k
]
function
(
)
{
return
'
Invalid
call
to
mixin
(
target
source
[
overwrite
]
)
:
cannot
overwrite
property
"
'
+
k
+
'
"
of
target
object
'
;
}
)
;
}
}
target
[
k
]
=
source
[
k
]
;
}
}
return
target
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
forbidNewOperator
=
__webpack_require__
(
125
)
;
var
isString
=
__webpack_require__
(
124
)
;
var
isObject
=
__webpack_require__
(
128
)
;
function
getDefaultName
(
map
)
{
return
Object
.
keys
(
map
)
.
map
(
function
(
k
)
{
return
assert
.
stringify
(
k
)
;
}
)
.
join
(
'
|
'
)
;
}
function
enums
(
map
name
)
{
if
(
false
)
{
assert
(
isObject
(
map
)
function
(
)
{
return
'
Invalid
argument
map
'
+
assert
.
stringify
(
map
)
+
'
supplied
to
enums
(
map
[
name
]
)
combinator
(
expected
a
dictionary
of
String
-
>
String
|
Number
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
enums
(
map
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
map
)
;
function
Enums
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Enums
)
;
path
=
path
|
|
[
displayName
]
;
assert
(
Enums
.
is
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
one
of
'
+
assert
.
stringify
(
Object
.
keys
(
map
)
)
+
'
)
'
;
}
)
;
}
return
value
;
}
Enums
.
meta
=
{
kind
:
'
enums
'
map
:
map
name
:
name
identity
:
true
}
;
Enums
.
displayName
=
displayName
;
Enums
.
is
=
function
(
x
)
{
return
map
.
hasOwnProperty
(
x
)
;
}
;
return
Enums
;
}
enums
.
of
=
function
(
keys
name
)
{
keys
=
isString
(
keys
)
?
keys
.
split
(
'
'
)
:
keys
;
var
value
=
{
}
;
keys
.
forEach
(
function
(
k
)
{
value
[
k
]
=
k
;
}
)
;
return
enums
(
value
name
)
;
}
;
enums
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
enums
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
isIdentity
=
__webpack_require__
(
142
)
;
var
create
=
__webpack_require__
(
143
)
;
var
is
=
__webpack_require__
(
144
)
;
var
isArray
=
__webpack_require__
(
129
)
;
function
getDefaultName
(
type
)
{
return
'
Array
<
'
+
getTypeName
(
type
)
+
'
>
'
;
}
function
list
(
type
name
)
{
if
(
false
)
{
assert
(
isFunction
(
type
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
type
)
+
'
supplied
to
list
(
type
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
list
(
type
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
type
)
;
var
typeNameCache
=
getTypeName
(
type
)
;
var
identity
=
isIdentity
(
type
)
;
function
List
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isArray
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
an
array
of
'
+
typeNameCache
+
'
)
'
;
}
)
;
}
var
idempotent
=
true
;
var
ret
=
[
]
;
for
(
var
i
=
0
len
=
value
.
length
;
i
<
len
;
i
+
+
)
{
var
actual
=
value
[
i
]
;
var
instance
=
create
(
type
actual
(
false
?
path
.
concat
(
i
+
'
:
'
+
typeNameCache
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
.
push
(
instance
)
;
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
List
.
meta
=
{
kind
:
'
list
'
type
:
type
name
:
name
identity
:
identity
}
;
List
.
displayName
=
displayName
;
List
.
is
=
function
(
x
)
{
return
isArray
(
x
)
&
&
x
.
every
(
function
(
e
)
{
return
is
(
e
type
)
;
}
)
;
}
;
List
.
update
=
function
(
instance
patch
)
{
return
List
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
List
;
}
list
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
list
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
isMaybe
=
__webpack_require__
(
155
)
;
var
isIdentity
=
__webpack_require__
(
142
)
;
var
Any
=
__webpack_require__
(
122
)
;
var
create
=
__webpack_require__
(
143
)
;
var
Nil
=
__webpack_require__
(
136
)
;
var
forbidNewOperator
=
__webpack_require__
(
125
)
;
var
is
=
__webpack_require__
(
144
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
function
getDefaultName
(
type
)
{
return
'
?
'
+
getTypeName
(
type
)
;
}
function
maybe
(
type
name
)
{
if
(
isMaybe
(
type
)
|
|
type
=
=
=
Any
|
|
type
=
=
=
Nil
)
{
return
type
;
}
if
(
false
)
{
assert
(
isFunction
(
type
)
function
(
)
{
return
'
Invalid
argument
type
'
+
assert
.
stringify
(
type
)
+
'
supplied
to
maybe
(
type
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
maybe
(
type
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
type
)
;
function
Maybe
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Maybe
)
;
}
return
Nil
.
is
(
value
)
?
value
:
create
(
type
value
path
)
;
}
Maybe
.
meta
=
{
kind
:
'
maybe
'
type
:
type
name
:
name
identity
:
isIdentity
(
type
)
}
;
Maybe
.
displayName
=
displayName
;
Maybe
.
is
=
function
(
x
)
{
return
Nil
.
is
(
x
)
|
|
is
(
x
type
)
;
}
;
return
Maybe
;
}
maybe
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
maybe
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
module
.
exports
=
function
isMaybe
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
maybe
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
String
=
__webpack_require__
(
147
)
;
var
Function
=
__webpack_require__
(
135
)
;
var
isBoolean
=
__webpack_require__
(
132
)
;
var
isObject
=
__webpack_require__
(
128
)
;
var
isNil
=
__webpack_require__
(
118
)
;
var
create
=
__webpack_require__
(
143
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
dict
=
__webpack_require__
(
149
)
;
var
getDefaultInterfaceName
=
__webpack_require__
(
157
)
;
var
extend
=
__webpack_require__
(
158
)
;
function
getDefaultName
(
props
)
{
return
'
Struct
'
+
getDefaultInterfaceName
(
props
)
;
}
function
extendStruct
(
mixins
name
)
{
return
extend
(
struct
mixins
name
)
;
}
function
getOptions
(
options
)
{
if
(
!
isObject
(
options
)
)
{
options
=
isNil
(
options
)
?
{
}
:
{
name
:
options
}
;
}
if
(
!
options
.
hasOwnProperty
(
'
strict
'
)
)
{
options
.
strict
=
struct
.
strict
;
}
if
(
!
options
.
hasOwnProperty
(
'
defaultProps
'
)
)
{
options
.
defaultProps
=
{
}
;
}
return
options
;
}
function
struct
(
props
options
)
{
options
=
getOptions
(
options
)
;
var
name
=
options
.
name
;
var
strict
=
options
.
strict
;
var
defaultProps
=
options
.
defaultProps
;
if
(
false
)
{
assert
(
dict
(
String
Function
)
.
is
(
props
)
function
(
)
{
return
'
Invalid
argument
props
'
+
assert
.
stringify
(
props
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
dictionary
String
-
>
Type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
assert
(
isBoolean
(
strict
)
function
(
)
{
return
'
Invalid
argument
strict
'
+
assert
.
stringify
(
strict
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
boolean
)
'
;
}
)
;
assert
(
isObject
(
defaultProps
)
function
(
)
{
return
'
Invalid
argument
defaultProps
'
+
assert
.
stringify
(
defaultProps
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
an
object
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
props
)
;
function
Struct
(
value
path
)
{
if
(
Struct
.
is
(
value
)
)
{
return
value
;
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isObject
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
an
object
)
'
;
}
)
;
if
(
strict
)
{
for
(
k
in
value
)
{
if
(
value
.
hasOwnProperty
(
k
)
)
{
assert
(
props
.
hasOwnProperty
(
k
)
function
(
)
{
return
'
Invalid
additional
prop
"
'
+
k
+
'
"
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
}
}
}
if
(
!
(
this
instanceof
Struct
)
)
{
return
new
Struct
(
value
path
)
;
}
for
(
var
k
in
props
)
{
if
(
props
.
hasOwnProperty
(
k
)
)
{
var
expected
=
props
[
k
]
;
var
actual
=
value
[
k
]
;
if
(
actual
=
=
=
undefined
)
{
actual
=
defaultProps
[
k
]
;
}
this
[
k
]
=
create
(
expected
actual
(
false
?
path
.
concat
(
k
+
'
:
'
+
getTypeName
(
expected
)
)
:
null
)
)
;
}
}
if
(
false
)
{
Object
.
freeze
(
this
)
;
}
}
Struct
.
meta
=
{
kind
:
'
struct
'
props
:
props
name
:
name
identity
:
false
strict
:
strict
defaultProps
:
defaultProps
}
;
Struct
.
displayName
=
displayName
;
Struct
.
is
=
function
(
x
)
{
return
x
instanceof
Struct
;
}
;
Struct
.
update
=
function
(
instance
patch
)
{
return
new
Struct
(
assert
.
update
(
instance
patch
)
)
;
}
;
Struct
.
extend
=
function
(
xs
name
)
{
return
extendStruct
(
[
Struct
]
.
concat
(
xs
)
name
)
;
}
;
return
Struct
;
}
struct
.
strict
=
false
;
struct
.
getOptions
=
getOptions
;
struct
.
getDefaultName
=
getDefaultName
;
struct
.
extend
=
extendStruct
;
module
.
exports
=
struct
;
}
function
(
module
exports
__webpack_require__
)
{
var
getTypeName
=
__webpack_require__
(
126
)
;
function
getDefaultInterfaceName
(
props
)
{
return
'
{
'
+
Object
.
keys
(
props
)
.
map
(
function
(
prop
)
{
return
prop
+
'
:
'
+
getTypeName
(
props
[
prop
]
)
;
}
)
.
join
(
'
'
)
+
'
}
'
;
}
module
.
exports
=
getDefaultInterfaceName
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
isArray
=
__webpack_require__
(
129
)
;
var
mixin
=
__webpack_require__
(
151
)
;
var
isStruct
=
__webpack_require__
(
159
)
;
var
isInterface
=
__webpack_require__
(
160
)
;
var
isObject
=
__webpack_require__
(
128
)
;
var
refinement
=
__webpack_require__
(
140
)
;
var
decompose
=
__webpack_require__
(
161
)
;
function
compose
(
predicates
unrefinedType
)
{
return
predicates
.
reduce
(
function
(
type
predicate
)
{
return
refinement
(
type
predicate
)
;
}
unrefinedType
)
;
}
function
getProps
(
type
)
{
return
isObject
(
type
)
?
type
:
type
.
meta
.
props
;
}
function
getDefaultProps
(
type
)
{
return
isObject
(
type
)
?
null
:
type
.
meta
.
defaultProps
;
}
function
pushAll
(
arr
elements
)
{
Array
.
prototype
.
push
.
apply
(
arr
elements
)
;
}
function
extend
(
combinator
mixins
options
)
{
if
(
false
)
{
assert
(
isFunction
(
combinator
)
function
(
)
{
return
'
Invalid
argument
combinator
supplied
to
extend
(
combinator
mixins
options
)
expected
a
function
'
;
}
)
;
assert
(
isArray
(
mixins
)
function
(
)
{
return
'
Invalid
argument
mixins
supplied
to
extend
(
combinator
mixins
options
)
expected
an
array
'
;
}
)
;
}
var
props
=
{
}
;
var
prototype
=
{
}
;
var
predicates
=
[
]
;
var
defaultProps
=
{
}
;
mixins
.
forEach
(
function
(
x
i
)
{
var
decomposition
=
decompose
(
x
)
;
var
unrefinedType
=
decomposition
.
unrefinedType
;
if
(
false
)
{
assert
(
isObject
(
unrefinedType
)
|
|
isStruct
(
unrefinedType
)
|
|
isInterface
(
unrefinedType
)
function
(
)
{
return
'
Invalid
argument
mixins
[
'
+
i
+
'
]
supplied
to
extend
(
combinator
mixins
options
)
expected
an
object
struct
interface
or
a
refinement
(
of
struct
or
interface
)
'
;
}
)
;
}
pushAll
(
predicates
decomposition
.
predicates
)
;
mixin
(
props
getProps
(
unrefinedType
)
)
;
mixin
(
prototype
unrefinedType
.
prototype
)
;
mixin
(
defaultProps
getDefaultProps
(
unrefinedType
)
)
;
}
)
;
options
=
combinator
.
getOptions
(
options
)
;
mixin
(
options
.
defaultProps
defaultProps
)
;
var
result
=
compose
(
predicates
combinator
(
props
options
)
)
;
mixin
(
result
.
prototype
prototype
)
;
return
result
;
}
module
.
exports
=
extend
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
module
.
exports
=
function
isStruct
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
struct
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
module
.
exports
=
function
isInterface
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
interface
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
function
isRefinement
(
type
)
{
return
isType
(
type
)
&
&
type
.
meta
.
kind
=
=
=
'
subtype
'
;
}
function
getPredicates
(
type
)
{
return
isRefinement
(
type
)
?
[
type
.
meta
.
predicate
]
.
concat
(
getPredicates
(
type
.
meta
.
type
)
)
:
[
]
;
}
function
getUnrefinedType
(
type
)
{
return
isRefinement
(
type
)
?
getUnrefinedType
(
type
.
meta
.
type
)
:
type
;
}
function
decompose
(
type
)
{
return
{
predicates
:
getPredicates
(
type
)
unrefinedType
:
getUnrefinedType
(
type
)
}
;
}
module
.
exports
=
decompose
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
isIdentity
=
__webpack_require__
(
142
)
;
var
isArray
=
__webpack_require__
(
129
)
;
var
create
=
__webpack_require__
(
143
)
;
var
is
=
__webpack_require__
(
144
)
;
function
getDefaultName
(
types
)
{
return
'
[
'
+
types
.
map
(
getTypeName
)
.
join
(
'
'
)
+
'
]
'
;
}
function
tuple
(
types
name
)
{
if
(
false
)
{
assert
(
isArray
(
types
)
&
&
types
.
every
(
isFunction
)
function
(
)
{
return
'
Invalid
argument
types
'
+
assert
.
stringify
(
types
)
+
'
supplied
to
tuple
(
types
[
name
]
)
combinator
(
expected
an
array
of
types
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
tuple
(
types
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
types
)
;
var
identity
=
types
.
every
(
isIdentity
)
;
function
Tuple
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
isArray
(
value
)
&
&
value
.
length
=
=
=
types
.
length
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
expected
an
array
of
length
'
+
types
.
length
+
'
)
'
;
}
)
;
}
var
idempotent
=
true
;
var
ret
=
[
]
;
for
(
var
i
=
0
len
=
types
.
length
;
i
<
len
;
i
+
+
)
{
var
expected
=
types
[
i
]
;
var
actual
=
value
[
i
]
;
var
instance
=
create
(
expected
actual
(
false
?
path
.
concat
(
i
+
'
:
'
+
getTypeName
(
expected
)
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
.
push
(
instance
)
;
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
Tuple
.
meta
=
{
kind
:
'
tuple
'
types
:
types
name
:
name
identity
:
identity
}
;
Tuple
.
displayName
=
displayName
;
Tuple
.
is
=
function
(
x
)
{
return
isArray
(
x
)
&
&
x
.
length
=
=
=
types
.
length
&
&
types
.
every
(
function
(
type
i
)
{
return
is
(
x
[
i
]
type
)
;
}
)
;
}
;
Tuple
.
update
=
function
(
instance
patch
)
{
return
Tuple
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Tuple
;
}
tuple
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
tuple
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
isIdentity
=
__webpack_require__
(
142
)
;
var
isArray
=
__webpack_require__
(
129
)
;
var
create
=
__webpack_require__
(
143
)
;
var
is
=
__webpack_require__
(
144
)
;
var
forbidNewOperator
=
__webpack_require__
(
125
)
;
var
isType
=
__webpack_require__
(
127
)
;
var
isUnion
=
__webpack_require__
(
164
)
;
var
isNil
=
__webpack_require__
(
118
)
;
function
getDefaultName
(
types
)
{
return
types
.
map
(
getTypeName
)
.
join
(
'
|
'
)
;
}
function
union
(
types
name
)
{
if
(
false
)
{
assert
(
isArray
(
types
)
&
&
types
.
every
(
isFunction
)
&
&
types
.
length
>
=
2
function
(
)
{
return
'
Invalid
argument
types
'
+
assert
.
stringify
(
types
)
+
'
supplied
to
union
(
types
[
name
]
)
combinator
(
expected
an
array
of
at
least
2
types
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
union
(
types
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
types
)
;
var
identity
=
types
.
every
(
isIdentity
)
;
function
Union
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
var
type
=
Union
.
dispatch
(
value
)
;
if
(
!
type
&
&
Union
.
is
(
value
)
)
{
return
value
;
}
if
(
false
)
{
forbidNewOperator
(
this
Union
)
;
path
=
path
|
|
[
displayName
]
;
assert
(
isType
(
type
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
+
'
(
no
constructor
returned
by
dispatch
)
'
;
}
)
;
path
[
path
.
length
-
1
]
+
=
'
(
'
+
getTypeName
(
type
)
+
'
)
'
;
}
return
create
(
type
value
path
)
;
}
Union
.
meta
=
{
kind
:
'
union
'
types
:
types
name
:
name
identity
:
identity
}
;
Union
.
displayName
=
displayName
;
Union
.
is
=
function
(
x
)
{
return
types
.
some
(
function
(
type
)
{
return
is
(
x
type
)
;
}
)
;
}
;
Union
.
dispatch
=
function
(
x
)
{
for
(
var
i
=
0
len
=
types
.
length
;
i
<
len
;
i
+
+
)
{
var
type
=
types
[
i
]
;
if
(
isUnion
(
type
)
)
{
var
t
=
type
.
dispatch
(
x
)
;
if
(
!
isNil
(
t
)
)
{
return
t
;
}
}
else
if
(
is
(
x
type
)
)
{
return
type
;
}
}
}
;
Union
.
update
=
function
(
instance
patch
)
{
return
Union
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Union
;
}
union
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
union
;
}
function
(
module
exports
__webpack_require__
)
{
var
isType
=
__webpack_require__
(
127
)
;
module
.
exports
=
function
isUnion
(
x
)
{
return
isType
(
x
)
&
&
(
x
.
meta
.
kind
=
=
=
'
union
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
FunctionType
=
__webpack_require__
(
135
)
;
var
isArray
=
__webpack_require__
(
129
)
;
var
list
=
__webpack_require__
(
153
)
;
var
isObject
=
__webpack_require__
(
128
)
;
var
create
=
__webpack_require__
(
143
)
;
var
isNil
=
__webpack_require__
(
118
)
;
var
isBoolean
=
__webpack_require__
(
132
)
;
var
tuple
=
__webpack_require__
(
162
)
;
var
getFunctionName
=
__webpack_require__
(
121
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
isType
=
__webpack_require__
(
127
)
;
function
getDefaultName
(
domain
codomain
)
{
return
'
(
'
+
domain
.
map
(
getTypeName
)
.
join
(
'
'
)
+
'
)
=
>
'
+
getTypeName
(
codomain
)
;
}
function
isInstrumented
(
f
)
{
return
FunctionType
.
is
(
f
)
&
&
isObject
(
f
.
instrumentation
)
;
}
function
getOptionalArgumentsIndex
(
types
)
{
var
end
=
types
.
length
;
var
areAllMaybes
=
false
;
for
(
var
i
=
end
-
1
;
i
>
=
0
;
i
-
-
)
{
var
type
=
types
[
i
]
;
if
(
!
isType
(
type
)
|
|
type
.
meta
.
kind
!
=
=
'
maybe
'
)
{
return
(
i
+
1
)
;
}
else
{
areAllMaybes
=
true
;
}
}
return
areAllMaybes
?
0
:
end
;
}
function
func
(
domain
codomain
name
)
{
domain
=
isArray
(
domain
)
?
domain
:
[
domain
]
;
if
(
false
)
{
assert
(
list
(
FunctionType
)
.
is
(
domain
)
function
(
)
{
return
'
Invalid
argument
domain
'
+
assert
.
stringify
(
domain
)
+
'
supplied
to
func
(
domain
codomain
[
name
]
)
combinator
(
expected
an
array
of
types
)
'
;
}
)
;
assert
(
FunctionType
.
is
(
codomain
)
function
(
)
{
return
'
Invalid
argument
codomain
'
+
assert
.
stringify
(
codomain
)
+
'
supplied
to
func
(
domain
codomain
[
name
]
)
combinator
(
expected
a
type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
func
(
domain
codomain
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
domain
codomain
)
;
var
domainLength
=
domain
.
length
;
var
optionalArgumentsIndex
=
getOptionalArgumentsIndex
(
domain
)
;
function
FuncType
(
value
path
)
{
if
(
!
isInstrumented
(
value
)
)
{
return
FuncType
.
of
(
value
)
;
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
FuncType
.
is
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
FuncType
.
meta
=
{
kind
:
'
func
'
domain
:
domain
codomain
:
codomain
name
:
name
identity
:
true
}
;
FuncType
.
displayName
=
displayName
;
FuncType
.
is
=
function
(
x
)
{
return
isInstrumented
(
x
)
&
&
x
.
instrumentation
.
domain
.
length
=
=
=
domainLength
&
&
x
.
instrumentation
.
domain
.
every
(
function
(
type
i
)
{
return
type
=
=
=
domain
[
i
]
;
}
)
&
&
x
.
instrumentation
.
codomain
=
=
=
codomain
;
}
;
FuncType
.
of
=
function
(
f
curried
)
{
if
(
false
)
{
assert
(
FunctionType
.
is
(
f
)
function
(
)
{
return
'
Invalid
argument
f
supplied
to
func
.
of
'
+
displayName
+
'
(
expected
a
function
)
'
;
}
)
;
assert
(
isNil
(
curried
)
|
|
isBoolean
(
curried
)
function
(
)
{
return
'
Invalid
argument
curried
'
+
assert
.
stringify
(
curried
)
+
'
supplied
to
func
.
of
'
+
displayName
+
'
(
expected
a
boolean
)
'
;
}
)
;
}
if
(
FuncType
.
is
(
f
)
)
{
return
f
;
}
function
fn
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
var
argsLength
=
args
.
length
;
if
(
false
)
{
var
tupleLength
=
curried
?
argsLength
:
Math
.
max
(
argsLength
optionalArgumentsIndex
)
;
tuple
(
domain
.
slice
(
0
tupleLength
)
'
arguments
of
function
'
+
displayName
)
(
args
)
;
}
if
(
curried
&
&
argsLength
<
domainLength
)
{
if
(
false
)
{
assert
(
argsLength
>
0
'
Invalid
arguments
.
length
=
0
for
curried
function
'
+
displayName
)
;
}
var
g
=
Function
.
prototype
.
bind
.
apply
(
f
[
this
]
.
concat
(
args
)
)
;
var
newDomain
=
func
(
domain
.
slice
(
argsLength
)
codomain
)
;
return
newDomain
.
of
(
g
true
)
;
}
else
{
return
create
(
codomain
f
.
apply
(
this
args
)
)
;
}
}
fn
.
instrumentation
=
{
domain
:
domain
codomain
:
codomain
f
:
f
}
;
fn
.
displayName
=
getFunctionName
(
f
)
;
return
fn
;
}
;
return
FuncType
;
}
func
.
getDefaultName
=
getDefaultName
;
func
.
getOptionalArgumentsIndex
=
getOptionalArgumentsIndex
;
module
.
exports
=
func
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
isArray
=
__webpack_require__
(
129
)
;
var
forbidNewOperator
=
__webpack_require__
(
142
)
;
var
is
=
__webpack_require__
(
144
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
function
getDefaultName
(
types
)
{
return
types
.
map
(
getTypeName
)
.
join
(
'
&
'
)
;
}
function
intersection
(
types
name
)
{
if
(
false
)
{
assert
(
isArray
(
types
)
&
&
types
.
every
(
isFunction
)
&
&
types
.
length
>
=
2
function
(
)
{
return
'
Invalid
argument
types
'
+
assert
.
stringify
(
types
)
+
'
supplied
to
intersection
(
types
[
name
]
)
combinator
(
expected
an
array
of
at
least
2
types
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
intersection
(
types
[
name
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultName
(
types
)
;
function
Intersection
(
value
path
)
{
if
(
false
)
{
forbidNewOperator
(
this
Intersection
)
;
path
=
path
|
|
[
displayName
]
;
assert
(
Intersection
.
is
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
assert
.
stringify
(
value
)
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
return
value
;
}
Intersection
.
meta
=
{
kind
:
'
intersection
'
types
:
types
name
:
name
identity
:
true
}
;
Intersection
.
displayName
=
displayName
;
Intersection
.
is
=
function
(
x
)
{
return
types
.
every
(
function
(
type
)
{
return
is
(
x
type
)
;
}
)
;
}
;
Intersection
.
update
=
function
(
instance
patch
)
{
return
Intersection
(
assert
.
update
(
instance
patch
)
)
;
}
;
return
Intersection
;
}
intersection
.
getDefaultName
=
getDefaultName
;
module
.
exports
=
intersection
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isTypeName
=
__webpack_require__
(
141
)
;
var
String
=
__webpack_require__
(
147
)
;
var
Function
=
__webpack_require__
(
135
)
;
var
isBoolean
=
__webpack_require__
(
132
)
;
var
isObject
=
__webpack_require__
(
128
)
;
var
isNil
=
__webpack_require__
(
118
)
;
var
create
=
__webpack_require__
(
143
)
;
var
getTypeName
=
__webpack_require__
(
126
)
;
var
dict
=
__webpack_require__
(
149
)
;
var
getDefaultInterfaceName
=
__webpack_require__
(
157
)
;
var
isIdentity
=
__webpack_require__
(
142
)
;
var
is
=
__webpack_require__
(
144
)
;
var
extend
=
__webpack_require__
(
158
)
;
function
extendInterface
(
mixins
name
)
{
return
extend
(
inter
mixins
name
)
;
}
function
getOptions
(
options
)
{
if
(
!
isObject
(
options
)
)
{
options
=
isNil
(
options
)
?
{
}
:
{
name
:
options
}
;
}
if
(
!
options
.
hasOwnProperty
(
'
strict
'
)
)
{
options
.
strict
=
inter
.
strict
;
}
return
options
;
}
function
inter
(
props
options
)
{
options
=
getOptions
(
options
)
;
var
name
=
options
.
name
;
var
strict
=
options
.
strict
;
if
(
false
)
{
assert
(
dict
(
String
Function
)
.
is
(
props
)
function
(
)
{
return
'
Invalid
argument
props
'
+
assert
.
stringify
(
props
)
+
'
supplied
to
interface
(
props
[
options
]
)
combinator
(
expected
a
dictionary
String
-
>
Type
)
'
;
}
)
;
assert
(
isTypeName
(
name
)
function
(
)
{
return
'
Invalid
argument
name
'
+
assert
.
stringify
(
name
)
+
'
supplied
to
interface
(
props
[
options
]
)
combinator
(
expected
a
string
)
'
;
}
)
;
assert
(
isBoolean
(
strict
)
function
(
)
{
return
'
Invalid
argument
strict
'
+
assert
.
stringify
(
strict
)
+
'
supplied
to
struct
(
props
[
options
]
)
combinator
(
expected
a
boolean
)
'
;
}
)
;
}
var
displayName
=
name
|
|
getDefaultInterfaceName
(
props
)
;
var
identity
=
Object
.
keys
(
props
)
.
map
(
function
(
prop
)
{
return
props
[
prop
]
;
}
)
.
every
(
isIdentity
)
;
function
Interface
(
value
path
)
{
if
(
true
)
{
if
(
identity
)
{
return
value
;
}
}
if
(
false
)
{
path
=
path
|
|
[
displayName
]
;
assert
(
!
isNil
(
value
)
function
(
)
{
return
'
Invalid
value
'
+
value
+
'
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
if
(
strict
)
{
for
(
var
k
in
value
)
{
assert
(
props
.
hasOwnProperty
(
k
)
function
(
)
{
return
'
Invalid
additional
prop
"
'
+
k
+
'
"
supplied
to
'
+
path
.
join
(
'
/
'
)
;
}
)
;
}
}
}
var
idempotent
=
true
;
var
ret
=
{
}
;
for
(
var
prop
in
props
)
{
var
expected
=
props
[
prop
]
;
var
actual
=
value
[
prop
]
;
var
instance
=
create
(
expected
actual
(
false
?
path
.
concat
(
prop
+
'
:
'
+
getTypeName
(
expected
)
)
:
null
)
)
;
idempotent
=
idempotent
&
&
(
actual
=
=
=
instance
)
;
ret
[
prop
]
=
instance
;
}
if
(
idempotent
)
{
ret
=
value
;
}
if
(
false
)
{
Object
.
freeze
(
ret
)
;
}
return
ret
;
}
Interface
.
meta
=
{
kind
:
'
interface
'
props
:
props
name
:
name
identity
:
identity
strict
:
strict
}
;
Interface
.
displayName
=
displayName
;
Interface
.
is
=
function
(
x
)
{
if
(
strict
)
{
for
(
var
k
in
x
)
{
if
(
!
props
.
hasOwnProperty
(
k
)
)
{
return
false
;
}
}
}
for
(
var
prop
in
props
)
{
if
(
!
is
(
x
[
prop
]
props
[
prop
]
)
)
{
return
false
;
}
}
return
true
;
}
;
Interface
.
update
=
function
(
instance
patch
)
{
return
Interface
(
assert
.
update
(
instance
patch
)
)
;
}
;
Interface
.
extend
=
function
(
xs
name
)
{
return
extendInterface
(
[
Interface
]
.
concat
(
xs
)
name
)
;
}
;
return
Interface
;
}
inter
.
strict
=
false
;
inter
.
getOptions
=
getOptions
;
inter
.
getDefaultName
=
getDefaultInterfaceName
;
inter
.
extend
=
extendInterface
;
module
.
exports
=
inter
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isObject
=
__webpack_require__
(
128
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
isArray
=
__webpack_require__
(
129
)
;
var
isNumber
=
__webpack_require__
(
138
)
;
var
mixin
=
__webpack_require__
(
151
)
;
function
getShallowCopy
(
x
)
{
if
(
isArray
(
x
)
)
{
return
x
.
concat
(
)
;
}
if
(
x
instanceof
Date
|
|
x
instanceof
RegExp
)
{
return
x
;
}
if
(
isObject
(
x
)
)
{
return
mixin
(
{
}
x
)
;
}
return
x
;
}
function
isCommand
(
k
)
{
return
update
.
commands
.
hasOwnProperty
(
k
)
;
}
function
getCommand
(
k
)
{
return
update
.
commands
[
k
]
;
}
function
update
(
instance
patch
)
{
if
(
false
)
{
assert
(
isObject
(
patch
)
function
(
)
{
return
'
Invalid
argument
patch
'
+
assert
.
stringify
(
patch
)
+
'
supplied
to
function
update
(
instance
patch
)
:
expected
an
object
containing
commands
'
;
}
)
;
}
var
value
=
instance
;
var
isChanged
=
false
;
var
newValue
;
for
(
var
k
in
patch
)
{
if
(
patch
.
hasOwnProperty
(
k
)
)
{
if
(
isCommand
(
k
)
)
{
newValue
=
getCommand
(
k
)
(
patch
[
k
]
value
)
;
if
(
newValue
!
=
=
instance
)
{
isChanged
=
true
;
value
=
newValue
;
}
else
{
value
=
instance
;
}
}
else
{
if
(
value
=
=
=
instance
)
{
value
=
getShallowCopy
(
instance
)
;
}
newValue
=
update
(
value
[
k
]
patch
[
k
]
)
;
isChanged
=
isChanged
|
|
(
newValue
!
=
=
value
[
k
]
)
;
value
[
k
]
=
newValue
;
}
}
}
return
isChanged
?
value
:
instance
;
}
function
apply
(
f
value
)
{
if
(
false
)
{
assert
(
isFunction
(
f
)
'
Invalid
argument
f
supplied
to
immutability
helper
{
apply
:
f
}
(
expected
a
function
)
'
)
;
}
return
f
(
value
)
;
}
function
push
(
elements
arr
)
{
if
(
false
)
{
assert
(
isArray
(
elements
)
'
Invalid
argument
elements
supplied
to
immutability
helper
{
push
:
elements
}
(
expected
an
array
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
push
(
expected
an
array
)
'
)
;
}
if
(
elements
.
length
>
0
)
{
return
arr
.
concat
(
elements
)
;
}
return
arr
;
}
function
remove
(
keys
obj
)
{
if
(
false
)
{
assert
(
isArray
(
keys
)
'
Invalid
argument
keys
supplied
to
immutability
helper
{
remove
:
keys
}
(
expected
an
array
)
'
)
;
assert
(
isObject
(
obj
)
'
Invalid
value
supplied
to
immutability
helper
remove
(
expected
an
object
)
'
)
;
}
if
(
keys
.
length
>
0
)
{
obj
=
getShallowCopy
(
obj
)
;
for
(
var
i
=
0
len
=
keys
.
length
;
i
<
len
;
i
+
+
)
{
delete
obj
[
keys
[
i
]
]
;
}
}
return
obj
;
}
function
set
(
value
)
{
return
value
;
}
function
splice
(
splices
arr
)
{
if
(
false
)
{
assert
(
isArray
(
splices
)
&
&
splices
.
every
(
isArray
)
'
Invalid
argument
splices
supplied
to
immutability
helper
{
splice
:
splices
}
(
expected
an
array
of
arrays
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
splice
(
expected
an
array
)
'
)
;
}
if
(
splices
.
length
>
0
)
{
arr
=
getShallowCopy
(
arr
)
;
return
splices
.
reduce
(
function
(
acc
splice
)
{
acc
.
splice
.
apply
(
acc
splice
)
;
return
acc
;
}
arr
)
;
}
return
arr
;
}
function
swap
(
config
arr
)
{
if
(
false
)
{
assert
(
isObject
(
config
)
'
Invalid
argument
config
supplied
to
immutability
helper
{
swap
:
config
}
(
expected
an
object
)
'
)
;
assert
(
isNumber
(
config
.
from
)
'
Invalid
argument
config
.
from
supplied
to
immutability
helper
{
swap
:
config
}
(
expected
a
number
)
'
)
;
assert
(
isNumber
(
config
.
to
)
'
Invalid
argument
config
.
to
supplied
to
immutability
helper
{
swap
:
config
}
(
expected
a
number
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
swap
(
expected
an
array
)
'
)
;
}
if
(
config
.
from
!
=
=
config
.
to
)
{
arr
=
getShallowCopy
(
arr
)
;
var
element
=
arr
[
config
.
to
]
;
arr
[
config
.
to
]
=
arr
[
config
.
from
]
;
arr
[
config
.
from
]
=
element
;
}
return
arr
;
}
function
unshift
(
elements
arr
)
{
if
(
false
)
{
assert
(
isArray
(
elements
)
'
Invalid
argument
elements
supplied
to
immutability
helper
{
unshift
:
elements
}
(
expected
an
array
)
'
)
;
assert
(
isArray
(
arr
)
'
Invalid
value
supplied
to
immutability
helper
unshift
(
expected
an
array
)
'
)
;
}
if
(
elements
.
length
>
0
)
{
return
elements
.
concat
(
arr
)
;
}
return
arr
;
}
function
merge
(
whatToMerge
value
)
{
var
isChanged
=
false
;
var
result
=
getShallowCopy
(
value
)
;
for
(
var
k
in
whatToMerge
)
{
if
(
whatToMerge
.
hasOwnProperty
(
k
)
)
{
result
[
k
]
=
whatToMerge
[
k
]
;
isChanged
=
isChanged
|
|
(
result
[
k
]
!
=
=
value
[
k
]
)
;
}
}
return
isChanged
?
result
:
value
;
}
update
.
commands
=
{
apply
:
apply
push
:
push
remove
:
remove
set
:
set
splice
:
splice
swap
:
swap
unshift
:
unshift
merge
:
merge
}
;
module
.
exports
=
update
;
}
function
(
module
exports
__webpack_require__
)
{
var
assert
=
__webpack_require__
(
116
)
;
var
isFunction
=
__webpack_require__
(
117
)
;
var
isType
=
__webpack_require__
(
127
)
;
var
Any
=
__webpack_require__
(
122
)
;
module
.
exports
=
function
match
(
x
)
{
var
type
guard
f
count
;
for
(
var
i
=
1
len
=
arguments
.
length
;
i
<
len
;
)
{
type
=
arguments
[
i
]
;
guard
=
arguments
[
i
+
1
]
;
f
=
arguments
[
i
+
2
]
;
if
(
isFunction
(
f
)
&
&
!
isType
(
f
)
)
{
i
=
i
+
3
;
}
else
{
f
=
guard
;
guard
=
Any
.
is
;
i
=
i
+
2
;
}
if
(
false
)
{
count
=
(
count
|
|
0
)
+
1
;
assert
(
isType
(
type
)
function
(
)
{
return
'
Invalid
type
in
clause
#
'
+
count
;
}
)
;
assert
(
isFunction
(
guard
)
function
(
)
{
return
'
Invalid
guard
in
clause
#
'
+
count
;
}
)
;
assert
(
isFunction
(
f
)
function
(
)
{
return
'
Invalid
block
in
clause
#
'
+
count
;
}
)
;
}
if
(
type
.
is
(
x
)
&
&
guard
(
x
)
)
{
return
f
(
x
)
;
}
}
assert
.
fail
(
'
Match
error
'
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
_require
=
__webpack_require__
(
114
)
;
var
BreakpointResult
=
_require
.
BreakpointResult
;
var
Location
=
_require
.
Location
;
var
defer
=
__webpack_require__
(
112
)
;
var
bpClients
=
void
0
;
var
threadClient
=
void
0
;
var
tabTarget
=
void
0
;
var
debuggerClient
=
void
0
;
function
setupCommands
(
dependencies
)
{
threadClient
=
dependencies
.
threadClient
;
tabTarget
=
dependencies
.
tabTarget
;
debuggerClient
=
dependencies
.
debuggerClient
;
bpClients
=
{
}
;
}
function
resume
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
resume
(
resolve
)
;
}
)
;
}
function
stepIn
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
stepIn
(
resolve
)
;
}
)
;
}
function
stepOver
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
stepOver
(
resolve
)
;
}
)
;
}
function
stepOut
(
)
{
return
new
Promise
(
resolve
=
>
{
threadClient
.
stepOut
(
resolve
)
;
}
)
;
}
function
breakOnNext
(
)
{
return
threadClient
.
breakOnNext
(
)
;
}
function
sourceContents
(
sourceId
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
sourceId
}
)
;
return
sourceClient
.
source
(
)
;
}
function
setBreakpoint
(
location
condition
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
location
.
sourceId
}
)
;
return
sourceClient
.
setBreakpoint
(
{
line
:
location
.
line
column
:
location
.
column
condition
:
condition
}
)
.
then
(
_ref
=
>
{
var
_ref2
=
_slicedToArray
(
_ref
2
)
;
var
res
=
_ref2
[
0
]
;
var
bpClient
=
_ref2
[
1
]
;
bpClients
[
bpClient
.
actor
]
=
bpClient
;
var
actualLocation
=
res
.
actualLocation
?
{
sourceId
:
res
.
actualLocation
.
source
.
actor
line
:
res
.
actualLocation
.
line
column
:
res
.
actualLocation
.
column
}
:
location
;
return
BreakpointResult
(
{
id
:
bpClient
.
actor
actualLocation
:
Location
(
actualLocation
)
}
)
;
}
)
;
}
function
removeBreakpoint
(
breakpointId
)
{
var
bpClient
=
bpClients
[
breakpointId
]
;
bpClients
[
breakpointId
]
=
null
;
return
bpClient
.
remove
(
)
;
}
function
evaluate
(
script
)
{
var
deferred
=
defer
(
)
;
tabTarget
.
activeConsole
.
evaluateJS
(
script
result
=
>
{
deferred
.
resolve
(
result
)
;
}
)
;
return
deferred
.
promise
;
}
function
debuggeeCommand
(
script
)
{
tabTarget
.
activeConsole
.
evaluateJS
(
script
(
)
=
>
{
}
)
;
var
consoleActor
=
tabTarget
.
form
.
consoleActor
;
var
request
=
debuggerClient
.
_activeRequests
.
get
(
consoleActor
)
;
request
.
emit
(
"
json
-
reply
"
{
}
)
;
debuggerClient
.
_activeRequests
.
delete
(
consoleActor
)
;
return
Promise
.
resolve
(
)
;
}
function
navigate
(
url
)
{
return
tabTarget
.
activeTab
.
navigateTo
(
url
)
;
}
function
reload
(
)
{
return
tabTarget
.
activeTab
.
reload
(
)
;
}
function
getProperties
(
grip
)
{
var
objClient
=
threadClient
.
pauseGrip
(
grip
)
;
return
objClient
.
getPrototypeAndProperties
(
)
;
}
function
pauseOnExceptions
(
shouldPauseOnExceptions
shouldIgnoreCaughtExceptions
)
{
return
threadClient
.
pauseOnExceptions
(
shouldPauseOnExceptions
shouldIgnoreCaughtExceptions
)
;
}
function
prettyPrint
(
sourceId
indentSize
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
sourceId
}
)
;
return
sourceClient
.
prettyPrint
(
indentSize
)
;
}
function
disablePrettyPrint
(
sourceId
)
{
var
sourceClient
=
threadClient
.
source
(
{
actor
:
sourceId
}
)
;
return
sourceClient
.
disablePrettyPrint
(
)
;
}
var
clientCommands
=
{
resume
stepIn
stepOut
stepOver
breakOnNext
sourceContents
setBreakpoint
removeBreakpoint
evaluate
debuggeeCommand
navigate
reload
getProperties
pauseOnExceptions
prettyPrint
disablePrettyPrint
}
;
module
.
exports
=
{
setupCommands
clientCommands
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
paused
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
_
packet
)
{
if
(
packet
.
why
.
type
=
=
=
"
interrupted
"
&
&
!
packet
.
why
.
onNext
)
{
return
;
}
var
response
=
yield
threadClient
.
getFrames
(
0
CALL_STACK_PAGE_SIZE
)
;
var
frames
=
response
.
frames
.
map
(
createFrame
)
;
var
pause
=
Object
.
assign
(
{
}
packet
{
frame
:
createFrame
(
packet
.
frame
)
frames
:
frames
}
)
;
actions
.
paused
(
pause
)
;
}
)
;
return
function
paused
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
172
)
;
var
createFrame
=
_require
.
createFrame
;
var
createSource
=
_require
.
createSource
;
var
CALL_STACK_PAGE_SIZE
=
1000
;
var
threadClient
=
void
0
;
var
actions
=
void
0
;
function
setupEvents
(
dependencies
)
{
threadClient
=
dependencies
.
threadClient
;
actions
=
dependencies
.
actions
;
}
function
resumed
(
_
packet
)
{
actions
.
resumed
(
packet
)
;
}
function
newSource
(
_
_ref2
)
{
var
source
=
_ref2
.
source
;
actions
.
newSource
(
createSource
(
source
)
)
;
}
var
clientEvents
=
{
paused
resumed
newSource
}
;
module
.
exports
=
{
setupEvents
clientEvents
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
114
)
;
var
Source
=
_require
.
Source
;
var
Frame
=
_require
.
Frame
;
var
Location
=
_require
.
Location
;
function
createFrame
(
frame
)
{
var
title
=
void
0
;
if
(
frame
.
type
=
=
"
call
"
)
{
var
c
=
frame
.
callee
;
title
=
c
.
name
|
|
c
.
userDisplayName
|
|
c
.
displayName
|
|
"
(
anonymous
)
"
;
}
else
{
title
=
"
(
"
+
frame
.
type
+
"
)
"
;
}
return
Frame
(
{
id
:
frame
.
actor
displayName
:
title
location
:
Location
(
{
sourceId
:
frame
.
where
.
source
.
actor
line
:
frame
.
where
.
line
column
:
frame
.
where
.
column
}
)
this
:
frame
.
this
scope
:
frame
.
environment
}
)
;
}
var
evalIndex
=
1
;
function
createSource
(
source
)
{
if
(
!
source
.
url
)
{
source
.
url
=
SOURCE
{
evalIndex
+
+
}
;
}
return
Source
(
{
id
:
source
.
actor
url
:
source
.
url
isPrettyPrinted
:
false
sourceMapURL
:
source
.
sourceMapURL
}
)
;
}
module
.
exports
=
{
createFrame
createSource
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
174
)
;
var
connect
=
_require
.
connect
;
var
defer
=
__webpack_require__
(
112
)
;
var
_require2
=
__webpack_require__
(
114
)
;
var
Tab
=
_require2
.
Tab
;
var
_require3
=
__webpack_require__
(
46
)
;
var
isEnabled
=
_require3
.
isEnabled
;
var
getValue
=
_require3
.
getValue
;
var
_require4
=
__webpack_require__
(
175
)
;
var
networkRequest
=
_require4
.
networkRequest
;
var
_require5
=
__webpack_require__
(
178
)
;
var
setupCommands
=
_require5
.
setupCommands
;
var
clientCommands
=
_require5
.
clientCommands
;
var
_require6
=
__webpack_require__
(
179
)
;
var
setupEvents
=
_require6
.
setupEvents
;
var
clientEvents
=
_require6
.
clientEvents
;
var
pageEvents
=
_require6
.
pageEvents
;
Array
.
prototype
.
peekLast
=
function
(
)
{
return
this
[
this
.
length
-
1
]
;
}
;
var
connection
=
void
0
;
function
createTabs
(
tabs
)
{
return
tabs
.
filter
(
tab
=
>
{
var
isPage
=
tab
.
type
=
=
"
page
"
;
return
isPage
;
}
)
.
map
(
tab
=
>
{
return
Tab
(
{
title
:
tab
.
title
url
:
tab
.
url
id
:
tab
.
id
tab
browser
:
"
chrome
"
}
)
;
}
)
;
}
function
connectClient
(
)
{
var
deferred
=
defer
(
)
;
if
(
!
getValue
(
"
chrome
.
debug
"
)
)
{
return
deferred
.
resolve
(
createTabs
(
[
]
)
)
;
}
var
webSocketPort
=
getValue
(
"
chrome
.
webSocketPort
"
)
;
var
url
=
http
:
/
/
localhost
:
{
webSocketPort
}
/
json
/
list
;
networkRequest
(
url
)
.
then
(
body
=
>
{
deferred
.
resolve
(
createTabs
(
body
)
)
;
}
)
.
catch
(
err
=
>
{
console
.
log
(
err
)
;
deferred
.
reject
(
)
;
}
)
;
return
deferred
.
promise
;
}
function
connectTab
(
tab
)
{
return
connect
(
tab
.
webSocketDebuggerUrl
)
.
then
(
conn
=
>
{
connection
=
conn
;
}
)
;
}
function
connectNode
(
url
)
{
return
connect
(
url
)
.
then
(
conn
=
>
{
connection
=
conn
;
}
)
;
}
function
initPage
(
actions
)
{
var
agents
=
connection
.
_agents
;
setupCommands
(
{
agents
:
agents
}
)
;
setupEvents
(
{
actions
agents
}
)
;
agents
.
Debugger
.
enable
(
)
;
agents
.
Debugger
.
setPauseOnExceptions
(
"
none
"
)
;
agents
.
Debugger
.
setAsyncCallStackDepth
(
0
)
;
agents
.
Runtime
.
enable
(
)
;
agents
.
Runtime
.
run
(
)
;
agents
.
Page
.
enable
(
)
;
connection
.
registerDispatcher
(
"
Debugger
"
clientEvents
)
;
connection
.
registerDispatcher
(
"
Page
"
pageEvents
)
;
}
module
.
exports
=
{
connectClient
clientCommands
connectNode
connectTab
initPage
}
;
}
function
(
module
exports
)
{
module
.
exports
=
{
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
176
)
;
var
log
=
_require
.
log
;
function
networkRequest
(
url
)
{
return
Promise
.
race
(
[
fetch
(
/
get
?
url
=
{
url
}
)
.
then
(
res
=
>
{
if
(
res
.
status
>
=
200
&
&
res
.
status
<
300
)
{
return
res
.
json
(
)
;
}
log
(
failed
to
request
{
url
}
)
;
return
Promise
.
resolve
(
[
]
)
;
}
)
new
Promise
(
(
resolve
reject
)
=
>
{
setTimeout
(
(
)
=
>
reject
(
new
Error
(
"
Connect
timeout
error
"
)
)
6000
)
;
}
)
]
)
;
}
module
.
exports
=
{
networkRequest
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
asyncMap
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
items
callback
)
{
var
newItems
=
[
]
;
for
(
var
item
of
items
)
{
item
=
yield
callback
(
item
)
;
newItems
.
push
(
item
)
;
}
return
newItems
;
}
)
;
return
function
asyncMap
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
co
=
__webpack_require__
(
177
)
;
var
_require
=
__webpack_require__
(
46
)
;
var
isDevelopment
=
_require
.
isDevelopment
;
var
defer
=
__webpack_require__
(
112
)
;
function
asPaused
(
client
func
)
{
if
(
client
.
state
!
=
"
paused
"
)
{
return
co
(
function
*
(
)
{
yield
client
.
interrupt
(
)
;
var
result
=
void
0
;
try
{
result
=
yield
func
(
)
;
}
catch
(
e
)
{
yield
client
.
resume
(
)
;
throw
e
;
}
yield
client
.
resume
(
)
;
return
result
;
}
)
;
}
return
func
(
)
;
}
function
handleError
(
err
)
{
console
.
log
(
"
ERROR
:
"
err
)
;
}
function
promisify
(
context
method
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
args
.
push
(
response
=
>
{
if
(
response
.
error
)
{
reject
(
response
)
;
}
else
{
resolve
(
response
)
;
}
}
)
;
method
.
apply
(
context
args
)
;
}
)
;
}
function
truncateStr
(
str
size
)
{
if
(
str
.
length
>
size
)
{
return
str
.
slice
(
0
size
)
+
"
.
.
.
"
;
}
return
str
;
}
function
endTruncateStr
(
str
size
)
{
if
(
str
.
length
>
size
)
{
return
"
.
.
.
"
+
str
.
slice
(
str
.
length
-
size
)
;
}
return
str
;
}
function
workerTask
(
worker
message
)
{
var
deferred
=
defer
(
)
;
worker
.
postMessage
(
message
)
;
worker
.
onmessage
=
function
(
result
)
{
if
(
result
.
error
)
{
deferred
.
reject
(
result
.
error
)
;
}
deferred
.
resolve
(
result
.
data
)
;
}
;
return
deferred
.
promise
;
}
function
zip
(
a
b
)
{
if
(
!
b
)
{
return
a
;
}
if
(
!
a
)
{
return
b
;
}
var
pairs
=
[
]
;
for
(
var
i
=
0
aLength
=
a
.
length
bLength
=
b
.
length
;
i
<
aLength
|
|
i
<
bLength
;
i
+
+
)
{
pairs
.
push
(
[
a
[
i
]
b
[
i
]
]
)
;
}
return
pairs
;
}
function
entries
(
obj
)
{
return
Object
.
keys
(
obj
)
.
map
(
k
=
>
[
k
obj
[
k
]
]
)
;
}
function
mapObject
(
obj
iteratee
)
{
return
toObject
(
entries
(
obj
)
.
map
(
_ref2
=
>
{
var
_ref3
=
_slicedToArray
(
_ref2
2
)
;
var
key
=
_ref3
[
0
]
;
var
value
=
_ref3
[
1
]
;
return
[
key
iteratee
(
key
value
)
]
;
}
)
)
;
}
function
toObject
(
arr
)
{
var
obj
=
{
}
;
for
(
var
pair
of
arr
)
{
obj
[
pair
[
0
]
]
=
pair
[
1
]
;
}
return
obj
;
}
function
compose
(
)
{
for
(
var
_len2
=
arguments
.
length
funcs
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
funcs
[
_key2
]
=
arguments
[
_key2
]
;
}
return
function
(
)
{
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
var
initialValue
=
funcs
[
funcs
.
length
-
1
]
.
apply
(
null
args
)
;
var
leftFuncs
=
funcs
.
slice
(
0
-
1
)
;
return
leftFuncs
.
reduceRight
(
(
composed
f
)
=
>
f
(
composed
)
initialValue
)
;
}
;
}
function
log
(
)
{
if
(
!
isDevelopment
(
)
)
{
return
;
}
console
.
log
.
apply
(
console
[
"
[
log
]
"
]
.
concat
(
Array
.
prototype
.
slice
.
call
(
arguments
)
)
)
;
}
function
updateObj
(
obj
fields
)
{
return
Object
.
assign
(
{
}
obj
fields
)
;
}
function
throttle
(
func
ms
)
{
var
timeout
=
void
0
_this
=
void
0
;
return
function
(
)
{
for
(
var
_len4
=
arguments
.
length
args
=
Array
(
_len4
)
_key4
=
0
;
_key4
<
_len4
;
_key4
+
+
)
{
args
[
_key4
]
=
arguments
[
_key4
]
;
}
_this
=
this
;
if
(
!
timeout
)
{
timeout
=
setTimeout
(
(
)
=
>
{
func
.
apply
.
apply
(
func
[
_this
]
.
concat
(
_toConsumableArray
(
args
)
)
)
;
timeout
=
null
;
}
ms
)
;
}
}
;
}
module
.
exports
=
{
asPaused
handleError
promisify
truncateStr
endTruncateStr
workerTask
asyncMap
zip
entries
toObject
mapObject
compose
log
updateObj
throttle
}
;
}
function
(
module
exports
)
{
var
slice
=
Array
.
prototype
.
slice
;
module
.
exports
=
co
[
'
default
'
]
=
co
.
co
=
co
;
co
.
wrap
=
function
(
fn
)
{
createPromise
.
__generatorFunction__
=
fn
;
return
createPromise
;
function
createPromise
(
)
{
return
co
.
call
(
this
fn
.
apply
(
this
arguments
)
)
;
}
}
;
function
co
(
gen
)
{
var
ctx
=
this
;
var
args
=
slice
.
call
(
arguments
1
)
return
new
Promise
(
function
(
resolve
reject
)
{
if
(
typeof
gen
=
=
=
'
function
'
)
gen
=
gen
.
apply
(
ctx
args
)
;
if
(
!
gen
|
|
typeof
gen
.
next
!
=
=
'
function
'
)
return
resolve
(
gen
)
;
onFulfilled
(
)
;
function
onFulfilled
(
res
)
{
var
ret
;
try
{
ret
=
gen
.
next
(
res
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
onRejected
(
err
)
{
var
ret
;
try
{
ret
=
gen
.
throw
(
err
)
;
}
catch
(
e
)
{
return
reject
(
e
)
;
}
next
(
ret
)
;
}
function
next
(
ret
)
{
if
(
ret
.
done
)
return
resolve
(
ret
.
value
)
;
var
value
=
toPromise
.
call
(
ctx
ret
.
value
)
;
if
(
value
&
&
isPromise
(
value
)
)
return
value
.
then
(
onFulfilled
onRejected
)
;
return
onRejected
(
new
TypeError
(
'
You
may
only
yield
a
function
promise
generator
array
or
object
'
+
'
but
the
following
object
was
passed
:
"
'
+
String
(
ret
.
value
)
+
'
"
'
)
)
;
}
}
)
;
}
function
toPromise
(
obj
)
{
if
(
!
obj
)
return
obj
;
if
(
isPromise
(
obj
)
)
return
obj
;
if
(
isGeneratorFunction
(
obj
)
|
|
isGenerator
(
obj
)
)
return
co
.
call
(
this
obj
)
;
if
(
'
function
'
=
=
typeof
obj
)
return
thunkToPromise
.
call
(
this
obj
)
;
if
(
Array
.
isArray
(
obj
)
)
return
arrayToPromise
.
call
(
this
obj
)
;
if
(
isObject
(
obj
)
)
return
objectToPromise
.
call
(
this
obj
)
;
return
obj
;
}
function
thunkToPromise
(
fn
)
{
var
ctx
=
this
;
return
new
Promise
(
function
(
resolve
reject
)
{
fn
.
call
(
ctx
function
(
err
res
)
{
if
(
err
)
return
reject
(
err
)
;
if
(
arguments
.
length
>
2
)
res
=
slice
.
call
(
arguments
1
)
;
resolve
(
res
)
;
}
)
;
}
)
;
}
function
arrayToPromise
(
obj
)
{
return
Promise
.
all
(
obj
.
map
(
toPromise
this
)
)
;
}
function
objectToPromise
(
obj
)
{
var
results
=
new
obj
.
constructor
(
)
;
var
keys
=
Object
.
keys
(
obj
)
;
var
promises
=
[
]
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
promise
=
toPromise
.
call
(
this
obj
[
key
]
)
;
if
(
promise
&
&
isPromise
(
promise
)
)
defer
(
promise
key
)
;
else
results
[
key
]
=
obj
[
key
]
;
}
return
Promise
.
all
(
promises
)
.
then
(
function
(
)
{
return
results
;
}
)
;
function
defer
(
promise
key
)
{
results
[
key
]
=
undefined
;
promises
.
push
(
promise
.
then
(
function
(
res
)
{
results
[
key
]
=
res
;
}
)
)
;
}
}
function
isPromise
(
obj
)
{
return
'
function
'
=
=
typeof
obj
.
then
;
}
function
isGenerator
(
obj
)
{
return
'
function
'
=
=
typeof
obj
.
next
&
&
'
function
'
=
=
typeof
obj
.
throw
;
}
function
isGeneratorFunction
(
obj
)
{
var
constructor
=
obj
.
constructor
;
if
(
!
constructor
)
return
false
;
if
(
'
GeneratorFunction
'
=
=
=
constructor
.
name
|
|
'
GeneratorFunction
'
=
=
=
constructor
.
displayName
)
return
true
;
return
isGenerator
(
constructor
.
prototype
)
;
}
function
isObject
(
val
)
{
return
Object
=
=
val
.
constructor
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
114
)
;
var
BreakpointResult
=
_require
.
BreakpointResult
;
var
Location
=
_require
.
Location
;
var
debuggerAgent
=
void
0
;
var
runtimeAgent
=
void
0
;
var
pageAgent
=
void
0
;
function
setupCommands
(
_ref
)
{
var
agents
=
_ref
.
agents
;
debuggerAgent
=
agents
.
Debugger
;
runtimeAgent
=
agents
.
Runtime
;
pageAgent
=
agents
.
Page
;
}
function
resume
(
)
{
return
debuggerAgent
.
resume
(
)
;
}
function
stepIn
(
)
{
return
debuggerAgent
.
stepInto
(
)
;
}
function
stepOver
(
)
{
return
debuggerAgent
.
stepOver
(
)
;
}
function
stepOut
(
)
{
return
debuggerAgent
.
stepOut
(
)
;
}
function
pauseOnExceptions
(
toggle
)
{
var
state
=
toggle
?
"
uncaught
"
:
"
none
"
;
return
debuggerAgent
.
setPauseOnExceptions
(
state
)
;
}
function
breakOnNext
(
)
{
return
debuggerAgent
.
pause
(
)
;
}
function
sourceContents
(
sourceId
)
{
return
debuggerAgent
.
getScriptSource
(
sourceId
(
err
contents
)
=
>
(
{
source
:
contents
contentType
:
null
}
)
)
;
}
function
setBreakpoint
(
location
condition
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
return
debuggerAgent
.
setBreakpoint
(
{
scriptId
:
location
.
sourceId
lineNumber
:
location
.
line
-
1
columnNumber
:
location
.
column
}
(
err
breakpointId
actualLocation
)
=
>
{
if
(
err
)
{
reject
(
err
)
;
return
;
}
actualLocation
=
actualLocation
?
{
sourceId
:
actualLocation
.
scriptId
line
:
actualLocation
.
lineNumber
+
1
column
:
actualLocation
.
columnNumber
}
:
location
;
resolve
(
BreakpointResult
(
{
id
:
breakpointId
actualLocation
:
Location
(
actualLocation
)
}
)
)
;
}
)
;
}
)
;
}
function
removeBreakpoint
(
breakpointId
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
resolve
(
debuggerAgent
.
removeBreakpoint
(
breakpointId
)
)
;
}
)
;
}
function
evaluate
(
script
)
{
return
runtimeAgent
.
evaluate
(
script
(
_
result
)
=
>
{
return
result
;
}
)
;
}
function
debuggeeCommand
(
script
)
{
evaluate
(
script
)
;
return
Promise
.
resolve
(
)
;
}
function
navigate
(
url
)
{
return
pageAgent
.
navigate
(
url
(
_
result
)
=
>
{
return
result
;
}
)
;
}
var
clientCommands
=
{
resume
stepIn
stepOut
stepOver
pauseOnExceptions
breakOnNext
sourceContents
setBreakpoint
removeBreakpoint
evaluate
debuggeeCommand
navigate
}
;
module
.
exports
=
{
setupCommands
clientCommands
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
paused
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
callFrames
reason
data
hitBreakpoints
asyncStackTrace
)
{
var
frames
=
callFrames
.
map
(
function
(
frame
)
{
return
Frame
(
{
id
:
frame
.
callFrameId
displayName
:
frame
.
functionName
location
:
Location
(
{
sourceId
:
frame
.
location
.
scriptId
line
:
frame
.
location
.
lineNumber
+
1
column
:
frame
.
location
.
columnNumber
}
)
}
)
;
}
)
;
var
frame
=
frames
[
0
]
;
var
why
=
Object
.
assign
(
{
}
{
type
:
reason
}
data
)
;
pageAgent
.
setOverlayMessage
(
"
Paused
in
debugger
.
html
"
)
;
yield
actions
.
paused
(
{
frame
why
frames
}
)
;
}
)
;
return
function
paused
(
_x
_x2
_x3
_x4
_x5
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
114
)
;
var
Source
=
_require
.
Source
;
var
Location
=
_require
.
Location
;
var
Frame
=
_require
.
Frame
;
var
actions
=
void
0
;
var
pageAgent
=
void
0
;
function
setupEvents
(
dependencies
)
{
actions
=
dependencies
.
actions
;
pageAgent
=
dependencies
.
agents
.
Page
;
}
function
scriptParsed
(
scriptId
url
startLine
startColumn
endLine
endColumn
executionContextId
hash
isContentScript
isInternalScript
isLiveEdit
sourceMapURL
hasSourceURL
deprecatedCommentWasUsed
)
{
if
(
isContentScript
)
{
return
;
}
actions
.
newSource
(
Source
(
{
id
:
scriptId
url
sourceMapURL
isPrettyPrinted
:
false
}
)
)
;
}
function
scriptFailedToParse
(
)
{
}
function
resumed
(
)
{
pageAgent
.
setOverlayMessage
(
undefined
)
;
actions
.
resumed
(
)
;
}
function
globalObjectCleared
(
)
{
}
function
frameNavigated
(
frame
)
{
actions
.
navigate
(
)
;
}
function
frameStartedLoading
(
)
{
actions
.
willNavigate
(
)
;
}
function
domContentEventFired
(
)
{
}
function
loadEventFired
(
)
{
}
function
frameStoppedLoading
(
)
{
}
var
clientEvents
=
{
scriptParsed
scriptFailedToParse
paused
resumed
globalObjectCleared
}
;
var
pageEvents
=
{
frameNavigated
frameStartedLoading
domContentEventFired
loadEventFired
frameStoppedLoading
}
;
module
.
exports
=
{
setupEvents
pageEvents
clientEvents
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
2
)
;
var
createStore
=
_require
.
createStore
;
var
applyMiddleware
=
_require
.
applyMiddleware
;
var
_require2
=
__webpack_require__
(
181
)
;
var
waitUntilService
=
_require2
.
waitUntilService
;
var
_require3
=
__webpack_require__
(
182
)
;
var
log
=
_require3
.
log
;
var
_require4
=
__webpack_require__
(
183
)
;
var
history
=
_require4
.
history
;
var
_require5
=
__webpack_require__
(
184
)
;
var
promise
=
_require5
.
promise
;
var
_require6
=
__webpack_require__
(
187
)
;
var
thunk
=
_require6
.
thunk
;
var
configureStore
=
function
(
)
{
var
opts
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
{
}
:
arguments
[
0
]
;
var
middleware
=
[
thunk
(
opts
.
makeThunkArgs
)
promise
waitUntilService
]
;
if
(
opts
.
history
)
{
middleware
.
push
(
history
(
opts
.
history
)
)
;
}
if
(
opts
.
middleware
)
{
opts
.
middleware
.
forEach
(
fn
=
>
middleware
.
push
(
fn
)
)
;
}
if
(
opts
.
log
)
{
middleware
.
push
(
log
)
;
}
var
devtoolsExt
=
typeof
window
=
=
=
"
object
"
&
&
window
.
devToolsExtension
?
window
.
devToolsExtension
(
)
:
f
=
>
f
;
return
applyMiddleware
.
apply
(
undefined
middleware
)
(
devtoolsExt
(
createStore
)
)
;
}
;
module
.
exports
=
configureStore
;
}
function
(
module
exports
)
{
"
use
strict
"
;
const
NAME
=
exports
.
NAME
=
"
service
/
waitUntil
"
;
function
waitUntilService
(
{
dispatch
getState
}
)
{
let
pending
=
[
]
;
function
checkPending
(
action
)
{
let
readyRequests
=
[
]
;
let
stillPending
=
[
]
;
for
(
let
request
of
pending
)
{
if
(
request
.
predicate
(
action
)
)
{
readyRequests
.
push
(
request
)
;
}
else
{
stillPending
.
push
(
request
)
;
}
}
pending
=
stillPending
;
for
(
let
request
of
readyRequests
)
{
request
.
run
(
dispatch
getState
action
)
;
}
}
return
next
=
>
action
=
>
{
if
(
action
.
type
=
=
=
NAME
)
{
pending
.
push
(
action
)
;
return
null
;
}
let
result
=
next
(
action
)
;
checkPending
(
action
)
;
return
result
;
}
;
}
exports
.
waitUntilService
=
waitUntilService
;
}
function
(
module
exports
)
{
function
log
(
_ref
)
{
var
dispatch
=
_ref
.
dispatch
;
var
getState
=
_ref
.
getState
;
return
next
=
>
action
=
>
{
var
actionText
=
JSON
.
stringify
(
action
null
2
)
;
var
truncatedActionText
=
actionText
.
slice
(
0
1000
)
+
"
.
.
.
"
;
console
.
log
(
[
DISPATCH
{
action
.
type
}
]
action
truncatedActionText
)
;
next
(
action
)
;
}
;
}
exports
.
log
=
log
;
}
function
(
module
exports
__webpack_require__
)
{
var
_require
=
__webpack_require__
(
46
)
;
var
isDevelopment
=
_require
.
isDevelopment
;
exports
.
history
=
function
(
)
{
var
log
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
[
]
:
arguments
[
0
]
;
return
_ref
=
>
{
var
dispatch
=
_ref
.
dispatch
;
var
getState
=
_ref
.
getState
;
if
(
isDevelopment
(
)
)
{
console
.
warn
(
"
Using
history
middleware
stores
all
actions
in
state
for
"
+
"
testing
and
devtools
is
not
currently
running
in
test
"
+
"
mode
.
Be
sure
this
is
intentional
.
"
)
;
}
return
next
=
>
action
=
>
{
log
.
push
(
action
)
;
next
(
action
)
;
}
;
}
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
uuidgen
=
__webpack_require__
(
185
)
.
uuid
;
var
defer
=
__webpack_require__
(
112
)
;
var
_require
=
__webpack_require__
(
176
)
;
var
entries
=
_require
.
entries
;
var
toObject
=
_require
.
toObject
;
var
_require2
=
__webpack_require__
(
186
)
;
var
executeSoon
=
_require2
.
executeSoon
;
var
PROMISE
=
exports
.
PROMISE
=
"
dispatch
/
promise
"
;
function
promiseMiddleware
(
_ref
)
{
var
dispatch
=
_ref
.
dispatch
;
var
getState
=
_ref
.
getState
;
return
next
=
>
action
=
>
{
if
(
!
(
PROMISE
in
action
)
)
{
return
next
(
action
)
;
}
var
promiseInst
=
action
[
PROMISE
]
;
var
seqId
=
uuidgen
(
)
.
toString
(
)
;
action
=
Object
.
assign
(
toObject
(
entries
(
action
)
.
filter
(
pair
=
>
pair
[
0
]
!
=
=
PROMISE
)
)
{
seqId
}
)
;
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
start
"
}
)
)
;
var
deferred
=
defer
(
)
;
promiseInst
.
then
(
value
=
>
{
executeSoon
(
(
)
=
>
{
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
done
"
value
:
value
}
)
)
;
deferred
.
resolve
(
value
)
;
}
)
;
}
error
=
>
{
executeSoon
(
(
)
=
>
{
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
error
"
error
:
error
.
message
|
|
error
}
)
)
;
deferred
.
reject
(
error
)
;
}
)
;
}
)
;
return
deferred
.
promise
;
}
;
}
exports
.
promise
=
promiseMiddleware
;
}
function
(
module
exports
)
{
let
i
=
1
;
function
uuid
(
)
{
return
'
not
-
really
-
uuid
'
+
(
i
+
+
)
;
}
module
.
exports
=
{
uuid
}
;
}
function
(
module
exports
)
{
function
reportException
(
who
exception
)
{
var
msg
=
who
+
"
threw
an
exception
:
"
;
console
.
error
(
msg
exception
)
;
}
function
assert
(
condition
message
)
{
if
(
!
condition
)
{
var
err
=
new
Error
(
"
Assertion
failure
:
"
+
message
)
;
reportException
(
"
DevToolsUtils
.
assert
"
err
)
;
throw
err
;
}
}
function
executeSoon
(
fn
)
{
setTimeout
(
fn
0
)
;
}
module
.
exports
=
{
reportException
executeSoon
assert
}
;
}
function
(
module
exports
)
{
function
thunk
(
makeArgs
)
{
return
_ref
=
>
{
var
dispatch
=
_ref
.
dispatch
;
var
getState
=
_ref
.
getState
;
var
args
=
{
dispatch
getState
}
;
return
next
=
>
action
=
>
{
return
typeof
action
=
=
=
"
function
"
?
action
(
makeArgs
?
makeArgs
(
args
getState
(
)
)
:
args
)
:
next
(
action
)
;
}
;
}
;
}
exports
.
thunk
=
thunk
;
}
function
(
module
exports
__webpack_require__
)
{
var
eventListeners
=
__webpack_require__
(
189
)
;
var
sources
=
__webpack_require__
(
191
)
;
var
breakpoints
=
__webpack_require__
(
195
)
;
var
asyncRequests
=
__webpack_require__
(
196
)
;
var
tabs
=
__webpack_require__
(
197
)
;
var
pause
=
__webpack_require__
(
198
)
;
module
.
exports
=
{
eventListeners
sources
:
sources
.
update
breakpoints
:
breakpoints
.
update
pause
:
pause
.
update
asyncRequests
tabs
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
190
)
;
var
initialState
=
{
activeEventNames
:
[
]
listeners
:
[
]
fetchingListeners
:
false
}
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
var
emit
=
arguments
[
2
]
;
switch
(
action
.
type
)
{
case
constants
.
UPDATE_EVENT_BREAKPOINTS
:
state
.
activeEventNames
=
action
.
eventNames
;
emit
(
"
activeEventNames
"
state
.
activeEventNames
)
;
break
;
case
constants
.
FETCH_EVENT_LISTENERS
:
if
(
action
.
status
=
=
=
"
begin
"
)
{
state
.
fetchingListeners
=
true
;
}
else
if
(
action
.
status
=
=
=
"
done
"
)
{
state
.
fetchingListeners
=
false
;
state
.
listeners
=
action
.
listeners
;
emit
(
"
event
-
listeners
"
state
.
listeners
)
;
}
break
;
case
constants
.
NAVIGATE
:
return
initialState
;
}
return
state
;
}
module
.
exports
=
update
;
}
function
(
module
exports
)
{
exports
.
UPDATE_EVENT_BREAKPOINTS
=
"
UPDATE_EVENT_BREAKPOINTS
"
;
exports
.
FETCH_EVENT_LISTENERS
=
"
FETCH_EVENT_LISTENERS
"
;
exports
.
TOGGLE_PRETTY_PRINT
=
"
TOGGLE_PRETTY_PRINT
"
;
exports
.
BLACKBOX
=
"
BLACKBOX
"
;
exports
.
ADD_BREAKPOINT
=
"
ADD_BREAKPOINT
"
;
exports
.
REMOVE_BREAKPOINT
=
"
REMOVE_BREAKPOINT
"
;
exports
.
ENABLE_BREAKPOINT
=
"
ENABLE_BREAKPOINT
"
;
exports
.
DISABLE_BREAKPOINT
=
"
DISABLE_BREAKPOINT
"
;
exports
.
SET_BREAKPOINT_CONDITION
=
"
SET_BREAKPOINT_CONDITION
"
;
exports
.
TOGGLE_BREAKPOINTS
=
"
TOGGLE_BREAKPOINTS
"
;
exports
.
ADD_SOURCE
=
"
ADD_SOURCE
"
;
exports
.
LOAD_SOURCE_MAP
=
"
LOAD_SOURCE_MAP
"
;
exports
.
CLOSE_TAB
=
"
CLOSE_TAB
"
;
exports
.
ADD_SOURCES
=
"
ADD_SOURCES
"
;
exports
.
LOAD_SOURCE_TEXT
=
"
LOAD_SOURCE_TEXT
"
;
exports
.
SELECT_SOURCE
=
"
SELECT_SOURCE
"
;
exports
.
SELECT_SOURCE_URL
=
"
SELECT_SOURCE_URL
"
;
exports
.
NAVIGATE
=
"
NAVIGATE
"
;
exports
.
RELOAD
=
"
RELOAD
"
;
exports
.
ADD_TABS
=
"
ADD_TABS
"
;
exports
.
SELECT_TAB
=
"
SELECT_TAB
"
;
exports
.
BREAK_ON_NEXT
=
"
BREAK_ON_NEXT
"
;
exports
.
RESUME
=
"
RESUME
"
;
exports
.
PAUSED
=
"
PAUSED
"
;
exports
.
PAUSE_ON_EXCEPTIONS
=
"
PAUSE_ON_EXCEPTIONS
"
;
exports
.
COMMAND
=
"
COMMAND
"
;
exports
.
SELECT_FRAME
=
"
SELECT_FRAME
"
;
exports
.
LOAD_OBJECT_PROPERTIES
=
"
LOAD_OBJECT_PROPERTIES
"
;
exports
.
ADD_EXPRESSION
=
"
ADD_EXPRESSION
"
;
exports
.
EVALUATE_EXPRESSION
=
"
EVALUATE_EXPRESSION
"
;
exports
.
UPDATE_EXPRESSION
=
"
UPDATE_EXPRESSION
"
;
exports
.
DELETE_EXPRESSION
=
"
DELETE_EXPRESSION
"
;
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
fromJS
=
__webpack_require__
(
192
)
;
var
I
=
__webpack_require__
(
193
)
;
var
makeRecord
=
__webpack_require__
(
194
)
;
var
State
=
makeRecord
(
{
sources
:
I
.
Map
(
)
selectedLocation
:
undefined
pendingSelectedLocation
:
undefined
sourcesText
:
I
.
Map
(
)
sourceMaps
:
I
.
Map
(
)
tabs
:
I
.
List
(
[
]
)
}
)
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
State
(
)
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
"
ADD_SOURCE
"
:
{
var
_source
=
action
.
source
;
return
state
.
mergeIn
(
[
"
sources
"
action
.
source
.
id
]
_source
)
;
}
case
"
LOAD_SOURCE_MAP
"
:
if
(
action
.
status
=
=
"
done
"
)
{
return
state
.
mergeIn
(
[
"
sourceMaps
"
action
.
source
.
id
]
action
.
value
.
sourceMap
)
;
}
break
;
case
"
SELECT_SOURCE
"
:
return
state
.
set
(
"
selectedLocation
"
{
sourceId
:
action
.
source
.
id
line
:
action
.
line
}
)
.
set
(
"
pendingSelectedLocation
"
null
)
.
merge
(
{
tabs
:
updateTabList
(
state
fromJS
(
action
.
source
)
action
.
tabIndex
)
}
)
;
case
"
SELECT_SOURCE_URL
"
:
return
state
.
set
(
"
pendingSelectedLocation
"
{
url
:
action
.
url
line
:
action
.
line
}
)
;
case
"
CLOSE_TAB
"
:
return
state
.
merge
(
{
tabs
:
removeSourceFromTabList
(
state
action
.
id
)
}
)
.
set
(
"
selectedLocation
"
{
sourceId
:
getNewSelectedSourceId
(
state
action
.
id
)
}
)
;
case
"
LOAD_SOURCE_TEXT
"
:
{
var
values
=
void
0
;
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_action
value
=
action
.
value
;
var
generatedSourceText
=
_action
value
.
generatedSourceText
;
var
originalSourceTexts
=
_action
value
.
originalSourceTexts
;
values
=
[
generatedSourceText
]
.
concat
(
_toConsumableArray
(
originalSourceTexts
)
)
;
}
else
{
var
_source2
=
action
.
source
;
values
=
[
_source2
]
;
}
return
_updateText
(
state
action
values
)
;
}
case
"
BLACKBOX
"
:
if
(
action
.
status
=
=
=
"
done
"
)
{
return
state
.
setIn
(
[
"
sources
"
action
.
source
.
id
"
isBlackBoxed
"
]
action
.
value
.
isBlackBoxed
)
;
}
break
;
case
"
TOGGLE_PRETTY_PRINT
"
:
if
(
action
.
status
=
=
=
"
done
"
)
{
return
_updateText
(
state
action
[
action
.
value
.
sourceText
]
)
.
setIn
(
[
"
sources
"
action
.
source
.
id
"
isPrettyPrinted
"
]
action
.
value
.
isPrettyPrinted
)
;
}
return
_updateText
(
state
action
[
action
.
originalSource
]
)
;
case
"
NAVIGATE
"
:
var
source
=
getSelectedSource
(
{
sources
:
state
}
)
;
var
_url
=
source
&
&
source
.
get
(
"
url
"
)
;
return
State
(
)
.
set
(
"
pendingSelectedLocation
"
{
url
:
_url
}
)
;
}
return
state
;
}
function
_updateText
(
state
action
values
)
{
if
(
action
.
status
=
=
=
"
start
"
)
{
return
values
.
reduce
(
(
_state
source
)
=
>
{
return
_state
.
mergeIn
(
[
"
sourcesText
"
source
.
id
]
{
loading
:
true
}
)
;
}
state
)
;
}
if
(
action
.
status
=
=
=
"
error
"
)
{
return
values
.
reduce
(
(
_state
source
)
=
>
{
return
_state
.
setIn
(
[
"
sourcesText
"
source
.
id
]
I
.
Map
(
{
error
:
action
.
error
}
)
)
;
}
state
)
;
}
return
values
.
reduce
(
(
_state
sourceText
)
=
>
{
return
_state
.
setIn
(
[
"
sourcesText
"
sourceText
.
id
]
I
.
Map
(
{
text
:
sourceText
.
text
contentType
:
sourceText
.
contentType
}
)
)
;
}
state
)
;
}
function
removeSourceFromTabList
(
state
id
)
{
return
state
.
tabs
.
filter
(
tab
=
>
tab
.
get
(
"
id
"
)
!
=
id
)
;
}
function
updateTabList
(
state
source
tabIndex
)
{
var
tabs
=
state
.
get
(
"
tabs
"
)
;
var
selectedSource
=
getSelectedSource
(
{
sources
:
state
}
)
;
var
selectedSourceIndex
=
tabs
.
indexOf
(
selectedSource
)
;
var
sourceIndex
=
tabs
.
indexOf
(
source
)
;
var
includesSource
=
!
!
tabs
.
find
(
t
=
>
t
.
get
(
"
id
"
)
=
=
source
.
get
(
"
id
"
)
)
;
if
(
includesSource
)
{
if
(
tabIndex
!
=
undefined
)
{
return
tabs
.
delete
(
sourceIndex
)
.
insert
(
tabIndex
source
)
;
}
return
tabs
;
}
return
tabs
.
insert
(
selectedSourceIndex
+
1
source
)
;
}
function
getNewSelectedSourceId
(
state
id
)
{
var
tabs
=
state
.
get
(
"
tabs
"
)
;
var
selectedSource
=
getSelectedSource
(
{
sources
:
state
}
)
;
if
(
selectedSource
.
get
(
"
id
"
)
!
=
id
)
{
return
selectedSource
.
get
(
"
id
"
)
;
}
var
tabIndex
=
tabs
.
findIndex
(
tab
=
>
tab
.
get
(
"
id
"
)
=
=
id
)
;
var
numTabs
=
tabs
.
count
(
)
;
if
(
numTabs
=
=
1
)
{
return
undefined
;
}
if
(
tabIndex
+
1
=
=
numTabs
)
{
return
tabs
.
get
(
tabIndex
-
1
)
.
get
(
"
id
"
)
;
}
return
tabs
.
get
(
tabIndex
+
1
)
.
get
(
"
id
"
)
;
}
function
getSource
(
state
id
)
{
return
state
.
sources
.
sources
.
get
(
id
)
;
}
function
getSourceByURL
(
state
url
)
{
return
state
.
sources
.
sources
.
find
(
source
=
>
source
.
get
(
"
url
"
)
=
=
url
)
;
}
function
getSourceById
(
state
id
)
{
return
state
.
sources
.
sources
.
find
(
source
=
>
source
.
get
(
"
id
"
)
=
=
id
)
;
}
function
getSources
(
state
)
{
return
state
.
sources
.
sources
;
}
function
getSourceText
(
state
id
)
{
return
state
.
sources
.
sourcesText
.
get
(
id
)
;
}
function
getSourceTabs
(
state
)
{
return
state
.
sources
.
tabs
;
}
function
getSelectedSource
(
state
)
{
return
state
.
sources
.
selectedLocation
&
&
getSource
(
state
state
.
sources
.
selectedLocation
.
sourceId
)
;
}
function
getSelectedLocation
(
state
)
{
return
state
.
sources
.
selectedLocation
;
}
function
getPendingSelectedLocation
(
state
)
{
return
state
.
sources
.
pendingSelectedLocation
;
}
function
getSourceMap
(
state
sourceId
)
{
return
state
.
sources
.
sourceMaps
.
get
(
sourceId
)
;
}
function
getPrettySource
(
state
id
)
{
var
source
=
getSource
(
state
id
)
;
if
(
!
source
)
{
return
;
}
return
getSourceByURL
(
state
source
.
get
(
"
url
"
)
+
"
:
formatted
"
)
;
}
module
.
exports
=
{
State
update
getSource
getSourceByURL
getSourceById
getSources
getSourceText
getSourceTabs
getSelectedSource
getSelectedLocation
getPendingSelectedLocation
getSourceMap
getPrettySource
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
Immutable
=
__webpack_require__
(
193
)
;
function
fromJS
(
value
)
{
if
(
Array
.
isArray
(
value
)
)
{
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toList
(
)
;
}
if
(
value
&
&
value
.
constructor
.
meta
)
{
var
kind
=
value
.
constructor
.
meta
.
kind
;
if
(
kind
=
=
=
"
struct
"
)
{
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toMap
(
)
;
}
else
if
(
kind
=
=
=
"
list
"
)
{
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toList
(
)
;
}
}
if
(
value
=
=
null
|
|
typeof
value
!
=
=
"
object
"
)
{
return
value
;
}
return
Immutable
.
Seq
(
value
)
.
map
(
fromJS
)
.
toMap
(
)
;
}
module
.
exports
=
fromJS
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
factory
)
{
true
?
module
.
exports
=
factory
(
)
:
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
?
define
(
factory
)
:
(
global
.
Immutable
=
factory
(
)
)
;
}
(
this
function
(
)
{
'
use
strict
'
;
var
SLICE
0
=
Array
.
prototype
.
slice
;
function
createClass
(
ctor
superClass
)
{
if
(
superClass
)
{
ctor
.
prototype
=
Object
.
create
(
superClass
.
prototype
)
;
}
ctor
.
prototype
.
constructor
=
ctor
;
}
function
Iterable
(
value
)
{
return
isIterable
(
value
)
?
value
:
Seq
(
value
)
;
}
createClass
(
KeyedIterable
Iterable
)
;
function
KeyedIterable
(
value
)
{
return
isKeyed
(
value
)
?
value
:
KeyedSeq
(
value
)
;
}
createClass
(
IndexedIterable
Iterable
)
;
function
IndexedIterable
(
value
)
{
return
isIndexed
(
value
)
?
value
:
IndexedSeq
(
value
)
;
}
createClass
(
SetIterable
Iterable
)
;
function
SetIterable
(
value
)
{
return
isIterable
(
value
)
&
&
!
isAssociative
(
value
)
?
value
:
SetSeq
(
value
)
;
}
function
isIterable
(
maybeIterable
)
{
return
!
!
(
maybeIterable
&
&
maybeIterable
[
IS_ITERABLE_SENTINEL
]
)
;
}
function
isKeyed
(
maybeKeyed
)
{
return
!
!
(
maybeKeyed
&
&
maybeKeyed
[
IS_KEYED_SENTINEL
]
)
;
}
function
isIndexed
(
maybeIndexed
)
{
return
!
!
(
maybeIndexed
&
&
maybeIndexed
[
IS_INDEXED_SENTINEL
]
)
;
}
function
isAssociative
(
maybeAssociative
)
{
return
isKeyed
(
maybeAssociative
)
|
|
isIndexed
(
maybeAssociative
)
;
}
function
isOrdered
(
maybeOrdered
)
{
return
!
!
(
maybeOrdered
&
&
maybeOrdered
[
IS_ORDERED_SENTINEL
]
)
;
}
Iterable
.
isIterable
=
isIterable
;
Iterable
.
isKeyed
=
isKeyed
;
Iterable
.
isIndexed
=
isIndexed
;
Iterable
.
isAssociative
=
isAssociative
;
Iterable
.
isOrdered
=
isOrdered
;
Iterable
.
Keyed
=
KeyedIterable
;
Iterable
.
Indexed
=
IndexedIterable
;
Iterable
.
Set
=
SetIterable
;
var
IS_ITERABLE_SENTINEL
=
'
__IMMUTABLE_ITERABLE__
'
;
var
IS_KEYED_SENTINEL
=
'
__IMMUTABLE_KEYED__
'
;
var
IS_INDEXED_SENTINEL
=
'
__IMMUTABLE_INDEXED__
'
;
var
IS_ORDERED_SENTINEL
=
'
__IMMUTABLE_ORDERED__
'
;
var
DELETE
=
'
delete
'
;
var
SHIFT
=
5
;
var
SIZE
=
1
<
<
SHIFT
;
var
MASK
=
SIZE
-
1
;
var
NOT_SET
=
{
}
;
var
CHANGE_LENGTH
=
{
value
:
false
}
;
var
DID_ALTER
=
{
value
:
false
}
;
function
MakeRef
(
ref
)
{
ref
.
value
=
false
;
return
ref
;
}
function
SetRef
(
ref
)
{
ref
&
&
(
ref
.
value
=
true
)
;
}
function
OwnerID
(
)
{
}
function
arrCopy
(
arr
offset
)
{
offset
=
offset
|
|
0
;
var
len
=
Math
.
max
(
0
arr
.
length
-
offset
)
;
var
newArr
=
new
Array
(
len
)
;
for
(
var
ii
=
0
;
ii
<
len
;
ii
+
+
)
{
newArr
[
ii
]
=
arr
[
ii
+
offset
]
;
}
return
newArr
;
}
function
ensureSize
(
iter
)
{
if
(
iter
.
size
=
=
=
undefined
)
{
iter
.
size
=
iter
.
__iterate
(
returnTrue
)
;
}
return
iter
.
size
;
}
function
wrapIndex
(
iter
index
)
{
if
(
typeof
index
!
=
=
'
number
'
)
{
var
uint32Index
=
index
>
>
>
0
;
if
(
'
'
+
uint32Index
!
=
=
index
|
|
uint32Index
=
=
=
4294967295
)
{
return
NaN
;
}
index
=
uint32Index
;
}
return
index
<
0
?
ensureSize
(
iter
)
+
index
:
index
;
}
function
returnTrue
(
)
{
return
true
;
}
function
wholeSlice
(
begin
end
size
)
{
return
(
begin
=
=
=
0
|
|
(
size
!
=
=
undefined
&
&
begin
<
=
-
size
)
)
&
&
(
end
=
=
=
undefined
|
|
(
size
!
=
=
undefined
&
&
end
>
=
size
)
)
;
}
function
resolveBegin
(
begin
size
)
{
return
resolveIndex
(
begin
size
0
)
;
}
function
resolveEnd
(
end
size
)
{
return
resolveIndex
(
end
size
size
)
;
}
function
resolveIndex
(
index
size
defaultIndex
)
{
return
index
=
=
=
undefined
?
defaultIndex
:
index
<
0
?
Math
.
max
(
0
size
+
index
)
:
size
=
=
=
undefined
?
index
:
Math
.
min
(
size
index
)
;
}
var
ITERATE_KEYS
=
0
;
var
ITERATE_VALUES
=
1
;
var
ITERATE_ENTRIES
=
2
;
var
REAL_ITERATOR_SYMBOL
=
typeof
Symbol
=
=
=
'
function
'
&
&
Symbol
.
iterator
;
var
FAUX_ITERATOR_SYMBOL
=
'
iterator
'
;
var
ITERATOR_SYMBOL
=
REAL_ITERATOR_SYMBOL
|
|
FAUX_ITERATOR_SYMBOL
;
function
Iterator
(
next
)
{
this
.
next
=
next
;
}
Iterator
.
prototype
.
toString
=
function
(
)
{
return
'
[
Iterator
]
'
;
}
;
Iterator
.
KEYS
=
ITERATE_KEYS
;
Iterator
.
VALUES
=
ITERATE_VALUES
;
Iterator
.
ENTRIES
=
ITERATE_ENTRIES
;
Iterator
.
prototype
.
inspect
=
Iterator
.
prototype
.
toSource
=
function
(
)
{
return
this
.
toString
(
)
;
}
Iterator
.
prototype
[
ITERATOR_SYMBOL
]
=
function
(
)
{
return
this
;
}
;
function
iteratorValue
(
type
k
v
iteratorResult
)
{
var
value
=
type
=
=
=
0
?
k
:
type
=
=
=
1
?
v
:
[
k
v
]
;
iteratorResult
?
(
iteratorResult
.
value
=
value
)
:
(
iteratorResult
=
{
value
:
value
done
:
false
}
)
;
return
iteratorResult
;
}
function
iteratorDone
(
)
{
return
{
value
:
undefined
done
:
true
}
;
}
function
hasIterator
(
maybeIterable
)
{
return
!
!
getIteratorFn
(
maybeIterable
)
;
}
function
isIterator
(
maybeIterator
)
{
return
maybeIterator
&
&
typeof
maybeIterator
.
next
=
=
=
'
function
'
;
}
function
getIterator
(
iterable
)
{
var
iteratorFn
=
getIteratorFn
(
iterable
)
;
return
iteratorFn
&
&
iteratorFn
.
call
(
iterable
)
;
}
function
getIteratorFn
(
iterable
)
{
var
iteratorFn
=
iterable
&
&
(
(
REAL_ITERATOR_SYMBOL
&
&
iterable
[
REAL_ITERATOR_SYMBOL
]
)
|
|
iterable
[
FAUX_ITERATOR_SYMBOL
]
)
;
if
(
typeof
iteratorFn
=
=
=
'
function
'
)
{
return
iteratorFn
;
}
}
function
isArrayLike
(
value
)
{
return
value
&
&
typeof
value
.
length
=
=
=
'
number
'
;
}
createClass
(
Seq
Iterable
)
;
function
Seq
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
:
isIterable
(
value
)
?
value
.
toSeq
(
)
:
seqFromValue
(
value
)
;
}
Seq
.
of
=
function
(
)
{
return
Seq
(
arguments
)
;
}
;
Seq
.
prototype
.
toSeq
=
function
(
)
{
return
this
;
}
;
Seq
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Seq
{
'
'
}
'
)
;
}
;
Seq
.
prototype
.
cacheResult
=
function
(
)
{
if
(
!
this
.
_cache
&
&
this
.
__iterateUncached
)
{
this
.
_cache
=
this
.
entrySeq
(
)
.
toArray
(
)
;
this
.
size
=
this
.
_cache
.
length
;
}
return
this
;
}
;
Seq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
return
seqIterate
(
this
fn
reverse
true
)
;
}
;
Seq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
seqIterator
(
this
type
reverse
true
)
;
}
;
createClass
(
KeyedSeq
Seq
)
;
function
KeyedSeq
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
.
toKeyedSeq
(
)
:
isIterable
(
value
)
?
(
isKeyed
(
value
)
?
value
.
toSeq
(
)
:
value
.
fromEntrySeq
(
)
)
:
keyedSeqFromValue
(
value
)
;
}
KeyedSeq
.
prototype
.
toKeyedSeq
=
function
(
)
{
return
this
;
}
;
createClass
(
IndexedSeq
Seq
)
;
function
IndexedSeq
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
:
!
isIterable
(
value
)
?
indexedSeqFromValue
(
value
)
:
isKeyed
(
value
)
?
value
.
entrySeq
(
)
:
value
.
toIndexedSeq
(
)
;
}
IndexedSeq
.
of
=
function
(
)
{
return
IndexedSeq
(
arguments
)
;
}
;
IndexedSeq
.
prototype
.
toIndexedSeq
=
function
(
)
{
return
this
;
}
;
IndexedSeq
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Seq
[
'
'
]
'
)
;
}
;
IndexedSeq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
return
seqIterate
(
this
fn
reverse
false
)
;
}
;
IndexedSeq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
seqIterator
(
this
type
reverse
false
)
;
}
;
createClass
(
SetSeq
Seq
)
;
function
SetSeq
(
value
)
{
return
(
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySequence
(
)
:
!
isIterable
(
value
)
?
indexedSeqFromValue
(
value
)
:
isKeyed
(
value
)
?
value
.
entrySeq
(
)
:
value
)
.
toSetSeq
(
)
;
}
SetSeq
.
of
=
function
(
)
{
return
SetSeq
(
arguments
)
;
}
;
SetSeq
.
prototype
.
toSetSeq
=
function
(
)
{
return
this
;
}
;
Seq
.
isSeq
=
isSeq
;
Seq
.
Keyed
=
KeyedSeq
;
Seq
.
Set
=
SetSeq
;
Seq
.
Indexed
=
IndexedSeq
;
var
IS_SEQ_SENTINEL
=
'
__IMMUTABLE_SEQ__
'
;
Seq
.
prototype
[
IS_SEQ_SENTINEL
]
=
true
;
createClass
(
ArraySeq
IndexedSeq
)
;
function
ArraySeq
(
array
)
{
this
.
_array
=
array
;
this
.
size
=
array
.
length
;
}
ArraySeq
.
prototype
.
get
=
function
(
index
notSetValue
)
{
return
this
.
has
(
index
)
?
this
.
_array
[
wrapIndex
(
this
index
)
]
:
notSetValue
;
}
;
ArraySeq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
array
=
this
.
_array
;
var
maxIndex
=
array
.
length
-
1
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
if
(
fn
(
array
[
reverse
?
maxIndex
-
ii
:
ii
]
ii
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
;
ArraySeq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
array
=
this
.
_array
;
var
maxIndex
=
array
.
length
-
1
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
return
ii
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
ii
array
[
reverse
?
maxIndex
-
ii
+
+
:
ii
+
+
]
)
}
)
;
}
;
createClass
(
ObjectSeq
KeyedSeq
)
;
function
ObjectSeq
(
object
)
{
var
keys
=
Object
.
keys
(
object
)
;
this
.
_object
=
object
;
this
.
_keys
=
keys
;
this
.
size
=
keys
.
length
;
}
ObjectSeq
.
prototype
.
get
=
function
(
key
notSetValue
)
{
if
(
notSetValue
!
=
=
undefined
&
&
!
this
.
has
(
key
)
)
{
return
notSetValue
;
}
return
this
.
_object
[
key
]
;
}
;
ObjectSeq
.
prototype
.
has
=
function
(
key
)
{
return
this
.
_object
.
hasOwnProperty
(
key
)
;
}
;
ObjectSeq
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
object
=
this
.
_object
;
var
keys
=
this
.
_keys
;
var
maxIndex
=
keys
.
length
-
1
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
var
key
=
keys
[
reverse
?
maxIndex
-
ii
:
ii
]
;
if
(
fn
(
object
[
key
]
key
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
;
ObjectSeq
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
object
=
this
.
_object
;
var
keys
=
this
.
_keys
;
var
maxIndex
=
keys
.
length
-
1
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
var
key
=
keys
[
reverse
?
maxIndex
-
ii
:
ii
]
;
return
ii
+
+
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
key
object
[
key
]
)
;
}
)
;
}
;
ObjectSeq
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
createClass
(
IterableSeq
IndexedSeq
)
;
function
IterableSeq
(
iterable
)
{
this
.
_iterable
=
iterable
;
this
.
size
=
iterable
.
length
|
|
iterable
.
size
;
}
IterableSeq
.
prototype
.
__iterateUncached
=
function
(
fn
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
iterable
=
this
.
_iterable
;
var
iterator
=
getIterator
(
iterable
)
;
var
iterations
=
0
;
if
(
isIterator
(
iterator
)
)
{
var
step
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
if
(
fn
(
step
.
value
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
}
}
return
iterations
;
}
;
IterableSeq
.
prototype
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterable
=
this
.
_iterable
;
var
iterator
=
getIterator
(
iterable
)
;
if
(
!
isIterator
(
iterator
)
)
{
return
new
Iterator
(
iteratorDone
)
;
}
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
iterations
+
+
step
.
value
)
;
}
)
;
}
;
createClass
(
IteratorSeq
IndexedSeq
)
;
function
IteratorSeq
(
iterator
)
{
this
.
_iterator
=
iterator
;
this
.
_iteratorCache
=
[
]
;
}
IteratorSeq
.
prototype
.
__iterateUncached
=
function
(
fn
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
iterator
=
this
.
_iterator
;
var
cache
=
this
.
_iteratorCache
;
var
iterations
=
0
;
while
(
iterations
<
cache
.
length
)
{
if
(
fn
(
cache
[
iterations
]
iterations
+
+
this
)
=
=
=
false
)
{
return
iterations
;
}
}
var
step
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
var
val
=
step
.
value
;
cache
[
iterations
]
=
val
;
if
(
fn
(
val
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
}
return
iterations
;
}
;
IteratorSeq
.
prototype
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
this
.
_iterator
;
var
cache
=
this
.
_iteratorCache
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
if
(
iterations
>
=
cache
.
length
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
cache
[
iterations
]
=
step
.
value
;
}
return
iteratorValue
(
type
iterations
cache
[
iterations
+
+
]
)
;
}
)
;
}
;
function
isSeq
(
maybeSeq
)
{
return
!
!
(
maybeSeq
&
&
maybeSeq
[
IS_SEQ_SENTINEL
]
)
;
}
var
EMPTY_SEQ
;
function
emptySequence
(
)
{
return
EMPTY_SEQ
|
|
(
EMPTY_SEQ
=
new
ArraySeq
(
[
]
)
)
;
}
function
keyedSeqFromValue
(
value
)
{
var
seq
=
Array
.
isArray
(
value
)
?
new
ArraySeq
(
value
)
.
fromEntrySeq
(
)
:
isIterator
(
value
)
?
new
IteratorSeq
(
value
)
.
fromEntrySeq
(
)
:
hasIterator
(
value
)
?
new
IterableSeq
(
value
)
.
fromEntrySeq
(
)
:
typeof
value
=
=
=
'
object
'
?
new
ObjectSeq
(
value
)
:
undefined
;
if
(
!
seq
)
{
throw
new
TypeError
(
'
Expected
Array
or
iterable
object
of
[
k
v
]
entries
'
+
'
or
keyed
object
:
'
+
value
)
;
}
return
seq
;
}
function
indexedSeqFromValue
(
value
)
{
var
seq
=
maybeIndexedSeqFromValue
(
value
)
;
if
(
!
seq
)
{
throw
new
TypeError
(
'
Expected
Array
or
iterable
object
of
values
:
'
+
value
)
;
}
return
seq
;
}
function
seqFromValue
(
value
)
{
var
seq
=
maybeIndexedSeqFromValue
(
value
)
|
|
(
typeof
value
=
=
=
'
object
'
&
&
new
ObjectSeq
(
value
)
)
;
if
(
!
seq
)
{
throw
new
TypeError
(
'
Expected
Array
or
iterable
object
of
values
or
keyed
object
:
'
+
value
)
;
}
return
seq
;
}
function
maybeIndexedSeqFromValue
(
value
)
{
return
(
isArrayLike
(
value
)
?
new
ArraySeq
(
value
)
:
isIterator
(
value
)
?
new
IteratorSeq
(
value
)
:
hasIterator
(
value
)
?
new
IterableSeq
(
value
)
:
undefined
)
;
}
function
seqIterate
(
seq
fn
reverse
useKeys
)
{
var
cache
=
seq
.
_cache
;
if
(
cache
)
{
var
maxIndex
=
cache
.
length
-
1
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
var
entry
=
cache
[
reverse
?
maxIndex
-
ii
:
ii
]
;
if
(
fn
(
entry
[
1
]
useKeys
?
entry
[
0
]
:
ii
seq
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
return
seq
.
__iterateUncached
(
fn
reverse
)
;
}
function
seqIterator
(
seq
type
reverse
useKeys
)
{
var
cache
=
seq
.
_cache
;
if
(
cache
)
{
var
maxIndex
=
cache
.
length
-
1
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
var
entry
=
cache
[
reverse
?
maxIndex
-
ii
:
ii
]
;
return
ii
+
+
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
useKeys
?
entry
[
0
]
:
ii
-
1
entry
[
1
]
)
;
}
)
;
}
return
seq
.
__iteratorUncached
(
type
reverse
)
;
}
function
fromJS
(
json
converter
)
{
return
converter
?
fromJSWith
(
converter
json
'
'
{
'
'
:
json
}
)
:
fromJSDefault
(
json
)
;
}
function
fromJSWith
(
converter
json
key
parentJSON
)
{
if
(
Array
.
isArray
(
json
)
)
{
return
converter
.
call
(
parentJSON
key
IndexedSeq
(
json
)
.
map
(
function
(
v
k
)
{
return
fromJSWith
(
converter
v
k
json
)
}
)
)
;
}
if
(
isPlainObj
(
json
)
)
{
return
converter
.
call
(
parentJSON
key
KeyedSeq
(
json
)
.
map
(
function
(
v
k
)
{
return
fromJSWith
(
converter
v
k
json
)
}
)
)
;
}
return
json
;
}
function
fromJSDefault
(
json
)
{
if
(
Array
.
isArray
(
json
)
)
{
return
IndexedSeq
(
json
)
.
map
(
fromJSDefault
)
.
toList
(
)
;
}
if
(
isPlainObj
(
json
)
)
{
return
KeyedSeq
(
json
)
.
map
(
fromJSDefault
)
.
toMap
(
)
;
}
return
json
;
}
function
isPlainObj
(
value
)
{
return
value
&
&
(
value
.
constructor
=
=
=
Object
|
|
value
.
constructor
=
=
=
undefined
)
;
}
function
is
(
valueA
valueB
)
{
if
(
valueA
=
=
=
valueB
|
|
(
valueA
!
=
=
valueA
&
&
valueB
!
=
=
valueB
)
)
{
return
true
;
}
if
(
!
valueA
|
|
!
valueB
)
{
return
false
;
}
if
(
typeof
valueA
.
valueOf
=
=
=
'
function
'
&
&
typeof
valueB
.
valueOf
=
=
=
'
function
'
)
{
valueA
=
valueA
.
valueOf
(
)
;
valueB
=
valueB
.
valueOf
(
)
;
if
(
valueA
=
=
=
valueB
|
|
(
valueA
!
=
=
valueA
&
&
valueB
!
=
=
valueB
)
)
{
return
true
;
}
if
(
!
valueA
|
|
!
valueB
)
{
return
false
;
}
}
if
(
typeof
valueA
.
equals
=
=
=
'
function
'
&
&
typeof
valueB
.
equals
=
=
=
'
function
'
&
&
valueA
.
equals
(
valueB
)
)
{
return
true
;
}
return
false
;
}
function
deepEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
!
isIterable
(
b
)
|
|
a
.
size
!
=
=
undefined
&
&
b
.
size
!
=
=
undefined
&
&
a
.
size
!
=
=
b
.
size
|
|
a
.
__hash
!
=
=
undefined
&
&
b
.
__hash
!
=
=
undefined
&
&
a
.
__hash
!
=
=
b
.
__hash
|
|
isKeyed
(
a
)
!
=
=
isKeyed
(
b
)
|
|
isIndexed
(
a
)
!
=
=
isIndexed
(
b
)
|
|
isOrdered
(
a
)
!
=
=
isOrdered
(
b
)
)
{
return
false
;
}
if
(
a
.
size
=
=
=
0
&
&
b
.
size
=
=
=
0
)
{
return
true
;
}
var
notAssociative
=
!
isAssociative
(
a
)
;
if
(
isOrdered
(
a
)
)
{
var
entries
=
a
.
entries
(
)
;
return
b
.
every
(
function
(
v
k
)
{
var
entry
=
entries
.
next
(
)
.
value
;
return
entry
&
&
is
(
entry
[
1
]
v
)
&
&
(
notAssociative
|
|
is
(
entry
[
0
]
k
)
)
;
}
)
&
&
entries
.
next
(
)
.
done
;
}
var
flipped
=
false
;
if
(
a
.
size
=
=
=
undefined
)
{
if
(
b
.
size
=
=
=
undefined
)
{
if
(
typeof
a
.
cacheResult
=
=
=
'
function
'
)
{
a
.
cacheResult
(
)
;
}
}
else
{
flipped
=
true
;
var
_
=
a
;
a
=
b
;
b
=
_
;
}
}
var
allEqual
=
true
;
var
bSize
=
b
.
__iterate
(
function
(
v
k
)
{
if
(
notAssociative
?
!
a
.
has
(
v
)
:
flipped
?
!
is
(
v
a
.
get
(
k
NOT_SET
)
)
:
!
is
(
a
.
get
(
k
NOT_SET
)
v
)
)
{
allEqual
=
false
;
return
false
;
}
}
)
;
return
allEqual
&
&
a
.
size
=
=
=
bSize
;
}
createClass
(
Repeat
IndexedSeq
)
;
function
Repeat
(
value
times
)
{
if
(
!
(
this
instanceof
Repeat
)
)
{
return
new
Repeat
(
value
times
)
;
}
this
.
_value
=
value
;
this
.
size
=
times
=
=
=
undefined
?
Infinity
:
Math
.
max
(
0
times
)
;
if
(
this
.
size
=
=
=
0
)
{
if
(
EMPTY_REPEAT
)
{
return
EMPTY_REPEAT
;
}
EMPTY_REPEAT
=
this
;
}
}
Repeat
.
prototype
.
toString
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
'
Repeat
[
]
'
;
}
return
'
Repeat
[
'
+
this
.
_value
+
'
'
+
this
.
size
+
'
times
]
'
;
}
;
Repeat
.
prototype
.
get
=
function
(
index
notSetValue
)
{
return
this
.
has
(
index
)
?
this
.
_value
:
notSetValue
;
}
;
Repeat
.
prototype
.
includes
=
function
(
searchValue
)
{
return
is
(
this
.
_value
searchValue
)
;
}
;
Repeat
.
prototype
.
slice
=
function
(
begin
end
)
{
var
size
=
this
.
size
;
return
wholeSlice
(
begin
end
size
)
?
this
:
new
Repeat
(
this
.
_value
resolveEnd
(
end
size
)
-
resolveBegin
(
begin
size
)
)
;
}
;
Repeat
.
prototype
.
reverse
=
function
(
)
{
return
this
;
}
;
Repeat
.
prototype
.
indexOf
=
function
(
searchValue
)
{
if
(
is
(
this
.
_value
searchValue
)
)
{
return
0
;
}
return
-
1
;
}
;
Repeat
.
prototype
.
lastIndexOf
=
function
(
searchValue
)
{
if
(
is
(
this
.
_value
searchValue
)
)
{
return
this
.
size
;
}
return
-
1
;
}
;
Repeat
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
for
(
var
ii
=
0
;
ii
<
this
.
size
;
ii
+
+
)
{
if
(
fn
(
this
.
_value
ii
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
}
return
ii
;
}
;
Repeat
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
this
0
=
this
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
return
ii
<
this
0
.
size
?
iteratorValue
(
type
ii
+
+
this
0
.
_value
)
:
iteratorDone
(
)
}
)
;
}
;
Repeat
.
prototype
.
equals
=
function
(
other
)
{
return
other
instanceof
Repeat
?
is
(
this
.
_value
other
.
_value
)
:
deepEqual
(
other
)
;
}
;
var
EMPTY_REPEAT
;
function
invariant
(
condition
error
)
{
if
(
!
condition
)
throw
new
Error
(
error
)
;
}
createClass
(
Range
IndexedSeq
)
;
function
Range
(
start
end
step
)
{
if
(
!
(
this
instanceof
Range
)
)
{
return
new
Range
(
start
end
step
)
;
}
invariant
(
step
!
=
=
0
'
Cannot
step
a
Range
by
0
'
)
;
start
=
start
|
|
0
;
if
(
end
=
=
=
undefined
)
{
end
=
Infinity
;
}
step
=
step
=
=
=
undefined
?
1
:
Math
.
abs
(
step
)
;
if
(
end
<
start
)
{
step
=
-
step
;
}
this
.
_start
=
start
;
this
.
_end
=
end
;
this
.
_step
=
step
;
this
.
size
=
Math
.
max
(
0
Math
.
ceil
(
(
end
-
start
)
/
step
-
1
)
+
1
)
;
if
(
this
.
size
=
=
=
0
)
{
if
(
EMPTY_RANGE
)
{
return
EMPTY_RANGE
;
}
EMPTY_RANGE
=
this
;
}
}
Range
.
prototype
.
toString
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
'
Range
[
]
'
;
}
return
'
Range
[
'
+
this
.
_start
+
'
.
.
.
'
+
this
.
_end
+
(
this
.
_step
!
=
=
1
?
'
by
'
+
this
.
_step
:
'
'
)
+
'
]
'
;
}
;
Range
.
prototype
.
get
=
function
(
index
notSetValue
)
{
return
this
.
has
(
index
)
?
this
.
_start
+
wrapIndex
(
this
index
)
*
this
.
_step
:
notSetValue
;
}
;
Range
.
prototype
.
includes
=
function
(
searchValue
)
{
var
possibleIndex
=
(
searchValue
-
this
.
_start
)
/
this
.
_step
;
return
possibleIndex
>
=
0
&
&
possibleIndex
<
this
.
size
&
&
possibleIndex
=
=
=
Math
.
floor
(
possibleIndex
)
;
}
;
Range
.
prototype
.
slice
=
function
(
begin
end
)
{
if
(
wholeSlice
(
begin
end
this
.
size
)
)
{
return
this
;
}
begin
=
resolveBegin
(
begin
this
.
size
)
;
end
=
resolveEnd
(
end
this
.
size
)
;
if
(
end
<
=
begin
)
{
return
new
Range
(
0
0
)
;
}
return
new
Range
(
this
.
get
(
begin
this
.
_end
)
this
.
get
(
end
this
.
_end
)
this
.
_step
)
;
}
;
Range
.
prototype
.
indexOf
=
function
(
searchValue
)
{
var
offsetValue
=
searchValue
-
this
.
_start
;
if
(
offsetValue
%
this
.
_step
=
=
=
0
)
{
var
index
=
offsetValue
/
this
.
_step
;
if
(
index
>
=
0
&
&
index
<
this
.
size
)
{
return
index
}
}
return
-
1
;
}
;
Range
.
prototype
.
lastIndexOf
=
function
(
searchValue
)
{
return
this
.
indexOf
(
searchValue
)
;
}
;
Range
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
maxIndex
=
this
.
size
-
1
;
var
step
=
this
.
_step
;
var
value
=
reverse
?
this
.
_start
+
maxIndex
*
step
:
this
.
_start
;
for
(
var
ii
=
0
;
ii
<
=
maxIndex
;
ii
+
+
)
{
if
(
fn
(
value
ii
this
)
=
=
=
false
)
{
return
ii
+
1
;
}
value
+
=
reverse
?
-
step
:
step
;
}
return
ii
;
}
;
Range
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
maxIndex
=
this
.
size
-
1
;
var
step
=
this
.
_step
;
var
value
=
reverse
?
this
.
_start
+
maxIndex
*
step
:
this
.
_start
;
var
ii
=
0
;
return
new
Iterator
(
function
(
)
{
var
v
=
value
;
value
+
=
reverse
?
-
step
:
step
;
return
ii
>
maxIndex
?
iteratorDone
(
)
:
iteratorValue
(
type
ii
+
+
v
)
;
}
)
;
}
;
Range
.
prototype
.
equals
=
function
(
other
)
{
return
other
instanceof
Range
?
this
.
_start
=
=
=
other
.
_start
&
&
this
.
_end
=
=
=
other
.
_end
&
&
this
.
_step
=
=
=
other
.
_step
:
deepEqual
(
this
other
)
;
}
;
var
EMPTY_RANGE
;
createClass
(
Collection
Iterable
)
;
function
Collection
(
)
{
throw
TypeError
(
'
Abstract
'
)
;
}
createClass
(
KeyedCollection
Collection
)
;
function
KeyedCollection
(
)
{
}
createClass
(
IndexedCollection
Collection
)
;
function
IndexedCollection
(
)
{
}
createClass
(
SetCollection
Collection
)
;
function
SetCollection
(
)
{
}
Collection
.
Keyed
=
KeyedCollection
;
Collection
.
Indexed
=
IndexedCollection
;
Collection
.
Set
=
SetCollection
;
var
imul
=
typeof
Math
.
imul
=
=
=
'
function
'
&
&
Math
.
imul
(
0xffffffff
2
)
=
=
=
-
2
?
Math
.
imul
:
function
imul
(
a
b
)
{
a
=
a
|
0
;
b
=
b
|
0
;
var
c
=
a
&
0xffff
;
var
d
=
b
&
0xffff
;
return
(
c
*
d
)
+
(
(
(
(
a
>
>
>
16
)
*
d
+
c
*
(
b
>
>
>
16
)
)
<
<
16
)
>
>
>
0
)
|
0
;
}
;
function
smi
(
i32
)
{
return
(
(
i32
>
>
>
1
)
&
0x40000000
)
|
(
i32
&
0xBFFFFFFF
)
;
}
function
hash
(
o
)
{
if
(
o
=
=
=
false
|
|
o
=
=
=
null
|
|
o
=
=
=
undefined
)
{
return
0
;
}
if
(
typeof
o
.
valueOf
=
=
=
'
function
'
)
{
o
=
o
.
valueOf
(
)
;
if
(
o
=
=
=
false
|
|
o
=
=
=
null
|
|
o
=
=
=
undefined
)
{
return
0
;
}
}
if
(
o
=
=
=
true
)
{
return
1
;
}
var
type
=
typeof
o
;
if
(
type
=
=
=
'
number
'
)
{
if
(
o
!
=
=
o
|
|
o
=
=
=
Infinity
)
{
return
0
;
}
var
h
=
o
|
0
;
if
(
h
!
=
=
o
)
{
h
^
=
o
*
0xFFFFFFFF
;
}
while
(
o
>
0xFFFFFFFF
)
{
o
/
=
0xFFFFFFFF
;
h
^
=
o
;
}
return
smi
(
h
)
;
}
if
(
type
=
=
=
'
string
'
)
{
return
o
.
length
>
STRING_HASH_CACHE_MIN_STRLEN
?
cachedHashString
(
o
)
:
hashString
(
o
)
;
}
if
(
typeof
o
.
hashCode
=
=
=
'
function
'
)
{
return
o
.
hashCode
(
)
;
}
if
(
type
=
=
=
'
object
'
)
{
return
hashJSObj
(
o
)
;
}
if
(
typeof
o
.
toString
=
=
=
'
function
'
)
{
return
hashString
(
o
.
toString
(
)
)
;
}
throw
new
Error
(
'
Value
type
'
+
type
+
'
cannot
be
hashed
.
'
)
;
}
function
cachedHashString
(
string
)
{
var
hash
=
stringHashCache
[
string
]
;
if
(
hash
=
=
=
undefined
)
{
hash
=
hashString
(
string
)
;
if
(
STRING_HASH_CACHE_SIZE
=
=
=
STRING_HASH_CACHE_MAX_SIZE
)
{
STRING_HASH_CACHE_SIZE
=
0
;
stringHashCache
=
{
}
;
}
STRING_HASH_CACHE_SIZE
+
+
;
stringHashCache
[
string
]
=
hash
;
}
return
hash
;
}
function
hashString
(
string
)
{
var
hash
=
0
;
for
(
var
ii
=
0
;
ii
<
string
.
length
;
ii
+
+
)
{
hash
=
31
*
hash
+
string
.
charCodeAt
(
ii
)
|
0
;
}
return
smi
(
hash
)
;
}
function
hashJSObj
(
obj
)
{
var
hash
;
if
(
usingWeakMap
)
{
hash
=
weakMap
.
get
(
obj
)
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
}
hash
=
obj
[
UID_HASH_KEY
]
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
if
(
!
canDefineProperty
)
{
hash
=
obj
.
propertyIsEnumerable
&
&
obj
.
propertyIsEnumerable
[
UID_HASH_KEY
]
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
hash
=
getIENodeHash
(
obj
)
;
if
(
hash
!
=
=
undefined
)
{
return
hash
;
}
}
hash
=
+
+
objHashUID
;
if
(
objHashUID
&
0x40000000
)
{
objHashUID
=
0
;
}
if
(
usingWeakMap
)
{
weakMap
.
set
(
obj
hash
)
;
}
else
if
(
isExtensible
!
=
=
undefined
&
&
isExtensible
(
obj
)
=
=
=
false
)
{
throw
new
Error
(
'
Non
-
extensible
objects
are
not
allowed
as
keys
.
'
)
;
}
else
if
(
canDefineProperty
)
{
Object
.
defineProperty
(
obj
UID_HASH_KEY
{
'
enumerable
'
:
false
'
configurable
'
:
false
'
writable
'
:
false
'
value
'
:
hash
}
)
;
}
else
if
(
obj
.
propertyIsEnumerable
!
=
=
undefined
&
&
obj
.
propertyIsEnumerable
=
=
=
obj
.
constructor
.
prototype
.
propertyIsEnumerable
)
{
obj
.
propertyIsEnumerable
=
function
(
)
{
return
this
.
constructor
.
prototype
.
propertyIsEnumerable
.
apply
(
this
arguments
)
;
}
;
obj
.
propertyIsEnumerable
[
UID_HASH_KEY
]
=
hash
;
}
else
if
(
obj
.
nodeType
!
=
=
undefined
)
{
obj
[
UID_HASH_KEY
]
=
hash
;
}
else
{
throw
new
Error
(
'
Unable
to
set
a
non
-
enumerable
property
on
object
.
'
)
;
}
return
hash
;
}
var
isExtensible
=
Object
.
isExtensible
;
var
canDefineProperty
=
(
function
(
)
{
try
{
Object
.
defineProperty
(
{
}
'
'
{
}
)
;
return
true
;
}
catch
(
e
)
{
return
false
;
}
}
(
)
)
;
function
getIENodeHash
(
node
)
{
if
(
node
&
&
node
.
nodeType
>
0
)
{
switch
(
node
.
nodeType
)
{
case
1
:
return
node
.
uniqueID
;
case
9
:
return
node
.
documentElement
&
&
node
.
documentElement
.
uniqueID
;
}
}
}
var
usingWeakMap
=
typeof
WeakMap
=
=
=
'
function
'
;
var
weakMap
;
if
(
usingWeakMap
)
{
weakMap
=
new
WeakMap
(
)
;
}
var
objHashUID
=
0
;
var
UID_HASH_KEY
=
'
__immutablehash__
'
;
if
(
typeof
Symbol
=
=
=
'
function
'
)
{
UID_HASH_KEY
=
Symbol
(
UID_HASH_KEY
)
;
}
var
STRING_HASH_CACHE_MIN_STRLEN
=
16
;
var
STRING_HASH_CACHE_MAX_SIZE
=
255
;
var
STRING_HASH_CACHE_SIZE
=
0
;
var
stringHashCache
=
{
}
;
function
assertNotInfinite
(
size
)
{
invariant
(
size
!
=
=
Infinity
'
Cannot
perform
this
action
with
an
infinite
size
.
'
)
;
}
createClass
(
Map
KeyedCollection
)
;
function
Map
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyMap
(
)
:
isMap
(
value
)
&
&
!
isOrdered
(
value
)
?
value
:
emptyMap
(
)
.
withMutations
(
function
(
map
)
{
var
iter
=
KeyedIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
k
)
{
return
map
.
set
(
k
v
)
}
)
;
}
)
;
}
Map
.
of
=
function
(
)
{
var
keyValues
=
SLICE
0
.
call
(
arguments
0
)
;
return
emptyMap
(
)
.
withMutations
(
function
(
map
)
{
for
(
var
i
=
0
;
i
<
keyValues
.
length
;
i
+
=
2
)
{
if
(
i
+
1
>
=
keyValues
.
length
)
{
throw
new
Error
(
'
Missing
value
for
key
:
'
+
keyValues
[
i
]
)
;
}
map
.
set
(
keyValues
[
i
]
keyValues
[
i
+
1
]
)
;
}
}
)
;
}
;
Map
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Map
{
'
'
}
'
)
;
}
;
Map
.
prototype
.
get
=
function
(
k
notSetValue
)
{
return
this
.
_root
?
this
.
_root
.
get
(
0
undefined
k
notSetValue
)
:
notSetValue
;
}
;
Map
.
prototype
.
set
=
function
(
k
v
)
{
return
updateMap
(
this
k
v
)
;
}
;
Map
.
prototype
.
setIn
=
function
(
keyPath
v
)
{
return
this
.
updateIn
(
keyPath
NOT_SET
function
(
)
{
return
v
}
)
;
}
;
Map
.
prototype
.
remove
=
function
(
k
)
{
return
updateMap
(
this
k
NOT_SET
)
;
}
;
Map
.
prototype
.
deleteIn
=
function
(
keyPath
)
{
return
this
.
updateIn
(
keyPath
function
(
)
{
return
NOT_SET
}
)
;
}
;
Map
.
prototype
.
update
=
function
(
k
notSetValue
updater
)
{
return
arguments
.
length
=
=
=
1
?
k
(
this
)
:
this
.
updateIn
(
[
k
]
notSetValue
updater
)
;
}
;
Map
.
prototype
.
updateIn
=
function
(
keyPath
notSetValue
updater
)
{
if
(
!
updater
)
{
updater
=
notSetValue
;
notSetValue
=
undefined
;
}
var
updatedValue
=
updateInDeepMap
(
this
forceIterator
(
keyPath
)
notSetValue
updater
)
;
return
updatedValue
=
=
=
NOT_SET
?
undefined
:
updatedValue
;
}
;
Map
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
0
;
this
.
_root
=
null
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
emptyMap
(
)
;
}
;
Map
.
prototype
.
merge
=
function
(
)
{
return
mergeIntoMapWith
(
this
undefined
arguments
)
;
}
;
Map
.
prototype
.
mergeWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoMapWith
(
this
merger
iters
)
;
}
;
Map
.
prototype
.
mergeIn
=
function
(
keyPath
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
this
.
updateIn
(
keyPath
emptyMap
(
)
function
(
m
)
{
return
typeof
m
.
merge
=
=
=
'
function
'
?
m
.
merge
.
apply
(
m
iters
)
:
iters
[
iters
.
length
-
1
]
}
)
;
}
;
Map
.
prototype
.
mergeDeep
=
function
(
)
{
return
mergeIntoMapWith
(
this
deepMerger
arguments
)
;
}
;
Map
.
prototype
.
mergeDeepWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoMapWith
(
this
deepMergerWith
(
merger
)
iters
)
;
}
;
Map
.
prototype
.
mergeDeepIn
=
function
(
keyPath
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
this
.
updateIn
(
keyPath
emptyMap
(
)
function
(
m
)
{
return
typeof
m
.
mergeDeep
=
=
=
'
function
'
?
m
.
mergeDeep
.
apply
(
m
iters
)
:
iters
[
iters
.
length
-
1
]
}
)
;
}
;
Map
.
prototype
.
sort
=
function
(
comparator
)
{
return
OrderedMap
(
sortFactory
(
this
comparator
)
)
;
}
;
Map
.
prototype
.
sortBy
=
function
(
mapper
comparator
)
{
return
OrderedMap
(
sortFactory
(
this
comparator
mapper
)
)
;
}
;
Map
.
prototype
.
withMutations
=
function
(
fn
)
{
var
mutable
=
this
.
asMutable
(
)
;
fn
(
mutable
)
;
return
mutable
.
wasAltered
(
)
?
mutable
.
__ensureOwner
(
this
.
__ownerID
)
:
this
;
}
;
Map
.
prototype
.
asMutable
=
function
(
)
{
return
this
.
__ownerID
?
this
:
this
.
__ensureOwner
(
new
OwnerID
(
)
)
;
}
;
Map
.
prototype
.
asImmutable
=
function
(
)
{
return
this
.
__ensureOwner
(
)
;
}
;
Map
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
__altered
;
}
;
Map
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
new
MapIterator
(
this
type
reverse
)
;
}
;
Map
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
this
.
_root
&
&
this
.
_root
.
iterate
(
function
(
entry
)
{
iterations
+
+
;
return
fn
(
entry
[
1
]
entry
[
0
]
this
0
)
;
}
reverse
)
;
return
iterations
;
}
;
Map
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
__altered
=
false
;
return
this
;
}
return
makeMap
(
this
.
size
this
.
_root
ownerID
this
.
__hash
)
;
}
;
function
isMap
(
maybeMap
)
{
return
!
!
(
maybeMap
&
&
maybeMap
[
IS_MAP_SENTINEL
]
)
;
}
Map
.
isMap
=
isMap
;
var
IS_MAP_SENTINEL
=
'
__IMMUTABLE_MAP__
'
;
var
MapPrototype
=
Map
.
prototype
;
MapPrototype
[
IS_MAP_SENTINEL
]
=
true
;
MapPrototype
[
DELETE
]
=
MapPrototype
.
remove
;
MapPrototype
.
removeIn
=
MapPrototype
.
deleteIn
;
function
ArrayMapNode
(
ownerID
entries
)
{
this
.
ownerID
=
ownerID
;
this
.
entries
=
entries
;
}
ArrayMapNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
var
entries
=
this
.
entries
;
for
(
var
ii
=
0
len
=
entries
.
length
;
ii
<
len
;
ii
+
+
)
{
if
(
is
(
key
entries
[
ii
]
[
0
]
)
)
{
return
entries
[
ii
]
[
1
]
;
}
}
return
notSetValue
;
}
;
ArrayMapNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
var
removed
=
value
=
=
=
NOT_SET
;
var
entries
=
this
.
entries
;
var
idx
=
0
;
for
(
var
len
=
entries
.
length
;
idx
<
len
;
idx
+
+
)
{
if
(
is
(
key
entries
[
idx
]
[
0
]
)
)
{
break
;
}
}
var
exists
=
idx
<
len
;
if
(
exists
?
entries
[
idx
]
[
1
]
=
=
=
value
:
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
(
removed
|
|
!
exists
)
&
&
SetRef
(
didChangeSize
)
;
if
(
removed
&
&
entries
.
length
=
=
=
1
)
{
return
;
}
if
(
!
exists
&
&
!
removed
&
&
entries
.
length
>
=
MAX_ARRAY_MAP_SIZE
)
{
return
createNodes
(
ownerID
entries
key
value
)
;
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newEntries
=
isEditable
?
entries
:
arrCopy
(
entries
)
;
if
(
exists
)
{
if
(
removed
)
{
idx
=
=
=
len
-
1
?
newEntries
.
pop
(
)
:
(
newEntries
[
idx
]
=
newEntries
.
pop
(
)
)
;
}
else
{
newEntries
[
idx
]
=
[
key
value
]
;
}
}
else
{
newEntries
.
push
(
[
key
value
]
)
;
}
if
(
isEditable
)
{
this
.
entries
=
newEntries
;
return
this
;
}
return
new
ArrayMapNode
(
ownerID
newEntries
)
;
}
;
function
BitmapIndexedNode
(
ownerID
bitmap
nodes
)
{
this
.
ownerID
=
ownerID
;
this
.
bitmap
=
bitmap
;
this
.
nodes
=
nodes
;
}
BitmapIndexedNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
bit
=
(
1
<
<
(
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
)
)
;
var
bitmap
=
this
.
bitmap
;
return
(
bitmap
&
bit
)
=
=
=
0
?
notSetValue
:
this
.
nodes
[
popCount
(
bitmap
&
(
bit
-
1
)
)
]
.
get
(
shift
+
SHIFT
keyHash
key
notSetValue
)
;
}
;
BitmapIndexedNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
keyHashFrag
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
bit
=
1
<
<
keyHashFrag
;
var
bitmap
=
this
.
bitmap
;
var
exists
=
(
bitmap
&
bit
)
!
=
=
0
;
if
(
!
exists
&
&
value
=
=
=
NOT_SET
)
{
return
this
;
}
var
idx
=
popCount
(
bitmap
&
(
bit
-
1
)
)
;
var
nodes
=
this
.
nodes
;
var
node
=
exists
?
nodes
[
idx
]
:
undefined
;
var
newNode
=
updateNode
(
node
ownerID
shift
+
SHIFT
keyHash
key
value
didChangeSize
didAlter
)
;
if
(
newNode
=
=
=
node
)
{
return
this
;
}
if
(
!
exists
&
&
newNode
&
&
nodes
.
length
>
=
MAX_BITMAP_INDEXED_SIZE
)
{
return
expandNodes
(
ownerID
nodes
bitmap
keyHashFrag
newNode
)
;
}
if
(
exists
&
&
!
newNode
&
&
nodes
.
length
=
=
=
2
&
&
isLeafNode
(
nodes
[
idx
^
1
]
)
)
{
return
nodes
[
idx
^
1
]
;
}
if
(
exists
&
&
newNode
&
&
nodes
.
length
=
=
=
1
&
&
isLeafNode
(
newNode
)
)
{
return
newNode
;
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newBitmap
=
exists
?
newNode
?
bitmap
:
bitmap
^
bit
:
bitmap
|
bit
;
var
newNodes
=
exists
?
newNode
?
setIn
(
nodes
idx
newNode
isEditable
)
:
spliceOut
(
nodes
idx
isEditable
)
:
spliceIn
(
nodes
idx
newNode
isEditable
)
;
if
(
isEditable
)
{
this
.
bitmap
=
newBitmap
;
this
.
nodes
=
newNodes
;
return
this
;
}
return
new
BitmapIndexedNode
(
ownerID
newBitmap
newNodes
)
;
}
;
function
HashArrayMapNode
(
ownerID
count
nodes
)
{
this
.
ownerID
=
ownerID
;
this
.
count
=
count
;
this
.
nodes
=
nodes
;
}
HashArrayMapNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
idx
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
node
=
this
.
nodes
[
idx
]
;
return
node
?
node
.
get
(
shift
+
SHIFT
keyHash
key
notSetValue
)
:
notSetValue
;
}
;
HashArrayMapNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
idx
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
removed
=
value
=
=
=
NOT_SET
;
var
nodes
=
this
.
nodes
;
var
node
=
nodes
[
idx
]
;
if
(
removed
&
&
!
node
)
{
return
this
;
}
var
newNode
=
updateNode
(
node
ownerID
shift
+
SHIFT
keyHash
key
value
didChangeSize
didAlter
)
;
if
(
newNode
=
=
=
node
)
{
return
this
;
}
var
newCount
=
this
.
count
;
if
(
!
node
)
{
newCount
+
+
;
}
else
if
(
!
newNode
)
{
newCount
-
-
;
if
(
newCount
<
MIN_HASH_ARRAY_MAP_SIZE
)
{
return
packNodes
(
ownerID
nodes
newCount
idx
)
;
}
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newNodes
=
setIn
(
nodes
idx
newNode
isEditable
)
;
if
(
isEditable
)
{
this
.
count
=
newCount
;
this
.
nodes
=
newNodes
;
return
this
;
}
return
new
HashArrayMapNode
(
ownerID
newCount
newNodes
)
;
}
;
function
HashCollisionNode
(
ownerID
keyHash
entries
)
{
this
.
ownerID
=
ownerID
;
this
.
keyHash
=
keyHash
;
this
.
entries
=
entries
;
}
HashCollisionNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
var
entries
=
this
.
entries
;
for
(
var
ii
=
0
len
=
entries
.
length
;
ii
<
len
;
ii
+
+
)
{
if
(
is
(
key
entries
[
ii
]
[
0
]
)
)
{
return
entries
[
ii
]
[
1
]
;
}
}
return
notSetValue
;
}
;
HashCollisionNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
keyHash
=
=
=
undefined
)
{
keyHash
=
hash
(
key
)
;
}
var
removed
=
value
=
=
=
NOT_SET
;
if
(
keyHash
!
=
=
this
.
keyHash
)
{
if
(
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
SetRef
(
didChangeSize
)
;
return
mergeIntoNode
(
this
ownerID
shift
keyHash
[
key
value
]
)
;
}
var
entries
=
this
.
entries
;
var
idx
=
0
;
for
(
var
len
=
entries
.
length
;
idx
<
len
;
idx
+
+
)
{
if
(
is
(
key
entries
[
idx
]
[
0
]
)
)
{
break
;
}
}
var
exists
=
idx
<
len
;
if
(
exists
?
entries
[
idx
]
[
1
]
=
=
=
value
:
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
(
removed
|
|
!
exists
)
&
&
SetRef
(
didChangeSize
)
;
if
(
removed
&
&
len
=
=
=
2
)
{
return
new
ValueNode
(
ownerID
this
.
keyHash
entries
[
idx
^
1
]
)
;
}
var
isEditable
=
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
;
var
newEntries
=
isEditable
?
entries
:
arrCopy
(
entries
)
;
if
(
exists
)
{
if
(
removed
)
{
idx
=
=
=
len
-
1
?
newEntries
.
pop
(
)
:
(
newEntries
[
idx
]
=
newEntries
.
pop
(
)
)
;
}
else
{
newEntries
[
idx
]
=
[
key
value
]
;
}
}
else
{
newEntries
.
push
(
[
key
value
]
)
;
}
if
(
isEditable
)
{
this
.
entries
=
newEntries
;
return
this
;
}
return
new
HashCollisionNode
(
ownerID
this
.
keyHash
newEntries
)
;
}
;
function
ValueNode
(
ownerID
keyHash
entry
)
{
this
.
ownerID
=
ownerID
;
this
.
keyHash
=
keyHash
;
this
.
entry
=
entry
;
}
ValueNode
.
prototype
.
get
=
function
(
shift
keyHash
key
notSetValue
)
{
return
is
(
key
this
.
entry
[
0
]
)
?
this
.
entry
[
1
]
:
notSetValue
;
}
;
ValueNode
.
prototype
.
update
=
function
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
var
removed
=
value
=
=
=
NOT_SET
;
var
keyMatch
=
is
(
key
this
.
entry
[
0
]
)
;
if
(
keyMatch
?
value
=
=
=
this
.
entry
[
1
]
:
removed
)
{
return
this
;
}
SetRef
(
didAlter
)
;
if
(
removed
)
{
SetRef
(
didChangeSize
)
;
return
;
}
if
(
keyMatch
)
{
if
(
ownerID
&
&
ownerID
=
=
=
this
.
ownerID
)
{
this
.
entry
[
1
]
=
value
;
return
this
;
}
return
new
ValueNode
(
ownerID
this
.
keyHash
[
key
value
]
)
;
}
SetRef
(
didChangeSize
)
;
return
mergeIntoNode
(
this
ownerID
shift
hash
(
key
)
[
key
value
]
)
;
}
;
ArrayMapNode
.
prototype
.
iterate
=
HashCollisionNode
.
prototype
.
iterate
=
function
(
fn
reverse
)
{
var
entries
=
this
.
entries
;
for
(
var
ii
=
0
maxIndex
=
entries
.
length
-
1
;
ii
<
=
maxIndex
;
ii
+
+
)
{
if
(
fn
(
entries
[
reverse
?
maxIndex
-
ii
:
ii
]
)
=
=
=
false
)
{
return
false
;
}
}
}
BitmapIndexedNode
.
prototype
.
iterate
=
HashArrayMapNode
.
prototype
.
iterate
=
function
(
fn
reverse
)
{
var
nodes
=
this
.
nodes
;
for
(
var
ii
=
0
maxIndex
=
nodes
.
length
-
1
;
ii
<
=
maxIndex
;
ii
+
+
)
{
var
node
=
nodes
[
reverse
?
maxIndex
-
ii
:
ii
]
;
if
(
node
&
&
node
.
iterate
(
fn
reverse
)
=
=
=
false
)
{
return
false
;
}
}
}
ValueNode
.
prototype
.
iterate
=
function
(
fn
reverse
)
{
return
fn
(
this
.
entry
)
;
}
createClass
(
MapIterator
Iterator
)
;
function
MapIterator
(
map
type
reverse
)
{
this
.
_type
=
type
;
this
.
_reverse
=
reverse
;
this
.
_stack
=
map
.
_root
&
&
mapIteratorFrame
(
map
.
_root
)
;
}
MapIterator
.
prototype
.
next
=
function
(
)
{
var
type
=
this
.
_type
;
var
stack
=
this
.
_stack
;
while
(
stack
)
{
var
node
=
stack
.
node
;
var
index
=
stack
.
index
+
+
;
var
maxIndex
;
if
(
node
.
entry
)
{
if
(
index
=
=
=
0
)
{
return
mapIteratorValue
(
type
node
.
entry
)
;
}
}
else
if
(
node
.
entries
)
{
maxIndex
=
node
.
entries
.
length
-
1
;
if
(
index
<
=
maxIndex
)
{
return
mapIteratorValue
(
type
node
.
entries
[
this
.
_reverse
?
maxIndex
-
index
:
index
]
)
;
}
}
else
{
maxIndex
=
node
.
nodes
.
length
-
1
;
if
(
index
<
=
maxIndex
)
{
var
subNode
=
node
.
nodes
[
this
.
_reverse
?
maxIndex
-
index
:
index
]
;
if
(
subNode
)
{
if
(
subNode
.
entry
)
{
return
mapIteratorValue
(
type
subNode
.
entry
)
;
}
stack
=
this
.
_stack
=
mapIteratorFrame
(
subNode
stack
)
;
}
continue
;
}
}
stack
=
this
.
_stack
=
this
.
_stack
.
__prev
;
}
return
iteratorDone
(
)
;
}
;
function
mapIteratorValue
(
type
entry
)
{
return
iteratorValue
(
type
entry
[
0
]
entry
[
1
]
)
;
}
function
mapIteratorFrame
(
node
prev
)
{
return
{
node
:
node
index
:
0
__prev
:
prev
}
;
}
function
makeMap
(
size
root
ownerID
hash
)
{
var
map
=
Object
.
create
(
MapPrototype
)
;
map
.
size
=
size
;
map
.
_root
=
root
;
map
.
__ownerID
=
ownerID
;
map
.
__hash
=
hash
;
map
.
__altered
=
false
;
return
map
;
}
var
EMPTY_MAP
;
function
emptyMap
(
)
{
return
EMPTY_MAP
|
|
(
EMPTY_MAP
=
makeMap
(
0
)
)
;
}
function
updateMap
(
map
k
v
)
{
var
newRoot
;
var
newSize
;
if
(
!
map
.
_root
)
{
if
(
v
=
=
=
NOT_SET
)
{
return
map
;
}
newSize
=
1
;
newRoot
=
new
ArrayMapNode
(
map
.
__ownerID
[
[
k
v
]
]
)
;
}
else
{
var
didChangeSize
=
MakeRef
(
CHANGE_LENGTH
)
;
var
didAlter
=
MakeRef
(
DID_ALTER
)
;
newRoot
=
updateNode
(
map
.
_root
map
.
__ownerID
0
undefined
k
v
didChangeSize
didAlter
)
;
if
(
!
didAlter
.
value
)
{
return
map
;
}
newSize
=
map
.
size
+
(
didChangeSize
.
value
?
v
=
=
=
NOT_SET
?
-
1
:
1
:
0
)
;
}
if
(
map
.
__ownerID
)
{
map
.
size
=
newSize
;
map
.
_root
=
newRoot
;
map
.
__hash
=
undefined
;
map
.
__altered
=
true
;
return
map
;
}
return
newRoot
?
makeMap
(
newSize
newRoot
)
:
emptyMap
(
)
;
}
function
updateNode
(
node
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
{
if
(
!
node
)
{
if
(
value
=
=
=
NOT_SET
)
{
return
node
;
}
SetRef
(
didAlter
)
;
SetRef
(
didChangeSize
)
;
return
new
ValueNode
(
ownerID
keyHash
[
key
value
]
)
;
}
return
node
.
update
(
ownerID
shift
keyHash
key
value
didChangeSize
didAlter
)
;
}
function
isLeafNode
(
node
)
{
return
node
.
constructor
=
=
=
ValueNode
|
|
node
.
constructor
=
=
=
HashCollisionNode
;
}
function
mergeIntoNode
(
node
ownerID
shift
keyHash
entry
)
{
if
(
node
.
keyHash
=
=
=
keyHash
)
{
return
new
HashCollisionNode
(
ownerID
keyHash
[
node
.
entry
entry
]
)
;
}
var
idx1
=
(
shift
=
=
=
0
?
node
.
keyHash
:
node
.
keyHash
>
>
>
shift
)
&
MASK
;
var
idx2
=
(
shift
=
=
=
0
?
keyHash
:
keyHash
>
>
>
shift
)
&
MASK
;
var
newNode
;
var
nodes
=
idx1
=
=
=
idx2
?
[
mergeIntoNode
(
node
ownerID
shift
+
SHIFT
keyHash
entry
)
]
:
(
(
newNode
=
new
ValueNode
(
ownerID
keyHash
entry
)
)
idx1
<
idx2
?
[
node
newNode
]
:
[
newNode
node
]
)
;
return
new
BitmapIndexedNode
(
ownerID
(
1
<
<
idx1
)
|
(
1
<
<
idx2
)
nodes
)
;
}
function
createNodes
(
ownerID
entries
key
value
)
{
if
(
!
ownerID
)
{
ownerID
=
new
OwnerID
(
)
;
}
var
node
=
new
ValueNode
(
ownerID
hash
(
key
)
[
key
value
]
)
;
for
(
var
ii
=
0
;
ii
<
entries
.
length
;
ii
+
+
)
{
var
entry
=
entries
[
ii
]
;
node
=
node
.
update
(
ownerID
0
undefined
entry
[
0
]
entry
[
1
]
)
;
}
return
node
;
}
function
packNodes
(
ownerID
nodes
count
excluding
)
{
var
bitmap
=
0
;
var
packedII
=
0
;
var
packedNodes
=
new
Array
(
count
)
;
for
(
var
ii
=
0
bit
=
1
len
=
nodes
.
length
;
ii
<
len
;
ii
+
+
bit
<
<
=
1
)
{
var
node
=
nodes
[
ii
]
;
if
(
node
!
=
=
undefined
&
&
ii
!
=
=
excluding
)
{
bitmap
|
=
bit
;
packedNodes
[
packedII
+
+
]
=
node
;
}
}
return
new
BitmapIndexedNode
(
ownerID
bitmap
packedNodes
)
;
}
function
expandNodes
(
ownerID
nodes
bitmap
including
node
)
{
var
count
=
0
;
var
expandedNodes
=
new
Array
(
SIZE
)
;
for
(
var
ii
=
0
;
bitmap
!
=
=
0
;
ii
+
+
bitmap
>
>
>
=
1
)
{
expandedNodes
[
ii
]
=
bitmap
&
1
?
nodes
[
count
+
+
]
:
undefined
;
}
expandedNodes
[
including
]
=
node
;
return
new
HashArrayMapNode
(
ownerID
count
+
1
expandedNodes
)
;
}
function
mergeIntoMapWith
(
map
merger
iterables
)
{
var
iters
=
[
]
;
for
(
var
ii
=
0
;
ii
<
iterables
.
length
;
ii
+
+
)
{
var
value
=
iterables
[
ii
]
;
var
iter
=
KeyedIterable
(
value
)
;
if
(
!
isIterable
(
value
)
)
{
iter
=
iter
.
map
(
function
(
v
)
{
return
fromJS
(
v
)
}
)
;
}
iters
.
push
(
iter
)
;
}
return
mergeIntoCollectionWith
(
map
merger
iters
)
;
}
function
deepMerger
(
existing
value
key
)
{
return
existing
&
&
existing
.
mergeDeep
&
&
isIterable
(
value
)
?
existing
.
mergeDeep
(
value
)
:
is
(
existing
value
)
?
existing
:
value
;
}
function
deepMergerWith
(
merger
)
{
return
function
(
existing
value
key
)
{
if
(
existing
&
&
existing
.
mergeDeepWith
&
&
isIterable
(
value
)
)
{
return
existing
.
mergeDeepWith
(
merger
value
)
;
}
var
nextValue
=
merger
(
existing
value
key
)
;
return
is
(
existing
nextValue
)
?
existing
:
nextValue
;
}
;
}
function
mergeIntoCollectionWith
(
collection
merger
iters
)
{
iters
=
iters
.
filter
(
function
(
x
)
{
return
x
.
size
!
=
=
0
}
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
collection
;
}
if
(
collection
.
size
=
=
=
0
&
&
!
collection
.
__ownerID
&
&
iters
.
length
=
=
=
1
)
{
return
collection
.
constructor
(
iters
[
0
]
)
;
}
return
collection
.
withMutations
(
function
(
collection
)
{
var
mergeIntoMap
=
merger
?
function
(
value
key
)
{
collection
.
update
(
key
NOT_SET
function
(
existing
)
{
return
existing
=
=
=
NOT_SET
?
value
:
merger
(
existing
value
key
)
}
)
;
}
:
function
(
value
key
)
{
collection
.
set
(
key
value
)
;
}
for
(
var
ii
=
0
;
ii
<
iters
.
length
;
ii
+
+
)
{
iters
[
ii
]
.
forEach
(
mergeIntoMap
)
;
}
}
)
;
}
function
updateInDeepMap
(
existing
keyPathIter
notSetValue
updater
)
{
var
isNotSet
=
existing
=
=
=
NOT_SET
;
var
step
=
keyPathIter
.
next
(
)
;
if
(
step
.
done
)
{
var
existingValue
=
isNotSet
?
notSetValue
:
existing
;
var
newValue
=
updater
(
existingValue
)
;
return
newValue
=
=
=
existingValue
?
existing
:
newValue
;
}
invariant
(
isNotSet
|
|
(
existing
&
&
existing
.
set
)
'
invalid
keyPath
'
)
;
var
key
=
step
.
value
;
var
nextExisting
=
isNotSet
?
NOT_SET
:
existing
.
get
(
key
NOT_SET
)
;
var
nextUpdated
=
updateInDeepMap
(
nextExisting
keyPathIter
notSetValue
updater
)
;
return
nextUpdated
=
=
=
nextExisting
?
existing
:
nextUpdated
=
=
=
NOT_SET
?
existing
.
remove
(
key
)
:
(
isNotSet
?
emptyMap
(
)
:
existing
)
.
set
(
key
nextUpdated
)
;
}
function
popCount
(
x
)
{
x
=
x
-
(
(
x
>
>
1
)
&
0x55555555
)
;
x
=
(
x
&
0x33333333
)
+
(
(
x
>
>
2
)
&
0x33333333
)
;
x
=
(
x
+
(
x
>
>
4
)
)
&
0x0f0f0f0f
;
x
=
x
+
(
x
>
>
8
)
;
x
=
x
+
(
x
>
>
16
)
;
return
x
&
0x7f
;
}
function
setIn
(
array
idx
val
canEdit
)
{
var
newArray
=
canEdit
?
array
:
arrCopy
(
array
)
;
newArray
[
idx
]
=
val
;
return
newArray
;
}
function
spliceIn
(
array
idx
val
canEdit
)
{
var
newLen
=
array
.
length
+
1
;
if
(
canEdit
&
&
idx
+
1
=
=
=
newLen
)
{
array
[
idx
]
=
val
;
return
array
;
}
var
newArray
=
new
Array
(
newLen
)
;
var
after
=
0
;
for
(
var
ii
=
0
;
ii
<
newLen
;
ii
+
+
)
{
if
(
ii
=
=
=
idx
)
{
newArray
[
ii
]
=
val
;
after
=
-
1
;
}
else
{
newArray
[
ii
]
=
array
[
ii
+
after
]
;
}
}
return
newArray
;
}
function
spliceOut
(
array
idx
canEdit
)
{
var
newLen
=
array
.
length
-
1
;
if
(
canEdit
&
&
idx
=
=
=
newLen
)
{
array
.
pop
(
)
;
return
array
;
}
var
newArray
=
new
Array
(
newLen
)
;
var
after
=
0
;
for
(
var
ii
=
0
;
ii
<
newLen
;
ii
+
+
)
{
if
(
ii
=
=
=
idx
)
{
after
=
1
;
}
newArray
[
ii
]
=
array
[
ii
+
after
]
;
}
return
newArray
;
}
var
MAX_ARRAY_MAP_SIZE
=
SIZE
/
4
;
var
MAX_BITMAP_INDEXED_SIZE
=
SIZE
/
2
;
var
MIN_HASH_ARRAY_MAP_SIZE
=
SIZE
/
4
;
createClass
(
List
IndexedCollection
)
;
function
List
(
value
)
{
var
empty
=
emptyList
(
)
;
if
(
value
=
=
=
null
|
|
value
=
=
=
undefined
)
{
return
empty
;
}
if
(
isList
(
value
)
)
{
return
value
;
}
var
iter
=
IndexedIterable
(
value
)
;
var
size
=
iter
.
size
;
if
(
size
=
=
=
0
)
{
return
empty
;
}
assertNotInfinite
(
size
)
;
if
(
size
>
0
&
&
size
<
SIZE
)
{
return
makeList
(
0
size
SHIFT
null
new
VNode
(
iter
.
toArray
(
)
)
)
;
}
return
empty
.
withMutations
(
function
(
list
)
{
list
.
setSize
(
size
)
;
iter
.
forEach
(
function
(
v
i
)
{
return
list
.
set
(
i
v
)
}
)
;
}
)
;
}
List
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
List
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
List
[
'
'
]
'
)
;
}
;
List
.
prototype
.
get
=
function
(
index
notSetValue
)
{
index
=
wrapIndex
(
this
index
)
;
if
(
index
>
=
0
&
&
index
<
this
.
size
)
{
index
+
=
this
.
_origin
;
var
node
=
listNodeFor
(
this
index
)
;
return
node
&
&
node
.
array
[
index
&
MASK
]
;
}
return
notSetValue
;
}
;
List
.
prototype
.
set
=
function
(
index
value
)
{
return
updateList
(
this
index
value
)
;
}
;
List
.
prototype
.
remove
=
function
(
index
)
{
return
!
this
.
has
(
index
)
?
this
:
index
=
=
=
0
?
this
.
shift
(
)
:
index
=
=
=
this
.
size
-
1
?
this
.
pop
(
)
:
this
.
splice
(
index
1
)
;
}
;
List
.
prototype
.
insert
=
function
(
index
value
)
{
return
this
.
splice
(
index
0
value
)
;
}
;
List
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
this
.
_origin
=
this
.
_capacity
=
0
;
this
.
_level
=
SHIFT
;
this
.
_root
=
this
.
_tail
=
null
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
emptyList
(
)
;
}
;
List
.
prototype
.
push
=
function
(
)
{
var
values
=
arguments
;
var
oldSize
=
this
.
size
;
return
this
.
withMutations
(
function
(
list
)
{
setListBounds
(
list
0
oldSize
+
values
.
length
)
;
for
(
var
ii
=
0
;
ii
<
values
.
length
;
ii
+
+
)
{
list
.
set
(
oldSize
+
ii
values
[
ii
]
)
;
}
}
)
;
}
;
List
.
prototype
.
pop
=
function
(
)
{
return
setListBounds
(
this
0
-
1
)
;
}
;
List
.
prototype
.
unshift
=
function
(
)
{
var
values
=
arguments
;
return
this
.
withMutations
(
function
(
list
)
{
setListBounds
(
list
-
values
.
length
)
;
for
(
var
ii
=
0
;
ii
<
values
.
length
;
ii
+
+
)
{
list
.
set
(
ii
values
[
ii
]
)
;
}
}
)
;
}
;
List
.
prototype
.
shift
=
function
(
)
{
return
setListBounds
(
this
1
)
;
}
;
List
.
prototype
.
merge
=
function
(
)
{
return
mergeIntoListWith
(
this
undefined
arguments
)
;
}
;
List
.
prototype
.
mergeWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoListWith
(
this
merger
iters
)
;
}
;
List
.
prototype
.
mergeDeep
=
function
(
)
{
return
mergeIntoListWith
(
this
deepMerger
arguments
)
;
}
;
List
.
prototype
.
mergeDeepWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
mergeIntoListWith
(
this
deepMergerWith
(
merger
)
iters
)
;
}
;
List
.
prototype
.
setSize
=
function
(
size
)
{
return
setListBounds
(
this
0
size
)
;
}
;
List
.
prototype
.
slice
=
function
(
begin
end
)
{
var
size
=
this
.
size
;
if
(
wholeSlice
(
begin
end
size
)
)
{
return
this
;
}
return
setListBounds
(
this
resolveBegin
(
begin
size
)
resolveEnd
(
end
size
)
)
;
}
;
List
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
index
=
0
;
var
values
=
iterateList
(
this
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
value
=
values
(
)
;
return
value
=
=
=
DONE
?
iteratorDone
(
)
:
iteratorValue
(
type
index
+
+
value
)
;
}
)
;
}
;
List
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
index
=
0
;
var
values
=
iterateList
(
this
reverse
)
;
var
value
;
while
(
(
value
=
values
(
)
)
!
=
=
DONE
)
{
if
(
fn
(
value
index
+
+
this
)
=
=
=
false
)
{
break
;
}
}
return
index
;
}
;
List
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
return
this
;
}
return
makeList
(
this
.
_origin
this
.
_capacity
this
.
_level
this
.
_root
this
.
_tail
ownerID
this
.
__hash
)
;
}
;
function
isList
(
maybeList
)
{
return
!
!
(
maybeList
&
&
maybeList
[
IS_LIST_SENTINEL
]
)
;
}
List
.
isList
=
isList
;
var
IS_LIST_SENTINEL
=
'
__IMMUTABLE_LIST__
'
;
var
ListPrototype
=
List
.
prototype
;
ListPrototype
[
IS_LIST_SENTINEL
]
=
true
;
ListPrototype
[
DELETE
]
=
ListPrototype
.
remove
;
ListPrototype
.
setIn
=
MapPrototype
.
setIn
;
ListPrototype
.
deleteIn
=
ListPrototype
.
removeIn
=
MapPrototype
.
removeIn
;
ListPrototype
.
update
=
MapPrototype
.
update
;
ListPrototype
.
updateIn
=
MapPrototype
.
updateIn
;
ListPrototype
.
mergeIn
=
MapPrototype
.
mergeIn
;
ListPrototype
.
mergeDeepIn
=
MapPrototype
.
mergeDeepIn
;
ListPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
ListPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
ListPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
ListPrototype
.
wasAltered
=
MapPrototype
.
wasAltered
;
function
VNode
(
array
ownerID
)
{
this
.
array
=
array
;
this
.
ownerID
=
ownerID
;
}
VNode
.
prototype
.
removeBefore
=
function
(
ownerID
level
index
)
{
if
(
index
=
=
=
level
?
1
<
<
level
:
0
|
|
this
.
array
.
length
=
=
=
0
)
{
return
this
;
}
var
originIndex
=
(
index
>
>
>
level
)
&
MASK
;
if
(
originIndex
>
=
this
.
array
.
length
)
{
return
new
VNode
(
[
]
ownerID
)
;
}
var
removingFirst
=
originIndex
=
=
=
0
;
var
newChild
;
if
(
level
>
0
)
{
var
oldChild
=
this
.
array
[
originIndex
]
;
newChild
=
oldChild
&
&
oldChild
.
removeBefore
(
ownerID
level
-
SHIFT
index
)
;
if
(
newChild
=
=
=
oldChild
&
&
removingFirst
)
{
return
this
;
}
}
if
(
removingFirst
&
&
!
newChild
)
{
return
this
;
}
var
editable
=
editableVNode
(
this
ownerID
)
;
if
(
!
removingFirst
)
{
for
(
var
ii
=
0
;
ii
<
originIndex
;
ii
+
+
)
{
editable
.
array
[
ii
]
=
undefined
;
}
}
if
(
newChild
)
{
editable
.
array
[
originIndex
]
=
newChild
;
}
return
editable
;
}
;
VNode
.
prototype
.
removeAfter
=
function
(
ownerID
level
index
)
{
if
(
index
=
=
=
(
level
?
1
<
<
level
:
0
)
|
|
this
.
array
.
length
=
=
=
0
)
{
return
this
;
}
var
sizeIndex
=
(
(
index
-
1
)
>
>
>
level
)
&
MASK
;
if
(
sizeIndex
>
=
this
.
array
.
length
)
{
return
this
;
}
var
newChild
;
if
(
level
>
0
)
{
var
oldChild
=
this
.
array
[
sizeIndex
]
;
newChild
=
oldChild
&
&
oldChild
.
removeAfter
(
ownerID
level
-
SHIFT
index
)
;
if
(
newChild
=
=
=
oldChild
&
&
sizeIndex
=
=
=
this
.
array
.
length
-
1
)
{
return
this
;
}
}
var
editable
=
editableVNode
(
this
ownerID
)
;
editable
.
array
.
splice
(
sizeIndex
+
1
)
;
if
(
newChild
)
{
editable
.
array
[
sizeIndex
]
=
newChild
;
}
return
editable
;
}
;
var
DONE
=
{
}
;
function
iterateList
(
list
reverse
)
{
var
left
=
list
.
_origin
;
var
right
=
list
.
_capacity
;
var
tailPos
=
getTailOffset
(
right
)
;
var
tail
=
list
.
_tail
;
return
iterateNodeOrLeaf
(
list
.
_root
list
.
_level
0
)
;
function
iterateNodeOrLeaf
(
node
level
offset
)
{
return
level
=
=
=
0
?
iterateLeaf
(
node
offset
)
:
iterateNode
(
node
level
offset
)
;
}
function
iterateLeaf
(
node
offset
)
{
var
array
=
offset
=
=
=
tailPos
?
tail
&
&
tail
.
array
:
node
&
&
node
.
array
;
var
from
=
offset
>
left
?
0
:
left
-
offset
;
var
to
=
right
-
offset
;
if
(
to
>
SIZE
)
{
to
=
SIZE
;
}
return
function
(
)
{
if
(
from
=
=
=
to
)
{
return
DONE
;
}
var
idx
=
reverse
?
-
-
to
:
from
+
+
;
return
array
&
&
array
[
idx
]
;
}
;
}
function
iterateNode
(
node
level
offset
)
{
var
values
;
var
array
=
node
&
&
node
.
array
;
var
from
=
offset
>
left
?
0
:
(
left
-
offset
)
>
>
level
;
var
to
=
(
(
right
-
offset
)
>
>
level
)
+
1
;
if
(
to
>
SIZE
)
{
to
=
SIZE
;
}
return
function
(
)
{
do
{
if
(
values
)
{
var
value
=
values
(
)
;
if
(
value
!
=
=
DONE
)
{
return
value
;
}
values
=
null
;
}
if
(
from
=
=
=
to
)
{
return
DONE
;
}
var
idx
=
reverse
?
-
-
to
:
from
+
+
;
values
=
iterateNodeOrLeaf
(
array
&
&
array
[
idx
]
level
-
SHIFT
offset
+
(
idx
<
<
level
)
)
;
}
while
(
true
)
;
}
;
}
}
function
makeList
(
origin
capacity
level
root
tail
ownerID
hash
)
{
var
list
=
Object
.
create
(
ListPrototype
)
;
list
.
size
=
capacity
-
origin
;
list
.
_origin
=
origin
;
list
.
_capacity
=
capacity
;
list
.
_level
=
level
;
list
.
_root
=
root
;
list
.
_tail
=
tail
;
list
.
__ownerID
=
ownerID
;
list
.
__hash
=
hash
;
list
.
__altered
=
false
;
return
list
;
}
var
EMPTY_LIST
;
function
emptyList
(
)
{
return
EMPTY_LIST
|
|
(
EMPTY_LIST
=
makeList
(
0
0
SHIFT
)
)
;
}
function
updateList
(
list
index
value
)
{
index
=
wrapIndex
(
list
index
)
;
if
(
index
!
=
=
index
)
{
return
list
;
}
if
(
index
>
=
list
.
size
|
|
index
<
0
)
{
return
list
.
withMutations
(
function
(
list
)
{
index
<
0
?
setListBounds
(
list
index
)
.
set
(
0
value
)
:
setListBounds
(
list
0
index
+
1
)
.
set
(
index
value
)
}
)
;
}
index
+
=
list
.
_origin
;
var
newTail
=
list
.
_tail
;
var
newRoot
=
list
.
_root
;
var
didAlter
=
MakeRef
(
DID_ALTER
)
;
if
(
index
>
=
getTailOffset
(
list
.
_capacity
)
)
{
newTail
=
updateVNode
(
newTail
list
.
__ownerID
0
index
value
didAlter
)
;
}
else
{
newRoot
=
updateVNode
(
newRoot
list
.
__ownerID
list
.
_level
index
value
didAlter
)
;
}
if
(
!
didAlter
.
value
)
{
return
list
;
}
if
(
list
.
__ownerID
)
{
list
.
_root
=
newRoot
;
list
.
_tail
=
newTail
;
list
.
__hash
=
undefined
;
list
.
__altered
=
true
;
return
list
;
}
return
makeList
(
list
.
_origin
list
.
_capacity
list
.
_level
newRoot
newTail
)
;
}
function
updateVNode
(
node
ownerID
level
index
value
didAlter
)
{
var
idx
=
(
index
>
>
>
level
)
&
MASK
;
var
nodeHas
=
node
&
&
idx
<
node
.
array
.
length
;
if
(
!
nodeHas
&
&
value
=
=
=
undefined
)
{
return
node
;
}
var
newNode
;
if
(
level
>
0
)
{
var
lowerNode
=
node
&
&
node
.
array
[
idx
]
;
var
newLowerNode
=
updateVNode
(
lowerNode
ownerID
level
-
SHIFT
index
value
didAlter
)
;
if
(
newLowerNode
=
=
=
lowerNode
)
{
return
node
;
}
newNode
=
editableVNode
(
node
ownerID
)
;
newNode
.
array
[
idx
]
=
newLowerNode
;
return
newNode
;
}
if
(
nodeHas
&
&
node
.
array
[
idx
]
=
=
=
value
)
{
return
node
;
}
SetRef
(
didAlter
)
;
newNode
=
editableVNode
(
node
ownerID
)
;
if
(
value
=
=
=
undefined
&
&
idx
=
=
=
newNode
.
array
.
length
-
1
)
{
newNode
.
array
.
pop
(
)
;
}
else
{
newNode
.
array
[
idx
]
=
value
;
}
return
newNode
;
}
function
editableVNode
(
node
ownerID
)
{
if
(
ownerID
&
&
node
&
&
ownerID
=
=
=
node
.
ownerID
)
{
return
node
;
}
return
new
VNode
(
node
?
node
.
array
.
slice
(
)
:
[
]
ownerID
)
;
}
function
listNodeFor
(
list
rawIndex
)
{
if
(
rawIndex
>
=
getTailOffset
(
list
.
_capacity
)
)
{
return
list
.
_tail
;
}
if
(
rawIndex
<
1
<
<
(
list
.
_level
+
SHIFT
)
)
{
var
node
=
list
.
_root
;
var
level
=
list
.
_level
;
while
(
node
&
&
level
>
0
)
{
node
=
node
.
array
[
(
rawIndex
>
>
>
level
)
&
MASK
]
;
level
-
=
SHIFT
;
}
return
node
;
}
}
function
setListBounds
(
list
begin
end
)
{
if
(
begin
!
=
=
undefined
)
{
begin
=
begin
|
0
;
}
if
(
end
!
=
=
undefined
)
{
end
=
end
|
0
;
}
var
owner
=
list
.
__ownerID
|
|
new
OwnerID
(
)
;
var
oldOrigin
=
list
.
_origin
;
var
oldCapacity
=
list
.
_capacity
;
var
newOrigin
=
oldOrigin
+
begin
;
var
newCapacity
=
end
=
=
=
undefined
?
oldCapacity
:
end
<
0
?
oldCapacity
+
end
:
oldOrigin
+
end
;
if
(
newOrigin
=
=
=
oldOrigin
&
&
newCapacity
=
=
=
oldCapacity
)
{
return
list
;
}
if
(
newOrigin
>
=
newCapacity
)
{
return
list
.
clear
(
)
;
}
var
newLevel
=
list
.
_level
;
var
newRoot
=
list
.
_root
;
var
offsetShift
=
0
;
while
(
newOrigin
+
offsetShift
<
0
)
{
newRoot
=
new
VNode
(
newRoot
&
&
newRoot
.
array
.
length
?
[
undefined
newRoot
]
:
[
]
owner
)
;
newLevel
+
=
SHIFT
;
offsetShift
+
=
1
<
<
newLevel
;
}
if
(
offsetShift
)
{
newOrigin
+
=
offsetShift
;
oldOrigin
+
=
offsetShift
;
newCapacity
+
=
offsetShift
;
oldCapacity
+
=
offsetShift
;
}
var
oldTailOffset
=
getTailOffset
(
oldCapacity
)
;
var
newTailOffset
=
getTailOffset
(
newCapacity
)
;
while
(
newTailOffset
>
=
1
<
<
(
newLevel
+
SHIFT
)
)
{
newRoot
=
new
VNode
(
newRoot
&
&
newRoot
.
array
.
length
?
[
newRoot
]
:
[
]
owner
)
;
newLevel
+
=
SHIFT
;
}
var
oldTail
=
list
.
_tail
;
var
newTail
=
newTailOffset
<
oldTailOffset
?
listNodeFor
(
list
newCapacity
-
1
)
:
newTailOffset
>
oldTailOffset
?
new
VNode
(
[
]
owner
)
:
oldTail
;
if
(
oldTail
&
&
newTailOffset
>
oldTailOffset
&
&
newOrigin
<
oldCapacity
&
&
oldTail
.
array
.
length
)
{
newRoot
=
editableVNode
(
newRoot
owner
)
;
var
node
=
newRoot
;
for
(
var
level
=
newLevel
;
level
>
SHIFT
;
level
-
=
SHIFT
)
{
var
idx
=
(
oldTailOffset
>
>
>
level
)
&
MASK
;
node
=
node
.
array
[
idx
]
=
editableVNode
(
node
.
array
[
idx
]
owner
)
;
}
node
.
array
[
(
oldTailOffset
>
>
>
SHIFT
)
&
MASK
]
=
oldTail
;
}
if
(
newCapacity
<
oldCapacity
)
{
newTail
=
newTail
&
&
newTail
.
removeAfter
(
owner
0
newCapacity
)
;
}
if
(
newOrigin
>
=
newTailOffset
)
{
newOrigin
-
=
newTailOffset
;
newCapacity
-
=
newTailOffset
;
newLevel
=
SHIFT
;
newRoot
=
null
;
newTail
=
newTail
&
&
newTail
.
removeBefore
(
owner
0
newOrigin
)
;
}
else
if
(
newOrigin
>
oldOrigin
|
|
newTailOffset
<
oldTailOffset
)
{
offsetShift
=
0
;
while
(
newRoot
)
{
var
beginIndex
=
(
newOrigin
>
>
>
newLevel
)
&
MASK
;
if
(
beginIndex
!
=
=
(
newTailOffset
>
>
>
newLevel
)
&
MASK
)
{
break
;
}
if
(
beginIndex
)
{
offsetShift
+
=
(
1
<
<
newLevel
)
*
beginIndex
;
}
newLevel
-
=
SHIFT
;
newRoot
=
newRoot
.
array
[
beginIndex
]
;
}
if
(
newRoot
&
&
newOrigin
>
oldOrigin
)
{
newRoot
=
newRoot
.
removeBefore
(
owner
newLevel
newOrigin
-
offsetShift
)
;
}
if
(
newRoot
&
&
newTailOffset
<
oldTailOffset
)
{
newRoot
=
newRoot
.
removeAfter
(
owner
newLevel
newTailOffset
-
offsetShift
)
;
}
if
(
offsetShift
)
{
newOrigin
-
=
offsetShift
;
newCapacity
-
=
offsetShift
;
}
}
if
(
list
.
__ownerID
)
{
list
.
size
=
newCapacity
-
newOrigin
;
list
.
_origin
=
newOrigin
;
list
.
_capacity
=
newCapacity
;
list
.
_level
=
newLevel
;
list
.
_root
=
newRoot
;
list
.
_tail
=
newTail
;
list
.
__hash
=
undefined
;
list
.
__altered
=
true
;
return
list
;
}
return
makeList
(
newOrigin
newCapacity
newLevel
newRoot
newTail
)
;
}
function
mergeIntoListWith
(
list
merger
iterables
)
{
var
iters
=
[
]
;
var
maxSize
=
0
;
for
(
var
ii
=
0
;
ii
<
iterables
.
length
;
ii
+
+
)
{
var
value
=
iterables
[
ii
]
;
var
iter
=
IndexedIterable
(
value
)
;
if
(
iter
.
size
>
maxSize
)
{
maxSize
=
iter
.
size
;
}
if
(
!
isIterable
(
value
)
)
{
iter
=
iter
.
map
(
function
(
v
)
{
return
fromJS
(
v
)
}
)
;
}
iters
.
push
(
iter
)
;
}
if
(
maxSize
>
list
.
size
)
{
list
=
list
.
setSize
(
maxSize
)
;
}
return
mergeIntoCollectionWith
(
list
merger
iters
)
;
}
function
getTailOffset
(
size
)
{
return
size
<
SIZE
?
0
:
(
(
(
size
-
1
)
>
>
>
SHIFT
)
<
<
SHIFT
)
;
}
createClass
(
OrderedMap
Map
)
;
function
OrderedMap
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyOrderedMap
(
)
:
isOrderedMap
(
value
)
?
value
:
emptyOrderedMap
(
)
.
withMutations
(
function
(
map
)
{
var
iter
=
KeyedIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
k
)
{
return
map
.
set
(
k
v
)
}
)
;
}
)
;
}
OrderedMap
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
OrderedMap
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
OrderedMap
{
'
'
}
'
)
;
}
;
OrderedMap
.
prototype
.
get
=
function
(
k
notSetValue
)
{
var
index
=
this
.
_map
.
get
(
k
)
;
return
index
!
=
=
undefined
?
this
.
_list
.
get
(
index
)
[
1
]
:
notSetValue
;
}
;
OrderedMap
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
0
;
this
.
_map
.
clear
(
)
;
this
.
_list
.
clear
(
)
;
return
this
;
}
return
emptyOrderedMap
(
)
;
}
;
OrderedMap
.
prototype
.
set
=
function
(
k
v
)
{
return
updateOrderedMap
(
this
k
v
)
;
}
;
OrderedMap
.
prototype
.
remove
=
function
(
k
)
{
return
updateOrderedMap
(
this
k
NOT_SET
)
;
}
;
OrderedMap
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
_map
.
wasAltered
(
)
|
|
this
.
_list
.
wasAltered
(
)
;
}
;
OrderedMap
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_list
.
__iterate
(
function
(
entry
)
{
return
entry
&
&
fn
(
entry
[
1
]
entry
[
0
]
this
0
)
}
reverse
)
;
}
;
OrderedMap
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
this
.
_list
.
fromEntrySeq
(
)
.
__iterator
(
type
reverse
)
;
}
;
OrderedMap
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
var
newMap
=
this
.
_map
.
__ensureOwner
(
ownerID
)
;
var
newList
=
this
.
_list
.
__ensureOwner
(
ownerID
)
;
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
_map
=
newMap
;
this
.
_list
=
newList
;
return
this
;
}
return
makeOrderedMap
(
newMap
newList
ownerID
this
.
__hash
)
;
}
;
function
isOrderedMap
(
maybeOrderedMap
)
{
return
isMap
(
maybeOrderedMap
)
&
&
isOrdered
(
maybeOrderedMap
)
;
}
OrderedMap
.
isOrderedMap
=
isOrderedMap
;
OrderedMap
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
OrderedMap
.
prototype
[
DELETE
]
=
OrderedMap
.
prototype
.
remove
;
function
makeOrderedMap
(
map
list
ownerID
hash
)
{
var
omap
=
Object
.
create
(
OrderedMap
.
prototype
)
;
omap
.
size
=
map
?
map
.
size
:
0
;
omap
.
_map
=
map
;
omap
.
_list
=
list
;
omap
.
__ownerID
=
ownerID
;
omap
.
__hash
=
hash
;
return
omap
;
}
var
EMPTY_ORDERED_MAP
;
function
emptyOrderedMap
(
)
{
return
EMPTY_ORDERED_MAP
|
|
(
EMPTY_ORDERED_MAP
=
makeOrderedMap
(
emptyMap
(
)
emptyList
(
)
)
)
;
}
function
updateOrderedMap
(
omap
k
v
)
{
var
map
=
omap
.
_map
;
var
list
=
omap
.
_list
;
var
i
=
map
.
get
(
k
)
;
var
has
=
i
!
=
=
undefined
;
var
newMap
;
var
newList
;
if
(
v
=
=
=
NOT_SET
)
{
if
(
!
has
)
{
return
omap
;
}
if
(
list
.
size
>
=
SIZE
&
&
list
.
size
>
=
map
.
size
*
2
)
{
newList
=
list
.
filter
(
function
(
entry
idx
)
{
return
entry
!
=
=
undefined
&
&
i
!
=
=
idx
}
)
;
newMap
=
newList
.
toKeyedSeq
(
)
.
map
(
function
(
entry
)
{
return
entry
[
0
]
}
)
.
flip
(
)
.
toMap
(
)
;
if
(
omap
.
__ownerID
)
{
newMap
.
__ownerID
=
newList
.
__ownerID
=
omap
.
__ownerID
;
}
}
else
{
newMap
=
map
.
remove
(
k
)
;
newList
=
i
=
=
=
list
.
size
-
1
?
list
.
pop
(
)
:
list
.
set
(
i
undefined
)
;
}
}
else
{
if
(
has
)
{
if
(
v
=
=
=
list
.
get
(
i
)
[
1
]
)
{
return
omap
;
}
newMap
=
map
;
newList
=
list
.
set
(
i
[
k
v
]
)
;
}
else
{
newMap
=
map
.
set
(
k
list
.
size
)
;
newList
=
list
.
set
(
list
.
size
[
k
v
]
)
;
}
}
if
(
omap
.
__ownerID
)
{
omap
.
size
=
newMap
.
size
;
omap
.
_map
=
newMap
;
omap
.
_list
=
newList
;
omap
.
__hash
=
undefined
;
return
omap
;
}
return
makeOrderedMap
(
newMap
newList
)
;
}
createClass
(
ToKeyedSequence
KeyedSeq
)
;
function
ToKeyedSequence
(
indexed
useKeys
)
{
this
.
_iter
=
indexed
;
this
.
_useKeys
=
useKeys
;
this
.
size
=
indexed
.
size
;
}
ToKeyedSequence
.
prototype
.
get
=
function
(
key
notSetValue
)
{
return
this
.
_iter
.
get
(
key
notSetValue
)
;
}
;
ToKeyedSequence
.
prototype
.
has
=
function
(
key
)
{
return
this
.
_iter
.
has
(
key
)
;
}
;
ToKeyedSequence
.
prototype
.
valueSeq
=
function
(
)
{
return
this
.
_iter
.
valueSeq
(
)
;
}
;
ToKeyedSequence
.
prototype
.
reverse
=
function
(
)
{
var
this
0
=
this
;
var
reversedSequence
=
reverseFactory
(
this
true
)
;
if
(
!
this
.
_useKeys
)
{
reversedSequence
.
valueSeq
=
function
(
)
{
return
this
0
.
_iter
.
toSeq
(
)
.
reverse
(
)
}
;
}
return
reversedSequence
;
}
;
ToKeyedSequence
.
prototype
.
map
=
function
(
mapper
context
)
{
var
this
0
=
this
;
var
mappedSequence
=
mapFactory
(
this
mapper
context
)
;
if
(
!
this
.
_useKeys
)
{
mappedSequence
.
valueSeq
=
function
(
)
{
return
this
0
.
_iter
.
toSeq
(
)
.
map
(
mapper
context
)
}
;
}
return
mappedSequence
;
}
;
ToKeyedSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
ii
;
return
this
.
_iter
.
__iterate
(
this
.
_useKeys
?
function
(
v
k
)
{
return
fn
(
v
k
this
0
)
}
:
(
(
ii
=
reverse
?
resolveSize
(
this
)
:
0
)
function
(
v
)
{
return
fn
(
v
reverse
?
-
-
ii
:
ii
+
+
this
0
)
}
)
reverse
)
;
}
;
ToKeyedSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
if
(
this
.
_useKeys
)
{
return
this
.
_iter
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
ii
=
reverse
?
resolveSize
(
this
)
:
0
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
reverse
?
-
-
ii
:
ii
+
+
step
.
value
step
)
;
}
)
;
}
;
ToKeyedSequence
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
createClass
(
ToIndexedSequence
IndexedSeq
)
;
function
ToIndexedSequence
(
iter
)
{
this
.
_iter
=
iter
;
this
.
size
=
iter
.
size
;
}
ToIndexedSequence
.
prototype
.
includes
=
function
(
value
)
{
return
this
.
_iter
.
includes
(
value
)
;
}
;
ToIndexedSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
return
this
.
_iter
.
__iterate
(
function
(
v
)
{
return
fn
(
v
iterations
+
+
this
0
)
}
reverse
)
;
}
;
ToIndexedSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
iterations
+
+
step
.
value
step
)
}
)
;
}
;
createClass
(
ToSetSequence
SetSeq
)
;
function
ToSetSequence
(
iter
)
{
this
.
_iter
=
iter
;
this
.
size
=
iter
.
size
;
}
ToSetSequence
.
prototype
.
has
=
function
(
key
)
{
return
this
.
_iter
.
includes
(
key
)
;
}
;
ToSetSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_iter
.
__iterate
(
function
(
v
)
{
return
fn
(
v
v
this
0
)
}
reverse
)
;
}
;
ToSetSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
return
step
.
done
?
step
:
iteratorValue
(
type
step
.
value
step
.
value
step
)
;
}
)
;
}
;
createClass
(
FromEntriesSequence
KeyedSeq
)
;
function
FromEntriesSequence
(
entries
)
{
this
.
_iter
=
entries
;
this
.
size
=
entries
.
size
;
}
FromEntriesSequence
.
prototype
.
entrySeq
=
function
(
)
{
return
this
.
_iter
.
toSeq
(
)
;
}
;
FromEntriesSequence
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_iter
.
__iterate
(
function
(
entry
)
{
if
(
entry
)
{
validateEntry
(
entry
)
;
var
indexedIterable
=
isIterable
(
entry
)
;
return
fn
(
indexedIterable
?
entry
.
get
(
1
)
:
entry
[
1
]
indexedIterable
?
entry
.
get
(
0
)
:
entry
[
0
]
this
0
)
;
}
}
reverse
)
;
}
;
FromEntriesSequence
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
iterator
=
this
.
_iter
.
__iterator
(
ITERATE_VALUES
reverse
)
;
return
new
Iterator
(
function
(
)
{
while
(
true
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
if
(
entry
)
{
validateEntry
(
entry
)
;
var
indexedIterable
=
isIterable
(
entry
)
;
return
iteratorValue
(
type
indexedIterable
?
entry
.
get
(
0
)
:
entry
[
0
]
indexedIterable
?
entry
.
get
(
1
)
:
entry
[
1
]
step
)
;
}
}
}
)
;
}
;
ToIndexedSequence
.
prototype
.
cacheResult
=
ToKeyedSequence
.
prototype
.
cacheResult
=
ToSetSequence
.
prototype
.
cacheResult
=
FromEntriesSequence
.
prototype
.
cacheResult
=
cacheResultThrough
;
function
flipFactory
(
iterable
)
{
var
flipSequence
=
makeSequence
(
iterable
)
;
flipSequence
.
_iter
=
iterable
;
flipSequence
.
size
=
iterable
.
size
;
flipSequence
.
flip
=
function
(
)
{
return
iterable
}
;
flipSequence
.
reverse
=
function
(
)
{
var
reversedSequence
=
iterable
.
reverse
.
apply
(
this
)
;
reversedSequence
.
flip
=
function
(
)
{
return
iterable
.
reverse
(
)
}
;
return
reversedSequence
;
}
;
flipSequence
.
has
=
function
(
key
)
{
return
iterable
.
includes
(
key
)
}
;
flipSequence
.
includes
=
function
(
key
)
{
return
iterable
.
has
(
key
)
}
;
flipSequence
.
cacheResult
=
cacheResultThrough
;
flipSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
iterable
.
__iterate
(
function
(
v
k
)
{
return
fn
(
k
v
this
0
)
!
=
=
false
}
reverse
)
;
}
flipSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
type
=
=
=
ITERATE_ENTRIES
)
{
var
iterator
=
iterable
.
__iterator
(
type
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
if
(
!
step
.
done
)
{
var
k
=
step
.
value
[
0
]
;
step
.
value
[
0
]
=
step
.
value
[
1
]
;
step
.
value
[
1
]
=
k
;
}
return
step
;
}
)
;
}
return
iterable
.
__iterator
(
type
=
=
=
ITERATE_VALUES
?
ITERATE_KEYS
:
ITERATE_VALUES
reverse
)
;
}
return
flipSequence
;
}
function
mapFactory
(
iterable
mapper
context
)
{
var
mappedSequence
=
makeSequence
(
iterable
)
;
mappedSequence
.
size
=
iterable
.
size
;
mappedSequence
.
has
=
function
(
key
)
{
return
iterable
.
has
(
key
)
}
;
mappedSequence
.
get
=
function
(
key
notSetValue
)
{
var
v
=
iterable
.
get
(
key
NOT_SET
)
;
return
v
=
=
=
NOT_SET
?
notSetValue
:
mapper
.
call
(
context
v
key
iterable
)
;
}
;
mappedSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
iterable
.
__iterate
(
function
(
v
k
c
)
{
return
fn
(
mapper
.
call
(
context
v
k
c
)
k
this
0
)
!
=
=
false
}
reverse
)
;
}
mappedSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
return
new
Iterator
(
function
(
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
var
key
=
entry
[
0
]
;
return
iteratorValue
(
type
key
mapper
.
call
(
context
entry
[
1
]
key
iterable
)
step
)
;
}
)
;
}
return
mappedSequence
;
}
function
reverseFactory
(
iterable
useKeys
)
{
var
reversedSequence
=
makeSequence
(
iterable
)
;
reversedSequence
.
_iter
=
iterable
;
reversedSequence
.
size
=
iterable
.
size
;
reversedSequence
.
reverse
=
function
(
)
{
return
iterable
}
;
if
(
iterable
.
flip
)
{
reversedSequence
.
flip
=
function
(
)
{
var
flipSequence
=
flipFactory
(
iterable
)
;
flipSequence
.
reverse
=
function
(
)
{
return
iterable
.
flip
(
)
}
;
return
flipSequence
;
}
;
}
reversedSequence
.
get
=
function
(
key
notSetValue
)
{
return
iterable
.
get
(
useKeys
?
key
:
-
1
-
key
notSetValue
)
}
;
reversedSequence
.
has
=
function
(
key
)
{
return
iterable
.
has
(
useKeys
?
key
:
-
1
-
key
)
}
;
reversedSequence
.
includes
=
function
(
value
)
{
return
iterable
.
includes
(
value
)
}
;
reversedSequence
.
cacheResult
=
cacheResultThrough
;
reversedSequence
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
iterable
.
__iterate
(
function
(
v
k
)
{
return
fn
(
v
k
this
0
)
}
!
reverse
)
;
}
;
reversedSequence
.
__iterator
=
function
(
type
reverse
)
{
return
iterable
.
__iterator
(
type
!
reverse
)
}
;
return
reversedSequence
;
}
function
filterFactory
(
iterable
predicate
context
useKeys
)
{
var
filterSequence
=
makeSequence
(
iterable
)
;
if
(
useKeys
)
{
filterSequence
.
has
=
function
(
key
)
{
var
v
=
iterable
.
get
(
key
NOT_SET
)
;
return
v
!
=
=
NOT_SET
&
&
!
!
predicate
.
call
(
context
v
key
iterable
)
;
}
;
filterSequence
.
get
=
function
(
key
notSetValue
)
{
var
v
=
iterable
.
get
(
key
NOT_SET
)
;
return
v
!
=
=
NOT_SET
&
&
predicate
.
call
(
context
v
key
iterable
)
?
v
:
notSetValue
;
}
;
}
filterSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
c
)
{
if
(
predicate
.
call
(
context
v
k
c
)
)
{
iterations
+
+
;
return
fn
(
v
useKeys
?
k
:
iterations
-
1
this
0
)
;
}
}
reverse
)
;
return
iterations
;
}
;
filterSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
while
(
true
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
var
key
=
entry
[
0
]
;
var
value
=
entry
[
1
]
;
if
(
predicate
.
call
(
context
value
key
iterable
)
)
{
return
iteratorValue
(
type
useKeys
?
key
:
iterations
+
+
value
step
)
;
}
}
}
)
;
}
return
filterSequence
;
}
function
countByFactory
(
iterable
grouper
context
)
{
var
groups
=
Map
(
)
.
asMutable
(
)
;
iterable
.
__iterate
(
function
(
v
k
)
{
groups
.
update
(
grouper
.
call
(
context
v
k
iterable
)
0
function
(
a
)
{
return
a
+
1
}
)
;
}
)
;
return
groups
.
asImmutable
(
)
;
}
function
groupByFactory
(
iterable
grouper
context
)
{
var
isKeyedIter
=
isKeyed
(
iterable
)
;
var
groups
=
(
isOrdered
(
iterable
)
?
OrderedMap
(
)
:
Map
(
)
)
.
asMutable
(
)
;
iterable
.
__iterate
(
function
(
v
k
)
{
groups
.
update
(
grouper
.
call
(
context
v
k
iterable
)
function
(
a
)
{
return
(
a
=
a
|
|
[
]
a
.
push
(
isKeyedIter
?
[
k
v
]
:
v
)
a
)
}
)
;
}
)
;
var
coerce
=
iterableClass
(
iterable
)
;
return
groups
.
map
(
function
(
arr
)
{
return
reify
(
iterable
coerce
(
arr
)
)
}
)
;
}
function
sliceFactory
(
iterable
begin
end
useKeys
)
{
var
originalSize
=
iterable
.
size
;
if
(
begin
!
=
=
undefined
)
{
begin
=
begin
|
0
;
}
if
(
end
!
=
=
undefined
)
{
if
(
end
=
=
=
Infinity
)
{
end
=
originalSize
;
}
else
{
end
=
end
|
0
;
}
}
if
(
wholeSlice
(
begin
end
originalSize
)
)
{
return
iterable
;
}
var
resolvedBegin
=
resolveBegin
(
begin
originalSize
)
;
var
resolvedEnd
=
resolveEnd
(
end
originalSize
)
;
if
(
resolvedBegin
!
=
=
resolvedBegin
|
|
resolvedEnd
!
=
=
resolvedEnd
)
{
return
sliceFactory
(
iterable
.
toSeq
(
)
.
cacheResult
(
)
begin
end
useKeys
)
;
}
var
resolvedSize
=
resolvedEnd
-
resolvedBegin
;
var
sliceSize
;
if
(
resolvedSize
=
=
=
resolvedSize
)
{
sliceSize
=
resolvedSize
<
0
?
0
:
resolvedSize
;
}
var
sliceSeq
=
makeSequence
(
iterable
)
;
sliceSeq
.
size
=
sliceSize
=
=
=
0
?
sliceSize
:
iterable
.
size
&
&
sliceSize
|
|
undefined
;
if
(
!
useKeys
&
&
isSeq
(
iterable
)
&
&
sliceSize
>
=
0
)
{
sliceSeq
.
get
=
function
(
index
notSetValue
)
{
index
=
wrapIndex
(
this
index
)
;
return
index
>
=
0
&
&
index
<
sliceSize
?
iterable
.
get
(
index
+
resolvedBegin
notSetValue
)
:
notSetValue
;
}
}
sliceSeq
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
if
(
sliceSize
=
=
=
0
)
{
return
0
;
}
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
skipped
=
0
;
var
isSkipping
=
true
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
)
{
if
(
!
(
isSkipping
&
&
(
isSkipping
=
skipped
+
+
<
resolvedBegin
)
)
)
{
iterations
+
+
;
return
fn
(
v
useKeys
?
k
:
iterations
-
1
this
0
)
!
=
=
false
&
&
iterations
!
=
=
sliceSize
;
}
}
)
;
return
iterations
;
}
;
sliceSeq
.
__iteratorUncached
=
function
(
type
reverse
)
{
if
(
sliceSize
!
=
=
0
&
&
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
sliceSize
!
=
=
0
&
&
iterable
.
__iterator
(
type
reverse
)
;
var
skipped
=
0
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
while
(
skipped
+
+
<
resolvedBegin
)
{
iterator
.
next
(
)
;
}
if
(
+
+
iterations
>
sliceSize
)
{
return
iteratorDone
(
)
;
}
var
step
=
iterator
.
next
(
)
;
if
(
useKeys
|
|
type
=
=
=
ITERATE_VALUES
)
{
return
step
;
}
else
if
(
type
=
=
=
ITERATE_KEYS
)
{
return
iteratorValue
(
type
iterations
-
1
undefined
step
)
;
}
else
{
return
iteratorValue
(
type
iterations
-
1
step
.
value
[
1
]
step
)
;
}
}
)
;
}
return
sliceSeq
;
}
function
takeWhileFactory
(
iterable
predicate
context
)
{
var
takeSequence
=
makeSequence
(
iterable
)
;
takeSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
c
)
{
return
predicate
.
call
(
context
v
k
c
)
&
&
+
+
iterations
&
&
fn
(
v
k
this
0
)
}
)
;
return
iterations
;
}
;
takeSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
var
iterating
=
true
;
return
new
Iterator
(
function
(
)
{
if
(
!
iterating
)
{
return
iteratorDone
(
)
;
}
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
var
entry
=
step
.
value
;
var
k
=
entry
[
0
]
;
var
v
=
entry
[
1
]
;
if
(
!
predicate
.
call
(
context
v
k
this
0
)
)
{
iterating
=
false
;
return
iteratorDone
(
)
;
}
return
type
=
=
=
ITERATE_ENTRIES
?
step
:
iteratorValue
(
type
k
v
step
)
;
}
)
;
}
;
return
takeSequence
;
}
function
skipWhileFactory
(
iterable
predicate
context
useKeys
)
{
var
skipSequence
=
makeSequence
(
iterable
)
;
skipSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterate
(
fn
reverse
)
;
}
var
isSkipping
=
true
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
c
)
{
if
(
!
(
isSkipping
&
&
(
isSkipping
=
predicate
.
call
(
context
v
k
c
)
)
)
)
{
iterations
+
+
;
return
fn
(
v
useKeys
?
k
:
iterations
-
1
this
0
)
;
}
}
)
;
return
iterations
;
}
;
skipSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
this
0
=
this
;
if
(
reverse
)
{
return
this
.
cacheResult
(
)
.
__iterator
(
type
reverse
)
;
}
var
iterator
=
iterable
.
__iterator
(
ITERATE_ENTRIES
reverse
)
;
var
skipping
=
true
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
var
step
k
v
;
do
{
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
if
(
useKeys
|
|
type
=
=
=
ITERATE_VALUES
)
{
return
step
;
}
else
if
(
type
=
=
=
ITERATE_KEYS
)
{
return
iteratorValue
(
type
iterations
+
+
undefined
step
)
;
}
else
{
return
iteratorValue
(
type
iterations
+
+
step
.
value
[
1
]
step
)
;
}
}
var
entry
=
step
.
value
;
k
=
entry
[
0
]
;
v
=
entry
[
1
]
;
skipping
&
&
(
skipping
=
predicate
.
call
(
context
v
k
this
0
)
)
;
}
while
(
skipping
)
;
return
type
=
=
=
ITERATE_ENTRIES
?
step
:
iteratorValue
(
type
k
v
step
)
;
}
)
;
}
;
return
skipSequence
;
}
function
concatFactory
(
iterable
values
)
{
var
isKeyedIterable
=
isKeyed
(
iterable
)
;
var
iters
=
[
iterable
]
.
concat
(
values
)
.
map
(
function
(
v
)
{
if
(
!
isIterable
(
v
)
)
{
v
=
isKeyedIterable
?
keyedSeqFromValue
(
v
)
:
indexedSeqFromValue
(
Array
.
isArray
(
v
)
?
v
:
[
v
]
)
;
}
else
if
(
isKeyedIterable
)
{
v
=
KeyedIterable
(
v
)
;
}
return
v
;
}
)
.
filter
(
function
(
v
)
{
return
v
.
size
!
=
=
0
}
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
iterable
;
}
if
(
iters
.
length
=
=
=
1
)
{
var
singleton
=
iters
[
0
]
;
if
(
singleton
=
=
=
iterable
|
|
isKeyedIterable
&
&
isKeyed
(
singleton
)
|
|
isIndexed
(
iterable
)
&
&
isIndexed
(
singleton
)
)
{
return
singleton
;
}
}
var
concatSeq
=
new
ArraySeq
(
iters
)
;
if
(
isKeyedIterable
)
{
concatSeq
=
concatSeq
.
toKeyedSeq
(
)
;
}
else
if
(
!
isIndexed
(
iterable
)
)
{
concatSeq
=
concatSeq
.
toSetSeq
(
)
;
}
concatSeq
=
concatSeq
.
flatten
(
true
)
;
concatSeq
.
size
=
iters
.
reduce
(
function
(
sum
seq
)
{
if
(
sum
!
=
=
undefined
)
{
var
size
=
seq
.
size
;
if
(
size
!
=
=
undefined
)
{
return
sum
+
size
;
}
}
}
0
)
;
return
concatSeq
;
}
function
flattenFactory
(
iterable
depth
useKeys
)
{
var
flatSequence
=
makeSequence
(
iterable
)
;
flatSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
iterations
=
0
;
var
stopped
=
false
;
function
flatDeep
(
iter
currentDepth
)
{
var
this
0
=
this
;
iter
.
__iterate
(
function
(
v
k
)
{
if
(
(
!
depth
|
|
currentDepth
<
depth
)
&
&
isIterable
(
v
)
)
{
flatDeep
(
v
currentDepth
+
1
)
;
}
else
if
(
fn
(
v
useKeys
?
k
:
iterations
+
+
this
0
)
=
=
=
false
)
{
stopped
=
true
;
}
return
!
stopped
;
}
reverse
)
;
}
flatDeep
(
iterable
0
)
;
return
iterations
;
}
flatSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
type
reverse
)
;
var
stack
=
[
]
;
var
iterations
=
0
;
return
new
Iterator
(
function
(
)
{
while
(
iterator
)
{
var
step
=
iterator
.
next
(
)
;
if
(
step
.
done
!
=
=
false
)
{
iterator
=
stack
.
pop
(
)
;
continue
;
}
var
v
=
step
.
value
;
if
(
type
=
=
=
ITERATE_ENTRIES
)
{
v
=
v
[
1
]
;
}
if
(
(
!
depth
|
|
stack
.
length
<
depth
)
&
&
isIterable
(
v
)
)
{
stack
.
push
(
iterator
)
;
iterator
=
v
.
__iterator
(
type
reverse
)
;
}
else
{
return
useKeys
?
step
:
iteratorValue
(
type
iterations
+
+
v
step
)
;
}
}
return
iteratorDone
(
)
;
}
)
;
}
return
flatSequence
;
}
function
flatMapFactory
(
iterable
mapper
context
)
{
var
coerce
=
iterableClass
(
iterable
)
;
return
iterable
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
coerce
(
mapper
.
call
(
context
v
k
iterable
)
)
}
)
.
flatten
(
true
)
;
}
function
interposeFactory
(
iterable
separator
)
{
var
interposedSequence
=
makeSequence
(
iterable
)
;
interposedSequence
.
size
=
iterable
.
size
&
&
iterable
.
size
*
2
-
1
;
interposedSequence
.
__iterateUncached
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
var
iterations
=
0
;
iterable
.
__iterate
(
function
(
v
k
)
{
return
(
!
iterations
|
|
fn
(
separator
iterations
+
+
this
0
)
!
=
=
false
)
&
&
fn
(
v
iterations
+
+
this
0
)
!
=
=
false
}
reverse
)
;
return
iterations
;
}
;
interposedSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterator
=
iterable
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
iterations
=
0
;
var
step
;
return
new
Iterator
(
function
(
)
{
if
(
!
step
|
|
iterations
%
2
)
{
step
=
iterator
.
next
(
)
;
if
(
step
.
done
)
{
return
step
;
}
}
return
iterations
%
2
?
iteratorValue
(
type
iterations
+
+
separator
)
:
iteratorValue
(
type
iterations
+
+
step
.
value
step
)
;
}
)
;
}
;
return
interposedSequence
;
}
function
sortFactory
(
iterable
comparator
mapper
)
{
if
(
!
comparator
)
{
comparator
=
defaultComparator
;
}
var
isKeyedIterable
=
isKeyed
(
iterable
)
;
var
index
=
0
;
var
entries
=
iterable
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
[
k
v
index
+
+
mapper
?
mapper
(
v
k
iterable
)
:
v
]
}
)
.
toArray
(
)
;
entries
.
sort
(
function
(
a
b
)
{
return
comparator
(
a
[
3
]
b
[
3
]
)
|
|
a
[
2
]
-
b
[
2
]
}
)
.
forEach
(
isKeyedIterable
?
function
(
v
i
)
{
entries
[
i
]
.
length
=
2
;
}
:
function
(
v
i
)
{
entries
[
i
]
=
v
[
1
]
;
}
)
;
return
isKeyedIterable
?
KeyedSeq
(
entries
)
:
isIndexed
(
iterable
)
?
IndexedSeq
(
entries
)
:
SetSeq
(
entries
)
;
}
function
maxFactory
(
iterable
comparator
mapper
)
{
if
(
!
comparator
)
{
comparator
=
defaultComparator
;
}
if
(
mapper
)
{
var
entry
=
iterable
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
[
v
mapper
(
v
k
iterable
)
]
}
)
.
reduce
(
function
(
a
b
)
{
return
maxCompare
(
comparator
a
[
1
]
b
[
1
]
)
?
b
:
a
}
)
;
return
entry
&
&
entry
[
0
]
;
}
else
{
return
iterable
.
reduce
(
function
(
a
b
)
{
return
maxCompare
(
comparator
a
b
)
?
b
:
a
}
)
;
}
}
function
maxCompare
(
comparator
a
b
)
{
var
comp
=
comparator
(
b
a
)
;
return
(
comp
=
=
=
0
&
&
b
!
=
=
a
&
&
(
b
=
=
=
undefined
|
|
b
=
=
=
null
|
|
b
!
=
=
b
)
)
|
|
comp
>
0
;
}
function
zipWithFactory
(
keyIter
zipper
iters
)
{
var
zipSequence
=
makeSequence
(
keyIter
)
;
zipSequence
.
size
=
new
ArraySeq
(
iters
)
.
map
(
function
(
i
)
{
return
i
.
size
}
)
.
min
(
)
;
zipSequence
.
__iterate
=
function
(
fn
reverse
)
{
var
iterator
=
this
.
__iterator
(
ITERATE_VALUES
reverse
)
;
var
step
;
var
iterations
=
0
;
while
(
!
(
step
=
iterator
.
next
(
)
)
.
done
)
{
if
(
fn
(
step
.
value
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
}
return
iterations
;
}
;
zipSequence
.
__iteratorUncached
=
function
(
type
reverse
)
{
var
iterators
=
iters
.
map
(
function
(
i
)
{
return
(
i
=
Iterable
(
i
)
getIterator
(
reverse
?
i
.
reverse
(
)
:
i
)
)
}
)
;
var
iterations
=
0
;
var
isDone
=
false
;
return
new
Iterator
(
function
(
)
{
var
steps
;
if
(
!
isDone
)
{
steps
=
iterators
.
map
(
function
(
i
)
{
return
i
.
next
(
)
}
)
;
isDone
=
steps
.
some
(
function
(
s
)
{
return
s
.
done
}
)
;
}
if
(
isDone
)
{
return
iteratorDone
(
)
;
}
return
iteratorValue
(
type
iterations
+
+
zipper
.
apply
(
null
steps
.
map
(
function
(
s
)
{
return
s
.
value
}
)
)
)
;
}
)
;
}
;
return
zipSequence
}
function
reify
(
iter
seq
)
{
return
isSeq
(
iter
)
?
seq
:
iter
.
constructor
(
seq
)
;
}
function
validateEntry
(
entry
)
{
if
(
entry
!
=
=
Object
(
entry
)
)
{
throw
new
TypeError
(
'
Expected
[
K
V
]
tuple
:
'
+
entry
)
;
}
}
function
resolveSize
(
iter
)
{
assertNotInfinite
(
iter
.
size
)
;
return
ensureSize
(
iter
)
;
}
function
iterableClass
(
iterable
)
{
return
isKeyed
(
iterable
)
?
KeyedIterable
:
isIndexed
(
iterable
)
?
IndexedIterable
:
SetIterable
;
}
function
makeSequence
(
iterable
)
{
return
Object
.
create
(
(
isKeyed
(
iterable
)
?
KeyedSeq
:
isIndexed
(
iterable
)
?
IndexedSeq
:
SetSeq
)
.
prototype
)
;
}
function
cacheResultThrough
(
)
{
if
(
this
.
_iter
.
cacheResult
)
{
this
.
_iter
.
cacheResult
(
)
;
this
.
size
=
this
.
_iter
.
size
;
return
this
;
}
else
{
return
Seq
.
prototype
.
cacheResult
.
call
(
this
)
;
}
}
function
defaultComparator
(
a
b
)
{
return
a
>
b
?
1
:
a
<
b
?
-
1
:
0
;
}
function
forceIterator
(
keyPath
)
{
var
iter
=
getIterator
(
keyPath
)
;
if
(
!
iter
)
{
if
(
!
isArrayLike
(
keyPath
)
)
{
throw
new
TypeError
(
'
Expected
iterable
or
array
-
like
:
'
+
keyPath
)
;
}
iter
=
getIterator
(
Iterable
(
keyPath
)
)
;
}
return
iter
;
}
createClass
(
Record
KeyedCollection
)
;
function
Record
(
defaultValues
name
)
{
var
hasInitialized
;
var
RecordType
=
function
Record
(
values
)
{
if
(
values
instanceof
RecordType
)
{
return
values
;
}
if
(
!
(
this
instanceof
RecordType
)
)
{
return
new
RecordType
(
values
)
;
}
if
(
!
hasInitialized
)
{
hasInitialized
=
true
;
var
keys
=
Object
.
keys
(
defaultValues
)
;
setProps
(
RecordTypePrototype
keys
)
;
RecordTypePrototype
.
size
=
keys
.
length
;
RecordTypePrototype
.
_name
=
name
;
RecordTypePrototype
.
_keys
=
keys
;
RecordTypePrototype
.
_defaultValues
=
defaultValues
;
}
this
.
_map
=
Map
(
values
)
;
}
;
var
RecordTypePrototype
=
RecordType
.
prototype
=
Object
.
create
(
RecordPrototype
)
;
RecordTypePrototype
.
constructor
=
RecordType
;
return
RecordType
;
}
Record
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
recordName
(
this
)
+
'
{
'
'
}
'
)
;
}
;
Record
.
prototype
.
has
=
function
(
k
)
{
return
this
.
_defaultValues
.
hasOwnProperty
(
k
)
;
}
;
Record
.
prototype
.
get
=
function
(
k
notSetValue
)
{
if
(
!
this
.
has
(
k
)
)
{
return
notSetValue
;
}
var
defaultVal
=
this
.
_defaultValues
[
k
]
;
return
this
.
_map
?
this
.
_map
.
get
(
k
defaultVal
)
:
defaultVal
;
}
;
Record
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
__ownerID
)
{
this
.
_map
&
&
this
.
_map
.
clear
(
)
;
return
this
;
}
var
RecordType
=
this
.
constructor
;
return
RecordType
.
_empty
|
|
(
RecordType
.
_empty
=
makeRecord
(
this
emptyMap
(
)
)
)
;
}
;
Record
.
prototype
.
set
=
function
(
k
v
)
{
if
(
!
this
.
has
(
k
)
)
{
throw
new
Error
(
'
Cannot
set
unknown
key
"
'
+
k
+
'
"
on
'
+
recordName
(
this
)
)
;
}
if
(
this
.
_map
&
&
!
this
.
_map
.
has
(
k
)
)
{
var
defaultVal
=
this
.
_defaultValues
[
k
]
;
if
(
v
=
=
=
defaultVal
)
{
return
this
;
}
}
var
newMap
=
this
.
_map
&
&
this
.
_map
.
set
(
k
v
)
;
if
(
this
.
__ownerID
|
|
newMap
=
=
=
this
.
_map
)
{
return
this
;
}
return
makeRecord
(
this
newMap
)
;
}
;
Record
.
prototype
.
remove
=
function
(
k
)
{
if
(
!
this
.
has
(
k
)
)
{
return
this
;
}
var
newMap
=
this
.
_map
&
&
this
.
_map
.
remove
(
k
)
;
if
(
this
.
__ownerID
|
|
newMap
=
=
=
this
.
_map
)
{
return
this
;
}
return
makeRecord
(
this
newMap
)
;
}
;
Record
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
_map
.
wasAltered
(
)
;
}
;
Record
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
var
this
0
=
this
;
return
KeyedIterable
(
this
.
_defaultValues
)
.
map
(
function
(
_
k
)
{
return
this
0
.
get
(
k
)
}
)
.
__iterator
(
type
reverse
)
;
}
;
Record
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
KeyedIterable
(
this
.
_defaultValues
)
.
map
(
function
(
_
k
)
{
return
this
0
.
get
(
k
)
}
)
.
__iterate
(
fn
reverse
)
;
}
;
Record
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
var
newMap
=
this
.
_map
&
&
this
.
_map
.
__ensureOwner
(
ownerID
)
;
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
_map
=
newMap
;
return
this
;
}
return
makeRecord
(
this
newMap
ownerID
)
;
}
;
var
RecordPrototype
=
Record
.
prototype
;
RecordPrototype
[
DELETE
]
=
RecordPrototype
.
remove
;
RecordPrototype
.
deleteIn
=
RecordPrototype
.
removeIn
=
MapPrototype
.
removeIn
;
RecordPrototype
.
merge
=
MapPrototype
.
merge
;
RecordPrototype
.
mergeWith
=
MapPrototype
.
mergeWith
;
RecordPrototype
.
mergeIn
=
MapPrototype
.
mergeIn
;
RecordPrototype
.
mergeDeep
=
MapPrototype
.
mergeDeep
;
RecordPrototype
.
mergeDeepWith
=
MapPrototype
.
mergeDeepWith
;
RecordPrototype
.
mergeDeepIn
=
MapPrototype
.
mergeDeepIn
;
RecordPrototype
.
setIn
=
MapPrototype
.
setIn
;
RecordPrototype
.
update
=
MapPrototype
.
update
;
RecordPrototype
.
updateIn
=
MapPrototype
.
updateIn
;
RecordPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
RecordPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
RecordPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
function
makeRecord
(
likeRecord
map
ownerID
)
{
var
record
=
Object
.
create
(
Object
.
getPrototypeOf
(
likeRecord
)
)
;
record
.
_map
=
map
;
record
.
__ownerID
=
ownerID
;
return
record
;
}
function
recordName
(
record
)
{
return
record
.
_name
|
|
record
.
constructor
.
name
|
|
'
Record
'
;
}
function
setProps
(
prototype
names
)
{
try
{
names
.
forEach
(
setProp
.
bind
(
undefined
prototype
)
)
;
}
catch
(
error
)
{
}
}
function
setProp
(
prototype
name
)
{
Object
.
defineProperty
(
prototype
name
{
get
:
function
(
)
{
return
this
.
get
(
name
)
;
}
set
:
function
(
value
)
{
invariant
(
this
.
__ownerID
'
Cannot
set
on
an
immutable
record
.
'
)
;
this
.
set
(
name
value
)
;
}
}
)
;
}
createClass
(
Set
SetCollection
)
;
function
Set
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptySet
(
)
:
isSet
(
value
)
&
&
!
isOrdered
(
value
)
?
value
:
emptySet
(
)
.
withMutations
(
function
(
set
)
{
var
iter
=
SetIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
)
{
return
set
.
add
(
v
)
}
)
;
}
)
;
}
Set
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
Set
.
fromKeys
=
function
(
value
)
{
return
this
(
KeyedIterable
(
value
)
.
keySeq
(
)
)
;
}
;
Set
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Set
{
'
'
}
'
)
;
}
;
Set
.
prototype
.
has
=
function
(
value
)
{
return
this
.
_map
.
has
(
value
)
;
}
;
Set
.
prototype
.
add
=
function
(
value
)
{
return
updateSet
(
this
this
.
_map
.
set
(
value
true
)
)
;
}
;
Set
.
prototype
.
remove
=
function
(
value
)
{
return
updateSet
(
this
this
.
_map
.
remove
(
value
)
)
;
}
;
Set
.
prototype
.
clear
=
function
(
)
{
return
updateSet
(
this
this
.
_map
.
clear
(
)
)
;
}
;
Set
.
prototype
.
union
=
function
(
)
{
var
iters
=
SLICE
0
.
call
(
arguments
0
)
;
iters
=
iters
.
filter
(
function
(
x
)
{
return
x
.
size
!
=
=
0
}
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
this
;
}
if
(
this
.
size
=
=
=
0
&
&
!
this
.
__ownerID
&
&
iters
.
length
=
=
=
1
)
{
return
this
.
constructor
(
iters
[
0
]
)
;
}
return
this
.
withMutations
(
function
(
set
)
{
for
(
var
ii
=
0
;
ii
<
iters
.
length
;
ii
+
+
)
{
SetIterable
(
iters
[
ii
]
)
.
forEach
(
function
(
value
)
{
return
set
.
add
(
value
)
}
)
;
}
}
)
;
}
;
Set
.
prototype
.
intersect
=
function
(
)
{
var
iters
=
SLICE
0
.
call
(
arguments
0
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
this
;
}
iters
=
iters
.
map
(
function
(
iter
)
{
return
SetIterable
(
iter
)
}
)
;
var
originalSet
=
this
;
return
this
.
withMutations
(
function
(
set
)
{
originalSet
.
forEach
(
function
(
value
)
{
if
(
!
iters
.
every
(
function
(
iter
)
{
return
iter
.
includes
(
value
)
}
)
)
{
set
.
remove
(
value
)
;
}
}
)
;
}
)
;
}
;
Set
.
prototype
.
subtract
=
function
(
)
{
var
iters
=
SLICE
0
.
call
(
arguments
0
)
;
if
(
iters
.
length
=
=
=
0
)
{
return
this
;
}
iters
=
iters
.
map
(
function
(
iter
)
{
return
SetIterable
(
iter
)
}
)
;
var
originalSet
=
this
;
return
this
.
withMutations
(
function
(
set
)
{
originalSet
.
forEach
(
function
(
value
)
{
if
(
iters
.
some
(
function
(
iter
)
{
return
iter
.
includes
(
value
)
}
)
)
{
set
.
remove
(
value
)
;
}
}
)
;
}
)
;
}
;
Set
.
prototype
.
merge
=
function
(
)
{
return
this
.
union
.
apply
(
this
arguments
)
;
}
;
Set
.
prototype
.
mergeWith
=
function
(
merger
)
{
var
iters
=
SLICE
0
.
call
(
arguments
1
)
;
return
this
.
union
.
apply
(
this
iters
)
;
}
;
Set
.
prototype
.
sort
=
function
(
comparator
)
{
return
OrderedSet
(
sortFactory
(
this
comparator
)
)
;
}
;
Set
.
prototype
.
sortBy
=
function
(
mapper
comparator
)
{
return
OrderedSet
(
sortFactory
(
this
comparator
mapper
)
)
;
}
;
Set
.
prototype
.
wasAltered
=
function
(
)
{
return
this
.
_map
.
wasAltered
(
)
;
}
;
Set
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
var
this
0
=
this
;
return
this
.
_map
.
__iterate
(
function
(
_
k
)
{
return
fn
(
k
k
this
0
)
}
reverse
)
;
}
;
Set
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
return
this
.
_map
.
map
(
function
(
_
k
)
{
return
k
}
)
.
__iterator
(
type
reverse
)
;
}
;
Set
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
var
newMap
=
this
.
_map
.
__ensureOwner
(
ownerID
)
;
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
_map
=
newMap
;
return
this
;
}
return
this
.
__make
(
newMap
ownerID
)
;
}
;
function
isSet
(
maybeSet
)
{
return
!
!
(
maybeSet
&
&
maybeSet
[
IS_SET_SENTINEL
]
)
;
}
Set
.
isSet
=
isSet
;
var
IS_SET_SENTINEL
=
'
__IMMUTABLE_SET__
'
;
var
SetPrototype
=
Set
.
prototype
;
SetPrototype
[
IS_SET_SENTINEL
]
=
true
;
SetPrototype
[
DELETE
]
=
SetPrototype
.
remove
;
SetPrototype
.
mergeDeep
=
SetPrototype
.
merge
;
SetPrototype
.
mergeDeepWith
=
SetPrototype
.
mergeWith
;
SetPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
SetPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
SetPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
SetPrototype
.
__empty
=
emptySet
;
SetPrototype
.
__make
=
makeSet
;
function
updateSet
(
set
newMap
)
{
if
(
set
.
__ownerID
)
{
set
.
size
=
newMap
.
size
;
set
.
_map
=
newMap
;
return
set
;
}
return
newMap
=
=
=
set
.
_map
?
set
:
newMap
.
size
=
=
=
0
?
set
.
__empty
(
)
:
set
.
__make
(
newMap
)
;
}
function
makeSet
(
map
ownerID
)
{
var
set
=
Object
.
create
(
SetPrototype
)
;
set
.
size
=
map
?
map
.
size
:
0
;
set
.
_map
=
map
;
set
.
__ownerID
=
ownerID
;
return
set
;
}
var
EMPTY_SET
;
function
emptySet
(
)
{
return
EMPTY_SET
|
|
(
EMPTY_SET
=
makeSet
(
emptyMap
(
)
)
)
;
}
createClass
(
OrderedSet
Set
)
;
function
OrderedSet
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyOrderedSet
(
)
:
isOrderedSet
(
value
)
?
value
:
emptyOrderedSet
(
)
.
withMutations
(
function
(
set
)
{
var
iter
=
SetIterable
(
value
)
;
assertNotInfinite
(
iter
.
size
)
;
iter
.
forEach
(
function
(
v
)
{
return
set
.
add
(
v
)
}
)
;
}
)
;
}
OrderedSet
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
OrderedSet
.
fromKeys
=
function
(
value
)
{
return
this
(
KeyedIterable
(
value
)
.
keySeq
(
)
)
;
}
;
OrderedSet
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
OrderedSet
{
'
'
}
'
)
;
}
;
function
isOrderedSet
(
maybeOrderedSet
)
{
return
isSet
(
maybeOrderedSet
)
&
&
isOrdered
(
maybeOrderedSet
)
;
}
OrderedSet
.
isOrderedSet
=
isOrderedSet
;
var
OrderedSetPrototype
=
OrderedSet
.
prototype
;
OrderedSetPrototype
[
IS_ORDERED_SENTINEL
]
=
true
;
OrderedSetPrototype
.
__empty
=
emptyOrderedSet
;
OrderedSetPrototype
.
__make
=
makeOrderedSet
;
function
makeOrderedSet
(
map
ownerID
)
{
var
set
=
Object
.
create
(
OrderedSetPrototype
)
;
set
.
size
=
map
?
map
.
size
:
0
;
set
.
_map
=
map
;
set
.
__ownerID
=
ownerID
;
return
set
;
}
var
EMPTY_ORDERED_SET
;
function
emptyOrderedSet
(
)
{
return
EMPTY_ORDERED_SET
|
|
(
EMPTY_ORDERED_SET
=
makeOrderedSet
(
emptyOrderedMap
(
)
)
)
;
}
createClass
(
Stack
IndexedCollection
)
;
function
Stack
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
?
emptyStack
(
)
:
isStack
(
value
)
?
value
:
emptyStack
(
)
.
unshiftAll
(
value
)
;
}
Stack
.
of
=
function
(
)
{
return
this
(
arguments
)
;
}
;
Stack
.
prototype
.
toString
=
function
(
)
{
return
this
.
__toString
(
'
Stack
[
'
'
]
'
)
;
}
;
Stack
.
prototype
.
get
=
function
(
index
notSetValue
)
{
var
head
=
this
.
_head
;
index
=
wrapIndex
(
this
index
)
;
while
(
head
&
&
index
-
-
)
{
head
=
head
.
next
;
}
return
head
?
head
.
value
:
notSetValue
;
}
;
Stack
.
prototype
.
peek
=
function
(
)
{
return
this
.
_head
&
&
this
.
_head
.
value
;
}
;
Stack
.
prototype
.
push
=
function
(
)
{
if
(
arguments
.
length
=
=
=
0
)
{
return
this
;
}
var
newSize
=
this
.
size
+
arguments
.
length
;
var
head
=
this
.
_head
;
for
(
var
ii
=
arguments
.
length
-
1
;
ii
>
=
0
;
ii
-
-
)
{
head
=
{
value
:
arguments
[
ii
]
next
:
head
}
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
newSize
;
this
.
_head
=
head
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
makeStack
(
newSize
head
)
;
}
;
Stack
.
prototype
.
pushAll
=
function
(
iter
)
{
iter
=
IndexedIterable
(
iter
)
;
if
(
iter
.
size
=
=
=
0
)
{
return
this
;
}
assertNotInfinite
(
iter
.
size
)
;
var
newSize
=
this
.
size
;
var
head
=
this
.
_head
;
iter
.
reverse
(
)
.
forEach
(
function
(
value
)
{
newSize
+
+
;
head
=
{
value
:
value
next
:
head
}
;
}
)
;
if
(
this
.
__ownerID
)
{
this
.
size
=
newSize
;
this
.
_head
=
head
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
makeStack
(
newSize
head
)
;
}
;
Stack
.
prototype
.
pop
=
function
(
)
{
return
this
.
slice
(
1
)
;
}
;
Stack
.
prototype
.
unshift
=
function
(
)
{
return
this
.
push
.
apply
(
this
arguments
)
;
}
;
Stack
.
prototype
.
unshiftAll
=
function
(
iter
)
{
return
this
.
pushAll
(
iter
)
;
}
;
Stack
.
prototype
.
shift
=
function
(
)
{
return
this
.
pop
.
apply
(
this
arguments
)
;
}
;
Stack
.
prototype
.
clear
=
function
(
)
{
if
(
this
.
size
=
=
=
0
)
{
return
this
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
0
;
this
.
_head
=
undefined
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
emptyStack
(
)
;
}
;
Stack
.
prototype
.
slice
=
function
(
begin
end
)
{
if
(
wholeSlice
(
begin
end
this
.
size
)
)
{
return
this
;
}
var
resolvedBegin
=
resolveBegin
(
begin
this
.
size
)
;
var
resolvedEnd
=
resolveEnd
(
end
this
.
size
)
;
if
(
resolvedEnd
!
=
=
this
.
size
)
{
return
IndexedCollection
.
prototype
.
slice
.
call
(
this
begin
end
)
;
}
var
newSize
=
this
.
size
-
resolvedBegin
;
var
head
=
this
.
_head
;
while
(
resolvedBegin
-
-
)
{
head
=
head
.
next
;
}
if
(
this
.
__ownerID
)
{
this
.
size
=
newSize
;
this
.
_head
=
head
;
this
.
__hash
=
undefined
;
this
.
__altered
=
true
;
return
this
;
}
return
makeStack
(
newSize
head
)
;
}
;
Stack
.
prototype
.
__ensureOwner
=
function
(
ownerID
)
{
if
(
ownerID
=
=
=
this
.
__ownerID
)
{
return
this
;
}
if
(
!
ownerID
)
{
this
.
__ownerID
=
ownerID
;
this
.
__altered
=
false
;
return
this
;
}
return
makeStack
(
this
.
size
this
.
_head
ownerID
this
.
__hash
)
;
}
;
Stack
.
prototype
.
__iterate
=
function
(
fn
reverse
)
{
if
(
reverse
)
{
return
this
.
reverse
(
)
.
__iterate
(
fn
)
;
}
var
iterations
=
0
;
var
node
=
this
.
_head
;
while
(
node
)
{
if
(
fn
(
node
.
value
iterations
+
+
this
)
=
=
=
false
)
{
break
;
}
node
=
node
.
next
;
}
return
iterations
;
}
;
Stack
.
prototype
.
__iterator
=
function
(
type
reverse
)
{
if
(
reverse
)
{
return
this
.
reverse
(
)
.
__iterator
(
type
)
;
}
var
iterations
=
0
;
var
node
=
this
.
_head
;
return
new
Iterator
(
function
(
)
{
if
(
node
)
{
var
value
=
node
.
value
;
node
=
node
.
next
;
return
iteratorValue
(
type
iterations
+
+
value
)
;
}
return
iteratorDone
(
)
;
}
)
;
}
;
function
isStack
(
maybeStack
)
{
return
!
!
(
maybeStack
&
&
maybeStack
[
IS_STACK_SENTINEL
]
)
;
}
Stack
.
isStack
=
isStack
;
var
IS_STACK_SENTINEL
=
'
__IMMUTABLE_STACK__
'
;
var
StackPrototype
=
Stack
.
prototype
;
StackPrototype
[
IS_STACK_SENTINEL
]
=
true
;
StackPrototype
.
withMutations
=
MapPrototype
.
withMutations
;
StackPrototype
.
asMutable
=
MapPrototype
.
asMutable
;
StackPrototype
.
asImmutable
=
MapPrototype
.
asImmutable
;
StackPrototype
.
wasAltered
=
MapPrototype
.
wasAltered
;
function
makeStack
(
size
head
ownerID
hash
)
{
var
map
=
Object
.
create
(
StackPrototype
)
;
map
.
size
=
size
;
map
.
_head
=
head
;
map
.
__ownerID
=
ownerID
;
map
.
__hash
=
hash
;
map
.
__altered
=
false
;
return
map
;
}
var
EMPTY_STACK
;
function
emptyStack
(
)
{
return
EMPTY_STACK
|
|
(
EMPTY_STACK
=
makeStack
(
0
)
)
;
}
function
mixin
(
ctor
methods
)
{
var
keyCopier
=
function
(
key
)
{
ctor
.
prototype
[
key
]
=
methods
[
key
]
;
}
;
Object
.
keys
(
methods
)
.
forEach
(
keyCopier
)
;
Object
.
getOwnPropertySymbols
&
&
Object
.
getOwnPropertySymbols
(
methods
)
.
forEach
(
keyCopier
)
;
return
ctor
;
}
Iterable
.
Iterator
=
Iterator
;
mixin
(
Iterable
{
toArray
:
function
(
)
{
assertNotInfinite
(
this
.
size
)
;
var
array
=
new
Array
(
this
.
size
|
|
0
)
;
this
.
valueSeq
(
)
.
__iterate
(
function
(
v
i
)
{
array
[
i
]
=
v
;
}
)
;
return
array
;
}
toIndexedSeq
:
function
(
)
{
return
new
ToIndexedSequence
(
this
)
;
}
toJS
:
function
(
)
{
return
this
.
toSeq
(
)
.
map
(
function
(
value
)
{
return
value
&
&
typeof
value
.
toJS
=
=
=
'
function
'
?
value
.
toJS
(
)
:
value
}
)
.
__toJS
(
)
;
}
toJSON
:
function
(
)
{
return
this
.
toSeq
(
)
.
map
(
function
(
value
)
{
return
value
&
&
typeof
value
.
toJSON
=
=
=
'
function
'
?
value
.
toJSON
(
)
:
value
}
)
.
__toJS
(
)
;
}
toKeyedSeq
:
function
(
)
{
return
new
ToKeyedSequence
(
this
true
)
;
}
toMap
:
function
(
)
{
return
Map
(
this
.
toKeyedSeq
(
)
)
;
}
toObject
:
function
(
)
{
assertNotInfinite
(
this
.
size
)
;
var
object
=
{
}
;
this
.
__iterate
(
function
(
v
k
)
{
object
[
k
]
=
v
;
}
)
;
return
object
;
}
toOrderedMap
:
function
(
)
{
return
OrderedMap
(
this
.
toKeyedSeq
(
)
)
;
}
toOrderedSet
:
function
(
)
{
return
OrderedSet
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toSet
:
function
(
)
{
return
Set
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toSetSeq
:
function
(
)
{
return
new
ToSetSequence
(
this
)
;
}
toSeq
:
function
(
)
{
return
isIndexed
(
this
)
?
this
.
toIndexedSeq
(
)
:
isKeyed
(
this
)
?
this
.
toKeyedSeq
(
)
:
this
.
toSetSeq
(
)
;
}
toStack
:
function
(
)
{
return
Stack
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toList
:
function
(
)
{
return
List
(
isKeyed
(
this
)
?
this
.
valueSeq
(
)
:
this
)
;
}
toString
:
function
(
)
{
return
'
[
Iterable
]
'
;
}
__toString
:
function
(
head
tail
)
{
if
(
this
.
size
=
=
=
0
)
{
return
head
+
tail
;
}
return
head
+
'
'
+
this
.
toSeq
(
)
.
map
(
this
.
__toStringMapper
)
.
join
(
'
'
)
+
'
'
+
tail
;
}
concat
:
function
(
)
{
var
values
=
SLICE
0
.
call
(
arguments
0
)
;
return
reify
(
this
concatFactory
(
this
values
)
)
;
}
includes
:
function
(
searchValue
)
{
return
this
.
some
(
function
(
value
)
{
return
is
(
value
searchValue
)
}
)
;
}
entries
:
function
(
)
{
return
this
.
__iterator
(
ITERATE_ENTRIES
)
;
}
every
:
function
(
predicate
context
)
{
assertNotInfinite
(
this
.
size
)
;
var
returnValue
=
true
;
this
.
__iterate
(
function
(
v
k
c
)
{
if
(
!
predicate
.
call
(
context
v
k
c
)
)
{
returnValue
=
false
;
return
false
;
}
}
)
;
return
returnValue
;
}
filter
:
function
(
predicate
context
)
{
return
reify
(
this
filterFactory
(
this
predicate
context
true
)
)
;
}
find
:
function
(
predicate
context
notSetValue
)
{
var
entry
=
this
.
findEntry
(
predicate
context
)
;
return
entry
?
entry
[
1
]
:
notSetValue
;
}
forEach
:
function
(
sideEffect
context
)
{
assertNotInfinite
(
this
.
size
)
;
return
this
.
__iterate
(
context
?
sideEffect
.
bind
(
context
)
:
sideEffect
)
;
}
join
:
function
(
separator
)
{
assertNotInfinite
(
this
.
size
)
;
separator
=
separator
!
=
=
undefined
?
'
'
+
separator
:
'
'
;
var
joined
=
'
'
;
var
isFirst
=
true
;
this
.
__iterate
(
function
(
v
)
{
isFirst
?
(
isFirst
=
false
)
:
(
joined
+
=
separator
)
;
joined
+
=
v
!
=
=
null
&
&
v
!
=
=
undefined
?
v
.
toString
(
)
:
'
'
;
}
)
;
return
joined
;
}
keys
:
function
(
)
{
return
this
.
__iterator
(
ITERATE_KEYS
)
;
}
map
:
function
(
mapper
context
)
{
return
reify
(
this
mapFactory
(
this
mapper
context
)
)
;
}
reduce
:
function
(
reducer
initialReduction
context
)
{
assertNotInfinite
(
this
.
size
)
;
var
reduction
;
var
useFirst
;
if
(
arguments
.
length
<
2
)
{
useFirst
=
true
;
}
else
{
reduction
=
initialReduction
;
}
this
.
__iterate
(
function
(
v
k
c
)
{
if
(
useFirst
)
{
useFirst
=
false
;
reduction
=
v
;
}
else
{
reduction
=
reducer
.
call
(
context
reduction
v
k
c
)
;
}
}
)
;
return
reduction
;
}
reduceRight
:
function
(
reducer
initialReduction
context
)
{
var
reversed
=
this
.
toKeyedSeq
(
)
.
reverse
(
)
;
return
reversed
.
reduce
.
apply
(
reversed
arguments
)
;
}
reverse
:
function
(
)
{
return
reify
(
this
reverseFactory
(
this
true
)
)
;
}
slice
:
function
(
begin
end
)
{
return
reify
(
this
sliceFactory
(
this
begin
end
true
)
)
;
}
some
:
function
(
predicate
context
)
{
return
!
this
.
every
(
not
(
predicate
)
context
)
;
}
sort
:
function
(
comparator
)
{
return
reify
(
this
sortFactory
(
this
comparator
)
)
;
}
values
:
function
(
)
{
return
this
.
__iterator
(
ITERATE_VALUES
)
;
}
butLast
:
function
(
)
{
return
this
.
slice
(
0
-
1
)
;
}
isEmpty
:
function
(
)
{
return
this
.
size
!
=
=
undefined
?
this
.
size
=
=
=
0
:
!
this
.
some
(
function
(
)
{
return
true
}
)
;
}
count
:
function
(
predicate
context
)
{
return
ensureSize
(
predicate
?
this
.
toSeq
(
)
.
filter
(
predicate
context
)
:
this
)
;
}
countBy
:
function
(
grouper
context
)
{
return
countByFactory
(
this
grouper
context
)
;
}
equals
:
function
(
other
)
{
return
deepEqual
(
this
other
)
;
}
entrySeq
:
function
(
)
{
var
iterable
=
this
;
if
(
iterable
.
_cache
)
{
return
new
ArraySeq
(
iterable
.
_cache
)
;
}
var
entriesSequence
=
iterable
.
toSeq
(
)
.
map
(
entryMapper
)
.
toIndexedSeq
(
)
;
entriesSequence
.
fromEntrySeq
=
function
(
)
{
return
iterable
.
toSeq
(
)
}
;
return
entriesSequence
;
}
filterNot
:
function
(
predicate
context
)
{
return
this
.
filter
(
not
(
predicate
)
context
)
;
}
findEntry
:
function
(
predicate
context
notSetValue
)
{
var
found
=
notSetValue
;
this
.
__iterate
(
function
(
v
k
c
)
{
if
(
predicate
.
call
(
context
v
k
c
)
)
{
found
=
[
k
v
]
;
return
false
;
}
}
)
;
return
found
;
}
findKey
:
function
(
predicate
context
)
{
var
entry
=
this
.
findEntry
(
predicate
context
)
;
return
entry
&
&
entry
[
0
]
;
}
findLast
:
function
(
predicate
context
notSetValue
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
find
(
predicate
context
notSetValue
)
;
}
findLastEntry
:
function
(
predicate
context
notSetValue
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
findEntry
(
predicate
context
notSetValue
)
;
}
findLastKey
:
function
(
predicate
context
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
findKey
(
predicate
context
)
;
}
first
:
function
(
)
{
return
this
.
find
(
returnTrue
)
;
}
flatMap
:
function
(
mapper
context
)
{
return
reify
(
this
flatMapFactory
(
this
mapper
context
)
)
;
}
flatten
:
function
(
depth
)
{
return
reify
(
this
flattenFactory
(
this
depth
true
)
)
;
}
fromEntrySeq
:
function
(
)
{
return
new
FromEntriesSequence
(
this
)
;
}
get
:
function
(
searchKey
notSetValue
)
{
return
this
.
find
(
function
(
_
key
)
{
return
is
(
key
searchKey
)
}
undefined
notSetValue
)
;
}
getIn
:
function
(
searchKeyPath
notSetValue
)
{
var
nested
=
this
;
var
iter
=
forceIterator
(
searchKeyPath
)
;
var
step
;
while
(
!
(
step
=
iter
.
next
(
)
)
.
done
)
{
var
key
=
step
.
value
;
nested
=
nested
&
&
nested
.
get
?
nested
.
get
(
key
NOT_SET
)
:
NOT_SET
;
if
(
nested
=
=
=
NOT_SET
)
{
return
notSetValue
;
}
}
return
nested
;
}
groupBy
:
function
(
grouper
context
)
{
return
groupByFactory
(
this
grouper
context
)
;
}
has
:
function
(
searchKey
)
{
return
this
.
get
(
searchKey
NOT_SET
)
!
=
=
NOT_SET
;
}
hasIn
:
function
(
searchKeyPath
)
{
return
this
.
getIn
(
searchKeyPath
NOT_SET
)
!
=
=
NOT_SET
;
}
isSubset
:
function
(
iter
)
{
iter
=
typeof
iter
.
includes
=
=
=
'
function
'
?
iter
:
Iterable
(
iter
)
;
return
this
.
every
(
function
(
value
)
{
return
iter
.
includes
(
value
)
}
)
;
}
isSuperset
:
function
(
iter
)
{
iter
=
typeof
iter
.
isSubset
=
=
=
'
function
'
?
iter
:
Iterable
(
iter
)
;
return
iter
.
isSubset
(
this
)
;
}
keyOf
:
function
(
searchValue
)
{
return
this
.
findKey
(
function
(
value
)
{
return
is
(
value
searchValue
)
}
)
;
}
keySeq
:
function
(
)
{
return
this
.
toSeq
(
)
.
map
(
keyMapper
)
.
toIndexedSeq
(
)
;
}
last
:
function
(
)
{
return
this
.
toSeq
(
)
.
reverse
(
)
.
first
(
)
;
}
lastKeyOf
:
function
(
searchValue
)
{
return
this
.
toKeyedSeq
(
)
.
reverse
(
)
.
keyOf
(
searchValue
)
;
}
max
:
function
(
comparator
)
{
return
maxFactory
(
this
comparator
)
;
}
maxBy
:
function
(
mapper
comparator
)
{
return
maxFactory
(
this
comparator
mapper
)
;
}
min
:
function
(
comparator
)
{
return
maxFactory
(
this
comparator
?
neg
(
comparator
)
:
defaultNegComparator
)
;
}
minBy
:
function
(
mapper
comparator
)
{
return
maxFactory
(
this
comparator
?
neg
(
comparator
)
:
defaultNegComparator
mapper
)
;
}
rest
:
function
(
)
{
return
this
.
slice
(
1
)
;
}
skip
:
function
(
amount
)
{
return
this
.
slice
(
Math
.
max
(
0
amount
)
)
;
}
skipLast
:
function
(
amount
)
{
return
reify
(
this
this
.
toSeq
(
)
.
reverse
(
)
.
skip
(
amount
)
.
reverse
(
)
)
;
}
skipWhile
:
function
(
predicate
context
)
{
return
reify
(
this
skipWhileFactory
(
this
predicate
context
true
)
)
;
}
skipUntil
:
function
(
predicate
context
)
{
return
this
.
skipWhile
(
not
(
predicate
)
context
)
;
}
sortBy
:
function
(
mapper
comparator
)
{
return
reify
(
this
sortFactory
(
this
comparator
mapper
)
)
;
}
take
:
function
(
amount
)
{
return
this
.
slice
(
0
Math
.
max
(
0
amount
)
)
;
}
takeLast
:
function
(
amount
)
{
return
reify
(
this
this
.
toSeq
(
)
.
reverse
(
)
.
take
(
amount
)
.
reverse
(
)
)
;
}
takeWhile
:
function
(
predicate
context
)
{
return
reify
(
this
takeWhileFactory
(
this
predicate
context
)
)
;
}
takeUntil
:
function
(
predicate
context
)
{
return
this
.
takeWhile
(
not
(
predicate
)
context
)
;
}
valueSeq
:
function
(
)
{
return
this
.
toIndexedSeq
(
)
;
}
hashCode
:
function
(
)
{
return
this
.
__hash
|
|
(
this
.
__hash
=
hashIterable
(
this
)
)
;
}
}
)
;
var
IterablePrototype
=
Iterable
.
prototype
;
IterablePrototype
[
IS_ITERABLE_SENTINEL
]
=
true
;
IterablePrototype
[
ITERATOR_SYMBOL
]
=
IterablePrototype
.
values
;
IterablePrototype
.
__toJS
=
IterablePrototype
.
toArray
;
IterablePrototype
.
__toStringMapper
=
quoteString
;
IterablePrototype
.
inspect
=
IterablePrototype
.
toSource
=
function
(
)
{
return
this
.
toString
(
)
;
}
;
IterablePrototype
.
chain
=
IterablePrototype
.
flatMap
;
IterablePrototype
.
contains
=
IterablePrototype
.
includes
;
mixin
(
KeyedIterable
{
flip
:
function
(
)
{
return
reify
(
this
flipFactory
(
this
)
)
;
}
mapEntries
:
function
(
mapper
context
)
{
var
this
0
=
this
;
var
iterations
=
0
;
return
reify
(
this
this
.
toSeq
(
)
.
map
(
function
(
v
k
)
{
return
mapper
.
call
(
context
[
k
v
]
iterations
+
+
this
0
)
}
)
.
fromEntrySeq
(
)
)
;
}
mapKeys
:
function
(
mapper
context
)
{
var
this
0
=
this
;
return
reify
(
this
this
.
toSeq
(
)
.
flip
(
)
.
map
(
function
(
k
v
)
{
return
mapper
.
call
(
context
k
v
this
0
)
}
)
.
flip
(
)
)
;
}
}
)
;
var
KeyedIterablePrototype
=
KeyedIterable
.
prototype
;
KeyedIterablePrototype
[
IS_KEYED_SENTINEL
]
=
true
;
KeyedIterablePrototype
[
ITERATOR_SYMBOL
]
=
IterablePrototype
.
entries
;
KeyedIterablePrototype
.
__toJS
=
IterablePrototype
.
toObject
;
KeyedIterablePrototype
.
__toStringMapper
=
function
(
v
k
)
{
return
JSON
.
stringify
(
k
)
+
'
:
'
+
quoteString
(
v
)
}
;
mixin
(
IndexedIterable
{
toKeyedSeq
:
function
(
)
{
return
new
ToKeyedSequence
(
this
false
)
;
}
filter
:
function
(
predicate
context
)
{
return
reify
(
this
filterFactory
(
this
predicate
context
false
)
)
;
}
findIndex
:
function
(
predicate
context
)
{
var
entry
=
this
.
findEntry
(
predicate
context
)
;
return
entry
?
entry
[
0
]
:
-
1
;
}
indexOf
:
function
(
searchValue
)
{
var
key
=
this
.
keyOf
(
searchValue
)
;
return
key
=
=
=
undefined
?
-
1
:
key
;
}
lastIndexOf
:
function
(
searchValue
)
{
var
key
=
this
.
lastKeyOf
(
searchValue
)
;
return
key
=
=
=
undefined
?
-
1
:
key
;
}
reverse
:
function
(
)
{
return
reify
(
this
reverseFactory
(
this
false
)
)
;
}
slice
:
function
(
begin
end
)
{
return
reify
(
this
sliceFactory
(
this
begin
end
false
)
)
;
}
splice
:
function
(
index
removeNum
)
{
var
numArgs
=
arguments
.
length
;
removeNum
=
Math
.
max
(
removeNum
|
0
0
)
;
if
(
numArgs
=
=
=
0
|
|
(
numArgs
=
=
=
2
&
&
!
removeNum
)
)
{
return
this
;
}
index
=
resolveBegin
(
index
index
<
0
?
this
.
count
(
)
:
this
.
size
)
;
var
spliced
=
this
.
slice
(
0
index
)
;
return
reify
(
this
numArgs
=
=
=
1
?
spliced
:
spliced
.
concat
(
arrCopy
(
arguments
2
)
this
.
slice
(
index
+
removeNum
)
)
)
;
}
findLastIndex
:
function
(
predicate
context
)
{
var
entry
=
this
.
findLastEntry
(
predicate
context
)
;
return
entry
?
entry
[
0
]
:
-
1
;
}
first
:
function
(
)
{
return
this
.
get
(
0
)
;
}
flatten
:
function
(
depth
)
{
return
reify
(
this
flattenFactory
(
this
depth
false
)
)
;
}
get
:
function
(
index
notSetValue
)
{
index
=
wrapIndex
(
this
index
)
;
return
(
index
<
0
|
|
(
this
.
size
=
=
=
Infinity
|
|
(
this
.
size
!
=
=
undefined
&
&
index
>
this
.
size
)
)
)
?
notSetValue
:
this
.
find
(
function
(
_
key
)
{
return
key
=
=
=
index
}
undefined
notSetValue
)
;
}
has
:
function
(
index
)
{
index
=
wrapIndex
(
this
index
)
;
return
index
>
=
0
&
&
(
this
.
size
!
=
=
undefined
?
this
.
size
=
=
=
Infinity
|
|
index
<
this
.
size
:
this
.
indexOf
(
index
)
!
=
=
-
1
)
;
}
interpose
:
function
(
separator
)
{
return
reify
(
this
interposeFactory
(
this
separator
)
)
;
}
interleave
:
function
(
)
{
var
iterables
=
[
this
]
.
concat
(
arrCopy
(
arguments
)
)
;
var
zipped
=
zipWithFactory
(
this
.
toSeq
(
)
IndexedSeq
.
of
iterables
)
;
var
interleaved
=
zipped
.
flatten
(
true
)
;
if
(
zipped
.
size
)
{
interleaved
.
size
=
zipped
.
size
*
iterables
.
length
;
}
return
reify
(
this
interleaved
)
;
}
keySeq
:
function
(
)
{
return
Range
(
0
this
.
size
)
;
}
last
:
function
(
)
{
return
this
.
get
(
-
1
)
;
}
skipWhile
:
function
(
predicate
context
)
{
return
reify
(
this
skipWhileFactory
(
this
predicate
context
false
)
)
;
}
zip
:
function
(
)
{
var
iterables
=
[
this
]
.
concat
(
arrCopy
(
arguments
)
)
;
return
reify
(
this
zipWithFactory
(
this
defaultZipper
iterables
)
)
;
}
zipWith
:
function
(
zipper
)
{
var
iterables
=
arrCopy
(
arguments
)
;
iterables
[
0
]
=
this
;
return
reify
(
this
zipWithFactory
(
this
zipper
iterables
)
)
;
}
}
)
;
IndexedIterable
.
prototype
[
IS_INDEXED_SENTINEL
]
=
true
;
IndexedIterable
.
prototype
[
IS_ORDERED_SENTINEL
]
=
true
;
mixin
(
SetIterable
{
get
:
function
(
value
notSetValue
)
{
return
this
.
has
(
value
)
?
value
:
notSetValue
;
}
includes
:
function
(
value
)
{
return
this
.
has
(
value
)
;
}
keySeq
:
function
(
)
{
return
this
.
valueSeq
(
)
;
}
}
)
;
SetIterable
.
prototype
.
has
=
IterablePrototype
.
includes
;
SetIterable
.
prototype
.
contains
=
SetIterable
.
prototype
.
includes
;
mixin
(
KeyedSeq
KeyedIterable
.
prototype
)
;
mixin
(
IndexedSeq
IndexedIterable
.
prototype
)
;
mixin
(
SetSeq
SetIterable
.
prototype
)
;
mixin
(
KeyedCollection
KeyedIterable
.
prototype
)
;
mixin
(
IndexedCollection
IndexedIterable
.
prototype
)
;
mixin
(
SetCollection
SetIterable
.
prototype
)
;
function
keyMapper
(
v
k
)
{
return
k
;
}
function
entryMapper
(
v
k
)
{
return
[
k
v
]
;
}
function
not
(
predicate
)
{
return
function
(
)
{
return
!
predicate
.
apply
(
this
arguments
)
;
}
}
function
neg
(
predicate
)
{
return
function
(
)
{
return
-
predicate
.
apply
(
this
arguments
)
;
}
}
function
quoteString
(
value
)
{
return
typeof
value
=
=
=
'
string
'
?
JSON
.
stringify
(
value
)
:
String
(
value
)
;
}
function
defaultZipper
(
)
{
return
arrCopy
(
arguments
)
;
}
function
defaultNegComparator
(
a
b
)
{
return
a
<
b
?
1
:
a
>
b
?
-
1
:
0
;
}
function
hashIterable
(
iterable
)
{
if
(
iterable
.
size
=
=
=
Infinity
)
{
return
0
;
}
var
ordered
=
isOrdered
(
iterable
)
;
var
keyed
=
isKeyed
(
iterable
)
;
var
h
=
ordered
?
1
:
0
;
var
size
=
iterable
.
__iterate
(
keyed
?
ordered
?
function
(
v
k
)
{
h
=
31
*
h
+
hashMerge
(
hash
(
v
)
hash
(
k
)
)
|
0
;
}
:
function
(
v
k
)
{
h
=
h
+
hashMerge
(
hash
(
v
)
hash
(
k
)
)
|
0
;
}
:
ordered
?
function
(
v
)
{
h
=
31
*
h
+
hash
(
v
)
|
0
;
}
:
function
(
v
)
{
h
=
h
+
hash
(
v
)
|
0
;
}
)
;
return
murmurHashOfSize
(
size
h
)
;
}
function
murmurHashOfSize
(
size
h
)
{
h
=
imul
(
h
0xCC9E2D51
)
;
h
=
imul
(
h
<
<
15
|
h
>
>
>
-
15
0x1B873593
)
;
h
=
imul
(
h
<
<
13
|
h
>
>
>
-
13
5
)
;
h
=
(
h
+
0xE6546B64
|
0
)
^
size
;
h
=
imul
(
h
^
h
>
>
>
16
0x85EBCA6B
)
;
h
=
imul
(
h
^
h
>
>
>
13
0xC2B2AE35
)
;
h
=
smi
(
h
^
h
>
>
>
16
)
;
return
h
;
}
function
hashMerge
(
a
b
)
{
return
a
^
b
+
0x9E3779B9
+
(
a
<
<
6
)
+
(
a
>
>
2
)
|
0
;
}
var
Immutable
=
{
Iterable
:
Iterable
Seq
:
Seq
Collection
:
Collection
Map
:
Map
OrderedMap
:
OrderedMap
List
:
List
Stack
:
Stack
Set
:
Set
OrderedSet
:
OrderedSet
Record
:
Record
Range
:
Range
Repeat
:
Repeat
is
:
is
fromJS
:
fromJS
}
;
return
Immutable
;
}
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
I
=
__webpack_require__
(
193
)
;
function
makeRecord
(
spec
)
{
return
I
.
Record
(
spec
)
;
}
module
.
exports
=
makeRecord
;
}
function
(
module
exports
__webpack_require__
)
{
var
fromJS
=
__webpack_require__
(
192
)
;
var
_require
=
__webpack_require__
(
176
)
;
var
updateObj
=
_require
.
updateObj
;
var
I
=
__webpack_require__
(
193
)
;
var
makeRecord
=
__webpack_require__
(
194
)
;
var
State
=
makeRecord
(
{
breakpoints
:
I
.
Map
(
)
breakpointsDisabled
:
false
}
)
;
function
firstString
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
for
(
var
arg
of
args
)
{
if
(
typeof
arg
=
=
=
"
string
"
)
{
return
arg
;
}
}
return
null
;
}
function
locationMoved
(
location
newLocation
)
{
return
location
.
line
!
=
=
newLocation
.
line
|
|
location
.
column
!
=
null
&
&
location
.
column
!
=
=
newLocation
.
column
;
}
function
makeLocationId
(
location
)
{
return
location
.
sourceId
+
"
:
"
+
location
.
line
.
toString
(
)
;
}
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
State
(
)
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
"
ADD_BREAKPOINT
"
:
{
var
id
=
makeLocationId
(
action
.
breakpoint
.
location
)
;
if
(
action
.
status
=
=
=
"
start
"
)
{
var
bp
=
state
.
breakpoints
.
get
(
id
)
|
|
action
.
breakpoint
;
return
state
.
setIn
(
[
"
breakpoints
"
id
]
updateObj
(
bp
{
disabled
:
false
loading
:
true
condition
:
firstString
(
action
.
condition
bp
.
condition
)
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_action
value
=
action
.
value
;
var
breakpointId
=
_action
value
.
id
;
var
text
=
_action
value
.
text
;
var
location
=
action
.
breakpoint
.
location
;
var
actualLocation
=
action
.
value
.
actualLocation
;
if
(
locationMoved
(
location
actualLocation
)
)
{
state
=
state
.
deleteIn
(
[
"
breakpoints
"
id
]
)
;
var
movedId
=
makeLocationId
(
actualLocation
)
;
var
currentBp
=
state
.
breakpoints
.
get
(
movedId
)
|
|
fromJS
(
action
.
breakpoint
)
;
var
newBp
=
updateObj
(
currentBp
{
location
:
actualLocation
}
)
;
state
=
state
.
setIn
(
[
"
breakpoints
"
movedId
]
newBp
)
;
location
=
actualLocation
;
}
var
locationId
=
makeLocationId
(
location
)
;
var
_bp
=
state
.
breakpoints
.
get
(
locationId
)
;
return
state
.
setIn
(
[
"
breakpoints
"
locationId
]
updateObj
(
_bp
{
id
:
breakpointId
disabled
:
false
loading
:
false
text
:
text
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
)
{
return
state
.
deleteIn
(
[
"
breakpoints
"
id
]
)
;
}
break
;
}
case
"
REMOVE_BREAKPOINT
"
:
{
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_id
=
makeLocationId
(
action
.
breakpoint
.
location
)
;
if
(
action
.
disabled
)
{
var
_bp2
=
state
.
breakpoints
.
get
(
_id
)
;
return
state
.
setIn
(
[
"
breakpoints
"
_id
]
updateObj
(
_bp2
{
loading
:
false
disabled
:
true
}
)
)
;
}
return
state
.
deleteIn
(
[
"
breakpoints
"
_id
]
)
;
}
break
;
}
case
"
TOGGLE_BREAKPOINTS
"
:
{
if
(
action
.
status
=
=
=
"
start
"
)
{
return
state
.
set
(
"
breakpointsDisabled
"
action
.
shouldDisableBreakpoints
)
;
}
break
;
}
case
"
SET_BREAKPOINT_CONDITION
"
:
{
var
_id2
=
makeLocationId
(
action
.
breakpoint
.
location
)
;
if
(
action
.
status
=
=
=
"
start
"
)
{
var
_bp3
=
state
.
breakpoints
.
get
(
_id2
)
;
return
state
.
setIn
(
[
"
breakpoints
"
_id2
]
updateObj
(
_bp3
{
loading
:
true
condition
:
action
.
condition
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
done
"
)
{
var
_bp4
=
state
.
breakpoints
.
get
(
_id2
)
;
return
state
.
setIn
(
[
"
breakpoints
"
_id2
]
updateObj
(
_bp4
{
loading
:
false
}
)
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
)
{
return
state
.
deleteIn
(
[
"
breakpoints
"
_id2
]
)
;
}
break
;
}
}
return
state
;
}
function
getBreakpoint
(
state
location
)
{
return
state
.
breakpoints
.
breakpoints
.
get
(
makeLocationId
(
location
)
)
;
}
function
getBreakpoints
(
state
)
{
return
state
.
breakpoints
.
breakpoints
;
}
function
getBreakpointsForSource
(
state
sourceId
)
{
return
state
.
breakpoints
.
breakpoints
.
filter
(
bp
=
>
{
return
bp
.
location
.
sourceId
=
=
=
sourceId
;
}
)
;
}
function
getBreakpointsDisabled
(
state
)
{
return
state
.
breakpoints
.
get
(
"
breakpointsDisabled
"
)
;
}
function
getBreakpointsLoading
(
state
)
{
var
breakpoints
=
getBreakpoints
(
state
)
;
var
isLoading
=
!
!
breakpoints
.
valueSeq
(
)
.
filter
(
bp
=
>
bp
.
loading
)
.
first
(
)
;
return
breakpoints
.
size
>
0
&
&
isLoading
;
}
module
.
exports
=
{
State
update
makeLocationId
getBreakpoint
getBreakpoints
getBreakpointsForSource
getBreakpointsDisabled
getBreakpointsLoading
}
;
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
constants
=
__webpack_require__
(
190
)
;
var
initialState
=
[
]
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
var
seqId
=
action
.
seqId
;
if
(
action
.
type
=
=
=
constants
.
NAVIGATE
)
{
return
initialState
;
}
else
if
(
seqId
)
{
var
newState
=
void
0
;
if
(
action
.
status
=
=
=
"
start
"
)
{
newState
=
[
]
.
concat
(
_toConsumableArray
(
state
)
[
seqId
]
)
;
}
else
if
(
action
.
status
=
=
=
"
error
"
|
|
action
.
status
=
=
=
"
done
"
)
{
newState
=
state
.
filter
(
id
=
>
id
!
=
=
seqId
)
;
}
return
newState
;
}
return
state
;
}
module
.
exports
=
update
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
190
)
;
var
Immutable
=
__webpack_require__
(
193
)
;
var
fromJS
=
__webpack_require__
(
192
)
;
var
initialState
=
fromJS
(
{
tabs
:
{
}
selectedTab
:
null
}
)
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
switch
(
action
.
type
)
{
case
constants
.
ADD_TABS
:
var
tabs
=
action
.
value
;
if
(
!
tabs
)
{
return
state
;
}
return
state
.
mergeIn
(
[
"
tabs
"
]
Immutable
.
Map
(
tabs
.
map
(
tab
=
>
{
tab
=
Object
.
assign
(
{
}
tab
{
id
:
getTabId
(
tab
)
}
)
;
return
[
tab
.
id
Immutable
.
Map
(
tab
)
]
;
}
)
)
)
;
case
constants
.
SELECT_TAB
:
var
tab
=
state
.
getIn
(
[
"
tabs
"
action
.
id
]
)
;
return
state
.
setIn
(
[
"
selectedTab
"
]
tab
)
;
}
return
state
;
}
function
getTabId
(
tab
)
{
var
id
=
tab
.
id
;
var
isFirefox
=
tab
.
browser
=
=
"
firefox
"
;
if
(
isFirefox
)
{
id
=
tab
.
id
.
split
(
"
.
"
)
.
pop
(
)
;
}
return
id
;
}
module
.
exports
=
update
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
190
)
;
var
fromJS
=
__webpack_require__
(
192
)
;
var
initialState
=
fromJS
(
{
pause
:
null
isWaitingOnBreak
:
false
frames
:
null
selectedFrameId
:
null
loadedObjects
:
{
}
shouldPauseOnExceptions
:
false
shouldIgnoreCaughtExceptions
:
false
expressions
:
[
]
}
)
;
function
update
(
)
{
var
state
=
arguments
.
length
<
=
0
|
|
arguments
[
0
]
=
=
=
undefined
?
initialState
:
arguments
[
0
]
;
var
action
=
arguments
[
1
]
;
var
emit
=
arguments
[
2
]
;
switch
(
action
.
type
)
{
case
constants
.
PAUSED
:
{
var
selectedFrameId
=
action
.
selectedFrameId
;
var
frames
=
action
.
frames
;
var
pauseInfo
=
action
.
pauseInfo
;
pauseInfo
.
isInterrupted
=
pauseInfo
.
why
.
type
=
=
=
"
interrupted
"
;
return
state
.
merge
(
{
isWaitingOnBreak
:
false
pause
:
fromJS
(
pauseInfo
)
selectedFrameId
frames
}
)
;
}
case
constants
.
RESUME
:
return
state
.
merge
(
{
pause
:
null
frames
:
null
selectedFrameId
:
null
loadedObjects
:
{
}
}
)
;
case
constants
.
TOGGLE_PRETTY_PRINT
:
if
(
action
.
status
=
=
"
done
"
)
{
var
_frames
=
action
.
value
.
frames
;
return
state
.
merge
(
{
frames
:
_frames
}
)
;
}
break
;
case
constants
.
BREAK_ON_NEXT
:
return
state
.
set
(
"
isWaitingOnBreak
"
true
)
;
case
constants
.
LOADED_FRAMES
:
if
(
action
.
status
=
=
"
done
"
)
{
return
state
.
set
(
"
frames
"
action
.
value
.
frames
)
;
}
break
;
case
constants
.
SELECT_FRAME
:
return
state
.
set
(
"
selectedFrameId
"
action
.
frame
.
id
)
;
case
constants
.
LOAD_OBJECT_PROPERTIES
:
if
(
action
.
status
=
=
=
"
done
"
)
{
var
ownProperties
=
action
.
value
.
ownProperties
;
var
prototype
=
action
.
value
.
prototype
;
return
state
.
setIn
(
[
"
loadedObjects
"
action
.
objectId
]
{
ownProperties
prototype
}
)
;
}
break
;
case
constants
.
NAVIGATE
:
return
initialState
;
case
constants
.
PAUSE_ON_EXCEPTIONS
:
var
shouldPauseOnExceptions
=
action
.
shouldPauseOnExceptions
;
var
shouldIgnoreCaughtExceptions
=
action
.
shouldIgnoreCaughtExceptions
;
return
state
.
merge
(
{
shouldPauseOnExceptions
shouldIgnoreCaughtExceptions
}
)
;
case
constants
.
ADD_EXPRESSION
:
return
state
.
setIn
(
[
"
expressions
"
action
.
id
]
{
id
:
action
.
id
input
:
action
.
input
value
:
action
.
value
updating
:
false
}
)
;
case
constants
.
EVALUATE_EXPRESSION
:
if
(
action
.
status
=
=
=
"
done
"
)
{
return
state
.
mergeIn
(
[
"
expressions
"
action
.
id
]
{
id
:
action
.
id
input
:
action
.
input
value
:
action
.
value
updating
:
false
}
)
;
}
break
;
case
constants
.
UPDATE_EXPRESSION
:
return
state
.
mergeIn
(
[
"
expressions
"
action
.
id
]
{
id
:
action
.
id
input
:
action
.
input
updating
:
true
}
)
;
case
constants
.
DELETE_EXPRESSION
:
return
state
.
deleteIn
(
[
"
expressions
"
action
.
id
]
)
;
}
return
state
;
}
function
getPause
(
state
)
{
return
state
.
pause
.
get
(
"
pause
"
)
;
}
function
getLoadedObjects
(
state
)
{
return
state
.
pause
.
get
(
"
loadedObjects
"
)
;
}
function
getExpressions
(
state
)
{
return
state
.
pause
.
get
(
"
expressions
"
)
;
}
function
getIsWaitingOnBreak
(
state
)
{
return
state
.
pause
.
get
(
"
isWaitingOnBreak
"
)
;
}
function
getShouldPauseOnExceptions
(
state
)
{
return
state
.
pause
.
get
(
"
shouldPauseOnExceptions
"
)
;
}
function
getShouldIgnoreCaughtExceptions
(
state
)
{
return
state
.
pause
.
get
(
"
shouldIgnoreCaughtExceptions
"
)
;
}
function
getFrames
(
state
)
{
return
state
.
pause
.
get
(
"
frames
"
)
|
|
[
]
;
}
function
getSelectedFrame
(
state
)
{
var
selectedFrameId
=
state
.
pause
.
get
(
"
selectedFrameId
"
)
;
var
frames
=
state
.
pause
.
get
(
"
frames
"
)
;
return
frames
&
&
frames
.
find
(
frame
=
>
frame
.
id
=
=
selectedFrameId
)
;
}
module
.
exports
=
{
initialState
update
getPause
getLoadedObjects
getExpressions
getIsWaitingOnBreak
getShouldPauseOnExceptions
getShouldIgnoreCaughtExceptions
getFrames
getSelectedFrame
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
URL
=
__webpack_require__
(
200
)
;
var
path
=
__webpack_require__
(
205
)
;
var
sources
=
__webpack_require__
(
191
)
;
var
pause
=
__webpack_require__
(
198
)
;
var
breakpoints
=
__webpack_require__
(
195
)
;
function
getTabs
(
state
)
{
return
state
.
tabs
.
get
(
"
tabs
"
)
;
}
function
getSelectedTab
(
state
)
{
return
state
.
tabs
.
get
(
"
selectedTab
"
)
;
}
function
getSourceMapURL
(
state
source
)
{
if
(
path
.
isURL
(
source
.
sourceMapURL
)
)
{
return
source
.
sourceMapURL
;
}
else
if
(
path
.
isAbsolute
(
source
.
sourceMapURL
)
)
{
var
urlObj
=
URL
.
parse
(
source
.
url
)
;
var
base
=
urlObj
.
protocol
+
"
/
/
"
+
urlObj
.
host
;
return
base
+
source
.
sourceMapURL
;
}
return
path
.
dirname
(
source
.
url
)
+
"
/
"
+
source
.
sourceMapURL
;
}
module
.
exports
=
{
getSource
:
sources
.
getSource
getSourceByURL
:
sources
.
getSourceByURL
getSourceById
:
sources
.
getSourceById
getSources
:
sources
.
getSources
getSourceText
:
sources
.
getSourceText
getSourceTabs
:
sources
.
getSourceTabs
getSelectedSource
:
sources
.
getSelectedSource
getSelectedLocation
:
sources
.
getSelectedLocation
getPendingSelectedLocation
:
sources
.
getPendingSelectedLocation
getSourceMap
:
sources
.
getSourceMap
getPrettySource
:
sources
.
getPrettySource
getSourceMapURL
getBreakpoint
:
breakpoints
.
getBreakpoint
getBreakpoints
:
breakpoints
.
getBreakpoints
getBreakpointsForSource
:
breakpoints
.
getBreakpointsForSource
getBreakpointsDisabled
:
breakpoints
.
getBreakpointsDisabled
getBreakpointsLoading
:
breakpoints
.
getBreakpointsLoading
getTabs
getSelectedTab
getPause
:
pause
.
getPause
getLoadedObjects
:
pause
.
getLoadedObjects
getExpressions
:
pause
.
getExpressions
getIsWaitingOnBreak
:
pause
.
getIsWaitingOnBreak
getShouldPauseOnExceptions
:
pause
.
getShouldPauseOnExceptions
getShouldIgnoreCaughtExceptions
:
pause
.
getShouldIgnoreCaughtExceptions
getFrames
:
pause
.
getFrames
getSelectedFrame
:
pause
.
getSelectedFrame
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
punycode
=
__webpack_require__
(
201
)
;
exports
.
parse
=
urlParse
;
exports
.
resolve
=
urlResolve
;
exports
.
resolveObject
=
urlResolveObject
;
exports
.
format
=
urlFormat
;
exports
.
Url
=
Url
;
function
Url
(
)
{
this
.
protocol
=
null
;
this
.
slashes
=
null
;
this
.
auth
=
null
;
this
.
host
=
null
;
this
.
port
=
null
;
this
.
hostname
=
null
;
this
.
hash
=
null
;
this
.
search
=
null
;
this
.
query
=
null
;
this
.
pathname
=
null
;
this
.
path
=
null
;
this
.
href
=
null
;
}
var
protocolPattern
=
/
^
(
[
a
-
z0
-
9
.
+
-
]
+
:
)
/
i
portPattern
=
/
:
[
0
-
9
]
*
/
delims
=
[
'
<
'
'
>
'
'
"
'
'
'
'
'
'
\
r
'
'
\
n
'
'
\
t
'
]
unwise
=
[
'
{
'
'
}
'
'
|
'
'
\
\
'
'
^
'
'
'
]
.
concat
(
delims
)
autoEscape
=
[
'
\
'
'
]
.
concat
(
unwise
)
nonHostChars
=
[
'
%
'
'
/
'
'
?
'
'
;
'
'
#
'
]
.
concat
(
autoEscape
)
hostEndingChars
=
[
'
/
'
'
?
'
'
#
'
]
hostnameMaxLen
=
255
hostnamePartPattern
=
/
^
[
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
/
hostnamePartStart
=
/
^
(
[
a
-
z0
-
9A
-
Z_
-
]
{
0
63
}
)
(
.
*
)
/
unsafeProtocol
=
{
'
javascript
'
:
true
'
javascript
:
'
:
true
}
hostlessProtocol
=
{
'
javascript
'
:
true
'
javascript
:
'
:
true
}
slashedProtocol
=
{
'
http
'
:
true
'
https
'
:
true
'
ftp
'
:
true
'
gopher
'
:
true
'
file
'
:
true
'
http
:
'
:
true
'
https
:
'
:
true
'
ftp
:
'
:
true
'
gopher
:
'
:
true
'
file
:
'
:
true
}
querystring
=
__webpack_require__
(
202
)
;
function
urlParse
(
url
parseQueryString
slashesDenoteHost
)
{
if
(
url
&
&
isObject
(
url
)
&
&
url
instanceof
Url
)
return
url
;
var
u
=
new
Url
;
u
.
parse
(
url
parseQueryString
slashesDenoteHost
)
;
return
u
;
}
Url
.
prototype
.
parse
=
function
(
url
parseQueryString
slashesDenoteHost
)
{
if
(
!
isString
(
url
)
)
{
throw
new
TypeError
(
"
Parameter
'
url
'
must
be
a
string
not
"
+
typeof
url
)
;
}
var
rest
=
url
;
rest
=
rest
.
trim
(
)
;
var
proto
=
protocolPattern
.
exec
(
rest
)
;
if
(
proto
)
{
proto
=
proto
[
0
]
;
var
lowerProto
=
proto
.
toLowerCase
(
)
;
this
.
protocol
=
lowerProto
;
rest
=
rest
.
substr
(
proto
.
length
)
;
}
if
(
slashesDenoteHost
|
|
proto
|
|
rest
.
match
(
/
^
\
/
\
/
[
^
\
/
]
+
[
^
\
/
]
+
/
)
)
{
var
slashes
=
rest
.
substr
(
0
2
)
=
=
=
'
/
/
'
;
if
(
slashes
&
&
!
(
proto
&
&
hostlessProtocol
[
proto
]
)
)
{
rest
=
rest
.
substr
(
2
)
;
this
.
slashes
=
true
;
}
}
if
(
!
hostlessProtocol
[
proto
]
&
&
(
slashes
|
|
(
proto
&
&
!
slashedProtocol
[
proto
]
)
)
)
{
var
hostEnd
=
-
1
;
for
(
var
i
=
0
;
i
<
hostEndingChars
.
length
;
i
+
+
)
{
var
hec
=
rest
.
indexOf
(
hostEndingChars
[
i
]
)
;
if
(
hec
!
=
=
-
1
&
&
(
hostEnd
=
=
=
-
1
|
|
hec
<
hostEnd
)
)
hostEnd
=
hec
;
}
var
auth
atSign
;
if
(
hostEnd
=
=
=
-
1
)
{
atSign
=
rest
.
lastIndexOf
(
'
'
)
;
}
else
{
atSign
=
rest
.
lastIndexOf
(
'
'
hostEnd
)
;
}
if
(
atSign
!
=
=
-
1
)
{
auth
=
rest
.
slice
(
0
atSign
)
;
rest
=
rest
.
slice
(
atSign
+
1
)
;
this
.
auth
=
decodeURIComponent
(
auth
)
;
}
hostEnd
=
-
1
;
for
(
var
i
=
0
;
i
<
nonHostChars
.
length
;
i
+
+
)
{
var
hec
=
rest
.
indexOf
(
nonHostChars
[
i
]
)
;
if
(
hec
!
=
=
-
1
&
&
(
hostEnd
=
=
=
-
1
|
|
hec
<
hostEnd
)
)
hostEnd
=
hec
;
}
if
(
hostEnd
=
=
=
-
1
)
hostEnd
=
rest
.
length
;
this
.
host
=
rest
.
slice
(
0
hostEnd
)
;
rest
=
rest
.
slice
(
hostEnd
)
;
this
.
parseHost
(
)
;
this
.
hostname
=
this
.
hostname
|
|
'
'
;
var
ipv6Hostname
=
this
.
hostname
[
0
]
=
=
=
'
[
'
&
&
this
.
hostname
[
this
.
hostname
.
length
-
1
]
=
=
=
'
]
'
;
if
(
!
ipv6Hostname
)
{
var
hostparts
=
this
.
hostname
.
split
(
/
\
.
/
)
;
for
(
var
i
=
0
l
=
hostparts
.
length
;
i
<
l
;
i
+
+
)
{
var
part
=
hostparts
[
i
]
;
if
(
!
part
)
continue
;
if
(
!
part
.
match
(
hostnamePartPattern
)
)
{
var
newpart
=
'
'
;
for
(
var
j
=
0
k
=
part
.
length
;
j
<
k
;
j
+
+
)
{
if
(
part
.
charCodeAt
(
j
)
>
127
)
{
newpart
+
=
'
x
'
;
}
else
{
newpart
+
=
part
[
j
]
;
}
}
if
(
!
newpart
.
match
(
hostnamePartPattern
)
)
{
var
validParts
=
hostparts
.
slice
(
0
i
)
;
var
notHost
=
hostparts
.
slice
(
i
+
1
)
;
var
bit
=
part
.
match
(
hostnamePartStart
)
;
if
(
bit
)
{
validParts
.
push
(
bit
[
1
]
)
;
notHost
.
unshift
(
bit
[
2
]
)
;
}
if
(
notHost
.
length
)
{
rest
=
'
/
'
+
notHost
.
join
(
'
.
'
)
+
rest
;
}
this
.
hostname
=
validParts
.
join
(
'
.
'
)
;
break
;
}
}
}
}
if
(
this
.
hostname
.
length
>
hostnameMaxLen
)
{
this
.
hostname
=
'
'
;
}
else
{
this
.
hostname
=
this
.
hostname
.
toLowerCase
(
)
;
}
if
(
!
ipv6Hostname
)
{
var
domainArray
=
this
.
hostname
.
split
(
'
.
'
)
;
var
newOut
=
[
]
;
for
(
var
i
=
0
;
i
<
domainArray
.
length
;
+
+
i
)
{
var
s
=
domainArray
[
i
]
;
newOut
.
push
(
s
.
match
(
/
[
^
A
-
Za
-
z0
-
9_
-
]
/
)
?
'
xn
-
-
'
+
punycode
.
encode
(
s
)
:
s
)
;
}
this
.
hostname
=
newOut
.
join
(
'
.
'
)
;
}
var
p
=
this
.
port
?
'
:
'
+
this
.
port
:
'
'
;
var
h
=
this
.
hostname
|
|
'
'
;
this
.
host
=
h
+
p
;
this
.
href
+
=
this
.
host
;
if
(
ipv6Hostname
)
{
this
.
hostname
=
this
.
hostname
.
substr
(
1
this
.
hostname
.
length
-
2
)
;
if
(
rest
[
0
]
!
=
=
'
/
'
)
{
rest
=
'
/
'
+
rest
;
}
}
}
if
(
!
unsafeProtocol
[
lowerProto
]
)
{
for
(
var
i
=
0
l
=
autoEscape
.
length
;
i
<
l
;
i
+
+
)
{
var
ae
=
autoEscape
[
i
]
;
var
esc
=
encodeURIComponent
(
ae
)
;
if
(
esc
=
=
=
ae
)
{
esc
=
escape
(
ae
)
;
}
rest
=
rest
.
split
(
ae
)
.
join
(
esc
)
;
}
}
var
hash
=
rest
.
indexOf
(
'
#
'
)
;
if
(
hash
!
=
=
-
1
)
{
this
.
hash
=
rest
.
substr
(
hash
)
;
rest
=
rest
.
slice
(
0
hash
)
;
}
var
qm
=
rest
.
indexOf
(
'
?
'
)
;
if
(
qm
!
=
=
-
1
)
{
this
.
search
=
rest
.
substr
(
qm
)
;
this
.
query
=
rest
.
substr
(
qm
+
1
)
;
if
(
parseQueryString
)
{
this
.
query
=
querystring
.
parse
(
this
.
query
)
;
}
rest
=
rest
.
slice
(
0
qm
)
;
}
else
if
(
parseQueryString
)
{
this
.
search
=
'
'
;
this
.
query
=
{
}
;
}
if
(
rest
)
this
.
pathname
=
rest
;
if
(
slashedProtocol
[
lowerProto
]
&
&
this
.
hostname
&
&
!
this
.
pathname
)
{
this
.
pathname
=
'
/
'
;
}
if
(
this
.
pathname
|
|
this
.
search
)
{
var
p
=
this
.
pathname
|
|
'
'
;
var
s
=
this
.
search
|
|
'
'
;
this
.
path
=
p
+
s
;
}
this
.
href
=
this
.
format
(
)
;
return
this
;
}
;
function
urlFormat
(
obj
)
{
if
(
isString
(
obj
)
)
obj
=
urlParse
(
obj
)
;
if
(
!
(
obj
instanceof
Url
)
)
return
Url
.
prototype
.
format
.
call
(
obj
)
;
return
obj
.
format
(
)
;
}
Url
.
prototype
.
format
=
function
(
)
{
var
auth
=
this
.
auth
|
|
'
'
;
if
(
auth
)
{
auth
=
encodeURIComponent
(
auth
)
;
auth
=
auth
.
replace
(
/
%
3A
/
i
'
:
'
)
;
auth
+
=
'
'
;
}
var
protocol
=
this
.
protocol
|
|
'
'
pathname
=
this
.
pathname
|
|
'
'
hash
=
this
.
hash
|
|
'
'
host
=
false
query
=
'
'
;
if
(
this
.
host
)
{
host
=
auth
+
this
.
host
;
}
else
if
(
this
.
hostname
)
{
host
=
auth
+
(
this
.
hostname
.
indexOf
(
'
:
'
)
=
=
=
-
1
?
this
.
hostname
:
'
[
'
+
this
.
hostname
+
'
]
'
)
;
if
(
this
.
port
)
{
host
+
=
'
:
'
+
this
.
port
;
}
}
if
(
this
.
query
&
&
isObject
(
this
.
query
)
&
&
Object
.
keys
(
this
.
query
)
.
length
)
{
query
=
querystring
.
stringify
(
this
.
query
)
;
}
var
search
=
this
.
search
|
|
(
query
&
&
(
'
?
'
+
query
)
)
|
|
'
'
;
if
(
protocol
&
&
protocol
.
substr
(
-
1
)
!
=
=
'
:
'
)
protocol
+
=
'
:
'
;
if
(
this
.
slashes
|
|
(
!
protocol
|
|
slashedProtocol
[
protocol
]
)
&
&
host
!
=
=
false
)
{
host
=
'
/
/
'
+
(
host
|
|
'
'
)
;
if
(
pathname
&
&
pathname
.
charAt
(
0
)
!
=
=
'
/
'
)
pathname
=
'
/
'
+
pathname
;
}
else
if
(
!
host
)
{
host
=
'
'
;
}
if
(
hash
&
&
hash
.
charAt
(
0
)
!
=
=
'
#
'
)
hash
=
'
#
'
+
hash
;
if
(
search
&
&
search
.
charAt
(
0
)
!
=
=
'
?
'
)
search
=
'
?
'
+
search
;
pathname
=
pathname
.
replace
(
/
[
?
#
]
/
g
function
(
match
)
{
return
encodeURIComponent
(
match
)
;
}
)
;
search
=
search
.
replace
(
'
#
'
'
%
23
'
)
;
return
protocol
+
host
+
pathname
+
search
+
hash
;
}
;
function
urlResolve
(
source
relative
)
{
return
urlParse
(
source
false
true
)
.
resolve
(
relative
)
;
}
Url
.
prototype
.
resolve
=
function
(
relative
)
{
return
this
.
resolveObject
(
urlParse
(
relative
false
true
)
)
.
format
(
)
;
}
;
function
urlResolveObject
(
source
relative
)
{
if
(
!
source
)
return
relative
;
return
urlParse
(
source
false
true
)
.
resolveObject
(
relative
)
;
}
Url
.
prototype
.
resolveObject
=
function
(
relative
)
{
if
(
isString
(
relative
)
)
{
var
rel
=
new
Url
(
)
;
rel
.
parse
(
relative
false
true
)
;
relative
=
rel
;
}
var
result
=
new
Url
(
)
;
Object
.
keys
(
this
)
.
forEach
(
function
(
k
)
{
result
[
k
]
=
this
[
k
]
;
}
this
)
;
result
.
hash
=
relative
.
hash
;
if
(
relative
.
href
=
=
=
'
'
)
{
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
relative
.
slashes
&
&
!
relative
.
protocol
)
{
Object
.
keys
(
relative
)
.
forEach
(
function
(
k
)
{
if
(
k
!
=
=
'
protocol
'
)
result
[
k
]
=
relative
[
k
]
;
}
)
;
if
(
slashedProtocol
[
result
.
protocol
]
&
&
result
.
hostname
&
&
!
result
.
pathname
)
{
result
.
path
=
result
.
pathname
=
'
/
'
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
relative
.
protocol
&
&
relative
.
protocol
!
=
=
result
.
protocol
)
{
if
(
!
slashedProtocol
[
relative
.
protocol
]
)
{
Object
.
keys
(
relative
)
.
forEach
(
function
(
k
)
{
result
[
k
]
=
relative
[
k
]
;
}
)
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
result
.
protocol
=
relative
.
protocol
;
if
(
!
relative
.
host
&
&
!
hostlessProtocol
[
relative
.
protocol
]
)
{
var
relPath
=
(
relative
.
pathname
|
|
'
'
)
.
split
(
'
/
'
)
;
while
(
relPath
.
length
&
&
!
(
relative
.
host
=
relPath
.
shift
(
)
)
)
;
if
(
!
relative
.
host
)
relative
.
host
=
'
'
;
if
(
!
relative
.
hostname
)
relative
.
hostname
=
'
'
;
if
(
relPath
[
0
]
!
=
=
'
'
)
relPath
.
unshift
(
'
'
)
;
if
(
relPath
.
length
<
2
)
relPath
.
unshift
(
'
'
)
;
result
.
pathname
=
relPath
.
join
(
'
/
'
)
;
}
else
{
result
.
pathname
=
relative
.
pathname
;
}
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
result
.
host
=
relative
.
host
|
|
'
'
;
result
.
auth
=
relative
.
auth
;
result
.
hostname
=
relative
.
hostname
|
|
relative
.
host
;
result
.
port
=
relative
.
port
;
if
(
result
.
pathname
|
|
result
.
search
)
{
var
p
=
result
.
pathname
|
|
'
'
;
var
s
=
result
.
search
|
|
'
'
;
result
.
path
=
p
+
s
;
}
result
.
slashes
=
result
.
slashes
|
|
relative
.
slashes
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
var
isSourceAbs
=
(
result
.
pathname
&
&
result
.
pathname
.
charAt
(
0
)
=
=
=
'
/
'
)
isRelAbs
=
(
relative
.
host
|
|
relative
.
pathname
&
&
relative
.
pathname
.
charAt
(
0
)
=
=
=
'
/
'
)
mustEndAbs
=
(
isRelAbs
|
|
isSourceAbs
|
|
(
result
.
host
&
&
relative
.
pathname
)
)
removeAllDots
=
mustEndAbs
srcPath
=
result
.
pathname
&
&
result
.
pathname
.
split
(
'
/
'
)
|
|
[
]
relPath
=
relative
.
pathname
&
&
relative
.
pathname
.
split
(
'
/
'
)
|
|
[
]
psychotic
=
result
.
protocol
&
&
!
slashedProtocol
[
result
.
protocol
]
;
if
(
psychotic
)
{
result
.
hostname
=
'
'
;
result
.
port
=
null
;
if
(
result
.
host
)
{
if
(
srcPath
[
0
]
=
=
=
'
'
)
srcPath
[
0
]
=
result
.
host
;
else
srcPath
.
unshift
(
result
.
host
)
;
}
result
.
host
=
'
'
;
if
(
relative
.
protocol
)
{
relative
.
hostname
=
null
;
relative
.
port
=
null
;
if
(
relative
.
host
)
{
if
(
relPath
[
0
]
=
=
=
'
'
)
relPath
[
0
]
=
relative
.
host
;
else
relPath
.
unshift
(
relative
.
host
)
;
}
relative
.
host
=
null
;
}
mustEndAbs
=
mustEndAbs
&
&
(
relPath
[
0
]
=
=
=
'
'
|
|
srcPath
[
0
]
=
=
=
'
'
)
;
}
if
(
isRelAbs
)
{
result
.
host
=
(
relative
.
host
|
|
relative
.
host
=
=
=
'
'
)
?
relative
.
host
:
result
.
host
;
result
.
hostname
=
(
relative
.
hostname
|
|
relative
.
hostname
=
=
=
'
'
)
?
relative
.
hostname
:
result
.
hostname
;
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
srcPath
=
relPath
;
}
else
if
(
relPath
.
length
)
{
if
(
!
srcPath
)
srcPath
=
[
]
;
srcPath
.
pop
(
)
;
srcPath
=
srcPath
.
concat
(
relPath
)
;
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
}
else
if
(
!
isNullOrUndefined
(
relative
.
search
)
)
{
if
(
psychotic
)
{
result
.
hostname
=
result
.
host
=
srcPath
.
shift
(
)
;
var
authInHost
=
result
.
host
&
&
result
.
host
.
indexOf
(
'
'
)
>
0
?
result
.
host
.
split
(
'
'
)
:
false
;
if
(
authInHost
)
{
result
.
auth
=
authInHost
.
shift
(
)
;
result
.
host
=
result
.
hostname
=
authInHost
.
shift
(
)
;
}
}
result
.
search
=
relative
.
search
;
result
.
query
=
relative
.
query
;
if
(
!
isNull
(
result
.
pathname
)
|
|
!
isNull
(
result
.
search
)
)
{
result
.
path
=
(
result
.
pathname
?
result
.
pathname
:
'
'
)
+
(
result
.
search
?
result
.
search
:
'
'
)
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
if
(
!
srcPath
.
length
)
{
result
.
pathname
=
null
;
if
(
result
.
search
)
{
result
.
path
=
'
/
'
+
result
.
search
;
}
else
{
result
.
path
=
null
;
}
result
.
href
=
result
.
format
(
)
;
return
result
;
}
var
last
=
srcPath
.
slice
(
-
1
)
[
0
]
;
var
hasTrailingSlash
=
(
(
result
.
host
|
|
relative
.
host
)
&
&
(
last
=
=
=
'
.
'
|
|
last
=
=
=
'
.
.
'
)
|
|
last
=
=
=
'
'
)
;
var
up
=
0
;
for
(
var
i
=
srcPath
.
length
;
i
>
=
0
;
i
-
-
)
{
last
=
srcPath
[
i
]
;
if
(
last
=
=
'
.
'
)
{
srcPath
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
srcPath
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
srcPath
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
!
mustEndAbs
&
&
!
removeAllDots
)
{
for
(
;
up
-
-
;
up
)
{
srcPath
.
unshift
(
'
.
.
'
)
;
}
}
if
(
mustEndAbs
&
&
srcPath
[
0
]
!
=
=
'
'
&
&
(
!
srcPath
[
0
]
|
|
srcPath
[
0
]
.
charAt
(
0
)
!
=
=
'
/
'
)
)
{
srcPath
.
unshift
(
'
'
)
;
}
if
(
hasTrailingSlash
&
&
(
srcPath
.
join
(
'
/
'
)
.
substr
(
-
1
)
!
=
=
'
/
'
)
)
{
srcPath
.
push
(
'
'
)
;
}
var
isAbsolute
=
srcPath
[
0
]
=
=
=
'
'
|
|
(
srcPath
[
0
]
&
&
srcPath
[
0
]
.
charAt
(
0
)
=
=
=
'
/
'
)
;
if
(
psychotic
)
{
result
.
hostname
=
result
.
host
=
isAbsolute
?
'
'
:
srcPath
.
length
?
srcPath
.
shift
(
)
:
'
'
;
var
authInHost
=
result
.
host
&
&
result
.
host
.
indexOf
(
'
'
)
>
0
?
result
.
host
.
split
(
'
'
)
:
false
;
if
(
authInHost
)
{
result
.
auth
=
authInHost
.
shift
(
)
;
result
.
host
=
result
.
hostname
=
authInHost
.
shift
(
)
;
}
}
mustEndAbs
=
mustEndAbs
|
|
(
result
.
host
&
&
srcPath
.
length
)
;
if
(
mustEndAbs
&
&
!
isAbsolute
)
{
srcPath
.
unshift
(
'
'
)
;
}
if
(
!
srcPath
.
length
)
{
result
.
pathname
=
null
;
result
.
path
=
null
;
}
else
{
result
.
pathname
=
srcPath
.
join
(
'
/
'
)
;
}
if
(
!
isNull
(
result
.
pathname
)
|
|
!
isNull
(
result
.
search
)
)
{
result
.
path
=
(
result
.
pathname
?
result
.
pathname
:
'
'
)
+
(
result
.
search
?
result
.
search
:
'
'
)
;
}
result
.
auth
=
relative
.
auth
|
|
result
.
auth
;
result
.
slashes
=
result
.
slashes
|
|
relative
.
slashes
;
result
.
href
=
result
.
format
(
)
;
return
result
;
}
;
Url
.
prototype
.
parseHost
=
function
(
)
{
var
host
=
this
.
host
;
var
port
=
portPattern
.
exec
(
host
)
;
if
(
port
)
{
port
=
port
[
0
]
;
if
(
port
!
=
=
'
:
'
)
{
this
.
port
=
port
.
substr
(
1
)
;
}
host
=
host
.
substr
(
0
host
.
length
-
port
.
length
)
;
}
if
(
host
)
this
.
hostname
=
host
;
}
;
function
isString
(
arg
)
{
return
typeof
arg
=
=
=
"
string
"
;
}
function
isObject
(
arg
)
{
return
typeof
arg
=
=
=
'
object
'
&
&
arg
!
=
=
null
;
}
function
isNull
(
arg
)
{
return
arg
=
=
=
null
;
}
function
isNullOrUndefined
(
arg
)
{
return
arg
=
=
null
;
}
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
module
global
)
{
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
&
&
!
exports
.
nodeType
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
!
module
.
nodeType
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
|
|
freeGlobal
.
self
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
punycode
maxInt
=
2147483647
base
=
36
tMin
=
1
tMax
=
26
skew
=
38
damp
=
700
initialBias
=
72
initialN
=
128
delimiter
=
'
-
'
regexPunycode
=
/
^
xn
-
-
/
regexNonASCII
=
/
[
^
\
x20
-
\
x7E
]
/
regexSeparators
=
/
[
\
x2E
\
u3002
\
uFF0E
\
uFF61
]
/
g
errors
=
{
'
overflow
'
:
'
Overflow
:
input
needs
wider
integers
to
process
'
'
not
-
basic
'
:
'
Illegal
input
>
=
0x80
(
not
a
basic
code
point
)
'
'
invalid
-
input
'
:
'
Invalid
input
'
}
baseMinusTMin
=
base
-
tMin
floor
=
Math
.
floor
stringFromCharCode
=
String
.
fromCharCode
key
;
function
error
(
type
)
{
throw
RangeError
(
errors
[
type
]
)
;
}
function
map
(
array
fn
)
{
var
length
=
array
.
length
;
var
result
=
[
]
;
while
(
length
-
-
)
{
result
[
length
]
=
fn
(
array
[
length
]
)
;
}
return
result
;
}
function
mapDomain
(
string
fn
)
{
var
parts
=
string
.
split
(
'
'
)
;
var
result
=
'
'
;
if
(
parts
.
length
>
1
)
{
result
=
parts
[
0
]
+
'
'
;
string
=
parts
[
1
]
;
}
string
=
string
.
replace
(
regexSeparators
'
\
x2E
'
)
;
var
labels
=
string
.
split
(
'
.
'
)
;
var
encoded
=
map
(
labels
fn
)
.
join
(
'
.
'
)
;
return
result
+
encoded
;
}
function
ucs2decode
(
string
)
{
var
output
=
[
]
counter
=
0
length
=
string
.
length
value
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
return
map
(
array
function
(
value
)
{
var
output
=
'
'
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
return
output
;
}
)
.
join
(
'
'
)
;
}
function
basicToDigit
(
codePoint
)
{
if
(
codePoint
-
48
<
10
)
{
return
codePoint
-
22
;
}
if
(
codePoint
-
65
<
26
)
{
return
codePoint
-
65
;
}
if
(
codePoint
-
97
<
26
)
{
return
codePoint
-
97
;
}
return
base
;
}
function
digitToBasic
(
digit
flag
)
{
return
digit
+
22
+
75
*
(
digit
<
26
)
-
(
(
flag
!
=
0
)
<
<
5
)
;
}
function
adapt
(
delta
numPoints
firstTime
)
{
var
k
=
0
;
delta
=
firstTime
?
floor
(
delta
/
damp
)
:
delta
>
>
1
;
delta
+
=
floor
(
delta
/
numPoints
)
;
for
(
;
delta
>
baseMinusTMin
*
tMax
>
>
1
;
k
+
=
base
)
{
delta
=
floor
(
delta
/
baseMinusTMin
)
;
}
return
floor
(
k
+
(
baseMinusTMin
+
1
)
*
delta
/
(
delta
+
skew
)
)
;
}
function
decode
(
input
)
{
var
output
=
[
]
inputLength
=
input
.
length
out
i
=
0
n
=
initialN
bias
=
initialBias
basic
j
index
oldi
w
k
digit
t
baseMinusT
;
basic
=
input
.
lastIndexOf
(
delimiter
)
;
if
(
basic
<
0
)
{
basic
=
0
;
}
for
(
j
=
0
;
j
<
basic
;
+
+
j
)
{
if
(
input
.
charCodeAt
(
j
)
>
=
0x80
)
{
error
(
'
not
-
basic
'
)
;
}
output
.
push
(
input
.
charCodeAt
(
j
)
)
;
}
for
(
index
=
basic
>
0
?
basic
+
1
:
0
;
index
<
inputLength
;
)
{
for
(
oldi
=
i
w
=
1
k
=
base
;
;
k
+
=
base
)
{
if
(
index
>
=
inputLength
)
{
error
(
'
invalid
-
input
'
)
;
}
digit
=
basicToDigit
(
input
.
charCodeAt
(
index
+
+
)
)
;
if
(
digit
>
=
base
|
|
digit
>
floor
(
(
maxInt
-
i
)
/
w
)
)
{
error
(
'
overflow
'
)
;
}
i
+
=
digit
*
w
;
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
digit
<
t
)
{
break
;
}
baseMinusT
=
base
-
t
;
if
(
w
>
floor
(
maxInt
/
baseMinusT
)
)
{
error
(
'
overflow
'
)
;
}
w
*
=
baseMinusT
;
}
out
=
output
.
length
+
1
;
bias
=
adapt
(
i
-
oldi
out
oldi
=
=
0
)
;
if
(
floor
(
i
/
out
)
>
maxInt
-
n
)
{
error
(
'
overflow
'
)
;
}
n
+
=
floor
(
i
/
out
)
;
i
%
=
out
;
output
.
splice
(
i
+
+
0
n
)
;
}
return
ucs2encode
(
output
)
;
}
function
encode
(
input
)
{
var
n
delta
handledCPCount
basicLength
bias
j
m
q
k
t
currentValue
output
=
[
]
inputLength
handledCPCountPlusOne
baseMinusT
qMinusT
;
input
=
ucs2decode
(
input
)
;
inputLength
=
input
.
length
;
n
=
initialN
;
delta
=
0
;
bias
=
initialBias
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
0x80
)
{
output
.
push
(
stringFromCharCode
(
currentValue
)
)
;
}
}
handledCPCount
=
basicLength
=
output
.
length
;
if
(
basicLength
)
{
output
.
push
(
delimiter
)
;
}
while
(
handledCPCount
<
inputLength
)
{
for
(
m
=
maxInt
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
>
=
n
&
&
currentValue
<
m
)
{
m
=
currentValue
;
}
}
handledCPCountPlusOne
=
handledCPCount
+
1
;
if
(
m
-
n
>
floor
(
(
maxInt
-
delta
)
/
handledCPCountPlusOne
)
)
{
error
(
'
overflow
'
)
;
}
delta
+
=
(
m
-
n
)
*
handledCPCountPlusOne
;
n
=
m
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
n
&
&
+
+
delta
>
maxInt
)
{
error
(
'
overflow
'
)
;
}
if
(
currentValue
=
=
n
)
{
for
(
q
=
delta
k
=
base
;
;
k
+
=
base
)
{
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
q
<
t
)
{
break
;
}
qMinusT
=
q
-
t
;
baseMinusT
=
base
-
t
;
output
.
push
(
stringFromCharCode
(
digitToBasic
(
t
+
qMinusT
%
baseMinusT
0
)
)
)
;
q
=
floor
(
qMinusT
/
baseMinusT
)
;
}
output
.
push
(
stringFromCharCode
(
digitToBasic
(
q
0
)
)
)
;
bias
=
adapt
(
delta
handledCPCountPlusOne
handledCPCount
=
=
basicLength
)
;
delta
=
0
;
+
+
handledCPCount
;
}
}
+
+
delta
;
+
+
n
;
}
return
output
.
join
(
'
'
)
;
}
function
toUnicode
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexPunycode
.
test
(
string
)
?
decode
(
string
.
slice
(
4
)
.
toLowerCase
(
)
)
:
string
;
}
)
;
}
function
toASCII
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexNonASCII
.
test
(
string
)
?
'
xn
-
-
'
+
encode
(
string
)
:
string
;
}
)
;
}
punycode
=
{
'
version
'
:
'
1
.
3
.
2
'
'
ucs2
'
:
{
'
decode
'
:
ucs2decode
'
encode
'
:
ucs2encode
}
'
decode
'
:
decode
'
encode
'
:
encode
'
toASCII
'
:
toASCII
'
toUnicode
'
:
toUnicode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
punycode
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
freeModule
)
{
if
(
module
.
exports
=
=
freeExports
)
{
freeModule
.
exports
=
punycode
;
}
else
{
for
(
key
in
punycode
)
{
punycode
.
hasOwnProperty
(
key
)
&
&
(
freeExports
[
key
]
=
punycode
[
key
]
)
;
}
}
}
else
{
root
.
punycode
=
punycode
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
101
)
(
module
)
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
exports
.
decode
=
exports
.
parse
=
__webpack_require__
(
203
)
;
exports
.
encode
=
exports
.
stringify
=
__webpack_require__
(
204
)
;
}
function
(
module
exports
)
{
'
use
strict
'
;
function
hasOwnProperty
(
obj
prop
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
prop
)
;
}
module
.
exports
=
function
(
qs
sep
eq
options
)
{
sep
=
sep
|
|
'
&
'
;
eq
=
eq
|
|
'
=
'
;
var
obj
=
{
}
;
if
(
typeof
qs
!
=
=
'
string
'
|
|
qs
.
length
=
=
=
0
)
{
return
obj
;
}
var
regexp
=
/
\
+
/
g
;
qs
=
qs
.
split
(
sep
)
;
var
maxKeys
=
1000
;
if
(
options
&
&
typeof
options
.
maxKeys
=
=
=
'
number
'
)
{
maxKeys
=
options
.
maxKeys
;
}
var
len
=
qs
.
length
;
if
(
maxKeys
>
0
&
&
len
>
maxKeys
)
{
len
=
maxKeys
;
}
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
var
x
=
qs
[
i
]
.
replace
(
regexp
'
%
20
'
)
idx
=
x
.
indexOf
(
eq
)
kstr
vstr
k
v
;
if
(
idx
>
=
0
)
{
kstr
=
x
.
substr
(
0
idx
)
;
vstr
=
x
.
substr
(
idx
+
1
)
;
}
else
{
kstr
=
x
;
vstr
=
'
'
;
}
k
=
decodeURIComponent
(
kstr
)
;
v
=
decodeURIComponent
(
vstr
)
;
if
(
!
hasOwnProperty
(
obj
k
)
)
{
obj
[
k
]
=
v
;
}
else
if
(
Array
.
isArray
(
obj
[
k
]
)
)
{
obj
[
k
]
.
push
(
v
)
;
}
else
{
obj
[
k
]
=
[
obj
[
k
]
v
]
;
}
}
return
obj
;
}
;
}
function
(
module
exports
)
{
'
use
strict
'
;
var
stringifyPrimitive
=
function
(
v
)
{
switch
(
typeof
v
)
{
case
'
string
'
:
return
v
;
case
'
boolean
'
:
return
v
?
'
true
'
:
'
false
'
;
case
'
number
'
:
return
isFinite
(
v
)
?
v
:
'
'
;
default
:
return
'
'
;
}
}
;
module
.
exports
=
function
(
obj
sep
eq
name
)
{
sep
=
sep
|
|
'
&
'
;
eq
=
eq
|
|
'
=
'
;
if
(
obj
=
=
=
null
)
{
obj
=
undefined
;
}
if
(
typeof
obj
=
=
=
'
object
'
)
{
return
Object
.
keys
(
obj
)
.
map
(
function
(
k
)
{
var
ks
=
encodeURIComponent
(
stringifyPrimitive
(
k
)
)
+
eq
;
if
(
Array
.
isArray
(
obj
[
k
]
)
)
{
return
obj
[
k
]
.
map
(
function
(
v
)
{
return
ks
+
encodeURIComponent
(
stringifyPrimitive
(
v
)
)
;
}
)
.
join
(
sep
)
;
}
else
{
return
ks
+
encodeURIComponent
(
stringifyPrimitive
(
obj
[
k
]
)
)
;
}
}
)
.
join
(
sep
)
;
}
if
(
!
name
)
return
'
'
;
return
encodeURIComponent
(
stringifyPrimitive
(
name
)
)
+
eq
+
encodeURIComponent
(
stringifyPrimitive
(
obj
)
)
;
}
;
}
function
(
module
exports
)
{
function
basename
(
path
)
{
return
path
.
split
(
"
/
"
)
.
pop
(
)
;
}
function
dirname
(
path
)
{
var
idx
=
path
.
lastIndexOf
(
"
/
"
)
;
return
path
.
slice
(
0
idx
)
;
}
function
isURL
(
str
)
{
return
str
.
indexOf
(
"
:
/
/
"
)
!
=
=
-
1
;
}
function
isAbsolute
(
str
)
{
return
str
[
0
]
=
=
=
"
/
"
;
}
module
.
exports
=
{
basename
dirname
isURL
isAbsolute
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
classnames
=
__webpack_require__
(
207
)
;
var
_require2
=
__webpack_require__
(
199
)
;
var
getTabs
=
_require2
.
getTabs
;
__webpack_require__
(
208
)
;
var
dom
=
React
.
DOM
;
var
githubUrl
=
"
https
:
/
/
github
.
com
/
devtools
-
html
/
debugger
.
html
/
blob
/
master
"
;
function
getTabsByBrowser
(
tabs
browser
)
{
return
tabs
.
valueSeq
(
)
.
filter
(
tab
=
>
tab
.
get
(
"
browser
"
)
=
=
browser
)
;
}
function
renderTabs
(
tabTitle
tabs
paramName
)
{
if
(
tabs
.
count
(
)
=
=
0
)
{
return
null
;
}
return
dom
.
div
(
{
className
:
tab
-
group
{
tabTitle
}
}
dom
.
div
(
{
className
:
"
tab
-
group
-
title
"
}
tabTitle
)
dom
.
ul
(
{
className
:
"
tab
-
list
"
}
tabs
.
valueSeq
(
)
.
map
(
tab
=
>
dom
.
li
(
{
"
className
"
:
"
tab
"
"
key
"
:
tab
.
get
(
"
id
"
)
"
onClick
"
:
(
)
=
>
{
window
.
location
=
"
/
?
"
+
paramName
+
"
=
"
+
tab
.
get
(
"
id
"
)
;
}
}
dom
.
div
(
{
className
:
"
tab
-
title
"
}
tab
.
get
(
"
title
"
)
)
dom
.
div
(
{
className
:
"
tab
-
url
"
}
tab
.
get
(
"
url
"
)
)
)
)
)
)
;
}
function
renderMessage
(
noTabs
)
{
return
dom
.
div
(
{
className
:
classnames
(
"
connect
-
message
"
{
"
not
-
connected
"
:
noTabs
}
)
}
dom
.
p
(
null
noTabs
&
&
"
No
remote
tabs
found
.
"
"
You
may
be
looking
to
"
dom
.
a
(
{
href
:
/
?
ws
=
{
document
.
location
.
hostname
}
:
9229
/
node
}
"
connect
to
Node
"
)
"
.
"
)
dom
.
p
(
null
"
Make
sure
you
run
"
dom
.
a
(
{
href
:
{
githubUrl
}
/
CONTRIBUTING
.
md
#
firefox
}
"
Firefox
"
)
"
"
dom
.
a
(
{
href
:
{
githubUrl
}
/
CONTRIBUTING
.
md
#
chrome
}
"
Chrome
"
)
"
or
"
dom
.
a
(
{
href
:
{
githubUrl
}
/
CONTRIBUTING
.
md
#
nodejs
}
"
Node
"
)
"
with
the
right
flags
.
"
)
)
;
}
function
Tabs
(
_ref
)
{
var
tabs
=
_ref
.
tabs
;
var
firefoxTabs
=
getTabsByBrowser
(
tabs
"
firefox
"
)
;
var
chromeTabs
=
getTabsByBrowser
(
tabs
"
chrome
"
)
;
return
dom
.
div
(
{
className
:
"
tabs
theme
-
light
"
}
renderTabs
(
"
Firefox
Tabs
"
firefoxTabs
"
firefox
-
tab
"
)
renderTabs
(
"
Chrome
Tabs
"
chromeTabs
"
chrome
-
tab
"
)
renderMessage
(
tabs
.
isEmpty
(
)
)
)
;
}
module
.
exports
=
connect
(
state
=
>
(
{
tabs
:
getTabs
(
state
)
}
)
)
(
Tabs
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
)
{
'
use
strict
'
;
var
hasOwn
=
{
}
.
hasOwnProperty
;
function
classNames
(
)
{
var
classes
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
continue
;
var
argType
=
typeof
arg
;
if
(
argType
=
=
=
'
string
'
|
|
argType
=
=
=
'
number
'
)
{
classes
.
push
(
arg
)
;
}
else
if
(
Array
.
isArray
(
arg
)
)
{
classes
.
push
(
classNames
.
apply
(
null
arg
)
)
;
}
else
if
(
argType
=
=
=
'
object
'
)
{
for
(
var
key
in
arg
)
{
if
(
hasOwn
.
call
(
arg
key
)
&
&
arg
[
key
]
)
{
classes
.
push
(
key
)
;
}
}
}
}
return
classes
.
join
(
'
'
)
;
}
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
module
.
exports
=
classNames
;
}
else
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
]
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
)
{
return
classNames
;
}
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
window
.
classNames
=
classNames
;
}
}
(
)
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
createFactory
=
React
.
createFactory
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
_require3
=
__webpack_require__
(
213
)
;
var
Services
=
_require3
.
Services
;
var
classnames
=
__webpack_require__
(
207
)
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require4
=
__webpack_require__
(
46
)
;
var
isFirefoxPanel
=
_require4
.
isFirefoxPanel
;
__webpack_require__
(
225
)
;
if
(
false
)
{
require
(
"
.
.
/
lib
/
themes
/
light
-
theme
.
css
"
)
;
}
var
Sources
=
createFactory
(
__webpack_require__
(
227
)
)
;
var
Editor
=
createFactory
(
__webpack_require__
(
262
)
)
;
var
SplitBox
=
createFactory
(
__webpack_require__
(
267
)
)
;
var
RightSidebar
=
createFactory
(
__webpack_require__
(
271
)
)
;
var
SourceTabs
=
createFactory
(
__webpack_require__
(
348
)
)
;
var
SourceFooter
=
createFactory
(
__webpack_require__
(
353
)
)
;
var
Svg
=
__webpack_require__
(
235
)
;
var
Autocomplete
=
createFactory
(
__webpack_require__
(
356
)
)
;
var
_require5
=
__webpack_require__
(
199
)
;
var
getSources
=
_require5
.
getSources
;
var
getSelectedSource
=
_require5
.
getSelectedSource
;
var
_require6
=
__webpack_require__
(
176
)
;
var
endTruncateStr
=
_require6
.
endTruncateStr
;
var
_require7
=
__webpack_require__
(
365
)
;
var
KeyShortcuts
=
_require7
.
KeyShortcuts
;
var
_require8
=
__webpack_require__
(
230
)
;
var
isHiddenSource
=
_require8
.
isHiddenSource
;
var
getURL
=
_require8
.
getURL
;
function
searchResults
(
sources
)
{
function
getSourcePath
(
source
)
{
var
_getURL
=
getURL
(
source
)
;
var
path
=
_getURL
.
path
;
return
endTruncateStr
(
path
50
)
;
}
return
sources
.
valueSeq
(
)
.
filter
(
source
=
>
!
isHiddenSource
(
source
)
)
.
map
(
source
=
>
(
{
value
:
getSourcePath
(
source
)
title
:
getSourcePath
(
source
)
.
split
(
"
/
"
)
.
pop
(
)
subtitle
:
getSourcePath
(
source
)
id
:
source
.
get
(
"
id
"
)
}
)
)
.
toJS
(
)
;
}
var
App
=
React
.
createClass
(
{
propTypes
:
{
sources
:
PropTypes
.
object
selectSource
:
PropTypes
.
func
selectedSource
:
PropTypes
.
object
}
displayName
:
"
App
"
getInitialState
(
)
{
return
{
searchOn
:
false
}
;
}
componentDidMount
(
)
{
this
.
shortcuts
=
new
KeyShortcuts
(
{
window
}
)
;
this
.
shortcuts
.
on
(
"
CmdOrCtrl
+
P
"
this
.
toggleSourcesSearch
)
;
window
.
addEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
}
componentWillUnmount
(
)
{
this
.
shortcuts
.
off
(
"
CmdOrCtrl
+
P
"
this
.
toggleSourcesSearch
)
;
window
.
removeEventListener
(
"
keydown
"
this
.
onKeyDown
)
;
}
toggleSourcesSearch
(
key
e
)
{
e
.
preventDefault
(
)
;
this
.
setState
(
{
searchOn
:
!
this
.
state
.
searchOn
}
)
;
}
onKeyDown
(
e
)
{
if
(
this
.
state
.
searchOn
&
&
e
.
key
=
=
=
"
Escape
"
)
{
this
.
setState
(
{
searchOn
:
false
}
)
;
e
.
preventDefault
(
)
;
}
}
closeSourcesSearch
(
)
{
this
.
setState
(
{
searchOn
:
false
}
)
;
}
renderSourcesSearch
(
)
{
return
dom
.
div
(
{
className
:
"
search
-
container
"
}
Autocomplete
(
{
selectItem
:
result
=
>
{
this
.
props
.
selectSource
(
result
.
id
)
;
this
.
setState
(
{
searchOn
:
false
}
)
;
}
items
:
searchResults
(
this
.
props
.
sources
)
}
)
dom
.
div
(
{
className
:
"
close
-
button
"
}
Svg
(
"
close
"
{
onClick
:
this
.
closeSourcesSearch
}
)
)
)
;
}
renderWelcomeBox
(
)
{
var
modifierTxt
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
"
Cmd
"
:
"
Ctrl
"
;
return
dom
.
div
(
{
className
:
"
welcomebox
"
}
Want
to
find
a
file
?
(
{
modifierTxt
}
+
P
)
)
;
}
renderCenterPane
(
)
{
return
dom
.
div
(
{
className
:
"
center
-
pane
"
}
dom
.
div
(
{
className
:
"
editor
-
container
"
}
SourceTabs
(
)
Editor
(
)
!
this
.
props
.
selectedSource
?
this
.
renderWelcomeBox
(
)
:
null
this
.
state
.
searchOn
?
this
.
renderSourcesSearch
(
)
:
null
SourceFooter
(
)
)
)
;
}
render
:
function
(
)
{
return
dom
.
div
(
{
className
:
classnames
(
"
debugger
theme
-
body
"
{
"
theme
-
light
"
:
!
isFirefoxPanel
(
)
}
)
}
SplitBox
(
{
initialWidth
:
300
left
:
Sources
(
{
sources
:
this
.
props
.
sources
}
)
right
:
SplitBox
(
{
initialWidth
:
300
rightFlex
:
true
left
:
this
.
renderCenterPane
(
this
.
props
)
right
:
RightSidebar
(
{
keyShortcuts
:
this
.
shortcuts
}
)
}
)
}
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
sources
:
getSources
(
state
)
selectedSource
:
getSelectedSource
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
App
)
;
}
function
(
module
exports
)
{
"
use
strict
"
;
const
PREF_INVALID
=
0
;
const
PREF_STRING
=
32
;
const
PREF_INT
=
64
;
const
PREF_BOOL
=
128
;
const
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
=
"
nsPref
:
changed
"
;
function
Preference
(
branch
name
fullName
)
{
this
.
branch
=
branch
;
this
.
name
=
name
;
this
.
fullName
=
fullName
;
this
.
defaultValue
=
null
;
this
.
hasUserValue
=
false
;
this
.
userValue
=
null
;
this
.
type
=
null
;
}
Preference
.
prototype
=
{
get
:
function
(
)
{
if
(
this
.
hasUserValue
)
{
return
this
.
userValue
;
}
return
this
.
defaultValue
;
}
set
:
function
(
value
)
{
if
(
!
this
.
hasUserValue
|
|
value
!
=
=
this
.
userValue
)
{
this
.
userValue
=
value
;
this
.
hasUserValue
=
true
;
this
.
saveAndNotify
(
)
;
}
}
setDefault
:
function
(
value
)
{
if
(
this
.
defaultValue
!
=
=
value
)
{
this
.
defaultValue
=
value
;
if
(
!
this
.
hasUserValue
)
{
this
.
saveAndNotify
(
)
;
}
}
}
clearUserValue
:
function
(
)
{
if
(
this
.
hasUserValue
)
{
this
.
userValue
=
null
;
this
.
hasUserValue
=
false
;
this
.
saveAndNotify
(
)
;
}
}
saveAndNotify
:
function
(
)
{
let
store
=
{
type
:
this
.
type
defaultValue
:
this
.
defaultValue
hasUserValue
:
this
.
hasUserValue
userValue
:
this
.
userValue
}
;
localStorage
.
setItem
(
this
.
fullName
JSON
.
stringify
(
store
)
)
;
this
.
branch
.
_notify
(
this
.
name
)
;
}
storageUpdated
:
function
(
type
userValue
hasUserValue
defaultValue
)
{
this
.
type
=
type
;
this
.
defaultValue
=
defaultValue
;
this
.
hasUserValue
=
hasUserValue
;
this
.
userValue
=
userValue
;
this
.
branch
.
_notify
(
this
.
name
)
;
}
}
;
function
PrefBranch
(
parent
name
fullName
)
{
this
.
_parent
=
parent
;
this
.
_name
=
name
;
this
.
_fullName
=
fullName
;
this
.
_observers
=
{
}
;
this
.
_children
=
{
}
;
if
(
!
parent
)
{
this
.
_initializeRoot
(
)
;
}
}
PrefBranch
.
prototype
=
{
PREF_INVALID
:
PREF_INVALID
PREF_STRING
:
PREF_STRING
PREF_INT
:
PREF_INT
PREF_BOOL
:
PREF_BOOL
get
root
(
)
{
return
this
.
_fullName
;
}
getPrefType
:
function
(
prefName
)
{
return
this
.
_findPref
(
prefName
)
.
type
;
}
getBoolPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
type
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
{
prefName
}
does
not
have
bool
type
)
;
}
return
thePref
.
get
(
)
;
}
setBoolPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
boolean
"
)
{
throw
new
Error
(
"
non
-
bool
passed
to
setBoolPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
type
!
=
=
PREF_BOOL
)
{
throw
new
Error
(
{
prefName
}
does
not
have
bool
type
)
;
}
thePref
.
set
(
value
)
;
}
getCharPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
type
!
=
=
PREF_STRING
)
{
throw
new
Error
(
{
prefName
}
does
not
have
string
type
)
;
}
return
thePref
.
get
(
)
;
}
setCharPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
string
"
)
{
throw
new
Error
(
"
non
-
string
passed
to
setCharPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
type
!
=
=
PREF_STRING
)
{
throw
new
Error
(
{
prefName
}
does
not
have
string
type
)
;
}
thePref
.
set
(
value
)
;
}
getIntPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
if
(
thePref
.
type
!
=
=
PREF_INT
)
{
throw
new
Error
(
{
prefName
}
does
not
have
int
type
)
;
}
return
thePref
.
get
(
)
;
}
setIntPref
:
function
(
prefName
value
)
{
if
(
typeof
value
!
=
=
"
number
"
)
{
throw
new
Error
(
"
non
-
number
passed
to
setIntPref
"
)
;
}
let
thePref
=
this
.
_findOrCreatePref
(
prefName
value
true
value
)
;
if
(
thePref
.
type
!
=
=
PREF_INT
)
{
throw
new
Error
(
{
prefName
}
does
not
have
int
type
)
;
}
thePref
.
set
(
value
)
;
}
clearUserPref
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
thePref
.
clearUserValue
(
)
;
}
prefHasUserValue
:
function
(
prefName
)
{
let
thePref
=
this
.
_findPref
(
prefName
)
;
return
thePref
.
hasUserValue
;
}
addObserver
:
function
(
domain
observer
holdWeak
)
{
if
(
domain
!
=
=
"
"
&
&
!
domain
.
endsWith
(
"
.
"
)
)
{
throw
new
Error
(
"
invalid
domain
to
addObserver
:
"
+
domain
)
;
}
if
(
holdWeak
)
{
throw
new
Error
(
"
shim
prefs
only
supports
strong
observers
"
)
;
}
if
(
!
(
domain
in
this
.
_observers
)
)
{
this
.
_observers
[
domain
]
=
[
]
;
}
this
.
_observers
[
domain
]
.
push
(
observer
)
;
}
removeObserver
:
function
(
domain
observer
)
{
if
(
!
(
domain
in
this
.
_observers
)
)
{
return
;
}
let
index
=
this
.
_observers
[
domain
]
.
indexOf
(
observer
)
;
if
(
index
>
=
0
)
{
this
.
_observers
[
domain
]
.
splice
(
index
1
)
;
}
}
savePrefFile
:
function
(
file
)
{
if
(
file
)
{
throw
new
Error
(
"
shim
prefs
only
supports
null
file
in
savePrefFile
"
)
;
}
}
getBranch
:
function
(
prefRoot
)
{
if
(
!
prefRoot
)
{
return
this
;
}
if
(
prefRoot
.
endsWith
(
"
.
"
)
)
{
prefRoot
=
prefRoot
.
slice
(
0
-
1
)
;
}
return
this
.
_findPref
(
prefRoot
)
;
}
_findPref
:
function
(
prefName
)
{
let
branchNames
=
prefName
.
split
(
"
.
"
)
;
let
branch
=
this
;
for
(
let
branchName
of
branchNames
)
{
branch
=
branch
.
_children
[
branchName
]
;
if
(
!
branch
)
{
throw
new
Error
(
"
could
not
find
pref
branch
"
+
prefName
)
;
}
}
return
branch
;
}
_notify
:
function
(
relativeName
)
{
for
(
let
domain
in
this
.
_observers
)
{
if
(
relativeName
.
startsWith
(
domain
)
)
{
let
localList
=
this
.
_observers
[
domain
]
.
slice
(
)
;
for
(
let
observer
of
localList
)
{
try
{
observer
.
observe
(
this
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
relativeName
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
}
}
}
if
(
this
.
_parent
)
{
this
.
_parent
.
_notify
(
this
.
_name
+
"
.
"
+
relativeName
)
;
}
}
_createBranch
:
function
(
branchList
)
{
let
parent
=
this
;
for
(
let
branch
of
branchList
)
{
if
(
!
parent
.
_children
[
branch
]
)
{
parent
.
_children
[
branch
]
=
new
PrefBranch
(
parent
branch
parent
.
root
+
"
.
"
+
branch
)
;
}
parent
=
parent
.
_children
[
branch
]
;
}
return
parent
;
}
_findOrCreatePref
:
function
(
keyName
userValue
hasUserValue
defaultValue
)
{
let
branchName
=
keyName
.
split
(
"
.
"
)
;
let
prefName
=
branchName
.
pop
(
)
;
let
branch
=
this
.
_createBranch
(
branchName
)
;
if
(
!
(
prefName
in
branch
.
_children
)
)
{
if
(
hasUserValue
&
&
typeof
(
userValue
)
!
=
=
typeof
(
defaultValue
)
)
{
throw
new
Error
(
"
inconsistent
values
when
creating
"
+
keyName
)
;
}
let
type
;
switch
(
typeof
(
defaultValue
)
)
{
case
"
boolean
"
:
type
=
PREF_BOOL
;
break
;
case
"
number
"
:
type
=
PREF_INT
;
break
;
case
"
string
"
:
type
=
PREF_STRING
;
break
;
default
:
throw
new
Error
(
"
unhandled
argument
type
:
"
+
typeof
(
defaultValue
)
)
;
}
let
thePref
=
new
Preference
(
branch
prefName
keyName
)
;
thePref
.
storageUpdated
(
type
userValue
hasUserValue
defaultValue
)
;
branch
.
_children
[
prefName
]
=
thePref
;
}
return
branch
.
_children
[
prefName
]
;
}
_onStorageChange
:
function
(
event
)
{
if
(
event
.
storageArea
!
=
=
localStorage
)
{
return
;
}
if
(
event
.
key
=
=
=
null
|
|
event
.
newValue
=
=
=
null
)
{
return
;
}
let
{
type
userValue
hasUserValue
defaultValue
}
=
JSON
.
parse
(
event
.
newValue
)
;
if
(
event
.
oldValue
=
=
=
null
)
{
this
.
_findOrCreatePref
(
event
.
key
userValue
hasUserValue
defaultValue
)
;
}
else
{
let
thePref
=
this
.
_findPref
(
event
.
key
)
;
thePref
.
storageUpdated
(
type
userValue
hasUserValue
defaultValue
)
;
}
}
_initializeRoot
:
function
(
)
{
try
{
if
(
localStorage
.
length
=
=
=
0
)
{
}
}
catch
(
e
)
{
return
;
}
for
(
let
i
=
0
;
i
<
localStorage
.
length
;
+
+
i
)
{
let
keyName
=
localStorage
.
key
(
i
)
;
try
{
let
{
userValue
hasUserValue
defaultValue
}
=
JSON
.
parse
(
localStorage
.
getItem
(
keyName
)
)
;
this
.
_findOrCreatePref
(
keyName
userValue
hasUserValue
defaultValue
)
;
}
catch
(
e
)
{
}
}
this
.
_onStorageChange
=
this
.
_onStorageChange
.
bind
(
this
)
;
window
.
addEventListener
(
"
storage
"
this
.
_onStorageChange
)
;
}
}
;
const
Services
=
{
prefs
:
new
PrefBranch
(
null
"
"
"
"
)
appinfo
:
{
get
OS
(
)
{
const
os
=
window
.
navigator
.
userAgent
;
if
(
os
)
{
if
(
os
.
includes
(
"
Linux
"
)
)
{
return
"
Linux
"
;
}
else
if
(
os
.
includes
(
"
Windows
"
)
)
{
return
"
WINNT
"
;
}
else
if
(
os
.
includes
(
"
Mac
"
)
)
{
return
"
Darwin
"
;
}
}
return
"
Unknown
"
;
}
get
name
(
)
{
return
window
.
navigator
.
userAgent
;
}
get
version
(
)
{
return
window
.
navigator
.
appVersion
;
}
get
is64Bit
(
)
{
return
true
;
}
}
telemetry
:
{
getHistogramById
:
function
(
name
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
getKeyedHistogramById
:
function
(
name
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
}
focus
:
{
MOVEFOCUS_FORWARD
:
1
MOVEFOCUS_BACKWARD
:
2
get
focusedElement
(
)
{
if
(
!
document
.
hasFocus
(
)
)
{
return
null
;
}
return
document
.
activeElement
;
}
moveFocus
:
function
(
window
startElement
type
flags
)
{
if
(
flags
!
=
=
0
)
{
throw
new
Error
(
"
shim
Services
.
focus
.
moveFocus
only
accepts
flags
=
=
=
0
"
)
;
}
if
(
type
!
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
&
&
type
!
=
=
Services
.
focus
.
MOVEFOCUS_BACKWARD
)
{
throw
new
Error
(
"
shim
Services
.
focus
.
moveFocus
only
supports
"
+
"
MOVEFOCUS_FORWARD
and
MOVEFOCUS_BACKWARD
"
)
;
}
if
(
!
startElement
)
{
startElement
=
document
.
activeElement
|
|
document
;
}
let
iter
=
document
.
createTreeWalker
(
document
NodeFilter
.
SHOW_ELEMENT
{
acceptNode
:
function
(
node
)
{
let
tabIndex
=
node
.
getAttribute
(
"
tabindex
"
)
;
if
(
tabIndex
=
=
=
"
-
1
"
)
{
return
NodeFilter
.
FILTER_SKIP
;
}
node
.
focus
(
)
;
if
(
document
.
activeElement
=
=
node
)
{
return
NodeFilter
.
FILTER_ACCEPT
;
}
return
NodeFilter
.
FILTER_SKIP
;
}
}
)
;
iter
.
currentNode
=
startElement
;
if
(
type
=
=
=
Services
.
focus
.
MOVEFOCUS_FORWARD
)
{
iter
.
nextNode
(
)
;
}
else
{
iter
.
previousNode
(
)
;
}
}
}
}
;
function
pref
(
name
value
)
{
let
thePref
=
Services
.
prefs
.
_findOrCreatePref
(
name
value
true
value
)
;
thePref
.
setDefault
(
value
)
;
}
exports
.
Services
=
Services
;
exports
.
pref
=
pref
;
}
function
(
module
exports
__webpack_require__
)
{
var
breakpoints
=
__webpack_require__
(
215
)
;
var
eventListeners
=
__webpack_require__
(
218
)
;
var
sources
=
__webpack_require__
(
219
)
;
var
tabs
=
__webpack_require__
(
222
)
;
var
pause
=
__webpack_require__
(
223
)
;
var
navigation
=
__webpack_require__
(
224
)
;
module
.
exports
=
Object
.
assign
(
navigation
breakpoints
eventListeners
sources
tabs
pause
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
constants
=
__webpack_require__
(
190
)
;
var
_require
=
__webpack_require__
(
184
)
;
var
PROMISE
=
_require
.
PROMISE
;
var
_require2
=
__webpack_require__
(
199
)
;
var
getBreakpoint
=
_require2
.
getBreakpoint
;
var
getBreakpoints
=
_require2
.
getBreakpoints
;
var
_require3
=
__webpack_require__
(
216
)
;
var
getOriginalLocation
=
_require3
.
getOriginalLocation
;
var
getGeneratedLocation
=
_require3
.
getGeneratedLocation
;
function
_breakpointExists
(
state
location
)
{
var
currentBp
=
getBreakpoint
(
state
location
)
;
return
currentBp
&
&
!
currentBp
.
disabled
;
}
function
_getOrCreateBreakpoint
(
state
location
condition
)
{
return
getBreakpoint
(
state
location
)
|
|
{
location
condition
}
;
}
function
enableBreakpoint
(
location
)
{
return
addBreakpoint
(
location
)
;
}
function
addBreakpoint
(
location
)
{
var
_ref
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
condition
=
_ref
.
condition
;
var
getTextForLine
=
_ref
.
getTextForLine
;
return
_ref2
=
>
{
var
dispatch
=
_ref2
.
dispatch
;
var
getState
=
_ref2
.
getState
;
var
client
=
_ref2
.
client
;
if
(
_breakpointExists
(
getState
(
)
location
)
)
{
return
Promise
.
resolve
(
)
;
}
var
bp
=
_getOrCreateBreakpoint
(
getState
(
)
location
condition
)
;
return
dispatch
(
{
type
:
constants
.
ADD_BREAKPOINT
breakpoint
:
bp
condition
:
condition
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
location
=
yield
getGeneratedLocation
(
getState
(
)
bp
.
location
)
;
var
_ref4
=
yield
client
.
setBreakpoint
(
location
bp
.
condition
)
;
var
id
=
_ref4
.
id
;
var
actualLocation
=
_ref4
.
actualLocation
;
actualLocation
=
yield
getOriginalLocation
(
getState
(
)
actualLocation
)
;
var
text
=
bp
.
text
;
if
(
!
text
)
{
text
=
getTextForLine
?
getTextForLine
(
actualLocation
.
line
)
:
"
"
;
}
return
{
id
actualLocation
text
}
;
}
)
(
)
}
)
;
}
;
}
function
disableBreakpoint
(
location
)
{
return
_removeOrDisableBreakpoint
(
location
true
)
;
}
function
removeBreakpoint
(
location
)
{
return
_removeOrDisableBreakpoint
(
location
)
;
}
function
_removeOrDisableBreakpoint
(
location
isDisabled
)
{
return
_ref5
=
>
{
var
dispatch
=
_ref5
.
dispatch
;
var
getState
=
_ref5
.
getState
;
var
client
=
_ref5
.
client
;
var
bp
=
getBreakpoint
(
getState
(
)
location
)
;
if
(
!
bp
)
{
throw
new
Error
(
"
attempt
to
remove
breakpoint
that
does
not
exist
"
)
;
}
if
(
bp
.
loading
)
{
throw
new
Error
(
"
attempt
to
remove
unsaved
breakpoint
"
)
;
}
var
action
=
{
type
:
constants
.
REMOVE_BREAKPOINT
breakpoint
:
bp
disabled
:
isDisabled
}
;
if
(
!
bp
.
disabled
)
{
return
dispatch
(
Object
.
assign
(
{
}
action
{
[
PROMISE
]
:
client
.
removeBreakpoint
(
bp
.
id
)
}
)
)
;
}
return
dispatch
(
Object
.
assign
(
{
}
action
{
status
:
"
done
"
}
)
)
;
}
;
}
function
toggleAllBreakpoints
(
shouldDisableBreakpoints
)
{
return
_ref6
=
>
{
var
dispatch
=
_ref6
.
dispatch
;
var
getState
=
_ref6
.
getState
;
var
breakpoints
=
getBreakpoints
(
getState
(
)
)
;
return
dispatch
(
{
type
:
constants
.
TOGGLE_BREAKPOINTS
shouldDisableBreakpoints
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
for
(
var
_ref8
of
breakpoints
)
{
var
_ref9
=
_slicedToArray
(
_ref8
2
)
;
var
breakpoint
=
_ref9
[
1
]
;
if
(
shouldDisableBreakpoints
)
{
yield
dispatch
(
disableBreakpoint
(
breakpoint
.
location
)
)
;
}
else
{
yield
dispatch
(
enableBreakpoint
(
breakpoint
.
location
)
)
;
}
}
}
)
(
)
}
)
;
}
;
}
function
setBreakpointCondition
(
location
condition
)
{
throw
new
Error
(
"
not
implemented
"
)
;
}
module
.
exports
=
{
enableBreakpoint
addBreakpoint
disableBreakpoint
removeBreakpoint
toggleAllBreakpoints
setBreakpointCondition
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
getOriginalSources
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
state
source
)
{
var
originalSourceUrls
=
yield
getOriginalSourceUrls
(
source
)
;
return
originalSourceUrls
.
map
(
function
(
url
)
{
return
getSourceByURL
(
state
url
)
;
}
)
;
}
)
;
return
function
getOriginalSources
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
getGeneratedLocation
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
state
location
)
{
var
source
=
getSource
(
state
location
.
sourceId
)
;
if
(
!
source
)
{
return
location
;
}
if
(
yield
isOriginal
(
source
.
toJS
(
)
)
)
{
return
yield
getGeneratedSourceLocation
(
source
.
toJS
(
)
location
)
;
}
return
location
;
}
)
;
return
function
getGeneratedLocation
(
_x3
_x4
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
getOriginalLocation
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
state
location
)
{
var
source
=
getSource
(
state
location
.
sourceId
)
;
if
(
!
source
)
{
return
location
;
}
if
(
isGenerated
(
source
.
toJS
(
)
)
)
{
var
originalPosition
=
yield
getOriginalSourcePosition
(
source
.
toJS
(
)
location
)
;
var
url
=
originalPosition
.
url
;
var
line
=
originalPosition
.
line
;
if
(
!
url
)
{
return
{
sourceId
:
source
.
get
(
"
id
"
)
line
:
location
.
line
}
;
}
var
originalSource
=
getSourceByURL
(
state
url
)
;
return
{
sourceId
:
originalSource
.
get
(
"
id
"
)
line
}
;
}
return
location
;
}
)
;
return
function
getOriginalLocation
(
_x5
_x6
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
getOriginalSourceTexts
=
(
(
)
=
>
{
var
_ref4
=
_asyncToGenerator
(
function
*
(
state
generatedSource
generatedText
)
{
if
(
!
_shouldSourceMap
(
generatedSource
)
)
{
return
[
]
;
}
var
originalTexts
=
yield
getOriginalTexts
(
generatedSource
generatedText
)
;
return
originalTexts
.
map
(
function
(
_ref5
)
{
var
text
=
_ref5
.
text
;
var
url
=
_ref5
.
url
;
var
id
=
getSourceByURL
(
state
url
)
.
get
(
"
id
"
)
;
var
contentType
=
"
text
/
javascript
"
;
return
{
text
id
contentType
}
;
}
)
;
}
)
;
return
function
getOriginalSourceTexts
(
_x7
_x8
_x9
)
{
return
_ref4
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
176
)
;
var
workerTask
=
_require
.
workerTask
;
var
_require2
=
__webpack_require__
(
217
)
;
var
makeOriginalSource
=
_require2
.
makeOriginalSource
;
var
getGeneratedSourceId
=
_require2
.
getGeneratedSourceId
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getSource
=
_require3
.
getSource
;
var
getSourceByURL
=
_require3
.
getSourceByURL
;
var
_require4
=
__webpack_require__
(
46
)
;
var
isEnabled
=
_require4
.
isEnabled
;
var
getValue
=
_require4
.
getValue
;
var
sourceMapWorker
=
void
0
;
function
restartWorker
(
)
{
if
(
sourceMapWorker
)
{
sourceMapWorker
.
terminate
(
)
;
}
sourceMapWorker
=
new
Worker
(
getValue
(
"
baseWorkerURL
"
)
+
"
source
-
map
-
worker
.
js
"
)
;
}
restartWorker
(
)
;
function
destroy
(
)
{
if
(
sourceMapWorker
)
{
sourceMapWorker
.
terminate
(
)
;
sourceMapWorker
=
null
;
}
}
var
sourceMapTask
=
function
(
method
)
{
return
function
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
return
workerTask
(
sourceMapWorker
{
method
args
}
)
;
}
;
}
;
var
getOriginalSourcePosition
=
sourceMapTask
(
"
getOriginalSourcePosition
"
)
;
var
getGeneratedSourceLocation
=
sourceMapTask
(
"
getGeneratedSourceLocation
"
)
;
var
createOriginalSources
=
sourceMapTask
(
"
createOriginalSources
"
)
;
var
getOriginalSourceUrls
=
sourceMapTask
(
"
getOriginalSourceUrls
"
)
;
var
getOriginalTexts
=
sourceMapTask
(
"
getOriginalTexts
"
)
;
var
createSourceMap
=
sourceMapTask
(
"
createSourceMap
"
)
;
var
clearData
=
sourceMapTask
(
"
clearData
"
)
;
function
_shouldSourceMap
(
source
)
{
return
isEnabled
(
"
sourceMaps
"
)
&
&
source
.
sourceMapURL
;
}
function
isMapped
(
source
)
{
return
_shouldSourceMap
(
source
)
;
}
function
isOriginal
(
originalSource
)
{
return
!
!
getGeneratedSourceId
(
originalSource
)
;
}
function
isGenerated
(
source
)
{
return
!
isOriginal
(
source
)
;
}
function
getGeneratedSource
(
state
source
)
{
if
(
isGenerated
(
source
)
)
{
return
source
;
}
var
generatedSourceId
=
getGeneratedSourceId
(
source
)
;
var
originalSource
=
getSource
(
state
generatedSourceId
)
;
if
(
originalSource
)
{
return
originalSource
.
toJS
(
)
;
}
return
source
;
}
module
.
exports
=
{
getGeneratedLocation
getOriginalLocation
makeOriginalSource
getOriginalSources
getGeneratedSource
getOriginalSourceTexts
getOriginalSourcePosition
getGeneratedSourceLocation
createOriginalSources
getOriginalSourceUrls
isOriginal
isGenerated
isMapped
getGeneratedSourceId
createSourceMap
clearData
restartWorker
destroy
}
;
}
function
(
module
exports
)
{
function
getGeneratedSourceId
(
originalSource
)
{
var
match
=
originalSource
.
id
.
match
(
/
(
.
*
)
\
/
originalSource
/
)
;
return
match
?
match
[
1
]
:
null
;
}
function
makeOriginalSource
(
_ref
)
{
var
url
=
_ref
.
url
;
var
source
=
_ref
.
source
;
var
_ref
id
=
_ref
.
id
;
var
id
=
_ref
id
=
=
=
undefined
?
1
:
_ref
id
;
var
generatedSourceId
=
source
.
id
;
return
{
url
id
:
{
generatedSourceId
}
/
originalSource
{
id
}
isPrettyPrinted
:
false
}
;
}
module
.
exports
=
{
makeOriginalSource
getGeneratedSourceId
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
190
)
;
var
_require
=
__webpack_require__
(
176
)
;
var
asPaused
=
_require
.
asPaused
;
var
_require2
=
__webpack_require__
(
186
)
;
var
reportException
=
_require2
.
reportException
;
var
_require3
=
__webpack_require__
(
97
)
;
var
Task
=
_require3
.
Task
;
var
FETCH_EVENT_LISTENERS_DELAY
=
200
;
function
fetchEventListeners
(
)
{
return
(
dispatch
getState
)
=
>
{
setNamedTimeout
(
"
event
-
listeners
-
fetch
"
FETCH_EVENT_LISTENERS_DELAY
(
)
=
>
{
if
(
getState
(
)
.
eventListeners
.
fetchingListeners
)
{
dispatch
(
{
type
:
services
.
WAIT_UNTIL
predicate
:
action
=
>
action
.
type
=
=
=
constants
.
FETCH_EVENT_LISTENERS
&
&
action
.
status
=
=
=
"
done
"
run
:
dispatch
=
>
dispatch
(
fetchEventListeners
(
)
)
}
)
;
return
;
}
dispatch
(
{
type
:
constants
.
FETCH_EVENT_LISTENERS
status
:
"
begin
"
}
)
;
asPaused
(
gThreadClient
_getListeners
)
.
then
(
listeners
=
>
{
window
.
emit
(
EVENTS
.
EVENT_LISTENERS_FETCHED
)
;
dispatch
(
{
type
:
constants
.
FETCH_EVENT_LISTENERS
status
:
"
done
"
listeners
:
listeners
}
)
;
}
)
;
}
)
;
}
;
}
var
_getListeners
=
Task
.
async
(
function
*
(
)
{
var
response
=
yield
gThreadClient
.
eventListeners
(
)
;
response
.
listeners
.
sort
(
(
a
b
)
=
>
a
.
type
>
b
.
type
?
1
:
-
1
)
;
var
fetchedDefinitions
=
new
Map
(
)
;
var
listeners
=
[
]
;
for
(
var
listener
of
response
.
listeners
)
{
var
definitionSite
=
void
0
;
if
(
fetchedDefinitions
.
has
(
listener
.
function
.
actor
)
)
{
definitionSite
=
fetchedDefinitions
.
get
(
listener
.
function
.
actor
)
;
}
else
if
(
listener
.
function
.
class
=
=
"
Function
"
)
{
definitionSite
=
yield
_getDefinitionSite
(
listener
.
function
)
;
if
(
!
definitionSite
)
{
continue
;
}
fetchedDefinitions
.
set
(
listener
.
function
.
actor
definitionSite
)
;
}
listener
.
function
.
url
=
definitionSite
;
listeners
.
push
(
listener
)
;
}
fetchedDefinitions
.
clear
(
)
;
return
listeners
;
}
)
;
var
_getDefinitionSite
=
Task
.
async
(
function
*
(
func
)
{
var
grip
=
gThreadClient
.
pauseGrip
(
func
)
;
var
response
=
void
0
;
try
{
response
=
yield
grip
.
getDefinitionSite
(
)
;
}
catch
(
e
)
{
reportException
(
"
_getDefinitionSite
"
e
)
;
return
null
;
}
return
response
.
source
.
url
;
}
)
;
function
updateEventBreakpoints
(
eventNames
)
{
return
dispatch
=
>
{
setNamedTimeout
(
"
event
-
breakpoints
-
update
"
0
(
)
=
>
{
gThreadClient
.
pauseOnDOMEvents
(
eventNames
function
(
)
{
window
.
emit
(
EVENTS
.
EVENT_BREAKPOINTS_UPDATED
)
;
dispatch
(
{
type
:
constants
.
UPDATE_EVENT_BREAKPOINTS
eventNames
:
eventNames
}
)
;
}
)
;
}
)
;
}
;
}
module
.
exports
=
{
updateEventBreakpoints
fetchEventListeners
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
_prettyPrintSource
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
_ref2
)
{
var
source
=
_ref2
.
source
;
var
sourceText
=
_ref2
.
sourceText
;
var
url
=
_ref2
.
url
;
var
contentType
=
sourceText
?
sourceText
.
contentType
:
null
;
var
indent
=
2
;
invariant
(
isJavaScript
(
source
.
url
contentType
)
"
Can
'
t
prettify
non
-
javascript
files
.
"
)
;
var
_ref3
=
yield
workerTask
(
new
Worker
(
"
public
/
build
/
pretty
-
print
-
worker
.
js
"
)
{
url
indent
source
:
sourceText
.
text
}
)
;
var
code
=
_ref3
.
code
;
var
mappings
=
_ref3
.
mappings
;
yield
createSourceMap
(
{
source
mappings
code
}
)
;
return
code
;
}
)
;
return
function
_prettyPrintSource
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
defer
=
__webpack_require__
(
112
)
;
var
_require
=
__webpack_require__
(
184
)
;
var
PROMISE
=
_require
.
PROMISE
;
var
_require2
=
__webpack_require__
(
97
)
;
var
Task
=
_require2
.
Task
;
var
_require3
=
__webpack_require__
(
220
)
;
var
isJavaScript
=
_require3
.
isJavaScript
;
var
_require4
=
__webpack_require__
(
175
)
;
var
networkRequest
=
_require4
.
networkRequest
;
var
_require5
=
__webpack_require__
(
176
)
;
var
workerTask
=
_require5
.
workerTask
;
var
_require6
=
__webpack_require__
(
221
)
;
var
updateFrameLocations
=
_require6
.
updateFrameLocations
;
var
constants
=
__webpack_require__
(
190
)
;
var
invariant
=
__webpack_require__
(
24
)
;
var
_require7
=
__webpack_require__
(
46
)
;
var
isEnabled
=
_require7
.
isEnabled
;
var
_require8
=
__webpack_require__
(
216
)
;
var
createOriginalSources
=
_require8
.
createOriginalSources
;
var
getOriginalSourceTexts
=
_require8
.
getOriginalSourceTexts
;
var
createSourceMap
=
_require8
.
createSourceMap
;
var
makeOriginalSource
=
_require8
.
makeOriginalSource
;
var
getGeneratedSource
=
_require8
.
getGeneratedSource
;
var
_require9
=
__webpack_require__
(
199
)
;
var
getSource
=
_require9
.
getSource
;
var
getSourceByURL
=
_require9
.
getSourceByURL
;
var
getSourceText
=
_require9
.
getSourceText
;
var
getPendingSelectedLocation
=
_require9
.
getPendingSelectedLocation
;
var
getSourceMap
=
_require9
.
getSourceMap
;
var
getSourceMapURL
=
_require9
.
getSourceMapURL
;
var
getFrames
=
_require9
.
getFrames
;
function
_shouldSourceMap
(
generatedSource
)
{
return
isEnabled
(
"
sourceMaps
"
)
&
&
generatedSource
.
sourceMapURL
;
}
function
newSource
(
source
)
{
return
_ref4
=
>
{
var
dispatch
=
_ref4
.
dispatch
;
var
getState
=
_ref4
.
getState
;
if
(
_shouldSourceMap
(
source
)
)
{
dispatch
(
loadSourceMap
(
source
)
)
;
}
dispatch
(
{
type
:
constants
.
ADD_SOURCE
source
}
)
;
var
pendingLocation
=
getPendingSelectedLocation
(
getState
(
)
)
;
if
(
pendingLocation
&
&
pendingLocation
.
url
=
=
=
source
.
url
)
{
dispatch
(
selectSource
(
source
.
id
{
line
:
pendingLocation
.
line
}
)
)
;
}
}
;
}
function
newSources
(
sources
)
{
return
_ref5
=
>
{
var
dispatch
=
_ref5
.
dispatch
;
var
getState
=
_ref5
.
getState
;
sources
.
filter
(
source
=
>
!
getSource
(
getState
(
)
source
.
id
)
)
.
forEach
(
source
=
>
dispatch
(
newSource
(
source
)
)
)
;
}
;
}
function
loadSourceMap
(
generatedSource
)
{
return
_ref6
=
>
{
var
dispatch
=
_ref6
.
dispatch
;
var
getState
=
_ref6
.
getState
;
var
sourceMap
=
getSourceMap
(
getState
(
)
generatedSource
.
id
)
;
if
(
sourceMap
)
{
return
;
}
dispatch
(
{
type
:
constants
.
LOAD_SOURCE_MAP
source
:
generatedSource
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
var
sourceMapURL
=
getSourceMapURL
(
getState
(
)
generatedSource
)
;
sourceMap
=
yield
networkRequest
(
sourceMapURL
)
;
var
originalSources
=
yield
createOriginalSources
(
generatedSource
sourceMap
)
;
originalSources
.
forEach
(
function
(
s
)
{
return
dispatch
(
newSource
(
s
)
)
;
}
)
;
return
{
sourceMap
}
;
}
)
(
)
}
)
;
}
;
}
function
selectSourceURL
(
url
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
return
_ref8
=
>
{
var
dispatch
=
_ref8
.
dispatch
;
var
getState
=
_ref8
.
getState
;
var
source
=
getSourceByURL
(
getState
(
)
url
)
;
if
(
source
)
{
dispatch
(
selectSource
(
source
.
get
(
"
id
"
)
options
)
)
;
}
else
{
dispatch
(
{
type
:
constants
.
SELECT_SOURCE_URL
url
:
url
tabIndex
:
options
.
tabIndex
line
:
options
.
line
}
)
;
}
}
;
}
function
selectSource
(
id
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
return
_ref9
=
>
{
var
dispatch
=
_ref9
.
dispatch
;
var
getState
=
_ref9
.
getState
;
var
client
=
_ref9
.
client
;
if
(
!
client
)
{
return
;
}
var
source
=
getSource
(
getState
(
)
id
)
.
toJS
(
)
;
dispatch
(
loadSourceText
(
source
)
)
;
dispatch
(
{
type
:
constants
.
SELECT_SOURCE
source
:
source
tabIndex
:
options
.
tabIndex
line
:
options
.
line
}
)
;
}
;
}
function
closeTab
(
id
)
{
return
{
type
:
constants
.
CLOSE_TAB
id
:
id
}
;
}
function
blackbox
(
source
shouldBlackBox
)
{
return
_ref10
=
>
{
var
dispatch
=
_ref10
.
dispatch
;
var
client
=
_ref10
.
client
;
dispatch
(
{
type
:
constants
.
BLACKBOX
source
:
source
[
PROMISE
]
:
Task
.
spawn
(
function
*
(
)
{
yield
shouldBlackBox
?
client
.
blackBox
(
source
.
id
)
:
client
.
unblackBox
(
source
.
id
)
;
return
{
isBlackBoxed
:
shouldBlackBox
}
;
}
)
}
)
;
}
;
}
function
togglePrettyPrint
(
id
)
{
return
_ref11
=
>
{
var
dispatch
=
_ref11
.
dispatch
;
var
getState
=
_ref11
.
getState
;
var
client
=
_ref11
.
client
;
var
source
=
getSource
(
getState
(
)
id
)
.
toJS
(
)
;
var
sourceText
=
getSourceText
(
getState
(
)
id
)
.
toJS
(
)
;
if
(
sourceText
.
loading
)
{
return
;
}
if
(
!
isEnabled
(
"
prettyPrint
"
)
|
|
source
.
isPrettyPrinted
)
{
return
{
}
;
}
var
url
=
source
.
url
+
"
:
formatted
"
;
var
originalSource
=
makeOriginalSource
(
{
url
source
}
)
;
dispatch
(
{
type
:
constants
.
ADD_SOURCE
source
:
originalSource
}
)
;
return
dispatch
(
{
type
:
constants
.
TOGGLE_PRETTY_PRINT
source
originalSource
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
var
state
=
getState
(
)
;
var
text
=
yield
_prettyPrintSource
(
{
source
sourceText
url
}
)
;
var
frames
=
yield
updateFrameLocations
(
state
getFrames
(
state
)
)
;
dispatch
(
selectSource
(
originalSource
.
id
)
)
;
var
originalSourceText
=
{
id
:
originalSource
.
id
contentType
:
"
text
/
javascript
"
text
}
;
return
{
isPrettyPrinted
:
true
sourceText
:
originalSourceText
frames
}
;
}
)
(
)
}
)
;
}
;
}
function
loadSourceText
(
source
)
{
return
_ref13
=
>
{
var
dispatch
=
_ref13
.
dispatch
;
var
getState
=
_ref13
.
getState
;
var
client
=
_ref13
.
client
;
var
textInfo
=
getSourceText
(
getState
(
)
source
.
id
)
;
if
(
textInfo
)
{
return
Promise
.
resolve
(
textInfo
)
;
}
return
dispatch
(
{
type
:
constants
.
LOAD_SOURCE_TEXT
source
:
source
[
PROMISE
]
:
_asyncToGenerator
(
function
*
(
)
{
var
generatedSource
=
yield
getGeneratedSource
(
getState
(
)
source
)
;
var
response
=
yield
client
.
sourceContents
(
generatedSource
.
id
)
;
var
generatedSourceText
=
{
text
:
response
.
source
contentType
:
response
.
contentType
|
|
"
text
/
javascript
"
id
:
generatedSource
.
id
}
;
var
originalSourceTexts
=
yield
getOriginalSourceTexts
(
getState
(
)
generatedSource
generatedSourceText
.
text
)
;
return
{
generatedSourceText
originalSourceTexts
}
;
}
)
(
)
}
)
;
}
;
}
var
FETCH_SOURCE_RESPONSE_DELAY
=
200
;
function
getTextForSources
(
actors
)
{
return
_ref15
=
>
{
var
dispatch
=
_ref15
.
dispatch
;
var
getState
=
_ref15
.
getState
;
var
deferred
=
defer
(
)
;
var
pending
=
new
Set
(
actors
)
;
var
fetched
=
[
]
;
var
_loop
=
function
(
actor
)
{
var
source
=
getSource
(
getState
(
)
actor
)
;
dispatch
(
loadSourceText
(
source
)
)
.
then
(
_ref24
=
>
{
var
text
=
_ref24
.
text
;
var
contentType
=
_ref24
.
contentType
;
onFetch
(
[
source
text
contentType
]
)
;
}
err
=
>
{
onError
(
source
err
)
;
}
)
;
}
;
for
(
var
actor
of
actors
)
{
_loop
(
actor
)
;
}
setTimeout
(
onTimeout
FETCH_SOURCE_RESPONSE_DELAY
)
;
function
onTimeout
(
)
{
pending
=
new
Set
(
)
;
maybeFinish
(
)
;
}
function
onFetch
(
_ref16
)
{
var
_ref17
=
_slicedToArray
(
_ref16
3
)
;
var
aSource
=
_ref17
[
0
]
;
var
aText
=
_ref17
[
1
]
;
var
aContentType
=
_ref17
[
2
]
;
if
(
!
pending
.
has
(
aSource
.
actor
)
)
{
return
;
}
pending
.
delete
(
aSource
.
actor
)
;
fetched
.
push
(
[
aSource
.
actor
aText
aContentType
]
)
;
maybeFinish
(
)
;
}
function
onError
(
_ref18
)
{
var
_ref19
=
_slicedToArray
(
_ref18
2
)
;
var
aSource
=
_ref19
[
0
]
;
var
aError
=
_ref19
[
1
]
;
pending
.
delete
(
aSource
.
actor
)
;
maybeFinish
(
)
;
}
function
maybeFinish
(
)
{
if
(
pending
.
size
=
=
0
)
{
deferred
.
resolve
(
fetched
.
sort
(
(
_ref20
_ref21
)
=
>
{
var
_ref23
=
_slicedToArray
(
_ref20
1
)
;
var
aFirst
=
_ref23
[
0
]
;
var
_ref22
=
_slicedToArray
(
_ref21
1
)
;
var
aSecond
=
_ref22
[
0
]
;
return
aFirst
>
aSecond
;
}
)
)
;
}
}
return
deferred
.
promise
;
}
;
}
module
.
exports
=
{
newSource
newSources
selectSource
selectSourceURL
closeTab
blackbox
togglePrettyPrint
loadSourceText
getTextForSources
}
;
}
function
(
module
exports
)
{
function
trimUrlQuery
(
url
)
{
var
length
=
url
.
length
;
var
q1
=
url
.
indexOf
(
"
?
"
)
;
var
q2
=
url
.
indexOf
(
"
&
"
)
;
var
q3
=
url
.
indexOf
(
"
#
"
)
;
var
q
=
Math
.
min
(
q1
!
=
-
1
?
q1
:
length
q2
!
=
-
1
?
q2
:
length
q3
!
=
-
1
?
q3
:
length
)
;
return
url
.
slice
(
0
q
)
;
}
function
isJavaScript
(
url
)
{
var
contentType
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
"
"
:
arguments
[
1
]
;
return
url
&
&
/
\
.
jsm
?
/
.
test
(
trimUrlQuery
(
url
)
)
|
|
contentType
.
includes
(
"
javascript
"
)
;
}
function
isPretty
(
source
)
{
return
source
.
url
.
match
(
/
formatted
/
)
;
}
module
.
exports
=
{
isJavaScript
isPretty
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
updateFrameLocation
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
state
frame
)
{
var
originalLocation
=
yield
getOriginalLocation
(
state
frame
.
location
)
;
return
Frame
.
update
(
frame
{
merge
:
{
location
:
Location
(
originalLocation
)
}
}
)
;
}
)
;
return
function
updateFrameLocation
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
updateFrameLocations
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
state
frames
)
{
return
yield
asyncMap
(
frames
function
(
item
)
{
return
updateFrameLocation
(
state
item
)
;
}
)
;
}
)
;
return
function
updateFrameLocations
(
_x3
_x4
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
114
)
;
var
Location
=
_require
.
Location
;
var
Frame
=
_require
.
Frame
;
var
_require2
=
__webpack_require__
(
216
)
;
var
getOriginalLocation
=
_require2
.
getOriginalLocation
;
var
_require3
=
__webpack_require__
(
176
)
;
var
asyncMap
=
_require3
.
asyncMap
;
module
.
exports
=
{
updateFrameLocations
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
190
)
;
function
newTabs
(
tabs
)
{
return
{
type
:
constants
.
ADD_TABS
value
:
tabs
}
;
}
function
selectTab
(
_ref
)
{
var
id
=
_ref
.
id
;
return
{
type
:
constants
.
SELECT_TAB
id
:
id
}
;
}
module
.
exports
=
{
newTabs
selectTab
}
;
}
function
(
module
exports
__webpack_require__
)
{
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
return
step
(
"
next
"
value
)
;
}
function
(
err
)
{
return
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
constants
=
__webpack_require__
(
190
)
;
var
_require
=
__webpack_require__
(
219
)
;
var
selectSource
=
_require
.
selectSource
;
var
_require2
=
__webpack_require__
(
184
)
;
var
PROMISE
=
_require2
.
PROMISE
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getExpressions
=
_require3
.
getExpressions
;
var
_require4
=
__webpack_require__
(
221
)
;
var
updateFrameLocations
=
_require4
.
updateFrameLocations
;
function
resumed
(
)
{
return
_ref
=
>
{
var
dispatch
=
_ref
.
dispatch
;
var
client
=
_ref
.
client
;
return
dispatch
(
{
type
:
constants
.
RESUME
value
:
undefined
}
)
;
}
;
}
function
paused
(
pauseInfo
)
{
return
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
_ref3
)
{
var
dispatch
=
_ref3
.
dispatch
;
var
getState
=
_ref3
.
getState
;
var
client
=
_ref3
.
client
;
var
frame
=
pauseInfo
.
frame
;
var
frames
=
pauseInfo
.
frames
;
var
why
=
pauseInfo
.
why
;
frames
=
yield
updateFrameLocations
(
getState
(
)
frames
)
;
dispatch
(
evaluateExpressions
(
)
)
;
dispatch
(
{
type
:
constants
.
PAUSED
pauseInfo
:
{
why
frame
}
frames
:
frames
selectedFrameId
:
frame
.
id
}
)
;
dispatch
(
selectSource
(
frame
.
location
.
sourceId
{
line
:
frame
.
location
.
line
}
)
)
;
}
)
;
return
function
(
_x
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
function
pauseOnExceptions
(
shouldPauseOnExceptions
shouldIgnoreCaughtExceptions
)
{
return
_ref4
=
>
{
var
dispatch
=
_ref4
.
dispatch
;
var
client
=
_ref4
.
client
;
dispatch
(
{
type
:
constants
.
PAUSE_ON_EXCEPTIONS
shouldPauseOnExceptions
shouldIgnoreCaughtExceptions
[
PROMISE
]
:
client
.
pauseOnExceptions
(
shouldPauseOnExceptions
shouldIgnoreCaughtExceptions
)
}
)
;
}
;
}
function
command
(
_ref5
)
{
var
type
=
_ref5
.
type
;
return
_ref6
=
>
{
var
dispatch
=
_ref6
.
dispatch
;
var
client
=
_ref6
.
client
;
client
[
type
]
(
)
;
return
dispatch
(
{
type
:
constants
.
COMMAND
value
:
undefined
}
)
;
}
;
}
function
stepIn
(
)
{
return
command
(
{
type
:
"
stepIn
"
}
)
;
}
function
stepOver
(
)
{
return
command
(
{
type
:
"
stepOver
"
}
)
;
}
function
stepOut
(
)
{
return
command
(
{
type
:
"
stepOut
"
}
)
;
}
function
resume
(
)
{
return
command
(
{
type
:
"
resume
"
}
)
;
}
function
breakOnNext
(
)
{
return
_ref7
=
>
{
var
dispatch
=
_ref7
.
dispatch
;
var
client
=
_ref7
.
client
;
client
.
breakOnNext
(
)
;
return
dispatch
(
{
type
:
constants
.
BREAK_ON_NEXT
value
:
true
}
)
;
}
;
}
function
selectFrame
(
frame
)
{
return
_ref8
=
>
{
var
dispatch
=
_ref8
.
dispatch
;
dispatch
(
selectSource
(
frame
.
location
.
sourceId
{
line
:
frame
.
location
.
line
}
)
)
;
dispatch
(
{
type
:
constants
.
SELECT_FRAME
frame
}
)
;
}
;
}
function
loadObjectProperties
(
grip
)
{
return
_ref9
=
>
{
var
dispatch
=
_ref9
.
dispatch
;
var
client
=
_ref9
.
client
;
dispatch
(
{
type
:
constants
.
LOAD_OBJECT_PROPERTIES
objectId
:
grip
.
actor
[
PROMISE
]
:
client
.
getProperties
(
grip
)
}
)
;
}
;
}
function
addExpression
(
expression
)
{
return
_ref10
=
>
{
var
dispatch
=
_ref10
.
dispatch
;
var
getState
=
_ref10
.
getState
;
var
id
=
expression
.
id
!
=
=
undefined
?
parseInt
(
expression
.
id
10
)
:
getExpressions
(
getState
(
)
)
.
toSeq
(
)
.
size
+
+
;
dispatch
(
{
type
:
constants
.
ADD_EXPRESSION
id
:
id
input
:
expression
.
input
}
)
;
dispatch
(
evaluateExpressions
(
)
)
;
}
;
}
function
updateExpression
(
expression
)
{
return
_ref11
=
>
{
var
dispatch
=
_ref11
.
dispatch
;
dispatch
(
{
type
:
constants
.
UPDATE_EXPRESSION
id
:
expression
.
id
input
:
expression
.
input
}
)
;
}
;
}
function
deleteExpression
(
expression
)
{
return
_ref12
=
>
{
var
dispatch
=
_ref12
.
dispatch
;
dispatch
(
{
type
:
constants
.
DELETE_EXPRESSION
id
:
expression
.
id
}
)
;
}
;
}
function
evaluateExpressions
(
)
{
return
_ref13
=
>
{
var
dispatch
=
_ref13
.
dispatch
;
var
getState
=
_ref13
.
getState
;
var
client
=
_ref13
.
client
;
for
(
var
expression
of
getExpressions
(
getState
(
)
)
)
{
dispatch
(
{
type
:
constants
.
EVALUATE_EXPRESSION
id
:
expression
.
id
input
:
expression
.
input
[
PROMISE
]
:
client
.
evaluate
(
expression
.
input
)
}
)
;
}
}
;
}
module
.
exports
=
{
addExpression
updateExpression
deleteExpression
resumed
paused
pauseOnExceptions
command
stepIn
stepOut
stepOver
resume
breakOnNext
selectFrame
loadObjectProperties
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
constants
=
__webpack_require__
(
190
)
;
var
_require
=
__webpack_require__
(
216
)
;
var
clearData
=
_require
.
clearData
;
function
willNavigate
(
)
{
clearData
(
)
;
return
{
type
:
constants
.
NAVIGATE
}
;
}
function
navigated
(
)
{
return
_ref
=
>
{
var
dispatch
=
_ref
.
dispatch
;
}
;
}
module
.
exports
=
{
willNavigate
navigated
}
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
SourcesTree
=
React
.
createFactory
(
__webpack_require__
(
229
)
)
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getSelectedSource
=
_require3
.
getSelectedSource
;
var
getSources
=
_require3
.
getSources
;
__webpack_require__
(
260
)
;
var
Sources
=
React
.
createClass
(
{
propTypes
:
{
sources
:
ImPropTypes
.
map
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
Sources
"
render
(
)
{
var
_props
=
this
.
props
;
var
sources
=
_props
.
sources
;
var
selectSource
=
_props
.
selectSource
;
return
dom
.
div
(
{
className
:
"
sources
-
panel
"
}
dom
.
div
(
{
className
:
"
sources
-
header
"
}
"
Sources
"
)
SourcesTree
(
{
sources
selectSource
}
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
selectedSource
:
getSelectedSource
(
state
)
sources
:
getSources
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Sources
)
;
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
Immutable
=
__webpack_require__
(
193
)
;
var
ANONYMOUS
=
"
<
<
anonymous
>
>
"
;
var
ImmutablePropTypes
=
{
listOf
:
createListOfTypeChecker
mapOf
:
createMapOfTypeChecker
orderedMapOf
:
createOrderedMapOfTypeChecker
setOf
:
createSetOfTypeChecker
orderedSetOf
:
createOrderedSetOfTypeChecker
stackOf
:
createStackOfTypeChecker
iterableOf
:
createIterableOfTypeChecker
recordOf
:
createRecordOfTypeChecker
shape
:
createShapeChecker
contains
:
createShapeChecker
mapContains
:
createMapContainsChecker
list
:
createImmutableTypeChecker
(
"
List
"
Immutable
.
List
.
isList
)
map
:
createImmutableTypeChecker
(
"
Map
"
Immutable
.
Map
.
isMap
)
orderedMap
:
createImmutableTypeChecker
(
"
OrderedMap
"
Immutable
.
OrderedMap
.
isOrderedMap
)
set
:
createImmutableTypeChecker
(
"
Set
"
Immutable
.
Set
.
isSet
)
orderedSet
:
createImmutableTypeChecker
(
"
OrderedSet
"
Immutable
.
OrderedSet
.
isOrderedSet
)
stack
:
createImmutableTypeChecker
(
"
Stack
"
Immutable
.
Stack
.
isStack
)
seq
:
createImmutableTypeChecker
(
"
Seq
"
Immutable
.
Seq
.
isSeq
)
record
:
createImmutableTypeChecker
(
"
Record
"
function
(
isRecord
)
{
return
isRecord
instanceof
Immutable
.
Record
;
}
)
iterable
:
createImmutableTypeChecker
(
"
Iterable
"
Immutable
.
Iterable
.
isIterable
)
}
;
function
getPropType
(
propValue
)
{
var
propType
=
typeof
propValue
;
if
(
Array
.
isArray
(
propValue
)
)
{
return
"
array
"
;
}
if
(
propValue
instanceof
RegExp
)
{
return
"
object
"
;
}
if
(
propValue
instanceof
Immutable
.
Iterable
)
{
return
"
Immutable
.
"
+
propValue
.
toSource
(
)
.
split
(
"
"
)
[
0
]
;
}
return
propType
;
}
function
createChainableTypeChecker
(
validate
)
{
function
checkType
(
isRequired
props
propName
componentName
location
propFullName
)
{
propFullName
=
propFullName
|
|
propName
;
componentName
=
componentName
|
|
ANONYMOUS
;
if
(
props
[
propName
]
=
=
null
)
{
var
locationName
=
location
;
if
(
isRequired
)
{
return
new
Error
(
"
Required
"
+
locationName
+
"
"
+
propFullName
+
"
was
not
specified
in
"
+
(
"
"
+
componentName
+
"
.
"
)
)
;
}
}
else
{
return
validate
(
props
propName
componentName
location
propFullName
)
;
}
}
var
chainedCheckType
=
checkType
.
bind
(
null
false
)
;
chainedCheckType
.
isRequired
=
checkType
.
bind
(
null
true
)
;
return
chainedCheckType
;
}
function
createImmutableTypeChecker
(
immutableClassName
immutableClassTypeValidator
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
if
(
!
immutableClassTypeValidator
(
propValue
)
)
{
var
propType
=
getPropType
(
propValue
)
;
return
new
Error
(
"
Invalid
"
+
location
+
"
"
+
propFullName
+
"
of
type
"
+
propType
+
"
"
+
(
"
supplied
to
"
+
componentName
+
"
expected
"
+
immutableClassName
+
"
.
"
)
)
;
}
return
null
;
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createIterableTypeChecker
(
typeChecker
immutableClassName
immutableClassTypeValidator
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
if
(
!
immutableClassTypeValidator
(
propValue
)
)
{
var
locationName
=
location
;
var
propType
=
getPropType
(
propValue
)
;
return
new
Error
(
"
Invalid
"
+
locationName
+
"
"
+
propFullName
+
"
of
type
"
+
(
"
"
+
propType
+
"
supplied
to
"
+
componentName
+
"
expected
an
Immutable
.
js
"
+
immutableClassName
+
"
.
"
)
)
;
}
if
(
typeof
typeChecker
!
=
=
"
function
"
)
{
return
new
Error
(
"
Invalid
typeChecker
supplied
to
"
+
componentName
+
"
"
+
(
"
for
propType
"
+
propFullName
+
"
expected
a
function
.
"
)
)
;
}
var
propValues
=
propValue
.
toArray
(
)
;
for
(
var
i
=
0
len
=
propValues
.
length
;
i
<
len
;
i
+
+
)
{
var
error
=
typeChecker
(
propValues
i
componentName
location
"
"
+
propFullName
+
"
[
"
+
i
+
"
]
"
)
;
if
(
error
instanceof
Error
)
{
return
error
;
}
}
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createListOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
List
"
Immutable
.
List
.
isList
)
;
}
function
createMapOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Map
"
Immutable
.
Map
.
isMap
)
;
}
function
createOrderedMapOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
OrderedMap
"
Immutable
.
OrderedMap
.
isOrderedMap
)
;
}
function
createSetOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Set
"
Immutable
.
Set
.
isSet
)
;
}
function
createOrderedSetOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
OrderedSet
"
Immutable
.
OrderedSet
.
isOrderedSet
)
;
}
function
createStackOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Stack
"
Immutable
.
Stack
.
isStack
)
;
}
function
createIterableOfTypeChecker
(
typeChecker
)
{
return
createIterableTypeChecker
(
typeChecker
"
Iterable
"
Immutable
.
Iterable
.
isIterable
)
;
}
function
createRecordOfTypeChecker
(
recordKeys
)
{
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
!
(
propValue
instanceof
Immutable
.
Record
)
)
{
var
locationName
=
location
;
return
new
Error
(
"
Invalid
"
+
locationName
+
"
"
+
propFullName
+
"
of
type
"
+
propType
+
"
"
+
(
"
supplied
to
"
+
componentName
+
"
expected
an
Immutable
.
js
Record
.
"
)
)
;
}
for
(
var
key
in
recordKeys
)
{
var
checker
=
recordKeys
[
key
]
;
if
(
!
checker
)
{
continue
;
}
var
mutablePropValue
=
propValue
.
toObject
(
)
;
var
error
=
checker
(
mutablePropValue
key
componentName
location
"
"
+
propFullName
+
"
.
"
+
key
)
;
if
(
error
)
{
return
error
;
}
}
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createShapeTypeChecker
(
shapeTypes
)
{
var
immutableClassName
=
arguments
[
1
]
=
=
=
undefined
?
"
Iterable
"
:
arguments
[
1
]
;
var
immutableClassTypeValidator
=
arguments
[
2
]
=
=
=
undefined
?
Immutable
.
Iterable
.
isIterable
:
arguments
[
2
]
;
function
validate
(
props
propName
componentName
location
propFullName
)
{
var
propValue
=
props
[
propName
]
;
var
propType
=
getPropType
(
propValue
)
;
if
(
!
immutableClassTypeValidator
(
propValue
)
)
{
var
locationName
=
location
;
return
new
Error
(
"
Invalid
"
+
locationName
+
"
"
+
propFullName
+
"
of
type
"
+
propType
+
"
"
+
(
"
supplied
to
"
+
componentName
+
"
expected
an
Immutable
.
js
"
+
immutableClassName
+
"
.
"
)
)
;
}
var
mutablePropValue
=
propValue
.
toObject
(
)
;
for
(
var
key
in
shapeTypes
)
{
var
checker
=
shapeTypes
[
key
]
;
if
(
!
checker
)
{
continue
;
}
var
error
=
checker
(
mutablePropValue
key
componentName
location
"
"
+
propFullName
+
"
.
"
+
key
)
;
if
(
error
)
{
return
error
;
}
}
}
return
createChainableTypeChecker
(
validate
)
;
}
function
createShapeChecker
(
shapeTypes
)
{
return
createShapeTypeChecker
(
shapeTypes
)
;
}
function
createMapContainsChecker
(
shapeTypes
)
{
return
createShapeTypeChecker
(
shapeTypes
"
Map
"
Immutable
.
Map
.
isMap
)
;
}
module
.
exports
=
ImmutablePropTypes
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
classnames
=
__webpack_require__
(
207
)
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
_require
=
__webpack_require__
(
193
)
;
var
Set
=
_require
.
Set
;
var
_require2
=
__webpack_require__
(
230
)
;
var
nodeHasChildren
=
_require2
.
nodeHasChildren
;
var
createParentMap
=
_require2
.
createParentMap
;
var
addToTree
=
_require2
.
addToTree
;
var
collapseTree
=
_require2
.
collapseTree
;
var
createTree
=
_require2
.
createTree
;
var
ManagedTree
=
React
.
createFactory
(
__webpack_require__
(
231
)
)
;
var
Svg
=
__webpack_require__
(
235
)
;
var
_require3
=
__webpack_require__
(
176
)
;
var
throttle
=
_require3
.
throttle
;
var
SourcesTree
=
React
.
createClass
(
{
propTypes
:
{
sources
:
ImPropTypes
.
map
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
SourcesTree
"
getInitialState
(
)
{
return
createTree
(
this
.
props
.
sources
)
;
}
queueUpdate
:
throttle
(
function
(
)
{
if
(
!
this
.
isMounted
(
)
)
{
return
;
}
this
.
forceUpdate
(
)
;
}
50
)
shouldComponentUpdate
(
)
{
this
.
queueUpdate
(
)
;
return
false
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
nextProps
.
sources
=
=
=
this
.
props
.
sources
)
{
return
;
}
if
(
nextProps
.
sources
.
size
=
=
=
0
)
{
this
.
setState
(
createTree
(
nextProps
.
sources
)
)
;
return
;
}
var
next
=
Set
(
nextProps
.
sources
.
valueSeq
(
)
)
;
var
prev
=
Set
(
this
.
props
.
sources
.
valueSeq
(
)
)
;
var
newSet
=
next
.
subtract
(
prev
)
;
var
uncollapsedTree
=
this
.
state
.
uncollapsedTree
;
for
(
var
source
of
newSet
)
{
addToTree
(
uncollapsedTree
source
)
;
}
var
sourceTree
=
newSet
.
size
>
0
?
collapseTree
(
uncollapsedTree
)
:
this
.
state
.
sourceTree
;
this
.
setState
(
{
uncollapsedTree
sourceTree
parentMap
:
createParentMap
(
sourceTree
)
}
)
;
}
focusItem
(
item
)
{
this
.
setState
(
{
focusedItem
:
item
}
)
;
}
selectItem
(
item
)
{
if
(
!
nodeHasChildren
(
item
)
)
{
this
.
props
.
selectSource
(
item
.
contents
.
get
(
"
id
"
)
)
;
}
}
getIcon
(
item
depth
)
{
if
(
depth
=
=
=
0
)
{
return
new
Svg
(
"
domain
"
)
;
}
if
(
!
nodeHasChildren
(
item
)
)
{
return
new
Svg
(
"
file
"
)
;
}
return
new
Svg
(
"
folder
"
)
;
}
renderItem
(
item
depth
focused
_
expanded
_ref
)
{
var
setExpanded
=
_ref
.
setExpanded
;
var
arrow
=
new
Svg
(
"
arrow
"
{
className
:
classnames
(
{
expanded
:
expanded
hidden
:
!
nodeHasChildren
(
item
)
}
)
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
setExpanded
(
item
!
expanded
)
;
}
}
)
;
var
icon
=
this
.
getIcon
(
item
depth
)
;
return
dom
.
div
(
{
className
:
classnames
(
"
node
"
{
focused
}
)
style
:
{
paddingLeft
:
depth
*
15
+
"
px
"
}
key
:
item
.
path
onClick
:
(
)
=
>
this
.
selectItem
(
item
)
onDoubleClick
:
e
=
>
setExpanded
(
item
!
expanded
)
}
dom
.
div
(
null
arrow
icon
item
.
name
)
)
;
}
render
:
function
(
)
{
var
_state
=
this
.
state
;
var
focusedItem
=
_state
.
focusedItem
;
var
sourceTree
=
_state
.
sourceTree
;
var
parentMap
=
_state
.
parentMap
;
var
tree
=
ManagedTree
(
{
getParent
:
item
=
>
{
return
parentMap
.
get
(
item
)
;
}
getChildren
:
item
=
>
{
if
(
nodeHasChildren
(
item
)
)
{
return
item
.
contents
;
}
return
[
]
;
}
getRoots
:
(
)
=
>
sourceTree
.
contents
getKey
:
(
item
i
)
=
>
item
.
path
itemHeight
:
30
autoExpandDepth
:
2
onFocus
:
this
.
focusItem
renderItem
:
this
.
renderItem
}
)
;
return
dom
.
div
(
{
className
:
"
sources
-
list
"
onKeyDown
:
e
=
>
{
if
(
e
.
keyCode
=
=
=
13
&
&
focusedItem
)
{
this
.
selectItem
(
focusedItem
)
;
}
}
}
tree
)
;
}
}
)
;
module
.
exports
=
SourcesTree
;
}
function
(
module
exports
__webpack_require__
)
{
var
URL
=
__webpack_require__
(
200
)
;
var
_require
=
__webpack_require__
(
186
)
;
var
assert
=
_require
.
assert
;
var
_require2
=
__webpack_require__
(
220
)
;
var
isPretty
=
_require2
.
isPretty
;
var
IGNORED_URLS
=
[
"
debugger
eval
code
"
"
XStringBundle
"
]
;
function
isHiddenSource
(
source
)
{
var
url
=
source
.
get
(
"
url
"
)
;
return
!
url
|
|
url
.
match
(
/
SOURCE
/
)
|
|
IGNORED_URLS
.
includes
(
url
)
;
}
function
nodeHasChildren
(
item
)
{
return
Array
.
isArray
(
item
.
contents
)
;
}
function
createNode
(
name
path
contents
)
{
return
{
name
path
contents
:
contents
|
|
null
}
;
}
function
createParentMap
(
tree
)
{
var
map
=
new
WeakMap
(
)
;
function
_traverse
(
subtree
)
{
if
(
nodeHasChildren
(
subtree
)
)
{
for
(
var
child
of
subtree
.
contents
)
{
map
.
set
(
child
subtree
)
;
_traverse
(
child
)
;
}
}
}
tree
.
contents
.
forEach
(
_traverse
)
;
return
map
;
}
function
getURL
(
source
)
{
var
url
=
source
.
get
(
"
url
"
)
;
if
(
!
url
)
{
return
null
;
}
var
urlObj
=
URL
.
parse
(
url
)
;
if
(
!
urlObj
.
protocol
&
&
urlObj
.
pathname
[
0
]
=
=
=
"
/
"
)
{
urlObj
.
protocol
=
"
file
:
"
;
}
else
if
(
!
urlObj
.
host
&
&
!
urlObj
.
protocol
)
{
return
{
path
:
url
group
:
"
(
no
domain
)
"
}
;
}
else
if
(
urlObj
.
protocol
=
=
=
"
javascript
:
"
)
{
return
null
;
}
else
if
(
urlObj
.
protocol
=
=
=
"
about
:
"
)
{
return
{
path
:
"
/
"
group
:
url
}
;
}
else
if
(
urlObj
.
protocol
=
=
=
"
http
:
"
|
|
urlObj
.
protocol
=
=
=
"
https
:
"
)
{
return
{
path
:
urlObj
.
pathname
group
:
urlObj
.
host
}
;
}
return
{
path
:
urlObj
.
path
group
:
urlObj
.
protocol
+
"
/
/
"
}
;
}
function
addToTree
(
tree
source
)
{
var
url
=
getURL
(
source
)
;
if
(
isHiddenSource
(
source
)
|
|
isPretty
(
source
.
toJS
(
)
)
)
{
return
;
}
url
.
path
=
decodeURIComponent
(
url
.
path
)
;
var
parts
=
url
.
path
.
split
(
"
/
"
)
.
filter
(
p
=
>
p
!
=
=
"
"
)
;
var
isDir
=
parts
.
length
=
=
=
0
|
|
parts
[
parts
.
length
-
1
]
.
indexOf
(
"
.
"
)
=
=
=
-
1
;
parts
.
unshift
(
url
.
group
)
;
var
path
=
"
"
;
var
subtree
=
tree
;
var
_loop
=
function
(
part
)
{
assert
(
nodeHasChildren
(
subtree
)
{
subtree
.
name
}
should
have
children
)
;
var
subpaths
=
subtree
.
contents
;
var
idx
=
subpaths
.
findIndex
(
subpath
=
>
{
return
subpath
.
name
.
localeCompare
(
part
)
>
=
0
;
}
)
;
if
(
idx
>
=
0
&
&
subpaths
[
idx
]
.
name
=
=
=
part
)
{
subtree
=
subpaths
[
idx
]
;
}
else
{
var
node
=
createNode
(
part
path
+
"
/
"
+
part
[
]
)
;
var
where
=
idx
=
=
=
-
1
?
subpaths
.
length
:
idx
;
subpaths
.
splice
(
where
0
node
)
;
subtree
=
subpaths
[
where
]
;
}
path
=
path
+
"
/
"
+
part
;
}
;
for
(
var
part
of
parts
)
{
_loop
(
part
)
;
}
if
(
isDir
)
{
subtree
.
contents
.
unshift
(
createNode
(
"
(
index
)
"
source
.
get
(
"
url
"
)
source
)
)
;
}
else
{
subtree
.
contents
=
source
;
}
}
function
collapseTree
(
node
)
{
var
depth
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
0
:
arguments
[
1
]
;
if
(
nodeHasChildren
(
node
)
)
{
if
(
depth
>
1
&
&
node
.
contents
.
length
=
=
=
1
)
{
var
next
=
node
.
contents
[
0
]
;
if
(
nodeHasChildren
(
next
)
)
{
return
collapseTree
(
createNode
(
{
node
.
name
}
/
{
next
.
name
}
next
.
path
next
.
contents
)
depth
+
1
)
;
}
}
return
createNode
(
node
.
name
node
.
path
node
.
contents
.
map
(
next
=
>
collapseTree
(
next
depth
+
1
)
)
)
;
}
return
node
;
}
function
createTree
(
sources
)
{
var
uncollapsedTree
=
createNode
(
"
root
"
"
"
[
]
)
;
for
(
var
source
of
sources
.
valueSeq
(
)
)
{
addToTree
(
uncollapsedTree
source
)
;
}
var
sourceTree
=
collapseTree
(
uncollapsedTree
)
;
return
{
uncollapsedTree
sourceTree
parentMap
:
createParentMap
(
sourceTree
)
focusedItem
:
null
}
;
}
module
.
exports
=
{
createNode
nodeHasChildren
createParentMap
addToTree
collapseTree
createTree
getURL
isHiddenSource
}
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
Tree
=
React
.
createFactory
(
__webpack_require__
(
232
)
)
;
__webpack_require__
(
233
)
;
var
ManagedTree
=
React
.
createClass
(
{
propTypes
:
Tree
.
propTypes
displayName
:
"
ManagedTree
"
getInitialState
(
)
{
return
{
expanded
:
new
Set
(
)
focusedItem
:
null
}
;
}
setExpanded
(
item
isExpanded
)
{
var
expanded
=
this
.
state
.
expanded
;
var
key
=
this
.
props
.
getKey
(
item
)
;
if
(
isExpanded
)
{
expanded
.
add
(
key
)
;
}
else
{
expanded
.
delete
(
key
)
;
}
this
.
setState
(
{
expanded
}
)
;
if
(
isExpanded
&
&
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
}
else
if
(
!
expanded
&
&
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
focusItem
(
item
)
{
if
(
!
this
.
props
.
disabledFocus
&
&
this
.
state
.
focusedItem
!
=
=
item
)
{
this
.
setState
(
{
focusedItem
:
item
}
)
;
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
}
render
(
)
{
var
_this
=
this
;
var
_state
=
this
.
state
;
var
expanded
=
_state
.
expanded
;
var
focusedItem
=
_state
.
focusedItem
;
var
props
=
Object
.
assign
(
{
}
this
.
props
{
isExpanded
:
item
=
>
expanded
.
has
(
this
.
props
.
getKey
(
item
)
)
focused
:
focusedItem
onExpand
:
item
=
>
this
.
setExpanded
(
item
true
)
onCollapse
:
item
=
>
this
.
setExpanded
(
item
false
)
onFocus
:
this
.
focusItem
renderItem
:
function
(
)
{
var
_props
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
return
(
_props
=
_this
.
props
)
.
renderItem
.
apply
(
_props
args
.
concat
(
[
{
setExpanded
:
_this
.
setExpanded
}
]
)
)
;
}
}
)
;
return
Tree
(
props
)
;
}
}
)
;
module
.
exports
=
ManagedTree
;
}
function
(
module
exports
__webpack_require__
)
{
const
{
DOM
:
dom
createClass
createFactory
PropTypes
}
=
__webpack_require__
(
17
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
ArrowExpander
=
createFactory
(
createClass
(
{
displayName
:
"
ArrowExpander
"
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
visible
!
=
=
nextProps
.
visible
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
attrs
=
{
className
:
"
arrow
theme
-
twisty
"
onClick
:
this
.
props
.
expanded
?
(
)
=
>
this
.
props
.
onCollapse
(
this
.
props
.
item
)
:
e
=
>
this
.
props
.
onExpand
(
this
.
props
.
item
e
.
altKey
)
}
;
if
(
this
.
props
.
expanded
)
{
attrs
.
className
+
=
"
open
"
;
}
if
(
!
this
.
props
.
visible
)
{
attrs
.
style
=
{
visibility
:
"
hidden
"
}
;
}
return
dom
.
div
(
attrs
this
.
props
.
children
)
;
}
}
)
)
;
const
TreeNode
=
createFactory
(
createClass
(
{
displayName
:
"
TreeNode
"
componentDidMount
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
componentDidUpdate
(
)
{
if
(
this
.
props
.
focused
)
{
this
.
refs
.
button
.
focus
(
)
;
}
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
focused
!
=
=
nextProps
.
focused
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
arrow
=
ArrowExpander
(
{
item
:
this
.
props
.
item
expanded
:
this
.
props
.
expanded
visible
:
this
.
props
.
hasChildren
onExpand
:
this
.
props
.
onExpand
onCollapse
:
this
.
props
.
onCollapse
}
)
;
let
isOddRow
=
this
.
props
.
index
%
2
;
return
dom
.
div
(
{
className
:
tree
-
node
div
{
isOddRow
?
"
tree
-
node
-
odd
"
:
"
"
}
onFocus
:
this
.
props
.
onFocus
onClick
:
this
.
props
.
onFocus
onBlur
:
this
.
props
.
onBlur
style
:
{
padding
:
0
margin
:
0
}
}
this
.
props
.
renderItem
(
this
.
props
.
item
this
.
props
.
depth
this
.
props
.
focused
arrow
this
.
props
.
expanded
)
dom
.
button
(
this
.
_buttonAttrs
)
)
;
}
_buttonAttrs
:
{
ref
:
"
button
"
style
:
{
opacity
:
0
width
:
"
0
!
important
"
height
:
"
0
!
important
"
padding
:
"
0
!
important
"
outline
:
"
none
"
MozAppearance
:
"
none
"
MozMarginStart
:
"
-
1000px
!
important
"
}
}
}
)
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
const
NUMBER_OF_OFFSCREEN_ITEMS
=
1
;
const
Tree
=
module
.
exports
=
createClass
(
{
displayName
:
"
Tree
"
propTypes
:
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
isExpanded
:
PropTypes
.
func
.
isRequired
itemHeight
:
PropTypes
.
number
.
isRequired
focused
:
PropTypes
.
any
onFocus
:
PropTypes
.
func
autoExpandDepth
:
PropTypes
.
number
onExpand
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
}
getDefaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
}
;
}
getInitialState
(
)
{
return
{
scroll
:
0
height
:
window
.
innerHeight
seen
:
new
Set
(
)
}
;
}
componentDidMount
(
)
{
window
.
addEventListener
(
"
resize
"
this
.
_updateHeight
)
;
this
.
_autoExpand
(
this
.
props
)
;
this
.
_updateHeight
(
)
;
}
componentWillUnmount
(
)
{
window
.
removeEventListener
(
"
resize
"
this
.
_updateHeight
)
;
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
nextProps
)
;
this
.
_updateHeight
(
)
;
}
_autoExpand
(
props
)
{
if
(
!
props
.
autoExpandDepth
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
if
(
currentDepth
>
=
props
.
autoExpandDepth
|
|
this
.
state
.
seen
.
has
(
item
)
)
{
return
;
}
props
.
onExpand
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
const
children
=
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
renderItem
=
i
=
>
{
let
{
item
depth
}
=
traversal
[
i
]
;
return
TreeNode
(
{
key
:
this
.
props
.
getKey
(
item
i
)
index
:
i
item
:
item
depth
:
depth
renderItem
:
this
.
props
.
renderItem
focused
:
this
.
props
.
focused
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
hasChildren
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onFocus
:
(
)
=
>
this
.
_focus
(
i
item
)
}
)
;
}
return
dom
.
div
(
{
className
:
"
tree
"
ref
:
"
tree
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
style
:
{
padding
:
0
margin
:
0
}
}
traversal
.
map
(
(
v
i
)
=
>
renderItem
(
i
)
)
)
;
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
}
_updateHeight
(
)
{
this
.
setState
(
{
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
:
oncePerAnimationFrame
(
function
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
)
_onCollapse
:
oncePerAnimationFrame
(
function
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
)
_focus
(
index
item
)
{
if
(
item
!
=
=
undefined
)
{
const
itemStartPosition
=
index
*
this
.
props
.
itemHeight
;
const
itemEndPosition
=
(
index
+
1
)
*
this
.
props
.
itemHeight
;
if
(
this
.
state
.
scroll
>
itemStartPosition
)
{
this
.
refs
.
tree
.
scrollTop
=
itemStartPosition
;
}
else
if
(
(
this
.
state
.
scroll
+
this
.
state
.
height
)
<
itemEndPosition
)
{
this
.
refs
.
tree
.
scrollTop
=
itemEndPosition
-
this
.
state
.
height
;
}
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_onBlur
(
)
{
this
.
_focus
(
0
undefined
)
;
}
_onScroll
:
oncePerAnimationFrame
(
function
(
e
)
{
this
.
setState
(
{
scroll
:
Math
.
max
(
this
.
refs
.
tree
.
scrollTop
0
)
height
:
this
.
refs
.
tree
.
clientHeight
}
)
;
}
)
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
props
.
getChildren
(
this
.
props
.
focused
)
.
length
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
;
}
}
_focusPrevNode
:
oncePerAnimationFrame
(
function
(
)
{
let
prev
;
let
prevIndex
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
prevIndex
=
i
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prevIndex
prev
)
;
}
)
_focusNextNode
:
oncePerAnimationFrame
(
function
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
i
+
1
traversal
[
i
+
1
]
.
item
)
;
}
}
)
_focusParentNode
:
oncePerAnimationFrame
(
function
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
return
;
}
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
parentIndex
=
0
;
for
(
;
parentIndex
<
length
;
parentIndex
+
+
)
{
if
(
traversal
[
parentIndex
]
.
item
=
=
=
parent
)
{
break
;
}
}
this
.
_focus
(
parentIndex
parent
)
;
}
)
}
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
Svg
=
__webpack_require__
(
236
)
;
module
.
exports
=
Svg
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
InlineSVG
=
__webpack_require__
(
237
)
;
var
svg
=
{
"
angle
-
brackets
"
:
__webpack_require__
(
238
)
"
arrow
"
:
__webpack_require__
(
239
)
"
blackBox
"
:
__webpack_require__
(
240
)
"
breakpoint
"
:
__webpack_require__
(
241
)
"
close
"
:
__webpack_require__
(
242
)
"
disableBreakpoints
"
:
__webpack_require__
(
243
)
"
domain
"
:
__webpack_require__
(
244
)
"
file
"
:
__webpack_require__
(
245
)
"
folder
"
:
__webpack_require__
(
246
)
"
globe
"
:
__webpack_require__
(
247
)
"
magnifying
-
glass
"
:
__webpack_require__
(
248
)
"
pause
"
:
__webpack_require__
(
249
)
"
pause
-
circle
"
:
__webpack_require__
(
250
)
"
pause
-
exceptions
"
:
__webpack_require__
(
251
)
"
prettyPrint
"
:
__webpack_require__
(
252
)
"
resume
"
:
__webpack_require__
(
253
)
"
settings
"
:
__webpack_require__
(
254
)
"
stepIn
"
:
__webpack_require__
(
255
)
"
stepOut
"
:
__webpack_require__
(
256
)
"
stepOver
"
:
__webpack_require__
(
257
)
"
subSettings
"
:
__webpack_require__
(
258
)
"
worker
"
:
__webpack_require__
(
259
)
}
;
module
.
exports
=
function
(
name
props
)
{
if
(
!
svg
[
name
]
)
{
throw
new
Error
(
"
Unknown
SVG
:
"
+
name
)
;
}
var
className
=
name
;
if
(
props
&
&
props
.
className
)
{
className
=
{
name
}
{
props
.
className
}
;
}
if
(
name
=
=
=
"
subSettings
"
)
{
className
=
"
"
;
}
props
=
Object
.
assign
(
{
}
props
{
className
src
:
svg
[
name
]
}
)
;
return
React
.
createElement
(
InlineSVG
props
)
;
}
;
}
function
(
module
exports
__webpack_require__
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
'
__esModule
'
{
value
:
true
}
)
;
var
_extends
=
Object
.
assign
|
|
function
(
target
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
var
source
=
arguments
[
i
]
;
for
(
var
key
in
source
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
source
key
)
)
{
target
[
key
]
=
source
[
key
]
;
}
}
}
return
target
;
}
;
var
_createClass
=
(
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
'
value
'
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
)
(
)
;
var
_get
=
function
get
(
_x
_x2
_x3
)
{
var
_again
=
true
;
_function
:
while
(
_again
)
{
var
object
=
_x
property
=
_x2
receiver
=
_x3
;
_again
=
false
;
if
(
object
=
=
=
null
)
object
=
Function
.
prototype
;
var
desc
=
Object
.
getOwnPropertyDescriptor
(
object
property
)
;
if
(
desc
=
=
=
undefined
)
{
var
parent
=
Object
.
getPrototypeOf
(
object
)
;
if
(
parent
=
=
=
null
)
{
return
undefined
;
}
else
{
_x
=
parent
;
_x2
=
property
;
_x3
=
receiver
;
_again
=
true
;
desc
=
parent
=
undefined
;
continue
_function
;
}
}
else
if
(
'
value
'
in
desc
)
{
return
desc
.
value
;
}
else
{
var
getter
=
desc
.
get
;
if
(
getter
=
=
=
undefined
)
{
return
undefined
;
}
return
getter
.
call
(
receiver
)
;
}
}
}
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
function
_objectWithoutProperties
(
obj
keys
)
{
var
target
=
{
}
;
for
(
var
i
in
obj
)
{
if
(
keys
.
indexOf
(
i
)
>
=
0
)
continue
;
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
continue
;
target
[
i
]
=
obj
[
i
]
;
}
return
target
;
}
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
'
Cannot
call
a
class
as
a
function
'
)
;
}
}
function
_inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
'
function
'
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
'
Super
expression
must
either
be
null
or
a
function
not
'
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
subClass
.
__proto__
=
superClass
;
}
var
_react
=
__webpack_require__
(
17
)
;
var
_react2
=
_interopRequireDefault
(
_react
)
;
var
DOMParser
=
typeof
window
!
=
=
'
undefined
'
&
&
window
.
DOMParser
;
var
process
=
process
|
|
{
}
;
process
.
env
=
process
.
env
|
|
{
}
;
var
parserAvailable
=
typeof
DOMParser
!
=
=
'
undefined
'
&
&
DOMParser
.
prototype
!
=
null
&
&
DOMParser
.
prototype
.
parseFromString
!
=
null
;
if
(
"
production
"
!
=
=
process
.
env
.
NODE_ENV
&
&
!
parserAvailable
)
{
console
.
info
(
'
<
InlineSVG
/
>
:
raw
prop
works
only
when
window
.
DOMParser
exists
.
'
)
;
}
function
isParsable
(
src
)
{
return
parserAvailable
&
&
typeof
src
=
=
=
'
string
'
&
&
src
.
trim
(
)
.
substr
(
0
4
)
=
=
=
'
<
svg
'
;
}
function
parseFromSVGString
(
src
)
{
var
parser
=
new
DOMParser
(
)
;
return
parser
.
parseFromString
(
src
"
image
/
svg
+
xml
"
)
;
}
function
switchSVGAttrToReactProp
(
propName
)
{
switch
(
propName
)
{
case
'
class
'
:
return
'
className
'
;
default
:
return
propName
;
}
}
var
InlineSVG
=
(
function
(
_React
Component
)
{
_inherits
(
InlineSVG
_React
Component
)
;
_createClass
(
InlineSVG
null
[
{
key
:
'
defaultProps
'
value
:
{
element
:
'
i
'
raw
:
false
src
:
'
'
}
enumerable
:
true
}
{
key
:
'
propTypes
'
value
:
{
src
:
_react2
[
'
default
'
]
.
PropTypes
.
string
.
isRequired
element
:
_react2
[
'
default
'
]
.
PropTypes
.
string
raw
:
_react2
[
'
default
'
]
.
PropTypes
.
bool
}
enumerable
:
true
}
]
)
;
function
InlineSVG
(
props
)
{
_classCallCheck
(
this
InlineSVG
)
;
_get
(
Object
.
getPrototypeOf
(
InlineSVG
.
prototype
)
'
constructor
'
this
)
.
call
(
this
props
)
;
this
.
_extractSVGProps
=
this
.
_extractSVGProps
.
bind
(
this
)
;
}
_createClass
(
InlineSVG
[
{
key
:
'
_serializeAttrs
'
value
:
function
_serializeAttrs
(
map
)
{
var
ret
=
{
}
;
var
prop
=
undefined
;
for
(
var
i
=
0
;
i
<
map
.
length
;
i
+
+
)
{
prop
=
switchSVGAttrToReactProp
(
map
[
i
]
.
name
)
;
ret
[
prop
]
=
map
[
i
]
.
value
;
}
return
ret
;
}
}
{
key
:
'
_extractSVGProps
'
value
:
function
_extractSVGProps
(
src
)
{
var
map
=
parseFromSVGString
(
src
)
.
documentElement
.
attributes
;
return
map
.
length
>
0
?
this
.
_serializeAttrs
(
map
)
:
null
;
}
}
{
key
:
'
_stripSVG
'
value
:
function
_stripSVG
(
src
)
{
return
parseFromSVGString
(
src
)
.
documentElement
.
innerHTML
;
}
}
{
key
:
'
componentWillReceiveProps
'
value
:
function
componentWillReceiveProps
(
_ref
)
{
var
children
=
_ref
.
children
;
if
(
"
production
"
!
=
=
process
.
env
.
NODE_ENV
&
&
children
!
=
null
)
{
console
.
info
(
'
<
InlineSVG
/
>
:
children
prop
will
be
ignored
.
'
)
;
}
}
}
{
key
:
'
render
'
value
:
function
render
(
)
{
var
Element
=
undefined
__html
=
undefined
svgProps
=
undefined
;
var
_props
=
this
.
props
;
var
element
=
_props
.
element
;
var
raw
=
_props
.
raw
;
var
src
=
_props
.
src
;
var
otherProps
=
_objectWithoutProperties
(
_props
[
'
element
'
'
raw
'
'
src
'
]
)
;
if
(
raw
=
=
=
true
&
&
isParsable
(
src
)
)
{
Element
=
'
svg
'
;
svgProps
=
this
.
_extractSVGProps
(
src
)
;
__html
=
this
.
_stripSVG
(
src
)
;
}
__html
=
__html
|
|
src
;
Element
=
Element
|
|
element
;
svgProps
=
svgProps
|
|
{
}
;
return
_react2
[
'
default
'
]
.
createElement
(
Element
_extends
(
{
}
svgProps
otherProps
{
src
:
null
children
:
null
dangerouslySetInnerHTML
:
{
__html
:
__html
}
}
)
)
;
}
}
]
)
;
return
InlineSVG
;
}
)
(
_react2
[
'
default
'
]
.
Component
)
;
exports
[
'
default
'
]
=
InlineSVG
;
module
.
exports
=
exports
[
'
default
'
]
;
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
-
1
73
16
11
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
g
id
=
\
"
Shape
-
Copy
-
3
-
+
-
Shape
-
Copy
-
4
\
"
stroke
=
\
"
none
\
"
stroke
-
width
=
\
"
1
\
"
fill
=
\
"
none
\
"
fill
-
rule
=
\
"
evenodd
\
"
transform
=
\
"
translate
(
0
.
000000
74
.
000000
)
\
"
>
<
path
d
=
\
"
M0
.
749321284
4
.
16081709
L4
.
43130681
0
.
242526751
C4
.
66815444
-
0
.
00952143591
5
.
06030999
-
0
.
0211407611
5
.
30721074
0
.
216574262
C5
.
55411149
0
.
454289284
5
.
56226116
0
.
851320812
5
.
32541353
1
.
103369
L1
.
95384971
4
.
69131519
L5
.
48809879
8
.
09407556
C5
.
73499955
8
.
33179058
5
.
74314922
8
.
72882211
5
.
50630159
8
.
9808703
C5
.
26945396
9
.
23291849
4
.
87729841
9
.
24453781
4
.
63039766
9
.
00682279
L0
.
827097345
5
.
34502101
C0
.
749816996
5
.
31670099
0
.
677016974
5
.
27216098
0
.
613753508
5
.
21125118
C0
.
427367989
5
.
03179997
0
.
377040713
4
.
7615583
0
.
465458792
4
.
53143559
C0
.
492371834
4
.
43667624
0
.
541703274
4
.
34676528
0
.
613628034
4
.
27022448
C0
.
654709457
4
.
22650651
0
.
70046335
4
.
19002189
0
.
749321284
4
.
16081709
Z
\
"
id
=
\
"
Shape
-
Copy
-
3
\
"
stroke
=
\
"
#
FFFFFF
\
"
stroke
-
width
=
\
"
0
.
05
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
/
path
>
<
path
d
=
\
"
M13
.
7119065
5
.
44453032
L9
.
77062746
9
.
09174784
C9
.
51677479
9
.
3266604
9
.
12476399
9
.
31089603
8
.
89504684
9
.
05653714
C8
.
66532968
8
.
80217826
8
.
68489539
8
.
40554539
8
.
93874806
8
.
17063283
L12
.
5546008
4
.
82456128
L9
.
26827469
1
.
18571135
C9
.
03855754
0
.
931352463
9
.
05812324
0
.
534719593
9
.
31197591
0
.
299807038
C9
.
56582858
0
.
0648944831
9
.
95783938
0
.
0806588502
10
.
1875565
0
.
335017737
L13
.
72891
4
.
25625178
C13
.
8013755
4
.
28980469
13
.
8684335
4
.
3382578
13
.
9254821
4
.
40142604
C14
.
0883019
4
.
58171146
14
.
1258883
4
.
83347168
14
.
0435812
5
.
04846202
C14
.
0126705
5
.
15680232
13
.
9526426
5
.
2583679
13
.
8641331
5
.
34027361
C13
.
8174417
5
.
38348136
13
.
7660763
5
.
41820853
13
.
7119065
5
.
44453032
Z
\
"
id
=
\
"
Shape
-
Copy
-
4
\
"
stroke
=
\
"
#
FFFFFF
\
"
stroke
-
width
=
\
"
0
.
05
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
viewBox
=
\
"
0
0
16
16
\
"
>
<
path
d
=
\
"
M8
13
.
4c
-
.
5
0
-
.
9
-
.
2
-
1
.
2
-
.
6L
.
4
5
.
2C0
4
.
7
-
.
1
4
.
3
.
2
3
.
7S1
3
1
.
6
3h12
.
8c
.
6
0
1
.
2
.
1
1
.
4
.
7
.
3
.
6
.
2
1
.
1
-
.
2
1
.
6l
-
6
.
4
7
.
6c
-
.
3
.
4
-
.
7
.
5
-
1
.
2
.
5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
circle
cx
=
\
"
8
\
"
cy
=
\
"
8
.
5
\
"
r
=
\
"
1
.
5
\
"
>
<
/
circle
>
<
path
d
=
\
"
M15
.
498
8
.
28l
-
.
001
-
.
03v
-
.
002
-
.
004l
-
.
002
-
.
018
-
.
004
-
.
031c0
-
.
002
0
-
.
002
0
0l
-
.
004
-
.
035
.
006
.
082c
-
.
037
-
.
296
-
.
133
-
.
501
-
.
28
-
.
661
-
.
4
-
.
522
-
.
915
-
1
.
042
-
1
.
562
-
1
.
604
-
1
.
36
-
1
.
182
-
2
.
74
-
1
.
975
-
4
.
178
-
2
.
309a6
.
544
6
.
544
0
0
0
-
2
.
755
-
.
042c
-
.
78
.
153
-
1
.
565
.
462
-
2
.
369
.
91C3
.
252
5
.
147
2
.
207
6
1
.
252
7
.
035c
-
.
216
.
233
-
.
36
.
398
-
.
499
.
577
-
.
338
.
437
-
.
338
1
0
1
.
437
.
428
.
552
.
941
1
.
072
1
.
59
1
.
635
1
.
359
1
.
181
2
.
739
1
.
975
4
.
177
2
.
308
.
907
.
21
1
.
829
.
223
2
.
756
.
043
.
78
-
.
153
1
.
564
-
.
462
2
.
369
-
.
91
1
.
097
-
.
612
2
.
141
-
1
.
464
3
.
097
-
2
.
499
.
217
-
.
235
.
36
-
.
398
.
498
-
.
578
.
12
-
.
128
.
216
-
.
334
.
248
-
.
554
0
.
01
0
.
01
-
.
008
.
04l
.
013
-
.
079
-
.
001
.
011
.
003
-
.
031
.
001
-
.
017v
.
005l
.
001
-
.
02v
.
008l
.
002
-
.
03
.
001
-
.
05
-
.
001
-
.
044v
-
.
004
-
.
004zm
-
.
954
.
045v
.
007l
.
001
.
004V8
.
33v
.
012l
-
.
001
.
01v
-
.
005
-
.
005l
.
002
-
.
015
-
.
001
.
008c
-
.
002
.
014
-
.
002
.
014
0
0l
-
.
007
.
084c
.
003
-
.
057
-
.
004
-
.
041
-
.
014
-
.
031
-
.
143
.
182
-
.
27
.
327
-
.
468
.
543
-
.
89
.
963
-
1
.
856
1
.
752
-
2
.
86
2
.
311
-
.
724
.
404
-
1
.
419
.
677
-
2
.
095
.
81a5
.
63
5
.
63
0
0
1
-
2
.
374
-
.
036c
-
1
.
273
-
.
295
-
2
.
523
-
1
.
014
-
3
.
774
-
2
.
101
-
.
604
-
.
525
-
1
.
075
-
1
.
001
-
1
.
457
-
1
.
496
-
.
054
-
.
07
-
.
054
-
.
107
0
-
.
177
.
117
-
.
152
.
244
-
.
298
.
442
-
.
512
.
89
-
.
963
1
.
856
-
1
.
752
2
.
86
-
2
.
311
.
724
-
.
404
1
.
419
-
.
678
2
.
095
-
.
81a5
.
631
5
.
631
0
0
1
2
.
374
.
036c1
.
272
.
295
2
.
523
1
.
014
3
.
774
2
.
101
.
603
.
524
1
.
074
1
1
.
457
1
.
496
.
035
.
041
.
043
.
057
.
046
.
076
0
.
01
0
.
01
.
008
.
043l
-
.
009
-
.
047
.
003
.
02
-
.
002
-
.
013v
-
.
008
.
016c0
-
.
004
0
-
.
004
0
0v
-
.
004z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
viewBox
=
\
"
0
0
33
12
\
"
>
<
path
id
=
\
"
base
-
path
\
"
d
=
\
"
M27
.
1
0H1C0
.
4
0
0
0
.
4
0
1v10c0
0
.
6
0
.
4
1
1
1h26
.
1
c0
.
6
0
1
.
2
-
0
.
3
1
.
5
-
0
.
7L33
6l
-
4
.
4
-
5
.
3C28
.
2
0
.
3
27
.
7
0
27
.
1
0z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
6
6
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
path
d
=
\
"
M1
.
35191454
5
.
27895256
L5
.
31214367
1
.
35518468
C5
.
50830675
1
.
16082764
5
.
50977084
0
.
844248536
5
.
3154138
0
.
648085456
C5
.
12105677
0
.
451922377
4
.
80447766
0
.
450458288
4
.
60831458
0
.
644815324
L0
.
648085456
4
.
56858321
C0
.
451922377
4
.
76294025
0
.
450458288
5
.
07951935
0
.
644815324
5
.
27568243
C0
.
83917236
5
.
47184551
1
.
15575146
5
.
4733096
1
.
35191454
5
.
27895256
L1
.
35191454
5
.
27895256
Z
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
none
\
"
fill
=
\
"
#
696969
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
path
d
=
\
"
M5
.
31214367
4
.
56858321
L1
.
35191454
0
.
644815324
C1
.
15575146
0
.
450458288
0
.
83917236
0
.
451922377
0
.
644815324
0
.
648085456
C0
.
450458288
0
.
844248536
0
.
451922377
1
.
16082764
0
.
648085456
1
.
35518468
L4
.
60831458
5
.
27895256
C4
.
80447766
5
.
4733096
5
.
12105677
5
.
47184551
5
.
3154138
5
.
27568243
C5
.
50977084
5
.
07951935
5
.
50830675
4
.
76294025
5
.
31214367
4
.
56858321
L5
.
31214367
4
.
56858321
Z
\
"
id
=
\
"
Line
-
Copy
-
2
\
"
stroke
=
\
"
none
\
"
fill
=
\
"
#
696969
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M3
.
233
11
.
25l
-
.
417
1H1
.
712C
.
763
12
.
25
0
11
.
574
0
10
.
747V6
.
503C0
5
.
675
.
755
5
1
.
712
5h4
.
127l
-
.
417
1H1
.
597C1
.
257
6
1
6
.
225
1
6
.
503v4
.
244c0
.
277
.
267
.
503
.
597
.
503h1
.
636zM7
.
405
11
.
27L7
12
.
306c
.
865
.
01
2
.
212
-
.
024
2
.
315
-
.
04
.
112
-
.
016
.
112
-
.
016
.
185
-
.
035
.
075
-
.
02
.
156
-
.
046
.
251
-
.
082
.
152
-
.
056
.
349
-
.
138
.
592
-
.
244
.
415
-
.
182
.
962
-
.
435
1
.
612
-
.
744l
.
138
-
.
066a179
.
35
179
.
35
0
0
0
2
.
255
-
1
.
094c1
.
191
-
.
546
1
.
191
-
2
.
074
-
.
025
-
2
.
632l
-
.
737
-
.
34a3547
.
554
3547
.
554
0
0
0
-
3
.
854
-
1
.
78c
-
.
029
.
11
-
.
065
.
222
-
.
11
.
336l
-
.
232
.
596c
.
894
.
408
4
.
56
2
.
107
4
.
56
2
.
107
.
458
.
21
.
458
.
596
0
.
806L9
.
197
11
.
27H7
.
405zM4
.
462
14
.
692l5
-
12a
.
5
.
5
0
1
0
-
.
924
-
.
384l
-
5
12a
.
5
.
5
0
1
0
.
924
.
384z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
path
d
=
\
"
M9
.
05
4
.
634l
-
2
.
144
.
003
-
.
116
.
116v1
.
445l
.
92
.
965
.
492
.
034
.
116
-
.
116v
-
.
617L9
.
13
5
.
7l
.
035
-
.
95M12
.
482
10
.
38l
-
1
.
505
-
1
.
462H9
.
362l
-
.
564
.
516
-
.
034
1
.
108
.
72
.
768
1
.
323
.
034
-
.
117
-
.
116v1
.
2l
.
972
1
.
02
.
315
.
034
.
116
-
.
116v
-
1
.
154l
.
422
-
.
374
.
034
-
.
927
-
.
117
.
117h
.
26l
.
408
-
.
36V10
.
5l
-
.
125
-
.
124
-
.
575
-
.
033
\
"
>
<
/
path
>
<
path
d
=
\
"
M8
.
47
15
.
073c
-
3
.
088
0
-
5
.
6
-
2
.
513
-
5
.
6
-
5
.
602V9
.
4v
-
.
003c0
-
.
018
0
-
.
018
.
002
-
.
034l
.
182
-
.
088
.
724
.
587
.
49
.
033
.
497
.
543
-
.
034
.
9
.
317
.
383h
.
47l
.
114
.
096
-
.
032
1
.
9
.
524
.
553h
.
105l
.
025
-
.
338
1
.
004
-
.
95
.
054
-
.
474
.
53
-
.
462v
-
.
888l
-
.
588
-
.
038
-
1
.
118
-
1
.
155H4
.
48l
-
.
154
-
.
09V9
.
01l
.
155
-
.
1h1
.
164v
-
.
273l
.
12
-
.
115
.
7
.
033
.
494
-
.
443
.
034
-
.
746
-
.
624
-
.
655h
-
.
724v
.
28l
-
.
11
.
07H4
.
64l
-
.
114
-
.
09
.
025
-
.
64
.
48
-
.
43v
-
.
244h
-
.
382c
-
.
102
0
-
.
152
-
.
128
-
.
08
-
.
2
1
.
04
-
1
.
01
2
.
428
-
1
.
59
3
.
903
-
1
.
59
1
.
374
0
2
.
672
.
5
3
.
688
1
.
39
.
08
.
068
.
03
.
198
-
.
075
.
198l
-
1
.
144
-
.
034
-
.
81
.
803
.
52
.
523v
.
16l
-
.
382
.
388h
-
.
158l
-
.
176
-
.
177v
-
.
16l
.
076
-
.
074
-
.
252
-
.
252
-
.
37
.
362
.
53
.
53c
.
072
.
072
.
005
.
194
-
.
096
.
194l
-
.
752
-
.
005v
.
844h
.
783L9
.
885
8l
.
16
-
.
143h
.
16l
.
62
.
61v
.
267l
.
58
.
027
.
003
.
002V8
.
76l
.
18
-
.
03
1
.
234
1
.
24
.
753
-
.
708h
.
382l
.
116
.
108c0
.
02
.
003
.
016
.
003
.
036v
.
065c0
3
.
09
-
2
.
515
5
.
603
-
5
.
605
5
.
603M8
.
47
3C4
.
904
3
2
5
.
903
2
9
.
47c0
3
.
57
2
.
903
6
.
472
6
.
47
6
.
472
3
.
57
0
6
.
472
-
2
.
903
6
.
472
-
6
.
47C14
.
942
5
.
9
12
.
04
3
8
.
472
3
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
path
d
=
\
"
M4
2v12h9V4
.
775L9
.
888
2H4zm0
-
1h5
.
888c
.
246
0
.
483
.
09
.
666
.
254l3
.
112
2
.
774c
.
212
.
19
.
334
.
462
.
334
.
747V14c0
.
552
-
.
448
1
-
1
1H4c
-
.
552
0
-
1
-
.
448
-
1
-
1V2c0
-
.
552
.
448
-
1
1
-
1z
\
"
>
<
/
path
>
<
path
d
=
\
"
M9
1
.
5v4c0
.
325
.
306
.
564
.
62
.
485l4
-
1c
.
27
-
.
067
.
432
-
.
338
.
365
-
.
606
-
.
067
-
.
27
-
.
338
-
.
432
-
.
606
-
.
365l
-
4
1L10
5
.
5v
-
4c0
-
.
276
-
.
224
-
.
5
-
.
5
-
.
5s
-
.
5
.
224
-
.
5
.
5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E5
\
"
>
<
path
d
=
\
"
M2
5
.
193v7
.
652c0
.
003
-
.
002
0
.
007
0H14v
-
7
.
69c0
-
.
003
.
002
0
-
.
007
0h
-
7
.
53v
-
2
.
15c0
-
.
002
-
.
004
-
.
005
-
.
01
-
.
005H2
.
01C2
3
2
3
2
3
.
005V5
.
193zm
-
1
0V3
.
005C1
2
.
45
1
.
444
2
2
.
01
2h4
.
442c
.
558
0
1
.
01
.
45
1
.
01
1
.
005v1
.
15h6
.
53c
.
557
0
1
.
008
.
44
1
.
008
1v7
.
69c0
.
553
-
.
45
1
-
1
.
007
1H2
.
007c
-
.
556
0
-
1
.
007
-
.
44
-
1
.
007
-
1V5
.
193zM6
.
08
4
.
15H2v1h4
.
46v
-
1h
-
.
38z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
14
6
13
12
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
g
id
=
\
"
world
\
"
stroke
=
\
"
none
\
"
stroke
-
width
=
\
"
1
\
"
fill
=
\
"
none
\
"
fill
-
rule
=
\
"
evenodd
\
"
transform
=
\
"
translate
(
14
.
000000
6
.
000000
)
\
"
stroke
-
linecap
=
\
"
round
\
"
stroke
-
linejoin
=
\
"
round
\
"
>
<
path
d
=
\
"
M6
.
35076107
0
.
354
C3
.
25095418
0
.
354
0
.
729
2
.
87582735
0
.
729
5
.
9758879
C0
.
729
9
.
07544113
3
.
25082735
11
.
5972685
6
.
35076107
11
.
5972685
C9
.
45044113
11
.
5972685
11
.
9723953
9
.
07544113
11
.
9723953
5
.
97576107
C11
.
9723953
2
.
87582735
9
.
45044113
0
.
354
6
.
35076107
0
.
354
L6
.
35076107
0
.
354
Z
M6
.
35076107
10
.
8289121
C3
.
67445071
10
.
8289121
1
.
49722956
8
.
65181776
1
.
49722956
5
.
97576107
C1
.
49722956
5
.
9443064
1
.
49900522
5
.
91335907
1
.
49976622
5
.
88215806
L2
.
20090094
6
.
4213266
L2
.
56313696
6
.
4213266
L2
.
97268183
6
.
8306178
L2
.
97268183
7
.
68217686
L3
.
32324919
8
.
03287105
L3
.
73926255
8
.
03287105
L3
.
73926255
9
.
79940584
L4
.
27386509
10
.
3361645
L4
.
4591686
10
.
3361645
L4
.
4591686
10
.
000183
L5
.
37655417
9
.
08343163
L5
.
37655417
8
.
73400577
L5
.
85585737
8
.
25203907
L5
.
85585737
7
.
37206934
L5
.
32518666
7
.
37206934
L4
.
28439226
6
.
33140176
L2
.
82225748
6
.
33140176
L2
.
82225748
5
.
56938704
L3
.
96286973
5
.
56938704
L3
.
96286973
5
.
23949352
L4
.
65068695
5
.
23949352
L5
.
11477015
4
.
77667865
L5
.
11477015
4
.
03001076
L4
.
49087694
3
.
40662489
L3
.
75359472
3
.
40662489
L3
.
75359472
3
.
78725175
L2
.
96228149
3
.
78725175
L2
.
96228149
3
.
28385021
L3
.
42217919
2
.
82319151
L3
.
42217919
2
.
49786399
L2
.
97001833
2
.
49786399
C3
.
84466106
1
.
64744643
5
.
03714814
1
.
12222956
6
.
35063424
1
.
12222956
C7
.
57292716
1
.
12222956
8
.
69020207
1
.
57730759
9
.
54442463
2
.
32587797
L8
.
46164839
2
.
32587797
L7
.
680355
3
.
10666403
L8
.
21508437
3
.
64088607
L7
.
87238068
3
.
98257509
L7
.
7165025
3
.
82669692
L7
.
85297518
3
.
68946324
L7
.
78930484
3
.
62566607
L7
.
78943167
3
.
62566607
L7
.
56011699
3
.
39559038
L7
.
55986332
3
.
39571722
L7
.
49758815
3
.
33318838
L7
.
01904595
3
.
78585658
L7
.
55910232
4
.
32654712
L6
.
8069806
4
.
32198112
L6
.
8069806
5
.
25864535
L7
.
66716433
5
.
25864535
L7
.
6723645
4
.
72112565
L7
.
81289584
4
.
57996014
L8
.
31819988
5
.
08653251
L8
.
31819988
5
.
41921636
L9
.
00703176
5
.
41921636
L9
.
03366676
5
.
39321553
L9
.
03430093
5
.
39194719
L10
.
195587
6
.
55259911
L10
.
8637451
5
.
88520206
L11
.
2018828
5
.
88520206
C11
.
2023901
5
.
9153884
11
.
2041658
5
.
94532107
11
.
2041658
5
.
97563424
C11
.
2040389
8
.
65181776
9
.
0269446
10
.
8289121
6
.
35076107
10
.
8289121
L6
.
35076107
10
.
8289121
Z
\
"
id
=
\
"
Shape
\
"
stroke
=
\
"
#
DDE1E5
\
"
stroke
-
width
=
\
"
0
.
25
\
"
fill
=
\
"
#
DDE1E5
\
"
>
<
/
path
>
<
polygon
id
=
\
"
Shape
\
"
stroke
=
\
"
#
DDE1E5
\
"
stroke
-
width
=
\
"
0
.
25
\
"
fill
=
\
"
#
DDE1E5
\
"
points
=
\
"
6
.
50676608
1
.
61523076
4
.
52892694
1
.
61789426
4
.
52892694
2
.
95192735
5
.
34560683
3
.
76733891
5
.
72496536
3
.
76733891
5
.
72496536
3
.
1967157
6
.
50676608
2
.
41592965
\
"
>
<
/
polygon
>
<
polygon
id
=
\
"
Shape
\
"
stroke
=
\
"
#
DDE1E5
\
"
stroke
-
width
=
\
"
0
.
25
\
"
fill
=
\
"
#
DDE1E5
\
"
points
=
\
"
9
.
59959714
6
.
88718547
8
.
28623788
5
.
57268471
8
.
28623788
5
.
57002121
6
.
79607294
5
.
57002121
6
.
35101474
6
.
01469891
6
.
35101474
6
.
96201714
6
.
98429362
7
.
59466185
8
.
12909136
7
.
59466185
8
.
12909136
8
.
70343893
8
.
99434843
9
.
56882283
9
.
20971144
9
.
56882283
9
.
20971144
8
.
50329592
9
.
63029081
8
.
08271655
9
.
63029081
7
.
3026915
9
.
87025949
7
.
3026915
10
.
1711082
7
.
00082814
10
.
0558167
6
.
88718547
\
"
>
<
/
polygon
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
488
384
14
14
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
path
d
=
\
"
M495
.
5
391
.
5
L500
.
200877
396
.
200877
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
#
4A90E2
\
"
stroke
-
width
=
\
"
1
.
25
\
"
stroke
-
linecap
=
\
"
round
\
"
stroke
-
linejoin
=
\
"
round
\
"
fill
=
\
"
none
\
"
>
<
/
path
>
<
ellipse
id
=
\
"
Oval
-
6
\
"
stroke
=
\
"
#
4A90E2
\
"
stroke
-
width
=
\
"
1
.
25
\
"
fill
=
\
"
#
FFFFFF
\
"
fill
-
rule
=
\
"
evenodd
\
"
cx
=
\
"
493
.
5
\
"
cy
=
\
"
389
.
5
\
"
rx
=
\
"
4
.
5
\
"
ry
=
\
"
4
.
5
\
"
>
<
/
ellipse
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M6
.
5
12
.
003l
.
052
-
9a
.
5
.
5
0
1
0
-
1
-
.
006l
-
.
052
9a
.
5
.
5
0
1
0
1
.
006zM13
11
.
997l
-
.
05
-
9a
.
488
.
488
0
0
0
-
.
477
-
.
497
.
488
.
488
0
0
0
-
.
473
.
503l
.
05
9a
.
488
.
488
0
0
0
.
477
.
497
.
488
.
488
0
0
0
.
473
-
.
503z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
975
569
11
11
\
"
version
=
\
"
1
.
1
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
>
<
g
id
=
\
"
Pause
-
circle
\
"
stroke
=
\
"
none
\
"
stroke
-
width
=
\
"
1
\
"
fill
=
\
"
none
\
"
fill
-
rule
=
\
"
evenodd
\
"
transform
=
\
"
translate
(
976
.
000000
570
.
000000
)
\
"
>
<
path
d
=
\
"
M4
.
5
0
.
538639227
C2
.
3152037
0
.
538639227
0
.
538639227
2
.
31614868
0
.
538639227
4
.
5
C0
.
538639227
6
.
6847963
2
.
3152037
8
.
46136077
4
.
5
8
.
46136077
C6
.
6847963
8
.
46136077
8
.
46136077
6
.
6847963
8
.
46136077
4
.
5
C8
.
46136077
2
.
31614868
6
.
6847963
0
.
538639227
4
.
5
0
.
538639227
M4
.
5
9
C2
.
01847963
9
0
6
.
98152037
0
4
.
5
C0
2
.
01847963
2
.
01847963
0
4
.
5
0
C6
.
98152037
0
9
2
.
01847963
9
4
.
5
C9
6
.
98152037
6
.
98152037
9
4
.
5
9
\
"
id
=
\
"
Fill
-
1
-
Copy
\
"
stroke
=
\
"
#
4990E2
\
"
stroke
-
width
=
\
"
0
.
5
\
"
fill
=
\
"
#
4990E2
\
"
>
<
/
path
>
<
path
d
=
\
"
M3
3
L3
6
.
5
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
#
4990E2
\
"
stroke
-
width
=
\
"
1
.
15
\
"
stroke
-
linecap
=
\
"
round
\
"
>
<
/
path
>
<
path
d
=
\
"
M6
3
L6
6
.
5
\
"
id
=
\
"
Line
\
"
stroke
=
\
"
#
4990E2
\
"
stroke
-
width
=
\
"
1
.
15
\
"
stroke
-
linecap
=
\
"
round
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
>
<
path
d
=
\
"
M10
.
483
13
.
995H5
.
517l
-
3
.
512
-
3
.
512V5
.
516l3
.
512
-
3
.
512h4
.
966l3
.
512
3
.
512v4
.
967l
-
3
.
512
3
.
512zm4
.
37
-
9
.
042l
-
3
.
807
-
3
.
805A
.
503
.
503
0
0
0
10
.
691
1H5
.
309a
.
503
.
503
0
0
0
-
.
356
.
148L1
.
147
4
.
953A
.
502
.
502
0
0
0
1
5
.
308v5
.
383c0
.
134
.
053
.
262
.
147
.
356l3
.
806
3
.
806a
.
503
.
503
0
0
0
.
356
.
147h5
.
382a
.
503
.
503
0
0
0
.
355
-
.
147l3
.
806
-
3
.
806A
.
502
.
502
0
0
0
15
10
.
69V5
.
308a
.
502
.
502
0
0
0
-
.
147
-
.
355z
\
"
>
<
/
path
>
<
path
d
=
\
"
M10
10
.
5a
.
5
.
5
0
1
0
1
0v
-
5a
.
5
.
5
0
1
0
-
1
0v5zM5
10
.
5a
.
5
.
5
0
1
0
1
0v
-
5a
.
5
.
5
0
0
0
-
1
0v5z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
path
d
=
\
"
M4
.
525
13
.
21h
-
.
472c
-
.
574
0
-
.
987
-
.
154
-
1
.
24
-
.
463
-
.
253
-
.
31
-
.
38
-
.
882
-
.
38
-
1
.
719v
-
.
573c0
-
.
746
-
.
097
-
1
.
265
-
.
292
-
1
.
557
-
.
196
-
.
293
-
.
51
-
.
44
-
.
945
-
.
44v
-
.
974c
.
435
0
.
75
-
.
146
.
945
-
.
44
.
195
-
.
292
.
293
-
.
811
.
293
-
1
.
556v
-
.
58c0
-
.
833
.
126
-
1
.
404
.
379
-
1
.
712
.
253
-
.
31
.
666
-
.
464
1
.
24
-
.
464h
.
472v
.
783h
-
.
179c
-
.
37
0
-
.
628
.
08
-
.
774
.
24
-
.
145
.
159
-
.
218
.
54
-
.
218
1
.
141v
.
383c0
.
824
-
.
096
1
.
432
-
.
287
1
.
823
-
.
191
.
39
-
.
516
.
679
-
.
974
.
866
.
458
.
191
.
783
.
482
.
974
.
873
.
191
.
39
.
287
.
998
.
287
1
.
823v
.
382c0
.
602
.
073
.
982
.
218
1
.
142
.
146
.
16
.
404
.
239
.
774
.
239h
.
18v
.
783zm9
.
502
-
4
.
752c
-
.
43
0
-
.
744
.
147
-
.
942
.
44
-
.
197
.
292
-
.
296
.
811
-
.
296
1
.
557v
.
573c0
.
837
-
.
125
1
.
41
-
.
376
1
.
719
-
.
251
.
309
-
.
664
.
463
-
1
.
237
.
463h
-
.
478v
-
.
783h
.
185c
.
37
0
.
628
-
.
08
.
774
-
.
24
.
145
-
.
159
.
218
-
.
539
.
218
-
1
.
14v
-
.
383c0
-
.
825
.
096
-
1
.
433
.
287
-
1
.
823
.
191
-
.
39
.
516
-
.
682
.
974
-
.
873
-
.
458
-
.
187
-
.
783
-
.
476
-
.
974
-
.
866
-
.
191
-
.
391
-
.
287
-
.
999
-
.
287
-
1
.
823v
-
.
383c0
-
.
602
-
.
073
-
.
982
-
.
218
-
1
.
142
-
.
146
-
.
159
-
.
404
-
.
239
-
.
774
-
.
239h
-
.
185v
-
.
783h
.
478c
.
573
0
.
986
.
155
1
.
237
.
464
.
25
.
308
.
376
.
88
.
376
1
.
712v
.
58c0
.
673
.
088
1
.
174
.
263
1
.
503
.
176
.
329
.
5
.
493
.
975
.
493v
.
974z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
696969
\
"
>
<
path
d
=
\
"
M6
.
925
12
.
5l7
.
4
-
5
-
7
.
4
-
5v10zM6
12
.
5v
-
10c0
-
.
785
.
8
-
1
.
264
1
.
415
-
.
848l7
.
4
5c
.
58
.
392
.
58
1
.
304
0
1
.
696l
-
7
.
4
5C6
.
8
13
.
764
6
13
.
285
6
12
.
5z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
xmlns
:
xlink
=
\
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xlink
\
"
viewBox
=
\
"
0
0
33
12
\
"
>
<
path
id
=
\
"
base
-
path
\
"
d
=
\
"
M27
.
1
0H1C0
.
4
0
0
0
.
4
0
1v10c0
0
.
6
0
.
4
1
1
1h26
.
1
c0
.
6
0
1
.
2
-
0
.
3
1
.
5
-
0
.
7L33
6l
-
4
.
4
-
5
.
3C28
.
2
0
.
3
27
.
7
0
27
.
1
0z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M1
.
5
14
.
042h4
.
095a
.
5
.
5
0
0
0
0
-
1H1
.
5a
.
5
.
5
0
1
0
0
1zM7
.
983
2a
.
5
.
5
0
0
1
.
517
.
5v7
.
483l3
.
136
-
3
.
326a
.
5
.
5
0
1
1
.
728
.
686l
-
4
4
.
243a
.
499
.
499
0
0
1
-
.
73
-
.
004L3
.
635
7
.
343a
.
5
.
5
0
0
1
.
728
-
.
686L7
.
5
9
.
983V3H1
.
536C1
.
24
3
1
2
.
776
1
2
.
5s
.
24
-
.
5
.
536
-
.
5h6
.
447zM10
.
5
14
.
042h4
.
095a
.
5
.
5
0
0
0
0
-
1H10
.
5a
.
5
.
5
0
1
0
0
1z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M5
13
.
5H1a
.
5
.
5
0
1
0
0
1h4a
.
5
.
5
0
1
0
0
-
1zM12
13
.
5H8a
.
5
.
5
0
1
0
0
1h4a
.
5
.
5
0
1
0
0
-
1zM6
.
11
5
.
012A
.
427
.
427
0
0
1
6
.
21
5h7
.
083L9
.
646
1
.
354a
.
5
.
5
0
1
1
.
708
-
.
708l4
.
5
4
.
5a
.
498
.
498
0
0
1
0
.
708l
-
4
.
5
4
.
5a
.
5
.
5
0
0
1
-
.
708
-
.
708L13
.
293
6H6
.
5v5
.
5a
.
5
.
5
0
1
1
-
1
0v
-
6a
.
5
.
5
0
0
1
.
61
-
.
488z
\
"
>
<
/
path
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
4A464C
\
"
>
<
g
fill
-
rule
=
\
"
evenodd
\
"
>
<
path
d
=
\
"
M13
.
297
6
.
912C12
.
595
4
.
39
10
.
167
2
.
5
7
.
398
2
.
5A5
.
898
5
.
898
0
0
0
1
.
5
8
.
398a
.
5
.
5
0
0
0
1
0A4
.
898
4
.
898
0
0
1
7
.
398
3
.
5c2
.
75
0
5
.
102
2
.
236
5
.
102
4
.
898v
.
004L8
.
669
7
.
029a
.
5
.
5
0
0
0
-
.
338
.
942l4
.
462
1
.
598a
.
5
.
5
0
0
0
.
651
-
.
34
.
506
.
506
0
0
0
.
02
-
.
043l2
-
5a
.
5
.
5
0
1
0
-
.
928
-
.
372l
-
1
.
24
3
.
098z
\
"
>
<
/
path
>
<
circle
cx
=
\
"
7
\
"
cy
=
\
"
12
\
"
r
=
\
"
1
\
"
>
<
/
circle
>
<
/
g
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
696969
\
"
>
<
path
d
=
\
"
M12
.
219
7c
.
345
0
.
635
.
117
.
869
.
352
.
234
.
234
.
351
.
524
.
351
.
869
0
.
351
-
.
118
.
652
-
.
356
.
903
-
.
238
.
25
-
.
526
.
376
-
.
864
.
376
-
.
332
0
-
.
615
-
.
125
-
.
85
-
.
376a1
.
276
1
.
276
0
0
1
-
.
351
-
.
903A1
.
185
1
.
185
0
0
1
12
.
218
7zM8
.
234
7c
.
345
0
.
635
.
117
.
87
.
352
.
234
.
234
.
351
.
524
.
351
.
869
0
.
351
-
.
119
.
652
-
.
356
.
903
-
.
238
.
25
-
.
526
.
376
-
.
865
.
376
-
.
332
0
-
.
613
-
.
125
-
.
844
-
.
376a1
.
286
1
.
286
0
0
1
-
.
347
-
.
903c0
-
.
352
.
114
-
.
643
.
342
-
.
874
.
228
-
.
231
.
51
-
.
347
.
85
-
.
347zM4
.
201
7c
.
339
0
.
627
.
117
.
864
.
352
.
238
.
234
.
357
.
524
.
357
.
869
0
.
351
-
.
119
.
652
-
.
357
.
903
-
.
237
.
25
-
.
525
.
376
-
.
864
.
376
-
.
338
0
-
.
623
-
.
125
-
.
854
-
.
376A1
.
286
1
.
286
0
0
1
3
8
.
221
1
.
185
1
.
185
0
0
1
4
.
201
7z
\
"
fill
-
rule
=
\
"
evenodd
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
module
.
exports
=
"
<
!
-
-
This
Source
Code
Form
is
subject
to
the
terms
of
the
Mozilla
Public
-
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
was
not
distributed
with
this
-
file
You
can
obtain
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
-
-
>
<
svg
viewBox
=
\
"
0
0
16
16
\
"
xmlns
=
\
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
\
"
fill
=
\
"
#
DDE1E4
\
"
>
<
path
fill
-
rule
=
\
"
evenodd
\
"
d
=
\
"
M8
.
5
8
.
793L5
.
854
6
.
146l
-
.
04
-
.
035L7
.
5
4
.
426c
.
2
-
.
2
.
3
-
.
4
.
3
-
.
6
0
-
.
2
-
.
1
-
.
4
-
.
2
-
.
6l
-
1
-
1c
-
.
4
-
.
3
-
.
9
-
.
3
-
1
.
2
0l
-
4
.
1
4
.
1c
-
.
2
.
2
-
.
3
.
4
-
.
3
.
6
0
.
2
.
1
.
4
.
2
.
6l1
1c
.
3
.
3
.
9
.
3
1
.
2
0l1
.
71
-
1
.
71
.
036
.
04L7
.
793
9
.
5l
-
3
.
647
3
.
646c
-
.
195
.
196
-
.
195
.
512
0
.
708
.
196
.
195
.
512
.
195
.
708
0L8
.
5
10
.
207l3
.
646
3
.
647c
.
196
.
195
.
512
.
195
.
708
0
.
195
-
.
196
.
195
-
.
512
0
-
.
708L9
.
207
9
.
5l2
.
565
-
2
.
565L13
.
3
8
.
5c
.
1
.
1
2
.
3
1
.
1
2
.
7
.
7
.
4
-
.
4
-
.
3
-
2
.
7
-
.
5
-
2
.
9l
-
1
.
1
-
1
.
1c
.
1
-
.
1
.
2
-
.
4
.
2
-
.
6
0
-
.
2
-
.
1
-
.
4
-
.
2
-
.
6l
-
.
4
-
.
4c
-
.
3
-
.
3
-
.
8
-
.
3
-
1
.
1
0l
-
1
.
5
-
1
.
4c
-
.
2
-
.
2
-
.
3
-
.
2
-
.
5
-
.
2s
-
.
3
.
1
-
.
5
.
2L9
.
2
3
.
4c
-
.
2
.
1
-
.
2
.
2
-
.
2
.
4s
.
1
.
4
.
2
.
5l1
.
874
1
.
92L8
.
5
8
.
792z
\
"
>
<
/
path
>
<
/
svg
>
"
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
ReactDOM
=
__webpack_require__
(
25
)
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
SourceEditor
=
__webpack_require__
(
263
)
;
var
_require3
=
__webpack_require__
(
45
)
;
var
debugGlobal
=
_require3
.
debugGlobal
;
var
_require4
=
__webpack_require__
(
199
)
;
var
getSourceText
=
_require4
.
getSourceText
;
var
getBreakpointsForSource
=
_require4
.
getBreakpointsForSource
;
var
getSelectedLocation
=
_require4
.
getSelectedLocation
;
var
getSelectedFrame
=
_require4
.
getSelectedFrame
;
var
_require5
=
__webpack_require__
(
195
)
;
var
makeLocationId
=
_require5
.
makeLocationId
;
var
actions
=
__webpack_require__
(
214
)
;
var
Breakpoint
=
React
.
createFactory
(
__webpack_require__
(
264
)
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
__webpack_require__
(
265
)
;
function
isTextForSource
(
sourceText
)
{
return
!
sourceText
.
get
(
"
loading
"
)
&
&
!
sourceText
.
get
(
"
error
"
)
;
}
function
resizeBreakpointGutter
(
editor
)
{
var
gutters
=
editor
.
display
.
gutters
;
var
lineNumbers
=
gutters
.
querySelector
(
"
.
CodeMirror
-
linenumbers
"
)
;
var
breakpoints
=
gutters
.
querySelector
(
"
.
breakpoints
"
)
;
breakpoints
.
style
.
width
=
lineNumbers
.
clientWidth
+
"
px
"
;
}
var
Editor
=
React
.
createClass
(
{
propTypes
:
{
breakpoints
:
ImPropTypes
.
map
.
isRequired
selectedLocation
:
PropTypes
.
object
sourceText
:
PropTypes
.
object
addBreakpoint
:
PropTypes
.
func
removeBreakpoint
:
PropTypes
.
func
selectedFrame
:
PropTypes
.
object
}
displayName
:
"
Editor
"
onGutterClick
(
cm
line
gutter
ev
)
{
var
bp
=
this
.
props
.
breakpoints
.
find
(
b
=
>
{
return
b
.
location
.
line
=
=
=
line
+
1
;
}
)
;
if
(
bp
&
&
bp
.
loading
)
{
return
;
}
if
(
bp
)
{
this
.
props
.
removeBreakpoint
(
{
sourceId
:
this
.
props
.
selectedLocation
.
sourceId
line
:
line
+
1
}
)
;
}
else
{
this
.
props
.
addBreakpoint
(
{
sourceId
:
this
.
props
.
selectedLocation
.
sourceId
line
:
line
+
1
}
{
getTextForLine
:
l
=
>
cm
.
getLine
(
l
-
1
)
.
trim
(
)
}
)
;
}
}
updateDebugLine
(
prevProps
nextProps
)
{
if
(
prevProps
.
selectedFrame
)
{
var
line
=
prevProps
.
selectedFrame
.
location
.
line
;
this
.
editor
.
codeMirror
.
removeLineClass
(
line
-
1
"
line
"
"
debug
-
line
"
)
;
}
if
(
nextProps
.
selectedFrame
)
{
var
_line
=
nextProps
.
selectedFrame
.
location
.
line
;
this
.
editor
.
codeMirror
.
addLineClass
(
_line
-
1
"
line
"
"
debug
-
line
"
)
;
}
}
highlightLine
(
)
{
if
(
!
this
.
pendingJumpLine
)
{
return
;
}
var
codeMirror
=
this
.
editor
.
codeMirror
;
if
(
this
.
lastJumpLine
)
{
codeMirror
.
removeLineClass
(
this
.
lastJumpLine
-
1
"
line
"
"
highlight
-
line
"
)
;
}
var
line
=
this
.
pendingJumpLine
;
this
.
editor
.
alignLine
(
line
)
;
if
(
!
this
.
props
.
selectedFrame
|
|
this
.
props
.
selectedFrame
.
location
.
line
!
=
=
line
)
{
this
.
editor
.
codeMirror
.
addLineClass
(
line
-
1
"
line
"
"
highlight
-
line
"
)
;
}
this
.
lastJumpLine
=
line
;
this
.
pendingJumpLine
=
null
;
}
setText
(
text
)
{
if
(
!
text
|
|
!
this
.
editor
)
{
return
;
}
this
.
editor
.
setText
(
text
)
;
}
setMode
(
sourceText
)
{
var
contentType
=
sourceText
.
get
(
"
contentType
"
)
;
if
(
contentType
.
includes
(
"
javascript
"
)
)
{
this
.
editor
.
setMode
(
{
name
:
"
javascript
"
}
)
;
}
else
if
(
contentType
=
=
=
"
text
/
wasm
"
)
{
this
.
editor
.
setMode
(
{
name
:
"
wasm
"
}
)
;
}
else
if
(
sourceText
.
get
(
"
text
"
)
.
match
(
/
^
\
s
*
<
/
)
)
{
this
.
editor
.
setMode
(
{
name
:
"
htmlmixed
"
}
)
;
}
else
{
this
.
editor
.
setMode
(
{
name
:
"
text
"
}
)
;
}
}
componentDidMount
(
)
{
this
.
editor
=
new
SourceEditor
(
{
mode
:
"
javascript
"
readOnly
:
true
lineNumbers
:
true
theme
:
"
mozilla
"
lineWrapping
:
false
matchBrackets
:
true
showAnnotationRuler
:
true
enableCodeFolding
:
false
gutters
:
[
"
breakpoints
"
]
value
:
"
"
}
)
;
this
.
editor
.
appendToLocalElement
(
ReactDOM
.
findDOMNode
(
this
)
.
querySelector
(
"
.
editor
-
mount
"
)
)
;
this
.
editor
.
codeMirror
.
on
(
"
gutterClick
"
this
.
onGutterClick
)
;
resizeBreakpointGutter
(
this
.
editor
.
codeMirror
)
;
debugGlobal
(
"
cm
"
this
.
editor
.
codeMirror
)
;
if
(
this
.
props
.
sourceText
)
{
this
.
setText
(
this
.
props
.
sourceText
.
get
(
"
text
"
)
)
;
}
}
componentWillUnmount
(
)
{
this
.
editor
.
destroy
(
)
;
this
.
editor
=
null
;
}
componentWillReceiveProps
(
nextProps
)
{
var
sourceText
=
nextProps
.
sourceText
;
if
(
!
sourceText
)
{
this
.
setText
(
"
"
)
;
this
.
editor
.
setMode
(
{
name
:
"
text
"
}
)
;
}
else
if
(
!
isTextForSource
(
sourceText
)
)
{
this
.
setText
(
sourceText
.
get
(
"
error
"
)
|
|
"
Loading
.
.
.
"
)
;
this
.
editor
.
setMode
(
{
name
:
"
text
"
}
)
;
}
else
if
(
this
.
props
.
sourceText
!
=
=
sourceText
)
{
this
.
setText
(
sourceText
.
get
(
"
text
"
)
)
;
this
.
setMode
(
sourceText
)
;
resizeBreakpointGutter
(
this
.
editor
.
codeMirror
)
;
}
}
componentDidUpdate
(
prevProps
)
{
var
selectedLocation
=
this
.
props
.
selectedLocation
;
if
(
prevProps
.
selectedLocation
!
=
=
selectedLocation
)
{
if
(
selectedLocation
&
&
selectedLocation
.
line
!
=
undefined
)
{
this
.
pendingJumpLine
=
selectedLocation
.
line
;
}
else
{
this
.
pendingJumpLine
=
null
;
}
}
if
(
this
.
props
.
sourceText
&
&
isTextForSource
(
this
.
props
.
sourceText
)
)
{
this
.
updateDebugLine
(
prevProps
this
.
props
)
;
this
.
highlightLine
(
)
;
}
}
render
(
)
{
var
_props
=
this
.
props
;
var
breakpoints
=
_props
.
breakpoints
;
var
sourceText
=
_props
.
sourceText
;
var
isLoading
=
sourceText
&
&
sourceText
.
get
(
"
loading
"
)
;
return
dom
.
div
(
{
className
:
"
editor
-
wrapper
devtools
-
monospace
"
}
dom
.
div
(
{
className
:
"
editor
-
mount
"
}
)
!
isLoading
&
&
breakpoints
.
valueSeq
(
)
.
map
(
bp
=
>
{
return
Breakpoint
(
{
key
:
makeLocationId
(
bp
.
location
)
breakpoint
:
bp
editor
:
this
.
editor
&
&
this
.
editor
.
codeMirror
}
)
;
}
)
)
;
}
}
)
;
module
.
exports
=
connect
(
(
state
props
)
=
>
{
var
selectedLocation
=
getSelectedLocation
(
state
)
;
var
sourceId
=
selectedLocation
&
&
selectedLocation
.
sourceId
;
return
{
selectedLocation
sourceText
:
getSourceText
(
state
sourceId
)
breakpoints
:
getBreakpointsForSource
(
state
sourceId
)
selectedFrame
:
getSelectedFrame
(
state
)
}
;
}
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Editor
)
;
}
function
(
module
exports
)
{
module
.
exports
=
devtoolsRequire
(
'
devtools
/
client
/
sourceeditor
/
editor
'
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
PropTypes
=
React
.
PropTypes
;
var
classnames
=
__webpack_require__
(
207
)
;
function
makeMarker
(
isDisabled
)
{
var
marker
=
document
.
createElement
(
"
div
"
)
;
marker
.
className
=
classnames
(
"
editor
new
-
breakpoint
"
{
"
breakpoint
-
disabled
"
:
isDisabled
}
)
;
var
svg
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
"
svg
"
)
;
svg
.
setAttribute
(
"
viewBox
"
"
0
0
60
12
"
)
;
svg
.
setAttribute
(
"
preserveAspectRatio
"
"
none
"
)
;
var
path
=
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
svg
"
"
path
"
)
;
path
.
setAttribute
(
"
d
"
"
M53
.
9
0H1C0
.
4
0
0
0
.
4
0
1v10c0
0
.
6
0
.
4
1
1
1h52
.
9c0
.
6
0
1
.
2
-
0
.
3
1
.
5
-
0
.
7L60
6l
-
4
.
4
-
5
.
3C55
0
.
3
54
.
5
0
53
.
9
0z
"
)
;
svg
.
appendChild
(
path
)
;
marker
.
appendChild
(
svg
)
;
return
marker
;
}
var
Breakpoint
=
React
.
createClass
(
{
propTypes
:
{
breakpoint
:
PropTypes
.
object
editor
:
PropTypes
.
object
}
displayName
:
"
Breakpoint
"
addBreakpoint
(
)
{
var
bp
=
this
.
props
.
breakpoint
;
var
line
=
bp
.
location
.
line
-
1
;
this
.
props
.
editor
.
setGutterMarker
(
line
"
breakpoints
"
makeMarker
(
bp
.
disabled
)
)
;
this
.
props
.
editor
.
addLineClass
(
line
"
line
"
"
new
-
breakpoint
"
)
;
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
editor
!
=
=
nextProps
.
editor
|
|
this
.
props
.
breakpoint
.
disabled
!
=
=
nextProps
.
breakpoint
.
disabled
;
}
componentDidMount
(
)
{
if
(
!
this
.
props
.
editor
)
{
return
;
}
this
.
addBreakpoint
(
)
;
}
componentDidUpdate
(
)
{
this
.
addBreakpoint
(
)
;
}
componentWillUnmount
(
)
{
if
(
!
this
.
props
.
editor
)
{
return
;
}
var
bp
=
this
.
props
.
breakpoint
;
var
line
=
bp
.
location
.
line
-
1
;
this
.
props
.
editor
.
setGutterMarker
(
line
"
breakpoints
"
null
)
;
this
.
props
.
editor
.
removeLineClass
(
line
"
line
"
"
new
-
breakpoint
"
)
;
}
render
(
)
{
return
null
;
}
}
)
;
module
.
exports
=
Breakpoint
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
ReactDOM
=
__webpack_require__
(
25
)
;
var
Draggable
=
React
.
createFactory
(
__webpack_require__
(
268
)
)
;
__webpack_require__
(
269
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
SplitBox
=
React
.
createClass
(
{
propTypes
:
{
left
:
PropTypes
.
any
.
isRequired
right
:
PropTypes
.
any
.
isRequired
initialWidth
:
PropTypes
.
any
rightFlex
:
PropTypes
.
bool
style
:
PropTypes
.
string
}
displayName
:
"
SplitBox
"
getInitialState
(
)
{
return
{
width
:
this
.
props
.
initialWidth
}
;
}
onMove
(
x
)
{
var
node
=
ReactDOM
.
findDOMNode
(
this
)
;
this
.
setState
(
{
width
:
this
.
props
.
rightFlex
?
node
.
offsetLeft
+
node
.
offsetWidth
-
x
:
x
-
node
.
offsetLeft
}
)
;
}
render
(
)
{
var
_props
=
this
.
props
;
var
left
=
_props
.
left
;
var
right
=
_props
.
right
;
var
rightFlex
=
_props
.
rightFlex
;
var
width
=
this
.
state
.
width
;
return
dom
.
div
(
{
className
:
"
split
-
box
"
style
:
this
.
props
.
style
}
dom
.
div
(
{
className
:
rightFlex
?
"
uncontrolled
"
:
"
controlled
"
style
:
{
width
:
rightFlex
?
null
:
width
}
}
left
)
dom
.
div
(
{
className
:
"
splitter
"
}
Draggable
(
{
className
:
"
splitter
-
handle
"
onMove
:
x
=
>
this
.
onMove
(
x
)
}
)
)
dom
.
div
(
{
className
:
rightFlex
?
"
controlled
"
:
"
uncontrolled
"
style
:
{
width
:
rightFlex
?
width
:
null
}
}
right
)
)
;
}
}
)
;
module
.
exports
=
SplitBox
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
ReactDOM
=
__webpack_require__
(
25
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
Draggable
=
React
.
createClass
(
{
propTypes
:
{
onMove
:
PropTypes
.
func
.
isRequired
onStart
:
PropTypes
.
func
onStop
:
PropTypes
.
func
style
:
PropTypes
.
object
className
:
PropTypes
.
string
}
displayName
:
"
Draggable
"
startDragging
(
ev
)
{
ev
.
preventDefault
(
)
;
var
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
addEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
addEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStart
&
&
this
.
props
.
onStart
(
)
;
}
onMove
(
ev
)
{
ev
.
preventDefault
(
)
;
this
.
props
.
onMove
(
ev
.
pageX
ev
.
pageY
)
;
}
onUp
(
ev
)
{
ev
.
preventDefault
(
)
;
var
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
removeEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
removeEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStop
&
&
this
.
props
.
onStop
(
)
;
}
render
(
)
{
return
dom
.
div
(
{
style
:
this
.
props
.
style
className
:
this
.
props
.
className
onMouseDown
:
this
.
startDragging
}
)
;
}
}
)
;
module
.
exports
=
Draggable
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getPause
=
_require3
.
getPause
;
var
getIsWaitingOnBreak
=
_require3
.
getIsWaitingOnBreak
;
var
getBreakpointsDisabled
=
_require3
.
getBreakpointsDisabled
;
var
getShouldPauseOnExceptions
=
_require3
.
getShouldPauseOnExceptions
;
var
getShouldIgnoreCaughtExceptions
=
_require3
.
getShouldIgnoreCaughtExceptions
;
var
getBreakpoints
=
_require3
.
getBreakpoints
;
var
getBreakpointsLoading
=
_require3
.
getBreakpointsLoading
;
var
_require4
=
__webpack_require__
(
46
)
;
var
isEnabled
=
_require4
.
isEnabled
;
var
Svg
=
__webpack_require__
(
235
)
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
_require5
=
__webpack_require__
(
213
)
;
var
Services
=
_require5
.
Services
;
var
shiftKey
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
?
"
\
u21E7
"
:
"
Shift
+
"
;
var
ctrlKey
=
Services
.
appinfo
.
OS
=
=
=
"
Linux
"
?
"
Ctrl
+
"
:
"
"
;
var
actions
=
__webpack_require__
(
214
)
;
var
Breakpoints
=
React
.
createFactory
(
__webpack_require__
(
272
)
)
;
var
Expressions
=
React
.
createFactory
(
__webpack_require__
(
275
)
)
;
var
Scopes
=
React
.
createFactory
(
__webpack_require__
(
308
)
)
;
var
Frames
=
React
.
createFactory
(
__webpack_require__
(
340
)
)
;
var
Accordion
=
React
.
createFactory
(
__webpack_require__
(
343
)
)
;
__webpack_require__
(
346
)
;
function
debugBtn
(
onClick
type
className
tooltip
)
{
className
=
{
type
}
{
className
}
;
return
dom
.
span
(
{
onClick
className
key
:
type
}
Svg
(
type
{
title
:
tooltip
}
)
)
;
}
var
RightSidebar
=
React
.
createClass
(
{
propTypes
:
{
sources
:
PropTypes
.
object
selectedSource
:
PropTypes
.
object
resume
:
PropTypes
.
func
stepIn
:
PropTypes
.
func
stepOut
:
PropTypes
.
func
stepOver
:
PropTypes
.
func
toggleAllBreakpoints
:
PropTypes
.
func
breakOnNext
:
PropTypes
.
func
pause
:
ImPropTypes
.
map
pauseOnExceptions
:
PropTypes
.
func
shouldPauseOnExceptions
:
PropTypes
.
bool
shouldIgnoreCaughtExceptions
:
PropTypes
.
bool
breakpoints
:
ImPropTypes
.
map
isWaitingOnBreak
:
PropTypes
.
bool
breakpointsDisabled
:
PropTypes
.
bool
breakpointsLoading
:
PropTypes
.
bool
keyShortcuts
:
PropTypes
.
object
}
displayName
:
"
RightSidebar
"
resume
(
)
{
if
(
this
.
props
.
pause
)
{
this
.
props
.
resume
(
)
;
}
else
if
(
!
this
.
props
.
isWaitingOnBreak
)
{
this
.
props
.
breakOnNext
(
)
;
}
}
stepOver
(
)
{
if
(
!
this
.
props
.
pause
)
{
return
;
}
this
.
props
.
stepOver
(
)
;
}
stepIn
(
)
{
if
(
!
this
.
props
.
pause
)
{
return
;
}
this
.
props
.
stepIn
(
)
;
}
stepOut
(
)
{
if
(
!
this
.
props
.
pause
)
{
return
;
}
this
.
props
.
stepOut
(
)
;
}
setupKeyboardShortcuts
(
)
{
var
keyShortcuts
=
this
.
props
.
keyShortcuts
;
if
(
this
.
keyShortcutsEnabled
)
{
return
;
}
this
.
keyShortcutsEnabled
=
true
;
keyShortcuts
.
on
(
"
F8
"
this
.
resume
)
;
keyShortcuts
.
on
(
"
F10
"
this
.
stepOver
)
;
keyShortcuts
.
on
(
{
ctrlKey
}
F11
this
.
stepIn
)
;
keyShortcuts
.
on
(
{
ctrlKey
}
Shift
+
F11
this
.
stepOut
)
;
}
componentWillUnmount
(
)
{
var
keyShortcuts
=
this
.
props
.
keyShortcuts
;
keyShortcuts
.
off
(
"
F8
"
this
.
resume
)
;
keyShortcuts
.
off
(
"
F10
"
this
.
stepOver
)
;
keyShortcuts
.
off
(
{
ctrlKey
}
F11
this
.
stepIn
)
;
keyShortcuts
.
off
(
{
ctrlKey
}
Shift
+
F11
this
.
stepOut
)
;
}
componentDidUpdate
(
)
{
this
.
setupKeyboardShortcuts
(
)
;
}
renderStepButtons
(
)
{
var
className
=
this
.
props
.
pause
?
"
active
"
:
"
disabled
"
;
return
[
debugBtn
(
this
.
stepOver
"
stepOver
"
className
"
Step
Over
(
F10
)
"
)
debugBtn
(
this
.
stepIn
"
stepIn
"
className
Step
In
(
{
ctrlKey
}
F11
)
)
debugBtn
(
this
.
stepOut
"
stepOut
"
className
Step
Out
(
{
ctrlKey
}
{
shiftKey
}
F11
)
)
]
;
}
renderPauseButton
(
)
{
var
_props
=
this
.
props
;
var
pause
=
_props
.
pause
;
var
breakOnNext
=
_props
.
breakOnNext
;
var
isWaitingOnBreak
=
_props
.
isWaitingOnBreak
;
if
(
pause
)
{
return
debugBtn
(
this
.
resume
"
resume
"
"
active
"
"
Click
to
resume
(
F8
)
"
)
;
}
if
(
isWaitingOnBreak
)
{
return
debugBtn
(
null
"
pause
"
"
disabled
"
"
Waiting
for
next
execution
"
)
;
}
return
debugBtn
(
breakOnNext
"
pause
"
"
active
"
"
Click
to
pause
(
F8
)
"
)
;
}
renderPauseOnExceptions
(
)
{
var
_props2
=
this
.
props
;
var
shouldPauseOnExceptions
=
_props2
.
shouldPauseOnExceptions
;
var
shouldIgnoreCaughtExceptions
=
_props2
.
shouldIgnoreCaughtExceptions
;
var
pauseOnExceptions
=
_props2
.
pauseOnExceptions
;
function
pauseBtn
(
pause
ignore
tooltip
)
{
return
debugBtn
(
(
)
=
>
pauseOnExceptions
(
pause
ignore
)
"
pause
-
exceptions
"
"
enabled
"
tooltip
)
;
}
if
(
!
shouldPauseOnExceptions
&
&
!
shouldIgnoreCaughtExceptions
)
{
return
pauseBtn
(
true
true
"
Ignore
exceptions
"
)
;
}
if
(
shouldPauseOnExceptions
&
&
shouldIgnoreCaughtExceptions
)
{
return
pauseBtn
(
true
false
"
Pause
on
uncaught
exceptions
"
)
;
}
return
pauseBtn
(
false
false
"
Pause
on
all
exceptions
"
)
;
}
renderDisableBreakpoints
(
)
{
var
_props3
=
this
.
props
;
var
toggleAllBreakpoints
=
_props3
.
toggleAllBreakpoints
;
var
breakpoints
=
_props3
.
breakpoints
;
var
breakpointsDisabled
=
_props3
.
breakpointsDisabled
;
var
breakpointsLoading
=
_props3
.
breakpointsLoading
;
if
(
breakpoints
.
size
=
=
0
|
|
breakpointsLoading
)
{
return
debugBtn
(
null
"
disableBreakpoints
"
"
disabled
"
"
Disable
Breakpoints
"
)
;
}
return
debugBtn
(
(
)
=
>
toggleAllBreakpoints
(
!
breakpointsDisabled
)
"
disableBreakpoints
"
breakpointsDisabled
?
"
breakpoints
-
disabled
"
:
"
"
"
Disable
Breakpoints
"
)
;
}
getItems
(
)
{
var
items
=
[
{
header
:
"
Breakpoints
"
component
:
Breakpoints
opened
:
true
}
{
header
:
"
Call
Stack
"
component
:
Frames
}
{
header
:
"
Scopes
"
component
:
Scopes
}
]
;
if
(
isEnabled
(
"
watchExpressions
"
)
)
{
items
.
unshift
(
{
header
:
"
Watch
Expressions
"
component
:
Expressions
opened
:
true
}
)
;
}
return
items
;
}
render
(
)
{
return
dom
.
div
(
{
className
:
"
right
-
sidebar
"
style
:
{
overflowX
:
"
hidden
"
}
}
dom
.
div
(
{
className
:
"
command
-
bar
"
}
this
.
renderPauseButton
(
)
this
.
renderStepButtons
(
)
this
.
renderDisableBreakpoints
(
)
this
.
renderPauseOnExceptions
(
)
)
Accordion
(
{
items
:
this
.
getItems
(
)
}
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
{
return
{
pause
:
getPause
(
state
)
isWaitingOnBreak
:
getIsWaitingOnBreak
(
state
)
shouldPauseOnExceptions
:
getShouldPauseOnExceptions
(
state
)
shouldIgnoreCaughtExceptions
:
getShouldIgnoreCaughtExceptions
(
state
)
breakpointsDisabled
:
getBreakpointsDisabled
(
state
)
breakpoints
:
getBreakpoints
(
state
)
breakpointsLoading
:
getBreakpointsLoading
(
state
)
}
;
}
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
RightSidebar
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
classnames
=
__webpack_require__
(
207
)
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getSource
=
_require3
.
getSource
;
var
getPause
=
_require3
.
getPause
;
var
getBreakpoints
=
_require3
.
getBreakpoints
;
var
_require4
=
__webpack_require__
(
195
)
;
var
makeLocationId
=
_require4
.
makeLocationId
;
var
_require5
=
__webpack_require__
(
176
)
;
var
truncateStr
=
_require5
.
truncateStr
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
_require6
=
__webpack_require__
(
176
)
;
var
endTruncateStr
=
_require6
.
endTruncateStr
;
var
_require7
=
__webpack_require__
(
205
)
;
var
basename
=
_require7
.
basename
;
__webpack_require__
(
273
)
;
function
isCurrentlyPausedAtBreakpoint
(
state
breakpoint
)
{
var
pause
=
getPause
(
state
)
;
if
(
!
pause
|
|
pause
.
get
(
"
isInterrupted
"
)
)
{
return
false
;
}
var
bpId
=
makeLocationId
(
breakpoint
.
location
)
;
var
pausedId
=
makeLocationId
(
pause
.
getIn
(
[
"
frame
"
"
location
"
]
)
.
toJS
(
)
)
;
return
bpId
=
=
=
pausedId
;
}
function
renderSourceLocation
(
source
line
)
{
var
url
=
basename
(
source
.
get
(
"
url
"
)
)
;
return
url
!
=
=
"
"
?
dom
.
div
(
{
className
:
"
location
"
}
{
endTruncateStr
(
url
30
)
}
:
{
line
}
)
:
null
;
}
var
Breakpoints
=
React
.
createClass
(
{
propTypes
:
{
breakpoints
:
ImPropTypes
.
map
.
isRequired
enableBreakpoint
:
PropTypes
.
func
.
isRequired
disableBreakpoint
:
PropTypes
.
func
.
isRequired
selectSource
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
Breakpoints
"
handleCheckbox
(
breakpoint
)
{
if
(
breakpoint
.
loading
)
{
return
;
}
if
(
breakpoint
.
disabled
)
{
this
.
props
.
enableBreakpoint
(
breakpoint
.
location
)
;
}
else
{
this
.
props
.
disableBreakpoint
(
breakpoint
.
location
)
;
}
}
selectBreakpoint
(
breakpoint
)
{
var
sourceId
=
breakpoint
.
location
.
sourceId
;
var
line
=
breakpoint
.
location
.
line
;
this
.
props
.
selectSource
(
sourceId
{
line
}
)
;
}
renderBreakpoint
(
breakpoint
)
{
var
snippet
=
truncateStr
(
breakpoint
.
text
|
|
"
"
30
)
;
var
locationId
=
breakpoint
.
locationId
;
var
line
=
breakpoint
.
location
.
line
;
var
isCurrentlyPaused
=
breakpoint
.
isCurrentlyPaused
;
var
isDisabled
=
breakpoint
.
disabled
;
return
dom
.
div
(
{
className
:
classnames
(
{
breakpoint
paused
:
isCurrentlyPaused
disabled
:
isDisabled
}
)
key
:
locationId
onClick
:
(
)
=
>
this
.
selectBreakpoint
(
breakpoint
)
}
dom
.
input
(
{
type
:
"
checkbox
"
checked
:
!
isDisabled
onChange
:
(
)
=
>
this
.
handleCheckbox
(
breakpoint
)
}
)
dom
.
div
(
{
className
:
"
breakpoint
-
label
"
title
:
breakpoint
.
text
}
dom
.
div
(
{
}
renderSourceLocation
(
breakpoint
.
location
.
source
line
)
)
)
dom
.
div
(
{
className
:
"
breakpoint
-
snippet
"
}
snippet
)
)
;
}
render
(
)
{
var
breakpoints
=
this
.
props
.
breakpoints
;
return
dom
.
div
(
{
className
:
"
pane
breakpoints
-
list
"
}
breakpoints
.
size
=
=
=
0
?
dom
.
div
(
{
className
:
"
pane
-
info
"
}
"
No
Breakpoints
"
)
:
breakpoints
.
valueSeq
(
)
.
map
(
bp
=
>
{
return
this
.
renderBreakpoint
(
bp
)
;
}
)
)
;
}
}
)
;
function
_getBreakpoints
(
state
)
{
return
getBreakpoints
(
state
)
.
map
(
bp
=
>
{
var
source
=
getSource
(
state
bp
.
location
.
sourceId
)
;
var
isCurrentlyPaused
=
isCurrentlyPausedAtBreakpoint
(
state
bp
)
;
var
locationId
=
makeLocationId
(
bp
.
location
)
;
bp
=
Object
.
assign
(
{
}
bp
)
;
bp
.
location
.
source
=
source
;
bp
.
locationId
=
locationId
;
bp
.
isCurrentlyPaused
=
isCurrentlyPaused
;
return
bp
;
}
)
.
filter
(
bp
=
>
bp
.
location
.
source
)
;
}
module
.
exports
=
connect
(
(
state
props
)
=
>
(
{
breakpoints
:
_getBreakpoints
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Breakpoints
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
Svg
=
__webpack_require__
(
235
)
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getExpressions
=
_require3
.
getExpressions
;
var
getPause
=
_require3
.
getPause
;
var
Rep
=
React
.
createFactory
(
__webpack_require__
(
276
)
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
__webpack_require__
(
306
)
;
var
Expressions
=
React
.
createClass
(
{
propTypes
:
{
expressions
:
ImPropTypes
.
list
addExpression
:
PropTypes
.
func
updateExpression
:
PropTypes
.
func
deleteExpression
:
PropTypes
.
func
}
displayName
:
"
Expressions
"
inputKeyPress
(
e
_ref
)
{
var
id
=
_ref
.
id
;
if
(
e
.
key
!
=
=
"
Enter
"
)
{
return
;
}
var
addExpression
=
this
.
props
.
addExpression
;
var
expression
=
{
input
:
e
.
target
.
value
}
;
if
(
id
!
=
=
undefined
)
{
expression
.
id
=
id
;
}
e
.
target
.
value
=
"
"
;
addExpression
(
expression
)
;
}
updateExpression
(
e
_ref2
)
{
var
id
=
_ref2
.
id
;
e
.
stopPropagation
(
)
;
var
updateExpression
=
this
.
props
.
updateExpression
;
var
expression
=
{
id
input
:
e
.
target
.
textContent
}
;
updateExpression
(
expression
)
;
}
renderExpressionValue
(
value
)
{
if
(
!
value
)
{
return
;
}
if
(
value
.
exception
)
{
return
Rep
(
{
object
:
value
.
exception
}
)
;
}
return
Rep
(
{
object
:
value
.
result
}
)
;
}
deleteExpression
(
e
expression
)
{
e
.
stopPropagation
(
)
;
var
deleteExpression
=
this
.
props
.
deleteExpression
;
deleteExpression
(
expression
)
;
}
renderExpressionUpdating
(
expression
)
{
return
dom
.
span
(
{
className
:
"
expression
-
input
-
container
"
}
dom
.
input
(
{
type
:
"
text
"
className
:
"
input
-
expression
"
onKeyPress
:
e
=
>
this
.
inputKeyPress
(
e
expression
)
defaultValue
:
expression
.
input
ref
:
c
=
>
{
this
.
_input
=
c
;
}
}
)
)
;
}
renderExpression
(
expression
)
{
return
dom
.
span
(
{
className
:
"
expression
-
output
-
container
"
key
:
expression
.
id
}
dom
.
span
(
{
className
:
"
expression
-
input
"
onClick
:
e
=
>
this
.
updateExpression
(
e
expression
)
}
expression
.
input
)
dom
.
span
(
{
className
:
"
expression
-
seperator
"
}
"
:
"
)
dom
.
span
(
{
className
:
"
expression
-
value
"
}
this
.
renderExpressionValue
(
expression
.
value
)
)
dom
.
span
(
{
className
:
"
close
-
btn
"
onClick
:
e
=
>
this
.
deleteExpression
(
e
expression
)
}
Svg
(
"
close
"
)
)
)
;
}
renderExpressionContainer
(
expression
)
{
return
dom
.
div
(
{
className
:
"
expression
-
container
"
key
:
expression
.
id
+
expression
.
input
}
expression
.
updating
?
this
.
renderExpressionUpdating
(
expression
)
:
this
.
renderExpression
(
expression
)
)
;
}
componentDidUpdate
(
)
{
if
(
this
.
_input
)
{
this
.
_input
.
focus
(
)
;
}
}
render
(
)
{
var
expressions
=
this
.
props
.
expressions
;
return
dom
.
span
(
{
className
:
"
pane
expressions
-
list
"
}
dom
.
input
(
{
type
:
"
text
"
className
:
"
input
-
expression
"
placeholder
:
"
Add
watch
Expression
"
onKeyPress
:
e
=
>
this
.
inputKeyPress
(
e
{
}
)
}
)
expressions
.
toSeq
(
)
.
map
(
expression
=
>
this
.
renderExpressionContainer
(
expression
)
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
pauseInfo
:
getPause
(
state
)
expressions
:
getExpressions
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Expressions
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
Rep
=
React
.
createFactory
(
__webpack_require__
(
277
)
.
Rep
)
;
var
Grip
=
__webpack_require__
(
303
)
.
Grip
;
__webpack_require__
(
304
)
;
function
renderRep
(
_ref
)
{
var
object
=
_ref
.
object
;
var
mode
=
_ref
.
mode
;
return
Rep
(
{
object
defaultRep
:
Grip
mode
}
)
;
}
module
.
exports
=
renderRep
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
Undefined
}
=
__webpack_require__
(
279
)
;
const
{
Null
}
=
__webpack_require__
(
281
)
;
const
{
StringRep
}
=
__webpack_require__
(
282
)
;
const
{
Number
}
=
__webpack_require__
(
283
)
;
const
{
ArrayRep
}
=
__webpack_require__
(
284
)
;
const
{
Obj
}
=
__webpack_require__
(
286
)
;
const
{
Attribute
}
=
__webpack_require__
(
288
)
;
const
{
DateTime
}
=
__webpack_require__
(
290
)
;
const
{
Document
}
=
__webpack_require__
(
291
)
;
const
{
Event
}
=
__webpack_require__
(
293
)
;
const
{
Func
}
=
__webpack_require__
(
294
)
;
const
{
NamedNodeMap
}
=
__webpack_require__
(
295
)
;
const
{
RegExp
}
=
__webpack_require__
(
296
)
;
const
{
StyleSheet
}
=
__webpack_require__
(
297
)
;
const
{
TextNode
}
=
__webpack_require__
(
298
)
;
const
{
Window
}
=
__webpack_require__
(
299
)
;
const
{
ObjectWithText
}
=
__webpack_require__
(
300
)
;
const
{
ObjectWithURL
}
=
__webpack_require__
(
301
)
;
const
{
GripArray
}
=
__webpack_require__
(
302
)
;
const
{
Grip
}
=
__webpack_require__
(
303
)
;
let
reps
=
[
RegExp
StyleSheet
Event
DateTime
TextNode
NamedNodeMap
Attribute
Func
ArrayRep
Document
Window
ObjectWithText
ObjectWithURL
GripArray
Grip
Undefined
Null
StringRep
Number
]
;
const
Rep
=
React
.
createClass
(
{
displayName
:
"
Rep
"
propTypes
:
{
object
:
React
.
PropTypes
.
any
defaultRep
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
string
}
render
:
function
(
)
{
let
rep
=
getRep
(
this
.
props
.
object
this
.
props
.
defaultRep
)
;
return
rep
(
this
.
props
)
;
}
}
)
;
function
getRep
(
object
defaultRep
=
Obj
)
{
let
type
=
typeof
object
;
if
(
type
=
=
"
object
"
&
&
object
instanceof
String
)
{
type
=
"
string
"
;
}
if
(
isGrip
(
object
)
)
{
type
=
object
.
class
;
}
for
(
let
i
=
0
;
i
<
reps
.
length
;
i
+
+
)
{
let
rep
=
reps
[
i
]
;
try
{
if
(
rep
.
supportsObject
(
object
type
)
)
{
return
React
.
createFactory
(
rep
.
rep
)
;
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
}
return
React
.
createFactory
(
defaultRep
.
rep
)
;
}
exports
.
Rep
=
Rep
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
function
createFactories
(
args
)
{
let
result
=
{
}
;
for
(
let
p
in
args
)
{
result
[
p
]
=
React
.
createFactory
(
args
[
p
]
)
;
}
return
result
;
}
function
isGrip
(
object
)
{
return
object
&
&
object
.
actor
;
}
function
escapeNewLines
(
value
)
{
return
value
.
replace
(
/
\
r
/
gm
"
\
\
r
"
)
.
replace
(
/
\
n
/
gm
"
\
\
n
"
)
;
}
function
cropMultipleLines
(
text
limit
)
{
return
escapeNewLines
(
cropString
(
text
limit
)
)
;
}
function
cropString
(
text
limit
alternativeText
)
{
if
(
!
alternativeText
)
{
alternativeText
=
"
\
u2026
"
;
}
text
=
text
+
"
"
;
if
(
!
limit
)
{
limit
=
50
;
}
if
(
limit
<
=
0
)
{
return
text
;
}
if
(
limit
<
=
alternativeText
.
length
)
{
limit
=
alternativeText
.
length
+
1
;
}
let
halfLimit
=
(
limit
-
alternativeText
.
length
)
/
2
;
if
(
text
.
length
>
limit
)
{
return
text
.
substr
(
0
Math
.
ceil
(
halfLimit
)
)
+
alternativeText
+
text
.
substr
(
text
.
length
-
Math
.
floor
(
halfLimit
)
)
;
}
return
text
;
}
exports
.
createFactories
=
createFactories
;
exports
.
isGrip
=
isGrip
;
exports
.
cropString
=
cropString
;
exports
.
cropMultipleLines
=
cropMultipleLines
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
Undefined
=
React
.
createClass
(
{
displayName
:
"
UndefinedRep
"
render
:
function
(
)
{
return
(
ObjectBox
(
{
className
:
"
undefined
"
}
"
undefined
"
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
undefined
"
)
{
return
true
;
}
return
(
type
=
=
"
undefined
"
)
;
}
exports
.
Undefined
=
{
rep
:
Undefined
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
DOM
=
React
.
DOM
;
const
ObjectBox
=
React
.
createClass
(
{
displayName
:
"
ObjectBox
"
render
:
function
(
)
{
let
className
=
this
.
props
.
className
;
let
boxClassName
=
className
?
"
objectBox
-
"
+
className
:
"
"
;
return
(
DOM
.
span
(
{
className
:
"
objectBox
"
+
boxClassName
role
:
"
presentation
"
}
this
.
props
.
children
)
)
;
}
}
)
;
exports
.
ObjectBox
=
ObjectBox
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
Null
=
React
.
createClass
(
{
displayName
:
"
NullRep
"
render
:
function
(
)
{
return
(
ObjectBox
(
{
className
:
"
null
"
}
"
null
"
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
object
&
&
object
.
type
&
&
object
.
type
=
=
"
null
"
)
{
return
true
;
}
return
(
object
=
=
null
)
;
}
exports
.
Null
=
{
rep
:
Null
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
cropMultipleLines
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
StringRep
=
React
.
createClass
(
{
displayName
:
"
StringRep
"
render
:
function
(
)
{
let
text
=
this
.
props
.
object
;
let
member
=
this
.
props
.
member
;
if
(
member
&
&
member
.
open
)
{
return
(
ObjectBox
(
{
className
:
"
string
"
}
"
\
"
"
+
text
+
"
\
"
"
)
)
;
}
return
(
ObjectBox
(
{
className
:
"
string
"
}
"
\
"
"
+
cropMultipleLines
(
text
)
+
"
\
"
"
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
return
(
type
=
=
"
string
"
)
;
}
exports
.
StringRep
=
{
rep
:
StringRep
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
Number
=
React
.
createClass
(
{
displayName
:
"
Number
"
stringify
:
function
(
object
)
{
return
(
Object
.
is
(
object
-
0
)
?
"
-
0
"
:
String
(
object
)
)
;
}
render
:
function
(
)
{
let
value
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
number
"
}
this
.
stringify
(
value
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
return
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
;
}
exports
.
Number
=
{
rep
:
Number
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
285
)
)
;
const
DOM
=
React
.
DOM
;
let
ArrayRep
=
React
.
createClass
(
{
displayName
:
"
ArrayRep
"
getTitle
:
function
(
object
context
)
{
return
"
[
"
+
object
.
length
+
"
]
"
;
}
arrayIterator
:
function
(
array
max
)
{
let
items
=
[
]
;
let
delim
;
for
(
let
i
=
0
;
i
<
array
.
length
&
&
i
<
=
max
;
i
+
+
)
{
try
{
let
value
=
array
[
i
]
;
delim
=
(
i
=
=
array
.
length
-
1
?
"
"
:
"
"
)
;
if
(
value
=
=
=
array
)
{
items
.
push
(
Reference
(
{
key
:
i
object
:
value
delim
:
delim
}
)
)
;
}
else
{
items
.
push
(
ItemRep
(
{
key
:
i
object
:
value
delim
:
delim
}
)
)
;
}
}
catch
(
exc
)
{
items
.
push
(
ItemRep
(
{
object
:
exc
delim
:
delim
key
:
i
}
)
)
;
}
}
if
(
array
.
length
>
max
+
1
)
{
items
.
pop
(
)
;
items
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
return
items
;
}
hasSpecialProperties
:
function
(
array
)
{
function
isInteger
(
x
)
{
let
y
=
parseInt
(
x
10
)
;
if
(
isNaN
(
y
)
)
{
return
false
;
}
return
x
=
=
=
y
.
toString
(
)
;
}
let
props
=
Object
.
getOwnPropertyNames
(
array
)
;
for
(
let
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
let
p
=
props
[
i
]
;
if
(
isInteger
(
p
)
)
{
continue
;
}
if
(
p
!
=
"
length
"
)
{
return
true
;
}
}
return
false
;
}
onToggleProperties
:
function
(
event
)
{
}
onClickBracket
:
function
(
event
)
{
}
render
:
function
(
)
{
let
mode
=
this
.
props
.
mode
|
|
"
short
"
;
let
object
=
this
.
props
.
object
;
let
items
;
if
(
mode
=
=
"
tiny
"
)
{
items
=
DOM
.
span
(
{
className
:
"
length
"
}
object
.
length
)
;
}
else
{
let
max
=
(
mode
=
=
"
short
"
)
?
3
:
300
;
items
=
this
.
arrayIterator
(
object
max
)
;
}
return
(
ObjectBox
(
{
className
:
"
array
"
onClick
:
this
.
onToggleProperties
}
DOM
.
a
(
{
className
:
"
objectLink
"
onclick
:
this
.
onClickBracket
}
DOM
.
span
(
{
className
:
"
arrayLeftBracket
"
role
:
"
presentation
"
}
"
[
"
)
)
items
DOM
.
a
(
{
className
:
"
objectLink
"
onclick
:
this
.
onClickBracket
}
DOM
.
span
(
{
className
:
"
arrayRightBracket
"
role
:
"
presentation
"
}
"
]
"
)
)
DOM
.
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
)
;
}
}
)
;
let
ItemRep
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
ItemRep
"
render
:
function
(
)
{
const
{
Rep
}
=
createFactories
(
__webpack_require__
(
277
)
)
;
let
object
=
this
.
props
.
object
;
let
delim
=
this
.
props
.
delim
;
return
(
DOM
.
span
(
{
}
Rep
(
{
object
:
object
}
)
delim
)
)
;
}
}
)
)
;
let
Reference
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
Reference
"
render
:
function
(
)
{
let
tooltip
=
"
Circular
reference
"
;
return
(
DOM
.
span
(
{
title
:
tooltip
}
"
[
.
.
.
]
"
)
)
;
}
}
)
)
;
function
supportsObject
(
object
type
)
{
return
Array
.
isArray
(
object
)
|
|
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Arguments
]
"
;
}
exports
.
ArrayRep
=
{
rep
:
ArrayRep
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
DOM
=
React
.
DOM
;
const
Caption
=
React
.
createClass
(
{
displayName
:
"
Caption
"
render
:
function
(
)
{
return
(
DOM
.
span
(
{
"
className
"
:
"
caption
"
}
this
.
props
.
object
)
)
;
}
}
)
;
exports
.
Caption
=
Caption
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
285
)
)
;
const
{
PropRep
}
=
createFactories
(
__webpack_require__
(
287
)
)
;
const
{
span
}
=
React
.
DOM
;
const
Obj
=
React
.
createClass
(
{
displayName
:
"
Obj
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
mode
:
React
.
PropTypes
.
string
}
getTitle
:
function
(
)
{
return
"
Object
"
;
}
longPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
100
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
shortPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
3
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
propIterator
:
function
(
object
max
)
{
let
isInterestingProp
=
(
t
value
)
=
>
{
return
(
t
=
=
"
boolean
"
|
|
t
=
=
"
number
"
|
|
(
t
=
=
"
string
"
&
&
value
)
)
;
}
;
if
(
Object
.
prototype
.
toString
.
call
(
object
)
=
=
=
"
[
object
Generator
]
"
)
{
object
=
Object
.
getPrototypeOf
(
object
)
;
}
let
props
=
this
.
getProps
(
object
max
isInterestingProp
)
;
if
(
props
.
length
<
=
max
)
{
props
=
props
.
concat
(
this
.
getProps
(
object
max
(
t
value
)
=
>
{
return
!
isInterestingProp
(
t
value
)
;
}
)
)
;
}
if
(
props
.
length
>
max
)
{
props
.
pop
(
)
;
props
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
else
if
(
props
.
length
>
0
)
{
props
[
props
.
length
-
1
]
=
React
.
cloneElement
(
props
[
props
.
length
-
1
]
{
delim
:
"
"
}
)
;
}
return
props
;
}
getProps
:
function
(
object
max
filter
)
{
let
props
=
[
]
;
max
=
max
|
|
3
;
if
(
!
object
)
{
return
props
;
}
let
mode
=
this
.
props
.
mode
;
try
{
for
(
let
name
in
object
)
{
if
(
props
.
length
>
max
)
{
return
props
;
}
let
value
;
try
{
value
=
object
[
name
]
;
}
catch
(
exc
)
{
continue
;
}
let
t
=
typeof
value
;
if
(
filter
(
t
value
)
)
{
props
.
push
(
PropRep
(
{
key
:
name
mode
:
mode
name
:
name
object
:
value
equal
:
"
:
"
delim
:
"
"
}
)
)
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
props
;
}
render
:
function
(
)
{
let
object
=
this
.
props
.
object
;
let
props
=
this
.
shortPropIterator
(
object
)
;
if
(
this
.
props
.
mode
=
=
"
tiny
"
|
|
!
props
.
length
)
{
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
)
)
)
)
;
}
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
)
)
span
(
{
className
:
"
objectLeftBrace
"
role
:
"
presentation
"
}
"
{
"
)
props
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
return
true
;
}
exports
.
Obj
=
{
rep
:
Obj
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
}
=
__webpack_require__
(
278
)
;
const
{
span
}
=
React
.
DOM
;
let
PropRep
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
PropRep
"
propTypes
:
{
name
:
React
.
PropTypes
.
string
equal
:
React
.
PropTypes
.
string
delim
:
React
.
PropTypes
.
string
}
render
:
function
(
)
{
let
{
Rep
}
=
createFactories
(
__webpack_require__
(
277
)
)
;
return
(
span
(
{
}
span
(
{
"
className
"
:
"
nodeName
"
}
this
.
props
.
name
)
span
(
{
"
className
"
:
"
objectEqual
"
role
:
"
presentation
"
}
this
.
props
.
equal
)
Rep
(
this
.
props
)
span
(
{
"
className
"
:
"
objectComma
"
role
:
"
presentation
"
}
this
.
props
.
delim
)
)
)
;
}
}
)
)
;
exports
.
PropRep
=
PropRep
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
const
{
StringRep
}
=
__webpack_require__
(
282
)
;
const
{
span
}
=
React
.
DOM
;
const
{
rep
:
StringRepFactory
}
=
createFactories
(
StringRep
)
;
let
Attribute
=
React
.
createClass
(
{
displayName
:
"
Attr
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getTitle
:
function
(
grip
)
{
return
grip
.
preview
.
nodeName
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
value
=
grip
.
preview
.
value
;
return
(
ObjectLink
(
{
className
:
"
Attr
"
}
span
(
{
}
span
(
{
className
:
"
attrTitle
"
}
this
.
getTitle
(
grip
)
)
span
(
{
className
:
"
attrEqual
"
}
"
=
"
)
StringRepFactory
(
{
object
:
value
}
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
type
=
=
"
Attr
"
&
&
grip
.
preview
)
;
}
exports
.
Attribute
=
{
rep
:
Attribute
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
DOM
=
React
.
DOM
;
const
ObjectLink
=
React
.
createClass
(
{
displayName
:
"
ObjectLink
"
render
:
function
(
)
{
let
className
=
this
.
props
.
className
;
let
objectClassName
=
className
?
"
objectLink
-
"
+
className
:
"
"
;
let
linkClassName
=
"
objectLink
"
+
objectClassName
+
"
a11yFocus
"
;
return
(
DOM
.
a
(
{
className
:
linkClassName
_repObject
:
this
.
props
.
object
}
this
.
props
.
children
)
)
;
}
}
)
;
exports
.
ObjectLink
=
ObjectLink
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
const
{
span
}
=
React
.
DOM
;
let
DateTime
=
React
.
createClass
(
{
displayName
:
"
Date
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getTitle
:
function
(
grip
)
{
return
new
Date
(
grip
.
preview
.
timestamp
)
.
toISOString
(
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
Date
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
type
=
=
"
Date
"
&
&
grip
.
preview
)
;
}
exports
.
DateTime
=
{
rep
:
DateTime
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
{
getFileName
}
=
__webpack_require__
(
292
)
;
const
{
span
}
=
React
.
DOM
;
let
Document
=
React
.
createClass
(
{
displayName
:
"
Document
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getLocation
:
function
(
grip
)
{
let
location
=
grip
.
preview
.
location
;
return
location
?
getFileName
(
location
)
:
"
"
;
}
getTitle
:
function
(
win
context
)
{
return
"
document
"
;
}
getTooltip
:
function
(
doc
)
{
return
doc
.
location
.
href
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
object
.
preview
&
&
type
=
=
"
HTMLDocument
"
)
;
}
exports
.
Document
=
{
rep
:
Document
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
function
parseURLParams
(
url
)
{
url
=
new
URL
(
url
)
;
return
parseURLEncodedText
(
url
.
searchParams
)
;
}
function
parseURLEncodedText
(
text
)
{
let
params
=
[
]
;
if
(
text
=
=
"
"
)
{
return
params
;
}
let
searchParams
=
new
URLSearchParams
(
text
)
;
let
entries
=
[
.
.
.
searchParams
.
entries
(
)
]
;
return
entries
.
map
(
entry
=
>
{
return
{
name
:
entry
[
0
]
value
:
entry
[
1
]
}
;
}
)
;
}
function
getFileName
(
url
)
{
let
split
=
splitURLBase
(
url
)
;
return
split
.
name
;
}
function
splitURLBase
(
url
)
{
if
(
!
isDataURL
(
url
)
)
{
return
splitURLTrue
(
url
)
;
}
return
{
}
;
}
function
isDataURL
(
url
)
{
return
(
url
&
&
url
.
substr
(
0
5
)
=
=
"
data
:
"
)
;
}
function
splitURLTrue
(
url
)
{
const
reSplitFile
=
/
(
.
*
?
)
:
\
/
{
2
3
}
(
[
^
\
/
]
*
)
(
.
*
?
)
(
[
^
\
/
]
*
?
)
(
|
\
?
.
*
)
/
;
let
m
=
reSplitFile
.
exec
(
url
)
;
if
(
!
m
)
{
return
{
name
:
url
path
:
url
}
;
}
else
if
(
m
[
4
]
=
=
"
"
&
&
m
[
5
]
=
=
"
"
)
{
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
3
]
name
:
m
[
3
]
!
=
"
/
"
?
m
[
3
]
:
m
[
2
]
}
;
}
return
{
protocol
:
m
[
1
]
domain
:
m
[
2
]
path
:
m
[
2
]
+
m
[
3
]
name
:
m
[
4
]
+
m
[
5
]
}
;
}
exports
.
parseURLParams
=
parseURLParams
;
exports
.
parseURLEncodedText
=
parseURLEncodedText
;
exports
.
getFileName
=
getFileName
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
let
Event
=
React
.
createClass
(
{
displayName
:
"
event
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
summarizeEvent
:
function
(
grip
)
{
let
info
=
[
grip
.
preview
.
type
"
"
]
;
let
eventFamily
=
grip
.
class
;
let
props
=
grip
.
preview
.
properties
;
if
(
eventFamily
=
=
"
MouseEvent
"
)
{
info
.
push
(
"
clientX
=
"
props
.
clientX
"
clientY
=
"
props
.
clientY
)
;
}
else
if
(
eventFamily
=
=
"
KeyboardEvent
"
)
{
info
.
push
(
"
charCode
=
"
props
.
charCode
"
keyCode
=
"
props
.
keyCode
)
;
}
else
if
(
eventFamily
=
=
"
MessageEvent
"
)
{
info
.
push
(
"
origin
=
"
props
.
origin
"
data
=
"
props
.
data
)
;
}
return
info
.
join
(
"
"
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
event
"
}
this
.
summarizeEvent
(
grip
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
DOMEvent
"
)
;
}
exports
.
Event
=
{
rep
:
Event
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
cropString
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
let
Func
=
React
.
createClass
(
{
displayName
:
"
Func
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
summarizeFunction
:
function
(
grip
)
{
let
name
=
grip
.
displayName
|
|
grip
.
name
|
|
"
function
"
;
return
cropString
(
name
+
"
(
)
"
100
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
function
"
}
this
.
summarizeFunction
(
grip
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
(
type
=
=
"
function
"
)
;
}
return
(
type
=
=
"
Function
"
)
;
}
exports
.
Func
=
{
rep
:
Func
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
285
)
)
;
const
{
span
}
=
React
.
DOM
;
let
NamedNodeMap
=
React
.
createClass
(
{
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
provider
:
React
.
PropTypes
.
object
}
className
:
"
NamedNodeMap
"
getLength
:
function
(
object
)
{
return
object
.
preview
.
length
;
}
getTitle
:
function
(
object
)
{
return
object
.
class
?
object
.
class
:
"
"
;
}
getItems
:
function
(
array
max
)
{
let
items
=
this
.
propIterator
(
array
max
)
;
items
=
items
.
map
(
item
=
>
PropRep
(
item
)
)
;
if
(
items
.
length
>
max
+
1
)
{
items
.
pop
(
)
;
items
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
return
items
;
}
propIterator
:
function
(
grip
max
)
{
max
=
max
|
|
3
;
let
props
=
[
]
;
let
provider
=
this
.
props
.
provider
;
if
(
!
provider
)
{
return
props
;
}
let
ownProperties
=
grip
.
preview
?
grip
.
preview
.
ownProperties
:
[
]
;
for
(
let
name
in
ownProperties
)
{
if
(
props
.
length
>
max
)
{
break
;
}
let
item
=
ownProperties
[
name
]
;
let
label
=
provider
.
getLabel
(
item
)
;
let
value
=
provider
.
getValue
(
item
)
;
props
.
push
(
Object
.
assign
(
{
}
this
.
props
{
name
:
label
object
:
value
equal
:
"
:
"
delim
:
"
"
}
)
)
;
}
return
props
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
mode
=
this
.
props
.
mode
;
let
items
;
if
(
mode
=
=
"
tiny
"
)
{
items
=
this
.
getLength
(
grip
)
;
}
else
{
let
max
=
(
mode
=
=
"
short
"
)
?
3
:
100
;
items
=
this
.
getItems
(
grip
max
)
;
}
return
(
ObjectLink
(
{
className
:
"
NamedNodeMap
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
grip
)
)
span
(
{
className
:
"
arrayLeftBracket
"
role
:
"
presentation
"
}
"
[
"
)
items
span
(
{
className
:
"
arrayRightBracket
"
role
:
"
presentation
"
}
"
]
"
)
)
)
;
}
}
)
;
let
PropRep
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
PropRep
"
propTypes
:
{
equal
:
React
.
PropTypes
.
string
delim
:
React
.
PropTypes
.
string
}
render
:
function
(
)
{
const
{
Rep
}
=
createFactories
(
__webpack_require__
(
277
)
)
;
return
(
span
(
{
}
span
(
{
className
:
"
nodeName
"
}
"
prop
.
name
"
)
span
(
{
className
:
"
objectEqual
"
role
:
"
presentation
"
}
this
.
props
.
equal
)
Rep
(
this
.
props
)
span
(
{
className
:
"
objectComma
"
role
:
"
presentation
"
}
this
.
props
.
delim
)
)
)
;
}
}
)
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
type
=
=
"
NamedNodeMap
"
&
&
grip
.
preview
)
;
}
exports
.
NamedNodeMap
=
{
rep
:
NamedNodeMap
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
const
{
span
}
=
React
.
DOM
;
let
RegExp
=
React
.
createClass
(
{
displayName
:
"
regexp
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getTitle
:
function
(
grip
)
{
return
grip
.
class
;
}
getSource
:
function
(
grip
)
{
return
grip
.
displayString
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
"
regexp
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
grip
)
)
span
(
"
"
)
span
(
{
className
:
"
regexpSource
"
}
this
.
getSource
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
type
=
=
"
RegExp
"
)
;
}
exports
.
RegExp
=
{
rep
:
RegExp
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
{
getFileName
}
=
__webpack_require__
(
292
)
;
const
DOM
=
React
.
DOM
;
let
StyleSheet
=
React
.
createClass
(
{
displayName
:
"
object
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getLocation
:
function
(
grip
)
{
let
url
=
grip
.
preview
?
grip
.
preview
.
url
:
"
"
;
return
url
?
getFileName
(
url
)
:
"
"
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
object
"
}
"
StyleSheet
"
DOM
.
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
type
=
=
"
CSSStyleSheet
"
)
;
}
exports
.
StyleSheet
=
{
rep
:
StyleSheet
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
cropMultipleLines
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
const
DOM
=
React
.
DOM
;
let
TextNode
=
React
.
createClass
(
{
displayName
:
"
TextNode
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
}
getTextContent
:
function
(
grip
)
{
return
cropMultipleLines
(
grip
.
preview
.
textContent
)
;
}
getTitle
:
function
(
win
context
)
{
return
"
textNode
"
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
let
mode
=
this
.
props
.
mode
|
|
"
short
"
;
if
(
mode
=
=
"
short
"
|
|
mode
=
=
"
tiny
"
)
{
return
(
ObjectLink
(
{
className
:
"
textNode
"
}
"
\
"
"
+
this
.
getTextContent
(
grip
)
+
"
\
"
"
)
)
;
}
return
(
ObjectLink
(
{
className
:
"
textNode
"
}
"
<
"
DOM
.
span
(
{
className
:
"
nodeTag
"
}
"
TextNode
"
)
"
textContent
=
\
"
"
DOM
.
span
(
{
className
:
"
nodeValue
"
}
this
.
getTextContent
(
grip
)
)
"
\
"
"
"
>
;
"
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
class
=
=
"
Text
"
)
;
}
exports
.
TextNode
=
{
rep
:
TextNode
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
cropString
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
DOM
=
React
.
DOM
;
let
Window
=
React
.
createClass
(
{
displayName
:
"
Window
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getLocation
:
function
(
grip
)
{
return
cropString
(
grip
.
preview
.
url
)
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectBox
(
{
className
:
"
Window
"
}
DOM
.
span
(
{
className
:
"
objectPropValue
"
}
this
.
getLocation
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
object
.
preview
&
&
type
=
=
"
Window
"
)
;
}
exports
.
Window
=
{
rep
:
Window
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
const
{
span
}
=
React
.
DOM
;
let
ObjectWithText
=
React
.
createClass
(
{
displayName
:
"
ObjectWithText
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getType
:
function
(
grip
)
{
return
grip
.
class
;
}
getDescription
:
function
(
grip
)
{
return
(
grip
.
preview
.
kind
=
=
"
ObjectWithText
"
)
?
grip
.
preview
.
text
:
"
"
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
this
.
getType
(
grip
)
}
span
(
{
className
:
"
objectPropValue
"
}
this
.
getDescription
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithText
"
)
;
}
exports
.
ObjectWithText
=
{
rep
:
ObjectWithText
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectLink
}
=
createFactories
(
__webpack_require__
(
289
)
)
;
const
{
span
}
=
React
.
DOM
;
let
ObjectWithURL
=
React
.
createClass
(
{
displayName
:
"
ObjectWithURL
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
}
getType
:
function
(
grip
)
{
return
grip
.
class
;
}
getDescription
:
function
(
grip
)
{
return
grip
.
preview
.
url
;
}
render
:
function
(
)
{
let
grip
=
this
.
props
.
object
;
return
(
ObjectLink
(
{
className
:
this
.
getType
(
grip
)
}
span
(
{
className
:
"
objectPropValue
"
}
this
.
getDescription
(
grip
)
)
)
)
;
}
}
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ObjectWithURL
"
)
;
}
exports
.
ObjectWithURL
=
{
rep
:
ObjectWithURL
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
285
)
)
;
const
{
a
span
}
=
React
.
DOM
;
let
GripArray
=
React
.
createClass
(
{
displayName
:
"
GripArray
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
provider
:
React
.
PropTypes
.
object
}
getLength
:
function
(
grip
)
{
return
grip
.
preview
?
grip
.
preview
.
length
:
0
;
}
getTitle
:
function
(
object
context
)
{
return
"
[
"
+
object
.
length
+
"
]
"
;
}
arrayIterator
:
function
(
grip
max
)
{
let
items
=
[
]
;
if
(
!
grip
.
preview
|
|
!
grip
.
preview
.
length
)
{
return
items
;
}
let
array
=
grip
.
preview
.
items
;
if
(
!
array
)
{
return
items
;
}
let
delim
;
let
provider
=
this
.
props
.
provider
;
for
(
let
i
=
0
;
i
<
array
.
length
&
&
i
<
=
max
;
i
+
+
)
{
try
{
let
itemGrip
=
array
[
i
]
;
let
value
=
provider
?
provider
.
getValue
(
itemGrip
)
:
itemGrip
;
delim
=
(
i
=
=
array
.
length
-
1
?
"
"
:
"
"
)
;
if
(
value
=
=
=
array
)
{
items
.
push
(
Reference
(
{
key
:
i
object
:
value
delim
:
delim
}
)
)
;
}
else
{
items
.
push
(
GripArrayItem
(
Object
.
assign
(
{
}
this
.
props
{
key
:
i
object
:
value
delim
:
delim
}
)
)
)
;
}
}
catch
(
exc
)
{
items
.
push
(
GripArrayItem
(
Object
.
assign
(
{
}
this
.
props
{
object
:
exc
delim
:
delim
key
:
i
}
)
)
)
;
}
}
if
(
array
.
length
>
max
+
1
)
{
items
.
pop
(
)
;
items
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
return
items
;
}
render
:
function
(
)
{
let
mode
=
this
.
props
.
mode
|
|
"
short
"
;
let
object
=
this
.
props
.
object
;
let
items
;
if
(
mode
=
=
"
tiny
"
)
{
items
=
span
(
{
className
:
"
length
"
}
this
.
getLength
(
object
)
)
;
}
else
{
let
max
=
(
mode
=
=
"
short
"
)
?
3
:
300
;
items
=
this
.
arrayIterator
(
object
max
)
;
}
return
(
ObjectBox
(
{
className
:
"
array
"
}
a
(
{
className
:
"
objectLink
"
}
span
(
{
className
:
"
arrayLeftBracket
"
role
:
"
presentation
"
}
"
[
"
)
)
items
a
(
{
className
:
"
objectLink
"
}
span
(
{
className
:
"
arrayRightBracket
"
role
:
"
presentation
"
}
"
]
"
)
)
span
(
{
className
:
"
arrayProperties
"
role
:
"
group
"
}
)
)
)
;
}
}
)
;
let
GripArrayItem
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
GripArrayItem
"
propTypes
:
{
delim
:
React
.
PropTypes
.
string
}
render
:
function
(
)
{
let
{
Rep
}
=
createFactories
(
__webpack_require__
(
277
)
)
;
return
(
span
(
{
}
Rep
(
Object
.
assign
(
{
}
this
.
props
{
mode
:
"
tiny
"
}
)
)
this
.
props
.
delim
)
)
;
}
}
)
)
;
let
Reference
=
React
.
createFactory
(
React
.
createClass
(
{
displayName
:
"
Reference
"
render
:
function
(
)
{
return
(
span
(
{
title
:
"
Circular
reference
"
}
"
[
.
.
.
]
"
)
)
;
}
}
)
)
;
function
supportsObject
(
grip
type
)
{
if
(
!
isGrip
(
grip
)
)
{
return
false
;
}
return
(
grip
.
preview
&
&
grip
.
preview
.
kind
=
=
"
ArrayLike
"
)
;
}
exports
.
GripArray
=
{
rep
:
GripArray
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
"
use
strict
"
;
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
function
(
require
exports
module
)
{
const
React
=
__webpack_require__
(
17
)
;
const
{
createFactories
isGrip
}
=
__webpack_require__
(
278
)
;
const
{
ObjectBox
}
=
createFactories
(
__webpack_require__
(
280
)
)
;
const
{
Caption
}
=
createFactories
(
__webpack_require__
(
285
)
)
;
const
{
PropRep
}
=
createFactories
(
__webpack_require__
(
287
)
)
;
const
{
span
}
=
React
.
DOM
;
const
Grip
=
React
.
createClass
(
{
displayName
:
"
Grip
"
propTypes
:
{
object
:
React
.
PropTypes
.
object
.
isRequired
mode
:
React
.
PropTypes
.
string
}
getTitle
:
function
(
)
{
return
this
.
props
.
object
.
class
|
|
"
Object
"
;
}
longPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
100
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
shortPropIterator
:
function
(
object
)
{
try
{
return
this
.
propIterator
(
object
3
)
;
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
[
]
;
}
propIterator
:
function
(
object
max
)
{
let
isInterestingProp
=
(
type
value
)
=
>
{
return
(
type
=
=
"
boolean
"
|
|
type
=
=
"
number
"
|
|
type
=
=
"
string
"
|
|
type
=
=
"
object
"
)
;
}
;
let
props
=
this
.
getProps
(
object
max
isInterestingProp
)
;
if
(
props
.
length
<
=
max
)
{
props
=
props
.
concat
(
this
.
getProps
(
object
max
(
t
value
)
=
>
{
return
!
isInterestingProp
(
t
value
)
;
}
)
)
;
}
if
(
props
.
length
>
max
)
{
props
.
pop
(
)
;
props
.
push
(
Caption
(
{
key
:
"
more
"
object
:
"
more
.
.
.
"
}
)
)
;
}
else
if
(
props
.
length
>
0
)
{
let
last
=
props
.
length
-
1
;
props
[
last
]
=
React
.
cloneElement
(
props
[
last
]
{
delim
:
"
"
}
)
;
}
return
props
;
}
getProps
:
function
(
object
max
filter
)
{
let
props
=
[
]
;
max
=
max
|
|
3
;
if
(
!
object
)
{
return
props
;
}
try
{
let
ownProperties
=
object
.
preview
?
object
.
preview
.
ownProperties
:
[
]
;
for
(
let
name
in
ownProperties
)
{
if
(
props
.
length
>
max
)
{
return
props
;
}
let
prop
=
ownProperties
[
name
]
;
let
value
=
prop
.
value
|
|
{
}
;
let
type
=
(
value
.
class
|
|
typeof
value
)
;
type
=
type
.
toLowerCase
(
)
;
if
(
filter
(
type
value
)
)
{
props
.
push
(
PropRep
(
Object
.
assign
(
{
}
this
.
props
{
key
:
name
mode
:
"
tiny
"
name
:
name
object
:
value
equal
:
"
:
"
delim
:
"
"
}
)
)
)
;
}
}
}
catch
(
err
)
{
console
.
error
(
err
)
;
}
return
props
;
}
render
:
function
(
)
{
let
object
=
this
.
props
.
object
;
let
props
=
(
this
.
props
.
mode
=
=
"
long
"
)
?
this
.
longPropIterator
(
object
)
:
this
.
shortPropIterator
(
object
)
;
if
(
this
.
props
.
mode
=
=
"
tiny
"
|
|
!
props
.
length
)
{
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
object
)
)
)
)
;
}
return
(
ObjectBox
(
{
className
:
"
object
"
}
span
(
{
className
:
"
objectTitle
"
}
this
.
getTitle
(
object
)
)
span
(
{
className
:
"
objectLeftBrace
"
role
:
"
presentation
"
}
"
{
"
)
props
span
(
{
className
:
"
objectRightBrace
"
}
"
}
"
)
)
)
;
}
}
)
;
function
supportsObject
(
object
type
)
{
if
(
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
object
.
preview
&
&
object
.
preview
.
ownProperties
)
;
}
exports
.
Grip
=
{
rep
:
Grip
supportsObject
:
supportsObject
}
;
}
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getSelectedFrame
=
_require3
.
getSelectedFrame
;
var
getLoadedObjects
=
_require3
.
getLoadedObjects
;
var
getPause
=
_require3
.
getPause
;
var
ObjectInspector
=
React
.
createFactory
(
__webpack_require__
(
309
)
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
toPairs
=
__webpack_require__
(
313
)
;
__webpack_require__
(
338
)
;
function
info
(
text
)
{
return
dom
.
div
(
{
className
:
"
pane
-
info
"
}
text
)
;
}
function
getBindingVariables
(
bindings
parentName
)
{
var
args
=
bindings
.
arguments
.
map
(
arg
=
>
toPairs
(
arg
)
[
0
]
)
;
var
variables
=
toPairs
(
bindings
.
variables
)
;
return
args
.
concat
(
variables
)
.
filter
(
binding
=
>
!
(
binding
[
1
]
.
value
.
missingArguments
|
|
binding
[
1
]
.
value
.
optimizedOut
)
)
.
map
(
binding
=
>
(
{
name
:
binding
[
0
]
path
:
parentName
+
"
/
"
+
binding
[
0
]
contents
:
binding
[
1
]
}
)
)
;
}
function
getSpecialVariables
(
pauseInfo
path
)
{
var
thrown
=
pauseInfo
.
getIn
(
[
"
why
"
"
frameFinished
"
"
throw
"
]
)
;
var
returned
=
pauseInfo
.
getIn
(
[
"
why
"
"
frameFinished
"
"
return
"
]
)
;
var
vars
=
[
]
;
if
(
thrown
)
{
thrown
=
thrown
.
toJS
?
thrown
.
toJS
(
)
:
thrown
;
vars
.
push
(
{
name
:
"
<
exception
>
"
path
:
path
+
"
/
<
exception
>
"
contents
:
{
value
:
thrown
}
}
)
;
}
if
(
returned
)
{
vars
.
push
(
{
name
:
"
<
return
>
"
path
:
path
+
"
/
<
return
>
"
contents
:
{
value
:
returned
.
toJS
(
)
}
}
)
;
}
return
vars
;
}
function
getThisVariable
(
frame
path
)
{
var
this_
=
frame
.
this
;
if
(
!
this_
)
{
return
null
;
}
return
{
name
:
"
<
this
>
"
path
:
path
+
"
/
<
this
>
"
contents
:
{
value
:
this_
}
}
;
}
function
getScopes
(
pauseInfo
selectedFrame
)
{
if
(
!
pauseInfo
|
|
!
selectedFrame
)
{
return
null
;
}
var
selectedScope
=
selectedFrame
.
scope
;
if
(
!
selectedScope
)
{
return
null
;
}
var
scopes
=
[
]
;
var
scope
=
selectedScope
;
var
pausedScopeActor
=
pauseInfo
.
getIn
(
[
"
frame
"
"
scope
"
]
)
.
get
(
"
actor
"
)
;
do
{
var
type
=
scope
.
type
;
var
key
=
scope
.
actor
;
if
(
type
=
=
=
"
function
"
|
|
type
=
=
=
"
block
"
)
{
var
bindings
=
scope
.
bindings
;
var
title
=
void
0
;
if
(
type
=
=
=
"
function
"
)
{
title
=
scope
.
function
.
displayName
|
|
"
(
anonymous
)
"
;
}
else
{
title
=
"
Block
"
;
}
var
vars
=
getBindingVariables
(
bindings
title
)
;
if
(
scope
.
actor
=
=
=
pausedScopeActor
)
{
vars
=
vars
.
concat
(
getSpecialVariables
(
pauseInfo
key
)
)
;
}
if
(
scope
.
actor
=
=
=
selectedScope
.
actor
)
{
var
this_
=
getThisVariable
(
selectedFrame
key
)
;
if
(
this_
)
{
vars
.
push
(
this_
)
;
}
}
if
(
vars
&
&
vars
.
length
)
{
vars
.
sort
(
(
a
b
)
=
>
a
.
name
.
localeCompare
(
b
.
name
)
)
;
scopes
.
push
(
{
name
:
title
path
:
key
contents
:
vars
}
)
;
}
}
else
if
(
type
=
=
=
"
object
"
)
{
scopes
.
push
(
{
name
:
scope
.
object
.
class
path
:
key
contents
:
{
value
:
scope
.
object
}
}
)
;
}
}
while
(
scope
=
scope
.
parent
)
;
return
scopes
;
}
var
Scopes
=
React
.
createClass
(
{
propTypes
:
{
pauseInfo
:
ImPropTypes
.
map
loadedObjects
:
ImPropTypes
.
map
loadObjectProperties
:
PropTypes
.
func
selectedFrame
:
PropTypes
.
object
}
displayName
:
"
Scopes
"
getInitialState
(
)
{
var
_props
=
this
.
props
;
var
pauseInfo
=
_props
.
pauseInfo
;
var
selectedFrame
=
_props
.
selectedFrame
;
return
{
scopes
:
getScopes
(
pauseInfo
selectedFrame
)
}
;
}
componentWillReceiveProps
(
nextProps
)
{
var
_props2
=
this
.
props
;
var
pauseInfo
=
_props2
.
pauseInfo
;
var
selectedFrame
=
_props2
.
selectedFrame
;
var
pauseInfoChanged
=
pauseInfo
!
=
=
nextProps
.
pauseInfo
;
var
selectedFrameChange
=
selectedFrame
!
=
=
nextProps
.
selectedFrame
;
if
(
pauseInfoChanged
|
|
selectedFrameChange
)
{
this
.
setState
(
{
scopes
:
getScopes
(
nextProps
.
pauseInfo
nextProps
.
selectedFrame
)
}
)
;
}
}
render
(
)
{
var
_props3
=
this
.
props
;
var
pauseInfo
=
_props3
.
pauseInfo
;
var
loadObjectProperties
=
_props3
.
loadObjectProperties
;
var
loadedObjects
=
_props3
.
loadedObjects
;
var
scopes
=
this
.
state
.
scopes
;
var
scopeInspector
=
info
(
"
Scopes
Unavailable
"
)
;
if
(
scopes
)
{
scopeInspector
=
ObjectInspector
(
{
roots
:
scopes
getObjectProperties
:
id
=
>
loadedObjects
.
get
(
id
)
loadObjectProperties
:
loadObjectProperties
}
)
;
}
return
dom
.
div
(
{
className
:
"
pane
scopes
-
list
"
}
pauseInfo
?
scopeInspector
:
info
(
"
Not
Paused
"
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
pauseInfo
:
getPause
(
state
)
selectedFrame
:
getSelectedFrame
(
state
)
loadedObjects
:
getLoadedObjects
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Scopes
)
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
classnames
=
__webpack_require__
(
207
)
;
var
ManagedTree
=
React
.
createFactory
(
__webpack_require__
(
231
)
)
;
var
Arrow
=
React
.
createFactory
(
__webpack_require__
(
310
)
)
;
var
Rep
=
__webpack_require__
(
276
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
function
nodeHasChildren
(
item
)
{
return
Array
.
isArray
(
item
.
contents
)
;
}
function
nodeHasProperties
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
item
.
contents
.
value
.
type
=
=
=
"
object
"
;
}
function
nodeIsPrimitive
(
item
)
{
return
!
nodeHasChildren
(
item
)
&
&
!
nodeHasProperties
(
item
)
;
}
function
createNode
(
name
path
contents
)
{
return
{
name
path
contents
}
;
}
var
ObjectInspector
=
React
.
createClass
(
{
propTypes
:
{
name
:
PropTypes
.
string
desc
:
PropTypes
.
object
roots
:
PropTypes
.
array
getObjectProperties
:
PropTypes
.
func
.
isRequired
loadObjectProperties
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
ObjectInspector
"
getInitialState
(
)
{
this
.
actorCache
=
{
}
;
return
{
}
;
}
makeNodesForProperties
(
objProps
parentPath
)
{
var
ownProperties
=
objProps
.
ownProperties
;
var
prototype
=
objProps
.
prototype
;
var
nodes
=
Object
.
keys
(
ownProperties
)
.
filter
(
name
=
>
{
return
"
value
"
in
ownProperties
[
name
]
;
}
)
.
map
(
name
=
>
{
return
createNode
(
name
parentPath
+
"
/
"
+
name
ownProperties
[
name
]
)
;
}
)
;
if
(
prototype
&
&
prototype
.
type
!
=
=
"
null
"
)
{
nodes
.
push
(
createNode
(
"
__proto__
"
parentPath
+
"
/
__proto__
"
{
value
:
prototype
}
)
)
;
}
return
nodes
;
}
getChildren
(
item
)
{
var
getObjectProperties
=
this
.
props
.
getObjectProperties
;
var
obj
=
item
.
contents
;
if
(
nodeHasChildren
(
item
)
)
{
return
item
.
contents
;
}
else
if
(
nodeHasProperties
(
item
)
)
{
var
actor
=
obj
.
value
.
actor
;
if
(
this
.
actorCache
[
actor
]
)
{
return
this
.
actorCache
[
actor
]
;
}
var
loadedProps
=
getObjectProperties
(
actor
)
;
if
(
loadedProps
)
{
var
children
=
this
.
makeNodesForProperties
(
loadedProps
item
.
path
)
;
this
.
actorCache
[
actor
]
=
children
;
return
children
;
}
return
[
]
;
}
return
[
]
;
}
renderItem
(
item
depth
focused
_
expanded
_ref
)
{
var
setExpanded
=
_ref
.
setExpanded
;
var
objectValue
=
void
0
;
if
(
nodeHasProperties
(
item
)
|
|
nodeIsPrimitive
(
item
)
)
{
var
object
=
item
.
contents
.
value
;
objectValue
=
Rep
(
{
object
mode
:
"
tiny
"
}
)
;
}
return
dom
.
div
(
{
className
:
classnames
(
"
node
"
{
focused
}
)
style
:
{
marginLeft
:
depth
*
15
}
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
setExpanded
(
item
!
expanded
)
;
}
}
Arrow
(
{
className
:
classnames
(
{
expanded
:
expanded
hidden
:
nodeIsPrimitive
(
item
)
}
)
}
)
dom
.
span
(
{
className
:
"
object
-
label
"
}
item
.
name
)
dom
.
span
(
{
className
:
"
object
-
delimiter
"
}
objectValue
?
"
:
"
:
"
"
)
dom
.
span
(
{
className
:
"
object
-
value
"
}
objectValue
|
|
"
"
)
)
;
}
render
(
)
{
var
_props
=
this
.
props
;
var
name
=
_props
.
name
;
var
desc
=
_props
.
desc
;
var
loadObjectProperties
=
_props
.
loadObjectProperties
;
var
roots
=
this
.
props
.
roots
;
if
(
!
roots
)
{
roots
=
[
createNode
(
name
name
desc
)
]
;
}
return
ManagedTree
(
{
itemHeight
:
20
getParent
:
item
=
>
null
getChildren
:
this
.
getChildren
getRoots
:
(
)
=
>
roots
getKey
:
item
=
>
item
.
path
autoExpand
:
0
disabledFocus
:
true
onExpand
:
item
=
>
{
if
(
nodeHasProperties
(
item
)
)
{
loadObjectProperties
(
item
.
contents
.
value
)
;
}
}
renderItem
:
this
.
renderItem
}
)
;
}
}
)
;
module
.
exports
=
ObjectInspector
;
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
InlineSVG
=
__webpack_require__
(
237
)
;
var
dom
=
React
.
DOM
;
__webpack_require__
(
311
)
;
var
Arrow
=
props
=
>
{
var
className
=
"
arrow
"
+
(
props
.
className
|
|
"
"
)
;
return
dom
.
span
(
Object
.
assign
(
{
}
props
{
className
}
)
React
.
createElement
(
InlineSVG
{
src
:
__webpack_require__
(
239
)
}
)
)
;
}
;
module
.
exports
=
Arrow
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
createToPairs
=
__webpack_require__
(
314
)
keys
=
__webpack_require__
(
324
)
;
var
toPairs
=
createToPairs
(
keys
)
;
module
.
exports
=
toPairs
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseToPairs
=
__webpack_require__
(
315
)
getTag
=
__webpack_require__
(
317
)
mapToArray
=
__webpack_require__
(
322
)
setToPairs
=
__webpack_require__
(
323
)
;
var
mapTag
=
'
[
object
Map
]
'
setTag
=
'
[
object
Set
]
'
;
function
createToPairs
(
keysFunc
)
{
return
function
(
object
)
{
var
tag
=
getTag
(
object
)
;
if
(
tag
=
=
mapTag
)
{
return
mapToArray
(
object
)
;
}
if
(
tag
=
=
setTag
)
{
return
setToPairs
(
object
)
;
}
return
baseToPairs
(
object
keysFunc
(
object
)
)
;
}
;
}
module
.
exports
=
createToPairs
;
}
function
(
module
exports
__webpack_require__
)
{
var
arrayMap
=
__webpack_require__
(
316
)
;
function
baseToPairs
(
object
props
)
{
return
arrayMap
(
props
function
(
key
)
{
return
[
key
object
[
key
]
]
;
}
)
;
}
module
.
exports
=
baseToPairs
;
}
function
(
module
exports
)
{
function
arrayMap
(
array
iteratee
)
{
var
index
=
-
1
length
=
array
?
array
.
length
:
0
result
=
Array
(
length
)
;
while
(
+
+
index
<
length
)
{
result
[
index
]
=
iteratee
(
array
[
index
]
index
array
)
;
}
return
result
;
}
module
.
exports
=
arrayMap
;
}
function
(
module
exports
__webpack_require__
)
{
var
DataView
=
__webpack_require__
(
318
)
Map
=
__webpack_require__
(
82
)
Promise
=
__webpack_require__
(
319
)
Set
=
__webpack_require__
(
320
)
WeakMap
=
__webpack_require__
(
321
)
toSource
=
__webpack_require__
(
68
)
;
var
mapTag
=
'
[
object
Map
]
'
objectTag
=
'
[
object
Object
]
'
promiseTag
=
'
[
object
Promise
]
'
setTag
=
'
[
object
Set
]
'
weakMapTag
=
'
[
object
WeakMap
]
'
;
var
dataViewTag
=
'
[
object
DataView
]
'
;
var
objectProto
=
Object
.
prototype
;
var
objectToString
=
objectProto
.
toString
;
var
dataViewCtorString
=
toSource
(
DataView
)
mapCtorString
=
toSource
(
Map
)
promiseCtorString
=
toSource
(
Promise
)
setCtorString
=
toSource
(
Set
)
weakMapCtorString
=
toSource
(
WeakMap
)
;
function
getTag
(
value
)
{
return
objectToString
.
call
(
value
)
;
}
if
(
(
DataView
&
&
getTag
(
new
DataView
(
new
ArrayBuffer
(
1
)
)
)
!
=
dataViewTag
)
|
|
(
Map
&
&
getTag
(
new
Map
)
!
=
mapTag
)
|
|
(
Promise
&
&
getTag
(
Promise
.
resolve
(
)
)
!
=
promiseTag
)
|
|
(
Set
&
&
getTag
(
new
Set
)
!
=
setTag
)
|
|
(
WeakMap
&
&
getTag
(
new
WeakMap
)
!
=
weakMapTag
)
)
{
getTag
=
function
(
value
)
{
var
result
=
objectToString
.
call
(
value
)
Ctor
=
result
=
=
objectTag
?
value
.
constructor
:
undefined
ctorString
=
Ctor
?
toSource
(
Ctor
)
:
undefined
;
if
(
ctorString
)
{
switch
(
ctorString
)
{
case
dataViewCtorString
:
return
dataViewTag
;
case
mapCtorString
:
return
mapTag
;
case
promiseCtorString
:
return
promiseTag
;
case
setCtorString
:
return
setTag
;
case
weakMapCtorString
:
return
weakMapTag
;
}
}
return
result
;
}
;
}
module
.
exports
=
getTag
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
60
)
root
=
__webpack_require__
(
66
)
;
var
DataView
=
getNative
(
root
'
DataView
'
)
;
module
.
exports
=
DataView
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
60
)
root
=
__webpack_require__
(
66
)
;
var
Promise
=
getNative
(
root
'
Promise
'
)
;
module
.
exports
=
Promise
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
60
)
root
=
__webpack_require__
(
66
)
;
var
Set
=
getNative
(
root
'
Set
'
)
;
module
.
exports
=
Set
;
}
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
60
)
root
=
__webpack_require__
(
66
)
;
var
WeakMap
=
getNative
(
root
'
WeakMap
'
)
;
module
.
exports
=
WeakMap
;
}
function
(
module
exports
)
{
function
mapToArray
(
map
)
{
var
index
=
-
1
result
=
Array
(
map
.
size
)
;
map
.
forEach
(
function
(
value
key
)
{
result
[
+
+
index
]
=
[
key
value
]
;
}
)
;
return
result
;
}
module
.
exports
=
mapToArray
;
}
function
(
module
exports
)
{
function
setToPairs
(
set
)
{
var
index
=
-
1
result
=
Array
(
set
.
size
)
;
set
.
forEach
(
function
(
value
)
{
result
[
+
+
index
]
=
[
value
value
]
;
}
)
;
return
result
;
}
module
.
exports
=
setToPairs
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseHas
=
__webpack_require__
(
325
)
baseKeys
=
__webpack_require__
(
326
)
indexKeys
=
__webpack_require__
(
327
)
isArrayLike
=
__webpack_require__
(
331
)
isIndex
=
__webpack_require__
(
336
)
isPrototype
=
__webpack_require__
(
337
)
;
function
keys
(
object
)
{
var
isProto
=
isPrototype
(
object
)
;
if
(
!
(
isProto
|
|
isArrayLike
(
object
)
)
)
{
return
baseKeys
(
object
)
;
}
var
indexes
=
indexKeys
(
object
)
skipIndexes
=
!
!
indexes
result
=
indexes
|
|
[
]
length
=
result
.
length
;
for
(
var
key
in
object
)
{
if
(
baseHas
(
object
key
)
&
&
!
(
skipIndexes
&
&
(
key
=
=
'
length
'
|
|
isIndex
(
key
length
)
)
)
&
&
!
(
isProto
&
&
key
=
=
'
constructor
'
)
)
{
result
.
push
(
key
)
;
}
}
return
result
;
}
module
.
exports
=
keys
;
}
function
(
module
exports
__webpack_require__
)
{
var
getPrototype
=
__webpack_require__
(
5
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
baseHas
(
object
key
)
{
return
object
!
=
null
&
&
(
hasOwnProperty
.
call
(
object
key
)
|
|
(
typeof
object
=
=
'
object
'
&
&
key
in
object
&
&
getPrototype
(
object
)
=
=
=
null
)
)
;
}
module
.
exports
=
baseHas
;
}
function
(
module
exports
)
{
var
nativeKeys
=
Object
.
keys
;
function
baseKeys
(
object
)
{
return
nativeKeys
(
Object
(
object
)
)
;
}
module
.
exports
=
baseKeys
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseTimes
=
__webpack_require__
(
328
)
isArguments
=
__webpack_require__
(
329
)
isArray
=
__webpack_require__
(
52
)
isLength
=
__webpack_require__
(
334
)
isString
=
__webpack_require__
(
335
)
;
function
indexKeys
(
object
)
{
var
length
=
object
?
object
.
length
:
undefined
;
if
(
isLength
(
length
)
&
&
(
isArray
(
object
)
|
|
isString
(
object
)
|
|
isArguments
(
object
)
)
)
{
return
baseTimes
(
length
String
)
;
}
return
null
;
}
module
.
exports
=
indexKeys
;
}
function
(
module
exports
)
{
function
baseTimes
(
n
iteratee
)
{
var
index
=
-
1
result
=
Array
(
n
)
;
while
(
+
+
index
<
n
)
{
result
[
index
]
=
iteratee
(
index
)
;
}
return
result
;
}
module
.
exports
=
baseTimes
;
}
function
(
module
exports
__webpack_require__
)
{
var
isArrayLikeObject
=
__webpack_require__
(
330
)
;
var
argsTag
=
'
[
object
Arguments
]
'
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
objectToString
=
objectProto
.
toString
;
var
propertyIsEnumerable
=
objectProto
.
propertyIsEnumerable
;
function
isArguments
(
value
)
{
return
isArrayLikeObject
(
value
)
&
&
hasOwnProperty
.
call
(
value
'
callee
'
)
&
&
(
!
propertyIsEnumerable
.
call
(
value
'
callee
'
)
|
|
objectToString
.
call
(
value
)
=
=
argsTag
)
;
}
module
.
exports
=
isArguments
;
}
function
(
module
exports
__webpack_require__
)
{
var
isArrayLike
=
__webpack_require__
(
331
)
isObjectLike
=
__webpack_require__
(
7
)
;
function
isArrayLikeObject
(
value
)
{
return
isObjectLike
(
value
)
&
&
isArrayLike
(
value
)
;
}
module
.
exports
=
isArrayLikeObject
;
}
function
(
module
exports
__webpack_require__
)
{
var
getLength
=
__webpack_require__
(
332
)
isFunction
=
__webpack_require__
(
62
)
isLength
=
__webpack_require__
(
334
)
;
function
isArrayLike
(
value
)
{
return
value
!
=
null
&
&
isLength
(
getLength
(
value
)
)
&
&
!
isFunction
(
value
)
;
}
module
.
exports
=
isArrayLike
;
}
function
(
module
exports
__webpack_require__
)
{
var
baseProperty
=
__webpack_require__
(
333
)
;
var
getLength
=
baseProperty
(
'
length
'
)
;
module
.
exports
=
getLength
;
}
function
(
module
exports
)
{
function
baseProperty
(
key
)
{
return
function
(
object
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
;
}
module
.
exports
=
baseProperty
;
}
function
(
module
exports
)
{
var
MAX_SAFE_INTEGER
=
9007199254740991
;
function
isLength
(
value
)
{
return
typeof
value
=
=
'
number
'
&
&
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
=
MAX_SAFE_INTEGER
;
}
module
.
exports
=
isLength
;
}
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
52
)
isObjectLike
=
__webpack_require__
(
7
)
;
var
stringTag
=
'
[
object
String
]
'
;
var
objectProto
=
Object
.
prototype
;
var
objectToString
=
objectProto
.
toString
;
function
isString
(
value
)
{
return
typeof
value
=
=
'
string
'
|
|
(
!
isArray
(
value
)
&
&
isObjectLike
(
value
)
&
&
objectToString
.
call
(
value
)
=
=
stringTag
)
;
}
module
.
exports
=
isString
;
}
function
(
module
exports
)
{
var
MAX_SAFE_INTEGER
=
9007199254740991
;
var
reIsUint
=
/
^
(
?
:
0
|
[
1
-
9
]
\
d
*
)
/
;
function
isIndex
(
value
length
)
{
length
=
length
=
=
null
?
MAX_SAFE_INTEGER
:
length
;
return
!
!
length
&
&
(
typeof
value
=
=
'
number
'
|
|
reIsUint
.
test
(
value
)
)
&
&
(
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
length
)
;
}
module
.
exports
=
isIndex
;
}
function
(
module
exports
)
{
var
objectProto
=
Object
.
prototype
;
function
isPrototype
(
value
)
{
var
Ctor
=
value
&
&
value
.
constructor
proto
=
(
typeof
Ctor
=
=
'
function
'
&
&
Ctor
.
prototype
)
|
|
objectProto
;
return
value
=
=
=
proto
;
}
module
.
exports
=
isPrototype
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
div
=
dom
.
div
;
var
_require
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require
.
bindActionCreators
;
var
_require2
=
__webpack_require__
(
15
)
;
var
connect
=
_require2
.
connect
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require3
=
__webpack_require__
(
176
)
;
var
endTruncateStr
=
_require3
.
endTruncateStr
;
var
_require4
=
__webpack_require__
(
205
)
;
var
basename
=
_require4
.
basename
;
var
_require5
=
__webpack_require__
(
199
)
;
var
getFrames
=
_require5
.
getFrames
;
var
getSelectedFrame
=
_require5
.
getSelectedFrame
;
var
getSource
=
_require5
.
getSource
;
if
(
typeof
window
=
=
"
object
"
)
{
__webpack_require__
(
341
)
;
}
function
renderFrameTitle
(
frame
)
{
return
div
(
{
className
:
"
title
"
}
endTruncateStr
(
frame
.
displayName
40
)
)
;
}
function
renderFrameLocation
(
frame
)
{
var
url
=
frame
.
source
.
url
?
basename
(
frame
.
source
.
url
)
:
"
"
;
var
line
=
url
!
=
=
"
"
?
:
{
frame
.
location
.
line
}
:
"
"
;
return
url
!
=
=
"
"
?
div
(
{
className
:
"
location
"
}
{
endTruncateStr
(
url
30
)
}
{
line
}
)
:
null
;
}
function
renderFrame
(
frame
selectedFrame
selectFrame
)
{
var
selectedClass
=
selectedFrame
&
&
(
selectedFrame
.
id
=
=
=
frame
.
id
?
"
selected
"
:
"
"
)
;
return
dom
.
li
(
{
key
:
frame
.
id
className
:
frame
{
selectedClass
}
onClick
:
(
)
=
>
selectFrame
(
frame
)
}
renderFrameTitle
(
frame
)
renderFrameLocation
(
frame
)
)
;
}
function
Frames
(
_ref
)
{
var
frames
=
_ref
.
frames
;
var
selectedFrame
=
_ref
.
selectedFrame
;
var
selectFrame
=
_ref
.
selectFrame
;
return
div
(
{
className
:
"
pane
frames
"
}
frames
.
length
=
=
=
0
?
div
(
{
className
:
"
pane
-
info
empty
"
}
"
Not
Paused
"
)
:
dom
.
ul
(
null
frames
.
map
(
frame
=
>
{
return
renderFrame
(
frame
selectedFrame
selectFrame
)
;
}
)
)
)
;
}
module
.
exports
=
connect
(
state
=
>
(
{
frames
:
getFrames
(
state
)
.
filter
(
frame
=
>
getSource
(
state
frame
.
location
.
sourceId
)
)
.
map
(
frame
=
>
{
return
Object
.
assign
(
{
}
frame
{
source
:
getSource
(
state
frame
.
location
.
sourceId
)
.
toJS
(
)
}
)
;
}
)
selectedFrame
:
getSelectedFrame
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
Frames
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
div
=
dom
.
div
;
var
Svg
=
__webpack_require__
(
235
)
;
__webpack_require__
(
344
)
;
var
Accordion
=
React
.
createClass
(
{
propTypes
:
{
items
:
PropTypes
.
array
}
displayName
:
"
Accordion
"
getInitialState
:
function
(
)
{
return
{
opened
:
this
.
props
.
items
.
map
(
item
=
>
item
.
opened
)
created
:
[
]
}
;
}
handleHeaderClick
:
function
(
i
)
{
var
opened
=
[
]
.
concat
(
_toConsumableArray
(
this
.
state
.
opened
)
)
;
var
created
=
[
]
.
concat
(
_toConsumableArray
(
this
.
state
.
created
)
)
;
var
item
=
this
.
props
.
items
[
i
]
;
opened
[
i
]
=
!
opened
[
i
]
;
created
[
i
]
=
true
;
if
(
opened
[
i
]
&
&
item
.
onOpened
)
{
item
.
onOpened
(
)
;
}
this
.
setState
(
{
opened
created
}
)
;
}
renderContainer
:
function
(
item
i
)
{
var
_state
=
this
.
state
;
var
opened
=
_state
.
opened
;
var
created
=
_state
.
created
;
var
containerClassName
=
item
.
header
.
toLowerCase
(
)
.
replace
(
/
\
s
/
g
"
-
"
)
+
"
-
pane
"
;
return
div
(
{
className
:
containerClassName
key
:
i
}
div
(
{
className
:
"
_header
"
onClick
:
(
)
=
>
this
.
handleHeaderClick
(
i
)
}
Svg
(
"
arrow
"
{
className
:
opened
[
i
]
?
"
expanded
"
:
"
"
}
)
item
.
header
)
created
[
i
]
|
|
opened
[
i
]
?
div
(
{
className
:
"
_content
"
style
:
{
display
:
opened
[
i
]
?
"
block
"
:
"
none
"
}
}
React
.
createElement
(
item
.
component
item
.
componentProps
|
|
{
}
)
)
:
null
)
;
}
render
:
function
(
)
{
return
div
(
{
className
:
"
accordion
"
}
this
.
props
.
items
.
map
(
this
.
renderContainer
)
)
;
}
}
)
;
module
.
exports
=
Accordion
;
}
function
(
module
exports
)
{
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
Svg
=
__webpack_require__
(
235
)
;
var
_require3
=
__webpack_require__
(
199
)
;
var
getSelectedSource
=
_require3
.
getSelectedSource
;
var
getSourceTabs
=
_require3
.
getSourceTabs
;
var
_require4
=
__webpack_require__
(
176
)
;
var
endTruncateStr
=
_require4
.
endTruncateStr
;
var
classnames
=
__webpack_require__
(
207
)
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require5
=
__webpack_require__
(
46
)
;
var
isEnabled
=
_require5
.
isEnabled
;
__webpack_require__
(
349
)
;
__webpack_require__
(
351
)
;
function
getFilename
(
url
)
{
if
(
!
url
)
{
return
"
"
;
}
var
name
=
url
;
var
m
=
url
.
toString
(
)
.
match
(
/
.
*
\
/
(
.
+
?
\
.
.
*
)
/
)
;
if
(
m
&
&
m
.
length
>
1
)
{
name
=
m
[
1
]
;
}
return
endTruncateStr
(
name
50
)
;
}
function
getHiddenTabs
(
sourceTabs
sourceTabEls
)
{
sourceTabEls
=
[
]
.
slice
.
call
(
sourceTabEls
)
;
function
getTopOffset
(
)
{
var
topOffsets
=
sourceTabEls
.
map
(
t
=
>
t
.
getBoundingClientRect
(
)
.
top
)
;
return
Math
.
min
.
apply
(
Math
_toConsumableArray
(
topOffsets
)
)
;
}
var
tabTopOffset
=
getTopOffset
(
)
;
return
sourceTabs
.
filter
(
(
tab
index
)
=
>
{
return
sourceTabEls
[
index
]
.
getBoundingClientRect
(
)
.
top
>
tabTopOffset
;
}
)
;
}
function
getLastVisibleTabIndex
(
sourceTabs
sourceTabEls
)
{
var
hiddenTabs
=
getHiddenTabs
(
sourceTabs
sourceTabEls
)
;
var
firstHiddenTab
=
hiddenTabs
.
first
(
)
;
var
firstHiddenTabIndex
=
sourceTabs
.
indexOf
(
firstHiddenTab
)
;
return
firstHiddenTabIndex
-
1
;
}
var
SourceTabs
=
React
.
createClass
(
{
propTypes
:
{
sourceTabs
:
ImPropTypes
.
list
selectedSource
:
ImPropTypes
.
map
selectSource
:
PropTypes
.
func
.
isRequired
closeTab
:
PropTypes
.
func
.
isRequired
}
displayName
:
"
SourceTabs
"
getInitialState
(
)
{
return
{
dropdownShown
:
false
hiddenSourceTabs
:
null
}
;
}
componentDidUpdate
(
)
{
this
.
updateHiddenSourceTabs
(
this
.
props
.
sourceTabs
)
;
}
updateHiddenSourceTabs
(
sourceTabs
)
{
if
(
!
this
.
refs
.
sourceTabs
)
{
return
;
}
var
sourceTabEls
=
this
.
refs
.
sourceTabs
.
children
;
var
hiddenSourceTabs
=
getHiddenTabs
(
sourceTabs
sourceTabEls
)
;
if
(
!
hiddenSourceTabs
.
equals
(
this
.
state
.
hiddenSourceTabs
)
)
{
this
.
setState
(
{
hiddenSourceTabs
}
)
;
}
}
toggleSourcesDropdown
(
e
)
{
this
.
setState
(
{
dropdownShown
:
!
this
.
state
.
dropdownShown
}
)
;
}
renderSourcesDropdown
(
)
{
if
(
!
this
.
state
.
hiddenSourceTabs
)
{
return
dom
.
div
(
{
}
)
;
}
return
dom
.
div
(
{
className
:
"
sources
-
dropdown
dropdown
"
ref
:
"
sourcesDropdown
"
style
:
{
display
:
this
.
state
.
dropdownShown
?
"
block
"
:
"
none
"
}
}
dom
.
ul
(
{
}
this
.
state
.
hiddenSourceTabs
.
map
(
this
.
renderDropdownSource
)
)
)
;
}
renderDropdownSource
(
source
)
{
var
_props
=
this
.
props
;
var
selectSource
=
_props
.
selectSource
;
var
sourceTabs
=
_props
.
sourceTabs
;
var
url
=
source
&
&
source
.
get
(
"
url
"
)
;
var
filename
=
getFilename
(
url
)
;
var
sourceTabEls
=
this
.
refs
.
sourceTabs
.
children
;
return
dom
.
li
(
{
key
:
source
.
get
(
"
id
"
)
onClick
:
(
)
=
>
{
var
tabIndex
=
getLastVisibleTabIndex
(
sourceTabs
sourceTabEls
)
;
selectSource
(
source
.
get
(
"
id
"
)
{
tabIndex
}
)
;
this
.
toggleSourcesDropdown
(
)
;
}
}
filename
)
;
}
renderSourcesDropdownButon
(
)
{
var
hiddenSourceTabs
=
this
.
state
.
hiddenSourceTabs
;
if
(
!
hiddenSourceTabs
|
|
hiddenSourceTabs
.
size
=
=
0
)
{
return
dom
.
div
(
{
}
)
;
}
return
dom
.
span
(
{
className
:
"
subsettings
"
onClick
:
this
.
toggleSourcesDropdown
}
dom
.
img
(
{
src
:
"
images
/
subSettings
.
svg
"
}
)
)
;
}
renderTabs
(
)
{
var
sourceTabs
=
this
.
props
.
sourceTabs
;
return
dom
.
div
(
{
className
:
"
source
-
tabs
"
ref
:
"
sourceTabs
"
}
sourceTabs
.
map
(
this
.
renderTab
)
)
;
}
renderTab
(
source
)
{
var
_props2
=
this
.
props
;
var
selectedSource
=
_props2
.
selectedSource
;
var
selectSource
=
_props2
.
selectSource
;
var
closeTab
=
_props2
.
closeTab
;
var
url
=
source
&
&
source
.
get
(
"
url
"
)
;
var
filename
=
getFilename
(
url
)
;
var
active
=
source
.
get
(
"
id
"
)
=
=
selectedSource
.
get
(
"
id
"
)
;
function
onClickClose
(
ev
)
{
ev
.
stopPropagation
(
)
;
closeTab
(
source
.
get
(
"
id
"
)
)
;
}
return
dom
.
div
(
{
className
:
classnames
(
"
source
-
tab
"
{
active
}
)
key
:
source
.
get
(
"
id
"
)
onClick
:
(
)
=
>
selectSource
(
source
.
get
(
"
id
"
)
)
title
:
url
}
dom
.
div
(
{
className
:
"
filename
"
}
filename
)
dom
.
div
(
{
onClick
:
onClickClose
}
dom
.
span
(
{
className
:
"
close
-
btn
"
}
Svg
(
"
close
"
)
)
)
)
;
}
render
(
)
{
if
(
!
isEnabled
(
"
tabs
"
)
)
{
return
dom
.
div
(
{
className
:
"
source
-
header
"
}
)
;
}
return
dom
.
div
(
{
className
:
"
source
-
header
"
}
this
.
renderSourcesDropdown
(
)
this
.
renderTabs
(
)
this
.
renderSourcesDropdownButon
(
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
(
{
selectedSource
:
getSelectedSource
(
state
)
sourceTabs
:
getSourceTabs
(
state
)
}
)
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
SourceTabs
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
_require
=
__webpack_require__
(
15
)
;
var
connect
=
_require
.
connect
;
var
_require2
=
__webpack_require__
(
2
)
;
var
bindActionCreators
=
_require2
.
bindActionCreators
;
var
actions
=
__webpack_require__
(
214
)
;
var
_require3
=
__webpack_require__
(
46
)
;
var
isEnabled
=
_require3
.
isEnabled
;
var
_require4
=
__webpack_require__
(
199
)
;
var
getSelectedSource
=
_require4
.
getSelectedSource
;
var
getSourceText
=
_require4
.
getSourceText
;
var
getPrettySource
=
_require4
.
getPrettySource
;
var
Svg
=
__webpack_require__
(
235
)
;
var
ImPropTypes
=
__webpack_require__
(
228
)
;
var
classnames
=
__webpack_require__
(
207
)
;
var
_require5
=
__webpack_require__
(
216
)
;
var
isMapped
=
_require5
.
isMapped
;
var
getGeneratedSourceId
=
_require5
.
getGeneratedSourceId
;
var
isOriginal
=
_require5
.
isOriginal
;
var
_require6
=
__webpack_require__
(
220
)
;
var
isPretty
=
_require6
.
isPretty
;
__webpack_require__
(
354
)
;
function
debugBtn
(
onClick
type
)
{
var
className
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
"
active
"
:
arguments
[
2
]
;
var
tooltip
=
arguments
[
3
]
;
className
=
{
type
}
{
className
}
;
return
dom
.
span
(
{
onClick
className
key
:
type
}
Svg
(
type
{
title
:
tooltip
}
)
)
;
}
var
SourceFooter
=
React
.
createClass
(
{
propTypes
:
{
selectedSource
:
ImPropTypes
.
map
togglePrettyPrint
:
PropTypes
.
func
sourceText
:
ImPropTypes
.
map
selectSource
:
PropTypes
.
func
prettySource
:
ImPropTypes
.
map
}
displayName
:
"
SourceFooter
"
blackboxButton
(
)
{
if
(
!
isEnabled
(
"
blackbox
"
)
)
{
return
null
;
}
return
debugBtn
(
(
)
=
>
{
}
"
blackBox
"
this
.
props
.
selectedSource
"
Toggle
Black
Boxing
"
)
;
}
onClickPrettyPrint
(
)
{
var
_props
=
this
.
props
;
var
selectedSource
=
_props
.
selectedSource
;
var
togglePrettyPrint
=
_props
.
togglePrettyPrint
;
var
selectSource
=
_props
.
selectSource
;
var
prettySource
=
_props
.
prettySource
;
if
(
isPretty
(
selectedSource
.
toJS
(
)
)
)
{
return
selectSource
(
getGeneratedSourceId
(
selectedSource
.
toJS
(
)
)
)
;
}
if
(
selectedSource
.
get
(
"
isPrettyPrinted
"
)
)
{
return
selectSource
(
prettySource
.
get
(
"
id
"
)
)
;
}
togglePrettyPrint
(
selectedSource
.
get
(
"
id
"
)
)
;
}
prettyPrintButton
(
)
{
var
_props2
=
this
.
props
;
var
selectedSource
=
_props2
.
selectedSource
;
var
sourceText
=
_props2
.
sourceText
;
var
sourceLoaded
=
selectedSource
&
&
!
sourceText
.
get
(
"
loading
"
)
;
if
(
isMapped
(
selectedSource
.
toJS
(
)
)
|
|
isOriginal
(
selectedSource
.
toJS
(
)
)
&
&
!
isPretty
(
selectedSource
.
toJS
(
)
)
)
{
return
;
}
return
debugBtn
(
this
.
onClickPrettyPrint
"
prettyPrint
"
classnames
(
{
active
:
sourceLoaded
pretty
:
isPretty
(
selectedSource
.
toJS
(
)
)
}
)
"
Prettify
Source
"
)
;
}
render
(
)
{
if
(
!
this
.
props
.
selectedSource
|
|
!
isEnabled
(
"
prettyPrint
"
)
&
&
!
isEnabled
(
"
blackBox
"
)
)
{
return
null
;
}
return
dom
.
div
(
{
className
:
"
source
-
footer
"
}
dom
.
div
(
{
className
:
"
command
-
bar
"
}
this
.
blackboxButton
(
)
this
.
prettyPrintButton
(
)
)
)
;
}
}
)
;
module
.
exports
=
connect
(
state
=
>
{
var
selectedSource
=
getSelectedSource
(
state
)
;
var
selectedId
=
selectedSource
&
&
selectedSource
.
get
(
"
id
"
)
;
return
{
selectedSource
sourceText
:
getSourceText
(
state
selectedId
)
prettySource
:
getPrettySource
(
state
selectedId
)
}
;
}
dispatch
=
>
bindActionCreators
(
actions
dispatch
)
)
(
SourceFooter
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
var
React
=
__webpack_require__
(
17
)
;
var
dom
=
React
.
DOM
;
var
PropTypes
=
React
.
PropTypes
;
var
_require
=
__webpack_require__
(
357
)
;
var
filter
=
_require
.
filter
;
var
classnames
=
__webpack_require__
(
207
)
;
__webpack_require__
(
363
)
;
var
Svg
=
__webpack_require__
(
235
)
;
var
INITIAL_SELECTED_INDEX
=
0
;
var
Autocomplete
=
React
.
createClass
(
{
propTypes
:
{
selectItem
:
PropTypes
.
func
items
:
PropTypes
.
array
}
displayName
:
"
Autocomplete
"
getInitialState
(
)
{
return
{
inputValue
:
"
"
selectedIndex
:
INITIAL_SELECTED_INDEX
}
;
}
componentDidMount
(
)
{
this
.
refs
.
searchInput
.
focus
(
)
;
}
componentDidUpdate
(
)
{
this
.
scrollList
(
)
;
}
scrollList
(
)
{
var
resultsEl
=
this
.
refs
.
results
;
if
(
resultsEl
.
children
.
length
=
=
=
0
)
{
return
;
}
var
resultsHeight
=
resultsEl
.
clientHeight
;
var
itemHeight
=
resultsEl
.
children
[
0
]
.
clientHeight
;
var
numVisible
=
resultsHeight
/
itemHeight
;
var
positionsToScroll
=
this
.
state
.
selectedIndex
-
numVisible
+
1
;
var
itemOffset
=
resultsHeight
%
itemHeight
;
var
scroll
=
positionsToScroll
*
(
itemHeight
+
2
)
+
itemOffset
;
resultsEl
.
scrollTop
=
Math
.
max
(
0
scroll
)
;
}
renderSearchItem
(
result
index
)
{
return
dom
.
li
(
{
onClick
:
(
)
=
>
this
.
props
.
selectItem
(
result
)
key
:
result
.
value
className
:
classnames
(
{
selected
:
index
=
=
=
this
.
state
.
selectedIndex
}
)
}
dom
.
div
(
{
className
:
"
title
"
}
result
.
title
)
dom
.
div
(
{
className
:
"
subtitle
"
}
result
.
subtitle
)
)
;
}
renderInput
(
)
{
return
dom
.
input
(
{
ref
:
"
searchInput
"
onChange
:
e
=
>
this
.
setState
(
{
inputValue
:
e
.
target
.
value
selectedIndex
:
INITIAL_SELECTED_INDEX
}
)
onFocus
:
e
=
>
this
.
setState
(
{
focused
:
true
}
)
onBlur
:
e
=
>
this
.
setState
(
{
focused
:
false
}
)
onKeyDown
:
this
.
onKeyDown
placeholder
:
"
Search
.
.
.
"
}
)
;
}
getSearchResults
(
)
{
var
inputValue
=
this
.
state
.
inputValue
;
if
(
inputValue
=
=
"
"
)
{
return
[
]
;
}
return
filter
(
this
.
props
.
items
this
.
state
.
inputValue
{
key
:
"
value
"
}
)
;
}
onKeyDown
(
e
)
{
var
searchResults
=
this
.
getSearchResults
(
)
resultCount
=
searchResults
.
length
;
if
(
e
.
key
=
=
=
"
ArrowUp
"
)
{
this
.
setState
(
{
selectedIndex
:
Math
.
max
(
0
this
.
state
.
selectedIndex
-
1
)
}
)
;
e
.
preventDefault
(
)
;
}
else
if
(
e
.
key
=
=
=
"
ArrowDown
"
)
{
this
.
setState
(
{
selectedIndex
:
Math
.
min
(
resultCount
-
1
this
.
state
.
selectedIndex
+
1
)
}
)
;
e
.
preventDefault
(
)
;
}
else
if
(
e
.
key
=
=
=
"
Enter
"
)
{
this
.
props
.
selectItem
(
searchResults
[
this
.
state
.
selectedIndex
]
)
;
e
.
preventDefault
(
)
;
}
}
render
(
)
{
var
searchResults
=
this
.
getSearchResults
(
)
;
return
dom
.
div
(
{
className
:
classnames
(
{
autocomplete
:
true
focused
:
this
.
state
.
focused
}
)
}
new
Svg
(
"
magnifying
-
glass
"
)
this
.
renderInput
(
)
dom
.
ul
(
{
className
:
"
results
"
ref
:
"
results
"
}
searchResults
.
map
(
this
.
renderSearchItem
)
)
)
;
}
}
)
;
module
.
exports
=
Autocomplete
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
filter
legacy_scorer
matcher
prepQueryCache
scorer
;
scorer
=
__webpack_require__
(
358
)
;
legacy_scorer
=
__webpack_require__
(
360
)
;
filter
=
__webpack_require__
(
361
)
;
matcher
=
__webpack_require__
(
362
)
;
PathSeparator
=
__webpack_require__
(
359
)
.
sep
;
prepQueryCache
=
null
;
module
.
exports
=
{
filter
:
function
(
candidates
query
options
)
{
if
(
!
(
(
query
!
=
null
?
query
.
length
:
void
0
)
&
&
(
candidates
!
=
null
?
candidates
.
length
:
void
0
)
)
)
{
return
[
]
;
}
return
filter
(
candidates
query
options
)
;
}
prepQuery
:
function
(
query
)
{
return
scorer
.
prepQuery
(
query
)
;
}
score
:
function
(
string
query
prepQuery
_arg
)
{
var
allowErrors
coreQuery
legacy
queryHasSlashes
score
_ref
;
_ref
=
_arg
!
=
null
?
_arg
:
{
}
allowErrors
=
_ref
.
allowErrors
legacy
=
_ref
.
legacy
;
if
(
!
(
(
string
!
=
null
?
string
.
length
:
void
0
)
&
&
(
query
!
=
null
?
query
.
length
:
void
0
)
)
)
{
return
0
;
}
if
(
prepQuery
=
=
null
)
{
prepQuery
=
prepQueryCache
&
&
prepQueryCache
.
query
=
=
=
query
?
prepQueryCache
:
(
prepQueryCache
=
scorer
.
prepQuery
(
query
)
)
;
}
if
(
!
legacy
)
{
score
=
scorer
.
score
(
string
query
prepQuery
!
!
allowErrors
)
;
}
else
{
queryHasSlashes
=
prepQuery
.
depth
>
0
;
coreQuery
=
prepQuery
.
core
;
score
=
legacy_scorer
.
score
(
string
coreQuery
queryHasSlashes
)
;
if
(
!
queryHasSlashes
)
{
score
=
legacy_scorer
.
basenameScore
(
string
coreQuery
score
)
;
}
}
return
score
;
}
match
:
function
(
string
query
prepQuery
_arg
)
{
var
allowErrors
baseMatches
matches
query_lw
string_lw
_i
_ref
_results
;
allowErrors
=
(
_arg
!
=
null
?
_arg
:
{
}
)
.
allowErrors
;
if
(
!
string
)
{
return
[
]
;
}
if
(
!
query
)
{
return
[
]
;
}
if
(
string
=
=
=
query
)
{
return
(
function
(
)
{
_results
=
[
]
;
for
(
var
_i
=
0
_ref
=
string
.
length
;
0
<
=
_ref
?
_i
<
_ref
:
_i
>
_ref
;
0
<
=
_ref
?
_i
+
+
:
_i
-
-
)
{
_results
.
push
(
_i
)
;
}
return
_results
;
}
)
.
apply
(
this
)
;
}
if
(
prepQuery
=
=
null
)
{
prepQuery
=
prepQueryCache
&
&
prepQueryCache
.
query
=
=
=
query
?
prepQueryCache
:
(
prepQueryCache
=
scorer
.
prepQuery
(
query
)
)
;
}
if
(
!
(
allowErrors
|
|
scorer
.
isMatch
(
string
prepQuery
.
core_lw
prepQuery
.
core_up
)
)
)
{
return
[
]
;
}
string_lw
=
string
.
toLowerCase
(
)
;
query_lw
=
prepQuery
.
query_lw
;
matches
=
matcher
.
match
(
string
string_lw
prepQuery
)
;
if
(
matches
.
length
=
=
=
0
)
{
return
matches
;
}
if
(
string
.
indexOf
(
PathSeparator
)
>
-
1
)
{
baseMatches
=
matcher
.
basenameMatch
(
string
string_lw
prepQuery
)
;
matches
=
matcher
.
mergeMatches
(
matches
baseMatches
)
;
}
return
matches
;
}
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
AcronymResult
PathSeparator
Query
basenameScore
coreChars
countDir
doScore
emptyAcronymResult
file_coeff
isMatch
isSeparator
isWordEnd
isWordStart
miss_coeff
opt_char_re
pos_bonus
scoreAcronyms
scoreCharacter
scoreConsecutives
scoreExact
scoreExactMatch
scorePattern
scorePosition
scoreSize
tau_depth
tau_size
truncatedUpperCase
wm
;
PathSeparator
=
__webpack_require__
(
359
)
.
sep
;
wm
=
150
;
pos_bonus
=
20
;
tau_depth
=
13
;
tau_size
=
85
;
file_coeff
=
1
.
2
;
miss_coeff
=
0
.
75
;
opt_char_re
=
/
[
_
\
-
:
\
/
\
\
]
/
g
;
exports
.
coreChars
=
coreChars
=
function
(
query
)
{
return
query
.
replace
(
opt_char_re
'
'
)
;
}
;
exports
.
score
=
function
(
string
query
prepQuery
allowErrors
)
{
var
score
string_lw
;
if
(
prepQuery
=
=
null
)
{
prepQuery
=
new
Query
(
query
)
;
}
if
(
allowErrors
=
=
null
)
{
allowErrors
=
false
;
}
if
(
!
(
allowErrors
|
|
isMatch
(
string
prepQuery
.
core_lw
prepQuery
.
core_up
)
)
)
{
return
0
;
}
string_lw
=
string
.
toLowerCase
(
)
;
score
=
doScore
(
string
string_lw
prepQuery
)
;
return
Math
.
ceil
(
basenameScore
(
string
string_lw
prepQuery
score
)
)
;
}
;
Query
=
(
function
(
)
{
function
Query
(
query
)
{
if
(
!
(
query
!
=
null
?
query
.
length
:
void
0
)
)
{
return
null
;
}
this
.
query
=
query
;
this
.
query_lw
=
query
.
toLowerCase
(
)
;
this
.
core
=
coreChars
(
query
)
;
this
.
core_lw
=
this
.
core
.
toLowerCase
(
)
;
this
.
core_up
=
truncatedUpperCase
(
this
.
core
)
;
this
.
depth
=
countDir
(
query
query
.
length
)
;
}
return
Query
;
}
)
(
)
;
exports
.
prepQuery
=
function
(
query
)
{
return
new
Query
(
query
)
;
}
;
exports
.
isMatch
=
isMatch
=
function
(
subject
query_lw
query_up
)
{
var
i
j
m
n
qj_lw
qj_up
si
;
m
=
subject
.
length
;
n
=
query_lw
.
length
;
if
(
!
m
|
|
n
>
m
)
{
return
false
;
}
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
[
j
]
;
qj_up
=
query_up
[
j
]
;
while
(
+
+
i
<
m
)
{
si
=
subject
[
i
]
;
if
(
si
=
=
=
qj_lw
|
|
si
=
=
=
qj_up
)
{
break
;
}
}
if
(
i
=
=
=
m
)
{
return
false
;
}
}
return
true
;
}
;
doScore
=
function
(
subject
subject_lw
prepQuery
)
{
var
acro
acro_score
align
csc_diag
csc_row
csc_score
i
j
m
miss_budget
miss_left
mm
n
pos
query
query_lw
record_miss
score
score_diag
score_row
score_up
si_lw
start
sz
;
query
=
prepQuery
.
query
;
query_lw
=
prepQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro
=
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
;
acro_score
=
acro
.
score
;
if
(
acro
.
count
=
=
=
n
)
{
return
scoreExact
(
n
m
acro_score
acro
.
pos
)
;
}
pos
=
subject_lw
.
indexOf
(
query_lw
)
;
if
(
pos
>
-
1
)
{
return
scoreExactMatch
(
subject
subject_lw
query
query_lw
pos
n
m
)
;
}
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
sz
=
scoreSize
(
n
m
)
;
miss_budget
=
Math
.
ceil
(
miss_coeff
*
n
)
+
5
;
miss_left
=
miss_budget
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
subject_lw
.
indexOf
(
query_lw
[
0
]
)
;
if
(
i
>
-
1
)
{
i
-
-
;
}
mm
=
subject_lw
.
lastIndexOf
(
query_lw
[
n
-
1
]
m
)
;
if
(
mm
>
i
)
{
m
=
mm
+
1
;
}
while
(
+
+
i
<
m
)
{
score
=
0
;
score_diag
=
0
;
csc_diag
=
0
;
si_lw
=
subject_lw
[
i
]
;
record_miss
=
true
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_up
=
score_row
[
j
]
;
if
(
score_up
>
score
)
{
score
=
score_up
;
}
csc_score
=
0
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
if
(
align
>
score
)
{
score
=
align
;
miss_left
=
miss_budget
;
}
else
{
if
(
record_miss
&
&
-
-
miss_left
<
=
0
)
{
return
score_row
[
n
-
1
]
*
sz
;
}
record_miss
=
false
;
}
}
score_diag
=
score_up
;
csc_diag
=
csc_row
[
j
]
;
csc_row
[
j
]
=
csc_score
;
score_row
[
j
]
=
score
;
}
}
return
score
*
sz
;
}
;
exports
.
isWordStart
=
isWordStart
=
function
(
pos
subject
subject_lw
)
{
var
curr_s
prev_s
;
if
(
pos
=
=
=
0
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
prev_s
=
subject
[
pos
-
1
]
;
return
isSeparator
(
curr_s
)
|
|
isSeparator
(
prev_s
)
|
|
(
curr_s
!
=
=
subject_lw
[
pos
]
&
&
prev_s
=
=
=
subject_lw
[
pos
-
1
]
)
;
}
;
exports
.
isWordEnd
=
isWordEnd
=
function
(
pos
subject
subject_lw
len
)
{
var
curr_s
next_s
;
if
(
pos
=
=
=
len
-
1
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
next_s
=
subject
[
pos
+
1
]
;
return
isSeparator
(
curr_s
)
|
|
isSeparator
(
next_s
)
|
|
(
curr_s
=
=
=
subject_lw
[
pos
]
&
&
next_s
!
=
=
subject_lw
[
pos
+
1
]
)
;
}
;
isSeparator
=
function
(
c
)
{
return
c
=
=
=
'
'
|
|
c
=
=
=
'
.
'
|
|
c
=
=
=
'
-
'
|
|
c
=
=
=
'
_
'
|
|
c
=
=
=
'
/
'
|
|
c
=
=
=
'
\
\
'
;
}
;
scorePosition
=
function
(
pos
)
{
var
sc
;
if
(
pos
<
pos_bonus
)
{
sc
=
pos_bonus
-
pos
;
return
100
+
sc
*
sc
;
}
else
{
return
Math
.
max
(
100
+
pos_bonus
-
pos
0
)
;
}
}
;
scoreSize
=
function
(
n
m
)
{
return
tau_size
/
(
tau_size
+
Math
.
abs
(
m
-
n
)
)
;
}
;
scoreExact
=
function
(
n
m
quality
pos
)
{
return
2
*
n
*
(
wm
*
quality
+
scorePosition
(
pos
)
)
*
scoreSize
(
n
m
)
;
}
;
exports
.
scorePattern
=
scorePattern
=
function
(
count
len
sameCase
start
end
)
{
var
bonus
sz
;
sz
=
count
;
bonus
=
6
;
if
(
sameCase
=
=
=
count
)
{
bonus
+
=
2
;
}
if
(
start
)
{
bonus
+
=
3
;
}
if
(
end
)
{
bonus
+
=
1
;
}
if
(
count
=
=
=
len
)
{
if
(
start
)
{
if
(
sameCase
=
=
=
len
)
{
sz
+
=
2
;
}
else
{
sz
+
=
1
;
}
}
if
(
end
)
{
bonus
+
=
1
;
}
}
return
sameCase
+
sz
*
(
sz
+
bonus
)
;
}
;
exports
.
scoreCharacter
=
scoreCharacter
=
function
(
i
j
start
acro_score
csc_score
)
{
var
posBonus
;
posBonus
=
scorePosition
(
i
)
;
if
(
start
)
{
return
posBonus
+
wm
*
(
(
acro_score
>
csc_score
?
acro_score
:
csc_score
)
+
10
)
;
}
return
posBonus
+
wm
*
csc_score
;
}
;
exports
.
scoreConsecutives
=
scoreConsecutives
=
function
(
subject
subject_lw
query
query_lw
i
j
start
)
{
var
k
m
mi
n
nj
sameCase
startPos
sz
;
m
=
subject
.
length
;
n
=
query
.
length
;
mi
=
m
-
i
;
nj
=
n
-
j
;
k
=
mi
<
nj
?
mi
:
nj
;
startPos
=
i
;
sameCase
=
0
;
sz
=
0
;
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
while
(
+
+
sz
<
k
&
&
query_lw
[
+
+
j
]
=
=
=
subject_lw
[
+
+
i
]
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
if
(
sz
=
=
=
1
)
{
return
1
+
2
*
sameCase
;
}
return
scorePattern
(
sz
n
sameCase
start
isWordEnd
(
i
subject
subject_lw
m
)
)
;
}
;
exports
.
scoreExactMatch
=
scoreExactMatch
=
function
(
subject
subject_lw
query
query_lw
pos
n
m
)
{
var
end
i
pos2
sameCase
start
;
start
=
isWordStart
(
pos
subject
subject_lw
)
;
if
(
!
start
)
{
pos2
=
subject_lw
.
indexOf
(
query_lw
pos
+
1
)
;
if
(
pos2
>
-
1
)
{
start
=
isWordStart
(
pos2
subject
subject_lw
)
;
if
(
start
)
{
pos
=
pos2
;
}
}
}
i
=
-
1
;
sameCase
=
0
;
while
(
+
+
i
<
n
)
{
if
(
query
[
pos
+
i
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
end
=
isWordEnd
(
pos
+
n
-
1
subject
subject_lw
m
)
;
return
scoreExact
(
n
m
scorePattern
(
n
n
sameCase
start
end
)
pos
)
;
}
;
AcronymResult
=
(
function
(
)
{
function
AcronymResult
(
score
pos
count
)
{
this
.
score
=
score
;
this
.
pos
=
pos
;
this
.
count
=
count
;
}
return
AcronymResult
;
}
)
(
)
;
emptyAcronymResult
=
new
AcronymResult
(
0
0
.
1
0
)
;
exports
.
scoreAcronyms
=
scoreAcronyms
=
function
(
subject
subject_lw
query
query_lw
)
{
var
count
i
j
m
n
pos
qj_lw
sameCase
score
;
m
=
subject
.
length
;
n
=
query
.
length
;
if
(
!
(
m
>
1
&
&
n
>
1
)
)
{
return
emptyAcronymResult
;
}
count
=
0
;
pos
=
0
;
sameCase
=
0
;
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
[
j
]
;
while
(
+
+
i
<
m
)
{
if
(
qj_lw
=
=
=
subject_lw
[
i
]
&
&
isWordStart
(
i
subject
subject_lw
)
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
pos
+
=
i
;
count
+
+
;
break
;
}
}
if
(
i
=
=
=
m
)
{
break
;
}
}
if
(
count
<
2
)
{
return
emptyAcronymResult
;
}
score
=
scorePattern
(
count
n
sameCase
true
false
)
;
return
new
AcronymResult
(
score
pos
/
count
count
)
;
}
;
basenameScore
=
function
(
subject
subject_lw
prepQuery
fullPathScore
)
{
var
alpha
basePathScore
basePos
depth
end
;
if
(
fullPathScore
=
=
=
0
)
{
return
0
;
}
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
PathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
PathSeparator
end
)
;
if
(
basePos
=
=
=
-
1
)
{
return
fullPathScore
;
}
depth
=
prepQuery
.
depth
;
while
(
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
PathSeparator
basePos
-
1
)
;
if
(
basePos
=
=
=
-
1
)
{
return
fullPathScore
;
}
}
basePos
+
+
;
end
+
+
;
basePathScore
=
doScore
(
subject
.
slice
(
basePos
end
)
subject_lw
.
slice
(
basePos
end
)
prepQuery
)
;
alpha
=
0
.
5
*
tau_depth
/
(
tau_depth
+
countDir
(
subject
end
+
1
)
)
;
return
alpha
*
basePathScore
+
(
1
-
alpha
)
*
fullPathScore
*
scoreSize
(
0
file_coeff
*
(
end
-
basePos
)
)
;
}
;
exports
.
countDir
=
countDir
=
function
(
path
end
)
{
var
count
i
;
if
(
end
<
1
)
{
return
0
;
}
count
=
0
;
i
=
-
1
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
PathSeparator
)
{
continue
;
}
while
(
+
+
i
<
end
)
{
if
(
path
[
i
]
=
=
=
PathSeparator
)
{
count
+
+
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
PathSeparator
)
{
continue
;
}
}
}
return
count
;
}
;
truncatedUpperCase
=
function
(
str
)
{
var
char
upper
_i
_len
;
upper
=
"
"
;
for
(
_i
=
0
_len
=
str
.
length
;
_i
<
_len
;
_i
+
+
)
{
char
=
str
[
_i
]
;
upper
+
=
char
.
toUpperCase
(
)
[
0
]
;
}
return
upper
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
function
normalizeArray
(
parts
allowAboveRoot
)
{
var
up
=
0
;
for
(
var
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
last
=
parts
[
i
]
;
if
(
last
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
parts
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
parts
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
allowAboveRoot
)
{
for
(
;
up
-
-
;
up
)
{
parts
.
unshift
(
'
.
.
'
)
;
}
}
return
parts
;
}
var
splitPathRe
=
/
^
(
\
/
?
|
)
(
[
\
s
\
S
]
*
?
)
(
(
?
:
\
.
{
1
2
}
|
[
^
\
/
]
+
?
|
)
(
\
.
[
^
.
\
/
]
*
|
)
)
(
?
:
[
\
/
]
*
)
/
;
var
splitPath
=
function
(
filename
)
{
return
splitPathRe
.
exec
(
filename
)
.
slice
(
1
)
;
}
;
exports
.
resolve
=
function
(
)
{
var
resolvedPath
=
'
'
resolvedAbsolute
=
false
;
for
(
var
i
=
arguments
.
length
-
1
;
i
>
=
-
1
&
&
!
resolvedAbsolute
;
i
-
-
)
{
var
path
=
(
i
>
=
0
)
?
arguments
[
i
]
:
process
.
cwd
(
)
;
if
(
typeof
path
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
resolve
must
be
strings
'
)
;
}
else
if
(
!
path
)
{
continue
;
}
resolvedPath
=
path
+
'
/
'
+
resolvedPath
;
resolvedAbsolute
=
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
resolvedPath
=
normalizeArray
(
filter
(
resolvedPath
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
resolvedAbsolute
)
.
join
(
'
/
'
)
;
return
(
(
resolvedAbsolute
?
'
/
'
:
'
'
)
+
resolvedPath
)
|
|
'
.
'
;
}
;
exports
.
normalize
=
function
(
path
)
{
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
trailingSlash
=
substr
(
path
-
1
)
=
=
=
'
/
'
;
path
=
normalizeArray
(
filter
(
path
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
isAbsolute
)
.
join
(
'
/
'
)
;
if
(
!
path
&
&
!
isAbsolute
)
{
path
=
'
.
'
;
}
if
(
path
&
&
trailingSlash
)
{
path
+
=
'
/
'
;
}
return
(
isAbsolute
?
'
/
'
:
'
'
)
+
path
;
}
;
exports
.
isAbsolute
=
function
(
path
)
{
return
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
;
exports
.
join
=
function
(
)
{
var
paths
=
Array
.
prototype
.
slice
.
call
(
arguments
0
)
;
return
exports
.
normalize
(
filter
(
paths
function
(
p
index
)
{
if
(
typeof
p
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
join
must
be
strings
'
)
;
}
return
p
;
}
)
.
join
(
'
/
'
)
)
;
}
;
exports
.
relative
=
function
(
from
to
)
{
from
=
exports
.
resolve
(
from
)
.
substr
(
1
)
;
to
=
exports
.
resolve
(
to
)
.
substr
(
1
)
;
function
trim
(
arr
)
{
var
start
=
0
;
for
(
;
start
<
arr
.
length
;
start
+
+
)
{
if
(
arr
[
start
]
!
=
=
'
'
)
break
;
}
var
end
=
arr
.
length
-
1
;
for
(
;
end
>
=
0
;
end
-
-
)
{
if
(
arr
[
end
]
!
=
=
'
'
)
break
;
}
if
(
start
>
end
)
return
[
]
;
return
arr
.
slice
(
start
end
-
start
+
1
)
;
}
var
fromParts
=
trim
(
from
.
split
(
'
/
'
)
)
;
var
toParts
=
trim
(
to
.
split
(
'
/
'
)
)
;
var
length
=
Math
.
min
(
fromParts
.
length
toParts
.
length
)
;
var
samePartsLength
=
length
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
fromParts
[
i
]
!
=
=
toParts
[
i
]
)
{
samePartsLength
=
i
;
break
;
}
}
var
outputParts
=
[
]
;
for
(
var
i
=
samePartsLength
;
i
<
fromParts
.
length
;
i
+
+
)
{
outputParts
.
push
(
'
.
.
'
)
;
}
outputParts
=
outputParts
.
concat
(
toParts
.
slice
(
samePartsLength
)
)
;
return
outputParts
.
join
(
'
/
'
)
;
}
;
exports
.
sep
=
'
/
'
;
exports
.
delimiter
=
'
:
'
;
exports
.
dirname
=
function
(
path
)
{
var
result
=
splitPath
(
path
)
root
=
result
[
0
]
dir
=
result
[
1
]
;
if
(
!
root
&
&
!
dir
)
{
return
'
.
'
;
}
if
(
dir
)
{
dir
=
dir
.
substr
(
0
dir
.
length
-
1
)
;
}
return
root
+
dir
;
}
;
exports
.
basename
=
function
(
path
ext
)
{
var
f
=
splitPath
(
path
)
[
2
]
;
if
(
ext
&
&
f
.
substr
(
-
1
*
ext
.
length
)
=
=
=
ext
)
{
f
=
f
.
substr
(
0
f
.
length
-
ext
.
length
)
;
}
return
f
;
}
;
exports
.
extname
=
function
(
path
)
{
return
splitPath
(
path
)
[
3
]
;
}
;
function
filter
(
xs
f
)
{
if
(
xs
.
filter
)
return
xs
.
filter
(
f
)
;
var
res
=
[
]
;
for
(
var
i
=
0
;
i
<
xs
.
length
;
i
+
+
)
{
if
(
f
(
xs
[
i
]
i
xs
)
)
res
.
push
(
xs
[
i
]
)
;
}
return
res
;
}
var
substr
=
'
ab
'
.
substr
(
-
1
)
=
=
=
'
b
'
?
function
(
str
start
len
)
{
return
str
.
substr
(
start
len
)
}
:
function
(
str
start
len
)
{
if
(
start
<
0
)
start
=
str
.
length
+
start
;
return
str
.
substr
(
start
len
)
;
}
;
}
.
call
(
exports
__webpack_require__
(
35
)
)
)
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
queryIsLastPathSegment
;
PathSeparator
=
__webpack_require__
(
359
)
.
sep
;
exports
.
basenameScore
=
function
(
string
query
score
)
{
var
base
depth
index
lastCharacter
segmentCount
slashCount
;
index
=
string
.
length
-
1
;
while
(
string
[
index
]
=
=
=
PathSeparator
)
{
index
-
-
;
}
slashCount
=
0
;
lastCharacter
=
index
;
base
=
null
;
while
(
index
>
=
0
)
{
if
(
string
[
index
]
=
=
=
PathSeparator
)
{
slashCount
+
+
;
if
(
base
=
=
null
)
{
base
=
string
.
substring
(
index
+
1
lastCharacter
+
1
)
;
}
}
else
if
(
index
=
=
=
0
)
{
if
(
lastCharacter
<
string
.
length
-
1
)
{
if
(
base
=
=
null
)
{
base
=
string
.
substring
(
0
lastCharacter
+
1
)
;
}
}
else
{
if
(
base
=
=
null
)
{
base
=
string
;
}
}
}
index
-
-
;
}
if
(
base
=
=
=
string
)
{
score
*
=
2
;
}
else
if
(
base
)
{
score
+
=
exports
.
score
(
base
query
)
;
}
segmentCount
=
slashCount
+
1
;
depth
=
Math
.
max
(
1
10
-
segmentCount
)
;
score
*
=
depth
*
0
.
01
;
return
score
;
}
;
exports
.
score
=
function
(
string
query
)
{
var
character
characterScore
indexInQuery
indexInString
lowerCaseIndex
minIndex
queryLength
queryScore
stringLength
totalCharacterScore
upperCaseIndex
_ref
;
if
(
string
=
=
=
query
)
{
return
1
;
}
if
(
queryIsLastPathSegment
(
string
query
)
)
{
return
1
;
}
totalCharacterScore
=
0
;
queryLength
=
query
.
length
;
stringLength
=
string
.
length
;
indexInQuery
=
0
;
indexInString
=
0
;
while
(
indexInQuery
<
queryLength
)
{
character
=
query
[
indexInQuery
+
+
]
;
lowerCaseIndex
=
string
.
indexOf
(
character
.
toLowerCase
(
)
)
;
upperCaseIndex
=
string
.
indexOf
(
character
.
toUpperCase
(
)
)
;
minIndex
=
Math
.
min
(
lowerCaseIndex
upperCaseIndex
)
;
if
(
minIndex
=
=
=
-
1
)
{
minIndex
=
Math
.
max
(
lowerCaseIndex
upperCaseIndex
)
;
}
indexInString
=
minIndex
;
if
(
indexInString
=
=
=
-
1
)
{
return
0
;
}
characterScore
=
0
.
1
;
if
(
string
[
indexInString
]
=
=
=
character
)
{
characterScore
+
=
0
.
1
;
}
if
(
indexInString
=
=
=
0
|
|
string
[
indexInString
-
1
]
=
=
=
PathSeparator
)
{
characterScore
+
=
0
.
8
;
}
else
if
(
(
_ref
=
string
[
indexInString
-
1
]
)
=
=
=
'
-
'
|
|
_ref
=
=
=
'
_
'
|
|
_ref
=
=
=
'
'
)
{
characterScore
+
=
0
.
7
;
}
string
=
string
.
substring
(
indexInString
+
1
stringLength
)
;
totalCharacterScore
+
=
characterScore
;
}
queryScore
=
totalCharacterScore
/
queryLength
;
return
(
(
queryScore
*
(
queryLength
/
stringLength
)
)
+
queryScore
)
/
2
;
}
;
queryIsLastPathSegment
=
function
(
string
query
)
{
if
(
string
[
string
.
length
-
query
.
length
-
1
]
=
=
=
PathSeparator
)
{
return
string
.
lastIndexOf
(
query
)
=
=
=
string
.
length
-
query
.
length
;
}
}
;
exports
.
match
=
function
(
string
query
stringOffset
)
{
var
character
indexInQuery
indexInString
lowerCaseIndex
matches
minIndex
queryLength
stringLength
upperCaseIndex
_i
_ref
_results
;
if
(
stringOffset
=
=
null
)
{
stringOffset
=
0
;
}
if
(
string
=
=
=
query
)
{
return
(
function
(
)
{
_results
=
[
]
;
for
(
var
_i
=
stringOffset
_ref
=
stringOffset
+
string
.
length
;
stringOffset
<
=
_ref
?
_i
<
_ref
:
_i
>
_ref
;
stringOffset
<
=
_ref
?
_i
+
+
:
_i
-
-
)
{
_results
.
push
(
_i
)
;
}
return
_results
;
}
)
.
apply
(
this
)
;
}
queryLength
=
query
.
length
;
stringLength
=
string
.
length
;
indexInQuery
=
0
;
indexInString
=
0
;
matches
=
[
]
;
while
(
indexInQuery
<
queryLength
)
{
character
=
query
[
indexInQuery
+
+
]
;
lowerCaseIndex
=
string
.
indexOf
(
character
.
toLowerCase
(
)
)
;
upperCaseIndex
=
string
.
indexOf
(
character
.
toUpperCase
(
)
)
;
minIndex
=
Math
.
min
(
lowerCaseIndex
upperCaseIndex
)
;
if
(
minIndex
=
=
=
-
1
)
{
minIndex
=
Math
.
max
(
lowerCaseIndex
upperCaseIndex
)
;
}
indexInString
=
minIndex
;
if
(
indexInString
=
=
=
-
1
)
{
return
[
]
;
}
matches
.
push
(
stringOffset
+
indexInString
)
;
stringOffset
+
=
indexInString
+
1
;
string
=
string
.
substring
(
indexInString
+
1
stringLength
)
;
}
return
matches
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
legacy_scorer
pluckCandidates
scorer
sortCandidates
;
scorer
=
__webpack_require__
(
358
)
;
legacy_scorer
=
__webpack_require__
(
360
)
;
pluckCandidates
=
function
(
a
)
{
return
a
.
candidate
;
}
;
sortCandidates
=
function
(
a
b
)
{
return
b
.
score
-
a
.
score
;
}
;
PathSeparator
=
__webpack_require__
(
359
)
.
sep
;
module
.
exports
=
function
(
candidates
query
_arg
)
{
var
allowErrors
bAllowErrors
bKey
candidate
coreQuery
key
legacy
maxInners
maxResults
prepQuery
queryHasSlashes
score
scoredCandidates
spotLeft
string
_i
_j
_len
_len1
_ref
;
_ref
=
_arg
!
=
null
?
_arg
:
{
}
key
=
_ref
.
key
maxResults
=
_ref
.
maxResults
maxInners
=
_ref
.
maxInners
allowErrors
=
_ref
.
allowErrors
legacy
=
_ref
.
legacy
;
scoredCandidates
=
[
]
;
spotLeft
=
(
maxInners
!
=
null
)
&
&
maxInners
>
0
?
maxInners
:
candidates
.
length
;
bAllowErrors
=
!
!
allowErrors
;
bKey
=
key
!
=
null
;
prepQuery
=
scorer
.
prepQuery
(
query
)
;
if
(
!
legacy
)
{
for
(
_i
=
0
_len
=
candidates
.
length
;
_i
<
_len
;
_i
+
+
)
{
candidate
=
candidates
[
_i
]
;
string
=
bKey
?
candidate
[
key
]
:
candidate
;
if
(
!
string
)
{
continue
;
}
score
=
scorer
.
score
(
string
query
prepQuery
bAllowErrors
)
;
if
(
score
>
0
)
{
scoredCandidates
.
push
(
{
candidate
:
candidate
score
:
score
}
)
;
if
(
!
-
-
spotLeft
)
{
break
;
}
}
}
}
else
{
queryHasSlashes
=
prepQuery
.
depth
>
0
;
coreQuery
=
prepQuery
.
core
;
for
(
_j
=
0
_len1
=
candidates
.
length
;
_j
<
_len1
;
_j
+
+
)
{
candidate
=
candidates
[
_j
]
;
string
=
key
!
=
null
?
candidate
[
key
]
:
candidate
;
if
(
!
string
)
{
continue
;
}
score
=
legacy_scorer
.
score
(
string
coreQuery
queryHasSlashes
)
;
if
(
!
queryHasSlashes
)
{
score
=
legacy_scorer
.
basenameScore
(
string
coreQuery
score
)
;
}
if
(
score
>
0
)
{
scoredCandidates
.
push
(
{
candidate
:
candidate
score
:
score
}
)
;
}
}
}
scoredCandidates
.
sort
(
sortCandidates
)
;
candidates
=
scoredCandidates
.
map
(
pluckCandidates
)
;
if
(
maxResults
!
=
null
)
{
candidates
=
candidates
.
slice
(
0
maxResults
)
;
}
return
candidates
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
PathSeparator
scorer
;
PathSeparator
=
__webpack_require__
(
359
)
.
sep
;
scorer
=
__webpack_require__
(
358
)
;
exports
.
basenameMatch
=
function
(
subject
subject_lw
prepQuery
)
{
var
basePos
depth
end
;
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
PathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
PathSeparator
end
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
depth
=
prepQuery
.
depth
;
while
(
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
PathSeparator
basePos
-
1
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
}
basePos
+
+
;
end
+
+
;
return
exports
.
match
(
subject
.
slice
(
basePos
end
)
subject_lw
.
slice
(
basePos
end
)
prepQuery
basePos
)
;
}
;
exports
.
mergeMatches
=
function
(
a
b
)
{
var
ai
bj
i
j
m
n
out
;
m
=
a
.
length
;
n
=
b
.
length
;
if
(
n
=
=
=
0
)
{
return
a
.
slice
(
)
;
}
if
(
m
=
=
=
0
)
{
return
b
.
slice
(
)
;
}
i
=
-
1
;
j
=
0
;
bj
=
b
[
j
]
;
out
=
[
]
;
while
(
+
+
i
<
m
)
{
ai
=
a
[
i
]
;
while
(
bj
<
=
ai
&
&
+
+
j
<
n
)
{
if
(
bj
<
ai
)
{
out
.
push
(
bj
)
;
}
bj
=
b
[
j
]
;
}
out
.
push
(
ai
)
;
}
while
(
j
<
n
)
{
out
.
push
(
b
[
j
+
+
]
)
;
}
return
out
;
}
;
exports
.
match
=
function
(
subject
subject_lw
prepQuery
offset
)
{
var
DIAGONAL
LEFT
STOP
UP
acro_score
align
backtrack
csc_diag
csc_row
csc_score
i
j
m
matches
move
n
pos
query
query_lw
score
score_diag
score_row
score_up
si_lw
start
trace
;
if
(
offset
=
=
null
)
{
offset
=
0
;
}
query
=
prepQuery
.
query
;
query_lw
=
prepQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro_score
=
scorer
.
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
.
score
;
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
STOP
=
0
;
UP
=
1
;
LEFT
=
2
;
DIAGONAL
=
3
;
trace
=
new
Array
(
m
*
n
)
;
pos
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
score
=
0
;
score_up
=
0
;
csc_diag
=
0
;
si_lw
=
subject_lw
[
i
]
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
csc_score
=
0
;
align
=
0
;
score_diag
=
score_up
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
scorer
.
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scorer
.
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scorer
.
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
}
score_up
=
score_row
[
j
]
;
csc_diag
=
csc_row
[
j
]
;
if
(
score
>
score_up
)
{
move
=
LEFT
;
}
else
{
score
=
score_up
;
move
=
UP
;
}
if
(
align
>
score
)
{
score
=
align
;
move
=
DIAGONAL
;
}
else
{
csc_score
=
0
;
}
score_row
[
j
]
=
score
;
csc_row
[
j
]
=
csc_score
;
trace
[
+
+
pos
]
=
score
>
0
?
move
:
STOP
;
}
}
i
=
m
-
1
;
j
=
n
-
1
;
pos
=
i
*
n
+
j
;
backtrack
=
true
;
matches
=
[
]
;
while
(
backtrack
&
&
i
>
=
0
&
&
j
>
=
0
)
{
switch
(
trace
[
pos
]
)
{
case
UP
:
i
-
-
;
pos
-
=
n
;
break
;
case
LEFT
:
j
-
-
;
pos
-
-
;
break
;
case
DIAGONAL
:
matches
.
push
(
i
+
offset
)
;
j
-
-
;
i
-
-
;
pos
-
=
n
+
1
;
break
;
default
:
backtrack
=
false
;
}
}
matches
.
reverse
(
)
;
return
matches
;
}
;
}
)
.
call
(
this
)
;
}
function
(
module
exports
)
{
}
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
{
Services
}
=
__webpack_require__
(
213
)
;
const
EventEmitter
=
__webpack_require__
(
111
)
;
const
isOSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
ElectronKeysMapping
=
{
"
F1
"
:
"
DOM_VK_F1
"
"
F2
"
:
"
DOM_VK_F2
"
"
F3
"
:
"
DOM_VK_F3
"
"
F4
"
:
"
DOM_VK_F4
"
"
F5
"
:
"
DOM_VK_F5
"
"
F6
"
:
"
DOM_VK_F6
"
"
F7
"
:
"
DOM_VK_F7
"
"
F8
"
:
"
DOM_VK_F8
"
"
F9
"
:
"
DOM_VK_F9
"
"
F10
"
:
"
DOM_VK_F10
"
"
F11
"
:
"
DOM_VK_F11
"
"
F12
"
:
"
DOM_VK_F12
"
"
F13
"
:
"
DOM_VK_F13
"
"
F14
"
:
"
DOM_VK_F14
"
"
F15
"
:
"
DOM_VK_F15
"
"
F16
"
:
"
DOM_VK_F16
"
"
F17
"
:
"
DOM_VK_F17
"
"
F18
"
:
"
DOM_VK_F18
"
"
F19
"
:
"
DOM_VK_F19
"
"
F20
"
:
"
DOM_VK_F20
"
"
F21
"
:
"
DOM_VK_F21
"
"
F22
"
:
"
DOM_VK_F22
"
"
F23
"
:
"
DOM_VK_F23
"
"
F24
"
:
"
DOM_VK_F24
"
"
Space
"
:
"
DOM_VK_SPACE
"
"
Backspace
"
:
"
DOM_VK_BACK_SPACE
"
"
Delete
"
:
"
DOM_VK_DELETE
"
"
Insert
"
:
"
DOM_VK_INSERT
"
"
Return
"
:
"
DOM_VK_RETURN
"
"
Enter
"
:
"
DOM_VK_RETURN
"
"
Up
"
:
"
DOM_VK_UP
"
"
Down
"
:
"
DOM_VK_DOWN
"
"
Left
"
:
"
DOM_VK_LEFT
"
"
Right
"
:
"
DOM_VK_RIGHT
"
"
Home
"
:
"
DOM_VK_HOME
"
"
End
"
:
"
DOM_VK_END
"
"
PageUp
"
:
"
DOM_VK_PAGE_UP
"
"
PageDown
"
:
"
DOM_VK_PAGE_DOWN
"
"
Escape
"
:
"
DOM_VK_ESCAPE
"
"
Esc
"
:
"
DOM_VK_ESCAPE
"
"
Tab
"
:
"
DOM_VK_TAB
"
"
VolumeUp
"
:
"
DOM_VK_VOLUME_UP
"
"
VolumeDown
"
:
"
DOM_VK_VOLUME_DOWN
"
"
VolumeMute
"
:
"
DOM_VK_VOLUME_MUTE
"
"
PrintScreen
"
:
"
DOM_VK_PRINTSCREEN
"
}
;
function
KeyShortcuts
(
{
window
target
}
)
{
this
.
window
=
window
;
this
.
target
=
target
|
|
window
;
this
.
keys
=
new
Map
(
)
;
this
.
eventEmitter
=
new
EventEmitter
(
)
;
this
.
target
.
addEventListener
(
"
keydown
"
this
)
;
}
KeyShortcuts
.
parseElectronKey
=
function
(
window
str
)
{
let
modifiers
=
str
.
split
(
"
+
"
)
;
let
key
=
modifiers
.
pop
(
)
;
let
shortcut
=
{
ctrl
:
false
meta
:
false
alt
:
false
shift
:
false
key
:
undefined
keyCode
:
undefined
}
;
for
(
let
mod
of
modifiers
)
{
if
(
mod
=
=
=
"
Alt
"
)
{
shortcut
.
alt
=
true
;
}
else
if
(
[
"
Command
"
"
Cmd
"
]
.
includes
(
mod
)
)
{
shortcut
.
meta
=
true
;
}
else
if
(
[
"
CommandOrControl
"
"
CmdOrCtrl
"
]
.
includes
(
mod
)
)
{
if
(
isOSX
)
{
shortcut
.
meta
=
true
;
}
else
{
shortcut
.
ctrl
=
true
;
}
}
else
if
(
[
"
Control
"
"
Ctrl
"
]
.
includes
(
mod
)
)
{
shortcut
.
ctrl
=
true
;
}
else
if
(
mod
=
=
=
"
Shift
"
)
{
shortcut
.
shift
=
true
;
}
else
{
console
.
error
(
"
Unsupported
modifier
:
"
mod
"
from
key
:
"
str
)
;
return
null
;
}
}
if
(
key
=
=
=
"
Plus
"
)
{
key
=
"
+
"
;
}
if
(
typeof
key
=
=
=
"
string
"
&
&
key
.
length
=
=
=
1
)
{
shortcut
.
key
=
key
.
toLowerCase
(
)
;
}
else
if
(
key
in
ElectronKeysMapping
)
{
key
=
ElectronKeysMapping
[
key
]
;
shortcut
.
keyCode
=
window
.
KeyboardEvent
[
key
]
;
shortcut
.
keyCodeString
=
key
;
shortcut
.
key
=
key
;
}
else
{
console
.
error
(
"
Unsupported
key
:
"
key
)
;
return
null
;
}
return
shortcut
;
}
;
KeyShortcuts
.
stringify
=
function
(
shortcut
)
{
let
list
=
[
]
;
if
(
shortcut
.
alt
)
{
list
.
push
(
"
Alt
"
)
;
}
if
(
shortcut
.
ctrl
)
{
list
.
push
(
"
Ctrl
"
)
;
}
if
(
shortcut
.
meta
)
{
list
.
push
(
"
Cmd
"
)
;
}
if
(
shortcut
.
shift
)
{
list
.
push
(
"
Shift
"
)
;
}
let
key
;
if
(
shortcut
.
key
)
{
key
=
shortcut
.
key
.
toUpperCase
(
)
;
}
else
{
key
=
shortcut
.
keyCodeString
;
}
list
.
push
(
key
)
;
return
list
.
join
(
"
+
"
)
;
}
;
KeyShortcuts
.
prototype
=
{
destroy
(
)
{
this
.
target
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
keys
.
clear
(
)
;
}
doesEventMatchShortcut
(
event
shortcut
)
{
if
(
shortcut
.
meta
!
=
event
.
metaKey
)
{
return
false
;
}
if
(
shortcut
.
ctrl
!
=
event
.
ctrlKey
)
{
return
false
;
}
if
(
shortcut
.
alt
!
=
event
.
altKey
)
{
return
false
;
}
if
(
shortcut
.
shift
!
=
event
.
shiftKey
&
&
event
.
key
&
&
event
.
key
.
match
(
/
[
a
-
zA
-
Z
]
/
)
)
{
return
false
;
}
if
(
shortcut
.
keyCode
)
{
return
event
.
keyCode
=
=
shortcut
.
keyCode
;
}
else
if
(
event
.
key
in
ElectronKeysMapping
)
{
return
ElectronKeysMapping
[
event
.
key
]
=
=
=
shortcut
.
key
;
}
let
key
=
event
.
key
|
|
String
.
fromCharCode
(
event
.
keyCode
)
;
return
key
.
toLowerCase
(
)
=
=
shortcut
.
key
|
|
(
shortcut
.
key
.
match
(
/
[
0
-
9
]
/
)
&
&
event
.
keyCode
=
=
shortcut
.
key
.
charCodeAt
(
0
)
)
;
}
handleEvent
(
event
)
{
for
(
let
[
key
shortcut
]
of
this
.
keys
)
{
if
(
this
.
doesEventMatchShortcut
(
event
shortcut
)
)
{
this
.
eventEmitter
.
emit
(
key
event
)
;
}
}
}
on
(
key
listener
)
{
if
(
typeof
listener
!
=
=
"
function
"
)
{
throw
new
Error
(
"
KeyShortcuts
.
on
(
)
expects
a
function
as
"
+
"
second
argument
"
)
;
}
if
(
!
this
.
keys
.
has
(
key
)
)
{
let
shortcut
=
KeyShortcuts
.
parseElectronKey
(
this
.
window
key
)
;
if
(
!
shortcut
)
{
return
;
}
this
.
keys
.
set
(
key
shortcut
)
;
}
this
.
eventEmitter
.
on
(
key
listener
)
;
}
off
(
key
listener
)
{
this
.
eventEmitter
.
off
(
key
listener
)
;
}
}
;
exports
.
KeyShortcuts
=
KeyShortcuts
;
}
]
)
;
