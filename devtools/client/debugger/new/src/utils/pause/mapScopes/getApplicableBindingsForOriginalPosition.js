"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
originalRangeStartsInside
=
originalRangeStartsInside
;
exports
.
getApplicableBindingsForOriginalPosition
=
getApplicableBindingsForOriginalPosition
;
var
_positionCmp
=
require
(
"
.
/
positionCmp
"
)
;
var
_filtering
=
require
(
"
.
/
filtering
"
)
;
var
_mappingContains
=
require
(
"
.
/
mappingContains
"
)
;
async
function
originalRangeStartsInside
(
source
{
start
end
}
sourceMaps
)
{
const
endPosition
=
await
sourceMaps
.
getGeneratedLocation
(
end
source
)
;
const
startPosition
=
await
sourceMaps
.
getGeneratedLocation
(
start
source
)
;
return
(
0
_positionCmp
.
positionCmp
)
(
startPosition
endPosition
)
!
=
=
0
;
}
async
function
getApplicableBindingsForOriginalPosition
(
generatedAstBindings
source
{
start
end
}
bindingType
locationType
sourceMaps
)
{
const
ranges
=
await
sourceMaps
.
getGeneratedRanges
(
start
source
)
;
const
resultRanges
=
ranges
.
reduce
(
(
acc
mapRange
)
=
>
{
if
(
locationType
=
=
=
"
ref
"
&
&
mapRange
.
columnStart
=
=
=
0
&
&
mapRange
.
columnEnd
=
=
=
Infinity
)
{
return
acc
;
}
const
range
=
{
start
:
{
line
:
mapRange
.
line
column
:
mapRange
.
columnStart
}
end
:
{
line
:
mapRange
.
line
column
:
mapRange
.
columnEnd
+
1
}
}
;
const
previous
=
acc
[
acc
.
length
-
1
]
;
if
(
previous
&
&
(
previous
.
end
.
line
=
=
=
range
.
start
.
line
&
&
previous
.
end
.
column
=
=
=
range
.
start
.
column
|
|
previous
.
end
.
line
+
1
=
=
=
range
.
start
.
line
&
&
previous
.
end
.
column
=
=
=
Infinity
&
&
range
.
start
.
column
=
=
=
0
)
)
{
previous
.
end
.
line
=
range
.
end
.
line
;
previous
.
end
.
column
=
range
.
end
.
column
;
}
else
{
acc
.
push
(
range
)
;
}
return
acc
;
}
[
]
)
;
if
(
bindingType
=
=
=
"
import
"
&
&
locationType
!
=
=
"
ref
"
)
{
const
endPosition
=
await
sourceMaps
.
getGeneratedLocation
(
end
source
)
;
const
startPosition
=
await
sourceMaps
.
getGeneratedLocation
(
start
source
)
;
for
(
const
range
of
resultRanges
)
{
if
(
(
0
_mappingContains
.
mappingContains
)
(
range
{
start
:
startPosition
end
:
startPosition
}
)
&
&
(
0
_positionCmp
.
positionCmp
)
(
range
.
end
endPosition
)
<
0
)
{
range
.
end
.
line
=
endPosition
.
line
;
range
.
end
.
column
=
endPosition
.
column
;
break
;
}
}
}
return
filterApplicableBindings
(
generatedAstBindings
resultRanges
)
;
}
function
filterApplicableBindings
(
bindings
ranges
)
{
const
result
=
[
]
;
for
(
const
range
of
ranges
)
{
const
filteredBindings
=
(
0
_filtering
.
filterSortedArray
)
(
bindings
binding
=
>
{
if
(
(
0
_positionCmp
.
positionCmp
)
(
binding
.
loc
.
end
range
.
start
)
<
=
0
)
{
return
-
1
;
}
if
(
(
0
_positionCmp
.
positionCmp
)
(
binding
.
loc
.
start
range
.
end
)
>
=
0
)
{
return
1
;
}
return
0
;
}
)
;
let
firstInRange
=
true
;
let
firstOnLine
=
true
;
let
line
=
-
1
;
for
(
const
binding
of
filteredBindings
)
{
if
(
binding
.
loc
.
start
.
line
=
=
=
line
)
{
firstOnLine
=
false
;
}
else
{
line
=
binding
.
loc
.
start
.
line
;
firstOnLine
=
true
;
}
result
.
push
(
{
binding
range
firstOnLine
firstInRange
}
)
;
firstInRange
=
false
;
}
}
return
result
;
}
