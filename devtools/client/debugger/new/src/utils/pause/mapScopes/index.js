"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
buildMappedScopes
=
buildMappedScopes
;
var
_parser
=
require
(
"
.
.
/
.
.
/
.
.
/
workers
/
parser
/
index
"
)
;
var
_locColumn
=
require
(
"
.
/
locColumn
"
)
;
var
_rangeMetadata
=
require
(
"
.
/
rangeMetadata
"
)
;
var
_findGeneratedBindingFromPosition
=
require
(
"
.
/
findGeneratedBindingFromPosition
"
)
;
var
_buildGeneratedBindingList
=
require
(
"
.
/
buildGeneratedBindingList
"
)
;
var
_getApplicableBindingsForOriginalPosition
=
require
(
"
.
/
getApplicableBindingsForOriginalPosition
"
)
;
var
_log
=
require
(
"
.
.
/
.
.
/
log
"
)
;
async
function
buildMappedScopes
(
source
frame
scopes
sourceMaps
client
)
{
const
originalAstScopes
=
await
(
0
_parser
.
getScopes
)
(
frame
.
location
)
;
const
generatedAstScopes
=
await
(
0
_parser
.
getScopes
)
(
frame
.
generatedLocation
)
;
if
(
!
originalAstScopes
|
|
!
generatedAstScopes
)
{
return
null
;
}
const
originalRanges
=
await
(
0
_rangeMetadata
.
loadRangeMetadata
)
(
source
frame
originalAstScopes
sourceMaps
)
;
if
(
hasLineMappings
(
originalRanges
)
)
{
return
null
;
}
const
generatedAstBindings
=
(
0
_buildGeneratedBindingList
.
buildGeneratedBindingList
)
(
scopes
generatedAstScopes
frame
.
this
)
;
const
{
mappedOriginalScopes
expressionLookup
}
=
await
mapOriginalBindingsToGenerated
(
source
originalRanges
originalAstScopes
generatedAstBindings
client
sourceMaps
)
;
const
mappedGeneratedScopes
=
generateClientScope
(
scopes
mappedOriginalScopes
)
;
return
isReliableScope
(
mappedGeneratedScopes
)
?
{
mappings
:
expressionLookup
scope
:
mappedGeneratedScopes
}
:
null
;
}
async
function
mapOriginalBindingsToGenerated
(
source
originalRanges
originalAstScopes
generatedAstBindings
client
sourceMaps
)
{
const
expressionLookup
=
{
}
;
const
mappedOriginalScopes
=
[
]
;
const
cachedSourceMaps
=
batchScopeMappings
(
originalAstScopes
source
sourceMaps
)
;
for
(
const
item
of
originalAstScopes
)
{
const
generatedBindings
=
{
}
;
for
(
const
name
of
Object
.
keys
(
item
.
bindings
)
)
{
const
binding
=
item
.
bindings
[
name
]
;
const
result
=
await
findGeneratedBinding
(
cachedSourceMaps
client
source
name
binding
originalRanges
generatedAstBindings
)
;
if
(
result
)
{
generatedBindings
[
name
]
=
result
.
grip
;
if
(
binding
.
refs
.
length
!
=
=
0
&
&
!
Object
.
prototype
.
hasOwnProperty
.
call
(
expressionLookup
name
)
)
{
expressionLookup
[
name
]
=
result
.
expression
;
}
}
}
mappedOriginalScopes
.
push
(
{
.
.
.
item
generatedBindings
}
)
;
}
return
{
mappedOriginalScopes
expressionLookup
}
;
}
function
isReliableScope
(
scope
)
{
let
totalBindings
=
0
;
let
unknownBindings
=
0
;
for
(
let
s
=
scope
;
s
;
s
=
s
.
parent
)
{
const
vars
=
s
.
bindings
&
&
s
.
bindings
.
variables
|
|
{
}
;
for
(
const
key
of
Object
.
keys
(
vars
)
)
{
const
binding
=
vars
[
key
]
;
totalBindings
+
=
1
;
if
(
binding
.
value
&
&
typeof
binding
.
value
=
=
=
"
object
"
&
&
(
binding
.
value
.
type
=
=
=
"
unscoped
"
|
|
binding
.
value
.
type
=
=
=
"
unmapped
"
)
)
{
unknownBindings
+
=
1
;
}
}
}
return
totalBindings
=
=
=
0
|
|
unknownBindings
/
totalBindings
<
0
.
25
;
}
function
hasLineMappings
(
ranges
)
{
return
ranges
.
every
(
range
=
>
range
.
columnStart
=
=
=
0
&
&
range
.
columnEnd
=
=
=
Infinity
)
;
}
function
batchScopeMappings
(
originalAstScopes
source
sourceMaps
)
{
const
precalculatedRanges
=
new
Map
(
)
;
const
precalculatedLocations
=
new
Map
(
)
;
for
(
const
item
of
originalAstScopes
)
{
for
(
const
name
of
Object
.
keys
(
item
.
bindings
)
)
{
for
(
const
ref
of
item
.
bindings
[
name
]
.
refs
)
{
const
locs
=
[
ref
]
;
if
(
ref
.
type
!
=
=
"
ref
"
)
{
locs
.
push
(
ref
.
declaration
)
;
}
for
(
const
loc
of
locs
)
{
precalculatedRanges
.
set
(
buildLocationKey
(
loc
.
start
)
sourceMaps
.
getGeneratedRanges
(
loc
.
start
source
)
)
;
precalculatedLocations
.
set
(
buildLocationKey
(
loc
.
start
)
sourceMaps
.
getGeneratedLocation
(
loc
.
start
source
)
)
;
precalculatedLocations
.
set
(
buildLocationKey
(
loc
.
end
)
sourceMaps
.
getGeneratedLocation
(
loc
.
end
source
)
)
;
}
}
}
}
return
{
async
getGeneratedRanges
(
pos
s
)
{
const
key
=
buildLocationKey
(
pos
)
;
if
(
s
!
=
=
source
|
|
!
precalculatedRanges
.
has
(
key
)
)
{
(
0
_log
.
log
)
(
"
Bad
precalculated
mapping
"
)
;
return
sourceMaps
.
getGeneratedRanges
(
pos
s
)
;
}
return
precalculatedRanges
.
get
(
key
)
;
}
async
getGeneratedLocation
(
pos
s
)
{
const
key
=
buildLocationKey
(
pos
)
;
if
(
s
!
=
=
source
|
|
!
precalculatedLocations
.
has
(
key
)
)
{
(
0
_log
.
log
)
(
"
Bad
precalculated
mapping
"
)
;
return
sourceMaps
.
getGeneratedLocation
(
pos
s
)
;
}
return
precalculatedLocations
.
get
(
key
)
;
}
}
;
}
function
buildLocationKey
(
loc
)
{
return
{
loc
.
line
}
:
{
(
0
_locColumn
.
locColumn
)
(
loc
)
}
;
}
function
generateClientScope
(
scopes
originalScopes
)
{
let
globalLexicalScope
=
null
;
for
(
let
s
=
scopes
;
s
.
parent
;
s
=
s
.
parent
)
{
globalLexicalScope
=
s
;
}
if
(
!
globalLexicalScope
)
{
throw
new
Error
(
"
Assertion
failure
-
there
should
always
be
a
scope
"
)
;
}
const
result
=
originalScopes
.
slice
(
0
-
2
)
.
reverse
(
)
.
reduce
(
(
acc
orig
i
)
=
>
{
const
{
this
:
_this
.
.
.
variables
}
=
orig
.
generatedBindings
;
return
{
parent
:
acc
actor
:
originalActor
{
i
}
type
:
orig
.
type
bindings
:
{
arguments
:
[
]
variables
}
.
.
.
(
orig
.
type
=
=
=
"
function
"
?
{
function
:
{
displayName
:
orig
.
displayName
}
}
:
null
)
.
.
.
(
orig
.
type
=
=
=
"
block
"
?
{
block
:
{
displayName
:
orig
.
displayName
}
}
:
null
)
}
;
}
globalLexicalScope
)
;
const
thisScope
=
originalScopes
.
find
(
scope
=
>
scope
.
bindings
.
this
)
;
if
(
result
.
bindings
&
&
thisScope
)
{
result
.
bindings
.
this
=
thisScope
.
generatedBindings
.
this
|
|
null
;
}
return
result
;
}
function
hasValidIdent
(
range
pos
)
{
return
range
.
type
=
=
=
"
match
"
|
|
pos
.
type
!
=
=
"
ref
"
&
&
range
.
type
=
=
=
"
contains
"
;
}
async
function
findGeneratedBinding
(
sourceMaps
client
source
name
originalBinding
originalRanges
generatedAstBindings
)
{
if
(
originalBinding
.
type
=
=
=
"
implicit
"
&
&
!
originalBinding
.
refs
.
some
(
item
=
>
item
.
type
=
=
=
"
ref
"
)
)
{
return
null
;
}
const
loadApplicableBindings
=
async
(
pos
locationType
)
=
>
{
let
applicableBindings
=
await
(
0
_getApplicableBindingsForOriginalPosition
.
getApplicableBindingsForOriginalPosition
)
(
generatedAstBindings
source
pos
originalBinding
.
type
locationType
sourceMaps
)
;
if
(
applicableBindings
.
length
>
0
)
{
hadApplicableBindings
=
true
;
}
if
(
locationType
=
=
=
"
ref
"
)
{
applicableBindings
=
applicableBindings
.
filter
(
(
{
range
}
)
=
>
!
(
range
.
start
.
column
=
=
=
0
&
&
range
.
end
.
column
=
=
=
Infinity
)
)
;
}
if
(
locationType
!
=
=
"
ref
"
&
&
!
(
await
(
0
_getApplicableBindingsForOriginalPosition
.
originalRangeStartsInside
)
(
source
pos
sourceMaps
)
)
)
{
applicableBindings
=
[
]
;
}
return
applicableBindings
;
}
;
const
{
refs
}
=
originalBinding
;
let
hadApplicableBindings
=
false
;
let
genContent
=
null
;
for
(
const
pos
of
refs
)
{
const
applicableBindings
=
await
loadApplicableBindings
(
pos
pos
.
type
)
;
const
range
=
(
0
_rangeMetadata
.
findMatchingRange
)
(
originalRanges
pos
)
;
if
(
range
&
&
hasValidIdent
(
range
pos
)
)
{
if
(
originalBinding
.
type
=
=
=
"
import
"
)
{
genContent
=
await
(
0
_findGeneratedBindingFromPosition
.
findGeneratedImportReference
)
(
applicableBindings
)
;
}
else
{
genContent
=
await
(
0
_findGeneratedBindingFromPosition
.
findGeneratedReference
)
(
applicableBindings
)
;
}
}
if
(
(
pos
.
type
=
=
=
"
class
-
decl
"
|
|
pos
.
type
=
=
=
"
class
-
inner
"
)
&
&
source
.
contentType
&
&
source
.
contentType
.
match
(
/
\
/
typescript
/
)
)
{
const
declRange
=
(
0
_rangeMetadata
.
findMatchingRange
)
(
originalRanges
pos
.
declaration
)
;
if
(
declRange
&
&
declRange
.
type
!
=
=
"
multiple
"
)
{
const
applicableDeclBindings
=
await
loadApplicableBindings
(
pos
.
declaration
pos
.
type
)
;
const
declContent
=
await
(
0
_findGeneratedBindingFromPosition
.
findGeneratedReference
)
(
applicableDeclBindings
)
;
if
(
declContent
)
{
genContent
=
declContent
;
}
}
}
if
(
!
genContent
&
&
pos
.
type
=
=
=
"
import
-
decl
"
&
&
typeof
pos
.
importName
=
=
=
"
string
"
)
{
const
{
importName
}
=
pos
;
const
declRange
=
(
0
_rangeMetadata
.
findMatchingRange
)
(
originalRanges
pos
.
declaration
)
;
if
(
declRange
&
&
declRange
.
singleDeclaration
)
{
const
applicableDeclBindings
=
await
loadApplicableBindings
(
pos
.
declaration
pos
.
type
)
;
genContent
=
await
(
0
_findGeneratedBindingFromPosition
.
findGeneratedImportDeclaration
)
(
applicableDeclBindings
importName
)
;
}
}
if
(
genContent
)
{
break
;
}
}
if
(
genContent
&
&
genContent
.
desc
)
{
return
{
grip
:
genContent
.
desc
expression
:
genContent
.
expression
}
;
}
else
if
(
genContent
)
{
if
(
name
=
=
=
"
this
"
)
{
return
null
;
}
return
{
grip
:
{
configurable
:
false
enumerable
:
true
writable
:
false
value
:
{
type
:
"
unscoped
"
unscoped
:
true
missingArguments
:
true
}
}
expression
:
null
}
;
}
else
if
(
!
hadApplicableBindings
&
&
name
!
=
=
"
this
"
)
{
return
{
grip
:
{
configurable
:
false
enumerable
:
true
writable
:
false
value
:
{
type
:
"
null
"
optimizedOut
:
true
}
}
expression
:
(
(
)
=
>
{
throw
new
Error
(
'
"
'
+
{
JSON
.
stringify
(
name
)
}
+
'
"
has
been
optimized
out
.
'
)
;
}
)
(
)
}
;
}
return
{
grip
:
{
configurable
:
false
enumerable
:
true
writable
:
false
value
:
{
type
:
"
unmapped
"
unmapped
:
true
missingArguments
:
true
}
}
expression
:
null
}
;
}
