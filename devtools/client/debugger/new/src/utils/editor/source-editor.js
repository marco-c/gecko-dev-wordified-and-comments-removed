const
CodeMirror
=
require
(
"
codemirror
"
)
;
require
(
"
codemirror
/
lib
/
codemirror
.
css
"
)
;
require
(
"
codemirror
/
mode
/
javascript
/
javascript
"
)
;
require
(
"
codemirror
/
mode
/
htmlmixed
/
htmlmixed
"
)
;
require
(
"
codemirror
/
mode
/
coffeescript
/
coffeescript
"
)
;
require
(
"
codemirror
/
mode
/
jsx
/
jsx
"
)
;
require
(
"
codemirror
/
mode
/
elm
/
elm
"
)
;
require
(
"
codemirror
/
mode
/
clojure
/
clojure
"
)
;
require
(
"
codemirror
/
mode
/
haxe
/
haxe
"
)
;
require
(
"
codemirror
/
addon
/
search
/
searchcursor
"
)
;
require
(
"
codemirror
/
addon
/
fold
/
foldcode
"
)
;
require
(
"
codemirror
/
addon
/
fold
/
brace
-
fold
"
)
;
require
(
"
codemirror
/
addon
/
fold
/
indent
-
fold
"
)
;
require
(
"
codemirror
/
addon
/
fold
/
foldgutter
"
)
;
require
(
"
codemirror
/
addon
/
runmode
/
runmode
"
)
;
require
(
"
codemirror
/
addon
/
selection
/
active
-
line
"
)
;
require
(
"
codemirror
/
addon
/
edit
/
matchbrackets
"
)
;
require
(
"
codemirror
/
addon
/
display
/
placeholder
"
)
;
require
(
"
codemirror
/
mode
/
clike
/
clike
"
)
;
require
(
"
codemirror
/
mode
/
rust
/
rust
"
)
;
require
(
"
.
/
source
-
editor
.
css
"
)
;
type
Mode
=
string
|
Object
;
export
type
AlignOpts
=
"
top
"
|
"
center
"
|
"
bottom
"
;
const
MAX_VERTICAL_OFFSET
=
3
;
type
SourceEditorOpts
=
{
enableCodeFolding
:
boolean
extraKeys
:
Object
gutters
:
string
[
]
foldGutter
:
boolean
lineNumbers
:
boolean
lineWrapping
:
boolean
matchBrackets
:
boolean
mode
:
string
readOnly
:
boolean
showAnnotationRuler
:
boolean
theme
:
string
value
:
string
}
;
export
default
class
SourceEditor
{
opts
:
SourceEditorOpts
;
editor
:
any
;
constructor
(
opts
:
SourceEditorOpts
)
{
this
.
opts
=
opts
;
}
appendToLocalElement
(
node
:
any
)
{
this
.
editor
=
CodeMirror
(
node
this
.
opts
)
;
}
destroy
(
)
{
if
(
this
.
editor
.
doc
)
{
this
.
editor
.
doc
.
cm
=
null
;
}
}
get
codeMirror
(
)
:
any
{
return
this
.
editor
;
}
get
CodeMirror
(
)
{
return
CodeMirror
;
}
setText
(
str
:
string
)
{
this
.
editor
.
setValue
(
str
)
;
}
getText
(
)
{
return
this
.
editor
.
getValue
(
)
;
}
setMode
(
value
:
Mode
)
{
this
.
editor
.
setOption
(
"
mode
"
value
)
;
}
replaceDocument
(
doc
:
any
)
{
this
.
editor
.
swapDoc
(
doc
)
;
}
createDocument
(
)
{
return
new
CodeMirror
.
Doc
(
"
"
)
;
}
alignLine
(
line
:
number
align
:
AlignOpts
=
"
top
"
)
{
const
cm
=
this
.
editor
;
const
editorClientRect
=
cm
.
getWrapperElement
(
)
.
getBoundingClientRect
(
)
;
const
from
=
cm
.
lineAtHeight
(
editorClientRect
.
top
"
page
"
)
;
const
to
=
cm
.
lineAtHeight
(
editorClientRect
.
height
+
editorClientRect
.
top
"
page
"
)
;
const
linesVisible
=
to
-
from
;
const
halfVisible
=
Math
.
round
(
linesVisible
/
2
)
;
if
(
line
<
=
to
&
&
line
>
=
from
)
{
return
;
}
const
offset
=
Math
.
min
(
halfVisible
MAX_VERTICAL_OFFSET
)
;
let
topLine
=
{
center
:
Math
.
max
(
line
-
halfVisible
0
)
bottom
:
Math
.
max
(
line
-
linesVisible
+
offset
0
)
top
:
Math
.
max
(
line
-
offset
0
)
}
[
align
|
|
"
top
"
]
|
|
offset
;
topLine
=
Math
.
min
(
topLine
cm
.
lineCount
(
)
)
;
this
.
setFirstVisibleLine
(
topLine
)
;
}
setFirstVisibleLine
(
line
:
number
)
{
const
{
top
}
=
this
.
editor
.
charCoords
(
{
line
:
line
ch
:
0
}
"
local
"
)
;
this
.
editor
.
scrollTo
(
0
top
)
;
}
}
