"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
addToTree
=
addToTree
;
var
_utils
=
require
(
"
.
/
utils
"
)
;
var
_treeOrder
=
require
(
"
.
/
treeOrder
"
)
;
var
_getURL
=
require
(
"
.
/
getURL
"
)
;
function
createNodeInTree
(
part
path
tree
index
)
{
const
node
=
(
0
_utils
.
createDirectoryNode
)
(
part
path
[
]
)
;
const
contents
=
tree
.
contents
.
slice
(
0
)
;
contents
.
splice
(
index
0
node
)
;
tree
.
contents
=
contents
;
return
node
;
}
function
findOrCreateNode
(
parts
subTree
path
part
index
url
debuggeeHost
)
{
const
addedPartIsFile
=
(
0
_utils
.
partIsFile
)
(
index
parts
url
)
;
const
{
found
:
childFound
index
:
childIndex
}
=
(
0
_treeOrder
.
findNodeInContents
)
(
subTree
(
0
_treeOrder
.
createTreeNodeMatcher
)
(
part
!
addedPartIsFile
debuggeeHost
)
)
;
if
(
!
childFound
)
{
return
createNodeInTree
(
part
path
subTree
childIndex
)
;
}
const
child
=
subTree
.
contents
[
childIndex
]
;
const
childIsFile
=
!
(
0
_utils
.
nodeHasChildren
)
(
child
)
;
if
(
child
.
type
=
=
=
"
source
"
|
|
!
childIsFile
&
&
addedPartIsFile
)
{
return
createNodeInTree
(
part
path
subTree
childIndex
)
;
}
return
child
;
}
function
traverseTree
(
url
tree
debuggeeHost
)
{
const
parts
=
url
.
path
.
split
(
"
/
"
)
.
filter
(
p
=
>
p
!
=
=
"
"
)
;
parts
.
unshift
(
url
.
group
)
;
let
path
=
"
"
;
return
parts
.
reduce
(
(
subTree
part
index
)
=
>
{
path
=
path
?
{
path
}
/
{
part
}
:
part
;
const
debuggeeHostIfRoot
=
index
=
=
=
0
?
debuggeeHost
:
null
;
return
findOrCreateNode
(
parts
subTree
path
part
index
url
debuggeeHostIfRoot
)
;
}
tree
)
;
}
function
addSourceToNode
(
node
url
source
)
{
const
isFile
=
!
(
0
_utils
.
isPathDirectory
)
(
url
.
path
)
;
if
(
node
.
type
=
=
"
source
"
)
{
throw
new
Error
(
wtf
{
node
.
name
}
)
;
}
if
(
isFile
)
{
node
.
type
=
"
source
"
;
return
source
;
}
const
{
filename
}
=
url
;
const
{
found
:
childFound
index
:
childIndex
}
=
(
0
_treeOrder
.
findNodeInContents
)
(
node
(
0
_treeOrder
.
createTreeNodeMatcher
)
(
filename
false
null
)
)
;
if
(
childFound
)
{
const
existingNode
=
node
.
contents
[
childIndex
]
;
if
(
existingNode
.
type
=
=
=
"
source
"
)
{
existingNode
.
contents
=
source
;
}
return
node
.
contents
;
}
const
newNode
=
(
0
_utils
.
createSourceNode
)
(
filename
source
.
url
source
)
;
const
contents
=
node
.
contents
.
slice
(
0
)
;
contents
.
splice
(
childIndex
0
newNode
)
;
return
contents
;
}
function
addToTree
(
tree
source
debuggeeUrl
projectRoot
)
{
const
url
=
(
0
_getURL
.
getURL
)
(
source
.
url
debuggeeUrl
)
;
const
debuggeeHost
=
(
0
_treeOrder
.
getDomain
)
(
debuggeeUrl
)
;
if
(
(
0
_utils
.
isInvalidUrl
)
(
url
source
)
)
{
return
;
}
const
finalNode
=
traverseTree
(
url
tree
debuggeeHost
)
;
finalNode
.
contents
=
addSourceToNode
(
finalNode
url
source
)
;
}
