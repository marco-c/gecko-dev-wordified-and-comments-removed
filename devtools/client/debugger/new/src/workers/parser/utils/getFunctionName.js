import
*
as
t
from
"
babel
/
types
"
;
import
type
{
Node
}
from
"
babel
/
types
"
;
export
default
function
getFunctionName
(
node
:
Node
parent
:
Node
)
:
string
{
if
(
t
.
isIdentifier
(
node
.
id
)
)
{
return
node
.
id
.
name
;
}
if
(
t
.
isObjectMethod
(
node
{
computed
:
false
}
)
|
|
t
.
isClassMethod
(
node
{
computed
:
false
}
)
)
{
const
key
=
node
.
key
;
if
(
t
.
isIdentifier
(
key
)
)
{
return
key
.
name
;
}
if
(
t
.
isStringLiteral
(
key
)
)
{
return
key
.
value
;
}
if
(
t
.
isNumericLiteral
(
key
)
)
{
return
{
key
.
value
}
;
}
}
if
(
t
.
isObjectProperty
(
parent
{
computed
:
false
value
:
node
}
)
|
|
(
t
.
isClassProperty
(
parent
{
value
:
node
}
)
&
&
!
parent
.
computed
)
)
{
const
key
=
parent
.
key
;
if
(
t
.
isIdentifier
(
key
)
)
{
return
key
.
name
;
}
if
(
t
.
isStringLiteral
(
key
)
)
{
return
key
.
value
;
}
if
(
t
.
isNumericLiteral
(
key
)
)
{
return
{
key
.
value
}
;
}
}
if
(
t
.
isAssignmentExpression
(
parent
{
operator
:
"
=
"
right
:
node
}
)
)
{
if
(
t
.
isIdentifier
(
parent
.
left
)
)
{
return
parent
.
left
.
name
;
}
if
(
t
.
isMemberExpression
(
parent
.
left
{
computed
:
false
}
)
)
{
return
parent
.
left
.
property
.
name
;
}
}
if
(
t
.
isAssignmentPattern
(
parent
{
right
:
node
}
)
&
&
t
.
isIdentifier
(
parent
.
left
)
)
{
return
parent
.
left
.
name
;
}
if
(
t
.
isVariableDeclarator
(
parent
{
init
:
node
}
)
&
&
t
.
isIdentifier
(
parent
.
id
)
)
{
return
parent
.
id
.
name
;
}
if
(
t
.
isExportDefaultDeclaration
(
parent
{
declaration
:
node
}
)
&
&
t
.
isFunctionDeclaration
(
node
)
)
{
return
"
default
"
;
}
return
"
anonymous
"
;
}
