"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_get
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
.
get
;
var
_get2
=
_interopRequireDefault
(
_get
)
;
var
_findIndex
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
.
findIndex
;
var
_findIndex2
=
_interopRequireDefault
(
_findIndex
)
;
var
_findLastIndex
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
.
findLastIndex
;
var
_findLastIndex2
=
_interopRequireDefault
(
_findLastIndex
)
;
var
_contains
=
require
(
"
.
/
utils
/
contains
"
)
;
var
_getSymbols
=
require
(
"
.
/
getSymbols
"
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
findSymbols
(
source
)
{
const
{
functions
comments
}
=
(
0
_getSymbols
.
getSymbols
)
(
source
)
;
return
{
functions
comments
}
;
}
function
getLocation
(
func
)
{
const
location
=
{
.
.
.
func
.
location
}
;
const
identifierEnd
=
(
0
_get2
.
default
)
(
func
"
identifier
.
loc
.
end
"
)
;
if
(
identifierEnd
)
{
location
.
start
=
identifierEnd
;
}
return
location
;
}
function
removeInnerLocations
(
locations
position
)
{
const
newLocs
=
locations
.
slice
(
)
;
const
parentIndex
=
(
0
_findLastIndex2
.
default
)
(
newLocs
loc
=
>
(
0
_contains
.
containsPosition
)
(
loc
position
)
)
;
if
(
parentIndex
<
0
)
{
return
newLocs
;
}
const
innerStartIndex
=
parentIndex
+
1
;
const
parentLoc
=
newLocs
[
parentIndex
]
;
const
outerBoundaryIndex
=
(
0
_findIndex2
.
default
)
(
newLocs
loc
=
>
!
(
0
_contains
.
containsLocation
)
(
parentLoc
loc
)
innerStartIndex
)
;
const
innerBoundaryIndex
=
outerBoundaryIndex
<
0
?
newLocs
.
length
-
1
:
outerBoundaryIndex
-
1
;
newLocs
.
splice
(
innerStartIndex
innerBoundaryIndex
-
parentIndex
)
;
return
newLocs
;
}
function
removeOverlaps
(
locations
)
{
if
(
locations
.
length
=
=
0
)
{
return
[
]
;
}
const
firstParent
=
locations
[
0
]
;
return
locations
.
reduce
(
deduplicateNode
[
firstParent
]
)
;
}
function
deduplicateNode
(
nodes
location
)
{
const
parent
=
nodes
[
nodes
.
length
-
1
]
;
if
(
!
(
0
_contains
.
containsLocation
)
(
parent
location
)
)
{
nodes
.
push
(
location
)
;
}
return
nodes
;
}
function
sortByStart
(
a
b
)
{
if
(
a
.
start
.
line
<
b
.
start
.
line
)
{
return
-
1
;
}
else
if
(
a
.
start
.
line
=
=
=
b
.
start
.
line
)
{
return
a
.
start
.
column
-
b
.
start
.
column
;
}
return
1
;
}
function
findOutOfScopeLocations
(
sourceId
position
)
{
const
{
functions
comments
}
=
findSymbols
(
sourceId
)
;
const
commentLocations
=
comments
.
map
(
c
=
>
c
.
location
)
;
let
locations
=
functions
.
map
(
getLocation
)
.
concat
(
commentLocations
)
.
sort
(
sortByStart
)
;
locations
=
removeInnerLocations
(
locations
position
)
.
filter
(
loc
=
>
!
(
0
_contains
.
containsPosition
)
(
loc
position
)
)
;
return
removeOverlaps
(
locations
)
;
}
exports
.
default
=
findOutOfScopeLocations
;
