import
{
getHiddenBreakpoint
isEvaluatingExpression
getSelectedFrame
getSources
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
mapFrames
}
from
"
.
"
;
import
{
removeBreakpoint
}
from
"
.
.
/
breakpoints
"
;
import
{
evaluateExpressions
}
from
"
.
.
/
expressions
"
;
import
{
selectLocation
}
from
"
.
.
/
sources
"
;
import
{
loadSourceText
}
from
"
.
.
/
sources
/
loadSourceText
"
;
import
{
togglePaneCollapse
}
from
"
.
.
/
ui
"
;
import
{
command
}
from
"
.
/
commands
"
;
import
{
shouldStep
}
from
"
.
.
/
.
.
/
utils
/
pause
"
;
import
{
updateFrameLocation
}
from
"
.
/
mapFrames
"
;
import
{
fetchScopes
}
from
"
.
/
fetchScopes
"
;
import
type
{
Pause
Frame
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
ThunkArgs
}
from
"
.
.
/
types
"
;
async
function
getOriginalSourceForFrame
(
state
frame
:
Frame
)
{
return
getSources
(
state
)
[
frame
.
location
.
sourceId
]
;
}
export
function
paused
(
pauseInfo
:
Pause
)
{
return
async
function
(
{
dispatch
getState
client
sourceMaps
}
:
ThunkArgs
)
{
const
{
thread
frames
why
loadedObjects
}
=
pauseInfo
;
const
topFrame
=
frames
.
length
>
0
?
frames
[
0
]
:
null
;
if
(
topFrame
&
&
!
why
.
frameFinished
&
&
why
.
type
=
=
"
resumeLimit
"
)
{
const
mappedFrame
=
await
updateFrameLocation
(
topFrame
sourceMaps
)
;
const
source
=
await
getOriginalSourceForFrame
(
getState
(
)
mappedFrame
)
;
await
dispatch
(
loadSourceText
(
source
)
)
;
if
(
shouldStep
(
mappedFrame
getState
(
)
sourceMaps
)
)
{
dispatch
(
command
(
"
stepOver
"
)
)
;
return
;
}
}
dispatch
(
{
type
:
"
PAUSED
"
thread
why
frames
selectedFrameId
:
topFrame
?
topFrame
.
id
:
undefined
loadedObjects
:
loadedObjects
|
|
[
]
}
)
;
const
hiddenBreakpoint
=
getHiddenBreakpoint
(
getState
(
)
)
;
if
(
hiddenBreakpoint
)
{
dispatch
(
removeBreakpoint
(
hiddenBreakpoint
)
)
;
}
await
dispatch
(
mapFrames
(
)
)
;
const
selectedFrame
=
getSelectedFrame
(
getState
(
)
)
;
if
(
selectedFrame
)
{
await
dispatch
(
selectLocation
(
selectedFrame
.
location
)
)
;
}
dispatch
(
togglePaneCollapse
(
"
end
"
false
)
)
;
await
dispatch
(
fetchScopes
(
)
)
;
const
atException
=
why
.
type
=
=
"
exception
"
;
if
(
!
atException
|
|
!
isEvaluatingExpression
(
getState
(
)
)
)
{
await
dispatch
(
evaluateExpressions
(
)
)
;
}
}
;
}
