import
{
getIsPaused
getCurrentThread
getSource
getTopFrame
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
PROMISE
}
from
"
.
.
/
utils
/
middleware
/
promise
"
;
import
{
getNextStep
}
from
"
.
.
/
.
.
/
workers
/
parser
"
;
import
{
addHiddenBreakpoint
}
from
"
.
.
/
breakpoints
"
;
import
{
evaluateExpressions
}
from
"
.
.
/
expressions
"
;
import
{
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
{
recordEvent
}
from
"
.
.
/
.
.
/
utils
/
telemetry
"
;
import
type
{
Source
ThreadId
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
ThunkArgs
}
from
"
.
.
/
types
"
;
import
type
{
Command
}
from
"
.
.
/
.
.
/
reducers
/
types
"
;
export
function
selectThread
(
thread
:
ThreadId
)
{
return
async
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
await
dispatch
(
{
type
:
"
SELECT_THREAD
"
thread
}
)
;
dispatch
(
evaluateExpressions
(
)
)
;
}
;
}
export
function
command
(
thread
:
ThreadId
type
:
Command
)
{
return
async
(
{
dispatch
getState
client
}
:
ThunkArgs
)
=
>
{
if
(
type
)
{
return
dispatch
(
{
type
:
"
COMMAND
"
command
:
type
thread
[
PROMISE
]
:
client
[
type
]
(
thread
)
}
)
;
}
}
;
}
export
function
stepIn
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
return
dispatch
(
command
(
thread
"
stepIn
"
)
)
;
}
}
;
}
export
function
stepOver
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
return
dispatch
(
astCommand
(
thread
"
stepOver
"
)
)
;
}
}
;
}
export
function
stepOut
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
return
dispatch
(
command
(
thread
"
stepOut
"
)
)
;
}
}
;
}
export
function
resume
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
recordEvent
(
"
continue
"
)
;
return
dispatch
(
command
(
thread
"
resume
"
)
)
;
}
}
;
}
export
function
rewind
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
return
dispatch
(
command
(
thread
"
rewind
"
)
)
;
}
}
;
}
export
function
reverseStepIn
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
return
dispatch
(
command
(
thread
"
reverseStepIn
"
)
)
;
}
}
;
}
export
function
reverseStepOver
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
return
dispatch
(
astCommand
(
thread
"
reverseStepOver
"
)
)
;
}
}
;
}
export
function
reverseStepOut
(
)
{
return
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
thread
=
getCurrentThread
(
getState
(
)
)
;
if
(
getIsPaused
(
getState
(
)
thread
)
)
{
return
dispatch
(
command
(
thread
"
reverseStepOut
"
)
)
;
}
}
;
}
function
hasAwait
(
source
:
Source
pauseLocation
)
{
const
{
line
column
}
=
pauseLocation
;
if
(
source
.
isWasm
|
|
!
source
.
text
)
{
return
false
;
}
const
lineText
=
source
.
text
.
split
(
"
\
n
"
)
[
line
-
1
]
;
if
(
!
lineText
)
{
return
false
;
}
const
snippet
=
lineText
.
slice
(
column
-
50
column
+
50
)
;
return
!
!
snippet
.
match
(
/
(
yield
|
await
)
/
)
;
}
export
function
astCommand
(
thread
:
ThreadId
stepType
:
Command
)
{
return
async
(
{
dispatch
getState
sourceMaps
}
:
ThunkArgs
)
=
>
{
if
(
!
features
.
asyncStepping
)
{
return
dispatch
(
command
(
thread
stepType
)
)
;
}
if
(
stepType
=
=
"
stepOver
"
)
{
const
frame
:
any
=
getTopFrame
(
getState
(
)
thread
)
;
const
source
=
getSource
(
getState
(
)
frame
.
location
.
sourceId
)
;
if
(
source
&
&
hasAwait
(
source
frame
.
location
)
)
{
const
nextLocation
=
await
getNextStep
(
source
.
id
frame
.
location
)
;
if
(
nextLocation
)
{
await
dispatch
(
addHiddenBreakpoint
(
nextLocation
)
)
;
return
dispatch
(
command
(
thread
"
resume
"
)
)
;
}
}
}
return
dispatch
(
command
(
thread
stepType
)
)
;
}
;
}
