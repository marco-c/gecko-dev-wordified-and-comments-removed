"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
command
=
command
;
exports
.
stepIn
=
stepIn
;
exports
.
stepOver
=
stepOver
;
exports
.
stepOut
=
stepOut
;
exports
.
resume
=
resume
;
exports
.
rewind
=
rewind
;
exports
.
reverseStepIn
=
reverseStepIn
;
exports
.
reverseStepOver
=
reverseStepOver
;
exports
.
reverseStepOut
=
reverseStepOut
;
exports
.
astCommand
=
astCommand
;
var
_selectors
=
require
(
"
.
.
/
.
.
/
selectors
/
index
"
)
;
var
_promise
=
require
(
"
.
.
/
utils
/
middleware
/
promise
"
)
;
var
_parser
=
require
(
"
.
.
/
.
.
/
workers
/
parser
/
index
"
)
;
var
_breakpoints
=
require
(
"
.
.
/
breakpoints
/
index
"
)
;
var
_prefs
=
require
(
"
.
.
/
.
.
/
utils
/
prefs
"
)
;
var
_telemetry
=
require
(
"
.
.
/
.
.
/
utils
/
telemetry
"
)
;
function
command
(
type
)
{
return
async
(
{
dispatch
client
}
)
=
>
{
return
dispatch
(
{
type
:
"
COMMAND
"
command
:
type
[
_promise
.
PROMISE
]
:
client
[
type
]
(
)
}
)
;
}
;
}
function
stepIn
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
return
dispatch
(
command
(
"
stepIn
"
)
)
;
}
}
;
}
function
stepOver
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
return
dispatch
(
astCommand
(
"
stepOver
"
)
)
;
}
}
;
}
function
stepOut
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
return
dispatch
(
command
(
"
stepOut
"
)
)
;
}
}
;
}
function
resume
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
(
0
_telemetry
.
recordEvent
)
(
"
continue
"
)
;
return
dispatch
(
command
(
"
resume
"
)
)
;
}
}
;
}
function
rewind
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
return
dispatch
(
command
(
"
rewind
"
)
)
;
}
}
;
}
function
reverseStepIn
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
return
dispatch
(
command
(
"
reverseStepIn
"
)
)
;
}
}
;
}
function
reverseStepOver
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
return
dispatch
(
astCommand
(
"
reverseStepOver
"
)
)
;
}
}
;
}
function
reverseStepOut
(
)
{
return
(
{
dispatch
getState
}
)
=
>
{
if
(
(
0
_selectors
.
isPaused
)
(
getState
(
)
)
)
{
return
dispatch
(
command
(
"
reverseStepOut
"
)
)
;
}
}
;
}
function
hasAwait
(
source
pauseLocation
)
{
const
{
line
column
}
=
pauseLocation
;
if
(
!
source
.
text
)
{
return
false
;
}
const
lineText
=
source
.
text
.
split
(
"
\
n
"
)
[
line
-
1
]
;
if
(
!
lineText
)
{
return
false
;
}
const
snippet
=
lineText
.
slice
(
column
-
50
column
+
50
)
;
return
!
!
snippet
.
match
(
/
(
yield
|
await
)
/
)
;
}
function
astCommand
(
stepType
)
{
return
async
(
{
dispatch
getState
sourceMaps
}
)
=
>
{
if
(
!
_prefs
.
features
.
asyncStepping
)
{
return
dispatch
(
command
(
stepType
)
)
;
}
if
(
stepType
=
=
"
stepOver
"
)
{
const
frame
=
(
0
_selectors
.
getTopFrame
)
(
getState
(
)
)
;
const
source
=
(
0
_selectors
.
getSource
)
(
getState
(
)
frame
.
location
.
sourceId
)
;
if
(
source
&
&
hasAwait
(
source
frame
.
location
)
)
{
const
nextLocation
=
await
(
0
_parser
.
getNextStep
)
(
source
.
id
frame
.
location
)
;
if
(
nextLocation
)
{
await
dispatch
(
(
0
_breakpoints
.
addHiddenBreakpoint
)
(
nextLocation
)
)
;
return
dispatch
(
command
(
"
resume
"
)
)
;
}
}
}
return
dispatch
(
command
(
stepType
)
)
;
}
;
}
