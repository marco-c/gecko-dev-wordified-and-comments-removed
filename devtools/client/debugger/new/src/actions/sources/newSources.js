import
{
generatedToOriginalId
}
from
"
devtools
-
source
-
map
"
;
import
{
flatten
}
from
"
lodash
"
;
import
{
toggleBlackBox
}
from
"
.
/
blackbox
"
;
import
{
syncBreakpoint
}
from
"
.
.
/
breakpoints
"
;
import
{
loadSourceText
}
from
"
.
/
loadSourceText
"
;
import
{
togglePrettyPrint
}
from
"
.
/
prettyPrint
"
;
import
{
selectLocation
}
from
"
.
.
/
sources
"
;
import
{
getRawSourceURL
isPrettyURL
isOriginal
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
getBlackBoxList
getSource
hasSourceActor
getPendingSelectedLocation
getPendingBreakpointsForSource
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
prefs
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
sourceQueue
from
"
.
.
/
.
.
/
utils
/
source
-
queue
"
;
import
type
{
Source
SourceId
}
from
"
.
.
/
.
.
/
types
"
;
import
type
{
Action
ThunkArgs
}
from
"
.
.
/
types
"
;
import
type
{
CreateSourceResult
}
from
"
.
.
/
.
.
/
client
/
firefox
/
types
"
;
function
createOriginalSource
(
originalUrl
generatedSource
sourceMaps
)
:
Source
{
return
{
url
:
originalUrl
relativeUrl
:
originalUrl
id
:
generatedToOriginalId
(
generatedSource
.
id
originalUrl
)
isPrettyPrinted
:
false
isWasm
:
false
isBlackBoxed
:
false
loadedState
:
"
unloaded
"
introductionUrl
:
null
}
;
}
function
loadSourceMaps
(
sources
:
Source
[
]
)
{
return
async
function
(
{
dispatch
sourceMaps
}
:
ThunkArgs
)
:
Promise
<
Promise
<
Source
>
[
]
>
{
if
(
!
prefs
.
clientSourceMapsEnabled
)
{
return
[
]
;
}
const
sourceList
=
await
Promise
.
all
(
sources
.
map
(
async
(
{
id
}
)
=
>
{
const
originalSources
=
await
dispatch
(
loadSourceMap
(
id
)
)
;
sourceQueue
.
queueSources
(
originalSources
.
map
(
source
=
>
(
{
source
}
)
)
)
;
return
originalSources
;
}
)
)
;
await
sourceQueue
.
flush
(
)
;
return
flatten
(
sourceList
)
;
}
;
}
function
loadSourceMap
(
sourceId
:
SourceId
)
{
return
async
function
(
{
dispatch
getState
sourceMaps
}
:
ThunkArgs
)
:
Promise
<
Source
[
]
>
{
const
source
=
getSource
(
getState
(
)
sourceId
)
;
if
(
!
source
|
|
isOriginal
(
source
)
|
|
!
source
.
sourceMapURL
)
{
return
[
]
;
}
let
urls
=
null
;
try
{
const
urlInfo
=
{
.
.
.
source
}
;
if
(
!
urlInfo
.
url
)
{
urlInfo
.
url
=
urlInfo
.
introductionUrl
;
}
urls
=
await
sourceMaps
.
getOriginalURLs
(
urlInfo
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
if
(
!
urls
)
{
const
currentSource
=
getSource
(
getState
(
)
sourceId
)
;
dispatch
(
(
{
type
:
"
UPDATE_SOURCE
"
source
:
(
(
{
.
.
.
currentSource
sourceMapURL
:
"
"
}
:
any
)
:
Source
)
}
:
Action
)
)
;
return
[
]
;
}
return
urls
.
map
(
url
=
>
createOriginalSource
(
url
source
sourceMaps
)
)
;
}
;
}
function
checkSelectedSource
(
sourceId
:
string
)
{
return
async
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
source
=
getSource
(
getState
(
)
sourceId
)
;
const
pendingLocation
=
getPendingSelectedLocation
(
getState
(
)
)
;
if
(
!
pendingLocation
|
|
!
pendingLocation
.
url
|
|
!
source
|
|
!
source
.
url
)
{
return
;
}
const
pendingUrl
=
pendingLocation
.
url
;
const
rawPendingUrl
=
getRawSourceURL
(
pendingUrl
)
;
if
(
rawPendingUrl
=
=
=
source
.
url
)
{
if
(
isPrettyURL
(
pendingUrl
)
)
{
const
prettySource
=
await
dispatch
(
togglePrettyPrint
(
source
.
id
)
)
;
return
dispatch
(
checkPendingBreakpoints
(
prettySource
.
id
)
)
;
}
await
dispatch
(
selectLocation
(
{
sourceId
:
source
.
id
line
:
typeof
pendingLocation
.
line
=
=
=
"
number
"
?
pendingLocation
.
line
:
0
column
:
pendingLocation
.
column
}
)
)
;
}
}
;
}
function
checkPendingBreakpoints
(
sourceId
:
string
)
{
return
async
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
source
=
getSource
(
getState
(
)
sourceId
)
;
if
(
!
source
)
{
return
;
}
const
pendingBreakpoints
=
getPendingBreakpointsForSource
(
getState
(
)
source
)
;
if
(
pendingBreakpoints
.
length
=
=
=
0
)
{
return
;
}
await
dispatch
(
loadSourceText
(
source
)
)
;
await
Promise
.
all
(
pendingBreakpoints
.
map
(
bp
=
>
dispatch
(
syncBreakpoint
(
sourceId
bp
)
)
)
)
;
}
;
}
function
restoreBlackBoxedSources
(
sources
:
Source
[
]
)
{
return
async
(
{
dispatch
}
:
ThunkArgs
)
=
>
{
const
tabs
=
getBlackBoxList
(
)
;
if
(
tabs
.
length
=
=
0
)
{
return
;
}
for
(
const
source
of
sources
)
{
if
(
tabs
.
includes
(
source
.
url
)
&
&
!
source
.
isBlackBoxed
)
{
dispatch
(
toggleBlackBox
(
source
)
)
;
}
}
}
;
}
export
function
newSource
(
source
:
CreateSourceResult
)
{
return
async
(
{
dispatch
}
:
ThunkArgs
)
=
>
{
await
dispatch
(
newSources
(
[
source
]
)
)
;
}
;
}
export
function
newSources
(
createdSources
:
CreateSourceResult
[
]
)
{
return
async
(
{
dispatch
getState
}
:
ThunkArgs
)
=
>
{
const
sources
=
createdSources
.
map
(
csr
=
>
csr
.
source
)
.
filter
(
source
=
>
!
getSource
(
getState
(
)
source
.
id
)
)
;
const
sourceActors
=
createdSources
.
map
(
csr
=
>
csr
.
sourceActor
)
.
filter
(
sourceActor
=
>
sourceActor
&
&
!
hasSourceActor
(
getState
(
)
sourceActor
)
)
;
if
(
sources
.
length
=
=
0
&
&
sourceActors
.
length
=
=
0
)
{
return
;
}
dispatch
(
{
type
:
"
ADD_SOURCES
"
sources
sourceActors
}
)
;
if
(
sources
.
length
=
=
0
)
{
return
;
}
for
(
const
source
of
sources
)
{
dispatch
(
checkSelectedSource
(
source
.
id
)
)
;
}
dispatch
(
restoreBlackBoxedSources
(
sources
)
)
;
dispatch
(
loadSourceMaps
(
sources
)
)
.
then
(
(
)
=
>
{
for
(
const
source
of
sources
)
{
dispatch
(
checkPendingBreakpoints
(
source
.
id
)
)
;
}
}
)
;
}
;
}
