"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
newSource
=
newSource
;
exports
.
newSources
=
newSources
;
var
_devtoolsSourceMap
=
require
(
"
devtools
/
client
/
shared
/
source
-
map
/
index
.
js
"
)
;
var
_lodash
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
;
var
_blackbox
=
require
(
"
.
/
blackbox
"
)
;
var
_breakpoints
=
require
(
"
.
.
/
breakpoints
/
index
"
)
;
var
_loadSourceText
=
require
(
"
.
/
loadSourceText
"
)
;
var
_prettyPrint
=
require
(
"
.
/
prettyPrint
"
)
;
var
_sources
=
require
(
"
.
.
/
sources
/
index
"
)
;
var
_source
=
require
(
"
.
.
/
.
.
/
utils
/
source
"
)
;
var
_selectors
=
require
(
"
.
.
/
.
.
/
selectors
/
index
"
)
;
function
createOriginalSource
(
originalUrl
generatedSource
sourceMaps
)
{
return
{
url
:
originalUrl
relativeUrl
:
originalUrl
id
:
sourceMaps
.
generatedToOriginalId
(
generatedSource
.
id
originalUrl
)
isPrettyPrinted
:
false
isWasm
:
false
isBlackBoxed
:
false
loadedState
:
"
unloaded
"
}
;
}
function
loadSourceMaps
(
sources
)
{
return
async
function
(
{
dispatch
sourceMaps
}
)
{
if
(
!
sourceMaps
)
{
return
;
}
const
originalSources
=
await
Promise
.
all
(
sources
.
map
(
source
=
>
dispatch
(
loadSourceMap
(
source
.
id
)
)
)
)
;
await
dispatch
(
newSources
(
(
0
_lodash
.
flatten
)
(
originalSources
)
)
)
;
}
;
}
function
loadSourceMap
(
sourceId
)
{
return
async
function
(
{
dispatch
getState
sourceMaps
}
)
{
const
source
=
(
0
_selectors
.
getSource
)
(
getState
(
)
sourceId
)
;
if
(
!
source
|
|
!
(
0
_devtoolsSourceMap
.
isGeneratedId
)
(
sourceId
)
|
|
!
source
.
sourceMapURL
)
{
return
;
}
let
urls
=
null
;
try
{
urls
=
await
sourceMaps
.
getOriginalURLs
(
source
)
;
}
catch
(
e
)
{
console
.
error
(
e
)
;
}
if
(
!
urls
)
{
dispatch
(
{
type
:
"
UPDATE_SOURCE
"
source
:
{
.
.
.
source
sourceMapURL
:
"
"
}
}
)
;
return
;
}
return
urls
.
map
(
url
=
>
createOriginalSource
(
url
source
sourceMaps
)
)
;
}
;
}
function
checkSelectedSource
(
sourceId
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
source
=
(
0
_selectors
.
getSourceFromId
)
(
getState
(
)
sourceId
)
;
const
pendingLocation
=
(
0
_selectors
.
getPendingSelectedLocation
)
(
getState
(
)
)
;
if
(
!
pendingLocation
|
|
!
pendingLocation
.
url
|
|
!
source
.
url
)
{
return
;
}
const
pendingUrl
=
pendingLocation
.
url
;
const
rawPendingUrl
=
(
0
_source
.
getRawSourceURL
)
(
pendingUrl
)
;
if
(
rawPendingUrl
=
=
=
source
.
url
)
{
if
(
(
0
_source
.
isPrettyURL
)
(
pendingUrl
)
)
{
const
prettySource
=
await
dispatch
(
(
0
_prettyPrint
.
togglePrettyPrint
)
(
source
.
id
)
)
;
return
dispatch
(
checkPendingBreakpoints
(
prettySource
.
id
)
)
;
}
await
dispatch
(
(
0
_sources
.
selectLocation
)
(
{
.
.
.
pendingLocation
sourceId
:
source
.
id
}
)
)
;
}
}
;
}
function
checkPendingBreakpoints
(
sourceId
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
source
=
(
0
_selectors
.
getSourceFromId
)
(
getState
(
)
sourceId
)
;
const
pendingBreakpoints
=
(
0
_selectors
.
getPendingBreakpointsForSource
)
(
getState
(
)
source
.
url
)
;
if
(
pendingBreakpoints
.
length
=
=
=
0
)
{
return
;
}
await
dispatch
(
(
0
_loadSourceText
.
loadSourceText
)
(
source
)
)
;
await
Promise
.
all
(
pendingBreakpoints
.
map
(
bp
=
>
dispatch
(
(
0
_breakpoints
.
syncBreakpoint
)
(
sourceId
bp
)
)
)
)
;
}
;
}
function
restoreBlackBoxedSources
(
sources
)
{
return
async
(
{
dispatch
}
)
=
>
{
const
tabs
=
(
0
_selectors
.
getBlackBoxList
)
(
)
;
if
(
tabs
.
length
=
=
0
)
{
return
;
}
for
(
const
source
of
sources
)
{
if
(
tabs
.
includes
(
source
.
url
)
&
&
!
source
.
isBlackBoxed
)
{
dispatch
(
(
0
_blackbox
.
toggleBlackBox
)
(
source
)
)
;
}
}
}
;
}
function
newSource
(
source
)
{
return
async
(
{
dispatch
}
)
=
>
{
await
dispatch
(
newSources
(
[
source
]
)
)
;
}
;
}
function
newSources
(
sources
)
{
return
async
(
{
dispatch
getState
}
)
=
>
{
const
filteredSources
=
sources
.
filter
(
source
=
>
source
&
&
!
(
0
_selectors
.
getSource
)
(
getState
(
)
source
.
id
)
)
;
if
(
filteredSources
.
length
=
=
0
)
{
return
;
}
dispatch
(
{
type
:
"
ADD_SOURCES
"
sources
:
filteredSources
}
)
;
for
(
const
source
of
filteredSources
)
{
dispatch
(
checkSelectedSource
(
source
.
id
)
)
;
dispatch
(
checkPendingBreakpoints
(
source
.
id
)
)
;
}
await
dispatch
(
loadSourceMaps
(
filteredSources
)
)
;
await
dispatch
(
restoreBlackBoxedSources
(
filteredSources
)
)
;
}
;
}
