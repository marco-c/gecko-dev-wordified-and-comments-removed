import
{
setBreakpointPositions
}
from
"
.
/
breakpointPositions
"
;
import
{
locationMoved
createBreakpoint
assertBreakpoint
assertPendingBreakpoint
findScopeByName
makeSourceActorLocation
makeBreakpointLocation
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
{
getGeneratedLocation
}
from
"
.
.
/
.
.
/
utils
/
source
-
maps
"
;
import
{
getTextAtPosition
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
originalToGeneratedId
isOriginalId
}
from
"
devtools
-
source
-
map
"
;
import
{
getSource
getSourceActors
}
from
"
.
.
/
.
.
/
selectors
"
;
import
{
features
}
from
"
.
.
/
.
.
/
utils
/
prefs
"
;
import
type
{
ThunkArgs
Action
}
from
"
.
.
/
types
"
;
import
type
{
SourceLocation
ASTLocation
PendingBreakpoint
SourceId
Breakpoint
}
from
"
.
.
/
.
.
/
types
"
;
type
BreakpointSyncData
=
{
previousLocation
:
SourceLocation
breakpoint
:
?
Breakpoint
}
;
async
function
makeScopedLocation
(
{
name
offset
index
}
:
ASTLocation
location
:
SourceLocation
source
)
{
const
scope
=
await
findScopeByName
(
source
name
index
)
;
const
line
=
scope
?
scope
.
location
.
start
.
line
+
offset
.
line
:
location
.
line
;
return
{
line
column
:
location
.
column
sourceUrl
:
source
.
url
sourceId
:
source
.
id
}
;
}
function
createSyncData
(
pendingBreakpoint
:
PendingBreakpoint
location
:
SourceLocation
generatedLocation
:
SourceLocation
previousLocation
:
SourceLocation
text
:
string
originalText
:
string
)
:
BreakpointSyncData
{
const
overrides
=
{
.
.
.
pendingBreakpoint
generatedLocation
text
originalText
}
;
const
breakpoint
=
createBreakpoint
(
location
overrides
)
;
assertBreakpoint
(
breakpoint
)
;
return
{
breakpoint
previousLocation
}
;
}
export
async
function
syncBreakpointPromise
(
getState
:
Function
client
:
Object
sourceMaps
:
Object
dispatch
:
Function
sourceId
:
SourceId
pendingBreakpoint
:
PendingBreakpoint
)
:
Promise
<
BreakpointSyncData
|
null
>
{
assertPendingBreakpoint
(
pendingBreakpoint
)
;
const
source
=
getSource
(
getState
(
)
sourceId
)
;
const
generatedSourceId
=
isOriginalId
(
sourceId
)
?
originalToGeneratedId
(
sourceId
)
:
sourceId
;
const
generatedSource
=
getSource
(
getState
(
)
generatedSourceId
)
;
if
(
!
source
)
{
return
null
;
}
const
{
location
astLocation
}
=
pendingBreakpoint
;
const
previousLocation
=
{
.
.
.
location
sourceId
}
;
const
scopedLocation
=
await
makeScopedLocation
(
astLocation
previousLocation
source
)
;
const
scopedGeneratedLocation
=
await
getGeneratedLocation
(
getState
(
)
source
scopedLocation
sourceMaps
)
;
const
generatedLocation
=
{
.
.
.
pendingBreakpoint
.
generatedLocation
sourceId
:
generatedSourceId
}
;
const
isSameLocation
=
!
locationMoved
(
generatedLocation
scopedGeneratedLocation
)
;
if
(
!
getSource
(
getState
(
)
generatedSourceId
)
)
{
return
null
;
}
const
breakpointLocation
=
makeBreakpointLocation
(
getState
(
)
generatedLocation
)
;
const
scopedBreakpointLocation
=
makeBreakpointLocation
(
getState
(
)
scopedGeneratedLocation
)
;
let
possiblePosition
=
true
;
if
(
features
.
columnBreakpoints
&
&
generatedLocation
.
column
!
=
undefined
)
{
const
{
positions
}
=
await
dispatch
(
setBreakpointPositions
(
generatedLocation
)
)
;
if
(
!
positions
.
includes
(
generatedLocation
.
column
)
)
{
possiblePosition
=
false
;
}
}
if
(
possiblePosition
&
&
(
pendingBreakpoint
.
disabled
|
|
isSameLocation
)
)
{
if
(
!
pendingBreakpoint
.
disabled
)
{
await
client
.
setBreakpoint
(
breakpointLocation
pendingBreakpoint
.
options
)
;
}
const
originalText
=
getTextAtPosition
(
source
previousLocation
)
;
const
text
=
getTextAtPosition
(
generatedSource
generatedLocation
)
;
return
createSyncData
(
pendingBreakpoint
scopedLocation
scopedGeneratedLocation
previousLocation
text
originalText
)
;
}
await
client
.
removeBreakpoint
(
breakpointLocation
)
;
if
(
!
possiblePosition
|
|
!
scopedGeneratedLocation
.
line
)
{
return
{
previousLocation
breakpoint
:
null
}
;
}
if
(
!
scopedGeneratedLocation
.
line
)
{
return
{
previousLocation
breakpoint
:
null
}
;
}
await
client
.
setBreakpoint
(
scopedGeneratedLocation
pendingBreakpoint
.
options
)
;
const
originalText
=
getTextAtPosition
(
source
scopedLocation
)
;
const
text
=
getTextAtPosition
(
generatedSource
scopedGeneratedLocation
)
;
return
createSyncData
(
pendingBreakpoint
scopedLocation
scopedGeneratedLocation
previousLocation
text
originalText
)
;
}
export
function
syncBreakpoint
(
sourceId
:
SourceId
pendingBreakpoint
:
PendingBreakpoint
)
{
return
async
(
{
dispatch
getState
client
sourceMaps
}
:
ThunkArgs
)
=
>
{
const
response
=
await
syncBreakpointPromise
(
getState
client
sourceMaps
dispatch
sourceId
pendingBreakpoint
)
;
if
(
!
response
)
{
return
;
}
const
{
breakpoint
previousLocation
}
=
response
;
return
dispatch
(
(
{
type
:
"
SYNC_BREAKPOINT
"
breakpoint
previousLocation
}
:
Action
)
)
;
}
;
}
