import
{
locationMoved
createBreakpoint
assertBreakpoint
assertPendingBreakpoint
findScopeByName
makeSourceActorLocation
}
from
"
.
.
/
.
.
/
utils
/
breakpoint
"
;
import
{
getGeneratedLocation
}
from
"
.
.
/
.
.
/
utils
/
source
-
maps
"
;
import
{
getTextAtPosition
}
from
"
.
.
/
.
.
/
utils
/
source
"
;
import
{
originalToGeneratedId
isOriginalId
}
from
"
devtools
-
source
-
map
"
;
import
{
getSource
getSourceActors
}
from
"
.
.
/
.
.
/
selectors
"
;
import
type
{
ThunkArgs
Action
}
from
"
.
.
/
types
"
;
import
type
{
SourceLocation
ASTLocation
PendingBreakpoint
SourceId
Breakpoint
}
from
"
.
.
/
.
.
/
types
"
;
type
BreakpointSyncData
=
{
previousLocation
:
SourceLocation
breakpoint
:
?
Breakpoint
}
;
async
function
makeScopedLocation
(
{
name
offset
index
}
:
ASTLocation
location
:
SourceLocation
source
)
{
const
scope
=
await
findScopeByName
(
source
name
index
)
;
const
line
=
scope
?
scope
.
location
.
start
.
line
+
offset
.
line
:
location
.
line
;
return
{
line
column
:
location
.
column
sourceUrl
:
source
.
url
sourceId
:
source
.
id
}
;
}
function
createSyncData
(
pendingBreakpoint
:
PendingBreakpoint
location
:
SourceLocation
generatedLocation
:
SourceLocation
previousLocation
:
SourceLocation
text
:
string
originalText
:
string
)
:
BreakpointSyncData
{
const
overrides
=
{
.
.
.
pendingBreakpoint
generatedLocation
text
originalText
}
;
const
breakpoint
=
createBreakpoint
(
location
overrides
)
;
assertBreakpoint
(
breakpoint
)
;
return
{
breakpoint
previousLocation
}
;
}
export
async
function
syncBreakpointPromise
(
getState
:
Function
client
:
Object
sourceMaps
:
Object
sourceId
:
SourceId
pendingBreakpoint
:
PendingBreakpoint
)
:
Promise
<
BreakpointSyncData
|
null
>
{
assertPendingBreakpoint
(
pendingBreakpoint
)
;
const
source
=
getSource
(
getState
(
)
sourceId
)
;
const
generatedSourceId
=
isOriginalId
(
sourceId
)
?
originalToGeneratedId
(
sourceId
)
:
sourceId
;
const
generatedSource
=
getSource
(
getState
(
)
generatedSourceId
)
;
if
(
!
source
)
{
return
null
;
}
const
{
location
astLocation
}
=
pendingBreakpoint
;
const
previousLocation
=
{
.
.
.
location
sourceId
}
;
const
scopedLocation
=
await
makeScopedLocation
(
astLocation
previousLocation
source
)
;
const
scopedGeneratedLocation
=
await
getGeneratedLocation
(
getState
(
)
source
scopedLocation
sourceMaps
)
;
const
generatedLocation
=
{
.
.
.
pendingBreakpoint
.
generatedLocation
sourceId
:
generatedSourceId
}
;
const
isSameLocation
=
!
locationMoved
(
generatedLocation
scopedGeneratedLocation
)
;
const
sourceActors
=
getSourceActors
(
getState
(
)
sourceId
)
;
if
(
pendingBreakpoint
.
disabled
|
|
isSameLocation
)
{
if
(
!
pendingBreakpoint
.
disabled
)
{
for
(
const
sourceActor
of
sourceActors
)
{
const
sourceActorLocation
=
makeSourceActorLocation
(
sourceActor
generatedLocation
)
;
if
(
!
client
.
getBreakpointByLocation
(
sourceActorLocation
)
)
{
await
client
.
setBreakpoint
(
sourceActorLocation
pendingBreakpoint
.
options
isOriginalId
(
sourceId
)
)
;
}
}
}
const
originalText
=
getTextAtPosition
(
source
previousLocation
)
;
const
text
=
getTextAtPosition
(
generatedSource
generatedLocation
)
;
return
createSyncData
(
pendingBreakpoint
scopedLocation
scopedGeneratedLocation
previousLocation
text
originalText
)
;
}
for
(
const
sourceActor
of
sourceActors
)
{
const
sourceActorLocation
=
makeSourceActorLocation
(
sourceActor
generatedLocation
)
;
if
(
client
.
getBreakpointByLocation
(
sourceActorLocation
)
)
{
await
client
.
removeBreakpoint
(
sourceActorLocation
)
;
}
}
if
(
!
scopedGeneratedLocation
.
line
)
{
return
{
previousLocation
breakpoint
:
null
}
;
}
const
newGeneratedLocation
=
{
.
.
.
scopedGeneratedLocation
}
;
for
(
const
sourceActor
of
sourceActors
)
{
const
sourceActorLocation
=
makeSourceActorLocation
(
sourceActor
scopedGeneratedLocation
)
;
const
{
actualLocation
}
=
await
client
.
setBreakpoint
(
sourceActorLocation
pendingBreakpoint
.
options
isOriginalId
(
sourceId
)
)
;
newGeneratedLocation
.
line
=
actualLocation
.
line
;
newGeneratedLocation
.
column
=
actualLocation
.
column
;
}
const
newLocation
=
await
sourceMaps
.
getOriginalLocation
(
newGeneratedLocation
)
;
const
originalText
=
getTextAtPosition
(
source
newLocation
)
;
const
text
=
getTextAtPosition
(
generatedSource
newGeneratedLocation
)
;
return
createSyncData
(
pendingBreakpoint
newLocation
newGeneratedLocation
previousLocation
text
originalText
)
;
}
export
function
syncBreakpoint
(
sourceId
:
SourceId
pendingBreakpoint
:
PendingBreakpoint
)
{
return
async
(
{
dispatch
getState
client
sourceMaps
}
:
ThunkArgs
)
=
>
{
const
response
=
await
syncBreakpointPromise
(
getState
client
sourceMaps
sourceId
pendingBreakpoint
)
;
if
(
!
response
)
{
return
;
}
const
{
breakpoint
previousLocation
}
=
response
;
return
dispatch
(
(
{
type
:
"
SYNC_BREAKPOINT
"
breakpoint
previousLocation
}
:
Action
)
)
;
}
;
}
