jest
.
mock
(
"
.
.
/
.
.
/
.
.
/
utils
/
source
-
maps
"
(
)
=
>
(
{
getGeneratedLocation
:
jest
.
fn
(
)
}
)
)
;
import
{
getGeneratedLocation
}
from
"
.
.
/
.
.
/
.
.
/
utils
/
source
-
maps
"
;
jest
.
mock
(
"
.
.
/
.
.
/
.
.
/
utils
/
prefs
"
(
)
=
>
(
{
prefs
:
{
expressions
:
[
]
pendingBreakpoints
:
{
}
}
features
:
{
replay
:
false
}
clear
:
jest
.
fn
(
)
}
)
)
;
import
{
createStore
selectors
actions
makeSource
}
from
"
.
.
/
.
.
/
.
.
/
utils
/
test
-
head
"
;
import
{
makeBreakpointId
}
from
"
.
.
/
.
.
/
.
.
/
utils
/
breakpoint
"
;
jest
.
mock
(
"
.
.
/
.
.
/
.
.
/
utils
/
breakpoint
/
astBreakpointLocation
"
(
)
=
>
(
{
findScopeByName
:
jest
.
fn
(
)
getASTLocation
:
jest
.
fn
(
)
}
)
)
;
import
{
findScopeByName
}
from
"
.
.
/
.
.
/
.
.
/
utils
/
breakpoint
/
astBreakpointLocation
"
;
import
{
syncBreakpointPromise
}
from
"
.
.
/
.
.
/
breakpoints
/
syncBreakpoint
.
js
"
;
function
setBreakpoint
(
location
condition
)
{
const
actualLocation
=
{
.
.
.
location
line
:
location
.
line
}
;
return
Promise
.
resolve
(
{
id
:
makeBreakpointId
(
location
)
actualLocation
condition
}
)
;
}
const
clientBreakpoint
=
{
id
:
"
foo
"
actualLocation
:
{
sourceUrl
:
"
http
:
/
/
localhost
:
8000
/
gen
.
js
"
sourceId
:
"
gen
.
js
"
line
:
3
column
:
undefined
}
}
;
const
threadClient
=
{
getBreakpointByLocation
:
(
)
=
>
clientBreakpoint
setBreakpoint
removeBreakpoint
:
jest
.
fn
(
)
}
;
const
sourceMaps
=
{
getOriginalLocation
:
(
)
=
>
(
{
sourceId
:
"
magic
.
js
"
sourceUrl
:
"
http
:
/
/
localhost
:
8000
/
magic
.
js
"
line
:
3
column
:
undefined
}
)
getOriginalURLs
:
(
)
=
>
{
}
isOriginalId
:
(
)
=
>
true
getGeneratedLocation
:
(
)
=
>
(
{
}
)
}
;
function
pendingBreakpoint
(
overrides
)
{
return
{
location
:
{
sourceId
:
"
magic
.
js
"
sourceUrl
:
"
http
:
/
/
localhost
:
8000
/
magic
.
js
"
line
:
3
column
:
undefined
}
generatedLocation
:
{
sourceId
:
"
gen
.
js
"
sourceUrl
:
"
http
:
/
/
localhost
:
8000
/
gen
.
js
"
line
:
3
column
:
undefined
}
astLocation
:
{
name
:
undefined
offset
:
{
line
:
3
}
index
:
0
}
options
:
{
logValue
:
"
"
hidden
:
false
}
disabled
:
false
loading
:
false
text
:
"
"
.
.
.
overrides
}
;
}
function
newGeneratedLocation
(
line
)
{
return
{
sourceUrl
:
"
http
:
/
/
localhost
:
8000
/
gen
.
js
"
sourceId
:
"
gen
.
js
"
line
column
:
undefined
}
;
}
describe
(
"
loading
the
debugger
"
(
)
=
>
{
it
(
"
loads
the
initial
breakpoint
state
"
async
(
)
=
>
{
(
getGeneratedLocation
:
any
)
.
mockImplementation
(
(
)
=
>
newGeneratedLocation
(
3
)
)
;
const
{
dispatch
getState
}
=
createStore
(
threadClient
{
}
sourceMaps
)
;
const
reloadedSource
=
makeSource
(
"
magic
.
js
"
)
;
await
dispatch
(
actions
.
newSource
(
reloadedSource
)
)
;
expect
(
selectors
.
getBreakpointCount
(
getState
(
)
)
)
.
toEqual
(
0
)
;
const
update
=
await
syncBreakpointPromise
(
getState
threadClient
sourceMaps
dispatch
reloadedSource
.
source
.
id
pendingBreakpoint
(
)
)
;
expect
(
threadClient
.
removeBreakpoint
.
mock
.
calls
)
.
toHaveLength
(
0
)
;
expect
(
update
)
.
toMatchSnapshot
(
)
;
}
)
;
it
(
"
loads
the
initial
breakpoint
state
with
a
changed
file
"
async
(
)
=
>
{
const
location
=
{
line
:
9
column
:
0
}
;
const
generated
=
3
;
(
getGeneratedLocation
:
any
)
.
mockImplementation
(
(
)
=
>
newGeneratedLocation
(
generated
)
)
;
(
findScopeByName
:
any
)
.
mockImplementation
(
(
)
=
>
(
{
location
:
{
start
:
location
}
}
)
)
;
const
{
dispatch
getState
}
=
createStore
(
threadClient
{
}
sourceMaps
)
;
const
reloadedSource
=
makeSource
(
"
magic
.
js
"
)
;
await
dispatch
(
actions
.
newSource
(
reloadedSource
)
)
;
expect
(
selectors
.
getBreakpointCount
(
getState
(
)
)
)
.
toEqual
(
0
)
;
const
update
=
await
syncBreakpointPromise
(
getState
threadClient
sourceMaps
dispatch
reloadedSource
.
source
.
id
pendingBreakpoint
(
)
)
;
expect
(
threadClient
.
removeBreakpoint
.
mock
.
calls
)
.
toHaveLength
(
0
)
;
expect
(
update
&
&
update
.
breakpoint
&
&
update
.
breakpoint
.
location
.
line
)
.
toBe
(
location
.
line
+
generated
)
;
expect
(
update
)
.
toMatchSnapshot
(
)
;
}
)
;
}
)
;
describe
(
"
reloading
debuggee
"
(
)
=
>
{
beforeEach
(
(
)
=
>
{
const
location
=
{
line
:
0
column
:
0
}
;
(
getGeneratedLocation
:
any
)
.
mockImplementation
(
(
)
=
>
newGeneratedLocation
(
3
)
)
;
(
findScopeByName
:
any
)
.
mockImplementation
(
(
)
=
>
(
{
location
:
{
start
:
location
}
}
)
)
;
}
)
;
it
(
"
syncs
with
unchanged
source
with
an
existing
BP
"
async
(
)
=
>
{
const
{
dispatch
getState
}
=
createStore
(
threadClient
{
}
sourceMaps
)
;
const
reloadedSource
=
makeSource
(
"
magic
.
js
"
)
;
const
loc1
=
{
sourceId
:
"
magic
.
js
"
sourceUrl
:
"
http
:
/
/
localhost
:
8000
/
magic
.
js
"
line
:
3
column
:
undefined
}
;
const
generatedSource
=
makeSource
(
"
gen
.
js
"
)
;
await
dispatch
(
actions
.
newSource
(
reloadedSource
)
)
;
await
dispatch
(
actions
.
newSource
(
generatedSource
)
)
;
await
dispatch
(
actions
.
addBreakpoint
(
loc1
)
)
;
const
update
=
await
syncBreakpointPromise
(
getState
threadClient
sourceMaps
dispatch
reloadedSource
.
source
.
id
pendingBreakpoint
(
{
location
:
loc1
}
)
)
;
expect
(
threadClient
.
removeBreakpoint
.
mock
.
calls
)
.
toHaveLength
(
0
)
;
expect
(
update
)
.
toMatchSnapshot
(
)
;
}
)
;
it
(
"
updates
a
corresponding
breakpoint
for
a
changed
source
"
async
(
)
=
>
{
(
getGeneratedLocation
:
any
)
.
mockImplementation
(
(
)
=
>
newGeneratedLocation
(
5
)
)
;
const
{
dispatch
getState
}
=
createStore
(
threadClient
{
}
sourceMaps
)
;
const
reloadedSource
=
makeSource
(
"
magic
.
js
"
)
;
await
dispatch
(
actions
.
newSource
(
reloadedSource
)
)
;
const
generatedSource
=
makeSource
(
"
gen
.
js
"
)
;
await
dispatch
(
actions
.
newSource
(
generatedSource
)
)
;
const
update
=
await
syncBreakpointPromise
(
getState
threadClient
sourceMaps
dispatch
reloadedSource
.
source
.
id
pendingBreakpoint
(
)
)
;
expect
(
threadClient
.
removeBreakpoint
.
mock
.
calls
)
.
toHaveLength
(
1
)
;
expect
(
findScopeByName
)
.
toHaveBeenCalled
(
)
;
expect
(
update
)
.
toMatchSnapshot
(
)
;
}
)
;
it
(
"
syncs
with
changed
source
and
an
existing
disabled
BP
"
async
(
)
=
>
{
(
getGeneratedLocation
:
any
)
.
mockImplementationOnce
(
(
)
=
>
newGeneratedLocation
(
5
)
)
;
const
{
dispatch
getState
}
=
createStore
(
threadClient
{
}
sourceMaps
)
;
const
reloadedSource
=
makeSource
(
"
magic
.
js
"
)
;
await
dispatch
(
actions
.
newSource
(
reloadedSource
)
)
;
const
generatedSource
=
makeSource
(
"
gen
.
js
"
)
;
await
dispatch
(
actions
.
newSource
(
generatedSource
)
)
;
const
location
=
{
sourceId
:
reloadedSource
.
source
.
id
line
:
3
column
:
undefined
}
;
const
breakpoint
=
await
dispatch
(
actions
.
addBreakpoint
(
location
)
)
;
await
dispatch
(
actions
.
disableBreakpoint
(
breakpoint
)
)
;
(
getGeneratedLocation
:
any
)
.
mockImplementationOnce
(
(
)
=
>
newGeneratedLocation
(
1
)
)
;
await
dispatch
(
actions
.
syncBreakpoint
(
reloadedSource
.
source
.
id
pendingBreakpoint
(
{
disabled
:
true
}
)
)
)
;
expect
(
selectors
.
getPendingBreakpoints
(
getState
(
)
)
)
.
toMatchSnapshot
(
)
;
}
)
;
}
)
;
