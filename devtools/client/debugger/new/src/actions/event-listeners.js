import
{
reportException
}
from
"
.
.
/
utils
/
DevToolsUtils
"
;
import
{
isPaused
getSourceByURL
}
from
"
.
.
/
selectors
"
;
import
{
NAME
as
WAIT_UNTIL
}
from
"
.
/
utils
/
middleware
/
wait
-
service
"
;
const
FETCH_EVENT_LISTENERS_DELAY
=
200
;
let
fetchListenersTimerID
;
async
function
asPaused
(
state
:
any
client
:
any
func
:
any
)
{
if
(
!
isPaused
(
state
)
)
{
await
client
.
interrupt
(
)
;
let
result
;
try
{
result
=
await
func
(
client
)
;
}
catch
(
e
)
{
await
client
.
resume
(
)
;
throw
e
;
}
await
client
.
resume
(
)
;
return
result
;
}
return
func
(
client
)
;
}
export
function
fetchEventListeners
(
)
{
return
(
{
dispatch
getState
client
}
)
=
>
{
if
(
fetchListenersTimerID
)
{
clearTimeout
(
fetchListenersTimerID
)
;
}
fetchListenersTimerID
=
setTimeout
(
(
)
=
>
{
if
(
getState
(
)
.
eventListeners
.
fetchingListeners
)
{
dispatch
(
{
type
:
WAIT_UNTIL
predicate
:
action
=
>
action
.
type
=
=
=
"
FETCH_EVENT_LISTENERS
"
&
&
action
.
status
=
=
=
"
done
"
run
:
dispatch
=
>
dispatch
(
fetchEventListeners
(
)
)
}
)
;
return
;
}
dispatch
(
{
type
:
"
FETCH_EVENT_LISTENERS
"
status
:
"
begin
"
}
)
;
asPaused
(
getState
(
)
client
_getEventListeners
)
.
then
(
listeners
=
>
{
dispatch
(
{
type
:
"
FETCH_EVENT_LISTENERS
"
status
:
"
done
"
listeners
:
formatListeners
(
getState
(
)
listeners
)
}
)
;
}
)
;
}
FETCH_EVENT_LISTENERS_DELAY
)
;
}
;
}
function
formatListeners
(
state
listeners
)
{
return
listeners
.
map
(
l
=
>
{
return
{
selector
:
l
.
node
.
selector
type
:
l
.
type
sourceId
:
getSourceByURL
(
state
l
.
function
.
location
.
url
)
.
id
line
:
l
.
function
.
location
.
line
}
;
}
)
;
}
async
function
_getEventListeners
(
threadClient
)
{
const
response
=
await
threadClient
.
eventListeners
(
)
;
response
.
listeners
.
sort
(
(
a
b
)
=
>
(
a
.
type
>
b
.
type
?
1
:
-
1
)
)
;
const
fetchedDefinitions
=
new
Map
(
)
;
const
listeners
=
[
]
;
for
(
const
listener
of
response
.
listeners
)
{
let
definitionSite
;
if
(
fetchedDefinitions
.
has
(
listener
.
function
.
actor
)
)
{
definitionSite
=
fetchedDefinitions
.
get
(
listener
.
function
.
actor
)
;
}
else
if
(
listener
.
function
.
class
=
=
"
Function
"
)
{
definitionSite
=
await
_getDefinitionSite
(
threadClient
listener
.
function
)
;
if
(
!
definitionSite
)
{
continue
;
}
fetchedDefinitions
.
set
(
listener
.
function
.
actor
definitionSite
)
;
}
listener
.
function
.
url
=
definitionSite
;
listeners
.
push
(
listener
)
;
}
fetchedDefinitions
.
clear
(
)
;
return
listeners
;
}
async
function
_getDefinitionSite
(
threadClient
func
)
{
const
grip
=
threadClient
.
pauseGrip
(
func
)
;
let
response
;
try
{
response
=
await
grip
.
getDefinitionSite
(
)
;
}
catch
(
e
)
{
reportException
(
"
_getDefinitionSite
"
e
)
;
return
null
;
}
return
response
.
source
.
url
;
}
export
function
updateEventBreakpoints
(
eventNames
)
{
return
dispatch
=
>
{
setNamedTimeout
(
"
event
-
breakpoints
-
update
"
0
(
)
=
>
{
gThreadClient
.
pauseOnDOMEvents
(
eventNames
(
)
=
>
{
window
.
emit
(
EVENTS
.
EVENT_BREAKPOINTS_UPDATED
)
;
dispatch
(
{
type
:
"
UPDATE_EVENT_BREAKPOINTS
"
eventNames
:
eventNames
}
)
;
}
)
;
}
)
;
}
;
}
