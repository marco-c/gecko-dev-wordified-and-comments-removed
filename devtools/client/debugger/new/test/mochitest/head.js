Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
devtools
/
client
/
shared
/
test
/
shared
-
head
.
js
"
this
)
;
var
{
Toolbox
}
=
require
(
"
devtools
/
client
/
framework
/
toolbox
"
)
;
var
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
sourceUtils
=
{
isLoaded
:
source
=
>
source
.
get
(
"
loadedState
"
)
=
=
=
"
loaded
"
}
;
const
EXAMPLE_URL
=
"
http
:
/
/
example
.
com
/
browser
/
devtools
/
client
/
debugger
/
new
/
test
/
mochitest
/
examples
/
"
;
Services
.
prefs
.
setBoolPref
(
"
devtools
.
debugger
.
new
-
debugger
-
frontend
"
true
)
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
new
-
debugger
-
frontend
"
)
;
delete
window
.
resumeTest
;
}
)
;
function
log
(
msg
data
)
{
info
(
{
msg
}
{
!
data
?
"
"
:
JSON
.
stringify
(
data
)
}
)
;
}
function
logThreadEvents
(
dbg
event
)
{
const
thread
=
dbg
.
toolbox
.
threadClient
;
thread
.
addListener
(
event
function
onEvent
(
eventName
.
.
.
args
)
{
info
(
Thread
event
'
{
eventName
}
'
fired
.
)
;
}
)
;
}
async
function
waitFor
(
condition
)
{
await
BrowserTestUtils
.
waitForCondition
(
condition
"
waitFor
"
10
500
)
;
return
condition
(
)
;
}
function
waitForNextDispatch
(
store
type
)
{
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
action
.
type
=
=
=
type
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
function
_afterDispatchDone
(
store
type
)
{
return
new
Promise
(
resolve
=
>
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
action
=
>
{
if
(
action
.
type
=
=
=
type
)
{
return
action
.
status
?
action
.
status
=
=
=
"
done
"
|
|
action
.
status
=
=
=
"
error
"
:
true
;
}
}
run
:
(
dispatch
getState
action
)
=
>
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
function
waitForDispatch
(
dbg
type
eventRepeat
=
1
)
{
let
count
=
0
;
return
Task
.
spawn
(
function
*
(
)
{
info
(
Waiting
for
{
type
}
to
dispatch
{
eventRepeat
}
time
(
s
)
)
;
while
(
count
<
eventRepeat
)
{
yield
_afterDispatchDone
(
dbg
.
store
type
)
;
count
+
+
;
info
(
{
type
}
dispatched
{
count
}
time
(
s
)
)
;
}
}
)
;
}
function
waitForThreadEvents
(
dbg
eventName
)
{
info
(
Waiting
for
thread
event
'
{
eventName
}
'
to
fire
.
)
;
const
thread
=
dbg
.
toolbox
.
threadClient
;
return
new
Promise
(
function
(
resolve
reject
)
{
thread
.
addListener
(
eventName
function
onEvent
(
eventName
.
.
.
args
)
{
info
(
Thread
event
'
{
eventName
}
'
fired
.
)
;
thread
.
removeListener
(
eventName
onEvent
)
;
resolve
.
apply
(
resolve
args
)
;
}
)
;
}
)
;
}
function
waitForState
(
dbg
predicate
msg
)
{
return
new
Promise
(
resolve
=
>
{
info
(
Waiting
for
state
change
:
{
msg
|
|
"
"
}
)
;
if
(
predicate
(
dbg
.
store
.
getState
(
)
)
)
{
return
resolve
(
)
;
}
const
unsubscribe
=
dbg
.
store
.
subscribe
(
(
)
=
>
{
if
(
predicate
(
dbg
.
store
.
getState
(
)
)
)
{
info
(
Finished
waiting
for
state
change
:
{
msg
|
|
"
"
}
)
;
unsubscribe
(
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
function
waitForSources
(
dbg
.
.
.
sources
)
{
if
(
sources
.
length
=
=
=
0
)
{
return
Promise
.
resolve
(
)
;
}
info
(
Waiting
on
sources
:
{
sources
.
join
(
"
"
)
}
)
;
const
{
selectors
:
{
getSources
}
store
}
=
dbg
;
return
Promise
.
all
(
sources
.
map
(
url
=
>
{
function
sourceExists
(
state
)
{
return
getSources
(
state
)
.
some
(
s
=
>
{
return
(
s
.
get
(
"
url
"
)
|
|
"
"
)
.
includes
(
url
)
;
}
)
;
}
if
(
!
sourceExists
(
store
.
getState
(
)
)
)
{
return
waitForState
(
dbg
sourceExists
source
{
url
}
)
;
}
}
)
)
;
}
function
waitForSource
(
dbg
url
)
{
return
waitForState
(
dbg
state
=
>
{
const
sources
=
dbg
.
selectors
.
getSources
(
state
)
;
return
sources
.
find
(
s
=
>
(
s
.
get
(
"
url
"
)
|
|
"
"
)
.
includes
(
url
)
)
;
}
)
;
}
async
function
waitForElement
(
dbg
name
)
{
await
waitUntil
(
(
)
=
>
findElement
(
dbg
name
)
)
;
return
findElement
(
dbg
name
)
;
}
async
function
waitForElementWithSelector
(
dbg
selector
)
{
await
waitUntil
(
(
)
=
>
findElementWithSelector
(
dbg
selector
)
)
;
return
findElementWithSelector
(
dbg
selector
)
;
}
function
waitForSelectedSource
(
dbg
url
)
{
return
waitForState
(
dbg
state
=
>
{
const
source
=
dbg
.
selectors
.
getSelectedSource
(
state
)
;
const
isLoaded
=
source
&
&
sourceUtils
.
isLoaded
(
source
)
;
if
(
!
isLoaded
)
{
return
false
;
}
if
(
!
url
)
{
return
true
;
}
const
newSource
=
findSource
(
dbg
url
{
silent
:
true
}
)
;
if
(
newSource
.
id
!
=
source
.
get
(
"
id
"
)
)
{
return
false
;
}
return
dbg
.
selectors
.
hasSymbols
(
state
source
.
toJS
(
)
)
;
}
"
selected
source
"
)
;
}
function
assertNotPaused
(
dbg
)
{
ok
(
!
isPaused
(
dbg
)
"
client
is
not
paused
"
)
;
}
function
assertPausedLocation
(
dbg
)
{
const
{
selectors
:
{
getSelectedSource
getVisibleSelectedFrame
}
getState
}
=
dbg
;
ok
(
isSelectedFrameSelected
(
dbg
getState
(
)
)
"
top
frame
'
s
source
is
selected
"
)
;
const
frame
=
getVisibleSelectedFrame
(
getState
(
)
)
;
const
pauseLine
=
frame
&
&
frame
.
location
.
line
;
assertDebugLine
(
dbg
pauseLine
)
;
ok
(
isVisibleInEditor
(
dbg
getCM
(
dbg
)
.
display
.
gutters
)
"
gutter
is
visible
"
)
;
}
function
assertDebugLine
(
dbg
line
)
{
const
lineInfo
=
getCM
(
dbg
)
.
lineInfo
(
line
-
1
)
;
const
source
=
dbg
.
selectors
.
getSelectedSource
(
dbg
.
getState
(
)
)
;
if
(
source
&
&
source
.
get
(
"
loadedState
"
)
=
=
"
loading
"
)
{
const
url
=
source
.
get
(
"
url
"
)
;
ok
(
false
Looks
like
the
source
{
url
}
is
still
loading
.
Try
adding
waitForLoadedSource
in
the
test
.
)
;
return
;
}
ok
(
lineInfo
.
wrapClass
.
includes
(
"
new
-
debug
-
line
"
)
"
Line
is
highlighted
as
paused
"
)
;
const
debugLine
=
findElement
(
dbg
"
debugLine
"
)
|
|
findElement
(
dbg
"
debugErrorLine
"
)
;
is
(
findAllElements
(
dbg
"
debugLine
"
)
.
length
+
findAllElements
(
dbg
"
debugErrorLine
"
)
.
length
1
"
There
is
only
one
line
"
)
;
ok
(
isVisibleInEditor
(
dbg
debugLine
)
"
debug
line
is
visible
"
)
;
const
markedSpans
=
lineInfo
.
handle
.
markedSpans
;
if
(
markedSpans
&
&
markedSpans
.
length
>
0
)
{
const
marker
=
markedSpans
[
0
]
.
marker
;
ok
(
marker
.
className
.
includes
(
"
debug
-
expression
"
)
"
expression
is
highlighted
as
paused
"
)
;
}
}
function
assertHighlightLocation
(
dbg
source
line
)
{
const
{
selectors
:
{
getSelectedSource
}
getState
}
=
dbg
;
source
=
findSource
(
dbg
source
)
;
is
(
getSelectedSource
(
getState
(
)
)
.
get
(
"
url
"
)
source
.
url
"
source
url
is
correct
"
)
;
const
lineEl
=
findElement
(
dbg
"
highlightLine
"
)
;
ok
(
lineEl
"
Line
is
highlighted
"
)
;
is
(
findAllElements
(
dbg
"
highlightLine
"
)
.
length
1
"
Only
1
line
is
highlighted
"
)
;
ok
(
isVisibleInEditor
(
dbg
lineEl
)
"
Highlighted
line
is
visible
"
)
;
ok
(
getCM
(
dbg
)
.
lineInfo
(
line
-
1
)
.
wrapClass
.
includes
(
"
highlight
-
line
"
)
"
Line
is
highlighted
"
)
;
}
function
isPaused
(
dbg
)
{
const
{
selectors
:
{
isPaused
}
getState
}
=
dbg
;
return
!
!
isPaused
(
getState
(
)
)
;
}
async
function
waitForLoadedScopes
(
dbg
)
{
const
scopes
=
await
waitForElement
(
dbg
"
scopes
"
)
;
await
waitUntil
(
(
)
=
>
scopes
.
querySelector
(
.
tree
-
node
[
aria
-
level
=
"
1
"
]
)
)
;
}
async
function
waitForPaused
(
dbg
)
{
const
{
getSelectedScope
}
=
dbg
.
selectors
;
const
onScopesLoaded
=
waitForLoadedScopes
(
dbg
)
;
const
onStateChanged
=
waitForState
(
dbg
state
=
>
{
const
paused
=
isPaused
(
dbg
)
;
const
scope
=
!
!
getSelectedScope
(
state
)
;
return
paused
&
&
scope
;
}
"
paused
"
)
;
await
Promise
.
all
(
[
onStateChanged
onScopesLoaded
]
)
;
}
function
waitForever
(
)
{
return
new
Promise
(
r
=
>
{
}
)
;
}
function
waitForTime
(
ms
)
{
return
new
Promise
(
r
=
>
setTimeout
(
r
ms
)
)
;
}
function
isSelectedFrameSelected
(
dbg
state
)
{
const
frame
=
dbg
.
selectors
.
getVisibleSelectedFrame
(
state
)
;
const
sourceId
=
frame
.
location
.
sourceId
;
const
source
=
dbg
.
selectors
.
getSelectedSource
(
state
)
;
if
(
!
source
)
{
return
false
;
}
const
isLoaded
=
source
.
has
(
"
loadedState
"
)
&
&
sourceUtils
.
isLoaded
(
source
)
;
if
(
!
isLoaded
)
{
return
false
;
}
return
source
.
get
(
"
id
"
)
=
=
sourceId
;
}
function
createDebuggerContext
(
toolbox
)
{
const
panel
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
;
const
win
=
panel
.
panelWin
;
const
{
store
client
selectors
actions
}
=
panel
.
getVarsForTests
(
)
;
return
{
actions
:
actions
selectors
:
selectors
getState
:
store
.
getState
store
:
store
client
:
client
toolbox
:
toolbox
win
:
win
panel
:
panel
}
;
}
function
clearDebuggerPreferences
(
)
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
pause
-
on
-
exceptions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
ignore
-
caught
-
exceptions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
tabs
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
pending
-
selected
-
location
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
pending
-
breakpoints
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
expressions
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
call
-
stack
-
visible
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
scopes
-
visible
"
)
;
}
async
function
initDebugger
(
url
)
{
clearDebuggerPreferences
(
)
;
const
toolbox
=
await
openNewTabAndToolbox
(
EXAMPLE_URL
+
url
"
jsdebugger
"
)
;
return
createDebuggerContext
(
toolbox
)
;
}
async
function
initPane
(
url
pane
)
{
clearDebuggerPreferences
(
)
;
return
openNewTabAndToolbox
(
EXAMPLE_URL
+
url
pane
)
;
}
window
.
resumeTest
=
undefined
;
function
pauseTest
(
)
{
info
(
"
Test
paused
.
Invoke
resumeTest
to
continue
.
"
)
;
return
new
Promise
(
resolve
=
>
(
resumeTest
=
resolve
)
)
;
}
function
findSource
(
dbg
url
{
silent
}
=
{
silent
:
false
}
)
{
if
(
typeof
url
!
=
=
"
string
"
)
{
const
source
=
url
;
return
source
;
}
const
sources
=
dbg
.
selectors
.
getSources
(
dbg
.
getState
(
)
)
;
const
source
=
sources
.
find
(
s
=
>
(
s
.
get
(
"
url
"
)
|
|
"
"
)
.
includes
(
url
)
)
;
if
(
!
source
)
{
if
(
silent
)
{
return
false
;
}
throw
new
Error
(
Unable
to
find
source
:
{
url
}
)
;
}
return
source
.
toJS
(
)
;
}
function
waitForLoadedSource
(
dbg
url
)
{
return
waitForState
(
dbg
state
=
>
findSource
(
dbg
url
{
silent
:
true
}
)
.
loadedState
=
=
"
loaded
"
"
loaded
source
"
)
;
}
function
waitForLoadedSources
(
dbg
)
{
return
waitForState
(
dbg
state
=
>
{
const
sources
=
dbg
.
selectors
.
getSources
(
state
)
.
valueSeq
(
)
.
toJS
(
)
;
return
!
sources
.
some
(
source
=
>
source
.
loadedState
=
=
"
loading
"
)
;
}
"
loaded
source
"
)
;
}
function
selectSource
(
dbg
url
line
)
{
const
source
=
findSource
(
dbg
url
)
;
return
dbg
.
actions
.
selectLocation
(
{
sourceId
:
source
.
id
line
}
)
;
}
function
closeTab
(
dbg
url
)
{
const
source
=
findSource
(
dbg
url
)
;
return
dbg
.
actions
.
closeTab
(
source
.
url
)
;
}
async
function
stepOver
(
dbg
)
{
await
dbg
.
actions
.
stepOver
(
)
;
return
waitForPaused
(
dbg
)
;
}
async
function
stepIn
(
dbg
)
{
info
(
"
Stepping
in
"
)
;
await
dbg
.
actions
.
stepIn
(
)
;
return
waitForPaused
(
dbg
)
;
}
async
function
stepOut
(
dbg
)
{
info
(
"
Stepping
out
"
)
;
await
dbg
.
actions
.
stepOut
(
)
;
return
waitForPaused
(
dbg
)
;
}
function
resume
(
dbg
)
{
info
(
"
Resuming
"
)
;
return
dbg
.
actions
.
resume
(
)
;
}
function
deleteExpression
(
dbg
input
)
{
info
(
Delete
expression
"
{
input
}
"
)
;
return
dbg
.
actions
.
deleteExpression
(
{
input
}
)
;
}
function
reload
(
dbg
.
.
.
sources
)
{
return
dbg
.
client
.
reload
(
)
.
then
(
(
)
=
>
waitForSources
(
dbg
.
.
.
sources
)
"
reloaded
"
)
;
}
function
navigate
(
dbg
url
.
.
.
sources
)
{
dbg
.
client
.
navigate
(
url
)
;
return
waitForSources
(
dbg
.
.
.
sources
)
;
}
function
addBreakpoint
(
dbg
source
line
column
)
{
source
=
findSource
(
dbg
source
)
;
const
sourceId
=
source
.
id
;
dbg
.
actions
.
addBreakpoint
(
{
sourceId
line
column
}
)
;
return
waitForDispatch
(
dbg
"
ADD_BREAKPOINT
"
)
;
}
function
disableBreakpoint
(
dbg
source
line
column
)
{
source
=
findSource
(
dbg
source
)
;
const
sourceId
=
source
.
id
;
dbg
.
actions
.
disableBreakpoint
(
{
sourceId
line
column
}
)
;
return
waitForDispatch
(
dbg
"
DISABLE_BREAKPOINT
"
)
;
}
function
removeBreakpoint
(
dbg
sourceId
line
column
)
{
dbg
.
actions
.
removeBreakpoint
(
{
sourceId
line
column
}
)
;
return
waitForDispatch
(
dbg
"
REMOVE_BREAKPOINT
"
)
;
}
async
function
togglePauseOnExceptions
(
dbg
pauseOnExceptions
ignoreCaughtExceptions
)
{
const
command
=
dbg
.
actions
.
pauseOnExceptions
(
pauseOnExceptions
ignoreCaughtExceptions
)
;
if
(
!
isPaused
(
dbg
)
)
{
await
waitForThreadEvents
(
dbg
"
resumed
"
)
;
}
return
command
;
}
function
waitForActive
(
dbg
)
{
return
waitForState
(
dbg
state
=
>
!
dbg
.
selectors
.
isPaused
(
state
)
"
active
"
)
;
}
function
invokeInTab
(
fnc
.
.
.
args
)
{
info
(
Invoking
in
tab
:
{
fnc
}
(
{
args
.
map
(
uneval
)
.
join
(
"
"
)
}
)
)
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
{
fnc
args
}
function
*
(
{
fnc
args
}
)
{
content
.
wrappedJSObject
[
fnc
]
(
.
.
.
args
)
;
}
)
;
}
const
isLinux
=
Services
.
appinfo
.
OS
=
=
=
"
Linux
"
;
const
isMac
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
cmdOrCtrl
=
isLinux
?
{
ctrlKey
:
true
}
:
{
metaKey
:
true
}
;
const
shiftOrAlt
=
isMac
?
{
accelKey
:
true
shiftKey
:
true
}
:
{
accelKey
:
true
altKey
:
true
}
;
const
cmdShift
=
isMac
?
{
accelKey
:
true
shiftKey
:
true
metaKey
:
true
}
:
{
accelKey
:
true
shiftKey
:
true
ctrlKey
:
true
}
;
const
endKey
=
isMac
?
{
code
:
"
VK_RIGHT
"
modifiers
:
cmdOrCtrl
}
:
{
code
:
"
VK_END
"
}
;
const
startKey
=
isMac
?
{
code
:
"
VK_LEFT
"
modifiers
:
cmdOrCtrl
}
:
{
code
:
"
VK_HOME
"
}
;
const
keyMappings
=
{
debugger
:
{
code
:
"
s
"
modifiers
:
shiftOrAlt
}
inspector
:
{
code
:
"
c
"
modifiers
:
shiftOrAlt
}
quickOpen
:
{
code
:
"
p
"
modifiers
:
cmdOrCtrl
}
quickOpenFunc
:
{
code
:
"
o
"
modifiers
:
cmdShift
}
quickOpenLine
:
{
code
:
"
:
"
modifiers
:
cmdOrCtrl
}
fileSearch
:
{
code
:
"
f
"
modifiers
:
cmdOrCtrl
}
Enter
:
{
code
:
"
VK_RETURN
"
}
ShiftEnter
:
{
code
:
"
VK_RETURN
"
modifiers
:
shiftOrAlt
}
Up
:
{
code
:
"
VK_UP
"
}
Down
:
{
code
:
"
VK_DOWN
"
}
Right
:
{
code
:
"
VK_RIGHT
"
}
Left
:
{
code
:
"
VK_LEFT
"
}
End
:
endKey
Start
:
startKey
Tab
:
{
code
:
"
VK_TAB
"
}
Escape
:
{
code
:
"
VK_ESCAPE
"
}
Delete
:
{
code
:
"
VK_DELETE
"
}
pauseKey
:
{
code
:
"
VK_F8
"
}
resumeKey
:
{
code
:
"
VK_F8
"
}
stepOverKey
:
{
code
:
"
VK_F10
"
}
stepInKey
:
{
code
:
"
VK_F11
"
modifiers
:
{
ctrlKey
:
isLinux
}
}
stepOutKey
:
{
code
:
"
VK_F11
"
modifiers
:
{
ctrlKey
:
isLinux
shiftKey
:
true
}
}
}
;
function
pressKey
(
dbg
keyName
)
{
const
keyEvent
=
keyMappings
[
keyName
]
;
const
{
code
modifiers
}
=
keyEvent
;
return
EventUtils
.
synthesizeKey
(
code
modifiers
|
|
{
}
dbg
.
win
)
;
}
function
type
(
dbg
string
)
{
string
.
split
(
"
"
)
.
forEach
(
char
=
>
EventUtils
.
synthesizeKey
(
char
{
}
dbg
.
win
)
)
;
}
function
isVisibleInEditor
(
dbg
element
)
{
return
isVisible
(
findElement
(
dbg
"
codeMirror
"
)
element
)
;
}
function
isVisible
(
outerEl
innerEl
)
{
if
(
!
innerEl
|
|
!
outerEl
)
{
return
false
;
}
const
innerRect
=
innerEl
.
getBoundingClientRect
(
)
;
const
outerRect
=
outerEl
.
getBoundingClientRect
(
)
;
const
verticallyVisible
=
innerRect
.
top
>
=
outerRect
.
top
|
|
innerRect
.
bottom
<
=
outerRect
.
bottom
|
|
(
innerRect
.
top
<
outerRect
.
top
&
&
innerRect
.
bottom
>
outerRect
.
bottom
)
;
const
horizontallyVisible
=
innerRect
.
left
>
=
outerRect
.
left
|
|
innerRect
.
right
<
=
outerRect
.
right
|
|
(
innerRect
.
left
<
outerRect
.
left
&
&
innerRect
.
right
>
outerRect
.
right
)
;
const
visible
=
verticallyVisible
&
&
horizontallyVisible
;
return
visible
;
}
const
selectors
=
{
callStackHeader
:
"
.
call
-
stack
-
pane
.
_header
"
callStackBody
:
"
.
call
-
stack
-
pane
.
pane
"
expressionNode
:
i
=
>
.
expressions
-
list
.
expression
-
container
:
nth
-
child
(
{
i
}
)
.
object
-
label
expressionValue
:
i
=
>
.
expressions
-
list
.
expression
-
container
:
nth
-
child
(
{
i
}
)
.
object
-
delimiter
+
*
expressionClose
:
i
=
>
.
expressions
-
list
.
expression
-
container
:
nth
-
child
(
{
i
}
)
.
close
expressionNodes
:
"
.
expressions
-
list
.
tree
-
node
"
scopesHeader
:
"
.
scopes
-
pane
.
_header
"
breakpointItem
:
i
=
>
.
breakpoints
-
list
.
breakpoint
:
nth
-
child
(
{
i
}
)
scopes
:
"
.
scopes
-
list
"
scopeNode
:
i
=
>
.
scopes
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
label
scopeValue
:
i
=
>
.
scopes
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
delimiter
+
*
frame
:
i
=
>
.
frames
ul
li
:
nth
-
child
(
{
i
}
)
frames
:
"
.
frames
ul
li
"
gutter
:
i
=
>
.
CodeMirror
-
code
*
:
nth
-
child
(
{
i
}
)
.
CodeMirror
-
linenumber
menuitem
:
i
=
>
menupopup
menuitem
:
nth
-
child
(
{
i
}
)
pauseOnExceptions
:
"
.
pause
-
exceptions
"
breakpoint
:
"
.
CodeMirror
-
code
>
.
new
-
breakpoint
"
highlightLine
:
"
.
CodeMirror
-
code
>
.
highlight
-
line
"
debugLine
:
"
.
new
-
debug
-
line
"
debugErrorLine
:
"
.
new
-
debug
-
line
-
error
"
codeMirror
:
"
.
CodeMirror
"
resume
:
"
.
resume
.
active
"
sourceTabs
:
"
.
source
-
tabs
"
stepOver
:
"
.
stepOver
.
active
"
stepOut
:
"
.
stepOut
.
active
"
stepIn
:
"
.
stepIn
.
active
"
replayPrevious
:
"
.
replay
-
previous
.
active
"
replayNext
:
"
.
replay
-
next
.
active
"
toggleBreakpoints
:
"
.
breakpoints
-
toggle
"
prettyPrintButton
:
"
.
source
-
footer
.
prettyPrint
"
sourceMapLink
:
"
.
source
-
footer
.
mapped
-
source
"
sourcesFooter
:
"
.
sources
-
panel
.
source
-
footer
"
editorFooter
:
"
.
editor
-
pane
.
source
-
footer
"
sourceNode
:
i
=
>
.
sources
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
node
sourceNodes
:
"
.
sources
-
list
.
tree
-
node
"
sourceDirectoryLabel
:
i
=
>
.
sources
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
label
resultItems
:
"
.
result
-
list
.
result
-
item
"
fileMatch
:
"
.
managed
-
tree
.
result
"
popup
:
"
.
popover
"
tooltip
:
"
.
tooltip
"
outlineItem
:
i
=
>
.
outline
-
list__element
:
nth
-
child
(
{
i
}
)
.
function
-
signature
outlineItems
:
"
.
outline
-
list__element
"
conditionalPanelInput
:
"
.
conditional
-
breakpoint
-
panel
input
"
}
;
function
getSelector
(
elementName
.
.
.
args
)
{
let
selector
=
selectors
[
elementName
]
;
if
(
!
selector
)
{
throw
new
Error
(
The
selector
{
elementName
}
is
not
defined
)
;
}
if
(
typeof
selector
=
=
"
function
"
)
{
selector
=
selector
(
.
.
.
args
)
;
}
return
selector
;
}
function
findElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
return
findElementWithSelector
(
dbg
selector
)
;
}
function
findElementWithSelector
(
dbg
selector
)
{
return
dbg
.
win
.
document
.
querySelector
(
selector
)
;
}
function
findAllElements
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
return
dbg
.
win
.
document
.
querySelectorAll
(
selector
)
;
}
async
function
clickElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
const
el
=
await
waitForElementWithSelector
(
dbg
selector
)
;
el
.
scrollIntoView
(
)
;
return
clickElementWithSelector
(
dbg
selector
)
;
}
function
clickElementWithSelector
(
dbg
selector
)
{
EventUtils
.
synthesizeMouseAtCenter
(
findElementWithSelector
(
dbg
selector
)
{
}
dbg
.
win
)
;
}
function
dblClickElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
return
EventUtils
.
synthesizeMouseAtCenter
(
findElementWithSelector
(
dbg
selector
)
{
clickCount
:
2
}
dbg
.
win
)
;
}
function
rightClickElement
(
dbg
elementName
.
.
.
args
)
{
const
selector
=
getSelector
(
elementName
.
.
.
args
)
;
const
doc
=
dbg
.
win
.
document
;
return
EventUtils
.
synthesizeMouseAtCenter
(
doc
.
querySelector
(
selector
)
{
type
:
"
contextmenu
"
}
dbg
.
win
)
;
}
function
selectMenuItem
(
dbg
index
)
{
const
doc
=
dbg
.
toolbox
.
win
.
document
;
const
popup
=
doc
.
querySelector
(
'
menupopup
[
menu
-
api
=
"
true
"
]
'
)
;
const
item
=
popup
.
querySelector
(
menuitem
:
nth
-
child
(
{
index
}
)
)
;
return
EventUtils
.
synthesizeMouseAtCenter
(
item
{
}
dbg
.
toolbox
.
win
)
;
}
function
toggleCallStack
(
dbg
)
{
return
findElement
(
dbg
"
callStackHeader
"
)
.
click
(
)
;
}
function
toggleScopes
(
dbg
)
{
return
findElement
(
dbg
"
scopesHeader
"
)
.
click
(
)
;
}
function
toggleExpressionNode
(
dbg
index
)
{
return
toggleObjectInspectorNode
(
findElement
(
dbg
"
expressionNode
"
index
)
)
;
}
function
toggleScopeNode
(
dbg
index
)
{
return
toggleObjectInspectorNode
(
findElement
(
dbg
"
scopeNode
"
index
)
)
;
}
function
getScopeLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeNode
"
index
)
.
innerText
;
}
function
getScopeValue
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeValue
"
index
)
.
innerText
;
}
function
toggleObjectInspectorNode
(
node
)
{
const
objectInspector
=
node
.
closest
(
"
.
object
-
inspector
"
)
;
const
properties
=
objectInspector
.
querySelectorAll
(
"
.
node
"
)
.
length
;
node
.
click
(
)
;
return
waitUntil
(
(
)
=
>
objectInspector
.
querySelectorAll
(
"
.
node
"
)
.
length
!
=
=
properties
)
;
}
function
getCM
(
dbg
)
{
const
el
=
dbg
.
win
.
document
.
querySelector
(
"
.
CodeMirror
"
)
;
return
el
.
CodeMirror
;
}
async
function
takeScreenshot
(
dbg
)
{
let
canvas
=
dbg
.
win
.
document
.
createElementNS
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
"
html
:
canvas
"
)
;
let
context
=
canvas
.
getContext
(
"
2d
"
)
;
canvas
.
width
=
dbg
.
win
.
innerWidth
;
canvas
.
height
=
dbg
.
win
.
innerHeight
;
context
.
drawWindow
(
dbg
.
win
0
0
canvas
.
width
canvas
.
height
"
white
"
)
;
await
waitForTime
(
1000
)
;
dump
(
[
SCREENSHOT
]
{
canvas
.
toDataURL
(
)
}
\
n
)
;
}
