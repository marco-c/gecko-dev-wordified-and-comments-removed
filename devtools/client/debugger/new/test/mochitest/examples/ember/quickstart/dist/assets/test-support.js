(
function
(
)
{
var
enifed
requireModule
Ember
;
mainContext
=
this
;
(
function
(
)
{
function
missingModule
(
name
referrerName
)
{
if
(
referrerName
)
{
throw
new
Error
(
'
Could
not
find
module
'
+
name
+
'
required
by
:
'
+
referrerName
)
;
}
else
{
throw
new
Error
(
'
Could
not
find
module
'
+
name
)
;
}
}
function
internalRequire
(
_name
referrerName
)
{
var
name
=
_name
;
var
mod
=
registry
[
name
]
;
if
(
!
mod
)
{
name
=
name
+
'
/
index
'
;
mod
=
registry
[
name
]
;
}
var
exports
=
seen
[
name
]
;
if
(
exports
!
=
=
undefined
)
{
return
exports
;
}
exports
=
seen
[
name
]
=
{
}
;
if
(
!
mod
)
{
missingModule
(
_name
referrerName
)
;
}
var
deps
=
mod
.
deps
;
var
callback
=
mod
.
callback
;
var
reified
=
new
Array
(
deps
.
length
)
;
for
(
var
i
=
0
;
i
<
deps
.
length
;
i
+
+
)
{
if
(
deps
[
i
]
=
=
=
'
exports
'
)
{
reified
[
i
]
=
exports
;
}
else
if
(
deps
[
i
]
=
=
=
'
require
'
)
{
reified
[
i
]
=
requireModule
;
}
else
{
reified
[
i
]
=
internalRequire
(
deps
[
i
]
name
)
;
}
}
callback
.
apply
(
this
reified
)
;
return
exports
;
}
var
isNode
=
typeof
window
=
=
=
'
undefined
'
&
&
typeof
process
!
=
=
'
undefined
'
&
&
{
}
.
toString
.
call
(
process
)
=
=
=
'
[
object
process
]
'
;
if
(
!
isNode
)
{
Ember
=
this
.
Ember
=
this
.
Ember
|
|
{
}
;
}
if
(
typeof
Ember
=
=
=
'
undefined
'
)
{
Ember
=
{
}
;
}
if
(
typeof
Ember
.
__loader
=
=
=
'
undefined
'
)
{
var
registry
=
{
}
;
var
seen
=
{
}
;
enifed
=
function
(
name
deps
callback
)
{
var
value
=
{
}
;
if
(
!
callback
)
{
value
.
deps
=
[
]
;
value
.
callback
=
deps
;
}
else
{
value
.
deps
=
deps
;
value
.
callback
=
callback
;
}
registry
[
name
]
=
value
;
}
;
requireModule
=
function
(
name
)
{
return
internalRequire
(
name
null
)
;
}
;
requireModule
[
'
default
'
]
=
requireModule
;
requireModule
.
has
=
function
registryHas
(
moduleName
)
{
return
!
!
registry
[
moduleName
]
|
|
!
!
registry
[
moduleName
+
'
/
index
'
]
;
}
;
requireModule
.
_eak_seen
=
registry
;
Ember
.
__loader
=
{
define
:
enifed
require
:
requireModule
registry
:
registry
}
;
}
else
{
enifed
=
Ember
.
__loader
.
define
;
requireModule
=
Ember
.
__loader
.
require
;
}
}
)
(
)
;
enifed
(
'
ember
-
babel
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
classCallCheck
=
classCallCheck
;
exports
.
inherits
=
inherits
;
exports
.
taggedTemplateLiteralLoose
=
taggedTemplateLiteralLoose
;
exports
.
createClass
=
createClass
;
exports
.
defaults
=
defaults
;
function
classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
'
Cannot
call
a
class
as
a
function
'
)
;
}
}
function
inherits
(
subClass
superClass
)
{
if
(
typeof
superClass
!
=
=
'
function
'
&
&
superClass
!
=
=
null
)
{
throw
new
TypeError
(
'
Super
expression
must
either
be
null
or
a
function
not
'
+
typeof
superClass
)
;
}
subClass
.
prototype
=
Object
.
create
(
superClass
&
&
superClass
.
prototype
{
constructor
:
{
value
:
subClass
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
if
(
superClass
)
Object
.
setPrototypeOf
?
Object
.
setPrototypeOf
(
subClass
superClass
)
:
defaults
(
subClass
superClass
)
;
}
function
taggedTemplateLiteralLoose
(
strings
raw
)
{
strings
.
raw
=
raw
;
return
strings
;
}
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
'
value
'
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
function
createClass
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
function
defaults
(
obj
defaults
)
{
var
keys
=
Object
.
getOwnPropertyNames
(
defaults
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
var
value
=
Object
.
getOwnPropertyDescriptor
(
defaults
key
)
;
if
(
value
&
&
value
.
configurable
&
&
obj
[
key
]
=
=
=
undefined
)
{
Object
.
defineProperty
(
obj
key
value
)
;
}
}
return
obj
;
}
var
possibleConstructorReturn
=
exports
.
possibleConstructorReturn
=
function
(
self
call
)
{
if
(
!
self
)
{
throw
new
ReferenceError
(
'
this
hasn
\
'
t
been
initialized
-
super
(
)
hasn
\
'
t
been
called
'
)
;
}
return
call
&
&
(
typeof
call
=
=
=
'
object
'
|
|
typeof
call
=
=
=
'
function
'
)
?
call
:
self
;
}
;
var
slice
=
exports
.
slice
=
Array
.
prototype
.
slice
;
}
)
;
enifed
(
'
ember
-
debug
/
deprecate
'
[
'
exports
'
'
ember
-
debug
/
error
'
'
ember
-
console
'
'
ember
-
environment
'
'
ember
-
debug
/
index
'
'
ember
-
debug
/
handlers
'
]
function
(
exports
_error
_emberConsole
_emberEnvironment
_index
_handlers
)
{
'
use
strict
'
;
exports
.
missingOptionsUntilDeprecation
=
exports
.
missingOptionsIdDeprecation
=
exports
.
missingOptionsDeprecation
=
exports
.
registerHandler
=
undefined
;
var
registerHandler
=
function
(
)
{
}
;
var
missingOptionsDeprecation
=
void
0
missingOptionsIdDeprecation
=
void
0
missingOptionsUntilDeprecation
=
void
0
deprecate
=
void
0
;
if
(
true
)
{
exports
.
registerHandler
=
registerHandler
=
function
registerHandler
(
handler
)
{
(
0
_handlers
.
registerHandler
)
(
'
deprecate
'
handler
)
;
}
;
var
formatMessage
=
function
formatMessage
(
_message
options
)
{
var
message
=
_message
;
if
(
options
&
&
options
.
id
)
{
message
=
message
+
(
'
[
deprecation
id
:
'
+
options
.
id
+
'
]
'
)
;
}
if
(
options
&
&
options
.
url
)
{
message
+
=
'
See
'
+
options
.
url
+
'
for
more
details
.
'
;
}
return
message
;
}
;
registerHandler
(
function
logDeprecationToConsole
(
message
options
)
{
var
updatedMessage
=
formatMessage
(
message
options
)
;
_emberConsole
.
default
.
warn
(
'
DEPRECATION
:
'
+
updatedMessage
)
;
}
)
;
var
captureErrorForStack
=
void
0
;
if
(
new
Error
(
)
.
stack
)
{
captureErrorForStack
=
function
(
)
{
return
new
Error
(
)
;
}
;
}
else
{
captureErrorForStack
=
function
(
)
{
try
{
__fail__
.
fail
(
)
;
}
catch
(
e
)
{
return
e
;
}
}
;
}
registerHandler
(
function
logDeprecationStackTrace
(
message
options
next
)
{
if
(
_emberEnvironment
.
ENV
.
LOG_STACKTRACE_ON_DEPRECATION
)
{
var
stackStr
=
'
'
;
var
error
=
captureErrorForStack
(
)
;
var
stack
=
void
0
;
if
(
error
.
stack
)
{
if
(
error
[
'
arguments
'
]
)
{
stack
=
error
.
stack
.
replace
(
/
^
\
s
+
at
\
s
+
/
gm
'
'
)
.
replace
(
/
^
(
[
^
\
(
]
+
?
)
(
[
\
n
]
)
/
gm
'
{
anonymous
}
(
1
)
2
'
)
.
replace
(
/
^
Object
.
<
anonymous
>
\
s
*
\
(
(
[
^
\
)
]
+
)
\
)
/
gm
'
{
anonymous
}
(
1
)
'
)
.
split
(
'
\
n
'
)
;
stack
.
shift
(
)
;
}
else
{
stack
=
error
.
stack
.
replace
(
/
(
?
:
\
n
:
0
)
?
\
s
+
/
m
'
'
)
.
replace
(
/
^
\
(
/
gm
'
{
anonymous
}
(
'
)
.
split
(
'
\
n
'
)
;
}
stackStr
=
'
\
n
'
+
stack
.
slice
(
2
)
.
join
(
'
\
n
'
)
;
}
var
updatedMessage
=
formatMessage
(
message
options
)
;
_emberConsole
.
default
.
warn
(
'
DEPRECATION
:
'
+
updatedMessage
+
stackStr
)
;
}
else
{
next
.
apply
(
undefined
arguments
)
;
}
}
)
;
registerHandler
(
function
raiseOnDeprecation
(
message
options
next
)
{
if
(
_emberEnvironment
.
ENV
.
RAISE_ON_DEPRECATION
)
{
var
updatedMessage
=
formatMessage
(
message
)
;
throw
new
_error
.
default
(
updatedMessage
)
;
}
else
{
next
.
apply
(
undefined
arguments
)
;
}
}
)
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
=
'
When
calling
deprecate
you
'
+
'
must
provide
an
options
hash
as
the
third
parameter
.
'
+
'
options
should
include
id
and
until
properties
.
'
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
=
'
When
calling
deprecate
you
must
provide
id
in
options
.
'
;
exports
.
missingOptionsUntilDeprecation
=
missingOptionsUntilDeprecation
=
'
When
calling
deprecate
you
must
provide
until
in
options
.
'
;
deprecate
=
function
deprecate
(
message
test
options
)
{
if
(
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
!
=
=
true
)
{
(
0
_index
.
assert
)
(
missingOptionsDeprecation
options
&
&
(
options
.
id
|
|
options
.
until
)
)
;
(
0
_index
.
assert
)
(
missingOptionsIdDeprecation
options
.
id
)
;
(
0
_index
.
assert
)
(
missingOptionsUntilDeprecation
options
.
until
)
;
}
if
(
(
!
options
|
|
!
options
.
id
&
&
!
options
.
until
)
&
&
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
=
=
=
true
)
{
deprecate
(
missingOptionsDeprecation
false
{
id
:
'
ember
-
debug
.
deprecate
-
options
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
id
&
&
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
=
=
=
true
)
{
deprecate
(
missingOptionsIdDeprecation
false
{
id
:
'
ember
-
debug
.
deprecate
-
id
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
until
&
&
_emberEnvironment
.
ENV
.
_ENABLE_DEPRECATION_OPTIONS_SUPPORT
=
=
=
true
)
{
deprecate
(
missingOptionsUntilDeprecation
options
&
&
options
.
until
{
id
:
'
ember
-
debug
.
deprecate
-
until
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
_handlers
.
invoke
.
apply
(
undefined
[
'
deprecate
'
]
.
concat
(
Array
.
prototype
.
slice
.
call
(
arguments
)
)
)
;
}
;
}
exports
.
default
=
deprecate
;
exports
.
registerHandler
=
registerHandler
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
;
exports
.
missingOptionsUntilDeprecation
=
missingOptionsUntilDeprecation
;
}
)
;
enifed
(
"
ember
-
debug
/
error
"
[
"
exports
"
"
ember
-
babel
"
]
function
(
exports
_emberBabel
)
{
"
use
strict
"
;
function
ExtendBuiltin
(
klass
)
{
function
ExtendableBuiltin
(
)
{
klass
.
apply
(
this
arguments
)
;
}
ExtendableBuiltin
.
prototype
=
Object
.
create
(
klass
.
prototype
)
;
ExtendableBuiltin
.
prototype
.
constructor
=
ExtendableBuiltin
;
return
ExtendableBuiltin
;
}
var
EmberError
=
function
(
_ExtendBuiltin
)
{
(
0
_emberBabel
.
inherits
)
(
EmberError
_ExtendBuiltin
)
;
function
EmberError
(
message
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
EmberError
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_ExtendBuiltin
.
call
(
this
)
)
;
if
(
!
(
_this
instanceof
EmberError
)
)
{
var
_ret
;
return
_ret
=
new
EmberError
(
message
)
(
0
_emberBabel
.
possibleConstructorReturn
)
(
_this
_ret
)
;
}
var
error
=
Error
.
call
(
_this
message
)
;
_this
.
stack
=
error
.
stack
;
_this
.
description
=
error
.
description
;
_this
.
fileName
=
error
.
fileName
;
_this
.
lineNumber
=
error
.
lineNumber
;
_this
.
message
=
error
.
message
;
_this
.
name
=
error
.
name
;
_this
.
number
=
error
.
number
;
_this
.
code
=
error
.
code
;
return
_this
;
}
return
EmberError
;
}
(
ExtendBuiltin
(
Error
)
)
;
exports
.
default
=
EmberError
;
}
)
;
enifed
(
'
ember
-
debug
/
features
'
[
'
exports
'
'
ember
-
environment
'
'
ember
/
features
'
]
function
(
exports
_emberEnvironment
_features
)
{
'
use
strict
'
;
exports
.
default
=
isEnabled
;
var
FEATURES
=
_features
.
FEATURES
;
function
isEnabled
(
feature
)
{
var
featureValue
=
FEATURES
[
feature
]
;
if
(
featureValue
=
=
=
true
|
|
featureValue
=
=
=
false
|
|
featureValue
=
=
=
undefined
)
{
return
featureValue
;
}
else
if
(
_emberEnvironment
.
ENV
.
ENABLE_OPTIONAL_FEATURES
)
{
return
true
;
}
else
{
return
false
;
}
}
}
)
;
enifed
(
'
ember
-
debug
/
handlers
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
var
HANDLERS
=
exports
.
HANDLERS
=
{
}
;
var
registerHandler
=
function
(
)
{
}
;
var
invoke
=
function
(
)
{
}
;
if
(
true
)
{
exports
.
registerHandler
=
registerHandler
=
function
registerHandler
(
type
callback
)
{
var
nextHandler
=
HANDLERS
[
type
]
|
|
function
(
)
{
}
;
HANDLERS
[
type
]
=
function
(
message
options
)
{
callback
(
message
options
nextHandler
)
;
}
;
}
;
exports
.
invoke
=
invoke
=
function
invoke
(
type
message
test
options
)
{
if
(
test
)
{
return
;
}
var
handlerForType
=
HANDLERS
[
type
]
;
if
(
handlerForType
)
{
handlerForType
(
message
options
)
;
}
}
;
}
exports
.
registerHandler
=
registerHandler
;
exports
.
invoke
=
invoke
;
}
)
;
enifed
(
'
ember
-
debug
/
index
'
[
'
exports
'
'
ember
-
debug
/
warn
'
'
ember
-
debug
/
deprecate
'
'
ember
-
debug
/
features
'
'
ember
-
debug
/
error
'
'
ember
-
debug
/
testing
'
'
ember
-
environment
'
'
ember
-
console
'
'
ember
/
features
'
]
function
(
exports
_warn2
_deprecate2
_features
_error
_testing
_emberEnvironment
_emberConsole
_features2
)
{
'
use
strict
'
;
exports
.
_warnIfUsingStrippedFeatureFlags
=
exports
.
getDebugFunction
=
exports
.
setDebugFunction
=
exports
.
deprecateFunc
=
exports
.
runInDebug
=
exports
.
debugFreeze
=
exports
.
debugSeal
=
exports
.
deprecate
=
exports
.
debug
=
exports
.
warn
=
exports
.
info
=
exports
.
assert
=
exports
.
setTesting
=
exports
.
isTesting
=
exports
.
Error
=
exports
.
isFeatureEnabled
=
exports
.
registerDeprecationHandler
=
exports
.
registerWarnHandler
=
undefined
;
Object
.
defineProperty
(
exports
'
registerWarnHandler
'
{
enumerable
:
true
get
:
function
(
)
{
return
_warn2
.
registerHandler
;
}
}
)
;
Object
.
defineProperty
(
exports
'
registerDeprecationHandler
'
{
enumerable
:
true
get
:
function
(
)
{
return
_deprecate2
.
registerHandler
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isFeatureEnabled
'
{
enumerable
:
true
get
:
function
(
)
{
return
_features
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Error
'
{
enumerable
:
true
get
:
function
(
)
{
return
_error
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isTesting
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testing
.
isTesting
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setTesting
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testing
.
setTesting
;
}
}
)
;
var
DEFAULT_FEATURES
=
_features2
.
DEFAULT_FEATURES
FEATURES
=
_features2
.
FEATURES
;
var
noop
=
function
(
)
{
}
;
var
assert
=
noop
;
var
info
=
noop
;
var
warn
=
noop
;
var
debug
=
noop
;
var
deprecate
=
noop
;
var
debugSeal
=
noop
;
var
debugFreeze
=
noop
;
var
runInDebug
=
noop
;
var
setDebugFunction
=
noop
;
var
getDebugFunction
=
noop
;
var
deprecateFunc
=
function
(
)
{
return
arguments
[
arguments
.
length
-
1
]
;
}
;
if
(
true
)
{
exports
.
setDebugFunction
=
setDebugFunction
=
function
(
type
callback
)
{
switch
(
type
)
{
case
'
assert
'
:
return
exports
.
assert
=
assert
=
callback
;
case
'
info
'
:
return
exports
.
info
=
info
=
callback
;
case
'
warn
'
:
return
exports
.
warn
=
warn
=
callback
;
case
'
debug
'
:
return
exports
.
debug
=
debug
=
callback
;
case
'
deprecate
'
:
return
exports
.
deprecate
=
deprecate
=
callback
;
case
'
debugSeal
'
:
return
exports
.
debugSeal
=
debugSeal
=
callback
;
case
'
debugFreeze
'
:
return
exports
.
debugFreeze
=
debugFreeze
=
callback
;
case
'
runInDebug
'
:
return
exports
.
runInDebug
=
runInDebug
=
callback
;
case
'
deprecateFunc
'
:
return
exports
.
deprecateFunc
=
deprecateFunc
=
callback
;
}
}
;
exports
.
getDebugFunction
=
getDebugFunction
=
function
(
type
)
{
switch
(
type
)
{
case
'
assert
'
:
return
assert
;
case
'
info
'
:
return
info
;
case
'
warn
'
:
return
warn
;
case
'
debug
'
:
return
debug
;
case
'
deprecate
'
:
return
deprecate
;
case
'
debugSeal
'
:
return
debugSeal
;
case
'
debugFreeze
'
:
return
debugFreeze
;
case
'
runInDebug
'
:
return
runInDebug
;
case
'
deprecateFunc
'
:
return
deprecateFunc
;
}
}
;
}
if
(
true
)
{
setDebugFunction
(
'
assert
'
function
assert
(
desc
test
)
{
if
(
!
test
)
{
throw
new
_error
.
default
(
'
Assertion
Failed
:
'
+
desc
)
;
}
}
)
;
setDebugFunction
(
'
debug
'
function
debug
(
message
)
{
_emberConsole
.
default
.
debug
(
'
DEBUG
:
'
+
message
)
;
}
)
;
setDebugFunction
(
'
info
'
function
info
(
)
{
_emberConsole
.
default
.
info
.
apply
(
undefined
arguments
)
;
}
)
;
setDebugFunction
(
'
deprecateFunc
'
function
deprecateFunc
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
args
.
length
=
=
=
3
)
{
var
message
=
args
[
0
]
options
=
args
[
1
]
func
=
args
[
2
]
;
return
function
(
)
{
deprecate
(
message
false
options
)
;
return
func
.
apply
(
this
arguments
)
;
}
;
}
else
{
var
_message
=
args
[
0
]
_func
=
args
[
1
]
;
return
function
(
)
{
deprecate
(
_message
)
;
return
_func
.
apply
(
this
arguments
)
;
}
;
}
}
)
;
setDebugFunction
(
'
runInDebug
'
function
runInDebug
(
func
)
{
func
(
)
;
}
)
;
setDebugFunction
(
'
debugSeal
'
function
debugSeal
(
obj
)
{
Object
.
seal
(
obj
)
;
}
)
;
setDebugFunction
(
'
debugFreeze
'
function
debugFreeze
(
obj
)
{
Object
.
freeze
(
obj
)
;
}
)
;
setDebugFunction
(
'
deprecate
'
_deprecate2
.
default
)
;
setDebugFunction
(
'
warn
'
_warn2
.
default
)
;
}
var
_warnIfUsingStrippedFeatureFlags
=
void
0
;
if
(
true
&
&
!
(
0
_testing
.
isTesting
)
(
)
)
{
exports
.
_warnIfUsingStrippedFeatureFlags
=
_warnIfUsingStrippedFeatureFlags
=
function
_warnIfUsingStrippedFeatureFlags
(
FEATURES
knownFeatures
featuresWereStripped
)
{
if
(
featuresWereStripped
)
{
warn
(
'
Ember
.
ENV
.
ENABLE_OPTIONAL_FEATURES
is
only
available
in
canary
builds
.
'
!
_emberEnvironment
.
ENV
.
ENABLE_OPTIONAL_FEATURES
{
id
:
'
ember
-
debug
.
feature
-
flag
-
with
-
features
-
stripped
'
}
)
;
var
keys
=
Object
.
keys
(
FEATURES
|
|
{
}
)
;
for
(
var
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
var
key
=
keys
[
i
]
;
if
(
key
=
=
=
'
isEnabled
'
|
|
!
(
key
in
knownFeatures
)
)
{
continue
;
}
warn
(
'
FEATURE
[
"
'
+
key
+
'
"
]
is
set
as
enabled
but
FEATURE
flags
are
only
available
in
canary
builds
.
'
!
FEATURES
[
key
]
{
id
:
'
ember
-
debug
.
feature
-
flag
-
with
-
features
-
stripped
'
}
)
;
}
}
}
;
FEATURES
[
'
features
-
stripped
-
test
'
]
=
true
;
var
featuresWereStripped
=
true
;
if
(
(
0
_features
.
default
)
(
'
features
-
stripped
-
test
'
)
)
{
featuresWereStripped
=
false
;
}
delete
FEATURES
[
'
features
-
stripped
-
test
'
]
;
_warnIfUsingStrippedFeatureFlags
(
_emberEnvironment
.
ENV
.
FEATURES
DEFAULT_FEATURES
featuresWereStripped
)
;
var
isFirefox
=
_emberEnvironment
.
environment
.
isFirefox
;
var
isChrome
=
_emberEnvironment
.
environment
.
isChrome
;
if
(
typeof
window
!
=
=
'
undefined
'
&
&
(
isFirefox
|
|
isChrome
)
&
&
window
.
addEventListener
)
{
window
.
addEventListener
(
'
load
'
function
(
)
{
if
(
document
.
documentElement
&
&
document
.
documentElement
.
dataset
&
&
!
document
.
documentElement
.
dataset
.
emberExtension
)
{
var
downloadURL
=
void
0
;
if
(
isChrome
)
{
downloadURL
=
'
https
:
/
/
chrome
.
google
.
com
/
webstore
/
detail
/
ember
-
inspector
/
bmdblncegkenkacieihfhpjfppoconhi
'
;
}
else
if
(
isFirefox
)
{
downloadURL
=
'
https
:
/
/
addons
.
mozilla
.
org
/
en
-
US
/
firefox
/
addon
/
ember
-
inspector
/
'
;
}
debug
(
'
For
more
advanced
debugging
install
the
Ember
Inspector
from
'
+
downloadURL
)
;
}
}
false
)
;
}
}
exports
.
assert
=
assert
;
exports
.
info
=
info
;
exports
.
warn
=
warn
;
exports
.
debug
=
debug
;
exports
.
deprecate
=
deprecate
;
exports
.
debugSeal
=
debugSeal
;
exports
.
debugFreeze
=
debugFreeze
;
exports
.
runInDebug
=
runInDebug
;
exports
.
deprecateFunc
=
deprecateFunc
;
exports
.
setDebugFunction
=
setDebugFunction
;
exports
.
getDebugFunction
=
getDebugFunction
;
exports
.
_warnIfUsingStrippedFeatureFlags
=
_warnIfUsingStrippedFeatureFlags
;
}
)
;
enifed
(
"
ember
-
debug
/
testing
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
isTesting
=
isTesting
;
exports
.
setTesting
=
setTesting
;
var
testing
=
false
;
function
isTesting
(
)
{
return
testing
;
}
function
setTesting
(
value
)
{
testing
=
!
!
value
;
}
}
)
;
enifed
(
'
ember
-
debug
/
warn
'
[
'
exports
'
'
ember
-
environment
'
'
ember
-
console
'
'
ember
-
debug
/
deprecate
'
'
ember
-
debug
/
index
'
'
ember
-
debug
/
handlers
'
]
function
(
exports
_emberEnvironment
_emberConsole
_deprecate
_index
_handlers
)
{
'
use
strict
'
;
exports
.
missingOptionsDeprecation
=
exports
.
missingOptionsIdDeprecation
=
exports
.
registerHandler
=
undefined
;
var
registerHandler
=
function
(
)
{
}
;
var
warn
=
function
(
)
{
}
;
var
missingOptionsDeprecation
=
void
0
missingOptionsIdDeprecation
=
void
0
;
if
(
true
)
{
exports
.
registerHandler
=
registerHandler
=
function
registerHandler
(
handler
)
{
(
0
_handlers
.
registerHandler
)
(
'
warn
'
handler
)
;
}
;
registerHandler
(
function
logWarning
(
message
)
{
_emberConsole
.
default
.
warn
(
'
WARNING
:
'
+
message
)
;
if
(
'
trace
'
in
_emberConsole
.
default
)
{
_emberConsole
.
default
.
trace
(
)
;
}
}
)
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
=
'
When
calling
warn
you
'
+
'
must
provide
an
options
hash
as
the
third
parameter
.
'
+
'
options
should
include
an
id
property
.
'
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
=
'
When
calling
warn
you
must
provide
id
in
options
.
'
;
warn
=
function
warn
(
message
test
options
)
{
if
(
arguments
.
length
=
=
=
2
&
&
typeof
test
=
=
=
'
object
'
)
{
options
=
test
;
test
=
false
;
}
if
(
_emberEnvironment
.
ENV
.
_ENABLE_WARN_OPTIONS_SUPPORT
!
=
=
true
)
{
(
0
_index
.
assert
)
(
missingOptionsDeprecation
options
)
;
(
0
_index
.
assert
)
(
missingOptionsIdDeprecation
options
&
&
options
.
id
)
;
}
if
(
!
options
&
&
_emberEnvironment
.
ENV
.
_ENABLE_WARN_OPTIONS_SUPPORT
=
=
=
true
)
{
(
0
_deprecate
.
default
)
(
missingOptionsDeprecation
false
{
id
:
'
ember
-
debug
.
warn
-
options
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
if
(
options
&
&
!
options
.
id
&
&
_emberEnvironment
.
ENV
.
_ENABLE_WARN_OPTIONS_SUPPORT
=
=
=
true
)
{
(
0
_deprecate
.
default
)
(
missingOptionsIdDeprecation
false
{
id
:
'
ember
-
debug
.
warn
-
id
-
missing
'
until
:
'
3
.
0
.
0
'
url
:
'
https
:
/
/
emberjs
.
com
/
deprecations
/
v2
.
x
/
#
toc_ember
-
debug
-
function
-
options
'
}
)
;
}
(
0
_handlers
.
invoke
)
(
'
warn
'
message
test
options
)
;
}
;
}
exports
.
default
=
warn
;
exports
.
registerHandler
=
registerHandler
;
exports
.
missingOptionsIdDeprecation
=
missingOptionsIdDeprecation
;
exports
.
missingOptionsDeprecation
=
missingOptionsDeprecation
;
}
)
;
enifed
(
'
ember
-
testing
/
adapters
/
adapter
'
[
'
exports
'
'
ember
-
runtime
'
]
function
(
exports
_emberRuntime
)
{
'
use
strict
'
;
function
K
(
)
{
return
this
;
}
exports
.
default
=
_emberRuntime
.
Object
.
extend
(
{
asyncStart
:
K
asyncEnd
:
K
exception
:
function
(
error
)
{
throw
error
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
adapters
/
qunit
'
[
'
exports
'
'
ember
-
utils
'
'
ember
-
testing
/
adapters
/
adapter
'
]
function
(
exports
_emberUtils
_adapter
)
{
'
use
strict
'
;
exports
.
default
=
_adapter
.
default
.
extend
(
{
asyncStart
:
function
(
)
{
QUnit
.
stop
(
)
;
}
asyncEnd
:
function
(
)
{
QUnit
.
start
(
)
;
}
exception
:
function
(
error
)
{
QUnit
.
config
.
current
.
assert
.
ok
(
false
(
0
_emberUtils
.
inspect
)
(
error
)
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
events
'
[
'
exports
'
'
ember
-
views
'
'
ember
-
metal
'
]
function
(
exports
_emberViews
_emberMetal
)
{
'
use
strict
'
;
exports
.
focus
=
focus
;
exports
.
fireEvent
=
fireEvent
;
var
DEFAULT_EVENT_OPTIONS
=
{
canBubble
:
true
cancelable
:
true
}
;
var
KEYBOARD_EVENT_TYPES
=
[
'
keydown
'
'
keypress
'
'
keyup
'
]
;
var
MOUSE_EVENT_TYPES
=
[
'
click
'
'
mousedown
'
'
mouseup
'
'
dblclick
'
'
mouseenter
'
'
mouseleave
'
'
mousemove
'
'
mouseout
'
'
mouseover
'
]
;
function
focus
(
el
)
{
if
(
!
el
)
{
return
;
}
var
el
=
(
0
_emberViews
.
jQuery
)
(
el
)
;
if
(
el
.
is
(
'
:
input
[
contenteditable
=
true
]
'
)
)
{
var
type
=
el
.
prop
(
'
type
'
)
;
if
(
type
!
=
=
'
checkbox
'
&
&
type
!
=
=
'
radio
'
&
&
type
!
=
=
'
hidden
'
)
{
(
0
_emberMetal
.
run
)
(
null
function
(
)
{
if
(
!
document
.
hasFocus
|
|
document
.
hasFocus
(
)
)
{
el
.
focus
(
)
;
}
else
{
el
.
trigger
(
'
focusin
'
)
;
}
}
)
;
}
}
}
function
fireEvent
(
element
type
)
{
var
options
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
{
}
;
if
(
!
element
)
{
return
;
}
var
event
=
void
0
;
if
(
KEYBOARD_EVENT_TYPES
.
indexOf
(
type
)
>
-
1
)
{
event
=
buildKeyboardEvent
(
type
options
)
;
}
else
if
(
MOUSE_EVENT_TYPES
.
indexOf
(
type
)
>
-
1
)
{
var
rect
=
element
.
getBoundingClientRect
(
)
;
var
x
=
rect
.
left
+
1
;
var
y
=
rect
.
top
+
1
;
var
simulatedCoordinates
=
{
screenX
:
x
+
5
screenY
:
y
+
95
clientX
:
x
clientY
:
y
}
;
event
=
buildMouseEvent
(
type
_emberViews
.
jQuery
.
extend
(
simulatedCoordinates
options
)
)
;
}
else
{
event
=
buildBasicEvent
(
type
options
)
;
}
element
.
dispatchEvent
(
event
)
;
}
function
buildBasicEvent
(
type
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
event
=
document
.
createEvent
(
'
Events
'
)
;
event
.
initEvent
(
type
true
true
)
;
_emberViews
.
jQuery
.
extend
(
event
options
)
;
return
event
;
}
function
buildMouseEvent
(
type
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
event
=
void
0
;
try
{
event
=
document
.
createEvent
(
'
MouseEvents
'
)
;
var
eventOpts
=
_emberViews
.
jQuery
.
extend
(
{
}
DEFAULT_EVENT_OPTIONS
options
)
;
event
.
initMouseEvent
(
type
eventOpts
.
canBubble
eventOpts
.
cancelable
window
eventOpts
.
detail
eventOpts
.
screenX
eventOpts
.
screenY
eventOpts
.
clientX
eventOpts
.
clientY
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
button
eventOpts
.
relatedTarget
)
;
}
catch
(
e
)
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
function
buildKeyboardEvent
(
type
)
{
var
options
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
var
event
=
void
0
;
try
{
event
=
document
.
createEvent
(
'
KeyEvents
'
)
;
var
eventOpts
=
_emberViews
.
jQuery
.
extend
(
{
}
DEFAULT_EVENT_OPTIONS
options
)
;
event
.
initKeyEvent
(
type
eventOpts
.
canBubble
eventOpts
.
cancelable
window
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
keyCode
eventOpts
.
charCode
)
;
}
catch
(
e
)
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
}
)
;
enifed
(
'
ember
-
testing
/
ext
/
application
'
[
'
ember
-
application
'
'
ember
-
testing
/
setup_for_testing
'
'
ember
-
testing
/
test
/
helpers
'
'
ember
-
testing
/
test
/
promise
'
'
ember
-
testing
/
test
/
run
'
'
ember
-
testing
/
test
/
on_inject_helpers
'
'
ember
-
testing
/
test
/
adapter
'
]
function
(
_emberApplication
_setup_for_testing
_helpers
_promise
_run
_on_inject_helpers
_adapter
)
{
'
use
strict
'
;
_emberApplication
.
Application
.
reopen
(
{
testHelpers
:
{
}
originalMethods
:
{
}
testing
:
false
setupForTesting
:
function
(
)
{
(
0
_setup_for_testing
.
default
)
(
)
;
this
.
testing
=
true
;
this
.
resolveRegistration
(
'
router
:
main
'
)
.
reopen
(
{
location
:
'
none
'
}
)
;
}
helperContainer
:
null
injectTestHelpers
:
function
(
helperContainer
)
{
if
(
helperContainer
)
{
this
.
helperContainer
=
helperContainer
;
}
else
{
this
.
helperContainer
=
window
;
}
this
.
reopen
(
{
willDestroy
:
function
(
)
{
this
.
_super
.
apply
(
this
arguments
)
;
this
.
removeTestHelpers
(
)
;
}
}
)
;
this
.
testHelpers
=
{
}
;
for
(
var
name
in
_helpers
.
helpers
)
{
this
.
originalMethods
[
name
]
=
this
.
helperContainer
[
name
]
;
this
.
testHelpers
[
name
]
=
this
.
helperContainer
[
name
]
=
helper
(
this
name
)
;
protoWrap
(
_promise
.
default
.
prototype
name
helper
(
this
name
)
_helpers
.
helpers
[
name
]
.
meta
.
wait
)
;
}
(
0
_on_inject_helpers
.
invokeInjectHelpersCallbacks
)
(
this
)
;
}
removeTestHelpers
:
function
(
)
{
if
(
!
this
.
helperContainer
)
{
return
;
}
for
(
var
name
in
_helpers
.
helpers
)
{
this
.
helperContainer
[
name
]
=
this
.
originalMethods
[
name
]
;
delete
_promise
.
default
.
prototype
[
name
]
;
delete
this
.
testHelpers
[
name
]
;
delete
this
.
originalMethods
[
name
]
;
}
}
}
)
;
function
protoWrap
(
proto
name
callback
isAsync
)
{
proto
[
name
]
=
function
(
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
)
_key
=
0
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
]
=
arguments
[
_key
]
;
}
if
(
isAsync
)
{
return
callback
.
apply
(
this
args
)
;
}
else
{
return
this
.
then
(
function
(
)
{
return
callback
.
apply
(
this
args
)
;
}
)
;
}
}
;
}
function
helper
(
app
name
)
{
var
fn
=
_helpers
.
helpers
[
name
]
.
method
;
var
meta
=
_helpers
.
helpers
[
name
]
.
meta
;
if
(
!
meta
.
wait
)
{
return
function
(
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
)
_key2
=
0
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
]
=
arguments
[
_key2
]
;
}
return
fn
.
apply
(
app
[
app
]
.
concat
(
args
)
)
;
}
;
}
return
function
(
)
{
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
)
_key3
=
0
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
]
=
arguments
[
_key3
]
;
}
var
lastPromise
=
(
0
_run
.
default
)
(
function
(
)
{
return
(
0
_promise
.
resolve
)
(
(
0
_promise
.
getLastPromise
)
(
)
)
;
}
)
;
(
0
_adapter
.
asyncStart
)
(
)
;
return
lastPromise
.
then
(
function
(
)
{
return
fn
.
apply
(
app
[
app
]
.
concat
(
args
)
)
;
}
)
.
finally
(
_adapter
.
asyncEnd
)
;
}
;
}
}
)
;
enifed
(
'
ember
-
testing
/
ext
/
rsvp
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
metal
'
'
ember
-
debug
'
'
ember
-
testing
/
test
/
adapter
'
]
function
(
exports
_emberRuntime
_emberMetal
_emberDebug
_adapter
)
{
'
use
strict
'
;
_emberRuntime
.
RSVP
.
configure
(
'
async
'
function
(
callback
promise
)
{
if
(
(
0
_emberDebug
.
isTesting
)
(
)
&
&
!
_emberMetal
.
run
.
backburner
.
currentInstance
)
{
(
0
_adapter
.
asyncStart
)
(
)
;
_emberMetal
.
run
.
backburner
.
schedule
(
'
actions
'
function
(
)
{
(
0
_adapter
.
asyncEnd
)
(
)
;
callback
(
promise
)
;
}
)
;
}
else
{
_emberMetal
.
run
.
backburner
.
schedule
(
'
actions
'
function
(
)
{
return
callback
(
promise
)
;
}
)
;
}
}
)
;
exports
.
default
=
_emberRuntime
.
RSVP
;
}
)
;
enifed
(
'
ember
-
testing
/
helpers
'
[
'
ember
-
testing
/
test
/
helpers
'
'
ember
-
testing
/
helpers
/
and_then
'
'
ember
-
testing
/
helpers
/
click
'
'
ember
-
testing
/
helpers
/
current_path
'
'
ember
-
testing
/
helpers
/
current_route_name
'
'
ember
-
testing
/
helpers
/
current_url
'
'
ember
-
testing
/
helpers
/
fill_in
'
'
ember
-
testing
/
helpers
/
find
'
'
ember
-
testing
/
helpers
/
find_with_assert
'
'
ember
-
testing
/
helpers
/
key_event
'
'
ember
-
testing
/
helpers
/
pause_test
'
'
ember
-
testing
/
helpers
/
trigger_event
'
'
ember
-
testing
/
helpers
/
visit
'
'
ember
-
testing
/
helpers
/
wait
'
]
function
(
_helpers
_and_then
_click
_current_path
_current_route_name
_current_url
_fill_in
_find
_find_with_assert
_key_event
_pause_test
_trigger_event
_visit
_wait
)
{
'
use
strict
'
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
visit
'
_visit
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
click
'
_click
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
keyEvent
'
_key_event
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
fillIn
'
_fill_in
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
wait
'
_wait
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
andThen
'
_and_then
.
default
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
pauseTest
'
_pause_test
.
pauseTest
)
;
(
0
_helpers
.
registerAsyncHelper
)
(
'
triggerEvent
'
_trigger_event
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
find
'
_find
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
findWithAssert
'
_find_with_assert
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
currentRouteName
'
_current_route_name
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
currentPath
'
_current_path
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
currentURL
'
_current_url
.
default
)
;
(
0
_helpers
.
registerHelper
)
(
'
resumeTest
'
_pause_test
.
resumeTest
)
;
}
)
;
enifed
(
"
ember
-
testing
/
helpers
/
and_then
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
andThen
;
function
andThen
(
app
callback
)
{
return
app
.
testHelpers
.
wait
(
callback
(
app
)
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
click
'
[
'
exports
'
'
ember
-
testing
/
events
'
]
function
(
exports
_events
)
{
'
use
strict
'
;
exports
.
default
=
click
;
function
click
(
app
selector
context
)
{
var
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
var
el
=
el
[
0
]
;
(
0
_events
.
fireEvent
)
(
el
'
mousedown
'
)
;
(
0
_events
.
focus
)
(
el
)
;
(
0
_events
.
fireEvent
)
(
el
'
mouseup
'
)
;
(
0
_events
.
fireEvent
)
(
el
'
click
'
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
current_path
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
currentPath
;
function
currentPath
(
app
)
{
var
routingService
=
app
.
__container__
.
lookup
(
'
service
:
-
routing
'
)
;
return
(
0
_emberMetal
.
get
)
(
routingService
'
currentPath
'
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
current_route_name
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
currentRouteName
;
function
currentRouteName
(
app
)
{
var
routingService
=
app
.
__container__
.
lookup
(
'
service
:
-
routing
'
)
;
return
(
0
_emberMetal
.
get
)
(
routingService
'
currentRouteName
'
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
current_url
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
currentURL
;
function
currentURL
(
app
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
return
(
0
_emberMetal
.
get
)
(
router
'
location
'
)
.
getURL
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
fill_in
'
[
'
exports
'
'
ember
-
testing
/
events
'
]
function
(
exports
_events
)
{
'
use
strict
'
;
exports
.
default
=
fillIn
;
function
fillIn
(
app
selector
contextOrText
text
)
{
var
el
=
void
0
el
=
void
0
context
=
void
0
;
if
(
text
=
=
=
undefined
)
{
text
=
contextOrText
;
}
else
{
context
=
contextOrText
;
}
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
el
=
el
[
0
]
;
(
0
_events
.
focus
)
(
el
)
;
el
.
eq
(
0
)
.
val
(
text
)
;
(
0
_events
.
fireEvent
)
(
el
'
input
'
)
;
(
0
_events
.
fireEvent
)
(
el
'
change
'
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
find
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
find
;
function
find
(
app
selector
context
)
{
var
el
=
void
0
;
context
=
context
|
|
(
0
_emberMetal
.
get
)
(
app
'
rootElement
'
)
;
el
=
app
.
(
selector
context
)
;
return
el
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
find_with_assert
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
exports
.
default
=
findWithAssert
;
function
findWithAssert
(
app
selector
context
)
{
var
el
=
app
.
testHelpers
.
find
(
selector
context
)
;
if
(
el
.
length
=
=
=
0
)
{
throw
new
Error
(
'
Element
'
+
selector
+
'
not
found
.
'
)
;
}
return
el
;
}
}
)
;
enifed
(
"
ember
-
testing
/
helpers
/
key_event
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
default
=
keyEvent
;
function
keyEvent
(
app
selector
contextOrType
typeOrKeyCode
keyCode
)
{
var
context
=
void
0
type
=
void
0
;
if
(
keyCode
=
=
=
undefined
)
{
context
=
null
;
keyCode
=
typeOrKeyCode
;
type
=
contextOrType
;
}
else
{
context
=
contextOrType
;
type
=
typeOrKeyCode
;
}
return
app
.
testHelpers
.
triggerEvent
(
selector
context
type
{
keyCode
:
keyCode
which
:
keyCode
}
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
pause_test
'
[
'
exports
'
'
ember
-
runtime
'
'
ember
-
console
'
'
ember
-
debug
'
]
function
(
exports
_emberRuntime
_emberConsole
_emberDebug
)
{
'
use
strict
'
;
exports
.
resumeTest
=
resumeTest
;
exports
.
pauseTest
=
pauseTest
;
var
resume
=
void
0
;
function
resumeTest
(
)
{
(
true
&
&
!
(
resume
)
&
&
(
0
_emberDebug
.
assert
)
(
'
Testing
has
not
been
paused
.
There
is
nothing
to
resume
.
'
resume
)
)
;
resume
(
)
;
resume
=
undefined
;
}
function
pauseTest
(
)
{
_emberConsole
.
default
.
info
(
'
Testing
paused
.
Use
resumeTest
(
)
to
continue
.
'
)
;
return
new
_emberRuntime
.
RSVP
.
Promise
(
function
(
resolve
)
{
resume
=
resolve
;
}
'
TestAdapter
paused
promise
'
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
trigger_event
'
[
'
exports
'
'
ember
-
testing
/
events
'
]
function
(
exports
_events
)
{
'
use
strict
'
;
exports
.
default
=
triggerEvent
;
function
triggerEvent
(
app
selector
contextOrType
typeOrOptions
possibleOptions
)
{
var
arity
=
arguments
.
length
;
var
context
=
void
0
type
=
void
0
options
=
void
0
;
if
(
arity
=
=
=
3
)
{
context
=
null
;
type
=
contextOrType
;
options
=
{
}
;
}
else
if
(
arity
=
=
=
4
)
{
if
(
typeof
typeOrOptions
=
=
=
'
object
'
)
{
context
=
null
;
type
=
contextOrType
;
options
=
typeOrOptions
;
}
else
{
context
=
contextOrType
;
type
=
typeOrOptions
;
options
=
{
}
;
}
}
else
{
context
=
contextOrType
;
type
=
typeOrOptions
;
options
=
possibleOptions
;
}
var
el
=
app
.
testHelpers
.
findWithAssert
(
selector
context
)
;
var
el
=
el
[
0
]
;
(
0
_events
.
fireEvent
)
(
el
type
options
)
;
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
visit
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
visit
;
function
visit
(
app
url
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
var
shouldHandleURL
=
false
;
app
.
boot
(
)
.
then
(
function
(
)
{
router
.
location
.
setURL
(
url
)
;
if
(
shouldHandleURL
)
{
(
0
_emberMetal
.
run
)
(
app
.
__deprecatedInstance__
'
handleURL
'
url
)
;
}
}
)
;
if
(
app
.
_readinessDeferrals
>
0
)
{
router
[
'
initialURL
'
]
=
url
;
(
0
_emberMetal
.
run
)
(
app
'
advanceReadiness
'
)
;
delete
router
[
'
initialURL
'
]
;
}
else
{
shouldHandleURL
=
true
;
}
return
app
.
testHelpers
.
wait
(
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
helpers
/
wait
'
[
'
exports
'
'
ember
-
testing
/
test
/
waiters
'
'
ember
-
runtime
'
'
ember
-
metal
'
'
ember
-
testing
/
test
/
pending_requests
'
]
function
(
exports
_waiters
_emberRuntime
_emberMetal
_pending_requests
)
{
'
use
strict
'
;
exports
.
default
=
wait
;
function
wait
(
app
value
)
{
return
new
_emberRuntime
.
RSVP
.
Promise
(
function
(
resolve
)
{
var
router
=
app
.
__container__
.
lookup
(
'
router
:
main
'
)
;
var
watcher
=
setInterval
(
function
(
)
{
var
routerIsLoading
=
router
.
_routerMicrolib
&
&
!
!
router
.
_routerMicrolib
.
activeTransition
;
if
(
routerIsLoading
)
{
return
;
}
if
(
(
0
_pending_requests
.
pendingRequests
)
(
)
)
{
return
;
}
if
(
_emberMetal
.
run
.
hasScheduledTimers
(
)
|
|
_emberMetal
.
run
.
currentRunLoop
)
{
return
;
}
if
(
(
0
_waiters
.
checkWaiters
)
(
)
)
{
return
;
}
clearInterval
(
watcher
)
;
(
0
_emberMetal
.
run
)
(
null
resolve
value
)
;
}
10
)
;
}
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
index
'
[
'
exports
'
'
ember
-
testing
/
test
'
'
ember
-
testing
/
adapters
/
adapter
'
'
ember
-
testing
/
setup_for_testing
'
'
ember
-
testing
/
adapters
/
qunit
'
'
ember
-
testing
/
support
'
'
ember
-
testing
/
ext
/
application
'
'
ember
-
testing
/
ext
/
rsvp
'
'
ember
-
testing
/
helpers
'
'
ember
-
testing
/
initializers
'
]
function
(
exports
_test
_adapter
_setup_for_testing
_qunit
)
{
'
use
strict
'
;
exports
.
QUnitAdapter
=
exports
.
setupForTesting
=
exports
.
Adapter
=
exports
.
Test
=
undefined
;
Object
.
defineProperty
(
exports
'
Test
'
{
enumerable
:
true
get
:
function
(
)
{
return
_test
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
Adapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_adapter
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupForTesting
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setup_for_testing
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
QUnitAdapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_qunit
.
default
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
initializers
'
[
'
ember
-
runtime
'
]
function
(
_emberRuntime
)
{
'
use
strict
'
;
var
name
=
'
deferReadiness
in
testing
mode
'
;
(
0
_emberRuntime
.
onLoad
)
(
'
Ember
.
Application
'
function
(
Application
)
{
if
(
!
Application
.
initializers
[
name
]
)
{
Application
.
initializer
(
{
name
:
name
initialize
:
function
(
application
)
{
if
(
application
.
testing
)
{
application
.
deferReadiness
(
)
;
}
}
}
)
;
}
}
)
;
}
)
;
enifed
(
'
ember
-
testing
/
setup_for_testing
'
[
'
exports
'
'
ember
-
debug
'
'
ember
-
views
'
'
ember
-
testing
/
test
/
adapter
'
'
ember
-
testing
/
test
/
pending_requests
'
'
ember
-
testing
/
adapters
/
adapter
'
'
ember
-
testing
/
adapters
/
qunit
'
]
function
(
exports
_emberDebug
_emberViews
_adapter
_pending_requests
_adapter2
_qunit
)
{
'
use
strict
'
;
exports
.
default
=
setupForTesting
;
function
setupForTesting
(
)
{
(
0
_emberDebug
.
setTesting
)
(
true
)
;
var
adapter
=
(
0
_adapter
.
getAdapter
)
(
)
;
if
(
!
adapter
)
{
(
0
_adapter
.
setAdapter
)
(
typeof
self
.
QUnit
=
=
=
'
undefined
'
?
new
_adapter2
.
default
(
)
:
new
_qunit
.
default
(
)
)
;
}
if
(
_emberViews
.
jQuery
)
{
(
0
_emberViews
.
jQuery
)
(
document
)
.
off
(
'
ajaxSend
'
_pending_requests
.
incrementPendingRequests
)
;
(
0
_emberViews
.
jQuery
)
(
document
)
.
off
(
'
ajaxComplete
'
_pending_requests
.
decrementPendingRequests
)
;
(
0
_pending_requests
.
clearPendingRequests
)
(
)
;
(
0
_emberViews
.
jQuery
)
(
document
)
.
on
(
'
ajaxSend
'
_pending_requests
.
incrementPendingRequests
)
;
(
0
_emberViews
.
jQuery
)
(
document
)
.
on
(
'
ajaxComplete
'
_pending_requests
.
decrementPendingRequests
)
;
}
}
}
)
;
enifed
(
'
ember
-
testing
/
support
'
[
'
ember
-
debug
'
'
ember
-
views
'
'
ember
-
environment
'
]
function
(
_emberDebug
_emberViews
_emberEnvironment
)
{
'
use
strict
'
;
var
=
_emberViews
.
jQuery
;
function
testCheckboxClick
(
handler
)
{
var
input
=
document
.
createElement
(
'
input
'
)
;
(
input
)
.
attr
(
'
type
'
'
checkbox
'
)
.
css
(
{
position
:
'
absolute
'
left
:
'
-
1000px
'
top
:
'
-
1000px
'
}
)
.
appendTo
(
'
body
'
)
.
on
(
'
click
'
handler
)
.
trigger
(
'
click
'
)
.
remove
(
)
;
}
if
(
_emberEnvironment
.
environment
.
hasDOM
&
&
typeof
=
=
=
'
function
'
)
{
(
function
(
)
{
testCheckboxClick
(
function
(
)
{
if
(
!
this
.
checked
&
&
!
.
event
.
special
.
click
)
{
.
event
.
special
.
click
=
{
trigger
:
function
(
)
{
if
(
.
nodeName
(
this
'
input
'
)
&
&
this
.
type
=
=
=
'
checkbox
'
&
&
this
.
click
)
{
this
.
click
(
)
;
return
false
;
}
}
}
;
}
}
)
;
testCheckboxClick
(
function
(
)
{
(
true
&
&
(
0
_emberDebug
.
warn
)
(
'
clicked
checkboxes
should
be
checked
!
the
jQuery
patch
didn
\
'
t
work
'
this
.
checked
{
id
:
'
ember
-
testing
.
test
-
checkbox
-
click
'
}
)
)
;
}
)
;
}
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
test
'
[
'
exports
'
'
ember
-
testing
/
test
/
helpers
'
'
ember
-
testing
/
test
/
on_inject_helpers
'
'
ember
-
testing
/
test
/
promise
'
'
ember
-
testing
/
test
/
waiters
'
'
ember
-
testing
/
test
/
adapter
'
]
function
(
exports
_helpers
_on_inject_helpers
_promise
_waiters
_adapter
)
{
'
use
strict
'
;
var
Test
=
{
_helpers
:
_helpers
.
helpers
registerHelper
:
_helpers
.
registerHelper
registerAsyncHelper
:
_helpers
.
registerAsyncHelper
unregisterHelper
:
_helpers
.
unregisterHelper
onInjectHelpers
:
_on_inject_helpers
.
onInjectHelpers
Promise
:
_promise
.
default
promise
:
_promise
.
promise
resolve
:
_promise
.
resolve
registerWaiter
:
_waiters
.
registerWaiter
unregisterWaiter
:
_waiters
.
unregisterWaiter
checkWaiters
:
_waiters
.
checkWaiters
}
;
Object
.
defineProperty
(
Test
'
adapter
'
{
get
:
_adapter
.
getAdapter
set
:
_adapter
.
setAdapter
}
)
;
exports
.
default
=
Test
;
}
)
;
enifed
(
'
ember
-
testing
/
test
/
adapter
'
[
'
exports
'
'
ember
-
console
'
'
ember
-
metal
'
]
function
(
exports
_emberConsole
_emberMetal
)
{
'
use
strict
'
;
exports
.
getAdapter
=
getAdapter
;
exports
.
setAdapter
=
setAdapter
;
exports
.
asyncStart
=
asyncStart
;
exports
.
asyncEnd
=
asyncEnd
;
var
adapter
=
void
0
;
function
getAdapter
(
)
{
return
adapter
;
}
function
setAdapter
(
value
)
{
adapter
=
value
;
if
(
value
&
&
typeof
value
.
exception
=
=
=
'
function
'
)
{
(
0
_emberMetal
.
setDispatchOverride
)
(
adapterDispatch
)
;
}
else
{
(
0
_emberMetal
.
setDispatchOverride
)
(
null
)
;
}
}
function
asyncStart
(
)
{
if
(
adapter
)
{
adapter
.
asyncStart
(
)
;
}
}
function
asyncEnd
(
)
{
if
(
adapter
)
{
adapter
.
asyncEnd
(
)
;
}
}
function
adapterDispatch
(
error
)
{
adapter
.
exception
(
error
)
;
_emberConsole
.
default
.
error
(
error
.
stack
)
;
}
}
)
;
enifed
(
'
ember
-
testing
/
test
/
helpers
'
[
'
exports
'
'
ember
-
testing
/
test
/
promise
'
]
function
(
exports
_promise
)
{
'
use
strict
'
;
exports
.
helpers
=
undefined
;
exports
.
registerHelper
=
registerHelper
;
exports
.
registerAsyncHelper
=
registerAsyncHelper
;
exports
.
unregisterHelper
=
unregisterHelper
;
var
helpers
=
exports
.
helpers
=
{
}
;
function
registerHelper
(
name
helperMethod
)
{
helpers
[
name
]
=
{
method
:
helperMethod
meta
:
{
wait
:
false
}
}
;
}
function
registerAsyncHelper
(
name
helperMethod
)
{
helpers
[
name
]
=
{
method
:
helperMethod
meta
:
{
wait
:
true
}
}
;
}
function
unregisterHelper
(
name
)
{
delete
helpers
[
name
]
;
delete
_promise
.
default
.
prototype
[
name
]
;
}
}
)
;
enifed
(
"
ember
-
testing
/
test
/
on_inject_helpers
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
onInjectHelpers
=
onInjectHelpers
;
exports
.
invokeInjectHelpersCallbacks
=
invokeInjectHelpersCallbacks
;
var
callbacks
=
exports
.
callbacks
=
[
]
;
function
onInjectHelpers
(
callback
)
{
callbacks
.
push
(
callback
)
;
}
function
invokeInjectHelpersCallbacks
(
app
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callbacks
[
i
]
(
app
)
;
}
}
}
)
;
enifed
(
"
ember
-
testing
/
test
/
pending_requests
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
pendingRequests
=
pendingRequests
;
exports
.
clearPendingRequests
=
clearPendingRequests
;
exports
.
incrementPendingRequests
=
incrementPendingRequests
;
exports
.
decrementPendingRequests
=
decrementPendingRequests
;
var
requests
=
[
]
;
function
pendingRequests
(
)
{
return
requests
.
length
;
}
function
clearPendingRequests
(
)
{
requests
.
length
=
0
;
}
function
incrementPendingRequests
(
_
xhr
)
{
requests
.
push
(
xhr
)
;
}
function
decrementPendingRequests
(
_
xhr
)
{
for
(
var
i
=
0
;
i
<
requests
.
length
;
i
+
+
)
{
if
(
xhr
=
=
=
requests
[
i
]
)
{
requests
.
splice
(
i
1
)
;
break
;
}
}
}
}
)
;
enifed
(
'
ember
-
testing
/
test
/
promise
'
[
'
exports
'
'
ember
-
babel
'
'
ember
-
runtime
'
'
ember
-
testing
/
test
/
run
'
]
function
(
exports
_emberBabel
_emberRuntime
_run
)
{
'
use
strict
'
;
exports
.
promise
=
promise
;
exports
.
resolve
=
resolve
;
exports
.
getLastPromise
=
getLastPromise
;
var
lastPromise
=
void
0
;
var
TestPromise
=
function
(
_RSVP
Promise
)
{
(
0
_emberBabel
.
inherits
)
(
TestPromise
_RSVP
Promise
)
;
function
TestPromise
(
)
{
(
0
_emberBabel
.
classCallCheck
)
(
this
TestPromise
)
;
var
_this
=
(
0
_emberBabel
.
possibleConstructorReturn
)
(
this
_RSVP
Promise
.
apply
(
this
arguments
)
)
;
lastPromise
=
_this
;
return
_this
;
}
TestPromise
.
prototype
.
then
=
function
then
(
_onFulfillment
)
{
var
_RSVP
Promise
prototy
;
var
onFulfillment
=
typeof
_onFulfillment
=
=
=
'
function
'
?
function
(
result
)
{
return
isolate
(
_onFulfillment
result
)
;
}
:
undefined
;
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
return
(
_RSVP
Promise
prototy
=
_RSVP
Promise
.
prototype
.
then
)
.
call
.
apply
(
_RSVP
Promise
prototy
[
this
onFulfillment
]
.
concat
(
args
)
)
;
}
;
return
TestPromise
;
}
(
_emberRuntime
.
RSVP
.
Promise
)
;
exports
.
default
=
TestPromise
;
function
promise
(
resolver
label
)
{
var
fullLabel
=
'
Ember
.
Test
.
promise
:
'
+
(
label
|
|
'
<
Unknown
Promise
>
'
)
;
return
new
TestPromise
(
resolver
fullLabel
)
;
}
function
resolve
(
result
label
)
{
return
TestPromise
.
resolve
(
result
label
)
;
}
function
getLastPromise
(
)
{
return
lastPromise
;
}
function
isolate
(
onFulfillment
result
)
{
lastPromise
=
null
;
var
value
=
onFulfillment
(
result
)
;
var
promise
=
lastPromise
;
lastPromise
=
null
;
if
(
value
&
&
value
instanceof
TestPromise
|
|
!
promise
)
{
return
value
;
}
else
{
return
(
0
_run
.
default
)
(
function
(
)
{
return
resolve
(
promise
)
.
then
(
function
(
)
{
return
value
;
}
)
;
}
)
;
}
}
}
)
;
enifed
(
'
ember
-
testing
/
test
/
run
'
[
'
exports
'
'
ember
-
metal
'
]
function
(
exports
_emberMetal
)
{
'
use
strict
'
;
exports
.
default
=
run
;
function
run
(
fn
)
{
if
(
!
_emberMetal
.
run
.
currentRunLoop
)
{
return
(
0
_emberMetal
.
run
)
(
fn
)
;
}
else
{
return
fn
(
)
;
}
}
}
)
;
enifed
(
"
ember
-
testing
/
test
/
waiters
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
exports
.
registerWaiter
=
registerWaiter
;
exports
.
unregisterWaiter
=
unregisterWaiter
;
exports
.
checkWaiters
=
checkWaiters
;
var
contexts
=
[
]
;
var
callbacks
=
[
]
;
function
registerWaiter
(
context
callback
)
{
if
(
arguments
.
length
=
=
=
1
)
{
callback
=
context
;
context
=
null
;
}
if
(
indexOf
(
context
callback
)
>
-
1
)
{
return
;
}
contexts
.
push
(
context
)
;
callbacks
.
push
(
callback
)
;
}
function
unregisterWaiter
(
context
callback
)
{
if
(
!
callbacks
.
length
)
{
return
;
}
if
(
arguments
.
length
=
=
=
1
)
{
callback
=
context
;
context
=
null
;
}
var
i
=
indexOf
(
context
callback
)
;
if
(
i
=
=
=
-
1
)
{
return
;
}
contexts
.
splice
(
i
1
)
;
callbacks
.
splice
(
i
1
)
;
}
function
checkWaiters
(
)
{
if
(
!
callbacks
.
length
)
{
return
false
;
}
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
var
context
=
contexts
[
i
]
;
var
callback
=
callbacks
[
i
]
;
if
(
!
callback
.
call
(
context
)
)
{
return
true
;
}
}
return
false
;
}
function
indexOf
(
context
callback
)
{
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
if
(
callbacks
[
i
]
=
=
=
callback
&
&
contexts
[
i
]
=
=
=
context
)
{
return
i
;
}
}
return
-
1
;
}
}
)
;
enifed
(
'
node
-
module
'
[
'
exports
'
]
function
(
_exports
)
{
var
IS_NODE
=
typeof
module
=
=
=
'
object
'
&
&
typeof
module
.
require
=
=
=
'
function
'
;
if
(
IS_NODE
)
{
_exports
.
require
=
module
.
require
;
_exports
.
module
=
module
;
_exports
.
IS_NODE
=
IS_NODE
;
}
else
{
_exports
.
require
=
null
;
_exports
.
module
=
null
;
_exports
.
IS_NODE
=
IS_NODE
;
}
}
)
;
var
testing
=
requireModule
(
'
ember
-
testing
'
)
;
Ember
.
Test
=
testing
.
Test
;
Ember
.
Test
.
Adapter
=
testing
.
Adapter
;
Ember
.
Test
.
QUnitAdapter
=
testing
.
QUnitAdapter
;
Ember
.
setupForTesting
=
testing
.
setupForTesting
;
}
(
)
)
;
(
(
)
=
>
{
if
(
typeof
jQuery
!
=
=
'
undefined
'
)
{
let
_Ember
;
if
(
typeof
Ember
!
=
=
'
undefined
'
)
{
_Ember
=
Ember
;
}
else
{
_Ember
=
require
(
'
ember
'
)
.
default
;
}
let
pendingRequests
;
if
(
Ember
.
__loader
.
registry
[
'
ember
-
testing
/
test
/
pending_requests
'
]
)
{
pendingRequests
=
Ember
.
__loader
.
require
(
'
ember
-
testing
/
test
/
pending_requests
'
)
;
}
if
(
pendingRequests
)
{
_Ember
.
Application
.
reopen
(
{
willDestroy
(
)
{
jQuery
(
document
)
.
off
(
'
ajaxSend
'
pendingRequests
.
incrementPendingRequests
)
;
jQuery
(
document
)
.
off
(
'
ajaxComplete
'
pendingRequests
.
decrementPendingRequests
)
;
pendingRequests
.
clearPendingRequests
(
)
;
this
.
_super
(
.
.
.
arguments
)
;
}
}
)
;
}
}
}
)
(
)
;
(
function
(
global
1
)
{
'
use
strict
'
;
global
1
=
global
1
&
&
global
1
.
hasOwnProperty
(
'
default
'
)
?
global
1
[
'
default
'
]
:
global
1
;
var
window
=
global
1
.
window
;
var
self
1
=
global
1
.
self
;
var
console
=
global
1
.
console
;
var
setTimeout
=
global
1
.
setTimeout
;
var
clearTimeout
=
global
1
.
clearTimeout
;
var
document
=
window
&
&
window
.
document
;
var
navigator
=
window
&
&
window
.
navigator
;
var
localSessionStorage
=
function
(
)
{
var
x
=
"
qunit
-
test
-
string
"
;
try
{
global
1
.
sessionStorage
.
setItem
(
x
x
)
;
global
1
.
sessionStorage
.
removeItem
(
x
)
;
return
global
1
.
sessionStorage
;
}
catch
(
e
)
{
return
undefined
;
}
}
(
)
;
var
_typeof
=
typeof
Symbol
=
=
=
"
function
"
&
&
typeof
Symbol
.
iterator
=
=
=
"
symbol
"
?
function
(
obj
)
{
return
typeof
obj
;
}
:
function
(
obj
)
{
return
obj
&
&
typeof
Symbol
=
=
=
"
function
"
&
&
obj
.
constructor
=
=
=
Symbol
&
&
obj
!
=
=
Symbol
.
prototype
?
"
symbol
"
:
typeof
obj
;
}
;
var
classCallCheck
=
function
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
;
var
createClass
=
function
(
)
{
function
defineProperties
(
target
props
)
{
for
(
var
i
=
0
;
i
<
props
.
length
;
i
+
+
)
{
var
descriptor
=
props
[
i
]
;
descriptor
.
enumerable
=
descriptor
.
enumerable
|
|
false
;
descriptor
.
configurable
=
true
;
if
(
"
value
"
in
descriptor
)
descriptor
.
writable
=
true
;
Object
.
defineProperty
(
target
descriptor
.
key
descriptor
)
;
}
}
return
function
(
Constructor
protoProps
staticProps
)
{
if
(
protoProps
)
defineProperties
(
Constructor
.
prototype
protoProps
)
;
if
(
staticProps
)
defineProperties
(
Constructor
staticProps
)
;
return
Constructor
;
}
;
}
(
)
;
var
toConsumableArray
=
function
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
arr2
[
i
]
=
arr
[
i
]
;
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
;
var
toString
=
Object
.
prototype
.
toString
;
var
hasOwn
=
Object
.
prototype
.
hasOwnProperty
;
var
now
=
Date
.
now
|
|
function
(
)
{
return
new
Date
(
)
.
getTime
(
)
;
}
;
var
defined
=
{
document
:
window
&
&
window
.
document
!
=
=
undefined
setTimeout
:
setTimeout
!
=
=
undefined
}
;
function
diff
(
a
b
)
{
var
i
j
result
=
a
.
slice
(
)
;
for
(
i
=
0
;
i
<
result
.
length
;
i
+
+
)
{
for
(
j
=
0
;
j
<
b
.
length
;
j
+
+
)
{
if
(
result
[
i
]
=
=
=
b
[
j
]
)
{
result
.
splice
(
i
1
)
;
i
-
-
;
break
;
}
}
}
return
result
;
}
function
inArray
(
elem
array
)
{
return
array
.
indexOf
(
elem
)
!
=
=
-
1
;
}
function
objectValues
(
obj
)
{
var
key
val
vals
=
is
(
"
array
"
obj
)
?
[
]
:
{
}
;
for
(
key
in
obj
)
{
if
(
hasOwn
.
call
(
obj
key
)
)
{
val
=
obj
[
key
]
;
vals
[
key
]
=
val
=
=
=
Object
(
val
)
?
objectValues
(
val
)
:
val
;
}
}
return
vals
;
}
function
extend
(
a
b
undefOnly
)
{
for
(
var
prop
in
b
)
{
if
(
hasOwn
.
call
(
b
prop
)
)
{
if
(
b
[
prop
]
=
=
=
undefined
)
{
delete
a
[
prop
]
;
}
else
if
(
!
(
undefOnly
&
&
typeof
a
[
prop
]
!
=
=
"
undefined
"
)
)
{
a
[
prop
]
=
b
[
prop
]
;
}
}
}
return
a
;
}
function
objectType
(
obj
)
{
if
(
typeof
obj
=
=
=
"
undefined
"
)
{
return
"
undefined
"
;
}
if
(
obj
=
=
=
null
)
{
return
"
null
"
;
}
var
match
=
toString
.
call
(
obj
)
.
match
(
/
^
\
[
object
\
s
(
.
*
)
\
]
/
)
type
=
match
&
&
match
[
1
]
;
switch
(
type
)
{
case
"
Number
"
:
if
(
isNaN
(
obj
)
)
{
return
"
nan
"
;
}
return
"
number
"
;
case
"
String
"
:
case
"
Boolean
"
:
case
"
Array
"
:
case
"
Set
"
:
case
"
Map
"
:
case
"
Date
"
:
case
"
RegExp
"
:
case
"
Function
"
:
case
"
Symbol
"
:
return
type
.
toLowerCase
(
)
;
default
:
return
typeof
obj
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
obj
)
;
}
}
function
is
(
type
obj
)
{
return
objectType
(
obj
)
=
=
=
type
;
}
function
generateHash
(
module
testName
)
{
var
str
=
module
+
"
\
x1C
"
+
testName
;
var
hash
=
0
;
for
(
var
i
=
0
;
i
<
str
.
length
;
i
+
+
)
{
hash
=
(
hash
<
<
5
)
-
hash
+
str
.
charCodeAt
(
i
)
;
hash
|
=
0
;
}
var
hex
=
(
0x100000000
+
hash
)
.
toString
(
16
)
;
if
(
hex
.
length
<
8
)
{
hex
=
"
0000000
"
+
hex
;
}
return
hex
.
slice
(
-
8
)
;
}
var
equiv
=
(
function
(
)
{
var
pairs
=
[
]
;
var
getProto
=
Object
.
getPrototypeOf
|
|
function
(
obj
)
{
return
obj
.
__proto__
;
}
;
function
useStrictEquality
(
a
b
)
{
if
(
(
typeof
a
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
a
)
)
=
=
=
"
object
"
)
{
a
=
a
.
valueOf
(
)
;
}
if
(
(
typeof
b
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
b
)
)
=
=
=
"
object
"
)
{
b
=
b
.
valueOf
(
)
;
}
return
a
=
=
=
b
;
}
function
compareConstructors
(
a
b
)
{
var
protoA
=
getProto
(
a
)
;
var
protoB
=
getProto
(
b
)
;
if
(
a
.
constructor
=
=
=
b
.
constructor
)
{
return
true
;
}
if
(
protoA
&
&
protoA
.
constructor
=
=
=
null
)
{
protoA
=
null
;
}
if
(
protoB
&
&
protoB
.
constructor
=
=
=
null
)
{
protoB
=
null
;
}
if
(
protoA
=
=
=
null
&
&
protoB
=
=
=
Object
.
prototype
|
|
protoB
=
=
=
null
&
&
protoA
=
=
=
Object
.
prototype
)
{
return
true
;
}
return
false
;
}
function
getRegExpFlags
(
regexp
)
{
return
"
flags
"
in
regexp
?
regexp
.
flags
:
regexp
.
toString
(
)
.
match
(
/
[
gimuy
]
*
/
)
[
0
]
;
}
function
isContainer
(
val
)
{
return
[
"
object
"
"
array
"
"
map
"
"
set
"
]
.
indexOf
(
objectType
(
val
)
)
!
=
=
-
1
;
}
function
breadthFirstCompareChild
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
if
(
!
isContainer
(
a
)
)
{
return
typeEquiv
(
a
b
)
;
}
if
(
pairs
.
every
(
function
(
pair
)
{
return
pair
.
a
!
=
=
a
|
|
pair
.
b
!
=
=
b
;
}
)
)
{
pairs
.
push
(
{
a
:
a
b
:
b
}
)
;
}
return
true
;
}
var
callbacks
=
{
"
string
"
:
useStrictEquality
"
boolean
"
:
useStrictEquality
"
number
"
:
useStrictEquality
"
null
"
:
useStrictEquality
"
undefined
"
:
useStrictEquality
"
symbol
"
:
useStrictEquality
"
date
"
:
useStrictEquality
"
nan
"
:
function
nan
(
)
{
return
true
;
}
"
regexp
"
:
function
regexp
(
a
b
)
{
return
a
.
source
=
=
=
b
.
source
&
&
getRegExpFlags
(
a
)
=
=
=
getRegExpFlags
(
b
)
;
}
"
function
"
:
function
_function
(
)
{
return
false
;
}
"
array
"
:
function
array
(
a
b
)
{
var
i
len
;
len
=
a
.
length
;
if
(
len
!
=
=
b
.
length
)
{
return
false
;
}
for
(
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
!
breadthFirstCompareChild
(
a
[
i
]
b
[
i
]
)
)
{
return
false
;
}
}
return
true
;
}
"
set
"
:
function
set
1
(
a
b
)
{
var
innerEq
outerEq
=
true
;
if
(
a
.
size
!
=
=
b
.
size
)
{
return
false
;
}
a
.
forEach
(
function
(
aVal
)
{
if
(
!
outerEq
)
{
return
;
}
innerEq
=
false
;
b
.
forEach
(
function
(
bVal
)
{
var
parentPairs
;
if
(
innerEq
)
{
return
;
}
parentPairs
=
pairs
;
if
(
innerEquiv
(
bVal
aVal
)
)
{
innerEq
=
true
;
}
pairs
=
parentPairs
;
}
)
;
if
(
!
innerEq
)
{
outerEq
=
false
;
}
}
)
;
return
outerEq
;
}
"
map
"
:
function
map
(
a
b
)
{
var
innerEq
outerEq
=
true
;
if
(
a
.
size
!
=
=
b
.
size
)
{
return
false
;
}
a
.
forEach
(
function
(
aVal
aKey
)
{
if
(
!
outerEq
)
{
return
;
}
innerEq
=
false
;
b
.
forEach
(
function
(
bVal
bKey
)
{
var
parentPairs
;
if
(
innerEq
)
{
return
;
}
parentPairs
=
pairs
;
if
(
innerEquiv
(
[
bVal
bKey
]
[
aVal
aKey
]
)
)
{
innerEq
=
true
;
}
pairs
=
parentPairs
;
}
)
;
if
(
!
innerEq
)
{
outerEq
=
false
;
}
}
)
;
return
outerEq
;
}
"
object
"
:
function
object
(
a
b
)
{
var
i
aProperties
=
[
]
bProperties
=
[
]
;
if
(
compareConstructors
(
a
b
)
=
=
=
false
)
{
return
false
;
}
for
(
i
in
a
)
{
aProperties
.
push
(
i
)
;
if
(
a
.
constructor
!
=
=
Object
&
&
typeof
a
.
constructor
!
=
=
"
undefined
"
&
&
typeof
a
[
i
]
=
=
=
"
function
"
&
&
typeof
b
[
i
]
=
=
=
"
function
"
&
&
a
[
i
]
.
toString
(
)
=
=
=
b
[
i
]
.
toString
(
)
)
{
continue
;
}
if
(
!
breadthFirstCompareChild
(
a
[
i
]
b
[
i
]
)
)
{
return
false
;
}
}
for
(
i
in
b
)
{
bProperties
.
push
(
i
)
;
}
return
typeEquiv
(
aProperties
.
sort
(
)
bProperties
.
sort
(
)
)
;
}
}
;
function
typeEquiv
(
a
b
)
{
var
type
=
objectType
(
a
)
;
return
objectType
(
b
)
=
=
=
type
&
&
callbacks
[
type
]
(
a
b
)
;
}
function
innerEquiv
(
a
b
)
{
var
i
pair
;
if
(
arguments
.
length
<
2
)
{
return
true
;
}
pairs
=
[
{
a
:
a
b
:
b
}
]
;
for
(
i
=
0
;
i
<
pairs
.
length
;
i
+
+
)
{
pair
=
pairs
[
i
]
;
if
(
pair
.
a
!
=
=
pair
.
b
&
&
!
typeEquiv
(
pair
.
a
pair
.
b
)
)
{
return
false
;
}
}
return
arguments
.
length
=
=
=
2
|
|
innerEquiv
.
apply
(
this
[
]
.
slice
.
call
(
arguments
1
)
)
;
}
return
function
(
)
{
var
result
=
innerEquiv
.
apply
(
undefined
arguments
)
;
pairs
.
length
=
0
;
return
result
;
}
;
}
)
(
)
;
var
config
=
{
queue
:
[
]
blocking
:
true
reorder
:
true
altertitle
:
true
collapse
:
true
scrolltop
:
true
maxDepth
:
5
requireExpects
:
false
urlConfig
:
[
]
modules
:
[
]
currentModule
:
{
name
:
"
"
tests
:
[
]
childModules
:
[
]
testsRun
:
0
unskippedTestsRun
:
0
hooks
:
{
before
:
[
]
beforeEach
:
[
]
afterEach
:
[
]
after
:
[
]
}
}
callbacks
:
{
}
storage
:
localSessionStorage
}
;
var
globalConfig
=
window
&
&
window
.
QUnit
&
&
window
.
QUnit
.
config
;
if
(
window
&
&
window
.
QUnit
&
&
!
window
.
QUnit
.
version
)
{
extend
(
config
globalConfig
)
;
}
config
.
modules
.
push
(
config
.
currentModule
)
;
var
dump
=
(
function
(
)
{
function
quote
(
str
)
{
return
"
\
"
"
+
str
.
toString
(
)
.
replace
(
/
\
\
/
g
"
\
\
\
\
"
)
.
replace
(
/
"
/
g
"
\
\
\
"
"
)
+
"
\
"
"
;
}
function
literal
(
o
)
{
return
o
+
"
"
;
}
function
join
(
pre
arr
post
)
{
var
s
=
dump
.
separator
(
)
base
=
dump
.
indent
(
)
inner
=
dump
.
indent
(
1
)
;
if
(
arr
.
join
)
{
arr
=
arr
.
join
(
"
"
+
s
+
inner
)
;
}
if
(
!
arr
)
{
return
pre
+
post
;
}
return
[
pre
inner
+
arr
base
+
post
]
.
join
(
s
)
;
}
function
array
(
arr
stack
)
{
var
i
=
arr
.
length
ret
=
new
Array
(
i
)
;
if
(
dump
.
maxDepth
&
&
dump
.
depth
>
dump
.
maxDepth
)
{
return
"
[
object
Array
]
"
;
}
this
.
up
(
)
;
while
(
i
-
-
)
{
ret
[
i
]
=
this
.
parse
(
arr
[
i
]
undefined
stack
)
;
}
this
.
down
(
)
;
return
join
(
"
[
"
ret
"
]
"
)
;
}
function
isArray
(
obj
)
{
return
(
toString
.
call
(
obj
)
=
=
=
"
[
object
Array
]
"
|
|
typeof
obj
.
length
=
=
=
"
number
"
&
&
obj
.
item
!
=
=
undefined
&
&
(
obj
.
length
?
obj
.
item
(
0
)
=
=
=
obj
[
0
]
:
obj
.
item
(
0
)
=
=
=
null
&
&
obj
[
0
]
=
=
=
undefined
)
)
;
}
var
reName
=
/
^
function
(
\
w
+
)
/
dump
=
{
parse
:
function
parse
(
obj
objType
stack
)
{
stack
=
stack
|
|
[
]
;
var
res
parser
parserType
objIndex
=
stack
.
indexOf
(
obj
)
;
if
(
objIndex
!
=
=
-
1
)
{
return
"
recursion
(
"
+
(
objIndex
-
stack
.
length
)
+
"
)
"
;
}
objType
=
objType
|
|
this
.
typeOf
(
obj
)
;
parser
=
this
.
parsers
[
objType
]
;
parserType
=
typeof
parser
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
parser
)
;
if
(
parserType
=
=
=
"
function
"
)
{
stack
.
push
(
obj
)
;
res
=
parser
.
call
(
this
obj
stack
)
;
stack
.
pop
(
)
;
return
res
;
}
return
parserType
=
=
=
"
string
"
?
parser
:
this
.
parsers
.
error
;
}
typeOf
:
function
typeOf
(
obj
)
{
var
type
;
if
(
obj
=
=
=
null
)
{
type
=
"
null
"
;
}
else
if
(
typeof
obj
=
=
=
"
undefined
"
)
{
type
=
"
undefined
"
;
}
else
if
(
is
(
"
regexp
"
obj
)
)
{
type
=
"
regexp
"
;
}
else
if
(
is
(
"
date
"
obj
)
)
{
type
=
"
date
"
;
}
else
if
(
is
(
"
function
"
obj
)
)
{
type
=
"
function
"
;
}
else
if
(
obj
.
setInterval
!
=
=
undefined
&
&
obj
.
document
!
=
=
undefined
&
&
obj
.
nodeType
=
=
=
undefined
)
{
type
=
"
window
"
;
}
else
if
(
obj
.
nodeType
=
=
=
9
)
{
type
=
"
document
"
;
}
else
if
(
obj
.
nodeType
)
{
type
=
"
node
"
;
}
else
if
(
isArray
(
obj
)
)
{
type
=
"
array
"
;
}
else
if
(
obj
.
constructor
=
=
=
Error
.
prototype
.
constructor
)
{
type
=
"
error
"
;
}
else
{
type
=
typeof
obj
=
=
=
"
undefined
"
?
"
undefined
"
:
_typeof
(
obj
)
;
}
return
type
;
}
separator
:
function
separator
(
)
{
if
(
this
.
multiline
)
{
return
this
.
HTML
?
"
<
br
/
>
"
:
"
\
n
"
;
}
else
{
return
this
.
HTML
?
"
&
#
160
;
"
:
"
"
;
}
}
indent
:
function
indent
(
extra
)
{
if
(
!
this
.
multiline
)
{
return
"
"
;
}
var
chr
=
this
.
indentChar
;
if
(
this
.
HTML
)
{
chr
=
chr
.
replace
(
/
\
t
/
g
"
"
)
.
replace
(
/
/
g
"
&
#
160
;
"
)
;
}
return
new
Array
(
this
.
depth
+
(
extra
|
|
0
)
)
.
join
(
chr
)
;
}
up
:
function
up
(
a
)
{
this
.
depth
+
=
a
|
|
1
;
}
down
:
function
down
(
a
)
{
this
.
depth
-
=
a
|
|
1
;
}
setParser
:
function
setParser
(
name
parser
)
{
this
.
parsers
[
name
]
=
parser
;
}
quote
:
quote
literal
:
literal
join
:
join
depth
:
1
maxDepth
:
config
.
maxDepth
parsers
:
{
window
:
"
[
Window
]
"
document
:
"
[
Document
]
"
error
:
function
error
(
_error
)
{
return
"
Error
(
\
"
"
+
_error
.
message
+
"
\
"
)
"
;
}
unknown
:
"
[
Unknown
]
"
"
null
"
:
"
null
"
"
undefined
"
:
"
undefined
"
"
function
"
:
function
_function
(
fn
)
{
var
ret
=
"
function
"
name
=
"
name
"
in
fn
?
fn
.
name
:
(
reName
.
exec
(
fn
)
|
|
[
]
)
[
1
]
;
if
(
name
)
{
ret
+
=
"
"
+
name
;
}
ret
+
=
"
(
"
;
ret
=
[
ret
dump
.
parse
(
fn
"
functionArgs
"
)
"
)
{
"
]
.
join
(
"
"
)
;
return
join
(
ret
dump
.
parse
(
fn
"
functionCode
"
)
"
}
"
)
;
}
array
:
array
nodelist
:
array
"
arguments
"
:
array
object
:
function
object
(
map
stack
)
{
var
keys
key
val
i
nonEnumerableProperties
ret
=
[
]
;
if
(
dump
.
maxDepth
&
&
dump
.
depth
>
dump
.
maxDepth
)
{
return
"
[
object
Object
]
"
;
}
dump
.
up
(
)
;
keys
=
[
]
;
for
(
key
in
map
)
{
keys
.
push
(
key
)
;
}
nonEnumerableProperties
=
[
"
message
"
"
name
"
]
;
for
(
i
in
nonEnumerableProperties
)
{
key
=
nonEnumerableProperties
[
i
]
;
if
(
key
in
map
&
&
!
inArray
(
key
keys
)
)
{
keys
.
push
(
key
)
;
}
}
keys
.
sort
(
)
;
for
(
i
=
0
;
i
<
keys
.
length
;
i
+
+
)
{
key
=
keys
[
i
]
;
val
=
map
[
key
]
;
ret
.
push
(
dump
.
parse
(
key
"
key
"
)
+
"
:
"
+
dump
.
parse
(
val
undefined
stack
)
)
;
}
dump
.
down
(
)
;
return
join
(
"
{
"
ret
"
}
"
)
;
}
node
:
function
node
(
_node
)
{
var
len
i
val
open
=
dump
.
HTML
?
"
&
lt
;
"
:
"
<
"
close
=
dump
.
HTML
?
"
&
gt
;
"
:
"
>
"
tag
=
_node
.
nodeName
.
toLowerCase
(
)
ret
=
open
+
tag
attrs
=
_node
.
attributes
;
if
(
attrs
)
{
for
(
i
=
0
len
=
attrs
.
length
;
i
<
len
;
i
+
+
)
{
val
=
attrs
[
i
]
.
nodeValue
;
if
(
val
&
&
val
!
=
=
"
inherit
"
)
{
ret
+
=
"
"
+
attrs
[
i
]
.
nodeName
+
"
=
"
+
dump
.
parse
(
val
"
attribute
"
)
;
}
}
}
ret
+
=
close
;
if
(
_node
.
nodeType
=
=
=
3
|
|
_node
.
nodeType
=
=
=
4
)
{
ret
+
=
_node
.
nodeValue
;
}
return
ret
+
open
+
"
/
"
+
tag
+
close
;
}
functionArgs
:
function
functionArgs
(
fn
)
{
var
args
l
=
fn
.
length
;
if
(
!
l
)
{
return
"
"
;
}
args
=
new
Array
(
l
)
;
while
(
l
-
-
)
{
args
[
l
]
=
String
.
fromCharCode
(
97
+
l
)
;
}
return
"
"
+
args
.
join
(
"
"
)
+
"
"
;
}
key
:
quote
functionCode
:
"
[
code
]
"
attribute
:
quote
string
:
quote
date
:
quote
regexp
:
literal
number
:
literal
"
boolean
"
:
literal
symbol
:
function
symbol
(
sym
)
{
return
sym
.
toString
(
)
;
}
}
HTML
:
false
indentChar
:
"
"
multiline
:
true
}
;
return
dump
;
}
)
(
)
;
var
LISTENERS
=
Object
.
create
(
null
)
;
var
SUPPORTED_EVENTS
=
[
"
runStart
"
"
suiteStart
"
"
testStart
"
"
assertion
"
"
testEnd
"
"
suiteEnd
"
"
runEnd
"
]
;
function
emit
(
eventName
data
)
{
if
(
objectType
(
eventName
)
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
eventName
must
be
a
string
when
emitting
an
event
"
)
;
}
var
originalCallbacks
=
LISTENERS
[
eventName
]
;
var
callbacks
=
originalCallbacks
?
[
]
.
concat
(
toConsumableArray
(
originalCallbacks
)
)
:
[
]
;
for
(
var
i
=
0
;
i
<
callbacks
.
length
;
i
+
+
)
{
callbacks
[
i
]
(
data
)
;
}
}
function
on
(
eventName
callback
)
{
if
(
objectType
(
eventName
)
!
=
=
"
string
"
)
{
throw
new
TypeError
(
"
eventName
must
be
a
string
when
registering
a
listener
"
)
;
}
else
if
(
!
inArray
(
eventName
SUPPORTED_EVENTS
)
)
{
var
events
=
SUPPORTED_EVENTS
.
join
(
"
"
)
;
throw
new
Error
(
"
\
"
"
+
eventName
+
"
\
"
is
not
a
valid
event
;
must
be
one
of
:
"
+
events
+
"
.
"
)
;
}
else
if
(
objectType
(
callback
)
!
=
=
"
function
"
)
{
throw
new
TypeError
(
"
callback
must
be
a
function
when
registering
a
listener
"
)
;
}
if
(
!
LISTENERS
[
eventName
]
)
{
LISTENERS
[
eventName
]
=
[
]
;
}
if
(
!
inArray
(
callback
LISTENERS
[
eventName
]
)
)
{
LISTENERS
[
eventName
]
.
push
(
callback
)
;
}
}
function
registerLoggingCallbacks
(
obj
)
{
var
i
l
key
callbackNames
=
[
"
begin
"
"
done
"
"
log
"
"
testStart
"
"
testDone
"
"
moduleStart
"
"
moduleDone
"
]
;
function
registerLoggingCallback
(
key
)
{
var
loggingCallback
=
function
loggingCallback
(
callback
)
{
if
(
objectType
(
callback
)
!
=
=
"
function
"
)
{
throw
new
Error
(
"
QUnit
logging
methods
require
a
callback
function
as
their
first
parameters
.
"
)
;
}
config
.
callbacks
[
key
]
.
push
(
callback
)
;
}
;
return
loggingCallback
;
}
for
(
i
=
0
l
=
callbackNames
.
length
;
i
<
l
;
i
+
+
)
{
key
=
callbackNames
[
i
]
;
if
(
objectType
(
config
.
callbacks
[
key
]
)
=
=
=
"
undefined
"
)
{
config
.
callbacks
[
key
]
=
[
]
;
}
obj
[
key
]
=
registerLoggingCallback
(
key
)
;
}
}
function
runLoggingCallbacks
(
key
args
)
{
var
i
l
callbacks
;
callbacks
=
config
.
callbacks
[
key
]
;
for
(
i
=
0
l
=
callbacks
.
length
;
i
<
l
;
i
+
+
)
{
callbacks
[
i
]
(
args
)
;
}
}
var
fileName
=
(
sourceFromStacktrace
(
0
)
|
|
"
"
)
.
replace
(
/
(
:
\
d
+
)
+
\
)
?
/
"
"
)
.
replace
(
/
.
+
\
/
/
"
"
)
;
function
extractStacktrace
(
e
offset
)
{
offset
=
offset
=
=
=
undefined
?
4
:
offset
;
var
stack
include
i
;
if
(
e
&
&
e
.
stack
)
{
stack
=
e
.
stack
.
split
(
"
\
n
"
)
;
if
(
/
^
error
/
i
.
test
(
stack
[
0
]
)
)
{
stack
.
shift
(
)
;
}
if
(
fileName
)
{
include
=
[
]
;
for
(
i
=
offset
;
i
<
stack
.
length
;
i
+
+
)
{
if
(
stack
[
i
]
.
indexOf
(
fileName
)
!
=
=
-
1
)
{
break
;
}
include
.
push
(
stack
[
i
]
)
;
}
if
(
include
.
length
)
{
return
include
.
join
(
"
\
n
"
)
;
}
}
return
stack
[
offset
]
;
}
}
function
sourceFromStacktrace
(
offset
)
{
var
error
=
new
Error
(
)
;
if
(
!
error
.
stack
)
{
try
{
throw
error
;
}
catch
(
err
)
{
error
=
err
;
}
}
return
extractStacktrace
(
error
offset
)
;
}
var
priorityCount
=
0
;
var
unitSampler
=
void
0
;
function
advance
(
)
{
var
start
=
now
(
)
;
config
.
depth
=
(
config
.
depth
|
|
0
)
+
1
;
while
(
config
.
queue
.
length
&
&
!
config
.
blocking
)
{
var
elapsedTime
=
now
(
)
-
start
;
if
(
!
defined
.
setTimeout
|
|
config
.
updateRate
<
=
0
|
|
elapsedTime
<
config
.
updateRate
)
{
if
(
priorityCount
>
0
)
{
priorityCount
-
-
;
}
config
.
queue
.
shift
(
)
(
)
;
}
else
{
setTimeout
(
advance
)
;
break
;
}
}
config
.
depth
-
-
;
if
(
!
config
.
blocking
&
&
!
config
.
queue
.
length
&
&
config
.
depth
=
=
=
0
)
{
done
(
)
;
}
}
function
addToQueueImmediate
(
callback
)
{
if
(
objectType
(
callback
)
=
=
=
"
array
"
)
{
while
(
callback
.
length
)
{
addToQueueImmediate
(
callback
.
pop
(
)
)
;
}
return
;
}
config
.
queue
.
unshift
(
callback
)
;
priorityCount
+
+
;
}
function
addToQueue
(
callback
prioritize
seed
)
{
if
(
prioritize
)
{
config
.
queue
.
splice
(
priorityCount
+
+
0
callback
)
;
}
else
if
(
seed
)
{
if
(
!
unitSampler
)
{
unitSampler
=
unitSamplerGenerator
(
seed
)
;
}
var
index
=
Math
.
floor
(
unitSampler
(
)
*
(
config
.
queue
.
length
-
priorityCount
+
1
)
)
;
config
.
queue
.
splice
(
priorityCount
+
index
0
callback
)
;
}
else
{
config
.
queue
.
push
(
callback
)
;
}
}
function
unitSamplerGenerator
(
seed
)
{
var
sample
=
parseInt
(
generateHash
(
seed
)
16
)
|
|
-
1
;
return
function
(
)
{
sample
^
=
sample
<
<
13
;
sample
^
=
sample
>
>
>
17
;
sample
^
=
sample
<
<
5
;
if
(
sample
<
0
)
{
sample
+
=
0x100000000
;
}
return
sample
/
0x100000000
;
}
;
}
function
done
(
)
{
var
storage
=
config
.
storage
;
ProcessingQueue
.
finished
=
true
;
var
runtime
=
now
(
)
-
config
.
started
;
var
passed
=
config
.
stats
.
all
-
config
.
stats
.
bad
;
emit
(
"
runEnd
"
globalSuite
.
end
(
true
)
)
;
runLoggingCallbacks
(
"
done
"
{
passed
:
passed
failed
:
config
.
stats
.
bad
total
:
config
.
stats
.
all
runtime
:
runtime
}
)
;
if
(
storage
&
&
config
.
stats
.
bad
=
=
=
0
)
{
for
(
var
i
=
storage
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
key
=
storage
.
key
(
i
)
;
if
(
key
.
indexOf
(
"
qunit
-
test
-
"
)
=
=
=
0
)
{
storage
.
removeItem
(
key
)
;
}
}
}
}
var
ProcessingQueue
=
{
finished
:
false
add
:
addToQueue
addImmediate
:
addToQueueImmediate
advance
:
advance
}
;
var
TestReport
=
function
(
)
{
function
TestReport
(
name
suite
options
)
{
classCallCheck
(
this
TestReport
)
;
this
.
name
=
name
;
this
.
suiteName
=
suite
.
name
;
this
.
fullName
=
suite
.
fullName
.
concat
(
name
)
;
this
.
runtime
=
0
;
this
.
assertions
=
[
]
;
this
.
skipped
=
!
!
options
.
skip
;
this
.
todo
=
!
!
options
.
todo
;
this
.
valid
=
options
.
valid
;
this
.
_startTime
=
0
;
this
.
_endTime
=
0
;
suite
.
pushTest
(
this
)
;
}
createClass
(
TestReport
[
{
key
:
"
start
"
value
:
function
start
(
recordTime
)
{
if
(
recordTime
)
{
this
.
_startTime
=
Date
.
now
(
)
;
}
return
{
name
:
this
.
name
suiteName
:
this
.
suiteName
fullName
:
this
.
fullName
.
slice
(
)
}
;
}
}
{
key
:
"
end
"
value
:
function
end
(
recordTime
)
{
if
(
recordTime
)
{
this
.
_endTime
=
Date
.
now
(
)
;
}
return
extend
(
this
.
start
(
)
{
runtime
:
this
.
getRuntime
(
)
status
:
this
.
getStatus
(
)
errors
:
this
.
getFailedAssertions
(
)
assertions
:
this
.
getAssertions
(
)
}
)
;
}
}
{
key
:
"
pushAssertion
"
value
:
function
pushAssertion
(
assertion
)
{
this
.
assertions
.
push
(
assertion
)
;
}
}
{
key
:
"
getRuntime
"
value
:
function
getRuntime
(
)
{
return
this
.
_endTime
-
this
.
_startTime
;
}
}
{
key
:
"
getStatus
"
value
:
function
getStatus
(
)
{
if
(
this
.
skipped
)
{
return
"
skipped
"
;
}
var
testPassed
=
this
.
getFailedAssertions
(
)
.
length
>
0
?
this
.
todo
:
!
this
.
todo
;
if
(
!
testPassed
)
{
return
"
failed
"
;
}
else
if
(
this
.
todo
)
{
return
"
todo
"
;
}
else
{
return
"
passed
"
;
}
}
}
{
key
:
"
getFailedAssertions
"
value
:
function
getFailedAssertions
(
)
{
return
this
.
assertions
.
filter
(
function
(
assertion
)
{
return
!
assertion
.
passed
;
}
)
;
}
}
{
key
:
"
getAssertions
"
value
:
function
getAssertions
(
)
{
return
this
.
assertions
.
slice
(
)
;
}
}
{
key
:
"
slimAssertions
"
value
:
function
slimAssertions
(
)
{
this
.
assertions
=
this
.
assertions
.
map
(
function
(
assertion
)
{
delete
assertion
.
actual
;
delete
assertion
.
expected
;
return
assertion
;
}
)
;
}
}
]
)
;
return
TestReport
;
}
(
)
;
var
focused
1
=
false
;
function
Test
(
settings
)
{
var
i
l
;
+
+
Test
.
count
;
this
.
expected
=
null
;
this
.
assertions
=
[
]
;
this
.
semaphore
=
0
;
this
.
module
=
config
.
currentModule
;
this
.
stack
=
sourceFromStacktrace
(
3
)
;
this
.
steps
=
[
]
;
this
.
timeout
=
undefined
;
if
(
this
.
module
.
skip
)
{
settings
.
skip
=
true
;
settings
.
todo
=
false
;
}
else
if
(
this
.
module
.
todo
&
&
!
settings
.
skip
)
{
settings
.
todo
=
true
;
}
extend
(
this
settings
)
;
this
.
testReport
=
new
TestReport
(
settings
.
testName
this
.
module
.
suiteReport
{
todo
:
settings
.
todo
skip
:
settings
.
skip
valid
:
this
.
valid
(
)
}
)
;
for
(
i
=
0
l
=
this
.
module
.
tests
;
i
<
l
.
length
;
i
+
+
)
{
if
(
this
.
module
.
tests
[
i
]
.
name
=
=
=
this
.
testName
)
{
this
.
testName
+
=
"
"
;
}
}
this
.
testId
=
generateHash
(
this
.
module
.
name
this
.
testName
)
;
this
.
module
.
tests
.
push
(
{
name
:
this
.
testName
testId
:
this
.
testId
skip
:
!
!
settings
.
skip
}
)
;
if
(
settings
.
skip
)
{
this
.
callback
=
function
(
)
{
}
;
this
.
async
=
false
;
this
.
expected
=
0
;
}
else
{
if
(
typeof
this
.
callback
!
=
=
"
function
"
)
{
var
method
=
this
.
todo
?
"
todo
"
:
"
test
"
;
throw
new
TypeError
(
"
You
must
provide
a
function
as
a
test
callback
to
QUnit
.
"
+
method
+
"
(
\
"
"
+
settings
.
testName
+
"
\
"
)
"
)
;
}
this
.
assert
=
new
Assert
(
this
)
;
}
}
Test
.
count
=
0
;
function
getNotStartedModules
(
startModule
)
{
var
module
=
startModule
modules
=
[
]
;
while
(
module
&
&
module
.
testsRun
=
=
=
0
)
{
modules
.
push
(
module
)
;
module
=
module
.
parentModule
;
}
return
modules
;
}
Test
.
prototype
=
{
before
:
function
before
(
)
{
var
i
startModule
module
=
this
.
module
notStartedModules
=
getNotStartedModules
(
module
)
;
for
(
i
=
notStartedModules
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
startModule
=
notStartedModules
[
i
]
;
startModule
.
stats
=
{
all
:
0
bad
:
0
started
:
now
(
)
}
;
emit
(
"
suiteStart
"
startModule
.
suiteReport
.
start
(
true
)
)
;
runLoggingCallbacks
(
"
moduleStart
"
{
name
:
startModule
.
name
tests
:
startModule
.
tests
}
)
;
}
config
.
current
=
this
;
this
.
testEnvironment
=
extend
(
{
}
module
.
testEnvironment
)
;
this
.
started
=
now
(
)
;
emit
(
"
testStart
"
this
.
testReport
.
start
(
true
)
)
;
runLoggingCallbacks
(
"
testStart
"
{
name
:
this
.
testName
module
:
module
.
name
testId
:
this
.
testId
previousFailure
:
this
.
previousFailure
}
)
;
if
(
!
config
.
pollution
)
{
saveGlobal
(
)
;
}
}
run
:
function
run
(
)
{
var
promise
;
config
.
current
=
this
;
this
.
callbackStarted
=
now
(
)
;
if
(
config
.
notrycatch
)
{
runTest
(
this
)
;
return
;
}
try
{
runTest
(
this
)
;
}
catch
(
e
)
{
this
.
pushFailure
(
"
Died
on
test
#
"
+
(
this
.
assertions
.
length
+
1
)
+
"
"
+
this
.
stack
+
"
:
"
+
(
e
.
message
|
|
e
)
extractStacktrace
(
e
0
)
)
;
saveGlobal
(
)
;
if
(
config
.
blocking
)
{
internalRecover
(
this
)
;
}
}
function
runTest
(
test
)
{
promise
=
test
.
callback
.
call
(
test
.
testEnvironment
test
.
assert
)
;
test
.
resolvePromise
(
promise
)
;
if
(
test
.
timeout
=
=
=
0
&
&
test
.
semaphore
!
=
=
0
)
{
pushFailure
(
"
Test
did
not
finish
synchronously
even
though
assert
.
timeout
(
0
)
was
used
.
"
sourceFromStacktrace
(
2
)
)
;
}
}
}
after
:
function
after
(
)
{
checkPollution
(
)
;
}
queueHook
:
function
queueHook
(
hook
hookName
hookOwner
)
{
var
_this
=
this
;
var
callHook
=
function
callHook
(
)
{
var
promise
=
hook
.
call
(
_this
.
testEnvironment
_this
.
assert
)
;
_this
.
resolvePromise
(
promise
hookName
)
;
}
;
var
runHook
=
function
runHook
(
)
{
if
(
hookName
=
=
=
"
before
"
)
{
if
(
hookOwner
.
unskippedTestsRun
!
=
=
0
)
{
return
;
}
_this
.
preserveEnvironment
=
true
;
}
if
(
hookName
=
=
=
"
after
"
&
&
hookOwner
.
unskippedTestsRun
!
=
=
numberOfUnskippedTests
(
hookOwner
)
-
1
&
&
config
.
queue
.
length
>
2
)
{
return
;
}
config
.
current
=
_this
;
if
(
config
.
notrycatch
)
{
callHook
(
)
;
return
;
}
try
{
callHook
(
)
;
}
catch
(
error
)
{
_this
.
pushFailure
(
hookName
+
"
failed
on
"
+
_this
.
testName
+
"
:
"
+
(
error
.
message
|
|
error
)
extractStacktrace
(
error
0
)
)
;
}
}
;
return
runHook
;
}
hooks
:
function
hooks
(
handler
)
{
var
hooks
=
[
]
;
function
processHooks
(
test
module
)
{
if
(
module
.
parentModule
)
{
processHooks
(
test
module
.
parentModule
)
;
}
if
(
module
.
hooks
[
handler
]
.
length
)
{
for
(
var
i
=
0
;
i
<
module
.
hooks
[
handler
]
.
length
;
i
+
+
)
{
hooks
.
push
(
test
.
queueHook
(
module
.
hooks
[
handler
]
[
i
]
handler
module
)
)
;
}
}
}
if
(
!
this
.
skip
)
{
processHooks
(
this
this
.
module
)
;
}
return
hooks
;
}
finish
:
function
finish
(
)
{
config
.
current
=
this
;
if
(
this
.
steps
.
length
)
{
var
stepsList
=
this
.
steps
.
join
(
"
"
)
;
this
.
pushFailure
(
"
Expected
assert
.
verifySteps
(
)
to
be
called
before
end
of
test
"
+
(
"
after
using
assert
.
step
(
)
.
Unverified
steps
:
"
+
stepsList
)
this
.
stack
)
;
}
if
(
config
.
requireExpects
&
&
this
.
expected
=
=
=
null
)
{
this
.
pushFailure
(
"
Expected
number
of
assertions
to
be
defined
but
expect
(
)
was
"
+
"
not
called
.
"
this
.
stack
)
;
}
else
if
(
this
.
expected
!
=
=
null
&
&
this
.
expected
!
=
=
this
.
assertions
.
length
)
{
this
.
pushFailure
(
"
Expected
"
+
this
.
expected
+
"
assertions
but
"
+
this
.
assertions
.
length
+
"
were
run
"
this
.
stack
)
;
}
else
if
(
this
.
expected
=
=
=
null
&
&
!
this
.
assertions
.
length
)
{
this
.
pushFailure
(
"
Expected
at
least
one
assertion
but
none
were
run
-
call
"
+
"
expect
(
0
)
to
accept
zero
assertions
.
"
this
.
stack
)
;
}
var
i
module
=
this
.
module
moduleName
=
module
.
name
testName
=
this
.
testName
skipped
=
!
!
this
.
skip
todo
=
!
!
this
.
todo
bad
=
0
storage
=
config
.
storage
;
this
.
runtime
=
now
(
)
-
this
.
started
;
config
.
stats
.
all
+
=
this
.
assertions
.
length
;
module
.
stats
.
all
+
=
this
.
assertions
.
length
;
for
(
i
=
0
;
i
<
this
.
assertions
.
length
;
i
+
+
)
{
if
(
!
this
.
assertions
[
i
]
.
result
)
{
bad
+
+
;
config
.
stats
.
bad
+
+
;
module
.
stats
.
bad
+
+
;
}
}
notifyTestsRan
(
module
skipped
)
;
if
(
storage
)
{
if
(
bad
)
{
storage
.
setItem
(
"
qunit
-
test
-
"
+
moduleName
+
"
-
"
+
testName
bad
)
;
}
else
{
storage
.
removeItem
(
"
qunit
-
test
-
"
+
moduleName
+
"
-
"
+
testName
)
;
}
}
emit
(
"
testEnd
"
this
.
testReport
.
end
(
true
)
)
;
this
.
testReport
.
slimAssertions
(
)
;
runLoggingCallbacks
(
"
testDone
"
{
name
:
testName
module
:
moduleName
skipped
:
skipped
todo
:
todo
failed
:
bad
passed
:
this
.
assertions
.
length
-
bad
total
:
this
.
assertions
.
length
runtime
:
skipped
?
0
:
this
.
runtime
assertions
:
this
.
assertions
testId
:
this
.
testId
source
:
this
.
stack
}
)
;
if
(
module
.
testsRun
=
=
=
numberOfTests
(
module
)
)
{
logSuiteEnd
(
module
)
;
var
parent
=
module
.
parentModule
;
while
(
parent
&
&
parent
.
testsRun
=
=
=
numberOfTests
(
parent
)
)
{
logSuiteEnd
(
parent
)
;
parent
=
parent
.
parentModule
;
}
}
config
.
current
=
undefined
;
function
logSuiteEnd
(
module
)
{
emit
(
"
suiteEnd
"
module
.
suiteReport
.
end
(
true
)
)
;
runLoggingCallbacks
(
"
moduleDone
"
{
name
:
module
.
name
tests
:
module
.
tests
failed
:
module
.
stats
.
bad
passed
:
module
.
stats
.
all
-
module
.
stats
.
bad
total
:
module
.
stats
.
all
runtime
:
now
(
)
-
module
.
stats
.
started
}
)
;
}
}
preserveTestEnvironment
:
function
preserveTestEnvironment
(
)
{
if
(
this
.
preserveEnvironment
)
{
this
.
module
.
testEnvironment
=
this
.
testEnvironment
;
this
.
testEnvironment
=
extend
(
{
}
this
.
module
.
testEnvironment
)
;
}
}
queue
:
function
queue
(
)
{
var
test
=
this
;
if
(
!
this
.
valid
(
)
)
{
return
;
}
function
runTest
(
)
{
ProcessingQueue
.
addImmediate
(
[
function
(
)
{
test
.
before
(
)
;
}
test
.
hooks
(
"
before
"
)
function
(
)
{
test
.
preserveTestEnvironment
(
)
;
}
test
.
hooks
(
"
beforeEach
"
)
function
(
)
{
test
.
run
(
)
;
}
test
.
hooks
(
"
afterEach
"
)
.
reverse
(
)
test
.
hooks
(
"
after
"
)
.
reverse
(
)
function
(
)
{
test
.
after
(
)
;
}
function
(
)
{
test
.
finish
(
)
;
}
]
)
;
}
var
previousFailCount
=
config
.
storage
&
&
+
config
.
storage
.
getItem
(
"
qunit
-
test
-
"
+
this
.
module
.
name
+
"
-
"
+
this
.
testName
)
;
var
prioritize
=
config
.
reorder
&
&
!
!
previousFailCount
;
this
.
previousFailure
=
!
!
previousFailCount
;
ProcessingQueue
.
add
(
runTest
prioritize
config
.
seed
)
;
if
(
ProcessingQueue
.
finished
)
{
ProcessingQueue
.
advance
(
)
;
}
}
pushResult
:
function
pushResult
(
resultInfo
)
{
if
(
this
!
=
=
config
.
current
)
{
throw
new
Error
(
"
Assertion
occurred
after
test
had
finished
.
"
)
;
}
var
source
details
=
{
module
:
this
.
module
.
name
name
:
this
.
testName
result
:
resultInfo
.
result
message
:
resultInfo
.
message
actual
:
resultInfo
.
actual
testId
:
this
.
testId
negative
:
resultInfo
.
negative
|
|
false
runtime
:
now
(
)
-
this
.
started
todo
:
!
!
this
.
todo
}
;
if
(
hasOwn
.
call
(
resultInfo
"
expected
"
)
)
{
details
.
expected
=
resultInfo
.
expected
;
}
if
(
!
resultInfo
.
result
)
{
source
=
resultInfo
.
source
|
|
sourceFromStacktrace
(
)
;
if
(
source
)
{
details
.
source
=
source
;
}
}
this
.
logAssertion
(
details
)
;
this
.
assertions
.
push
(
{
result
:
!
!
resultInfo
.
result
message
:
resultInfo
.
message
}
)
;
}
pushFailure
:
function
pushFailure
(
message
source
actual
)
{
if
(
!
(
this
instanceof
Test
)
)
{
throw
new
Error
(
"
pushFailure
(
)
assertion
outside
test
context
was
"
+
sourceFromStacktrace
(
2
)
)
;
}
this
.
pushResult
(
{
result
:
false
message
:
message
|
|
"
error
"
actual
:
actual
|
|
null
source
:
source
}
)
;
}
logAssertion
:
function
logAssertion
(
details
)
{
runLoggingCallbacks
(
"
log
"
details
)
;
var
assertion
=
{
passed
:
details
.
result
actual
:
details
.
actual
expected
:
details
.
expected
message
:
details
.
message
stack
:
details
.
source
todo
:
details
.
todo
}
;
this
.
testReport
.
pushAssertion
(
assertion
)
;
emit
(
"
assertion
"
assertion
)
;
}
resolvePromise
:
function
resolvePromise
(
promise
phase
)
{
var
then
resume
message
test
=
this
;
if
(
promise
!
=
null
)
{
then
=
promise
.
then
;
if
(
objectType
(
then
)
=
=
=
"
function
"
)
{
resume
=
internalStop
(
test
)
;
if
(
config
.
notrycatch
)
{
then
.
call
(
promise
function
(
)
{
resume
(
)
;
}
)
;
}
else
{
then
.
call
(
promise
function
(
)
{
resume
(
)
;
}
function
(
error
)
{
message
=
"
Promise
rejected
"
+
(
!
phase
?
"
during
"
:
phase
.
replace
(
/
Each
/
"
"
)
)
+
"
\
"
"
+
test
.
testName
+
"
\
"
:
"
+
(
error
&
&
error
.
message
|
|
error
)
;
test
.
pushFailure
(
message
extractStacktrace
(
error
0
)
)
;
saveGlobal
(
)
;
internalRecover
(
test
)
;
}
)
;
}
}
}
}
valid
:
function
valid
(
)
{
var
filter
=
config
.
filter
regexFilter
=
/
^
(
!
?
)
\
/
(
[
\
w
\
W
]
*
)
\
/
(
i
?
)
/
.
exec
(
filter
)
module
=
config
.
module
&
&
config
.
module
.
toLowerCase
(
)
fullName
=
this
.
module
.
name
+
"
:
"
+
this
.
testName
;
function
moduleChainNameMatch
(
testModule
)
{
var
testModuleName
=
testModule
.
name
?
testModule
.
name
.
toLowerCase
(
)
:
null
;
if
(
testModuleName
=
=
=
module
)
{
return
true
;
}
else
if
(
testModule
.
parentModule
)
{
return
moduleChainNameMatch
(
testModule
.
parentModule
)
;
}
else
{
return
false
;
}
}
function
moduleChainIdMatch
(
testModule
)
{
return
inArray
(
testModule
.
moduleId
config
.
moduleId
)
|
|
testModule
.
parentModule
&
&
moduleChainIdMatch
(
testModule
.
parentModule
)
;
}
if
(
this
.
callback
&
&
this
.
callback
.
validTest
)
{
return
true
;
}
if
(
config
.
moduleId
&
&
config
.
moduleId
.
length
>
0
&
&
!
moduleChainIdMatch
(
this
.
module
)
)
{
return
false
;
}
if
(
config
.
testId
&
&
config
.
testId
.
length
>
0
&
&
!
inArray
(
this
.
testId
config
.
testId
)
)
{
return
false
;
}
if
(
module
&
&
!
moduleChainNameMatch
(
this
.
module
)
)
{
return
false
;
}
if
(
!
filter
)
{
return
true
;
}
return
regexFilter
?
this
.
regexFilter
(
!
!
regexFilter
[
1
]
regexFilter
[
2
]
regexFilter
[
3
]
fullName
)
:
this
.
stringFilter
(
filter
fullName
)
;
}
regexFilter
:
function
regexFilter
(
exclude
pattern
flags
fullName
)
{
var
regex
=
new
RegExp
(
pattern
flags
)
;
var
match
=
regex
.
test
(
fullName
)
;
return
match
!
=
=
exclude
;
}
stringFilter
:
function
stringFilter
(
filter
fullName
)
{
filter
=
filter
.
toLowerCase
(
)
;
fullName
=
fullName
.
toLowerCase
(
)
;
var
include
=
filter
.
charAt
(
0
)
!
=
=
"
!
"
;
if
(
!
include
)
{
filter
=
filter
.
slice
(
1
)
;
}
if
(
fullName
.
indexOf
(
filter
)
!
=
=
-
1
)
{
return
include
;
}
return
!
include
;
}
}
;
function
pushFailure
(
)
{
if
(
!
config
.
current
)
{
throw
new
Error
(
"
pushFailure
(
)
assertion
outside
test
context
in
"
+
sourceFromStacktrace
(
2
)
)
;
}
var
currentTest
=
config
.
current
;
return
currentTest
.
pushFailure
.
apply
(
currentTest
arguments
)
;
}
function
saveGlobal
(
)
{
config
.
pollution
=
[
]
;
if
(
config
.
noglobals
)
{
for
(
var
key
in
global
1
)
{
if
(
hasOwn
.
call
(
global
1
key
)
)
{
if
(
/
^
qunit
-
test
-
output
/
.
test
(
key
)
)
{
continue
;
}
config
.
pollution
.
push
(
key
)
;
}
}
}
}
function
checkPollution
(
)
{
var
newGlobals
deletedGlobals
old
=
config
.
pollution
;
saveGlobal
(
)
;
newGlobals
=
diff
(
config
.
pollution
old
)
;
if
(
newGlobals
.
length
>
0
)
{
pushFailure
(
"
Introduced
global
variable
(
s
)
:
"
+
newGlobals
.
join
(
"
"
)
)
;
}
deletedGlobals
=
diff
(
old
config
.
pollution
)
;
if
(
deletedGlobals
.
length
>
0
)
{
pushFailure
(
"
Deleted
global
variable
(
s
)
:
"
+
deletedGlobals
.
join
(
"
"
)
)
;
}
}
function
test
(
testName
callback
)
{
if
(
focused
1
)
{
return
;
}
var
newTest
=
new
Test
(
{
testName
:
testName
callback
:
callback
}
)
;
newTest
.
queue
(
)
;
}
function
todo
(
testName
callback
)
{
if
(
focused
1
)
{
return
;
}
var
newTest
=
new
Test
(
{
testName
:
testName
callback
:
callback
todo
:
true
}
)
;
newTest
.
queue
(
)
;
}
function
skip
(
testName
)
{
if
(
focused
1
)
{
return
;
}
var
test
=
new
Test
(
{
testName
:
testName
skip
:
true
}
)
;
test
.
queue
(
)
;
}
function
only
(
testName
callback
)
{
if
(
focused
1
)
{
return
;
}
config
.
queue
.
length
=
0
;
focused
1
=
true
;
var
newTest
=
new
Test
(
{
testName
:
testName
callback
:
callback
}
)
;
newTest
.
queue
(
)
;
}
function
internalStop
(
test
)
{
test
.
semaphore
+
=
1
;
config
.
blocking
=
true
;
if
(
defined
.
setTimeout
)
{
var
timeoutDuration
=
void
0
;
if
(
typeof
test
.
timeout
=
=
=
"
number
"
)
{
timeoutDuration
=
test
.
timeout
;
}
else
if
(
typeof
config
.
testTimeout
=
=
=
"
number
"
)
{
timeoutDuration
=
config
.
testTimeout
;
}
if
(
typeof
timeoutDuration
=
=
=
"
number
"
&
&
timeoutDuration
>
0
)
{
clearTimeout
(
config
.
timeout
)
;
config
.
timeout
=
setTimeout
(
function
(
)
{
pushFailure
(
"
Test
took
longer
than
"
+
timeoutDuration
+
"
ms
;
test
timed
out
.
"
sourceFromStacktrace
(
2
)
)
;
internalRecover
(
test
)
;
}
timeoutDuration
)
;
}
}
var
released
=
false
;
return
function
resume
(
)
{
if
(
released
)
{
return
;
}
released
=
true
;
test
.
semaphore
-
=
1
;
internalStart
(
test
)
;
}
;
}
function
internalRecover
(
test
)
{
test
.
semaphore
=
0
;
internalStart
(
test
)
;
}
function
internalStart
(
test
)
{
if
(
isNaN
(
test
.
semaphore
)
)
{
test
.
semaphore
=
0
;
pushFailure
(
"
Invalid
value
on
test
.
semaphore
"
sourceFromStacktrace
(
2
)
)
;
return
;
}
if
(
test
.
semaphore
>
0
)
{
return
;
}
if
(
test
.
semaphore
<
0
)
{
test
.
semaphore
=
0
;
pushFailure
(
"
Tried
to
restart
test
while
already
started
(
test
'
s
semaphore
was
0
already
)
"
sourceFromStacktrace
(
2
)
)
;
return
;
}
if
(
defined
.
setTimeout
)
{
if
(
config
.
timeout
)
{
clearTimeout
(
config
.
timeout
)
;
}
config
.
timeout
=
setTimeout
(
function
(
)
{
if
(
test
.
semaphore
>
0
)
{
return
;
}
if
(
config
.
timeout
)
{
clearTimeout
(
config
.
timeout
)
;
}
begin
(
)
;
}
)
;
}
else
{
begin
(
)
;
}
}
function
collectTests
(
module
)
{
var
tests
=
[
]
.
concat
(
module
.
tests
)
;
var
modules
=
[
]
.
concat
(
toConsumableArray
(
module
.
childModules
)
)
;
while
(
modules
.
length
)
{
var
nextModule
=
modules
.
shift
(
)
;
tests
.
push
.
apply
(
tests
nextModule
.
tests
)
;
modules
.
push
.
apply
(
modules
toConsumableArray
(
nextModule
.
childModules
)
)
;
}
return
tests
;
}
function
numberOfTests
(
module
)
{
return
collectTests
(
module
)
.
length
;
}
function
numberOfUnskippedTests
(
module
)
{
return
collectTests
(
module
)
.
filter
(
function
(
test
)
{
return
!
test
.
skip
;
}
)
.
length
;
}
function
notifyTestsRan
(
module
skipped
)
{
module
.
testsRun
+
+
;
if
(
!
skipped
)
{
module
.
unskippedTestsRun
+
+
;
}
while
(
module
=
module
.
parentModule
)
{
module
.
testsRun
+
+
;
if
(
!
skipped
)
{
module
.
unskippedTestsRun
+
+
;
}
}
}
function
consoleProxy
(
method
)
{
return
function
(
)
{
if
(
console
)
{
console
[
method
]
.
apply
(
console
arguments
)
;
}
}
;
}
var
Logger
=
{
warn
:
consoleProxy
(
"
warn
"
)
}
;
var
Assert
=
function
(
)
{
function
Assert
(
testContext
)
{
classCallCheck
(
this
Assert
)
;
this
.
test
=
testContext
;
}
createClass
(
Assert
[
{
key
:
"
timeout
"
value
:
function
timeout
(
duration
)
{
if
(
typeof
duration
!
=
=
"
number
"
)
{
throw
new
Error
(
"
You
must
pass
a
number
as
the
duration
to
assert
.
timeout
"
)
;
}
this
.
test
.
timeout
=
duration
;
}
}
{
key
:
"
step
"
value
:
function
step
(
message
)
{
var
result
=
!
!
message
;
this
.
test
.
steps
.
push
(
message
)
;
return
this
.
pushResult
(
{
result
:
result
message
:
message
|
|
"
You
must
provide
a
message
to
assert
.
step
"
}
)
;
}
}
{
key
:
"
verifySteps
"
value
:
function
verifySteps
(
steps
message
)
{
this
.
deepEqual
(
this
.
test
.
steps
steps
message
)
;
this
.
test
.
steps
.
length
=
0
;
}
}
{
key
:
"
expect
"
value
:
function
expect
(
asserts
)
{
if
(
arguments
.
length
=
=
=
1
)
{
this
.
test
.
expected
=
asserts
;
}
else
{
return
this
.
test
.
expected
;
}
}
}
{
key
:
"
async
"
value
:
function
async
(
count
)
{
var
test
1
=
this
.
test
;
var
popped
=
false
acceptCallCount
=
count
;
if
(
typeof
acceptCallCount
=
=
=
"
undefined
"
)
{
acceptCallCount
=
1
;
}
var
resume
=
internalStop
(
test
1
)
;
return
function
done
(
)
{
if
(
config
.
current
!
=
=
test
1
)
{
throw
Error
(
"
assert
.
async
callback
called
after
test
finished
.
"
)
;
}
if
(
popped
)
{
test
1
.
pushFailure
(
"
Too
many
calls
to
the
assert
.
async
callback
"
sourceFromStacktrace
(
2
)
)
;
return
;
}
acceptCallCount
-
=
1
;
if
(
acceptCallCount
>
0
)
{
return
;
}
popped
=
true
;
resume
(
)
;
}
;
}
}
{
key
:
"
push
"
value
:
function
push
(
result
actual
expected
message
negative
)
{
Logger
.
warn
(
"
assert
.
push
is
deprecated
and
will
be
removed
in
QUnit
3
.
0
.
"
+
"
Please
use
assert
.
pushResult
instead
(
https
:
/
/
api
.
qunitjs
.
com
/
assert
/
pushResult
)
.
"
)
;
var
currentAssert
=
this
instanceof
Assert
?
this
:
config
.
current
.
assert
;
return
currentAssert
.
pushResult
(
{
result
:
result
actual
:
actual
expected
:
expected
message
:
message
negative
:
negative
}
)
;
}
}
{
key
:
"
pushResult
"
value
:
function
pushResult
(
resultInfo
)
{
var
assert
=
this
;
var
currentTest
=
assert
instanceof
Assert
&
&
assert
.
test
|
|
config
.
current
;
if
(
!
currentTest
)
{
throw
new
Error
(
"
assertion
outside
test
context
in
"
+
sourceFromStacktrace
(
2
)
)
;
}
if
(
!
(
assert
instanceof
Assert
)
)
{
assert
=
currentTest
.
assert
;
}
return
assert
.
test
.
pushResult
(
resultInfo
)
;
}
}
{
key
:
"
ok
"
value
:
function
ok
(
result
message
)
{
if
(
!
message
)
{
message
=
result
?
"
okay
"
:
"
failed
expected
argument
to
be
truthy
was
:
"
+
dump
.
parse
(
result
)
;
}
this
.
pushResult
(
{
result
:
!
!
result
actual
:
result
expected
:
true
message
:
message
}
)
;
}
}
{
key
:
"
notOk
"
value
:
function
notOk
(
result
message
)
{
if
(
!
message
)
{
message
=
!
result
?
"
okay
"
:
"
failed
expected
argument
to
be
falsy
was
:
"
+
dump
.
parse
(
result
)
;
}
this
.
pushResult
(
{
result
:
!
result
actual
:
result
expected
:
false
message
:
message
}
)
;
}
}
{
key
:
"
equal
"
value
:
function
equal
(
actual
expected
message
)
{
var
result
=
expected
=
=
actual
;
this
.
pushResult
(
{
result
:
result
actual
:
actual
expected
:
expected
message
:
message
}
)
;
}
}
{
key
:
"
notEqual
"
value
:
function
notEqual
(
actual
expected
message
)
{
var
result
=
expected
!
=
actual
;
this
.
pushResult
(
{
result
:
result
actual
:
actual
expected
:
expected
message
:
message
negative
:
true
}
)
;
}
}
{
key
:
"
propEqual
"
value
:
function
propEqual
(
actual
expected
message
)
{
actual
=
objectValues
(
actual
)
;
expected
=
objectValues
(
expected
)
;
this
.
pushResult
(
{
result
:
equiv
(
actual
expected
)
actual
:
actual
expected
:
expected
message
:
message
}
)
;
}
}
{
key
:
"
notPropEqual
"
value
:
function
notPropEqual
(
actual
expected
message
)
{
actual
=
objectValues
(
actual
)
;
expected
=
objectValues
(
expected
)
;
this
.
pushResult
(
{
result
:
!
equiv
(
actual
expected
)
actual
:
actual
expected
:
expected
message
:
message
negative
:
true
}
)
;
}
}
{
key
:
"
deepEqual
"
value
:
function
deepEqual
(
actual
expected
message
)
{
this
.
pushResult
(
{
result
:
equiv
(
actual
expected
)
actual
:
actual
expected
:
expected
message
:
message
}
)
;
}
}
{
key
:
"
notDeepEqual
"
value
:
function
notDeepEqual
(
actual
expected
message
)
{
this
.
pushResult
(
{
result
:
!
equiv
(
actual
expected
)
actual
:
actual
expected
:
expected
message
:
message
negative
:
true
}
)
;
}
}
{
key
:
"
strictEqual
"
value
:
function
strictEqual
(
actual
expected
message
)
{
this
.
pushResult
(
{
result
:
expected
=
=
=
actual
actual
:
actual
expected
:
expected
message
:
message
}
)
;
}
}
{
key
:
"
notStrictEqual
"
value
:
function
notStrictEqual
(
actual
expected
message
)
{
this
.
pushResult
(
{
result
:
expected
!
=
=
actual
actual
:
actual
expected
:
expected
message
:
message
negative
:
true
}
)
;
}
}
{
key
:
"
throws
"
value
:
function
throws
(
block
expected
message
)
{
var
actual
=
void
0
result
=
false
;
var
currentTest
=
this
instanceof
Assert
&
&
this
.
test
|
|
config
.
current
;
if
(
objectType
(
expected
)
=
=
=
"
string
"
)
{
if
(
message
=
=
null
)
{
message
=
expected
;
expected
=
null
;
}
else
{
throw
new
Error
(
"
throws
/
raises
does
not
accept
a
string
value
for
the
expected
argument
.
\
n
"
+
"
Use
a
non
-
string
object
value
(
e
.
g
.
regExp
)
instead
if
it
'
s
necessary
.
"
)
;
}
}
currentTest
.
ignoreGlobalErrors
=
true
;
try
{
block
.
call
(
currentTest
.
testEnvironment
)
;
}
catch
(
e
)
{
actual
=
e
;
}
currentTest
.
ignoreGlobalErrors
=
false
;
if
(
actual
)
{
var
expectedType
=
objectType
(
expected
)
;
if
(
!
expected
)
{
result
=
true
;
expected
=
null
;
}
else
if
(
expectedType
=
=
=
"
regexp
"
)
{
result
=
expected
.
test
(
errorString
(
actual
)
)
;
}
else
if
(
expectedType
=
=
=
"
function
"
&
&
actual
instanceof
expected
)
{
result
=
true
;
}
else
if
(
expectedType
=
=
=
"
object
"
)
{
result
=
actual
instanceof
expected
.
constructor
&
&
actual
.
name
=
=
=
expected
.
name
&
&
actual
.
message
=
=
=
expected
.
message
;
}
else
if
(
expectedType
=
=
=
"
function
"
&
&
expected
.
call
(
{
}
actual
)
=
=
=
true
)
{
expected
=
null
;
result
=
true
;
}
}
currentTest
.
assert
.
pushResult
(
{
result
:
result
actual
:
actual
expected
:
expected
message
:
message
}
)
;
}
}
{
key
:
"
rejects
"
value
:
function
rejects
(
promise
expected
message
)
{
var
result
=
false
;
var
currentTest
=
this
instanceof
Assert
&
&
this
.
test
|
|
config
.
current
;
if
(
objectType
(
expected
)
=
=
=
"
string
"
)
{
if
(
message
=
=
=
undefined
)
{
message
=
expected
;
expected
=
undefined
;
}
else
{
message
=
"
assert
.
rejects
does
not
accept
a
string
value
for
the
expected
"
+
"
argument
.
\
nUse
a
non
-
string
object
value
(
e
.
g
.
validator
function
)
instead
"
+
"
if
necessary
.
"
;
currentTest
.
assert
.
pushResult
(
{
result
:
false
message
:
message
}
)
;
return
;
}
}
var
then
=
promise
&
&
promise
.
then
;
if
(
objectType
(
then
)
!
=
=
"
function
"
)
{
var
_message
=
"
The
value
provided
to
assert
.
rejects
in
"
+
"
\
"
"
+
currentTest
.
testName
+
"
\
"
was
not
a
promise
.
"
;
currentTest
.
assert
.
pushResult
(
{
result
:
false
message
:
_message
actual
:
promise
}
)
;
return
;
}
var
done
=
this
.
async
(
)
;
return
then
.
call
(
promise
function
handleFulfillment
(
)
{
var
message
=
"
The
promise
returned
by
the
assert
.
rejects
callback
in
"
+
"
\
"
"
+
currentTest
.
testName
+
"
\
"
did
not
reject
.
"
;
currentTest
.
assert
.
pushResult
(
{
result
:
false
message
:
message
actual
:
promise
}
)
;
done
(
)
;
}
function
handleRejection
(
actual
)
{
if
(
actual
)
{
var
expectedType
=
objectType
(
expected
)
;
if
(
expected
=
=
=
undefined
)
{
result
=
true
;
expected
=
null
;
}
else
if
(
expectedType
=
=
=
"
regexp
"
)
{
result
=
expected
.
test
(
errorString
(
actual
)
)
;
}
else
if
(
expectedType
=
=
=
"
function
"
&
&
actual
instanceof
expected
)
{
result
=
true
;
}
else
if
(
expectedType
=
=
=
"
object
"
)
{
result
=
actual
instanceof
expected
.
constructor
&
&
actual
.
name
=
=
=
expected
.
name
&
&
actual
.
message
=
=
=
expected
.
message
;
}
else
{
if
(
expectedType
=
=
=
"
function
"
)
{
result
=
expected
.
call
(
{
}
actual
)
=
=
=
true
;
expected
=
null
;
}
else
{
result
=
false
;
message
=
"
invalid
expected
value
provided
to
assert
.
rejects
"
+
"
callback
in
\
"
"
+
currentTest
.
testName
+
"
\
"
:
"
+
expectedType
+
"
.
"
;
}
}
}
currentTest
.
assert
.
pushResult
(
{
result
:
result
actual
:
actual
expected
:
expected
message
:
message
}
)
;
done
(
)
;
}
)
;
}
}
]
)
;
return
Assert
;
}
(
)
;
Assert
.
prototype
.
raises
=
Assert
.
prototype
[
"
throws
"
]
;
function
errorString
(
error
)
{
var
resultErrorString
=
error
.
toString
(
)
;
if
(
resultErrorString
.
substring
(
0
7
)
=
=
=
"
[
object
"
)
{
var
name
=
error
.
name
?
error
.
name
.
toString
(
)
:
"
Error
"
;
var
message
=
error
.
message
?
error
.
message
.
toString
(
)
:
"
"
;
if
(
name
&
&
message
)
{
return
name
+
"
:
"
+
message
;
}
else
if
(
name
)
{
return
name
;
}
else
if
(
message
)
{
return
message
;
}
else
{
return
"
Error
"
;
}
}
else
{
return
resultErrorString
;
}
}
function
exportQUnit
(
QUnit
)
{
if
(
defined
.
document
)
{
if
(
window
.
QUnit
&
&
window
.
QUnit
.
version
)
{
throw
new
Error
(
"
QUnit
has
already
been
defined
.
"
)
;
}
window
.
QUnit
=
QUnit
;
}
if
(
typeof
module
!
=
=
"
undefined
"
&
&
module
&
&
module
.
exports
)
{
module
.
exports
=
QUnit
;
module
.
exports
.
QUnit
=
QUnit
;
}
if
(
typeof
exports
!
=
=
"
undefined
"
&
&
exports
)
{
exports
.
QUnit
=
QUnit
;
}
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
function
(
)
{
return
QUnit
;
}
)
;
QUnit
.
config
.
autostart
=
false
;
}
if
(
self
1
&
&
self
1
.
WorkerGlobalScope
&
&
self
1
instanceof
self
1
.
WorkerGlobalScope
)
{
self
1
.
QUnit
=
QUnit
;
}
}
var
SuiteReport
=
function
(
)
{
function
SuiteReport
(
name
parentSuite
)
{
classCallCheck
(
this
SuiteReport
)
;
this
.
name
=
name
;
this
.
fullName
=
parentSuite
?
parentSuite
.
fullName
.
concat
(
name
)
:
[
]
;
this
.
tests
=
[
]
;
this
.
childSuites
=
[
]
;
if
(
parentSuite
)
{
parentSuite
.
pushChildSuite
(
this
)
;
}
}
createClass
(
SuiteReport
[
{
key
:
"
start
"
value
:
function
start
(
recordTime
)
{
if
(
recordTime
)
{
this
.
_startTime
=
Date
.
now
(
)
;
}
return
{
name
:
this
.
name
fullName
:
this
.
fullName
.
slice
(
)
tests
:
this
.
tests
.
map
(
function
(
test
)
{
return
test
.
start
(
)
;
}
)
childSuites
:
this
.
childSuites
.
map
(
function
(
suite
)
{
return
suite
.
start
(
)
;
}
)
testCounts
:
{
total
:
this
.
getTestCounts
(
)
.
total
}
}
;
}
}
{
key
:
"
end
"
value
:
function
end
(
recordTime
)
{
if
(
recordTime
)
{
this
.
_endTime
=
Date
.
now
(
)
;
}
return
{
name
:
this
.
name
fullName
:
this
.
fullName
.
slice
(
)
tests
:
this
.
tests
.
map
(
function
(
test
)
{
return
test
.
end
(
)
;
}
)
childSuites
:
this
.
childSuites
.
map
(
function
(
suite
)
{
return
suite
.
end
(
)
;
}
)
testCounts
:
this
.
getTestCounts
(
)
runtime
:
this
.
getRuntime
(
)
status
:
this
.
getStatus
(
)
}
;
}
}
{
key
:
"
pushChildSuite
"
value
:
function
pushChildSuite
(
suite
)
{
this
.
childSuites
.
push
(
suite
)
;
}
}
{
key
:
"
pushTest
"
value
:
function
pushTest
(
test
)
{
this
.
tests
.
push
(
test
)
;
}
}
{
key
:
"
getRuntime
"
value
:
function
getRuntime
(
)
{
return
this
.
_endTime
-
this
.
_startTime
;
}
}
{
key
:
"
getTestCounts
"
value
:
function
getTestCounts
(
)
{
var
counts
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
passed
:
0
failed
:
0
skipped
:
0
todo
:
0
total
:
0
}
;
counts
=
this
.
tests
.
reduce
(
function
(
counts
test
)
{
if
(
test
.
valid
)
{
counts
[
test
.
getStatus
(
)
]
+
+
;
counts
.
total
+
+
;
}
return
counts
;
}
counts
)
;
return
this
.
childSuites
.
reduce
(
function
(
counts
suite
)
{
return
suite
.
getTestCounts
(
counts
)
;
}
counts
)
;
}
}
{
key
:
"
getStatus
"
value
:
function
getStatus
(
)
{
var
_getTestCounts
=
this
.
getTestCounts
(
)
total
=
_getTestCounts
.
total
failed
=
_getTestCounts
.
failed
skipped
=
_getTestCounts
.
skipped
todo
=
_getTestCounts
.
todo
;
if
(
failed
)
{
return
"
failed
"
;
}
else
{
if
(
skipped
=
=
=
total
)
{
return
"
skipped
"
;
}
else
if
(
todo
=
=
=
total
)
{
return
"
todo
"
;
}
else
{
return
"
passed
"
;
}
}
}
}
]
)
;
return
SuiteReport
;
}
(
)
;
function
onError
(
error
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
if
(
config
.
current
)
{
if
(
config
.
current
.
ignoreGlobalErrors
)
{
return
true
;
}
pushFailure
.
apply
(
undefined
[
error
.
message
error
.
fileName
+
"
:
"
+
error
.
lineNumber
]
.
concat
(
args
)
)
;
}
else
{
test
(
"
global
failure
"
extend
(
function
(
)
{
pushFailure
.
apply
(
undefined
[
error
.
message
error
.
fileName
+
"
:
"
+
error
.
lineNumber
]
.
concat
(
args
)
)
;
}
{
validTest
:
true
}
)
)
;
}
return
false
;
}
function
onUnhandledRejection
(
reason
)
{
var
resultInfo
=
{
result
:
false
message
:
reason
.
message
|
|
"
error
"
actual
:
reason
source
:
reason
.
stack
|
|
sourceFromStacktrace
(
3
)
}
;
var
currentTest
=
config
.
current
;
if
(
currentTest
)
{
currentTest
.
assert
.
pushResult
(
resultInfo
)
;
}
else
{
test
(
"
global
failure
"
extend
(
function
(
assert
)
{
assert
.
pushResult
(
resultInfo
)
;
}
{
validTest
:
true
}
)
)
;
}
}
var
focused
=
false
;
var
QUnit
=
{
}
;
var
globalSuite
=
new
SuiteReport
(
)
;
config
.
currentModule
.
suiteReport
=
globalSuite
;
var
moduleStack
=
[
]
;
var
globalStartCalled
=
false
;
var
runStarted
=
false
;
QUnit
.
isLocal
=
!
(
defined
.
document
&
&
window
.
location
.
protocol
!
=
=
"
file
:
"
)
;
QUnit
.
version
=
"
2
.
5
.
1
"
;
function
createModule
(
name
testEnvironment
modifiers
)
{
var
parentModule
=
moduleStack
.
length
?
moduleStack
.
slice
(
-
1
)
[
0
]
:
null
;
var
moduleName
=
parentModule
!
=
=
null
?
[
parentModule
.
name
name
]
.
join
(
"
>
"
)
:
name
;
var
parentSuite
=
parentModule
?
parentModule
.
suiteReport
:
globalSuite
;
var
skip
1
=
parentModule
!
=
=
null
&
&
parentModule
.
skip
|
|
modifiers
.
skip
;
var
todo
1
=
parentModule
!
=
=
null
&
&
parentModule
.
todo
|
|
modifiers
.
todo
;
var
module
=
{
name
:
moduleName
parentModule
:
parentModule
tests
:
[
]
moduleId
:
generateHash
(
moduleName
)
testsRun
:
0
unskippedTestsRun
:
0
childModules
:
[
]
suiteReport
:
new
SuiteReport
(
name
parentSuite
)
skip
:
skip
1
todo
:
skip
1
?
false
:
todo
1
}
;
var
env
=
{
}
;
if
(
parentModule
)
{
parentModule
.
childModules
.
push
(
module
)
;
extend
(
env
parentModule
.
testEnvironment
)
;
}
extend
(
env
testEnvironment
)
;
module
.
testEnvironment
=
env
;
config
.
modules
.
push
(
module
)
;
return
module
;
}
function
processModule
(
name
options
executeNow
)
{
var
modifiers
=
arguments
.
length
>
3
&
&
arguments
[
3
]
!
=
=
undefined
?
arguments
[
3
]
:
{
}
;
var
module
=
createModule
(
name
options
modifiers
)
;
var
testEnvironment
=
module
.
testEnvironment
;
var
hooks
=
module
.
hooks
=
{
}
;
setHookFromEnvironment
(
hooks
testEnvironment
"
before
"
)
;
setHookFromEnvironment
(
hooks
testEnvironment
"
beforeEach
"
)
;
setHookFromEnvironment
(
hooks
testEnvironment
"
afterEach
"
)
;
setHookFromEnvironment
(
hooks
testEnvironment
"
after
"
)
;
function
setHookFromEnvironment
(
hooks
environment
name
)
{
var
potentialHook
=
environment
[
name
]
;
hooks
[
name
]
=
typeof
potentialHook
=
=
=
"
function
"
?
[
potentialHook
]
:
[
]
;
delete
environment
[
name
]
;
}
var
moduleFns
=
{
before
:
setHookFunction
(
module
"
before
"
)
beforeEach
:
setHookFunction
(
module
"
beforeEach
"
)
afterEach
:
setHookFunction
(
module
"
afterEach
"
)
after
:
setHookFunction
(
module
"
after
"
)
}
;
var
currentModule
=
config
.
currentModule
;
if
(
objectType
(
executeNow
)
=
=
=
"
function
"
)
{
moduleStack
.
push
(
module
)
;
config
.
currentModule
=
module
;
executeNow
.
call
(
module
.
testEnvironment
moduleFns
)
;
moduleStack
.
pop
(
)
;
module
=
module
.
parentModule
|
|
currentModule
;
}
config
.
currentModule
=
module
;
}
function
module
1
(
name
options
executeNow
)
{
if
(
focused
)
{
return
;
}
if
(
arguments
.
length
=
=
=
2
)
{
if
(
objectType
(
options
)
=
=
=
"
function
"
)
{
executeNow
=
options
;
options
=
undefined
;
}
}
processModule
(
name
options
executeNow
)
;
}
module
1
.
only
=
function
(
)
{
if
(
focused
)
{
return
;
}
config
.
modules
.
length
=
0
;
config
.
queue
.
length
=
0
;
module
1
.
apply
(
undefined
arguments
)
;
focused
=
true
;
}
;
module
1
.
skip
=
function
(
name
options
executeNow
)
{
if
(
focused
)
{
return
;
}
if
(
arguments
.
length
=
=
=
2
)
{
if
(
objectType
(
options
)
=
=
=
"
function
"
)
{
executeNow
=
options
;
options
=
undefined
;
}
}
processModule
(
name
options
executeNow
{
skip
:
true
}
)
;
}
;
module
1
.
todo
=
function
(
name
options
executeNow
)
{
if
(
focused
)
{
return
;
}
if
(
arguments
.
length
=
=
=
2
)
{
if
(
objectType
(
options
)
=
=
=
"
function
"
)
{
executeNow
=
options
;
options
=
undefined
;
}
}
processModule
(
name
options
executeNow
{
todo
:
true
}
)
;
}
;
extend
(
QUnit
{
on
:
on
module
:
module
1
test
:
test
todo
:
todo
skip
:
skip
only
:
only
start
:
function
start
(
count
)
{
var
globalStartAlreadyCalled
=
globalStartCalled
;
if
(
!
config
.
current
)
{
globalStartCalled
=
true
;
if
(
runStarted
)
{
throw
new
Error
(
"
Called
start
(
)
while
test
already
started
running
"
)
;
}
else
if
(
globalStartAlreadyCalled
|
|
count
>
1
)
{
throw
new
Error
(
"
Called
start
(
)
outside
of
a
test
context
too
many
times
"
)
;
}
else
if
(
config
.
autostart
)
{
throw
new
Error
(
"
Called
start
(
)
outside
of
a
test
context
when
"
+
"
QUnit
.
config
.
autostart
was
true
"
)
;
}
else
if
(
!
config
.
pageLoaded
)
{
config
.
autostart
=
true
;
if
(
!
defined
.
document
)
{
QUnit
.
load
(
)
;
}
return
;
}
}
else
{
throw
new
Error
(
"
QUnit
.
start
cannot
be
called
inside
a
test
context
.
"
)
;
}
scheduleBegin
(
)
;
}
config
:
config
is
:
is
objectType
:
objectType
extend
:
extend
load
:
function
load
(
)
{
config
.
pageLoaded
=
true
;
extend
(
config
{
stats
:
{
all
:
0
bad
:
0
}
started
:
0
updateRate
:
1000
autostart
:
true
filter
:
"
"
}
true
)
;
if
(
!
runStarted
)
{
config
.
blocking
=
false
;
if
(
config
.
autostart
)
{
scheduleBegin
(
)
;
}
}
}
stack
:
function
stack
(
offset
)
{
offset
=
(
offset
|
|
0
)
+
2
;
return
sourceFromStacktrace
(
offset
)
;
}
onError
:
onError
onUnhandledRejection
:
onUnhandledRejection
}
)
;
QUnit
.
pushFailure
=
pushFailure
;
QUnit
.
assert
=
Assert
.
prototype
;
QUnit
.
equiv
=
equiv
;
QUnit
.
dump
=
dump
;
registerLoggingCallbacks
(
QUnit
)
;
function
scheduleBegin
(
)
{
runStarted
=
true
;
if
(
defined
.
setTimeout
)
{
setTimeout
(
function
(
)
{
begin
(
)
;
}
)
;
}
else
{
begin
(
)
;
}
}
function
begin
(
)
{
var
i
l
modulesLog
=
[
]
;
if
(
!
config
.
started
)
{
config
.
started
=
now
(
)
;
if
(
config
.
modules
[
0
]
.
name
=
=
=
"
"
&
&
config
.
modules
[
0
]
.
tests
.
length
=
=
=
0
)
{
config
.
modules
.
shift
(
)
;
}
for
(
i
=
0
l
=
config
.
modules
.
length
;
i
<
l
;
i
+
+
)
{
modulesLog
.
push
(
{
name
:
config
.
modules
[
i
]
.
name
tests
:
config
.
modules
[
i
]
.
tests
}
)
;
}
emit
(
"
runStart
"
globalSuite
.
start
(
true
)
)
;
runLoggingCallbacks
(
"
begin
"
{
totalTests
:
Test
.
count
modules
:
modulesLog
}
)
;
}
config
.
blocking
=
false
;
ProcessingQueue
.
advance
(
)
;
}
function
setHookFunction
(
module
hookName
)
{
return
function
setHook
(
callback
)
{
module
.
hooks
[
hookName
]
.
push
(
callback
)
;
}
;
}
exportQUnit
(
QUnit
)
;
(
function
(
)
{
if
(
typeof
window
=
=
=
"
undefined
"
|
|
typeof
document
=
=
=
"
undefined
"
)
{
return
;
}
var
config
=
QUnit
.
config
hasOwn
=
Object
.
prototype
.
hasOwnProperty
;
function
storeFixture
(
)
{
if
(
hasOwn
.
call
(
config
"
fixture
"
)
)
{
return
;
}
var
fixture
=
document
.
getElementById
(
"
qunit
-
fixture
"
)
;
if
(
fixture
)
{
config
.
fixture
=
fixture
.
cloneNode
(
true
)
;
}
}
QUnit
.
begin
(
storeFixture
)
;
function
resetFixture
(
)
{
if
(
config
.
fixture
=
=
null
)
{
return
;
}
var
fixture
=
document
.
getElementById
(
"
qunit
-
fixture
"
)
;
var
resetFixtureType
=
_typeof
(
config
.
fixture
)
;
if
(
resetFixtureType
=
=
=
"
string
"
)
{
var
newFixture
=
document
.
createElement
(
"
div
"
)
;
newFixture
.
setAttribute
(
"
id
"
"
qunit
-
fixture
"
)
;
newFixture
.
innerHTML
=
config
.
fixture
;
fixture
.
parentNode
.
replaceChild
(
newFixture
fixture
)
;
}
else
{
var
clonedFixture
=
config
.
fixture
.
cloneNode
(
true
)
;
fixture
.
parentNode
.
replaceChild
(
clonedFixture
fixture
)
;
}
}
QUnit
.
testStart
(
resetFixture
)
;
}
)
(
)
;
(
function
(
)
{
var
location
=
typeof
window
!
=
=
"
undefined
"
&
&
window
.
location
;
if
(
!
location
)
{
return
;
}
var
urlParams
=
getUrlParams
(
)
;
QUnit
.
urlParams
=
urlParams
;
QUnit
.
config
.
moduleId
=
[
]
.
concat
(
urlParams
.
moduleId
|
|
[
]
)
;
QUnit
.
config
.
testId
=
[
]
.
concat
(
urlParams
.
testId
|
|
[
]
)
;
QUnit
.
config
.
module
=
urlParams
.
module
;
QUnit
.
config
.
filter
=
urlParams
.
filter
;
if
(
urlParams
.
seed
=
=
=
true
)
{
QUnit
.
config
.
seed
=
Math
.
random
(
)
.
toString
(
36
)
.
slice
(
2
)
;
}
else
if
(
urlParams
.
seed
)
{
QUnit
.
config
.
seed
=
urlParams
.
seed
;
}
QUnit
.
config
.
urlConfig
.
push
(
{
id
:
"
hidepassed
"
label
:
"
Hide
passed
tests
"
tooltip
:
"
Only
show
tests
and
assertions
that
fail
.
Stored
as
query
-
strings
.
"
}
{
id
:
"
noglobals
"
label
:
"
Check
for
Globals
"
tooltip
:
"
Enabling
this
will
test
if
any
test
introduces
new
properties
on
the
"
+
"
global
object
(
window
in
Browsers
)
.
Stored
as
query
-
strings
.
"
}
{
id
:
"
notrycatch
"
label
:
"
No
try
-
catch
"
tooltip
:
"
Enabling
this
will
run
tests
outside
of
a
try
-
catch
block
.
Makes
debugging
"
+
"
exceptions
in
IE
reasonable
.
Stored
as
query
-
strings
.
"
}
)
;
QUnit
.
begin
(
function
(
)
{
var
i
option
urlConfig
=
QUnit
.
config
.
urlConfig
;
for
(
i
=
0
;
i
<
urlConfig
.
length
;
i
+
+
)
{
option
=
QUnit
.
config
.
urlConfig
[
i
]
;
if
(
typeof
option
!
=
=
"
string
"
)
{
option
=
option
.
id
;
}
if
(
QUnit
.
config
[
option
]
=
=
=
undefined
)
{
QUnit
.
config
[
option
]
=
urlParams
[
option
]
;
}
}
}
)
;
function
getUrlParams
(
)
{
var
i
param
name
value
;
var
urlParams
=
Object
.
create
(
null
)
;
var
params
=
location
.
search
.
slice
(
1
)
.
split
(
"
&
"
)
;
var
length
=
params
.
length
;
for
(
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
params
[
i
]
)
{
param
=
params
[
i
]
.
split
(
"
=
"
)
;
name
=
decodeQueryParam
(
param
[
0
]
)
;
value
=
param
.
length
=
=
=
1
|
|
decodeQueryParam
(
param
.
slice
(
1
)
.
join
(
"
=
"
)
)
;
if
(
name
in
urlParams
)
{
urlParams
[
name
]
=
[
]
.
concat
(
urlParams
[
name
]
value
)
;
}
else
{
urlParams
[
name
]
=
value
;
}
}
}
return
urlParams
;
}
function
decodeQueryParam
(
param
)
{
return
decodeURIComponent
(
param
.
replace
(
/
\
+
/
g
"
%
20
"
)
)
;
}
}
)
(
)
;
var
stats
=
{
passedTests
:
0
failedTests
:
0
skippedTests
:
0
todoTests
:
0
}
;
function
escapeText
(
s
)
{
if
(
!
s
)
{
return
"
"
;
}
s
=
s
+
"
"
;
return
s
.
replace
(
/
[
'
"
<
>
&
]
/
g
function
(
s
)
{
switch
(
s
)
{
case
"
'
"
:
return
"
&
#
039
;
"
;
case
"
\
"
"
:
return
"
&
quot
;
"
;
case
"
<
"
:
return
"
&
lt
;
"
;
case
"
>
"
:
return
"
&
gt
;
"
;
case
"
&
"
:
return
"
&
amp
;
"
;
}
}
)
;
}
(
function
(
)
{
if
(
typeof
window
=
=
=
"
undefined
"
|
|
!
window
.
document
)
{
return
;
}
var
config
=
QUnit
.
config
document
1
=
window
.
document
collapseNext
=
false
hasOwn
=
Object
.
prototype
.
hasOwnProperty
unfilteredUrl
=
setUrl
(
{
filter
:
undefined
module
:
undefined
moduleId
:
undefined
testId
:
undefined
}
)
modulesList
=
[
]
;
function
addEvent
(
elem
type
fn
)
{
elem
.
addEventListener
(
type
fn
false
)
;
}
function
removeEvent
(
elem
type
fn
)
{
elem
.
removeEventListener
(
type
fn
false
)
;
}
function
addEvents
(
elems
type
fn
)
{
var
i
=
elems
.
length
;
while
(
i
-
-
)
{
addEvent
(
elems
[
i
]
type
fn
)
;
}
}
function
hasClass
(
elem
name
)
{
return
(
"
"
+
elem
.
className
+
"
"
)
.
indexOf
(
"
"
+
name
+
"
"
)
>
=
0
;
}
function
addClass
(
elem
name
)
{
if
(
!
hasClass
(
elem
name
)
)
{
elem
.
className
+
=
(
elem
.
className
?
"
"
:
"
"
)
+
name
;
}
}
function
toggleClass
(
elem
name
force
)
{
if
(
force
|
|
typeof
force
=
=
=
"
undefined
"
&
&
!
hasClass
(
elem
name
)
)
{
addClass
(
elem
name
)
;
}
else
{
removeClass
(
elem
name
)
;
}
}
function
removeClass
(
elem
name
)
{
var
set
=
"
"
+
elem
.
className
+
"
"
;
while
(
set
.
indexOf
(
"
"
+
name
+
"
"
)
>
=
0
)
{
set
=
set
.
replace
(
"
"
+
name
+
"
"
"
"
)
;
}
elem
.
className
=
typeof
set
.
trim
=
=
=
"
function
"
?
set
.
trim
(
)
:
set
.
replace
(
/
^
\
s
+
|
\
s
+
/
g
"
"
)
;
}
function
id
(
name
)
{
return
document
1
.
getElementById
&
&
document
1
.
getElementById
(
name
)
;
}
function
abortTests
(
)
{
var
abortButton
=
id
(
"
qunit
-
abort
-
tests
-
button
"
)
;
if
(
abortButton
)
{
abortButton
.
disabled
=
true
;
abortButton
.
innerHTML
=
"
Aborting
.
.
.
"
;
}
QUnit
.
config
.
queue
.
length
=
0
;
return
false
;
}
function
interceptNavigation
(
ev
)
{
applyUrlParams
(
)
;
if
(
ev
&
&
ev
.
preventDefault
)
{
ev
.
preventDefault
(
)
;
}
return
false
;
}
function
getUrlConfigHtml
(
)
{
var
i
j
val
escaped
escapedTooltip
selection
=
false
urlConfig
=
config
.
urlConfig
urlConfigHtml
=
"
"
;
for
(
i
=
0
;
i
<
urlConfig
.
length
;
i
+
+
)
{
val
=
config
.
urlConfig
[
i
]
;
if
(
typeof
val
=
=
=
"
string
"
)
{
val
=
{
id
:
val
label
:
val
}
;
}
escaped
=
escapeText
(
val
.
id
)
;
escapedTooltip
=
escapeText
(
val
.
tooltip
)
;
if
(
!
val
.
value
|
|
typeof
val
.
value
=
=
=
"
string
"
)
{
urlConfigHtml
+
=
"
<
label
for
=
'
qunit
-
urlconfig
-
"
+
escaped
+
"
'
title
=
'
"
+
escapedTooltip
+
"
'
>
<
input
id
=
'
qunit
-
urlconfig
-
"
+
escaped
+
"
'
name
=
'
"
+
escaped
+
"
'
type
=
'
checkbox
'
"
+
(
val
.
value
?
"
value
=
'
"
+
escapeText
(
val
.
value
)
+
"
'
"
:
"
"
)
+
(
config
[
val
.
id
]
?
"
checked
=
'
checked
'
"
:
"
"
)
+
"
title
=
'
"
+
escapedTooltip
+
"
'
/
>
"
+
escapeText
(
val
.
label
)
+
"
<
/
label
>
"
;
}
else
{
urlConfigHtml
+
=
"
<
label
for
=
'
qunit
-
urlconfig
-
"
+
escaped
+
"
'
title
=
'
"
+
escapedTooltip
+
"
'
>
"
+
val
.
label
+
"
:
<
/
label
>
<
select
id
=
'
qunit
-
urlconfig
-
"
+
escaped
+
"
'
name
=
'
"
+
escaped
+
"
'
title
=
'
"
+
escapedTooltip
+
"
'
>
<
option
>
<
/
option
>
"
;
if
(
QUnit
.
is
(
"
array
"
val
.
value
)
)
{
for
(
j
=
0
;
j
<
val
.
value
.
length
;
j
+
+
)
{
escaped
=
escapeText
(
val
.
value
[
j
]
)
;
urlConfigHtml
+
=
"
<
option
value
=
'
"
+
escaped
+
"
'
"
+
(
config
[
val
.
id
]
=
=
=
val
.
value
[
j
]
?
(
selection
=
true
)
&
&
"
selected
=
'
selected
'
"
:
"
"
)
+
"
>
"
+
escaped
+
"
<
/
option
>
"
;
}
}
else
{
for
(
j
in
val
.
value
)
{
if
(
hasOwn
.
call
(
val
.
value
j
)
)
{
urlConfigHtml
+
=
"
<
option
value
=
'
"
+
escapeText
(
j
)
+
"
'
"
+
(
config
[
val
.
id
]
=
=
=
j
?
(
selection
=
true
)
&
&
"
selected
=
'
selected
'
"
:
"
"
)
+
"
>
"
+
escapeText
(
val
.
value
[
j
]
)
+
"
<
/
option
>
"
;
}
}
}
if
(
config
[
val
.
id
]
&
&
!
selection
)
{
escaped
=
escapeText
(
config
[
val
.
id
]
)
;
urlConfigHtml
+
=
"
<
option
value
=
'
"
+
escaped
+
"
'
selected
=
'
selected
'
disabled
=
'
disabled
'
>
"
+
escaped
+
"
<
/
option
>
"
;
}
urlConfigHtml
+
=
"
<
/
select
>
"
;
}
}
return
urlConfigHtml
;
}
function
toolbarChanged
(
)
{
var
updatedUrl
value
tests
field
=
this
params
=
{
}
;
if
(
"
selectedIndex
"
in
field
)
{
value
=
field
.
options
[
field
.
selectedIndex
]
.
value
|
|
undefined
;
}
else
{
value
=
field
.
checked
?
field
.
defaultValue
|
|
true
:
undefined
;
}
params
[
field
.
name
]
=
value
;
updatedUrl
=
setUrl
(
params
)
;
if
(
"
hidepassed
"
=
=
=
field
.
name
&
&
"
replaceState
"
in
window
.
history
)
{
QUnit
.
urlParams
[
field
.
name
]
=
value
;
config
[
field
.
name
]
=
value
|
|
false
;
tests
=
id
(
"
qunit
-
tests
"
)
;
if
(
tests
)
{
toggleClass
(
tests
"
hidepass
"
value
|
|
false
)
;
}
window
.
history
.
replaceState
(
null
"
"
updatedUrl
)
;
}
else
{
window
.
location
=
updatedUrl
;
}
}
function
setUrl
(
params
)
{
var
key
arrValue
i
querystring
=
"
?
"
location
=
window
.
location
;
params
=
QUnit
.
extend
(
QUnit
.
extend
(
{
}
QUnit
.
urlParams
)
params
)
;
for
(
key
in
params
)
{
if
(
hasOwn
.
call
(
params
key
)
&
&
params
[
key
]
!
=
=
undefined
)
{
arrValue
=
[
]
.
concat
(
params
[
key
]
)
;
for
(
i
=
0
;
i
<
arrValue
.
length
;
i
+
+
)
{
querystring
+
=
encodeURIComponent
(
key
)
;
if
(
arrValue
[
i
]
!
=
=
true
)
{
querystring
+
=
"
=
"
+
encodeURIComponent
(
arrValue
[
i
]
)
;
}
querystring
+
=
"
&
"
;
}
}
}
return
location
.
protocol
+
"
/
/
"
+
location
.
host
+
location
.
pathname
+
querystring
.
slice
(
0
-
1
)
;
}
function
applyUrlParams
(
)
{
var
i
selectedModules
=
[
]
modulesList
=
id
(
"
qunit
-
modulefilter
-
dropdown
-
list
"
)
.
getElementsByTagName
(
"
input
"
)
filter
=
id
(
"
qunit
-
filter
-
input
"
)
.
value
;
for
(
i
=
0
;
i
<
modulesList
.
length
;
i
+
+
)
{
if
(
modulesList
[
i
]
.
checked
)
{
selectedModules
.
push
(
modulesList
[
i
]
.
value
)
;
}
}
window
.
location
=
setUrl
(
{
filter
:
filter
=
=
=
"
"
?
undefined
:
filter
moduleId
:
selectedModules
.
length
=
=
=
0
?
undefined
:
selectedModules
module
:
undefined
testId
:
undefined
}
)
;
}
function
toolbarUrlConfigContainer
(
)
{
var
urlConfigContainer
=
document
1
.
createElement
(
"
span
"
)
;
urlConfigContainer
.
innerHTML
=
getUrlConfigHtml
(
)
;
addClass
(
urlConfigContainer
"
qunit
-
url
-
config
"
)
;
addEvents
(
urlConfigContainer
.
getElementsByTagName
(
"
input
"
)
"
change
"
toolbarChanged
)
;
addEvents
(
urlConfigContainer
.
getElementsByTagName
(
"
select
"
)
"
change
"
toolbarChanged
)
;
return
urlConfigContainer
;
}
function
abortTestsButton
(
)
{
var
button
=
document
1
.
createElement
(
"
button
"
)
;
button
.
id
=
"
qunit
-
abort
-
tests
-
button
"
;
button
.
innerHTML
=
"
Abort
"
;
addEvent
(
button
"
click
"
abortTests
)
;
return
button
;
}
function
toolbarLooseFilter
(
)
{
var
filter
=
document
1
.
createElement
(
"
form
"
)
label
=
document
1
.
createElement
(
"
label
"
)
input
=
document
1
.
createElement
(
"
input
"
)
button
=
document
1
.
createElement
(
"
button
"
)
;
addClass
(
filter
"
qunit
-
filter
"
)
;
label
.
innerHTML
=
"
Filter
:
"
;
input
.
type
=
"
text
"
;
input
.
value
=
config
.
filter
|
|
"
"
;
input
.
name
=
"
filter
"
;
input
.
id
=
"
qunit
-
filter
-
input
"
;
button
.
innerHTML
=
"
Go
"
;
label
.
appendChild
(
input
)
;
filter
.
appendChild
(
label
)
;
filter
.
appendChild
(
document
1
.
createTextNode
(
"
"
)
)
;
filter
.
appendChild
(
button
)
;
addEvent
(
filter
"
submit
"
interceptNavigation
)
;
return
filter
;
}
function
moduleListHtml
(
)
{
var
i
checked
html
=
"
"
;
for
(
i
=
0
;
i
<
config
.
modules
.
length
;
i
+
+
)
{
if
(
config
.
modules
[
i
]
.
name
!
=
=
"
"
)
{
checked
=
config
.
moduleId
.
indexOf
(
config
.
modules
[
i
]
.
moduleId
)
>
-
1
;
html
+
=
"
<
li
>
<
label
class
=
'
clickable
"
+
(
checked
?
"
checked
"
:
"
"
)
+
"
'
>
<
input
type
=
'
checkbox
'
"
+
"
value
=
'
"
+
config
.
modules
[
i
]
.
moduleId
+
"
'
"
+
(
checked
?
"
checked
=
'
checked
'
"
:
"
"
)
+
"
/
>
"
+
escapeText
(
config
.
modules
[
i
]
.
name
)
+
"
<
/
label
>
<
/
li
>
"
;
}
}
return
html
;
}
function
toolbarModuleFilter
(
)
{
var
allCheckbox
commit
reset
moduleFilter
=
document
1
.
createElement
(
"
form
"
)
label
=
document
1
.
createElement
(
"
label
"
)
moduleSearch
=
document
1
.
createElement
(
"
input
"
)
dropDown
=
document
1
.
createElement
(
"
div
"
)
actions
=
document
1
.
createElement
(
"
span
"
)
dropDownList
=
document
1
.
createElement
(
"
ul
"
)
dirty
=
false
;
moduleSearch
.
id
=
"
qunit
-
modulefilter
-
search
"
;
addEvent
(
moduleSearch
"
input
"
searchInput
)
;
addEvent
(
moduleSearch
"
input
"
searchFocus
)
;
addEvent
(
moduleSearch
"
focus
"
searchFocus
)
;
addEvent
(
moduleSearch
"
click
"
searchFocus
)
;
label
.
id
=
"
qunit
-
modulefilter
-
search
-
container
"
;
label
.
innerHTML
=
"
Module
:
"
;
label
.
appendChild
(
moduleSearch
)
;
actions
.
id
=
"
qunit
-
modulefilter
-
actions
"
;
actions
.
innerHTML
=
"
<
button
style
=
'
display
:
none
'
>
Apply
<
/
button
>
"
+
"
<
button
type
=
'
reset
'
style
=
'
display
:
none
'
>
Reset
<
/
button
>
"
+
"
<
label
class
=
'
clickable
"
+
(
config
.
moduleId
.
length
?
"
"
:
"
checked
"
)
+
"
'
>
<
input
type
=
'
checkbox
'
"
+
(
config
.
moduleId
.
length
?
"
"
:
"
checked
=
'
checked
'
"
)
+
"
>
All
modules
<
/
label
>
"
;
allCheckbox
=
actions
.
lastChild
.
firstChild
;
commit
=
actions
.
firstChild
;
reset
=
commit
.
nextSibling
;
addEvent
(
commit
"
click
"
applyUrlParams
)
;
dropDownList
.
id
=
"
qunit
-
modulefilter
-
dropdown
-
list
"
;
dropDownList
.
innerHTML
=
moduleListHtml
(
)
;
dropDown
.
id
=
"
qunit
-
modulefilter
-
dropdown
"
;
dropDown
.
style
.
display
=
"
none
"
;
dropDown
.
appendChild
(
actions
)
;
dropDown
.
appendChild
(
dropDownList
)
;
addEvent
(
dropDown
"
change
"
selectionChange
)
;
selectionChange
(
)
;
moduleFilter
.
id
=
"
qunit
-
modulefilter
"
;
moduleFilter
.
appendChild
(
label
)
;
moduleFilter
.
appendChild
(
dropDown
)
;
addEvent
(
moduleFilter
"
submit
"
interceptNavigation
)
;
addEvent
(
moduleFilter
"
reset
"
function
(
)
{
window
.
setTimeout
(
selectionChange
)
;
}
)
;
function
searchFocus
(
)
{
if
(
dropDown
.
style
.
display
!
=
=
"
none
"
)
{
return
;
}
dropDown
.
style
.
display
=
"
block
"
;
addEvent
(
document
1
"
click
"
hideHandler
)
;
addEvent
(
document
1
"
keydown
"
hideHandler
)
;
function
hideHandler
(
e
)
{
var
inContainer
=
moduleFilter
.
contains
(
e
.
target
)
;
if
(
e
.
keyCode
=
=
=
27
|
|
!
inContainer
)
{
if
(
e
.
keyCode
=
=
=
27
&
&
inContainer
)
{
moduleSearch
.
focus
(
)
;
}
dropDown
.
style
.
display
=
"
none
"
;
removeEvent
(
document
1
"
click
"
hideHandler
)
;
removeEvent
(
document
1
"
keydown
"
hideHandler
)
;
moduleSearch
.
value
=
"
"
;
searchInput
(
)
;
}
}
}
function
searchInput
(
)
{
var
i
item
searchText
=
moduleSearch
.
value
.
toLowerCase
(
)
listItems
=
dropDownList
.
children
;
for
(
i
=
0
;
i
<
listItems
.
length
;
i
+
+
)
{
item
=
listItems
[
i
]
;
if
(
!
searchText
|
|
item
.
textContent
.
toLowerCase
(
)
.
indexOf
(
searchText
)
>
-
1
)
{
item
.
style
.
display
=
"
"
;
}
else
{
item
.
style
.
display
=
"
none
"
;
}
}
}
function
selectionChange
(
evt
)
{
var
i
item
checkbox
=
evt
&
&
evt
.
target
|
|
allCheckbox
modulesList
=
dropDownList
.
getElementsByTagName
(
"
input
"
)
selectedNames
=
[
]
;
toggleClass
(
checkbox
.
parentNode
"
checked
"
checkbox
.
checked
)
;
dirty
=
false
;
if
(
checkbox
.
checked
&
&
checkbox
!
=
=
allCheckbox
)
{
allCheckbox
.
checked
=
false
;
removeClass
(
allCheckbox
.
parentNode
"
checked
"
)
;
}
for
(
i
=
0
;
i
<
modulesList
.
length
;
i
+
+
)
{
item
=
modulesList
[
i
]
;
if
(
!
evt
)
{
toggleClass
(
item
.
parentNode
"
checked
"
item
.
checked
)
;
}
else
if
(
checkbox
=
=
=
allCheckbox
&
&
checkbox
.
checked
)
{
item
.
checked
=
false
;
removeClass
(
item
.
parentNode
"
checked
"
)
;
}
dirty
=
dirty
|
|
item
.
checked
!
=
=
item
.
defaultChecked
;
if
(
item
.
checked
)
{
selectedNames
.
push
(
item
.
parentNode
.
textContent
)
;
}
}
commit
.
style
.
display
=
reset
.
style
.
display
=
dirty
?
"
"
:
"
none
"
;
moduleSearch
.
placeholder
=
selectedNames
.
join
(
"
"
)
|
|
allCheckbox
.
parentNode
.
textContent
;
moduleSearch
.
title
=
"
Type
to
filter
list
.
Current
selection
:
\
n
"
+
(
selectedNames
.
join
(
"
\
n
"
)
|
|
allCheckbox
.
parentNode
.
textContent
)
;
}
return
moduleFilter
;
}
function
appendToolbar
(
)
{
var
toolbar
=
id
(
"
qunit
-
testrunner
-
toolbar
"
)
;
if
(
toolbar
)
{
toolbar
.
appendChild
(
toolbarUrlConfigContainer
(
)
)
;
toolbar
.
appendChild
(
toolbarModuleFilter
(
)
)
;
toolbar
.
appendChild
(
toolbarLooseFilter
(
)
)
;
toolbar
.
appendChild
(
document
1
.
createElement
(
"
div
"
)
)
.
className
=
"
clearfix
"
;
}
}
function
appendHeader
(
)
{
var
header
=
id
(
"
qunit
-
header
"
)
;
if
(
header
)
{
header
.
innerHTML
=
"
<
a
href
=
'
"
+
escapeText
(
unfilteredUrl
)
+
"
'
>
"
+
header
.
innerHTML
+
"
<
/
a
>
"
;
}
}
function
appendBanner
(
)
{
var
banner
=
id
(
"
qunit
-
banner
"
)
;
if
(
banner
)
{
banner
.
className
=
"
"
;
}
}
function
appendTestResults
(
)
{
var
tests
=
id
(
"
qunit
-
tests
"
)
result
=
id
(
"
qunit
-
testresult
"
)
controls
;
if
(
result
)
{
result
.
parentNode
.
removeChild
(
result
)
;
}
if
(
tests
)
{
tests
.
innerHTML
=
"
"
;
result
=
document
1
.
createElement
(
"
p
"
)
;
result
.
id
=
"
qunit
-
testresult
"
;
result
.
className
=
"
result
"
;
tests
.
parentNode
.
insertBefore
(
result
tests
)
;
result
.
innerHTML
=
"
<
div
id
=
\
"
qunit
-
testresult
-
display
\
"
>
Running
.
.
.
<
br
/
>
&
#
160
;
<
/
div
>
"
+
"
<
div
id
=
\
"
qunit
-
testresult
-
controls
\
"
>
<
/
div
>
"
+
"
<
div
class
=
\
"
clearfix
\
"
>
<
/
div
>
"
;
controls
=
id
(
"
qunit
-
testresult
-
controls
"
)
;
}
if
(
controls
)
{
controls
.
appendChild
(
abortTestsButton
(
)
)
;
}
}
function
appendFilteredTest
(
)
{
var
testId
=
QUnit
.
config
.
testId
;
if
(
!
testId
|
|
testId
.
length
<
=
0
)
{
return
"
"
;
}
return
"
<
div
id
=
'
qunit
-
filteredTest
'
>
Rerunning
selected
tests
:
"
+
escapeText
(
testId
.
join
(
"
"
)
)
+
"
<
a
id
=
'
qunit
-
clearFilter
'
href
=
'
"
+
escapeText
(
unfilteredUrl
)
+
"
'
>
Run
all
tests
<
/
a
>
<
/
div
>
"
;
}
function
appendUserAgent
(
)
{
var
userAgent
=
id
(
"
qunit
-
userAgent
"
)
;
if
(
userAgent
)
{
userAgent
.
innerHTML
=
"
"
;
userAgent
.
appendChild
(
document
1
.
createTextNode
(
"
QUnit
"
+
QUnit
.
version
+
"
;
"
+
navigator
.
userAgent
)
)
;
}
}
function
appendInterface
(
)
{
var
qunit
=
id
(
"
qunit
"
)
;
if
(
qunit
)
{
qunit
.
innerHTML
=
"
<
h1
id
=
'
qunit
-
header
'
>
"
+
escapeText
(
document
1
.
title
)
+
"
<
/
h1
>
"
+
"
<
h2
id
=
'
qunit
-
banner
'
>
<
/
h2
>
"
+
"
<
div
id
=
'
qunit
-
testrunner
-
toolbar
'
>
<
/
div
>
"
+
appendFilteredTest
(
)
+
"
<
h2
id
=
'
qunit
-
userAgent
'
>
<
/
h2
>
"
+
"
<
ol
id
=
'
qunit
-
tests
'
>
<
/
ol
>
"
;
}
appendHeader
(
)
;
appendBanner
(
)
;
appendTestResults
(
)
;
appendUserAgent
(
)
;
appendToolbar
(
)
;
}
function
appendTestsList
(
modules
)
{
var
i
l
x
z
test
moduleObj
;
for
(
i
=
0
l
=
modules
.
length
;
i
<
l
;
i
+
+
)
{
moduleObj
=
modules
[
i
]
;
for
(
x
=
0
z
=
moduleObj
.
tests
.
length
;
x
<
z
;
x
+
+
)
{
test
=
moduleObj
.
tests
[
x
]
;
appendTest
(
test
.
name
test
.
testId
moduleObj
.
name
)
;
}
}
}
function
appendTest
(
name
testId
moduleName
)
{
var
title
rerunTrigger
testBlock
assertList
tests
=
id
(
"
qunit
-
tests
"
)
;
if
(
!
tests
)
{
return
;
}
title
=
document
1
.
createElement
(
"
strong
"
)
;
title
.
innerHTML
=
getNameHtml
(
name
moduleName
)
;
rerunTrigger
=
document
1
.
createElement
(
"
a
"
)
;
rerunTrigger
.
innerHTML
=
"
Rerun
"
;
rerunTrigger
.
href
=
setUrl
(
{
testId
:
testId
}
)
;
testBlock
=
document
1
.
createElement
(
"
li
"
)
;
testBlock
.
appendChild
(
title
)
;
testBlock
.
appendChild
(
rerunTrigger
)
;
testBlock
.
id
=
"
qunit
-
test
-
output
-
"
+
testId
;
assertList
=
document
1
.
createElement
(
"
ol
"
)
;
assertList
.
className
=
"
qunit
-
assert
-
list
"
;
testBlock
.
appendChild
(
assertList
)
;
tests
.
appendChild
(
testBlock
)
;
}
QUnit
.
begin
(
function
(
details
)
{
var
i
moduleObj
tests
;
for
(
i
=
0
;
i
<
details
.
modules
.
length
;
i
+
+
)
{
moduleObj
=
details
.
modules
[
i
]
;
if
(
moduleObj
.
name
)
{
modulesList
.
push
(
moduleObj
.
name
)
;
}
}
modulesList
.
sort
(
function
(
a
b
)
{
return
a
.
localeCompare
(
b
)
;
}
)
;
appendInterface
(
)
;
appendTestsList
(
details
.
modules
)
;
tests
=
id
(
"
qunit
-
tests
"
)
;
if
(
tests
&
&
config
.
hidepassed
)
{
addClass
(
tests
"
hidepass
"
)
;
}
}
)
;
QUnit
.
done
(
function
(
details
)
{
var
banner
=
id
(
"
qunit
-
banner
"
)
tests
=
id
(
"
qunit
-
tests
"
)
abortButton
=
id
(
"
qunit
-
abort
-
tests
-
button
"
)
totalTests
=
stats
.
passedTests
+
stats
.
skippedTests
+
stats
.
todoTests
+
stats
.
failedTests
html
=
[
totalTests
"
tests
completed
in
"
details
.
runtime
"
milliseconds
with
"
stats
.
failedTests
"
failed
"
stats
.
skippedTests
"
skipped
and
"
stats
.
todoTests
"
todo
.
<
br
/
>
"
"
<
span
class
=
'
passed
'
>
"
details
.
passed
"
<
/
span
>
assertions
of
<
span
class
=
'
total
'
>
"
details
.
total
"
<
/
span
>
passed
<
span
class
=
'
failed
'
>
"
details
.
failed
"
<
/
span
>
failed
.
"
]
.
join
(
"
"
)
test
assertLi
assertList
;
if
(
abortButton
&
&
abortButton
.
disabled
)
{
html
=
"
Tests
aborted
after
"
+
details
.
runtime
+
"
milliseconds
.
"
;
for
(
var
i
=
0
;
i
<
tests
.
children
.
length
;
i
+
+
)
{
test
=
tests
.
children
[
i
]
;
if
(
test
.
className
=
=
=
"
"
|
|
test
.
className
=
=
=
"
running
"
)
{
test
.
className
=
"
aborted
"
;
assertList
=
test
.
getElementsByTagName
(
"
ol
"
)
[
0
]
;
assertLi
=
document
1
.
createElement
(
"
li
"
)
;
assertLi
.
className
=
"
fail
"
;
assertLi
.
innerHTML
=
"
Test
aborted
.
"
;
assertList
.
appendChild
(
assertLi
)
;
}
}
}
if
(
banner
&
&
(
!
abortButton
|
|
abortButton
.
disabled
=
=
=
false
)
)
{
banner
.
className
=
stats
.
failedTests
?
"
qunit
-
fail
"
:
"
qunit
-
pass
"
;
}
if
(
abortButton
)
{
abortButton
.
parentNode
.
removeChild
(
abortButton
)
;
}
if
(
tests
)
{
id
(
"
qunit
-
testresult
-
display
"
)
.
innerHTML
=
html
;
}
if
(
config
.
altertitle
&
&
document
1
.
title
)
{
document
1
.
title
=
[
stats
.
failedTests
?
"
\
u2716
"
:
"
\
u2714
"
document
1
.
title
.
replace
(
/
^
[
\
u2714
\
u2716
]
/
i
"
"
)
]
.
join
(
"
"
)
;
}
if
(
config
.
scrolltop
&
&
window
.
scrollTo
)
{
window
.
scrollTo
(
0
0
)
;
}
}
)
;
function
getNameHtml
(
name
module
)
{
var
nameHtml
=
"
"
;
if
(
module
)
{
nameHtml
=
"
<
span
class
=
'
module
-
name
'
>
"
+
escapeText
(
module
)
+
"
<
/
span
>
:
"
;
}
nameHtml
+
=
"
<
span
class
=
'
test
-
name
'
>
"
+
escapeText
(
name
)
+
"
<
/
span
>
"
;
return
nameHtml
;
}
QUnit
.
testStart
(
function
(
details
)
{
var
running
testBlock
bad
;
testBlock
=
id
(
"
qunit
-
test
-
output
-
"
+
details
.
testId
)
;
if
(
testBlock
)
{
testBlock
.
className
=
"
running
"
;
}
else
{
appendTest
(
details
.
name
details
.
testId
details
.
module
)
;
}
running
=
id
(
"
qunit
-
testresult
-
display
"
)
;
if
(
running
)
{
bad
=
QUnit
.
config
.
reorder
&
&
details
.
previousFailure
;
running
.
innerHTML
=
[
bad
?
"
Rerunning
previously
failed
test
:
<
br
/
>
"
:
"
Running
:
<
br
/
>
"
getNameHtml
(
details
.
name
details
.
module
)
]
.
join
(
"
"
)
;
}
}
)
;
function
stripHtml
(
string
)
{
return
string
.
replace
(
/
<
\
/
?
[
^
>
]
+
(
>
|
)
/
g
"
"
)
.
replace
(
/
\
&
quot
;
/
g
"
"
)
.
replace
(
/
\
s
+
/
g
"
"
)
;
}
QUnit
.
log
(
function
(
details
)
{
var
assertList
assertLi
message
expected
actual
diff
showDiff
=
false
testItem
=
id
(
"
qunit
-
test
-
output
-
"
+
details
.
testId
)
;
if
(
!
testItem
)
{
return
;
}
message
=
escapeText
(
details
.
message
)
|
|
(
details
.
result
?
"
okay
"
:
"
failed
"
)
;
message
=
"
<
span
class
=
'
test
-
message
'
>
"
+
message
+
"
<
/
span
>
"
;
message
+
=
"
<
span
class
=
'
runtime
'
>
"
+
details
.
runtime
+
"
ms
<
/
span
>
"
;
if
(
!
details
.
result
&
&
hasOwn
.
call
(
details
"
expected
"
)
)
{
if
(
details
.
negative
)
{
expected
=
"
NOT
"
+
QUnit
.
dump
.
parse
(
details
.
expected
)
;
}
else
{
expected
=
QUnit
.
dump
.
parse
(
details
.
expected
)
;
}
actual
=
QUnit
.
dump
.
parse
(
details
.
actual
)
;
message
+
=
"
<
table
>
<
tr
class
=
'
test
-
expected
'
>
<
th
>
Expected
:
<
/
th
>
<
td
>
<
pre
>
"
+
escapeText
(
expected
)
+
"
<
/
pre
>
<
/
td
>
<
/
tr
>
"
;
if
(
actual
!
=
=
expected
)
{
message
+
=
"
<
tr
class
=
'
test
-
actual
'
>
<
th
>
Result
:
<
/
th
>
<
td
>
<
pre
>
"
+
escapeText
(
actual
)
+
"
<
/
pre
>
<
/
td
>
<
/
tr
>
"
;
if
(
typeof
details
.
actual
=
=
=
"
number
"
&
&
typeof
details
.
expected
=
=
=
"
number
"
)
{
if
(
!
isNaN
(
details
.
actual
)
&
&
!
isNaN
(
details
.
expected
)
)
{
showDiff
=
true
;
diff
=
details
.
actual
-
details
.
expected
;
diff
=
(
diff
>
0
?
"
+
"
:
"
"
)
+
diff
;
}
}
else
if
(
typeof
details
.
actual
!
=
=
"
boolean
"
&
&
typeof
details
.
expected
!
=
=
"
boolean
"
)
{
diff
=
QUnit
.
diff
(
expected
actual
)
;
showDiff
=
stripHtml
(
diff
)
.
length
!
=
=
stripHtml
(
expected
)
.
length
+
stripHtml
(
actual
)
.
length
;
}
if
(
showDiff
)
{
message
+
=
"
<
tr
class
=
'
test
-
diff
'
>
<
th
>
Diff
:
<
/
th
>
<
td
>
<
pre
>
"
+
diff
+
"
<
/
pre
>
<
/
td
>
<
/
tr
>
"
;
}
}
else
if
(
expected
.
indexOf
(
"
[
object
Array
]
"
)
!
=
=
-
1
|
|
expected
.
indexOf
(
"
[
object
Object
]
"
)
!
=
=
-
1
)
{
message
+
=
"
<
tr
class
=
'
test
-
message
'
>
<
th
>
Message
:
<
/
th
>
<
td
>
"
+
"
Diff
suppressed
as
the
depth
of
object
is
more
than
current
max
depth
(
"
+
QUnit
.
config
.
maxDepth
+
"
)
.
<
p
>
Hint
:
Use
<
code
>
QUnit
.
dump
.
maxDepth
<
/
code
>
to
"
+
"
run
with
a
higher
max
depth
or
<
a
href
=
'
"
+
escapeText
(
setUrl
(
{
maxDepth
:
-
1
}
)
)
+
"
'
>
"
+
"
Rerun
<
/
a
>
without
max
depth
.
<
/
p
>
<
/
td
>
<
/
tr
>
"
;
}
else
{
message
+
=
"
<
tr
class
=
'
test
-
message
'
>
<
th
>
Message
:
<
/
th
>
<
td
>
"
+
"
Diff
suppressed
as
the
expected
and
actual
results
have
an
equivalent
"
+
"
serialization
<
/
td
>
<
/
tr
>
"
;
}
if
(
details
.
source
)
{
message
+
=
"
<
tr
class
=
'
test
-
source
'
>
<
th
>
Source
:
<
/
th
>
<
td
>
<
pre
>
"
+
escapeText
(
details
.
source
)
+
"
<
/
pre
>
<
/
td
>
<
/
tr
>
"
;
}
message
+
=
"
<
/
table
>
"
;
}
else
if
(
!
details
.
result
&
&
details
.
source
)
{
message
+
=
"
<
table
>
"
+
"
<
tr
class
=
'
test
-
source
'
>
<
th
>
Source
:
<
/
th
>
<
td
>
<
pre
>
"
+
escapeText
(
details
.
source
)
+
"
<
/
pre
>
<
/
td
>
<
/
tr
>
"
+
"
<
/
table
>
"
;
}
assertList
=
testItem
.
getElementsByTagName
(
"
ol
"
)
[
0
]
;
assertLi
=
document
1
.
createElement
(
"
li
"
)
;
assertLi
.
className
=
details
.
result
?
"
pass
"
:
"
fail
"
;
assertLi
.
innerHTML
=
message
;
assertList
.
appendChild
(
assertLi
)
;
}
)
;
QUnit
.
testDone
(
function
(
details
)
{
var
testTitle
time
testItem
assertList
good
bad
testCounts
skipped
sourceName
tests
=
id
(
"
qunit
-
tests
"
)
;
if
(
!
tests
)
{
return
;
}
testItem
=
id
(
"
qunit
-
test
-
output
-
"
+
details
.
testId
)
;
assertList
=
testItem
.
getElementsByTagName
(
"
ol
"
)
[
0
]
;
good
=
details
.
passed
;
bad
=
details
.
failed
;
var
testPassed
=
details
.
failed
>
0
?
details
.
todo
:
!
details
.
todo
;
if
(
testPassed
)
{
addClass
(
assertList
"
qunit
-
collapsed
"
)
;
}
else
if
(
config
.
collapse
)
{
if
(
!
collapseNext
)
{
collapseNext
=
true
;
}
else
{
addClass
(
assertList
"
qunit
-
collapsed
"
)
;
}
}
testTitle
=
testItem
.
firstChild
;
testCounts
=
bad
?
"
<
b
class
=
'
failed
'
>
"
+
bad
+
"
<
/
b
>
"
+
"
<
b
class
=
'
passed
'
>
"
+
good
+
"
<
/
b
>
"
:
"
"
;
testTitle
.
innerHTML
+
=
"
<
b
class
=
'
counts
'
>
(
"
+
testCounts
+
details
.
assertions
.
length
+
"
)
<
/
b
>
"
;
if
(
details
.
skipped
)
{
stats
.
skippedTests
+
+
;
testItem
.
className
=
"
skipped
"
;
skipped
=
document
1
.
createElement
(
"
em
"
)
;
skipped
.
className
=
"
qunit
-
skipped
-
label
"
;
skipped
.
innerHTML
=
"
skipped
"
;
testItem
.
insertBefore
(
skipped
testTitle
)
;
}
else
{
addEvent
(
testTitle
"
click
"
function
(
)
{
toggleClass
(
assertList
"
qunit
-
collapsed
"
)
;
}
)
;
testItem
.
className
=
testPassed
?
"
pass
"
:
"
fail
"
;
if
(
details
.
todo
)
{
var
todoLabel
=
document
1
.
createElement
(
"
em
"
)
;
todoLabel
.
className
=
"
qunit
-
todo
-
label
"
;
todoLabel
.
innerHTML
=
"
todo
"
;
testItem
.
className
+
=
"
todo
"
;
testItem
.
insertBefore
(
todoLabel
testTitle
)
;
}
time
=
document
1
.
createElement
(
"
span
"
)
;
time
.
className
=
"
runtime
"
;
time
.
innerHTML
=
details
.
runtime
+
"
ms
"
;
testItem
.
insertBefore
(
time
assertList
)
;
if
(
!
testPassed
)
{
stats
.
failedTests
+
+
;
}
else
if
(
details
.
todo
)
{
stats
.
todoTests
+
+
;
}
else
{
stats
.
passedTests
+
+
;
}
}
if
(
details
.
source
)
{
sourceName
=
document
1
.
createElement
(
"
p
"
)
;
sourceName
.
innerHTML
=
"
<
strong
>
Source
:
<
/
strong
>
"
+
details
.
source
;
addClass
(
sourceName
"
qunit
-
source
"
)
;
if
(
testPassed
)
{
addClass
(
sourceName
"
qunit
-
collapsed
"
)
;
}
addEvent
(
testTitle
"
click
"
function
(
)
{
toggleClass
(
sourceName
"
qunit
-
collapsed
"
)
;
}
)
;
testItem
.
appendChild
(
sourceName
)
;
}
}
)
;
var
notPhantom
=
function
(
p
)
{
return
!
(
p
&
&
p
.
version
&
&
p
.
version
.
major
>
0
)
;
}
(
window
.
phantom
)
;
if
(
notPhantom
&
&
document
1
.
readyState
=
=
=
"
complete
"
)
{
QUnit
.
load
(
)
;
}
else
{
addEvent
(
window
"
load
"
QUnit
.
load
)
;
}
var
originalWindowOnError
=
window
.
onerror
;
window
.
onerror
=
function
(
message
fileName
lineNumber
)
{
var
ret
=
false
;
if
(
originalWindowOnError
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
3
?
_len
-
3
:
0
)
_key
=
3
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
3
]
=
arguments
[
_key
]
;
}
ret
=
originalWindowOnError
.
call
.
apply
(
originalWindowOnError
[
this
message
fileName
lineNumber
]
.
concat
(
args
)
)
;
}
if
(
ret
!
=
=
true
)
{
var
error
=
{
message
:
message
fileName
:
fileName
lineNumber
:
lineNumber
}
;
ret
=
QUnit
.
onError
(
error
)
;
}
return
ret
;
}
;
window
.
addEventListener
(
"
unhandledrejection
"
function
(
event
)
{
QUnit
.
onUnhandledRejection
(
event
.
reason
)
;
}
)
;
}
)
(
)
;
QUnit
.
diff
=
function
(
)
{
function
DiffMatchPatch
(
)
{
}
var
DIFF_DELETE
=
-
1
DIFF_INSERT
=
1
DIFF_EQUAL
=
0
;
DiffMatchPatch
.
prototype
.
DiffMain
=
function
(
text1
text2
optChecklines
)
{
var
deadline
checklines
commonlength
commonprefix
commonsuffix
diffs
;
deadline
=
new
Date
(
)
.
getTime
(
)
+
1000
;
if
(
text1
=
=
=
null
|
|
text2
=
=
=
null
)
{
throw
new
Error
(
"
Null
input
.
(
DiffMain
)
"
)
;
}
if
(
text1
=
=
=
text2
)
{
if
(
text1
)
{
return
[
[
DIFF_EQUAL
text1
]
]
;
}
return
[
]
;
}
if
(
typeof
optChecklines
=
=
=
"
undefined
"
)
{
optChecklines
=
true
;
}
checklines
=
optChecklines
;
commonlength
=
this
.
diffCommonPrefix
(
text1
text2
)
;
commonprefix
=
text1
.
substring
(
0
commonlength
)
;
text1
=
text1
.
substring
(
commonlength
)
;
text2
=
text2
.
substring
(
commonlength
)
;
commonlength
=
this
.
diffCommonSuffix
(
text1
text2
)
;
commonsuffix
=
text1
.
substring
(
text1
.
length
-
commonlength
)
;
text1
=
text1
.
substring
(
0
text1
.
length
-
commonlength
)
;
text2
=
text2
.
substring
(
0
text2
.
length
-
commonlength
)
;
diffs
=
this
.
diffCompute
(
text1
text2
checklines
deadline
)
;
if
(
commonprefix
)
{
diffs
.
unshift
(
[
DIFF_EQUAL
commonprefix
]
)
;
}
if
(
commonsuffix
)
{
diffs
.
push
(
[
DIFF_EQUAL
commonsuffix
]
)
;
}
this
.
diffCleanupMerge
(
diffs
)
;
return
diffs
;
}
;
DiffMatchPatch
.
prototype
.
diffCleanupEfficiency
=
function
(
diffs
)
{
var
changes
equalities
equalitiesLength
lastequality
pointer
preIns
preDel
postIns
postDel
;
changes
=
false
;
equalities
=
[
]
;
equalitiesLength
=
0
;
lastequality
=
null
;
pointer
=
0
;
preIns
=
false
;
preDel
=
false
;
postIns
=
false
;
postDel
=
false
;
while
(
pointer
<
diffs
.
length
)
{
if
(
diffs
[
pointer
]
[
0
]
=
=
=
DIFF_EQUAL
)
{
if
(
diffs
[
pointer
]
[
1
]
.
length
<
4
&
&
(
postIns
|
|
postDel
)
)
{
equalities
[
equalitiesLength
+
+
]
=
pointer
;
preIns
=
postIns
;
preDel
=
postDel
;
lastequality
=
diffs
[
pointer
]
[
1
]
;
}
else
{
equalitiesLength
=
0
;
lastequality
=
null
;
}
postIns
=
postDel
=
false
;
}
else
{
if
(
diffs
[
pointer
]
[
0
]
=
=
=
DIFF_DELETE
)
{
postDel
=
true
;
}
else
{
postIns
=
true
;
}
if
(
lastequality
&
&
(
preIns
&
&
preDel
&
&
postIns
&
&
postDel
|
|
lastequality
.
length
<
2
&
&
preIns
+
preDel
+
postIns
+
postDel
=
=
=
3
)
)
{
diffs
.
splice
(
equalities
[
equalitiesLength
-
1
]
0
[
DIFF_DELETE
lastequality
]
)
;
diffs
[
equalities
[
equalitiesLength
-
1
]
+
1
]
[
0
]
=
DIFF_INSERT
;
equalitiesLength
-
-
;
lastequality
=
null
;
if
(
preIns
&
&
preDel
)
{
postIns
=
postDel
=
true
;
equalitiesLength
=
0
;
}
else
{
equalitiesLength
-
-
;
pointer
=
equalitiesLength
>
0
?
equalities
[
equalitiesLength
-
1
]
:
-
1
;
postIns
=
postDel
=
false
;
}
changes
=
true
;
}
}
pointer
+
+
;
}
if
(
changes
)
{
this
.
diffCleanupMerge
(
diffs
)
;
}
}
;
DiffMatchPatch
.
prototype
.
diffPrettyHtml
=
function
(
diffs
)
{
var
op
data
x
html
=
[
]
;
for
(
x
=
0
;
x
<
diffs
.
length
;
x
+
+
)
{
op
=
diffs
[
x
]
[
0
]
;
data
=
diffs
[
x
]
[
1
]
;
switch
(
op
)
{
case
DIFF_INSERT
:
html
[
x
]
=
"
<
ins
>
"
+
escapeText
(
data
)
+
"
<
/
ins
>
"
;
break
;
case
DIFF_DELETE
:
html
[
x
]
=
"
<
del
>
"
+
escapeText
(
data
)
+
"
<
/
del
>
"
;
break
;
case
DIFF_EQUAL
:
html
[
x
]
=
"
<
span
>
"
+
escapeText
(
data
)
+
"
<
/
span
>
"
;
break
;
}
}
return
html
.
join
(
"
"
)
;
}
;
DiffMatchPatch
.
prototype
.
diffCommonPrefix
=
function
(
text1
text2
)
{
var
pointermid
pointermax
pointermin
pointerstart
;
if
(
!
text1
|
|
!
text2
|
|
text1
.
charAt
(
0
)
!
=
=
text2
.
charAt
(
0
)
)
{
return
0
;
}
pointermin
=
0
;
pointermax
=
Math
.
min
(
text1
.
length
text2
.
length
)
;
pointermid
=
pointermax
;
pointerstart
=
0
;
while
(
pointermin
<
pointermid
)
{
if
(
text1
.
substring
(
pointerstart
pointermid
)
=
=
=
text2
.
substring
(
pointerstart
pointermid
)
)
{
pointermin
=
pointermid
;
pointerstart
=
pointermin
;
}
else
{
pointermax
=
pointermid
;
}
pointermid
=
Math
.
floor
(
(
pointermax
-
pointermin
)
/
2
+
pointermin
)
;
}
return
pointermid
;
}
;
DiffMatchPatch
.
prototype
.
diffCommonSuffix
=
function
(
text1
text2
)
{
var
pointermid
pointermax
pointermin
pointerend
;
if
(
!
text1
|
|
!
text2
|
|
text1
.
charAt
(
text1
.
length
-
1
)
!
=
=
text2
.
charAt
(
text2
.
length
-
1
)
)
{
return
0
;
}
pointermin
=
0
;
pointermax
=
Math
.
min
(
text1
.
length
text2
.
length
)
;
pointermid
=
pointermax
;
pointerend
=
0
;
while
(
pointermin
<
pointermid
)
{
if
(
text1
.
substring
(
text1
.
length
-
pointermid
text1
.
length
-
pointerend
)
=
=
=
text2
.
substring
(
text2
.
length
-
pointermid
text2
.
length
-
pointerend
)
)
{
pointermin
=
pointermid
;
pointerend
=
pointermin
;
}
else
{
pointermax
=
pointermid
;
}
pointermid
=
Math
.
floor
(
(
pointermax
-
pointermin
)
/
2
+
pointermin
)
;
}
return
pointermid
;
}
;
DiffMatchPatch
.
prototype
.
diffCompute
=
function
(
text1
text2
checklines
deadline
)
{
var
diffs
longtext
shorttext
i
hm
text1A
text2A
text1B
text2B
midCommon
diffsA
diffsB
;
if
(
!
text1
)
{
return
[
[
DIFF_INSERT
text2
]
]
;
}
if
(
!
text2
)
{
return
[
[
DIFF_DELETE
text1
]
]
;
}
longtext
=
text1
.
length
>
text2
.
length
?
text1
:
text2
;
shorttext
=
text1
.
length
>
text2
.
length
?
text2
:
text1
;
i
=
longtext
.
indexOf
(
shorttext
)
;
if
(
i
!
=
=
-
1
)
{
diffs
=
[
[
DIFF_INSERT
longtext
.
substring
(
0
i
)
]
[
DIFF_EQUAL
shorttext
]
[
DIFF_INSERT
longtext
.
substring
(
i
+
shorttext
.
length
)
]
]
;
if
(
text1
.
length
>
text2
.
length
)
{
diffs
[
0
]
[
0
]
=
diffs
[
2
]
[
0
]
=
DIFF_DELETE
;
}
return
diffs
;
}
if
(
shorttext
.
length
=
=
=
1
)
{
return
[
[
DIFF_DELETE
text1
]
[
DIFF_INSERT
text2
]
]
;
}
hm
=
this
.
diffHalfMatch
(
text1
text2
)
;
if
(
hm
)
{
text1A
=
hm
[
0
]
;
text1B
=
hm
[
1
]
;
text2A
=
hm
[
2
]
;
text2B
=
hm
[
3
]
;
midCommon
=
hm
[
4
]
;
diffsA
=
this
.
DiffMain
(
text1A
text2A
checklines
deadline
)
;
diffsB
=
this
.
DiffMain
(
text1B
text2B
checklines
deadline
)
;
return
diffsA
.
concat
(
[
[
DIFF_EQUAL
midCommon
]
]
diffsB
)
;
}
if
(
checklines
&
&
text1
.
length
>
100
&
&
text2
.
length
>
100
)
{
return
this
.
diffLineMode
(
text1
text2
deadline
)
;
}
return
this
.
diffBisect
(
text1
text2
deadline
)
;
}
;
DiffMatchPatch
.
prototype
.
diffHalfMatch
=
function
(
text1
text2
)
{
var
longtext
shorttext
dmp
text1A
text2B
text2A
text1B
midCommon
hm1
hm2
hm
;
longtext
=
text1
.
length
>
text2
.
length
?
text1
:
text2
;
shorttext
=
text1
.
length
>
text2
.
length
?
text2
:
text1
;
if
(
longtext
.
length
<
4
|
|
shorttext
.
length
*
2
<
longtext
.
length
)
{
return
null
;
}
dmp
=
this
;
function
diffHalfMatchI
(
longtext
shorttext
i
)
{
var
seed
j
bestCommon
prefixLength
suffixLength
bestLongtextA
bestLongtextB
bestShorttextA
bestShorttextB
;
seed
=
longtext
.
substring
(
i
i
+
Math
.
floor
(
longtext
.
length
/
4
)
)
;
j
=
-
1
;
bestCommon
=
"
"
;
while
(
(
j
=
shorttext
.
indexOf
(
seed
j
+
1
)
)
!
=
=
-
1
)
{
prefixLength
=
dmp
.
diffCommonPrefix
(
longtext
.
substring
(
i
)
shorttext
.
substring
(
j
)
)
;
suffixLength
=
dmp
.
diffCommonSuffix
(
longtext
.
substring
(
0
i
)
shorttext
.
substring
(
0
j
)
)
;
if
(
bestCommon
.
length
<
suffixLength
+
prefixLength
)
{
bestCommon
=
shorttext
.
substring
(
j
-
suffixLength
j
)
+
shorttext
.
substring
(
j
j
+
prefixLength
)
;
bestLongtextA
=
longtext
.
substring
(
0
i
-
suffixLength
)
;
bestLongtextB
=
longtext
.
substring
(
i
+
prefixLength
)
;
bestShorttextA
=
shorttext
.
substring
(
0
j
-
suffixLength
)
;
bestShorttextB
=
shorttext
.
substring
(
j
+
prefixLength
)
;
}
}
if
(
bestCommon
.
length
*
2
>
=
longtext
.
length
)
{
return
[
bestLongtextA
bestLongtextB
bestShorttextA
bestShorttextB
bestCommon
]
;
}
else
{
return
null
;
}
}
hm1
=
diffHalfMatchI
(
longtext
shorttext
Math
.
ceil
(
longtext
.
length
/
4
)
)
;
hm2
=
diffHalfMatchI
(
longtext
shorttext
Math
.
ceil
(
longtext
.
length
/
2
)
)
;
if
(
!
hm1
&
&
!
hm2
)
{
return
null
;
}
else
if
(
!
hm2
)
{
hm
=
hm1
;
}
else
if
(
!
hm1
)
{
hm
=
hm2
;
}
else
{
hm
=
hm1
[
4
]
.
length
>
hm2
[
4
]
.
length
?
hm1
:
hm2
;
}
if
(
text1
.
length
>
text2
.
length
)
{
text1A
=
hm
[
0
]
;
text1B
=
hm
[
1
]
;
text2A
=
hm
[
2
]
;
text2B
=
hm
[
3
]
;
}
else
{
text2A
=
hm
[
0
]
;
text2B
=
hm
[
1
]
;
text1A
=
hm
[
2
]
;
text1B
=
hm
[
3
]
;
}
midCommon
=
hm
[
4
]
;
return
[
text1A
text1B
text2A
text2B
midCommon
]
;
}
;
DiffMatchPatch
.
prototype
.
diffLineMode
=
function
(
text1
text2
deadline
)
{
var
a
diffs
linearray
pointer
countInsert
countDelete
textInsert
textDelete
j
;
a
=
this
.
diffLinesToChars
(
text1
text2
)
;
text1
=
a
.
chars1
;
text2
=
a
.
chars2
;
linearray
=
a
.
lineArray
;
diffs
=
this
.
DiffMain
(
text1
text2
false
deadline
)
;
this
.
diffCharsToLines
(
diffs
linearray
)
;
this
.
diffCleanupSemantic
(
diffs
)
;
diffs
.
push
(
[
DIFF_EQUAL
"
"
]
)
;
pointer
=
0
;
countDelete
=
0
;
countInsert
=
0
;
textDelete
=
"
"
;
textInsert
=
"
"
;
while
(
pointer
<
diffs
.
length
)
{
switch
(
diffs
[
pointer
]
[
0
]
)
{
case
DIFF_INSERT
:
countInsert
+
+
;
textInsert
+
=
diffs
[
pointer
]
[
1
]
;
break
;
case
DIFF_DELETE
:
countDelete
+
+
;
textDelete
+
=
diffs
[
pointer
]
[
1
]
;
break
;
case
DIFF_EQUAL
:
if
(
countDelete
>
=
1
&
&
countInsert
>
=
1
)
{
diffs
.
splice
(
pointer
-
countDelete
-
countInsert
countDelete
+
countInsert
)
;
pointer
=
pointer
-
countDelete
-
countInsert
;
a
=
this
.
DiffMain
(
textDelete
textInsert
false
deadline
)
;
for
(
j
=
a
.
length
-
1
;
j
>
=
0
;
j
-
-
)
{
diffs
.
splice
(
pointer
0
a
[
j
]
)
;
}
pointer
=
pointer
+
a
.
length
;
}
countInsert
=
0
;
countDelete
=
0
;
textDelete
=
"
"
;
textInsert
=
"
"
;
break
;
}
pointer
+
+
;
}
diffs
.
pop
(
)
;
return
diffs
;
}
;
DiffMatchPatch
.
prototype
.
diffBisect
=
function
(
text1
text2
deadline
)
{
var
text1Length
text2Length
maxD
vOffset
vLength
v1
v2
x
delta
front
k1start
k1end
k2start
k2end
k2Offset
k1Offset
x1
x2
y1
y2
d
k1
k2
;
text1Length
=
text1
.
length
;
text2Length
=
text2
.
length
;
maxD
=
Math
.
ceil
(
(
text1Length
+
text2Length
)
/
2
)
;
vOffset
=
maxD
;
vLength
=
2
*
maxD
;
v1
=
new
Array
(
vLength
)
;
v2
=
new
Array
(
vLength
)
;
for
(
x
=
0
;
x
<
vLength
;
x
+
+
)
{
v1
[
x
]
=
-
1
;
v2
[
x
]
=
-
1
;
}
v1
[
vOffset
+
1
]
=
0
;
v2
[
vOffset
+
1
]
=
0
;
delta
=
text1Length
-
text2Length
;
front
=
delta
%
2
!
=
=
0
;
k1start
=
0
;
k1end
=
0
;
k2start
=
0
;
k2end
=
0
;
for
(
d
=
0
;
d
<
maxD
;
d
+
+
)
{
if
(
new
Date
(
)
.
getTime
(
)
>
deadline
)
{
break
;
}
for
(
k1
=
-
d
+
k1start
;
k1
<
=
d
-
k1end
;
k1
+
=
2
)
{
k1Offset
=
vOffset
+
k1
;
if
(
k1
=
=
=
-
d
|
|
k1
!
=
=
d
&
&
v1
[
k1Offset
-
1
]
<
v1
[
k1Offset
+
1
]
)
{
x1
=
v1
[
k1Offset
+
1
]
;
}
else
{
x1
=
v1
[
k1Offset
-
1
]
+
1
;
}
y1
=
x1
-
k1
;
while
(
x1
<
text1Length
&
&
y1
<
text2Length
&
&
text1
.
charAt
(
x1
)
=
=
=
text2
.
charAt
(
y1
)
)
{
x1
+
+
;
y1
+
+
;
}
v1
[
k1Offset
]
=
x1
;
if
(
x1
>
text1Length
)
{
k1end
+
=
2
;
}
else
if
(
y1
>
text2Length
)
{
k1start
+
=
2
;
}
else
if
(
front
)
{
k2Offset
=
vOffset
+
delta
-
k1
;
if
(
k2Offset
>
=
0
&
&
k2Offset
<
vLength
&
&
v2
[
k2Offset
]
!
=
=
-
1
)
{
x2
=
text1Length
-
v2
[
k2Offset
]
;
if
(
x1
>
=
x2
)
{
return
this
.
diffBisectSplit
(
text1
text2
x1
y1
deadline
)
;
}
}
}
}
for
(
k2
=
-
d
+
k2start
;
k2
<
=
d
-
k2end
;
k2
+
=
2
)
{
k2Offset
=
vOffset
+
k2
;
if
(
k2
=
=
=
-
d
|
|
k2
!
=
=
d
&
&
v2
[
k2Offset
-
1
]
<
v2
[
k2Offset
+
1
]
)
{
x2
=
v2
[
k2Offset
+
1
]
;
}
else
{
x2
=
v2
[
k2Offset
-
1
]
+
1
;
}
y2
=
x2
-
k2
;
while
(
x2
<
text1Length
&
&
y2
<
text2Length
&
&
text1
.
charAt
(
text1Length
-
x2
-
1
)
=
=
=
text2
.
charAt
(
text2Length
-
y2
-
1
)
)
{
x2
+
+
;
y2
+
+
;
}
v2
[
k2Offset
]
=
x2
;
if
(
x2
>
text1Length
)
{
k2end
+
=
2
;
}
else
if
(
y2
>
text2Length
)
{
k2start
+
=
2
;
}
else
if
(
!
front
)
{
k1Offset
=
vOffset
+
delta
-
k2
;
if
(
k1Offset
>
=
0
&
&
k1Offset
<
vLength
&
&
v1
[
k1Offset
]
!
=
=
-
1
)
{
x1
=
v1
[
k1Offset
]
;
y1
=
vOffset
+
x1
-
k1Offset
;
x2
=
text1Length
-
x2
;
if
(
x1
>
=
x2
)
{
return
this
.
diffBisectSplit
(
text1
text2
x1
y1
deadline
)
;
}
}
}
}
}
return
[
[
DIFF_DELETE
text1
]
[
DIFF_INSERT
text2
]
]
;
}
;
DiffMatchPatch
.
prototype
.
diffBisectSplit
=
function
(
text1
text2
x
y
deadline
)
{
var
text1a
text1b
text2a
text2b
diffs
diffsb
;
text1a
=
text1
.
substring
(
0
x
)
;
text2a
=
text2
.
substring
(
0
y
)
;
text1b
=
text1
.
substring
(
x
)
;
text2b
=
text2
.
substring
(
y
)
;
diffs
=
this
.
DiffMain
(
text1a
text2a
false
deadline
)
;
diffsb
=
this
.
DiffMain
(
text1b
text2b
false
deadline
)
;
return
diffs
.
concat
(
diffsb
)
;
}
;
DiffMatchPatch
.
prototype
.
diffCleanupSemantic
=
function
(
diffs
)
{
var
changes
equalities
equalitiesLength
lastequality
pointer
lengthInsertions2
lengthDeletions2
lengthInsertions1
lengthDeletions1
deletion
insertion
overlapLength1
overlapLength2
;
changes
=
false
;
equalities
=
[
]
;
equalitiesLength
=
0
;
lastequality
=
null
;
pointer
=
0
;
lengthInsertions1
=
0
;
lengthDeletions1
=
0
;
lengthInsertions2
=
0
;
lengthDeletions2
=
0
;
while
(
pointer
<
diffs
.
length
)
{
if
(
diffs
[
pointer
]
[
0
]
=
=
=
DIFF_EQUAL
)
{
equalities
[
equalitiesLength
+
+
]
=
pointer
;
lengthInsertions1
=
lengthInsertions2
;
lengthDeletions1
=
lengthDeletions2
;
lengthInsertions2
=
0
;
lengthDeletions2
=
0
;
lastequality
=
diffs
[
pointer
]
[
1
]
;
}
else
{
if
(
diffs
[
pointer
]
[
0
]
=
=
=
DIFF_INSERT
)
{
lengthInsertions2
+
=
diffs
[
pointer
]
[
1
]
.
length
;
}
else
{
lengthDeletions2
+
=
diffs
[
pointer
]
[
1
]
.
length
;
}
if
(
lastequality
&
&
lastequality
.
length
<
=
Math
.
max
(
lengthInsertions1
lengthDeletions1
)
&
&
lastequality
.
length
<
=
Math
.
max
(
lengthInsertions2
lengthDeletions2
)
)
{
diffs
.
splice
(
equalities
[
equalitiesLength
-
1
]
0
[
DIFF_DELETE
lastequality
]
)
;
diffs
[
equalities
[
equalitiesLength
-
1
]
+
1
]
[
0
]
=
DIFF_INSERT
;
equalitiesLength
-
-
;
equalitiesLength
-
-
;
pointer
=
equalitiesLength
>
0
?
equalities
[
equalitiesLength
-
1
]
:
-
1
;
lengthInsertions1
=
0
;
lengthDeletions1
=
0
;
lengthInsertions2
=
0
;
lengthDeletions2
=
0
;
lastequality
=
null
;
changes
=
true
;
}
}
pointer
+
+
;
}
if
(
changes
)
{
this
.
diffCleanupMerge
(
diffs
)
;
}
pointer
=
1
;
while
(
pointer
<
diffs
.
length
)
{
if
(
diffs
[
pointer
-
1
]
[
0
]
=
=
=
DIFF_DELETE
&
&
diffs
[
pointer
]
[
0
]
=
=
=
DIFF_INSERT
)
{
deletion
=
diffs
[
pointer
-
1
]
[
1
]
;
insertion
=
diffs
[
pointer
]
[
1
]
;
overlapLength1
=
this
.
diffCommonOverlap
(
deletion
insertion
)
;
overlapLength2
=
this
.
diffCommonOverlap
(
insertion
deletion
)
;
if
(
overlapLength1
>
=
overlapLength2
)
{
if
(
overlapLength1
>
=
deletion
.
length
/
2
|
|
overlapLength1
>
=
insertion
.
length
/
2
)
{
diffs
.
splice
(
pointer
0
[
DIFF_EQUAL
insertion
.
substring
(
0
overlapLength1
)
]
)
;
diffs
[
pointer
-
1
]
[
1
]
=
deletion
.
substring
(
0
deletion
.
length
-
overlapLength1
)
;
diffs
[
pointer
+
1
]
[
1
]
=
insertion
.
substring
(
overlapLength1
)
;
pointer
+
+
;
}
}
else
{
if
(
overlapLength2
>
=
deletion
.
length
/
2
|
|
overlapLength2
>
=
insertion
.
length
/
2
)
{
diffs
.
splice
(
pointer
0
[
DIFF_EQUAL
deletion
.
substring
(
0
overlapLength2
)
]
)
;
diffs
[
pointer
-
1
]
[
0
]
=
DIFF_INSERT
;
diffs
[
pointer
-
1
]
[
1
]
=
insertion
.
substring
(
0
insertion
.
length
-
overlapLength2
)
;
diffs
[
pointer
+
1
]
[
0
]
=
DIFF_DELETE
;
diffs
[
pointer
+
1
]
[
1
]
=
deletion
.
substring
(
overlapLength2
)
;
pointer
+
+
;
}
}
pointer
+
+
;
}
pointer
+
+
;
}
}
;
DiffMatchPatch
.
prototype
.
diffCommonOverlap
=
function
(
text1
text2
)
{
var
text1Length
text2Length
textLength
best
length
pattern
found
;
text1Length
=
text1
.
length
;
text2Length
=
text2
.
length
;
if
(
text1Length
=
=
=
0
|
|
text2Length
=
=
=
0
)
{
return
0
;
}
if
(
text1Length
>
text2Length
)
{
text1
=
text1
.
substring
(
text1Length
-
text2Length
)
;
}
else
if
(
text1Length
<
text2Length
)
{
text2
=
text2
.
substring
(
0
text1Length
)
;
}
textLength
=
Math
.
min
(
text1Length
text2Length
)
;
if
(
text1
=
=
=
text2
)
{
return
textLength
;
}
best
=
0
;
length
=
1
;
while
(
true
)
{
pattern
=
text1
.
substring
(
textLength
-
length
)
;
found
=
text2
.
indexOf
(
pattern
)
;
if
(
found
=
=
=
-
1
)
{
return
best
;
}
length
+
=
found
;
if
(
found
=
=
=
0
|
|
text1
.
substring
(
textLength
-
length
)
=
=
=
text2
.
substring
(
0
length
)
)
{
best
=
length
;
length
+
+
;
}
}
}
;
DiffMatchPatch
.
prototype
.
diffLinesToChars
=
function
(
text1
text2
)
{
var
lineArray
lineHash
chars1
chars2
;
lineArray
=
[
]
;
lineHash
=
{
}
;
lineArray
[
0
]
=
"
"
;
function
diffLinesToCharsMunge
(
text
)
{
var
chars
lineStart
lineEnd
lineArrayLength
line
;
chars
=
"
"
;
lineStart
=
0
;
lineEnd
=
-
1
;
lineArrayLength
=
lineArray
.
length
;
while
(
lineEnd
<
text
.
length
-
1
)
{
lineEnd
=
text
.
indexOf
(
"
\
n
"
lineStart
)
;
if
(
lineEnd
=
=
=
-
1
)
{
lineEnd
=
text
.
length
-
1
;
}
line
=
text
.
substring
(
lineStart
lineEnd
+
1
)
;
lineStart
=
lineEnd
+
1
;
var
lineHashExists
=
lineHash
.
hasOwnProperty
?
lineHash
.
hasOwnProperty
(
line
)
:
lineHash
[
line
]
!
=
=
undefined
;
if
(
lineHashExists
)
{
chars
+
=
String
.
fromCharCode
(
lineHash
[
line
]
)
;
}
else
{
chars
+
=
String
.
fromCharCode
(
lineArrayLength
)
;
lineHash
[
line
]
=
lineArrayLength
;
lineArray
[
lineArrayLength
+
+
]
=
line
;
}
}
return
chars
;
}
chars1
=
diffLinesToCharsMunge
(
text1
)
;
chars2
=
diffLinesToCharsMunge
(
text2
)
;
return
{
chars1
:
chars1
chars2
:
chars2
lineArray
:
lineArray
}
;
}
;
DiffMatchPatch
.
prototype
.
diffCharsToLines
=
function
(
diffs
lineArray
)
{
var
x
chars
text
y
;
for
(
x
=
0
;
x
<
diffs
.
length
;
x
+
+
)
{
chars
=
diffs
[
x
]
[
1
]
;
text
=
[
]
;
for
(
y
=
0
;
y
<
chars
.
length
;
y
+
+
)
{
text
[
y
]
=
lineArray
[
chars
.
charCodeAt
(
y
)
]
;
}
diffs
[
x
]
[
1
]
=
text
.
join
(
"
"
)
;
}
}
;
DiffMatchPatch
.
prototype
.
diffCleanupMerge
=
function
(
diffs
)
{
var
pointer
countDelete
countInsert
textInsert
textDelete
commonlength
changes
diffPointer
position
;
diffs
.
push
(
[
DIFF_EQUAL
"
"
]
)
;
pointer
=
0
;
countDelete
=
0
;
countInsert
=
0
;
textDelete
=
"
"
;
textInsert
=
"
"
;
while
(
pointer
<
diffs
.
length
)
{
switch
(
diffs
[
pointer
]
[
0
]
)
{
case
DIFF_INSERT
:
countInsert
+
+
;
textInsert
+
=
diffs
[
pointer
]
[
1
]
;
pointer
+
+
;
break
;
case
DIFF_DELETE
:
countDelete
+
+
;
textDelete
+
=
diffs
[
pointer
]
[
1
]
;
pointer
+
+
;
break
;
case
DIFF_EQUAL
:
if
(
countDelete
+
countInsert
>
1
)
{
if
(
countDelete
!
=
=
0
&
&
countInsert
!
=
=
0
)
{
commonlength
=
this
.
diffCommonPrefix
(
textInsert
textDelete
)
;
if
(
commonlength
!
=
=
0
)
{
if
(
pointer
-
countDelete
-
countInsert
>
0
&
&
diffs
[
pointer
-
countDelete
-
countInsert
-
1
]
[
0
]
=
=
=
DIFF_EQUAL
)
{
diffs
[
pointer
-
countDelete
-
countInsert
-
1
]
[
1
]
+
=
textInsert
.
substring
(
0
commonlength
)
;
}
else
{
diffs
.
splice
(
0
0
[
DIFF_EQUAL
textInsert
.
substring
(
0
commonlength
)
]
)
;
pointer
+
+
;
}
textInsert
=
textInsert
.
substring
(
commonlength
)
;
textDelete
=
textDelete
.
substring
(
commonlength
)
;
}
commonlength
=
this
.
diffCommonSuffix
(
textInsert
textDelete
)
;
if
(
commonlength
!
=
=
0
)
{
diffs
[
pointer
]
[
1
]
=
textInsert
.
substring
(
textInsert
.
length
-
commonlength
)
+
diffs
[
pointer
]
[
1
]
;
textInsert
=
textInsert
.
substring
(
0
textInsert
.
length
-
commonlength
)
;
textDelete
=
textDelete
.
substring
(
0
textDelete
.
length
-
commonlength
)
;
}
}
if
(
countDelete
=
=
=
0
)
{
diffs
.
splice
(
pointer
-
countInsert
countDelete
+
countInsert
[
DIFF_INSERT
textInsert
]
)
;
}
else
if
(
countInsert
=
=
=
0
)
{
diffs
.
splice
(
pointer
-
countDelete
countDelete
+
countInsert
[
DIFF_DELETE
textDelete
]
)
;
}
else
{
diffs
.
splice
(
pointer
-
countDelete
-
countInsert
countDelete
+
countInsert
[
DIFF_DELETE
textDelete
]
[
DIFF_INSERT
textInsert
]
)
;
}
pointer
=
pointer
-
countDelete
-
countInsert
+
(
countDelete
?
1
:
0
)
+
(
countInsert
?
1
:
0
)
+
1
;
}
else
if
(
pointer
!
=
=
0
&
&
diffs
[
pointer
-
1
]
[
0
]
=
=
=
DIFF_EQUAL
)
{
diffs
[
pointer
-
1
]
[
1
]
+
=
diffs
[
pointer
]
[
1
]
;
diffs
.
splice
(
pointer
1
)
;
}
else
{
pointer
+
+
;
}
countInsert
=
0
;
countDelete
=
0
;
textDelete
=
"
"
;
textInsert
=
"
"
;
break
;
}
}
if
(
diffs
[
diffs
.
length
-
1
]
[
1
]
=
=
=
"
"
)
{
diffs
.
pop
(
)
;
}
changes
=
false
;
pointer
=
1
;
while
(
pointer
<
diffs
.
length
-
1
)
{
if
(
diffs
[
pointer
-
1
]
[
0
]
=
=
=
DIFF_EQUAL
&
&
diffs
[
pointer
+
1
]
[
0
]
=
=
=
DIFF_EQUAL
)
{
diffPointer
=
diffs
[
pointer
]
[
1
]
;
position
=
diffPointer
.
substring
(
diffPointer
.
length
-
diffs
[
pointer
-
1
]
[
1
]
.
length
)
;
if
(
position
=
=
=
diffs
[
pointer
-
1
]
[
1
]
)
{
diffs
[
pointer
]
[
1
]
=
diffs
[
pointer
-
1
]
[
1
]
+
diffs
[
pointer
]
[
1
]
.
substring
(
0
diffs
[
pointer
]
[
1
]
.
length
-
diffs
[
pointer
-
1
]
[
1
]
.
length
)
;
diffs
[
pointer
+
1
]
[
1
]
=
diffs
[
pointer
-
1
]
[
1
]
+
diffs
[
pointer
+
1
]
[
1
]
;
diffs
.
splice
(
pointer
-
1
1
)
;
changes
=
true
;
}
else
if
(
diffPointer
.
substring
(
0
diffs
[
pointer
+
1
]
[
1
]
.
length
)
=
=
=
diffs
[
pointer
+
1
]
[
1
]
)
{
diffs
[
pointer
-
1
]
[
1
]
+
=
diffs
[
pointer
+
1
]
[
1
]
;
diffs
[
pointer
]
[
1
]
=
diffs
[
pointer
]
[
1
]
.
substring
(
diffs
[
pointer
+
1
]
[
1
]
.
length
)
+
diffs
[
pointer
+
1
]
[
1
]
;
diffs
.
splice
(
pointer
+
1
1
)
;
changes
=
true
;
}
}
pointer
+
+
;
}
if
(
changes
)
{
this
.
diffCleanupMerge
(
diffs
)
;
}
}
;
return
function
(
o
n
)
{
var
diff
output
text
;
diff
=
new
DiffMatchPatch
(
)
;
output
=
diff
.
DiffMain
(
o
n
)
;
diff
.
diffCleanupEfficiency
(
output
)
;
text
=
diff
.
diffPrettyHtml
(
output
)
;
return
text
;
}
;
}
(
)
;
}
(
(
function
(
)
{
return
this
;
}
(
)
)
)
)
;
(
function
(
)
{
QUnit
.
config
.
autostart
=
false
;
QUnit
.
config
.
urlConfig
.
push
(
{
id
:
'
nocontainer
'
label
:
'
Hide
container
'
}
)
;
QUnit
.
config
.
urlConfig
.
push
(
{
id
:
'
nolint
'
label
:
'
Disable
Linting
'
}
)
;
QUnit
.
config
.
urlConfig
.
push
(
{
id
:
'
dockcontainer
'
label
:
'
Dock
container
'
}
)
;
QUnit
.
config
.
urlConfig
.
push
(
{
id
:
'
devmode
'
label
:
'
Development
mode
'
}
)
;
QUnit
.
config
.
testTimeout
=
QUnit
.
urlParams
.
devmode
?
null
:
60000
;
}
)
(
)
;
define
(
'
ember
/
test
-
helpers
/
-
utils
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
nextTickPromise
=
nextTickPromise
;
exports
.
runDestroyablesFor
=
runDestroyablesFor
;
const
nextTick
=
exports
.
nextTick
=
setTimeout
;
const
futureTick
=
exports
.
futureTick
=
setTimeout
;
function
nextTickPromise
(
)
{
return
new
Ember
.
RSVP
.
Promise
(
resolve
=
>
{
nextTick
(
resolve
)
;
}
)
;
}
function
runDestroyablesFor
(
object
property
)
{
let
destroyables
=
object
[
property
]
;
if
(
!
destroyables
)
{
return
;
}
for
(
let
i
=
0
;
i
<
destroyables
.
length
;
i
+
+
)
{
destroyables
[
i
]
(
)
;
}
delete
object
[
property
]
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
application
'
[
'
exports
'
'
ember
/
test
-
helpers
/
resolver
'
]
function
(
exports
_resolver
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
setApplication
=
setApplication
;
exports
.
getApplication
=
getApplication
;
var
__application__
;
function
setApplication
(
application
)
{
__application__
=
application
;
if
(
!
(
0
_resolver
.
getResolver
)
(
)
)
{
let
Resolver
=
application
.
Resolver
;
let
resolver
=
Resolver
.
create
(
{
namespace
:
application
}
)
;
(
0
_resolver
.
setResolver
)
(
resolver
)
;
}
}
function
getApplication
(
)
{
return
__application__
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
build
-
owner
'
[
'
exports
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
build
-
registry
'
]
function
(
exports
_buildRegistry
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
buildOwner
;
function
buildOwner
(
application
resolver
)
{
if
(
application
)
{
return
application
.
boot
(
)
.
then
(
app
=
>
app
.
buildInstance
(
)
.
boot
(
)
)
;
}
if
(
!
resolver
)
{
throw
new
Error
(
'
You
must
set
up
the
ember
-
test
-
helpers
environment
with
either
setResolver
or
setApplication
before
running
any
tests
.
'
)
;
}
let
{
owner
}
=
(
0
_buildRegistry
.
default
)
(
resolver
)
;
return
Ember
.
RSVP
.
Promise
.
resolve
(
owner
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
get
-
root
-
element
'
]
function
(
exports
_getRootElement
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
getElement
;
function
getElement
(
target
)
{
if
(
target
.
nodeType
=
=
=
Node
.
ELEMENT_NODE
|
|
target
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
|
|
target
instanceof
Window
)
{
return
target
;
}
else
if
(
typeof
target
=
=
=
'
string
'
)
{
let
rootElement
=
(
0
_getRootElement
.
default
)
(
)
;
return
rootElement
.
querySelector
(
target
)
;
}
else
{
throw
new
Error
(
'
Must
use
an
element
or
a
selector
string
'
)
;
}
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
-
get
-
elements
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
get
-
root
-
element
'
]
function
(
exports
_getRootElement
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
getElements
;
function
getElements
(
target
)
{
if
(
typeof
target
=
=
=
'
string
'
)
{
let
rootElement
=
(
0
_getRootElement
.
default
)
(
)
;
return
rootElement
.
querySelectorAll
(
target
)
;
}
else
{
throw
new
Error
(
'
Must
use
a
selector
string
'
)
;
}
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
-
is
-
focusable
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
is
-
form
-
control
'
]
function
(
exports
_isFormControl
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
isFocusable
;
const
FOCUSABLE_TAGS
=
[
'
A
'
]
;
function
isFocusable
(
element
)
{
if
(
(
0
_isFormControl
.
default
)
(
element
)
|
|
element
.
isContentEditable
|
|
FOCUSABLE_TAGS
.
indexOf
(
element
.
tagName
)
>
-
1
)
{
return
true
;
}
return
element
.
hasAttribute
(
'
tabindex
'
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
-
is
-
form
-
control
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
isFormControl
;
const
FORM_CONTROL_TAGS
=
[
'
INPUT
'
'
BUTTON
'
'
SELECT
'
'
TEXTAREA
'
]
;
function
isFormControl
(
element
)
{
let
{
tagName
type
}
=
element
;
if
(
type
=
=
=
'
hidden
'
)
{
return
false
;
}
return
FORM_CONTROL_TAGS
.
indexOf
(
tagName
)
>
-
1
;
}
}
)
;
define
(
"
ember
/
test
-
helpers
/
dom
/
-
to
-
array
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
toArray
;
function
toArray
(
nodelist
)
{
let
array
=
new
Array
(
nodelist
.
length
)
;
for
(
let
i
=
0
;
i
<
nodelist
.
length
;
i
+
+
)
{
array
[
i
]
=
nodelist
[
i
]
;
}
return
array
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
blur
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
dom
/
-
is
-
focusable
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_getElement
_fireEvent
_settled
_isFocusable
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
__blur__
=
__blur__
;
exports
.
default
=
blur
;
function
__blur__
(
element
)
{
let
browserIsNotFocused
=
document
.
hasFocus
&
&
!
document
.
hasFocus
(
)
;
element
.
blur
(
)
;
if
(
browserIsNotFocused
)
{
(
0
_fireEvent
.
default
)
(
element
'
blur
'
{
bubbles
:
false
}
)
;
(
0
_fireEvent
.
default
)
(
element
'
focusout
'
)
;
}
}
function
blur
(
target
=
document
.
activeElement
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
let
element
=
(
0
_getElement
.
default
)
(
target
)
;
if
(
!
element
)
{
throw
new
Error
(
Element
not
found
when
calling
\
blur
(
'
{
target
}
'
)
\
.
)
;
}
if
(
!
(
0
_isFocusable
.
default
)
(
element
)
)
{
throw
new
Error
(
{
target
}
is
not
focusable
)
;
}
__blur__
(
element
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
click
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
'
ember
/
test
-
helpers
/
dom
/
focus
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
dom
/
-
is
-
focusable
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_getElement
_fireEvent
_focus
_settled
_isFocusable
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
__click__
=
__click__
;
exports
.
default
=
click
;
function
__click__
(
element
)
{
(
0
_fireEvent
.
default
)
(
element
'
mousedown
'
)
;
if
(
(
0
_isFocusable
.
default
)
(
element
)
)
{
(
0
_focus
.
__focus__
)
(
element
)
;
}
(
0
_fireEvent
.
default
)
(
element
'
mouseup
'
)
;
(
0
_fireEvent
.
default
)
(
element
'
click
'
)
;
}
function
click
(
target
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
if
(
!
target
)
{
throw
new
Error
(
'
Must
pass
an
element
or
selector
to
click
.
'
)
;
}
let
element
=
(
0
_getElement
.
default
)
(
target
)
;
if
(
!
element
)
{
throw
new
Error
(
Element
not
found
when
calling
\
click
(
'
{
target
}
'
)
\
.
)
;
}
__click__
(
element
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
fill
-
in
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
-
is
-
form
-
control
'
'
ember
/
test
-
helpers
/
dom
/
focus
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_getElement
_isFormControl
_focus
_settled
_fireEvent
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
fillIn
;
function
fillIn
(
target
text
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
if
(
!
target
)
{
throw
new
Error
(
'
Must
pass
an
element
or
selector
to
fillIn
.
'
)
;
}
let
element
=
(
0
_getElement
.
default
)
(
target
)
;
if
(
!
element
)
{
throw
new
Error
(
Element
not
found
when
calling
\
fillIn
(
'
{
target
}
'
)
\
.
)
;
}
let
isControl
=
(
0
_isFormControl
.
default
)
(
element
)
;
if
(
!
isControl
&
&
!
element
.
isContentEditable
)
{
throw
new
Error
(
'
fillIn
is
only
usable
on
form
controls
or
contenteditable
elements
.
'
)
;
}
if
(
typeof
text
=
=
=
'
undefined
'
|
|
text
=
=
=
null
)
{
throw
new
Error
(
'
Must
provide
text
when
calling
fillIn
.
'
)
;
}
(
0
_focus
.
__focus__
)
(
element
)
;
if
(
isControl
)
{
element
.
value
=
text
;
}
else
{
element
.
innerHTML
=
text
;
}
(
0
_fireEvent
.
default
)
(
element
'
input
'
)
;
(
0
_fireEvent
.
default
)
(
element
'
change
'
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
find
-
all
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
elements
'
'
ember
/
test
-
helpers
/
dom
/
-
to
-
array
'
]
function
(
exports
_getElements
_toArray
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
find
;
function
find
(
selector
)
{
if
(
!
selector
)
{
throw
new
Error
(
'
Must
pass
a
selector
to
findAll
.
'
)
;
}
return
(
0
_toArray
.
default
)
(
(
0
_getElements
.
default
)
(
selector
)
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
find
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
]
function
(
exports
_getElement
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
find
;
function
find
(
selector
)
{
if
(
!
selector
)
{
throw
new
Error
(
'
Must
pass
a
selector
to
find
.
'
)
;
}
return
(
0
_getElement
.
default
)
(
selector
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
fireEvent
;
const
DEFAULT_EVENT_OPTIONS
=
{
bubbles
:
true
cancelable
:
true
}
;
const
KEYBOARD_EVENT_TYPES
=
exports
.
KEYBOARD_EVENT_TYPES
=
Object
.
freeze
(
[
'
keydown
'
'
keypress
'
'
keyup
'
]
)
;
const
MOUSE_EVENT_TYPES
=
[
'
click
'
'
mousedown
'
'
mouseup
'
'
dblclick
'
'
mouseenter
'
'
mouseleave
'
'
mousemove
'
'
mouseout
'
'
mouseover
'
]
;
const
FILE_SELECTION_EVENT_TYPES
=
[
'
change
'
]
;
function
fireEvent
(
element
eventType
options
=
{
}
)
{
if
(
!
element
)
{
throw
new
Error
(
'
Must
pass
an
element
to
fireEvent
'
)
;
}
let
event
;
if
(
KEYBOARD_EVENT_TYPES
.
indexOf
(
eventType
)
>
-
1
)
{
event
=
buildKeyboardEvent
(
eventType
options
)
;
}
else
if
(
MOUSE_EVENT_TYPES
.
indexOf
(
eventType
)
>
-
1
)
{
let
rect
;
if
(
element
instanceof
Window
)
{
rect
=
element
.
document
.
documentElement
.
getBoundingClientRect
(
)
;
}
else
if
(
element
.
nodeType
=
=
=
Node
.
DOCUMENT_NODE
)
{
rect
=
element
.
documentElement
.
getBoundingClientRect
(
)
;
}
else
if
(
element
.
nodeType
=
=
=
Node
.
ELEMENT_NODE
)
{
rect
=
element
.
getBoundingClientRect
(
)
;
}
else
{
return
;
}
let
x
=
rect
.
left
+
1
;
let
y
=
rect
.
top
+
1
;
let
simulatedCoordinates
=
{
screenX
:
x
+
5
screenY
:
y
+
95
clientX
:
x
clientY
:
y
}
;
event
=
buildMouseEvent
(
eventType
Ember
.
merge
(
simulatedCoordinates
options
)
)
;
}
else
if
(
FILE_SELECTION_EVENT_TYPES
.
indexOf
(
eventType
)
>
-
1
&
&
element
.
files
)
{
event
=
buildFileEvent
(
eventType
element
options
)
;
}
else
{
event
=
buildBasicEvent
(
eventType
options
)
;
}
element
.
dispatchEvent
(
event
)
;
return
event
;
}
function
buildBasicEvent
(
type
options
=
{
}
)
{
let
event
=
document
.
createEvent
(
'
Events
'
)
;
let
bubbles
=
options
.
bubbles
!
=
=
undefined
?
options
.
bubbles
:
true
;
let
cancelable
=
options
.
cancelable
!
=
=
undefined
?
options
.
cancelable
:
true
;
delete
options
.
bubbles
;
delete
options
.
cancelable
;
event
.
initEvent
(
type
bubbles
cancelable
)
;
Ember
.
merge
(
event
options
)
;
return
event
;
}
function
buildMouseEvent
(
type
options
=
{
}
)
{
let
event
;
try
{
event
=
document
.
createEvent
(
'
MouseEvents
'
)
;
let
eventOpts
=
Ember
.
merge
(
Ember
.
merge
(
{
}
DEFAULT_EVENT_OPTIONS
)
options
)
;
event
.
initMouseEvent
(
type
eventOpts
.
bubbles
eventOpts
.
cancelable
window
eventOpts
.
detail
eventOpts
.
screenX
eventOpts
.
screenY
eventOpts
.
clientX
eventOpts
.
clientY
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
button
eventOpts
.
relatedTarget
)
;
}
catch
(
e
)
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
function
buildKeyboardEvent
(
type
options
=
{
}
)
{
let
eventOpts
=
Ember
.
merge
(
Ember
.
merge
(
{
}
DEFAULT_EVENT_OPTIONS
)
options
)
;
let
event
eventMethodName
;
try
{
event
=
new
KeyboardEvent
(
type
eventOpts
)
;
Object
.
defineProperty
(
event
'
keyCode
'
{
get
(
)
{
return
parseInt
(
this
.
key
)
;
}
}
)
;
Object
.
defineProperty
(
event
'
which
'
{
get
(
)
{
return
parseInt
(
this
.
key
)
;
}
}
)
;
return
event
;
}
catch
(
e
)
{
}
try
{
event
=
document
.
createEvent
(
'
KeyboardEvents
'
)
;
eventMethodName
=
'
initKeyboardEvent
'
;
}
catch
(
e
)
{
}
if
(
!
event
)
{
try
{
event
=
document
.
createEvent
(
'
KeyEvents
'
)
;
eventMethodName
=
'
initKeyEvent
'
;
}
catch
(
e
)
{
}
}
if
(
event
)
{
event
[
eventMethodName
]
(
type
eventOpts
.
bubbles
eventOpts
.
cancelable
window
eventOpts
.
ctrlKey
eventOpts
.
altKey
eventOpts
.
shiftKey
eventOpts
.
metaKey
eventOpts
.
keyCode
eventOpts
.
charCode
)
;
}
else
{
event
=
buildBasicEvent
(
type
options
)
;
}
return
event
;
}
function
buildFileEvent
(
type
element
files
=
[
]
)
{
let
event
=
buildBasicEvent
(
type
)
;
if
(
files
.
length
>
0
)
{
Object
.
defineProperty
(
files
'
item
'
{
value
(
index
)
{
return
typeof
index
=
=
=
'
number
'
?
this
[
index
]
:
null
;
}
}
)
;
Object
.
defineProperty
(
element
'
files
'
{
value
:
files
configurable
:
true
}
)
;
}
Object
.
defineProperty
(
event
'
target
'
{
value
:
element
}
)
;
return
event
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
focus
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
dom
/
-
is
-
focusable
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_getElement
_fireEvent
_settled
_isFocusable
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
__focus__
=
__focus__
;
exports
.
default
=
focus
;
function
__focus__
(
element
)
{
let
browserIsNotFocused
=
document
.
hasFocus
&
&
!
document
.
hasFocus
(
)
;
element
.
focus
(
)
;
if
(
browserIsNotFocused
)
{
(
0
_fireEvent
.
default
)
(
element
'
focus
'
{
bubbles
:
false
}
)
;
(
0
_fireEvent
.
default
)
(
element
'
focusin
'
)
;
}
}
function
focus
(
target
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
if
(
!
target
)
{
throw
new
Error
(
'
Must
pass
an
element
or
selector
to
focus
.
'
)
;
}
let
element
=
(
0
_getElement
.
default
)
(
target
)
;
if
(
!
element
)
{
throw
new
Error
(
Element
not
found
when
calling
\
focus
(
'
{
target
}
'
)
\
.
)
;
}
if
(
!
(
0
_isFocusable
.
default
)
(
element
)
)
{
throw
new
Error
(
{
target
}
is
not
focusable
)
;
}
__focus__
(
element
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
get
-
root
-
element
'
[
'
exports
'
'
ember
/
test
-
helpers
/
setup
-
context
'
]
function
(
exports
_setupContext
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
getRootElement
;
function
getRootElement
(
)
{
let
context
=
(
0
_setupContext
.
getContext
)
(
)
;
let
owner
=
context
&
&
context
.
owner
;
if
(
!
owner
)
{
throw
new
Error
(
'
Must
setup
rendering
context
before
attempting
to
interact
with
elements
.
'
)
;
}
let
rootElementSelector
;
if
(
owner
&
&
owner
.
_emberTestHelpersMockOwner
=
=
=
undefined
)
{
rootElementSelector
=
owner
.
rootElement
;
}
else
{
rootElementSelector
=
'
#
ember
-
testing
'
;
}
let
rootElement
=
document
.
querySelector
(
rootElementSelector
)
;
return
rootElement
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
tap
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
'
ember
/
test
-
helpers
/
dom
/
click
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_getElement
_fireEvent
_click
_settled
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
tap
;
function
tap
(
target
options
=
{
}
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
if
(
!
target
)
{
throw
new
Error
(
'
Must
pass
an
element
or
selector
to
tap
.
'
)
;
}
let
element
=
(
0
_getElement
.
default
)
(
target
)
;
if
(
!
element
)
{
throw
new
Error
(
Element
not
found
when
calling
\
tap
(
'
{
target
}
'
)
\
.
)
;
}
let
touchstartEv
=
(
0
_fireEvent
.
default
)
(
element
'
touchstart
'
options
)
;
let
touchendEv
=
(
0
_fireEvent
.
default
)
(
element
'
touchend
'
options
)
;
if
(
!
touchstartEv
.
defaultPrevented
&
&
!
touchendEv
.
defaultPrevented
)
{
(
0
_click
.
__click__
)
(
element
)
;
}
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
trigger
-
event
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_getElement
_fireEvent
_settled
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
triggerEvent
;
function
triggerEvent
(
target
eventType
options
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
if
(
!
target
)
{
throw
new
Error
(
'
Must
pass
an
element
or
selector
to
triggerEvent
.
'
)
;
}
let
element
=
(
0
_getElement
.
default
)
(
target
)
;
if
(
!
element
)
{
throw
new
Error
(
Element
not
found
when
calling
\
triggerEvent
(
'
{
target
}
'
.
.
.
)
\
.
)
;
}
if
(
!
eventType
)
{
throw
new
Error
(
Must
provide
an
\
eventType
\
to
\
triggerEvent
\
)
;
}
(
0
_fireEvent
.
default
)
(
element
eventType
options
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
trigger
-
key
-
event
'
[
'
exports
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
fire
-
event
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_getElement
_fireEvent
_settled
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
triggerKeyEvent
;
const
DEFAULT_MODIFIERS
=
Object
.
freeze
(
{
ctrlKey
:
false
altKey
:
false
shiftKey
:
false
metaKey
:
false
}
)
;
function
triggerKeyEvent
(
target
eventType
keyCode
modifiers
=
DEFAULT_MODIFIERS
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
if
(
!
target
)
{
throw
new
Error
(
'
Must
pass
an
element
or
selector
to
triggerKeyEvent
.
'
)
;
}
let
element
=
(
0
_getElement
.
default
)
(
target
)
;
if
(
!
element
)
{
throw
new
Error
(
Element
not
found
when
calling
\
triggerKeyEvent
(
'
{
target
}
'
.
.
.
)
\
.
)
;
}
if
(
!
eventType
)
{
throw
new
Error
(
Must
provide
an
\
eventType
\
to
\
triggerKeyEvent
\
)
;
}
if
(
_fireEvent
.
KEYBOARD_EVENT_TYPES
.
indexOf
(
eventType
)
=
=
=
-
1
)
{
let
validEventTypes
=
_fireEvent
.
KEYBOARD_EVENT_TYPES
.
join
(
'
'
)
;
throw
new
Error
(
Must
provide
an
\
eventType
\
of
{
validEventTypes
}
to
\
triggerKeyEvent
\
but
you
passed
\
{
eventType
}
\
.
)
;
}
if
(
!
keyCode
)
{
throw
new
Error
(
Must
provide
a
\
keyCode
\
to
\
triggerKeyEvent
\
)
;
}
let
options
=
Ember
.
merge
(
{
keyCode
which
:
keyCode
key
:
keyCode
}
modifiers
)
;
(
0
_fireEvent
.
default
)
(
element
eventType
options
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
dom
/
wait
-
for
'
[
'
exports
'
'
ember
/
test
-
helpers
/
wait
-
until
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
element
'
'
ember
/
test
-
helpers
/
dom
/
-
get
-
elements
'
'
ember
/
test
-
helpers
/
dom
/
-
to
-
array
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_waitUntil
_getElement
_getElements
_toArray
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
waitFor
;
function
waitFor
(
selector
{
timeout
=
1000
count
=
null
}
=
{
}
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
if
(
!
selector
)
{
throw
new
Error
(
'
Must
pass
a
selector
to
waitFor
.
'
)
;
}
let
callback
;
if
(
count
!
=
=
null
)
{
callback
=
(
)
=
>
{
let
elements
=
(
0
_getElements
.
default
)
(
selector
)
;
if
(
elements
.
length
=
=
=
count
)
{
return
(
0
_toArray
.
default
)
(
elements
)
;
}
}
;
}
else
{
callback
=
(
)
=
>
(
0
_getElement
.
default
)
(
selector
)
;
}
return
(
0
_waitUntil
.
default
)
(
callback
{
timeout
}
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
global
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
(
(
)
=
>
{
if
(
typeof
self
!
=
=
'
undefined
'
)
{
return
self
;
}
else
if
(
typeof
window
!
=
=
'
undefined
'
)
{
return
window
;
}
else
if
(
typeof
global
!
=
=
'
undefined
'
)
{
return
global
;
}
else
{
return
Function
(
'
return
this
'
)
(
)
;
}
}
)
(
)
;
}
)
;
define
(
'
ember
/
test
-
helpers
/
has
-
ember
-
version
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
hasEmberVersion
;
function
hasEmberVersion
(
major
minor
)
{
var
numbers
=
Ember
.
VERSION
.
split
(
'
-
'
)
[
0
]
.
split
(
'
.
'
)
;
var
actualMajor
=
parseInt
(
numbers
[
0
]
10
)
;
var
actualMinor
=
parseInt
(
numbers
[
1
]
10
)
;
return
actualMajor
>
major
|
|
actualMajor
=
=
=
major
&
&
actualMinor
>
=
minor
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
index
'
[
'
exports
'
'
ember
/
test
-
helpers
/
resolver
'
'
ember
/
test
-
helpers
/
application
'
'
ember
/
test
-
helpers
/
setup
-
context
'
'
ember
/
test
-
helpers
/
teardown
-
context
'
'
ember
/
test
-
helpers
/
setup
-
rendering
-
context
'
'
ember
/
test
-
helpers
/
teardown
-
rendering
-
context
'
'
ember
/
test
-
helpers
/
setup
-
application
-
context
'
'
ember
/
test
-
helpers
/
teardown
-
application
-
context
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
wait
-
until
'
'
ember
/
test
-
helpers
/
validate
-
error
-
handler
'
'
ember
/
test
-
helpers
/
dom
/
click
'
'
ember
/
test
-
helpers
/
dom
/
tap
'
'
ember
/
test
-
helpers
/
dom
/
focus
'
'
ember
/
test
-
helpers
/
dom
/
blur
'
'
ember
/
test
-
helpers
/
dom
/
trigger
-
event
'
'
ember
/
test
-
helpers
/
dom
/
trigger
-
key
-
event
'
'
ember
/
test
-
helpers
/
dom
/
fill
-
in
'
'
ember
/
test
-
helpers
/
dom
/
wait
-
for
'
'
ember
/
test
-
helpers
/
dom
/
get
-
root
-
element
'
'
ember
/
test
-
helpers
/
dom
/
find
'
'
ember
/
test
-
helpers
/
dom
/
find
-
all
'
]
function
(
exports
_resolver
_application
_setupContext
_teardownContext
_setupRenderingContext
_teardownRenderingContext
_setupApplicationContext
_teardownApplicationContext
_settled
_waitUntil
_validateErrorHandler
_click
_tap
_focus
_blur
_triggerEvent
_triggerKeyEvent
_fillIn
_waitFor
_getRootElement
_find
_findAll
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
setResolver
'
{
enumerable
:
true
get
:
function
(
)
{
return
_resolver
.
setResolver
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getResolver
'
{
enumerable
:
true
get
:
function
(
)
{
return
_resolver
.
getResolver
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getApplication
'
{
enumerable
:
true
get
:
function
(
)
{
return
_application
.
getApplication
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setApplication
'
{
enumerable
:
true
get
:
function
(
)
{
return
_application
.
setApplication
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupContext
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupContext
.
getContext
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupContext
.
setContext
;
}
}
)
;
Object
.
defineProperty
(
exports
'
unsetContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupContext
.
unsetContext
;
}
}
)
;
Object
.
defineProperty
(
exports
'
pauseTest
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupContext
.
pauseTest
;
}
}
)
;
Object
.
defineProperty
(
exports
'
resumeTest
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupContext
.
resumeTest
;
}
}
)
;
Object
.
defineProperty
(
exports
'
teardownContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_teardownContext
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupRenderingContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupRenderingContext
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
render
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupRenderingContext
.
render
;
}
}
)
;
Object
.
defineProperty
(
exports
'
clearRender
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupRenderingContext
.
clearRender
;
}
}
)
;
Object
.
defineProperty
(
exports
'
teardownRenderingContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_teardownRenderingContext
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupApplicationContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupApplicationContext
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
visit
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupApplicationContext
.
visit
;
}
}
)
;
Object
.
defineProperty
(
exports
'
currentRouteName
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupApplicationContext
.
currentRouteName
;
}
}
)
;
Object
.
defineProperty
(
exports
'
currentURL
'
{
enumerable
:
true
get
:
function
(
)
{
return
_setupApplicationContext
.
currentURL
;
}
}
)
;
Object
.
defineProperty
(
exports
'
teardownApplicationContext
'
{
enumerable
:
true
get
:
function
(
)
{
return
_teardownApplicationContext
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
settled
'
{
enumerable
:
true
get
:
function
(
)
{
return
_settled
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
isSettled
'
{
enumerable
:
true
get
:
function
(
)
{
return
_settled
.
isSettled
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getSettledState
'
{
enumerable
:
true
get
:
function
(
)
{
return
_settled
.
getSettledState
;
}
}
)
;
Object
.
defineProperty
(
exports
'
waitUntil
'
{
enumerable
:
true
get
:
function
(
)
{
return
_waitUntil
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
validateErrorHandler
'
{
enumerable
:
true
get
:
function
(
)
{
return
_validateErrorHandler
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
click
'
{
enumerable
:
true
get
:
function
(
)
{
return
_click
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
tap
'
{
enumerable
:
true
get
:
function
(
)
{
return
_tap
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
focus
'
{
enumerable
:
true
get
:
function
(
)
{
return
_focus
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
blur
'
{
enumerable
:
true
get
:
function
(
)
{
return
_blur
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
triggerEvent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_triggerEvent
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
triggerKeyEvent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_triggerKeyEvent
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
fillIn
'
{
enumerable
:
true
get
:
function
(
)
{
return
_fillIn
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
waitFor
'
{
enumerable
:
true
get
:
function
(
)
{
return
_waitFor
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
getRootElement
'
{
enumerable
:
true
get
:
function
(
)
{
return
_getRootElement
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
find
'
{
enumerable
:
true
get
:
function
(
)
{
return
_find
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
findAll
'
{
enumerable
:
true
get
:
function
(
)
{
return
_findAll
.
default
;
}
}
)
;
}
)
;
define
(
"
ember
/
test
-
helpers
/
resolver
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
setResolver
=
setResolver
;
exports
.
getResolver
=
getResolver
;
var
__resolver__
;
function
setResolver
(
resolver
)
{
__resolver__
=
resolver
;
}
function
getResolver
(
)
{
return
__resolver__
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
settled
'
[
'
exports
'
'
ember
/
test
-
helpers
/
-
utils
'
'
ember
/
test
-
helpers
/
wait
-
until
'
]
function
(
exports
_utils
_waitUntil
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
_teardownAJAXHooks
=
_teardownAJAXHooks
;
exports
.
_setupAJAXHooks
=
_setupAJAXHooks
;
exports
.
getSettledState
=
getSettledState
;
exports
.
isSettled
=
isSettled
;
exports
.
default
=
settled
;
const
_internalPendingRequests
=
(
(
)
=
>
{
if
(
Ember
.
__loader
.
registry
[
'
ember
-
testing
/
test
/
pending_requests
'
]
)
{
return
Ember
.
__loader
.
require
(
'
ember
-
testing
/
test
/
pending_requests
'
)
.
pendingRequests
;
}
return
(
)
=
>
0
;
}
)
(
)
;
let
requests
;
function
pendingRequests
(
)
{
let
localRequestsPending
=
requests
!
=
=
undefined
?
requests
.
length
:
0
;
let
internalRequestsPending
=
_internalPendingRequests
(
)
;
return
localRequestsPending
+
internalRequestsPending
;
}
function
incrementAjaxPendingRequests
(
event
xhr
)
{
requests
.
push
(
xhr
)
;
}
function
decrementAjaxPendingRequests
(
event
xhr
)
{
(
0
_utils
.
nextTick
)
(
(
)
=
>
{
for
(
let
i
=
0
;
i
<
requests
.
length
;
i
+
+
)
{
if
(
xhr
=
=
=
requests
[
i
]
)
{
requests
.
splice
(
i
1
)
;
}
}
}
0
)
;
}
function
_teardownAJAXHooks
(
)
{
if
(
!
Ember
.
)
{
return
;
}
Ember
.
(
document
)
.
off
(
'
ajaxSend
'
incrementAjaxPendingRequests
)
;
Ember
.
(
document
)
.
off
(
'
ajaxComplete
'
decrementAjaxPendingRequests
)
;
}
function
_setupAJAXHooks
(
)
{
requests
=
[
]
;
if
(
!
Ember
.
)
{
return
;
}
Ember
.
(
document
)
.
on
(
'
ajaxSend
'
incrementAjaxPendingRequests
)
;
Ember
.
(
document
)
.
on
(
'
ajaxComplete
'
decrementAjaxPendingRequests
)
;
}
let
_internalCheckWaiters
;
if
(
Ember
.
__loader
.
registry
[
'
ember
-
testing
/
test
/
waiters
'
]
)
{
_internalCheckWaiters
=
Ember
.
__loader
.
require
(
'
ember
-
testing
/
test
/
waiters
'
)
.
checkWaiters
;
}
function
checkWaiters
(
)
{
if
(
_internalCheckWaiters
)
{
return
_internalCheckWaiters
(
)
;
}
else
if
(
Ember
.
Test
.
waiters
)
{
if
(
Ember
.
Test
.
waiters
.
any
(
(
[
context
callback
]
)
=
>
!
callback
.
call
(
context
)
)
)
{
return
true
;
}
}
return
false
;
}
function
getSettledState
(
)
{
let
pendingRequestCount
=
pendingRequests
(
)
;
return
{
hasPendingTimers
:
Boolean
(
Ember
.
run
.
hasScheduledTimers
(
)
)
hasRunLoop
:
Boolean
(
Ember
.
run
.
currentRunLoop
)
hasPendingWaiters
:
checkWaiters
(
)
hasPendingRequests
:
pendingRequestCount
>
0
pendingRequestCount
}
;
}
function
isSettled
(
)
{
let
{
hasPendingTimers
hasRunLoop
hasPendingRequests
hasPendingWaiters
}
=
getSettledState
(
)
;
if
(
hasPendingTimers
|
|
hasRunLoop
|
|
hasPendingRequests
|
|
hasPendingWaiters
)
{
return
false
;
}
return
true
;
}
function
settled
(
)
{
return
(
0
_waitUntil
.
default
)
(
isSettled
{
timeout
:
Infinity
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
setup
-
application
-
context
'
[
'
exports
'
'
ember
/
test
-
helpers
/
-
utils
'
'
ember
/
test
-
helpers
/
setup
-
context
'
'
ember
/
test
-
helpers
/
has
-
ember
-
version
'
'
ember
/
test
-
helpers
/
settled
'
]
function
(
exports
_utils
_setupContext
_hasEmberVersion
_settled
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
visit
=
visit
;
exports
.
currentRouteName
=
currentRouteName
;
exports
.
currentURL
=
currentURL
;
exports
.
default
=
setupApplicationContext
;
function
visit
(
)
{
let
context
=
(
0
_setupContext
.
getContext
)
(
)
;
let
{
owner
}
=
context
;
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
return
owner
.
visit
(
.
.
.
arguments
)
;
}
)
.
then
(
(
)
=
>
{
if
(
EmberENV
.
_APPLICATION_TEMPLATE_WRAPPER
!
=
=
false
)
{
context
.
element
=
document
.
querySelector
(
'
#
ember
-
testing
>
.
ember
-
view
'
)
;
}
else
{
context
.
element
=
document
.
querySelector
(
'
#
ember
-
testing
'
)
;
}
}
)
.
then
(
_settled
.
default
)
;
}
function
currentRouteName
(
)
{
let
{
owner
}
=
(
0
_setupContext
.
getContext
)
(
)
;
let
router
=
owner
.
lookup
(
'
router
:
main
'
)
;
return
Ember
.
get
(
router
'
currentRouteName
'
)
;
}
const
HAS_CURRENT_URL_ON_ROUTER
=
(
0
_hasEmberVersion
.
default
)
(
2
13
)
;
function
currentURL
(
)
{
let
{
owner
}
=
(
0
_setupContext
.
getContext
)
(
)
;
let
router
=
owner
.
lookup
(
'
router
:
main
'
)
;
if
(
HAS_CURRENT_URL_ON_ROUTER
)
{
return
Ember
.
get
(
router
'
currentURL
'
)
;
}
else
{
return
Ember
.
get
(
router
'
location
'
)
.
getURL
(
)
;
}
}
function
setupApplicationContext
(
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
setup
-
context
'
[
'
exports
'
'
ember
/
test
-
helpers
/
build
-
owner
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
global
'
'
ember
/
test
-
helpers
/
resolver
'
'
ember
/
test
-
helpers
/
application
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_buildOwner
_settled
_global
_resolver
_application
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
CLEANUP
=
undefined
;
exports
.
setContext
=
setContext
;
exports
.
getContext
=
getContext
;
exports
.
unsetContext
=
unsetContext
;
exports
.
pauseTest
=
pauseTest
;
exports
.
resumeTest
=
resumeTest
;
exports
.
default
=
function
(
context
options
=
{
}
)
{
Ember
.
testing
=
true
;
setContext
(
context
)
;
let
contextGuid
=
Ember
.
guidFor
(
context
)
;
CLEANUP
[
contextGuid
]
=
[
]
;
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
let
application
=
(
0
_application
.
getApplication
)
(
)
;
if
(
application
)
{
return
application
.
boot
(
)
;
}
}
)
.
then
(
(
)
=
>
{
let
testElementContainer
=
document
.
getElementById
(
'
ember
-
testing
-
container
'
)
;
let
fixtureResetValue
=
testElementContainer
.
innerHTML
;
CLEANUP
[
contextGuid
]
.
push
(
(
)
=
>
{
testElementContainer
.
innerHTML
=
fixtureResetValue
;
}
)
;
let
{
resolver
}
=
options
;
if
(
resolver
)
{
return
(
0
_buildOwner
.
default
)
(
null
resolver
)
;
}
return
(
0
_buildOwner
.
default
)
(
(
0
_application
.
getApplication
)
(
)
(
0
_resolver
.
getResolver
)
(
)
)
;
}
)
.
then
(
owner
=
>
{
context
.
owner
=
owner
;
context
.
set
=
function
(
key
value
)
{
let
ret
=
Ember
.
run
(
function
(
)
{
return
Ember
.
set
(
context
key
value
)
;
}
)
;
return
ret
;
}
;
context
.
setProperties
=
function
(
hash
)
{
let
ret
=
Ember
.
run
(
function
(
)
{
return
Ember
.
setProperties
(
context
hash
)
;
}
)
;
return
ret
;
}
;
context
.
get
=
function
(
key
)
{
return
Ember
.
get
(
context
key
)
;
}
;
context
.
getProperties
=
function
(
.
.
.
args
)
{
return
Ember
.
getProperties
(
context
args
)
;
}
;
let
resume
;
context
.
resumeTest
=
function
resumeTest
(
)
{
(
true
&
&
!
(
resume
)
&
&
Ember
.
assert
(
'
Testing
has
not
been
paused
.
There
is
nothing
to
resume
.
'
resume
)
)
;
resume
(
)
;
_global
.
default
.
resumeTest
=
resume
=
undefined
;
}
;
context
.
pauseTest
=
function
pauseTest
(
)
{
console
.
info
(
'
Testing
paused
.
Use
resumeTest
(
)
to
continue
.
'
)
;
return
new
Ember
.
RSVP
.
Promise
(
resolve
=
>
{
resume
=
resolve
;
_global
.
default
.
resumeTest
=
resumeTest
;
}
'
TestAdapter
paused
promise
'
)
;
}
;
(
0
_settled
.
_setupAJAXHooks
)
(
)
;
return
context
;
}
)
;
}
;
let
__test_context__
;
function
setContext
(
context
)
{
__test_context__
=
context
;
}
function
getContext
(
)
{
return
__test_context__
;
}
function
unsetContext
(
)
{
__test_context__
=
undefined
;
}
function
pauseTest
(
)
{
let
context
=
getContext
(
)
;
if
(
!
context
|
|
typeof
context
.
pauseTest
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Cannot
call
pauseTest
without
having
first
called
setupTest
or
setupRenderingTest
.
'
)
;
}
return
context
.
pauseTest
(
)
;
}
function
resumeTest
(
)
{
let
context
=
getContext
(
)
;
if
(
!
context
|
|
typeof
context
.
resumeTest
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Cannot
call
resumeTest
without
having
first
called
setupTest
or
setupRenderingTest
.
'
)
;
}
context
.
resumeTest
(
)
;
}
const
CLEANUP
=
exports
.
CLEANUP
=
Object
.
create
(
null
)
;
}
)
;
define
(
'
ember
/
test
-
helpers
/
setup
-
rendering
-
context
'
[
'
exports
'
'
ember
/
test
-
helpers
/
global
'
'
ember
/
test
-
helpers
/
setup
-
context
'
'
ember
/
test
-
helpers
/
-
utils
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
dom
/
get
-
root
-
element
'
]
function
(
exports
_global
_setupContext
_utils
_settled
_getRootElement
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
RENDERING_CLEANUP
=
undefined
;
exports
.
render
=
render
;
exports
.
clearRender
=
clearRender
;
exports
.
default
=
setupRenderingContext
;
const
RENDERING_CLEANUP
=
exports
.
RENDERING_CLEANUP
=
Object
.
create
(
null
)
;
const
OUTLET_TEMPLATE
=
Ember
.
HTMLBars
.
template
(
{
"
id
"
:
"
gc40spmP
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
]
\
"
statements
\
"
:
[
[
1
[
18
\
"
outlet
\
"
]
false
]
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
}
}
)
;
const
EMPTY_TEMPLATE
=
Ember
.
HTMLBars
.
template
(
{
"
id
"
:
"
xOcW61lH
"
"
block
"
:
"
{
\
"
symbols
\
"
:
[
]
\
"
statements
\
"
:
[
]
\
"
hasEval
\
"
:
false
}
"
"
meta
"
:
{
}
}
)
;
function
lookupOutletTemplate
(
owner
)
{
let
OutletTemplate
=
owner
.
lookup
(
'
template
:
-
outlet
'
)
;
if
(
!
OutletTemplate
)
{
owner
.
register
(
'
template
:
-
outlet
'
OUTLET_TEMPLATE
)
;
OutletTemplate
=
owner
.
lookup
(
'
template
:
-
outlet
'
)
;
}
return
OutletTemplate
;
}
function
jQuerySelector
(
selector
)
{
let
{
element
}
=
(
0
_setupContext
.
getContext
)
(
)
;
return
selector
?
_global
.
default
.
jQuery
(
selector
element
)
:
_global
.
default
.
jQuery
(
element
)
;
}
let
templateId
=
0
;
function
render
(
template
)
{
let
context
=
(
0
_setupContext
.
getContext
)
(
)
;
if
(
!
template
)
{
throw
new
Error
(
'
you
must
pass
a
template
to
render
(
)
'
)
;
}
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
let
{
owner
}
=
context
;
let
toplevelView
=
owner
.
lookup
(
'
-
top
-
level
-
view
:
main
'
)
;
let
OutletTemplate
=
lookupOutletTemplate
(
owner
)
;
templateId
+
=
1
;
let
templateFullName
=
template
:
-
undertest
-
{
templateId
}
;
owner
.
register
(
templateFullName
template
)
;
let
outletState
=
{
render
:
{
owner
into
:
undefined
outlet
:
'
main
'
name
:
'
application
'
controller
:
undefined
ViewClass
:
undefined
template
:
OutletTemplate
}
outlets
:
{
main
:
{
render
:
{
owner
into
:
undefined
outlet
:
'
main
'
name
:
'
index
'
controller
:
context
ViewClass
:
undefined
template
:
owner
.
lookup
(
templateFullName
)
outlets
:
{
}
}
outlets
:
{
}
}
}
}
;
toplevelView
.
setOutletState
(
outletState
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
function
clearRender
(
)
{
let
context
=
(
0
_setupContext
.
getContext
)
(
)
;
if
(
!
context
|
|
typeof
context
.
clearRender
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Cannot
call
clearRender
without
having
first
called
setupRenderingContext
.
'
)
;
}
return
render
(
EMPTY_TEMPLATE
)
;
}
function
setupRenderingContext
(
context
)
{
let
contextGuid
=
Ember
.
guidFor
(
context
)
;
RENDERING_CLEANUP
[
contextGuid
]
=
[
]
;
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
let
{
owner
}
=
context
;
context
.
render
=
render
;
context
.
clearRender
=
clearRender
;
if
(
_global
.
default
.
jQuery
)
{
context
.
=
jQuerySelector
;
}
if
(
owner
.
_emberTestHelpersMockOwner
)
{
let
dispatcher
=
owner
.
lookup
(
'
event_dispatcher
:
main
'
)
|
|
Ember
.
EventDispatcher
.
create
(
)
;
dispatcher
.
setup
(
{
}
'
#
ember
-
testing
'
)
;
}
let
OutletView
=
owner
.
factoryFor
?
owner
.
factoryFor
(
'
view
:
-
outlet
'
)
:
owner
.
_lookupFactory
(
'
view
:
-
outlet
'
)
;
let
toplevelView
=
OutletView
.
create
(
)
;
owner
.
register
(
'
-
top
-
level
-
view
:
main
'
{
create
(
)
{
return
toplevelView
;
}
}
)
;
return
render
(
EMPTY_TEMPLATE
)
.
then
(
(
)
=
>
{
Ember
.
run
(
toplevelView
'
appendTo
'
(
0
_getRootElement
.
default
)
(
)
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
)
.
then
(
(
)
=
>
{
if
(
EmberENV
.
_APPLICATION_TEMPLATE_WRAPPER
!
=
=
false
)
{
context
.
element
=
(
0
_getRootElement
.
default
)
(
)
.
querySelector
(
'
.
ember
-
view
'
)
;
}
else
{
context
.
element
=
(
0
_getRootElement
.
default
)
(
)
;
}
return
context
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
teardown
-
application
-
context
'
[
'
exports
'
'
ember
/
test
-
helpers
/
settled
'
]
function
(
exports
_settled
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
function
(
)
{
return
(
0
_settled
.
default
)
(
)
;
}
;
}
)
;
define
(
'
ember
/
test
-
helpers
/
teardown
-
context
'
[
'
exports
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
/
setup
-
context
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_settled
_setupContext
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
teardownContext
;
function
teardownContext
(
context
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
let
{
owner
}
=
context
;
(
0
_settled
.
_teardownAJAXHooks
)
(
)
;
Ember
.
run
(
owner
'
destroy
'
)
;
Ember
.
testing
=
false
;
(
0
_setupContext
.
unsetContext
)
(
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
.
finally
(
(
)
=
>
{
let
contextGuid
=
Ember
.
guidFor
(
context
)
;
(
0
_utils
.
runDestroyablesFor
)
(
_setupContext
.
CLEANUP
contextGuid
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
teardown
-
rendering
-
context
'
[
'
exports
'
'
ember
/
test
-
helpers
/
setup
-
rendering
-
context
'
'
ember
/
test
-
helpers
/
-
utils
'
'
ember
/
test
-
helpers
/
settled
'
]
function
(
exports
_setupRenderingContext
_utils
_settled
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
teardownRenderingContext
;
function
teardownRenderingContext
(
context
)
{
return
(
0
_utils
.
nextTickPromise
)
(
)
.
then
(
(
)
=
>
{
let
contextGuid
=
Ember
.
guidFor
(
context
)
;
(
0
_utils
.
runDestroyablesFor
)
(
_setupRenderingContext
.
RENDERING_CLEANUP
contextGuid
)
;
return
(
0
_settled
.
default
)
(
)
;
}
)
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
validate
-
error
-
handler
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
validateErrorHandler
;
const
VALID
=
Object
.
freeze
(
{
isValid
:
true
message
:
null
}
)
;
const
INVALID
=
Object
.
freeze
(
{
isValid
:
false
message
:
'
error
handler
should
have
re
-
thrown
the
provided
error
'
}
)
;
function
validateErrorHandler
(
callback
=
Ember
.
onerror
)
{
if
(
callback
=
=
=
undefined
|
|
callback
=
=
=
null
)
{
return
VALID
;
}
let
error
=
new
Error
(
'
Error
handler
validation
error
!
'
)
;
let
originalEmberTesting
=
Ember
.
testing
;
Ember
.
testing
=
true
;
try
{
callback
(
error
)
;
}
catch
(
e
)
{
if
(
e
=
=
=
error
)
{
return
VALID
;
}
}
finally
{
Ember
.
testing
=
originalEmberTesting
;
}
return
INVALID
;
}
}
)
;
define
(
'
ember
/
test
-
helpers
/
wait
-
until
'
[
'
exports
'
'
ember
/
test
-
helpers
/
-
utils
'
]
function
(
exports
_utils
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
waitUntil
;
const
TIMEOUTS
=
[
0
1
2
5
7
]
;
const
MAX_TIMEOUT
=
10
;
function
waitUntil
(
callback
options
=
{
}
)
{
let
timeout
=
'
timeout
'
in
options
?
options
.
timeout
:
1000
;
let
waitUntilTimedOut
=
new
Error
(
'
waitUntil
timed
out
'
)
;
return
new
Ember
.
RSVP
.
Promise
(
function
(
resolve
reject
)
{
let
time
=
0
;
function
scheduleCheck
(
timeoutsIndex
)
{
let
interval
=
TIMEOUTS
[
timeoutsIndex
]
;
if
(
interval
=
=
=
undefined
)
{
interval
=
MAX_TIMEOUT
;
}
(
0
_utils
.
futureTick
)
(
function
(
)
{
time
+
=
interval
;
let
value
;
try
{
value
=
callback
(
)
;
}
catch
(
error
)
{
reject
(
error
)
;
}
if
(
value
)
{
resolve
(
value
)
;
}
else
if
(
time
<
timeout
)
{
scheduleCheck
(
timeoutsIndex
+
1
)
;
}
else
{
reject
(
waitUntilTimedOut
)
;
}
}
interval
)
;
}
scheduleCheck
(
0
)
;
}
)
;
}
}
)
;
define
(
'
ember
-
cli
-
qunit
'
[
'
exports
'
'
ember
-
qunit
'
]
function
(
exports
_emberQunit
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
TestLoader
'
{
enumerable
:
true
get
:
function
(
)
{
return
_emberQunit
.
TestLoader
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupTestContainer
'
{
enumerable
:
true
get
:
function
(
)
{
return
_emberQunit
.
setupTestContainer
;
}
}
)
;
Object
.
defineProperty
(
exports
'
loadTests
'
{
enumerable
:
true
get
:
function
(
)
{
return
_emberQunit
.
loadTests
;
}
}
)
;
Object
.
defineProperty
(
exports
'
startTests
'
{
enumerable
:
true
get
:
function
(
)
{
return
_emberQunit
.
startTests
;
}
}
)
;
Object
.
defineProperty
(
exports
'
setupTestAdapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_emberQunit
.
setupTestAdapter
;
}
}
)
;
Object
.
defineProperty
(
exports
'
start
'
{
enumerable
:
true
get
:
function
(
)
{
return
_emberQunit
.
start
;
}
}
)
;
}
)
;
define
(
'
ember
-
cli
-
test
-
loader
/
test
-
support
/
index
'
[
'
exports
'
]
function
(
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
addModuleIncludeMatcher
=
addModuleIncludeMatcher
;
exports
.
addModuleExcludeMatcher
=
addModuleExcludeMatcher
;
let
moduleIncludeMatchers
=
[
]
;
let
moduleExcludeMatchers
=
[
]
;
function
addModuleIncludeMatcher
(
fn
)
{
moduleIncludeMatchers
.
push
(
fn
)
;
}
function
addModuleExcludeMatcher
(
fn
)
{
moduleExcludeMatchers
.
push
(
fn
)
;
}
function
checkMatchers
(
matchers
moduleName
)
{
return
matchers
.
some
(
matcher
=
>
matcher
(
moduleName
)
)
;
}
class
TestLoader
{
static
load
(
)
{
new
TestLoader
(
)
.
loadModules
(
)
;
}
constructor
(
)
{
this
.
_didLogMissingUnsee
=
false
;
}
shouldLoadModule
(
moduleName
)
{
return
moduleName
.
match
(
/
[
-
_
]
test
/
)
;
}
listModules
(
)
{
return
Object
.
keys
(
requirejs
.
entries
)
;
}
listTestModules
(
)
{
let
moduleNames
=
this
.
listModules
(
)
;
let
testModules
=
[
]
;
let
moduleName
;
for
(
let
i
=
0
;
i
<
moduleNames
.
length
;
i
+
+
)
{
moduleName
=
moduleNames
[
i
]
;
if
(
checkMatchers
(
moduleExcludeMatchers
moduleName
)
)
{
continue
;
}
if
(
checkMatchers
(
moduleIncludeMatchers
moduleName
)
|
|
this
.
shouldLoadModule
(
moduleName
)
)
{
testModules
.
push
(
moduleName
)
;
}
}
return
testModules
;
}
loadModules
(
)
{
let
testModules
=
this
.
listTestModules
(
)
;
let
testModule
;
for
(
let
i
=
0
;
i
<
testModules
.
length
;
i
+
+
)
{
testModule
=
testModules
[
i
]
;
this
.
require
(
testModule
)
;
this
.
unsee
(
testModule
)
;
}
}
require
(
moduleName
)
{
try
{
require
(
moduleName
)
;
}
catch
(
e
)
{
this
.
moduleLoadFailure
(
moduleName
e
)
;
}
}
unsee
(
moduleName
)
{
if
(
typeof
require
.
unsee
=
=
=
'
function
'
)
{
require
.
unsee
(
moduleName
)
;
}
else
if
(
!
this
.
_didLogMissingUnsee
)
{
this
.
_didLogMissingUnsee
=
true
;
if
(
typeof
console
!
=
=
'
undefined
'
)
{
console
.
warn
(
'
unable
to
require
.
unsee
please
upgrade
loader
.
js
to
>
=
v3
.
3
.
0
'
)
;
}
}
}
moduleLoadFailure
(
moduleName
error
)
{
console
.
error
(
'
Error
loading
:
'
+
moduleName
error
.
stack
)
;
}
}
exports
.
default
=
TestLoader
;
;
}
)
;
define
(
'
ember
-
qunit
/
adapter
'
[
'
exports
'
'
qunit
'
'
ember
/
test
-
helpers
/
has
-
ember
-
version
'
]
function
(
exports
_qunit
_hasEmberVersion
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
function
unhandledRejectionAssertion
(
current
error
)
{
let
message
source
;
if
(
typeof
error
=
=
=
'
object
'
&
&
error
!
=
=
null
)
{
message
=
error
.
message
;
source
=
error
.
stack
;
}
else
if
(
typeof
error
=
=
=
'
string
'
)
{
message
=
error
;
source
=
'
unknown
source
'
;
}
else
{
message
=
'
unhandledRejection
occured
but
it
had
no
message
'
;
source
=
'
unknown
source
'
;
}
current
.
assert
.
pushResult
(
{
result
:
false
actual
:
false
expected
:
true
message
:
message
source
:
source
}
)
;
}
let
Adapter
=
Ember
.
Test
.
Adapter
.
extend
(
{
init
(
)
{
this
.
doneCallbacks
=
[
]
;
}
asyncStart
(
)
{
this
.
doneCallbacks
.
push
(
_qunit
.
default
.
config
.
current
?
_qunit
.
default
.
config
.
current
.
assert
.
async
(
)
:
null
)
;
}
asyncEnd
(
)
{
let
done
=
this
.
doneCallbacks
.
pop
(
)
;
if
(
done
)
{
done
(
)
;
}
}
exception
:
null
}
)
;
if
(
!
(
0
_hasEmberVersion
.
default
)
(
2
17
)
)
{
Adapter
=
Adapter
.
extend
(
{
exception
(
error
)
{
unhandledRejectionAssertion
(
_qunit
.
default
.
config
.
current
error
)
;
}
}
)
;
}
exports
.
default
=
Adapter
;
}
)
;
define
(
'
ember
-
qunit
/
index
'
[
'
exports
'
'
ember
-
qunit
/
legacy
-
2
-
x
/
module
-
for
'
'
ember
-
qunit
/
legacy
-
2
-
x
/
module
-
for
-
component
'
'
ember
-
qunit
/
legacy
-
2
-
x
/
module
-
for
-
model
'
'
ember
-
qunit
/
adapter
'
'
qunit
'
'
ember
-
qunit
/
test
-
loader
'
'
ember
/
test
-
helpers
'
]
function
(
exports
_moduleFor
_moduleForComponent
_moduleForModel
_adapter
_qunit
_testLoader
_testHelpers
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
loadTests
=
exports
.
todo
=
exports
.
only
=
exports
.
skip
=
exports
.
test
=
exports
.
module
=
exports
.
QUnitAdapter
=
exports
.
moduleForModel
=
exports
.
moduleForComponent
=
exports
.
moduleFor
=
undefined
;
Object
.
defineProperty
(
exports
'
moduleFor
'
{
enumerable
:
true
get
:
function
(
)
{
return
_moduleFor
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
moduleForComponent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_moduleForComponent
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
moduleForModel
'
{
enumerable
:
true
get
:
function
(
)
{
return
_moduleForModel
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
QUnitAdapter
'
{
enumerable
:
true
get
:
function
(
)
{
return
_adapter
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
module
'
{
enumerable
:
true
get
:
function
(
)
{
return
_qunit
.
module
;
}
}
)
;
Object
.
defineProperty
(
exports
'
test
'
{
enumerable
:
true
get
:
function
(
)
{
return
_qunit
.
test
;
}
}
)
;
Object
.
defineProperty
(
exports
'
skip
'
{
enumerable
:
true
get
:
function
(
)
{
return
_qunit
.
skip
;
}
}
)
;
Object
.
defineProperty
(
exports
'
only
'
{
enumerable
:
true
get
:
function
(
)
{
return
_qunit
.
only
;
}
}
)
;
Object
.
defineProperty
(
exports
'
todo
'
{
enumerable
:
true
get
:
function
(
)
{
return
_qunit
.
todo
;
}
}
)
;
Object
.
defineProperty
(
exports
'
loadTests
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testLoader
.
loadTests
;
}
}
)
;
exports
.
setResolver
=
setResolver
;
exports
.
render
=
render
;
exports
.
clearRender
=
clearRender
;
exports
.
settled
=
settled
;
exports
.
pauseTest
=
pauseTest
;
exports
.
resumeTest
=
resumeTest
;
exports
.
setupTest
=
setupTest
;
exports
.
setupRenderingTest
=
setupRenderingTest
;
exports
.
setupApplicationTest
=
setupApplicationTest
;
exports
.
setupTestContainer
=
setupTestContainer
;
exports
.
startTests
=
startTests
;
exports
.
setupTestAdapter
=
setupTestAdapter
;
exports
.
setupEmberTesting
=
setupEmberTesting
;
exports
.
setupEmberOnerrorValidation
=
setupEmberOnerrorValidation
;
exports
.
start
=
start
;
function
setResolver
(
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
setResolver
should
be
imported
from
ember
/
test
-
helpers
but
was
imported
from
ember
-
qunit
'
false
{
id
:
'
ember
-
qunit
.
deprecated
-
reexports
.
setResolver
'
until
:
'
4
.
0
.
0
'
}
)
)
;
return
(
0
_testHelpers
.
setResolver
)
(
.
.
.
arguments
)
;
}
function
render
(
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
render
should
be
imported
from
ember
/
test
-
helpers
but
was
imported
from
ember
-
qunit
'
false
{
id
:
'
ember
-
qunit
.
deprecated
-
reexports
.
render
'
until
:
'
4
.
0
.
0
'
}
)
)
;
return
(
0
_testHelpers
.
render
)
(
.
.
.
arguments
)
;
}
function
clearRender
(
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
clearRender
should
be
imported
from
ember
/
test
-
helpers
but
was
imported
from
ember
-
qunit
'
false
{
id
:
'
ember
-
qunit
.
deprecated
-
reexports
.
clearRender
'
until
:
'
4
.
0
.
0
'
}
)
)
;
return
(
0
_testHelpers
.
clearRender
)
(
.
.
.
arguments
)
;
}
function
settled
(
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
settled
should
be
imported
from
ember
/
test
-
helpers
but
was
imported
from
ember
-
qunit
'
false
{
id
:
'
ember
-
qunit
.
deprecated
-
reexports
.
settled
'
until
:
'
4
.
0
.
0
'
}
)
)
;
return
(
0
_testHelpers
.
settled
)
(
.
.
.
arguments
)
;
}
function
pauseTest
(
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
pauseTest
should
be
imported
from
ember
/
test
-
helpers
but
was
imported
from
ember
-
qunit
'
false
{
id
:
'
ember
-
qunit
.
deprecated
-
reexports
.
pauseTest
'
until
:
'
4
.
0
.
0
'
}
)
)
;
return
(
0
_testHelpers
.
pauseTest
)
(
.
.
.
arguments
)
;
}
function
resumeTest
(
)
{
(
true
&
&
!
(
false
)
&
&
Ember
.
deprecate
(
'
resumeTest
should
be
imported
from
ember
/
test
-
helpers
but
was
imported
from
ember
-
qunit
'
false
{
id
:
'
ember
-
qunit
.
deprecated
-
reexports
.
resumeTest
'
until
:
'
4
.
0
.
0
'
}
)
)
;
return
(
0
_testHelpers
.
resumeTest
)
(
.
.
.
arguments
)
;
}
function
setupTest
(
hooks
options
)
{
hooks
.
beforeEach
(
function
(
assert
)
{
return
(
0
_testHelpers
.
setupContext
)
(
this
options
)
.
then
(
(
)
=
>
{
let
originalPauseTest
=
this
.
pauseTest
;
this
.
pauseTest
=
function
QUnit_pauseTest
(
)
{
assert
.
timeout
(
-
1
)
;
return
originalPauseTest
.
call
(
this
)
;
}
;
}
)
;
}
)
;
hooks
.
afterEach
(
function
(
)
{
return
(
0
_testHelpers
.
teardownContext
)
(
this
)
;
}
)
;
}
function
setupRenderingTest
(
hooks
options
)
{
setupTest
(
hooks
options
)
;
hooks
.
beforeEach
(
function
(
)
{
return
(
0
_testHelpers
.
setupRenderingContext
)
(
this
)
;
}
)
;
hooks
.
afterEach
(
function
(
)
{
return
(
0
_testHelpers
.
teardownRenderingContext
)
(
this
)
;
}
)
;
}
function
setupApplicationTest
(
hooks
options
)
{
setupTest
(
hooks
options
)
;
hooks
.
beforeEach
(
function
(
)
{
return
(
0
_testHelpers
.
setupApplicationContext
)
(
this
)
;
}
)
;
hooks
.
afterEach
(
function
(
)
{
return
(
0
_testHelpers
.
teardownApplicationContext
)
(
this
)
;
}
)
;
}
function
setupTestContainer
(
)
{
let
testContainer
=
document
.
getElementById
(
'
ember
-
testing
-
container
'
)
;
if
(
!
testContainer
)
{
return
;
}
let
params
=
_qunit
.
default
.
urlParams
;
let
containerVisibility
=
params
.
nocontainer
?
'
hidden
'
:
'
visible
'
;
let
containerPosition
=
params
.
dockcontainer
|
|
params
.
devmode
?
'
fixed
'
:
'
relative
'
;
if
(
params
.
devmode
)
{
testContainer
.
className
=
'
full
-
screen
'
;
}
testContainer
.
style
.
visibility
=
containerVisibility
;
testContainer
.
style
.
position
=
containerPosition
;
let
qunitContainer
=
document
.
getElementById
(
'
qunit
'
)
;
if
(
params
.
dockcontainer
)
{
qunitContainer
.
style
.
marginBottom
=
window
.
getComputedStyle
(
testContainer
)
.
height
;
}
}
function
startTests
(
)
{
_qunit
.
default
.
start
(
)
;
}
function
setupTestAdapter
(
)
{
Ember
.
Test
.
adapter
=
_adapter
.
default
.
create
(
)
;
}
function
setupEmberTesting
(
)
{
_qunit
.
default
.
testStart
(
(
)
=
>
{
Ember
.
testing
=
true
;
}
)
;
_qunit
.
default
.
testDone
(
(
)
=
>
{
Ember
.
testing
=
false
;
}
)
;
}
function
setupEmberOnerrorValidation
(
)
{
_qunit
.
default
.
module
(
'
ember
-
qunit
:
Ember
.
onerror
validation
'
function
(
)
{
_qunit
.
default
.
test
(
'
Ember
.
onerror
is
functioning
properly
'
function
(
assert
)
{
assert
.
expect
(
1
)
;
let
result
=
(
0
_testHelpers
.
validateErrorHandler
)
(
)
;
assert
.
ok
(
result
.
isValid
Ember
.
onerror
handler
with
invalid
testing
behavior
detected
.
An
Ember
.
onerror
handler
_must_
rethrow
exceptions
when
\
Ember
.
testing
\
is
\
true
\
or
the
test
suite
is
unreliable
.
See
https
:
/
/
git
.
io
/
vbine
for
more
details
.
)
;
}
)
;
}
)
;
}
function
start
(
options
=
{
}
)
{
if
(
options
.
loadTests
!
=
=
false
)
{
(
0
_testLoader
.
loadTests
)
(
)
;
}
if
(
options
.
setupTestContainer
!
=
=
false
)
{
setupTestContainer
(
)
;
}
if
(
options
.
setupTestAdapter
!
=
=
false
)
{
setupTestAdapter
(
)
;
}
if
(
options
.
setupEmberTesting
!
=
=
false
)
{
setupEmberTesting
(
)
;
}
if
(
options
.
setupEmberOnerrorValidation
!
=
=
false
)
{
setupEmberOnerrorValidation
(
)
;
}
if
(
options
.
startTests
!
=
=
false
)
{
startTests
(
)
;
}
}
}
)
;
define
(
'
ember
-
qunit
/
legacy
-
2
-
x
/
module
-
for
-
component
'
[
'
exports
'
'
ember
-
qunit
/
legacy
-
2
-
x
/
qunit
-
module
'
'
ember
-
test
-
helpers
'
]
function
(
exports
_qunitModule
_emberTestHelpers
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
moduleForComponent
;
function
moduleForComponent
(
name
description
callbacks
)
{
(
0
_qunitModule
.
createModule
)
(
_emberTestHelpers
.
TestModuleForComponent
name
description
callbacks
)
;
}
}
)
;
define
(
'
ember
-
qunit
/
legacy
-
2
-
x
/
module
-
for
-
model
'
[
'
exports
'
'
ember
-
qunit
/
legacy
-
2
-
x
/
qunit
-
module
'
'
ember
-
test
-
helpers
'
]
function
(
exports
_qunitModule
_emberTestHelpers
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
moduleForModel
;
function
moduleForModel
(
name
description
callbacks
)
{
(
0
_qunitModule
.
createModule
)
(
_emberTestHelpers
.
TestModuleForModel
name
description
callbacks
)
;
}
}
)
;
define
(
'
ember
-
qunit
/
legacy
-
2
-
x
/
module
-
for
'
[
'
exports
'
'
ember
-
qunit
/
legacy
-
2
-
x
/
qunit
-
module
'
'
ember
-
test
-
helpers
'
]
function
(
exports
_qunitModule
_emberTestHelpers
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
moduleFor
;
function
moduleFor
(
name
description
callbacks
)
{
(
0
_qunitModule
.
createModule
)
(
_emberTestHelpers
.
TestModule
name
description
callbacks
)
;
}
}
)
;
define
(
'
ember
-
qunit
/
legacy
-
2
-
x
/
qunit
-
module
'
[
'
exports
'
'
qunit
'
]
function
(
exports
_qunit
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
createModule
=
createModule
;
function
noop
(
)
{
}
function
callbackFor
(
name
callbacks
)
{
if
(
typeof
callbacks
!
=
=
'
object
'
)
{
return
noop
;
}
if
(
!
callbacks
)
{
return
noop
;
}
var
callback
=
noop
;
if
(
callbacks
[
name
]
)
{
callback
=
callbacks
[
name
]
;
delete
callbacks
[
name
]
;
}
return
callback
;
}
function
createModule
(
Constructor
name
description
callbacks
)
{
if
(
!
callbacks
&
&
typeof
description
=
=
=
'
object
'
)
{
callbacks
=
description
;
description
=
name
;
}
var
before
=
callbackFor
(
'
before
'
callbacks
)
;
var
beforeEach
=
callbackFor
(
'
beforeEach
'
callbacks
)
;
var
afterEach
=
callbackFor
(
'
afterEach
'
callbacks
)
;
var
after
=
callbackFor
(
'
after
'
callbacks
)
;
var
module
;
var
moduleName
=
typeof
description
=
=
=
'
string
'
?
description
:
name
;
(
0
_qunit
.
module
)
(
moduleName
{
before
(
)
{
module
=
new
Constructor
(
name
description
callbacks
)
;
return
before
.
apply
(
this
arguments
)
;
}
beforeEach
(
)
{
module
.
setContext
(
this
)
;
return
module
.
setup
(
.
.
.
arguments
)
.
then
(
(
)
=
>
{
return
beforeEach
.
apply
(
this
arguments
)
;
}
)
;
}
afterEach
(
)
{
let
result
=
afterEach
.
apply
(
this
arguments
)
;
return
Ember
.
RSVP
.
resolve
(
result
)
.
then
(
(
)
=
>
module
.
teardown
(
.
.
.
arguments
)
)
;
}
after
(
)
{
try
{
return
after
.
apply
(
this
arguments
)
;
}
finally
{
after
=
afterEach
=
before
=
beforeEach
=
callbacks
=
module
=
null
;
}
}
}
)
;
}
}
)
;
define
(
'
ember
-
qunit
/
test
-
loader
'
[
'
exports
'
'
qunit
'
'
ember
-
cli
-
test
-
loader
/
test
-
support
/
index
'
]
function
(
exports
_qunit
_index
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
TestLoader
=
undefined
;
exports
.
loadTests
=
loadTests
;
(
0
_index
.
addModuleExcludeMatcher
)
(
function
(
moduleName
)
{
return
_qunit
.
default
.
urlParams
.
nolint
&
&
moduleName
.
match
(
/
\
.
(
jshint
|
lint
-
test
)
/
)
;
}
)
;
(
0
_index
.
addModuleIncludeMatcher
)
(
function
(
moduleName
)
{
return
moduleName
.
match
(
/
\
.
jshint
/
)
;
}
)
;
let
moduleLoadFailures
=
[
]
;
_qunit
.
default
.
done
(
function
(
)
{
if
(
moduleLoadFailures
.
length
)
{
throw
new
Error
(
'
\
n
'
+
moduleLoadFailures
.
join
(
'
\
n
'
)
)
;
}
}
)
;
class
TestLoader
extends
_index
.
default
{
moduleLoadFailure
(
moduleName
error
)
{
moduleLoadFailures
.
push
(
error
)
;
_qunit
.
default
.
module
(
'
TestLoader
Failures
'
)
;
_qunit
.
default
.
test
(
moduleName
+
'
:
could
not
be
loaded
'
function
(
)
{
throw
error
;
}
)
;
}
}
exports
.
TestLoader
=
TestLoader
;
function
loadTests
(
)
{
new
TestLoader
(
)
.
loadModules
(
)
;
}
}
)
;
define
(
'
ember
-
test
-
helpers
/
has
-
ember
-
version
'
[
'
exports
'
'
ember
/
test
-
helpers
/
has
-
ember
-
version
'
]
function
(
exports
_hasEmberVersion
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
'
default
'
{
enumerable
:
true
get
:
function
(
)
{
return
_hasEmberVersion
.
default
;
}
}
)
;
}
)
;
define
(
'
ember
-
test
-
helpers
/
index
'
[
'
exports
'
'
ember
/
test
-
helpers
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
-
for
-
acceptance
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
-
for
-
component
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
-
for
-
model
'
]
function
(
exports
_testHelpers
_testModule
_testModuleForAcceptance
_testModuleForComponent
_testModuleForModel
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
keys
(
_testHelpers
)
.
forEach
(
function
(
key
)
{
if
(
key
=
=
=
"
default
"
|
|
key
=
=
=
"
__esModule
"
)
return
;
Object
.
defineProperty
(
exports
key
{
enumerable
:
true
get
:
function
(
)
{
return
_testHelpers
[
key
]
;
}
}
)
;
}
)
;
Object
.
defineProperty
(
exports
'
TestModule
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testModule
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TestModuleForAcceptance
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testModuleForAcceptance
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TestModuleForComponent
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testModuleForComponent
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
'
TestModuleForModel
'
{
enumerable
:
true
get
:
function
(
)
{
return
_testModuleForModel
.
default
;
}
}
)
;
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
-
legacy
-
overrides
'
[
'
exports
'
'
ember
-
test
-
helpers
/
has
-
ember
-
version
'
]
function
(
exports
_hasEmberVersion
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
preGlimmerSetupIntegrationForComponent
=
preGlimmerSetupIntegrationForComponent
;
function
preGlimmerSetupIntegrationForComponent
(
)
{
var
module
=
this
;
var
context
=
this
.
context
;
this
.
actionHooks
=
{
}
;
context
.
dispatcher
=
this
.
container
.
lookup
(
'
event_dispatcher
:
main
'
)
|
|
Ember
.
EventDispatcher
.
create
(
)
;
context
.
dispatcher
.
setup
(
{
}
'
#
ember
-
testing
'
)
;
context
.
actions
=
module
.
actionHooks
;
(
this
.
registry
|
|
this
.
container
)
.
register
(
'
component
:
-
test
-
holder
'
Ember
.
Component
.
extend
(
)
)
;
context
.
render
=
function
(
template
)
{
module
.
teardownComponent
(
)
;
if
(
!
template
)
{
throw
new
Error
(
'
in
a
component
integration
test
you
must
pass
a
template
to
render
(
)
'
)
;
}
if
(
Ember
.
isArray
(
template
)
)
{
template
=
template
.
join
(
'
'
)
;
}
if
(
typeof
template
=
=
=
'
string
'
)
{
template
=
Ember
.
Handlebars
.
compile
(
template
)
;
}
module
.
component
=
module
.
container
.
lookupFactory
(
'
component
:
-
test
-
holder
'
)
.
create
(
{
layout
:
template
}
)
;
module
.
component
.
set
(
'
context
'
context
)
;
module
.
component
.
set
(
'
controller
'
context
)
;
Ember
.
run
(
function
(
)
{
module
.
component
.
appendTo
(
'
#
ember
-
testing
'
)
;
}
)
;
context
.
_element
=
module
.
component
.
element
;
}
;
context
.
=
function
(
)
{
return
module
.
component
.
.
apply
(
module
.
component
arguments
)
;
}
;
context
.
set
=
function
(
key
value
)
{
var
ret
=
Ember
.
run
(
function
(
)
{
return
Ember
.
set
(
context
key
value
)
;
}
)
;
if
(
(
0
_hasEmberVersion
.
default
)
(
2
0
)
)
{
return
ret
;
}
}
;
context
.
setProperties
=
function
(
hash
)
{
var
ret
=
Ember
.
run
(
function
(
)
{
return
Ember
.
setProperties
(
context
hash
)
;
}
)
;
if
(
(
0
_hasEmberVersion
.
default
)
(
2
0
)
)
{
return
ret
;
}
}
;
context
.
get
=
function
(
key
)
{
return
Ember
.
get
(
context
key
)
;
}
;
context
.
getProperties
=
function
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
return
Ember
.
getProperties
(
context
args
)
;
}
;
context
.
on
=
function
(
actionName
handler
)
{
module
.
actionHooks
[
actionName
]
=
handler
;
}
;
context
.
send
=
function
(
actionName
)
{
var
hook
=
module
.
actionHooks
[
actionName
]
;
if
(
!
hook
)
{
throw
new
Error
(
'
integration
testing
template
received
unexpected
action
'
+
actionName
)
;
}
hook
.
apply
(
module
Array
.
prototype
.
slice
.
call
(
arguments
1
)
)
;
}
;
context
.
clearRender
=
function
(
)
{
module
.
teardownComponent
(
)
;
}
;
}
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
abstract
-
test
-
module
'
[
'
exports
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
ext
/
rsvp
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
'
]
function
(
exports
_rsvp
_settled
_testHelpers
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
const
merge
=
Ember
.
assign
|
|
Ember
.
merge
;
exports
.
default
=
class
{
constructor
(
name
options
)
{
this
.
context
=
undefined
;
this
.
name
=
name
;
this
.
callbacks
=
options
|
|
{
}
;
this
.
initSetupSteps
(
)
;
this
.
initTeardownSteps
(
)
;
}
setup
(
assert
)
{
Ember
.
testing
=
true
;
return
this
.
invokeSteps
(
this
.
setupSteps
this
assert
)
.
then
(
(
)
=
>
{
this
.
contextualizeCallbacks
(
)
;
return
this
.
invokeSteps
(
this
.
contextualizedSetupSteps
this
.
context
assert
)
;
}
)
;
}
teardown
(
assert
)
{
return
this
.
invokeSteps
(
this
.
contextualizedTeardownSteps
this
.
context
assert
)
.
then
(
(
)
=
>
{
return
this
.
invokeSteps
(
this
.
teardownSteps
this
assert
)
;
}
)
.
then
(
(
)
=
>
{
this
.
cache
=
null
;
this
.
cachedCalls
=
null
;
}
)
.
finally
(
function
(
)
{
Ember
.
testing
=
false
;
}
)
;
}
initSetupSteps
(
)
{
this
.
setupSteps
=
[
]
;
this
.
contextualizedSetupSteps
=
[
]
;
if
(
this
.
callbacks
.
beforeSetup
)
{
this
.
setupSteps
.
push
(
this
.
callbacks
.
beforeSetup
)
;
delete
this
.
callbacks
.
beforeSetup
;
}
this
.
setupSteps
.
push
(
this
.
setupContext
)
;
this
.
setupSteps
.
push
(
this
.
setupTestElements
)
;
this
.
setupSteps
.
push
(
this
.
setupAJAXListeners
)
;
this
.
setupSteps
.
push
(
this
.
setupPromiseListeners
)
;
if
(
this
.
callbacks
.
setup
)
{
this
.
contextualizedSetupSteps
.
push
(
this
.
callbacks
.
setup
)
;
delete
this
.
callbacks
.
setup
;
}
}
invokeSteps
(
steps
context
assert
)
{
steps
=
steps
.
slice
(
)
;
function
nextStep
(
)
{
var
step
=
steps
.
shift
(
)
;
if
(
step
)
{
return
new
Ember
.
RSVP
.
Promise
(
resolve
=
>
{
resolve
(
step
.
call
(
context
assert
)
)
;
}
)
.
then
(
nextStep
)
;
}
else
{
return
Ember
.
RSVP
.
resolve
(
)
;
}
}
return
nextStep
(
)
;
}
contextualizeCallbacks
(
)
{
}
initTeardownSteps
(
)
{
this
.
teardownSteps
=
[
]
;
this
.
contextualizedTeardownSteps
=
[
]
;
if
(
this
.
callbacks
.
teardown
)
{
this
.
contextualizedTeardownSteps
.
push
(
this
.
callbacks
.
teardown
)
;
delete
this
.
callbacks
.
teardown
;
}
this
.
teardownSteps
.
push
(
this
.
teardownContext
)
;
this
.
teardownSteps
.
push
(
this
.
teardownTestElements
)
;
this
.
teardownSteps
.
push
(
this
.
teardownAJAXListeners
)
;
this
.
teardownSteps
.
push
(
this
.
teardownPromiseListeners
)
;
if
(
this
.
callbacks
.
afterTeardown
)
{
this
.
teardownSteps
.
push
(
this
.
callbacks
.
afterTeardown
)
;
delete
this
.
callbacks
.
afterTeardown
;
}
}
setupTestElements
(
)
{
let
testElementContainer
=
document
.
querySelector
(
'
#
ember
-
testing
-
container
'
)
;
if
(
!
testElementContainer
)
{
testElementContainer
=
document
.
createElement
(
'
div
'
)
;
testElementContainer
.
setAttribute
(
'
id
'
'
ember
-
testing
-
container
'
)
;
document
.
body
.
appendChild
(
testElementContainer
)
;
}
let
testEl
=
document
.
querySelector
(
'
#
ember
-
testing
'
)
;
if
(
!
testEl
)
{
let
element
=
document
.
createElement
(
'
div
'
)
;
element
.
setAttribute
(
'
id
'
'
ember
-
testing
'
)
;
testElementContainer
.
appendChild
(
element
)
;
this
.
fixtureResetValue
=
'
'
;
}
else
{
this
.
fixtureResetValue
=
testElementContainer
.
innerHTML
;
}
}
setupContext
(
options
)
{
let
context
=
this
.
getContext
(
)
;
merge
(
context
{
dispatcher
:
null
inject
:
{
}
}
)
;
merge
(
context
options
)
;
this
.
setToString
(
)
;
(
0
_testHelpers
.
setContext
)
(
context
)
;
this
.
context
=
context
;
}
setContext
(
context
)
{
this
.
context
=
context
;
}
getContext
(
)
{
if
(
this
.
context
)
{
return
this
.
context
;
}
return
this
.
context
=
(
0
_testHelpers
.
getContext
)
(
)
|
|
{
}
;
}
setToString
(
)
{
this
.
context
.
toString
=
(
)
=
>
{
if
(
this
.
subjectName
)
{
return
test
context
for
:
{
this
.
subjectName
}
;
}
if
(
this
.
name
)
{
return
test
context
for
:
{
this
.
name
}
;
}
}
;
}
setupAJAXListeners
(
)
{
(
0
_settled
.
_setupAJAXHooks
)
(
)
;
}
teardownAJAXListeners
(
)
{
(
0
_settled
.
_teardownAJAXHooks
)
(
)
;
}
setupPromiseListeners
(
)
{
(
0
_rsvp
.
_setupPromiseListeners
)
(
)
;
}
teardownPromiseListeners
(
)
{
(
0
_rsvp
.
_teardownPromiseListeners
)
(
)
;
}
teardownTestElements
(
)
{
document
.
getElementById
(
'
ember
-
testing
-
container
'
)
.
innerHTML
=
this
.
fixtureResetValue
;
if
(
Ember
.
View
&
&
Ember
.
View
.
views
)
{
Ember
.
View
.
views
=
{
}
;
}
}
teardownContext
(
)
{
var
context
=
this
.
context
;
this
.
context
=
undefined
;
(
0
_testHelpers
.
unsetContext
)
(
)
;
if
(
context
&
&
context
.
dispatcher
&
&
!
context
.
dispatcher
.
isDestroyed
)
{
Ember
.
run
(
function
(
)
{
context
.
dispatcher
.
destroy
(
)
;
}
)
;
}
}
}
;
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
build
-
registry
'
[
'
exports
'
'
require
'
]
function
(
exports
_require2
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
function
(
resolver
)
{
var
fallbackRegistry
registry
container
;
var
namespace
=
Ember
.
Object
.
create
(
{
Resolver
:
{
create
(
)
{
return
resolver
;
}
}
}
)
;
function
register
(
name
factory
)
{
var
thingToRegisterWith
=
registry
|
|
container
;
if
(
!
(
container
.
factoryFor
?
container
.
factoryFor
(
name
)
:
container
.
lookupFactory
(
name
)
)
)
{
thingToRegisterWith
.
register
(
name
factory
)
;
}
}
if
(
Ember
.
Application
.
buildRegistry
)
{
fallbackRegistry
=
Ember
.
Application
.
buildRegistry
(
namespace
)
;
fallbackRegistry
.
register
(
'
component
-
lookup
:
main
'
Ember
.
ComponentLookup
)
;
registry
=
new
Ember
.
Registry
(
{
fallback
:
fallbackRegistry
}
)
;
if
(
Ember
.
ApplicationInstance
&
&
Ember
.
ApplicationInstance
.
setupRegistry
)
{
Ember
.
ApplicationInstance
.
setupRegistry
(
registry
)
;
}
registry
.
normalizeFullName
=
fallbackRegistry
.
normalizeFullName
;
registry
.
makeToString
=
fallbackRegistry
.
makeToString
;
registry
.
describe
=
fallbackRegistry
.
describe
;
var
owner
=
Owner
.
create
(
{
__registry__
:
registry
__container__
:
null
}
)
;
container
=
registry
.
container
(
{
owner
:
owner
}
)
;
owner
.
__container__
=
container
;
exposeRegistryMethodsWithoutDeprecations
(
container
)
;
}
else
{
container
=
Ember
.
Application
.
buildContainer
(
namespace
)
;
container
.
register
(
'
component
-
lookup
:
main
'
Ember
.
ComponentLookup
)
;
}
if
(
Ember
.
View
)
{
register
(
'
view
:
toplevel
'
Ember
.
View
.
extend
(
)
)
;
}
if
(
Ember
.
_MetamorphView
)
{
register
(
'
view
:
default
'
Ember
.
_MetamorphView
)
;
}
var
globalContext
=
typeof
global
=
=
=
'
object
'
&
&
global
|
|
self
;
if
(
requirejs
.
entries
[
'
ember
-
data
/
setup
-
container
'
]
)
{
var
setupContainer
=
(
0
_require2
.
default
)
(
'
ember
-
data
/
setup
-
container
'
)
[
'
default
'
]
;
setupContainer
(
registry
|
|
container
)
;
}
else
if
(
globalContext
.
DS
)
{
var
DS
=
globalContext
.
DS
;
if
(
DS
.
_setupContainer
)
{
DS
.
_setupContainer
(
registry
|
|
container
)
;
}
else
{
register
(
'
transform
:
boolean
'
DS
.
BooleanTransform
)
;
register
(
'
transform
:
date
'
DS
.
DateTransform
)
;
register
(
'
transform
:
number
'
DS
.
NumberTransform
)
;
register
(
'
transform
:
string
'
DS
.
StringTransform
)
;
register
(
'
serializer
:
-
default
'
DS
.
JSONSerializer
)
;
register
(
'
serializer
:
-
rest
'
DS
.
RESTSerializer
)
;
register
(
'
adapter
:
-
rest
'
DS
.
RESTAdapter
)
;
}
}
return
{
registry
container
owner
}
;
}
;
function
exposeRegistryMethodsWithoutDeprecations
(
container
)
{
var
methods
=
[
'
register
'
'
unregister
'
'
resolve
'
'
normalize
'
'
typeInjection
'
'
injection
'
'
factoryInjection
'
'
factoryTypeInjection
'
'
has
'
'
options
'
'
optionsForType
'
]
;
function
exposeRegistryMethod
(
container
method
)
{
if
(
method
in
container
)
{
container
[
method
]
=
function
(
)
{
return
container
.
_registry
[
method
]
.
apply
(
container
.
_registry
arguments
)
;
}
;
}
}
for
(
var
i
=
0
l
=
methods
.
length
;
i
<
l
;
i
+
+
)
{
exposeRegistryMethod
(
container
methods
[
i
]
)
;
}
}
var
Owner
=
function
(
)
{
if
(
Ember
.
_RegistryProxyMixin
&
&
Ember
.
_ContainerProxyMixin
)
{
return
Ember
.
Object
.
extend
(
Ember
.
_RegistryProxyMixin
Ember
.
_ContainerProxyMixin
{
_emberTestHelpersMockOwner
:
true
}
)
;
}
return
Ember
.
Object
.
extend
(
{
_emberTestHelpersMockOwner
:
true
}
)
;
}
(
)
;
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
ext
/
rsvp
'
[
'
exports
'
]
function
(
exports
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
_setupPromiseListeners
=
_setupPromiseListeners
;
exports
.
_teardownPromiseListeners
=
_teardownPromiseListeners
;
let
originalAsync
;
function
_setupPromiseListeners
(
)
{
originalAsync
=
Ember
.
RSVP
.
configure
(
'
async
'
)
;
Ember
.
RSVP
.
configure
(
'
async
'
function
(
callback
promise
)
{
Ember
.
run
.
backburner
.
schedule
(
'
actions
'
(
)
=
>
{
callback
(
promise
)
;
}
)
;
}
)
;
}
function
_teardownPromiseListeners
(
)
{
Ember
.
RSVP
.
configure
(
'
async
'
originalAsync
)
;
}
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
-
for
-
acceptance
'
[
'
exports
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
abstract
-
test
-
module
'
'
ember
/
test
-
helpers
'
]
function
(
exports
_abstractTestModule
_testHelpers
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
class
extends
_abstractTestModule
.
default
{
setupContext
(
)
{
super
.
setupContext
(
{
application
:
this
.
createApplication
(
)
}
)
;
}
teardownContext
(
)
{
Ember
.
run
(
(
)
=
>
{
(
0
_testHelpers
.
getContext
)
(
)
.
application
.
destroy
(
)
;
}
)
;
super
.
teardownContext
(
)
;
}
createApplication
(
)
{
let
{
Application
config
}
=
this
.
callbacks
;
let
application
;
Ember
.
run
(
(
)
=
>
{
application
=
Application
.
create
(
config
)
;
application
.
setupForTesting
(
)
;
application
.
injectTestHelpers
(
)
;
}
)
;
return
application
;
}
}
;
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
-
for
-
component
'
[
'
exports
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
'
'
ember
-
test
-
helpers
/
has
-
ember
-
version
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
-
legacy
-
overrides
'
]
function
(
exports
_testModule
_hasEmberVersion
_legacyOverrides
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
setupComponentIntegrationTest
=
setupComponentIntegrationTest
;
let
ACTION_KEY
;
if
(
(
0
_hasEmberVersion
.
default
)
(
2
0
)
)
{
ACTION_KEY
=
'
actions
'
;
}
else
{
ACTION_KEY
=
'
_actions
'
;
}
const
isPreGlimmer
=
!
(
0
_hasEmberVersion
.
default
)
(
1
13
)
;
exports
.
default
=
class
extends
_testModule
.
default
{
constructor
(
componentName
description
callbacks
)
{
if
(
!
callbacks
&
&
typeof
description
=
=
=
'
object
'
)
{
callbacks
=
description
;
description
=
null
;
}
else
if
(
!
callbacks
)
{
callbacks
=
{
}
;
}
let
integrationOption
=
callbacks
.
integration
;
let
hasNeeds
=
Array
.
isArray
(
callbacks
.
needs
)
;
super
(
'
component
:
'
+
componentName
description
callbacks
)
;
this
.
componentName
=
componentName
;
if
(
hasNeeds
|
|
callbacks
.
unit
|
|
integrationOption
=
=
=
false
)
{
this
.
isUnitTest
=
true
;
}
else
if
(
integrationOption
)
{
this
.
isUnitTest
=
false
;
}
else
{
Ember
.
deprecate
(
'
the
component
:
'
+
componentName
+
'
test
module
is
implicitly
running
in
unit
test
mode
'
+
'
which
will
change
to
integration
test
mode
by
default
in
an
upcoming
version
of
'
+
'
ember
-
test
-
helpers
.
Add
unit
:
true
or
a
needs
:
[
]
list
to
explicitly
opt
in
to
unit
'
+
'
test
mode
.
'
false
{
id
:
'
ember
-
test
-
helpers
.
test
-
module
-
for
-
component
.
test
-
type
'
until
:
'
0
.
6
.
0
'
}
)
;
this
.
isUnitTest
=
true
;
}
if
(
!
this
.
isUnitTest
&
&
!
this
.
isLegacy
)
{
callbacks
.
integration
=
true
;
}
if
(
this
.
isUnitTest
|
|
this
.
isLegacy
)
{
this
.
setupSteps
.
push
(
this
.
setupComponentUnitTest
)
;
}
else
{
this
.
callbacks
.
subject
=
function
(
)
{
throw
new
Error
(
"
component
integration
tests
do
not
support
subject
(
)
.
Instead
render
the
component
as
if
it
were
HTML
:
this
.
render
(
'
<
my
-
component
foo
=
true
>
'
)
;
.
For
more
information
read
:
http
:
/
/
guides
.
emberjs
.
com
/
v2
.
2
.
0
/
testing
/
testing
-
components
/
"
)
;
}
;
this
.
setupSteps
.
push
(
this
.
setupComponentIntegrationTest
)
;
this
.
teardownSteps
.
unshift
(
this
.
teardownComponent
)
;
}
if
(
Ember
.
View
&
&
Ember
.
View
.
views
)
{
this
.
setupSteps
.
push
(
this
.
_aliasViewRegistry
)
;
this
.
teardownSteps
.
unshift
(
this
.
_resetViewRegistry
)
;
}
}
initIntegration
(
options
)
{
this
.
isLegacy
=
options
.
integration
=
=
=
'
legacy
'
;
this
.
isIntegration
=
options
.
integration
!
=
=
'
legacy
'
;
}
_aliasViewRegistry
(
)
{
this
.
_originalGlobalViewRegistry
=
Ember
.
View
.
views
;
var
viewRegistry
=
this
.
container
.
lookup
(
'
-
view
-
registry
:
main
'
)
;
if
(
viewRegistry
)
{
Ember
.
View
.
views
=
viewRegistry
;
}
}
_resetViewRegistry
(
)
{
Ember
.
View
.
views
=
this
.
_originalGlobalViewRegistry
;
}
setupComponentUnitTest
(
)
{
var
_this
=
this
;
var
resolver
=
this
.
resolver
;
var
context
=
this
.
context
;
var
layoutName
=
'
template
:
components
/
'
+
this
.
componentName
;
var
layout
=
resolver
.
resolve
(
layoutName
)
;
var
thingToRegisterWith
=
this
.
registry
|
|
this
.
container
;
if
(
layout
)
{
thingToRegisterWith
.
register
(
layoutName
layout
)
;
thingToRegisterWith
.
injection
(
this
.
subjectName
'
layout
'
layoutName
)
;
}
var
eventDispatcher
=
resolver
.
resolve
(
'
event_dispatcher
:
main
'
)
;
if
(
eventDispatcher
)
{
thingToRegisterWith
.
register
(
'
event_dispatcher
:
main
'
eventDispatcher
)
;
}
context
.
dispatcher
=
this
.
container
.
lookup
(
'
event_dispatcher
:
main
'
)
|
|
Ember
.
EventDispatcher
.
create
(
)
;
context
.
dispatcher
.
setup
(
{
}
'
#
ember
-
testing
'
)
;
context
.
_element
=
null
;
this
.
callbacks
.
render
=
function
(
)
{
var
subject
;
Ember
.
run
(
function
(
)
{
subject
=
context
.
subject
(
)
;
subject
.
appendTo
(
'
#
ember
-
testing
'
)
;
}
)
;
context
.
_element
=
subject
.
element
;
_this
.
teardownSteps
.
unshift
(
function
(
)
{
Ember
.
run
(
function
(
)
{
Ember
.
tryInvoke
(
subject
'
destroy
'
)
;
}
)
;
}
)
;
}
;
this
.
callbacks
.
append
=
function
(
)
{
Ember
.
deprecate
(
'
this
.
append
(
)
is
deprecated
.
Please
use
this
.
render
(
)
or
this
.
(
)
instead
.
'
false
{
id
:
'
ember
-
test
-
helpers
.
test
-
module
-
for
-
component
.
append
'
until
:
'
0
.
6
.
0
'
}
)
;
return
context
.
(
)
;
}
;
context
.
=
function
(
)
{
this
.
render
(
)
;
var
subject
=
this
.
subject
(
)
;
return
subject
.
.
apply
(
subject
arguments
)
;
}
;
}
setupComponentIntegrationTest
(
)
{
if
(
isPreGlimmer
)
{
return
_legacyOverrides
.
preGlimmerSetupIntegrationForComponent
.
apply
(
this
arguments
)
;
}
else
{
return
setupComponentIntegrationTest
.
apply
(
this
arguments
)
;
}
}
setupContext
(
)
{
super
.
setupContext
(
)
;
if
(
this
.
container
.
factoryFor
?
this
.
container
.
factoryFor
(
'
-
view
-
registry
:
main
'
)
:
this
.
container
.
lookupFactory
(
'
-
view
-
registry
:
main
'
)
)
{
(
this
.
registry
|
|
this
.
container
)
.
injection
(
'
component
'
'
_viewRegistry
'
'
-
view
-
registry
:
main
'
)
;
}
if
(
!
this
.
isUnitTest
&
&
!
this
.
isLegacy
)
{
this
.
context
.
factory
=
function
(
)
{
}
;
}
}
teardownComponent
(
)
{
var
component
=
this
.
component
;
if
(
component
)
{
Ember
.
run
(
component
'
destroy
'
)
;
this
.
component
=
null
;
}
}
}
;
function
setupComponentIntegrationTest
(
)
{
var
module
=
this
;
var
context
=
this
.
context
;
this
.
actionHooks
=
context
[
ACTION_KEY
]
=
{
}
;
context
.
dispatcher
=
this
.
container
.
lookup
(
'
event_dispatcher
:
main
'
)
|
|
Ember
.
EventDispatcher
.
create
(
)
;
context
.
dispatcher
.
setup
(
{
}
'
#
ember
-
testing
'
)
;
var
hasRendered
=
false
;
var
OutletView
=
module
.
container
.
factoryFor
?
module
.
container
.
factoryFor
(
'
view
:
-
outlet
'
)
:
module
.
container
.
lookupFactory
(
'
view
:
-
outlet
'
)
;
var
OutletTemplate
=
module
.
container
.
lookup
(
'
template
:
-
outlet
'
)
;
var
toplevelView
=
module
.
component
=
OutletView
.
create
(
)
;
var
hasOutletTemplate
=
!
!
OutletTemplate
;
var
outletState
=
{
render
:
{
owner
:
Ember
.
getOwner
?
Ember
.
getOwner
(
module
.
container
)
:
undefined
into
:
undefined
outlet
:
'
main
'
name
:
'
application
'
controller
:
module
.
context
ViewClass
:
undefined
template
:
OutletTemplate
}
outlets
:
{
}
}
;
var
element
=
document
.
getElementById
(
'
ember
-
testing
'
)
;
var
templateId
=
0
;
if
(
hasOutletTemplate
)
{
Ember
.
run
(
(
)
=
>
{
toplevelView
.
setOutletState
(
outletState
)
;
}
)
;
}
context
.
render
=
function
(
template
)
{
if
(
!
template
)
{
throw
new
Error
(
'
in
a
component
integration
test
you
must
pass
a
template
to
render
(
)
'
)
;
}
if
(
Ember
.
isArray
(
template
)
)
{
template
=
template
.
join
(
'
'
)
;
}
if
(
typeof
template
=
=
=
'
string
'
)
{
template
=
Ember
.
Handlebars
.
compile
(
template
)
;
}
var
templateFullName
=
'
template
:
-
undertest
-
'
+
+
+
templateId
;
this
.
registry
.
register
(
templateFullName
template
)
;
var
stateToRender
=
{
owner
:
Ember
.
getOwner
?
Ember
.
getOwner
(
module
.
container
)
:
undefined
into
:
undefined
outlet
:
'
main
'
name
:
'
index
'
controller
:
module
.
context
ViewClass
:
undefined
template
:
module
.
container
.
lookup
(
templateFullName
)
outlets
:
{
}
}
;
if
(
hasOutletTemplate
)
{
stateToRender
.
name
=
'
index
'
;
outletState
.
outlets
.
main
=
{
render
:
stateToRender
outlets
:
{
}
}
;
}
else
{
stateToRender
.
name
=
'
application
'
;
outletState
=
{
render
:
stateToRender
outlets
:
{
}
}
;
}
Ember
.
run
(
(
)
=
>
{
toplevelView
.
setOutletState
(
outletState
)
;
}
)
;
if
(
!
hasRendered
)
{
Ember
.
run
(
module
.
component
'
appendTo
'
'
#
ember
-
testing
'
)
;
hasRendered
=
true
;
}
if
(
EmberENV
.
_APPLICATION_TEMPLATE_WRAPPER
!
=
=
false
)
{
context
.
_element
=
element
=
document
.
querySelector
(
'
#
ember
-
testing
>
.
ember
-
view
'
)
;
}
else
{
context
.
_element
=
element
=
document
.
querySelector
(
'
#
ember
-
testing
'
)
;
}
}
;
context
.
=
function
(
selector
)
{
return
selector
?
Ember
.
(
selector
element
)
:
Ember
.
(
element
)
;
}
;
context
.
set
=
function
(
key
value
)
{
var
ret
=
Ember
.
run
(
function
(
)
{
return
Ember
.
set
(
context
key
value
)
;
}
)
;
if
(
(
0
_hasEmberVersion
.
default
)
(
2
0
)
)
{
return
ret
;
}
}
;
context
.
setProperties
=
function
(
hash
)
{
var
ret
=
Ember
.
run
(
function
(
)
{
return
Ember
.
setProperties
(
context
hash
)
;
}
)
;
if
(
(
0
_hasEmberVersion
.
default
)
(
2
0
)
)
{
return
ret
;
}
}
;
context
.
get
=
function
(
key
)
{
return
Ember
.
get
(
context
key
)
;
}
;
context
.
getProperties
=
function
(
)
{
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
return
Ember
.
getProperties
(
context
args
)
;
}
;
context
.
on
=
function
(
actionName
handler
)
{
module
.
actionHooks
[
actionName
]
=
handler
;
}
;
context
.
send
=
function
(
actionName
)
{
var
hook
=
module
.
actionHooks
[
actionName
]
;
if
(
!
hook
)
{
throw
new
Error
(
'
integration
testing
template
received
unexpected
action
'
+
actionName
)
;
}
hook
.
apply
(
module
.
context
Array
.
prototype
.
slice
.
call
(
arguments
1
)
)
;
}
;
context
.
clearRender
=
function
(
)
{
Ember
.
run
(
function
(
)
{
toplevelView
.
setOutletState
(
{
render
:
{
owner
:
module
.
container
into
:
undefined
outlet
:
'
main
'
name
:
'
application
'
controller
:
module
.
context
ViewClass
:
undefined
template
:
undefined
}
outlets
:
{
}
}
)
;
}
)
;
}
;
}
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
-
for
-
model
'
[
'
exports
'
'
require
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
'
]
function
(
exports
_require2
_testModule
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
class
extends
_testModule
.
default
{
constructor
(
modelName
description
callbacks
)
{
super
(
'
model
:
'
+
modelName
description
callbacks
)
;
this
.
modelName
=
modelName
;
this
.
setupSteps
.
push
(
this
.
setupModel
)
;
}
setupModel
(
)
{
var
container
=
this
.
container
;
var
defaultSubject
=
this
.
defaultSubject
;
var
callbacks
=
this
.
callbacks
;
var
modelName
=
this
.
modelName
;
var
adapterFactory
=
container
.
factoryFor
?
container
.
factoryFor
(
'
adapter
:
application
'
)
:
container
.
lookupFactory
(
'
adapter
:
application
'
)
;
if
(
!
adapterFactory
)
{
if
(
requirejs
.
entries
[
'
ember
-
data
/
adapters
/
json
-
api
'
]
)
{
adapterFactory
=
(
0
_require2
.
default
)
(
'
ember
-
data
/
adapters
/
json
-
api
'
)
[
'
default
'
]
;
}
if
(
!
adapterFactory
|
|
!
adapterFactory
.
create
)
{
adapterFactory
=
DS
.
JSONAPIAdapter
|
|
DS
.
FixtureAdapter
;
}
var
thingToRegisterWith
=
this
.
registry
|
|
this
.
container
;
thingToRegisterWith
.
register
(
'
adapter
:
application
'
adapterFactory
)
;
}
callbacks
.
store
=
function
(
)
{
var
container
=
this
.
container
;
return
container
.
lookup
(
'
service
:
store
'
)
|
|
container
.
lookup
(
'
store
:
main
'
)
;
}
;
if
(
callbacks
.
subject
=
=
=
defaultSubject
)
{
callbacks
.
subject
=
function
(
options
)
{
var
container
=
this
.
container
;
return
Ember
.
run
(
function
(
)
{
var
store
=
container
.
lookup
(
'
service
:
store
'
)
|
|
container
.
lookup
(
'
store
:
main
'
)
;
return
store
.
createRecord
(
modelName
options
)
;
}
)
;
}
;
}
}
}
;
}
)
;
define
(
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
test
-
module
'
[
'
exports
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
abstract
-
test
-
module
'
'
ember
/
test
-
helpers
'
'
ember
-
test
-
helpers
/
legacy
-
0
-
6
-
x
/
build
-
registry
'
'
ember
/
test
-
helpers
/
has
-
ember
-
version
'
]
function
(
exports
_abstractTestModule
_testHelpers
_buildRegistry
_hasEmberVersion
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
class
extends
_abstractTestModule
.
default
{
constructor
(
subjectName
description
callbacks
)
{
if
(
!
callbacks
&
&
typeof
description
=
=
=
'
object
'
)
{
callbacks
=
description
;
description
=
subjectName
;
}
super
(
description
|
|
subjectName
callbacks
)
;
this
.
subjectName
=
subjectName
;
this
.
description
=
description
|
|
subjectName
;
this
.
resolver
=
this
.
callbacks
.
resolver
|
|
(
0
_testHelpers
.
getResolver
)
(
)
;
if
(
this
.
callbacks
.
integration
&
&
this
.
callbacks
.
needs
)
{
throw
new
Error
(
"
cannot
declare
'
integration
:
true
'
and
'
needs
'
in
the
same
module
"
)
;
}
if
(
this
.
callbacks
.
integration
)
{
this
.
initIntegration
(
callbacks
)
;
delete
callbacks
.
integration
;
}
this
.
initSubject
(
)
;
this
.
initNeeds
(
)
;
}
initIntegration
(
options
)
{
if
(
options
.
integration
=
=
=
'
legacy
'
)
{
throw
new
Error
(
"
integration
:
'
legacy
'
is
only
valid
for
component
tests
.
"
)
;
}
this
.
isIntegration
=
true
;
}
initSubject
(
)
{
this
.
callbacks
.
subject
=
this
.
callbacks
.
subject
|
|
this
.
defaultSubject
;
}
initNeeds
(
)
{
this
.
needs
=
[
this
.
subjectName
]
;
if
(
this
.
callbacks
.
needs
)
{
this
.
needs
=
this
.
needs
.
concat
(
this
.
callbacks
.
needs
)
;
delete
this
.
callbacks
.
needs
;
}
}
initSetupSteps
(
)
{
this
.
setupSteps
=
[
]
;
this
.
contextualizedSetupSteps
=
[
]
;
if
(
this
.
callbacks
.
beforeSetup
)
{
this
.
setupSteps
.
push
(
this
.
callbacks
.
beforeSetup
)
;
delete
this
.
callbacks
.
beforeSetup
;
}
this
.
setupSteps
.
push
(
this
.
setupContainer
)
;
this
.
setupSteps
.
push
(
this
.
setupContext
)
;
this
.
setupSteps
.
push
(
this
.
setupTestElements
)
;
this
.
setupSteps
.
push
(
this
.
setupAJAXListeners
)
;
this
.
setupSteps
.
push
(
this
.
setupPromiseListeners
)
;
if
(
this
.
callbacks
.
setup
)
{
this
.
contextualizedSetupSteps
.
push
(
this
.
callbacks
.
setup
)
;
delete
this
.
callbacks
.
setup
;
}
}
initTeardownSteps
(
)
{
this
.
teardownSteps
=
[
]
;
this
.
contextualizedTeardownSteps
=
[
]
;
if
(
this
.
callbacks
.
teardown
)
{
this
.
contextualizedTeardownSteps
.
push
(
this
.
callbacks
.
teardown
)
;
delete
this
.
callbacks
.
teardown
;
}
this
.
teardownSteps
.
push
(
this
.
teardownSubject
)
;
this
.
teardownSteps
.
push
(
this
.
teardownContainer
)
;
this
.
teardownSteps
.
push
(
this
.
teardownContext
)
;
this
.
teardownSteps
.
push
(
this
.
teardownTestElements
)
;
this
.
teardownSteps
.
push
(
this
.
teardownAJAXListeners
)
;
this
.
teardownSteps
.
push
(
this
.
teardownPromiseListeners
)
;
if
(
this
.
callbacks
.
afterTeardown
)
{
this
.
teardownSteps
.
push
(
this
.
callbacks
.
afterTeardown
)
;
delete
this
.
callbacks
.
afterTeardown
;
}
}
setupContainer
(
)
{
if
(
this
.
isIntegration
|
|
this
.
isLegacy
)
{
this
.
_setupIntegratedContainer
(
)
;
}
else
{
this
.
_setupIsolatedContainer
(
)
;
}
}
setupContext
(
)
{
var
subjectName
=
this
.
subjectName
;
var
container
=
this
.
container
;
var
factory
=
function
(
)
{
return
container
.
factoryFor
?
container
.
factoryFor
(
subjectName
)
:
container
.
lookupFactory
(
subjectName
)
;
}
;
super
.
setupContext
(
{
container
:
this
.
container
registry
:
this
.
registry
factory
:
factory
register
(
)
{
var
target
=
this
.
registry
|
|
this
.
container
;
return
target
.
register
.
apply
(
target
arguments
)
;
}
}
)
;
if
(
Ember
.
setOwner
)
{
Ember
.
setOwner
(
this
.
context
this
.
container
.
owner
)
;
}
this
.
setupInject
(
)
;
}
setupInject
(
)
{
var
module
=
this
;
var
context
=
this
.
context
;
if
(
Ember
.
inject
)
{
var
keys
=
(
Object
.
keys
|
|
keys
)
(
Ember
.
inject
)
;
keys
.
forEach
(
function
(
typeName
)
{
context
.
inject
[
typeName
]
=
function
(
name
opts
)
{
var
alias
=
opts
&
&
opts
.
as
|
|
name
;
Ember
.
run
(
function
(
)
{
Ember
.
set
(
context
alias
module
.
container
.
lookup
(
typeName
+
'
:
'
+
name
)
)
;
}
)
;
}
;
}
)
;
}
}
teardownSubject
(
)
{
var
subject
=
this
.
cache
.
subject
;
if
(
subject
)
{
Ember
.
run
(
function
(
)
{
Ember
.
tryInvoke
(
subject
'
destroy
'
)
;
}
)
;
}
}
teardownContainer
(
)
{
var
container
=
this
.
container
;
Ember
.
run
(
function
(
)
{
container
.
destroy
(
)
;
}
)
;
}
defaultSubject
(
options
factory
)
{
return
factory
.
create
(
options
)
;
}
contextualizeCallbacks
(
)
{
var
callbacks
=
this
.
callbacks
;
var
context
=
this
.
context
;
this
.
cache
=
this
.
cache
|
|
{
}
;
this
.
cachedCalls
=
this
.
cachedCalls
|
|
{
}
;
var
keys
=
(
Object
.
keys
|
|
keys
)
(
callbacks
)
;
var
keysLength
=
keys
.
length
;
if
(
keysLength
)
{
var
deprecatedContext
=
this
.
_buildDeprecatedContext
(
this
context
)
;
for
(
var
i
=
0
;
i
<
keysLength
;
i
+
+
)
{
this
.
_contextualizeCallback
(
context
keys
[
i
]
deprecatedContext
)
;
}
}
}
_contextualizeCallback
(
context
key
callbackContext
)
{
var
_this
=
this
;
var
callbacks
=
this
.
callbacks
;
var
factory
=
context
.
factory
;
context
[
key
]
=
function
(
options
)
{
if
(
_this
.
cachedCalls
[
key
]
)
{
return
_this
.
cache
[
key
]
;
}
var
result
=
callbacks
[
key
]
.
call
(
callbackContext
options
factory
(
)
)
;
_this
.
cache
[
key
]
=
result
;
_this
.
cachedCalls
[
key
]
=
true
;
return
result
;
}
;
}
_buildDeprecatedContext
(
module
context
)
{
var
deprecatedContext
=
Object
.
create
(
context
)
;
var
keysForDeprecation
=
Object
.
keys
(
module
)
;
for
(
var
i
=
0
l
=
keysForDeprecation
.
length
;
i
<
l
;
i
+
+
)
{
this
.
_proxyDeprecation
(
module
deprecatedContext
keysForDeprecation
[
i
]
)
;
}
return
deprecatedContext
;
}
_proxyDeprecation
(
obj
proxy
key
)
{
if
(
typeof
proxy
[
key
]
=
=
=
'
undefined
'
)
{
Object
.
defineProperty
(
proxy
key
{
get
(
)
{
Ember
.
deprecate
(
'
Accessing
the
test
module
property
"
'
+
key
+
'
"
from
a
callback
is
deprecated
.
'
false
{
id
:
'
ember
-
test
-
helpers
.
test
-
module
.
callback
-
context
'
until
:
'
0
.
6
.
0
'
}
)
;
return
obj
[
key
]
;
}
}
)
;
}
}
_setupContainer
(
isolated
)
{
var
resolver
=
this
.
resolver
;
var
items
=
(
0
_buildRegistry
.
default
)
(
!
isolated
?
resolver
:
Object
.
create
(
resolver
{
resolve
:
{
value
(
)
{
}
}
}
)
)
;
this
.
container
=
items
.
container
;
this
.
registry
=
items
.
registry
;
if
(
(
0
_hasEmberVersion
.
default
)
(
1
13
)
)
{
var
thingToRegisterWith
=
this
.
registry
|
|
this
.
container
;
var
router
=
resolver
.
resolve
(
'
router
:
main
'
)
;
router
=
router
|
|
Ember
.
Router
.
extend
(
)
;
thingToRegisterWith
.
register
(
'
router
:
main
'
router
)
;
}
}
_setupIsolatedContainer
(
)
{
var
resolver
=
this
.
resolver
;
this
.
_setupContainer
(
true
)
;
var
thingToRegisterWith
=
this
.
registry
|
|
this
.
container
;
for
(
var
i
=
this
.
needs
.
length
;
i
>
0
;
i
-
-
)
{
var
fullName
=
this
.
needs
[
i
-
1
]
;
var
normalizedFullName
=
resolver
.
normalize
(
fullName
)
;
thingToRegisterWith
.
register
(
fullName
resolver
.
resolve
(
normalizedFullName
)
)
;
}
if
(
!
this
.
registry
)
{
this
.
container
.
resolver
=
function
(
)
{
}
;
}
}
_setupIntegratedContainer
(
)
{
this
.
_setupContainer
(
)
;
}
}
;
}
)
;
define
(
'
ember
-
test
-
helpers
/
wait
'
[
'
exports
'
'
ember
/
test
-
helpers
/
settled
'
'
ember
/
test
-
helpers
'
]
function
(
exports
_settled
_testHelpers
)
{
'
use
strict
'
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
_teardownPromiseListeners
=
exports
.
_teardownAJAXHooks
=
exports
.
_setupPromiseListeners
=
exports
.
_setupAJAXHooks
=
undefined
;
Object
.
defineProperty
(
exports
'
_setupAJAXHooks
'
{
enumerable
:
true
get
:
function
(
)
{
return
_settled
.
_setupAJAXHooks
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_setupPromiseListeners
'
{
enumerable
:
true
get
:
function
(
)
{
return
_settled
.
_setupPromiseListeners
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_teardownAJAXHooks
'
{
enumerable
:
true
get
:
function
(
)
{
return
_settled
.
_teardownAJAXHooks
;
}
}
)
;
Object
.
defineProperty
(
exports
'
_teardownPromiseListeners
'
{
enumerable
:
true
get
:
function
(
)
{
return
_settled
.
_teardownPromiseListeners
;
}
}
)
;
exports
.
default
=
wait
;
function
wait
(
options
=
{
}
)
{
if
(
typeof
options
!
=
=
'
object
'
|
|
options
=
=
=
null
)
{
options
=
{
}
;
}
return
(
0
_testHelpers
.
waitUntil
)
(
(
)
=
>
{
let
waitForTimers
=
'
waitForTimers
'
in
options
?
options
.
waitForTimers
:
true
;
let
waitForAJAX
=
'
waitForAJAX
'
in
options
?
options
.
waitForAJAX
:
true
;
let
waitForWaiters
=
'
waitForWaiters
'
in
options
?
options
.
waitForWaiters
:
true
;
let
{
hasPendingTimers
hasRunLoop
hasPendingRequests
hasPendingWaiters
}
=
(
0
_testHelpers
.
getSettledState
)
(
)
;
if
(
waitForTimers
&
&
(
hasPendingTimers
|
|
hasRunLoop
)
)
{
return
false
;
}
if
(
waitForAJAX
&
&
hasPendingRequests
)
{
return
false
;
}
if
(
waitForWaiters
&
&
hasPendingWaiters
)
{
return
false
;
}
return
true
;
}
{
timeout
:
Infinity
}
)
;
}
}
)
;
define
(
"
qunit
/
index
"
[
"
exports
"
]
function
(
exports
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
_module
=
QUnit
.
module
;
exports
.
module
=
_module
;
var
test
=
exports
.
test
=
QUnit
.
test
;
var
skip
=
exports
.
skip
=
QUnit
.
skip
;
var
only
=
exports
.
only
=
QUnit
.
only
;
var
todo
=
exports
.
todo
=
QUnit
.
todo
;
exports
.
default
=
QUnit
;
}
)
;
runningTests
=
true
;
if
(
window
.
Testem
)
{
window
.
Testem
.
hookIntoTestFramework
(
)
;
}
