(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
require
(
"
Services
"
)
require
(
"
devtools
/
shared
/
flags
"
)
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
"
Services
"
"
devtools
/
shared
/
flags
"
]
factory
)
;
else
{
var
a
=
typeof
exports
=
=
=
'
object
'
?
factory
(
require
(
"
Services
"
)
require
(
"
devtools
/
shared
/
flags
"
)
)
:
factory
(
root
[
"
Services
"
]
root
[
"
devtools
/
shared
/
flags
"
]
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
this
function
(
__WEBPACK_EXTERNAL_MODULE_29__
__WEBPACK_EXTERNAL_MODULE_121__
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
return
installedModules
[
moduleId
]
.
exports
;
var
module
=
installedModules
[
moduleId
]
=
{
exports
:
{
}
id
:
moduleId
loaded
:
false
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
loaded
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
0
)
;
}
)
(
{
0
:
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
757
)
;
}
6
:
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
7
)
getRawTag
=
__webpack_require__
(
10
)
objectToString
=
__webpack_require__
(
11
)
;
var
nullTag
=
'
[
object
Null
]
'
undefinedTag
=
'
[
object
Undefined
]
'
;
var
symToStringTag
=
Symbol
?
Symbol
.
toStringTag
:
undefined
;
function
baseGetTag
(
value
)
{
if
(
value
=
=
null
)
{
return
value
=
=
=
undefined
?
undefinedTag
:
nullTag
;
}
return
(
symToStringTag
&
&
symToStringTag
in
Object
(
value
)
)
?
getRawTag
(
value
)
:
objectToString
(
value
)
;
}
module
.
exports
=
baseGetTag
;
}
7
:
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
8
)
;
var
Symbol
=
root
.
Symbol
;
module
.
exports
=
Symbol
;
}
8
:
function
(
module
exports
__webpack_require__
)
{
var
freeGlobal
=
__webpack_require__
(
9
)
;
var
freeSelf
=
typeof
self
=
=
'
object
'
&
&
self
&
&
self
.
Object
=
=
=
Object
&
&
self
;
var
root
=
freeGlobal
|
|
freeSelf
|
|
Function
(
'
return
this
'
)
(
)
;
module
.
exports
=
root
;
}
9
:
function
(
module
exports
)
{
(
function
(
global
)
{
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
&
&
global
.
Object
=
=
=
Object
&
&
global
;
module
.
exports
=
freeGlobal
;
}
.
call
(
exports
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
10
:
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
7
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
nativeObjectToString
=
objectProto
.
toString
;
var
symToStringTag
=
Symbol
?
Symbol
.
toStringTag
:
undefined
;
function
getRawTag
(
value
)
{
var
isOwn
=
hasOwnProperty
.
call
(
value
symToStringTag
)
tag
=
value
[
symToStringTag
]
;
try
{
value
[
symToStringTag
]
=
undefined
;
var
unmasked
=
true
;
}
catch
(
e
)
{
}
var
result
=
nativeObjectToString
.
call
(
value
)
;
if
(
unmasked
)
{
if
(
isOwn
)
{
value
[
symToStringTag
]
=
tag
;
}
else
{
delete
value
[
symToStringTag
]
;
}
}
return
result
;
}
module
.
exports
=
getRawTag
;
}
11
:
function
(
module
exports
)
{
var
objectProto
=
Object
.
prototype
;
var
nativeObjectToString
=
objectProto
.
toString
;
function
objectToString
(
value
)
{
return
nativeObjectToString
.
call
(
value
)
;
}
module
.
exports
=
objectToString
;
}
13
:
function
(
module
exports
)
{
function
overArg
(
func
transform
)
{
return
function
(
arg
)
{
return
func
(
transform
(
arg
)
)
;
}
;
}
module
.
exports
=
overArg
;
}
14
:
function
(
module
exports
)
{
function
isObjectLike
(
value
)
{
return
value
!
=
null
&
&
typeof
value
=
=
'
object
'
;
}
module
.
exports
=
isObjectLike
;
}
29
:
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_29__
;
}
51
:
function
(
module
exports
)
{
module
.
exports
=
function
(
module
)
{
if
(
!
module
.
webpackPolyfill
)
{
module
.
deprecate
=
function
(
)
{
}
;
module
.
paths
=
[
]
;
module
.
children
=
[
]
;
module
.
webpackPolyfill
=
1
;
}
return
module
;
}
}
67
:
function
(
module
exports
__webpack_require__
)
{
var
baseGet
=
__webpack_require__
(
68
)
;
function
get
(
object
path
defaultValue
)
{
var
result
=
object
=
=
null
?
undefined
:
baseGet
(
object
path
)
;
return
result
=
=
=
undefined
?
defaultValue
:
result
;
}
module
.
exports
=
get
;
}
68
:
function
(
module
exports
__webpack_require__
)
{
var
castPath
=
__webpack_require__
(
69
)
toKey
=
__webpack_require__
(
111
)
;
function
baseGet
(
object
path
)
{
path
=
castPath
(
path
object
)
;
var
index
=
0
length
=
path
.
length
;
while
(
object
!
=
null
&
&
index
<
length
)
{
object
=
object
[
toKey
(
path
[
index
+
+
]
)
]
;
}
return
(
index
&
&
index
=
=
length
)
?
object
:
undefined
;
}
module
.
exports
=
baseGet
;
}
69
:
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
70
)
isKey
=
__webpack_require__
(
71
)
stringToPath
=
__webpack_require__
(
73
)
toString
=
__webpack_require__
(
108
)
;
function
castPath
(
value
object
)
{
if
(
isArray
(
value
)
)
{
return
value
;
}
return
isKey
(
value
object
)
?
[
value
]
:
stringToPath
(
toString
(
value
)
)
;
}
module
.
exports
=
castPath
;
}
70
:
function
(
module
exports
)
{
var
isArray
=
Array
.
isArray
;
module
.
exports
=
isArray
;
}
71
:
function
(
module
exports
__webpack_require__
)
{
var
isArray
=
__webpack_require__
(
70
)
isSymbol
=
__webpack_require__
(
72
)
;
var
reIsDeepProp
=
/
\
.
|
\
[
(
?
:
[
^
[
\
]
]
*
|
(
[
"
'
]
)
(
?
:
(
?
!
\
1
)
[
^
\
\
]
|
\
\
.
)
*
?
\
1
)
\
]
/
reIsPlainProp
=
/
^
\
w
*
/
;
function
isKey
(
value
object
)
{
if
(
isArray
(
value
)
)
{
return
false
;
}
var
type
=
typeof
value
;
if
(
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
|
|
value
=
=
null
|
|
isSymbol
(
value
)
)
{
return
true
;
}
return
reIsPlainProp
.
test
(
value
)
|
|
!
reIsDeepProp
.
test
(
value
)
|
|
(
object
!
=
null
&
&
value
in
Object
(
object
)
)
;
}
module
.
exports
=
isKey
;
}
72
:
function
(
module
exports
__webpack_require__
)
{
var
baseGetTag
=
__webpack_require__
(
6
)
isObjectLike
=
__webpack_require__
(
14
)
;
var
symbolTag
=
'
[
object
Symbol
]
'
;
function
isSymbol
(
value
)
{
return
typeof
value
=
=
'
symbol
'
|
|
(
isObjectLike
(
value
)
&
&
baseGetTag
(
value
)
=
=
symbolTag
)
;
}
module
.
exports
=
isSymbol
;
}
73
:
function
(
module
exports
__webpack_require__
)
{
var
memoizeCapped
=
__webpack_require__
(
74
)
;
var
reLeadingDot
=
/
^
\
.
/
rePropName
=
/
[
^
.
[
\
]
]
+
|
\
[
(
?
:
(
-
?
\
d
+
(
?
:
\
.
\
d
+
)
?
)
|
(
[
"
'
]
)
(
(
?
:
(
?
!
\
2
)
[
^
\
\
]
|
\
\
.
)
*
?
)
\
2
)
\
]
|
(
?
=
(
?
:
\
.
|
\
[
\
]
)
(
?
:
\
.
|
\
[
\
]
|
)
)
/
g
;
var
reEscapeChar
=
/
\
\
(
\
\
)
?
/
g
;
var
stringToPath
=
memoizeCapped
(
function
(
string
)
{
var
result
=
[
]
;
if
(
reLeadingDot
.
test
(
string
)
)
{
result
.
push
(
'
'
)
;
}
string
.
replace
(
rePropName
function
(
match
number
quote
string
)
{
result
.
push
(
quote
?
string
.
replace
(
reEscapeChar
'
1
'
)
:
(
number
|
|
match
)
)
;
}
)
;
return
result
;
}
)
;
module
.
exports
=
stringToPath
;
}
74
:
function
(
module
exports
__webpack_require__
)
{
var
memoize
=
__webpack_require__
(
75
)
;
var
MAX_MEMOIZE_SIZE
=
500
;
function
memoizeCapped
(
func
)
{
var
result
=
memoize
(
func
function
(
key
)
{
if
(
cache
.
size
=
=
=
MAX_MEMOIZE_SIZE
)
{
cache
.
clear
(
)
;
}
return
key
;
}
)
;
var
cache
=
result
.
cache
;
return
result
;
}
module
.
exports
=
memoizeCapped
;
}
75
:
function
(
module
exports
__webpack_require__
)
{
var
MapCache
=
__webpack_require__
(
76
)
;
var
FUNC_ERROR_TEXT
=
'
Expected
a
function
'
;
function
memoize
(
func
resolver
)
{
if
(
typeof
func
!
=
'
function
'
|
|
(
resolver
!
=
null
&
&
typeof
resolver
!
=
'
function
'
)
)
{
throw
new
TypeError
(
FUNC_ERROR_TEXT
)
;
}
var
memoized
=
function
(
)
{
var
args
=
arguments
key
=
resolver
?
resolver
.
apply
(
this
args
)
:
args
[
0
]
cache
=
memoized
.
cache
;
if
(
cache
.
has
(
key
)
)
{
return
cache
.
get
(
key
)
;
}
var
result
=
func
.
apply
(
this
args
)
;
memoized
.
cache
=
cache
.
set
(
key
result
)
|
|
cache
;
return
result
;
}
;
memoized
.
cache
=
new
(
memoize
.
Cache
|
|
MapCache
)
;
return
memoized
;
}
memoize
.
Cache
=
MapCache
;
module
.
exports
=
memoize
;
}
76
:
function
(
module
exports
__webpack_require__
)
{
var
mapCacheClear
=
__webpack_require__
(
77
)
mapCacheDelete
=
__webpack_require__
(
102
)
mapCacheGet
=
__webpack_require__
(
105
)
mapCacheHas
=
__webpack_require__
(
106
)
mapCacheSet
=
__webpack_require__
(
107
)
;
function
MapCache
(
entries
)
{
var
index
=
-
1
length
=
entries
=
=
null
?
0
:
entries
.
length
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
MapCache
.
prototype
.
clear
=
mapCacheClear
;
MapCache
.
prototype
[
'
delete
'
]
=
mapCacheDelete
;
MapCache
.
prototype
.
get
=
mapCacheGet
;
MapCache
.
prototype
.
has
=
mapCacheHas
;
MapCache
.
prototype
.
set
=
mapCacheSet
;
module
.
exports
=
MapCache
;
}
77
:
function
(
module
exports
__webpack_require__
)
{
var
Hash
=
__webpack_require__
(
78
)
ListCache
=
__webpack_require__
(
93
)
Map
=
__webpack_require__
(
101
)
;
function
mapCacheClear
(
)
{
this
.
size
=
0
;
this
.
__data__
=
{
'
hash
'
:
new
Hash
'
map
'
:
new
(
Map
|
|
ListCache
)
'
string
'
:
new
Hash
}
;
}
module
.
exports
=
mapCacheClear
;
}
78
:
function
(
module
exports
__webpack_require__
)
{
var
hashClear
=
__webpack_require__
(
79
)
hashDelete
=
__webpack_require__
(
89
)
hashGet
=
__webpack_require__
(
90
)
hashHas
=
__webpack_require__
(
91
)
hashSet
=
__webpack_require__
(
92
)
;
function
Hash
(
entries
)
{
var
index
=
-
1
length
=
entries
=
=
null
?
0
:
entries
.
length
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
Hash
.
prototype
.
clear
=
hashClear
;
Hash
.
prototype
[
'
delete
'
]
=
hashDelete
;
Hash
.
prototype
.
get
=
hashGet
;
Hash
.
prototype
.
has
=
hashHas
;
Hash
.
prototype
.
set
=
hashSet
;
module
.
exports
=
Hash
;
}
79
:
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
80
)
;
function
hashClear
(
)
{
this
.
__data__
=
nativeCreate
?
nativeCreate
(
null
)
:
{
}
;
this
.
size
=
0
;
}
module
.
exports
=
hashClear
;
}
80
:
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
81
)
;
var
nativeCreate
=
getNative
(
Object
'
create
'
)
;
module
.
exports
=
nativeCreate
;
}
81
:
function
(
module
exports
__webpack_require__
)
{
var
baseIsNative
=
__webpack_require__
(
82
)
getValue
=
__webpack_require__
(
88
)
;
function
getNative
(
object
key
)
{
var
value
=
getValue
(
object
key
)
;
return
baseIsNative
(
value
)
?
value
:
undefined
;
}
module
.
exports
=
getNative
;
}
82
:
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
83
)
isMasked
=
__webpack_require__
(
85
)
isObject
=
__webpack_require__
(
84
)
toSource
=
__webpack_require__
(
87
)
;
var
reRegExpChar
=
/
[
\
\
^
.
*
+
?
(
)
[
\
]
{
}
|
]
/
g
;
var
reIsHostCtor
=
/
^
\
[
object
.
+
?
Constructor
\
]
/
;
var
funcProto
=
Function
.
prototype
objectProto
=
Object
.
prototype
;
var
funcToString
=
funcProto
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
reIsNative
=
RegExp
(
'
^
'
+
funcToString
.
call
(
hasOwnProperty
)
.
replace
(
reRegExpChar
'
\
\
&
'
)
.
replace
(
/
hasOwnProperty
|
(
function
)
.
*
?
(
?
=
\
\
\
(
)
|
for
.
+
?
(
?
=
\
\
\
]
)
/
g
'
1
.
*
?
'
)
+
'
'
)
;
function
baseIsNative
(
value
)
{
if
(
!
isObject
(
value
)
|
|
isMasked
(
value
)
)
{
return
false
;
}
var
pattern
=
isFunction
(
value
)
?
reIsNative
:
reIsHostCtor
;
return
pattern
.
test
(
toSource
(
value
)
)
;
}
module
.
exports
=
baseIsNative
;
}
83
:
function
(
module
exports
__webpack_require__
)
{
var
baseGetTag
=
__webpack_require__
(
6
)
isObject
=
__webpack_require__
(
84
)
;
var
asyncTag
=
'
[
object
AsyncFunction
]
'
funcTag
=
'
[
object
Function
]
'
genTag
=
'
[
object
GeneratorFunction
]
'
proxyTag
=
'
[
object
Proxy
]
'
;
function
isFunction
(
value
)
{
if
(
!
isObject
(
value
)
)
{
return
false
;
}
var
tag
=
baseGetTag
(
value
)
;
return
tag
=
=
funcTag
|
|
tag
=
=
genTag
|
|
tag
=
=
asyncTag
|
|
tag
=
=
proxyTag
;
}
module
.
exports
=
isFunction
;
}
84
:
function
(
module
exports
)
{
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
value
!
=
null
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
module
.
exports
=
isObject
;
}
85
:
function
(
module
exports
__webpack_require__
)
{
var
coreJsData
=
__webpack_require__
(
86
)
;
var
maskSrcKey
=
(
function
(
)
{
var
uid
=
/
[
^
.
]
+
/
.
exec
(
coreJsData
&
&
coreJsData
.
keys
&
&
coreJsData
.
keys
.
IE_PROTO
|
|
'
'
)
;
return
uid
?
(
'
Symbol
(
src
)
_1
.
'
+
uid
)
:
'
'
;
}
(
)
)
;
function
isMasked
(
func
)
{
return
!
!
maskSrcKey
&
&
(
maskSrcKey
in
func
)
;
}
module
.
exports
=
isMasked
;
}
86
:
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
8
)
;
var
coreJsData
=
root
[
'
__core
-
js_shared__
'
]
;
module
.
exports
=
coreJsData
;
}
87
:
function
(
module
exports
)
{
var
funcProto
=
Function
.
prototype
;
var
funcToString
=
funcProto
.
toString
;
function
toSource
(
func
)
{
if
(
func
!
=
null
)
{
try
{
return
funcToString
.
call
(
func
)
;
}
catch
(
e
)
{
}
try
{
return
(
func
+
'
'
)
;
}
catch
(
e
)
{
}
}
return
'
'
;
}
module
.
exports
=
toSource
;
}
88
:
function
(
module
exports
)
{
function
getValue
(
object
key
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
module
.
exports
=
getValue
;
}
89
:
function
(
module
exports
)
{
function
hashDelete
(
key
)
{
var
result
=
this
.
has
(
key
)
&
&
delete
this
.
__data__
[
key
]
;
this
.
size
-
=
result
?
1
:
0
;
return
result
;
}
module
.
exports
=
hashDelete
;
}
90
:
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
80
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashGet
(
key
)
{
var
data
=
this
.
__data__
;
if
(
nativeCreate
)
{
var
result
=
data
[
key
]
;
return
result
=
=
=
HASH_UNDEFINED
?
undefined
:
result
;
}
return
hasOwnProperty
.
call
(
data
key
)
?
data
[
key
]
:
undefined
;
}
module
.
exports
=
hashGet
;
}
91
:
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
80
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
hashHas
(
key
)
{
var
data
=
this
.
__data__
;
return
nativeCreate
?
(
data
[
key
]
!
=
=
undefined
)
:
hasOwnProperty
.
call
(
data
key
)
;
}
module
.
exports
=
hashHas
;
}
92
:
function
(
module
exports
__webpack_require__
)
{
var
nativeCreate
=
__webpack_require__
(
80
)
;
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
function
hashSet
(
key
value
)
{
var
data
=
this
.
__data__
;
this
.
size
+
=
this
.
has
(
key
)
?
0
:
1
;
data
[
key
]
=
(
nativeCreate
&
&
value
=
=
=
undefined
)
?
HASH_UNDEFINED
:
value
;
return
this
;
}
module
.
exports
=
hashSet
;
}
93
:
function
(
module
exports
__webpack_require__
)
{
var
listCacheClear
=
__webpack_require__
(
94
)
listCacheDelete
=
__webpack_require__
(
95
)
listCacheGet
=
__webpack_require__
(
98
)
listCacheHas
=
__webpack_require__
(
99
)
listCacheSet
=
__webpack_require__
(
100
)
;
function
ListCache
(
entries
)
{
var
index
=
-
1
length
=
entries
=
=
null
?
0
:
entries
.
length
;
this
.
clear
(
)
;
while
(
+
+
index
<
length
)
{
var
entry
=
entries
[
index
]
;
this
.
set
(
entry
[
0
]
entry
[
1
]
)
;
}
}
ListCache
.
prototype
.
clear
=
listCacheClear
;
ListCache
.
prototype
[
'
delete
'
]
=
listCacheDelete
;
ListCache
.
prototype
.
get
=
listCacheGet
;
ListCache
.
prototype
.
has
=
listCacheHas
;
ListCache
.
prototype
.
set
=
listCacheSet
;
module
.
exports
=
ListCache
;
}
94
:
function
(
module
exports
)
{
function
listCacheClear
(
)
{
this
.
__data__
=
[
]
;
this
.
size
=
0
;
}
module
.
exports
=
listCacheClear
;
}
95
:
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
96
)
;
var
arrayProto
=
Array
.
prototype
;
var
splice
=
arrayProto
.
splice
;
function
listCacheDelete
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
return
false
;
}
var
lastIndex
=
data
.
length
-
1
;
if
(
index
=
=
lastIndex
)
{
data
.
pop
(
)
;
}
else
{
splice
.
call
(
data
index
1
)
;
}
-
-
this
.
size
;
return
true
;
}
module
.
exports
=
listCacheDelete
;
}
96
:
function
(
module
exports
__webpack_require__
)
{
var
eq
=
__webpack_require__
(
97
)
;
function
assocIndexOf
(
array
key
)
{
var
length
=
array
.
length
;
while
(
length
-
-
)
{
if
(
eq
(
array
[
length
]
[
0
]
key
)
)
{
return
length
;
}
}
return
-
1
;
}
module
.
exports
=
assocIndexOf
;
}
97
:
function
(
module
exports
)
{
function
eq
(
value
other
)
{
return
value
=
=
=
other
|
|
(
value
!
=
=
value
&
&
other
!
=
=
other
)
;
}
module
.
exports
=
eq
;
}
98
:
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
96
)
;
function
listCacheGet
(
key
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
return
index
<
0
?
undefined
:
data
[
index
]
[
1
]
;
}
module
.
exports
=
listCacheGet
;
}
99
:
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
96
)
;
function
listCacheHas
(
key
)
{
return
assocIndexOf
(
this
.
__data__
key
)
>
-
1
;
}
module
.
exports
=
listCacheHas
;
}
100
:
function
(
module
exports
__webpack_require__
)
{
var
assocIndexOf
=
__webpack_require__
(
96
)
;
function
listCacheSet
(
key
value
)
{
var
data
=
this
.
__data__
index
=
assocIndexOf
(
data
key
)
;
if
(
index
<
0
)
{
+
+
this
.
size
;
data
.
push
(
[
key
value
]
)
;
}
else
{
data
[
index
]
[
1
]
=
value
;
}
return
this
;
}
module
.
exports
=
listCacheSet
;
}
101
:
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
81
)
root
=
__webpack_require__
(
8
)
;
var
Map
=
getNative
(
root
'
Map
'
)
;
module
.
exports
=
Map
;
}
102
:
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
103
)
;
function
mapCacheDelete
(
key
)
{
var
result
=
getMapData
(
this
key
)
[
'
delete
'
]
(
key
)
;
this
.
size
-
=
result
?
1
:
0
;
return
result
;
}
module
.
exports
=
mapCacheDelete
;
}
103
:
function
(
module
exports
__webpack_require__
)
{
var
isKeyable
=
__webpack_require__
(
104
)
;
function
getMapData
(
map
key
)
{
var
data
=
map
.
__data__
;
return
isKeyable
(
key
)
?
data
[
typeof
key
=
=
'
string
'
?
'
string
'
:
'
hash
'
]
:
data
.
map
;
}
module
.
exports
=
getMapData
;
}
104
:
function
(
module
exports
)
{
function
isKeyable
(
value
)
{
var
type
=
typeof
value
;
return
(
type
=
=
'
string
'
|
|
type
=
=
'
number
'
|
|
type
=
=
'
symbol
'
|
|
type
=
=
'
boolean
'
)
?
(
value
!
=
=
'
__proto__
'
)
:
(
value
=
=
=
null
)
;
}
module
.
exports
=
isKeyable
;
}
105
:
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
103
)
;
function
mapCacheGet
(
key
)
{
return
getMapData
(
this
key
)
.
get
(
key
)
;
}
module
.
exports
=
mapCacheGet
;
}
106
:
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
103
)
;
function
mapCacheHas
(
key
)
{
return
getMapData
(
this
key
)
.
has
(
key
)
;
}
module
.
exports
=
mapCacheHas
;
}
107
:
function
(
module
exports
__webpack_require__
)
{
var
getMapData
=
__webpack_require__
(
103
)
;
function
mapCacheSet
(
key
value
)
{
var
data
=
getMapData
(
this
key
)
size
=
data
.
size
;
data
.
set
(
key
value
)
;
this
.
size
+
=
data
.
size
=
=
size
?
0
:
1
;
return
this
;
}
module
.
exports
=
mapCacheSet
;
}
108
:
function
(
module
exports
__webpack_require__
)
{
var
baseToString
=
__webpack_require__
(
109
)
;
function
toString
(
value
)
{
return
value
=
=
null
?
'
'
:
baseToString
(
value
)
;
}
module
.
exports
=
toString
;
}
109
:
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
7
)
arrayMap
=
__webpack_require__
(
110
)
isArray
=
__webpack_require__
(
70
)
isSymbol
=
__webpack_require__
(
72
)
;
var
INFINITY
=
1
/
0
;
var
symbolProto
=
Symbol
?
Symbol
.
prototype
:
undefined
symbolToString
=
symbolProto
?
symbolProto
.
toString
:
undefined
;
function
baseToString
(
value
)
{
if
(
typeof
value
=
=
'
string
'
)
{
return
value
;
}
if
(
isArray
(
value
)
)
{
return
arrayMap
(
value
baseToString
)
+
'
'
;
}
if
(
isSymbol
(
value
)
)
{
return
symbolToString
?
symbolToString
.
call
(
value
)
:
'
'
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
baseToString
;
}
110
:
function
(
module
exports
)
{
function
arrayMap
(
array
iteratee
)
{
var
index
=
-
1
length
=
array
=
=
null
?
0
:
array
.
length
result
=
Array
(
length
)
;
while
(
+
+
index
<
length
)
{
result
[
index
]
=
iteratee
(
array
[
index
]
index
array
)
;
}
return
result
;
}
module
.
exports
=
arrayMap
;
}
111
:
function
(
module
exports
__webpack_require__
)
{
var
isSymbol
=
__webpack_require__
(
72
)
;
var
INFINITY
=
1
/
0
;
function
toKey
(
value
)
{
if
(
typeof
value
=
=
'
string
'
|
|
isSymbol
(
value
)
)
{
return
value
;
}
var
result
=
(
value
+
'
'
)
;
return
(
result
=
=
'
0
'
&
&
(
1
/
value
)
=
=
-
INFINITY
)
?
'
-
0
'
:
result
;
}
module
.
exports
=
toKey
;
}
112
:
function
(
module
exports
__webpack_require__
)
{
var
baseSet
=
__webpack_require__
(
113
)
;
function
set
(
object
path
value
)
{
return
object
=
=
null
?
object
:
baseSet
(
object
path
value
)
;
}
module
.
exports
=
set
;
}
113
:
function
(
module
exports
__webpack_require__
)
{
var
assignValue
=
__webpack_require__
(
114
)
castPath
=
__webpack_require__
(
69
)
isIndex
=
__webpack_require__
(
117
)
isObject
=
__webpack_require__
(
84
)
toKey
=
__webpack_require__
(
111
)
;
function
baseSet
(
object
path
value
customizer
)
{
if
(
!
isObject
(
object
)
)
{
return
object
;
}
path
=
castPath
(
path
object
)
;
var
index
=
-
1
length
=
path
.
length
lastIndex
=
length
-
1
nested
=
object
;
while
(
nested
!
=
null
&
&
+
+
index
<
length
)
{
var
key
=
toKey
(
path
[
index
]
)
newValue
=
value
;
if
(
index
!
=
lastIndex
)
{
var
objValue
=
nested
[
key
]
;
newValue
=
customizer
?
customizer
(
objValue
key
nested
)
:
undefined
;
if
(
newValue
=
=
=
undefined
)
{
newValue
=
isObject
(
objValue
)
?
objValue
:
(
isIndex
(
path
[
index
+
1
]
)
?
[
]
:
{
}
)
;
}
}
assignValue
(
nested
key
newValue
)
;
nested
=
nested
[
key
]
;
}
return
object
;
}
module
.
exports
=
baseSet
;
}
114
:
function
(
module
exports
__webpack_require__
)
{
var
baseAssignValue
=
__webpack_require__
(
115
)
eq
=
__webpack_require__
(
97
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
assignValue
(
object
key
value
)
{
var
objValue
=
object
[
key
]
;
if
(
!
(
hasOwnProperty
.
call
(
object
key
)
&
&
eq
(
objValue
value
)
)
|
|
(
value
=
=
=
undefined
&
&
!
(
key
in
object
)
)
)
{
baseAssignValue
(
object
key
value
)
;
}
}
module
.
exports
=
assignValue
;
}
115
:
function
(
module
exports
__webpack_require__
)
{
var
defineProperty
=
__webpack_require__
(
116
)
;
function
baseAssignValue
(
object
key
value
)
{
if
(
key
=
=
'
__proto__
'
&
&
defineProperty
)
{
defineProperty
(
object
key
{
'
configurable
'
:
true
'
enumerable
'
:
true
'
value
'
:
value
'
writable
'
:
true
}
)
;
}
else
{
object
[
key
]
=
value
;
}
}
module
.
exports
=
baseAssignValue
;
}
116
:
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
81
)
;
var
defineProperty
=
(
function
(
)
{
try
{
var
func
=
getNative
(
Object
'
defineProperty
'
)
;
func
(
{
}
'
'
{
}
)
;
return
func
;
}
catch
(
e
)
{
}
}
(
)
)
;
module
.
exports
=
defineProperty
;
}
117
:
function
(
module
exports
)
{
var
MAX_SAFE_INTEGER
=
9007199254740991
;
var
reIsUint
=
/
^
(
?
:
0
|
[
1
-
9
]
\
d
*
)
/
;
function
isIndex
(
value
length
)
{
length
=
length
=
=
null
?
MAX_SAFE_INTEGER
:
length
;
return
!
!
length
&
&
(
typeof
value
=
=
'
number
'
|
|
reIsUint
.
test
(
value
)
)
&
&
(
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
length
)
;
}
module
.
exports
=
isIndex
;
}
118
:
function
(
module
exports
)
{
}
119
:
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
function
normalizeArray
(
parts
allowAboveRoot
)
{
var
up
=
0
;
for
(
var
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
last
=
parts
[
i
]
;
if
(
last
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
parts
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
parts
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
allowAboveRoot
)
{
for
(
;
up
-
-
;
up
)
{
parts
.
unshift
(
'
.
.
'
)
;
}
}
return
parts
;
}
var
splitPathRe
=
/
^
(
\
/
?
|
)
(
[
\
s
\
S
]
*
?
)
(
(
?
:
\
.
{
1
2
}
|
[
^
\
/
]
+
?
|
)
(
\
.
[
^
.
\
/
]
*
|
)
)
(
?
:
[
\
/
]
*
)
/
;
var
splitPath
=
function
(
filename
)
{
return
splitPathRe
.
exec
(
filename
)
.
slice
(
1
)
;
}
;
exports
.
resolve
=
function
(
)
{
var
resolvedPath
=
'
'
resolvedAbsolute
=
false
;
for
(
var
i
=
arguments
.
length
-
1
;
i
>
=
-
1
&
&
!
resolvedAbsolute
;
i
-
-
)
{
var
path
=
(
i
>
=
0
)
?
arguments
[
i
]
:
process
.
cwd
(
)
;
if
(
typeof
path
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
resolve
must
be
strings
'
)
;
}
else
if
(
!
path
)
{
continue
;
}
resolvedPath
=
path
+
'
/
'
+
resolvedPath
;
resolvedAbsolute
=
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
resolvedPath
=
normalizeArray
(
filter
(
resolvedPath
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
resolvedAbsolute
)
.
join
(
'
/
'
)
;
return
(
(
resolvedAbsolute
?
'
/
'
:
'
'
)
+
resolvedPath
)
|
|
'
.
'
;
}
;
exports
.
normalize
=
function
(
path
)
{
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
trailingSlash
=
substr
(
path
-
1
)
=
=
=
'
/
'
;
path
=
normalizeArray
(
filter
(
path
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
isAbsolute
)
.
join
(
'
/
'
)
;
if
(
!
path
&
&
!
isAbsolute
)
{
path
=
'
.
'
;
}
if
(
path
&
&
trailingSlash
)
{
path
+
=
'
/
'
;
}
return
(
isAbsolute
?
'
/
'
:
'
'
)
+
path
;
}
;
exports
.
isAbsolute
=
function
(
path
)
{
return
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
;
exports
.
join
=
function
(
)
{
var
paths
=
Array
.
prototype
.
slice
.
call
(
arguments
0
)
;
return
exports
.
normalize
(
filter
(
paths
function
(
p
index
)
{
if
(
typeof
p
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
join
must
be
strings
'
)
;
}
return
p
;
}
)
.
join
(
'
/
'
)
)
;
}
;
exports
.
relative
=
function
(
from
to
)
{
from
=
exports
.
resolve
(
from
)
.
substr
(
1
)
;
to
=
exports
.
resolve
(
to
)
.
substr
(
1
)
;
function
trim
(
arr
)
{
var
start
=
0
;
for
(
;
start
<
arr
.
length
;
start
+
+
)
{
if
(
arr
[
start
]
!
=
=
'
'
)
break
;
}
var
end
=
arr
.
length
-
1
;
for
(
;
end
>
=
0
;
end
-
-
)
{
if
(
arr
[
end
]
!
=
=
'
'
)
break
;
}
if
(
start
>
end
)
return
[
]
;
return
arr
.
slice
(
start
end
-
start
+
1
)
;
}
var
fromParts
=
trim
(
from
.
split
(
'
/
'
)
)
;
var
toParts
=
trim
(
to
.
split
(
'
/
'
)
)
;
var
length
=
Math
.
min
(
fromParts
.
length
toParts
.
length
)
;
var
samePartsLength
=
length
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
fromParts
[
i
]
!
=
=
toParts
[
i
]
)
{
samePartsLength
=
i
;
break
;
}
}
var
outputParts
=
[
]
;
for
(
var
i
=
samePartsLength
;
i
<
fromParts
.
length
;
i
+
+
)
{
outputParts
.
push
(
'
.
.
'
)
;
}
outputParts
=
outputParts
.
concat
(
toParts
.
slice
(
samePartsLength
)
)
;
return
outputParts
.
join
(
'
/
'
)
;
}
;
exports
.
sep
=
'
/
'
;
exports
.
delimiter
=
'
:
'
;
exports
.
dirname
=
function
(
path
)
{
var
result
=
splitPath
(
path
)
root
=
result
[
0
]
dir
=
result
[
1
]
;
if
(
!
root
&
&
!
dir
)
{
return
'
.
'
;
}
if
(
dir
)
{
dir
=
dir
.
substr
(
0
dir
.
length
-
1
)
;
}
return
root
+
dir
;
}
;
exports
.
basename
=
function
(
path
ext
)
{
var
f
=
splitPath
(
path
)
[
2
]
;
if
(
ext
&
&
f
.
substr
(
-
1
*
ext
.
length
)
=
=
=
ext
)
{
f
=
f
.
substr
(
0
f
.
length
-
ext
.
length
)
;
}
return
f
;
}
;
exports
.
extname
=
function
(
path
)
{
return
splitPath
(
path
)
[
3
]
;
}
;
function
filter
(
xs
f
)
{
if
(
xs
.
filter
)
return
xs
.
filter
(
f
)
;
var
res
=
[
]
;
for
(
var
i
=
0
;
i
<
xs
.
length
;
i
+
+
)
{
if
(
f
(
xs
[
i
]
i
xs
)
)
res
.
push
(
xs
[
i
]
)
;
}
return
res
;
}
var
substr
=
'
ab
'
.
substr
(
-
1
)
=
=
=
'
b
'
?
function
(
str
start
len
)
{
return
str
.
substr
(
start
len
)
}
:
function
(
str
start
len
)
{
if
(
start
<
0
)
start
=
str
.
length
+
start
;
return
str
.
substr
(
start
len
)
;
}
;
}
.
call
(
exports
__webpack_require__
(
120
)
)
)
}
120
:
function
(
module
exports
)
{
var
process
=
module
.
exports
=
{
}
;
var
cachedSetTimeout
;
var
cachedClearTimeout
;
function
defaultSetTimout
(
)
{
throw
new
Error
(
'
setTimeout
has
not
been
defined
'
)
;
}
function
defaultClearTimeout
(
)
{
throw
new
Error
(
'
clearTimeout
has
not
been
defined
'
)
;
}
(
function
(
)
{
try
{
if
(
typeof
setTimeout
=
=
=
'
function
'
)
{
cachedSetTimeout
=
setTimeout
;
}
else
{
cachedSetTimeout
=
defaultSetTimout
;
}
}
catch
(
e
)
{
cachedSetTimeout
=
defaultSetTimout
;
}
try
{
if
(
typeof
clearTimeout
=
=
=
'
function
'
)
{
cachedClearTimeout
=
clearTimeout
;
}
else
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
catch
(
e
)
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
(
)
)
function
runTimeout
(
fun
)
{
if
(
cachedSetTimeout
=
=
=
setTimeout
)
{
return
setTimeout
(
fun
0
)
;
}
if
(
(
cachedSetTimeout
=
=
=
defaultSetTimout
|
|
!
cachedSetTimeout
)
&
&
setTimeout
)
{
cachedSetTimeout
=
setTimeout
;
return
setTimeout
(
fun
0
)
;
}
try
{
return
cachedSetTimeout
(
fun
0
)
;
}
catch
(
e
)
{
try
{
return
cachedSetTimeout
.
call
(
null
fun
0
)
;
}
catch
(
e
)
{
return
cachedSetTimeout
.
call
(
this
fun
0
)
;
}
}
}
function
runClearTimeout
(
marker
)
{
if
(
cachedClearTimeout
=
=
=
clearTimeout
)
{
return
clearTimeout
(
marker
)
;
}
if
(
(
cachedClearTimeout
=
=
=
defaultClearTimeout
|
|
!
cachedClearTimeout
)
&
&
clearTimeout
)
{
cachedClearTimeout
=
clearTimeout
;
return
clearTimeout
(
marker
)
;
}
try
{
return
cachedClearTimeout
(
marker
)
;
}
catch
(
e
)
{
try
{
return
cachedClearTimeout
.
call
(
null
marker
)
;
}
catch
(
e
)
{
return
cachedClearTimeout
.
call
(
this
marker
)
;
}
}
}
var
queue
=
[
]
;
var
draining
=
false
;
var
currentQueue
;
var
queueIndex
=
-
1
;
function
cleanUpNextTick
(
)
{
if
(
!
draining
|
|
!
currentQueue
)
{
return
;
}
draining
=
false
;
if
(
currentQueue
.
length
)
{
queue
=
currentQueue
.
concat
(
queue
)
;
}
else
{
queueIndex
=
-
1
;
}
if
(
queue
.
length
)
{
drainQueue
(
)
;
}
}
function
drainQueue
(
)
{
if
(
draining
)
{
return
;
}
var
timeout
=
runTimeout
(
cleanUpNextTick
)
;
draining
=
true
;
var
len
=
queue
.
length
;
while
(
len
)
{
currentQueue
=
queue
;
queue
=
[
]
;
while
(
+
+
queueIndex
<
len
)
{
if
(
currentQueue
)
{
currentQueue
[
queueIndex
]
.
run
(
)
;
}
}
queueIndex
=
-
1
;
len
=
queue
.
length
;
}
currentQueue
=
null
;
draining
=
false
;
runClearTimeout
(
timeout
)
;
}
process
.
nextTick
=
function
(
fun
)
{
var
args
=
new
Array
(
arguments
.
length
-
1
)
;
if
(
arguments
.
length
>
1
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
}
queue
.
push
(
new
Item
(
fun
args
)
)
;
if
(
queue
.
length
=
=
=
1
&
&
!
draining
)
{
runTimeout
(
drainQueue
)
;
}
}
;
function
Item
(
fun
array
)
{
this
.
fun
=
fun
;
this
.
array
=
array
;
}
Item
.
prototype
.
run
=
function
(
)
{
this
.
fun
.
apply
(
null
this
.
array
)
;
}
;
process
.
title
=
'
browser
'
;
process
.
browser
=
true
;
process
.
env
=
{
}
;
process
.
argv
=
[
]
;
process
.
version
=
'
'
;
process
.
versions
=
{
}
;
function
noop
(
)
{
}
process
.
on
=
noop
;
process
.
addListener
=
noop
;
process
.
once
=
noop
;
process
.
off
=
noop
;
process
.
removeListener
=
noop
;
process
.
removeAllListeners
=
noop
;
process
.
emit
=
noop
;
process
.
prependListener
=
noop
;
process
.
prependOnceListener
=
noop
;
process
.
listeners
=
function
(
name
)
{
return
[
]
}
process
.
binding
=
function
(
name
)
{
throw
new
Error
(
'
process
.
binding
is
not
supported
'
)
;
}
;
process
.
cwd
=
function
(
)
{
return
'
/
'
}
;
process
.
chdir
=
function
(
dir
)
{
throw
new
Error
(
'
process
.
chdir
is
not
supported
'
)
;
}
;
process
.
umask
=
function
(
)
{
return
0
;
}
;
}
121
:
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_121__
;
}
198
:
function
(
module
exports
__webpack_require__
)
{
var
DataView
=
__webpack_require__
(
199
)
Map
=
__webpack_require__
(
101
)
Promise
=
__webpack_require__
(
200
)
Set
=
__webpack_require__
(
201
)
WeakMap
=
__webpack_require__
(
202
)
baseGetTag
=
__webpack_require__
(
6
)
toSource
=
__webpack_require__
(
87
)
;
var
mapTag
=
'
[
object
Map
]
'
objectTag
=
'
[
object
Object
]
'
promiseTag
=
'
[
object
Promise
]
'
setTag
=
'
[
object
Set
]
'
weakMapTag
=
'
[
object
WeakMap
]
'
;
var
dataViewTag
=
'
[
object
DataView
]
'
;
var
dataViewCtorString
=
toSource
(
DataView
)
mapCtorString
=
toSource
(
Map
)
promiseCtorString
=
toSource
(
Promise
)
setCtorString
=
toSource
(
Set
)
weakMapCtorString
=
toSource
(
WeakMap
)
;
var
getTag
=
baseGetTag
;
if
(
(
DataView
&
&
getTag
(
new
DataView
(
new
ArrayBuffer
(
1
)
)
)
!
=
dataViewTag
)
|
|
(
Map
&
&
getTag
(
new
Map
)
!
=
mapTag
)
|
|
(
Promise
&
&
getTag
(
Promise
.
resolve
(
)
)
!
=
promiseTag
)
|
|
(
Set
&
&
getTag
(
new
Set
)
!
=
setTag
)
|
|
(
WeakMap
&
&
getTag
(
new
WeakMap
)
!
=
weakMapTag
)
)
{
getTag
=
function
(
value
)
{
var
result
=
baseGetTag
(
value
)
Ctor
=
result
=
=
objectTag
?
value
.
constructor
:
undefined
ctorString
=
Ctor
?
toSource
(
Ctor
)
:
'
'
;
if
(
ctorString
)
{
switch
(
ctorString
)
{
case
dataViewCtorString
:
return
dataViewTag
;
case
mapCtorString
:
return
mapTag
;
case
promiseCtorString
:
return
promiseTag
;
case
setCtorString
:
return
setTag
;
case
weakMapCtorString
:
return
weakMapTag
;
}
}
return
result
;
}
;
}
module
.
exports
=
getTag
;
}
199
:
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
81
)
root
=
__webpack_require__
(
8
)
;
var
DataView
=
getNative
(
root
'
DataView
'
)
;
module
.
exports
=
DataView
;
}
200
:
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
81
)
root
=
__webpack_require__
(
8
)
;
var
Promise
=
getNative
(
root
'
Promise
'
)
;
module
.
exports
=
Promise
;
}
201
:
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
81
)
root
=
__webpack_require__
(
8
)
;
var
Set
=
getNative
(
root
'
Set
'
)
;
module
.
exports
=
Set
;
}
202
:
function
(
module
exports
__webpack_require__
)
{
var
getNative
=
__webpack_require__
(
81
)
root
=
__webpack_require__
(
8
)
;
var
WeakMap
=
getNative
(
root
'
WeakMap
'
)
;
module
.
exports
=
WeakMap
;
}
203
:
function
(
module
exports
)
{
function
mapToArray
(
map
)
{
var
index
=
-
1
result
=
Array
(
map
.
size
)
;
map
.
forEach
(
function
(
value
key
)
{
result
[
+
+
index
]
=
[
key
value
]
;
}
)
;
return
result
;
}
module
.
exports
=
mapToArray
;
}
205
:
function
(
module
exports
__webpack_require__
)
{
var
arrayLikeKeys
=
__webpack_require__
(
206
)
baseKeys
=
__webpack_require__
(
217
)
isArrayLike
=
__webpack_require__
(
220
)
;
function
keys
(
object
)
{
return
isArrayLike
(
object
)
?
arrayLikeKeys
(
object
)
:
baseKeys
(
object
)
;
}
module
.
exports
=
keys
;
}
206
:
function
(
module
exports
__webpack_require__
)
{
var
baseTimes
=
__webpack_require__
(
207
)
isArguments
=
__webpack_require__
(
208
)
isArray
=
__webpack_require__
(
70
)
isBuffer
=
__webpack_require__
(
210
)
isIndex
=
__webpack_require__
(
117
)
isTypedArray
=
__webpack_require__
(
212
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
arrayLikeKeys
(
value
inherited
)
{
var
isArr
=
isArray
(
value
)
isArg
=
!
isArr
&
&
isArguments
(
value
)
isBuff
=
!
isArr
&
&
!
isArg
&
&
isBuffer
(
value
)
isType
=
!
isArr
&
&
!
isArg
&
&
!
isBuff
&
&
isTypedArray
(
value
)
skipIndexes
=
isArr
|
|
isArg
|
|
isBuff
|
|
isType
result
=
skipIndexes
?
baseTimes
(
value
.
length
String
)
:
[
]
length
=
result
.
length
;
for
(
var
key
in
value
)
{
if
(
(
inherited
|
|
hasOwnProperty
.
call
(
value
key
)
)
&
&
!
(
skipIndexes
&
&
(
key
=
=
'
length
'
|
|
(
isBuff
&
&
(
key
=
=
'
offset
'
|
|
key
=
=
'
parent
'
)
)
|
|
(
isType
&
&
(
key
=
=
'
buffer
'
|
|
key
=
=
'
byteLength
'
|
|
key
=
=
'
byteOffset
'
)
)
|
|
isIndex
(
key
length
)
)
)
)
{
result
.
push
(
key
)
;
}
}
return
result
;
}
module
.
exports
=
arrayLikeKeys
;
}
207
:
function
(
module
exports
)
{
function
baseTimes
(
n
iteratee
)
{
var
index
=
-
1
result
=
Array
(
n
)
;
while
(
+
+
index
<
n
)
{
result
[
index
]
=
iteratee
(
index
)
;
}
return
result
;
}
module
.
exports
=
baseTimes
;
}
208
:
function
(
module
exports
__webpack_require__
)
{
var
baseIsArguments
=
__webpack_require__
(
209
)
isObjectLike
=
__webpack_require__
(
14
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
propertyIsEnumerable
=
objectProto
.
propertyIsEnumerable
;
var
isArguments
=
baseIsArguments
(
function
(
)
{
return
arguments
;
}
(
)
)
?
baseIsArguments
:
function
(
value
)
{
return
isObjectLike
(
value
)
&
&
hasOwnProperty
.
call
(
value
'
callee
'
)
&
&
!
propertyIsEnumerable
.
call
(
value
'
callee
'
)
;
}
;
module
.
exports
=
isArguments
;
}
209
:
function
(
module
exports
__webpack_require__
)
{
var
baseGetTag
=
__webpack_require__
(
6
)
isObjectLike
=
__webpack_require__
(
14
)
;
var
argsTag
=
'
[
object
Arguments
]
'
;
function
baseIsArguments
(
value
)
{
return
isObjectLike
(
value
)
&
&
baseGetTag
(
value
)
=
=
argsTag
;
}
module
.
exports
=
baseIsArguments
;
}
210
:
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
)
{
var
root
=
__webpack_require__
(
8
)
stubFalse
=
__webpack_require__
(
211
)
;
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
&
&
!
exports
.
nodeType
&
&
exports
;
var
freeModule
=
freeExports
&
&
typeof
module
=
=
'
object
'
&
&
module
&
&
!
module
.
nodeType
&
&
module
;
var
moduleExports
=
freeModule
&
&
freeModule
.
exports
=
=
=
freeExports
;
var
Buffer
=
moduleExports
?
root
.
Buffer
:
undefined
;
var
nativeIsBuffer
=
Buffer
?
Buffer
.
isBuffer
:
undefined
;
var
isBuffer
=
nativeIsBuffer
|
|
stubFalse
;
module
.
exports
=
isBuffer
;
}
.
call
(
exports
__webpack_require__
(
51
)
(
module
)
)
)
}
211
:
function
(
module
exports
)
{
function
stubFalse
(
)
{
return
false
;
}
module
.
exports
=
stubFalse
;
}
212
:
function
(
module
exports
__webpack_require__
)
{
var
baseIsTypedArray
=
__webpack_require__
(
213
)
baseUnary
=
__webpack_require__
(
215
)
nodeUtil
=
__webpack_require__
(
216
)
;
var
nodeIsTypedArray
=
nodeUtil
&
&
nodeUtil
.
isTypedArray
;
var
isTypedArray
=
nodeIsTypedArray
?
baseUnary
(
nodeIsTypedArray
)
:
baseIsTypedArray
;
module
.
exports
=
isTypedArray
;
}
213
:
function
(
module
exports
__webpack_require__
)
{
var
baseGetTag
=
__webpack_require__
(
6
)
isLength
=
__webpack_require__
(
214
)
isObjectLike
=
__webpack_require__
(
14
)
;
var
argsTag
=
'
[
object
Arguments
]
'
arrayTag
=
'
[
object
Array
]
'
boolTag
=
'
[
object
Boolean
]
'
dateTag
=
'
[
object
Date
]
'
errorTag
=
'
[
object
Error
]
'
funcTag
=
'
[
object
Function
]
'
mapTag
=
'
[
object
Map
]
'
numberTag
=
'
[
object
Number
]
'
objectTag
=
'
[
object
Object
]
'
regexpTag
=
'
[
object
RegExp
]
'
setTag
=
'
[
object
Set
]
'
stringTag
=
'
[
object
String
]
'
weakMapTag
=
'
[
object
WeakMap
]
'
;
var
arrayBufferTag
=
'
[
object
ArrayBuffer
]
'
dataViewTag
=
'
[
object
DataView
]
'
float32Tag
=
'
[
object
Float32Array
]
'
float64Tag
=
'
[
object
Float64Array
]
'
int8Tag
=
'
[
object
Int8Array
]
'
int16Tag
=
'
[
object
Int16Array
]
'
int32Tag
=
'
[
object
Int32Array
]
'
uint8Tag
=
'
[
object
Uint8Array
]
'
uint8ClampedTag
=
'
[
object
Uint8ClampedArray
]
'
uint16Tag
=
'
[
object
Uint16Array
]
'
uint32Tag
=
'
[
object
Uint32Array
]
'
;
var
typedArrayTags
=
{
}
;
typedArrayTags
[
float32Tag
]
=
typedArrayTags
[
float64Tag
]
=
typedArrayTags
[
int8Tag
]
=
typedArrayTags
[
int16Tag
]
=
typedArrayTags
[
int32Tag
]
=
typedArrayTags
[
uint8Tag
]
=
typedArrayTags
[
uint8ClampedTag
]
=
typedArrayTags
[
uint16Tag
]
=
typedArrayTags
[
uint32Tag
]
=
true
;
typedArrayTags
[
argsTag
]
=
typedArrayTags
[
arrayTag
]
=
typedArrayTags
[
arrayBufferTag
]
=
typedArrayTags
[
boolTag
]
=
typedArrayTags
[
dataViewTag
]
=
typedArrayTags
[
dateTag
]
=
typedArrayTags
[
errorTag
]
=
typedArrayTags
[
funcTag
]
=
typedArrayTags
[
mapTag
]
=
typedArrayTags
[
numberTag
]
=
typedArrayTags
[
objectTag
]
=
typedArrayTags
[
regexpTag
]
=
typedArrayTags
[
setTag
]
=
typedArrayTags
[
stringTag
]
=
typedArrayTags
[
weakMapTag
]
=
false
;
function
baseIsTypedArray
(
value
)
{
return
isObjectLike
(
value
)
&
&
isLength
(
value
.
length
)
&
&
!
!
typedArrayTags
[
baseGetTag
(
value
)
]
;
}
module
.
exports
=
baseIsTypedArray
;
}
214
:
function
(
module
exports
)
{
var
MAX_SAFE_INTEGER
=
9007199254740991
;
function
isLength
(
value
)
{
return
typeof
value
=
=
'
number
'
&
&
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
=
MAX_SAFE_INTEGER
;
}
module
.
exports
=
isLength
;
}
215
:
function
(
module
exports
)
{
function
baseUnary
(
func
)
{
return
function
(
value
)
{
return
func
(
value
)
;
}
;
}
module
.
exports
=
baseUnary
;
}
216
:
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
)
{
var
freeGlobal
=
__webpack_require__
(
9
)
;
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
&
&
!
exports
.
nodeType
&
&
exports
;
var
freeModule
=
freeExports
&
&
typeof
module
=
=
'
object
'
&
&
module
&
&
!
module
.
nodeType
&
&
module
;
var
moduleExports
=
freeModule
&
&
freeModule
.
exports
=
=
=
freeExports
;
var
freeProcess
=
moduleExports
&
&
freeGlobal
.
process
;
var
nodeUtil
=
(
function
(
)
{
try
{
return
freeProcess
&
&
freeProcess
.
binding
&
&
freeProcess
.
binding
(
'
util
'
)
;
}
catch
(
e
)
{
}
}
(
)
)
;
module
.
exports
=
nodeUtil
;
}
.
call
(
exports
__webpack_require__
(
51
)
(
module
)
)
)
}
217
:
function
(
module
exports
__webpack_require__
)
{
var
isPrototype
=
__webpack_require__
(
218
)
nativeKeys
=
__webpack_require__
(
219
)
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
baseKeys
(
object
)
{
if
(
!
isPrototype
(
object
)
)
{
return
nativeKeys
(
object
)
;
}
var
result
=
[
]
;
for
(
var
key
in
Object
(
object
)
)
{
if
(
hasOwnProperty
.
call
(
object
key
)
&
&
key
!
=
'
constructor
'
)
{
result
.
push
(
key
)
;
}
}
return
result
;
}
module
.
exports
=
baseKeys
;
}
218
:
function
(
module
exports
)
{
var
objectProto
=
Object
.
prototype
;
function
isPrototype
(
value
)
{
var
Ctor
=
value
&
&
value
.
constructor
proto
=
(
typeof
Ctor
=
=
'
function
'
&
&
Ctor
.
prototype
)
|
|
objectProto
;
return
value
=
=
=
proto
;
}
module
.
exports
=
isPrototype
;
}
219
:
function
(
module
exports
__webpack_require__
)
{
var
overArg
=
__webpack_require__
(
13
)
;
var
nativeKeys
=
overArg
(
Object
.
keys
Object
)
;
module
.
exports
=
nativeKeys
;
}
220
:
function
(
module
exports
__webpack_require__
)
{
var
isFunction
=
__webpack_require__
(
83
)
isLength
=
__webpack_require__
(
214
)
;
function
isArrayLike
(
value
)
{
return
value
!
=
null
&
&
isLength
(
value
.
length
)
&
&
!
isFunction
(
value
)
;
}
module
.
exports
=
isArrayLike
;
}
226
:
function
(
module
exports
__webpack_require__
)
{
const
{
isDevelopment
}
=
__webpack_require__
(
828
)
;
const
{
Services
PrefsHelper
}
=
__webpack_require__
(
830
)
;
const
prefsSchemaVersion
=
"
1
.
0
.
1
"
;
const
pref
=
Services
.
pref
;
if
(
isDevelopment
(
)
)
{
pref
(
"
devtools
.
debugger
.
client
-
source
-
maps
-
enabled
"
true
)
;
pref
(
"
devtools
.
debugger
.
pause
-
on
-
exceptions
"
false
)
;
pref
(
"
devtools
.
debugger
.
ignore
-
caught
-
exceptions
"
false
)
;
pref
(
"
devtools
.
debugger
.
call
-
stack
-
visible
"
false
)
;
pref
(
"
devtools
.
debugger
.
scopes
-
visible
"
false
)
;
pref
(
"
devtools
.
debugger
.
start
-
panel
-
collapsed
"
false
)
;
pref
(
"
devtools
.
debugger
.
end
-
panel
-
collapsed
"
false
)
;
pref
(
"
devtools
.
debugger
.
tabs
"
"
[
]
"
)
;
pref
(
"
devtools
.
debugger
.
ui
.
framework
-
grouping
-
on
"
true
)
;
pref
(
"
devtools
.
debugger
.
pending
-
selected
-
location
"
"
{
}
"
)
;
pref
(
"
devtools
.
debugger
.
pending
-
breakpoints
"
"
{
}
"
)
;
pref
(
"
devtools
.
debugger
.
expressions
"
"
[
]
"
)
;
pref
(
"
devtools
.
debugger
.
file
-
search
-
case
-
sensitive
"
false
)
;
pref
(
"
devtools
.
debugger
.
file
-
search
-
whole
-
word
"
false
)
;
pref
(
"
devtools
.
debugger
.
file
-
search
-
regex
-
match
"
false
)
;
pref
(
"
devtools
.
debugger
.
prefs
-
schema
-
version
"
"
1
.
0
.
0
"
)
;
}
const
prefs
=
new
PrefsHelper
(
"
devtools
"
{
clientSourceMapsEnabled
:
[
"
Bool
"
"
debugger
.
client
-
source
-
maps
-
enabled
"
]
pauseOnExceptions
:
[
"
Bool
"
"
debugger
.
pause
-
on
-
exceptions
"
]
ignoreCaughtExceptions
:
[
"
Bool
"
"
debugger
.
ignore
-
caught
-
exceptions
"
]
callStackVisible
:
[
"
Bool
"
"
debugger
.
call
-
stack
-
visible
"
]
scopesVisible
:
[
"
Bool
"
"
debugger
.
scopes
-
visible
"
]
startPanelCollapsed
:
[
"
Bool
"
"
debugger
.
start
-
panel
-
collapsed
"
]
endPanelCollapsed
:
[
"
Bool
"
"
debugger
.
end
-
panel
-
collapsed
"
]
frameworkGroupingOn
:
[
"
Bool
"
"
debugger
.
ui
.
framework
-
grouping
-
on
"
]
tabs
:
[
"
Json
"
"
debugger
.
tabs
"
]
pendingSelectedLocation
:
[
"
Json
"
"
debugger
.
pending
-
selected
-
location
"
]
pendingBreakpoints
:
[
"
Json
"
"
debugger
.
pending
-
breakpoints
"
]
expressions
:
[
"
Json
"
"
debugger
.
expressions
"
]
fileSearchCaseSensitive
:
[
"
Bool
"
"
debugger
.
file
-
search
-
case
-
sensitive
"
]
fileSearchWholeWord
:
[
"
Bool
"
"
debugger
.
file
-
search
-
whole
-
word
"
]
fileSearchRegexMatch
:
[
"
Bool
"
"
debugger
.
file
-
search
-
regex
-
match
"
]
debuggerPrefsSchemaVersion
:
[
"
Char
"
"
debugger
.
prefs
-
schema
-
version
"
]
}
)
;
if
(
prefs
.
debuggerPrefsSchemaVersion
!
=
=
prefsSchemaVersion
)
{
prefs
.
pendingBreakpoints
=
{
}
;
prefs
.
debuggerPrefsSchemaVersion
=
prefsSchemaVersion
;
}
module
.
exports
=
{
prefs
}
;
}
264
:
function
(
module
exports
__webpack_require__
)
{
var
baseMatches
=
__webpack_require__
(
265
)
baseMatchesProperty
=
__webpack_require__
(
294
)
identity
=
__webpack_require__
(
298
)
isArray
=
__webpack_require__
(
70
)
property
=
__webpack_require__
(
299
)
;
function
baseIteratee
(
value
)
{
if
(
typeof
value
=
=
'
function
'
)
{
return
value
;
}
if
(
value
=
=
null
)
{
return
identity
;
}
if
(
typeof
value
=
=
'
object
'
)
{
return
isArray
(
value
)
?
baseMatchesProperty
(
value
[
0
]
value
[
1
]
)
:
baseMatches
(
value
)
;
}
return
property
(
value
)
;
}
module
.
exports
=
baseIteratee
;
}
265
:
function
(
module
exports
__webpack_require__
)
{
var
baseIsMatch
=
__webpack_require__
(
266
)
getMatchData
=
__webpack_require__
(
291
)
matchesStrictComparable
=
__webpack_require__
(
293
)
;
function
baseMatches
(
source
)
{
var
matchData
=
getMatchData
(
source
)
;
if
(
matchData
.
length
=
=
1
&
&
matchData
[
0
]
[
2
]
)
{
return
matchesStrictComparable
(
matchData
[
0
]
[
0
]
matchData
[
0
]
[
1
]
)
;
}
return
function
(
object
)
{
return
object
=
=
=
source
|
|
baseIsMatch
(
object
source
matchData
)
;
}
;
}
module
.
exports
=
baseMatches
;
}
266
:
function
(
module
exports
__webpack_require__
)
{
var
Stack
=
__webpack_require__
(
267
)
baseIsEqual
=
__webpack_require__
(
273
)
;
var
COMPARE_PARTIAL_FLAG
=
1
COMPARE_UNORDERED_FLAG
=
2
;
function
baseIsMatch
(
object
source
matchData
customizer
)
{
var
index
=
matchData
.
length
length
=
index
noCustomizer
=
!
customizer
;
if
(
object
=
=
null
)
{
return
!
length
;
}
object
=
Object
(
object
)
;
while
(
index
-
-
)
{
var
data
=
matchData
[
index
]
;
if
(
(
noCustomizer
&
&
data
[
2
]
)
?
data
[
1
]
!
=
=
object
[
data
[
0
]
]
:
!
(
data
[
0
]
in
object
)
)
{
return
false
;
}
}
while
(
+
+
index
<
length
)
{
data
=
matchData
[
index
]
;
var
key
=
data
[
0
]
objValue
=
object
[
key
]
srcValue
=
data
[
1
]
;
if
(
noCustomizer
&
&
data
[
2
]
)
{
if
(
objValue
=
=
=
undefined
&
&
!
(
key
in
object
)
)
{
return
false
;
}
}
else
{
var
stack
=
new
Stack
;
if
(
customizer
)
{
var
result
=
customizer
(
objValue
srcValue
key
object
source
stack
)
;
}
if
(
!
(
result
=
=
=
undefined
?
baseIsEqual
(
srcValue
objValue
COMPARE_PARTIAL_FLAG
|
COMPARE_UNORDERED_FLAG
customizer
stack
)
:
result
)
)
{
return
false
;
}
}
}
return
true
;
}
module
.
exports
=
baseIsMatch
;
}
267
:
function
(
module
exports
__webpack_require__
)
{
var
ListCache
=
__webpack_require__
(
93
)
stackClear
=
__webpack_require__
(
268
)
stackDelete
=
__webpack_require__
(
269
)
stackGet
=
__webpack_require__
(
270
)
stackHas
=
__webpack_require__
(
271
)
stackSet
=
__webpack_require__
(
272
)
;
function
Stack
(
entries
)
{
var
data
=
this
.
__data__
=
new
ListCache
(
entries
)
;
this
.
size
=
data
.
size
;
}
Stack
.
prototype
.
clear
=
stackClear
;
Stack
.
prototype
[
'
delete
'
]
=
stackDelete
;
Stack
.
prototype
.
get
=
stackGet
;
Stack
.
prototype
.
has
=
stackHas
;
Stack
.
prototype
.
set
=
stackSet
;
module
.
exports
=
Stack
;
}
268
:
function
(
module
exports
__webpack_require__
)
{
var
ListCache
=
__webpack_require__
(
93
)
;
function
stackClear
(
)
{
this
.
__data__
=
new
ListCache
;
this
.
size
=
0
;
}
module
.
exports
=
stackClear
;
}
269
:
function
(
module
exports
)
{
function
stackDelete
(
key
)
{
var
data
=
this
.
__data__
result
=
data
[
'
delete
'
]
(
key
)
;
this
.
size
=
data
.
size
;
return
result
;
}
module
.
exports
=
stackDelete
;
}
270
:
function
(
module
exports
)
{
function
stackGet
(
key
)
{
return
this
.
__data__
.
get
(
key
)
;
}
module
.
exports
=
stackGet
;
}
271
:
function
(
module
exports
)
{
function
stackHas
(
key
)
{
return
this
.
__data__
.
has
(
key
)
;
}
module
.
exports
=
stackHas
;
}
272
:
function
(
module
exports
__webpack_require__
)
{
var
ListCache
=
__webpack_require__
(
93
)
Map
=
__webpack_require__
(
101
)
MapCache
=
__webpack_require__
(
76
)
;
var
LARGE_ARRAY_SIZE
=
200
;
function
stackSet
(
key
value
)
{
var
data
=
this
.
__data__
;
if
(
data
instanceof
ListCache
)
{
var
pairs
=
data
.
__data__
;
if
(
!
Map
|
|
(
pairs
.
length
<
LARGE_ARRAY_SIZE
-
1
)
)
{
pairs
.
push
(
[
key
value
]
)
;
this
.
size
=
+
+
data
.
size
;
return
this
;
}
data
=
this
.
__data__
=
new
MapCache
(
pairs
)
;
}
data
.
set
(
key
value
)
;
this
.
size
=
data
.
size
;
return
this
;
}
module
.
exports
=
stackSet
;
}
273
:
function
(
module
exports
__webpack_require__
)
{
var
baseIsEqualDeep
=
__webpack_require__
(
274
)
isObjectLike
=
__webpack_require__
(
14
)
;
function
baseIsEqual
(
value
other
bitmask
customizer
stack
)
{
if
(
value
=
=
=
other
)
{
return
true
;
}
if
(
value
=
=
null
|
|
other
=
=
null
|
|
(
!
isObjectLike
(
value
)
&
&
!
isObjectLike
(
other
)
)
)
{
return
value
!
=
=
value
&
&
other
!
=
=
other
;
}
return
baseIsEqualDeep
(
value
other
bitmask
customizer
baseIsEqual
stack
)
;
}
module
.
exports
=
baseIsEqual
;
}
274
:
function
(
module
exports
__webpack_require__
)
{
var
Stack
=
__webpack_require__
(
267
)
equalArrays
=
__webpack_require__
(
275
)
equalByTag
=
__webpack_require__
(
281
)
equalObjects
=
__webpack_require__
(
284
)
getTag
=
__webpack_require__
(
198
)
isArray
=
__webpack_require__
(
70
)
isBuffer
=
__webpack_require__
(
210
)
isTypedArray
=
__webpack_require__
(
212
)
;
var
COMPARE_PARTIAL_FLAG
=
1
;
var
argsTag
=
'
[
object
Arguments
]
'
arrayTag
=
'
[
object
Array
]
'
objectTag
=
'
[
object
Object
]
'
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
baseIsEqualDeep
(
object
other
bitmask
customizer
equalFunc
stack
)
{
var
objIsArr
=
isArray
(
object
)
othIsArr
=
isArray
(
other
)
objTag
=
objIsArr
?
arrayTag
:
getTag
(
object
)
othTag
=
othIsArr
?
arrayTag
:
getTag
(
other
)
;
objTag
=
objTag
=
=
argsTag
?
objectTag
:
objTag
;
othTag
=
othTag
=
=
argsTag
?
objectTag
:
othTag
;
var
objIsObj
=
objTag
=
=
objectTag
othIsObj
=
othTag
=
=
objectTag
isSameTag
=
objTag
=
=
othTag
;
if
(
isSameTag
&
&
isBuffer
(
object
)
)
{
if
(
!
isBuffer
(
other
)
)
{
return
false
;
}
objIsArr
=
true
;
objIsObj
=
false
;
}
if
(
isSameTag
&
&
!
objIsObj
)
{
stack
|
|
(
stack
=
new
Stack
)
;
return
(
objIsArr
|
|
isTypedArray
(
object
)
)
?
equalArrays
(
object
other
bitmask
customizer
equalFunc
stack
)
:
equalByTag
(
object
other
objTag
bitmask
customizer
equalFunc
stack
)
;
}
if
(
!
(
bitmask
&
COMPARE_PARTIAL_FLAG
)
)
{
var
objIsWrapped
=
objIsObj
&
&
hasOwnProperty
.
call
(
object
'
__wrapped__
'
)
othIsWrapped
=
othIsObj
&
&
hasOwnProperty
.
call
(
other
'
__wrapped__
'
)
;
if
(
objIsWrapped
|
|
othIsWrapped
)
{
var
objUnwrapped
=
objIsWrapped
?
object
.
value
(
)
:
object
othUnwrapped
=
othIsWrapped
?
other
.
value
(
)
:
other
;
stack
|
|
(
stack
=
new
Stack
)
;
return
equalFunc
(
objUnwrapped
othUnwrapped
bitmask
customizer
stack
)
;
}
}
if
(
!
isSameTag
)
{
return
false
;
}
stack
|
|
(
stack
=
new
Stack
)
;
return
equalObjects
(
object
other
bitmask
customizer
equalFunc
stack
)
;
}
module
.
exports
=
baseIsEqualDeep
;
}
275
:
function
(
module
exports
__webpack_require__
)
{
var
SetCache
=
__webpack_require__
(
276
)
arraySome
=
__webpack_require__
(
279
)
cacheHas
=
__webpack_require__
(
280
)
;
var
COMPARE_PARTIAL_FLAG
=
1
COMPARE_UNORDERED_FLAG
=
2
;
function
equalArrays
(
array
other
bitmask
customizer
equalFunc
stack
)
{
var
isPartial
=
bitmask
&
COMPARE_PARTIAL_FLAG
arrLength
=
array
.
length
othLength
=
other
.
length
;
if
(
arrLength
!
=
othLength
&
&
!
(
isPartial
&
&
othLength
>
arrLength
)
)
{
return
false
;
}
var
stacked
=
stack
.
get
(
array
)
;
if
(
stacked
&
&
stack
.
get
(
other
)
)
{
return
stacked
=
=
other
;
}
var
index
=
-
1
result
=
true
seen
=
(
bitmask
&
COMPARE_UNORDERED_FLAG
)
?
new
SetCache
:
undefined
;
stack
.
set
(
array
other
)
;
stack
.
set
(
other
array
)
;
while
(
+
+
index
<
arrLength
)
{
var
arrValue
=
array
[
index
]
othValue
=
other
[
index
]
;
if
(
customizer
)
{
var
compared
=
isPartial
?
customizer
(
othValue
arrValue
index
other
array
stack
)
:
customizer
(
arrValue
othValue
index
array
other
stack
)
;
}
if
(
compared
!
=
=
undefined
)
{
if
(
compared
)
{
continue
;
}
result
=
false
;
break
;
}
if
(
seen
)
{
if
(
!
arraySome
(
other
function
(
othValue
othIndex
)
{
if
(
!
cacheHas
(
seen
othIndex
)
&
&
(
arrValue
=
=
=
othValue
|
|
equalFunc
(
arrValue
othValue
bitmask
customizer
stack
)
)
)
{
return
seen
.
push
(
othIndex
)
;
}
}
)
)
{
result
=
false
;
break
;
}
}
else
if
(
!
(
arrValue
=
=
=
othValue
|
|
equalFunc
(
arrValue
othValue
bitmask
customizer
stack
)
)
)
{
result
=
false
;
break
;
}
}
stack
[
'
delete
'
]
(
array
)
;
stack
[
'
delete
'
]
(
other
)
;
return
result
;
}
module
.
exports
=
equalArrays
;
}
276
:
function
(
module
exports
__webpack_require__
)
{
var
MapCache
=
__webpack_require__
(
76
)
setCacheAdd
=
__webpack_require__
(
277
)
setCacheHas
=
__webpack_require__
(
278
)
;
function
SetCache
(
values
)
{
var
index
=
-
1
length
=
values
=
=
null
?
0
:
values
.
length
;
this
.
__data__
=
new
MapCache
;
while
(
+
+
index
<
length
)
{
this
.
add
(
values
[
index
]
)
;
}
}
SetCache
.
prototype
.
add
=
SetCache
.
prototype
.
push
=
setCacheAdd
;
SetCache
.
prototype
.
has
=
setCacheHas
;
module
.
exports
=
SetCache
;
}
277
:
function
(
module
exports
)
{
var
HASH_UNDEFINED
=
'
__lodash_hash_undefined__
'
;
function
setCacheAdd
(
value
)
{
this
.
__data__
.
set
(
value
HASH_UNDEFINED
)
;
return
this
;
}
module
.
exports
=
setCacheAdd
;
}
278
:
function
(
module
exports
)
{
function
setCacheHas
(
value
)
{
return
this
.
__data__
.
has
(
value
)
;
}
module
.
exports
=
setCacheHas
;
}
279
:
function
(
module
exports
)
{
function
arraySome
(
array
predicate
)
{
var
index
=
-
1
length
=
array
=
=
null
?
0
:
array
.
length
;
while
(
+
+
index
<
length
)
{
if
(
predicate
(
array
[
index
]
index
array
)
)
{
return
true
;
}
}
return
false
;
}
module
.
exports
=
arraySome
;
}
280
:
function
(
module
exports
)
{
function
cacheHas
(
cache
key
)
{
return
cache
.
has
(
key
)
;
}
module
.
exports
=
cacheHas
;
}
281
:
function
(
module
exports
__webpack_require__
)
{
var
Symbol
=
__webpack_require__
(
7
)
Uint8Array
=
__webpack_require__
(
282
)
eq
=
__webpack_require__
(
97
)
equalArrays
=
__webpack_require__
(
275
)
mapToArray
=
__webpack_require__
(
203
)
setToArray
=
__webpack_require__
(
283
)
;
var
COMPARE_PARTIAL_FLAG
=
1
COMPARE_UNORDERED_FLAG
=
2
;
var
boolTag
=
'
[
object
Boolean
]
'
dateTag
=
'
[
object
Date
]
'
errorTag
=
'
[
object
Error
]
'
mapTag
=
'
[
object
Map
]
'
numberTag
=
'
[
object
Number
]
'
regexpTag
=
'
[
object
RegExp
]
'
setTag
=
'
[
object
Set
]
'
stringTag
=
'
[
object
String
]
'
symbolTag
=
'
[
object
Symbol
]
'
;
var
arrayBufferTag
=
'
[
object
ArrayBuffer
]
'
dataViewTag
=
'
[
object
DataView
]
'
;
var
symbolProto
=
Symbol
?
Symbol
.
prototype
:
undefined
symbolValueOf
=
symbolProto
?
symbolProto
.
valueOf
:
undefined
;
function
equalByTag
(
object
other
tag
bitmask
customizer
equalFunc
stack
)
{
switch
(
tag
)
{
case
dataViewTag
:
if
(
(
object
.
byteLength
!
=
other
.
byteLength
)
|
|
(
object
.
byteOffset
!
=
other
.
byteOffset
)
)
{
return
false
;
}
object
=
object
.
buffer
;
other
=
other
.
buffer
;
case
arrayBufferTag
:
if
(
(
object
.
byteLength
!
=
other
.
byteLength
)
|
|
!
equalFunc
(
new
Uint8Array
(
object
)
new
Uint8Array
(
other
)
)
)
{
return
false
;
}
return
true
;
case
boolTag
:
case
dateTag
:
case
numberTag
:
return
eq
(
+
object
+
other
)
;
case
errorTag
:
return
object
.
name
=
=
other
.
name
&
&
object
.
message
=
=
other
.
message
;
case
regexpTag
:
case
stringTag
:
return
object
=
=
(
other
+
'
'
)
;
case
mapTag
:
var
convert
=
mapToArray
;
case
setTag
:
var
isPartial
=
bitmask
&
COMPARE_PARTIAL_FLAG
;
convert
|
|
(
convert
=
setToArray
)
;
if
(
object
.
size
!
=
other
.
size
&
&
!
isPartial
)
{
return
false
;
}
var
stacked
=
stack
.
get
(
object
)
;
if
(
stacked
)
{
return
stacked
=
=
other
;
}
bitmask
|
=
COMPARE_UNORDERED_FLAG
;
stack
.
set
(
object
other
)
;
var
result
=
equalArrays
(
convert
(
object
)
convert
(
other
)
bitmask
customizer
equalFunc
stack
)
;
stack
[
'
delete
'
]
(
object
)
;
return
result
;
case
symbolTag
:
if
(
symbolValueOf
)
{
return
symbolValueOf
.
call
(
object
)
=
=
symbolValueOf
.
call
(
other
)
;
}
}
return
false
;
}
module
.
exports
=
equalByTag
;
}
282
:
function
(
module
exports
__webpack_require__
)
{
var
root
=
__webpack_require__
(
8
)
;
var
Uint8Array
=
root
.
Uint8Array
;
module
.
exports
=
Uint8Array
;
}
283
:
function
(
module
exports
)
{
function
setToArray
(
set
)
{
var
index
=
-
1
result
=
Array
(
set
.
size
)
;
set
.
forEach
(
function
(
value
)
{
result
[
+
+
index
]
=
value
;
}
)
;
return
result
;
}
module
.
exports
=
setToArray
;
}
284
:
function
(
module
exports
__webpack_require__
)
{
var
getAllKeys
=
__webpack_require__
(
285
)
;
var
COMPARE_PARTIAL_FLAG
=
1
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
function
equalObjects
(
object
other
bitmask
customizer
equalFunc
stack
)
{
var
isPartial
=
bitmask
&
COMPARE_PARTIAL_FLAG
objProps
=
getAllKeys
(
object
)
objLength
=
objProps
.
length
othProps
=
getAllKeys
(
other
)
othLength
=
othProps
.
length
;
if
(
objLength
!
=
othLength
&
&
!
isPartial
)
{
return
false
;
}
var
index
=
objLength
;
while
(
index
-
-
)
{
var
key
=
objProps
[
index
]
;
if
(
!
(
isPartial
?
key
in
other
:
hasOwnProperty
.
call
(
other
key
)
)
)
{
return
false
;
}
}
var
stacked
=
stack
.
get
(
object
)
;
if
(
stacked
&
&
stack
.
get
(
other
)
)
{
return
stacked
=
=
other
;
}
var
result
=
true
;
stack
.
set
(
object
other
)
;
stack
.
set
(
other
object
)
;
var
skipCtor
=
isPartial
;
while
(
+
+
index
<
objLength
)
{
key
=
objProps
[
index
]
;
var
objValue
=
object
[
key
]
othValue
=
other
[
key
]
;
if
(
customizer
)
{
var
compared
=
isPartial
?
customizer
(
othValue
objValue
key
other
object
stack
)
:
customizer
(
objValue
othValue
key
object
other
stack
)
;
}
if
(
!
(
compared
=
=
=
undefined
?
(
objValue
=
=
=
othValue
|
|
equalFunc
(
objValue
othValue
bitmask
customizer
stack
)
)
:
compared
)
)
{
result
=
false
;
break
;
}
skipCtor
|
|
(
skipCtor
=
key
=
=
'
constructor
'
)
;
}
if
(
result
&
&
!
skipCtor
)
{
var
objCtor
=
object
.
constructor
othCtor
=
other
.
constructor
;
if
(
objCtor
!
=
othCtor
&
&
(
'
constructor
'
in
object
&
&
'
constructor
'
in
other
)
&
&
!
(
typeof
objCtor
=
=
'
function
'
&
&
objCtor
instanceof
objCtor
&
&
typeof
othCtor
=
=
'
function
'
&
&
othCtor
instanceof
othCtor
)
)
{
result
=
false
;
}
}
stack
[
'
delete
'
]
(
object
)
;
stack
[
'
delete
'
]
(
other
)
;
return
result
;
}
module
.
exports
=
equalObjects
;
}
285
:
function
(
module
exports
__webpack_require__
)
{
var
baseGetAllKeys
=
__webpack_require__
(
286
)
getSymbols
=
__webpack_require__
(
288
)
keys
=
__webpack_require__
(
205
)
;
function
getAllKeys
(
object
)
{
return
baseGetAllKeys
(
object
keys
getSymbols
)
;
}
module
.
exports
=
getAllKeys
;
}
286
:
function
(
module
exports
__webpack_require__
)
{
var
arrayPush
=
__webpack_require__
(
287
)
isArray
=
__webpack_require__
(
70
)
;
function
baseGetAllKeys
(
object
keysFunc
symbolsFunc
)
{
var
result
=
keysFunc
(
object
)
;
return
isArray
(
object
)
?
result
:
arrayPush
(
result
symbolsFunc
(
object
)
)
;
}
module
.
exports
=
baseGetAllKeys
;
}
287
:
function
(
module
exports
)
{
function
arrayPush
(
array
values
)
{
var
index
=
-
1
length
=
values
.
length
offset
=
array
.
length
;
while
(
+
+
index
<
length
)
{
array
[
offset
+
index
]
=
values
[
index
]
;
}
return
array
;
}
module
.
exports
=
arrayPush
;
}
288
:
function
(
module
exports
__webpack_require__
)
{
var
arrayFilter
=
__webpack_require__
(
289
)
stubArray
=
__webpack_require__
(
290
)
;
var
objectProto
=
Object
.
prototype
;
var
propertyIsEnumerable
=
objectProto
.
propertyIsEnumerable
;
var
nativeGetSymbols
=
Object
.
getOwnPropertySymbols
;
var
getSymbols
=
!
nativeGetSymbols
?
stubArray
:
function
(
object
)
{
if
(
object
=
=
null
)
{
return
[
]
;
}
object
=
Object
(
object
)
;
return
arrayFilter
(
nativeGetSymbols
(
object
)
function
(
symbol
)
{
return
propertyIsEnumerable
.
call
(
object
symbol
)
;
}
)
;
}
;
module
.
exports
=
getSymbols
;
}
289
:
function
(
module
exports
)
{
function
arrayFilter
(
array
predicate
)
{
var
index
=
-
1
length
=
array
=
=
null
?
0
:
array
.
length
resIndex
=
0
result
=
[
]
;
while
(
+
+
index
<
length
)
{
var
value
=
array
[
index
]
;
if
(
predicate
(
value
index
array
)
)
{
result
[
resIndex
+
+
]
=
value
;
}
}
return
result
;
}
module
.
exports
=
arrayFilter
;
}
290
:
function
(
module
exports
)
{
function
stubArray
(
)
{
return
[
]
;
}
module
.
exports
=
stubArray
;
}
291
:
function
(
module
exports
__webpack_require__
)
{
var
isStrictComparable
=
__webpack_require__
(
292
)
keys
=
__webpack_require__
(
205
)
;
function
getMatchData
(
object
)
{
var
result
=
keys
(
object
)
length
=
result
.
length
;
while
(
length
-
-
)
{
var
key
=
result
[
length
]
value
=
object
[
key
]
;
result
[
length
]
=
[
key
value
isStrictComparable
(
value
)
]
;
}
return
result
;
}
module
.
exports
=
getMatchData
;
}
292
:
function
(
module
exports
__webpack_require__
)
{
var
isObject
=
__webpack_require__
(
84
)
;
function
isStrictComparable
(
value
)
{
return
value
=
=
=
value
&
&
!
isObject
(
value
)
;
}
module
.
exports
=
isStrictComparable
;
}
293
:
function
(
module
exports
)
{
function
matchesStrictComparable
(
key
srcValue
)
{
return
function
(
object
)
{
if
(
object
=
=
null
)
{
return
false
;
}
return
object
[
key
]
=
=
=
srcValue
&
&
(
srcValue
!
=
=
undefined
|
|
(
key
in
Object
(
object
)
)
)
;
}
;
}
module
.
exports
=
matchesStrictComparable
;
}
294
:
function
(
module
exports
__webpack_require__
)
{
var
baseIsEqual
=
__webpack_require__
(
273
)
get
=
__webpack_require__
(
67
)
hasIn
=
__webpack_require__
(
295
)
isKey
=
__webpack_require__
(
71
)
isStrictComparable
=
__webpack_require__
(
292
)
matchesStrictComparable
=
__webpack_require__
(
293
)
toKey
=
__webpack_require__
(
111
)
;
var
COMPARE_PARTIAL_FLAG
=
1
COMPARE_UNORDERED_FLAG
=
2
;
function
baseMatchesProperty
(
path
srcValue
)
{
if
(
isKey
(
path
)
&
&
isStrictComparable
(
srcValue
)
)
{
return
matchesStrictComparable
(
toKey
(
path
)
srcValue
)
;
}
return
function
(
object
)
{
var
objValue
=
get
(
object
path
)
;
return
(
objValue
=
=
=
undefined
&
&
objValue
=
=
=
srcValue
)
?
hasIn
(
object
path
)
:
baseIsEqual
(
srcValue
objValue
COMPARE_PARTIAL_FLAG
|
COMPARE_UNORDERED_FLAG
)
;
}
;
}
module
.
exports
=
baseMatchesProperty
;
}
295
:
function
(
module
exports
__webpack_require__
)
{
var
baseHasIn
=
__webpack_require__
(
296
)
hasPath
=
__webpack_require__
(
297
)
;
function
hasIn
(
object
path
)
{
return
object
!
=
null
&
&
hasPath
(
object
path
baseHasIn
)
;
}
module
.
exports
=
hasIn
;
}
296
:
function
(
module
exports
)
{
function
baseHasIn
(
object
key
)
{
return
object
!
=
null
&
&
key
in
Object
(
object
)
;
}
module
.
exports
=
baseHasIn
;
}
297
:
function
(
module
exports
__webpack_require__
)
{
var
castPath
=
__webpack_require__
(
69
)
isArguments
=
__webpack_require__
(
208
)
isArray
=
__webpack_require__
(
70
)
isIndex
=
__webpack_require__
(
117
)
isLength
=
__webpack_require__
(
214
)
toKey
=
__webpack_require__
(
111
)
;
function
hasPath
(
object
path
hasFunc
)
{
path
=
castPath
(
path
object
)
;
var
index
=
-
1
length
=
path
.
length
result
=
false
;
while
(
+
+
index
<
length
)
{
var
key
=
toKey
(
path
[
index
]
)
;
if
(
!
(
result
=
object
!
=
null
&
&
hasFunc
(
object
key
)
)
)
{
break
;
}
object
=
object
[
key
]
;
}
if
(
result
|
|
+
+
index
!
=
length
)
{
return
result
;
}
length
=
object
=
=
null
?
0
:
object
.
length
;
return
!
!
length
&
&
isLength
(
length
)
&
&
isIndex
(
key
length
)
&
&
(
isArray
(
object
)
|
|
isArguments
(
object
)
)
;
}
module
.
exports
=
hasPath
;
}
298
:
function
(
module
exports
)
{
function
identity
(
value
)
{
return
value
;
}
module
.
exports
=
identity
;
}
299
:
function
(
module
exports
__webpack_require__
)
{
var
baseProperty
=
__webpack_require__
(
300
)
basePropertyDeep
=
__webpack_require__
(
301
)
isKey
=
__webpack_require__
(
71
)
toKey
=
__webpack_require__
(
111
)
;
function
property
(
path
)
{
return
isKey
(
path
)
?
baseProperty
(
toKey
(
path
)
)
:
basePropertyDeep
(
path
)
;
}
module
.
exports
=
property
;
}
300
:
function
(
module
exports
)
{
function
baseProperty
(
key
)
{
return
function
(
object
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
;
}
module
.
exports
=
baseProperty
;
}
301
:
function
(
module
exports
__webpack_require__
)
{
var
baseGet
=
__webpack_require__
(
68
)
;
function
basePropertyDeep
(
path
)
{
return
function
(
object
)
{
return
baseGet
(
object
path
)
;
}
;
}
module
.
exports
=
basePropertyDeep
;
}
395
:
function
(
module
exports
__webpack_require__
)
{
var
createBaseFor
=
__webpack_require__
(
396
)
;
var
baseFor
=
createBaseFor
(
)
;
module
.
exports
=
baseFor
;
}
396
:
function
(
module
exports
)
{
function
createBaseFor
(
fromRight
)
{
return
function
(
object
iteratee
keysFunc
)
{
var
index
=
-
1
iterable
=
Object
(
object
)
props
=
keysFunc
(
object
)
length
=
props
.
length
;
while
(
length
-
-
)
{
var
key
=
props
[
fromRight
?
length
:
+
+
index
]
;
if
(
iteratee
(
iterable
[
key
]
key
iterable
)
=
=
=
false
)
{
break
;
}
}
return
object
;
}
;
}
module
.
exports
=
createBaseFor
;
}
757
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
tests
=
__webpack_require__
(
758
)
;
var
_require
=
__webpack_require__
(
766
)
setupTestRunner
=
_require
.
setupTestRunner
;
var
utils
=
__webpack_require__
(
760
)
;
var
_require2
=
__webpack_require__
(
828
)
isDevelopment
=
_require2
.
isDevelopment
;
if
(
isDevelopment
(
)
)
{
__webpack_require__
(
792
)
;
}
module
.
exports
=
Object
.
assign
(
{
}
tests
{
setupTestRunner
utils
}
)
;
}
758
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
module
.
exports
=
{
asm
:
__webpack_require__
(
759
)
breaking
:
__webpack_require__
(
769
)
breakpoints
:
__webpack_require__
(
770
)
breakpointsCond
:
__webpack_require__
(
771
)
callStack
:
__webpack_require__
(
772
)
expressions
:
__webpack_require__
(
773
)
debuggerButtons
:
__webpack_require__
(
774
)
editorSelect
:
__webpack_require__
(
775
)
editorPreview
:
__webpack_require__
(
1020
)
editorGutter
:
__webpack_require__
(
776
)
editorHighlight
:
__webpack_require__
(
777
)
keyboardNavigation
:
__webpack_require__
(
778
)
keyboardShortcuts
:
__webpack_require__
(
779
)
iframes
:
__webpack_require__
(
780
)
navigation
:
__webpack_require__
(
781
)
pauseOnExceptions
:
__webpack_require__
(
782
)
prettyPrint
:
__webpack_require__
(
783
)
prettyPrintPaused
:
__webpack_require__
(
784
)
returnvalues
:
__webpack_require__
(
785
)
scopes
:
__webpack_require__
(
786
)
scopesMutations
:
__webpack_require__
(
1021
)
searching
:
__webpack_require__
(
787
)
sources
:
__webpack_require__
(
788
)
sourceMaps
:
__webpack_require__
(
789
)
sourceMapsReloading
:
__webpack_require__
(
1129
)
sourceMaps2
:
__webpack_require__
(
790
)
sourceMapsBogus
:
__webpack_require__
(
791
)
tabs
:
__webpack_require__
(
1022
)
}
;
}
759
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
asm
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
is
=
ctx
.
is
;
var
dbg
=
yield
initDebugger
(
"
doc
-
asm
.
html
"
)
;
var
getSelectedSource
=
dbg
.
selectors
.
getSelectedSource
getState
=
dbg
.
getState
;
yield
reload
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
yield
resume
(
dbg
)
;
yield
waitForSources
(
dbg
"
doc
-
asm
.
html
"
"
asm
.
js
"
)
;
is
(
findAllElements
(
dbg
"
sourceNodes
"
)
.
length
2
)
;
clickElement
(
dbg
"
sourceArrow
"
2
)
;
is
(
findAllElements
(
dbg
"
sourceNodes
"
)
.
length
4
)
;
selectSource
(
dbg
"
asm
.
js
"
)
;
yield
addBreakpoint
(
dbg
"
asm
.
js
"
7
)
;
invokeInTab
(
dbg
"
runAsm
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
asm
.
js
"
7
)
;
}
)
;
return
function
asm
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
invokeInTab
=
_require
.
invokeInTab
assertPausedLocation
=
_require
.
assertPausedLocation
clickElement
=
_require
.
clickElement
findAllElements
=
_require
.
findAllElements
addBreakpoint
=
_require
.
addBreakpoint
reload
=
_require
.
reload
waitForPaused
=
_require
.
waitForPaused
resume
=
_require
.
resume
selectSource
=
_require
.
selectSource
waitForSources
=
_require
.
waitForSources
;
module
.
exports
=
asm
;
}
760
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
wait
=
__webpack_require__
(
761
)
;
var
assert
=
__webpack_require__
(
765
)
;
var
mocha
=
__webpack_require__
(
766
)
;
var
commands
=
__webpack_require__
(
767
)
;
var
shared
=
__webpack_require__
(
762
)
;
module
.
exports
=
Object
.
assign
(
{
}
wait
assert
mocha
commands
shared
)
;
}
761
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
waitForState
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
dbg
predicate
)
{
return
new
Promise
(
function
(
resolve
)
{
var
unsubscribe
=
dbg
.
store
.
subscribe
(
function
(
)
{
if
(
predicate
(
dbg
.
store
.
getState
(
)
)
)
{
unsubscribe
(
)
;
resolve
(
)
;
}
}
)
;
}
)
;
}
)
;
return
function
waitForState
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForPaused
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
dbg
)
{
yield
waitForThreadEvents
(
dbg
"
paused
"
)
yield
waitForState
(
dbg
function
(
state
)
{
var
pause
=
dbg
.
selectors
.
getPause
(
state
)
;
if
(
!
pause
)
{
return
false
;
}
var
sourceId
=
get
(
pause
"
frame
.
location
.
sourceId
"
)
;
var
source
=
dbg
.
selectors
.
getSourc
(
dbg
.
getState
(
)
sourceId
)
;
return
source
&
&
!
source
.
get
(
"
loading
"
)
;
}
)
;
}
)
;
return
function
waitForPaused
(
_x3
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForDispatch
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
dbg
type
)
{
var
_ref4
=
arguments
.
length
>
2
&
&
arguments
[
2
]
!
=
=
undefined
?
arguments
[
2
]
:
{
}
_ref4
useLaunchpad
=
_ref4
.
useLaunchpad
useLaunchpad
=
_ref4
useLaunchpad
=
=
=
undefined
?
false
:
_ref4
useLaunchpad
_ref4
eventRepeat
=
_ref4
.
eventRepeat
eventRepeat
=
_ref4
eventRepeat
=
=
=
undefined
?
1
:
_ref4
eventRepeat
;
var
store
=
useLaunchpad
?
dbg
.
launchpadStore
:
dbg
.
store
;
var
count
=
0
;
info
(
"
Waiting
for
"
+
type
+
"
to
dispatch
"
+
eventRepeat
+
"
time
(
s
)
"
)
;
while
(
count
<
eventRepeat
)
{
yield
_afterDispatchDone
(
store
type
)
;
count
+
+
;
info
(
type
+
"
dispatched
"
+
count
+
"
time
(
s
)
"
)
;
}
}
)
;
return
function
waitForDispatch
(
_x4
_x5
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
_afterDispatchDone
=
(
(
)
=
>
{
var
_ref5
=
_asyncToGenerator
(
function
*
(
store
type
)
{
return
new
Promise
(
function
(
resolve
)
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
function
(
action
)
{
if
(
action
.
type
=
=
=
type
)
{
return
action
.
status
?
action
.
status
=
=
=
"
done
"
|
|
action
.
status
=
=
=
"
error
"
:
true
;
}
}
run
:
function
(
dispatch
getState
action
)
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
)
;
return
function
_afterDispatchDone
(
_x7
_x8
)
{
return
_ref5
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForNextDispatch
=
(
(
)
=
>
{
var
_ref6
=
_asyncToGenerator
(
function
*
(
store
type
)
{
return
new
Promise
(
function
(
resolve
)
{
store
.
dispatch
(
{
type
:
"
service
/
waitUntil
"
predicate
:
function
(
action
)
{
return
action
.
type
=
=
=
type
;
}
run
:
function
(
dispatch
getState
action
)
{
resolve
(
action
)
;
}
}
)
;
}
)
;
}
)
;
return
function
waitForNextDispatch
(
_x9
_x10
)
{
return
_ref6
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForTime
=
(
(
)
=
>
{
var
_ref7
=
_asyncToGenerator
(
function
*
(
time
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
setTimeout
(
resolve
time
)
;
}
)
;
}
)
;
return
function
waitForTime
(
_x11
)
{
return
_ref7
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForSources
=
(
(
)
=
>
{
var
_ref8
=
_asyncToGenerator
(
function
*
(
dbg
)
{
for
(
var
_len
=
arguments
.
length
sources
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
sources
[
_key
-
1
]
=
arguments
[
_key
]
;
}
if
(
sources
.
length
=
=
=
0
)
{
return
Promise
.
resolve
(
)
;
}
function
sourceExists
(
state
url
)
{
return
getSources
(
state
)
.
some
(
s
=
>
{
var
sourceUrl
=
s
.
get
(
"
url
"
)
;
return
sourceUrl
&
&
sourceUrl
.
includes
(
url
)
;
}
)
;
}
info
(
"
Waiting
on
sources
:
"
+
sources
.
join
(
"
"
)
)
;
var
getSources
=
dbg
.
selectors
.
getSources
store
=
dbg
.
store
;
return
Promise
.
all
(
sources
.
map
(
function
(
url
)
{
if
(
!
sourceExists
(
store
.
getState
(
)
url
)
)
{
return
waitForState
(
dbg
function
(
)
{
return
sourceExists
(
store
.
getState
(
)
url
)
;
}
)
;
}
}
)
)
;
}
)
;
return
function
waitForSources
(
_x12
)
{
return
_ref8
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForElement
=
(
(
)
=
>
{
var
_ref9
=
_asyncToGenerator
(
function
*
(
dbg
selector
)
{
return
waitUntil
(
function
(
)
{
return
findElementWithSelector
(
dbg
selector
)
;
}
)
;
}
)
;
return
function
waitForElement
(
_x13
_x14
)
{
return
_ref9
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitUntil
=
(
(
)
=
>
{
var
_ref10
=
_asyncToGenerator
(
function
*
(
predicate
)
{
var
interval
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
20
;
return
new
Promise
(
function
(
resolve
)
{
var
timer
=
setInterval
(
function
(
)
{
if
(
predicate
(
)
)
{
clearInterval
(
timer
)
;
resolve
(
)
;
}
}
interval
)
;
}
)
;
}
)
;
return
function
waitUntil
(
_x15
)
{
return
_ref10
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForThreadEvents
=
(
(
)
=
>
{
var
_ref11
=
_asyncToGenerator
(
function
*
(
dbg
eventName
)
{
info
(
"
Waiting
for
thread
event
'
"
+
eventName
+
"
'
to
fire
.
"
)
;
var
thread
=
dbg
.
threadClient
;
return
new
Promise
(
function
(
resolve
reject
)
{
thread
.
addListener
(
eventName
function
onEvent
(
eventName
)
{
info
(
"
Thread
event
'
"
+
eventName
+
"
'
fired
.
"
)
;
thread
.
removeListener
(
eventName
onEvent
)
;
resolve
.
apply
(
resolve
)
;
}
)
;
}
)
;
}
)
;
return
function
waitForThreadEvents
(
_x17
_x18
)
{
return
_ref11
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
waitForTargetEvent
=
(
(
)
=
>
{
var
_ref12
=
_asyncToGenerator
(
function
*
(
dbg
eventName
)
{
info
(
"
Waiting
for
target
event
'
"
+
eventName
+
"
'
to
fire
.
"
)
;
var
tabTarget
=
dbg
.
tabTarget
;
return
new
Promise
(
function
(
resolve
reject
)
{
tabTarget
.
on
(
eventName
function
onEvent
(
eventName
)
{
info
(
"
Thread
event
'
"
+
eventName
+
"
'
fired
.
"
)
;
tabTarget
.
off
(
eventName
onEvent
)
;
resolve
.
apply
(
resolve
)
;
}
)
;
}
)
;
}
)
;
return
function
waitForTargetEvent
(
_x19
_x20
)
{
return
_ref12
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
get
=
__webpack_require__
(
67
)
;
var
_require
=
__webpack_require__
(
762
)
findElementWithSelector
=
_require
.
findElementWithSelector
info
=
_require
.
info
;
module
.
exports
=
{
waitForPaused
waitForDispatch
waitForTime
waitForSources
waitForElement
waitForTargetEvent
waitForThreadEvents
waitUntil
}
;
}
762
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
mapValues
=
__webpack_require__
(
763
)
;
var
selectors
=
{
callStackHeader
:
"
.
call
-
stack
-
pane
.
_header
"
callStackBody
:
"
.
call
-
stack
-
pane
.
pane
"
scopesHeader
:
"
.
scopes
-
pane
.
_header
"
breakpointItem
:
i
=
>
.
breakpoints
-
list
.
breakpoint
:
nth
-
child
(
{
i
}
)
scopeNode
:
i
=
>
.
scopes
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
label
scopeValue
:
i
=
>
.
scopes
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
value
expressionNode
:
i
=
>
.
expressions
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
label
expressionValue
:
i
=
>
.
expressions
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
object
-
value
expressionClose
:
i
=
>
.
expressions
-
list
.
expression
-
container
:
nth
-
child
(
{
i
}
)
.
close
-
btn
expressionNodes
:
"
.
expressions
-
list
.
tree
-
node
"
frame
:
i
=
>
.
frames
ul
li
:
nth
-
child
(
{
i
}
)
frames
:
"
.
frames
ul
li
"
gutter
:
i
=
>
.
CodeMirror
-
code
*
:
nth
-
child
(
{
i
}
)
.
CodeMirror
-
linenumber
menuitem
:
i
=
>
menupopup
menuitem
:
nth
-
child
(
{
i
}
)
pauseOnExceptions
:
"
.
pause
-
exceptions
"
breakpoint
:
"
.
CodeMirror
-
code
>
.
new
-
breakpoint
"
highlightLine
:
"
.
CodeMirror
-
code
>
.
highlight
-
line
"
codeMirror
:
"
.
CodeMirror
"
resume
:
"
.
resume
.
active
"
stepOver
:
"
.
stepOver
.
active
"
stepOut
:
"
.
stepOut
.
active
"
stepIn
:
"
.
stepIn
.
active
"
toggleBreakpoints
:
"
.
breakpoints
-
toggle
"
prettyPrintButton
:
"
.
prettyPrint
"
sourcesFooter
:
"
.
sources
-
panel
.
source
-
footer
"
editorFooter
:
"
.
editor
-
pane
.
source
-
footer
"
sourceNode
:
i
=
>
.
sources
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
node
sourceNodes
:
"
.
sources
-
list
.
tree
-
node
"
sourceArrow
:
i
=
>
.
sources
-
list
.
tree
-
node
:
nth
-
child
(
{
i
}
)
.
arrow
sourceTabs
:
.
source
-
tabs
}
;
function
findElement
(
dbg
elementName
)
{
for
(
var
_len
=
arguments
.
length
args
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
2
]
=
arguments
[
_key
]
;
}
var
selector
=
getSelector
.
apply
(
undefined
[
elementName
]
.
concat
(
args
)
)
;
return
findElementWithSelector
(
dbg
selector
)
;
}
function
findElementWithSelector
(
dbg
selector
)
{
return
dbg
.
win
.
document
.
querySelector
(
selector
)
;
}
function
findAllElements
(
dbg
elementName
)
{
for
(
var
_len2
=
arguments
.
length
args
=
Array
(
_len2
>
2
?
_len2
-
2
:
0
)
_key2
=
2
;
_key2
<
_len2
;
_key2
+
+
)
{
args
[
_key2
-
2
]
=
arguments
[
_key2
]
;
}
var
selector
=
getSelector
.
apply
(
undefined
[
elementName
]
.
concat
(
args
)
)
;
return
dbg
.
win
.
document
.
querySelectorAll
(
selector
)
;
}
function
getSelector
(
elementName
)
{
var
selector
=
selectors
[
elementName
]
;
if
(
!
selector
)
{
throw
new
Error
(
The
selector
{
elementName
}
is
not
defined
)
;
}
if
(
typeof
selector
=
=
"
function
"
)
{
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
>
1
?
_len3
-
1
:
0
)
_key3
=
1
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
-
1
]
=
arguments
[
_key3
]
;
}
selector
=
selector
.
apply
(
undefined
args
)
;
}
return
selector
;
}
function
findSource
(
dbg
url
)
{
if
(
typeof
url
!
=
=
"
string
"
)
{
return
url
;
}
var
sources
=
dbg
.
selectors
.
getSources
(
dbg
.
getState
(
)
)
;
var
source
=
sources
.
find
(
s
=
>
{
var
sourceUrl
=
s
.
get
(
"
url
"
)
;
return
sourceUrl
&
&
sourceUrl
.
includes
(
url
)
;
}
)
;
if
(
!
source
)
{
throw
new
Error
(
"
Unable
to
find
source
:
"
+
url
)
;
}
return
source
.
toJS
(
)
;
}
function
isPaused
(
dbg
)
{
var
getPause
=
dbg
.
selectors
.
getPause
getState
=
dbg
.
getState
;
return
!
!
getPause
(
getState
(
)
)
;
}
function
isVisibleWithin
(
outerEl
innerEl
)
{
var
innerRect
=
innerEl
.
getBoundingClientRect
(
)
;
var
outerRect
=
outerEl
.
getBoundingClientRect
(
)
;
return
innerRect
.
top
>
outerRect
.
top
&
&
innerRect
.
bottom
<
outerRect
.
bottom
;
}
function
info
(
msg
)
{
var
message
=
INFO
:
{
msg
}
\
n
;
if
(
typeof
dump
=
=
"
function
"
)
{
dump
(
message
)
;
}
console
.
log
(
message
)
;
}
module
.
exports
=
{
findElement
findElementWithSelector
findAllElements
findSource
selectors
getSelector
isPaused
isVisibleWithin
info
}
;
}
763
:
function
(
module
exports
__webpack_require__
)
{
var
baseAssignValue
=
__webpack_require__
(
115
)
baseForOwn
=
__webpack_require__
(
764
)
baseIteratee
=
__webpack_require__
(
264
)
;
function
mapValues
(
object
iteratee
)
{
var
result
=
{
}
;
iteratee
=
baseIteratee
(
iteratee
3
)
;
baseForOwn
(
object
function
(
value
key
object
)
{
baseAssignValue
(
result
key
iteratee
(
value
key
object
)
)
;
}
)
;
return
result
;
}
module
.
exports
=
mapValues
;
}
764
:
function
(
module
exports
__webpack_require__
)
{
var
baseFor
=
__webpack_require__
(
395
)
keys
=
__webpack_require__
(
205
)
;
function
baseForOwn
(
object
iteratee
)
{
return
object
&
&
baseFor
(
object
iteratee
keys
)
;
}
module
.
exports
=
baseForOwn
;
}
765
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
get
=
__webpack_require__
(
67
)
;
var
_require
=
__webpack_require__
(
762
)
findSource
=
_require
.
findSource
findElement
=
_require
.
findElement
isVisibleWithin
=
_require
.
isVisibleWithin
isPaused
=
_require
.
isPaused
;
function
assertPausedLocation
(
dbg
ctx
source
line
)
{
var
_dbg
selectors
=
dbg
.
selectors
getSelectedSource
=
_dbg
selectors
.
getSelectedSource
getPause
=
_dbg
selectors
.
getPause
getState
=
dbg
.
getState
;
source
=
findSource
(
dbg
source
)
;
var
is
=
ctx
.
is
ok
=
ctx
.
ok
;
is
(
getSelectedSource
(
getState
(
)
)
.
get
(
"
id
"
)
source
.
id
)
;
var
location
=
get
(
getPause
(
getState
(
)
)
"
frame
.
location
"
)
;
is
(
location
.
sourceId
source
.
id
)
;
is
(
location
.
line
line
)
;
ok
(
dbg
.
win
.
cm
.
lineInfo
(
line
-
1
)
.
wrapClass
.
includes
(
"
debug
-
line
"
)
"
Line
is
highlighted
as
paused
"
)
;
}
function
assertNotPaused
(
dbg
ctx
)
{
var
ok
=
ctx
.
ok
;
ok
(
!
isPaused
(
dbg
)
"
not
paused
"
)
;
}
function
assertHighlightLocation
(
dbg
ctx
source
line
)
{
var
_dbg
selectors2
=
dbg
.
selectors
getSelectedSource
=
_dbg
selectors2
.
getSelectedSource
getPause
=
_dbg
selectors2
.
getPause
getState
=
dbg
.
getState
;
var
is
=
ctx
.
is
ok
=
ctx
.
ok
;
source
=
findSource
(
dbg
source
)
;
is
(
getSelectedSource
(
getState
(
)
)
.
get
(
"
url
"
)
source
.
url
)
;
var
lineEl
=
findElement
(
dbg
"
highlightLine
"
)
;
ok
(
lineEl
"
Line
is
highlighted
"
)
;
ok
(
isVisibleWithin
(
findElement
(
dbg
"
codeMirror
"
)
lineEl
)
"
Highlighted
line
is
visible
"
)
;
ok
(
dbg
.
win
.
cm
.
lineInfo
(
line
-
1
)
.
wrapClass
.
includes
(
"
highlight
-
line
"
)
"
Line
is
highlighted
"
)
;
}
module
.
exports
=
{
assertPausedLocation
assertNotPaused
assertHighlightLocation
}
;
}
766
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
initDebugger
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
url
)
{
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
tabs
"
)
;
Services
.
prefs
.
clearUserPref
(
"
devtools
.
debugger
.
pending
-
selected
-
location
"
)
;
url
=
url
.
startsWith
(
"
data
:
"
)
?
url
:
EXAMPLE_URL
+
url
;
var
toolbox
=
yield
openNewTabAndToolbox
(
url
"
jsdebugger
"
)
;
return
createDebuggerContext
(
toolbox
)
;
}
)
;
return
function
initDebugger
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
762
)
info
=
_require
.
info
;
var
ContentTask
gBrowser
isLinux
isMac
cmdOrCtrl
keyMappings
openNewTabAndToolbox
Services
EXAMPLE_URL
EventUtils
;
function
setKeyboardMapping
(
isLinux
cmdOrCtrl
)
{
var
endKey
=
isMac
?
{
code
:
"
VK_RIGHT
"
modifiers
:
cmdOrCtrl
}
:
{
code
:
"
VK_END
"
}
;
var
startKey
=
isMac
?
{
code
:
"
VK_LEFT
"
modifiers
:
cmdOrCtrl
}
:
{
code
:
"
VK_HOME
"
}
;
return
{
sourceSearch
:
{
code
:
"
p
"
modifiers
:
cmdOrCtrl
}
fileSearch
:
{
code
:
"
f
"
modifiers
:
cmdOrCtrl
}
Enter
:
{
code
:
"
VK_RETURN
"
}
Up
:
{
code
:
"
VK_UP
"
}
Down
:
{
code
:
"
VK_DOWN
"
}
Right
:
{
code
:
"
VK_RIGHT
"
}
Left
:
{
code
:
"
VK_LEFT
"
}
End
:
endKey
Start
:
startKey
Tab
:
{
code
:
"
VK_TAB
"
}
Escape
:
{
code
:
"
VK_ESCAPE
"
}
pauseKey
:
{
code
:
"
VK_F8
"
}
resumeKey
:
{
code
:
"
VK_F8
"
}
stepOverKey
:
{
code
:
"
VK_F10
"
}
stepInKey
:
{
code
:
"
VK_F11
"
modifiers
:
{
ctrlKey
:
isLinux
}
}
stepOutKey
:
{
code
:
"
VK_F11
"
modifiers
:
{
ctrlKey
:
isLinux
shiftKey
:
true
}
}
}
;
}
function
setupTestRunner
(
context
)
{
ContentTask
=
context
.
ContentTask
;
gBrowser
=
context
.
gBrowser
;
openNewTabAndToolbox
=
context
.
openNewTabAndToolbox
;
Services
=
context
.
Services
;
EXAMPLE_URL
=
context
.
EXAMPLE_URL
;
EventUtils
=
context
.
EventUtils
;
isLinux
=
Services
.
appinfo
.
OS
=
=
=
"
Linux
"
;
isMac
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
cmdOrCtrl
=
isLinux
?
{
ctrlKey
:
true
}
:
{
metaKey
:
true
}
;
keyMappings
=
setKeyboardMapping
(
isLinux
cmdOrCtrl
)
;
}
function
invokeInTab
(
dbg
fnc
)
{
info
(
Invoking
function
{
fnc
}
in
tab
)
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
fnc
function
*
(
fnc
)
{
content
.
wrappedJSObject
[
fnc
]
(
)
;
}
)
;
}
function
evalInTab
(
dbg
script
)
{
info
(
evaling
script
{
script
}
)
;
return
ContentTask
.
spawn
(
gBrowser
.
selectedBrowser
script
function
(
script
)
{
content
.
eval
(
script
)
;
}
)
;
}
function
selectMenuItem
(
dbg
index
)
{
var
doc
=
dbg
.
toolbox
.
win
.
document
;
var
popup
=
doc
.
querySelector
(
'
menupopup
[
menu
-
api
=
"
true
"
]
'
)
;
var
item
=
popup
.
querySelector
(
menuitem
:
nth
-
child
(
{
index
}
)
)
;
return
EventUtils
.
synthesizeMouseAtCenter
(
item
{
}
dbg
.
toolbox
.
win
)
;
}
function
pressKey
(
dbg
keyName
)
{
var
keyEvent
=
keyMappings
[
keyName
]
;
var
code
=
keyEvent
.
code
modifiers
=
keyEvent
.
modifiers
;
return
EventUtils
.
synthesizeKey
(
code
modifiers
|
|
{
}
dbg
.
win
)
;
}
function
type
(
dbg
string
)
{
string
.
split
(
"
"
)
.
forEach
(
char
=
>
{
EventUtils
.
synthesizeKey
(
char
{
}
dbg
.
win
)
;
}
)
;
}
function
countSources
(
dbg
)
{
var
sources
=
dbg
.
selectors
.
getSources
(
dbg
.
getState
(
)
)
;
return
sources
.
size
;
}
function
createDebuggerContext
(
toolbox
)
{
var
win
=
toolbox
.
getPanel
(
"
jsdebugger
"
)
.
panelWin
;
var
store
=
win
.
Debugger
.
store
;
return
{
actions
:
win
.
Debugger
.
actions
selectors
:
win
.
Debugger
.
selectors
getState
:
store
.
getState
store
:
store
client
:
win
.
Debugger
.
client
threadClient
:
toolbox
.
threadClient
toolbox
:
toolbox
win
:
win
}
;
}
module
.
exports
=
{
invokeInTab
evalInTab
selectMenuItem
pressKey
type
countSources
setupTestRunner
info
initDebugger
environment
:
"
mochitest
"
}
;
}
767
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
selectSource
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
dbg
url
line
)
{
info
(
"
Selecting
source
:
"
+
url
)
;
var
source
=
findSource
(
dbg
url
)
;
var
hasSource
=
!
!
dbg
.
selectors
.
getSource
(
dbg
.
getState
(
)
source
.
id
)
;
dbg
.
actions
.
selectSource
(
source
.
id
{
line
}
)
;
if
(
!
hasSource
)
{
return
waitForDispatch
(
dbg
"
SELECT_SOURCE
"
)
;
}
}
)
;
return
function
selectSource
(
_x
_x2
_x3
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
stepOver
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
dbg
)
{
info
(
"
Stepping
over
"
)
;
dbg
.
actions
.
stepOver
(
)
;
return
waitForPaused
(
dbg
)
;
}
)
;
return
function
stepOver
(
_x4
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
stepIn
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
dbg
)
{
info
(
"
Stepping
in
"
)
;
dbg
.
actions
.
stepIn
(
)
;
return
waitForPaused
(
dbg
)
;
}
)
;
return
function
stepIn
(
_x5
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
stepOut
=
(
(
)
=
>
{
var
_ref4
=
_asyncToGenerator
(
function
*
(
dbg
)
{
info
(
"
Stepping
out
"
)
;
dbg
.
actions
.
stepOut
(
)
;
return
waitForPaused
(
dbg
)
;
}
)
;
return
function
stepOut
(
_x6
)
{
return
_ref4
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
resume
=
(
(
)
=
>
{
var
_ref5
=
_asyncToGenerator
(
function
*
(
dbg
)
{
info
(
"
Resuming
"
)
;
dbg
.
actions
.
resume
(
)
;
return
waitForThreadEvents
(
dbg
"
resumed
"
)
;
}
)
;
return
function
resume
(
_x7
)
{
return
_ref5
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
reload
=
(
(
)
=
>
{
var
_ref6
=
_asyncToGenerator
(
function
*
(
dbg
)
{
yield
dbg
.
client
.
reload
(
)
;
yield
waitForDispatch
(
dbg
"
NAVIGATE
"
)
;
for
(
var
_len
=
arguments
.
length
sources
=
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
sources
[
_key
-
1
]
=
arguments
[
_key
]
;
}
return
waitForSources
.
apply
(
undefined
[
dbg
]
.
concat
(
sources
)
)
;
}
)
;
return
function
reload
(
_x8
)
{
return
_ref6
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
navigate
=
(
(
)
=
>
{
var
_ref7
=
_asyncToGenerator
(
function
*
(
dbg
url
)
{
dbg
.
client
.
navigate
(
url
)
;
for
(
var
_len2
=
arguments
.
length
sources
=
Array
(
_len2
>
2
?
_len2
-
2
:
0
)
_key2
=
2
;
_key2
<
_len2
;
_key2
+
+
)
{
sources
[
_key2
-
2
]
=
arguments
[
_key2
]
;
}
return
waitForSources
.
apply
(
undefined
[
dbg
]
.
concat
(
sources
)
)
;
}
)
;
return
function
navigate
(
_x9
_x10
)
{
return
_ref7
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
addBreakpoint
=
(
(
)
=
>
{
var
_ref8
=
_asyncToGenerator
(
function
*
(
dbg
source
line
col
)
{
source
=
findSource
(
dbg
source
)
;
var
sourceId
=
source
.
id
;
dbg
.
actions
.
addBreakpoint
(
{
sourceId
line
col
}
)
;
return
waitForDispatch
(
dbg
"
ADD_BREAKPOINT
"
)
;
}
)
;
return
function
addBreakpoint
(
_x11
_x12
_x13
_x14
)
{
return
_ref8
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
removeBreakpoint
=
(
(
)
=
>
{
var
_ref9
=
_asyncToGenerator
(
function
*
(
dbg
sourceId
line
col
)
{
return
dbg
.
actions
.
removeBreakpoint
(
{
sourceId
line
col
}
)
;
}
)
;
return
function
removeBreakpoint
(
_x15
_x16
_x17
_x18
)
{
return
_ref9
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
disableBreakpoint
=
(
(
)
=
>
{
var
_ref10
=
_asyncToGenerator
(
function
*
(
dbg
source
line
)
{
return
dbg
.
actions
.
disableBreakpoint
(
{
sourceId
:
source
.
id
line
column
:
undefined
}
)
;
}
)
;
return
function
disableBreakpoint
(
_x19
_x20
_x21
)
{
return
_ref10
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
togglePauseOnExceptions
=
(
(
)
=
>
{
var
_ref11
=
_asyncToGenerator
(
function
*
(
dbg
pauseOnExceptions
ignoreCaughtExceptions
)
{
var
command
=
dbg
.
actions
.
pauseOnExceptions
(
pauseOnExceptions
ignoreCaughtExceptions
)
;
if
(
!
isPaused
(
dbg
)
)
{
return
waitForThreadEvents
(
dbg
"
resumed
"
)
;
}
return
command
;
}
)
;
return
function
togglePauseOnExceptions
(
_x22
_x23
_x24
)
{
return
_ref11
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
clickElement
=
(
(
)
=
>
{
var
_ref12
=
_asyncToGenerator
(
function
*
(
dbg
elementName
)
{
for
(
var
_len3
=
arguments
.
length
args
=
Array
(
_len3
>
2
?
_len3
-
2
:
0
)
_key3
=
2
;
_key3
<
_len3
;
_key3
+
+
)
{
args
[
_key3
-
2
]
=
arguments
[
_key3
]
;
}
var
selector
=
getSelector
.
apply
(
undefined
[
elementName
]
.
concat
(
args
)
)
;
var
el
=
dbg
.
win
.
document
.
querySelector
(
selector
)
;
clickEl
(
dbg
.
win
el
)
;
}
)
;
return
function
clickElement
(
_x25
_x26
)
{
return
_ref12
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
dblClickElement
=
(
(
)
=
>
{
var
_ref13
=
_asyncToGenerator
(
function
*
(
dbg
elementName
)
{
for
(
var
_len4
=
arguments
.
length
args
=
Array
(
_len4
>
2
?
_len4
-
2
:
0
)
_key4
=
2
;
_key4
<
_len4
;
_key4
+
+
)
{
args
[
_key4
-
2
]
=
arguments
[
_key4
]
;
}
var
selector
=
getSelector
.
apply
(
undefined
[
elementName
]
.
concat
(
args
)
)
;
var
el
=
dbg
.
win
.
document
.
querySelector
(
selector
)
;
dblClickEl
(
dbg
.
win
el
)
;
}
)
;
return
function
dblClickElement
(
_x27
_x28
)
{
return
_ref13
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
rightClickElement
=
(
(
)
=
>
{
var
_ref14
=
_asyncToGenerator
(
function
*
(
dbg
elementName
)
{
for
(
var
_len5
=
arguments
.
length
args
=
Array
(
_len5
>
2
?
_len5
-
2
:
0
)
_key5
=
2
;
_key5
<
_len5
;
_key5
+
+
)
{
args
[
_key5
-
2
]
=
arguments
[
_key5
]
;
}
var
selector
=
getSelector
.
apply
(
undefined
[
elementName
]
.
concat
(
args
)
)
;
var
el
=
dbg
.
win
.
document
.
querySelector
(
selector
)
;
info
(
"
right
click
on
the
gutter
"
el
)
;
rightClickEl
(
dbg
.
win
el
)
;
}
)
;
return
function
rightClickElement
(
_x29
_x30
)
{
return
_ref14
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
768
)
clickEl
=
_require
.
clickEl
rightClickEl
=
_require
.
rightClickEl
dblClickEl
=
_require
.
dblClickEl
mouseOverEl
=
_require
.
mouseOverEl
;
function
info
(
msg
)
{
console
.
log
(
info
:
{
msg
}
\
n
)
;
}
var
_require2
=
__webpack_require__
(
766
)
evalInTab
=
_require2
.
evalInTab
invokeInTab
=
_require2
.
invokeInTab
selectMenuItem
=
_require2
.
selectMenuItem
pressKey
=
_require2
.
pressKey
type
=
_require2
.
type
;
var
_require3
=
__webpack_require__
(
762
)
selectors
=
_require3
.
selectors
findSource
=
_require3
.
findSource
getSelector
=
_require3
.
getSelector
info
=
_require3
.
info
isPaused
=
_require3
.
isPaused
;
var
_require4
=
__webpack_require__
(
761
)
waitForSources
=
_require4
.
waitForSources
waitForDispatch
=
_require4
.
waitForDispatch
waitForPaused
=
_require4
.
waitForPaused
waitForThreadEvents
=
_require4
.
waitForThreadEvents
;
function
closeTab
(
dbg
url
)
{
info
(
"
Closing
tab
:
"
+
url
)
;
var
source
=
findSource
(
dbg
url
)
;
dbg
.
actions
.
closeTab
(
source
.
url
)
;
}
var
winObj
=
typeof
window
=
=
"
Object
"
?
window
:
{
}
;
winObj
.
resumeTest
=
undefined
;
function
pauseTest
(
)
{
info
(
"
Test
paused
.
Invoke
resumeTest
to
continue
.
"
)
;
return
new
Promise
(
resolve
=
>
resumeTest
=
resolve
)
;
}
module
.
exports
=
{
closeTab
selectSource
stepOver
stepIn
stepOut
resume
reload
navigate
addBreakpoint
removeBreakpoint
disableBreakpoint
togglePauseOnExceptions
clickElement
mouseOverEl
navigate
invokeInTab
evalInTab
rightClickElement
dblClickElement
selectMenuItem
type
pressKey
pauseTest
}
;
}
768
:
function
(
module
exports
)
{
"
use
strict
"
;
function
triggerMouseEvent
(
_ref
)
{
var
type
=
_ref
.
type
_ref
props
=
_ref
.
props
props
=
_ref
props
=
=
=
undefined
?
{
}
:
_ref
props
win
=
_ref
.
win
el
=
_ref
.
el
;
var
event
=
new
win
.
Event
(
type
{
view
:
win
bubbles
:
true
cancelable
:
true
}
)
;
var
rect
=
el
.
getBoundingClientRect
(
)
;
event
=
Object
.
assign
(
event
props
{
clientX
:
(
rect
.
left
+
rect
.
right
)
/
2
clientY
:
(
rect
.
top
+
rect
.
bottom
)
/
2
}
)
;
el
.
dispatchEvent
(
event
)
;
}
function
clickEl
(
win
el
)
{
triggerMouseEvent
(
{
type
:
"
mousedown
"
win
:
win
el
}
)
;
triggerMouseEvent
(
{
type
:
"
click
"
win
:
win
el
}
)
;
return
triggerMouseEvent
(
{
type
:
"
mouseup
"
win
:
win
el
}
)
;
}
function
rightClickEl
(
win
el
)
{
return
triggerMouseEvent
(
{
type
:
"
contextmenu
"
props
:
{
which
:
3
}
win
el
}
)
;
}
function
dblClickEl
(
win
el
)
{
return
triggerMouseEvent
(
{
type
:
"
dblclick
"
win
el
}
)
;
}
function
mouseOverEl
(
win
el
)
{
triggerMouseEvent
(
{
type
:
"
mouseover
"
win
:
win
el
}
)
;
}
module
.
exports
=
{
clickEl
rightClickEl
dblClickEl
mouseOverEl
}
;
}
769
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
findElement
=
_require
.
findElement
selectSource
=
_require
.
selectSource
clickElement
=
_require
.
clickElement
addBreakpoint
=
_require
.
addBreakpoint
reload
=
_require
.
reload
stepOver
=
_require
.
stepOver
invokeInTab
=
_require
.
invokeInTab
resume
=
_require
.
resume
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
setupTestRunner
=
_require
.
setupTestRunner
initDebugger
=
_require
.
initDebugger
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
scripts
.
html
"
)
;
var
getSelectedSource
=
dbg
.
selectors
.
getSelectedSource
getState
=
dbg
.
getState
;
yield
addBreakpoint
(
dbg
"
scripts
.
html
"
18
)
;
reload
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
scripts
.
html
"
18
)
;
yield
resume
(
dbg
)
;
var
paused
=
waitForPaused
(
dbg
)
;
invokeInTab
(
dbg
"
doEval
"
)
;
yield
paused
;
yield
resume
(
dbg
)
;
var
source
=
getSelectedSource
(
getState
(
)
)
.
toJS
(
)
;
ok
(
!
source
.
url
"
It
is
an
eval
source
"
)
;
yield
addBreakpoint
(
dbg
source
5
)
;
invokeInTab
(
dbg
"
evaledFunc
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
source
5
)
;
}
)
;
function
breaking
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
return
breaking
;
}
)
(
)
;
}
770
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
removeBreakpoint
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
dbg
index
)
{
var
bp
=
findElement
(
dbg
"
breakpointItem
"
index
)
;
bp
.
querySelector
(
"
.
close
-
btn
"
)
.
click
(
)
;
yield
waitForDispatch
(
dbg
"
REMOVE_BREAKPOINT
"
)
;
}
)
;
return
function
removeBreakpoint
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
disableBreakpoint
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
dbg
index
)
{
toggleBreakpoint
(
dbg
index
)
;
yield
waitForDispatch
(
dbg
"
DISABLE_BREAKPOINT
"
)
;
}
)
;
return
function
disableBreakpoint
(
_x3
_x4
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
enableBreakpoint
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
dbg
index
)
{
toggleBreakpoint
(
dbg
index
)
;
yield
waitForDispatch
(
dbg
"
ENABLE_BREAKPOINT
"
)
;
}
)
;
return
function
enableBreakpoint
(
_x5
_x6
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
toggleBreakpoints
=
(
(
)
=
>
{
var
_ref4
=
_asyncToGenerator
(
function
*
(
dbg
)
{
clickElement
(
dbg
"
toggleBreakpoints
"
)
;
yield
waitForDispatch
(
dbg
"
TOGGLE_BREAKPOINTS
"
)
;
}
)
;
return
function
toggleBreakpoints
(
_x7
)
{
return
_ref4
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
toggle
=
(
(
)
=
>
{
var
_ref5
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
simple2
"
)
;
yield
selectSource
(
dbg
"
simple2
"
)
;
yield
addBreakpoint
(
dbg
"
simple2
"
3
)
;
yield
addBreakpoint
(
dbg
"
simple2
"
5
)
;
yield
disableBreakpoint
(
dbg
1
)
;
var
bp1
=
findBreakpoint
(
dbg
"
simple2
"
3
)
;
var
bp2
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp1
.
disabled
true
"
first
breakpoint
is
disabled
"
)
;
is
(
bp2
.
disabled
false
"
second
breakpoint
is
enabled
"
)
;
yield
disableBreakpoint
(
dbg
2
)
;
yield
enableBreakpoint
(
dbg
2
)
;
bp2
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp2
.
disabled
false
"
second
breakpoint
is
enabled
"
)
;
}
)
;
return
function
toggle
(
_x8
)
{
return
_ref5
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
toggleAll
=
(
(
)
=
>
{
var
_ref6
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
)
;
yield
selectSource
(
dbg
"
simple2
"
)
;
yield
addBreakpoint
(
dbg
"
simple2
"
3
)
;
yield
addBreakpoint
(
dbg
"
simple2
"
5
)
;
yield
toggleBreakpoints
(
dbg
)
;
var
bp1
=
findBreakpoint
(
dbg
"
simple2
"
3
)
;
var
bp2
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp1
.
disabled
true
"
first
breakpoint
is
disabled
"
)
;
is
(
bp2
.
disabled
true
"
second
breakpoint
is
disabled
"
)
;
yield
toggleBreakpoints
(
dbg
)
;
bp1
=
findBreakpoint
(
dbg
"
simple2
"
3
)
;
bp2
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp1
.
disabled
false
"
first
breakpoint
is
enabled
"
)
;
is
(
bp2
.
disabled
false
"
second
breakpoint
is
enabled
"
)
;
yield
removeBreakpoint
(
dbg
1
)
;
yield
removeBreakpoint
(
dbg
1
)
;
var
bps
=
findBreakpoints
(
dbg
)
;
is
(
bps
.
size
0
"
breakpoints
are
removed
"
)
;
}
)
;
return
function
toggleAll
(
_x9
)
{
return
_ref6
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
findElement
=
_require
.
findElement
findSource
=
_require
.
findSource
selectSource
=
_require
.
selectSource
clickElement
=
_require
.
clickElement
addBreakpoint
=
_require
.
addBreakpoint
waitForDispatch
=
_require
.
waitForDispatch
;
function
toggleBreakpoint
(
dbg
index
)
{
var
bp
=
findElement
(
dbg
"
breakpointItem
"
index
)
;
var
input
=
bp
.
querySelector
(
"
input
"
)
;
input
.
click
(
)
;
}
function
findBreakpoint
(
dbg
url
line
)
{
var
getBreakpoint
=
dbg
.
selectors
.
getBreakpoint
getState
=
dbg
.
getState
;
var
source
=
findSource
(
dbg
url
)
;
return
getBreakpoint
(
getState
(
)
{
sourceId
:
source
.
id
line
}
)
;
}
function
findBreakpoints
(
dbg
)
{
var
getBreakpoints
=
dbg
.
selectors
.
getBreakpoints
getState
=
dbg
.
getState
;
return
getBreakpoints
(
getState
(
)
)
;
}
module
.
exports
=
{
toggle
toggleAll
}
;
}
771
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
setConditionalBreakpoint
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
dbg
_ref2
index
condition
)
{
var
info
=
_ref2
.
info
;
info
(
"
right
click
on
the
gutter
"
)
;
rightClickElement
(
dbg
"
gutter
"
index
)
;
selectMenuItem
(
dbg
2
)
;
yield
waitForElement
(
dbg
cbInput
)
;
var
el
=
findElementWithSelector
(
dbg
cbInput
)
;
type
(
dbg
condition
)
;
pressKey
(
dbg
"
Enter
"
)
;
}
)
;
return
function
setConditionalBreakpoint
(
_x
_x2
_x3
_x4
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
waitForPaused
=
_require
.
waitForPaused
waitForElement
=
_require
.
waitForElement
waitForDispatch
=
_require
.
waitForDispatch
findSource
=
_require
.
findSource
findElement
=
_require
.
findElement
findElementWithSelector
=
_require
.
findElementWithSelector
selectSource
=
_require
.
selectSource
clickElement
=
_require
.
clickElement
rightClickElement
=
_require
.
rightClickElement
selectMenuItem
=
_require
.
selectMenuItem
type
=
_require
.
type
pressKey
=
_require
.
pressKey
initDebugger
=
_require
.
initDebugger
;
var
cbInput
=
"
.
conditional
-
breakpoint
-
panel
input
"
;
function
findBreakpoint
(
dbg
url
line
)
{
var
getBreakpoint
=
dbg
.
selectors
.
getBreakpoint
getState
=
dbg
.
getState
;
var
source
=
findSource
(
dbg
url
)
;
return
getBreakpoint
(
getState
(
)
{
sourceId
:
source
.
id
line
}
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
simple2
"
)
;
yield
selectSource
(
dbg
"
simple2
"
)
;
info
(
"
Adding
a
conditional
Breakpoint
"
)
;
yield
setConditionalBreakpoint
(
dbg
ctx
5
"
1
"
)
;
yield
waitForDispatch
(
dbg
"
ADD_BREAKPOINT
"
)
;
var
bp
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp
.
condition
"
1
"
"
breakpoint
is
created
with
the
condition
"
)
;
info
(
"
Editing
a
conditional
Breakpoint
"
)
;
yield
setConditionalBreakpoint
(
dbg
ctx
5
"
2
"
)
;
yield
waitForDispatch
(
dbg
"
SET_BREAKPOINT_CONDITION
"
)
;
bp
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp
.
condition
"
12
"
"
breakpoint
is
created
with
the
condition
"
)
;
info
(
"
Removing
a
conditional
breakpoint
"
)
;
clickElement
(
dbg
"
gutter
"
5
)
;
yield
waitForDispatch
(
dbg
"
REMOVE_BREAKPOINT
"
)
;
bp
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp
undefined
"
breakpoint
was
removed
"
)
;
info
(
"
Adding
a
condition
to
a
breakpoint
"
)
;
clickElement
(
dbg
"
gutter
"
5
)
;
yield
waitForDispatch
(
dbg
"
ADD_BREAKPOINT
"
)
;
yield
setConditionalBreakpoint
(
dbg
ctx
5
"
1
"
)
;
bp
=
findBreakpoint
(
dbg
"
simple2
"
5
)
;
is
(
bp
.
condition
"
1
"
"
breakpoint
is
created
with
the
condition
"
)
;
}
)
;
function
breakpointsCond
(
_x5
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
return
breakpointsCond
;
}
)
(
)
;
}
772
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
test1
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
script
-
switching
.
html
"
)
;
toggleCallStack
(
dbg
)
;
var
notPaused
=
findElement
(
dbg
"
callStackBody
"
)
.
innerText
.
trim
(
)
;
is
(
notPaused
"
Not
Paused
"
"
Not
paused
message
is
shown
"
)
;
invokeInTab
(
dbg
"
firstCall
"
)
;
yield
waitForPaused
(
dbg
)
;
ok
(
isFrameSelected
(
dbg
1
"
secondCall
"
)
"
the
first
frame
is
selected
"
)
;
clickElement
(
dbg
"
frame
"
2
)
;
ok
(
isFrameSelected
(
dbg
2
"
firstCall
"
)
"
the
second
frame
is
selected
"
)
;
var
button
=
toggleButton
(
dbg
)
;
ok
(
!
button
"
toggle
button
shouldn
'
t
be
there
"
)
;
}
)
;
return
function
test1
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
test2
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
frames
.
html
"
"
frames
"
)
;
if
(
isPaused
(
dbg
)
)
{
yield
resume
(
dbg
)
;
}
toggleCallStack
(
dbg
)
;
invokeInTab
(
dbg
"
startRecursion
"
)
;
yield
waitForPaused
(
dbg
)
;
ok
(
isFrameSelected
(
dbg
1
"
recurseA
"
)
"
the
first
frame
is
selected
"
)
;
var
button
=
toggleButton
(
dbg
)
;
var
frames
=
findAllElements
(
dbg
"
frames
"
)
;
is
(
button
.
innerText
"
Expand
Rows
"
"
toggle
button
should
be
expand
"
)
;
is
(
frames
.
length
7
"
There
should
be
at
most
seven
frames
"
)
;
button
.
click
(
)
;
button
=
toggleButton
(
dbg
)
;
frames
=
findAllElements
(
dbg
"
frames
"
)
;
is
(
button
.
innerText
"
Collapse
Rows
"
"
toggle
button
should
be
collapse
"
)
;
var
frameCount
=
environment
=
=
"
mocha
"
?
23
:
22
;
is
(
frames
.
length
frameCount
"
All
of
the
frames
should
be
shown
"
)
;
}
)
;
return
function
test2
(
_x2
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
environment
=
_require
.
environment
assertPausedLocation
=
_require
.
assertPausedLocation
waitForPaused
=
_require
.
waitForPaused
invokeInTab
=
_require
.
invokeInTab
clickElement
=
_require
.
clickElement
findElement
=
_require
.
findElement
findAllElements
=
_require
.
findAllElements
isPaused
=
_require
.
isPaused
resume
=
_require
.
resume
reload
=
_require
.
reload
;
function
isFrameSelected
(
dbg
index
title
)
{
var
frame
=
findElement
(
dbg
"
frame
"
index
)
;
var
frame
=
dbg
.
selectors
.
getSelectedFrame
(
dbg
.
getState
(
)
)
;
var
elSelected
=
frame
.
classList
.
contains
(
"
selected
"
)
;
var
titleSelected
=
frame
.
displayName
=
=
title
;
return
elSelected
&
&
titleSelected
;
}
function
toggleButton
(
dbg
)
{
var
callStackBody
=
findElement
(
dbg
"
callStackBody
"
)
;
return
callStackBody
.
querySelector
(
"
.
show
-
more
"
)
;
}
function
toggleCallStack
(
dbg
)
{
return
findElement
(
dbg
"
callStackHeader
"
)
.
click
(
)
;
}
module
.
exports
=
{
test1
test2
}
;
}
773
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
addExpression
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
dbg
input
)
{
info
(
"
Adding
an
expression
"
)
;
findElementWithSelector
(
dbg
selectors
.
input
)
.
focus
(
)
;
type
(
dbg
input
)
;
pressKey
(
dbg
"
Enter
"
)
;
yield
waitForDispatch
(
dbg
"
EVALUATE_EXPRESSION
"
)
;
}
)
;
return
function
addExpression
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
editExpression
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
dbg
input
)
{
info
(
"
updating
the
expression
"
)
;
dblClickElement
(
dbg
"
expressionNode
"
1
)
;
type
(
dbg
input
)
;
pressKey
(
dbg
"
Enter
"
)
;
yield
waitForDispatch
(
dbg
"
EVALUATE_EXPRESSION
"
)
;
}
)
;
return
function
editExpression
(
_x3
_x4
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
deleteExpression
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
dbg
index
)
{
info
(
"
Deleting
the
expression
"
)
;
var
deleteExpression
=
waitForDispatch
(
dbg
"
DELETE_EXPRESSION
"
)
;
clickElement
(
dbg
"
expressionClose
"
index
)
;
yield
deleteExpression
;
}
)
;
return
function
deleteExpression
(
_x5
_x6
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
addBreakpoint
=
_require
.
addBreakpoint
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
type
=
_require
.
type
pressKey
=
_require
.
pressKey
findElementWithSelector
=
_require
.
findElementWithSelector
findElement
=
_require
.
findElement
findAllElements
=
_require
.
findAllElements
invokeInTab
=
_require
.
invokeInTab
clickElement
=
_require
.
clickElement
dblClickElement
=
_require
.
dblClickElement
;
var
selectors
=
{
input
:
"
input
.
input
-
expression
"
}
;
function
getLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
expressionNode
"
index
)
.
innerText
;
}
function
getValue
(
dbg
index
)
{
return
findElement
(
dbg
"
expressionValue
"
index
)
.
innerText
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref4
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
requestLongerTimeout
=
ctx
.
requestLongerTimeout
;
var
dbg
=
yield
initDebugger
(
"
doc
-
script
-
switching
.
html
"
)
;
invokeInTab
(
dbg
"
firstCall
"
)
;
yield
waitForPaused
(
dbg
)
;
yield
addExpression
(
dbg
"
f
"
)
;
is
(
getLabel
(
dbg
1
)
"
f
"
)
;
is
(
getValue
(
dbg
1
)
"
(
unavailable
)
"
)
;
yield
editExpression
(
dbg
"
oo
"
)
;
is
(
getLabel
(
dbg
1
)
"
foo
(
)
"
)
;
is
(
getValue
(
dbg
1
)
"
"
)
;
yield
deleteExpression
(
dbg
1
)
;
is
(
findAllElements
(
dbg
"
expressionNodes
"
)
.
length
0
)
;
}
)
;
return
function
(
_x7
)
{
return
_ref4
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
774
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
waitForPaused
=
_require
.
waitForPaused
invokeInTab
=
_require
.
invokeInTab
clickElement
=
_require
.
clickElement
findElement
=
_require
.
findElement
reload
=
_require
.
reload
;
function
clickStepOver
(
dbg
)
{
clickElement
(
dbg
"
stepOver
"
)
;
return
waitForPaused
(
dbg
)
;
}
function
clickStepIn
(
dbg
)
{
clickElement
(
dbg
"
stepIn
"
)
;
return
waitForPaused
(
dbg
)
;
}
function
clickStepOut
(
dbg
)
{
clickElement
(
dbg
"
stepOut
"
)
;
return
waitForPaused
(
dbg
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
debugger
-
statements
.
html
"
)
;
yield
reload
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
8
)
;
clickElement
(
dbg
"
resume
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
12
)
;
yield
clickStepOver
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
13
)
;
yield
clickStepIn
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
18
)
;
yield
clickStepOver
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
20
)
;
yield
clickStepOut
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
20
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
775
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
addBreakpoint
=
_require
.
addBreakpoint
waitForPaused
=
_require
.
waitForPaused
invokeInTab
=
_require
.
invokeInTab
clickElement
=
_require
.
clickElement
findElement
=
_require
.
findElement
stepIn
=
_require
.
stepIn
stepOut
=
_require
.
stepOut
resume
=
_require
.
resume
isVisibleWithin
=
_require
.
isVisibleWithin
;
function
isElementVisible
(
dbg
elementName
)
{
var
bpLine
=
findElement
(
dbg
elementName
)
;
var
cm
=
findElement
(
dbg
"
codeMirror
"
)
;
return
bpLine
&
&
isVisibleWithin
(
cm
bpLine
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
requestLongerTimeout
=
ctx
.
requestLongerTimeout
;
requestLongerTimeout
(
2
)
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
)
;
var
getSelectedSource
=
dbg
.
selectors
.
getSelectedSource
getState
=
dbg
.
getState
;
var
simple1
=
findSource
(
dbg
"
simple1
.
js
"
)
;
var
simple2
=
findSource
(
dbg
"
simple2
.
js
"
)
;
yield
addBreakpoint
(
dbg
simple1
4
)
;
ok
(
!
getSelectedSource
(
getState
(
)
)
"
No
selected
source
"
)
;
invokeInTab
(
dbg
"
main
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
simple1
4
)
;
yield
stepIn
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
simple2
2
)
;
yield
stepOut
(
dbg
)
;
yield
stepOut
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
simple1
5
)
;
yield
resume
(
dbg
)
;
var
longSrc
=
findSource
(
dbg
"
long
.
js
"
)
;
yield
addBreakpoint
(
dbg
longSrc
66
)
;
invokeInTab
(
dbg
"
testModel
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
longSrc
66
)
;
ok
(
isElementVisible
(
dbg
"
breakpoint
"
)
"
Breakpoint
is
visible
"
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
776
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
clickElement
=
_require
.
clickElement
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
selectSource
=
_require
.
selectSource
addBreakpoint
=
_require
.
addBreakpoint
assertHighlightLocation
=
_require
.
assertHighlightLocation
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
;
function
clickGutter
(
dbg
line
)
{
clickElement
(
dbg
"
gutter
"
line
)
;
}
function
getLineEl
(
dbg
line
)
{
var
lines
=
dbg
.
win
.
document
.
querySelectorAll
(
"
.
CodeMirror
-
code
>
div
"
)
;
return
lines
[
line
-
1
]
;
}
function
assertEditorBreakpoint
(
dbg
ctx
line
shouldExist
)
{
var
ok
=
ctx
.
ok
;
var
exists
=
!
!
getLineEl
(
dbg
line
)
.
querySelector
(
"
.
new
-
breakpoint
"
)
;
ok
(
exists
=
=
=
shouldExist
"
Breakpoint
"
+
(
shouldExist
?
"
exists
"
:
"
does
not
exist
"
)
+
"
on
line
"
+
line
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
)
;
var
_dbg
selectors
=
dbg
.
selectors
getBreakpoints
=
_dbg
selectors
.
getBreakpoints
getBreakpoint
=
_dbg
selectors
.
getBreakpoint
getState
=
dbg
.
getState
;
var
source
=
findSource
(
dbg
"
simple1
.
js
"
)
;
yield
selectSource
(
dbg
source
.
url
)
;
clickGutter
(
dbg
4
)
;
yield
waitForDispatch
(
dbg
"
ADD_BREAKPOINT
"
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
1
"
One
breakpoint
exists
"
)
;
assertEditorBreakpoint
(
dbg
ctx
4
true
)
;
clickGutter
(
dbg
4
)
;
yield
waitForDispatch
(
dbg
"
REMOVE_BREAKPOINT
"
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
0
"
No
breakpoints
exist
"
)
;
assertEditorBreakpoint
(
dbg
ctx
4
false
)
;
clickGutter
(
dbg
2
)
;
yield
waitForDispatch
(
dbg
"
ADD_BREAKPOINT
"
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
1
"
One
breakpoint
exists
"
)
;
ok
(
getBreakpoint
(
getState
(
)
{
sourceId
:
source
.
id
line
:
4
}
)
"
Breakpoint
has
correct
line
"
)
;
assertEditorBreakpoint
(
dbg
ctx
2
false
)
;
assertEditorBreakpoint
(
dbg
ctx
4
true
)
;
clickGutter
(
dbg
2
)
;
yield
waitForDispatch
(
dbg
"
ADD_BREAKPOINT
"
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
1
"
One
breakpoint
exists
"
)
;
assertEditorBreakpoint
(
dbg
ctx
2
false
)
;
assertEditorBreakpoint
(
dbg
ctx
4
true
)
;
clickGutter
(
dbg
4
)
;
yield
waitForDispatch
(
dbg
"
REMOVE_BREAKPOINT
"
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
0
"
No
breakpoints
exist
"
)
;
assertEditorBreakpoint
(
dbg
ctx
4
false
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
777
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
addBreakpoint
=
_require
.
addBreakpoint
assertHighlightLocation
=
_require
.
assertHighlightLocation
selectSource
=
_require
.
selectSource
findAllElements
=
_require
.
findAllElements
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
EXAMPLE_URL
=
ctx
.
EXAMPLE_URL
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
)
;
var
getSourceText
=
dbg
.
selectors
.
getSourceText
getState
=
dbg
.
getState
;
var
sourceUrl
=
EXAMPLE_URL
+
"
long
.
js
"
;
dbg
.
actions
.
selectSourceURL
(
sourceUrl
{
line
:
66
}
)
;
yield
waitForDispatch
(
dbg
"
LOAD_SOURCE_TEXT
"
)
;
yield
selectSource
(
dbg
"
long
.
js
"
16
)
;
assertHighlightLocation
(
dbg
ctx
"
long
.
js
"
16
)
;
yield
selectSource
(
dbg
"
long
.
js
"
17
)
;
yield
selectSource
(
dbg
"
long
.
js
"
18
)
;
assertHighlightLocation
(
dbg
ctx
"
long
.
js
"
18
)
;
is
(
findAllElements
(
dbg
"
highlightLine
"
)
.
length
1
"
Only
1
line
is
highlighted
"
)
;
selectSource
(
dbg
"
simple1
.
js
"
6
)
;
var
simple1
=
findSource
(
dbg
"
simple1
.
js
"
)
;
ok
(
getSourceText
(
getState
(
)
simple1
.
id
)
.
get
(
"
loading
"
)
)
;
yield
waitForDispatch
(
dbg
"
LOAD_SOURCE_TEXT
"
)
;
ok
(
getSourceText
(
getState
(
)
simple1
.
id
)
.
get
(
"
text
"
)
)
;
assertHighlightLocation
(
dbg
ctx
"
simple1
.
js
"
6
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
778
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
keyboardNavigation
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
)
;
var
doc
=
dbg
.
win
.
document
;
yield
selectSource
(
dbg
"
simple2
"
)
;
yield
waitForElement
(
dbg
"
.
CodeMirror
"
)
;
var
editor
=
findElementWithSelector
(
dbg
"
.
CodeMirror
"
)
;
var
textarea
=
findElementWithSelector
(
dbg
"
textarea
"
)
;
editor
.
focus
(
)
;
info
(
"
Enter
code
editor
"
)
;
pressKey
(
dbg
"
Enter
"
)
;
is
(
textarea
doc
.
activeElement
"
Editor
is
enabled
"
)
;
info
(
"
Exit
code
editor
and
focus
on
container
"
)
;
pressKey
(
dbg
"
Escape
"
)
;
is
(
editor
doc
.
activeElement
"
Focused
on
container
"
)
;
info
(
"
Enter
code
editor
"
)
;
pressKey
(
dbg
"
Tab
"
)
;
is
(
textarea
doc
.
activeElement
"
Editor
is
enabled
"
)
;
}
)
;
return
function
keyboardNavigation
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
waitForElement
=
_require
.
waitForElement
findElement
=
_require
.
findElement
findElementWithSelector
=
_require
.
findElementWithSelector
selectSource
=
_require
.
selectSource
pressKey
=
_require
.
pressKey
;
module
.
exports
=
keyboardNavigation
;
}
779
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
keyboardShortcuts
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
debugger
-
statements
.
html
"
)
;
yield
reload
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
8
)
;
yield
pressResume
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
12
)
;
yield
pressStepIn
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
13
)
;
yield
pressStepOut
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
14
)
;
yield
pressStepOver
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
9
)
;
}
)
;
return
function
keyboardShortcuts
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
waitForElement
=
_require
.
waitForElement
waitForPaused
=
_require
.
waitForPaused
assertPausedLocation
=
_require
.
assertPausedLocation
pressKey
=
_require
.
pressKey
reload
=
_require
.
reload
;
function
pressResume
(
dbg
)
{
pressKey
(
dbg
"
resumeKey
"
)
;
return
waitForPaused
(
dbg
)
;
}
function
pressStepOver
(
dbg
)
{
pressKey
(
dbg
"
stepOverKey
"
)
;
return
waitForPaused
(
dbg
)
;
}
function
pressStepIn
(
dbg
)
{
pressKey
(
dbg
"
stepInKey
"
)
;
return
waitForPaused
(
dbg
)
;
}
function
pressStepOut
(
dbg
)
{
pressKey
(
dbg
"
stepOutKey
"
)
;
return
waitForPaused
(
dbg
)
;
}
module
.
exports
=
keyboardShortcuts
;
}
780
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
reload
=
_require
.
reload
resume
=
_require
.
resume
waitForPaused
=
_require
.
waitForPaused
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
iframes
.
html
"
)
;
yield
reload
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
iframes
.
html
"
8
)
;
yield
resume
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
8
)
;
yield
resume
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
debugger
-
statements
.
html
"
12
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
781
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
invokeInTab
=
_require
.
invokeInTab
waitForElement
=
_require
.
waitForElement
navigate
=
_require
.
navigate
addBreakpoint
=
_require
.
addBreakpoint
selectSource
=
_require
.
selectSource
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
assertPausedLocation
=
_require
.
assertPausedLocation
reload
=
_require
.
reload
;
function
countSources
(
dbg
)
{
var
sources
=
dbg
.
selectors
.
getSources
(
dbg
.
getState
(
)
)
;
return
sources
.
size
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
script
-
switching
.
html
"
)
;
var
_dbg
selectors
=
dbg
.
selectors
getSelectedSource
=
_dbg
selectors
.
getSelectedSource
getPause
=
_dbg
selectors
.
getPause
getState
=
dbg
.
getState
;
invokeInTab
(
dbg
"
firstCall
"
)
;
yield
waitForPaused
(
dbg
)
;
yield
navigate
(
dbg
"
doc
-
scripts
.
html
"
"
simple1
.
js
"
)
;
yield
addBreakpoint
(
dbg
"
simple1
.
js
"
4
)
;
invokeInTab
(
dbg
"
main
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
simple1
.
js
"
4
)
;
is
(
countSources
(
dbg
)
4
"
4
sources
are
loaded
.
"
)
;
yield
navigate
(
dbg
"
about
:
blank
"
)
;
yield
waitForDispatch
(
dbg
"
NAVIGATE
"
)
;
is
(
countSources
(
dbg
)
0
"
0
sources
are
loaded
.
"
)
;
ok
(
!
getPause
(
getState
(
)
)
"
No
pause
state
exists
"
)
;
yield
navigate
(
dbg
"
doc
-
scripts
.
html
"
"
simple1
.
js
"
"
simple2
.
js
"
"
long
.
js
"
"
scripts
.
html
"
)
;
is
(
countSources
(
dbg
)
4
"
4
sources
are
loaded
.
"
)
;
yield
selectSource
(
dbg
"
long
.
js
"
)
;
yield
reload
(
dbg
"
long
.
js
"
)
;
ok
(
getSelectedSource
(
getState
(
)
)
.
get
(
"
url
"
)
.
includes
(
"
long
.
js
"
)
"
Selected
source
is
long
.
js
"
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
782
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
testButton
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
exceptions
.
html
"
)
;
yield
togglePauseOnExceptions
(
dbg
false
false
)
;
yield
uncaughtException
(
dbg
)
;
ok
(
!
isPaused
(
dbg
)
)
;
yield
togglePauseOnExceptions
(
dbg
true
false
)
;
uncaughtException
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
exceptions
.
js
"
2
)
;
yield
resume
(
dbg
)
;
yield
togglePauseOnExceptions
(
dbg
true
false
)
;
caughtException
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
exceptions
.
js
"
15
)
;
yield
resume
(
dbg
)
;
yield
togglePauseOnExceptions
(
dbg
true
true
)
;
caughtException
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
exceptions
.
js
"
17
)
;
yield
resume
(
dbg
)
;
}
)
;
return
function
testButton
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
testReloading
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
exceptions
.
html
"
)
;
yield
togglePauseOnExceptions
(
dbg
true
false
)
;
dbg
=
yield
initDebugger
(
"
doc
-
exceptions
.
html
"
)
;
assertPOEState
(
dbg
ctx
true
false
)
;
}
)
;
return
function
testReloading
(
_x2
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
invokeInTab
=
_require
.
invokeInTab
togglePauseOnExceptions
=
_require
.
togglePauseOnExceptions
waitForPaused
=
_require
.
waitForPaused
isPaused
=
_require
.
isPaused
resume
=
_require
.
resume
reload
=
_require
.
reload
;
function
uncaughtException
(
dbg
)
{
return
invokeInTab
(
dbg
"
uncaughtException
"
)
.
catch
(
(
)
=
>
{
}
)
;
}
function
caughtException
(
dbg
)
{
return
invokeInTab
(
dbg
"
caughtException
"
)
;
}
function
assertPOEState
(
dbg
ctx
pause
ignore
)
{
var
is
=
ctx
.
is
;
var
getState
=
dbg
.
getState
_dbg
selectors
=
dbg
.
selectors
getShouldPauseOnExceptions
=
_dbg
selectors
.
getShouldPauseOnExceptions
getShouldIgnoreCaughtExceptions
=
_dbg
selectors
.
getShouldIgnoreCaughtExceptions
;
is
(
getShouldPauseOnExceptions
(
getState
(
)
)
pause
)
;
is
(
getShouldIgnoreCaughtExceptions
(
getState
(
)
)
ignore
)
;
}
module
.
exports
=
{
testButton
testReloading
}
;
}
783
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
prettyPrint
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
;
var
dbg
=
yield
initDebugger
(
"
doc
-
minified
.
html
"
"
math
.
min
"
)
;
yield
selectSource
(
dbg
"
math
.
min
.
js
"
)
;
clickElement
(
dbg
"
prettyPrintButton
"
)
;
yield
waitForDispatch
(
dbg
"
TOGGLE_PRETTY_PRINT
"
)
;
var
ppSrc
=
findSource
(
dbg
"
math
.
min
.
js
:
formatted
"
)
;
ok
(
ppSrc
"
Pretty
-
printed
source
exists
"
)
;
yield
addBreakpoint
(
dbg
ppSrc
18
)
;
invokeInTab
(
dbg
"
arithmetic
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
ppSrc
18
)
;
yield
stepOver
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
ppSrc
27
)
;
yield
resume
(
dbg
)
;
ok
(
!
findElement
(
dbg
"
editorFooter
"
)
"
Footer
is
hidden
"
)
;
yield
selectSource
(
dbg
"
math
.
min
.
js
"
)
;
ok
(
findElement
(
dbg
"
editorFooter
"
)
"
Footer
is
hidden
"
)
;
}
)
;
return
function
prettyPrint
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
findSource
=
_require
.
findSource
findElement
=
_require
.
findElement
selectSource
=
_require
.
selectSource
clickElement
=
_require
.
clickElement
addBreakpoint
=
_require
.
addBreakpoint
stepOver
=
_require
.
stepOver
invokeInTab
=
_require
.
invokeInTab
resume
=
_require
.
resume
;
module
.
exports
=
prettyPrint
;
}
784
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
selectSource
=
_require
.
selectSource
addBreakpoint
=
_require
.
addBreakpoint
invokeInTab
=
_require
.
invokeInTab
resume
=
_require
.
resume
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
clickElement
=
_require
.
clickElement
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
minified
.
html
"
)
;
yield
selectSource
(
dbg
"
math
.
min
.
js
"
)
;
yield
addBreakpoint
(
dbg
"
math
.
min
.
js
"
2
)
;
invokeInTab
(
dbg
"
arithmetic
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
math
.
min
.
js
"
2
)
;
clickElement
(
dbg
"
prettyPrintButton
"
)
;
yield
waitForDispatch
(
dbg
"
TOGGLE_PRETTY_PRINT
"
)
;
assertPausedLocation
(
dbg
ctx
"
math
.
min
.
js
:
formatted
"
18
)
;
yield
resume
(
dbg
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
785
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
testReturnValue
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
dbg
ctx
val
)
{
var
is
=
ctx
.
is
ok
=
ctx
.
ok
;
evalInTab
(
dbg
return_something
(
{
val
}
)
)
;
yield
waitForPaused
(
dbg
)
;
yield
stepIn
(
dbg
)
;
yield
stepIn
(
dbg
)
;
yield
stepIn
(
dbg
)
;
is
(
getLabel
(
dbg
1
)
"
return_something
"
"
check
for
return_something
"
)
;
var
label
=
getLabel
(
dbg
2
)
;
if
(
val
=
=
=
"
undefined
"
)
{
ok
(
label
!
=
=
"
<
return
>
"
"
do
not
show
<
return
>
for
undefined
"
)
;
}
else
{
is
(
label
"
<
return
>
"
"
check
for
<
return
>
"
)
;
is
(
getValue
(
dbg
2
)
val
check
value
is
{
val
}
)
;
}
yield
resume
(
dbg
)
;
assertNotPaused
(
dbg
ctx
)
;
}
)
;
return
function
testReturnValue
(
_x
_x2
_x3
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
testThrowValue
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
dbg
ctx
val
)
{
var
is
=
ctx
.
is
;
evalInTab
(
dbg
throw_something
(
{
val
}
)
)
.
catch
(
function
(
)
{
}
)
;
yield
waitForPaused
(
dbg
)
;
yield
stepIn
(
dbg
)
;
is
(
getLabel
(
dbg
1
)
"
callee
"
"
check
for
callee
"
)
;
is
(
getLabel
(
dbg
2
)
"
<
exception
>
"
"
check
for
<
exception
>
"
)
;
is
(
getValue
(
dbg
2
)
val
check
exception
value
is
{
val
}
)
;
yield
resume
(
dbg
)
;
yield
waitForPaused
(
dbg
)
;
yield
resume
(
dbg
)
;
assertNotPaused
(
dbg
ctx
)
;
}
)
;
return
function
testThrowValue
(
_x4
_x5
_x6
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
evalInTab
=
_require
.
evalInTab
assertNotPaused
=
_require
.
assertNotPaused
findElement
=
_require
.
findElement
initDebugger
=
_require
.
initDebugger
togglePauseOnExceptions
=
_require
.
togglePauseOnExceptions
resume
=
_require
.
resume
stepIn
=
_require
.
stepIn
waitForPaused
=
_require
.
waitForPaused
;
function
getLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeNode
"
index
)
.
innerText
;
}
function
getValue
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeValue
"
index
)
.
innerText
;
}
function
toggleScopes
(
dbg
)
{
return
findElement
(
dbg
"
scopesHeader
"
)
.
click
(
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
return
-
values
.
html
"
)
;
toggleScopes
(
dbg
)
;
yield
togglePauseOnExceptions
(
dbg
true
false
)
;
yield
testReturnValue
(
dbg
ctx
"
57
"
)
;
yield
testThrowValue
(
dbg
ctx
"
57
"
)
;
}
)
;
return
function
(
_x7
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
786
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
expandingProperties
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
script
-
switching
.
html
"
"
script
-
switching
-
01
"
"
script
-
switching
-
02
"
)
;
toggleScopes
(
dbg
)
;
invokeInTab
(
dbg
"
firstCall
"
)
;
yield
waitForPaused
(
dbg
)
;
is
(
getLabel
(
dbg
1
)
"
secondCall
"
)
;
is
(
getLabel
(
dbg
2
)
"
<
this
>
"
)
;
is
(
getLabel
(
dbg
4
)
"
foo
(
)
"
)
;
toggleNode
(
dbg
4
)
;
yield
waitForDispatch
(
dbg
"
LOAD_OBJECT_PROPERTIES
"
)
;
is
(
getLabel
(
dbg
5
)
"
length
"
)
;
yield
stepOver
(
dbg
)
;
is
(
getLabel
(
dbg
4
)
"
foo
(
)
"
)
;
is
(
getLabel
(
dbg
5
)
"
Window
"
)
;
}
)
;
return
function
expandingProperties
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
changingScopes
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
script
-
switching
.
html
"
"
script
-
switching
-
01
"
"
script
-
switching
-
02
"
)
;
toggleScopes
(
dbg
)
;
invokeInTab
(
dbg
"
firstCall
"
)
;
yield
waitForPaused
(
dbg
)
;
clickElement
(
dbg
"
frame
"
2
)
;
is
(
getLabel
(
dbg
1
)
"
firstCall
"
)
;
is
(
getLabel
(
dbg
2
)
"
<
this
>
"
)
;
toggleNode
(
dbg
2
)
;
yield
waitForDispatch
(
dbg
"
LOAD_OBJECT_PROPERTIES
"
)
;
is
(
getLabel
(
dbg
5
)
"
CSS2Properties
(
)
"
)
;
}
)
;
return
function
changingScopes
(
_x2
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
waitForPaused
=
_require
.
waitForPaused
invokeInTab
=
_require
.
invokeInTab
evalInTab
=
_require
.
evalInTab
clickElement
=
_require
.
clickElement
findElement
=
_require
.
findElement
waitForTime
=
_require
.
waitForTime
waitForDispatch
=
_require
.
waitForDispatch
stepOver
=
_require
.
stepOver
;
function
toggleNode
(
dbg
index
)
{
clickElement
(
dbg
"
scopeNode
"
index
)
;
}
function
getLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeNode
"
index
)
.
innerText
;
}
function
toggleScopes
(
dbg
)
{
return
findElement
(
dbg
"
scopesHeader
"
)
.
click
(
)
;
}
module
.
exports
=
{
expandingProperties
changingScopes
}
;
}
787
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
waitForPaused
=
_require
.
waitForPaused
pressKey
=
_require
.
pressKey
findElementWithSelector
=
_require
.
findElementWithSelector
type
=
_require
.
type
waitForElement
=
_require
.
waitForElement
invokeInTab
=
_require
.
invokeInTab
clickElement
=
_require
.
clickElement
findElement
=
_require
.
findElement
waitForDispatch
=
_require
.
waitForDispatch
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
script
-
switching
.
html
"
)
;
pressKey
(
dbg
"
sourceSearch
"
)
;
yield
waitForElement
(
dbg
"
input
"
)
;
findElementWithSelector
(
dbg
"
input
"
)
.
focus
(
)
;
type
(
dbg
"
sw
"
)
;
pressKey
(
dbg
"
Enter
"
)
;
yield
waitForDispatch
(
dbg
"
LOAD_SOURCE_TEXT
"
)
;
var
source
=
dbg
.
selectors
.
getSelectedSource
(
dbg
.
getState
(
)
)
;
ok
(
source
.
get
(
"
url
"
)
.
match
(
/
switching
-
01
/
)
"
first
source
is
selected
"
)
;
pressKey
(
dbg
"
sourceSearch
"
)
;
findElementWithSelector
(
dbg
"
input
"
)
.
focus
(
)
;
type
(
dbg
"
sw
"
)
;
pressKey
(
dbg
"
Down
"
)
;
pressKey
(
dbg
"
Enter
"
)
;
yield
waitForDispatch
(
dbg
"
LOAD_SOURCE_TEXT
"
)
;
source
=
dbg
.
selectors
.
getSelectedSource
(
dbg
.
getState
(
)
)
;
ok
(
source
.
get
(
"
url
"
)
.
match
(
/
switching
-
02
/
)
"
second
source
is
selected
"
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
788
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
waitForSourceCount
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
dbg
i
)
{
yield
waitUntil
(
function
(
)
{
return
countSources
(
dbg
)
=
=
=
i
;
}
)
;
}
)
;
return
function
waitForSourceCount
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
environment
=
_require
.
environment
clickElement
=
_require
.
clickElement
invokeInTab
=
_require
.
invokeInTab
pressKey
=
_require
.
pressKey
selectSource
=
_require
.
selectSource
evalInTab
=
_require
.
evalInTab
findElement
=
_require
.
findElement
findAllElements
=
_require
.
findAllElements
findElementWithSelector
=
_require
.
findElementWithSelector
waitForSources
=
_require
.
waitForSources
waitForDispatch
=
_require
.
waitForDispatch
waitUntil
=
_require
.
waitUntil
waitForTime
=
_require
.
waitForTime
;
function
countSources
(
dbg
)
{
return
findAllElements
(
dbg
"
sourceNodes
"
)
.
length
;
}
function
toggleDirectory
(
dbg
index
)
{
return
clickElement
(
dbg
"
sourceArrow
"
index
)
;
}
function
clickNode
(
dbg
index
)
{
return
clickElement
(
dbg
"
sourceNode
"
index
)
;
}
function
getSourceNode
(
dbg
index
)
{
return
findElement
(
dbg
"
sourceNode
"
index
)
.
textContent
;
}
function
getFocusedNode
(
dbg
)
{
return
findElementWithSelector
(
dbg
"
.
sources
-
list
.
focused
"
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
sources
.
html
"
)
;
var
getSelectedSource
=
dbg
.
selectors
.
getSelectedSource
getState
=
dbg
.
getState
;
yield
waitForSources
(
dbg
"
simple1
"
"
simple2
"
"
nested
-
source
"
"
long
.
js
"
"
doc
-
sources
.
html
"
)
;
yield
waitForTime
(
200
)
;
is
(
countSources
(
dbg
)
2
)
;
toggleDirectory
(
dbg
2
)
;
is
(
countSources
(
dbg
)
7
)
;
toggleDirectory
(
dbg
3
)
;
is
(
countSources
(
dbg
)
8
)
;
ok
(
!
getFocusedNode
(
dbg
)
"
Source
is
not
focused
"
)
;
var
selected
=
waitForDispatch
(
dbg
"
SELECT_SOURCE
"
)
;
clickNode
(
dbg
4
)
;
yield
selected
;
ok
(
getFocusedNode
(
dbg
)
"
Source
is
focused
"
)
;
ok
(
getSelectedSource
(
getState
(
)
)
.
get
(
"
url
"
)
.
includes
(
"
nested
-
source
.
js
"
)
"
The
right
source
is
selected
"
)
;
invokeInTab
(
dbg
"
loadScript
"
)
;
yield
waitForSourceCount
(
dbg
9
)
;
is
(
getSourceNode
(
dbg
7
)
"
math
.
min
.
js
"
"
The
dynamic
script
exists
"
)
;
if
(
environment
=
=
"
mochitest
"
)
{
evalInTab
(
dbg
"
window
.
evaledFunc
=
function
(
)
{
}
/
/
#
sourceURL
=
evaled
.
js
"
)
;
yield
waitForSourceCount
(
dbg
11
)
;
is
(
findElement
(
dbg
"
sourceNode
"
2
)
.
textContent
"
evaled
.
js
"
"
The
eval
script
exists
"
)
;
}
}
)
;
return
function
(
_x3
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
789
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
waitForSources
=
_require
.
waitForSources
selectSource
=
_require
.
selectSource
addBreakpoint
=
_require
.
addBreakpoint
stepIn
=
_require
.
stepIn
stepOut
=
_require
.
stepOut
stepOver
=
_require
.
stepOver
invokeInTab
=
_require
.
invokeInTab
waitForPaused
=
_require
.
waitForPaused
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
sourcemaps
.
html
"
)
;
var
_dbg
selectors
=
dbg
.
selectors
getBreakpoint
=
_dbg
selectors
.
getBreakpoint
getBreakpoints
=
_dbg
selectors
.
getBreakpoints
getState
=
dbg
.
getState
;
yield
waitForSources
(
dbg
"
entry
.
js
"
"
output
.
js
"
"
times2
.
js
"
"
opts
.
js
"
)
;
ok
(
true
"
Original
sources
exist
"
)
;
var
entrySrc
=
findSource
(
dbg
"
entry
.
js
"
)
;
yield
selectSource
(
dbg
entrySrc
)
;
ok
(
dbg
.
win
.
cm
.
getValue
(
)
.
includes
(
"
window
.
keepMeAlive
"
)
"
Original
source
text
loaded
correctly
"
)
;
yield
addBreakpoint
(
dbg
entrySrc
13
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
1
"
One
breakpoint
exists
"
)
;
ok
(
getBreakpoint
(
getState
(
)
{
sourceId
:
entrySrc
.
id
line
:
13
}
)
"
Breakpoint
has
correct
line
"
)
;
yield
addBreakpoint
(
dbg
"
entry
.
js
"
15
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
2
"
Two
breakpoints
exist
"
)
;
ok
(
getBreakpoint
(
getState
(
)
{
sourceId
:
entrySrc
.
id
line
:
15
}
)
"
Breakpoint
has
correct
line
"
)
;
invokeInTab
(
dbg
"
keepMeAlive
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
entrySrc
15
)
;
yield
stepIn
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
times2
.
js
"
2
)
;
yield
stepOver
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
times2
.
js
"
3
)
;
yield
stepOut
(
dbg
)
;
yield
stepOut
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
entry
.
js
"
16
)
;
}
)
;
function
sourceMaps
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
return
sourceMaps
;
}
)
(
)
;
}
790
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
waitForSources
=
_require
.
waitForSources
selectSource
=
_require
.
selectSource
addBreakpoint
=
_require
.
addBreakpoint
invokeInTab
=
_require
.
invokeInTab
waitForPaused
=
_require
.
waitForPaused
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
sourcemaps2
.
html
"
)
;
var
_dbg
selectors
=
dbg
.
selectors
getBreakpoint
=
_dbg
selectors
.
getBreakpoint
getBreakpoints
=
_dbg
selectors
.
getBreakpoints
getState
=
dbg
.
getState
;
yield
waitForSources
(
dbg
"
main
.
js
"
"
main
.
min
.
js
"
)
;
ok
(
true
"
Original
sources
exist
"
)
;
var
mainSrc
=
findSource
(
dbg
"
main
.
js
"
)
;
yield
selectSource
(
dbg
mainSrc
)
;
yield
addBreakpoint
(
dbg
mainSrc
4
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
1
"
One
breakpoint
exists
"
)
;
ok
(
getBreakpoint
(
getState
(
)
{
sourceId
:
mainSrc
.
id
line
:
4
}
)
"
Breakpoint
has
correct
line
"
)
;
invokeInTab
(
dbg
"
logMessage
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
main
.
js
"
4
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
791
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
countSources
=
_require
.
countSources
assertPausedLocation
=
_require
.
assertPausedLocation
selectSource
=
_require
.
selectSource
addBreakpoint
=
_require
.
addBreakpoint
invokeInTab
=
_require
.
invokeInTab
waitForPaused
=
_require
.
waitForPaused
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
var
dbg
=
yield
initDebugger
(
"
doc
-
sourcemap
-
bogus
.
html
"
)
;
var
getSources
=
dbg
.
selectors
.
getSources
getState
=
dbg
.
getState
;
yield
selectSource
(
dbg
"
bogus
-
map
.
js
"
)
;
yield
addBreakpoint
(
dbg
"
bogus
-
map
.
js
"
4
)
;
invokeInTab
(
dbg
"
runCode
"
)
;
yield
waitForPaused
(
dbg
)
;
assertPausedLocation
(
dbg
ctx
"
bogus
-
map
.
js
"
4
)
;
is
(
countSources
(
dbg
)
1
"
Only
1
source
exists
"
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
792
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_expect
=
__webpack_require__
(
800
)
;
var
_expect2
=
_interopRequireDefault
(
_expect
)
;
var
_index
=
__webpack_require__
(
758
)
;
var
_index2
=
_interopRequireDefault
(
_index
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
__webpack_require__
(
793
)
;
var
_require
=
__webpack_require__
(
226
)
prefs
=
_require
.
prefs
;
Object
.
assign
(
window
{
prefs
}
_index2
.
default
)
;
window
.
ok
=
function
ok
(
expected
)
{
(
0
_expect2
.
default
)
(
expected
)
.
to
.
be
.
truthy
;
}
;
window
.
is
=
function
is
(
expected
actual
)
{
(
0
_expect2
.
default
)
(
expected
)
.
to
.
equal
(
actual
)
;
}
;
window
.
info
=
function
info
(
msg
)
{
console
.
log
(
info
:
{
msg
}
\
n
)
;
}
;
window
.
requestLongerTimeout
=
function
(
)
{
}
;
var
ctx
=
{
ok
is
info
requestLongerTimeout
}
;
mocha
.
setup
(
{
timeout
:
10000
ui
:
"
bdd
"
}
)
;
describe
(
"
Tests
"
(
)
=
>
{
beforeEach
(
function
(
)
{
console
.
log
(
"
TEST
START
"
this
.
currentTest
.
title
)
;
prefs
.
pauseOnExceptions
=
false
;
prefs
.
ignoreCaughtExceptions
=
false
;
prefs
.
pendingSelectedLocation
=
{
}
;
prefs
.
expressions
=
[
]
;
prefs
.
pendingBreakpoints
=
[
]
;
prefs
.
tabs
=
[
]
;
}
)
;
afterEach
(
function
(
)
{
prefs
.
pauseOnExceptions
=
false
;
prefs
.
ignoreCaughtExceptions
=
false
;
prefs
.
pendingSelectedLocation
=
{
}
;
prefs
.
expressions
=
[
]
;
prefs
.
pendingBreakpoints
=
[
]
;
prefs
.
tabs
=
[
]
;
var
err
=
this
.
currentTest
.
err
;
var
msg
=
err
?
"
FAILURE
"
:
"
SUCCESS
"
;
console
.
log
(
TEST
{
msg
}
this
.
currentTest
.
title
)
;
if
(
err
)
{
console
.
log
(
err
.
message
)
;
console
.
log
(
err
.
stack
)
;
}
}
)
;
it
(
"
asm
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
asm
(
ctx
)
;
}
)
)
;
describe
(
"
breakpoints
"
(
)
=
>
{
it
(
"
breakpoints
-
toggle
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
breakpoints
.
toggle
(
ctx
)
;
}
)
)
;
it
(
"
breakpoints
-
toggleAll
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
breakpoints
.
toggleAll
(
ctx
)
;
}
)
)
;
it
(
"
breaking
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
breaking
(
ctx
)
;
}
)
)
;
it
(
"
conditional
breakpoints
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
breakpointsCond
(
ctx
)
;
}
)
)
;
}
)
;
it
(
"
expressions
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
expressions
(
ctx
)
;
}
)
)
;
describe
(
"
editor
"
(
)
=
>
{
it
(
"
editor
select
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
editorSelect
(
ctx
)
;
}
)
)
;
it
(
"
editor
gutter
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
editorGutter
(
ctx
)
;
}
)
)
;
xit
(
"
editor
highlight
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
editorHighlight
(
ctx
)
;
}
)
)
;
xit
(
"
editor
preview
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
editorPreview
(
ctx
)
;
}
)
)
;
}
)
;
xit
(
"
keyboard
navigation
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
keyboardNavigation
(
ctx
)
;
}
)
)
;
xit
(
"
keyboard
shortcuts
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
keyboardShortcuts
(
ctx
)
;
}
)
)
;
xit
(
"
navigation
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
navigation
(
ctx
)
;
}
)
)
;
describe
(
"
call
stack
"
(
)
=
>
{
it
(
"
test
1
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
callStack
.
test1
(
ctx
)
;
}
)
)
;
it
(
"
test
2
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
callStack
.
test2
(
ctx
)
;
}
)
)
;
}
)
;
it
(
"
debugger
buttons
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
debuggerButtons
(
ctx
)
;
}
)
)
;
it
(
"
iframes
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
iframes
(
ctx
)
;
}
)
)
;
it
(
"
pause
on
exceptions
-
button
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
pauseOnExceptions
.
testButton
(
ctx
)
;
}
)
)
;
it
(
"
pause
on
exceptions
-
reloading
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
pauseOnExceptions
.
testReloading
(
ctx
)
;
}
)
)
;
it
(
"
pretty
print
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
prettyPrint
(
ctx
)
;
}
)
)
;
it
(
"
pretty
print
paused
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
prettyPrintPaused
(
ctx
)
;
}
)
)
;
it
(
"
returnvalues
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
returnvalues
(
ctx
)
;
}
)
)
;
xit
(
"
searching
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
searching
(
ctx
)
;
}
)
)
;
it
(
"
scopes
-
expanding
properties
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
scopes
.
expandingProperties
(
ctx
)
;
}
)
)
;
it
(
"
scopes
-
changing
scopes
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
scopes
.
changingScopes
(
ctx
)
;
}
)
)
;
it
(
"
render
the
expected
scopes
when
variable
mutates
while
stepping
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
scopesMutations
(
ctx
)
;
}
)
)
;
it
(
"
sources
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
sources
(
ctx
)
;
}
)
)
;
describe
(
"
source
maps
"
(
)
=
>
{
it
(
"
stepping
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
sourceMaps
(
ctx
)
;
}
)
)
;
it
(
"
reloading
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
sourceMapsReloading
(
ctx
)
;
}
)
)
;
it
(
"
source
maps
2
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
sourceMaps2
(
ctx
)
;
}
)
)
;
it
(
"
source
maps
bogus
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
sourceMapsBogus
(
ctx
)
;
}
)
)
;
}
)
;
describe
(
"
tabs
"
(
)
=
>
{
it
(
"
add
tabs
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
tabs
.
addTabs
(
ctx
)
;
}
)
)
;
it
(
"
reload
with
tabs
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
tabs
.
reloadWithTabs
(
ctx
)
;
}
)
)
;
it
(
"
reload
with
no
tabs
"
_asyncToGenerator
(
function
*
(
)
{
return
yield
tabs
.
reloadWithNoTabs
(
ctx
)
;
}
)
)
;
}
)
;
}
)
;
mocha
.
run
(
failures
=
>
{
console
.
log
(
"
WERE
DON
"
failures
)
;
}
)
;
}
793
:
function
(
module
exports
)
{
(
function
e
(
t
n
r
)
{
function
s
(
o
u
)
{
if
(
!
n
[
o
]
)
{
if
(
!
t
[
o
]
)
{
var
a
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
u
&
&
a
)
return
a
(
o
!
0
)
;
if
(
i
)
return
i
(
o
!
0
)
;
var
f
=
new
Error
(
"
Cannot
find
module
'
"
+
o
+
"
'
"
)
;
throw
f
.
code
=
"
MODULE_NOT_FOUND
"
f
}
var
l
=
n
[
o
]
=
{
exports
:
{
}
}
;
t
[
o
]
[
0
]
.
call
(
l
.
exports
function
(
e
)
{
var
n
=
t
[
o
]
[
1
]
[
e
]
;
return
s
(
n
?
n
:
e
)
}
l
l
.
exports
e
t
n
r
)
}
return
n
[
o
]
.
exports
}
var
i
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
o
=
0
;
o
<
r
.
length
;
o
+
+
)
s
(
r
[
o
]
)
;
return
s
}
)
(
{
1
:
[
function
(
require
module
exports
)
{
(
function
(
process
global
)
{
'
use
strict
'
;
process
.
stdout
=
require
(
'
browser
-
stdout
'
)
(
)
;
var
Mocha
=
require
(
'
.
/
lib
/
mocha
'
)
;
var
mocha
=
new
Mocha
(
{
reporter
:
'
html
'
}
)
;
var
Date
=
global
.
Date
;
var
setTimeout
=
global
.
setTimeout
;
var
setInterval
=
global
.
setInterval
;
var
clearTimeout
=
global
.
clearTimeout
;
var
clearInterval
=
global
.
clearInterval
;
var
uncaughtExceptionHandlers
=
[
]
;
var
originalOnerrorHandler
=
global
.
onerror
;
process
.
removeListener
=
function
(
e
fn
)
{
if
(
e
=
=
=
'
uncaughtException
'
)
{
if
(
originalOnerrorHandler
)
{
global
.
onerror
=
originalOnerrorHandler
;
}
else
{
global
.
onerror
=
function
(
)
{
}
;
}
var
i
=
Mocha
.
utils
.
indexOf
(
uncaughtExceptionHandlers
fn
)
;
if
(
i
!
=
=
-
1
)
{
uncaughtExceptionHandlers
.
splice
(
i
1
)
;
}
}
}
;
process
.
on
=
function
(
e
fn
)
{
if
(
e
=
=
=
'
uncaughtException
'
)
{
global
.
onerror
=
function
(
err
url
line
)
{
fn
(
new
Error
(
err
+
'
(
'
+
url
+
'
:
'
+
line
+
'
)
'
)
)
;
return
!
mocha
.
allowUncaught
;
}
;
uncaughtExceptionHandlers
.
push
(
fn
)
;
}
}
;
mocha
.
suite
.
removeAllListeners
(
'
pre
-
require
'
)
;
var
immediateQueue
=
[
]
;
var
immediateTimeout
;
function
timeslice
(
)
{
var
immediateStart
=
new
Date
(
)
.
getTime
(
)
;
while
(
immediateQueue
.
length
&
&
(
new
Date
(
)
.
getTime
(
)
-
immediateStart
)
<
100
)
{
immediateQueue
.
shift
(
)
(
)
;
}
if
(
immediateQueue
.
length
)
{
immediateTimeout
=
setTimeout
(
timeslice
0
)
;
}
else
{
immediateTimeout
=
null
;
}
}
Mocha
.
Runner
.
immediately
=
function
(
callback
)
{
immediateQueue
.
push
(
callback
)
;
if
(
!
immediateTimeout
)
{
immediateTimeout
=
setTimeout
(
timeslice
0
)
;
}
}
;
mocha
.
throwError
=
function
(
err
)
{
Mocha
.
utils
.
forEach
(
uncaughtExceptionHandlers
function
(
fn
)
{
fn
(
err
)
;
}
)
;
throw
err
;
}
;
mocha
.
ui
=
function
(
ui
)
{
Mocha
.
prototype
.
ui
.
call
(
this
ui
)
;
this
.
suite
.
emit
(
'
pre
-
require
'
global
null
this
)
;
return
this
;
}
;
mocha
.
setup
=
function
(
opts
)
{
if
(
typeof
opts
=
=
=
'
string
'
)
{
opts
=
{
ui
:
opts
}
;
}
for
(
var
opt
in
opts
)
{
if
(
opts
.
hasOwnProperty
(
opt
)
)
{
this
[
opt
]
(
opts
[
opt
]
)
;
}
}
return
this
;
}
;
mocha
.
run
=
function
(
fn
)
{
var
options
=
mocha
.
options
;
mocha
.
globals
(
'
location
'
)
;
var
query
=
Mocha
.
utils
.
parseQuery
(
global
.
location
.
search
|
|
'
'
)
;
if
(
query
.
grep
)
{
mocha
.
grep
(
query
.
grep
)
;
}
if
(
query
.
fgrep
)
{
mocha
.
fgrep
(
query
.
fgrep
)
;
}
if
(
query
.
invert
)
{
mocha
.
invert
(
)
;
}
return
Mocha
.
prototype
.
run
.
call
(
mocha
function
(
err
)
{
var
document
=
global
.
document
;
if
(
document
&
&
document
.
getElementById
(
'
mocha
'
)
&
&
options
.
noHighlighting
!
=
=
true
)
{
Mocha
.
utils
.
highlightTags
(
'
code
'
)
;
}
if
(
fn
)
{
fn
(
err
)
;
}
}
)
;
}
;
Mocha
.
process
=
process
;
global
.
Mocha
=
Mocha
;
global
.
mocha
=
mocha
;
module
.
exports
=
global
;
}
)
.
call
(
this
require
(
'
_process
'
)
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
.
/
lib
/
mocha
"
:
14
"
_process
"
:
82
"
browser
-
stdout
"
:
41
}
]
2
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
function
noop
(
)
{
}
module
.
exports
=
function
(
)
{
return
noop
;
}
;
}
{
}
]
3
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
EventEmitter
=
EventEmitter
;
var
objToString
=
Object
.
prototype
.
toString
;
function
isArray
(
val
)
{
return
objToString
.
call
(
val
)
=
=
=
'
[
object
Array
]
'
;
}
function
EventEmitter
(
)
{
}
EventEmitter
.
prototype
.
on
=
function
(
name
fn
)
{
if
(
!
this
.
events
)
{
this
.
events
=
{
}
;
}
if
(
!
this
.
events
[
name
]
)
{
this
.
events
[
name
]
=
fn
;
}
else
if
(
isArray
(
this
.
events
[
name
]
)
)
{
this
.
events
[
name
]
.
push
(
fn
)
;
}
else
{
this
.
events
[
name
]
=
[
this
.
events
[
name
]
fn
]
;
}
return
this
;
}
;
EventEmitter
.
prototype
.
addListener
=
EventEmitter
.
prototype
.
on
;
EventEmitter
.
prototype
.
once
=
function
(
name
fn
)
{
var
self
=
this
;
function
on
(
)
{
self
.
removeListener
(
name
on
)
;
fn
.
apply
(
this
arguments
)
;
}
on
.
listener
=
fn
;
this
.
on
(
name
on
)
;
return
this
;
}
;
EventEmitter
.
prototype
.
removeListener
=
function
(
name
fn
)
{
if
(
this
.
events
&
&
this
.
events
[
name
]
)
{
var
list
=
this
.
events
[
name
]
;
if
(
isArray
(
list
)
)
{
var
pos
=
-
1
;
for
(
var
i
=
0
l
=
list
.
length
;
i
<
l
;
i
+
+
)
{
if
(
list
[
i
]
=
=
=
fn
|
|
(
list
[
i
]
.
listener
&
&
list
[
i
]
.
listener
=
=
=
fn
)
)
{
pos
=
i
;
break
;
}
}
if
(
pos
<
0
)
{
return
this
;
}
list
.
splice
(
pos
1
)
;
if
(
!
list
.
length
)
{
delete
this
.
events
[
name
]
;
}
}
else
if
(
list
=
=
=
fn
|
|
(
list
.
listener
&
&
list
.
listener
=
=
=
fn
)
)
{
delete
this
.
events
[
name
]
;
}
}
return
this
;
}
;
EventEmitter
.
prototype
.
removeAllListeners
=
function
(
name
)
{
if
(
name
=
=
=
undefined
)
{
this
.
events
=
{
}
;
return
this
;
}
if
(
this
.
events
&
&
this
.
events
[
name
]
)
{
this
.
events
[
name
]
=
null
;
}
return
this
;
}
;
EventEmitter
.
prototype
.
listeners
=
function
(
name
)
{
if
(
!
this
.
events
)
{
this
.
events
=
{
}
;
}
if
(
!
this
.
events
[
name
]
)
{
this
.
events
[
name
]
=
[
]
;
}
if
(
!
isArray
(
this
.
events
[
name
]
)
)
{
this
.
events
[
name
]
=
[
this
.
events
[
name
]
]
;
}
return
this
.
events
[
name
]
;
}
;
EventEmitter
.
prototype
.
emit
=
function
(
name
)
{
if
(
!
this
.
events
)
{
return
false
;
}
var
handler
=
this
.
events
[
name
]
;
if
(
!
handler
)
{
return
false
;
}
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
if
(
typeof
handler
=
=
=
'
function
'
)
{
handler
.
apply
(
this
args
)
;
}
else
if
(
isArray
(
handler
)
)
{
var
listeners
=
handler
.
slice
(
)
;
for
(
var
i
=
0
l
=
listeners
.
length
;
i
<
l
;
i
+
+
)
{
listeners
[
i
]
.
apply
(
this
args
)
;
}
}
else
{
return
false
;
}
return
true
;
}
;
}
{
}
]
4
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
Progress
;
function
Progress
(
)
{
this
.
percent
=
0
;
this
.
size
(
0
)
;
this
.
fontSize
(
11
)
;
this
.
font
(
'
helvetica
arial
sans
-
serif
'
)
;
}
Progress
.
prototype
.
size
=
function
(
size
)
{
this
.
_size
=
size
;
return
this
;
}
;
Progress
.
prototype
.
text
=
function
(
text
)
{
this
.
_text
=
text
;
return
this
;
}
;
Progress
.
prototype
.
fontSize
=
function
(
size
)
{
this
.
_fontSize
=
size
;
return
this
;
}
;
Progress
.
prototype
.
font
=
function
(
family
)
{
this
.
_font
=
family
;
return
this
;
}
;
Progress
.
prototype
.
update
=
function
(
n
)
{
this
.
percent
=
n
;
return
this
;
}
;
Progress
.
prototype
.
draw
=
function
(
ctx
)
{
try
{
var
percent
=
Math
.
min
(
this
.
percent
100
)
;
var
size
=
this
.
_size
;
var
half
=
size
/
2
;
var
x
=
half
;
var
y
=
half
;
var
rad
=
half
-
1
;
var
fontSize
=
this
.
_fontSize
;
ctx
.
font
=
fontSize
+
'
px
'
+
this
.
_font
;
var
angle
=
Math
.
PI
*
2
*
(
percent
/
100
)
;
ctx
.
clearRect
(
0
0
size
size
)
;
ctx
.
strokeStyle
=
'
#
9f9f9f
'
;
ctx
.
beginPath
(
)
;
ctx
.
arc
(
x
y
rad
0
angle
false
)
;
ctx
.
stroke
(
)
;
ctx
.
strokeStyle
=
'
#
eee
'
;
ctx
.
beginPath
(
)
;
ctx
.
arc
(
x
y
rad
-
1
0
angle
true
)
;
ctx
.
stroke
(
)
;
var
text
=
this
.
_text
|
|
(
percent
|
0
)
+
'
%
'
;
var
w
=
ctx
.
measureText
(
text
)
.
width
;
ctx
.
fillText
(
text
x
-
w
/
2
+
1
y
+
fontSize
/
2
-
1
)
;
}
catch
(
err
)
{
}
return
this
;
}
;
}
{
}
]
5
:
[
function
(
require
module
exports
)
{
(
function
(
global
)
{
'
use
strict
'
;
exports
.
isatty
=
function
isatty
(
)
{
return
true
;
}
;
exports
.
getWindowSize
=
function
getWindowSize
(
)
{
if
(
'
innerHeight
'
in
global
)
{
return
[
global
.
innerHeight
global
.
innerWidth
]
;
}
return
[
640
480
]
;
}
;
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
}
]
6
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
JSON
=
require
(
'
json3
'
)
;
module
.
exports
=
Context
;
function
Context
(
)
{
}
Context
.
prototype
.
runnable
=
function
(
runnable
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_runnable
;
}
this
.
test
=
this
.
_runnable
=
runnable
;
return
this
;
}
;
Context
.
prototype
.
timeout
=
function
(
ms
)
{
if
(
!
arguments
.
length
)
{
return
this
.
runnable
(
)
.
timeout
(
)
;
}
this
.
runnable
(
)
.
timeout
(
ms
)
;
return
this
;
}
;
Context
.
prototype
.
enableTimeouts
=
function
(
enabled
)
{
this
.
runnable
(
)
.
enableTimeouts
(
enabled
)
;
return
this
;
}
;
Context
.
prototype
.
slow
=
function
(
ms
)
{
this
.
runnable
(
)
.
slow
(
ms
)
;
return
this
;
}
;
Context
.
prototype
.
skip
=
function
(
)
{
this
.
runnable
(
)
.
skip
(
)
;
return
this
;
}
;
Context
.
prototype
.
retries
=
function
(
n
)
{
if
(
!
arguments
.
length
)
{
return
this
.
runnable
(
)
.
retries
(
)
;
}
this
.
runnable
(
)
.
retries
(
n
)
;
return
this
;
}
;
Context
.
prototype
.
inspect
=
function
(
)
{
return
JSON
.
stringify
(
this
function
(
key
val
)
{
return
key
=
=
=
'
runnable
'
|
|
key
=
=
=
'
test
'
?
undefined
:
val
;
}
2
)
;
}
;
}
{
"
json3
"
:
69
}
]
7
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Runnable
=
require
(
'
.
/
runnable
'
)
;
var
inherits
=
require
(
'
.
/
utils
'
)
.
inherits
;
module
.
exports
=
Hook
;
function
Hook
(
title
fn
)
{
Runnable
.
call
(
this
title
fn
)
;
this
.
type
=
'
hook
'
;
}
inherits
(
Hook
Runnable
)
;
Hook
.
prototype
.
error
=
function
(
err
)
{
if
(
!
arguments
.
length
)
{
err
=
this
.
_error
;
this
.
_error
=
null
;
return
err
;
}
this
.
_error
=
err
;
}
;
}
{
"
.
/
runnable
"
:
33
"
.
/
utils
"
:
38
}
]
8
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Test
=
require
(
'
.
.
/
test
'
)
;
module
.
exports
=
function
(
suite
)
{
var
suites
=
[
suite
]
;
suite
.
on
(
'
pre
-
require
'
function
(
context
file
mocha
)
{
var
common
=
require
(
'
.
/
common
'
)
(
suites
context
mocha
)
;
context
.
before
=
common
.
before
;
context
.
after
=
common
.
after
;
context
.
beforeEach
=
common
.
beforeEach
;
context
.
afterEach
=
common
.
afterEach
;
context
.
run
=
mocha
.
options
.
delay
&
&
common
.
runWithSuite
(
suite
)
;
context
.
describe
=
context
.
context
=
function
(
title
fn
)
{
return
common
.
suite
.
create
(
{
title
:
title
file
:
file
fn
:
fn
}
)
;
}
;
context
.
xdescribe
=
context
.
xcontext
=
context
.
describe
.
skip
=
function
(
title
fn
)
{
return
common
.
suite
.
skip
(
{
title
:
title
file
:
file
fn
:
fn
}
)
;
}
;
context
.
describe
.
only
=
function
(
title
fn
)
{
return
common
.
suite
.
only
(
{
title
:
title
file
:
file
fn
:
fn
}
)
;
}
;
context
.
it
=
context
.
specify
=
function
(
title
fn
)
{
var
suite
=
suites
[
0
]
;
if
(
suite
.
isPending
(
)
)
{
fn
=
null
;
}
var
test
=
new
Test
(
title
fn
)
;
test
.
file
=
file
;
suite
.
addTest
(
test
)
;
return
test
;
}
;
context
.
it
.
only
=
function
(
title
fn
)
{
return
common
.
test
.
only
(
mocha
context
.
it
(
title
fn
)
)
;
}
;
context
.
xit
=
context
.
xspecify
=
context
.
it
.
skip
=
function
(
title
)
{
context
.
it
(
title
)
;
}
;
context
.
it
.
retries
=
function
(
n
)
{
context
.
retries
(
n
)
;
}
;
}
)
;
}
;
}
{
"
.
.
/
test
"
:
36
"
.
/
common
"
:
9
}
]
9
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Suite
=
require
(
'
.
.
/
suite
'
)
;
module
.
exports
=
function
(
suites
context
mocha
)
{
return
{
runWithSuite
:
function
runWithSuite
(
suite
)
{
return
function
run
(
)
{
suite
.
run
(
)
;
}
;
}
before
:
function
(
name
fn
)
{
suites
[
0
]
.
beforeAll
(
name
fn
)
;
}
after
:
function
(
name
fn
)
{
suites
[
0
]
.
afterAll
(
name
fn
)
;
}
beforeEach
:
function
(
name
fn
)
{
suites
[
0
]
.
beforeEach
(
name
fn
)
;
}
afterEach
:
function
(
name
fn
)
{
suites
[
0
]
.
afterEach
(
name
fn
)
;
}
suite
:
{
only
:
function
only
(
opts
)
{
mocha
.
options
.
hasOnly
=
true
;
opts
.
isOnly
=
true
;
return
this
.
create
(
opts
)
;
}
skip
:
function
skip
(
opts
)
{
opts
.
pending
=
true
;
return
this
.
create
(
opts
)
;
}
create
:
function
create
(
opts
)
{
var
suite
=
Suite
.
create
(
suites
[
0
]
opts
.
title
)
;
suite
.
pending
=
Boolean
(
opts
.
pending
)
;
suite
.
file
=
opts
.
file
;
suites
.
unshift
(
suite
)
;
if
(
opts
.
isOnly
)
{
suite
.
parent
.
_onlySuites
=
suite
.
parent
.
_onlySuites
.
concat
(
suite
)
;
mocha
.
options
.
hasOnly
=
true
;
}
if
(
typeof
opts
.
fn
=
=
=
'
function
'
)
{
opts
.
fn
.
call
(
suite
)
;
suites
.
shift
(
)
;
}
else
if
(
typeof
opts
.
fn
=
=
=
'
undefined
'
&
&
!
suite
.
pending
)
{
throw
new
Error
(
'
Suite
"
'
+
suite
.
fullTitle
(
)
+
'
"
was
defined
but
no
callback
was
supplied
.
Supply
a
callback
or
explicitly
skip
the
suite
.
'
)
;
}
return
suite
;
}
}
test
:
{
only
:
function
(
mocha
test
)
{
test
.
parent
.
_onlyTests
=
test
.
parent
.
_onlyTests
.
concat
(
test
)
;
mocha
.
options
.
hasOnly
=
true
;
return
test
;
}
skip
:
function
(
title
)
{
context
.
test
(
title
)
;
}
retries
:
function
(
n
)
{
context
.
retries
(
n
)
;
}
}
}
;
}
;
}
{
"
.
.
/
suite
"
:
35
}
]
10
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Suite
=
require
(
'
.
.
/
suite
'
)
;
var
Test
=
require
(
'
.
.
/
test
'
)
;
module
.
exports
=
function
(
suite
)
{
var
suites
=
[
suite
]
;
suite
.
on
(
'
require
'
visit
)
;
function
visit
(
obj
file
)
{
var
suite
;
for
(
var
key
in
obj
)
{
if
(
typeof
obj
[
key
]
=
=
=
'
function
'
)
{
var
fn
=
obj
[
key
]
;
switch
(
key
)
{
case
'
before
'
:
suites
[
0
]
.
beforeAll
(
fn
)
;
break
;
case
'
after
'
:
suites
[
0
]
.
afterAll
(
fn
)
;
break
;
case
'
beforeEach
'
:
suites
[
0
]
.
beforeEach
(
fn
)
;
break
;
case
'
afterEach
'
:
suites
[
0
]
.
afterEach
(
fn
)
;
break
;
default
:
var
test
=
new
Test
(
key
fn
)
;
test
.
file
=
file
;
suites
[
0
]
.
addTest
(
test
)
;
}
}
else
{
suite
=
Suite
.
create
(
suites
[
0
]
key
)
;
suites
.
unshift
(
suite
)
;
visit
(
obj
[
key
]
file
)
;
suites
.
shift
(
)
;
}
}
}
}
;
}
{
"
.
.
/
suite
"
:
35
"
.
.
/
test
"
:
36
}
]
11
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
bdd
=
require
(
'
.
/
bdd
'
)
;
exports
.
tdd
=
require
(
'
.
/
tdd
'
)
;
exports
.
qunit
=
require
(
'
.
/
qunit
'
)
;
exports
.
exports
=
require
(
'
.
/
exports
'
)
;
}
{
"
.
/
bdd
"
:
8
"
.
/
exports
"
:
10
"
.
/
qunit
"
:
12
"
.
/
tdd
"
:
13
}
]
12
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Test
=
require
(
'
.
.
/
test
'
)
;
module
.
exports
=
function
(
suite
)
{
var
suites
=
[
suite
]
;
suite
.
on
(
'
pre
-
require
'
function
(
context
file
mocha
)
{
var
common
=
require
(
'
.
/
common
'
)
(
suites
context
mocha
)
;
context
.
before
=
common
.
before
;
context
.
after
=
common
.
after
;
context
.
beforeEach
=
common
.
beforeEach
;
context
.
afterEach
=
common
.
afterEach
;
context
.
run
=
mocha
.
options
.
delay
&
&
common
.
runWithSuite
(
suite
)
;
context
.
suite
=
function
(
title
)
{
if
(
suites
.
length
>
1
)
{
suites
.
shift
(
)
;
}
return
common
.
suite
.
create
(
{
title
:
title
file
:
file
fn
:
false
}
)
;
}
;
context
.
suite
.
only
=
function
(
title
)
{
if
(
suites
.
length
>
1
)
{
suites
.
shift
(
)
;
}
return
common
.
suite
.
only
(
{
title
:
title
file
:
file
fn
:
false
}
)
;
}
;
context
.
test
=
function
(
title
fn
)
{
var
test
=
new
Test
(
title
fn
)
;
test
.
file
=
file
;
suites
[
0
]
.
addTest
(
test
)
;
return
test
;
}
;
context
.
test
.
only
=
function
(
title
fn
)
{
return
common
.
test
.
only
(
mocha
context
.
test
(
title
fn
)
)
;
}
;
context
.
test
.
skip
=
common
.
test
.
skip
;
context
.
test
.
retries
=
common
.
test
.
retries
;
}
)
;
}
;
}
{
"
.
.
/
test
"
:
36
"
.
/
common
"
:
9
}
]
13
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Test
=
require
(
'
.
.
/
test
'
)
;
module
.
exports
=
function
(
suite
)
{
var
suites
=
[
suite
]
;
suite
.
on
(
'
pre
-
require
'
function
(
context
file
mocha
)
{
var
common
=
require
(
'
.
/
common
'
)
(
suites
context
mocha
)
;
context
.
setup
=
common
.
beforeEach
;
context
.
teardown
=
common
.
afterEach
;
context
.
suiteSetup
=
common
.
before
;
context
.
suiteTeardown
=
common
.
after
;
context
.
run
=
mocha
.
options
.
delay
&
&
common
.
runWithSuite
(
suite
)
;
context
.
suite
=
function
(
title
fn
)
{
return
common
.
suite
.
create
(
{
title
:
title
file
:
file
fn
:
fn
}
)
;
}
;
context
.
suite
.
skip
=
function
(
title
fn
)
{
return
common
.
suite
.
skip
(
{
title
:
title
file
:
file
fn
:
fn
}
)
;
}
;
context
.
suite
.
only
=
function
(
title
fn
)
{
return
common
.
suite
.
only
(
{
title
:
title
file
:
file
fn
:
fn
}
)
;
}
;
context
.
test
=
function
(
title
fn
)
{
var
suite
=
suites
[
0
]
;
if
(
suite
.
isPending
(
)
)
{
fn
=
null
;
}
var
test
=
new
Test
(
title
fn
)
;
test
.
file
=
file
;
suite
.
addTest
(
test
)
;
return
test
;
}
;
context
.
test
.
only
=
function
(
title
fn
)
{
return
common
.
test
.
only
(
mocha
context
.
test
(
title
fn
)
)
;
}
;
context
.
test
.
skip
=
common
.
test
.
skip
;
context
.
test
.
retries
=
common
.
test
.
retries
;
}
)
;
}
;
}
{
"
.
.
/
test
"
:
36
"
.
/
common
"
:
9
}
]
14
:
[
function
(
require
module
exports
)
{
(
function
(
process
global
__dirname
)
{
'
use
strict
'
;
var
escapeRe
=
require
(
'
escape
-
string
-
regexp
'
)
;
var
path
=
require
(
'
path
'
)
;
var
reporters
=
require
(
'
.
/
reporters
'
)
;
var
utils
=
require
(
'
.
/
utils
'
)
;
exports
=
module
.
exports
=
Mocha
;
if
(
!
process
.
browser
)
{
var
cwd
=
process
.
cwd
(
)
;
module
.
paths
.
push
(
cwd
path
.
join
(
cwd
'
node_modules
'
)
)
;
}
exports
.
utils
=
utils
;
exports
.
interfaces
=
require
(
'
.
/
interfaces
'
)
;
exports
.
reporters
=
reporters
;
exports
.
Runnable
=
require
(
'
.
/
runnable
'
)
;
exports
.
Context
=
require
(
'
.
/
context
'
)
;
exports
.
Runner
=
require
(
'
.
/
runner
'
)
;
exports
.
Suite
=
require
(
'
.
/
suite
'
)
;
exports
.
Hook
=
require
(
'
.
/
hook
'
)
;
exports
.
Test
=
require
(
'
.
/
test
'
)
;
function
image
(
name
)
{
return
path
.
join
(
__dirname
'
.
.
/
images
'
name
+
'
.
png
'
)
;
}
function
Mocha
(
options
)
{
options
=
options
|
|
{
}
;
this
.
files
=
[
]
;
this
.
options
=
options
;
if
(
options
.
grep
)
{
this
.
grep
(
new
RegExp
(
options
.
grep
)
)
;
}
if
(
options
.
fgrep
)
{
this
.
fgrep
(
options
.
fgrep
)
;
}
this
.
suite
=
new
exports
.
Suite
(
'
'
new
exports
.
Context
(
)
)
;
this
.
ui
(
options
.
ui
)
;
this
.
bail
(
options
.
bail
)
;
this
.
reporter
(
options
.
reporter
options
.
reporterOptions
)
;
if
(
typeof
options
.
timeout
!
=
=
'
undefined
'
&
&
options
.
timeout
!
=
=
null
)
{
this
.
timeout
(
options
.
timeout
)
;
}
if
(
typeof
options
.
retries
!
=
=
'
undefined
'
&
&
options
.
retries
!
=
=
null
)
{
this
.
retries
(
options
.
retries
)
;
}
this
.
useColors
(
options
.
useColors
)
;
if
(
options
.
enableTimeouts
!
=
=
null
)
{
this
.
enableTimeouts
(
options
.
enableTimeouts
)
;
}
if
(
options
.
slow
)
{
this
.
slow
(
options
.
slow
)
;
}
}
Mocha
.
prototype
.
bail
=
function
(
bail
)
{
if
(
!
arguments
.
length
)
{
bail
=
true
;
}
this
.
suite
.
bail
(
bail
)
;
return
this
;
}
;
Mocha
.
prototype
.
addFile
=
function
(
file
)
{
this
.
files
.
push
(
file
)
;
return
this
;
}
;
Mocha
.
prototype
.
reporter
=
function
(
reporter
reporterOptions
)
{
if
(
typeof
reporter
=
=
=
'
function
'
)
{
this
.
_reporter
=
reporter
;
}
else
{
reporter
=
reporter
|
|
'
spec
'
;
var
_reporter
;
if
(
reporters
[
reporter
]
)
{
_reporter
=
reporters
[
reporter
]
;
}
if
(
!
_reporter
)
{
try
{
_reporter
=
require
(
reporter
)
;
}
catch
(
err
)
{
if
(
err
.
message
.
indexOf
(
'
Cannot
find
module
'
)
!
=
=
-
1
)
{
try
{
_reporter
=
require
(
path
.
resolve
(
process
.
cwd
(
)
reporter
)
)
;
}
catch
(
_err
)
{
err
.
message
.
indexOf
(
'
Cannot
find
module
'
)
!
=
=
-
1
?
console
.
warn
(
'
"
'
+
reporter
+
'
"
reporter
not
found
'
)
:
console
.
warn
(
'
"
'
+
reporter
+
'
"
reporter
blew
up
with
error
:
\
n
'
+
err
.
stack
)
;
}
}
else
{
console
.
warn
(
'
"
'
+
reporter
+
'
"
reporter
blew
up
with
error
:
\
n
'
+
err
.
stack
)
;
}
}
}
if
(
!
_reporter
&
&
reporter
=
=
=
'
teamcity
'
)
{
console
.
warn
(
'
The
Teamcity
reporter
was
moved
to
a
package
named
'
+
'
mocha
-
teamcity
-
reporter
'
+
'
(
https
:
/
/
npmjs
.
org
/
package
/
mocha
-
teamcity
-
reporter
)
.
'
)
;
}
if
(
!
_reporter
)
{
throw
new
Error
(
'
invalid
reporter
"
'
+
reporter
+
'
"
'
)
;
}
this
.
_reporter
=
_reporter
;
}
this
.
options
.
reporterOptions
=
reporterOptions
;
return
this
;
}
;
Mocha
.
prototype
.
ui
=
function
(
name
)
{
name
=
name
|
|
'
bdd
'
;
this
.
_ui
=
exports
.
interfaces
[
name
]
;
if
(
!
this
.
_ui
)
{
try
{
this
.
_ui
=
require
(
name
)
;
}
catch
(
err
)
{
throw
new
Error
(
'
invalid
interface
"
'
+
name
+
'
"
'
)
;
}
}
this
.
_ui
=
this
.
_ui
(
this
.
suite
)
;
this
.
suite
.
on
(
'
pre
-
require
'
function
(
context
)
{
exports
.
afterEach
=
context
.
afterEach
|
|
context
.
teardown
;
exports
.
after
=
context
.
after
|
|
context
.
suiteTeardown
;
exports
.
beforeEach
=
context
.
beforeEach
|
|
context
.
setup
;
exports
.
before
=
context
.
before
|
|
context
.
suiteSetup
;
exports
.
describe
=
context
.
describe
|
|
context
.
suite
;
exports
.
it
=
context
.
it
|
|
context
.
test
;
exports
.
setup
=
context
.
setup
|
|
context
.
beforeEach
;
exports
.
suiteSetup
=
context
.
suiteSetup
|
|
context
.
before
;
exports
.
suiteTeardown
=
context
.
suiteTeardown
|
|
context
.
after
;
exports
.
suite
=
context
.
suite
|
|
context
.
describe
;
exports
.
teardown
=
context
.
teardown
|
|
context
.
afterEach
;
exports
.
test
=
context
.
test
|
|
context
.
it
;
exports
.
run
=
context
.
run
;
}
)
;
return
this
;
}
;
Mocha
.
prototype
.
loadFiles
=
function
(
fn
)
{
var
self
=
this
;
var
suite
=
this
.
suite
;
this
.
files
.
forEach
(
function
(
file
)
{
file
=
path
.
resolve
(
file
)
;
suite
.
emit
(
'
pre
-
require
'
global
file
self
)
;
suite
.
emit
(
'
require
'
require
(
file
)
file
self
)
;
suite
.
emit
(
'
post
-
require
'
global
file
self
)
;
}
)
;
fn
&
&
fn
(
)
;
}
;
Mocha
.
prototype
.
_growl
=
function
(
runner
reporter
)
{
var
notify
=
require
(
'
growl
'
)
;
runner
.
on
(
'
end
'
function
(
)
{
var
stats
=
reporter
.
stats
;
if
(
stats
.
failures
)
{
var
msg
=
stats
.
failures
+
'
of
'
+
runner
.
total
+
'
tests
failed
'
;
notify
(
msg
{
name
:
'
mocha
'
title
:
'
Failed
'
image
:
image
(
'
error
'
)
}
)
;
}
else
{
notify
(
stats
.
passes
+
'
tests
passed
in
'
+
stats
.
duration
+
'
ms
'
{
name
:
'
mocha
'
title
:
'
Passed
'
image
:
image
(
'
ok
'
)
}
)
;
}
}
)
;
}
;
Mocha
.
prototype
.
fgrep
=
function
(
str
)
{
return
this
.
grep
(
new
RegExp
(
escapeRe
(
str
)
)
)
;
}
;
Mocha
.
prototype
.
grep
=
function
(
re
)
{
if
(
utils
.
isString
(
re
)
)
{
var
arg
=
re
.
match
(
/
^
\
/
(
.
*
)
\
/
(
g
|
i
|
)
|
.
*
/
)
;
this
.
options
.
grep
=
new
RegExp
(
arg
[
1
]
|
|
arg
[
0
]
arg
[
2
]
)
;
}
else
{
this
.
options
.
grep
=
re
;
}
return
this
;
}
;
Mocha
.
prototype
.
invert
=
function
(
)
{
this
.
options
.
invert
=
true
;
return
this
;
}
;
Mocha
.
prototype
.
ignoreLeaks
=
function
(
ignore
)
{
this
.
options
.
ignoreLeaks
=
Boolean
(
ignore
)
;
return
this
;
}
;
Mocha
.
prototype
.
checkLeaks
=
function
(
)
{
this
.
options
.
ignoreLeaks
=
false
;
return
this
;
}
;
Mocha
.
prototype
.
fullTrace
=
function
(
)
{
this
.
options
.
fullStackTrace
=
true
;
return
this
;
}
;
Mocha
.
prototype
.
growl
=
function
(
)
{
this
.
options
.
growl
=
true
;
return
this
;
}
;
Mocha
.
prototype
.
globals
=
function
(
globals
)
{
this
.
options
.
globals
=
(
this
.
options
.
globals
|
|
[
]
)
.
concat
(
globals
)
;
return
this
;
}
;
Mocha
.
prototype
.
useColors
=
function
(
colors
)
{
if
(
colors
!
=
=
undefined
)
{
this
.
options
.
useColors
=
colors
;
}
return
this
;
}
;
Mocha
.
prototype
.
useInlineDiffs
=
function
(
inlineDiffs
)
{
this
.
options
.
useInlineDiffs
=
inlineDiffs
!
=
=
undefined
&
&
inlineDiffs
;
return
this
;
}
;
Mocha
.
prototype
.
timeout
=
function
(
timeout
)
{
this
.
suite
.
timeout
(
timeout
)
;
return
this
;
}
;
Mocha
.
prototype
.
retries
=
function
(
n
)
{
this
.
suite
.
retries
(
n
)
;
return
this
;
}
;
Mocha
.
prototype
.
slow
=
function
(
slow
)
{
this
.
suite
.
slow
(
slow
)
;
return
this
;
}
;
Mocha
.
prototype
.
enableTimeouts
=
function
(
enabled
)
{
this
.
suite
.
enableTimeouts
(
arguments
.
length
&
&
enabled
!
=
=
undefined
?
enabled
:
true
)
;
return
this
;
}
;
Mocha
.
prototype
.
asyncOnly
=
function
(
)
{
this
.
options
.
asyncOnly
=
true
;
return
this
;
}
;
Mocha
.
prototype
.
noHighlighting
=
function
(
)
{
this
.
options
.
noHighlighting
=
true
;
return
this
;
}
;
Mocha
.
prototype
.
allowUncaught
=
function
(
)
{
this
.
options
.
allowUncaught
=
true
;
return
this
;
}
;
Mocha
.
prototype
.
delay
=
function
delay
(
)
{
this
.
options
.
delay
=
true
;
return
this
;
}
;
Mocha
.
prototype
.
run
=
function
(
fn
)
{
if
(
this
.
files
.
length
)
{
this
.
loadFiles
(
)
;
}
var
suite
=
this
.
suite
;
var
options
=
this
.
options
;
options
.
files
=
this
.
files
;
var
runner
=
new
exports
.
Runner
(
suite
options
.
delay
)
;
var
reporter
=
new
this
.
_reporter
(
runner
options
)
;
runner
.
ignoreLeaks
=
options
.
ignoreLeaks
!
=
=
false
;
runner
.
fullStackTrace
=
options
.
fullStackTrace
;
runner
.
hasOnly
=
options
.
hasOnly
;
runner
.
asyncOnly
=
options
.
asyncOnly
;
runner
.
allowUncaught
=
options
.
allowUncaught
;
if
(
options
.
grep
)
{
runner
.
grep
(
options
.
grep
options
.
invert
)
;
}
if
(
options
.
globals
)
{
runner
.
globals
(
options
.
globals
)
;
}
if
(
options
.
growl
)
{
this
.
_growl
(
runner
reporter
)
;
}
if
(
options
.
useColors
!
=
=
undefined
)
{
exports
.
reporters
.
Base
.
useColors
=
options
.
useColors
;
}
exports
.
reporters
.
Base
.
inlineDiffs
=
options
.
useInlineDiffs
;
function
done
(
failures
)
{
if
(
reporter
.
done
)
{
reporter
.
done
(
failures
fn
)
;
}
else
{
fn
&
&
fn
(
failures
)
;
}
}
return
runner
.
run
(
done
)
;
}
;
}
)
.
call
(
this
require
(
'
_process
'
)
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
"
/
lib
"
)
}
{
"
.
/
context
"
:
6
"
.
/
hook
"
:
7
"
.
/
interfaces
"
:
11
"
.
/
reporters
"
:
21
"
.
/
runnable
"
:
33
"
.
/
runner
"
:
34
"
.
/
suite
"
:
35
"
.
/
test
"
:
36
"
.
/
utils
"
:
38
"
_process
"
:
82
"
escape
-
string
-
regexp
"
:
62
"
growl
"
:
64
"
path
"
:
42
}
]
15
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
s
=
1000
;
var
m
=
s
*
60
;
var
h
=
m
*
60
;
var
d
=
h
*
24
;
var
y
=
d
*
365
.
25
;
module
.
exports
=
function
(
val
options
)
{
options
=
options
|
|
{
}
;
if
(
typeof
val
=
=
=
'
string
'
)
{
return
parse
(
val
)
;
}
return
options
[
'
long
'
]
?
longFormat
(
val
)
:
shortFormat
(
val
)
;
}
;
function
parse
(
str
)
{
var
match
=
(
/
^
(
(
?
:
\
d
+
)
?
\
.
?
\
d
+
)
*
(
ms
|
seconds
?
|
s
|
minutes
?
|
m
|
hours
?
|
h
|
days
?
|
d
|
years
?
|
y
)
?
/
i
)
.
exec
(
str
)
;
if
(
!
match
)
{
return
;
}
var
n
=
parseFloat
(
match
[
1
]
)
;
var
type
=
(
match
[
2
]
|
|
'
ms
'
)
.
toLowerCase
(
)
;
switch
(
type
)
{
case
'
years
'
:
case
'
year
'
:
case
'
y
'
:
return
n
*
y
;
case
'
days
'
:
case
'
day
'
:
case
'
d
'
:
return
n
*
d
;
case
'
hours
'
:
case
'
hour
'
:
case
'
h
'
:
return
n
*
h
;
case
'
minutes
'
:
case
'
minute
'
:
case
'
m
'
:
return
n
*
m
;
case
'
seconds
'
:
case
'
second
'
:
case
'
s
'
:
return
n
*
s
;
case
'
ms
'
:
return
n
;
default
:
}
}
function
shortFormat
(
ms
)
{
if
(
ms
>
=
d
)
{
return
Math
.
round
(
ms
/
d
)
+
'
d
'
;
}
if
(
ms
>
=
h
)
{
return
Math
.
round
(
ms
/
h
)
+
'
h
'
;
}
if
(
ms
>
=
m
)
{
return
Math
.
round
(
ms
/
m
)
+
'
m
'
;
}
if
(
ms
>
=
s
)
{
return
Math
.
round
(
ms
/
s
)
+
'
s
'
;
}
return
ms
+
'
ms
'
;
}
function
longFormat
(
ms
)
{
return
plural
(
ms
d
'
day
'
)
|
|
plural
(
ms
h
'
hour
'
)
|
|
plural
(
ms
m
'
minute
'
)
|
|
plural
(
ms
s
'
second
'
)
|
|
ms
+
'
ms
'
;
}
function
plural
(
ms
n
name
)
{
if
(
ms
<
n
)
{
return
;
}
if
(
ms
<
n
*
1
.
5
)
{
return
Math
.
floor
(
ms
/
n
)
+
'
'
+
name
;
}
return
Math
.
ceil
(
ms
/
n
)
+
'
'
+
name
+
'
s
'
;
}
}
{
}
]
16
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
Pending
;
function
Pending
(
message
)
{
this
.
message
=
message
;
}
}
{
}
]
17
:
[
function
(
require
module
exports
)
{
(
function
(
process
global
)
{
'
use
strict
'
;
var
tty
=
require
(
'
tty
'
)
;
var
diff
=
require
(
'
diff
'
)
;
var
ms
=
require
(
'
.
.
/
ms
'
)
;
var
utils
=
require
(
'
.
.
/
utils
'
)
;
var
supportsColor
=
process
.
browser
?
null
:
require
(
'
supports
-
color
'
)
;
exports
=
module
.
exports
=
Base
;
var
Date
=
global
.
Date
;
var
setTimeout
=
global
.
setTimeout
;
var
setInterval
=
global
.
setInterval
;
var
clearTimeout
=
global
.
clearTimeout
;
var
clearInterval
=
global
.
clearInterval
;
var
isatty
=
tty
.
isatty
(
1
)
&
&
tty
.
isatty
(
2
)
;
exports
.
useColors
=
!
process
.
browser
&
&
(
supportsColor
|
|
(
process
.
env
.
MOCHA_COLORS
!
=
=
undefined
)
)
;
exports
.
inlineDiffs
=
false
;
exports
.
colors
=
{
pass
:
90
fail
:
31
'
bright
pass
'
:
92
'
bright
fail
'
:
91
'
bright
yellow
'
:
93
pending
:
36
suite
:
0
'
error
title
'
:
0
'
error
message
'
:
31
'
error
stack
'
:
90
checkmark
:
32
fast
:
90
medium
:
33
slow
:
31
green
:
32
light
:
90
'
diff
gutter
'
:
90
'
diff
added
'
:
32
'
diff
removed
'
:
31
}
;
exports
.
symbols
=
{
ok
:
'
'
err
:
'
'
dot
:
'
'
comma
:
'
'
bang
:
'
!
'
}
;
if
(
process
.
platform
=
=
=
'
win32
'
)
{
exports
.
symbols
.
ok
=
'
\
u221A
'
;
exports
.
symbols
.
err
=
'
\
u00D7
'
;
exports
.
symbols
.
dot
=
'
.
'
;
}
var
color
=
exports
.
color
=
function
(
type
str
)
{
if
(
!
exports
.
useColors
)
{
return
String
(
str
)
;
}
return
'
\
u001b
[
'
+
exports
.
colors
[
type
]
+
'
m
'
+
str
+
'
\
u001b
[
0m
'
;
}
;
exports
.
window
=
{
width
:
75
}
;
if
(
isatty
)
{
exports
.
window
.
width
=
process
.
stdout
.
getWindowSize
?
process
.
stdout
.
getWindowSize
(
1
)
[
0
]
:
tty
.
getWindowSize
(
)
[
1
]
;
}
exports
.
cursor
=
{
hide
:
function
(
)
{
isatty
&
&
process
.
stdout
.
write
(
'
\
u001b
[
?
25l
'
)
;
}
show
:
function
(
)
{
isatty
&
&
process
.
stdout
.
write
(
'
\
u001b
[
?
25h
'
)
;
}
deleteLine
:
function
(
)
{
isatty
&
&
process
.
stdout
.
write
(
'
\
u001b
[
2K
'
)
;
}
beginningOfLine
:
function
(
)
{
isatty
&
&
process
.
stdout
.
write
(
'
\
u001b
[
0G
'
)
;
}
CR
:
function
(
)
{
if
(
isatty
)
{
exports
.
cursor
.
deleteLine
(
)
;
exports
.
cursor
.
beginningOfLine
(
)
;
}
else
{
process
.
stdout
.
write
(
'
\
r
'
)
;
}
}
}
;
exports
.
list
=
function
(
failures
)
{
console
.
log
(
)
;
failures
.
forEach
(
function
(
test
i
)
{
var
fmt
=
color
(
'
error
title
'
'
%
s
)
%
s
:
\
n
'
)
+
color
(
'
error
message
'
'
%
s
'
)
+
color
(
'
error
stack
'
'
\
n
%
s
\
n
'
)
;
var
msg
;
var
err
=
test
.
err
;
var
message
;
if
(
err
.
message
&
&
typeof
err
.
message
.
toString
=
=
=
'
function
'
)
{
message
=
err
.
message
+
'
'
;
}
else
if
(
typeof
err
.
inspect
=
=
=
'
function
'
)
{
message
=
err
.
inspect
(
)
+
'
'
;
}
else
{
message
=
'
'
;
}
var
stack
=
err
.
stack
|
|
message
;
var
index
=
message
?
stack
.
indexOf
(
message
)
:
-
1
;
var
actual
=
err
.
actual
;
var
expected
=
err
.
expected
;
var
escape
=
true
;
if
(
index
=
=
=
-
1
)
{
msg
=
message
;
}
else
{
index
+
=
message
.
length
;
msg
=
stack
.
slice
(
0
index
)
;
stack
=
stack
.
slice
(
index
+
1
)
;
}
if
(
err
.
uncaught
)
{
msg
=
'
Uncaught
'
+
msg
;
}
if
(
err
.
showDiff
!
=
=
false
&
&
sameType
(
actual
expected
)
&
&
expected
!
=
=
undefined
)
{
escape
=
false
;
if
(
!
(
utils
.
isString
(
actual
)
&
&
utils
.
isString
(
expected
)
)
)
{
err
.
actual
=
actual
=
utils
.
stringify
(
actual
)
;
err
.
expected
=
expected
=
utils
.
stringify
(
expected
)
;
}
fmt
=
color
(
'
error
title
'
'
%
s
)
%
s
:
\
n
%
s
'
)
+
color
(
'
error
stack
'
'
\
n
%
s
\
n
'
)
;
var
match
=
message
.
match
(
/
^
(
[
^
:
]
+
)
:
expected
/
)
;
msg
=
'
\
n
'
+
color
(
'
error
message
'
match
?
match
[
1
]
:
msg
)
;
if
(
exports
.
inlineDiffs
)
{
msg
+
=
inlineDiff
(
err
escape
)
;
}
else
{
msg
+
=
unifiedDiff
(
err
escape
)
;
}
}
stack
=
stack
.
replace
(
/
^
/
gm
'
'
)
;
console
.
log
(
fmt
(
i
+
1
)
test
.
fullTitle
(
)
msg
stack
)
;
}
)
;
}
;
function
Base
(
runner
)
{
var
stats
=
this
.
stats
=
{
suites
:
0
tests
:
0
passes
:
0
pending
:
0
failures
:
0
}
;
var
failures
=
this
.
failures
=
[
]
;
if
(
!
runner
)
{
return
;
}
this
.
runner
=
runner
;
runner
.
stats
=
stats
;
runner
.
on
(
'
start
'
function
(
)
{
stats
.
start
=
new
Date
(
)
;
}
)
;
runner
.
on
(
'
suite
'
function
(
suite
)
{
stats
.
suites
=
stats
.
suites
|
|
0
;
suite
.
root
|
|
stats
.
suites
+
+
;
}
)
;
runner
.
on
(
'
test
end
'
function
(
)
{
stats
.
tests
=
stats
.
tests
|
|
0
;
stats
.
tests
+
+
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
stats
.
passes
=
stats
.
passes
|
|
0
;
if
(
test
.
duration
>
test
.
slow
(
)
)
{
test
.
speed
=
'
slow
'
;
}
else
if
(
test
.
duration
>
test
.
slow
(
)
/
2
)
{
test
.
speed
=
'
medium
'
;
}
else
{
test
.
speed
=
'
fast
'
;
}
stats
.
passes
+
+
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
err
)
{
stats
.
failures
=
stats
.
failures
|
|
0
;
stats
.
failures
+
+
;
test
.
err
=
err
;
failures
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
stats
.
end
=
new
Date
(
)
;
stats
.
duration
=
new
Date
(
)
-
stats
.
start
;
}
)
;
runner
.
on
(
'
pending
'
function
(
)
{
stats
.
pending
+
+
;
}
)
;
}
Base
.
prototype
.
epilogue
=
function
(
)
{
var
stats
=
this
.
stats
;
var
fmt
;
console
.
log
(
)
;
fmt
=
color
(
'
bright
pass
'
'
'
)
+
color
(
'
green
'
'
%
d
passing
'
)
+
color
(
'
light
'
'
(
%
s
)
'
)
;
console
.
log
(
fmt
stats
.
passes
|
|
0
ms
(
stats
.
duration
)
)
;
if
(
stats
.
pending
)
{
fmt
=
color
(
'
pending
'
'
'
)
+
color
(
'
pending
'
'
%
d
pending
'
)
;
console
.
log
(
fmt
stats
.
pending
)
;
}
if
(
stats
.
failures
)
{
fmt
=
color
(
'
fail
'
'
%
d
failing
'
)
;
console
.
log
(
fmt
stats
.
failures
)
;
Base
.
list
(
this
.
failures
)
;
console
.
log
(
)
;
}
console
.
log
(
)
;
}
;
function
pad
(
str
len
)
{
str
=
String
(
str
)
;
return
Array
(
len
-
str
.
length
+
1
)
.
join
(
'
'
)
+
str
;
}
function
inlineDiff
(
err
escape
)
{
var
msg
=
errorDiff
(
err
'
WordsWithSpace
'
escape
)
;
var
lines
=
msg
.
split
(
'
\
n
'
)
;
if
(
lines
.
length
>
4
)
{
var
width
=
String
(
lines
.
length
)
.
length
;
msg
=
lines
.
map
(
function
(
str
i
)
{
return
pad
(
+
+
i
width
)
+
'
|
'
+
'
'
+
str
;
}
)
.
join
(
'
\
n
'
)
;
}
msg
=
'
\
n
'
+
color
(
'
diff
removed
'
'
actual
'
)
+
'
'
+
color
(
'
diff
added
'
'
expected
'
)
+
'
\
n
\
n
'
+
msg
+
'
\
n
'
;
msg
=
msg
.
replace
(
/
^
/
gm
'
'
)
;
return
msg
;
}
function
unifiedDiff
(
err
escape
)
{
var
indent
=
'
'
;
function
cleanUp
(
line
)
{
if
(
escape
)
{
line
=
escapeInvisibles
(
line
)
;
}
if
(
line
[
0
]
=
=
=
'
+
'
)
{
return
indent
+
colorLines
(
'
diff
added
'
line
)
;
}
if
(
line
[
0
]
=
=
=
'
-
'
)
{
return
indent
+
colorLines
(
'
diff
removed
'
line
)
;
}
if
(
line
.
match
(
/
/
)
)
{
return
null
;
}
if
(
line
.
match
(
/
\
\
No
newline
/
)
)
{
return
null
;
}
return
indent
+
line
;
}
function
notBlank
(
line
)
{
return
typeof
line
!
=
=
'
undefined
'
&
&
line
!
=
=
null
;
}
var
msg
=
diff
.
createPatch
(
'
string
'
err
.
actual
err
.
expected
)
;
var
lines
=
msg
.
split
(
'
\
n
'
)
.
splice
(
4
)
;
return
'
\
n
'
+
colorLines
(
'
diff
added
'
'
+
expected
'
)
+
'
'
+
colorLines
(
'
diff
removed
'
'
-
actual
'
)
+
'
\
n
\
n
'
+
lines
.
map
(
cleanUp
)
.
filter
(
notBlank
)
.
join
(
'
\
n
'
)
;
}
function
errorDiff
(
err
type
escape
)
{
var
actual
=
escape
?
escapeInvisibles
(
err
.
actual
)
:
err
.
actual
;
var
expected
=
escape
?
escapeInvisibles
(
err
.
expected
)
:
err
.
expected
;
return
diff
[
'
diff
'
+
type
]
(
actual
expected
)
.
map
(
function
(
str
)
{
if
(
str
.
added
)
{
return
colorLines
(
'
diff
added
'
str
.
value
)
;
}
if
(
str
.
removed
)
{
return
colorLines
(
'
diff
removed
'
str
.
value
)
;
}
return
str
.
value
;
}
)
.
join
(
'
'
)
;
}
function
escapeInvisibles
(
line
)
{
return
line
.
replace
(
/
\
t
/
g
'
<
tab
>
'
)
.
replace
(
/
\
r
/
g
'
<
CR
>
'
)
.
replace
(
/
\
n
/
g
'
<
LF
>
\
n
'
)
;
}
function
colorLines
(
name
str
)
{
return
str
.
split
(
'
\
n
'
)
.
map
(
function
(
str
)
{
return
color
(
name
str
)
;
}
)
.
join
(
'
\
n
'
)
;
}
var
objToString
=
Object
.
prototype
.
toString
;
function
sameType
(
a
b
)
{
return
objToString
.
call
(
a
)
=
=
=
objToString
.
call
(
b
)
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
.
.
/
ms
"
:
15
"
.
.
/
utils
"
:
38
"
_process
"
:
82
"
diff
"
:
56
"
supports
-
color
"
:
42
"
tty
"
:
5
}
]
18
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
utils
=
require
(
'
.
.
/
utils
'
)
;
exports
=
module
.
exports
=
Doc
;
function
Doc
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
indents
=
2
;
function
indent
(
)
{
return
Array
(
indents
)
.
join
(
'
'
)
;
}
runner
.
on
(
'
suite
'
function
(
suite
)
{
if
(
suite
.
root
)
{
return
;
}
+
+
indents
;
console
.
log
(
'
%
s
<
section
class
=
"
suite
"
>
'
indent
(
)
)
;
+
+
indents
;
console
.
log
(
'
%
s
<
h1
>
%
s
<
/
h1
>
'
indent
(
)
utils
.
escape
(
suite
.
title
)
)
;
console
.
log
(
'
%
s
<
dl
>
'
indent
(
)
)
;
}
)
;
runner
.
on
(
'
suite
end
'
function
(
suite
)
{
if
(
suite
.
root
)
{
return
;
}
console
.
log
(
'
%
s
<
/
dl
>
'
indent
(
)
)
;
-
-
indents
;
console
.
log
(
'
%
s
<
/
section
>
'
indent
(
)
)
;
-
-
indents
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
console
.
log
(
'
%
s
<
dt
>
%
s
<
/
dt
>
'
indent
(
)
utils
.
escape
(
test
.
title
)
)
;
var
code
=
utils
.
escape
(
utils
.
clean
(
test
.
body
)
)
;
console
.
log
(
'
%
s
<
dd
>
<
pre
>
<
code
>
%
s
<
/
code
>
<
/
pre
>
<
/
dd
>
'
indent
(
)
code
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
err
)
{
console
.
log
(
'
%
s
<
dt
class
=
"
error
"
>
%
s
<
/
dt
>
'
indent
(
)
utils
.
escape
(
test
.
title
)
)
;
var
code
=
utils
.
escape
(
utils
.
clean
(
test
.
body
)
)
;
console
.
log
(
'
%
s
<
dd
class
=
"
error
"
>
<
pre
>
<
code
>
%
s
<
/
code
>
<
/
pre
>
<
/
dd
>
'
indent
(
)
code
)
;
console
.
log
(
'
%
s
<
dd
class
=
"
error
"
>
%
s
<
/
dd
>
'
indent
(
)
utils
.
escape
(
err
)
)
;
}
)
;
}
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
}
]
19
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
inherits
=
require
(
'
.
.
/
utils
'
)
.
inherits
;
var
color
=
Base
.
color
;
exports
=
module
.
exports
=
Dot
;
function
Dot
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
width
=
Base
.
window
.
width
*
0
.
75
|
0
;
var
n
=
-
1
;
runner
.
on
(
'
start
'
function
(
)
{
process
.
stdout
.
write
(
'
\
n
'
)
;
}
)
;
runner
.
on
(
'
pending
'
function
(
)
{
if
(
+
+
n
%
width
=
=
=
0
)
{
process
.
stdout
.
write
(
'
\
n
'
)
;
}
process
.
stdout
.
write
(
color
(
'
pending
'
Base
.
symbols
.
comma
)
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
if
(
+
+
n
%
width
=
=
=
0
)
{
process
.
stdout
.
write
(
'
\
n
'
)
;
}
if
(
test
.
speed
=
=
=
'
slow
'
)
{
process
.
stdout
.
write
(
color
(
'
bright
yellow
'
Base
.
symbols
.
dot
)
)
;
}
else
{
process
.
stdout
.
write
(
color
(
test
.
speed
Base
.
symbols
.
dot
)
)
;
}
}
)
;
runner
.
on
(
'
fail
'
function
(
)
{
if
(
+
+
n
%
width
=
=
=
0
)
{
process
.
stdout
.
write
(
'
\
n
'
)
;
}
process
.
stdout
.
write
(
color
(
'
fail
'
Base
.
symbols
.
bang
)
)
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
console
.
log
(
)
;
self
.
epilogue
(
)
;
}
)
;
}
inherits
(
Dot
Base
)
;
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
20
:
[
function
(
require
module
exports
)
{
(
function
(
global
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
utils
=
require
(
'
.
.
/
utils
'
)
;
var
Progress
=
require
(
'
.
.
/
browser
/
progress
'
)
;
var
escapeRe
=
require
(
'
escape
-
string
-
regexp
'
)
;
var
escape
=
utils
.
escape
;
var
Date
=
global
.
Date
;
var
setTimeout
=
global
.
setTimeout
;
var
setInterval
=
global
.
setInterval
;
var
clearTimeout
=
global
.
clearTimeout
;
var
clearInterval
=
global
.
clearInterval
;
exports
=
module
.
exports
=
HTML
;
var
statsTemplate
=
'
<
ul
id
=
"
mocha
-
stats
"
>
'
+
'
<
li
class
=
"
progress
"
>
<
canvas
width
=
"
40
"
height
=
"
40
"
>
<
/
canvas
>
<
/
li
>
'
+
'
<
li
class
=
"
passes
"
>
<
a
href
=
"
javascript
:
void
(
0
)
;
"
>
passes
:
<
/
a
>
<
em
>
0
<
/
em
>
<
/
li
>
'
+
'
<
li
class
=
"
failures
"
>
<
a
href
=
"
javascript
:
void
(
0
)
;
"
>
failures
:
<
/
a
>
<
em
>
0
<
/
em
>
<
/
li
>
'
+
'
<
li
class
=
"
duration
"
>
duration
:
<
em
>
0
<
/
em
>
s
<
/
li
>
'
+
'
<
/
ul
>
'
;
var
playIcon
=
'
&
#
x2023
;
'
;
function
HTML
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
stats
=
this
.
stats
;
var
stat
=
fragment
(
statsTemplate
)
;
var
items
=
stat
.
getElementsByTagName
(
'
li
'
)
;
var
passes
=
items
[
1
]
.
getElementsByTagName
(
'
em
'
)
[
0
]
;
var
passesLink
=
items
[
1
]
.
getElementsByTagName
(
'
a
'
)
[
0
]
;
var
failures
=
items
[
2
]
.
getElementsByTagName
(
'
em
'
)
[
0
]
;
var
failuresLink
=
items
[
2
]
.
getElementsByTagName
(
'
a
'
)
[
0
]
;
var
duration
=
items
[
3
]
.
getElementsByTagName
(
'
em
'
)
[
0
]
;
var
canvas
=
stat
.
getElementsByTagName
(
'
canvas
'
)
[
0
]
;
var
report
=
fragment
(
'
<
ul
id
=
"
mocha
-
report
"
>
<
/
ul
>
'
)
;
var
stack
=
[
report
]
;
var
progress
;
var
ctx
;
var
root
=
document
.
getElementById
(
'
mocha
'
)
;
if
(
canvas
.
getContext
)
{
var
ratio
=
window
.
devicePixelRatio
|
|
1
;
canvas
.
style
.
width
=
canvas
.
width
;
canvas
.
style
.
height
=
canvas
.
height
;
canvas
.
width
*
=
ratio
;
canvas
.
height
*
=
ratio
;
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
ctx
.
scale
(
ratio
ratio
)
;
progress
=
new
Progress
(
)
;
}
if
(
!
root
)
{
return
error
(
'
#
mocha
div
missing
add
it
to
your
document
'
)
;
}
on
(
passesLink
'
click
'
function
(
evt
)
{
evt
.
preventDefault
(
)
;
unhide
(
)
;
var
name
=
(
/
pass
/
)
.
test
(
report
.
className
)
?
'
'
:
'
pass
'
;
report
.
className
=
report
.
className
.
replace
(
/
fail
|
pass
/
g
'
'
)
+
name
;
if
(
report
.
className
.
trim
(
)
)
{
hideSuitesWithout
(
'
test
pass
'
)
;
}
}
)
;
on
(
failuresLink
'
click
'
function
(
evt
)
{
evt
.
preventDefault
(
)
;
unhide
(
)
;
var
name
=
(
/
fail
/
)
.
test
(
report
.
className
)
?
'
'
:
'
fail
'
;
report
.
className
=
report
.
className
.
replace
(
/
fail
|
pass
/
g
'
'
)
+
name
;
if
(
report
.
className
.
trim
(
)
)
{
hideSuitesWithout
(
'
test
fail
'
)
;
}
}
)
;
root
.
appendChild
(
stat
)
;
root
.
appendChild
(
report
)
;
if
(
progress
)
{
progress
.
size
(
40
)
;
}
runner
.
on
(
'
suite
'
function
(
suite
)
{
if
(
suite
.
root
)
{
return
;
}
var
url
=
self
.
suiteURL
(
suite
)
;
var
el
=
fragment
(
'
<
li
class
=
"
suite
"
>
<
h1
>
<
a
href
=
"
%
s
"
>
%
s
<
/
a
>
<
/
h1
>
<
/
li
>
'
url
escape
(
suite
.
title
)
)
;
stack
[
0
]
.
appendChild
(
el
)
;
stack
.
unshift
(
document
.
createElement
(
'
ul
'
)
)
;
el
.
appendChild
(
stack
[
0
]
)
;
}
)
;
runner
.
on
(
'
suite
end
'
function
(
suite
)
{
if
(
suite
.
root
)
{
updateStats
(
)
;
return
;
}
stack
.
shift
(
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
var
url
=
self
.
testURL
(
test
)
;
var
markup
=
'
<
li
class
=
"
test
pass
%
e
"
>
<
h2
>
%
e
<
span
class
=
"
duration
"
>
%
ems
<
/
span
>
'
+
'
<
a
href
=
"
%
s
"
class
=
"
replay
"
>
'
+
playIcon
+
'
<
/
a
>
<
/
h2
>
<
/
li
>
'
;
var
el
=
fragment
(
markup
test
.
speed
test
.
title
test
.
duration
url
)
;
self
.
addCodeToggle
(
el
test
.
body
)
;
appendToStack
(
el
)
;
updateStats
(
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
)
{
var
el
=
fragment
(
'
<
li
class
=
"
test
fail
"
>
<
h2
>
%
e
<
a
href
=
"
%
e
"
class
=
"
replay
"
>
'
+
playIcon
+
'
<
/
a
>
<
/
h2
>
<
/
li
>
'
test
.
title
self
.
testURL
(
test
)
)
;
var
stackString
;
var
message
=
test
.
err
.
toString
(
)
;
if
(
message
=
=
=
'
[
object
Error
]
'
)
{
message
=
test
.
err
.
message
;
}
if
(
test
.
err
.
stack
)
{
var
indexOfMessage
=
test
.
err
.
stack
.
indexOf
(
test
.
err
.
message
)
;
if
(
indexOfMessage
=
=
=
-
1
)
{
stackString
=
test
.
err
.
stack
;
}
else
{
stackString
=
test
.
err
.
stack
.
substr
(
test
.
err
.
message
.
length
+
indexOfMessage
)
;
}
}
else
if
(
test
.
err
.
sourceURL
&
&
test
.
err
.
line
!
=
=
undefined
)
{
stackString
=
'
\
n
(
'
+
test
.
err
.
sourceURL
+
'
:
'
+
test
.
err
.
line
+
'
)
'
;
}
stackString
=
stackString
|
|
'
'
;
if
(
test
.
err
.
htmlMessage
&
&
stackString
)
{
el
.
appendChild
(
fragment
(
'
<
div
class
=
"
html
-
error
"
>
%
s
\
n
<
pre
class
=
"
error
"
>
%
e
<
/
pre
>
<
/
div
>
'
test
.
err
.
htmlMessage
stackString
)
)
;
}
else
if
(
test
.
err
.
htmlMessage
)
{
el
.
appendChild
(
fragment
(
'
<
div
class
=
"
html
-
error
"
>
%
s
<
/
div
>
'
test
.
err
.
htmlMessage
)
)
;
}
else
{
el
.
appendChild
(
fragment
(
'
<
pre
class
=
"
error
"
>
%
e
%
e
<
/
pre
>
'
message
stackString
)
)
;
}
self
.
addCodeToggle
(
el
test
.
body
)
;
appendToStack
(
el
)
;
updateStats
(
)
;
}
)
;
runner
.
on
(
'
pending
'
function
(
test
)
{
var
el
=
fragment
(
'
<
li
class
=
"
test
pass
pending
"
>
<
h2
>
%
e
<
/
h2
>
<
/
li
>
'
test
.
title
)
;
appendToStack
(
el
)
;
updateStats
(
)
;
}
)
;
function
appendToStack
(
el
)
{
if
(
stack
[
0
]
)
{
stack
[
0
]
.
appendChild
(
el
)
;
}
}
function
updateStats
(
)
{
var
percent
=
stats
.
tests
/
runner
.
total
*
100
|
0
;
if
(
progress
)
{
progress
.
update
(
percent
)
.
draw
(
ctx
)
;
}
var
ms
=
new
Date
(
)
-
stats
.
start
;
text
(
passes
stats
.
passes
)
;
text
(
failures
stats
.
failures
)
;
text
(
duration
(
ms
/
1000
)
.
toFixed
(
2
)
)
;
}
}
function
makeUrl
(
s
)
{
var
search
=
window
.
location
.
search
;
if
(
search
)
{
search
=
search
.
replace
(
/
[
?
&
]
grep
=
[
^
&
\
s
]
*
/
g
'
'
)
.
replace
(
/
^
&
/
'
?
'
)
;
}
return
window
.
location
.
pathname
+
(
search
?
search
+
'
&
'
:
'
?
'
)
+
'
grep
=
'
+
encodeURIComponent
(
escapeRe
(
s
)
)
;
}
HTML
.
prototype
.
suiteURL
=
function
(
suite
)
{
return
makeUrl
(
suite
.
fullTitle
(
)
)
;
}
;
HTML
.
prototype
.
testURL
=
function
(
test
)
{
return
makeUrl
(
test
.
fullTitle
(
)
)
;
}
;
HTML
.
prototype
.
addCodeToggle
=
function
(
el
contents
)
{
var
h2
=
el
.
getElementsByTagName
(
'
h2
'
)
[
0
]
;
on
(
h2
'
click
'
function
(
)
{
pre
.
style
.
display
=
pre
.
style
.
display
=
=
=
'
none
'
?
'
block
'
:
'
none
'
;
}
)
;
var
pre
=
fragment
(
'
<
pre
>
<
code
>
%
e
<
/
code
>
<
/
pre
>
'
utils
.
clean
(
contents
)
)
;
el
.
appendChild
(
pre
)
;
pre
.
style
.
display
=
'
none
'
;
}
;
function
error
(
msg
)
{
document
.
body
.
appendChild
(
fragment
(
'
<
div
id
=
"
mocha
-
error
"
>
%
s
<
/
div
>
'
msg
)
)
;
}
function
fragment
(
html
)
{
var
args
=
arguments
;
var
div
=
document
.
createElement
(
'
div
'
)
;
var
i
=
1
;
div
.
innerHTML
=
html
.
replace
(
/
%
(
[
se
]
)
/
g
function
(
_
type
)
{
switch
(
type
)
{
case
'
s
'
:
return
String
(
args
[
i
+
+
]
)
;
case
'
e
'
:
return
escape
(
args
[
i
+
+
]
)
;
}
}
)
;
return
div
.
firstChild
;
}
function
hideSuitesWithout
(
classname
)
{
var
suites
=
document
.
getElementsByClassName
(
'
suite
'
)
;
for
(
var
i
=
0
;
i
<
suites
.
length
;
i
+
+
)
{
var
els
=
suites
[
i
]
.
getElementsByClassName
(
classname
)
;
if
(
!
els
.
length
)
{
suites
[
i
]
.
className
+
=
'
hidden
'
;
}
}
}
function
unhide
(
)
{
var
els
=
document
.
getElementsByClassName
(
'
suite
hidden
'
)
;
for
(
var
i
=
0
;
i
<
els
.
length
;
+
+
i
)
{
els
[
i
]
.
className
=
els
[
i
]
.
className
.
replace
(
'
suite
hidden
'
'
suite
'
)
;
}
}
function
text
(
el
contents
)
{
if
(
el
.
textContent
)
{
el
.
textContent
=
contents
;
}
else
{
el
.
innerText
=
contents
;
}
}
function
on
(
el
event
fn
)
{
if
(
el
.
addEventListener
)
{
el
.
addEventListener
(
event
fn
false
)
;
}
else
{
el
.
attachEvent
(
'
on
'
+
event
fn
)
;
}
}
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
.
.
/
browser
/
progress
"
:
4
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
escape
-
string
-
regexp
"
:
62
}
]
21
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
Base
=
exports
.
base
=
require
(
'
.
/
base
'
)
;
exports
.
Dot
=
exports
.
dot
=
require
(
'
.
/
dot
'
)
;
exports
.
Doc
=
exports
.
doc
=
require
(
'
.
/
doc
'
)
;
exports
.
TAP
=
exports
.
tap
=
require
(
'
.
/
tap
'
)
;
exports
.
JSON
=
exports
.
json
=
require
(
'
.
/
json
'
)
;
exports
.
HTML
=
exports
.
html
=
require
(
'
.
/
html
'
)
;
exports
.
List
=
exports
.
list
=
require
(
'
.
/
list
'
)
;
exports
.
Min
=
exports
.
min
=
require
(
'
.
/
min
'
)
;
exports
.
Spec
=
exports
.
spec
=
require
(
'
.
/
spec
'
)
;
exports
.
Nyan
=
exports
.
nyan
=
require
(
'
.
/
nyan
'
)
;
exports
.
XUnit
=
exports
.
xunit
=
require
(
'
.
/
xunit
'
)
;
exports
.
Markdown
=
exports
.
markdown
=
require
(
'
.
/
markdown
'
)
;
exports
.
Progress
=
exports
.
progress
=
require
(
'
.
/
progress
'
)
;
exports
.
Landing
=
exports
.
landing
=
require
(
'
.
/
landing
'
)
;
exports
.
JSONStream
=
exports
[
'
json
-
stream
'
]
=
require
(
'
.
/
json
-
stream
'
)
;
}
{
"
.
/
base
"
:
17
"
.
/
doc
"
:
18
"
.
/
dot
"
:
19
"
.
/
html
"
:
20
"
.
/
json
"
:
23
"
.
/
json
-
stream
"
:
22
"
.
/
landing
"
:
24
"
.
/
list
"
:
25
"
.
/
markdown
"
:
26
"
.
/
min
"
:
27
"
.
/
nyan
"
:
28
"
.
/
progress
"
:
29
"
.
/
spec
"
:
30
"
.
/
tap
"
:
31
"
.
/
xunit
"
:
32
}
]
22
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
JSON
=
require
(
'
json3
'
)
;
exports
=
module
.
exports
=
List
;
function
List
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
total
=
runner
.
total
;
runner
.
on
(
'
start
'
function
(
)
{
console
.
log
(
JSON
.
stringify
(
[
'
start
'
{
total
:
total
}
]
)
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
console
.
log
(
JSON
.
stringify
(
[
'
pass
'
clean
(
test
)
]
)
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
err
)
{
test
=
clean
(
test
)
;
test
.
err
=
err
.
message
;
test
.
stack
=
err
.
stack
|
|
null
;
console
.
log
(
JSON
.
stringify
(
[
'
fail
'
test
]
)
)
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
process
.
stdout
.
write
(
JSON
.
stringify
(
[
'
end
'
self
.
stats
]
)
)
;
}
)
;
}
function
clean
(
test
)
{
return
{
title
:
test
.
title
fullTitle
:
test
.
fullTitle
(
)
duration
:
test
.
duration
currentRetry
:
test
.
currentRetry
(
)
}
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
/
base
"
:
17
"
_process
"
:
82
"
json3
"
:
69
}
]
23
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
exports
=
module
.
exports
=
JSONReporter
;
function
JSONReporter
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
tests
=
[
]
;
var
pending
=
[
]
;
var
failures
=
[
]
;
var
passes
=
[
]
;
runner
.
on
(
'
test
end
'
function
(
test
)
{
tests
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
passes
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
)
{
failures
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
pending
'
function
(
test
)
{
pending
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
var
obj
=
{
stats
:
self
.
stats
tests
:
tests
.
map
(
clean
)
pending
:
pending
.
map
(
clean
)
failures
:
failures
.
map
(
clean
)
passes
:
passes
.
map
(
clean
)
}
;
runner
.
testResults
=
obj
;
process
.
stdout
.
write
(
JSON
.
stringify
(
obj
null
2
)
)
;
}
)
;
}
function
clean
(
test
)
{
return
{
title
:
test
.
title
fullTitle
:
test
.
fullTitle
(
)
duration
:
test
.
duration
currentRetry
:
test
.
currentRetry
(
)
err
:
errorJSON
(
test
.
err
|
|
{
}
)
}
;
}
function
errorJSON
(
err
)
{
var
res
=
{
}
;
Object
.
getOwnPropertyNames
(
err
)
.
forEach
(
function
(
key
)
{
res
[
key
]
=
err
[
key
]
;
}
err
)
;
return
res
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
24
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
inherits
=
require
(
'
.
.
/
utils
'
)
.
inherits
;
var
cursor
=
Base
.
cursor
;
var
color
=
Base
.
color
;
exports
=
module
.
exports
=
Landing
;
Base
.
colors
.
plane
=
0
;
Base
.
colors
[
'
plane
crash
'
]
=
31
;
Base
.
colors
.
runway
=
90
;
function
Landing
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
width
=
Base
.
window
.
width
*
0
.
75
|
0
;
var
total
=
runner
.
total
;
var
stream
=
process
.
stdout
;
var
plane
=
color
(
'
plane
'
'
'
)
;
var
crashed
=
-
1
;
var
n
=
0
;
function
runway
(
)
{
var
buf
=
Array
(
width
)
.
join
(
'
-
'
)
;
return
'
'
+
color
(
'
runway
'
buf
)
;
}
runner
.
on
(
'
start
'
function
(
)
{
stream
.
write
(
'
\
n
\
n
\
n
'
)
;
cursor
.
hide
(
)
;
}
)
;
runner
.
on
(
'
test
end
'
function
(
test
)
{
var
col
=
crashed
=
=
=
-
1
?
width
*
+
+
n
/
total
|
0
:
crashed
;
if
(
test
.
state
=
=
=
'
failed
'
)
{
plane
=
color
(
'
plane
crash
'
'
'
)
;
crashed
=
col
;
}
stream
.
write
(
'
\
u001b
[
'
+
(
width
+
1
)
+
'
D
\
u001b
[
2A
'
)
;
stream
.
write
(
runway
(
)
)
;
stream
.
write
(
'
\
n
'
)
;
stream
.
write
(
color
(
'
runway
'
Array
(
col
)
.
join
(
'
'
)
)
)
;
stream
.
write
(
plane
)
;
stream
.
write
(
color
(
'
runway
'
Array
(
width
-
col
)
.
join
(
'
'
)
+
'
\
n
'
)
)
;
stream
.
write
(
runway
(
)
)
;
stream
.
write
(
'
\
u001b
[
0m
'
)
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
cursor
.
show
(
)
;
console
.
log
(
)
;
self
.
epilogue
(
)
;
}
)
;
}
inherits
(
Landing
Base
)
;
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
25
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
inherits
=
require
(
'
.
.
/
utils
'
)
.
inherits
;
var
color
=
Base
.
color
;
var
cursor
=
Base
.
cursor
;
exports
=
module
.
exports
=
List
;
function
List
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
n
=
0
;
runner
.
on
(
'
start
'
function
(
)
{
console
.
log
(
)
;
}
)
;
runner
.
on
(
'
test
'
function
(
test
)
{
process
.
stdout
.
write
(
color
(
'
pass
'
'
'
+
test
.
fullTitle
(
)
+
'
:
'
)
)
;
}
)
;
runner
.
on
(
'
pending
'
function
(
test
)
{
var
fmt
=
color
(
'
checkmark
'
'
-
'
)
+
color
(
'
pending
'
'
%
s
'
)
;
console
.
log
(
fmt
test
.
fullTitle
(
)
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
var
fmt
=
color
(
'
checkmark
'
'
'
+
Base
.
symbols
.
ok
)
+
color
(
'
pass
'
'
%
s
:
'
)
+
color
(
test
.
speed
'
%
dms
'
)
;
cursor
.
CR
(
)
;
console
.
log
(
fmt
test
.
fullTitle
(
)
test
.
duration
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
)
{
cursor
.
CR
(
)
;
console
.
log
(
color
(
'
fail
'
'
%
d
)
%
s
'
)
+
+
n
test
.
fullTitle
(
)
)
;
}
)
;
runner
.
on
(
'
end
'
self
.
epilogue
.
bind
(
self
)
)
;
}
inherits
(
List
Base
)
;
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
26
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
utils
=
require
(
'
.
.
/
utils
'
)
;
var
SUITE_PREFIX
=
'
'
;
exports
=
module
.
exports
=
Markdown
;
function
Markdown
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
level
=
0
;
var
buf
=
'
'
;
function
title
(
str
)
{
return
Array
(
level
)
.
join
(
'
#
'
)
+
'
'
+
str
;
}
function
mapTOC
(
suite
obj
)
{
var
ret
=
obj
;
var
key
=
SUITE_PREFIX
+
suite
.
title
;
obj
=
obj
[
key
]
=
obj
[
key
]
|
|
{
suite
:
suite
}
;
suite
.
suites
.
forEach
(
function
(
suite
)
{
mapTOC
(
suite
obj
)
;
}
)
;
return
ret
;
}
function
stringifyTOC
(
obj
level
)
{
+
+
level
;
var
buf
=
'
'
;
var
link
;
for
(
var
key
in
obj
)
{
if
(
key
=
=
=
'
suite
'
)
{
continue
;
}
if
(
key
!
=
=
SUITE_PREFIX
)
{
link
=
'
-
[
'
+
key
.
substring
(
1
)
+
'
]
'
;
link
+
=
'
(
#
'
+
utils
.
slug
(
obj
[
key
]
.
suite
.
fullTitle
(
)
)
+
'
)
\
n
'
;
buf
+
=
Array
(
level
)
.
join
(
'
'
)
+
link
;
}
buf
+
=
stringifyTOC
(
obj
[
key
]
level
)
;
}
return
buf
;
}
function
generateTOC
(
suite
)
{
var
obj
=
mapTOC
(
suite
{
}
)
;
return
stringifyTOC
(
obj
0
)
;
}
generateTOC
(
runner
.
suite
)
;
runner
.
on
(
'
suite
'
function
(
suite
)
{
+
+
level
;
var
slug
=
utils
.
slug
(
suite
.
fullTitle
(
)
)
;
buf
+
=
'
<
a
name
=
"
'
+
slug
+
'
"
>
<
/
a
>
'
+
'
\
n
'
;
buf
+
=
title
(
suite
.
title
)
+
'
\
n
'
;
}
)
;
runner
.
on
(
'
suite
end
'
function
(
)
{
-
-
level
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
var
code
=
utils
.
clean
(
test
.
body
)
;
buf
+
=
test
.
title
+
'
.
\
n
'
;
buf
+
=
'
\
n
js
\
n
'
;
buf
+
=
code
+
'
\
n
'
;
buf
+
=
'
\
n
\
n
'
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
process
.
stdout
.
write
(
'
#
TOC
\
n
'
)
;
process
.
stdout
.
write
(
generateTOC
(
runner
.
suite
)
)
;
process
.
stdout
.
write
(
buf
)
;
}
)
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
27
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
inherits
=
require
(
'
.
.
/
utils
'
)
.
inherits
;
exports
=
module
.
exports
=
Min
;
function
Min
(
runner
)
{
Base
.
call
(
this
runner
)
;
runner
.
on
(
'
start
'
function
(
)
{
process
.
stdout
.
write
(
'
\
u001b
[
2J
'
)
;
process
.
stdout
.
write
(
'
\
u001b
[
1
;
3H
'
)
;
}
)
;
runner
.
on
(
'
end
'
this
.
epilogue
.
bind
(
this
)
)
;
}
inherits
(
Min
Base
)
;
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
28
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
inherits
=
require
(
'
.
.
/
utils
'
)
.
inherits
;
exports
=
module
.
exports
=
NyanCat
;
function
NyanCat
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
width
=
Base
.
window
.
width
*
0
.
75
|
0
;
var
nyanCatWidth
=
this
.
nyanCatWidth
=
11
;
this
.
colorIndex
=
0
;
this
.
numberOfLines
=
4
;
this
.
rainbowColors
=
self
.
generateColors
(
)
;
this
.
scoreboardWidth
=
5
;
this
.
tick
=
0
;
this
.
trajectories
=
[
[
]
[
]
[
]
[
]
]
;
this
.
trajectoryWidthMax
=
(
width
-
nyanCatWidth
)
;
runner
.
on
(
'
start
'
function
(
)
{
Base
.
cursor
.
hide
(
)
;
self
.
draw
(
)
;
}
)
;
runner
.
on
(
'
pending
'
function
(
)
{
self
.
draw
(
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
)
{
self
.
draw
(
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
)
{
self
.
draw
(
)
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
Base
.
cursor
.
show
(
)
;
for
(
var
i
=
0
;
i
<
self
.
numberOfLines
;
i
+
+
)
{
write
(
'
\
n
'
)
;
}
self
.
epilogue
(
)
;
}
)
;
}
inherits
(
NyanCat
Base
)
;
NyanCat
.
prototype
.
draw
=
function
(
)
{
this
.
appendRainbow
(
)
;
this
.
drawScoreboard
(
)
;
this
.
drawRainbow
(
)
;
this
.
drawNyanCat
(
)
;
this
.
tick
=
!
this
.
tick
;
}
;
NyanCat
.
prototype
.
drawScoreboard
=
function
(
)
{
var
stats
=
this
.
stats
;
function
draw
(
type
n
)
{
write
(
'
'
)
;
write
(
Base
.
color
(
type
n
)
)
;
write
(
'
\
n
'
)
;
}
draw
(
'
green
'
stats
.
passes
)
;
draw
(
'
fail
'
stats
.
failures
)
;
draw
(
'
pending
'
stats
.
pending
)
;
write
(
'
\
n
'
)
;
this
.
cursorUp
(
this
.
numberOfLines
)
;
}
;
NyanCat
.
prototype
.
appendRainbow
=
function
(
)
{
var
segment
=
this
.
tick
?
'
_
'
:
'
-
'
;
var
rainbowified
=
this
.
rainbowify
(
segment
)
;
for
(
var
index
=
0
;
index
<
this
.
numberOfLines
;
index
+
+
)
{
var
trajectory
=
this
.
trajectories
[
index
]
;
if
(
trajectory
.
length
>
=
this
.
trajectoryWidthMax
)
{
trajectory
.
shift
(
)
;
}
trajectory
.
push
(
rainbowified
)
;
}
}
;
NyanCat
.
prototype
.
drawRainbow
=
function
(
)
{
var
self
=
this
;
this
.
trajectories
.
forEach
(
function
(
line
)
{
write
(
'
\
u001b
[
'
+
self
.
scoreboardWidth
+
'
C
'
)
;
write
(
line
.
join
(
'
'
)
)
;
write
(
'
\
n
'
)
;
}
)
;
this
.
cursorUp
(
this
.
numberOfLines
)
;
}
;
NyanCat
.
prototype
.
drawNyanCat
=
function
(
)
{
var
self
=
this
;
var
startWidth
=
this
.
scoreboardWidth
+
this
.
trajectories
[
0
]
.
length
;
var
dist
=
'
\
u001b
[
'
+
startWidth
+
'
C
'
;
var
padding
=
'
'
;
write
(
dist
)
;
write
(
'
_
-
-
-
-
-
-
'
)
;
write
(
'
\
n
'
)
;
write
(
dist
)
;
padding
=
self
.
tick
?
'
'
:
'
'
;
write
(
'
_
|
'
+
padding
+
'
/
\
\
_
/
\
\
'
)
;
write
(
'
\
n
'
)
;
write
(
dist
)
;
padding
=
self
.
tick
?
'
_
'
:
'
__
'
;
var
tail
=
self
.
tick
?
'
~
'
:
'
^
'
;
write
(
tail
+
'
|
'
+
padding
+
this
.
face
(
)
+
'
'
)
;
write
(
'
\
n
'
)
;
write
(
dist
)
;
padding
=
self
.
tick
?
'
'
:
'
'
;
write
(
padding
+
'
"
"
"
"
'
)
;
write
(
'
\
n
'
)
;
this
.
cursorUp
(
this
.
numberOfLines
)
;
}
;
NyanCat
.
prototype
.
face
=
function
(
)
{
var
stats
=
this
.
stats
;
if
(
stats
.
failures
)
{
return
'
(
x
.
x
)
'
;
}
else
if
(
stats
.
pending
)
{
return
'
(
o
.
o
)
'
;
}
else
if
(
stats
.
passes
)
{
return
'
(
^
.
^
)
'
;
}
return
'
(
-
.
-
)
'
;
}
;
NyanCat
.
prototype
.
cursorUp
=
function
(
n
)
{
write
(
'
\
u001b
[
'
+
n
+
'
A
'
)
;
}
;
NyanCat
.
prototype
.
cursorDown
=
function
(
n
)
{
write
(
'
\
u001b
[
'
+
n
+
'
B
'
)
;
}
;
NyanCat
.
prototype
.
generateColors
=
function
(
)
{
var
colors
=
[
]
;
for
(
var
i
=
0
;
i
<
(
6
*
7
)
;
i
+
+
)
{
var
pi3
=
Math
.
floor
(
Math
.
PI
/
3
)
;
var
n
=
(
i
*
(
1
.
0
/
6
)
)
;
var
r
=
Math
.
floor
(
3
*
Math
.
sin
(
n
)
+
3
)
;
var
g
=
Math
.
floor
(
3
*
Math
.
sin
(
n
+
2
*
pi3
)
+
3
)
;
var
b
=
Math
.
floor
(
3
*
Math
.
sin
(
n
+
4
*
pi3
)
+
3
)
;
colors
.
push
(
36
*
r
+
6
*
g
+
b
+
16
)
;
}
return
colors
;
}
;
NyanCat
.
prototype
.
rainbowify
=
function
(
str
)
{
if
(
!
Base
.
useColors
)
{
return
str
;
}
var
color
=
this
.
rainbowColors
[
this
.
colorIndex
%
this
.
rainbowColors
.
length
]
;
this
.
colorIndex
+
=
1
;
return
'
\
u001b
[
38
;
5
;
'
+
color
+
'
m
'
+
str
+
'
\
u001b
[
0m
'
;
}
;
function
write
(
string
)
{
process
.
stdout
.
write
(
string
)
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
29
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
inherits
=
require
(
'
.
.
/
utils
'
)
.
inherits
;
var
color
=
Base
.
color
;
var
cursor
=
Base
.
cursor
;
exports
=
module
.
exports
=
Progress
;
Base
.
colors
.
progress
=
90
;
function
Progress
(
runner
options
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
width
=
Base
.
window
.
width
*
0
.
50
|
0
;
var
total
=
runner
.
total
;
var
complete
=
0
;
var
lastN
=
-
1
;
options
=
options
|
|
{
}
;
options
.
open
=
options
.
open
|
|
'
[
'
;
options
.
complete
=
options
.
complete
|
|
'
'
;
options
.
incomplete
=
options
.
incomplete
|
|
Base
.
symbols
.
dot
;
options
.
close
=
options
.
close
|
|
'
]
'
;
options
.
verbose
=
false
;
runner
.
on
(
'
start
'
function
(
)
{
console
.
log
(
)
;
cursor
.
hide
(
)
;
}
)
;
runner
.
on
(
'
test
end
'
function
(
)
{
complete
+
+
;
var
percent
=
complete
/
total
;
var
n
=
width
*
percent
|
0
;
var
i
=
width
-
n
;
if
(
n
=
=
=
lastN
&
&
!
options
.
verbose
)
{
return
;
}
lastN
=
n
;
cursor
.
CR
(
)
;
process
.
stdout
.
write
(
'
\
u001b
[
J
'
)
;
process
.
stdout
.
write
(
color
(
'
progress
'
'
'
+
options
.
open
)
)
;
process
.
stdout
.
write
(
Array
(
n
)
.
join
(
options
.
complete
)
)
;
process
.
stdout
.
write
(
Array
(
i
)
.
join
(
options
.
incomplete
)
)
;
process
.
stdout
.
write
(
color
(
'
progress
'
options
.
close
)
)
;
if
(
options
.
verbose
)
{
process
.
stdout
.
write
(
color
(
'
progress
'
'
'
+
complete
+
'
of
'
+
total
)
)
;
}
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
cursor
.
show
(
)
;
console
.
log
(
)
;
self
.
epilogue
(
)
;
}
)
;
}
inherits
(
Progress
Base
)
;
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
}
]
30
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
inherits
=
require
(
'
.
.
/
utils
'
)
.
inherits
;
var
color
=
Base
.
color
;
exports
=
module
.
exports
=
Spec
;
function
Spec
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
self
=
this
;
var
indents
=
0
;
var
n
=
0
;
function
indent
(
)
{
return
Array
(
indents
)
.
join
(
'
'
)
;
}
runner
.
on
(
'
start
'
function
(
)
{
console
.
log
(
)
;
}
)
;
runner
.
on
(
'
suite
'
function
(
suite
)
{
+
+
indents
;
console
.
log
(
color
(
'
suite
'
'
%
s
%
s
'
)
indent
(
)
suite
.
title
)
;
}
)
;
runner
.
on
(
'
suite
end
'
function
(
)
{
-
-
indents
;
if
(
indents
=
=
=
1
)
{
console
.
log
(
)
;
}
}
)
;
runner
.
on
(
'
pending
'
function
(
test
)
{
var
fmt
=
indent
(
)
+
color
(
'
pending
'
'
-
%
s
'
)
;
console
.
log
(
fmt
test
.
title
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
var
fmt
;
if
(
test
.
speed
=
=
=
'
fast
'
)
{
fmt
=
indent
(
)
+
color
(
'
checkmark
'
'
'
+
Base
.
symbols
.
ok
)
+
color
(
'
pass
'
'
%
s
'
)
;
console
.
log
(
fmt
test
.
title
)
;
}
else
{
fmt
=
indent
(
)
+
color
(
'
checkmark
'
'
'
+
Base
.
symbols
.
ok
)
+
color
(
'
pass
'
'
%
s
'
)
+
color
(
test
.
speed
'
(
%
dms
)
'
)
;
console
.
log
(
fmt
test
.
title
test
.
duration
)
;
}
}
)
;
runner
.
on
(
'
fail
'
function
(
test
)
{
console
.
log
(
indent
(
)
+
color
(
'
fail
'
'
%
d
)
%
s
'
)
+
+
n
test
.
title
)
;
}
)
;
runner
.
on
(
'
end
'
self
.
epilogue
.
bind
(
self
)
)
;
}
inherits
(
Spec
Base
)
;
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
}
]
31
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
exports
=
module
.
exports
=
TAP
;
function
TAP
(
runner
)
{
Base
.
call
(
this
runner
)
;
var
n
=
1
;
var
passes
=
0
;
var
failures
=
0
;
runner
.
on
(
'
start
'
function
(
)
{
var
total
=
runner
.
grepTotal
(
runner
.
suite
)
;
console
.
log
(
'
%
d
.
.
%
d
'
1
total
)
;
}
)
;
runner
.
on
(
'
test
end
'
function
(
)
{
+
+
n
;
}
)
;
runner
.
on
(
'
pending
'
function
(
test
)
{
console
.
log
(
'
ok
%
d
%
s
#
SKIP
-
'
n
title
(
test
)
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
passes
+
+
;
console
.
log
(
'
ok
%
d
%
s
'
n
title
(
test
)
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
err
)
{
failures
+
+
;
console
.
log
(
'
not
ok
%
d
%
s
'
n
title
(
test
)
)
;
if
(
err
.
stack
)
{
console
.
log
(
err
.
stack
.
replace
(
/
^
/
gm
'
'
)
)
;
}
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
console
.
log
(
'
#
tests
'
+
(
passes
+
failures
)
)
;
console
.
log
(
'
#
pass
'
+
passes
)
;
console
.
log
(
'
#
fail
'
+
failures
)
;
}
)
;
}
function
title
(
test
)
{
return
test
.
fullTitle
(
)
.
replace
(
/
#
/
g
'
'
)
;
}
}
{
"
.
/
base
"
:
17
}
]
32
:
[
function
(
require
module
exports
)
{
(
function
(
process
global
)
{
'
use
strict
'
;
var
Base
=
require
(
'
.
/
base
'
)
;
var
utils
=
require
(
'
.
.
/
utils
'
)
;
var
inherits
=
utils
.
inherits
;
var
fs
=
require
(
'
fs
'
)
;
var
escape
=
utils
.
escape
;
var
mkdirp
=
require
(
'
mkdirp
'
)
;
var
path
=
require
(
'
path
'
)
;
var
Date
=
global
.
Date
;
var
setTimeout
=
global
.
setTimeout
;
var
setInterval
=
global
.
setInterval
;
var
clearTimeout
=
global
.
clearTimeout
;
var
clearInterval
=
global
.
clearInterval
;
exports
=
module
.
exports
=
XUnit
;
function
XUnit
(
runner
options
)
{
Base
.
call
(
this
runner
)
;
var
stats
=
this
.
stats
;
var
tests
=
[
]
;
var
self
=
this
;
if
(
options
&
&
options
.
reporterOptions
&
&
options
.
reporterOptions
.
output
)
{
if
(
!
fs
.
createWriteStream
)
{
throw
new
Error
(
'
file
output
not
supported
in
browser
'
)
;
}
mkdirp
.
sync
(
path
.
dirname
(
options
.
reporterOptions
.
output
)
)
;
self
.
fileStream
=
fs
.
createWriteStream
(
options
.
reporterOptions
.
output
)
;
}
runner
.
on
(
'
pending
'
function
(
test
)
{
tests
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
pass
'
function
(
test
)
{
tests
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
fail
'
function
(
test
)
{
tests
.
push
(
test
)
;
}
)
;
runner
.
on
(
'
end
'
function
(
)
{
self
.
write
(
tag
(
'
testsuite
'
{
name
:
'
Mocha
Tests
'
tests
:
stats
.
tests
failures
:
stats
.
failures
errors
:
stats
.
failures
skipped
:
stats
.
tests
-
stats
.
failures
-
stats
.
passes
timestamp
:
(
new
Date
(
)
)
.
toUTCString
(
)
time
:
(
stats
.
duration
/
1000
)
|
|
0
}
false
)
)
;
tests
.
forEach
(
function
(
t
)
{
self
.
test
(
t
)
;
}
)
;
self
.
write
(
'
<
/
testsuite
>
'
)
;
}
)
;
}
inherits
(
XUnit
Base
)
;
XUnit
.
prototype
.
done
=
function
(
failures
fn
)
{
if
(
this
.
fileStream
)
{
this
.
fileStream
.
end
(
function
(
)
{
fn
(
failures
)
;
}
)
;
}
else
{
fn
(
failures
)
;
}
}
;
XUnit
.
prototype
.
write
=
function
(
line
)
{
if
(
this
.
fileStream
)
{
this
.
fileStream
.
write
(
line
+
'
\
n
'
)
;
}
else
if
(
typeof
process
=
=
=
'
object
'
&
&
process
.
stdout
)
{
process
.
stdout
.
write
(
line
+
'
\
n
'
)
;
}
else
{
console
.
log
(
line
)
;
}
}
;
XUnit
.
prototype
.
test
=
function
(
test
)
{
var
attrs
=
{
classname
:
test
.
parent
.
fullTitle
(
)
name
:
test
.
title
time
:
(
test
.
duration
/
1000
)
|
|
0
}
;
if
(
test
.
state
=
=
=
'
failed
'
)
{
var
err
=
test
.
err
;
this
.
write
(
tag
(
'
testcase
'
attrs
false
tag
(
'
failure
'
{
}
false
escape
(
err
.
message
)
+
'
\
n
'
+
escape
(
err
.
stack
)
)
)
)
;
}
else
if
(
test
.
isPending
(
)
)
{
this
.
write
(
tag
(
'
testcase
'
attrs
false
tag
(
'
skipped
'
{
}
true
)
)
)
;
}
else
{
this
.
write
(
tag
(
'
testcase
'
attrs
true
)
)
;
}
}
;
function
tag
(
name
attrs
close
content
)
{
var
end
=
close
?
'
/
>
'
:
'
>
'
;
var
pairs
=
[
]
;
var
tag
;
for
(
var
key
in
attrs
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
attrs
key
)
)
{
pairs
.
push
(
key
+
'
=
"
'
+
escape
(
attrs
[
key
]
)
+
'
"
'
)
;
}
}
tag
=
'
<
'
+
name
+
(
pairs
.
length
?
'
'
+
pairs
.
join
(
'
'
)
:
'
'
)
+
end
;
if
(
content
)
{
tag
+
=
content
+
'
<
/
'
+
name
+
end
;
}
return
tag
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
.
.
/
utils
"
:
38
"
.
/
base
"
:
17
"
_process
"
:
82
"
fs
"
:
42
"
mkdirp
"
:
79
"
path
"
:
42
}
]
33
:
[
function
(
require
module
exports
)
{
(
function
(
global
)
{
'
use
strict
'
;
var
EventEmitter
=
require
(
'
events
'
)
.
EventEmitter
;
var
JSON
=
require
(
'
json3
'
)
;
var
Pending
=
require
(
'
.
/
pending
'
)
;
var
debug
=
require
(
'
debug
'
)
(
'
mocha
:
runnable
'
)
;
var
milliseconds
=
require
(
'
.
/
ms
'
)
;
var
utils
=
require
(
'
.
/
utils
'
)
;
var
create
=
require
(
'
lodash
.
create
'
)
;
var
Date
=
global
.
Date
;
var
setTimeout
=
global
.
setTimeout
;
var
setInterval
=
global
.
setInterval
;
var
clearTimeout
=
global
.
clearTimeout
;
var
clearInterval
=
global
.
clearInterval
;
var
toString
=
Object
.
prototype
.
toString
;
module
.
exports
=
Runnable
;
function
Runnable
(
title
fn
)
{
this
.
title
=
title
;
this
.
fn
=
fn
;
this
.
body
=
(
fn
|
|
'
'
)
.
toString
(
)
;
this
.
async
=
fn
&
&
fn
.
length
;
this
.
sync
=
!
this
.
async
;
this
.
_timeout
=
2000
;
this
.
_slow
=
75
;
this
.
_enableTimeouts
=
true
;
this
.
timedOut
=
false
;
this
.
_trace
=
new
Error
(
'
done
(
)
called
multiple
times
'
)
;
this
.
_retries
=
-
1
;
this
.
_currentRetry
=
0
;
this
.
pending
=
false
;
}
Runnable
.
prototype
=
create
(
EventEmitter
.
prototype
{
constructor
:
Runnable
}
)
;
Runnable
.
prototype
.
timeout
=
function
(
ms
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_timeout
;
}
if
(
ms
=
=
=
0
|
|
ms
>
Math
.
pow
(
2
31
)
)
{
this
.
_enableTimeouts
=
false
;
}
if
(
typeof
ms
=
=
=
'
string
'
)
{
ms
=
milliseconds
(
ms
)
;
}
debug
(
'
timeout
%
d
'
ms
)
;
this
.
_timeout
=
ms
;
if
(
this
.
timer
)
{
this
.
resetTimeout
(
)
;
}
return
this
;
}
;
Runnable
.
prototype
.
slow
=
function
(
ms
)
{
if
(
typeof
ms
=
=
=
'
undefined
'
)
{
return
this
.
_slow
;
}
if
(
typeof
ms
=
=
=
'
string
'
)
{
ms
=
milliseconds
(
ms
)
;
}
debug
(
'
timeout
%
d
'
ms
)
;
this
.
_slow
=
ms
;
return
this
;
}
;
Runnable
.
prototype
.
enableTimeouts
=
function
(
enabled
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_enableTimeouts
;
}
debug
(
'
enableTimeouts
%
s
'
enabled
)
;
this
.
_enableTimeouts
=
enabled
;
return
this
;
}
;
Runnable
.
prototype
.
skip
=
function
(
)
{
throw
new
Pending
(
'
sync
skip
'
)
;
}
;
Runnable
.
prototype
.
isPending
=
function
(
)
{
return
this
.
pending
|
|
(
this
.
parent
&
&
this
.
parent
.
isPending
(
)
)
;
}
;
Runnable
.
prototype
.
retries
=
function
(
n
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_retries
;
}
this
.
_retries
=
n
;
}
;
Runnable
.
prototype
.
currentRetry
=
function
(
n
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_currentRetry
;
}
this
.
_currentRetry
=
n
;
}
;
Runnable
.
prototype
.
fullTitle
=
function
(
)
{
return
this
.
parent
.
fullTitle
(
)
+
'
'
+
this
.
title
;
}
;
Runnable
.
prototype
.
clearTimeout
=
function
(
)
{
clearTimeout
(
this
.
timer
)
;
}
;
Runnable
.
prototype
.
inspect
=
function
(
)
{
return
JSON
.
stringify
(
this
function
(
key
val
)
{
if
(
key
[
0
]
=
=
=
'
_
'
)
{
return
;
}
if
(
key
=
=
=
'
parent
'
)
{
return
'
#
<
Suite
>
'
;
}
if
(
key
=
=
=
'
ctx
'
)
{
return
'
#
<
Context
>
'
;
}
return
val
;
}
2
)
;
}
;
Runnable
.
prototype
.
resetTimeout
=
function
(
)
{
var
self
=
this
;
var
ms
=
this
.
timeout
(
)
|
|
1e9
;
if
(
!
this
.
_enableTimeouts
)
{
return
;
}
this
.
clearTimeout
(
)
;
this
.
timer
=
setTimeout
(
function
(
)
{
if
(
!
self
.
_enableTimeouts
)
{
return
;
}
self
.
callback
(
new
Error
(
'
Timeout
of
'
+
ms
+
'
ms
exceeded
.
For
async
tests
and
hooks
ensure
"
done
(
)
"
is
called
;
if
returning
a
Promise
ensure
it
resolves
.
'
)
)
;
self
.
timedOut
=
true
;
}
ms
)
;
}
;
Runnable
.
prototype
.
globals
=
function
(
globals
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_allowedGlobals
;
}
this
.
_allowedGlobals
=
globals
;
}
;
Runnable
.
prototype
.
run
=
function
(
fn
)
{
var
self
=
this
;
var
start
=
new
Date
(
)
;
var
ctx
=
this
.
ctx
;
var
finished
;
var
emitted
;
if
(
ctx
&
&
ctx
.
runnable
)
{
ctx
.
runnable
(
this
)
;
}
function
multiple
(
err
)
{
if
(
emitted
)
{
return
;
}
emitted
=
true
;
self
.
emit
(
'
error
'
err
|
|
new
Error
(
'
done
(
)
called
multiple
times
;
stacktrace
may
be
inaccurate
'
)
)
;
}
function
done
(
err
)
{
var
ms
=
self
.
timeout
(
)
;
if
(
self
.
timedOut
)
{
return
;
}
if
(
finished
)
{
return
multiple
(
err
|
|
self
.
_trace
)
;
}
self
.
clearTimeout
(
)
;
self
.
duration
=
new
Date
(
)
-
start
;
finished
=
true
;
if
(
!
err
&
&
self
.
duration
>
ms
&
&
self
.
_enableTimeouts
)
{
err
=
new
Error
(
'
Timeout
of
'
+
ms
+
'
ms
exceeded
.
For
async
tests
and
hooks
ensure
"
done
(
)
"
is
called
;
if
returning
a
Promise
ensure
it
resolves
.
'
)
;
}
fn
(
err
)
;
}
this
.
callback
=
done
;
if
(
this
.
async
)
{
this
.
resetTimeout
(
)
;
this
.
skip
=
function
asyncSkip
(
)
{
done
(
new
Pending
(
'
async
skip
call
'
)
)
;
throw
new
Pending
(
'
async
skip
;
aborting
execution
'
)
;
}
;
if
(
this
.
allowUncaught
)
{
return
callFnAsync
(
this
.
fn
)
;
}
try
{
callFnAsync
(
this
.
fn
)
;
}
catch
(
err
)
{
emitted
=
true
;
done
(
utils
.
getError
(
err
)
)
;
}
return
;
}
if
(
this
.
allowUncaught
)
{
if
(
this
.
isPending
(
)
)
{
done
(
)
;
}
else
{
callFn
(
this
.
fn
)
;
}
return
;
}
try
{
if
(
this
.
isPending
(
)
)
{
done
(
)
;
}
else
{
callFn
(
this
.
fn
)
;
}
}
catch
(
err
)
{
emitted
=
true
;
done
(
utils
.
getError
(
err
)
)
;
}
function
callFn
(
fn
)
{
var
result
=
fn
.
call
(
ctx
)
;
if
(
result
&
&
typeof
result
.
then
=
=
=
'
function
'
)
{
self
.
resetTimeout
(
)
;
result
.
then
(
function
(
)
{
done
(
)
;
return
null
;
}
function
(
reason
)
{
done
(
reason
|
|
new
Error
(
'
Promise
rejected
with
no
or
falsy
reason
'
)
)
;
}
)
;
}
else
{
if
(
self
.
asyncOnly
)
{
return
done
(
new
Error
(
'
-
-
async
-
only
option
in
use
without
declaring
done
(
)
or
returning
a
promise
'
)
)
;
}
done
(
)
;
}
}
function
callFnAsync
(
fn
)
{
var
result
=
fn
.
call
(
ctx
function
(
err
)
{
if
(
err
instanceof
Error
|
|
toString
.
call
(
err
)
=
=
=
'
[
object
Error
]
'
)
{
return
done
(
err
)
;
}
if
(
err
)
{
if
(
Object
.
prototype
.
toString
.
call
(
err
)
=
=
=
'
[
object
Object
]
'
)
{
return
done
(
new
Error
(
'
done
(
)
invoked
with
non
-
Error
:
'
+
JSON
.
stringify
(
err
)
)
)
;
}
return
done
(
new
Error
(
'
done
(
)
invoked
with
non
-
Error
:
'
+
err
)
)
;
}
if
(
result
&
&
utils
.
isPromise
(
result
)
)
{
return
done
(
new
Error
(
'
Resolution
method
is
overspecified
.
Specify
a
callback
*
or
*
return
a
Promise
;
not
both
.
'
)
)
;
}
done
(
)
;
}
)
;
}
}
;
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
.
/
ms
"
:
15
"
.
/
pending
"
:
16
"
.
/
utils
"
:
38
"
debug
"
:
2
"
events
"
:
3
"
json3
"
:
69
"
lodash
.
create
"
:
75
}
]
34
:
[
function
(
require
module
exports
)
{
(
function
(
process
global
)
{
'
use
strict
'
;
var
EventEmitter
=
require
(
'
events
'
)
.
EventEmitter
;
var
Pending
=
require
(
'
.
/
pending
'
)
;
var
utils
=
require
(
'
.
/
utils
'
)
;
var
inherits
=
utils
.
inherits
;
var
debug
=
require
(
'
debug
'
)
(
'
mocha
:
runner
'
)
;
var
Runnable
=
require
(
'
.
/
runnable
'
)
;
var
filter
=
utils
.
filter
;
var
indexOf
=
utils
.
indexOf
;
var
some
=
utils
.
some
;
var
keys
=
utils
.
keys
;
var
stackFilter
=
utils
.
stackTraceFilter
(
)
;
var
stringify
=
utils
.
stringify
;
var
type
=
utils
.
type
;
var
undefinedError
=
utils
.
undefinedError
;
var
isArray
=
utils
.
isArray
;
var
globals
=
[
'
setTimeout
'
'
clearTimeout
'
'
setInterval
'
'
clearInterval
'
'
XMLHttpRequest
'
'
Date
'
'
setImmediate
'
'
clearImmediate
'
]
;
module
.
exports
=
Runner
;
function
Runner
(
suite
delay
)
{
var
self
=
this
;
this
.
_globals
=
[
]
;
this
.
_abort
=
false
;
this
.
_delay
=
delay
;
this
.
suite
=
suite
;
this
.
started
=
false
;
this
.
total
=
suite
.
total
(
)
;
this
.
failures
=
0
;
this
.
on
(
'
test
end
'
function
(
test
)
{
self
.
checkGlobals
(
test
)
;
}
)
;
this
.
on
(
'
hook
end
'
function
(
hook
)
{
self
.
checkGlobals
(
hook
)
;
}
)
;
this
.
_defaultGrep
=
/
.
*
/
;
this
.
grep
(
this
.
_defaultGrep
)
;
this
.
globals
(
this
.
globalProps
(
)
.
concat
(
extraGlobals
(
)
)
)
;
}
Runner
.
immediately
=
global
.
setImmediate
|
|
process
.
nextTick
;
inherits
(
Runner
EventEmitter
)
;
Runner
.
prototype
.
grep
=
function
(
re
invert
)
{
debug
(
'
grep
%
s
'
re
)
;
this
.
_grep
=
re
;
this
.
_invert
=
invert
;
this
.
total
=
this
.
grepTotal
(
this
.
suite
)
;
return
this
;
}
;
Runner
.
prototype
.
grepTotal
=
function
(
suite
)
{
var
self
=
this
;
var
total
=
0
;
suite
.
eachTest
(
function
(
test
)
{
var
match
=
self
.
_grep
.
test
(
test
.
fullTitle
(
)
)
;
if
(
self
.
_invert
)
{
match
=
!
match
;
}
if
(
match
)
{
total
+
+
;
}
}
)
;
return
total
;
}
;
Runner
.
prototype
.
globalProps
=
function
(
)
{
var
props
=
keys
(
global
)
;
for
(
var
i
=
0
;
i
<
globals
.
length
;
+
+
i
)
{
if
(
~
indexOf
(
props
globals
[
i
]
)
)
{
continue
;
}
props
.
push
(
globals
[
i
]
)
;
}
return
props
;
}
;
Runner
.
prototype
.
globals
=
function
(
arr
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_globals
;
}
debug
(
'
globals
%
j
'
arr
)
;
this
.
_globals
=
this
.
_globals
.
concat
(
arr
)
;
return
this
;
}
;
Runner
.
prototype
.
checkGlobals
=
function
(
test
)
{
if
(
this
.
ignoreLeaks
)
{
return
;
}
var
ok
=
this
.
_globals
;
var
globals
=
this
.
globalProps
(
)
;
var
leaks
;
if
(
test
)
{
ok
=
ok
.
concat
(
test
.
_allowedGlobals
|
|
[
]
)
;
}
if
(
this
.
prevGlobalsLength
=
=
=
globals
.
length
)
{
return
;
}
this
.
prevGlobalsLength
=
globals
.
length
;
leaks
=
filterLeaks
(
ok
globals
)
;
this
.
_globals
=
this
.
_globals
.
concat
(
leaks
)
;
if
(
leaks
.
length
>
1
)
{
this
.
fail
(
test
new
Error
(
'
global
leaks
detected
:
'
+
leaks
.
join
(
'
'
)
+
'
'
)
)
;
}
else
if
(
leaks
.
length
)
{
this
.
fail
(
test
new
Error
(
'
global
leak
detected
:
'
+
leaks
[
0
]
)
)
;
}
}
;
Runner
.
prototype
.
fail
=
function
(
test
err
)
{
if
(
test
.
isPending
(
)
)
{
return
;
}
+
+
this
.
failures
;
test
.
state
=
'
failed
'
;
if
(
!
(
err
instanceof
Error
|
|
err
&
&
typeof
err
.
message
=
=
=
'
string
'
)
)
{
err
=
new
Error
(
'
the
'
+
type
(
err
)
+
'
'
+
stringify
(
err
)
+
'
was
thrown
throw
an
Error
:
)
'
)
;
}
try
{
err
.
stack
=
(
this
.
fullStackTrace
|
|
!
err
.
stack
)
?
err
.
stack
:
stackFilter
(
err
.
stack
)
;
}
catch
(
ignored
)
{
}
this
.
emit
(
'
fail
'
test
err
)
;
}
;
Runner
.
prototype
.
failHook
=
function
(
hook
err
)
{
if
(
hook
.
ctx
&
&
hook
.
ctx
.
currentTest
)
{
hook
.
originalTitle
=
hook
.
originalTitle
|
|
hook
.
title
;
hook
.
title
=
hook
.
originalTitle
+
'
for
"
'
+
hook
.
ctx
.
currentTest
.
title
+
'
"
'
;
}
this
.
fail
(
hook
err
)
;
if
(
this
.
suite
.
bail
(
)
)
{
this
.
emit
(
'
end
'
)
;
}
}
;
Runner
.
prototype
.
hook
=
function
(
name
fn
)
{
var
suite
=
this
.
suite
;
var
hooks
=
suite
[
'
_
'
+
name
]
;
var
self
=
this
;
function
next
(
i
)
{
var
hook
=
hooks
[
i
]
;
if
(
!
hook
)
{
return
fn
(
)
;
}
self
.
currentRunnable
=
hook
;
hook
.
ctx
.
currentTest
=
self
.
test
;
self
.
emit
(
'
hook
'
hook
)
;
if
(
!
hook
.
listeners
(
'
error
'
)
.
length
)
{
hook
.
on
(
'
error
'
function
(
err
)
{
self
.
failHook
(
hook
err
)
;
}
)
;
}
hook
.
run
(
function
(
err
)
{
var
testError
=
hook
.
error
(
)
;
if
(
testError
)
{
self
.
fail
(
self
.
test
testError
)
;
}
if
(
err
)
{
if
(
err
instanceof
Pending
)
{
if
(
name
=
=
=
'
beforeEach
'
|
|
name
=
=
=
'
afterEach
'
)
{
self
.
test
.
pending
=
true
;
}
else
{
utils
.
forEach
(
suite
.
tests
function
(
test
)
{
test
.
pending
=
true
;
}
)
;
hook
.
pending
=
true
;
}
}
else
{
self
.
failHook
(
hook
err
)
;
return
fn
(
err
)
;
}
}
self
.
emit
(
'
hook
end
'
hook
)
;
delete
hook
.
ctx
.
currentTest
;
next
(
+
+
i
)
;
}
)
;
}
Runner
.
immediately
(
function
(
)
{
next
(
0
)
;
}
)
;
}
;
Runner
.
prototype
.
hooks
=
function
(
name
suites
fn
)
{
var
self
=
this
;
var
orig
=
this
.
suite
;
function
next
(
suite
)
{
self
.
suite
=
suite
;
if
(
!
suite
)
{
self
.
suite
=
orig
;
return
fn
(
)
;
}
self
.
hook
(
name
function
(
err
)
{
if
(
err
)
{
var
errSuite
=
self
.
suite
;
self
.
suite
=
orig
;
return
fn
(
err
errSuite
)
;
}
next
(
suites
.
pop
(
)
)
;
}
)
;
}
next
(
suites
.
pop
(
)
)
;
}
;
Runner
.
prototype
.
hookUp
=
function
(
name
fn
)
{
var
suites
=
[
this
.
suite
]
.
concat
(
this
.
parents
(
)
)
.
reverse
(
)
;
this
.
hooks
(
name
suites
fn
)
;
}
;
Runner
.
prototype
.
hookDown
=
function
(
name
fn
)
{
var
suites
=
[
this
.
suite
]
.
concat
(
this
.
parents
(
)
)
;
this
.
hooks
(
name
suites
fn
)
;
}
;
Runner
.
prototype
.
parents
=
function
(
)
{
var
suite
=
this
.
suite
;
var
suites
=
[
]
;
while
(
suite
.
parent
)
{
suite
=
suite
.
parent
;
suites
.
push
(
suite
)
;
}
return
suites
;
}
;
Runner
.
prototype
.
runTest
=
function
(
fn
)
{
var
self
=
this
;
var
test
=
this
.
test
;
if
(
!
test
)
{
return
;
}
if
(
this
.
asyncOnly
)
{
test
.
asyncOnly
=
true
;
}
test
.
on
(
'
error
'
function
(
err
)
{
self
.
fail
(
test
err
)
;
}
)
;
if
(
this
.
allowUncaught
)
{
test
.
allowUncaught
=
true
;
return
test
.
run
(
fn
)
;
}
try
{
test
.
run
(
fn
)
;
}
catch
(
err
)
{
fn
(
err
)
;
}
}
;
Runner
.
prototype
.
runTests
=
function
(
suite
fn
)
{
var
self
=
this
;
var
tests
=
suite
.
tests
.
slice
(
)
;
var
test
;
function
hookErr
(
_
errSuite
after
)
{
var
orig
=
self
.
suite
;
self
.
suite
=
after
?
errSuite
.
parent
:
errSuite
;
if
(
self
.
suite
)
{
self
.
hookUp
(
'
afterEach
'
function
(
err2
errSuite2
)
{
self
.
suite
=
orig
;
if
(
err2
)
{
return
hookErr
(
err2
errSuite2
true
)
;
}
fn
(
errSuite
)
;
}
)
;
}
else
{
self
.
suite
=
orig
;
fn
(
errSuite
)
;
}
}
function
next
(
err
errSuite
)
{
if
(
self
.
failures
&
&
suite
.
_bail
)
{
return
fn
(
)
;
}
if
(
self
.
_abort
)
{
return
fn
(
)
;
}
if
(
err
)
{
return
hookErr
(
err
errSuite
true
)
;
}
test
=
tests
.
shift
(
)
;
if
(
!
test
)
{
return
fn
(
)
;
}
var
match
=
self
.
_grep
.
test
(
test
.
fullTitle
(
)
)
;
if
(
self
.
_invert
)
{
match
=
!
match
;
}
if
(
!
match
)
{
if
(
self
.
_grep
!
=
=
self
.
_defaultGrep
)
{
Runner
.
immediately
(
next
)
;
}
else
{
next
(
)
;
}
return
;
}
if
(
test
.
isPending
(
)
)
{
self
.
emit
(
'
pending
'
test
)
;
self
.
emit
(
'
test
end
'
test
)
;
return
next
(
)
;
}
self
.
emit
(
'
test
'
self
.
test
=
test
)
;
self
.
hookDown
(
'
beforeEach
'
function
(
err
errSuite
)
{
if
(
test
.
isPending
(
)
)
{
self
.
emit
(
'
pending
'
test
)
;
self
.
emit
(
'
test
end
'
test
)
;
return
next
(
)
;
}
if
(
err
)
{
return
hookErr
(
err
errSuite
false
)
;
}
self
.
currentRunnable
=
self
.
test
;
self
.
runTest
(
function
(
err
)
{
test
=
self
.
test
;
if
(
err
)
{
var
retry
=
test
.
currentRetry
(
)
;
if
(
err
instanceof
Pending
)
{
test
.
pending
=
true
;
self
.
emit
(
'
pending
'
test
)
;
}
else
if
(
retry
<
test
.
retries
(
)
)
{
var
clonedTest
=
test
.
clone
(
)
;
clonedTest
.
currentRetry
(
retry
+
1
)
;
tests
.
unshift
(
clonedTest
)
;
return
self
.
hookUp
(
'
afterEach
'
next
)
;
}
else
{
self
.
fail
(
test
err
)
;
}
self
.
emit
(
'
test
end
'
test
)
;
if
(
err
instanceof
Pending
)
{
return
next
(
)
;
}
return
self
.
hookUp
(
'
afterEach
'
next
)
;
}
test
.
state
=
'
passed
'
;
self
.
emit
(
'
pass
'
test
)
;
self
.
emit
(
'
test
end
'
test
)
;
self
.
hookUp
(
'
afterEach
'
next
)
;
}
)
;
}
)
;
}
this
.
next
=
next
;
this
.
hookErr
=
hookErr
;
next
(
)
;
}
;
Runner
.
prototype
.
runSuite
=
function
(
suite
fn
)
{
var
i
=
0
;
var
self
=
this
;
var
total
=
this
.
grepTotal
(
suite
)
;
var
afterAllHookCalled
=
false
;
debug
(
'
run
suite
%
s
'
suite
.
fullTitle
(
)
)
;
if
(
!
total
|
|
(
self
.
failures
&
&
suite
.
_bail
)
)
{
return
fn
(
)
;
}
this
.
emit
(
'
suite
'
this
.
suite
=
suite
)
;
function
next
(
errSuite
)
{
if
(
errSuite
)
{
if
(
errSuite
=
=
=
suite
)
{
return
done
(
)
;
}
return
done
(
errSuite
)
;
}
if
(
self
.
_abort
)
{
return
done
(
)
;
}
var
curr
=
suite
.
suites
[
i
+
+
]
;
if
(
!
curr
)
{
return
done
(
)
;
}
if
(
self
.
_grep
!
=
=
self
.
_defaultGrep
)
{
Runner
.
immediately
(
function
(
)
{
self
.
runSuite
(
curr
next
)
;
}
)
;
}
else
{
self
.
runSuite
(
curr
next
)
;
}
}
function
done
(
errSuite
)
{
self
.
suite
=
suite
;
self
.
nextSuite
=
next
;
if
(
afterAllHookCalled
)
{
fn
(
errSuite
)
;
}
else
{
afterAllHookCalled
=
true
;
delete
self
.
test
;
self
.
hook
(
'
afterAll
'
function
(
)
{
self
.
emit
(
'
suite
end
'
suite
)
;
fn
(
errSuite
)
;
}
)
;
}
}
this
.
nextSuite
=
next
;
this
.
hook
(
'
beforeAll
'
function
(
err
)
{
if
(
err
)
{
return
done
(
)
;
}
self
.
runTests
(
suite
next
)
;
}
)
;
}
;
Runner
.
prototype
.
uncaught
=
function
(
err
)
{
if
(
err
)
{
debug
(
'
uncaught
exception
%
s
'
err
=
=
=
(
function
(
)
{
return
this
;
}
.
call
(
err
)
)
?
(
err
.
message
|
|
err
)
:
err
)
;
}
else
{
debug
(
'
uncaught
undefined
exception
'
)
;
err
=
undefinedError
(
)
;
}
err
.
uncaught
=
true
;
var
runnable
=
this
.
currentRunnable
;
if
(
!
runnable
)
{
runnable
=
new
Runnable
(
'
Uncaught
error
outside
test
suite
'
)
;
runnable
.
parent
=
this
.
suite
;
if
(
this
.
started
)
{
this
.
fail
(
runnable
err
)
;
}
else
{
this
.
emit
(
'
start
'
)
;
this
.
fail
(
runnable
err
)
;
this
.
emit
(
'
end
'
)
;
}
return
;
}
runnable
.
clearTimeout
(
)
;
if
(
runnable
.
state
|
|
runnable
.
isPending
(
)
)
{
return
;
}
this
.
fail
(
runnable
err
)
;
if
(
runnable
.
type
=
=
=
'
test
'
)
{
this
.
emit
(
'
test
end
'
runnable
)
;
this
.
hookUp
(
'
afterEach
'
this
.
next
)
;
return
;
}
if
(
runnable
.
type
=
=
=
'
hook
'
)
{
var
errSuite
=
this
.
suite
;
if
(
runnable
.
fullTitle
(
)
.
indexOf
(
'
after
each
'
)
>
-
1
)
{
return
this
.
hookErr
(
err
errSuite
true
)
;
}
if
(
runnable
.
fullTitle
(
)
.
indexOf
(
'
before
each
'
)
>
-
1
)
{
return
this
.
hookErr
(
err
errSuite
false
)
;
}
return
this
.
nextSuite
(
errSuite
)
;
}
this
.
emit
(
'
end
'
)
;
}
;
function
cleanSuiteReferences
(
suite
)
{
function
cleanArrReferences
(
arr
)
{
for
(
var
i
=
0
;
i
<
arr
.
length
;
i
+
+
)
{
delete
arr
[
i
]
.
fn
;
}
}
if
(
isArray
(
suite
.
_beforeAll
)
)
{
cleanArrReferences
(
suite
.
_beforeAll
)
;
}
if
(
isArray
(
suite
.
_beforeEach
)
)
{
cleanArrReferences
(
suite
.
_beforeEach
)
;
}
if
(
isArray
(
suite
.
_afterAll
)
)
{
cleanArrReferences
(
suite
.
_afterAll
)
;
}
if
(
isArray
(
suite
.
_afterEach
)
)
{
cleanArrReferences
(
suite
.
_afterEach
)
;
}
for
(
var
i
=
0
;
i
<
suite
.
tests
.
length
;
i
+
+
)
{
delete
suite
.
tests
[
i
]
.
fn
;
}
}
Runner
.
prototype
.
run
=
function
(
fn
)
{
var
self
=
this
;
var
rootSuite
=
this
.
suite
;
if
(
this
.
hasOnly
)
{
filterOnly
(
rootSuite
)
;
}
fn
=
fn
|
|
function
(
)
{
}
;
function
uncaught
(
err
)
{
self
.
uncaught
(
err
)
;
}
function
start
(
)
{
self
.
started
=
true
;
self
.
emit
(
'
start
'
)
;
self
.
runSuite
(
rootSuite
function
(
)
{
debug
(
'
finished
running
'
)
;
self
.
emit
(
'
end
'
)
;
}
)
;
}
debug
(
'
start
'
)
;
this
.
on
(
'
suite
end
'
cleanSuiteReferences
)
;
this
.
on
(
'
end
'
function
(
)
{
debug
(
'
end
'
)
;
process
.
removeListener
(
'
uncaughtException
'
uncaught
)
;
fn
(
self
.
failures
)
;
}
)
;
process
.
on
(
'
uncaughtException
'
uncaught
)
;
if
(
this
.
_delay
)
{
this
.
emit
(
'
waiting
'
rootSuite
)
;
rootSuite
.
once
(
'
run
'
start
)
;
}
else
{
start
(
)
;
}
return
this
;
}
;
Runner
.
prototype
.
abort
=
function
(
)
{
debug
(
'
aborting
'
)
;
this
.
_abort
=
true
;
return
this
;
}
;
function
filterOnly
(
suite
)
{
if
(
suite
.
_onlyTests
.
length
)
{
suite
.
tests
=
suite
.
_onlyTests
;
suite
.
suites
=
[
]
;
}
else
{
suite
.
tests
=
[
]
;
utils
.
forEach
(
suite
.
_onlySuites
function
(
onlySuite
)
{
if
(
hasOnly
(
onlySuite
)
)
{
filterOnly
(
onlySuite
)
;
}
}
)
;
suite
.
suites
=
filter
(
suite
.
suites
function
(
childSuite
)
{
return
indexOf
(
suite
.
_onlySuites
childSuite
)
!
=
=
-
1
|
|
filterOnly
(
childSuite
)
;
}
)
;
}
return
suite
.
tests
.
length
|
|
suite
.
suites
.
length
;
}
function
hasOnly
(
suite
)
{
return
suite
.
_onlyTests
.
length
|
|
suite
.
_onlySuites
.
length
|
|
some
(
suite
.
suites
hasOnly
)
;
}
function
filterLeaks
(
ok
globals
)
{
return
filter
(
globals
function
(
key
)
{
if
(
/
^
\
d
+
/
.
test
(
key
)
)
{
return
false
;
}
if
(
global
.
navigator
&
&
(
/
^
getInterface
/
)
.
test
(
key
)
)
{
return
false
;
}
if
(
global
.
navigator
&
&
(
/
^
\
d
+
/
)
.
test
(
key
)
)
{
return
false
;
}
if
(
/
^
mocha
-
/
.
test
(
key
)
)
{
return
false
;
}
var
matched
=
filter
(
ok
function
(
ok
)
{
if
(
~
ok
.
indexOf
(
'
*
'
)
)
{
return
key
.
indexOf
(
ok
.
split
(
'
*
'
)
[
0
]
)
=
=
=
0
;
}
return
key
=
=
=
ok
;
}
)
;
return
!
matched
.
length
&
&
(
!
global
.
navigator
|
|
key
!
=
=
'
onerror
'
)
;
}
)
;
}
function
extraGlobals
(
)
{
if
(
typeof
process
=
=
=
'
object
'
&
&
typeof
process
.
version
=
=
=
'
string
'
)
{
var
parts
=
process
.
version
.
split
(
'
.
'
)
;
var
nodeVersion
=
utils
.
reduce
(
parts
function
(
a
v
)
{
return
a
<
<
8
|
v
;
}
)
;
if
(
nodeVersion
<
0x00090B
)
{
return
[
'
errno
'
]
;
}
}
return
[
]
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
.
/
pending
"
:
16
"
.
/
runnable
"
:
33
"
.
/
utils
"
:
38
"
_process
"
:
82
"
debug
"
:
2
"
events
"
:
3
}
]
35
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
EventEmitter
=
require
(
'
events
'
)
.
EventEmitter
;
var
Hook
=
require
(
'
.
/
hook
'
)
;
var
utils
=
require
(
'
.
/
utils
'
)
;
var
inherits
=
utils
.
inherits
;
var
debug
=
require
(
'
debug
'
)
(
'
mocha
:
suite
'
)
;
var
milliseconds
=
require
(
'
.
/
ms
'
)
;
exports
=
module
.
exports
=
Suite
;
exports
.
create
=
function
(
parent
title
)
{
var
suite
=
new
Suite
(
title
parent
.
ctx
)
;
suite
.
parent
=
parent
;
title
=
suite
.
fullTitle
(
)
;
parent
.
addSuite
(
suite
)
;
return
suite
;
}
;
function
Suite
(
title
parentContext
)
{
if
(
!
utils
.
isString
(
title
)
)
{
throw
new
Error
(
'
Suite
title
should
be
a
"
string
"
but
"
'
+
typeof
title
+
'
"
was
given
instead
.
'
)
;
}
this
.
title
=
title
;
function
Context
(
)
{
}
Context
.
prototype
=
parentContext
;
this
.
ctx
=
new
Context
(
)
;
this
.
suites
=
[
]
;
this
.
tests
=
[
]
;
this
.
pending
=
false
;
this
.
_beforeEach
=
[
]
;
this
.
_beforeAll
=
[
]
;
this
.
_afterEach
=
[
]
;
this
.
_afterAll
=
[
]
;
this
.
root
=
!
title
;
this
.
_timeout
=
2000
;
this
.
_enableTimeouts
=
true
;
this
.
_slow
=
75
;
this
.
_bail
=
false
;
this
.
_retries
=
-
1
;
this
.
_onlyTests
=
[
]
;
this
.
_onlySuites
=
[
]
;
this
.
delayed
=
false
;
}
inherits
(
Suite
EventEmitter
)
;
Suite
.
prototype
.
clone
=
function
(
)
{
var
suite
=
new
Suite
(
this
.
title
)
;
debug
(
'
clone
'
)
;
suite
.
ctx
=
this
.
ctx
;
suite
.
timeout
(
this
.
timeout
(
)
)
;
suite
.
retries
(
this
.
retries
(
)
)
;
suite
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
suite
.
slow
(
this
.
slow
(
)
)
;
suite
.
bail
(
this
.
bail
(
)
)
;
return
suite
;
}
;
Suite
.
prototype
.
timeout
=
function
(
ms
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_timeout
;
}
if
(
ms
.
toString
(
)
=
=
=
'
0
'
)
{
this
.
_enableTimeouts
=
false
;
}
if
(
typeof
ms
=
=
=
'
string
'
)
{
ms
=
milliseconds
(
ms
)
;
}
debug
(
'
timeout
%
d
'
ms
)
;
this
.
_timeout
=
parseInt
(
ms
10
)
;
return
this
;
}
;
Suite
.
prototype
.
retries
=
function
(
n
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_retries
;
}
debug
(
'
retries
%
d
'
n
)
;
this
.
_retries
=
parseInt
(
n
10
)
|
|
0
;
return
this
;
}
;
Suite
.
prototype
.
enableTimeouts
=
function
(
enabled
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_enableTimeouts
;
}
debug
(
'
enableTimeouts
%
s
'
enabled
)
;
this
.
_enableTimeouts
=
enabled
;
return
this
;
}
;
Suite
.
prototype
.
slow
=
function
(
ms
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_slow
;
}
if
(
typeof
ms
=
=
=
'
string
'
)
{
ms
=
milliseconds
(
ms
)
;
}
debug
(
'
slow
%
d
'
ms
)
;
this
.
_slow
=
ms
;
return
this
;
}
;
Suite
.
prototype
.
bail
=
function
(
bail
)
{
if
(
!
arguments
.
length
)
{
return
this
.
_bail
;
}
debug
(
'
bail
%
s
'
bail
)
;
this
.
_bail
=
bail
;
return
this
;
}
;
Suite
.
prototype
.
isPending
=
function
(
)
{
return
this
.
pending
|
|
(
this
.
parent
&
&
this
.
parent
.
isPending
(
)
)
;
}
;
Suite
.
prototype
.
beforeAll
=
function
(
title
fn
)
{
if
(
this
.
isPending
(
)
)
{
return
this
;
}
if
(
typeof
title
=
=
=
'
function
'
)
{
fn
=
title
;
title
=
fn
.
name
;
}
title
=
'
"
before
all
"
hook
'
+
(
title
?
'
:
'
+
title
:
'
'
)
;
var
hook
=
new
Hook
(
title
fn
)
;
hook
.
parent
=
this
;
hook
.
timeout
(
this
.
timeout
(
)
)
;
hook
.
retries
(
this
.
retries
(
)
)
;
hook
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
hook
.
slow
(
this
.
slow
(
)
)
;
hook
.
ctx
=
this
.
ctx
;
this
.
_beforeAll
.
push
(
hook
)
;
this
.
emit
(
'
beforeAll
'
hook
)
;
return
this
;
}
;
Suite
.
prototype
.
afterAll
=
function
(
title
fn
)
{
if
(
this
.
isPending
(
)
)
{
return
this
;
}
if
(
typeof
title
=
=
=
'
function
'
)
{
fn
=
title
;
title
=
fn
.
name
;
}
title
=
'
"
after
all
"
hook
'
+
(
title
?
'
:
'
+
title
:
'
'
)
;
var
hook
=
new
Hook
(
title
fn
)
;
hook
.
parent
=
this
;
hook
.
timeout
(
this
.
timeout
(
)
)
;
hook
.
retries
(
this
.
retries
(
)
)
;
hook
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
hook
.
slow
(
this
.
slow
(
)
)
;
hook
.
ctx
=
this
.
ctx
;
this
.
_afterAll
.
push
(
hook
)
;
this
.
emit
(
'
afterAll
'
hook
)
;
return
this
;
}
;
Suite
.
prototype
.
beforeEach
=
function
(
title
fn
)
{
if
(
this
.
isPending
(
)
)
{
return
this
;
}
if
(
typeof
title
=
=
=
'
function
'
)
{
fn
=
title
;
title
=
fn
.
name
;
}
title
=
'
"
before
each
"
hook
'
+
(
title
?
'
:
'
+
title
:
'
'
)
;
var
hook
=
new
Hook
(
title
fn
)
;
hook
.
parent
=
this
;
hook
.
timeout
(
this
.
timeout
(
)
)
;
hook
.
retries
(
this
.
retries
(
)
)
;
hook
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
hook
.
slow
(
this
.
slow
(
)
)
;
hook
.
ctx
=
this
.
ctx
;
this
.
_beforeEach
.
push
(
hook
)
;
this
.
emit
(
'
beforeEach
'
hook
)
;
return
this
;
}
;
Suite
.
prototype
.
afterEach
=
function
(
title
fn
)
{
if
(
this
.
isPending
(
)
)
{
return
this
;
}
if
(
typeof
title
=
=
=
'
function
'
)
{
fn
=
title
;
title
=
fn
.
name
;
}
title
=
'
"
after
each
"
hook
'
+
(
title
?
'
:
'
+
title
:
'
'
)
;
var
hook
=
new
Hook
(
title
fn
)
;
hook
.
parent
=
this
;
hook
.
timeout
(
this
.
timeout
(
)
)
;
hook
.
retries
(
this
.
retries
(
)
)
;
hook
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
hook
.
slow
(
this
.
slow
(
)
)
;
hook
.
ctx
=
this
.
ctx
;
this
.
_afterEach
.
push
(
hook
)
;
this
.
emit
(
'
afterEach
'
hook
)
;
return
this
;
}
;
Suite
.
prototype
.
addSuite
=
function
(
suite
)
{
suite
.
parent
=
this
;
suite
.
timeout
(
this
.
timeout
(
)
)
;
suite
.
retries
(
this
.
retries
(
)
)
;
suite
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
suite
.
slow
(
this
.
slow
(
)
)
;
suite
.
bail
(
this
.
bail
(
)
)
;
this
.
suites
.
push
(
suite
)
;
this
.
emit
(
'
suite
'
suite
)
;
return
this
;
}
;
Suite
.
prototype
.
addTest
=
function
(
test
)
{
test
.
parent
=
this
;
test
.
timeout
(
this
.
timeout
(
)
)
;
test
.
retries
(
this
.
retries
(
)
)
;
test
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
test
.
slow
(
this
.
slow
(
)
)
;
test
.
ctx
=
this
.
ctx
;
this
.
tests
.
push
(
test
)
;
this
.
emit
(
'
test
'
test
)
;
return
this
;
}
;
Suite
.
prototype
.
fullTitle
=
function
(
)
{
if
(
this
.
parent
)
{
var
full
=
this
.
parent
.
fullTitle
(
)
;
if
(
full
)
{
return
full
+
'
'
+
this
.
title
;
}
}
return
this
.
title
;
}
;
Suite
.
prototype
.
total
=
function
(
)
{
return
utils
.
reduce
(
this
.
suites
function
(
sum
suite
)
{
return
sum
+
suite
.
total
(
)
;
}
0
)
+
this
.
tests
.
length
;
}
;
Suite
.
prototype
.
eachTest
=
function
(
fn
)
{
utils
.
forEach
(
this
.
tests
fn
)
;
utils
.
forEach
(
this
.
suites
function
(
suite
)
{
suite
.
eachTest
(
fn
)
;
}
)
;
return
this
;
}
;
Suite
.
prototype
.
run
=
function
run
(
)
{
if
(
this
.
root
)
{
this
.
emit
(
'
run
'
)
;
}
}
;
}
{
"
.
/
hook
"
:
7
"
.
/
ms
"
:
15
"
.
/
utils
"
:
38
"
debug
"
:
2
"
events
"
:
3
}
]
36
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Runnable
=
require
(
'
.
/
runnable
'
)
;
var
create
=
require
(
'
lodash
.
create
'
)
;
var
isString
=
require
(
'
.
/
utils
'
)
.
isString
;
module
.
exports
=
Test
;
function
Test
(
title
fn
)
{
if
(
!
isString
(
title
)
)
{
throw
new
Error
(
'
Test
title
should
be
a
"
string
"
but
"
'
+
typeof
title
+
'
"
was
given
instead
.
'
)
;
}
Runnable
.
call
(
this
title
fn
)
;
this
.
pending
=
!
fn
;
this
.
type
=
'
test
'
;
}
Test
.
prototype
=
create
(
Runnable
.
prototype
{
constructor
:
Test
}
)
;
Test
.
prototype
.
clone
=
function
(
)
{
var
test
=
new
Test
(
this
.
title
this
.
fn
)
;
test
.
timeout
(
this
.
timeout
(
)
)
;
test
.
slow
(
this
.
slow
(
)
)
;
test
.
enableTimeouts
(
this
.
enableTimeouts
(
)
)
;
test
.
retries
(
this
.
retries
(
)
)
;
test
.
currentRetry
(
this
.
currentRetry
(
)
)
;
test
.
globals
(
this
.
globals
(
)
)
;
test
.
parent
=
this
.
parent
;
test
.
file
=
this
.
file
;
test
.
ctx
=
this
.
ctx
;
return
test
;
}
;
}
{
"
.
/
runnable
"
:
33
"
.
/
utils
"
:
38
"
lodash
.
create
"
:
75
}
]
37
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
function
pad
(
number
)
{
var
n
=
number
.
toString
(
)
;
return
n
.
length
=
=
=
1
?
'
0
'
+
n
:
n
;
}
function
toISOString
(
date
)
{
return
date
.
getUTCFullYear
(
)
+
'
-
'
+
pad
(
date
.
getUTCMonth
(
)
+
1
)
+
'
-
'
+
pad
(
date
.
getUTCDate
(
)
)
+
'
T
'
+
pad
(
date
.
getUTCHours
(
)
)
+
'
:
'
+
pad
(
date
.
getUTCMinutes
(
)
)
+
'
:
'
+
pad
(
date
.
getUTCSeconds
(
)
)
+
'
.
'
+
String
(
(
date
.
getUTCMilliseconds
(
)
/
1000
)
.
toFixed
(
3
)
)
.
slice
(
2
5
)
+
'
Z
'
;
}
module
.
exports
=
toISOString
;
}
{
}
]
38
:
[
function
(
require
module
exports
)
{
(
function
(
process
Buffer
)
{
'
use
strict
'
;
var
JSON
=
require
(
'
json3
'
)
;
var
basename
=
require
(
'
path
'
)
.
basename
;
var
debug
=
require
(
'
debug
'
)
(
'
mocha
:
watch
'
)
;
var
exists
=
require
(
'
fs
'
)
.
existsSync
|
|
require
(
'
path
'
)
.
existsSync
;
var
glob
=
require
(
'
glob
'
)
;
var
path
=
require
(
'
path
'
)
;
var
join
=
path
.
join
;
var
readdirSync
=
require
(
'
fs
'
)
.
readdirSync
;
var
statSync
=
require
(
'
fs
'
)
.
statSync
;
var
watchFile
=
require
(
'
fs
'
)
.
watchFile
;
var
lstatSync
=
require
(
'
fs
'
)
.
lstatSync
;
var
toISOString
=
require
(
'
.
/
to
-
iso
-
string
'
)
;
var
ignore
=
[
'
node_modules
'
'
.
git
'
]
;
exports
.
inherits
=
require
(
'
util
'
)
.
inherits
;
exports
.
escape
=
function
(
html
)
{
return
String
(
html
)
.
replace
(
/
&
/
g
'
&
amp
;
'
)
.
replace
(
/
"
/
g
'
&
quot
;
'
)
.
replace
(
/
<
/
g
'
&
lt
;
'
)
.
replace
(
/
>
/
g
'
&
gt
;
'
)
;
}
;
exports
.
forEach
=
function
(
arr
fn
scope
)
{
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
i
+
+
)
{
fn
.
call
(
scope
arr
[
i
]
i
)
;
}
}
;
exports
.
isString
=
function
(
obj
)
{
return
typeof
obj
=
=
=
'
string
'
;
}
;
exports
.
map
=
function
(
arr
fn
scope
)
{
var
result
=
[
]
;
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
i
+
+
)
{
result
.
push
(
fn
.
call
(
scope
arr
[
i
]
i
arr
)
)
;
}
return
result
;
}
;
var
indexOf
=
exports
.
indexOf
=
function
(
arr
obj
start
)
{
for
(
var
i
=
start
|
|
0
l
=
arr
.
length
;
i
<
l
;
i
+
+
)
{
if
(
arr
[
i
]
=
=
=
obj
)
{
return
i
;
}
}
return
-
1
;
}
;
var
reduce
=
exports
.
reduce
=
function
(
arr
fn
val
)
{
var
rval
=
val
;
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
i
+
+
)
{
rval
=
fn
(
rval
arr
[
i
]
i
arr
)
;
}
return
rval
;
}
;
exports
.
filter
=
function
(
arr
fn
)
{
var
ret
=
[
]
;
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
i
+
+
)
{
var
val
=
arr
[
i
]
;
if
(
fn
(
val
i
arr
)
)
{
ret
.
push
(
val
)
;
}
}
return
ret
;
}
;
exports
.
some
=
function
(
arr
fn
)
{
for
(
var
i
=
0
l
=
arr
.
length
;
i
<
l
;
i
+
+
)
{
if
(
fn
(
arr
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
;
exports
.
keys
=
typeof
Object
.
keys
=
=
=
'
function
'
?
Object
.
keys
:
function
(
obj
)
{
var
keys
=
[
]
;
var
has
=
Object
.
prototype
.
hasOwnProperty
;
for
(
var
key
in
obj
)
{
if
(
has
.
call
(
obj
key
)
)
{
keys
.
push
(
key
)
;
}
}
return
keys
;
}
;
exports
.
watch
=
function
(
files
fn
)
{
var
options
=
{
interval
:
100
}
;
files
.
forEach
(
function
(
file
)
{
debug
(
'
file
%
s
'
file
)
;
watchFile
(
file
options
function
(
curr
prev
)
{
if
(
prev
.
mtime
<
curr
.
mtime
)
{
fn
(
file
)
;
}
}
)
;
}
)
;
}
;
var
isArray
=
typeof
Array
.
isArray
=
=
=
'
function
'
?
Array
.
isArray
:
function
(
obj
)
{
return
Object
.
prototype
.
toString
.
call
(
obj
)
=
=
=
'
[
object
Array
]
'
;
}
;
exports
.
isArray
=
isArray
;
if
(
typeof
Buffer
!
=
=
'
undefined
'
&
&
Buffer
.
prototype
)
{
Buffer
.
prototype
.
toJSON
=
Buffer
.
prototype
.
toJSON
|
|
function
(
)
{
return
Array
.
prototype
.
slice
.
call
(
this
0
)
;
}
;
}
function
ignored
(
path
)
{
return
!
~
ignore
.
indexOf
(
path
)
;
}
exports
.
files
=
function
(
dir
ext
ret
)
{
ret
=
ret
|
|
[
]
;
ext
=
ext
|
|
[
'
js
'
]
;
var
re
=
new
RegExp
(
'
\
\
.
(
'
+
ext
.
join
(
'
|
'
)
+
'
)
'
)
;
readdirSync
(
dir
)
.
filter
(
ignored
)
.
forEach
(
function
(
path
)
{
path
=
join
(
dir
path
)
;
if
(
lstatSync
(
path
)
.
isDirectory
(
)
)
{
exports
.
files
(
path
ext
ret
)
;
}
else
if
(
path
.
match
(
re
)
)
{
ret
.
push
(
path
)
;
}
}
)
;
return
ret
;
}
;
exports
.
slug
=
function
(
str
)
{
return
str
.
toLowerCase
(
)
.
replace
(
/
+
/
g
'
-
'
)
.
replace
(
/
[
^
-
\
w
]
/
g
'
'
)
;
}
;
exports
.
clean
=
function
(
str
)
{
str
=
str
.
replace
(
/
\
r
\
n
?
|
[
\
n
\
u2028
\
u2029
]
/
g
'
\
n
'
)
.
replace
(
/
^
\
uFEFF
/
'
'
)
.
replace
(
/
^
function
(
?
:
\
s
*
|
\
s
+
[
^
(
]
*
)
\
(
[
^
)
]
*
\
)
\
s
*
\
{
(
(
?
:
.
|
\
n
)
*
?
)
\
s
*
\
}
|
^
\
(
[
^
)
]
*
\
)
\
s
*
=
>
\
s
*
(
?
:
\
{
(
(
?
:
.
|
\
n
)
*
?
)
\
s
*
\
}
|
(
(
?
:
.
|
\
n
)
*
)
)
/
'
1
2
3
'
)
;
var
spaces
=
str
.
match
(
/
^
\
n
?
(
*
)
/
)
[
1
]
.
length
;
var
tabs
=
str
.
match
(
/
^
\
n
?
(
\
t
*
)
/
)
[
1
]
.
length
;
var
re
=
new
RegExp
(
'
^
\
n
?
'
+
(
tabs
?
'
\
t
'
:
'
'
)
+
'
{
'
+
(
tabs
|
|
spaces
)
+
'
}
'
'
gm
'
)
;
str
=
str
.
replace
(
re
'
'
)
;
return
exports
.
trim
(
str
)
;
}
;
exports
.
trim
=
function
(
str
)
{
return
str
.
replace
(
/
^
\
s
+
|
\
s
+
/
g
'
'
)
;
}
;
exports
.
parseQuery
=
function
(
qs
)
{
return
reduce
(
qs
.
replace
(
'
?
'
'
'
)
.
split
(
'
&
'
)
function
(
obj
pair
)
{
var
i
=
pair
.
indexOf
(
'
=
'
)
;
var
key
=
pair
.
slice
(
0
i
)
;
var
val
=
pair
.
slice
(
+
+
i
)
;
obj
[
key
]
=
decodeURIComponent
(
val
.
replace
(
/
\
+
/
g
'
%
20
'
)
)
;
return
obj
;
}
{
}
)
;
}
;
function
highlight
(
js
)
{
return
js
.
replace
(
/
<
/
g
'
&
lt
;
'
)
.
replace
(
/
>
/
g
'
&
gt
;
'
)
.
replace
(
/
\
/
\
/
(
.
*
)
/
gm
'
<
span
class
=
"
comment
"
>
/
/
1
<
/
span
>
'
)
.
replace
(
/
(
'
.
*
?
'
)
/
gm
'
<
span
class
=
"
string
"
>
1
<
/
span
>
'
)
.
replace
(
/
(
\
d
+
\
.
\
d
+
)
/
gm
'
<
span
class
=
"
number
"
>
1
<
/
span
>
'
)
.
replace
(
/
(
\
d
+
)
/
gm
'
<
span
class
=
"
number
"
>
1
<
/
span
>
'
)
.
replace
(
/
\
bnew
[
\
t
]
+
(
\
w
+
)
/
gm
'
<
span
class
=
"
keyword
"
>
new
<
/
span
>
<
span
class
=
"
init
"
>
1
<
/
span
>
'
)
.
replace
(
/
\
b
(
function
|
new
|
throw
|
return
|
var
|
if
|
else
)
\
b
/
gm
'
<
span
class
=
"
keyword
"
>
1
<
/
span
>
'
)
;
}
exports
.
highlightTags
=
function
(
name
)
{
var
code
=
document
.
getElementById
(
'
mocha
'
)
.
getElementsByTagName
(
name
)
;
for
(
var
i
=
0
len
=
code
.
length
;
i
<
len
;
+
+
i
)
{
code
[
i
]
.
innerHTML
=
highlight
(
code
[
i
]
.
innerHTML
)
;
}
}
;
function
emptyRepresentation
(
value
typeHint
)
{
switch
(
typeHint
)
{
case
'
function
'
:
return
'
[
Function
]
'
;
case
'
object
'
:
return
'
{
}
'
;
case
'
array
'
:
return
'
[
]
'
;
default
:
return
value
.
toString
(
)
;
}
}
var
type
=
exports
.
type
=
function
type
(
value
)
{
if
(
value
=
=
=
undefined
)
{
return
'
undefined
'
;
}
else
if
(
value
=
=
=
null
)
{
return
'
null
'
;
}
else
if
(
typeof
Buffer
!
=
=
'
undefined
'
&
&
Buffer
.
isBuffer
(
value
)
)
{
return
'
buffer
'
;
}
return
Object
.
prototype
.
toString
.
call
(
value
)
.
replace
(
/
^
\
[
.
+
\
s
(
.
+
?
)
]
/
'
1
'
)
.
toLowerCase
(
)
;
}
;
exports
.
stringify
=
function
(
value
)
{
var
typeHint
=
type
(
value
)
;
if
(
!
~
indexOf
(
[
'
object
'
'
array
'
'
function
'
]
typeHint
)
)
{
if
(
typeHint
=
=
=
'
buffer
'
)
{
var
json
=
value
.
toJSON
(
)
;
return
jsonStringify
(
json
.
data
&
&
json
.
type
?
json
.
data
:
json
2
)
.
replace
(
/
(
\
n
|
)
/
g
'
1
'
)
;
}
if
(
typeHint
=
=
=
'
string
'
&
&
typeof
value
=
=
=
'
object
'
)
{
value
=
reduce
(
value
.
split
(
'
'
)
function
(
acc
char
idx
)
{
acc
[
idx
]
=
char
;
return
acc
;
}
{
}
)
;
typeHint
=
'
object
'
;
}
else
{
return
jsonStringify
(
value
)
;
}
}
for
(
var
prop
in
value
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
value
prop
)
)
{
return
jsonStringify
(
exports
.
canonicalize
(
value
null
typeHint
)
2
)
.
replace
(
/
(
\
n
|
)
/
g
'
1
'
)
;
}
}
return
emptyRepresentation
(
value
typeHint
)
;
}
;
function
jsonStringify
(
object
spaces
depth
)
{
if
(
typeof
spaces
=
=
=
'
undefined
'
)
{
return
_stringify
(
object
)
;
}
depth
=
depth
|
|
1
;
var
space
=
spaces
*
depth
;
var
str
=
isArray
(
object
)
?
'
[
'
:
'
{
'
;
var
end
=
isArray
(
object
)
?
'
]
'
:
'
}
'
;
var
length
=
typeof
object
.
length
=
=
=
'
number
'
?
object
.
length
:
exports
.
keys
(
object
)
.
length
;
function
repeat
(
s
n
)
{
return
new
Array
(
n
)
.
join
(
s
)
;
}
function
_stringify
(
val
)
{
switch
(
type
(
val
)
)
{
case
'
null
'
:
case
'
undefined
'
:
val
=
'
[
'
+
val
+
'
]
'
;
break
;
case
'
array
'
:
case
'
object
'
:
val
=
jsonStringify
(
val
spaces
depth
+
1
)
;
break
;
case
'
boolean
'
:
case
'
regexp
'
:
case
'
symbol
'
:
case
'
number
'
:
val
=
val
=
=
=
0
&
&
(
1
/
val
)
=
=
=
-
Infinity
?
'
-
0
'
:
val
.
toString
(
)
;
break
;
case
'
date
'
:
var
sDate
;
if
(
isNaN
(
val
.
getTime
(
)
)
)
{
sDate
=
val
.
toString
(
)
;
}
else
{
sDate
=
val
.
toISOString
?
val
.
toISOString
(
)
:
toISOString
(
val
)
;
}
val
=
'
[
Date
:
'
+
sDate
+
'
]
'
;
break
;
case
'
buffer
'
:
var
json
=
val
.
toJSON
(
)
;
json
=
json
.
data
&
&
json
.
type
?
json
.
data
:
json
;
val
=
'
[
Buffer
:
'
+
jsonStringify
(
json
2
depth
+
1
)
+
'
]
'
;
break
;
default
:
val
=
(
val
=
=
=
'
[
Function
]
'
|
|
val
=
=
=
'
[
Circular
]
'
)
?
val
:
JSON
.
stringify
(
val
)
;
}
return
val
;
}
for
(
var
i
in
object
)
{
if
(
!
Object
.
prototype
.
hasOwnProperty
.
call
(
object
i
)
)
{
continue
;
}
-
-
length
;
str
+
=
'
\
n
'
+
repeat
(
'
'
space
)
+
(
isArray
(
object
)
?
'
'
:
'
"
'
+
i
+
'
"
:
'
)
+
_stringify
(
object
[
i
]
)
+
(
length
?
'
'
:
'
'
)
;
}
return
str
+
(
str
.
length
!
=
=
1
?
'
\
n
'
+
repeat
(
'
'
-
-
space
)
+
end
:
end
)
;
}
exports
.
isBuffer
=
function
(
value
)
{
return
typeof
Buffer
!
=
=
'
undefined
'
&
&
Buffer
.
isBuffer
(
value
)
;
}
;
exports
.
canonicalize
=
function
canonicalize
(
value
stack
typeHint
)
{
var
canonicalizedObj
;
var
prop
;
typeHint
=
typeHint
|
|
type
(
value
)
;
function
withStack
(
value
fn
)
{
stack
.
push
(
value
)
;
fn
(
)
;
stack
.
pop
(
)
;
}
stack
=
stack
|
|
[
]
;
if
(
indexOf
(
stack
value
)
!
=
=
-
1
)
{
return
'
[
Circular
]
'
;
}
switch
(
typeHint
)
{
case
'
undefined
'
:
case
'
buffer
'
:
case
'
null
'
:
canonicalizedObj
=
value
;
break
;
case
'
array
'
:
withStack
(
value
function
(
)
{
canonicalizedObj
=
exports
.
map
(
value
function
(
item
)
{
return
exports
.
canonicalize
(
item
stack
)
;
}
)
;
}
)
;
break
;
case
'
function
'
:
for
(
prop
in
value
)
{
canonicalizedObj
=
{
}
;
break
;
}
if
(
!
canonicalizedObj
)
{
canonicalizedObj
=
emptyRepresentation
(
value
typeHint
)
;
break
;
}
case
'
object
'
:
canonicalizedObj
=
canonicalizedObj
|
|
{
}
;
withStack
(
value
function
(
)
{
exports
.
forEach
(
exports
.
keys
(
value
)
.
sort
(
)
function
(
key
)
{
canonicalizedObj
[
key
]
=
exports
.
canonicalize
(
value
[
key
]
stack
)
;
}
)
;
}
)
;
break
;
case
'
date
'
:
case
'
number
'
:
case
'
regexp
'
:
case
'
boolean
'
:
case
'
symbol
'
:
canonicalizedObj
=
value
;
break
;
default
:
canonicalizedObj
=
value
+
'
'
;
}
return
canonicalizedObj
;
}
;
exports
.
lookupFiles
=
function
lookupFiles
(
path
extensions
recursive
)
{
var
files
=
[
]
;
var
re
=
new
RegExp
(
'
\
\
.
(
'
+
extensions
.
join
(
'
|
'
)
+
'
)
'
)
;
if
(
!
exists
(
path
)
)
{
if
(
exists
(
path
+
'
.
js
'
)
)
{
path
+
=
'
.
js
'
;
}
else
{
files
=
glob
.
sync
(
path
)
;
if
(
!
files
.
length
)
{
throw
new
Error
(
"
cannot
resolve
path
(
or
pattern
)
'
"
+
path
+
"
'
"
)
;
}
return
files
;
}
}
try
{
var
stat
=
statSync
(
path
)
;
if
(
stat
.
isFile
(
)
)
{
return
path
;
}
}
catch
(
err
)
{
return
;
}
readdirSync
(
path
)
.
forEach
(
function
(
file
)
{
file
=
join
(
path
file
)
;
try
{
var
stat
=
statSync
(
file
)
;
if
(
stat
.
isDirectory
(
)
)
{
if
(
recursive
)
{
files
=
files
.
concat
(
lookupFiles
(
file
extensions
recursive
)
)
;
}
return
;
}
}
catch
(
err
)
{
return
;
}
if
(
!
stat
.
isFile
(
)
|
|
!
re
.
test
(
file
)
|
|
basename
(
file
)
[
0
]
=
=
=
'
.
'
)
{
return
;
}
files
.
push
(
file
)
;
}
)
;
return
files
;
}
;
exports
.
undefinedError
=
function
(
)
{
return
new
Error
(
'
Caught
undefined
error
did
you
throw
without
specifying
what
?
'
)
;
}
;
exports
.
getError
=
function
(
err
)
{
return
err
|
|
exports
.
undefinedError
(
)
;
}
;
exports
.
stackTraceFilter
=
function
(
)
{
var
is
=
typeof
document
=
=
=
'
undefined
'
?
{
node
:
true
}
:
{
browser
:
true
}
;
var
slash
=
path
.
sep
;
var
cwd
;
if
(
is
.
node
)
{
cwd
=
process
.
cwd
(
)
+
slash
;
}
else
{
cwd
=
(
typeof
location
=
=
=
'
undefined
'
?
window
.
location
:
location
)
.
href
.
replace
(
/
\
/
[
^
/
]
*
/
'
/
'
)
;
slash
=
'
/
'
;
}
function
isMochaInternal
(
line
)
{
return
(
~
line
.
indexOf
(
'
node_modules
'
+
slash
+
'
mocha
'
+
slash
)
)
|
|
(
~
line
.
indexOf
(
'
node_modules
'
+
slash
+
'
mocha
.
js
'
)
)
|
|
(
~
line
.
indexOf
(
'
bower_components
'
+
slash
+
'
mocha
.
js
'
)
)
|
|
(
~
line
.
indexOf
(
slash
+
'
mocha
.
js
'
)
)
;
}
function
isNodeInternal
(
line
)
{
return
(
~
line
.
indexOf
(
'
(
timers
.
js
:
'
)
)
|
|
(
~
line
.
indexOf
(
'
(
events
.
js
:
'
)
)
|
|
(
~
line
.
indexOf
(
'
(
node
.
js
:
'
)
)
|
|
(
~
line
.
indexOf
(
'
(
module
.
js
:
'
)
)
|
|
(
~
line
.
indexOf
(
'
GeneratorFunctionPrototype
.
next
(
native
)
'
)
)
|
|
false
;
}
return
function
(
stack
)
{
stack
=
stack
.
split
(
'
\
n
'
)
;
stack
=
reduce
(
stack
function
(
list
line
)
{
if
(
isMochaInternal
(
line
)
)
{
return
list
;
}
if
(
is
.
node
&
&
isNodeInternal
(
line
)
)
{
return
list
;
}
if
(
/
\
(
?
.
+
:
\
d
+
:
\
d
+
\
)
?
/
.
test
(
line
)
)
{
line
=
line
.
replace
(
cwd
'
'
)
;
}
list
.
push
(
line
)
;
return
list
;
}
[
]
)
;
return
stack
.
join
(
'
\
n
'
)
;
}
;
}
;
exports
.
isPromise
=
function
isPromise
(
value
)
{
return
typeof
value
=
=
=
'
object
'
&
&
typeof
value
.
then
=
=
=
'
function
'
;
}
;
exports
.
noop
=
function
(
)
{
}
;
}
)
.
call
(
this
require
(
'
_process
'
)
require
(
"
buffer
"
)
.
Buffer
)
}
{
"
.
/
to
-
iso
-
string
"
:
37
"
_process
"
:
82
"
buffer
"
:
44
"
debug
"
:
2
"
fs
"
:
42
"
glob
"
:
42
"
json3
"
:
69
"
path
"
:
42
"
util
"
:
99
}
]
39
:
[
function
(
require
module
exports
)
{
'
use
strict
'
exports
.
byteLength
=
byteLength
exports
.
toByteArray
=
toByteArray
exports
.
fromByteArray
=
fromByteArray
var
lookup
=
[
]
var
revLookup
=
[
]
var
Arr
=
typeof
Uint8Array
!
=
=
'
undefined
'
?
Uint8Array
:
Array
var
code
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
for
(
var
i
=
0
len
=
code
.
length
;
i
<
len
;
+
+
i
)
{
lookup
[
i
]
=
code
[
i
]
revLookup
[
code
.
charCodeAt
(
i
)
]
=
i
}
revLookup
[
'
-
'
.
charCodeAt
(
0
)
]
=
62
revLookup
[
'
_
'
.
charCodeAt
(
0
)
]
=
63
function
placeHoldersCount
(
b64
)
{
var
len
=
b64
.
length
if
(
len
%
4
>
0
)
{
throw
new
Error
(
'
Invalid
string
.
Length
must
be
a
multiple
of
4
'
)
}
return
b64
[
len
-
2
]
=
=
=
'
=
'
?
2
:
b64
[
len
-
1
]
=
=
=
'
=
'
?
1
:
0
}
function
byteLength
(
b64
)
{
return
b64
.
length
*
3
/
4
-
placeHoldersCount
(
b64
)
}
function
toByteArray
(
b64
)
{
var
i
j
l
tmp
placeHolders
arr
var
len
=
b64
.
length
placeHolders
=
placeHoldersCount
(
b64
)
arr
=
new
Arr
(
len
*
3
/
4
-
placeHolders
)
l
=
placeHolders
>
0
?
len
-
4
:
len
var
L
=
0
for
(
i
=
0
j
=
0
;
i
<
l
;
i
+
=
4
j
+
=
3
)
{
tmp
=
(
revLookup
[
b64
.
charCodeAt
(
i
)
]
<
<
18
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
1
)
]
<
<
12
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
2
)
]
<
<
6
)
|
revLookup
[
b64
.
charCodeAt
(
i
+
3
)
]
arr
[
L
+
+
]
=
(
tmp
>
>
16
)
&
0xFF
arr
[
L
+
+
]
=
(
tmp
>
>
8
)
&
0xFF
arr
[
L
+
+
]
=
tmp
&
0xFF
}
if
(
placeHolders
=
=
=
2
)
{
tmp
=
(
revLookup
[
b64
.
charCodeAt
(
i
)
]
<
<
2
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
1
)
]
>
>
4
)
arr
[
L
+
+
]
=
tmp
&
0xFF
}
else
if
(
placeHolders
=
=
=
1
)
{
tmp
=
(
revLookup
[
b64
.
charCodeAt
(
i
)
]
<
<
10
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
1
)
]
<
<
4
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
2
)
]
>
>
2
)
arr
[
L
+
+
]
=
(
tmp
>
>
8
)
&
0xFF
arr
[
L
+
+
]
=
tmp
&
0xFF
}
return
arr
}
function
tripletToBase64
(
num
)
{
return
lookup
[
num
>
>
18
&
0x3F
]
+
lookup
[
num
>
>
12
&
0x3F
]
+
lookup
[
num
>
>
6
&
0x3F
]
+
lookup
[
num
&
0x3F
]
}
function
encodeChunk
(
uint8
start
end
)
{
var
tmp
var
output
=
[
]
for
(
var
i
=
start
;
i
<
end
;
i
+
=
3
)
{
tmp
=
(
uint8
[
i
]
<
<
16
)
+
(
uint8
[
i
+
1
]
<
<
8
)
+
(
uint8
[
i
+
2
]
)
output
.
push
(
tripletToBase64
(
tmp
)
)
}
return
output
.
join
(
'
'
)
}
function
fromByteArray
(
uint8
)
{
var
tmp
var
len
=
uint8
.
length
var
extraBytes
=
len
%
3
var
output
=
'
'
var
parts
=
[
]
var
maxChunkLength
=
16383
for
(
var
i
=
0
len2
=
len
-
extraBytes
;
i
<
len2
;
i
+
=
maxChunkLength
)
{
parts
.
push
(
encodeChunk
(
uint8
i
(
i
+
maxChunkLength
)
>
len2
?
len2
:
(
i
+
maxChunkLength
)
)
)
}
if
(
extraBytes
=
=
=
1
)
{
tmp
=
uint8
[
len
-
1
]
output
+
=
lookup
[
tmp
>
>
2
]
output
+
=
lookup
[
(
tmp
<
<
4
)
&
0x3F
]
output
+
=
'
=
=
'
}
else
if
(
extraBytes
=
=
=
2
)
{
tmp
=
(
uint8
[
len
-
2
]
<
<
8
)
+
(
uint8
[
len
-
1
]
)
output
+
=
lookup
[
tmp
>
>
10
]
output
+
=
lookup
[
(
tmp
>
>
4
)
&
0x3F
]
output
+
=
lookup
[
(
tmp
<
<
2
)
&
0x3F
]
output
+
=
'
=
'
}
parts
.
push
(
output
)
return
parts
.
join
(
'
'
)
}
}
{
}
]
40
:
[
function
(
require
module
exports
)
{
}
{
}
]
41
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
var
WritableStream
=
require
(
'
stream
'
)
.
Writable
var
inherits
=
require
(
'
util
'
)
.
inherits
module
.
exports
=
BrowserStdout
inherits
(
BrowserStdout
WritableStream
)
function
BrowserStdout
(
opts
)
{
if
(
!
(
this
instanceof
BrowserStdout
)
)
return
new
BrowserStdout
(
opts
)
opts
=
opts
|
|
{
}
WritableStream
.
call
(
this
opts
)
this
.
label
=
(
opts
.
label
!
=
=
undefined
)
?
opts
.
label
:
'
stdout
'
}
BrowserStdout
.
prototype
.
_write
=
function
(
chunks
encoding
cb
)
{
var
output
=
chunks
.
toString
?
chunks
.
toString
(
)
:
chunks
if
(
this
.
label
=
=
=
false
)
{
console
.
log
(
output
)
}
else
{
console
.
log
(
this
.
label
+
'
:
'
output
)
}
process
.
nextTick
(
cb
)
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
_process
"
:
82
"
stream
"
:
94
"
util
"
:
99
}
]
42
:
[
function
(
require
module
exports
)
{
arguments
[
4
]
[
40
]
[
0
]
.
apply
(
exports
arguments
)
}
{
"
dup
"
:
40
}
]
43
:
[
function
(
require
module
exports
)
{
(
function
(
global
)
{
'
use
strict
'
;
var
buffer
=
require
(
'
buffer
'
)
;
var
Buffer
=
buffer
.
Buffer
;
var
SlowBuffer
=
buffer
.
SlowBuffer
;
var
MAX_LEN
=
buffer
.
kMaxLength
|
|
2147483647
;
exports
.
alloc
=
function
alloc
(
size
fill
encoding
)
{
if
(
typeof
Buffer
.
alloc
=
=
=
'
function
'
)
{
return
Buffer
.
alloc
(
size
fill
encoding
)
;
}
if
(
typeof
encoding
=
=
=
'
number
'
)
{
throw
new
TypeError
(
'
encoding
must
not
be
number
'
)
;
}
if
(
typeof
size
!
=
=
'
number
'
)
{
throw
new
TypeError
(
'
size
must
be
a
number
'
)
;
}
if
(
size
>
MAX_LEN
)
{
throw
new
RangeError
(
'
size
is
too
large
'
)
;
}
var
enc
=
encoding
;
var
_fill
=
fill
;
if
(
_fill
=
=
=
undefined
)
{
enc
=
undefined
;
_fill
=
0
;
}
var
buf
=
new
Buffer
(
size
)
;
if
(
typeof
_fill
=
=
=
'
string
'
)
{
var
fillBuf
=
new
Buffer
(
_fill
enc
)
;
var
flen
=
fillBuf
.
length
;
var
i
=
-
1
;
while
(
+
+
i
<
size
)
{
buf
[
i
]
=
fillBuf
[
i
%
flen
]
;
}
}
else
{
buf
.
fill
(
_fill
)
;
}
return
buf
;
}
exports
.
allocUnsafe
=
function
allocUnsafe
(
size
)
{
if
(
typeof
Buffer
.
allocUnsafe
=
=
=
'
function
'
)
{
return
Buffer
.
allocUnsafe
(
size
)
;
}
if
(
typeof
size
!
=
=
'
number
'
)
{
throw
new
TypeError
(
'
size
must
be
a
number
'
)
;
}
if
(
size
>
MAX_LEN
)
{
throw
new
RangeError
(
'
size
is
too
large
'
)
;
}
return
new
Buffer
(
size
)
;
}
exports
.
from
=
function
from
(
value
encodingOrOffset
length
)
{
if
(
typeof
Buffer
.
from
=
=
=
'
function
'
&
&
(
!
global
.
Uint8Array
|
|
Uint8Array
.
from
!
=
=
Buffer
.
from
)
)
{
return
Buffer
.
from
(
value
encodingOrOffset
length
)
;
}
if
(
typeof
value
=
=
=
'
number
'
)
{
throw
new
TypeError
(
'
"
value
"
argument
must
not
be
a
number
'
)
;
}
if
(
typeof
value
=
=
=
'
string
'
)
{
return
new
Buffer
(
value
encodingOrOffset
)
;
}
if
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
value
instanceof
ArrayBuffer
)
{
var
offset
=
encodingOrOffset
;
if
(
arguments
.
length
=
=
=
1
)
{
return
new
Buffer
(
value
)
;
}
if
(
typeof
offset
=
=
=
'
undefined
'
)
{
offset
=
0
;
}
var
len
=
length
;
if
(
typeof
len
=
=
=
'
undefined
'
)
{
len
=
value
.
byteLength
-
offset
;
}
if
(
offset
>
=
value
.
byteLength
)
{
throw
new
RangeError
(
'
\
'
offset
\
'
is
out
of
bounds
'
)
;
}
if
(
len
>
value
.
byteLength
-
offset
)
{
throw
new
RangeError
(
'
\
'
length
\
'
is
out
of
bounds
'
)
;
}
return
new
Buffer
(
value
.
slice
(
offset
offset
+
len
)
)
;
}
if
(
Buffer
.
isBuffer
(
value
)
)
{
var
out
=
new
Buffer
(
value
.
length
)
;
value
.
copy
(
out
0
0
value
.
length
)
;
return
out
;
}
if
(
value
)
{
if
(
Array
.
isArray
(
value
)
|
|
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
value
.
buffer
instanceof
ArrayBuffer
)
|
|
'
length
'
in
value
)
{
return
new
Buffer
(
value
)
;
}
if
(
value
.
type
=
=
=
'
Buffer
'
&
&
Array
.
isArray
(
value
.
data
)
)
{
return
new
Buffer
(
value
.
data
)
;
}
}
throw
new
TypeError
(
'
First
argument
must
be
a
string
Buffer
'
+
'
ArrayBuffer
Array
or
array
-
like
object
.
'
)
;
}
exports
.
allocUnsafeSlow
=
function
allocUnsafeSlow
(
size
)
{
if
(
typeof
Buffer
.
allocUnsafeSlow
=
=
=
'
function
'
)
{
return
Buffer
.
allocUnsafeSlow
(
size
)
;
}
if
(
typeof
size
!
=
=
'
number
'
)
{
throw
new
TypeError
(
'
size
must
be
a
number
'
)
;
}
if
(
size
>
=
MAX_LEN
)
{
throw
new
RangeError
(
'
size
is
too
large
'
)
;
}
return
new
SlowBuffer
(
size
)
;
}
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
buffer
"
:
44
}
]
44
:
[
function
(
require
module
exports
)
{
(
function
(
global
)
{
'
use
strict
'
var
base64
=
require
(
'
base64
-
js
'
)
var
ieee754
=
require
(
'
ieee754
'
)
var
isArray
=
require
(
'
isarray
'
)
exports
.
Buffer
=
Buffer
exports
.
SlowBuffer
=
SlowBuffer
exports
.
INSPECT_MAX_BYTES
=
50
Buffer
.
TYPED_ARRAY_SUPPORT
=
global
.
TYPED_ARRAY_SUPPORT
!
=
=
undefined
?
global
.
TYPED_ARRAY_SUPPORT
:
typedArraySupport
(
)
exports
.
kMaxLength
=
kMaxLength
(
)
function
typedArraySupport
(
)
{
try
{
var
arr
=
new
Uint8Array
(
1
)
arr
.
__proto__
=
{
__proto__
:
Uint8Array
.
prototype
foo
:
function
(
)
{
return
42
}
}
return
arr
.
foo
(
)
=
=
=
42
&
&
typeof
arr
.
subarray
=
=
=
'
function
'
&
&
arr
.
subarray
(
1
1
)
.
byteLength
=
=
=
0
}
catch
(
e
)
{
return
false
}
}
function
kMaxLength
(
)
{
return
Buffer
.
TYPED_ARRAY_SUPPORT
?
0x7fffffff
:
0x3fffffff
}
function
createBuffer
(
that
length
)
{
if
(
kMaxLength
(
)
<
length
)
{
throw
new
RangeError
(
'
Invalid
typed
array
length
'
)
}
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
that
=
new
Uint8Array
(
length
)
that
.
__proto__
=
Buffer
.
prototype
}
else
{
if
(
that
=
=
=
null
)
{
that
=
new
Buffer
(
length
)
}
that
.
length
=
length
}
return
that
}
function
Buffer
(
arg
encodingOrOffset
length
)
{
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
&
&
!
(
this
instanceof
Buffer
)
)
{
return
new
Buffer
(
arg
encodingOrOffset
length
)
}
if
(
typeof
arg
=
=
=
'
number
'
)
{
if
(
typeof
encodingOrOffset
=
=
=
'
string
'
)
{
throw
new
Error
(
'
If
encoding
is
specified
then
the
first
argument
must
be
a
string
'
)
}
return
allocUnsafe
(
this
arg
)
}
return
from
(
this
arg
encodingOrOffset
length
)
}
Buffer
.
poolSize
=
8192
Buffer
.
_augment
=
function
(
arr
)
{
arr
.
__proto__
=
Buffer
.
prototype
return
arr
}
function
from
(
that
value
encodingOrOffset
length
)
{
if
(
typeof
value
=
=
=
'
number
'
)
{
throw
new
TypeError
(
'
"
value
"
argument
must
not
be
a
number
'
)
}
if
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
value
instanceof
ArrayBuffer
)
{
return
fromArrayBuffer
(
that
value
encodingOrOffset
length
)
}
if
(
typeof
value
=
=
=
'
string
'
)
{
return
fromString
(
that
value
encodingOrOffset
)
}
return
fromObject
(
that
value
)
}
Buffer
.
from
=
function
(
value
encodingOrOffset
length
)
{
return
from
(
null
value
encodingOrOffset
length
)
}
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
Buffer
.
prototype
.
__proto__
=
Uint8Array
.
prototype
Buffer
.
__proto__
=
Uint8Array
if
(
typeof
Symbol
!
=
=
'
undefined
'
&
&
Symbol
.
species
&
&
Buffer
[
Symbol
.
species
]
=
=
=
Buffer
)
{
Object
.
defineProperty
(
Buffer
Symbol
.
species
{
value
:
null
configurable
:
true
}
)
}
}
function
assertSize
(
size
)
{
if
(
typeof
size
!
=
=
'
number
'
)
{
throw
new
TypeError
(
'
"
size
"
argument
must
be
a
number
'
)
}
else
if
(
size
<
0
)
{
throw
new
RangeError
(
'
"
size
"
argument
must
not
be
negative
'
)
}
}
function
alloc
(
that
size
fill
encoding
)
{
assertSize
(
size
)
if
(
size
<
=
0
)
{
return
createBuffer
(
that
size
)
}
if
(
fill
!
=
=
undefined
)
{
return
typeof
encoding
=
=
=
'
string
'
?
createBuffer
(
that
size
)
.
fill
(
fill
encoding
)
:
createBuffer
(
that
size
)
.
fill
(
fill
)
}
return
createBuffer
(
that
size
)
}
Buffer
.
alloc
=
function
(
size
fill
encoding
)
{
return
alloc
(
null
size
fill
encoding
)
}
function
allocUnsafe
(
that
size
)
{
assertSize
(
size
)
that
=
createBuffer
(
that
size
<
0
?
0
:
checked
(
size
)
|
0
)
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
for
(
var
i
=
0
;
i
<
size
;
+
+
i
)
{
that
[
i
]
=
0
}
}
return
that
}
Buffer
.
allocUnsafe
=
function
(
size
)
{
return
allocUnsafe
(
null
size
)
}
Buffer
.
allocUnsafeSlow
=
function
(
size
)
{
return
allocUnsafe
(
null
size
)
}
function
fromString
(
that
string
encoding
)
{
if
(
typeof
encoding
!
=
=
'
string
'
|
|
encoding
=
=
=
'
'
)
{
encoding
=
'
utf8
'
}
if
(
!
Buffer
.
isEncoding
(
encoding
)
)
{
throw
new
TypeError
(
'
"
encoding
"
must
be
a
valid
string
encoding
'
)
}
var
length
=
byteLength
(
string
encoding
)
|
0
that
=
createBuffer
(
that
length
)
var
actual
=
that
.
write
(
string
encoding
)
if
(
actual
!
=
=
length
)
{
that
=
that
.
slice
(
0
actual
)
}
return
that
}
function
fromArrayLike
(
that
array
)
{
var
length
=
array
.
length
<
0
?
0
:
checked
(
array
.
length
)
|
0
that
=
createBuffer
(
that
length
)
for
(
var
i
=
0
;
i
<
length
;
i
+
=
1
)
{
that
[
i
]
=
array
[
i
]
&
255
}
return
that
}
function
fromArrayBuffer
(
that
array
byteOffset
length
)
{
array
.
byteLength
if
(
byteOffset
<
0
|
|
array
.
byteLength
<
byteOffset
)
{
throw
new
RangeError
(
'
\
'
offset
\
'
is
out
of
bounds
'
)
}
if
(
array
.
byteLength
<
byteOffset
+
(
length
|
|
0
)
)
{
throw
new
RangeError
(
'
\
'
length
\
'
is
out
of
bounds
'
)
}
if
(
byteOffset
=
=
=
undefined
&
&
length
=
=
=
undefined
)
{
array
=
new
Uint8Array
(
array
)
}
else
if
(
length
=
=
=
undefined
)
{
array
=
new
Uint8Array
(
array
byteOffset
)
}
else
{
array
=
new
Uint8Array
(
array
byteOffset
length
)
}
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
that
=
array
that
.
__proto__
=
Buffer
.
prototype
}
else
{
that
=
fromArrayLike
(
that
array
)
}
return
that
}
function
fromObject
(
that
obj
)
{
if
(
Buffer
.
isBuffer
(
obj
)
)
{
var
len
=
checked
(
obj
.
length
)
|
0
that
=
createBuffer
(
that
len
)
if
(
that
.
length
=
=
=
0
)
{
return
that
}
obj
.
copy
(
that
0
0
len
)
return
that
}
if
(
obj
)
{
if
(
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
obj
.
buffer
instanceof
ArrayBuffer
)
|
|
'
length
'
in
obj
)
{
if
(
typeof
obj
.
length
!
=
=
'
number
'
|
|
isnan
(
obj
.
length
)
)
{
return
createBuffer
(
that
0
)
}
return
fromArrayLike
(
that
obj
)
}
if
(
obj
.
type
=
=
=
'
Buffer
'
&
&
isArray
(
obj
.
data
)
)
{
return
fromArrayLike
(
that
obj
.
data
)
}
}
throw
new
TypeError
(
'
First
argument
must
be
a
string
Buffer
ArrayBuffer
Array
or
array
-
like
object
.
'
)
}
function
checked
(
length
)
{
if
(
length
>
=
kMaxLength
(
)
)
{
throw
new
RangeError
(
'
Attempt
to
allocate
Buffer
larger
than
maximum
'
+
'
size
:
0x
'
+
kMaxLength
(
)
.
toString
(
16
)
+
'
bytes
'
)
}
return
length
|
0
}
function
SlowBuffer
(
length
)
{
if
(
+
length
!
=
length
)
{
length
=
0
}
return
Buffer
.
alloc
(
+
length
)
}
Buffer
.
isBuffer
=
function
isBuffer
(
b
)
{
return
!
!
(
b
!
=
null
&
&
b
.
_isBuffer
)
}
Buffer
.
compare
=
function
compare
(
a
b
)
{
if
(
!
Buffer
.
isBuffer
(
a
)
|
|
!
Buffer
.
isBuffer
(
b
)
)
{
throw
new
TypeError
(
'
Arguments
must
be
Buffers
'
)
}
if
(
a
=
=
=
b
)
return
0
var
x
=
a
.
length
var
y
=
b
.
length
for
(
var
i
=
0
len
=
Math
.
min
(
x
y
)
;
i
<
len
;
+
+
i
)
{
if
(
a
[
i
]
!
=
=
b
[
i
]
)
{
x
=
a
[
i
]
y
=
b
[
i
]
break
}
}
if
(
x
<
y
)
return
-
1
if
(
y
<
x
)
return
1
return
0
}
Buffer
.
isEncoding
=
function
isEncoding
(
encoding
)
{
switch
(
String
(
encoding
)
.
toLowerCase
(
)
)
{
case
'
hex
'
:
case
'
utf8
'
:
case
'
utf
-
8
'
:
case
'
ascii
'
:
case
'
latin1
'
:
case
'
binary
'
:
case
'
base64
'
:
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
true
default
:
return
false
}
}
Buffer
.
concat
=
function
concat
(
list
length
)
{
if
(
!
isArray
(
list
)
)
{
throw
new
TypeError
(
'
"
list
"
argument
must
be
an
Array
of
Buffers
'
)
}
if
(
list
.
length
=
=
=
0
)
{
return
Buffer
.
alloc
(
0
)
}
var
i
if
(
length
=
=
=
undefined
)
{
length
=
0
for
(
i
=
0
;
i
<
list
.
length
;
+
+
i
)
{
length
+
=
list
[
i
]
.
length
}
}
var
buffer
=
Buffer
.
allocUnsafe
(
length
)
var
pos
=
0
for
(
i
=
0
;
i
<
list
.
length
;
+
+
i
)
{
var
buf
=
list
[
i
]
if
(
!
Buffer
.
isBuffer
(
buf
)
)
{
throw
new
TypeError
(
'
"
list
"
argument
must
be
an
Array
of
Buffers
'
)
}
buf
.
copy
(
buffer
pos
)
pos
+
=
buf
.
length
}
return
buffer
}
function
byteLength
(
string
encoding
)
{
if
(
Buffer
.
isBuffer
(
string
)
)
{
return
string
.
length
}
if
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
typeof
ArrayBuffer
.
isView
=
=
=
'
function
'
&
&
(
ArrayBuffer
.
isView
(
string
)
|
|
string
instanceof
ArrayBuffer
)
)
{
return
string
.
byteLength
}
if
(
typeof
string
!
=
=
'
string
'
)
{
string
=
'
'
+
string
}
var
len
=
string
.
length
if
(
len
=
=
=
0
)
return
0
var
loweredCase
=
false
for
(
;
;
)
{
switch
(
encoding
)
{
case
'
ascii
'
:
case
'
latin1
'
:
case
'
binary
'
:
return
len
case
'
utf8
'
:
case
'
utf
-
8
'
:
case
undefined
:
return
utf8ToBytes
(
string
)
.
length
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
len
*
2
case
'
hex
'
:
return
len
>
>
>
1
case
'
base64
'
:
return
base64ToBytes
(
string
)
.
length
default
:
if
(
loweredCase
)
return
utf8ToBytes
(
string
)
.
length
encoding
=
(
'
'
+
encoding
)
.
toLowerCase
(
)
loweredCase
=
true
}
}
}
Buffer
.
byteLength
=
byteLength
function
slowToString
(
encoding
start
end
)
{
var
loweredCase
=
false
if
(
start
=
=
=
undefined
|
|
start
<
0
)
{
start
=
0
}
if
(
start
>
this
.
length
)
{
return
'
'
}
if
(
end
=
=
=
undefined
|
|
end
>
this
.
length
)
{
end
=
this
.
length
}
if
(
end
<
=
0
)
{
return
'
'
}
end
>
>
>
=
0
start
>
>
>
=
0
if
(
end
<
=
start
)
{
return
'
'
}
if
(
!
encoding
)
encoding
=
'
utf8
'
while
(
true
)
{
switch
(
encoding
)
{
case
'
hex
'
:
return
hexSlice
(
this
start
end
)
case
'
utf8
'
:
case
'
utf
-
8
'
:
return
utf8Slice
(
this
start
end
)
case
'
ascii
'
:
return
asciiSlice
(
this
start
end
)
case
'
latin1
'
:
case
'
binary
'
:
return
latin1Slice
(
this
start
end
)
case
'
base64
'
:
return
base64Slice
(
this
start
end
)
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
utf16leSlice
(
this
start
end
)
default
:
if
(
loweredCase
)
throw
new
TypeError
(
'
Unknown
encoding
:
'
+
encoding
)
encoding
=
(
encoding
+
'
'
)
.
toLowerCase
(
)
loweredCase
=
true
}
}
}
Buffer
.
prototype
.
_isBuffer
=
true
function
swap
(
b
n
m
)
{
var
i
=
b
[
n
]
b
[
n
]
=
b
[
m
]
b
[
m
]
=
i
}
Buffer
.
prototype
.
swap16
=
function
swap16
(
)
{
var
len
=
this
.
length
if
(
len
%
2
!
=
=
0
)
{
throw
new
RangeError
(
'
Buffer
size
must
be
a
multiple
of
16
-
bits
'
)
}
for
(
var
i
=
0
;
i
<
len
;
i
+
=
2
)
{
swap
(
this
i
i
+
1
)
}
return
this
}
Buffer
.
prototype
.
swap32
=
function
swap32
(
)
{
var
len
=
this
.
length
if
(
len
%
4
!
=
=
0
)
{
throw
new
RangeError
(
'
Buffer
size
must
be
a
multiple
of
32
-
bits
'
)
}
for
(
var
i
=
0
;
i
<
len
;
i
+
=
4
)
{
swap
(
this
i
i
+
3
)
swap
(
this
i
+
1
i
+
2
)
}
return
this
}
Buffer
.
prototype
.
swap64
=
function
swap64
(
)
{
var
len
=
this
.
length
if
(
len
%
8
!
=
=
0
)
{
throw
new
RangeError
(
'
Buffer
size
must
be
a
multiple
of
64
-
bits
'
)
}
for
(
var
i
=
0
;
i
<
len
;
i
+
=
8
)
{
swap
(
this
i
i
+
7
)
swap
(
this
i
+
1
i
+
6
)
swap
(
this
i
+
2
i
+
5
)
swap
(
this
i
+
3
i
+
4
)
}
return
this
}
Buffer
.
prototype
.
toString
=
function
toString
(
)
{
var
length
=
this
.
length
|
0
if
(
length
=
=
=
0
)
return
'
'
if
(
arguments
.
length
=
=
=
0
)
return
utf8Slice
(
this
0
length
)
return
slowToString
.
apply
(
this
arguments
)
}
Buffer
.
prototype
.
equals
=
function
equals
(
b
)
{
if
(
!
Buffer
.
isBuffer
(
b
)
)
throw
new
TypeError
(
'
Argument
must
be
a
Buffer
'
)
if
(
this
=
=
=
b
)
return
true
return
Buffer
.
compare
(
this
b
)
=
=
=
0
}
Buffer
.
prototype
.
inspect
=
function
inspect
(
)
{
var
str
=
'
'
var
max
=
exports
.
INSPECT_MAX_BYTES
if
(
this
.
length
>
0
)
{
str
=
this
.
toString
(
'
hex
'
0
max
)
.
match
(
/
.
{
2
}
/
g
)
.
join
(
'
'
)
if
(
this
.
length
>
max
)
str
+
=
'
.
.
.
'
}
return
'
<
Buffer
'
+
str
+
'
>
'
}
Buffer
.
prototype
.
compare
=
function
compare
(
target
start
end
thisStart
thisEnd
)
{
if
(
!
Buffer
.
isBuffer
(
target
)
)
{
throw
new
TypeError
(
'
Argument
must
be
a
Buffer
'
)
}
if
(
start
=
=
=
undefined
)
{
start
=
0
}
if
(
end
=
=
=
undefined
)
{
end
=
target
?
target
.
length
:
0
}
if
(
thisStart
=
=
=
undefined
)
{
thisStart
=
0
}
if
(
thisEnd
=
=
=
undefined
)
{
thisEnd
=
this
.
length
}
if
(
start
<
0
|
|
end
>
target
.
length
|
|
thisStart
<
0
|
|
thisEnd
>
this
.
length
)
{
throw
new
RangeError
(
'
out
of
range
index
'
)
}
if
(
thisStart
>
=
thisEnd
&
&
start
>
=
end
)
{
return
0
}
if
(
thisStart
>
=
thisEnd
)
{
return
-
1
}
if
(
start
>
=
end
)
{
return
1
}
start
>
>
>
=
0
end
>
>
>
=
0
thisStart
>
>
>
=
0
thisEnd
>
>
>
=
0
if
(
this
=
=
=
target
)
return
0
var
x
=
thisEnd
-
thisStart
var
y
=
end
-
start
var
len
=
Math
.
min
(
x
y
)
var
thisCopy
=
this
.
slice
(
thisStart
thisEnd
)
var
targetCopy
=
target
.
slice
(
start
end
)
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
thisCopy
[
i
]
!
=
=
targetCopy
[
i
]
)
{
x
=
thisCopy
[
i
]
y
=
targetCopy
[
i
]
break
}
}
if
(
x
<
y
)
return
-
1
if
(
y
<
x
)
return
1
return
0
}
function
bidirectionalIndexOf
(
buffer
val
byteOffset
encoding
dir
)
{
if
(
buffer
.
length
=
=
=
0
)
return
-
1
if
(
typeof
byteOffset
=
=
=
'
string
'
)
{
encoding
=
byteOffset
byteOffset
=
0
}
else
if
(
byteOffset
>
0x7fffffff
)
{
byteOffset
=
0x7fffffff
}
else
if
(
byteOffset
<
-
0x80000000
)
{
byteOffset
=
-
0x80000000
}
byteOffset
=
+
byteOffset
if
(
isNaN
(
byteOffset
)
)
{
byteOffset
=
dir
?
0
:
(
buffer
.
length
-
1
)
}
if
(
byteOffset
<
0
)
byteOffset
=
buffer
.
length
+
byteOffset
if
(
byteOffset
>
=
buffer
.
length
)
{
if
(
dir
)
return
-
1
else
byteOffset
=
buffer
.
length
-
1
}
else
if
(
byteOffset
<
0
)
{
if
(
dir
)
byteOffset
=
0
else
return
-
1
}
if
(
typeof
val
=
=
=
'
string
'
)
{
val
=
Buffer
.
from
(
val
encoding
)
}
if
(
Buffer
.
isBuffer
(
val
)
)
{
if
(
val
.
length
=
=
=
0
)
{
return
-
1
}
return
arrayIndexOf
(
buffer
val
byteOffset
encoding
dir
)
}
else
if
(
typeof
val
=
=
=
'
number
'
)
{
val
=
val
&
0xFF
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
&
&
typeof
Uint8Array
.
prototype
.
indexOf
=
=
=
'
function
'
)
{
if
(
dir
)
{
return
Uint8Array
.
prototype
.
indexOf
.
call
(
buffer
val
byteOffset
)
}
else
{
return
Uint8Array
.
prototype
.
lastIndexOf
.
call
(
buffer
val
byteOffset
)
}
}
return
arrayIndexOf
(
buffer
[
val
]
byteOffset
encoding
dir
)
}
throw
new
TypeError
(
'
val
must
be
string
number
or
Buffer
'
)
}
function
arrayIndexOf
(
arr
val
byteOffset
encoding
dir
)
{
var
indexSize
=
1
var
arrLength
=
arr
.
length
var
valLength
=
val
.
length
if
(
encoding
!
=
=
undefined
)
{
encoding
=
String
(
encoding
)
.
toLowerCase
(
)
if
(
encoding
=
=
=
'
ucs2
'
|
|
encoding
=
=
=
'
ucs
-
2
'
|
|
encoding
=
=
=
'
utf16le
'
|
|
encoding
=
=
=
'
utf
-
16le
'
)
{
if
(
arr
.
length
<
2
|
|
val
.
length
<
2
)
{
return
-
1
}
indexSize
=
2
arrLength
/
=
2
valLength
/
=
2
byteOffset
/
=
2
}
}
function
read
(
buf
i
)
{
if
(
indexSize
=
=
=
1
)
{
return
buf
[
i
]
}
else
{
return
buf
.
readUInt16BE
(
i
*
indexSize
)
}
}
var
i
if
(
dir
)
{
var
foundIndex
=
-
1
for
(
i
=
byteOffset
;
i
<
arrLength
;
i
+
+
)
{
if
(
read
(
arr
i
)
=
=
=
read
(
val
foundIndex
=
=
=
-
1
?
0
:
i
-
foundIndex
)
)
{
if
(
foundIndex
=
=
=
-
1
)
foundIndex
=
i
if
(
i
-
foundIndex
+
1
=
=
=
valLength
)
return
foundIndex
*
indexSize
}
else
{
if
(
foundIndex
!
=
=
-
1
)
i
-
=
i
-
foundIndex
foundIndex
=
-
1
}
}
}
else
{
if
(
byteOffset
+
valLength
>
arrLength
)
byteOffset
=
arrLength
-
valLength
for
(
i
=
byteOffset
;
i
>
=
0
;
i
-
-
)
{
var
found
=
true
for
(
var
j
=
0
;
j
<
valLength
;
j
+
+
)
{
if
(
read
(
arr
i
+
j
)
!
=
=
read
(
val
j
)
)
{
found
=
false
break
}
}
if
(
found
)
return
i
}
}
return
-
1
}
Buffer
.
prototype
.
includes
=
function
includes
(
val
byteOffset
encoding
)
{
return
this
.
indexOf
(
val
byteOffset
encoding
)
!
=
=
-
1
}
Buffer
.
prototype
.
indexOf
=
function
indexOf
(
val
byteOffset
encoding
)
{
return
bidirectionalIndexOf
(
this
val
byteOffset
encoding
true
)
}
Buffer
.
prototype
.
lastIndexOf
=
function
lastIndexOf
(
val
byteOffset
encoding
)
{
return
bidirectionalIndexOf
(
this
val
byteOffset
encoding
false
)
}
function
hexWrite
(
buf
string
offset
length
)
{
offset
=
Number
(
offset
)
|
|
0
var
remaining
=
buf
.
length
-
offset
if
(
!
length
)
{
length
=
remaining
}
else
{
length
=
Number
(
length
)
if
(
length
>
remaining
)
{
length
=
remaining
}
}
var
strLen
=
string
.
length
if
(
strLen
%
2
!
=
=
0
)
throw
new
TypeError
(
'
Invalid
hex
string
'
)
if
(
length
>
strLen
/
2
)
{
length
=
strLen
/
2
}
for
(
var
i
=
0
;
i
<
length
;
+
+
i
)
{
var
parsed
=
parseInt
(
string
.
substr
(
i
*
2
2
)
16
)
if
(
isNaN
(
parsed
)
)
return
i
buf
[
offset
+
i
]
=
parsed
}
return
i
}
function
utf8Write
(
buf
string
offset
length
)
{
return
blitBuffer
(
utf8ToBytes
(
string
buf
.
length
-
offset
)
buf
offset
length
)
}
function
asciiWrite
(
buf
string
offset
length
)
{
return
blitBuffer
(
asciiToBytes
(
string
)
buf
offset
length
)
}
function
latin1Write
(
buf
string
offset
length
)
{
return
asciiWrite
(
buf
string
offset
length
)
}
function
base64Write
(
buf
string
offset
length
)
{
return
blitBuffer
(
base64ToBytes
(
string
)
buf
offset
length
)
}
function
ucs2Write
(
buf
string
offset
length
)
{
return
blitBuffer
(
utf16leToBytes
(
string
buf
.
length
-
offset
)
buf
offset
length
)
}
Buffer
.
prototype
.
write
=
function
write
(
string
offset
length
encoding
)
{
if
(
offset
=
=
=
undefined
)
{
encoding
=
'
utf8
'
length
=
this
.
length
offset
=
0
}
else
if
(
length
=
=
=
undefined
&
&
typeof
offset
=
=
=
'
string
'
)
{
encoding
=
offset
length
=
this
.
length
offset
=
0
}
else
if
(
isFinite
(
offset
)
)
{
offset
=
offset
|
0
if
(
isFinite
(
length
)
)
{
length
=
length
|
0
if
(
encoding
=
=
=
undefined
)
encoding
=
'
utf8
'
}
else
{
encoding
=
length
length
=
undefined
}
}
else
{
throw
new
Error
(
'
Buffer
.
write
(
string
encoding
offset
[
length
]
)
is
no
longer
supported
'
)
}
var
remaining
=
this
.
length
-
offset
if
(
length
=
=
=
undefined
|
|
length
>
remaining
)
length
=
remaining
if
(
(
string
.
length
>
0
&
&
(
length
<
0
|
|
offset
<
0
)
)
|
|
offset
>
this
.
length
)
{
throw
new
RangeError
(
'
Attempt
to
write
outside
buffer
bounds
'
)
}
if
(
!
encoding
)
encoding
=
'
utf8
'
var
loweredCase
=
false
for
(
;
;
)
{
switch
(
encoding
)
{
case
'
hex
'
:
return
hexWrite
(
this
string
offset
length
)
case
'
utf8
'
:
case
'
utf
-
8
'
:
return
utf8Write
(
this
string
offset
length
)
case
'
ascii
'
:
return
asciiWrite
(
this
string
offset
length
)
case
'
latin1
'
:
case
'
binary
'
:
return
latin1Write
(
this
string
offset
length
)
case
'
base64
'
:
return
base64Write
(
this
string
offset
length
)
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
ucs2Write
(
this
string
offset
length
)
default
:
if
(
loweredCase
)
throw
new
TypeError
(
'
Unknown
encoding
:
'
+
encoding
)
encoding
=
(
'
'
+
encoding
)
.
toLowerCase
(
)
loweredCase
=
true
}
}
}
Buffer
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
type
:
'
Buffer
'
data
:
Array
.
prototype
.
slice
.
call
(
this
.
_arr
|
|
this
0
)
}
}
function
base64Slice
(
buf
start
end
)
{
if
(
start
=
=
=
0
&
&
end
=
=
=
buf
.
length
)
{
return
base64
.
fromByteArray
(
buf
)
}
else
{
return
base64
.
fromByteArray
(
buf
.
slice
(
start
end
)
)
}
}
function
utf8Slice
(
buf
start
end
)
{
end
=
Math
.
min
(
buf
.
length
end
)
var
res
=
[
]
var
i
=
start
while
(
i
<
end
)
{
var
firstByte
=
buf
[
i
]
var
codePoint
=
null
var
bytesPerSequence
=
(
firstByte
>
0xEF
)
?
4
:
(
firstByte
>
0xDF
)
?
3
:
(
firstByte
>
0xBF
)
?
2
:
1
if
(
i
+
bytesPerSequence
<
=
end
)
{
var
secondByte
thirdByte
fourthByte
tempCodePoint
switch
(
bytesPerSequence
)
{
case
1
:
if
(
firstByte
<
0x80
)
{
codePoint
=
firstByte
}
break
case
2
:
secondByte
=
buf
[
i
+
1
]
if
(
(
secondByte
&
0xC0
)
=
=
=
0x80
)
{
tempCodePoint
=
(
firstByte
&
0x1F
)
<
<
0x6
|
(
secondByte
&
0x3F
)
if
(
tempCodePoint
>
0x7F
)
{
codePoint
=
tempCodePoint
}
}
break
case
3
:
secondByte
=
buf
[
i
+
1
]
thirdByte
=
buf
[
i
+
2
]
if
(
(
secondByte
&
0xC0
)
=
=
=
0x80
&
&
(
thirdByte
&
0xC0
)
=
=
=
0x80
)
{
tempCodePoint
=
(
firstByte
&
0xF
)
<
<
0xC
|
(
secondByte
&
0x3F
)
<
<
0x6
|
(
thirdByte
&
0x3F
)
if
(
tempCodePoint
>
0x7FF
&
&
(
tempCodePoint
<
0xD800
|
|
tempCodePoint
>
0xDFFF
)
)
{
codePoint
=
tempCodePoint
}
}
break
case
4
:
secondByte
=
buf
[
i
+
1
]
thirdByte
=
buf
[
i
+
2
]
fourthByte
=
buf
[
i
+
3
]
if
(
(
secondByte
&
0xC0
)
=
=
=
0x80
&
&
(
thirdByte
&
0xC0
)
=
=
=
0x80
&
&
(
fourthByte
&
0xC0
)
=
=
=
0x80
)
{
tempCodePoint
=
(
firstByte
&
0xF
)
<
<
0x12
|
(
secondByte
&
0x3F
)
<
<
0xC
|
(
thirdByte
&
0x3F
)
<
<
0x6
|
(
fourthByte
&
0x3F
)
if
(
tempCodePoint
>
0xFFFF
&
&
tempCodePoint
<
0x110000
)
{
codePoint
=
tempCodePoint
}
}
}
}
if
(
codePoint
=
=
=
null
)
{
codePoint
=
0xFFFD
bytesPerSequence
=
1
}
else
if
(
codePoint
>
0xFFFF
)
{
codePoint
-
=
0x10000
res
.
push
(
codePoint
>
>
>
10
&
0x3FF
|
0xD800
)
codePoint
=
0xDC00
|
codePoint
&
0x3FF
}
res
.
push
(
codePoint
)
i
+
=
bytesPerSequence
}
return
decodeCodePointsArray
(
res
)
}
var
MAX_ARGUMENTS_LENGTH
=
0x1000
function
decodeCodePointsArray
(
codePoints
)
{
var
len
=
codePoints
.
length
if
(
len
<
=
MAX_ARGUMENTS_LENGTH
)
{
return
String
.
fromCharCode
.
apply
(
String
codePoints
)
}
var
res
=
'
'
var
i
=
0
while
(
i
<
len
)
{
res
+
=
String
.
fromCharCode
.
apply
(
String
codePoints
.
slice
(
i
i
+
=
MAX_ARGUMENTS_LENGTH
)
)
}
return
res
}
function
asciiSlice
(
buf
start
end
)
{
var
ret
=
'
'
end
=
Math
.
min
(
buf
.
length
end
)
for
(
var
i
=
start
;
i
<
end
;
+
+
i
)
{
ret
+
=
String
.
fromCharCode
(
buf
[
i
]
&
0x7F
)
}
return
ret
}
function
latin1Slice
(
buf
start
end
)
{
var
ret
=
'
'
end
=
Math
.
min
(
buf
.
length
end
)
for
(
var
i
=
start
;
i
<
end
;
+
+
i
)
{
ret
+
=
String
.
fromCharCode
(
buf
[
i
]
)
}
return
ret
}
function
hexSlice
(
buf
start
end
)
{
var
len
=
buf
.
length
if
(
!
start
|
|
start
<
0
)
start
=
0
if
(
!
end
|
|
end
<
0
|
|
end
>
len
)
end
=
len
var
out
=
'
'
for
(
var
i
=
start
;
i
<
end
;
+
+
i
)
{
out
+
=
toHex
(
buf
[
i
]
)
}
return
out
}
function
utf16leSlice
(
buf
start
end
)
{
var
bytes
=
buf
.
slice
(
start
end
)
var
res
=
'
'
for
(
var
i
=
0
;
i
<
bytes
.
length
;
i
+
=
2
)
{
res
+
=
String
.
fromCharCode
(
bytes
[
i
]
+
bytes
[
i
+
1
]
*
256
)
}
return
res
}
Buffer
.
prototype
.
slice
=
function
slice
(
start
end
)
{
var
len
=
this
.
length
start
=
~
~
start
end
=
end
=
=
=
undefined
?
len
:
~
~
end
if
(
start
<
0
)
{
start
+
=
len
if
(
start
<
0
)
start
=
0
}
else
if
(
start
>
len
)
{
start
=
len
}
if
(
end
<
0
)
{
end
+
=
len
if
(
end
<
0
)
end
=
0
}
else
if
(
end
>
len
)
{
end
=
len
}
if
(
end
<
start
)
end
=
start
var
newBuf
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
newBuf
=
this
.
subarray
(
start
end
)
newBuf
.
__proto__
=
Buffer
.
prototype
}
else
{
var
sliceLen
=
end
-
start
newBuf
=
new
Buffer
(
sliceLen
undefined
)
for
(
var
i
=
0
;
i
<
sliceLen
;
+
+
i
)
{
newBuf
[
i
]
=
this
[
i
+
start
]
}
}
return
newBuf
}
function
checkOffset
(
offset
ext
length
)
{
if
(
(
offset
%
1
)
!
=
=
0
|
|
offset
<
0
)
throw
new
RangeError
(
'
offset
is
not
uint
'
)
if
(
offset
+
ext
>
length
)
throw
new
RangeError
(
'
Trying
to
access
beyond
buffer
length
'
)
}
Buffer
.
prototype
.
readUIntLE
=
function
readUIntLE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
checkOffset
(
offset
byteLength
this
.
length
)
var
val
=
this
[
offset
]
var
mul
=
1
var
i
=
0
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
i
]
*
mul
}
return
val
}
Buffer
.
prototype
.
readUIntBE
=
function
readUIntBE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
{
checkOffset
(
offset
byteLength
this
.
length
)
}
var
val
=
this
[
offset
+
-
-
byteLength
]
var
mul
=
1
while
(
byteLength
>
0
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
-
-
byteLength
]
*
mul
}
return
val
}
Buffer
.
prototype
.
readUInt8
=
function
readUInt8
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
1
this
.
length
)
return
this
[
offset
]
}
Buffer
.
prototype
.
readUInt16LE
=
function
readUInt16LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
return
this
[
offset
]
|
(
this
[
offset
+
1
]
<
<
8
)
}
Buffer
.
prototype
.
readUInt16BE
=
function
readUInt16BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
return
(
this
[
offset
]
<
<
8
)
|
this
[
offset
+
1
]
}
Buffer
.
prototype
.
readUInt32LE
=
function
readUInt32LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
(
this
[
offset
]
)
|
(
this
[
offset
+
1
]
<
<
8
)
|
(
this
[
offset
+
2
]
<
<
16
)
)
+
(
this
[
offset
+
3
]
*
0x1000000
)
}
Buffer
.
prototype
.
readUInt32BE
=
function
readUInt32BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
this
[
offset
]
*
0x1000000
)
+
(
(
this
[
offset
+
1
]
<
<
16
)
|
(
this
[
offset
+
2
]
<
<
8
)
|
this
[
offset
+
3
]
)
}
Buffer
.
prototype
.
readIntLE
=
function
readIntLE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
checkOffset
(
offset
byteLength
this
.
length
)
var
val
=
this
[
offset
]
var
mul
=
1
var
i
=
0
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
i
]
*
mul
}
mul
*
=
0x80
if
(
val
>
=
mul
)
val
-
=
Math
.
pow
(
2
8
*
byteLength
)
return
val
}
Buffer
.
prototype
.
readIntBE
=
function
readIntBE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
checkOffset
(
offset
byteLength
this
.
length
)
var
i
=
byteLength
var
mul
=
1
var
val
=
this
[
offset
+
-
-
i
]
while
(
i
>
0
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
-
-
i
]
*
mul
}
mul
*
=
0x80
if
(
val
>
=
mul
)
val
-
=
Math
.
pow
(
2
8
*
byteLength
)
return
val
}
Buffer
.
prototype
.
readInt8
=
function
readInt8
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
1
this
.
length
)
if
(
!
(
this
[
offset
]
&
0x80
)
)
return
(
this
[
offset
]
)
return
(
(
0xff
-
this
[
offset
]
+
1
)
*
-
1
)
}
Buffer
.
prototype
.
readInt16LE
=
function
readInt16LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
var
val
=
this
[
offset
]
|
(
this
[
offset
+
1
]
<
<
8
)
return
(
val
&
0x8000
)
?
val
|
0xFFFF0000
:
val
}
Buffer
.
prototype
.
readInt16BE
=
function
readInt16BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
var
val
=
this
[
offset
+
1
]
|
(
this
[
offset
]
<
<
8
)
return
(
val
&
0x8000
)
?
val
|
0xFFFF0000
:
val
}
Buffer
.
prototype
.
readInt32LE
=
function
readInt32LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
this
[
offset
]
)
|
(
this
[
offset
+
1
]
<
<
8
)
|
(
this
[
offset
+
2
]
<
<
16
)
|
(
this
[
offset
+
3
]
<
<
24
)
}
Buffer
.
prototype
.
readInt32BE
=
function
readInt32BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
this
[
offset
]
<
<
24
)
|
(
this
[
offset
+
1
]
<
<
16
)
|
(
this
[
offset
+
2
]
<
<
8
)
|
(
this
[
offset
+
3
]
)
}
Buffer
.
prototype
.
readFloatLE
=
function
readFloatLE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
ieee754
.
read
(
this
offset
true
23
4
)
}
Buffer
.
prototype
.
readFloatBE
=
function
readFloatBE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
ieee754
.
read
(
this
offset
false
23
4
)
}
Buffer
.
prototype
.
readDoubleLE
=
function
readDoubleLE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
8
this
.
length
)
return
ieee754
.
read
(
this
offset
true
52
8
)
}
Buffer
.
prototype
.
readDoubleBE
=
function
readDoubleBE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
8
this
.
length
)
return
ieee754
.
read
(
this
offset
false
52
8
)
}
function
checkInt
(
buf
value
offset
ext
max
min
)
{
if
(
!
Buffer
.
isBuffer
(
buf
)
)
throw
new
TypeError
(
'
"
buffer
"
argument
must
be
a
Buffer
instance
'
)
if
(
value
>
max
|
|
value
<
min
)
throw
new
RangeError
(
'
"
value
"
argument
is
out
of
bounds
'
)
if
(
offset
+
ext
>
buf
.
length
)
throw
new
RangeError
(
'
Index
out
of
range
'
)
}
Buffer
.
prototype
.
writeUIntLE
=
function
writeUIntLE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
{
var
maxBytes
=
Math
.
pow
(
2
8
*
byteLength
)
-
1
checkInt
(
this
value
offset
byteLength
maxBytes
0
)
}
var
mul
=
1
var
i
=
0
this
[
offset
]
=
value
&
0xFF
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
this
[
offset
+
i
]
=
(
value
/
mul
)
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeUIntBE
=
function
writeUIntBE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
{
var
maxBytes
=
Math
.
pow
(
2
8
*
byteLength
)
-
1
checkInt
(
this
value
offset
byteLength
maxBytes
0
)
}
var
i
=
byteLength
-
1
var
mul
=
1
this
[
offset
+
i
]
=
value
&
0xFF
while
(
-
-
i
>
=
0
&
&
(
mul
*
=
0x100
)
)
{
this
[
offset
+
i
]
=
(
value
/
mul
)
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeUInt8
=
function
writeUInt8
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
1
0xff
0
)
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
value
=
Math
.
floor
(
value
)
this
[
offset
]
=
(
value
&
0xff
)
return
offset
+
1
}
function
objectWriteUInt16
(
buf
value
offset
littleEndian
)
{
if
(
value
<
0
)
value
=
0xffff
+
value
+
1
for
(
var
i
=
0
j
=
Math
.
min
(
buf
.
length
-
offset
2
)
;
i
<
j
;
+
+
i
)
{
buf
[
offset
+
i
]
=
(
value
&
(
0xff
<
<
(
8
*
(
littleEndian
?
i
:
1
-
i
)
)
)
)
>
>
>
(
littleEndian
?
i
:
1
-
i
)
*
8
}
}
Buffer
.
prototype
.
writeUInt16LE
=
function
writeUInt16LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0xffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
&
0xff
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
}
else
{
objectWriteUInt16
(
this
value
offset
true
)
}
return
offset
+
2
}
Buffer
.
prototype
.
writeUInt16BE
=
function
writeUInt16BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0xffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
8
)
this
[
offset
+
1
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt16
(
this
value
offset
false
)
}
return
offset
+
2
}
function
objectWriteUInt32
(
buf
value
offset
littleEndian
)
{
if
(
value
<
0
)
value
=
0xffffffff
+
value
+
1
for
(
var
i
=
0
j
=
Math
.
min
(
buf
.
length
-
offset
4
)
;
i
<
j
;
+
+
i
)
{
buf
[
offset
+
i
]
=
(
value
>
>
>
(
littleEndian
?
i
:
3
-
i
)
*
8
)
&
0xff
}
}
Buffer
.
prototype
.
writeUInt32LE
=
function
writeUInt32LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0xffffffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
+
3
]
=
(
value
>
>
>
24
)
this
[
offset
+
2
]
=
(
value
>
>
>
16
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
this
[
offset
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt32
(
this
value
offset
true
)
}
return
offset
+
4
}
Buffer
.
prototype
.
writeUInt32BE
=
function
writeUInt32BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0xffffffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
24
)
this
[
offset
+
1
]
=
(
value
>
>
>
16
)
this
[
offset
+
2
]
=
(
value
>
>
>
8
)
this
[
offset
+
3
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt32
(
this
value
offset
false
)
}
return
offset
+
4
}
Buffer
.
prototype
.
writeIntLE
=
function
writeIntLE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
{
var
limit
=
Math
.
pow
(
2
8
*
byteLength
-
1
)
checkInt
(
this
value
offset
byteLength
limit
-
1
-
limit
)
}
var
i
=
0
var
mul
=
1
var
sub
=
0
this
[
offset
]
=
value
&
0xFF
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
if
(
value
<
0
&
&
sub
=
=
=
0
&
&
this
[
offset
+
i
-
1
]
!
=
=
0
)
{
sub
=
1
}
this
[
offset
+
i
]
=
(
(
value
/
mul
)
>
>
0
)
-
sub
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeIntBE
=
function
writeIntBE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
{
var
limit
=
Math
.
pow
(
2
8
*
byteLength
-
1
)
checkInt
(
this
value
offset
byteLength
limit
-
1
-
limit
)
}
var
i
=
byteLength
-
1
var
mul
=
1
var
sub
=
0
this
[
offset
+
i
]
=
value
&
0xFF
while
(
-
-
i
>
=
0
&
&
(
mul
*
=
0x100
)
)
{
if
(
value
<
0
&
&
sub
=
=
=
0
&
&
this
[
offset
+
i
+
1
]
!
=
=
0
)
{
sub
=
1
}
this
[
offset
+
i
]
=
(
(
value
/
mul
)
>
>
0
)
-
sub
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeInt8
=
function
writeInt8
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
1
0x7f
-
0x80
)
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
value
=
Math
.
floor
(
value
)
if
(
value
<
0
)
value
=
0xff
+
value
+
1
this
[
offset
]
=
(
value
&
0xff
)
return
offset
+
1
}
Buffer
.
prototype
.
writeInt16LE
=
function
writeInt16LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0x7fff
-
0x8000
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
&
0xff
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
}
else
{
objectWriteUInt16
(
this
value
offset
true
)
}
return
offset
+
2
}
Buffer
.
prototype
.
writeInt16BE
=
function
writeInt16BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0x7fff
-
0x8000
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
8
)
this
[
offset
+
1
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt16
(
this
value
offset
false
)
}
return
offset
+
2
}
Buffer
.
prototype
.
writeInt32LE
=
function
writeInt32LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0x7fffffff
-
0x80000000
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
&
0xff
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
this
[
offset
+
2
]
=
(
value
>
>
>
16
)
this
[
offset
+
3
]
=
(
value
>
>
>
24
)
}
else
{
objectWriteUInt32
(
this
value
offset
true
)
}
return
offset
+
4
}
Buffer
.
prototype
.
writeInt32BE
=
function
writeInt32BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0x7fffffff
-
0x80000000
)
if
(
value
<
0
)
value
=
0xffffffff
+
value
+
1
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
24
)
this
[
offset
+
1
]
=
(
value
>
>
>
16
)
this
[
offset
+
2
]
=
(
value
>
>
>
8
)
this
[
offset
+
3
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt32
(
this
value
offset
false
)
}
return
offset
+
4
}
function
checkIEEE754
(
buf
value
offset
ext
max
min
)
{
if
(
offset
+
ext
>
buf
.
length
)
throw
new
RangeError
(
'
Index
out
of
range
'
)
if
(
offset
<
0
)
throw
new
RangeError
(
'
Index
out
of
range
'
)
}
function
writeFloat
(
buf
value
offset
littleEndian
noAssert
)
{
if
(
!
noAssert
)
{
checkIEEE754
(
buf
value
offset
4
3
.
4028234663852886e
+
38
-
3
.
4028234663852886e
+
38
)
}
ieee754
.
write
(
buf
value
offset
littleEndian
23
4
)
return
offset
+
4
}
Buffer
.
prototype
.
writeFloatLE
=
function
writeFloatLE
(
value
offset
noAssert
)
{
return
writeFloat
(
this
value
offset
true
noAssert
)
}
Buffer
.
prototype
.
writeFloatBE
=
function
writeFloatBE
(
value
offset
noAssert
)
{
return
writeFloat
(
this
value
offset
false
noAssert
)
}
function
writeDouble
(
buf
value
offset
littleEndian
noAssert
)
{
if
(
!
noAssert
)
{
checkIEEE754
(
buf
value
offset
8
1
.
7976931348623157E
+
308
-
1
.
7976931348623157E
+
308
)
}
ieee754
.
write
(
buf
value
offset
littleEndian
52
8
)
return
offset
+
8
}
Buffer
.
prototype
.
writeDoubleLE
=
function
writeDoubleLE
(
value
offset
noAssert
)
{
return
writeDouble
(
this
value
offset
true
noAssert
)
}
Buffer
.
prototype
.
writeDoubleBE
=
function
writeDoubleBE
(
value
offset
noAssert
)
{
return
writeDouble
(
this
value
offset
false
noAssert
)
}
Buffer
.
prototype
.
copy
=
function
copy
(
target
targetStart
start
end
)
{
if
(
!
start
)
start
=
0
if
(
!
end
&
&
end
!
=
=
0
)
end
=
this
.
length
if
(
targetStart
>
=
target
.
length
)
targetStart
=
target
.
length
if
(
!
targetStart
)
targetStart
=
0
if
(
end
>
0
&
&
end
<
start
)
end
=
start
if
(
end
=
=
=
start
)
return
0
if
(
target
.
length
=
=
=
0
|
|
this
.
length
=
=
=
0
)
return
0
if
(
targetStart
<
0
)
{
throw
new
RangeError
(
'
targetStart
out
of
bounds
'
)
}
if
(
start
<
0
|
|
start
>
=
this
.
length
)
throw
new
RangeError
(
'
sourceStart
out
of
bounds
'
)
if
(
end
<
0
)
throw
new
RangeError
(
'
sourceEnd
out
of
bounds
'
)
if
(
end
>
this
.
length
)
end
=
this
.
length
if
(
target
.
length
-
targetStart
<
end
-
start
)
{
end
=
target
.
length
-
targetStart
+
start
}
var
len
=
end
-
start
var
i
if
(
this
=
=
=
target
&
&
start
<
targetStart
&
&
targetStart
<
end
)
{
for
(
i
=
len
-
1
;
i
>
=
0
;
-
-
i
)
{
target
[
i
+
targetStart
]
=
this
[
i
+
start
]
}
}
else
if
(
len
<
1000
|
|
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
for
(
i
=
0
;
i
<
len
;
+
+
i
)
{
target
[
i
+
targetStart
]
=
this
[
i
+
start
]
}
}
else
{
Uint8Array
.
prototype
.
set
.
call
(
target
this
.
subarray
(
start
start
+
len
)
targetStart
)
}
return
len
}
Buffer
.
prototype
.
fill
=
function
fill
(
val
start
end
encoding
)
{
if
(
typeof
val
=
=
=
'
string
'
)
{
if
(
typeof
start
=
=
=
'
string
'
)
{
encoding
=
start
start
=
0
end
=
this
.
length
}
else
if
(
typeof
end
=
=
=
'
string
'
)
{
encoding
=
end
end
=
this
.
length
}
if
(
val
.
length
=
=
=
1
)
{
var
code
=
val
.
charCodeAt
(
0
)
if
(
code
<
256
)
{
val
=
code
}
}
if
(
encoding
!
=
=
undefined
&
&
typeof
encoding
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
encoding
must
be
a
string
'
)
}
if
(
typeof
encoding
=
=
=
'
string
'
&
&
!
Buffer
.
isEncoding
(
encoding
)
)
{
throw
new
TypeError
(
'
Unknown
encoding
:
'
+
encoding
)
}
}
else
if
(
typeof
val
=
=
=
'
number
'
)
{
val
=
val
&
255
}
if
(
start
<
0
|
|
this
.
length
<
start
|
|
this
.
length
<
end
)
{
throw
new
RangeError
(
'
Out
of
range
index
'
)
}
if
(
end
<
=
start
)
{
return
this
}
start
=
start
>
>
>
0
end
=
end
=
=
=
undefined
?
this
.
length
:
end
>
>
>
0
if
(
!
val
)
val
=
0
var
i
if
(
typeof
val
=
=
=
'
number
'
)
{
for
(
i
=
start
;
i
<
end
;
+
+
i
)
{
this
[
i
]
=
val
}
}
else
{
var
bytes
=
Buffer
.
isBuffer
(
val
)
?
val
:
utf8ToBytes
(
new
Buffer
(
val
encoding
)
.
toString
(
)
)
var
len
=
bytes
.
length
for
(
i
=
0
;
i
<
end
-
start
;
+
+
i
)
{
this
[
i
+
start
]
=
bytes
[
i
%
len
]
}
}
return
this
}
var
INVALID_BASE64_RE
=
/
[
^
+
\
/
0
-
9A
-
Za
-
z
-
_
]
/
g
function
base64clean
(
str
)
{
str
=
stringtrim
(
str
)
.
replace
(
INVALID_BASE64_RE
'
'
)
if
(
str
.
length
<
2
)
return
'
'
while
(
str
.
length
%
4
!
=
=
0
)
{
str
=
str
+
'
=
'
}
return
str
}
function
stringtrim
(
str
)
{
if
(
str
.
trim
)
return
str
.
trim
(
)
return
str
.
replace
(
/
^
\
s
+
|
\
s
+
/
g
'
'
)
}
function
toHex
(
n
)
{
if
(
n
<
16
)
return
'
0
'
+
n
.
toString
(
16
)
return
n
.
toString
(
16
)
}
function
utf8ToBytes
(
string
units
)
{
units
=
units
|
|
Infinity
var
codePoint
var
length
=
string
.
length
var
leadSurrogate
=
null
var
bytes
=
[
]
for
(
var
i
=
0
;
i
<
length
;
+
+
i
)
{
codePoint
=
string
.
charCodeAt
(
i
)
if
(
codePoint
>
0xD7FF
&
&
codePoint
<
0xE000
)
{
if
(
!
leadSurrogate
)
{
if
(
codePoint
>
0xDBFF
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
continue
}
else
if
(
i
+
1
=
=
=
length
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
continue
}
leadSurrogate
=
codePoint
continue
}
if
(
codePoint
<
0xDC00
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
leadSurrogate
=
codePoint
continue
}
codePoint
=
(
leadSurrogate
-
0xD800
<
<
10
|
codePoint
-
0xDC00
)
+
0x10000
}
else
if
(
leadSurrogate
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
}
leadSurrogate
=
null
if
(
codePoint
<
0x80
)
{
if
(
(
units
-
=
1
)
<
0
)
break
bytes
.
push
(
codePoint
)
}
else
if
(
codePoint
<
0x800
)
{
if
(
(
units
-
=
2
)
<
0
)
break
bytes
.
push
(
codePoint
>
>
0x6
|
0xC0
codePoint
&
0x3F
|
0x80
)
}
else
if
(
codePoint
<
0x10000
)
{
if
(
(
units
-
=
3
)
<
0
)
break
bytes
.
push
(
codePoint
>
>
0xC
|
0xE0
codePoint
>
>
0x6
&
0x3F
|
0x80
codePoint
&
0x3F
|
0x80
)
}
else
if
(
codePoint
<
0x110000
)
{
if
(
(
units
-
=
4
)
<
0
)
break
bytes
.
push
(
codePoint
>
>
0x12
|
0xF0
codePoint
>
>
0xC
&
0x3F
|
0x80
codePoint
>
>
0x6
&
0x3F
|
0x80
codePoint
&
0x3F
|
0x80
)
}
else
{
throw
new
Error
(
'
Invalid
code
point
'
)
}
}
return
bytes
}
function
asciiToBytes
(
str
)
{
var
byteArray
=
[
]
for
(
var
i
=
0
;
i
<
str
.
length
;
+
+
i
)
{
byteArray
.
push
(
str
.
charCodeAt
(
i
)
&
0xFF
)
}
return
byteArray
}
function
utf16leToBytes
(
str
units
)
{
var
c
hi
lo
var
byteArray
=
[
]
for
(
var
i
=
0
;
i
<
str
.
length
;
+
+
i
)
{
if
(
(
units
-
=
2
)
<
0
)
break
c
=
str
.
charCodeAt
(
i
)
hi
=
c
>
>
8
lo
=
c
%
256
byteArray
.
push
(
lo
)
byteArray
.
push
(
hi
)
}
return
byteArray
}
function
base64ToBytes
(
str
)
{
return
base64
.
toByteArray
(
base64clean
(
str
)
)
}
function
blitBuffer
(
src
dst
offset
length
)
{
for
(
var
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
(
i
+
offset
>
=
dst
.
length
)
|
|
(
i
>
=
src
.
length
)
)
break
dst
[
i
+
offset
]
=
src
[
i
]
}
return
i
}
function
isnan
(
val
)
{
return
val
!
=
=
val
}
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
base64
-
js
"
:
39
"
ieee754
"
:
65
"
isarray
"
:
68
}
]
45
:
[
function
(
require
module
exports
)
{
(
function
(
Buffer
)
{
function
isArray
(
arg
)
{
if
(
Array
.
isArray
)
{
return
Array
.
isArray
(
arg
)
;
}
return
objectToString
(
arg
)
=
=
=
'
[
object
Array
]
'
;
}
exports
.
isArray
=
isArray
;
function
isBoolean
(
arg
)
{
return
typeof
arg
=
=
=
'
boolean
'
;
}
exports
.
isBoolean
=
isBoolean
;
function
isNull
(
arg
)
{
return
arg
=
=
=
null
;
}
exports
.
isNull
=
isNull
;
function
isNullOrUndefined
(
arg
)
{
return
arg
=
=
null
;
}
exports
.
isNullOrUndefined
=
isNullOrUndefined
;
function
isNumber
(
arg
)
{
return
typeof
arg
=
=
=
'
number
'
;
}
exports
.
isNumber
=
isNumber
;
function
isString
(
arg
)
{
return
typeof
arg
=
=
=
'
string
'
;
}
exports
.
isString
=
isString
;
function
isSymbol
(
arg
)
{
return
typeof
arg
=
=
=
'
symbol
'
;
}
exports
.
isSymbol
=
isSymbol
;
function
isUndefined
(
arg
)
{
return
arg
=
=
=
void
0
;
}
exports
.
isUndefined
=
isUndefined
;
function
isRegExp
(
re
)
{
return
objectToString
(
re
)
=
=
=
'
[
object
RegExp
]
'
;
}
exports
.
isRegExp
=
isRegExp
;
function
isObject
(
arg
)
{
return
typeof
arg
=
=
=
'
object
'
&
&
arg
!
=
=
null
;
}
exports
.
isObject
=
isObject
;
function
isDate
(
d
)
{
return
objectToString
(
d
)
=
=
=
'
[
object
Date
]
'
;
}
exports
.
isDate
=
isDate
;
function
isError
(
e
)
{
return
(
objectToString
(
e
)
=
=
=
'
[
object
Error
]
'
|
|
e
instanceof
Error
)
;
}
exports
.
isError
=
isError
;
function
isFunction
(
arg
)
{
return
typeof
arg
=
=
=
'
function
'
;
}
exports
.
isFunction
=
isFunction
;
function
isPrimitive
(
arg
)
{
return
arg
=
=
=
null
|
|
typeof
arg
=
=
=
'
boolean
'
|
|
typeof
arg
=
=
=
'
number
'
|
|
typeof
arg
=
=
=
'
string
'
|
|
typeof
arg
=
=
=
'
symbol
'
|
|
typeof
arg
=
=
=
'
undefined
'
;
}
exports
.
isPrimitive
=
isPrimitive
;
exports
.
isBuffer
=
Buffer
.
isBuffer
;
function
objectToString
(
o
)
{
return
Object
.
prototype
.
toString
.
call
(
o
)
;
}
}
)
.
call
(
this
{
"
isBuffer
"
:
require
(
"
.
.
/
.
.
/
is
-
buffer
/
index
.
js
"
)
}
)
}
{
"
.
.
/
.
.
/
is
-
buffer
/
index
.
js
"
:
67
}
]
46
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
convertChangesToDMP
=
convertChangesToDMP
;
function
convertChangesToDMP
(
changes
)
{
var
ret
=
[
]
change
=
void
0
operation
=
void
0
;
for
(
var
i
=
0
;
i
<
changes
.
length
;
i
+
+
)
{
change
=
changes
[
i
]
;
if
(
change
.
added
)
{
operation
=
1
;
}
else
if
(
change
.
removed
)
{
operation
=
-
1
;
}
else
{
operation
=
0
;
}
ret
.
push
(
[
operation
change
.
value
]
)
;
}
return
ret
;
}
}
{
}
]
47
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
convertChangesToXML
=
convertChangesToXML
;
function
convertChangesToXML
(
changes
)
{
var
ret
=
[
]
;
for
(
var
i
=
0
;
i
<
changes
.
length
;
i
+
+
)
{
var
change
=
changes
[
i
]
;
if
(
change
.
added
)
{
ret
.
push
(
'
<
ins
>
'
)
;
}
else
if
(
change
.
removed
)
{
ret
.
push
(
'
<
del
>
'
)
;
}
ret
.
push
(
escapeHTML
(
change
.
value
)
)
;
if
(
change
.
added
)
{
ret
.
push
(
'
<
/
ins
>
'
)
;
}
else
if
(
change
.
removed
)
{
ret
.
push
(
'
<
/
del
>
'
)
;
}
}
return
ret
.
join
(
'
'
)
;
}
function
escapeHTML
(
s
)
{
var
n
=
s
;
n
=
n
.
replace
(
/
&
/
g
'
&
amp
;
'
)
;
n
=
n
.
replace
(
/
<
/
g
'
&
lt
;
'
)
;
n
=
n
.
replace
(
/
>
/
g
'
&
gt
;
'
)
;
n
=
n
.
replace
(
/
"
/
g
'
&
quot
;
'
)
;
return
n
;
}
}
{
}
]
48
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
arrayDiff
=
undefined
;
exports
.
diffArrays
=
diffArrays
;
var
_base
=
require
(
'
.
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
var
arrayDiff
=
exports
.
arrayDiff
=
new
_base2
[
'
default
'
]
(
)
;
arrayDiff
.
tokenize
=
arrayDiff
.
join
=
function
(
value
)
{
return
value
.
slice
(
)
;
}
;
function
diffArrays
(
oldArr
newArr
callback
)
{
return
arrayDiff
.
diff
(
oldArr
newArr
callback
)
;
}
}
{
"
.
/
base
"
:
49
}
]
49
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
[
'
default
'
]
=
Diff
;
function
Diff
(
)
{
}
Diff
.
prototype
=
{
diff
:
function
diff
(
oldString
newString
)
{
var
options
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
{
}
:
arguments
[
2
]
;
var
callback
=
options
.
callback
;
if
(
typeof
options
=
=
=
'
function
'
)
{
callback
=
options
;
options
=
{
}
;
}
this
.
options
=
options
;
var
self
=
this
;
function
done
(
value
)
{
if
(
callback
)
{
setTimeout
(
function
(
)
{
callback
(
undefined
value
)
;
}
0
)
;
return
true
;
}
else
{
return
value
;
}
}
oldString
=
this
.
castInput
(
oldString
)
;
newString
=
this
.
castInput
(
newString
)
;
oldString
=
this
.
removeEmpty
(
this
.
tokenize
(
oldString
)
)
;
newString
=
this
.
removeEmpty
(
this
.
tokenize
(
newString
)
)
;
var
newLen
=
newString
.
length
oldLen
=
oldString
.
length
;
var
editLength
=
1
;
var
maxEditLength
=
newLen
+
oldLen
;
var
bestPath
=
[
{
newPos
:
-
1
components
:
[
]
}
]
;
var
oldPos
=
this
.
extractCommon
(
bestPath
[
0
]
newString
oldString
0
)
;
if
(
bestPath
[
0
]
.
newPos
+
1
>
=
newLen
&
&
oldPos
+
1
>
=
oldLen
)
{
return
done
(
[
{
value
:
this
.
join
(
newString
)
count
:
newString
.
length
}
]
)
;
}
function
execEditLength
(
)
{
for
(
var
diagonalPath
=
-
1
*
editLength
;
diagonalPath
<
=
editLength
;
diagonalPath
+
=
2
)
{
var
basePath
=
void
0
;
var
addPath
=
bestPath
[
diagonalPath
-
1
]
removePath
=
bestPath
[
diagonalPath
+
1
]
_oldPos
=
(
removePath
?
removePath
.
newPos
:
0
)
-
diagonalPath
;
if
(
addPath
)
{
bestPath
[
diagonalPath
-
1
]
=
undefined
;
}
var
canAdd
=
addPath
&
&
addPath
.
newPos
+
1
<
newLen
canRemove
=
removePath
&
&
0
<
=
_oldPos
&
&
_oldPos
<
oldLen
;
if
(
!
canAdd
&
&
!
canRemove
)
{
bestPath
[
diagonalPath
]
=
undefined
;
continue
;
}
if
(
!
canAdd
|
|
canRemove
&
&
addPath
.
newPos
<
removePath
.
newPos
)
{
basePath
=
clonePath
(
removePath
)
;
self
.
pushComponent
(
basePath
.
components
undefined
true
)
;
}
else
{
basePath
=
addPath
;
basePath
.
newPos
+
+
;
self
.
pushComponent
(
basePath
.
components
true
undefined
)
;
}
_oldPos
=
self
.
extractCommon
(
basePath
newString
oldString
diagonalPath
)
;
if
(
basePath
.
newPos
+
1
>
=
newLen
&
&
_oldPos
+
1
>
=
oldLen
)
{
return
done
(
buildValues
(
self
basePath
.
components
newString
oldString
self
.
useLongestToken
)
)
;
}
else
{
bestPath
[
diagonalPath
]
=
basePath
;
}
}
editLength
+
+
;
}
if
(
callback
)
{
(
function
exec
(
)
{
setTimeout
(
function
(
)
{
if
(
editLength
>
maxEditLength
)
{
return
callback
(
)
;
}
if
(
!
execEditLength
(
)
)
{
exec
(
)
;
}
}
0
)
;
}
)
(
)
;
}
else
{
while
(
editLength
<
=
maxEditLength
)
{
var
ret
=
execEditLength
(
)
;
if
(
ret
)
{
return
ret
;
}
}
}
}
pushComponent
:
function
pushComponent
(
components
added
removed
)
{
var
last
=
components
[
components
.
length
-
1
]
;
if
(
last
&
&
last
.
added
=
=
=
added
&
&
last
.
removed
=
=
=
removed
)
{
components
[
components
.
length
-
1
]
=
{
count
:
last
.
count
+
1
added
:
added
removed
:
removed
}
;
}
else
{
components
.
push
(
{
count
:
1
added
:
added
removed
:
removed
}
)
;
}
}
extractCommon
:
function
extractCommon
(
basePath
newString
oldString
diagonalPath
)
{
var
newLen
=
newString
.
length
oldLen
=
oldString
.
length
newPos
=
basePath
.
newPos
oldPos
=
newPos
-
diagonalPath
commonCount
=
0
;
while
(
newPos
+
1
<
newLen
&
&
oldPos
+
1
<
oldLen
&
&
this
.
equals
(
newString
[
newPos
+
1
]
oldString
[
oldPos
+
1
]
)
)
{
newPos
+
+
;
oldPos
+
+
;
commonCount
+
+
;
}
if
(
commonCount
)
{
basePath
.
components
.
push
(
{
count
:
commonCount
}
)
;
}
basePath
.
newPos
=
newPos
;
return
oldPos
;
}
equals
:
function
equals
(
left
right
)
{
return
left
=
=
=
right
;
}
removeEmpty
:
function
removeEmpty
(
array
)
{
var
ret
=
[
]
;
for
(
var
i
=
0
;
i
<
array
.
length
;
i
+
+
)
{
if
(
array
[
i
]
)
{
ret
.
push
(
array
[
i
]
)
;
}
}
return
ret
;
}
castInput
:
function
castInput
(
value
)
{
return
value
;
}
tokenize
:
function
tokenize
(
value
)
{
return
value
.
split
(
'
'
)
;
}
join
:
function
join
(
chars
)
{
return
chars
.
join
(
'
'
)
;
}
}
;
function
buildValues
(
diff
components
newString
oldString
useLongestToken
)
{
var
componentPos
=
0
componentLen
=
components
.
length
newPos
=
0
oldPos
=
0
;
for
(
;
componentPos
<
componentLen
;
componentPos
+
+
)
{
var
component
=
components
[
componentPos
]
;
if
(
!
component
.
removed
)
{
if
(
!
component
.
added
&
&
useLongestToken
)
{
var
value
=
newString
.
slice
(
newPos
newPos
+
component
.
count
)
;
value
=
value
.
map
(
function
(
value
i
)
{
var
oldValue
=
oldString
[
oldPos
+
i
]
;
return
oldValue
.
length
>
value
.
length
?
oldValue
:
value
;
}
)
;
component
.
value
=
diff
.
join
(
value
)
;
}
else
{
component
.
value
=
diff
.
join
(
newString
.
slice
(
newPos
newPos
+
component
.
count
)
)
;
}
newPos
+
=
component
.
count
;
if
(
!
component
.
added
)
{
oldPos
+
=
component
.
count
;
}
}
else
{
component
.
value
=
diff
.
join
(
oldString
.
slice
(
oldPos
oldPos
+
component
.
count
)
)
;
oldPos
+
=
component
.
count
;
if
(
componentPos
&
&
components
[
componentPos
-
1
]
.
added
)
{
var
tmp
=
components
[
componentPos
-
1
]
;
components
[
componentPos
-
1
]
=
components
[
componentPos
]
;
components
[
componentPos
]
=
tmp
;
}
}
}
var
lastComponent
=
components
[
componentLen
-
1
]
;
if
(
componentLen
>
1
&
&
(
lastComponent
.
added
|
|
lastComponent
.
removed
)
&
&
diff
.
equals
(
'
'
lastComponent
.
value
)
)
{
components
[
componentLen
-
2
]
.
value
+
=
lastComponent
.
value
;
components
.
pop
(
)
;
}
return
components
;
}
function
clonePath
(
path
)
{
return
{
newPos
:
path
.
newPos
components
:
path
.
components
.
slice
(
0
)
}
;
}
}
{
}
]
50
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
characterDiff
=
undefined
;
exports
.
diffChars
=
diffChars
;
var
_base
=
require
(
'
.
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
var
characterDiff
=
exports
.
characterDiff
=
new
_base2
[
'
default
'
]
(
)
;
function
diffChars
(
oldStr
newStr
callback
)
{
return
characterDiff
.
diff
(
oldStr
newStr
callback
)
;
}
}
{
"
.
/
base
"
:
49
}
]
51
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
cssDiff
=
undefined
;
exports
.
diffCss
=
diffCss
;
var
_base
=
require
(
'
.
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
var
cssDiff
=
exports
.
cssDiff
=
new
_base2
[
'
default
'
]
(
)
;
cssDiff
.
tokenize
=
function
(
value
)
{
return
value
.
split
(
/
(
[
{
}
:
;
]
|
\
s
+
)
/
)
;
}
;
function
diffCss
(
oldStr
newStr
callback
)
{
return
cssDiff
.
diff
(
oldStr
newStr
callback
)
;
}
}
{
"
.
/
base
"
:
49
}
]
52
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
jsonDiff
=
undefined
;
var
_typeof
=
typeof
Symbol
=
=
=
"
function
"
&
&
typeof
Symbol
.
iterator
=
=
=
"
symbol
"
?
function
(
obj
)
{
return
typeof
obj
;
}
:
function
(
obj
)
{
return
obj
&
&
typeof
Symbol
=
=
=
"
function
"
&
&
obj
.
constructor
=
=
=
Symbol
?
"
symbol
"
:
typeof
obj
;
}
;
exports
.
diffJson
=
diffJson
;
exports
.
canonicalize
=
canonicalize
;
var
_base
=
require
(
'
.
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_line
=
require
(
'
.
/
line
'
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
var
objectPrototypeToString
=
Object
.
prototype
.
toString
;
var
jsonDiff
=
exports
.
jsonDiff
=
new
_base2
[
'
default
'
]
(
)
;
jsonDiff
.
useLongestToken
=
true
;
jsonDiff
.
tokenize
=
_line
.
lineDiff
.
tokenize
;
jsonDiff
.
castInput
=
function
(
value
)
{
var
undefinedReplacement
=
this
.
options
.
undefinedReplacement
;
return
typeof
value
=
=
=
'
string
'
?
value
:
JSON
.
stringify
(
canonicalize
(
value
)
function
(
k
v
)
{
if
(
typeof
v
=
=
=
'
undefined
'
)
{
return
undefinedReplacement
;
}
return
v
;
}
'
'
)
;
}
;
jsonDiff
.
equals
=
function
(
left
right
)
{
return
(
_base2
[
'
default
'
]
.
prototype
.
equals
(
left
.
replace
(
/
(
[
\
r
\
n
]
)
/
g
'
1
'
)
right
.
replace
(
/
(
[
\
r
\
n
]
)
/
g
'
1
'
)
)
)
;
}
;
function
diffJson
(
oldObj
newObj
options
)
{
return
jsonDiff
.
diff
(
oldObj
newObj
options
)
;
}
function
canonicalize
(
obj
stack
replacementStack
)
{
stack
=
stack
|
|
[
]
;
replacementStack
=
replacementStack
|
|
[
]
;
var
i
=
void
0
;
for
(
i
=
0
;
i
<
stack
.
length
;
i
+
=
1
)
{
if
(
stack
[
i
]
=
=
=
obj
)
{
return
replacementStack
[
i
]
;
}
}
var
canonicalizedObj
=
void
0
;
if
(
'
[
object
Array
]
'
=
=
=
objectPrototypeToString
.
call
(
obj
)
)
{
stack
.
push
(
obj
)
;
canonicalizedObj
=
new
Array
(
obj
.
length
)
;
replacementStack
.
push
(
canonicalizedObj
)
;
for
(
i
=
0
;
i
<
obj
.
length
;
i
+
=
1
)
{
canonicalizedObj
[
i
]
=
canonicalize
(
obj
[
i
]
stack
replacementStack
)
;
}
stack
.
pop
(
)
;
replacementStack
.
pop
(
)
;
return
canonicalizedObj
;
}
if
(
obj
&
&
obj
.
toJSON
)
{
obj
=
obj
.
toJSON
(
)
;
}
if
(
(
typeof
obj
=
=
=
'
undefined
'
?
'
undefined
'
:
_typeof
(
obj
)
)
=
=
=
'
object
'
&
&
obj
!
=
=
null
)
{
stack
.
push
(
obj
)
;
canonicalizedObj
=
{
}
;
replacementStack
.
push
(
canonicalizedObj
)
;
var
sortedKeys
=
[
]
key
=
void
0
;
for
(
key
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
key
)
)
{
sortedKeys
.
push
(
key
)
;
}
}
sortedKeys
.
sort
(
)
;
for
(
i
=
0
;
i
<
sortedKeys
.
length
;
i
+
=
1
)
{
key
=
sortedKeys
[
i
]
;
canonicalizedObj
[
key
]
=
canonicalize
(
obj
[
key
]
stack
replacementStack
)
;
}
stack
.
pop
(
)
;
replacementStack
.
pop
(
)
;
}
else
{
canonicalizedObj
=
obj
;
}
return
canonicalizedObj
;
}
}
{
"
.
/
base
"
:
49
"
.
/
line
"
:
53
}
]
53
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
lineDiff
=
undefined
;
exports
.
diffLines
=
diffLines
;
exports
.
diffTrimmedLines
=
diffTrimmedLines
;
var
_base
=
require
(
'
.
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_params
=
require
(
'
.
.
/
util
/
params
'
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
var
lineDiff
=
exports
.
lineDiff
=
new
_base2
[
'
default
'
]
(
)
;
lineDiff
.
tokenize
=
function
(
value
)
{
var
retLines
=
[
]
linesAndNewlines
=
value
.
split
(
/
(
\
n
|
\
r
\
n
)
/
)
;
if
(
!
linesAndNewlines
[
linesAndNewlines
.
length
-
1
]
)
{
linesAndNewlines
.
pop
(
)
;
}
for
(
var
i
=
0
;
i
<
linesAndNewlines
.
length
;
i
+
+
)
{
var
line
=
linesAndNewlines
[
i
]
;
if
(
i
%
2
&
&
!
this
.
options
.
newlineIsToken
)
{
retLines
[
retLines
.
length
-
1
]
+
=
line
;
}
else
{
if
(
this
.
options
.
ignoreWhitespace
)
{
line
=
line
.
trim
(
)
;
}
retLines
.
push
(
line
)
;
}
}
return
retLines
;
}
;
function
diffLines
(
oldStr
newStr
callback
)
{
return
lineDiff
.
diff
(
oldStr
newStr
callback
)
;
}
function
diffTrimmedLines
(
oldStr
newStr
callback
)
{
var
options
=
(
0
_params
.
generateOptions
)
(
callback
{
ignoreWhitespace
:
true
}
)
;
return
lineDiff
.
diff
(
oldStr
newStr
options
)
;
}
}
{
"
.
.
/
util
/
params
"
:
61
"
.
/
base
"
:
49
}
]
54
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
sentenceDiff
=
undefined
;
exports
.
diffSentences
=
diffSentences
;
var
_base
=
require
(
'
.
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
var
sentenceDiff
=
exports
.
sentenceDiff
=
new
_base2
[
'
default
'
]
(
)
;
sentenceDiff
.
tokenize
=
function
(
value
)
{
return
value
.
split
(
/
(
\
S
.
+
?
[
.
!
?
]
)
(
?
=
\
s
+
|
)
/
)
;
}
;
function
diffSentences
(
oldStr
newStr
callback
)
{
return
sentenceDiff
.
diff
(
oldStr
newStr
callback
)
;
}
}
{
"
.
/
base
"
:
49
}
]
55
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
wordDiff
=
undefined
;
exports
.
diffWords
=
diffWords
;
exports
.
diffWordsWithSpace
=
diffWordsWithSpace
;
var
_base
=
require
(
'
.
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_params
=
require
(
'
.
.
/
util
/
params
'
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
var
extendedWordChars
=
/
^
[
A
-
Za
-
z
\
xC0
-
\
u02C6
\
u02C8
-
\
u02D7
\
u02DE
-
\
u02FF
\
u1E00
-
\
u1EFF
]
+
/
;
var
reWhitespace
=
/
\
S
/
;
var
wordDiff
=
exports
.
wordDiff
=
new
_base2
[
'
default
'
]
(
)
;
wordDiff
.
equals
=
function
(
left
right
)
{
return
left
=
=
=
right
|
|
this
.
options
.
ignoreWhitespace
&
&
!
reWhitespace
.
test
(
left
)
&
&
!
reWhitespace
.
test
(
right
)
;
}
;
wordDiff
.
tokenize
=
function
(
value
)
{
var
tokens
=
value
.
split
(
/
(
\
s
+
|
\
b
)
/
)
;
for
(
var
i
=
0
;
i
<
tokens
.
length
-
1
;
i
+
+
)
{
if
(
!
tokens
[
i
+
1
]
&
&
tokens
[
i
+
2
]
&
&
extendedWordChars
.
test
(
tokens
[
i
]
)
&
&
extendedWordChars
.
test
(
tokens
[
i
+
2
]
)
)
{
tokens
[
i
]
+
=
tokens
[
i
+
2
]
;
tokens
.
splice
(
i
+
1
2
)
;
i
-
-
;
}
}
return
tokens
;
}
;
function
diffWords
(
oldStr
newStr
callback
)
{
var
options
=
(
0
_params
.
generateOptions
)
(
callback
{
ignoreWhitespace
:
true
}
)
;
return
wordDiff
.
diff
(
oldStr
newStr
options
)
;
}
function
diffWordsWithSpace
(
oldStr
newStr
callback
)
{
return
wordDiff
.
diff
(
oldStr
newStr
callback
)
;
}
}
{
"
.
.
/
util
/
params
"
:
61
"
.
/
base
"
:
49
}
]
56
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
canonicalize
=
exports
.
convertChangesToXML
=
exports
.
convertChangesToDMP
=
exports
.
parsePatch
=
exports
.
applyPatches
=
exports
.
applyPatch
=
exports
.
createPatch
=
exports
.
createTwoFilesPatch
=
exports
.
structuredPatch
=
exports
.
diffArrays
=
exports
.
diffJson
=
exports
.
diffCss
=
exports
.
diffSentences
=
exports
.
diffTrimmedLines
=
exports
.
diffLines
=
exports
.
diffWordsWithSpace
=
exports
.
diffWords
=
exports
.
diffChars
=
exports
.
Diff
=
undefined
;
var
_base
=
require
(
'
.
/
diff
/
base
'
)
;
var
_base2
=
_interopRequireDefault
(
_base
)
;
var
_character
=
require
(
'
.
/
diff
/
character
'
)
;
var
_word
=
require
(
'
.
/
diff
/
word
'
)
;
var
_line
=
require
(
'
.
/
diff
/
line
'
)
;
var
_sentence
=
require
(
'
.
/
diff
/
sentence
'
)
;
var
_css
=
require
(
'
.
/
diff
/
css
'
)
;
var
_json
=
require
(
'
.
/
diff
/
json
'
)
;
var
_array
=
require
(
'
.
/
diff
/
array
'
)
;
var
_apply
=
require
(
'
.
/
patch
/
apply
'
)
;
var
_parse
=
require
(
'
.
/
patch
/
parse
'
)
;
var
_create
=
require
(
'
.
/
patch
/
create
'
)
;
var
_dmp
=
require
(
'
.
/
convert
/
dmp
'
)
;
var
_xml
=
require
(
'
.
/
convert
/
xml
'
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
exports
.
Diff
=
_base2
[
'
default
'
]
;
exports
.
diffChars
=
_character
.
diffChars
;
exports
.
diffWords
=
_word
.
diffWords
;
exports
.
diffWordsWithSpace
=
_word
.
diffWordsWithSpace
;
exports
.
diffLines
=
_line
.
diffLines
;
exports
.
diffTrimmedLines
=
_line
.
diffTrimmedLines
;
exports
.
diffSentences
=
_sentence
.
diffSentences
;
exports
.
diffCss
=
_css
.
diffCss
;
exports
.
diffJson
=
_json
.
diffJson
;
exports
.
diffArrays
=
_array
.
diffArrays
;
exports
.
structuredPatch
=
_create
.
structuredPatch
;
exports
.
createTwoFilesPatch
=
_create
.
createTwoFilesPatch
;
exports
.
createPatch
=
_create
.
createPatch
;
exports
.
applyPatch
=
_apply
.
applyPatch
;
exports
.
applyPatches
=
_apply
.
applyPatches
;
exports
.
parsePatch
=
_parse
.
parsePatch
;
exports
.
convertChangesToDMP
=
_dmp
.
convertChangesToDMP
;
exports
.
convertChangesToXML
=
_xml
.
convertChangesToXML
;
exports
.
canonicalize
=
_json
.
canonicalize
;
}
{
"
.
/
convert
/
dmp
"
:
46
"
.
/
convert
/
xml
"
:
47
"
.
/
diff
/
array
"
:
48
"
.
/
diff
/
base
"
:
49
"
.
/
diff
/
character
"
:
50
"
.
/
diff
/
css
"
:
51
"
.
/
diff
/
json
"
:
52
"
.
/
diff
/
line
"
:
53
"
.
/
diff
/
sentence
"
:
54
"
.
/
diff
/
word
"
:
55
"
.
/
patch
/
apply
"
:
57
"
.
/
patch
/
create
"
:
58
"
.
/
patch
/
parse
"
:
59
}
]
57
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
applyPatch
=
applyPatch
;
exports
.
applyPatches
=
applyPatches
;
var
_parse
=
require
(
'
.
/
parse
'
)
;
var
_distanceIterator
=
require
(
'
.
.
/
util
/
distance
-
iterator
'
)
;
var
_distanceIterator2
=
_interopRequireDefault
(
_distanceIterator
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
'
default
'
:
obj
}
;
}
function
applyPatch
(
source
uniDiff
)
{
var
options
=
arguments
.
length
<
=
2
|
|
arguments
[
2
]
=
=
=
undefined
?
{
}
:
arguments
[
2
]
;
if
(
typeof
uniDiff
=
=
=
'
string
'
)
{
uniDiff
=
(
0
_parse
.
parsePatch
)
(
uniDiff
)
;
}
if
(
Array
.
isArray
(
uniDiff
)
)
{
if
(
uniDiff
.
length
>
1
)
{
throw
new
Error
(
'
applyPatch
only
works
with
a
single
input
.
'
)
;
}
uniDiff
=
uniDiff
[
0
]
;
}
var
lines
=
source
.
split
(
/
\
r
\
n
|
[
\
n
\
v
\
f
\
r
\
x85
]
/
)
delimiters
=
source
.
match
(
/
\
r
\
n
|
[
\
n
\
v
\
f
\
r
\
x85
]
/
g
)
|
|
[
]
hunks
=
uniDiff
.
hunks
compareLine
=
options
.
compareLine
|
|
function
(
lineNumber
line
operation
patchContent
)
{
return
(
line
=
=
=
patchContent
)
;
}
errorCount
=
0
fuzzFactor
=
options
.
fuzzFactor
|
|
0
minLine
=
0
offset
=
0
removeEOFNL
=
void
0
addEOFNL
=
void
0
;
function
hunkFits
(
hunk
toPos
)
{
for
(
var
j
=
0
;
j
<
hunk
.
lines
.
length
;
j
+
+
)
{
var
line
=
hunk
.
lines
[
j
]
operation
=
line
[
0
]
content
=
line
.
substr
(
1
)
;
if
(
operation
=
=
=
'
'
|
|
operation
=
=
=
'
-
'
)
{
if
(
!
compareLine
(
toPos
+
1
lines
[
toPos
]
operation
content
)
)
{
errorCount
+
+
;
if
(
errorCount
>
fuzzFactor
)
{
return
false
;
}
}
toPos
+
+
;
}
}
return
true
;
}
for
(
var
i
=
0
;
i
<
hunks
.
length
;
i
+
+
)
{
var
hunk
=
hunks
[
i
]
maxLine
=
lines
.
length
-
hunk
.
oldLines
localOffset
=
0
toPos
=
offset
+
hunk
.
oldStart
-
1
;
var
iterator
=
(
0
_distanceIterator2
[
'
default
'
]
)
(
toPos
minLine
maxLine
)
;
for
(
;
localOffset
!
=
=
undefined
;
localOffset
=
iterator
(
)
)
{
if
(
hunkFits
(
hunk
toPos
+
localOffset
)
)
{
hunk
.
offset
=
offset
+
=
localOffset
;
break
;
}
}
if
(
localOffset
=
=
=
undefined
)
{
return
false
;
}
minLine
=
hunk
.
offset
+
hunk
.
oldStart
+
hunk
.
oldLines
;
}
for
(
var
_i
=
0
;
_i
<
hunks
.
length
;
_i
+
+
)
{
var
_hunk
=
hunks
[
_i
]
_toPos
=
_hunk
.
offset
+
_hunk
.
newStart
-
1
;
if
(
_hunk
.
newLines
=
=
0
)
{
_toPos
+
+
;
}
for
(
var
j
=
0
;
j
<
_hunk
.
lines
.
length
;
j
+
+
)
{
var
line
=
_hunk
.
lines
[
j
]
operation
=
line
[
0
]
content
=
line
.
substr
(
1
)
delimiter
=
_hunk
.
linedelimiters
[
j
]
;
if
(
operation
=
=
=
'
'
)
{
_toPos
+
+
;
}
else
if
(
operation
=
=
=
'
-
'
)
{
lines
.
splice
(
_toPos
1
)
;
delimiters
.
splice
(
_toPos
1
)
;
}
else
if
(
operation
=
=
=
'
+
'
)
{
lines
.
splice
(
_toPos
0
content
)
;
delimiters
.
splice
(
_toPos
0
delimiter
)
;
_toPos
+
+
;
}
else
if
(
operation
=
=
=
'
\
\
'
)
{
var
previousOperation
=
_hunk
.
lines
[
j
-
1
]
?
_hunk
.
lines
[
j
-
1
]
[
0
]
:
null
;
if
(
previousOperation
=
=
=
'
+
'
)
{
removeEOFNL
=
true
;
}
else
if
(
previousOperation
=
=
=
'
-
'
)
{
addEOFNL
=
true
;
}
}
}
}
if
(
removeEOFNL
)
{
while
(
!
lines
[
lines
.
length
-
1
]
)
{
lines
.
pop
(
)
;
delimiters
.
pop
(
)
;
}
}
else
if
(
addEOFNL
)
{
lines
.
push
(
'
'
)
;
delimiters
.
push
(
'
\
n
'
)
;
}
for
(
var
_k
=
0
;
_k
<
lines
.
length
-
1
;
_k
+
+
)
{
lines
[
_k
]
=
lines
[
_k
]
+
delimiters
[
_k
]
;
}
return
lines
.
join
(
'
'
)
;
}
function
applyPatches
(
uniDiff
options
)
{
if
(
typeof
uniDiff
=
=
=
'
string
'
)
{
uniDiff
=
(
0
_parse
.
parsePatch
)
(
uniDiff
)
;
}
var
currentIndex
=
0
;
function
processIndex
(
)
{
var
index
=
uniDiff
[
currentIndex
+
+
]
;
if
(
!
index
)
{
return
options
.
complete
(
)
;
}
options
.
loadFile
(
index
function
(
err
data
)
{
if
(
err
)
{
return
options
.
complete
(
err
)
;
}
var
updatedContent
=
applyPatch
(
data
index
options
)
;
options
.
patched
(
index
updatedContent
function
(
err
)
{
if
(
err
)
{
return
options
.
complete
(
err
)
;
}
processIndex
(
)
;
}
)
;
}
)
;
}
processIndex
(
)
;
}
}
{
"
.
.
/
util
/
distance
-
iterator
"
:
60
"
.
/
parse
"
:
59
}
]
58
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
structuredPatch
=
structuredPatch
;
exports
.
createTwoFilesPatch
=
createTwoFilesPatch
;
exports
.
createPatch
=
createPatch
;
var
_line
=
require
(
'
.
.
/
diff
/
line
'
)
;
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
function
structuredPatch
(
oldFileName
newFileName
oldStr
newStr
oldHeader
newHeader
options
)
{
if
(
!
options
)
{
options
=
{
}
;
}
if
(
typeof
options
.
context
=
=
=
'
undefined
'
)
{
options
.
context
=
4
;
}
var
diff
=
(
0
_line
.
diffLines
)
(
oldStr
newStr
options
)
;
diff
.
push
(
{
value
:
'
'
lines
:
[
]
}
)
;
function
contextLines
(
lines
)
{
return
lines
.
map
(
function
(
entry
)
{
return
'
'
+
entry
;
}
)
;
}
var
hunks
=
[
]
;
var
oldRangeStart
=
0
newRangeStart
=
0
curRange
=
[
]
oldLine
=
1
newLine
=
1
;
var
_loop
=
function
_loop
(
i
)
{
var
current
=
diff
[
i
]
lines
=
current
.
lines
|
|
current
.
value
.
replace
(
/
\
n
/
'
'
)
.
split
(
'
\
n
'
)
;
current
.
lines
=
lines
;
if
(
current
.
added
|
|
current
.
removed
)
{
var
_curRange
;
if
(
!
oldRangeStart
)
{
var
prev
=
diff
[
i
-
1
]
;
oldRangeStart
=
oldLine
;
newRangeStart
=
newLine
;
if
(
prev
)
{
curRange
=
options
.
context
>
0
?
contextLines
(
prev
.
lines
.
slice
(
-
options
.
context
)
)
:
[
]
;
oldRangeStart
-
=
curRange
.
length
;
newRangeStart
-
=
curRange
.
length
;
}
}
(
_curRange
=
curRange
)
.
push
.
apply
(
_curRange
_toConsumableArray
(
lines
.
map
(
function
(
entry
)
{
return
(
current
.
added
?
'
+
'
:
'
-
'
)
+
entry
;
}
)
)
)
;
if
(
current
.
added
)
{
newLine
+
=
lines
.
length
;
}
else
{
oldLine
+
=
lines
.
length
;
}
}
else
{
if
(
oldRangeStart
)
{
if
(
lines
.
length
<
=
options
.
context
*
2
&
&
i
<
diff
.
length
-
2
)
{
var
_curRange2
;
(
_curRange2
=
curRange
)
.
push
.
apply
(
_curRange2
_toConsumableArray
(
contextLines
(
lines
)
)
)
;
}
else
{
var
_curRange3
;
var
contextSize
=
Math
.
min
(
lines
.
length
options
.
context
)
;
(
_curRange3
=
curRange
)
.
push
.
apply
(
_curRange3
_toConsumableArray
(
contextLines
(
lines
.
slice
(
0
contextSize
)
)
)
)
;
var
hunk
=
{
oldStart
:
oldRangeStart
oldLines
:
oldLine
-
oldRangeStart
+
contextSize
newStart
:
newRangeStart
newLines
:
newLine
-
newRangeStart
+
contextSize
lines
:
curRange
}
;
if
(
i
>
=
diff
.
length
-
2
&
&
lines
.
length
<
=
options
.
context
)
{
var
oldEOFNewline
=
/
\
n
/
.
test
(
oldStr
)
;
var
newEOFNewline
=
/
\
n
/
.
test
(
newStr
)
;
if
(
lines
.
length
=
=
0
&
&
!
oldEOFNewline
)
{
curRange
.
splice
(
hunk
.
oldLines
0
'
\
\
No
newline
at
end
of
file
'
)
;
}
else
if
(
!
oldEOFNewline
|
|
!
newEOFNewline
)
{
curRange
.
push
(
'
\
\
No
newline
at
end
of
file
'
)
;
}
}
hunks
.
push
(
hunk
)
;
oldRangeStart
=
0
;
newRangeStart
=
0
;
curRange
=
[
]
;
}
}
oldLine
+
=
lines
.
length
;
newLine
+
=
lines
.
length
;
}
}
;
for
(
var
i
=
0
;
i
<
diff
.
length
;
i
+
+
)
{
_loop
(
i
)
;
}
return
{
oldFileName
:
oldFileName
newFileName
:
newFileName
oldHeader
:
oldHeader
newHeader
:
newHeader
hunks
:
hunks
}
;
}
function
createTwoFilesPatch
(
oldFileName
newFileName
oldStr
newStr
oldHeader
newHeader
options
)
{
var
diff
=
structuredPatch
(
oldFileName
newFileName
oldStr
newStr
oldHeader
newHeader
options
)
;
var
ret
=
[
]
;
if
(
oldFileName
=
=
newFileName
)
{
ret
.
push
(
'
Index
:
'
+
oldFileName
)
;
}
ret
.
push
(
'
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
'
)
;
ret
.
push
(
'
-
-
-
'
+
diff
.
oldFileName
+
(
typeof
diff
.
oldHeader
=
=
=
'
undefined
'
?
'
'
:
'
\
t
'
+
diff
.
oldHeader
)
)
;
ret
.
push
(
'
+
+
+
'
+
diff
.
newFileName
+
(
typeof
diff
.
newHeader
=
=
=
'
undefined
'
?
'
'
:
'
\
t
'
+
diff
.
newHeader
)
)
;
for
(
var
i
=
0
;
i
<
diff
.
hunks
.
length
;
i
+
+
)
{
var
hunk
=
diff
.
hunks
[
i
]
;
ret
.
push
(
'
-
'
+
hunk
.
oldStart
+
'
'
+
hunk
.
oldLines
+
'
+
'
+
hunk
.
newStart
+
'
'
+
hunk
.
newLines
+
'
'
)
;
ret
.
push
.
apply
(
ret
hunk
.
lines
)
;
}
return
ret
.
join
(
'
\
n
'
)
+
'
\
n
'
;
}
function
createPatch
(
fileName
oldStr
newStr
oldHeader
newHeader
options
)
{
return
createTwoFilesPatch
(
fileName
fileName
oldStr
newStr
oldHeader
newHeader
options
)
;
}
}
{
"
.
.
/
diff
/
line
"
:
53
}
]
59
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
parsePatch
=
parsePatch
;
function
parsePatch
(
uniDiff
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
var
diffstr
=
uniDiff
.
split
(
/
\
r
\
n
|
[
\
n
\
v
\
f
\
r
\
x85
]
/
)
delimiters
=
uniDiff
.
match
(
/
\
r
\
n
|
[
\
n
\
v
\
f
\
r
\
x85
]
/
g
)
|
|
[
]
list
=
[
]
i
=
0
;
function
parseIndex
(
)
{
var
index
=
{
}
;
list
.
push
(
index
)
;
while
(
i
<
diffstr
.
length
)
{
var
line
=
diffstr
[
i
]
;
if
(
/
^
(
\
-
\
-
\
-
|
\
+
\
+
\
+
|
)
\
s
/
.
test
(
line
)
)
{
break
;
}
var
header
=
/
^
(
?
:
Index
:
|
diff
(
?
:
-
r
\
w
+
)
+
)
\
s
+
(
.
+
?
)
\
s
*
/
.
exec
(
line
)
;
if
(
header
)
{
index
.
index
=
header
[
1
]
;
}
i
+
+
;
}
parseFileHeader
(
index
)
;
parseFileHeader
(
index
)
;
index
.
hunks
=
[
]
;
while
(
i
<
diffstr
.
length
)
{
var
_line
=
diffstr
[
i
]
;
if
(
/
^
(
Index
:
|
diff
|
\
-
\
-
\
-
|
\
+
\
+
\
+
)
\
s
/
.
test
(
_line
)
)
{
break
;
}
else
if
(
/
^
/
.
test
(
_line
)
)
{
index
.
hunks
.
push
(
parseHunk
(
)
)
;
}
else
if
(
_line
&
&
options
.
strict
)
{
throw
new
Error
(
'
Unknown
line
'
+
(
i
+
1
)
+
'
'
+
JSON
.
stringify
(
_line
)
)
;
}
else
{
i
+
+
;
}
}
}
function
parseFileHeader
(
index
)
{
var
headerPattern
=
/
^
(
-
-
-
|
\
+
\
+
\
+
)
\
s
+
(
[
\
S
]
*
)
(
?
:
\
t
(
.
*
?
)
\
s
*
)
?
/
;
var
fileHeader
=
headerPattern
.
exec
(
diffstr
[
i
]
)
;
if
(
fileHeader
)
{
var
keyPrefix
=
fileHeader
[
1
]
=
=
=
'
-
-
-
'
?
'
old
'
:
'
new
'
;
index
[
keyPrefix
+
'
FileName
'
]
=
fileHeader
[
2
]
;
index
[
keyPrefix
+
'
Header
'
]
=
fileHeader
[
3
]
;
i
+
+
;
}
}
function
parseHunk
(
)
{
var
chunkHeaderIndex
=
i
chunkHeaderLine
=
diffstr
[
i
+
+
]
chunkHeader
=
chunkHeaderLine
.
split
(
/
-
(
\
d
+
)
(
?
:
(
\
d
+
)
)
?
\
+
(
\
d
+
)
(
?
:
(
\
d
+
)
)
?
/
)
;
var
hunk
=
{
oldStart
:
+
chunkHeader
[
1
]
oldLines
:
+
chunkHeader
[
2
]
|
|
1
newStart
:
+
chunkHeader
[
3
]
newLines
:
+
chunkHeader
[
4
]
|
|
1
lines
:
[
]
linedelimiters
:
[
]
}
;
var
addCount
=
0
removeCount
=
0
;
for
(
;
i
<
diffstr
.
length
;
i
+
+
)
{
if
(
diffstr
[
i
]
.
indexOf
(
'
-
-
-
'
)
=
=
=
0
&
&
i
+
2
<
diffstr
.
length
&
&
diffstr
[
i
+
1
]
.
indexOf
(
'
+
+
+
'
)
=
=
=
0
&
&
diffstr
[
i
+
2
]
.
indexOf
(
'
'
)
=
=
=
0
)
{
break
;
}
var
operation
=
diffstr
[
i
]
[
0
]
;
if
(
operation
=
=
=
'
+
'
|
|
operation
=
=
=
'
-
'
|
|
operation
=
=
=
'
'
|
|
operation
=
=
=
'
\
\
'
)
{
hunk
.
lines
.
push
(
diffstr
[
i
]
)
;
hunk
.
linedelimiters
.
push
(
delimiters
[
i
]
|
|
'
\
n
'
)
;
if
(
operation
=
=
=
'
+
'
)
{
addCount
+
+
;
}
else
if
(
operation
=
=
=
'
-
'
)
{
removeCount
+
+
;
}
else
if
(
operation
=
=
=
'
'
)
{
addCount
+
+
;
removeCount
+
+
;
}
}
else
{
break
;
}
}
if
(
!
addCount
&
&
hunk
.
newLines
=
=
=
1
)
{
hunk
.
newLines
=
0
;
}
if
(
!
removeCount
&
&
hunk
.
oldLines
=
=
=
1
)
{
hunk
.
oldLines
=
0
;
}
if
(
options
.
strict
)
{
if
(
addCount
!
=
=
hunk
.
newLines
)
{
throw
new
Error
(
'
Added
line
count
did
not
match
for
hunk
at
line
'
+
(
chunkHeaderIndex
+
1
)
)
;
}
if
(
removeCount
!
=
=
hunk
.
oldLines
)
{
throw
new
Error
(
'
Removed
line
count
did
not
match
for
hunk
at
line
'
+
(
chunkHeaderIndex
+
1
)
)
;
}
}
return
hunk
;
}
while
(
i
<
diffstr
.
length
)
{
parseIndex
(
)
;
}
return
list
;
}
}
{
}
]
60
:
[
function
(
require
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
[
"
default
"
]
=
function
(
start
minLine
maxLine
)
{
var
wantForward
=
true
backwardExhausted
=
false
forwardExhausted
=
false
localOffset
=
1
;
return
function
iterator
(
)
{
if
(
wantForward
&
&
!
forwardExhausted
)
{
if
(
backwardExhausted
)
{
localOffset
+
+
;
}
else
{
wantForward
=
false
;
}
if
(
start
+
localOffset
<
=
maxLine
)
{
return
localOffset
;
}
forwardExhausted
=
true
;
}
if
(
!
backwardExhausted
)
{
if
(
!
forwardExhausted
)
{
wantForward
=
true
;
}
if
(
minLine
<
=
start
-
localOffset
)
{
return
-
localOffset
+
+
;
}
backwardExhausted
=
true
;
return
iterator
(
)
;
}
}
;
}
;
}
{
}
]
61
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
exports
.
__esModule
=
true
;
exports
.
generateOptions
=
generateOptions
;
function
generateOptions
(
options
defaults
)
{
if
(
typeof
options
=
=
=
'
function
'
)
{
defaults
.
callback
=
options
;
}
else
if
(
options
)
{
for
(
var
name
in
options
)
{
if
(
options
.
hasOwnProperty
(
name
)
)
{
defaults
[
name
]
=
options
[
name
]
;
}
}
}
return
defaults
;
}
}
{
}
]
62
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
matchOperatorsRe
=
/
[
|
\
\
{
}
(
)
[
\
]
^
+
*
?
.
]
/
g
;
module
.
exports
=
function
(
str
)
{
if
(
typeof
str
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Expected
a
string
'
)
;
}
return
str
.
replace
(
matchOperatorsRe
'
\
\
&
'
)
;
}
;
}
{
}
]
63
:
[
function
(
require
module
exports
)
{
function
EventEmitter
(
)
{
this
.
_events
=
this
.
_events
|
|
{
}
;
this
.
_maxListeners
=
this
.
_maxListeners
|
|
undefined
;
}
module
.
exports
=
EventEmitter
;
EventEmitter
.
EventEmitter
=
EventEmitter
;
EventEmitter
.
prototype
.
_events
=
undefined
;
EventEmitter
.
prototype
.
_maxListeners
=
undefined
;
EventEmitter
.
defaultMaxListeners
=
10
;
EventEmitter
.
prototype
.
setMaxListeners
=
function
(
n
)
{
if
(
!
isNumber
(
n
)
|
|
n
<
0
|
|
isNaN
(
n
)
)
throw
TypeError
(
'
n
must
be
a
positive
number
'
)
;
this
.
_maxListeners
=
n
;
return
this
;
}
;
EventEmitter
.
prototype
.
emit
=
function
(
type
)
{
var
er
handler
len
args
i
listeners
;
if
(
!
this
.
_events
)
this
.
_events
=
{
}
;
if
(
type
=
=
=
'
error
'
)
{
if
(
!
this
.
_events
.
error
|
|
(
isObject
(
this
.
_events
.
error
)
&
&
!
this
.
_events
.
error
.
length
)
)
{
er
=
arguments
[
1
]
;
if
(
er
instanceof
Error
)
{
throw
er
;
}
else
{
var
err
=
new
Error
(
'
Uncaught
unspecified
"
error
"
event
.
(
'
+
er
+
'
)
'
)
;
err
.
context
=
er
;
throw
err
;
}
}
}
handler
=
this
.
_events
[
type
]
;
if
(
isUndefined
(
handler
)
)
return
false
;
if
(
isFunction
(
handler
)
)
{
switch
(
arguments
.
length
)
{
case
1
:
handler
.
call
(
this
)
;
break
;
case
2
:
handler
.
call
(
this
arguments
[
1
]
)
;
break
;
case
3
:
handler
.
call
(
this
arguments
[
1
]
arguments
[
2
]
)
;
break
;
default
:
args
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
handler
.
apply
(
this
args
)
;
}
}
else
if
(
isObject
(
handler
)
)
{
args
=
Array
.
prototype
.
slice
.
call
(
arguments
1
)
;
listeners
=
handler
.
slice
(
)
;
len
=
listeners
.
length
;
for
(
i
=
0
;
i
<
len
;
i
+
+
)
listeners
[
i
]
.
apply
(
this
args
)
;
}
return
true
;
}
;
EventEmitter
.
prototype
.
addListener
=
function
(
type
listener
)
{
var
m
;
if
(
!
isFunction
(
listener
)
)
throw
TypeError
(
'
listener
must
be
a
function
'
)
;
if
(
!
this
.
_events
)
this
.
_events
=
{
}
;
if
(
this
.
_events
.
newListener
)
this
.
emit
(
'
newListener
'
type
isFunction
(
listener
.
listener
)
?
listener
.
listener
:
listener
)
;
if
(
!
this
.
_events
[
type
]
)
this
.
_events
[
type
]
=
listener
;
else
if
(
isObject
(
this
.
_events
[
type
]
)
)
this
.
_events
[
type
]
.
push
(
listener
)
;
else
this
.
_events
[
type
]
=
[
this
.
_events
[
type
]
listener
]
;
if
(
isObject
(
this
.
_events
[
type
]
)
&
&
!
this
.
_events
[
type
]
.
warned
)
{
if
(
!
isUndefined
(
this
.
_maxListeners
)
)
{
m
=
this
.
_maxListeners
;
}
else
{
m
=
EventEmitter
.
defaultMaxListeners
;
}
if
(
m
&
&
m
>
0
&
&
this
.
_events
[
type
]
.
length
>
m
)
{
this
.
_events
[
type
]
.
warned
=
true
;
console
.
error
(
'
(
node
)
warning
:
possible
EventEmitter
memory
'
+
'
leak
detected
.
%
d
listeners
added
.
'
+
'
Use
emitter
.
setMaxListeners
(
)
to
increase
limit
.
'
this
.
_events
[
type
]
.
length
)
;
if
(
typeof
console
.
trace
=
=
=
'
function
'
)
{
console
.
trace
(
)
;
}
}
}
return
this
;
}
;
EventEmitter
.
prototype
.
on
=
EventEmitter
.
prototype
.
addListener
;
EventEmitter
.
prototype
.
once
=
function
(
type
listener
)
{
if
(
!
isFunction
(
listener
)
)
throw
TypeError
(
'
listener
must
be
a
function
'
)
;
var
fired
=
false
;
function
g
(
)
{
this
.
removeListener
(
type
g
)
;
if
(
!
fired
)
{
fired
=
true
;
listener
.
apply
(
this
arguments
)
;
}
}
g
.
listener
=
listener
;
this
.
on
(
type
g
)
;
return
this
;
}
;
EventEmitter
.
prototype
.
removeListener
=
function
(
type
listener
)
{
var
list
position
length
i
;
if
(
!
isFunction
(
listener
)
)
throw
TypeError
(
'
listener
must
be
a
function
'
)
;
if
(
!
this
.
_events
|
|
!
this
.
_events
[
type
]
)
return
this
;
list
=
this
.
_events
[
type
]
;
length
=
list
.
length
;
position
=
-
1
;
if
(
list
=
=
=
listener
|
|
(
isFunction
(
list
.
listener
)
&
&
list
.
listener
=
=
=
listener
)
)
{
delete
this
.
_events
[
type
]
;
if
(
this
.
_events
.
removeListener
)
this
.
emit
(
'
removeListener
'
type
listener
)
;
}
else
if
(
isObject
(
list
)
)
{
for
(
i
=
length
;
i
-
-
>
0
;
)
{
if
(
list
[
i
]
=
=
=
listener
|
|
(
list
[
i
]
.
listener
&
&
list
[
i
]
.
listener
=
=
=
listener
)
)
{
position
=
i
;
break
;
}
}
if
(
position
<
0
)
return
this
;
if
(
list
.
length
=
=
=
1
)
{
list
.
length
=
0
;
delete
this
.
_events
[
type
]
;
}
else
{
list
.
splice
(
position
1
)
;
}
if
(
this
.
_events
.
removeListener
)
this
.
emit
(
'
removeListener
'
type
listener
)
;
}
return
this
;
}
;
EventEmitter
.
prototype
.
removeAllListeners
=
function
(
type
)
{
var
key
listeners
;
if
(
!
this
.
_events
)
return
this
;
if
(
!
this
.
_events
.
removeListener
)
{
if
(
arguments
.
length
=
=
=
0
)
this
.
_events
=
{
}
;
else
if
(
this
.
_events
[
type
]
)
delete
this
.
_events
[
type
]
;
return
this
;
}
if
(
arguments
.
length
=
=
=
0
)
{
for
(
key
in
this
.
_events
)
{
if
(
key
=
=
=
'
removeListener
'
)
continue
;
this
.
removeAllListeners
(
key
)
;
}
this
.
removeAllListeners
(
'
removeListener
'
)
;
this
.
_events
=
{
}
;
return
this
;
}
listeners
=
this
.
_events
[
type
]
;
if
(
isFunction
(
listeners
)
)
{
this
.
removeListener
(
type
listeners
)
;
}
else
if
(
listeners
)
{
while
(
listeners
.
length
)
this
.
removeListener
(
type
listeners
[
listeners
.
length
-
1
]
)
;
}
delete
this
.
_events
[
type
]
;
return
this
;
}
;
EventEmitter
.
prototype
.
listeners
=
function
(
type
)
{
var
ret
;
if
(
!
this
.
_events
|
|
!
this
.
_events
[
type
]
)
ret
=
[
]
;
else
if
(
isFunction
(
this
.
_events
[
type
]
)
)
ret
=
[
this
.
_events
[
type
]
]
;
else
ret
=
this
.
_events
[
type
]
.
slice
(
)
;
return
ret
;
}
;
EventEmitter
.
prototype
.
listenerCount
=
function
(
type
)
{
if
(
this
.
_events
)
{
var
evlistener
=
this
.
_events
[
type
]
;
if
(
isFunction
(
evlistener
)
)
return
1
;
else
if
(
evlistener
)
return
evlistener
.
length
;
}
return
0
;
}
;
EventEmitter
.
listenerCount
=
function
(
emitter
type
)
{
return
emitter
.
listenerCount
(
type
)
;
}
;
function
isFunction
(
arg
)
{
return
typeof
arg
=
=
=
'
function
'
;
}
function
isNumber
(
arg
)
{
return
typeof
arg
=
=
=
'
number
'
;
}
function
isObject
(
arg
)
{
return
typeof
arg
=
=
=
'
object
'
&
&
arg
!
=
=
null
;
}
function
isUndefined
(
arg
)
{
return
arg
=
=
=
void
0
;
}
}
{
}
]
64
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
var
exec
=
require
(
'
child_process
'
)
.
exec
fs
=
require
(
'
fs
'
)
path
=
require
(
'
path
'
)
exists
=
fs
.
existsSync
|
|
path
.
existsSync
os
=
require
(
'
os
'
)
quote
=
JSON
.
stringify
cmd
;
function
which
(
name
)
{
var
paths
=
process
.
env
.
PATH
.
split
(
'
:
'
)
;
var
loc
;
for
(
var
i
=
0
len
=
paths
.
length
;
i
<
len
;
+
+
i
)
{
loc
=
path
.
join
(
paths
[
i
]
name
)
;
if
(
exists
(
loc
)
)
return
loc
;
}
}
switch
(
os
.
type
(
)
)
{
case
'
Darwin
'
:
if
(
which
(
'
terminal
-
notifier
'
)
)
{
cmd
=
{
type
:
"
Darwin
-
NotificationCenter
"
pkg
:
"
terminal
-
notifier
"
msg
:
'
-
message
'
title
:
'
-
title
'
subtitle
:
'
-
subtitle
'
icon
:
'
-
appIcon
'
sound
:
'
-
sound
'
url
:
'
-
open
'
priority
:
{
cmd
:
'
-
execute
'
range
:
[
]
}
}
;
}
else
{
cmd
=
{
type
:
"
Darwin
-
Growl
"
pkg
:
"
growlnotify
"
msg
:
'
-
m
'
sticky
:
'
-
-
sticky
'
priority
:
{
cmd
:
'
-
-
priority
'
range
:
[
-
2
-
1
0
1
2
"
Very
Low
"
"
Moderate
"
"
Normal
"
"
High
"
"
Emergency
"
]
}
}
;
}
break
;
case
'
Linux
'
:
if
(
which
(
'
growl
'
)
)
{
cmd
=
{
type
:
"
Linux
-
Growl
"
pkg
:
"
growl
"
msg
:
'
-
m
'
title
:
'
-
title
'
subtitle
:
'
-
subtitle
'
host
:
{
cmd
:
'
-
H
'
hostname
:
'
192
.
168
.
33
.
1
'
}
}
;
}
else
{
cmd
=
{
type
:
"
Linux
"
pkg
:
"
notify
-
send
"
msg
:
'
'
sticky
:
'
-
t
0
'
icon
:
'
-
i
'
priority
:
{
cmd
:
'
-
u
'
range
:
[
"
low
"
"
normal
"
"
critical
"
]
}
}
;
}
break
;
case
'
Windows_NT
'
:
cmd
=
{
type
:
"
Windows
"
pkg
:
"
growlnotify
"
msg
:
'
'
sticky
:
'
/
s
:
true
'
title
:
'
/
t
:
'
icon
:
'
/
i
:
'
url
:
'
/
cu
:
'
priority
:
{
cmd
:
'
/
p
:
'
range
:
[
-
2
-
1
0
1
2
]
}
}
;
break
;
}
exports
=
module
.
exports
=
growl
;
exports
.
version
=
'
1
.
4
.
1
'
function
growl
(
msg
options
fn
)
{
var
image
args
options
=
options
|
|
{
}
fn
=
fn
|
|
function
(
)
{
}
;
if
(
options
.
exec
)
{
cmd
=
{
type
:
"
Custom
"
pkg
:
options
.
exec
range
:
[
]
}
;
}
if
(
!
cmd
)
return
fn
(
new
Error
(
'
growl
not
supported
on
this
platform
'
)
)
;
args
=
[
cmd
.
pkg
]
;
if
(
image
=
options
.
image
)
{
switch
(
cmd
.
type
)
{
case
'
Darwin
-
Growl
'
:
var
flag
ext
=
path
.
extname
(
image
)
.
substr
(
1
)
flag
=
flag
|
|
ext
=
=
'
icns
'
&
&
'
iconpath
'
flag
=
flag
|
|
/
^
[
A
-
Z
]
/
.
test
(
image
)
&
&
'
appIcon
'
flag
=
flag
|
|
/
^
png
|
gif
|
jpe
?
g
/
.
test
(
ext
)
&
&
'
image
'
flag
=
flag
|
|
ext
&
&
(
image
=
ext
)
&
&
'
icon
'
flag
=
flag
|
|
'
icon
'
args
.
push
(
'
-
-
'
+
flag
quote
(
image
)
)
break
;
case
'
Darwin
-
NotificationCenter
'
:
args
.
push
(
cmd
.
icon
quote
(
image
)
)
;
break
;
case
'
Linux
'
:
args
.
push
(
cmd
.
icon
quote
(
image
)
)
;
if
(
!
options
.
sticky
)
args
.
push
(
'
-
-
hint
=
int
:
transient
:
1
'
)
;
break
;
case
'
Windows
'
:
args
.
push
(
cmd
.
icon
+
quote
(
image
)
)
;
break
;
}
}
if
(
options
.
sticky
)
args
.
push
(
cmd
.
sticky
)
;
if
(
options
.
priority
)
{
var
priority
=
options
.
priority
+
'
'
;
var
checkindexOf
=
cmd
.
priority
.
range
.
indexOf
(
priority
)
;
if
(
~
cmd
.
priority
.
range
.
indexOf
(
priority
)
)
{
args
.
push
(
cmd
.
priority
options
.
priority
)
;
}
}
if
(
options
.
sound
&
&
cmd
.
type
=
=
=
'
Darwin
-
NotificationCenter
'
)
{
args
.
push
(
cmd
.
sound
options
.
sound
)
}
if
(
options
.
name
&
&
cmd
.
type
=
=
=
"
Darwin
-
Growl
"
)
{
args
.
push
(
'
-
-
name
'
options
.
name
)
;
}
switch
(
cmd
.
type
)
{
case
'
Darwin
-
Growl
'
:
args
.
push
(
cmd
.
msg
)
;
args
.
push
(
quote
(
msg
)
.
replace
(
/
\
\
n
/
g
'
\
n
'
)
)
;
if
(
options
.
title
)
args
.
push
(
quote
(
options
.
title
)
)
;
break
;
case
'
Darwin
-
NotificationCenter
'
:
args
.
push
(
cmd
.
msg
)
;
var
stringifiedMsg
=
quote
(
msg
)
;
var
escapedMsg
=
stringifiedMsg
.
replace
(
/
\
\
n
/
g
'
\
n
'
)
;
args
.
push
(
escapedMsg
)
;
if
(
options
.
title
)
{
args
.
push
(
cmd
.
title
)
;
args
.
push
(
quote
(
options
.
title
)
)
;
}
if
(
options
.
subtitle
)
{
args
.
push
(
cmd
.
subtitle
)
;
args
.
push
(
quote
(
options
.
subtitle
)
)
;
}
if
(
options
.
url
)
{
args
.
push
(
cmd
.
url
)
;
args
.
push
(
quote
(
options
.
url
)
)
;
}
break
;
case
'
Linux
-
Growl
'
:
args
.
push
(
cmd
.
msg
)
;
args
.
push
(
quote
(
msg
)
.
replace
(
/
\
\
n
/
g
'
\
n
'
)
)
;
if
(
options
.
title
)
args
.
push
(
quote
(
options
.
title
)
)
;
if
(
cmd
.
host
)
{
args
.
push
(
cmd
.
host
.
cmd
cmd
.
host
.
hostname
)
}
break
;
case
'
Linux
'
:
if
(
options
.
title
)
{
args
.
push
(
quote
(
options
.
title
)
)
;
args
.
push
(
cmd
.
msg
)
;
args
.
push
(
quote
(
msg
)
.
replace
(
/
\
\
n
/
g
'
\
n
'
)
)
;
}
else
{
args
.
push
(
quote
(
msg
)
.
replace
(
/
\
\
n
/
g
'
\
n
'
)
)
;
}
break
;
case
'
Windows
'
:
args
.
push
(
quote
(
msg
)
.
replace
(
/
\
\
n
/
g
'
\
n
'
)
)
;
if
(
options
.
title
)
args
.
push
(
cmd
.
title
+
quote
(
options
.
title
)
)
;
if
(
options
.
url
)
args
.
push
(
cmd
.
url
+
quote
(
options
.
url
)
)
;
break
;
case
'
Custom
'
:
args
[
0
]
=
(
function
(
origCommand
)
{
var
message
=
options
.
title
?
options
.
title
+
'
:
'
+
msg
:
msg
;
var
command
=
origCommand
.
replace
(
/
(
^
|
[
^
%
]
)
%
s
/
g
'
1
'
+
quote
(
message
)
)
;
if
(
command
=
=
=
origCommand
)
args
.
push
(
quote
(
message
)
)
;
return
command
;
}
)
(
args
[
0
]
)
;
break
;
}
exec
(
args
.
join
(
'
'
)
fn
)
;
}
;
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
_process
"
:
82
"
child_process
"
:
42
"
fs
"
:
42
"
os
"
:
80
"
path
"
:
42
}
]
65
:
[
function
(
require
module
exports
)
{
exports
.
read
=
function
(
buffer
offset
isLE
mLen
nBytes
)
{
var
e
m
var
eLen
=
nBytes
*
8
-
mLen
-
1
var
eMax
=
(
1
<
<
eLen
)
-
1
var
eBias
=
eMax
>
>
1
var
nBits
=
-
7
var
i
=
isLE
?
(
nBytes
-
1
)
:
0
var
d
=
isLE
?
-
1
:
1
var
s
=
buffer
[
offset
+
i
]
i
+
=
d
e
=
s
&
(
(
1
<
<
(
-
nBits
)
)
-
1
)
s
>
>
=
(
-
nBits
)
nBits
+
=
eLen
for
(
;
nBits
>
0
;
e
=
e
*
256
+
buffer
[
offset
+
i
]
i
+
=
d
nBits
-
=
8
)
{
}
m
=
e
&
(
(
1
<
<
(
-
nBits
)
)
-
1
)
e
>
>
=
(
-
nBits
)
nBits
+
=
mLen
for
(
;
nBits
>
0
;
m
=
m
*
256
+
buffer
[
offset
+
i
]
i
+
=
d
nBits
-
=
8
)
{
}
if
(
e
=
=
=
0
)
{
e
=
1
-
eBias
}
else
if
(
e
=
=
=
eMax
)
{
return
m
?
NaN
:
(
(
s
?
-
1
:
1
)
*
Infinity
)
}
else
{
m
=
m
+
Math
.
pow
(
2
mLen
)
e
=
e
-
eBias
}
return
(
s
?
-
1
:
1
)
*
m
*
Math
.
pow
(
2
e
-
mLen
)
}
exports
.
write
=
function
(
buffer
value
offset
isLE
mLen
nBytes
)
{
var
e
m
c
var
eLen
=
nBytes
*
8
-
mLen
-
1
var
eMax
=
(
1
<
<
eLen
)
-
1
var
eBias
=
eMax
>
>
1
var
rt
=
(
mLen
=
=
=
23
?
Math
.
pow
(
2
-
24
)
-
Math
.
pow
(
2
-
77
)
:
0
)
var
i
=
isLE
?
0
:
(
nBytes
-
1
)
var
d
=
isLE
?
1
:
-
1
var
s
=
value
<
0
|
|
(
value
=
=
=
0
&
&
1
/
value
<
0
)
?
1
:
0
value
=
Math
.
abs
(
value
)
if
(
isNaN
(
value
)
|
|
value
=
=
=
Infinity
)
{
m
=
isNaN
(
value
)
?
1
:
0
e
=
eMax
}
else
{
e
=
Math
.
floor
(
Math
.
log
(
value
)
/
Math
.
LN2
)
if
(
value
*
(
c
=
Math
.
pow
(
2
-
e
)
)
<
1
)
{
e
-
-
c
*
=
2
}
if
(
e
+
eBias
>
=
1
)
{
value
+
=
rt
/
c
}
else
{
value
+
=
rt
*
Math
.
pow
(
2
1
-
eBias
)
}
if
(
value
*
c
>
=
2
)
{
e
+
+
c
/
=
2
}
if
(
e
+
eBias
>
=
eMax
)
{
m
=
0
e
=
eMax
}
else
if
(
e
+
eBias
>
=
1
)
{
m
=
(
value
*
c
-
1
)
*
Math
.
pow
(
2
mLen
)
e
=
e
+
eBias
}
else
{
m
=
value
*
Math
.
pow
(
2
eBias
-
1
)
*
Math
.
pow
(
2
mLen
)
e
=
0
}
}
for
(
;
mLen
>
=
8
;
buffer
[
offset
+
i
]
=
m
&
0xff
i
+
=
d
m
/
=
256
mLen
-
=
8
)
{
}
e
=
(
e
<
<
mLen
)
|
m
eLen
+
=
mLen
for
(
;
eLen
>
0
;
buffer
[
offset
+
i
]
=
e
&
0xff
i
+
=
d
e
/
=
256
eLen
-
=
8
)
{
}
buffer
[
offset
+
i
-
d
]
|
=
s
*
128
}
}
{
}
]
66
:
[
function
(
require
module
exports
)
{
if
(
typeof
Object
.
create
=
=
=
'
function
'
)
{
module
.
exports
=
function
inherits
(
ctor
superCtor
)
{
ctor
.
super_
=
superCtor
ctor
.
prototype
=
Object
.
create
(
superCtor
.
prototype
{
constructor
:
{
value
:
ctor
enumerable
:
false
writable
:
true
configurable
:
true
}
}
)
;
}
;
}
else
{
module
.
exports
=
function
inherits
(
ctor
superCtor
)
{
ctor
.
super_
=
superCtor
var
TempCtor
=
function
(
)
{
}
TempCtor
.
prototype
=
superCtor
.
prototype
ctor
.
prototype
=
new
TempCtor
(
)
ctor
.
prototype
.
constructor
=
ctor
}
}
}
{
}
]
67
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
(
obj
)
{
return
obj
!
=
null
&
&
(
isBuffer
(
obj
)
|
|
isSlowBuffer
(
obj
)
|
|
!
!
obj
.
_isBuffer
)
}
function
isBuffer
(
obj
)
{
return
!
!
obj
.
constructor
&
&
typeof
obj
.
constructor
.
isBuffer
=
=
=
'
function
'
&
&
obj
.
constructor
.
isBuffer
(
obj
)
}
function
isSlowBuffer
(
obj
)
{
return
typeof
obj
.
readFloatLE
=
=
=
'
function
'
&
&
typeof
obj
.
slice
=
=
=
'
function
'
&
&
isBuffer
(
obj
.
slice
(
0
0
)
)
}
}
{
}
]
68
:
[
function
(
require
module
exports
)
{
var
toString
=
{
}
.
toString
;
module
.
exports
=
Array
.
isArray
|
|
function
(
arr
)
{
return
toString
.
call
(
arr
)
=
=
'
[
object
Array
]
'
;
}
;
}
{
}
]
69
:
[
function
(
require
module
exports
)
{
(
function
(
global
)
{
;
(
function
(
)
{
var
isLoader
=
false
;
var
objectTypes
=
{
"
function
"
:
true
"
object
"
:
true
}
;
var
freeExports
=
objectTypes
[
typeof
exports
]
&
&
exports
&
&
!
exports
.
nodeType
&
&
exports
;
var
root
=
objectTypes
[
typeof
window
]
&
&
window
|
|
this
freeGlobal
=
freeExports
&
&
objectTypes
[
typeof
module
]
&
&
module
&
&
!
module
.
nodeType
&
&
typeof
global
=
=
"
object
"
&
&
global
;
if
(
freeGlobal
&
&
(
freeGlobal
[
"
global
"
]
=
=
=
freeGlobal
|
|
freeGlobal
[
"
window
"
]
=
=
=
freeGlobal
|
|
freeGlobal
[
"
self
"
]
=
=
=
freeGlobal
)
)
{
root
=
freeGlobal
;
}
function
runInContext
(
context
exports
)
{
context
|
|
(
context
=
root
[
"
Object
"
]
(
)
)
;
exports
|
|
(
exports
=
root
[
"
Object
"
]
(
)
)
;
var
Number
=
context
[
"
Number
"
]
|
|
root
[
"
Number
"
]
String
=
context
[
"
String
"
]
|
|
root
[
"
String
"
]
Object
=
context
[
"
Object
"
]
|
|
root
[
"
Object
"
]
Date
=
context
[
"
Date
"
]
|
|
root
[
"
Date
"
]
SyntaxError
=
context
[
"
SyntaxError
"
]
|
|
root
[
"
SyntaxError
"
]
TypeError
=
context
[
"
TypeError
"
]
|
|
root
[
"
TypeError
"
]
Math
=
context
[
"
Math
"
]
|
|
root
[
"
Math
"
]
nativeJSON
=
context
[
"
JSON
"
]
|
|
root
[
"
JSON
"
]
;
if
(
typeof
nativeJSON
=
=
"
object
"
&
&
nativeJSON
)
{
exports
.
stringify
=
nativeJSON
.
stringify
;
exports
.
parse
=
nativeJSON
.
parse
;
}
var
objectProto
=
Object
.
prototype
getClass
=
objectProto
.
toString
isProperty
forEach
undef
;
var
isExtended
=
new
Date
(
-
3509827334573292
)
;
try
{
isExtended
=
isExtended
.
getUTCFullYear
(
)
=
=
-
109252
&
&
isExtended
.
getUTCMonth
(
)
=
=
=
0
&
&
isExtended
.
getUTCDate
(
)
=
=
=
1
&
&
isExtended
.
getUTCHours
(
)
=
=
10
&
&
isExtended
.
getUTCMinutes
(
)
=
=
37
&
&
isExtended
.
getUTCSeconds
(
)
=
=
6
&
&
isExtended
.
getUTCMilliseconds
(
)
=
=
708
;
}
catch
(
exception
)
{
}
function
has
(
name
)
{
if
(
has
[
name
]
!
=
=
undef
)
{
return
has
[
name
]
;
}
var
isSupported
;
if
(
name
=
=
"
bug
-
string
-
char
-
index
"
)
{
isSupported
=
"
a
"
[
0
]
!
=
"
a
"
;
}
else
if
(
name
=
=
"
json
"
)
{
isSupported
=
has
(
"
json
-
stringify
"
)
&
&
has
(
"
json
-
parse
"
)
;
}
else
{
var
value
serialized
=
'
{
"
a
"
:
[
1
true
false
null
"
\
\
u0000
\
\
b
\
\
n
\
\
f
\
\
r
\
\
t
"
]
}
'
;
if
(
name
=
=
"
json
-
stringify
"
)
{
var
stringify
=
exports
.
stringify
stringifySupported
=
typeof
stringify
=
=
"
function
"
&
&
isExtended
;
if
(
stringifySupported
)
{
(
value
=
function
(
)
{
return
1
;
}
)
.
toJSON
=
value
;
try
{
stringifySupported
=
stringify
(
0
)
=
=
=
"
0
"
&
&
stringify
(
new
Number
(
)
)
=
=
=
"
0
"
&
&
stringify
(
new
String
(
)
)
=
=
'
"
"
'
&
&
stringify
(
getClass
)
=
=
=
undef
&
&
stringify
(
undef
)
=
=
=
undef
&
&
stringify
(
)
=
=
=
undef
&
&
stringify
(
value
)
=
=
=
"
1
"
&
&
stringify
(
[
value
]
)
=
=
"
[
1
]
"
&
&
stringify
(
[
undef
]
)
=
=
"
[
null
]
"
&
&
stringify
(
null
)
=
=
"
null
"
&
&
stringify
(
[
undef
getClass
null
]
)
=
=
"
[
null
null
null
]
"
&
&
stringify
(
{
"
a
"
:
[
value
true
false
null
"
\
x00
\
b
\
n
\
f
\
r
\
t
"
]
}
)
=
=
serialized
&
&
stringify
(
null
value
)
=
=
=
"
1
"
&
&
stringify
(
[
1
2
]
null
1
)
=
=
"
[
\
n
1
\
n
2
\
n
]
"
&
&
stringify
(
new
Date
(
-
8
.
64e15
)
)
=
=
'
"
-
271821
-
04
-
20T00
:
00
:
00
.
000Z
"
'
&
&
stringify
(
new
Date
(
8
.
64e15
)
)
=
=
'
"
+
275760
-
09
-
13T00
:
00
:
00
.
000Z
"
'
&
&
stringify
(
new
Date
(
-
621987552e5
)
)
=
=
'
"
-
000001
-
01
-
01T00
:
00
:
00
.
000Z
"
'
&
&
stringify
(
new
Date
(
-
1
)
)
=
=
'
"
1969
-
12
-
31T23
:
59
:
59
.
999Z
"
'
;
}
catch
(
exception
)
{
stringifySupported
=
false
;
}
}
isSupported
=
stringifySupported
;
}
if
(
name
=
=
"
json
-
parse
"
)
{
var
parse
=
exports
.
parse
;
if
(
typeof
parse
=
=
"
function
"
)
{
try
{
if
(
parse
(
"
0
"
)
=
=
=
0
&
&
!
parse
(
false
)
)
{
value
=
parse
(
serialized
)
;
var
parseSupported
=
value
[
"
a
"
]
.
length
=
=
5
&
&
value
[
"
a
"
]
[
0
]
=
=
=
1
;
if
(
parseSupported
)
{
try
{
parseSupported
=
!
parse
(
'
"
\
t
"
'
)
;
}
catch
(
exception
)
{
}
if
(
parseSupported
)
{
try
{
parseSupported
=
parse
(
"
01
"
)
!
=
=
1
;
}
catch
(
exception
)
{
}
}
if
(
parseSupported
)
{
try
{
parseSupported
=
parse
(
"
1
.
"
)
!
=
=
1
;
}
catch
(
exception
)
{
}
}
}
}
}
catch
(
exception
)
{
parseSupported
=
false
;
}
}
isSupported
=
parseSupported
;
}
}
return
has
[
name
]
=
!
!
isSupported
;
}
if
(
!
has
(
"
json
"
)
)
{
var
functionClass
=
"
[
object
Function
]
"
dateClass
=
"
[
object
Date
]
"
numberClass
=
"
[
object
Number
]
"
stringClass
=
"
[
object
String
]
"
arrayClass
=
"
[
object
Array
]
"
booleanClass
=
"
[
object
Boolean
]
"
;
var
charIndexBuggy
=
has
(
"
bug
-
string
-
char
-
index
"
)
;
if
(
!
isExtended
)
{
var
floor
=
Math
.
floor
;
var
Months
=
[
0
31
59
90
120
151
181
212
243
273
304
334
]
;
var
getDay
=
function
(
year
month
)
{
return
Months
[
month
]
+
365
*
(
year
-
1970
)
+
floor
(
(
year
-
1969
+
(
month
=
+
(
month
>
1
)
)
)
/
4
)
-
floor
(
(
year
-
1901
+
month
)
/
100
)
+
floor
(
(
year
-
1601
+
month
)
/
400
)
;
}
;
}
if
(
!
(
isProperty
=
objectProto
.
hasOwnProperty
)
)
{
isProperty
=
function
(
property
)
{
var
members
=
{
}
constructor
;
if
(
(
members
.
__proto__
=
null
members
.
__proto__
=
{
"
toString
"
:
1
}
members
)
.
toString
!
=
getClass
)
{
isProperty
=
function
(
property
)
{
var
original
=
this
.
__proto__
result
=
property
in
(
this
.
__proto__
=
null
this
)
;
this
.
__proto__
=
original
;
return
result
;
}
;
}
else
{
constructor
=
members
.
constructor
;
isProperty
=
function
(
property
)
{
var
parent
=
(
this
.
constructor
|
|
constructor
)
.
prototype
;
return
property
in
this
&
&
!
(
property
in
parent
&
&
this
[
property
]
=
=
=
parent
[
property
]
)
;
}
;
}
members
=
null
;
return
isProperty
.
call
(
this
property
)
;
}
;
}
forEach
=
function
(
object
callback
)
{
var
size
=
0
Properties
members
property
;
(
Properties
=
function
(
)
{
this
.
valueOf
=
0
;
}
)
.
prototype
.
valueOf
=
0
;
members
=
new
Properties
(
)
;
for
(
property
in
members
)
{
if
(
isProperty
.
call
(
members
property
)
)
{
size
+
+
;
}
}
Properties
=
members
=
null
;
if
(
!
size
)
{
members
=
[
"
valueOf
"
"
toString
"
"
toLocaleString
"
"
propertyIsEnumerable
"
"
isPrototypeOf
"
"
hasOwnProperty
"
"
constructor
"
]
;
forEach
=
function
(
object
callback
)
{
var
isFunction
=
getClass
.
call
(
object
)
=
=
functionClass
property
length
;
var
hasProperty
=
!
isFunction
&
&
typeof
object
.
constructor
!
=
"
function
"
&
&
objectTypes
[
typeof
object
.
hasOwnProperty
]
&
&
object
.
hasOwnProperty
|
|
isProperty
;
for
(
property
in
object
)
{
if
(
!
(
isFunction
&
&
property
=
=
"
prototype
"
)
&
&
hasProperty
.
call
(
object
property
)
)
{
callback
(
property
)
;
}
}
for
(
length
=
members
.
length
;
property
=
members
[
-
-
length
]
;
hasProperty
.
call
(
object
property
)
&
&
callback
(
property
)
)
;
}
;
}
else
if
(
size
=
=
2
)
{
forEach
=
function
(
object
callback
)
{
var
members
=
{
}
isFunction
=
getClass
.
call
(
object
)
=
=
functionClass
property
;
for
(
property
in
object
)
{
if
(
!
(
isFunction
&
&
property
=
=
"
prototype
"
)
&
&
!
isProperty
.
call
(
members
property
)
&
&
(
members
[
property
]
=
1
)
&
&
isProperty
.
call
(
object
property
)
)
{
callback
(
property
)
;
}
}
}
;
}
else
{
forEach
=
function
(
object
callback
)
{
var
isFunction
=
getClass
.
call
(
object
)
=
=
functionClass
property
isConstructor
;
for
(
property
in
object
)
{
if
(
!
(
isFunction
&
&
property
=
=
"
prototype
"
)
&
&
isProperty
.
call
(
object
property
)
&
&
!
(
isConstructor
=
property
=
=
=
"
constructor
"
)
)
{
callback
(
property
)
;
}
}
if
(
isConstructor
|
|
isProperty
.
call
(
object
(
property
=
"
constructor
"
)
)
)
{
callback
(
property
)
;
}
}
;
}
return
forEach
(
object
callback
)
;
}
;
if
(
!
has
(
"
json
-
stringify
"
)
)
{
var
Escapes
=
{
92
:
"
\
\
\
\
"
34
:
'
\
\
"
'
8
:
"
\
\
b
"
12
:
"
\
\
f
"
10
:
"
\
\
n
"
13
:
"
\
\
r
"
9
:
"
\
\
t
"
}
;
var
leadingZeroes
=
"
000000
"
;
var
toPaddedString
=
function
(
width
value
)
{
return
(
leadingZeroes
+
(
value
|
|
0
)
)
.
slice
(
-
width
)
;
}
;
var
unicodePrefix
=
"
\
\
u00
"
;
var
quote
=
function
(
value
)
{
var
result
=
'
"
'
index
=
0
length
=
value
.
length
useCharIndex
=
!
charIndexBuggy
|
|
length
>
10
;
var
symbols
=
useCharIndex
&
&
(
charIndexBuggy
?
value
.
split
(
"
"
)
:
value
)
;
for
(
;
index
<
length
;
index
+
+
)
{
var
charCode
=
value
.
charCodeAt
(
index
)
;
switch
(
charCode
)
{
case
8
:
case
9
:
case
10
:
case
12
:
case
13
:
case
34
:
case
92
:
result
+
=
Escapes
[
charCode
]
;
break
;
default
:
if
(
charCode
<
32
)
{
result
+
=
unicodePrefix
+
toPaddedString
(
2
charCode
.
toString
(
16
)
)
;
break
;
}
result
+
=
useCharIndex
?
symbols
[
index
]
:
value
.
charAt
(
index
)
;
}
}
return
result
+
'
"
'
;
}
;
var
serialize
=
function
(
property
object
callback
properties
whitespace
indentation
stack
)
{
var
value
className
year
month
date
time
hours
minutes
seconds
milliseconds
results
element
index
length
prefix
result
;
try
{
value
=
object
[
property
]
;
}
catch
(
exception
)
{
}
if
(
typeof
value
=
=
"
object
"
&
&
value
)
{
className
=
getClass
.
call
(
value
)
;
if
(
className
=
=
dateClass
&
&
!
isProperty
.
call
(
value
"
toJSON
"
)
)
{
if
(
value
>
-
1
/
0
&
&
value
<
1
/
0
)
{
if
(
getDay
)
{
date
=
floor
(
value
/
864e5
)
;
for
(
year
=
floor
(
date
/
365
.
2425
)
+
1970
-
1
;
getDay
(
year
+
1
0
)
<
=
date
;
year
+
+
)
;
for
(
month
=
floor
(
(
date
-
getDay
(
year
0
)
)
/
30
.
42
)
;
getDay
(
year
month
+
1
)
<
=
date
;
month
+
+
)
;
date
=
1
+
date
-
getDay
(
year
month
)
;
time
=
(
value
%
864e5
+
864e5
)
%
864e5
;
hours
=
floor
(
time
/
36e5
)
%
24
;
minutes
=
floor
(
time
/
6e4
)
%
60
;
seconds
=
floor
(
time
/
1e3
)
%
60
;
milliseconds
=
time
%
1e3
;
}
else
{
year
=
value
.
getUTCFullYear
(
)
;
month
=
value
.
getUTCMonth
(
)
;
date
=
value
.
getUTCDate
(
)
;
hours
=
value
.
getUTCHours
(
)
;
minutes
=
value
.
getUTCMinutes
(
)
;
seconds
=
value
.
getUTCSeconds
(
)
;
milliseconds
=
value
.
getUTCMilliseconds
(
)
;
}
value
=
(
year
<
=
0
|
|
year
>
=
1e4
?
(
year
<
0
?
"
-
"
:
"
+
"
)
+
toPaddedString
(
6
year
<
0
?
-
year
:
year
)
:
toPaddedString
(
4
year
)
)
+
"
-
"
+
toPaddedString
(
2
month
+
1
)
+
"
-
"
+
toPaddedString
(
2
date
)
+
"
T
"
+
toPaddedString
(
2
hours
)
+
"
:
"
+
toPaddedString
(
2
minutes
)
+
"
:
"
+
toPaddedString
(
2
seconds
)
+
"
.
"
+
toPaddedString
(
3
milliseconds
)
+
"
Z
"
;
}
else
{
value
=
null
;
}
}
else
if
(
typeof
value
.
toJSON
=
=
"
function
"
&
&
(
(
className
!
=
numberClass
&
&
className
!
=
stringClass
&
&
className
!
=
arrayClass
)
|
|
isProperty
.
call
(
value
"
toJSON
"
)
)
)
{
value
=
value
.
toJSON
(
property
)
;
}
}
if
(
callback
)
{
value
=
callback
.
call
(
object
property
value
)
;
}
if
(
value
=
=
=
null
)
{
return
"
null
"
;
}
className
=
getClass
.
call
(
value
)
;
if
(
className
=
=
booleanClass
)
{
return
"
"
+
value
;
}
else
if
(
className
=
=
numberClass
)
{
return
value
>
-
1
/
0
&
&
value
<
1
/
0
?
"
"
+
value
:
"
null
"
;
}
else
if
(
className
=
=
stringClass
)
{
return
quote
(
"
"
+
value
)
;
}
if
(
typeof
value
=
=
"
object
"
)
{
for
(
length
=
stack
.
length
;
length
-
-
;
)
{
if
(
stack
[
length
]
=
=
=
value
)
{
throw
TypeError
(
)
;
}
}
stack
.
push
(
value
)
;
results
=
[
]
;
prefix
=
indentation
;
indentation
+
=
whitespace
;
if
(
className
=
=
arrayClass
)
{
for
(
index
=
0
length
=
value
.
length
;
index
<
length
;
index
+
+
)
{
element
=
serialize
(
index
value
callback
properties
whitespace
indentation
stack
)
;
results
.
push
(
element
=
=
=
undef
?
"
null
"
:
element
)
;
}
result
=
results
.
length
?
(
whitespace
?
"
[
\
n
"
+
indentation
+
results
.
join
(
"
\
n
"
+
indentation
)
+
"
\
n
"
+
prefix
+
"
]
"
:
(
"
[
"
+
results
.
join
(
"
"
)
+
"
]
"
)
)
:
"
[
]
"
;
}
else
{
forEach
(
properties
|
|
value
function
(
property
)
{
var
element
=
serialize
(
property
value
callback
properties
whitespace
indentation
stack
)
;
if
(
element
!
=
=
undef
)
{
results
.
push
(
quote
(
property
)
+
"
:
"
+
(
whitespace
?
"
"
:
"
"
)
+
element
)
;
}
}
)
;
result
=
results
.
length
?
(
whitespace
?
"
{
\
n
"
+
indentation
+
results
.
join
(
"
\
n
"
+
indentation
)
+
"
\
n
"
+
prefix
+
"
}
"
:
(
"
{
"
+
results
.
join
(
"
"
)
+
"
}
"
)
)
:
"
{
}
"
;
}
stack
.
pop
(
)
;
return
result
;
}
}
;
exports
.
stringify
=
function
(
source
filter
width
)
{
var
whitespace
callback
properties
className
;
if
(
objectTypes
[
typeof
filter
]
&
&
filter
)
{
if
(
(
className
=
getClass
.
call
(
filter
)
)
=
=
functionClass
)
{
callback
=
filter
;
}
else
if
(
className
=
=
arrayClass
)
{
properties
=
{
}
;
for
(
var
index
=
0
length
=
filter
.
length
value
;
index
<
length
;
value
=
filter
[
index
+
+
]
(
(
className
=
getClass
.
call
(
value
)
)
className
=
=
stringClass
|
|
className
=
=
numberClass
)
&
&
(
properties
[
value
]
=
1
)
)
;
}
}
if
(
width
)
{
if
(
(
className
=
getClass
.
call
(
width
)
)
=
=
numberClass
)
{
if
(
(
width
-
=
width
%
1
)
>
0
)
{
for
(
whitespace
=
"
"
width
>
10
&
&
(
width
=
10
)
;
whitespace
.
length
<
width
;
whitespace
+
=
"
"
)
;
}
}
else
if
(
className
=
=
stringClass
)
{
whitespace
=
width
.
length
<
=
10
?
width
:
width
.
slice
(
0
10
)
;
}
}
return
serialize
(
"
"
(
value
=
{
}
value
[
"
"
]
=
source
value
)
callback
properties
whitespace
"
"
[
]
)
;
}
;
}
if
(
!
has
(
"
json
-
parse
"
)
)
{
var
fromCharCode
=
String
.
fromCharCode
;
var
Unescapes
=
{
92
:
"
\
\
"
34
:
'
"
'
47
:
"
/
"
98
:
"
\
b
"
116
:
"
\
t
"
110
:
"
\
n
"
102
:
"
\
f
"
114
:
"
\
r
"
}
;
var
Index
Source
;
var
abort
=
function
(
)
{
Index
=
Source
=
null
;
throw
SyntaxError
(
)
;
}
;
var
lex
=
function
(
)
{
var
source
=
Source
length
=
source
.
length
value
begin
position
isSigned
charCode
;
while
(
Index
<
length
)
{
charCode
=
source
.
charCodeAt
(
Index
)
;
switch
(
charCode
)
{
case
9
:
case
10
:
case
13
:
case
32
:
Index
+
+
;
break
;
case
123
:
case
125
:
case
91
:
case
93
:
case
58
:
case
44
:
value
=
charIndexBuggy
?
source
.
charAt
(
Index
)
:
source
[
Index
]
;
Index
+
+
;
return
value
;
case
34
:
for
(
value
=
"
"
Index
+
+
;
Index
<
length
;
)
{
charCode
=
source
.
charCodeAt
(
Index
)
;
if
(
charCode
<
32
)
{
abort
(
)
;
}
else
if
(
charCode
=
=
92
)
{
charCode
=
source
.
charCodeAt
(
+
+
Index
)
;
switch
(
charCode
)
{
case
92
:
case
34
:
case
47
:
case
98
:
case
116
:
case
110
:
case
102
:
case
114
:
value
+
=
Unescapes
[
charCode
]
;
Index
+
+
;
break
;
case
117
:
begin
=
+
+
Index
;
for
(
position
=
Index
+
4
;
Index
<
position
;
Index
+
+
)
{
charCode
=
source
.
charCodeAt
(
Index
)
;
if
(
!
(
charCode
>
=
48
&
&
charCode
<
=
57
|
|
charCode
>
=
97
&
&
charCode
<
=
102
|
|
charCode
>
=
65
&
&
charCode
<
=
70
)
)
{
abort
(
)
;
}
}
value
+
=
fromCharCode
(
"
0x
"
+
source
.
slice
(
begin
Index
)
)
;
break
;
default
:
abort
(
)
;
}
}
else
{
if
(
charCode
=
=
34
)
{
break
;
}
charCode
=
source
.
charCodeAt
(
Index
)
;
begin
=
Index
;
while
(
charCode
>
=
32
&
&
charCode
!
=
92
&
&
charCode
!
=
34
)
{
charCode
=
source
.
charCodeAt
(
+
+
Index
)
;
}
value
+
=
source
.
slice
(
begin
Index
)
;
}
}
if
(
source
.
charCodeAt
(
Index
)
=
=
34
)
{
Index
+
+
;
return
value
;
}
abort
(
)
;
default
:
begin
=
Index
;
if
(
charCode
=
=
45
)
{
isSigned
=
true
;
charCode
=
source
.
charCodeAt
(
+
+
Index
)
;
}
if
(
charCode
>
=
48
&
&
charCode
<
=
57
)
{
if
(
charCode
=
=
48
&
&
(
(
charCode
=
source
.
charCodeAt
(
Index
+
1
)
)
charCode
>
=
48
&
&
charCode
<
=
57
)
)
{
abort
(
)
;
}
isSigned
=
false
;
for
(
;
Index
<
length
&
&
(
(
charCode
=
source
.
charCodeAt
(
Index
)
)
charCode
>
=
48
&
&
charCode
<
=
57
)
;
Index
+
+
)
;
if
(
source
.
charCodeAt
(
Index
)
=
=
46
)
{
position
=
+
+
Index
;
for
(
;
position
<
length
&
&
(
(
charCode
=
source
.
charCodeAt
(
position
)
)
charCode
>
=
48
&
&
charCode
<
=
57
)
;
position
+
+
)
;
if
(
position
=
=
Index
)
{
abort
(
)
;
}
Index
=
position
;
}
charCode
=
source
.
charCodeAt
(
Index
)
;
if
(
charCode
=
=
101
|
|
charCode
=
=
69
)
{
charCode
=
source
.
charCodeAt
(
+
+
Index
)
;
if
(
charCode
=
=
43
|
|
charCode
=
=
45
)
{
Index
+
+
;
}
for
(
position
=
Index
;
position
<
length
&
&
(
(
charCode
=
source
.
charCodeAt
(
position
)
)
charCode
>
=
48
&
&
charCode
<
=
57
)
;
position
+
+
)
;
if
(
position
=
=
Index
)
{
abort
(
)
;
}
Index
=
position
;
}
return
+
source
.
slice
(
begin
Index
)
;
}
if
(
isSigned
)
{
abort
(
)
;
}
if
(
source
.
slice
(
Index
Index
+
4
)
=
=
"
true
"
)
{
Index
+
=
4
;
return
true
;
}
else
if
(
source
.
slice
(
Index
Index
+
5
)
=
=
"
false
"
)
{
Index
+
=
5
;
return
false
;
}
else
if
(
source
.
slice
(
Index
Index
+
4
)
=
=
"
null
"
)
{
Index
+
=
4
;
return
null
;
}
abort
(
)
;
}
}
return
"
"
;
}
;
var
get
=
function
(
value
)
{
var
results
hasMembers
;
if
(
value
=
=
"
"
)
{
abort
(
)
;
}
if
(
typeof
value
=
=
"
string
"
)
{
if
(
(
charIndexBuggy
?
value
.
charAt
(
0
)
:
value
[
0
]
)
=
=
"
"
)
{
return
value
.
slice
(
1
)
;
}
if
(
value
=
=
"
[
"
)
{
results
=
[
]
;
for
(
;
;
hasMembers
|
|
(
hasMembers
=
true
)
)
{
value
=
lex
(
)
;
if
(
value
=
=
"
]
"
)
{
break
;
}
if
(
hasMembers
)
{
if
(
value
=
=
"
"
)
{
value
=
lex
(
)
;
if
(
value
=
=
"
]
"
)
{
abort
(
)
;
}
}
else
{
abort
(
)
;
}
}
if
(
value
=
=
"
"
)
{
abort
(
)
;
}
results
.
push
(
get
(
value
)
)
;
}
return
results
;
}
else
if
(
value
=
=
"
{
"
)
{
results
=
{
}
;
for
(
;
;
hasMembers
|
|
(
hasMembers
=
true
)
)
{
value
=
lex
(
)
;
if
(
value
=
=
"
}
"
)
{
break
;
}
if
(
hasMembers
)
{
if
(
value
=
=
"
"
)
{
value
=
lex
(
)
;
if
(
value
=
=
"
}
"
)
{
abort
(
)
;
}
}
else
{
abort
(
)
;
}
}
if
(
value
=
=
"
"
|
|
typeof
value
!
=
"
string
"
|
|
(
charIndexBuggy
?
value
.
charAt
(
0
)
:
value
[
0
]
)
!
=
"
"
|
|
lex
(
)
!
=
"
:
"
)
{
abort
(
)
;
}
results
[
value
.
slice
(
1
)
]
=
get
(
lex
(
)
)
;
}
return
results
;
}
abort
(
)
;
}
return
value
;
}
;
var
update
=
function
(
source
property
callback
)
{
var
element
=
walk
(
source
property
callback
)
;
if
(
element
=
=
=
undef
)
{
delete
source
[
property
]
;
}
else
{
source
[
property
]
=
element
;
}
}
;
var
walk
=
function
(
source
property
callback
)
{
var
value
=
source
[
property
]
length
;
if
(
typeof
value
=
=
"
object
"
&
&
value
)
{
if
(
getClass
.
call
(
value
)
=
=
arrayClass
)
{
for
(
length
=
value
.
length
;
length
-
-
;
)
{
update
(
value
length
callback
)
;
}
}
else
{
forEach
(
value
function
(
property
)
{
update
(
value
property
callback
)
;
}
)
;
}
}
return
callback
.
call
(
source
property
value
)
;
}
;
exports
.
parse
=
function
(
source
callback
)
{
var
result
value
;
Index
=
0
;
Source
=
"
"
+
source
;
result
=
get
(
lex
(
)
)
;
if
(
lex
(
)
!
=
"
"
)
{
abort
(
)
;
}
Index
=
Source
=
null
;
return
callback
&
&
getClass
.
call
(
callback
)
=
=
functionClass
?
walk
(
(
value
=
{
}
value
[
"
"
]
=
result
value
)
"
"
callback
)
:
result
;
}
;
}
}
exports
[
"
runInContext
"
]
=
runInContext
;
return
exports
;
}
if
(
freeExports
&
&
!
isLoader
)
{
runInContext
(
root
freeExports
)
;
}
else
{
var
nativeJSON
=
root
.
JSON
previousJSON
=
root
[
"
JSON3
"
]
isRestored
=
false
;
var
JSON3
=
runInContext
(
root
(
root
[
"
JSON3
"
]
=
{
"
noConflict
"
:
function
(
)
{
if
(
!
isRestored
)
{
isRestored
=
true
;
root
.
JSON
=
nativeJSON
;
root
[
"
JSON3
"
]
=
previousJSON
;
nativeJSON
=
previousJSON
=
null
;
}
return
JSON3
;
}
}
)
)
;
root
.
JSON
=
{
"
parse
"
:
JSON3
.
parse
"
stringify
"
:
JSON3
.
stringify
}
;
}
if
(
isLoader
)
{
define
(
function
(
)
{
return
JSON3
;
}
)
;
}
}
)
.
call
(
this
)
;
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
}
]
70
:
[
function
(
require
module
exports
)
{
var
baseCopy
=
require
(
'
lodash
.
_basecopy
'
)
keys
=
require
(
'
lodash
.
keys
'
)
;
function
baseAssign
(
object
source
)
{
return
source
=
=
null
?
object
:
baseCopy
(
source
keys
(
source
)
object
)
;
}
module
.
exports
=
baseAssign
;
}
{
"
lodash
.
_basecopy
"
:
71
"
lodash
.
keys
"
:
78
}
]
71
:
[
function
(
require
module
exports
)
{
function
baseCopy
(
source
props
object
)
{
object
|
|
(
object
=
{
}
)
;
var
index
=
-
1
length
=
props
.
length
;
while
(
+
+
index
<
length
)
{
var
key
=
props
[
index
]
;
object
[
key
]
=
source
[
key
]
;
}
return
object
;
}
module
.
exports
=
baseCopy
;
}
{
}
]
72
:
[
function
(
require
module
exports
)
{
var
baseCreate
=
(
function
(
)
{
function
object
(
)
{
}
return
function
(
prototype
)
{
if
(
isObject
(
prototype
)
)
{
object
.
prototype
=
prototype
;
var
result
=
new
object
;
object
.
prototype
=
undefined
;
}
return
result
|
|
{
}
;
}
;
}
(
)
)
;
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
module
.
exports
=
baseCreate
;
}
{
}
]
73
:
[
function
(
require
module
exports
)
{
var
funcTag
=
'
[
object
Function
]
'
;
var
reIsHostCtor
=
/
^
\
[
object
.
+
?
Constructor
\
]
/
;
function
isObjectLike
(
value
)
{
return
!
!
value
&
&
typeof
value
=
=
'
object
'
;
}
var
objectProto
=
Object
.
prototype
;
var
fnToString
=
Function
.
prototype
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
objToString
=
objectProto
.
toString
;
var
reIsNative
=
RegExp
(
'
^
'
+
fnToString
.
call
(
hasOwnProperty
)
.
replace
(
/
[
\
\
^
.
*
+
?
(
)
[
\
]
{
}
|
]
/
g
'
\
\
&
'
)
.
replace
(
/
hasOwnProperty
|
(
function
)
.
*
?
(
?
=
\
\
\
(
)
|
for
.
+
?
(
?
=
\
\
\
]
)
/
g
'
1
.
*
?
'
)
+
'
'
)
;
function
getNative
(
object
key
)
{
var
value
=
object
=
=
null
?
undefined
:
object
[
key
]
;
return
isNative
(
value
)
?
value
:
undefined
;
}
function
isFunction
(
value
)
{
return
isObject
(
value
)
&
&
objToString
.
call
(
value
)
=
=
funcTag
;
}
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
function
isNative
(
value
)
{
if
(
value
=
=
null
)
{
return
false
;
}
if
(
isFunction
(
value
)
)
{
return
reIsNative
.
test
(
fnToString
.
call
(
value
)
)
;
}
return
isObjectLike
(
value
)
&
&
reIsHostCtor
.
test
(
value
)
;
}
module
.
exports
=
getNative
;
}
{
}
]
74
:
[
function
(
require
module
exports
)
{
var
reIsUint
=
/
^
\
d
+
/
;
var
MAX_SAFE_INTEGER
=
9007199254740991
;
function
baseProperty
(
key
)
{
return
function
(
object
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
;
}
var
getLength
=
baseProperty
(
'
length
'
)
;
function
isArrayLike
(
value
)
{
return
value
!
=
null
&
&
isLength
(
getLength
(
value
)
)
;
}
function
isIndex
(
value
length
)
{
value
=
(
typeof
value
=
=
'
number
'
|
|
reIsUint
.
test
(
value
)
)
?
+
value
:
-
1
;
length
=
length
=
=
null
?
MAX_SAFE_INTEGER
:
length
;
return
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
length
;
}
function
isIterateeCall
(
value
index
object
)
{
if
(
!
isObject
(
object
)
)
{
return
false
;
}
var
type
=
typeof
index
;
if
(
type
=
=
'
number
'
?
(
isArrayLike
(
object
)
&
&
isIndex
(
index
object
.
length
)
)
:
(
type
=
=
'
string
'
&
&
index
in
object
)
)
{
var
other
=
object
[
index
]
;
return
value
=
=
=
value
?
(
value
=
=
=
other
)
:
(
other
!
=
=
other
)
;
}
return
false
;
}
function
isLength
(
value
)
{
return
typeof
value
=
=
'
number
'
&
&
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
=
MAX_SAFE_INTEGER
;
}
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
module
.
exports
=
isIterateeCall
;
}
{
}
]
75
:
[
function
(
require
module
exports
)
{
var
baseAssign
=
require
(
'
lodash
.
_baseassign
'
)
baseCreate
=
require
(
'
lodash
.
_basecreate
'
)
isIterateeCall
=
require
(
'
lodash
.
_isiterateecall
'
)
;
function
create
(
prototype
properties
guard
)
{
var
result
=
baseCreate
(
prototype
)
;
if
(
guard
&
&
isIterateeCall
(
prototype
properties
guard
)
)
{
properties
=
undefined
;
}
return
properties
?
baseAssign
(
result
properties
)
:
result
;
}
module
.
exports
=
create
;
}
{
"
lodash
.
_baseassign
"
:
70
"
lodash
.
_basecreate
"
:
72
"
lodash
.
_isiterateecall
"
:
74
}
]
76
:
[
function
(
require
module
exports
)
{
var
MAX_SAFE_INTEGER
=
9007199254740991
;
var
argsTag
=
'
[
object
Arguments
]
'
funcTag
=
'
[
object
Function
]
'
genTag
=
'
[
object
GeneratorFunction
]
'
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
objectToString
=
objectProto
.
toString
;
var
propertyIsEnumerable
=
objectProto
.
propertyIsEnumerable
;
function
isArguments
(
value
)
{
return
isArrayLikeObject
(
value
)
&
&
hasOwnProperty
.
call
(
value
'
callee
'
)
&
&
(
!
propertyIsEnumerable
.
call
(
value
'
callee
'
)
|
|
objectToString
.
call
(
value
)
=
=
argsTag
)
;
}
function
isArrayLike
(
value
)
{
return
value
!
=
null
&
&
isLength
(
value
.
length
)
&
&
!
isFunction
(
value
)
;
}
function
isArrayLikeObject
(
value
)
{
return
isObjectLike
(
value
)
&
&
isArrayLike
(
value
)
;
}
function
isFunction
(
value
)
{
var
tag
=
isObject
(
value
)
?
objectToString
.
call
(
value
)
:
'
'
;
return
tag
=
=
funcTag
|
|
tag
=
=
genTag
;
}
function
isLength
(
value
)
{
return
typeof
value
=
=
'
number
'
&
&
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
=
MAX_SAFE_INTEGER
;
}
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
function
isObjectLike
(
value
)
{
return
!
!
value
&
&
typeof
value
=
=
'
object
'
;
}
module
.
exports
=
isArguments
;
}
{
}
]
77
:
[
function
(
require
module
exports
)
{
var
arrayTag
=
'
[
object
Array
]
'
funcTag
=
'
[
object
Function
]
'
;
var
reIsHostCtor
=
/
^
\
[
object
.
+
?
Constructor
\
]
/
;
function
isObjectLike
(
value
)
{
return
!
!
value
&
&
typeof
value
=
=
'
object
'
;
}
var
objectProto
=
Object
.
prototype
;
var
fnToString
=
Function
.
prototype
.
toString
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
objToString
=
objectProto
.
toString
;
var
reIsNative
=
RegExp
(
'
^
'
+
fnToString
.
call
(
hasOwnProperty
)
.
replace
(
/
[
\
\
^
.
*
+
?
(
)
[
\
]
{
}
|
]
/
g
'
\
\
&
'
)
.
replace
(
/
hasOwnProperty
|
(
function
)
.
*
?
(
?
=
\
\
\
(
)
|
for
.
+
?
(
?
=
\
\
\
]
)
/
g
'
1
.
*
?
'
)
+
'
'
)
;
var
nativeIsArray
=
getNative
(
Array
'
isArray
'
)
;
var
MAX_SAFE_INTEGER
=
9007199254740991
;
function
getNative
(
object
key
)
{
var
value
=
object
=
=
null
?
undefined
:
object
[
key
]
;
return
isNative
(
value
)
?
value
:
undefined
;
}
function
isLength
(
value
)
{
return
typeof
value
=
=
'
number
'
&
&
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
=
MAX_SAFE_INTEGER
;
}
var
isArray
=
nativeIsArray
|
|
function
(
value
)
{
return
isObjectLike
(
value
)
&
&
isLength
(
value
.
length
)
&
&
objToString
.
call
(
value
)
=
=
arrayTag
;
}
;
function
isFunction
(
value
)
{
return
isObject
(
value
)
&
&
objToString
.
call
(
value
)
=
=
funcTag
;
}
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
function
isNative
(
value
)
{
if
(
value
=
=
null
)
{
return
false
;
}
if
(
isFunction
(
value
)
)
{
return
reIsNative
.
test
(
fnToString
.
call
(
value
)
)
;
}
return
isObjectLike
(
value
)
&
&
reIsHostCtor
.
test
(
value
)
;
}
module
.
exports
=
isArray
;
}
{
}
]
78
:
[
function
(
require
module
exports
)
{
var
getNative
=
require
(
'
lodash
.
_getnative
'
)
isArguments
=
require
(
'
lodash
.
isarguments
'
)
isArray
=
require
(
'
lodash
.
isarray
'
)
;
var
reIsUint
=
/
^
\
d
+
/
;
var
objectProto
=
Object
.
prototype
;
var
hasOwnProperty
=
objectProto
.
hasOwnProperty
;
var
nativeKeys
=
getNative
(
Object
'
keys
'
)
;
var
MAX_SAFE_INTEGER
=
9007199254740991
;
function
baseProperty
(
key
)
{
return
function
(
object
)
{
return
object
=
=
null
?
undefined
:
object
[
key
]
;
}
;
}
var
getLength
=
baseProperty
(
'
length
'
)
;
function
isArrayLike
(
value
)
{
return
value
!
=
null
&
&
isLength
(
getLength
(
value
)
)
;
}
function
isIndex
(
value
length
)
{
value
=
(
typeof
value
=
=
'
number
'
|
|
reIsUint
.
test
(
value
)
)
?
+
value
:
-
1
;
length
=
length
=
=
null
?
MAX_SAFE_INTEGER
:
length
;
return
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
length
;
}
function
isLength
(
value
)
{
return
typeof
value
=
=
'
number
'
&
&
value
>
-
1
&
&
value
%
1
=
=
0
&
&
value
<
=
MAX_SAFE_INTEGER
;
}
function
shimKeys
(
object
)
{
var
props
=
keysIn
(
object
)
propsLength
=
props
.
length
length
=
propsLength
&
&
object
.
length
;
var
allowIndexes
=
!
!
length
&
&
isLength
(
length
)
&
&
(
isArray
(
object
)
|
|
isArguments
(
object
)
)
;
var
index
=
-
1
result
=
[
]
;
while
(
+
+
index
<
propsLength
)
{
var
key
=
props
[
index
]
;
if
(
(
allowIndexes
&
&
isIndex
(
key
length
)
)
|
|
hasOwnProperty
.
call
(
object
key
)
)
{
result
.
push
(
key
)
;
}
}
return
result
;
}
function
isObject
(
value
)
{
var
type
=
typeof
value
;
return
!
!
value
&
&
(
type
=
=
'
object
'
|
|
type
=
=
'
function
'
)
;
}
var
keys
=
!
nativeKeys
?
shimKeys
:
function
(
object
)
{
var
Ctor
=
object
=
=
null
?
undefined
:
object
.
constructor
;
if
(
(
typeof
Ctor
=
=
'
function
'
&
&
Ctor
.
prototype
=
=
=
object
)
|
|
(
typeof
object
!
=
'
function
'
&
&
isArrayLike
(
object
)
)
)
{
return
shimKeys
(
object
)
;
}
return
isObject
(
object
)
?
nativeKeys
(
object
)
:
[
]
;
}
;
function
keysIn
(
object
)
{
if
(
object
=
=
null
)
{
return
[
]
;
}
if
(
!
isObject
(
object
)
)
{
object
=
Object
(
object
)
;
}
var
length
=
object
.
length
;
length
=
(
length
&
&
isLength
(
length
)
&
&
(
isArray
(
object
)
|
|
isArguments
(
object
)
)
&
&
length
)
|
|
0
;
var
Ctor
=
object
.
constructor
index
=
-
1
isProto
=
typeof
Ctor
=
=
'
function
'
&
&
Ctor
.
prototype
=
=
=
object
result
=
Array
(
length
)
skipIndexes
=
length
>
0
;
while
(
+
+
index
<
length
)
{
result
[
index
]
=
(
index
+
'
'
)
;
}
for
(
var
key
in
object
)
{
if
(
!
(
skipIndexes
&
&
isIndex
(
key
length
)
)
&
&
!
(
key
=
=
'
constructor
'
&
&
(
isProto
|
|
!
hasOwnProperty
.
call
(
object
key
)
)
)
)
{
result
.
push
(
key
)
;
}
}
return
result
;
}
module
.
exports
=
keys
;
}
{
"
lodash
.
_getnative
"
:
73
"
lodash
.
isarguments
"
:
76
"
lodash
.
isarray
"
:
77
}
]
79
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
var
path
=
require
(
'
path
'
)
;
var
fs
=
require
(
'
fs
'
)
;
var
_0777
=
parseInt
(
'
0777
'
8
)
;
module
.
exports
=
mkdirP
.
mkdirp
=
mkdirP
.
mkdirP
=
mkdirP
;
function
mkdirP
(
p
opts
f
made
)
{
if
(
typeof
opts
=
=
=
'
function
'
)
{
f
=
opts
;
opts
=
{
}
;
}
else
if
(
!
opts
|
|
typeof
opts
!
=
=
'
object
'
)
{
opts
=
{
mode
:
opts
}
;
}
var
mode
=
opts
.
mode
;
var
xfs
=
opts
.
fs
|
|
fs
;
if
(
mode
=
=
=
undefined
)
{
mode
=
_0777
&
(
~
process
.
umask
(
)
)
;
}
if
(
!
made
)
made
=
null
;
var
cb
=
f
|
|
function
(
)
{
}
;
p
=
path
.
resolve
(
p
)
;
xfs
.
mkdir
(
p
mode
function
(
er
)
{
if
(
!
er
)
{
made
=
made
|
|
p
;
return
cb
(
null
made
)
;
}
switch
(
er
.
code
)
{
case
'
ENOENT
'
:
mkdirP
(
path
.
dirname
(
p
)
opts
function
(
er
made
)
{
if
(
er
)
cb
(
er
made
)
;
else
mkdirP
(
p
opts
cb
made
)
;
}
)
;
break
;
default
:
xfs
.
stat
(
p
function
(
er2
stat
)
{
if
(
er2
|
|
!
stat
.
isDirectory
(
)
)
cb
(
er
made
)
else
cb
(
null
made
)
;
}
)
;
break
;
}
}
)
;
}
mkdirP
.
sync
=
function
sync
(
p
opts
made
)
{
if
(
!
opts
|
|
typeof
opts
!
=
=
'
object
'
)
{
opts
=
{
mode
:
opts
}
;
}
var
mode
=
opts
.
mode
;
var
xfs
=
opts
.
fs
|
|
fs
;
if
(
mode
=
=
=
undefined
)
{
mode
=
_0777
&
(
~
process
.
umask
(
)
)
;
}
if
(
!
made
)
made
=
null
;
p
=
path
.
resolve
(
p
)
;
try
{
xfs
.
mkdirSync
(
p
mode
)
;
made
=
made
|
|
p
;
}
catch
(
err0
)
{
switch
(
err0
.
code
)
{
case
'
ENOENT
'
:
made
=
sync
(
path
.
dirname
(
p
)
opts
made
)
;
sync
(
p
opts
made
)
;
break
;
default
:
var
stat
;
try
{
stat
=
xfs
.
statSync
(
p
)
;
}
catch
(
err1
)
{
throw
err0
;
}
if
(
!
stat
.
isDirectory
(
)
)
throw
err0
;
break
;
}
}
return
made
;
}
;
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
_process
"
:
82
"
fs
"
:
42
"
path
"
:
42
}
]
80
:
[
function
(
require
module
exports
)
{
exports
.
endianness
=
function
(
)
{
return
'
LE
'
}
;
exports
.
hostname
=
function
(
)
{
if
(
typeof
location
!
=
=
'
undefined
'
)
{
return
location
.
hostname
}
else
return
'
'
;
}
;
exports
.
loadavg
=
function
(
)
{
return
[
]
}
;
exports
.
uptime
=
function
(
)
{
return
0
}
;
exports
.
freemem
=
function
(
)
{
return
Number
.
MAX_VALUE
;
}
;
exports
.
totalmem
=
function
(
)
{
return
Number
.
MAX_VALUE
;
}
;
exports
.
cpus
=
function
(
)
{
return
[
]
}
;
exports
.
type
=
function
(
)
{
return
'
Browser
'
}
;
exports
.
release
=
function
(
)
{
if
(
typeof
navigator
!
=
=
'
undefined
'
)
{
return
navigator
.
appVersion
;
}
return
'
'
;
}
;
exports
.
networkInterfaces
=
exports
.
getNetworkInterfaces
=
function
(
)
{
return
{
}
}
;
exports
.
arch
=
function
(
)
{
return
'
javascript
'
}
;
exports
.
platform
=
function
(
)
{
return
'
browser
'
}
;
exports
.
tmpdir
=
exports
.
tmpDir
=
function
(
)
{
return
'
/
tmp
'
;
}
;
exports
.
EOL
=
'
\
n
'
;
}
{
}
]
81
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
if
(
!
process
.
version
|
|
process
.
version
.
indexOf
(
'
v0
.
'
)
=
=
=
0
|
|
process
.
version
.
indexOf
(
'
v1
.
'
)
=
=
=
0
&
&
process
.
version
.
indexOf
(
'
v1
.
8
.
'
)
!
=
=
0
)
{
module
.
exports
=
nextTick
;
}
else
{
module
.
exports
=
process
.
nextTick
;
}
function
nextTick
(
fn
arg1
arg2
arg3
)
{
if
(
typeof
fn
!
=
=
'
function
'
)
{
throw
new
TypeError
(
'
"
callback
"
argument
must
be
a
function
'
)
;
}
var
len
=
arguments
.
length
;
var
args
i
;
switch
(
len
)
{
case
0
:
case
1
:
return
process
.
nextTick
(
fn
)
;
case
2
:
return
process
.
nextTick
(
function
afterTickOne
(
)
{
fn
.
call
(
null
arg1
)
;
}
)
;
case
3
:
return
process
.
nextTick
(
function
afterTickTwo
(
)
{
fn
.
call
(
null
arg1
arg2
)
;
}
)
;
case
4
:
return
process
.
nextTick
(
function
afterTickThree
(
)
{
fn
.
call
(
null
arg1
arg2
arg3
)
;
}
)
;
default
:
args
=
new
Array
(
len
-
1
)
;
i
=
0
;
while
(
i
<
args
.
length
)
{
args
[
i
+
+
]
=
arguments
[
i
]
;
}
return
process
.
nextTick
(
function
afterTick
(
)
{
fn
.
apply
(
null
args
)
;
}
)
;
}
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
_process
"
:
82
}
]
82
:
[
function
(
require
module
exports
)
{
var
process
=
module
.
exports
=
{
}
;
var
cachedSetTimeout
;
var
cachedClearTimeout
;
function
defaultSetTimout
(
)
{
throw
new
Error
(
'
setTimeout
has
not
been
defined
'
)
;
}
function
defaultClearTimeout
(
)
{
throw
new
Error
(
'
clearTimeout
has
not
been
defined
'
)
;
}
(
function
(
)
{
try
{
if
(
typeof
setTimeout
=
=
=
'
function
'
)
{
cachedSetTimeout
=
setTimeout
;
}
else
{
cachedSetTimeout
=
defaultSetTimout
;
}
}
catch
(
e
)
{
cachedSetTimeout
=
defaultSetTimout
;
}
try
{
if
(
typeof
clearTimeout
=
=
=
'
function
'
)
{
cachedClearTimeout
=
clearTimeout
;
}
else
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
catch
(
e
)
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
(
)
)
function
runTimeout
(
fun
)
{
if
(
cachedSetTimeout
=
=
=
setTimeout
)
{
return
setTimeout
(
fun
0
)
;
}
if
(
(
cachedSetTimeout
=
=
=
defaultSetTimout
|
|
!
cachedSetTimeout
)
&
&
setTimeout
)
{
cachedSetTimeout
=
setTimeout
;
return
setTimeout
(
fun
0
)
;
}
try
{
return
cachedSetTimeout
(
fun
0
)
;
}
catch
(
e
)
{
try
{
return
cachedSetTimeout
.
call
(
null
fun
0
)
;
}
catch
(
e
)
{
return
cachedSetTimeout
.
call
(
this
fun
0
)
;
}
}
}
function
runClearTimeout
(
marker
)
{
if
(
cachedClearTimeout
=
=
=
clearTimeout
)
{
return
clearTimeout
(
marker
)
;
}
if
(
(
cachedClearTimeout
=
=
=
defaultClearTimeout
|
|
!
cachedClearTimeout
)
&
&
clearTimeout
)
{
cachedClearTimeout
=
clearTimeout
;
return
clearTimeout
(
marker
)
;
}
try
{
return
cachedClearTimeout
(
marker
)
;
}
catch
(
e
)
{
try
{
return
cachedClearTimeout
.
call
(
null
marker
)
;
}
catch
(
e
)
{
return
cachedClearTimeout
.
call
(
this
marker
)
;
}
}
}
var
queue
=
[
]
;
var
draining
=
false
;
var
currentQueue
;
var
queueIndex
=
-
1
;
function
cleanUpNextTick
(
)
{
if
(
!
draining
|
|
!
currentQueue
)
{
return
;
}
draining
=
false
;
if
(
currentQueue
.
length
)
{
queue
=
currentQueue
.
concat
(
queue
)
;
}
else
{
queueIndex
=
-
1
;
}
if
(
queue
.
length
)
{
drainQueue
(
)
;
}
}
function
drainQueue
(
)
{
if
(
draining
)
{
return
;
}
var
timeout
=
runTimeout
(
cleanUpNextTick
)
;
draining
=
true
;
var
len
=
queue
.
length
;
while
(
len
)
{
currentQueue
=
queue
;
queue
=
[
]
;
while
(
+
+
queueIndex
<
len
)
{
if
(
currentQueue
)
{
currentQueue
[
queueIndex
]
.
run
(
)
;
}
}
queueIndex
=
-
1
;
len
=
queue
.
length
;
}
currentQueue
=
null
;
draining
=
false
;
runClearTimeout
(
timeout
)
;
}
process
.
nextTick
=
function
(
fun
)
{
var
args
=
new
Array
(
arguments
.
length
-
1
)
;
if
(
arguments
.
length
>
1
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
}
queue
.
push
(
new
Item
(
fun
args
)
)
;
if
(
queue
.
length
=
=
=
1
&
&
!
draining
)
{
runTimeout
(
drainQueue
)
;
}
}
;
function
Item
(
fun
array
)
{
this
.
fun
=
fun
;
this
.
array
=
array
;
}
Item
.
prototype
.
run
=
function
(
)
{
this
.
fun
.
apply
(
null
this
.
array
)
;
}
;
process
.
title
=
'
browser
'
;
process
.
browser
=
true
;
process
.
env
=
{
}
;
process
.
argv
=
[
]
;
process
.
version
=
'
'
;
process
.
versions
=
{
}
;
function
noop
(
)
{
}
process
.
on
=
noop
;
process
.
addListener
=
noop
;
process
.
once
=
noop
;
process
.
off
=
noop
;
process
.
removeListener
=
noop
;
process
.
removeAllListeners
=
noop
;
process
.
emit
=
noop
;
process
.
binding
=
function
(
name
)
{
throw
new
Error
(
'
process
.
binding
is
not
supported
'
)
;
}
;
process
.
cwd
=
function
(
)
{
return
'
/
'
}
;
process
.
chdir
=
function
(
dir
)
{
throw
new
Error
(
'
process
.
chdir
is
not
supported
'
)
;
}
;
process
.
umask
=
function
(
)
{
return
0
;
}
;
}
{
}
]
83
:
[
function
(
require
module
exports
)
{
module
.
exports
=
require
(
"
.
/
lib
/
_stream_duplex
.
js
"
)
}
{
"
.
/
lib
/
_stream_duplex
.
js
"
:
84
}
]
84
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
objectKeys
=
Object
.
keys
|
|
function
(
obj
)
{
var
keys
=
[
]
;
for
(
var
key
in
obj
)
{
keys
.
push
(
key
)
;
}
return
keys
;
}
;
module
.
exports
=
Duplex
;
var
processNextTick
=
require
(
'
process
-
nextick
-
args
'
)
;
var
util
=
require
(
'
core
-
util
-
is
'
)
;
util
.
inherits
=
require
(
'
inherits
'
)
;
var
Readable
=
require
(
'
.
/
_stream_readable
'
)
;
var
Writable
=
require
(
'
.
/
_stream_writable
'
)
;
util
.
inherits
(
Duplex
Readable
)
;
var
keys
=
objectKeys
(
Writable
.
prototype
)
;
for
(
var
v
=
0
;
v
<
keys
.
length
;
v
+
+
)
{
var
method
=
keys
[
v
]
;
if
(
!
Duplex
.
prototype
[
method
]
)
Duplex
.
prototype
[
method
]
=
Writable
.
prototype
[
method
]
;
}
function
Duplex
(
options
)
{
if
(
!
(
this
instanceof
Duplex
)
)
return
new
Duplex
(
options
)
;
Readable
.
call
(
this
options
)
;
Writable
.
call
(
this
options
)
;
if
(
options
&
&
options
.
readable
=
=
=
false
)
this
.
readable
=
false
;
if
(
options
&
&
options
.
writable
=
=
=
false
)
this
.
writable
=
false
;
this
.
allowHalfOpen
=
true
;
if
(
options
&
&
options
.
allowHalfOpen
=
=
=
false
)
this
.
allowHalfOpen
=
false
;
this
.
once
(
'
end
'
onend
)
;
}
function
onend
(
)
{
if
(
this
.
allowHalfOpen
|
|
this
.
_writableState
.
ended
)
return
;
processNextTick
(
onEndNT
this
)
;
}
function
onEndNT
(
self
)
{
self
.
end
(
)
;
}
function
forEach
(
xs
f
)
{
for
(
var
i
=
0
l
=
xs
.
length
;
i
<
l
;
i
+
+
)
{
f
(
xs
[
i
]
i
)
;
}
}
}
{
"
.
/
_stream_readable
"
:
86
"
.
/
_stream_writable
"
:
88
"
core
-
util
-
is
"
:
45
"
inherits
"
:
66
"
process
-
nextick
-
args
"
:
81
}
]
85
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
PassThrough
;
var
Transform
=
require
(
'
.
/
_stream_transform
'
)
;
var
util
=
require
(
'
core
-
util
-
is
'
)
;
util
.
inherits
=
require
(
'
inherits
'
)
;
util
.
inherits
(
PassThrough
Transform
)
;
function
PassThrough
(
options
)
{
if
(
!
(
this
instanceof
PassThrough
)
)
return
new
PassThrough
(
options
)
;
Transform
.
call
(
this
options
)
;
}
PassThrough
.
prototype
.
_transform
=
function
(
chunk
encoding
cb
)
{
cb
(
null
chunk
)
;
}
;
}
{
"
.
/
_stream_transform
"
:
87
"
core
-
util
-
is
"
:
45
"
inherits
"
:
66
}
]
86
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
module
.
exports
=
Readable
;
var
processNextTick
=
require
(
'
process
-
nextick
-
args
'
)
;
var
isArray
=
require
(
'
isarray
'
)
;
Readable
.
ReadableState
=
ReadableState
;
var
EE
=
require
(
'
events
'
)
.
EventEmitter
;
var
EElistenerCount
=
function
(
emitter
type
)
{
return
emitter
.
listeners
(
type
)
.
length
;
}
;
var
Stream
;
(
function
(
)
{
try
{
Stream
=
require
(
'
st
'
+
'
ream
'
)
;
}
catch
(
_
)
{
}
finally
{
if
(
!
Stream
)
Stream
=
require
(
'
events
'
)
.
EventEmitter
;
}
}
)
(
)
;
var
Buffer
=
require
(
'
buffer
'
)
.
Buffer
;
var
bufferShim
=
require
(
'
buffer
-
shims
'
)
;
var
util
=
require
(
'
core
-
util
-
is
'
)
;
util
.
inherits
=
require
(
'
inherits
'
)
;
var
debugUtil
=
require
(
'
util
'
)
;
var
debug
=
void
0
;
if
(
debugUtil
&
&
debugUtil
.
debuglog
)
{
debug
=
debugUtil
.
debuglog
(
'
stream
'
)
;
}
else
{
debug
=
function
(
)
{
}
;
}
var
BufferList
=
require
(
'
.
/
internal
/
streams
/
BufferList
'
)
;
var
StringDecoder
;
util
.
inherits
(
Readable
Stream
)
;
function
prependListener
(
emitter
event
fn
)
{
if
(
typeof
emitter
.
prependListener
=
=
=
'
function
'
)
{
return
emitter
.
prependListener
(
event
fn
)
;
}
else
{
if
(
!
emitter
.
_events
|
|
!
emitter
.
_events
[
event
]
)
emitter
.
on
(
event
fn
)
;
else
if
(
isArray
(
emitter
.
_events
[
event
]
)
)
emitter
.
_events
[
event
]
.
unshift
(
fn
)
;
else
emitter
.
_events
[
event
]
=
[
fn
emitter
.
_events
[
event
]
]
;
}
}
var
Duplex
;
function
ReadableState
(
options
stream
)
{
Duplex
=
Duplex
|
|
require
(
'
.
/
_stream_duplex
'
)
;
options
=
options
|
|
{
}
;
this
.
objectMode
=
!
!
options
.
objectMode
;
if
(
stream
instanceof
Duplex
)
this
.
objectMode
=
this
.
objectMode
|
|
!
!
options
.
readableObjectMode
;
var
hwm
=
options
.
highWaterMark
;
var
defaultHwm
=
this
.
objectMode
?
16
:
16
*
1024
;
this
.
highWaterMark
=
hwm
|
|
hwm
=
=
=
0
?
hwm
:
defaultHwm
;
this
.
highWaterMark
=
~
~
this
.
highWaterMark
;
this
.
buffer
=
new
BufferList
(
)
;
this
.
length
=
0
;
this
.
pipes
=
null
;
this
.
pipesCount
=
0
;
this
.
flowing
=
null
;
this
.
ended
=
false
;
this
.
endEmitted
=
false
;
this
.
reading
=
false
;
this
.
sync
=
true
;
this
.
needReadable
=
false
;
this
.
emittedReadable
=
false
;
this
.
readableListening
=
false
;
this
.
resumeScheduled
=
false
;
this
.
defaultEncoding
=
options
.
defaultEncoding
|
|
'
utf8
'
;
this
.
ranOut
=
false
;
this
.
awaitDrain
=
0
;
this
.
readingMore
=
false
;
this
.
decoder
=
null
;
this
.
encoding
=
null
;
if
(
options
.
encoding
)
{
if
(
!
StringDecoder
)
StringDecoder
=
require
(
'
string_decoder
/
'
)
.
StringDecoder
;
this
.
decoder
=
new
StringDecoder
(
options
.
encoding
)
;
this
.
encoding
=
options
.
encoding
;
}
}
var
Duplex
;
function
Readable
(
options
)
{
Duplex
=
Duplex
|
|
require
(
'
.
/
_stream_duplex
'
)
;
if
(
!
(
this
instanceof
Readable
)
)
return
new
Readable
(
options
)
;
this
.
_readableState
=
new
ReadableState
(
options
this
)
;
this
.
readable
=
true
;
if
(
options
&
&
typeof
options
.
read
=
=
=
'
function
'
)
this
.
_read
=
options
.
read
;
Stream
.
call
(
this
)
;
}
Readable
.
prototype
.
push
=
function
(
chunk
encoding
)
{
var
state
=
this
.
_readableState
;
if
(
!
state
.
objectMode
&
&
typeof
chunk
=
=
=
'
string
'
)
{
encoding
=
encoding
|
|
state
.
defaultEncoding
;
if
(
encoding
!
=
=
state
.
encoding
)
{
chunk
=
bufferShim
.
from
(
chunk
encoding
)
;
encoding
=
'
'
;
}
}
return
readableAddChunk
(
this
state
chunk
encoding
false
)
;
}
;
Readable
.
prototype
.
unshift
=
function
(
chunk
)
{
var
state
=
this
.
_readableState
;
return
readableAddChunk
(
this
state
chunk
'
'
true
)
;
}
;
Readable
.
prototype
.
isPaused
=
function
(
)
{
return
this
.
_readableState
.
flowing
=
=
=
false
;
}
;
function
readableAddChunk
(
stream
state
chunk
encoding
addToFront
)
{
var
er
=
chunkInvalid
(
state
chunk
)
;
if
(
er
)
{
stream
.
emit
(
'
error
'
er
)
;
}
else
if
(
chunk
=
=
=
null
)
{
state
.
reading
=
false
;
onEofChunk
(
stream
state
)
;
}
else
if
(
state
.
objectMode
|
|
chunk
&
&
chunk
.
length
>
0
)
{
if
(
state
.
ended
&
&
!
addToFront
)
{
var
e
=
new
Error
(
'
stream
.
push
(
)
after
EOF
'
)
;
stream
.
emit
(
'
error
'
e
)
;
}
else
if
(
state
.
endEmitted
&
&
addToFront
)
{
var
_e
=
new
Error
(
'
stream
.
unshift
(
)
after
end
event
'
)
;
stream
.
emit
(
'
error
'
_e
)
;
}
else
{
var
skipAdd
;
if
(
state
.
decoder
&
&
!
addToFront
&
&
!
encoding
)
{
chunk
=
state
.
decoder
.
write
(
chunk
)
;
skipAdd
=
!
state
.
objectMode
&
&
chunk
.
length
=
=
=
0
;
}
if
(
!
addToFront
)
state
.
reading
=
false
;
if
(
!
skipAdd
)
{
if
(
state
.
flowing
&
&
state
.
length
=
=
=
0
&
&
!
state
.
sync
)
{
stream
.
emit
(
'
data
'
chunk
)
;
stream
.
read
(
0
)
;
}
else
{
state
.
length
+
=
state
.
objectMode
?
1
:
chunk
.
length
;
if
(
addToFront
)
state
.
buffer
.
unshift
(
chunk
)
;
else
state
.
buffer
.
push
(
chunk
)
;
if
(
state
.
needReadable
)
emitReadable
(
stream
)
;
}
}
maybeReadMore
(
stream
state
)
;
}
}
else
if
(
!
addToFront
)
{
state
.
reading
=
false
;
}
return
needMoreData
(
state
)
;
}
function
needMoreData
(
state
)
{
return
!
state
.
ended
&
&
(
state
.
needReadable
|
|
state
.
length
<
state
.
highWaterMark
|
|
state
.
length
=
=
=
0
)
;
}
Readable
.
prototype
.
setEncoding
=
function
(
enc
)
{
if
(
!
StringDecoder
)
StringDecoder
=
require
(
'
string_decoder
/
'
)
.
StringDecoder
;
this
.
_readableState
.
decoder
=
new
StringDecoder
(
enc
)
;
this
.
_readableState
.
encoding
=
enc
;
return
this
;
}
;
var
MAX_HWM
=
0x800000
;
function
computeNewHighWaterMark
(
n
)
{
if
(
n
>
=
MAX_HWM
)
{
n
=
MAX_HWM
;
}
else
{
n
-
-
;
n
|
=
n
>
>
>
1
;
n
|
=
n
>
>
>
2
;
n
|
=
n
>
>
>
4
;
n
|
=
n
>
>
>
8
;
n
|
=
n
>
>
>
16
;
n
+
+
;
}
return
n
;
}
function
howMuchToRead
(
n
state
)
{
if
(
n
<
=
0
|
|
state
.
length
=
=
=
0
&
&
state
.
ended
)
return
0
;
if
(
state
.
objectMode
)
return
1
;
if
(
n
!
=
=
n
)
{
if
(
state
.
flowing
&
&
state
.
length
)
return
state
.
buffer
.
head
.
data
.
length
;
else
return
state
.
length
;
}
if
(
n
>
state
.
highWaterMark
)
state
.
highWaterMark
=
computeNewHighWaterMark
(
n
)
;
if
(
n
<
=
state
.
length
)
return
n
;
if
(
!
state
.
ended
)
{
state
.
needReadable
=
true
;
return
0
;
}
return
state
.
length
;
}
Readable
.
prototype
.
read
=
function
(
n
)
{
debug
(
'
read
'
n
)
;
n
=
parseInt
(
n
10
)
;
var
state
=
this
.
_readableState
;
var
nOrig
=
n
;
if
(
n
!
=
=
0
)
state
.
emittedReadable
=
false
;
if
(
n
=
=
=
0
&
&
state
.
needReadable
&
&
(
state
.
length
>
=
state
.
highWaterMark
|
|
state
.
ended
)
)
{
debug
(
'
read
:
emitReadable
'
state
.
length
state
.
ended
)
;
if
(
state
.
length
=
=
=
0
&
&
state
.
ended
)
endReadable
(
this
)
;
else
emitReadable
(
this
)
;
return
null
;
}
n
=
howMuchToRead
(
n
state
)
;
if
(
n
=
=
=
0
&
&
state
.
ended
)
{
if
(
state
.
length
=
=
=
0
)
endReadable
(
this
)
;
return
null
;
}
var
doRead
=
state
.
needReadable
;
debug
(
'
need
readable
'
doRead
)
;
if
(
state
.
length
=
=
=
0
|
|
state
.
length
-
n
<
state
.
highWaterMark
)
{
doRead
=
true
;
debug
(
'
length
less
than
watermark
'
doRead
)
;
}
if
(
state
.
ended
|
|
state
.
reading
)
{
doRead
=
false
;
debug
(
'
reading
or
ended
'
doRead
)
;
}
else
if
(
doRead
)
{
debug
(
'
do
read
'
)
;
state
.
reading
=
true
;
state
.
sync
=
true
;
if
(
state
.
length
=
=
=
0
)
state
.
needReadable
=
true
;
this
.
_read
(
state
.
highWaterMark
)
;
state
.
sync
=
false
;
if
(
!
state
.
reading
)
n
=
howMuchToRead
(
nOrig
state
)
;
}
var
ret
;
if
(
n
>
0
)
ret
=
fromList
(
n
state
)
;
else
ret
=
null
;
if
(
ret
=
=
=
null
)
{
state
.
needReadable
=
true
;
n
=
0
;
}
else
{
state
.
length
-
=
n
;
}
if
(
state
.
length
=
=
=
0
)
{
if
(
!
state
.
ended
)
state
.
needReadable
=
true
;
if
(
nOrig
!
=
=
n
&
&
state
.
ended
)
endReadable
(
this
)
;
}
if
(
ret
!
=
=
null
)
this
.
emit
(
'
data
'
ret
)
;
return
ret
;
}
;
function
chunkInvalid
(
state
chunk
)
{
var
er
=
null
;
if
(
!
Buffer
.
isBuffer
(
chunk
)
&
&
typeof
chunk
!
=
=
'
string
'
&
&
chunk
!
=
=
null
&
&
chunk
!
=
=
undefined
&
&
!
state
.
objectMode
)
{
er
=
new
TypeError
(
'
Invalid
non
-
string
/
buffer
chunk
'
)
;
}
return
er
;
}
function
onEofChunk
(
stream
state
)
{
if
(
state
.
ended
)
return
;
if
(
state
.
decoder
)
{
var
chunk
=
state
.
decoder
.
end
(
)
;
if
(
chunk
&
&
chunk
.
length
)
{
state
.
buffer
.
push
(
chunk
)
;
state
.
length
+
=
state
.
objectMode
?
1
:
chunk
.
length
;
}
}
state
.
ended
=
true
;
emitReadable
(
stream
)
;
}
function
emitReadable
(
stream
)
{
var
state
=
stream
.
_readableState
;
state
.
needReadable
=
false
;
if
(
!
state
.
emittedReadable
)
{
debug
(
'
emitReadable
'
state
.
flowing
)
;
state
.
emittedReadable
=
true
;
if
(
state
.
sync
)
processNextTick
(
emitReadable_
stream
)
;
else
emitReadable_
(
stream
)
;
}
}
function
emitReadable_
(
stream
)
{
debug
(
'
emit
readable
'
)
;
stream
.
emit
(
'
readable
'
)
;
flow
(
stream
)
;
}
function
maybeReadMore
(
stream
state
)
{
if
(
!
state
.
readingMore
)
{
state
.
readingMore
=
true
;
processNextTick
(
maybeReadMore_
stream
state
)
;
}
}
function
maybeReadMore_
(
stream
state
)
{
var
len
=
state
.
length
;
while
(
!
state
.
reading
&
&
!
state
.
flowing
&
&
!
state
.
ended
&
&
state
.
length
<
state
.
highWaterMark
)
{
debug
(
'
maybeReadMore
read
0
'
)
;
stream
.
read
(
0
)
;
if
(
len
=
=
=
state
.
length
)
break
;
else
len
=
state
.
length
;
}
state
.
readingMore
=
false
;
}
Readable
.
prototype
.
_read
=
function
(
n
)
{
this
.
emit
(
'
error
'
new
Error
(
'
not
implemented
'
)
)
;
}
;
Readable
.
prototype
.
pipe
=
function
(
dest
pipeOpts
)
{
var
src
=
this
;
var
state
=
this
.
_readableState
;
switch
(
state
.
pipesCount
)
{
case
0
:
state
.
pipes
=
dest
;
break
;
case
1
:
state
.
pipes
=
[
state
.
pipes
dest
]
;
break
;
default
:
state
.
pipes
.
push
(
dest
)
;
break
;
}
state
.
pipesCount
+
=
1
;
debug
(
'
pipe
count
=
%
d
opts
=
%
j
'
state
.
pipesCount
pipeOpts
)
;
var
doEnd
=
(
!
pipeOpts
|
|
pipeOpts
.
end
!
=
=
false
)
&
&
dest
!
=
=
process
.
stdout
&
&
dest
!
=
=
process
.
stderr
;
var
endFn
=
doEnd
?
onend
:
cleanup
;
if
(
state
.
endEmitted
)
processNextTick
(
endFn
)
;
else
src
.
once
(
'
end
'
endFn
)
;
dest
.
on
(
'
unpipe
'
onunpipe
)
;
function
onunpipe
(
readable
)
{
debug
(
'
onunpipe
'
)
;
if
(
readable
=
=
=
src
)
{
cleanup
(
)
;
}
}
function
onend
(
)
{
debug
(
'
onend
'
)
;
dest
.
end
(
)
;
}
var
ondrain
=
pipeOnDrain
(
src
)
;
dest
.
on
(
'
drain
'
ondrain
)
;
var
cleanedUp
=
false
;
function
cleanup
(
)
{
debug
(
'
cleanup
'
)
;
dest
.
removeListener
(
'
close
'
onclose
)
;
dest
.
removeListener
(
'
finish
'
onfinish
)
;
dest
.
removeListener
(
'
drain
'
ondrain
)
;
dest
.
removeListener
(
'
error
'
onerror
)
;
dest
.
removeListener
(
'
unpipe
'
onunpipe
)
;
src
.
removeListener
(
'
end
'
onend
)
;
src
.
removeListener
(
'
end
'
cleanup
)
;
src
.
removeListener
(
'
data
'
ondata
)
;
cleanedUp
=
true
;
if
(
state
.
awaitDrain
&
&
(
!
dest
.
_writableState
|
|
dest
.
_writableState
.
needDrain
)
)
ondrain
(
)
;
}
var
increasedAwaitDrain
=
false
;
src
.
on
(
'
data
'
ondata
)
;
function
ondata
(
chunk
)
{
debug
(
'
ondata
'
)
;
increasedAwaitDrain
=
false
;
var
ret
=
dest
.
write
(
chunk
)
;
if
(
false
=
=
=
ret
&
&
!
increasedAwaitDrain
)
{
if
(
(
state
.
pipesCount
=
=
=
1
&
&
state
.
pipes
=
=
=
dest
|
|
state
.
pipesCount
>
1
&
&
indexOf
(
state
.
pipes
dest
)
!
=
=
-
1
)
&
&
!
cleanedUp
)
{
debug
(
'
false
write
response
pause
'
src
.
_readableState
.
awaitDrain
)
;
src
.
_readableState
.
awaitDrain
+
+
;
increasedAwaitDrain
=
true
;
}
src
.
pause
(
)
;
}
}
function
onerror
(
er
)
{
debug
(
'
onerror
'
er
)
;
unpipe
(
)
;
dest
.
removeListener
(
'
error
'
onerror
)
;
if
(
EElistenerCount
(
dest
'
error
'
)
=
=
=
0
)
dest
.
emit
(
'
error
'
er
)
;
}
prependListener
(
dest
'
error
'
onerror
)
;
function
onclose
(
)
{
dest
.
removeListener
(
'
finish
'
onfinish
)
;
unpipe
(
)
;
}
dest
.
once
(
'
close
'
onclose
)
;
function
onfinish
(
)
{
debug
(
'
onfinish
'
)
;
dest
.
removeListener
(
'
close
'
onclose
)
;
unpipe
(
)
;
}
dest
.
once
(
'
finish
'
onfinish
)
;
function
unpipe
(
)
{
debug
(
'
unpipe
'
)
;
src
.
unpipe
(
dest
)
;
}
dest
.
emit
(
'
pipe
'
src
)
;
if
(
!
state
.
flowing
)
{
debug
(
'
pipe
resume
'
)
;
src
.
resume
(
)
;
}
return
dest
;
}
;
function
pipeOnDrain
(
src
)
{
return
function
(
)
{
var
state
=
src
.
_readableState
;
debug
(
'
pipeOnDrain
'
state
.
awaitDrain
)
;
if
(
state
.
awaitDrain
)
state
.
awaitDrain
-
-
;
if
(
state
.
awaitDrain
=
=
=
0
&
&
EElistenerCount
(
src
'
data
'
)
)
{
state
.
flowing
=
true
;
flow
(
src
)
;
}
}
;
}
Readable
.
prototype
.
unpipe
=
function
(
dest
)
{
var
state
=
this
.
_readableState
;
if
(
state
.
pipesCount
=
=
=
0
)
return
this
;
if
(
state
.
pipesCount
=
=
=
1
)
{
if
(
dest
&
&
dest
!
=
=
state
.
pipes
)
return
this
;
if
(
!
dest
)
dest
=
state
.
pipes
;
state
.
pipes
=
null
;
state
.
pipesCount
=
0
;
state
.
flowing
=
false
;
if
(
dest
)
dest
.
emit
(
'
unpipe
'
this
)
;
return
this
;
}
if
(
!
dest
)
{
var
dests
=
state
.
pipes
;
var
len
=
state
.
pipesCount
;
state
.
pipes
=
null
;
state
.
pipesCount
=
0
;
state
.
flowing
=
false
;
for
(
var
_i
=
0
;
_i
<
len
;
_i
+
+
)
{
dests
[
_i
]
.
emit
(
'
unpipe
'
this
)
;
}
return
this
;
}
var
i
=
indexOf
(
state
.
pipes
dest
)
;
if
(
i
=
=
=
-
1
)
return
this
;
state
.
pipes
.
splice
(
i
1
)
;
state
.
pipesCount
-
=
1
;
if
(
state
.
pipesCount
=
=
=
1
)
state
.
pipes
=
state
.
pipes
[
0
]
;
dest
.
emit
(
'
unpipe
'
this
)
;
return
this
;
}
;
Readable
.
prototype
.
on
=
function
(
ev
fn
)
{
var
res
=
Stream
.
prototype
.
on
.
call
(
this
ev
fn
)
;
if
(
ev
=
=
=
'
data
'
)
{
if
(
this
.
_readableState
.
flowing
!
=
=
false
)
this
.
resume
(
)
;
}
else
if
(
ev
=
=
=
'
readable
'
)
{
var
state
=
this
.
_readableState
;
if
(
!
state
.
endEmitted
&
&
!
state
.
readableListening
)
{
state
.
readableListening
=
state
.
needReadable
=
true
;
state
.
emittedReadable
=
false
;
if
(
!
state
.
reading
)
{
processNextTick
(
nReadingNextTick
this
)
;
}
else
if
(
state
.
length
)
{
emitReadable
(
this
state
)
;
}
}
}
return
res
;
}
;
Readable
.
prototype
.
addListener
=
Readable
.
prototype
.
on
;
function
nReadingNextTick
(
self
)
{
debug
(
'
readable
nexttick
read
0
'
)
;
self
.
read
(
0
)
;
}
Readable
.
prototype
.
resume
=
function
(
)
{
var
state
=
this
.
_readableState
;
if
(
!
state
.
flowing
)
{
debug
(
'
resume
'
)
;
state
.
flowing
=
true
;
resume
(
this
state
)
;
}
return
this
;
}
;
function
resume
(
stream
state
)
{
if
(
!
state
.
resumeScheduled
)
{
state
.
resumeScheduled
=
true
;
processNextTick
(
resume_
stream
state
)
;
}
}
function
resume_
(
stream
state
)
{
if
(
!
state
.
reading
)
{
debug
(
'
resume
read
0
'
)
;
stream
.
read
(
0
)
;
}
state
.
resumeScheduled
=
false
;
state
.
awaitDrain
=
0
;
stream
.
emit
(
'
resume
'
)
;
flow
(
stream
)
;
if
(
state
.
flowing
&
&
!
state
.
reading
)
stream
.
read
(
0
)
;
}
Readable
.
prototype
.
pause
=
function
(
)
{
debug
(
'
call
pause
flowing
=
%
j
'
this
.
_readableState
.
flowing
)
;
if
(
false
!
=
=
this
.
_readableState
.
flowing
)
{
debug
(
'
pause
'
)
;
this
.
_readableState
.
flowing
=
false
;
this
.
emit
(
'
pause
'
)
;
}
return
this
;
}
;
function
flow
(
stream
)
{
var
state
=
stream
.
_readableState
;
debug
(
'
flow
'
state
.
flowing
)
;
while
(
state
.
flowing
&
&
stream
.
read
(
)
!
=
=
null
)
{
}
}
Readable
.
prototype
.
wrap
=
function
(
stream
)
{
var
state
=
this
.
_readableState
;
var
paused
=
false
;
var
self
=
this
;
stream
.
on
(
'
end
'
function
(
)
{
debug
(
'
wrapped
end
'
)
;
if
(
state
.
decoder
&
&
!
state
.
ended
)
{
var
chunk
=
state
.
decoder
.
end
(
)
;
if
(
chunk
&
&
chunk
.
length
)
self
.
push
(
chunk
)
;
}
self
.
push
(
null
)
;
}
)
;
stream
.
on
(
'
data
'
function
(
chunk
)
{
debug
(
'
wrapped
data
'
)
;
if
(
state
.
decoder
)
chunk
=
state
.
decoder
.
write
(
chunk
)
;
if
(
state
.
objectMode
&
&
(
chunk
=
=
=
null
|
|
chunk
=
=
=
undefined
)
)
return
;
else
if
(
!
state
.
objectMode
&
&
(
!
chunk
|
|
!
chunk
.
length
)
)
return
;
var
ret
=
self
.
push
(
chunk
)
;
if
(
!
ret
)
{
paused
=
true
;
stream
.
pause
(
)
;
}
}
)
;
for
(
var
i
in
stream
)
{
if
(
this
[
i
]
=
=
=
undefined
&
&
typeof
stream
[
i
]
=
=
=
'
function
'
)
{
this
[
i
]
=
function
(
method
)
{
return
function
(
)
{
return
stream
[
method
]
.
apply
(
stream
arguments
)
;
}
;
}
(
i
)
;
}
}
var
events
=
[
'
error
'
'
close
'
'
destroy
'
'
pause
'
'
resume
'
]
;
forEach
(
events
function
(
ev
)
{
stream
.
on
(
ev
self
.
emit
.
bind
(
self
ev
)
)
;
}
)
;
self
.
_read
=
function
(
n
)
{
debug
(
'
wrapped
_read
'
n
)
;
if
(
paused
)
{
paused
=
false
;
stream
.
resume
(
)
;
}
}
;
return
self
;
}
;
Readable
.
_fromList
=
fromList
;
function
fromList
(
n
state
)
{
if
(
state
.
length
=
=
=
0
)
return
null
;
var
ret
;
if
(
state
.
objectMode
)
ret
=
state
.
buffer
.
shift
(
)
;
else
if
(
!
n
|
|
n
>
=
state
.
length
)
{
if
(
state
.
decoder
)
ret
=
state
.
buffer
.
join
(
'
'
)
;
else
if
(
state
.
buffer
.
length
=
=
=
1
)
ret
=
state
.
buffer
.
head
.
data
;
else
ret
=
state
.
buffer
.
concat
(
state
.
length
)
;
state
.
buffer
.
clear
(
)
;
}
else
{
ret
=
fromListPartial
(
n
state
.
buffer
state
.
decoder
)
;
}
return
ret
;
}
function
fromListPartial
(
n
list
hasStrings
)
{
var
ret
;
if
(
n
<
list
.
head
.
data
.
length
)
{
ret
=
list
.
head
.
data
.
slice
(
0
n
)
;
list
.
head
.
data
=
list
.
head
.
data
.
slice
(
n
)
;
}
else
if
(
n
=
=
=
list
.
head
.
data
.
length
)
{
ret
=
list
.
shift
(
)
;
}
else
{
ret
=
hasStrings
?
copyFromBufferString
(
n
list
)
:
copyFromBuffer
(
n
list
)
;
}
return
ret
;
}
function
copyFromBufferString
(
n
list
)
{
var
p
=
list
.
head
;
var
c
=
1
;
var
ret
=
p
.
data
;
n
-
=
ret
.
length
;
while
(
p
=
p
.
next
)
{
var
str
=
p
.
data
;
var
nb
=
n
>
str
.
length
?
str
.
length
:
n
;
if
(
nb
=
=
=
str
.
length
)
ret
+
=
str
;
else
ret
+
=
str
.
slice
(
0
n
)
;
n
-
=
nb
;
if
(
n
=
=
=
0
)
{
if
(
nb
=
=
=
str
.
length
)
{
+
+
c
;
if
(
p
.
next
)
list
.
head
=
p
.
next
;
else
list
.
head
=
list
.
tail
=
null
;
}
else
{
list
.
head
=
p
;
p
.
data
=
str
.
slice
(
nb
)
;
}
break
;
}
+
+
c
;
}
list
.
length
-
=
c
;
return
ret
;
}
function
copyFromBuffer
(
n
list
)
{
var
ret
=
bufferShim
.
allocUnsafe
(
n
)
;
var
p
=
list
.
head
;
var
c
=
1
;
p
.
data
.
copy
(
ret
)
;
n
-
=
p
.
data
.
length
;
while
(
p
=
p
.
next
)
{
var
buf
=
p
.
data
;
var
nb
=
n
>
buf
.
length
?
buf
.
length
:
n
;
buf
.
copy
(
ret
ret
.
length
-
n
0
nb
)
;
n
-
=
nb
;
if
(
n
=
=
=
0
)
{
if
(
nb
=
=
=
buf
.
length
)
{
+
+
c
;
if
(
p
.
next
)
list
.
head
=
p
.
next
;
else
list
.
head
=
list
.
tail
=
null
;
}
else
{
list
.
head
=
p
;
p
.
data
=
buf
.
slice
(
nb
)
;
}
break
;
}
+
+
c
;
}
list
.
length
-
=
c
;
return
ret
;
}
function
endReadable
(
stream
)
{
var
state
=
stream
.
_readableState
;
if
(
state
.
length
>
0
)
throw
new
Error
(
'
"
endReadable
(
)
"
called
on
non
-
empty
stream
'
)
;
if
(
!
state
.
endEmitted
)
{
state
.
ended
=
true
;
processNextTick
(
endReadableNT
state
stream
)
;
}
}
function
endReadableNT
(
state
stream
)
{
if
(
!
state
.
endEmitted
&
&
state
.
length
=
=
=
0
)
{
state
.
endEmitted
=
true
;
stream
.
readable
=
false
;
stream
.
emit
(
'
end
'
)
;
}
}
function
forEach
(
xs
f
)
{
for
(
var
i
=
0
l
=
xs
.
length
;
i
<
l
;
i
+
+
)
{
f
(
xs
[
i
]
i
)
;
}
}
function
indexOf
(
xs
x
)
{
for
(
var
i
=
0
l
=
xs
.
length
;
i
<
l
;
i
+
+
)
{
if
(
xs
[
i
]
=
=
=
x
)
return
i
;
}
return
-
1
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
/
_stream_duplex
"
:
84
"
.
/
internal
/
streams
/
BufferList
"
:
89
"
_process
"
:
82
"
buffer
"
:
44
"
buffer
-
shims
"
:
43
"
core
-
util
-
is
"
:
45
"
events
"
:
63
"
inherits
"
:
66
"
isarray
"
:
68
"
process
-
nextick
-
args
"
:
81
"
string_decoder
/
"
:
95
"
util
"
:
40
}
]
87
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
module
.
exports
=
Transform
;
var
Duplex
=
require
(
'
.
/
_stream_duplex
'
)
;
var
util
=
require
(
'
core
-
util
-
is
'
)
;
util
.
inherits
=
require
(
'
inherits
'
)
;
util
.
inherits
(
Transform
Duplex
)
;
function
TransformState
(
stream
)
{
this
.
afterTransform
=
function
(
er
data
)
{
return
afterTransform
(
stream
er
data
)
;
}
;
this
.
needTransform
=
false
;
this
.
transforming
=
false
;
this
.
writecb
=
null
;
this
.
writechunk
=
null
;
this
.
writeencoding
=
null
;
}
function
afterTransform
(
stream
er
data
)
{
var
ts
=
stream
.
_transformState
;
ts
.
transforming
=
false
;
var
cb
=
ts
.
writecb
;
if
(
!
cb
)
return
stream
.
emit
(
'
error
'
new
Error
(
'
no
writecb
in
Transform
class
'
)
)
;
ts
.
writechunk
=
null
;
ts
.
writecb
=
null
;
if
(
data
!
=
=
null
&
&
data
!
=
=
undefined
)
stream
.
push
(
data
)
;
cb
(
er
)
;
var
rs
=
stream
.
_readableState
;
rs
.
reading
=
false
;
if
(
rs
.
needReadable
|
|
rs
.
length
<
rs
.
highWaterMark
)
{
stream
.
_read
(
rs
.
highWaterMark
)
;
}
}
function
Transform
(
options
)
{
if
(
!
(
this
instanceof
Transform
)
)
return
new
Transform
(
options
)
;
Duplex
.
call
(
this
options
)
;
this
.
_transformState
=
new
TransformState
(
this
)
;
var
stream
=
this
;
this
.
_readableState
.
needReadable
=
true
;
this
.
_readableState
.
sync
=
false
;
if
(
options
)
{
if
(
typeof
options
.
transform
=
=
=
'
function
'
)
this
.
_transform
=
options
.
transform
;
if
(
typeof
options
.
flush
=
=
=
'
function
'
)
this
.
_flush
=
options
.
flush
;
}
this
.
once
(
'
prefinish
'
function
(
)
{
if
(
typeof
this
.
_flush
=
=
=
'
function
'
)
this
.
_flush
(
function
(
er
)
{
done
(
stream
er
)
;
}
)
;
else
done
(
stream
)
;
}
)
;
}
Transform
.
prototype
.
push
=
function
(
chunk
encoding
)
{
this
.
_transformState
.
needTransform
=
false
;
return
Duplex
.
prototype
.
push
.
call
(
this
chunk
encoding
)
;
}
;
Transform
.
prototype
.
_transform
=
function
(
chunk
encoding
cb
)
{
throw
new
Error
(
'
Not
implemented
'
)
;
}
;
Transform
.
prototype
.
_write
=
function
(
chunk
encoding
cb
)
{
var
ts
=
this
.
_transformState
;
ts
.
writecb
=
cb
;
ts
.
writechunk
=
chunk
;
ts
.
writeencoding
=
encoding
;
if
(
!
ts
.
transforming
)
{
var
rs
=
this
.
_readableState
;
if
(
ts
.
needTransform
|
|
rs
.
needReadable
|
|
rs
.
length
<
rs
.
highWaterMark
)
this
.
_read
(
rs
.
highWaterMark
)
;
}
}
;
Transform
.
prototype
.
_read
=
function
(
n
)
{
var
ts
=
this
.
_transformState
;
if
(
ts
.
writechunk
!
=
=
null
&
&
ts
.
writecb
&
&
!
ts
.
transforming
)
{
ts
.
transforming
=
true
;
this
.
_transform
(
ts
.
writechunk
ts
.
writeencoding
ts
.
afterTransform
)
;
}
else
{
ts
.
needTransform
=
true
;
}
}
;
function
done
(
stream
er
)
{
if
(
er
)
return
stream
.
emit
(
'
error
'
er
)
;
var
ws
=
stream
.
_writableState
;
var
ts
=
stream
.
_transformState
;
if
(
ws
.
length
)
throw
new
Error
(
'
Calling
transform
done
when
ws
.
length
!
=
0
'
)
;
if
(
ts
.
transforming
)
throw
new
Error
(
'
Calling
transform
done
when
still
transforming
'
)
;
return
stream
.
push
(
null
)
;
}
}
{
"
.
/
_stream_duplex
"
:
84
"
core
-
util
-
is
"
:
45
"
inherits
"
:
66
}
]
88
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
'
use
strict
'
;
module
.
exports
=
Writable
;
var
processNextTick
=
require
(
'
process
-
nextick
-
args
'
)
;
var
asyncWrite
=
!
process
.
browser
&
&
[
'
v0
.
10
'
'
v0
.
9
.
'
]
.
indexOf
(
process
.
version
.
slice
(
0
5
)
)
>
-
1
?
setImmediate
:
processNextTick
;
Writable
.
WritableState
=
WritableState
;
var
util
=
require
(
'
core
-
util
-
is
'
)
;
util
.
inherits
=
require
(
'
inherits
'
)
;
var
internalUtil
=
{
deprecate
:
require
(
'
util
-
deprecate
'
)
}
;
var
Stream
;
(
function
(
)
{
try
{
Stream
=
require
(
'
st
'
+
'
ream
'
)
;
}
catch
(
_
)
{
}
finally
{
if
(
!
Stream
)
Stream
=
require
(
'
events
'
)
.
EventEmitter
;
}
}
)
(
)
;
var
Buffer
=
require
(
'
buffer
'
)
.
Buffer
;
var
bufferShim
=
require
(
'
buffer
-
shims
'
)
;
util
.
inherits
(
Writable
Stream
)
;
function
nop
(
)
{
}
function
WriteReq
(
chunk
encoding
cb
)
{
this
.
chunk
=
chunk
;
this
.
encoding
=
encoding
;
this
.
callback
=
cb
;
this
.
next
=
null
;
}
var
Duplex
;
function
WritableState
(
options
stream
)
{
Duplex
=
Duplex
|
|
require
(
'
.
/
_stream_duplex
'
)
;
options
=
options
|
|
{
}
;
this
.
objectMode
=
!
!
options
.
objectMode
;
if
(
stream
instanceof
Duplex
)
this
.
objectMode
=
this
.
objectMode
|
|
!
!
options
.
writableObjectMode
;
var
hwm
=
options
.
highWaterMark
;
var
defaultHwm
=
this
.
objectMode
?
16
:
16
*
1024
;
this
.
highWaterMark
=
hwm
|
|
hwm
=
=
=
0
?
hwm
:
defaultHwm
;
this
.
highWaterMark
=
~
~
this
.
highWaterMark
;
this
.
needDrain
=
false
;
this
.
ending
=
false
;
this
.
ended
=
false
;
this
.
finished
=
false
;
var
noDecode
=
options
.
decodeStrings
=
=
=
false
;
this
.
decodeStrings
=
!
noDecode
;
this
.
defaultEncoding
=
options
.
defaultEncoding
|
|
'
utf8
'
;
this
.
length
=
0
;
this
.
writing
=
false
;
this
.
corked
=
0
;
this
.
sync
=
true
;
this
.
bufferProcessing
=
false
;
this
.
onwrite
=
function
(
er
)
{
onwrite
(
stream
er
)
;
}
;
this
.
writecb
=
null
;
this
.
writelen
=
0
;
this
.
bufferedRequest
=
null
;
this
.
lastBufferedRequest
=
null
;
this
.
pendingcb
=
0
;
this
.
prefinished
=
false
;
this
.
errorEmitted
=
false
;
this
.
bufferedRequestCount
=
0
;
this
.
corkedRequestsFree
=
new
CorkedRequest
(
this
)
;
}
WritableState
.
prototype
.
getBuffer
=
function
writableStateGetBuffer
(
)
{
var
current
=
this
.
bufferedRequest
;
var
out
=
[
]
;
while
(
current
)
{
out
.
push
(
current
)
;
current
=
current
.
next
;
}
return
out
;
}
;
(
function
(
)
{
try
{
Object
.
defineProperty
(
WritableState
.
prototype
'
buffer
'
{
get
:
internalUtil
.
deprecate
(
function
(
)
{
return
this
.
getBuffer
(
)
;
}
'
_writableState
.
buffer
is
deprecated
.
Use
_writableState
.
getBuffer
'
+
'
instead
.
'
)
}
)
;
}
catch
(
_
)
{
}
}
)
(
)
;
var
Duplex
;
function
Writable
(
options
)
{
Duplex
=
Duplex
|
|
require
(
'
.
/
_stream_duplex
'
)
;
if
(
!
(
this
instanceof
Writable
)
&
&
!
(
this
instanceof
Duplex
)
)
return
new
Writable
(
options
)
;
this
.
_writableState
=
new
WritableState
(
options
this
)
;
this
.
writable
=
true
;
if
(
options
)
{
if
(
typeof
options
.
write
=
=
=
'
function
'
)
this
.
_write
=
options
.
write
;
if
(
typeof
options
.
writev
=
=
=
'
function
'
)
this
.
_writev
=
options
.
writev
;
}
Stream
.
call
(
this
)
;
}
Writable
.
prototype
.
pipe
=
function
(
)
{
this
.
emit
(
'
error
'
new
Error
(
'
Cannot
pipe
not
readable
'
)
)
;
}
;
function
writeAfterEnd
(
stream
cb
)
{
var
er
=
new
Error
(
'
write
after
end
'
)
;
stream
.
emit
(
'
error
'
er
)
;
processNextTick
(
cb
er
)
;
}
function
validChunk
(
stream
state
chunk
cb
)
{
var
valid
=
true
;
var
er
=
false
;
if
(
chunk
=
=
=
null
)
{
er
=
new
TypeError
(
'
May
not
write
null
values
to
stream
'
)
;
}
else
if
(
!
Buffer
.
isBuffer
(
chunk
)
&
&
typeof
chunk
!
=
=
'
string
'
&
&
chunk
!
=
=
undefined
&
&
!
state
.
objectMode
)
{
er
=
new
TypeError
(
'
Invalid
non
-
string
/
buffer
chunk
'
)
;
}
if
(
er
)
{
stream
.
emit
(
'
error
'
er
)
;
processNextTick
(
cb
er
)
;
valid
=
false
;
}
return
valid
;
}
Writable
.
prototype
.
write
=
function
(
chunk
encoding
cb
)
{
var
state
=
this
.
_writableState
;
var
ret
=
false
;
if
(
typeof
encoding
=
=
=
'
function
'
)
{
cb
=
encoding
;
encoding
=
null
;
}
if
(
Buffer
.
isBuffer
(
chunk
)
)
encoding
=
'
buffer
'
;
else
if
(
!
encoding
)
encoding
=
state
.
defaultEncoding
;
if
(
typeof
cb
!
=
=
'
function
'
)
cb
=
nop
;
if
(
state
.
ended
)
writeAfterEnd
(
this
cb
)
;
else
if
(
validChunk
(
this
state
chunk
cb
)
)
{
state
.
pendingcb
+
+
;
ret
=
writeOrBuffer
(
this
state
chunk
encoding
cb
)
;
}
return
ret
;
}
;
Writable
.
prototype
.
cork
=
function
(
)
{
var
state
=
this
.
_writableState
;
state
.
corked
+
+
;
}
;
Writable
.
prototype
.
uncork
=
function
(
)
{
var
state
=
this
.
_writableState
;
if
(
state
.
corked
)
{
state
.
corked
-
-
;
if
(
!
state
.
writing
&
&
!
state
.
corked
&
&
!
state
.
finished
&
&
!
state
.
bufferProcessing
&
&
state
.
bufferedRequest
)
clearBuffer
(
this
state
)
;
}
}
;
Writable
.
prototype
.
setDefaultEncoding
=
function
setDefaultEncoding
(
encoding
)
{
if
(
typeof
encoding
=
=
=
'
string
'
)
encoding
=
encoding
.
toLowerCase
(
)
;
if
(
!
(
[
'
hex
'
'
utf8
'
'
utf
-
8
'
'
ascii
'
'
binary
'
'
base64
'
'
ucs2
'
'
ucs
-
2
'
'
utf16le
'
'
utf
-
16le
'
'
raw
'
]
.
indexOf
(
(
encoding
+
'
'
)
.
toLowerCase
(
)
)
>
-
1
)
)
throw
new
TypeError
(
'
Unknown
encoding
:
'
+
encoding
)
;
this
.
_writableState
.
defaultEncoding
=
encoding
;
return
this
;
}
;
function
decodeChunk
(
state
chunk
encoding
)
{
if
(
!
state
.
objectMode
&
&
state
.
decodeStrings
!
=
=
false
&
&
typeof
chunk
=
=
=
'
string
'
)
{
chunk
=
bufferShim
.
from
(
chunk
encoding
)
;
}
return
chunk
;
}
function
writeOrBuffer
(
stream
state
chunk
encoding
cb
)
{
chunk
=
decodeChunk
(
state
chunk
encoding
)
;
if
(
Buffer
.
isBuffer
(
chunk
)
)
encoding
=
'
buffer
'
;
var
len
=
state
.
objectMode
?
1
:
chunk
.
length
;
state
.
length
+
=
len
;
var
ret
=
state
.
length
<
state
.
highWaterMark
;
if
(
!
ret
)
state
.
needDrain
=
true
;
if
(
state
.
writing
|
|
state
.
corked
)
{
var
last
=
state
.
lastBufferedRequest
;
state
.
lastBufferedRequest
=
new
WriteReq
(
chunk
encoding
cb
)
;
if
(
last
)
{
last
.
next
=
state
.
lastBufferedRequest
;
}
else
{
state
.
bufferedRequest
=
state
.
lastBufferedRequest
;
}
state
.
bufferedRequestCount
+
=
1
;
}
else
{
doWrite
(
stream
state
false
len
chunk
encoding
cb
)
;
}
return
ret
;
}
function
doWrite
(
stream
state
writev
len
chunk
encoding
cb
)
{
state
.
writelen
=
len
;
state
.
writecb
=
cb
;
state
.
writing
=
true
;
state
.
sync
=
true
;
if
(
writev
)
stream
.
_writev
(
chunk
state
.
onwrite
)
;
else
stream
.
_write
(
chunk
encoding
state
.
onwrite
)
;
state
.
sync
=
false
;
}
function
onwriteError
(
stream
state
sync
er
cb
)
{
-
-
state
.
pendingcb
;
if
(
sync
)
processNextTick
(
cb
er
)
;
else
cb
(
er
)
;
stream
.
_writableState
.
errorEmitted
=
true
;
stream
.
emit
(
'
error
'
er
)
;
}
function
onwriteStateUpdate
(
state
)
{
state
.
writing
=
false
;
state
.
writecb
=
null
;
state
.
length
-
=
state
.
writelen
;
state
.
writelen
=
0
;
}
function
onwrite
(
stream
er
)
{
var
state
=
stream
.
_writableState
;
var
sync
=
state
.
sync
;
var
cb
=
state
.
writecb
;
onwriteStateUpdate
(
state
)
;
if
(
er
)
onwriteError
(
stream
state
sync
er
cb
)
;
else
{
var
finished
=
needFinish
(
state
)
;
if
(
!
finished
&
&
!
state
.
corked
&
&
!
state
.
bufferProcessing
&
&
state
.
bufferedRequest
)
{
clearBuffer
(
stream
state
)
;
}
if
(
sync
)
{
asyncWrite
(
afterWrite
stream
state
finished
cb
)
;
}
else
{
afterWrite
(
stream
state
finished
cb
)
;
}
}
}
function
afterWrite
(
stream
state
finished
cb
)
{
if
(
!
finished
)
onwriteDrain
(
stream
state
)
;
state
.
pendingcb
-
-
;
cb
(
)
;
finishMaybe
(
stream
state
)
;
}
function
onwriteDrain
(
stream
state
)
{
if
(
state
.
length
=
=
=
0
&
&
state
.
needDrain
)
{
state
.
needDrain
=
false
;
stream
.
emit
(
'
drain
'
)
;
}
}
function
clearBuffer
(
stream
state
)
{
state
.
bufferProcessing
=
true
;
var
entry
=
state
.
bufferedRequest
;
if
(
stream
.
_writev
&
&
entry
&
&
entry
.
next
)
{
var
l
=
state
.
bufferedRequestCount
;
var
buffer
=
new
Array
(
l
)
;
var
holder
=
state
.
corkedRequestsFree
;
holder
.
entry
=
entry
;
var
count
=
0
;
while
(
entry
)
{
buffer
[
count
]
=
entry
;
entry
=
entry
.
next
;
count
+
=
1
;
}
doWrite
(
stream
state
true
state
.
length
buffer
'
'
holder
.
finish
)
;
state
.
pendingcb
+
+
;
state
.
lastBufferedRequest
=
null
;
if
(
holder
.
next
)
{
state
.
corkedRequestsFree
=
holder
.
next
;
holder
.
next
=
null
;
}
else
{
state
.
corkedRequestsFree
=
new
CorkedRequest
(
state
)
;
}
}
else
{
while
(
entry
)
{
var
chunk
=
entry
.
chunk
;
var
encoding
=
entry
.
encoding
;
var
cb
=
entry
.
callback
;
var
len
=
state
.
objectMode
?
1
:
chunk
.
length
;
doWrite
(
stream
state
false
len
chunk
encoding
cb
)
;
entry
=
entry
.
next
;
if
(
state
.
writing
)
{
break
;
}
}
if
(
entry
=
=
=
null
)
state
.
lastBufferedRequest
=
null
;
}
state
.
bufferedRequestCount
=
0
;
state
.
bufferedRequest
=
entry
;
state
.
bufferProcessing
=
false
;
}
Writable
.
prototype
.
_write
=
function
(
chunk
encoding
cb
)
{
cb
(
new
Error
(
'
not
implemented
'
)
)
;
}
;
Writable
.
prototype
.
_writev
=
null
;
Writable
.
prototype
.
end
=
function
(
chunk
encoding
cb
)
{
var
state
=
this
.
_writableState
;
if
(
typeof
chunk
=
=
=
'
function
'
)
{
cb
=
chunk
;
chunk
=
null
;
encoding
=
null
;
}
else
if
(
typeof
encoding
=
=
=
'
function
'
)
{
cb
=
encoding
;
encoding
=
null
;
}
if
(
chunk
!
=
=
null
&
&
chunk
!
=
=
undefined
)
this
.
write
(
chunk
encoding
)
;
if
(
state
.
corked
)
{
state
.
corked
=
1
;
this
.
uncork
(
)
;
}
if
(
!
state
.
ending
&
&
!
state
.
finished
)
endWritable
(
this
state
cb
)
;
}
;
function
needFinish
(
state
)
{
return
state
.
ending
&
&
state
.
length
=
=
=
0
&
&
state
.
bufferedRequest
=
=
=
null
&
&
!
state
.
finished
&
&
!
state
.
writing
;
}
function
prefinish
(
stream
state
)
{
if
(
!
state
.
prefinished
)
{
state
.
prefinished
=
true
;
stream
.
emit
(
'
prefinish
'
)
;
}
}
function
finishMaybe
(
stream
state
)
{
var
need
=
needFinish
(
state
)
;
if
(
need
)
{
if
(
state
.
pendingcb
=
=
=
0
)
{
prefinish
(
stream
state
)
;
state
.
finished
=
true
;
stream
.
emit
(
'
finish
'
)
;
}
else
{
prefinish
(
stream
state
)
;
}
}
return
need
;
}
function
endWritable
(
stream
state
cb
)
{
state
.
ending
=
true
;
finishMaybe
(
stream
state
)
;
if
(
cb
)
{
if
(
state
.
finished
)
processNextTick
(
cb
)
;
else
stream
.
once
(
'
finish
'
cb
)
;
}
state
.
ended
=
true
;
stream
.
writable
=
false
;
}
function
CorkedRequest
(
state
)
{
var
_this
=
this
;
this
.
next
=
null
;
this
.
entry
=
null
;
this
.
finish
=
function
(
err
)
{
var
entry
=
_this
.
entry
;
_this
.
entry
=
null
;
while
(
entry
)
{
var
cb
=
entry
.
callback
;
state
.
pendingcb
-
-
;
cb
(
err
)
;
entry
=
entry
.
next
;
}
if
(
state
.
corkedRequestsFree
)
{
state
.
corkedRequestsFree
.
next
=
_this
;
}
else
{
state
.
corkedRequestsFree
=
_this
;
}
}
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
/
_stream_duplex
"
:
84
"
_process
"
:
82
"
buffer
"
:
44
"
buffer
-
shims
"
:
43
"
core
-
util
-
is
"
:
45
"
events
"
:
63
"
inherits
"
:
66
"
process
-
nextick
-
args
"
:
81
"
util
-
deprecate
"
:
96
}
]
89
:
[
function
(
require
module
exports
)
{
'
use
strict
'
;
var
Buffer
=
require
(
'
buffer
'
)
.
Buffer
;
var
bufferShim
=
require
(
'
buffer
-
shims
'
)
;
module
.
exports
=
BufferList
;
function
BufferList
(
)
{
this
.
head
=
null
;
this
.
tail
=
null
;
this
.
length
=
0
;
}
BufferList
.
prototype
.
push
=
function
(
v
)
{
var
entry
=
{
data
:
v
next
:
null
}
;
if
(
this
.
length
>
0
)
this
.
tail
.
next
=
entry
;
else
this
.
head
=
entry
;
this
.
tail
=
entry
;
+
+
this
.
length
;
}
;
BufferList
.
prototype
.
unshift
=
function
(
v
)
{
var
entry
=
{
data
:
v
next
:
this
.
head
}
;
if
(
this
.
length
=
=
=
0
)
this
.
tail
=
entry
;
this
.
head
=
entry
;
+
+
this
.
length
;
}
;
BufferList
.
prototype
.
shift
=
function
(
)
{
if
(
this
.
length
=
=
=
0
)
return
;
var
ret
=
this
.
head
.
data
;
if
(
this
.
length
=
=
=
1
)
this
.
head
=
this
.
tail
=
null
;
else
this
.
head
=
this
.
head
.
next
;
-
-
this
.
length
;
return
ret
;
}
;
BufferList
.
prototype
.
clear
=
function
(
)
{
this
.
head
=
this
.
tail
=
null
;
this
.
length
=
0
;
}
;
BufferList
.
prototype
.
join
=
function
(
s
)
{
if
(
this
.
length
=
=
=
0
)
return
'
'
;
var
p
=
this
.
head
;
var
ret
=
'
'
+
p
.
data
;
while
(
p
=
p
.
next
)
{
ret
+
=
s
+
p
.
data
;
}
return
ret
;
}
;
BufferList
.
prototype
.
concat
=
function
(
n
)
{
if
(
this
.
length
=
=
=
0
)
return
bufferShim
.
alloc
(
0
)
;
if
(
this
.
length
=
=
=
1
)
return
this
.
head
.
data
;
var
ret
=
bufferShim
.
allocUnsafe
(
n
>
>
>
0
)
;
var
p
=
this
.
head
;
var
i
=
0
;
while
(
p
)
{
p
.
data
.
copy
(
ret
i
)
;
i
+
=
p
.
data
.
length
;
p
=
p
.
next
;
}
return
ret
;
}
;
}
{
"
buffer
"
:
44
"
buffer
-
shims
"
:
43
}
]
90
:
[
function
(
require
module
exports
)
{
module
.
exports
=
require
(
"
.
/
lib
/
_stream_passthrough
.
js
"
)
}
{
"
.
/
lib
/
_stream_passthrough
.
js
"
:
85
}
]
91
:
[
function
(
require
module
exports
)
{
(
function
(
process
)
{
var
Stream
=
(
function
(
)
{
try
{
return
require
(
'
st
'
+
'
ream
'
)
;
}
catch
(
_
)
{
}
}
(
)
)
;
exports
=
module
.
exports
=
require
(
'
.
/
lib
/
_stream_readable
.
js
'
)
;
exports
.
Stream
=
Stream
|
|
exports
;
exports
.
Readable
=
exports
;
exports
.
Writable
=
require
(
'
.
/
lib
/
_stream_writable
.
js
'
)
;
exports
.
Duplex
=
require
(
'
.
/
lib
/
_stream_duplex
.
js
'
)
;
exports
.
Transform
=
require
(
'
.
/
lib
/
_stream_transform
.
js
'
)
;
exports
.
PassThrough
=
require
(
'
.
/
lib
/
_stream_passthrough
.
js
'
)
;
if
(
!
process
.
browser
&
&
process
.
env
.
READABLE_STREAM
=
=
=
'
disable
'
&
&
Stream
)
{
module
.
exports
=
Stream
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
)
}
{
"
.
/
lib
/
_stream_duplex
.
js
"
:
84
"
.
/
lib
/
_stream_passthrough
.
js
"
:
85
"
.
/
lib
/
_stream_readable
.
js
"
:
86
"
.
/
lib
/
_stream_transform
.
js
"
:
87
"
.
/
lib
/
_stream_writable
.
js
"
:
88
"
_process
"
:
82
}
]
92
:
[
function
(
require
module
exports
)
{
module
.
exports
=
require
(
"
.
/
lib
/
_stream_transform
.
js
"
)
}
{
"
.
/
lib
/
_stream_transform
.
js
"
:
87
}
]
93
:
[
function
(
require
module
exports
)
{
module
.
exports
=
require
(
"
.
/
lib
/
_stream_writable
.
js
"
)
}
{
"
.
/
lib
/
_stream_writable
.
js
"
:
88
}
]
94
:
[
function
(
require
module
exports
)
{
module
.
exports
=
Stream
;
var
EE
=
require
(
'
events
'
)
.
EventEmitter
;
var
inherits
=
require
(
'
inherits
'
)
;
inherits
(
Stream
EE
)
;
Stream
.
Readable
=
require
(
'
readable
-
stream
/
readable
.
js
'
)
;
Stream
.
Writable
=
require
(
'
readable
-
stream
/
writable
.
js
'
)
;
Stream
.
Duplex
=
require
(
'
readable
-
stream
/
duplex
.
js
'
)
;
Stream
.
Transform
=
require
(
'
readable
-
stream
/
transform
.
js
'
)
;
Stream
.
PassThrough
=
require
(
'
readable
-
stream
/
passthrough
.
js
'
)
;
Stream
.
Stream
=
Stream
;
function
Stream
(
)
{
EE
.
call
(
this
)
;
}
Stream
.
prototype
.
pipe
=
function
(
dest
options
)
{
var
source
=
this
;
function
ondata
(
chunk
)
{
if
(
dest
.
writable
)
{
if
(
false
=
=
=
dest
.
write
(
chunk
)
&
&
source
.
pause
)
{
source
.
pause
(
)
;
}
}
}
source
.
on
(
'
data
'
ondata
)
;
function
ondrain
(
)
{
if
(
source
.
readable
&
&
source
.
resume
)
{
source
.
resume
(
)
;
}
}
dest
.
on
(
'
drain
'
ondrain
)
;
if
(
!
dest
.
_isStdio
&
&
(
!
options
|
|
options
.
end
!
=
=
false
)
)
{
source
.
on
(
'
end
'
onend
)
;
source
.
on
(
'
close
'
onclose
)
;
}
var
didOnEnd
=
false
;
function
onend
(
)
{
if
(
didOnEnd
)
return
;
didOnEnd
=
true
;
dest
.
end
(
)
;
}
function
onclose
(
)
{
if
(
didOnEnd
)
return
;
didOnEnd
=
true
;
if
(
typeof
dest
.
destroy
=
=
=
'
function
'
)
dest
.
destroy
(
)
;
}
function
onerror
(
er
)
{
cleanup
(
)
;
if
(
EE
.
listenerCount
(
this
'
error
'
)
=
=
=
0
)
{
throw
er
;
}
}
source
.
on
(
'
error
'
onerror
)
;
dest
.
on
(
'
error
'
onerror
)
;
function
cleanup
(
)
{
source
.
removeListener
(
'
data
'
ondata
)
;
dest
.
removeListener
(
'
drain
'
ondrain
)
;
source
.
removeListener
(
'
end
'
onend
)
;
source
.
removeListener
(
'
close
'
onclose
)
;
source
.
removeListener
(
'
error
'
onerror
)
;
dest
.
removeListener
(
'
error
'
onerror
)
;
source
.
removeListener
(
'
end
'
cleanup
)
;
source
.
removeListener
(
'
close
'
cleanup
)
;
dest
.
removeListener
(
'
close
'
cleanup
)
;
}
source
.
on
(
'
end
'
cleanup
)
;
source
.
on
(
'
close
'
cleanup
)
;
dest
.
on
(
'
close
'
cleanup
)
;
dest
.
emit
(
'
pipe
'
source
)
;
return
dest
;
}
;
}
{
"
events
"
:
63
"
inherits
"
:
66
"
readable
-
stream
/
duplex
.
js
"
:
83
"
readable
-
stream
/
passthrough
.
js
"
:
90
"
readable
-
stream
/
readable
.
js
"
:
91
"
readable
-
stream
/
transform
.
js
"
:
92
"
readable
-
stream
/
writable
.
js
"
:
93
}
]
95
:
[
function
(
require
module
exports
)
{
var
Buffer
=
require
(
'
buffer
'
)
.
Buffer
;
var
isBufferEncoding
=
Buffer
.
isEncoding
|
|
function
(
encoding
)
{
switch
(
encoding
&
&
encoding
.
toLowerCase
(
)
)
{
case
'
hex
'
:
case
'
utf8
'
:
case
'
utf
-
8
'
:
case
'
ascii
'
:
case
'
binary
'
:
case
'
base64
'
:
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
case
'
raw
'
:
return
true
;
default
:
return
false
;
}
}
function
assertEncoding
(
encoding
)
{
if
(
encoding
&
&
!
isBufferEncoding
(
encoding
)
)
{
throw
new
Error
(
'
Unknown
encoding
:
'
+
encoding
)
;
}
}
var
StringDecoder
=
exports
.
StringDecoder
=
function
(
encoding
)
{
this
.
encoding
=
(
encoding
|
|
'
utf8
'
)
.
toLowerCase
(
)
.
replace
(
/
[
-
_
]
/
'
'
)
;
assertEncoding
(
encoding
)
;
switch
(
this
.
encoding
)
{
case
'
utf8
'
:
this
.
surrogateSize
=
3
;
break
;
case
'
ucs2
'
:
case
'
utf16le
'
:
this
.
surrogateSize
=
2
;
this
.
detectIncompleteChar
=
utf16DetectIncompleteChar
;
break
;
case
'
base64
'
:
this
.
surrogateSize
=
3
;
this
.
detectIncompleteChar
=
base64DetectIncompleteChar
;
break
;
default
:
this
.
write
=
passThroughWrite
;
return
;
}
this
.
charBuffer
=
new
Buffer
(
6
)
;
this
.
charReceived
=
0
;
this
.
charLength
=
0
;
}
;
StringDecoder
.
prototype
.
write
=
function
(
buffer
)
{
var
charStr
=
'
'
;
while
(
this
.
charLength
)
{
var
available
=
(
buffer
.
length
>
=
this
.
charLength
-
this
.
charReceived
)
?
this
.
charLength
-
this
.
charReceived
:
buffer
.
length
;
buffer
.
copy
(
this
.
charBuffer
this
.
charReceived
0
available
)
;
this
.
charReceived
+
=
available
;
if
(
this
.
charReceived
<
this
.
charLength
)
{
return
'
'
;
}
buffer
=
buffer
.
slice
(
available
buffer
.
length
)
;
charStr
=
this
.
charBuffer
.
slice
(
0
this
.
charLength
)
.
toString
(
this
.
encoding
)
;
var
charCode
=
charStr
.
charCodeAt
(
charStr
.
length
-
1
)
;
if
(
charCode
>
=
0xD800
&
&
charCode
<
=
0xDBFF
)
{
this
.
charLength
+
=
this
.
surrogateSize
;
charStr
=
'
'
;
continue
;
}
this
.
charReceived
=
this
.
charLength
=
0
;
if
(
buffer
.
length
=
=
=
0
)
{
return
charStr
;
}
break
;
}
this
.
detectIncompleteChar
(
buffer
)
;
var
end
=
buffer
.
length
;
if
(
this
.
charLength
)
{
buffer
.
copy
(
this
.
charBuffer
0
buffer
.
length
-
this
.
charReceived
end
)
;
end
-
=
this
.
charReceived
;
}
charStr
+
=
buffer
.
toString
(
this
.
encoding
0
end
)
;
var
end
=
charStr
.
length
-
1
;
var
charCode
=
charStr
.
charCodeAt
(
end
)
;
if
(
charCode
>
=
0xD800
&
&
charCode
<
=
0xDBFF
)
{
var
size
=
this
.
surrogateSize
;
this
.
charLength
+
=
size
;
this
.
charReceived
+
=
size
;
this
.
charBuffer
.
copy
(
this
.
charBuffer
size
0
size
)
;
buffer
.
copy
(
this
.
charBuffer
0
0
size
)
;
return
charStr
.
substring
(
0
end
)
;
}
return
charStr
;
}
;
StringDecoder
.
prototype
.
detectIncompleteChar
=
function
(
buffer
)
{
var
i
=
(
buffer
.
length
>
=
3
)
?
3
:
buffer
.
length
;
for
(
;
i
>
0
;
i
-
-
)
{
var
c
=
buffer
[
buffer
.
length
-
i
]
;
if
(
i
=
=
1
&
&
c
>
>
5
=
=
0x06
)
{
this
.
charLength
=
2
;
break
;
}
if
(
i
<
=
2
&
&
c
>
>
4
=
=
0x0E
)
{
this
.
charLength
=
3
;
break
;
}
if
(
i
<
=
3
&
&
c
>
>
3
=
=
0x1E
)
{
this
.
charLength
=
4
;
break
;
}
}
this
.
charReceived
=
i
;
}
;
StringDecoder
.
prototype
.
end
=
function
(
buffer
)
{
var
res
=
'
'
;
if
(
buffer
&
&
buffer
.
length
)
res
=
this
.
write
(
buffer
)
;
if
(
this
.
charReceived
)
{
var
cr
=
this
.
charReceived
;
var
buf
=
this
.
charBuffer
;
var
enc
=
this
.
encoding
;
res
+
=
buf
.
slice
(
0
cr
)
.
toString
(
enc
)
;
}
return
res
;
}
;
function
passThroughWrite
(
buffer
)
{
return
buffer
.
toString
(
this
.
encoding
)
;
}
function
utf16DetectIncompleteChar
(
buffer
)
{
this
.
charReceived
=
buffer
.
length
%
2
;
this
.
charLength
=
this
.
charReceived
?
2
:
0
;
}
function
base64DetectIncompleteChar
(
buffer
)
{
this
.
charReceived
=
buffer
.
length
%
3
;
this
.
charLength
=
this
.
charReceived
?
3
:
0
;
}
}
{
"
buffer
"
:
44
}
]
96
:
[
function
(
require
module
exports
)
{
(
function
(
global
)
{
module
.
exports
=
deprecate
;
function
deprecate
(
fn
msg
)
{
if
(
config
(
'
noDeprecation
'
)
)
{
return
fn
;
}
var
warned
=
false
;
function
deprecated
(
)
{
if
(
!
warned
)
{
if
(
config
(
'
throwDeprecation
'
)
)
{
throw
new
Error
(
msg
)
;
}
else
if
(
config
(
'
traceDeprecation
'
)
)
{
console
.
trace
(
msg
)
;
}
else
{
console
.
warn
(
msg
)
;
}
warned
=
true
;
}
return
fn
.
apply
(
this
arguments
)
;
}
return
deprecated
;
}
function
config
(
name
)
{
try
{
if
(
!
global
.
localStorage
)
return
false
;
}
catch
(
_
)
{
return
false
;
}
var
val
=
global
.
localStorage
[
name
]
;
if
(
null
=
=
val
)
return
false
;
return
String
(
val
)
.
toLowerCase
(
)
=
=
=
'
true
'
;
}
}
)
.
call
(
this
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
}
]
97
:
[
function
(
require
module
exports
)
{
arguments
[
4
]
[
66
]
[
0
]
.
apply
(
exports
arguments
)
}
{
"
dup
"
:
66
}
]
98
:
[
function
(
require
module
exports
)
{
module
.
exports
=
function
isBuffer
(
arg
)
{
return
arg
&
&
typeof
arg
=
=
=
'
object
'
&
&
typeof
arg
.
copy
=
=
=
'
function
'
&
&
typeof
arg
.
fill
=
=
=
'
function
'
&
&
typeof
arg
.
readUInt8
=
=
=
'
function
'
;
}
}
{
}
]
99
:
[
function
(
require
module
exports
)
{
(
function
(
process
global
)
{
var
formatRegExp
=
/
%
[
sdj
%
]
/
g
;
exports
.
format
=
function
(
f
)
{
if
(
!
isString
(
f
)
)
{
var
objects
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
objects
.
push
(
inspect
(
arguments
[
i
]
)
)
;
}
return
objects
.
join
(
'
'
)
;
}
var
i
=
1
;
var
args
=
arguments
;
var
len
=
args
.
length
;
var
str
=
String
(
f
)
.
replace
(
formatRegExp
function
(
x
)
{
if
(
x
=
=
=
'
%
%
'
)
return
'
%
'
;
if
(
i
>
=
len
)
return
x
;
switch
(
x
)
{
case
'
%
s
'
:
return
String
(
args
[
i
+
+
]
)
;
case
'
%
d
'
:
return
Number
(
args
[
i
+
+
]
)
;
case
'
%
j
'
:
try
{
return
JSON
.
stringify
(
args
[
i
+
+
]
)
;
}
catch
(
_
)
{
return
'
[
Circular
]
'
;
}
default
:
return
x
;
}
}
)
;
for
(
var
x
=
args
[
i
]
;
i
<
len
;
x
=
args
[
+
+
i
]
)
{
if
(
isNull
(
x
)
|
|
!
isObject
(
x
)
)
{
str
+
=
'
'
+
x
;
}
else
{
str
+
=
'
'
+
inspect
(
x
)
;
}
}
return
str
;
}
;
exports
.
deprecate
=
function
(
fn
msg
)
{
if
(
isUndefined
(
global
.
process
)
)
{
return
function
(
)
{
return
exports
.
deprecate
(
fn
msg
)
.
apply
(
this
arguments
)
;
}
;
}
if
(
process
.
noDeprecation
=
=
=
true
)
{
return
fn
;
}
var
warned
=
false
;
function
deprecated
(
)
{
if
(
!
warned
)
{
if
(
process
.
throwDeprecation
)
{
throw
new
Error
(
msg
)
;
}
else
if
(
process
.
traceDeprecation
)
{
console
.
trace
(
msg
)
;
}
else
{
console
.
error
(
msg
)
;
}
warned
=
true
;
}
return
fn
.
apply
(
this
arguments
)
;
}
return
deprecated
;
}
;
var
debugs
=
{
}
;
var
debugEnviron
;
exports
.
debuglog
=
function
(
set
)
{
if
(
isUndefined
(
debugEnviron
)
)
debugEnviron
=
process
.
env
.
NODE_DEBUG
|
|
'
'
;
set
=
set
.
toUpperCase
(
)
;
if
(
!
debugs
[
set
]
)
{
if
(
new
RegExp
(
'
\
\
b
'
+
set
+
'
\
\
b
'
'
i
'
)
.
test
(
debugEnviron
)
)
{
var
pid
=
process
.
pid
;
debugs
[
set
]
=
function
(
)
{
var
msg
=
exports
.
format
.
apply
(
exports
arguments
)
;
console
.
error
(
'
%
s
%
d
:
%
s
'
set
pid
msg
)
;
}
;
}
else
{
debugs
[
set
]
=
function
(
)
{
}
;
}
}
return
debugs
[
set
]
;
}
;
function
inspect
(
obj
opts
)
{
var
ctx
=
{
seen
:
[
]
stylize
:
stylizeNoColor
}
;
if
(
arguments
.
length
>
=
3
)
ctx
.
depth
=
arguments
[
2
]
;
if
(
arguments
.
length
>
=
4
)
ctx
.
colors
=
arguments
[
3
]
;
if
(
isBoolean
(
opts
)
)
{
ctx
.
showHidden
=
opts
;
}
else
if
(
opts
)
{
exports
.
_extend
(
ctx
opts
)
;
}
if
(
isUndefined
(
ctx
.
showHidden
)
)
ctx
.
showHidden
=
false
;
if
(
isUndefined
(
ctx
.
depth
)
)
ctx
.
depth
=
2
;
if
(
isUndefined
(
ctx
.
colors
)
)
ctx
.
colors
=
false
;
if
(
isUndefined
(
ctx
.
customInspect
)
)
ctx
.
customInspect
=
true
;
if
(
ctx
.
colors
)
ctx
.
stylize
=
stylizeWithColor
;
return
formatValue
(
ctx
obj
ctx
.
depth
)
;
}
exports
.
inspect
=
inspect
;
inspect
.
colors
=
{
'
bold
'
:
[
1
22
]
'
italic
'
:
[
3
23
]
'
underline
'
:
[
4
24
]
'
inverse
'
:
[
7
27
]
'
white
'
:
[
37
39
]
'
grey
'
:
[
90
39
]
'
black
'
:
[
30
39
]
'
blue
'
:
[
34
39
]
'
cyan
'
:
[
36
39
]
'
green
'
:
[
32
39
]
'
magenta
'
:
[
35
39
]
'
red
'
:
[
31
39
]
'
yellow
'
:
[
33
39
]
}
;
inspect
.
styles
=
{
'
special
'
:
'
cyan
'
'
number
'
:
'
yellow
'
'
boolean
'
:
'
yellow
'
'
undefined
'
:
'
grey
'
'
null
'
:
'
bold
'
'
string
'
:
'
green
'
'
date
'
:
'
magenta
'
'
regexp
'
:
'
red
'
}
;
function
stylizeWithColor
(
str
styleType
)
{
var
style
=
inspect
.
styles
[
styleType
]
;
if
(
style
)
{
return
'
\
u001b
[
'
+
inspect
.
colors
[
style
]
[
0
]
+
'
m
'
+
str
+
'
\
u001b
[
'
+
inspect
.
colors
[
style
]
[
1
]
+
'
m
'
;
}
else
{
return
str
;
}
}
function
stylizeNoColor
(
str
styleType
)
{
return
str
;
}
function
arrayToHash
(
array
)
{
var
hash
=
{
}
;
array
.
forEach
(
function
(
val
idx
)
{
hash
[
val
]
=
true
;
}
)
;
return
hash
;
}
function
formatValue
(
ctx
value
recurseTimes
)
{
if
(
ctx
.
customInspect
&
&
value
&
&
isFunction
(
value
.
inspect
)
&
&
value
.
inspect
!
=
=
exports
.
inspect
&
&
!
(
value
.
constructor
&
&
value
.
constructor
.
prototype
=
=
=
value
)
)
{
var
ret
=
value
.
inspect
(
recurseTimes
ctx
)
;
if
(
!
isString
(
ret
)
)
{
ret
=
formatValue
(
ctx
ret
recurseTimes
)
;
}
return
ret
;
}
var
primitive
=
formatPrimitive
(
ctx
value
)
;
if
(
primitive
)
{
return
primitive
;
}
var
keys
=
Object
.
keys
(
value
)
;
var
visibleKeys
=
arrayToHash
(
keys
)
;
if
(
ctx
.
showHidden
)
{
keys
=
Object
.
getOwnPropertyNames
(
value
)
;
}
if
(
isError
(
value
)
&
&
(
keys
.
indexOf
(
'
message
'
)
>
=
0
|
|
keys
.
indexOf
(
'
description
'
)
>
=
0
)
)
{
return
formatError
(
value
)
;
}
if
(
keys
.
length
=
=
=
0
)
{
if
(
isFunction
(
value
)
)
{
var
name
=
value
.
name
?
'
:
'
+
value
.
name
:
'
'
;
return
ctx
.
stylize
(
'
[
Function
'
+
name
+
'
]
'
'
special
'
)
;
}
if
(
isRegExp
(
value
)
)
{
return
ctx
.
stylize
(
RegExp
.
prototype
.
toString
.
call
(
value
)
'
regexp
'
)
;
}
if
(
isDate
(
value
)
)
{
return
ctx
.
stylize
(
Date
.
prototype
.
toString
.
call
(
value
)
'
date
'
)
;
}
if
(
isError
(
value
)
)
{
return
formatError
(
value
)
;
}
}
var
base
=
'
'
array
=
false
braces
=
[
'
{
'
'
}
'
]
;
if
(
isArray
(
value
)
)
{
array
=
true
;
braces
=
[
'
[
'
'
]
'
]
;
}
if
(
isFunction
(
value
)
)
{
var
n
=
value
.
name
?
'
:
'
+
value
.
name
:
'
'
;
base
=
'
[
Function
'
+
n
+
'
]
'
;
}
if
(
isRegExp
(
value
)
)
{
base
=
'
'
+
RegExp
.
prototype
.
toString
.
call
(
value
)
;
}
if
(
isDate
(
value
)
)
{
base
=
'
'
+
Date
.
prototype
.
toUTCString
.
call
(
value
)
;
}
if
(
isError
(
value
)
)
{
base
=
'
'
+
formatError
(
value
)
;
}
if
(
keys
.
length
=
=
=
0
&
&
(
!
array
|
|
value
.
length
=
=
0
)
)
{
return
braces
[
0
]
+
base
+
braces
[
1
]
;
}
if
(
recurseTimes
<
0
)
{
if
(
isRegExp
(
value
)
)
{
return
ctx
.
stylize
(
RegExp
.
prototype
.
toString
.
call
(
value
)
'
regexp
'
)
;
}
else
{
return
ctx
.
stylize
(
'
[
Object
]
'
'
special
'
)
;
}
}
ctx
.
seen
.
push
(
value
)
;
var
output
;
if
(
array
)
{
output
=
formatArray
(
ctx
value
recurseTimes
visibleKeys
keys
)
;
}
else
{
output
=
keys
.
map
(
function
(
key
)
{
return
formatProperty
(
ctx
value
recurseTimes
visibleKeys
key
array
)
;
}
)
;
}
ctx
.
seen
.
pop
(
)
;
return
reduceToSingleString
(
output
base
braces
)
;
}
function
formatPrimitive
(
ctx
value
)
{
if
(
isUndefined
(
value
)
)
return
ctx
.
stylize
(
'
undefined
'
'
undefined
'
)
;
if
(
isString
(
value
)
)
{
var
simple
=
'
\
'
'
+
JSON
.
stringify
(
value
)
.
replace
(
/
^
"
|
"
/
g
'
'
)
.
replace
(
/
'
/
g
"
\
\
'
"
)
.
replace
(
/
\
\
"
/
g
'
"
'
)
+
'
\
'
'
;
return
ctx
.
stylize
(
simple
'
string
'
)
;
}
if
(
isNumber
(
value
)
)
return
ctx
.
stylize
(
'
'
+
value
'
number
'
)
;
if
(
isBoolean
(
value
)
)
return
ctx
.
stylize
(
'
'
+
value
'
boolean
'
)
;
if
(
isNull
(
value
)
)
return
ctx
.
stylize
(
'
null
'
'
null
'
)
;
}
function
formatError
(
value
)
{
return
'
[
'
+
Error
.
prototype
.
toString
.
call
(
value
)
+
'
]
'
;
}
function
formatArray
(
ctx
value
recurseTimes
visibleKeys
keys
)
{
var
output
=
[
]
;
for
(
var
i
=
0
l
=
value
.
length
;
i
<
l
;
+
+
i
)
{
if
(
hasOwnProperty
(
value
String
(
i
)
)
)
{
output
.
push
(
formatProperty
(
ctx
value
recurseTimes
visibleKeys
String
(
i
)
true
)
)
;
}
else
{
output
.
push
(
'
'
)
;
}
}
keys
.
forEach
(
function
(
key
)
{
if
(
!
key
.
match
(
/
^
\
d
+
/
)
)
{
output
.
push
(
formatProperty
(
ctx
value
recurseTimes
visibleKeys
key
true
)
)
;
}
}
)
;
return
output
;
}
function
formatProperty
(
ctx
value
recurseTimes
visibleKeys
key
array
)
{
var
name
str
desc
;
desc
=
Object
.
getOwnPropertyDescriptor
(
value
key
)
|
|
{
value
:
value
[
key
]
}
;
if
(
desc
.
get
)
{
if
(
desc
.
set
)
{
str
=
ctx
.
stylize
(
'
[
Getter
/
Setter
]
'
'
special
'
)
;
}
else
{
str
=
ctx
.
stylize
(
'
[
Getter
]
'
'
special
'
)
;
}
}
else
{
if
(
desc
.
set
)
{
str
=
ctx
.
stylize
(
'
[
Setter
]
'
'
special
'
)
;
}
}
if
(
!
hasOwnProperty
(
visibleKeys
key
)
)
{
name
=
'
[
'
+
key
+
'
]
'
;
}
if
(
!
str
)
{
if
(
ctx
.
seen
.
indexOf
(
desc
.
value
)
<
0
)
{
if
(
isNull
(
recurseTimes
)
)
{
str
=
formatValue
(
ctx
desc
.
value
null
)
;
}
else
{
str
=
formatValue
(
ctx
desc
.
value
recurseTimes
-
1
)
;
}
if
(
str
.
indexOf
(
'
\
n
'
)
>
-
1
)
{
if
(
array
)
{
str
=
str
.
split
(
'
\
n
'
)
.
map
(
function
(
line
)
{
return
'
'
+
line
;
}
)
.
join
(
'
\
n
'
)
.
substr
(
2
)
;
}
else
{
str
=
'
\
n
'
+
str
.
split
(
'
\
n
'
)
.
map
(
function
(
line
)
{
return
'
'
+
line
;
}
)
.
join
(
'
\
n
'
)
;
}
}
}
else
{
str
=
ctx
.
stylize
(
'
[
Circular
]
'
'
special
'
)
;
}
}
if
(
isUndefined
(
name
)
)
{
if
(
array
&
&
key
.
match
(
/
^
\
d
+
/
)
)
{
return
str
;
}
name
=
JSON
.
stringify
(
'
'
+
key
)
;
if
(
name
.
match
(
/
^
"
(
[
a
-
zA
-
Z_
]
[
a
-
zA
-
Z_0
-
9
]
*
)
"
/
)
)
{
name
=
name
.
substr
(
1
name
.
length
-
2
)
;
name
=
ctx
.
stylize
(
name
'
name
'
)
;
}
else
{
name
=
name
.
replace
(
/
'
/
g
"
\
\
'
"
)
.
replace
(
/
\
\
"
/
g
'
"
'
)
.
replace
(
/
(
^
"
|
"
)
/
g
"
'
"
)
;
name
=
ctx
.
stylize
(
name
'
string
'
)
;
}
}
return
name
+
'
:
'
+
str
;
}
function
reduceToSingleString
(
output
base
braces
)
{
var
numLinesEst
=
0
;
var
length
=
output
.
reduce
(
function
(
prev
cur
)
{
numLinesEst
+
+
;
if
(
cur
.
indexOf
(
'
\
n
'
)
>
=
0
)
numLinesEst
+
+
;
return
prev
+
cur
.
replace
(
/
\
u001b
\
[
\
d
\
d
?
m
/
g
'
'
)
.
length
+
1
;
}
0
)
;
if
(
length
>
60
)
{
return
braces
[
0
]
+
(
base
=
=
=
'
'
?
'
'
:
base
+
'
\
n
'
)
+
'
'
+
output
.
join
(
'
\
n
'
)
+
'
'
+
braces
[
1
]
;
}
return
braces
[
0
]
+
base
+
'
'
+
output
.
join
(
'
'
)
+
'
'
+
braces
[
1
]
;
}
function
isArray
(
ar
)
{
return
Array
.
isArray
(
ar
)
;
}
exports
.
isArray
=
isArray
;
function
isBoolean
(
arg
)
{
return
typeof
arg
=
=
=
'
boolean
'
;
}
exports
.
isBoolean
=
isBoolean
;
function
isNull
(
arg
)
{
return
arg
=
=
=
null
;
}
exports
.
isNull
=
isNull
;
function
isNullOrUndefined
(
arg
)
{
return
arg
=
=
null
;
}
exports
.
isNullOrUndefined
=
isNullOrUndefined
;
function
isNumber
(
arg
)
{
return
typeof
arg
=
=
=
'
number
'
;
}
exports
.
isNumber
=
isNumber
;
function
isString
(
arg
)
{
return
typeof
arg
=
=
=
'
string
'
;
}
exports
.
isString
=
isString
;
function
isSymbol
(
arg
)
{
return
typeof
arg
=
=
=
'
symbol
'
;
}
exports
.
isSymbol
=
isSymbol
;
function
isUndefined
(
arg
)
{
return
arg
=
=
=
void
0
;
}
exports
.
isUndefined
=
isUndefined
;
function
isRegExp
(
re
)
{
return
isObject
(
re
)
&
&
objectToString
(
re
)
=
=
=
'
[
object
RegExp
]
'
;
}
exports
.
isRegExp
=
isRegExp
;
function
isObject
(
arg
)
{
return
typeof
arg
=
=
=
'
object
'
&
&
arg
!
=
=
null
;
}
exports
.
isObject
=
isObject
;
function
isDate
(
d
)
{
return
isObject
(
d
)
&
&
objectToString
(
d
)
=
=
=
'
[
object
Date
]
'
;
}
exports
.
isDate
=
isDate
;
function
isError
(
e
)
{
return
isObject
(
e
)
&
&
(
objectToString
(
e
)
=
=
=
'
[
object
Error
]
'
|
|
e
instanceof
Error
)
;
}
exports
.
isError
=
isError
;
function
isFunction
(
arg
)
{
return
typeof
arg
=
=
=
'
function
'
;
}
exports
.
isFunction
=
isFunction
;
function
isPrimitive
(
arg
)
{
return
arg
=
=
=
null
|
|
typeof
arg
=
=
=
'
boolean
'
|
|
typeof
arg
=
=
=
'
number
'
|
|
typeof
arg
=
=
=
'
string
'
|
|
typeof
arg
=
=
=
'
symbol
'
|
|
typeof
arg
=
=
=
'
undefined
'
;
}
exports
.
isPrimitive
=
isPrimitive
;
exports
.
isBuffer
=
require
(
'
.
/
support
/
isBuffer
'
)
;
function
objectToString
(
o
)
{
return
Object
.
prototype
.
toString
.
call
(
o
)
;
}
function
pad
(
n
)
{
return
n
<
10
?
'
0
'
+
n
.
toString
(
10
)
:
n
.
toString
(
10
)
;
}
var
months
=
[
'
Jan
'
'
Feb
'
'
Mar
'
'
Apr
'
'
May
'
'
Jun
'
'
Jul
'
'
Aug
'
'
Sep
'
'
Oct
'
'
Nov
'
'
Dec
'
]
;
function
timestamp
(
)
{
var
d
=
new
Date
(
)
;
var
time
=
[
pad
(
d
.
getHours
(
)
)
pad
(
d
.
getMinutes
(
)
)
pad
(
d
.
getSeconds
(
)
)
]
.
join
(
'
:
'
)
;
return
[
d
.
getDate
(
)
months
[
d
.
getMonth
(
)
]
time
]
.
join
(
'
'
)
;
}
exports
.
log
=
function
(
)
{
console
.
log
(
'
%
s
-
%
s
'
timestamp
(
)
exports
.
format
.
apply
(
exports
arguments
)
)
;
}
;
exports
.
inherits
=
require
(
'
inherits
'
)
;
exports
.
_extend
=
function
(
origin
add
)
{
if
(
!
add
|
|
!
isObject
(
add
)
)
return
origin
;
var
keys
=
Object
.
keys
(
add
)
;
var
i
=
keys
.
length
;
while
(
i
-
-
)
{
origin
[
keys
[
i
]
]
=
add
[
keys
[
i
]
]
;
}
return
origin
;
}
;
function
hasOwnProperty
(
obj
prop
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
prop
)
;
}
}
)
.
call
(
this
require
(
'
_process
'
)
typeof
global
!
=
=
"
undefined
"
?
global
:
typeof
self
!
=
=
"
undefined
"
?
self
:
typeof
window
!
=
=
"
undefined
"
?
window
:
{
}
)
}
{
"
.
/
support
/
isBuffer
"
:
98
"
_process
"
:
82
"
inherits
"
:
97
}
]
}
{
}
[
1
]
)
;
}
794
:
function
(
module
exports
__webpack_require__
)
{
(
function
(
global
)
{
'
use
strict
'
var
base64
=
__webpack_require__
(
795
)
var
ieee754
=
__webpack_require__
(
796
)
var
isArray
=
__webpack_require__
(
797
)
exports
.
Buffer
=
Buffer
exports
.
SlowBuffer
=
SlowBuffer
exports
.
INSPECT_MAX_BYTES
=
50
Buffer
.
TYPED_ARRAY_SUPPORT
=
global
.
TYPED_ARRAY_SUPPORT
!
=
=
undefined
?
global
.
TYPED_ARRAY_SUPPORT
:
typedArraySupport
(
)
exports
.
kMaxLength
=
kMaxLength
(
)
function
typedArraySupport
(
)
{
try
{
var
arr
=
new
Uint8Array
(
1
)
arr
.
__proto__
=
{
__proto__
:
Uint8Array
.
prototype
foo
:
function
(
)
{
return
42
}
}
return
arr
.
foo
(
)
=
=
=
42
&
&
typeof
arr
.
subarray
=
=
=
'
function
'
&
&
arr
.
subarray
(
1
1
)
.
byteLength
=
=
=
0
}
catch
(
e
)
{
return
false
}
}
function
kMaxLength
(
)
{
return
Buffer
.
TYPED_ARRAY_SUPPORT
?
0x7fffffff
:
0x3fffffff
}
function
createBuffer
(
that
length
)
{
if
(
kMaxLength
(
)
<
length
)
{
throw
new
RangeError
(
'
Invalid
typed
array
length
'
)
}
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
that
=
new
Uint8Array
(
length
)
that
.
__proto__
=
Buffer
.
prototype
}
else
{
if
(
that
=
=
=
null
)
{
that
=
new
Buffer
(
length
)
}
that
.
length
=
length
}
return
that
}
function
Buffer
(
arg
encodingOrOffset
length
)
{
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
&
&
!
(
this
instanceof
Buffer
)
)
{
return
new
Buffer
(
arg
encodingOrOffset
length
)
}
if
(
typeof
arg
=
=
=
'
number
'
)
{
if
(
typeof
encodingOrOffset
=
=
=
'
string
'
)
{
throw
new
Error
(
'
If
encoding
is
specified
then
the
first
argument
must
be
a
string
'
)
}
return
allocUnsafe
(
this
arg
)
}
return
from
(
this
arg
encodingOrOffset
length
)
}
Buffer
.
poolSize
=
8192
Buffer
.
_augment
=
function
(
arr
)
{
arr
.
__proto__
=
Buffer
.
prototype
return
arr
}
function
from
(
that
value
encodingOrOffset
length
)
{
if
(
typeof
value
=
=
=
'
number
'
)
{
throw
new
TypeError
(
'
"
value
"
argument
must
not
be
a
number
'
)
}
if
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
value
instanceof
ArrayBuffer
)
{
return
fromArrayBuffer
(
that
value
encodingOrOffset
length
)
}
if
(
typeof
value
=
=
=
'
string
'
)
{
return
fromString
(
that
value
encodingOrOffset
)
}
return
fromObject
(
that
value
)
}
Buffer
.
from
=
function
(
value
encodingOrOffset
length
)
{
return
from
(
null
value
encodingOrOffset
length
)
}
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
Buffer
.
prototype
.
__proto__
=
Uint8Array
.
prototype
Buffer
.
__proto__
=
Uint8Array
if
(
typeof
Symbol
!
=
=
'
undefined
'
&
&
Symbol
.
species
&
&
Buffer
[
Symbol
.
species
]
=
=
=
Buffer
)
{
Object
.
defineProperty
(
Buffer
Symbol
.
species
{
value
:
null
configurable
:
true
}
)
}
}
function
assertSize
(
size
)
{
if
(
typeof
size
!
=
=
'
number
'
)
{
throw
new
TypeError
(
'
"
size
"
argument
must
be
a
number
'
)
}
else
if
(
size
<
0
)
{
throw
new
RangeError
(
'
"
size
"
argument
must
not
be
negative
'
)
}
}
function
alloc
(
that
size
fill
encoding
)
{
assertSize
(
size
)
if
(
size
<
=
0
)
{
return
createBuffer
(
that
size
)
}
if
(
fill
!
=
=
undefined
)
{
return
typeof
encoding
=
=
=
'
string
'
?
createBuffer
(
that
size
)
.
fill
(
fill
encoding
)
:
createBuffer
(
that
size
)
.
fill
(
fill
)
}
return
createBuffer
(
that
size
)
}
Buffer
.
alloc
=
function
(
size
fill
encoding
)
{
return
alloc
(
null
size
fill
encoding
)
}
function
allocUnsafe
(
that
size
)
{
assertSize
(
size
)
that
=
createBuffer
(
that
size
<
0
?
0
:
checked
(
size
)
|
0
)
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
for
(
var
i
=
0
;
i
<
size
;
+
+
i
)
{
that
[
i
]
=
0
}
}
return
that
}
Buffer
.
allocUnsafe
=
function
(
size
)
{
return
allocUnsafe
(
null
size
)
}
Buffer
.
allocUnsafeSlow
=
function
(
size
)
{
return
allocUnsafe
(
null
size
)
}
function
fromString
(
that
string
encoding
)
{
if
(
typeof
encoding
!
=
=
'
string
'
|
|
encoding
=
=
=
'
'
)
{
encoding
=
'
utf8
'
}
if
(
!
Buffer
.
isEncoding
(
encoding
)
)
{
throw
new
TypeError
(
'
"
encoding
"
must
be
a
valid
string
encoding
'
)
}
var
length
=
byteLength
(
string
encoding
)
|
0
that
=
createBuffer
(
that
length
)
var
actual
=
that
.
write
(
string
encoding
)
if
(
actual
!
=
=
length
)
{
that
=
that
.
slice
(
0
actual
)
}
return
that
}
function
fromArrayLike
(
that
array
)
{
var
length
=
array
.
length
<
0
?
0
:
checked
(
array
.
length
)
|
0
that
=
createBuffer
(
that
length
)
for
(
var
i
=
0
;
i
<
length
;
i
+
=
1
)
{
that
[
i
]
=
array
[
i
]
&
255
}
return
that
}
function
fromArrayBuffer
(
that
array
byteOffset
length
)
{
array
.
byteLength
if
(
byteOffset
<
0
|
|
array
.
byteLength
<
byteOffset
)
{
throw
new
RangeError
(
'
\
'
offset
\
'
is
out
of
bounds
'
)
}
if
(
array
.
byteLength
<
byteOffset
+
(
length
|
|
0
)
)
{
throw
new
RangeError
(
'
\
'
length
\
'
is
out
of
bounds
'
)
}
if
(
byteOffset
=
=
=
undefined
&
&
length
=
=
=
undefined
)
{
array
=
new
Uint8Array
(
array
)
}
else
if
(
length
=
=
=
undefined
)
{
array
=
new
Uint8Array
(
array
byteOffset
)
}
else
{
array
=
new
Uint8Array
(
array
byteOffset
length
)
}
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
that
=
array
that
.
__proto__
=
Buffer
.
prototype
}
else
{
that
=
fromArrayLike
(
that
array
)
}
return
that
}
function
fromObject
(
that
obj
)
{
if
(
Buffer
.
isBuffer
(
obj
)
)
{
var
len
=
checked
(
obj
.
length
)
|
0
that
=
createBuffer
(
that
len
)
if
(
that
.
length
=
=
=
0
)
{
return
that
}
obj
.
copy
(
that
0
0
len
)
return
that
}
if
(
obj
)
{
if
(
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
obj
.
buffer
instanceof
ArrayBuffer
)
|
|
'
length
'
in
obj
)
{
if
(
typeof
obj
.
length
!
=
=
'
number
'
|
|
isnan
(
obj
.
length
)
)
{
return
createBuffer
(
that
0
)
}
return
fromArrayLike
(
that
obj
)
}
if
(
obj
.
type
=
=
=
'
Buffer
'
&
&
isArray
(
obj
.
data
)
)
{
return
fromArrayLike
(
that
obj
.
data
)
}
}
throw
new
TypeError
(
'
First
argument
must
be
a
string
Buffer
ArrayBuffer
Array
or
array
-
like
object
.
'
)
}
function
checked
(
length
)
{
if
(
length
>
=
kMaxLength
(
)
)
{
throw
new
RangeError
(
'
Attempt
to
allocate
Buffer
larger
than
maximum
'
+
'
size
:
0x
'
+
kMaxLength
(
)
.
toString
(
16
)
+
'
bytes
'
)
}
return
length
|
0
}
function
SlowBuffer
(
length
)
{
if
(
+
length
!
=
length
)
{
length
=
0
}
return
Buffer
.
alloc
(
+
length
)
}
Buffer
.
isBuffer
=
function
isBuffer
(
b
)
{
return
!
!
(
b
!
=
null
&
&
b
.
_isBuffer
)
}
Buffer
.
compare
=
function
compare
(
a
b
)
{
if
(
!
Buffer
.
isBuffer
(
a
)
|
|
!
Buffer
.
isBuffer
(
b
)
)
{
throw
new
TypeError
(
'
Arguments
must
be
Buffers
'
)
}
if
(
a
=
=
=
b
)
return
0
var
x
=
a
.
length
var
y
=
b
.
length
for
(
var
i
=
0
len
=
Math
.
min
(
x
y
)
;
i
<
len
;
+
+
i
)
{
if
(
a
[
i
]
!
=
=
b
[
i
]
)
{
x
=
a
[
i
]
y
=
b
[
i
]
break
}
}
if
(
x
<
y
)
return
-
1
if
(
y
<
x
)
return
1
return
0
}
Buffer
.
isEncoding
=
function
isEncoding
(
encoding
)
{
switch
(
String
(
encoding
)
.
toLowerCase
(
)
)
{
case
'
hex
'
:
case
'
utf8
'
:
case
'
utf
-
8
'
:
case
'
ascii
'
:
case
'
latin1
'
:
case
'
binary
'
:
case
'
base64
'
:
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
true
default
:
return
false
}
}
Buffer
.
concat
=
function
concat
(
list
length
)
{
if
(
!
isArray
(
list
)
)
{
throw
new
TypeError
(
'
"
list
"
argument
must
be
an
Array
of
Buffers
'
)
}
if
(
list
.
length
=
=
=
0
)
{
return
Buffer
.
alloc
(
0
)
}
var
i
if
(
length
=
=
=
undefined
)
{
length
=
0
for
(
i
=
0
;
i
<
list
.
length
;
+
+
i
)
{
length
+
=
list
[
i
]
.
length
}
}
var
buffer
=
Buffer
.
allocUnsafe
(
length
)
var
pos
=
0
for
(
i
=
0
;
i
<
list
.
length
;
+
+
i
)
{
var
buf
=
list
[
i
]
if
(
!
Buffer
.
isBuffer
(
buf
)
)
{
throw
new
TypeError
(
'
"
list
"
argument
must
be
an
Array
of
Buffers
'
)
}
buf
.
copy
(
buffer
pos
)
pos
+
=
buf
.
length
}
return
buffer
}
function
byteLength
(
string
encoding
)
{
if
(
Buffer
.
isBuffer
(
string
)
)
{
return
string
.
length
}
if
(
typeof
ArrayBuffer
!
=
=
'
undefined
'
&
&
typeof
ArrayBuffer
.
isView
=
=
=
'
function
'
&
&
(
ArrayBuffer
.
isView
(
string
)
|
|
string
instanceof
ArrayBuffer
)
)
{
return
string
.
byteLength
}
if
(
typeof
string
!
=
=
'
string
'
)
{
string
=
'
'
+
string
}
var
len
=
string
.
length
if
(
len
=
=
=
0
)
return
0
var
loweredCase
=
false
for
(
;
;
)
{
switch
(
encoding
)
{
case
'
ascii
'
:
case
'
latin1
'
:
case
'
binary
'
:
return
len
case
'
utf8
'
:
case
'
utf
-
8
'
:
case
undefined
:
return
utf8ToBytes
(
string
)
.
length
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
len
*
2
case
'
hex
'
:
return
len
>
>
>
1
case
'
base64
'
:
return
base64ToBytes
(
string
)
.
length
default
:
if
(
loweredCase
)
return
utf8ToBytes
(
string
)
.
length
encoding
=
(
'
'
+
encoding
)
.
toLowerCase
(
)
loweredCase
=
true
}
}
}
Buffer
.
byteLength
=
byteLength
function
slowToString
(
encoding
start
end
)
{
var
loweredCase
=
false
if
(
start
=
=
=
undefined
|
|
start
<
0
)
{
start
=
0
}
if
(
start
>
this
.
length
)
{
return
'
'
}
if
(
end
=
=
=
undefined
|
|
end
>
this
.
length
)
{
end
=
this
.
length
}
if
(
end
<
=
0
)
{
return
'
'
}
end
>
>
>
=
0
start
>
>
>
=
0
if
(
end
<
=
start
)
{
return
'
'
}
if
(
!
encoding
)
encoding
=
'
utf8
'
while
(
true
)
{
switch
(
encoding
)
{
case
'
hex
'
:
return
hexSlice
(
this
start
end
)
case
'
utf8
'
:
case
'
utf
-
8
'
:
return
utf8Slice
(
this
start
end
)
case
'
ascii
'
:
return
asciiSlice
(
this
start
end
)
case
'
latin1
'
:
case
'
binary
'
:
return
latin1Slice
(
this
start
end
)
case
'
base64
'
:
return
base64Slice
(
this
start
end
)
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
utf16leSlice
(
this
start
end
)
default
:
if
(
loweredCase
)
throw
new
TypeError
(
'
Unknown
encoding
:
'
+
encoding
)
encoding
=
(
encoding
+
'
'
)
.
toLowerCase
(
)
loweredCase
=
true
}
}
}
Buffer
.
prototype
.
_isBuffer
=
true
function
swap
(
b
n
m
)
{
var
i
=
b
[
n
]
b
[
n
]
=
b
[
m
]
b
[
m
]
=
i
}
Buffer
.
prototype
.
swap16
=
function
swap16
(
)
{
var
len
=
this
.
length
if
(
len
%
2
!
=
=
0
)
{
throw
new
RangeError
(
'
Buffer
size
must
be
a
multiple
of
16
-
bits
'
)
}
for
(
var
i
=
0
;
i
<
len
;
i
+
=
2
)
{
swap
(
this
i
i
+
1
)
}
return
this
}
Buffer
.
prototype
.
swap32
=
function
swap32
(
)
{
var
len
=
this
.
length
if
(
len
%
4
!
=
=
0
)
{
throw
new
RangeError
(
'
Buffer
size
must
be
a
multiple
of
32
-
bits
'
)
}
for
(
var
i
=
0
;
i
<
len
;
i
+
=
4
)
{
swap
(
this
i
i
+
3
)
swap
(
this
i
+
1
i
+
2
)
}
return
this
}
Buffer
.
prototype
.
swap64
=
function
swap64
(
)
{
var
len
=
this
.
length
if
(
len
%
8
!
=
=
0
)
{
throw
new
RangeError
(
'
Buffer
size
must
be
a
multiple
of
64
-
bits
'
)
}
for
(
var
i
=
0
;
i
<
len
;
i
+
=
8
)
{
swap
(
this
i
i
+
7
)
swap
(
this
i
+
1
i
+
6
)
swap
(
this
i
+
2
i
+
5
)
swap
(
this
i
+
3
i
+
4
)
}
return
this
}
Buffer
.
prototype
.
toString
=
function
toString
(
)
{
var
length
=
this
.
length
|
0
if
(
length
=
=
=
0
)
return
'
'
if
(
arguments
.
length
=
=
=
0
)
return
utf8Slice
(
this
0
length
)
return
slowToString
.
apply
(
this
arguments
)
}
Buffer
.
prototype
.
equals
=
function
equals
(
b
)
{
if
(
!
Buffer
.
isBuffer
(
b
)
)
throw
new
TypeError
(
'
Argument
must
be
a
Buffer
'
)
if
(
this
=
=
=
b
)
return
true
return
Buffer
.
compare
(
this
b
)
=
=
=
0
}
Buffer
.
prototype
.
inspect
=
function
inspect
(
)
{
var
str
=
'
'
var
max
=
exports
.
INSPECT_MAX_BYTES
if
(
this
.
length
>
0
)
{
str
=
this
.
toString
(
'
hex
'
0
max
)
.
match
(
/
.
{
2
}
/
g
)
.
join
(
'
'
)
if
(
this
.
length
>
max
)
str
+
=
'
.
.
.
'
}
return
'
<
Buffer
'
+
str
+
'
>
'
}
Buffer
.
prototype
.
compare
=
function
compare
(
target
start
end
thisStart
thisEnd
)
{
if
(
!
Buffer
.
isBuffer
(
target
)
)
{
throw
new
TypeError
(
'
Argument
must
be
a
Buffer
'
)
}
if
(
start
=
=
=
undefined
)
{
start
=
0
}
if
(
end
=
=
=
undefined
)
{
end
=
target
?
target
.
length
:
0
}
if
(
thisStart
=
=
=
undefined
)
{
thisStart
=
0
}
if
(
thisEnd
=
=
=
undefined
)
{
thisEnd
=
this
.
length
}
if
(
start
<
0
|
|
end
>
target
.
length
|
|
thisStart
<
0
|
|
thisEnd
>
this
.
length
)
{
throw
new
RangeError
(
'
out
of
range
index
'
)
}
if
(
thisStart
>
=
thisEnd
&
&
start
>
=
end
)
{
return
0
}
if
(
thisStart
>
=
thisEnd
)
{
return
-
1
}
if
(
start
>
=
end
)
{
return
1
}
start
>
>
>
=
0
end
>
>
>
=
0
thisStart
>
>
>
=
0
thisEnd
>
>
>
=
0
if
(
this
=
=
=
target
)
return
0
var
x
=
thisEnd
-
thisStart
var
y
=
end
-
start
var
len
=
Math
.
min
(
x
y
)
var
thisCopy
=
this
.
slice
(
thisStart
thisEnd
)
var
targetCopy
=
target
.
slice
(
start
end
)
for
(
var
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
thisCopy
[
i
]
!
=
=
targetCopy
[
i
]
)
{
x
=
thisCopy
[
i
]
y
=
targetCopy
[
i
]
break
}
}
if
(
x
<
y
)
return
-
1
if
(
y
<
x
)
return
1
return
0
}
function
bidirectionalIndexOf
(
buffer
val
byteOffset
encoding
dir
)
{
if
(
buffer
.
length
=
=
=
0
)
return
-
1
if
(
typeof
byteOffset
=
=
=
'
string
'
)
{
encoding
=
byteOffset
byteOffset
=
0
}
else
if
(
byteOffset
>
0x7fffffff
)
{
byteOffset
=
0x7fffffff
}
else
if
(
byteOffset
<
-
0x80000000
)
{
byteOffset
=
-
0x80000000
}
byteOffset
=
+
byteOffset
if
(
isNaN
(
byteOffset
)
)
{
byteOffset
=
dir
?
0
:
(
buffer
.
length
-
1
)
}
if
(
byteOffset
<
0
)
byteOffset
=
buffer
.
length
+
byteOffset
if
(
byteOffset
>
=
buffer
.
length
)
{
if
(
dir
)
return
-
1
else
byteOffset
=
buffer
.
length
-
1
}
else
if
(
byteOffset
<
0
)
{
if
(
dir
)
byteOffset
=
0
else
return
-
1
}
if
(
typeof
val
=
=
=
'
string
'
)
{
val
=
Buffer
.
from
(
val
encoding
)
}
if
(
Buffer
.
isBuffer
(
val
)
)
{
if
(
val
.
length
=
=
=
0
)
{
return
-
1
}
return
arrayIndexOf
(
buffer
val
byteOffset
encoding
dir
)
}
else
if
(
typeof
val
=
=
=
'
number
'
)
{
val
=
val
&
0xFF
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
&
&
typeof
Uint8Array
.
prototype
.
indexOf
=
=
=
'
function
'
)
{
if
(
dir
)
{
return
Uint8Array
.
prototype
.
indexOf
.
call
(
buffer
val
byteOffset
)
}
else
{
return
Uint8Array
.
prototype
.
lastIndexOf
.
call
(
buffer
val
byteOffset
)
}
}
return
arrayIndexOf
(
buffer
[
val
]
byteOffset
encoding
dir
)
}
throw
new
TypeError
(
'
val
must
be
string
number
or
Buffer
'
)
}
function
arrayIndexOf
(
arr
val
byteOffset
encoding
dir
)
{
var
indexSize
=
1
var
arrLength
=
arr
.
length
var
valLength
=
val
.
length
if
(
encoding
!
=
=
undefined
)
{
encoding
=
String
(
encoding
)
.
toLowerCase
(
)
if
(
encoding
=
=
=
'
ucs2
'
|
|
encoding
=
=
=
'
ucs
-
2
'
|
|
encoding
=
=
=
'
utf16le
'
|
|
encoding
=
=
=
'
utf
-
16le
'
)
{
if
(
arr
.
length
<
2
|
|
val
.
length
<
2
)
{
return
-
1
}
indexSize
=
2
arrLength
/
=
2
valLength
/
=
2
byteOffset
/
=
2
}
}
function
read
(
buf
i
)
{
if
(
indexSize
=
=
=
1
)
{
return
buf
[
i
]
}
else
{
return
buf
.
readUInt16BE
(
i
*
indexSize
)
}
}
var
i
if
(
dir
)
{
var
foundIndex
=
-
1
for
(
i
=
byteOffset
;
i
<
arrLength
;
i
+
+
)
{
if
(
read
(
arr
i
)
=
=
=
read
(
val
foundIndex
=
=
=
-
1
?
0
:
i
-
foundIndex
)
)
{
if
(
foundIndex
=
=
=
-
1
)
foundIndex
=
i
if
(
i
-
foundIndex
+
1
=
=
=
valLength
)
return
foundIndex
*
indexSize
}
else
{
if
(
foundIndex
!
=
=
-
1
)
i
-
=
i
-
foundIndex
foundIndex
=
-
1
}
}
}
else
{
if
(
byteOffset
+
valLength
>
arrLength
)
byteOffset
=
arrLength
-
valLength
for
(
i
=
byteOffset
;
i
>
=
0
;
i
-
-
)
{
var
found
=
true
for
(
var
j
=
0
;
j
<
valLength
;
j
+
+
)
{
if
(
read
(
arr
i
+
j
)
!
=
=
read
(
val
j
)
)
{
found
=
false
break
}
}
if
(
found
)
return
i
}
}
return
-
1
}
Buffer
.
prototype
.
includes
=
function
includes
(
val
byteOffset
encoding
)
{
return
this
.
indexOf
(
val
byteOffset
encoding
)
!
=
=
-
1
}
Buffer
.
prototype
.
indexOf
=
function
indexOf
(
val
byteOffset
encoding
)
{
return
bidirectionalIndexOf
(
this
val
byteOffset
encoding
true
)
}
Buffer
.
prototype
.
lastIndexOf
=
function
lastIndexOf
(
val
byteOffset
encoding
)
{
return
bidirectionalIndexOf
(
this
val
byteOffset
encoding
false
)
}
function
hexWrite
(
buf
string
offset
length
)
{
offset
=
Number
(
offset
)
|
|
0
var
remaining
=
buf
.
length
-
offset
if
(
!
length
)
{
length
=
remaining
}
else
{
length
=
Number
(
length
)
if
(
length
>
remaining
)
{
length
=
remaining
}
}
var
strLen
=
string
.
length
if
(
strLen
%
2
!
=
=
0
)
throw
new
TypeError
(
'
Invalid
hex
string
'
)
if
(
length
>
strLen
/
2
)
{
length
=
strLen
/
2
}
for
(
var
i
=
0
;
i
<
length
;
+
+
i
)
{
var
parsed
=
parseInt
(
string
.
substr
(
i
*
2
2
)
16
)
if
(
isNaN
(
parsed
)
)
return
i
buf
[
offset
+
i
]
=
parsed
}
return
i
}
function
utf8Write
(
buf
string
offset
length
)
{
return
blitBuffer
(
utf8ToBytes
(
string
buf
.
length
-
offset
)
buf
offset
length
)
}
function
asciiWrite
(
buf
string
offset
length
)
{
return
blitBuffer
(
asciiToBytes
(
string
)
buf
offset
length
)
}
function
latin1Write
(
buf
string
offset
length
)
{
return
asciiWrite
(
buf
string
offset
length
)
}
function
base64Write
(
buf
string
offset
length
)
{
return
blitBuffer
(
base64ToBytes
(
string
)
buf
offset
length
)
}
function
ucs2Write
(
buf
string
offset
length
)
{
return
blitBuffer
(
utf16leToBytes
(
string
buf
.
length
-
offset
)
buf
offset
length
)
}
Buffer
.
prototype
.
write
=
function
write
(
string
offset
length
encoding
)
{
if
(
offset
=
=
=
undefined
)
{
encoding
=
'
utf8
'
length
=
this
.
length
offset
=
0
}
else
if
(
length
=
=
=
undefined
&
&
typeof
offset
=
=
=
'
string
'
)
{
encoding
=
offset
length
=
this
.
length
offset
=
0
}
else
if
(
isFinite
(
offset
)
)
{
offset
=
offset
|
0
if
(
isFinite
(
length
)
)
{
length
=
length
|
0
if
(
encoding
=
=
=
undefined
)
encoding
=
'
utf8
'
}
else
{
encoding
=
length
length
=
undefined
}
}
else
{
throw
new
Error
(
'
Buffer
.
write
(
string
encoding
offset
[
length
]
)
is
no
longer
supported
'
)
}
var
remaining
=
this
.
length
-
offset
if
(
length
=
=
=
undefined
|
|
length
>
remaining
)
length
=
remaining
if
(
(
string
.
length
>
0
&
&
(
length
<
0
|
|
offset
<
0
)
)
|
|
offset
>
this
.
length
)
{
throw
new
RangeError
(
'
Attempt
to
write
outside
buffer
bounds
'
)
}
if
(
!
encoding
)
encoding
=
'
utf8
'
var
loweredCase
=
false
for
(
;
;
)
{
switch
(
encoding
)
{
case
'
hex
'
:
return
hexWrite
(
this
string
offset
length
)
case
'
utf8
'
:
case
'
utf
-
8
'
:
return
utf8Write
(
this
string
offset
length
)
case
'
ascii
'
:
return
asciiWrite
(
this
string
offset
length
)
case
'
latin1
'
:
case
'
binary
'
:
return
latin1Write
(
this
string
offset
length
)
case
'
base64
'
:
return
base64Write
(
this
string
offset
length
)
case
'
ucs2
'
:
case
'
ucs
-
2
'
:
case
'
utf16le
'
:
case
'
utf
-
16le
'
:
return
ucs2Write
(
this
string
offset
length
)
default
:
if
(
loweredCase
)
throw
new
TypeError
(
'
Unknown
encoding
:
'
+
encoding
)
encoding
=
(
'
'
+
encoding
)
.
toLowerCase
(
)
loweredCase
=
true
}
}
}
Buffer
.
prototype
.
toJSON
=
function
toJSON
(
)
{
return
{
type
:
'
Buffer
'
data
:
Array
.
prototype
.
slice
.
call
(
this
.
_arr
|
|
this
0
)
}
}
function
base64Slice
(
buf
start
end
)
{
if
(
start
=
=
=
0
&
&
end
=
=
=
buf
.
length
)
{
return
base64
.
fromByteArray
(
buf
)
}
else
{
return
base64
.
fromByteArray
(
buf
.
slice
(
start
end
)
)
}
}
function
utf8Slice
(
buf
start
end
)
{
end
=
Math
.
min
(
buf
.
length
end
)
var
res
=
[
]
var
i
=
start
while
(
i
<
end
)
{
var
firstByte
=
buf
[
i
]
var
codePoint
=
null
var
bytesPerSequence
=
(
firstByte
>
0xEF
)
?
4
:
(
firstByte
>
0xDF
)
?
3
:
(
firstByte
>
0xBF
)
?
2
:
1
if
(
i
+
bytesPerSequence
<
=
end
)
{
var
secondByte
thirdByte
fourthByte
tempCodePoint
switch
(
bytesPerSequence
)
{
case
1
:
if
(
firstByte
<
0x80
)
{
codePoint
=
firstByte
}
break
case
2
:
secondByte
=
buf
[
i
+
1
]
if
(
(
secondByte
&
0xC0
)
=
=
=
0x80
)
{
tempCodePoint
=
(
firstByte
&
0x1F
)
<
<
0x6
|
(
secondByte
&
0x3F
)
if
(
tempCodePoint
>
0x7F
)
{
codePoint
=
tempCodePoint
}
}
break
case
3
:
secondByte
=
buf
[
i
+
1
]
thirdByte
=
buf
[
i
+
2
]
if
(
(
secondByte
&
0xC0
)
=
=
=
0x80
&
&
(
thirdByte
&
0xC0
)
=
=
=
0x80
)
{
tempCodePoint
=
(
firstByte
&
0xF
)
<
<
0xC
|
(
secondByte
&
0x3F
)
<
<
0x6
|
(
thirdByte
&
0x3F
)
if
(
tempCodePoint
>
0x7FF
&
&
(
tempCodePoint
<
0xD800
|
|
tempCodePoint
>
0xDFFF
)
)
{
codePoint
=
tempCodePoint
}
}
break
case
4
:
secondByte
=
buf
[
i
+
1
]
thirdByte
=
buf
[
i
+
2
]
fourthByte
=
buf
[
i
+
3
]
if
(
(
secondByte
&
0xC0
)
=
=
=
0x80
&
&
(
thirdByte
&
0xC0
)
=
=
=
0x80
&
&
(
fourthByte
&
0xC0
)
=
=
=
0x80
)
{
tempCodePoint
=
(
firstByte
&
0xF
)
<
<
0x12
|
(
secondByte
&
0x3F
)
<
<
0xC
|
(
thirdByte
&
0x3F
)
<
<
0x6
|
(
fourthByte
&
0x3F
)
if
(
tempCodePoint
>
0xFFFF
&
&
tempCodePoint
<
0x110000
)
{
codePoint
=
tempCodePoint
}
}
}
}
if
(
codePoint
=
=
=
null
)
{
codePoint
=
0xFFFD
bytesPerSequence
=
1
}
else
if
(
codePoint
>
0xFFFF
)
{
codePoint
-
=
0x10000
res
.
push
(
codePoint
>
>
>
10
&
0x3FF
|
0xD800
)
codePoint
=
0xDC00
|
codePoint
&
0x3FF
}
res
.
push
(
codePoint
)
i
+
=
bytesPerSequence
}
return
decodeCodePointsArray
(
res
)
}
var
MAX_ARGUMENTS_LENGTH
=
0x1000
function
decodeCodePointsArray
(
codePoints
)
{
var
len
=
codePoints
.
length
if
(
len
<
=
MAX_ARGUMENTS_LENGTH
)
{
return
String
.
fromCharCode
.
apply
(
String
codePoints
)
}
var
res
=
'
'
var
i
=
0
while
(
i
<
len
)
{
res
+
=
String
.
fromCharCode
.
apply
(
String
codePoints
.
slice
(
i
i
+
=
MAX_ARGUMENTS_LENGTH
)
)
}
return
res
}
function
asciiSlice
(
buf
start
end
)
{
var
ret
=
'
'
end
=
Math
.
min
(
buf
.
length
end
)
for
(
var
i
=
start
;
i
<
end
;
+
+
i
)
{
ret
+
=
String
.
fromCharCode
(
buf
[
i
]
&
0x7F
)
}
return
ret
}
function
latin1Slice
(
buf
start
end
)
{
var
ret
=
'
'
end
=
Math
.
min
(
buf
.
length
end
)
for
(
var
i
=
start
;
i
<
end
;
+
+
i
)
{
ret
+
=
String
.
fromCharCode
(
buf
[
i
]
)
}
return
ret
}
function
hexSlice
(
buf
start
end
)
{
var
len
=
buf
.
length
if
(
!
start
|
|
start
<
0
)
start
=
0
if
(
!
end
|
|
end
<
0
|
|
end
>
len
)
end
=
len
var
out
=
'
'
for
(
var
i
=
start
;
i
<
end
;
+
+
i
)
{
out
+
=
toHex
(
buf
[
i
]
)
}
return
out
}
function
utf16leSlice
(
buf
start
end
)
{
var
bytes
=
buf
.
slice
(
start
end
)
var
res
=
'
'
for
(
var
i
=
0
;
i
<
bytes
.
length
;
i
+
=
2
)
{
res
+
=
String
.
fromCharCode
(
bytes
[
i
]
+
bytes
[
i
+
1
]
*
256
)
}
return
res
}
Buffer
.
prototype
.
slice
=
function
slice
(
start
end
)
{
var
len
=
this
.
length
start
=
~
~
start
end
=
end
=
=
=
undefined
?
len
:
~
~
end
if
(
start
<
0
)
{
start
+
=
len
if
(
start
<
0
)
start
=
0
}
else
if
(
start
>
len
)
{
start
=
len
}
if
(
end
<
0
)
{
end
+
=
len
if
(
end
<
0
)
end
=
0
}
else
if
(
end
>
len
)
{
end
=
len
}
if
(
end
<
start
)
end
=
start
var
newBuf
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
newBuf
=
this
.
subarray
(
start
end
)
newBuf
.
__proto__
=
Buffer
.
prototype
}
else
{
var
sliceLen
=
end
-
start
newBuf
=
new
Buffer
(
sliceLen
undefined
)
for
(
var
i
=
0
;
i
<
sliceLen
;
+
+
i
)
{
newBuf
[
i
]
=
this
[
i
+
start
]
}
}
return
newBuf
}
function
checkOffset
(
offset
ext
length
)
{
if
(
(
offset
%
1
)
!
=
=
0
|
|
offset
<
0
)
throw
new
RangeError
(
'
offset
is
not
uint
'
)
if
(
offset
+
ext
>
length
)
throw
new
RangeError
(
'
Trying
to
access
beyond
buffer
length
'
)
}
Buffer
.
prototype
.
readUIntLE
=
function
readUIntLE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
checkOffset
(
offset
byteLength
this
.
length
)
var
val
=
this
[
offset
]
var
mul
=
1
var
i
=
0
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
i
]
*
mul
}
return
val
}
Buffer
.
prototype
.
readUIntBE
=
function
readUIntBE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
{
checkOffset
(
offset
byteLength
this
.
length
)
}
var
val
=
this
[
offset
+
-
-
byteLength
]
var
mul
=
1
while
(
byteLength
>
0
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
-
-
byteLength
]
*
mul
}
return
val
}
Buffer
.
prototype
.
readUInt8
=
function
readUInt8
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
1
this
.
length
)
return
this
[
offset
]
}
Buffer
.
prototype
.
readUInt16LE
=
function
readUInt16LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
return
this
[
offset
]
|
(
this
[
offset
+
1
]
<
<
8
)
}
Buffer
.
prototype
.
readUInt16BE
=
function
readUInt16BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
return
(
this
[
offset
]
<
<
8
)
|
this
[
offset
+
1
]
}
Buffer
.
prototype
.
readUInt32LE
=
function
readUInt32LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
(
this
[
offset
]
)
|
(
this
[
offset
+
1
]
<
<
8
)
|
(
this
[
offset
+
2
]
<
<
16
)
)
+
(
this
[
offset
+
3
]
*
0x1000000
)
}
Buffer
.
prototype
.
readUInt32BE
=
function
readUInt32BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
this
[
offset
]
*
0x1000000
)
+
(
(
this
[
offset
+
1
]
<
<
16
)
|
(
this
[
offset
+
2
]
<
<
8
)
|
this
[
offset
+
3
]
)
}
Buffer
.
prototype
.
readIntLE
=
function
readIntLE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
checkOffset
(
offset
byteLength
this
.
length
)
var
val
=
this
[
offset
]
var
mul
=
1
var
i
=
0
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
i
]
*
mul
}
mul
*
=
0x80
if
(
val
>
=
mul
)
val
-
=
Math
.
pow
(
2
8
*
byteLength
)
return
val
}
Buffer
.
prototype
.
readIntBE
=
function
readIntBE
(
offset
byteLength
noAssert
)
{
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
checkOffset
(
offset
byteLength
this
.
length
)
var
i
=
byteLength
var
mul
=
1
var
val
=
this
[
offset
+
-
-
i
]
while
(
i
>
0
&
&
(
mul
*
=
0x100
)
)
{
val
+
=
this
[
offset
+
-
-
i
]
*
mul
}
mul
*
=
0x80
if
(
val
>
=
mul
)
val
-
=
Math
.
pow
(
2
8
*
byteLength
)
return
val
}
Buffer
.
prototype
.
readInt8
=
function
readInt8
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
1
this
.
length
)
if
(
!
(
this
[
offset
]
&
0x80
)
)
return
(
this
[
offset
]
)
return
(
(
0xff
-
this
[
offset
]
+
1
)
*
-
1
)
}
Buffer
.
prototype
.
readInt16LE
=
function
readInt16LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
var
val
=
this
[
offset
]
|
(
this
[
offset
+
1
]
<
<
8
)
return
(
val
&
0x8000
)
?
val
|
0xFFFF0000
:
val
}
Buffer
.
prototype
.
readInt16BE
=
function
readInt16BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
2
this
.
length
)
var
val
=
this
[
offset
+
1
]
|
(
this
[
offset
]
<
<
8
)
return
(
val
&
0x8000
)
?
val
|
0xFFFF0000
:
val
}
Buffer
.
prototype
.
readInt32LE
=
function
readInt32LE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
this
[
offset
]
)
|
(
this
[
offset
+
1
]
<
<
8
)
|
(
this
[
offset
+
2
]
<
<
16
)
|
(
this
[
offset
+
3
]
<
<
24
)
}
Buffer
.
prototype
.
readInt32BE
=
function
readInt32BE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
(
this
[
offset
]
<
<
24
)
|
(
this
[
offset
+
1
]
<
<
16
)
|
(
this
[
offset
+
2
]
<
<
8
)
|
(
this
[
offset
+
3
]
)
}
Buffer
.
prototype
.
readFloatLE
=
function
readFloatLE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
ieee754
.
read
(
this
offset
true
23
4
)
}
Buffer
.
prototype
.
readFloatBE
=
function
readFloatBE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
4
this
.
length
)
return
ieee754
.
read
(
this
offset
false
23
4
)
}
Buffer
.
prototype
.
readDoubleLE
=
function
readDoubleLE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
8
this
.
length
)
return
ieee754
.
read
(
this
offset
true
52
8
)
}
Buffer
.
prototype
.
readDoubleBE
=
function
readDoubleBE
(
offset
noAssert
)
{
if
(
!
noAssert
)
checkOffset
(
offset
8
this
.
length
)
return
ieee754
.
read
(
this
offset
false
52
8
)
}
function
checkInt
(
buf
value
offset
ext
max
min
)
{
if
(
!
Buffer
.
isBuffer
(
buf
)
)
throw
new
TypeError
(
'
"
buffer
"
argument
must
be
a
Buffer
instance
'
)
if
(
value
>
max
|
|
value
<
min
)
throw
new
RangeError
(
'
"
value
"
argument
is
out
of
bounds
'
)
if
(
offset
+
ext
>
buf
.
length
)
throw
new
RangeError
(
'
Index
out
of
range
'
)
}
Buffer
.
prototype
.
writeUIntLE
=
function
writeUIntLE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
{
var
maxBytes
=
Math
.
pow
(
2
8
*
byteLength
)
-
1
checkInt
(
this
value
offset
byteLength
maxBytes
0
)
}
var
mul
=
1
var
i
=
0
this
[
offset
]
=
value
&
0xFF
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
this
[
offset
+
i
]
=
(
value
/
mul
)
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeUIntBE
=
function
writeUIntBE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
byteLength
=
byteLength
|
0
if
(
!
noAssert
)
{
var
maxBytes
=
Math
.
pow
(
2
8
*
byteLength
)
-
1
checkInt
(
this
value
offset
byteLength
maxBytes
0
)
}
var
i
=
byteLength
-
1
var
mul
=
1
this
[
offset
+
i
]
=
value
&
0xFF
while
(
-
-
i
>
=
0
&
&
(
mul
*
=
0x100
)
)
{
this
[
offset
+
i
]
=
(
value
/
mul
)
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeUInt8
=
function
writeUInt8
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
1
0xff
0
)
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
value
=
Math
.
floor
(
value
)
this
[
offset
]
=
(
value
&
0xff
)
return
offset
+
1
}
function
objectWriteUInt16
(
buf
value
offset
littleEndian
)
{
if
(
value
<
0
)
value
=
0xffff
+
value
+
1
for
(
var
i
=
0
j
=
Math
.
min
(
buf
.
length
-
offset
2
)
;
i
<
j
;
+
+
i
)
{
buf
[
offset
+
i
]
=
(
value
&
(
0xff
<
<
(
8
*
(
littleEndian
?
i
:
1
-
i
)
)
)
)
>
>
>
(
littleEndian
?
i
:
1
-
i
)
*
8
}
}
Buffer
.
prototype
.
writeUInt16LE
=
function
writeUInt16LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0xffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
&
0xff
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
}
else
{
objectWriteUInt16
(
this
value
offset
true
)
}
return
offset
+
2
}
Buffer
.
prototype
.
writeUInt16BE
=
function
writeUInt16BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0xffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
8
)
this
[
offset
+
1
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt16
(
this
value
offset
false
)
}
return
offset
+
2
}
function
objectWriteUInt32
(
buf
value
offset
littleEndian
)
{
if
(
value
<
0
)
value
=
0xffffffff
+
value
+
1
for
(
var
i
=
0
j
=
Math
.
min
(
buf
.
length
-
offset
4
)
;
i
<
j
;
+
+
i
)
{
buf
[
offset
+
i
]
=
(
value
>
>
>
(
littleEndian
?
i
:
3
-
i
)
*
8
)
&
0xff
}
}
Buffer
.
prototype
.
writeUInt32LE
=
function
writeUInt32LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0xffffffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
+
3
]
=
(
value
>
>
>
24
)
this
[
offset
+
2
]
=
(
value
>
>
>
16
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
this
[
offset
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt32
(
this
value
offset
true
)
}
return
offset
+
4
}
Buffer
.
prototype
.
writeUInt32BE
=
function
writeUInt32BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0xffffffff
0
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
24
)
this
[
offset
+
1
]
=
(
value
>
>
>
16
)
this
[
offset
+
2
]
=
(
value
>
>
>
8
)
this
[
offset
+
3
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt32
(
this
value
offset
false
)
}
return
offset
+
4
}
Buffer
.
prototype
.
writeIntLE
=
function
writeIntLE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
{
var
limit
=
Math
.
pow
(
2
8
*
byteLength
-
1
)
checkInt
(
this
value
offset
byteLength
limit
-
1
-
limit
)
}
var
i
=
0
var
mul
=
1
var
sub
=
0
this
[
offset
]
=
value
&
0xFF
while
(
+
+
i
<
byteLength
&
&
(
mul
*
=
0x100
)
)
{
if
(
value
<
0
&
&
sub
=
=
=
0
&
&
this
[
offset
+
i
-
1
]
!
=
=
0
)
{
sub
=
1
}
this
[
offset
+
i
]
=
(
(
value
/
mul
)
>
>
0
)
-
sub
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeIntBE
=
function
writeIntBE
(
value
offset
byteLength
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
{
var
limit
=
Math
.
pow
(
2
8
*
byteLength
-
1
)
checkInt
(
this
value
offset
byteLength
limit
-
1
-
limit
)
}
var
i
=
byteLength
-
1
var
mul
=
1
var
sub
=
0
this
[
offset
+
i
]
=
value
&
0xFF
while
(
-
-
i
>
=
0
&
&
(
mul
*
=
0x100
)
)
{
if
(
value
<
0
&
&
sub
=
=
=
0
&
&
this
[
offset
+
i
+
1
]
!
=
=
0
)
{
sub
=
1
}
this
[
offset
+
i
]
=
(
(
value
/
mul
)
>
>
0
)
-
sub
&
0xFF
}
return
offset
+
byteLength
}
Buffer
.
prototype
.
writeInt8
=
function
writeInt8
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
1
0x7f
-
0x80
)
if
(
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
value
=
Math
.
floor
(
value
)
if
(
value
<
0
)
value
=
0xff
+
value
+
1
this
[
offset
]
=
(
value
&
0xff
)
return
offset
+
1
}
Buffer
.
prototype
.
writeInt16LE
=
function
writeInt16LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0x7fff
-
0x8000
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
&
0xff
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
}
else
{
objectWriteUInt16
(
this
value
offset
true
)
}
return
offset
+
2
}
Buffer
.
prototype
.
writeInt16BE
=
function
writeInt16BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
2
0x7fff
-
0x8000
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
8
)
this
[
offset
+
1
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt16
(
this
value
offset
false
)
}
return
offset
+
2
}
Buffer
.
prototype
.
writeInt32LE
=
function
writeInt32LE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0x7fffffff
-
0x80000000
)
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
&
0xff
)
this
[
offset
+
1
]
=
(
value
>
>
>
8
)
this
[
offset
+
2
]
=
(
value
>
>
>
16
)
this
[
offset
+
3
]
=
(
value
>
>
>
24
)
}
else
{
objectWriteUInt32
(
this
value
offset
true
)
}
return
offset
+
4
}
Buffer
.
prototype
.
writeInt32BE
=
function
writeInt32BE
(
value
offset
noAssert
)
{
value
=
+
value
offset
=
offset
|
0
if
(
!
noAssert
)
checkInt
(
this
value
offset
4
0x7fffffff
-
0x80000000
)
if
(
value
<
0
)
value
=
0xffffffff
+
value
+
1
if
(
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
this
[
offset
]
=
(
value
>
>
>
24
)
this
[
offset
+
1
]
=
(
value
>
>
>
16
)
this
[
offset
+
2
]
=
(
value
>
>
>
8
)
this
[
offset
+
3
]
=
(
value
&
0xff
)
}
else
{
objectWriteUInt32
(
this
value
offset
false
)
}
return
offset
+
4
}
function
checkIEEE754
(
buf
value
offset
ext
max
min
)
{
if
(
offset
+
ext
>
buf
.
length
)
throw
new
RangeError
(
'
Index
out
of
range
'
)
if
(
offset
<
0
)
throw
new
RangeError
(
'
Index
out
of
range
'
)
}
function
writeFloat
(
buf
value
offset
littleEndian
noAssert
)
{
if
(
!
noAssert
)
{
checkIEEE754
(
buf
value
offset
4
3
.
4028234663852886e
+
38
-
3
.
4028234663852886e
+
38
)
}
ieee754
.
write
(
buf
value
offset
littleEndian
23
4
)
return
offset
+
4
}
Buffer
.
prototype
.
writeFloatLE
=
function
writeFloatLE
(
value
offset
noAssert
)
{
return
writeFloat
(
this
value
offset
true
noAssert
)
}
Buffer
.
prototype
.
writeFloatBE
=
function
writeFloatBE
(
value
offset
noAssert
)
{
return
writeFloat
(
this
value
offset
false
noAssert
)
}
function
writeDouble
(
buf
value
offset
littleEndian
noAssert
)
{
if
(
!
noAssert
)
{
checkIEEE754
(
buf
value
offset
8
1
.
7976931348623157E
+
308
-
1
.
7976931348623157E
+
308
)
}
ieee754
.
write
(
buf
value
offset
littleEndian
52
8
)
return
offset
+
8
}
Buffer
.
prototype
.
writeDoubleLE
=
function
writeDoubleLE
(
value
offset
noAssert
)
{
return
writeDouble
(
this
value
offset
true
noAssert
)
}
Buffer
.
prototype
.
writeDoubleBE
=
function
writeDoubleBE
(
value
offset
noAssert
)
{
return
writeDouble
(
this
value
offset
false
noAssert
)
}
Buffer
.
prototype
.
copy
=
function
copy
(
target
targetStart
start
end
)
{
if
(
!
start
)
start
=
0
if
(
!
end
&
&
end
!
=
=
0
)
end
=
this
.
length
if
(
targetStart
>
=
target
.
length
)
targetStart
=
target
.
length
if
(
!
targetStart
)
targetStart
=
0
if
(
end
>
0
&
&
end
<
start
)
end
=
start
if
(
end
=
=
=
start
)
return
0
if
(
target
.
length
=
=
=
0
|
|
this
.
length
=
=
=
0
)
return
0
if
(
targetStart
<
0
)
{
throw
new
RangeError
(
'
targetStart
out
of
bounds
'
)
}
if
(
start
<
0
|
|
start
>
=
this
.
length
)
throw
new
RangeError
(
'
sourceStart
out
of
bounds
'
)
if
(
end
<
0
)
throw
new
RangeError
(
'
sourceEnd
out
of
bounds
'
)
if
(
end
>
this
.
length
)
end
=
this
.
length
if
(
target
.
length
-
targetStart
<
end
-
start
)
{
end
=
target
.
length
-
targetStart
+
start
}
var
len
=
end
-
start
var
i
if
(
this
=
=
=
target
&
&
start
<
targetStart
&
&
targetStart
<
end
)
{
for
(
i
=
len
-
1
;
i
>
=
0
;
-
-
i
)
{
target
[
i
+
targetStart
]
=
this
[
i
+
start
]
}
}
else
if
(
len
<
1000
|
|
!
Buffer
.
TYPED_ARRAY_SUPPORT
)
{
for
(
i
=
0
;
i
<
len
;
+
+
i
)
{
target
[
i
+
targetStart
]
=
this
[
i
+
start
]
}
}
else
{
Uint8Array
.
prototype
.
set
.
call
(
target
this
.
subarray
(
start
start
+
len
)
targetStart
)
}
return
len
}
Buffer
.
prototype
.
fill
=
function
fill
(
val
start
end
encoding
)
{
if
(
typeof
val
=
=
=
'
string
'
)
{
if
(
typeof
start
=
=
=
'
string
'
)
{
encoding
=
start
start
=
0
end
=
this
.
length
}
else
if
(
typeof
end
=
=
=
'
string
'
)
{
encoding
=
end
end
=
this
.
length
}
if
(
val
.
length
=
=
=
1
)
{
var
code
=
val
.
charCodeAt
(
0
)
if
(
code
<
256
)
{
val
=
code
}
}
if
(
encoding
!
=
=
undefined
&
&
typeof
encoding
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
encoding
must
be
a
string
'
)
}
if
(
typeof
encoding
=
=
=
'
string
'
&
&
!
Buffer
.
isEncoding
(
encoding
)
)
{
throw
new
TypeError
(
'
Unknown
encoding
:
'
+
encoding
)
}
}
else
if
(
typeof
val
=
=
=
'
number
'
)
{
val
=
val
&
255
}
if
(
start
<
0
|
|
this
.
length
<
start
|
|
this
.
length
<
end
)
{
throw
new
RangeError
(
'
Out
of
range
index
'
)
}
if
(
end
<
=
start
)
{
return
this
}
start
=
start
>
>
>
0
end
=
end
=
=
=
undefined
?
this
.
length
:
end
>
>
>
0
if
(
!
val
)
val
=
0
var
i
if
(
typeof
val
=
=
=
'
number
'
)
{
for
(
i
=
start
;
i
<
end
;
+
+
i
)
{
this
[
i
]
=
val
}
}
else
{
var
bytes
=
Buffer
.
isBuffer
(
val
)
?
val
:
utf8ToBytes
(
new
Buffer
(
val
encoding
)
.
toString
(
)
)
var
len
=
bytes
.
length
for
(
i
=
0
;
i
<
end
-
start
;
+
+
i
)
{
this
[
i
+
start
]
=
bytes
[
i
%
len
]
}
}
return
this
}
var
INVALID_BASE64_RE
=
/
[
^
+
\
/
0
-
9A
-
Za
-
z
-
_
]
/
g
function
base64clean
(
str
)
{
str
=
stringtrim
(
str
)
.
replace
(
INVALID_BASE64_RE
'
'
)
if
(
str
.
length
<
2
)
return
'
'
while
(
str
.
length
%
4
!
=
=
0
)
{
str
=
str
+
'
=
'
}
return
str
}
function
stringtrim
(
str
)
{
if
(
str
.
trim
)
return
str
.
trim
(
)
return
str
.
replace
(
/
^
\
s
+
|
\
s
+
/
g
'
'
)
}
function
toHex
(
n
)
{
if
(
n
<
16
)
return
'
0
'
+
n
.
toString
(
16
)
return
n
.
toString
(
16
)
}
function
utf8ToBytes
(
string
units
)
{
units
=
units
|
|
Infinity
var
codePoint
var
length
=
string
.
length
var
leadSurrogate
=
null
var
bytes
=
[
]
for
(
var
i
=
0
;
i
<
length
;
+
+
i
)
{
codePoint
=
string
.
charCodeAt
(
i
)
if
(
codePoint
>
0xD7FF
&
&
codePoint
<
0xE000
)
{
if
(
!
leadSurrogate
)
{
if
(
codePoint
>
0xDBFF
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
continue
}
else
if
(
i
+
1
=
=
=
length
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
continue
}
leadSurrogate
=
codePoint
continue
}
if
(
codePoint
<
0xDC00
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
leadSurrogate
=
codePoint
continue
}
codePoint
=
(
leadSurrogate
-
0xD800
<
<
10
|
codePoint
-
0xDC00
)
+
0x10000
}
else
if
(
leadSurrogate
)
{
if
(
(
units
-
=
3
)
>
-
1
)
bytes
.
push
(
0xEF
0xBF
0xBD
)
}
leadSurrogate
=
null
if
(
codePoint
<
0x80
)
{
if
(
(
units
-
=
1
)
<
0
)
break
bytes
.
push
(
codePoint
)
}
else
if
(
codePoint
<
0x800
)
{
if
(
(
units
-
=
2
)
<
0
)
break
bytes
.
push
(
codePoint
>
>
0x6
|
0xC0
codePoint
&
0x3F
|
0x80
)
}
else
if
(
codePoint
<
0x10000
)
{
if
(
(
units
-
=
3
)
<
0
)
break
bytes
.
push
(
codePoint
>
>
0xC
|
0xE0
codePoint
>
>
0x6
&
0x3F
|
0x80
codePoint
&
0x3F
|
0x80
)
}
else
if
(
codePoint
<
0x110000
)
{
if
(
(
units
-
=
4
)
<
0
)
break
bytes
.
push
(
codePoint
>
>
0x12
|
0xF0
codePoint
>
>
0xC
&
0x3F
|
0x80
codePoint
>
>
0x6
&
0x3F
|
0x80
codePoint
&
0x3F
|
0x80
)
}
else
{
throw
new
Error
(
'
Invalid
code
point
'
)
}
}
return
bytes
}
function
asciiToBytes
(
str
)
{
var
byteArray
=
[
]
for
(
var
i
=
0
;
i
<
str
.
length
;
+
+
i
)
{
byteArray
.
push
(
str
.
charCodeAt
(
i
)
&
0xFF
)
}
return
byteArray
}
function
utf16leToBytes
(
str
units
)
{
var
c
hi
lo
var
byteArray
=
[
]
for
(
var
i
=
0
;
i
<
str
.
length
;
+
+
i
)
{
if
(
(
units
-
=
2
)
<
0
)
break
c
=
str
.
charCodeAt
(
i
)
hi
=
c
>
>
8
lo
=
c
%
256
byteArray
.
push
(
lo
)
byteArray
.
push
(
hi
)
}
return
byteArray
}
function
base64ToBytes
(
str
)
{
return
base64
.
toByteArray
(
base64clean
(
str
)
)
}
function
blitBuffer
(
src
dst
offset
length
)
{
for
(
var
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
(
i
+
offset
>
=
dst
.
length
)
|
|
(
i
>
=
src
.
length
)
)
break
dst
[
i
+
offset
]
=
src
[
i
]
}
return
i
}
function
isnan
(
val
)
{
return
val
!
=
=
val
}
}
.
call
(
exports
(
function
(
)
{
return
this
;
}
(
)
)
)
)
}
795
:
function
(
module
exports
)
{
'
use
strict
'
exports
.
byteLength
=
byteLength
exports
.
toByteArray
=
toByteArray
exports
.
fromByteArray
=
fromByteArray
var
lookup
=
[
]
var
revLookup
=
[
]
var
Arr
=
typeof
Uint8Array
!
=
=
'
undefined
'
?
Uint8Array
:
Array
var
code
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
for
(
var
i
=
0
len
=
code
.
length
;
i
<
len
;
+
+
i
)
{
lookup
[
i
]
=
code
[
i
]
revLookup
[
code
.
charCodeAt
(
i
)
]
=
i
}
revLookup
[
'
-
'
.
charCodeAt
(
0
)
]
=
62
revLookup
[
'
_
'
.
charCodeAt
(
0
)
]
=
63
function
placeHoldersCount
(
b64
)
{
var
len
=
b64
.
length
if
(
len
%
4
>
0
)
{
throw
new
Error
(
'
Invalid
string
.
Length
must
be
a
multiple
of
4
'
)
}
return
b64
[
len
-
2
]
=
=
=
'
=
'
?
2
:
b64
[
len
-
1
]
=
=
=
'
=
'
?
1
:
0
}
function
byteLength
(
b64
)
{
return
b64
.
length
*
3
/
4
-
placeHoldersCount
(
b64
)
}
function
toByteArray
(
b64
)
{
var
i
j
l
tmp
placeHolders
arr
var
len
=
b64
.
length
placeHolders
=
placeHoldersCount
(
b64
)
arr
=
new
Arr
(
len
*
3
/
4
-
placeHolders
)
l
=
placeHolders
>
0
?
len
-
4
:
len
var
L
=
0
for
(
i
=
0
j
=
0
;
i
<
l
;
i
+
=
4
j
+
=
3
)
{
tmp
=
(
revLookup
[
b64
.
charCodeAt
(
i
)
]
<
<
18
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
1
)
]
<
<
12
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
2
)
]
<
<
6
)
|
revLookup
[
b64
.
charCodeAt
(
i
+
3
)
]
arr
[
L
+
+
]
=
(
tmp
>
>
16
)
&
0xFF
arr
[
L
+
+
]
=
(
tmp
>
>
8
)
&
0xFF
arr
[
L
+
+
]
=
tmp
&
0xFF
}
if
(
placeHolders
=
=
=
2
)
{
tmp
=
(
revLookup
[
b64
.
charCodeAt
(
i
)
]
<
<
2
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
1
)
]
>
>
4
)
arr
[
L
+
+
]
=
tmp
&
0xFF
}
else
if
(
placeHolders
=
=
=
1
)
{
tmp
=
(
revLookup
[
b64
.
charCodeAt
(
i
)
]
<
<
10
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
1
)
]
<
<
4
)
|
(
revLookup
[
b64
.
charCodeAt
(
i
+
2
)
]
>
>
2
)
arr
[
L
+
+
]
=
(
tmp
>
>
8
)
&
0xFF
arr
[
L
+
+
]
=
tmp
&
0xFF
}
return
arr
}
function
tripletToBase64
(
num
)
{
return
lookup
[
num
>
>
18
&
0x3F
]
+
lookup
[
num
>
>
12
&
0x3F
]
+
lookup
[
num
>
>
6
&
0x3F
]
+
lookup
[
num
&
0x3F
]
}
function
encodeChunk
(
uint8
start
end
)
{
var
tmp
var
output
=
[
]
for
(
var
i
=
start
;
i
<
end
;
i
+
=
3
)
{
tmp
=
(
uint8
[
i
]
<
<
16
)
+
(
uint8
[
i
+
1
]
<
<
8
)
+
(
uint8
[
i
+
2
]
)
output
.
push
(
tripletToBase64
(
tmp
)
)
}
return
output
.
join
(
'
'
)
}
function
fromByteArray
(
uint8
)
{
var
tmp
var
len
=
uint8
.
length
var
extraBytes
=
len
%
3
var
output
=
'
'
var
parts
=
[
]
var
maxChunkLength
=
16383
for
(
var
i
=
0
len2
=
len
-
extraBytes
;
i
<
len2
;
i
+
=
maxChunkLength
)
{
parts
.
push
(
encodeChunk
(
uint8
i
(
i
+
maxChunkLength
)
>
len2
?
len2
:
(
i
+
maxChunkLength
)
)
)
}
if
(
extraBytes
=
=
=
1
)
{
tmp
=
uint8
[
len
-
1
]
output
+
=
lookup
[
tmp
>
>
2
]
output
+
=
lookup
[
(
tmp
<
<
4
)
&
0x3F
]
output
+
=
'
=
=
'
}
else
if
(
extraBytes
=
=
=
2
)
{
tmp
=
(
uint8
[
len
-
2
]
<
<
8
)
+
(
uint8
[
len
-
1
]
)
output
+
=
lookup
[
tmp
>
>
10
]
output
+
=
lookup
[
(
tmp
>
>
4
)
&
0x3F
]
output
+
=
lookup
[
(
tmp
<
<
2
)
&
0x3F
]
output
+
=
'
=
'
}
parts
.
push
(
output
)
return
parts
.
join
(
'
'
)
}
}
796
:
function
(
module
exports
)
{
exports
.
read
=
function
(
buffer
offset
isLE
mLen
nBytes
)
{
var
e
m
var
eLen
=
nBytes
*
8
-
mLen
-
1
var
eMax
=
(
1
<
<
eLen
)
-
1
var
eBias
=
eMax
>
>
1
var
nBits
=
-
7
var
i
=
isLE
?
(
nBytes
-
1
)
:
0
var
d
=
isLE
?
-
1
:
1
var
s
=
buffer
[
offset
+
i
]
i
+
=
d
e
=
s
&
(
(
1
<
<
(
-
nBits
)
)
-
1
)
s
>
>
=
(
-
nBits
)
nBits
+
=
eLen
for
(
;
nBits
>
0
;
e
=
e
*
256
+
buffer
[
offset
+
i
]
i
+
=
d
nBits
-
=
8
)
{
}
m
=
e
&
(
(
1
<
<
(
-
nBits
)
)
-
1
)
e
>
>
=
(
-
nBits
)
nBits
+
=
mLen
for
(
;
nBits
>
0
;
m
=
m
*
256
+
buffer
[
offset
+
i
]
i
+
=
d
nBits
-
=
8
)
{
}
if
(
e
=
=
=
0
)
{
e
=
1
-
eBias
}
else
if
(
e
=
=
=
eMax
)
{
return
m
?
NaN
:
(
(
s
?
-
1
:
1
)
*
Infinity
)
}
else
{
m
=
m
+
Math
.
pow
(
2
mLen
)
e
=
e
-
eBias
}
return
(
s
?
-
1
:
1
)
*
m
*
Math
.
pow
(
2
e
-
mLen
)
}
exports
.
write
=
function
(
buffer
value
offset
isLE
mLen
nBytes
)
{
var
e
m
c
var
eLen
=
nBytes
*
8
-
mLen
-
1
var
eMax
=
(
1
<
<
eLen
)
-
1
var
eBias
=
eMax
>
>
1
var
rt
=
(
mLen
=
=
=
23
?
Math
.
pow
(
2
-
24
)
-
Math
.
pow
(
2
-
77
)
:
0
)
var
i
=
isLE
?
0
:
(
nBytes
-
1
)
var
d
=
isLE
?
1
:
-
1
var
s
=
value
<
0
|
|
(
value
=
=
=
0
&
&
1
/
value
<
0
)
?
1
:
0
value
=
Math
.
abs
(
value
)
if
(
isNaN
(
value
)
|
|
value
=
=
=
Infinity
)
{
m
=
isNaN
(
value
)
?
1
:
0
e
=
eMax
}
else
{
e
=
Math
.
floor
(
Math
.
log
(
value
)
/
Math
.
LN2
)
if
(
value
*
(
c
=
Math
.
pow
(
2
-
e
)
)
<
1
)
{
e
-
-
c
*
=
2
}
if
(
e
+
eBias
>
=
1
)
{
value
+
=
rt
/
c
}
else
{
value
+
=
rt
*
Math
.
pow
(
2
1
-
eBias
)
}
if
(
value
*
c
>
=
2
)
{
e
+
+
c
/
=
2
}
if
(
e
+
eBias
>
=
eMax
)
{
m
=
0
e
=
eMax
}
else
if
(
e
+
eBias
>
=
1
)
{
m
=
(
value
*
c
-
1
)
*
Math
.
pow
(
2
mLen
)
e
=
e
+
eBias
}
else
{
m
=
value
*
Math
.
pow
(
2
eBias
-
1
)
*
Math
.
pow
(
2
mLen
)
e
=
0
}
}
for
(
;
mLen
>
=
8
;
buffer
[
offset
+
i
]
=
m
&
0xff
i
+
=
d
m
/
=
256
mLen
-
=
8
)
{
}
e
=
(
e
<
<
mLen
)
|
m
eLen
+
=
mLen
for
(
;
eLen
>
0
;
buffer
[
offset
+
i
]
=
e
&
0xff
i
+
=
d
e
/
=
256
eLen
-
=
8
)
{
}
buffer
[
offset
+
i
-
d
]
|
=
s
*
128
}
}
797
:
function
(
module
exports
)
{
var
toString
=
{
}
.
toString
;
module
.
exports
=
Array
.
isArray
|
|
function
(
arr
)
{
return
toString
.
call
(
arr
)
=
=
'
[
object
Array
]
'
;
}
;
}
800
:
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
Buffer
)
{
(
function
(
global
module
)
{
var
exports
=
module
.
exports
;
module
.
exports
=
expect
;
expect
.
Assertion
=
Assertion
;
expect
.
version
=
'
0
.
3
.
1
'
;
var
flags
=
{
not
:
[
'
to
'
'
be
'
'
have
'
'
include
'
'
only
'
]
to
:
[
'
be
'
'
have
'
'
include
'
'
only
'
'
not
'
]
only
:
[
'
have
'
]
have
:
[
'
own
'
]
be
:
[
'
an
'
]
}
;
function
expect
(
obj
)
{
return
new
Assertion
(
obj
)
;
}
function
Assertion
(
obj
flag
parent
)
{
this
.
obj
=
obj
;
this
.
flags
=
{
}
;
if
(
undefined
!
=
parent
)
{
this
.
flags
[
flag
]
=
true
;
for
(
var
i
in
parent
.
flags
)
{
if
(
parent
.
flags
.
hasOwnProperty
(
i
)
)
{
this
.
flags
[
i
]
=
true
;
}
}
}
var
flags
=
flag
?
flags
[
flag
]
:
keys
(
flags
)
self
=
this
;
if
(
flags
)
{
for
(
var
i
=
0
l
=
flags
.
length
;
i
<
l
;
i
+
+
)
{
if
(
this
.
flags
[
flags
[
i
]
]
)
continue
;
var
name
=
flags
[
i
]
assertion
=
new
Assertion
(
this
.
obj
name
this
)
if
(
'
function
'
=
=
typeof
Assertion
.
prototype
[
name
]
)
{
var
old
=
this
[
name
]
;
this
[
name
]
=
function
(
)
{
return
old
.
apply
(
self
arguments
)
;
}
;
for
(
var
fn
in
Assertion
.
prototype
)
{
if
(
Assertion
.
prototype
.
hasOwnProperty
(
fn
)
&
&
fn
!
=
name
)
{
this
[
name
]
[
fn
]
=
bind
(
assertion
[
fn
]
assertion
)
;
}
}
}
else
{
this
[
name
]
=
assertion
;
}
}
}
}
Assertion
.
prototype
.
assert
=
function
(
truth
msg
error
expected
)
{
var
msg
=
this
.
flags
.
not
?
error
:
msg
ok
=
this
.
flags
.
not
?
!
truth
:
truth
err
;
if
(
!
ok
)
{
err
=
new
Error
(
msg
.
call
(
this
)
)
;
if
(
arguments
.
length
>
3
)
{
err
.
actual
=
this
.
obj
;
err
.
expected
=
expected
;
err
.
showDiff
=
true
;
}
throw
err
;
}
this
.
and
=
new
Assertion
(
this
.
obj
)
;
}
;
Assertion
.
prototype
.
ok
=
function
(
)
{
this
.
assert
(
!
!
this
.
obj
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
truthy
'
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
falsy
'
}
)
;
}
;
Assertion
.
prototype
.
withArgs
=
function
(
)
{
expect
(
this
.
obj
)
.
to
.
be
.
a
(
'
function
'
)
;
var
fn
=
this
.
obj
;
var
args
=
Array
.
prototype
.
slice
.
call
(
arguments
)
;
return
expect
(
function
(
)
{
fn
.
apply
(
null
args
)
;
}
)
;
}
;
Assertion
.
prototype
.
throwError
=
Assertion
.
prototype
.
throwException
=
function
(
fn
)
{
expect
(
this
.
obj
)
.
to
.
be
.
a
(
'
function
'
)
;
var
thrown
=
false
not
=
this
.
flags
.
not
;
try
{
this
.
obj
(
)
;
}
catch
(
e
)
{
if
(
isRegExp
(
fn
)
)
{
var
subject
=
'
string
'
=
=
typeof
e
?
e
:
e
.
message
;
if
(
not
)
{
expect
(
subject
)
.
to
.
not
.
match
(
fn
)
;
}
else
{
expect
(
subject
)
.
to
.
match
(
fn
)
;
}
}
else
if
(
'
function
'
=
=
typeof
fn
)
{
fn
(
e
)
;
}
thrown
=
true
;
}
if
(
isRegExp
(
fn
)
&
&
not
)
{
this
.
flags
.
not
=
false
;
}
var
name
=
this
.
obj
.
name
|
|
'
fn
'
;
this
.
assert
(
thrown
function
(
)
{
return
'
expected
'
+
name
+
'
to
throw
an
exception
'
}
function
(
)
{
return
'
expected
'
+
name
+
'
not
to
throw
an
exception
'
}
)
;
}
;
Assertion
.
prototype
.
empty
=
function
(
)
{
var
expectation
;
if
(
'
object
'
=
=
typeof
this
.
obj
&
&
null
!
=
=
this
.
obj
&
&
!
isArray
(
this
.
obj
)
)
{
if
(
'
number
'
=
=
typeof
this
.
obj
.
length
)
{
expectation
=
!
this
.
obj
.
length
;
}
else
{
expectation
=
!
keys
(
this
.
obj
)
.
length
;
}
}
else
{
if
(
'
string
'
!
=
typeof
this
.
obj
)
{
expect
(
this
.
obj
)
.
to
.
be
.
an
(
'
object
'
)
;
}
expect
(
this
.
obj
)
.
to
.
have
.
property
(
'
length
'
)
;
expectation
=
!
this
.
obj
.
length
;
}
this
.
assert
(
expectation
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
empty
'
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
be
empty
'
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
be
=
Assertion
.
prototype
.
equal
=
function
(
obj
)
{
this
.
assert
(
obj
=
=
=
this
.
obj
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
equal
'
+
i
(
obj
)
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
equal
'
+
i
(
obj
)
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
eql
=
function
(
obj
)
{
this
.
assert
(
expect
.
eql
(
this
.
obj
obj
)
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
sort
of
equal
'
+
i
(
obj
)
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
sort
of
not
equal
'
+
i
(
obj
)
}
obj
)
;
return
this
;
}
;
Assertion
.
prototype
.
within
=
function
(
start
finish
)
{
var
range
=
start
+
'
.
.
'
+
finish
;
this
.
assert
(
this
.
obj
>
=
start
&
&
this
.
obj
<
=
finish
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
within
'
+
range
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
be
within
'
+
range
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
a
=
Assertion
.
prototype
.
an
=
function
(
type
)
{
if
(
'
string
'
=
=
typeof
type
)
{
var
n
=
/
^
[
aeiou
]
/
.
test
(
type
)
?
'
n
'
:
'
'
;
this
.
assert
(
'
array
'
=
=
type
?
isArray
(
this
.
obj
)
:
'
regexp
'
=
=
type
?
isRegExp
(
this
.
obj
)
:
'
object
'
=
=
type
?
'
object
'
=
=
typeof
this
.
obj
&
&
null
!
=
=
this
.
obj
:
type
=
=
typeof
this
.
obj
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
a
'
+
n
+
'
'
+
type
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
not
to
be
a
'
+
n
+
'
'
+
type
}
)
;
}
else
{
var
name
=
type
.
name
|
|
'
supplied
constructor
'
;
this
.
assert
(
this
.
obj
instanceof
type
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
an
instance
of
'
+
name
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
not
to
be
an
instance
of
'
+
name
}
)
;
}
return
this
;
}
;
Assertion
.
prototype
.
greaterThan
=
Assertion
.
prototype
.
above
=
function
(
n
)
{
this
.
assert
(
this
.
obj
>
n
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
above
'
+
n
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
below
'
+
n
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
lessThan
=
Assertion
.
prototype
.
below
=
function
(
n
)
{
this
.
assert
(
this
.
obj
<
n
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
below
'
+
n
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
be
above
'
+
n
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
match
=
function
(
regexp
)
{
this
.
assert
(
regexp
.
exec
(
this
.
obj
)
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
match
'
+
regexp
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
not
to
match
'
+
regexp
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
length
=
function
(
n
)
{
expect
(
this
.
obj
)
.
to
.
have
.
property
(
'
length
'
)
;
var
len
=
this
.
obj
.
length
;
this
.
assert
(
n
=
=
len
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
have
a
length
of
'
+
n
+
'
but
got
'
+
len
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
have
a
length
of
'
+
len
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
property
=
function
(
name
val
)
{
if
(
this
.
flags
.
own
)
{
this
.
assert
(
Object
.
prototype
.
hasOwnProperty
.
call
(
this
.
obj
name
)
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
have
own
property
'
+
i
(
name
)
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
have
own
property
'
+
i
(
name
)
}
)
;
return
this
;
}
if
(
this
.
flags
.
not
&
&
undefined
!
=
=
val
)
{
if
(
undefined
=
=
=
this
.
obj
[
name
]
)
{
throw
new
Error
(
i
(
this
.
obj
)
+
'
has
no
property
'
+
i
(
name
)
)
;
}
}
else
{
var
hasProp
;
try
{
hasProp
=
name
in
this
.
obj
}
catch
(
e
)
{
hasProp
=
undefined
!
=
=
this
.
obj
[
name
]
}
this
.
assert
(
hasProp
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
have
a
property
'
+
i
(
name
)
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
have
a
property
'
+
i
(
name
)
}
)
;
}
if
(
undefined
!
=
=
val
)
{
this
.
assert
(
val
=
=
=
this
.
obj
[
name
]
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
have
a
property
'
+
i
(
name
)
+
'
of
'
+
i
(
val
)
+
'
but
got
'
+
i
(
this
.
obj
[
name
]
)
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
have
a
property
'
+
i
(
name
)
+
'
of
'
+
i
(
val
)
}
)
;
}
this
.
obj
=
this
.
obj
[
name
]
;
return
this
;
}
;
Assertion
.
prototype
.
string
=
Assertion
.
prototype
.
contain
=
function
(
obj
)
{
if
(
'
string
'
=
=
typeof
this
.
obj
)
{
this
.
assert
(
~
this
.
obj
.
indexOf
(
obj
)
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
contain
'
+
i
(
obj
)
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
contain
'
+
i
(
obj
)
}
)
;
}
else
{
this
.
assert
(
~
indexOf
(
this
.
obj
obj
)
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
contain
'
+
i
(
obj
)
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
contain
'
+
i
(
obj
)
}
)
;
}
return
this
;
}
;
Assertion
.
prototype
.
key
=
Assertion
.
prototype
.
keys
=
function
(
keys
)
{
var
str
ok
=
true
;
keys
=
isArray
(
keys
)
?
keys
:
Array
.
prototype
.
slice
.
call
(
arguments
)
;
if
(
!
keys
.
length
)
throw
new
Error
(
'
keys
required
'
)
;
var
actual
=
keys
(
this
.
obj
)
len
=
keys
.
length
;
ok
=
every
(
keys
function
(
key
)
{
return
~
indexOf
(
actual
key
)
;
}
)
;
if
(
!
this
.
flags
.
not
&
&
this
.
flags
.
only
)
{
ok
=
ok
&
&
keys
.
length
=
=
actual
.
length
;
}
if
(
len
>
1
)
{
keys
=
map
(
keys
function
(
key
)
{
return
i
(
key
)
;
}
)
;
var
last
=
keys
.
pop
(
)
;
str
=
keys
.
join
(
'
'
)
+
'
and
'
+
last
;
}
else
{
str
=
i
(
keys
[
0
]
)
;
}
str
=
(
len
>
1
?
'
keys
'
:
'
key
'
)
+
str
;
str
=
(
!
this
.
flags
.
only
?
'
include
'
:
'
only
have
'
)
+
str
;
this
.
assert
(
ok
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
'
+
str
}
function
(
)
{
return
'
expected
'
+
i
(
this
.
obj
)
+
'
to
not
'
+
str
}
)
;
return
this
;
}
;
Assertion
.
prototype
.
fail
=
function
(
msg
)
{
var
error
=
function
(
)
{
return
msg
|
|
"
explicit
failure
"
;
}
this
.
assert
(
false
error
error
)
;
return
this
;
}
;
function
bind
(
fn
scope
)
{
return
function
(
)
{
return
fn
.
apply
(
scope
arguments
)
;
}
}
function
every
(
arr
fn
thisObj
)
{
var
scope
=
thisObj
|
|
global
;
for
(
var
i
=
0
j
=
arr
.
length
;
i
<
j
;
+
+
i
)
{
if
(
!
fn
.
call
(
scope
arr
[
i
]
i
arr
)
)
{
return
false
;
}
}
return
true
;
}
function
indexOf
(
arr
o
i
)
{
if
(
Array
.
prototype
.
indexOf
)
{
return
Array
.
prototype
.
indexOf
.
call
(
arr
o
i
)
;
}
if
(
arr
.
length
=
=
=
undefined
)
{
return
-
1
;
}
for
(
var
j
=
arr
.
length
i
=
i
<
0
?
i
+
j
<
0
?
0
:
i
+
j
:
i
|
|
0
;
i
<
j
&
&
arr
[
i
]
!
=
=
o
;
i
+
+
)
;
return
j
<
=
i
?
-
1
:
i
;
}
var
getOuterHTML
=
function
(
element
)
{
if
(
'
outerHTML
'
in
element
)
return
element
.
outerHTML
;
var
ns
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
var
container
=
document
.
createElementNS
(
ns
'
_
'
)
;
var
xmlSerializer
=
new
XMLSerializer
(
)
;
var
html
;
if
(
document
.
xmlVersion
)
{
return
xmlSerializer
.
serializeToString
(
element
)
;
}
else
{
container
.
appendChild
(
element
.
cloneNode
(
false
)
)
;
html
=
container
.
innerHTML
.
replace
(
'
>
<
'
'
>
'
+
element
.
innerHTML
+
'
<
'
)
;
container
.
innerHTML
=
'
'
;
return
html
;
}
}
;
var
isDOMElement
=
function
(
object
)
{
if
(
typeof
HTMLElement
=
=
=
'
object
'
)
{
return
object
instanceof
HTMLElement
;
}
else
{
return
object
&
&
typeof
object
=
=
=
'
object
'
&
&
object
.
nodeType
=
=
=
1
&
&
typeof
object
.
nodeName
=
=
=
'
string
'
;
}
}
;
function
i
(
obj
showHidden
depth
)
{
var
seen
=
[
]
;
function
stylize
(
str
)
{
return
str
;
}
function
format
(
value
recurseTimes
)
{
if
(
value
&
&
typeof
value
.
inspect
=
=
=
'
function
'
&
&
value
!
=
=
exports
&
&
!
(
value
.
constructor
&
&
value
.
constructor
.
prototype
=
=
=
value
)
)
{
return
value
.
inspect
(
recurseTimes
)
;
}
switch
(
typeof
value
)
{
case
'
undefined
'
:
return
stylize
(
'
undefined
'
'
undefined
'
)
;
case
'
string
'
:
var
simple
=
'
\
'
'
+
json
.
stringify
(
value
)
.
replace
(
/
^
"
|
"
/
g
'
'
)
.
replace
(
/
'
/
g
"
\
\
'
"
)
.
replace
(
/
\
\
"
/
g
'
"
'
)
+
'
\
'
'
;
return
stylize
(
simple
'
string
'
)
;
case
'
number
'
:
return
stylize
(
'
'
+
value
'
number
'
)
;
case
'
boolean
'
:
return
stylize
(
'
'
+
value
'
boolean
'
)
;
}
if
(
value
=
=
=
null
)
{
return
stylize
(
'
null
'
'
null
'
)
;
}
if
(
isDOMElement
(
value
)
)
{
return
getOuterHTML
(
value
)
;
}
var
visible_keys
=
keys
(
value
)
;
var
keys
=
showHidden
?
Object
.
getOwnPropertyNames
(
value
)
:
visible_keys
;
if
(
typeof
value
=
=
=
'
function
'
&
&
keys
.
length
=
=
=
0
)
{
if
(
isRegExp
(
value
)
)
{
return
stylize
(
'
'
+
value
'
regexp
'
)
;
}
else
{
var
name
=
value
.
name
?
'
:
'
+
value
.
name
:
'
'
;
return
stylize
(
'
[
Function
'
+
name
+
'
]
'
'
special
'
)
;
}
}
if
(
isDate
(
value
)
&
&
keys
.
length
=
=
=
0
)
{
return
stylize
(
value
.
toUTCString
(
)
'
date
'
)
;
}
if
(
value
instanceof
Error
)
{
return
stylize
(
"
[
"
+
value
.
toString
(
)
+
"
]
"
'
Error
'
)
;
}
var
base
type
braces
;
if
(
isArray
(
value
)
)
{
type
=
'
Array
'
;
braces
=
[
'
[
'
'
]
'
]
;
}
else
{
type
=
'
Object
'
;
braces
=
[
'
{
'
'
}
'
]
;
}
if
(
typeof
value
=
=
=
'
function
'
)
{
var
n
=
value
.
name
?
'
:
'
+
value
.
name
:
'
'
;
base
=
(
isRegExp
(
value
)
)
?
'
'
+
value
:
'
[
Function
'
+
n
+
'
]
'
;
}
else
{
base
=
'
'
;
}
if
(
isDate
(
value
)
)
{
base
=
'
'
+
value
.
toUTCString
(
)
;
}
if
(
keys
.
length
=
=
=
0
)
{
return
braces
[
0
]
+
base
+
braces
[
1
]
;
}
if
(
recurseTimes
<
0
)
{
if
(
isRegExp
(
value
)
)
{
return
stylize
(
'
'
+
value
'
regexp
'
)
;
}
else
{
return
stylize
(
'
[
Object
]
'
'
special
'
)
;
}
}
seen
.
push
(
value
)
;
var
output
=
map
(
keys
function
(
key
)
{
var
name
str
;
if
(
value
.
__lookupGetter__
)
{
if
(
value
.
__lookupGetter__
(
key
)
)
{
if
(
value
.
__lookupSetter__
(
key
)
)
{
str
=
stylize
(
'
[
Getter
/
Setter
]
'
'
special
'
)
;
}
else
{
str
=
stylize
(
'
[
Getter
]
'
'
special
'
)
;
}
}
else
{
if
(
value
.
__lookupSetter__
(
key
)
)
{
str
=
stylize
(
'
[
Setter
]
'
'
special
'
)
;
}
}
}
if
(
indexOf
(
visible_keys
key
)
<
0
)
{
name
=
'
[
'
+
key
+
'
]
'
;
}
if
(
!
str
)
{
if
(
indexOf
(
seen
value
[
key
]
)
<
0
)
{
if
(
recurseTimes
=
=
=
null
)
{
str
=
format
(
value
[
key
]
)
;
}
else
{
str
=
format
(
value
[
key
]
recurseTimes
-
1
)
;
}
if
(
str
.
indexOf
(
'
\
n
'
)
>
-
1
)
{
if
(
isArray
(
value
)
)
{
str
=
map
(
str
.
split
(
'
\
n
'
)
function
(
line
)
{
return
'
'
+
line
;
}
)
.
join
(
'
\
n
'
)
.
substr
(
2
)
;
}
else
{
str
=
'
\
n
'
+
map
(
str
.
split
(
'
\
n
'
)
function
(
line
)
{
return
'
'
+
line
;
}
)
.
join
(
'
\
n
'
)
;
}
}
}
else
{
str
=
stylize
(
'
[
Circular
]
'
'
special
'
)
;
}
}
if
(
typeof
name
=
=
=
'
undefined
'
)
{
if
(
type
=
=
=
'
Array
'
&
&
key
.
match
(
/
^
\
d
+
/
)
)
{
return
str
;
}
name
=
json
.
stringify
(
'
'
+
key
)
;
if
(
name
.
match
(
/
^
"
(
[
a
-
zA
-
Z_
]
[
a
-
zA
-
Z_0
-
9
]
*
)
"
/
)
)
{
name
=
name
.
substr
(
1
name
.
length
-
2
)
;
name
=
stylize
(
name
'
name
'
)
;
}
else
{
name
=
name
.
replace
(
/
'
/
g
"
\
\
'
"
)
.
replace
(
/
\
\
"
/
g
'
"
'
)
.
replace
(
/
(
^
"
|
"
)
/
g
"
'
"
)
;
name
=
stylize
(
name
'
string
'
)
;
}
}
return
name
+
'
:
'
+
str
;
}
)
;
seen
.
pop
(
)
;
var
numLinesEst
=
0
;
var
length
=
reduce
(
output
function
(
prev
cur
)
{
numLinesEst
+
+
;
if
(
indexOf
(
cur
'
\
n
'
)
>
=
0
)
numLinesEst
+
+
;
return
prev
+
cur
.
length
+
1
;
}
0
)
;
if
(
length
>
50
)
{
output
=
braces
[
0
]
+
(
base
=
=
=
'
'
?
'
'
:
base
+
'
\
n
'
)
+
'
'
+
output
.
join
(
'
\
n
'
)
+
'
'
+
braces
[
1
]
;
}
else
{
output
=
braces
[
0
]
+
base
+
'
'
+
output
.
join
(
'
'
)
+
'
'
+
braces
[
1
]
;
}
return
output
;
}
return
format
(
obj
(
typeof
depth
=
=
=
'
undefined
'
?
2
:
depth
)
)
;
}
expect
.
stringify
=
i
;
function
isArray
(
ar
)
{
return
Object
.
prototype
.
toString
.
call
(
ar
)
=
=
=
'
[
object
Array
]
'
;
}
function
isRegExp
(
re
)
{
var
s
;
try
{
s
=
'
'
+
re
;
}
catch
(
e
)
{
return
false
;
}
return
re
instanceof
RegExp
|
|
typeof
(
re
)
=
=
=
'
function
'
&
&
re
.
constructor
.
name
=
=
=
'
RegExp
'
&
&
re
.
compile
&
&
re
.
test
&
&
re
.
exec
&
&
s
.
match
(
/
^
\
/
.
*
\
/
[
gim
]
{
0
3
}
/
)
;
}
function
isDate
(
d
)
{
return
d
instanceof
Date
;
}
function
keys
(
obj
)
{
if
(
Object
.
keys
)
{
return
Object
.
keys
(
obj
)
;
}
var
keys
=
[
]
;
for
(
var
i
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
i
)
)
{
keys
.
push
(
i
)
;
}
}
return
keys
;
}
function
map
(
arr
mapper
that
)
{
if
(
Array
.
prototype
.
map
)
{
return
Array
.
prototype
.
map
.
call
(
arr
mapper
that
)
;
}
var
other
=
new
Array
(
arr
.
length
)
;
for
(
var
i
=
0
n
=
arr
.
length
;
i
<
n
;
i
+
+
)
if
(
i
in
arr
)
other
[
i
]
=
mapper
.
call
(
that
arr
[
i
]
i
arr
)
;
return
other
;
}
function
reduce
(
arr
fun
)
{
if
(
Array
.
prototype
.
reduce
)
{
return
Array
.
prototype
.
reduce
.
apply
(
arr
Array
.
prototype
.
slice
.
call
(
arguments
1
)
)
;
}
var
len
=
+
this
.
length
;
if
(
typeof
fun
!
=
=
"
function
"
)
throw
new
TypeError
(
)
;
if
(
len
=
=
=
0
&
&
arguments
.
length
=
=
=
1
)
throw
new
TypeError
(
)
;
var
i
=
0
;
if
(
arguments
.
length
>
=
2
)
{
var
rv
=
arguments
[
1
]
;
}
else
{
do
{
if
(
i
in
this
)
{
rv
=
this
[
i
+
+
]
;
break
;
}
if
(
+
+
i
>
=
len
)
throw
new
TypeError
(
)
;
}
while
(
true
)
;
}
for
(
;
i
<
len
;
i
+
+
)
{
if
(
i
in
this
)
rv
=
fun
.
call
(
null
rv
this
[
i
]
i
this
)
;
}
return
rv
;
}
expect
.
eql
=
function
eql
(
actual
expected
)
{
if
(
actual
=
=
=
expected
)
{
return
true
;
}
else
if
(
'
undefined
'
!
=
typeof
Buffer
&
&
Buffer
.
isBuffer
(
actual
)
&
&
Buffer
.
isBuffer
(
expected
)
)
{
if
(
actual
.
length
!
=
expected
.
length
)
return
false
;
for
(
var
i
=
0
;
i
<
actual
.
length
;
i
+
+
)
{
if
(
actual
[
i
]
!
=
=
expected
[
i
]
)
return
false
;
}
return
true
;
}
else
if
(
actual
instanceof
Date
&
&
expected
instanceof
Date
)
{
return
actual
.
getTime
(
)
=
=
=
expected
.
getTime
(
)
;
}
else
if
(
typeof
actual
!
=
'
object
'
&
&
typeof
expected
!
=
'
object
'
)
{
return
actual
=
=
expected
;
}
else
if
(
isRegExp
(
actual
)
&
&
isRegExp
(
expected
)
)
{
return
regExpEquiv
(
actual
expected
)
;
}
else
{
return
objEquiv
(
actual
expected
)
;
}
}
;
function
isUndefinedOrNull
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
;
}
function
isArguments
(
object
)
{
return
Object
.
prototype
.
toString
.
call
(
object
)
=
=
'
[
object
Arguments
]
'
;
}
function
regExpEquiv
(
a
b
)
{
return
a
.
source
=
=
=
b
.
source
&
&
a
.
global
=
=
=
b
.
global
&
&
a
.
ignoreCase
=
=
=
b
.
ignoreCase
&
&
a
.
multiline
=
=
=
b
.
multiline
;
}
function
objEquiv
(
a
b
)
{
if
(
isUndefinedOrNull
(
a
)
|
|
isUndefinedOrNull
(
b
)
)
return
false
;
if
(
a
.
prototype
!
=
=
b
.
prototype
)
return
false
;
if
(
isArguments
(
a
)
)
{
if
(
!
isArguments
(
b
)
)
{
return
false
;
}
a
=
pSlice
.
call
(
a
)
;
b
=
pSlice
.
call
(
b
)
;
return
expect
.
eql
(
a
b
)
;
}
try
{
var
ka
=
keys
(
a
)
kb
=
keys
(
b
)
key
i
;
}
catch
(
e
)
{
return
false
;
}
if
(
ka
.
length
!
=
kb
.
length
)
return
false
;
ka
.
sort
(
)
;
kb
.
sort
(
)
;
for
(
i
=
ka
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
ka
[
i
]
!
=
kb
[
i
]
)
return
false
;
}
for
(
i
=
ka
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
key
=
ka
[
i
]
;
if
(
!
expect
.
eql
(
a
[
key
]
b
[
key
]
)
)
return
false
;
}
return
true
;
}
var
json
=
(
function
(
)
{
"
use
strict
"
;
if
(
'
object
'
=
=
typeof
JSON
&
&
JSON
.
parse
&
&
JSON
.
stringify
)
{
return
{
parse
:
nativeJSON
.
parse
stringify
:
nativeJSON
.
stringify
}
}
var
JSON
=
{
}
;
function
f
(
n
)
{
return
n
<
10
?
'
0
'
+
n
:
n
;
}
function
date
(
d
key
)
{
return
isFinite
(
d
.
valueOf
(
)
)
?
d
.
getUTCFullYear
(
)
+
'
-
'
+
f
(
d
.
getUTCMonth
(
)
+
1
)
+
'
-
'
+
f
(
d
.
getUTCDate
(
)
)
+
'
T
'
+
f
(
d
.
getUTCHours
(
)
)
+
'
:
'
+
f
(
d
.
getUTCMinutes
(
)
)
+
'
:
'
+
f
(
d
.
getUTCSeconds
(
)
)
+
'
Z
'
:
null
;
}
var
cx
=
/
[
\
u0000
\
u00ad
\
u0600
-
\
u0604
\
u070f
\
u17b4
\
u17b5
\
u200c
-
\
u200f
\
u2028
-
\
u202f
\
u2060
-
\
u206f
\
ufeff
\
ufff0
-
\
uffff
]
/
g
escapable
=
/
[
\
\
\
"
\
x00
-
\
x1f
\
x7f
-
\
x9f
\
u00ad
\
u0600
-
\
u0604
\
u070f
\
u17b4
\
u17b5
\
u200c
-
\
u200f
\
u2028
-
\
u202f
\
u2060
-
\
u206f
\
ufeff
\
ufff0
-
\
uffff
]
/
g
gap
indent
meta
=
{
'
\
b
'
:
'
\
\
b
'
'
\
t
'
:
'
\
\
t
'
'
\
n
'
:
'
\
\
n
'
'
\
f
'
:
'
\
\
f
'
'
\
r
'
:
'
\
\
r
'
'
"
'
:
'
\
\
"
'
'
\
\
'
:
'
\
\
\
\
'
}
rep
;
function
quote
(
string
)
{
escapable
.
lastIndex
=
0
;
return
escapable
.
test
(
string
)
?
'
"
'
+
string
.
replace
(
escapable
function
(
a
)
{
var
c
=
meta
[
a
]
;
return
typeof
c
=
=
=
'
string
'
?
c
:
'
\
\
u
'
+
(
'
0000
'
+
a
.
charCodeAt
(
0
)
.
toString
(
16
)
)
.
slice
(
-
4
)
;
}
)
+
'
"
'
:
'
"
'
+
string
+
'
"
'
;
}
function
str
(
key
holder
)
{
var
i
k
v
length
mind
=
gap
partial
value
=
holder
[
key
]
;
if
(
value
instanceof
Date
)
{
value
=
date
(
key
)
;
}
if
(
typeof
rep
=
=
=
'
function
'
)
{
value
=
rep
.
call
(
holder
key
value
)
;
}
switch
(
typeof
value
)
{
case
'
string
'
:
return
quote
(
value
)
;
case
'
number
'
:
return
isFinite
(
value
)
?
String
(
value
)
:
'
null
'
;
case
'
boolean
'
:
case
'
null
'
:
return
String
(
value
)
;
case
'
object
'
:
if
(
!
value
)
{
return
'
null
'
;
}
gap
+
=
indent
;
partial
=
[
]
;
if
(
Object
.
prototype
.
toString
.
apply
(
value
)
=
=
=
'
[
object
Array
]
'
)
{
length
=
value
.
length
;
for
(
i
=
0
;
i
<
length
;
i
+
=
1
)
{
partial
[
i
]
=
str
(
i
value
)
|
|
'
null
'
;
}
v
=
partial
.
length
=
=
=
0
?
'
[
]
'
:
gap
?
'
[
\
n
'
+
gap
+
partial
.
join
(
'
\
n
'
+
gap
)
+
'
\
n
'
+
mind
+
'
]
'
:
'
[
'
+
partial
.
join
(
'
'
)
+
'
]
'
;
gap
=
mind
;
return
v
;
}
if
(
rep
&
&
typeof
rep
=
=
=
'
object
'
)
{
length
=
rep
.
length
;
for
(
i
=
0
;
i
<
length
;
i
+
=
1
)
{
if
(
typeof
rep
[
i
]
=
=
=
'
string
'
)
{
k
=
rep
[
i
]
;
v
=
str
(
k
value
)
;
if
(
v
)
{
partial
.
push
(
quote
(
k
)
+
(
gap
?
'
:
'
:
'
:
'
)
+
v
)
;
}
}
}
}
else
{
for
(
k
in
value
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
value
k
)
)
{
v
=
str
(
k
value
)
;
if
(
v
)
{
partial
.
push
(
quote
(
k
)
+
(
gap
?
'
:
'
:
'
:
'
)
+
v
)
;
}
}
}
}
v
=
partial
.
length
=
=
=
0
?
'
{
}
'
:
gap
?
'
{
\
n
'
+
gap
+
partial
.
join
(
'
\
n
'
+
gap
)
+
'
\
n
'
+
mind
+
'
}
'
:
'
{
'
+
partial
.
join
(
'
'
)
+
'
}
'
;
gap
=
mind
;
return
v
;
}
}
JSON
.
stringify
=
function
(
value
replacer
space
)
{
var
i
;
gap
=
'
'
;
indent
=
'
'
;
if
(
typeof
space
=
=
=
'
number
'
)
{
for
(
i
=
0
;
i
<
space
;
i
+
=
1
)
{
indent
+
=
'
'
;
}
}
else
if
(
typeof
space
=
=
=
'
string
'
)
{
indent
=
space
;
}
rep
=
replacer
;
if
(
replacer
&
&
typeof
replacer
!
=
=
'
function
'
&
&
(
typeof
replacer
!
=
=
'
object
'
|
|
typeof
replacer
.
length
!
=
=
'
number
'
)
)
{
throw
new
Error
(
'
JSON
.
stringify
'
)
;
}
return
str
(
'
'
{
'
'
:
value
}
)
;
}
;
JSON
.
parse
=
function
(
text
reviver
)
{
var
j
;
function
walk
(
holder
key
)
{
var
k
v
value
=
holder
[
key
]
;
if
(
value
&
&
typeof
value
=
=
=
'
object
'
)
{
for
(
k
in
value
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
value
k
)
)
{
v
=
walk
(
value
k
)
;
if
(
v
!
=
=
undefined
)
{
value
[
k
]
=
v
;
}
else
{
delete
value
[
k
]
;
}
}
}
}
return
reviver
.
call
(
holder
key
value
)
;
}
text
=
String
(
text
)
;
cx
.
lastIndex
=
0
;
if
(
cx
.
test
(
text
)
)
{
text
=
text
.
replace
(
cx
function
(
a
)
{
return
'
\
\
u
'
+
(
'
0000
'
+
a
.
charCodeAt
(
0
)
.
toString
(
16
)
)
.
slice
(
-
4
)
;
}
)
;
}
if
(
/
^
[
\
]
:
{
}
\
s
]
*
/
.
test
(
text
.
replace
(
/
\
\
(
?
:
[
"
\
\
\
/
bfnrt
]
|
u
[
0
-
9a
-
fA
-
F
]
{
4
}
)
/
g
'
'
)
.
replace
(
/
"
[
^
"
\
\
\
n
\
r
]
*
"
|
true
|
false
|
null
|
-
?
\
d
+
(
?
:
\
.
\
d
*
)
?
(
?
:
[
eE
]
[
+
\
-
]
?
\
d
+
)
?
/
g
'
]
'
)
.
replace
(
/
(
?
:
^
|
:
|
)
(
?
:
\
s
*
\
[
)
+
/
g
'
'
)
)
)
{
j
=
eval
(
'
(
'
+
text
+
'
)
'
)
;
return
typeof
reviver
=
=
=
'
function
'
?
walk
(
{
'
'
:
j
}
'
'
)
:
j
;
}
throw
new
SyntaxError
(
'
JSON
.
parse
'
)
;
}
;
return
JSON
;
}
)
(
)
;
if
(
'
undefined
'
!
=
typeof
window
)
{
window
.
expect
=
module
.
exports
;
}
}
)
(
this
true
?
module
:
{
exports
:
{
}
}
)
;
}
.
call
(
exports
__webpack_require__
(
51
)
(
module
)
__webpack_require__
(
794
)
.
Buffer
)
)
}
828
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
feature
=
__webpack_require__
(
829
)
;
module
.
exports
=
feature
;
}
829
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
pick
=
__webpack_require__
(
67
)
;
var
put
=
__webpack_require__
(
112
)
;
var
fs
=
__webpack_require__
(
118
)
;
var
path
=
__webpack_require__
(
119
)
;
var
config
=
void
0
;
var
flag
=
__webpack_require__
(
121
)
;
function
isBrowser
(
)
{
return
typeof
window
=
=
"
object
"
&
&
typeof
module
=
=
"
undefined
"
;
}
function
getValue
(
key
)
{
return
pick
(
config
key
)
;
}
function
setValue
(
key
value
)
{
return
put
(
config
key
value
)
;
}
function
isEnabled
(
key
)
{
return
config
.
features
&
&
typeof
config
.
features
[
key
]
=
=
"
object
"
?
config
.
features
[
key
]
.
enabled
:
config
.
features
[
key
]
;
}
function
isDevelopment
(
)
{
if
(
isBrowser
(
)
)
{
if
(
true
)
{
return
false
;
}
var
href
=
window
.
location
?
window
.
location
.
href
:
"
"
;
return
href
.
match
(
/
^
file
:
/
)
|
|
href
.
match
(
/
localhost
:
/
)
;
}
if
(
isFirefoxPanel
(
)
)
{
return
(
"
production
"
)
=
=
=
"
development
"
;
}
return
(
"
production
"
)
!
=
=
"
production
"
;
}
function
isTesting
(
)
{
return
flag
.
testing
;
}
function
isFirefoxPanel
(
)
{
return
(
"
firefox
-
panel
"
)
=
=
"
firefox
-
panel
"
;
}
function
isApplication
(
)
{
return
(
"
firefox
-
panel
"
)
=
=
"
application
"
;
}
function
isFirefox
(
)
{
return
(
/
firefox
/
i
.
test
(
navigator
.
userAgent
)
)
;
}
function
setConfig
(
value
)
{
config
=
value
;
}
function
getConfig
(
)
{
return
config
;
}
function
updateLocalConfig
(
relativePath
)
{
var
localConfigPath
=
path
.
resolve
(
relativePath
"
.
.
/
configs
/
local
.
json
"
)
;
var
output
=
JSON
.
stringify
(
config
null
2
)
;
fs
.
writeFileSync
(
localConfigPath
output
{
flag
:
"
w
"
}
)
;
return
output
;
}
module
.
exports
=
{
isEnabled
getValue
setValue
isDevelopment
isTesting
isFirefoxPanel
isApplication
isFirefox
getConfig
setConfig
updateLocalConfig
}
;
}
830
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
Menu
=
__webpack_require__
(
967
)
;
var
MenuItem
=
__webpack_require__
(
970
)
;
var
_require
=
__webpack_require__
(
971
)
PrefsHelper
=
_require
.
PrefsHelper
;
var
Services
=
__webpack_require__
(
29
)
;
var
_require2
=
__webpack_require__
(
972
)
KeyShortcuts
=
_require2
.
KeyShortcuts
;
module
.
exports
=
{
KeyShortcuts
Menu
MenuItem
PrefsHelper
Services
}
;
}
967
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
EventEmitter
=
__webpack_require__
(
968
)
;
function
inToolbox
(
)
{
return
window
.
parent
.
document
.
documentURI
=
=
"
about
:
devtools
-
toolbox
"
;
}
function
Menu
(
)
{
var
_ref
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
_ref
id
=
_ref
.
id
id
=
_ref
id
=
=
=
undefined
?
null
:
_ref
id
;
this
.
menuitems
=
[
]
;
this
.
id
=
id
;
Object
.
defineProperty
(
this
"
items
"
{
get
(
)
{
return
this
.
menuitems
;
}
}
)
;
EventEmitter
.
decorate
(
this
)
;
}
Menu
.
prototype
.
append
=
function
(
menuItem
)
{
this
.
menuitems
.
push
(
menuItem
)
;
}
;
Menu
.
prototype
.
insert
=
function
(
pos
menuItem
)
{
throw
Error
(
"
Not
implemented
"
)
;
}
;
Menu
.
prototype
.
popup
=
function
(
screenX
screenY
toolbox
)
{
var
doc
=
toolbox
.
doc
;
var
popupset
=
doc
.
querySelector
(
"
popupset
"
)
;
var
popup
=
popupset
.
querySelector
(
"
menupopup
[
menu
-
api
=
\
"
true
\
"
]
"
)
;
if
(
popup
)
{
popup
.
hidePopup
(
)
;
}
popup
=
this
.
createPopup
(
doc
)
;
popup
.
setAttribute
(
"
menu
-
api
"
"
true
"
)
;
if
(
this
.
id
)
{
popup
.
id
=
this
.
id
;
}
this
.
_createMenuItems
(
popup
)
;
popup
.
addEventListener
(
"
popuphidden
"
e
=
>
{
if
(
e
.
target
=
=
=
popup
)
{
popup
.
remove
(
)
;
this
.
emit
(
"
close
"
popup
)
;
}
}
)
;
popup
.
addEventListener
(
"
popupshown
"
e
=
>
{
if
(
e
.
target
=
=
=
popup
)
{
this
.
emit
(
"
open
"
popup
)
;
}
}
)
;
popupset
.
appendChild
(
popup
)
;
popup
.
openPopupAtScreen
(
screenX
screenY
true
)
;
}
;
Menu
.
prototype
.
createPopup
=
function
(
doc
)
{
return
doc
.
createElement
(
"
menupopup
"
)
;
}
;
Menu
.
prototype
.
_createMenuItems
=
function
(
parent
)
{
var
doc
=
parent
.
ownerDocument
;
this
.
menuitems
.
forEach
(
item
=
>
{
if
(
!
item
.
visible
)
{
return
;
}
if
(
item
.
submenu
)
{
var
menupopup
=
doc
.
createElement
(
"
menupopup
"
)
;
item
.
submenu
.
_createMenuItems
(
menupopup
)
;
var
menuitem
=
doc
.
createElement
(
"
menuitem
"
)
;
menuitem
.
setAttribute
(
"
label
"
item
.
label
)
;
if
(
!
inToolbox
(
)
)
{
menuitem
.
textContent
=
item
.
label
;
}
var
menu
=
doc
.
createElement
(
"
menu
"
)
;
menu
.
appendChild
(
menuitem
)
;
menu
.
appendChild
(
menupopup
)
;
if
(
item
.
disabled
)
{
menu
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
item
.
accesskey
)
{
menu
.
setAttribute
(
"
accesskey
"
item
.
accesskey
)
;
}
if
(
item
.
id
)
{
menu
.
id
=
item
.
id
;
}
parent
.
appendChild
(
menu
)
;
}
else
if
(
item
.
type
=
=
=
"
separator
"
)
{
var
menusep
=
doc
.
createElement
(
"
menuseparator
"
)
;
parent
.
appendChild
(
menusep
)
;
}
else
{
var
_menuitem
=
doc
.
createElement
(
"
menuitem
"
)
;
_menuitem
.
setAttribute
(
"
label
"
item
.
label
)
;
if
(
!
inToolbox
(
)
)
{
_menuitem
.
textContent
=
item
.
label
;
}
_menuitem
.
addEventListener
(
"
command
"
(
)
=
>
item
.
click
(
)
)
;
if
(
item
.
type
=
=
=
"
checkbox
"
)
{
_menuitem
.
setAttribute
(
"
type
"
"
checkbox
"
)
;
}
if
(
item
.
type
=
=
=
"
radio
"
)
{
_menuitem
.
setAttribute
(
"
type
"
"
radio
"
)
;
}
if
(
item
.
disabled
)
{
_menuitem
.
setAttribute
(
"
disabled
"
"
true
"
)
;
}
if
(
item
.
checked
)
{
_menuitem
.
setAttribute
(
"
checked
"
"
true
"
)
;
}
if
(
item
.
accesskey
)
{
_menuitem
.
setAttribute
(
"
accesskey
"
item
.
accesskey
)
;
}
if
(
item
.
id
)
{
_menuitem
.
id
=
item
.
id
;
}
parent
.
appendChild
(
_menuitem
)
;
}
}
)
;
}
;
Menu
.
setApplicationMenu
=
(
)
=
>
{
throw
Error
(
"
Not
implemented
"
)
;
}
;
Menu
.
sendActionToFirstResponder
=
(
)
=
>
{
throw
Error
(
"
Not
implemented
"
)
;
}
;
Menu
.
buildFromTemplate
=
(
)
=
>
{
throw
Error
(
"
Not
implemented
"
)
;
}
;
module
.
exports
=
Menu
;
}
968
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
EventEmitter
=
function
EventEmitter
(
)
{
}
;
module
.
exports
=
EventEmitter
;
var
promise
=
__webpack_require__
(
969
)
;
EventEmitter
.
decorate
=
function
EventEmitter_decorate
(
aObjectToDecorate
)
{
var
emitter
=
new
EventEmitter
(
)
;
aObjectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
aObjectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
aObjectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
aObjectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
:
function
EventEmitter_on
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
this
.
_eventEmitterListeners
=
new
Map
(
)
;
if
(
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
aEvent
)
.
push
(
aListener
)
;
}
once
:
function
EventEmitter_once
(
aEvent
aListener
)
{
var
_this
=
this
;
var
deferred
=
promise
.
defer
(
)
;
var
handler
=
function
(
aEvent
aFirstArg
)
{
for
(
var
_len
=
arguments
.
length
aRest
=
Array
(
_len
>
2
?
_len
-
2
:
0
)
_key
=
2
;
_key
<
_len
;
_key
+
+
)
{
aRest
[
_key
-
2
]
=
arguments
[
_key
]
;
}
_this
.
off
(
aEvent
handler
)
;
if
(
aListener
)
{
aListener
.
apply
(
null
[
aEvent
aFirstArg
]
.
concat
(
aRest
)
)
;
}
deferred
.
resolve
(
aFirstArg
)
;
}
;
handler
.
_originalListener
=
aListener
;
this
.
on
(
aEvent
handler
)
;
return
deferred
.
promise
;
}
off
:
function
EventEmitter_off
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
return
;
var
listeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
listeners
.
filter
(
l
=
>
{
return
l
!
=
=
aListener
&
&
l
.
_originalListener
!
=
=
aListener
;
}
)
)
;
}
}
emit
:
function
EventEmitter_emit
(
aEvent
)
{
var
_this2
=
this
_arguments
=
arguments
;
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
return
;
}
var
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
var
_loop
=
function
(
listener
)
{
if
(
!
_this2
.
_eventEmitterListeners
)
{
return
"
break
"
;
}
if
(
originalListeners
=
=
=
_this2
.
_eventEmitterListeners
.
get
(
aEvent
)
|
|
_this2
.
_eventEmitterListeners
.
get
(
aEvent
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
.
apply
(
null
_arguments
)
;
}
catch
(
ex
)
{
var
msg
=
ex
+
"
:
"
+
ex
.
stack
;
console
.
log
(
msg
)
;
}
}
}
;
for
(
var
listener
of
this
.
_eventEmitterListeners
.
get
(
aEvent
)
)
{
var
_ret
=
_loop
(
listener
)
;
if
(
_ret
=
=
=
"
break
"
)
break
;
}
}
}
;
}
969
:
function
(
module
exports
)
{
"
use
strict
"
;
var
p
=
typeof
window
!
=
"
undefined
"
?
window
.
Promise
:
Promise
;
p
.
defer
=
function
defer
(
)
{
var
resolve
reject
;
var
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
;
module
.
exports
=
p
;
}
970
:
function
(
module
exports
)
{
"
use
strict
"
;
function
MenuItem
(
)
{
var
_ref
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
{
}
_ref
accesskey
=
_ref
.
accesskey
accesskey
=
_ref
accesskey
=
=
=
undefined
?
null
:
_ref
accesskey
_ref
checked
=
_ref
.
checked
checked
=
_ref
checked
=
=
=
undefined
?
false
:
_ref
checked
_ref
click
=
_ref
.
click
click
=
_ref
click
=
=
=
undefined
?
(
)
=
>
{
}
:
_ref
click
_ref
disabled
=
_ref
.
disabled
disabled
=
_ref
disabled
=
=
=
undefined
?
false
:
_ref
disabled
_ref
label
=
_ref
.
label
label
=
_ref
label
=
=
=
undefined
?
"
"
:
_ref
label
_ref
id
=
_ref
.
id
id
=
_ref
id
=
=
=
undefined
?
null
:
_ref
id
_ref
submenu
=
_ref
.
submenu
submenu
=
_ref
submenu
=
=
=
undefined
?
null
:
_ref
submenu
_ref
type
=
_ref
.
type
type
=
_ref
type
=
=
=
undefined
?
"
normal
"
:
_ref
type
_ref
visible
=
_ref
.
visible
visible
=
_ref
visible
=
=
=
undefined
?
true
:
_ref
visible
;
this
.
accesskey
=
accesskey
;
this
.
checked
=
checked
;
this
.
click
=
click
;
this
.
disabled
=
disabled
;
this
.
id
=
id
;
this
.
label
=
label
;
this
.
submenu
=
submenu
;
this
.
type
=
type
;
this
.
visible
=
visible
;
}
module
.
exports
=
MenuItem
;
}
971
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
Services
=
__webpack_require__
(
29
)
;
var
EventEmitter
=
__webpack_require__
(
968
)
;
function
PrefsHelper
(
)
{
var
prefsRoot
=
arguments
.
length
>
0
&
&
arguments
[
0
]
!
=
=
undefined
?
arguments
[
0
]
:
"
"
;
var
prefsBlueprint
=
arguments
.
length
>
1
&
&
arguments
[
1
]
!
=
=
undefined
?
arguments
[
1
]
:
{
}
;
EventEmitter
.
decorate
(
this
)
;
var
cache
=
new
Map
(
)
;
for
(
var
accessorName
in
prefsBlueprint
)
{
var
_prefsBlueprint
acces
=
_slicedToArray
(
prefsBlueprint
[
accessorName
]
2
)
prefType
=
_prefsBlueprint
acces
[
0
]
prefName
=
_prefsBlueprint
acces
[
1
]
;
map
(
this
cache
accessorName
prefType
prefsRoot
prefName
)
;
}
var
observer
=
makeObserver
(
this
cache
prefsRoot
prefsBlueprint
)
;
this
.
registerObserver
=
(
)
=
>
observer
.
register
(
)
;
this
.
unregisterObserver
=
(
)
=
>
observer
.
unregister
(
)
;
}
function
get
(
cache
prefType
prefsRoot
prefName
)
{
var
cachedPref
=
cache
.
get
(
prefName
)
;
if
(
cachedPref
!
=
=
undefined
)
{
return
cachedPref
;
}
var
value
=
Services
.
prefs
[
"
get
"
+
prefType
+
"
Pref
"
]
(
[
prefsRoot
prefName
]
.
join
(
"
.
"
)
)
;
cache
.
set
(
prefName
value
)
;
return
value
;
}
function
set
(
cache
prefType
prefsRoot
prefName
value
)
{
Services
.
prefs
[
"
set
"
+
prefType
+
"
Pref
"
]
(
[
prefsRoot
prefName
]
.
join
(
"
.
"
)
value
)
;
cache
.
set
(
prefName
value
)
;
}
function
map
(
self
cache
accessorName
prefType
prefsRoot
prefName
)
{
var
serializer
=
arguments
.
length
>
6
&
&
arguments
[
6
]
!
=
=
undefined
?
arguments
[
6
]
:
{
in
:
e
=
>
e
out
:
e
=
>
e
}
;
if
(
prefName
in
self
)
{
throw
new
Error
(
Can
'
t
use
{
prefName
}
because
it
overrides
a
property
+
"
on
the
instance
.
"
)
;
}
if
(
prefType
=
=
"
Json
"
)
{
map
(
self
cache
accessorName
"
Char
"
prefsRoot
prefName
{
in
:
JSON
.
parse
out
:
JSON
.
stringify
}
)
;
return
;
}
if
(
prefType
=
=
"
Float
"
)
{
map
(
self
cache
accessorName
"
Char
"
prefsRoot
prefName
{
in
:
Number
.
parseFloat
out
:
n
=
>
n
+
"
"
}
)
;
return
;
}
Object
.
defineProperty
(
self
accessorName
{
get
:
(
)
=
>
serializer
.
in
(
get
(
cache
prefType
prefsRoot
prefName
)
)
set
:
e
=
>
set
(
cache
prefType
prefsRoot
prefName
serializer
.
out
(
e
)
)
}
)
;
}
function
accessorNameForPref
(
somePrefName
prefsBlueprint
)
{
for
(
var
accessorName
in
prefsBlueprint
)
{
var
_prefsBlueprint
acces2
=
_slicedToArray
(
prefsBlueprint
[
accessorName
]
2
)
prefName
=
_prefsBlueprint
acces2
[
1
]
;
if
(
somePrefName
=
=
prefName
)
{
return
accessorName
;
}
}
return
"
"
;
}
function
makeObserver
(
self
cache
prefsRoot
prefsBlueprint
)
{
return
{
register
:
function
(
)
{
this
.
_branch
=
Services
.
prefs
.
getBranch
(
prefsRoot
+
"
.
"
)
;
this
.
_branch
.
addObserver
(
"
"
this
)
;
}
unregister
:
function
(
)
{
this
.
_branch
.
removeObserver
(
"
"
this
)
;
}
observe
:
function
(
subject
topic
prefName
)
{
var
accessorName
=
accessorNameForPref
(
prefName
prefsBlueprint
)
;
if
(
!
(
accessorName
in
self
)
)
{
return
;
}
cache
.
delete
(
prefName
)
;
self
.
emit
(
"
pref
-
changed
"
accessorName
self
[
accessorName
]
)
;
}
}
;
}
exports
.
PrefsHelper
=
PrefsHelper
;
}
972
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_slicedToArray
=
function
(
)
{
function
sliceIterator
(
arr
i
)
{
var
_arr
=
[
]
;
var
_n
=
true
;
var
_d
=
false
;
var
_e
=
undefined
;
try
{
for
(
var
_i
=
arr
[
Symbol
.
iterator
]
(
)
_s
;
!
(
_n
=
(
_s
=
_i
.
next
(
)
)
.
done
)
;
_n
=
true
)
{
_arr
.
push
(
_s
.
value
)
;
if
(
i
&
&
_arr
.
length
=
=
=
i
)
break
;
}
}
catch
(
err
)
{
_d
=
true
;
_e
=
err
;
}
finally
{
try
{
if
(
!
_n
&
&
_i
[
"
return
"
]
)
_i
[
"
return
"
]
(
)
;
}
finally
{
if
(
_d
)
throw
_e
;
}
}
return
_arr
;
}
return
function
(
arr
i
)
{
if
(
Array
.
isArray
(
arr
)
)
{
return
arr
;
}
else
if
(
Symbol
.
iterator
in
Object
(
arr
)
)
{
return
sliceIterator
(
arr
i
)
;
}
else
{
throw
new
TypeError
(
"
Invalid
attempt
to
destructure
non
-
iterable
instance
"
)
;
}
}
;
}
(
)
;
var
_require
=
__webpack_require__
(
29
)
appinfo
=
_require
.
appinfo
;
var
EventEmitter
=
__webpack_require__
(
968
)
;
var
isOSX
=
appinfo
.
OS
=
=
=
"
Darwin
"
;
var
ElectronKeysMapping
=
{
"
F1
"
:
"
DOM_VK_F1
"
"
F2
"
:
"
DOM_VK_F2
"
"
F3
"
:
"
DOM_VK_F3
"
"
F4
"
:
"
DOM_VK_F4
"
"
F5
"
:
"
DOM_VK_F5
"
"
F6
"
:
"
DOM_VK_F6
"
"
F7
"
:
"
DOM_VK_F7
"
"
F8
"
:
"
DOM_VK_F8
"
"
F9
"
:
"
DOM_VK_F9
"
"
F10
"
:
"
DOM_VK_F10
"
"
F11
"
:
"
DOM_VK_F11
"
"
F12
"
:
"
DOM_VK_F12
"
"
F13
"
:
"
DOM_VK_F13
"
"
F14
"
:
"
DOM_VK_F14
"
"
F15
"
:
"
DOM_VK_F15
"
"
F16
"
:
"
DOM_VK_F16
"
"
F17
"
:
"
DOM_VK_F17
"
"
F18
"
:
"
DOM_VK_F18
"
"
F19
"
:
"
DOM_VK_F19
"
"
F20
"
:
"
DOM_VK_F20
"
"
F21
"
:
"
DOM_VK_F21
"
"
F22
"
:
"
DOM_VK_F22
"
"
F23
"
:
"
DOM_VK_F23
"
"
F24
"
:
"
DOM_VK_F24
"
"
Space
"
:
"
DOM_VK_SPACE
"
"
Backspace
"
:
"
DOM_VK_BACK_SPACE
"
"
Delete
"
:
"
DOM_VK_DELETE
"
"
Insert
"
:
"
DOM_VK_INSERT
"
"
Return
"
:
"
DOM_VK_RETURN
"
"
Enter
"
:
"
DOM_VK_RETURN
"
"
Up
"
:
"
DOM_VK_UP
"
"
Down
"
:
"
DOM_VK_DOWN
"
"
Left
"
:
"
DOM_VK_LEFT
"
"
Right
"
:
"
DOM_VK_RIGHT
"
"
Home
"
:
"
DOM_VK_HOME
"
"
End
"
:
"
DOM_VK_END
"
"
PageUp
"
:
"
DOM_VK_PAGE_UP
"
"
PageDown
"
:
"
DOM_VK_PAGE_DOWN
"
"
Escape
"
:
"
DOM_VK_ESCAPE
"
"
Esc
"
:
"
DOM_VK_ESCAPE
"
"
Tab
"
:
"
DOM_VK_TAB
"
"
VolumeUp
"
:
"
DOM_VK_VOLUME_UP
"
"
VolumeDown
"
:
"
DOM_VK_VOLUME_DOWN
"
"
VolumeMute
"
:
"
DOM_VK_VOLUME_MUTE
"
"
PrintScreen
"
:
"
DOM_VK_PRINTSCREEN
"
}
;
function
KeyShortcuts
(
_ref
)
{
var
window
=
_ref
.
window
target
=
_ref
.
target
;
this
.
window
=
window
;
this
.
target
=
target
|
|
window
;
this
.
keys
=
new
Map
(
)
;
this
.
eventEmitter
=
new
EventEmitter
(
)
;
this
.
target
.
addEventListener
(
"
keydown
"
this
)
;
}
KeyShortcuts
.
parseElectronKey
=
function
(
window
str
)
{
var
modifiers
=
str
.
split
(
"
+
"
)
;
var
key
=
modifiers
.
pop
(
)
;
var
shortcut
=
{
ctrl
:
false
meta
:
false
alt
:
false
shift
:
false
key
:
undefined
keyCode
:
undefined
}
;
for
(
var
mod
of
modifiers
)
{
if
(
mod
=
=
=
"
Alt
"
)
{
shortcut
.
alt
=
true
;
}
else
if
(
[
"
Command
"
"
Cmd
"
]
.
includes
(
mod
)
)
{
shortcut
.
meta
=
true
;
}
else
if
(
[
"
CommandOrControl
"
"
CmdOrCtrl
"
]
.
includes
(
mod
)
)
{
if
(
isOSX
)
{
shortcut
.
meta
=
true
;
}
else
{
shortcut
.
ctrl
=
true
;
}
}
else
if
(
[
"
Control
"
"
Ctrl
"
]
.
includes
(
mod
)
)
{
shortcut
.
ctrl
=
true
;
}
else
if
(
mod
=
=
=
"
Shift
"
)
{
shortcut
.
shift
=
true
;
}
else
{
console
.
error
(
"
Unsupported
modifier
:
"
mod
"
from
key
:
"
str
)
;
return
null
;
}
}
if
(
key
=
=
=
"
Plus
"
)
{
key
=
"
+
"
;
}
if
(
typeof
key
=
=
=
"
string
"
&
&
key
.
length
=
=
=
1
)
{
shortcut
.
key
=
key
.
toLowerCase
(
)
;
}
else
if
(
key
in
ElectronKeysMapping
)
{
key
=
ElectronKeysMapping
[
key
]
;
shortcut
.
keyCode
=
window
.
KeyboardEvent
[
key
]
;
shortcut
.
keyCodeString
=
key
;
shortcut
.
key
=
key
;
}
else
{
console
.
error
(
"
Unsupported
key
:
"
key
)
;
return
null
;
}
return
shortcut
;
}
;
KeyShortcuts
.
stringify
=
function
(
shortcut
)
{
var
list
=
[
]
;
if
(
shortcut
.
alt
)
{
list
.
push
(
"
Alt
"
)
;
}
if
(
shortcut
.
ctrl
)
{
list
.
push
(
"
Ctrl
"
)
;
}
if
(
shortcut
.
meta
)
{
list
.
push
(
"
Cmd
"
)
;
}
if
(
shortcut
.
shift
)
{
list
.
push
(
"
Shift
"
)
;
}
var
key
=
void
0
;
if
(
shortcut
.
key
)
{
key
=
shortcut
.
key
.
toUpperCase
(
)
;
}
else
{
key
=
shortcut
.
keyCodeString
;
}
list
.
push
(
key
)
;
return
list
.
join
(
"
+
"
)
;
}
;
KeyShortcuts
.
prototype
=
{
destroy
(
)
{
this
.
target
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
keys
.
clear
(
)
;
}
doesEventMatchShortcut
(
event
shortcut
)
{
if
(
shortcut
.
meta
!
=
event
.
metaKey
)
{
return
false
;
}
if
(
shortcut
.
ctrl
!
=
event
.
ctrlKey
)
{
return
false
;
}
if
(
shortcut
.
alt
!
=
event
.
altKey
)
{
return
false
;
}
if
(
shortcut
.
shift
!
=
event
.
shiftKey
&
&
event
.
key
&
&
event
.
key
.
match
(
/
[
a
-
zA
-
Z
]
/
)
)
{
return
false
;
}
if
(
shortcut
.
keyCode
)
{
return
event
.
keyCode
=
=
shortcut
.
keyCode
;
}
else
if
(
event
.
key
in
ElectronKeysMapping
)
{
return
ElectronKeysMapping
[
event
.
key
]
=
=
=
shortcut
.
key
;
}
var
key
=
event
.
key
|
|
String
.
fromCharCode
(
event
.
keyCode
)
;
return
key
.
toLowerCase
(
)
=
=
shortcut
.
key
|
|
shortcut
.
key
.
match
(
/
^
[
0
-
9
]
/
)
&
&
event
.
keyCode
=
=
shortcut
.
key
.
charCodeAt
(
0
)
;
}
handleEvent
(
event
)
{
for
(
var
_ref2
of
this
.
keys
)
{
var
_ref3
=
_slicedToArray
(
_ref2
2
)
;
var
key
=
_ref3
[
0
]
;
var
shortcut
=
_ref3
[
1
]
;
if
(
this
.
doesEventMatchShortcut
(
event
shortcut
)
)
{
this
.
eventEmitter
.
emit
(
key
event
)
;
}
}
}
on
(
key
listener
)
{
if
(
typeof
listener
!
=
=
"
function
"
)
{
throw
new
Error
(
"
KeyShortcuts
.
on
(
)
expects
a
function
as
"
+
"
second
argument
"
)
;
}
if
(
!
this
.
keys
.
has
(
key
)
)
{
var
shortcut
=
KeyShortcuts
.
parseElectronKey
(
this
.
window
key
)
;
if
(
!
shortcut
)
{
return
;
}
this
.
keys
.
set
(
key
shortcut
)
;
}
this
.
eventEmitter
.
on
(
key
listener
)
;
}
off
(
key
listener
)
{
this
.
eventEmitter
.
off
(
key
listener
)
;
}
}
;
exports
.
KeyShortcuts
=
KeyShortcuts
;
}
1020
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
addBreakpoint
=
_require
.
addBreakpoint
assertHighlightLocation
=
_require
.
assertHighlightLocation
selectSource
=
_require
.
selectSource
invokeInTab
=
_require
.
invokeInTab
mouseOverEl
=
_require
.
mouseOverEl
findAllElements
=
_require
.
findAllElements
waitForPaused
=
_require
.
waitForPaused
waitForDispatch
=
_require
.
waitForDispatch
;
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
EXAMPLE_URL
=
ctx
.
EXAMPLE_URL
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
long
.
js
"
)
;
yield
addBreakpoint
(
dbg
"
long
.
js
"
82
)
;
invokeInTab
(
dbg
"
toggleModel
"
)
;
yield
waitForPaused
(
dbg
)
;
var
el
=
dbg
.
win
.
cm
.
getWrapperElement
(
)
.
querySelectorAll
(
"
.
CodeMirror
-
line
"
)
[
50
]
.
querySelector
(
"
.
cm
-
variable
-
2
"
)
;
mouseOverEl
(
dbg
.
win
el
)
;
assertPausedLocation
(
dbg
ctx
"
long
.
js
"
82
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
1021
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
clickElement
=
_require
.
clickElement
evalInTab
=
_require
.
evalInTab
findElement
=
_require
.
findElement
initDebugger
=
_require
.
initDebugger
invokeInTab
=
_require
.
invokeInTab
resume
=
_require
.
resume
stepOver
=
_require
.
stepOver
waitForDispatch
=
_require
.
waitForDispatch
waitForPaused
=
_require
.
waitForPaused
waitForTime
=
_require
.
waitForTime
;
function
getScopeNodeLabel
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeNode
"
index
)
.
innerText
;
}
function
getScopeNodeValue
(
dbg
index
)
{
return
findElement
(
dbg
"
scopeValue
"
index
)
.
innerText
;
}
function
expandNode
(
dbg
index
)
{
var
onLoadProperties
=
onLoadObjectProperties
(
dbg
)
;
clickElement
(
dbg
"
scopeNode
"
index
)
;
return
onLoadProperties
;
}
function
toggleScopes
(
dbg
)
{
return
findElement
(
dbg
"
scopesHeader
"
)
.
click
(
)
;
}
function
onLoadObjectProperties
(
dbg
)
{
return
waitForDispatch
(
dbg
"
LOAD_OBJECT_PROPERTIES
"
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
;
console
.
log
(
"
>
>
>
starting
"
)
;
var
dbg
=
yield
initDebugger
(
"
doc
-
script
-
mutate
.
html
"
"
script
-
mutate
"
)
;
toggleScopes
(
dbg
)
;
var
onPaused
=
waitForPaused
(
dbg
)
;
invokeInTab
(
dbg
"
mutate
"
)
;
yield
onPaused
;
is
(
getScopeNodeLabel
(
dbg
2
)
"
<
this
>
"
'
The
second
element
in
the
scope
panel
is
"
<
this
>
"
'
)
;
is
(
getScopeNodeLabel
(
dbg
3
)
"
phonebook
"
'
The
third
element
in
the
scope
panel
is
"
phonebook
"
'
)
;
yield
expandNode
(
dbg
3
)
;
is
(
getScopeNodeLabel
(
dbg
4
)
"
S
"
'
The
fourth
element
in
the
scope
panel
is
"
S
"
'
)
;
yield
expandNode
(
dbg
4
)
;
is
(
getScopeNodeLabel
(
dbg
5
)
"
sarah
"
'
The
fifth
element
in
the
scope
panel
is
"
sarah
"
'
)
;
is
(
getScopeNodeLabel
(
dbg
6
)
"
serena
"
'
The
sixth
element
in
the
scope
panel
is
"
serena
"
'
)
;
yield
expandNode
(
dbg
5
)
;
is
(
getScopeNodeLabel
(
dbg
6
)
"
lastName
"
'
The
sixth
element
in
the
scope
panel
is
now
"
lastName
"
'
)
;
is
(
getScopeNodeValue
(
dbg
6
)
'
"
Doe
"
'
'
The
"
lastName
"
element
has
the
expected
"
Doe
"
value
'
)
;
info
(
"
Resuming
"
)
;
onPaused
=
waitForPaused
(
dbg
)
;
yield
resume
(
dbg
)
;
yield
onPaused
;
is
(
getScopeNodeLabel
(
dbg
2
)
"
<
this
>
"
'
The
second
element
in
the
scope
panel
is
"
<
this
>
"
'
)
;
is
(
getScopeNodeLabel
(
dbg
3
)
"
phonebook
"
'
The
third
element
in
the
scope
panel
is
"
phonebook
"
'
)
;
}
)
;
return
function
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
1022
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
var
addTabs
=
exports
.
addTabs
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
requestLongerTimeout
=
ctx
.
requestLongerTimeout
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
simple1
"
"
simple2
"
)
;
yield
selectSource
(
dbg
"
simple1
"
)
;
yield
selectSource
(
dbg
"
simple2
"
)
;
expect
(
countTabs
(
dbg
)
)
.
to
.
equal
(
2
)
;
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
simple1
"
"
simple2
"
)
;
expect
(
countTabs
(
dbg
)
)
.
to
.
equal
(
2
)
;
yield
selectSource
(
dbg
"
simple2
"
)
;
yield
reload
(
dbg
"
simple1
"
"
simple2
"
)
;
yield
waitForDispatch
(
dbg
"
LOAD_SOURCE_TEXT
"
)
;
expect
(
countTabs
(
dbg
)
)
.
to
.
equal
(
2
)
;
}
)
;
return
function
addTabs
(
_x
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
reloadWithTabs
=
exports
.
reloadWithTabs
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
requestLongerTimeout
=
ctx
.
requestLongerTimeout
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
simple1
"
"
simple2
"
)
;
yield
selectSource
(
dbg
"
simple1
"
)
;
yield
selectSource
(
dbg
"
simple2
"
)
;
expect
(
countTabs
(
dbg
)
)
.
to
.
equal
(
2
)
;
yield
reload
(
dbg
"
simple1
"
"
simple2
"
)
;
yield
waitForDispatch
(
dbg
"
SELECT_SOURCE
"
)
;
expect
(
countTabs
(
dbg
)
)
.
to
.
equal
(
2
)
;
}
)
;
return
function
reloadWithTabs
(
_x2
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
var
reloadWithNoTabs
=
exports
.
reloadWithNoTabs
=
(
(
)
=
>
{
var
_ref3
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
requestLongerTimeout
=
ctx
.
requestLongerTimeout
;
var
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
simple1
"
"
simple2
"
)
;
yield
selectSource
(
dbg
"
simple1
"
)
;
yield
selectSource
(
dbg
"
simple2
"
)
;
closeTab
(
dbg
"
simple1
"
)
;
closeTab
(
dbg
"
simple2
"
)
;
dbg
=
yield
initDebugger
(
"
doc
-
scripts
.
html
"
"
simple1
"
"
simple2
"
)
;
expect
(
countTabs
(
dbg
)
)
.
to
.
equal
(
0
)
;
}
)
;
return
function
reloadWithNoTabs
(
_x3
)
{
return
_ref3
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
reload
=
_require
.
reload
selectSource
=
_require
.
selectSource
findElement
=
_require
.
findElement
waitForDispatch
=
_require
.
waitForDispatch
closeTab
=
_require
.
closeTab
;
function
countTabs
(
dbg
)
{
return
findElement
(
dbg
"
sourceTabs
"
)
.
children
.
length
;
}
}
1129
:
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
var
_require
=
__webpack_require__
(
760
)
initDebugger
=
_require
.
initDebugger
reload
=
_require
.
reload
selectSource
=
_require
.
selectSource
findElement
=
_require
.
findElement
waitForDispatch
=
_require
.
waitForDispatch
closeTab
=
_require
.
closeTab
assertPausedLocation
=
_require
.
assertPausedLocation
findSource
=
_require
.
findSource
waitForSources
=
_require
.
waitForSources
disableBreakpoint
=
_require
.
disableBreakpoint
addBreakpoint
=
_require
.
addBreakpoint
waitForPaused
=
_require
.
waitForPaused
;
function
assertBP
(
dbg
sourceId
_ref
)
{
var
line
=
_ref
.
line
_ref
disabled
=
_ref
.
disabled
disabled
=
_ref
disabled
=
=
=
undefined
?
false
:
_ref
disabled
;
var
_dbg
selectors
=
dbg
.
selectors
getBreakpoint
=
_dbg
selectors
.
getBreakpoint
getBreakpoints
=
_dbg
selectors
.
getBreakpoints
getState
=
dbg
.
getState
;
var
bp
=
getBreakpoint
(
getState
(
)
{
sourceId
line
}
)
;
is
(
bp
.
location
.
line
line
"
Breakpoint
has
correct
line
"
)
;
is
(
bp
.
disabled
disabled
)
;
}
module
.
exports
=
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
ctx
)
{
var
ok
=
ctx
.
ok
is
=
ctx
.
is
info
=
ctx
.
info
requestLongerTimeout
=
ctx
.
requestLongerTimeout
;
var
dbg
=
yield
initDebugger
(
"
doc
-
sourcemaps
.
html
"
)
;
var
_dbg
selectors2
=
dbg
.
selectors
getBreakpoint
=
_dbg
selectors2
.
getBreakpoint
getBreakpoints
=
_dbg
selectors2
.
getBreakpoints
getState
=
dbg
.
getState
;
yield
waitForSources
(
dbg
"
entry
.
js
"
"
output
.
js
"
"
times2
.
js
"
"
opts
.
js
"
)
;
var
entrySrc
=
findSource
(
dbg
"
entry
.
js
"
)
;
yield
selectSource
(
dbg
entrySrc
)
;
yield
addBreakpoint
(
dbg
entrySrc
13
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
1
"
One
breakpoint
exists
"
)
;
assertBP
(
dbg
entrySrc
.
id
{
line
:
13
}
)
;
yield
addBreakpoint
(
dbg
entrySrc
15
)
;
yield
disableBreakpoint
(
dbg
entrySrc
15
)
;
yield
reload
(
dbg
"
times2
.
js
"
"
opts
.
js
"
)
;
yield
waitForDispatch
(
dbg
"
LOAD_SOURCE_TEXT
"
)
;
is
(
getBreakpoints
(
getState
(
)
)
.
size
2
"
One
breakpoint
exists
"
)
;
assertBP
(
dbg
entrySrc
.
id
{
line
:
13
}
)
;
assertBP
(
dbg
entrySrc
.
id
{
line
:
15
disabled
:
true
}
)
;
}
)
;
function
sourceMapsReloading
(
_x
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
return
sourceMapsReloading
;
}
)
(
)
;
}
}
)
}
)
;
;
