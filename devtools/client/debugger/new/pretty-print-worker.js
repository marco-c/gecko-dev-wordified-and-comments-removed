(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
]
factory
)
;
else
{
var
a
=
factory
(
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
this
function
(
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
{
return
installedModules
[
moduleId
]
.
exports
;
}
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
380
)
;
}
)
(
{
380
:
(
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
964
)
;
}
)
381
:
(
function
(
module
exports
__webpack_require__
)
{
var
require
;
var
require
;
(
function
(
f
)
{
if
(
true
)
{
module
.
exports
=
f
(
)
}
else
if
(
typeof
define
=
=
=
"
function
"
&
&
define
.
amd
)
{
define
(
[
]
f
)
}
else
{
var
g
;
if
(
typeof
window
!
=
=
"
undefined
"
)
{
g
=
window
}
else
if
(
typeof
global
!
=
=
"
undefined
"
)
{
g
=
global
}
else
if
(
typeof
self
!
=
=
"
undefined
"
)
{
g
=
self
}
else
{
g
=
this
}
g
.
acorn
=
f
(
)
}
}
)
(
function
(
)
{
var
define
module
exports
;
return
(
function
e
(
t
n
r
)
{
function
s
(
o
u
)
{
if
(
!
n
[
o
]
)
{
if
(
!
t
[
o
]
)
{
var
a
=
typeof
require
=
=
"
function
"
&
&
require
;
if
(
!
u
&
&
a
)
return
require
(
o
!
0
)
;
if
(
i
)
return
i
(
o
!
0
)
;
var
f
=
new
Error
(
"
Cannot
find
module
'
"
+
o
+
"
'
"
)
;
throw
f
.
code
=
"
MODULE_NOT_FOUND
"
f
}
var
l
=
n
[
o
]
=
{
exports
:
{
}
}
;
t
[
o
]
[
0
]
.
call
(
l
.
exports
function
(
e
)
{
var
n
=
t
[
o
]
[
1
]
[
e
]
;
return
s
(
n
?
n
:
e
)
}
l
l
.
exports
e
t
n
r
)
}
return
n
[
o
]
.
exports
}
var
i
=
typeof
require
=
=
"
function
"
&
&
require
;
for
(
var
o
=
0
;
o
<
r
.
length
;
o
+
+
)
s
(
r
[
o
]
)
;
return
s
}
)
(
{
1
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
pp
=
_state
.
Parser
.
prototype
;
pp
.
checkPropClash
=
function
(
prop
propHash
)
{
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
(
prop
.
computed
|
|
prop
.
method
|
|
prop
.
shorthand
)
)
return
;
var
key
=
prop
.
key
;
var
name
=
undefined
;
switch
(
key
.
type
)
{
case
"
Identifier
"
:
name
=
key
.
name
;
break
;
case
"
Literal
"
:
name
=
String
(
key
.
value
)
;
break
;
default
:
return
;
}
var
kind
=
prop
.
kind
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
if
(
name
=
=
=
"
__proto__
"
&
&
kind
=
=
=
"
init
"
)
{
if
(
propHash
.
proto
)
this
.
raise
(
key
.
start
"
Redefinition
of
__proto__
property
"
)
;
propHash
.
proto
=
true
;
}
return
;
}
name
=
"
"
+
name
;
var
other
=
propHash
[
name
]
;
if
(
other
)
{
var
isGetSet
=
kind
!
=
=
"
init
"
;
if
(
(
this
.
strict
|
|
isGetSet
)
&
&
other
[
kind
]
|
|
!
(
isGetSet
^
other
.
init
)
)
this
.
raise
(
key
.
start
"
Redefinition
of
property
"
)
;
}
else
{
other
=
propHash
[
name
]
=
{
init
:
false
get
:
false
set
:
false
}
;
}
other
[
kind
]
=
true
;
}
;
pp
.
parseExpression
=
function
(
noIn
refDestructuringErrors
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseMaybeAssign
(
noIn
refDestructuringErrors
)
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
comma
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
expressions
=
[
expr
]
;
while
(
this
.
eat
(
_tokentype
.
types
.
comma
)
)
node
.
expressions
.
push
(
this
.
parseMaybeAssign
(
noIn
refDestructuringErrors
)
)
;
return
this
.
finishNode
(
node
"
SequenceExpression
"
)
;
}
return
expr
;
}
;
pp
.
parseMaybeAssign
=
function
(
noIn
refDestructuringErrors
afterLeftParse
)
{
if
(
this
.
type
=
=
_tokentype
.
types
.
_yield
&
&
this
.
inGenerator
)
return
this
.
parseYield
(
)
;
var
validateDestructuring
=
false
;
if
(
!
refDestructuringErrors
)
{
refDestructuringErrors
=
{
shorthandAssign
:
0
trailingComma
:
0
}
;
validateDestructuring
=
true
;
}
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
if
(
this
.
type
=
=
_tokentype
.
types
.
parenL
|
|
this
.
type
=
=
_tokentype
.
types
.
name
)
this
.
potentialArrowAt
=
this
.
start
;
var
left
=
this
.
parseMaybeConditional
(
noIn
refDestructuringErrors
)
;
if
(
afterLeftParse
)
left
=
afterLeftParse
.
call
(
this
left
startPos
startLoc
)
;
if
(
this
.
type
.
isAssign
)
{
if
(
validateDestructuring
)
this
.
checkPatternErrors
(
refDestructuringErrors
true
)
;
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
operator
=
this
.
value
;
node
.
left
=
this
.
type
=
=
=
_tokentype
.
types
.
eq
?
this
.
toAssignable
(
left
)
:
left
;
refDestructuringErrors
.
shorthandAssign
=
0
;
this
.
checkLVal
(
left
)
;
this
.
next
(
)
;
node
.
right
=
this
.
parseMaybeAssign
(
noIn
)
;
return
this
.
finishNode
(
node
"
AssignmentExpression
"
)
;
}
else
{
if
(
validateDestructuring
)
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
}
return
left
;
}
;
pp
.
parseMaybeConditional
=
function
(
noIn
refDestructuringErrors
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseExprOps
(
noIn
refDestructuringErrors
)
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
)
return
expr
;
if
(
this
.
eat
(
_tokentype
.
types
.
question
)
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
test
=
expr
;
node
.
consequent
=
this
.
parseMaybeAssign
(
)
;
this
.
expect
(
_tokentype
.
types
.
colon
)
;
node
.
alternate
=
this
.
parseMaybeAssign
(
noIn
)
;
return
this
.
finishNode
(
node
"
ConditionalExpression
"
)
;
}
return
expr
;
}
;
pp
.
parseExprOps
=
function
(
noIn
refDestructuringErrors
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseMaybeUnary
(
refDestructuringErrors
)
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
)
return
expr
;
return
this
.
parseExprOp
(
expr
startPos
startLoc
-
1
noIn
)
;
}
;
pp
.
parseExprOp
=
function
(
left
leftStartPos
leftStartLoc
minPrec
noIn
)
{
var
prec
=
this
.
type
.
binop
;
if
(
prec
!
=
null
&
&
(
!
noIn
|
|
this
.
type
!
=
=
_tokentype
.
types
.
_in
)
)
{
if
(
prec
>
minPrec
)
{
var
node
=
this
.
startNodeAt
(
leftStartPos
leftStartLoc
)
;
node
.
left
=
left
;
node
.
operator
=
this
.
value
;
var
op
=
this
.
type
;
this
.
next
(
)
;
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
node
.
right
=
this
.
parseExprOp
(
this
.
parseMaybeUnary
(
)
startPos
startLoc
prec
noIn
)
;
this
.
finishNode
(
node
op
=
=
=
_tokentype
.
types
.
logicalOR
|
|
op
=
=
=
_tokentype
.
types
.
logicalAND
?
"
LogicalExpression
"
:
"
BinaryExpression
"
)
;
return
this
.
parseExprOp
(
node
leftStartPos
leftStartLoc
minPrec
noIn
)
;
}
}
return
left
;
}
;
pp
.
parseMaybeUnary
=
function
(
refDestructuringErrors
)
{
if
(
this
.
type
.
prefix
)
{
var
node
=
this
.
startNode
(
)
update
=
this
.
type
=
=
=
_tokentype
.
types
.
incDec
;
node
.
operator
=
this
.
value
;
node
.
prefix
=
true
;
this
.
next
(
)
;
node
.
argument
=
this
.
parseMaybeUnary
(
)
;
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
if
(
update
)
this
.
checkLVal
(
node
.
argument
)
;
else
if
(
this
.
strict
&
&
node
.
operator
=
=
=
"
delete
"
&
&
node
.
argument
.
type
=
=
=
"
Identifier
"
)
this
.
raise
(
node
.
start
"
Deleting
local
variable
in
strict
mode
"
)
;
return
this
.
finishNode
(
node
update
?
"
UpdateExpression
"
:
"
UnaryExpression
"
)
;
}
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseExprSubscripts
(
refDestructuringErrors
)
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
)
return
expr
;
while
(
this
.
type
.
postfix
&
&
!
this
.
canInsertSemicolon
(
)
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
operator
=
this
.
value
;
node
.
prefix
=
false
;
node
.
argument
=
expr
;
this
.
checkLVal
(
expr
)
;
this
.
next
(
)
;
expr
=
this
.
finishNode
(
node
"
UpdateExpression
"
)
;
}
return
expr
;
}
;
pp
.
parseExprSubscripts
=
function
(
refDestructuringErrors
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
expr
=
this
.
parseExprAtom
(
refDestructuringErrors
)
;
var
skipArrowSubscripts
=
expr
.
type
=
=
=
"
ArrowFunctionExpression
"
&
&
this
.
input
.
slice
(
this
.
lastTokStart
this
.
lastTokEnd
)
!
=
=
"
)
"
;
if
(
this
.
checkExpressionErrors
(
refDestructuringErrors
)
|
|
skipArrowSubscripts
)
return
expr
;
return
this
.
parseSubscripts
(
expr
startPos
startLoc
)
;
}
;
pp
.
parseSubscripts
=
function
(
base
startPos
startLoc
noCalls
)
{
for
(
;
;
)
{
if
(
this
.
eat
(
_tokentype
.
types
.
dot
)
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
object
=
base
;
node
.
property
=
this
.
parseIdent
(
true
)
;
node
.
computed
=
false
;
base
=
this
.
finishNode
(
node
"
MemberExpression
"
)
;
}
else
if
(
this
.
eat
(
_tokentype
.
types
.
bracketL
)
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
object
=
base
;
node
.
property
=
this
.
parseExpression
(
)
;
node
.
computed
=
true
;
this
.
expect
(
_tokentype
.
types
.
bracketR
)
;
base
=
this
.
finishNode
(
node
"
MemberExpression
"
)
;
}
else
if
(
!
noCalls
&
&
this
.
eat
(
_tokentype
.
types
.
parenL
)
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
callee
=
base
;
node
.
arguments
=
this
.
parseExprList
(
_tokentype
.
types
.
parenR
false
)
;
base
=
this
.
finishNode
(
node
"
CallExpression
"
)
;
}
else
if
(
this
.
type
=
=
=
_tokentype
.
types
.
backQuote
)
{
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
tag
=
base
;
node
.
quasi
=
this
.
parseTemplate
(
)
;
base
=
this
.
finishNode
(
node
"
TaggedTemplateExpression
"
)
;
}
else
{
return
base
;
}
}
}
;
pp
.
parseExprAtom
=
function
(
refDestructuringErrors
)
{
var
node
=
undefined
canBeArrow
=
this
.
potentialArrowAt
=
=
this
.
start
;
switch
(
this
.
type
)
{
case
_tokentype
.
types
.
_super
:
if
(
!
this
.
inFunction
)
this
.
raise
(
this
.
start
"
'
super
'
outside
of
function
or
class
"
)
;
case
_tokentype
.
types
.
_this
:
var
type
=
this
.
type
=
=
=
_tokentype
.
types
.
_this
?
"
ThisExpression
"
:
"
Super
"
;
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
return
this
.
finishNode
(
node
type
)
;
case
_tokentype
.
types
.
_yield
:
if
(
this
.
inGenerator
)
this
.
unexpected
(
)
;
case
_tokentype
.
types
.
name
:
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
var
id
=
this
.
parseIdent
(
this
.
type
!
=
=
_tokentype
.
types
.
name
)
;
if
(
canBeArrow
&
&
!
this
.
canInsertSemicolon
(
)
&
&
this
.
eat
(
_tokentype
.
types
.
arrow
)
)
return
this
.
parseArrowExpression
(
this
.
startNodeAt
(
startPos
startLoc
)
[
id
]
)
;
return
id
;
case
_tokentype
.
types
.
regexp
:
var
value
=
this
.
value
;
node
=
this
.
parseLiteral
(
value
.
value
)
;
node
.
regex
=
{
pattern
:
value
.
pattern
flags
:
value
.
flags
}
;
return
node
;
case
_tokentype
.
types
.
num
:
case
_tokentype
.
types
.
string
:
return
this
.
parseLiteral
(
this
.
value
)
;
case
_tokentype
.
types
.
_null
:
case
_tokentype
.
types
.
_true
:
case
_tokentype
.
types
.
_false
:
node
=
this
.
startNode
(
)
;
node
.
value
=
this
.
type
=
=
=
_tokentype
.
types
.
_null
?
null
:
this
.
type
=
=
=
_tokentype
.
types
.
_true
;
node
.
raw
=
this
.
type
.
keyword
;
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
Literal
"
)
;
case
_tokentype
.
types
.
parenL
:
return
this
.
parseParenAndDistinguishExpression
(
canBeArrow
)
;
case
_tokentype
.
types
.
bracketL
:
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
if
(
this
.
options
.
ecmaVersion
>
=
7
&
&
this
.
type
=
=
=
_tokentype
.
types
.
_for
)
{
return
this
.
parseComprehension
(
node
false
)
;
}
node
.
elements
=
this
.
parseExprList
(
_tokentype
.
types
.
bracketR
true
true
refDestructuringErrors
)
;
return
this
.
finishNode
(
node
"
ArrayExpression
"
)
;
case
_tokentype
.
types
.
braceL
:
return
this
.
parseObj
(
false
refDestructuringErrors
)
;
case
_tokentype
.
types
.
_function
:
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
return
this
.
parseFunction
(
node
false
)
;
case
_tokentype
.
types
.
_class
:
return
this
.
parseClass
(
this
.
startNode
(
)
false
)
;
case
_tokentype
.
types
.
_new
:
return
this
.
parseNew
(
)
;
case
_tokentype
.
types
.
backQuote
:
return
this
.
parseTemplate
(
)
;
default
:
this
.
unexpected
(
)
;
}
}
;
pp
.
parseLiteral
=
function
(
value
)
{
var
node
=
this
.
startNode
(
)
;
node
.
value
=
value
;
node
.
raw
=
this
.
input
.
slice
(
this
.
start
this
.
end
)
;
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
Literal
"
)
;
}
;
pp
.
parseParenExpression
=
function
(
)
{
this
.
expect
(
_tokentype
.
types
.
parenL
)
;
var
val
=
this
.
parseExpression
(
)
;
this
.
expect
(
_tokentype
.
types
.
parenR
)
;
return
val
;
}
;
pp
.
parseParenAndDistinguishExpression
=
function
(
canBeArrow
)
{
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
val
=
undefined
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
this
.
next
(
)
;
if
(
this
.
options
.
ecmaVersion
>
=
7
&
&
this
.
type
=
=
=
_tokentype
.
types
.
_for
)
{
return
this
.
parseComprehension
(
this
.
startNodeAt
(
startPos
startLoc
)
true
)
;
}
var
innerStartPos
=
this
.
start
innerStartLoc
=
this
.
startLoc
;
var
exprList
=
[
]
first
=
true
;
var
refDestructuringErrors
=
{
shorthandAssign
:
0
trailingComma
:
0
}
spreadStart
=
undefined
innerParenStart
=
undefined
;
while
(
this
.
type
!
=
=
_tokentype
.
types
.
parenR
)
{
first
?
first
=
false
:
this
.
expect
(
_tokentype
.
types
.
comma
)
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
ellipsis
)
{
spreadStart
=
this
.
start
;
exprList
.
push
(
this
.
parseParenItem
(
this
.
parseRest
(
)
)
)
;
break
;
}
else
{
if
(
this
.
type
=
=
=
_tokentype
.
types
.
parenL
&
&
!
innerParenStart
)
{
innerParenStart
=
this
.
start
;
}
exprList
.
push
(
this
.
parseMaybeAssign
(
false
refDestructuringErrors
this
.
parseParenItem
)
)
;
}
}
var
innerEndPos
=
this
.
start
innerEndLoc
=
this
.
startLoc
;
this
.
expect
(
_tokentype
.
types
.
parenR
)
;
if
(
canBeArrow
&
&
!
this
.
canInsertSemicolon
(
)
&
&
this
.
eat
(
_tokentype
.
types
.
arrow
)
)
{
this
.
checkPatternErrors
(
refDestructuringErrors
true
)
;
if
(
innerParenStart
)
this
.
unexpected
(
innerParenStart
)
;
return
this
.
parseParenArrowList
(
startPos
startLoc
exprList
)
;
}
if
(
!
exprList
.
length
)
this
.
unexpected
(
this
.
lastTokStart
)
;
if
(
spreadStart
)
this
.
unexpected
(
spreadStart
)
;
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
if
(
exprList
.
length
>
1
)
{
val
=
this
.
startNodeAt
(
innerStartPos
innerStartLoc
)
;
val
.
expressions
=
exprList
;
this
.
finishNodeAt
(
val
"
SequenceExpression
"
innerEndPos
innerEndLoc
)
;
}
else
{
val
=
exprList
[
0
]
;
}
}
else
{
val
=
this
.
parseParenExpression
(
)
;
}
if
(
this
.
options
.
preserveParens
)
{
var
par
=
this
.
startNodeAt
(
startPos
startLoc
)
;
par
.
expression
=
val
;
return
this
.
finishNode
(
par
"
ParenthesizedExpression
"
)
;
}
else
{
return
val
;
}
}
;
pp
.
parseParenItem
=
function
(
item
)
{
return
item
;
}
;
pp
.
parseParenArrowList
=
function
(
startPos
startLoc
exprList
)
{
return
this
.
parseArrowExpression
(
this
.
startNodeAt
(
startPos
startLoc
)
exprList
)
;
}
;
var
empty
=
[
]
;
pp
.
parseNew
=
function
(
)
{
var
node
=
this
.
startNode
(
)
;
var
meta
=
this
.
parseIdent
(
true
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
eat
(
_tokentype
.
types
.
dot
)
)
{
node
.
meta
=
meta
;
node
.
property
=
this
.
parseIdent
(
true
)
;
if
(
node
.
property
.
name
!
=
=
"
target
"
)
this
.
raise
(
node
.
property
.
start
"
The
only
valid
meta
property
for
new
is
new
.
target
"
)
;
if
(
!
this
.
inFunction
)
this
.
raise
(
node
.
start
"
new
.
target
can
only
be
used
in
functions
"
)
;
return
this
.
finishNode
(
node
"
MetaProperty
"
)
;
}
var
startPos
=
this
.
start
startLoc
=
this
.
startLoc
;
node
.
callee
=
this
.
parseSubscripts
(
this
.
parseExprAtom
(
)
startPos
startLoc
true
)
;
if
(
this
.
eat
(
_tokentype
.
types
.
parenL
)
)
node
.
arguments
=
this
.
parseExprList
(
_tokentype
.
types
.
parenR
false
)
;
else
node
.
arguments
=
empty
;
return
this
.
finishNode
(
node
"
NewExpression
"
)
;
}
;
pp
.
parseTemplateElement
=
function
(
)
{
var
elem
=
this
.
startNode
(
)
;
elem
.
value
=
{
raw
:
this
.
input
.
slice
(
this
.
start
this
.
end
)
.
replace
(
/
\
r
\
n
?
/
g
'
\
n
'
)
cooked
:
this
.
value
}
;
this
.
next
(
)
;
elem
.
tail
=
this
.
type
=
=
=
_tokentype
.
types
.
backQuote
;
return
this
.
finishNode
(
elem
"
TemplateElement
"
)
;
}
;
pp
.
parseTemplate
=
function
(
)
{
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
expressions
=
[
]
;
var
curElt
=
this
.
parseTemplateElement
(
)
;
node
.
quasis
=
[
curElt
]
;
while
(
!
curElt
.
tail
)
{
this
.
expect
(
_tokentype
.
types
.
dollarBraceL
)
;
node
.
expressions
.
push
(
this
.
parseExpression
(
)
)
;
this
.
expect
(
_tokentype
.
types
.
braceR
)
;
node
.
quasis
.
push
(
curElt
=
this
.
parseTemplateElement
(
)
)
;
}
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
TemplateLiteral
"
)
;
}
;
pp
.
parseObj
=
function
(
isPattern
refDestructuringErrors
)
{
var
node
=
this
.
startNode
(
)
first
=
true
propHash
=
{
}
;
node
.
properties
=
[
]
;
this
.
next
(
)
;
while
(
!
this
.
eat
(
_tokentype
.
types
.
braceR
)
)
{
if
(
!
first
)
{
this
.
expect
(
_tokentype
.
types
.
comma
)
;
if
(
this
.
afterTrailingComma
(
_tokentype
.
types
.
braceR
)
)
break
;
}
else
first
=
false
;
var
prop
=
this
.
startNode
(
)
isGenerator
=
undefined
startPos
=
undefined
startLoc
=
undefined
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
prop
.
method
=
false
;
prop
.
shorthand
=
false
;
if
(
isPattern
|
|
refDestructuringErrors
)
{
startPos
=
this
.
start
;
startLoc
=
this
.
startLoc
;
}
if
(
!
isPattern
)
isGenerator
=
this
.
eat
(
_tokentype
.
types
.
star
)
;
}
this
.
parsePropertyName
(
prop
)
;
this
.
parsePropertyValue
(
prop
isPattern
isGenerator
startPos
startLoc
refDestructuringErrors
)
;
this
.
checkPropClash
(
prop
propHash
)
;
node
.
properties
.
push
(
this
.
finishNode
(
prop
"
Property
"
)
)
;
}
return
this
.
finishNode
(
node
isPattern
?
"
ObjectPattern
"
:
"
ObjectExpression
"
)
;
}
;
pp
.
parsePropertyValue
=
function
(
prop
isPattern
isGenerator
startPos
startLoc
refDestructuringErrors
)
{
if
(
this
.
eat
(
_tokentype
.
types
.
colon
)
)
{
prop
.
value
=
isPattern
?
this
.
parseMaybeDefault
(
this
.
start
this
.
startLoc
)
:
this
.
parseMaybeAssign
(
false
refDestructuringErrors
)
;
prop
.
kind
=
"
init
"
;
}
else
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
type
=
=
=
_tokentype
.
types
.
parenL
)
{
if
(
isPattern
)
this
.
unexpected
(
)
;
prop
.
kind
=
"
init
"
;
prop
.
method
=
true
;
prop
.
value
=
this
.
parseMethod
(
isGenerator
)
;
}
else
if
(
this
.
options
.
ecmaVersion
>
=
5
&
&
!
prop
.
computed
&
&
prop
.
key
.
type
=
=
=
"
Identifier
"
&
&
(
prop
.
key
.
name
=
=
=
"
get
"
|
|
prop
.
key
.
name
=
=
=
"
set
"
)
&
&
(
this
.
type
!
=
_tokentype
.
types
.
comma
&
&
this
.
type
!
=
_tokentype
.
types
.
braceR
)
)
{
if
(
isGenerator
|
|
isPattern
)
this
.
unexpected
(
)
;
prop
.
kind
=
prop
.
key
.
name
;
this
.
parsePropertyName
(
prop
)
;
prop
.
value
=
this
.
parseMethod
(
false
)
;
var
paramCount
=
prop
.
kind
=
=
=
"
get
"
?
0
:
1
;
if
(
prop
.
value
.
params
.
length
!
=
=
paramCount
)
{
var
start
=
prop
.
value
.
start
;
if
(
prop
.
kind
=
=
=
"
get
"
)
this
.
raise
(
start
"
getter
should
have
no
params
"
)
;
else
this
.
raise
(
start
"
setter
should
have
exactly
one
param
"
)
;
}
}
else
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
!
prop
.
computed
&
&
prop
.
key
.
type
=
=
=
"
Identifier
"
)
{
prop
.
kind
=
"
init
"
;
if
(
isPattern
)
{
if
(
this
.
keywords
.
test
(
prop
.
key
.
name
)
|
|
(
this
.
strict
?
this
.
reservedWordsStrictBind
:
this
.
reservedWords
)
.
test
(
prop
.
key
.
name
)
)
this
.
raise
(
prop
.
key
.
start
"
Binding
"
+
prop
.
key
.
name
)
;
prop
.
value
=
this
.
parseMaybeDefault
(
startPos
startLoc
prop
.
key
)
;
}
else
if
(
this
.
type
=
=
=
_tokentype
.
types
.
eq
&
&
refDestructuringErrors
)
{
if
(
!
refDestructuringErrors
.
shorthandAssign
)
refDestructuringErrors
.
shorthandAssign
=
this
.
start
;
prop
.
value
=
this
.
parseMaybeDefault
(
startPos
startLoc
prop
.
key
)
;
}
else
{
prop
.
value
=
prop
.
key
;
}
prop
.
shorthand
=
true
;
}
else
this
.
unexpected
(
)
;
}
;
pp
.
parsePropertyName
=
function
(
prop
)
{
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
if
(
this
.
eat
(
_tokentype
.
types
.
bracketL
)
)
{
prop
.
computed
=
true
;
prop
.
key
=
this
.
parseMaybeAssign
(
)
;
this
.
expect
(
_tokentype
.
types
.
bracketR
)
;
return
prop
.
key
;
}
else
{
prop
.
computed
=
false
;
}
}
return
prop
.
key
=
this
.
type
=
=
=
_tokentype
.
types
.
num
|
|
this
.
type
=
=
=
_tokentype
.
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
parseIdent
(
true
)
;
}
;
pp
.
initFunction
=
function
(
node
)
{
node
.
id
=
null
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
node
.
generator
=
false
;
node
.
expression
=
false
;
}
}
;
pp
.
parseMethod
=
function
(
isGenerator
)
{
var
node
=
this
.
startNode
(
)
;
this
.
initFunction
(
node
)
;
this
.
expect
(
_tokentype
.
types
.
parenL
)
;
node
.
params
=
this
.
parseBindingList
(
_tokentype
.
types
.
parenR
false
false
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
node
.
generator
=
isGenerator
;
this
.
parseFunctionBody
(
node
false
)
;
return
this
.
finishNode
(
node
"
FunctionExpression
"
)
;
}
;
pp
.
parseArrowExpression
=
function
(
node
params
)
{
this
.
initFunction
(
node
)
;
node
.
params
=
this
.
toAssignableList
(
params
true
)
;
this
.
parseFunctionBody
(
node
true
)
;
return
this
.
finishNode
(
node
"
ArrowFunctionExpression
"
)
;
}
;
pp
.
parseFunctionBody
=
function
(
node
isArrowFunction
)
{
var
isExpression
=
isArrowFunction
&
&
this
.
type
!
=
=
_tokentype
.
types
.
braceL
;
if
(
isExpression
)
{
node
.
body
=
this
.
parseMaybeAssign
(
)
;
node
.
expression
=
true
;
}
else
{
var
oldInFunc
=
this
.
inFunction
oldInGen
=
this
.
inGenerator
oldLabels
=
this
.
labels
;
this
.
inFunction
=
true
;
this
.
inGenerator
=
node
.
generator
;
this
.
labels
=
[
]
;
node
.
body
=
this
.
parseBlock
(
true
)
;
node
.
expression
=
false
;
this
.
inFunction
=
oldInFunc
;
this
.
inGenerator
=
oldInGen
;
this
.
labels
=
oldLabels
;
}
if
(
this
.
strict
|
|
!
isExpression
&
&
node
.
body
.
body
.
length
&
&
this
.
isUseStrict
(
node
.
body
.
body
[
0
]
)
)
{
var
oldStrict
=
this
.
strict
;
this
.
strict
=
true
;
if
(
node
.
id
)
this
.
checkLVal
(
node
.
id
true
)
;
this
.
checkParams
(
node
)
;
this
.
strict
=
oldStrict
;
}
else
if
(
isArrowFunction
)
{
this
.
checkParams
(
node
)
;
}
}
;
pp
.
checkParams
=
function
(
node
)
{
var
nameHash
=
{
}
;
for
(
var
i
=
0
;
i
<
node
.
params
.
length
;
i
+
+
)
{
this
.
checkLVal
(
node
.
params
[
i
]
true
nameHash
)
;
}
}
;
pp
.
parseExprList
=
function
(
close
allowTrailingComma
allowEmpty
refDestructuringErrors
)
{
var
elts
=
[
]
first
=
true
;
while
(
!
this
.
eat
(
close
)
)
{
if
(
!
first
)
{
this
.
expect
(
_tokentype
.
types
.
comma
)
;
if
(
this
.
type
=
=
=
close
&
&
refDestructuringErrors
&
&
!
refDestructuringErrors
.
trailingComma
)
{
refDestructuringErrors
.
trailingComma
=
this
.
lastTokStart
;
}
if
(
allowTrailingComma
&
&
this
.
afterTrailingComma
(
close
)
)
break
;
}
else
first
=
false
;
var
elt
=
undefined
;
if
(
allowEmpty
&
&
this
.
type
=
=
=
_tokentype
.
types
.
comma
)
elt
=
null
;
else
if
(
this
.
type
=
=
=
_tokentype
.
types
.
ellipsis
)
elt
=
this
.
parseSpread
(
refDestructuringErrors
)
;
else
elt
=
this
.
parseMaybeAssign
(
false
refDestructuringErrors
)
;
elts
.
push
(
elt
)
;
}
return
elts
;
}
;
pp
.
parseIdent
=
function
(
liberal
)
{
var
node
=
this
.
startNode
(
)
;
if
(
liberal
&
&
this
.
options
.
allowReserved
=
=
"
never
"
)
liberal
=
false
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
name
)
{
if
(
!
liberal
&
&
(
this
.
strict
?
this
.
reservedWordsStrict
:
this
.
reservedWords
)
.
test
(
this
.
value
)
&
&
(
this
.
options
.
ecmaVersion
>
=
6
|
|
this
.
input
.
slice
(
this
.
start
this
.
end
)
.
indexOf
(
"
\
\
"
)
=
=
-
1
)
)
this
.
raise
(
this
.
start
"
The
keyword
'
"
+
this
.
value
+
"
'
is
reserved
"
)
;
node
.
name
=
this
.
value
;
}
else
if
(
liberal
&
&
this
.
type
.
keyword
)
{
node
.
name
=
this
.
type
.
keyword
;
}
else
{
this
.
unexpected
(
)
;
}
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
Identifier
"
)
;
}
;
pp
.
parseYield
=
function
(
)
{
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
if
(
this
.
type
=
=
_tokentype
.
types
.
semi
|
|
this
.
canInsertSemicolon
(
)
|
|
this
.
type
!
=
_tokentype
.
types
.
star
&
&
!
this
.
type
.
startsExpr
)
{
node
.
delegate
=
false
;
node
.
argument
=
null
;
}
else
{
node
.
delegate
=
this
.
eat
(
_tokentype
.
types
.
star
)
;
node
.
argument
=
this
.
parseMaybeAssign
(
)
;
}
return
this
.
finishNode
(
node
"
YieldExpression
"
)
;
}
;
pp
.
parseComprehension
=
function
(
node
isGenerator
)
{
node
.
blocks
=
[
]
;
while
(
this
.
type
=
=
=
_tokentype
.
types
.
_for
)
{
var
block
=
this
.
startNode
(
)
;
this
.
next
(
)
;
this
.
expect
(
_tokentype
.
types
.
parenL
)
;
block
.
left
=
this
.
parseBindingAtom
(
)
;
this
.
checkLVal
(
block
.
left
true
)
;
this
.
expectContextual
(
"
of
"
)
;
block
.
right
=
this
.
parseExpression
(
)
;
this
.
expect
(
_tokentype
.
types
.
parenR
)
;
node
.
blocks
.
push
(
this
.
finishNode
(
block
"
ComprehensionBlock
"
)
)
;
}
node
.
filter
=
this
.
eat
(
_tokentype
.
types
.
_if
)
?
this
.
parseParenExpression
(
)
:
null
;
node
.
body
=
this
.
parseExpression
(
)
;
this
.
expect
(
isGenerator
?
_tokentype
.
types
.
parenR
:
_tokentype
.
types
.
bracketR
)
;
node
.
generator
=
isGenerator
;
return
this
.
finishNode
(
node
"
ComprehensionExpression
"
)
;
}
;
}
{
"
.
/
state
"
:
10
"
.
/
tokentype
"
:
14
}
]
2
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
isIdentifierStart
=
isIdentifierStart
;
exports
.
isIdentifierChar
=
isIdentifierChar
;
var
reservedWords
=
{
3
:
"
abstract
boolean
byte
char
class
double
enum
export
extends
final
float
goto
implements
import
int
interface
long
native
package
private
protected
public
short
static
super
synchronized
throws
transient
volatile
"
5
:
"
class
enum
extends
super
const
export
import
"
6
:
"
enum
"
strict
:
"
implements
interface
let
package
private
protected
public
static
yield
"
strictBind
:
"
eval
arguments
"
}
;
exports
.
reservedWords
=
reservedWords
;
var
ecma5AndLessKeywords
=
"
break
case
catch
continue
debugger
default
do
else
finally
for
function
if
return
switch
throw
try
var
while
with
null
true
false
instanceof
typeof
void
delete
new
in
this
"
;
var
keywords
=
{
5
:
ecma5AndLessKeywords
6
:
ecma5AndLessKeywords
+
"
let
const
class
extends
export
import
yield
super
"
}
;
exports
.
keywords
=
keywords
;
var
nonASCIIidentifierStartChars
=
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
;
var
nonASCIIidentifierChars
=
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
;
var
nonASCIIidentifierStart
=
new
RegExp
(
"
[
"
+
nonASCIIidentifierStartChars
+
"
]
"
)
;
var
nonASCIIidentifier
=
new
RegExp
(
"
[
"
+
nonASCIIidentifierStartChars
+
nonASCIIidentifierChars
+
"
]
"
)
;
nonASCIIidentifierStartChars
=
nonASCIIidentifierChars
=
null
;
var
astralIdentifierStartCodes
=
[
0
11
2
25
2
18
2
1
2
14
3
13
35
122
70
52
268
28
4
48
48
31
17
26
6
37
11
29
3
35
5
7
2
4
43
157
99
39
9
51
157
310
10
21
11
7
153
5
3
0
2
43
2
1
4
0
3
22
11
22
10
30
98
21
11
25
71
55
7
1
65
0
16
3
2
2
2
26
45
28
4
28
36
7
2
27
28
53
11
21
11
18
14
17
111
72
955
52
76
44
33
24
27
35
42
34
4
0
13
47
15
3
22
0
38
17
2
24
133
46
39
7
3
1
3
21
2
6
2
1
2
4
4
0
32
4
287
47
21
1
2
0
185
46
82
47
21
0
60
42
502
63
32
0
449
56
1288
920
104
110
2962
1070
13266
568
8
30
114
29
19
47
17
3
32
20
6
18
881
68
12
0
67
12
16481
1
3071
106
6
12
4
8
8
9
5991
84
2
70
2
1
3
0
3
1
3
3
2
11
2
0
2
6
2
64
2
3
3
7
2
6
2
27
2
3
2
4
2
0
4
6
2
339
3
24
2
24
2
30
2
24
2
30
2
24
2
30
2
24
2
30
2
24
2
7
4149
196
1340
3
2
26
2
1
2
0
3
0
2
9
2
3
2
0
2
0
7
0
5
0
2
0
2
0
2
2
2
1
2
0
3
0
2
0
2
0
2
0
2
0
2
1
2
0
3
3
2
6
2
3
2
3
2
0
2
9
2
16
6
2
2
4
2
16
4421
42710
42
4148
12
221
16355
541
]
;
var
astralIdentifierCodes
=
[
509
0
227
0
150
4
294
9
1368
2
2
1
6
3
41
2
5
0
166
1
1306
2
54
14
32
9
16
3
46
10
54
9
7
2
37
13
2
9
52
0
13
2
49
13
16
9
83
11
168
11
6
9
8
2
57
0
2
6
3
1
3
2
10
0
11
1
3
6
4
4
316
19
13
9
214
6
3
8
112
16
16
9
82
12
9
9
535
9
20855
9
135
4
60
6
26
9
1016
45
17
3
19723
1
5319
4
4
5
9
7
3
6
31
3
149
2
1418
49
4305
6
792618
239
]
;
function
isInAstralSet
(
code
set
)
{
var
pos
=
0x10000
;
for
(
var
i
=
0
;
i
<
set
.
length
;
i
+
=
2
)
{
pos
+
=
set
[
i
]
;
if
(
pos
>
code
)
return
false
;
pos
+
=
set
[
i
+
1
]
;
if
(
pos
>
=
code
)
return
true
;
}
}
function
isIdentifierStart
(
code
astral
)
{
if
(
code
<
65
)
return
code
=
=
=
36
;
if
(
code
<
91
)
return
true
;
if
(
code
<
97
)
return
code
=
=
=
95
;
if
(
code
<
123
)
return
true
;
if
(
code
<
=
0xffff
)
return
code
>
=
0xaa
&
&
nonASCIIidentifierStart
.
test
(
String
.
fromCharCode
(
code
)
)
;
if
(
astral
=
=
=
false
)
return
false
;
return
isInAstralSet
(
code
astralIdentifierStartCodes
)
;
}
function
isIdentifierChar
(
code
astral
)
{
if
(
code
<
48
)
return
code
=
=
=
36
;
if
(
code
<
58
)
return
true
;
if
(
code
<
65
)
return
false
;
if
(
code
<
91
)
return
true
;
if
(
code
<
97
)
return
code
=
=
=
95
;
if
(
code
<
123
)
return
true
;
if
(
code
<
=
0xffff
)
return
code
>
=
0xaa
&
&
nonASCIIidentifier
.
test
(
String
.
fromCharCode
(
code
)
)
;
if
(
astral
=
=
=
false
)
return
false
;
return
isInAstralSet
(
code
astralIdentifierStartCodes
)
|
|
isInAstralSet
(
code
astralIdentifierCodes
)
;
}
}
{
}
]
3
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
parse
=
parse
;
exports
.
parseExpressionAt
=
parseExpressionAt
;
exports
.
tokenizer
=
tokenizer
;
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
_dereq_
(
"
.
/
parseutil
"
)
;
_dereq_
(
"
.
/
statement
"
)
;
_dereq_
(
"
.
/
lval
"
)
;
_dereq_
(
"
.
/
expression
"
)
;
_dereq_
(
"
.
/
location
"
)
;
exports
.
Parser
=
_state
.
Parser
;
exports
.
plugins
=
_state
.
plugins
;
var
_options
=
_dereq_
(
"
.
/
options
"
)
;
exports
.
defaultOptions
=
_options
.
defaultOptions
;
var
_locutil
=
_dereq_
(
"
.
/
locutil
"
)
;
exports
.
Position
=
_locutil
.
Position
;
exports
.
SourceLocation
=
_locutil
.
SourceLocation
;
exports
.
getLineInfo
=
_locutil
.
getLineInfo
;
var
_node
=
_dereq_
(
"
.
/
node
"
)
;
exports
.
Node
=
_node
.
Node
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
exports
.
TokenType
=
_tokentype
.
TokenType
;
exports
.
tokTypes
=
_tokentype
.
types
;
var
_tokencontext
=
_dereq_
(
"
.
/
tokencontext
"
)
;
exports
.
TokContext
=
_tokencontext
.
TokContext
;
exports
.
tokContexts
=
_tokencontext
.
types
;
var
_identifier
=
_dereq_
(
"
.
/
identifier
"
)
;
exports
.
isIdentifierChar
=
_identifier
.
isIdentifierChar
;
exports
.
isIdentifierStart
=
_identifier
.
isIdentifierStart
;
var
_tokenize
=
_dereq_
(
"
.
/
tokenize
"
)
;
exports
.
Token
=
_tokenize
.
Token
;
var
_whitespace
=
_dereq_
(
"
.
/
whitespace
"
)
;
exports
.
isNewLine
=
_whitespace
.
isNewLine
;
exports
.
lineBreak
=
_whitespace
.
lineBreak
;
exports
.
lineBreakG
=
_whitespace
.
lineBreakG
;
var
version
=
"
2
.
6
.
4
"
;
exports
.
version
=
version
;
function
parse
(
input
options
)
{
return
new
_state
.
Parser
(
options
input
)
.
parse
(
)
;
}
function
parseExpressionAt
(
input
pos
options
)
{
var
p
=
new
_state
.
Parser
(
options
input
pos
)
;
p
.
nextToken
(
)
;
return
p
.
parseExpression
(
)
;
}
function
tokenizer
(
input
options
)
{
return
new
_state
.
Parser
(
options
input
)
;
}
}
{
"
.
/
expression
"
:
1
"
.
/
identifier
"
:
2
"
.
/
location
"
:
4
"
.
/
locutil
"
:
5
"
.
/
lval
"
:
6
"
.
/
node
"
:
7
"
.
/
options
"
:
8
"
.
/
parseutil
"
:
9
"
.
/
state
"
:
10
"
.
/
statement
"
:
11
"
.
/
tokencontext
"
:
12
"
.
/
tokenize
"
:
13
"
.
/
tokentype
"
:
14
"
.
/
whitespace
"
:
16
}
]
4
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
_locutil
=
_dereq_
(
"
.
/
locutil
"
)
;
var
pp
=
_state
.
Parser
.
prototype
;
pp
.
raise
=
function
(
pos
message
)
{
var
loc
=
_locutil
.
getLineInfo
(
this
.
input
pos
)
;
message
+
=
"
(
"
+
loc
.
line
+
"
:
"
+
loc
.
column
+
"
)
"
;
var
err
=
new
SyntaxError
(
message
)
;
err
.
pos
=
pos
;
err
.
loc
=
loc
;
err
.
raisedAt
=
this
.
pos
;
throw
err
;
}
;
pp
.
curPosition
=
function
(
)
{
if
(
this
.
options
.
locations
)
{
return
new
_locutil
.
Position
(
this
.
curLine
this
.
pos
-
this
.
lineStart
)
;
}
}
;
}
{
"
.
/
locutil
"
:
5
"
.
/
state
"
:
10
}
]
5
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
getLineInfo
=
getLineInfo
;
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
_whitespace
=
_dereq_
(
"
.
/
whitespace
"
)
;
var
Position
=
(
function
(
)
{
function
Position
(
line
col
)
{
_classCallCheck
(
this
Position
)
;
this
.
line
=
line
;
this
.
column
=
col
;
}
Position
.
prototype
.
offset
=
function
offset
(
n
)
{
return
new
Position
(
this
.
line
this
.
column
+
n
)
;
}
;
return
Position
;
}
)
(
)
;
exports
.
Position
=
Position
;
var
SourceLocation
=
function
SourceLocation
(
p
start
end
)
{
_classCallCheck
(
this
SourceLocation
)
;
this
.
start
=
start
;
this
.
end
=
end
;
if
(
p
.
sourceFile
!
=
=
null
)
this
.
source
=
p
.
sourceFile
;
}
;
exports
.
SourceLocation
=
SourceLocation
;
function
getLineInfo
(
input
offset
)
{
for
(
var
line
=
1
cur
=
0
;
;
)
{
_whitespace
.
lineBreakG
.
lastIndex
=
cur
;
var
match
=
_whitespace
.
lineBreakG
.
exec
(
input
)
;
if
(
match
&
&
match
.
index
<
offset
)
{
+
+
line
;
cur
=
match
.
index
+
match
[
0
]
.
length
;
}
else
{
return
new
Position
(
line
offset
-
cur
)
;
}
}
}
}
{
"
.
/
whitespace
"
:
16
}
]
6
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
_util
=
_dereq_
(
"
.
/
util
"
)
;
var
pp
=
_state
.
Parser
.
prototype
;
pp
.
toAssignable
=
function
(
node
isBinding
)
{
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
node
)
{
switch
(
node
.
type
)
{
case
"
Identifier
"
:
case
"
ObjectPattern
"
:
case
"
ArrayPattern
"
:
break
;
case
"
ObjectExpression
"
:
node
.
type
=
"
ObjectPattern
"
;
for
(
var
i
=
0
;
i
<
node
.
properties
.
length
;
i
+
+
)
{
var
prop
=
node
.
properties
[
i
]
;
if
(
prop
.
kind
!
=
=
"
init
"
)
this
.
raise
(
prop
.
key
.
start
"
Object
pattern
can
'
t
contain
getter
or
setter
"
)
;
this
.
toAssignable
(
prop
.
value
isBinding
)
;
}
break
;
case
"
ArrayExpression
"
:
node
.
type
=
"
ArrayPattern
"
;
this
.
toAssignableList
(
node
.
elements
isBinding
)
;
break
;
case
"
AssignmentExpression
"
:
if
(
node
.
operator
=
=
=
"
=
"
)
{
node
.
type
=
"
AssignmentPattern
"
;
delete
node
.
operator
;
}
else
{
this
.
raise
(
node
.
left
.
end
"
Only
'
=
'
operator
can
be
used
for
specifying
default
value
.
"
)
;
break
;
}
case
"
AssignmentPattern
"
:
if
(
node
.
right
.
type
=
=
=
"
YieldExpression
"
)
this
.
raise
(
node
.
right
.
start
"
Yield
expression
cannot
be
a
default
value
"
)
;
break
;
case
"
ParenthesizedExpression
"
:
node
.
expression
=
this
.
toAssignable
(
node
.
expression
isBinding
)
;
break
;
case
"
MemberExpression
"
:
if
(
!
isBinding
)
break
;
default
:
this
.
raise
(
node
.
start
"
Assigning
to
rvalue
"
)
;
}
}
return
node
;
}
;
pp
.
toAssignableList
=
function
(
exprList
isBinding
)
{
var
end
=
exprList
.
length
;
if
(
end
)
{
var
last
=
exprList
[
end
-
1
]
;
if
(
last
&
&
last
.
type
=
=
"
RestElement
"
)
{
-
-
end
;
}
else
if
(
last
&
&
last
.
type
=
=
"
SpreadElement
"
)
{
last
.
type
=
"
RestElement
"
;
var
arg
=
last
.
argument
;
this
.
toAssignable
(
arg
isBinding
)
;
if
(
arg
.
type
!
=
=
"
Identifier
"
&
&
arg
.
type
!
=
=
"
MemberExpression
"
&
&
arg
.
type
!
=
=
"
ArrayPattern
"
)
this
.
unexpected
(
arg
.
start
)
;
-
-
end
;
}
if
(
isBinding
&
&
last
.
type
=
=
=
"
RestElement
"
&
&
last
.
argument
.
type
!
=
=
"
Identifier
"
)
this
.
unexpected
(
last
.
argument
.
start
)
;
}
for
(
var
i
=
0
;
i
<
end
;
i
+
+
)
{
var
elt
=
exprList
[
i
]
;
if
(
elt
)
this
.
toAssignable
(
elt
isBinding
)
;
}
return
exprList
;
}
;
pp
.
parseSpread
=
function
(
refDestructuringErrors
)
{
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
argument
=
this
.
parseMaybeAssign
(
refDestructuringErrors
)
;
return
this
.
finishNode
(
node
"
SpreadElement
"
)
;
}
;
pp
.
parseRest
=
function
(
allowNonIdent
)
{
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
if
(
allowNonIdent
)
node
.
argument
=
this
.
type
=
=
=
_tokentype
.
types
.
name
?
this
.
parseIdent
(
)
:
this
.
unexpected
(
)
;
else
node
.
argument
=
this
.
type
=
=
=
_tokentype
.
types
.
name
|
|
this
.
type
=
=
=
_tokentype
.
types
.
bracketL
?
this
.
parseBindingAtom
(
)
:
this
.
unexpected
(
)
;
return
this
.
finishNode
(
node
"
RestElement
"
)
;
}
;
pp
.
parseBindingAtom
=
function
(
)
{
if
(
this
.
options
.
ecmaVersion
<
6
)
return
this
.
parseIdent
(
)
;
switch
(
this
.
type
)
{
case
_tokentype
.
types
.
name
:
return
this
.
parseIdent
(
)
;
case
_tokentype
.
types
.
bracketL
:
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
node
.
elements
=
this
.
parseBindingList
(
_tokentype
.
types
.
bracketR
true
true
)
;
return
this
.
finishNode
(
node
"
ArrayPattern
"
)
;
case
_tokentype
.
types
.
braceL
:
return
this
.
parseObj
(
true
)
;
default
:
this
.
unexpected
(
)
;
}
}
;
pp
.
parseBindingList
=
function
(
close
allowEmpty
allowTrailingComma
allowNonIdent
)
{
var
elts
=
[
]
first
=
true
;
while
(
!
this
.
eat
(
close
)
)
{
if
(
first
)
first
=
false
;
else
this
.
expect
(
_tokentype
.
types
.
comma
)
;
if
(
allowEmpty
&
&
this
.
type
=
=
=
_tokentype
.
types
.
comma
)
{
elts
.
push
(
null
)
;
}
else
if
(
allowTrailingComma
&
&
this
.
afterTrailingComma
(
close
)
)
{
break
;
}
else
if
(
this
.
type
=
=
=
_tokentype
.
types
.
ellipsis
)
{
var
rest
=
this
.
parseRest
(
allowNonIdent
)
;
this
.
parseBindingListItem
(
rest
)
;
elts
.
push
(
rest
)
;
this
.
expect
(
close
)
;
break
;
}
else
{
var
elem
=
this
.
parseMaybeDefault
(
this
.
start
this
.
startLoc
)
;
this
.
parseBindingListItem
(
elem
)
;
elts
.
push
(
elem
)
;
}
}
return
elts
;
}
;
pp
.
parseBindingListItem
=
function
(
param
)
{
return
param
;
}
;
pp
.
parseMaybeDefault
=
function
(
startPos
startLoc
left
)
{
left
=
left
|
|
this
.
parseBindingAtom
(
)
;
if
(
this
.
options
.
ecmaVersion
<
6
|
|
!
this
.
eat
(
_tokentype
.
types
.
eq
)
)
return
left
;
var
node
=
this
.
startNodeAt
(
startPos
startLoc
)
;
node
.
left
=
left
;
node
.
right
=
this
.
parseMaybeAssign
(
)
;
return
this
.
finishNode
(
node
"
AssignmentPattern
"
)
;
}
;
pp
.
checkLVal
=
function
(
expr
isBinding
checkClashes
)
{
switch
(
expr
.
type
)
{
case
"
Identifier
"
:
if
(
this
.
strict
&
&
this
.
reservedWordsStrictBind
.
test
(
expr
.
name
)
)
this
.
raise
(
expr
.
start
(
isBinding
?
"
Binding
"
:
"
Assigning
to
"
)
+
expr
.
name
+
"
in
strict
mode
"
)
;
if
(
checkClashes
)
{
if
(
_util
.
has
(
checkClashes
expr
.
name
)
)
this
.
raise
(
expr
.
start
"
Argument
name
clash
"
)
;
checkClashes
[
expr
.
name
]
=
true
;
}
break
;
case
"
MemberExpression
"
:
if
(
isBinding
)
this
.
raise
(
expr
.
start
(
isBinding
?
"
Binding
"
:
"
Assigning
to
"
)
+
"
member
expression
"
)
;
break
;
case
"
ObjectPattern
"
:
for
(
var
i
=
0
;
i
<
expr
.
properties
.
length
;
i
+
+
)
{
this
.
checkLVal
(
expr
.
properties
[
i
]
.
value
isBinding
checkClashes
)
;
}
break
;
case
"
ArrayPattern
"
:
for
(
var
i
=
0
;
i
<
expr
.
elements
.
length
;
i
+
+
)
{
var
elem
=
expr
.
elements
[
i
]
;
if
(
elem
)
this
.
checkLVal
(
elem
isBinding
checkClashes
)
;
}
break
;
case
"
AssignmentPattern
"
:
this
.
checkLVal
(
expr
.
left
isBinding
checkClashes
)
;
break
;
case
"
RestElement
"
:
this
.
checkLVal
(
expr
.
argument
isBinding
checkClashes
)
;
break
;
case
"
ParenthesizedExpression
"
:
this
.
checkLVal
(
expr
.
expression
isBinding
checkClashes
)
;
break
;
default
:
this
.
raise
(
expr
.
start
(
isBinding
?
"
Binding
"
:
"
Assigning
to
"
)
+
"
rvalue
"
)
;
}
}
;
}
{
"
.
/
state
"
:
10
"
.
/
tokentype
"
:
14
"
.
/
util
"
:
15
}
]
7
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
_locutil
=
_dereq_
(
"
.
/
locutil
"
)
;
var
Node
=
function
Node
(
parser
pos
loc
)
{
_classCallCheck
(
this
Node
)
;
this
.
type
=
"
"
;
this
.
start
=
pos
;
this
.
end
=
0
;
if
(
parser
.
options
.
locations
)
this
.
loc
=
new
_locutil
.
SourceLocation
(
parser
loc
)
;
if
(
parser
.
options
.
directSourceFile
)
this
.
sourceFile
=
parser
.
options
.
directSourceFile
;
if
(
parser
.
options
.
ranges
)
this
.
range
=
[
pos
0
]
;
}
;
exports
.
Node
=
Node
;
var
pp
=
_state
.
Parser
.
prototype
;
pp
.
startNode
=
function
(
)
{
return
new
Node
(
this
this
.
start
this
.
startLoc
)
;
}
;
pp
.
startNodeAt
=
function
(
pos
loc
)
{
return
new
Node
(
this
pos
loc
)
;
}
;
function
finishNodeAt
(
node
type
pos
loc
)
{
node
.
type
=
type
;
node
.
end
=
pos
;
if
(
this
.
options
.
locations
)
node
.
loc
.
end
=
loc
;
if
(
this
.
options
.
ranges
)
node
.
range
[
1
]
=
pos
;
return
node
;
}
pp
.
finishNode
=
function
(
node
type
)
{
return
finishNodeAt
.
call
(
this
node
type
this
.
lastTokEnd
this
.
lastTokEndLoc
)
;
}
;
pp
.
finishNodeAt
=
function
(
node
type
pos
loc
)
{
return
finishNodeAt
.
call
(
this
node
type
pos
loc
)
;
}
;
}
{
"
.
/
locutil
"
:
5
"
.
/
state
"
:
10
}
]
8
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
getOptions
=
getOptions
;
var
_util
=
_dereq_
(
"
.
/
util
"
)
;
var
_locutil
=
_dereq_
(
"
.
/
locutil
"
)
;
var
defaultOptions
=
{
ecmaVersion
:
5
sourceType
:
"
script
"
onInsertedSemicolon
:
null
onTrailingComma
:
null
allowReserved
:
null
allowReturnOutsideFunction
:
false
allowImportExportEverywhere
:
false
allowHashBang
:
false
locations
:
false
onToken
:
null
onComment
:
null
ranges
:
false
program
:
null
sourceFile
:
null
directSourceFile
:
null
preserveParens
:
false
plugins
:
{
}
}
;
exports
.
defaultOptions
=
defaultOptions
;
function
getOptions
(
opts
)
{
var
options
=
{
}
;
for
(
var
opt
in
defaultOptions
)
{
options
[
opt
]
=
opts
&
&
_util
.
has
(
opts
opt
)
?
opts
[
opt
]
:
defaultOptions
[
opt
]
;
}
if
(
options
.
allowReserved
=
=
null
)
options
.
allowReserved
=
options
.
ecmaVersion
<
5
;
if
(
_util
.
isArray
(
options
.
onToken
)
)
{
(
function
(
)
{
var
tokens
=
options
.
onToken
;
options
.
onToken
=
function
(
token
)
{
return
tokens
.
push
(
token
)
;
}
;
}
)
(
)
;
}
if
(
_util
.
isArray
(
options
.
onComment
)
)
options
.
onComment
=
pushComment
(
options
options
.
onComment
)
;
return
options
;
}
function
pushComment
(
options
array
)
{
return
function
(
block
text
start
end
startLoc
endLoc
)
{
var
comment
=
{
type
:
block
?
'
Block
'
:
'
Line
'
value
:
text
start
:
start
end
:
end
}
;
if
(
options
.
locations
)
comment
.
loc
=
new
_locutil
.
SourceLocation
(
this
startLoc
endLoc
)
;
if
(
options
.
ranges
)
comment
.
range
=
[
start
end
]
;
array
.
push
(
comment
)
;
}
;
}
}
{
"
.
/
locutil
"
:
5
"
.
/
util
"
:
15
}
]
9
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
_whitespace
=
_dereq_
(
"
.
/
whitespace
"
)
;
var
pp
=
_state
.
Parser
.
prototype
;
pp
.
isUseStrict
=
function
(
stmt
)
{
return
this
.
options
.
ecmaVersion
>
=
5
&
&
stmt
.
type
=
=
=
"
ExpressionStatement
"
&
&
stmt
.
expression
.
type
=
=
=
"
Literal
"
&
&
stmt
.
expression
.
raw
.
slice
(
1
-
1
)
=
=
=
"
use
strict
"
;
}
;
pp
.
eat
=
function
(
type
)
{
if
(
this
.
type
=
=
=
type
)
{
this
.
next
(
)
;
return
true
;
}
else
{
return
false
;
}
}
;
pp
.
isContextual
=
function
(
name
)
{
return
this
.
type
=
=
=
_tokentype
.
types
.
name
&
&
this
.
value
=
=
=
name
;
}
;
pp
.
eatContextual
=
function
(
name
)
{
return
this
.
value
=
=
=
name
&
&
this
.
eat
(
_tokentype
.
types
.
name
)
;
}
;
pp
.
expectContextual
=
function
(
name
)
{
if
(
!
this
.
eatContextual
(
name
)
)
this
.
unexpected
(
)
;
}
;
pp
.
canInsertSemicolon
=
function
(
)
{
return
this
.
type
=
=
=
_tokentype
.
types
.
eof
|
|
this
.
type
=
=
=
_tokentype
.
types
.
braceR
|
|
_whitespace
.
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
start
)
)
;
}
;
pp
.
insertSemicolon
=
function
(
)
{
if
(
this
.
canInsertSemicolon
(
)
)
{
if
(
this
.
options
.
onInsertedSemicolon
)
this
.
options
.
onInsertedSemicolon
(
this
.
lastTokEnd
this
.
lastTokEndLoc
)
;
return
true
;
}
}
;
pp
.
semicolon
=
function
(
)
{
if
(
!
this
.
eat
(
_tokentype
.
types
.
semi
)
&
&
!
this
.
insertSemicolon
(
)
)
this
.
unexpected
(
)
;
}
;
pp
.
afterTrailingComma
=
function
(
tokType
)
{
if
(
this
.
type
=
=
tokType
)
{
if
(
this
.
options
.
onTrailingComma
)
this
.
options
.
onTrailingComma
(
this
.
lastTokStart
this
.
lastTokStartLoc
)
;
this
.
next
(
)
;
return
true
;
}
}
;
pp
.
expect
=
function
(
type
)
{
this
.
eat
(
type
)
|
|
this
.
unexpected
(
)
;
}
;
pp
.
unexpected
=
function
(
pos
)
{
this
.
raise
(
pos
!
=
null
?
pos
:
this
.
start
"
Unexpected
token
"
)
;
}
;
pp
.
checkPatternErrors
=
function
(
refDestructuringErrors
andThrow
)
{
var
pos
=
refDestructuringErrors
&
&
refDestructuringErrors
.
trailingComma
;
if
(
!
andThrow
)
return
!
!
pos
;
if
(
pos
)
this
.
raise
(
pos
"
Trailing
comma
is
not
permitted
in
destructuring
patterns
"
)
;
}
;
pp
.
checkExpressionErrors
=
function
(
refDestructuringErrors
andThrow
)
{
var
pos
=
refDestructuringErrors
&
&
refDestructuringErrors
.
shorthandAssign
;
if
(
!
andThrow
)
return
!
!
pos
;
if
(
pos
)
this
.
raise
(
pos
"
Shorthand
property
assignments
are
valid
only
in
destructuring
patterns
"
)
;
}
;
}
{
"
.
/
state
"
:
10
"
.
/
tokentype
"
:
14
"
.
/
whitespace
"
:
16
}
]
10
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
_identifier
=
_dereq_
(
"
.
/
identifier
"
)
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
var
_whitespace
=
_dereq_
(
"
.
/
whitespace
"
)
;
var
_options
=
_dereq_
(
"
.
/
options
"
)
;
var
plugins
=
{
}
;
exports
.
plugins
=
plugins
;
function
keywordRegexp
(
words
)
{
return
new
RegExp
(
"
^
(
"
+
words
.
replace
(
/
/
g
"
|
"
)
+
"
)
"
)
;
}
var
Parser
=
(
function
(
)
{
function
Parser
(
options
input
startPos
)
{
_classCallCheck
(
this
Parser
)
;
this
.
options
=
options
=
_options
.
getOptions
(
options
)
;
this
.
sourceFile
=
options
.
sourceFile
;
this
.
keywords
=
keywordRegexp
(
_identifier
.
keywords
[
options
.
ecmaVersion
>
=
6
?
6
:
5
]
)
;
var
reserved
=
options
.
allowReserved
?
"
"
:
_identifier
.
reservedWords
[
options
.
ecmaVersion
]
+
(
options
.
sourceType
=
=
"
module
"
?
"
await
"
:
"
"
)
;
this
.
reservedWords
=
keywordRegexp
(
reserved
)
;
var
reservedStrict
=
(
reserved
?
reserved
+
"
"
:
"
"
)
+
_identifier
.
reservedWords
.
strict
;
this
.
reservedWordsStrict
=
keywordRegexp
(
reservedStrict
)
;
this
.
reservedWordsStrictBind
=
keywordRegexp
(
reservedStrict
+
"
"
+
_identifier
.
reservedWords
.
strictBind
)
;
this
.
input
=
String
(
input
)
;
this
.
containsEsc
=
false
;
this
.
loadPlugins
(
options
.
plugins
)
;
if
(
startPos
)
{
this
.
pos
=
startPos
;
this
.
lineStart
=
Math
.
max
(
0
this
.
input
.
lastIndexOf
(
"
\
n
"
startPos
)
)
;
this
.
curLine
=
this
.
input
.
slice
(
0
this
.
lineStart
)
.
split
(
_whitespace
.
lineBreak
)
.
length
;
}
else
{
this
.
pos
=
this
.
lineStart
=
0
;
this
.
curLine
=
1
;
}
this
.
type
=
_tokentype
.
types
.
eof
;
this
.
value
=
null
;
this
.
start
=
this
.
end
=
this
.
pos
;
this
.
startLoc
=
this
.
endLoc
=
this
.
curPosition
(
)
;
this
.
lastTokEndLoc
=
this
.
lastTokStartLoc
=
null
;
this
.
lastTokStart
=
this
.
lastTokEnd
=
this
.
pos
;
this
.
context
=
this
.
initialContext
(
)
;
this
.
exprAllowed
=
true
;
this
.
strict
=
this
.
inModule
=
options
.
sourceType
=
=
=
"
module
"
;
this
.
potentialArrowAt
=
-
1
;
this
.
inFunction
=
this
.
inGenerator
=
false
;
this
.
labels
=
[
]
;
if
(
this
.
pos
=
=
=
0
&
&
options
.
allowHashBang
&
&
this
.
input
.
slice
(
0
2
)
=
=
=
'
#
!
'
)
this
.
skipLineComment
(
2
)
;
}
Parser
.
prototype
.
isKeyword
=
function
isKeyword
(
word
)
{
return
this
.
keywords
.
test
(
word
)
;
}
;
Parser
.
prototype
.
isReservedWord
=
function
isReservedWord
(
word
)
{
return
this
.
reservedWords
.
test
(
word
)
;
}
;
Parser
.
prototype
.
extend
=
function
extend
(
name
f
)
{
this
[
name
]
=
f
(
this
[
name
]
)
;
}
;
Parser
.
prototype
.
loadPlugins
=
function
loadPlugins
(
pluginConfigs
)
{
for
(
var
_name
in
pluginConfigs
)
{
var
plugin
=
plugins
[
_name
]
;
if
(
!
plugin
)
throw
new
Error
(
"
Plugin
'
"
+
_name
+
"
'
not
found
"
)
;
plugin
(
this
pluginConfigs
[
_name
]
)
;
}
}
;
Parser
.
prototype
.
parse
=
function
parse
(
)
{
var
node
=
this
.
options
.
program
|
|
this
.
startNode
(
)
;
this
.
nextToken
(
)
;
return
this
.
parseTopLevel
(
node
)
;
}
;
return
Parser
;
}
)
(
)
;
exports
.
Parser
=
Parser
;
}
{
"
.
/
identifier
"
:
2
"
.
/
options
"
:
8
"
.
/
tokentype
"
:
14
"
.
/
whitespace
"
:
16
}
]
11
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
_whitespace
=
_dereq_
(
"
.
/
whitespace
"
)
;
var
pp
=
_state
.
Parser
.
prototype
;
pp
.
parseTopLevel
=
function
(
node
)
{
var
first
=
true
;
if
(
!
node
.
body
)
node
.
body
=
[
]
;
while
(
this
.
type
!
=
=
_tokentype
.
types
.
eof
)
{
var
stmt
=
this
.
parseStatement
(
true
true
)
;
node
.
body
.
push
(
stmt
)
;
if
(
first
)
{
if
(
this
.
isUseStrict
(
stmt
)
)
this
.
setStrict
(
true
)
;
first
=
false
;
}
}
this
.
next
(
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
node
.
sourceType
=
this
.
options
.
sourceType
;
}
return
this
.
finishNode
(
node
"
Program
"
)
;
}
;
var
loopLabel
=
{
kind
:
"
loop
"
}
switchLabel
=
{
kind
:
"
switch
"
}
;
pp
.
parseStatement
=
function
(
declaration
topLevel
)
{
var
starttype
=
this
.
type
node
=
this
.
startNode
(
)
;
switch
(
starttype
)
{
case
_tokentype
.
types
.
_break
:
case
_tokentype
.
types
.
_continue
:
return
this
.
parseBreakContinueStatement
(
node
starttype
.
keyword
)
;
case
_tokentype
.
types
.
_debugger
:
return
this
.
parseDebuggerStatement
(
node
)
;
case
_tokentype
.
types
.
_do
:
return
this
.
parseDoStatement
(
node
)
;
case
_tokentype
.
types
.
_for
:
return
this
.
parseForStatement
(
node
)
;
case
_tokentype
.
types
.
_function
:
if
(
!
declaration
&
&
this
.
options
.
ecmaVersion
>
=
6
)
this
.
unexpected
(
)
;
return
this
.
parseFunctionStatement
(
node
)
;
case
_tokentype
.
types
.
_class
:
if
(
!
declaration
)
this
.
unexpected
(
)
;
return
this
.
parseClass
(
node
true
)
;
case
_tokentype
.
types
.
_if
:
return
this
.
parseIfStatement
(
node
)
;
case
_tokentype
.
types
.
_return
:
return
this
.
parseReturnStatement
(
node
)
;
case
_tokentype
.
types
.
_switch
:
return
this
.
parseSwitchStatement
(
node
)
;
case
_tokentype
.
types
.
_throw
:
return
this
.
parseThrowStatement
(
node
)
;
case
_tokentype
.
types
.
_try
:
return
this
.
parseTryStatement
(
node
)
;
case
_tokentype
.
types
.
_let
:
case
_tokentype
.
types
.
_const
:
if
(
!
declaration
)
this
.
unexpected
(
)
;
case
_tokentype
.
types
.
_var
:
return
this
.
parseVarStatement
(
node
starttype
)
;
case
_tokentype
.
types
.
_while
:
return
this
.
parseWhileStatement
(
node
)
;
case
_tokentype
.
types
.
_with
:
return
this
.
parseWithStatement
(
node
)
;
case
_tokentype
.
types
.
braceL
:
return
this
.
parseBlock
(
)
;
case
_tokentype
.
types
.
semi
:
return
this
.
parseEmptyStatement
(
node
)
;
case
_tokentype
.
types
.
_export
:
case
_tokentype
.
types
.
_import
:
if
(
!
this
.
options
.
allowImportExportEverywhere
)
{
if
(
!
topLevel
)
this
.
raise
(
this
.
start
"
'
import
'
and
'
export
'
may
only
appear
at
the
top
level
"
)
;
if
(
!
this
.
inModule
)
this
.
raise
(
this
.
start
"
'
import
'
and
'
export
'
may
appear
only
with
'
sourceType
:
module
'
"
)
;
}
return
starttype
=
=
=
_tokentype
.
types
.
_import
?
this
.
parseImport
(
node
)
:
this
.
parseExport
(
node
)
;
default
:
var
maybeName
=
this
.
value
expr
=
this
.
parseExpression
(
)
;
if
(
starttype
=
=
=
_tokentype
.
types
.
name
&
&
expr
.
type
=
=
=
"
Identifier
"
&
&
this
.
eat
(
_tokentype
.
types
.
colon
)
)
return
this
.
parseLabeledStatement
(
node
maybeName
expr
)
;
else
return
this
.
parseExpressionStatement
(
node
expr
)
;
}
}
;
pp
.
parseBreakContinueStatement
=
function
(
node
keyword
)
{
var
isBreak
=
keyword
=
=
"
break
"
;
this
.
next
(
)
;
if
(
this
.
eat
(
_tokentype
.
types
.
semi
)
|
|
this
.
insertSemicolon
(
)
)
node
.
label
=
null
;
else
if
(
this
.
type
!
=
=
_tokentype
.
types
.
name
)
this
.
unexpected
(
)
;
else
{
node
.
label
=
this
.
parseIdent
(
)
;
this
.
semicolon
(
)
;
}
for
(
var
i
=
0
;
i
<
this
.
labels
.
length
;
+
+
i
)
{
var
lab
=
this
.
labels
[
i
]
;
if
(
node
.
label
=
=
null
|
|
lab
.
name
=
=
=
node
.
label
.
name
)
{
if
(
lab
.
kind
!
=
null
&
&
(
isBreak
|
|
lab
.
kind
=
=
=
"
loop
"
)
)
break
;
if
(
node
.
label
&
&
isBreak
)
break
;
}
}
if
(
i
=
=
=
this
.
labels
.
length
)
this
.
raise
(
node
.
start
"
Unsyntactic
"
+
keyword
)
;
return
this
.
finishNode
(
node
isBreak
?
"
BreakStatement
"
:
"
ContinueStatement
"
)
;
}
;
pp
.
parseDebuggerStatement
=
function
(
node
)
{
this
.
next
(
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
DebuggerStatement
"
)
;
}
;
pp
.
parseDoStatement
=
function
(
node
)
{
this
.
next
(
)
;
this
.
labels
.
push
(
loopLabel
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
this
.
expect
(
_tokentype
.
types
.
_while
)
;
node
.
test
=
this
.
parseParenExpression
(
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
this
.
eat
(
_tokentype
.
types
.
semi
)
;
else
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
DoWhileStatement
"
)
;
}
;
pp
.
parseForStatement
=
function
(
node
)
{
this
.
next
(
)
;
this
.
labels
.
push
(
loopLabel
)
;
this
.
expect
(
_tokentype
.
types
.
parenL
)
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
semi
)
return
this
.
parseFor
(
node
null
)
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
_var
|
|
this
.
type
=
=
=
_tokentype
.
types
.
_let
|
|
this
.
type
=
=
=
_tokentype
.
types
.
_const
)
{
var
_init
=
this
.
startNode
(
)
varKind
=
this
.
type
;
this
.
next
(
)
;
this
.
parseVar
(
_init
true
varKind
)
;
this
.
finishNode
(
_init
"
VariableDeclaration
"
)
;
if
(
(
this
.
type
=
=
=
_tokentype
.
types
.
_in
|
|
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
isContextual
(
"
of
"
)
)
&
&
_init
.
declarations
.
length
=
=
=
1
&
&
!
(
varKind
!
=
=
_tokentype
.
types
.
_var
&
&
_init
.
declarations
[
0
]
.
init
)
)
return
this
.
parseForIn
(
node
_init
)
;
return
this
.
parseFor
(
node
_init
)
;
}
var
refDestructuringErrors
=
{
shorthandAssign
:
0
trailingComma
:
0
}
;
var
init
=
this
.
parseExpression
(
true
refDestructuringErrors
)
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
_in
|
|
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
isContextual
(
"
of
"
)
)
{
this
.
checkPatternErrors
(
refDestructuringErrors
true
)
;
this
.
toAssignable
(
init
)
;
this
.
checkLVal
(
init
)
;
return
this
.
parseForIn
(
node
init
)
;
}
else
{
this
.
checkExpressionErrors
(
refDestructuringErrors
true
)
;
}
return
this
.
parseFor
(
node
init
)
;
}
;
pp
.
parseFunctionStatement
=
function
(
node
)
{
this
.
next
(
)
;
return
this
.
parseFunction
(
node
true
)
;
}
;
pp
.
parseIfStatement
=
function
(
node
)
{
this
.
next
(
)
;
node
.
test
=
this
.
parseParenExpression
(
)
;
node
.
consequent
=
this
.
parseStatement
(
false
)
;
node
.
alternate
=
this
.
eat
(
_tokentype
.
types
.
_else
)
?
this
.
parseStatement
(
false
)
:
null
;
return
this
.
finishNode
(
node
"
IfStatement
"
)
;
}
;
pp
.
parseReturnStatement
=
function
(
node
)
{
if
(
!
this
.
inFunction
&
&
!
this
.
options
.
allowReturnOutsideFunction
)
this
.
raise
(
this
.
start
"
'
return
'
outside
of
function
"
)
;
this
.
next
(
)
;
if
(
this
.
eat
(
_tokentype
.
types
.
semi
)
|
|
this
.
insertSemicolon
(
)
)
node
.
argument
=
null
;
else
{
node
.
argument
=
this
.
parseExpression
(
)
;
this
.
semicolon
(
)
;
}
return
this
.
finishNode
(
node
"
ReturnStatement
"
)
;
}
;
pp
.
parseSwitchStatement
=
function
(
node
)
{
this
.
next
(
)
;
node
.
discriminant
=
this
.
parseParenExpression
(
)
;
node
.
cases
=
[
]
;
this
.
expect
(
_tokentype
.
types
.
braceL
)
;
this
.
labels
.
push
(
switchLabel
)
;
for
(
var
cur
sawDefault
=
false
;
this
.
type
!
=
_tokentype
.
types
.
braceR
;
)
{
if
(
this
.
type
=
=
=
_tokentype
.
types
.
_case
|
|
this
.
type
=
=
=
_tokentype
.
types
.
_default
)
{
var
isCase
=
this
.
type
=
=
=
_tokentype
.
types
.
_case
;
if
(
cur
)
this
.
finishNode
(
cur
"
SwitchCase
"
)
;
node
.
cases
.
push
(
cur
=
this
.
startNode
(
)
)
;
cur
.
consequent
=
[
]
;
this
.
next
(
)
;
if
(
isCase
)
{
cur
.
test
=
this
.
parseExpression
(
)
;
}
else
{
if
(
sawDefault
)
this
.
raise
(
this
.
lastTokStart
"
Multiple
default
clauses
"
)
;
sawDefault
=
true
;
cur
.
test
=
null
;
}
this
.
expect
(
_tokentype
.
types
.
colon
)
;
}
else
{
if
(
!
cur
)
this
.
unexpected
(
)
;
cur
.
consequent
.
push
(
this
.
parseStatement
(
true
)
)
;
}
}
if
(
cur
)
this
.
finishNode
(
cur
"
SwitchCase
"
)
;
this
.
next
(
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
"
SwitchStatement
"
)
;
}
;
pp
.
parseThrowStatement
=
function
(
node
)
{
this
.
next
(
)
;
if
(
_whitespace
.
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
start
)
)
)
this
.
raise
(
this
.
lastTokEnd
"
Illegal
newline
after
throw
"
)
;
node
.
argument
=
this
.
parseExpression
(
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ThrowStatement
"
)
;
}
;
var
empty
=
[
]
;
pp
.
parseTryStatement
=
function
(
node
)
{
this
.
next
(
)
;
node
.
block
=
this
.
parseBlock
(
)
;
node
.
handler
=
null
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
_catch
)
{
var
clause
=
this
.
startNode
(
)
;
this
.
next
(
)
;
this
.
expect
(
_tokentype
.
types
.
parenL
)
;
clause
.
param
=
this
.
parseBindingAtom
(
)
;
this
.
checkLVal
(
clause
.
param
true
)
;
this
.
expect
(
_tokentype
.
types
.
parenR
)
;
clause
.
body
=
this
.
parseBlock
(
)
;
node
.
handler
=
this
.
finishNode
(
clause
"
CatchClause
"
)
;
}
node
.
finalizer
=
this
.
eat
(
_tokentype
.
types
.
_finally
)
?
this
.
parseBlock
(
)
:
null
;
if
(
!
node
.
handler
&
&
!
node
.
finalizer
)
this
.
raise
(
node
.
start
"
Missing
catch
or
finally
clause
"
)
;
return
this
.
finishNode
(
node
"
TryStatement
"
)
;
}
;
pp
.
parseVarStatement
=
function
(
node
kind
)
{
this
.
next
(
)
;
this
.
parseVar
(
node
false
kind
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
VariableDeclaration
"
)
;
}
;
pp
.
parseWhileStatement
=
function
(
node
)
{
this
.
next
(
)
;
node
.
test
=
this
.
parseParenExpression
(
)
;
this
.
labels
.
push
(
loopLabel
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
"
WhileStatement
"
)
;
}
;
pp
.
parseWithStatement
=
function
(
node
)
{
if
(
this
.
strict
)
this
.
raise
(
this
.
start
"
'
with
'
in
strict
mode
"
)
;
this
.
next
(
)
;
node
.
object
=
this
.
parseParenExpression
(
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
return
this
.
finishNode
(
node
"
WithStatement
"
)
;
}
;
pp
.
parseEmptyStatement
=
function
(
node
)
{
this
.
next
(
)
;
return
this
.
finishNode
(
node
"
EmptyStatement
"
)
;
}
;
pp
.
parseLabeledStatement
=
function
(
node
maybeName
expr
)
{
for
(
var
i
=
0
;
i
<
this
.
labels
.
length
;
+
+
i
)
{
if
(
this
.
labels
[
i
]
.
name
=
=
=
maybeName
)
this
.
raise
(
expr
.
start
"
Label
'
"
+
maybeName
+
"
'
is
already
declared
"
)
;
}
var
kind
=
this
.
type
.
isLoop
?
"
loop
"
:
this
.
type
=
=
=
_tokentype
.
types
.
_switch
?
"
switch
"
:
null
;
for
(
var
i
=
this
.
labels
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
label
=
this
.
labels
[
i
]
;
if
(
label
.
statementStart
=
=
node
.
start
)
{
label
.
statementStart
=
this
.
start
;
label
.
kind
=
kind
;
}
else
break
;
}
this
.
labels
.
push
(
{
name
:
maybeName
kind
:
kind
statementStart
:
this
.
start
}
)
;
node
.
body
=
this
.
parseStatement
(
true
)
;
this
.
labels
.
pop
(
)
;
node
.
label
=
expr
;
return
this
.
finishNode
(
node
"
LabeledStatement
"
)
;
}
;
pp
.
parseExpressionStatement
=
function
(
node
expr
)
{
node
.
expression
=
expr
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ExpressionStatement
"
)
;
}
;
pp
.
parseBlock
=
function
(
allowStrict
)
{
var
node
=
this
.
startNode
(
)
first
=
true
oldStrict
=
undefined
;
node
.
body
=
[
]
;
this
.
expect
(
_tokentype
.
types
.
braceL
)
;
while
(
!
this
.
eat
(
_tokentype
.
types
.
braceR
)
)
{
var
stmt
=
this
.
parseStatement
(
true
)
;
node
.
body
.
push
(
stmt
)
;
if
(
first
&
&
allowStrict
&
&
this
.
isUseStrict
(
stmt
)
)
{
oldStrict
=
this
.
strict
;
this
.
setStrict
(
this
.
strict
=
true
)
;
}
first
=
false
;
}
if
(
oldStrict
=
=
=
false
)
this
.
setStrict
(
false
)
;
return
this
.
finishNode
(
node
"
BlockStatement
"
)
;
}
;
pp
.
parseFor
=
function
(
node
init
)
{
node
.
init
=
init
;
this
.
expect
(
_tokentype
.
types
.
semi
)
;
node
.
test
=
this
.
type
=
=
=
_tokentype
.
types
.
semi
?
null
:
this
.
parseExpression
(
)
;
this
.
expect
(
_tokentype
.
types
.
semi
)
;
node
.
update
=
this
.
type
=
=
=
_tokentype
.
types
.
parenR
?
null
:
this
.
parseExpression
(
)
;
this
.
expect
(
_tokentype
.
types
.
parenR
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
"
ForStatement
"
)
;
}
;
pp
.
parseForIn
=
function
(
node
init
)
{
var
type
=
this
.
type
=
=
=
_tokentype
.
types
.
_in
?
"
ForInStatement
"
:
"
ForOfStatement
"
;
this
.
next
(
)
;
node
.
left
=
init
;
node
.
right
=
this
.
parseExpression
(
)
;
this
.
expect
(
_tokentype
.
types
.
parenR
)
;
node
.
body
=
this
.
parseStatement
(
false
)
;
this
.
labels
.
pop
(
)
;
return
this
.
finishNode
(
node
type
)
;
}
;
pp
.
parseVar
=
function
(
node
isFor
kind
)
{
node
.
declarations
=
[
]
;
node
.
kind
=
kind
.
keyword
;
for
(
;
;
)
{
var
decl
=
this
.
startNode
(
)
;
this
.
parseVarId
(
decl
)
;
if
(
this
.
eat
(
_tokentype
.
types
.
eq
)
)
{
decl
.
init
=
this
.
parseMaybeAssign
(
isFor
)
;
}
else
if
(
kind
=
=
=
_tokentype
.
types
.
_const
&
&
!
(
this
.
type
=
=
=
_tokentype
.
types
.
_in
|
|
this
.
options
.
ecmaVersion
>
=
6
&
&
this
.
isContextual
(
"
of
"
)
)
)
{
this
.
unexpected
(
)
;
}
else
if
(
decl
.
id
.
type
!
=
"
Identifier
"
&
&
!
(
isFor
&
&
(
this
.
type
=
=
=
_tokentype
.
types
.
_in
|
|
this
.
isContextual
(
"
of
"
)
)
)
)
{
this
.
raise
(
this
.
lastTokEnd
"
Complex
binding
patterns
require
an
initialization
value
"
)
;
}
else
{
decl
.
init
=
null
;
}
node
.
declarations
.
push
(
this
.
finishNode
(
decl
"
VariableDeclarator
"
)
)
;
if
(
!
this
.
eat
(
_tokentype
.
types
.
comma
)
)
break
;
}
return
node
;
}
;
pp
.
parseVarId
=
function
(
decl
)
{
decl
.
id
=
this
.
parseBindingAtom
(
)
;
this
.
checkLVal
(
decl
.
id
true
)
;
}
;
pp
.
parseFunction
=
function
(
node
isStatement
allowExpressionBody
)
{
this
.
initFunction
(
node
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
node
.
generator
=
this
.
eat
(
_tokentype
.
types
.
star
)
;
if
(
isStatement
|
|
this
.
type
=
=
=
_tokentype
.
types
.
name
)
node
.
id
=
this
.
parseIdent
(
)
;
this
.
parseFunctionParams
(
node
)
;
this
.
parseFunctionBody
(
node
allowExpressionBody
)
;
return
this
.
finishNode
(
node
isStatement
?
"
FunctionDeclaration
"
:
"
FunctionExpression
"
)
;
}
;
pp
.
parseFunctionParams
=
function
(
node
)
{
this
.
expect
(
_tokentype
.
types
.
parenL
)
;
node
.
params
=
this
.
parseBindingList
(
_tokentype
.
types
.
parenR
false
false
true
)
;
}
;
pp
.
parseClass
=
function
(
node
isStatement
)
{
this
.
next
(
)
;
this
.
parseClassId
(
node
isStatement
)
;
this
.
parseClassSuper
(
node
)
;
var
classBody
=
this
.
startNode
(
)
;
var
hadConstructor
=
false
;
classBody
.
body
=
[
]
;
this
.
expect
(
_tokentype
.
types
.
braceL
)
;
while
(
!
this
.
eat
(
_tokentype
.
types
.
braceR
)
)
{
if
(
this
.
eat
(
_tokentype
.
types
.
semi
)
)
continue
;
var
method
=
this
.
startNode
(
)
;
var
isGenerator
=
this
.
eat
(
_tokentype
.
types
.
star
)
;
var
isMaybeStatic
=
this
.
type
=
=
=
_tokentype
.
types
.
name
&
&
this
.
value
=
=
=
"
static
"
;
this
.
parsePropertyName
(
method
)
;
method
[
"
static
"
]
=
isMaybeStatic
&
&
this
.
type
!
=
=
_tokentype
.
types
.
parenL
;
if
(
method
[
"
static
"
]
)
{
if
(
isGenerator
)
this
.
unexpected
(
)
;
isGenerator
=
this
.
eat
(
_tokentype
.
types
.
star
)
;
this
.
parsePropertyName
(
method
)
;
}
method
.
kind
=
"
method
"
;
var
isGetSet
=
false
;
if
(
!
method
.
computed
)
{
var
key
=
method
.
key
;
if
(
!
isGenerator
&
&
key
.
type
=
=
=
"
Identifier
"
&
&
this
.
type
!
=
=
_tokentype
.
types
.
parenL
&
&
(
key
.
name
=
=
=
"
get
"
|
|
key
.
name
=
=
=
"
set
"
)
)
{
isGetSet
=
true
;
method
.
kind
=
key
.
name
;
key
=
this
.
parsePropertyName
(
method
)
;
}
if
(
!
method
[
"
static
"
]
&
&
(
key
.
type
=
=
=
"
Identifier
"
&
&
key
.
name
=
=
=
"
constructor
"
|
|
key
.
type
=
=
=
"
Literal
"
&
&
key
.
value
=
=
=
"
constructor
"
)
)
{
if
(
hadConstructor
)
this
.
raise
(
key
.
start
"
Duplicate
constructor
in
the
same
class
"
)
;
if
(
isGetSet
)
this
.
raise
(
key
.
start
"
Constructor
can
'
t
have
get
/
set
modifier
"
)
;
if
(
isGenerator
)
this
.
raise
(
key
.
start
"
Constructor
can
'
t
be
a
generator
"
)
;
method
.
kind
=
"
constructor
"
;
hadConstructor
=
true
;
}
}
this
.
parseClassMethod
(
classBody
method
isGenerator
)
;
if
(
isGetSet
)
{
var
paramCount
=
method
.
kind
=
=
=
"
get
"
?
0
:
1
;
if
(
method
.
value
.
params
.
length
!
=
=
paramCount
)
{
var
start
=
method
.
value
.
start
;
if
(
method
.
kind
=
=
=
"
get
"
)
this
.
raise
(
start
"
getter
should
have
no
params
"
)
;
else
this
.
raise
(
start
"
setter
should
have
exactly
one
param
"
)
;
}
}
}
node
.
body
=
this
.
finishNode
(
classBody
"
ClassBody
"
)
;
return
this
.
finishNode
(
node
isStatement
?
"
ClassDeclaration
"
:
"
ClassExpression
"
)
;
}
;
pp
.
parseClassMethod
=
function
(
classBody
method
isGenerator
)
{
method
.
value
=
this
.
parseMethod
(
isGenerator
)
;
classBody
.
body
.
push
(
this
.
finishNode
(
method
"
MethodDefinition
"
)
)
;
}
;
pp
.
parseClassId
=
function
(
node
isStatement
)
{
node
.
id
=
this
.
type
=
=
=
_tokentype
.
types
.
name
?
this
.
parseIdent
(
)
:
isStatement
?
this
.
unexpected
(
)
:
null
;
}
;
pp
.
parseClassSuper
=
function
(
node
)
{
node
.
superClass
=
this
.
eat
(
_tokentype
.
types
.
_extends
)
?
this
.
parseExprSubscripts
(
)
:
null
;
}
;
pp
.
parseExport
=
function
(
node
)
{
this
.
next
(
)
;
if
(
this
.
eat
(
_tokentype
.
types
.
star
)
)
{
this
.
expectContextual
(
"
from
"
)
;
node
.
source
=
this
.
type
=
=
=
_tokentype
.
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
unexpected
(
)
;
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ExportAllDeclaration
"
)
;
}
if
(
this
.
eat
(
_tokentype
.
types
.
_default
)
)
{
var
expr
=
this
.
parseMaybeAssign
(
)
;
var
needsSemi
=
true
;
if
(
expr
.
type
=
=
"
FunctionExpression
"
|
|
expr
.
type
=
=
"
ClassExpression
"
)
{
needsSemi
=
false
;
if
(
expr
.
id
)
{
expr
.
type
=
expr
.
type
=
=
"
FunctionExpression
"
?
"
FunctionDeclaration
"
:
"
ClassDeclaration
"
;
}
}
node
.
declaration
=
expr
;
if
(
needsSemi
)
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ExportDefaultDeclaration
"
)
;
}
if
(
this
.
shouldParseExportStatement
(
)
)
{
node
.
declaration
=
this
.
parseStatement
(
true
)
;
node
.
specifiers
=
[
]
;
node
.
source
=
null
;
}
else
{
node
.
declaration
=
null
;
node
.
specifiers
=
this
.
parseExportSpecifiers
(
)
;
if
(
this
.
eatContextual
(
"
from
"
)
)
{
node
.
source
=
this
.
type
=
=
=
_tokentype
.
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
unexpected
(
)
;
}
else
{
for
(
var
i
=
0
;
i
<
node
.
specifiers
.
length
;
i
+
+
)
{
if
(
this
.
keywords
.
test
(
node
.
specifiers
[
i
]
.
local
.
name
)
|
|
this
.
reservedWords
.
test
(
node
.
specifiers
[
i
]
.
local
.
name
)
)
{
this
.
unexpected
(
node
.
specifiers
[
i
]
.
local
.
start
)
;
}
}
node
.
source
=
null
;
}
this
.
semicolon
(
)
;
}
return
this
.
finishNode
(
node
"
ExportNamedDeclaration
"
)
;
}
;
pp
.
shouldParseExportStatement
=
function
(
)
{
return
this
.
type
.
keyword
;
}
;
pp
.
parseExportSpecifiers
=
function
(
)
{
var
nodes
=
[
]
first
=
true
;
this
.
expect
(
_tokentype
.
types
.
braceL
)
;
while
(
!
this
.
eat
(
_tokentype
.
types
.
braceR
)
)
{
if
(
!
first
)
{
this
.
expect
(
_tokentype
.
types
.
comma
)
;
if
(
this
.
afterTrailingComma
(
_tokentype
.
types
.
braceR
)
)
break
;
}
else
first
=
false
;
var
node
=
this
.
startNode
(
)
;
node
.
local
=
this
.
parseIdent
(
this
.
type
=
=
=
_tokentype
.
types
.
_default
)
;
node
.
exported
=
this
.
eatContextual
(
"
as
"
)
?
this
.
parseIdent
(
true
)
:
node
.
local
;
nodes
.
push
(
this
.
finishNode
(
node
"
ExportSpecifier
"
)
)
;
}
return
nodes
;
}
;
pp
.
parseImport
=
function
(
node
)
{
this
.
next
(
)
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
string
)
{
node
.
specifiers
=
empty
;
node
.
source
=
this
.
parseExprAtom
(
)
;
}
else
{
node
.
specifiers
=
this
.
parseImportSpecifiers
(
)
;
this
.
expectContextual
(
"
from
"
)
;
node
.
source
=
this
.
type
=
=
=
_tokentype
.
types
.
string
?
this
.
parseExprAtom
(
)
:
this
.
unexpected
(
)
;
}
this
.
semicolon
(
)
;
return
this
.
finishNode
(
node
"
ImportDeclaration
"
)
;
}
;
pp
.
parseImportSpecifiers
=
function
(
)
{
var
nodes
=
[
]
first
=
true
;
if
(
this
.
type
=
=
=
_tokentype
.
types
.
name
)
{
var
node
=
this
.
startNode
(
)
;
node
.
local
=
this
.
parseIdent
(
)
;
this
.
checkLVal
(
node
.
local
true
)
;
nodes
.
push
(
this
.
finishNode
(
node
"
ImportDefaultSpecifier
"
)
)
;
if
(
!
this
.
eat
(
_tokentype
.
types
.
comma
)
)
return
nodes
;
}
if
(
this
.
type
=
=
=
_tokentype
.
types
.
star
)
{
var
node
=
this
.
startNode
(
)
;
this
.
next
(
)
;
this
.
expectContextual
(
"
as
"
)
;
node
.
local
=
this
.
parseIdent
(
)
;
this
.
checkLVal
(
node
.
local
true
)
;
nodes
.
push
(
this
.
finishNode
(
node
"
ImportNamespaceSpecifier
"
)
)
;
return
nodes
;
}
this
.
expect
(
_tokentype
.
types
.
braceL
)
;
while
(
!
this
.
eat
(
_tokentype
.
types
.
braceR
)
)
{
if
(
!
first
)
{
this
.
expect
(
_tokentype
.
types
.
comma
)
;
if
(
this
.
afterTrailingComma
(
_tokentype
.
types
.
braceR
)
)
break
;
}
else
first
=
false
;
var
node
=
this
.
startNode
(
)
;
node
.
imported
=
this
.
parseIdent
(
true
)
;
node
.
local
=
this
.
eatContextual
(
"
as
"
)
?
this
.
parseIdent
(
)
:
node
.
imported
;
this
.
checkLVal
(
node
.
local
true
)
;
nodes
.
push
(
this
.
finishNode
(
node
"
ImportSpecifier
"
)
)
;
}
return
nodes
;
}
;
}
{
"
.
/
state
"
:
10
"
.
/
tokentype
"
:
14
"
.
/
whitespace
"
:
16
}
]
12
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
var
_whitespace
=
_dereq_
(
"
.
/
whitespace
"
)
;
var
TokContext
=
function
TokContext
(
token
isExpr
preserveSpace
override
)
{
_classCallCheck
(
this
TokContext
)
;
this
.
token
=
token
;
this
.
isExpr
=
!
!
isExpr
;
this
.
preserveSpace
=
!
!
preserveSpace
;
this
.
override
=
override
;
}
;
exports
.
TokContext
=
TokContext
;
var
types
=
{
b_stat
:
new
TokContext
(
"
{
"
false
)
b_expr
:
new
TokContext
(
"
{
"
true
)
b_tmpl
:
new
TokContext
(
"
{
"
true
)
p_stat
:
new
TokContext
(
"
(
"
false
)
p_expr
:
new
TokContext
(
"
(
"
true
)
q_tmpl
:
new
TokContext
(
"
"
true
true
function
(
p
)
{
return
p
.
readTmplToken
(
)
;
}
)
f_expr
:
new
TokContext
(
"
function
"
true
)
}
;
exports
.
types
=
types
;
var
pp
=
_state
.
Parser
.
prototype
;
pp
.
initialContext
=
function
(
)
{
return
[
types
.
b_stat
]
;
}
;
pp
.
braceIsBlock
=
function
(
prevType
)
{
if
(
prevType
=
=
=
_tokentype
.
types
.
colon
)
{
var
_parent
=
this
.
curContext
(
)
;
if
(
_parent
=
=
=
types
.
b_stat
|
|
_parent
=
=
=
types
.
b_expr
)
return
!
_parent
.
isExpr
;
}
if
(
prevType
=
=
=
_tokentype
.
types
.
_return
)
return
_whitespace
.
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
start
)
)
;
if
(
prevType
=
=
=
_tokentype
.
types
.
_else
|
|
prevType
=
=
=
_tokentype
.
types
.
semi
|
|
prevType
=
=
=
_tokentype
.
types
.
eof
|
|
prevType
=
=
=
_tokentype
.
types
.
parenR
)
return
true
;
if
(
prevType
=
=
_tokentype
.
types
.
braceL
)
return
this
.
curContext
(
)
=
=
=
types
.
b_stat
;
return
!
this
.
exprAllowed
;
}
;
pp
.
updateContext
=
function
(
prevType
)
{
var
update
=
undefined
type
=
this
.
type
;
if
(
type
.
keyword
&
&
prevType
=
=
_tokentype
.
types
.
dot
)
this
.
exprAllowed
=
false
;
else
if
(
update
=
type
.
updateContext
)
update
.
call
(
this
prevType
)
;
else
this
.
exprAllowed
=
type
.
beforeExpr
;
}
;
_tokentype
.
types
.
parenR
.
updateContext
=
_tokentype
.
types
.
braceR
.
updateContext
=
function
(
)
{
if
(
this
.
context
.
length
=
=
1
)
{
this
.
exprAllowed
=
true
;
return
;
}
var
out
=
this
.
context
.
pop
(
)
;
if
(
out
=
=
=
types
.
b_stat
&
&
this
.
curContext
(
)
=
=
=
types
.
f_expr
)
{
this
.
context
.
pop
(
)
;
this
.
exprAllowed
=
false
;
}
else
if
(
out
=
=
=
types
.
b_tmpl
)
{
this
.
exprAllowed
=
true
;
}
else
{
this
.
exprAllowed
=
!
out
.
isExpr
;
}
}
;
_tokentype
.
types
.
braceL
.
updateContext
=
function
(
prevType
)
{
this
.
context
.
push
(
this
.
braceIsBlock
(
prevType
)
?
types
.
b_stat
:
types
.
b_expr
)
;
this
.
exprAllowed
=
true
;
}
;
_tokentype
.
types
.
dollarBraceL
.
updateContext
=
function
(
)
{
this
.
context
.
push
(
types
.
b_tmpl
)
;
this
.
exprAllowed
=
true
;
}
;
_tokentype
.
types
.
parenL
.
updateContext
=
function
(
prevType
)
{
var
statementParens
=
prevType
=
=
=
_tokentype
.
types
.
_if
|
|
prevType
=
=
=
_tokentype
.
types
.
_for
|
|
prevType
=
=
=
_tokentype
.
types
.
_with
|
|
prevType
=
=
=
_tokentype
.
types
.
_while
;
this
.
context
.
push
(
statementParens
?
types
.
p_stat
:
types
.
p_expr
)
;
this
.
exprAllowed
=
true
;
}
;
_tokentype
.
types
.
incDec
.
updateContext
=
function
(
)
{
}
;
_tokentype
.
types
.
_function
.
updateContext
=
function
(
)
{
if
(
this
.
curContext
(
)
!
=
=
types
.
b_stat
)
this
.
context
.
push
(
types
.
f_expr
)
;
this
.
exprAllowed
=
false
;
}
;
_tokentype
.
types
.
backQuote
.
updateContext
=
function
(
)
{
if
(
this
.
curContext
(
)
=
=
=
types
.
q_tmpl
)
this
.
context
.
pop
(
)
;
else
this
.
context
.
push
(
types
.
q_tmpl
)
;
this
.
exprAllowed
=
false
;
}
;
}
{
"
.
/
state
"
:
10
"
.
/
tokentype
"
:
14
"
.
/
whitespace
"
:
16
}
]
13
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
_identifier
=
_dereq_
(
"
.
/
identifier
"
)
;
var
_tokentype
=
_dereq_
(
"
.
/
tokentype
"
)
;
var
_state
=
_dereq_
(
"
.
/
state
"
)
;
var
_locutil
=
_dereq_
(
"
.
/
locutil
"
)
;
var
_whitespace
=
_dereq_
(
"
.
/
whitespace
"
)
;
var
Token
=
function
Token
(
p
)
{
_classCallCheck
(
this
Token
)
;
this
.
type
=
p
.
type
;
this
.
value
=
p
.
value
;
this
.
start
=
p
.
start
;
this
.
end
=
p
.
end
;
if
(
p
.
options
.
locations
)
this
.
loc
=
new
_locutil
.
SourceLocation
(
p
p
.
startLoc
p
.
endLoc
)
;
if
(
p
.
options
.
ranges
)
this
.
range
=
[
p
.
start
p
.
end
]
;
}
;
exports
.
Token
=
Token
;
var
pp
=
_state
.
Parser
.
prototype
;
var
isRhino
=
typeof
Packages
=
=
"
object
"
&
&
Object
.
prototype
.
toString
.
call
(
Packages
)
=
=
"
[
object
JavaPackage
]
"
;
pp
.
next
=
function
(
)
{
if
(
this
.
options
.
onToken
)
this
.
options
.
onToken
(
new
Token
(
this
)
)
;
this
.
lastTokEnd
=
this
.
end
;
this
.
lastTokStart
=
this
.
start
;
this
.
lastTokEndLoc
=
this
.
endLoc
;
this
.
lastTokStartLoc
=
this
.
startLoc
;
this
.
nextToken
(
)
;
}
;
pp
.
getToken
=
function
(
)
{
this
.
next
(
)
;
return
new
Token
(
this
)
;
}
;
if
(
typeof
Symbol
!
=
=
"
undefined
"
)
pp
[
Symbol
.
iterator
]
=
function
(
)
{
var
self
=
this
;
return
{
next
:
function
next
(
)
{
var
token
=
self
.
getToken
(
)
;
return
{
done
:
token
.
type
=
=
=
_tokentype
.
types
.
eof
value
:
token
}
;
}
}
;
}
;
pp
.
setStrict
=
function
(
strict
)
{
this
.
strict
=
strict
;
if
(
this
.
type
!
=
=
_tokentype
.
types
.
num
&
&
this
.
type
!
=
=
_tokentype
.
types
.
string
)
return
;
this
.
pos
=
this
.
start
;
if
(
this
.
options
.
locations
)
{
while
(
this
.
pos
<
this
.
lineStart
)
{
this
.
lineStart
=
this
.
input
.
lastIndexOf
(
"
\
n
"
this
.
lineStart
-
2
)
+
1
;
-
-
this
.
curLine
;
}
}
this
.
nextToken
(
)
;
}
;
pp
.
curContext
=
function
(
)
{
return
this
.
context
[
this
.
context
.
length
-
1
]
;
}
;
pp
.
nextToken
=
function
(
)
{
var
curContext
=
this
.
curContext
(
)
;
if
(
!
curContext
|
|
!
curContext
.
preserveSpace
)
this
.
skipSpace
(
)
;
this
.
start
=
this
.
pos
;
if
(
this
.
options
.
locations
)
this
.
startLoc
=
this
.
curPosition
(
)
;
if
(
this
.
pos
>
=
this
.
input
.
length
)
return
this
.
finishToken
(
_tokentype
.
types
.
eof
)
;
if
(
curContext
.
override
)
return
curContext
.
override
(
this
)
;
else
this
.
readToken
(
this
.
fullCharCodeAtPos
(
)
)
;
}
;
pp
.
readToken
=
function
(
code
)
{
if
(
_identifier
.
isIdentifierStart
(
code
this
.
options
.
ecmaVersion
>
=
6
)
|
|
code
=
=
=
92
)
return
this
.
readWord
(
)
;
return
this
.
getTokenFromCode
(
code
)
;
}
;
pp
.
fullCharCodeAtPos
=
function
(
)
{
var
code
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
if
(
code
<
=
0xd7ff
|
|
code
>
=
0xe000
)
return
code
;
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
return
(
code
<
<
10
)
+
next
-
0x35fdc00
;
}
;
pp
.
skipBlockComment
=
function
(
)
{
var
startLoc
=
this
.
options
.
onComment
&
&
this
.
curPosition
(
)
;
var
start
=
this
.
pos
end
=
this
.
input
.
indexOf
(
"
*
/
"
this
.
pos
+
=
2
)
;
if
(
end
=
=
=
-
1
)
this
.
raise
(
this
.
pos
-
2
"
Unterminated
comment
"
)
;
this
.
pos
=
end
+
2
;
if
(
this
.
options
.
locations
)
{
_whitespace
.
lineBreakG
.
lastIndex
=
start
;
var
match
=
undefined
;
while
(
(
match
=
_whitespace
.
lineBreakG
.
exec
(
this
.
input
)
)
&
&
match
.
index
<
this
.
pos
)
{
+
+
this
.
curLine
;
this
.
lineStart
=
match
.
index
+
match
[
0
]
.
length
;
}
}
if
(
this
.
options
.
onComment
)
this
.
options
.
onComment
(
true
this
.
input
.
slice
(
start
+
2
end
)
start
this
.
pos
startLoc
this
.
curPosition
(
)
)
;
}
;
pp
.
skipLineComment
=
function
(
startSkip
)
{
var
start
=
this
.
pos
;
var
startLoc
=
this
.
options
.
onComment
&
&
this
.
curPosition
(
)
;
var
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
+
=
startSkip
)
;
while
(
this
.
pos
<
this
.
input
.
length
&
&
ch
!
=
=
10
&
&
ch
!
=
=
13
&
&
ch
!
=
=
8232
&
&
ch
!
=
=
8233
)
{
+
+
this
.
pos
;
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
}
if
(
this
.
options
.
onComment
)
this
.
options
.
onComment
(
false
this
.
input
.
slice
(
start
+
startSkip
this
.
pos
)
start
this
.
pos
startLoc
this
.
curPosition
(
)
)
;
}
;
pp
.
skipSpace
=
function
(
)
{
loop
:
while
(
this
.
pos
<
this
.
input
.
length
)
{
var
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
switch
(
ch
)
{
case
32
:
case
160
:
+
+
this
.
pos
;
break
;
case
13
:
if
(
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
=
=
=
10
)
{
+
+
this
.
pos
;
}
case
10
:
case
8232
:
case
8233
:
+
+
this
.
pos
;
if
(
this
.
options
.
locations
)
{
+
+
this
.
curLine
;
this
.
lineStart
=
this
.
pos
;
}
break
;
case
47
:
switch
(
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
)
{
case
42
:
this
.
skipBlockComment
(
)
;
break
;
case
47
:
this
.
skipLineComment
(
2
)
;
break
;
default
:
break
loop
;
}
break
;
default
:
if
(
ch
>
8
&
&
ch
<
14
|
|
ch
>
=
5760
&
&
_whitespace
.
nonASCIIwhitespace
.
test
(
String
.
fromCharCode
(
ch
)
)
)
{
+
+
this
.
pos
;
}
else
{
break
loop
;
}
}
}
}
;
pp
.
finishToken
=
function
(
type
val
)
{
this
.
end
=
this
.
pos
;
if
(
this
.
options
.
locations
)
this
.
endLoc
=
this
.
curPosition
(
)
;
var
prevType
=
this
.
type
;
this
.
type
=
type
;
this
.
value
=
val
;
this
.
updateContext
(
prevType
)
;
}
;
pp
.
readToken_dot
=
function
(
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
>
=
48
&
&
next
<
=
57
)
return
this
.
readNumber
(
true
)
;
var
next2
=
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
&
&
next
=
=
=
46
&
&
next2
=
=
=
46
)
{
this
.
pos
+
=
3
;
return
this
.
finishToken
(
_tokentype
.
types
.
ellipsis
)
;
}
else
{
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
dot
)
;
}
}
;
pp
.
readToken_slash
=
function
(
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
this
.
exprAllowed
)
{
+
+
this
.
pos
;
return
this
.
readRegexp
(
)
;
}
if
(
next
=
=
=
61
)
return
this
.
finishOp
(
_tokentype
.
types
.
assign
2
)
;
return
this
.
finishOp
(
_tokentype
.
types
.
slash
1
)
;
}
;
pp
.
readToken_mult_modulo
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
61
)
return
this
.
finishOp
(
_tokentype
.
types
.
assign
2
)
;
return
this
.
finishOp
(
code
=
=
=
42
?
_tokentype
.
types
.
star
:
_tokentype
.
types
.
modulo
1
)
;
}
;
pp
.
readToken_pipe_amp
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
code
)
return
this
.
finishOp
(
code
=
=
=
124
?
_tokentype
.
types
.
logicalOR
:
_tokentype
.
types
.
logicalAND
2
)
;
if
(
next
=
=
=
61
)
return
this
.
finishOp
(
_tokentype
.
types
.
assign
2
)
;
return
this
.
finishOp
(
code
=
=
=
124
?
_tokentype
.
types
.
bitwiseOR
:
_tokentype
.
types
.
bitwiseAND
1
)
;
}
;
pp
.
readToken_caret
=
function
(
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
61
)
return
this
.
finishOp
(
_tokentype
.
types
.
assign
2
)
;
return
this
.
finishOp
(
_tokentype
.
types
.
bitwiseXOR
1
)
;
}
;
pp
.
readToken_plus_min
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
code
)
{
if
(
next
=
=
45
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
62
&
&
_whitespace
.
lineBreak
.
test
(
this
.
input
.
slice
(
this
.
lastTokEnd
this
.
pos
)
)
)
{
this
.
skipLineComment
(
3
)
;
this
.
skipSpace
(
)
;
return
this
.
nextToken
(
)
;
}
return
this
.
finishOp
(
_tokentype
.
types
.
incDec
2
)
;
}
if
(
next
=
=
=
61
)
return
this
.
finishOp
(
_tokentype
.
types
.
assign
2
)
;
return
this
.
finishOp
(
_tokentype
.
types
.
plusMin
1
)
;
}
;
pp
.
readToken_lt_gt
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
var
size
=
1
;
if
(
next
=
=
=
code
)
{
size
=
code
=
=
=
62
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
=
62
?
3
:
2
;
if
(
this
.
input
.
charCodeAt
(
this
.
pos
+
size
)
=
=
=
61
)
return
this
.
finishOp
(
_tokentype
.
types
.
assign
size
+
1
)
;
return
this
.
finishOp
(
_tokentype
.
types
.
bitShift
size
)
;
}
if
(
next
=
=
33
&
&
code
=
=
60
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
45
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
3
)
=
=
45
)
{
if
(
this
.
inModule
)
this
.
unexpected
(
)
;
this
.
skipLineComment
(
4
)
;
this
.
skipSpace
(
)
;
return
this
.
nextToken
(
)
;
}
if
(
next
=
=
=
61
)
size
=
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
=
61
?
3
:
2
;
return
this
.
finishOp
(
_tokentype
.
types
.
relational
size
)
;
}
;
pp
.
readToken_eq_excl
=
function
(
code
)
{
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
61
)
return
this
.
finishOp
(
_tokentype
.
types
.
equality
this
.
input
.
charCodeAt
(
this
.
pos
+
2
)
=
=
=
61
?
3
:
2
)
;
if
(
code
=
=
=
61
&
&
next
=
=
=
62
&
&
this
.
options
.
ecmaVersion
>
=
6
)
{
this
.
pos
+
=
2
;
return
this
.
finishToken
(
_tokentype
.
types
.
arrow
)
;
}
return
this
.
finishOp
(
code
=
=
=
61
?
_tokentype
.
types
.
eq
:
_tokentype
.
types
.
prefix
1
)
;
}
;
pp
.
getTokenFromCode
=
function
(
code
)
{
switch
(
code
)
{
case
46
:
return
this
.
readToken_dot
(
)
;
case
40
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
parenL
)
;
case
41
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
parenR
)
;
case
59
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
semi
)
;
case
44
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
comma
)
;
case
91
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
bracketL
)
;
case
93
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
bracketR
)
;
case
123
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
braceL
)
;
case
125
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
braceR
)
;
case
58
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
colon
)
;
case
63
:
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
question
)
;
case
96
:
if
(
this
.
options
.
ecmaVersion
<
6
)
break
;
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
backQuote
)
;
case
48
:
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
;
if
(
next
=
=
=
120
|
|
next
=
=
=
88
)
return
this
.
readRadixNumber
(
16
)
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
{
if
(
next
=
=
=
111
|
|
next
=
=
=
79
)
return
this
.
readRadixNumber
(
8
)
;
if
(
next
=
=
=
98
|
|
next
=
=
=
66
)
return
this
.
readRadixNumber
(
2
)
;
}
case
49
:
case
50
:
case
51
:
case
52
:
case
53
:
case
54
:
case
55
:
case
56
:
case
57
:
return
this
.
readNumber
(
false
)
;
case
34
:
case
39
:
return
this
.
readString
(
code
)
;
case
47
:
return
this
.
readToken_slash
(
)
;
case
37
:
case
42
:
return
this
.
readToken_mult_modulo
(
code
)
;
case
124
:
case
38
:
return
this
.
readToken_pipe_amp
(
code
)
;
case
94
:
return
this
.
readToken_caret
(
)
;
case
43
:
case
45
:
return
this
.
readToken_plus_min
(
code
)
;
case
60
:
case
62
:
return
this
.
readToken_lt_gt
(
code
)
;
case
61
:
case
33
:
return
this
.
readToken_eq_excl
(
code
)
;
case
126
:
return
this
.
finishOp
(
_tokentype
.
types
.
prefix
1
)
;
}
this
.
raise
(
this
.
pos
"
Unexpected
character
'
"
+
codePointToString
(
code
)
+
"
'
"
)
;
}
;
pp
.
finishOp
=
function
(
type
size
)
{
var
str
=
this
.
input
.
slice
(
this
.
pos
this
.
pos
+
size
)
;
this
.
pos
+
=
size
;
return
this
.
finishToken
(
type
str
)
;
}
;
function
tryCreateRegexp
(
src
flags
throwErrorAt
parser
)
{
try
{
return
new
RegExp
(
src
flags
)
;
}
catch
(
e
)
{
if
(
throwErrorAt
!
=
=
undefined
)
{
if
(
e
instanceof
SyntaxError
)
parser
.
raise
(
throwErrorAt
"
Error
parsing
regular
expression
:
"
+
e
.
message
)
;
throw
e
;
}
}
}
var
regexpUnicodeSupport
=
!
!
tryCreateRegexp
(
"
"
"
u
"
)
;
pp
.
readRegexp
=
function
(
)
{
var
_this
=
this
;
var
escaped
=
undefined
inClass
=
undefined
start
=
this
.
pos
;
for
(
;
;
)
{
if
(
this
.
pos
>
=
this
.
input
.
length
)
this
.
raise
(
start
"
Unterminated
regular
expression
"
)
;
var
ch
=
this
.
input
.
charAt
(
this
.
pos
)
;
if
(
_whitespace
.
lineBreak
.
test
(
ch
)
)
this
.
raise
(
start
"
Unterminated
regular
expression
"
)
;
if
(
!
escaped
)
{
if
(
ch
=
=
=
"
[
"
)
inClass
=
true
;
else
if
(
ch
=
=
=
"
]
"
&
&
inClass
)
inClass
=
false
;
else
if
(
ch
=
=
=
"
/
"
&
&
!
inClass
)
break
;
escaped
=
ch
=
=
=
"
\
\
"
;
}
else
escaped
=
false
;
+
+
this
.
pos
;
}
var
content
=
this
.
input
.
slice
(
start
this
.
pos
)
;
+
+
this
.
pos
;
var
mods
=
this
.
readWord1
(
)
;
var
tmp
=
content
;
if
(
mods
)
{
var
validFlags
=
/
^
[
gmsiy
]
*
/
;
if
(
this
.
options
.
ecmaVersion
>
=
6
)
validFlags
=
/
^
[
gmsiyu
]
*
/
;
if
(
!
validFlags
.
test
(
mods
)
)
this
.
raise
(
start
"
Invalid
regular
expression
flag
"
)
;
if
(
mods
.
indexOf
(
'
u
'
)
>
=
0
&
&
!
regexpUnicodeSupport
)
{
tmp
=
tmp
.
replace
(
/
\
\
u
\
{
(
[
0
-
9a
-
fA
-
F
]
+
)
\
}
/
g
function
(
_match
code
offset
)
{
code
=
Number
(
"
0x
"
+
code
)
;
if
(
code
>
0x10FFFF
)
_this
.
raise
(
start
+
offset
+
3
"
Code
point
out
of
bounds
"
)
;
return
"
x
"
;
}
)
;
tmp
=
tmp
.
replace
(
/
\
\
u
(
[
a
-
fA
-
F0
-
9
]
{
4
}
)
|
[
\
uD800
-
\
uDBFF
]
[
\
uDC00
-
\
uDFFF
]
/
g
"
x
"
)
;
}
}
var
value
=
null
;
if
(
!
isRhino
)
{
tryCreateRegexp
(
tmp
undefined
start
this
)
;
value
=
tryCreateRegexp
(
content
mods
)
;
}
return
this
.
finishToken
(
_tokentype
.
types
.
regexp
{
pattern
:
content
flags
:
mods
value
:
value
}
)
;
}
;
pp
.
readInt
=
function
(
radix
len
)
{
var
start
=
this
.
pos
total
=
0
;
for
(
var
i
=
0
e
=
len
=
=
null
?
Infinity
:
len
;
i
<
e
;
+
+
i
)
{
var
code
=
this
.
input
.
charCodeAt
(
this
.
pos
)
val
=
undefined
;
if
(
code
>
=
97
)
val
=
code
-
97
+
10
;
else
if
(
code
>
=
65
)
val
=
code
-
65
+
10
;
else
if
(
code
>
=
48
&
&
code
<
=
57
)
val
=
code
-
48
;
else
val
=
Infinity
;
if
(
val
>
=
radix
)
break
;
+
+
this
.
pos
;
total
=
total
*
radix
+
val
;
}
if
(
this
.
pos
=
=
=
start
|
|
len
!
=
null
&
&
this
.
pos
-
start
!
=
=
len
)
return
null
;
return
total
;
}
;
pp
.
readRadixNumber
=
function
(
radix
)
{
this
.
pos
+
=
2
;
var
val
=
this
.
readInt
(
radix
)
;
if
(
val
=
=
null
)
this
.
raise
(
this
.
start
+
2
"
Expected
number
in
radix
"
+
radix
)
;
if
(
_identifier
.
isIdentifierStart
(
this
.
fullCharCodeAtPos
(
)
)
)
this
.
raise
(
this
.
pos
"
Identifier
directly
after
number
"
)
;
return
this
.
finishToken
(
_tokentype
.
types
.
num
val
)
;
}
;
pp
.
readNumber
=
function
(
startsWithDot
)
{
var
start
=
this
.
pos
isFloat
=
false
octal
=
this
.
input
.
charCodeAt
(
this
.
pos
)
=
=
=
48
;
if
(
!
startsWithDot
&
&
this
.
readInt
(
10
)
=
=
=
null
)
this
.
raise
(
start
"
Invalid
number
"
)
;
var
next
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
if
(
next
=
=
=
46
)
{
+
+
this
.
pos
;
this
.
readInt
(
10
)
;
isFloat
=
true
;
next
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
}
if
(
next
=
=
=
69
|
|
next
=
=
=
101
)
{
next
=
this
.
input
.
charCodeAt
(
+
+
this
.
pos
)
;
if
(
next
=
=
=
43
|
|
next
=
=
=
45
)
+
+
this
.
pos
;
if
(
this
.
readInt
(
10
)
=
=
=
null
)
this
.
raise
(
start
"
Invalid
number
"
)
;
isFloat
=
true
;
}
if
(
_identifier
.
isIdentifierStart
(
this
.
fullCharCodeAtPos
(
)
)
)
this
.
raise
(
this
.
pos
"
Identifier
directly
after
number
"
)
;
var
str
=
this
.
input
.
slice
(
start
this
.
pos
)
val
=
undefined
;
if
(
isFloat
)
val
=
parseFloat
(
str
)
;
else
if
(
!
octal
|
|
str
.
length
=
=
=
1
)
val
=
parseInt
(
str
10
)
;
else
if
(
/
[
89
]
/
.
test
(
str
)
|
|
this
.
strict
)
this
.
raise
(
start
"
Invalid
number
"
)
;
else
val
=
parseInt
(
str
8
)
;
return
this
.
finishToken
(
_tokentype
.
types
.
num
val
)
;
}
;
pp
.
readCodePoint
=
function
(
)
{
var
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
)
code
=
undefined
;
if
(
ch
=
=
=
123
)
{
if
(
this
.
options
.
ecmaVersion
<
6
)
this
.
unexpected
(
)
;
var
codePos
=
+
+
this
.
pos
;
code
=
this
.
readHexChar
(
this
.
input
.
indexOf
(
'
}
'
this
.
pos
)
-
this
.
pos
)
;
+
+
this
.
pos
;
if
(
code
>
0x10FFFF
)
this
.
raise
(
codePos
"
Code
point
out
of
bounds
"
)
;
}
else
{
code
=
this
.
readHexChar
(
4
)
;
}
return
code
;
}
;
function
codePointToString
(
code
)
{
if
(
code
<
=
0xFFFF
)
return
String
.
fromCharCode
(
code
)
;
code
-
=
0x10000
;
return
String
.
fromCharCode
(
(
code
>
>
10
)
+
0xD800
(
code
&
1023
)
+
0xDC00
)
;
}
pp
.
readString
=
function
(
quote
)
{
var
out
=
"
"
chunkStart
=
+
+
this
.
pos
;
for
(
;
;
)
{
if
(
this
.
pos
>
=
this
.
input
.
length
)
this
.
raise
(
this
.
start
"
Unterminated
string
constant
"
)
;
var
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
if
(
ch
=
=
=
quote
)
break
;
if
(
ch
=
=
=
92
)
{
out
+
=
this
.
input
.
slice
(
chunkStart
this
.
pos
)
;
out
+
=
this
.
readEscapedChar
(
false
)
;
chunkStart
=
this
.
pos
;
}
else
{
if
(
_whitespace
.
isNewLine
(
ch
)
)
this
.
raise
(
this
.
start
"
Unterminated
string
constant
"
)
;
+
+
this
.
pos
;
}
}
out
+
=
this
.
input
.
slice
(
chunkStart
this
.
pos
+
+
)
;
return
this
.
finishToken
(
_tokentype
.
types
.
string
out
)
;
}
;
pp
.
readTmplToken
=
function
(
)
{
var
out
=
"
"
chunkStart
=
this
.
pos
;
for
(
;
;
)
{
if
(
this
.
pos
>
=
this
.
input
.
length
)
this
.
raise
(
this
.
start
"
Unterminated
template
"
)
;
var
ch
=
this
.
input
.
charCodeAt
(
this
.
pos
)
;
if
(
ch
=
=
=
96
|
|
ch
=
=
=
36
&
&
this
.
input
.
charCodeAt
(
this
.
pos
+
1
)
=
=
=
123
)
{
if
(
this
.
pos
=
=
=
this
.
start
&
&
this
.
type
=
=
=
_tokentype
.
types
.
template
)
{
if
(
ch
=
=
=
36
)
{
this
.
pos
+
=
2
;
return
this
.
finishToken
(
_tokentype
.
types
.
dollarBraceL
)
;
}
else
{
+
+
this
.
pos
;
return
this
.
finishToken
(
_tokentype
.
types
.
backQuote
)
;
}
}
out
+
=
this
.
input
.
slice
(
chunkStart
this
.
pos
)
;
return
this
.
finishToken
(
_tokentype
.
types
.
template
out
)
;
}
if
(
ch
=
=
=
92
)
{
out
+
=
this
.
input
.
slice
(
chunkStart
this
.
pos
)
;
out
+
=
this
.
readEscapedChar
(
true
)
;
chunkStart
=
this
.
pos
;
}
else
if
(
_whitespace
.
isNewLine
(
ch
)
)
{
out
+
=
this
.
input
.
slice
(
chunkStart
this
.
pos
)
;
+
+
this
.
pos
;
switch
(
ch
)
{
case
13
:
if
(
this
.
input
.
charCodeAt
(
this
.
pos
)
=
=
=
10
)
+
+
this
.
pos
;
case
10
:
out
+
=
"
\
n
"
;
break
;
default
:
out
+
=
String
.
fromCharCode
(
ch
)
;
break
;
}
if
(
this
.
options
.
locations
)
{
+
+
this
.
curLine
;
this
.
lineStart
=
this
.
pos
;
}
chunkStart
=
this
.
pos
;
}
else
{
+
+
this
.
pos
;
}
}
}
;
pp
.
readEscapedChar
=
function
(
inTemplate
)
{
var
ch
=
this
.
input
.
charCodeAt
(
+
+
this
.
pos
)
;
+
+
this
.
pos
;
switch
(
ch
)
{
case
110
:
return
"
\
n
"
;
case
114
:
return
"
\
r
"
;
case
120
:
return
String
.
fromCharCode
(
this
.
readHexChar
(
2
)
)
;
case
117
:
return
codePointToString
(
this
.
readCodePoint
(
)
)
;
case
116
:
return
"
\
t
"
;
case
98
:
return
"
\
b
"
;
case
118
:
return
"
\
u000b
"
;
case
102
:
return
"
\
f
"
;
case
13
:
if
(
this
.
input
.
charCodeAt
(
this
.
pos
)
=
=
=
10
)
+
+
this
.
pos
;
case
10
:
if
(
this
.
options
.
locations
)
{
this
.
lineStart
=
this
.
pos
;
+
+
this
.
curLine
;
}
return
"
"
;
default
:
if
(
ch
>
=
48
&
&
ch
<
=
55
)
{
var
octalStr
=
this
.
input
.
substr
(
this
.
pos
-
1
3
)
.
match
(
/
^
[
0
-
7
]
+
/
)
[
0
]
;
var
octal
=
parseInt
(
octalStr
8
)
;
if
(
octal
>
255
)
{
octalStr
=
octalStr
.
slice
(
0
-
1
)
;
octal
=
parseInt
(
octalStr
8
)
;
}
if
(
octal
>
0
&
&
(
this
.
strict
|
|
inTemplate
)
)
{
this
.
raise
(
this
.
pos
-
2
"
Octal
literal
in
strict
mode
"
)
;
}
this
.
pos
+
=
octalStr
.
length
-
1
;
return
String
.
fromCharCode
(
octal
)
;
}
return
String
.
fromCharCode
(
ch
)
;
}
}
;
pp
.
readHexChar
=
function
(
len
)
{
var
codePos
=
this
.
pos
;
var
n
=
this
.
readInt
(
16
len
)
;
if
(
n
=
=
=
null
)
this
.
raise
(
codePos
"
Bad
character
escape
sequence
"
)
;
return
n
;
}
;
pp
.
readWord1
=
function
(
)
{
this
.
containsEsc
=
false
;
var
word
=
"
"
first
=
true
chunkStart
=
this
.
pos
;
var
astral
=
this
.
options
.
ecmaVersion
>
=
6
;
while
(
this
.
pos
<
this
.
input
.
length
)
{
var
ch
=
this
.
fullCharCodeAtPos
(
)
;
if
(
_identifier
.
isIdentifierChar
(
ch
astral
)
)
{
this
.
pos
+
=
ch
<
=
0xffff
?
1
:
2
;
}
else
if
(
ch
=
=
=
92
)
{
this
.
containsEsc
=
true
;
word
+
=
this
.
input
.
slice
(
chunkStart
this
.
pos
)
;
var
escStart
=
this
.
pos
;
if
(
this
.
input
.
charCodeAt
(
+
+
this
.
pos
)
!
=
117
)
this
.
raise
(
this
.
pos
"
Expecting
Unicode
escape
sequence
\
\
uXXXX
"
)
;
+
+
this
.
pos
;
var
esc
=
this
.
readCodePoint
(
)
;
if
(
!
(
first
?
_identifier
.
isIdentifierStart
:
_identifier
.
isIdentifierChar
)
(
esc
astral
)
)
this
.
raise
(
escStart
"
Invalid
Unicode
escape
"
)
;
word
+
=
codePointToString
(
esc
)
;
chunkStart
=
this
.
pos
;
}
else
{
break
;
}
first
=
false
;
}
return
word
+
this
.
input
.
slice
(
chunkStart
this
.
pos
)
;
}
;
pp
.
readWord
=
function
(
)
{
var
word
=
this
.
readWord1
(
)
;
var
type
=
_tokentype
.
types
.
name
;
if
(
(
this
.
options
.
ecmaVersion
>
=
6
|
|
!
this
.
containsEsc
)
&
&
this
.
keywords
.
test
(
word
)
)
type
=
_tokentype
.
keywords
[
word
]
;
return
this
.
finishToken
(
type
word
)
;
}
;
}
{
"
.
/
identifier
"
:
2
"
.
/
locutil
"
:
5
"
.
/
state
"
:
10
"
.
/
tokentype
"
:
14
"
.
/
whitespace
"
:
16
}
]
14
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
function
_classCallCheck
(
instance
Constructor
)
{
if
(
!
(
instance
instanceof
Constructor
)
)
{
throw
new
TypeError
(
"
Cannot
call
a
class
as
a
function
"
)
;
}
}
var
TokenType
=
function
TokenType
(
label
)
{
var
conf
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
_classCallCheck
(
this
TokenType
)
;
this
.
label
=
label
;
this
.
keyword
=
conf
.
keyword
;
this
.
beforeExpr
=
!
!
conf
.
beforeExpr
;
this
.
startsExpr
=
!
!
conf
.
startsExpr
;
this
.
isLoop
=
!
!
conf
.
isLoop
;
this
.
isAssign
=
!
!
conf
.
isAssign
;
this
.
prefix
=
!
!
conf
.
prefix
;
this
.
postfix
=
!
!
conf
.
postfix
;
this
.
binop
=
conf
.
binop
|
|
null
;
this
.
updateContext
=
null
;
}
;
exports
.
TokenType
=
TokenType
;
function
binop
(
name
prec
)
{
return
new
TokenType
(
name
{
beforeExpr
:
true
binop
:
prec
}
)
;
}
var
beforeExpr
=
{
beforeExpr
:
true
}
startsExpr
=
{
startsExpr
:
true
}
;
var
types
=
{
num
:
new
TokenType
(
"
num
"
startsExpr
)
regexp
:
new
TokenType
(
"
regexp
"
startsExpr
)
string
:
new
TokenType
(
"
string
"
startsExpr
)
name
:
new
TokenType
(
"
name
"
startsExpr
)
eof
:
new
TokenType
(
"
eof
"
)
bracketL
:
new
TokenType
(
"
[
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
bracketR
:
new
TokenType
(
"
]
"
)
braceL
:
new
TokenType
(
"
{
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
braceR
:
new
TokenType
(
"
}
"
)
parenL
:
new
TokenType
(
"
(
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
parenR
:
new
TokenType
(
"
)
"
)
comma
:
new
TokenType
(
"
"
beforeExpr
)
semi
:
new
TokenType
(
"
;
"
beforeExpr
)
colon
:
new
TokenType
(
"
:
"
beforeExpr
)
dot
:
new
TokenType
(
"
.
"
)
question
:
new
TokenType
(
"
?
"
beforeExpr
)
arrow
:
new
TokenType
(
"
=
>
"
beforeExpr
)
template
:
new
TokenType
(
"
template
"
)
ellipsis
:
new
TokenType
(
"
.
.
.
"
beforeExpr
)
backQuote
:
new
TokenType
(
"
"
startsExpr
)
dollarBraceL
:
new
TokenType
(
"
{
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
eq
:
new
TokenType
(
"
=
"
{
beforeExpr
:
true
isAssign
:
true
}
)
assign
:
new
TokenType
(
"
_
=
"
{
beforeExpr
:
true
isAssign
:
true
}
)
incDec
:
new
TokenType
(
"
+
+
/
-
-
"
{
prefix
:
true
postfix
:
true
startsExpr
:
true
}
)
prefix
:
new
TokenType
(
"
prefix
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
logicalOR
:
binop
(
"
|
|
"
1
)
logicalAND
:
binop
(
"
&
&
"
2
)
bitwiseOR
:
binop
(
"
|
"
3
)
bitwiseXOR
:
binop
(
"
^
"
4
)
bitwiseAND
:
binop
(
"
&
"
5
)
equality
:
binop
(
"
=
=
/
!
=
"
6
)
relational
:
binop
(
"
<
/
>
"
7
)
bitShift
:
binop
(
"
<
<
/
>
>
"
8
)
plusMin
:
new
TokenType
(
"
+
/
-
"
{
beforeExpr
:
true
binop
:
9
prefix
:
true
startsExpr
:
true
}
)
modulo
:
binop
(
"
%
"
10
)
star
:
binop
(
"
*
"
10
)
slash
:
binop
(
"
/
"
10
)
}
;
exports
.
types
=
types
;
var
keywords
=
{
}
;
exports
.
keywords
=
keywords
;
function
kw
(
name
)
{
var
options
=
arguments
.
length
<
=
1
|
|
arguments
[
1
]
=
=
=
undefined
?
{
}
:
arguments
[
1
]
;
options
.
keyword
=
name
;
keywords
[
name
]
=
types
[
"
_
"
+
name
]
=
new
TokenType
(
name
options
)
;
}
kw
(
"
break
"
)
;
kw
(
"
case
"
beforeExpr
)
;
kw
(
"
catch
"
)
;
kw
(
"
continue
"
)
;
kw
(
"
debugger
"
)
;
kw
(
"
default
"
beforeExpr
)
;
kw
(
"
do
"
{
isLoop
:
true
beforeExpr
:
true
}
)
;
kw
(
"
else
"
beforeExpr
)
;
kw
(
"
finally
"
)
;
kw
(
"
for
"
{
isLoop
:
true
}
)
;
kw
(
"
function
"
startsExpr
)
;
kw
(
"
if
"
)
;
kw
(
"
return
"
beforeExpr
)
;
kw
(
"
switch
"
)
;
kw
(
"
throw
"
beforeExpr
)
;
kw
(
"
try
"
)
;
kw
(
"
var
"
)
;
kw
(
"
let
"
)
;
kw
(
"
const
"
)
;
kw
(
"
while
"
{
isLoop
:
true
}
)
;
kw
(
"
with
"
)
;
kw
(
"
new
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
;
kw
(
"
this
"
startsExpr
)
;
kw
(
"
super
"
startsExpr
)
;
kw
(
"
class
"
)
;
kw
(
"
extends
"
beforeExpr
)
;
kw
(
"
export
"
)
;
kw
(
"
import
"
)
;
kw
(
"
yield
"
{
beforeExpr
:
true
startsExpr
:
true
}
)
;
kw
(
"
null
"
startsExpr
)
;
kw
(
"
true
"
startsExpr
)
;
kw
(
"
false
"
startsExpr
)
;
kw
(
"
in
"
{
beforeExpr
:
true
binop
:
7
}
)
;
kw
(
"
instanceof
"
{
beforeExpr
:
true
binop
:
7
}
)
;
kw
(
"
typeof
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
;
kw
(
"
void
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
;
kw
(
"
delete
"
{
beforeExpr
:
true
prefix
:
true
startsExpr
:
true
}
)
;
}
{
}
]
15
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
isArray
=
isArray
;
exports
.
has
=
has
;
function
isArray
(
obj
)
{
return
Object
.
prototype
.
toString
.
call
(
obj
)
=
=
=
"
[
object
Array
]
"
;
}
function
has
(
obj
propName
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
propName
)
;
}
}
{
}
]
16
:
[
function
(
_dereq_
module
exports
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
isNewLine
=
isNewLine
;
var
lineBreak
=
/
\
r
\
n
?
|
\
n
|
\
u2028
|
\
u2029
/
;
exports
.
lineBreak
=
lineBreak
;
var
lineBreakG
=
new
RegExp
(
lineBreak
.
source
"
g
"
)
;
exports
.
lineBreakG
=
lineBreakG
;
function
isNewLine
(
code
)
{
return
code
=
=
=
10
|
|
code
=
=
=
13
|
|
code
=
=
=
0x2028
|
|
code
=
=
0x2029
;
}
var
nonASCIIwhitespace
=
/
[
\
u1680
\
u180e
\
u2000
-
\
u200a
\
u202f
\
u205f
\
u3000
\
ufeff
]
/
;
exports
.
nonASCIIwhitespace
=
nonASCIIwhitespace
;
}
{
}
]
}
{
}
[
3
]
)
(
3
)
}
)
;
}
)
802
:
(
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_FACTORY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
root
factory
)
{
"
use
strict
"
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_FACTORY__
=
(
factory
)
__WEBPACK_AMD_DEFINE_RESULT__
=
(
typeof
__WEBPACK_AMD_DEFINE_FACTORY__
=
=
=
'
function
'
?
(
__WEBPACK_AMD_DEFINE_FACTORY__
.
call
(
exports
__webpack_require__
exports
module
)
)
:
__WEBPACK_AMD_DEFINE_FACTORY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
typeof
exports
=
=
=
"
object
"
)
{
module
.
exports
=
factory
(
)
;
}
else
{
root
.
prettyFast
=
factory
(
)
;
}
}
(
this
function
(
)
{
"
use
strict
"
;
var
acorn
=
this
.
acorn
|
|
__webpack_require__
(
381
)
;
var
sourceMap
=
this
.
sourceMap
|
|
__webpack_require__
(
815
)
;
var
SourceNode
=
sourceMap
.
SourceNode
;
var
PRE_ARRAY_LITERAL_TOKENS
=
{
"
typeof
"
:
true
"
void
"
:
true
"
delete
"
:
true
"
case
"
:
true
"
do
"
:
true
"
=
"
:
true
"
in
"
:
true
"
{
"
:
true
"
*
"
:
true
"
/
"
:
true
"
%
"
:
true
"
else
"
:
true
"
;
"
:
true
"
+
+
"
:
true
"
-
-
"
:
true
"
+
"
:
true
"
-
"
:
true
"
~
"
:
true
"
!
"
:
true
"
:
"
:
true
"
?
"
:
true
"
>
>
"
:
true
"
>
>
>
"
:
true
"
<
<
"
:
true
"
|
|
"
:
true
"
&
&
"
:
true
"
<
"
:
true
"
>
"
:
true
"
<
=
"
:
true
"
>
=
"
:
true
"
instanceof
"
:
true
"
&
"
:
true
"
^
"
:
true
"
|
"
:
true
"
=
=
"
:
true
"
!
=
"
:
true
"
=
=
=
"
:
true
"
!
=
=
"
:
true
"
"
:
true
"
}
"
:
true
}
;
function
isArrayLiteral
(
token
lastToken
)
{
if
(
token
.
type
.
label
!
=
"
[
"
)
{
return
false
;
}
if
(
!
lastToken
)
{
return
true
;
}
if
(
lastToken
.
type
.
isAssign
)
{
return
true
;
}
return
!
!
PRE_ARRAY_LITERAL_TOKENS
[
lastToken
.
type
.
keyword
|
|
lastToken
.
type
.
label
]
;
}
var
PREVENT_ASI_AFTER_TOKENS
=
{
"
*
"
:
true
"
/
"
:
true
"
%
"
:
true
"
+
"
:
true
"
-
"
:
true
"
<
<
"
:
true
"
>
>
"
:
true
"
>
>
>
"
:
true
"
<
"
:
true
"
>
"
:
true
"
<
=
"
:
true
"
>
=
"
:
true
"
instanceof
"
:
true
"
in
"
:
true
"
=
=
"
:
true
"
!
=
"
:
true
"
=
=
=
"
:
true
"
!
=
=
"
:
true
"
&
"
:
true
"
^
"
:
true
"
|
"
:
true
"
&
&
"
:
true
"
|
|
"
:
true
"
"
:
true
"
.
"
:
true
"
=
"
:
true
"
*
=
"
:
true
"
/
=
"
:
true
"
%
=
"
:
true
"
+
=
"
:
true
"
-
=
"
:
true
"
<
<
=
"
:
true
"
>
>
=
"
:
true
"
>
>
>
=
"
:
true
"
&
=
"
:
true
"
^
=
"
:
true
"
|
=
"
:
true
"
delete
"
:
true
"
void
"
:
true
"
typeof
"
:
true
"
~
"
:
true
"
!
"
:
true
"
new
"
:
true
"
(
"
:
true
}
;
var
PREVENT_ASI_BEFORE_TOKENS
=
{
"
*
"
:
true
"
/
"
:
true
"
%
"
:
true
"
<
<
"
:
true
"
>
>
"
:
true
"
>
>
>
"
:
true
"
<
"
:
true
"
>
"
:
true
"
<
=
"
:
true
"
>
=
"
:
true
"
instanceof
"
:
true
"
in
"
:
true
"
=
=
"
:
true
"
!
=
"
:
true
"
=
=
=
"
:
true
"
!
=
=
"
:
true
"
&
"
:
true
"
^
"
:
true
"
|
"
:
true
"
&
&
"
:
true
"
|
|
"
:
true
"
"
:
true
"
.
"
:
true
"
=
"
:
true
"
*
=
"
:
true
"
/
=
"
:
true
"
%
=
"
:
true
"
+
=
"
:
true
"
-
=
"
:
true
"
<
<
=
"
:
true
"
>
>
=
"
:
true
"
>
>
>
=
"
:
true
"
&
=
"
:
true
"
^
=
"
:
true
"
|
=
"
:
true
"
(
"
:
true
}
;
function
isASI
(
token
lastToken
)
{
if
(
!
lastToken
)
{
return
false
;
}
if
(
token
.
loc
.
start
.
line
=
=
=
lastToken
.
loc
.
start
.
line
)
{
return
false
;
}
if
(
PREVENT_ASI_AFTER_TOKENS
[
lastToken
.
type
.
label
|
|
lastToken
.
type
.
keyword
]
)
{
return
false
;
}
if
(
PREVENT_ASI_BEFORE_TOKENS
[
token
.
type
.
label
|
|
token
.
type
.
keyword
]
)
{
return
false
;
}
return
true
;
}
function
isGetterOrSetter
(
token
lastToken
stack
)
{
return
stack
[
stack
.
length
-
1
]
=
=
"
{
"
&
&
lastToken
&
&
lastToken
.
type
.
label
=
=
"
name
"
&
&
(
lastToken
.
value
=
=
"
get
"
|
|
lastToken
.
value
=
=
"
set
"
)
&
&
token
.
type
.
label
=
=
"
name
"
;
}
function
isLineDelimiter
(
token
stack
)
{
if
(
token
.
isArrayLiteral
)
{
return
true
;
}
var
ttl
=
token
.
type
.
label
;
var
top
=
stack
[
stack
.
length
-
1
]
;
return
ttl
=
=
"
;
"
&
&
top
!
=
"
(
"
|
|
ttl
=
=
"
{
"
|
|
ttl
=
=
"
"
&
&
top
!
=
"
(
"
|
|
ttl
=
=
"
:
"
&
&
(
top
=
=
"
case
"
|
|
top
=
=
"
default
"
)
;
}
function
appendNewline
(
token
write
stack
)
{
if
(
isLineDelimiter
(
token
stack
)
)
{
write
(
"
\
n
"
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
return
true
;
}
return
false
;
}
function
needsSpaceAfter
(
token
lastToken
)
{
if
(
lastToken
)
{
if
(
lastToken
.
type
.
isLoop
)
{
return
true
;
}
if
(
lastToken
.
type
.
isAssign
)
{
return
true
;
}
if
(
lastToken
.
type
.
binop
!
=
null
)
{
return
true
;
}
var
ltt
=
lastToken
.
type
.
label
;
if
(
ltt
=
=
"
?
"
)
{
return
true
;
}
if
(
ltt
=
=
"
:
"
)
{
return
true
;
}
if
(
ltt
=
=
"
"
)
{
return
true
;
}
if
(
ltt
=
=
"
;
"
)
{
return
true
;
}
var
ltk
=
lastToken
.
type
.
keyword
;
if
(
ltk
!
=
null
)
{
if
(
ltk
=
=
"
break
"
|
|
ltk
=
=
"
continue
"
|
|
ltk
=
=
"
return
"
)
{
return
token
.
type
.
label
!
=
"
;
"
;
}
if
(
ltk
!
=
"
debugger
"
&
&
ltk
!
=
"
null
"
&
&
ltk
!
=
"
true
"
&
&
ltk
!
=
"
false
"
&
&
ltk
!
=
"
this
"
&
&
ltk
!
=
"
default
"
)
{
return
true
;
}
}
if
(
ltt
=
=
"
)
"
&
&
(
token
.
type
.
label
!
=
"
)
"
&
&
token
.
type
.
label
!
=
"
]
"
&
&
token
.
type
.
label
!
=
"
;
"
&
&
token
.
type
.
label
!
=
"
"
&
&
token
.
type
.
label
!
=
"
.
"
)
)
{
return
true
;
}
}
if
(
token
.
type
.
isAssign
)
{
return
true
;
}
if
(
token
.
type
.
binop
!
=
null
)
{
return
true
;
}
if
(
token
.
type
.
label
=
=
"
?
"
)
{
return
true
;
}
return
false
;
}
function
prependWhiteSpace
(
token
lastToken
addedNewline
write
options
indentLevel
stack
)
{
var
ttk
=
token
.
type
.
keyword
;
var
ttl
=
token
.
type
.
label
;
var
newlineAdded
=
addedNewline
;
var
ltt
=
lastToken
?
lastToken
.
type
.
label
:
null
;
if
(
lastToken
&
&
ltt
=
=
"
}
"
)
{
if
(
ttk
=
=
"
while
"
&
&
stack
[
stack
.
length
-
1
]
=
=
"
do
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
else
if
(
ttk
=
=
"
else
"
|
|
ttk
=
=
"
catch
"
|
|
ttk
=
=
"
finally
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
else
if
(
ttl
!
=
"
(
"
&
&
ttl
!
=
"
;
"
&
&
ttl
!
=
"
"
&
&
ttl
!
=
"
)
"
&
&
ttl
!
=
"
.
"
)
{
write
(
"
\
n
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
newlineAdded
=
true
;
}
}
if
(
isGetterOrSetter
(
token
lastToken
stack
)
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
if
(
ttl
=
=
"
:
"
&
&
stack
[
stack
.
length
-
1
]
=
=
"
?
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
if
(
lastToken
&
&
ltt
!
=
"
}
"
&
&
ttk
=
=
"
else
"
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
function
ensureNewline
(
)
{
if
(
!
newlineAdded
)
{
write
(
"
\
n
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
newlineAdded
=
true
;
}
}
if
(
isASI
(
token
lastToken
)
)
{
ensureNewline
(
)
;
}
if
(
decrementsIndent
(
ttl
stack
)
)
{
ensureNewline
(
)
;
}
if
(
newlineAdded
)
{
if
(
ttk
=
=
"
case
"
|
|
ttk
=
=
"
default
"
)
{
write
(
repeat
(
options
.
indent
indentLevel
-
1
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
else
{
write
(
repeat
(
options
.
indent
indentLevel
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
}
else
if
(
needsSpaceAfter
(
token
lastToken
)
)
{
write
(
"
"
lastToken
.
loc
.
start
.
line
lastToken
.
loc
.
start
.
column
)
;
}
}
function
repeat
(
str
n
)
{
var
result
=
"
"
;
while
(
n
>
0
)
{
if
(
n
&
1
)
{
result
+
=
str
;
}
n
>
>
=
1
;
str
+
=
str
;
}
return
result
;
}
var
sanitize
=
(
function
(
)
{
var
escapeCharacters
=
{
"
\
\
"
:
"
\
\
\
\
"
"
\
n
"
:
"
\
\
n
"
"
\
r
"
:
"
\
\
r
"
"
\
t
"
:
"
\
\
t
"
"
\
v
"
:
"
\
\
v
"
"
\
f
"
:
"
\
\
f
"
"
\
0
"
:
"
\
\
0
"
"
'
"
:
"
\
\
'
"
}
;
var
regExpString
=
"
(
"
+
Object
.
keys
(
escapeCharacters
)
.
map
(
function
(
c
)
{
return
escapeCharacters
[
c
]
;
}
)
.
join
(
"
|
"
)
+
"
)
"
;
var
escapeCharactersRegExp
=
new
RegExp
(
regExpString
"
g
"
)
;
return
function
(
str
)
{
return
str
.
replace
(
escapeCharactersRegExp
function
(
_
c
)
{
return
escapeCharacters
[
c
]
;
}
)
;
}
;
}
(
)
)
;
function
addToken
(
token
write
)
{
if
(
token
.
type
.
label
=
=
"
string
"
)
{
write
(
"
'
"
+
sanitize
(
token
.
value
)
+
"
'
"
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
else
if
(
token
.
type
.
label
=
=
"
regexp
"
)
{
write
(
String
(
token
.
value
.
value
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
else
{
write
(
String
(
token
.
value
!
=
null
?
token
.
value
:
token
.
type
.
label
)
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
}
}
function
belongsOnStack
(
token
)
{
var
ttl
=
token
.
type
.
label
;
var
ttk
=
token
.
type
.
keyword
;
return
ttl
=
=
"
{
"
|
|
ttl
=
=
"
(
"
|
|
ttl
=
=
"
[
"
|
|
ttl
=
=
"
?
"
|
|
ttk
=
=
"
do
"
|
|
ttk
=
=
"
switch
"
|
|
ttk
=
=
"
case
"
|
|
ttk
=
=
"
default
"
;
}
function
shouldStackPop
(
token
stack
)
{
var
ttl
=
token
.
type
.
label
;
var
ttk
=
token
.
type
.
keyword
;
var
top
=
stack
[
stack
.
length
-
1
]
;
return
ttl
=
=
"
]
"
|
|
ttl
=
=
"
)
"
|
|
ttl
=
=
"
}
"
|
|
(
ttl
=
=
"
:
"
&
&
(
top
=
=
"
case
"
|
|
top
=
=
"
default
"
|
|
top
=
=
"
?
"
)
)
|
|
(
ttk
=
=
"
while
"
&
&
top
=
=
"
do
"
)
;
}
function
decrementsIndent
(
tokenType
stack
)
{
return
tokenType
=
=
"
}
"
|
|
(
tokenType
=
=
"
]
"
&
&
stack
[
stack
.
length
-
1
]
=
=
"
[
\
n
"
)
;
}
function
incrementsIndent
(
token
)
{
return
token
.
type
.
label
=
=
"
{
"
|
|
token
.
isArrayLiteral
|
|
token
.
type
.
keyword
=
=
"
switch
"
;
}
function
addComment
(
write
indentLevel
options
block
text
line
column
)
{
var
indentString
=
repeat
(
options
.
indent
indentLevel
)
;
write
(
indentString
line
column
)
;
if
(
block
)
{
write
(
"
/
*
"
)
;
write
(
text
.
split
(
new
RegExp
(
"
/
\
n
"
+
indentString
+
"
/
"
"
g
"
)
)
.
join
(
"
\
n
"
+
indentString
)
)
;
write
(
"
*
/
"
)
;
}
else
{
write
(
"
/
/
"
)
;
write
(
text
)
;
}
write
(
"
\
n
"
)
;
}
return
function
prettyFast
(
input
options
)
{
var
indentLevel
=
0
;
var
result
=
new
SourceNode
(
)
;
var
write
=
(
function
(
)
{
var
buffer
=
[
]
;
var
bufferLine
=
-
1
;
var
bufferColumn
=
-
1
;
return
function
write
(
str
line
column
)
{
if
(
line
!
=
null
&
&
bufferLine
=
=
=
-
1
)
{
bufferLine
=
line
;
}
if
(
column
!
=
null
&
&
bufferColumn
=
=
=
-
1
)
{
bufferColumn
=
column
;
}
buffer
.
push
(
str
)
;
if
(
str
=
=
"
\
n
"
)
{
var
lineStr
=
"
"
;
for
(
var
i
=
0
len
=
buffer
.
length
;
i
<
len
;
i
+
+
)
{
lineStr
+
=
buffer
[
i
]
;
}
result
.
add
(
new
SourceNode
(
bufferLine
bufferColumn
options
.
url
lineStr
)
)
;
buffer
.
splice
(
0
buffer
.
length
)
;
bufferLine
=
-
1
;
bufferColumn
=
-
1
;
}
}
;
}
(
)
)
;
var
addedNewline
=
false
;
var
token
;
var
ttl
;
var
ttk
;
var
lastToken
;
var
stack
=
[
]
;
var
tokenQueue
=
[
]
;
var
tokens
=
acorn
.
tokenizer
(
input
{
locations
:
true
sourceFile
:
options
.
url
onComment
:
function
(
block
text
start
end
startLoc
endLoc
)
{
tokenQueue
.
push
(
{
type
:
{
}
comment
:
true
block
:
block
text
:
text
loc
:
{
start
:
startLoc
end
:
endLoc
}
}
)
;
}
}
)
;
for
(
;
;
)
{
token
=
tokens
.
getToken
(
)
;
tokenQueue
.
push
(
token
)
;
if
(
token
.
type
.
label
=
=
"
eof
"
)
{
break
;
}
}
for
(
var
i
=
0
;
i
<
tokenQueue
.
length
;
i
+
+
)
{
token
=
tokenQueue
[
i
]
;
if
(
token
.
comment
)
{
var
commentIndentLevel
=
indentLevel
;
if
(
lastToken
&
&
(
lastToken
.
loc
.
end
.
line
=
=
token
.
loc
.
start
.
line
)
)
{
commentIndentLevel
=
0
;
write
(
"
"
)
;
}
addComment
(
write
commentIndentLevel
options
token
.
block
token
.
text
token
.
loc
.
start
.
line
token
.
loc
.
start
.
column
)
;
addedNewline
=
true
;
continue
;
}
ttk
=
token
.
type
.
keyword
;
ttl
=
token
.
type
.
label
;
if
(
ttl
=
=
"
eof
"
)
{
if
(
!
addedNewline
)
{
write
(
"
\
n
"
)
;
}
break
;
}
token
.
isArrayLiteral
=
isArrayLiteral
(
token
lastToken
)
;
if
(
belongsOnStack
(
token
)
)
{
if
(
token
.
isArrayLiteral
)
{
stack
.
push
(
"
[
\
n
"
)
;
}
else
{
stack
.
push
(
ttl
|
|
ttk
)
;
}
}
if
(
decrementsIndent
(
ttl
stack
)
)
{
indentLevel
-
-
;
if
(
ttl
=
=
"
}
"
&
&
stack
.
length
>
1
&
&
stack
[
stack
.
length
-
2
]
=
=
"
switch
"
)
{
indentLevel
-
-
;
}
}
prependWhiteSpace
(
token
lastToken
addedNewline
write
options
indentLevel
stack
)
;
addToken
(
token
write
)
;
var
nextToken
=
tokenQueue
[
i
+
1
]
;
if
(
!
nextToken
|
|
!
nextToken
.
comment
|
|
token
.
loc
.
end
.
line
!
=
nextToken
.
loc
.
start
.
line
)
{
addedNewline
=
appendNewline
(
token
write
stack
)
;
}
if
(
shouldStackPop
(
token
stack
)
)
{
stack
.
pop
(
)
;
if
(
token
=
=
"
}
"
&
&
stack
.
length
&
&
stack
[
stack
.
length
-
1
]
=
=
"
switch
"
)
{
stack
.
pop
(
)
;
}
}
if
(
incrementsIndent
(
token
)
)
{
indentLevel
+
+
;
}
if
(
!
lastToken
)
{
lastToken
=
{
loc
:
{
start
:
{
}
end
:
{
}
}
}
;
}
lastToken
.
start
=
token
.
start
;
lastToken
.
end
=
token
.
end
;
lastToken
.
loc
.
start
.
line
=
token
.
loc
.
start
.
line
;
lastToken
.
loc
.
start
.
column
=
token
.
loc
.
start
.
column
;
lastToken
.
loc
.
end
.
line
=
token
.
loc
.
end
.
line
;
lastToken
.
loc
.
end
.
column
=
token
.
loc
.
end
.
column
;
lastToken
.
type
=
token
.
type
;
lastToken
.
value
=
token
.
value
;
lastToken
.
isArrayLiteral
=
token
.
isArrayLiteral
;
}
return
result
.
toStringWithSourceMap
(
{
file
:
options
.
url
}
)
;
}
;
}
.
bind
(
this
)
)
)
;
}
)
815
:
(
function
(
module
exports
__webpack_require__
)
{
exports
.
SourceMapGenerator
=
__webpack_require__
(
816
)
.
SourceMapGenerator
;
exports
.
SourceMapConsumer
=
__webpack_require__
(
822
)
.
SourceMapConsumer
;
exports
.
SourceNode
=
__webpack_require__
(
825
)
.
SourceNode
;
}
)
816
:
(
function
(
module
exports
__webpack_require__
)
{
var
base64VLQ
=
__webpack_require__
(
817
)
;
var
util
=
__webpack_require__
(
819
)
;
var
ArraySet
=
__webpack_require__
(
820
)
.
ArraySet
;
var
MappingList
=
__webpack_require__
(
821
)
.
MappingList
;
function
SourceMapGenerator
(
aArgs
)
{
if
(
!
aArgs
)
{
aArgs
=
{
}
;
}
this
.
_file
=
util
.
getArg
(
aArgs
'
file
'
null
)
;
this
.
_sourceRoot
=
util
.
getArg
(
aArgs
'
sourceRoot
'
null
)
;
this
.
_skipValidation
=
util
.
getArg
(
aArgs
'
skipValidation
'
false
)
;
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
this
.
_mappings
=
new
MappingList
(
)
;
this
.
_sourcesContents
=
null
;
}
SourceMapGenerator
.
prototype
.
_version
=
3
;
SourceMapGenerator
.
fromSourceMap
=
function
SourceMapGenerator_fromSourceMap
(
aSourceMapConsumer
)
{
var
sourceRoot
=
aSourceMapConsumer
.
sourceRoot
;
var
generator
=
new
SourceMapGenerator
(
{
file
:
aSourceMapConsumer
.
file
sourceRoot
:
sourceRoot
}
)
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
var
newMapping
=
{
generated
:
{
line
:
mapping
.
generatedLine
column
:
mapping
.
generatedColumn
}
}
;
if
(
mapping
.
source
!
=
null
)
{
newMapping
.
source
=
mapping
.
source
;
if
(
sourceRoot
!
=
null
)
{
newMapping
.
source
=
util
.
relative
(
sourceRoot
newMapping
.
source
)
;
}
newMapping
.
original
=
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
;
if
(
mapping
.
name
!
=
null
)
{
newMapping
.
name
=
mapping
.
name
;
}
}
generator
.
addMapping
(
newMapping
)
;
}
)
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
generator
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
generator
;
}
;
SourceMapGenerator
.
prototype
.
addMapping
=
function
SourceMapGenerator_addMapping
(
aArgs
)
{
var
generated
=
util
.
getArg
(
aArgs
'
generated
'
)
;
var
original
=
util
.
getArg
(
aArgs
'
original
'
null
)
;
var
source
=
util
.
getArg
(
aArgs
'
source
'
null
)
;
var
name
=
util
.
getArg
(
aArgs
'
name
'
null
)
;
if
(
!
this
.
_skipValidation
)
{
this
.
_validateMapping
(
generated
original
source
name
)
;
}
if
(
source
!
=
null
)
{
source
=
String
(
source
)
;
if
(
!
this
.
_sources
.
has
(
source
)
)
{
this
.
_sources
.
add
(
source
)
;
}
}
if
(
name
!
=
null
)
{
name
=
String
(
name
)
;
if
(
!
this
.
_names
.
has
(
name
)
)
{
this
.
_names
.
add
(
name
)
;
}
}
this
.
_mappings
.
add
(
{
generatedLine
:
generated
.
line
generatedColumn
:
generated
.
column
originalLine
:
original
!
=
null
&
&
original
.
line
originalColumn
:
original
!
=
null
&
&
original
.
column
source
:
source
name
:
name
}
)
;
}
;
SourceMapGenerator
.
prototype
.
setSourceContent
=
function
SourceMapGenerator_setSourceContent
(
aSourceFile
aSourceContent
)
{
var
source
=
aSourceFile
;
if
(
this
.
_sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
_sourceRoot
source
)
;
}
if
(
aSourceContent
!
=
null
)
{
if
(
!
this
.
_sourcesContents
)
{
this
.
_sourcesContents
=
Object
.
create
(
null
)
;
}
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
=
aSourceContent
;
}
else
if
(
this
.
_sourcesContents
)
{
delete
this
.
_sourcesContents
[
util
.
toSetString
(
source
)
]
;
if
(
Object
.
keys
(
this
.
_sourcesContents
)
.
length
=
=
=
0
)
{
this
.
_sourcesContents
=
null
;
}
}
}
;
SourceMapGenerator
.
prototype
.
applySourceMap
=
function
SourceMapGenerator_applySourceMap
(
aSourceMapConsumer
aSourceFile
aSourceMapPath
)
{
var
sourceFile
=
aSourceFile
;
if
(
aSourceFile
=
=
null
)
{
if
(
aSourceMapConsumer
.
file
=
=
null
)
{
throw
new
Error
(
'
SourceMapGenerator
.
prototype
.
applySourceMap
requires
either
an
explicit
source
file
'
+
'
or
the
source
map
\
'
s
"
file
"
property
.
Both
were
omitted
.
'
)
;
}
sourceFile
=
aSourceMapConsumer
.
file
;
}
var
sourceRoot
=
this
.
_sourceRoot
;
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
var
newSources
=
new
ArraySet
(
)
;
var
newNames
=
new
ArraySet
(
)
;
this
.
_mappings
.
unsortedForEach
(
function
(
mapping
)
{
if
(
mapping
.
source
=
=
=
sourceFile
&
&
mapping
.
originalLine
!
=
null
)
{
var
original
=
aSourceMapConsumer
.
originalPositionFor
(
{
line
:
mapping
.
originalLine
column
:
mapping
.
originalColumn
}
)
;
if
(
original
.
source
!
=
null
)
{
mapping
.
source
=
original
.
source
;
if
(
aSourceMapPath
!
=
null
)
{
mapping
.
source
=
util
.
join
(
aSourceMapPath
mapping
.
source
)
}
if
(
sourceRoot
!
=
null
)
{
mapping
.
source
=
util
.
relative
(
sourceRoot
mapping
.
source
)
;
}
mapping
.
originalLine
=
original
.
line
;
mapping
.
originalColumn
=
original
.
column
;
if
(
original
.
name
!
=
null
)
{
mapping
.
name
=
original
.
name
;
}
}
}
var
source
=
mapping
.
source
;
if
(
source
!
=
null
&
&
!
newSources
.
has
(
source
)
)
{
newSources
.
add
(
source
)
;
}
var
name
=
mapping
.
name
;
if
(
name
!
=
null
&
&
!
newNames
.
has
(
name
)
)
{
newNames
.
add
(
name
)
;
}
}
this
)
;
this
.
_sources
=
newSources
;
this
.
_names
=
newNames
;
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aSourceMapPath
!
=
null
)
{
sourceFile
=
util
.
join
(
aSourceMapPath
sourceFile
)
;
}
if
(
sourceRoot
!
=
null
)
{
sourceFile
=
util
.
relative
(
sourceRoot
sourceFile
)
;
}
this
.
setSourceContent
(
sourceFile
content
)
;
}
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
_validateMapping
=
function
SourceMapGenerator_validateMapping
(
aGenerated
aOriginal
aSource
aName
)
{
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
!
aOriginal
&
&
!
aSource
&
&
!
aName
)
{
return
;
}
else
if
(
aGenerated
&
&
'
line
'
in
aGenerated
&
&
'
column
'
in
aGenerated
&
&
aOriginal
&
&
'
line
'
in
aOriginal
&
&
'
column
'
in
aOriginal
&
&
aGenerated
.
line
>
0
&
&
aGenerated
.
column
>
=
0
&
&
aOriginal
.
line
>
0
&
&
aOriginal
.
column
>
=
0
&
&
aSource
)
{
return
;
}
else
{
throw
new
Error
(
'
Invalid
mapping
:
'
+
JSON
.
stringify
(
{
generated
:
aGenerated
source
:
aSource
original
:
aOriginal
name
:
aName
}
)
)
;
}
}
;
SourceMapGenerator
.
prototype
.
_serializeMappings
=
function
SourceMapGenerator_serializeMappings
(
)
{
var
previousGeneratedColumn
=
0
;
var
previousGeneratedLine
=
1
;
var
previousOriginalColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousName
=
0
;
var
previousSource
=
0
;
var
result
=
'
'
;
var
next
;
var
mapping
;
var
nameIdx
;
var
sourceIdx
;
var
mappings
=
this
.
_mappings
.
toArray
(
)
;
for
(
var
i
=
0
len
=
mappings
.
length
;
i
<
len
;
i
+
+
)
{
mapping
=
mappings
[
i
]
;
next
=
'
'
if
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
previousGeneratedColumn
=
0
;
while
(
mapping
.
generatedLine
!
=
=
previousGeneratedLine
)
{
next
+
=
'
;
'
;
previousGeneratedLine
+
+
;
}
}
else
{
if
(
i
>
0
)
{
if
(
!
util
.
compareByGeneratedPositionsInflated
(
mapping
mappings
[
i
-
1
]
)
)
{
continue
;
}
next
+
=
'
'
;
}
}
next
+
=
base64VLQ
.
encode
(
mapping
.
generatedColumn
-
previousGeneratedColumn
)
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
mapping
.
source
!
=
null
)
{
sourceIdx
=
this
.
_sources
.
indexOf
(
mapping
.
source
)
;
next
+
=
base64VLQ
.
encode
(
sourceIdx
-
previousSource
)
;
previousSource
=
sourceIdx
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalLine
-
1
-
previousOriginalLine
)
;
previousOriginalLine
=
mapping
.
originalLine
-
1
;
next
+
=
base64VLQ
.
encode
(
mapping
.
originalColumn
-
previousOriginalColumn
)
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
mapping
.
name
!
=
null
)
{
nameIdx
=
this
.
_names
.
indexOf
(
mapping
.
name
)
;
next
+
=
base64VLQ
.
encode
(
nameIdx
-
previousName
)
;
previousName
=
nameIdx
;
}
}
result
+
=
next
;
}
return
result
;
}
;
SourceMapGenerator
.
prototype
.
_generateSourcesContent
=
function
SourceMapGenerator_generateSourcesContent
(
aSources
aSourceRoot
)
{
return
aSources
.
map
(
function
(
source
)
{
if
(
!
this
.
_sourcesContents
)
{
return
null
;
}
if
(
aSourceRoot
!
=
null
)
{
source
=
util
.
relative
(
aSourceRoot
source
)
;
}
var
key
=
util
.
toSetString
(
source
)
;
return
Object
.
prototype
.
hasOwnProperty
.
call
(
this
.
_sourcesContents
key
)
?
this
.
_sourcesContents
[
key
]
:
null
;
}
this
)
;
}
;
SourceMapGenerator
.
prototype
.
toJSON
=
function
SourceMapGenerator_toJSON
(
)
{
var
map
=
{
version
:
this
.
_version
sources
:
this
.
_sources
.
toArray
(
)
names
:
this
.
_names
.
toArray
(
)
mappings
:
this
.
_serializeMappings
(
)
}
;
if
(
this
.
_file
!
=
null
)
{
map
.
file
=
this
.
_file
;
}
if
(
this
.
_sourceRoot
!
=
null
)
{
map
.
sourceRoot
=
this
.
_sourceRoot
;
}
if
(
this
.
_sourcesContents
)
{
map
.
sourcesContent
=
this
.
_generateSourcesContent
(
map
.
sources
map
.
sourceRoot
)
;
}
return
map
;
}
;
SourceMapGenerator
.
prototype
.
toString
=
function
SourceMapGenerator_toString
(
)
{
return
JSON
.
stringify
(
this
.
toJSON
(
)
)
;
}
;
exports
.
SourceMapGenerator
=
SourceMapGenerator
;
}
)
817
:
(
function
(
module
exports
__webpack_require__
)
{
var
base64
=
__webpack_require__
(
818
)
;
var
VLQ_BASE_SHIFT
=
5
;
var
VLQ_BASE
=
1
<
<
VLQ_BASE_SHIFT
;
var
VLQ_BASE_MASK
=
VLQ_BASE
-
1
;
var
VLQ_CONTINUATION_BIT
=
VLQ_BASE
;
function
toVLQSigned
(
aValue
)
{
return
aValue
<
0
?
(
(
-
aValue
)
<
<
1
)
+
1
:
(
aValue
<
<
1
)
+
0
;
}
function
fromVLQSigned
(
aValue
)
{
var
isNegative
=
(
aValue
&
1
)
=
=
=
1
;
var
shifted
=
aValue
>
>
1
;
return
isNegative
?
-
shifted
:
shifted
;
}
exports
.
encode
=
function
base64VLQ_encode
(
aValue
)
{
var
encoded
=
"
"
;
var
digit
;
var
vlq
=
toVLQSigned
(
aValue
)
;
do
{
digit
=
vlq
&
VLQ_BASE_MASK
;
vlq
>
>
>
=
VLQ_BASE_SHIFT
;
if
(
vlq
>
0
)
{
digit
|
=
VLQ_CONTINUATION_BIT
;
}
encoded
+
=
base64
.
encode
(
digit
)
;
}
while
(
vlq
>
0
)
;
return
encoded
;
}
;
exports
.
decode
=
function
base64VLQ_decode
(
aStr
aIndex
aOutParam
)
{
var
strLen
=
aStr
.
length
;
var
result
=
0
;
var
shift
=
0
;
var
continuation
digit
;
do
{
if
(
aIndex
>
=
strLen
)
{
throw
new
Error
(
"
Expected
more
digits
in
base
64
VLQ
value
.
"
)
;
}
digit
=
base64
.
decode
(
aStr
.
charCodeAt
(
aIndex
+
+
)
)
;
if
(
digit
=
=
=
-
1
)
{
throw
new
Error
(
"
Invalid
base64
digit
:
"
+
aStr
.
charAt
(
aIndex
-
1
)
)
;
}
continuation
=
!
!
(
digit
&
VLQ_CONTINUATION_BIT
)
;
digit
&
=
VLQ_BASE_MASK
;
result
=
result
+
(
digit
<
<
shift
)
;
shift
+
=
VLQ_BASE_SHIFT
;
}
while
(
continuation
)
;
aOutParam
.
value
=
fromVLQSigned
(
result
)
;
aOutParam
.
rest
=
aIndex
;
}
;
}
)
818
:
(
function
(
module
exports
)
{
var
intToCharMap
=
'
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
+
/
'
.
split
(
'
'
)
;
exports
.
encode
=
function
(
number
)
{
if
(
0
<
=
number
&
&
number
<
intToCharMap
.
length
)
{
return
intToCharMap
[
number
]
;
}
throw
new
TypeError
(
"
Must
be
between
0
and
63
:
"
+
number
)
;
}
;
exports
.
decode
=
function
(
charCode
)
{
var
bigA
=
65
;
var
bigZ
=
90
;
var
littleA
=
97
;
var
littleZ
=
122
;
var
zero
=
48
;
var
nine
=
57
;
var
plus
=
43
;
var
slash
=
47
;
var
littleOffset
=
26
;
var
numberOffset
=
52
;
if
(
bigA
<
=
charCode
&
&
charCode
<
=
bigZ
)
{
return
(
charCode
-
bigA
)
;
}
if
(
littleA
<
=
charCode
&
&
charCode
<
=
littleZ
)
{
return
(
charCode
-
littleA
+
littleOffset
)
;
}
if
(
zero
<
=
charCode
&
&
charCode
<
=
nine
)
{
return
(
charCode
-
zero
+
numberOffset
)
;
}
if
(
charCode
=
=
plus
)
{
return
62
;
}
if
(
charCode
=
=
slash
)
{
return
63
;
}
return
-
1
;
}
;
}
)
819
:
(
function
(
module
exports
)
{
function
getArg
(
aArgs
aName
aDefaultValue
)
{
if
(
aName
in
aArgs
)
{
return
aArgs
[
aName
]
;
}
else
if
(
arguments
.
length
=
=
=
3
)
{
return
aDefaultValue
;
}
else
{
throw
new
Error
(
'
"
'
+
aName
+
'
"
is
a
required
argument
.
'
)
;
}
}
exports
.
getArg
=
getArg
;
var
urlRegexp
=
/
^
(
?
:
(
[
\
w
+
\
-
.
]
+
)
:
)
?
\
/
\
/
(
?
:
(
\
w
+
:
\
w
+
)
)
?
(
[
\
w
.
]
*
)
(
?
:
:
(
\
d
+
)
)
?
(
\
S
*
)
/
;
var
dataUrlRegexp
=
/
^
data
:
.
+
\
.
+
/
;
function
urlParse
(
aUrl
)
{
var
match
=
aUrl
.
match
(
urlRegexp
)
;
if
(
!
match
)
{
return
null
;
}
return
{
scheme
:
match
[
1
]
auth
:
match
[
2
]
host
:
match
[
3
]
port
:
match
[
4
]
path
:
match
[
5
]
}
;
}
exports
.
urlParse
=
urlParse
;
function
urlGenerate
(
aParsedUrl
)
{
var
url
=
'
'
;
if
(
aParsedUrl
.
scheme
)
{
url
+
=
aParsedUrl
.
scheme
+
'
:
'
;
}
url
+
=
'
/
/
'
;
if
(
aParsedUrl
.
auth
)
{
url
+
=
aParsedUrl
.
auth
+
'
'
;
}
if
(
aParsedUrl
.
host
)
{
url
+
=
aParsedUrl
.
host
;
}
if
(
aParsedUrl
.
port
)
{
url
+
=
"
:
"
+
aParsedUrl
.
port
}
if
(
aParsedUrl
.
path
)
{
url
+
=
aParsedUrl
.
path
;
}
return
url
;
}
exports
.
urlGenerate
=
urlGenerate
;
function
normalize
(
aPath
)
{
var
path
=
aPath
;
var
url
=
urlParse
(
aPath
)
;
if
(
url
)
{
if
(
!
url
.
path
)
{
return
aPath
;
}
path
=
url
.
path
;
}
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
;
var
parts
=
path
.
split
(
/
\
/
+
/
)
;
for
(
var
part
up
=
0
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
part
=
parts
[
i
]
;
if
(
part
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
part
=
=
=
'
.
.
'
)
{
up
+
+
;
}
else
if
(
up
>
0
)
{
if
(
part
=
=
=
'
'
)
{
parts
.
splice
(
i
+
1
up
)
;
up
=
0
;
}
else
{
parts
.
splice
(
i
2
)
;
up
-
-
;
}
}
}
path
=
parts
.
join
(
'
/
'
)
;
if
(
path
=
=
=
'
'
)
{
path
=
isAbsolute
?
'
/
'
:
'
.
'
;
}
if
(
url
)
{
url
.
path
=
path
;
return
urlGenerate
(
url
)
;
}
return
path
;
}
exports
.
normalize
=
normalize
;
function
join
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
if
(
aPath
=
=
=
"
"
)
{
aPath
=
"
.
"
;
}
var
aPathUrl
=
urlParse
(
aPath
)
;
var
aRootUrl
=
urlParse
(
aRoot
)
;
if
(
aRootUrl
)
{
aRoot
=
aRootUrl
.
path
|
|
'
/
'
;
}
if
(
aPathUrl
&
&
!
aPathUrl
.
scheme
)
{
if
(
aRootUrl
)
{
aPathUrl
.
scheme
=
aRootUrl
.
scheme
;
}
return
urlGenerate
(
aPathUrl
)
;
}
if
(
aPathUrl
|
|
aPath
.
match
(
dataUrlRegexp
)
)
{
return
aPath
;
}
if
(
aRootUrl
&
&
!
aRootUrl
.
host
&
&
!
aRootUrl
.
path
)
{
aRootUrl
.
host
=
aPath
;
return
urlGenerate
(
aRootUrl
)
;
}
var
joined
=
aPath
.
charAt
(
0
)
=
=
=
'
/
'
?
aPath
:
normalize
(
aRoot
.
replace
(
/
\
/
+
/
'
'
)
+
'
/
'
+
aPath
)
;
if
(
aRootUrl
)
{
aRootUrl
.
path
=
joined
;
return
urlGenerate
(
aRootUrl
)
;
}
return
joined
;
}
exports
.
join
=
join
;
exports
.
isAbsolute
=
function
(
aPath
)
{
return
aPath
.
charAt
(
0
)
=
=
=
'
/
'
|
|
!
!
aPath
.
match
(
urlRegexp
)
;
}
;
function
relative
(
aRoot
aPath
)
{
if
(
aRoot
=
=
=
"
"
)
{
aRoot
=
"
.
"
;
}
aRoot
=
aRoot
.
replace
(
/
\
/
/
'
'
)
;
var
level
=
0
;
while
(
aPath
.
indexOf
(
aRoot
+
'
/
'
)
!
=
=
0
)
{
var
index
=
aRoot
.
lastIndexOf
(
"
/
"
)
;
if
(
index
<
0
)
{
return
aPath
;
}
aRoot
=
aRoot
.
slice
(
0
index
)
;
if
(
aRoot
.
match
(
/
^
(
[
^
\
/
]
+
:
\
/
)
?
\
/
*
/
)
)
{
return
aPath
;
}
+
+
level
;
}
return
Array
(
level
+
1
)
.
join
(
"
.
.
/
"
)
+
aPath
.
substr
(
aRoot
.
length
+
1
)
;
}
exports
.
relative
=
relative
;
var
supportsNullProto
=
(
function
(
)
{
var
obj
=
Object
.
create
(
null
)
;
return
!
(
'
__proto__
'
in
obj
)
;
}
(
)
)
;
function
identity
(
s
)
{
return
s
;
}
function
toSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
'
'
+
aStr
;
}
return
aStr
;
}
exports
.
toSetString
=
supportsNullProto
?
identity
:
toSetString
;
function
fromSetString
(
aStr
)
{
if
(
isProtoString
(
aStr
)
)
{
return
aStr
.
slice
(
1
)
;
}
return
aStr
;
}
exports
.
fromSetString
=
supportsNullProto
?
identity
:
fromSetString
;
function
isProtoString
(
s
)
{
if
(
!
s
)
{
return
false
;
}
var
length
=
s
.
length
;
if
(
length
<
9
)
{
return
false
;
}
if
(
s
.
charCodeAt
(
length
-
1
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
2
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
3
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
4
)
!
=
=
116
|
|
s
.
charCodeAt
(
length
-
5
)
!
=
=
111
|
|
s
.
charCodeAt
(
length
-
6
)
!
=
=
114
|
|
s
.
charCodeAt
(
length
-
7
)
!
=
=
112
|
|
s
.
charCodeAt
(
length
-
8
)
!
=
=
95
|
|
s
.
charCodeAt
(
length
-
9
)
!
=
=
95
)
{
return
false
;
}
for
(
var
i
=
length
-
10
;
i
>
=
0
;
i
-
-
)
{
if
(
s
.
charCodeAt
(
i
)
!
=
=
36
)
{
return
false
;
}
}
return
true
;
}
function
compareByOriginalPositions
(
mappingA
mappingB
onlyCompareOriginal
)
{
var
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareOriginal
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByOriginalPositions
=
compareByOriginalPositions
;
function
compareByGeneratedPositionsDeflated
(
mappingA
mappingB
onlyCompareGenerated
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
|
|
onlyCompareGenerated
)
{
return
cmp
;
}
cmp
=
mappingA
.
source
-
mappingB
.
source
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
mappingA
.
name
-
mappingB
.
name
;
}
exports
.
compareByGeneratedPositionsDeflated
=
compareByGeneratedPositionsDeflated
;
function
strcmp
(
aStr1
aStr2
)
{
if
(
aStr1
=
=
=
aStr2
)
{
return
0
;
}
if
(
aStr1
>
aStr2
)
{
return
1
;
}
return
-
1
;
}
function
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
{
var
cmp
=
mappingA
.
generatedLine
-
mappingB
.
generatedLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
generatedColumn
-
mappingB
.
generatedColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
strcmp
(
mappingA
.
source
mappingB
.
source
)
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalLine
-
mappingB
.
originalLine
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
cmp
=
mappingA
.
originalColumn
-
mappingB
.
originalColumn
;
if
(
cmp
!
=
=
0
)
{
return
cmp
;
}
return
strcmp
(
mappingA
.
name
mappingB
.
name
)
;
}
exports
.
compareByGeneratedPositionsInflated
=
compareByGeneratedPositionsInflated
;
}
)
820
:
(
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
819
)
;
var
has
=
Object
.
prototype
.
hasOwnProperty
;
function
ArraySet
(
)
{
this
.
_array
=
[
]
;
this
.
_set
=
Object
.
create
(
null
)
;
}
ArraySet
.
fromArray
=
function
ArraySet_fromArray
(
aArray
aAllowDuplicates
)
{
var
set
=
new
ArraySet
(
)
;
for
(
var
i
=
0
len
=
aArray
.
length
;
i
<
len
;
i
+
+
)
{
set
.
add
(
aArray
[
i
]
aAllowDuplicates
)
;
}
return
set
;
}
;
ArraySet
.
prototype
.
size
=
function
ArraySet_size
(
)
{
return
Object
.
getOwnPropertyNames
(
this
.
_set
)
.
length
;
}
;
ArraySet
.
prototype
.
add
=
function
ArraySet_add
(
aStr
aAllowDuplicates
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
var
isDuplicate
=
has
.
call
(
this
.
_set
sStr
)
;
var
idx
=
this
.
_array
.
length
;
if
(
!
isDuplicate
|
|
aAllowDuplicates
)
{
this
.
_array
.
push
(
aStr
)
;
}
if
(
!
isDuplicate
)
{
this
.
_set
[
sStr
]
=
idx
;
}
}
;
ArraySet
.
prototype
.
has
=
function
ArraySet_has
(
aStr
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
return
has
.
call
(
this
.
_set
sStr
)
;
}
;
ArraySet
.
prototype
.
indexOf
=
function
ArraySet_indexOf
(
aStr
)
{
var
sStr
=
util
.
toSetString
(
aStr
)
;
if
(
has
.
call
(
this
.
_set
sStr
)
)
{
return
this
.
_set
[
sStr
]
;
}
throw
new
Error
(
'
"
'
+
aStr
+
'
"
is
not
in
the
set
.
'
)
;
}
;
ArraySet
.
prototype
.
at
=
function
ArraySet_at
(
aIdx
)
{
if
(
aIdx
>
=
0
&
&
aIdx
<
this
.
_array
.
length
)
{
return
this
.
_array
[
aIdx
]
;
}
throw
new
Error
(
'
No
element
indexed
by
'
+
aIdx
)
;
}
;
ArraySet
.
prototype
.
toArray
=
function
ArraySet_toArray
(
)
{
return
this
.
_array
.
slice
(
)
;
}
;
exports
.
ArraySet
=
ArraySet
;
}
)
821
:
(
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
819
)
;
function
generatedPositionAfter
(
mappingA
mappingB
)
{
var
lineA
=
mappingA
.
generatedLine
;
var
lineB
=
mappingB
.
generatedLine
;
var
columnA
=
mappingA
.
generatedColumn
;
var
columnB
=
mappingB
.
generatedColumn
;
return
lineB
>
lineA
|
|
lineB
=
=
lineA
&
&
columnB
>
=
columnA
|
|
util
.
compareByGeneratedPositionsInflated
(
mappingA
mappingB
)
<
=
0
;
}
function
MappingList
(
)
{
this
.
_array
=
[
]
;
this
.
_sorted
=
true
;
this
.
_last
=
{
generatedLine
:
-
1
generatedColumn
:
0
}
;
}
MappingList
.
prototype
.
unsortedForEach
=
function
MappingList_forEach
(
aCallback
aThisArg
)
{
this
.
_array
.
forEach
(
aCallback
aThisArg
)
;
}
;
MappingList
.
prototype
.
add
=
function
MappingList_add
(
aMapping
)
{
if
(
generatedPositionAfter
(
this
.
_last
aMapping
)
)
{
this
.
_last
=
aMapping
;
this
.
_array
.
push
(
aMapping
)
;
}
else
{
this
.
_sorted
=
false
;
this
.
_array
.
push
(
aMapping
)
;
}
}
;
MappingList
.
prototype
.
toArray
=
function
MappingList_toArray
(
)
{
if
(
!
this
.
_sorted
)
{
this
.
_array
.
sort
(
util
.
compareByGeneratedPositionsInflated
)
;
this
.
_sorted
=
true
;
}
return
this
.
_array
;
}
;
exports
.
MappingList
=
MappingList
;
}
)
822
:
(
function
(
module
exports
__webpack_require__
)
{
var
util
=
__webpack_require__
(
819
)
;
var
binarySearch
=
__webpack_require__
(
823
)
;
var
ArraySet
=
__webpack_require__
(
820
)
.
ArraySet
;
var
base64VLQ
=
__webpack_require__
(
817
)
;
var
quickSort
=
__webpack_require__
(
824
)
.
quickSort
;
function
SourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
return
sourceMap
.
sections
!
=
null
?
new
IndexedSourceMapConsumer
(
sourceMap
)
:
new
BasicSourceMapConsumer
(
sourceMap
)
;
}
SourceMapConsumer
.
fromSourceMap
=
function
(
aSourceMap
)
{
return
BasicSourceMapConsumer
.
fromSourceMap
(
aSourceMap
)
;
}
SourceMapConsumer
.
prototype
.
_version
=
3
;
SourceMapConsumer
.
prototype
.
__generatedMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_generatedMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__generatedMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__generatedMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
__originalMappings
=
null
;
Object
.
defineProperty
(
SourceMapConsumer
.
prototype
'
_originalMappings
'
{
get
:
function
(
)
{
if
(
!
this
.
__originalMappings
)
{
this
.
_parseMappings
(
this
.
_mappings
this
.
sourceRoot
)
;
}
return
this
.
__originalMappings
;
}
}
)
;
SourceMapConsumer
.
prototype
.
_charIsMappingSeparator
=
function
SourceMapConsumer_charIsMappingSeparator
(
aStr
index
)
{
var
c
=
aStr
.
charAt
(
index
)
;
return
c
=
=
=
"
;
"
|
|
c
=
=
=
"
"
;
}
;
SourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
throw
new
Error
(
"
Subclasses
must
implement
_parseMappings
"
)
;
}
;
SourceMapConsumer
.
GENERATED_ORDER
=
1
;
SourceMapConsumer
.
ORIGINAL_ORDER
=
2
;
SourceMapConsumer
.
GREATEST_LOWER_BOUND
=
1
;
SourceMapConsumer
.
LEAST_UPPER_BOUND
=
2
;
SourceMapConsumer
.
prototype
.
eachMapping
=
function
SourceMapConsumer_eachMapping
(
aCallback
aContext
aOrder
)
{
var
context
=
aContext
|
|
null
;
var
order
=
aOrder
|
|
SourceMapConsumer
.
GENERATED_ORDER
;
var
mappings
;
switch
(
order
)
{
case
SourceMapConsumer
.
GENERATED_ORDER
:
mappings
=
this
.
_generatedMappings
;
break
;
case
SourceMapConsumer
.
ORIGINAL_ORDER
:
mappings
=
this
.
_originalMappings
;
break
;
default
:
throw
new
Error
(
"
Unknown
order
of
iteration
.
"
)
;
}
var
sourceRoot
=
this
.
sourceRoot
;
mappings
.
map
(
function
(
mapping
)
{
var
source
=
mapping
.
source
=
=
=
null
?
null
:
this
.
_sources
.
at
(
mapping
.
source
)
;
if
(
source
!
=
null
&
&
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
sourceRoot
source
)
;
}
return
{
source
:
source
generatedLine
:
mapping
.
generatedLine
generatedColumn
:
mapping
.
generatedColumn
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
mapping
.
name
=
=
=
null
?
null
:
this
.
_names
.
at
(
mapping
.
name
)
}
;
}
this
)
.
forEach
(
aCallback
context
)
;
}
;
SourceMapConsumer
.
prototype
.
allGeneratedPositionsFor
=
function
SourceMapConsumer_allGeneratedPositionsFor
(
aArgs
)
{
var
line
=
util
.
getArg
(
aArgs
'
line
'
)
;
var
needle
=
{
source
:
util
.
getArg
(
aArgs
'
source
'
)
originalLine
:
line
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
0
)
}
;
if
(
this
.
sourceRoot
!
=
null
)
{
needle
.
source
=
util
.
relative
(
this
.
sourceRoot
needle
.
source
)
;
}
if
(
!
this
.
_sources
.
has
(
needle
.
source
)
)
{
return
[
]
;
}
needle
.
source
=
this
.
_sources
.
indexOf
(
needle
.
source
)
;
var
mappings
=
[
]
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
binarySearch
.
LEAST_UPPER_BOUND
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
aArgs
.
column
=
=
=
undefined
)
{
var
originalLine
=
mapping
.
originalLine
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
originalLine
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
else
{
var
originalColumn
=
mapping
.
originalColumn
;
while
(
mapping
&
&
mapping
.
originalLine
=
=
=
line
&
&
mapping
.
originalColumn
=
=
originalColumn
)
{
mappings
.
push
(
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
)
;
mapping
=
this
.
_originalMappings
[
+
+
index
]
;
}
}
}
return
mappings
;
}
;
exports
.
SourceMapConsumer
=
SourceMapConsumer
;
function
BasicSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sources
=
util
.
getArg
(
sourceMap
'
sources
'
)
;
var
names
=
util
.
getArg
(
sourceMap
'
names
'
[
]
)
;
var
sourceRoot
=
util
.
getArg
(
sourceMap
'
sourceRoot
'
null
)
;
var
sourcesContent
=
util
.
getArg
(
sourceMap
'
sourcesContent
'
null
)
;
var
mappings
=
util
.
getArg
(
sourceMap
'
mappings
'
)
;
var
file
=
util
.
getArg
(
sourceMap
'
file
'
null
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
sources
=
sources
.
map
(
String
)
.
map
(
util
.
normalize
)
.
map
(
function
(
source
)
{
return
sourceRoot
&
&
util
.
isAbsolute
(
sourceRoot
)
&
&
util
.
isAbsolute
(
source
)
?
util
.
relative
(
sourceRoot
source
)
:
source
;
}
)
;
this
.
_names
=
ArraySet
.
fromArray
(
names
.
map
(
String
)
true
)
;
this
.
_sources
=
ArraySet
.
fromArray
(
sources
true
)
;
this
.
sourceRoot
=
sourceRoot
;
this
.
sourcesContent
=
sourcesContent
;
this
.
_mappings
=
mappings
;
this
.
file
=
file
;
}
BasicSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
BasicSourceMapConsumer
.
prototype
.
consumer
=
SourceMapConsumer
;
BasicSourceMapConsumer
.
fromSourceMap
=
function
SourceMapConsumer_fromSourceMap
(
aSourceMap
)
{
var
smc
=
Object
.
create
(
BasicSourceMapConsumer
.
prototype
)
;
var
names
=
smc
.
_names
=
ArraySet
.
fromArray
(
aSourceMap
.
_names
.
toArray
(
)
true
)
;
var
sources
=
smc
.
_sources
=
ArraySet
.
fromArray
(
aSourceMap
.
_sources
.
toArray
(
)
true
)
;
smc
.
sourceRoot
=
aSourceMap
.
_sourceRoot
;
smc
.
sourcesContent
=
aSourceMap
.
_generateSourcesContent
(
smc
.
_sources
.
toArray
(
)
smc
.
sourceRoot
)
;
smc
.
file
=
aSourceMap
.
_file
;
var
generatedMappings
=
aSourceMap
.
_mappings
.
toArray
(
)
.
slice
(
)
;
var
destGeneratedMappings
=
smc
.
__generatedMappings
=
[
]
;
var
destOriginalMappings
=
smc
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
length
=
generatedMappings
.
length
;
i
<
length
;
i
+
+
)
{
var
srcMapping
=
generatedMappings
[
i
]
;
var
destMapping
=
new
Mapping
;
destMapping
.
generatedLine
=
srcMapping
.
generatedLine
;
destMapping
.
generatedColumn
=
srcMapping
.
generatedColumn
;
if
(
srcMapping
.
source
)
{
destMapping
.
source
=
sources
.
indexOf
(
srcMapping
.
source
)
;
destMapping
.
originalLine
=
srcMapping
.
originalLine
;
destMapping
.
originalColumn
=
srcMapping
.
originalColumn
;
if
(
srcMapping
.
name
)
{
destMapping
.
name
=
names
.
indexOf
(
srcMapping
.
name
)
;
}
destOriginalMappings
.
push
(
destMapping
)
;
}
destGeneratedMappings
.
push
(
destMapping
)
;
}
quickSort
(
smc
.
__originalMappings
util
.
compareByOriginalPositions
)
;
return
smc
;
}
;
BasicSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
BasicSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
return
this
.
_sources
.
toArray
(
)
.
map
(
function
(
s
)
{
return
this
.
sourceRoot
!
=
null
?
util
.
join
(
this
.
sourceRoot
s
)
:
s
;
}
this
)
;
}
}
)
;
function
Mapping
(
)
{
this
.
generatedLine
=
0
;
this
.
generatedColumn
=
0
;
this
.
source
=
null
;
this
.
originalLine
=
null
;
this
.
originalColumn
=
null
;
this
.
name
=
null
;
}
BasicSourceMapConsumer
.
prototype
.
_parseMappings
=
function
SourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
var
generatedLine
=
1
;
var
previousGeneratedColumn
=
0
;
var
previousOriginalLine
=
0
;
var
previousOriginalColumn
=
0
;
var
previousSource
=
0
;
var
previousName
=
0
;
var
length
=
aStr
.
length
;
var
index
=
0
;
var
cachedSegments
=
{
}
;
var
temp
=
{
}
;
var
originalMappings
=
[
]
;
var
generatedMappings
=
[
]
;
var
mapping
str
segment
end
value
;
while
(
index
<
length
)
{
if
(
aStr
.
charAt
(
index
)
=
=
=
'
;
'
)
{
generatedLine
+
+
;
index
+
+
;
previousGeneratedColumn
=
0
;
}
else
if
(
aStr
.
charAt
(
index
)
=
=
=
'
'
)
{
index
+
+
;
}
else
{
mapping
=
new
Mapping
(
)
;
mapping
.
generatedLine
=
generatedLine
;
for
(
end
=
index
;
end
<
length
;
end
+
+
)
{
if
(
this
.
_charIsMappingSeparator
(
aStr
end
)
)
{
break
;
}
}
str
=
aStr
.
slice
(
index
end
)
;
segment
=
cachedSegments
[
str
]
;
if
(
segment
)
{
index
+
=
str
.
length
;
}
else
{
segment
=
[
]
;
while
(
index
<
end
)
{
base64VLQ
.
decode
(
aStr
index
temp
)
;
value
=
temp
.
value
;
index
=
temp
.
rest
;
segment
.
push
(
value
)
;
}
if
(
segment
.
length
=
=
=
2
)
{
throw
new
Error
(
'
Found
a
source
but
no
line
and
column
'
)
;
}
if
(
segment
.
length
=
=
=
3
)
{
throw
new
Error
(
'
Found
a
source
and
line
but
no
column
'
)
;
}
cachedSegments
[
str
]
=
segment
;
}
mapping
.
generatedColumn
=
previousGeneratedColumn
+
segment
[
0
]
;
previousGeneratedColumn
=
mapping
.
generatedColumn
;
if
(
segment
.
length
>
1
)
{
mapping
.
source
=
previousSource
+
segment
[
1
]
;
previousSource
+
=
segment
[
1
]
;
mapping
.
originalLine
=
previousOriginalLine
+
segment
[
2
]
;
previousOriginalLine
=
mapping
.
originalLine
;
mapping
.
originalLine
+
=
1
;
mapping
.
originalColumn
=
previousOriginalColumn
+
segment
[
3
]
;
previousOriginalColumn
=
mapping
.
originalColumn
;
if
(
segment
.
length
>
4
)
{
mapping
.
name
=
previousName
+
segment
[
4
]
;
previousName
+
=
segment
[
4
]
;
}
}
generatedMappings
.
push
(
mapping
)
;
if
(
typeof
mapping
.
originalLine
=
=
=
'
number
'
)
{
originalMappings
.
push
(
mapping
)
;
}
}
}
quickSort
(
generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
this
.
__generatedMappings
=
generatedMappings
;
quickSort
(
originalMappings
util
.
compareByOriginalPositions
)
;
this
.
__originalMappings
=
originalMappings
;
}
;
BasicSourceMapConsumer
.
prototype
.
_findMapping
=
function
SourceMapConsumer_findMapping
(
aNeedle
aMappings
aLineName
aColumnName
aComparator
aBias
)
{
if
(
aNeedle
[
aLineName
]
<
=
0
)
{
throw
new
TypeError
(
'
Line
must
be
greater
than
or
equal
to
1
got
'
+
aNeedle
[
aLineName
]
)
;
}
if
(
aNeedle
[
aColumnName
]
<
0
)
{
throw
new
TypeError
(
'
Column
must
be
greater
than
or
equal
to
0
got
'
+
aNeedle
[
aColumnName
]
)
;
}
return
binarySearch
.
search
(
aNeedle
aMappings
aComparator
aBias
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
computeColumnSpans
=
function
SourceMapConsumer_computeColumnSpans
(
)
{
for
(
var
index
=
0
;
index
<
this
.
_generatedMappings
.
length
;
+
+
index
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
index
+
1
<
this
.
_generatedMappings
.
length
)
{
var
nextMapping
=
this
.
_generatedMappings
[
index
+
1
]
;
if
(
mapping
.
generatedLine
=
=
=
nextMapping
.
generatedLine
)
{
mapping
.
lastGeneratedColumn
=
nextMapping
.
generatedColumn
-
1
;
continue
;
}
}
mapping
.
lastGeneratedColumn
=
Infinity
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
SourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_generatedMappings
"
generatedLine
"
"
generatedColumn
"
util
.
compareByGeneratedPositionsDeflated
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_generatedMappings
[
index
]
;
if
(
mapping
.
generatedLine
=
=
=
needle
.
generatedLine
)
{
var
source
=
util
.
getArg
(
mapping
'
source
'
null
)
;
if
(
source
!
=
=
null
)
{
source
=
this
.
_sources
.
at
(
source
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
join
(
this
.
sourceRoot
source
)
;
}
}
var
name
=
util
.
getArg
(
mapping
'
name
'
null
)
;
if
(
name
!
=
=
null
)
{
name
=
this
.
_names
.
at
(
name
)
;
}
return
{
source
:
source
line
:
util
.
getArg
(
mapping
'
originalLine
'
null
)
column
:
util
.
getArg
(
mapping
'
originalColumn
'
null
)
name
:
name
}
;
}
}
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
;
BasicSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
BasicSourceMapConsumer_hasContentsOfAllSources
(
)
{
if
(
!
this
.
sourcesContent
)
{
return
false
;
}
return
this
.
sourcesContent
.
length
>
=
this
.
_sources
.
size
(
)
&
&
!
this
.
sourcesContent
.
some
(
function
(
sc
)
{
return
sc
=
=
null
;
}
)
;
}
;
BasicSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
SourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
if
(
!
this
.
sourcesContent
)
{
return
null
;
}
if
(
this
.
sourceRoot
!
=
null
)
{
aSource
=
util
.
relative
(
this
.
sourceRoot
aSource
)
;
}
if
(
this
.
_sources
.
has
(
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
aSource
)
]
;
}
var
url
;
if
(
this
.
sourceRoot
!
=
null
&
&
(
url
=
util
.
urlParse
(
this
.
sourceRoot
)
)
)
{
var
fileUriAbsPath
=
aSource
.
replace
(
/
^
file
:
\
/
\
/
/
"
"
)
;
if
(
url
.
scheme
=
=
"
file
"
&
&
this
.
_sources
.
has
(
fileUriAbsPath
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
fileUriAbsPath
)
]
}
if
(
(
!
url
.
path
|
|
url
.
path
=
=
"
/
"
)
&
&
this
.
_sources
.
has
(
"
/
"
+
aSource
)
)
{
return
this
.
sourcesContent
[
this
.
_sources
.
indexOf
(
"
/
"
+
aSource
)
]
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
BasicSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
SourceMapConsumer_generatedPositionFor
(
aArgs
)
{
var
source
=
util
.
getArg
(
aArgs
'
source
'
)
;
if
(
this
.
sourceRoot
!
=
null
)
{
source
=
util
.
relative
(
this
.
sourceRoot
source
)
;
}
if
(
!
this
.
_sources
.
has
(
source
)
)
{
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
needle
=
{
source
:
source
originalLine
:
util
.
getArg
(
aArgs
'
line
'
)
originalColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
index
=
this
.
_findMapping
(
needle
this
.
_originalMappings
"
originalLine
"
"
originalColumn
"
util
.
compareByOriginalPositions
util
.
getArg
(
aArgs
'
bias
'
SourceMapConsumer
.
GREATEST_LOWER_BOUND
)
)
;
if
(
index
>
=
0
)
{
var
mapping
=
this
.
_originalMappings
[
index
]
;
if
(
mapping
.
source
=
=
=
needle
.
source
)
{
return
{
line
:
util
.
getArg
(
mapping
'
generatedLine
'
null
)
column
:
util
.
getArg
(
mapping
'
generatedColumn
'
null
)
lastColumn
:
util
.
getArg
(
mapping
'
lastGeneratedColumn
'
null
)
}
;
}
}
return
{
line
:
null
column
:
null
lastColumn
:
null
}
;
}
;
exports
.
BasicSourceMapConsumer
=
BasicSourceMapConsumer
;
function
IndexedSourceMapConsumer
(
aSourceMap
)
{
var
sourceMap
=
aSourceMap
;
if
(
typeof
aSourceMap
=
=
=
'
string
'
)
{
sourceMap
=
JSON
.
parse
(
aSourceMap
.
replace
(
/
^
\
)
\
]
\
}
'
/
'
'
)
)
;
}
var
version
=
util
.
getArg
(
sourceMap
'
version
'
)
;
var
sections
=
util
.
getArg
(
sourceMap
'
sections
'
)
;
if
(
version
!
=
this
.
_version
)
{
throw
new
Error
(
'
Unsupported
version
:
'
+
version
)
;
}
this
.
_sources
=
new
ArraySet
(
)
;
this
.
_names
=
new
ArraySet
(
)
;
var
lastOffset
=
{
line
:
-
1
column
:
0
}
;
this
.
_sections
=
sections
.
map
(
function
(
s
)
{
if
(
s
.
url
)
{
throw
new
Error
(
'
Support
for
url
field
in
sections
not
implemented
.
'
)
;
}
var
offset
=
util
.
getArg
(
s
'
offset
'
)
;
var
offsetLine
=
util
.
getArg
(
offset
'
line
'
)
;
var
offsetColumn
=
util
.
getArg
(
offset
'
column
'
)
;
if
(
offsetLine
<
lastOffset
.
line
|
|
(
offsetLine
=
=
=
lastOffset
.
line
&
&
offsetColumn
<
lastOffset
.
column
)
)
{
throw
new
Error
(
'
Section
offsets
must
be
ordered
and
non
-
overlapping
.
'
)
;
}
lastOffset
=
offset
;
return
{
generatedOffset
:
{
generatedLine
:
offsetLine
+
1
generatedColumn
:
offsetColumn
+
1
}
consumer
:
new
SourceMapConsumer
(
util
.
getArg
(
s
'
map
'
)
)
}
}
)
;
}
IndexedSourceMapConsumer
.
prototype
=
Object
.
create
(
SourceMapConsumer
.
prototype
)
;
IndexedSourceMapConsumer
.
prototype
.
constructor
=
SourceMapConsumer
;
IndexedSourceMapConsumer
.
prototype
.
_version
=
3
;
Object
.
defineProperty
(
IndexedSourceMapConsumer
.
prototype
'
sources
'
{
get
:
function
(
)
{
var
sources
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
this
.
_sections
[
i
]
.
consumer
.
sources
.
length
;
j
+
+
)
{
sources
.
push
(
this
.
_sections
[
i
]
.
consumer
.
sources
[
j
]
)
;
}
}
return
sources
;
}
}
)
;
IndexedSourceMapConsumer
.
prototype
.
originalPositionFor
=
function
IndexedSourceMapConsumer_originalPositionFor
(
aArgs
)
{
var
needle
=
{
generatedLine
:
util
.
getArg
(
aArgs
'
line
'
)
generatedColumn
:
util
.
getArg
(
aArgs
'
column
'
)
}
;
var
sectionIndex
=
binarySearch
.
search
(
needle
this
.
_sections
function
(
needle
section
)
{
var
cmp
=
needle
.
generatedLine
-
section
.
generatedOffset
.
generatedLine
;
if
(
cmp
)
{
return
cmp
;
}
return
(
needle
.
generatedColumn
-
section
.
generatedOffset
.
generatedColumn
)
;
}
)
;
var
section
=
this
.
_sections
[
sectionIndex
]
;
if
(
!
section
)
{
return
{
source
:
null
line
:
null
column
:
null
name
:
null
}
;
}
return
section
.
consumer
.
originalPositionFor
(
{
line
:
needle
.
generatedLine
-
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
needle
.
generatedColumn
-
(
section
.
generatedOffset
.
generatedLine
=
=
=
needle
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
bias
:
aArgs
.
bias
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
hasContentsOfAllSources
=
function
IndexedSourceMapConsumer_hasContentsOfAllSources
(
)
{
return
this
.
_sections
.
every
(
function
(
s
)
{
return
s
.
consumer
.
hasContentsOfAllSources
(
)
;
}
)
;
}
;
IndexedSourceMapConsumer
.
prototype
.
sourceContentFor
=
function
IndexedSourceMapConsumer_sourceContentFor
(
aSource
nullOnMissing
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
content
=
section
.
consumer
.
sourceContentFor
(
aSource
true
)
;
if
(
content
)
{
return
content
;
}
}
if
(
nullOnMissing
)
{
return
null
;
}
else
{
throw
new
Error
(
'
"
'
+
aSource
+
'
"
is
not
in
the
SourceMap
.
'
)
;
}
}
;
IndexedSourceMapConsumer
.
prototype
.
generatedPositionFor
=
function
IndexedSourceMapConsumer_generatedPositionFor
(
aArgs
)
{
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
if
(
section
.
consumer
.
sources
.
indexOf
(
util
.
getArg
(
aArgs
'
source
'
)
)
=
=
=
-
1
)
{
continue
;
}
var
generatedPosition
=
section
.
consumer
.
generatedPositionFor
(
aArgs
)
;
if
(
generatedPosition
)
{
var
ret
=
{
line
:
generatedPosition
.
line
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
column
:
generatedPosition
.
column
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
generatedPosition
.
line
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
}
;
return
ret
;
}
}
return
{
line
:
null
column
:
null
}
;
}
;
IndexedSourceMapConsumer
.
prototype
.
_parseMappings
=
function
IndexedSourceMapConsumer_parseMappings
(
aStr
aSourceRoot
)
{
this
.
__generatedMappings
=
[
]
;
this
.
__originalMappings
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
_sections
.
length
;
i
+
+
)
{
var
section
=
this
.
_sections
[
i
]
;
var
sectionMappings
=
section
.
consumer
.
_generatedMappings
;
for
(
var
j
=
0
;
j
<
sectionMappings
.
length
;
j
+
+
)
{
var
mapping
=
sectionMappings
[
j
]
;
var
source
=
section
.
consumer
.
_sources
.
at
(
mapping
.
source
)
;
if
(
section
.
consumer
.
sourceRoot
!
=
=
null
)
{
source
=
util
.
join
(
section
.
consumer
.
sourceRoot
source
)
;
}
this
.
_sources
.
add
(
source
)
;
source
=
this
.
_sources
.
indexOf
(
source
)
;
var
name
=
section
.
consumer
.
_names
.
at
(
mapping
.
name
)
;
this
.
_names
.
add
(
name
)
;
name
=
this
.
_names
.
indexOf
(
name
)
;
var
adjustedMapping
=
{
source
:
source
generatedLine
:
mapping
.
generatedLine
+
(
section
.
generatedOffset
.
generatedLine
-
1
)
generatedColumn
:
mapping
.
generatedColumn
+
(
section
.
generatedOffset
.
generatedLine
=
=
=
mapping
.
generatedLine
?
section
.
generatedOffset
.
generatedColumn
-
1
:
0
)
originalLine
:
mapping
.
originalLine
originalColumn
:
mapping
.
originalColumn
name
:
name
}
;
this
.
__generatedMappings
.
push
(
adjustedMapping
)
;
if
(
typeof
adjustedMapping
.
originalLine
=
=
=
'
number
'
)
{
this
.
__originalMappings
.
push
(
adjustedMapping
)
;
}
}
}
quickSort
(
this
.
__generatedMappings
util
.
compareByGeneratedPositionsDeflated
)
;
quickSort
(
this
.
__originalMappings
util
.
compareByOriginalPositions
)
;
}
;
exports
.
IndexedSourceMapConsumer
=
IndexedSourceMapConsumer
;
}
)
823
:
(
function
(
module
exports
)
{
exports
.
GREATEST_LOWER_BOUND
=
1
;
exports
.
LEAST_UPPER_BOUND
=
2
;
function
recursiveSearch
(
aLow
aHigh
aNeedle
aHaystack
aCompare
aBias
)
{
var
mid
=
Math
.
floor
(
(
aHigh
-
aLow
)
/
2
)
+
aLow
;
var
cmp
=
aCompare
(
aNeedle
aHaystack
[
mid
]
true
)
;
if
(
cmp
=
=
=
0
)
{
return
mid
;
}
else
if
(
cmp
>
0
)
{
if
(
aHigh
-
mid
>
1
)
{
return
recursiveSearch
(
mid
aHigh
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
aHigh
<
aHaystack
.
length
?
aHigh
:
-
1
;
}
else
{
return
mid
;
}
}
else
{
if
(
mid
-
aLow
>
1
)
{
return
recursiveSearch
(
aLow
mid
aNeedle
aHaystack
aCompare
aBias
)
;
}
if
(
aBias
=
=
exports
.
LEAST_UPPER_BOUND
)
{
return
mid
;
}
else
{
return
aLow
<
0
?
-
1
:
aLow
;
}
}
}
exports
.
search
=
function
search
(
aNeedle
aHaystack
aCompare
aBias
)
{
if
(
aHaystack
.
length
=
=
=
0
)
{
return
-
1
;
}
var
index
=
recursiveSearch
(
-
1
aHaystack
.
length
aNeedle
aHaystack
aCompare
aBias
|
|
exports
.
GREATEST_LOWER_BOUND
)
;
if
(
index
<
0
)
{
return
-
1
;
}
while
(
index
-
1
>
=
0
)
{
if
(
aCompare
(
aHaystack
[
index
]
aHaystack
[
index
-
1
]
true
)
!
=
=
0
)
{
break
;
}
-
-
index
;
}
return
index
;
}
;
}
)
824
:
(
function
(
module
exports
)
{
function
swap
(
ary
x
y
)
{
var
temp
=
ary
[
x
]
;
ary
[
x
]
=
ary
[
y
]
;
ary
[
y
]
=
temp
;
}
function
randomIntInRange
(
low
high
)
{
return
Math
.
round
(
low
+
(
Math
.
random
(
)
*
(
high
-
low
)
)
)
;
}
function
doQuickSort
(
ary
comparator
p
r
)
{
if
(
p
<
r
)
{
var
pivotIndex
=
randomIntInRange
(
p
r
)
;
var
i
=
p
-
1
;
swap
(
ary
pivotIndex
r
)
;
var
pivot
=
ary
[
r
]
;
for
(
var
j
=
p
;
j
<
r
;
j
+
+
)
{
if
(
comparator
(
ary
[
j
]
pivot
)
<
=
0
)
{
i
+
=
1
;
swap
(
ary
i
j
)
;
}
}
swap
(
ary
i
+
1
j
)
;
var
q
=
i
+
1
;
doQuickSort
(
ary
comparator
p
q
-
1
)
;
doQuickSort
(
ary
comparator
q
+
1
r
)
;
}
}
exports
.
quickSort
=
function
(
ary
comparator
)
{
doQuickSort
(
ary
comparator
0
ary
.
length
-
1
)
;
}
;
}
)
825
:
(
function
(
module
exports
__webpack_require__
)
{
var
SourceMapGenerator
=
__webpack_require__
(
816
)
.
SourceMapGenerator
;
var
util
=
__webpack_require__
(
819
)
;
var
REGEX_NEWLINE
=
/
(
\
r
?
\
n
)
/
;
var
NEWLINE_CODE
=
10
;
var
isSourceNode
=
"
isSourceNode
"
;
function
SourceNode
(
aLine
aColumn
aSource
aChunks
aName
)
{
this
.
children
=
[
]
;
this
.
sourceContents
=
{
}
;
this
.
line
=
aLine
=
=
null
?
null
:
aLine
;
this
.
column
=
aColumn
=
=
null
?
null
:
aColumn
;
this
.
source
=
aSource
=
=
null
?
null
:
aSource
;
this
.
name
=
aName
=
=
null
?
null
:
aName
;
this
[
isSourceNode
]
=
true
;
if
(
aChunks
!
=
null
)
this
.
add
(
aChunks
)
;
}
SourceNode
.
fromStringWithSourceMap
=
function
SourceNode_fromStringWithSourceMap
(
aGeneratedCode
aSourceMapConsumer
aRelativePath
)
{
var
node
=
new
SourceNode
(
)
;
var
remainingLines
=
aGeneratedCode
.
split
(
REGEX_NEWLINE
)
;
var
shiftNextLine
=
function
(
)
{
var
lineContents
=
remainingLines
.
shift
(
)
;
var
newLine
=
remainingLines
.
shift
(
)
|
|
"
"
;
return
lineContents
+
newLine
;
}
;
var
lastGeneratedLine
=
1
lastGeneratedColumn
=
0
;
var
lastMapping
=
null
;
aSourceMapConsumer
.
eachMapping
(
function
(
mapping
)
{
if
(
lastMapping
!
=
=
null
)
{
if
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
lastGeneratedColumn
=
0
;
}
else
{
var
nextLine
=
remainingLines
[
0
]
;
var
code
=
nextLine
.
substr
(
0
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
remainingLines
[
0
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
-
lastGeneratedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
addMappingWithCode
(
lastMapping
code
)
;
lastMapping
=
mapping
;
return
;
}
}
while
(
lastGeneratedLine
<
mapping
.
generatedLine
)
{
node
.
add
(
shiftNextLine
(
)
)
;
lastGeneratedLine
+
+
;
}
if
(
lastGeneratedColumn
<
mapping
.
generatedColumn
)
{
var
nextLine
=
remainingLines
[
0
]
;
node
.
add
(
nextLine
.
substr
(
0
mapping
.
generatedColumn
)
)
;
remainingLines
[
0
]
=
nextLine
.
substr
(
mapping
.
generatedColumn
)
;
lastGeneratedColumn
=
mapping
.
generatedColumn
;
}
lastMapping
=
mapping
;
}
this
)
;
if
(
remainingLines
.
length
>
0
)
{
if
(
lastMapping
)
{
addMappingWithCode
(
lastMapping
shiftNextLine
(
)
)
;
}
node
.
add
(
remainingLines
.
join
(
"
"
)
)
;
}
aSourceMapConsumer
.
sources
.
forEach
(
function
(
sourceFile
)
{
var
content
=
aSourceMapConsumer
.
sourceContentFor
(
sourceFile
)
;
if
(
content
!
=
null
)
{
if
(
aRelativePath
!
=
null
)
{
sourceFile
=
util
.
join
(
aRelativePath
sourceFile
)
;
}
node
.
setSourceContent
(
sourceFile
content
)
;
}
}
)
;
return
node
;
function
addMappingWithCode
(
mapping
code
)
{
if
(
mapping
=
=
=
null
|
|
mapping
.
source
=
=
=
undefined
)
{
node
.
add
(
code
)
;
}
else
{
var
source
=
aRelativePath
?
util
.
join
(
aRelativePath
mapping
.
source
)
:
mapping
.
source
;
node
.
add
(
new
SourceNode
(
mapping
.
originalLine
mapping
.
originalColumn
source
code
mapping
.
name
)
)
;
}
}
}
;
SourceNode
.
prototype
.
add
=
function
SourceNode_add
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
aChunk
.
forEach
(
function
(
chunk
)
{
this
.
add
(
chunk
)
;
}
this
)
;
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
if
(
aChunk
)
{
this
.
children
.
push
(
aChunk
)
;
}
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
prepend
=
function
SourceNode_prepend
(
aChunk
)
{
if
(
Array
.
isArray
(
aChunk
)
)
{
for
(
var
i
=
aChunk
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
this
.
prepend
(
aChunk
[
i
]
)
;
}
}
else
if
(
aChunk
[
isSourceNode
]
|
|
typeof
aChunk
=
=
=
"
string
"
)
{
this
.
children
.
unshift
(
aChunk
)
;
}
else
{
throw
new
TypeError
(
"
Expected
a
SourceNode
string
or
an
array
of
SourceNodes
and
strings
.
Got
"
+
aChunk
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
walk
=
function
SourceNode_walk
(
aFn
)
{
var
chunk
;
for
(
var
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
chunk
=
this
.
children
[
i
]
;
if
(
chunk
[
isSourceNode
]
)
{
chunk
.
walk
(
aFn
)
;
}
else
{
if
(
chunk
!
=
=
'
'
)
{
aFn
(
chunk
{
source
:
this
.
source
line
:
this
.
line
column
:
this
.
column
name
:
this
.
name
}
)
;
}
}
}
}
;
SourceNode
.
prototype
.
join
=
function
SourceNode_join
(
aSep
)
{
var
newChildren
;
var
i
;
var
len
=
this
.
children
.
length
;
if
(
len
>
0
)
{
newChildren
=
[
]
;
for
(
i
=
0
;
i
<
len
-
1
;
i
+
+
)
{
newChildren
.
push
(
this
.
children
[
i
]
)
;
newChildren
.
push
(
aSep
)
;
}
newChildren
.
push
(
this
.
children
[
i
]
)
;
this
.
children
=
newChildren
;
}
return
this
;
}
;
SourceNode
.
prototype
.
replaceRight
=
function
SourceNode_replaceRight
(
aPattern
aReplacement
)
{
var
lastChild
=
this
.
children
[
this
.
children
.
length
-
1
]
;
if
(
lastChild
[
isSourceNode
]
)
{
lastChild
.
replaceRight
(
aPattern
aReplacement
)
;
}
else
if
(
typeof
lastChild
=
=
=
'
string
'
)
{
this
.
children
[
this
.
children
.
length
-
1
]
=
lastChild
.
replace
(
aPattern
aReplacement
)
;
}
else
{
this
.
children
.
push
(
'
'
.
replace
(
aPattern
aReplacement
)
)
;
}
return
this
;
}
;
SourceNode
.
prototype
.
setSourceContent
=
function
SourceNode_setSourceContent
(
aSourceFile
aSourceContent
)
{
this
.
sourceContents
[
util
.
toSetString
(
aSourceFile
)
]
=
aSourceContent
;
}
;
SourceNode
.
prototype
.
walkSourceContents
=
function
SourceNode_walkSourceContents
(
aFn
)
{
for
(
var
i
=
0
len
=
this
.
children
.
length
;
i
<
len
;
i
+
+
)
{
if
(
this
.
children
[
i
]
[
isSourceNode
]
)
{
this
.
children
[
i
]
.
walkSourceContents
(
aFn
)
;
}
}
var
sources
=
Object
.
keys
(
this
.
sourceContents
)
;
for
(
var
i
=
0
len
=
sources
.
length
;
i
<
len
;
i
+
+
)
{
aFn
(
util
.
fromSetString
(
sources
[
i
]
)
this
.
sourceContents
[
sources
[
i
]
]
)
;
}
}
;
SourceNode
.
prototype
.
toString
=
function
SourceNode_toString
(
)
{
var
str
=
"
"
;
this
.
walk
(
function
(
chunk
)
{
str
+
=
chunk
;
}
)
;
return
str
;
}
;
SourceNode
.
prototype
.
toStringWithSourceMap
=
function
SourceNode_toStringWithSourceMap
(
aArgs
)
{
var
generated
=
{
code
:
"
"
line
:
1
column
:
0
}
;
var
map
=
new
SourceMapGenerator
(
aArgs
)
;
var
sourceMappingActive
=
false
;
var
lastOriginalSource
=
null
;
var
lastOriginalLine
=
null
;
var
lastOriginalColumn
=
null
;
var
lastOriginalName
=
null
;
this
.
walk
(
function
(
chunk
original
)
{
generated
.
code
+
=
chunk
;
if
(
original
.
source
!
=
=
null
&
&
original
.
line
!
=
=
null
&
&
original
.
column
!
=
=
null
)
{
if
(
lastOriginalSource
!
=
=
original
.
source
|
|
lastOriginalLine
!
=
=
original
.
line
|
|
lastOriginalColumn
!
=
=
original
.
column
|
|
lastOriginalName
!
=
=
original
.
name
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
lastOriginalSource
=
original
.
source
;
lastOriginalLine
=
original
.
line
;
lastOriginalColumn
=
original
.
column
;
lastOriginalName
=
original
.
name
;
sourceMappingActive
=
true
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
}
)
;
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
for
(
var
idx
=
0
length
=
chunk
.
length
;
idx
<
length
;
idx
+
+
)
{
if
(
chunk
.
charCodeAt
(
idx
)
=
=
=
NEWLINE_CODE
)
{
generated
.
line
+
+
;
generated
.
column
=
0
;
if
(
idx
+
1
=
=
=
length
)
{
lastOriginalSource
=
null
;
sourceMappingActive
=
false
;
}
else
if
(
sourceMappingActive
)
{
map
.
addMapping
(
{
source
:
original
.
source
original
:
{
line
:
original
.
line
column
:
original
.
column
}
generated
:
{
line
:
generated
.
line
column
:
generated
.
column
}
name
:
original
.
name
}
)
;
}
}
else
{
generated
.
column
+
+
;
}
}
}
)
;
this
.
walkSourceContents
(
function
(
sourceFile
sourceContent
)
{
map
.
setSourceContent
(
sourceFile
sourceContent
)
;
}
)
;
return
{
code
:
generated
.
code
map
:
map
}
;
}
;
exports
.
SourceNode
=
SourceNode
;
}
)
900
:
(
function
(
module
exports
__webpack_require__
)
{
const
networkRequest
=
__webpack_require__
(
901
)
;
const
workerUtils
=
__webpack_require__
(
902
)
;
module
.
exports
=
{
networkRequest
workerUtils
}
;
}
)
901
:
(
function
(
module
exports
)
{
function
networkRequest
(
url
opts
)
{
return
fetch
(
url
{
cache
:
opts
.
loadFromCache
?
"
default
"
:
"
no
-
cache
"
}
)
.
then
(
res
=
>
{
if
(
res
.
status
>
=
200
&
&
res
.
status
<
300
)
{
return
res
.
text
(
)
.
then
(
text
=
>
(
{
content
:
text
}
)
)
;
}
return
Promise
.
reject
(
request
failed
with
status
{
res
.
status
}
)
;
}
)
;
}
module
.
exports
=
networkRequest
;
}
)
902
:
(
function
(
module
exports
)
{
function
_asyncToGenerator
(
fn
)
{
return
function
(
)
{
var
gen
=
fn
.
apply
(
this
arguments
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
function
step
(
key
arg
)
{
try
{
var
info
=
gen
[
key
]
(
arg
)
;
var
value
=
info
.
value
;
}
catch
(
error
)
{
reject
(
error
)
;
return
;
}
if
(
info
.
done
)
{
resolve
(
value
)
;
}
else
{
return
Promise
.
resolve
(
value
)
.
then
(
function
(
value
)
{
step
(
"
next
"
value
)
;
}
function
(
err
)
{
step
(
"
throw
"
err
)
;
}
)
;
}
}
return
step
(
"
next
"
)
;
}
)
;
}
;
}
function
WorkerDispatcher
(
)
{
this
.
msgId
=
1
;
this
.
worker
=
null
;
}
WorkerDispatcher
.
prototype
=
{
start
(
url
)
{
this
.
worker
=
new
Worker
(
url
)
;
this
.
worker
.
onerror
=
(
)
=
>
{
console
.
error
(
Error
in
worker
{
url
}
)
;
}
;
}
stop
(
)
{
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
terminate
(
)
;
this
.
worker
=
null
;
}
task
(
method
)
{
return
(
.
.
.
args
)
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
id
=
this
.
msgId
+
+
;
this
.
worker
.
postMessage
(
{
id
method
args
}
)
;
const
listener
=
(
{
data
:
result
}
)
=
>
{
if
(
result
.
id
!
=
=
id
)
{
return
;
}
this
.
worker
.
removeEventListener
(
"
message
"
listener
)
;
if
(
result
.
error
)
{
reject
(
result
.
error
)
;
}
else
{
resolve
(
result
.
response
)
;
}
}
;
this
.
worker
.
addEventListener
(
"
message
"
listener
)
;
}
)
;
}
;
}
}
;
function
workerHandler
(
publicInterface
)
{
return
function
(
msg
)
{
const
{
id
method
args
}
=
msg
.
data
;
try
{
const
response
=
publicInterface
[
method
]
.
apply
(
undefined
args
)
;
if
(
response
instanceof
Promise
)
{
response
.
then
(
val
=
>
self
.
postMessage
(
{
id
response
:
val
}
)
err
=
>
self
.
postMessage
(
{
id
error
:
err
}
)
)
;
}
else
{
self
.
postMessage
(
{
id
response
}
)
;
}
}
catch
(
error
)
{
self
.
postMessage
(
{
id
error
}
)
;
}
}
;
}
function
streamingWorkerHandler
(
publicInterface
{
timeout
=
100
}
=
{
}
worker
=
self
)
{
let
streamingWorker
=
(
(
)
=
>
{
var
_ref
=
_asyncToGenerator
(
function
*
(
id
tasks
)
{
let
isWorking
=
true
;
const
intervalId
=
setTimeout
(
function
(
)
{
isWorking
=
false
;
}
timeout
)
;
const
results
=
[
]
;
while
(
tasks
.
length
!
=
=
0
&
&
isWorking
)
{
const
{
callback
context
args
}
=
tasks
.
shift
(
)
;
const
result
=
yield
callback
.
call
(
context
args
)
;
results
.
push
(
result
)
;
}
worker
.
postMessage
(
{
id
status
:
"
pending
"
data
:
results
}
)
;
clearInterval
(
intervalId
)
;
if
(
tasks
.
length
!
=
=
0
)
{
yield
streamingWorker
(
id
tasks
)
;
}
}
)
;
return
function
streamingWorker
(
_x
_x2
)
{
return
_ref
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
return
(
(
)
=
>
{
var
_ref2
=
_asyncToGenerator
(
function
*
(
msg
)
{
const
{
id
method
args
}
=
msg
.
data
;
const
workerMethod
=
publicInterface
[
method
]
;
if
(
!
workerMethod
)
{
console
.
error
(
Could
not
find
{
method
}
defined
in
worker
.
)
;
}
worker
.
postMessage
(
{
id
status
:
"
start
"
}
)
;
try
{
const
tasks
=
workerMethod
(
args
)
;
yield
streamingWorker
(
id
tasks
)
;
worker
.
postMessage
(
{
id
status
:
"
done
"
}
)
;
}
catch
(
error
)
{
worker
.
postMessage
(
{
id
status
:
"
error
"
error
}
)
;
}
}
)
;
return
function
(
_x3
)
{
return
_ref2
.
apply
(
this
arguments
)
;
}
;
}
)
(
)
;
}
module
.
exports
=
{
WorkerDispatcher
workerHandler
streamingWorkerHandler
}
;
}
)
964
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_prettyFast
=
__webpack_require__
(
802
)
;
var
_prettyFast2
=
_interopRequireDefault
(
_prettyFast
)
;
var
_devtoolsUtils
=
__webpack_require__
(
900
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
var
workerHandler
=
_devtoolsUtils
.
workerUtils
.
workerHandler
;
function
prettyPrint
(
_ref
)
{
var
url
=
_ref
.
url
indent
=
_ref
.
indent
source
=
_ref
.
source
;
var
prettified
=
(
0
_prettyFast2
.
default
)
(
source
{
url
:
url
indent
:
"
"
.
repeat
(
indent
)
}
)
;
return
{
code
:
prettified
.
code
mappings
:
invertMappings
(
prettified
.
map
.
_mappings
)
}
;
}
function
invertMappings
(
mappings
)
{
return
mappings
.
_array
.
map
(
m
=
>
{
var
mapping
=
{
generated
:
{
line
:
m
.
originalLine
column
:
m
.
originalColumn
}
}
;
if
(
m
.
source
)
{
mapping
.
source
=
m
.
source
;
mapping
.
original
=
{
line
:
m
.
generatedLine
column
:
m
.
generatedColumn
}
;
mapping
.
name
=
m
.
name
;
}
return
mapping
;
}
)
;
}
self
.
onmessage
=
workerHandler
(
{
prettyPrint
}
)
;
}
)
}
)
;
}
)
;
