const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
button
span
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
getGripType
isGrip
cropString
wrapRender
}
=
require
(
"
.
/
rep
-
utils
"
)
;
const
{
MODE
}
=
require
(
"
.
/
constants
"
)
;
const
IGNORED_SOURCE_URLS
=
[
"
debugger
eval
code
"
]
;
FunctionRep
.
propTypes
=
{
object
:
PropTypes
.
object
.
isRequired
parameterNames
:
PropTypes
.
array
onViewSourceInDebugger
:
PropTypes
.
func
sourceMapService
:
PropTypes
.
object
}
;
function
FunctionRep
(
props
)
{
const
{
object
:
grip
onViewSourceInDebugger
recordTelemetryEvent
sourceMapService
}
=
props
;
let
jumpToDefinitionButton
;
if
(
onViewSourceInDebugger
&
&
grip
.
location
&
&
grip
.
location
.
url
&
&
!
IGNORED_SOURCE_URLS
.
includes
(
grip
.
location
.
url
)
)
{
jumpToDefinitionButton
=
button
(
{
className
:
"
jump
-
definition
"
draggable
:
false
title
:
"
Jump
to
definition
"
onClick
:
async
e
=
>
{
e
.
stopPropagation
(
)
;
if
(
recordTelemetryEvent
)
{
recordTelemetryEvent
(
"
jump_to_definition
"
)
;
}
const
sourceLocation
=
await
getSourceLocation
(
grip
.
location
sourceMapService
)
;
onViewSourceInDebugger
(
sourceLocation
)
;
}
}
)
;
}
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
grip
.
actor
className
:
"
objectBox
objectBox
-
function
"
dir
:
"
ltr
"
}
getTitle
(
grip
props
)
getFunctionName
(
grip
props
)
"
(
"
.
.
.
renderParams
(
props
)
"
)
"
jumpToDefinitionButton
)
;
}
function
getTitle
(
grip
props
)
{
const
{
mode
}
=
props
;
if
(
mode
=
=
=
MODE
.
TINY
&
&
!
grip
.
isGenerator
&
&
!
grip
.
isAsync
)
{
return
null
;
}
let
title
=
mode
=
=
=
MODE
.
TINY
?
"
"
:
"
function
"
;
if
(
grip
.
isGenerator
)
{
title
=
mode
=
=
=
MODE
.
TINY
?
"
*
"
:
"
function
*
"
;
}
if
(
grip
.
isAsync
)
{
title
=
{
"
async
"
+
"
"
}
{
title
}
;
}
return
span
(
{
className
:
"
objectTitle
"
}
title
)
;
}
function
getFunctionName
(
grip
props
=
{
}
)
{
let
{
functionName
}
=
props
;
let
name
;
if
(
functionName
)
{
const
end
=
functionName
.
length
-
1
;
functionName
=
functionName
.
startsWith
(
'
"
'
)
&
&
functionName
.
endsWith
(
'
"
'
)
?
functionName
.
substring
(
1
end
)
:
functionName
;
}
if
(
grip
.
displayName
!
=
undefined
&
&
functionName
!
=
undefined
&
&
grip
.
displayName
!
=
functionName
)
{
name
=
{
functionName
}
:
{
grip
.
displayName
}
;
}
else
{
name
=
cleanFunctionName
(
grip
.
userDisplayName
|
|
grip
.
displayName
|
|
grip
.
name
|
|
props
.
functionName
|
|
"
"
)
;
}
return
cropString
(
name
100
)
;
}
const
objectProperty
=
/
(
[
\
w
\
d
\
]
+
)
/
;
const
arrayProperty
=
/
\
[
(
.
*
?
)
\
]
/
;
const
functionProperty
=
/
(
[
\
w
\
d
]
+
)
[
\
/
\
.
<
]
*
?
/
;
const
annonymousProperty
=
/
(
[
\
w
\
d
]
+
)
\
(
\
^
\
)
/
;
function
cleanFunctionName
(
name
)
{
for
(
const
reg
of
[
objectProperty
arrayProperty
functionProperty
annonymousProperty
]
)
{
const
match
=
reg
.
exec
(
name
)
;
if
(
match
)
{
return
match
[
1
]
;
}
}
return
name
;
}
function
renderParams
(
props
)
{
const
{
parameterNames
=
[
]
}
=
props
;
return
parameterNames
.
filter
(
param
=
>
param
)
.
reduce
(
(
res
param
index
arr
)
=
>
{
res
.
push
(
span
(
{
className
:
"
param
"
}
param
)
)
;
if
(
index
<
arr
.
length
-
1
)
{
res
.
push
(
span
(
{
className
:
"
delimiter
"
}
"
"
)
)
;
}
return
res
;
}
[
]
)
;
}
function
supportsObject
(
grip
noGrip
=
false
)
{
const
type
=
getGripType
(
grip
noGrip
)
;
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
grip
)
)
{
return
type
=
=
"
function
"
;
}
return
type
=
=
"
Function
"
;
}
async
function
getSourceLocation
(
location
sourceMapService
)
{
if
(
!
sourceMapService
)
{
return
location
;
}
try
{
const
originalLocation
=
await
sourceMapService
.
originalPositionFor
(
location
.
url
location
.
line
location
.
column
)
;
if
(
originalLocation
)
{
const
{
sourceUrl
line
column
}
=
originalLocation
;
return
{
url
:
sourceUrl
line
column
}
;
}
}
catch
(
e
)
{
}
return
location
;
}
module
.
exports
=
{
rep
:
wrapRender
(
FunctionRep
)
supportsObject
cleanFunctionName
getFunctionName
}
;
