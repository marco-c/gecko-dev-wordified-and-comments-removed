const
PropTypes
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
;
const
{
span
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
;
const
{
getGripType
isGrip
wrapRender
}
=
require
(
"
.
/
rep
-
utils
"
)
;
const
{
cleanFunctionName
}
=
require
(
"
.
/
function
"
)
;
const
{
isLongString
}
=
require
(
"
.
/
string
"
)
;
const
{
MODE
}
=
require
(
"
.
/
constants
"
)
;
const
IGNORED_SOURCE_URLS
=
[
"
debugger
eval
code
"
]
;
ErrorRep
.
propTypes
=
{
object
:
PropTypes
.
object
.
isRequired
mode
:
PropTypes
.
oneOf
(
Object
.
keys
(
MODE
)
.
map
(
key
=
>
MODE
[
key
]
)
)
renderStacktrace
:
PropTypes
.
func
}
;
function
ErrorRep
(
props
)
{
const
object
=
props
.
object
;
const
preview
=
object
.
preview
;
const
mode
=
props
.
mode
;
let
name
;
if
(
preview
&
&
preview
.
name
&
&
preview
.
kind
)
{
switch
(
preview
.
kind
)
{
case
"
Error
"
:
name
=
preview
.
name
;
break
;
case
"
DOMException
"
:
name
=
preview
.
kind
;
break
;
default
:
throw
new
Error
(
"
Unknown
preview
kind
for
the
Error
rep
.
"
)
;
}
}
else
{
name
=
"
Error
"
;
}
const
content
=
[
]
;
if
(
mode
=
=
=
MODE
.
TINY
)
{
content
.
push
(
name
)
;
}
else
{
content
.
push
(
{
name
}
:
"
{
preview
.
message
}
"
)
;
}
if
(
preview
.
stack
&
&
(
mode
!
=
=
MODE
.
TINY
&
&
mode
!
=
=
MODE
.
SHORT
)
)
{
const
stacktrace
=
props
.
renderStacktrace
?
props
.
renderStacktrace
(
parseStackString
(
preview
.
stack
)
)
:
getStacktraceElements
(
props
preview
)
;
content
.
push
(
stacktrace
)
;
}
return
span
(
{
"
data
-
link
-
actor
-
id
"
:
object
.
actor
className
:
"
objectBox
-
stackTrace
"
}
content
)
;
}
function
getStacktraceElements
(
props
preview
)
{
const
stack
=
[
]
;
if
(
!
preview
.
stack
)
{
return
stack
;
}
parseStackString
(
preview
.
stack
)
.
forEach
(
(
frame
index
frames
)
=
>
{
let
onLocationClick
;
const
{
filename
lineNumber
columnNumber
functionName
location
}
=
frame
;
if
(
props
.
onViewSourceInDebugger
&
&
!
IGNORED_SOURCE_URLS
.
includes
(
filename
)
)
{
onLocationClick
=
e
=
>
{
e
.
stopPropagation
(
)
;
props
.
onViewSourceInDebugger
(
{
url
:
filename
line
:
lineNumber
column
:
columnNumber
}
)
;
}
;
}
stack
.
push
(
"
\
t
"
span
(
{
key
:
fn
{
index
}
className
:
"
objectBox
-
stackTrace
-
fn
"
}
cleanFunctionName
(
functionName
)
)
"
"
span
(
{
key
:
location
{
index
}
className
:
"
objectBox
-
stackTrace
-
location
"
onClick
:
onLocationClick
title
:
onLocationClick
?
View
source
in
debugger
{
location
}
:
undefined
}
location
)
"
\
n
"
)
;
}
)
;
return
span
(
{
key
:
"
stack
"
className
:
"
objectBox
-
stackTrace
-
grid
"
}
stack
)
;
}
function
parseStackString
(
stack
)
{
if
(
!
stack
)
{
return
[
]
;
}
const
isStacktraceALongString
=
isLongString
(
stack
)
;
const
stackString
=
isStacktraceALongString
?
stack
.
initial
:
stack
;
if
(
typeof
stackString
!
=
=
"
string
"
)
{
return
[
]
;
}
const
res
=
[
]
;
stackString
.
split
(
"
\
n
"
)
.
forEach
(
(
frame
index
frames
)
=
>
{
if
(
!
frame
)
{
return
;
}
if
(
isStacktraceALongString
&
&
index
=
=
=
frames
.
length
-
1
)
{
return
;
}
let
functionName
;
let
location
;
const
result
=
frame
.
match
(
/
^
(
.
*
)
(
.
*
)
/
)
;
if
(
result
&
&
result
.
length
=
=
=
3
)
{
functionName
=
result
[
1
]
;
location
=
result
[
2
]
.
split
(
"
-
>
"
)
.
pop
(
)
;
}
if
(
!
functionName
)
{
functionName
=
"
<
anonymous
>
"
;
}
const
locationParts
=
location
?
location
.
match
(
/
^
(
.
*
)
:
(
\
d
+
)
:
(
\
d
+
)
/
)
:
null
;
if
(
location
&
&
locationParts
)
{
const
[
filename
line
column
]
=
locationParts
;
res
.
push
(
{
filename
functionName
location
columnNumber
:
Number
(
column
)
lineNumber
:
Number
(
line
)
}
)
;
}
}
)
;
return
res
;
}
function
supportsObject
(
object
noGrip
=
false
)
{
if
(
noGrip
=
=
=
true
|
|
!
isGrip
(
object
)
)
{
return
false
;
}
return
(
(
object
.
preview
&
&
getGripType
(
object
noGrip
)
=
=
=
"
Error
"
)
|
|
object
.
class
=
=
=
"
DOMException
"
)
;
}
module
.
exports
=
{
rep
:
wrapRender
(
ErrorRep
)
supportsObject
}
;
