"
use
strict
"
;
const
DBNAME
=
"
devtools
-
async
-
storage
"
;
const
DBVERSION
=
1
;
const
STORENAME
=
"
keyvaluepairs
"
;
var
db
=
null
;
function
withStore
(
type
onsuccess
onerror
)
{
if
(
db
)
{
const
transaction
=
db
.
transaction
(
STORENAME
type
)
;
const
store
=
transaction
.
objectStore
(
STORENAME
)
;
onsuccess
(
store
)
;
}
else
{
const
openreq
=
indexedDB
.
open
(
DBNAME
DBVERSION
)
;
openreq
.
onerror
=
function
withStoreOnError
(
)
{
onerror
(
)
;
}
;
openreq
.
onupgradeneeded
=
function
withStoreOnUpgradeNeeded
(
)
{
openreq
.
result
.
createObjectStore
(
STORENAME
)
;
}
;
openreq
.
onsuccess
=
function
withStoreOnSuccess
(
)
{
db
=
openreq
.
result
;
const
transaction
=
db
.
transaction
(
STORENAME
type
)
;
const
store
=
transaction
.
objectStore
(
STORENAME
)
;
onsuccess
(
store
)
;
}
;
}
}
function
getItem
(
itemKey
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
req
;
withStore
(
"
readonly
"
store
=
>
{
store
.
transaction
.
oncomplete
=
function
onComplete
(
)
{
let
value
=
req
.
result
;
if
(
value
=
=
=
undefined
)
{
value
=
null
;
}
resolve
(
value
)
;
}
;
req
=
store
.
get
(
itemKey
)
;
req
.
onerror
=
function
getItemOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
getItem
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
setItem
(
itemKey
value
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
withStore
(
"
readwrite
"
store
=
>
{
store
.
transaction
.
oncomplete
=
resolve
;
const
req
=
store
.
put
(
value
itemKey
)
;
req
.
onerror
=
function
setItemOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
setItem
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
removeItem
(
itemKey
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
withStore
(
"
readwrite
"
store
=
>
{
store
.
transaction
.
oncomplete
=
resolve
;
const
req
=
store
.
delete
(
itemKey
)
;
req
.
onerror
=
function
removeItemOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
removeItem
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
clear
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
withStore
(
"
readwrite
"
store
=
>
{
store
.
transaction
.
oncomplete
=
resolve
;
const
req
=
store
.
clear
(
)
;
req
.
onerror
=
function
clearOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
clear
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
length
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
req
;
withStore
(
"
readonly
"
store
=
>
{
store
.
transaction
.
oncomplete
=
function
onComplete
(
)
{
resolve
(
req
.
result
)
;
}
;
req
=
store
.
count
(
)
;
req
.
onerror
=
function
lengthOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
length
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
key
(
n
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
n
<
0
)
{
resolve
(
null
)
;
return
;
}
let
req
;
withStore
(
"
readonly
"
store
=
>
{
store
.
transaction
.
oncomplete
=
function
onComplete
(
)
{
const
cursor
=
req
.
result
;
resolve
(
cursor
?
cursor
.
key
:
null
)
;
}
;
let
advanced
=
false
;
req
=
store
.
openCursor
(
)
;
req
.
onsuccess
=
function
keyOnSuccess
(
)
{
const
cursor
=
req
.
result
;
if
(
!
cursor
)
{
return
;
}
if
(
n
=
=
=
0
|
|
advanced
)
{
return
;
}
advanced
=
true
;
cursor
.
advance
(
n
)
;
}
;
req
.
onerror
=
function
keyOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
key
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
exports
.
getItem
=
getItem
;
exports
.
setItem
=
setItem
;
exports
.
removeItem
=
removeItem
;
exports
.
clear
=
clear
;
exports
.
length
=
length
;
exports
.
key
=
key
;
