jest
.
useFakeTimers
(
)
;
const
networkRequest
=
require
(
"
.
.
/
network
-
request
"
)
;
describe
(
"
network
request
"
(
)
=
>
{
beforeEach
(
(
)
=
>
{
global
.
fetch
=
jest
.
fn
(
)
;
}
)
;
it
(
"
successful
fetch
"
async
(
)
=
>
{
global
.
fetch
.
mockImplementation
(
async
(
)
=
>
(
{
status
:
200
headers
:
{
get
:
(
)
=
>
"
application
/
json
"
}
text
:
async
(
)
=
>
"
Yay
"
}
)
)
;
const
res
=
await
networkRequest
(
"
foo
"
)
;
expect
(
res
)
.
toEqual
(
{
content
:
"
Yay
"
}
)
;
}
)
;
it
(
"
wasm
successful
fetch
"
async
(
)
=
>
{
global
.
fetch
.
mockImplementation
(
async
(
)
=
>
(
{
status
:
200
headers
:
{
get
:
(
)
=
>
"
application
/
wasm
"
}
arrayBuffer
:
async
(
)
=
>
"
Yay
"
}
)
)
;
const
res
=
await
networkRequest
(
"
foo
"
)
;
expect
(
res
)
.
toEqual
(
{
content
:
"
Yay
"
isDwarf
:
true
}
)
;
}
)
;
it
(
"
failed
fetch
"
async
(
)
=
>
{
global
.
fetch
.
mockImplementation
(
async
(
)
=
>
(
{
status
:
400
headers
:
{
get
:
(
)
=
>
"
application
/
json
"
}
text
:
async
(
)
=
>
"
Sad
"
}
)
)
;
await
expect
(
networkRequest
(
"
foo
"
)
)
.
rejects
.
toThrow
(
expect
.
objectContaining
(
{
message
:
"
failed
to
request
foo
"
}
)
)
;
}
)
;
it
(
"
timed
out
fetch
"
async
(
)
=
>
{
global
.
fetch
.
mockImplementation
(
async
(
)
=
>
{
}
)
;
networkRequest
(
"
foo
"
)
.
catch
(
e
=
>
{
expect
(
e
.
message
)
.
toEqual
(
"
Connect
timeout
error
"
)
;
}
)
;
jest
.
runAllTimers
(
)
;
}
)
;
}
)
;
