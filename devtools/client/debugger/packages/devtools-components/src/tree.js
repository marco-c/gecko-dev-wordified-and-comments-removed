import
React
from
"
react
"
;
const
{
Component
createFactory
}
=
React
;
import
dom
from
"
react
-
dom
-
factories
"
;
import
PropTypes
from
"
prop
-
types
"
;
require
(
"
.
/
tree
.
css
"
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
FOCUSABLE_SELECTOR
=
[
"
a
[
href
]
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
button
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
iframe
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
input
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
select
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
textarea
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
[
tabindex
]
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
]
.
join
(
"
"
)
;
class
ArrowExpander
extends
Component
{
static
get
propTypes
(
)
{
return
{
expanded
:
PropTypes
.
bool
}
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
{
expanded
}
=
this
.
props
;
const
classNames
=
[
"
arrow
"
]
;
if
(
expanded
)
{
classNames
.
push
(
"
expanded
"
)
;
}
return
dom
.
button
(
{
className
:
classNames
.
join
(
"
"
)
}
)
;
}
}
const
treeIndent
=
dom
.
span
(
{
className
:
"
tree
-
indent
"
}
"
\
u200B
"
)
;
const
treeLastIndent
=
dom
.
span
(
{
className
:
"
tree
-
indent
tree
-
last
-
indent
"
}
"
\
u200B
"
)
;
class
TreeNode
extends
Component
{
static
get
propTypes
(
)
{
return
{
id
:
PropTypes
.
any
.
isRequired
index
:
PropTypes
.
number
.
isRequired
depth
:
PropTypes
.
number
.
isRequired
focused
:
PropTypes
.
bool
.
isRequired
active
:
PropTypes
.
bool
.
isRequired
expanded
:
PropTypes
.
bool
.
isRequired
item
:
PropTypes
.
any
.
isRequired
isExpandable
:
PropTypes
.
bool
.
isRequired
onClick
:
PropTypes
.
func
shouldItemUpdate
:
PropTypes
.
func
renderItem
:
PropTypes
.
func
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
treeNodeRef
=
React
.
createRef
(
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
}
componentDidMount
(
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
if
(
this
.
props
.
active
)
{
if
(
elms
.
length
>
0
&
&
!
elms
.
includes
(
document
.
activeElement
)
)
{
elms
[
0
]
.
focus
(
)
;
}
}
else
{
elms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
)
;
}
}
shouldComponentUpdate
(
nextProps
)
{
return
(
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
(
this
.
props
.
shouldItemUpdate
&
&
this
.
props
.
shouldItemUpdate
(
this
.
props
.
item
nextProps
.
item
)
)
|
|
this
.
props
.
focused
!
=
=
nextProps
.
focused
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
)
;
}
getFocusableElements
(
)
{
return
this
.
treeNodeRef
.
current
?
Array
.
from
(
this
.
treeNodeRef
.
current
.
querySelectorAll
(
FOCUSABLE_SELECTOR
)
)
:
[
]
;
}
_wrapMoveFocus
(
current
back
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
let
next
;
if
(
elms
.
length
=
=
=
0
)
{
return
false
;
}
if
(
back
)
{
if
(
elms
.
indexOf
(
current
)
=
=
=
0
)
{
next
=
elms
[
elms
.
length
-
1
]
;
next
.
focus
(
)
;
}
}
else
if
(
elms
.
indexOf
(
current
)
=
=
=
elms
.
length
-
1
)
{
next
=
elms
[
0
]
;
next
.
focus
(
)
;
}
return
!
!
next
;
}
_onKeyDown
(
e
)
{
const
{
target
key
shiftKey
}
=
e
;
if
(
key
!
=
=
"
Tab
"
)
{
return
;
}
const
focusMoved
=
this
.
_wrapMoveFocus
(
target
shiftKey
)
;
if
(
focusMoved
)
{
e
.
preventDefault
(
)
;
}
e
.
stopPropagation
(
)
;
}
render
(
)
{
const
{
depth
id
item
focused
active
expanded
renderItem
isExpandable
}
=
this
.
props
;
const
arrow
=
isExpandable
?
ArrowExpanderFactory
(
{
item
expanded
}
)
:
null
;
let
ariaExpanded
;
if
(
this
.
props
.
isExpandable
)
{
ariaExpanded
=
false
;
}
if
(
this
.
props
.
expanded
)
{
ariaExpanded
=
true
;
}
const
indents
=
Array
.
from
(
{
length
:
depth
}
(
_
i
)
=
>
{
if
(
i
=
=
depth
-
1
)
{
return
treeLastIndent
;
}
return
treeIndent
;
}
)
const
items
=
indents
.
concat
(
renderItem
(
item
depth
focused
arrow
expanded
)
)
;
return
dom
.
div
(
{
id
className
:
tree
-
node
{
focused
?
"
focused
"
:
"
"
}
{
active
?
"
active
"
:
"
"
}
onClick
:
this
.
props
.
onClick
onKeyDownCapture
:
active
?
this
.
_onKeyDown
:
null
role
:
"
treeitem
"
ref
:
this
.
treeNodeRef
"
aria
-
level
"
:
depth
+
1
"
aria
-
expanded
"
:
ariaExpanded
"
data
-
expandable
"
:
this
.
props
.
isExpandable
}
.
.
.
items
)
;
}
}
const
ArrowExpanderFactory
=
createFactory
(
ArrowExpander
)
;
const
TreeNodeFactory
=
createFactory
(
TreeNode
)
;
function
oncePerAnimationFrame
(
fn
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
animationId
=
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
class
Tree
extends
Component
{
static
get
propTypes
(
)
{
return
{
getParent
:
PropTypes
.
func
.
isRequired
getChildren
:
PropTypes
.
func
.
isRequired
shouldItemUpdate
:
PropTypes
.
func
renderItem
:
PropTypes
.
func
.
isRequired
getRoots
:
PropTypes
.
func
.
isRequired
getKey
:
PropTypes
.
func
.
isRequired
isExpanded
:
PropTypes
.
func
.
isRequired
focused
:
PropTypes
.
any
onFocus
:
PropTypes
.
func
autoExpandDepth
:
PropTypes
.
number
autoExpandAll
:
PropTypes
.
bool
autoExpandNodeChildrenLimit
:
PropTypes
.
number
labelledby
:
PropTypes
.
string
label
:
PropTypes
.
string
onExpand
:
PropTypes
.
func
onCollapse
:
PropTypes
.
func
active
:
PropTypes
.
any
onActivate
:
PropTypes
.
func
isExpandable
:
PropTypes
.
func
className
:
PropTypes
.
string
style
:
PropTypes
.
object
preventBlur
:
PropTypes
.
bool
}
;
}
static
get
defaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
autoExpandAll
:
true
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
seen
:
new
Set
(
)
}
;
this
.
treeRef
=
React
.
createRef
(
)
;
this
.
_onExpand
=
oncePerAnimationFrame
(
this
.
_onExpand
)
.
bind
(
this
)
;
this
.
_onCollapse
=
oncePerAnimationFrame
(
this
.
_onCollapse
)
.
bind
(
this
)
;
this
.
_focusPrevNode
=
oncePerAnimationFrame
(
this
.
_focusPrevNode
)
.
bind
(
this
)
;
this
.
_focusNextNode
=
oncePerAnimationFrame
(
this
.
_focusNextNode
)
.
bind
(
this
)
;
this
.
_focusParentNode
=
oncePerAnimationFrame
(
this
.
_focusParentNode
)
.
bind
(
this
)
;
this
.
_focusFirstNode
=
oncePerAnimationFrame
(
this
.
_focusFirstNode
)
.
bind
(
this
)
;
this
.
_focusLastNode
=
oncePerAnimationFrame
(
this
.
_focusLastNode
)
.
bind
(
this
)
;
this
.
_autoExpand
=
this
.
_autoExpand
.
bind
(
this
)
;
this
.
_preventArrowKeyScrolling
=
this
.
_preventArrowKeyScrolling
.
bind
(
this
)
;
this
.
_preventEvent
=
this
.
_preventEvent
.
bind
(
this
)
;
this
.
_dfs
=
this
.
_dfs
.
bind
(
this
)
;
this
.
_dfsFromRoots
=
this
.
_dfsFromRoots
.
bind
(
this
)
;
this
.
_focus
=
this
.
_focus
.
bind
(
this
)
;
this
.
_activate
=
this
.
_activate
.
bind
(
this
)
;
this
.
_scrollNodeIntoView
=
this
.
_scrollNodeIntoView
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
_nodeIsExpandable
=
this
.
_nodeIsExpandable
.
bind
(
this
)
;
}
componentDidMount
(
)
{
this
.
_autoExpand
(
)
;
if
(
this
.
props
.
focused
)
{
this
.
_scrollNodeIntoView
(
this
.
props
.
focused
)
;
}
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
)
;
}
componentDidUpdate
(
prevProps
prevState
)
{
if
(
this
.
props
.
focused
&
&
prevProps
.
focused
!
=
=
this
.
props
.
focused
)
{
this
.
_scrollNodeIntoView
(
this
.
props
.
focused
)
;
}
}
_autoExpand
(
)
{
const
{
autoExpandDepth
autoExpandNodeChildrenLimit
}
=
this
.
props
;
if
(
!
autoExpandDepth
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
if
(
currentDepth
>
=
autoExpandDepth
|
|
this
.
state
.
seen
.
has
(
item
)
)
{
return
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
if
(
autoExpandNodeChildrenLimit
&
&
children
.
length
>
autoExpandNodeChildrenLimit
)
{
return
;
}
this
.
props
.
onExpand
(
item
)
;
this
.
state
.
seen
.
add
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
if
(
this
.
props
.
autoExpandAll
)
{
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
else
if
(
length
!
=
0
)
{
autoExpand
(
roots
[
0
]
0
)
;
}
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
this
.
_preventEvent
(
e
)
;
break
;
}
}
_preventEvent
(
e
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
_onCollapse
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
_focus
(
item
options
=
{
}
)
{
const
{
preventAutoScroll
}
=
options
;
if
(
item
&
&
!
preventAutoScroll
)
{
this
.
_scrollNodeIntoView
(
item
options
)
;
}
if
(
this
.
props
.
active
!
=
undefined
)
{
this
.
_activate
(
undefined
)
;
if
(
this
.
treeRef
.
current
!
=
=
document
.
activeElement
)
{
this
.
treeRef
.
current
.
focus
(
)
;
}
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_activate
(
item
)
{
if
(
this
.
props
.
onActivate
)
{
this
.
props
.
onActivate
(
item
)
;
}
}
_scrollNodeIntoView
(
item
options
=
{
}
)
{
if
(
item
!
=
=
undefined
)
{
const
treeElement
=
this
.
treeRef
.
current
;
const
element
=
document
.
getElementById
(
this
.
props
.
getKey
(
item
)
)
;
if
(
element
)
{
const
{
top
bottom
}
=
element
.
getBoundingClientRect
(
)
;
const
closestScrolledParent
=
node
=
>
{
if
(
node
=
=
null
)
{
return
null
;
}
if
(
node
.
scrollHeight
>
node
.
clientHeight
)
{
return
node
;
}
return
closestScrolledParent
(
node
.
parentNode
)
;
}
;
const
scrolledParent
=
closestScrolledParent
(
treeElement
)
;
const
scrolledParentRect
=
scrolledParent
?
scrolledParent
.
getBoundingClientRect
(
)
:
null
;
const
isVisible
=
!
scrolledParent
|
|
(
top
>
=
scrolledParentRect
.
top
&
&
bottom
<
=
scrolledParentRect
.
bottom
)
;
if
(
!
isVisible
)
{
const
{
alignTo
}
=
options
;
const
scrollToTop
=
alignTo
?
alignTo
=
=
=
"
top
"
:
!
scrolledParentRect
|
|
top
<
scrolledParentRect
.
top
;
element
.
scrollIntoView
(
scrollToTop
)
;
}
}
}
}
_onBlur
(
e
)
{
if
(
this
.
props
.
active
!
=
undefined
)
{
const
{
relatedTarget
}
=
e
;
if
(
!
this
.
treeRef
.
current
.
contains
(
relatedTarget
)
)
{
this
.
_activate
(
undefined
)
;
}
}
else
if
(
!
this
.
props
.
preventBlur
)
{
this
.
_focus
(
undefined
)
;
}
}
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
_nodeIsExpandable
(
this
.
props
.
focused
)
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
this
.
_nodeIsExpandable
(
this
.
props
.
focused
)
&
&
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
;
case
"
Home
"
:
this
.
_focusFirstNode
(
)
;
return
;
case
"
End
"
:
this
.
_focusLastNode
(
)
;
return
;
case
"
Enter
"
:
case
"
"
:
if
(
this
.
treeRef
.
current
=
=
=
document
.
activeElement
)
{
this
.
_preventEvent
(
e
)
;
if
(
this
.
props
.
active
!
=
=
this
.
props
.
focused
)
{
this
.
_activate
(
this
.
props
.
focused
)
;
}
}
return
;
case
"
Escape
"
:
this
.
_preventEvent
(
e
)
;
if
(
this
.
props
.
active
!
=
undefined
)
{
this
.
_activate
(
undefined
)
;
}
if
(
this
.
treeRef
.
current
!
=
=
document
.
activeElement
)
{
this
.
treeRef
.
current
.
focus
(
)
;
}
}
}
_focusPrevNode
(
)
{
let
prev
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prev
{
alignTo
:
"
top
"
}
)
;
}
_focusNextNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
traversal
[
i
+
1
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
}
_focusParentNode
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
this
.
_focusPrevNode
(
this
.
props
.
focused
)
;
return
;
}
this
.
_focus
(
parent
{
alignTo
:
"
top
"
}
)
;
}
_focusFirstNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
this
.
_focus
(
traversal
[
0
]
.
item
{
alignTo
:
"
top
"
}
)
;
}
_focusLastNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
lastIndex
=
traversal
.
length
-
1
;
this
.
_focus
(
traversal
[
lastIndex
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
_nodeIsExpandable
(
item
)
{
return
this
.
props
.
isExpandable
?
this
.
props
.
isExpandable
(
item
)
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
;
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
{
active
focused
}
=
this
.
props
;
const
nodes
=
traversal
.
map
(
(
v
i
)
=
>
{
const
{
item
depth
}
=
traversal
[
i
]
;
const
key
=
this
.
props
.
getKey
(
item
i
)
;
return
TreeNodeFactory
(
{
key
:
{
key
}
-
{
active
=
=
=
item
?
"
active
"
:
"
inactive
"
}
id
:
key
index
:
i
item
depth
shouldItemUpdate
:
this
.
props
.
shouldItemUpdate
renderItem
:
this
.
props
.
renderItem
focused
:
focused
=
=
=
item
active
:
active
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
isExpandable
:
this
.
_nodeIsExpandable
(
item
)
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
this
.
_focus
(
item
{
preventAutoScroll
:
true
}
)
;
if
(
this
.
props
.
isExpanded
(
item
)
)
{
this
.
props
.
onCollapse
(
item
e
.
altKey
)
;
}
else
{
this
.
props
.
onExpand
(
item
e
.
altKey
)
;
}
this
.
treeRef
.
current
.
focus
(
)
;
}
}
)
;
}
)
;
const
style
=
Object
.
assign
(
{
}
this
.
props
.
style
|
|
{
}
)
;
return
dom
.
div
(
{
className
:
tree
{
this
.
props
.
className
?
this
.
props
.
className
:
"
"
}
ref
:
this
.
treeRef
role
:
"
tree
"
tabIndex
:
"
0
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
onFocus
:
(
{
nativeEvent
}
)
=
>
{
if
(
focused
|
|
!
nativeEvent
|
|
!
this
.
treeRef
.
current
)
{
return
;
}
const
{
explicitOriginalTarget
}
=
nativeEvent
;
if
(
explicitOriginalTarget
!
=
=
this
.
treeRef
.
current
&
&
!
this
.
treeRef
.
current
.
contains
(
explicitOriginalTarget
)
)
{
this
.
_focus
(
traversal
[
0
]
.
item
)
;
}
}
onBlur
:
this
.
_onBlur
"
aria
-
label
"
:
this
.
props
.
label
"
aria
-
labelledby
"
:
this
.
props
.
labelledby
"
aria
-
activedescendant
"
:
focused
&
&
this
.
props
.
getKey
(
focused
)
style
}
nodes
)
;
}
}
export
default
Tree
;
