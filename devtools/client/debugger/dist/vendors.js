(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
require
(
"
Services
"
)
require
(
"
devtools
/
shared
/
flags
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
require
(
"
devtools
/
client
/
framework
/
menu
"
)
require
(
"
devtools
/
client
/
framework
/
menu
-
item
"
)
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
"
devtools
/
client
/
shared
/
vendor
/
react
"
"
Services
"
"
devtools
/
shared
/
flags
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
"
devtools
/
client
/
framework
/
menu
"
"
devtools
/
client
/
framework
/
menu
-
item
"
]
factory
)
;
else
{
var
a
=
typeof
exports
=
=
=
'
object
'
?
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
require
(
"
Services
"
)
require
(
"
devtools
/
shared
/
flags
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
require
(
"
devtools
/
client
/
framework
/
menu
"
)
require
(
"
devtools
/
client
/
framework
/
menu
-
item
"
)
)
:
factory
(
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
root
[
"
Services
"
]
root
[
"
devtools
/
shared
/
flags
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
]
root
[
"
devtools
/
client
/
framework
/
menu
"
]
root
[
"
devtools
/
client
/
framework
/
menu
-
item
"
]
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
typeof
self
!
=
=
'
undefined
'
?
self
:
this
function
(
__WEBPACK_EXTERNAL_MODULE_0__
__WEBPACK_EXTERNAL_MODULE_1__
__WEBPACK_EXTERNAL_MODULE_6__
__WEBPACK_EXTERNAL_MODULE_37__
__WEBPACK_EXTERNAL_MODULE_103__
__WEBPACK_EXTERNAL_MODULE_112__
__WEBPACK_EXTERNAL_MODULE_417__
__WEBPACK_EXTERNAL_MODULE_490__
__WEBPACK_EXTERNAL_MODULE_491__
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
{
return
installedModules
[
moduleId
]
.
exports
;
}
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
413
)
;
}
)
(
{
0
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_0__
;
}
)
1
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_1__
;
}
)
102
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
const
flag
=
__webpack_require__
(
103
)
;
function
isBrowser
(
)
{
return
typeof
window
=
=
"
object
"
;
}
function
isNode
(
)
{
return
process
&
&
process
.
release
&
&
process
.
release
.
name
=
=
'
node
'
;
}
function
isDevelopment
(
)
{
if
(
!
isNode
(
)
&
&
isBrowser
(
)
)
{
const
href
=
window
.
location
?
window
.
location
.
href
:
"
"
;
return
href
.
match
(
/
^
file
:
/
)
|
|
href
.
match
(
/
localhost
:
/
)
;
}
return
"
production
"
!
=
"
production
"
;
}
function
isTesting
(
)
{
return
flag
.
testing
;
}
function
isFirefoxPanel
(
)
{
return
!
isDevelopment
(
)
;
}
function
isFirefox
(
)
{
return
/
firefox
/
i
.
test
(
navigator
.
userAgent
)
;
}
module
.
exports
=
{
isDevelopment
isTesting
isFirefoxPanel
isFirefox
}
;
}
.
call
(
exports
__webpack_require__
(
35
)
)
)
}
)
103
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_103__
;
}
)
108
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_tree
=
_interopRequireDefault
(
__webpack_require__
(
109
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
module
.
exports
=
{
Tree
:
_tree
.
default
}
;
}
)
109
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_reactDomFactories
=
_interopRequireDefault
(
__webpack_require__
(
1
)
)
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
{
Component
createFactory
}
=
_react
.
default
;
__webpack_require__
(
110
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
FOCUSABLE_SELECTOR
=
[
"
a
[
href
]
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
button
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
iframe
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
input
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
select
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
textarea
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
[
tabindex
]
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
]
.
join
(
"
"
)
;
class
ArrowExpander
extends
Component
{
static
get
propTypes
(
)
{
return
{
expanded
:
_propTypes
.
default
.
bool
}
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
{
expanded
}
=
this
.
props
;
const
classNames
=
[
"
arrow
"
]
;
if
(
expanded
)
{
classNames
.
push
(
"
expanded
"
)
;
}
return
_reactDomFactories
.
default
.
button
(
{
className
:
classNames
.
join
(
"
"
)
}
)
;
}
}
const
treeIndent
=
_reactDomFactories
.
default
.
span
(
{
className
:
"
tree
-
indent
"
}
"
\
u200B
"
)
;
const
treeLastIndent
=
_reactDomFactories
.
default
.
span
(
{
className
:
"
tree
-
indent
tree
-
last
-
indent
"
}
"
\
u200B
"
)
;
class
TreeNode
extends
Component
{
static
get
propTypes
(
)
{
return
{
id
:
_propTypes
.
default
.
any
.
isRequired
index
:
_propTypes
.
default
.
number
.
isRequired
depth
:
_propTypes
.
default
.
number
.
isRequired
focused
:
_propTypes
.
default
.
bool
.
isRequired
active
:
_propTypes
.
default
.
bool
.
isRequired
expanded
:
_propTypes
.
default
.
bool
.
isRequired
item
:
_propTypes
.
default
.
any
.
isRequired
isExpandable
:
_propTypes
.
default
.
bool
.
isRequired
onClick
:
_propTypes
.
default
.
func
shouldItemUpdate
:
_propTypes
.
default
.
func
renderItem
:
_propTypes
.
default
.
func
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
treeNodeRef
=
_react
.
default
.
createRef
(
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
}
componentDidMount
(
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
if
(
this
.
props
.
active
)
{
const
doc
=
this
.
treeNodeRef
.
current
.
ownerDocument
;
if
(
elms
.
length
>
0
&
&
!
elms
.
includes
(
doc
.
activeElement
)
)
{
elms
[
0
]
.
focus
(
)
;
}
}
else
{
elms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
)
;
}
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
shouldItemUpdate
&
&
this
.
props
.
shouldItemUpdate
(
this
.
props
.
item
nextProps
.
item
)
|
|
this
.
props
.
focused
!
=
=
nextProps
.
focused
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
getFocusableElements
(
)
{
return
this
.
treeNodeRef
.
current
?
Array
.
from
(
this
.
treeNodeRef
.
current
.
querySelectorAll
(
FOCUSABLE_SELECTOR
)
)
:
[
]
;
}
_wrapMoveFocus
(
current
back
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
let
next
;
if
(
elms
.
length
=
=
=
0
)
{
return
false
;
}
if
(
back
)
{
if
(
elms
.
indexOf
(
current
)
=
=
=
0
)
{
next
=
elms
[
elms
.
length
-
1
]
;
next
.
focus
(
)
;
}
}
else
if
(
elms
.
indexOf
(
current
)
=
=
=
elms
.
length
-
1
)
{
next
=
elms
[
0
]
;
next
.
focus
(
)
;
}
return
!
!
next
;
}
_onKeyDown
(
e
)
{
const
{
target
key
shiftKey
}
=
e
;
if
(
key
!
=
=
"
Tab
"
)
{
return
;
}
const
focusMoved
=
this
.
_wrapMoveFocus
(
target
shiftKey
)
;
if
(
focusMoved
)
{
e
.
preventDefault
(
)
;
}
e
.
stopPropagation
(
)
;
}
render
(
)
{
const
{
depth
id
item
focused
active
expanded
renderItem
isExpandable
}
=
this
.
props
;
const
arrow
=
isExpandable
?
ArrowExpanderFactory
(
{
item
expanded
}
)
:
null
;
let
ariaExpanded
;
if
(
this
.
props
.
isExpandable
)
{
ariaExpanded
=
false
;
}
if
(
this
.
props
.
expanded
)
{
ariaExpanded
=
true
;
}
const
indents
=
Array
.
from
(
{
length
:
depth
}
(
_
i
)
=
>
{
if
(
i
=
=
depth
-
1
)
{
return
treeLastIndent
;
}
return
treeIndent
;
}
)
;
const
items
=
indents
.
concat
(
renderItem
(
item
depth
focused
arrow
expanded
)
)
;
return
_reactDomFactories
.
default
.
div
(
{
id
className
:
tree
-
node
{
focused
?
"
focused
"
:
"
"
}
{
active
?
"
active
"
:
"
"
}
onClick
:
this
.
props
.
onClick
onKeyDownCapture
:
active
?
this
.
_onKeyDown
:
null
role
:
"
treeitem
"
ref
:
this
.
treeNodeRef
"
aria
-
level
"
:
depth
+
1
"
aria
-
expanded
"
:
ariaExpanded
"
data
-
expandable
"
:
this
.
props
.
isExpandable
}
.
.
.
items
)
;
}
}
const
ArrowExpanderFactory
=
createFactory
(
ArrowExpander
)
;
const
TreeNodeFactory
=
createFactory
(
TreeNode
)
;
function
oncePerAnimationFrame
(
fn
{
getDocument
}
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
const
doc
=
getDocument
(
)
;
if
(
!
doc
)
{
return
;
}
animationId
=
doc
.
defaultView
.
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
class
Tree
extends
Component
{
static
get
propTypes
(
)
{
return
{
getParent
:
_propTypes
.
default
.
func
.
isRequired
getChildren
:
_propTypes
.
default
.
func
.
isRequired
shouldItemUpdate
:
_propTypes
.
default
.
func
renderItem
:
_propTypes
.
default
.
func
.
isRequired
getRoots
:
_propTypes
.
default
.
func
.
isRequired
getKey
:
_propTypes
.
default
.
func
.
isRequired
isExpanded
:
_propTypes
.
default
.
func
.
isRequired
focused
:
_propTypes
.
default
.
any
onFocus
:
_propTypes
.
default
.
func
autoExpandDepth
:
_propTypes
.
default
.
number
autoExpandAll
:
_propTypes
.
default
.
bool
autoExpandNodeChildrenLimit
:
_propTypes
.
default
.
number
labelledby
:
_propTypes
.
default
.
string
label
:
_propTypes
.
default
.
string
onExpand
:
_propTypes
.
default
.
func
onCollapse
:
_propTypes
.
default
.
func
active
:
_propTypes
.
default
.
any
onActivate
:
_propTypes
.
default
.
func
isExpandable
:
_propTypes
.
default
.
func
className
:
_propTypes
.
default
.
string
style
:
_propTypes
.
default
.
object
preventBlur
:
_propTypes
.
default
.
bool
}
;
}
static
get
defaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
autoExpandAll
:
true
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
autoExpanded
:
new
Set
(
)
}
;
this
.
treeRef
=
_react
.
default
.
createRef
(
)
;
const
opaf
=
fn
=
>
oncePerAnimationFrame
(
fn
{
getDocument
:
(
)
=
>
this
.
treeRef
.
current
&
&
this
.
treeRef
.
current
.
ownerDocument
}
)
;
this
.
_onExpand
=
opaf
(
this
.
_onExpand
)
.
bind
(
this
)
;
this
.
_onCollapse
=
opaf
(
this
.
_onCollapse
)
.
bind
(
this
)
;
this
.
_focusPrevNode
=
opaf
(
this
.
_focusPrevNode
)
.
bind
(
this
)
;
this
.
_focusNextNode
=
opaf
(
this
.
_focusNextNode
)
.
bind
(
this
)
;
this
.
_focusParentNode
=
opaf
(
this
.
_focusParentNode
)
.
bind
(
this
)
;
this
.
_focusFirstNode
=
opaf
(
this
.
_focusFirstNode
)
.
bind
(
this
)
;
this
.
_focusLastNode
=
opaf
(
this
.
_focusLastNode
)
.
bind
(
this
)
;
this
.
_autoExpand
=
this
.
_autoExpand
.
bind
(
this
)
;
this
.
_preventArrowKeyScrolling
=
this
.
_preventArrowKeyScrolling
.
bind
(
this
)
;
this
.
_preventEvent
=
this
.
_preventEvent
.
bind
(
this
)
;
this
.
_dfs
=
this
.
_dfs
.
bind
(
this
)
;
this
.
_dfsFromRoots
=
this
.
_dfsFromRoots
.
bind
(
this
)
;
this
.
_focus
=
this
.
_focus
.
bind
(
this
)
;
this
.
_activate
=
this
.
_activate
.
bind
(
this
)
;
this
.
_scrollNodeIntoView
=
this
.
_scrollNodeIntoView
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
_nodeIsExpandable
=
this
.
_nodeIsExpandable
.
bind
(
this
)
;
}
componentDidMount
(
)
{
this
.
_autoExpand
(
)
;
if
(
this
.
props
.
focused
)
{
this
.
_scrollNodeIntoView
(
this
.
props
.
focused
)
;
}
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
)
;
}
componentDidUpdate
(
prevProps
prevState
)
{
if
(
this
.
props
.
focused
&
&
prevProps
.
focused
!
=
=
this
.
props
.
focused
)
{
this
.
_scrollNodeIntoView
(
this
.
props
.
focused
)
;
}
}
_autoExpand
(
)
{
const
{
autoExpandDepth
autoExpandNodeChildrenLimit
initiallyExpanded
}
=
this
.
props
;
if
(
!
autoExpandDepth
&
&
!
initiallyExpanded
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
const
initial
=
initiallyExpanded
&
&
initiallyExpanded
(
item
)
;
if
(
!
initial
&
&
currentDepth
>
=
autoExpandDepth
)
{
return
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
if
(
!
initial
&
&
autoExpandNodeChildrenLimit
&
&
children
.
length
>
autoExpandNodeChildrenLimit
)
{
return
;
}
if
(
!
this
.
state
.
autoExpanded
.
has
(
item
)
)
{
this
.
props
.
onExpand
(
item
)
;
this
.
state
.
autoExpanded
.
add
(
item
)
;
}
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
if
(
this
.
props
.
autoExpandAll
)
{
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
else
if
(
length
!
=
0
)
{
autoExpand
(
roots
[
0
]
0
)
;
if
(
initiallyExpanded
)
{
for
(
let
i
=
1
;
i
<
length
;
i
+
+
)
{
if
(
initiallyExpanded
(
roots
[
i
]
)
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
}
}
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
this
.
_preventEvent
(
e
)
;
break
;
}
}
_preventEvent
(
e
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
_onCollapse
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
_focus
(
item
options
=
{
}
)
{
const
{
preventAutoScroll
}
=
options
;
if
(
item
&
&
!
preventAutoScroll
)
{
this
.
_scrollNodeIntoView
(
item
options
)
;
}
if
(
this
.
props
.
active
!
=
undefined
)
{
this
.
_activate
(
undefined
)
;
const
doc
=
this
.
treeRef
.
current
&
&
this
.
treeRef
.
current
.
ownerDocument
;
if
(
this
.
treeRef
.
current
!
=
=
doc
.
activeElement
)
{
this
.
treeRef
.
current
.
focus
(
)
;
}
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_activate
(
item
)
{
if
(
this
.
props
.
onActivate
)
{
this
.
props
.
onActivate
(
item
)
;
}
}
_scrollNodeIntoView
(
item
options
=
{
}
)
{
if
(
item
!
=
=
undefined
)
{
const
treeElement
=
this
.
treeRef
.
current
;
const
doc
=
treeElement
&
&
treeElement
.
ownerDocument
;
const
element
=
doc
.
getElementById
(
this
.
props
.
getKey
(
item
)
)
;
if
(
element
)
{
const
{
top
bottom
}
=
element
.
getBoundingClientRect
(
)
;
const
closestScrolledParent
=
node
=
>
{
if
(
node
=
=
null
)
{
return
null
;
}
if
(
node
.
scrollHeight
>
node
.
clientHeight
)
{
return
node
;
}
return
closestScrolledParent
(
node
.
parentNode
)
;
}
;
const
scrolledParent
=
closestScrolledParent
(
treeElement
)
;
const
scrolledParentRect
=
scrolledParent
?
scrolledParent
.
getBoundingClientRect
(
)
:
null
;
const
isVisible
=
!
scrolledParent
|
|
top
>
=
scrolledParentRect
.
top
&
&
bottom
<
=
scrolledParentRect
.
bottom
;
if
(
!
isVisible
)
{
const
{
alignTo
}
=
options
;
const
scrollToTop
=
alignTo
?
alignTo
=
=
=
"
top
"
:
!
scrolledParentRect
|
|
top
<
scrolledParentRect
.
top
;
element
.
scrollIntoView
(
scrollToTop
)
;
}
}
}
}
_onBlur
(
e
)
{
if
(
this
.
props
.
active
!
=
undefined
)
{
const
{
relatedTarget
}
=
e
;
if
(
!
this
.
treeRef
.
current
.
contains
(
relatedTarget
)
)
{
this
.
_activate
(
undefined
)
;
}
}
else
if
(
!
this
.
props
.
preventBlur
)
{
this
.
_focus
(
undefined
)
;
}
}
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
const
doc
=
this
.
treeRef
.
current
&
&
this
.
treeRef
.
current
.
ownerDocument
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
_nodeIsExpandable
(
this
.
props
.
focused
)
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
this
.
_nodeIsExpandable
(
this
.
props
.
focused
)
&
&
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
;
case
"
Home
"
:
this
.
_focusFirstNode
(
)
;
return
;
case
"
End
"
:
this
.
_focusLastNode
(
)
;
return
;
case
"
Enter
"
:
case
"
"
:
if
(
this
.
treeRef
.
current
=
=
=
doc
.
activeElement
)
{
this
.
_preventEvent
(
e
)
;
if
(
this
.
props
.
active
!
=
=
this
.
props
.
focused
)
{
this
.
_activate
(
this
.
props
.
focused
)
;
}
}
return
;
case
"
Escape
"
:
this
.
_preventEvent
(
e
)
;
if
(
this
.
props
.
active
!
=
undefined
)
{
this
.
_activate
(
undefined
)
;
}
if
(
this
.
treeRef
.
current
!
=
=
doc
.
activeElement
)
{
this
.
treeRef
.
current
.
focus
(
)
;
}
}
}
_focusPrevNode
(
)
{
let
prev
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prev
{
alignTo
:
"
top
"
}
)
;
}
_focusNextNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
traversal
[
i
+
1
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
}
_focusParentNode
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
this
.
_focusPrevNode
(
this
.
props
.
focused
)
;
return
;
}
this
.
_focus
(
parent
{
alignTo
:
"
top
"
}
)
;
}
_focusFirstNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
this
.
_focus
(
traversal
[
0
]
.
item
{
alignTo
:
"
top
"
}
)
;
}
_focusLastNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
lastIndex
=
traversal
.
length
-
1
;
this
.
_focus
(
traversal
[
lastIndex
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
_nodeIsExpandable
(
item
)
{
return
this
.
props
.
isExpandable
?
this
.
props
.
isExpandable
(
item
)
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
;
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
{
active
focused
}
=
this
.
props
;
const
nodes
=
traversal
.
map
(
(
v
i
)
=
>
{
const
{
item
depth
}
=
traversal
[
i
]
;
const
key
=
this
.
props
.
getKey
(
item
i
)
;
return
TreeNodeFactory
(
{
key
:
{
key
}
-
{
active
=
=
=
item
?
"
active
"
:
"
inactive
"
}
id
:
key
index
:
i
item
depth
shouldItemUpdate
:
this
.
props
.
shouldItemUpdate
renderItem
:
this
.
props
.
renderItem
focused
:
focused
=
=
=
item
active
:
active
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
isExpandable
:
this
.
_nodeIsExpandable
(
item
)
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
this
.
_focus
(
item
{
preventAutoScroll
:
true
}
)
;
if
(
this
.
props
.
isExpanded
(
item
)
)
{
this
.
props
.
onCollapse
(
item
e
.
altKey
)
;
}
else
{
this
.
props
.
onExpand
(
item
e
.
altKey
)
;
}
this
.
treeRef
.
current
.
focus
(
)
;
}
}
)
;
}
)
;
const
style
=
Object
.
assign
(
{
}
this
.
props
.
style
|
|
{
}
)
;
return
_reactDomFactories
.
default
.
div
(
{
className
:
tree
{
this
.
props
.
className
?
this
.
props
.
className
:
"
"
}
ref
:
this
.
treeRef
role
:
"
tree
"
tabIndex
:
"
0
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
onFocus
:
(
{
nativeEvent
}
)
=
>
{
if
(
focused
|
|
!
nativeEvent
|
|
!
this
.
treeRef
.
current
)
{
return
;
}
const
{
explicitOriginalTarget
}
=
nativeEvent
;
if
(
explicitOriginalTarget
!
=
=
this
.
treeRef
.
current
&
&
!
this
.
treeRef
.
current
.
contains
(
explicitOriginalTarget
)
)
{
this
.
_focus
(
traversal
[
0
]
.
item
)
;
}
}
onBlur
:
this
.
_onBlur
"
aria
-
label
"
:
this
.
props
.
label
"
aria
-
labelledby
"
:
this
.
props
.
labelledby
"
aria
-
activedescendant
"
:
focused
&
&
this
.
props
.
getKey
(
focused
)
style
}
nodes
)
;
}
}
var
_default
=
Tree
;
exports
.
default
=
_default
;
}
)
110
:
(
function
(
module
exports
)
{
}
)
111
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
computeScore
countDir
file_coeff
getExtension
getExtensionScore
isMatch
scorePath
scoreSize
tau_depth
_ref
;
_ref
=
__webpack_require__
(
66
)
isMatch
=
_ref
.
isMatch
computeScore
=
_ref
.
computeScore
scoreSize
=
_ref
.
scoreSize
;
tau_depth
=
20
;
file_coeff
=
2
.
5
;
exports
.
score
=
function
(
string
query
options
)
{
var
allowErrors
preparedQuery
score
string_lw
;
preparedQuery
=
options
.
preparedQuery
allowErrors
=
options
.
allowErrors
;
if
(
!
(
allowErrors
|
|
isMatch
(
string
preparedQuery
.
core_lw
preparedQuery
.
core_up
)
)
)
{
return
0
;
}
string_lw
=
string
.
toLowerCase
(
)
;
score
=
computeScore
(
string
string_lw
preparedQuery
)
;
score
=
scorePath
(
string
string_lw
score
options
)
;
return
Math
.
ceil
(
score
)
;
}
;
scorePath
=
function
(
subject
subject_lw
fullPathScore
options
)
{
var
alpha
basePathScore
basePos
depth
end
extAdjust
fileLength
pathSeparator
preparedQuery
useExtensionBonus
;
if
(
fullPathScore
=
=
=
0
)
{
return
0
;
}
preparedQuery
=
options
.
preparedQuery
useExtensionBonus
=
options
.
useExtensionBonus
pathSeparator
=
options
.
pathSeparator
;
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
pathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
pathSeparator
end
)
;
fileLength
=
end
-
basePos
;
extAdjust
=
1
.
0
;
if
(
useExtensionBonus
)
{
extAdjust
+
=
getExtensionScore
(
subject_lw
preparedQuery
.
ext
basePos
end
2
)
;
fullPathScore
*
=
extAdjust
;
}
if
(
basePos
=
=
=
-
1
)
{
return
fullPathScore
;
}
depth
=
preparedQuery
.
depth
;
while
(
basePos
>
-
1
&
&
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
pathSeparator
basePos
-
1
)
;
}
basePathScore
=
basePos
=
=
=
-
1
?
fullPathScore
:
extAdjust
*
computeScore
(
subject
.
slice
(
basePos
+
1
end
+
1
)
subject_lw
.
slice
(
basePos
+
1
end
+
1
)
preparedQuery
)
;
alpha
=
0
.
5
*
tau_depth
/
(
tau_depth
+
countDir
(
subject
end
+
1
pathSeparator
)
)
;
return
alpha
*
basePathScore
+
(
1
-
alpha
)
*
fullPathScore
*
scoreSize
(
0
file_coeff
*
fileLength
)
;
}
;
exports
.
countDir
=
countDir
=
function
(
path
end
pathSeparator
)
{
var
count
i
;
if
(
end
<
1
)
{
return
0
;
}
count
=
0
;
i
=
-
1
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
pathSeparator
)
{
continue
;
}
while
(
+
+
i
<
end
)
{
if
(
path
[
i
]
=
=
=
pathSeparator
)
{
count
+
+
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
pathSeparator
)
{
continue
;
}
}
}
return
count
;
}
;
exports
.
getExtension
=
getExtension
=
function
(
str
)
{
var
pos
;
pos
=
str
.
lastIndexOf
(
"
.
"
)
;
if
(
pos
<
0
)
{
return
"
"
;
}
else
{
return
str
.
substr
(
pos
+
1
)
;
}
}
;
getExtensionScore
=
function
(
candidate
ext
startPos
endPos
maxDepth
)
{
var
m
matched
n
pos
;
if
(
!
ext
.
length
)
{
return
0
;
}
pos
=
candidate
.
lastIndexOf
(
"
.
"
endPos
)
;
if
(
!
(
pos
>
startPos
)
)
{
return
0
;
}
n
=
ext
.
length
;
m
=
endPos
-
pos
;
if
(
m
<
n
)
{
n
=
m
;
m
=
ext
.
length
;
}
pos
+
+
;
matched
=
-
1
;
while
(
+
+
matched
<
n
)
{
if
(
candidate
[
pos
+
matched
]
!
=
=
ext
[
matched
]
)
{
break
;
}
}
if
(
matched
=
=
=
0
&
&
maxDepth
>
0
)
{
return
0
.
9
*
getExtensionScore
(
candidate
ext
startPos
pos
-
2
maxDepth
-
1
)
;
}
return
matched
/
m
;
}
;
}
)
.
call
(
this
)
;
}
)
112
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_112__
;
}
)
13
:
(
function
(
module
exports
)
{
function
networkRequest
(
url
opts
)
{
return
fetch
(
url
{
cache
:
opts
.
loadFromCache
?
"
default
"
:
"
no
-
cache
"
}
)
.
then
(
res
=
>
{
if
(
res
.
status
>
=
200
&
&
res
.
status
<
300
)
{
if
(
res
.
headers
.
get
(
"
Content
-
Type
"
)
=
=
=
"
application
/
wasm
"
)
{
return
res
.
arrayBuffer
(
)
.
then
(
buffer
=
>
(
{
content
:
buffer
isDwarf
:
true
}
)
)
;
}
return
res
.
text
(
)
.
then
(
text
=
>
(
{
content
:
text
}
)
)
;
}
return
Promise
.
reject
(
request
failed
with
status
{
res
.
status
}
)
;
}
)
;
}
module
.
exports
=
networkRequest
;
}
)
14
:
(
function
(
module
exports
)
{
function
WorkerDispatcher
(
)
{
this
.
msgId
=
1
;
this
.
worker
=
null
;
}
WorkerDispatcher
.
prototype
=
{
start
(
url
win
=
window
)
{
this
.
worker
=
new
win
.
Worker
(
url
)
;
this
.
worker
.
onerror
=
err
=
>
{
console
.
error
(
Error
in
worker
{
url
}
err
.
message
)
;
}
;
}
stop
(
)
{
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
terminate
(
)
;
this
.
worker
=
null
;
}
task
(
method
{
queue
=
false
}
=
{
}
)
{
const
calls
=
[
]
;
const
push
=
args
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
queue
&
&
calls
.
length
=
=
=
0
)
{
Promise
.
resolve
(
)
.
then
(
flush
)
;
}
calls
.
push
(
[
args
resolve
reject
]
)
;
if
(
!
queue
)
{
flush
(
)
;
}
}
)
;
}
;
const
flush
=
(
)
=
>
{
const
items
=
calls
.
slice
(
)
;
calls
.
length
=
0
;
if
(
!
this
.
worker
)
{
return
;
}
const
id
=
this
.
msgId
+
+
;
this
.
worker
.
postMessage
(
{
id
method
calls
:
items
.
map
(
item
=
>
item
[
0
]
)
}
)
;
const
listener
=
(
{
data
:
result
}
)
=
>
{
if
(
result
.
id
!
=
=
id
)
{
return
;
}
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
removeEventListener
(
"
message
"
listener
)
;
result
.
results
.
forEach
(
(
resultData
i
)
=
>
{
const
[
resolve
reject
]
=
items
[
i
]
;
if
(
resultData
.
error
)
{
const
err
=
new
Error
(
resultData
.
message
)
;
err
.
metadata
=
resultData
.
metadata
;
reject
(
err
)
;
}
else
{
resolve
(
resultData
.
response
)
;
}
}
)
;
}
;
this
.
worker
.
addEventListener
(
"
message
"
listener
)
;
}
;
return
(
.
.
.
args
)
=
>
push
(
args
)
;
}
invoke
(
method
.
.
.
args
)
{
return
this
.
task
(
method
)
(
.
.
.
args
)
;
}
}
;
function
workerHandler
(
publicInterface
)
{
return
function
(
msg
)
{
const
{
id
method
calls
}
=
msg
.
data
;
Promise
.
all
(
calls
.
map
(
args
=
>
{
try
{
const
response
=
publicInterface
[
method
]
.
apply
(
undefined
args
)
;
if
(
response
instanceof
Promise
)
{
return
response
.
then
(
val
=
>
(
{
response
:
val
}
)
err
=
>
asErrorMessage
(
err
)
)
;
}
return
{
response
}
;
}
catch
(
error
)
{
return
asErrorMessage
(
error
)
;
}
}
)
)
.
then
(
results
=
>
{
self
.
postMessage
(
{
id
results
}
)
;
}
)
;
}
;
}
function
asErrorMessage
(
error
)
{
if
(
typeof
error
=
=
=
"
object
"
&
&
error
&
&
"
message
"
in
error
)
{
return
{
error
:
true
message
:
error
.
message
metadata
:
error
.
metadata
}
;
}
return
{
error
:
true
message
:
error
=
=
null
?
error
:
error
.
toString
(
)
metadata
:
undefined
}
;
}
module
.
exports
=
{
WorkerDispatcher
workerHandler
}
;
}
)
15
:
(
function
(
module
exports
)
{
var
g
;
g
=
(
function
(
)
{
return
this
;
}
)
(
)
;
try
{
g
=
g
|
|
Function
(
"
return
this
"
)
(
)
|
|
(
1
eval
)
(
"
this
"
)
;
}
catch
(
e
)
{
if
(
typeof
window
=
=
=
"
object
"
)
g
=
window
;
}
module
.
exports
=
g
;
}
)
184
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
Query
coreChars
countDir
getCharCodes
getExtension
opt_char_re
truncatedUpperCase
_ref
;
_ref
=
__webpack_require__
(
111
)
countDir
=
_ref
.
countDir
getExtension
=
_ref
.
getExtension
;
module
.
exports
=
Query
=
(
function
(
)
{
function
Query
(
query
_arg
)
{
var
optCharRegEx
pathSeparator
_ref1
;
_ref1
=
_arg
!
=
null
?
_arg
:
{
}
optCharRegEx
=
_ref1
.
optCharRegEx
pathSeparator
=
_ref1
.
pathSeparator
;
if
(
!
(
query
&
&
query
.
length
)
)
{
return
null
;
}
this
.
query
=
query
;
this
.
query_lw
=
query
.
toLowerCase
(
)
;
this
.
core
=
coreChars
(
query
optCharRegEx
)
;
this
.
core_lw
=
this
.
core
.
toLowerCase
(
)
;
this
.
core_up
=
truncatedUpperCase
(
this
.
core
)
;
this
.
depth
=
countDir
(
query
query
.
length
pathSeparator
)
;
this
.
ext
=
getExtension
(
this
.
query_lw
)
;
this
.
charCodes
=
getCharCodes
(
this
.
query_lw
)
;
}
return
Query
;
}
)
(
)
;
opt_char_re
=
/
[
_
\
-
:
\
/
\
\
]
/
g
;
coreChars
=
function
(
query
optCharRegEx
)
{
if
(
optCharRegEx
=
=
null
)
{
optCharRegEx
=
opt_char_re
;
}
return
query
.
replace
(
optCharRegEx
'
'
)
;
}
;
truncatedUpperCase
=
function
(
str
)
{
var
char
upper
_i
_len
;
upper
=
"
"
;
for
(
_i
=
0
_len
=
str
.
length
;
_i
<
_len
;
_i
+
+
)
{
char
=
str
[
_i
]
;
upper
+
=
char
.
toUpperCase
(
)
[
0
]
;
}
return
upper
;
}
;
getCharCodes
=
function
(
str
)
{
var
charCodes
i
len
;
len
=
str
.
length
;
i
=
-
1
;
charCodes
=
[
]
;
while
(
+
+
i
<
len
)
{
charCodes
[
str
.
charCodeAt
(
i
)
]
=
true
;
}
return
charCodes
;
}
;
}
)
.
call
(
this
)
;
}
)
185
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_tab
=
_interopRequireDefault
(
__webpack_require__
(
186
)
)
;
var
_tabList
=
_interopRequireDefault
(
__webpack_require__
(
441
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
class
TabList
extends
_react
.
default
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
const
childrenCount
=
_react
.
default
.
Children
.
count
(
props
.
children
)
;
this
.
handleKeyPress
=
this
.
handleKeyPress
.
bind
(
this
)
;
this
.
tabRefs
=
new
Array
(
childrenCount
)
.
fill
(
0
)
.
map
(
(
)
=
>
_react
.
default
.
createRef
(
)
)
;
this
.
handlers
=
this
.
getHandlers
(
props
.
vertical
)
;
}
componentDidUpdate
(
prevProps
)
{
if
(
prevProps
.
activeIndex
!
=
=
this
.
props
.
activeIndex
)
{
this
.
tabRefs
[
this
.
props
.
activeIndex
]
.
current
.
focus
(
)
;
}
}
getHandlers
(
vertical
)
{
if
(
vertical
)
{
return
{
ArrowDown
:
this
.
next
.
bind
(
this
)
ArrowUp
:
this
.
previous
.
bind
(
this
)
}
;
}
return
{
ArrowLeft
:
this
.
previous
.
bind
(
this
)
ArrowRight
:
this
.
next
.
bind
(
this
)
}
;
}
wrapIndex
(
index
)
{
const
count
=
_react
.
default
.
Children
.
count
(
this
.
props
.
children
)
;
return
(
index
+
count
)
%
count
;
}
handleKeyPress
(
event
)
{
const
handler
=
this
.
handlers
[
event
.
key
]
;
if
(
handler
)
{
handler
(
)
;
}
}
previous
(
)
{
const
newIndex
=
this
.
wrapIndex
(
this
.
props
.
activeIndex
-
1
)
;
this
.
props
.
onActivateTab
(
newIndex
)
;
}
next
(
)
{
const
newIndex
=
this
.
wrapIndex
(
this
.
props
.
activeIndex
+
1
)
;
this
.
props
.
onActivateTab
(
newIndex
)
;
}
render
(
)
{
const
{
accessibleId
activeIndex
children
className
onActivateTab
}
=
this
.
props
;
return
_react
.
default
.
createElement
(
"
ul
"
{
className
:
className
onKeyUp
:
this
.
handleKeyPress
role
:
"
tablist
"
}
_react
.
default
.
Children
.
map
(
children
(
child
index
)
=
>
{
if
(
child
.
type
!
=
=
_tab
.
default
)
{
throw
new
Error
(
'
Direct
children
of
a
<
TabList
>
must
be
a
<
Tab
>
'
)
;
}
const
active
=
index
=
=
=
activeIndex
;
const
tabRef
=
this
.
tabRefs
[
index
]
;
return
_react
.
default
.
cloneElement
(
child
{
accessibleId
:
active
?
accessibleId
:
undefined
active
tabRef
onActivate
:
(
)
=
>
onActivateTab
(
index
)
}
)
;
}
)
)
;
}
}
exports
.
default
=
TabList
;
TabList
.
propTypes
=
{
accessibleId
:
_propTypes
.
default
.
string
activeIndex
:
_propTypes
.
default
.
number
children
:
_propTypes
.
default
.
node
className
:
_propTypes
.
default
.
string
onActivateTab
:
_propTypes
.
default
.
func
vertical
:
_propTypes
.
default
.
bool
}
;
TabList
.
defaultProps
=
{
accessibleId
:
undefined
activeIndex
:
0
children
:
null
className
:
_tabList
.
default
.
container
onActivateTab
:
(
)
=
>
{
}
vertical
:
false
}
;
}
)
186
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Tab
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_ref
=
_interopRequireDefault
(
__webpack_require__
(
439
)
)
;
var
_tab
=
_interopRequireDefault
(
__webpack_require__
(
440
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
Tab
(
{
accessibleId
active
children
className
onActivate
tabRef
}
)
{
return
_react
.
default
.
createElement
(
"
li
"
{
"
aria
-
selected
"
:
active
className
:
className
id
:
accessibleId
onClick
:
onActivate
onKeyDown
:
(
)
=
>
{
}
ref
:
tabRef
role
:
"
tab
"
tabIndex
:
active
?
0
:
undefined
}
children
)
;
}
Tab
.
propTypes
=
{
accessibleId
:
_propTypes
.
default
.
string
active
:
_propTypes
.
default
.
bool
children
:
_propTypes
.
default
.
node
.
isRequired
className
:
_propTypes
.
default
.
string
onActivate
:
_propTypes
.
default
.
func
tabRef
:
_ref
.
default
}
;
Tab
.
defaultProps
=
{
accessibleId
:
undefined
active
:
false
className
:
_tab
.
default
.
container
onActivate
:
undefined
tabRef
:
undefined
}
;
}
)
187
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
TabPanels
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
TabPanels
(
{
accessibleId
activeIndex
children
className
hasFocusableContent
}
)
{
return
_react
.
default
.
createElement
(
"
div
"
{
"
aria
-
labelledby
"
:
accessibleId
role
:
"
tabpanel
"
className
:
className
tabIndex
:
hasFocusableContent
?
undefined
:
0
}
_react
.
default
.
Children
.
toArray
(
children
)
[
activeIndex
]
)
;
}
TabPanels
.
propTypes
=
{
accessibleId
:
_propTypes
.
default
.
string
activeIndex
:
_propTypes
.
default
.
number
children
:
_propTypes
.
default
.
node
.
isRequired
className
:
_propTypes
.
default
.
string
hasFocusableContent
:
_propTypes
.
default
.
bool
.
isRequired
}
;
TabPanels
.
defaultProps
=
{
accessibleId
:
undefined
activeIndex
:
0
className
:
null
}
;
}
)
22
:
(
function
(
module
exports
)
{
module
.
exports
=
function
(
module
)
{
if
(
!
module
.
webpackPolyfill
)
{
module
.
deprecate
=
function
(
)
{
}
;
module
.
paths
=
[
]
;
if
(
!
module
.
children
)
module
.
children
=
[
]
;
Object
.
defineProperty
(
module
"
loaded
"
{
enumerable
:
true
get
:
function
(
)
{
return
module
.
l
;
}
}
)
;
Object
.
defineProperty
(
module
"
id
"
{
enumerable
:
true
get
:
function
(
)
{
return
module
.
i
;
}
}
)
;
module
.
webpackPolyfill
=
1
;
}
return
module
;
}
;
}
)
35
:
(
function
(
module
exports
)
{
var
process
=
module
.
exports
=
{
}
;
var
cachedSetTimeout
;
var
cachedClearTimeout
;
function
defaultSetTimout
(
)
{
throw
new
Error
(
'
setTimeout
has
not
been
defined
'
)
;
}
function
defaultClearTimeout
(
)
{
throw
new
Error
(
'
clearTimeout
has
not
been
defined
'
)
;
}
(
function
(
)
{
try
{
if
(
typeof
setTimeout
=
=
=
'
function
'
)
{
cachedSetTimeout
=
setTimeout
;
}
else
{
cachedSetTimeout
=
defaultSetTimout
;
}
}
catch
(
e
)
{
cachedSetTimeout
=
defaultSetTimout
;
}
try
{
if
(
typeof
clearTimeout
=
=
=
'
function
'
)
{
cachedClearTimeout
=
clearTimeout
;
}
else
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
catch
(
e
)
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
(
)
)
function
runTimeout
(
fun
)
{
if
(
cachedSetTimeout
=
=
=
setTimeout
)
{
return
setTimeout
(
fun
0
)
;
}
if
(
(
cachedSetTimeout
=
=
=
defaultSetTimout
|
|
!
cachedSetTimeout
)
&
&
setTimeout
)
{
cachedSetTimeout
=
setTimeout
;
return
setTimeout
(
fun
0
)
;
}
try
{
return
cachedSetTimeout
(
fun
0
)
;
}
catch
(
e
)
{
try
{
return
cachedSetTimeout
.
call
(
null
fun
0
)
;
}
catch
(
e
)
{
return
cachedSetTimeout
.
call
(
this
fun
0
)
;
}
}
}
function
runClearTimeout
(
marker
)
{
if
(
cachedClearTimeout
=
=
=
clearTimeout
)
{
return
clearTimeout
(
marker
)
;
}
if
(
(
cachedClearTimeout
=
=
=
defaultClearTimeout
|
|
!
cachedClearTimeout
)
&
&
clearTimeout
)
{
cachedClearTimeout
=
clearTimeout
;
return
clearTimeout
(
marker
)
;
}
try
{
return
cachedClearTimeout
(
marker
)
;
}
catch
(
e
)
{
try
{
return
cachedClearTimeout
.
call
(
null
marker
)
;
}
catch
(
e
)
{
return
cachedClearTimeout
.
call
(
this
marker
)
;
}
}
}
var
queue
=
[
]
;
var
draining
=
false
;
var
currentQueue
;
var
queueIndex
=
-
1
;
function
cleanUpNextTick
(
)
{
if
(
!
draining
|
|
!
currentQueue
)
{
return
;
}
draining
=
false
;
if
(
currentQueue
.
length
)
{
queue
=
currentQueue
.
concat
(
queue
)
;
}
else
{
queueIndex
=
-
1
;
}
if
(
queue
.
length
)
{
drainQueue
(
)
;
}
}
function
drainQueue
(
)
{
if
(
draining
)
{
return
;
}
var
timeout
=
runTimeout
(
cleanUpNextTick
)
;
draining
=
true
;
var
len
=
queue
.
length
;
while
(
len
)
{
currentQueue
=
queue
;
queue
=
[
]
;
while
(
+
+
queueIndex
<
len
)
{
if
(
currentQueue
)
{
currentQueue
[
queueIndex
]
.
run
(
)
;
}
}
queueIndex
=
-
1
;
len
=
queue
.
length
;
}
currentQueue
=
null
;
draining
=
false
;
runClearTimeout
(
timeout
)
;
}
process
.
nextTick
=
function
(
fun
)
{
var
args
=
new
Array
(
arguments
.
length
-
1
)
;
if
(
arguments
.
length
>
1
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
}
queue
.
push
(
new
Item
(
fun
args
)
)
;
if
(
queue
.
length
=
=
=
1
&
&
!
draining
)
{
runTimeout
(
drainQueue
)
;
}
}
;
function
Item
(
fun
array
)
{
this
.
fun
=
fun
;
this
.
array
=
array
;
}
Item
.
prototype
.
run
=
function
(
)
{
this
.
fun
.
apply
(
null
this
.
array
)
;
}
;
process
.
title
=
'
browser
'
;
process
.
browser
=
true
;
process
.
env
=
{
}
;
process
.
argv
=
[
]
;
process
.
version
=
'
'
;
process
.
versions
=
{
}
;
function
noop
(
)
{
}
process
.
on
=
noop
;
process
.
addListener
=
noop
;
process
.
once
=
noop
;
process
.
off
=
noop
;
process
.
removeListener
=
noop
;
process
.
removeAllListeners
=
noop
;
process
.
emit
=
noop
;
process
.
prependListener
=
noop
;
process
.
prependOnceListener
=
noop
;
process
.
listeners
=
function
(
name
)
{
return
[
]
}
process
.
binding
=
function
(
name
)
{
throw
new
Error
(
'
process
.
binding
is
not
supported
'
)
;
}
;
process
.
cwd
=
function
(
)
{
return
'
/
'
}
;
process
.
chdir
=
function
(
dir
)
{
throw
new
Error
(
'
process
.
chdir
is
not
supported
'
)
;
}
;
process
.
umask
=
function
(
)
{
return
0
;
}
;
}
)
37
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_37__
;
}
)
413
:
(
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
414
)
;
}
)
414
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
vendored
=
void
0
;
var
devtoolsComponents
=
_interopRequireWildcard
(
__webpack_require__
(
108
)
)
;
var
devtoolsConfig
=
_interopRequireWildcard
(
__webpack_require__
(
415
)
)
;
var
devtoolsContextmenu
=
_interopRequireWildcard
(
__webpack_require__
(
420
)
)
;
var
devtoolsEnvironment
=
_interopRequireWildcard
(
__webpack_require__
(
102
)
)
;
var
devtoolsModules
=
_interopRequireWildcard
(
__webpack_require__
(
538
)
)
;
var
devtoolsUtils
=
_interopRequireWildcard
(
__webpack_require__
(
7
)
)
;
var
fuzzaldrinPlus
=
_interopRequireWildcard
(
__webpack_require__
(
432
)
)
;
var
transition
=
_interopRequireWildcard
(
__webpack_require__
(
435
)
)
;
var
reactAriaComponentsTabs
=
_interopRequireWildcard
(
__webpack_require__
(
438
)
)
;
var
_classnames
=
_interopRequireDefault
(
__webpack_require__
(
67
)
)
;
var
_devtoolsSplitter
=
_interopRequireDefault
(
__webpack_require__
(
445
)
)
;
var
_lodashMove
=
_interopRequireDefault
(
__webpack_require__
(
449
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_getRequireWildcardCache
(
)
{
if
(
typeof
WeakMap
!
=
=
"
function
"
)
return
null
;
var
cache
=
new
WeakMap
(
)
;
_getRequireWildcardCache
=
function
(
)
{
return
cache
;
}
;
return
cache
;
}
function
_interopRequireWildcard
(
obj
)
{
if
(
obj
&
&
obj
.
__esModule
)
{
return
obj
;
}
if
(
obj
=
=
=
null
|
|
typeof
obj
!
=
=
"
object
"
&
&
typeof
obj
!
=
=
"
function
"
)
{
return
{
default
:
obj
}
;
}
var
cache
=
_getRequireWildcardCache
(
)
;
if
(
cache
&
&
cache
.
has
(
obj
)
)
{
return
cache
.
get
(
obj
)
;
}
var
newObj
=
{
}
;
var
hasPropertyDescriptor
=
Object
.
defineProperty
&
&
Object
.
getOwnPropertyDescriptor
;
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
{
var
desc
=
hasPropertyDescriptor
?
Object
.
getOwnPropertyDescriptor
(
obj
key
)
:
null
;
if
(
desc
&
&
(
desc
.
get
|
|
desc
.
set
)
)
{
Object
.
defineProperty
(
newObj
key
desc
)
;
}
else
{
newObj
[
key
]
=
obj
[
key
]
;
}
}
}
newObj
.
default
=
obj
;
if
(
cache
)
{
cache
.
set
(
obj
newObj
)
;
}
return
newObj
;
}
const
vendored
=
{
classnames
:
_classnames
.
default
"
devtools
-
components
"
:
devtoolsComponents
"
devtools
-
config
"
:
devtoolsConfig
"
devtools
-
contextmenu
"
:
devtoolsContextmenu
"
devtools
-
environment
"
:
devtoolsEnvironment
"
devtools
-
modules
"
:
devtoolsModules
"
devtools
-
splitter
"
:
_devtoolsSplitter
.
default
"
devtools
-
utils
"
:
devtoolsUtils
"
fuzzaldrin
-
plus
"
:
fuzzaldrinPlus
"
lodash
-
move
"
:
_lodashMove
.
default
"
react
-
aria
-
components
/
src
/
tabs
"
:
reactAriaComponentsTabs
"
react
-
transition
-
group
/
Transition
"
:
transition
}
;
exports
.
vendored
=
vendored
;
}
)
415
:
(
function
(
module
exports
__webpack_require__
)
{
const
feature
=
__webpack_require__
(
416
)
;
module
.
exports
=
feature
;
}
)
416
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
get
:
pick
set
:
put
}
=
__webpack_require__
(
417
)
;
const
fs
=
__webpack_require__
(
418
)
;
const
path
=
__webpack_require__
(
419
)
;
let
config
;
function
getValue
(
key
)
{
return
pick
(
config
key
)
;
}
function
setValue
(
key
value
)
{
return
put
(
config
key
value
)
;
}
function
setConfig
(
value
)
{
config
=
value
;
}
function
getConfig
(
)
{
return
config
;
}
function
updateLocalConfig
(
relativePath
)
{
const
localConfigPath
=
path
.
resolve
(
relativePath
"
.
.
/
configs
/
local
.
json
"
)
;
const
output
=
JSON
.
stringify
(
config
null
2
)
;
fs
.
writeFileSync
(
localConfigPath
output
{
flag
:
"
w
"
}
)
;
return
output
;
}
module
.
exports
=
{
getValue
setValue
getConfig
setConfig
updateLocalConfig
}
;
}
)
417
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_417__
;
}
)
418
:
(
function
(
module
exports
)
{
}
)
419
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
function
normalizeArray
(
parts
allowAboveRoot
)
{
var
up
=
0
;
for
(
var
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
last
=
parts
[
i
]
;
if
(
last
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
parts
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
parts
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
allowAboveRoot
)
{
for
(
;
up
-
-
;
up
)
{
parts
.
unshift
(
'
.
.
'
)
;
}
}
return
parts
;
}
exports
.
resolve
=
function
(
)
{
var
resolvedPath
=
'
'
resolvedAbsolute
=
false
;
for
(
var
i
=
arguments
.
length
-
1
;
i
>
=
-
1
&
&
!
resolvedAbsolute
;
i
-
-
)
{
var
path
=
(
i
>
=
0
)
?
arguments
[
i
]
:
process
.
cwd
(
)
;
if
(
typeof
path
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
resolve
must
be
strings
'
)
;
}
else
if
(
!
path
)
{
continue
;
}
resolvedPath
=
path
+
'
/
'
+
resolvedPath
;
resolvedAbsolute
=
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
resolvedPath
=
normalizeArray
(
filter
(
resolvedPath
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
resolvedAbsolute
)
.
join
(
'
/
'
)
;
return
(
(
resolvedAbsolute
?
'
/
'
:
'
'
)
+
resolvedPath
)
|
|
'
.
'
;
}
;
exports
.
normalize
=
function
(
path
)
{
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
trailingSlash
=
substr
(
path
-
1
)
=
=
=
'
/
'
;
path
=
normalizeArray
(
filter
(
path
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
isAbsolute
)
.
join
(
'
/
'
)
;
if
(
!
path
&
&
!
isAbsolute
)
{
path
=
'
.
'
;
}
if
(
path
&
&
trailingSlash
)
{
path
+
=
'
/
'
;
}
return
(
isAbsolute
?
'
/
'
:
'
'
)
+
path
;
}
;
exports
.
isAbsolute
=
function
(
path
)
{
return
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
;
exports
.
join
=
function
(
)
{
var
paths
=
Array
.
prototype
.
slice
.
call
(
arguments
0
)
;
return
exports
.
normalize
(
filter
(
paths
function
(
p
index
)
{
if
(
typeof
p
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
join
must
be
strings
'
)
;
}
return
p
;
}
)
.
join
(
'
/
'
)
)
;
}
;
exports
.
relative
=
function
(
from
to
)
{
from
=
exports
.
resolve
(
from
)
.
substr
(
1
)
;
to
=
exports
.
resolve
(
to
)
.
substr
(
1
)
;
function
trim
(
arr
)
{
var
start
=
0
;
for
(
;
start
<
arr
.
length
;
start
+
+
)
{
if
(
arr
[
start
]
!
=
=
'
'
)
break
;
}
var
end
=
arr
.
length
-
1
;
for
(
;
end
>
=
0
;
end
-
-
)
{
if
(
arr
[
end
]
!
=
=
'
'
)
break
;
}
if
(
start
>
end
)
return
[
]
;
return
arr
.
slice
(
start
end
-
start
+
1
)
;
}
var
fromParts
=
trim
(
from
.
split
(
'
/
'
)
)
;
var
toParts
=
trim
(
to
.
split
(
'
/
'
)
)
;
var
length
=
Math
.
min
(
fromParts
.
length
toParts
.
length
)
;
var
samePartsLength
=
length
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
fromParts
[
i
]
!
=
=
toParts
[
i
]
)
{
samePartsLength
=
i
;
break
;
}
}
var
outputParts
=
[
]
;
for
(
var
i
=
samePartsLength
;
i
<
fromParts
.
length
;
i
+
+
)
{
outputParts
.
push
(
'
.
.
'
)
;
}
outputParts
=
outputParts
.
concat
(
toParts
.
slice
(
samePartsLength
)
)
;
return
outputParts
.
join
(
'
/
'
)
;
}
;
exports
.
sep
=
'
/
'
;
exports
.
delimiter
=
'
:
'
;
exports
.
dirname
=
function
(
path
)
{
if
(
typeof
path
!
=
=
'
string
'
)
path
=
path
+
'
'
;
if
(
path
.
length
=
=
=
0
)
return
'
.
'
;
var
code
=
path
.
charCodeAt
(
0
)
;
var
hasRoot
=
code
=
=
=
47
;
var
end
=
-
1
;
var
matchedSlash
=
true
;
for
(
var
i
=
path
.
length
-
1
;
i
>
=
1
;
-
-
i
)
{
code
=
path
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
47
)
{
if
(
!
matchedSlash
)
{
end
=
i
;
break
;
}
}
else
{
matchedSlash
=
false
;
}
}
if
(
end
=
=
=
-
1
)
return
hasRoot
?
'
/
'
:
'
.
'
;
if
(
hasRoot
&
&
end
=
=
=
1
)
{
return
'
/
'
;
}
return
path
.
slice
(
0
end
)
;
}
;
function
basename
(
path
)
{
if
(
typeof
path
!
=
=
'
string
'
)
path
=
path
+
'
'
;
var
start
=
0
;
var
end
=
-
1
;
var
matchedSlash
=
true
;
var
i
;
for
(
i
=
path
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
path
.
charCodeAt
(
i
)
=
=
=
47
)
{
if
(
!
matchedSlash
)
{
start
=
i
+
1
;
break
;
}
}
else
if
(
end
=
=
=
-
1
)
{
matchedSlash
=
false
;
end
=
i
+
1
;
}
}
if
(
end
=
=
=
-
1
)
return
'
'
;
return
path
.
slice
(
start
end
)
;
}
exports
.
basename
=
function
(
path
ext
)
{
var
f
=
basename
(
path
)
;
if
(
ext
&
&
f
.
substr
(
-
1
*
ext
.
length
)
=
=
=
ext
)
{
f
=
f
.
substr
(
0
f
.
length
-
ext
.
length
)
;
}
return
f
;
}
;
exports
.
extname
=
function
(
path
)
{
if
(
typeof
path
!
=
=
'
string
'
)
path
=
path
+
'
'
;
var
startDot
=
-
1
;
var
startPart
=
0
;
var
end
=
-
1
;
var
matchedSlash
=
true
;
var
preDotState
=
0
;
for
(
var
i
=
path
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
code
=
path
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
47
)
{
if
(
!
matchedSlash
)
{
startPart
=
i
+
1
;
break
;
}
continue
;
}
if
(
end
=
=
=
-
1
)
{
matchedSlash
=
false
;
end
=
i
+
1
;
}
if
(
code
=
=
=
46
)
{
if
(
startDot
=
=
=
-
1
)
startDot
=
i
;
else
if
(
preDotState
!
=
=
1
)
preDotState
=
1
;
}
else
if
(
startDot
!
=
=
-
1
)
{
preDotState
=
-
1
;
}
}
if
(
startDot
=
=
=
-
1
|
|
end
=
=
=
-
1
|
|
preDotState
=
=
=
0
|
|
preDotState
=
=
=
1
&
&
startDot
=
=
=
end
-
1
&
&
startDot
=
=
=
startPart
+
1
)
{
return
'
'
;
}
return
path
.
slice
(
startDot
end
)
;
}
;
function
filter
(
xs
f
)
{
if
(
xs
.
filter
)
return
xs
.
filter
(
f
)
;
var
res
=
[
]
;
for
(
var
i
=
0
;
i
<
xs
.
length
;
i
+
+
)
{
if
(
f
(
xs
[
i
]
i
xs
)
)
res
.
push
(
xs
[
i
]
)
;
}
return
res
;
}
var
substr
=
'
ab
'
.
substr
(
-
1
)
=
=
=
'
b
'
?
function
(
str
start
len
)
{
return
str
.
substr
(
start
len
)
}
:
function
(
str
start
len
)
{
if
(
start
<
0
)
start
=
str
.
length
+
start
;
return
str
.
substr
(
start
len
)
;
}
;
}
.
call
(
exports
__webpack_require__
(
35
)
)
)
}
)
420
:
(
function
(
module
exports
__webpack_require__
)
{
const
Menu
=
__webpack_require__
(
490
)
;
const
MenuItem
=
__webpack_require__
(
491
)
;
function
inToolbox
(
)
{
try
{
return
window
.
parent
.
document
.
documentURI
.
startsWith
(
"
about
:
devtools
-
toolbox
"
)
;
}
catch
(
e
)
{
return
true
;
}
}
if
(
!
inToolbox
(
)
)
{
__webpack_require__
(
431
)
;
}
function
createPopup
(
doc
)
{
let
popup
=
doc
.
createElement
(
"
menupopup
"
)
;
popup
.
className
=
"
landing
-
popup
"
;
if
(
popup
.
openPopupAtScreen
)
{
return
popup
;
}
function
preventDefault
(
e
)
{
e
.
preventDefault
(
)
;
e
.
returnValue
=
false
;
}
let
mask
=
document
.
querySelector
(
"
#
contextmenu
-
mask
"
)
;
if
(
!
mask
)
{
mask
=
doc
.
createElement
(
"
div
"
)
;
mask
.
id
=
"
contextmenu
-
mask
"
;
document
.
body
.
appendChild
(
mask
)
;
}
mask
.
onclick
=
(
)
=
>
popup
.
hidePopup
(
)
;
popup
.
openPopupAtScreen
=
function
(
clientX
clientY
)
{
this
.
style
.
setProperty
(
"
left
"
{
clientX
}
px
)
;
this
.
style
.
setProperty
(
"
top
"
{
clientY
}
px
)
;
mask
=
document
.
querySelector
(
"
#
contextmenu
-
mask
"
)
;
window
.
onwheel
=
preventDefault
;
mask
.
classList
.
add
(
"
show
"
)
;
this
.
dispatchEvent
(
new
Event
(
"
popupshown
"
)
)
;
this
.
popupshown
;
}
;
popup
.
hidePopup
=
function
(
)
{
this
.
remove
(
)
;
mask
=
document
.
querySelector
(
"
#
contextmenu
-
mask
"
)
;
mask
.
classList
.
remove
(
"
show
"
)
;
window
.
onwheel
=
null
;
}
;
return
popup
;
}
if
(
!
inToolbox
(
)
)
{
Menu
.
prototype
.
createPopup
=
createPopup
;
}
function
onShown
(
menu
popup
)
{
popup
.
childNodes
.
forEach
(
(
menuItemNode
i
)
=
>
{
let
item
=
menu
.
items
[
i
]
;
if
(
!
item
.
disabled
&
&
item
.
visible
)
{
menuItemNode
.
onclick
=
(
)
=
>
{
item
.
click
(
)
;
popup
.
hidePopup
(
)
;
}
;
showSubMenu
(
item
.
submenu
menuItemNode
popup
)
;
}
}
)
;
}
function
showMenu
(
evt
items
)
{
if
(
items
.
length
=
=
=
0
)
{
return
;
}
let
menu
=
new
Menu
(
)
;
items
.
filter
(
item
=
>
item
.
visible
=
=
=
undefined
|
|
item
.
visible
=
=
=
true
)
.
forEach
(
item
=
>
{
let
menuItem
=
new
MenuItem
(
item
)
;
menuItem
.
submenu
=
createSubMenu
(
item
.
submenu
)
;
menu
.
append
(
menuItem
)
;
}
)
;
if
(
inToolbox
(
)
)
{
menu
.
popup
(
evt
.
screenX
evt
.
screenY
window
.
parent
.
document
)
;
return
;
}
menu
.
on
(
"
open
"
(
_
popup
)
=
>
onShown
(
menu
popup
)
)
;
menu
.
popup
(
evt
.
clientX
evt
.
clientY
document
)
;
}
function
createSubMenu
(
subItems
)
{
if
(
subItems
)
{
let
subMenu
=
new
Menu
(
)
;
subItems
.
forEach
(
subItem
=
>
{
subMenu
.
append
(
new
MenuItem
(
subItem
)
)
;
}
)
;
return
subMenu
;
}
return
null
;
}
function
showSubMenu
(
subMenu
menuItemNode
popup
)
{
if
(
subMenu
)
{
let
subMenuNode
=
menuItemNode
.
querySelector
(
"
menupopup
"
)
;
let
{
top
}
=
menuItemNode
.
getBoundingClientRect
(
)
;
let
{
left
width
}
=
popup
.
getBoundingClientRect
(
)
;
subMenuNode
.
style
.
setProperty
(
"
left
"
{
left
+
width
-
1
}
px
)
;
subMenuNode
.
style
.
setProperty
(
"
top
"
{
top
}
px
)
;
let
subMenuItemNodes
=
menuItemNode
.
querySelector
(
"
menupopup
:
not
(
.
landing
-
popup
)
"
)
.
childNodes
;
subMenuItemNodes
.
forEach
(
(
subMenuItemNode
j
)
=
>
{
let
subMenuItem
=
subMenu
.
items
.
filter
(
item
=
>
item
.
visible
=
=
=
undefined
|
|
item
.
visible
=
=
=
true
)
[
j
]
;
if
(
!
subMenuItem
.
disabled
&
&
subMenuItem
.
visible
)
{
subMenuItemNode
.
onclick
=
(
)
=
>
{
subMenuItem
.
click
(
)
;
popup
.
hidePopup
(
)
;
}
;
}
}
)
;
}
}
function
buildMenu
(
items
)
{
return
items
.
map
(
itm
=
>
{
const
hide
=
typeof
itm
.
hidden
=
=
=
"
function
"
?
itm
.
hidden
(
)
:
itm
.
hidden
;
return
hide
?
null
:
itm
.
item
;
}
)
.
filter
(
itm
=
>
itm
!
=
=
null
)
;
}
module
.
exports
=
{
showMenu
buildMenu
}
;
}
)
431
:
(
function
(
module
exports
)
{
}
)
432
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
(
function
(
)
{
var
Query
defaultPathSeparator
filter
matcher
parseOptions
pathScorer
preparedQueryCache
scorer
;
filter
=
__webpack_require__
(
433
)
;
matcher
=
__webpack_require__
(
434
)
;
scorer
=
__webpack_require__
(
66
)
;
pathScorer
=
__webpack_require__
(
111
)
;
Query
=
__webpack_require__
(
184
)
;
preparedQueryCache
=
null
;
defaultPathSeparator
=
(
typeof
process
!
=
=
"
undefined
"
&
&
process
!
=
=
null
?
process
.
platform
:
void
0
)
=
=
=
"
win32
"
?
'
\
\
'
:
'
/
'
;
module
.
exports
=
{
filter
:
function
(
candidates
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
(
(
query
!
=
null
?
query
.
length
:
void
0
)
&
&
(
candidates
!
=
null
?
candidates
.
length
:
void
0
)
)
)
{
return
[
]
;
}
options
=
parseOptions
(
options
query
)
;
return
filter
(
candidates
query
options
)
;
}
score
:
function
(
string
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
(
(
string
!
=
null
?
string
.
length
:
void
0
)
&
&
(
query
!
=
null
?
query
.
length
:
void
0
)
)
)
{
return
0
;
}
options
=
parseOptions
(
options
query
)
;
if
(
options
.
usePathScoring
)
{
return
pathScorer
.
score
(
string
query
options
)
;
}
else
{
return
scorer
.
score
(
string
query
options
)
;
}
}
match
:
function
(
string
query
options
)
{
var
_i
_ref
_results
;
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
string
)
{
return
[
]
;
}
if
(
!
query
)
{
return
[
]
;
}
if
(
string
=
=
=
query
)
{
return
(
function
(
)
{
_results
=
[
]
;
for
(
var
_i
=
0
_ref
=
string
.
length
;
0
<
=
_ref
?
_i
<
_ref
:
_i
>
_ref
;
0
<
=
_ref
?
_i
+
+
:
_i
-
-
)
{
_results
.
push
(
_i
)
;
}
return
_results
;
}
)
.
apply
(
this
)
;
}
options
=
parseOptions
(
options
query
)
;
return
matcher
.
match
(
string
query
options
)
;
}
wrap
:
function
(
string
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
string
)
{
return
[
]
;
}
if
(
!
query
)
{
return
[
]
;
}
options
=
parseOptions
(
options
query
)
;
return
matcher
.
wrap
(
string
query
options
)
;
}
prepareQuery
:
function
(
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
options
=
parseOptions
(
options
query
)
;
return
options
.
preparedQuery
;
}
}
;
parseOptions
=
function
(
options
query
)
{
if
(
options
.
allowErrors
=
=
null
)
{
options
.
allowErrors
=
false
;
}
if
(
options
.
usePathScoring
=
=
null
)
{
options
.
usePathScoring
=
true
;
}
if
(
options
.
useExtensionBonus
=
=
null
)
{
options
.
useExtensionBonus
=
false
;
}
if
(
options
.
pathSeparator
=
=
null
)
{
options
.
pathSeparator
=
defaultPathSeparator
;
}
if
(
options
.
optCharRegEx
=
=
null
)
{
options
.
optCharRegEx
=
null
;
}
if
(
options
.
wrap
=
=
null
)
{
options
.
wrap
=
null
;
}
if
(
options
.
preparedQuery
=
=
null
)
{
options
.
preparedQuery
=
preparedQueryCache
&
&
preparedQueryCache
.
query
=
=
=
query
?
preparedQueryCache
:
(
preparedQueryCache
=
new
Query
(
query
options
)
)
;
}
return
options
;
}
;
}
)
.
call
(
this
)
;
}
.
call
(
exports
__webpack_require__
(
35
)
)
)
}
)
433
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
Query
pathScorer
pluckCandidates
scorer
sortCandidates
;
scorer
=
__webpack_require__
(
66
)
;
pathScorer
=
__webpack_require__
(
111
)
;
Query
=
__webpack_require__
(
184
)
;
pluckCandidates
=
function
(
a
)
{
return
a
.
candidate
;
}
;
sortCandidates
=
function
(
a
b
)
{
return
b
.
score
-
a
.
score
;
}
;
module
.
exports
=
function
(
candidates
query
options
)
{
var
bKey
candidate
key
maxInners
maxResults
score
scoreProvider
scoredCandidates
spotLeft
string
usePathScoring
_i
_len
;
scoredCandidates
=
[
]
;
key
=
options
.
key
maxResults
=
options
.
maxResults
maxInners
=
options
.
maxInners
usePathScoring
=
options
.
usePathScoring
;
spotLeft
=
(
maxInners
!
=
null
)
&
&
maxInners
>
0
?
maxInners
:
candidates
.
length
+
1
;
bKey
=
key
!
=
null
;
scoreProvider
=
usePathScoring
?
pathScorer
:
scorer
;
for
(
_i
=
0
_len
=
candidates
.
length
;
_i
<
_len
;
_i
+
+
)
{
candidate
=
candidates
[
_i
]
;
string
=
bKey
?
candidate
[
key
]
:
candidate
;
if
(
!
string
)
{
continue
;
}
score
=
scoreProvider
.
score
(
string
query
options
)
;
if
(
score
>
0
)
{
scoredCandidates
.
push
(
{
candidate
:
candidate
score
:
score
}
)
;
if
(
!
-
-
spotLeft
)
{
break
;
}
}
}
scoredCandidates
.
sort
(
sortCandidates
)
;
candidates
=
scoredCandidates
.
map
(
pluckCandidates
)
;
if
(
maxResults
!
=
null
)
{
candidates
=
candidates
.
slice
(
0
maxResults
)
;
}
return
candidates
;
}
;
}
)
.
call
(
this
)
;
}
)
434
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
basenameMatch
computeMatch
isMatch
isWordStart
match
mergeMatches
scoreAcronyms
scoreCharacter
scoreConsecutives
_ref
;
_ref
=
__webpack_require__
(
66
)
isMatch
=
_ref
.
isMatch
isWordStart
=
_ref
.
isWordStart
scoreConsecutives
=
_ref
.
scoreConsecutives
scoreCharacter
=
_ref
.
scoreCharacter
scoreAcronyms
=
_ref
.
scoreAcronyms
;
exports
.
match
=
match
=
function
(
string
query
options
)
{
var
allowErrors
baseMatches
matches
pathSeparator
preparedQuery
string_lw
;
allowErrors
=
options
.
allowErrors
preparedQuery
=
options
.
preparedQuery
pathSeparator
=
options
.
pathSeparator
;
if
(
!
(
allowErrors
|
|
isMatch
(
string
preparedQuery
.
core_lw
preparedQuery
.
core_up
)
)
)
{
return
[
]
;
}
string_lw
=
string
.
toLowerCase
(
)
;
matches
=
computeMatch
(
string
string_lw
preparedQuery
)
;
if
(
matches
.
length
=
=
=
0
)
{
return
matches
;
}
if
(
string
.
indexOf
(
pathSeparator
)
>
-
1
)
{
baseMatches
=
basenameMatch
(
string
string_lw
preparedQuery
pathSeparator
)
;
matches
=
mergeMatches
(
matches
baseMatches
)
;
}
return
matches
;
}
;
exports
.
wrap
=
function
(
string
query
options
)
{
var
matchIndex
matchPos
matchPositions
output
strPos
tagClass
tagClose
tagOpen
_ref1
;
if
(
(
options
.
wrap
!
=
null
)
)
{
_ref1
=
options
.
wrap
tagClass
=
_ref1
.
tagClass
tagOpen
=
_ref1
.
tagOpen
tagClose
=
_ref1
.
tagClose
;
}
if
(
tagClass
=
=
null
)
{
tagClass
=
'
highlight
'
;
}
if
(
tagOpen
=
=
null
)
{
tagOpen
=
'
<
strong
class
=
"
'
+
tagClass
+
'
"
>
'
;
}
if
(
tagClose
=
=
null
)
{
tagClose
=
'
<
/
strong
>
'
;
}
if
(
string
=
=
=
query
)
{
return
tagOpen
+
string
+
tagClose
;
}
matchPositions
=
match
(
string
query
options
)
;
if
(
matchPositions
.
length
=
=
=
0
)
{
return
string
;
}
output
=
'
'
;
matchIndex
=
-
1
;
strPos
=
0
;
while
(
+
+
matchIndex
<
matchPositions
.
length
)
{
matchPos
=
matchPositions
[
matchIndex
]
;
if
(
matchPos
>
strPos
)
{
output
+
=
string
.
substring
(
strPos
matchPos
)
;
strPos
=
matchPos
;
}
while
(
+
+
matchIndex
<
matchPositions
.
length
)
{
if
(
matchPositions
[
matchIndex
]
=
=
=
matchPos
+
1
)
{
matchPos
+
+
;
}
else
{
matchIndex
-
-
;
break
;
}
}
matchPos
+
+
;
if
(
matchPos
>
strPos
)
{
output
+
=
tagOpen
;
output
+
=
string
.
substring
(
strPos
matchPos
)
;
output
+
=
tagClose
;
strPos
=
matchPos
;
}
}
if
(
strPos
<
=
string
.
length
-
1
)
{
output
+
=
string
.
substring
(
strPos
)
;
}
return
output
;
}
;
basenameMatch
=
function
(
subject
subject_lw
preparedQuery
pathSeparator
)
{
var
basePos
depth
end
;
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
pathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
pathSeparator
end
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
depth
=
preparedQuery
.
depth
;
while
(
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
pathSeparator
basePos
-
1
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
}
basePos
+
+
;
end
+
+
;
return
computeMatch
(
subject
.
slice
(
basePos
end
)
subject_lw
.
slice
(
basePos
end
)
preparedQuery
basePos
)
;
}
;
mergeMatches
=
function
(
a
b
)
{
var
ai
bj
i
j
m
n
out
;
m
=
a
.
length
;
n
=
b
.
length
;
if
(
n
=
=
=
0
)
{
return
a
.
slice
(
)
;
}
if
(
m
=
=
=
0
)
{
return
b
.
slice
(
)
;
}
i
=
-
1
;
j
=
0
;
bj
=
b
[
j
]
;
out
=
[
]
;
while
(
+
+
i
<
m
)
{
ai
=
a
[
i
]
;
while
(
bj
<
=
ai
&
&
+
+
j
<
n
)
{
if
(
bj
<
ai
)
{
out
.
push
(
bj
)
;
}
bj
=
b
[
j
]
;
}
out
.
push
(
ai
)
;
}
while
(
j
<
n
)
{
out
.
push
(
b
[
j
+
+
]
)
;
}
return
out
;
}
;
computeMatch
=
function
(
subject
subject_lw
preparedQuery
offset
)
{
var
DIAGONAL
LEFT
STOP
UP
acro_score
align
backtrack
csc_diag
csc_row
csc_score
i
j
m
matches
move
n
pos
query
query_lw
score
score_diag
score_row
score_up
si_lw
start
trace
;
if
(
offset
=
=
null
)
{
offset
=
0
;
}
query
=
preparedQuery
.
query
;
query_lw
=
preparedQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro_score
=
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
.
score
;
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
STOP
=
0
;
UP
=
1
;
LEFT
=
2
;
DIAGONAL
=
3
;
trace
=
new
Array
(
m
*
n
)
;
pos
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
score
=
0
;
score_up
=
0
;
csc_diag
=
0
;
si_lw
=
subject_lw
[
i
]
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
csc_score
=
0
;
align
=
0
;
score_diag
=
score_up
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
}
score_up
=
score_row
[
j
]
;
csc_diag
=
csc_row
[
j
]
;
if
(
score
>
score_up
)
{
move
=
LEFT
;
}
else
{
score
=
score_up
;
move
=
UP
;
}
if
(
align
>
score
)
{
score
=
align
;
move
=
DIAGONAL
;
}
else
{
csc_score
=
0
;
}
score_row
[
j
]
=
score
;
csc_row
[
j
]
=
csc_score
;
trace
[
+
+
pos
]
=
score
>
0
?
move
:
STOP
;
}
}
i
=
m
-
1
;
j
=
n
-
1
;
pos
=
i
*
n
+
j
;
backtrack
=
true
;
matches
=
[
]
;
while
(
backtrack
&
&
i
>
=
0
&
&
j
>
=
0
)
{
switch
(
trace
[
pos
]
)
{
case
UP
:
i
-
-
;
pos
-
=
n
;
break
;
case
LEFT
:
j
-
-
;
pos
-
-
;
break
;
case
DIAGONAL
:
matches
.
push
(
i
+
offset
)
;
j
-
-
;
i
-
-
;
pos
-
=
n
+
1
;
break
;
default
:
backtrack
=
false
;
}
}
matches
.
reverse
(
)
;
return
matches
;
}
;
}
)
.
call
(
this
)
;
}
)
435
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
default
=
exports
.
EXITING
=
exports
.
ENTERED
=
exports
.
ENTERING
=
exports
.
EXITED
=
exports
.
UNMOUNTED
=
void
0
;
var
PropTypes
=
_interopRequireWildcard
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_reactDom
=
_interopRequireDefault
(
__webpack_require__
(
112
)
)
;
var
_reactLifecyclesCompat
=
__webpack_require__
(
436
)
;
var
_PropTypes
=
__webpack_require__
(
437
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_interopRequireWildcard
(
obj
)
{
if
(
obj
&
&
obj
.
__esModule
)
{
return
obj
;
}
else
{
var
newObj
=
{
}
;
if
(
obj
!
=
null
)
{
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
{
var
desc
=
Object
.
defineProperty
&
&
Object
.
getOwnPropertyDescriptor
?
Object
.
getOwnPropertyDescriptor
(
obj
key
)
:
{
}
;
if
(
desc
.
get
|
|
desc
.
set
)
{
Object
.
defineProperty
(
newObj
key
desc
)
;
}
else
{
newObj
[
key
]
=
obj
[
key
]
;
}
}
}
}
newObj
.
default
=
obj
;
return
newObj
;
}
}
function
_objectWithoutPropertiesLoose
(
source
excluded
)
{
if
(
source
=
=
null
)
return
{
}
;
var
target
=
{
}
;
var
sourceKeys
=
Object
.
keys
(
source
)
;
var
key
i
;
for
(
i
=
0
;
i
<
sourceKeys
.
length
;
i
+
+
)
{
key
=
sourceKeys
[
i
]
;
if
(
excluded
.
indexOf
(
key
)
>
=
0
)
continue
;
target
[
key
]
=
source
[
key
]
;
}
return
target
;
}
function
_inheritsLoose
(
subClass
superClass
)
{
subClass
.
prototype
=
Object
.
create
(
superClass
.
prototype
)
;
subClass
.
prototype
.
constructor
=
subClass
;
subClass
.
__proto__
=
superClass
;
}
var
UNMOUNTED
=
'
unmounted
'
;
exports
.
UNMOUNTED
=
UNMOUNTED
;
var
EXITED
=
'
exited
'
;
exports
.
EXITED
=
EXITED
;
var
ENTERING
=
'
entering
'
;
exports
.
ENTERING
=
ENTERING
;
var
ENTERED
=
'
entered
'
;
exports
.
ENTERED
=
ENTERED
;
var
EXITING
=
'
exiting
'
;
exports
.
EXITING
=
EXITING
;
var
Transition
=
function
(
_React
Component
)
{
_inheritsLoose
(
Transition
_React
Component
)
;
function
Transition
(
props
context
)
{
var
_this
;
_this
=
_React
Component
.
call
(
this
props
context
)
|
|
this
;
var
parentGroup
=
context
.
transitionGroup
;
var
appear
=
parentGroup
&
&
!
parentGroup
.
isMounting
?
props
.
enter
:
props
.
appear
;
var
initialStatus
;
_this
.
appearStatus
=
null
;
if
(
props
.
in
)
{
if
(
appear
)
{
initialStatus
=
EXITED
;
_this
.
appearStatus
=
ENTERING
;
}
else
{
initialStatus
=
ENTERED
;
}
}
else
{
if
(
props
.
unmountOnExit
|
|
props
.
mountOnEnter
)
{
initialStatus
=
UNMOUNTED
;
}
else
{
initialStatus
=
EXITED
;
}
}
_this
.
state
=
{
status
:
initialStatus
}
;
_this
.
nextCallback
=
null
;
return
_this
;
}
var
_proto
=
Transition
.
prototype
;
_proto
.
getChildContext
=
function
getChildContext
(
)
{
return
{
transitionGroup
:
null
}
;
}
;
Transition
.
getDerivedStateFromProps
=
function
getDerivedStateFromProps
(
_ref
prevState
)
{
var
nextIn
=
_ref
.
in
;
if
(
nextIn
&
&
prevState
.
status
=
=
=
UNMOUNTED
)
{
return
{
status
:
EXITED
}
;
}
return
null
;
}
;
_proto
.
componentDidMount
=
function
componentDidMount
(
)
{
this
.
updateStatus
(
true
this
.
appearStatus
)
;
}
;
_proto
.
componentDidUpdate
=
function
componentDidUpdate
(
prevProps
)
{
var
nextStatus
=
null
;
if
(
prevProps
!
=
=
this
.
props
)
{
var
status
=
this
.
state
.
status
;
if
(
this
.
props
.
in
)
{
if
(
status
!
=
=
ENTERING
&
&
status
!
=
=
ENTERED
)
{
nextStatus
=
ENTERING
;
}
}
else
{
if
(
status
=
=
=
ENTERING
|
|
status
=
=
=
ENTERED
)
{
nextStatus
=
EXITING
;
}
}
}
this
.
updateStatus
(
false
nextStatus
)
;
}
;
_proto
.
componentWillUnmount
=
function
componentWillUnmount
(
)
{
this
.
cancelNextCallback
(
)
;
}
;
_proto
.
getTimeouts
=
function
getTimeouts
(
)
{
var
timeout
=
this
.
props
.
timeout
;
var
exit
enter
appear
;
exit
=
enter
=
appear
=
timeout
;
if
(
timeout
!
=
null
&
&
typeof
timeout
!
=
=
'
number
'
)
{
exit
=
timeout
.
exit
;
enter
=
timeout
.
enter
;
appear
=
timeout
.
appear
!
=
=
undefined
?
timeout
.
appear
:
enter
;
}
return
{
exit
:
exit
enter
:
enter
appear
:
appear
}
;
}
;
_proto
.
updateStatus
=
function
updateStatus
(
mounting
nextStatus
)
{
if
(
mounting
=
=
=
void
0
)
{
mounting
=
false
;
}
if
(
nextStatus
!
=
=
null
)
{
this
.
cancelNextCallback
(
)
;
var
node
=
_reactDom
.
default
.
findDOMNode
(
this
)
;
if
(
nextStatus
=
=
=
ENTERING
)
{
this
.
performEnter
(
node
mounting
)
;
}
else
{
this
.
performExit
(
node
)
;
}
}
else
if
(
this
.
props
.
unmountOnExit
&
&
this
.
state
.
status
=
=
=
EXITED
)
{
this
.
setState
(
{
status
:
UNMOUNTED
}
)
;
}
}
;
_proto
.
performEnter
=
function
performEnter
(
node
mounting
)
{
var
_this2
=
this
;
var
enter
=
this
.
props
.
enter
;
var
appearing
=
this
.
context
.
transitionGroup
?
this
.
context
.
transitionGroup
.
isMounting
:
mounting
;
var
timeouts
=
this
.
getTimeouts
(
)
;
var
enterTimeout
=
appearing
?
timeouts
.
appear
:
timeouts
.
enter
;
if
(
!
mounting
&
&
!
enter
)
{
this
.
safeSetState
(
{
status
:
ENTERED
}
function
(
)
{
_this2
.
props
.
onEntered
(
node
)
;
}
)
;
return
;
}
this
.
props
.
onEnter
(
node
appearing
)
;
this
.
safeSetState
(
{
status
:
ENTERING
}
function
(
)
{
_this2
.
props
.
onEntering
(
node
appearing
)
;
_this2
.
onTransitionEnd
(
node
enterTimeout
function
(
)
{
_this2
.
safeSetState
(
{
status
:
ENTERED
}
function
(
)
{
_this2
.
props
.
onEntered
(
node
appearing
)
;
}
)
;
}
)
;
}
)
;
}
;
_proto
.
performExit
=
function
performExit
(
node
)
{
var
_this3
=
this
;
var
exit
=
this
.
props
.
exit
;
var
timeouts
=
this
.
getTimeouts
(
)
;
if
(
!
exit
)
{
this
.
safeSetState
(
{
status
:
EXITED
}
function
(
)
{
_this3
.
props
.
onExited
(
node
)
;
}
)
;
return
;
}
this
.
props
.
onExit
(
node
)
;
this
.
safeSetState
(
{
status
:
EXITING
}
function
(
)
{
_this3
.
props
.
onExiting
(
node
)
;
_this3
.
onTransitionEnd
(
node
timeouts
.
exit
function
(
)
{
_this3
.
safeSetState
(
{
status
:
EXITED
}
function
(
)
{
_this3
.
props
.
onExited
(
node
)
;
}
)
;
}
)
;
}
)
;
}
;
_proto
.
cancelNextCallback
=
function
cancelNextCallback
(
)
{
if
(
this
.
nextCallback
!
=
=
null
)
{
this
.
nextCallback
.
cancel
(
)
;
this
.
nextCallback
=
null
;
}
}
;
_proto
.
safeSetState
=
function
safeSetState
(
nextState
callback
)
{
callback
=
this
.
setNextCallback
(
callback
)
;
this
.
setState
(
nextState
callback
)
;
}
;
_proto
.
setNextCallback
=
function
setNextCallback
(
callback
)
{
var
_this4
=
this
;
var
active
=
true
;
this
.
nextCallback
=
function
(
event
)
{
if
(
active
)
{
active
=
false
;
_this4
.
nextCallback
=
null
;
callback
(
event
)
;
}
}
;
this
.
nextCallback
.
cancel
=
function
(
)
{
active
=
false
;
}
;
return
this
.
nextCallback
;
}
;
_proto
.
onTransitionEnd
=
function
onTransitionEnd
(
node
timeout
handler
)
{
this
.
setNextCallback
(
handler
)
;
var
doesNotHaveTimeoutOrListener
=
timeout
=
=
null
&
&
!
this
.
props
.
addEndListener
;
if
(
!
node
|
|
doesNotHaveTimeoutOrListener
)
{
setTimeout
(
this
.
nextCallback
0
)
;
return
;
}
if
(
this
.
props
.
addEndListener
)
{
this
.
props
.
addEndListener
(
node
this
.
nextCallback
)
;
}
if
(
timeout
!
=
null
)
{
setTimeout
(
this
.
nextCallback
timeout
)
;
}
}
;
_proto
.
render
=
function
render
(
)
{
var
status
=
this
.
state
.
status
;
if
(
status
=
=
=
UNMOUNTED
)
{
return
null
;
}
var
_this
props
=
this
.
props
children
=
_this
props
.
children
childProps
=
_objectWithoutPropertiesLoose
(
_this
props
[
"
children
"
]
)
;
delete
childProps
.
in
;
delete
childProps
.
mountOnEnter
;
delete
childProps
.
unmountOnExit
;
delete
childProps
.
appear
;
delete
childProps
.
enter
;
delete
childProps
.
exit
;
delete
childProps
.
timeout
;
delete
childProps
.
addEndListener
;
delete
childProps
.
onEnter
;
delete
childProps
.
onEntering
;
delete
childProps
.
onEntered
;
delete
childProps
.
onExit
;
delete
childProps
.
onExiting
;
delete
childProps
.
onExited
;
if
(
typeof
children
=
=
=
'
function
'
)
{
return
children
(
status
childProps
)
;
}
var
child
=
_react
.
default
.
Children
.
only
(
children
)
;
return
_react
.
default
.
cloneElement
(
child
childProps
)
;
}
;
return
Transition
;
}
(
_react
.
default
.
Component
)
;
Transition
.
contextTypes
=
{
transitionGroup
:
PropTypes
.
object
}
;
Transition
.
childContextTypes
=
{
transitionGroup
:
function
transitionGroup
(
)
{
}
}
;
Transition
.
propTypes
=
false
?
{
children
:
PropTypes
.
oneOfType
(
[
PropTypes
.
func
.
isRequired
PropTypes
.
element
.
isRequired
]
)
.
isRequired
in
:
PropTypes
.
bool
mountOnEnter
:
PropTypes
.
bool
unmountOnExit
:
PropTypes
.
bool
appear
:
PropTypes
.
bool
enter
:
PropTypes
.
bool
exit
:
PropTypes
.
bool
timeout
:
function
timeout
(
props
)
{
var
pt
=
_PropTypes
.
timeoutsShape
;
if
(
!
props
.
addEndListener
)
pt
=
pt
.
isRequired
;
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
return
pt
.
apply
(
void
0
[
props
]
.
concat
(
args
)
)
;
}
addEndListener
:
PropTypes
.
func
onEnter
:
PropTypes
.
func
onEntering
:
PropTypes
.
func
onEntered
:
PropTypes
.
func
onExit
:
PropTypes
.
func
onExiting
:
PropTypes
.
func
onExited
:
PropTypes
.
func
}
:
{
}
;
function
noop
(
)
{
}
Transition
.
defaultProps
=
{
in
:
false
mountOnEnter
:
false
unmountOnExit
:
false
appear
:
false
enter
:
true
exit
:
true
onEnter
:
noop
onEntering
:
noop
onEntered
:
noop
onExit
:
noop
onExiting
:
noop
onExited
:
noop
}
;
Transition
.
UNMOUNTED
=
0
;
Transition
.
EXITED
=
1
;
Transition
.
ENTERING
=
2
;
Transition
.
ENTERED
=
3
;
Transition
.
EXITING
=
4
;
var
_default
=
(
0
_reactLifecyclesCompat
.
polyfill
)
(
Transition
)
;
exports
.
default
=
_default
;
}
)
436
:
(
function
(
module
__webpack_exports__
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
__webpack_exports__
"
__esModule
"
{
value
:
true
}
)
;
__webpack_require__
.
d
(
__webpack_exports__
"
polyfill
"
function
(
)
{
return
polyfill
;
}
)
;
function
componentWillMount
(
)
{
var
state
=
this
.
constructor
.
getDerivedStateFromProps
(
this
.
props
this
.
state
)
;
if
(
state
!
=
=
null
&
&
state
!
=
=
undefined
)
{
this
.
setState
(
state
)
;
}
}
function
componentWillReceiveProps
(
nextProps
)
{
function
updater
(
prevState
)
{
var
state
=
this
.
constructor
.
getDerivedStateFromProps
(
nextProps
prevState
)
;
return
state
!
=
=
null
&
&
state
!
=
=
undefined
?
state
:
null
;
}
this
.
setState
(
updater
.
bind
(
this
)
)
;
}
function
componentWillUpdate
(
nextProps
nextState
)
{
try
{
var
prevProps
=
this
.
props
;
var
prevState
=
this
.
state
;
this
.
props
=
nextProps
;
this
.
state
=
nextState
;
this
.
__reactInternalSnapshotFlag
=
true
;
this
.
__reactInternalSnapshot
=
this
.
getSnapshotBeforeUpdate
(
prevProps
prevState
)
;
}
finally
{
this
.
props
=
prevProps
;
this
.
state
=
prevState
;
}
}
componentWillMount
.
__suppressDeprecationWarning
=
true
;
componentWillReceiveProps
.
__suppressDeprecationWarning
=
true
;
componentWillUpdate
.
__suppressDeprecationWarning
=
true
;
function
polyfill
(
Component
)
{
var
prototype
=
Component
.
prototype
;
if
(
!
prototype
|
|
!
prototype
.
isReactComponent
)
{
throw
new
Error
(
'
Can
only
polyfill
class
components
'
)
;
}
if
(
typeof
Component
.
getDerivedStateFromProps
!
=
=
'
function
'
&
&
typeof
prototype
.
getSnapshotBeforeUpdate
!
=
=
'
function
'
)
{
return
Component
;
}
var
foundWillMountName
=
null
;
var
foundWillReceivePropsName
=
null
;
var
foundWillUpdateName
=
null
;
if
(
typeof
prototype
.
componentWillMount
=
=
=
'
function
'
)
{
foundWillMountName
=
'
componentWillMount
'
;
}
else
if
(
typeof
prototype
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
foundWillMountName
=
'
UNSAFE_componentWillMount
'
;
}
if
(
typeof
prototype
.
componentWillReceiveProps
=
=
=
'
function
'
)
{
foundWillReceivePropsName
=
'
componentWillReceiveProps
'
;
}
else
if
(
typeof
prototype
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
foundWillReceivePropsName
=
'
UNSAFE_componentWillReceiveProps
'
;
}
if
(
typeof
prototype
.
componentWillUpdate
=
=
=
'
function
'
)
{
foundWillUpdateName
=
'
componentWillUpdate
'
;
}
else
if
(
typeof
prototype
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
foundWillUpdateName
=
'
UNSAFE_componentWillUpdate
'
;
}
if
(
foundWillMountName
!
=
=
null
|
|
foundWillReceivePropsName
!
=
=
null
|
|
foundWillUpdateName
!
=
=
null
)
{
var
componentName
=
Component
.
displayName
|
|
Component
.
name
;
var
newApiName
=
typeof
Component
.
getDerivedStateFromProps
=
=
=
'
function
'
?
'
getDerivedStateFromProps
(
)
'
:
'
getSnapshotBeforeUpdate
(
)
'
;
throw
Error
(
'
Unsafe
legacy
lifecycles
will
not
be
called
for
components
using
new
component
APIs
.
\
n
\
n
'
+
componentName
+
'
uses
'
+
newApiName
+
'
but
also
contains
the
following
legacy
lifecycles
:
'
+
(
foundWillMountName
!
=
=
null
?
'
\
n
'
+
foundWillMountName
:
'
'
)
+
(
foundWillReceivePropsName
!
=
=
null
?
'
\
n
'
+
foundWillReceivePropsName
:
'
'
)
+
(
foundWillUpdateName
!
=
=
null
?
'
\
n
'
+
foundWillUpdateName
:
'
'
)
+
'
\
n
\
nThe
above
lifecycles
should
be
removed
.
Learn
more
about
this
warning
here
:
\
n
'
+
'
https
:
/
/
fb
.
me
/
react
-
async
-
component
-
lifecycle
-
hooks
'
)
;
}
if
(
typeof
Component
.
getDerivedStateFromProps
=
=
=
'
function
'
)
{
prototype
.
componentWillMount
=
componentWillMount
;
prototype
.
componentWillReceiveProps
=
componentWillReceiveProps
;
}
if
(
typeof
prototype
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
typeof
prototype
.
componentDidUpdate
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Cannot
polyfill
getSnapshotBeforeUpdate
(
)
for
components
that
do
not
define
componentDidUpdate
(
)
on
the
prototype
'
)
;
}
prototype
.
componentWillUpdate
=
componentWillUpdate
;
var
componentDidUpdate
=
prototype
.
componentDidUpdate
;
prototype
.
componentDidUpdate
=
function
componentDidUpdatePolyfill
(
prevProps
prevState
maybeSnapshot
)
{
var
snapshot
=
this
.
__reactInternalSnapshotFlag
?
this
.
__reactInternalSnapshot
:
maybeSnapshot
;
componentDidUpdate
.
call
(
this
prevProps
prevState
snapshot
)
;
}
;
}
return
Component
;
}
}
)
437
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
classNamesShape
=
exports
.
timeoutsShape
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
var
timeoutsShape
=
false
?
_propTypes
.
default
.
oneOfType
(
[
_propTypes
.
default
.
number
_propTypes
.
default
.
shape
(
{
enter
:
_propTypes
.
default
.
number
exit
:
_propTypes
.
default
.
number
appear
:
_propTypes
.
default
.
number
}
)
.
isRequired
]
)
:
null
;
exports
.
timeoutsShape
=
timeoutsShape
;
var
classNamesShape
=
false
?
_propTypes
.
default
.
oneOfType
(
[
_propTypes
.
default
.
string
_propTypes
.
default
.
shape
(
{
enter
:
_propTypes
.
default
.
string
exit
:
_propTypes
.
default
.
string
active
:
_propTypes
.
default
.
string
}
)
_propTypes
.
default
.
shape
(
{
enter
:
_propTypes
.
default
.
string
enterDone
:
_propTypes
.
default
.
string
enterActive
:
_propTypes
.
default
.
string
exit
:
_propTypes
.
default
.
string
exitDone
:
_propTypes
.
default
.
string
exitActive
:
_propTypes
.
default
.
string
}
)
]
)
:
null
;
exports
.
classNamesShape
=
classNamesShape
;
}
)
438
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
"
TabList
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tabList
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
"
TabPanels
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tabPanels
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
"
Tab
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tab
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
"
Tabs
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tabs
.
default
;
}
}
)
;
var
_tabList
=
_interopRequireDefault
(
__webpack_require__
(
185
)
)
;
var
_tabPanels
=
_interopRequireDefault
(
__webpack_require__
(
187
)
)
;
var
_tab
=
_interopRequireDefault
(
__webpack_require__
(
186
)
)
;
var
_tabs
=
_interopRequireDefault
(
__webpack_require__
(
442
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
}
)
439
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
var
_default
=
_propTypes
.
default
.
object
;
exports
.
default
=
_default
;
}
)
440
:
(
function
(
module
exports
)
{
}
)
441
:
(
function
(
module
exports
)
{
}
)
442
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_uniqueId
=
_interopRequireDefault
(
__webpack_require__
(
443
)
)
;
var
_tabList
=
_interopRequireDefault
(
__webpack_require__
(
185
)
)
;
var
_tabPanels
=
_interopRequireDefault
(
__webpack_require__
(
187
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
class
Tabs
extends
_react
.
default
.
Component
{
constructor
(
)
{
super
(
)
;
this
.
accessibleId
=
(
0
_uniqueId
.
default
)
(
)
;
}
render
(
)
{
const
{
activeIndex
children
className
onActivateTab
}
=
this
.
props
;
const
accessibleId
=
this
.
accessibleId
;
return
_react
.
default
.
createElement
(
"
div
"
{
className
:
className
}
_react
.
default
.
Children
.
map
(
children
child
=
>
{
if
(
!
child
)
{
return
child
;
}
switch
(
child
.
type
)
{
case
_tabList
.
default
:
return
_react
.
default
.
cloneElement
(
child
{
accessibleId
activeIndex
onActivateTab
}
)
;
case
_tabPanels
.
default
:
return
_react
.
default
.
cloneElement
(
child
{
accessibleId
activeIndex
}
)
;
default
:
return
child
;
}
}
)
)
;
}
}
exports
.
default
=
Tabs
;
Tabs
.
propTypes
=
{
activeIndex
:
_propTypes
.
default
.
number
.
isRequired
children
:
_propTypes
.
default
.
node
className
:
_propTypes
.
default
.
string
onActivateTab
:
_propTypes
.
default
.
func
}
;
Tabs
.
defaultProps
=
{
children
:
null
className
:
undefined
onActivateTab
:
(
)
=
>
{
}
}
;
}
)
443
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
uniqueId
;
let
counter
=
0
;
function
uniqueId
(
)
{
counter
+
=
1
;
return
rac
{
counter
}
;
}
}
)
445
:
(
function
(
module
exports
__webpack_require__
)
{
const
SplitBox
=
__webpack_require__
(
446
)
;
module
.
exports
=
SplitBox
;
}
)
446
:
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
6
)
;
const
ReactDOM
=
__webpack_require__
(
112
)
;
const
Draggable
=
React
.
createFactory
(
__webpack_require__
(
447
)
)
;
const
{
Component
}
=
React
;
const
PropTypes
=
__webpack_require__
(
0
)
;
const
dom
=
__webpack_require__
(
1
)
;
__webpack_require__
(
448
)
;
class
SplitBox
extends
Component
{
static
get
propTypes
(
)
{
return
{
className
:
PropTypes
.
string
initialSize
:
PropTypes
.
any
initialWidth
:
PropTypes
.
number
initialHeight
:
PropTypes
.
number
startPanel
:
PropTypes
.
any
startPanelCollapsed
:
PropTypes
.
bool
minSize
:
PropTypes
.
any
maxSize
:
PropTypes
.
any
endPanel
:
PropTypes
.
any
endPanelCollapsed
:
PropTypes
.
bool
endPanelControl
:
PropTypes
.
bool
splitterSize
:
PropTypes
.
number
vert
:
PropTypes
.
bool
style
:
PropTypes
.
object
onResizeEnd
:
PropTypes
.
func
}
;
}
static
get
defaultProps
(
)
{
return
{
splitterSize
:
5
vert
:
true
endPanelControl
:
false
endPanelCollapsed
:
false
startPanelCollapsed
:
false
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
vert
:
props
.
vert
width
:
parseInt
(
props
.
initialWidth
|
|
props
.
initialSize
10
)
height
:
parseInt
(
props
.
initialHeight
|
|
props
.
initialSize
10
)
}
;
this
.
onStartMove
=
this
.
onStartMove
.
bind
(
this
)
;
this
.
onStopMove
=
this
.
onStopMove
.
bind
(
this
)
;
this
.
onMove
=
this
.
onMove
.
bind
(
this
)
;
this
.
preparePanelStyles
=
this
.
preparePanelStyles
.
bind
(
this
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
this
.
props
.
vert
!
=
=
nextProps
.
vert
)
{
this
.
setState
(
{
vert
:
nextProps
.
vert
}
)
;
}
if
(
this
.
props
.
initialSize
!
=
=
nextProps
.
initialSize
|
|
this
.
props
.
initialWidth
!
=
=
nextProps
.
initialWidth
|
|
this
.
props
.
initialHeight
!
=
=
nextProps
.
initialHeight
)
{
this
.
setState
(
{
width
:
parseInt
(
nextProps
.
initialWidth
|
|
nextProps
.
initialSize
10
)
height
:
parseInt
(
nextProps
.
initialHeight
|
|
nextProps
.
initialSize
10
)
}
)
;
}
}
onStartMove
(
)
{
const
splitBox
=
ReactDOM
.
findDOMNode
(
this
)
;
const
doc
=
splitBox
.
ownerDocument
;
const
defaultCursor
=
doc
.
documentElement
.
style
.
cursor
;
doc
.
documentElement
.
style
.
cursor
=
this
.
state
.
vert
?
"
ew
-
resize
"
:
"
ns
-
resize
"
;
splitBox
.
classList
.
add
(
"
dragging
"
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
drag
:
start
"
)
)
;
this
.
setState
(
{
defaultCursor
:
defaultCursor
}
)
;
}
onStopMove
(
)
{
const
splitBox
=
ReactDOM
.
findDOMNode
(
this
)
;
const
doc
=
splitBox
.
ownerDocument
;
doc
.
documentElement
.
style
.
cursor
=
this
.
state
.
defaultCursor
;
splitBox
.
classList
.
remove
(
"
dragging
"
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
drag
:
end
"
)
)
;
if
(
this
.
props
.
onResizeEnd
)
{
this
.
props
.
onResizeEnd
(
this
.
state
.
vert
?
this
.
state
.
width
:
this
.
state
.
height
)
;
}
}
onMove
(
{
clientX
movementY
}
)
{
const
node
=
ReactDOM
.
findDOMNode
(
this
)
;
const
doc
=
node
.
ownerDocument
;
let
targetWidth
;
if
(
this
.
props
.
endPanelControl
)
{
targetWidth
=
node
.
clientWidth
-
clientX
;
movementY
=
-
movementY
;
}
else
{
targetWidth
=
this
.
calcStartPanelWidth
(
{
node
clientX
doc
}
)
;
}
if
(
this
.
state
.
vert
)
{
const
isRtl
=
doc
.
dir
=
=
=
"
rtl
"
;
if
(
isRtl
&
&
this
.
props
.
endPanelControl
)
{
const
fullWidth
=
node
.
clientWidth
+
node
.
offsetLeft
;
targetWidth
=
fullWidth
-
targetWidth
;
}
this
.
setState
(
(
state
props
)
=
>
(
{
width
:
targetWidth
}
)
)
;
}
else
{
this
.
setState
(
(
state
props
)
=
>
(
{
height
:
state
.
height
+
movementY
}
)
)
;
}
}
calcStartPanelWidth
(
options
)
{
const
{
node
clientX
doc
}
=
options
;
const
availableWidth
=
node
.
clientWidth
;
const
maxSize
=
parseInt
(
this
.
props
.
maxSize
10
)
/
100
;
const
maxPossibleWidth
=
Math
.
ceil
(
availableWidth
*
maxSize
)
;
if
(
doc
.
dir
=
=
=
"
rtl
"
)
{
const
fullWidth
=
node
.
clientWidth
+
node
.
offsetLeft
;
const
targetWidth
=
fullWidth
-
clientX
;
return
targetWidth
>
maxPossibleWidth
?
maxPossibleWidth
:
targetWidth
;
}
return
clientX
>
maxPossibleWidth
?
maxPossibleWidth
:
clientX
;
}
preparePanelStyles
(
)
{
const
vert
=
this
.
state
.
vert
;
const
{
minSize
maxSize
startPanelCollapsed
endPanelControl
endPanelCollapsed
}
=
this
.
props
;
let
leftPanelStyle
rightPanelStyle
;
if
(
vert
)
{
const
startWidth
=
endPanelControl
?
null
:
this
.
state
.
width
endWidth
=
endPanelControl
?
this
.
state
.
width
:
null
;
leftPanelStyle
=
{
maxWidth
:
endPanelControl
?
null
:
maxSize
minWidth
:
endPanelControl
?
null
:
minSize
width
:
startPanelCollapsed
?
0
:
startWidth
}
;
rightPanelStyle
=
{
maxWidth
:
endPanelControl
?
maxSize
:
null
minWidth
:
endPanelControl
?
minSize
:
null
width
:
endPanelCollapsed
?
0
:
endWidth
}
;
}
else
{
const
startHeight
=
endPanelControl
?
null
:
this
.
state
.
height
endHeight
=
endPanelControl
?
this
.
state
.
height
:
null
;
leftPanelStyle
=
{
maxHeight
:
endPanelControl
?
null
:
maxSize
minHeight
:
endPanelControl
?
null
:
minSize
height
:
endPanelCollapsed
?
maxSize
:
startHeight
}
;
rightPanelStyle
=
{
maxHeight
:
endPanelControl
?
maxSize
:
null
minHeight
:
endPanelControl
?
minSize
:
null
height
:
startPanelCollapsed
?
maxSize
:
endHeight
}
;
}
return
{
leftPanelStyle
rightPanelStyle
}
;
}
render
(
)
{
const
vert
=
this
.
state
.
vert
;
const
{
startPanelCollapsed
startPanel
endPanel
endPanelControl
splitterSize
endPanelCollapsed
}
=
this
.
props
;
const
style
=
Object
.
assign
(
{
}
this
.
props
.
style
)
;
let
classNames
=
[
"
split
-
box
"
]
;
classNames
.
push
(
vert
?
"
vert
"
:
"
horz
"
)
;
if
(
this
.
props
.
className
)
{
classNames
=
classNames
.
concat
(
this
.
props
.
className
.
split
(
"
"
)
)
;
}
const
{
leftPanelStyle
rightPanelStyle
}
=
this
.
preparePanelStyles
(
)
;
const
splitterStyle
=
{
flex
:
0
0
{
splitterSize
}
px
}
;
return
dom
.
div
(
{
className
:
classNames
.
join
(
"
"
)
style
:
style
}
!
startPanelCollapsed
?
dom
.
div
(
{
className
:
endPanelControl
?
"
uncontrolled
"
:
"
controlled
"
style
:
leftPanelStyle
}
startPanel
)
:
null
Draggable
(
{
className
:
"
splitter
"
style
:
splitterStyle
onStart
:
this
.
onStartMove
onStop
:
this
.
onStopMove
onMove
:
this
.
onMove
}
)
!
endPanelCollapsed
?
dom
.
div
(
{
className
:
endPanelControl
?
"
controlled
"
:
"
uncontrolled
"
style
:
rightPanelStyle
}
endPanel
)
:
null
)
;
}
}
module
.
exports
=
SplitBox
;
}
)
447
:
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
6
)
;
const
ReactDOM
=
__webpack_require__
(
112
)
;
const
{
Component
}
=
React
;
const
PropTypes
=
__webpack_require__
(
0
)
;
const
dom
=
__webpack_require__
(
1
)
;
class
Draggable
extends
Component
{
static
get
propTypes
(
)
{
return
{
onMove
:
PropTypes
.
func
.
isRequired
onStart
:
PropTypes
.
func
onStop
:
PropTypes
.
func
style
:
PropTypes
.
object
className
:
PropTypes
.
string
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
startDragging
=
this
.
startDragging
.
bind
(
this
)
;
this
.
onMove
=
this
.
onMove
.
bind
(
this
)
;
this
.
onUp
=
this
.
onUp
.
bind
(
this
)
;
}
startDragging
(
ev
)
{
ev
.
preventDefault
(
)
;
const
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
addEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
addEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStart
&
&
this
.
props
.
onStart
(
)
;
}
onMove
(
ev
)
{
ev
.
preventDefault
(
)
;
if
(
!
ev
.
target
.
tagName
)
{
return
;
}
this
.
props
.
onMove
(
ev
)
;
}
onUp
(
ev
)
{
ev
.
preventDefault
(
)
;
const
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
removeEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
removeEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStop
&
&
this
.
props
.
onStop
(
)
;
}
render
(
)
{
return
dom
.
div
(
{
style
:
this
.
props
.
style
className
:
this
.
props
.
className
onMouseDown
:
this
.
startDragging
}
)
;
}
}
module
.
exports
=
Draggable
;
}
)
448
:
(
function
(
module
exports
)
{
}
)
449
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
move
;
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
function
move
(
array
moveIndex
toIndex
)
{
var
item
=
array
[
moveIndex
]
;
var
length
=
array
.
length
;
var
diff
=
moveIndex
-
toIndex
;
if
(
diff
>
0
)
{
return
[
]
.
concat
(
_toConsumableArray
(
array
.
slice
(
0
toIndex
)
)
[
item
]
_toConsumableArray
(
array
.
slice
(
toIndex
moveIndex
)
)
_toConsumableArray
(
array
.
slice
(
moveIndex
+
1
length
)
)
)
;
}
else
if
(
diff
<
0
)
{
return
[
]
.
concat
(
_toConsumableArray
(
array
.
slice
(
0
moveIndex
)
)
_toConsumableArray
(
array
.
slice
(
moveIndex
+
1
toIndex
+
1
)
)
[
item
]
_toConsumableArray
(
array
.
slice
(
toIndex
+
1
length
)
)
)
;
}
return
array
;
}
}
)
490
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_490__
;
}
)
491
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_491__
;
}
)
537
:
(
function
(
module
exports
__webpack_require__
)
{
var
EventEmitter
=
function
EventEmitter
(
)
{
}
;
module
.
exports
=
EventEmitter
;
const
promise
=
__webpack_require__
(
540
)
;
EventEmitter
.
decorate
=
function
EventEmitter_decorate
(
aObjectToDecorate
)
{
let
emitter
=
new
EventEmitter
(
)
;
aObjectToDecorate
.
on
=
emitter
.
on
.
bind
(
emitter
)
;
aObjectToDecorate
.
off
=
emitter
.
off
.
bind
(
emitter
)
;
aObjectToDecorate
.
once
=
emitter
.
once
.
bind
(
emitter
)
;
aObjectToDecorate
.
emit
=
emitter
.
emit
.
bind
(
emitter
)
;
}
;
EventEmitter
.
prototype
=
{
on
:
function
EventEmitter_on
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
this
.
_eventEmitterListeners
=
new
Map
(
)
;
if
(
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
[
]
)
;
}
this
.
_eventEmitterListeners
.
get
(
aEvent
)
.
push
(
aListener
)
;
}
once
:
function
EventEmitter_once
(
aEvent
aListener
)
{
let
deferred
=
promise
.
defer
(
)
;
let
handler
=
(
aEvent
aFirstArg
.
.
.
aRest
)
=
>
{
this
.
off
(
aEvent
handler
)
;
if
(
aListener
)
{
aListener
.
apply
(
null
[
aEvent
aFirstArg
.
.
.
aRest
]
)
;
}
deferred
.
resolve
(
aFirstArg
)
;
}
;
handler
.
_originalListener
=
aListener
;
this
.
on
(
aEvent
handler
)
;
return
deferred
.
promise
;
}
off
:
function
EventEmitter_off
(
aEvent
aListener
)
{
if
(
!
this
.
_eventEmitterListeners
)
return
;
let
listeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
if
(
listeners
)
{
this
.
_eventEmitterListeners
.
set
(
aEvent
listeners
.
filter
(
l
=
>
{
return
l
!
=
=
aListener
&
&
l
.
_originalListener
!
=
=
aListener
;
}
)
)
;
}
}
emit
:
function
EventEmitter_emit
(
aEvent
)
{
if
(
!
this
.
_eventEmitterListeners
|
|
!
this
.
_eventEmitterListeners
.
has
(
aEvent
)
)
{
return
;
}
let
originalListeners
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
;
for
(
let
listener
of
this
.
_eventEmitterListeners
.
get
(
aEvent
)
)
{
if
(
!
this
.
_eventEmitterListeners
)
{
break
;
}
if
(
originalListeners
=
=
=
this
.
_eventEmitterListeners
.
get
(
aEvent
)
|
|
this
.
_eventEmitterListeners
.
get
(
aEvent
)
.
some
(
l
=
>
l
=
=
=
listener
)
)
{
try
{
listener
.
apply
(
null
arguments
)
;
}
catch
(
ex
)
{
let
msg
=
ex
+
"
:
"
+
ex
.
stack
;
console
.
log
(
msg
)
;
}
}
}
}
}
;
}
)
538
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
PrefsHelper
}
=
__webpack_require__
(
539
)
;
const
KeyShortcuts
=
__webpack_require__
(
541
)
;
const
{
ZoomKeys
}
=
__webpack_require__
(
542
)
;
const
EventEmitter
=
__webpack_require__
(
537
)
;
const
asyncStorage
=
__webpack_require__
(
543
)
;
const
asyncStoreHelper
=
__webpack_require__
(
549
)
;
const
SourceUtils
=
__webpack_require__
(
544
)
;
const
Telemetry
=
__webpack_require__
(
545
)
;
const
{
getUnicodeHostname
getUnicodeUrlPath
getUnicodeUrl
}
=
__webpack_require__
(
546
)
;
const
PluralForm
=
__webpack_require__
(
547
)
;
const
saveAs
=
__webpack_require__
(
548
)
;
module
.
exports
=
{
KeyShortcuts
PrefsHelper
ZoomKeys
asyncStorage
asyncStoreHelper
EventEmitter
SourceUtils
Telemetry
getUnicodeHostname
getUnicodeUrlPath
getUnicodeUrl
PluralForm
saveAs
}
;
}
)
539
:
(
function
(
module
exports
__webpack_require__
)
{
const
Services
=
__webpack_require__
(
37
)
;
const
EventEmitter
=
__webpack_require__
(
537
)
;
function
PrefsHelper
(
prefsRoot
=
"
"
prefsBlueprint
=
{
}
)
{
EventEmitter
.
decorate
(
this
)
;
let
cache
=
new
Map
(
)
;
for
(
let
accessorName
in
prefsBlueprint
)
{
let
[
prefType
prefName
prefDefault
]
=
prefsBlueprint
[
accessorName
]
;
map
(
this
cache
accessorName
prefType
prefsRoot
prefName
prefDefault
)
;
}
let
observer
=
makeObserver
(
this
cache
prefsRoot
prefsBlueprint
)
;
this
.
registerObserver
=
(
)
=
>
observer
.
register
(
)
;
this
.
unregisterObserver
=
(
)
=
>
observer
.
unregister
(
)
;
}
function
get
(
cache
prefType
prefsRoot
prefName
)
{
let
cachedPref
=
cache
.
get
(
prefName
)
;
if
(
cachedPref
!
=
=
undefined
)
{
return
cachedPref
;
}
let
value
=
Services
.
prefs
[
"
get
"
+
prefType
+
"
Pref
"
]
(
[
prefsRoot
prefName
]
.
join
(
"
.
"
)
)
;
cache
.
set
(
prefName
value
)
;
return
value
;
}
function
set
(
cache
prefType
prefsRoot
prefName
value
)
{
Services
.
prefs
[
"
set
"
+
prefType
+
"
Pref
"
]
(
[
prefsRoot
prefName
]
.
join
(
"
.
"
)
value
)
;
cache
.
set
(
prefName
value
)
;
}
function
map
(
self
cache
accessorName
prefType
prefsRoot
prefName
prefDefault
serializer
=
{
in
:
e
=
>
e
out
:
e
=
>
e
}
)
{
if
(
prefName
in
self
)
{
throw
new
Error
(
Can
'
t
use
{
prefName
}
because
it
overrides
a
property
+
"
on
the
instance
.
"
)
;
}
if
(
prefType
=
=
"
Json
"
)
{
map
(
self
cache
accessorName
"
String
"
prefsRoot
prefName
prefDefault
{
in
:
JSON
.
parse
out
:
JSON
.
stringify
}
)
;
return
;
}
if
(
prefType
=
=
"
Float
"
)
{
map
(
self
cache
accessorName
"
Char
"
prefsRoot
prefName
prefDefault
{
in
:
Number
.
parseFloat
out
:
(
n
)
=
>
n
+
"
"
}
)
;
return
;
}
Object
.
defineProperty
(
self
accessorName
{
get
:
(
)
=
>
{
try
{
return
serializer
.
in
(
get
(
cache
prefType
prefsRoot
prefName
)
)
;
}
catch
(
e
)
{
if
(
typeof
prefDefault
!
=
=
'
undefined
'
)
{
return
prefDefault
;
}
throw
e
;
}
}
set
:
(
e
)
=
>
set
(
cache
prefType
prefsRoot
prefName
serializer
.
out
(
e
)
)
}
)
;
}
function
accessorNameForPref
(
somePrefName
prefsBlueprint
)
{
for
(
let
accessorName
in
prefsBlueprint
)
{
let
[
prefName
]
=
prefsBlueprint
[
accessorName
]
;
if
(
somePrefName
=
=
prefName
)
{
return
accessorName
;
}
}
return
"
"
;
}
function
makeObserver
(
self
cache
prefsRoot
prefsBlueprint
)
{
return
{
register
:
function
(
)
{
this
.
_branch
=
Services
.
prefs
.
getBranch
(
prefsRoot
+
"
.
"
)
;
this
.
_branch
.
addObserver
(
"
"
this
)
;
}
unregister
:
function
(
)
{
this
.
_branch
.
removeObserver
(
"
"
this
)
;
}
observe
:
function
(
subject
topic
prefName
)
{
let
accessorName
=
accessorNameForPref
(
prefName
prefsBlueprint
)
;
if
(
!
(
accessorName
in
self
)
)
{
return
;
}
cache
.
delete
(
prefName
)
;
self
.
emit
(
"
pref
-
changed
"
accessorName
self
[
accessorName
]
)
;
}
}
;
}
exports
.
PrefsHelper
=
PrefsHelper
;
}
)
540
:
(
function
(
module
exports
)
{
let
p
=
typeof
window
!
=
"
undefined
"
?
window
.
Promise
:
Promise
;
p
.
defer
=
function
defer
(
)
{
var
resolve
reject
;
var
promise
=
new
Promise
(
function
(
)
{
resolve
=
arguments
[
0
]
;
reject
=
arguments
[
1
]
;
}
)
;
return
{
resolve
:
resolve
reject
:
reject
promise
:
promise
}
;
}
;
module
.
exports
=
p
;
}
)
541
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
appinfo
}
=
__webpack_require__
(
37
)
;
const
EventEmitter
=
__webpack_require__
(
537
)
;
const
isOSX
=
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
ElectronKeysMapping
=
{
"
F1
"
:
"
DOM_VK_F1
"
"
F2
"
:
"
DOM_VK_F2
"
"
F3
"
:
"
DOM_VK_F3
"
"
F4
"
:
"
DOM_VK_F4
"
"
F5
"
:
"
DOM_VK_F5
"
"
F6
"
:
"
DOM_VK_F6
"
"
F7
"
:
"
DOM_VK_F7
"
"
F8
"
:
"
DOM_VK_F8
"
"
F9
"
:
"
DOM_VK_F9
"
"
F10
"
:
"
DOM_VK_F10
"
"
F11
"
:
"
DOM_VK_F11
"
"
F12
"
:
"
DOM_VK_F12
"
"
F13
"
:
"
DOM_VK_F13
"
"
F14
"
:
"
DOM_VK_F14
"
"
F15
"
:
"
DOM_VK_F15
"
"
F16
"
:
"
DOM_VK_F16
"
"
F17
"
:
"
DOM_VK_F17
"
"
F18
"
:
"
DOM_VK_F18
"
"
F19
"
:
"
DOM_VK_F19
"
"
F20
"
:
"
DOM_VK_F20
"
"
F21
"
:
"
DOM_VK_F21
"
"
F22
"
:
"
DOM_VK_F22
"
"
F23
"
:
"
DOM_VK_F23
"
"
F24
"
:
"
DOM_VK_F24
"
"
Space
"
:
"
DOM_VK_SPACE
"
"
Backspace
"
:
"
DOM_VK_BACK_SPACE
"
"
Delete
"
:
"
DOM_VK_DELETE
"
"
Insert
"
:
"
DOM_VK_INSERT
"
"
Return
"
:
"
DOM_VK_RETURN
"
"
Enter
"
:
"
DOM_VK_RETURN
"
"
Up
"
:
"
DOM_VK_UP
"
"
Down
"
:
"
DOM_VK_DOWN
"
"
Left
"
:
"
DOM_VK_LEFT
"
"
Right
"
:
"
DOM_VK_RIGHT
"
"
Home
"
:
"
DOM_VK_HOME
"
"
End
"
:
"
DOM_VK_END
"
"
PageUp
"
:
"
DOM_VK_PAGE_UP
"
"
PageDown
"
:
"
DOM_VK_PAGE_DOWN
"
"
Escape
"
:
"
DOM_VK_ESCAPE
"
"
Esc
"
:
"
DOM_VK_ESCAPE
"
"
Tab
"
:
"
DOM_VK_TAB
"
"
VolumeUp
"
:
"
DOM_VK_VOLUME_UP
"
"
VolumeDown
"
:
"
DOM_VK_VOLUME_DOWN
"
"
VolumeMute
"
:
"
DOM_VK_VOLUME_MUTE
"
"
PrintScreen
"
:
"
DOM_VK_PRINTSCREEN
"
}
;
function
KeyShortcuts
(
{
window
target
}
)
{
this
.
window
=
window
;
this
.
target
=
target
|
|
window
;
this
.
keys
=
new
Map
(
)
;
this
.
eventEmitter
=
new
EventEmitter
(
)
;
this
.
target
.
addEventListener
(
"
keydown
"
this
)
;
}
KeyShortcuts
.
parseElectronKey
=
function
(
window
str
)
{
let
modifiers
=
str
.
split
(
"
+
"
)
;
let
key
=
modifiers
.
pop
(
)
;
let
shortcut
=
{
ctrl
:
false
meta
:
false
alt
:
false
shift
:
false
key
:
undefined
keyCode
:
undefined
}
;
for
(
let
mod
of
modifiers
)
{
if
(
mod
=
=
=
"
Alt
"
)
{
shortcut
.
alt
=
true
;
}
else
if
(
[
"
Command
"
"
Cmd
"
]
.
includes
(
mod
)
)
{
shortcut
.
meta
=
true
;
}
else
if
(
[
"
CommandOrControl
"
"
CmdOrCtrl
"
]
.
includes
(
mod
)
)
{
if
(
isOSX
)
{
shortcut
.
meta
=
true
;
}
else
{
shortcut
.
ctrl
=
true
;
}
}
else
if
(
[
"
Control
"
"
Ctrl
"
]
.
includes
(
mod
)
)
{
shortcut
.
ctrl
=
true
;
}
else
if
(
mod
=
=
=
"
Shift
"
)
{
shortcut
.
shift
=
true
;
}
else
{
console
.
error
(
"
Unsupported
modifier
:
"
mod
"
from
key
:
"
str
)
;
return
null
;
}
}
if
(
key
=
=
=
"
Plus
"
)
{
key
=
"
+
"
;
}
if
(
typeof
key
=
=
=
"
string
"
&
&
key
.
length
=
=
=
1
)
{
shortcut
.
key
=
key
.
toLowerCase
(
)
;
}
else
if
(
key
in
ElectronKeysMapping
)
{
key
=
ElectronKeysMapping
[
key
]
;
shortcut
.
keyCode
=
window
.
KeyboardEvent
[
key
]
;
shortcut
.
keyCodeString
=
key
;
shortcut
.
key
=
key
;
}
else
{
console
.
error
(
"
Unsupported
key
:
"
key
)
;
return
null
;
}
return
shortcut
;
}
;
KeyShortcuts
.
stringify
=
function
(
shortcut
)
{
let
list
=
[
]
;
if
(
shortcut
.
alt
)
{
list
.
push
(
"
Alt
"
)
;
}
if
(
shortcut
.
ctrl
)
{
list
.
push
(
"
Ctrl
"
)
;
}
if
(
shortcut
.
meta
)
{
list
.
push
(
"
Cmd
"
)
;
}
if
(
shortcut
.
shift
)
{
list
.
push
(
"
Shift
"
)
;
}
let
key
;
if
(
shortcut
.
key
)
{
key
=
shortcut
.
key
.
toUpperCase
(
)
;
}
else
{
key
=
shortcut
.
keyCodeString
;
}
list
.
push
(
key
)
;
return
list
.
join
(
"
+
"
)
;
}
;
KeyShortcuts
.
prototype
=
{
destroy
(
)
{
this
.
target
.
removeEventListener
(
"
keydown
"
this
)
;
this
.
keys
.
clear
(
)
;
}
doesEventMatchShortcut
(
event
shortcut
)
{
if
(
shortcut
.
meta
!
=
event
.
metaKey
)
{
return
false
;
}
if
(
shortcut
.
ctrl
!
=
event
.
ctrlKey
)
{
return
false
;
}
if
(
shortcut
.
alt
!
=
event
.
altKey
)
{
return
false
;
}
if
(
shortcut
.
shift
!
=
event
.
shiftKey
&
&
event
.
key
&
&
event
.
key
.
match
(
/
[
a
-
zA
-
Z
]
/
)
)
{
return
false
;
}
if
(
shortcut
.
keyCode
)
{
return
event
.
keyCode
=
=
shortcut
.
keyCode
;
}
else
if
(
event
.
key
in
ElectronKeysMapping
)
{
return
ElectronKeysMapping
[
event
.
key
]
=
=
=
shortcut
.
key
;
}
let
key
=
event
.
key
|
|
String
.
fromCharCode
(
event
.
keyCode
)
;
return
key
.
toLowerCase
(
)
=
=
shortcut
.
key
|
|
shortcut
.
key
.
match
(
/
^
[
0
-
9
]
/
)
&
&
event
.
keyCode
=
=
shortcut
.
key
.
charCodeAt
(
0
)
;
}
handleEvent
(
event
)
{
for
(
let
[
key
shortcut
]
of
this
.
keys
)
{
if
(
this
.
doesEventMatchShortcut
(
event
shortcut
)
)
{
this
.
eventEmitter
.
emit
(
key
event
)
;
}
}
}
on
(
key
listener
)
{
if
(
typeof
listener
!
=
=
"
function
"
)
{
throw
new
Error
(
"
KeyShortcuts
.
on
(
)
expects
a
function
as
"
+
"
second
argument
"
)
;
}
if
(
!
this
.
keys
.
has
(
key
)
)
{
let
shortcut
=
KeyShortcuts
.
parseElectronKey
(
this
.
window
key
)
;
if
(
!
shortcut
)
{
return
;
}
this
.
keys
.
set
(
key
shortcut
)
;
}
this
.
eventEmitter
.
on
(
key
listener
)
;
}
off
(
key
listener
)
{
this
.
eventEmitter
.
off
(
key
listener
)
;
}
}
;
module
.
exports
=
KeyShortcuts
;
}
)
542
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
exports
.
register
=
function
(
window
)
{
}
;
}
)
543
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
DBNAME
=
"
devtools
-
async
-
storage
"
;
const
DBVERSION
=
1
;
const
STORENAME
=
"
keyvaluepairs
"
;
var
db
=
null
;
function
withStore
(
type
onsuccess
onerror
)
{
if
(
db
)
{
const
transaction
=
db
.
transaction
(
STORENAME
type
)
;
const
store
=
transaction
.
objectStore
(
STORENAME
)
;
onsuccess
(
store
)
;
}
else
{
const
openreq
=
indexedDB
.
open
(
DBNAME
DBVERSION
)
;
openreq
.
onerror
=
function
withStoreOnError
(
)
{
onerror
(
)
;
}
;
openreq
.
onupgradeneeded
=
function
withStoreOnUpgradeNeeded
(
)
{
openreq
.
result
.
createObjectStore
(
STORENAME
)
;
}
;
openreq
.
onsuccess
=
function
withStoreOnSuccess
(
)
{
db
=
openreq
.
result
;
const
transaction
=
db
.
transaction
(
STORENAME
type
)
;
const
store
=
transaction
.
objectStore
(
STORENAME
)
;
onsuccess
(
store
)
;
}
;
}
}
function
getItem
(
itemKey
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
req
;
withStore
(
"
readonly
"
store
=
>
{
store
.
transaction
.
oncomplete
=
function
onComplete
(
)
{
let
value
=
req
.
result
;
if
(
value
=
=
=
undefined
)
{
value
=
null
;
}
resolve
(
value
)
;
}
;
req
=
store
.
get
(
itemKey
)
;
req
.
onerror
=
function
getItemOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
getItem
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
setItem
(
itemKey
value
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
withStore
(
"
readwrite
"
store
=
>
{
store
.
transaction
.
oncomplete
=
resolve
;
const
req
=
store
.
put
(
value
itemKey
)
;
req
.
onerror
=
function
setItemOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
setItem
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
removeItem
(
itemKey
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
withStore
(
"
readwrite
"
store
=
>
{
store
.
transaction
.
oncomplete
=
resolve
;
const
req
=
store
.
delete
(
itemKey
)
;
req
.
onerror
=
function
removeItemOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
removeItem
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
clear
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
withStore
(
"
readwrite
"
store
=
>
{
store
.
transaction
.
oncomplete
=
resolve
;
const
req
=
store
.
clear
(
)
;
req
.
onerror
=
function
clearOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
clear
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
length
(
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
req
;
withStore
(
"
readonly
"
store
=
>
{
store
.
transaction
.
oncomplete
=
function
onComplete
(
)
{
resolve
(
req
.
result
)
;
}
;
req
=
store
.
count
(
)
;
req
.
onerror
=
function
lengthOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
length
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
function
key
(
n
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
n
<
0
)
{
resolve
(
null
)
;
return
;
}
let
req
;
withStore
(
"
readonly
"
store
=
>
{
store
.
transaction
.
oncomplete
=
function
onComplete
(
)
{
const
cursor
=
req
.
result
;
resolve
(
cursor
?
cursor
.
key
:
null
)
;
}
;
let
advanced
=
false
;
req
=
store
.
openCursor
(
)
;
req
.
onsuccess
=
function
keyOnSuccess
(
)
{
const
cursor
=
req
.
result
;
if
(
!
cursor
)
{
return
;
}
if
(
n
=
=
=
0
|
|
advanced
)
{
return
;
}
advanced
=
true
;
cursor
.
advance
(
n
)
;
}
;
req
.
onerror
=
function
keyOnError
(
)
{
reject
(
"
Error
in
asyncStorage
.
key
(
)
:
"
req
.
error
.
name
)
;
}
;
}
reject
)
;
}
)
;
}
exports
.
getItem
=
getItem
;
exports
.
setItem
=
setItem
;
exports
.
removeItem
=
removeItem
;
exports
.
clear
=
clear
;
exports
.
length
=
length
;
exports
.
key
=
key
;
}
)
544
:
(
function
(
module
exports
)
{
const
UNKNOWN_SOURCE_STRING
=
"
(
unknown
)
"
;
const
CHAR_CODE_A
=
"
a
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_B
=
"
b
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_C
=
"
c
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_D
=
"
d
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_E
=
"
e
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_F
=
"
f
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_H
=
"
h
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_I
=
"
i
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_J
=
"
j
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_L
=
"
l
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_M
=
"
m
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_N
=
"
n
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_O
=
"
o
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_P
=
"
p
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_R
=
"
r
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_S
=
"
s
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_T
=
"
t
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_U
=
"
u
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_W
=
"
w
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_COLON
=
"
:
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_DASH
=
"
-
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_L_SQUARE_BRACKET
=
"
[
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_SLASH
=
"
/
"
.
charCodeAt
(
0
)
;
const
CHAR_CODE_CAP_S
=
"
S
"
.
charCodeAt
(
0
)
;
const
gURLStore
=
new
Map
(
)
;
const
gSourceNamesStore
=
new
Map
(
)
;
function
parseURL
(
location
)
{
let
url
=
gURLStore
.
get
(
location
)
;
if
(
url
!
=
=
void
0
)
{
return
url
;
}
try
{
url
=
new
URL
(
location
)
;
url
=
{
href
:
url
.
href
protocol
:
url
.
protocol
host
:
url
.
host
hostname
:
url
.
hostname
port
:
url
.
port
|
|
null
pathname
:
url
.
pathname
search
:
url
.
search
hash
:
url
.
hash
username
:
url
.
username
password
:
url
.
password
origin
:
url
.
origin
}
;
let
isChrome
=
isChromeScheme
(
location
)
;
url
.
fileName
=
url
.
pathname
?
url
.
pathname
.
slice
(
url
.
pathname
.
lastIndexOf
(
"
/
"
)
+
1
)
|
|
"
/
"
:
"
/
"
;
if
(
isChrome
)
{
url
.
hostname
=
null
;
url
.
host
=
null
;
}
gURLStore
.
set
(
location
url
)
;
return
url
;
}
catch
(
e
)
{
gURLStore
.
set
(
location
null
)
;
return
null
;
}
}
function
getSourceNames
(
source
)
{
let
data
=
gSourceNamesStore
.
get
(
source
)
;
if
(
data
)
{
return
data
;
}
let
short
long
host
;
const
sourceStr
=
source
?
String
(
source
)
:
"
"
;
if
(
isDataScheme
(
sourceStr
)
)
{
let
commaIndex
=
sourceStr
.
indexOf
(
"
"
)
;
if
(
commaIndex
>
-
1
)
{
short
=
data
:
{
sourceStr
.
substring
(
commaIndex
+
1
)
}
.
slice
(
0
100
)
;
let
result
=
{
short
long
:
sourceStr
}
;
gSourceNamesStore
.
set
(
source
result
)
;
return
result
;
}
}
const
parsedUrl
=
parseURL
(
sourceStr
)
;
if
(
!
parsedUrl
)
{
long
=
sourceStr
;
short
=
sourceStr
.
slice
(
0
100
)
;
}
else
{
host
=
parsedUrl
.
host
;
long
=
parsedUrl
.
href
;
if
(
parsedUrl
.
hash
)
{
long
=
long
.
replace
(
parsedUrl
.
hash
"
"
)
;
}
if
(
parsedUrl
.
search
)
{
long
=
long
.
replace
(
parsedUrl
.
search
"
"
)
;
}
short
=
parsedUrl
.
fileName
;
if
(
short
=
=
=
"
/
"
&
&
parsedUrl
.
pathname
!
=
=
"
/
"
)
{
short
=
parseURL
(
long
.
replace
(
/
\
/
/
"
"
)
)
.
fileName
;
}
}
if
(
!
short
)
{
if
(
!
long
)
{
long
=
UNKNOWN_SOURCE_STRING
;
}
short
=
long
.
slice
(
0
100
)
;
}
let
result
=
{
short
long
host
}
;
gSourceNamesStore
.
set
(
source
result
)
;
return
result
;
}
function
isColonSlashSlash
(
location
i
=
0
)
{
return
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_COLON
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_SLASH
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_SLASH
;
}
function
isDataScheme
(
location
i
=
0
)
{
return
location
.
charCodeAt
(
i
)
=
=
=
CHAR_CODE_D
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_A
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_T
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_A
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_COLON
;
}
function
isContentScheme
(
location
i
=
0
)
{
let
firstChar
=
location
.
charCodeAt
(
i
)
;
switch
(
firstChar
)
{
case
CHAR_CODE_H
:
if
(
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_T
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_T
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_P
)
{
if
(
location
.
charCodeAt
(
i
+
1
)
=
=
=
CHAR_CODE_S
)
{
+
+
i
;
}
return
isColonSlashSlash
(
location
i
)
;
}
return
false
;
case
CHAR_CODE_F
:
if
(
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_I
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_L
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_E
)
{
return
isColonSlashSlash
(
location
i
)
;
}
return
false
;
case
CHAR_CODE_A
:
if
(
location
.
charCodeAt
(
+
+
i
)
=
=
CHAR_CODE_P
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
CHAR_CODE_P
)
{
return
isColonSlashSlash
(
location
i
)
;
}
return
false
;
case
CHAR_CODE_B
:
if
(
location
.
charCodeAt
(
+
+
i
)
=
=
CHAR_CODE_L
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
CHAR_CODE_O
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
CHAR_CODE_B
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
CHAR_CODE_COLON
)
{
return
isContentScheme
(
location
i
+
1
)
;
}
return
false
;
default
:
return
false
;
}
}
function
isChromeScheme
(
location
i
=
0
)
{
let
firstChar
=
location
.
charCodeAt
(
i
)
;
switch
(
firstChar
)
{
case
CHAR_CODE_C
:
if
(
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_H
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_R
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_O
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_M
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_E
)
{
return
isColonSlashSlash
(
location
i
)
;
}
return
false
;
case
CHAR_CODE_R
:
if
(
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_E
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_S
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_O
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_U
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_R
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_C
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_E
)
{
return
isColonSlashSlash
(
location
i
)
;
}
return
false
;
case
CHAR_CODE_J
:
if
(
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_A
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_R
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_COLON
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_F
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_I
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_L
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_E
)
{
return
isColonSlashSlash
(
location
i
)
;
}
return
false
;
default
:
return
false
;
}
}
function
isWASM
(
location
i
=
0
)
{
return
(
location
.
charCodeAt
(
i
)
=
=
=
CHAR_CODE_W
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_A
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_S
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_M
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_DASH
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_F
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_U
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_N
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_C
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_T
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_I
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_O
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_N
&
&
location
.
charCodeAt
(
+
+
i
)
=
=
=
CHAR_CODE_L_SQUARE_BRACKET
)
;
}
function
getSourceMappedFile
(
source
)
{
if
(
source
.
lastIndexOf
(
"
/
"
)
>
=
0
)
{
source
=
source
.
slice
(
source
.
lastIndexOf
(
"
/
"
)
+
1
)
;
}
else
if
(
source
.
lastIndexOf
(
"
\
\
"
)
>
=
0
)
{
source
=
source
.
slice
(
source
.
lastIndexOf
(
"
\
\
"
)
+
1
)
;
}
return
source
;
}
module
.
exports
=
{
parseURL
getSourceNames
isChromeScheme
isContentScheme
isWASM
isDataScheme
getSourceMappedFile
}
;
}
)
545
:
(
function
(
module
exports
)
{
class
Telemetry
{
get
msSystemNow
(
)
{
return
0
;
}
start
(
histogramId
obj
)
{
return
true
;
}
startKeyed
(
histogramId
key
obj
)
{
return
true
;
}
finish
(
histogramId
obj
canceledOkay
)
{
return
true
;
}
finishKeyed
(
histogramId
key
obj
cancelledOkay
)
{
return
true
;
}
getHistogramById
(
histogramId
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
getKeyedHistogramById
(
histogramId
)
{
return
{
add
:
(
)
=
>
{
}
}
;
}
scalarSet
(
scalarId
value
)
{
}
scalarAdd
(
scalarId
value
)
{
}
keyedScalarAdd
(
scalarId
key
value
)
{
}
setEventRecordingEnabled
(
enabled
)
{
return
enabled
;
}
preparePendingEvent
(
obj
method
object
value
expected
=
[
]
)
{
}
addEventProperty
(
obj
method
object
value
pendingPropName
pendingPropValue
)
{
}
addEventProperties
(
obj
method
object
value
pendingObject
)
{
}
_sendPendingEvent
(
obj
method
object
value
)
{
}
recordEvent
(
method
object
value
extra
)
{
}
toolOpened
(
id
sessionId
obj
)
{
}
toolClosed
(
id
sessionId
obj
)
{
}
}
module
.
exports
=
Telemetry
;
}
)
546
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
punycode
=
__webpack_require__
(
62
)
;
function
getUnicodeHostname
(
hostname
)
{
try
{
return
punycode
.
toUnicode
(
hostname
)
;
}
catch
(
err
)
{
}
return
hostname
;
}
function
getUnicodeUrlPath
(
urlPath
)
{
try
{
return
decodeURIComponent
(
urlPath
)
;
}
catch
(
err
)
{
}
return
urlPath
;
}
function
getUnicodeUrl
(
url
)
{
try
{
const
{
protocol
hostname
}
=
new
URL
(
url
)
;
if
(
protocol
=
=
=
"
data
:
"
)
{
return
url
;
}
const
readableHostname
=
getUnicodeHostname
(
hostname
)
;
url
=
decodeURIComponent
(
url
)
;
return
url
.
replace
(
hostname
readableHostname
)
;
}
catch
(
err
)
{
}
return
url
;
}
module
.
exports
=
{
getUnicodeHostname
getUnicodeUrlPath
getUnicodeUrl
}
;
}
)
547
:
(
function
(
module
exports
)
{
const
gFunctions
=
[
[
1
n
=
>
0
]
[
2
n
=
>
n
!
=
1
?
1
:
0
]
[
2
n
=
>
n
>
1
?
1
:
0
]
[
3
n
=
>
n
%
10
=
=
1
&
&
n
%
100
!
=
11
?
1
:
n
%
10
=
=
0
?
0
:
2
]
[
4
n
=
>
n
=
=
1
|
|
n
=
=
11
?
0
:
n
=
=
2
|
|
n
=
=
12
?
1
:
n
>
0
&
&
n
<
20
?
2
:
3
]
[
3
n
=
>
n
=
=
1
?
0
:
n
=
=
0
|
|
n
%
100
>
0
&
&
n
%
100
<
20
?
1
:
2
]
[
3
n
=
>
n
%
10
=
=
1
&
&
n
%
100
!
=
11
?
0
:
n
%
10
>
=
2
&
&
(
n
%
100
<
10
|
|
n
%
100
>
=
20
)
?
2
:
1
]
[
3
n
=
>
n
%
10
=
=
1
&
&
n
%
100
!
=
11
?
0
:
n
%
10
>
=
2
&
&
n
%
10
<
=
4
&
&
(
n
%
100
<
10
|
|
n
%
100
>
=
20
)
?
1
:
2
]
[
3
n
=
>
n
=
=
1
?
0
:
n
>
=
2
&
&
n
<
=
4
?
1
:
2
]
[
3
n
=
>
n
=
=
1
?
0
:
n
%
10
>
=
2
&
&
n
%
10
<
=
4
&
&
(
n
%
100
<
10
|
|
n
%
100
>
=
20
)
?
1
:
2
]
[
4
n
=
>
n
%
100
=
=
1
?
0
:
n
%
100
=
=
2
?
1
:
n
%
100
=
=
3
|
|
n
%
100
=
=
4
?
2
:
3
]
[
5
n
=
>
n
=
=
1
?
0
:
n
=
=
2
?
1
:
n
>
=
3
&
&
n
<
=
6
?
2
:
n
>
=
7
&
&
n
<
=
10
?
3
:
4
]
[
6
n
=
>
n
=
=
0
?
5
:
n
=
=
1
?
0
:
n
=
=
2
?
1
:
n
%
100
>
=
3
&
&
n
%
100
<
=
10
?
2
:
n
%
100
>
=
11
&
&
n
%
100
<
=
99
?
3
:
4
]
[
4
n
=
>
n
=
=
1
?
0
:
n
=
=
0
|
|
n
%
100
>
0
&
&
n
%
100
<
=
10
?
1
:
n
%
100
>
10
&
&
n
%
100
<
20
?
2
:
3
]
[
3
n
=
>
n
%
10
=
=
1
?
0
:
n
%
10
=
=
2
?
1
:
2
]
[
2
n
=
>
n
%
10
=
=
1
&
&
n
%
100
!
=
11
?
0
:
1
]
[
5
n
=
>
n
%
10
=
=
1
&
&
n
%
100
!
=
11
&
&
n
%
100
!
=
71
&
&
n
%
100
!
=
91
?
0
:
n
%
10
=
=
2
&
&
n
%
100
!
=
12
&
&
n
%
100
!
=
72
&
&
n
%
100
!
=
92
?
1
:
(
n
%
10
=
=
3
|
|
n
%
10
=
=
4
|
|
n
%
10
=
=
9
)
&
&
n
%
100
!
=
13
&
&
n
%
100
!
=
14
&
&
n
%
100
!
=
19
&
&
n
%
100
!
=
73
&
&
n
%
100
!
=
74
&
&
n
%
100
!
=
79
&
&
n
%
100
!
=
93
&
&
n
%
100
!
=
94
&
&
n
%
100
!
=
99
?
2
:
n
%
1000000
=
=
0
&
&
n
!
=
0
?
3
:
4
]
[
2
n
=
>
n
!
=
0
?
1
:
0
]
[
6
n
=
>
n
=
=
0
?
0
:
n
=
=
1
?
1
:
n
=
=
2
?
2
:
n
=
=
3
?
3
:
n
=
=
6
?
4
:
5
]
[
3
n
=
>
n
%
10
=
=
1
&
&
n
%
100
!
=
11
?
0
:
n
%
10
>
=
2
&
&
n
%
10
<
=
4
&
&
(
n
%
100
<
10
|
|
n
%
100
>
=
20
)
?
1
:
2
]
]
;
const
PluralForm
=
{
get
get
(
)
{
delete
this
.
numForms
;
delete
this
.
get
;
[
this
.
get
this
.
numForms
]
=
this
.
makeGetter
(
this
.
ruleNum
)
;
return
this
.
get
;
}
makeGetter
:
function
(
aRuleNum
)
{
if
(
aRuleNum
<
0
|
|
aRuleNum
>
=
gFunctions
.
length
|
|
isNaN
(
aRuleNum
)
)
{
log
(
[
"
Invalid
rule
number
:
"
aRuleNum
"
-
-
defaulting
to
0
"
]
)
;
aRuleNum
=
0
;
}
let
[
numForms
pluralFunc
]
=
gFunctions
[
aRuleNum
]
;
return
[
function
(
aNum
aWords
)
{
let
index
=
pluralFunc
(
aNum
?
Number
(
aNum
)
:
0
)
;
let
words
=
aWords
?
aWords
.
split
(
/
;
/
)
:
[
"
"
]
;
let
ret
=
index
<
words
.
length
?
words
[
index
]
:
undefined
;
if
(
ret
=
=
undefined
|
|
ret
=
=
"
"
)
{
log
(
[
"
Index
#
"
index
"
of
'
"
aWords
"
'
for
value
"
aNum
"
is
invalid
-
-
plural
rule
#
"
aRuleNum
"
;
"
]
)
;
ret
=
words
[
0
]
;
}
return
ret
;
}
(
)
=
>
numForms
]
;
}
get
numForms
(
)
{
this
.
get
(
)
;
return
this
.
numForms
;
}
get
ruleNum
(
)
{
try
{
return
parseInt
(
L10N
.
getStr
(
"
pluralRule
"
)
10
)
;
}
catch
(
e
)
{
return
1
;
}
}
}
;
function
log
(
aMsg
)
{
let
msg
=
"
plural
-
form
.
js
:
"
+
(
aMsg
.
join
?
aMsg
.
join
(
"
"
)
:
aMsg
)
;
console
.
log
(
msg
+
"
\
n
"
)
;
}
module
.
exports
=
PluralForm
;
}
)
548
:
(
function
(
module
exports
)
{
module
.
exports
=
(
)
=
>
{
}
;
}
)
549
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
const
asyncStorage
=
__webpack_require__
(
543
)
;
function
asyncStoreHelper
(
root
mappings
)
{
let
store
=
{
}
;
function
getMappingKey
(
key
)
{
return
Array
.
isArray
(
mappings
[
key
]
)
?
mappings
[
key
]
[
0
]
:
mappings
[
key
]
;
}
function
getMappingDefaultValue
(
key
)
{
return
Array
.
isArray
(
mappings
[
key
]
)
?
mappings
[
key
]
[
1
]
:
null
;
}
Object
.
keys
(
mappings
)
.
map
(
key
=
>
Object
.
defineProperty
(
store
key
{
async
get
(
)
{
const
value
=
await
asyncStorage
.
getItem
(
{
root
}
.
{
getMappingKey
(
key
)
}
)
;
return
value
|
|
getMappingDefaultValue
(
key
)
;
}
set
(
value
)
{
return
asyncStorage
.
setItem
(
{
root
}
.
{
getMappingKey
(
key
)
}
value
)
;
}
}
)
)
;
store
=
new
Proxy
(
store
{
set
:
function
(
target
property
value
receiver
)
{
if
(
!
mappings
.
hasOwnProperty
(
property
)
)
{
throw
new
Error
(
AsyncStore
:
{
property
}
is
not
defined
in
mappings
)
;
}
Reflect
.
set
(
.
.
.
arguments
)
;
return
true
;
}
}
)
;
return
store
;
}
module
.
exports
=
asyncStoreHelper
;
}
)
6
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_6__
;
}
)
62
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
module
global
)
{
var
__WEBPACK_AMD_DEFINE_RESULT__
;
;
(
function
(
root
)
{
var
freeExports
=
typeof
exports
=
=
'
object
'
&
&
exports
&
&
!
exports
.
nodeType
&
&
exports
;
var
freeModule
=
typeof
module
=
=
'
object
'
&
&
module
&
&
!
module
.
nodeType
&
&
module
;
var
freeGlobal
=
typeof
global
=
=
'
object
'
&
&
global
;
if
(
freeGlobal
.
global
=
=
=
freeGlobal
|
|
freeGlobal
.
window
=
=
=
freeGlobal
|
|
freeGlobal
.
self
=
=
=
freeGlobal
)
{
root
=
freeGlobal
;
}
var
punycode
maxInt
=
2147483647
base
=
36
tMin
=
1
tMax
=
26
skew
=
38
damp
=
700
initialBias
=
72
initialN
=
128
delimiter
=
'
-
'
regexPunycode
=
/
^
xn
-
-
/
regexNonASCII
=
/
[
^
\
x20
-
\
x7E
]
/
regexSeparators
=
/
[
\
x2E
\
u3002
\
uFF0E
\
uFF61
]
/
g
errors
=
{
'
overflow
'
:
'
Overflow
:
input
needs
wider
integers
to
process
'
'
not
-
basic
'
:
'
Illegal
input
>
=
0x80
(
not
a
basic
code
point
)
'
'
invalid
-
input
'
:
'
Invalid
input
'
}
baseMinusTMin
=
base
-
tMin
floor
=
Math
.
floor
stringFromCharCode
=
String
.
fromCharCode
key
;
function
error
(
type
)
{
throw
new
RangeError
(
errors
[
type
]
)
;
}
function
map
(
array
fn
)
{
var
length
=
array
.
length
;
var
result
=
[
]
;
while
(
length
-
-
)
{
result
[
length
]
=
fn
(
array
[
length
]
)
;
}
return
result
;
}
function
mapDomain
(
string
fn
)
{
var
parts
=
string
.
split
(
'
'
)
;
var
result
=
'
'
;
if
(
parts
.
length
>
1
)
{
result
=
parts
[
0
]
+
'
'
;
string
=
parts
[
1
]
;
}
string
=
string
.
replace
(
regexSeparators
'
\
x2E
'
)
;
var
labels
=
string
.
split
(
'
.
'
)
;
var
encoded
=
map
(
labels
fn
)
.
join
(
'
.
'
)
;
return
result
+
encoded
;
}
function
ucs2decode
(
string
)
{
var
output
=
[
]
counter
=
0
length
=
string
.
length
value
extra
;
while
(
counter
<
length
)
{
value
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
value
>
=
0xD800
&
&
value
<
=
0xDBFF
&
&
counter
<
length
)
{
extra
=
string
.
charCodeAt
(
counter
+
+
)
;
if
(
(
extra
&
0xFC00
)
=
=
0xDC00
)
{
output
.
push
(
(
(
value
&
0x3FF
)
<
<
10
)
+
(
extra
&
0x3FF
)
+
0x10000
)
;
}
else
{
output
.
push
(
value
)
;
counter
-
-
;
}
}
else
{
output
.
push
(
value
)
;
}
}
return
output
;
}
function
ucs2encode
(
array
)
{
return
map
(
array
function
(
value
)
{
var
output
=
'
'
;
if
(
value
>
0xFFFF
)
{
value
-
=
0x10000
;
output
+
=
stringFromCharCode
(
value
>
>
>
10
&
0x3FF
|
0xD800
)
;
value
=
0xDC00
|
value
&
0x3FF
;
}
output
+
=
stringFromCharCode
(
value
)
;
return
output
;
}
)
.
join
(
'
'
)
;
}
function
basicToDigit
(
codePoint
)
{
if
(
codePoint
-
48
<
10
)
{
return
codePoint
-
22
;
}
if
(
codePoint
-
65
<
26
)
{
return
codePoint
-
65
;
}
if
(
codePoint
-
97
<
26
)
{
return
codePoint
-
97
;
}
return
base
;
}
function
digitToBasic
(
digit
flag
)
{
return
digit
+
22
+
75
*
(
digit
<
26
)
-
(
(
flag
!
=
0
)
<
<
5
)
;
}
function
adapt
(
delta
numPoints
firstTime
)
{
var
k
=
0
;
delta
=
firstTime
?
floor
(
delta
/
damp
)
:
delta
>
>
1
;
delta
+
=
floor
(
delta
/
numPoints
)
;
for
(
;
delta
>
baseMinusTMin
*
tMax
>
>
1
;
k
+
=
base
)
{
delta
=
floor
(
delta
/
baseMinusTMin
)
;
}
return
floor
(
k
+
(
baseMinusTMin
+
1
)
*
delta
/
(
delta
+
skew
)
)
;
}
function
decode
(
input
)
{
var
output
=
[
]
inputLength
=
input
.
length
out
i
=
0
n
=
initialN
bias
=
initialBias
basic
j
index
oldi
w
k
digit
t
baseMinusT
;
basic
=
input
.
lastIndexOf
(
delimiter
)
;
if
(
basic
<
0
)
{
basic
=
0
;
}
for
(
j
=
0
;
j
<
basic
;
+
+
j
)
{
if
(
input
.
charCodeAt
(
j
)
>
=
0x80
)
{
error
(
'
not
-
basic
'
)
;
}
output
.
push
(
input
.
charCodeAt
(
j
)
)
;
}
for
(
index
=
basic
>
0
?
basic
+
1
:
0
;
index
<
inputLength
;
)
{
for
(
oldi
=
i
w
=
1
k
=
base
;
;
k
+
=
base
)
{
if
(
index
>
=
inputLength
)
{
error
(
'
invalid
-
input
'
)
;
}
digit
=
basicToDigit
(
input
.
charCodeAt
(
index
+
+
)
)
;
if
(
digit
>
=
base
|
|
digit
>
floor
(
(
maxInt
-
i
)
/
w
)
)
{
error
(
'
overflow
'
)
;
}
i
+
=
digit
*
w
;
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
digit
<
t
)
{
break
;
}
baseMinusT
=
base
-
t
;
if
(
w
>
floor
(
maxInt
/
baseMinusT
)
)
{
error
(
'
overflow
'
)
;
}
w
*
=
baseMinusT
;
}
out
=
output
.
length
+
1
;
bias
=
adapt
(
i
-
oldi
out
oldi
=
=
0
)
;
if
(
floor
(
i
/
out
)
>
maxInt
-
n
)
{
error
(
'
overflow
'
)
;
}
n
+
=
floor
(
i
/
out
)
;
i
%
=
out
;
output
.
splice
(
i
+
+
0
n
)
;
}
return
ucs2encode
(
output
)
;
}
function
encode
(
input
)
{
var
n
delta
handledCPCount
basicLength
bias
j
m
q
k
t
currentValue
output
=
[
]
inputLength
handledCPCountPlusOne
baseMinusT
qMinusT
;
input
=
ucs2decode
(
input
)
;
inputLength
=
input
.
length
;
n
=
initialN
;
delta
=
0
;
bias
=
initialBias
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
0x80
)
{
output
.
push
(
stringFromCharCode
(
currentValue
)
)
;
}
}
handledCPCount
=
basicLength
=
output
.
length
;
if
(
basicLength
)
{
output
.
push
(
delimiter
)
;
}
while
(
handledCPCount
<
inputLength
)
{
for
(
m
=
maxInt
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
>
=
n
&
&
currentValue
<
m
)
{
m
=
currentValue
;
}
}
handledCPCountPlusOne
=
handledCPCount
+
1
;
if
(
m
-
n
>
floor
(
(
maxInt
-
delta
)
/
handledCPCountPlusOne
)
)
{
error
(
'
overflow
'
)
;
}
delta
+
=
(
m
-
n
)
*
handledCPCountPlusOne
;
n
=
m
;
for
(
j
=
0
;
j
<
inputLength
;
+
+
j
)
{
currentValue
=
input
[
j
]
;
if
(
currentValue
<
n
&
&
+
+
delta
>
maxInt
)
{
error
(
'
overflow
'
)
;
}
if
(
currentValue
=
=
n
)
{
for
(
q
=
delta
k
=
base
;
;
k
+
=
base
)
{
t
=
k
<
=
bias
?
tMin
:
(
k
>
=
bias
+
tMax
?
tMax
:
k
-
bias
)
;
if
(
q
<
t
)
{
break
;
}
qMinusT
=
q
-
t
;
baseMinusT
=
base
-
t
;
output
.
push
(
stringFromCharCode
(
digitToBasic
(
t
+
qMinusT
%
baseMinusT
0
)
)
)
;
q
=
floor
(
qMinusT
/
baseMinusT
)
;
}
output
.
push
(
stringFromCharCode
(
digitToBasic
(
q
0
)
)
)
;
bias
=
adapt
(
delta
handledCPCountPlusOne
handledCPCount
=
=
basicLength
)
;
delta
=
0
;
+
+
handledCPCount
;
}
}
+
+
delta
;
+
+
n
;
}
return
output
.
join
(
'
'
)
;
}
function
toUnicode
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexPunycode
.
test
(
string
)
?
decode
(
string
.
slice
(
4
)
.
toLowerCase
(
)
)
:
string
;
}
)
;
}
function
toASCII
(
input
)
{
return
mapDomain
(
input
function
(
string
)
{
return
regexNonASCII
.
test
(
string
)
?
'
xn
-
-
'
+
encode
(
string
)
:
string
;
}
)
;
}
punycode
=
{
'
version
'
:
'
1
.
4
.
1
'
'
ucs2
'
:
{
'
decode
'
:
ucs2decode
'
encode
'
:
ucs2encode
}
'
decode
'
:
decode
'
encode
'
:
encode
'
toASCII
'
:
toASCII
'
toUnicode
'
:
toUnicode
}
;
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_RESULT__
=
(
function
(
)
{
return
punycode
;
}
)
.
call
(
exports
__webpack_require__
exports
module
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
if
(
freeExports
&
&
freeModule
)
{
if
(
module
.
exports
=
=
freeExports
)
{
freeModule
.
exports
=
punycode
;
}
else
{
for
(
key
in
punycode
)
{
punycode
.
hasOwnProperty
(
key
)
&
&
(
freeExports
[
key
]
=
punycode
[
key
]
)
;
}
}
}
else
{
root
.
punycode
=
punycode
;
}
}
(
this
)
)
;
}
.
call
(
exports
__webpack_require__
(
22
)
(
module
)
__webpack_require__
(
15
)
)
)
}
)
66
:
(
function
(
module
exports
)
{
(
function
(
)
{
var
AcronymResult
computeScore
emptyAcronymResult
isAcronymFullWord
isMatch
isSeparator
isWordEnd
isWordStart
miss_coeff
pos_bonus
scoreAcronyms
scoreCharacter
scoreConsecutives
scoreExact
scoreExactMatch
scorePattern
scorePosition
scoreSize
tau_size
wm
;
wm
=
150
;
pos_bonus
=
20
;
tau_size
=
150
;
miss_coeff
=
0
.
75
;
exports
.
score
=
function
(
string
query
options
)
{
var
allowErrors
preparedQuery
score
string_lw
;
preparedQuery
=
options
.
preparedQuery
allowErrors
=
options
.
allowErrors
;
if
(
!
(
allowErrors
|
|
isMatch
(
string
preparedQuery
.
core_lw
preparedQuery
.
core_up
)
)
)
{
return
0
;
}
string_lw
=
string
.
toLowerCase
(
)
;
score
=
computeScore
(
string
string_lw
preparedQuery
)
;
return
Math
.
ceil
(
score
)
;
}
;
exports
.
isMatch
=
isMatch
=
function
(
subject
query_lw
query_up
)
{
var
i
j
m
n
qj_lw
qj_up
si
;
m
=
subject
.
length
;
n
=
query_lw
.
length
;
if
(
!
m
|
|
n
>
m
)
{
return
false
;
}
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
.
charCodeAt
(
j
)
;
qj_up
=
query_up
.
charCodeAt
(
j
)
;
while
(
+
+
i
<
m
)
{
si
=
subject
.
charCodeAt
(
i
)
;
if
(
si
=
=
=
qj_lw
|
|
si
=
=
=
qj_up
)
{
break
;
}
}
if
(
i
=
=
=
m
)
{
return
false
;
}
}
return
true
;
}
;
exports
.
computeScore
=
computeScore
=
function
(
subject
subject_lw
preparedQuery
)
{
var
acro
acro_score
align
csc_diag
csc_row
csc_score
csc_should_rebuild
i
j
m
miss_budget
miss_left
n
pos
query
query_lw
record_miss
score
score_diag
score_row
score_up
si_lw
start
sz
;
query
=
preparedQuery
.
query
;
query_lw
=
preparedQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro
=
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
;
acro_score
=
acro
.
score
;
if
(
acro
.
count
=
=
=
n
)
{
return
scoreExact
(
n
m
acro_score
acro
.
pos
)
;
}
pos
=
subject_lw
.
indexOf
(
query_lw
)
;
if
(
pos
>
-
1
)
{
return
scoreExactMatch
(
subject
subject_lw
query
query_lw
pos
n
m
)
;
}
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
sz
=
scoreSize
(
n
m
)
;
miss_budget
=
Math
.
ceil
(
miss_coeff
*
n
)
+
5
;
miss_left
=
miss_budget
;
csc_should_rebuild
=
true
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
si_lw
=
subject_lw
[
i
]
;
if
(
!
si_lw
.
charCodeAt
(
0
)
in
preparedQuery
.
charCodes
)
{
if
(
csc_should_rebuild
)
{
j
=
-
1
;
while
(
+
+
j
<
n
)
{
csc_row
[
j
]
=
0
;
}
csc_should_rebuild
=
false
;
}
continue
;
}
score
=
0
;
score_diag
=
0
;
csc_diag
=
0
;
record_miss
=
true
;
csc_should_rebuild
=
true
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_up
=
score_row
[
j
]
;
if
(
score_up
>
score
)
{
score
=
score_up
;
}
csc_score
=
0
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
if
(
align
>
score
)
{
score
=
align
;
miss_left
=
miss_budget
;
}
else
{
if
(
record_miss
&
&
-
-
miss_left
<
=
0
)
{
return
Math
.
max
(
score
score_row
[
n
-
1
]
)
*
sz
;
}
record_miss
=
false
;
}
}
score_diag
=
score_up
;
csc_diag
=
csc_row
[
j
]
;
csc_row
[
j
]
=
csc_score
;
score_row
[
j
]
=
score
;
}
}
score
=
score_row
[
n
-
1
]
;
return
score
*
sz
;
}
;
exports
.
isWordStart
=
isWordStart
=
function
(
pos
subject
subject_lw
)
{
var
curr_s
prev_s
;
if
(
pos
=
=
=
0
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
prev_s
=
subject
[
pos
-
1
]
;
return
isSeparator
(
prev_s
)
|
|
(
curr_s
!
=
=
subject_lw
[
pos
]
&
&
prev_s
=
=
=
subject_lw
[
pos
-
1
]
)
;
}
;
exports
.
isWordEnd
=
isWordEnd
=
function
(
pos
subject
subject_lw
len
)
{
var
curr_s
next_s
;
if
(
pos
=
=
=
len
-
1
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
next_s
=
subject
[
pos
+
1
]
;
return
isSeparator
(
next_s
)
|
|
(
curr_s
=
=
=
subject_lw
[
pos
]
&
&
next_s
!
=
=
subject_lw
[
pos
+
1
]
)
;
}
;
isSeparator
=
function
(
c
)
{
return
c
=
=
=
'
'
|
|
c
=
=
=
'
.
'
|
|
c
=
=
=
'
-
'
|
|
c
=
=
=
'
_
'
|
|
c
=
=
=
'
/
'
|
|
c
=
=
=
'
\
\
'
;
}
;
scorePosition
=
function
(
pos
)
{
var
sc
;
if
(
pos
<
pos_bonus
)
{
sc
=
pos_bonus
-
pos
;
return
100
+
sc
*
sc
;
}
else
{
return
Math
.
max
(
100
+
pos_bonus
-
pos
0
)
;
}
}
;
exports
.
scoreSize
=
scoreSize
=
function
(
n
m
)
{
return
tau_size
/
(
tau_size
+
Math
.
abs
(
m
-
n
)
)
;
}
;
scoreExact
=
function
(
n
m
quality
pos
)
{
return
2
*
n
*
(
wm
*
quality
+
scorePosition
(
pos
)
)
*
scoreSize
(
n
m
)
;
}
;
exports
.
scorePattern
=
scorePattern
=
function
(
count
len
sameCase
start
end
)
{
var
bonus
sz
;
sz
=
count
;
bonus
=
6
;
if
(
sameCase
=
=
=
count
)
{
bonus
+
=
2
;
}
if
(
start
)
{
bonus
+
=
3
;
}
if
(
end
)
{
bonus
+
=
1
;
}
if
(
count
=
=
=
len
)
{
if
(
start
)
{
if
(
sameCase
=
=
=
len
)
{
sz
+
=
2
;
}
else
{
sz
+
=
1
;
}
}
if
(
end
)
{
bonus
+
=
1
;
}
}
return
sameCase
+
sz
*
(
sz
+
bonus
)
;
}
;
exports
.
scoreCharacter
=
scoreCharacter
=
function
(
i
j
start
acro_score
csc_score
)
{
var
posBonus
;
posBonus
=
scorePosition
(
i
)
;
if
(
start
)
{
return
posBonus
+
wm
*
(
(
acro_score
>
csc_score
?
acro_score
:
csc_score
)
+
10
)
;
}
return
posBonus
+
wm
*
csc_score
;
}
;
exports
.
scoreConsecutives
=
scoreConsecutives
=
function
(
subject
subject_lw
query
query_lw
i
j
startOfWord
)
{
var
k
m
mi
n
nj
sameCase
sz
;
m
=
subject
.
length
;
n
=
query
.
length
;
mi
=
m
-
i
;
nj
=
n
-
j
;
k
=
mi
<
nj
?
mi
:
nj
;
sameCase
=
0
;
sz
=
0
;
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
while
(
+
+
sz
<
k
&
&
query_lw
[
+
+
j
]
=
=
=
subject_lw
[
+
+
i
]
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
if
(
sz
<
k
)
{
i
-
-
;
}
if
(
sz
=
=
=
1
)
{
return
1
+
2
*
sameCase
;
}
return
scorePattern
(
sz
n
sameCase
startOfWord
isWordEnd
(
i
subject
subject_lw
m
)
)
;
}
;
exports
.
scoreExactMatch
=
scoreExactMatch
=
function
(
subject
subject_lw
query
query_lw
pos
n
m
)
{
var
end
i
pos2
sameCase
start
;
start
=
isWordStart
(
pos
subject
subject_lw
)
;
if
(
!
start
)
{
pos2
=
subject_lw
.
indexOf
(
query_lw
pos
+
1
)
;
if
(
pos2
>
-
1
)
{
start
=
isWordStart
(
pos2
subject
subject_lw
)
;
if
(
start
)
{
pos
=
pos2
;
}
}
}
i
=
-
1
;
sameCase
=
0
;
while
(
+
+
i
<
n
)
{
if
(
query
[
pos
+
i
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
end
=
isWordEnd
(
pos
+
n
-
1
subject
subject_lw
m
)
;
return
scoreExact
(
n
m
scorePattern
(
n
n
sameCase
start
end
)
pos
)
;
}
;
AcronymResult
=
(
function
(
)
{
function
AcronymResult
(
score
pos
count
)
{
this
.
score
=
score
;
this
.
pos
=
pos
;
this
.
count
=
count
;
}
return
AcronymResult
;
}
)
(
)
;
emptyAcronymResult
=
new
AcronymResult
(
0
0
.
1
0
)
;
exports
.
scoreAcronyms
=
scoreAcronyms
=
function
(
subject
subject_lw
query
query_lw
)
{
var
count
fullWord
i
j
m
n
qj_lw
sameCase
score
sepCount
sumPos
;
m
=
subject
.
length
;
n
=
query
.
length
;
if
(
!
(
m
>
1
&
&
n
>
1
)
)
{
return
emptyAcronymResult
;
}
count
=
0
;
sepCount
=
0
;
sumPos
=
0
;
sameCase
=
0
;
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
[
j
]
;
if
(
isSeparator
(
qj_lw
)
)
{
i
=
subject_lw
.
indexOf
(
qj_lw
i
+
1
)
;
if
(
i
>
-
1
)
{
sepCount
+
+
;
continue
;
}
else
{
break
;
}
}
while
(
+
+
i
<
m
)
{
if
(
qj_lw
=
=
=
subject_lw
[
i
]
&
&
isWordStart
(
i
subject
subject_lw
)
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
sumPos
+
=
i
;
count
+
+
;
break
;
}
}
if
(
i
=
=
=
m
)
{
break
;
}
}
if
(
count
<
2
)
{
return
emptyAcronymResult
;
}
fullWord
=
count
=
=
=
n
?
isAcronymFullWord
(
subject
subject_lw
query
count
)
:
false
;
score
=
scorePattern
(
count
n
sameCase
true
fullWord
)
;
return
new
AcronymResult
(
score
sumPos
/
count
count
+
sepCount
)
;
}
;
isAcronymFullWord
=
function
(
subject
subject_lw
query
nbAcronymInQuery
)
{
var
count
i
m
n
;
m
=
subject
.
length
;
n
=
query
.
length
;
count
=
0
;
if
(
m
>
12
*
n
)
{
return
false
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
if
(
isWordStart
(
i
subject
subject_lw
)
&
&
+
+
count
>
nbAcronymInQuery
)
{
return
false
;
}
}
return
true
;
}
;
}
)
.
call
(
this
)
;
}
)
67
:
(
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
)
{
'
use
strict
'
;
var
hasOwn
=
{
}
.
hasOwnProperty
;
function
classNames
(
)
{
var
classes
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
continue
;
var
argType
=
typeof
arg
;
if
(
argType
=
=
=
'
string
'
|
|
argType
=
=
=
'
number
'
)
{
classes
.
push
(
arg
)
;
}
else
if
(
Array
.
isArray
(
arg
)
&
&
arg
.
length
)
{
var
inner
=
classNames
.
apply
(
null
arg
)
;
if
(
inner
)
{
classes
.
push
(
inner
)
;
}
}
else
if
(
argType
=
=
=
'
object
'
)
{
for
(
var
key
in
arg
)
{
if
(
hasOwn
.
call
(
arg
key
)
&
&
arg
[
key
]
)
{
classes
.
push
(
key
)
;
}
}
}
}
return
classes
.
join
(
'
'
)
;
}
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
classNames
.
default
=
classNames
;
module
.
exports
=
classNames
;
}
else
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
]
__WEBPACK_AMD_DEFINE_RESULT__
=
(
function
(
)
{
return
classNames
;
}
)
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
window
.
classNames
=
classNames
;
}
}
(
)
)
;
}
)
7
:
(
function
(
module
exports
__webpack_require__
)
{
const
networkRequest
=
__webpack_require__
(
13
)
;
const
workerUtils
=
__webpack_require__
(
14
)
;
module
.
exports
=
{
networkRequest
workerUtils
}
;
}
)
}
)
;
}
)
;
