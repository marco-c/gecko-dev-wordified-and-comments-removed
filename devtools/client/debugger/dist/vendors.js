(
function
webpackUniversalModuleDefinition
(
root
factory
)
{
if
(
typeof
exports
=
=
=
'
object
'
&
&
typeof
module
=
=
=
'
object
'
)
module
.
exports
=
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
require
(
"
devtools
/
shared
/
flags
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
)
;
else
if
(
typeof
define
=
=
=
'
function
'
&
&
define
.
amd
)
define
(
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
"
devtools
/
client
/
shared
/
vendor
/
react
"
"
devtools
/
shared
/
flags
"
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
]
factory
)
;
else
{
var
a
=
typeof
exports
=
=
=
'
object
'
?
factory
(
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
"
)
require
(
"
devtools
/
shared
/
flags
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
)
require
(
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
)
)
:
factory
(
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
prop
-
types
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
-
factories
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
"
]
root
[
"
devtools
/
shared
/
flags
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
react
-
dom
"
]
root
[
"
devtools
/
client
/
shared
/
vendor
/
lodash
"
]
)
;
for
(
var
i
in
a
)
(
typeof
exports
=
=
=
'
object
'
?
exports
:
root
)
[
i
]
=
a
[
i
]
;
}
}
)
(
typeof
self
!
=
=
'
undefined
'
?
self
:
this
function
(
__WEBPACK_EXTERNAL_MODULE_0__
__WEBPACK_EXTERNAL_MODULE_1__
__WEBPACK_EXTERNAL_MODULE_6__
__WEBPACK_EXTERNAL_MODULE_103__
__WEBPACK_EXTERNAL_MODULE_112__
__WEBPACK_EXTERNAL_MODULE_417__
)
{
return
(
function
(
modules
)
{
var
installedModules
=
{
}
;
function
__webpack_require__
(
moduleId
)
{
if
(
installedModules
[
moduleId
]
)
{
return
installedModules
[
moduleId
]
.
exports
;
}
var
module
=
installedModules
[
moduleId
]
=
{
i
:
moduleId
l
:
false
exports
:
{
}
}
;
modules
[
moduleId
]
.
call
(
module
.
exports
module
module
.
exports
__webpack_require__
)
;
module
.
l
=
true
;
return
module
.
exports
;
}
__webpack_require__
.
m
=
modules
;
__webpack_require__
.
c
=
installedModules
;
__webpack_require__
.
d
=
function
(
exports
name
getter
)
{
if
(
!
__webpack_require__
.
o
(
exports
name
)
)
{
Object
.
defineProperty
(
exports
name
{
configurable
:
false
enumerable
:
true
get
:
getter
}
)
;
}
}
;
__webpack_require__
.
n
=
function
(
module
)
{
var
getter
=
module
&
&
module
.
__esModule
?
function
getDefault
(
)
{
return
module
[
'
default
'
]
;
}
:
function
getModuleExports
(
)
{
return
module
;
}
;
__webpack_require__
.
d
(
getter
'
a
'
getter
)
;
return
getter
;
}
;
__webpack_require__
.
o
=
function
(
object
property
)
{
return
Object
.
prototype
.
hasOwnProperty
.
call
(
object
property
)
;
}
;
__webpack_require__
.
p
=
"
/
assets
/
build
"
;
return
__webpack_require__
(
__webpack_require__
.
s
=
413
)
;
}
)
(
{
0
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_0__
;
}
)
1
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_1__
;
}
)
103
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_103__
;
}
)
108
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
var
_tree
=
_interopRequireDefault
(
__webpack_require__
(
109
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
module
.
exports
=
{
Tree
:
_tree
.
default
}
;
}
)
109
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_reactDomFactories
=
_interopRequireDefault
(
__webpack_require__
(
1
)
)
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
const
{
Component
createFactory
}
=
_react
.
default
;
__webpack_require__
(
110
)
;
const
AUTO_EXPAND_DEPTH
=
0
;
const
FOCUSABLE_SELECTOR
=
[
"
a
[
href
]
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
button
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
iframe
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
input
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
select
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
textarea
:
not
(
[
disabled
]
)
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
"
[
tabindex
]
:
not
(
[
tabindex
=
'
-
1
'
]
)
"
]
.
join
(
"
"
)
;
class
ArrowExpander
extends
Component
{
static
get
propTypes
(
)
{
return
{
expanded
:
_propTypes
.
default
.
bool
}
;
}
shouldComponentUpdate
(
nextProps
nextState
)
{
return
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
render
(
)
{
const
{
expanded
}
=
this
.
props
;
const
classNames
=
[
"
arrow
"
]
;
if
(
expanded
)
{
classNames
.
push
(
"
expanded
"
)
;
}
return
_reactDomFactories
.
default
.
button
(
{
className
:
classNames
.
join
(
"
"
)
}
)
;
}
}
const
treeIndent
=
_reactDomFactories
.
default
.
span
(
{
className
:
"
tree
-
indent
"
}
"
\
u200B
"
)
;
const
treeLastIndent
=
_reactDomFactories
.
default
.
span
(
{
className
:
"
tree
-
indent
tree
-
last
-
indent
"
}
"
\
u200B
"
)
;
class
TreeNode
extends
Component
{
static
get
propTypes
(
)
{
return
{
id
:
_propTypes
.
default
.
any
.
isRequired
index
:
_propTypes
.
default
.
number
.
isRequired
depth
:
_propTypes
.
default
.
number
.
isRequired
focused
:
_propTypes
.
default
.
bool
.
isRequired
active
:
_propTypes
.
default
.
bool
.
isRequired
expanded
:
_propTypes
.
default
.
bool
.
isRequired
item
:
_propTypes
.
default
.
any
.
isRequired
isExpandable
:
_propTypes
.
default
.
bool
.
isRequired
onClick
:
_propTypes
.
default
.
func
shouldItemUpdate
:
_propTypes
.
default
.
func
renderItem
:
_propTypes
.
default
.
func
.
isRequired
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
treeNodeRef
=
_react
.
default
.
createRef
(
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
}
componentDidMount
(
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
if
(
this
.
props
.
active
)
{
const
doc
=
this
.
treeNodeRef
.
current
.
ownerDocument
;
if
(
elms
.
length
>
0
&
&
!
elms
.
includes
(
doc
.
activeElement
)
)
{
elms
[
0
]
.
focus
(
)
;
}
}
else
{
elms
.
forEach
(
elm
=
>
elm
.
setAttribute
(
"
tabindex
"
"
-
1
"
)
)
;
}
}
shouldComponentUpdate
(
nextProps
)
{
return
this
.
props
.
item
!
=
=
nextProps
.
item
|
|
this
.
props
.
shouldItemUpdate
&
&
this
.
props
.
shouldItemUpdate
(
this
.
props
.
item
nextProps
.
item
)
|
|
this
.
props
.
focused
!
=
=
nextProps
.
focused
|
|
this
.
props
.
expanded
!
=
=
nextProps
.
expanded
;
}
getFocusableElements
(
)
{
return
this
.
treeNodeRef
.
current
?
Array
.
from
(
this
.
treeNodeRef
.
current
.
querySelectorAll
(
FOCUSABLE_SELECTOR
)
)
:
[
]
;
}
_wrapMoveFocus
(
current
back
)
{
const
elms
=
this
.
getFocusableElements
(
)
;
let
next
;
if
(
elms
.
length
=
=
=
0
)
{
return
false
;
}
if
(
back
)
{
if
(
elms
.
indexOf
(
current
)
=
=
=
0
)
{
next
=
elms
[
elms
.
length
-
1
]
;
next
.
focus
(
)
;
}
}
else
if
(
elms
.
indexOf
(
current
)
=
=
=
elms
.
length
-
1
)
{
next
=
elms
[
0
]
;
next
.
focus
(
)
;
}
return
!
!
next
;
}
_onKeyDown
(
e
)
{
const
{
target
key
shiftKey
}
=
e
;
if
(
key
!
=
=
"
Tab
"
)
{
return
;
}
const
focusMoved
=
this
.
_wrapMoveFocus
(
target
shiftKey
)
;
if
(
focusMoved
)
{
e
.
preventDefault
(
)
;
}
e
.
stopPropagation
(
)
;
}
render
(
)
{
const
{
depth
id
item
focused
active
expanded
renderItem
isExpandable
}
=
this
.
props
;
const
arrow
=
isExpandable
?
ArrowExpanderFactory
(
{
item
expanded
}
)
:
null
;
let
ariaExpanded
;
if
(
this
.
props
.
isExpandable
)
{
ariaExpanded
=
false
;
}
if
(
this
.
props
.
expanded
)
{
ariaExpanded
=
true
;
}
const
indents
=
Array
.
from
(
{
length
:
depth
}
(
_
i
)
=
>
{
if
(
i
=
=
depth
-
1
)
{
return
treeLastIndent
;
}
return
treeIndent
;
}
)
;
const
items
=
indents
.
concat
(
renderItem
(
item
depth
focused
arrow
expanded
)
)
;
return
_reactDomFactories
.
default
.
div
(
{
id
className
:
tree
-
node
{
focused
?
"
focused
"
:
"
"
}
{
active
?
"
active
"
:
"
"
}
onClick
:
this
.
props
.
onClick
onKeyDownCapture
:
active
?
this
.
_onKeyDown
:
null
role
:
"
treeitem
"
ref
:
this
.
treeNodeRef
"
aria
-
level
"
:
depth
+
1
"
aria
-
expanded
"
:
ariaExpanded
"
data
-
expandable
"
:
this
.
props
.
isExpandable
}
.
.
.
items
)
;
}
}
const
ArrowExpanderFactory
=
createFactory
(
ArrowExpander
)
;
const
TreeNodeFactory
=
createFactory
(
TreeNode
)
;
function
oncePerAnimationFrame
(
fn
{
getDocument
}
)
{
let
animationId
=
null
;
let
argsToPass
=
null
;
return
function
(
.
.
.
args
)
{
argsToPass
=
args
;
if
(
animationId
!
=
=
null
)
{
return
;
}
const
doc
=
getDocument
(
)
;
if
(
!
doc
)
{
return
;
}
animationId
=
doc
.
defaultView
.
requestAnimationFrame
(
(
)
=
>
{
fn
.
call
(
this
.
.
.
argsToPass
)
;
animationId
=
null
;
argsToPass
=
null
;
}
)
;
}
;
}
class
Tree
extends
Component
{
static
get
propTypes
(
)
{
return
{
getParent
:
_propTypes
.
default
.
func
.
isRequired
getChildren
:
_propTypes
.
default
.
func
.
isRequired
shouldItemUpdate
:
_propTypes
.
default
.
func
renderItem
:
_propTypes
.
default
.
func
.
isRequired
getRoots
:
_propTypes
.
default
.
func
.
isRequired
getKey
:
_propTypes
.
default
.
func
.
isRequired
isExpanded
:
_propTypes
.
default
.
func
.
isRequired
focused
:
_propTypes
.
default
.
any
onFocus
:
_propTypes
.
default
.
func
autoExpandDepth
:
_propTypes
.
default
.
number
autoExpandAll
:
_propTypes
.
default
.
bool
autoExpandNodeChildrenLimit
:
_propTypes
.
default
.
number
labelledby
:
_propTypes
.
default
.
string
label
:
_propTypes
.
default
.
string
onExpand
:
_propTypes
.
default
.
func
onCollapse
:
_propTypes
.
default
.
func
active
:
_propTypes
.
default
.
any
onActivate
:
_propTypes
.
default
.
func
isExpandable
:
_propTypes
.
default
.
func
className
:
_propTypes
.
default
.
string
style
:
_propTypes
.
default
.
object
preventBlur
:
_propTypes
.
default
.
bool
}
;
}
static
get
defaultProps
(
)
{
return
{
autoExpandDepth
:
AUTO_EXPAND_DEPTH
autoExpandAll
:
true
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
autoExpanded
:
new
Set
(
)
}
;
this
.
treeRef
=
_react
.
default
.
createRef
(
)
;
const
opaf
=
fn
=
>
oncePerAnimationFrame
(
fn
{
getDocument
:
(
)
=
>
this
.
treeRef
.
current
&
&
this
.
treeRef
.
current
.
ownerDocument
}
)
;
this
.
_onExpand
=
opaf
(
this
.
_onExpand
)
.
bind
(
this
)
;
this
.
_onCollapse
=
opaf
(
this
.
_onCollapse
)
.
bind
(
this
)
;
this
.
_focusPrevNode
=
opaf
(
this
.
_focusPrevNode
)
.
bind
(
this
)
;
this
.
_focusNextNode
=
opaf
(
this
.
_focusNextNode
)
.
bind
(
this
)
;
this
.
_focusParentNode
=
opaf
(
this
.
_focusParentNode
)
.
bind
(
this
)
;
this
.
_focusFirstNode
=
opaf
(
this
.
_focusFirstNode
)
.
bind
(
this
)
;
this
.
_focusLastNode
=
opaf
(
this
.
_focusLastNode
)
.
bind
(
this
)
;
this
.
_autoExpand
=
this
.
_autoExpand
.
bind
(
this
)
;
this
.
_preventArrowKeyScrolling
=
this
.
_preventArrowKeyScrolling
.
bind
(
this
)
;
this
.
_preventEvent
=
this
.
_preventEvent
.
bind
(
this
)
;
this
.
_dfs
=
this
.
_dfs
.
bind
(
this
)
;
this
.
_dfsFromRoots
=
this
.
_dfsFromRoots
.
bind
(
this
)
;
this
.
_focus
=
this
.
_focus
.
bind
(
this
)
;
this
.
_activate
=
this
.
_activate
.
bind
(
this
)
;
this
.
_scrollNodeIntoView
=
this
.
_scrollNodeIntoView
.
bind
(
this
)
;
this
.
_onBlur
=
this
.
_onBlur
.
bind
(
this
)
;
this
.
_onKeyDown
=
this
.
_onKeyDown
.
bind
(
this
)
;
this
.
_nodeIsExpandable
=
this
.
_nodeIsExpandable
.
bind
(
this
)
;
}
componentDidMount
(
)
{
this
.
_autoExpand
(
)
;
if
(
this
.
props
.
focused
)
{
this
.
_scrollNodeIntoView
(
this
.
props
.
focused
)
;
}
}
componentWillReceiveProps
(
nextProps
)
{
this
.
_autoExpand
(
)
;
}
componentDidUpdate
(
prevProps
prevState
)
{
if
(
this
.
props
.
focused
&
&
prevProps
.
focused
!
=
=
this
.
props
.
focused
)
{
this
.
_scrollNodeIntoView
(
this
.
props
.
focused
)
;
}
}
_autoExpand
(
)
{
const
{
autoExpandDepth
autoExpandNodeChildrenLimit
initiallyExpanded
}
=
this
.
props
;
if
(
!
autoExpandDepth
&
&
!
initiallyExpanded
)
{
return
;
}
const
autoExpand
=
(
item
currentDepth
)
=
>
{
const
initial
=
initiallyExpanded
&
&
initiallyExpanded
(
item
)
;
if
(
!
initial
&
&
currentDepth
>
=
autoExpandDepth
)
{
return
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
if
(
!
initial
&
&
autoExpandNodeChildrenLimit
&
&
children
.
length
>
autoExpandNodeChildrenLimit
)
{
return
;
}
if
(
!
this
.
state
.
autoExpanded
.
has
(
item
)
)
{
this
.
props
.
onExpand
(
item
)
;
this
.
state
.
autoExpanded
.
add
(
item
)
;
}
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
children
[
i
]
currentDepth
+
1
)
;
}
}
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
if
(
this
.
props
.
autoExpandAll
)
{
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
else
if
(
length
!
=
0
)
{
autoExpand
(
roots
[
0
]
0
)
;
if
(
initiallyExpanded
)
{
for
(
let
i
=
1
;
i
<
length
;
i
+
+
)
{
if
(
initiallyExpanded
(
roots
[
i
]
)
)
{
autoExpand
(
roots
[
i
]
0
)
;
}
}
}
}
}
_preventArrowKeyScrolling
(
e
)
{
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
case
"
ArrowDown
"
:
case
"
ArrowLeft
"
:
case
"
ArrowRight
"
:
this
.
_preventEvent
(
e
)
;
break
;
}
}
_preventEvent
(
e
)
{
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
if
(
e
.
nativeEvent
)
{
if
(
e
.
nativeEvent
.
preventDefault
)
{
e
.
nativeEvent
.
preventDefault
(
)
;
}
if
(
e
.
nativeEvent
.
stopPropagation
)
{
e
.
nativeEvent
.
stopPropagation
(
)
;
}
}
}
_dfs
(
item
maxDepth
=
Infinity
traversal
=
[
]
_depth
=
0
)
{
traversal
.
push
(
{
item
depth
:
_depth
}
)
;
if
(
!
this
.
props
.
isExpanded
(
item
)
)
{
return
traversal
;
}
const
nextDepth
=
_depth
+
1
;
if
(
nextDepth
>
maxDepth
)
{
return
traversal
;
}
const
children
=
this
.
props
.
getChildren
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
children
[
i
]
maxDepth
traversal
nextDepth
)
;
}
return
traversal
;
}
_dfsFromRoots
(
maxDepth
=
Infinity
)
{
const
traversal
=
[
]
;
const
roots
=
this
.
props
.
getRoots
(
)
;
const
length
=
roots
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
_dfs
(
roots
[
i
]
maxDepth
traversal
)
;
}
return
traversal
;
}
_onExpand
(
item
expandAllChildren
)
{
if
(
this
.
props
.
onExpand
)
{
this
.
props
.
onExpand
(
item
)
;
if
(
expandAllChildren
)
{
const
children
=
this
.
_dfs
(
item
)
;
const
length
=
children
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
this
.
props
.
onExpand
(
children
[
i
]
.
item
)
;
}
}
}
}
_onCollapse
(
item
)
{
if
(
this
.
props
.
onCollapse
)
{
this
.
props
.
onCollapse
(
item
)
;
}
}
_focus
(
item
options
=
{
}
)
{
const
{
preventAutoScroll
}
=
options
;
if
(
item
&
&
!
preventAutoScroll
)
{
this
.
_scrollNodeIntoView
(
item
options
)
;
}
if
(
this
.
props
.
active
!
=
undefined
)
{
this
.
_activate
(
undefined
)
;
const
doc
=
this
.
treeRef
.
current
&
&
this
.
treeRef
.
current
.
ownerDocument
;
if
(
this
.
treeRef
.
current
!
=
=
doc
.
activeElement
)
{
this
.
treeRef
.
current
.
focus
(
)
;
}
}
if
(
this
.
props
.
onFocus
)
{
this
.
props
.
onFocus
(
item
)
;
}
}
_activate
(
item
)
{
if
(
this
.
props
.
onActivate
)
{
this
.
props
.
onActivate
(
item
)
;
}
}
_scrollNodeIntoView
(
item
options
=
{
}
)
{
if
(
item
!
=
=
undefined
)
{
const
treeElement
=
this
.
treeRef
.
current
;
const
doc
=
treeElement
&
&
treeElement
.
ownerDocument
;
const
element
=
doc
.
getElementById
(
this
.
props
.
getKey
(
item
)
)
;
if
(
element
)
{
const
{
top
bottom
}
=
element
.
getBoundingClientRect
(
)
;
const
closestScrolledParent
=
node
=
>
{
if
(
node
=
=
null
)
{
return
null
;
}
if
(
node
.
scrollHeight
>
node
.
clientHeight
)
{
return
node
;
}
return
closestScrolledParent
(
node
.
parentNode
)
;
}
;
const
scrolledParent
=
closestScrolledParent
(
treeElement
)
;
const
scrolledParentRect
=
scrolledParent
?
scrolledParent
.
getBoundingClientRect
(
)
:
null
;
const
isVisible
=
!
scrolledParent
|
|
top
>
=
scrolledParentRect
.
top
&
&
bottom
<
=
scrolledParentRect
.
bottom
;
if
(
!
isVisible
)
{
const
{
alignTo
}
=
options
;
const
scrollToTop
=
alignTo
?
alignTo
=
=
=
"
top
"
:
!
scrolledParentRect
|
|
top
<
scrolledParentRect
.
top
;
element
.
scrollIntoView
(
scrollToTop
)
;
}
}
}
}
_onBlur
(
e
)
{
if
(
this
.
props
.
active
!
=
undefined
)
{
const
{
relatedTarget
}
=
e
;
if
(
!
this
.
treeRef
.
current
.
contains
(
relatedTarget
)
)
{
this
.
_activate
(
undefined
)
;
}
}
else
if
(
!
this
.
props
.
preventBlur
)
{
this
.
_focus
(
undefined
)
;
}
}
_onKeyDown
(
e
)
{
if
(
this
.
props
.
focused
=
=
null
)
{
return
;
}
if
(
e
.
altKey
|
|
e
.
ctrlKey
|
|
e
.
shiftKey
|
|
e
.
metaKey
)
{
return
;
}
this
.
_preventArrowKeyScrolling
(
e
)
;
const
doc
=
this
.
treeRef
.
current
&
&
this
.
treeRef
.
current
.
ownerDocument
;
switch
(
e
.
key
)
{
case
"
ArrowUp
"
:
this
.
_focusPrevNode
(
)
;
return
;
case
"
ArrowDown
"
:
this
.
_focusNextNode
(
)
;
return
;
case
"
ArrowLeft
"
:
if
(
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
&
&
this
.
_nodeIsExpandable
(
this
.
props
.
focused
)
)
{
this
.
_onCollapse
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusParentNode
(
)
;
}
return
;
case
"
ArrowRight
"
:
if
(
this
.
_nodeIsExpandable
(
this
.
props
.
focused
)
&
&
!
this
.
props
.
isExpanded
(
this
.
props
.
focused
)
)
{
this
.
_onExpand
(
this
.
props
.
focused
)
;
}
else
{
this
.
_focusNextNode
(
)
;
}
return
;
case
"
Home
"
:
this
.
_focusFirstNode
(
)
;
return
;
case
"
End
"
:
this
.
_focusLastNode
(
)
;
return
;
case
"
Enter
"
:
case
"
"
:
if
(
this
.
treeRef
.
current
=
=
=
doc
.
activeElement
)
{
this
.
_preventEvent
(
e
)
;
if
(
this
.
props
.
active
!
=
=
this
.
props
.
focused
)
{
this
.
_activate
(
this
.
props
.
focused
)
;
}
}
return
;
case
"
Escape
"
:
this
.
_preventEvent
(
e
)
;
if
(
this
.
props
.
active
!
=
undefined
)
{
this
.
_activate
(
undefined
)
;
}
if
(
this
.
treeRef
.
current
!
=
=
doc
.
activeElement
)
{
this
.
treeRef
.
current
.
focus
(
)
;
}
}
}
_focusPrevNode
(
)
{
let
prev
;
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
for
(
let
i
=
0
;
i
<
length
;
i
+
+
)
{
const
item
=
traversal
[
i
]
.
item
;
if
(
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
prev
=
item
;
}
if
(
prev
=
=
=
undefined
)
{
return
;
}
this
.
_focus
(
prev
{
alignTo
:
"
top
"
}
)
;
}
_focusNextNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
length
=
traversal
.
length
;
let
i
=
0
;
while
(
i
<
length
)
{
if
(
traversal
[
i
]
.
item
=
=
=
this
.
props
.
focused
)
{
break
;
}
i
+
+
;
}
if
(
i
+
1
<
traversal
.
length
)
{
this
.
_focus
(
traversal
[
i
+
1
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
}
_focusParentNode
(
)
{
const
parent
=
this
.
props
.
getParent
(
this
.
props
.
focused
)
;
if
(
!
parent
)
{
this
.
_focusPrevNode
(
this
.
props
.
focused
)
;
return
;
}
this
.
_focus
(
parent
{
alignTo
:
"
top
"
}
)
;
}
_focusFirstNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
this
.
_focus
(
traversal
[
0
]
.
item
{
alignTo
:
"
top
"
}
)
;
}
_focusLastNode
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
lastIndex
=
traversal
.
length
-
1
;
this
.
_focus
(
traversal
[
lastIndex
]
.
item
{
alignTo
:
"
bottom
"
}
)
;
}
_nodeIsExpandable
(
item
)
{
return
this
.
props
.
isExpandable
?
this
.
props
.
isExpandable
(
item
)
:
!
!
this
.
props
.
getChildren
(
item
)
.
length
;
}
render
(
)
{
const
traversal
=
this
.
_dfsFromRoots
(
)
;
const
{
active
focused
}
=
this
.
props
;
const
nodes
=
traversal
.
map
(
(
v
i
)
=
>
{
const
{
item
depth
}
=
traversal
[
i
]
;
const
key
=
this
.
props
.
getKey
(
item
i
)
;
return
TreeNodeFactory
(
{
key
:
{
key
}
-
{
active
=
=
=
item
?
"
active
"
:
"
inactive
"
}
id
:
key
index
:
i
item
depth
shouldItemUpdate
:
this
.
props
.
shouldItemUpdate
renderItem
:
this
.
props
.
renderItem
focused
:
focused
=
=
=
item
active
:
active
=
=
=
item
expanded
:
this
.
props
.
isExpanded
(
item
)
isExpandable
:
this
.
_nodeIsExpandable
(
item
)
onExpand
:
this
.
_onExpand
onCollapse
:
this
.
_onCollapse
onClick
:
e
=
>
{
e
.
stopPropagation
(
)
;
this
.
_focus
(
item
{
preventAutoScroll
:
true
}
)
;
if
(
this
.
props
.
isExpanded
(
item
)
)
{
this
.
props
.
onCollapse
(
item
e
.
altKey
)
;
}
else
{
this
.
props
.
onExpand
(
item
e
.
altKey
)
;
}
this
.
treeRef
.
current
.
focus
(
)
;
}
}
)
;
}
)
;
const
style
=
Object
.
assign
(
{
}
this
.
props
.
style
|
|
{
}
)
;
return
_reactDomFactories
.
default
.
div
(
{
className
:
tree
{
this
.
props
.
className
?
this
.
props
.
className
:
"
"
}
ref
:
this
.
treeRef
role
:
"
tree
"
tabIndex
:
"
0
"
onKeyDown
:
this
.
_onKeyDown
onKeyPress
:
this
.
_preventArrowKeyScrolling
onKeyUp
:
this
.
_preventArrowKeyScrolling
onFocus
:
(
{
nativeEvent
}
)
=
>
{
if
(
focused
|
|
!
nativeEvent
|
|
!
this
.
treeRef
.
current
)
{
return
;
}
const
{
explicitOriginalTarget
}
=
nativeEvent
;
if
(
explicitOriginalTarget
!
=
=
this
.
treeRef
.
current
&
&
!
this
.
treeRef
.
current
.
contains
(
explicitOriginalTarget
)
)
{
this
.
_focus
(
traversal
[
0
]
.
item
)
;
}
}
onBlur
:
this
.
_onBlur
"
aria
-
label
"
:
this
.
props
.
label
"
aria
-
labelledby
"
:
this
.
props
.
labelledby
"
aria
-
activedescendant
"
:
focused
&
&
this
.
props
.
getKey
(
focused
)
style
}
nodes
)
;
}
}
var
_default
=
Tree
;
exports
.
default
=
_default
;
}
)
110
:
(
function
(
module
exports
)
{
}
)
111
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
computeScore
countDir
file_coeff
getExtension
getExtensionScore
isMatch
scorePath
scoreSize
tau_depth
_ref
;
_ref
=
__webpack_require__
(
66
)
isMatch
=
_ref
.
isMatch
computeScore
=
_ref
.
computeScore
scoreSize
=
_ref
.
scoreSize
;
tau_depth
=
20
;
file_coeff
=
2
.
5
;
exports
.
score
=
function
(
string
query
options
)
{
var
allowErrors
preparedQuery
score
string_lw
;
preparedQuery
=
options
.
preparedQuery
allowErrors
=
options
.
allowErrors
;
if
(
!
(
allowErrors
|
|
isMatch
(
string
preparedQuery
.
core_lw
preparedQuery
.
core_up
)
)
)
{
return
0
;
}
string_lw
=
string
.
toLowerCase
(
)
;
score
=
computeScore
(
string
string_lw
preparedQuery
)
;
score
=
scorePath
(
string
string_lw
score
options
)
;
return
Math
.
ceil
(
score
)
;
}
;
scorePath
=
function
(
subject
subject_lw
fullPathScore
options
)
{
var
alpha
basePathScore
basePos
depth
end
extAdjust
fileLength
pathSeparator
preparedQuery
useExtensionBonus
;
if
(
fullPathScore
=
=
=
0
)
{
return
0
;
}
preparedQuery
=
options
.
preparedQuery
useExtensionBonus
=
options
.
useExtensionBonus
pathSeparator
=
options
.
pathSeparator
;
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
pathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
pathSeparator
end
)
;
fileLength
=
end
-
basePos
;
extAdjust
=
1
.
0
;
if
(
useExtensionBonus
)
{
extAdjust
+
=
getExtensionScore
(
subject_lw
preparedQuery
.
ext
basePos
end
2
)
;
fullPathScore
*
=
extAdjust
;
}
if
(
basePos
=
=
=
-
1
)
{
return
fullPathScore
;
}
depth
=
preparedQuery
.
depth
;
while
(
basePos
>
-
1
&
&
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
pathSeparator
basePos
-
1
)
;
}
basePathScore
=
basePos
=
=
=
-
1
?
fullPathScore
:
extAdjust
*
computeScore
(
subject
.
slice
(
basePos
+
1
end
+
1
)
subject_lw
.
slice
(
basePos
+
1
end
+
1
)
preparedQuery
)
;
alpha
=
0
.
5
*
tau_depth
/
(
tau_depth
+
countDir
(
subject
end
+
1
pathSeparator
)
)
;
return
alpha
*
basePathScore
+
(
1
-
alpha
)
*
fullPathScore
*
scoreSize
(
0
file_coeff
*
fileLength
)
;
}
;
exports
.
countDir
=
countDir
=
function
(
path
end
pathSeparator
)
{
var
count
i
;
if
(
end
<
1
)
{
return
0
;
}
count
=
0
;
i
=
-
1
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
pathSeparator
)
{
continue
;
}
while
(
+
+
i
<
end
)
{
if
(
path
[
i
]
=
=
=
pathSeparator
)
{
count
+
+
;
while
(
+
+
i
<
end
&
&
path
[
i
]
=
=
=
pathSeparator
)
{
continue
;
}
}
}
return
count
;
}
;
exports
.
getExtension
=
getExtension
=
function
(
str
)
{
var
pos
;
pos
=
str
.
lastIndexOf
(
"
.
"
)
;
if
(
pos
<
0
)
{
return
"
"
;
}
else
{
return
str
.
substr
(
pos
+
1
)
;
}
}
;
getExtensionScore
=
function
(
candidate
ext
startPos
endPos
maxDepth
)
{
var
m
matched
n
pos
;
if
(
!
ext
.
length
)
{
return
0
;
}
pos
=
candidate
.
lastIndexOf
(
"
.
"
endPos
)
;
if
(
!
(
pos
>
startPos
)
)
{
return
0
;
}
n
=
ext
.
length
;
m
=
endPos
-
pos
;
if
(
m
<
n
)
{
n
=
m
;
m
=
ext
.
length
;
}
pos
+
+
;
matched
=
-
1
;
while
(
+
+
matched
<
n
)
{
if
(
candidate
[
pos
+
matched
]
!
=
=
ext
[
matched
]
)
{
break
;
}
}
if
(
matched
=
=
=
0
&
&
maxDepth
>
0
)
{
return
0
.
9
*
getExtensionScore
(
candidate
ext
startPos
pos
-
2
maxDepth
-
1
)
;
}
return
matched
/
m
;
}
;
}
)
.
call
(
this
)
;
}
)
112
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_112__
;
}
)
13
:
(
function
(
module
exports
)
{
function
networkRequest
(
url
opts
)
{
return
fetch
(
url
{
cache
:
opts
.
loadFromCache
?
"
default
"
:
"
no
-
cache
"
}
)
.
then
(
res
=
>
{
if
(
res
.
status
>
=
200
&
&
res
.
status
<
300
)
{
if
(
res
.
headers
.
get
(
"
Content
-
Type
"
)
=
=
=
"
application
/
wasm
"
)
{
return
res
.
arrayBuffer
(
)
.
then
(
buffer
=
>
(
{
content
:
buffer
isDwarf
:
true
}
)
)
;
}
return
res
.
text
(
)
.
then
(
text
=
>
(
{
content
:
text
}
)
)
;
}
return
Promise
.
reject
(
request
failed
with
status
{
res
.
status
}
)
;
}
)
;
}
module
.
exports
=
networkRequest
;
}
)
14
:
(
function
(
module
exports
)
{
function
WorkerDispatcher
(
)
{
this
.
msgId
=
1
;
this
.
worker
=
null
;
}
WorkerDispatcher
.
prototype
=
{
start
(
url
win
=
window
)
{
this
.
worker
=
new
win
.
Worker
(
url
)
;
this
.
worker
.
onerror
=
err
=
>
{
console
.
error
(
Error
in
worker
{
url
}
err
.
message
)
;
}
;
}
stop
(
)
{
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
terminate
(
)
;
this
.
worker
=
null
;
}
task
(
method
{
queue
=
false
}
=
{
}
)
{
const
calls
=
[
]
;
const
push
=
args
=
>
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
queue
&
&
calls
.
length
=
=
=
0
)
{
Promise
.
resolve
(
)
.
then
(
flush
)
;
}
calls
.
push
(
[
args
resolve
reject
]
)
;
if
(
!
queue
)
{
flush
(
)
;
}
}
)
;
}
;
const
flush
=
(
)
=
>
{
const
items
=
calls
.
slice
(
)
;
calls
.
length
=
0
;
if
(
!
this
.
worker
)
{
return
;
}
const
id
=
this
.
msgId
+
+
;
this
.
worker
.
postMessage
(
{
id
method
calls
:
items
.
map
(
item
=
>
item
[
0
]
)
}
)
;
const
listener
=
(
{
data
:
result
}
)
=
>
{
if
(
result
.
id
!
=
=
id
)
{
return
;
}
if
(
!
this
.
worker
)
{
return
;
}
this
.
worker
.
removeEventListener
(
"
message
"
listener
)
;
result
.
results
.
forEach
(
(
resultData
i
)
=
>
{
const
[
resolve
reject
]
=
items
[
i
]
;
if
(
resultData
.
error
)
{
const
err
=
new
Error
(
resultData
.
message
)
;
err
.
metadata
=
resultData
.
metadata
;
reject
(
err
)
;
}
else
{
resolve
(
resultData
.
response
)
;
}
}
)
;
}
;
this
.
worker
.
addEventListener
(
"
message
"
listener
)
;
}
;
return
(
.
.
.
args
)
=
>
push
(
args
)
;
}
invoke
(
method
.
.
.
args
)
{
return
this
.
task
(
method
)
(
.
.
.
args
)
;
}
}
;
function
workerHandler
(
publicInterface
)
{
return
function
(
msg
)
{
const
{
id
method
calls
}
=
msg
.
data
;
Promise
.
all
(
calls
.
map
(
args
=
>
{
try
{
const
response
=
publicInterface
[
method
]
.
apply
(
undefined
args
)
;
if
(
response
instanceof
Promise
)
{
return
response
.
then
(
val
=
>
(
{
response
:
val
}
)
err
=
>
asErrorMessage
(
err
)
)
;
}
return
{
response
}
;
}
catch
(
error
)
{
return
asErrorMessage
(
error
)
;
}
}
)
)
.
then
(
results
=
>
{
self
.
postMessage
(
{
id
results
}
)
;
}
)
;
}
;
}
function
asErrorMessage
(
error
)
{
if
(
typeof
error
=
=
=
"
object
"
&
&
error
&
&
"
message
"
in
error
)
{
return
{
error
:
true
message
:
error
.
message
metadata
:
error
.
metadata
}
;
}
return
{
error
:
true
message
:
error
=
=
null
?
error
:
error
.
toString
(
)
metadata
:
undefined
}
;
}
module
.
exports
=
{
WorkerDispatcher
workerHandler
}
;
}
)
184
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
Query
coreChars
countDir
getCharCodes
getExtension
opt_char_re
truncatedUpperCase
_ref
;
_ref
=
__webpack_require__
(
111
)
countDir
=
_ref
.
countDir
getExtension
=
_ref
.
getExtension
;
module
.
exports
=
Query
=
(
function
(
)
{
function
Query
(
query
_arg
)
{
var
optCharRegEx
pathSeparator
_ref1
;
_ref1
=
_arg
!
=
null
?
_arg
:
{
}
optCharRegEx
=
_ref1
.
optCharRegEx
pathSeparator
=
_ref1
.
pathSeparator
;
if
(
!
(
query
&
&
query
.
length
)
)
{
return
null
;
}
this
.
query
=
query
;
this
.
query_lw
=
query
.
toLowerCase
(
)
;
this
.
core
=
coreChars
(
query
optCharRegEx
)
;
this
.
core_lw
=
this
.
core
.
toLowerCase
(
)
;
this
.
core_up
=
truncatedUpperCase
(
this
.
core
)
;
this
.
depth
=
countDir
(
query
query
.
length
pathSeparator
)
;
this
.
ext
=
getExtension
(
this
.
query_lw
)
;
this
.
charCodes
=
getCharCodes
(
this
.
query_lw
)
;
}
return
Query
;
}
)
(
)
;
opt_char_re
=
/
[
_
\
-
:
\
/
\
\
]
/
g
;
coreChars
=
function
(
query
optCharRegEx
)
{
if
(
optCharRegEx
=
=
null
)
{
optCharRegEx
=
opt_char_re
;
}
return
query
.
replace
(
optCharRegEx
'
'
)
;
}
;
truncatedUpperCase
=
function
(
str
)
{
var
char
upper
_i
_len
;
upper
=
"
"
;
for
(
_i
=
0
_len
=
str
.
length
;
_i
<
_len
;
_i
+
+
)
{
char
=
str
[
_i
]
;
upper
+
=
char
.
toUpperCase
(
)
[
0
]
;
}
return
upper
;
}
;
getCharCodes
=
function
(
str
)
{
var
charCodes
i
len
;
len
=
str
.
length
;
i
=
-
1
;
charCodes
=
[
]
;
while
(
+
+
i
<
len
)
{
charCodes
[
str
.
charCodeAt
(
i
)
]
=
true
;
}
return
charCodes
;
}
;
}
)
.
call
(
this
)
;
}
)
185
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_tab
=
_interopRequireDefault
(
__webpack_require__
(
186
)
)
;
var
_tabList
=
_interopRequireDefault
(
__webpack_require__
(
441
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
class
TabList
extends
_react
.
default
.
Component
{
constructor
(
props
)
{
super
(
props
)
;
const
childrenCount
=
_react
.
default
.
Children
.
count
(
props
.
children
)
;
this
.
handleKeyPress
=
this
.
handleKeyPress
.
bind
(
this
)
;
this
.
tabRefs
=
new
Array
(
childrenCount
)
.
fill
(
0
)
.
map
(
(
)
=
>
_react
.
default
.
createRef
(
)
)
;
this
.
handlers
=
this
.
getHandlers
(
props
.
vertical
)
;
}
componentDidUpdate
(
prevProps
)
{
if
(
prevProps
.
activeIndex
!
=
=
this
.
props
.
activeIndex
)
{
this
.
tabRefs
[
this
.
props
.
activeIndex
]
.
current
.
focus
(
)
;
}
}
getHandlers
(
vertical
)
{
if
(
vertical
)
{
return
{
ArrowDown
:
this
.
next
.
bind
(
this
)
ArrowUp
:
this
.
previous
.
bind
(
this
)
}
;
}
return
{
ArrowLeft
:
this
.
previous
.
bind
(
this
)
ArrowRight
:
this
.
next
.
bind
(
this
)
}
;
}
wrapIndex
(
index
)
{
const
count
=
_react
.
default
.
Children
.
count
(
this
.
props
.
children
)
;
return
(
index
+
count
)
%
count
;
}
handleKeyPress
(
event
)
{
const
handler
=
this
.
handlers
[
event
.
key
]
;
if
(
handler
)
{
handler
(
)
;
}
}
previous
(
)
{
const
newIndex
=
this
.
wrapIndex
(
this
.
props
.
activeIndex
-
1
)
;
this
.
props
.
onActivateTab
(
newIndex
)
;
}
next
(
)
{
const
newIndex
=
this
.
wrapIndex
(
this
.
props
.
activeIndex
+
1
)
;
this
.
props
.
onActivateTab
(
newIndex
)
;
}
render
(
)
{
const
{
accessibleId
activeIndex
children
className
onActivateTab
}
=
this
.
props
;
return
_react
.
default
.
createElement
(
"
ul
"
{
className
:
className
onKeyUp
:
this
.
handleKeyPress
role
:
"
tablist
"
}
_react
.
default
.
Children
.
map
(
children
(
child
index
)
=
>
{
if
(
child
.
type
!
=
=
_tab
.
default
)
{
throw
new
Error
(
'
Direct
children
of
a
<
TabList
>
must
be
a
<
Tab
>
'
)
;
}
const
active
=
index
=
=
=
activeIndex
;
const
tabRef
=
this
.
tabRefs
[
index
]
;
return
_react
.
default
.
cloneElement
(
child
{
accessibleId
:
active
?
accessibleId
:
undefined
active
tabRef
onActivate
:
(
)
=
>
onActivateTab
(
index
)
}
)
;
}
)
)
;
}
}
exports
.
default
=
TabList
;
TabList
.
propTypes
=
{
accessibleId
:
_propTypes
.
default
.
string
activeIndex
:
_propTypes
.
default
.
number
children
:
_propTypes
.
default
.
node
className
:
_propTypes
.
default
.
string
onActivateTab
:
_propTypes
.
default
.
func
vertical
:
_propTypes
.
default
.
bool
}
;
TabList
.
defaultProps
=
{
accessibleId
:
undefined
activeIndex
:
0
children
:
null
className
:
_tabList
.
default
.
container
onActivateTab
:
(
)
=
>
{
}
vertical
:
false
}
;
}
)
186
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
Tab
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_ref
=
_interopRequireDefault
(
__webpack_require__
(
439
)
)
;
var
_tab
=
_interopRequireDefault
(
__webpack_require__
(
440
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
Tab
(
{
accessibleId
active
children
className
onActivate
tabRef
}
)
{
return
_react
.
default
.
createElement
(
"
li
"
{
"
aria
-
selected
"
:
active
className
:
className
id
:
accessibleId
onClick
:
onActivate
onKeyDown
:
(
)
=
>
{
}
ref
:
tabRef
role
:
"
tab
"
tabIndex
:
active
?
0
:
undefined
}
children
)
;
}
Tab
.
propTypes
=
{
accessibleId
:
_propTypes
.
default
.
string
active
:
_propTypes
.
default
.
bool
children
:
_propTypes
.
default
.
node
.
isRequired
className
:
_propTypes
.
default
.
string
onActivate
:
_propTypes
.
default
.
func
tabRef
:
_ref
.
default
}
;
Tab
.
defaultProps
=
{
accessibleId
:
undefined
active
:
false
className
:
_tab
.
default
.
container
onActivate
:
undefined
tabRef
:
undefined
}
;
}
)
187
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
TabPanels
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
TabPanels
(
{
accessibleId
activeIndex
children
className
hasFocusableContent
}
)
{
return
_react
.
default
.
createElement
(
"
div
"
{
"
aria
-
labelledby
"
:
accessibleId
role
:
"
tabpanel
"
className
:
className
tabIndex
:
hasFocusableContent
?
undefined
:
0
}
_react
.
default
.
Children
.
toArray
(
children
)
[
activeIndex
]
)
;
}
TabPanels
.
propTypes
=
{
accessibleId
:
_propTypes
.
default
.
string
activeIndex
:
_propTypes
.
default
.
number
children
:
_propTypes
.
default
.
node
.
isRequired
className
:
_propTypes
.
default
.
string
hasFocusableContent
:
_propTypes
.
default
.
bool
.
isRequired
}
;
TabPanels
.
defaultProps
=
{
accessibleId
:
undefined
activeIndex
:
0
className
:
null
}
;
}
)
35
:
(
function
(
module
exports
)
{
var
process
=
module
.
exports
=
{
}
;
var
cachedSetTimeout
;
var
cachedClearTimeout
;
function
defaultSetTimout
(
)
{
throw
new
Error
(
'
setTimeout
has
not
been
defined
'
)
;
}
function
defaultClearTimeout
(
)
{
throw
new
Error
(
'
clearTimeout
has
not
been
defined
'
)
;
}
(
function
(
)
{
try
{
if
(
typeof
setTimeout
=
=
=
'
function
'
)
{
cachedSetTimeout
=
setTimeout
;
}
else
{
cachedSetTimeout
=
defaultSetTimout
;
}
}
catch
(
e
)
{
cachedSetTimeout
=
defaultSetTimout
;
}
try
{
if
(
typeof
clearTimeout
=
=
=
'
function
'
)
{
cachedClearTimeout
=
clearTimeout
;
}
else
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
catch
(
e
)
{
cachedClearTimeout
=
defaultClearTimeout
;
}
}
(
)
)
function
runTimeout
(
fun
)
{
if
(
cachedSetTimeout
=
=
=
setTimeout
)
{
return
setTimeout
(
fun
0
)
;
}
if
(
(
cachedSetTimeout
=
=
=
defaultSetTimout
|
|
!
cachedSetTimeout
)
&
&
setTimeout
)
{
cachedSetTimeout
=
setTimeout
;
return
setTimeout
(
fun
0
)
;
}
try
{
return
cachedSetTimeout
(
fun
0
)
;
}
catch
(
e
)
{
try
{
return
cachedSetTimeout
.
call
(
null
fun
0
)
;
}
catch
(
e
)
{
return
cachedSetTimeout
.
call
(
this
fun
0
)
;
}
}
}
function
runClearTimeout
(
marker
)
{
if
(
cachedClearTimeout
=
=
=
clearTimeout
)
{
return
clearTimeout
(
marker
)
;
}
if
(
(
cachedClearTimeout
=
=
=
defaultClearTimeout
|
|
!
cachedClearTimeout
)
&
&
clearTimeout
)
{
cachedClearTimeout
=
clearTimeout
;
return
clearTimeout
(
marker
)
;
}
try
{
return
cachedClearTimeout
(
marker
)
;
}
catch
(
e
)
{
try
{
return
cachedClearTimeout
.
call
(
null
marker
)
;
}
catch
(
e
)
{
return
cachedClearTimeout
.
call
(
this
marker
)
;
}
}
}
var
queue
=
[
]
;
var
draining
=
false
;
var
currentQueue
;
var
queueIndex
=
-
1
;
function
cleanUpNextTick
(
)
{
if
(
!
draining
|
|
!
currentQueue
)
{
return
;
}
draining
=
false
;
if
(
currentQueue
.
length
)
{
queue
=
currentQueue
.
concat
(
queue
)
;
}
else
{
queueIndex
=
-
1
;
}
if
(
queue
.
length
)
{
drainQueue
(
)
;
}
}
function
drainQueue
(
)
{
if
(
draining
)
{
return
;
}
var
timeout
=
runTimeout
(
cleanUpNextTick
)
;
draining
=
true
;
var
len
=
queue
.
length
;
while
(
len
)
{
currentQueue
=
queue
;
queue
=
[
]
;
while
(
+
+
queueIndex
<
len
)
{
if
(
currentQueue
)
{
currentQueue
[
queueIndex
]
.
run
(
)
;
}
}
queueIndex
=
-
1
;
len
=
queue
.
length
;
}
currentQueue
=
null
;
draining
=
false
;
runClearTimeout
(
timeout
)
;
}
process
.
nextTick
=
function
(
fun
)
{
var
args
=
new
Array
(
arguments
.
length
-
1
)
;
if
(
arguments
.
length
>
1
)
{
for
(
var
i
=
1
;
i
<
arguments
.
length
;
i
+
+
)
{
args
[
i
-
1
]
=
arguments
[
i
]
;
}
}
queue
.
push
(
new
Item
(
fun
args
)
)
;
if
(
queue
.
length
=
=
=
1
&
&
!
draining
)
{
runTimeout
(
drainQueue
)
;
}
}
;
function
Item
(
fun
array
)
{
this
.
fun
=
fun
;
this
.
array
=
array
;
}
Item
.
prototype
.
run
=
function
(
)
{
this
.
fun
.
apply
(
null
this
.
array
)
;
}
;
process
.
title
=
'
browser
'
;
process
.
browser
=
true
;
process
.
env
=
{
}
;
process
.
argv
=
[
]
;
process
.
version
=
'
'
;
process
.
versions
=
{
}
;
function
noop
(
)
{
}
process
.
on
=
noop
;
process
.
addListener
=
noop
;
process
.
once
=
noop
;
process
.
off
=
noop
;
process
.
removeListener
=
noop
;
process
.
removeAllListeners
=
noop
;
process
.
emit
=
noop
;
process
.
prependListener
=
noop
;
process
.
prependOnceListener
=
noop
;
process
.
listeners
=
function
(
name
)
{
return
[
]
}
process
.
binding
=
function
(
name
)
{
throw
new
Error
(
'
process
.
binding
is
not
supported
'
)
;
}
;
process
.
cwd
=
function
(
)
{
return
'
/
'
}
;
process
.
chdir
=
function
(
dir
)
{
throw
new
Error
(
'
process
.
chdir
is
not
supported
'
)
;
}
;
process
.
umask
=
function
(
)
{
return
0
;
}
;
}
)
413
:
(
function
(
module
exports
__webpack_require__
)
{
module
.
exports
=
__webpack_require__
(
414
)
;
}
)
414
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
vendored
=
void
0
;
var
devtoolsComponents
=
_interopRequireWildcard
(
__webpack_require__
(
108
)
)
;
var
devtoolsConfig
=
_interopRequireWildcard
(
__webpack_require__
(
550
)
)
;
var
devtoolsEnvironment
=
_interopRequireWildcard
(
__webpack_require__
(
554
)
)
;
var
devtoolsUtils
=
_interopRequireWildcard
(
__webpack_require__
(
7
)
)
;
var
fuzzaldrinPlus
=
_interopRequireWildcard
(
__webpack_require__
(
432
)
)
;
var
transition
=
_interopRequireWildcard
(
__webpack_require__
(
435
)
)
;
var
reactAriaComponentsTabs
=
_interopRequireWildcard
(
__webpack_require__
(
438
)
)
;
var
_classnames
=
_interopRequireDefault
(
__webpack_require__
(
67
)
)
;
var
_devtoolsSplitter
=
_interopRequireDefault
(
__webpack_require__
(
445
)
)
;
var
_lodashMove
=
_interopRequireDefault
(
__webpack_require__
(
449
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_getRequireWildcardCache
(
)
{
if
(
typeof
WeakMap
!
=
=
"
function
"
)
return
null
;
var
cache
=
new
WeakMap
(
)
;
_getRequireWildcardCache
=
function
(
)
{
return
cache
;
}
;
return
cache
;
}
function
_interopRequireWildcard
(
obj
)
{
if
(
obj
&
&
obj
.
__esModule
)
{
return
obj
;
}
if
(
obj
=
=
=
null
|
|
typeof
obj
!
=
=
"
object
"
&
&
typeof
obj
!
=
=
"
function
"
)
{
return
{
default
:
obj
}
;
}
var
cache
=
_getRequireWildcardCache
(
)
;
if
(
cache
&
&
cache
.
has
(
obj
)
)
{
return
cache
.
get
(
obj
)
;
}
var
newObj
=
{
}
;
var
hasPropertyDescriptor
=
Object
.
defineProperty
&
&
Object
.
getOwnPropertyDescriptor
;
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
{
var
desc
=
hasPropertyDescriptor
?
Object
.
getOwnPropertyDescriptor
(
obj
key
)
:
null
;
if
(
desc
&
&
(
desc
.
get
|
|
desc
.
set
)
)
{
Object
.
defineProperty
(
newObj
key
desc
)
;
}
else
{
newObj
[
key
]
=
obj
[
key
]
;
}
}
}
newObj
.
default
=
obj
;
if
(
cache
)
{
cache
.
set
(
obj
newObj
)
;
}
return
newObj
;
}
const
vendored
=
{
classnames
:
_classnames
.
default
"
devtools
-
components
"
:
devtoolsComponents
"
devtools
-
config
"
:
devtoolsConfig
"
devtools
-
environment
"
:
devtoolsEnvironment
"
devtools
-
splitter
"
:
_devtoolsSplitter
.
default
"
devtools
-
utils
"
:
devtoolsUtils
"
fuzzaldrin
-
plus
"
:
fuzzaldrinPlus
"
lodash
-
move
"
:
_lodashMove
.
default
"
react
-
aria
-
components
/
src
/
tabs
"
:
reactAriaComponentsTabs
"
react
-
transition
-
group
/
Transition
"
:
transition
}
;
exports
.
vendored
=
vendored
;
}
)
417
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_417__
;
}
)
418
:
(
function
(
module
exports
)
{
}
)
419
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
function
normalizeArray
(
parts
allowAboveRoot
)
{
var
up
=
0
;
for
(
var
i
=
parts
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
var
last
=
parts
[
i
]
;
if
(
last
=
=
=
'
.
'
)
{
parts
.
splice
(
i
1
)
;
}
else
if
(
last
=
=
=
'
.
.
'
)
{
parts
.
splice
(
i
1
)
;
up
+
+
;
}
else
if
(
up
)
{
parts
.
splice
(
i
1
)
;
up
-
-
;
}
}
if
(
allowAboveRoot
)
{
for
(
;
up
-
-
;
up
)
{
parts
.
unshift
(
'
.
.
'
)
;
}
}
return
parts
;
}
exports
.
resolve
=
function
(
)
{
var
resolvedPath
=
'
'
resolvedAbsolute
=
false
;
for
(
var
i
=
arguments
.
length
-
1
;
i
>
=
-
1
&
&
!
resolvedAbsolute
;
i
-
-
)
{
var
path
=
(
i
>
=
0
)
?
arguments
[
i
]
:
process
.
cwd
(
)
;
if
(
typeof
path
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
resolve
must
be
strings
'
)
;
}
else
if
(
!
path
)
{
continue
;
}
resolvedPath
=
path
+
'
/
'
+
resolvedPath
;
resolvedAbsolute
=
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
resolvedPath
=
normalizeArray
(
filter
(
resolvedPath
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
resolvedAbsolute
)
.
join
(
'
/
'
)
;
return
(
(
resolvedAbsolute
?
'
/
'
:
'
'
)
+
resolvedPath
)
|
|
'
.
'
;
}
;
exports
.
normalize
=
function
(
path
)
{
var
isAbsolute
=
exports
.
isAbsolute
(
path
)
trailingSlash
=
substr
(
path
-
1
)
=
=
=
'
/
'
;
path
=
normalizeArray
(
filter
(
path
.
split
(
'
/
'
)
function
(
p
)
{
return
!
!
p
;
}
)
!
isAbsolute
)
.
join
(
'
/
'
)
;
if
(
!
path
&
&
!
isAbsolute
)
{
path
=
'
.
'
;
}
if
(
path
&
&
trailingSlash
)
{
path
+
=
'
/
'
;
}
return
(
isAbsolute
?
'
/
'
:
'
'
)
+
path
;
}
;
exports
.
isAbsolute
=
function
(
path
)
{
return
path
.
charAt
(
0
)
=
=
=
'
/
'
;
}
;
exports
.
join
=
function
(
)
{
var
paths
=
Array
.
prototype
.
slice
.
call
(
arguments
0
)
;
return
exports
.
normalize
(
filter
(
paths
function
(
p
index
)
{
if
(
typeof
p
!
=
=
'
string
'
)
{
throw
new
TypeError
(
'
Arguments
to
path
.
join
must
be
strings
'
)
;
}
return
p
;
}
)
.
join
(
'
/
'
)
)
;
}
;
exports
.
relative
=
function
(
from
to
)
{
from
=
exports
.
resolve
(
from
)
.
substr
(
1
)
;
to
=
exports
.
resolve
(
to
)
.
substr
(
1
)
;
function
trim
(
arr
)
{
var
start
=
0
;
for
(
;
start
<
arr
.
length
;
start
+
+
)
{
if
(
arr
[
start
]
!
=
=
'
'
)
break
;
}
var
end
=
arr
.
length
-
1
;
for
(
;
end
>
=
0
;
end
-
-
)
{
if
(
arr
[
end
]
!
=
=
'
'
)
break
;
}
if
(
start
>
end
)
return
[
]
;
return
arr
.
slice
(
start
end
-
start
+
1
)
;
}
var
fromParts
=
trim
(
from
.
split
(
'
/
'
)
)
;
var
toParts
=
trim
(
to
.
split
(
'
/
'
)
)
;
var
length
=
Math
.
min
(
fromParts
.
length
toParts
.
length
)
;
var
samePartsLength
=
length
;
for
(
var
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
fromParts
[
i
]
!
=
=
toParts
[
i
]
)
{
samePartsLength
=
i
;
break
;
}
}
var
outputParts
=
[
]
;
for
(
var
i
=
samePartsLength
;
i
<
fromParts
.
length
;
i
+
+
)
{
outputParts
.
push
(
'
.
.
'
)
;
}
outputParts
=
outputParts
.
concat
(
toParts
.
slice
(
samePartsLength
)
)
;
return
outputParts
.
join
(
'
/
'
)
;
}
;
exports
.
sep
=
'
/
'
;
exports
.
delimiter
=
'
:
'
;
exports
.
dirname
=
function
(
path
)
{
if
(
typeof
path
!
=
=
'
string
'
)
path
=
path
+
'
'
;
if
(
path
.
length
=
=
=
0
)
return
'
.
'
;
var
code
=
path
.
charCodeAt
(
0
)
;
var
hasRoot
=
code
=
=
=
47
;
var
end
=
-
1
;
var
matchedSlash
=
true
;
for
(
var
i
=
path
.
length
-
1
;
i
>
=
1
;
-
-
i
)
{
code
=
path
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
47
)
{
if
(
!
matchedSlash
)
{
end
=
i
;
break
;
}
}
else
{
matchedSlash
=
false
;
}
}
if
(
end
=
=
=
-
1
)
return
hasRoot
?
'
/
'
:
'
.
'
;
if
(
hasRoot
&
&
end
=
=
=
1
)
{
return
'
/
'
;
}
return
path
.
slice
(
0
end
)
;
}
;
function
basename
(
path
)
{
if
(
typeof
path
!
=
=
'
string
'
)
path
=
path
+
'
'
;
var
start
=
0
;
var
end
=
-
1
;
var
matchedSlash
=
true
;
var
i
;
for
(
i
=
path
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
path
.
charCodeAt
(
i
)
=
=
=
47
)
{
if
(
!
matchedSlash
)
{
start
=
i
+
1
;
break
;
}
}
else
if
(
end
=
=
=
-
1
)
{
matchedSlash
=
false
;
end
=
i
+
1
;
}
}
if
(
end
=
=
=
-
1
)
return
'
'
;
return
path
.
slice
(
start
end
)
;
}
exports
.
basename
=
function
(
path
ext
)
{
var
f
=
basename
(
path
)
;
if
(
ext
&
&
f
.
substr
(
-
1
*
ext
.
length
)
=
=
=
ext
)
{
f
=
f
.
substr
(
0
f
.
length
-
ext
.
length
)
;
}
return
f
;
}
;
exports
.
extname
=
function
(
path
)
{
if
(
typeof
path
!
=
=
'
string
'
)
path
=
path
+
'
'
;
var
startDot
=
-
1
;
var
startPart
=
0
;
var
end
=
-
1
;
var
matchedSlash
=
true
;
var
preDotState
=
0
;
for
(
var
i
=
path
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
var
code
=
path
.
charCodeAt
(
i
)
;
if
(
code
=
=
=
47
)
{
if
(
!
matchedSlash
)
{
startPart
=
i
+
1
;
break
;
}
continue
;
}
if
(
end
=
=
=
-
1
)
{
matchedSlash
=
false
;
end
=
i
+
1
;
}
if
(
code
=
=
=
46
)
{
if
(
startDot
=
=
=
-
1
)
startDot
=
i
;
else
if
(
preDotState
!
=
=
1
)
preDotState
=
1
;
}
else
if
(
startDot
!
=
=
-
1
)
{
preDotState
=
-
1
;
}
}
if
(
startDot
=
=
=
-
1
|
|
end
=
=
=
-
1
|
|
preDotState
=
=
=
0
|
|
preDotState
=
=
=
1
&
&
startDot
=
=
=
end
-
1
&
&
startDot
=
=
=
startPart
+
1
)
{
return
'
'
;
}
return
path
.
slice
(
startDot
end
)
;
}
;
function
filter
(
xs
f
)
{
if
(
xs
.
filter
)
return
xs
.
filter
(
f
)
;
var
res
=
[
]
;
for
(
var
i
=
0
;
i
<
xs
.
length
;
i
+
+
)
{
if
(
f
(
xs
[
i
]
i
xs
)
)
res
.
push
(
xs
[
i
]
)
;
}
return
res
;
}
var
substr
=
'
ab
'
.
substr
(
-
1
)
=
=
=
'
b
'
?
function
(
str
start
len
)
{
return
str
.
substr
(
start
len
)
}
:
function
(
str
start
len
)
{
if
(
start
<
0
)
start
=
str
.
length
+
start
;
return
str
.
substr
(
start
len
)
;
}
;
}
.
call
(
exports
__webpack_require__
(
35
)
)
)
}
)
432
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
(
function
(
)
{
var
Query
defaultPathSeparator
filter
matcher
parseOptions
pathScorer
preparedQueryCache
scorer
;
filter
=
__webpack_require__
(
433
)
;
matcher
=
__webpack_require__
(
434
)
;
scorer
=
__webpack_require__
(
66
)
;
pathScorer
=
__webpack_require__
(
111
)
;
Query
=
__webpack_require__
(
184
)
;
preparedQueryCache
=
null
;
defaultPathSeparator
=
(
typeof
process
!
=
=
"
undefined
"
&
&
process
!
=
=
null
?
process
.
platform
:
void
0
)
=
=
=
"
win32
"
?
'
\
\
'
:
'
/
'
;
module
.
exports
=
{
filter
:
function
(
candidates
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
(
(
query
!
=
null
?
query
.
length
:
void
0
)
&
&
(
candidates
!
=
null
?
candidates
.
length
:
void
0
)
)
)
{
return
[
]
;
}
options
=
parseOptions
(
options
query
)
;
return
filter
(
candidates
query
options
)
;
}
score
:
function
(
string
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
(
(
string
!
=
null
?
string
.
length
:
void
0
)
&
&
(
query
!
=
null
?
query
.
length
:
void
0
)
)
)
{
return
0
;
}
options
=
parseOptions
(
options
query
)
;
if
(
options
.
usePathScoring
)
{
return
pathScorer
.
score
(
string
query
options
)
;
}
else
{
return
scorer
.
score
(
string
query
options
)
;
}
}
match
:
function
(
string
query
options
)
{
var
_i
_ref
_results
;
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
string
)
{
return
[
]
;
}
if
(
!
query
)
{
return
[
]
;
}
if
(
string
=
=
=
query
)
{
return
(
function
(
)
{
_results
=
[
]
;
for
(
var
_i
=
0
_ref
=
string
.
length
;
0
<
=
_ref
?
_i
<
_ref
:
_i
>
_ref
;
0
<
=
_ref
?
_i
+
+
:
_i
-
-
)
{
_results
.
push
(
_i
)
;
}
return
_results
;
}
)
.
apply
(
this
)
;
}
options
=
parseOptions
(
options
query
)
;
return
matcher
.
match
(
string
query
options
)
;
}
wrap
:
function
(
string
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
if
(
!
string
)
{
return
[
]
;
}
if
(
!
query
)
{
return
[
]
;
}
options
=
parseOptions
(
options
query
)
;
return
matcher
.
wrap
(
string
query
options
)
;
}
prepareQuery
:
function
(
query
options
)
{
if
(
options
=
=
null
)
{
options
=
{
}
;
}
options
=
parseOptions
(
options
query
)
;
return
options
.
preparedQuery
;
}
}
;
parseOptions
=
function
(
options
query
)
{
if
(
options
.
allowErrors
=
=
null
)
{
options
.
allowErrors
=
false
;
}
if
(
options
.
usePathScoring
=
=
null
)
{
options
.
usePathScoring
=
true
;
}
if
(
options
.
useExtensionBonus
=
=
null
)
{
options
.
useExtensionBonus
=
false
;
}
if
(
options
.
pathSeparator
=
=
null
)
{
options
.
pathSeparator
=
defaultPathSeparator
;
}
if
(
options
.
optCharRegEx
=
=
null
)
{
options
.
optCharRegEx
=
null
;
}
if
(
options
.
wrap
=
=
null
)
{
options
.
wrap
=
null
;
}
if
(
options
.
preparedQuery
=
=
null
)
{
options
.
preparedQuery
=
preparedQueryCache
&
&
preparedQueryCache
.
query
=
=
=
query
?
preparedQueryCache
:
(
preparedQueryCache
=
new
Query
(
query
options
)
)
;
}
return
options
;
}
;
}
)
.
call
(
this
)
;
}
.
call
(
exports
__webpack_require__
(
35
)
)
)
}
)
433
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
Query
pathScorer
pluckCandidates
scorer
sortCandidates
;
scorer
=
__webpack_require__
(
66
)
;
pathScorer
=
__webpack_require__
(
111
)
;
Query
=
__webpack_require__
(
184
)
;
pluckCandidates
=
function
(
a
)
{
return
a
.
candidate
;
}
;
sortCandidates
=
function
(
a
b
)
{
return
b
.
score
-
a
.
score
;
}
;
module
.
exports
=
function
(
candidates
query
options
)
{
var
bKey
candidate
key
maxInners
maxResults
score
scoreProvider
scoredCandidates
spotLeft
string
usePathScoring
_i
_len
;
scoredCandidates
=
[
]
;
key
=
options
.
key
maxResults
=
options
.
maxResults
maxInners
=
options
.
maxInners
usePathScoring
=
options
.
usePathScoring
;
spotLeft
=
(
maxInners
!
=
null
)
&
&
maxInners
>
0
?
maxInners
:
candidates
.
length
+
1
;
bKey
=
key
!
=
null
;
scoreProvider
=
usePathScoring
?
pathScorer
:
scorer
;
for
(
_i
=
0
_len
=
candidates
.
length
;
_i
<
_len
;
_i
+
+
)
{
candidate
=
candidates
[
_i
]
;
string
=
bKey
?
candidate
[
key
]
:
candidate
;
if
(
!
string
)
{
continue
;
}
score
=
scoreProvider
.
score
(
string
query
options
)
;
if
(
score
>
0
)
{
scoredCandidates
.
push
(
{
candidate
:
candidate
score
:
score
}
)
;
if
(
!
-
-
spotLeft
)
{
break
;
}
}
}
scoredCandidates
.
sort
(
sortCandidates
)
;
candidates
=
scoredCandidates
.
map
(
pluckCandidates
)
;
if
(
maxResults
!
=
null
)
{
candidates
=
candidates
.
slice
(
0
maxResults
)
;
}
return
candidates
;
}
;
}
)
.
call
(
this
)
;
}
)
434
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
)
{
var
basenameMatch
computeMatch
isMatch
isWordStart
match
mergeMatches
scoreAcronyms
scoreCharacter
scoreConsecutives
_ref
;
_ref
=
__webpack_require__
(
66
)
isMatch
=
_ref
.
isMatch
isWordStart
=
_ref
.
isWordStart
scoreConsecutives
=
_ref
.
scoreConsecutives
scoreCharacter
=
_ref
.
scoreCharacter
scoreAcronyms
=
_ref
.
scoreAcronyms
;
exports
.
match
=
match
=
function
(
string
query
options
)
{
var
allowErrors
baseMatches
matches
pathSeparator
preparedQuery
string_lw
;
allowErrors
=
options
.
allowErrors
preparedQuery
=
options
.
preparedQuery
pathSeparator
=
options
.
pathSeparator
;
if
(
!
(
allowErrors
|
|
isMatch
(
string
preparedQuery
.
core_lw
preparedQuery
.
core_up
)
)
)
{
return
[
]
;
}
string_lw
=
string
.
toLowerCase
(
)
;
matches
=
computeMatch
(
string
string_lw
preparedQuery
)
;
if
(
matches
.
length
=
=
=
0
)
{
return
matches
;
}
if
(
string
.
indexOf
(
pathSeparator
)
>
-
1
)
{
baseMatches
=
basenameMatch
(
string
string_lw
preparedQuery
pathSeparator
)
;
matches
=
mergeMatches
(
matches
baseMatches
)
;
}
return
matches
;
}
;
exports
.
wrap
=
function
(
string
query
options
)
{
var
matchIndex
matchPos
matchPositions
output
strPos
tagClass
tagClose
tagOpen
_ref1
;
if
(
(
options
.
wrap
!
=
null
)
)
{
_ref1
=
options
.
wrap
tagClass
=
_ref1
.
tagClass
tagOpen
=
_ref1
.
tagOpen
tagClose
=
_ref1
.
tagClose
;
}
if
(
tagClass
=
=
null
)
{
tagClass
=
'
highlight
'
;
}
if
(
tagOpen
=
=
null
)
{
tagOpen
=
'
<
strong
class
=
"
'
+
tagClass
+
'
"
>
'
;
}
if
(
tagClose
=
=
null
)
{
tagClose
=
'
<
/
strong
>
'
;
}
if
(
string
=
=
=
query
)
{
return
tagOpen
+
string
+
tagClose
;
}
matchPositions
=
match
(
string
query
options
)
;
if
(
matchPositions
.
length
=
=
=
0
)
{
return
string
;
}
output
=
'
'
;
matchIndex
=
-
1
;
strPos
=
0
;
while
(
+
+
matchIndex
<
matchPositions
.
length
)
{
matchPos
=
matchPositions
[
matchIndex
]
;
if
(
matchPos
>
strPos
)
{
output
+
=
string
.
substring
(
strPos
matchPos
)
;
strPos
=
matchPos
;
}
while
(
+
+
matchIndex
<
matchPositions
.
length
)
{
if
(
matchPositions
[
matchIndex
]
=
=
=
matchPos
+
1
)
{
matchPos
+
+
;
}
else
{
matchIndex
-
-
;
break
;
}
}
matchPos
+
+
;
if
(
matchPos
>
strPos
)
{
output
+
=
tagOpen
;
output
+
=
string
.
substring
(
strPos
matchPos
)
;
output
+
=
tagClose
;
strPos
=
matchPos
;
}
}
if
(
strPos
<
=
string
.
length
-
1
)
{
output
+
=
string
.
substring
(
strPos
)
;
}
return
output
;
}
;
basenameMatch
=
function
(
subject
subject_lw
preparedQuery
pathSeparator
)
{
var
basePos
depth
end
;
end
=
subject
.
length
-
1
;
while
(
subject
[
end
]
=
=
=
pathSeparator
)
{
end
-
-
;
}
basePos
=
subject
.
lastIndexOf
(
pathSeparator
end
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
depth
=
preparedQuery
.
depth
;
while
(
depth
-
-
>
0
)
{
basePos
=
subject
.
lastIndexOf
(
pathSeparator
basePos
-
1
)
;
if
(
basePos
=
=
=
-
1
)
{
return
[
]
;
}
}
basePos
+
+
;
end
+
+
;
return
computeMatch
(
subject
.
slice
(
basePos
end
)
subject_lw
.
slice
(
basePos
end
)
preparedQuery
basePos
)
;
}
;
mergeMatches
=
function
(
a
b
)
{
var
ai
bj
i
j
m
n
out
;
m
=
a
.
length
;
n
=
b
.
length
;
if
(
n
=
=
=
0
)
{
return
a
.
slice
(
)
;
}
if
(
m
=
=
=
0
)
{
return
b
.
slice
(
)
;
}
i
=
-
1
;
j
=
0
;
bj
=
b
[
j
]
;
out
=
[
]
;
while
(
+
+
i
<
m
)
{
ai
=
a
[
i
]
;
while
(
bj
<
=
ai
&
&
+
+
j
<
n
)
{
if
(
bj
<
ai
)
{
out
.
push
(
bj
)
;
}
bj
=
b
[
j
]
;
}
out
.
push
(
ai
)
;
}
while
(
j
<
n
)
{
out
.
push
(
b
[
j
+
+
]
)
;
}
return
out
;
}
;
computeMatch
=
function
(
subject
subject_lw
preparedQuery
offset
)
{
var
DIAGONAL
LEFT
STOP
UP
acro_score
align
backtrack
csc_diag
csc_row
csc_score
i
j
m
matches
move
n
pos
query
query_lw
score
score_diag
score_row
score_up
si_lw
start
trace
;
if
(
offset
=
=
null
)
{
offset
=
0
;
}
query
=
preparedQuery
.
query
;
query_lw
=
preparedQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro_score
=
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
.
score
;
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
STOP
=
0
;
UP
=
1
;
LEFT
=
2
;
DIAGONAL
=
3
;
trace
=
new
Array
(
m
*
n
)
;
pos
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
score
=
0
;
score_up
=
0
;
csc_diag
=
0
;
si_lw
=
subject_lw
[
i
]
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
csc_score
=
0
;
align
=
0
;
score_diag
=
score_up
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
}
score_up
=
score_row
[
j
]
;
csc_diag
=
csc_row
[
j
]
;
if
(
score
>
score_up
)
{
move
=
LEFT
;
}
else
{
score
=
score_up
;
move
=
UP
;
}
if
(
align
>
score
)
{
score
=
align
;
move
=
DIAGONAL
;
}
else
{
csc_score
=
0
;
}
score_row
[
j
]
=
score
;
csc_row
[
j
]
=
csc_score
;
trace
[
+
+
pos
]
=
score
>
0
?
move
:
STOP
;
}
}
i
=
m
-
1
;
j
=
n
-
1
;
pos
=
i
*
n
+
j
;
backtrack
=
true
;
matches
=
[
]
;
while
(
backtrack
&
&
i
>
=
0
&
&
j
>
=
0
)
{
switch
(
trace
[
pos
]
)
{
case
UP
:
i
-
-
;
pos
-
=
n
;
break
;
case
LEFT
:
j
-
-
;
pos
-
-
;
break
;
case
DIAGONAL
:
matches
.
push
(
i
+
offset
)
;
j
-
-
;
i
-
-
;
pos
-
=
n
+
1
;
break
;
default
:
backtrack
=
false
;
}
}
matches
.
reverse
(
)
;
return
matches
;
}
;
}
)
.
call
(
this
)
;
}
)
435
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
default
=
exports
.
EXITING
=
exports
.
ENTERED
=
exports
.
ENTERING
=
exports
.
EXITED
=
exports
.
UNMOUNTED
=
void
0
;
var
PropTypes
=
_interopRequireWildcard
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_reactDom
=
_interopRequireDefault
(
__webpack_require__
(
112
)
)
;
var
_reactLifecyclesCompat
=
__webpack_require__
(
436
)
;
var
_PropTypes
=
__webpack_require__
(
437
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
function
_interopRequireWildcard
(
obj
)
{
if
(
obj
&
&
obj
.
__esModule
)
{
return
obj
;
}
else
{
var
newObj
=
{
}
;
if
(
obj
!
=
null
)
{
for
(
var
key
in
obj
)
{
if
(
Object
.
prototype
.
hasOwnProperty
.
call
(
obj
key
)
)
{
var
desc
=
Object
.
defineProperty
&
&
Object
.
getOwnPropertyDescriptor
?
Object
.
getOwnPropertyDescriptor
(
obj
key
)
:
{
}
;
if
(
desc
.
get
|
|
desc
.
set
)
{
Object
.
defineProperty
(
newObj
key
desc
)
;
}
else
{
newObj
[
key
]
=
obj
[
key
]
;
}
}
}
}
newObj
.
default
=
obj
;
return
newObj
;
}
}
function
_objectWithoutPropertiesLoose
(
source
excluded
)
{
if
(
source
=
=
null
)
return
{
}
;
var
target
=
{
}
;
var
sourceKeys
=
Object
.
keys
(
source
)
;
var
key
i
;
for
(
i
=
0
;
i
<
sourceKeys
.
length
;
i
+
+
)
{
key
=
sourceKeys
[
i
]
;
if
(
excluded
.
indexOf
(
key
)
>
=
0
)
continue
;
target
[
key
]
=
source
[
key
]
;
}
return
target
;
}
function
_inheritsLoose
(
subClass
superClass
)
{
subClass
.
prototype
=
Object
.
create
(
superClass
.
prototype
)
;
subClass
.
prototype
.
constructor
=
subClass
;
subClass
.
__proto__
=
superClass
;
}
var
UNMOUNTED
=
'
unmounted
'
;
exports
.
UNMOUNTED
=
UNMOUNTED
;
var
EXITED
=
'
exited
'
;
exports
.
EXITED
=
EXITED
;
var
ENTERING
=
'
entering
'
;
exports
.
ENTERING
=
ENTERING
;
var
ENTERED
=
'
entered
'
;
exports
.
ENTERED
=
ENTERED
;
var
EXITING
=
'
exiting
'
;
exports
.
EXITING
=
EXITING
;
var
Transition
=
function
(
_React
Component
)
{
_inheritsLoose
(
Transition
_React
Component
)
;
function
Transition
(
props
context
)
{
var
_this
;
_this
=
_React
Component
.
call
(
this
props
context
)
|
|
this
;
var
parentGroup
=
context
.
transitionGroup
;
var
appear
=
parentGroup
&
&
!
parentGroup
.
isMounting
?
props
.
enter
:
props
.
appear
;
var
initialStatus
;
_this
.
appearStatus
=
null
;
if
(
props
.
in
)
{
if
(
appear
)
{
initialStatus
=
EXITED
;
_this
.
appearStatus
=
ENTERING
;
}
else
{
initialStatus
=
ENTERED
;
}
}
else
{
if
(
props
.
unmountOnExit
|
|
props
.
mountOnEnter
)
{
initialStatus
=
UNMOUNTED
;
}
else
{
initialStatus
=
EXITED
;
}
}
_this
.
state
=
{
status
:
initialStatus
}
;
_this
.
nextCallback
=
null
;
return
_this
;
}
var
_proto
=
Transition
.
prototype
;
_proto
.
getChildContext
=
function
getChildContext
(
)
{
return
{
transitionGroup
:
null
}
;
}
;
Transition
.
getDerivedStateFromProps
=
function
getDerivedStateFromProps
(
_ref
prevState
)
{
var
nextIn
=
_ref
.
in
;
if
(
nextIn
&
&
prevState
.
status
=
=
=
UNMOUNTED
)
{
return
{
status
:
EXITED
}
;
}
return
null
;
}
;
_proto
.
componentDidMount
=
function
componentDidMount
(
)
{
this
.
updateStatus
(
true
this
.
appearStatus
)
;
}
;
_proto
.
componentDidUpdate
=
function
componentDidUpdate
(
prevProps
)
{
var
nextStatus
=
null
;
if
(
prevProps
!
=
=
this
.
props
)
{
var
status
=
this
.
state
.
status
;
if
(
this
.
props
.
in
)
{
if
(
status
!
=
=
ENTERING
&
&
status
!
=
=
ENTERED
)
{
nextStatus
=
ENTERING
;
}
}
else
{
if
(
status
=
=
=
ENTERING
|
|
status
=
=
=
ENTERED
)
{
nextStatus
=
EXITING
;
}
}
}
this
.
updateStatus
(
false
nextStatus
)
;
}
;
_proto
.
componentWillUnmount
=
function
componentWillUnmount
(
)
{
this
.
cancelNextCallback
(
)
;
}
;
_proto
.
getTimeouts
=
function
getTimeouts
(
)
{
var
timeout
=
this
.
props
.
timeout
;
var
exit
enter
appear
;
exit
=
enter
=
appear
=
timeout
;
if
(
timeout
!
=
null
&
&
typeof
timeout
!
=
=
'
number
'
)
{
exit
=
timeout
.
exit
;
enter
=
timeout
.
enter
;
appear
=
timeout
.
appear
!
=
=
undefined
?
timeout
.
appear
:
enter
;
}
return
{
exit
:
exit
enter
:
enter
appear
:
appear
}
;
}
;
_proto
.
updateStatus
=
function
updateStatus
(
mounting
nextStatus
)
{
if
(
mounting
=
=
=
void
0
)
{
mounting
=
false
;
}
if
(
nextStatus
!
=
=
null
)
{
this
.
cancelNextCallback
(
)
;
var
node
=
_reactDom
.
default
.
findDOMNode
(
this
)
;
if
(
nextStatus
=
=
=
ENTERING
)
{
this
.
performEnter
(
node
mounting
)
;
}
else
{
this
.
performExit
(
node
)
;
}
}
else
if
(
this
.
props
.
unmountOnExit
&
&
this
.
state
.
status
=
=
=
EXITED
)
{
this
.
setState
(
{
status
:
UNMOUNTED
}
)
;
}
}
;
_proto
.
performEnter
=
function
performEnter
(
node
mounting
)
{
var
_this2
=
this
;
var
enter
=
this
.
props
.
enter
;
var
appearing
=
this
.
context
.
transitionGroup
?
this
.
context
.
transitionGroup
.
isMounting
:
mounting
;
var
timeouts
=
this
.
getTimeouts
(
)
;
var
enterTimeout
=
appearing
?
timeouts
.
appear
:
timeouts
.
enter
;
if
(
!
mounting
&
&
!
enter
)
{
this
.
safeSetState
(
{
status
:
ENTERED
}
function
(
)
{
_this2
.
props
.
onEntered
(
node
)
;
}
)
;
return
;
}
this
.
props
.
onEnter
(
node
appearing
)
;
this
.
safeSetState
(
{
status
:
ENTERING
}
function
(
)
{
_this2
.
props
.
onEntering
(
node
appearing
)
;
_this2
.
onTransitionEnd
(
node
enterTimeout
function
(
)
{
_this2
.
safeSetState
(
{
status
:
ENTERED
}
function
(
)
{
_this2
.
props
.
onEntered
(
node
appearing
)
;
}
)
;
}
)
;
}
)
;
}
;
_proto
.
performExit
=
function
performExit
(
node
)
{
var
_this3
=
this
;
var
exit
=
this
.
props
.
exit
;
var
timeouts
=
this
.
getTimeouts
(
)
;
if
(
!
exit
)
{
this
.
safeSetState
(
{
status
:
EXITED
}
function
(
)
{
_this3
.
props
.
onExited
(
node
)
;
}
)
;
return
;
}
this
.
props
.
onExit
(
node
)
;
this
.
safeSetState
(
{
status
:
EXITING
}
function
(
)
{
_this3
.
props
.
onExiting
(
node
)
;
_this3
.
onTransitionEnd
(
node
timeouts
.
exit
function
(
)
{
_this3
.
safeSetState
(
{
status
:
EXITED
}
function
(
)
{
_this3
.
props
.
onExited
(
node
)
;
}
)
;
}
)
;
}
)
;
}
;
_proto
.
cancelNextCallback
=
function
cancelNextCallback
(
)
{
if
(
this
.
nextCallback
!
=
=
null
)
{
this
.
nextCallback
.
cancel
(
)
;
this
.
nextCallback
=
null
;
}
}
;
_proto
.
safeSetState
=
function
safeSetState
(
nextState
callback
)
{
callback
=
this
.
setNextCallback
(
callback
)
;
this
.
setState
(
nextState
callback
)
;
}
;
_proto
.
setNextCallback
=
function
setNextCallback
(
callback
)
{
var
_this4
=
this
;
var
active
=
true
;
this
.
nextCallback
=
function
(
event
)
{
if
(
active
)
{
active
=
false
;
_this4
.
nextCallback
=
null
;
callback
(
event
)
;
}
}
;
this
.
nextCallback
.
cancel
=
function
(
)
{
active
=
false
;
}
;
return
this
.
nextCallback
;
}
;
_proto
.
onTransitionEnd
=
function
onTransitionEnd
(
node
timeout
handler
)
{
this
.
setNextCallback
(
handler
)
;
var
doesNotHaveTimeoutOrListener
=
timeout
=
=
null
&
&
!
this
.
props
.
addEndListener
;
if
(
!
node
|
|
doesNotHaveTimeoutOrListener
)
{
setTimeout
(
this
.
nextCallback
0
)
;
return
;
}
if
(
this
.
props
.
addEndListener
)
{
this
.
props
.
addEndListener
(
node
this
.
nextCallback
)
;
}
if
(
timeout
!
=
null
)
{
setTimeout
(
this
.
nextCallback
timeout
)
;
}
}
;
_proto
.
render
=
function
render
(
)
{
var
status
=
this
.
state
.
status
;
if
(
status
=
=
=
UNMOUNTED
)
{
return
null
;
}
var
_this
props
=
this
.
props
children
=
_this
props
.
children
childProps
=
_objectWithoutPropertiesLoose
(
_this
props
[
"
children
"
]
)
;
delete
childProps
.
in
;
delete
childProps
.
mountOnEnter
;
delete
childProps
.
unmountOnExit
;
delete
childProps
.
appear
;
delete
childProps
.
enter
;
delete
childProps
.
exit
;
delete
childProps
.
timeout
;
delete
childProps
.
addEndListener
;
delete
childProps
.
onEnter
;
delete
childProps
.
onEntering
;
delete
childProps
.
onEntered
;
delete
childProps
.
onExit
;
delete
childProps
.
onExiting
;
delete
childProps
.
onExited
;
if
(
typeof
children
=
=
=
'
function
'
)
{
return
children
(
status
childProps
)
;
}
var
child
=
_react
.
default
.
Children
.
only
(
children
)
;
return
_react
.
default
.
cloneElement
(
child
childProps
)
;
}
;
return
Transition
;
}
(
_react
.
default
.
Component
)
;
Transition
.
contextTypes
=
{
transitionGroup
:
PropTypes
.
object
}
;
Transition
.
childContextTypes
=
{
transitionGroup
:
function
transitionGroup
(
)
{
}
}
;
Transition
.
propTypes
=
false
?
{
children
:
PropTypes
.
oneOfType
(
[
PropTypes
.
func
.
isRequired
PropTypes
.
element
.
isRequired
]
)
.
isRequired
in
:
PropTypes
.
bool
mountOnEnter
:
PropTypes
.
bool
unmountOnExit
:
PropTypes
.
bool
appear
:
PropTypes
.
bool
enter
:
PropTypes
.
bool
exit
:
PropTypes
.
bool
timeout
:
function
timeout
(
props
)
{
var
pt
=
_PropTypes
.
timeoutsShape
;
if
(
!
props
.
addEndListener
)
pt
=
pt
.
isRequired
;
for
(
var
_len
=
arguments
.
length
args
=
new
Array
(
_len
>
1
?
_len
-
1
:
0
)
_key
=
1
;
_key
<
_len
;
_key
+
+
)
{
args
[
_key
-
1
]
=
arguments
[
_key
]
;
}
return
pt
.
apply
(
void
0
[
props
]
.
concat
(
args
)
)
;
}
addEndListener
:
PropTypes
.
func
onEnter
:
PropTypes
.
func
onEntering
:
PropTypes
.
func
onEntered
:
PropTypes
.
func
onExit
:
PropTypes
.
func
onExiting
:
PropTypes
.
func
onExited
:
PropTypes
.
func
}
:
{
}
;
function
noop
(
)
{
}
Transition
.
defaultProps
=
{
in
:
false
mountOnEnter
:
false
unmountOnExit
:
false
appear
:
false
enter
:
true
exit
:
true
onEnter
:
noop
onEntering
:
noop
onEntered
:
noop
onExit
:
noop
onExiting
:
noop
onExited
:
noop
}
;
Transition
.
UNMOUNTED
=
0
;
Transition
.
EXITED
=
1
;
Transition
.
ENTERING
=
2
;
Transition
.
ENTERED
=
3
;
Transition
.
EXITING
=
4
;
var
_default
=
(
0
_reactLifecyclesCompat
.
polyfill
)
(
Transition
)
;
exports
.
default
=
_default
;
}
)
436
:
(
function
(
module
__webpack_exports__
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
__webpack_exports__
"
__esModule
"
{
value
:
true
}
)
;
__webpack_require__
.
d
(
__webpack_exports__
"
polyfill
"
function
(
)
{
return
polyfill
;
}
)
;
function
componentWillMount
(
)
{
var
state
=
this
.
constructor
.
getDerivedStateFromProps
(
this
.
props
this
.
state
)
;
if
(
state
!
=
=
null
&
&
state
!
=
=
undefined
)
{
this
.
setState
(
state
)
;
}
}
function
componentWillReceiveProps
(
nextProps
)
{
function
updater
(
prevState
)
{
var
state
=
this
.
constructor
.
getDerivedStateFromProps
(
nextProps
prevState
)
;
return
state
!
=
=
null
&
&
state
!
=
=
undefined
?
state
:
null
;
}
this
.
setState
(
updater
.
bind
(
this
)
)
;
}
function
componentWillUpdate
(
nextProps
nextState
)
{
try
{
var
prevProps
=
this
.
props
;
var
prevState
=
this
.
state
;
this
.
props
=
nextProps
;
this
.
state
=
nextState
;
this
.
__reactInternalSnapshotFlag
=
true
;
this
.
__reactInternalSnapshot
=
this
.
getSnapshotBeforeUpdate
(
prevProps
prevState
)
;
}
finally
{
this
.
props
=
prevProps
;
this
.
state
=
prevState
;
}
}
componentWillMount
.
__suppressDeprecationWarning
=
true
;
componentWillReceiveProps
.
__suppressDeprecationWarning
=
true
;
componentWillUpdate
.
__suppressDeprecationWarning
=
true
;
function
polyfill
(
Component
)
{
var
prototype
=
Component
.
prototype
;
if
(
!
prototype
|
|
!
prototype
.
isReactComponent
)
{
throw
new
Error
(
'
Can
only
polyfill
class
components
'
)
;
}
if
(
typeof
Component
.
getDerivedStateFromProps
!
=
=
'
function
'
&
&
typeof
prototype
.
getSnapshotBeforeUpdate
!
=
=
'
function
'
)
{
return
Component
;
}
var
foundWillMountName
=
null
;
var
foundWillReceivePropsName
=
null
;
var
foundWillUpdateName
=
null
;
if
(
typeof
prototype
.
componentWillMount
=
=
=
'
function
'
)
{
foundWillMountName
=
'
componentWillMount
'
;
}
else
if
(
typeof
prototype
.
UNSAFE_componentWillMount
=
=
=
'
function
'
)
{
foundWillMountName
=
'
UNSAFE_componentWillMount
'
;
}
if
(
typeof
prototype
.
componentWillReceiveProps
=
=
=
'
function
'
)
{
foundWillReceivePropsName
=
'
componentWillReceiveProps
'
;
}
else
if
(
typeof
prototype
.
UNSAFE_componentWillReceiveProps
=
=
=
'
function
'
)
{
foundWillReceivePropsName
=
'
UNSAFE_componentWillReceiveProps
'
;
}
if
(
typeof
prototype
.
componentWillUpdate
=
=
=
'
function
'
)
{
foundWillUpdateName
=
'
componentWillUpdate
'
;
}
else
if
(
typeof
prototype
.
UNSAFE_componentWillUpdate
=
=
=
'
function
'
)
{
foundWillUpdateName
=
'
UNSAFE_componentWillUpdate
'
;
}
if
(
foundWillMountName
!
=
=
null
|
|
foundWillReceivePropsName
!
=
=
null
|
|
foundWillUpdateName
!
=
=
null
)
{
var
componentName
=
Component
.
displayName
|
|
Component
.
name
;
var
newApiName
=
typeof
Component
.
getDerivedStateFromProps
=
=
=
'
function
'
?
'
getDerivedStateFromProps
(
)
'
:
'
getSnapshotBeforeUpdate
(
)
'
;
throw
Error
(
'
Unsafe
legacy
lifecycles
will
not
be
called
for
components
using
new
component
APIs
.
\
n
\
n
'
+
componentName
+
'
uses
'
+
newApiName
+
'
but
also
contains
the
following
legacy
lifecycles
:
'
+
(
foundWillMountName
!
=
=
null
?
'
\
n
'
+
foundWillMountName
:
'
'
)
+
(
foundWillReceivePropsName
!
=
=
null
?
'
\
n
'
+
foundWillReceivePropsName
:
'
'
)
+
(
foundWillUpdateName
!
=
=
null
?
'
\
n
'
+
foundWillUpdateName
:
'
'
)
+
'
\
n
\
nThe
above
lifecycles
should
be
removed
.
Learn
more
about
this
warning
here
:
\
n
'
+
'
https
:
/
/
fb
.
me
/
react
-
async
-
component
-
lifecycle
-
hooks
'
)
;
}
if
(
typeof
Component
.
getDerivedStateFromProps
=
=
=
'
function
'
)
{
prototype
.
componentWillMount
=
componentWillMount
;
prototype
.
componentWillReceiveProps
=
componentWillReceiveProps
;
}
if
(
typeof
prototype
.
getSnapshotBeforeUpdate
=
=
=
'
function
'
)
{
if
(
typeof
prototype
.
componentDidUpdate
!
=
=
'
function
'
)
{
throw
new
Error
(
'
Cannot
polyfill
getSnapshotBeforeUpdate
(
)
for
components
that
do
not
define
componentDidUpdate
(
)
on
the
prototype
'
)
;
}
prototype
.
componentWillUpdate
=
componentWillUpdate
;
var
componentDidUpdate
=
prototype
.
componentDidUpdate
;
prototype
.
componentDidUpdate
=
function
componentDidUpdatePolyfill
(
prevProps
prevState
maybeSnapshot
)
{
var
snapshot
=
this
.
__reactInternalSnapshotFlag
?
this
.
__reactInternalSnapshot
:
maybeSnapshot
;
componentDidUpdate
.
call
(
this
prevProps
prevState
snapshot
)
;
}
;
}
return
Component
;
}
}
)
437
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
exports
.
__esModule
=
true
;
exports
.
classNamesShape
=
exports
.
timeoutsShape
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
var
timeoutsShape
=
false
?
_propTypes
.
default
.
oneOfType
(
[
_propTypes
.
default
.
number
_propTypes
.
default
.
shape
(
{
enter
:
_propTypes
.
default
.
number
exit
:
_propTypes
.
default
.
number
appear
:
_propTypes
.
default
.
number
}
)
.
isRequired
]
)
:
null
;
exports
.
timeoutsShape
=
timeoutsShape
;
var
classNamesShape
=
false
?
_propTypes
.
default
.
oneOfType
(
[
_propTypes
.
default
.
string
_propTypes
.
default
.
shape
(
{
enter
:
_propTypes
.
default
.
string
exit
:
_propTypes
.
default
.
string
active
:
_propTypes
.
default
.
string
}
)
_propTypes
.
default
.
shape
(
{
enter
:
_propTypes
.
default
.
string
enterDone
:
_propTypes
.
default
.
string
enterActive
:
_propTypes
.
default
.
string
exit
:
_propTypes
.
default
.
string
exitDone
:
_propTypes
.
default
.
string
exitActive
:
_propTypes
.
default
.
string
}
)
]
)
:
null
;
exports
.
classNamesShape
=
classNamesShape
;
}
)
438
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
Object
.
defineProperty
(
exports
"
TabList
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tabList
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
"
TabPanels
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tabPanels
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
"
Tab
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tab
.
default
;
}
}
)
;
Object
.
defineProperty
(
exports
"
Tabs
"
{
enumerable
:
true
get
:
function
(
)
{
return
_tabs
.
default
;
}
}
)
;
var
_tabList
=
_interopRequireDefault
(
__webpack_require__
(
185
)
)
;
var
_tabPanels
=
_interopRequireDefault
(
__webpack_require__
(
187
)
)
;
var
_tab
=
_interopRequireDefault
(
__webpack_require__
(
186
)
)
;
var
_tabs
=
_interopRequireDefault
(
__webpack_require__
(
442
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
}
)
439
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
var
_default
=
_propTypes
.
default
.
object
;
exports
.
default
=
_default
;
}
)
440
:
(
function
(
module
exports
)
{
}
)
441
:
(
function
(
module
exports
)
{
}
)
442
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
void
0
;
var
_propTypes
=
_interopRequireDefault
(
__webpack_require__
(
0
)
)
;
var
_react
=
_interopRequireDefault
(
__webpack_require__
(
6
)
)
;
var
_uniqueId
=
_interopRequireDefault
(
__webpack_require__
(
443
)
)
;
var
_tabList
=
_interopRequireDefault
(
__webpack_require__
(
185
)
)
;
var
_tabPanels
=
_interopRequireDefault
(
__webpack_require__
(
187
)
)
;
function
_interopRequireDefault
(
obj
)
{
return
obj
&
&
obj
.
__esModule
?
obj
:
{
default
:
obj
}
;
}
class
Tabs
extends
_react
.
default
.
Component
{
constructor
(
)
{
super
(
)
;
this
.
accessibleId
=
(
0
_uniqueId
.
default
)
(
)
;
}
render
(
)
{
const
{
activeIndex
children
className
onActivateTab
}
=
this
.
props
;
const
accessibleId
=
this
.
accessibleId
;
return
_react
.
default
.
createElement
(
"
div
"
{
className
:
className
}
_react
.
default
.
Children
.
map
(
children
child
=
>
{
if
(
!
child
)
{
return
child
;
}
switch
(
child
.
type
)
{
case
_tabList
.
default
:
return
_react
.
default
.
cloneElement
(
child
{
accessibleId
activeIndex
onActivateTab
}
)
;
case
_tabPanels
.
default
:
return
_react
.
default
.
cloneElement
(
child
{
accessibleId
activeIndex
}
)
;
default
:
return
child
;
}
}
)
)
;
}
}
exports
.
default
=
Tabs
;
Tabs
.
propTypes
=
{
activeIndex
:
_propTypes
.
default
.
number
.
isRequired
children
:
_propTypes
.
default
.
node
className
:
_propTypes
.
default
.
string
onActivateTab
:
_propTypes
.
default
.
func
}
;
Tabs
.
defaultProps
=
{
children
:
null
className
:
undefined
onActivateTab
:
(
)
=
>
{
}
}
;
}
)
443
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
uniqueId
;
let
counter
=
0
;
function
uniqueId
(
)
{
counter
+
=
1
;
return
rac
{
counter
}
;
}
}
)
445
:
(
function
(
module
exports
__webpack_require__
)
{
const
SplitBox
=
__webpack_require__
(
446
)
;
module
.
exports
=
SplitBox
;
}
)
446
:
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
6
)
;
const
ReactDOM
=
__webpack_require__
(
112
)
;
const
Draggable
=
React
.
createFactory
(
__webpack_require__
(
447
)
)
;
const
{
Component
}
=
React
;
const
PropTypes
=
__webpack_require__
(
0
)
;
const
dom
=
__webpack_require__
(
1
)
;
__webpack_require__
(
448
)
;
class
SplitBox
extends
Component
{
static
get
propTypes
(
)
{
return
{
className
:
PropTypes
.
string
initialSize
:
PropTypes
.
any
initialWidth
:
PropTypes
.
number
initialHeight
:
PropTypes
.
number
startPanel
:
PropTypes
.
any
startPanelCollapsed
:
PropTypes
.
bool
minSize
:
PropTypes
.
any
maxSize
:
PropTypes
.
any
endPanel
:
PropTypes
.
any
endPanelCollapsed
:
PropTypes
.
bool
endPanelControl
:
PropTypes
.
bool
splitterSize
:
PropTypes
.
number
vert
:
PropTypes
.
bool
style
:
PropTypes
.
object
onResizeEnd
:
PropTypes
.
func
}
;
}
static
get
defaultProps
(
)
{
return
{
splitterSize
:
5
vert
:
true
endPanelControl
:
false
endPanelCollapsed
:
false
startPanelCollapsed
:
false
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
state
=
{
vert
:
props
.
vert
width
:
parseInt
(
props
.
initialWidth
|
|
props
.
initialSize
10
)
height
:
parseInt
(
props
.
initialHeight
|
|
props
.
initialSize
10
)
}
;
this
.
onStartMove
=
this
.
onStartMove
.
bind
(
this
)
;
this
.
onStopMove
=
this
.
onStopMove
.
bind
(
this
)
;
this
.
onMove
=
this
.
onMove
.
bind
(
this
)
;
this
.
preparePanelStyles
=
this
.
preparePanelStyles
.
bind
(
this
)
;
}
componentWillReceiveProps
(
nextProps
)
{
if
(
this
.
props
.
vert
!
=
=
nextProps
.
vert
)
{
this
.
setState
(
{
vert
:
nextProps
.
vert
}
)
;
}
if
(
this
.
props
.
initialSize
!
=
=
nextProps
.
initialSize
|
|
this
.
props
.
initialWidth
!
=
=
nextProps
.
initialWidth
|
|
this
.
props
.
initialHeight
!
=
=
nextProps
.
initialHeight
)
{
this
.
setState
(
{
width
:
parseInt
(
nextProps
.
initialWidth
|
|
nextProps
.
initialSize
10
)
height
:
parseInt
(
nextProps
.
initialHeight
|
|
nextProps
.
initialSize
10
)
}
)
;
}
}
onStartMove
(
)
{
const
splitBox
=
ReactDOM
.
findDOMNode
(
this
)
;
const
doc
=
splitBox
.
ownerDocument
;
const
defaultCursor
=
doc
.
documentElement
.
style
.
cursor
;
doc
.
documentElement
.
style
.
cursor
=
this
.
state
.
vert
?
"
ew
-
resize
"
:
"
ns
-
resize
"
;
splitBox
.
classList
.
add
(
"
dragging
"
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
drag
:
start
"
)
)
;
this
.
setState
(
{
defaultCursor
:
defaultCursor
}
)
;
}
onStopMove
(
)
{
const
splitBox
=
ReactDOM
.
findDOMNode
(
this
)
;
const
doc
=
splitBox
.
ownerDocument
;
doc
.
documentElement
.
style
.
cursor
=
this
.
state
.
defaultCursor
;
splitBox
.
classList
.
remove
(
"
dragging
"
)
;
document
.
dispatchEvent
(
new
CustomEvent
(
"
drag
:
end
"
)
)
;
if
(
this
.
props
.
onResizeEnd
)
{
this
.
props
.
onResizeEnd
(
this
.
state
.
vert
?
this
.
state
.
width
:
this
.
state
.
height
)
;
}
}
onMove
(
{
clientX
movementY
}
)
{
const
node
=
ReactDOM
.
findDOMNode
(
this
)
;
const
doc
=
node
.
ownerDocument
;
let
targetWidth
;
if
(
this
.
props
.
endPanelControl
)
{
targetWidth
=
node
.
clientWidth
-
clientX
;
movementY
=
-
movementY
;
}
else
{
targetWidth
=
this
.
calcStartPanelWidth
(
{
node
clientX
doc
}
)
;
}
if
(
this
.
state
.
vert
)
{
const
isRtl
=
doc
.
dir
=
=
=
"
rtl
"
;
if
(
isRtl
&
&
this
.
props
.
endPanelControl
)
{
const
fullWidth
=
node
.
clientWidth
+
node
.
offsetLeft
;
targetWidth
=
fullWidth
-
targetWidth
;
}
this
.
setState
(
(
state
props
)
=
>
(
{
width
:
targetWidth
}
)
)
;
}
else
{
this
.
setState
(
(
state
props
)
=
>
(
{
height
:
state
.
height
+
movementY
}
)
)
;
}
}
calcStartPanelWidth
(
options
)
{
const
{
node
clientX
doc
}
=
options
;
const
availableWidth
=
node
.
clientWidth
;
const
maxSize
=
parseInt
(
this
.
props
.
maxSize
10
)
/
100
;
const
maxPossibleWidth
=
Math
.
ceil
(
availableWidth
*
maxSize
)
;
if
(
doc
.
dir
=
=
=
"
rtl
"
)
{
const
fullWidth
=
node
.
clientWidth
+
node
.
offsetLeft
;
const
targetWidth
=
fullWidth
-
clientX
;
return
targetWidth
>
maxPossibleWidth
?
maxPossibleWidth
:
targetWidth
;
}
return
clientX
>
maxPossibleWidth
?
maxPossibleWidth
:
clientX
;
}
preparePanelStyles
(
)
{
const
vert
=
this
.
state
.
vert
;
const
{
minSize
maxSize
startPanelCollapsed
endPanelControl
endPanelCollapsed
}
=
this
.
props
;
let
leftPanelStyle
rightPanelStyle
;
if
(
vert
)
{
const
startWidth
=
endPanelControl
?
null
:
this
.
state
.
width
endWidth
=
endPanelControl
?
this
.
state
.
width
:
null
;
leftPanelStyle
=
{
maxWidth
:
endPanelControl
?
null
:
maxSize
minWidth
:
endPanelControl
?
null
:
minSize
width
:
startPanelCollapsed
?
0
:
startWidth
}
;
rightPanelStyle
=
{
maxWidth
:
endPanelControl
?
maxSize
:
null
minWidth
:
endPanelControl
?
minSize
:
null
width
:
endPanelCollapsed
?
0
:
endWidth
}
;
}
else
{
const
startHeight
=
endPanelControl
?
null
:
this
.
state
.
height
endHeight
=
endPanelControl
?
this
.
state
.
height
:
null
;
leftPanelStyle
=
{
maxHeight
:
endPanelControl
?
null
:
maxSize
minHeight
:
endPanelControl
?
null
:
minSize
height
:
endPanelCollapsed
?
maxSize
:
startHeight
}
;
rightPanelStyle
=
{
maxHeight
:
endPanelControl
?
maxSize
:
null
minHeight
:
endPanelControl
?
minSize
:
null
height
:
startPanelCollapsed
?
maxSize
:
endHeight
}
;
}
return
{
leftPanelStyle
rightPanelStyle
}
;
}
render
(
)
{
const
vert
=
this
.
state
.
vert
;
const
{
startPanelCollapsed
startPanel
endPanel
endPanelControl
splitterSize
endPanelCollapsed
}
=
this
.
props
;
const
style
=
Object
.
assign
(
{
}
this
.
props
.
style
)
;
let
classNames
=
[
"
split
-
box
"
]
;
classNames
.
push
(
vert
?
"
vert
"
:
"
horz
"
)
;
if
(
this
.
props
.
className
)
{
classNames
=
classNames
.
concat
(
this
.
props
.
className
.
split
(
"
"
)
)
;
}
const
{
leftPanelStyle
rightPanelStyle
}
=
this
.
preparePanelStyles
(
)
;
const
splitterStyle
=
{
flex
:
0
0
{
splitterSize
}
px
}
;
return
dom
.
div
(
{
className
:
classNames
.
join
(
"
"
)
style
:
style
}
!
startPanelCollapsed
?
dom
.
div
(
{
className
:
endPanelControl
?
"
uncontrolled
"
:
"
controlled
"
style
:
leftPanelStyle
}
startPanel
)
:
null
Draggable
(
{
className
:
"
splitter
"
style
:
splitterStyle
onStart
:
this
.
onStartMove
onStop
:
this
.
onStopMove
onMove
:
this
.
onMove
}
)
!
endPanelCollapsed
?
dom
.
div
(
{
className
:
endPanelControl
?
"
controlled
"
:
"
uncontrolled
"
style
:
rightPanelStyle
}
endPanel
)
:
null
)
;
}
}
module
.
exports
=
SplitBox
;
}
)
447
:
(
function
(
module
exports
__webpack_require__
)
{
const
React
=
__webpack_require__
(
6
)
;
const
ReactDOM
=
__webpack_require__
(
112
)
;
const
{
Component
}
=
React
;
const
PropTypes
=
__webpack_require__
(
0
)
;
const
dom
=
__webpack_require__
(
1
)
;
class
Draggable
extends
Component
{
static
get
propTypes
(
)
{
return
{
onMove
:
PropTypes
.
func
.
isRequired
onStart
:
PropTypes
.
func
onStop
:
PropTypes
.
func
style
:
PropTypes
.
object
className
:
PropTypes
.
string
}
;
}
constructor
(
props
)
{
super
(
props
)
;
this
.
startDragging
=
this
.
startDragging
.
bind
(
this
)
;
this
.
onMove
=
this
.
onMove
.
bind
(
this
)
;
this
.
onUp
=
this
.
onUp
.
bind
(
this
)
;
}
startDragging
(
ev
)
{
ev
.
preventDefault
(
)
;
const
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
addEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
addEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStart
&
&
this
.
props
.
onStart
(
)
;
}
onMove
(
ev
)
{
ev
.
preventDefault
(
)
;
if
(
!
ev
.
target
.
tagName
)
{
return
;
}
this
.
props
.
onMove
(
ev
)
;
}
onUp
(
ev
)
{
ev
.
preventDefault
(
)
;
const
doc
=
ReactDOM
.
findDOMNode
(
this
)
.
ownerDocument
;
doc
.
removeEventListener
(
"
mousemove
"
this
.
onMove
)
;
doc
.
removeEventListener
(
"
mouseup
"
this
.
onUp
)
;
this
.
props
.
onStop
&
&
this
.
props
.
onStop
(
)
;
}
render
(
)
{
return
dom
.
div
(
{
style
:
this
.
props
.
style
className
:
this
.
props
.
className
onMouseDown
:
this
.
startDragging
}
)
;
}
}
module
.
exports
=
Draggable
;
}
)
448
:
(
function
(
module
exports
)
{
}
)
449
:
(
function
(
module
exports
__webpack_require__
)
{
"
use
strict
"
;
Object
.
defineProperty
(
exports
"
__esModule
"
{
value
:
true
}
)
;
exports
.
default
=
move
;
function
_toConsumableArray
(
arr
)
{
if
(
Array
.
isArray
(
arr
)
)
{
for
(
var
i
=
0
arr2
=
Array
(
arr
.
length
)
;
i
<
arr
.
length
;
i
+
+
)
{
arr2
[
i
]
=
arr
[
i
]
;
}
return
arr2
;
}
else
{
return
Array
.
from
(
arr
)
;
}
}
function
move
(
array
moveIndex
toIndex
)
{
var
item
=
array
[
moveIndex
]
;
var
length
=
array
.
length
;
var
diff
=
moveIndex
-
toIndex
;
if
(
diff
>
0
)
{
return
[
]
.
concat
(
_toConsumableArray
(
array
.
slice
(
0
toIndex
)
)
[
item
]
_toConsumableArray
(
array
.
slice
(
toIndex
moveIndex
)
)
_toConsumableArray
(
array
.
slice
(
moveIndex
+
1
length
)
)
)
;
}
else
if
(
diff
<
0
)
{
return
[
]
.
concat
(
_toConsumableArray
(
array
.
slice
(
0
moveIndex
)
)
_toConsumableArray
(
array
.
slice
(
moveIndex
+
1
toIndex
+
1
)
)
[
item
]
_toConsumableArray
(
array
.
slice
(
toIndex
+
1
length
)
)
)
;
}
return
array
;
}
}
)
550
:
(
function
(
module
exports
__webpack_require__
)
{
const
feature
=
__webpack_require__
(
551
)
;
module
.
exports
=
feature
;
}
)
551
:
(
function
(
module
exports
__webpack_require__
)
{
const
{
get
:
pick
set
:
put
}
=
__webpack_require__
(
417
)
;
const
fs
=
__webpack_require__
(
418
)
;
const
path
=
__webpack_require__
(
419
)
;
let
config
;
function
getValue
(
key
)
{
return
pick
(
config
key
)
;
}
function
setValue
(
key
value
)
{
return
put
(
config
key
value
)
;
}
function
setConfig
(
value
)
{
config
=
value
;
}
function
getConfig
(
)
{
return
config
;
}
function
updateLocalConfig
(
relativePath
)
{
const
localConfigPath
=
path
.
resolve
(
relativePath
"
.
.
/
configs
/
local
.
json
"
)
;
const
output
=
JSON
.
stringify
(
config
null
2
)
;
fs
.
writeFileSync
(
localConfigPath
output
{
flag
:
"
w
"
}
)
;
return
output
;
}
module
.
exports
=
{
getValue
setValue
getConfig
setConfig
updateLocalConfig
}
;
}
)
554
:
(
function
(
module
exports
__webpack_require__
)
{
(
function
(
process
)
{
const
flag
=
__webpack_require__
(
103
)
;
function
isBrowser
(
)
{
return
typeof
window
=
=
"
object
"
;
}
function
isNode
(
)
{
return
process
&
&
process
.
release
&
&
process
.
release
.
name
=
=
'
node
'
;
}
function
isDevelopment
(
)
{
if
(
!
isNode
(
)
&
&
isBrowser
(
)
)
{
const
href
=
window
.
location
?
window
.
location
.
href
:
"
"
;
return
href
.
match
(
/
^
file
:
/
)
|
|
href
.
match
(
/
localhost
:
/
)
;
}
return
"
production
"
!
=
"
production
"
;
}
function
isTesting
(
)
{
return
flag
.
testing
;
}
function
isFirefoxPanel
(
)
{
return
!
isDevelopment
(
)
;
}
function
isFirefox
(
)
{
return
/
firefox
/
i
.
test
(
navigator
.
userAgent
)
;
}
module
.
exports
=
{
isDevelopment
isTesting
isFirefoxPanel
isFirefox
}
;
}
.
call
(
exports
__webpack_require__
(
35
)
)
)
}
)
6
:
(
function
(
module
exports
)
{
module
.
exports
=
__WEBPACK_EXTERNAL_MODULE_6__
;
}
)
66
:
(
function
(
module
exports
)
{
(
function
(
)
{
var
AcronymResult
computeScore
emptyAcronymResult
isAcronymFullWord
isMatch
isSeparator
isWordEnd
isWordStart
miss_coeff
pos_bonus
scoreAcronyms
scoreCharacter
scoreConsecutives
scoreExact
scoreExactMatch
scorePattern
scorePosition
scoreSize
tau_size
wm
;
wm
=
150
;
pos_bonus
=
20
;
tau_size
=
150
;
miss_coeff
=
0
.
75
;
exports
.
score
=
function
(
string
query
options
)
{
var
allowErrors
preparedQuery
score
string_lw
;
preparedQuery
=
options
.
preparedQuery
allowErrors
=
options
.
allowErrors
;
if
(
!
(
allowErrors
|
|
isMatch
(
string
preparedQuery
.
core_lw
preparedQuery
.
core_up
)
)
)
{
return
0
;
}
string_lw
=
string
.
toLowerCase
(
)
;
score
=
computeScore
(
string
string_lw
preparedQuery
)
;
return
Math
.
ceil
(
score
)
;
}
;
exports
.
isMatch
=
isMatch
=
function
(
subject
query_lw
query_up
)
{
var
i
j
m
n
qj_lw
qj_up
si
;
m
=
subject
.
length
;
n
=
query_lw
.
length
;
if
(
!
m
|
|
n
>
m
)
{
return
false
;
}
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
.
charCodeAt
(
j
)
;
qj_up
=
query_up
.
charCodeAt
(
j
)
;
while
(
+
+
i
<
m
)
{
si
=
subject
.
charCodeAt
(
i
)
;
if
(
si
=
=
=
qj_lw
|
|
si
=
=
=
qj_up
)
{
break
;
}
}
if
(
i
=
=
=
m
)
{
return
false
;
}
}
return
true
;
}
;
exports
.
computeScore
=
computeScore
=
function
(
subject
subject_lw
preparedQuery
)
{
var
acro
acro_score
align
csc_diag
csc_row
csc_score
csc_should_rebuild
i
j
m
miss_budget
miss_left
n
pos
query
query_lw
record_miss
score
score_diag
score_row
score_up
si_lw
start
sz
;
query
=
preparedQuery
.
query
;
query_lw
=
preparedQuery
.
query_lw
;
m
=
subject
.
length
;
n
=
query
.
length
;
acro
=
scoreAcronyms
(
subject
subject_lw
query
query_lw
)
;
acro_score
=
acro
.
score
;
if
(
acro
.
count
=
=
=
n
)
{
return
scoreExact
(
n
m
acro_score
acro
.
pos
)
;
}
pos
=
subject_lw
.
indexOf
(
query_lw
)
;
if
(
pos
>
-
1
)
{
return
scoreExactMatch
(
subject
subject_lw
query
query_lw
pos
n
m
)
;
}
score_row
=
new
Array
(
n
)
;
csc_row
=
new
Array
(
n
)
;
sz
=
scoreSize
(
n
m
)
;
miss_budget
=
Math
.
ceil
(
miss_coeff
*
n
)
+
5
;
miss_left
=
miss_budget
;
csc_should_rebuild
=
true
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_row
[
j
]
=
0
;
csc_row
[
j
]
=
0
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
si_lw
=
subject_lw
[
i
]
;
if
(
!
si_lw
.
charCodeAt
(
0
)
in
preparedQuery
.
charCodes
)
{
if
(
csc_should_rebuild
)
{
j
=
-
1
;
while
(
+
+
j
<
n
)
{
csc_row
[
j
]
=
0
;
}
csc_should_rebuild
=
false
;
}
continue
;
}
score
=
0
;
score_diag
=
0
;
csc_diag
=
0
;
record_miss
=
true
;
csc_should_rebuild
=
true
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
score_up
=
score_row
[
j
]
;
if
(
score_up
>
score
)
{
score
=
score_up
;
}
csc_score
=
0
;
if
(
query_lw
[
j
]
=
=
=
si_lw
)
{
start
=
isWordStart
(
i
subject
subject_lw
)
;
csc_score
=
csc_diag
>
0
?
csc_diag
:
scoreConsecutives
(
subject
subject_lw
query
query_lw
i
j
start
)
;
align
=
score_diag
+
scoreCharacter
(
i
j
start
acro_score
csc_score
)
;
if
(
align
>
score
)
{
score
=
align
;
miss_left
=
miss_budget
;
}
else
{
if
(
record_miss
&
&
-
-
miss_left
<
=
0
)
{
return
Math
.
max
(
score
score_row
[
n
-
1
]
)
*
sz
;
}
record_miss
=
false
;
}
}
score_diag
=
score_up
;
csc_diag
=
csc_row
[
j
]
;
csc_row
[
j
]
=
csc_score
;
score_row
[
j
]
=
score
;
}
}
score
=
score_row
[
n
-
1
]
;
return
score
*
sz
;
}
;
exports
.
isWordStart
=
isWordStart
=
function
(
pos
subject
subject_lw
)
{
var
curr_s
prev_s
;
if
(
pos
=
=
=
0
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
prev_s
=
subject
[
pos
-
1
]
;
return
isSeparator
(
prev_s
)
|
|
(
curr_s
!
=
=
subject_lw
[
pos
]
&
&
prev_s
=
=
=
subject_lw
[
pos
-
1
]
)
;
}
;
exports
.
isWordEnd
=
isWordEnd
=
function
(
pos
subject
subject_lw
len
)
{
var
curr_s
next_s
;
if
(
pos
=
=
=
len
-
1
)
{
return
true
;
}
curr_s
=
subject
[
pos
]
;
next_s
=
subject
[
pos
+
1
]
;
return
isSeparator
(
next_s
)
|
|
(
curr_s
=
=
=
subject_lw
[
pos
]
&
&
next_s
!
=
=
subject_lw
[
pos
+
1
]
)
;
}
;
isSeparator
=
function
(
c
)
{
return
c
=
=
=
'
'
|
|
c
=
=
=
'
.
'
|
|
c
=
=
=
'
-
'
|
|
c
=
=
=
'
_
'
|
|
c
=
=
=
'
/
'
|
|
c
=
=
=
'
\
\
'
;
}
;
scorePosition
=
function
(
pos
)
{
var
sc
;
if
(
pos
<
pos_bonus
)
{
sc
=
pos_bonus
-
pos
;
return
100
+
sc
*
sc
;
}
else
{
return
Math
.
max
(
100
+
pos_bonus
-
pos
0
)
;
}
}
;
exports
.
scoreSize
=
scoreSize
=
function
(
n
m
)
{
return
tau_size
/
(
tau_size
+
Math
.
abs
(
m
-
n
)
)
;
}
;
scoreExact
=
function
(
n
m
quality
pos
)
{
return
2
*
n
*
(
wm
*
quality
+
scorePosition
(
pos
)
)
*
scoreSize
(
n
m
)
;
}
;
exports
.
scorePattern
=
scorePattern
=
function
(
count
len
sameCase
start
end
)
{
var
bonus
sz
;
sz
=
count
;
bonus
=
6
;
if
(
sameCase
=
=
=
count
)
{
bonus
+
=
2
;
}
if
(
start
)
{
bonus
+
=
3
;
}
if
(
end
)
{
bonus
+
=
1
;
}
if
(
count
=
=
=
len
)
{
if
(
start
)
{
if
(
sameCase
=
=
=
len
)
{
sz
+
=
2
;
}
else
{
sz
+
=
1
;
}
}
if
(
end
)
{
bonus
+
=
1
;
}
}
return
sameCase
+
sz
*
(
sz
+
bonus
)
;
}
;
exports
.
scoreCharacter
=
scoreCharacter
=
function
(
i
j
start
acro_score
csc_score
)
{
var
posBonus
;
posBonus
=
scorePosition
(
i
)
;
if
(
start
)
{
return
posBonus
+
wm
*
(
(
acro_score
>
csc_score
?
acro_score
:
csc_score
)
+
10
)
;
}
return
posBonus
+
wm
*
csc_score
;
}
;
exports
.
scoreConsecutives
=
scoreConsecutives
=
function
(
subject
subject_lw
query
query_lw
i
j
startOfWord
)
{
var
k
m
mi
n
nj
sameCase
sz
;
m
=
subject
.
length
;
n
=
query
.
length
;
mi
=
m
-
i
;
nj
=
n
-
j
;
k
=
mi
<
nj
?
mi
:
nj
;
sameCase
=
0
;
sz
=
0
;
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
while
(
+
+
sz
<
k
&
&
query_lw
[
+
+
j
]
=
=
=
subject_lw
[
+
+
i
]
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
if
(
sz
<
k
)
{
i
-
-
;
}
if
(
sz
=
=
=
1
)
{
return
1
+
2
*
sameCase
;
}
return
scorePattern
(
sz
n
sameCase
startOfWord
isWordEnd
(
i
subject
subject_lw
m
)
)
;
}
;
exports
.
scoreExactMatch
=
scoreExactMatch
=
function
(
subject
subject_lw
query
query_lw
pos
n
m
)
{
var
end
i
pos2
sameCase
start
;
start
=
isWordStart
(
pos
subject
subject_lw
)
;
if
(
!
start
)
{
pos2
=
subject_lw
.
indexOf
(
query_lw
pos
+
1
)
;
if
(
pos2
>
-
1
)
{
start
=
isWordStart
(
pos2
subject
subject_lw
)
;
if
(
start
)
{
pos
=
pos2
;
}
}
}
i
=
-
1
;
sameCase
=
0
;
while
(
+
+
i
<
n
)
{
if
(
query
[
pos
+
i
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
}
end
=
isWordEnd
(
pos
+
n
-
1
subject
subject_lw
m
)
;
return
scoreExact
(
n
m
scorePattern
(
n
n
sameCase
start
end
)
pos
)
;
}
;
AcronymResult
=
(
function
(
)
{
function
AcronymResult
(
score
pos
count
)
{
this
.
score
=
score
;
this
.
pos
=
pos
;
this
.
count
=
count
;
}
return
AcronymResult
;
}
)
(
)
;
emptyAcronymResult
=
new
AcronymResult
(
0
0
.
1
0
)
;
exports
.
scoreAcronyms
=
scoreAcronyms
=
function
(
subject
subject_lw
query
query_lw
)
{
var
count
fullWord
i
j
m
n
qj_lw
sameCase
score
sepCount
sumPos
;
m
=
subject
.
length
;
n
=
query
.
length
;
if
(
!
(
m
>
1
&
&
n
>
1
)
)
{
return
emptyAcronymResult
;
}
count
=
0
;
sepCount
=
0
;
sumPos
=
0
;
sameCase
=
0
;
i
=
-
1
;
j
=
-
1
;
while
(
+
+
j
<
n
)
{
qj_lw
=
query_lw
[
j
]
;
if
(
isSeparator
(
qj_lw
)
)
{
i
=
subject_lw
.
indexOf
(
qj_lw
i
+
1
)
;
if
(
i
>
-
1
)
{
sepCount
+
+
;
continue
;
}
else
{
break
;
}
}
while
(
+
+
i
<
m
)
{
if
(
qj_lw
=
=
=
subject_lw
[
i
]
&
&
isWordStart
(
i
subject
subject_lw
)
)
{
if
(
query
[
j
]
=
=
=
subject
[
i
]
)
{
sameCase
+
+
;
}
sumPos
+
=
i
;
count
+
+
;
break
;
}
}
if
(
i
=
=
=
m
)
{
break
;
}
}
if
(
count
<
2
)
{
return
emptyAcronymResult
;
}
fullWord
=
count
=
=
=
n
?
isAcronymFullWord
(
subject
subject_lw
query
count
)
:
false
;
score
=
scorePattern
(
count
n
sameCase
true
fullWord
)
;
return
new
AcronymResult
(
score
sumPos
/
count
count
+
sepCount
)
;
}
;
isAcronymFullWord
=
function
(
subject
subject_lw
query
nbAcronymInQuery
)
{
var
count
i
m
n
;
m
=
subject
.
length
;
n
=
query
.
length
;
count
=
0
;
if
(
m
>
12
*
n
)
{
return
false
;
}
i
=
-
1
;
while
(
+
+
i
<
m
)
{
if
(
isWordStart
(
i
subject
subject_lw
)
&
&
+
+
count
>
nbAcronymInQuery
)
{
return
false
;
}
}
return
true
;
}
;
}
)
.
call
(
this
)
;
}
)
67
:
(
function
(
module
exports
__webpack_require__
)
{
var
__WEBPACK_AMD_DEFINE_ARRAY__
__WEBPACK_AMD_DEFINE_RESULT__
;
(
function
(
)
{
'
use
strict
'
;
var
hasOwn
=
{
}
.
hasOwnProperty
;
function
classNames
(
)
{
var
classes
=
[
]
;
for
(
var
i
=
0
;
i
<
arguments
.
length
;
i
+
+
)
{
var
arg
=
arguments
[
i
]
;
if
(
!
arg
)
continue
;
var
argType
=
typeof
arg
;
if
(
argType
=
=
=
'
string
'
|
|
argType
=
=
=
'
number
'
)
{
classes
.
push
(
arg
)
;
}
else
if
(
Array
.
isArray
(
arg
)
&
&
arg
.
length
)
{
var
inner
=
classNames
.
apply
(
null
arg
)
;
if
(
inner
)
{
classes
.
push
(
inner
)
;
}
}
else
if
(
argType
=
=
=
'
object
'
)
{
for
(
var
key
in
arg
)
{
if
(
hasOwn
.
call
(
arg
key
)
&
&
arg
[
key
]
)
{
classes
.
push
(
key
)
;
}
}
}
}
return
classes
.
join
(
'
'
)
;
}
if
(
typeof
module
!
=
=
'
undefined
'
&
&
module
.
exports
)
{
classNames
.
default
=
classNames
;
module
.
exports
=
classNames
;
}
else
if
(
true
)
{
!
(
__WEBPACK_AMD_DEFINE_ARRAY__
=
[
]
__WEBPACK_AMD_DEFINE_RESULT__
=
(
function
(
)
{
return
classNames
;
}
)
.
apply
(
exports
__WEBPACK_AMD_DEFINE_ARRAY__
)
__WEBPACK_AMD_DEFINE_RESULT__
!
=
=
undefined
&
&
(
module
.
exports
=
__WEBPACK_AMD_DEFINE_RESULT__
)
)
;
}
else
{
window
.
classNames
=
classNames
;
}
}
(
)
)
;
}
)
7
:
(
function
(
module
exports
__webpack_require__
)
{
const
networkRequest
=
__webpack_require__
(
13
)
;
const
workerUtils
=
__webpack_require__
(
14
)
;
module
.
exports
=
{
networkRequest
workerUtils
}
;
}
)
}
)
;
}
)
;
