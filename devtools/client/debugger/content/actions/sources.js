"
use
strict
"
;
const
constants
=
require
(
"
.
.
/
constants
"
)
;
const
promise
=
require
(
"
promise
"
)
;
const
Services
=
require
(
"
Services
"
)
;
const
{
dumpn
}
=
require
(
"
devtools
/
shared
/
DevToolsUtils
"
)
;
const
{
PROMISE
HISTOGRAM_ID
}
=
require
(
"
devtools
/
client
/
shared
/
redux
/
middleware
/
promise
"
)
;
const
{
getSource
getSourceText
}
=
require
(
"
.
.
/
queries
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
NEW_SOURCE_IGNORED_URLS
=
[
"
debugger
eval
code
"
"
XStringBundle
"
]
;
const
FETCH_SOURCE_RESPONSE_DELAY
=
200
;
function
getSourceClient
(
source
)
{
return
gThreadClient
.
source
(
source
)
;
}
function
newSource
(
source
)
{
return
dispatch
=
>
{
if
(
NEW_SOURCE_IGNORED_URLS
.
includes
(
source
.
url
)
)
{
return
;
}
window
.
emit
(
EVENTS
.
NEW_SOURCE
)
;
return
dispatch
(
{
type
:
constants
.
ADD_SOURCE
source
:
source
}
)
;
}
;
}
function
selectSource
(
source
opts
)
{
return
(
dispatch
getState
)
=
>
{
if
(
!
gThreadClient
)
{
return
;
}
source
=
getSource
(
getState
(
)
source
.
actor
)
;
dispatch
(
loadSourceText
(
source
)
)
;
dispatch
(
{
type
:
constants
.
SELECT_SOURCE
source
:
source
opts
:
opts
}
)
;
}
;
}
function
loadSources
(
)
{
return
{
type
:
constants
.
LOAD_SOURCES
[
PROMISE
]
:
Task
.
spawn
(
function
*
(
)
{
const
response
=
yield
gThreadClient
.
getSources
(
)
;
if
(
!
response
.
sources
)
{
dumpn
(
"
Error
getting
sources
probably
because
a
top
-
level
"
+
"
breakpoint
was
hit
while
executing
them
"
)
;
return
;
}
return
response
.
sources
.
filter
(
source
=
>
{
return
!
NEW_SOURCE_IGNORED_URLS
.
includes
(
source
.
url
)
;
}
)
;
}
)
}
;
}
function
blackbox
(
source
shouldBlackBox
)
{
const
client
=
getSourceClient
(
source
)
;
return
{
type
:
constants
.
BLACKBOX
source
:
source
[
PROMISE
]
:
Task
.
spawn
(
function
*
(
)
{
yield
shouldBlackBox
?
client
.
blackBox
(
)
:
client
.
unblackBox
(
)
;
return
{
isBlackBoxed
:
shouldBlackBox
}
;
}
)
}
;
}
function
togglePrettyPrint
(
source
)
{
return
(
dispatch
getState
)
=
>
{
const
sourceClient
=
getSourceClient
(
source
)
;
const
wantPretty
=
!
source
.
isPrettyPrinted
;
return
dispatch
(
{
type
:
constants
.
TOGGLE_PRETTY_PRINT
source
:
source
[
PROMISE
]
:
Task
.
spawn
(
function
*
(
)
{
let
response
;
const
sourceText
=
getSourceText
(
getState
(
)
source
.
actor
)
;
const
contentType
=
sourceText
?
sourceText
.
contentType
:
null
;
if
(
!
SourceUtils
.
isJavaScript
(
source
.
url
contentType
)
)
{
throw
new
Error
(
"
Can
'
t
prettify
non
-
javascript
files
.
"
)
;
}
if
(
wantPretty
)
{
response
=
yield
sourceClient
.
prettyPrint
(
Prefs
.
editorTabSize
)
;
}
else
{
response
=
yield
sourceClient
.
disablePrettyPrint
(
)
;
}
DebuggerController
.
Parser
.
clearSource
(
source
.
url
)
;
return
{
isPrettyPrinted
:
wantPretty
text
:
response
.
source
contentType
:
response
.
contentType
}
;
}
)
}
)
;
}
;
}
function
loadSourceText
(
source
)
{
return
(
dispatch
getState
)
=
>
{
let
textInfo
=
getSourceText
(
getState
(
)
source
.
actor
)
;
if
(
textInfo
)
{
return
promise
.
resolve
(
textInfo
)
;
}
const
sourceClient
=
getSourceClient
(
source
)
;
return
dispatch
(
{
type
:
constants
.
LOAD_SOURCE_TEXT
source
:
source
[
PROMISE
]
:
Task
.
spawn
(
function
*
(
)
{
let
transportType
=
gClient
.
localTransport
?
"
_LOCAL
"
:
"
_REMOTE
"
;
let
histogramId
=
"
DEVTOOLS_DEBUGGER_DISPLAY_SOURCE
"
+
transportType
+
"
_MS
"
;
let
histogram
=
Services
.
telemetry
.
getHistogramById
(
histogramId
)
;
let
startTime
=
Date
.
now
(
)
;
const
response
=
yield
sourceClient
.
source
(
)
;
histogram
.
add
(
Date
.
now
(
)
-
startTime
)
;
if
(
Prefs
.
autoPrettyPrint
&
&
!
source
.
isPrettyPrinted
&
&
SourceUtils
.
isMinified
(
source
.
actor
response
.
source
)
)
{
dispatch
(
togglePrettyPrint
(
source
)
)
;
}
return
{
text
:
response
.
source
contentType
:
response
.
contentType
}
;
}
)
}
)
;
}
;
}
function
getTextForSources
(
actors
)
{
return
(
dispatch
getState
)
=
>
{
let
deferred
=
promise
.
defer
(
)
;
let
pending
=
new
Set
(
actors
)
;
let
fetched
=
[
]
;
for
(
let
actor
of
actors
)
{
let
source
=
getSource
(
getState
(
)
actor
)
;
dispatch
(
loadSourceText
(
source
)
)
.
then
(
(
{
text
contentType
}
)
=
>
{
onFetch
(
[
source
text
contentType
]
)
;
}
err
=
>
{
onError
(
source
err
)
;
}
)
;
}
setTimeout
(
onTimeout
FETCH_SOURCE_RESPONSE_DELAY
)
;
function
onTimeout
(
)
{
pending
=
new
Set
(
)
;
maybeFinish
(
)
;
}
function
onFetch
(
[
aSource
aText
aContentType
]
)
{
if
(
!
pending
.
has
(
aSource
.
actor
)
)
{
return
;
}
pending
.
delete
(
aSource
.
actor
)
;
fetched
.
push
(
[
aSource
.
actor
aText
aContentType
]
)
;
maybeFinish
(
)
;
}
function
onError
(
[
aSource
aError
]
)
{
pending
.
delete
(
aSource
.
actor
)
;
maybeFinish
(
)
;
}
function
maybeFinish
(
)
{
if
(
pending
.
size
=
=
0
)
{
deferred
.
resolve
(
fetched
.
sort
(
(
[
aFirst
]
[
aSecond
]
)
=
>
aFirst
>
aSecond
)
)
;
}
}
return
deferred
.
promise
;
}
;
}
module
.
exports
=
{
newSource
selectSource
loadSources
blackbox
togglePrettyPrint
loadSourceText
getTextForSources
}
;
