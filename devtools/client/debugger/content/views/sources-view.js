"
use
strict
"
;
const
utils
=
require
(
"
.
.
/
utils
"
)
;
const
{
getSelectedSource
getSourceByURL
getBreakpoint
getBreakpoints
makeLocationId
}
=
require
(
"
.
.
/
queries
"
)
;
const
actions
=
Object
.
assign
(
{
}
require
(
"
.
.
/
actions
/
sources
"
)
require
(
"
.
.
/
actions
/
breakpoints
"
)
)
;
const
{
bindActionCreators
}
=
require
(
"
devtools
/
client
/
shared
/
vendor
/
redux
"
)
;
const
{
extend
}
=
require
(
"
devtools
/
shared
/
extend
"
)
;
const
{
WidgetMethods
setNamedTimeout
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
view
-
helpers
"
)
;
const
{
Task
}
=
require
(
"
devtools
/
shared
/
task
"
)
;
const
{
SideMenuWidget
}
=
require
(
"
resource
:
/
/
devtools
/
client
/
shared
/
widgets
/
SideMenuWidget
.
jsm
"
)
;
const
{
gDevTools
}
=
require
(
"
devtools
/
client
/
framework
/
devtools
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
NEW_SOURCE_DISPLAY_DELAY
=
200
;
const
FUNCTION_SEARCH_POPUP_POSITION
=
"
topcenter
bottomleft
"
;
const
BREAKPOINT_LINE_TOOLTIP_MAX_LENGTH
=
1000
;
const
BREAKPOINT_CONDITIONAL_POPUP_POSITION
=
"
before_start
"
;
const
BREAKPOINT_CONDITIONAL_POPUP_OFFSET_X
=
7
;
const
BREAKPOINT_CONDITIONAL_POPUP_OFFSET_Y
=
-
3
;
function
SourcesView
(
controller
DebuggerView
)
{
dumpn
(
"
SourcesView
was
instantiated
"
)
;
utils
.
onReducerEvents
(
controller
{
"
source
"
:
this
.
renderSource
"
blackboxed
"
:
this
.
renderBlackBoxed
"
prettyprinted
"
:
this
.
updateToolbarButtonsState
"
source
-
selected
"
:
this
.
renderSourceSelected
"
breakpoint
-
updated
"
:
bp
=
>
this
.
renderBreakpoint
(
bp
)
"
breakpoint
-
enabled
"
:
bp
=
>
this
.
renderBreakpoint
(
bp
)
"
breakpoint
-
disabled
"
:
bp
=
>
this
.
renderBreakpoint
(
bp
)
"
breakpoint
-
removed
"
:
bp
=
>
this
.
renderBreakpoint
(
bp
true
)
}
this
)
;
this
.
getState
=
controller
.
getState
;
this
.
actions
=
bindActionCreators
(
actions
controller
.
dispatch
)
;
this
.
DebuggerView
=
DebuggerView
;
this
.
Parser
=
DebuggerController
.
Parser
;
this
.
togglePrettyPrint
=
this
.
togglePrettyPrint
.
bind
(
this
)
;
this
.
toggleBlackBoxing
=
this
.
toggleBlackBoxing
.
bind
(
this
)
;
this
.
toggleBreakpoints
=
this
.
toggleBreakpoints
.
bind
(
this
)
;
this
.
_onEditorCursorActivity
=
this
.
_onEditorCursorActivity
.
bind
(
this
)
;
this
.
_onMouseDown
=
this
.
_onMouseDown
.
bind
(
this
)
;
this
.
_onSourceSelect
=
this
.
_onSourceSelect
.
bind
(
this
)
;
this
.
_onStopBlackBoxing
=
this
.
_onStopBlackBoxing
.
bind
(
this
)
;
this
.
_onBreakpointRemoved
=
this
.
_onBreakpointRemoved
.
bind
(
this
)
;
this
.
_onBreakpointClick
=
this
.
_onBreakpointClick
.
bind
(
this
)
;
this
.
_onBreakpointCheckboxClick
=
this
.
_onBreakpointCheckboxClick
.
bind
(
this
)
;
this
.
_onConditionalPopupShowing
=
this
.
_onConditionalPopupShowing
.
bind
(
this
)
;
this
.
_onConditionalPopupShown
=
this
.
_onConditionalPopupShown
.
bind
(
this
)
;
this
.
_onConditionalPopupHiding
=
this
.
_onConditionalPopupHiding
.
bind
(
this
)
;
this
.
_onConditionalTextboxKeyPress
=
this
.
_onConditionalTextboxKeyPress
.
bind
(
this
)
;
this
.
_onEditorContextMenuOpen
=
this
.
_onEditorContextMenuOpen
.
bind
(
this
)
;
this
.
_onCopyUrlCommand
=
this
.
_onCopyUrlCommand
.
bind
(
this
)
;
this
.
_onNewTabCommand
=
this
.
_onNewTabCommand
.
bind
(
this
)
;
this
.
_onConditionalPopupHidden
=
this
.
_onConditionalPopupHidden
.
bind
(
this
)
;
}
SourcesView
.
prototype
=
extend
(
WidgetMethods
{
initialize
:
function
(
isWorker
)
{
dumpn
(
"
Initializing
the
SourcesView
"
)
;
this
.
widget
=
new
SideMenuWidget
(
document
.
getElementById
(
"
sources
"
)
{
contextMenu
:
document
.
getElementById
(
"
debuggerSourcesContextMenu
"
)
showArrows
:
true
}
)
;
this
.
_preferredSourceURL
=
null
;
this
.
_unnamedSourceIndex
=
0
;
this
.
emptyText
=
L10N
.
getStr
(
"
noSourcesText
"
)
;
this
.
_blackBoxCheckboxTooltip
=
L10N
.
getStr
(
"
blackboxCheckboxTooltip2
"
)
;
this
.
_commandset
=
document
.
getElementById
(
"
debuggerCommands
"
)
;
this
.
_popupset
=
document
.
getElementById
(
"
debuggerPopupset
"
)
;
this
.
_cmPopup
=
document
.
getElementById
(
"
sourceEditorContextMenu
"
)
;
this
.
_cbPanel
=
document
.
getElementById
(
"
conditional
-
breakpoint
-
panel
"
)
;
this
.
_cbTextbox
=
document
.
getElementById
(
"
conditional
-
breakpoint
-
panel
-
textbox
"
)
;
this
.
_blackBoxButton
=
document
.
getElementById
(
"
black
-
box
"
)
;
this
.
_stopBlackBoxButton
=
document
.
getElementById
(
"
black
-
boxed
-
message
-
button
"
)
;
this
.
_prettyPrintButton
=
document
.
getElementById
(
"
pretty
-
print
"
)
;
this
.
_toggleBreakpointsButton
=
document
.
getElementById
(
"
toggle
-
breakpoints
"
)
;
this
.
_newTabMenuItem
=
document
.
getElementById
(
"
debugger
-
sources
-
context
-
newtab
"
)
;
this
.
_copyUrlMenuItem
=
document
.
getElementById
(
"
debugger
-
sources
-
context
-
copyurl
"
)
;
this
.
_noResultsFoundToolTip
=
new
Tooltip
(
document
)
;
this
.
_noResultsFoundToolTip
.
defaultPosition
=
FUNCTION_SEARCH_POPUP_POSITION
;
if
(
Prefs
.
prettyPrintEnabled
&
&
!
isWorker
)
{
this
.
_prettyPrintButton
.
removeAttribute
(
"
hidden
"
)
;
}
this
.
_editorContainer
=
document
.
getElementById
(
"
editor
"
)
;
this
.
_editorContainer
.
addEventListener
(
"
mousedown
"
this
.
_onMouseDown
)
;
this
.
widget
.
addEventListener
(
"
select
"
this
.
_onSourceSelect
)
;
this
.
_stopBlackBoxButton
.
addEventListener
(
"
click
"
this
.
_onStopBlackBoxing
)
;
this
.
_cbPanel
.
addEventListener
(
"
popupshowing
"
this
.
_onConditionalPopupShowing
)
;
this
.
_cbPanel
.
addEventListener
(
"
popupshown
"
this
.
_onConditionalPopupShown
)
;
this
.
_cbPanel
.
addEventListener
(
"
popuphiding
"
this
.
_onConditionalPopupHiding
)
;
this
.
_cbPanel
.
addEventListener
(
"
popuphidden
"
this
.
_onConditionalPopupHidden
)
;
this
.
_cbTextbox
.
addEventListener
(
"
keypress
"
this
.
_onConditionalTextboxKeyPress
)
;
this
.
_copyUrlMenuItem
.
addEventListener
(
"
command
"
this
.
_onCopyUrlCommand
)
;
this
.
_newTabMenuItem
.
addEventListener
(
"
command
"
this
.
_onNewTabCommand
)
;
this
.
_cbPanel
.
hidden
=
true
;
this
.
allowFocusOnRightClick
=
true
;
this
.
autoFocusOnSelection
=
false
;
this
.
autoFocusOnFirstItem
=
false
;
this
.
sortContents
(
(
aFirst
aSecond
)
=
>
{
return
+
(
aFirst
.
attachment
.
label
.
toLowerCase
(
)
>
aSecond
.
attachment
.
label
.
toLowerCase
(
)
)
;
}
)
;
this
.
widget
.
groupSortPredicate
=
function
(
a
b
)
{
if
(
(
a
in
KNOWN_SOURCE_GROUPS
)
=
=
(
b
in
KNOWN_SOURCE_GROUPS
)
)
{
return
a
.
localeCompare
(
b
)
;
}
return
(
a
in
KNOWN_SOURCE_GROUPS
)
?
1
:
-
1
;
}
;
this
.
DebuggerView
.
editor
.
on
(
"
popupOpen
"
this
.
_onEditorContextMenuOpen
)
;
this
.
_addCommands
(
)
;
}
destroy
:
function
(
)
{
dumpn
(
"
Destroying
the
SourcesView
"
)
;
this
.
widget
.
removeEventListener
(
"
select
"
this
.
_onSourceSelect
)
;
this
.
_stopBlackBoxButton
.
removeEventListener
(
"
click
"
this
.
_onStopBlackBoxing
)
;
this
.
_cbPanel
.
removeEventListener
(
"
popupshowing
"
this
.
_onConditionalPopupShowing
)
;
this
.
_cbPanel
.
removeEventListener
(
"
popupshown
"
this
.
_onConditionalPopupShown
)
;
this
.
_cbPanel
.
removeEventListener
(
"
popuphiding
"
this
.
_onConditionalPopupHiding
)
;
this
.
_cbPanel
.
removeEventListener
(
"
popuphidden
"
this
.
_onConditionalPopupHidden
)
;
this
.
_cbTextbox
.
removeEventListener
(
"
keypress
"
this
.
_onConditionalTextboxKeyPress
)
;
this
.
_copyUrlMenuItem
.
removeEventListener
(
"
command
"
this
.
_onCopyUrlCommand
)
;
this
.
_newTabMenuItem
.
removeEventListener
(
"
command
"
this
.
_onNewTabCommand
)
;
this
.
DebuggerView
.
editor
.
off
(
"
popupOpen
"
this
.
_onEditorContextMenuOpen
false
)
;
}
empty
:
function
(
)
{
WidgetMethods
.
empty
.
call
(
this
)
;
this
.
_unnamedSourceIndex
=
0
;
this
.
_selectedBreakpoint
=
null
;
}
_addCommands
:
function
(
)
{
XULUtils
.
addCommands
(
this
.
_commandset
{
addBreakpointCommand
:
e
=
>
this
.
_onCmdAddBreakpoint
(
e
)
addConditionalBreakpointCommand
:
e
=
>
this
.
_onCmdAddConditionalBreakpoint
(
e
)
blackBoxCommand
:
(
)
=
>
this
.
toggleBlackBoxing
(
)
unBlackBoxButton
:
(
)
=
>
this
.
_onStopBlackBoxing
(
)
prettyPrintCommand
:
(
)
=
>
this
.
togglePrettyPrint
(
)
toggleBreakpointsCommand
:
(
)
=
>
this
.
toggleBreakpoints
(
)
nextSourceCommand
:
(
)
=
>
this
.
selectNextItem
(
)
prevSourceCommand
:
(
)
=
>
this
.
selectPrevItem
(
)
}
)
;
}
set
preferredSource
(
aUrl
)
{
this
.
_preferredValue
=
aUrl
;
if
(
this
.
containsValue
(
aUrl
)
)
{
this
.
selectedValue
=
aUrl
;
}
}
sourcesDidUpdate
:
function
(
)
{
if
(
!
getSelectedSource
(
this
.
getState
(
)
)
)
{
let
url
=
this
.
_preferredSourceURL
;
let
source
=
url
&
&
getSourceByURL
(
this
.
getState
(
)
url
)
;
if
(
source
)
{
this
.
actions
.
selectSource
(
source
)
;
}
else
{
setNamedTimeout
(
"
new
-
source
"
NEW_SOURCE_DISPLAY_DELAY
(
)
=
>
{
if
(
!
getSelectedSource
(
this
.
getState
(
)
)
&
&
this
.
itemCount
>
0
)
{
this
.
actions
.
selectSource
(
this
.
getItemAtIndex
(
0
)
.
attachment
.
source
)
;
}
}
)
;
}
}
}
renderSource
:
function
(
source
)
{
this
.
addSource
(
source
{
staged
:
false
}
)
;
for
(
let
bp
of
getBreakpoints
(
this
.
getState
(
)
)
)
{
if
(
bp
.
location
.
actor
=
=
=
source
.
actor
)
{
this
.
renderBreakpoint
(
bp
)
;
}
}
this
.
sourcesDidUpdate
(
)
;
}
addSource
:
function
(
aSource
aOptions
=
{
}
)
{
if
(
!
aSource
.
url
&
&
!
aOptions
.
force
)
{
return
;
}
let
{
label
group
unicodeUrl
}
=
this
.
_parseUrl
(
aSource
)
;
let
contents
=
document
.
createElement
(
"
label
"
)
;
contents
.
className
=
"
plain
dbg
-
source
-
item
"
;
contents
.
setAttribute
(
"
value
"
label
)
;
contents
.
setAttribute
(
"
crop
"
"
start
"
)
;
contents
.
setAttribute
(
"
flex
"
"
1
"
)
;
contents
.
setAttribute
(
"
tooltiptext
"
unicodeUrl
)
;
if
(
aSource
.
introductionType
=
=
=
"
wasm
"
)
{
const
wasm
=
document
.
createElement
(
"
box
"
)
;
wasm
.
className
=
"
dbg
-
wasm
-
item
"
;
const
icon
=
document
.
createElement
(
"
box
"
)
;
icon
.
setAttribute
(
"
tooltiptext
"
L10N
.
getStr
(
"
experimental
"
)
)
;
icon
.
className
=
"
icon
"
;
wasm
.
appendChild
(
icon
)
;
wasm
.
appendChild
(
contents
)
;
contents
=
wasm
;
}
if
(
gThreadClient
.
source
(
aSource
)
.
isBlackBoxed
)
{
contents
.
classList
.
add
(
"
black
-
boxed
"
)
;
}
this
.
push
(
[
contents
aSource
.
actor
]
{
staged
:
aOptions
.
staged
attachment
:
{
label
:
label
group
:
group
checkboxState
:
!
aSource
.
isBlackBoxed
checkboxTooltip
:
this
.
_blackBoxCheckboxTooltip
source
:
aSource
}
}
)
;
}
_parseUrl
:
function
(
aSource
)
{
let
fullUrl
=
aSource
.
url
;
let
url
unicodeUrl
label
group
;
if
(
!
fullUrl
)
{
unicodeUrl
=
"
SCRIPT
"
+
this
.
_unnamedSourceIndex
+
+
;
label
=
unicodeUrl
;
group
=
L10N
.
getStr
(
"
anonymousSourcesLabel
"
)
;
}
else
{
let
url
=
fullUrl
.
split
(
"
-
>
"
)
.
pop
(
)
;
label
=
aSource
.
addonPath
?
aSource
.
addonPath
:
SourceUtils
.
getSourceLabel
(
url
)
;
group
=
aSource
.
addonID
?
aSource
.
addonID
:
SourceUtils
.
getSourceGroup
(
url
)
;
unicodeUrl
=
NetworkHelper
.
convertToUnicode
(
unescape
(
fullUrl
)
)
;
}
return
{
label
:
label
group
:
group
unicodeUrl
:
unicodeUrl
}
;
}
renderBreakpoint
:
function
(
breakpoint
removed
)
{
if
(
removed
)
{
if
(
this
.
_getBreakpoint
(
breakpoint
)
)
{
this
.
_removeBreakpoint
(
breakpoint
)
;
}
}
else
{
if
(
this
.
_getBreakpoint
(
breakpoint
)
)
{
this
.
_updateBreakpointStatus
(
breakpoint
)
;
}
else
{
this
.
_addBreakpoint
(
breakpoint
)
;
}
}
}
_addBreakpoint
:
function
(
breakpoint
options
=
{
}
)
{
let
disabled
=
breakpoint
.
disabled
;
let
location
=
breakpoint
.
location
;
let
sourceItem
=
this
.
getItemByValue
(
location
.
actor
)
;
if
(
!
sourceItem
)
{
return
;
}
let
breakpointArgs
=
extend
(
breakpoint
.
asMutable
(
)
options
)
;
let
breakpointView
=
this
.
_createBreakpointView
.
call
(
this
breakpointArgs
)
;
let
contextMenu
=
this
.
_createContextMenu
.
call
(
this
breakpointArgs
)
;
sourceItem
.
append
(
breakpointView
.
container
{
attachment
:
extend
(
breakpointArgs
{
actor
:
location
.
actor
line
:
location
.
line
view
:
breakpointView
popup
:
contextMenu
}
)
attributes
:
[
[
"
contextmenu
"
contextMenu
.
menupopupId
]
]
finalize
:
this
.
_onBreakpointRemoved
}
)
;
if
(
typeof
breakpoint
.
condition
=
=
=
"
string
"
)
{
this
.
highlightBreakpoint
(
breakpoint
.
location
{
openPopup
:
true
noEditorUpdate
:
true
}
)
;
}
window
.
emit
(
EVENTS
.
BREAKPOINT_SHOWN_IN_PANE
)
;
}
_removeBreakpoint
:
function
(
breakpoint
)
{
let
sourceItem
=
this
.
getItemByValue
(
breakpoint
.
location
.
actor
)
;
if
(
!
sourceItem
)
{
return
;
}
sourceItem
.
remove
(
this
.
_getBreakpoint
(
breakpoint
)
)
;
if
(
this
.
_selectedBreakpoint
&
&
(
queries
.
makeLocationId
(
this
.
_selectedBreakpoint
.
location
)
=
=
=
queries
.
makeLocationId
(
breakpoint
.
location
)
)
)
{
this
.
_selectedBreakpoint
=
null
;
}
window
.
emit
(
EVENTS
.
BREAKPOINT_HIDDEN_IN_PANE
)
;
}
_getBreakpoint
:
function
(
bp
)
{
return
this
.
getItemForPredicate
(
item
=
>
{
return
item
.
attachment
.
actor
=
=
=
bp
.
location
.
actor
&
&
item
.
attachment
.
line
=
=
=
bp
.
location
.
line
;
}
)
;
}
_updateBreakpointStatus
:
function
(
breakpoint
)
{
let
location
=
breakpoint
.
location
;
let
breakpointItem
=
this
.
_getBreakpoint
(
getBreakpoint
(
this
.
getState
(
)
location
)
)
;
if
(
!
breakpointItem
)
{
return
promise
.
reject
(
new
Error
(
"
No
breakpoint
found
.
"
)
)
;
}
let
attachment
=
breakpointItem
.
attachment
;
let
prefix
=
"
bp
-
cMenu
-
"
;
let
identifier
=
makeLocationId
(
location
)
;
let
enableSelfId
=
prefix
+
"
enableSelf
-
"
+
identifier
+
"
-
menuitem
"
;
let
disableSelfId
=
prefix
+
"
disableSelf
-
"
+
identifier
+
"
-
menuitem
"
;
let
enableSelf
=
document
.
getElementById
(
enableSelfId
)
;
let
disableSelf
=
document
.
getElementById
(
disableSelfId
)
;
if
(
breakpoint
.
disabled
)
{
enableSelf
.
removeAttribute
(
"
hidden
"
)
;
disableSelf
.
setAttribute
(
"
hidden
"
true
)
;
attachment
.
view
.
checkbox
.
removeAttribute
(
"
checked
"
)
;
}
else
{
enableSelf
.
setAttribute
(
"
hidden
"
true
)
;
disableSelf
.
removeAttribute
(
"
hidden
"
)
;
attachment
.
view
.
checkbox
.
setAttribute
(
"
checked
"
"
true
"
)
;
this
.
_toggleBreakpointsButton
.
removeAttribute
(
"
checked
"
)
;
}
}
highlightBreakpoint
:
function
(
aLocation
aOptions
=
{
}
)
{
let
breakpoint
=
getBreakpoint
(
this
.
getState
(
)
aLocation
)
;
if
(
!
breakpoint
)
{
return
;
}
this
.
_selectBreakpoint
(
breakpoint
)
;
if
(
!
aOptions
.
noEditorUpdate
)
{
this
.
DebuggerView
.
setEditorLocation
(
aLocation
.
actor
aLocation
.
line
{
noDebug
:
true
}
)
;
}
if
(
aOptions
.
openPopup
)
{
return
this
.
_openConditionalPopup
(
)
;
}
else
{
return
this
.
_hideConditionalPopup
(
)
;
}
}
highlightBreakpointAtCursor
:
function
(
)
{
let
actor
=
this
.
selectedValue
;
let
line
=
this
.
DebuggerView
.
editor
.
getCursor
(
)
.
line
+
1
;
let
location
=
{
actor
:
actor
line
:
line
}
;
this
.
highlightBreakpoint
(
location
{
noEditorUpdate
:
true
}
)
;
}
unhighlightBreakpoint
:
function
(
)
{
this
.
_hideConditionalPopup
(
)
;
this
.
_unselectBreakpoint
(
)
;
}
showBreakpointConditionThrownMessage
:
function
(
aLocation
aMessage
=
"
"
)
{
let
breakpointItem
=
this
.
_getBreakpoint
(
getBreakpoint
(
this
.
getState
(
)
aLocation
)
)
;
if
(
!
breakpointItem
)
{
return
;
}
let
attachment
=
breakpointItem
.
attachment
;
attachment
.
view
.
container
.
classList
.
add
(
"
dbg
-
breakpoint
-
condition
-
thrown
"
)
;
attachment
.
view
.
message
.
setAttribute
(
"
value
"
aMessage
)
;
}
updateToolbarButtonsState
:
function
(
source
)
{
if
(
source
.
isBlackBoxed
)
{
this
.
_blackBoxButton
.
setAttribute
(
"
checked
"
true
)
;
this
.
_prettyPrintButton
.
setAttribute
(
"
checked
"
true
)
;
}
else
{
this
.
_blackBoxButton
.
removeAttribute
(
"
checked
"
)
;
this
.
_prettyPrintButton
.
removeAttribute
(
"
checked
"
)
;
}
if
(
source
.
isPrettyPrinted
)
{
this
.
_prettyPrintButton
.
setAttribute
(
"
checked
"
true
)
;
}
else
{
this
.
_prettyPrintButton
.
removeAttribute
(
"
checked
"
)
;
}
}
togglePrettyPrint
:
function
(
)
{
if
(
this
.
_prettyPrintButton
.
hasAttribute
(
"
disabled
"
)
)
{
return
;
}
this
.
DebuggerView
.
showProgressBar
(
)
;
const
source
=
getSelectedSource
(
this
.
getState
(
)
)
;
const
sourceClient
=
gThreadClient
.
source
(
source
)
;
const
shouldPrettyPrint
=
!
source
.
isPrettyPrinted
;
if
(
shouldPrettyPrint
)
{
this
.
_prettyPrintButton
.
setAttribute
(
"
checked
"
true
)
;
}
else
{
this
.
_prettyPrintButton
.
removeAttribute
(
"
checked
"
)
;
}
this
.
actions
.
togglePrettyPrint
(
source
)
;
}
toggleBlackBoxing
:
Task
.
async
(
function
*
(
)
{
const
source
=
getSelectedSource
(
this
.
getState
(
)
)
;
const
shouldBlackBox
=
!
source
.
isBlackBoxed
;
if
(
shouldBlackBox
)
{
this
.
_prettyPrintButton
.
setAttribute
(
"
disabled
"
true
)
;
this
.
_blackBoxButton
.
setAttribute
(
"
checked
"
true
)
;
}
else
{
this
.
_prettyPrintButton
.
removeAttribute
(
"
disabled
"
)
;
this
.
_blackBoxButton
.
removeAttribute
(
"
checked
"
)
;
}
this
.
actions
.
blackbox
(
source
shouldBlackBox
)
;
}
)
renderBlackBoxed
:
function
(
source
)
{
const
sourceItem
=
this
.
getItemByValue
(
source
.
actor
)
;
sourceItem
.
prebuiltNode
.
classList
.
toggle
(
"
black
-
boxed
"
source
.
isBlackBoxed
)
;
if
(
getSelectedSource
(
this
.
getState
(
)
)
.
actor
=
=
=
source
.
actor
)
{
this
.
updateToolbarButtonsState
(
source
)
;
}
}
toggleBreakpoints
:
function
(
)
{
let
breakpoints
=
getBreakpoints
(
this
.
getState
(
)
)
;
let
hasBreakpoints
=
breakpoints
.
length
>
0
;
let
hasEnabledBreakpoints
=
breakpoints
.
some
(
bp
=
>
!
bp
.
disabled
)
;
if
(
hasBreakpoints
&
&
hasEnabledBreakpoints
)
{
this
.
_toggleBreakpointsButton
.
setAttribute
(
"
checked
"
true
)
;
this
.
_onDisableAll
(
)
;
}
else
{
this
.
_toggleBreakpointsButton
.
removeAttribute
(
"
checked
"
)
;
this
.
_onEnableAll
(
)
;
}
}
hidePrettyPrinting
:
function
(
)
{
this
.
_prettyPrintButton
.
style
.
display
=
"
none
"
;
if
(
this
.
_blackBoxButton
.
style
.
display
=
=
=
"
none
"
)
{
let
sep
=
document
.
querySelector
(
"
#
sources
-
toolbar
.
devtools
-
separator
"
)
;
sep
.
style
.
display
=
"
none
"
;
}
}
hideBlackBoxing
:
function
(
)
{
this
.
_blackBoxButton
.
style
.
display
=
"
none
"
;
if
(
this
.
_prettyPrintButton
.
style
.
display
=
=
=
"
none
"
)
{
let
sep
=
document
.
querySelector
(
"
#
sources
-
toolbar
.
devtools
-
separator
"
)
;
sep
.
style
.
display
=
"
none
"
;
}
}
getDisplayURL
:
function
(
source
)
{
if
(
!
source
.
url
)
{
return
this
.
getItemByValue
(
source
.
actor
)
.
attachment
.
label
;
}
return
NetworkHelper
.
convertToUnicode
(
unescape
(
source
.
url
)
)
;
}
_selectBreakpoint
:
function
(
bp
)
{
if
(
this
.
_selectedBreakpoint
=
=
=
bp
)
{
return
;
}
this
.
_unselectBreakpoint
(
)
;
this
.
_selectedBreakpoint
=
bp
;
const
item
=
this
.
_getBreakpoint
(
bp
)
;
item
.
target
.
classList
.
add
(
"
selected
"
)
;
this
.
widget
.
ensureElementIsVisible
(
item
.
target
)
;
}
_unselectBreakpoint
:
function
(
)
{
if
(
!
this
.
_selectedBreakpoint
)
{
return
;
}
const
item
=
this
.
_getBreakpoint
(
this
.
_selectedBreakpoint
)
;
item
.
target
.
classList
.
remove
(
"
selected
"
)
;
this
.
_selectedBreakpoint
=
null
;
}
_openConditionalPopup
:
function
(
)
{
let
breakpointItem
=
this
.
_getBreakpoint
(
this
.
_selectedBreakpoint
)
;
let
attachment
=
breakpointItem
.
attachment
;
let
bp
=
getBreakpoint
(
this
.
getState
(
)
attachment
)
;
let
expr
=
(
bp
?
(
bp
.
condition
|
|
"
"
)
:
"
"
)
;
let
cbPanel
=
this
.
_cbPanel
;
this
.
_cbTextbox
.
value
=
expr
;
function
openPopup
(
)
{
cbPanel
.
hidden
=
false
;
cbPanel
.
openPopup
(
breakpointItem
.
attachment
.
view
.
lineNumber
BREAKPOINT_CONDITIONAL_POPUP_POSITION
BREAKPOINT_CONDITIONAL_POPUP_OFFSET_X
BREAKPOINT_CONDITIONAL_POPUP_OFFSET_Y
)
;
cbPanel
.
removeEventListener
(
"
popuphidden
"
openPopup
)
;
}
if
(
!
this
.
_cbPanel
.
hidden
)
{
this
.
_cbPanel
.
addEventListener
(
"
popuphidden
"
openPopup
)
;
}
else
{
openPopup
(
)
;
}
}
_hideConditionalPopup
:
function
(
)
{
if
(
this
.
_cbPanel
.
hidePopup
)
{
this
.
_cbPanel
.
hidePopup
(
)
;
}
}
_createBreakpointView
:
function
(
aOptions
)
{
let
{
location
disabled
text
message
isWasm
}
=
aOptions
;
let
identifier
=
makeLocationId
(
location
)
;
let
checkbox
=
document
.
createElement
(
"
checkbox
"
)
;
if
(
!
disabled
)
{
checkbox
.
setAttribute
(
"
checked
"
true
)
;
}
checkbox
.
className
=
"
dbg
-
breakpoint
-
checkbox
"
;
let
lineNumberNode
=
document
.
createElement
(
"
label
"
)
;
lineNumberNode
.
className
=
"
plain
dbg
-
breakpoint
-
line
"
;
let
lineNumberStr
=
!
isWasm
?
location
.
line
.
toString
(
)
:
location
.
line
.
toString
(
16
)
.
toUpperCase
(
)
;
lineNumberNode
.
setAttribute
(
"
value
"
lineNumberStr
)
;
let
lineTextNode
=
document
.
createElement
(
"
label
"
)
;
lineTextNode
.
className
=
"
plain
dbg
-
breakpoint
-
text
"
;
lineTextNode
.
setAttribute
(
"
value
"
text
)
;
lineTextNode
.
setAttribute
(
"
crop
"
"
end
"
)
;
lineTextNode
.
setAttribute
(
"
flex
"
"
1
"
)
;
let
tooltip
=
text
?
text
.
substr
(
0
BREAKPOINT_LINE_TOOLTIP_MAX_LENGTH
)
:
"
"
;
lineTextNode
.
setAttribute
(
"
tooltiptext
"
tooltip
)
;
let
thrownNode
=
document
.
createElement
(
"
label
"
)
;
thrownNode
.
className
=
"
plain
dbg
-
breakpoint
-
condition
-
thrown
-
message
dbg
-
breakpoint
-
text
"
;
thrownNode
.
setAttribute
(
"
value
"
message
)
;
thrownNode
.
setAttribute
(
"
crop
"
"
end
"
)
;
thrownNode
.
setAttribute
(
"
flex
"
"
1
"
)
;
let
bpLineContainer
=
document
.
createElement
(
"
hbox
"
)
;
bpLineContainer
.
className
=
"
plain
dbg
-
breakpoint
-
line
-
container
"
;
bpLineContainer
.
setAttribute
(
"
flex
"
"
1
"
)
;
bpLineContainer
.
appendChild
(
lineNumberNode
)
;
bpLineContainer
.
appendChild
(
lineTextNode
)
;
let
bpDetailContainer
=
document
.
createElement
(
"
vbox
"
)
;
bpDetailContainer
.
className
=
"
plain
dbg
-
breakpoint
-
detail
-
container
"
;
bpDetailContainer
.
setAttribute
(
"
flex
"
"
1
"
)
;
bpDetailContainer
.
appendChild
(
bpLineContainer
)
;
bpDetailContainer
.
appendChild
(
thrownNode
)
;
let
container
=
document
.
createElement
(
"
hbox
"
)
;
container
.
id
=
"
breakpoint
-
"
+
identifier
;
container
.
className
=
"
dbg
-
breakpoint
side
-
menu
-
widget
-
item
-
other
"
;
container
.
classList
.
add
(
"
devtools
-
monospace
"
)
;
container
.
setAttribute
(
"
align
"
"
center
"
)
;
container
.
setAttribute
(
"
flex
"
"
1
"
)
;
container
.
addEventListener
(
"
click
"
this
.
_onBreakpointClick
)
;
checkbox
.
addEventListener
(
"
click
"
this
.
_onBreakpointCheckboxClick
)
;
container
.
appendChild
(
checkbox
)
;
container
.
appendChild
(
bpDetailContainer
)
;
return
{
container
:
container
checkbox
:
checkbox
lineNumber
:
lineNumberNode
lineText
:
lineTextNode
message
:
thrownNode
}
;
}
_createContextMenu
:
function
(
aOptions
)
{
let
{
location
disabled
}
=
aOptions
;
let
identifier
=
makeLocationId
(
location
)
;
let
commandset
=
document
.
createElement
(
"
commandset
"
)
;
let
menupopup
=
document
.
createElement
(
"
menupopup
"
)
;
commandset
.
id
=
"
bp
-
cSet
-
"
+
identifier
;
menupopup
.
id
=
"
bp
-
mPop
-
"
+
identifier
;
createMenuItem
.
call
(
this
"
enableSelf
"
!
disabled
)
;
createMenuItem
.
call
(
this
"
disableSelf
"
disabled
)
;
createMenuItem
.
call
(
this
"
deleteSelf
"
)
;
createMenuSeparator
(
)
;
createMenuItem
.
call
(
this
"
setConditional
"
)
;
createMenuSeparator
(
)
;
createMenuItem
.
call
(
this
"
enableOthers
"
)
;
createMenuItem
.
call
(
this
"
disableOthers
"
)
;
createMenuItem
.
call
(
this
"
deleteOthers
"
)
;
createMenuSeparator
(
)
;
createMenuItem
.
call
(
this
"
enableAll
"
)
;
createMenuItem
.
call
(
this
"
disableAll
"
)
;
createMenuSeparator
(
)
;
createMenuItem
.
call
(
this
"
deleteAll
"
)
;
this
.
_popupset
.
appendChild
(
menupopup
)
;
this
.
_commandset
.
appendChild
(
commandset
)
;
return
{
commandsetId
:
commandset
.
id
menupopupId
:
menupopup
.
id
}
;
function
createMenuItem
(
aName
aHiddenFlag
)
{
let
menuitem
=
document
.
createElement
(
"
menuitem
"
)
;
let
command
=
document
.
createElement
(
"
command
"
)
;
let
prefix
=
"
bp
-
cMenu
-
"
;
let
commandId
=
prefix
+
aName
+
"
-
"
+
identifier
+
"
-
command
"
;
let
menuitemId
=
prefix
+
aName
+
"
-
"
+
identifier
+
"
-
menuitem
"
;
let
label
=
L10N
.
getStr
(
"
breakpointMenuItem
.
"
+
aName
)
;
let
func
=
"
_on
"
+
aName
.
charAt
(
0
)
.
toUpperCase
(
)
+
aName
.
slice
(
1
)
;
command
.
id
=
commandId
;
command
.
setAttribute
(
"
label
"
label
)
;
command
.
addEventListener
(
"
command
"
(
)
=
>
this
[
func
]
(
location
)
)
;
menuitem
.
id
=
menuitemId
;
menuitem
.
setAttribute
(
"
command
"
commandId
)
;
aHiddenFlag
&
&
menuitem
.
setAttribute
(
"
hidden
"
"
true
"
)
;
commandset
.
appendChild
(
command
)
;
menupopup
.
appendChild
(
menuitem
)
;
}
function
createMenuSeparator
(
)
{
let
menuseparator
=
document
.
createElement
(
"
menuseparator
"
)
;
menupopup
.
appendChild
(
menuseparator
)
;
}
}
_onCopyUrlCommand
:
function
(
)
{
let
selected
=
this
.
selectedItem
&
&
this
.
selectedItem
.
attachment
;
if
(
!
selected
)
{
return
;
}
clipboardHelper
.
copyString
(
selected
.
source
.
url
)
;
}
_onNewTabCommand
:
function
(
)
{
let
win
=
Services
.
wm
.
getMostRecentWindow
(
gDevTools
.
chromeWindowType
)
;
let
selected
=
this
.
selectedItem
.
attachment
;
win
.
openUILinkIn
(
selected
.
source
.
url
"
tab
"
{
relatedToCurrent
:
true
}
)
;
}
_onBreakpointRemoved
:
function
(
aItem
)
{
dumpn
(
"
Finalizing
breakpoint
item
:
"
+
aItem
.
stringify
(
)
)
;
let
contextMenu
=
aItem
.
attachment
.
popup
;
document
.
getElementById
(
contextMenu
.
commandsetId
)
.
remove
(
)
;
document
.
getElementById
(
contextMenu
.
menupopupId
)
.
remove
(
)
;
}
_onMouseDown
:
function
(
e
)
{
this
.
hideNoResultsTooltip
(
)
;
if
(
!
e
.
metaKey
)
{
return
;
}
let
editor
=
this
.
DebuggerView
.
editor
;
let
identifier
=
this
.
_findIdentifier
(
e
.
clientX
e
.
clientY
)
;
if
(
!
identifier
)
{
return
;
}
let
foundDefinitions
=
this
.
_getFunctionDefinitions
(
identifier
)
;
if
(
!
foundDefinitions
|
|
!
foundDefinitions
.
definitions
)
{
return
;
}
this
.
_showFunctionDefinitionResults
(
identifier
foundDefinitions
.
definitions
editor
)
;
}
_findDefinition
:
function
(
parsedSource
aName
)
{
let
functionDefinitions
=
parsedSource
.
getNamedFunctionDefinitions
(
aName
)
;
let
resultList
=
[
]
;
if
(
!
functionDefinitions
|
|
!
functionDefinitions
.
length
|
|
!
functionDefinitions
[
0
]
.
length
)
{
return
{
definitions
:
resultList
}
;
}
for
(
let
i
=
0
;
i
<
functionDefinitions
.
length
;
i
+
+
)
{
let
functionDefinition
=
{
source
:
functionDefinitions
[
i
]
.
sourceUrl
startLine
:
functionDefinitions
[
i
]
[
0
]
.
functionLocation
.
start
.
line
startColumn
:
functionDefinitions
[
i
]
[
0
]
.
functionLocation
.
start
.
column
name
:
functionDefinitions
[
i
]
[
0
]
.
functionName
}
;
resultList
.
push
(
functionDefinition
)
;
}
return
{
definitions
:
resultList
}
;
}
_findIdentifier
:
function
(
x
y
)
{
let
parsedSource
=
SourceUtils
.
parseSource
(
this
.
DebuggerView
this
.
Parser
)
;
let
identifierInfo
=
SourceUtils
.
findIdentifier
(
this
.
DebuggerView
.
editor
parsedSource
x
y
)
;
if
(
!
identifierInfo
)
{
return
;
}
return
identifierInfo
;
}
_onEditorCursorActivity
:
function
(
e
)
{
let
editor
=
this
.
DebuggerView
.
editor
;
let
start
=
editor
.
getCursor
(
"
start
"
)
.
line
+
1
;
let
end
=
editor
.
getCursor
(
)
.
line
+
1
;
let
source
=
getSelectedSource
(
this
.
getState
(
)
)
;
if
(
source
)
{
let
location
=
{
actor
:
source
.
actor
line
:
start
}
;
if
(
getBreakpoint
(
this
.
getState
(
)
location
)
&
&
start
=
=
end
)
{
this
.
highlightBreakpoint
(
location
{
noEditorUpdate
:
true
}
)
;
}
else
{
this
.
unhighlightBreakpoint
(
)
;
}
}
}
_showFunctionDefinitionResults
:
function
(
aHoveredFunction
aDefinitionList
aEditor
)
{
let
definitions
=
aDefinitionList
;
let
hoveredFunction
=
aHoveredFunction
;
if
(
definitions
.
length
=
=
0
)
{
this
.
_noResultsFoundToolTip
.
setTextContent
(
{
messages
:
[
L10N
.
getStr
(
"
noMatchingStringsText
"
)
]
}
)
;
this
.
_markedIdentifier
=
aEditor
.
markText
(
{
line
:
hoveredFunction
.
location
.
start
.
line
-
1
ch
:
hoveredFunction
.
location
.
start
.
column
}
{
line
:
hoveredFunction
.
location
.
end
.
line
-
1
ch
:
hoveredFunction
.
location
.
end
.
column
}
)
;
this
.
_noResultsFoundToolTip
.
show
(
this
.
_markedIdentifier
.
anchor
)
;
}
else
if
(
definitions
.
length
=
=
1
)
{
this
.
DebuggerView
.
setEditorLocation
(
definitions
[
0
]
.
source
definitions
[
0
]
.
startLine
)
;
}
else
{
this
.
DebuggerView
.
setEditorLocation
(
definitions
[
0
]
.
source
definitions
[
0
]
.
startLine
)
;
}
}
hideNoResultsTooltip
:
function
(
)
{
this
.
_noResultsFoundToolTip
.
hide
(
)
;
if
(
this
.
_markedIdentifier
)
{
this
.
_markedIdentifier
.
clear
(
)
;
this
.
_markedIdentifier
=
null
;
}
}
_getFunctionDefinitions
:
function
(
aIdentifierInfo
)
{
let
parsedSource
=
SourceUtils
.
parseSource
(
this
.
DebuggerView
this
.
Parser
)
;
let
definition_info
=
this
.
_findDefinition
(
parsedSource
aIdentifierInfo
.
name
)
;
if
(
!
definition_info
)
{
return
;
}
return
definition_info
;
}
_onSourceSelect
:
function
(
{
detail
:
sourceItem
}
)
{
if
(
!
sourceItem
)
{
return
;
}
const
{
source
}
=
sourceItem
.
attachment
;
this
.
actions
.
selectSource
(
source
)
;
}
renderSourceSelected
:
function
(
source
)
{
if
(
source
.
url
)
{
this
.
_preferredSourceURL
=
source
.
url
;
}
this
.
updateToolbarButtonsState
(
source
)
;
this
.
_selectItem
(
this
.
getItemByValue
(
source
.
actor
)
)
;
}
_onStopBlackBoxing
:
Task
.
async
(
function
*
(
)
{
this
.
actions
.
blackbox
(
getSelectedSource
(
this
.
getState
(
)
)
false
)
;
}
)
_onEditorContextMenuOpen
:
function
(
message
ev
popup
)
{
let
actor
=
this
.
selectedValue
;
let
line
=
this
.
DebuggerView
.
editor
.
getCursor
(
)
.
line
+
1
;
let
location
=
{
actor
line
}
;
let
breakpoint
=
getBreakpoint
(
this
.
getState
(
)
location
)
;
let
addConditionalBreakpointMenuItem
=
popup
.
querySelector
(
"
#
se
-
dbg
-
cMenu
-
addConditionalBreakpoint
"
)
;
let
editConditionalBreakpointMenuItem
=
popup
.
querySelector
(
"
#
se
-
dbg
-
cMenu
-
editConditionalBreakpoint
"
)
;
if
(
breakpoint
&
&
!
!
breakpoint
.
condition
)
{
editConditionalBreakpointMenuItem
.
removeAttribute
(
"
hidden
"
)
;
addConditionalBreakpointMenuItem
.
setAttribute
(
"
hidden
"
true
)
;
}
else
{
addConditionalBreakpointMenuItem
.
removeAttribute
(
"
hidden
"
)
;
editConditionalBreakpointMenuItem
.
setAttribute
(
"
hidden
"
true
)
;
}
}
_onBreakpointClick
:
function
(
e
)
{
let
sourceItem
=
this
.
getItemForElement
(
e
.
target
)
;
let
breakpointItem
=
this
.
getItemForElement
.
call
(
sourceItem
e
.
target
)
;
let
attachment
=
breakpointItem
.
attachment
;
let
bp
=
getBreakpoint
(
this
.
getState
(
)
attachment
)
;
if
(
bp
)
{
this
.
highlightBreakpoint
(
bp
.
location
{
openPopup
:
bp
.
condition
&
&
e
.
button
=
=
0
}
)
;
}
else
{
this
.
highlightBreakpoint
(
bp
.
location
)
;
}
}
_onBreakpointCheckboxClick
:
function
(
e
)
{
let
sourceItem
=
this
.
getItemForElement
(
e
.
target
)
;
let
breakpointItem
=
this
.
getItemForElement
.
call
(
sourceItem
e
.
target
)
;
let
bp
=
getBreakpoint
(
this
.
getState
(
)
breakpointItem
.
attachment
)
;
if
(
bp
.
disabled
)
{
this
.
actions
.
enableBreakpoint
(
bp
.
location
)
;
}
else
{
this
.
actions
.
disableBreakpoint
(
bp
.
location
)
;
}
e
.
preventDefault
(
)
;
e
.
stopPropagation
(
)
;
}
_onConditionalPopupShowing
:
function
(
)
{
this
.
_conditionalPopupVisible
=
true
;
}
_onConditionalPopupShown
:
function
(
)
{
this
.
_cbTextbox
.
focus
(
)
;
this
.
_cbTextbox
.
select
(
)
;
window
.
emit
(
EVENTS
.
CONDITIONAL_BREAKPOINT_POPUP_SHOWN
)
;
}
_onConditionalPopupHiding
:
function
(
)
{
this
.
_conditionalPopupVisible
=
false
;
let
bp
=
this
.
_selectedBreakpoint
;
if
(
bp
)
{
let
condition
=
this
.
_cbTextbox
.
value
;
this
.
actions
.
setBreakpointCondition
(
bp
.
location
condition
)
;
}
}
_onConditionalPopupHidden
:
function
(
)
{
this
.
_cbPanel
.
hidden
=
true
;
window
.
emit
(
EVENTS
.
CONDITIONAL_BREAKPOINT_POPUP_HIDDEN
)
;
}
_onConditionalTextboxKeyPress
:
function
(
e
)
{
if
(
e
.
keyCode
=
=
KeyCodes
.
DOM_VK_RETURN
)
{
this
.
_hideConditionalPopup
(
)
;
}
}
_onCmdAddBreakpoint
:
function
(
e
)
{
let
actor
=
this
.
selectedValue
;
let
line
=
(
this
.
DebuggerView
.
clickedLine
?
this
.
DebuggerView
.
clickedLine
+
1
:
this
.
DebuggerView
.
editor
.
getCursor
(
)
.
line
+
1
)
;
let
location
=
{
actor
line
}
;
let
bp
=
getBreakpoint
(
this
.
getState
(
)
location
)
;
if
(
bp
)
{
this
.
actions
.
removeBreakpoint
(
bp
.
location
)
;
}
else
{
this
.
actions
.
addBreakpoint
(
location
)
;
}
}
_onCmdAddConditionalBreakpoint
:
function
(
e
)
{
let
actor
=
this
.
selectedValue
;
let
line
=
(
this
.
DebuggerView
.
clickedLine
?
this
.
DebuggerView
.
clickedLine
+
1
:
this
.
DebuggerView
.
editor
.
getCursor
(
)
.
line
+
1
)
;
let
location
=
{
actor
line
}
;
let
bp
=
getBreakpoint
(
this
.
getState
(
)
location
)
;
if
(
bp
)
{
this
.
highlightBreakpoint
(
bp
.
location
{
openPopup
:
true
}
)
;
}
else
{
this
.
actions
.
addBreakpoint
(
location
"
"
)
;
}
}
getOtherBreakpoints
:
function
(
location
)
{
const
bps
=
getBreakpoints
(
this
.
getState
(
)
)
;
if
(
location
)
{
return
bps
.
filter
(
bp
=
>
{
return
(
bp
.
location
.
actor
!
=
=
location
.
actor
|
|
bp
.
location
.
line
!
=
=
location
.
line
)
;
}
)
;
}
return
bps
;
}
_onSetConditional
:
function
(
aLocation
)
{
this
.
highlightBreakpoint
(
aLocation
{
openPopup
:
true
}
)
;
}
_onEnableSelf
:
function
(
aLocation
)
{
this
.
actions
.
enableBreakpoint
(
aLocation
)
;
}
_onDisableSelf
:
function
(
aLocation
)
{
const
bp
=
getBreakpoint
(
this
.
getState
(
)
aLocation
)
;
if
(
!
bp
.
disabled
)
{
this
.
actions
.
disableBreakpoint
(
aLocation
)
;
}
}
_onDeleteSelf
:
function
(
aLocation
)
{
this
.
actions
.
removeBreakpoint
(
aLocation
)
;
}
_onEnableOthers
:
function
(
aLocation
)
{
let
other
=
this
.
getOtherBreakpoints
(
aLocation
)
;
other
.
forEach
(
bp
=
>
this
.
_onEnableSelf
(
bp
.
location
)
)
;
}
_onDisableOthers
:
function
(
aLocation
)
{
let
other
=
this
.
getOtherBreakpoints
(
aLocation
)
;
other
.
forEach
(
bp
=
>
this
.
_onDisableSelf
(
bp
.
location
)
)
;
}
_onDeleteOthers
:
function
(
aLocation
)
{
let
other
=
this
.
getOtherBreakpoints
(
aLocation
)
;
other
.
forEach
(
bp
=
>
this
.
_onDeleteSelf
(
bp
.
location
)
)
;
}
_onEnableAll
:
function
(
)
{
this
.
_onEnableOthers
(
undefined
)
;
}
_onDisableAll
:
function
(
)
{
this
.
_onDisableOthers
(
undefined
)
;
}
_onDeleteAll
:
function
(
)
{
this
.
_onDeleteOthers
(
undefined
)
;
}
_commandset
:
null
_popupset
:
null
_cmPopup
:
null
_cbPanel
:
null
_cbTextbox
:
null
_selectedBreakpointItem
:
null
_conditionalPopupVisible
:
false
_noResultsFoundToolTip
:
null
_markedIdentifier
:
null
_selectedBreakpoint
:
null
_conditionalPopupVisible
:
false
}
)
;
module
.
exports
=
SourcesView
;
