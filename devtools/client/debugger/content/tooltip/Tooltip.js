"
use
strict
"
;
const
defer
=
require
(
"
devtools
/
shared
/
defer
"
)
;
const
EventEmitter
=
require
(
"
devtools
/
shared
/
event
-
emitter
"
)
;
const
{
KeyCodes
}
=
require
(
"
devtools
/
client
/
shared
/
keycodes
"
)
;
const
{
TooltipToggle
}
=
require
(
"
devtools
/
client
/
shared
/
widgets
/
tooltip
/
TooltipToggle
"
)
;
const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
ESCAPE_KEYCODE
=
KeyCodes
.
DOM_VK_ESCAPE
;
const
POPUP_EVENTS
=
[
"
shown
"
"
hidden
"
"
showing
"
"
hiding
"
]
;
class
Tooltip
{
constructor
(
doc
{
consumeOutsideClick
=
false
closeOnKeys
=
[
ESCAPE_KEYCODE
]
noAutoFocus
=
true
closeOnEvents
=
[
]
}
=
{
}
)
{
EventEmitter
.
decorate
(
this
)
;
this
.
defaultPosition
=
"
before_start
"
;
this
.
defaultOffsetX
=
0
;
this
.
defaultOffsetY
=
0
;
this
.
doc
=
doc
;
this
.
consumeOutsideClick
=
consumeOutsideClick
;
this
.
closeOnKeys
=
closeOnKeys
;
this
.
noAutoFocus
=
noAutoFocus
;
this
.
closeOnEvents
=
closeOnEvents
;
this
.
panel
=
this
.
_createPanel
(
)
;
this
.
_toggle
=
new
TooltipToggle
(
this
)
;
this
.
startTogglingOnHover
=
this
.
_toggle
.
start
.
bind
(
this
.
_toggle
)
;
this
.
stopTogglingOnHover
=
this
.
_toggle
.
stop
.
bind
(
this
.
_toggle
)
;
for
(
const
eventName
of
POPUP_EVENTS
)
{
this
[
"
_onPopup
"
+
eventName
]
=
(
name
=
>
{
return
e
=
>
{
if
(
e
.
target
=
=
=
this
.
panel
)
{
this
.
emit
(
name
)
;
}
}
;
}
)
(
eventName
)
;
this
.
panel
.
addEventListener
(
"
popup
"
+
eventName
this
[
"
_onPopup
"
+
eventName
]
)
;
}
const
win
=
this
.
doc
.
querySelector
(
"
window
"
)
;
this
.
_onKeyDown
=
event
=
>
{
if
(
this
.
panel
.
hidden
)
{
return
;
}
this
.
emit
(
"
keydown
"
event
.
keyCode
)
;
if
(
this
.
closeOnKeys
.
includes
(
event
.
keyCode
)
&
&
this
.
isShown
(
)
)
{
event
.
stopPropagation
(
)
;
this
.
hide
(
)
;
}
}
;
win
.
addEventListener
(
"
keydown
"
this
.
_onKeyDown
)
;
this
.
hide
=
this
.
hide
.
bind
(
this
)
;
for
(
const
{
emitter
event
useCapture
}
of
this
.
closeOnEvents
)
{
for
(
const
add
of
[
"
addEventListener
"
"
on
"
]
)
{
if
(
add
in
emitter
)
{
emitter
[
add
]
(
event
this
.
hide
useCapture
)
;
break
;
}
}
}
}
show
(
anchor
position
=
this
.
defaultPosition
x
=
this
.
defaultOffsetX
y
=
this
.
defaultOffsetY
)
{
this
.
panel
.
hidden
=
false
;
this
.
panel
.
openPopup
(
anchor
position
x
y
)
;
}
hide
(
)
{
this
.
panel
.
hidden
=
true
;
this
.
panel
.
hidePopup
(
)
;
}
isShown
(
)
{
return
this
.
panel
&
&
this
.
panel
.
state
!
=
=
"
closed
"
&
&
this
.
panel
.
state
!
=
=
"
hiding
"
;
}
setSize
(
width
height
)
{
this
.
panel
.
sizeTo
(
width
height
)
;
}
empty
(
)
{
while
(
this
.
panel
.
hasChildNodes
(
)
)
{
this
.
panel
.
firstChild
.
remove
(
)
;
}
}
isHidden
(
)
{
return
this
.
panel
.
state
=
=
"
closed
"
|
|
this
.
panel
.
state
=
=
"
hiding
"
;
}
isEmpty
(
)
{
return
!
this
.
panel
.
hasChildNodes
(
)
;
}
destroy
(
)
{
this
.
hide
(
)
;
for
(
const
eventName
of
POPUP_EVENTS
)
{
this
.
panel
.
removeEventListener
(
"
popup
"
+
eventName
this
[
"
_onPopup
"
+
eventName
]
)
;
}
const
win
=
this
.
doc
.
querySelector
(
"
window
"
)
;
win
.
removeEventListener
(
"
keydown
"
this
.
_onKeyDown
)
;
for
(
const
{
emitter
event
useCapture
}
of
this
.
closeOnEvents
)
{
for
(
const
remove
of
[
"
removeEventListener
"
"
off
"
]
)
{
if
(
remove
in
emitter
)
{
emitter
[
remove
]
(
event
this
.
hide
useCapture
)
;
break
;
}
}
}
this
.
content
=
null
;
this
.
_toggle
.
destroy
(
)
;
this
.
doc
=
null
;
this
.
panel
.
remove
(
)
;
this
.
panel
=
null
;
}
get
container
(
)
{
return
this
.
panel
;
}
set
content
(
content
)
{
if
(
this
.
content
=
=
content
)
{
return
;
}
this
.
empty
(
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
"
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
-
no
-
min
-
height
"
)
;
this
.
panel
.
removeAttribute
(
"
clamped
-
dimensions
-
no
-
max
-
or
-
min
-
height
"
)
;
this
.
panel
.
removeAttribute
(
"
wide
"
)
;
if
(
content
)
{
this
.
panel
.
appendChild
(
content
)
;
}
}
get
content
(
)
{
return
this
.
panel
.
firstChild
;
}
setTextContent
(
{
messages
messagesClass
containerClass
}
extraButtons
=
[
]
)
{
messagesClass
=
messagesClass
|
|
"
default
-
tooltip
-
simple
-
text
-
colors
"
;
containerClass
=
containerClass
|
|
"
default
-
tooltip
-
simple
-
text
-
colors
"
;
const
vbox
=
this
.
doc
.
createXULElement
(
"
vbox
"
)
;
vbox
.
className
=
"
devtools
-
tooltip
-
simple
-
text
-
container
"
+
containerClass
;
vbox
.
setAttribute
(
"
flex
"
"
1
"
)
;
for
(
const
text
of
messages
)
{
const
description
=
this
.
doc
.
createXULElement
(
"
description
"
)
;
description
.
setAttribute
(
"
flex
"
"
1
"
)
;
description
.
className
=
"
devtools
-
tooltip
-
simple
-
text
"
+
messagesClass
;
description
.
textContent
=
text
;
vbox
.
appendChild
(
description
)
;
}
for
(
const
{
label
className
command
}
of
extraButtons
)
{
const
button
=
this
.
doc
.
createXULElement
(
"
button
"
)
;
button
.
className
=
className
;
button
.
setAttribute
(
"
label
"
label
)
;
button
.
addEventListener
(
"
command
"
command
)
;
vbox
.
appendChild
(
button
)
;
}
this
.
content
=
vbox
;
}
setIFrameContent
(
{
width
height
}
url
)
{
const
def
=
defer
(
)
;
const
iframe
=
this
.
doc
.
createElementNS
(
XHTML_NS
"
iframe
"
)
;
iframe
.
setAttribute
(
"
transparent
"
true
)
;
iframe
.
setAttribute
(
"
width
"
width
)
;
iframe
.
setAttribute
(
"
height
"
height
)
;
iframe
.
setAttribute
(
"
flex
"
"
1
"
)
;
iframe
.
setAttribute
(
"
tooltip
"
"
aHTMLTooltip
"
)
;
iframe
.
setAttribute
(
"
class
"
"
devtools
-
tooltip
-
iframe
"
)
;
function
onLoad
(
)
{
iframe
.
removeEventListener
(
"
load
"
onLoad
true
)
;
def
.
resolve
(
iframe
)
;
}
iframe
.
addEventListener
(
"
load
"
onLoad
true
)
;
iframe
.
setAttribute
(
"
src
"
url
)
;
this
.
content
=
iframe
;
return
def
.
promise
;
}
_createPanel
(
)
{
const
panel
=
this
.
doc
.
createXULElement
(
"
panel
"
)
;
panel
.
setAttribute
(
"
hidden
"
true
)
;
panel
.
setAttribute
(
"
ignorekeys
"
true
)
;
panel
.
setAttribute
(
"
animate
"
false
)
;
panel
.
setAttribute
(
"
consumeoutsideclicks
"
this
.
consumeOutsideClick
)
;
panel
.
setAttribute
(
"
noautofocus
"
this
.
noAutoFocus
)
;
panel
.
setAttribute
(
"
type
"
"
arrow
"
)
;
panel
.
setAttribute
(
"
level
"
"
top
"
)
;
panel
.
setAttribute
(
"
class
"
"
devtools
-
tooltip
theme
-
tooltip
-
panel
"
)
;
this
.
doc
.
querySelector
(
"
window
"
)
.
appendChild
(
panel
)
;
return
panel
;
}
}
module
.
exports
=
Tooltip
;
