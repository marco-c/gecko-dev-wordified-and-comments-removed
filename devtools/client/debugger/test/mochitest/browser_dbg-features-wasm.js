"
use
strict
"
;
add_task
(
async
function
(
)
{
const
tab
=
await
addTab
(
EXAMPLE_URL
+
"
doc
-
wasm
-
sourcemaps
.
html
"
)
;
const
toolbox
=
await
openToolboxForTab
(
tab
"
webconsole
"
)
;
await
reloadBrowser
(
)
;
await
toolbox
.
selectTool
(
"
jsdebugger
"
)
;
const
dbg
=
createDebuggerContext
(
toolbox
)
;
await
waitForSourcesInSourceTree
(
dbg
[
"
doc
-
wasm
-
sourcemaps
.
html
"
"
fib
.
wasm
"
]
)
;
is
(
dbg
.
selectors
.
getSourceCount
(
)
2
"
There
are
only
these
two
sources
"
)
;
const
source
=
findSource
(
dbg
"
fib
.
wasm
"
)
;
is
(
source
.
isWasm
true
"
The
original
source
is
flagged
as
Wasm
source
"
)
;
await
dbg
.
actions
.
selectLocation
(
createLocation
(
{
source
}
)
{
keepContext
:
false
}
)
;
is
(
getEditorContent
(
dbg
)
Please
refresh
to
debug
this
module
)
;
info
(
"
Reload
and
assert
that
WASM
files
are
then
debuggable
"
)
;
await
reload
(
dbg
"
doc
-
wasm
-
sourcemaps
.
html
"
"
fib
.
wasm
"
"
fib
.
c
"
)
;
info
(
"
After
reloading
original
file
lines
are
breakable
"
)
;
await
selectSource
(
dbg
"
fib
.
c
"
)
;
await
assertLineIsBreakable
(
dbg
source
.
url
14
true
)
;
await
waitForSourcesInSourceTree
(
dbg
[
"
doc
-
wasm
-
sourcemaps
.
html
"
"
fib
.
wasm
"
"
fib
.
c
"
]
)
;
is
(
dbg
.
selectors
.
getSourceCount
(
)
3
"
There
is
all
these
3
sources
"
)
;
const
breakpointLine
=
12
;
assertTextContentOnLine
(
dbg
breakpointLine
"
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
"
)
;
info
(
"
Register
and
trigger
a
breakpoint
from
the
original
source
in
C
"
)
;
await
addBreakpoint
(
dbg
"
fib
.
c
"
breakpointLine
)
;
invokeInTab
(
"
runWasm
"
)
;
await
waitForPausedInOriginalFileAndToggleMapScopes
(
dbg
)
;
await
assertPausedAtSourceAndLine
(
dbg
findSource
(
dbg
"
fib
.
c
"
)
.
id
breakpointLine
)
;
await
assertBreakpoint
(
dbg
breakpointLine
)
;
const
frames
=
dbg
.
selectors
.
getCurrentThreadFrames
(
)
;
const
generatedLine
=
frames
[
0
]
.
generatedLocation
.
line
;
assertFirstFrameTitleAndLocation
(
dbg
"
(
wasmcall
)
"
"
fib
.
c
"
)
;
await
removeBreakpoint
(
dbg
findSource
(
dbg
"
fib
.
c
"
)
.
id
breakpointLine
)
;
await
resume
(
dbg
)
;
info
(
"
Now
register
and
trigger
the
same
breakpoint
from
the
binary
source
file
"
)
;
const
binarySource
=
findSource
(
dbg
"
fib
.
wasm
"
)
;
const
virtualBinaryLine
=
0x11a
;
is
(
"
0x
"
+
virtualBinaryLine
.
toString
(
16
)
"
0x
"
+
generatedLine
.
toString
(
16
)
"
The
hardcoded
binary
line
(
0x
"
+
generatedLine
.
toString
(
16
)
+
"
)
matches
the
mapped
location
when
we
set
the
breakpoint
on
the
original
line
.
If
you
rebuilt
the
binary
you
may
just
need
to
update
the
virtualBinaryLine
variable
to
the
new
location
.
"
)
;
const
binaryLine
=
wasmOffsetToLine
(
dbg
binarySource
.
id
virtualBinaryLine
)
;
await
dbg
.
actions
.
selectLocation
(
createLocation
(
{
source
:
binarySource
}
)
{
keepContext
:
false
}
)
;
await
scrollEditorIntoView
(
dbg
binaryLine
0
)
;
await
assertLineIsBreakable
(
dbg
binarySource
.
url
binaryLine
true
)
;
await
addBreakpoint
(
dbg
binarySource
virtualBinaryLine
)
;
invokeInTab
(
"
runWasm
"
)
;
await
waitForPaused
(
dbg
)
;
await
assertPausedAtSourceAndLine
(
dbg
binarySource
.
id
virtualBinaryLine
)
;
info
(
"
Manually
switch
to
original
C
source
as
we
set
the
breakpoint
on
binary
source
we
paused
on
it
"
)
;
await
dbg
.
actions
.
jumpToMappedSelectedLocation
(
)
;
await
waitForPausedInOriginalFileAndToggleMapScopes
(
dbg
)
;
await
assertPausedAtSourceAndLine
(
dbg
findSource
(
dbg
"
fib
.
c
"
)
.
id
breakpointLine
)
;
info
(
"
Reselect
the
binary
source
"
)
;
await
dbg
.
actions
.
selectLocation
(
createLocation
(
{
source
:
binarySource
}
)
{
keepContext
:
false
}
)
;
assertFirstFrameTitleAndLocation
(
dbg
"
(
wasmcall
)
"
"
fib
.
wasm
"
)
;
await
assertBreakpoint
(
dbg
binaryLine
)
;
await
removeBreakpoint
(
dbg
binarySource
.
id
virtualBinaryLine
)
;
await
resume
(
dbg
)
;
}
)
;
function
assertFirstFrameTitleAndLocation
(
dbg
title
location
)
{
const
frames
=
findAllElements
(
dbg
"
frames
"
)
;
const
firstFrameTitle
=
frames
[
0
]
.
querySelector
(
"
.
title
"
)
.
textContent
;
is
(
firstFrameTitle
title
"
First
frame
title
is
the
expected
one
"
)
;
const
firstFrameLocation
=
frames
[
0
]
.
querySelector
(
"
.
location
"
)
.
textContent
;
is
(
firstFrameLocation
.
includes
(
location
)
true
First
frame
location
'
{
firstFrameLocation
}
'
includes
'
{
location
}
'
)
;
}
